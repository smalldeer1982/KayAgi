# [清华集训 2016] 组合数问题

## 题目描述

组合数 $C_n^m$ 表示的是从 $n$ 个物品中选出 $m$ 个物品的方案数。举个例子，从 $(1,2,3)$ 三个物品中选择两个物品可以有 $(1,2),(1,3),(2,3)$ 这三种选择方法。根据组合数的定义，我们可以给出计算组合数 $C_n^m$ 的一般公式：

$$C_n^m=\dfrac{n!}{m!(n-m)!}$$

其中 $n!=1×2×⋯×n$。（额外的，当 $n=0$ 时，$n!=1$）

小葱想知道如果给定 $n,m$ 和 $k$，对于所有的 $0≤i≤n,0≤j≤\min(i,m)$ 有多少对 $(i,j)$ 满足 $C^j_i$ 是 $k$ 的倍数。

答案对 $10^9+7$ 取模。

## 说明/提示

#### 样例 $1$ 解释

在所有情况中，只有 $C_{2}^{1}=2$ 是 $2$ 的倍数。

#### 限制与约定

对于 $20\%$ 的测试点，$1≤n,m≤100$；

对于另外 $15\%$ 的测试点，$n≤m$；

对于另外 $15\%$ 的测试点，$k=2$；

对于另外 $15\%$ 的测试点， $m\le10$；

对于 $100\%$ 的测试点， $1≤n,m≤10^{18}$，$1≤t,k≤100$，且 $k$ 是一个质数。

## 样例 #1

### 输入

```
1 2
3 3```

### 输出

```
1```

## 样例 #2

### 输入

```
2 5
4 5
6 7```

### 输出

```
0
7```

## 样例 #3

### 输入

```
3 23
23333333 23333333
233333333 233333333
2333333333 2333333333```

### 输出

```
851883128
959557926
680723120```

# 题解

## 作者：syksykCCC (赞：27)

发现 $n, m$ 都很大，正常求组合数没法做，而 $k$ 是一个质数，所以考虑使用 Lucas 定理：

$$ \binom{n}{m} \equiv \binom{\lfloor\frac{n}{k}\rfloor}{\lfloor\frac{m}{k}\rfloor} \times \binom{n \bmod k}{m \bmod k} \pmod{k} $$

上面那个式子显然是一个 $k$ 进制拆分的式子，如果把 $n,m$ 都写作 $k$ 进制的形式，$n$ 的第 $i$ 位（最低位为第一位）为 $bn_i$，$m$ 的第 $i$ 位为 $bm_i$，则有：

$$ \binom{n}{m} \equiv \prod_{i} \binom{bn_i}{bm_i} \pmod{k}$$

显然，如果 $\binom{n}{m}$ 是 $k$ 的倍数，那么它在模 $k$ 意义下肯定等于 $0$。观察上面这个连乘的式子，显然如果有一项为 $0$，结果就是 $0$。因为对于 $\forall i, 0 \le bn_i, bm_i < k$，那么 $\binom{bn_i}{bm_i} = 0$ 当且仅当 $bn_i < bm_i$。

所以，问题就转化为了：给定 $n, m$，求有多少组数对 $i, j$，满足 $1 \le i \le n, 1 \le j \le \min(i, m)$，且 $i, j$ 都写作 $k$ 进制形式至少有一位 $i$ 的数值比 $j$ 小。

于是可以设计出一个数位 dp，用 $f(cur, \text{ok, dif, fn, fm})$ 来表示当前处理到第 $cur$ 位，目前有没有出现某一位数值 $i<j$，目前 $i$ 与 $j$ 是不是出现了差异（也就是最高 $cur$ 位 $i, j$ 是不是完全相同），目前 $i$ 与 $n$ 是不是出现了差异，目前 $j$ 与 $m$ 是不是出现了差异。转移显然，为了方便使用记忆化搜索实现。

代码仅供参考。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL MOD = 1e9 + 7;
const int LOGN = 66;
LL k, n, m, bn[LOGN], bm[LOGN];
LL f[LOGN][2][2][2][2];
LL Solve(int cur, bool ok, bool dif, bool fn, bool fm)
{
	if(!cur) return ok;
	LL &res = f[cur][ok][dif][fn][fm];
	if(~res) return res;
	res = 0;
	int upn = fn ? k - 1 : bn[cur], upm = fm ? k - 1 : bm[cur];
	for(int i = 0; i <= upn; i++)
		for(int j = 0; (j <= i || dif) && j <= upm; j++)
			res = (res + Solve(cur - 1, ok | (i < j), dif | (i != j), fn | (i < upn), fm | (j < upm))) % MOD;
	return res;
}
int main()
{
	int t;
	scanf("%d %lld", &t, &k);
	while(t--)
	{
		scanf("%lld %lld", &n, &m);
		memset(f, -1, sizeof f);
		LL mx = max(n, m), len = 0;
		while(mx) mx /= k, len++;
		for(int i = 1; i <= len; i++) bn[i] = n % k, n /= k;
		for(int i = 1; i <= len; i++) bm[i] = m % k, m /= k;
		printf("%lld\n", Solve(len, false, false, false, false));
	}
	return 0;
}
```

---

## 作者：zac2010 (赞：5)

这道题的难点在于 $k|C_{i}^{j}$ 这个特殊限制。

由于 $n,m$ 的范围很大，再加上式子中有组合数，我们自然而然地想到了 $\text{lucas}$ 定理：
$$
C_{n}^{m}={C_{\lfloor\frac{n}{k}\rfloor}^{\lfloor\frac{m}{k}\rfloor}\times C_{n\%k}^{m\%k}}\pmod k
$$

不难发现这是一个 $k$ 进制下的形式。再由于 $k$ 是质数，所以最终 $k|C_{i}^{j}$ 当且仅当某一个 $C_{n\%k}^{m\%k}=0$。

考虑直接在 $k$ 进制下数位 $\text{DP}$。记 $f_{x,y,b1,b2,b3}$ 为当前从高到低考虑到了第 $x$ 位，前面那些位里是($y=1$)否($y=0$)已经有元素满足 $C_{n\%k}^{m\%k}=0$，$i$ 是($b1=1$)否($b1=0$)抵到上界，$j$ 是($b2=1$)否($b2=0$)抵到上界，$j$ 是 $b3=1$ 否 $b3=0$ 抵到 $i$ 的大小。

转移比较套路，这里不作赘述。

状态数 $O(\log k\times 2^4)$，单词转移复杂度为 $O(k^2)$，总时间复杂度为 $O(T\times \log k\times 2^4\times k^2)$，可以通过。

```cpp
#include <bits/stdc++.h>
#define FL(i, a, b) for(int i = (a); i <= (b); ++i)
#define FR(i, a, b) for(int i = (a); i >= (b); --i)
using namespace std;
typedef long long ll;
const int N = 66, K = 110, mod = 1e9 + 7;
int k, t, t2, a[N], b[N], C[K][K];
ll n, m, f[N][2][2][2][2];
ll F(int x, int y, int b1, int b2, int b3){
    if(!x) return y;
    if(~f[x][y][b1][b2][b3]) return f[x][y][b1][b2][b3];
    int rn = b1? a[x] : k - 1; ll s = 0;
    FL(i, 0, rn){
        int rm = min((b3? i : k - 1), (b2? b[x] : k - 1));
        FL(j, 0, rm){
            s += F(x - 1, (y || !C[i][j]), (b1 && i == a[x]), (b2 && j == b[x]), (b3 && i == j));
            s %= mod;
        }
    }
    return f[x][y][b1][b2][b3] = s;
}
void solve(){
    scanf("%lld%lld", &n, &m);
    memset(f, -1, sizeof(f)), t = t2 = 0;
    memset(a, 0, sizeof(a));
    memset(b, 0, sizeof(b));
    ll tmp = n;
    while(tmp) a[++t] = tmp % k, tmp /= k;
    tmp = m;
    while(tmp) b[++t2] = tmp % k, tmp /= k;
    printf("%lld\n", F(max(t, t2), 0, 1, 1, 1));
}
int main(){
    int T; scanf("%d%d", &T, &k);
    FL(i, 0, k){
        C[i][0] = 1;
        FL(j, 1, i){
            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % k;
        }
    }
    while(T--) solve();
    return 0;
}
```


---

## 作者：绝顶我为峰 (赞：4)

过了这题，发现题解区全部是卢卡斯定理，于是来写一个不一样的题解。

本题是 [CF582D](https://codeforces.com/contest/582/problem/D) 的超级弱化版，这两题都是**勒让德定理**的模板题。

勒让德定理的内容是：若 $p\in prime$，则 $n!$ 质因数分解中 $p$ 的次数是 $\sum_{i=1}\lfloor\frac{n}{p^i}\rfloor=\frac{n-S(n)}{p-1}$，$S(n)$ 表示 $p$ 进制下 $n$ 的数位和。

这个定理有一个更为常用的**推论**：$\dbinom {n+m}m$ 中 $p$ 的幂次等于 $n+m$ 在 $p$ 进制下进位次数。

我们证明这个推论：$\dbinom{n+m}m$ 中 $p$ 的幂次等于 $\sum(\lfloor\frac{n+m}{p^i}\rfloor-\lfloor\frac n{p^i}\rfloor-\lfloor\frac m{p^i}\rfloor)$。对于每个 $i$，发现当且仅当 $n+m$ 在 $p$ 进制下第 $i$ 位进位时 $\lfloor\frac{n+m}{p^i}\rfloor-\lfloor\frac n{p^i}\rfloor-\lfloor\frac m{p^i}\rfloor=1$，否则 $\lfloor\frac{n+m}{p^i}\rfloor-\lfloor\frac n{p^i}\rfloor-\lfloor\frac m{p^i}\rfloor=0$，于是得证。

那么这题要求的是 $\dbinom ij$ 能被 $p$ 整除，也就是说我们需要统计有序数对 $(i,j)$ 的数量使得 $i\leq n,j\leq\min(i,m)$ 且 $i-j$ 与 $j$ 在 $p$ 进制下相加会产生进位。

这个显然不好做，考虑统计不进位的数量。

发现这是平凡的，设计一个数位 dp，$dp_{k,0/1,0/1}$ 表示当前决定到第 $k$ 位，$i,j$ 各自是否顶上界，不产生进位的方案数，转移直接枚举 $i$ 和 $j$ 这一位填什么即可，注意要满足 $i$ 在 $p$ 进制下任意一位都要大于 $j$ 的对应位置，这样才不会产生进位。

时间复杂度 $O(Tp^2\log_pn)$。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
#define int long long
const int mod=1000000007;
int t,p,n,m,a[101],b[101],len,dp[101][2][2],ans;
signed main()
{
    cin>>t>>p;
    while(t--)
    {
        cin>>n>>m;
        m=min(n,m);
        len=ans=0;
        memset(a,0,sizeof a);
        memset(b,0,sizeof b);
        memset(dp,0,sizeof dp);
        int tn=n,tm=m;
        while(tn)
        {
            ++len;
            a[len]=tn%p;
            tn/=p;
            b[len]=tm%p;
            tm/=p;
        }
        dp[len+1][1][1]=1;
        for(int i=len;i>=1;--i)
            for(int x=0;x<2;++x)
                for(int y=0;y<2;++y)
                    if(dp[i+1][x][y])
                        for(int l=0;l<p;++l)
                            if(!x||l<=a[i])
                                for(int r=0;r<=l;++r)
                                    if((!y||r<=b[i]))
                                        dp[i][x&&l==a[i]][y&&r==b[i]]=(dp[i][x&&l==a[i]][y&&r==b[i]]+dp[i+1][x][y])%mod;
        for(int x=0;x<2;++x)
            for(int y=0;y<2;++y)
                ans=(ans+dp[1][x][y])%mod;
        cout<<((1ll*(m+2)%mod*((m+1)%mod)%mod*((mod+1)>>1)%mod+1ll*(m+1)%mod*((n-m)%mod)%mod)%mod-ans+mod)%mod<<'\n';
    }
    return 0;
}
```

---

## 作者：edward1346 (赞：3)

## 数位 DP 记忆化搜索

记得这是老师给我讲数位 dp 时的第一道例题。

[题目传送门](https://www.luogu.com.cn/problem/P6669)

### 问题的转化

看到组合数，就想到了一个和组合数相关的定理——卢卡斯定理。


$ C _ {n} ^ {m} \bmod p = C _ {\frac{n}{p}} ^ \frac{m}{p} \times C _ {n \bmod p} ^ {m \bmod p} \bmod p$

可以带数进去算，比如这是 $n=60, m=12, p=5$ 的情况：

$C _ {61} ^{31} \bmod 5 = C _ {12} ^ {6} \times C _ {1} ^ {1} \bmod 5$ 

我们就会发现 $C _ {12} ^ {6}$ 还可以继续拆分，于是式子就变成了这样：

$C _ {61} ^{31} \bmod 5 = C _ {2} ^{1} \times C_{2} ^{1} \times C_{1}^{1} \bmod 5$

现在所有组合数都没法在往下拆分了，于是聪明的你也许会发现在这个时候**所有的数都是小于 $p$ 的**。

所有的数都是小于 $p$ 的，你会想到什么？

对，就是 $p$ 进制！

所以，我们就有了一个大致的思路：要先将 $n$ 和 $m$ 转换成 $p$ 进制。

然后，我们再回头看上面的式子，思考一下，这个式子什么时候它的值是等于 $0$ 的？

对，没错，就是当 $m > n$ 时，式子的值为 $0$，也就是 $C _ {n} ^{m}$ 是 $p$ 的倍数。

于是，问题就变成了：求有多少个 $p$ 进制数 $i$ 和 $j$，满足 $i$ 小于等于 $n$ 且 $j$ 小于等于 $\min(i,m)$。

判断 $i$ 和 $j$ 是否满足题目条件，就只需要看看 $p$ 进制下的 $i$ 的某一数位是否小于 $p$ 进制下的 $j$ 的对应数位。

所以可以用数位 DP 来解决这个问题。

### 解题方法

我们就可以设置 dp 数组的状态了：

$f(pos,bj,fl,l1,l2)$ 表示该状态下合法的组合数对有多少个。

$pos$ 表示当前还剩 $pos$ 位未填，$bj$ 表示当前的 $i$ 是否小于 $j$，$fl$ 表示前面填的 $i$ 和 $j$ 的每一位是否是相同的，$l1$ 表示第一个数是否有最高位限制，$l2$ 表示第二个数是否有最高位限制。

**记得多组数据，要初始化！**

AC 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int q,k;
long long n,m;
int a[101],b[101],la,lb;
int f[101][2][2][2][2];
long long mod=1e9+7;
int dfs(int pos,int bj,int fl,int l1,int l2)
{
	if(pos==0)
	{
		return bj;
	}
	
	if(f[pos][bj][l1][l2][fl]!=-1)
		return f[pos][bj][l1][l2][fl];
	
	int up1=k-1,up2=k-1;
	if(l1)up1=a[pos];
	if(l2)up2=b[pos];
	
	int ans=0;
	for(int i=0;i<=up1;i++)
	{
		for(int j=0;j<=up2;j++){
			if(fl==0)
			{
				if(i!=j)//如果i和j的当前位不一样，那么我们就要改变fl的值
					if(i>j)//如果i>j，那么我们就要改变bj的值
					{
						ans+=dfs(pos-1,bj | (i<j),1,l1&&i==up1,l2&&j==up2);
						ans%=mod;
					}	
					else
						continue;
				else{
					ans+=dfs(pos-1,bj | (i<j),0,l1&&i==up1,l2&&j==up2);
					ans%=mod;
				}
					
			}
			else{
				ans+=dfs(pos-1,bj | (i<j),fl,l1&&i==up1,l2&&j==up2);
				ans%=mod;
			}
			ans=(ans+mod)%mod;	
		}
	}
	ans%=mod;
	f[pos][bj][l1][l2][fl]=ans;
	
	return ans;
}
main()
{
	cin>>q>>k;
	while(q--)
	{
		memset(f,-1,sizeof f);
        memset(a,0,sizeof a);
        memset(b,0,sizeof b);
		scanf("%lld%lld",&n,&m);
		la=0,lb=0;
		while(n)
		{
			a[++la]=n%k;
			n/=k;
		}
		while(m)
		{
			b[++lb]=m%k;
			m/=k;
		}
		cout<<dfs(max(la,lb),0,0,1,1)<<endl;
	}
}

```

---

## 作者：JustPureH2O (赞：2)

[更好的阅读体验](https://justpureh2o.cn/articles/6669)

题目地址：[P6669](https://www.luogu.com.cn/problem/P6669)

看到超大组合数对质数取模首先考虑朴素 $\texttt{Lucas}$ 定理，定理内容如下：

$$
\binom{n}{m}\bmod p=\binom{\lfloor\frac{n}{p}\rfloor}{\lfloor\frac{m}{p}\rfloor}\times\binom{n\bmod p}{m\bmod p}
$$

其中第一项可以继续递归。但是这里要涉及到 $\texttt{Lucas}$ 定理的另外一个意义——发现这个公式实质上是在对 $n,m$ 进行 $p$ 进制分解。整个组合数可以看作是将 $n,m$ 转换为 $p$ 进制后对位求组合数然后累乘得到的，即：

$$
\binom{n}{m}=\prod\limits_{i=1}^{k}\binom{n_i}{m_i}
$$

其中 $k$ 为 $n,m$ 在 $p$ 进制下位数的最大值，若位数不够则将该位看作 $0$。

如果一个数要是 $k$ 的倍数，那么这个数模 $k$ 的结果一定是 $0$。根据 $\texttt{Lucas}$ 定理，在连乘过程中，必须至少出现一个零项，最终结果才会是 $0$。根据组合数 $\binom{a}{b}$ 在 $b>a$ 时结果为 $0$ 的性质，可知我们需要统计 $p$ 进制下有多少 $j$ 有至少一个位严格大于 $i$，此时同时对 $i,j$ 数位 DP 即可。

```cpp
#include <bits/stdc++.h>

#define N 62
#define MOD 1000000007
using namespace std;

typedef long long ll;

int numN[N], numM[N];
ll f[N][2][2][2][2];
int k;

ll dfs(int pos, bool valid, bool limitN, bool limitM, bool limitI) {
//     当前位   是否已合法   i顶到上界n   j顶到上界m   j顶到上界i
    if (pos < 0) return valid;
    if (f[pos][valid][limitN][limitM][limitI] >= 0) return f[pos][valid][limitN][limitM][limitI]; // 记忆化搜索
    ll sum = 0;
    for (int i = 0; i <= (limitN ? numN[pos] : k - 1); i++) {
        // 枚举 i 在这一位上填的数字
        for (int j = 0; j <= min((limitM ? numM[pos] : k - 1), (limitI ? i : k - 1)); j++) {
            // 枚举 j 在这一位上填的数字，注意需要满足 j 不超过 i 和 m 的最小值
            sum = (sum + dfs(pos - 1, valid | (j > i), limitN & (i == numN[pos]), limitM & (j == numM[pos]),limitI & (i == j))) % MOD;
        }
    }
    f[pos][valid][limitN][limitM][limitI] = sum;
    return sum;
}

ll calc(ll n, ll m) {
    memset(numN, 0, sizeof numN);
    memset(numM, 0, sizeof numM);
    memset(f, -1, sizeof f);

    // 进制分解
    int size1 = 0, size2 = 0;
    ll tmp1 = n, tmp2 = m;
    while (tmp1) {
        numN[size1++] = tmp1 % k;
        tmp1 /= k;
    }
    while (tmp2) {
        numM[size2++] = tmp2 % k;
        tmp2 /= k;
    }
    return dfs(max(size1, size2) - 1, false, true, true, true);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    memset(f, -1, sizeof f);

    int t;
    cin >> t >> k;
    while (t--) {
        ll n, m;
        cin >> n >> m;
        cout << calc(n, m) << endl;
    }
    return 0;
}
```

$\texttt{The End}$

---

## 作者：pomelo_nene (赞：2)

大家都知道 $\mathrm{Lucas}$ 定理，先不要管整个结论叫什么，摆出一个众所周知的式子给大家看看：

$$
 \dbinom{m}{n} \equiv \dbinom{m \bmod k}{n \bmod k} \cdot \dbinom{\lfloor \frac{m}{k} \rfloor}{\lfloor \frac{n}{k} \rfloor} (\bmod\  k)
$$

回顾一下我们做 $\mathrm{Lucas}$ 算法求组合数的时候，我们根据上面那个式子可以递归算。但是似乎还是没有什么头绪。

于是找到 $\mathrm{Lucas}$ 定理（Lucas's theorem）:

> 对于非负整数 $m,n$ 和质数 $p$，有 $\dbinom{m}{n} \equiv \displaystyle \prod_{i=0}^k \dbinom{m_i}{n_i} (\bmod  \ p)$，其中 $m = m_kp^k + m_{k-1}p^{k-1} + \cdots + m_1p + m_0,n=n_kp^k + n_{k-1}p^{k-1} + \cdots + n_1p + n_0$，即 $m,n$ 的 $p$ 次方展开。

再回看这个式子，是否会清晰很多？

所以说，$\dbinom{m}{n}$ 若想被质数 $k$ 整除，一定有：$n,m$ 写成 $k$ 进制数，存在有一位数上的数位，$n$ 比 $m$ 小。

发现可以数位 dp 直接来。为了简便，我们可以算不能被质数 $k$ 整除的方案，被总方案减去就是答案。可以直接按位去进行 dp。

传统的数位 dp 算达到上限，对于达到上限的状态不进行记忆化会跑得比较慢。所以定义 $dp_{i,0 / 1,0 /1}$，表示选到第 $i$ 位，$n,m$ 分别是否达到上限，乱 dp 就行了。具体实现看代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef __int128 LL;
char buf[1<<21],*p1=buf,*p2=buf;
#define getchar() (p1==p2 && (p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
LL read()
{
	LL x=0,f=1;
	char c=getchar();
	while(c<'0' || c>'9')
	{
		if(c=='-')	f=-1;
		c=getchar();
	}
	while(c>='0' && c<='9')	x=(x<<1)+(x<<3)+(c^'0'),c=getchar();
	return x*f;
}
void write(LL x)
{
	if(x<0)	putchar('-'),x=-x;
	if(x>9)	write(x/10);
	putchar(x%10+'0');
}
const LL MOD=1e9+7;
LL dp[65][2][2],k,pnt1[65],pnt2[65],cnt1,cnt2;
LL dfs(LL now,LL lead1,LL lead2)
{
	if(!now)	return 1;
	if(~dp[now][lead1][lead2])	return dp[now][lead1][lead2];
	LL up1=lead1?pnt1[now]:k-1,up2=lead2?pnt2[now]:k-1,ans=0;
	for(LL i=0;i<=up1;++i)
	{
		for(LL j=0;j<=min(up2,i);++j)
		{
			ans+=dfs(now-1,lead1 && i==up1,lead2 && j==up2);
			ans%=MOD;
		}
	}
	return dp[now][lead1][lead2]=ans;
}
LL calc(LL n,LL m)
{
	cnt1=cnt2=0;
	LL tmp=n;
	while(tmp)	pnt1[++cnt1]=tmp%k,tmp/=k;
	tmp=m;
	memset(pnt2,0,sizeof pnt2);
	while(tmp)	pnt2[++cnt2]=tmp%k,tmp/=k;
	return dfs(cnt1,1,1);
}
int main(){
	LL T=read();
	k=read();
	while(T-->0)
	{
		LL n=read(),m=read();
		m=min(m,n);
		memset(dp,-1,sizeof dp);
		write((((m+1)%MOD*(m+2)%MOD*500000004ll%MOD+((n-m+MOD)%MOD+MOD)%MOD*(m+1)%MOD)%MOD+MOD-calc(n,m))%MOD);
		puts("");
	}
	return 0;
}
```

---

## 作者：Cx114514 (赞：1)

### 题目链接：[[清华集训2016] 组合数问题](https://www.luogu.com.cn/problem/P6669)
发现 $n,m$ 都很大，$k$ 很小，考虑 $\text{Lucas}$ 定理，有：

 $$\binom{n}{m} \equiv \binom{\left \lfloor \frac{n}{k} \right \rfloor }{\left \lfloor \frac{m}{k} \right \rfloor}\times \binom{n\bmod k}{m\bmod k} \pmod{k}$$ 

若 $\binom{n}{m}\equiv 0\pmod k$，则在使用 $\text{Lucas}$ 定理递归计算时的某一次中，$\binom{n\bmod k}{m\bmod k}=0$，而该式 $=0$ 当且仅当 $m \bmod k>n\bmod k$。

每次 $\bmod$ $k$ 可以看作是按 $k$ 进制分解。那么 $\binom{n}{m}\equiv 0\pmod k$ 的充要条件即为：在 $k$ 进制下，至少存在一位使得 $m$ 该位上的数字 $>$ $n$ 该位上的数字。

那么问题就转化为了：

给定 $n,m$，求有多少组 $i,j$ 满足 $1\le i\le n$，$1\le j \le \min\left(i,m\right)$ 且在 $k$ 进制上至少存在一位 $i<j$。

这个乍一看可以用数位 $\text{DP}$ 做，但是仔细一想会发现根本设计不出来好的状态可以转移。

记忆化搜索大法好！

令 $len$ 表示 $k$ 进制下 $n$ 和 $m$ 数位总数的较大值。

设 $f\left(pos,0/1,0/1,0/1,0/1\right)$ 表示 
**考虑到从低到高的第 $pos$ 位，从 $pos\sim len$ 是否有一位上 $i<j$，从 $pos\sim len$ 是否有一位上 $i>j$，$1\sim pos$ 是否满足 $i$ 的约束条件，$1\sim pos$ 是否满足 $j$ 的约束条件** 的方案数。

令 $m$ 和 $n$ 同阶，时间复杂度为 $O\left(Xtk^2\log_k n\right)$，其中 $X$ 是一个大小为 $2^4$ 的常数。

代码：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int mod = 1e9 + 7;

int t, k, n, m, len1, len2, len, N[105], M[105], f[105][5][5][5][5];

int solve(int pos, int lim1, int lim2, int lim3, int lim4)
{
	if (!pos) return lim1;
	if (f[pos][lim1][lim2][lim3][lim4]) return f[pos][lim1][lim2][lim3][lim4];
	int ans = 0;
	int maxn = lim3 ? k - 1 : N[pos];
	int maxm = lim4 ? k - 1 : M[pos];
	for (int i = 0; i <= maxn; i++)
		for (int j = 0; j <= maxm && (j <= i || lim2); j++)
			ans = (ans + solve(pos - 1, lim1 | (i < j), lim2 | (i > j), lim3 | (i < maxn), lim4 | (j < maxm))) % mod;
	return f[pos][lim1][lim2][lim3][lim4] = ans;
}

signed main()
{
	cin >> t >> k;
	while (t--)
	{
		cin >> n >> m;
		len1 = 0;
		len2 = 0;
		memset(N, 0, sizeof(N));
		memset(M, 0, sizeof(M));
		memset(f, 0, sizeof(f));
		while (n)
		{
			N[++len1] = n % k;
			n /= k;		
		}
		while (m)
		{
			M[++len2] = m % k;
			m /= k;
		}
		len = max(len1, len2);
		cout << solve(len, 0, 0, 0, 0) << endl;
	}
	return 0;
}
```

---

## 作者：Strelitzia (赞：1)

[题目床送门](https://www.luogu.com.cn/problem/P6669)

---

前置知识：$\mathrm{Lucas}$ 定理

啊，好像没有这样的做的。

由 $Lucas$ 定理得。

$$
\dbinom nm \equiv \dbinom{\lfloor\frac{n}{k}\rfloor}{\lfloor\frac{m}{k}\rfloor}.\dbinom{n \bmod k}{m \bmod k} (\bmod k)
$$

当 $\dbinom{n \bmod k}{m \bmod k}$ 或$\dbinom{\lfloor\frac{n}{k}\rfloor}{\lfloor\frac{m}{k}\rfloor}$ 为 $\mathrm{0}$ 是，是被 $k$ 整除。

而 $\dbinom{\lfloor\frac{n}{k}\rfloor}{\lfloor\frac{m}{k}\rfloor}$ 可以继续往下分，我们就可以只考虑 $\dbinom{n \bmod k}{m \bmod k}$ 的部分。

而只有 $n \bmod k < m \bmod k$ 时 $\dbinom{n \bmod k}{m \bmod k}$ 为 $\mathrm 0$，就是相当于在 $\mathrm k$ 进制下 $\mathrm{n}$ 有一位比 $\mathrm m$ 小 $\dbinom n m$ 就整除 $\mathrm{k}$。

然后就可以用数位动规做了。

```cpp
#include <queue>
#include <cmath>
#include <cstdio>
#include <cctype>
#include <cstring>
#include <algorithm>
using namespace std;

char buf[1 << 23],*p1 = buf,*p2 = buf,obuf[1 << 23],*O = obuf;
#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf,1,1 << 21,stdin),p1 == p2) ? EOF : *p1 ++)
#define putchar(x) *O ++ = x

template<typename T>void read(T &x) {
	x = 0;T f = 1;char ch = getchar();
	while (!isdigit(ch)) {if (ch == '-') f = -1;ch = getchar();}
	while (isdigit(ch)) {x = (x << 3) + (x << 1) + ch - '0';ch = getchar();}
	x *= f;
}
int read() {
	int x = 0, f = 1;char ch = getchar();
	while (!isdigit(ch)) {if (ch == '-') f = -1;ch = getchar();}
	while (isdigit(ch)) {x = (x << 3) + (x << 1) + ch - '0';ch = getchar();}
	return x * f;
}
template<typename T>void print(T x) {
	if (x < 0) putchar('-'),x = -x;
	if (x > 9) print(x / 10);
	putchar(x % 10 + '0');
}

template<typename T>T Abs(T x) {return x < 0 ? -x : x;}
template<typename T>T Min(T x,T y) {return x < y ? x : y;}
template<typename T>T Max(T x,T y) {return x > y ? x : y;}
template<typename T>void Swap(T &x,T &y) {T z = x;x = y;y = z;}

const int MOD = 1e9 + 7;

long long n,m;
int t,k,tot1,tot2;
int b[65],c[65];
int f[65][2][2][2][2];

int dfs(int len,int up1,int up2,int app,int can) {
	if (!len) return app;
	if (~f[len][up1][up2][app][can]) return f[len][up1][up2][app][can];
	int mdig1 = up1 ? b[len] : k - 1;
	int mdig2 = up2 ? c[len] : k - 1;
	int res = 0;
	for (int i = 0 ; i <= mdig1 ; ++ i) {
		for (int j = 0 ; j <= mdig2 ; ++ j) {
			if (j > i && !can) continue;
			res += dfs(len - 1,up1 && i == mdig1,up2 && j == mdig2,app || (j > i),can || (i > j));
			res = res > MOD ? res - MOD : res;
		}
	}
	return f[len][up1][up2][app][can] = res;
}

int DP(long long x,long long y) {
	memset(f,-1,sizeof f);
	if (y > x) y = x;
	memset(b,0,sizeof b);
	memset(c,0,sizeof c);
	tot1 = tot2 = 0;
	while (x) b[++ tot1] = x % k,x /= k;
	while (y) c[++ tot2] = y % k,y /= k;
	return dfs(tot1,1,1,0,0);
}

int main () {
	read(t);read(k);
	while (t --) {
		read(n);read(m);
		print(DP(n,m)),putchar('\n');
	}
	fwrite(obuf,O - obuf,1,stdout);
	return 0;
}
```

---

## 作者：KAMIYA_KINA (赞：0)

## Tag

卢卡斯定理，数位 dp。

## Description

$T$ 组询问，给定常数 $k$。

对于每一组询问，给定 $n,m$，对于 $0 \leq i \leq n, 0 \leq j \leq \min(i,m)$，你需要求出 $k|\dbinom ij$ 的方案数。

$\texttt{data range:} n,m\leq 10^{18}, k \leq 100,k \in \mathbb P$.

## Solution

看到整除，我们一般使用积性函数求和来完成，但是本题中组合数并没有积性，所以不太能用积性函数来做。

考虑 lucas 定理的过程（而非本质）。

对于一个组合数 $\dbinom{n}{m}$，如果对于一个质数 $p$ 取模，那么这个式子等价于：$\dbinom{\lfloor n/p\rfloor}{\lfloor m / p \rfloor}\dbinom{n \bmod p}{m \bmod p} \pmod p$。

对于这个式子，首先如果 $n\geq m$，那么前面一项永远不可能是 $0$，考虑后面一项什么时候是 $0$。显然当 $n < m$ 的时候有 $\dbinom{n}{m} = 0$，所以当某一个 $\dbinom{n\bmod p}{m\bmod p}=0$ 的时候，这个组合数在模 $p$ 意义下等于 $0$。

考虑到后面那个组合数的形式实际上是一个 $k$ 进制的转换，那么我们可以使用**数位 dp** 来解决这个问题。

具体可以令 $f_{p,a,b,c,d}$ 表示当前枚举到第 $p$ 位，当前位置是否保证 $n\leq m$，当前位置之前是否存在一个位置使 $\dbinom{a_i}{b_i} = 0$，当前位置是否是 $n$ 的危险点，当前位置是否是 $m$ 的危险点。

然后求解一番就可以了。下面是校内测试赛时候写的代码，效率并不是非常优秀……

## Code

```cpp
using ll = long long;

const int N = 100;
const int mod = 1e9 + 7;

inline void chk(int &x) {x -= mod; x += x >> 31 & mod;}
inline int mll(int x, int y) {return (ll) x * y % mod;}
inline int add(int x, int y) {chk(x += y); return x;}
inline int del(int x, int y) {return add(x, mod - y);}

int k;
int f[N][2][2][2][2];
int la[N], lb[N];

int dfs(const int p, const int a, const int b, const int c, const int d) {
    if(!p) return a && b;
    if(~f[p][a][b][c][d]) return f[p][a][b][c][d];
    int ret = 0, tem1 = c ? k - 1 : la[p], tem2 = d ? k - 1 : lb[p];
    FOR(i, 0, tem1) FOR(j, 0, tem2) {
        if(!a && i < j) break;
        bool f1 = a | (i > j), f2 = b | (i < j);
        bool f3 = c | (i != la[p]), f4 = d | (j != lb[p]);
        chk(ret += dfs(p - 1, f1, f2, f3, f4));
    }
    return f[p][a][b][c][d] = ret;
}

inline int calc(const ll n, const ll m) {
    int ret = 0, lim = 0;
    memset(f, -1, sizeof(f));
    ll temn = n, temm = m;
    while(temn || temm) {
        lim++;
        la[lim] = temn % k, lb[lim] = temm % k;
        temn /= k, temm /= k;
    }
    ret = dfs(lim, 0, 0, 0, 0);
    return ret;
}

inline void solve() {
    int t = rd;
    k = rd;
    while(t--) {
        ll n = rd, m = rd;
        cout << calc(n, m) << '\n';
    }
    return ;
}
```

---

## 作者：Leap_Frog (赞：0)

### Description.
求  
$$\sum_{i=1}^{n}\sum_{j=1}^{\min(i,m)}[k|C_i^j]$$

### P.S.
前置知识： Lucas 定理  
![](https://bkimg.cdn.bcebos.com/formula/a784fd83c19921085f6e12dff816ef1d.svg)  
（摘自百度百科。详细证明及实现方法左传[模板](https://www.luogu.com.cn/problem/P3807)  

此篇题解假设读者已经会了 Lucas 定理以及实现方法。

### Solution.
我们首先县观察数据范围，发现 $k$ 是一个质数。  
题目名字又叫组合数问题，那我们能第一时间反应出来这是道 Lucas 的题目。  
我们分析一下 Lucas 是如何求组合数 $\text{mod}\ k$ 结果的。  
```cpp
inline int C(int n,int m)
{
	if(m>n) return 0;//这个fac是阶乘数组
	else return 1ll*fac[n]*qpow(fac[m],k-2)%k*qpow(fac[n-m],k-2)%k;
}
inline int lucas(int n,int m)
{
	if(m==0) return 1;
	else return 1ll*C(n%k,m%k)*lucas(n/k,m/k)%k;
}
```
这就是笔者的 Lucas 代码，（写的丑，请轻喷。  
我们发现其实 Lucas 定理就是把组合数的 $n$ 和 $m$ 一遍一遍对 $k$ 取模，把所有取模后的余数的组合数乘起来。  
感觉这个方式有点似曾相识，我们在做进制转换时也时这样做的。  
所以 Lucas 定理的本质就是把 $n$ 和 $m$ 转化成 $k$ 进制，然后把每进制位上的数位求组合数，最后把所得到的组合数乘起来。  
同时我们又发现，$k$ 进制的每一个进制位上的数都小于 $k$。  
又根据组合数的定义：  
$$C_n^m=\frac{n!}{m!(n-m)!}$$  
所以当 $m\le n<k$ 时，$C_n^m$ 肯定没有 $k$ 这个因数。  
那么我们是怎么让它 $\text{mod}\ k$ 等于 $0$ 的呢？  
我们手模一组样例或者仔细观察一下上面的代码就可以知道，当 $m>n$ 时组合数就为 $0$ 了。  
当 $m<=n$ 时 $C_n^m\ \text{mod}\ k \not = 0$ ， 当 $m>n$ 时组合数一直为 $0$。  
所以$C_n^m\ \text{mod}\ k=0$的充分必要条件是，把 $n$ 和 $m$ 转化成 $k$ 进制后存在一位，使得 $n$ 在这位上的数值小于 $m$ 在这位上的数值。  
所以最后我们直接对 $n$ 和 $m$ 进行一个数位 dp，就可以得到最后的答案了。  

完结撒花。

### Coding.
注意，这篇代码为了使实现变得简单，用了一个小小的容斥  
也就是说，组合数对 $k$ 取模模为 $0$ 的数等于总数减去对 $k$ 取模答案不为 $0$ 的方案数。  
```cpp
//也请让我相信，你一直以来所相信的事吧——“活着是一件很美好的事”
//只要记住你的名字 不管你在世界的哪个地方 我一定会去见你
//我现在依然喜欢着你，但我们就算是来往一千封邮件，心却不可能接近哪怕一厘米
//嗯，那样的话，你就再努力一次试试吧！别在这种地方畏畏缩缩的！别对自己说谎！再努力一次吧
//拜托了 请把力量借给软弱的我 给我从这里再度起身迈步的力量
//虽然灯塔已经失去了光明…… 但是 只要有你的那首歌在 就一定能将那些人再次导向此方
//小时候曾认为这个世界会更加的单纯简单，没有赢不了的比试，努力就会有回报，认为这世上一切皆有可能。
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int P=1000000007;int t,k,n,m,dp[105][2][2],cnt1,a[105],cnt2,b[105];
inline int dfs(int x,int lim1,int lim2)
{//数位dp，用的记搜，x表示当前搜到了第几位，lim1表示当前n是否顶到了上界，lim2表示m
	if(!x) return 1;else if(dp[x][lim1][lim2]!=-1) return dp[x][lim1][lim2];
	//边界条件，或者记忆化
	int ed1=lim1?a[x]:k-1,ed2=lim2?b[x]:k-1,res=0;
	//ed表示end，即当前这一位能取的最大值
	for(int i=0;i<=ed1;i++) for(int j=0;j<=i&&j<=ed2;j++) res=(res+dfs(x-1,lim1&&i==ed1,lim2&&j==ed2))%P;
	//直接dp，数位dp模板
	return dp[x][lim1][lim2]=res;//记忆化
}
signed main()
{
	for(scanf("%lld%lld",&t,&k);t--;)
	{
		scanf("%lld%lld",&n,&m),m=min(n,m),cnt1=cnt2=0,memset(dp,-1,sizeof(dp)),memset(b,0,sizeof(b));//多组数据清零
		int r=(((m+1)%P*((m+2)%P))%P*500000004%P+(n-m)%P*((m+1)%P)%P)%P;
		//r表示总数，这个500000004是2%(1e9+7)的乘法逆元，懒得打一个快速幂了QAQ
		{while(n) a[++cnt1]=n%k,n/=k;}{while(m) b[++cnt2]=m%k,m/=k;}
		//把n和m按照k进制展开
		printf("%lld\n",(r-dfs(cnt1,1,1)+P)%P);//减去答案不为0的答案
	}
	return 0;
}
```

---

## 作者：JasonL (赞：0)

## [清华集训$2016$] 组合数问题

[题目链接](https://www.luogu.com.cn/problem/solution/P6669)

### 分析

本题需要求得

$\sum\limits_{i=0}^{n}\sum\limits_{j=0}^{\min(i,m)}[\gcd(C^j_i,k)==k] \mod 10^{9}+7$

等价于$\sum\limits_{i=0}^{n}\sum\limits_{j=0}^{\min(i,m)}[C^j_i \equiv 0\mod k] \mod 10^{9}+7$

其中$k\in prime,k\in[1,100]$.

（虽然笔者写的算式让人想到反演，但是实际上$\frac{C^j_i}{k}$难以处理。我们尝试别的思路。）

先考虑对于$C_i^j$如何得到$[\gcd(C^j_i,k)==k]$。

我们提取出$i!,j!,(i-j)!$中包含$k$因子的个数（我们记为$c_k$）。那么当

$i!_k-j!_k-(i-j)!_k>0$

就有$[\gcd(C^j_i,k)==k]=1$

这种写法可适用于小范围暴力计算。

我们也可以这样看：

上式等同于计算$C_i^j \mod k$的值是否等于$0$.由$k$的性质可以利用卢卡斯定理。

$C^j_i\equiv C^{j\mod k}_{i \mod k}C^{\left\lfloor\frac{j}{k}\right\rfloor}_{\left\lfloor\frac{i}{k}\right\rfloor} \mod k$

那么分解过程中，当其中至少有一项为$0$时可以得到$[\gcd(C^j_i,k)==k]=1$.

同样，这种写法对于小范围数据是足够的。

那么对于$n,m\le 10^{18}$呢？这种写法还能不能继续优化？

我们想，上式其实就是将$i,j$转化为$k$进制后拆分数位，对于相同数位求组合数.

$j={\over a_1a_2a_3a_4\dots}_k$

$i={\over b_1b_2b_3b_4\dots}_k$

$C^j_i \equiv C^{a_1}_{b_1}C^{a_2}_{b_2}C^{a_3}_{b_3}C^{a_4}_{b_4}\dots \mod k$

说到数位分离我们就会想到数位$DP$。

最坏情况下$i,j$在$k$进制下为$60$位数（$k=2,i=10^{18}$）。同时，对于$C^j_i = 0(0\le i,j\le k)$，由于$i,j$的特殊性，$C^j_i$必不携带因子$k$.若要令$C^j_i = 0$，那么只能有$j>i$。

那么剩下的问题就是在$DP$过程中要求$0\le i\le n,0\le j\le\min(i,m)$，在该条件下我们对每一位进行枚举即可。

我们令$f_{ok,p,ji,in,jm},(ok,ji,in,jm\in\{0,1\})$表示枚举到第$p$位时且满足如下条件时的方案：$ok$记录当前是否$C^j_i=0$,$ji$记录当前是否$j<i$,$in$记录当前是否$i<n$,$jm$记录当前是否$j<m$。先将$n,m$的$k$进制表示求出，然后对其做记忆化搜索即可。

时间复杂度在$O(16k^2len)$左右，其中$len$为$n$在$k$进制表示下的长度。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
typedef long long ll;
const int maxl=61,mod=1000000007;
ll n,m;
int f[2][maxl][2][2][2];
int an[maxl],am[maxl],len,k;
inline ll read(){
	ll res=0;
	char ch=getchar(),ch1=ch;
	while(!isdigit(ch))ch1=ch,ch=getchar();
	while(isdigit(ch))res=(res<<3)+(res<<1)+ch-'0',ch=getchar();
	return ch1=='-'?-res:res;
}
int mmod(int x){
	return x>=mod?x-mod:x;
}
int dfs(bool ok,int p,bool ji,bool in,bool jm){
	if(!p)return ok;
	int &res=f[ok][p][ji][in][jm];
	if(~res);
	else{
		res=0;
		int upi=in?k-1:an[p],upj=jm?k-1:am[p];
		for(register int i=0;i<=upi;++i)
			for(register int j=0;j<=upj&&(ji||j<=i);++j)
					res=mmod(res+dfs(ok|(j>i),p-1,ji|(j<i),in|(i<an[p]),jm|(j<am[p])));
	}
	return res;
}
int main(){
	int T=read();k=read();
	while(T--){
		n=read();m=read();
		memset(f,-1,sizeof(f));
		if(m>n)m=n;
		len=0;
		while(n){
			an[++len]=n%k;n/=k;
			am[len]=m%k;m/=k;
		}
		printf("%d\n",dfs(0,len,0,0,0));
	}
	return 0;
}
```


---


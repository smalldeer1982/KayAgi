# [蓝桥杯 2019 省 A] 组合数问题

## 题目描述

给 $n,m,k$，求有多少对 $(i,j)$ 满足 $1 \le i \le n,0 \le j \le \min(i,m)$ 且 ${i\choose j} \equiv 0\pmod{k}$，$k$ 是质数。其中 ${i\choose j}$ 是组合数，表示从 $i$ 个不同的数中选出 $j$ 个组成一个集合的方案数。

## 说明/提示

**【样例说明】**

在所有可能的情况中，只有 ${2 \choose 1}=2$ 是 $2$ 的倍数。

**【数据规模和约定】**

对于所有评测用例，$1 \le k \le 10^8,1 \le t \le 10^5,1 \le n,m \le 10^{18}$，且 $k$ 是质数。

评测时将使用 $10$ 个评测用例测试你的程序，每个评测用例的限制如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/jb7e32a0.png)

蓝桥杯 2019 年省赛 A 组 J 题。

## 样例 #1

### 输入

```
1 2
3 3```

### 输出

```
1```

## 样例 #2

### 输入

```
2 5
4 5
6 7```

### 输出

```
0
7```

## 样例 #3

### 输入

```
3 23
23333333 23333333
233333333 233333333
2333333333 2333333333```

### 输出

```
851883128
959557926
680723120```

# 题解

## 作者：离散小波变换° (赞：8)

## 题解

首先 $m>n$ 多出来的部分毫无意义，所以第一步 $m\gets \min(n,m)$ 可以避免一些无意义的讨论。

观察到 $1\le n,m\le 10^{18}$ 过大，很明显没法用正常的方法去做。不过注意到 $k\le 10^8$ 是一个质数，可以从这里先下手。

对于一个组合数模一个质数，可以想到 $\text{Lucas}$ 定理：

$$\dbinom{x}{y}\bmod p=\dbinom{x\operatorname{div} p}{y\operatorname{div} p}\times \dbinom{x\bmod p}{y\bmod p}\bmod p$$

在使用 $\text{Lucas}$ 定理计算组合数模 $p$ 的值时，通常会递归处理。因此在本题中我们也考虑递归地展开 $\dbinom{x}{y}\bmod p$ 的值。

具体地，我们把 $x$ 和 $y$ 看作 $k$ 进制数并进行分解。也就是，

$$\begin{aligned}
x&= a_0+a_1k+a_2k^2+\cdots +a_u k^u \cr
y&= b_0+b_1k+b_2k^2+\cdots +b_v k^v \cr
\end{aligned}$$

其中，$0\le a_i,b_i<k$。那么应用 $\text{Lucas}$ 定理并将其递归展开后，可以得到如下形式：

$$\dbinom{x}{y}\bmod p=\dbinom{a_0}{b_0}\dbinom{a_1}{b_1}\dbinom{a_2}{b_2}\cdots \dbinom{a_{\max (u,v)}}{b_{\max(u,v)}}\bmod p$$

在这个式子中我们认为当 $i>u$ 时 $a_i=0$，当 $i>v$ 时 $b_i=0$。

我们随便选取其中某一项，可以发现 $\dbinom{a_i}{b_i}\neq 0$ 的充要条件是 $a\ge b$。这是因为，$a<b$ 时显然 $\dbinom{a}{b}=0$，而 $a\ge b$ 时将组合数展开为阶乘形式，就能发现最终计算结果不可能带有 $p$ 作为因子。

接着发现要存在至少一个 $i$ 满足 $a_i<b_i$，不如从总方案数里减去对于所有 $i$ 都有 $a_i\ge b_i$ 的方案数。总方案数显然为 $nm-\dfrac{m(m+1)}{2}$。但是需要特别小心对总方案数的取模，因为 $n,m$ 均为 $\text{long long}$ 级别，取模稍有不慎就会溢出！

这题到这里其实已经很容易解决了。我们只需要将每一对 $(a_i,b_i)$ 看作数码，跑一个数位 dp 就行。记 $l=\max(u,v)$ 是 $x,y$ 的最长长度，$f(i,0/1,0/1)$ 表示当前处理到第 $i\sim l$ 位，其中第 $i$ 位在 $x$ 中这一位有没有被限制，在 $y$ 中这一位有没有被限制。可以得到状态转移方程式：

$$\begin{aligned}
f(i,1,1) =&\ f(i+1,1,1)\operatorname{bitand} [a_i>b_i] \cr
f(i,1,0) =&\ f(i+1,1,1)\times \min(a_i+1,b_i)+f(i+1,1,0)\times (a_i+1) \cr
f(i,0,1) =&\ f(i+1,1,1)\times \max(a_i-b_i,0)+f(i+1,0,1)\times (k-a_i) \cr
f(i,0,0) =&\ f(i+1,1,1)\times g(a,b)+f(i+1,1,0)\times g(a,k)\cr
+&\ f(i+1,0,1)\times g(k,b)+f(i+1,0,0)\times g(k,k)
\end{aligned}$$

其中，

$$g(n,m)=\sum_{i=0}^{n-1}\sum_{j=0}^{m-1}[i\ge j]$$

分类讨论一下，容易可以得到 $g$ 的表达式：

$$g(n,m)=\begin{cases}\dfrac{m(m+1)}{2}+(n-m)m & n\ge m \cr \dfrac{n(n+1)}{2} & n< m\end{cases}$$

每种情形都很简单，但是讨论起来异常麻烦。读者有兴趣可以自行推导。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l, r, i) for(int i = l, END##i = r;i <= END##i;++ i)
#define dn(r, l, i) for(int i = r, END##i = l;i >= END##i;-- i)
using namespace std;
typedef long long i64;
const int INF = 2147483647;
const int MAXN=  60 + 3;
const int MOD = 1e9 + 7;
int A[MAXN], B[MAXN], k;
int F[MAXN][2][2];
void add_to(int &a, int b){
    a = (a + b) % MOD;
}
int calc(int a, int b){
    if(a >= b){
        return (1ll * b * (b + 1) / 2 + 1ll * (a - b) * b) % MOD;
    } else
        return  1ll * a * (a + 1) / 2 % MOD;
}
int dp(int l, bool f, bool g){
    if(F[l][f][g] != -1) return F[l][f][g];
    F[l][f][g] = 0;
    int a = A[l];
    int b = B[l];
    if(f == true && g == true){
        F[l][f][g] = dp(l + 1, true, true) & (a >= b);
    } else if(f == true){
        add_to(F[l][f][g], 1ll * dp(l + 1,  true,  true) * min(a + 1, b) % MOD);
        add_to(F[l][f][g], 1ll * dp(l + 1,  true, false) *    (a + 1)    % MOD);
    } else if(g == true){
        if(a - b > 0)
        add_to(F[l][f][g], 1ll * dp(l + 1,  true,  true) * (a - b) % MOD);
        add_to(F[l][f][g], 1ll * dp(l + 1, false,  true) * (k - b) % MOD);
    } else {
        add_to(F[l][f][g], 1ll * dp(l + 1,  true,  true) * calc(a, b) % MOD);
        add_to(F[l][f][g], 1ll * dp(l + 1,  true, false) * calc(a, k) % MOD);
        add_to(F[l][f][g], 1ll * dp(l + 1, false,  true) * calc(k, b) % MOD);
        add_to(F[l][f][g], 1ll * dp(l + 1, false, false) * calc(k, k) % MOD);
    }
    return F[l][f][g];
}
i64 qread(){
    i64 w = 1, c, ret;
    while((c = getchar()) >  '9' || c <  '0') w = (c == '-' ? -1 : 1); ret = c - '0';
    while((c = getchar()) >= '0' && c <= '9') ret = ret * 10 + c - '0';
    return ret * w;
}
int main(){
    int T = qread(); k = qread();
    up(1, T, _){
        i64 n = qread(), nn = n; int a = 0;
        i64 m = qread(), mm = m; int b = 0;
        mm = m = min(n, m);
        while(nn) A[++ a] = nn % k, nn /= k;
        while(mm) B[++ b] = mm % k, mm /= k;
        int c = max(a, b);
        up(a + 1, c, i) A[i] = 0;
        up(b + 1, c, i) B[i] = 0;
        up(1, c, i){
            F[i][0][0] = F[i][0][1] = -1;
            F[i][1][0] = F[i][1][1] = -1;
        }
        F[c + 1][1][1] = 1;
        F[c + 1][1][0] = 0;
        F[c + 1][0][1] = 0;
        F[c + 1][0][0] = 0;
        int w = 0;
        add_to(w, dp(1, 0, 0));
        add_to(w, dp(1, 0, 1));
        add_to(w, dp(1, 1, 0));
        add_to(w, dp(1, 1, 1));
        int ans = ((m + 1) % MOD * ((n + 1) % MOD) % MOD - w + MOD) % MOD;
        if(m % 2 == 0)
            ans = (ans - (m / 2) % MOD * ((m + 1) % MOD) % MOD + MOD) % MOD;
        else 
            ans = (ans - m % MOD * (((m + 1) / 2) % MOD) % MOD + MOD) % MOD;
        printf("%d\n", ans);
    }
    return 0;
}
```

---

## 作者：Purslane (赞：4)

# Solution

不用 Lucas 换一种视角理解。

考虑 $v_p(n!) = \sum_{i=1} \lfloor \dfrac{n}{p^i} \rfloor$。还是根据 Lengdre 定理，有 $v_p(n!)=\dfrac{n-S_p(n)}{p-1}$。其中 $S_p(n)$ 是 $p$ 进制下 $n$ 的数位和。

因此 $v_p(C_n^m)=\dfrac{(n-S_p(n))-(m-S_p(m))-((n-m)-S_p(n-m))}{p-1}$。于是题要求 $S_p(j)+S_p(i-j) > S_p(i)$。很显然，这相当于 $p$ 进制加法 $(i-j)+j$ 产生了进位。相当于 $p$ 进制下 $i$ 有一位比 $j$ 小。

所以我们发现，只要 $i$ 有一位比 $j$ 对应的位小就可以。因此我们考虑找到 $i$ 的每一位都大于等于 $j$ 对应的位的情况。拿总情况减去这些情况即可。

那么就数位 DP 啦。考虑我们我们对于 $i$ 和 $j$ 填数的唯一限制就是能不能比上限 $i$ 和 $j$ 大。

于是就可以开两个维度记录 $i$ 和 $j$ 前面是否有小于 $n$ 和 $m$ 对应位的情况。$1$ 就代表这一位可以瞎填数。$0$ 代表这一位必须严格小于限制的对应位。我们依次分类讨论所有情况。

1. 两维的限制分别是 $11$。那么随心所欲，可以填 $\frac{p(p+1)}{2}$ 种，转移到 $11$。
2. 两维的限制是 $10$。这说明 $i$ 随心所欲，$j$ 必须小于等于 $m$ 的对应位。转移非常简单，假设 $m$ 的对应位为 $t$。转移到 $10$ 的有 $p-t$ 种，转移到 $11$ 的有 $\frac{t(t+1)}{2}+t(p-t)$ 种。
3. 两维的限制是 $01$。这说明 $i$ 有限制，比如小于等于 $t$，$j$ 随随心所欲。转移到 $01$ 的有 $t+1$ 种。转移到 $11$ 的有 $\frac{t(t+1)}{2}$。
4. 两维的限制是 $00$。这个很复杂。设 $i$ 的限制为 $x$，$j$ 的限制为 $y$。我们考虑这个状态转移到 $00/01/10/11$ 四种情况。

	- 4.1 转移到 $00$。这说明，$i$ 选了 $x$，$j$ 选了 $y$。有 $[x \ge y]$ 种。
   - 4.2 转移到 $10$。说明，$i$ 选了小于 $x$，$j$ 选了 $y$。有 $\max\{x-y,0\}$ 种。
   - 4.3 转移到 $01$。说明，$i$ 选了 $x$，$j$ 选了小于 $y$。有 $\min\{x+1,y\}$ 种。
   - 4.4 转移到 $11$。说明，$i$ 选了小于 $x$，$j$ 选了小于 $y$。那么考虑计算 $\sum_{i=0}^{x-1} \min\{i+1,y\}$。如果 $x \le y$，那么这个东西就是 $\frac{x(x+1)}{2}$。否则这个东西是 $\frac{y(y+1)}{2}+y(x-y)$。
   
然后代码非常好写。顺便通过了弱化版 [P6669](https://www.luogu.com.cn/problem/P6669)。

我爱分讨。

校内模拟赛给 $k$ 加了一个幂次。大家可以尝试思考一下。

```cpp
#include<bits/stdc++.h>
#define int long long 
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXM=60+5,MOD=1e9+7;
int T,k,n,m,dp[MAXM][2][2];
vector<int> div(int n) {
	vector<int> res;
	while(n) res.push_back(n%k),n/=k;
	return res;	
}
int N[MAXM],M[MAXM],tot;
int sum(int p) {
	int a=p,b=p+1;
	if(a%2==0) a/=2; else b/=2;
	a%=MOD,b%=MOD;
	return a*b%MOD;	
}
int solve(void) {
	memset(dp,0,sizeof(dp));
	vector<int> vc1=div(n),vc2=div(m);
	tot=max(vc1.size(),vc2.size());
	memset(dp,0,sizeof(dp)),memset(N,0,sizeof(N)),memset(M,0,sizeof(M));
	ffor(i,0,vc1.size()-1) N[tot-i]=vc1[i];
	ffor(i,0,vc2.size()-1) M[tot-i]=vc2[i];
	dp[0][0][0]=1;
	ffor(i,0,tot-1) {
		dp[i+1][1][1]=(dp[i+1][1][1]+dp[i][1][1]*sum(k))%MOD;
		
		dp[i+1][1][1]=(dp[i+1][1][1]+(sum(M[i+1])+M[i+1]*(k-M[i+1]))%MOD*dp[i][1][0])%MOD;
		dp[i+1][1][0]=(dp[i+1][1][0]+(k-M[i+1])*dp[i][1][0])%MOD;
		
		dp[i+1][0][1]=(dp[i+1][0][1]+(N[i+1]+1)*dp[i][0][1])%MOD;
		dp[i+1][1][1]=(dp[i+1][1][1]+sum(N[i+1])*dp[i][0][1])%MOD;
		
		int x=N[i+1],y=M[i+1];
		dp[i+1][0][0]=(dp[i+1][0][0]+dp[i][0][0]*(x>=y))%MOD;
		dp[i+1][1][0]=(dp[i+1][1][0]+dp[i][0][0]*max(0ll,x-y))%MOD;
		dp[i+1][0][1]=(dp[i+1][0][1]+dp[i][0][0]*min(x+1,y))%MOD;
		if(x<=y) dp[i+1][1][1]=(dp[i+1][1][1]+sum(x)*dp[i][0][0])%MOD;
		else dp[i+1][1][1]=(dp[i+1][1][1]+(sum(y)+y*(x-y))%MOD*dp[i][0][0])%MOD;
	}
	int al=(dp[tot][0][0]+dp[tot][0][1]+dp[tot][1][0]+dp[tot][1][1])%MOD;
	int cnt=sum(m+1)+(n-m)%MOD*((m+1)%MOD)%MOD-al;
	return (cnt%MOD+MOD)%MOD;
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>T>>k;
	while(T--) cin>>n>>m,m=min(m,n),cout<<solve()<<'\n';	
	return 0;
}
```

---

## 作者：Union_Find (赞：3)

直接做是难做的，但是我们考虑到有 $C_x^y \bmod k$ 的形式，考虑用 $\text{Lucas}$ 定理。

$$C_x^y \bmod k= C_{ \bmod k}^{y \bmod k} \times C_{\left \lfloor x/k \right \rfloor}^{\left \lfloor y/k \right \rfloor}$$

因为要求 $C_x^y \bmod k = 0$，所以一定是 $C_{x \bmod k}^{y \bmod k}$，因为如果只有 $x<y$，$C_x^y$ 才会等于 $0$。

于是我们可以对 $x,y$ 按照 $k$ 进制拆分。假设 $x$ 的 $k$ 进制拆分的第 $i$ 为是 $a_i$，$y$ 的 $k$ 进制拆分的第 $i$ 位是 $b_i$。其中 $a_0,b_0$ 是最低位。

于是我们就知道，只要让 $\exists i,a_i < b_i$，就会使得 $C_x^y \bmod k = 0$。存在是困难的，正难则反，去计算 $\forall i,a_i \ge b_i$ 的方案数，用总的方案数减去。

定义 $f_{i,0/1,0/1}$ 表示考虑到第 $i$ 为，$x$ 是否顶到上界，$y$ 是否顶到上界。

首先，如果 $m>n$，多出来的是无意义的，所以一开始 $m \gets \min(n,m)$。

然后就开始快乐推式子。

$$f_{i,1,1} \gets f_{i+1,1,1}[a_i\ge b_i]$$

如果两个数字都是上界，那么上一次一定是上界，并且这一次也是上界。所以只要考虑当前位的大小。

$$f_{i,1,0} \gets f_{i+1,1,1} \times \min(a_i + 1, b_i) + f_{i+1,1,0} \times (a_i + 1)$$

如果只有 $x$ 顶到上界，说明上一位 $x$ 也是上界，考虑 $y$ 是否顶到上界。如果 $y$ 上一位顶到了上界，那么这一位可以 $y$ 选的数字同时受到 $y \le x$ 和 $y \le m$ 的限制，所以是 $min(a_i+1,b_i)$。

而如果上一次 $y$ 没有顶到上界，这一位就只受到 $y \le x$ 的限制。

$$f_{i,0,1} \gets f_{i+1,1,1} \times \max(a_i - b_i,0) + f_{i+1,0,1} \times (k-b_i)$$

如果只有 $y$ 顶到上界，那么上一位 $y$ 也是上界。如果 $x$ 上一位是上界，那么 $x$ 有一个 $n$ 的上界和 $x \ge y$ 的下界，所以有 $\max(a_i - b_i,0)$ 中选择方法。

如果上一次没有顶到上界，那么没有了 $n$ 的上界。所以有 $k - b_i$ 种选法，毕竟 $k$ 进制只能小于 $k$。


在推到 $f_{i,0,0}$ 之前，我们先定义 $G(n,m)$ 函数方便计算。
$$G(n,m) = \sum_{i=0}^{n-1} \sum_{j=0}^{m-1} [i \ge j]$$

其中可以证明如下结果。
$$G(n,m) =\left\{\begin{matrix}
\frac{m(m+1)}{2}+(n-m)m \hspace{1cm}n \ge m
\\ 
\frac{n(n+1)}{2} \hspace{3.15cm}n<m

\end{matrix}\right.$$

首先证明上面式子是简单的。如果 $n \ge m$，那么写算 $i,j$ 都不大于 $m$ 的，再加上 $i$ 大于 $m$，$j$ 不大于 $m$。

如果 $n < m$，那么直接 $m \gets \min(n,m)$，再带入上式，得到新的结果。实际上代码实现可以直接 $m \gets \min(n,m)$，然后带上面的公式。

$$f_{i,0,0} \gets f_{i+1,1,1} \times G(a_i,b_i) + f_{i+1,1,0} \times G(a_i,k) + f_{i+1,0,1} \times G(k,b) + f_{i,0,0} \times G(k,k)$$

这个式子就是好推的，因为两个都无法确定，所以只要选择的数字满足 $a_i \ge b_i$ 即可。当然，这一位的上界取决于上一位是否顶到了上界，所以系数是不一样的。

最后就是 $O(T\log_k n)$ 的时间复杂度，带上一个 $4$ 的常数。这里理论最差是 $k = 2,O(T\log n)$。

但是我们似乎忘了什么。我们求的是 $\exists i,a_i < b_i$，要用总的减去。总的方案数其实就是选择 $x,y$ 使得 $x \le y$ 的方案数，与 $G$ 是一样的，直接用，但是注意写的时候要先取 $\min$ 再模。

```cpp
il int G(ll n, ll m){
	m = min(n, m), n %= P, m %= P;
	return ((1ll * m * (m + 1) % P * inv2 % P + 1ll * (n - m) * m % P) % P + P) % P;
}
```

因为 $n,m$ 是 $10^{18}$ 级别，直接乘起来会炸 $\text{long long}$，所以要取模。如果先取模，会影响大小关系。

最后就是真的结束了。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define il inline
il ll rd(){
	ll s = 0, w = 1;
	char ch = getchar();
	for (;ch < '0' || ch > '9'; ch = getchar()) if (ch == '-') w = -1;
	for (;ch >= '0' && ch <= '9'; ch = getchar()) s = ((s << 1) + (s << 3) + ch - '0');
	return s * w;
}
const int P = 1e9 + 7, inv2 = 500000004;
int T, k, f[75][2][2], L, A[75], B[75];
ll n, m;
il void add(int &x, int y){x = ((x + y) % P + P) % P;}
il int G(ll n, ll m){
	m = min(n, m), n %= P, m %= P;
	return ((1ll * m * (m + 1) % P * inv2 % P + 1ll * (n - m) * m % P) % P + P) % P;
}
il int max(int a, int b){return (a > b) ? a : b;}
il int min(int a, int b){return (a < b) ? a : b;}
int Main(){
	n = rd(), m = rd(), m = min(n, m);
	memset (f, 0, sizeof f), memset (A, 0, sizeof A), memset (B, 0, sizeof B);
	int i, j, ans = G(n + 1, m + 1);
	for (i = 0; n; n /= k, i++) A[i] = n % k;
	for (j = 0; m; m /= k, j++) B[j] = m % k;
	L = max(i, j);
	f[L + 1][1][1] = 1;
	for (int i = L; i >= 0; i--){
		int a = A[i], b = B[i];
		if (a >= b) add(f[i][1][1], f[i + 1][1][1]);
		add(f[i][1][0], 1ll * f[i + 1][1][1] * min(a + 1, b) % P), add(f[i][1][0], 1ll * f[i + 1][1][0] * (a + 1) % P);
		add(f[i][0][1], 1ll * f[i + 1][1][1] * max(a - b, 0) % P), add(f[i][0][1], 1ll * f[i + 1][0][1] * (k - b) % P);
		add(f[i][0][0], 1ll * f[i + 1][1][1] * G(a, b) % P), add(f[i][0][0], 1ll * f[i + 1][1][0] * G(a, k) % P);
		add(f[i][0][0], 1ll * f[i + 1][0][1] * G(k, b) % P), add(f[i][0][0], 1ll * f[i + 1][0][0] * G(k, k) % P);
	}
	add(ans, -f[0][1][1]), add(ans, -f[0][1][0]), add(ans, -f[0][0][1]), add(ans, -f[0][0][0]);
	printf ("%d\n", ans);
	return 0;
}
int main(){
	for (T = rd(), k = rd(); T--;) Main(); 
	return 0;
}

```

---


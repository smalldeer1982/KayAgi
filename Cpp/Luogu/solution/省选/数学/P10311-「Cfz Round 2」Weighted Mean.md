# 「Cfz Round 2」Weighted Mean

## 题目描述

给定一个长度为 $n$ 的序列 $a$ 和一个整数 $m$，保证序列 $a$ 中的每个元素均为不大于 $m$ 的正整数，且每个元素互不相等。

你需要构造一个长度为 $n$ 的序列 $b$，满足：

- 序列 $b$ 中的每个元素均为不大于 $m$ 的正整数；
- $\dfrac{\sum\limits_{i=1}^n (a_i \cdot b_i)}{\sum\limits_{i=1}^n b_i}$ 为整数，即 $a_i$ 的权为 $b_i$ 时，序列 $a$ 的加权平均数为整数；
- 不存在有序三元整数组 $(i,j,k)$，满足 $1\le i<j<k\le n$ 且 $b_i=b_j=b_k$；

或报告无解。

## 说明/提示

#### 「样例解释 #1」

对于第 $1$ 组测试数据，给出的样例的加权平均数为 $\dfrac{1 \times 1+2 \times 2 + 3 \times 1}{1+2+1}=2$，为整数。

输出 `1 5 1` 也视作正确，其加权平均数为 $2$。

但是输出 `1 6 1` 不正确，虽然其加权平均数为 $2$，但是 $b_2>5$。

输出 `1 2 3` 也不正确，其加权平均数为 $\dfrac{7}{3}$，不为整数。

输出 `1 1 1` 也不正确，虽然其加权平均数为 $2$，但是存在有序三元组 $(1,2,3)$ 满足 $1 \leq 1 < 2 < 3 \leq 3$ 且 $b_1=b_2=b_3$。

对于第 $2$ 组测试数据，可以证明不存在满足条件的序列 $b$。

对于第 $3$ 组测试数据，给出的样例的加权平均数为 $\dfrac{1 \times 1+2 \times 1 + 5 \times 3+9 \times 4}{1+1+3+4}=6$，为整数。

#### 「数据范围」

设 $\sum n$ 表示单个测试点中 $n$ 的和。

对于所有数据，$1 \le T \le 1000$，$1 \le n \le 10^6$，$1 \le a_i \le m \le 10^9$，$\sum n \le 10^6$，保证序列 $a$ 中的每个元素间互不相等。

**只有你通过本题的所有测试点，你才能获得本题的分数。**

## 样例 #1

### 输入

```
3
3 5
1 2 3
2 2
1 2
4 100000
1 2 5 9```

### 输出

```
1 2 1
-1
1 1 3 4
```

# 题解

## 作者：McIron233 (赞：15)

数据人题解。

考虑到 $a_i$ 的顺序并不影响答案的相对位置，因此对 $a_i$ 从小到大排序。

从题目的第二个条件入手：

>    $\dfrac{\sum\limits_{i=1}^n (a_i \cdot b_i)}{\sum\limits_{i=1}^n b_i}$ 为整数，即 $a_i$ 的权为 $b_i$ 时，序列 $a$ 的加权平均数为整数。

设这个加权平均数为 $\lambda$，那么有：
$$
\begin{aligned}
&\ \frac{\sum\limits_{i=1}^n (a_i \cdot b_i)}{ \sum\limits_{i=1}^n b_i}=\lambda \\
&\ \sum\limits_{i=1}^n (a_i \cdot b_i)=\lambda \sum\limits_{i=1}^n b_i \\
&\ \sum\limits_{i=1}^n (a_i \cdot b_i)=\sum\limits_{i=1}^n (\lambda b_i) \\
&\ \sum\limits_{i=1}^n (a_i \cdot b_i)-\sum\limits_{i=1}^n (\lambda b_i)=0 \\
&\ \sum\limits_{i=1}^n [b_i (a_i - \lambda)]=0
\end{aligned}
$$
因此当 $\lambda$ 确定，整个序列 $c_i=a_i - \lambda$ 就确定，相应的 $b_i$ 也就有比较简单的构造方案了，问题转化成找到一个合适的 $\lambda$。显然，当 $\lambda$ 离 $a_i$ 中位数越近，序列 $b_i$ 越好构造。

考虑直接取中位数，那么我们需要根据 $n$ 的奇偶性分类讨论：

## $n$ 是奇数

那么直接取 $\lambda = a_{\lceil \frac{n}{2} \rceil}$，然后得到序列 $c_i$。显然，$c_i$ 是单调递增的，且前 $\lfloor \dfrac{n}{2} \rfloor$ 个元素都是负数，后 $\lfloor \dfrac{n}{2} \rfloor$ 个元素都是正数。所以我们可以在 $i \not= \dfrac{n}{2}$ 时直接取 $b_i={| c_{n-i+1} |}$；在 $i = \dfrac{n}{2}$ 时，直接取 $b_i=m$。

证明：第二个条件已由刚才的构造得到满足。

对于第一个条件“序列 $b$ 中的每个元素均为不大于 $m$ 的正整数”，容易发现 $| a_n-\lambda | < m$ 且 $| a_1-\lambda | < m$，那么第一个条件也就能进而成立。

对于第三个条件“不存在有序三元整数组 $(i,j,k)$，满足 $1\le i<j<k\le n$ 且 $b_i=b_j=b_k$”，我们发现由于 $a_i$ 是互不相同的，因此 $c_i$ 中绝对值相等的数也最多只有 $2$ 个，不会达到 $3$ 个，此外，$a_n - \lambda <m$，所以 $c_i$ 中没有绝对值为 $m$ 的元素。故第三个条件同样满足。

举一个构造例子。当 $a_i=\{1,3,4,6,7\}$，$m=7$ 来说，$\lambda=a_3=4$，得到 $c_i=\{-3,-1,0,2,3\}$，对应有：$b_1=|c_{5-1+1}|=|c_5|=3$，其余元素同理，且 $b_3=m=7$，于是 $b_i=\{3,2,7,1,3\}$。

## $n$ 是偶数

这时候需要进行简单转化。容易发现当序列 $a_i$ 中间两个数不连续时直接取 $\lambda$ 满足 $a_{\frac{n}{2}}<\lambda<a_{\frac{n}{2}+1}$，然后类比 $n$ 是奇数的方法来构造即可，不同点是不需要确定 $b_\frac{n}{2}$ 的值。

如果中间两个元素连续，考虑取 $\lambda$ 是中间两个元素中的一个，接下来使用如下的构造方法。

### 构造方法

这里取 $\lambda=a_{\frac{n}{2}}$，那么得到的序列 $c_i$ 中负数元素数量比正数元素数量少 $1$ 个。考虑合并两个正数元素。容易发现此时 $c_{\frac{n}{2}+1}=1$，因此将 $c_{\frac{n}{2}+1}$ 与 $c_n$ 合并，具体方式是：$c_n \leftarrow c_n+1$，然后与 $n$ 是奇数的相似方法（**有不同点**）构造，再 $b_{\frac{n}{2}+1} \leftarrow b_n$ 就完成了。

显然，在这种情况下 $n=2$ 时是无解的，证明可以从另一个角度——分离常数法来解释。

不同点：由于第三个条件“不存在有序三元整数组 $(i,j,k)$，满足 $1\le i<j<k\le n$ 且 $b_i=b_j=b_k$”，我们为合并后的 $c_n$ 配对时，需要在 $[1,n)$ 中寻找一个合适的 $c_i$ 满足 $c_i \not=c_n$。所以有可能出现找不到这样的 $c_i$ 的情况，那么取 $\lambda=a_{\frac{n}{2}}$ 时就不可行了，换用 $\lambda=a_{\frac{n}{2}+1}$，然后类比该构造方法。可以证明两个 $\lambda$ 中至少有一个是可行的。

### 关于两个 $\lambda$ 至少一者可行的证明

这里给出两个 $\lambda$ 取值时得到的 $c_i$ 序列：

| $\lambda$ 取值/下标 | $1$ | $2$ | $\cdots$ | $\dfrac{n}{2}$ | $\dfrac{n}{2}+1$ | $\cdots$ | $n-1$ | $n$ |
| :-----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| $a_{\frac{n}{2}}$ | $x_1$ | $x_2$ | $\cdots$ | $0$ | $1$ | $\cdots$ | $x_{n-1}$ | $x_n$ |
| $a_{\frac{n}{2}+1}$ | $x_1-1$ | $x_2-1$ | $\cdots$ | $-1$ | $0$ | $\cdots$ | $x_{n-1}-1$ | $x_n-1$ |

注：$x_i$ 互不相同。

根据 $c_i$ 的单调递增性，两个 $\lambda$ 都不合法的必要条件是：

$$
\begin{cases}
x_1+1+x_n=0 \\
x_1-1-1+x_n-1=0
\end{cases}
$$

而这个方程组没有解。所以两个 $\lambda$ 中至少有一者合法。

## 构造时间复杂度

单组测试数据的时间复杂度是 $O(n \log n)$，瓶颈在排序。

---

## 作者：xixisuper (赞：2)

# P10311 「Cfz Round 2」Weighted Mean 题解

我爱构造。

以此题解纪念我那失去的半个上午加半个下午。

## 思路

转述一下题意，给定一个长度为 $n$ 的数列 $a$，值域为 $1$ 到 $m$ 的正整数，你需要构造出一个长度为 $n$ 的数列 $b$，并满足如下三个条件：


- 序列 $b$ 的值域为 $1$ 到 $m$ 的正整数。
- $\dfrac{\sum\limits_{i=1}^n (a_i \cdot b_i)}{\sum\limits_{i=1}^n b_i}$ 为整数，即 $a_i$ 的权为 $b_i$ 时，序列 $a$ 的加权平均数为整数。
- 不存在有序三元整数组 $(i,j,k)$，满足 $1\le i<j<k\le n$ 且 $b_i=b_j=b_k$。

首先看到一个大大的分式，并且上下都是求和，肯定是要把分母上的求和式乘过去的，我们不妨设：

$$\dfrac{\sum\limits_{i=1}^n (a_i \cdot b_i)}{\sum\limits_{i=1}^n b_i}=x$$

然后变换几下：

$$
\begin{aligned}
\dfrac{\sum\limits_{i=1}^n (a_i \cdot b_i)}{\sum\limits_{i=1}^n b_i}&=x\\
\sum\limits_{i=1}^n (a_i \cdot b_i)&=x\sum\limits_{i=1}^n b_i\\
\sum\limits_{i=1}^n (a_i-x) \cdot b_i&=0
\end{aligned}
$$

不难发现在最后的求和式中，$b_i$ 恒正，所以想要使最终答案为 $0$ 最好的方式是调节 $x$ 的大小，显然我们希望 $a_i-x$ 为负的部分和为正的部分差不多，所以说考虑让 $x$ 取 $a$ 的中位数。

在下文中，我们默认 $a$ 数组是排过序的（单调递增）。在下文中，我们用 $k_i$ 表示 $a_i-x$。

### $n$ 为奇数

此时 $x=a_{\frac{n+1}{2}}$，则 $k_i=a_{i}-x=a_{i}-a_{\frac{n+1}{2}}$。

显然我们可以根据 $k$ 的正负性将其分成三段，分别是 $[1,\frac{n+1}{2}-1]$、$\{\frac{n+1}{2}\}$、$[\frac{n+1}{2}+1,n]$，由于此时 $k$ 值为正的部分与 $k$ 的值为负的部分元素个数相等，所以我们考虑将他们两两配对，然后单独给 $k_{\frac{n+1}{2}}$ 配上一个在之前都没有出现过的值即可。

根据此思路，我们便可以得出这样一组构造：

$$
b_i=
\begin{cases}
|k_{n-i+1}| & i\not=\frac{n+1}{2}\\
m & i=\frac{n+1}{2}
\end{cases}
$$

分别考虑此时 $b$ 对应的三个性质是否满足：

- 首先，由于 $a_i\in[1,m]$，所以 $k_i\in[1-m,m-1]\Rightarrow|k_i|\in[0,m]$，而唯一一个 $k_i=0$ 的位置上我们给其赋上的值为 $m$，于是此时 $b$ 满足性质一。
- 其次，根据构造可知 $\forall i\not=\frac{n+1}{2},k_i\cdot b_i+k_{n-i+1}\cdot b_{n-i+1}=0$，所以性质二显然成立。
- 最后，由于 $k$ 单调递增，所以取绝对值后最多会出现两个值相同的数，不会出现超过两个相同的数，而 $m$ 又必然不会出现在 $k$ 中，所以性质三成立。

综上，我们得到了 $n$ 为奇数时的构造。

### $n$ 为偶数

如果 $a_{\frac{n}{2}+1}-a_{\frac{n}{2}}>1$，证明我们可以取 $x=a_{\frac{n}{2}}+1$ 使得 $k$ 按正负性分成两段，且这两段元素个数一样，于是我们构造：

$$
b_i=|k_{n-i+1}|
$$

分别考虑此时 $b$ 对应的三个性质是否满足：

- 首先，由于 $a_i\in[1,m]$，所以 $k_i\in[1-m,m-1]\Rightarrow|k_i|\in[0,m]$，而由于不存在 $k_i=0$，于是此时 $b$ 满足性质一。
- 其次，根据构造可知 $\forall i,k_i\cdot b_i+k_{n-i+1}\cdot b_{n-i+1}=0$，所以性质二显然成立。
- 最后，由于 $k$ 单调递增，所以取绝对值后最多会出现两个值相同的数，不会出现超过两个相同的数，所以性质三成立。

好，如果本题到此为止，那么这将不是一道紫题，而是一道黄 or 绿题，但很显然我们并没有考虑完，直接进入下面最难的一部分构造。

如果 $a_{\frac{n}{2}+1}-a_{\frac{n}{2}}=1$（$n\not = 2$），即数列 $a$ 的中间两个数是连续的，那么我们无法取一个合适的 $x$，使得 $k$ 正好分成正负两部分，且这两部分的元素个数是相等的，本着尽量缩小两部分差异的原则，我们先考虑取 $x=a_{\frac{n}{2}}$。

观察此时 $k$ 变成了什么样：

$$
\{k_1,k_2,k_3,\cdots,0,1,\cdots,k_{n-2},k_{n-1},k_{n}\}
$$

注意到此时 $k$ 的正数部分要比负数部分多一个数，并且我们能够保证 $k_{\frac{n}{2}+1}=1$，我们不妨把 $k_n$ 与这个 $1$ 视为是同一个数，最后只需要把 $b_n$ 与 $b_{\frac{n}{2}+1}$ 赋成同一个数即可。仍旧套用之前的方案，考虑构造一组方案使得 $\forall i,\exist j,b_i=|k_j|,b_j=|k_i|,b_ik_i+b_jk_j=0$，且 $i$ 到 $j$ 为满射。我们把 $i$ 与 $j$ 的取值集合列出来：

$$i\in\{1,2,3,\cdots,\frac{n}{2}-1\}$$
$$j\in\{\frac{n}{2}+2,\frac{n}{2}+3,\cdots,n\}$$

由于我们要满足第三条性质，所以说 $n$ 所对应的那个 $i$，其 $|k_i|$ 的值不能出现在 $|k_j|$ 中，否则的话必然会出现 $3$ 个相等的值，如果此时存在这样的一个 $i$，则我们就可以实现构造，否则的话我们所取的 $x$ 值便无法满足构造。换句话说，如果下述两个集合完全相等，则我们取的 $x$ 值是无法满足构造的。

$$|k_i|\in\{|k_1|,|k_2|,|k_3|,\cdots,|k_{\frac{n}{2}-1}|\}$$
$$|k_j|\in\{|k_{\frac{n}{2}+2}|,|k_{\frac{n}{2}+3}|,\cdots,|k_n|\}$$

于是我们考虑改变 $x$ 的值为 $a_{\frac{n}{2}+1}$，为了方便计算，我们沿用上述 $k$ 的值，并不改变其含义。此时 $k$ 的负数部分要比正数部分多一个数，并且我们能够保证 $k_{\frac{n}{2}}=-1$，我们不妨把 $k_1$ 与这个 $-1$ 视为是同一个数，最后只需要把 $b_1$ 与 $b_{\frac{n}{2}}$ 赋成同一个数即可。我们能够发现原来的取值集合发生了改变：

$$|k_i|\in\{|k_1|+1,|k_2|+1,|k_3|+1,\cdots,|k_{\frac{n}{2}-1}|+1\}$$
$$|k_j|\in\{|k_{\frac{n}{2}+2}|-1,|k_{\frac{n}{2}+3}|-1,\cdots,|k_n|-1\}$$

显然我们让 $|k_i|$ 的取值集合所有数变大了 $1$，让 $|k_j|$ 的取值集合所有的数都减小了 $1$，如果原来的两集合满足一一对应的关系的话，显然新的集合不满足一一对应关系了，那么就一定存在某个 $j$，使得 $|k_j|$ 一定不在 $|k_i|$ 当中。

**上面的一长串论证可以总结成一句话，$x=a_{\frac{n}{2}}$ 与 $x=a_{\frac{n}{2}+1}$ 至少有一个能够得出满足条件的构造。**

这个时候，我们只需要对两种情况都考虑一遍就行了，那么怎么把上述抽象过程搬到代码上呢？

我们考虑把 $|k_i|$ 丢进 `set` 中维护，然后随便选 $j$ 使其跟 $i$ 相匹配，但是要钦定 $1$ 或者 $n$ 相匹配的情况。如果发现当前 $x$ 的取值无法满足性质三，只需要更换 $x$ 的取值即可。

分别考虑此时 $b$ 对应的三个性质是否满足：

- 首先，由于 $a_i\in[1,m]$，所以 $k_i\in[1-m,m-1]\Rightarrow|k_i|\in[0,m]$，而唯一一个 $k_i=0$ 的位置上我们给其赋上的值为 $m$，于是此时 $b$ 满足性质一。
- 其次，根据构造可知，存在 $i\rightarrow j$ 的满射满足 $b_ik_i+b_jk_j=0$，对于 $k_i=0$ 来说，$k_im=0$，所以性质二成立。
- 最后，由于 $k$ 单调递增，所以取绝对值后最多会出现两个值相同的数，而我们钦定的 $1$ 或 $n$ 对应的值仅存在在另一个集合中，则不会出现超过两个相同的数，所以性质三成立。

综上，我们便得到了所有（除无解外）$n$ 为偶数的构造。

### 关于无解的情况

从构造出发我们发现，当 $n$ 为奇数时一定有解，当 $n$ 为偶数且 $a_{\frac{n}{2}+1}-a_{\frac{n}{2}}>1$ 时一定有解，因为这些情况必然能够将 $k$ 分为正负两部分。

当 $n$ 为偶数且 $a_{\frac{n}{2}+1}-a_{\frac{n}{2}}=1$ 时，如果 $n\not =2$，也一定是有解的，因为 $|k_i|$ 与 $|k_j|$ 之间满足条件的满射关系存在。

而对于 $n=2$ 时的上述情况，根本不存在 $|k_i|$ 与 $|k_j|$ 的取值集合，或者说这两者的集合都是空集，所以我们无法找到满足条件的满射，也就是无解了。

当然我们也可以换一种更简洁的方式理解，当 $n=2$ 时我们能够把性质二的式子视为这样：

$$
(a_1-x)b_1+(a_1+1-x)b_2=0
$$

由于 $b_1,b_2$ 恒正，我们便能够分讨：

- 当 $x<a_1$ 时，两项的结果必然恒正，不可能等于 $0$。
- 当 $x=a_1$ 时，第一项值为 $0$，第二项的结果恒正，则和必然恒正，不可能等于 $0$。
- 当 $x=a_1+1$ 时，第一项的结果恒负，第二项的值为 $0$，则和必然恒负，不可能等于 $0$。
- 当 $x>a_1+1$ 时，两项的结果必然恒负，不可能等于 $0$。

综上所述，不存在合法的构造使得当前的 $b$ 满足性质二，故此类情况无解。

## 代码

用到了排序和 `set`，因此时间复杂度为 $O(n\log n)$。

这是一道合格的检验代码能力的题，如果可以的话推荐自己写一写。

```cpp
#include <iostream>
#include <algorithm>
#include <set>
#define ll int
using namespace std;
const ll N=1e6+10;
struct node{ll dat,id;}a[N],b[N];
inline bool cmp1(node a,node b){return a.dat<b.dat;}
inline bool cmp2(node a,node b){return a.id<b.id;}
ll n,m,k,c[N];
bool vis[N];
inline ll jue(ll x){return (x<0)?(-x):x;} 
void solve(){
	cin>>n>>m;
	for(ll i=1;i<=n;i++){cin>>a[i].dat;a[i].id=i;}
	sort(a+1,a+1+n,cmp1);
	for(ll i=1;i<=n;i++) b[i].id=a[i].id;
	if(n==2&&a[2].dat-a[1].dat==1){cout<<"-1\n";return;}
	if(n&1){
		for(ll i=1;i<=n;i++){
			b[i].dat=jue(a[n-i+1].dat-a[n/2+1].dat);
			if(i==n/2+1) b[i].dat=m;
		}
	}
	else{
		if(a[n/2+1].dat-a[n/2].dat>1){
			k=a[n/2].dat+1;
			for(ll i=1;i<=n;i++) b[i].dat=jue(a[n-i+1].dat-k);
		}
		else{
			//x 取 n/2   n/2+1:1  n:
			k=a[n/2].dat;
			for(ll i=1;i<=n;i++) c[i]=jue(a[i].dat-k);
			c[n]+=1;
			set<ll> st;
			for(ll i=1;i<n/2;i++) st.insert(c[i]);
			for(ll i=n/2+2;i<=n;i++) st.erase(c[i]);
			if(st.empty()) goto nextsol;
			for(ll i=1;i<n/2;i++){
				if(*st.begin()==c[i]){
					b[n].dat=c[i];
					b[n/2+1].dat=c[i];
					b[i].dat=c[n];
					vis[i]=vis[n/2+1]=vis[n]=1;
				}
			}
			st.clear();
			vis[n/2]=1;b[n/2].dat=m;
			for(ll i=1;i<=n;i++){
				if(vis[i]) continue;
				if(i<n/2) st.insert(i);
				else{
					b[i].dat=c[*st.begin()];
					b[*st.begin()].dat=c[i];
					st.erase(st.begin());
				}
			} 
			goto endthesol;
			nextsol:;//x 取 n/2+1 n/2:1 1: 
			k=a[n/2+1].dat;
			for(ll i=1;i<=n;i++) c[i]=jue(a[i].dat-k);
			c[1]+=1;
			for(ll i=n/2+2;i<=n;i++) st.insert(c[i]);
			for(ll i=1;i<n/2;i++) st.erase(c[i]);
			for(ll i=n/2+2;i<=n;i++){
				if(*st.begin()==c[i]){
					b[1].dat=c[i];
					b[n/2].dat=c[i];
					b[i].dat=c[1];
					vis[i]=vis[n/2]=vis[1]=1;
				}
			}
			st.clear();
			vis[n/2+1]=1;b[n/2+1].dat=m;
			for(ll i=n;i>=1;i--){
				if(vis[i]) continue;
				if(i>n/2+1) st.insert(i);
				else{
					b[i].dat=c[*st.begin()];
					b[*st.begin()].dat=c[i];
					st.erase(st.begin());
				}
			} 
		}
	}
	endthesol:;
	sort(b+1,b+1+n,cmp2);
	for(ll i=1;i<=n;i++){
		cout<<b[i].dat<<' ';
		vis[i]=0;
	}
	cout<<"\n";
	return;
}
ll T;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>T;
	while(T--) solve();
	return 0;
}
```

---


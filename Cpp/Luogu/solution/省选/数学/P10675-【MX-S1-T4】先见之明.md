# 【MX-S1-T4】先见之明

## 题目背景

原题链接：<https://oier.team/problems/S1D>。

## 题目描述

给定 $n$ 个非负整数 $a_1, a_2, \ldots, a_n$。有 $q$ 次询问，每次询问：

- 给定一个非负整数 $k$，你需要从 $2^{a_1}, \ldots, 2^{a_n}$ 中取出一部分（即一个子集，可以为空），使得它们的和 $\ge k$。
- 在保证和 $\ge k$ 的前提下，你需要最小化它们的和。你只需求出这个最小化的和。
- $k$ 以二进制的形式给出，具体地，以 $k = \sum_{i = 1}^{m} 2^{p_i}$ 的形式给出，保证 $p_i$ 均为非负整数且严格单调递减，即 $p_i > p_{i + 1}$。

由于答案可能很大，你只需要输出对 $998244353$ 取模后的结果。

若无法从 $2^{a_1}, \ldots, 2^{a_n}$ 中取出一部分使得它们的和 $\ge k$，该询问输出 $-1$。

## 说明/提示

__【样例解释 1】__

每个 $2^{a_i}$ 分别为 $1, 1, 2$。三次询问的 $k$ 为：$0,3,8$。具体如下：
- $k = 0$：取空。
- $k = 3$：取 $1, 2$ 即可。
- $k = 8$：无解。

__【样例解释 2】__

此样例满足子任务 $1$ 的限制。

__【数据范围】__

__本题使用子任务捆绑测试。__

对于 $100\%$ 的数据，$1\le n,q\le 10^6$，$0\le m\le 10^6$，$\sum m\le 5\times 10^6$，$0\le a_i,p_i\le 10^6$，$p_i>p_{i+1}$。

表格留空表示无额外限制。

| 子任务编号 | $n\le $        | $q\le $        | $\sum m\le $     | $a_i,p_i \le $ | 特殊性质       | 分值 |
| ---------- | -------------- | -------------- | ---------------- | -------------- | -------------- | ---- |
| $1$        | $20$           |                |                  | $60$           |                | $10$ |
| $2$        | $120$          |                |                  | $60$           |                | $10$ |
| $3$        | $5\times 10^3$ | $5\times 10^3$ | $2.5\times 10^4$ | $5\times 10^3$ |                | $20$ |
| $4$        | $10^5$         | $10^5$         | $5\times 10^5$   | $10^5$         |                | $20$ |
| $5$        |                |                |                  |                | $m\le 2$       | $10$ |
| $6$        |                |                |                  |                | $a_i$ 互不相同 | $10$ |
| $7$        | $10^6$         | $10^6$         | $5\times 10^6$   | $10^6$         |                | $20$ |

由于本题输入量较大，我们在下发文件中提供了 `fast_read.cpp` 可以选择使用（注意在 C++98 标准下可能无法编译通过）。

保证时间限制达到了没有使用特殊的读入优化的 std 的两倍。

## 样例 #1

### 输入

```
3 3
0 0 1
0
2 1 0
1 3
```

### 输出

```
0
3
-1
```

## 样例 #2

### 输入

```
见下发文件。```

### 输出

```
见下发文件。```

# 题解

## 作者：C1942huangjiaxu (赞：7)

有意思的题。

贪心的考虑，可以发现，如果不能相等，那么答案的形式一定是，$\exist 1\le j\le m$，$i\lt j$ 的 $p_i$ 都恰好取到，同时存在 $p_{j-1}\ge a_u\gt p_j$ 没被使用，即 $ans=\sum_{i=1}^{j-1} 2^{p_i}+2^{a_u}$。

求出 $a_u$ 了我们就可以得出答案，那么问题在于求出 $a_u$ 的最小值。

我们定义，**如果 $j$ 满足，$\sum_{i=j}^m 2^{p_i}\gt \sum_{a_x\le p_j} 2^{a_x}$，那么 $j$ 是关键的。**

先给出结论，我们找到最小的关键位置 $j$，那么 $a_u=\min_{a_x\gt p_j} a_x$。

首先容易说明这是 $a_u$ 的下界，因为这意味着 $[j,m]$ 的后缀必须用 $\gt p_j$ 的 $a_x$ 覆盖。

现在我们证明去除 $a_u$ 后，$\forall 1\le i\lt j$，$p_i$ 能被恰好表示。

我们先证明如果**不存在关键位置，那么答案一定能取等。**

考虑归纳，可以发现对于 $p_m$，我们一定能取等，那么我们凑出 $p_m$ 后，删除 $p_m$ 和用于凑 $p_m$ 的 $a$ 后，变成了一个 $m-1$ 的子问题，同时仍然不存在关键位置。

那么考虑 $2^{p_j+1}\gt \sum_{i=j}^m 2^{p_i}\gt \sum_{a_x\le p_j} 2^{a_x}$，也就是说，$a_x\le p_j$ 的 $a$ 对于 $\gt p_j$ 的位是没有影响的，那么去除 $a_u$ 和 $p_j\sim p_m$ 后，$[1,j-1]$ 依旧不是关键的，因为 $[j,m]$ 的后缀必定要用一个 $\ge a_u$ 的数来覆盖掉，那么可以类似上面的归纳证明，$[1,j-1]$ 是可以取等的。

那么现在的问题在于比较 $\sum_{i=j}^m 2^{p_i}$ 和 $\sum_{a_x\le p_j} 2^{a_x}$ 的大小。

我们先求出 $\sum 2^{a_i}$ 的 2 进制表示，记为 $S$。

同时，我们对于所有 $v$，求出 $\sum_{a_i\le v}$ $2^{a_i}$ 的 2 进制下最高位，记为 $mx_v$。

那么如果 $mx_{p_j}\gt p_j$，显然 $j$ 不是关键位置。

否则等价于 $S$ 的 $[p_j,0]$ 后缀和 $p$ 的 $[j,m]$ 后缀比较大小，通过一些预处理就可以 $O(m)$ 递推出结果。

时间复杂度 $O(n+V+\sum m)$。

参考代码

```cpp
#include<bits/stdc++.h>
using namespace std;
char buf[1<<23],*p1=buf,*p2=buf;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<23,stdin),p1==p2)?EOF:*p1++)
template<class rd>
void read(rd &x){
	char c=getchar();
	for(;c<48||c>57;c=getchar());
	for(x=0;c>47&&c<58;c=getchar())x=(x<<1)+(x<<3)+(c^48);
}
const int V=1e6+20,N=V+5,P=998244353;
int n,m,q,a[N],pw[N],c[N],d[N],mx[N],pd[N],pc[N],p[N];
bool f[N];
inline int md(int x){
	return x>=P?x-P:x;
}
void solve(){
	read(m);
	for(int i=1;i<=m;++i)read(p[i]);
	f[m+1]=true;
	int o=m+1,res=0;
	for(int i=m;i;--i){
		if(i<m&&pd[p[i+1]+1]<p[i])f[i+1]=true;
		if(!d[p[i]])f[i]=false;
		else f[i]=f[i+1];
		if(!f[i]&&mx[p[i]]<=p[i])o=i;
	}
	for(int i=1;i<o;++i)res=md(res+pw[p[i]]);
	if(o<=m){
		if(pc[p[o]+1]==-1)res=-1;
		else res=md(res+pw[pc[p[o]+1]]);
	}
	printf("%d\n",res);
}
int main(){
	pw[0]=1;
	for(int i=1;i<N;++i)pw[i]=md(2*pw[i-1]);
	read(n),read(q);
	for(int i=1;i<=n;++i)read(a[i]),++c[a[i]];
	for(int i=0,mp=-1,j;i<=V;++i){
		if(c[i]){
			d[i]+=c[i],j=i;
			while(d[j]>1){
				d[j+1]+=d[j]>>1;
				d[j]&=1,++j;	
			}
			mp=max(mp,j);
		}
		mx[i]=mp;
	}
	pd[V]=pc[V]=-1;
	for(int i=V-1;~i;--i){
		if(d[i])pd[i]=i;
		else pd[i]=pd[i+1];
		if(c[i])pc[i]=i;
		else pc[i]=pc[i+1];
	}
	while(q--)solve();
	return 0;
}
```

---

## 作者：Rain_chr (赞：6)

**前情提要：本文全文都是对 @C1942huangjiaxu 题解所作的注解，加上了本人的一些思考，并将其题解中一笔带过的地方加以说明**

**upd: 2024.10.26 更改了一处笔误，添加了得出结论的过程。**

先摆出题解中的结论：

设 $j$ 是最小满足下式的位置

$$\sum_{i=j}^{m}2^{p_i}>\sum_{a_y\le p_j} 2^{a_y}$$

如果 $j$ 存在，设 $a_x$ 是最小满足 $a_x>p_j$ 的数，答案即为 

$$\sum_{i=1}^{j-1}2^{p_i}+2^{a_x}$$

否则，答案即为

$$\sum_{i=1}^{j-1}2^{p_i}$$

这个结论是怎样猜到的呢？因为我们知道，若要使选出的数之和大于等于 $k$，则必然选出的数与 $k$ 要么完全相等，要么在二进制串的一段前缀中完全相等，并在某一位中我们选定的数字这一位比 $k$ 要大，这就是结论中两种情况答案的计算方式。

接下来，本文将开始证明这一个结论。

**首先证明：若位置 $j$ 不存在，那么答案是 $\sum_{i=1}^{j-1}2^{p_i}$**

我们从最末尾的 $p_m$ 开始证明能够被构造出来，再以此类推归纳到 $p_1$。

首先有 $2^{p_m}\le \sum_{a_y\le p_m} 2^{a_y}$，我们可以通过如下办法构造出 $p_m$：

1. 设 $tmp=0$，从大到小依次枚举 $a_y$。如果 $tmp+2^{a_y} < p_m$,则 $tmp\gets tmp+2^{a_y}$，否则 $tmp$ 不变。

2. 进行完上述过程，可以得到一个最大的 $tmp<p_m$。因为 $a_y$ 总和是要大于 $p_m$ 的，所以可以找到一个最大没有被选中的 $a_k$，让 $tmp\gets tmp+2^{a_k}$，此时 $tmp\ge p_m$。

3. 此时观察所有小于 $a_k$ 的位置，这些数可以被 $\{2^{a_y}|a_y\le p_m\}$ 集合构造出来，所以直接减去这些数字是没有问题的，相当于把组成这些位置的 $2^{a_y}$ 删除。

4. 由此，我们就构造出来了 $2^{p_m}$。

所以，$2^{p_m}$ 是可以构造的，我们再来看 $2^{p_{m-1}}$，因为有 $2^{p_m}+2^{p_{m-1}}\le \sum_{a_y\le p_{m-1}} 2^{a_y}$，所以有 $p_{m-1}\le \sum_{a_y\le p_{m-1}} 2^{a_y}-p_m$。这就意味着，排除掉我们刚刚为了凑出 $p_m$ 而使用的数字，剩下的数字仍然可以凑出 $p_{m-1}$。以此类推，我们就可以证明整个序列都可以被构造出来。

**最后证明原结论**

仍然可以尝试归纳，从最末尾的 $p_{j-1}$ 开始证明可以被构造，以此类推归纳可得到 $\{p_k|1<k<j\}$ 都可以被构造。

首先有 

$$
\begin{cases}
\sum_{i=j}^{m}2^{p_i} > \sum_{a_y\le p_j} 2^{a_y} \\
\sum_{i=j}^{m}2^{p_i}+2^{p_{j-1}} \le \sum_{a_y\le p_{j-1}} 2^{a_y}
\end{cases}
$$

我们要证明的是：

$$\sum_{i=j-1}^{m}2^{p_i}\le \sum_{a_y\le p_{j-1}} 2^{a_y}-2^{a_x}$$

因为为了覆盖掉 $j$ 后面的位数，我们需要用到 $2^{a_x}$ 保证我们的数字比给出的大，所以 $2^{a_x}$ 就无法再被使用了。 

我们来比较不等式两边的变化量：

左边变化量是 $2^{p_j-1}$，右边的变化量是 $\sum_{p_j<a_y\le p_{j-1}} 2^{a_y}$。由于变化之后左边从大于变成小于等于右边，所以有 $\sum_{p_j<a_y\le p_{j-1}} 2^{a_y}> 2^{p_j-1}$。

因为我们知道，$\sum_{p_j<a_y\le p_{j-1}} 2^{a_y}\ge 2^{p_j-1}$，意味着 $p_{j-1}$ 可以被 $\{a_y|p_j<a_y\le p_{j-1} \}$ 构造出来；而大于号就意味着构造出来了后，还有剩余的数字没有用完，就正好可以作为 $2^{a_x}$ 使用。

所以 $2^{p_{j-1}}$ 可以被构造。以此类推，所有的数字都可以被构造出来。

所以，结论得证。

**具体实现**

本来以为证明结论之后，代码比较好写，结果发现自己竟然不会比较两个求和式的大小，所以与第一篇题解作者交流之后，参考了第一篇题解的实现方式，并加以具体说明。

我们现在要来比较 $\sum_{i=j}^{m}2^{p_i}$ 与 $\sum_{a_y\le p_j} 2^{a_y}$ 的大小。

一个整体的思路是，我们先比较两者的最高位，如果最高位相同，我们就可以比较 $2^{a_y}$ 总和中第 $p_j$ 位以后组成的字符串和 $p_j$ 以后所有数加起来得到的二进制字符串的大小。这样做的原因是，总和中第 $p_j$ 位以后组成的字符串一定都是由 $\{2^{a_y}|a_y\le p_j\}$ 加起来得到的，且这个集合中的数的贡献全部在第 $p_j$ 位以后组成的字符串中，所以比较原式大小等价于比较总和第 $p_j$ 位以后组成的字符串大小。


具体地，我们设 $f_i$ 表示总和中第 $p_j$ 位以后组成的字符串是否大于等于 $p_j$ 以后所有数加起来得到的二进制字符串。

首先，如果总和的第 $p_j$ 位是 0，没得说，总和中第 $p_j$ 位以后组成的字符串一定小于 $p_j$ 以后所有数加起来得到的二进制字符串。

否则，如果存在 $p_{j+1}<a_y<p_j$，那么这个 $2^{a_y}$ 可以覆盖掉后面的 $p_{j+1}$，所以总和中第 $p_j$ 位以后组成的字符串一定大于 $p_j$。

如果以上两者都不满足，那么很显然，$f_j=f_{j+1}$。

再综合一下，我们可以得到如果这个 $j$ 不满足条件，需要满足下列两个条件:

1. $Max_{p_j}\le p_j$，否则根本没得比

2. $f_j=0$，表示总和中第 $p_j$ 位以后组成的字符串小于 $p_j$ 以后所有数加起来得到的二进制字符串。

由此，我们就可以找到最小的不合法的 $j$ 了。


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=998244353;
const int N=1e6+30;
int a[N];
bool use[N];
int Max[N];//用小于等于x的数字构成的最高位
int nxt[N];//全部加起来中的第一个大于等于x的位
int p[N];
bool f[N]; //f并不代表这一个位置是否满足条件，而代表 A[pi,0] 的后缀 <= P[pi,m] 的后缀
int Pow[N];
signed main()
{  
    // freopen("1.in","r",stdin);
    // freopen("1.out","w",stdout);
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    int n,q;
    cin>>n>>q;
    set<int> st;
    for(int i=1;i<=n;i++) cin>>a[i],st.insert(a[i]);
    Pow[0]=1;
    for(int i=1;i<=1e6+20;i++) Pow[i]=(Pow[i-1]<<1)>=mod?(Pow[i-1]<<1)-mod:(Pow[i-1]<<1);
    sort(a+1,a+1+n);
    int pp=1,now=-1;
    for(int i=0;i<=1e6+20;i++)
    {
        while(a[pp]<=i&&pp<=n)
        {
            int t=a[pp];
            while(use[t]) use[t]=0,t++;
            use[t]=1,now=max(now,t);
            pp++;
        }
        Max[i]=now;
    }
    nxt[1000021]=-1;
    for(int i=1e6+20;i>=0;i--)
    {
        if(use[i]) nxt[i]=i;
        else nxt[i]=nxt[i+1];
    }
    while(q--)
    {
        int m;
        cin>>m;
        for(int i=1;i<=m;i++) cin>>p[i];
        f[m+1]=1;
        int j=m+1;
        for(int i=m;i;i--)
        {
            if(!use[p[i]]) f[i]=0;
            else f[i]=f[i+1]|(i<m&&nxt[p[i+1]+1]<p[i]);
            if(!f[i]&&Max[p[i]]<=p[i]) j=i;
        }
        long long ans=0;
        for(int i=1;i<j;i++) ans+=Pow[p[i]];
        if(j<=m)
        {
            if(st.upper_bound(p[j])==st.end()) ans=-1;
            else ans+=Pow[*st.upper_bound(p[j])];
        }
        cout<<ans%mod<<'\n';
    }
	return 0;
}
```

---

## 作者：Dicer_L (赞：2)

本题解思路来自 @[Clonoth](https://www.luogu.com.cn/user/212036)。

特判 $m = 0$ 即 $k = 0$ 的情况。

令 $n$ 与值域同阶。

我们往原集合中加入一个无穷大的数，如果选了这个数那么答案为 $-1$。

考虑直接从大到小枚举原集合中的每个数进行贪心，在贪心过程中记录还未决策的数的和，设还要选
的和为 $k$，当前为决策的数为 $x$，在 $x$ 之后决策的数的和为 $S$，则必然要求 $k \le S + X$。若 $x \le k$，直接选上 $x$；若 $k \le S$且 $k < x$，直接跳过；否则必然有 $S < k$ 且 $k < x$，选上 $x$，直接结束。

正确性证明：对于 $x < k \le S$ 的情况，在跳过了 $x$ 之后选出来的子集，必然存在该子集的一个子集
和等于 $x$。

我们得到了一个 $O(n^2q)$ 的做法。

注意到若一个 $2^{a_i}$ 出现了 $\ge 3$ 次，那么我们可以将两个  $2^{a_i}$ 变成一个 $2^{a_i+1}$，显然答案不变。

设 $c_i$ 表示 $2^i$ 的出现次数，$s_i = \sum^{i}_{j = 1}  c_j \times 2^j$，可以发现 $s_i \le 4 \times 2^i - 2 < 4 \times 2^i = 2^{i + 2}$，即 $s_i < 2^{i + 2}$。

我们尝试从高到低消去 $k$ 中的每一位。设 $k$ 中的最高位为 $2^h$，若 $s_h < k$，那么答案为 $> h$ 的最小 $a_i$ 的二的幂次。 注意到当前决策的 $2^x \le k$ 等价于 $x \le h$。由于 $s_{h-2} < 2^h$，所以必然有 $c_h > 0$ 或 $c_{h-1} > 0$。只有在 $c_h = 0$ 且 $c_{h-1} = 1$ 的情况无法消去 $2^h$，而是会使 $h \leftarrow h-1$。那么一段连续的 $h \leftarrow h-1$ 必然对应 $c$ 上一段连续的 $1$。假设直到 $k$ 中的次高位 $h'$ 为止都仍未消去 $h$ 这位，即此时 $h = h'$。注意到此时 $c_{h'}$ 和 $c_{h'+1}$ 都已被使用，而 $2 \times 2^{h'} = 2^{h' + 1} > s_{h' - 1}$，无解，则假设的情况不存在。

如果将连续的 $1$ 缩成一个数，那么可能有用的位置数量只有 $O(m)$，直接模拟即可。直接使用线段树维护比较当前 $k$ 与 $S$ 的大小，复杂度为 $O\left(n+\sum m \log n\right)$。

事实上，我们不需要在一开始的时候比较 $S$ 与 $k$，可以假装总有 $S \geq k$，只需要判断最高位能不能依次消去，在不能消去时进行回退即可，显然至多回退 $O(m)$ 个数。

总结一下操作：$O(m)$ 次区间赋 $0$，最后查询区间内位置最小的非 $0$ 值。

查询时直接枚举每个没有被赋值的间隔，预处理每个位置后第一个非 $0$ 值。

总复杂度 $O\left(n+q+\sum m\right)$。

代码略。

---


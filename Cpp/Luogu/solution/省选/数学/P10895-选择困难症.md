# 选择困难症

## 题目背景

Parviz 认为，如果一道题有一个可以显著优化复杂度的方法而不去使用，那这题就是有遗憾的。

Alice 认为，任何算法难度大于思维难度的题，出在正式比赛中都是没有意义的。

猫猫认为，ta 是学数学学的。

$\textsf{linyue}$ 认为……啊？你们在说啥？

很有喜剧效果的是这四个名字你可能都没法一下子对上号（

## 题目描述

Alice 与 Bob 在下棋之余，也需要一些娱乐活动来放松身心，比如去小吃街吃饭。作为一名绅士，Bob 每次都让 Alice 选择要去吃哪家。这却让 Alice 犯了难——她有选择困难症。

小吃街有 $n$ 家饭店，在第 $i$ 家就餐需要 $i$ 元钱。如果预算为 $a$ 元，则可以选择前 $a$ 家餐厅。

在长期的纠结后，Alice 想到一种方法：她提前在心里想好一个非负整数 $k< \text{lcm}_{i=1}^{n} i$ ，在得知预算 $a$ 之后，选择在第 $(k$ $\text{mod}$ $a)+1$ 家餐厅就餐。

由于买棋盘与棋子的市场价格浮动，每次就餐的预算未必相同，但都是 $[2,n]$ 之间的整数。Alice 想每次都换换口味，希望对于不同的 $a$，最后选定的餐厅各不相同。她想要知道满足要求的 $k$ 的个数，但又忙于与 Bob 下棋没有时间算，于是只好求助于你啦。

形式化地说，对于给定的 $n$，你需要求有多少个整数 $k \in [0, \text{lcm}_{i=1}^{n}i)$ ，满足 $k\bmod 2,k\bmod3 ,..., k\bmod n$ 各不相同。答案对 $998244353$ 取模。

## 说明/提示

**【样例解释1】**

$n=3,4$ 时，$k$ 的取值集合分别为 $\{2, 3, 4, 5\}$ 、 $\{3, 10, 11\}$。

$n=5$ 时：

| $k$ | $k \bmod 2$ | $k \bmod 3$ | $k \bmod 4$ | $k \bmod 5$ |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| $27$ | $1$ | $0$ | $3$ | $2$ |
| $34$ | $0$ | $1$ | $2$ | $4$ |
| $35$ | $1$ | $2$ | $3$ | $0$ |
| $39$ | $1$ | $0$ | $3$ | $4$ |
| $58$ | $0$ | $1$ | $2$ | $3$ |
| $59$ | $1$ | $2$ | $3$ | $4$ |

$\text{lcm}_{i=1}^{n}i=60$，可以验证在 $[0,60)$ 内不存在其他的 $k$ 满足条件，故答案为 $6$。

| 测试点编号 | $T \leq$ | $n \leq$ |
| -----------: | -----------: | -----------: |
| $1-2$ | $15$ | $15$ |
| $3-6$ | $1000$ | $1000$ |
| $7-12$ | $1000$ | $2 \times 10^7$ |
| $13-20$ | $15$ | $2 \times 10^9$ |

对于 $100\%$ 的数据，满足 $3 \leq n \leq 2 \times 10^9$，$ T \leq 1000$。

## 样例 #1

### 输入

```
3
3
4
5```

### 输出

```
4
3
6```

## 样例 #2

### 输入

```
5
13860108
13850709
220000633
693439571
1004535809```

### 输出

```
188051653
724253523
444803502
370347248
425186012```

# 题解

## 作者：Priestess_SLG (赞：6)

~~为了写这个题学习的亚线性求区间质数个数~~ 写完这个题真的玉玉了

思路参考第一篇题解。

题目大意是问 $[0,\text{L}(n))$ 中有多少个数 $i$ 满足 $i\bmod 2$，$i\bmod 3$，$\ldots$，$i\bmod n$ 两两不同。其中 $\text{L}(n)=\text{lcm}(1,2,3,\ldots,i)$。

首先有一种很简单的方法（最喜欢的）：写一个暴力然后瞪眼找规律，可以很容易的发现答案。

正确做法：

首先根据~~山茶的~~《奥赛经典 · 初中数学竞赛中的数论问题》可以得到：

$\textbf{Lemma 1}$ 若 $x\equiv a(\bmod\ p)$，则 $x\equiv pl+a(\bmod\ p)$。

$\textbf{Proof}$ 对于 $x\equiv a(\bmod\ p)$ 根据同余的基本性质可以得到若得到 $x\equiv b(\bmod\ p)$ 则相加得到 $x\equiv a+b(\bmod\ p)$。此时构造 $x\equiv pl\equiv 0(\bmod\ p)$，将原式与上述式子相加得到 $x\equiv pl+a(\bmod p)$，得证。

考虑现在知道 $x$ 是一个满足条件的解，则：

+ 若 $x\equiv1(\bmod\ 2)$，则根据数论知识得到 $x\equiv1,3(\bmod\ 4)$。为保证 $x\bmod 2\neq x\bmod 4$，所以得到 $x\equiv 3(\bmod\ 4)$，同理此时 $x\equiv (2k-1)(\bmod\ 2k)$。
+ 否则有 $x\equiv0(\bmod\ 2)$，则根据数论知识得到 $x\equiv0,2(\bmod\ 4))$。为保证 $x\bmod 2\neq x\bmod 4$，所以得到 $x\equiv 2(\bmod\ 4)$，同理此时 $x\equiv (2k-2)(\bmod\ 2k)$。

$\bmod\ 3$、$\bmod\ 5$ 的情况同理。所以：

$\textbf{Lemma 2}$ 若目前已知 $x\bmod p$ 的值，则 $x\bmod kp(k\in\textbf{N}_+)$ 的情况必然确定。

$\textbf{Proof}$ 若 $x\bmod p=q$（$0\le q<p$ 且 $q\in\textbf{N}$），则 $x\bmod 2p$ 的取值仅可以为 $q,q+p$，为保证互不相同条件需有 $ $。同理 $x\bmod 3p$ 的取值仅可以为 $q,q+p,q+2p$，以此类推。得到 $x\bmod kp$ 的取值仅可以为 $q,q+p,q+2p,\ldots,q+(k-1)p$。回顾行列式上三角矩阵求值方法/大雾，$x\bmod p=q$，则 $x\bmod 2p$ 为和 $x\bmod p$ 不同必须满足 $x\bmod 2p\neq q$，即 $x\bmod 2p=q+p$。同理 $x\bmod 3p=q+2p$，$\ldots$，$x\bmod kp=q+(k-1)p$。因此构造出了唯一满足条件的解并证明引理 $2$。

然后考虑 $x\bmod 2$ 的值确定，就可以确定出 $x\bmod (2\times 3)$ 即 $x\bmod 6$ 的值。若 $x\bmod 6=q$，则考虑用 $x\bmod 3$ 的值反推答案。令 $x\bmod 3=p$，则 $x\bmod 6$ 只能取 $p$ 和 $p+3$。目前已经知道 $x\bmod 6$ 的值为 $p$ 或者 $p+3$，显然可以反推出 $x\bmod 3$ 的值为 $p$ 或者 $p+3$ 中不为 $x\bmod 6$ 的那个值。也就是说：$x\bmod 2$ 的值已知，那么可以得到 $x\bmod 3$ 的值。

$\textbf{Lemma 3}$ 若 $x\bmod p$ 的值已知，且 $\text{lcm}(p,q)\le n$，则可以用 $x\bmod p$ 的值直接唯一确定 $x\bmod q$ 的值。

$\textbf{Proof}$ 首先可以用 $x\bmod p$ 的值直接唯一确定 $x\bmod \text{lcm}(p,q)$ 的值，然后考虑根据 $x\bmod \text{lcm}(p,q)$ 的值直接反推出 $x\bmod kq$ 的值（$k\in \textbf{N}$ 且 $kq\le n$），发现 $x\bmod kq$ 的值都可以使用上述方法唯一确定。因此得证。

然后考虑什么数不可以使用 $\textbf{Lemma 3}$ 来确定。发现若 $p\ge\lfloor\frac{n}{2}\rfloor+1$ 则 $x\bmod p$ 的值没法被唯一确定。考虑继续分类讨论：

+ $x\equiv 0(\bmod\ 2)$。此时继续分类讨论：
  + 若 $n$ 不为质数则手摸一会儿可以发现对于每一个剩下的质数都有一组唯一的配对方案，因此答案为 $1$。
  + 否则 $x\bmod n$ 的情况多一组配对方案，因此答案为 $1+1=2$。
+ $x\equiv 1(\bmod\ 2)$。此时发现剩下的每一个质数都恰好有两种不同的配对方案。因此设在 $[\lfloor\frac{n}{2}\rfloor+1,n]$ 中有 $C$ 个质数，则恰好有 $2^C$ 种不同的配对方案。和 $n$ 是否为质数无关。

总结：

$$
F(n)=\left\lbrace
\begin{aligned}
& 2^C+2 & n\in\text{prime}\\
& 2^C+1 & n\not\in\text{prime}
\end{aligned}\right.
$$

然后高兴的发现 $n$ 为 $2\times 10^9$，直接数区间素数过不了……

考虑 SD NOIP2023 赛前九连测 Day7 T2 的做法，使用如 Meissel-Lehmer 或者 Min-25 筛等亚线性做法求解，判断 $n$ 是否为质数不需要 Miller-rabin 直接 $O(\sqrt n)$ 暴力判断，即可以通过。

核心代码：

```cpp
void solve(unsigned int __testid=1){
    // cerr<<"Pi(10)="<<lehmer(10)<<'\n';
    int n;cin>>n;
    int cnt=lehmer(n)-lehmer(n/2);
    cnt%=mod;
    cnt=ksm(2,cnt,mod);
    if(chk(n))cnt+=2;
    else ++cnt;
    cnt%=mod;
    cout<<cnt<<'\n';
}
```

---

## 作者：littlep001 (赞：5)

### 思路


---

首先我们知道, $ k \bmod 2 $ , $ k \bmod 3 $ , $ k \bmod 4 $ , … , $ k \bmod n $ 的值是在 $ [0,n-1] $ 之间的不重复的 $ n - 1 $ 个数。理论上应该会有 $ 2^{n-1} $ 种可选择的方案数，但很明显，这是不对的，我们多算了一些不合法的部分.

这里举个反例：如果 $ k \bmod 2 = 0 $ , 那么必有
$ k \bmod 4 \neq 1 $ , 但是我们刚才的算法会算出那部分. 

所以如果 $ k \bmod 2 = 0 $ 时 , $ k \bmod 4 = 2 $ , 不能让 $ k \bmod 4 = 0 $ 是因为 $ 0 $ 已经在 $ k \bmod 2 $ 时使用过了.同理 $ k \bmod 6 = 4 $ , ...

而如果 $ k \bmod 2 = 1 $ , 时 , 有 $ k \bmod 4 = 3 $ , $ k \bmod 6 = 5 $ , ...

而 $ k \bmod 3 $ 也是一样的 , 如果 $ k \bmod 3 = 0 $ , 时 , $ k \bmod 6 = 3 $ , $ k \bmod 9 = 6 $ , ...

而 $ k \bmod p = q$ 时 , 必有 $ k \bmod 2p = (q+p) $ , ... 

而如果我们能确认 $ k \bmod p $ , $ k \bmod 2p $ , ...    其中的任意一个的值，那么也可以求出其他部分.

我们只要知道了 $ k \bmod 2 $ 的值 , 就可以求出 $ k \bmod 6 $ 的值，也可推出 $ k \bmod 3 $ 的值 , 当然也可以推出 $ k \bmod 5 $ , $ k \bmod 7 $ , ...   都可以求出来.

那哪些数不能在已知 $ k \bmod 2 $ 求出来的呢 , 当且仅当 $ p $ 为质数且 $ p \leq n $ , $ 2 \times p \gt n $ , 时不能得出.

当 $ k \bmod 2 = 0 $ 时 , 我们考虑所有不能直接求出的 $ p $ , 那么还没有用过且合法的模数一共用 $ 1 $ 个 , 这里注意特判一下 $ n $ 是否为质数 , 如果是的话 $ n $ 的情况还会多一个.

总结一下 , 若 $ n $ 为质数 , 那么有 $ 2 $ 种可能 , 反之只有 $ 1 $ 种.

而 $ k \bmod 2 = 1 $ 时 , 每一种不能求出的 $ p $ , 都有两种可能 , 设 $ cnt $ 为 $ \lfloor \frac {n} {2} \rfloor + 1 $ 到 $ n $ 的质数个数 , 根据乘法原理知答案为 $ 2^{cnt} $.

所以最终答案：

$$ answer=\begin{cases}
2 + 2^{cnt} & \operatorname{is-prime(n)} \\
1 + 2^{cnt} & otherwise. 
\end{cases}$$

$ \operatorname{is-prime(n)} $ 为真时代表 $ n $ 为质数.

而 $ cnt $ 可以用 [Meissel–Lehmer 算法](https://oi-wiki.org/math/number-theory/meissel-lehmer/) 可以在亚线性时间复杂度内求出



---


### 代码部分

```cpp
#include<bits/stdc++.h>

using namespace std;

typedef long long LL;
const int N = 5e6 + 2, mod = 998244353;
bool np[N];
int prime[N], pi[N];

int getprime() {
    int cnt = 0;
    np[0] = np[1] = true;
    pi[0] = pi[1] = 0;
    for(int i = 2; i < N; ++i) {
        if(!np[i]) prime[++cnt] = i;
        pi[i] = cnt;
        for(int j = 1; j <= cnt && i * prime[j] < N; ++j) {
            np[i * prime[j]] = true;
            if(i % prime[j] == 0)   break;
        }
    }
    return cnt;
}
const int M = 7;
const int PM = 2 * 3 * 5 * 7 * 11 * 13 * 17;
int phi[PM + 1][M + 1], sz[M + 1];
void init() {
    getprime();
    sz[0] = 1;
    for(int i = 0; i <= PM; ++i)  phi[i][0] = i;
    for(int i = 1; i <= M; ++i) {
        sz[i] = prime[i] * sz[i - 1];
        for(int j = 1; j <= PM; ++j) {
            phi[j][i] = phi[j][i - 1] - phi[j / prime[i]][i - 1];
        }
    }
}
int sqrt2(LL x) {
    LL r = (LL)sqrt(x - 0.1);
    while(r * r <= x)   ++r;
    return int(r - 1);
}
int sqrt3(LL x) {
    LL r = (LL)cbrt(x - 0.1);
    while(r * r * r <= x)   ++r;
    return int(r - 1);
}
LL getphi(LL x, int s) {
    if(s == 0)  return x;
    if(s <= M)  return phi[x % sz[s]][s] + (x / sz[s]) * phi[sz[s]][s];
    if(x <= prime[s]*prime[s])   return pi[x] - s + 1;
    if(x <= prime[s]*prime[s]*prime[s] && x < N) {
        int s2x = pi[sqrt2(x)];
        LL ans = pi[x] - (s2x + s - 2) * (s2x - s + 1) / 2;
        for(int i = s + 1; i <= s2x; ++i) {
            ans += pi[x / prime[i]];
        }
        return ans;
    }
    return getphi(x, s - 1) - getphi(x / prime[s], s - 1);
}
LL getpi(LL x) {
    if(x < N)   return pi[x];
    LL ans = getphi(x, pi[sqrt3(x)]) + pi[sqrt3(x)] - 1;
    for(int i = pi[sqrt3(x)] + 1, ed = pi[sqrt2(x)]; i <= ed; ++i) {
        ans -= getpi(x / prime[i]) - i + 1;
    }
    return ans;
}
LL lehmer_pi(LL x) {
    if(x < N)   return pi[x];
    int a = (int)lehmer_pi(sqrt2(sqrt2(x)));
    int b = (int)lehmer_pi(sqrt2(x));
    int c = (int)lehmer_pi(sqrt3(x));
    LL sum = getphi(x, a) + LL(b + a - 2) * (b - a + 1) / 2;
    for (int i = a + 1; i <= b; i++) {
        LL w = x / prime[i];
        sum -= lehmer_pi(w);
        if (i > c) continue;
        LL lim = lehmer_pi(sqrt2(w));
        for (int j = i; j <= lim; j++) {
            sum -= lehmer_pi(w / prime[j]) - (j - 1);
        }
    }
    return sum;
}
inline LL qpow(LL a, LL b) {
	LL ans = 1;
	while (b) {
		if (b & 1) {
			ans = ans * a % mod;
		}
		a = a * a % mod;
		b >>= 1;
	}
	return ans;
}
int main() {
    init();
    /*
    LL n;
    while(cin >> n) {
        cout << lehmer_pi(n) << endl;
    }*/
    int t;
    cin >> t;
    while(t--) {
    	LL n, ans = 0;
    	cin >> n;
    	if (n == 3) {
    		cout << 4 << "\n";
    		continue;
		}
    	LL tmp = n / 2 + 1;
    	LL cnt = lehmer_pi(n) - lehmer_pi(tmp - 1); //求n/2+1到n的质数个数
    	if(lehmer_pi(n) - lehmer_pi(n - 1) == 1) {
    		ans = 2;
		}else {
			ans = 1;
		}
		cout << ans + qpow(2, cnt) << "\n";
	}
    return 0;
}
```
Meissel–Lehmer 算法实现部分摘自于 [这篇文章](https://blog.csdn.net/weixin_30586085/article/details/98655524)

最后，感谢您~~耐着性子~~看到这里qwq

---

## 作者：隔壁泞2的如心 (赞：3)

非常好的题目。真的不太好想……

我们不妨直接分析 $k$ 对 $i\in[2,n]$ 取模后形成的数列 $\{a_i\}$，有多少个这样的数列能被取到，就有多少个 $k$ 满足条件。

从 $2$ 开始一直推过去，首先 $a_2$ 只可能为 $0$ 或 $1$。

现考虑 $a_2=1$，则：

- 若 $n\ge3$，则 $a_3$ 可能为 $0,2$。

- 若 $n\ge4$，由 $a_2=1$ 得 $a_4$ 可能为 $1,3$，但由于 $a_i$ 需两两不同，得到 $a_4=3$。

- 若 $n\ge5$，则 $a_5$ 可任意取不等于 $a_2,a_3,a_4$ 的两个值。

- 若 $n\ge6$，则若 $a_3$ 为 $0$，则 $a_6=0=a_4$，不合题意；若 $a_3$ 为 $2$，则 $a_6=5$。

……

设命题 $X_n$：$\forall i\le\frac{n}{2}$，$a_i=i-1$。

由命题 $X_n$ 可以直接由 CRT 推得，对于任意不为素数幂的 $x\le n$，$a_x=x-1$，因为这时 $x$ 被分解为的各个素数幂均 $\le\frac{n}{2}$。

进一步地，设素数幂 $p^k \le n$，则 $a_{p^k}$ 可能等于 $qp^{k-1}+a_{p^{k-1}},q \in [0,p-1]$，由于 $p^{k-1} \le \frac{n}{2}$，若 $q \ne p-1$，则 $a_{p^k}=qp^{k-1}+p^{k-1}-1=a_{(q+1)p^{k-1}}$，不合题意，因此 $a_{p^k}=p^k-1$。

因此，若 $X_n$ 成立，则数列 ${a_n}$ 中除了满足 $2p \ge n$ 的素数 $p$ 的其他位置均已确定。而这样的 $a_p$ 每个都可以从两个与前项均不相等的值里任意选，这样的数列有 $2^{c}$ 个（$c$ 为这样的 $p$ 的数量），同时 $a_p$ 可取的值总会是某奇素数 $-1$ 或 $0$。

考虑从 $X_n$ 推导到 $X_{n+1}$，容易发现，只要 $\frac{n+1}{2}$ 不是素数，$X_{n+1}$ 已被证明。设 $\frac{n+1}{2}=p\ge 3$，则 $a_{2p}=a_p+p$。但考虑 $x=a_p+p+1$ 是个偶数，若$a_p < p-1$，由得 $a_x=x-1=a_p+p=a_{2p}$，不合题意。故此时 $a_p=p-1$，$X_{n+1}$ 得证。因此可由数学归纳法证明所有 $X_n$。

不过，还有 $a_2=0$ 的情况！还是一直推下去……

- 若 $n\ge3$，则 $a_3$ 可能为 $1,2$。

- 若 $n\ge4$，由 $a_2=0$ 得 $a_4$ 可能为 $0,2$，但由于 $a_i$ 需两两不同，得到 $a_4=2$。因此 $a_3=1$。

- 若 $n\ge5$，则 $a_5$ 可任意取不等于 $a_2,a_3,a_4$ 的两个值，也就是 $3,4$。

- 若 $n\ge6$，由 CRT 得 $a_6=4$，故 $a_5=3$。

……

这个情况就简单多了!

- 若 $n\ge p$，则 $a_p$ 可能为 $p-1,p-2$。

- 由前面的推导得，若 $n\ge p+1$，则由 CRT 得 $a_{p+1}=p-1$  ，故 $a_p=p-2$。

- $a_n$ 的合数位置均可由 CRT 直接求得。

这样的数列在 $n$ 为素数时有 $2$ 种，$n$ 不为素数时只有一种。综上，我们终于讨论完了此题！

所以，你只需要用你喜欢的方法求 $n$ 以内的质数数量即可。

```cpp
#include<cstdio>
#include<cassert>
#include<cstring>
#define mod 998244353
#define ll long long
#define N 100000ll
using namespace std;
int t,n,p[N+6],a1[N+6],a2[N+6],cnt;
int isp(int n0){
	for(int i=2;i*i<=n0;i++)if(n0%i==0)return 0;
	return 1;
}
void init(){
	for(int i=2;i<=N;i++)if(isp(i))p[++cnt]=i;
}
inline int* g(ll ind){
	if(ind>N)return a1+(N*N/ind);
	else return a2+ind;
}
int solve(int n0){
	memset(a1,0,sizeof(a1));memset(a2,0,sizeof(a2));
	for(int l=1,r;l<=n0;l=r+1){
		r=n0/(n0/l);
		*g(n0/l)=(n0/l+1)/2;
	}*g(2)=1;
	for(int i=2;p[i]*p[i]<=n0;i++){
		for(int l=1,r;n0/l>=p[i]*p[i];l=r+1){
			r=n0/(n0/l);int now=n0/l;
			*g(now)=*g(now)-(*g(now/p[i])-i+1);
		}
	}
	return *g(n0);
}
ll qpow(int n1,int n2){
	ll n3=n1,n4=1;
	while(n2){
		if(n2&1)n4*=n3,n4%=mod;
		n3*=n3;n3%=mod;n2>>=1;
	}return n4;
}
signed main(){
	init();
	scanf("%d",&t);
	while(t--){
		scanf("%d",&n);
		printf("%lld\n",(qpow(2,solve(n)-solve(n/2))+1+isp(n))%mod);
	}
}
```

特殊奖励 2：本题背景中 Parviz 对应 @[Anoshag_Ruwan](https://www.luogu.com.cn/user/111172)，Alice 对应 @[Alicer](https://www.luogu.com.cn/user/1162660)，猫猫对应 @[pjykk](https://www.luogu.com.cn/user/94617)，$\textsf{linyue}$ 对应 @[隔壁泞2的如心](https://www.luogu.com.cn/user/222901)，故此奖励的获得条件为：```在 T4“选择困难症”中输出“111172 1162660 94617 222901”。```

---


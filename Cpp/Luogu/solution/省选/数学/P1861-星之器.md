# 星之器

## 题目背景

Magic Land 上的时间又过了若干世纪…

现在，人们谈论着一个传说：从前，他们的祖先来到了一个位于东方的岛屿，那里简直就是另外一个世界。善于分析与构造的 Magic Land 上的人们总是不明白那里的人们是如何不借助精确的实验与计算驱动和操纵魔法。

## 题目描述

偶然地，一个魔法使（Magician）来到了 Magic Land，在临走的时候留下了一个神奇的盒子，叫做星之器（Casket of star）。

虽然不知道这个盒子是做什么的，但是经过了大量的实验和计算后，人们已经清楚它的一些事实：

1. 星之器之中有 $N\times M$ 个区域，可看作分成 $N$ 行和 $M$ 列的格子，每个区域之中有若干单位的称为“星”的对象，这个对象的最小单位已经被确定，所以，这个数量总是整数。
2. 魔法使可以驱动星之器中位于同一行或同一列的不相邻（有公共边的区域称为相邻的）两个区域中各 $1$ 单位的“星”，使得它们分别向中心移动 $1$ 格。
3. 每一次使用 2 中的方法驱动“星”，将会产生魔力，魔法使会得到这一部分魔力。魔力的量等于这个两个区域之间所间隔的区域数。

这样，我们可以用一个 $N\times M$ 的数表来表示星之器的状态，比如 $N=2,M=3$ 时：

```plain
2 0 1                                     1 2 0
5 1 4                                     5 1 4
```

当星之器为左侧的状态时，通过操纵第一行的第 $1$ 和 $3$ 个区域中的“星”，变为右侧所示的状态，同时，将产生 $1$ 单位的魔力（因为这两个区域之间恰好隔了 $1$ 个区域）。

在经过了进一步的研究之后，人们知道了这个星之器最初的状态（Ini）以及最终被他们得到时的状态（Fin）。

你希望知道，星之器最多帮助它的拥有者提供了多少的魔力。即：经过一系列上述操作由初态（Ini）变为终态（Fin），至多产生多少魔力。

需要注意的是，显然操作过程中每个区域内“星”的数量不能是负的，即：如果那个区域已经没有“星”了，当然就不能继续操作了。

## 说明/提示

对于 $100\%$ 的数据，$1\le N,M\le200$，$\mathit{Ini}_{i,j},\mathit{Fin}_{i,j}\le1000$。

所有数据保证了至少存在一个操作方法使得星之器由初态变为终态，同时保证了初态与终态不是完全相同的。

## 样例 #1

### 输入

```
5 5 
1 0 0 0 1 
0 0 0 0 0 
0 0 0 0 0 
0 1 0 1 1 
1 0 0 0 0 

0 0 0 0 0 
0 0 0 0 1 
2 0 0 0 1 
0 0 2 0 0 
0 0 0 0 0```

### 输出

```
7```

# 题解

## 作者：linfourxu (赞：23)

容易发现，答案只与初态末态有关且唯一，那么考虑设一个势能函数使得每移动一次，势能的减少量等于答案的增加量。值得注意的是，这种思想在“鞅的停时问题”中也非常常用。

考虑设 $f(x,y)$ 表示位于 $(x,y)$ 的一颗“星”的势能，容易发现势能是每颗星的势能的加和，且 $x$ 维度上的势能与 $y$ 维度上的势能相互独立且等价。这些也是“鞅的停时问题”中设势能函数相当常用也相当容易发现的结论。

那么就可以化简势能函数为 $f(x)$ 表示某一维上位于 $x$ 位置的一颗"星"的势能，根据变化不难列出 $f(x_1)+f(x_2)-f(x_1+1)-f(x_2-1)=x2-x1-1$ 其中 $x1<x2$，该式子含义即为”驱动“位于 $x_1$ 的一颗星与位于 $x_2$ 的一颗星。

简单移项可得 $f(x_1+1)-f(x_1)-(x_1+1)=f(x_2)-f(x_2-1)-x2$ 所以我们设的势能函数只需要满足 $f(x)-f(x-1)-x$ 为定值即可，不妨令这个定值与 $f(0)$ 都为 $0$，当然你令这两个值为多少都行。

那么不难得到 $f(x)$ 的通项为 $\frac{x^2+x}{2}$，当然这个通项与你 $f(0)$ 和定值的取值有关。

那么这题中每颗星总的势能即可表示为 $\frac{x^2+y^2+x+y}{2}$，答案即为初态的总势能减去末态的总势能。

```cpp
rint n=read<int>(),m=read<int>();rll ans=0;
for(rint i=1;i<=n;i++)
	for(rint j=1;j<=m;j++)
		ans+=read<int>()*(i*(i+1)/2+j*(j+1)/2);
for(rint i=1;i<=n;i++)
	for(rint j=1;j<=m;j++)
		ans-=read<int>()*(i*(i+1)/2+j*(j+1)/2);
printf("%lld\n",ans);
```

---

## 作者：a2956331800 (赞：8)

# 真是神仙人类智慧题

手玩几组小的发现获得的魔力与移动方式无关，只与初、末状态有关

所以~~只要找到~~一种把初始状态变成终止状态的移动方式~~就可以了~~

- ~~然后就不会做了去看了题解~~

因为移动方式可能相当复杂，暴力找都没法找，所以考虑用别的方法计算

观察两个在同一列的星$(x_1,y),(x_2,y)(x_1<x_2)$靠近时，获得的魔力为$x_2-x_1$，想办法给星一个_**"势能"**_，使得它们靠近时产生的魔力等于势能的减小量（_**神仙思路**_） 

> 一颗星$(x,y)$的势能为$\frac{x^2+y^2}{2}$

然后带到上面那种情况算一下

$$E_0=\frac{x_1^2+y_1^2+x_2^2+y_2^2}{2}$$
$$E=\frac{(x_1+1)^2+y_1^2+(x_2-1)^2+y_2^2}{2}$$
$$\Delta E=x_2-x_1$$

- 这就证明了按$x^2+y^2$定势能满足**靠近时产生的魔力等于势能的减小量**

然后就**做完了**。读入初始状态，算一下势能，减去终止状态的势能就是答案（注意相同位置的**每颗星都要算一次**势能而不是一共算一次）

- （实际上为了避免$/2$出小数可以把势能按$x^2+y^2$算，最后答案除$2$）

~~甚至数组都可以不用是不是很简单啊~~

---

## 作者：Vidoliga (赞：7)

~~这真是一到水死了的题~~

废话不多说→_→，我们来康康吧

# 这题暴力枚举是不可能的，那该怎么办呢(⊙o⊙)！
我们需要找到一开始的“星”与结束时候的“星”的关系，我们需要考虑到一个权值能把开始的“星”到结束的“星”的将得到的魔力值算出来。
**而关键是怎么找到这种权值！！**

------------

我们仔细观察，不难发现
 每克“星”的权值为$\frac{x × x + y × y}{2}$
 
###  这是怎么证明的呢？
设某2克开始时的“星”的坐标为 $(x1,y1)$ 和 $(x2,y1),2$克结束时的“星”
的坐标为$(x3,y1)$和$(x4,y1)$
 _同x轴或y轴都一样，我们考虑同y轴_ 
我们可以得出总共增加了$(x1-x2)+ ......+(x3-x4) = (x1-x2+x3-x4) × \frac{x1-x3+1}{2}$ 

而这个权值（开始的“星”的权值减结束的“星”的权值）：
经检验可得 两式相等

代码$:$

```cpp
#include<iostream>
using namespace std;
int n,m;
long long all;
long long h;
int main(){
	cin>>n>>m;
	int s,x = 0;
	for(int i = 0;i < n;i++){
		for(int j = 0;j < m;j++){
			cin>>s;
			all += (i * i + j * j) * s;
		}
	}
	all = all / 2;
	for(int i = 0;i < n;i++){
		for(int j = 0;j < m;j++){
			cin>>s;
			h += (i * i + j * j) * s;
		}
	}
	h = h / 2;
	cout<<all - h; 
	return 0; 
} 
```
$QwQ$完结

摘自我以前的[$blog$](https://www.luogu.com.cn/blog/gf2020daihengfei/solution-p4626)

---

## 作者：jijidawang (赞：4)

~~日推天天给我推这道神题，真以为我能做出来吗 qwq~~

做法真的牛逼啊，首先答案和怎么移动无关，对于一定的初态末态每种移动方式产生的能量都是一样的 .

考虑设一个势能函数使得每移动一次，势能的减少量等于答案的增加量 .

首先整个状态的势能就是每个点的势能之和，且发现势能函数关于维度独立且等价 .

于是令 $f(x)$ 表示一个维度上第 $x$ 位的势能，于是根据题目中给的移动方式，就有对于任意两个位置 $x_1<x_2$，有
$$f(x_1)+f(x_2)-f(x_1+1)-f(x_2-1)=x_2-x_1-1$$
移项，得 $f(x_1+1)-f(x_1)-x_1=f(x_2+1)-f(x_2)-x_2$ .

于是我们的势能函数 $f$ 只需满足 $f(x+1)-f(x)-x$ 是定值就完了 .

此时大家就都整的是 $f(x)=\dfrac{x^2+x}2$，同学们不要拘泥于已有的题解啊，$f(x)=\dfrac 12x^2+x$ 也行啊 .

于是一个点的势能就是 $\dfrac 12(x^2+y^2)+x+y$，答案就是初态势能减终态势能 .

实际操作的时候可以把 $\dfrac 12$ 先提出来，规避浮点数操作 .
```cpp
int n, m, x;
ll ans;
int main()
{
	scanf("%d%d", &n, &m);
	for (int i=1; i<=n; i++)
		for (int j=1; j<=m; j++)
			scanf("%d", &x), ans += x * (i * i + j * j + 2 * i + 2 * j);
	for (int i=1; i<=n; i++)
		for (int j=1; j<=m; j++)
			scanf("%d", &x), ans -= x * (i * i + j * j + 2 * i + 2 * j);
	printf("%lld\n", ans / 2);
	return 0;
}
```

参考 [第二篇题解](https://www.luogu.com.cn/blog/lin4xu/solution-p1861) .

---

## 作者：Augen_stern (赞：4)

## Part 1：分析题目

读题后可以发现，一个星之器产生的魔力其实只与它的初态和终态有关，所以我们来分析一下这两者的关系。

## Part 2：算法实现

根据上面的性质，可以进行以下操作；

设一颗星 $A(x_1,y_1)$，另外一颗星 $B(x_2,y_2)$ 且这两颗星不同但横或纵坐标相同;

若横坐标相同则魔力加成为 $|y_1-y_2-1|$；

若纵坐标相同则魔力加成为 $|x_1-x_2-1|$；

为了便于描述以上两种情况，简化式子为 $a-b-1$；

此时将式子因式分解得到：$a-b-1=\dfrac{1}{2}\times(a^2-(a-1)^2+b^2-(b+1)^2)$；

此时，答案显而易见：终态魔力减去初态魔力就是题目的答案；

而对于每一个点 $(x,y)$ 来讲，其魔力差为 $\dfrac{(x^2+y^2)\times(Ini_{(x,y)}-Fin_{(x,y)})}{2}$；

## Part 3 CODE

对于每一个点都进行如上的公式操作，就可以得到代码了；

当然你可以将初态的图存入数组，在输入终态使一并处理；

当然你还可以将二分之一提出来，最后再一并处理。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<math.h>
#include<algorithm>
#include<queue>
#define INF 0x7fffffff/2
using namespace std;
int n,m,g;
double ans=0;
signed main() {
	scanf("%d%d",&n,&m);
	for(int i=1; i<=n; i++) {
		for(int j=1; j<=m; j++) {
			scanf("%d",&g);
			ans+=(i*i+j*j)*g; // 初态加；
		}
	}
	for(int i=1; i<=n; i++) {
		for(int j=1; j<=m; j++) {
			scanf("%d",&g);
			ans-=(i*i+j*j)*g; // 终态减；
		}
	}
	printf("%.0f",ans/2); // 将原式的二分之一提出来，最后再一次性进行操作。
	return 0;
}
```

这题挺神仙的，思路十分清奇！

2021.9.25 初稿成！

---

## 作者：Hanx16Kira (赞：1)

# 星之器

[Luogu P1861](https://www.luogu.com.cn/problem/P1861)

## Solution

神题，不接受任何反驳。

先将问题给压缩成为一维，不难发现，产生的魔力只与初态和终态相关，而与中间过程无关。在物理学上，有一个东西叫做重力势能，如果要知道物体从某处下落至另一处，只需要知道起点的高度和终点的高度，即可算出相差的重力势能，而与中间下落的过程无关。试着将这两个东西联想到一起，为每一个点设置一个势能函数 $f(x)$，使得我们能够通过势能的相减得出产生魔力的值。

假设需要将两个点 $x,y$ 给进行一次变换（不妨设 $x<y$），那么根据势能函数需要完成的事情，可以推导出这个式子：

$$
f(x)+f(y)-f(x+1)-f(y-1)=y-x-1
$$

进行移项得：

$$
f(x+1)-f(x)-(x+1)=f(y)-f(y-1)-y
$$

不难发现，等号左右侧的式子形式是相同的，所以可以设这个等号等于一个定值 $C$，即需要找到一个表达式满足：

$$
f(x+1)-f(x)-(x+1)=C
$$

因为表达式的形式对答案没有影响，所以为了方便推导，将 $C$ 直接假设成为 $0$。那么有：

$$
f(x+1)-f(x)-(x+1)=0
$$
$$
f(x+1)=f(x)+(x+1)
$$
$$
f(x)=f(x-1)+x
$$

很明显，这个递推式的通项公式就是一个二次函数，所以将这个二次函数的一次项和常数项全部假设为 $0$，表示成 $f(x)=ax^2$，将 $x=1$ 带入可以解得 $\displaystyle a=\frac{1}{2}$，因此势能函数即为 $\displaystyle f(x)=\frac{x^2}{2}$。

如果 $x$ 位置上的“星”的数量为 $cnt_x$，那么不难发现，这个点的势能就应该是 $cnt_x\times f(x)$（每个“星”都可以进行变换，所以这个点可以变换的总势能就应该是单个“星”的势能乘以“星”的个数）。

尝试推广到二维。首先，二维的情况下的答案也只与初态和终态有关，与过程无关，所以可以将我们上面的势能函数推广到二维：

$$
\displaystyle f(x,y)=\frac{x^2+y^2}{2}
$$

随便带一组数据进去验证，可以发现是正确的。那么答案就应该是初态矩阵的势能之和减去终态矩阵的势能之和：

$$
st=\sum \limits _{x=1}^{n} \sum \limits _{y=1}^{m} cntSt_{x,y}\times f(x,y)
$$
$$
ed=\sum \limits _{x=1}^{n} \sum \limits _{y=1}^{m} cntEd_{x,y}\times f(x,y)
$$
$$
ans=st-ed
$$

### Code

代码实现中甚至可以不用开数组，并且计算 $st$ 和 $ed$ 的时候势能函数可以先不除以 $2$，在最终答案的地方除以 $2$ 即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
template<typename T> void read(T &k)
{
	k=0;T flag=1;char b=getchar();
	while (!isdigit(b)) {flag=(b=='-')?-1:1;b=getchar();}
	while (isdigit(b)) {k=k*10+b-48;b=getchar();}
	k*=flag;
}
template<typename T> void write(T k) {if (k<0) putchar('-'),write(-k);if (k>9) write(k/10);putchar(k%10+48);}
template<typename T> void writewith(T k,char c) {write(k);putchar(c);}
int n,m,x;
long long st=0,ed=0;
int main()
{
	read(n),read(m);
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++)
			read(x),st+=(i*i+j*j)*x;//初态
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++)
			read(x),ed+=(i*i+j*j)*x;//终态
	writewith((st-ed)>>1,'\n');//答案为(st-ed)/2
	return 0;
}

```

---

## 作者：yizcdl2357 (赞：0)

# 解法

这题虽然代码非常简单，但是思维难度非常大（wtcl）。下面尽可能还原本菜鸡的原始思路。

首先，题目中让我们从“初态”变化到“终态”，涉及两个矩阵，如果能**合并**为一个或许会好一些。怎么合并呢？

“每个区域内‘星’的数量不能是负的”这个条件略显多余。经过若干次试验，我们发现，如果去掉这个条件，答案仍然不变（即，对 $0$ 进行“操纵”一定不优）。

**观察 1**：这个条件是多余的。矩阵里的元素可以推广到整数。

接下来我们就可以将两个矩阵合并了。

注意到，在两个矩阵的对应位置加上相同的数，答案不变（例如，`1 0 1 0` 到 `0 2 0 0` 的魔力值，和 `1 0 1 100` 到 `0 2 0 100` 和魔力值是一样的）。

反复运用这一原理，在初始态 $Ini_{i,j}$ 和终态 $Fin_{i,j}$ 同时加上 $-Fin_{i,j}$，最终可以将终态消成一个全 $0$ 矩阵。这就完成了矩阵的合并。

**观察 2**：不妨设终态为全 $0$ 矩阵。

本文余下部分默认此假设成立，即只考虑初始态 $Ini$。

下一个难点在于：“魔力的量等于这个两个区域之间所间隔的区域数”。我们比较擅长求出操作次数，不擅长求出“魔力值”之和。

设两个区域的距离为 $d$。能不能定义一种新操作，使得这个操作执行 $d$ 次后，两个区域分别向对方靠近一格？

答案是肯定的。手玩几组样例就可以发现，这个操作将一个格子左右（或上下）的两个格子各减 $1$，并将这个格子加 $2$。

**观察 3**：答案等于：初始态执行这个操作几次后可以转化为全 $0$ 态。

二维的矩阵还是有点难搞，考虑先在一维的序列上处理问题。

手玩几次后发现，不管怎么操作，转化到全 $0$ 序列的步数似乎是一样的。我们猜想，存在一个和序列元素相关的量（下记为 $s$），进行一次操作后 $s$ 的值一定增加（减少）一个等量。

问题转化到如何确定 $s$ 的值上。

我们考虑 $s=\sum_{i=1}^na_i$，但是这显然是 $0$；

$\sum_{i=1}^n i\times a_i$ 也不奏效，因为对位置 $k$ 进行一次操作后，$s$ 的值增加了 $(k-1)\times ((a_{k-1}-1)-a_{k-1})+k\times ((a_k+2)-a_k)+(k+1)\times ((a_{k+1}-1)-a_{k+1})=0$。

几经尝试，发现 $s=\sum_{i=1}^n i^2\times a_i$ 是一个有效的选择（技巧：和为常数就试试平方和）。容易验证：

$(k-1)^2\times ((a_{k-1}-1)-a_{k-1})+k^2\times ((a_k+2)-a_k)+(k+1)^2\times ((a_{k+1}-1)-a_{k+1})=-2$

即进行一次操作 $s$ 就减二。

**观察 4**：一维时，答案等于 $\dfrac{1}{2}\sum_{i=1}^n i^2\times a_i$。

尝试将 $s$ 的定义推广到二维。显然定义应该包含坐标的平方，且横坐标和纵坐标的地位相同……再次经过尝试得知：

$s=\sum_{i=1}^n\sum_{j=1}^m a_{i,j}\times(i^2+j^2)$

是一个有效的定义。同上分析可知，进行一次操作 $s$ 就减二。

**结论**：二维时，答案为 $\dfrac{1}{2}\sum_{i=1}^n\sum_{j=1}^m a_{i,j}\times(i^2+j^2)$。
# 代码
```cpp
#include<iostream>
#include<cstdio>
#define int long long
using namespace std;
int n,m,x,ans;
signed main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)
		scanf("%lld",&x),ans+=x*(i*i+j*j);
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)
		scanf("%lld",&x),ans-=x*(i*i+j*j);
	cout<<ans/2;
	return 0;
}
```


---


# 计算电压

## 题目背景

相信不少人轻松灭掉 1，2 两题（蒟蒻无视此句） ，我相信，大家对物理也是很有兴趣的（众人：我们对揍人也是很有兴趣的） ，那么，再奉上 100 分给 Physicaler 们。

## 题目描述

现给定一个电阻网络，已知其中每条边上的电阻，和若干个点和负极之间的电压（电源电压不变） ，现在求任意两点之间的电压。

## 说明/提示

【数据范围】

对于 $10\%$ 的数据，$1\le q\le 10$；

对于 $20\%$ 的数据，$1\le n\le 10$，且保证电路为串联、并联或混联；

对于 $40\%$ 的数据，$1\le n\le 40$，$k\le 5$；

对于 $100\%$ 的数据，$1\le k\le n\le 200$，$1\le m\le 2\times 10^5$，$1\le r_i,u_i\le 10^4$，$1\le q\le 10^6$。

【时空限制】

时间限制：1.00s，空间限制：125.00MB。

【样例解释】

如图所示。

![样例解释](https://cdn.luogu.com.cn/upload/pic/722.png)

## 样例 #1

### 输入

```
3 5 1 3
1 18
1 2 6
1 3 2
2 3 6
3 0 6
2 0 2
1 0
2 3
1 2
```

### 输出

```
18.00
-6.00
12.00
```

# 题解

## 作者：C_SUNSHINE (赞：23)

本题主要考察选手通过物理学公式列方程和使用高斯消元解方程的能力。

由电荷守恒公理可以得出，流向某一结点的电流之和恒等于由该结点流出的电流之和，这便是著名的基尔霍夫电流定律(KCL)，由此可以列出n-1个独立方程组，电源上列出的方程在电池的外部不满足电流守恒，可直接列出电压等式。

可以设i节点上的电势为Xi列出方程：

∑ (Xj-Xi)/Rij=Xi (<i,j>∈R)rnXi=Vi （i为电源）


使用高斯消元法解出X，然后对于任意询问<a,b>，直接输出Xa-Xb即可。

注意，由于输入中可能存在多条电阻丝并联，并且R不为0，我们可以将电阻取倒数记为导电系数，每次在两个节点之间增加导电系数即可。此外，由于询问次数非常大（达到1000000），直接输出浮点数会超时，所以要先将所有可能的结果（200\*200=40000种）以字符串形式保存，这样会减少输出占用的时间，可以通过全部测试点。

参考资料：

http://baike.baidu.com/view/131449.htm

http://baike.baidu.com/view/325740.htm

http://baike.baidu.com/view/33268.htm


---

## 作者：P_E_K_K_A (赞：19)

（Update：修改了乘号）

~~1道电学好题~~

前置知识：**高斯消元**

# 分析

观察样例：

![](https://cdn.luogu.com.cn/upload/pic/722.png)

对于一个 $Q$（比如图中的②）：令电流流入 $Q$ 的节点记为 $A_i$；
电流流出 $Q$ 的节点为 $B_i$。容易知道：

$\sum_{Ai}I_A=\sum_{Bi}I_B$ 

(流入的电流之和等于流出的电流之和)

因为：

$I=\frac{U}{R}$ （但愿你学过初中电学）

所以：

$\sum_{Ai}\frac{U_A}{R_A}=\sum_{Bi}\frac{U_B}{R_B}$

（这里的 $U$ 和 $R$ 指的是 $A_i$ 或 $B_i$ 到 $Q$ 这段导体的电压和电阻，因为我们习惯于考虑一段电阻而不是两个点的电势差）

$R_i$ 我们知道，但是 $U_i$ 怎么知道呢？

如果你学习过一定高中物理，你会知道电压其实就是两个位置之间电势的差值，所以设节点 $i$ 的电势为 $curU_i$ 则 $U=\vert  curU_i-curU_Q \vert$

式子变成：

$\sum_{A_i}\frac{curU_A-curU_Q}{R_A}=\sum_{Bi}\frac{curU_Q-curU_B}{R_B}$

移项：

$\sum_{A_i}\frac{curU_A-curU_Q}{R_A}+\sum_{Bi}\frac{curU_B-curU_Q}{R_B}=0$

令$S_i=A_i\cup B_i$即：

$\sum_{S_i}\frac{curU_S-curU_Q}{R_S}=0$


于是你惊喜地发现：不需要判断电流方向了！

但知道这个式子有什么用呢？

# 解决（代码）

由式子想到列方程（**高斯消元**），设每个点的电势为未知量，讯问时直接作差即可

变形：

$\sum_{S_i}curU_S \times \frac{1}{R_S} - curU_Q  \times \sum_{S_i}\frac{1}{R_S}=0$

所以如果节点 $A$ 与 $Q$ 直接相连，那么在以 $curU_Q$ 主元的方程中 $curU_A$ 的系数为 $\frac{1}{R_A}$ 

而对于以 $curU_Q$ 主元的方程，$curU_Q$的系数为 $-\sum_{S_i}\frac{1}{R_S}$  

核心代码（带注释）：

```cpp
for(register int i=1;i<=m;i++)
{
	int u,v;db w;
	u=read(),v=read(),w=read();
	add(u,v,w),add(v,u,w);//建立电路图
}
//列方程（核心）
for(register int i=1;i<=n;i++)
{
	if(st[i])	k[i][i]=1,k[i][n+1]=st[i];
	//st[i]是正电极电势
	//如果是正电极那么方程直接为 1*U[i]=st[i]
	else
	{
		db sum=0;
		for(int j=head[i];j;j=Edge[j].nxt)
		{
			int v=Edge[j].v;db w=Edge[j].w;
			k[i][v]+=1.0/w;//注意可能两点间有多个电阻
			sum+=1.0/w;
		}
		k[i][i]=-sum;//主元的系数
	}
}
gouse();//自行添加
```

正确性：每个未知量都有主元的方程（即一共 $n$ 个），肯定能解出来

时间复杂度：~~O(能过)~~

列方程 O($n+m$) 高斯消元O( $n^3$ )总：O($n^3+m$) 

制作不易，望管理员大大通过（这道题还没有较为详细的题解）

QwQ
完结撒花~~~



---

## 作者：JustPureH2O (赞：4)

[更好的阅读体验](https://justpureh2o.cn/articles/2011)

题目地址：[P2011](https://www.luogu.com.cn/problem/P2011)

> 现给定一个电阻网络，已知其中每条边上的电阻，和若干个点和负极之间的电压（电源电压不变） ，现在求任意两点之间的电压。
>
> 对于 ${100\%}$ 的数据，${1\le k\le n\le 200}$，${1\le m\le 2\times 10^5}$，${1\le r_i,u_i\le 10^4}$，${1\le q\le 10^6}$。

要解决这道题，我们首先要明白一个定理，即 $\texttt{Kirchhoff}$ 电流定律（$\texttt{KCL}$，或称 $\texttt{Kirchhoff} $ 第一定律）。定理内容如下：

> 电路中任意一个节点上，在任何时刻，流入这个节点的电流之和等于流出这个节点的电流之和。

于是我们把每一个接线柱分开来看。假如当前在讨论接线柱 $M$，假设电流从若干接线柱流出并流入 $M$，那么记 $A$ 为这些接线柱的集合；相应地，如果电流从 $M$ 流出，并流入另一些接线柱，那么记这些接线柱的集合为 $B$。此时根据欧姆定律有如下关系：

$$
\sum\limits_{i\in A}\frac{U_i}{R_i}=\sum\limits_{j\in B}\frac{U_j}{R_j}
$$

发现此时又要求每个电阻丝的电压，非常的麻烦。根据高中知识可得，导体两端的电压其实就等于它两端的电势之差，假如电阻丝 $T$ 左右分别连接着接线柱 $a,b$，那么 $U_T=|\varphi_a-\varphi_b|$。上式转化为：

$$
\begin{aligned}
\sum\limits_{i\in A}\frac{|\varphi_i-\varphi_M|}{R_i}&=\sum\limits_{j\in B}\frac{|\varphi_M-\varphi_j|}{R_j}
\\\sum\limits_{i\in A}\frac{|\varphi_i-\varphi_M|}{R_i}+\sum\limits_{j\in B}\frac{|\varphi_j-\varphi_M|}{R_j}&=0
\\\sum\limits_{i\in A\cup B}\frac{|\varphi_i-\varphi_M|}{R_i}&=0
\\\sum\limits_{i\in A\cup B}\frac{\varphi_i}{R_i}-\varphi_M\sum\limits_{i\in A\cup B}\frac{1}{R_i}&=0
\\\frac{\varphi_1}{R_1}+\frac{\varphi_2}{R_2}+\dots-\varphi_M\sum\limits_{i\in A\cup B}\frac{1}{R_i}+\dots+\frac{\varphi_n}{R_n}&=0
\end{aligned}
$$

发现最后的这个方程式可以使用高斯消元来解决，在系数矩阵中分别填入 $\frac{1}{R_1},\frac{1}{R_2},\dots,\frac{1}{R_k}$，作为系数。此时需要注意，第 $M$ 项的系数应是 $-\sum\limits_{i\in A\cup B}\frac{1}{R_i}$。对于题目中已经给定的值，即直接与正极相连的接线柱只需要列出形如 $\varphi_k=a_k$ 的方程即可。不难发现方程组有 $n$ 条方程，$n$ 个未知数，是一定有解的。题目的询问就可以转化成求两接线柱之间的电势差了。

```cpp
#include <bits/stdc++.h>

#define N 210
using namespace std;

typedef pair<int, double> PID;

const double EPS = 1e-12;

vector<PID> G[N];

double matrix[N][N];
double voltage[N];
double start[N];

int gauss(int n) {
    int rank = 0;
    for (int c = 0, r = 0; c <= n; c++) {
        int t = r;
        for (int i = r; i <= n; i++) {
            if (abs(matrix[i][c]) > abs(matrix[t][c])) t = i;
        }
        if (abs(matrix[t][c]) < EPS) continue;
        if (t ^ r) swap(matrix[t], matrix[r]);
        for (int i = n + 1; i >= c; i--) matrix[r][i] /= matrix[r][c];
        for (int i = 0; i <= n; i++) {
            if (abs(matrix[i][c]) > EPS && i ^ r) {
                for (int j = n + 1; j >= c; j--) {
                    matrix[i][j] -= matrix[i][c] * matrix[r][j];
                }
            }
        }
        r++;
        rank++;
    }
    for (int i = 0; i <= n; i++) voltage[i] = matrix[i][n + 1];
    return 2;
}

void out(int n) {
    cerr << "------------------" << endl;
    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= n + 1; j++) {
            cerr << fixed << setprecision(2) << setw(10) << matrix[i][j];
        }
        cerr << endl;
    }
    cerr << "------------------" << endl;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    int n, m, k, q;
    cin >> n >> m >> k >> q;
    while (k--) {
        int u;
        cin >> u >> start[u];
    }
    while (m--) {
        int u, v;
        double w;
        cin >> u >> v >> w;
        G[u].emplace_back(v, w);
        G[v].emplace_back(u, w);
    }
    matrix[0][0] = 1.0;
    for (int i = 1; i <= n; i++) {
        double sum = 0.0;
        if (abs(start[i]) > EPS) {
            matrix[i][i] = 1.0;
            matrix[i][n + 1] = start[i];
            continue;
        }
        for (auto p: G[i]) {
            int u = p.first;
            matrix[i][u] += 1.0 / p.second;
            sum += 1.0 / p.second;
        }
        matrix[i][i] = -sum;
    }
    gauss(n);
    while (q--) {
        int u, v;
        cin >> u >> v;
        cout << fixed << setprecision(2) << voltage[u] - voltage[v] << endl;
    }
    return 0;
}
```

$\texttt{The End}$

---

## 作者：Zq_water (赞：3)

## 题意
给定一电阻网络，电阻网络上有 $n$ 个节点，$m$ 个电阻连接着两个节点，给定 $k$ 个直接与电源正极连接的节点及其电压，$q$ 次询问任意两节点间的电压。

## 分析
求等效电路是不可能实现的，看到 $n\le200$ 想到可以对于每一个**节点**列方程跑高斯消元，在此之前现需要知道基尔霍夫电流定律，即**电路中任一个节点上，在任一时刻，流入节点的电流之和等于流出节点的电流之和**。写成表达式形式就是：

对于任意的节点 $\text{P}$，记电流流入 $\text{P}$ 的节点集合为 $\text{A}$，电流流出的节点集合为 $\text{B}$，即电流方向就是 $\text{A}$ 到 $\text{P}$ 到 $\text{B}$。

$$\sum_{k\in \text{A}}I_{k\to \text{P}}=\sum_{k\in \text{B}}I_{\text{P}\to k}$$

由欧姆定律可得：

$$\sum_{k\in \text{A}}\frac{U_{k\to \text{P}}}{R_{k\to \text{P}}}=\sum_{k\in \text{B}}\frac{U_{\text{P}\to k}}{R_{\text{P}\to k}}$$

现在我们遇到了问题，上述式子所包含的电压电流都是需要在边上处理的信息，而我们的时间复杂度只允许在点上处理，并且电流的方向也是无法确定的，因此需要将信息转化到点上，你想到了什么？

中学课本告诉我们：**电路中两节点间的电压即为两个节点的电势之差**。因此我们可以将上式化为：

$$\sum_{k\in \text{A}}\frac{\varphi_k-\varphi_{\text{P}}}{R_{k\to \text{P}}}=\sum_{k\in \text{B}}\frac{\varphi_{\text{P}}-\varphi_k}{R_{\text{P}\to k}}$$

其中 $\varphi_k$ 即为节点 $k$ 的电势，对上式移项：

$$\sum_{k\in \text{A}}\frac{\varphi_k-\varphi_{\text{P}}}{R_{k\to \text{P}}}+\sum_{k\in \text{B}}\frac{\varphi_k-\varphi_{\text{P}}}{R_{\text{P}\to k}}=0$$

$$\sum_{k\in \text{A}\cup\text{B}}\frac{\varphi_k-\varphi_{\text{P}}}{R_{k\to \text{P}}}=0$$

这时我们神奇的发现，信息不仅被转移到了点上，电流的方向也不需要判断了，因此我们将电阻 $R$ 看做常数，以 $\varphi$ 为主元列方程，考虑如何构造方程组：

若节点 $\text{P}$ 直接与电源正极相连，那么 $\text{P}$ 与电源负极之间的电压即为电势 $\varphi_{\text{P}}$，可直接得到，但为了方便还是将该等式视为一条方程。

其余的情况就可以利用上面的式子，将求和拆开：

$$\sum_{k\in \text{A}\cup\text{B}}\frac{\varphi_k-\varphi_{\text{P}}}{R_{k\to \text{P}}}=0$$

$$\sum_{k\in \text{A}\cup\text{B}}(\frac{1}{R_{k\to \text{P}}}\times\varphi_k)-\sum_{k\in \text{A}\cup\text{B}}(\frac{1}{R_{k\to \text{P}}}\times \varphi_{\text{P}})=0$$

即我们找了了一个关于节点 $\text{P}$ 和所有与 $\text{P}$ 相连的节点的电势的方程，由于每一个节点我们都可以得到一个这样的方程，因此可以将每一个节点的电势解出来，最后的询问任意两点间的电压即为两点间的电势作差。

## 代码

```cpp
#include<bits/stdc++.h>
#define INF 2e18
#define endl '\n'
#define pb push_back
#define fi first
#define se second
#define int long long
#define mem(x,v) memset(x,v,sizeof x)
using namespace std;
const int N = 205;
const double eps = 1e-6;

int n,m,k,q;
double start[N],voltage[N],matrix[N][N];
vector <pair<int,double> > g[N];

signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m>>k>>q;
	for(int i=1,u;i<=k;i++)cin>>u,cin>>start[u];
	for(int i=1,u,v;i<=m;i++){
		double w;cin>>u>>v>>w;
		g[u].pb({v,w}),g[v].pb({u,w});
	}
	for(int i=1;i<=n;i++){
		double sum=0;
		if(fabs(start[i])>eps){
			matrix[i][i]=1,matrix[i][n+1]=start[i];
			continue;
		}
		for(auto it:g[i]){
			int v=it.fi,w=it.se;
			matrix[i][v]+=1.0/w,sum+=1.0/w;
		}
		matrix[i][i]=-sum;
	}
	for(int i=1;i<=n;i++){
		int r=i;
		for(int j=i+1;j<=n;j++)if(fabs(matrix[j][i])>fabs(matrix[r][i]))r=j;
		swap(matrix[i],matrix[r]);
		double div=matrix[i][i];
		for(int j=i;j<=n+1;j++)matrix[i][j]/=div;
		for(int j=i+1;j<=n;j++){
			div=matrix[j][i];
			for(int k=i;k<=n+1;k++)matrix[j][k]-=matrix[i][k]*div; 
		}
	}
	voltage[n]=matrix[n][n+1];
	for(int i=n-1;i>=1;i--){
		voltage[i]=matrix[i][n+1];
		for(int j=i+1;j<=n;j++)voltage[i]-=(matrix[i][j]*voltage[j]);
	}
	for(int i=1,u,v;i<=q;i++){
		cin>>u>>v,
		cout<<fixed<<setprecision(2)<<voltage[u]-voltage[v]<<endl;
	}
	return 0;
}
```

---

## 作者：Eltaos_xingyu (赞：1)

作者没有学过高中物理电学，这里提供一个大多是通过观察得到的解法。

首先，我们知道欧姆定理：$I=\frac{U}{R}$，变形一下得到 $U=IR$。

在样例解释的图上随意找两相邻点的电压，不难发现均满足 $U_{in}-U_{out}=IR$。大胆猜测，被一根导线连接起来的两点满足 $I=\frac{U_{in}-U_{out}}{R}$。

根据 $n\leq 200$ 的数据范围，对于计算类问题，不难想到高斯消元，我们要对于每一个点进行方程式的构造。再观察样例解释，不难发现随意选取一个点，我们都有 $I_{\text{入}}=I_{\text{出}}$（其实下面的提示 `电流守恒` 也说明了这一点），那么根据上面两个观察得到的结论，我们可以列出以下方程式：
$$
\begin{aligned}
I_{\text{入}}&=I_{\text{出}}\\
\sum_{j\to i}\frac{U_j-U_i}{R_{j,i}}&=\sum_{i\to k}\frac{U_i-U_k}{R_{i,k}}
\end{aligned}
$$
变形一下，可以得到：
$$
\sum_{(i,j)\in E}\frac{U_j-U_i}{R_{i,j}}=0
$$
那么可以无视电流方向建出方程。

还剩最后一个问题，即如果电源电压与一个点直连，这个点的电压是直接是电源电压还是有部分是其他电源传过来的呢？由初中知识 `导线两端的电压不变` 可知这里的电压一定和电源电压一致。建方程时特判一下即可。

剩下就是高斯消元的模板了。 

[AC 记录](https://www.luogu.com.cn/record/146149732)



---


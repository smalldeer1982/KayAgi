# [清华集训 2012] 模积和

## 题目背景

数学题，无背景。


## 题目描述

求

$$\sum_{i=1}^{n} \sum_{j=1}^{m} (n \bmod i) \times (m \bmod j), i \neq j$$

mod 19940417 的值

## 说明/提示

#### 数据规模与约定

- 对于 $10\%$ 的数据，保证 $n,m \leq 10^3$。
- 对于 $30\%$ 的数据，保证 $n,m \leq 10^6$。
- 另有 $30\%$ 的数据，保证 $n \leq 100$。
- 对于 $100\%$ 的数据，保证 $1 \leq n,m \leq 10^9$。



## 样例 #1

### 输入

```
3 4```

### 输出

```
1```

## 样例 #2

### 输入

```
123456 654321```

### 输出

```
116430```

# 题解

## 作者：whiteqwq (赞：53)

[P2260 [清华集训2012]模积和](https://www.luogu.com.cn/problem/P2260)解题报告：

[更好的阅读体验](https://zybuluo.com/xiaoziyao/note/1724317)

双倍经验：[P2834 能力测验](https://www.luogu.com.cn/problem/P2834)

## 题意
题意：求$\sum_{i=1}^n\sum_{j=1}^m[i\ne j](n\bmod i)\cdot(m\bmod j)$。

数据范围：$1\leqslant n,m\leqslant 10^9$。

## 分析

这是一道简单的推式子题，但是实现比较恶心。

首先不妨设$n\leqslant m$（如果$n>m$交换一下就好了）

然后可以用容斥将题目拆成两个部分：

$$\sum_{i=1}^n\sum_{j=1}^m(n\bmod i)\cdot(m\bmod j)-\sum_{i=1}^n(n\bmod i)\cdot(m\bmod i)$$

将两个求和拆开：

$$\sum_{i=1}^n(n\bmod i)\cdot\sum_{j=1}^m(m\bmod j)-\sum_{i=1}^n(n\bmod i)\cdot(m\bmod i)$$

因为取模很难搞，所以可以用一个性质$a\bmod b=a-\lfloor\frac{a}{b}\rfloor\cdot b$（取模的定义），将上式转换为：

$$\sum_{i=1}^n(n-\lfloor\frac{n}{i}\rfloor\cdot i)\cdot\sum_{j=1}^m(m-\lfloor\frac{m}{j}\rfloor\cdot j)-\sum_{i=1}^n(n-\lfloor\frac{n}{i}\rfloor\cdot i)\cdot(m-\lfloor\frac{m}{i}\rfloor\cdot i)$$

将括号拆开，可以得到：

$$(n^2-\sum_{i=1}^ni\cdot\lfloor\frac{n}{i}\rfloor)\cdot(m^2-\sum_{i=1}^mi\cdot\lfloor\frac{m}{i}\rfloor)-\sum_{i=1}^n(nm-mi\cdot\lfloor\frac{n}{i}\rfloor-ni\cdot\lfloor\frac{m}{i}\rfloor+i^2\cdot\lfloor\frac{n}{i}\rfloor\cdot\lfloor\frac{m}{i}\rfloor)$$

此时我们的复杂度已经是$O(n)$了，然而这个复杂度仍然不足以通过本题。

要做这道题需要一个简单的技巧——整除分块。

我们很容易发现很多$\lfloor\frac{n}{i}\rfloor$的值是一样的，且所有的$\lfloor\frac{n}{i}\rfloor$为一个不下降子序列，呈块状分布

通过简单的计算可以得到，对于每个起点为$i$的块，它的值为$\lfloor\frac{n}{i}\rfloor$，终点为$\lfloor\frac{n}{\lfloor\frac{n}{i}\rfloor}\rfloor$，然后我们就可以用$O(\sqrt{n})$的算法计算$\sum_{i=1}^ni\cdot \lfloor\frac{n}{i}\rfloor$了：

主要步骤，对于每一个块$[l,r]$，它乘号前面前缀和差分得到，即$(1+2+\cdots+r)-(1+2+\cdots+(l-1))$，乘号后面的就是$\lfloor\frac{n}{l}\rfloor$。

代码：

```
inline long long sum1(long long x){
	return x*(x+1)%mod*inv2%mod;
}

l=1,sum=n*n%mod;
while(l<=n){
	r=n/(n/l);
	sum=(sum-(sum1(r)-sum1(l-1)+mod)%mod*(n/l)%mod+mod)%mod;
	l=r+1;
}
```

同样，$\sum_{i=1}^mi\cdot \lfloor\frac{m}{i}\rfloor$的值也可以用相同的方法求得。

考虑求$\sum_{i=1}^n(nm-mi\cdot\lfloor\frac{n}{i}\rfloor-ni\cdot\lfloor\frac{m}{i}\rfloor+i^2\cdot\lfloor\frac{n}{i}\rfloor\cdot\lfloor\frac{m}{i}\rfloor)$，发现用整除分块完成它需要使区间$[l,r]$中所有的$i$都满足$\lfloor\frac{n}{i}\rfloor$与$\lfloor\frac{m}{i}\rfloor$相同。

可以用类似的方法，将上面代码中的```r=n/(n/l);```改为```r=min(n/(n/l),m/(m/l));```，然后就可以直接求值了！

且慢，虽然前三项$nm,mi\cdot\lfloor\frac{n}{i}\rfloor,ni\cdot\lfloor\frac{m}{i}\rfloor$都很容易求得，但是$i^2\cdot\lfloor\frac{n}{i}\rfloor\cdot\lfloor\frac{m}{i}\rfloor$不是很容易求，因为$(1^2+2^2+\cdots+i^2)$不好处理。

这里有一个简单的结论：$1^2+2^2+\cdots+n^2=\frac{n(n+1)(2n+1)}{6}$，会在文后证明，现在先给出这一部分的代码：

```
inline long long sum2(long long x){
	return x*(x+1)%mod*(2*x+1)%mod*inv6%mod;
}

l=1,tmp3=0;
while(l<=n){
	long long a,b,c;
	r=min(n/(n/l),m/(m/l));
	a=(r-l+1)*n%mod*m%mod;
	b=(sum1(r)-sum1(l-1)+mod)%mod*((n/l)*m%mod+(m/l)*n%mod)%mod;
	c=(sum2(r)-sum2(l-1)+mod)%mod*(n/l)%mod*(m/l)%mod;
	tmp3=(tmp3+a-b+c+mod)%mod;
	l=r+1;
}
```

## 代码
- 记得开long long
- 取模很恶心，如果错了多半是这种原因
- 因为三个整数相乘会爆long long，因此除法用逆元实现（逆元提前求得）

```
#include<stdio.h>
const long long mod=19940417,inv2=9970209,inv6=3323403;
long long i,j,k,m,n,l,r,ans,tmp1,tmp2,tmp3;
inline long long min(long long a,long long b){
	return a<b? a:b; 
}
inline void swp(long long &a,long long &b){
	a+=b,b=a-b,a-=b;
}
inline long long sum1(long long x){
	return x*(x+1)%mod*inv2%mod;
}
inline long long sum2(long long x){
	return x*(x+1)%mod*(2*x+1)%mod*inv6%mod;
}
int main(){
	scanf("%lld%lld",&n,&m);
	if(n>m)
		swp(n,m);
	l=1,tmp1=n*n%mod;
	while(l<=n){
		r=n/(n/l);
		tmp1=(tmp1-(sum1(r)-sum1(l-1)+mod)%mod*(n/l)%mod+mod)%mod;
		l=r+1;
	}
	l=1,tmp2=m*m%mod;
	while(l<=m){
		r=m/(m/l);
		tmp2=(tmp2-(sum1(r)-sum1(l-1)+mod)%mod*(m/l)%mod+mod)%mod;
		l=r+1;
	}
	l=1,tmp3=0;
	while(l<=n){
		long long a,b,c;
		r=min(n/(n/l),m/(m/l));
		a=(r-l+1)*n%mod*m%mod;
		b=(sum1(r)-sum1(l-1)+mod)%mod*((n/l)*m%mod+(m/l)*n%mod)%mod;
		c=(sum2(r)-sum2(l-1)+mod)%mod*(n/l)%mod*(m/l)%mod;
		tmp3=(tmp3+a-b+c+mod)%mod;
		l=r+1;
	}
	ans=(tmp1*tmp2%mod-tmp3+mod)%mod;
	printf("%lld\n",ans);
	return 0;
} 
```

## 简单的证明
证明：

$$1^2+2^2+\cdots+n^2=\frac{n(n+1)(2n+1)}{6}$$

（这个式子可以用简单构造法与数学归纳法证明，由于大部分题解都是用的数学归纳法，且用数学归纳法读者自证不难，因此这里使用简单构造法）

由于有这样一个式子：$i^2=i^2-i+i(i-1)\cdot i+i$，因此我们可以将这个拆开：

$$1^2+2^2+\cdots+n^2=\sum_{i=1}^ni^2=\sum_{i=1}^n(i-1)\cdot i+\sum_{i=1}^ni$$

然后乘上$\frac{1}{3}$：

$$\sum_{i=1}^ni^2=\frac{1}{3}\sum_{i=1}^n(i-1)\cdot i\cdot3+\sum_{i=1}^ni$$

构造一下：

$$\sum_{i=1}^ni^2=\frac{1}{3}\sum_{i=1}^n(i-1)\cdot i\cdot((i+1)-(i-2))=\frac{1}{3}\sum_{i=1}^n(-(i-2)\cdot(i-1)\cdot i+(i-1)\cdot i\cdot(i+1))+\sum_{i=1}^ni$$

把它们全部展开：

$$\sum_{i=1}^ni^2=\frac{1}{3}(-(-1)\cdot0\cdot1+0\cdot1\cdot2-0\cdot1\cdot2+1\cdot2\cdot3-1\cdot2\cdot3+\cdots(n-1)\cdot n\cdot(n+1))+\frac{n\cdot(n+1)}{2}$$

发现括号里的很多项都可以抵消：

$$\sum_{i=1}^ni^2=\frac{(n-1)\cdot n\cdot(n+1)}{3}+\frac{n\cdot(n+1)}{2}=\frac{n\cdot(n+1)\cdot(2(n-1)+3)}{6}=\frac{n\cdot(n+1)\cdot(2n+1)}{6}$$

证毕。

---

## 作者：硫代硫酸钠 (赞：18)

预备知识:

1.对于任意正整数$a,p$,如果$(a,p)=1$,则$a^{\phi(p)}\equiv1 (mod)$  $p$.
上式被称为欧拉定理.

2.$\sum\limits_{i=1}^n i^2=\frac{n(n+1)(2n+1)}{6}$ ,用数学归纳法易证.

3.$\sum\limits_{i=1}^n \lfloor \frac{n}{i} \rfloor$可以在$O(\sqrt n)$时间内求出,因为$\lfloor \frac{n}{i} \rfloor$最多只有$O(\sqrt n)$种取值.

下面开始本题的推导

$\sum\limits_{i=1}^n \sum\limits_{j=1,j\neq i}^m (n$ $mod$ $i)$ $\cdot (m$  $mod$ $j)$

利用容斥原理,把$j\neq i$的条件转换出来,

$\sum_{i=1}^{n}\sum_{j=1}^{m}(n-{\left \lfloor \frac{n}{i} \right \rfloor}i)(m-{\left \lfloor \frac{m}{j} \right \rfloor}j)-\sum_{i=1}^{min(n,m)}(n-{\left \lfloor \frac{n}{i} \right \rfloor}i)(m-{\left \lfloor \frac{m}{i} \right \rfloor}i)$

把后面的式子展开

$\sum_{i=1}^{n}\sum_{j=1}^{m}(n-{\left \lfloor \frac{n}{i} \right \rfloor}i)(m-{\left \lfloor \frac{m}{j} \right \rfloor}j)-\sum_{i=1}^{min(n,m)}(nm+{\left \lfloor \frac{n}{i} \right \rfloor}{\left \lfloor \frac{m}{i} \right \rfloor}i^2-(m{\left \lfloor \frac{n}{i} \right \rfloor}+n{\left \lfloor \frac{m}{i} \right \rfloor})i)$

然后提出来一个求和,

$\sum_{i=1}^{n}(n-{\left \lfloor \frac{n}{i} \right \rfloor}i)\sum_{j=1}^{m}(m-{\left \lfloor \frac{m}{j} \right \rfloor}j)-\sum_{i=1}^{min(n,m)}(nm+{\left \lfloor \frac{n}{i} \right \rfloor}{\left \lfloor \frac{m}{i} \right \rfloor}i^2-(m{\left \lfloor \frac{n}{i} \right \rfloor}+n{\left \lfloor \frac{m}{i} \right \rfloor})i)$

然后前两个式子可以用数论分块做,后三个参见预备知识.

蒟蒻的代码:

注:逆元也可以用扩展欧几里得求出.

```cpp
#include<algorithm>
#include<cctype>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<map>
#include<queue>
#include<stack>
#include<vector>
#define size 500010
#define debug(x) cerr<<#x<<"="<<x
#define gc getchar()
#define db double
#define ll long long
#define rep(i,s,n) for (register int i=s;i<=n;i++)
#define drep(i,n,s) for (register int i=n;i>=s;i--)
#define il inline
using namespace std;

il ll read()
{
	char c; ll x,f=1;
	for (c=gc;!isdigit(c);c=gc) if (c=='-') f=-1; x=c-'0';
	for (c=gc;isdigit(c);c=gc) x=(x<<1)+(x<<3)+c-'0';
	return f*x;
}

const ll M=19940417;

ll ksm(ll x,ll y)
{
	ll res=1;
	while (y)
	{
		if (y&1) res=res*x%M;
		x=x*x%M;
		y>>=1;
	}
	return res;
}

ll n,m,k,ans=0,inv=ksm(6,17091779);
il ll sum1(ll p,ll q) {return (q+p)*(q-p+1)/2%M;}
il ll sum2(ll x) {return (x*(x+1))%M*(2*x+1)%M*inv%M;}


ll calc(ll n)
{
	ll res=0;
	for (ll l=1,r; l<=n; l=r+1) r=n/(n/l),res=(res+n*(r-l+1)%M-sum1(l,r)*(n/l)%M+M)%M;
	return res;
}

void work(ll n,ll m)
{
	ans=calc(n)*calc(m)%M;
	for (ll l=1,r,sum=0,SUM=0,Sum=0;l<=n;l=r+1)
	{
		r=min(n/(n/l),m/(m/l));
		SUM=(m*n%M*(r-l+1))%M;
		Sum=(n/l)*(m/l)%M*(sum2(r)-sum2(l-1)+M)%M;
		sum=(n/l*m%M+m/l*n%M)*sum1(l,r)%M;
		ans=(ans-(SUM+Sum-sum+M)%M+M)%M;
	}
	cout<<ans%M<<endl;
}

int main()
{
	n=read(); m=read(); if (n>m) swap(n,m); 
	work(n,m);
	return 0;
}


```


---

## 作者：Gorenstein (赞：13)

我们一步一步地来。

------------
先化简一波柿子qaqq

方便起见，假设 $n\leqslant m$，程序具体实现的时候，如果 $n>m$ 则交换一下即可。观察柿子

$$
\sum\limits_{i=1}^n\sum\limits_{j=1}^m (n\bmod i)\times(m\bmod j)\;\left[i\ne j\right]
$$

好像求和号里面第一个因式和 $j$ 没什么关系啊，那么就赶紧提出去

$$
\sum\limits_{i=1}^n(n\bmod i)\times\sum\limits_{j=1}^m (m\bmod j)\;\left[i\ne j\right]
$$

众所周知这种 $i\ne j$ 是可以容斥的，我们转换成两个求和式相减

$$
\sum\limits_{i=1}^n(n\bmod i)\times\sum\limits_{j=1}^m (m\bmod j)-\sum\limits_{i=1}^n (n\bmod i)\times(m\bmod i)
$$

这个 $\bmod$ 一看就很不顺眼，我们把 $a\bmod b$ 写成 $a-\lfloor\frac{a}{b}\rfloor\times b$ 的形式

$$
\sum\limits_{i=1}^n\left(n-\Big\lfloor\frac{n}{i}\Big\rfloor\times i\right)\times\sum\limits_{j=1}^m \Big(m-\Big\lfloor\frac{m}{j}\Big\rfloor\times j\Big)-\sum\limits_{i=1}^n\left(n-\Big\lfloor\frac{n}{i}\Big\rfloor\times i\right)\times\left(m-\Big\lfloor\frac{m}{i}\Big\rfloor\times i\right)
$$

现在柿子看上去好多了！

我们把俩求和分开来看。

------------
首先我们来看

$$
\sum\limits_{i=1}^n\left(n-\Big\lfloor\frac{n}{i}\Big\rfloor\times i\right)\times \sum\limits_{j=1}^m \Big(m-\Big\lfloor\frac{m}{j}\Big\rfloor\times j\Big)
$$

我们又看到了求和号里有一些和 $i$ 或 $j$ 无关的东西，所以可以进一步提取出，柿子就变成了

$$
\left(n^2-\sum\limits_{i=1}^n\Big\lfloor\frac{n}{i}\Big\rfloor\times i\right)\times \left(m^2-\sum\limits_{j=1}^m\Big\lfloor\frac{m}{
j}\Big\rfloor\times j\right)
$$

我们知道对于一段的 $i$， $\lfloor\frac{n}{i}\rfloor$ 的值事一样的。我们如何找到这一段区间的端点 $l,r$？

首先这个 $l$ 救世上一个区间的 $r+1$，第一个 $l$ 就是 $1$，所以我们只需考虑 $r$ 怎么出来。其实是要找到一个$r$，使
$\Big\lfloor\frac{n}{l}\Big\rfloor\times r\leqslant n$。

于是我们随便移项一下，便可得 $r=\bigg\lfloor\dfrac{n}{\lfloor\frac{n}{l}\rfloor}\bigg\rfloor$

这就是我们的除法分块qaqq

好家伙我们在前面推出的柿子里看到了除法分块的影子，碰巧 $i$ 的前缀和很好求，所以这里除法分块非常容易！

看下代码罢：

```cpp
sum=n*n%p;
for(ll l=1,r;l<=n;l=r+1)
{
	r=min(n/(n/l),n);
	sum=(sum-(s1(r)-s1(l-1)+p)%p*(n/l)%p+p)%p;
}
ans+=sum,sum=m*m%p;
for(ll l=1,r;l<=m;l=r+1)
{
	r=min(m/(m/l),m);
	sum=(sum-(s1(r)-s1(l-1)+p)%p*(m/l)%p+p)%p;
}
ans*=sum,ans%=p,sum=0;
```

------------
然后我们再看后面一部分。

$$
\sum\limits_{i=1}^n\left(n-\Big\lfloor\frac{n}{i}\Big\rfloor\times i\right)\times\left(m-\Big\lfloor\frac{m}{i}\Big\rfloor\times i\right)
$$

上面看到了除法分块，那么这儿多半也是了。这边有个 $n$ 和 $m$ 在括号里面不好弄，所以我们暴力拆括号把和 $i$ 无关的这个 $n,m$ 分离出来



$$
\sum\limits_{i=1}^n\left(nm-ni\Big\lfloor\frac{m}{i}\Big\rfloor-mi\Big\lfloor\frac{n}{i}\Big\rfloor+i^2\Big\lfloor\frac{n}{i}\Big\rfloor\Big\lfloor\frac{m}{i}\Big\rfloor\right)
$$

前三项非常好弄，第四项好像也可以除法分块，只不过俩变量所以块多一点不要紧。问题是 $i^2$ 前缀和咋搞？

我们知道 $i^2=i(i-1)+i=\binom{i}{2}+\binom{i}{1}$，因此

$$
\sum_{i=1}^n i^2=\sum_{i=1}^n\binom{i}{2}+i
$$

这个二项式系数是认真的？

不要紧我们有帕斯卡公式：$\binom{n}{k}=\binom{n-1}{k}+\binom{n-1}{k-1}$。因为当 $n<k$ 的时候二项式系数为 $0$，我们对等式右侧的第一个求和反复逆用帕斯卡公式：

$$
\begin{aligned}
\\ \sum_{i=1}^n= &\binom{0}{3}+\binom{1}{2}+\binom{2}{2}+\dots+\binom{n}{2}
\\ =& \binom{3}{3}+\binom{2}{2}+\dots+\binom{n-1}{2}+\binom{n}{2}
\\=&\binom{4}{3}+\dots+\binom{n-1}{2}+\binom{n}{2}
\\ =&\binom{n+1}{3}=\frac{n(n+1)(n-1)}{6}
\end{aligned}
$$

那么我们把 $\frac{n(n+1)(n-1)}{6}$ 带回原来的求和式，最终得到

$$
\sum_{i=1}^n i^2=\frac{n(n+1)(n-1)}{6}+\frac{n(n+1)}{2}=\frac{n(n+1)(2n+1)}{6}
$$

原来我们的 $i^2$ 的前缀和也是可以处理的！！

```cpp

for(ll l=1,r;l<=n;l=r+1)
{
	r=min(min(n/(n/l),m/(m/l)),n);
	sum+=(r-l+1)*n%p*m%p;
	sum-=(s1(r)-s1(l-1)+p)%p*((n/l)*m%p+(m/l)*n%p)%p;
	sum+=(s2(r)-s2(l-1)+p)%p*(n/l)%p*(m/l)%p;
	sum+=p,sum%=p;
}
```

然后呢？我们这道题就做完啦qaqq

------------
代码实现注意随时要 $\bmod\,p$，否则就是一片WA。

其他救世套路啦qaqq

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
inline ll read()
{
	ll x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return x*f;
}
const ll p=1000000007,inv2=500000004,inv6=166666668;
ll n,m,ans,sum;
#define s1(x) (x)*((x)+1)%p*inv2%p
#define s2(x) (x)*((x)+1)%p*(2*(x)+1)%p*inv6%p
inline ll min(ll a,ll b){return a<b?a:b;}
int main(){
	n=read(),m=read();
	if(n>m)swap(n,m);
	sum=n*n%p;
	for(ll l=1,r;l<=n;l=r+1)
	{
		r=min(n/(n/l),n);
		sum=(sum-(s1(r)-s1(l-1)+p)%p*(n/l)%p+p)%p;
	}
	ans+=sum,sum=m*m%p;
	for(ll l=1,r;l<=m;l=r+1)
	{
		r=min(m/(m/l),m);
		sum=(sum-(s1(r)-s1(l-1)+p)%p*(m/l)%p+p)%p;
	}
	ans*=sum,ans%=p,sum=0;
	for(ll l=1,r;l<=n;l=r+1)
	{
		r=min(min(n/(n/l),m/(m/l)),n);
		sum+=(r-l+1)*n%p*m%p;
		sum-=(s1(r)-s1(l-1)+p)%p*((n/l)*m%p+(m/l)*n%p)%p;
		sum+=(s2(r)-s2(l-1)+p)%p*(n/l)%p*(m/l)%p;
		sum+=p,sum%=p;
	}
	ans-=sum,ans+=p,ans%=p;
	printf("%lld\n",ans);
	return 0;
} 
```

---

## 作者：pomelo_nene (赞：4)

题意：给定 $n,m$，需要在 $O(\sqrt n)$ 的时间复杂度内求得下面式子的值：

$$\sum_{i=1}^n \sum_{j=1}^m (n \bmod i)(m \bmod j)[i ≠j]$$

首先简单容斥，假设 $n<m$，可以将式子化为下面的样子:

$$\sum_{i=1}^n \sum_{j=1}^m (n \bmod i)(m \bmod j)-\sum_{i=1}^{n}(n \bmod i)(m \bmod i)$$

两个式子不相关，考虑分别计算。左边一式长得不好看，首先将 $(n \bmod i) $ 一项移出来。原式化为：

$$\sum_{i=1}^n (n \bmod i) \sum_{j=1}^m (m \bmod j)$$

根据取模的定义得到：

$$\sum_{i=1}^n (n-i\times \lfloor \dfrac{n}{i} \rfloor) \times \sum_{i=1}^m (m-i\times \lfloor \dfrac{m}{i} \rfloor)$$

又将 $n$ 和 $m$ 提出来：

$$(n^2 - \sum_{i=1}^n i\times \lfloor \dfrac{n}{i} \rfloor) \times (m^2 -\sum_{i=1}^mi\times \lfloor \dfrac{m}{i} \rfloor)$$

有整除分块的样子了。

---
考虑整理右边的式子。根据定义式将其化为：

$$\sum_{i=1}^n(nm-m\times i\times \lfloor \dfrac{n}{i} \rfloor - n \times i \times \lfloor \dfrac{m}{i} \rfloor + \lfloor \dfrac{n}{i} \rfloor \times \lfloor \dfrac{m}{i} \rfloor \times i^2)$$

也是整除分块的样子。接下来考虑的是 $\sum_{i=1}^n i^2$ 怎么算。

从三次方入手开始降次。写出 $(n+1)^3-n^3=3n^2+3n+1$。同理可得 $n^3-(n-1)^3=3(n-1)^2+3(n-1)+1$。继续写下去，会得到 $2^3-1^3=3\times 1^3+3\times 1+1$。将这 $n$ 个式子加起来，得到 $(n+1)^3-1=3 \times (\sum_{i=1}^n i^2)+3\times (\sum_{i=1}^n i)$。

我们已经知道了 $\sum_{i=1}^n i=\dfrac{i \times (i+1)}{2}$，移项得到 $\sum_{i=1}^n i^2=\dfrac{n \times(n+1 \times (2n+1))}{6}$。

最后处理出 $2,6$ 的逆元。这道题就解决了。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef __int128 LL;
char buf[1<<21],*p1=buf,*p2=buf;
#define getchar() (p1==p2 && (p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
LL read()
{
	LL x=0,f=1;
	char c=getchar();
	while(c<'0' || c>'9')
	{
		if(c=='-')	f=-1;
		c=getchar();
	}
	while(c>='0' && c<='9')	x=(x<<1)+(x<<3)+(c^'0'),c=getchar();
	return x*f;
}
void write(LL x)
{
	if(x<0)	putchar('-'),x=-x;
	if(x>9)	write(x/10);
	putchar(x%10+'0');
}
const LL MOD=19940417,inv2=9970209,inv6=3323403;
LL line(LL p){return p*(p+1)/2;}
LL square(LL p){return p*(p+1)*(2*p+1)/6;}
LL n,m;
int main(){
	n=read(),m=read();
	if(n>m)	n^=m^=n^=m;
	LL a=0;
	for(LL l=1,r;l<=n;l=r+1)
	{
		r=n/(n/l);
		a+=(n/l)*(line(r)-line(l-1));
	}
	a=n*n-a;
	LL b=0;
	for(LL l=1,r;l<=m;l=r+1)
	{
		r=m/(m/l);
		b+=(m/l)*(line(r)-line(l-1));
	}
	b=m*m-b;
	LL c=n*m*n;
	LL k=0;
	for(LL l=1,r;l<=n;l=r+1)
	{
		r=min(n/(n/l),m/(m/l));
		r=min(r,n);
		k+=(n/l)*(line(r)-line(l-1));
	}
	c-=k*m;
	k=0;
	for(LL l=1,r;l<=n;l=r+1)
	{
		r=min(n/(n/l),m/(m/l));
		r=min(r,n);
		k+=(m/l)*(line(r)-line(l-1));
	}
	c-=k*n;
	k=0;
	for(LL l=1,r;l<=n;l=r+1)
	{
		r=min(n/(n/l),m/(m/l));
		r=min(r,n);
		k+=(n/l)*(m/l)*(square(r)-square(l-1));
	}
	c+=k;
	LL res=a*b-c;
	res%=MOD;
	res+=MOD;
	res%=MOD;
	write(res);
	return 0;
}
```

---

## 作者：JK_LOVER (赞：4)

## 分析
已知：
$$
n \mod m=n-\lfloor \frac{n}{m} \rfloor \times m
$$
$$
ans=ans_1-ans_2
$$
$$
ans_1=\sum_i^n\sum_j^m(n - \lfloor \frac{n}{i} \rfloor \times i)\times (m-\lfloor \frac{m}{j} \rfloor \times j)
$$
$$
ans_1=\sum_i^n(n - \lfloor \frac{n}{i} \rfloor \times i)\times \sum_j^m(m-\lfloor \frac{m}{j} \rfloor \times j)
$$
$$
ans_2=\sum_i^n(n - \lfloor \frac{n}{i} \rfloor \times i)\times (m-\lfloor \frac{m}{i} \rfloor \times i)
$$
$$
ans_2=\sum_i^n(n m-\lfloor \frac{n}{i} \rfloor \times i\times m-\lfloor \frac{m}{i} \rfloor \times i\times n+\lfloor \frac{n}{i} \rfloor\lfloor \frac{m}{i} \rfloor\times i^2)
$$
令：
$$
f(x) = \sum_i^x(x - \lfloor \frac{x}{i} \rfloor \times i)=x^2-\sum_i^x (\lfloor \frac{x}{i} \rfloor \times i) 
$$
$$
g(x) = \sum_i^n(\lfloor \frac{n}{i} \rfloor \times i)
$$
考虑 $g(x)$ 的快速求法，因为一个为 $n$ 的数不可能有超过 $\sqrt{n}$ 个除数，所以：
$$
g(x) = \sum_i^n(\lfloor \frac{n}{i} \rfloor \times i) 
$$
因为 $k$ 的取值不超过 $\sqrt{n}$ 所以复杂度为 $O(\sqrt{n})$ 。
所以 $f(x) = x^2-g(x)$ ，则：
$$
ans_1=f(n)\times f(m) = n^2m^2-n^2g(m)-m^2g(n)+g(n)g(m)
$$
现在考虑 $ans_2$ :
$$
ans_2=(n^2 m-m\times g(n)-n \times g(m) +\sum_i^n\lfloor \frac{n}{i} \rfloor\lfloor \frac{m}{i} \rfloor\times i^2)
$$
由于 
$$
\sum_i^ni^2=\frac{n(2n+1)(n+1)}{6}
$$
所以 
$
\sum_i^n\lfloor \frac{n}{i} \rfloor\lfloor \frac{m}{i} \rfloor\times i^2 
$
可以在 $O(\sqrt{n})$ 的时间复杂度内求出来。
$$
ans=n^2m^2-n^2g(m)-m^2g(n)+g(n)g(m)-(n^2 m-m\times g(n)-n \times g(m) +\sum_i^n\lfloor \frac{n}{i} \rfloor\lfloor \frac{m}{i} \rfloor\times i^2)
$$
## 代码
因为取模挂了，直接__int128，如有大佬发现是哪里挂了，求解。
```cpp
#include<bits/stdc++.h>
#define int __int128
using namespace std;
const int mod = 1000000007;
inline int read()
{
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}

inline void write(int x)
{
    if(x<0)
    {
        putchar('-');
        x=-x;
    }
    if(x>9)
        write(x/10);
    putchar(x%10+'0');
}
void exgcd(int a,int b,int &x,int &y)
{
	if(b == 0){x = 1;y = 0;return;}
	exgcd(b,a%b,x,y);
	int k = x;
	x = y;
	y = k - a/b*x;
}
int inv2,inv6,n,m,xzc,ans1,ans2,ans;
int sum2(int x)
{
	return x%mod*(2*x+1)%mod*(x+1)%mod*inv6%mod;
}
int sum1(int x)
{
	return (x*(x+1))%mod*inv2%mod;
}
int solve(int n)
{
	int ans = 1LL*n*n % mod;
	for(int l = 1,r;l <= n;l=r+1)
	{
		r = n/(n/l);
		ans = (ans-(sum1(r)-sum1(l-1))*(n/l)+mod)%mod;
	}
	return ans;
}
signed main()
{
	exgcd(2,mod,inv2,xzc);
	exgcd(6,mod,inv6,xzc);
	n = read();m = read();
	if(n>m) swap(n,m);
	ans1 = solve(n) * solve(m) % mod;
	ans2 = 1LL*n*m*n%mod;
	for(int l = 1,r;l<=n;l=r+1)
	{
		r = min(n/(n/l),m/(m/l));
		ans2 = (ans2-((sum1(r)-sum1(l-1)+mod)%mod*(((n/l)*m +(m/l)*n)+mod)%mod+mod)%mod+mod)%mod;
		ans2 = (ans2+1LL*(sum2(r)-sum2(l-1)+mod)%mod*(n/l)%mod*(m/l)%mod+mod) % mod;
	}
	ans = ans1-ans2;
	ans = (ans+mod)%mod;
	write(ans);
}
```
[博客地址](https://www.luogu.com.cn/blog/xzc/solution-p2834)

---

## 作者：Lates (赞：3)

半个月前就想做这题了（今天AC来水个题解。

---

默认 $n\le m,a/b=\lfloor\frac{a}{b}\rfloor$

有人问我为什么可以默认 $n\le m$ ，其实就是为了一般性，在程序中只要体现成 当 $n>m$ 就 `swap(n,m)` 就行。（其实是为了少写 $\min(n,m)$

首先有

$a\bmod b=a-b(a/b)$

考虑容斥

$$\sum_{i=1}^{n}(n \bmod i)\sum_{j=1}^{m}(m\bmod j)-\sum_{i=1}^{n}(n\bmod i)(m\bmod i)$$

然后设

$$f(n,x)=\sum_{i=1}^{n}i(x/i)$$

则 
$$\sum_{i=1}^{n}(n\bmod i)=\sum_{i=1}^{n}n-i(n/i)=n^2-\sum_{i=1}^{n}i(n/i)$$

这样的式子可以用类似求法。

这个和余数求和那题比较像，可以数论分块 $O(\sqrt n)$，so

$$原式=(n^2-f(n,n))(m^2-f(m,m))-\sum_{i=1}^{n}(n\bmod i)(m\bmod i)$$

$$=(n^2-f(n,n))(m^2-f(m,m))-\sum_{i=1}^{n}(n-i(n/i))(m-i(m/i))$$

考虑推倒容斥的部分

$$\sum_{i=1}^{n}(n-i(n/i))m-(n-i(n/i))i(m/i)$$
$$=\sum_{i=1}^{n}nm-mi(n/i)-ni(m/i)+i^2(n/i)(m/i)$$
$$=n^2m-m\sum_{i=1}^{n}i(n/i)-n\sum_{i=1}^{n}i(m/i)+\sum_{i=1}^{n}i^2(n/i)(m/i)$$

$$=n^2m-mf(n,n)-nf(n,m)+\sum_{i=1}^{n}i^2(n/i)(m/i)$$

发现最后一个 sigma 还是可以数论分块 $O(\sqrt n)$ 求。

so 预处理 $f(n,n),f(n,m),f(m,m)$ 和 上面的东西，就做完了。

最终复杂度$O(\sqrt n)$

$Code:$

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
typedef long long ll;
const ll P=19940417;
inline ll read(){
	register ll x=0,f=0,ch=getchar();
	while('0'>ch||ch>'9')f^=ch=='-',ch=getchar();
	while('0'<=ch&&ch<='9')x=(x<<1)+(x<<3)+(ch^'0'),ch=getchar();
	return f?-x:x;
}
inline ll sum0(ll l,ll r){
	return 1LL*(r-l+1)*(l+r)%P*9970209%P;
}
inline ll sum(ll x){
	x%=P;
	return (1LL*x*(x+1)%P*((x+x)%P+1)%P*3323403%P)%P;
}
inline ll solve(ll t,ll x){
	register ll res=0;
	for(register int l=1,r;l<=t;l=r+1){
		if(x/l==0)r=t;
		else r=min(x/(x/l),t);
		res+=1LL*sum0(l,r)*(x/l)%P;
		res%=P;
	}	
	return res%P;
}
ll a,b,c;
ll n,m,f1,f2,f3,f4,ans;
inline void solved(){
	for(register int l=1,r;l<=n;l=r+1){
		r=min(n/(n/l),m/(m/l));
		f4+=1LL*(sum(r)%P-sum(l-1)%P+P)%P*(n/l)%P*(m/l)%P;
		f4%=P;
	}
}
signed main(){
	n=read(),m=read();
	if(n>m)n^=m^=n^=m;
	f1=solve(n,n);
	f2=solve(n,m);
	f3=solve(m,m);
	solved();
	ans=1LL*(1LL*n*n%P-f1+P)%P*(1LL*m*m%P-f3+P)%P;
	ans-=1LL*(1LL*n*n%P*m%P-(1LL*m*f1%P)-(1LL*n*f2%P)+f4)%P;
	ans=(ans+P)%P;
	printf("%lld\n",ans);
	return 0;
}

```

---

## 作者：陈曦 (赞：3)

话说这道题与[P2260](https://www.luogu.org/problemnew/show/P2260#sub)
一样啊，只是模数不一样。

也是[P2261](https://www.luogu.org/problemnew/show/P2261)的升级版，三倍经验收下了。

这道题我的解法来自2261的分块题解，跑得不比反演慢。

$ans=\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m}(n\mod i)\times (m\mod j)(i!=j)$

根据容斥，$ans=\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m}(n\mod i)\times (m\mod j)-\sum\limits_{i=1}^{min(n,m)}(n\mod i)\times (m\mod i)$

这样我们发现就是两个P2260累乘再减去一个值。

这样我们就可以分成两块了

$n\mod i=n-[n/i]$

$\sum\limits_{i=1}^{n}(n\mod i)=\sum\limits_{i=1}^{n}[n/i]\times i=n^2-\sum\limits_{i=1}^{n}[n/i]*i$

$m$ 也是同理，这样就可以套分块了，现在考虑


$\sum\limits_{i=1}^{min(n,m)}(n\mod i)\times (m\mod i)$

$\sum\limits_{i=1}^{min(n,m)}(n-[n/i])\times (m-[m/i])$

拆开括号

$\sum\limits_{i=1}^{min(n,m)}(n\times m-i\times (m\times [n/i]+n\times [m/i])+[n/i]\times [m/i]*i^2)$

其他还好，$\sum\limits_{i=1}^{min(n,m)}i^2$怎么求？

其实有一个公式：$\sum\limits_{i=1}^{n}i^2=n\times (n+1)\times (2n+1)/6$

也容易证明

我们先计算得当 $n=1,2$ 时等式成立。

再假设当 $n=x$ 时等式成立。

即 $1^2+2^2+3^3+...+x^2=x\times (x+1)\times (2x+1)/6$

我们再考虑 $x+1$

$1^2+2^2+3^3+...+x^2+(x+1)^2$

$=x\times (x+1)\times (2x+1)/6+(x+1)^2$

$=(x+1)\times (2x^2+x+6x+6)/6$

$=(x+1)\times (2x^2+7x+6)/6$

$=(x+1)\times (2x+3)\times (x+2)/6$

仔细观察，这不就是 $n=x+1$ 时，公式的情况吗？

如果这样递推下去，发现当 $n$ 为正整数时等式成立，这就是数学归纳法

所以就可以 $O(1)$ 算了。

但是还有一个地方，公式除 $6$ 是不能直接算的，所以我们用快速幂或扩欧求一下逆元就好了。

至于代码，因为太丑我就不发了，基本上就是裸的分块了，就几个这种for循环
```
for(long long i=1,j;i<=min(n,m);i=j+1)
```


---

## 作者：HohleFeuerwerke (赞：2)

### 前言

没想到清华集训也有可做题，而且还挺无脑……

[P2260 [清华集训2012]模积和](https://www.luogu.com.cn/problem/P2260)。

---

### 正文

求的是这样一个式子：

$$\sum_{i=1}^n\sum_{j=1}^m(n\operatorname{mod}i)(m\operatorname{mod}j),i≠j$$

显然如果没有 $i≠j$ 会很好做。所以我们考虑大力分类讨论。

$$ys=\sum_{i=1}^n\sum_{j=1}^m(n\operatorname{mod}i)(m\operatorname{mod}j)-\sum_{i=1}^{\min(n,m)}(n\operatorname{mod}i)(m\operatorname{mod}i)$$

然后我们分开来看，我们假设：

$$x=\sum_{i=1}^n\sum_{j=1}^m(n\operatorname{mod}i)(m\operatorname{mod}j)$$

$$y=\sum_{i=1}^{\min(n,m)}(n\operatorname{mod}i)(m\operatorname{mod}j)$$

那么原式就可以表示成 $ys=x-y$。我们分解开来对 $x$ 和 $y$ 去分析一波。

$$x=\sum_{i=1}^n(n\operatorname{mod}i)\sum_{j=1}^m(m\operatorname{mod}j)$$
看到取模有常规操作 $a\operatorname{mod}b=a-b\times\lfloor\frac{a}{b}\rfloor$。所以我们把这个式子往上面回代：

$$x=\sum_{i=1}^n(n-\lfloor\frac{n}{i}\rfloor\times i)\sum_{j=1}^m(m-\lfloor\frac{m}{j}\rfloor\times j)$$

对于这个式子有个比较好的处理方法。因为这两部分看起来非常相似所以我们设：

$$p(x)=\sum_{i=1}^x(x-\lfloor\frac{x}{i}\rfloor\times i)$$

显然可以得到：

$$x=p(n)p(m)$$

然后我们对这个 $p(x)$ 进行化简：

$$p(x)=x^2-\sum_{i=1}^x(\lfloor\frac{x}{i}\rfloor\times i)$$

后面那个式子好像在 [这里](https://www.luogu.com.cn/problem/P2261) 见过，所以我们设：

$$l(x,k)=\sum_{i=1}^x(\lfloor\frac{k}{i}\rfloor\times i)$$

这个 $l$ 就可以用整除分块求解。然后我们把他回代：

$$p(x)=x^2\times l(x,x)$$

这样我们就把前面半部分搞定了，接下来搞后半部分，

$$y=\sum_{i=1}^{\min(n,m)}(n\operatorname{mod}i)(m\operatorname{mod}i)$$

同样的，我们可以把 $\operatorname{mod}$ 化出来：

$$y=\sum_{i=1}^{\min(n,m)}(n-\lfloor\frac{n}{i}\rfloor\times i)(m-\lfloor\frac{m}{i}\rfloor\times i)$$

然后把这个括号打开：

$$y=\sum_{i=1}^{\min(n,m)}(nm-\lfloor\frac{n}{i}\rfloor\times i\times m-\lfloor\frac{m}{i}\rfloor\times i\times n-\lfloor\frac{n}{i}\rfloor\times\lfloor\frac{m}{i}\rfloor\times i^2)$$

这个时候把 $\sum$ 拆开是个比较好的选择。如果仍然保留着 $\min$ 会很难受，所以我们设 $n=\min(n,m)$。

$$y=n^2m-m\sum_{i=1}^n(\lfloor\frac{n}{i}\rfloor\times i)-n\sum_{i=1}^n(\lfloor\frac{m}{i}\rfloor\times i)-\sum_{i=1}^n(i^2\times\lfloor\frac{n}{i}\rfloor\times\lfloor\frac{m}{i}\rfloor)$$

你会发现前面两个式子我们曾经定义过，直接使用就行：

$$y=n^2m-m\times l(n,n)-n\times l(n,m)-\sum_{i=1}^n(i^2\times \lfloor\frac{n}{i}\rfloor\times\lfloor\frac{m}{i}\rfloor)$$

然后除掉 $n^2m$ 可以用 $\Theta(1)$ 求出，前面后面都可以用整除分块解决。并且我们有：

$$\sum_{i=1}^ni^2=\frac{n\times(n+1)\times(2n+1)}{6}$$

所以我们把 $x,y$ 合并一下：

$$ys=n^2m^2\times l(n,n)\times l(m,m)-n^2m+m\times l(n,n)+n\times l(n,m)+\sum_{i=1}^n(i^2\times \lfloor\frac{n}{i}\rfloor\times\lfloor\frac{m}{i}\rfloor)$$

再处理一下就可以整除分块解决了。

处理细节也是有的，比如这个模数不是素数，所以要用 $\text{ksm}$ 预处理一下 $2$（用于整除分块）和 $6$（用于区间平方和）的逆元，然后就可以愉快的把这题切了。

---

### 参考文献

[command_block 整除分块入门小记](https://www.luogu.com.cn/blog/command-block/zheng-chu-fen-kuai-ru-men-xiao-ji)

---

## 作者：henry_y (赞：2)

你谷不资瓷公式块，差评

直接给图片

![TIM截图20181231222419.png](https://i.loli.net/2018/12/31/5c2a26d1a9f2b.png)

实在看不惯这图片的可以到我的[博客园的blogs](https://www.cnblogs.com/henry-1202/p/10201032.html)看

```cpp
#include <bits/stdc++.h>
using namespace std;

#define ll long long
#define N 2010
#define mod 19940417
const ll m6 = 3323403;
ll n, m;
ll ans = 0;

ll sum(ll l, ll r) {
    return (r - l + 1) * (l + r) / 2 % mod;
}

ll calc(ll k) {
    ll ans = k * k % mod;
    for(int l = 1, r; l <= k; l = r + 1) {
        r = k / (k / l);
        ans = ((ans - sum(l, r) * (k / l) % mod) % mod + mod) % mod; 
    } 
    return ans;
}

ll cal(ll x) {
    return x * (x + 1) % mod * (2 * x + 1) % mod * m6 % mod;
}

ll sum2(ll l, ll r) {
    return (cal(r) - cal(l - 1) + mod) % mod;
} 

int main() {
    scanf("%lld%lld", &n, &m);
    if(n > m) swap(n, m);
    ans = calc(n) * calc(m) % mod;
    ans = ((ans - n * n % mod * m % mod) % mod + mod) % mod; 
    for(int l = 1, r; l <= n; l = r + 1) {
        r = min(n / (n / l), m / (m / l));
        ans = (ans + sum(l, r) * ((n/l)*m % mod + (m/l)*n % mod) % mod % mod);
        ans = (ans - sum2(l, r) * (n/l) % mod * (m/l) % mod + mod) % mod;
    }
    printf("%lld\n", (ans % mod + mod) % mod);
    return 0;
}
```

---

## 作者：AE酱 (赞：2)

![](http://m.qpic.cn/psb?/V14FBJZS3lmtUs/CDAUAsaqmef3jNHZzBxmOw7Uc762PTsn2VIryNuoJ\*o!/b/dD8BAAAAAAAA&bo=DQOAAgAAAAADB64!&rf=viewer\_4)


代码：

    
```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cstdio>
using namespace std;
#define LL long long
const LL MOD=19940417;
LL n,m,Ans=0;
inline void solve(){
    LL midA=0;
    for(LL L=1,R;L<=n;L=R+1){
        R=min(n/(n/L),n);
        midA=(midA-(n/L)*(((L+R)*(R-L+1)%MOD)*9970209%MOD+MOD)%MOD+MOD)%MOD;
    }
    midA=(midA+n*n%MOD)%MOD;
    LL midB=0;
    for(LL L=1,R;L<=m;L=R+1){
        R=min(m/(m/L),m);
        midB=(midB-(m/L)*(((L+R)*(R-L+1)%MOD)*9970209%MOD+MOD)%MOD+MOD)%MOD;
    }
    midB=(midB+m*m%MOD)%MOD;
    Ans=midA*midB%MOD;
    //减去 i==j 的情况 
    Ans=(Ans-(n*n%MOD)*m%MOD+MOD)%MOD;
    for(LL L=1,R;L<=n;L=R+1){ 
        R=min(n/(n/L),min(m/(m/L),n));
        LL sum=(((L+R)*(R-L+1)%MOD)*9970209%MOD+MOD)%MOD; //从 L加到R的和，9970209是2在模19940417下的乘法逆元 
        LL sum2=(((R*(R+1)%MOD)*(2*R+1)%MOD-((L-1)*L%MOD)*(2*L-1)%MOD+MOD)%MOD)*3323403%MOD; //L到R的平方和，3323403是6在模19940417下的乘法逆元 
        Ans=(Ans+(n*(m/L)%MOD)*sum%MOD)%MOD;
        Ans=(Ans+(m*(n/L)%MOD)*sum%MOD)%MOD;
        Ans=(Ans-((n/L)*(m/L)%MOD)*sum2%MOD+MOD)%MOD;
    }
}
int main(){
    scanf("%lld %lld",&n,&m);
    if(n>m) swap(n,m);
    solve();
    printf("%lld\n",Ans%MOD);
    return 0;
}
```

---

## 作者：pomelo_nene (赞：1)

题意：给定 $n,m$，需要在 $O(\sqrt n)$ 的时间复杂度内求得下面式子的值：

$$\sum_{i=1}^n \sum_{j=1}^m (n \bmod i)(m \bmod j)[i ≠j]$$

首先简单容斥，假设 $n<m$，可以将式子化为下面的样子:

$$\sum_{i=1}^n \sum_{j=1}^m (n \bmod i)(m \bmod j)-\sum_{i=1}^{n}(n \bmod i)(m \bmod i)$$

两个式子不相关，考虑分别计算。左边一式长得不好看，首先将 $(n \bmod i) $ 一项移出来。原式化为：

$$\sum_{i=1}^n (n \bmod i) \sum_{j=1}^m (m \bmod j)$$

根据取模的定义得到：

$$\sum_{i=1}^n (n-i\times \lfloor \dfrac{n}{i} \rfloor) \times \sum_{i=1}^m (m-i\times \lfloor \dfrac{m}{i} \rfloor)$$

又将 $n$ 和 $m$ 提出来：

$$(n^2 - \sum_{i=1}^n i\times \lfloor \dfrac{n}{i} \rfloor) \times (m^2 -\sum_{i=1}^mi\times \lfloor \dfrac{m}{i} \rfloor)$$

有整除分块的样子了。

---
考虑整理右边的式子。根据定义式将其化为：

$$\sum_{i=1}^n(nm-m\times i\times \lfloor \dfrac{n}{i} \rfloor - n \times i \times \lfloor \dfrac{m}{i} \rfloor + \lfloor \dfrac{n}{i} \rfloor \times \lfloor \dfrac{m}{i} \rfloor \times i^2)$$

也是整除分块的样子。接下来考虑的是 $\sum_{i=1}^n i^2$ 怎么算。

从三次方入手开始降次。写出 $(n+1)^3-n^3=3n^2+3n+1$。同理可得 $n^3-(n-1)^3=3(n-1)^2+3(n-1)+1$。继续写下去，会得到 $2^3-1^3=3\times 1^3+3\times 1+1$。将这 $n$ 个式子加起来，得到 $(n+1)^3-1=3 \times (\sum_{i=1}^n i^2)+3\times (\sum_{i=1}^n i)$。

我们已经知道了 $\sum_{i=1}^n i=\dfrac{i \times (i+1)}{2}$，移项得到 $\sum_{i=1}^n i^2=\dfrac{n \times(n+1 \times (2n+1))}{6}$。

最后处理出 $2,6$ 的逆元。这道题就解决了。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef __int128 LL;
char buf[1<<21],*p1=buf,*p2=buf;
#define getchar() (p1==p2 && (p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
LL read()
{
	LL x=0,f=1;
	char c=getchar();
	while(c<'0' || c>'9')
	{
		if(c=='-')	f=-1;
		c=getchar();
	}
	while(c>='0' && c<='9')	x=(x<<1)+(x<<3)+(c^'0'),c=getchar();
	return x*f;
}
void write(LL x)
{
	if(x<0)	putchar('-'),x=-x;
	if(x>9)	write(x/10);
	putchar(x%10+'0');
}
const LL MOD=1000000007,inv2=500000004,inv6=166666668;
LL line(LL p){return p*(p+1)/2;}
LL square(LL p){return p*(p+1)*(2*p+1)/6;}
LL n,m;
int main(){
	n=read(),m=read();
	if(n>m)	n^=m^=n^=m;
	LL a=0;
	for(LL l=1,r;l<=n;l=r+1)
	{
		r=n/(n/l);
		a+=(n/l)*(line(r)-line(l-1));
	}
	a=n*n-a;
	LL b=0;
	for(LL l=1,r;l<=m;l=r+1)
	{
		r=m/(m/l);
		b+=(m/l)*(line(r)-line(l-1));
	}
	b=m*m-b;
	LL c=n*m*n;
	LL k=0;
	for(LL l=1,r;l<=n;l=r+1)
	{
		r=min(n/(n/l),m/(m/l));
		r=min(r,n);
		k+=(n/l)*(line(r)-line(l-1));
	}
	c-=k*m;
	k=0;
	for(LL l=1,r;l<=n;l=r+1)
	{
		r=min(n/(n/l),m/(m/l));
		r=min(r,n);
		k+=(m/l)*(line(r)-line(l-1));
	}
	c-=k*n;
	k=0;
	for(LL l=1,r;l<=n;l=r+1)
	{
		r=min(n/(n/l),m/(m/l));
		r=min(r,n);
		k+=(n/l)*(m/l)*(square(r)-square(l-1));
	}
	c+=k;
	LL res=a*b-c;
	res%=MOD;
	res+=MOD;
	res%=MOD;
	write(res);
	return 0;
}
```

---

## 作者：loceaner (赞：1)

## [题目链接](https://www.luogu.com.cn/problem/P2260)

## 思路

求 $\sum\limits_{i = 1}^{n} (n \mod i)\sum\limits_{j=1}^{m}(m\mod j)[i\neq j]$

假设没有限制情况$i\neq j$

$\sum\limits_{i = 1}^{n} (n \mod i)\sum\limits_{j=1}^{m}(m\mod j)$

只看左半部分：

$\ \ \ \sum\limits_{i=1}^{n}(n\% i)$

$= \sum\limits_{i=1}^{n}(n - \lfloor \frac{n}{i}\rfloor * i)$

$= \sum\limits_{i=1}^{n}n - \sum\limits_{i = 1}^{n}\lfloor\frac{n}{i}\rfloor*i$

显然数论分块，右半部分同理，都可以数论分块做(余数求和那道题的完全一样的做法)

再看$i=j$的情况，即

$ \sum\limits_{i=1}^{k=\min(n,m)}(n\mod i)(m\mod i)$

$=\sum\limits_{i=1}^{k}(n-\lfloor\frac{n}{i}\rfloor*i)(m-\lfloor\frac{m}{i}\rfloor*i)$

$=\sum\limits_{i=1}^{k}(nm-(\lfloor\frac{n}{i}\rfloor*m+\lfloor\frac{m}{i}\rfloor*n)*i+\lfloor\frac{n}{i}\rfloor*\lfloor\frac{m}{i}\rfloor*i^2)$

用数论分块求出上面两个式子，用总的减去下面这个式子，注意除法要用逆元

> $ps$：
>
> 1. 能模就模，好事多模
>
> 2. 小知识点
>
>    $$\sum\limits_{i = l}^{r}i=(r -l + 1)*(l + r) / 2$$
>
>    $$\sum\limits_{i = 1} ^{n}i^2= n * (n + 1) * (2* n + 1)/ 6$$

时间复杂度$O(\sqrt{n})$

## 代码

```cpp
/*
Author:loceaner
*/
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define int long long
using namespace std;

const int A = 5e5 + 11;
const int B = 1e6 + 11;
const int inv6 = 3323403;
const int inv2 = 9970209;
const int mod = 19940417;
const int inf = 0x3f3f3f3f;

inline int read() {
	char c = getchar();
	int x = 0, f = 1;
	for( ; !isdigit(c); c = getchar()) if(c == '-') f = -1;
	for( ; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
	return x * f;
}

int n, m, k;

inline int sum(int l, int r) {
	return (r - l + 1) * (l + r) / 2 % mod;
}

inline int sum1(int r) {
	return r * (r + 1) % mod * (2 * r + 1) % mod * inv6 % mod;
}

inline int sum2(int l, int r) {
	return (sum1(r) - sum1(l - 1)) % mod;
}

inline int solve(int n) {
	int ans = n * n;
	for (int l = 1, r; l <= n; l = r + 1) {
		if (n / l == 0) break;
		r = min(n / (n / l), n);
		ans -= (n / l) % mod * sum(l, r) % mod;
		ans %= mod;
	}
	return (ans % mod + mod) % mod;
}

signed main() {
	n = read(), m = read();
	int ans1 = solve(n) * solve(m) % mod, ans2 = 0;
	for (int l = 1, r, now1, now2, now3, now4; l <= min(n, m); l = r + 1) {
		r = min(n / (n / l), m / (m / l));
		now1 = n * m % mod * (r - l + 1) % mod;
		now2 = ((n / l) * (m / l) % mod * sum2(l, r) % mod + mod) % mod;
		now3 = ((n / l) * m % mod + (m / l) * n % mod) * sum(l, r) % mod;
		now4 = (now1 + now2 - now3 + mod) % mod;
		ans2 = (ans2 + now4) % mod;
	}
	cout << ((ans1 - ans2) % mod + mod) % mod;
	return 0;
}
```

---

## 作者：pantw (赞：1)

做法参考自[hzwer的Blog](http://hzwer.com/6113.html)。

推式子过程可以前往上述Blog观看。


这里分享需要注意的几个小细节：

1. 涉及爆int的地方全部要用long long。


2. 程序中，我们计算$\sum\limits_{i=1}^{n}i^2$的时候需要除6，涉及到求6的逆元。但模数不是质数的时候不能用费马小定理求逆元，应换用欧拉定理或拓展欧几里得算法（exgcd），下面的程序就是用exgcd求6的逆元的。当然你也可以事先计算好6的逆元，在代码中直接使用。


3. 此类数学题在调试的时候可以使用单元测试的方式，即分别测试一个个小函数是否写错，这样查错会比较快。


4. 宁可多用几个`%MOD`，也不要漏写任何一个`%MOD`。比如说减的时候一般要`+ MOD) % MOD`，有的时候甚至需要`((x-y)%MOD+MOD)%MOD`。


其余实现细节详见代码。


```cpp
#include <cstdio>
#define MOD 19940417
#define Lovelive long long
#define lld "%lld"
#define min(a, b) ((a) < (b) ? (a) : (b))
// 拓展欧几里得算法
Lovelive exgcd(Lovelive a, Lovelive b, Lovelive& x, Lovelive& y) {
    if(!b) {
        x = 1, y = 0;
        return a;
    }
    else {
        Lovelive ret = exgcd(b, a % b, y, x);
        y -= a / b * x;
        return ret;
    }
}
// 计算逆元
Lovelive getinv(int arg) {
    Lovelive x, y;
    exgcd(MOD, arg, x, y);
    return y > 0 ? y : -y; // 取abs
}

const Lovelive inv6 = getinv(6); // 当然可以提前算出它就是3323403。

Lovelive sum1(Lovelive x) { // 计算sigma(i)
    return x * (x + 1) / 2 % MOD;
}

Lovelive dif1(Lovelive l, Lovelive r) {
    return (sum1(r) - sum1(l - 1) + MOD) % MOD;
}

Lovelive sum2(Lovelive x) { // 计算sigma(i^2)
    return x * (x + 1) % MOD * (2 * x + 1) % MOD * inv6 % MOD;
}

Lovelive dif2(Lovelive l, Lovelive r) {
    return (sum2(r) - sum2(l - 1) + MOD) % MOD;
}

Lovelive calc(Lovelive n) { // 计算sigma(n % i)
    Lovelive ret = 0;
    for(int i = 1, j; i <= n; i = j + 1) {
        j = n / (n/i);
        ret = (ret + n * (j-i+1) % MOD - dif1(i, j) * (n/i) % MOD + MOD) % MOD;
    }
    return (ret + MOD) % MOD;
}

Lovelive n, m, li, s1, s2, s3;

int main() {
    scanf(lld lld, &n, &m);
    Lovelive ans = calc(n) * calc(m) % MOD;
    li = min(n, m);
    for(int i = 1, j; i <= li; i = j + 1) {
        j = min(n / (n/i), m / (m/i)); // 根号分块
        s1 = (s1 + n * m % MOD * (j-i+1)) % MOD; // 常数项
        s2 = (s2 + (n * (m/i) + m * (n/i)) % MOD * dif1(i, j)) % MOD; // 一次项
        s3 = (s3 + (n/i) * (m/i) % MOD * dif2(i, j) % MOD) % MOD; // 二次项
    }
    ans = ((ans - s1 + s2 - s3) % MOD + MOD) % MOD;
    printf(lld, ans);
}
```

---

## 作者：whiteqwq (赞：1)

[P2834 能力测验](https://www.luogu.com.cn/problem/P2834)解题报告：

[更好的阅读体验](https://zybuluo.com/xiaoziyao/note/1724305)

双倍经验：[P2260 [清华集训2012]模积和](https://www.luogu.com.cn/problem/P2260)

## 题意
题意：求$\sum_{i=1}^n\sum_{j=1}^m[i\ne j](n\bmod i)\cdot(m\bmod j)$。

数据范围：$1\leqslant n,m\leqslant 10^9$。

## 分析

这是一道简单的推式子题，但是实现比较恶心。

首先不妨设$n\leqslant m$（如果$n>m$交换一下就好了）

然后可以用容斥将题目拆成两个部分：

$$\sum_{i=1}^n\sum_{j=1}^m(n\bmod i)\cdot(m\bmod j)-\sum_{i=1}^n(n\bmod i)\cdot(m\bmod i)$$

将两个求和拆开：

$$\sum_{i=1}^n(n\bmod i)\cdot\sum_{j=1}^m(m\bmod j)-\sum_{i=1}^n(n\bmod i)\cdot(m\bmod i)$$

因为取模很难搞，所以可以用一个性质$a\bmod b=a-\lfloor\frac{a}{b}\rfloor\cdot b$（取模的定义），将上式转换为：

$$\sum_{i=1}^n(n-\lfloor\frac{n}{i}\rfloor\cdot i)\cdot\sum_{j=1}^m(m-\lfloor\frac{m}{j}\rfloor\cdot j)-\sum_{i=1}^n(n-\lfloor\frac{n}{i}\rfloor\cdot i)\cdot(m-\lfloor\frac{m}{i}\rfloor\cdot i)$$

将括号拆开，可以得到：

$$(n^2-\sum_{i=1}^ni\cdot\lfloor\frac{n}{i}\rfloor)\cdot(m^2-\sum_{i=1}^mi\cdot\lfloor\frac{m}{i}\rfloor)-\sum_{i=1}^n(nm-mi\cdot\lfloor\frac{n}{i}\rfloor-ni\cdot\lfloor\frac{m}{i}\rfloor+i^2\cdot\lfloor\frac{n}{i}\rfloor\cdot\lfloor\frac{m}{i}\rfloor)$$

此时我们的复杂度已经是$O(n)$了，然而这个复杂度仍然不足以通过本题。

要做这道题需要一个简单的技巧——整除分块。

我们很容易发现很多$\lfloor\frac{n}{i}\rfloor$的值是一样的，且所有的$\lfloor\frac{n}{i}\rfloor$为一个不下降子序列，呈块状分布

通过简单的计算可以得到，对于每个起点为$i$的块，它的值为$\lfloor\frac{n}{i}\rfloor$，终点为$\lfloor\frac{n}{\lfloor\frac{n}{i}\rfloor}\rfloor$，然后我们就可以用$O(\sqrt{n})$的算法计算$\sum_{i=1}^ni\cdot \lfloor\frac{n}{i}\rfloor$了：

主要步骤，对于每一个块$[l,r]$，它乘号前面前缀和差分得到，即$(1+2+\cdots+r)-(1+2+\cdots+(l-1))$，乘号后面的就是$\lfloor\frac{n}{l}\rfloor$。

代码：

```
inline long long sum1(long long x){
	return x*(x+1)%mod*inv2%mod;
}

l=1,sum=n*n%mod;
while(l<=n){
	r=n/(n/l);
	sum=(sum-(sum1(r)-sum1(l-1)+mod)%mod*(n/l)%mod+mod)%mod;
	l=r+1;
}
```

同样，$\sum_{i=1}^mi\cdot \lfloor\frac{m}{i}\rfloor$的值也可以用相同的方法求得。

考虑求$\sum_{i=1}^n(nm-mi\cdot\lfloor\frac{n}{i}\rfloor-ni\cdot\lfloor\frac{m}{i}\rfloor+i^2\cdot\lfloor\frac{n}{i}\rfloor\cdot\lfloor\frac{m}{i}\rfloor)$，发现用整除分块完成它需要使区间$[l,r]$中所有的$i$都满足$\lfloor\frac{n}{i}\rfloor$与$\lfloor\frac{m}{i}\rfloor$相同。

可以用类似的方法，将上面代码中的```r=n/(n/l);```改为```r=min(n/(n/l),m/(m/l));```，然后就可以直接求值了！

且慢，虽然前三项$nm,mi\cdot\lfloor\frac{n}{i}\rfloor,ni\cdot\lfloor\frac{m}{i}\rfloor$都很容易求得，但是$i^2\cdot\lfloor\frac{n}{i}\rfloor\cdot\lfloor\frac{m}{i}\rfloor$不是很容易求，因为$(1^2+2^2+\cdots+i^2)$不好处理。

这里有一个简单的结论：$1^2+2^2+\cdots+n^2=\frac{n(n+1)(2n+1)}{6}$，会在文后证明，现在先给出这一部分的代码：

```
inline long long sum2(long long x){
	return x*(x+1)%mod*(2*x+1)%mod*inv6%mod;
}

l=1,tmp3=0;
while(l<=n){
	long long a,b,c;
	r=min(n/(n/l),m/(m/l));
	a=(r-l+1)*n%mod*m%mod;
	b=(sum1(r)-sum1(l-1)+mod)%mod*((n/l)*m%mod+(m/l)*n%mod)%mod;
	c=(sum2(r)-sum2(l-1)+mod)%mod*(n/l)%mod*(m/l)%mod;
	tmp3=(tmp3+a-b+c+mod)%mod;
	l=r+1;
}
```

## 代码
- 记得开long long
- 取模很恶心，如果错了多半是这种原因
- 因为三个整数相乘会爆long long，因此除法用逆元实现（逆元提前求得）

```
#include<stdio.h>
const long long mod=1000000007,inv2=500000004,inv6=166666668;
long long i,j,k,m,n,l,r,ans,tmp1,tmp2,tmp3;
inline long long min(long long a,long long b){
	return a<b? a:b; 
}
inline void swp(long long &a,long long &b){
	a+=b,b=a-b,a-=b;
}
inline long long sum1(long long x){
	return x*(x+1)%mod*inv2%mod;
}
inline long long sum2(long long x){
	return x*(x+1)%mod*(2*x+1)%mod*inv6%mod;
}
int main(){
	scanf("%lld%lld",&n,&m);
	if(n>m)
		swp(n,m);
	l=1,tmp1=n*n%mod;
	while(l<=n){
		r=n/(n/l);
		tmp1=(tmp1-(sum1(r)-sum1(l-1)+mod)%mod*(n/l)%mod+mod)%mod;
		l=r+1;
	}
	l=1,tmp2=m*m%mod;
	while(l<=m){
		r=m/(m/l);
		tmp2=(tmp2-(sum1(r)-sum1(l-1)+mod)%mod*(m/l)%mod+mod)%mod;
		l=r+1;
	}
	l=1,tmp3=0;
	while(l<=n){
		long long a,b,c;
		r=min(n/(n/l),m/(m/l));
		a=(r-l+1)*n%mod*m%mod;
		b=(sum1(r)-sum1(l-1)+mod)%mod*((n/l)*m%mod+(m/l)*n%mod)%mod;
		c=(sum2(r)-sum2(l-1)+mod)%mod*(n/l)%mod*(m/l)%mod;
		tmp3=(tmp3+a-b+c+mod)%mod;
		l=r+1;
	}
	ans=(tmp1*tmp2%mod-tmp3+mod)%mod;
	printf("%lld\n",ans);
	return 0;
} 
```

## 简单的证明
证明：

$$1^2+2^2+\cdots+n^2=\frac{n(n+1)(2n+1)}{6}$$

（这个式子可以用简单构造法与数学归纳法证明，由于大部分题解都是用的数学归纳法，且用数学归纳法读者自证不难，因此这里使用简单构造法）

由于有这样一个式子：$i^2=i^2-i+i(i-1)\cdot i+i$，因此我们可以将这个拆开：

$$1^2+2^2+\cdots+n^2=\sum_{i=1}^ni^2=\sum_{i=1}^n(i-1)\cdot i+\sum_{i=1}^ni$$

然后乘上$\frac{1}{3}$：

$$\sum_{i=1}^ni^2=\frac{1}{3}\sum_{i=1}^n(i-1)\cdot i\cdot3+\sum_{i=1}^ni$$

构造一下：

$$\sum_{i=1}^ni^2=\frac{1}{3}\sum_{i=1}^n(i-1)\cdot i\cdot((i+1)-(i-2))=\frac{1}{3}\sum_{i=1}^n(-(i-2)\cdot(i-1)\cdot i+(i-1)\cdot i\cdot(i+1))+\sum_{i=1}^ni$$

把它们全部展开：

$$\sum_{i=1}^ni^2=\frac{1}{3}(-(-1)\cdot0\cdot1+0\cdot1\cdot2-0\cdot1\cdot2+1\cdot2\cdot3-1\cdot2\cdot3+\cdots(n-1)\cdot n\cdot(n+1))+\frac{n\cdot(n+1)}{2}$$

发现括号里的很多项都可以抵消：

$$\sum_{i=1}^ni^2=\frac{(n-1)\cdot n\cdot(n+1)}{3}+\frac{n\cdot(n+1)}{2}=\frac{n\cdot(n+1)\cdot(2(n-1)+3)}{6}=\frac{n\cdot(n+1)\cdot(2n+1)}{6}$$

证毕。

---

## 作者：starseven (赞：1)

$$
ans=\sum_{i=1}^n\sum_{j=1}^m(n\;mod\;i)\times(m\;mod\;j),i\neq j
$$

我们假设
$$
n\leq m
$$

$$
\begin{aligned}

ans

   & =\sum_{i=1}^n\sum_{j=1}^m(n\;mod\;i)\times(m\;mod\;j),i\neq j
   
\\ & =\sum_{i=1}^{n}\sum_{j=1}^m(n\;mod\;i)\times(m\;mod\;j)-\sum_{i=1}^n(n\;mod\;i)\times(m\;mod\;i)    

\\ & =\sum_{i=1}^{n}\sum_{j=1}^m(n-\left\lfloor\dfrac{n}{i}\right\rfloor\cdot i)\times(m-\left\lfloor\dfrac{m}{j}\right\rfloor\cdot j)-\sum_{i=1}^n(n-\left\lfloor\dfrac{n}{i}\right\rfloor\cdot i)\times(m-\left\lfloor\dfrac{m}{i}\right\rfloor\cdot i)    

\\ & =\sum_{i=1}^{n}(n-\left\lfloor\dfrac{n}{i}\right\rfloor\cdot i)\sum_{j=1}^m(m-\left\lfloor\dfrac{m}{j}\right\rfloor\cdot j)-\sum_{i=1}^n(n-\left\lfloor\dfrac{n}{i}\right\rfloor\cdot i)\times(m-\left\lfloor\dfrac{m}{i}\right\rfloor\cdot i)    

\\ & =\sum_{i=1}^{n}(n-\left\lfloor\dfrac{n}{i}\right\rfloor\cdot i)\sum_{j=1}^m(m-\left\lfloor\dfrac{m}{j}\right\rfloor\cdot j)-\sum_{i=1}^n(n\cdot m - i\cdot(\left\lfloor\dfrac{n}{i}\right\rfloor\cdot m+\left\lfloor\dfrac{m}{i}\right\rfloor\cdot n)+\left\lfloor\dfrac{n}{i}\right\rfloor\left\lfloor\dfrac{m}{i}\right\rfloor i^2)   

\end{aligned}
$$

然后

前面的等式先用数论分块算出j循环的值，然后第二次数论分块分i的值，从而将前面的等式算出来。

后面的等式直接数论分块

```cpp
r = min(n / (n / l), m / (m / l));
```

换个样子就可以分了。

然后要用平方和公式，所以得先把2,6的逆元算出来
$$
\sum_{i=1}^ni^2=\frac{i\cdot(i+1)\cdot(2\cdot i +1)}{6}
$$
剩下的就没什么了

```cpp
#include<cstdio>
#define Starseven main
#define ll long long
const ll mod = 19940417;

ll Add(ll l, ll r) {
	ll re = 0, ny2 = 9970209;
	re = (1 + r) * r % mod * ny2 % mod;
	re %= mod;
	l--;
	re = (re - (l + 1) * l % mod * ny2 % mod) % mod;
	re = (re + mod) % mod;
	return re;
}

ll All(ll l, ll r) {
	ll ny6 = 3323403;
	ll re = 0;
	re = r * (r + 1) % mod * ((2 * r + 1) % mod) % mod * ny6 % mod;
	l--;
	re = (re - (l * (l + 1) % mod *((2 * l + 1) % mod) % mod * ny6 % mod)) % mod;
	re = (re + mod) % mod;
	return re; 
}

int Starseven(void) {
	ll n, m;
	read(n);
	read(m);
	if(n > m) swap(n, m);
	ll ans = 0, judge = 0;
	for (ll l = 1, r; l <= m; l = r + 1) {
		r = m / (m / l);
		ll hack = (r - l + 1) * m % mod;
		hack = (hack - (m / l) * Add(l, r) % mod) % mod;
		hack = (hack + mod) % mod;
		judge = (judge + hack) % mod;
	} 
	for (ll l = 1, r; l <= n; l = r + 1) {
		r = n / (n / l);
		ll hack = (r - l + 1) * n % mod;
		hack = (hack - (n / l) * Add(l, r) % mod) % mod;
		hack = (hack + mod) % mod;
		hack = hack * judge % mod;
		ans = (ans + hack) % mod;
	}
	for (ll l = 1, r; l <= n; l = r + 1) {
		r = min(n / (n / l), m / (m / l));
		ll hack = n * m % mod * (r - l + 1) % mod;
		hack += (n / l) * (m / l) % mod * All(l, r) % mod;
		hack %= mod;
		ll a = m * (n / l) % mod, b = n * (m / l) % mod;
		hack = (hack - Add(l, r) * (a + b) % mod) % mod;
		hack = (hack + mod) % mod;
		ans = (ans - hack) % mod;
		ans = (ans + mod) % mod;
	}
	write(ans);
	puts("");
	return 0;	
}
```



---

## 作者：Stinger (赞：0)

~~其实是P2260的双倍经验~~

套路推式子题~~好像还挺无脑的啊~~。

规定 $n<m$。原式珂以等于这一坨。

$$
(\sum\limits^n_{i=1}(n\operatorname{mod} i) )(\sum\limits^m_{j=1}(m\operatorname{mod} j))-\sum\limits^n_{i=1}((n\operatorname{mod} i)\times (m\operatorname{mod} i))
$$

那么可以把减号左右两边的和式分别处理。先处理好搞的左边。按照[这题](https://www.luogu.com.cn/problem/P2261)的方法强行把模转化为除法然后用整除分块求解。那么 $\sum\limits^n_{i=1}n\operatorname{mod} i$ 实际上等于 $\sum\limits^n_{i=1}(n-\lfloor \frac{n}{i}\rfloor\times i)$。$\sum\limits^m_{j=1}m\operatorname{mod} j$ 一个道理。

现在处理右边的和式。

$$
\begin{aligned}
\sum\limits^n_{i=1}(n\operatorname{mod} i)\times (m\operatorname{mod} i)&=\sum\limits^n_{i=1}(n-\lfloor\frac{n}{i}\rfloor\times i)(m-\lfloor\frac{m}{i}\rfloor\times i)\\
&=\sum\limits^n_{i=1}nm-ni\lfloor\frac{m}{i}\rfloor-mi\lfloor\frac{n}{i}\rfloor+\lfloor\frac{n}{i}\rfloor\lfloor\frac{m}{i}\rfloor i^2\\
&=n^2m-n\sum\limits^n_{i=1}i\lfloor\frac{m}{i}\rfloor-m\sum\limits^{n}_{i=1}i\lfloor\frac{n}{i}\rfloor+\sum\limits^n_{i=1}\lfloor\frac{n}{i}\rfloor\lfloor\frac{m}{i}\rfloor i^2
\end{aligned}
$$

~~把一个和式硬拆成三个和式有意思吗？~~

最后展开的式子，前两个和式朴素地整除分块即可，最后那个和式……我们好像确定了一个 $[l,r]$ 区间商都为 $k$ 后需要计算 $\sum\limits^r_{i=l}i^2$。

根据小学奥数知识，$\sum\limits^n_{i=1}i^2=\frac{n(n+1)(2n+1)}{6}$。所以前缀和一下 $\sum\limits^r_{i=l}i^2=\sum\limits^r_{i=1}i^2-\sum\limits^{l-1}_{i=1}i^2$，套公式即可。

```cpp
#include <cstdio>
#define int long long

const int mod = 1e9 + 7;
inline int min(const int x, const int y) {return x < y ? x : y;}

int qpow(int a, int b) {
	int ret = 1LL;
	while (b) {
		if (b & 1) ret = ret * a % mod;
		a = a * a % mod;
		b >>= 1; 
	}
	return ret;
}

int calc(int n) {
	int ans = 0;
	ans = n * n;
	for (int l = 1, r; l <= n; l = r + 1) {
		r = n / (n / l);
		ans -= (n / l) * (r - l + 1) * (l + r) / 2;
	}
	ans = (ans % mod + mod) % mod;
	return ans;
}
int calc2(int n, int k) {
	int sum = 0;
	if (k > n) k = n;
	for (int l = 1, r; l <= k; l = r + 1) {
		r = min(n / (n / l), k);
		sum = (sum + (n / l) * (r - l + 1) * (l + r) / 2 % mod) % mod;
	}
	return sum;
}
int calc4(int n) {
	if (!n) return 0;
	int a[] = {n, n + 1, 2 * n + 1};
	for (int i = 0; i <= 2; ++ i)
		if (a[i] % 2 == 0) {a[i] /= 2; break;}
	for (int i = 0; i <= 2; ++ i)
		if (a[i] % 3 == 0) {a[i] /= 3; break;}
	return a[0] * a[1] % mod * a[2] % mod;
}
int calc3(int n, int m) {
	int sum = 0;
	for (int l = 1, r; l <= n; l = r + 1) {
		r = min(n / (n / l), m / (m / l));
		int k = (calc4(r) - calc4(l - 1) + mod) % mod;
		sum = (sum + (n / l) * (m / l) * k % mod) % mod;
	}
	return sum % mod;
}

signed main() {
	int n, m, ans;
	scanf("%lld%lld", &n, &m);
	if (n > m) n ^= m ^= n ^= m;
	ans = calc(n) * calc(m) % mod;
	ans = (ans - n * n % mod * m % mod) % mod;
	ans = (ans - calc3(n, m)) % mod;
	ans = (ans + n * calc2(m, n) % mod + m * calc2(n, m) % mod) % mod;
	printf("%lld", (ans + mod) % mod);
	return 0;
}
```

---

## 作者：bifanwen (赞：0)

[CSDN同步](https://blog.csdn.net/bifanwen/article/details/106973001)

[博客园同步](https://www.cnblogs.com/bifanwen/p/13195919.html)

[洛谷题解同步](https://www.luogu.com.cn/blog/bfw/solution-p2260)

[原题链接](https://www.luogu.com.cn/problem/P2260)

简要题意：

给定 $n,m$，求：

$$\sum_{i=1}^n \sum_{j=1}^m (n \space \text{mod} \space i) \times (m \space \text{mod} \space j) , i \not = j$$

$n,m \leq 10^9$.

我们直接奔着 $100$ 分的数据去吧，不要看部分分，部分分就没意思。

这个式子的瓶颈在于 $n \space \text{mod} \space i$ 的展开问题。所以只需要用 $n \space \text{mod} \space i = n - \lfloor \frac{n}{i} \rfloor \times i$ ，然后灵活用多项式的拆开与合并，一波整除分块带走即可。

首先说好，这一次的推式子没有 **莫比乌斯反演**，也没有 **奇怪的筛法**，有的只是 **多项式的灵活展开 与 整除分块**。

于是我们开始推式子。

$$\sum_{i=1}^n \sum_{j=1}^m (n \space \text{mod} \space i) \times (m \space \text{mod} \space j) , i \not = j$$

$$ = \sum_{i=1}^n \sum_{j=1}^m (n - \lfloor \frac{n}{i} \rfloor \times i) \times (m - \lfloor \frac{m}{j} \rfloor \times j) , i \not = j$$

$$ = \sum_{i=1}^n (n - \lfloor \frac{n}{i} \rfloor \times i) \times  \sum_{j=1}^m (m - \lfloor \frac{m}{j} \rfloor \times j) , i \not = j$$

首先我们把 $i=j$ 的答案丢掉，先做所有的答案。

令 $f_n = \sum_{i=1}^n (n - \lfloor \frac{n}{i} \rfloor \times i)$，则 $\text{ans} = f_n \times f_m$，考虑如何快速求 $f$.

$$f_n = \sum_{i=1}^n (n - \lfloor \frac{n}{i} \rfloor \times i)$$

$$ = n^2 - \sum_{i=1}^n \Big( \lfloor \frac{n}{i} \rfloor \times i \Big)$$

然后你会发现这东西直接 **整除分块**，$\mathcal{O}(
\sqrt{n})$ 很稳。

最后多余的 $i=j$ 的答案应该会是：

$$\sum_{i=1}^{\min(n,m)} (n \space \text{mod} \space i) \times (m \space \text{mod} \space i)$$

$$ = \sum_{i=1}^{\min(n,m)} (n - \lfloor \frac{n}{i} \rfloor \times i) \times (m - \lfloor \frac{m}{i} \rfloor \times i)$$

$$ = \sum_{i=1}^{\min(n,m)} \Big( nm - ni \lfloor \frac{m}{i} \rfloor - mi \lfloor \frac{n}{i} \rfloor + i^2 \lfloor \frac{n}{i} \rfloor \lfloor \frac{m}{i} \rfloor \Big)$$

$$ = nm \cdot \min(n,m) - n \times \sum_{i=1}^{\min(n,m)} i \lfloor \frac{m}{i} \rfloor - m \times \sum_{i=1}^{\min(n,m)} i \lfloor \frac{n}{i} \rfloor + \sum_{i=1}^{\min(n,m)} i^2 \lfloor \frac{n}{i} \rfloor \lfloor \frac{m}{i} \rfloor$$

令 $g_{n,k} = \sum_{i=1}^k i \lfloor \frac{n}{i} \rfloor$

则：

$$ = nm \cdot \min(n,m) - n \times g_{m,\min(n,m)} - m \times g_{n,\min(n,m)} + \sum_{i=1}^{\min(n,m)} i^2 \lfloor \frac{n}{i} \rfloor \lfloor \frac{m}{i} \rfloor$$

显然，$g$ 可以整除分块，所以整个式子都可以整除分块。

对于最后的一块，我们令 $h_{n,m,k} = \sum_{i=1}^{k} i^2 \lfloor \frac{n}{i} \rfloor \lfloor \frac{m}{i} \rfloor$，但是注意到：


$\sum_{i=1}^{\min(n,m)} i^2 \lfloor \frac{n}{i} \rfloor \lfloor \frac{m}{i} \rfloor$ 的计算需要用到公式：

$$\sum_{i=1}^n i^2 = \frac{n (n+1) (2n+1)}{6}$$

但是模意义下的除法不好做。这里有三种解决方法：

- 求出模意义下 $6$ 的逆元，可惜模数不是质数，我们只能用 $\text{exgcd}$ 去做。
- 由于 $n(n+1)$ 不会溢出，可以考虑 $n(n+1)/2 * (2n+1)/3$，但是最终的结果会爆 $\text{long long}$，因此这种方法不行。
- 直接开 $\text{\_\_int128}$ 解决所有问题。

当然本人为了方便直接开了 $\text{\_\_int128}$，解决了所有的溢出计算问题。反正 $(10^9)^3 = 10^{27}$ 肯定不会超过 $2^{127}$，因为 $2^{127}$ 大概有 $40$ 位。
上述方法已经说明，$f$ 和 $g$ 均可以在 $\mathcal{O}(\sqrt{n} + \sqrt{m} + \sqrt{\min(n,m)})$ 的时间内解决。$n$ ，$m$ 与 $\min(n,m)$ 均同级，所以最终时间复杂度为 $\mathcal{O}(\sqrt{n})$.

时间复杂度：$\mathcal{O}(\sqrt n)$.

实际得分：$100pts$.

**这个故事告诉我们，清华集训的题并不难，在自己擅长的领域完全可以吊打集训队**。（当然离那一天还很遥远）

```cpp
#pragma GCC optimize(2)
#include<bits/stdc++.h>
using namespace std;

typedef __int128 ll;
const ll MOD=19940417;

inline ll read(){char ch=getchar(); int f=1; while(ch<'0' || ch>'9') {if(ch=='-') f=-f; ch=getchar();}
	ll x=0; while(ch>='0' && ch<='9') x=(x<<3)+(x<<1)+ch-'0',ch=getchar(); return x*f;}

inline void write(ll x) {
	if(x<0) {putchar('-');write(-x);return;}
	if(x<10) {putchar(char(x%10+'0'));return;}
	write(x/10);putchar(char(x%10+'0'));
} //int128 需要快读快输
inline ll sum(ll n) {return n*(n+1)/2%MOD;} //一维和
inline ll pf(ll n) {return n*(n+1)*(2*n+1)/6%MOD;} //平方和
inline ll min(ll n,ll m) {return n<m?n:m;} //手动最小值
inline ll f(ll n) {
	ll ans=0;
	for(ll l=1,r;l<=n;l=r+1) {
		r=n/(n/l);
		ans=(ans+(n/l)*(sum(r)-sum(l-1))%MOD)%MOD;
	} //printf("%lld\n",ans);
	return (n*n-ans)%MOD;
} //整除分块计算 f

inline ll g(ll n,ll k) {
	ll ans=0;
	for(ll l=1,r;l<=k;l=r+1) {
		r=n/(n/l); r=min(r,k); //保证块不超过 k
		ans=(ans+(n/l)*(sum(r)-sum(l-1))%MOD)%MOD;
	} return ans;
} //整除分块计算 g

inline ll h(ll n,ll m,ll k) {
	ll ans=0;
	for(ll l=1,r;l<=k;l=r+1) {
		r=min(n/(n/l),m/(m/l)); r=min(r,k); //保证块不超过 k
		ans=(ans+(n/l)*(m/l)%MOD*(pf(r)-pf(l-1))%MOD)%MOD;
	} return ans;
} //整除分块计算 h

int main() {
	ll n=read(),m=read(),x=min(n,m);
	ll tot1=f(n)*f(m)%MOD; //原本答案
	ll tot2=(n*m*min(n,m)-n*g(m,x)-m*g(n,x)+h(n,m,x)+MOD+MOD)%MOD; //多余答案
//	write(tot1),putchar(' '),write(tot2),putchar('\n');
	write((tot1-tot2+MOD)%MOD); //减法需要处理负数
	return 0;
}


```

---

## 作者：derta (赞：0)

易知原式为
$$\sum_{i=1}^{n}\sum_{j=1}^{m}(n-i\lfloor\frac{n}{i}\rfloor)(m-j\lfloor\frac{m}{j}\rfloor),i \neq j$$

令
$$F(n)=\sum_{i=1}^{n}(n-i\lfloor\frac{n}{i}\rfloor)$$

则原式为
$$F(n)F(m)-\sum_{i=1}^{n}(n-i\lfloor\frac{n}{i}\rfloor)(m-i\lfloor\frac{m}{i}\rfloor)$$

$F(n)$ 可以整除分块，先看后面
$$\sum_{i=1}^{n}(n-i\lfloor\frac{n}{i}\rfloor)(m-i\lfloor\frac{m}{i}\rfloor)$$

拆括号
$$\sum_{i=1}^{n}nm-ni\lfloor\frac{m}{i}\rfloor-mi\lfloor\frac{n}{i}\rfloor+i^2\lfloor\frac{n}{i}\rfloor\lfloor\frac{m}{i}\rfloor$$

直接整除分块，时间复杂度 $O(\sqrt n + \sqrt m)$

$\rm{Code}:$

```cpp
#include <iostream>
#include <algorithm>
const int MOD = 19940417;
int inv6 = 3323403;

int pm(int x)
{ return x < 0 ? x + MOD : x; }

int sum1(int a, int b) // a + (a + 1) + ... + b
{ return (1LL*(a + b)*(b - a + 1) >> 1LL)%MOD; }

int sum2(int a) // 1^2 + 2^2 + 3^2 + ... + a^2
{ return 1LL*a*(a + 1LL)%MOD*((a << 1LL) + 1LL)%MOD*inv6%MOD; }

int sum2(int a, int b) // a^2 + (a + 1)^2 + (a + 2)^2 + ... + b^2
{ return pm(sum2(b) - sum2(a - 1)); }

// 整除分块求 F(n) 
int solve1(int n) {
	int res = 1LL*n*n%MOD;
	for(int i = 1, ni; i <= n; i = ni + 1) {
		ni = n/(n/i);
		res = pm(res - 1LL*(n/i)*sum1(i, ni)%MOD);
	}
	return res;
}

// 整除分块求剩下的一坨 
int solve2(int n, int m) {
	int res = 1LL*n*n%MOD*m%MOD;
	for(int i = 1, ni; i <= n; i = ni + 1) {
		ni = std::min(n/(n/i), m/(m/i));
		res = (res - 1LL*sum1(i, ni)*(m/i)%MOD*n%MOD - 1LL*sum1(i, ni)*(n/i)%MOD*m%MOD
				   + 1LL*(n/i)*(m/i)%MOD*sum2(i, ni)%MOD)%MOD;
	}
	return pm(res);
}

int main() {
	int n, m, ans;
	std::cin >> n >> m;
	if(n > m)
		std::swap(n, m); // 若不交换，在solve2的m/(m/i)会RE 
	ans = pm(1LL*solve1(n)*solve1(m)%MOD - solve2(n, m));
	std::cout << ans;
	return 0;
}
```

---

## 作者：LevenKoko (赞：0)

### 十年OI一场空，忘记取模见祖宗


------------


**题目：**

求
$$\sum_{i=1}^{n}\sum_{j=1}^{m} (n \bmod i)(m \bmod i)$$
(其中i,j不相等)

 暴力拆式子：

$$ANS=\sum_{i=1}^{n}\sum_{j=1}^{m} (n- \left \lfloor \frac{n}{i} \right \rfloor*i)(m- \left \lfloor \frac{m}{i} \right \rfloor*i)-\sum_{i=1}^{min(n,m)} (n- \left \lfloor \frac{n}{i} \right \rfloor *i)(m- \left \lfloor \frac{m}{i} \right \rfloor *i)$$

令$f(n)=\sum_{i=1}^{n} (n- \left \lfloor \frac{n}{i} \right \rfloor *i)$

令$g(n)=\sum_{i=1}^{n}(n- \left \lfloor \frac{n}{i} \right \rfloor *i)(m- \left \lfloor \frac{m}{i} \right \rfloor *i)$

不妨设n<=m

则有

$$ANS=f(n)*f(m)-g(n)$$

其中
$$g(n)=\sum_{i=1}^{n} n*m-n*\sum_{i=1}^{n} \left \lfloor \frac{m}{i} \right \rfloor *i-m*\sum_{i=1}^{n} \left \lfloor \frac{n}{i} \right \rfloor *i+\sum_{i=1}^{n} \left \lfloor \frac{n}{i} \right \rfloor* \left \lfloor \frac{m}{i} \right \rfloor *i^2$$

且由初中知识有
$$\sum_{i=1}^{n} i^2=\frac{n*(n+1)*(2*n+1)}{6}$$

用exgcd预处理6在模19940417意义下的逆元

然后用数论分块把上面一堆东西算一下即可

 
```cpp
#include<bits/stdc++.h>
#define int long long
#define writeln(x)  write(x),puts("")
#define writep(x)   write(x),putchar(' ')
using namespace std;
inline int read(){
	int ans=0,f=1;char chr=getchar();
	while(!isdigit(chr)){if(chr=='-') f=-1;chr=getchar();}
	while(isdigit(chr)){ans=(ans<<3)+(ans<<1)+chr-48;chr=getchar();}
	return ans*f;
}void write(int x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}const int mod = 19940417;
int n,m,k;
inline void Add(int &x,int y){x+=y;x%=mod;}
void exgcd(int a,int b,int &x,int &y){
	if(b==0)return x=1,y=0,void();
	exgcd(b,a%b,x,y);
	int t=x;x=y,y=t-a/b*y;
}int inv(int x){
	int xx,y;
	exgcd(6,mod,xx,y);
	xx=(xx%mod+mod)%mod;
	return xx;
}const int inv6=inv(6);
int sum(int x){return (x)*(x+1)%mod*(2*x%mod+1)%mod*inv6%mod;}
int query1(int l,int r){return ((sum(r)-sum(l-1))%mod+mod)%mod;}
int query2(int l,int r){int ans=(r-l+1)*(l+r)/2;return ans%mod;}
int calc1(int n){
	int ans=0;
	for(int i=1,j,t;i<=n;i=j+1){
		j=n/(n/i);
		t=n/i*(i+j)*(j-i+1)/2;
		t%=mod;
		Add(ans,t);
	}ans=n*n%mod-ans;
	ans=(ans%mod+mod)%mod;
	return ans;
}int calc2(int k){
	int ans=0;
	for(int i=1,j,t;i<=n;i=j+1){
		j=min(n/(n/i),m/(m/i));
		int s1=n*(m/i)%mod*query2(i,j)%mod;
		int s2=m*(n/i)%mod*query2(i,j)%mod;
		int s3=(n/i)*(m/i)%mod*query1(i,j)%mod;
		Add(s1,s2);
		Add(ans,s1);
		ans-=s3;
		ans=((ans)%mod+mod)%mod;
	}return ans;
}
signed main(){
	n=read(),m=read();
	if(n>m)swap(n,m);
	int ans=calc1(n)*calc1(m)%mod;
	ans-=n*m%mod*n%mod;
	ans=(ans%mod+mod)%mod;
	ans+=calc2(n);
	ans=(ans%mod+mod)%mod;
	cout<<ans<<endl;
	return 0;
}


```
 

 

 

 

---

## 作者：Rainy_chen (赞：0)

### 题面
求
$$ \sum_{i=1}^n\sum_{j=1}^m(n~{\rm{mod}}~i)\times(m~{\rm mod}~j)\mod 19940417,i!=j $$
$ n,m\le10^9 $
### 题解
先化简式子  
$\sum_{i=1}^n\sum_{j=1}^m(n~{\rm{mod}}~i)\times(m~{\rm mod}~j)$

$=\sum_{i=1}^n(n~{\rm mod}~ i)\sum_{j=1}^m(m~{\rm mod}~j)$



实际上这里就是两个余数求和，所以可以直接套用套路。

$=\sum_{i=1}^n(n-i\times\left\lfloor\frac ni\right\rfloor)\sum_{j=1}^m(m-j\times\left\lfloor\frac mj\right\rfloor)$

左右分别拉出来数论分块求和即可。



但是这样做显然是有问题的，我们没有考虑题目中给出的$i\not=j$的限定条件。

所以考虑一下$i=j$的情况，减去这部分的值就行了。 



也就是$\sum_{i=1}^{\min(n,m)}(n~{\rm mod}~i)(m~{\rm mod}~i)$。

为了方便起见，假定$n\le m$成立。再按照余数求和的套路化简一下

$=\sum\limits_{i=1}^n(n-i\times\left\lfloor\frac ni\right\rfloor)(m-i\times\left\lfloor\frac mi\right\rfloor)$

$=\sum\limits_{i=1}^n(nm-ni\left\lfloor\frac mi\right\rfloor-mi\left\lfloor\frac ni\right\rfloor+i^2\left\lfloor\frac ni\right\rfloor\left\lfloor\frac mi\right\rfloor)$

$=n^2m-n\sum\limits_{i=1}^ni\left\lfloor\frac mi\right\rfloor-m\sum\limits_{i=1}^ni\left\lfloor\frac ni\right\rfloor+\sum\limits_{i=1}^ni^2\left\lfloor\frac ni\right\rfloor\left\lfloor\frac mi\right\rfloor$

然后可以发现后三个都可以数论分块，于是就可以比较快速的计算出这个式子的值了。

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<string>
using namespace std;
typedef long long ll;
#define p 19940417
#define inv2 9970209
#define inv3 6646806

ll sum1n(ll x){
    return x*(x+1)%p*inv2%p;
}

ll sum1n2(ll x){
    return x*(x+1)%p*(2*x+1)%p*inv3%p*inv2%p;
}

ll Sab(ll a,ll b){
    return (sum1n(b)-sum1n(a-1))%p;
}

ll S2ab(ll a,ll b){
    return ((sum1n2(b)-sum1n2(a-1))%p+p)%p;
}

ll f(ll n){
    ll ans = n*n%p,i=1;
    while(i<=n){
        ll nxt = n/(n/i);
        ans = ((ans-(n/i)*Sab(i,nxt))%p+p)%p;
        i = nxt+1;
    }
    return ans;
}

ll g(ll n,ll m){
    //n<m
    ll ans = n*n%p*m%p,i=1;
    while(i<=n){
        ll nxt = min(n/(n/i),m/(m/i));
        ans = (ans-n*((m/i)*Sab(i,nxt)%p)%p+p)%p;
        ans = (ans-m*((n/i)*Sab(i,nxt)%p)%p+p)%p;
        ans = (ans+(n/i)*(m/i)%p*S2ab(i,nxt)%p+p)%p;
        i = nxt+1;
    }
    return ans;
}

int main(){
    ll n,m;cin>>n>>m;
    if(m<n)swap(n,m);
    ll ans = f(n)*f(m);
    ans%=p;
    ans-=g(n,m);
    ans=(ans%p+p)%p;
    cout<<ans;
}
```


---

## 作者：GKxx (赞：0)

可以说是最近做的几道数学题里比较弱智的了

基本上就是[余数求和](https://www.luogu.org/problemnew/show/P2261)的加强版，没有设置什么障碍

$ans=\sum\limits_{i=1}^n\sum\limits_{j=1}^m(n\bmod i)(m\bmod j)-\sum\limits_{i=1}^{\min(n,m)}(n\bmod i)(m\bmod i)$

不妨记为$ans=a-b$，分别计算

$a=\sum\limits_{i=1}^n(n\bmod i)\sum\limits_{j=1}^m(m\bmod j)$

$=\sum\limits_{i=1}^n(n-i\lfloor\frac{n}{i}\rfloor)\sum\limits_{j=1}^m(m-j\lfloor\frac{m}{j}\rfloor)$

整除分块即可解决，就相当于把余数求和跑两遍

不妨设$k=\min(n,m)$那么

$b=\sum\limits_{i=1}^k(n-i\lfloor\frac{n}{i}\rfloor)(m-i\lfloor\frac{m}{i}\rfloor)$

$=\sum\limits_{i=1}^k(mn-mi\lfloor\frac{n}{i}\rfloor-ni\lfloor\frac{m}{i}\rfloor+i^2\lfloor\frac{n}{i}\rfloor\lfloor\frac{m}{i}\rfloor)$

$=kmn-\sum\limits_{i=1}^k(mi\lfloor\frac{n}{i}\rfloor+ni\lfloor\frac{m}{i}\rfloor-i^2\lfloor\frac{n}{i}\rfloor\lfloor\frac{m}{i}\rfloor)$

整除分块即可解决。

另外两个需要知道的公式：

$\sum\limits_{i=1}^ni=\frac{n(n+1)}{2}$

$\sum\limits_{i=1}^ni^2=\frac{n(n+1)(2n+1)}{6}$

前者使用的时候直接用$\text{long long}$就行了，但是后者需要求$6$的逆元，因为三个数相乘会爆$\text{long long}$。

```cpp
#include <cctype>
#include <cstdio>
#include <climits>
#include <algorithm>

template <typename T> inline void read(T& x) {
    int f = 0, c = getchar(); x = 0;
    while (!isdigit(c)) f |= c == '-', c = getchar();
    while (isdigit(c)) x = x * 10 + c - 48, c = getchar();
    if (f) x = -x;
}
template <typename T, typename... Args>
inline void read(T& x, Args&... args) {
    read(x); read(args...); 
}
template <typename T> void write(T x) {
    if (x < 0) x = -x, putchar('-');
    if (x > 9) write(x / 10);
    putchar(x % 10 + 48);
}
template <typename T> inline void writeln(T x) { write(x); puts(""); }
template <typename T> inline bool chkmin(T& x, const T& y) { return y < x ? (x = y, true) : false; }
template <typename T> inline bool chkmax(T& x, const T& y) { return x < y ? (x = y, true) : false; }

typedef long long LL;

const LL mod = 19940417;

int n, m;
int inv6 = 3323403;

inline int s1(int l, int r) {
    return 1ll * (l + r) * (r - l + 1) / 2 % mod;
}
inline int s2(int l, int r) {
    auto f = [](int x) -> int { return 1ll * x * (x + 1) % mod * (2 * x + 1) % mod * inv6 % mod; };
    return ((f(r) - f(l - 1)) % mod + mod) % mod;
}

inline int calc(int n) {
    int ans = 1ll * n * n % mod;
    for (int l = 1, r; l <= n; l = r + 1) {
        r = n / (n / l);
        ans = (ans - 1ll * s1(l, r) * (n / l) % mod + mod) % mod;
    }
    return ans;
}

int main() {
    read(n, m);
    int ans = 1ll * calc(n) * calc(m) % mod;
    int mn = std::min(n, m);
    ans = (ans - 1ll * mn * n % mod * m % mod + mod) % mod;
    for (int l = 1, r; l <= mn; l = r + 1) {
        r = std::min(n / (n / l), m / (m / l));
        ans = (ans + 1ll * s1(l, r) * (1ll * n * (m / l) % mod + 1ll * m * (n / l) % mod) % mod) % mod;
        ans = (ans - 1ll * s2(l, r) * (n / l) % mod * (m / l) % mod + mod) % mod;
    }
    writeln((ans % mod + mod) % mod);
    return 0;
}
```


---


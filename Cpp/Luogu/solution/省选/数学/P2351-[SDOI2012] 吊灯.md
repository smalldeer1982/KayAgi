# [SDOI2012] 吊灯

## 题目背景

山东省省队选拔赛第二试（第一天）


## 题目描述

Alice 家里有一盏很大的吊灯。所谓吊灯，就是由很多个灯泡组成。只有一个灯泡是挂在天花板上的，剩下的灯泡都是挂在其他的灯泡上的。也就是说，整个吊灯实际上类似于**一棵树**。其中编号为 $1$ 的灯泡是挂在天花板上的，剩下的灯泡都是挂在编号小于自己的灯泡上的。

现在，Alice 想要办一场派对，她想改造一下这盏吊灯，将灯泡换成不同的颜色。她希望相同颜色的灯泡都是相连的，并且每一种颜色的灯泡个数都是相同的。

Alice 希望你能告诉她，总共有哪些方案。

Alice 是一个贪心的孩子，如果她发现方案不够多，或者太多了，就会很不高兴，于是她会尝试调整。对于编号为 $x$（$x\neq 1$）的灯泡，如果原来是挂在编号为 $f_x$ 的灯泡上，那么 Alice 会把第 $x$ 个灯泡挂到第 $(f_x + 19940105)\bmod (x-1) + 1$ 个灯泡上。

由于九在古汉语中表示极大的数，于是，Alice 决定只调整 $9$ 次。对于原始状态和每一次调整过的状态，Alice 希望你依次告诉她每种状态下有哪些方案。


## 说明/提示

对于 $20\%$ 的数据，$n\leq 3\times 10^3$。

对于 $40\%$ 的数据，$n\leq 5\times 10^4$。

对于 $50\%$ 的数据，$n\leq 10^5$。

对于 $60\%$ 的数据，$n\leq 3\times 10^5$。

对于 $70\%$ 的数据，$n\leq 7\times 10^5$。

对于 $100\%$ 的数据，$1\leq n\leq 1.2\times 10^6$。


## 样例 #1

### 输入

```
6
1,2,3,4,5```

### 输出

```
Case #1:
1
2
3
6
Case #2:
1
2
6
Case #3:
1
3
6
Case #4:
1
3
6
Case #5:
1
3
6
Case #6:
1
2
6
Case #7:
1
2
3
6
Case #8:
1
6
Case #9:
1
2
6
Case #10:
1
3
6```

# 题解

## 作者：wzj423 (赞：9)

解释了一下如何证明结论:
```cpp
#include <bits/stdc++.h>

using namespace std;
//thoughts==================
/*
考虑一颗被完全合法染色的树
根据反证法可以得出:一定有一个同色联通块,它的每一个节点都不是其他异色节点的父节点,其大小为floor(sz[tot]/K)
我们把这种不同颜色染色块之间的"父子"关系抽象成一条有向边
那么以颜色为节点,这一定是一个有向无环图
所以类似拓扑排序那样删边之后,上述结论一定成立
那么之前题解提到的,
满足条件时颜色的节点数为k，当且仅当有 n/k 个节点满足它的子树是k的倍数(显然还有 k|n )的结论就很显然了.
*/
//tool======================
inline int rd() {
	int x=0,f=1; char ch=getchar();
    for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-1;
    for(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';
    return x*f;
}
//main======================
const int MAXN=2e6;
typedef int arr[MAXN];
arr fa,num,sz;
int N,T;
int main() {
	N=rd();
	for(T=1;T<=10;++T) {
		for(int i=2;i<=N;++i)
			if(T==1) fa[i]=rd();
			else fa[i]=(fa[i]+19940105)%(i-1)+1;
		//for(int i=2;i<=N;++i) printf("fa[%d]=%d\n",i,fa[i]);
        for(int i=1;i<=N;++i) sz[i]=1,num[i]=0;
        for(int i=N;i>1;--i) sz[fa[i]]+=sz[i];
        for(int i=1;i<=N;++i) ++num[sz[i]];
        printf("Case #%d:\n1\n",T);
		for(int i=2;i<=N;++i) if(N%i==0) {
			int t=0;
			for(int j=1;i*j<=N;++j) {
                t+=num[i*j];
			}
			if(t*i>=N) printf("%d\n",i);
		}
	}
	return 0;
}

```

---

## 作者：Hehe_0 (赞：3)

大致题意：我们需要在一个树上改变9次树的形态（有固定规则，题面已给出，可详见代码），每次我们需要使相同颜色相连（分组），每个联通块大小相等。求每种形态树满足要求的组大小。  

显然，我们的这个数一定是总结点的约数。  
我们可以考虑去找每个块的大小，比如为 $ x $   
注意：一定存在 $ \left ( \dfrac { n }{x} \right ) $    其子树大小为 x 的倍数。


我们可以很暴力的枚举 1~n ，看：1 . 它是不是约数 2 .放 到树上是否可行  

每次枚举后树的形态都会改变，记得重新处理 siz ， num  


```cpp
#include<bits/stdc++.h>

using namespace std;
const int N=12e5+7;

int fa[N],siz[N],num[N];
int n;
inline int read()
{
	int out = 0,flag = 1; char c = getchar();
	while (c < 48 || c > 57){if (c == '-') flag = -1; c = getchar();}
	while (c >= 48 && c <= 57){out = (out << 3) + (out << 1) + c - 48; c = getchar();}
	return out * flag;
}
void init()
{
	fill(num,num+1+n,0);
	fill(siz,siz+1+n,1);
	for(int i=n;i;i--)
	{
		siz[fa[i]]+=siz[i];
		num[siz[i]]++;
	}
	return ;
}
bool pd(int x)
{
	int re=0;
	for(int i=x;i<=n;i+=x)
	{//x的倍数大小的数量 
		re+=num[i];
	}
	return re==n/x;
}

int main()
{
	ios::sync_with_stdio(false);
	n=read();
	
	for(int i=2;i<=n;i++)
	fa[i]=read();
	
	for(int cas=1;cas<=10;cas++)
	{
		cout<<"Case #"<<cas<<':'<<endl; 
		init();
		
		for(int i=1;i<=n;i++)
		{
			if((!(n%i))&&pd(i))
			cout<<i<<endl;
		}
	
		for(int i=2;i<=n;i++)
		fa[i]=(fa[i]+19940105)%(i-1)+1;
	}
		
	return 0;
}
```


---

## 作者：Cx114514 (赞：2)

### 题目链接：[[SDOI2012] 吊灯](https://www.luogu.com.cn/problem/P2351)
神秘结论题。

首先，以 $1$ 为根，考虑 $ans=k$ 的情况：DFS 遍历整棵树，用类似于拓扑排序的方式，如果一个树的子树中未删部分大小为 $k$，则这一部分可以染成相同的颜色，再把这一部分删去。

这样一共会删去 $\frac{n}{k}$ 次，且每一次删去的子树 $u$ 均满足 $k\mid sz_u$。

仔细想想，会发现一个神奇的事情，一个图中满足子树大小 $k\mid sz_u$ 的结点 $u$ 不会超过 $\frac{n}{k}$ 个：在原有基础上，想再多一个结点 $u$ 满足 $k\mid sz_u$，则必须要再多 $k$ 个结点，而整棵树只有 $n$ 个结点。

这个时候，就不难推出，一个树能划分成 $k$ 个颜色相同的连续块的充要条件是恰好有 $\frac{n}{k}$ 个结点 $u$ 满足 $k\mid sz_u$。

这题对于时间要求较紧，这里要注意代码实现的细节：

题目保证父节点编号小于子节点，则不需要真的把图建出来跑 DFS，只需要线性递推即可求出 $sz$ 的值。

在统计 $g_i=\sum\limits_{k}cnt_{ik}$ 时，需要使用狄利克雷后缀和优化。

时间复杂度 $O\left(Pn\log\log n\right)$，其中 $P$ 是大小为 $10$ 的常数。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

int read()
{
	int f = 1;
	char c = getchar();
	while (!isdigit(c))
	{
	    if (c == '-') f = -1;
	    c = getchar();
    }
	int x = 0;
	while (isdigit(c))
	{
		x = x * 10 + c - '0';
		c = getchar();
	}
	return x * f;
}

int buf[15];

void write(int x)
{
	int p = 0;
	if (x < 0)
	{
	    putchar('-');
	    x = -x;
	}
	if (x == 0) putchar('0');
	else
	{
		while (x)
		{
			buf[++p] = x % 10;
			x /= 10;
		}
		for (int i = p; i >= 1; i--)
			putchar('0' + buf[i]);
	}
}

const int mod = 19940105;

int n, tot, vis[1200005], p[1200005], f[1200005], sz[1200005], cnt[1200005];

int main()
{
	n = read();
	if (n == 1)
	{
		for (int i = 1; i <= 10; i++)
		{
			printf("Case #%d:\n", i);
			write(1);
			putchar('\n');
		}
		exit(0);	
	}
	scanf("%d", &f[2]);
	for (int i = 3; i <= n; i++)
		scanf(",%d", &f[i]);
	for (int i = 2; i <= n; i++)
	{
		if (!vis[i]) p[++tot] = i;
		for (int j = 1; j <= tot && i * p[j] <= n; j++)
		{
			vis[i * p[j]] = 1;
			if (i % p[j] == 0) break;
		}
	}
	for (int ppp = 1; ppp <= 10; ppp++)
	{
		for (int i = 1; i <= n; i++)
			cnt[i] = 0;
		for (int i = 1; i <= n; i++)
			sz[i] = 1;
		for (int i = n; i >= 1; i--)
			sz[f[i]] += sz[i];
		for (int i = 1; i <= n; i++)
			cnt[sz[i]]++;
		for (int i = 1; i <= tot; i++)
			for (int j = n / p[i]; j >= 1; j--)
				cnt[j] += cnt[j * p[i]];
		printf("Case #%d:\n", ppp);
		for (int i = 1; i <= n; i++)
		{
			if (n % i) continue;
			if (cnt[i] >= n / i) 
			{
				write(i);
				putchar('\n');
			}
		}
		for (int i = 2; i <= n; i++)
			f[i] = (f[i] + 19940105) % (i - 1) + 1;
	}
	return 0;
}
```

---

## 作者：BF_AlphaShoot (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P2351)。

首先有一个显然的结论：设所有区块大小为 $i$，则一定有 $i|n$ 且区块个数为 $\dfrac{n}{i}$。​

一定有一个同色区块保证没有任一节点为异色节点的父节点。

证明（感谢 [wzj423 提供思路](https://www.luogu.com.cn/blog/wzj423/solution-p2351)）：

不妨把每一个颜色抽象为一个点，每一种颜色的父子关系抽象为有向边，则形成一个 DAG。进行拓扑排序并删边，发现一定有，该命题成立。

有了这一结论，显然的，节点的子树个数之和一定为 $i$​​ 的倍数。

所以每次统计每个点的子树节点个数再加以判断分为几块，合法即可。

 $(f_x+19940105)\mod (x-1)+1<f_x$，可知子节点权值一定大于父节点，因此在枚举时从大到小枚举以优化。枚举判断不多赘述。 

View code：

```cpp
#include<bits/stdc++.h>
using namespace std;

#define ri register int
#define il inline

const int INF=0x3f3f3f3f,N=1.5e6,C=19940105;
int n;
int u[N],size[N],sum[N];

il ll read(){
    ll x=0,y=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
            y=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=x*10+c-'0';
        c=getchar();
    }
    return x*y;
}

signed main(){
    n=read();
    for(ri i=2;i<=n;i++)
        u[i]=read();
    for(ri i=1;i<=10;i++){
        printf("Case #%d:\n1\n",i);
        if(i!=1)
            for(ri i=2;i<=n;i++)
		    	u[i]=(u[i]+C)%(i-1)+1;
        for(ri i=1;i<=n;i++){
	    	size[i]=1;
	    	sum[i]=0;	
	    } 
	    for(ri i=n;i>1;i--)
	    	size[u[i]]+=size[i];
	    for(ri i=1;i<=n;i++)
	    	sum[size[i]]++;
        for(ri i=2;i<=n;i++){
			int mid=0;
			if(!(n%i)){
				for(ri j=1;i*j<=n;j++)
					mid+=sum[i*j];
				if(mid*i>=n)
                    printf("%d\n",i);
			}
		}
    }
    return 0;
}
```



---

## 作者：xxr___ (赞：0)

性质好题。

本题性质：
1. 答案 $k$ 一定是满足 $k \mid n,k\leq n$ 的，要不然你无法恰好覆盖完。
2. 如果有解，肯定存在子树大小 $sz_u = k$ 的节点 $u$。
    - 证明：假设我们当前到了点 $u$ 其儿子节点是 $\{v\}$。我们这里可以证明这个树一定有节点 $u$ 满足 $|\{v\}| \ge 2$ 的。
      - 不然的话只有一种情况，就是一条链的情况，这个时候得从链底顺着铺，铺到链头，这个时候显然是有 $sz_x = k$ 的，因为是一条链且 $k\leq n$ 的。
    - 那么此时一定能证明 $u$ 子树内部是无法满足条件且一定整颗树是无解的。
        - 因为这个时候设 $v' = \max_{v\in son_u} sz_v$ 的那个儿子节点，如果 $sz_{v'} > k$ 变成子问题求解，否则，如果要满足 $v'$ 的限制，肯定它选的颜色联通块是会覆盖到 $u$ 的，那么因为 $u$ 有不止一个儿子，且 $u$ 的其他儿子的颜色不能和 $v'$ 所在的联通块的颜色相同，但是 $u$ 的其他儿子要想符合条件也要自然覆盖到 $u$ 就和 $v'$ 的选择矛盾了，自然是不合法的。

那么我们就有一种简单判断有解无解的方法了，我们对树进行一次 DFS 然后定义 $f_x$ 表示 $x$ 子树尽量删，还剩多少个点，合法即为 $f_1 = 0$。

递归的过程中，如果某个点满足此时 $f_x = k$ 那么肯定能把这 $k$ 个点删了，因为我们 $f_i$ 是基于 $i$ 还没有删的前提下的，所以此时 $u$ 子树内没删的点只能是儿子，或者儿子的儿子....他们是联通的。

上述证明过有 $sz_u = k$ 所以有解一定可以判断出来的，也就是给 DFS 边界一样的东西。

并且，我们发现，如果有解，一定会删恰好 $\frac {n}{k}$ 次，因为每次只会删 $k$ 个点。一个子树能删，当且仅当 $k \mid sz_u$ 的，那么有解的条件自然就是能删 $\frac {n}{k}$ 次，即满足 $k \mid sz_u$ 的个数恰好是 $\frac {n}{k}$ 了。

时间复杂度是一个调和级数，是 $O(Tn\log n)$ 的，这里 $T = 10$。

至此，已经可以通过这个题，并且拿到 [最优解](https://www.luogu.com.cn/record/list?pid=P2351&orderBy=1&status=&page=1)。

代码（C++20）：
```cpp
#include<iostream>
#define getchar getchar_unlocked
const int N = 1200005;

int cnt[N],sz[N],fa[N],d[1005],tot = 0,n;

inline void rd(int & x){
	char c = getchar();
	x = 0;
	while(!(c >= '0' && c <= '9')) c = getchar();
	while(c >= '0' && c <= '9') x = (x << 3) + (x << 1) + (c ^ 48),c = getchar();
}
int main(){
	rd( n );
	for(int i = 2;i <= n; ++i){
		rd( fa[i] );
	}
	for(int i = 1;i <= n; ++i){
		if(n % i == 0){
			d[++tot] = i;
		}
	}
	for(int i = 1;i <= 10; ++i){
		for(int j = 1;j <= n; ++j){
			sz[j] = 1;cnt[j] = 0;
		}
		for(int j = n; j > 1 ;-- j){
			sz[fa[j]] += sz[j];
		}
		std::cout << "Case #" << i << ":\n";
		for(int i = 1;i <= n; ++i) ++cnt[sz[i]];
		for(int k = 1;k <= tot; ++k){
			int ans = 0;
			for(int p = d[k];p <= n;p += d[k]){
				ans += cnt[p];
			}
			if(ans == n / d[k]){
				std::cout << d[k] << '\n';
			}
		}
		for(int j = 2;j <= n; ++j){
			fa[j] = (fa[j] + 19940105) % (j - 1) + 1;
		}
	}
	return 0;
}
```

---

## 作者：Durancer (赞：0)

### P2351 [SDOI] 吊灯

#### 知识点

- 树，联通块，染色

- 结论

#### 思路

一个很明显的条件大家伙都知道：如果要有 $i$ 种颜色，那么必须要保证 $i|n$ 。

其次，继续可以通过画图来找找结论：

![此处输入图片的描述][1]

以当 $i=2$ 的时候为例，看左边的图，子树的大小为 $2$ 的倍数的一共有两个，所以 $2\times 2=4$ 可以划分为两种颜色。

再继续看右边的树，子树的大小为 $2$ 的倍数的只有一个，那么因为 $2\times 1<4$ 那么肯定不成立。

通过手摸多组小样例都是成立的，那么就可以根据这个来做题啦。

~~话说跟 DP 有啥关系~~

#### 代码实现

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<stack>
#include<map>
#include<algorithm>
#include<cmath>
#include<vector>
using namespace std;
const int N=1300010;
int n;
int fa[N];
int size[N];
int sum[N];
int read()
{
	int f=1,x=0;
	char s=getchar();
	while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();} 
	while(s>='0'&&s<='9'){x=(x<<1)+(x<<3)+(s^'0');s=getchar();}
	return f*x;
}
void clear()
{
	for(int i=1;i<=n;i++)
	{
		size[i]=1;
		sum[i]=0;//权值统计，统计一下子树大小为i的有多少	
	} 
	for(int i=n;i>1;i--)
		size[fa[i]]+=size[i];
	for(int i=1;i<=n;i++)
		sum[size[i]]++;//统计一下子树大小为i的有多少 
}
int main()
{
	n=read();
	for(int i=1;i<=10;i++)
	{
		if(i==1)
			for(int j=2;j<=n;j++)
				fa[j]=read();
		else 
			for(int j=2;j<=n;j++)
				fa[j]=(fa[j]+19940105)%(j-1)+1;
		clear(); 
		printf("Case #%d:\n",i);
		cout<<1<<endl;//1一定是行的 
		for(int j=2;j<=n;j++)
		{
			int cnt=0;
			if(n%j==0)//必须是整除，不然无法满足每种颜色个数相等
			{
				for(int k=1;j*k<=n;k++)//通过手摸几组样例可以发现
				//只有在大小为j的倍数的子树的个数乘上j超过n的时候，才可以满足
				//会有n/j种相同颜色的联通块出现，反之绝对不可能 
					cnt+=sum[j*k];
				if(cnt*j>=n) printf("%lld\n",j);
			}	
		} 
	}
	return 0;
}
```





  [1]: https://img.imgdb.cn/item/606c4c368322e6675cca186c.png

---

## 作者：keep_ (赞：0)

# 洛谷 p2351 [SDOI2012]吊灯

## 题目分析 

[题目链接](https://www.luogu.com.cn/problem/P2351)

看完这个题后，我们可以得出一个很显然的结论，要保证一颗节点数为$n$的树可以分成若干个大小

为 $i$ 的连通块，一定有$i|n$且定有$\lfloor \frac{n}{i}\rfloor$个

节点的子树节点数之和(包括其本身)是$i$的倍数,证明可以看楼上，这里

就不具体写了.

所以思路就很简单了，每次统计每个点的子树节点个数，然后判断分几块是

合理的就行了，本题题目透露出了一个优化方案，即子节点的编号大于根

节点，利用此性质从大到小枚举节点数，可以$O(n)$得出子树节点个数

在枚举i时可以利用整除分块对其优化

具体细节看代码吧

```c++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
using namespace std;
const int maxn=2e6+10;
inline int read(){
	int ret=0;
	int f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')
			f=-f;
		ch=getchar();
	}
	while(ch<='9'&&ch>='0'){
		ret=ret*10+(ch^'0');
		ch=getchar();
	}
	return f*ret;
}
int num[maxn];
int n;
int size[maxn];
int f[maxn];
int main(){
	freopen("a.in","r",stdin);
	n=read();
	int t=10;
	while(t--){
		for(int i=2;i<=n;i++){
			if(t==9){
				f[i]=read();
			}
			else{
				f[i]=(f[i]+19940105)%(i-1)+1;
			}	
		}
		memset(num,0,sizeof(num));
		for(int i=1;i<=n;i++){
			size[i]=1;
		}
		for(int i=n;i>1;i--){
		//	cout<<f[i]<<endl;
			size[f[i]]+=size[i];
		} 
		for(int i=1;i<=n;i++){
		//	cout<<size[i]<<endl;
			num[size[i]]++;	
		}
		cout<<"Case #"<<10-t<<':'<<endl;
		for(int l=1,r;l<=n;l=r+1){
			r=n/(n/l);//整除优化，能稍微快一点，把此处的n优化为根号n
			int t=0;
			for(int j=1;r*j<=n;++j) {
                t+=num[r*j];
			}
			if(t*r==n) cout<<r<<endl;
		}
	}
	return 0;
}
```

完结撒花!



---

## 作者：lizongru (赞：0)

- 看到这一篇没有题解于是来写一下。
- 首先这一题处理儿子个数时就有一个trick：直接dfs虽然复杂度也是$O(n)$，但是实际速度会比较慢，可能超时，这时候就要观察到由于灯泡挂在$(f[x]+19940105)mod(x-1)+1$灯泡下，所以$f[x]<x$,利用这个性质我们就可以从n到1倒过来for循环一遍，将自己的son个数加到父亲上，就是一遍for循环的复杂度了。
- 有一点是比较显然的，那就是$ans$一定在$n$的约数中，所以可以先把$n$的约数先预处理出来，存在一个数组或vector里面。
- 我们还需要观察到一个性质，就是答案ans合法的充要条件是至少有$\frac{n}{x}$个节点的子树大小为$x$的倍数。想到以后证明比较显然，有兴趣的同学可以尝试自己证明一下。
- 代码如下，还不会的同学可以自行参考：

```cpp
#include<bits/stdc++.h>
using namespace std;
inline void read(int &x){
    char c=getchar();
    int p=1;
    x=0;
    while(!isdigit(c)){
        if(c=='-')p=-1;
        c=getchar();
    }
    while(isdigit(c)){
        x=(x<<1)+(x<<3)+(c^'0');
        c=getchar();
    }
    x*=p;
}
const int maxn=2000005;
int tot,f[maxn],n,cnt[maxn],s[maxn];
vector<int>vec,ans;
int main(){
    //freopen(".in","r",stdin);
    //freopen(".out","w",stdout);
    read(n);
    for(register int i=2;i<=n;++i){
        read(f[i]);
    }
    for(register int i=1;i<=n;++i){
        if(n%i==0)vec.push_back(i);
    }
    int sum=vec.size()-1;
    for(register int cas=1;cas<=10;++cas){
        printf("Case #%d:\n",cas);
        ans.clear();
        for(register int i=1;i<=n;++i){
            s[i]=1;
        }
        for(register int i=n;i>1;--i){
            s[f[i]]+=s[i];
        }
        memset(cnt,0,sizeof(cnt));
        for(register int i=1;i<=n;++i){
            cnt[s[i]]++;
        }
        ans.push_back(1);
        for(register int i=1;i<=sum;++i){
            tot=0;
            for(register int j=vec[i];j<=n;j+=vec[i]){
                tot+=cnt[j];
            }
            if(tot>=n/vec[i])ans.push_back(vec[i]);
        }
        for(register int i=0;i<ans.size();++i){
            printf("%d\n",ans[i]);
        }
        for(register int i=2;i<=n;++i){
            f[i]=(f[i]+19940105)%(i-1)+1;
        }
    }
    return 0;
}
```

---

## 作者：依依 (赞：0)

解：期望：？   实际：10  骗分

正解：

题目大意：将一棵树分成x个连通块，且每个连通块的大小相同，看是否可行

假设将书分为x个连通块，那么必定存在至少n/x个节点的size[]

为x的倍数，（显然将一颗子树分到一起是最优的）

我们枚举每个节点的size[],看是否可行

由于递归层数的限制（亲测通过dfs获得size[]只有70分），并且孩子

编号一定比父亲大，我们可以从后向前枚举节点，来获取size[]值    
[hello](http://www.cnblogs.com/adelalove/p/8622638.html)

---


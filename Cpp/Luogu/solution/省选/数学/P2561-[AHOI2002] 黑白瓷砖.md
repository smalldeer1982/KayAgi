# [AHOI2002] 黑白瓷砖

## 题目描述

![](https://cdn.luogu.com.cn/upload/pic/1685.png) 

![](https://cdn.luogu.com.cn/upload/pic/1686.png)


## 样例 #1

### 输入

```
1```

### 输出

```
2```

## 样例 #2

### 输入

```
2```

### 输出

```
4```

# 题解

## 作者：gxy001 (赞：14)

看到染色旋转翻转，我们就可以猜到这道题需要使用 Pólya 定理（ ó : Alt + 243 ）。

## Pólya 定理

$$l=\frac 1 {\mid G\mid}\sum_{k=1}^{\mid G \mid}m^{c(p_k)}$$

$G=\{p_1,p_2,\cdots\}$ 为 $N$ 个对象的置换群，$c(p_k)$ 为置换 $p_k$ 的循环数，$l$ 为 $m$ 种颜色染 $N$ 个对象的方案数。

## 分析

显然，在此题中 $\mid G \mid=6$，分别为单位元，由旋转得到的两种，由翻转得到的三种，可以观察出既旋转又翻转得到的置换包括在上述六种中。又由黑白染色得出 $m=2$，瓷砖大小 $N=\frac{n\times(n+1)}{2}$。

代入公式，我们可以发现仅剩 $c(p_k)$ 没有求出，思考循环的含义：

$$\bigg(^{a_1\ a_2\ a_3\ \cdots\ a_n}_{a_n\ a_1\ a_2\ \cdots\ a_{n-1}}\bigg)=(1\ 2\ 3\ \cdots\ n)$$

+ 我们可以发现，单位元的循环数量显然为 $N$；

+ 而对于旋转产生的两种置换，一个点在旋转 $120\degree$ 后定然与另一点重合，在旋转三次后回到原位，共经过三个位置，那么每一个循环的大小就为 $3$，循环数量为 $\lceil\frac N 3\rceil$，注意向上取整，原因——在某些情况下（如 $n=4$），存在不动的中心点，其循环大小为 $1$；

+ 对于翻转来说，除了对称轴上的 $\lceil\frac n 2\rceil$ 个点，其余均为两两交换，循环大小为 $2$，循环数量为 $\frac {N-\lceil\frac n 2\rceil} 2+\lceil\frac n 2\rceil$。

## 结论

$$
ans=\frac 1 6(2^N+2\times 2^{\lceil\frac N 3\rceil}+3\times2^{(\frac {N-\lceil\frac n 2\rceil} 2+\lceil\frac n 2\rceil)})
$$

$$N=\frac{n\times(n+1)}{2}$$

## 代码

注意：此题需要高精度，但可以不用快速幂。

```cpp
#include<cstdio>//for IO
#include<cstring>//for memset
#include<utility>//for std::swap
int n,bs,xz,fz;//单位元，旋转，翻转 
struct bign{
	static const int base=10000;
	int a[60],l;
	bign():l(){//init
		memset(a,0,sizeof(a));
	}
	int& operator [](int x){
		return a[x];
	}
	const int& operator [](int const&x)const{
		return a[x];
	}
	friend bign operator + (bign x,bign y){
		bign ans;
		if(x.l<y.l)std::swap(x,y);
		ans[0]=0;
		for(ans.l=0;ans.l<x.l||ans[ans.l];++ans.l){
			ans[ans.l]+=x[ans.l]+y[ans.l];
			if(ans[ans.l]>base)ans[ans.l+1]=1,ans[ans.l]-=base;
			else ans[ans.l+1]=0;
		}
		return ans;
	}
	friend bign operator *(bign x,int y){
		bign ans;
		ans[0]=0;
		for(ans.l=0;ans.l<x.l||ans[ans.l];++ans.l){
			ans[ans.l]+=x[ans.l]*y;
			if(ans[ans.l]>base)ans[ans.l+1]=ans[ans.l]/base,ans[ans.l]%=base;
			else ans[ans.l+1]=0;
		}
		return ans;
	}
	friend bign operator /(bign x,int y){
		for(int i=x.l-1;~i;--i){
			if(i)x[i-1]+=(x[i]%y)*base;
			x[i]/=y;
		}
		while(x.l&&!x[x.l-1])x.l--;
		return x;
	}
	void output(void){
		printf("%d",a[l-1]);
		for(int i=l-2;~i;--i)
			printf("%04d",a[i]);
	}
}bsp,fzp,xzp,res;
int main(){
	scanf("%d",&n);
	bs=n*(n+1)/2;
	fz=(bs-(n+1)/2)/2+(n+1)/2;
	xz=(bs+2)/3;
//ans=(pow(2,bs)+pow(2,fz)*3+pow(2,xz)*2)/6
	bsp[0]=1,bsp.l=1;
	for(int i=1;i<=bs;i++)bsp=bsp*2;
	fzp[0]=1,fzp.l=1;
	for(int i=1;i<=fz;i++)fzp=fzp*2;
	fzp=fzp*3;
	xzp[0]=1,xzp.l=1;
	for(int i=1;i<=xz;i++)xzp=xzp*2;
	xzp=xzp*2;
	res=(bsp+fzp+xzp)/6;
	res.output();
	return 0;
}
```
最后，如有错误，请在评论指出。

---

## 作者：hanker_AFO (赞：10)

# $P2561 [AHOI2002]$黑白瓷砖

## Polya定理

> 对于一个$n$阶置换
$$
 (a_1,a_2,a_3,..,a_n)=
 \lgroup
 \begin{matrix}
     1 & 2 & 3 & .. & n\\
     a_1 & a_2 & a_3 & .. &a_n\\
 \end{matrix} 
 \rgroup
$$
> 我们可以找到其中若干循环节
>
> 循环节:
>
> 我们记$i->a_i$ 为一次变换,若$i$经过$k$次变换后等于$i$,且任何小于$k$次的变换均不为$i$
>
> 那么我们找到了一个大小为$k-1$的循环节
>
> 显然一个$n$阶置换最多有$n$个循环节,最少$1$个循环节,并且每个数只存在于一个循环节内
>
> 举个例子:
$$
 \lgroup
 \begin{matrix}
     1 & 2 & 3 & 4 & 5\\
     3 & 5 & 1 & 4 & 2\\
 \end{matrix} 
 \rgroup
 =(13)(25)(4)
$$
> 其中后面用多个括号组合成的表达式,其每对括号内的数形成一个循环节
>
> 计数公式:
$$
 L=\frac{1}{|G|}(m^{c(g_1)}+m^{c(g_2)}+m^{c(g_3)}+ \cdots+m^{c(g_s)})
$$
> 解释一下
>
> $L$:计数结果
>
> $G$:置换群
>
> $|G|$:置换群的置换数,即$s$,表示总共有$s$种置换方式
>
> $m$:对于$n$阶置换,表示置换操作前,$n$种元素每个元素的取值,或者理解为每个点的染色方式,共$m$种
>
> $g_i$:表示单个置换,为$G$中的元素
>
> $c()$:函数,返回每个置换中的循环节数
>
> 以上为$Polya$定理



注意置换群必须满足群的性质,封闭性,结合律,单位元,逆元. 

题目所给的置换种类可能不足以构成群,需要补充置换



下面针对题目:

> 显然我们有基础的三种置换,旋转两种,翻转一种
>
> 明显我们缺失了不动的置换,加入单位元
>
> 封闭性:即G的任意两个元素在 $*$下的运算结果都是该集合的一个元素
>
> 我们发现翻转再旋转的置换不在群内
>
> 所以我们补充两种翻转,形成六种置换:
>
> 1. 旋转:$120^{\circ }, 240^{\circ} $
> 2. 翻转,对于三条对称轴各有一种
> 3. 不动,即为单位元
>
> 然后来统计循环节数
>
> 1. 旋转,我们知道同一方式旋转三次一定会与原图重合,所以循环节应该是三个一组,然后手推一下$1 \sim 4$ 的情况,得到循环节数为$\lceil \frac{n}{3} \rceil$
> 2. 翻转,翻两次肯定重合,但是中轴线上的点一直不变.我们先得到中轴线上的点数$s= \lceil \frac{n}{2} \rceil$,循环节数为$\frac{n-s}{2}+s$
> 3. 不动,显然为$n$
>
> 接着由于是黑白染色,染色方式$m=2$
>
> 我们直接套公式即可

code:

```cpp
#include <bits/stdc++.h>
using namespace std;

int read(){
	int x=0; char c; int flag=1;
	for(c=getchar();!isdigit(c);c=getchar()) if(c=='-') flag=-1;
	for(;isdigit(c);c=getchar()) x=(x<<1)+(x<<3)+(c^48);
	return x*flag;
}

struct bignum{
    int g[505];
    int l;
    void init() { l=0; memset(g,0,sizeof(g)); }
    void one() { init(); l=1; g[1]=1; }
    void jw(){ while(g[l+1]>0) { ++l; g[l+1]=g[l]/10; g[l]%=10; }  }
    void out() { for(int i=l;i>=1;i--) printf("%d",g[i]); printf("\n"); }
};

bignum operator +(bignum a,bignum b){
    bignum c; c.init();
    c.l=max(a.l,b.l);
    for(int i=1;i<=c.l;i++){
	    c.g[i]+=a.g[i]+b.g[i];
	    c.g[i+1]+=c.g[i]/10;
	    c.g[i]%=10;
	}
	c.jw();
	return c;
}

bignum operator *(bignum a,bignum b){
    bignum c; 
	c.init(); c.l=a.l+b.l-1;
    for(int i=1;i<=a.l;i++)
    for(int j=1;j<=b.l;j++)
    c.g[i+j-1]+=a.g[i]*b.g[j];
    
    for(int i=1;i<=c.l;i++){
	    c.g[i+1]+=c.g[i]/10;
	    c.g[i]%=10;
	}
	c.jw();
	return c;
}

bignum operator /(bignum a,int b){
    for(int i=a.l;i>=1;i--){
	    a.g[i-1]+=(a.g[i]%b)*10;
	    a.g[i]/=b;
	}
	
	while(a.l>1&&a.g[a.l]==0) --a.l;
	return a;
}

bignum ksm(int y){
    bignum ret; ret.one();
    bignum x; x.one(); x.g[1]=2;
    
    while(y){
	    if(y&1) ret=ret*x;
	    y>>=1;
	    x=x*x;
	}
	return ret;
} 

signed main() {
    int n=read();
    
    int Still=n*(n+1)/2;//n行,格子数1+2+..+n,等差数列
	int Rotate=(Still+2)/3;//旋转的循环节数
	int Reverse=(Still-(n+1)/2)/2+(n+1)/2; //翻转的循环节数
	
	bignum ans; ans.init();
	 ans=ans+ksm(Still)+ksm(Rotate)+ksm(Rotate)+ksm(Reverse)+ksm(Reverse)+ksm(Reverse);
	//忘记写高精*低精了
    ans=ans/6;
	//以上为公式
	ans.out();
	return 0;
}

```

因为公式格式挂了,交了好几次题解,不知道会怎样,

管理大大不要生气,只要通过最后这次就好了qwq


---

## 作者：Buried_Dream (赞：3)

题目意思还是比较清晰的，然后我们观察一下。

- 对于“不动”，子环个数十分显然为 $n$。

- 对于“旋转”,为总格子个数除以 $3$ 后向上取整

- 对于“对称”,为格子总数加上中轴线上 $ (n / 2) / 2 $。

然后本体还要用到高精，数据范围挺小，我们可以用 `Python` 打出表来，当然也可以直接用 `Python` 切了。

下面是 `Python` 代码：

```cpp
n=int(input())
m=n*(n+1)//2
t=2**m
c=0
for i in range(1,n+1):
    c+=(i+1)//2
t+=2**c
if n%3==1:
    t+=2*((2**((m-1)//3+1))+(2**((m-4)//2+3)))
else:
    t+=2*((2**(m//3))+(2**c))
print(t//6)
```
## AC code:

```cpp
/*
work by: TLE_Automation
Time: O(TLE)
knowledge:
*/
#include<bits/stdc++.h>
#define TLE std
#define int long long
#define Min(x, y)  (x > y ? y : x);
#define Max(x, y)  (x > y ? x : y);
#define orz cout << "szt lps fjh AK IOI";
using namespace TLE;

const int maxn = 3e6;
const int MAXN = 3e3;
const double down = 0.996;
const double limit = 1e-10;

inline int read() {
	int s = 0, w = 1;
	char ch = getchar();
	while (!isdigit(ch)) {if(ch == '-') {w = -1;}ch = getchar();}
	while (isdigit(ch)) {s = (s << 1) + (s << 3) + (ch ^ 48);ch = getchar();}
	return s * w;
}

inline void print(int x) {
	if (x < 0 ) putchar('-'), x = -x;
	if (x > 9 ) print(x / 10);
	putchar(x % 10 + '0');
}

string a[22] = {"0", "2","4","20","208","5728","351616","44772352","11453771776","5864078802944","6004800040206336","12297829416834170880","50371909152808594571264","412646679762074900658913280","6760803201217259503457555972096","221537999297485988040673580072042496","14518714321960041110131833181979847688192","1902996923607946508078923551753025410956263424","498859225542281529413525041870510961437758449516544","261545905641111698493157893267478067457861758958922891264","274250759553534340359161530426874121271106557923036528403021824"};
signed main() {
	int n = read();
	cout << a[n];
}


```

---

## 作者：EkiXu (赞：3)

Pólya是解决染色问题的好方法，但是观察题中的所给的置换发现不符合构成置换群的条件（不构成就不能使用该定理）


1.单位元e，我们用置换“不动”

2.封闭性，多加两个斜着的置换


根据Pólya定理有


$ans=\Large\frac{1}{|G|}\sum\limits_{f\in G}k^{c(f)}$

其中 m(f) 为子环个数


观察一下我们发现


- 对于“不动”，显然子环个数为n

- 对于“旋转”,为总格子个数除以3向上取整

- 对于“对称”,为格子总数加上中轴线上（n / 2）（向上取整）个格子/2


所以有如下代码（未加高精度）


```cpp
#include<cstdio>
BigNum f[300];//数字大 使用高精度
int n;
inline void polya(){
    BigNum ans=0;
    int still=(n+1)*n/2;
    int roate=still/3+(still%3?1:0);//向上取整
    int filp=(still+(n+1)/2)/2;
    f[0]=1;
    for(int i=1;i<=still||i<=roate||i<=filp;i++)
        f[i]=f[i-1]*2;
    ans=(f[still]+f[roate]*2+f[filp]*3)/6;//2*roate 是因为有两种旋转 3*filp是因为有三条对称轴翻转 一共三种 
    ans.print();
}
int main(){
    scanf("%d",&n);
    polya();
    return 0;
}
```
详见[oi.ozem.pw](https://oi.ozem.pw/CodeVS/p2926.html)


关于Pólya定律可参见 刘汝佳、黄亮《算法艺术与信息学竞赛》和Richard A.Brualdi《组合数学》


---

## 作者：Pentiment (赞：1)

[Pólya 定理](https://www.luogu.com.cn/article/wawpsgc8)模板题。

本题颜色数为 $2$，元素个数为 $N=\dfrac12n(n+1)$，群 $G$ 中的元素有三类：单位元，顺时针旋转，以及绕三个轴翻转。容易验证它是封闭的，对应的就是三个顶点（图中的 $1,4,6$）的排列。

考虑计算每个元素的轮换数：

1. 单位元的轮换数为 $N$；
2. 顺时针旋转，每个元素转 $3$ 次后会回到原位，考虑到中间可能有不动点，轮换数为 $\left\lceil\dfrac N3\right\rceil$；
3. 绕轴翻转，除去对角线上有 $\left\lceil\dfrac n2\right\rceil$ 个不动点外，其余元素翻转 $2$ 次后会回到原位，轮换数为 $\left\lceil\dfrac n2\right\rceil+\dfrac{N-\left\lceil\dfrac n2\right\rceil}{2}$。

故答案为：
$$
\dfrac16\left(2^N+2\times2^{\lceil\frac N3\rceil}+3\times2^{\lceil\frac n2\rceil+\frac{N-\lceil\frac n2\rceil}{2}}\right)
$$

```python
n = int(input())
N = n * (n + 1) // 2
print((pow(2, N) + 2 * pow(2, (N + 2) // 3) + 3 * pow(2, (N - (n + 1) // 2) // 2 + (n + 1) // 2)) // 6)
```

---

## 作者：xiezheyuan (赞：0)

## 简要题意

有一个 $n$ 行的三角形矩阵，每个点可以染成黑色或者白色，求本质不同染色方案数。称两种方案本质相同，当且仅当存在两个整数 $a,b$，使得前者旋转 $a180\degree+b120\degree$ 后可以得到后者。

$1\leq n\leq 20$

## 思路

又是一道 Burnside 引理经典题目。

首先考虑群肯定是 $\frac{1}{2}n(n+1)$ 次置换群的一个子群。然后考虑子群中的元素。

可以写一个 Python 程序找出 $(a180+b120)\bmod 360$ 的所有可能值：

```python
mp = {}
def dfs(x):
  if x in mp.keys():
    return
  mp[x] = 1
  dfs((x + 180) % 360)
  dfs((x + 120) % 360)
dfs(0)
print(mp)
```

发现取值只有下面 $6$ 种：

1. $0$
1. $180$
1. $120$
1. $120+120=240$
1. $120+180=300$
1. $120\times 2+180=420,420\bmod 360=60$

然后就好办了，枚举这六种情况即可，然后就是计算 $|X^g|$ 也就是置换情况下本质不变的数目。发现置换环必须染成一个颜色，所以也就是 $2^c$，其中 $c$ 就是置换环数量。

最后有一个小细节，如何求出置换？发现只需要求出 $120\degree$ 旋转后的置换和 $180\degree$ 旋转后的置换即可。观察题目描述给的示例，发现 $120\degree$ 就是从左下角元素开始，按照右对角线从一条一条从上至下写下来，$180\degree$ 就是每一行翻转。都是可以简单模拟的。

于是本题就做完了。

## 代码

由于本题为远古题目，需要高精，所以这里写的是 Python。

```python
from copy import deepcopy

n = int(input())
n2 = n

def rotate120(lst : list[list[int]]) -> list[list[int]]:
    ans = []
    for i in range(n2 - 1, -1, -1):
        x, y = i, 0
        now = []
        while x < n2:
            now.append(lst[x][y])
            x += 1
            y += 1
        now.reverse()
        ans.append(now)
    return ans

def rotate180(lst : list[list[int]]) -> list[list[int]]:
    ans = []
    for i in range(n2):
        now = deepcopy(lst[i])
        now.reverse()
        ans.append(now)
    return ans

def get_perm_rings(perm : list[int]) -> int:
    fa = [i for i in range(n + 1)]
    find = lambda x : fa[x] if fa[x] == x else find(fa[x])
    for i in range(n):
        x, y = find(i + 1), find(perm[i])
        fa[x] = y
    ans = 0
    for i in range(n):
        if find(i + 1) == (i + 1):
            ans += 1
    return ans

def flatten(lst : list[list[int]]) -> list[int]:
    ans = []
    for i in lst:
        ans.extend(i)
    return ans

source = []
cnt = 0
for i in range(n):
    now = []
    for j in range(i + 1):
        cnt += 1
        now.append(cnt)
    source.append(now)
n = cnt
ans = 0
ans += 2 ** get_perm_rings(flatten(source))
ans += 2 ** get_perm_rings(flatten(rotate120(source)))
ans += 2 ** get_perm_rings(flatten(rotate180(source)))
ans += 2 ** get_perm_rings(flatten(rotate120(rotate120(source))))
ans += 2 ** get_perm_rings(flatten(rotate120(rotate180(source))))
ans += 2 ** get_perm_rings(flatten(rotate120(rotate180(rotate120(source)))))
print(ans // 6)
```

---

## 作者：CaoXian (赞：0)

这题吧，基本上就是个裸的 Polya 定理，直接把置换群构造出来就好了。

首先一个恒等置换，再加上旋转的两种（$120^\circ$ 和 $240^\circ$，一次旋转除了中心可能有一个中心点不动，剩下的点都是三个一组循环的。），翻转的话就把前面的情况复制一遍再翻转就好了，总共就有 $6$ 种，所以 $|G| = 6$。

（我刚开始一直在想先翻转后旋转和先旋转后翻转不应该是不同的吗，为什么可以直接把翻转放到后面来算。还纠结了半天，事实证明不如自己拿个纸板子转两下就知道了😂，先翻后转和先转后翻没啥区别。）

接下来是 $c(g)$ 的问题，令 $sum = \dfrac{n(n + 1)}{2}$，那么恒等置换显然有 $sum$ 个循环置换。

旋转的情况的话因为是三个一组的，并且可能有一个中心点不动会提供一个大小为 $1$ 的循环置换，所以这时 $c(g) = \left\lceil\dfrac{sum}{3}\right\rceil$。

翻转（加上翻转后旋转的）本质上是将其按照三条对称轴进行翻转，每一行的元素两两一组翻转，注意每隔一行就会有一个中心点不会翻转，此时 $c(g) = \dfrac{sum - \left\lceil\dfrac{n}{2}\right\rceil}{2} + \left\lceil\dfrac{n}{2}\right\rceil$。

代入一下 Polya 定理公式：

$$
|X / G| = \dfrac{1}{|G|}\sum\limits_{g \in G}|
B|^{c(g)}
$$

答案即为：

$$
\dfrac{2^{sum} + 2 \times 2^{\left\lceil\frac{sum}{3}\right\rceil} + 3 \times 2^{\frac{sum - \left\lceil\frac{n}{2}\right\rceil}{2} + \left\lceil\frac{n}{2}\right\rceil}}{6}
$$

最后再高精度计算一下就好啦。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n, sum;
struct meow {
	basic_string<int> s;
	meow(int x = 0): s({x}) {
		while(s.back() > 9) s.push_back(s.back() / 10), *(----s.end()) %= 10;
	}
	void operator += (const meow& x) {
		auto it = x.s.begin();
		int r = 0;
		for(auto& i : s) {
			i += r;
			if(it != x.s.end()) i += *(it++);
			r = i / 10;
			i %= 10;
		}
		while(r || it != x.s.end()) {
			s.push_back(r);
			if(it != x.s.end()) s.back() += *(it++);
			r = s.back() / 10;
			s.back() %= 10;
		}
	}
	void operator *= (const int& x) {
		int r = 0;
		for(auto& i : s) {
			i = i * x + r;
			r = i / 10;
			i %= 10;
		}
		while(r) s.push_back(r % 10), r /= 10;
	}
	void operator /= (const int& x) {
		reverse(s.begin(), s.end());
		int r = 0;
		for(auto& i : s) {
			i += r * 10;
			r = i % x;
			i /= x;
		}
		reverse(s.begin(), s.end());
		while(!s.back()) s.pop_back();
	}
	friend ostream& operator << (ostream& out, const meow& x) {
		for(auto it = x.s.rbegin(); it != x.s.rend(); ++it) out << *it;
		return out;
	}
} a, ans;
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> n;
	sum = n * (n + 1) / 2;
	a = 1;
	for(int i = 1; i <= sum; ++i) a *= 2;
	ans += a;
	a = 1;
	for(int i = 1; i <= (sum + 2) / 3; ++i) a *= 2;
	a *= 2;
	ans += a;
	a = 1;
	for(int i = 1; i <= (sum - (n + 1) / 2) / 2 + (n + 1) / 2; ++i) a *= 2;
	a *= 3;
	ans += a;
	ans /= 6;
	cout << ans;
	return 0;
}
```

---

## 作者：creation_hy (赞：0)

这题好水啊，难点是高精吗（

这里默认大家都会 polya 定理了，不会请先做板子。

明显 polya 定理，发现有三种置换，分别是：不变、旋转、翻转。

记格子总数为 $tot$，即 $\dfrac{n(n+1)}{2}$。

不变就是所有可能嘛，$2^{tot}$。

翻转也很简单，奇数行中心对称，为 $\dfrac{i+1}{2}$，偶数行就是一半。把每行看成一个数，发现这个数列是 $1+1+2+2+...$，分类讨论，如果行数为偶数就是 $2\times\dfrac{(\dfrac{n}{2})(\dfrac{n}{2}+1)}{2}$，否则 $2\times\dfrac{(\dfrac{n}{2})(\dfrac{n}{2}+1)}{2}+\dfrac{n}{2}+1$。

然后就是旋转，旋转手动模拟 $n=[1,4]$ 的情况就可以发现是每三个一个循环，如果多出来就单独算。由于 $tot \bmod 3$ 不可能为 $2$，所以只需要考虑这两种。

接下来考虑每种置换的方法数，不变显然一种，旋转有两种（题面上的那两种），翻转有三种（三个轴）。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
struct BigInt
{
    vector<int> vec;
    inline BigInt operator+(BigInt t)
    {
        int sz = max(vec.size(), t.vec.size());
        vector<int> res(sz);
        int cry = 0;
        for (int i = 0; i < sz; i++)
        {
            if (vec.size() > i)
                res[i] += vec[i];
            if (t.vec.size() > i)
                res[i] += t.vec[i];
            res[i] += cry;
            cry = res[i] > 9;
            res[i] %= 10;
        }
        if (cry)
            res.emplace_back(1);
        return (BigInt){res};
    }
    inline BigInt operator-(BigInt t)
    {
        vector<int> res = vec;
        int cry = 0;
        for (int i = 0; i < vec.size(); i++)
        {
            if (t.vec.size() > i)
                res[i] -= t.vec[i];
            res[i] -= cry;
            cry = 0;
            if (res[i] < 0)
            {
                res[i] += 10;
                cry = 1;
            }
        }
        while (res.size() > 1 && !res.back())
            res.pop_back();
        return (BigInt){res};
    }
    inline BigInt operator*(BigInt t)
    {
        vector<int> res(vec.size() + t.vec.size() - 1);
        for (int i = 0; i < vec.size(); i++)
            for (int j = 0; j < t.vec.size(); j++)
                res[i + j] += vec[i] * t.vec[j];
        for (int i = 0; i < res.size() - 1; i++)
            res[i + 1] += res[i] / 10, res[i] %= 10;
        while (res.back() > 9)
        {
            res.emplace_back(res.back() / 10);
            res[res.size() - 2] %= 10;
        }
        return (BigInt){res};
    }
    inline BigInt operator/(int k)
    {
        vector<int> res;
        reverse(vec.begin(), vec.end());
        int cur = 0, beg = 0;
        for (int i = 0; i < vec.size(); i++)
        {
            cur = cur * 10 + vec[i];
            if (cur >= k)
            {
                res.emplace_back(cur / k);
                cur %= k;
                beg = 1;
            }
            else if (beg)
                res.emplace_back(0);
        }
        reverse(vec.begin(), vec.end());
        reverse(res.begin(), res.end());
        if (res.empty())
            res.emplace_back(0);
        return (BigInt){res};
    }
    inline bool operator<=(BigInt t)
    {
        if (vec.size() != t.vec.size())
            return vec.size() < t.vec.size();
        for (int i = vec.size() - 1; ~i; i--)
            if (vec[i] != t.vec[i])
                return vec[i] < t.vec[i];
        return true;
    }
    inline BigInt sqrt()
    {
        BigInt l, r, num = *this, _1, _2;
        l.vec.emplace_back(0);
        r.vec.emplace_back(1);
        _1.vec.emplace_back(1);
        _2.vec.emplace_back(2);
        while (r * r <= num)
            r = r * _2;
        while (l <= r)
        {
            BigInt mid = (l + r) / 2;
            if (mid * mid <= num)
                l = mid + _1;
            else
                r = mid - _1;
        }
        return l - _1;
    }
    inline BigInt pow2()
    {
        BigInt res, num = *this, _0, _1, _2;
        res.vec.emplace_back(1);
        _0.vec.emplace_back(0);
        _1.vec.emplace_back(1);
        _2.vec.emplace_back(2);
        while (!(num <= _0))
        {
            res = res * _2;
            num = num - _1;
        }
        return res;
    }
    inline void read()
    {
        string s;
        cin >> s;
        vec.resize(s.size());
        for (int i = 0; i < s.size(); i++)
            vec[s.size() - i - 1] = s[i] - '0';
    }
    inline void print()
    {
        for (int i = vec.size() - 1; ~i; i--)
            cout << vec[i];
    }
    inline int mod3()
    {
        int res = 0;
        for (int x : vec)
            (res += x) %= 3;
        return res;
    }
};
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    BigInt n, _1;
    _1.vec.emplace_back(1);
    n.read();
    BigInt tot = n * (n + _1) / 2;
    BigInt a = tot.pow2();
    BigInt b = (!(n.vec.back() & 1) ? (n / 2) * (n / 2 + _1) : (n / 2) * (n / 2 + _1) + n / 2 + _1).pow2();
    BigInt c = (!(tot.mod3()) ? tot / 3 : tot / 3 + _1).pow2();
    ((a + b + b + b + c + c) / 6).print();
    return 0;
}   
```

---


# 四元组统计

## 题目描述

有 $n$ 个正整数 $a _ i$，你要统计有多少个四元组满足 $\gcd(a _ i, a _ j, a _ k, a _ l) = 1$。


## 说明/提示

对于 $30\%$ 的数据，$4 ≤ n ≤ 10$，且数据组数不超过 $10$；

对于 $100\%$ 的数据，$4 ≤ n ≤ 10000$，$1 ≤ a _ i≤ 10000$，且数据组数不超过 $100$。


## 样例 #1

### 输入

```
4
2 3 4 5
4
2 4 6 8
7
2 3 4 5 7 6 8  ```

### 输出

```
1
0
34
```

# 题解

## 作者：command_block (赞：19)

**题意** : 给出$n$个数$a_{1...n}$,统计有多少个四元组满足$gcd(a_i,a_j,a_k,a_l)=1$

多组数据,$T\leq 100,n,a_i\leq 10^4$

------------

- **类似的问题** : 给出若干个$[0,2^n)$内的数,对$m=[0,2^n)$求选取$k$元组`and`起来为$m$的方案数.

  开个桶记录出现次数,设为$F[n]$.

  先跑高维前缀和,然后$F[n]$就变成了“是$n$的超集的个数”

  我们令$F[n]=\dbinom{F[n]}{k}$,即“且起来是是$n$的超集的$k$元组个数”

  然后跑高维差分,即可得到“且起来是是$n$的$k$元组个数”。

  这道题告诉我们,对于按位取$\min/\max$的运算,其转移是个`DAG`,这类变换除了线性性之外往往还有其他优秀性质。

回到本题,其实`gcd`就是质因数向量上的$\min$.

先做一个约数前缀和,然后就变为了点值,每个点值变成$\dbinom{num}{4}$,然后跑一个约数差分即可。

这样甚至能得到$\gcd$为每个数的答案,我们最后只需取出$F[1]$即可。

容易发现,改成$k$元组同样能做。

复杂度可以用[P5495 Dirichlet 前缀和](https://www.luogu.com.cn/problem/P5495)做到$O(Tn\log\log n)$

代码很好写 :

```cpp
#include<algorithm>
#include<cstdio>
#define MaxN 20050000
#define ll long long
using namespace std;
inline int read(){
  register int X=0;
  register char ch=0;
  while(ch<48||ch>57)ch=getchar();
  while(ch>=48&&ch<=57)X=X*10+(ch^48),ch=getchar();
  return X;
}
ll F[MaxN];
int p[MaxN/12],tn;
void solve()
{
  int m,n=1;
  if (scanf("%d",&m)==EOF)exit(0);
  for(int i=1,t;i<=m;i++){
    F[t=read()]++;
    n=max(n,t);
  }
  for(int i=1;p[i]<=n;i++)
    for(int j=n/p[i];j;j--)
      F[j]+=F[j*p[i]];
  for(int i=1;i<=n;i++)F[i]=(F[i]-3)*(F[i]-2)*(F[i]-1)*F[i]/24;
  for(int i=1;p[i]<=n;i++)
    for(int j=1;j*p[i]<=n;j++)
      F[j]-=F[j*p[i]];
  printf("%lld\n",F[1]);
  for(int i=1;i<=n;i++)F[i]=0;
}
bool e[MaxN];
int main()
{
  for(int i=2;i*i<=10000;i++)
    if (!e[i])
      for (int j=i*i;j<=10000;j+=i)
        e[j]=1;
  for(int i=2;i<=10000;i++)
    if (!e[i])p[++tn]=i;
  p[++tn]=10001;
  while(1)solve();
  return 0;
}
```

似乎利用$\mu$函数非零值较少写暴力也可以跑得很快……

---

## 作者：da32s1da (赞：17)

分两步，令$\mathrm{M}=10^4$

1. $O(\mathrm{n\ ln\,n})$统计$1-\mathrm{M}$每个数的倍数
2. $O(\mathrm{n\ ln\,n})$统计$1-\mathrm{M}$每个数的答案

----

对于1操作，开一个桶$f$记录每个数出现次数，然后$f[i]=\sum_{i|d}f[d]$

----

对于2操作，求出所有$i$的倍数可能组成的四元组，这时$\gcd$一定是$i,2i,3i,\cdots$，然后减去$\gcd$是$2i,3i,\cdots$的四元组个数。即$f[i]={cnt\choose 4}-\sum_{i|d,i\neq d}f[d]$

----

正确性显然

```cpp
#include<cstdio>
#include<cstring>
const int N=1e4+50;
const int M=1e4;
typedef long long LL;
inline void rad(int &_){
    static char ch;
    while(ch=getchar(),ch<'0'||ch>'9');_=ch-48;
    while(ch=getchar(),ch<='9'&&ch>='0')_=_*10+ch-48;
}
int n,x;
LL f[N],Ans;
int main(){
	while(scanf("%d",&n)!=EOF){
		memset(f,0,sizeof(f));Ans=0;
		for(int i=1;i<=n;i++)rad(x),f[x]++;
		for(int i=1;i<=M;i++)
		for(int j=i<<1;j<=M;j+=i)
		f[i]+=f[j];//记录i的倍数 的数的个数
		for(int i=M;i;i--){
			f[i]=f[i]*(f[i]-1)*(f[i]-2)*(f[i]-3)/24;//i的倍数能组成多少四元组
			for(int j=i<<1;j<=M;j+=i)
			f[i]-=f[j];//减去gcd是2i,3i,...的四元组
		}
		printf("%lld\n",f[1]);
	}
}
```

---

## 作者：Leasier (赞：7)

Update on 2021.2.19：感谢 @黑题切割者_yql。 

1. $30 \operatorname{pts}$ 做法

依题意暴力统计即可。设数据组数为 $T$，令 $m = \max(a_1, a_2, \cdots, a_n)$，则时间复杂度为 $O(Tn^4 \log m)$。

代码：
```cpp
#include <stdio.h>

typedef long long ll;

int a[10007];

int gcd(int a, int b){
	return b == 0 ? a : gcd(b, a % b);
}

int main(){
	int n;
	while (scanf("%d", &n) != EOF){
		ll ans = 0;
		for (register int i = 1; i <= n; i++){
			scanf("%d", &a[i]);
		}
		for (register int i = 1; i <= n; i++){
			for (register int j = i + 1; j <= n; j++){
				for (register int k = j + 1; k <= n; k++){
					for (register int l = k + 1; l <= n; l++){
						if (gcd(a[i], gcd(a[j], gcd(a[k], a[l]))) == 1) ans++;
					}
				}
			}
		}
		printf("%lld\n", ans);
	}
	return 0;
}
```
2. $100 \operatorname{pts}$ 做法

前置芝士：[莫比乌斯反演](https://oi-wiki.org/math/mobius/)

令 $\operatorname{cnt}_i = \displaystyle\sum_{j = 1}^n [a_j = i]$，$f(x)$ 表示其 $\gcd$ 为 $x$ 的方案数，$g(x)$ 表示其 $\gcd$ 为 $x$ 的倍数的方案数，则所求为 $f(1)$。

显然 $g(x) = C_{\sum_{x\ |\ d}^m  \operatorname{cnt}_d}^4 = \displaystyle\sum_{x\ |\ d}^n f(d)$。运用倍数形式的莫比乌斯反演公式可得：$f(x) = \displaystyle\sum_{x\ |\ d}^n \mu(d) g(d)$。

将 $n = 1$ 带入可得：$f(1) = \displaystyle\sum_{i = 1}^n \mu(i) f(i)$。

线性筛出 $\mu$ 函数后直接计算即可。时间复杂度为 $O(Tm \ln m + N)$。

代码：
```cpp
#include <stdio.h>

typedef long long ll;

const int N = 1e4 + 7;
int prime[N], mu[N], a[N], cnt[N];
bool p[N];

inline void init1(){
	int cnt = 0;
	p[0] = p[1] = true;
	mu[1] = 1;
	for (register int i = 2; i < N; i++){
		if (!p[i]){
			prime[++cnt] = i;
			mu[i] = -1;
		}
		for (register int j = 1; j <= cnt && i * prime[j] < N; j++){
			int t = i * prime[j];
			p[t] = true;
			if (i % prime[j] == 0){
				mu[t] = 0;
				break;
			}
			mu[t] = -mu[i];
		}
	}
}

inline void init2(int n, int m){
	for (register int i = 1; i <= m; i++){
		cnt[i] = 0;
	}
	for (register int i = 1; i <= n; i++){
		cnt[a[i]]++;
	}
}

inline int max(int a, int b){
	return a > b ? a : b;
}

inline ll comb_4(int n){
	return (ll)n * (n - 1) * (n - 2) * (n - 3) / 24;
}

int main(){
	int n;
	init1();
	while (scanf("%d", &n) != EOF){
		int m = 0;
		ll ans = 0;
		for (register int i = 1; i <= n; i++){
			scanf("%d", &a[i]);
			m = max(m, a[i]);
		}
		init2(n, m);
		for (register int i = 1; i <= m; i++){
			if (mu[i] != 0){
				int cur_ans = 0;
				for (register int j = i; j <= m; j += i) cur_ans += cnt[j];
				ans += mu[i] * comb_4(cur_ans);
			}
		}
		printf("%lld\n", ans);
	}
	return 0;
}
```

---

## 作者：lianchanghua (赞：7)

#### 题目大意

有 $n$ 个正整数 $a_i$，你要统计有多少个四元组满足全部互质（不要求两两互质）。

#### 思路

本题需要用到容斥原理。
我可以逆向考虑：我们去考虑其补集, 我们求出四个数的最大公约数大于 $1$ 的。然后再用 $C_{n}^{4}$ 减去剩下的就是结果。我们就可以将每个数的因子都分解出来。然后进行相加减，如 $6$ 时，$6$ 会重复出现在 $2$，$3$ 中，所以就从中减去，每个都进行这样的操作即可。

思路就是这个思路，实现就十分简单了。

#### AC code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m;
int a[10010],ans[10010];
void q(int x){
	for(int i=1;i*i<=x;i++){
		if(x%i==0){
			a[i]++;
			if(i*i!=x) a[x/i]++;
		}
	}
}
int qq(int x){
	return x*(x-1)*(x-2)*(x-3)/24;
}
signed main(){
    while(cin>>n){
        memset(ans,0,sizeof(ans));
        memset(a,0,sizeof(a));
        for(int i=1;i<=n;i++){
        	int x;
        	cin>>x;
        	q(x);
    	}
        for(int i=10000;i>=1;i--){
        	ans[i]=qq(a[i]);
        	for(int j=i*2;j<=10000;j+=i)
        		ans[i]-=ans[j];
    	}
    	cout<<ans[1]<<"\n";    
    }
	return 0;
}
```

---

## 作者：ollo (赞：5)

~~个人认为我的思路是比较自然的。~~

首先，显然 $\gcd(a_i,a_j,a_k,a_l) = 1$ 是不好做的，考虑将其转换成总方案数减去 $\gcd(a_i,a_j,a_k,a_l) \neq 1$ 的方案数。记后半部分为 $num$，则原问题等价于求 $\binom n 4 - num$。

考虑怎么求 $num$，显然有 $\gcd(a_i,a_j,a_k,a_l) \neq 1$ 等价于 $\gcd(a_i,a_j,a_k,a_l) = f(f > 1)$。不妨枚举每个 $k$, 将所有可以整除它的 $a_i$ 统计一遍，记作 $w_i$，则此时貌似有 $num = \sum_{i = 2}^{10000} \binom {w_i} 4$。

但是此时会有重复计算，如 $\gcd(a_i,a_j,a_k,a_l) = 6$，则它在 $2$ 和 $3$ 都会被统计一遍。考虑容斥，易：

> $num = \binom {w_2} 4 + \binom {w_3} 4 + \binom {w_5} 4 + ... + \binom {w_{prime[tot]}} 4 - \binom {w_{2 \times 3}} 4 - \binom {w_{2 \times 5}} 4 - ...$

即若 $i$ 的唯一分解最高次为 $1$ 且 $i$ 的唯一分解有 $c$ 项，则加上 $(-1)^c\binom {w_i} 4$。将原方程变形，有

> $num = 1\binom {w_{2}} 4 + 1\binom {w_{3}} 4 + 0\binom {w_{4}} 4 + 1\binom {w_{5}} 4 + (-1)\binom {w_{6}} 4 + 1\binom {w_{7}} 4 + 0\binom {w_{8}} 4...$

由上，不难发现此方程等价于

> $num = \sum_{i = 2}^{10000}[w_i \neq 0]\mu(i)\binom {w_{i}} 4$

预处理出 $C$ 与 $\mu$ 即可。至于 $w$，可以用刷表法递推。

总时间复杂度 $O(T n \log n)$。

upd:

事实上，该方程有一般形式：

> 在一个集合 $a$ 中，记值域上界为 $k$，则满足 $\gcd(b_1, b_2, b_3, ..., b_m) = 1$ 的有序数对方案数为 $\binom n m - \sum_{i = 2}^{k}[w_i \neq 0]\mu(i)\binom {w_{i}} m$。

代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int N = 50010;

int C[N], mu[N], p[N], tot;
int w[N], a[N];
bool vis[N];

int n;

void solve(){
	mu[1] = 1;
	for(int i = 2; i <= 10000; i++){
		if(!vis[i]) p[++tot] = i, mu[i] = -1;
		for(int j = 1; j <= tot && i * p[j] <= 10000; j++){
			vis[i * p[j]] = 1;
			if(!(i % p[j])) break;
			mu[i * p[j]] = -mu[i];
		}
	}
	for(int i = 4; i <= 10000; i++){
		C[i] = i * (i - 1) * (i - 2) * (i - 3) / (2 * 3 * 4);
	}
}

signed main(){
	solve();
	while(cin >> n){
		for(int i = 1; i <= n; i++){
			cin >> a[i];w[a[i]]++;
		}
		for(int i = 1; i <= 10000; i++){
			for(int j = i * 2; j <= 10000; j += i){
				w[i] += w[j];
			}
		}
		int ans = 0;
		for(int i = 1; i <= 10000; i++){
			if(w[i] >= 4) ans = ans + C[w[i]] * mu[i];
		}
		cout << ans << endl;
		memset(w, 0, sizeof(w));
	}
	return 0;
}
```

---

## 作者：too_later (赞：3)

### [link](https://www.luogu.com.cn/problem/P2714)

### 题目大意：

有 $n$ 个正整数 $a_i$，你要统计有多少个四元组满足 $\gcd(a_i,a_j,a_k,a_l) = 1$。

$1\le n\le 10000,T\le 100,a_i\le 10000$。

### Solution:

首先考虑一个弱化版：求多少个四元组满足 $\gcd(a_i,a_j,a_k,a_l)=kx,k\in N^* $。

这个问题我们只要把每个数的质因数统计出来，然后取 $\dbinom n 4$ 即可。（必须包含这个质因子）

那么我们对于每个数得倍数都会做了，现在要求单独的怎么做呢？容斥呗！从大到小处理，把其倍数都减掉即可。

这个题做完了，时间复杂度 $O(nlogn+n\sqrt a_i)$

### Code:

```cpp
#include<bits/stdc++.h>
#define int long long
#define I inline
#define RI register int
#define rep(i,a,b) for(RI i=a;i<=b;++i)
#define dow(i,a,b) for(RI i=a;i>=b;--i)
using namespace std;
const int N=1e5+5;
int n,ans,a[N],buk[N],num[N];
I int C4(int n){ return (n-3)*(n-2)/2*(n-1)/3*n/4; }
signed main(){
	while(~scanf("%lld",&n)){
		ans=0;
		rep(i,1,n) scanf("%lld",&a[i]);
		rep(i,1,1e4) buk[i]=0;
		rep(i,1,n){
			rep(j,1,sqrt(a[i])){
				if(a[i]%j==0) {
					++buk[j];
					if(j*j!=a[i]) ++buk[a[i]/j];
				}
			}
		}
		dow(i,1e4,2){
			num[i]=C4(buk[i]);
			for(RI j=i+i;j<=1e4;j+=i){
				num[i]-=num[j];
			}
		}
		RI ans=C4(n);
		rep(i,2,1e4) ans-=num[i];
		printf("%lld\n",ans);
	}
	return 0;
}
```

### 思考

本质上就是会做倍数的，这种涉及到倍数的算重题一般可以用容斥做。

---

## 作者：金爷爷哈哈 (赞：3)

本题其实就是一个反演+组合的简单题。

我们设f[i]为gcd是i的倍数的4元组个数，g[i]为gcd是i的4元组个数。

显然 f[i]=Σg[j] (i|j).

那么反演一下，可以得到 g[i]=Σf[j]\*μ[j/i] (i|j)。


g不好求，我们看一下怎么求f从而求得g。


f[i]其实很好求，因为我们只要知道了a中i的倍数个数num,f[i]=C(num,4)。

所以对于每组数据，我们只要先求出了f，然后反演得到了g，那么g[1]即所求。


code:



    



        
        
    
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
#define maxn 10005
ll zs[maxn],u[maxn],t;
bool v[maxn];
ll T,C[maxn][5];
ll num[maxn],a[maxn],n,f[maxn],ans=0;
inline void init(){
    C[0][0]=1;
    for(int i=1;i<=maxn;i++){
        C[i][0]=1;
        for(int j=1;j<=4;j++) C[i][j]=C[i-1][j-1]+C[i-1][j];
    }
    u[1]=1;
    for(int i=2;i<=maxn;i++){
        if(!v[i]) zs[++t]=i,u[i]=-1;
        for(int j=1,w;j<=t&&(w=zs[j]*i)<=maxn;j++){
            v[w]=1;
            if(!(i%zs[j])) break;
            u[w]=-u[i];
        }
    }
}
inline void read(ll&x){
    x=0; char ch=getchar();
    while(!isdigit(ch)) ch=getchar();
    for(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';
}
int main(){
    init();
    while(scanf("%lld",&n)==1){
        memset(num,0,sizeof(num));
        memset(f,0,sizeof(f));
        ans=0;
        ll mx=0;
        for(int i=1;i<=n;i++) read(a[i]),num[a[i]]++,mx=max(mx,a[i]);
        for(int i=mx;i;i--){
              for(int j=i;j<=mx;j+=i) f[i]+=num[j];
              f[i]=C[f[i]][4];
        }
        for(int i=1;i<=mx;i++) ans+=u[i]*f[i];
        cout<<ans<<endl;
    }
    return 0;
}
```

---

## 作者：Lucky_Xiang (赞：2)

# 题目

[P2714](https://www.luogu.com.cn/problem/P2714)

# 分析

满足条件 $\gcd(a_i,a_j,a_k,a_l)=1$ 的四元组个数是不好直接求出的，但是满足条件 $d\mid\gcd(a_i,a_j,a_k,a_l)$ 的四元组个数是很好求的，其个数 $f(d)=\operatorname{C}_k^4$，其中 $k$ 表示序列中为 $d$ 的倍数的数的个数。

设满足条件 $\gcd(a_i,a_j,a_k,a_l)=d$ 的四元组个数为 $g(d)$，则 $f(n)=\sum_{n\mid d}g(d)$。由莫比乌斯反演，$g(n)=\sum_{n\mid d}\mu({d\over n})f(d)$，答案就很好求出来了。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int mn=10010;
const int N=10000;
int n,x;
int c[mn];
int p[mn],tot,mu[mn];
LL f[mn],g[mn];
bool st[mn];
void init()
{
    mu[1]=1;
    for(int i=2;i<=N;i++)
    {
        if(!st[i])p[++tot]=i,mu[i]=-1;
        for(int j=1;i*p[j]<=N;j++)
        {
            st[i*p[j]]=1;
            if(i%p[j]==0)
            {
                mu[i*p[j]]=0;
                break;
            }
            mu[i*p[j]]=-mu[i];
        }
    }
}
LL C(LL n)
{
    return n *(n-1)/2 *(n-2)/3 *(n-3)/4;
}
int cnt;
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    init();
    while(cin>>n)
    {
        for(int i=1;i<=N;i++)c[i]=f[i]=g[i]=0;
        for(int i=1;i<=n;i++)
        {
            cin>>x;
            c[x]++;
        }
        for(int k=1;k<=N;k++)
        {
            cnt=0;
            for(int i=k;i<=N;i+=k)
            {
                cnt+=c[i];
            }
            f[k]=C(cnt);
        }
        for(int k=1;k<=N;k++)
        {
            for(int i=k;i<=N;i+=k)
            {
                g[k]+=mu[i/k]*f[i];
            }
        }
        cout<<g[1]<<endl;
    }
    return 0;
}
```

---

## 作者：Light_Star_RPmax_AFO (赞：2)

### 前言

为了纪念 **长沙市一中** 第一次思维训练，我写下这篇题解。

[传送门](https://www.luogu.com.cn/problem/P2714)

## 题目描述

有 $n$ 个正整数 $a_i$，你要统计有多少个四元组满足 $\gcd(a_i,a_j,a_k,a_l) = 1$。

## 思路分析

我们使用 [**容斥**](https://oi-wiki.org/math/combinatorics/inclusion-exclusion-principle/) 遍历每一个 $\gcd(a_i,a_j,a_k,a_l) = x$ 的个数，储存在 $f_x$ 中，一直到 $1$ 的答案出现。

## 实现

得到 $x=2$ 时的个数，我们使用组合，也就是从序列中随便选取 $4$ 个包含 $2$ 的数，这时我们的方案数就是 $C_{m_{2}}^{4}$。

仅仅是这样吗？

**No!**

如果这四个数都包含 $4$ 呢？我们就重复算了 $x=4$ 的个数，这时候不仅是 $4$ 所有 $2$ 的倍数全部都被算了一遍。

所以我们可以把多算的全部减去：

$$f_i=C_{m_i}^4-{\sum _{j=i\times2}^{maxn}[j|i] f_j} $$

那么就得出了答案。

注：$\sum _{j=i\times2}^{maxn}[j|i] f_j$ 意思为查找 $i$ 的倍数 $j$ 的方案数的累加。

# AC Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,maxn=-1;
int g[10010],f[10010];
void check(int x){
	for(int i=1;i<=sqrt(x);++i){
		if(x%i==0){
			g[i]++;
			if(i*i!=x){
				g[x/i]++;		
			}	
		}	
	}
}//查找每一个因数

int C(int n,int m)
{
	int ans=1;
	for (int i=1;i<=n;i++){
		ans=ans*(m-i+1);
		ans=ans/i;
	}
	return ans;
}//组合公式

signed main(){
	while(cin>>n){
		memset(g,0,sizeof(g));
		memset(f,0,sizeof(f));
		for(int i=1,s;i<=n;i++){
			cin>>s;
			check(s);
			maxn=max(maxn,s);	
		}
		for(int i=maxn;i>=1;i--){
			f[i]=C(4,g[i]);
			for(int j=i*2;j<=maxn;j+=i){
				f[i]-=f[j];//容斥，去除算了两次的。
			}
		}
		cout<<f[1]<<endl;//输出答案。
	}
	
}
/*
4
2 3 4 5
4
2 4 6 8
7
2 3 4 5 7 6 8
*/
```

---

## 作者：yyxmy (赞：2)

此题可以容斥解决， 对于每一个$i$， 我们可以找到它的倍数有多少个， 从它的倍数中任意选择， 那么得到的答案就是$gcd$为i的倍数的方案数， 我们现在要求的是$gcd$恰好为1的方案数， 那么我们令f(i)表示$gcd$恰好为i， g(i)表示$gcd$至少为i的方案数， g(i)我们已经知道怎么求了， 考虑$f(i)$的求法， 那么很显然

$f(i)=g(i) - \sum [i|j] f(j)$ 从大往小做， 我们就可以得到gcd为1的答案了


```cpp
#include<bits/stdc++.h>
#define reg register
#define maxn 100001
#define int long long
using namespace std;
inline int  read() {
    reg int s = 0, t = 0; reg char ch = getchar();
    while(ch > '9' || ch < '0') t |= ch == '-', ch = getchar();
    while(ch >= '0' && ch <= '9') s = (s << 1) + (s << 3) + (ch ^ 48), ch = getchar();
    return t ? -s : s;
}
int n, a[maxn + 7], prime[maxn + 7], mul[maxn + 7], is_prime[maxn + 7], d[maxn + 7], ans, maxx, cnt;
int C(int x){
	if(x <= 3) return 0;
	return x * (x - 1) * (x - 2) * (x - 3) / 24;
}
signed main(){
	//freopen("1.in","r", stdin);
	mul[1] = 1;
	for(int i = 2; i <= maxn; i++){
		if(!is_prime[i]) prime[++cnt] = i, mul[i] = -1;
		for(int j = 1; j <= cnt && prime[j] * i <= maxn; j++){
			is_prime[i * prime[j]] = 1; 
			if(i % prime[j] == 0) break;
			mul[i * prime[j]] = -mul[i];
		}
	}
	while(cin >> n){
		for(int i = 1; i <= n; i++) a[i] = read(), d[a[i]]++, maxx = max(maxx, a[i]);
		for(int i = 1; i <= maxx; i++)
			for(int j = i + i; j <= maxx; j += i) d[i] += d[j];
		for(int i = 1; i <= maxx; i++){
			ans = ans + mul[i] * C(d[i]);
		}
		cout << ans << endl;
		for(int i = 1; i <= maxx; i++) d[i] = 0; maxx = 0; ans = 0;
	}
}
```


---

## 作者：Kreado (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P2714)。

#### 思路

很典的数论容斥题目。

令 $g(x)$ 表示 $\gcd(a_i,a_j,a_k,a_l)|x$ 的个数，$f(x)$ 表示 $\gcd(a_i,a_j,a_k,a_l)=x$ 的个数。

很显然，有 $g(x)=\sum_{x|i}f(i)\Leftrightarrow f(x)=\sum_{x|i}g(i)\mu(\frac{i}{x})$

将 $x=1$ 带入得 $f(1)=\sum_{i=1}^n\mu(i)f(i)$。

对于 $g(x)$，我们已知了 $a$ 中 $x$ 的个数 $p$，那么 $g(x)=\dbinom{num}{4}$。

接下来直接求 $f(1)$ 即可。

#### CoDe

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const ll Maxn=1e5+7;
ll n,a[Maxn],f[Maxn],g[Maxn],mu[Maxn],num[Maxn],V;
int prime[Maxn],cnt;
bool isprime[Maxn];
inline void init(ll N){
	isprime[1]=isprime[0]=1;mu[1]=1;
	for(ll i=2;i<=N;i++){
		if(!isprime[i]) prime[++cnt]=i,mu[i]=-1;
		for(ll j=1;j<=cnt&&prime[j]*i<=N;j++){
			isprime[i*prime[j]]=1;
			if(!(i%prime[j])) break;
			mu[i*prime[j]]=-mu[i];
		}
	}
}
inline ll C(ll x){
	if(x<=3) return 0;
	return x*(x-1)*(x-2)*(x-3)/24;
}
int main(){
	init(Maxn-7);
	while(~scanf("%lld",&n)){
		ll ans=0;
		memset(num,0,sizeof num);
		for(ll i=1;i<=n;i++) scanf("%lld",&a[i]),num[a[i]]++,V=max(V,a[i]);
		for(ll i=V;i>=1;i--){
			for(ll j=i;j<=V;j+=i) 
				f[i]+=num[j];
			f[i]=C(f[i]);
		}
		for(ll i=1;i<=V;i++) ans+=f[i]*mu[i];
		printf("%lld\n",ans);	
		for(ll i=1;i<=V;i++) f[i]=0,num[i]=0;
	}
	return 0;
}

```


---

## 作者：WeLikeStudying (赞：1)

- [前置知识](https://www.luogu.com.cn/blog/luo1gu1zui1bang1/gao-wei-qian-zhui-hu)。
- [主要思想](https://www.luogu.com.cn/blog/luo1gu1zui1bang1/mei-hao-di-xi-ri)。

**题意**
- [链接](https://www.luogu.com.cn/problem/P2714)。
- 给出 $n$ 个数，统计满足最大公约数为 $1$ 的四元组（无序）个数。
- 值域 $w\le 10^4$，$4\le n\le 10^4$。

**分析**
- 直接上 $O(n^4)$ 的暴力显然不可取。
- 不过这题值域很小，我们有更好的方法。
- 定义长度为 $w$ 的向量 $a,b$ 的卷积 $c=a\times b$ 为：
$$c_n=\sum_{\gcd(i,j)=n}a_ib_j$$
- 那么有什么办法可以求出它呢？
- 我们知道一种传统的办法是算贡献，但这题的贡献并不好拆分，什么好拆分呢？$[n|\gcd(i,j)]=[n|i][n|j]$，整除好拆分！
- 那么设对于向量 $f$，它的 $f'$ 形如：
$$f'_ n=\sum_{n|d}f_d$$
- 容易得到（当然实际反推并不需要这样变化，只是方便辨认）：
$$f_ n=\sum_{n|d}\mu\bigg(\frac dn\bigg)f'_ d$$
- 那么卷积是容易计算的，正变换一下，直接相乘，再逆变换一下。
- 如果四元组有序，设长度为 $w$ 的向量 $a$ 满足 $a_i$ 是原数组中值域为 $i$ 的数的个数，且 $c=a^4$（$c'_ i=a'^4_ i$），那么 $c_1$ 显然就是答案。
- 如果四元组无序，设长度为 $w$ 的向量 $a$ 满足 $a_i$ 是原数组中值域为 $i$ 的数的个数，且 $c=a^4$（$c'_ i=C(a'_ i,4)$），那么 $c_1$ 显然就是答案。
- 怎么理解这个？实际上 $c'_ i$ 解决的是这样一个问题，有多少个四元组是 $i$ 的倍数？所以可以这样搞。
- 朴素做法的复杂度是 $O(Tn\log n)$ 的，运用[前置知识](https://www.luogu.com.cn/blog/luo1gu1zui1bang1/gao-wei-qian-zhui-hu)的内容可以做到 $O(Tn\log\log n)$。
- [代码实现](https://www.luogu.com.cn/paste/a84nkub6)。
- [理论上更优但实际上更慢的实现](https://www.luogu.com.cn/paste/d2wlsr5m)。

---

## 作者：_maze (赞：1)

你听说过循环不变式吗？不妨来品鉴一下吧：[WeLikeStudying 大佬的博客：循环不变式](https://www.luogu.com.cn/blog/luo1gu1zui1bang1/solution-p5495)

而这篇文章，只是对大佬博客的小小注解，外加一点实际应用。



------------

- 我们可以把循环不变式理解成一组条件。在每次循环中，我们保证这组条件均为真。而最后循环就可以得出我们想要的结果。

- 如果思考本质，这实际上可以一种数学归纳法。我们保证了循环任何时候都满足条件，只需要验证满足了这组条件就能求出答案。

- 满足的条件可以是显示在代码中的，也可以是隐藏起来的。

举个例子，斐波拉契数列中，我们创造两个变量 $a,b$，且保证：

$$a = \operatorname{fib}(i), b = \operatorname{fib}(i + 1)$$

那么就可以求出答案。

- 我们可以发现，选择一组好实现的条件，是化繁为简的关键。

------------

现在我们看到这道题：

- 首先这道题和 $\gcd$ 有关，再看到数据范围，这意味着我们的复杂度只要和每个数的倍数有关，就能通过此题。

- 最简单的条件是创造数组 $f_i$，且 $f_i=ans_i$。其中 $ans_i$ 就是 $\gcd(a,b,c,d) = i$ 的答案。但是我们发现这不好实现。

- 考虑扩大条件。我们不能求出恰好的答案，但是我们可以求出至少的答案。具体地，我们定义 $g_i$ 为 $\gcd(a,b,c,d)\mid i$ 的个数。我们枚举每个数的倍数，可以在 $n \ln n$ 的时间内求出来。

- 最后，我们寻找这两者的关系。要得到恰好为 $i$ 的答案，就要把所有比 $i$ 大的答案都从 $g_i$ 剔除出去。因此，我们得出 $f_i = g_i - \sum_{j \mid i} f_j$。

- 注意这个式子去除了一次 $f_i$。但是由于此时 $f_i$ 没有求出，应该为 $0$，所以没有影响。

总结一下，在程序中，我们只要满足下面的条件，那么 $f(1)$ 就是答案（设 $i$ 在序列中出现了 $num_i$ 次）。

$$g_i = \sum_{j \mid i} num_j$$

$$f_i = g_i - \sum_{j \mid i} f_j$$

下面是代码：

```cpp
#include<iostream>
#include<algorithm>

using namespace std;

const int N = 1e4 + 5;

int n;
int a[N];

long long ton[N], f[N], g[N];

void solve() {
  for (int i = 1; i <= n; ++i) cin >> a[i];

  int mxa = 0;
  for (int i = 1; i <= n; ++i) mxa = max(mxa, a[i]);
  for (int i = 1; i <= mxa; ++i) f[i] = g[i] = ton[i] = 0;
  for (int i = 1; i <= n; ++i) ++ton[a[i]];

  for (int i = mxa; i >= 1; --i) {
    long long sum_g = 0, sum_f = 0;
    for (int j = 1; i * j <= mxa; ++j) {
      sum_g += ton[i * j];
      sum_f += f[i * j];
    }
    g[i] = (sum_g * (sum_g - 1) * (sum_g - 2) * (sum_g - 3)) / (4 * 3 * 2 * 1);
    f[i] = max(1LL * 0, g[i] - sum_f);
  }

  cout << f[1] << endl;
}

signed main() {
  ios::sync_with_stdio(false);
  cin.tie(0);
  cout.tie(0);

  while (cin >> n) solve();

  return 0;
}

```


---

## 作者：zzy_zhouzhiyuan (赞：0)

####   题目大意：
有 $n$ 个正整数 $a_i$，你要统计有多少个四元组满足 $\gcd(a_i,a_j,a_k,a_l)=1$。

####   思路分析：
直接枚举四元组显然会超时。

所以我们可以考虑将每个数分解质因数，用 $f$ 数组统计。然后让 $ans$ 加上 $\sum_{i=1}^{10000}C_{f_i}^4$。
根据容斥原理，答案就是 $C_n^4-ans$。

#### 代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=10000;
int n,s,t;
int a[10005],f[10005],ff[10005];
int c(int n){
	return (n-3)*(n-2)*(n-1)*n/24;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	while(cin>>n){
	    s=c(n);
    	for(int i=1;i<=n;i++)cin>>a[i];
    	for(int i=1;i<=n;i++){
    		for(int j=1;j*j<=a[i];j++){
    			if(a[i]%j==0){
    				f[j]++;
    				if(j*j!=a[i])f[a[i]/j]++;
    			}
    		}
    	}
    	for(int i=N;i>=2;i--){
    		if(f[i]>=4){
    			ff[i]=c(f[i]);
    			for(int j=i*2;j<=N;j+=i)ff[i]-=ff[j];
    		}
    	}
    	for(int i=2;i<=N;i++)s-=ff[i],f[i]=0,ff[i]=0;
    	cout<<s<<"\n";
	}
}
```



---

## 作者：Register_int (赞：0)

首先[双倍经验](/problem/SP4191)。  
直接硬刚不太好做，考虑问题的反面，即有多少个四元组 $a,b,c,d$ 满足 $\gcd(a,b,c,d)>1$。枚举这个 $\gcd$ 的约数 $x$，并且设序列中能被 $x$ 整除的数的个数为 $x=n$，则满足 $x|\gcd(a,b,c,d)$ 的四元组个数为 $\binom n4$。之后，如果枚举过程中 $x$ 有平方因子 $p^2$，那么所有 $x$ 的方案数就都要作废。因为在容斥过程中，所有能被 $p^2$ 整除的方案都能被 $p$ 计算到。如果没有平方因子，那么就按照奇质因子为正，偶质因子为负的方式容斥。容易发现这一因数就是 $-\mu(x)$。那么直接计算就可以了。  
注意，为了快速计算能被 $x$ 整除的数的个数，需要先枚举倍数做一遍前缀和。
# AC 代码
```cpp
#include <bits/stdc++.h> 

using namespace std;

typedef long long ll;

const int MAXN = 1e4 + 10;

int p[MAXN], mu[MAXN], tot;
bool vis[MAXN];

inline 
void init(int n) {
    mu[1] = 1;
    for (int i = 2; i <= n; i++) {
        if (!vis[i]) p[++tot] = i, mu[i] = -1;
        for (int j = 1; j <= tot; j++) {
            if (i * p[j] > n) break;
            vis[i * p[j]] = 1;
            if (i % p[j] == 0) break;
            mu[i * p[j]] = -mu[i];
        }
    }
}

inline 
ll c4(ll n) {
    return n * (n - 1) / 2 * (n - 2) / 3 * (n - 3) / 4;
}

int n, maxp;

int a[MAXN], t[MAXN];

ll res;

int main() {
    init(1e4);
    while (~scanf("%d", &n)) {
        memset(t, 0, sizeof t), res = maxp = 0;
        for (int i = 1; i <= n; i++) scanf("%d", &a[i]), t[a[i]]++, maxp = max(maxp, a[i]);
        for (int i = 2; i <= maxp; i++) {
            for (int j = i << 1; j <= maxp; j += i) t[i] += t[j];
        }
        for (int i = 2; i <= maxp; i++) res += -mu[i] * c4(t[i]);
        printf("%lld\n", c4(n) - res);
    }
}
```

---


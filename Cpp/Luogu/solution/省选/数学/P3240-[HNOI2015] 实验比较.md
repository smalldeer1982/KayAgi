# [HNOI2015] 实验比较

## 题目描述

小 D 被邀请到实验室，做一个跟图片质量评价相关的主观实验。

实验用到的图片集一共有 $N$ 张图片，编号为 $1$ 到 $N$。实验分若干轮进行，在每轮实验中，小 D 会被要求观看某两张随机选取的图片， 然后小 D 需要根据他自己主观上的判断确定这两张图片谁好谁坏，或者这两张图片质量差不多。 

用符号 ”$<$”、“$>$” 和 “$=$” 表示图片 $x$ 和 $y$（$x$、$y$ 为图片编号）之间的比较：如果上下文中 $x$ 和 $y$ 是图片编号，则 $x<y$ 表示图片 $x$「质量优于」$y$，$x>y$ 表示图片 $x$「质量差于」$y$，$x=y$ 表示图片 $x$ 和 $y$ 「质量相同」；也就是说，这种上下文中，“$<$”、“$>$”、“$=$” 分别是质量优于、质量差于、质量相同的意思；在其他上下文中，这三个符号分别是小于、大于、等于的含义。

图片质量比较的推理规则（在 $x$ 和 $y$ 是图片编号的上下文中）：
1. $x < y$ 等价于 $y > x$。
2. 若 $x < y$ 且 $y = z$，则 $x < z$。
3. 若 $x < y$ 且 $x = z$，则 $z < y$。
4. $x=y$ 等价于 $y=x$。
5. 若 $x=y$ 且 $y=z$，则 $x=z$。 

实验中，小 D 需要对一些图片对 $(x, y)$，给出 $x < y$ 或 $x = y$ 或 $x > y$ 的主观判断。小 D 在做完实验后， 忽然对这个基于局部比较的实验的一些全局性质产生了兴趣。

在主观实验数据给定的情形下，定义这 $N$ 张图片的一个合法质量序列为形如 “$x_1 R_1 x_2 R_2 x_3 R_3 …x_{N-1} R_{N-1} x_N$” 的串，也可看作是集合 $\{ x_i R_i x_{i+1}|1 \leq i \leq N-1 \}$，其中  $x_i$ 为图片编号，$x_1,x_2, \ldots ,x_N$ 两两互不相同（即不存在重复编号），$R_i$ 为 $<$ 或 $=$，「合法」是指这个图片质量序列与任何一对主观实验给出的判断不冲突。 

例如： 质量序列 $3 < 1 = 2$ 与主观判断 “$3 > 1$，$3 = 2$” 冲突（因为质量序列中 $3<1$ 且 $1=2$，从而 $3<2$，这与主观判断中的 $3=2$ 冲突；同时质量序列中的 $3<1$ 与主观判断中的 $3>1$ 冲突） ，但与主观判断 “$2 = 1$，$3 < 2$”  不冲突；因此给定主观判断 “$3>1$，$3=2$” 时，$1<3=2$ 和 $1<2=3$ 都是合法的质量序列，$3<1=2$ 和 $1<2<3$ 都是非法的质量序列。

由于实验已经做完一段时间了，小 D 已经忘了一部分主观实验的数据。对每张图片 $X_i$，小 D 都**最多**只记住了某一张质量不比 $X_i$ 好的另一张图片 $K_{X_i}$。这些小 D 仍然记得的质量判断一共有 $M$ 条（$0 \leq M \leq N$），其中第 $i$ 条涉及的图片对为 $(K_{X_i}, X_i)$，判断要么是 $K_{X_i} < X_i$，要么是 $K_{X_i} = X_i$，而且所有的 $X_i$ 互不相同。小 D 打算就以这 M 条自己还记得的质量判断作为他的所有主观数据。

现在，基于这些主观数据，我们希望你帮小 D 求出这 $N$ 张图片一共有多少个不同的合法质量序列。我们规定：如果质量序列中出现 “$x = y$”，那么序列中交换 $x$ 和 $y$ 的位置后仍是同一个序列。因此： $1<2=3=4<5$ 和 $1<4=2=3<5$ 是同一个序列， $1 < 2 = 3$ 和 $1 < 3 = 2$ 是同一个序列，而 $1 < 2 < 3$ 与 $1 < 2 = 3$ 是不同的序列，$1<2<3$ 和 $2<1<3$ 是不同的序列。

由于合法的图片质量序列可能很多， 所以你需要输出答案对 $10^9 + 7$ 取模的结果。

## 说明/提示

不同的合法序列共5个，如下所示：

- $1 = 5 < 2 < 3 < 4$ 
- $1 = 5 < 2 < 4 < 3$
- $1 = 5 < 2 < 3 = 4$ 
- $1 = 5 < 3 < 2 < 4$ 
- $1 = 5 < 2 = 3 < 4$

$100\%$ 的数据满足 $N \leq 100$。

## 样例 #1

### 输入

```
5 4
1 < 2
1 < 3
2 < 4
1 = 5```

### 输出

```
5```

# 题解

## 作者：xyz32768 (赞：23)

先用并查集将所有用等号连接的点缩成一个。然后看到题目中有一个很重要的条件：

对每张图片$i$，小D都最多只记住了某一张质量不比$i$差的另一张图片$K_i$。

缩点后建树，对于每个$i$，如果$K_i$存在，就将$K_i$作为$i$的父节点。建树后有可能是一棵森林，所以新建一个新的节点$n+1$连接森林里每棵树的根节点，形成一棵树，$n+1$为根。

然后树形DP，$f[u]$表示$u$的子树内的方案数。

但对于$u$的两个不同子节点$v$和$w$，$v$和$w$的子树内可能存在两个点质量相等，所以还需要加一维：

$f[u][i]$表示$u$的子树里，分成$i$段（也就是共有$i-1$个小于号把质量序列分成了$i$个部分，每个部分里的图片质量相等）的方案数，然后做一次树形背包DP（当前枚举到了$u$的子节点$v$，$f'$表示枚举到子节点$v$之前的DP值）：

$$f[u][i]=\sum_{j,k}f'[u][j]\times f[v][k]\times ORZ$$

$ORZ$表示$j$段和$k$段合并成$i$段的方案数。

如何求$ORZ$呢？

设$f[u]$的质量序列为$A$，$f'[u]$的质量序列为$B$，$f[v]$的质量序列为$C$。

$A$中的每一段可以只包含$B$中的一段，可以只包含$C$中的一段，也可以有$B$和$C$中各一段合并而成，但不能为空。特殊地，$A$的第一段只能包含节点$u$。

相当于先枚举$B$中的$j-1$段在$A$中放的位置，方案数为$C_{i-1}^{j-1}$，然后把$C$中的$i-j$段放到$A$中剩下的位置，使每一段都不为空。现在$C$中还剩下$k-i+j$个段，他们需要与$B$中的段合并，方案数$C_{j-1}^{k-i+j}$。

所以：

$$ORZ=C_{i-1}^{j-1}\times C_{j-1}^{k-i+j}$$

最后答案$\sum_{i}f[n+1][i]$。

复杂度：$f[u][i]$第二维的上界只有$u$的子树大小，枚举$i$相当于枚举$i$的子树内的点。所以看上去是$O(n^4)$的，实际上每对点都只在lca处被计算贡献了$O(n)$次，复杂度$O(n^3)$。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
	int res = 0; bool bo = 0; char c;
	while (((c = getchar()) < '0' || c > '9') && c != '-');
	if (c == '-') bo = 1; else res = c - 48;
	while ((c = getchar()) >= '0' && c <= '9')
		res = (res << 3) + (res << 1) + (c - 48);
	return bo ? ~res + 1 : res;
}
inline char get() {
	char c; while ((c = getchar()) != '<' && c != '='); return c;
}
const int N = 135, M = 265, ZZQ = 1e9 + 7;
int n, m, X[N], Y[N], fa[N], ecnt, nxt[M], adj[N], go[M], in[N], cnt[N],
f[N][N], sze[N], C[N][N], g[N];
bool eq[N], its[N];
void init() {
	int i, j; for (i = 0; i <= 120; i++) C[i][0] = 1;
	for (i = 1; i <= 120; i++) for (j = 1; j <= i; j++)
		C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % ZZQ;
}
void add_edge(int u, int v) {
	nxt[++ecnt] = adj[u]; adj[u] = ecnt; go[ecnt] = v;
	nxt[++ecnt] = adj[v]; adj[v] = ecnt; go[ecnt] = u;
}
int cx(int x) {
	if (fa[x] != x) fa[x] = cx(fa[x]);
	return fa[x];
}
bool zm(int x, int y) {
	int ix = cx(x), iy = cx(y);
	if (ix != iy) fa[iy] = ix;
	else return 1;
	return 0;
}
void dfs(int u, int fu) {
	int i, j, k; sze[u] = f[u][1] = 1;
	for (int e = adj[u], v; e; e = nxt[e]) {
		if ((v = go[e]) == fu) continue; dfs(v, u);
		for (i = 1; i <= n; i++) g[i] = 0;
		for (i = 1; i <= sze[u] + sze[v]; i++) for (j = 1; j <= sze[u]; j++)
		for (k = 1; k <= sze[v]; k++) {
			int x = k - i + j; if (x < 0) continue;
			(g[i] += 1ll * f[u][j] * f[v][k] % ZZQ *
				C[i - 1][j - 1] % ZZQ * C[j - 1][x] % ZZQ) %= ZZQ;
		}
		for (i = 1; i <= sze[u] + sze[v]; i++) f[u][i] = g[i];
		sze[u] += sze[v]; 
	}
}
int main() {
	int i; n = read(); m = read(); init();
	for (i = 1; i <= n; i++) fa[i] = i;
	for (i = 1; i <= m; i++) X[i] = read(),
		eq[i] = get() == '=', Y[i] = read();
	for (i = 1; i <= m; i++) if (eq[i]) zm(X[i], Y[i]);
	for (i = 1; i <= n; i++) its[in[i] = cx(i)] = 1;
	for (i = 1; i <= n; i++) fa[i] = i;
	for (i = 1; i <= m; i++)
		if (!eq[i]) {
			add_edge(in[X[i]], in[Y[i]]); cnt[in[Y[i]]]++;
			if (zm(in[X[i]], in[Y[i]])) return printf("0\n"), 0;
		}
	for (i = 1; i <= n; i++) if (its[i] && !cnt[i]) add_edge(n + 1, i);
	int ans = 0; dfs(n + 1, 0); for (i = 1; i <= sze[n + 1]; i++)
		ans = (ans + f[n + 1][i]) % ZZQ; cout << ans << endl;
	return 0;
}
```

---

## 作者：Imakf (赞：18)

## Editorial

**这是一个 $O(n^2)$ 的做法。**

题意各位大佬都讲得很清楚了，现在可以转化成一个问题是：给定一个内向森林，祖先结点的颜色必须严格大于后代结点。颜色必须为连续正整数，求方案。

先考虑一棵树的答案：

设 $g(n)$ 表示所有节点有 $n$ 种颜色且满足题意的方案数。

然后我们可以设 $f(n)= \sum\limits_{i=0}^{n}\binom{n}{i}g(i)$。

**21.1.13upd**：这样看着可能不太明确其含义，补一下：我们可以设 $f[i][j]$ 表示在 $i$ 子树内的所有节点，颜色小于 $j$，$i$ 的颜色恰好是 $j$ 的方案数。即，不要求选出的颜色的值域是 $1\sim k$ 连续的。这样就可以树形 dp 了。

不难发现 $f(i)\ (1 \le i \le n)$ 可以通过一个 $O(n^2)$ 的前缀和优化树形 dp 求出。

根据二项式反演  $g(n)=\sum\limits_{i=0}^{n} \binom{n}{i}(-1)^{n-i}f(i)$ 我们就可以得到答案了。

总复杂度仅为 $O(n^2)$。

-----

## Code

而在本题中，是内向树森林，我们建立一个虚结点 $n+1$，与所有树的根连边。

运行上述算法时，我们对虚结点的转移进行单独判断即可。

```cpp
int ind[MX];
int head[MX] ,tot;
struct edge{
	int node ,next;
}h[MX << 1];
void addedge(int u ,int v){
	h[++tot] = (edge){v ,head[u]} ,head[u] = tot;
	ind[v]++;
}

LL dp[MX][MX] ,S[MX][MX] ,C[MX][MX];

int fa[MX] ,n ,m;
void init(){
	for(int i = 1 ; i < MX ; ++i) fa[i] = i;
	for(int i = 0 ; i < MX ; ++i) C[i][0] = 1;
	for(int i = 1 ; i < MX ; ++i)
		for(int j = 1 ; j < MX ; ++j)
			C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % MOD;
}
int find(int x){return fa[x] == x ? x : fa[x] = find(fa[x]);}
void link(int u ,int v){u = find(u) ,v = find(v) ,fa[u] = v;}

int cnt ,ins[MX];
void dapai(int x){
	if(ins[x]) puts("0") ,exit(0);
	ins[x] = 1;
	for(int i = 1 ; i <= cnt ; ++i) dp[x][i] = 1;
	for(int i = head[x] ,d ; i ; i = h[i].next){
		dapai(d = h[i].node);
		for(int j = 1 ; j <= cnt ; ++j){
			if(x == n + 1) dp[x][j] = dp[x][j] * S[d][j] % MOD;
			else dp[x][j] = dp[x][j] * S[d][j - 1] % MOD;
		}
	}
	ins[x] = 0;
	for(int i = 1 ; i <= cnt ; ++i) S[x][i] = (S[x][i - 1] + dp[x][i]) % MOD;
}

int ecnt;
struct EDGE{int u ,v;}E[MX];

int main(){
	init();
	n = read() ,m = read();
	for(int i = 1 ,u ,v ; i <= m ; ++i){
		char type[233];
		scanf("%d%s%d" ,&u ,type ,&v);
		if(type[0] == '=') link(u ,v);
		else E[++ecnt] = (EDGE){u ,v};
	}
	for(int i = 1 ; i <= ecnt ; ++i){
		addedge(find(E[i].u) ,find(E[i].v));
	}

	int in = 0;
	for(int i = 1 ; i <= n ; ++i){
		if(find(i) == i) ++cnt;
		if(find(i) == i && !ind[i]){
			addedge(n + 1 ,find(i));
			++in;
		}
	}
	if(!in){
		puts("0");
		return 0;
	}
	dapai(n + 1);
	LL ans = 0;
	for(int j = 1 ; j <= cnt ; ++j){
		LL tmp = 0;
		for(int i = 0 ; i <= j ; ++i){
			LL add = dp[n + 1][i] * ((j - i) & 1 ? -1 : 1) * C[j][i] % MOD;
			add = (add + MOD) % MOD;
			tmp = (tmp + add) % MOD;
		}
		debug("stained %d color %lld\n" ,j ,tmp);
		ans = (ans + tmp) % MOD;
	}
	printf("%lld\n" ,ans);
	return 0;
}
```



---

## 作者：伟大的王夫子 (赞：3)

首先，我们把本来就相等的点用并查集连到一起。然后对于小于关系，我们可以用 floyd 进行传递闭包，并且建图。由于对于一张照片 $X$， 小 $D$ 最多只记住了一张照片比他不好，所以我们可以保证建出来的是一棵树，每个点只有一个父亲。对于那些没有小于他的照片，可以建立一个虚点，向虚点连边即可。当然，还要提前判断一下是否有解。

那样的话我们可以进行一个树形 DP。容易发现，我们最终得到的合法序列的形式一定是一堆用小于号连接的连等式。在我们合并两个合法序列时，合并的方案数也只是与连等式的个数有关。那我们在合并时也只需要记一下当前连等式的段数就好了。

我们假设当前要将有 $u$ 段的和有 $v$ 段的合法序列合并成 $k$ 段。考虑 $k = u +v$ 的平凡情况。合并方案数显然是 $ \binom{u + v}{v}$。相当于是从 $u+v$ 个位置中选取 $u$ 个位置给 $u$，剩下的全部给 $v$。在思考一下正常 $k \le u + v$  的情况。答案为 $\binom{k}{u}\binom{u}{u+v-k}$。即从 $k$ 中先选出 $u$ 个，再从 $u$ 中选出 $u +v - k$ 个，那样剩下来刚好有 $(u + v - k) +(k - u) = v$         个位置。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 105;
const int mod = 1e9 + 7;
int n, m, fa[N], c[N], g[N][N], sz[N], dp[N][N], pd[N], C[N][N];
bool d[N][N], v[N];
vector<int> e[N];
struct {
	int x, y;
	bool t;
} a[N];
void floyd() {
	for (int k = 1; k <= n; ++k)
		for (int i = 1; i <= n; ++i)
			for (int j = 1; j <= n; ++j)
				d[i][j] |= d[i][k] & d[k][j];
}
int get(int x) {
	return fa[x] == x ? x : fa[x] = get(fa[x]);
}
void dfs(int x) {
	dp[x][0] = 1;
	for (auto y : e[x]) {//cout << x << ' ' << y << endl;
		dfs(y);
		for (int k = 0; k <= sz[x] + sz[y]; ++k) pd[k] = 0;
		for (int u = 0; u <= sz[x]; ++u)
			for (int v = 0; v <= sz[y]; ++v)
				for (int k = max(u, v); k <= u + v; ++k)
					pd[k] = (pd[k] + 1ll * dp[x][u] * dp[y][v] % mod * C[k][u] % mod * C[u][u + v - k] % mod) % mod;
		for (int k = 0; k <= sz[x] + sz[y]; ++k) dp[x][k] = pd[k];
		sz[x] += sz[y];
	}
	++sz[x];
	for (int i = sz[x]; i; --i) dp[x][i] = dp[x][i - 1];
	dp[x][0] = 0;
}
int main() {
	cin >> n >> m;
	for (int i = 1; i <= n; ++i) fa[i] = i;
	for (int i = 1, x, y; i <= m; ++i) {
		char op[5];
		scanf("%d%s%d", &a[i].x, op, &a[i].y);
		if (op[0] == '=') fa[get(a[i].x)] = get(a[i].y);
		else a[i].t = 1;
	}
	int tt = 0;
	for (int i = 1; i <= n; ++i)
		if (fa[i] == i) c[i] = ++tt;
	n = tt;
	for (int i = 0; i <= n; ++i) {
		C[i][0] = 1;
		for (int j = 1; j <= i; ++j) C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;
	}
	for (int i = 1; i <= m; ++i) if (a[i].t) d[c[get(a[i].x)]][c[get(a[i].y)]] = 1;
	floyd();
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= n; ++j)
			if (d[i][j] & d[j][i]) return puts("0"), 0;//先判断无解 
	for (int i = 1; i <= m; ++i) {
		if (!a[i].t) continue;
		bool flag = 0;
		int x = get(a[i].x), y = get(a[i].y);
		x = c[x], y = c[y];
		for (int k = 1; k <= n; ++k)
			if (d[x][k] & d[k][y]) {
				flag = 1;
				break;
			}
		if (flag) continue;
		e[x].push_back(y);
		v[y] = 1;
	}
	for (int i = 1; i <= n; ++i) if (!v[i]) e[0].push_back(i);
	dfs(0);
	int ans = 0;
	for (int i = 1; i <= n + 1; ++i) {
		ans += dp[0][i];
		ans %= mod;
	}
	printf("%d", ans);
}
```

---

## 作者：justin_cao (赞：3)

一篇比较详细的题解。

首先按照题目的要求，显然先把所有等于号连起来的点利用并查集缩点。

然后按照这个大小关系将小的点向大的点连边（如果两个有大小关系的点在之前被缩在了一个点里显然无解）。

然后这张图如果有环肯定不合法，因为会出现大小矛盾。

于是这张图一定是一颗森林，建一个虚拟根$0$，从$0$向所有森林中的树的根连边，这样就形成了一颗树。

那么可以发现，题目要求的实际上是一个排列，且一个点在排列中的位置一定要在它的子树内其它点的前面的方案数。

这个考虑dp解决。

最简单的想法是设$f[i]$表示以$i$为根的子树构成一个序列的方案数，但是发现由于两个点之间可以连等于号而在合并的时候等于号中间不能插入其它元素，于是我们还需要加一维。设$f[i][j]$表示以$i$为根的子树形成的序列有$j$个连续段的方案数，其中连续段是指一段由等于号连接（由小于号分隔）的段，举个例子，$a_1<a_2=a_3=a_4<a_5=a_6<a_7$中就有$4$个连续段。

考虑怎么转移。

首先考虑一个问题，假设有一个$j$段的序列和一个$k$段的序列，有多少种方案拼出$l$段序列呢？

开始要注意一点，因为是等号连接一段，所以一段被拼出的序列中不能包含两个或以上来自同一序列的段，于是那$l$段中的某一段只能是：$j$段中的一段，$k$段中的一段，$j$段中的一段$+k$段中的一段。

明确了上面一点之后就简单了。首先将$j$段按顺序放进这$l$个空中，方案数就会是$C_{l}^{j}$。那么剩下还有$l-j$个空只能让$k$段中的$l-j$段来填了，那么剩下的$k-l+j$段要被分进之前放入的那$j$段中，那方案数就是$C_{j}^{k-l+j}$。

综上所述，方案数就会是$C_{l}^{j}\times C_{j}^{k-l+j}$。

然后考虑$dp$转移。首先这个显然是一个树形背包，于是我们要考虑的就是$f[i][j]$与$f[son][k]$怎么对$f[i][l]$做贡献了。一颗子树的根肯定是要放在最前面开一段的，于是我们转移的系数实际上就是$j-1$段和$k$段放入$l-1$段中，于是套用上面得到的公式就可以得到转移式了：

$$

f[i][l]+=f[i][j]\times f[son][k]\times C_{l-1}^{j-1}\times C_{j-1}^{k-l+j}

$$

按照这样做树形背包即可。

复杂度$O(n^3)$。

code：
```cpp
#include<bits/stdc++.h>
#define maxn 105
#define mod 1000000007
using namespace std;
typedef long long ll;
int read()
{
    int x=0,f=1;
    char ch=getchar();
    while(ch-'0'<0||ch-'0'>9){if(ch=='-') f=-1;ch=getchar();}
    while(ch-'0'>=0&&ch-'0'<=9){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int n,m;
struct P{
    int u,v;
    char op;
}a[maxn];
int fa[maxn],id[maxn],cnt;
int find(int x)
{
    return fa[x]==x?x:fa[x]=find(fa[x]);
}
void merge(int x,int y)
{
    int u=find(x),v=find(y);
    fa[u]=v;
}
int head[maxn],nxt[maxn],to[maxn],tot,deg[maxn];
void add(int u,int v)
{
    tot++;
    nxt[tot]=head[u];
    head[u]=tot;
    to[tot]=v;
    deg[v]++;
}
queue<int>q;
bool top_sort()
{
    q.push(0);
    while(q.size())
    {
        int now=q.front();q.pop();
        for(int i=head[now];i;i=nxt[i])
        {
            deg[to[i]]--;
            if(!deg[to[i]])  q.push(to[i]);
        }
    }
    for(int i=0;i<=cnt;i++)
      if(deg[i])  return false;
    return true;
}
int f[maxn][maxn],size[maxn],C[maxn][maxn],g[maxn];
void addx(int &x,int y)
{
    x=(x+y>=mod)?x+y-mod:x+y;
}
void solve(int x)
{
    f[x][1]=size[x]=1;
    for(int i=head[x];i;i=nxt[i])
    {
        solve(to[i]);
        for(int j=1;j<=size[x];j++)
        {
            for(int k=1;k<=size[to[i]];k++)
            {
                int lim=max(k+1,j);
                for(int l=lim;l<=k+j;l++)  addx(g[l],1ll*f[x][j]*f[to[i]][k]%mod*C[l-1][j-1]%mod*C[j-1][k-l+j]%mod);
            }
        }
        size[x]+=size[to[i]];
        for(int j=1;j<=size[x];j++)  f[x][j]=g[j],g[j]=0;
    }
}
int main()
{
    n=read();m=read();
    for(int i=1;i<=m;i++)  a[i].u=read(),a[i].op=getchar(),a[i].v=read();
    C[0][0]=1;
    for(int i=1;i<=n;i++)
    {
        C[i][0]=1;
        for(int j=1;j<=i;j++)  C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;
    }
    for(int i=1;i<=n;i++)  fa[i]=i;
    for(int i=1;i<=m;i++)
      if(a[i].op=='=')  merge(a[i].u,a[i].v);
    for(int i=1;i<=n;i++)
      if(fa[i]==i)  id[i]=++cnt;
    for(int i=1;i<=m;i++)
    {
        if(a[i].op=='=')  continue;
        int u=id[find(a[i].u)],v=id[find(a[i].v)];
        if(u==v)
        {
            puts("0");
            return 0;
        }
        if(a[i].op=='<')  add(u,v);
        else              add(v,u);
    }
    for(int i=1;i<=cnt;i++)
      if(!deg[i])  add(0,i);
    if(!top_sort())
    {
        puts("0");
        return 0;
    }
    solve(0);
    int ans=0;
    for(int i=1;i<=cnt+1;i++)  addx(ans,f[0][i]);
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：WilliamFranklin (赞：1)

Update: 第一个式子的 $f_{u, j}$ 已改为 $f_{u, i}$。

### - Solution

先将所有 $a = b$ 用并查集合并成一个点，然后对于每一个条 $a < b$ 的形式连边 $a \rightarrow b$。因为题目保证对于每一个 $b$ 最多有一个 $a$，所以最终的图像为一个有向树森林。为了方便，我们再建一个新点 $0$，连向所有树的根。

下面就是树形 dp 了。

想到树形 dp 第一步重点不是设状态，而是一个点当前信息与当前儿子节点的信息合并需要什么。

我们发现有一个必要的是两个关系串合并就是将两个关系串分别分成若干段，然后有序地合并。而且任意一段都是连续 $=$ 的才会发现合并时不重不漏，因为这个是最小单位。所以我们设 $f_{i, j}$ 表示将 $i$ 的子树内的关系串分为 $j$ 段（及一共有 $j - 1$ 个 $<$，且每一段内都是 $=$ 连接）的方案数。然后考虑合并。对于当前 $u$ 的信息我们设为 $f_u'$，最终合并的信息为 $f_u$，当前的儿子节点 $v$ 的信息为 $f_v$，那么转移方程为：

$$
f_{u, i} = \sum{f_{u, j}' \times f_{v, k} \times \square}
$$

问题就在于这个 $\square$ 是啥。

设 $f_u$ 的关系串为 $X$，$f_u'$ 的关系串为 $Y$，$f_v$ 的关系串为 $Z$，$Y$ 的 $j$ 个段要与 $Z$ 的 $k$ 个段合并成 $X$ 的 $i$ 个段。

考虑 $Y$ 和 $Z$ 合并只不过就是 $Y$ 一个段单独成一个新的段，$Z$ 一个段单独成一个新的段，$Y$ 和 $Z$ 各一个段拼成一个新的段。

首先因为 $X$ 与 $Y$ 的第一个段一定是 $u$ 自己，那么参与合并的就只有 $X$ 的 $i - 1$ 个段空位和 $Y$ 的 $j - 1$ 个段。然后我们会先再 $X$ 这 $i - 1$ 个段空位中选择 $j - 1$ 个位置放下 $Y$ 的这 $j - 1$ 个段，方案数为 $\binom{i - 1}{j - 1}$，然后再看 $Z$，我们肯定会从中选出 $k - (i - j)$ 个段来贴补剩下的空位的，但是我们发现直接先乘上从 $k$ 个段中选出 $k - (i - j)$ 个段的方案数是不对的，因为我们还要保证剩下的段成次序且与选出的 $k - (i - j)$ 个段成次序的与 $Y$ 中的段合并。所以我们可以先从这 $j - 1$ 个 $Y$ 的段中选出 $k - (i - j)$ 个段表示要和 $Z$ 中的某些段合并，然后我们就可以将 $Z$ 中的段按照次序放入 $X$ 中了，那么得出 $\square = \binom{i - 1}{j - 1} \times \binom{j - 1}{k - i + j}$。

最终的转移方程：

$$
f_{u, i} = \sum{f_{u, j}' \times f_{v, k} \times \binom{i - 1}{j - 1} \times \binom{j - 1}{k - i + j}}
$$

感觉比较妙的是最后 $Z$ 的合并。

时间复杂度 $O(n^4)$，可是根本跑不满，所以跑的贼快。

### - AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define x first
#define y second
#define mp(Tx, Ty) make_pair(Tx, Ty)
#define For(Ti, Ta, Tb) for(auto Ti = (Ta); Ti <= (Tb); Ti++)
#define Dec(Ti, Ta, Tb) for(auto Ti = (Ta); Ti >= (Tb); Ti--)
#define debug(...) fprintf(stderr, __VA_ARGS__)
#define range(Tx) begin(Tx),end(Tx)
const int N = 105, mod = 1e9 + 7;
int fa[N];
int h[N], e[N * 2], ne[N * 2], idx;
int n, m;
long long C[N][N];
long long f[N][N];
vector<pair<int, int> > G;
void add(int a, int b) {
	e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}
int find(int x) {
	if (fa[x] == x) return x;
	fa[x] = find(fa[x]);
	return fa[x];
} 
void U(int x, int y) {
	fa[find(y)] = find(x);
}
int sz[N];
long long temp[N][N];
int dfs(int x) {
	if (sz[x]) {
		cout << 0 << '\n';
		exit(0);
	}
	f[x][1] = 1;
	sz[x] = 1;
	for (int i = h[x]; ~i; i = ne[i]) {
		int v = e[i];
		sz[x] += dfs(v);
		For(i, 1, sz[x]) {
			temp[x][i] = 0;
			For(j, 1, sz[x] - sz[v]) {
				For(k, i - j, sz[v]) {
					temp[x][i] = (temp[x][i] + f[x][j] * f[v][k] % mod * C[i - 1][j - 1] % mod * C[j - 1][k - i + j] % mod) % mod;
				}
			}
		}
		For(i, 1, sz[x]) f[x][i] = temp[x][i];
	}
//	cout << x << ' ' << sz[x] << ": " << '\n';
//	For(i, 1, sz[x]) {
//		cout << f[x][i] << ' ';
//	}
//	cout << '\n';
	return sz[x];
}
int main() {
	cin.tie(nullptr)->sync_with_stdio(false);
	memset(h, -1, sizeof(h));
	C[0][0] = 1;
	For(i, 1, N - 1) {
		C[i][0] = 1;
		For(j, 1, i) {
			C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;
		}
	}
	cin >> n >> m;
	For(i, 1, n) fa[i] = i;
	For(i, 1, m) {
		int a, b;
		char op;
		cin >> a >> op >> b;
		if (op == '=') U(a, b);
		else G.push_back(mp(a, b));
	}
	for (auto i : G) add(find(i.x), find(i.y));
	for (auto i : G) U(find(i.x), find(i.y));
	For(i, 1, n) fa[i] = find(i);
	sort(fa + 1, fa + n + 1);
	For(i, 1, n) if (fa[i] != fa[i - 1]) add(0, fa[i]);
	dfs(0);
	long long ans = 0;
	For(i, 1, n + 1) ans = (ans + f[0][i]) % mod;
	cout << ans;
	return 0;
} 
```

---

## 作者：iamzq (赞：1)

### 此为一个补充性质的题解（因为后面部分与上面所有题解相同）。这篇题解主要讲如果不会组合数学 $ORZ$ 怎么求（使用dp）。

注：$ORZ$ 为将 $i$ 段和 $j$ 合并成 $k$ 段的方案数（详见第一篇题解）。

设 $g_{i,j,k,0/1/2}$ 表示 $i$ 段和 $j$ 段合并成 $k$ 段，结尾是来自第一条中的/第二条中的/两条都有（中间用 $=$ 连接）的方案数。

对于 $0$ 和 $1$ 来说，最后一段前面只能用 $<$ 连接，转移方程显而易见。

对于 $2$ 来说，由于 $=$ 两边交换顺序只算一种，所以规定等号右边是来自第二条的。

$$g_{i,j,k,2}=g_{i-1,j,k,1}$$

考虑一下循环顺序就解决了。

部分代码：

```cpp
void ginit()
{
    for (int i=1; i<=n; i++) g[i][0][i][0]=g[0][i][i][1]=1; 
    for (int ipj=2; ipj<=n; ipj++)
        for (int i=1; i<ipj; i++)
        {
            int j=ipj-i;
            for (int k=1; k<=ipj; k++)
            {
                g[i][j][k][0]=(1ll*g[i-1][j][k-1][0]+g[i-1][j][k-1][1]+g[i-1][j][k-1][2])%ljc;
                g[i][j][k][1]=(1ll*g[i][j-1][k-1][0]+g[i][j-1][k-1][1]+g[i][j-1][k-1][2])%ljc;
                g[i][j][k][2]=g[i-1][j][k][1];
            }
        }
}
```

最终 $ORZ=g_{i,j,k,0}+g_{i,j,k,1}+g_{i,j,k,2}$，时间复杂度 $O(N^3)$。

~~可能有点蠢，能过就行:)~~

---

## 作者：zzw4257 (赞：1)

### 题意

>考虑给出些限制关系形如$a<b$或$a=b$并且使得对于任意一个$y$最多一个$x$存在要求$x<y$求所有点的大小合法情况(相等的位置交换算一种

### Solution

首先对于这些限制:

- $a=b$是合并两个点
- $a<b$是有向边具有传递性

再考虑特殊要求实际上告诉我们建出来的图是一个森林

考虑虚点把森林转树后树形$dp$,这种树上定序的过程很类似于[$\mathtt{BSOJ2927}$](https://oj.bashu.com.cn/code/problempage.php?problem_id=2927)

首先我们要设状态，好像直接用一维$f_x$表示$x$子树序列方案就可以用$\mathtt{size}$转移了

但实际上因为存在等号连成的连续块，是不能插在中间的(或者说叫插中间无序的)因此考虑加入一维$i$表示这些连续块个数

$\displaystyle f_{x,i}=\sum_{y,j,k}f'_{x,j}f_{y,k}g_{i,j,k}$

我们考虑来求这个转移系数$g_{i,j,k}$

设$f_{x}$对应$A$序列,$f'_{x}$对应$B$,$f_{y}$对应$C$

$A$中第一段是$x$,其余段是$B$中一段/$C$中一段/各一段拼接

因此首先在后面$i-1$段中选出$B$插进来$j-1$段$\binom{i-1}{j-1}$,然后再把$C$中$i-j$个去填$A$中空的段这里方案被固定在后面还需用$C$中剩余$k-i+j$个去与$B$的$j-1$个拼接$\binom{j-1}{k-i+j}$，因此$g_{i,j,k}=\binom{i-1}{j-1}\binom{j-1}{k-i+j}$

发现这是一种类似背包的转移用上$\mathtt{size}$优化复杂度为$O(n^3)$

```cpp
#include<stdio.h>
#include<vector>
#define re register
#define N 105
#define mod 1000000007
int n,m,fa[N],size[N],C[N][N],f[N][N],prt[N],tmp[N],ans;
char flag,vis[N];
inline int getf(re int x){return x==prt[x]?x:prt[x]=getf(prt[x]);}
std::vector<int>*g;
inline int Mod(re int x){return x>=mod?x-mod:x;}
inline void dfs(re int x){
	re int i,j,k,l,y;if(size[x]==1)return flag=1,void();
	f[x][1]=size[x]=1;
	for(l=g[x].size()-1;~l;--l){
		dfs(y=g[x][l]);if(flag)return;
		for(j=1;j<=size[x];++j)if(f[x][j])
			for(k=1;k<=size[y];++k)if(f[y][k]){
				for(i=j>k?j:k;i<=j+k;++i)tmp[i]=(tmp[i]+1ll*f[x][j]*f[y][k]%mod*C[i-1][j-1]%mod*C[j-1][k+j-i])%mod;
			}
		size[x]+=size[y];
		for(i=1;i<=size[x];++i)f[x][i]=tmp[i],tmp[i]=0;
	}
}
int main(void){
	re std::vector<int>gg[N];g=gg;
	re int i,j,x,y;re char opt[3];scanf("%d%d",&n,&m);
	for(i=0;i<=n+1;++i)prt[i]=i,C[i][i]=C[i][0]=1;
	for(i=1;i<=n+1;++i)for(j=1;j<i;++j)C[i][j]=Mod(C[i-1][j-1]+C[i-1][j]);
	while(m--)scanf("%d%s%d",&x,opt,&y),x=getf(x),y=getf(y),(*opt=='=')?prt[x]=y:fa[y]=x;
	for(i=1;i<=n;++i){
		x=getf(i);if(!fa[x])fa[x]=fa[i];fa[x]=getf(fa[x]);
		if(x==fa[x])return puts("0"),0;
		if(!vis[x])g[fa[x]].push_back(x),vis[x]=1;
	}
	dfs(0);if(flag||!g[0].size())return puts("0"),0;
	for(i=1;i<=size[0];++i)ans=Mod(ans+f[0][i]);
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Tgotp (赞：1)

题意描述里有一句：“对每张图片 i，小 D 都最多只记住了某一张质量不比 i 差的另一张图片 Ki。”


即只有一个父亲，且m <= n,所以建树，容易想到树形dp，


对于 ”=“ 的，直接用并查集将之看成一个点，


对于“<”的，将小的连一条到大的点的边，


然后不一定是一棵树，可能是森林，所以扫一遍，每次求出答案然后用乘法原理并起来。


令f[x][y]表示以x为根，有y个不同的数的方案，容易想到，对于一个点，他的儿子间可以随便组合，


但是儿子肯定不能更改与父亲的关系。


即 t[i] =  ∑f[x][q] \* f[to[i]][p]\* C(p - (e - q),q - 1)\* C(q - 1,e - 1)) ;


另外，如果树上有环，直接返还 0；


[蒟蒻代码](http://tgotp.science/4013-hnoi2015%E5%AE%9E%E9%AA%8C%E6%AF%94%E8%BE%83/)


---

## 作者：liugh_ (赞：0)

## [[HNOI2015] 实验比较](https://www.luogu.com.cn/problem/P3240)

> 给定 $n$ 个变量和 $\le m$ 个具有传递性的偏序关系（形如 $x_i<y_i$；$x_i=y_i$ 的情况可以将它们视作一个点），求将 $n$ 个变量用 $<$ 或 $=$ 间隔并满足这 $m$ 个关系的排列数。保证所有 $y_i$ 互不相同。
>
> $m\le n\le 100$。

由所有 $y_i$ 互不相同可知，这些偏序关系构成一颗森林的形状。于是问题转化为**类似**求树的 topo 序，考虑建超级根以树形 dp，有一道非常像的题：[[HEOI2013] SAO](https://www.luogu.com.cn/problem/P4099)。复制粘贴一通乱改发现并不能直接那样做，因为有两个不同点。首先，本题中只有 $<$ 没有 $>$，点 $u$ 在其子树内的 topo 序一定是第一个，故我们并不需要记录点 $u$ 的 topo 序。但能直接设 $f(u)$ 为点 $u$ 子树内的方案数吗？尝试后发现并不行，因为**本题中存在 $=$ 的限制**。

$<$ 和 $=$ 的数量是不确定的，我们最好把 $=$ 加进状态里去。可我们转移的重点在于偏序关系啊，记录 $=$ 好像转移并不明显；注意到 $<$ 和 $=$ 是相对的，记录 $<$ 与记录 $=$ 是等价的。于是，我们可以设 $f(u,i)$ 为点 $u$ 子树内答案序列中有 $i-1$ 个 $<$ 把序列分成了 $i$ 部分，其中第 $1$ 部分一定只有 $u$。

考虑转移。对于边 $(u,v)$，$f(u,k)$ 要从 $f(u,i)$ 和 $f(v,j)$ 转移过来，首先，$u$ 的段数一定不会减少，即 $i\le k\le siz_u+siz_v$，而我们要把原来 $u$ 的 $i$ 段放进现在 $u$ 的 $k$ 段中，注意第一段一定是 $u$ 不会变，所以方案数是
$$\binom{k-1}{i-1}$$
接着，我们把 $v$ 的序列放进现在 $u$ 的序列中，首先一定得把刚才 $u$ 没放完的 $k-i$ 个空位补全，然后 $v$ 的序列剩下了 $j-(k-i)$ 个部分，这些部分还得插入到原来 $u$ 的**可以被插入的 $i-1$ 个部分**中，而不能插入到 $v$ 的用来补全的部分中。因此，对于这些剩下的部分，方案数为
$$\binom{i-1}{j-(k-i)}$$
而对于每一个确定的剩下部分的排列方案，用来补全的部分的方案是唯一确定的（要满足在 $v$ 序列中的顺序），所以这部分的贡献为 $1$。于是，我们有最终的转移
$$f(u,k)=f(u,i)\cdot f(v,j)\cdot \binom{k-1}{i-1}\cdot \binom{i-1}{j-(k-i)}$$
最后，有两个要注意的地方。首先，注意判断数据中的偏序关系是否已经不合法，此处我用并查集实现。其次，不要忘记孤立点，这些点是自由的，可以直接算方案数，也可以将其连到超级根并在树形 dp 中一同求出，此处我采用后者的实现。

```cpp
#include<iostream>
#include<algorithm>
#include<cassert>
#include<list>
#include<bitset>
#ifdef ONLINE_JUDGE
#define getchar() (_p==_q&&(_q=(_p=_b)+fread(_b,1,_s,stdin),_p==_q)?-1:*_p++)
#define putchar(x) ((_r-_o<_s)?(*_r++=x):(flush(),_r=_o,*_r++=x))
#endif
#define inline inline __attribute__((__always_inline__))
#define flush() fwrite(_o,_r-_o,1,stdout),fflush(stdout)
using namespace std;const int _s=1<<20;char _b[_s],_o[_s],*_p=_b,*_q=_b,*_r=_o;template<class T>inline bool fr(T&x){x=0;char c=0;bool f=0;do{if((c=getchar())==-1)return 0;if(c=='-')f=1;}while(c<48||c>57);do {x=x*10+c-48;if((c=getchar())==-1)break;}while(c>47&&c<58);if(f)x=-x;return 1;}template<class T>inline void fw(T x){char _d[40],_l=-1;if(x<0)x=-x,putchar('-');do _d[++_l]=x%10+48;while(x/=10);do putchar(_d[_l]);while(~--_l);}

constexpr int maxn=200+5,mod=1e9+7;

int n,m,rt;
bitset<maxn> fa;
int cnt[maxn];

struct _eg{int to,pre;}eg[maxn];int ei=1,eh[maxn];
inline void ea(int u,int v){eg[++ei]={v,eh[u]};eh[u]=ei;}

struct _ln{int u;char c;int v;}ln[maxn];

struct _uni{
    int bel[maxn];int &operator [] (int x){return bel[x];}
    int get(int x){return x==bel[x]?bel[x]:bel[x]=get(bel[x]);}
}uni1,uni2;

int fac[maxn];
inline void calfac(int V){fac[0]=1;for(int i=1;i<=V;i++)fac[i]=1ll*fac[i-1]*i%mod;}

int C[maxn][maxn];
#define C(a,b) C[a][b]
inline void calcom(int V){
    C(0,0)=1;
    for(int i=1;C(i,0)=1,i<=V;i++)
        for(int j=1;j<=i;j++)
            C(i,j)=(C(i-1,j)+C(i-1,j-1))%mod;
}

inline void over(){fw(0),exit((flush(),0));}

int siz[maxn];
int f[maxn][maxn];
#define f(a,b) f[a][b]
void dfs(int u){
    siz[u]=1;
    f(u,1)=1;
    for(int e=eh[u];e;e=eg[e].pre){
        int v=eg[e].to;
        dfs(v);
        static int g[maxn];copy(f[u],f[u]+siz[u]+1,g);fill(f[u],f[u]+siz[u]+1,0);
        for(int i=1;i<=siz[u];i++){
            for(int j=1;j<=siz[v];j++){
                for(int k=i;k<=siz[u]+siz[v];k++){
                    f(u,k)=(f(u,k)+1ll*g[i]*f(v,j)%mod*C(k-1,i-1)%mod*C(i-1,j-(k-i))%mod)%mod;
                }
            }
        }
        siz[u]+=siz[v];
    }
}

signed main(){
    // ios::sync_with_stdio(0),cin.tie(0),cout.tie(0),cerr.tie(0);
    // freopen("2.in","r",stdin);
    // freopen("2.out","w",stdout);
    
    fr(n),fr(m),rt=n+1;
    calcom(rt),calfac(rt);
    for(int i=1;i<=n;i++)uni1[i]=i;
    for(int i=1;i<=n;i++)uni2[i]=i;
    for(int i=1;i<=m;i++){
        auto &[u,c,v]=ln[i];
        fr(u);do{}while(isspace(c=getchar()));fr(v);
        if(c=='=')uni1[uni1.get(u)]=uni1.get(v);
    }
    for(int i=1;i<=m;i++){
        auto [u,c,v]=ln[i];
        if(c=='<'){
            if(uni2.get(u)==uni2.get(v))over();
            uni2[uni2[u]]=uni2[v];
            ea(uni1.get(u),uni1.get(v)),fa[uni1[v]]=1;
        }
    }
    for(int i=1;i<=n;i++){
        cnt[uni1.get(i)]++;
        if(uni1[i]!=i)cnt[i]=-1;
    }
    for(int i=1;i<=n;i++)if(cnt[i]!=-1&&!fa[i])ea(rt,i),fa[i]=rt;
    dfs(rt);
    int ans=0;
    for(int i=1;i<=siz[rt];i++)ans=(ans+f(rt,i))%mod;
    fw(ans);
    exit((flush(),0));
}
```

---


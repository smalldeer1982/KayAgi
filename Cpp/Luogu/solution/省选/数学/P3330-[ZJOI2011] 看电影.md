# [ZJOI2011] 看电影

## 题目描述

到了难得的假期，小白班上组织大家去看电影。但由于假期里看电影的人太多，很难做到让全班看上同一场电影。最后大家在一个偏僻的小胡同里找到了一家电影院，但这家电影院分配座位的方式很特殊，具体方式如下：

电影院的座位共有 $K$ 个，并被标号为 $1 \sim K$。每个人买完票后会被随机指定一个座位，具体来说是从 $1 \sim K$ 中等概率随机选取一个正整数，设其为 $L$。

如果编号 $L$ 的座位是空位，则这个座位就分配给此人，否则将 $L$ 加一，继续前面的步骤；如果不存在编号 $L$ 的座位，则该人只能站着看电影，即所谓的站票。

小白班上共有 $N$ 人（包括小白自己），作为数学爱好者，小白想知道全班都能够有座位的概率是多少。


## 说明/提示

对于 $100 \%$ 的数据，$1 \leq T \leq 50$，$1 \leq N,K \leq 200$。

## 样例 #1

### 输入

```
3
1 1
2 1
2 2```

### 输出

```
1 1
0 1
3 4
```

# 题解

## 作者：SoyTony (赞：21)

[题目传送门](https://www.luogu.com.cn/problem/P3330)

[前排广告](https://www.luogu.com.cn/blog/Tony-ZhuJialiang/)

~~省流~~：
$$\operatorname{ans}=\dfrac{(k+1)^{n-1}(k+1-n)}{k^n}$$
说说我自己这个式子的理解吧。

首先，如果人数多于座位数，即 $n>k$，是绝对无法达成“都有座位”的，直接特判输出。

接着，一个事件的概率=符合条件的情况数/总情况数，那么这个总情况数是非常好考虑的，$n$ 个人等概率的从 $[1,k]$ 中选取一个，情况数自然是 $k^n$。

然后来看符合条件的情况数，注意到题目中提到“如果当前位置已经有人则向下一个位置以此类推”，而我们并不确定开始选择的位置究竟是什么，不如添加一个 $k+1$ 号椅子并连成一个环，排除其他条件不谈，这 $(k+1)$ 个椅子的情况数为 $(k+1)^n$，然而是存在重复情况的。例如 ${1,3,2,4}$ 与 ${2,4,1,3}$ 分别首尾相连成环以后，都是形如 ${1,3,2,4,(1})$ 的，也就是说这两种情况是等价的。而成环的连接点有 $(k+1)$ 个，去重后就有 $(k+1)^{n-1}$ 种情况。

接下来是个人认为最难的地方了，这个 $(k+1-n)$ 是怎么得来的？为什么要连成一个环？

因为这里考虑的是符合条件“都有座位”的情况数，那么就要保证成功，方法是尽可能让每个人向右找座位的容错更高，但显然这个开始点是不确定的，我们连成一个环后，对于每个情况单独考虑，所有没有坐人的地方都可以删去并断开成正常的序列。因此选 $n$ 个座位后剩下的是 $k+1-n$ 个座位，也就是可以断成 $k+1-n$ 种不同的序列。

对上述解释一句话概括：连成环后忽略编号，哪里为空断开哪里，哪里就是 $k+1$ 把椅子。

然而需要一个高精度，因为式子中 $(k+1)^{n-1}$ 与 $k^n$ 是无法化简，只要看 $n+1-k$ 和 $k^n$ 就可以了，这里会发现，前一个数字是个低精度，而高精取模低精后是低精度，所以麻烦的高精 $\gcd$ 其实可以拆分成一次高精取模低精和低精 $\gcd$ 就可以了。

其他的看代码就能理解了。

```cpp
int t;
struct largenum{
    int num[10005];
    inline void scan(){
        char s[10005];
        scanf("%s",s+1);
        int len=strlen(s+1);
        for(int i=len;i>=1;i-=4){
            int j=max(i-3,1);
            int sum=0;
            while(j<=i){
                sum=sum*10+(s[j++]-'0');
            }
            num[++num[0]]=sum;
        }
    }
    inline void print(){
        printf("%d",num[num[0]]);
        for(int i=num[0]-1;i>=1;i--){
            printf("%04d",num[i]);
        }
        printf(" ");
    }
    largenum operator *(const largenum &tmp)const{
        largenum res;
        memset(res.num,0,sizeof(res.num));
        res.num[0]=num[0]+tmp.num[0];
        for(int i=1;i<=num[0];i++){
            for(int j=1;j<=tmp.num[0];j++){
                res.num[i+j-1]+=num[i]*tmp.num[j];
                res.num[i+j]+=res.num[i+j-1]/base;
                res.num[i+j-1]%=base;
            }
        }
        while(res.num[res.num[0]]) res.num[0]++;
        while(!res.num[res.num[0]]&&res.num[0]>1) res.num[0]--;
        return res;
    }
    largenum operator *(const int &tmp)const{
        largenum res;
        memset(res.num,0,sizeof(res.num));
        res.num[0]=num[0];
        int laz=0;
        for(int i=1;i<=res.num[0];i++){
            res.num[i]=num[i]*tmp+laz;
            laz=res.num[i]/base;
            res.num[i]=res.num[i]%base;
        }
        while(laz){
            res.num[++res.num[0]]=laz%base;
            laz/=base;
        }
        while(res.num[res.num[0]]) res.num[0]++;
        while(!res.num[res.num[0]]&&res.num[0]>1) res.num[0]--;
        return res;
    }
    int operator %(const int &tmp)const{
        int res=0;
        for(int i=num[0];i>=1;i--){
            res=(res*base+num[i])%tmp;
        }
        return res;
    }
    largenum operator /(const int &tmp)const{
        largenum res;
        memset(res.num,0,sizeof(res.num));
        res.num[0]=num[0];
        ll laz=0;
        for(int i=res.num[0];i>=1;i--){
            res.num[i]=(laz*base+num[i])/tmp;
            laz=(laz*base+num[i])%tmp;
        }
        while(!res.num[res.num[0]]&&res.num[0]>1) res.num[0]--;
        return res;
    }
}ans1,ans2,tmp;
inline largenum q_pow(largenum x,int p){
    largenum res;
    memset(res.num,0,sizeof(res.num));
    res.num[0]=res.num[1]=1;
    while(p){
        if(p&1){
            res=res*x;
        }
        x=x*x;
        p>>=1;
    }
    return res;
}
inline int gcd(int a,int b){
    if(!b) return a;
    return gcd(b,a%b);
}
int n,k,m;
int main(){
    t=read();
    while(t--){
        n=read(),k=read();
        m=k+1-n;
        if(n>k){
            printf("0 1\n");
            continue;
        }
        memset(ans1.num,0,sizeof(ans1.num));
        memset(ans2.num,0,sizeof(ans2.num));
        ans1.num[0]=ans2.num[0]=1;
        ans1.num[1]=k+1,ans2.num[1]=k;
        ans1=q_pow(ans1,n-1);
        ans2=q_pow(ans2,n);
        ans1=ans1*m;
        //ans1.print();
        //ans2.print();
        tmp=ans2;
        int g=tmp%m;
        //printf("\n%d\n",g);
        g=gcd(m,g);
        //printf("%d\n",g);
        ans1=ans1/g;
        //printf("%d\n",m);
        ans1.print();
        ans2=ans2/g;
        ans2.print();
        printf("\n");
    }
    return 0;
}

```

---

## 作者：一只书虫仔 (赞：21)

[P3330 [ZJOI2011]看电影](https://www.luogu.com.cn/problem/P3330)

### Description

给定 $n$ 个人和 $k$ 个座位，从 $k$ 个座位等概率的选择出第 $l$ 个座位，对于每个人进行下面的操作：

- 如果 $l$ 座位上没有人就在 $l$ 座位上坐下
- 如果有了就把 $l++$ 重复操作一
- 如果 $l=n$ 都没坐到座位上就是站票

求全班都坐下的概率。

### Solution

典型的古典概型

- 合理方案数把所有座位连成环就可以了，应该是 $(k+1)^{n-1}\times(k-n+1)$
- 所有方案数这应该很无脑吧 …… $k^n$

$$\text{ans}=\dfrac{(k+1)^{n-1}\times(k-n+1)}{k^n}$$

然后就可以得到代码啦 ~

### Code 1

```cpp
#include <bits/stdc++.h>

using namespace std;

long long binpow (long long b, long long p, long long k) {
	b %= k;
	long long res = 1;
	while (p > 0) {
		if (p & 1)
			res = res * b % k;
		b = b * b % k;
		p >>= 1;
	}
	return res;
}

int gcd (int a, int b) {return b == 0 ? a : gcd(b, a % b);}

int main () {
	int T;
	scanf("%d", &T);
	while (T--) {
		int n, k;
		scanf("%d%d", &n, &k);
		int ans1 = binpow(k + 1, n - 1, 0x3f3f3f3f) * (k - n + 1);
		int ans2 = binpow(k, n, 0x3f3f3f3f);
		int _gcd = gcd(ans1, ans2);
		ans1 /= _gcd, ans2 /= _gcd;
		printf("%d %d\n", ans1, ans2);
	}
	return 0;
}

```

期望得分：$10$ 分   
[Link](https://www.luogu.com.cn/record/34315379)

加 ll 没用，只有 $20$ 分（

### Solution Addition

Why？我们带着数据往里面算

分子：$2.1677811057188525650385281027847e+458$   
分母：$1.6069380442589902755419620923412e+460$

这两个数都是 $450$ 多位的啊 ……   
不用高精不行啊 ……

所以这题需要高精 ……

高精法一：用 C++          
就是最后处理 $\gcd$ 的时候会麻烦亿点

高精法二：用 python        

这里打一个 python 的 /cy

```python
import fractions
import math

t = int(input())

for i in range(t):
    a, b = map(int, input().split())
    c = ((b + 1) ** (a - 1)) * (b - a + 1)
    d = b ** a
    e = math.gcd(c, d)
    print(c // e, d // e)
```

但是你发现你只有 $90$ 分，这是为啥呢？

因为我们要特判 $n > k$ 的情况！

```python
import fractions
import math
t = int(input())
for i in range(t):
    a, b = map(int, input().split())
    if a > b:
        print(0, 1)
    else:
        c = ((b + 1) ** (a - 1)) * (b - a + 1)
        d = b ** a
        e = math.gcd(c, d)
        print(c // e, d // e)
```

然后你就可以 A 了。

[AC Link](https://www.luogu.com.cn/record/35795650)

---

参考资料：

Z-Y-Y-S 巨佬的 [Blog](https://www.cnblogs.com/Y-E-T-I/p/7109975.html)

---

## 作者：Brioche (赞：14)

### [[ZJOI2011]看电影](https://www.luogu.org/problemnew/show/P3330)

这题模型转化很巧妙.(神仙题)

对于这种题首先肯定知道答案就是合法方案除以总方案.

总方案显然是$k^n$.

那么考虑怎么算合法方案.

当$n>k$的时候显然答案为0.

否则,我们不妨虚构出来一个从最后一个座位到第一个座位传送门,如果一个人他走到最后一个座位还没有空位置的话,他本来应该要是站着的,但是现在有了传送门,他就可以走到第一个座位,再一路走看看有没有空座位,找个位置坐下,由于这样构成了一个环,座位的个数一定是够坐的.这样每个人都有座位了.

我们现在要求的就是**没有人穿过传送门**的方案总数.考虑上面这样处理不好算.不妨再虚构一个座位,它的编号为$k+1$,现在如果有人走到n没有座位,就会先坐在$n+1$,那么一个不合法方案当且仅当$k+1$位置被人坐了,一个合法方案当且仅当$k+1$位置没有人坐.

这样的圆排列一共有$\frac{(k+1)^n}{k+1}=(k+1)^{n-1}$(n个人,每个人可以选择$k+1$个座位中的一个坐下,有人就按照规则往后坐就可以了,反正可以坐下),只有$k-n+1$个位置是空的,我们可以选择从这些位置断环成链,并把这些位置当做$k+1$号座位.

于是答案就是

$$
\frac{(k+1)^{n-1}(k-n+1)}{k^n}
$$

数据范围这么小是因为要高精...

处理gcd的时候注意$k+1$和$k$是没有公因子的,只要考虑$k-n+1$和$k^n$的gcd.

只要高精乘法,快速幂一下就可以了.


### [代码](https://www.cnblogs.com/terribleterrible/p/9912207.html)

---

## 作者：JJA_ (赞：12)

### 题目大意

输入一个整数 $T$ ，接下来 $T$ 行分别输入 $N, K$ 。接下来 $l$ 取一个小于 $K$ 的数，如果这个数是空位，就坐在这，否则就 `l++`。问最后所有人都有座位的概率。

---
很显然，概率=所有人都坐下的方案数 $\div$ 总方案数。~~别告诉我你没学过~~

总方案数很显然，为 $k^n$ ，所以主要的问题就出在如何计算分子。

现在，假如所有的椅子全围成一个圆，这样的话所有人就能坐下。那么现在肯定所有人都能坐下了。所以得出结论：

$$(k+1)^{n-1}\times(k-n+1)$$

那么概率（之后就用 $ans$ 表示） $ans=\dfrac{(k+1)^{n-1}\times(k-n+1)}{k^n}$ 。

第二步，是要约分。于是我们打出一个`gcd`代码：
```cpp
int gcd(int a,int b)
{
	if(a==b)
	return a;
	int c;
	if(a>b)
	swap(a,b);
	c=a%b;
	while(a%b!=0)
	{
		c=a%b;
		a=b;
		b=c;
	}
	return c;
}
```
这里我用了辗转相除法。

最后就是源代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int gcd(int a,int b)
{
	if(a==b)
	return a;
	int c;
	if(a>b)
	swap(a,b);
	c=a%b;
	while(a%b!=0)
	{
		c=a%b;
		a=b;
		b=c;
	}
	return c;
}
void solve(int n,int k)
{
	int ans1=pow(k+1,n-1)*(k-n+1);
	int ans2=pow(k,n);
	cout<<ans1/gcd(n,k)<<" "<<ans2/gcd(n,k)<<endl;
}
signed main()
{
	int n,k,T;
	cin>>T;
	while(T--)
	{
		cin>>n>>k;
		solve(n,k);
	}
}
```
但是我们绝望地发现只得了20pts。那就往里面输入几个数，最大的是 `200,200`，输出是
`-46116860184273879 -46116860184273879`，明显爆ll了。

所以，我们~~卑微地~~用高精吧。

高精的加减乘除不用说，都有板子。这里是我的：
```cpp
#define maxn 1000001
using namespace std;
long long a[maxn], b[maxn],res[maxn];
string sub(string s1, string s2)
{
    int n = s1.length(), m = s2.length();
    for (int i = 0; i < n; i ++) a[i] = s1[n-1-i] - '0';
    for (int i = 0; i < m; i ++) b[i] = s2[m-1-i] - '0';
    int len = max(n, m);
    for (int i = n; i < len; i ++) a[i] = 0;
    for (int i = m; i < len; i ++) b[i] = 0;
    for (int i = 0; i < len; i ++) res[i] = 0;
    for (int i = 0; i < len; i ++) {
        res[i] += a[i] - b[i];
        if (res[i] < 0) {
            res[i+1] --;
            res[i] += 10;
        }
    }
    int i = len-1;
    while (res[i] == 0 && i > 0) i --;
    string s = "";
    for (; i >= 0; i --) {
        char c = (char) (res[i] + '0');
        s += c;
    }
    return s;
}
string add(string s1, string s2)
{
    int n = s1.length(), m = s2.length();
    for (int i = 0; i < n; i ++) a[i] = s1[n-1-i] - '0';
    for (int i = 0; i < m; i ++) b[i] = s2[m-1-i] - '0';
    int len = max(n, m) + 1;
    for (int i = n; i < len; i ++) a[i] = 0;
    for (int i = m; i < len; i ++) b[i] = 0;
    for (int i = 0; i < len; i ++) res[i] = 0;
    for (int i = 0; i < len; i ++)
	{
        res[i] += a[i] + b[i];
        if (res[i] >= 10)
		{
            res[i+1] += res[i] / 10;
            res[i] %= 10;
        }
    }
    int i = len-1;
    while (res[i] == 0 && i > 0) i --;
    string s = "";
    for (; i >= 0; i --)
	{
        char c = (char) (res[i] + '0');
        s += c;
    }
    return s;
}
bool cmp(string s1, string s2)
{
    int n = s1.length(), m = s2.length();
    int i;
    for (i = 0; i < n-1 && s1[i] == '0'; i ++);
    s1 = s1.substr(i);
    for (i = 0; i < m-1 && s2[i] == '0'; i ++);
    s2 = s2.substr(i);
    if (s1.length() != s2.length()) return s1.length() < s2.length();
    return s1 < s2;
}

string div(string s1, string s2)
{
    string s = "", t = "";
    int n = s1.length(), m = s2.length();
    bool flag = false;
    for (int i = 0; i < n; i ++)
	{
        s += s1[i];
        int num = 0;
        while (cmp(s, s2) == false)
		{
            num ++;
            s = sub(s, s2);
        }
        if (num > 0)
		{
            flag = true;
            char c = (char)(num + '0');
            t += c;
        }
        else if (flag)
		{
            t += '0';
        }
    }
    if (t.length() == 0) t = "0";
    while (s[0] == '0' && s.length() > 1) s = s.substr(1);
    return t;
}

string mul(string s1, string s2)
{
    int n = s1.length(), m = s2.length();
    for (int i = 0; i < n; i ++) a[i] = s1[n-1-i] - '0';
    for (int i = 0; i < m; i ++) b[i] = s2[m-1-i] - '0';
    int len = n + m;
    for (int i = n; i < len; i ++) a[i] = 0;
    for (int i = m; i < len; i ++) b[i] = 0;
    for (int i = 0; i < len; i ++) res[i] = 0;
    for (int i = 0; i < n; i ++)
        for (int j = 0; j < m; j ++)
            res[i+j] += a[i] * b[j];
    for (int i = 0; i < len; i ++) {
        res[i+1] += res[i] / 10;
        res[i] %= 10;
    }
    int i = len-1;
    while (res[i] == 0 && i > 0) i --;
    string s = "";
    for (; i >= 0; i --) {
        char c = (char) (res[i] + '0');
        s += c;
    }
    return s;
}
```
但是如何计算模/最大公约数呢？

打开童年的纱窗，

$$a\div b=c \dots d$$

那么，

$$b\times c+d=a$$

所以，余数 $d$就是

$$a-b\times c$$

~~如果这个都不知道的话打回小学重修~~

所以，就有`mod`的函数：
```cpp
string mod(string a,string b)
{
	if(cmp(a,b)==-1)
	swap(a,b);
	return sub(a,mul(div(a,b),b));
}
```
~~常数有那么亿点点大~~

那么，gcd的函数用辗转相除法也能做出来：
```cpp
string gcd(string a,string b)
{
	if(a==b)
	return a;
	string str;
	str=mod(a,b);
	while(mod(a,b)!="0")
	{
		str=mod(a,b);
		a=b;
		b=str;
	}
	if(str=="0")
	return "1";
	return str;
}
```
唯一注意，如果`if(str=="0")`，返回 $1$。

而幂运算相信也能写出来，
```cpp
string spow(string n,string k)
{
	string a=n;
	string i="0";
	while(cmp(k,i)==0)
	{
		i=add(i,"1");
		n=mul(n,a);
	}
	return div(div(n,a),a);
}
```
所以总体需要的函数等就都齐全了。之后就是`solve`函数。按照题目要求即可：
```cpp
void solve(string n,string k)
{
	string ans1,ans2;
	ans1=mul(spow(add(k,"1"),sub(n,"1")),sub(k,sub(n,"1")));
	ans2=spow(k,n);
	string gcdd=gcd(ans1,ans2);
	if(gcdd=="1")
	{
		cout<<ans1<<" "<<ans2<<endl;
		return;
	}
	else
	{
		ans1=div(ans1,gcdd);
		ans2=div(ans2,gcdd);
		cout<<ans1<<" "<<ans2<<endl;
		return;
	}
}
```
于是我们再次交上去，发现：第四个点 WA 了。

那只得看看样例，却发现：`2 1`的输出和样例输出不大一样。

所以，推导一下，若 $n>k$，则输出`0 1`就行。所以加一个判断：
```cpp
if(cmp(n,k)==1)
	{
		cout<<0<<" "<<1<<endl;
		continue;
	}
```
即可。

所以最后源代码：
```cpp
#include<bits/stdc++.h>
#define maxn 1000001
using namespace std;
long long a[maxn], b[maxn],res[maxn];
string sub(string s1, string s2)
{
    int n = s1.length(), m = s2.length();
    for (int i = 0; i < n; i ++) a[i] = s1[n-1-i] - '0';
    for (int i = 0; i < m; i ++) b[i] = s2[m-1-i] - '0';
    int len = max(n, m);
    for (int i = n; i < len; i ++) a[i] = 0;
    for (int i = m; i < len; i ++) b[i] = 0;
    for (int i = 0; i < len; i ++) res[i] = 0;
    for (int i = 0; i < len; i ++) {
        res[i] += a[i] - b[i];
        if (res[i] < 0) {
            res[i+1] --;
            res[i] += 10;
        }
    }
    int i = len-1;
    while (res[i] == 0 && i > 0) i --;
    string s = "";
    for (; i >= 0; i --) {
        char c = (char) (res[i] + '0');
        s += c;
    }
    return s;
}
string add(string s1, string s2)
{
    int n = s1.length(), m = s2.length();
    for (int i = 0; i < n; i ++) a[i] = s1[n-1-i] - '0';
    for (int i = 0; i < m; i ++) b[i] = s2[m-1-i] - '0';
    int len = max(n, m) + 1;
    for (int i = n; i < len; i ++) a[i] = 0;
    for (int i = m; i < len; i ++) b[i] = 0;
    for (int i = 0; i < len; i ++) res[i] = 0;
    for (int i = 0; i < len; i ++)
	{
        res[i] += a[i] + b[i];
        if (res[i] >= 10)
		{
            res[i+1] += res[i] / 10;
            res[i] %= 10;
        }
    }
    int i = len-1;
    while (res[i] == 0 && i > 0) i --;
    string s = "";
    for (; i >= 0; i --)
	{
        char c = (char) (res[i] + '0');
        s += c;
    }
    return s;
}
bool cmp(string s1, string s2)
{
    int n = s1.length(), m = s2.length();
    int i;
    for (i = 0; i < n-1 && s1[i] == '0'; i ++);
    s1 = s1.substr(i);
    for (i = 0; i < m-1 && s2[i] == '0'; i ++);
    s2 = s2.substr(i);
    if (s1.length() != s2.length()) return s1.length() < s2.length();
    return s1 < s2;
}

string div(string s1, string s2)
{
    string s = "", t = "";
    int n = s1.length(), m = s2.length();
    bool flag = false;
    for (int i = 0; i < n; i ++)
	{
        s += s1[i];
        int num = 0;
        while (cmp(s, s2) == false)
		{
            num ++;
            s = sub(s, s2);
        }
        if (num > 0)
		{
            flag = true;
            char c = (char)(num + '0');
            t += c;
        }
        else if (flag)
		{
            t += '0';
        }
    }
    if (t.length() == 0) t = "0";
    while (s[0] == '0' && s.length() > 1) s = s.substr(1);
    return t;
}

string mul(string s1, string s2)
{
    int n = s1.length(), m = s2.length();
    for (int i = 0; i < n; i ++) a[i] = s1[n-1-i] - '0';
    for (int i = 0; i < m; i ++) b[i] = s2[m-1-i] - '0';
    int len = n + m;
    for (int i = n; i < len; i ++) a[i] = 0;
    for (int i = m; i < len; i ++) b[i] = 0;
    for (int i = 0; i < len; i ++) res[i] = 0;
    for (int i = 0; i < n; i ++)
        for (int j = 0; j < m; j ++)
            res[i+j] += a[i] * b[j];
    for (int i = 0; i < len; i ++) {
        res[i+1] += res[i] / 10;
        res[i] %= 10;
    }
    int i = len-1;
    while (res[i] == 0 && i > 0) i --;
    string s = "";
    for (; i >= 0; i --) {
        char c = (char) (res[i] + '0');
        s += c;
    }
    return s;
}
string mod(string a,string b)
{
	if(cmp(a,b)==-1)
	swap(a,b);
	return sub(a,mul(div(a,b),b));
}
string gcd(string a,string b)
{
	if(a==b)
	return a;
	string str;
	str=mod(a,b);
	while(mod(a,b)!="0")
	{
		str=mod(a,b);
		a=b;
		b=str;
	}
	if(str=="0")
	return "1";
	return str;
}
string spow(string n,string k)
{
	string a=n;
	string i="0";
	while(cmp(k,i)==0)
	{
		i=add(i,"1");
		n=mul(n,a);
	}
	return div(div(n,a),a);
}
void solve(string n,string k)
{
	string ans1,ans2;
	ans1=mul(spow(add(k,"1"),sub(n,"1")),sub(k,sub(n,"1")));
	ans2=spow(k,n);
	string gcdd=gcd(ans1,ans2);
	if(gcdd=="1")
	{
		cout<<ans1<<" "<<ans2<<endl;
		return;
	}
	else
	{
		ans1=div(ans1,gcdd);
		ans2=div(ans2,gcdd);
		cout<<ans1<<" "<<ans2<<endl;
		return;
	}
}
signed main ()
{
	int T;
	cin>>T;
	while(T--)
	{
		string n,k;
		cin>>n>>k;
		if(cmp(n,k)==1)
		{
			cout<<0<<" "<<1<<endl;
			continue;
		}
		solve(n,k);
	}
}
```
就愉快过了。

---

## 作者：K8He (赞：5)

# 「解题报告」[[ZJOI2011]看电影](https://www.luogu.com.cn/problem/P3330)

这个式子还是蛮有意思的，但要用高精。

首先答案 $=\frac{\text{合法情况数}}{\text{总情况数}}$，总情况数显然是 $k^n$，考虑如何算出合法情况数。

首先我们在 $k$ 后面新增一个座位 $k+1$ 然后拉链为环，让没有座位的人从头开始往后坐，这样一定所有人都会有座位，那么这样的环一共会有 $(k+1)^{n-1}$ 个（即圆排列）。**注意：这里暂时不考虑标号。**

但是我们怎么判断做法是否合法呢？**如果 $k+1$ 这个位置最后有人，那么在没有环与新座位时就一定会有人站在这里，否则没人站着（即合法情况）**，也就是说 **我们在环中找到空的位置当成 $k+1$ 即可**，空的位置一共有 $k+1-n$ 个，所以最后答案为：

$$
\frac{(k+1)^{n-1}(k+1-n)}{k^n}
$$

这就是拉链为环前莫名其妙地新增一个座位 $k+1$ 的原因。

然后这个题非常恶心，要用高精，化简分数时要用高精除，这里考虑一种简单的方法：

显然 $k+1$ 与 $k$ 互质，只能化简 $\dfrac{k+1-n}{k^n}$。

这里 $k+1-n$ 为低精，我们提前做一次 $\gcd$ 把 $k^n$ 膜 $k+1-n$ 转换为低精，就可以低精求 $\gcd$ 了。

也就是说，最后我们只需要高精乘，高精除低精和高精膜低精即可。

```cpp
namespace SOLVE {
	typedef long double ldb;
	typedef long long ll;
	typedef double db;
	const ll N = 110, B = 10000000; // Base
	ll T, n, k;
	class BigNum {
	public:
		ll num[N];
		inline void Print () {
			printf ("%lld", num[num[0]]);
			for_ (i, num[0] - 1, 1) printf ("%07lld", num[i]);
			return;
		}
		inline void Clear () {
			memset (num, 0, sizeof (num));
			num[0] = 1;
			return;
		}
		inline void In (ll number) { num[1] = number; }
		BigNum operator * (ll ano) {
			BigNum ans;
			ans.Clear ();
			ans.num[0] = num[0];
			_for (i, 1, num[0]) {
				ans.num[i] += num[i] * ano;
				ans.num[i + 1] += ans.num[i] / B;
				ans.num[i] %= B;
			}
			while (ans.num[ans.num[0] + 1]) ++ans.num[0];
			return ans;
		}
		BigNum operator * (BigNum ano) {
			BigNum ans;ans.Clear ();
			ans.num[0] = num[0] + ano.num[0] - 1;
			_for (i, 1, num[0]) {
				_for (j, 1, ano.num[0]) {
					ans.num[i + j - 1] += num[i] * ano.num[j];
					ans.num[i + j] += ans.num[i + j - 1] / B;
					ans.num[i + j - 1] %= B;
				}
			}
			while (ans.num[ans.num[0] + 1]) ++ans.num[0];
			return ans;
		}
		inline BigNum operator / (ll ano) {
			BigNum ans (*this);
			for_ (i, num[0], 1) {
				if (i > 1) ans.num[i - 1] += (ans.num[i] % ano) * B;
				ans.num[i] /= ano;
			}
			while (!ans.num[ans.num[0]] && ans.num[0] > 1) --ans.num[0];
			return ans;
		}
		inline ll operator % (ll ano) {
			ll ans = 0;
			for_ (i, num[0], 1) {
				ans = ans * B % ano;
				ans += num[i] % ano;
			}
			return ans;
		}
	} a, b;
	inline ll Gcd (ll a, ll b) {
		if (!b) return a;
		return Gcd (b, a % b);
	}
	inline BigNum FastPow (BigNum a, ll b) {
		BigNum ans;ans.Clear ();
		ans.num[0] = ans.num[1] = 1;
		while (b) {
			if (b & 1) ans = ans * a;
			a = a * a, b >>= 1;
		}
		return ans;
	}
	inline ll rnt () {
		ll x = 0, w = 1; char c = getchar ();
		while (!isdigit (c)) { if (c == '-') w = -1; c = getchar (); }
		while (isdigit (c)) x = (x << 3) + (x << 1) + (c ^ 48), c = getchar ();
		return x * w;
	}
	inline void In () {
		n = rnt (), k = rnt ();
		return;
	}
	inline void Solve () {
		a.Clear (), b.Clear ();
		a.num[1] = k + 1, b.num[1] = k;
		a = FastPow (a, n - 1) * (k + 1 - n);
		b = FastPow (b, n);
		ll c = b % (k + 1 - n);
		ll g = Gcd (k + 1 - n, c);
		a = a / g, b = b / g;
		return;
	}
	inline void Out () {
		a.Print (), putchar (' ');
		b.Print (), puts ("");
		return;
	}
}
```

---

## 作者：倾城ファン恋 (赞：4)

这个数据范围不是递推就是推公式.(反正要推，不是电脑推就是人推）


分母不说了，k^n（每个人选一个选）。


分子现在就是重点了。n>k肯定不管，直接就是0了（除非叠罗汉）。


我当时也是直接打了个暴力然后看数据推出来是(k+1)^(n-1)\*(k+1-n)的。


现在我们就分析n<=k的情况。我们先搞个环出来，虚构一个点，到这个点就又轮回到1去（超级点），这样就有（k+1)^n种选法，但由于是环所以去重后其实只有(k+1)^(n-1)（因为方案数种每种有k+1个，以每个点开头都有一个）。现在没有重复情况了，我们只要删除一个没人的点就可以破环了，所以最后要乘以没人的位置数(k+1-n)。


这道题最后主要是高精度有毒，当你发现辛辛苦苦推出公式了，但高精度打错了。（本OIer亲身经历）


代码如下：




```cpp
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<cstdio>
using namespace std;
typedef long long ll;
int n,m;
int a[205],b[205];
struct shu
{
    int len,s[2005];
    shu ()
    {
        memset(s,0,sizeof(s));
        len=1;
    }
    void operator =(int x)
    {
        shu c;
        while(x>0)
        {
            c.s[c.len-1]=x%10;
            c.len++;
            x=x/10;
        }
        while(c.s[c.len-1]==0) c.len--;
        *this=c;
    }
    void out()
    {
        for(int i=len-1;i>=0;i--)
        printf("%d",s[i]);
        printf(" ");
    }
    friend shu operator *(shu a,shu b)
    {
        shu c;
        c.len=a.len+b.len+1;
        for(int i=0;i<a.len;i++)
        for(int j=0;j<b.len;j++)
        {
            c.s[i+j]+=a.s[i]*b.s[j];
            c.s[i+j+1]+=c.s[i+j]/10;
            c.s[i+j]=c.s[i+j]%10;
        }
        while(!c.s[c.len-1]) c.len--;
        return c;
    }
    friend shu operator *(shu a,int b)
    {
        shu c;
        c=b;
        return a*c;
    }
}a1,b1;
void work()
{
    int t=m;
    for(int i=2;i<=t;i++) 
    {
        while(t%i==0)
        {
            t/=i;
            a[i]+=n;
        }
    }
    t=m+1;
    for(int i=2;i<=t;i++)
    {
        while(t%i==0)
        {
            t/=i;
            b[i]+=n-1;
        }
    }
    t=m+1-n;
    for(int i=2;i<=t;i++)
    {
        while(t%i==0)
        {
            t/=i;
            b[i]++;
        }
    }
    for(int i=1;i<=200;i++) 
    {
        int k=min(a[i],b[i]);
        a[i]-=k;
        b[i]-=k;
    }
    a1=1,b1=1;
    for(int i=1;i<=200;i++)
    while(a[i])
    {
        a1=a1*i;
        a[i]--;
    }
    for(int i=1;i<=200;i++)
    while(b[i])
    {
        b1=b1*i;
        b[i]--;
    }
}
int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);
    int T;
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d%d",&n,&m);
        if(m<n) {printf("0 1\n");continue;}
        memset(a,0,sizeof(a));
        memset(b,0,sizeof(b));
        work();
        b1.out();
        a1.out();
        printf("\n");
    }
    return 0;
}
```

---

## 作者：_Robin_ (赞：4)



乍一看，这个数据还是非常和善的，  
可恶，然而；  
每一个人的初始位置共有 $K$ 种选择，一共有 $n$ 个人，这个基数还是相当大的,搞不好就是惊人的 $K^n$；   
这就需要我们再进行考虑一下；  

首先，高精是必须有的，因为别的题都给了模数，这个题没有，所以先去把高精搞了，考虑到分数化简，高精模和高精除也得打一下；

下面是蒟蒻的高精模板
```cpp
typedef long long ll;
const ll M = 100000;
struct BigInt{
	ll len;
	ll a[10001];
	inline void clear(){memset(this->a,0,sizeof(this->a));this->len=0;}
	inline void give(int x){this->a[this->len=1]=x;}
	BigInt operator *(const BigInt &A)const{
		BigInt ans;
		ans.clear();
		ans.len=this->len+A.len+10;
		for(int i=1;i<=this->len;i++){
			for(int j=1;j<=A.len;j++){
				ans.a[i+j-1]+=this->a[i]*A.a[j];
				ans.a[i+j]+=ans.a[i+j-1]/M;
				ans.a[i+j-1]%=M;
			}
		}
		for(int i=1;i<=ans.len;i++){
			ans.a[i+1]+=ans.a[i]/M;
			ans.a[i]%=M;
		}
		while(ans.len&&!ans.a[ans.len]) ans.len--;
		return ans;
	}

	ll operator %(const ll &A)const{
		ll ans=0;
		for(int i=this->len;i>=1;i--) ans=(this->a[i]+ans*M)%A;
		return ans;
	}
	BigInt operator /(const ll &A)const{
		BigInt ans;
		ans.clear();
		ans.len=this->len;
		ll res=0;
		for(int i=ans.len;i>=1;i--){
			ans.a[i]=(res*M+this->a[i])/A;
			res=(res*M+this->a[i])%A;
		}
		while(ans.len&&!ans.a[ans.len]) ans.len--;
		return ans;
	}
	inline void print(){
		printf("%lld",this->a[this->len]);
		for(int i=this->len-1;i>=1;i--) printf("%05lld",this->a[i]);
	}
}Ans,a;
```
接下来就是这个题的解法了；  
首先看一下这个分母，一定是 $K^n$ ，这里直接快速幂就行；  

然后就是分子，我们首先可以考虑加一个座位编号为 $K+1$ ，最后处理就是从一个没做人的位置断开；剩下的就是 $n$ 全坐满的情况； 

**这样处理的原因就是，根据题目要求，如果该位置有人，则向右移动一个，这样单个讨论情况太复杂，不如把它搞成一个环，可以一直向右移动，这样就可以省略好多讨论，最后去重就可以了**

重复的情况，就是一个环中，一串数列可以向移动 $K+1$ 次，情况不同，但是在原题中的坐法是一样的，所以分子上现有一个 $(K+1)^{n-1}$, 

然后就是断开这个环，这个好说，在 $K+1-n$ 个点中随便选一个断开就是了，所以我们的答案就是  
$$ ans=\frac{(K+1)^{n-1}(K+1-n)}{K^n}$$  

最后就是约分这一步了；

考虑到高精与高精求 $\gcd$ 的困难度,我们需要再考虑一下；  
一阵玄学，突然发现，$K+1$ 和 $K$ 一定是互质的，因为；  
$$\gcd(a,b)=\gcd(b,a-b)$$
所以我们可能出现需要约分的地方就是 $K+1-n$ 和 $K$ ，这样就好办多了；  

这里一开始我有一个错的地方，就是 $K+1-n$ 与  $K$ 的 $\gcd$ 不一定是 $K^n$ 和 $K+1-n$ 的 $\gcd$；  

这里我们的处理方法是搞一个 $K^n \bmod(K+1-n)$ 的值，然后再求这个值和 $K+1-n$ 的 $\gcd$；  
最后上下同除一个低精的 $\gcd$ 就行了； 
-----一个辗转相除法求 $\gcd$   

好了；最后的最后，别忘了特判 $k<n$ 的情况，直接

```cpp
printf("0 1\n");
continue;
```
好了这就是看电影的解法了；
下面放上代码
```cpp
inline BigInt qpow(BigInt a,ll k){
	BigInt ans;
	ans.clear();ans.give(1);
	while(k){
		if(k&1) ans=ans*a;
		a=a*a;
		k>>=1;
	}
	return ans;
}
ll gcd(ll a,ll b){
	return b?gcd(b,a%b):a;
}
int n,k,T;
int main(){
	cin>>T;
	while(T--){
		cin>>n>>k;
		if(n>k){
			printf("0 1\n");
			continue;
		}
		BigInt ans1,ans2,r;
		ll t=k+1-n;
		BigInt f;f.clear();f.give(t);
		ans1.clear();ans1.give(k+1);
		ans1=qpow(ans1,n-1);ans1=ans1*f;
		ans2.clear();ans2.give(k);
		ans2=qpow(ans2,n);
		r=ans2;
		ll g=r%t;
		ll Gcd=gcd(g,t);
		ans1=ans1/Gcd;
		ans2=ans2/Gcd;
		ans1.print();putchar(' ');ans2.print();putchar('\n');
	}
}
```
完结，望审核大大通过；

---

## 作者：TempestMiku (赞：3)

# [题目传送门](https://www.luogu.com.cn/problem/P3330)

## 压行高精简单好写

根据题意，我们需要求:

概率 $=$ 合理方案 $/$ 总方案数

这里先给出式子。

$$ ans= \frac{(k+1)^{(n-1)}\times (k+1-n)}{k^n} $$
             
------------
# 推理

首先我们一定是把所有方案数作为分母。

显然是 $k^n$。

另外当 $n>k$ 时输出 ```0 1```即可。

之后的思路就比较神仙。

我们把链转成环，并在最后加一个座位。

这样根据题目给定的规则，由于 $n<k$，每个人最后一定可以坐下。

如果有人走到座位 $k$ 都不能坐下，他就会在加的那个座位坐下。

那么一个合法方案，即加的座位没有人坐的情况。

这时候就可以开始列柿子了:

 $n$ 个人，每次选 $k+1$ 中的一个坐下，（反正最终一定能坐下，不用想的太复杂），$(k+1)^n$。

且因为环的性质，（哪都能断，可能重复），每种排列算了 $k+1$ 次。

所以这部分是 $\frac{(k+1)^n}{k+1}=(k+1)^{n-1}$。

且有 $k-n+1$ 个空着的。

我们可以选择从这些位置断开重新伸展成链，使第 $k+1$ 个座无意义化。

$$ans=\frac{(k+1)^{n-1}(k-n+1)}{k^n}$$ 

没模法显然要高精对吧。

（高精乘低精就搞定了）。



根据古典数学:




$$ \operatorname{ans}= \frac{(k+1)^{(n-1)}  (k+1-n)}{k^n} $$
## 化简




[高精公约数](https://www.luogu.com.cn/problem/P2152) 不会也没关系，考虑化简。

~~这道题还要求输出约分后的结果别告诉我你要高精除。~~

分母累乘的时候一直求公约数一直约就行了。

原式子：

$$ \operatorname{ans}=\frac{(k+1)^{(n-1)}(k+1-n)}{k^n} $$

在乘起来的过程中即化简，我们需要找到分子和分母的公因数。

因为 $(k+1)$ 和 $k$ 互质所以下面和上面的公约数一定存在于 $(k+1-n)$ 和  $k$ 中。



------------


```cpp
int op=k+1-n;
     for(register int i=1;i<=n;i++){
         int gcd=__gcd(op,k);
         op/=gcd;
         mul2(k/gcd);//分母压行高精乘法。
     }
```


------------

这样就能不用高精 $\gcd$ 了。

## 代码实现

这里提供一个~~非常简单~~的压行高精，时间还快，代码还好写。

压位的高精乘法。


------------

```cpp
inline void mul1(int x){
    int tmp,pre(0);
    for(register int i=1;i<=len1;i++){
        tmp=op1[i]*x;
        op1[i]=pre+tmp%mod;
        pre=tmp/mod;
    }
    if(pre){
        ++len1;
        op1[len1]=pre;
    }
}
```



------------


### 高精输出



------------


```cpp
inline void print1(){
    write(op1[len1]);
    while(--len1){
        printf("%016lld",op1[len1]);
    }
}
```


------------


### 完结撒花

[完整代码](https://www.luogu.com.cn/paste/ixitgrgz)


---

## 作者：_Diu_ (赞：1)

题目[传送门](https://www.luogu.com.cn/problem/P3330)

这一道题其实并不会很难，但要想到这个思路也不容易。

这里给两道类似的题：

[P2523 \[HAOI2011\]Problem c](https://www.luogu.com.cn/problem/P2523)

[P1386 座位安排](https://www.luogu.com.cn/problem/P1386)

这一道题的大体思路：

### 合法方案/总方案

1. 总方案

这个很简单。

每一个人有 $k$ 个方案，总共乘法原理：$k^n$。

2. 合法方案

我们在第 $k$ 把椅子后面放上第 $k+1$ 把椅子。

再把这几个座位连成一个环

这样每一个人都有座位了

此时的方案数：

$\dfrac{(k+1)^n}{k+1}=(k+1)^{n-1}$

然后此时我们从剩下的 $k-n+1$ 个座位中选择一个拿掉，

再断开这个环，

这样就是一个合法方案了。

所以答案就是 $\dfrac{(k+1)^{n-1}(k-n+1)}{k^n}$

这里要注意：

当 $n>k$ 时，肯定有人要站着，所以概率是 $0$，这里输出 `0 1`。

我这里有一个小优化，因为 $(k+1)^{n-1}$ 和 $k^n$ 肯定是互质的，

所以在约分时只考虑 $k-n+1$ 和 $k^n$ 就可以了


## code

注意要开高精度！

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=100010;
int a[maxn],b[maxn],res[maxn];
string add(string s1,string s2){
    int n=s1.length(),m=s2.length();
    for(int i=0;i<n;i++)a[i]=s1[n-1-i]-'0';
    for(int i=0;i<m;i++)b[i]=s2[m-1-i]-'0';
    int len=max(n,m)+1;
    for(int i=n;i<len;i++)a[i]=0;
    for(int i=m;i<len;i++)b[i]=0;
    for(int i=0;i<len;i++)res[i]=0;
    for(int i=0;i<len;i++){
        res[i]+=a[i]+b[i];
        if(res[i]>=10){
            res[i+1]+=res[i]/10;
            res[i]%=10;
        }
    }
    int i=len-1;
    while(res[i]==0&&i>0)i--;
    string s="";
    for(;i>=0;i--)s+=(char)(res[i]+'0');
    return s;
}
string sub(string s1,string s2){
    int n=s1.length(),m=s2.length();
    for(int i=0;i<n;i++)a[i]=s1[n-1-i]-'0';
    for(int i=0;i<m;i++)b[i]=s2[m-1-i]-'0';
    int len=max(n,m);
    for(int i=n;i<len;i++)a[i]=0;
    for(int i=m;i<len;i++)b[i]=0;
    for(int i=0;i<len;i++)res[i]=0;
    for(int i=0;i<len;i++){
        res[i]+=a[i]-b[i];
        if(res[i]<0){
            res[i+1] --;
            res[i] += 10;
        }
    }
    int i=len-1;
    while(res[i]==0&&i>0)i--;
    string s="";
    for(;i>=0;i--)s+=(char)(res[i]+'0');
    return s;
}
bool cmp(string s1,string s2){
    int n=s1.length(),m=s2.length();
    int i;
    for(i=0;i<n-1&&s1[i]=='0';i++);
    s1=s1.substr(i);
    for(i=0;i<m-1&&s2[i]=='0';i++);
    s2=s2.substr(i);
    if(s1.length()!=s2.length())return s1.length()<s2.length();
    return s1<s2;
}
string Add(string s1,string s2){
    if(s1[0]=='-'&&s2[0]=='-'){
        return "-"+add(s1.substr(1),s2.substr(1));
    }
    else if(s1[0]=='-'){
        s1=s1.substr(1);
        if(cmp(s1,s2)==true){
            return sub(s2,s1);
        }else{
            return "-"+sub(s1,s2);
        }
    }
    else if(s2[0]=='-'){
        s2=s2.substr(1);
        if(cmp(s1,s2)){
            return "-"+sub(s2,s1);
        }else{
            return sub(s1,s2);
        }
    }
    else{
        return add(s1,s2);
    }
}
string Sub(string s1,string s2){
    if(s2[0]=='-'){
        s2=s2.substr(1);
        return Add(s1,s2);
    }else{
        return Add(s1,"-"+s2);
    }
}
string multi(string s1,string s2){
    int n=s1.length(), m=s2.length();
    for(int i=0;i<n;i++)a[i]=s1[n-1-i]-'0';
    for(int i=0;i<m;i++)b[i]=s2[m-1-i]-'0';
    int len=n+m;
    for(int i=n;i<len;i++)a[i]=0;
    for(int i=m;i<len;i++)b[i]=0;
    for(int i=0;i<len;i++)res[i]=0;
    for(int i=0;i<n;i++)
        for(int j=0;j<m;j++)
            res[i+j]+=a[i]*b[j];
    for(int i=0;i<len;i++){
        res[i+1]+=res[i]/10;
        res[i]%=10;
    }
    int i=len-1;
    while(res[i]==0&&i>0)i--;
    string s="";
    for(;i>=0;i--)s+=(char)(res[i]+'0');
    return s;
}
pair<string,string> divide(string s1,string s2) {
    string s="",t="";
    int n=s1.length(),m=s2.length();
    bool flag=false;
    for(int i=0;i<n;i++){
        s+=s1[i];
        int num=0;
        while(cmp(s,s2)==false){
            num++;
            s=sub(s,s2);
        }
        if(num>0){
            flag=true;
            char c=(char)(num+'0');
            t+=c;
        }
        else if(flag){
            t+='0';
        }
    }
    if(t.length()==0)t="0";
    while(s[0]=='0'&&s.length()>1)s=s.substr(1);
    return make_pair(t,s);
}
string gcd(string a,string b){
	if(b=="0")return a;
	return gcd(b,divide(a,b).second);
}
string qpow(string x,int y){
	string mul="1";
	for(;y;y>>=1){
		if(y&1)mul=multi(mul,x);
		x=multi(x,x);
	}
	return mul;
}
int t,n_;
string n,k,q,p;
int main(){
	scanf("%d",&t);
	while(t--){
		cin>>n>>k;
		if(cmp(k,n))puts("0 1");
		else{
			n_=0;
			for(int i=0;i<n.size();i++)n_=n_*10+n[i]-'0';
			q=Sub(Add(k,"1"),n);
			p=qpow(k,n_);
			string d=gcd(q,p);
			q=multi(divide(q,d).first,qpow(Add(k,"1"),n_-1));
			p=divide(p,d).first;
			cout<<q<<' '<<p<<'\n';
		}
	}
}
```

---

## 作者：Leasier (赞：1)

首先，这个问题是一道古典概型的题目，所以答案为合法方案数除以总方案数。

显然，总方案数为 $n^k$。

接下来，我们来考虑一下合法方案数应该如何计算。

1. $n \leq k$ 时

我们可以虚构一个座位 $k + 1$，座位安排到这里就穿越回座位 $1$ 去，这样就会有 $(k + 1)^n$ 种选法。但是，由于这是一个环，即每个人的方案有 $k + 1$ 种，所以去重后只有 $(k + 1)^{n - 1}$ 种情况。最后，我们需要删除那个虚构的座位，所以需要从剩下的座位中随意抽取一把，即结果要乘以剩下座位的数量 $k - n + 1$。

所以结果为：$\frac{(k + 1)^{n - 1}(k - n + 1)}{n^k}$。

2. $n > k$ 时

这种情况下，怎么也无法让所有同学都坐到座位上，所以结果为 $0$。

代码：
```python
import math

t = int(input())
for i in range(t):
	n, k = map(int, input().split())
	if (n > k):
		print(0, 1)
	else:
		a = ((k + 1) ** (n - 1)) * (k - n + 1)
		b = k ** n
		d = math.gcd(a, b)
		print(a // d, b // d)
```

---

## 作者：ncwzdlsd (赞：0)

显然，题目要求的“全班都能够有座位的概率”即为全班都有座的方案数与总方案数之比。

总方案数为全排列，即 $K^N$。

对于 $N>K$ 时，答案显然为 $0$；

下面考虑合法的方案数。我们用一个小技巧，把所有的座椅变成一个环，此时我们可以保证每一个人都有座位。这样对于每一个人来说，方案数有 $(k+1)^{n-1}$ 种。又因为我们需要的这个空座即第 $K+1$ 个共有 $(K-N+1)$ 种可能，所以概率为：

$$
\frac{(K+1)^{N-1}\times (K-N+1)}{K^N}
$$

但是比较恶心的点是这道题要用高精度，所以我们友情提供一份 Python 代码。

代码如下：
```python
import fractions
import math

T=int(input())

for i in range(T):
    N,K=map(int,input().split())
    if N>K:
        print(0,1)
    else:
        ans1=((K+1)**(N-1))*(K-N+1)
        ans2=K**N
        tmp=math.gcd(ans1,ans2)
        print(ans1//tmp,ans2//tmp)
```

---


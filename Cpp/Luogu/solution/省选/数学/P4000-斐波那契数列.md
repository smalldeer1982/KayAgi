# 斐波那契数列

## 题目描述

大家都知道，斐波那契数列是满足如下性质的一个数列：

• $f_1 = 1$

• $f_2 = 1$

• $f_n = f_{n-1} + f_{n-2}$ ($n \geq 2$ 且 $n$ 为整数)

请你求出 $f_n \mod p$ 的值。


## 说明/提示

对于 $100\%$ 的数据，$n \leq 10^{30000000}, p<2^{31}$


## 样例 #1

### 输入

```
5
1000000007```

### 输出

```
5```

## 样例 #2

### 输入

```
10
1000000007```

### 输出

```
55```

# 题解

## 作者：Itst (赞：85)

同步发布于[cnblogs](https://www.cnblogs.com/Itst/p/12241180.html)

## 前言

> 你打开了“P4000 斐波那契数列”一题；

> 你发现是已经写过 $\mathrm{998244853}$ 遍的求 $\mathrm{Fib}_n$；

> 你熟练地写出矩阵快速幂并提交；

> 你得到了一版的 $\mathrm{TLE}$ ，因为 $n \leq 10^{30000000}$；

> 你点开了题解，发现第一篇题解一大片公式和定理；

> 你向下滑动界面，其他的题解都直接摆结论。

相信经历了这么多的你心中满满的“我太难了”。

那么这篇题解将拯救你于水火之中（？）

## 前置芝士

- 主角：生日悖论；
- 辅助结论：模数为 $p$ 的斐波那契循环节长度 $\pi(p) \leq 6p$；
- $O(\sqrt p)-O(1)$ 快速幂，[LOJ有模板题](https://loj.ac/problem/162)。

关于辅助结论的证明，因为前置结论比较多 ~~（实际上是我不会）~~ ，故在本篇题解中被省略。如果你有条件，可以参考 $\mathrm{Wikipedia}$ 中的 $\mathrm{Pisano\ Period}$ 条目，其中有证明。

所以实际上这个做法也有很多前置。但是相比纯数论做法，结论只有这一个，而且这个结论很好记。

## 算法流程

一件显然的事情是需要计算斐波那契数列的循环节。暴力做法基本没有优化空间，考虑：设循环节长度为 $\pi(p)$，对于 $i \neq j$ ，如果 $\mathrm{Fib}_i = \mathrm{Fib}_j$ 且 $\mathrm{Fib}_{i+1} = \mathrm{Fib}_{j+1}$，那么$\pi(p) \mid j-i$。也就是说如果找到两个位置 $i,j$ 满足条件就可以得到循环节长度的某个倍数。

因为只需求值，所以求出$\pi(p)$的真实值没有必要，求出其倍数也可以接受。所以可以利用随机化得到一个新算法：每一次随机两个数 $i,j$，计算 $\mathrm{Fib}_i , \mathrm{Fib}_{i+1} , \mathrm{Fib}_j , \mathrm{Fib}_{j+1}$ 的值判断是否相等。

显然这个做法是期望 $O(p)$ 的，跟暴力没有区别。但我们可以换一个角度描述这个问题：每一次随机两个位置 $i,j$，相当于随机两个数 $x = i \mod \pi(p)$ 和 $y = j \mod \pi(p)$，如果 $x=y$ 就可以找到循环节的倍数。

可以发现这个问题与“生日悖论”问题基本一致。利用生日悖论思想，每一次随机两个命中概率很小，但随机三个、四个、很多个位置，随着随机的数量增长，命中概率是以平方级别增长的。

所以可以得到一个更优秀的算法：使用一个哈希表记录之前随机到的所有 $(\mathrm{Fib}_i , \mathrm{Fib}_{i+1} , i)$ 三元组，每次随机位置 $j$ 并得到 $(\mathrm{Fib}_j , \mathrm{Fib}_{j+1} , j)$，如果在哈希表中可以找到满足 $\mathrm{Fib}_i = \mathrm{Fib}_j$ 且 $\mathrm{Fib}_{i+1} = \mathrm{Fib}_{j+1}$ 的三元组 $(\mathrm{Fib}_i , \mathrm{Fib}_{i+1} , i)$，就可以得到循环节的某个倍数。

根据生日悖论，上述算法在期望 $O(\sqrt p)$ 次内可以完成寻找。使用 $O(\sqrt p) - O(1)$ 矩阵/扩域快速幂实现求斐波那契数，可以做到 $O(\sqrt p)$ 求出循环节。

## 后话

这个做法是在复习`Pollard-rho`算法时 ~~打隔膜~~ 翻到有博客记录 $\pi(p) \leq 6p$ 时浮现的。如果在考场上遇到了类似问题，只需要信仰猜想循环节长度为模数级别、把 $\frac{\text{循环节长度}}{\text{模数}}$ 这个常数估计大一些然后套用本题做法就可以了，拓展性比较高。

如果想求 $\pi(p)$ 的真实值，只需要枚举算出来的循环节的约数然后逐个判断即可。

## Show me the Code.

两个实现细节：

- 建议随机位置上界大于 $12p$，否则期望次数可能会退化。代码中的随机上界是 $2^{36}$，选择二的次幂作为模数（或许）可以最小化因为取模导致的`mt19937_64`随机不均匀问题。
- $p < 2^{31}$ 所以可以直接用一个`long long`存下 $(\mathrm{Fib}_i,\mathrm{Fib}_{i+1})$ 二元组，然后就可以用 `unordered_map`实现哈希表了。

与此同时这份代码常数比较大，用扩域常数会小一半。

```cpp
#include<bits/stdc++.h>
using namespace std;

#define ll long long
#define ull unsigned long long
unordered_map < ull , ll > circ; ll len;
int MOD , MX = 1 << 18; mt19937_64 rnd(time(0));
struct matrix{
	ll arr[2][2];
	matrix(){memset(arr , 0 , sizeof(arr));}
	ll* operator [](int x){return arr[x];}
	friend matrix operator *(matrix p , matrix q){
		matrix x;
		for(int i = 0 ; i < 2 ; ++i)
			for(int j = 0 ; j < 2 ; ++j)
				for(int k = 0 ; k < 2 ; ++k)
					x[i][k] += p[i][j] * q[j][k];
		for(int i = 0 ; i < 2 ; ++i)
			for(int j = 0 ; j < 2 ; ++j) x[i][j] %= MOD;
		return x;
	}
}G , T[2][1 << 18 | 1];

signed main(){
	static char str[300000003]; scanf("%s %d" , str + 1 , &MOD);
	T[0][0][0][0] = T[0][0][1][1] = T[1][0][0][0] = T[1][0][1][1] = 1;
	T[0][1][0][1] = T[0][1][1][0] = T[0][1][1][1] = 1;
	for(int i = 2 ; i <= MX ; ++i) T[0][i] = T[0][i - 1] * T[0][1];
	T[1][1] = T[0][MX]; for(int i = 2 ; i <= MX ; ++i) T[1][i] = T[1][i - 1] * T[1][1];
	while(1){
		ll x = (rnd() << 28 >> 28); matrix C = T[0][x & (MX - 1)] * T[1][x >> 18];
		ull val = ((1ull * C[0][0]) << 32) | C[0][1];
		if(circ.find(val) != circ.end()){len = abs(circ[val] - x); break;}
		circ[val] = x;
	}
	ll sum = 0; 
	for(int i = 1 ; str[i] ; ++i) sum = (sum * 10 + str[i] - '0') % len;
	cout << (T[0][sum & (MX - 1)] * T[1][sum >> 18])[0][1];
	return 0;
}
```

---

## 作者：飞雨烟雁 (赞：73)

#### 原题链接：[P4000 斐波那契数列](https://www.luogu.com.cn/problem/P4000)


------------

~~（一开始以为是道水题，没想到竟然如此复杂，呜呜呜）~~

> 题目：求 $f_n\bmod P$ 的值。

**注：** 原题的模数是小写的 $p$，此处为了区分下文的质数 $p$，改为大写的 $P$。

首先，$n$ 达到了 $10^{30000000}$ 的级别，矩阵快速幂肯定 TLE。

于是我们想到了要通过一些方法降低 $n$ 的大小，最先想到的是对 $n$ 模以某个数，然后再矩阵快速幂不就好了嘛。

那么先手算一下取模的这个数和 $P$ 的关系吧，假设 $P=4$，那么斐波那契数列长这样：

$$1,1,2,3,1,0,1,1,2,3,1,0,...$$

好像确实有规律，针对 $P=4$ 时我们只需求 $f_{n\bmod 6}$ 就好了！

可是对于其他的 $P$ 要怎么求？为了解决这个问题，我们可能需要一点前置知识……

------------

## 前置知识：二次剩余

------------

可能需先掌握「[原根](https://www.luogu.com.cn/problem/P6091)」的知识。

二次剩余是指这样一类问题：

> 已知 $n,p$ 的值，解方程 $x^2\equiv n\pmod p$ 。

洛谷上有模板题：[P5491 【模板】二次剩余](https://www.luogu.com.cn/problem/P5491)。此处不做详述，只讲与下文有关的，即 $p$ 是奇素数的情况。

首先 $p\mid n$ 时，$x^2\equiv n\equiv 0\pmod p$，故 $x=0$。

当 $p\nmid n$ 时，$x$ 可能无解，如 $n=2,p=3$ 时。那么 $n,p$ 满足什么条件时 $x$ 有解呢？

**结论一**：$n^{\frac{p-1}{2}}\equiv 1\pmod p$ 是 $x$ 有不为 $0$ 的解的充要条件。以下证明：

当 $x$ 有不为 $0$ 的解时，$x^{p-1}\equiv 1$。因此 $n^{\frac{p-1}{2}}\equiv(x^2)^{\frac{p-1}{2}}\equiv x^{p-1}\equiv 1$，必要性证毕。

当 $n^{\frac{p-1}{2}}\equiv 1$ 时，设 $g$ 是 $p$ 的原根，则存在 $k$ 使得 $n=g^k$，故 $g^{\frac{k}{2}(p-1)}\equiv 1$。因为 $g$ 的阶是 $p-1$，所以 $(p-1)|\frac{k}{2}(p-1)$，即 $k$ 是偶数。那么解得 $x\equiv g^{\frac{k}{2}}$，有不为 $0$ 的解。充分性证毕。

那什么时候无解呢？因为 $n^{p-1}\equiv 1$，$(n^{\frac{p-1}{2}}-1)(n^{\frac{p-1}{2}}+1)\equiv 0$，即 $n^{\frac{p-1}{2}}\equiv \pm1$。由结论一推理得，$n^{\frac{p-1}{2}}\equiv -1$ 是 $x$ 无解的充要条件，记为**结论二**。

事实上，上面这些对下文有用的只有这句话：

$x^2=n\pmod p$ 无解等价于 $n^{\frac{p-1}{2}}\equiv -1\pmod p$。

------------

## 斐波那契循环节

------------

接下来就是主线情节了。

**结论三**：斐波那契数列 $\{f_i\}$ 对 $p$ 取模后必定是周期数列。

显然，只要存在 $i\neq j$ 满足 $f_i\equiv f_j$ 且 $f_{i+1}\equiv f_{j+1}$。那么由递推关系可以得到 $f_{i+k}\equiv f_{j+k}$，命题就成立了。

要证明存在这样的 $i,j$ 也不难，因为不可能有无穷多对不同的 $(f_i,f_{i+1})$，至多 $p^2$ 对，因此一定存在 $i\neq j$，满足 $f_i\equiv f_j$ 且 $f_{i+1}\equiv f_{j+1}$。故循环节一定存在，且长度不超过 $p^2$，证毕。

设 $\pi(p)$ 是这个数列的周期（注意，此处并不要求 $\pi(p)$ 是最小正周期）。那要怎样求 $\pi(p)$？

不难发现，若存在 $k$ 满足 $\forall i, f_{i}\equiv f_{i+k}\pmod p$，那 $k$ 就是 $\{f_i\bmod p\}$ 的周期，取 $\pi(p)=k$ 就好了。

------------

### Part 1：

让我们从最简单的情况开始：当模数 $P$ 等于**某个质数** $p$ 的时候。

先搬出斐波那契数列的通项公式：$f_i=\dfrac{(\frac{1+\sqrt 5}{2})^i-(\frac{1-\sqrt 5}{2})^i}{\sqrt 5}$。

因为公式里有 $\sqrt 5,\frac1 2$，所以我们先单独讨论 $p=2,5$ 的情况：经计算取 $\pi(2)=3,\pi(5)=20$。

撇除这些特殊情况后，$p$ 便是一个不等于 $5$ 的奇素数。但根据二次剩余的知识，$\sqrt 5$ 模 $p$ 时不一定能表示成整数，需分类讨论。

- $x^2\equiv 5\pmod p$ 有非 $0$ 解

这时 $x$ 等价于 $\sqrt 5$ ，那么 $\sqrt 5,\frac{1}{\sqrt 5},\frac 1 2$ 模 $p$ 就都有意义，即 $\frac{1+\sqrt 5}{2},\frac{1-\sqrt 5}{2}$ 能用整数表示，适用于欧拉定理。所以：

$$\begin{aligned}f_{i+\varphi(p)}&\equiv \frac{(\frac{1+\sqrt 5}{2})^{i+\varphi(p)}-(\frac{1-\sqrt 5}{2})^{i+\varphi(p)}}{\sqrt 5}\\&\equiv\frac{(\frac{1+\sqrt 5}{2})^i-(\frac{1-\sqrt 5}{2})^i}{\sqrt 5}=f_i\end{aligned}$$

故 $\varphi(p)$ 是数列的一个周期，取 $\pi(p)= \varphi(p)=p-1$。

- $x^2\equiv 5\pmod p$ 无解

无解意味着找不到整数替代 $\sqrt 5$，需要**扩域**。

扩域指的是令某个数 $w$ 满足 $w^2\equiv K$，其中 $K^{\frac{p-1}{2}}\equiv -1$。因为 $x^2\equiv K$ 无解，所以这里的 $w$ 类似于 $i^2=-1$ 的 $i$，并非整数。同时，由 $w$ 构成的数 $a+bw$ 也不满足欧拉定理等，需要新的结论。 

**结论四**：对于奇素数 $p$，有 $(a+bw)^{p+1}\equiv a^2-b^2K\pmod p$。

以下证明：由二项式定理可得：

$$(a+bw)^{p+1}=\sum_{i=0}^{p+1}C_{p+1}^ia^{p+1-i}(bw)^i$$

聚焦于组合数 $C_{p+1}^i\equiv\frac{p!}{i!(p+1-i)!}$，可以发现仅在 $i=0,1,p,p+1$ 这四个值时组合数模 $p$ 后不为 $0$。因此原式等于：

$$C_{p+1}^0a^{p+1-0}(bw)^0+C_{p+1}^1a^{p+1-1}(bw)^1+C_{p+1}^{p}a^{p+1-p}(bw)^p+C_{p+1}^{p+1}a^{p+1-p-1}(bw)^{p+1}$$

即 $a^{p+1}+a^{p}bw+ab^pw^p+b^{p+1}w^{p+1}\equiv a^2+abw+abw^p+b^2w^{p+1}$。

$\because w^2\equiv K,K^{\frac{p-1}{2}}\equiv -1$

$\therefore (w^2)^{\frac{p-1}{2}}\equiv w^{p-1}\equiv -1$

代入原式得：$a^2-b^2w^2\equiv a^2-b^2K$，证毕。

接下来，设 $w^2\equiv 5$，则通项公式可写成：$f_i=\dfrac{(\frac{p+1}{2}+\frac{p+1}{2}w)^i-(\frac{p+1}{2}-\frac{p+1}{2}w)^i}{w}$。

先看 $\frac{p+1}{2}+\frac{p+1}{2}w$，由结论四得：$(\frac{p+1}{2}+\frac{p+1}{2}w)^{p+1}\equiv (\frac{p+1}{2})^2-5(\frac{p+1}{2})^2\equiv -1$。

所以 $(\frac{p+1}{2}+\frac{p+1}{2}w)^{2p+2}\equiv 1$，同理 $(\frac{p+1}{2}-\frac{p+1}{2}w)^{2p+2}\equiv 1$。

因此 $f_{i+2p+2}\equiv f_i$，取 $\pi(p)=2p+2$。

------------

### Part 2：

接下来，讨论模数 $P$ 是**某个质数的幂**的情况，记 $P=p^k$。

**注**：Part 2 的证明参考了部分资料（链接见文末）。

**结论五**：对于质数 $p$，已知 $a\equiv 1\pmod p$，则 $a^{p^k}\equiv 1\pmod {p^{k+1}}$。

以下证明：考虑数学归纳法，假设 $k$ 时等式成立，证明 $k+1$ 时等式也成立。

设 $a^{p^{k}}=sp^{k+1}+1$，那么 $a^{p^{k+1}}=(a^{p^k})^p=(sp^{k+1}+1)^p$。

由二项式定理：

$$(sp^{k+1}+1)^p=\sum_{i=0}^pC_p^i(sp^{k+1})^i$$

当 $i\ge 2$ 时，$p^{(k+1)i}\bmod p^{k+2}=0$，只需算出 $i=0,1$ 的值。代入得 $1+sp^{k+2}\equiv 1\pmod {p^{k+2}}$，证毕。

方便起见，记 $\frac{1+\sqrt 5}{2}=u,\frac{1-\sqrt 5}{2}=v$。

**结论六**：对于质数 $p$，有 $u^{\pi(p)}\equiv v^{\pi(p)}\equiv 1\pmod p$。

$\because f_{\pi(p)}\equiv 0\pmod p$

$\therefore u^{\pi(p)}\equiv v^{\pi(p)}$

$\because f_{\pi(p)+1}\equiv 1$

$\therefore {u^{\pi(p)}u-v^{\pi(p)}v}\equiv \sqrt 5$

代入 $u^{\pi(p)}\equiv v^{\pi(p)}$ 化简得：$u^{\pi(p)}\equiv v^{\pi(p)}\equiv 1$，证毕。

结合结论五和结论六可得：$u^{\pi(p)p^{k-1}}\equiv v^{\pi(p)p^{k-1}}\equiv 1\pmod {p^k}$。

因此 $f_{\pi(p)p^{k-1}}\equiv \frac{1}{\sqrt 5}(u^{\pi(p)p^{k-1}}-v^{\pi(p)p^{k-1}})\equiv 0\pmod {p^k}$。

且 $f_{1+\pi(p)p^{k-1}}\equiv \frac{1}{\sqrt 5}(u^{\pi(p)p^{k-1}}u-v^{\pi(p)p^{k-1}}v)\equiv \frac{u-v}{\sqrt 5}\equiv 1\pmod {p^k}$。

也就是说：$f_{i+\pi(p)p^{k-1}}\equiv f_i\pmod {p^k}$，取 $\pi(p^k)=\pi(p)p^{k-1}$。

------------

### Part 3：

最后一步了，也是最简单的情况。

**结论七**：设模数 $P$ 的质因数分解式为 $\prod p^k$，则可取 $\pi(P)=\operatorname{lcm}(\pi(p_i^{k_i}))$。

以下证明：

$\because f_{\pi(P)}\equiv 0\pmod{p_i^{k_i}},p_i^{k_i}\mid f_{\pi(P)}$

$\therefore {\pi(p_i^{k_i})}\mid {\pi(P)}$

取 $\pi(P)$ 为 $\pi(p_i^{k_i})$ 的最小公倍数即可，证毕。

------------

## 代码实现

------------

回到原题，开始整理思路。

1. 对 $P$ 进行质因数分解，时间复杂度 $O(\sqrt P)$；

2. 对于 $P$ 的每个质因数分解 $p_i^{k_i}$，求出对应的周期长 $\pi(p_i^{k_i})$；

3. 求出每个周期的最小公倍数，作为 $\pi(P)$ 的值；

4. 把读入的 $n$ 模以 $\pi(P)$，然后矩阵快速幂解决。

就这样，代码在此：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#define ll long long
using namespace std;

ll FastPow(ll a, ll b, ll mod){
    ll res = 1;
    while(b){
        if(b & 1) res = res * a % mod;
        b >>= 1, a = a * a % mod;
    }
    return res;
}

ll FastPowNoMod(ll a, ll b){
    ll res = 1;
    while(b){
        if(b & 1) res = res * a;
        b >>= 1, a = a * a;
    }
    return res;
}

const int Mx = 3e7 + 10;
int Fac[30], Tim[30], tot;
char N[Mx];

void Divide(int p){ // 分解质因数
    for(int i = 2; i * i <= p; ++i) if(p % i == 0){
        Fac[++tot] = i;
        while(p % i == 0) p /= i, ++Tim[tot];
    }
    if(p != 1) Fac[++tot] = p, Tim[tot] = 1;
}

ll PrimeLoop(ll p){ // 求 pi(p)
    if(p == 2) return 3;
    if(p == 5) return 20;
    if(FastPow(5, (p - 1) >> 1, p) == 1) return p - 1;
    return 2 * p + 2;
}

ll PrimePow(int id){ return FastPowNoMod(Fac[id], Tim[id] - 1) * PrimeLoop(Fac[id]);} // 求 pi(p^k)

ll Gcd(ll a, ll b){ return b == 0 ? a : Gcd(b, a % b);}

ll GetLoop(){ // 求 pi(P)
    ll res = PrimePow(1), temp;
    for(int i = 2; i <= tot; ++i) temp = PrimePow(i), res = res / Gcd(res, temp) * temp;
    return res;
}

int P;

struct Matrix{
    ll val[3][3];
    Matrix operator * (const Matrix& a) const {
        Matrix Res = (*this);
        for(int i = 1; i <= 2; ++i) for(int j = 1; j <= 2; ++j)
            Res.val[i][j] = (val[i][1] * a.val[1][j] % P + val[i][2] * a.val[2][j] % P) % P;
        return Res;
    }
    Matrix operator *= (const Matrix& a) { return (*this) = a * (*this);}
    Matrix operator ^ (ll k) const {
        Matrix Res, Temp = (*this);
        Res.val[1][1] = Res.val[2][2] = 1, Res.val[1][2] = Res.val[2][1] = 0;
        while(k){
            if(k & 1) Res *= Temp;
            k >>= 1, Temp *= Temp;
        }
        return Res;
    }
} Fibo, Cell;

void Solve(ll n){
    if(n == 0){
        printf("0");
        return;
    }
	Fibo.val[1][1] = 0, Fibo.val[2][1] = Fibo.val[1][2] = Fibo.val[2][2] = 1;
	Cell.val[1][1] = 1, Cell.val[1][2] = 1;
    Matrix Res = Cell * (Fibo ^ (n - 1));
    printf("%lld", Res.val[1][1] % P);
}

int main(){
    scanf(" %s %d", N, &P);
    if(P == 1){
        printf("0");
        return 0;
    }
    Divide(P);
    ll Loop = GetLoop(), n = 0;
    int Len = strlen(N);
    for(int i = 0; i < Len; ++i) n = (n * 10 + (N[i] ^ 48)) % Loop;
    Solve(n);
    return 0;
}
```

------------

#### 参考资料：

- [Pisano Period](https://www.cnblogs.com/cjoierShiina-Mashiro/p/11385287.html)

- [The Period of the Fibonacci Sequence Modulo j
](https://gradprogram.math.arizona.edu/~ura-reports/071/Campbell.Charles/Final.pdf)

---

## 作者：Pulsating_Dust (赞：15)

大家好，我是一个非常喜欢卡常的毒瘤，因此我用暴力通过了这道题(而且比不少人的正解跑的还快)

提交记录

[Link](https://www.luogu.com.cn/record/95907487)

这道题正常的解法应该是生日悖论+哈希判重或者数论直接计算循环节。

计算循环节的复杂度为 $O(\sqrt p)$ 或者 $O(p^{1/4})$ ,取决于你使用的质因数分解算法。

如果使用生日悖论+哈希判重，由于循环节不超过 $6p$ ,预处理即可做到 $O(\sqrt p)$ 。

但读入并取模的复杂度就已经达到了 $O(\log{n})$ 的级别，而我们注意到直接使用矩阵快速幂计算复杂度也是 $O(\log{n})$ ,之所以卡不过是因为常数太大。

我们来考虑怎么卡常。

首先对于这个输入格式来说必须采用十进制下的矩阵快速幂，因为转换到二进制复杂度为 $O(\log^2n)$ 复杂度上完全无法接受。

矩阵乘法本身常数是非常大的，但对于计算斐波那契数列这个特殊情况来说并不需要一个真正的矩阵乘法。

这个矩阵中恒有 $F_{12}=F_{21}$ 因此我们考虑把这两个缩成一个并去除循环 这样就能优化掉1/4的计算常数和氧气下自动展开的循环常数。

但是还是无法通过。

把取模去掉直接计算，居然没有T掉而且跑的相当快(不过全wa了)，显然巨大的常数来自取模操作，由于模数可变，编译器无法优化取模运算，取模运算的巨大常数暴露无疑。

因此考虑优化取模操作，对于固定的模数，barret约减非常适合优化(对于固定模数编译器就是采用了barret约减进行优化)，barret约减在预处理后使用一次乘法与一次位移代替除法操作，这样就足以通过了。

最后额外优化：

实际上，一个二元组即可表示这个矩阵乘法。

我们令$f_n$表示斐波那契数列的第n项，则有:

$(f_{n+m},f_{n+m-1})=(f_n{\times}f_m+f_n{\times}f_{m-1}+f_m{\times}f_{n-1},f_n{\times}f_m+f_{n-1}{\times}f_{m-1})$

证明可以通过斐波那契数列的通项公式。

循环展开也可以进一步优化常数。

Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ll;
struct barret{//barret约减 加速大量除法
	typedef unsigned __int128 lll;
	typedef unsigned long long ll;
	ll m;//m 为取模参数
	int p;//p 表示使用的模数
    int c;//c 为另一个取模参数
    inline void init(int t){
		c=31+2*ceil(log2(t)),p=t,m=(ll((lll(1)<<c)/t))+1;
	}
    friend inline ll operator % (ll n,const barret &d) {
		return n-((lll(n)*d.m)>>d.c)*d.p;
	}//return n%d
}modp;
const int maxlgn=3e7+20;
int p;
char buf[maxlgn];
int len,rlen;
void qread(){
	len=fread(buf,1,maxlgn,stdin);
	rlen=len;
    while (buf[rlen]>'9'||buf[rlen]<'0'){rlen--;}
	while(rlen--){
		if(buf[rlen]>'9'||buf[rlen]<'0'){
			do{rlen--;}while(buf[rlen]>'9'||buf[rlen]<'0');
			break;
		}
	}
	int now=rlen;
	char _ch=buf[++now];
	while (_ch>'9'||_ch<'0'){_ch=buf[++now];}
	while(_ch<='9'&&_ch>='0'){p=p*10+(_ch-48);_ch=buf[++now];}
}//fread读入 与scanf读入相比大概快了50ms左右

struct node{
	ll x1,x2;
};
const node e={0,1};//单位元
const node fib={1,0};//第一项

inline node operator * (const node &a,const node &b){
	return {(a.x1*b.x1+a.x1*b.x2+a.x2*b.x1)%modp,(a.x1*b.x1+a.x2*b.x2)%modp};
}//乘法操作

node pow10w[10005]={e,fib};

void init(){
	modp.init(p);
	for(int i=2;i<=10000;++i){
		pow10w[i]=pow10w[i-1]*fib;
        //cout<<pow10w[i].x1<<" "<<pow10w[i].x2<<endl;
	}
}//初始化modp 预处理1~10000的答案

ll count(){
	if(p==1){return 0;}//p==1特判
	node ans=e;
	int nlen=(rlen/4)*4;
	for(int i=0;i<nlen;i+=4){
		node mid=ans*ans;
		mid=mid*mid;mid=mid*mid;ans=mid=mid*mid;//ans=mid=ans^16
		mid=mid*mid;mid=mid*mid;mid=mid*mid;mid=mid*mid;//mid=ans^256
		ans=ans*mid;//ans=ans^272
		mid=mid*mid;//mid=ans^512
		ans=ans*mid;//ans=ans^784
		mid=mid*mid;//mid=ans^1024
		ans=ans*mid;//ans=ans^2008
		mid=mid*mid;mid=mid*mid;mid=mid*mid;//mid=ans^8192
		ans=ans*mid;//ans=ans^10000
		ans=ans*pow10w[(buf[i]-48)*1000+(buf[i+1]-48)*100+(buf[i+2]-48)*10+(buf[i+3]-48)];
	}//循环展开
	for(int i=nlen;i<=rlen;++i){
		node mid=ans*ans;//mid=ans^2
		ans=mid;//ans=ans^2
		mid=mid*mid;mid=mid*mid;//mid=ans^8
		ans=ans*mid;//ans=ans^10
		ans=ans*pow10w[buf[i]^48];
	}//处理末尾的剩余部分
	return ans.x1;
}
int main(){
	qread();
	//scanf("%s %d",buf,&p);
	init();
	printf("%lld",count());
	return 0;
}
```




---

## 作者：RuSun (赞：14)

思路来自 @jklover orz 。

有结论，斐波那契数列的循环节的上界为 $6p$ 。考虑矩阵加速，设斐波那契的第 $i$ 项和第 $i + 1$ 项构成的矩阵为 $A _ i$ ，转移矩阵为 $B$ 。如果有循环节 $k$ ，那么有 $A _ 1 B ^ k = A _ 1 \bmod p$ 。$A, B$ 显然都是存在逆的，那么 $B ^ k = I$ ，其中 $I$ 表示单位矩阵。这样将问题转化为 BSGS 的标准形式。用 BSGS 可以在 $O(\sqrt p \log \sqrt p)$ 的时间内解得 $k$ 。然后直接矩阵加速即可。

```cpp
#include <cstdio>
#include <cmath>
#include <array>
#include <map>
#include <cstring>
using namespace std;
template <class Type>
void read (Type &x)
{
    char c;
    bool flag = false;
    while ((c = getchar()) < '0' || c > '9')
        c == '-' && (flag = true);
    x = c - '0';
    while ((c = getchar()) >= '0' && c <= '9')
        x = (x << 1) + (x << 3) + c - '0';
    flag && (x = ~x + 1);
}
template <class Type, class ...rest>
void read (Type &x, rest &...y) { read(x), read(y...); }
template <class Type>
void write (Type x)
{
    x < 0 && (putchar('-'), x = ~x + 1);
    x > 9 && (write(x / 10), 0);
    putchar('0' + x % 10);
}
const int N = 2, M = 3e7 + 10;
typedef long long LL;
typedef array<array<int, N>, N> Matrix;
int p;
Matrix operator * (const Matrix &a, const Matrix &b)
{
    Matrix res;
    for (int i = 0; i < N; ++i)
        for (int j = 0; j < N; ++j)
        {
            res[i][j] = 0;
            for (int k = 0; k < N; ++k)
                res[i][j] = (res[i][j] + (LL)a[i][k] * b[k][j]) % p;
        }
    return res;
}
Matrix binpow (Matrix b, LL k)
{
    Matrix res;
    for (int i = 0; i < N; ++i)
        for (int j = 0; j < N; ++j)
            res[i][j] = i == j;
    for (; k; k >>= 1, b = b * b)
        if (k & 1) res = res * b;
    return res;
}
LL BSGS (Matrix A, Matrix B)
{
    int k = sqrt(p * 6ll) + 1;
    map <Matrix, int> H;
    Matrix s = B;
    for (int i = 0; i < k; ++i, s = s * A) H[s] = i;
    Matrix t = binpow(A, k);
    s = t;
    for (int i = 1; i <= k; ++i, s = s * t)
        if (H.count(s)) return (LL)i * k - H[s];
    return -1;
}
char str[M];
int main ()
{
    scanf("%s", str);
    read(p);
    Matrix A, B;
    A[0][0] = A[0][1] = A[1][0] = 1, A[1][1] = 0;
    B[0][0] = B[1][1] = 1, B[0][1] = B[1][0] = 0;
    LL mod = BSGS(A, B);
    int len = strlen(str);
    LL n = 0;
    for (int i = 0; i < len; ++i)
        n = (n * 10ll + str[i] - '0') % mod;
    write(binpow(A, n)[1][0]);
    return 0;
}
```

---

## 作者：RaymondFang (赞：11)

[P4000 斐波那契数列](https://www.luogu.com.cn/problem/P4000)

题目就是要求 $f_n \text{ mod } p$ 的值。如果尝试着用矩阵乘法，明显会T的很惨，因为 $n\le 10^{30000000}$。

约定：题目中的 $p$ 在下文记作 $m$，防止与泛指质数的字母 $p$ 弄混淆。

## 计算斐波那契数列循环节

**结论 1**：斐波那契数列对 $m$ 取模后必定是周期数列。

证明：考虑
$$
(F_1,F_2),(F_2,F_3),(F_3,F_4),\cdots,(F_{p^2+1},F_{p^2+2})
$$
共 $m^2+1$ 组两个相邻的斐波那契数组成的数对。一个正整数模 $m$ 只有 $0,1,\cdots,m-1$ 这 $m$ 个结果，故一个数对中两个数模 $m$ 共有 $m^2$ 种情况，由抽屉原理可得上面 $m^2+1$ 组数对必然至少两个是相同的。从而它们后面所生成的模意义下的斐波那契数列也是相同的。

从而存在 $i,j(i<j)$，使得 $F_i \equiv F_j$ 并且 $F_{i+1} \equiv F_{j+1}$。则数列的循环周期为 $j-i+1$（不一定是最小正周期），令其为 $k$。那么对于任意自然数 $i$，都有 $F_i=F_{i+k}=F_{i+2k}=\cdots$，即斐波那契数列对 $m$ 取模后必然是周期数列。

**皮萨诺周期**（Pisano periods, [OEIS A001175](http://oeis.org/A001175)）：模 $m$ 意义下的斐波那契数列的最小正周期被称为皮萨诺周期。为了方便表示，将其记作 $\text{Pi}_m$。

事实上，有 $\text{Pi}_m \le 6m$，当且仅当 $m=2 \times 5^k (k \in \mathbb N)$ 时取等号。（我也不知道怎么证明，貌似对这道题有一点优化的作用，不过没有太大用处）

**结论 2**：若 $a,b$ 互质，则 $\text{Pi}_{ab}=\text{lcm}(\text{Pi}_a,\text{Pi}_b)$。

正确性显然。

#### Part 1. 当 $m$ 为素数

我们知道斐波那契数列的通项公式
$$
F_n=\frac{1}{\sqrt 5}\left(\left(\frac{1+\sqrt 5}{2}\right)^n-\left(\frac{1-\sqrt 5}{2}\right)^n\right)
$$
由于里面有一个 $\sqrt 5$，所以我们得分类讨论。

**结论 3**：对于任意奇素数 $p$ 使得 $x^2\equiv 5 \pmod p$ 有非 $0$ 解，则 $p-1$ 是模 $p$ 斐波那契数列的周期。即 $\text{Pi}_p | p-1$。

证明：此时 $\sqrt{5},\dfrac 12$ 在模 $p$ 下都有意义。那么有
$$
\begin{aligned}
F_n&=\frac{1}{\sqrt 5}\left(\left(\frac{1+\sqrt 5}{2}\right)^n-\left(\frac{1-\sqrt 5}{2}\right)^n\right) \\
&\equiv \frac{1}{\sqrt 5}\left(\left(\frac{1+\sqrt{5}}{2}\right)^{n+\varphi(p)}-\left(\frac{1-\sqrt 5}{2}\right)^{n+\varphi(p)}\right) \\
&\equiv F_{n+p-1}
\end{aligned}
$$
即周期为 $p-1$。

在代码编写当中，判断依据可以写 ```if(qpow(5,(p-1)/2,mod)==1)```。当然，写 ```if(p%5==1||p%5==4)``` 是更好的选择。事实上，这种情况下 $p \equiv 1,4 \pmod 5$。

下面给出证明：由 $x^2 \equiv 5 \pmod p$ 存在非 $0$ 解，则有 $\left(\dfrac{5}{p}\right)=1$，其中 $\left(\dfrac{a}{p}\right)$ 是勒让德符号。由二次互反律（它的证明我不想写了，有亿点复杂，可以在网上搜）
$$
\displaystyle\left(\frac{p}{q}\right)\left(\frac{q}{p}\right)=(-1)^{\frac{p-1}2\frac{q-1}2}
$$
可以得到 $\left(\dfrac{5}{p}\right)\left(\dfrac{p}{5}\right)=(-1)^{2\times\frac{p-1}2}$，即 $\left(\dfrac p5\right)=1$，也就是说方程 $x^2 \equiv p \pmod 5$ 有非 $0$ 解，即 $p \equiv 1,4 \pmod 5$。

**结论 4**：对于任意奇素数 $p$ 使得 $x^2\equiv 5 \pmod p$ 无解，则 $2p+2$ 是模 $p$ 斐波那契数列的周期。即 $\text{Pi}_p|2p+2$。

证明：此时 $\sqrt{5}$ 在模 $p$ 下无意义。即 $5^{\frac{p-1}2} \equiv -1 \pmod p$，也就是 $\sqrt 5^{p-1} \equiv -1 \pmod p$。

对斐波那契数列通项公式进行二项式展开：
$$
\begin{aligned}
F_n&=\frac{1}{2^n\sqrt 5}\left(\sum\limits_{i=0}^n\dbinom{n}{i}\sqrt 5^i-\sum\limits_{i=0}^n\dbinom{n}{i}(-1)^i\sqrt 5^i\right) \\
&=\frac{1}{2^n\sqrt 5}\left(\sum\limits_{i=0}^{\left\lfloor\frac{n-1}2\right\rfloor}\dbinom{n}{2i+1}\cdot 2 \cdot \sqrt 5^{2i+1}\right) \\
&=\frac{1}{2^{n-1}\sqrt 5}\sum\limits_{i=0}^{\left\lfloor\frac{n-1}2\right\rfloor}\dbinom{n}{2i+1}\sqrt 5^{2i+1} \\
&=\frac{1}{2^{n-1}\sqrt 5}\left(\dbinom{n}{1}\sqrt 5+\dbinom{n}{3}\sqrt 5^3+\cdots+\dbinom{n}{2\left\lfloor\frac{n-1}2\right\rfloor+1}\sqrt 5^{\left(2\left\lfloor\frac{n-1}2\right\rfloor+1\right)}\right)
\end{aligned}
$$
那么有
$$
\begin{gathered}
F_{2p}=\frac{1}{2^{2p-1}\sqrt 5}\left(\dbinom{2p}1\sqrt 5+\dbinom{2p}3\sqrt 5^3+\cdots+\dbinom{2p}{2p-1}\sqrt 5^{2p-1}\right) \\
F_{2p+1}=\frac{1}{2^{2p}\sqrt 5}\left(\dbinom{2p}1\sqrt 5+\dbinom{2p}3\sqrt 5^3+\cdots+\dbinom{2p}{2p-1}\sqrt 5^{2p-1}\right)
\end{gathered}
$$
通过观察可以得到模 $p$ 之后 $F_{2p}$ 后面括号内只有 $\dbinom{2p}p \equiv 2 \pmod p$ 保留了下来，其余的组合数均含 $p$ 因子；$F_{2p+1}$ 后面括号内只有 $\dbinom{2p+1}1 \equiv 1 \pmod p$、$\dbinom{2p+1}p \equiv 2 \pmod p$、$\dbinom{2p+1}{2p+1} \equiv 1 \pmod p$ 三者保留了下来，其余组合数均含 $p$ 因子。故通过费马小定理可得
$$
\begin{aligned}
F_{2p}&\equiv\frac{1}{2^{2p-1}\sqrt 5}\cdot \dbinom{2p}p\sqrt 5^p \\
&\equiv \left(\frac 12\right)^{2(p-1)}\cdot \frac12 \cdot2 \cdot (-1) \\
&\equiv-1 \pmod p \\
F_{2p+1}&\equiv\frac{1}{2^{2p}\sqrt 5}\left(\dbinom{2p+1}1\sqrt 5+\dbinom{2p+1}p\sqrt 5^p+\dbinom{2p+1}{2p+1}\sqrt 5^{2p+1}\right) \\
&\equiv \left(\frac 12\right)^{2(p-1)}\cdot\frac 14\cdot\left(1+2\cdot\sqrt 5^{p-1}+1\cdot\sqrt 5^{2p}\right) \\
&\equiv\frac{1-2+5^p}4 \\
&\equiv\frac{1-2+5}4 \\
&\equiv 1 \pmod p
\end{aligned}
$$
而又因为 $F_1=F_2=1$ 得出 $F_{-1}=1,F_{-2}=-1$，也就是 $F_{2p} \equiv F_{-2}$ 且 $F_{2p+1} \equiv F_{-1}$，所以周期为 $2p+2$。

同理，通过二次互反律，可以得到 $p \equiv 2,3 \pmod 5$。

### 但是！！！

我们忽略了两种情况。如果 $p=2$，那么 $\dfrac12$ 没有意义；如果 $p=5$，那么 $x^2\equiv 5 \pmod p$ 会有 $x=0$ 这个解。所以，对于 $p=2$ 或 $p=5$ 这两个情况，我们要特判。不难得到，$\text{Pi}_2=3,\text{Pi}_5=20$。（当然，如果有些人出于信仰用 $114$ 和 $5140$ 也无大碍，只要是 $3$ 和 $20$ 的倍数即可，[以此为证](https://www.luogu.com.cn/record/115346160)）

#### Part 2. 当 $m=p^k \ (p \in \mathbb P, k \in \mathbb N)$

**结论 5**：若 $a \equiv 1 \pmod{p}$，那么 $a^{p^k} \equiv 1 \pmod{p^{k+1}}$。

事实上，可以通过升幂定理的特殊形式证明：

1. 当 $p$ 为奇素数，有 $v_p(a^{p^k}-1)=v_p(a-1)+v_p(p^k)=v_p(a-1)+k$。而 $a-1 \equiv 0 \pmod p \Rightarrow v_p(a-1) \ge 1$ 得到 $v_p(a^{p^k}-1)\ge k+1$，即 $a^{p^k}-1 \equiv 0 \pmod{p^{k+1}}$。
2. 当 $p=2$，有 $v_2(a^{p^k}-1)=v_2(a-1)+v_2(a+1)+v_2(p^k)-1=v_2(a-1)+v_2(a+1)+k-1$。由 $a \equiv 1 \pmod 2$ 可得 $a$ 为奇数，则 $a+1$ 是偶数，也就是 $v_2(a+1) \ge 1$。所以 $v_2(a^{p^k}-1) \ge 1+1+k-1=k+1$，也就是 $a^{p^k}-1 \equiv 0 \pmod{p^{k+1}}$。

关于升幂定理的内容以及证明见文末。

考虑数学归纳法。令 $a^{p^k}=rp^{k+1}+1$，由二项式展开得到：
$$
\begin{aligned}
a^{p^{k+1}}&=\left(a^{p^k}\right)^p \\
&=\sum\limits_{i=0}^p \dbinom{p}{i} r^ip^{(k+1)i}
\end{aligned}
$$
然而当 $i \ge 2$ 时 $p^{(k+1)i} \equiv 0 \pmod{p^{k+2}}$，所以：
$$
\begin{aligned}
a^{p^{k+1}}&\equiv\dbinom{p}{0}+\dbinom{p}{1}rp^{k+1} \\
&\equiv 1+rp^{k+2} \\
&\equiv 1
\end{aligned}
\pmod{p^{k+2}}
$$
即证。

**结论 6**：对于素数 $p$，有
$$
\text{Pi}_{p^{k-1}}|M \iff \text{Pi}_{p^k}|Mp
$$
特别地，
$$
M=\text{Pi}_{p^{k-1}} \iff Mp=\text{Pi}_{p^k}
$$
证明：令 $x_1=\dfrac{1+\sqrt 5}2, x_2=\dfrac{1-\sqrt 5}2$，由于 $F_M=\dfrac{1}{\sqrt 5}\left(x_1^M-x_2^M\right) \equiv 0 \pmod{p^{k-1}}$，且 $F_{M+1}=\dfrac{1}{\sqrt 5}\left(x_1^{M+1}-x_2^{M+1}\right) \pmod{p^{k-1}}$。

所以有 $x_1^M \equiv x_2^M \pmod{p^{k-1}}$ 且 $1 \equiv \dfrac{1}{\sqrt 5}\left(x_1^M \cdot x_1-x_2^M\cdot x_2\right) \equiv \dfrac{1}{\sqrt 5}x_1^M\left(x_1-x_2\right) \equiv x_1^M $。即 $x_1^M \equiv x_2^M \equiv 1 \pmod{p^{k-1}}$。以上步骤反方向也可推导，所以：
$$
\text{Pi}_{p^{k-1}}|M \iff x_1^M \equiv x_2^M \equiv 1 \pmod{p^{k+1}}
$$
而由 **结论 5** 可以得到 $x_1^{Mp}\equiv x_2^{Mp} \equiv 1 \pmod{p^k}$，即：
$$
\text{Pi}_{p^{k-1}}|M \iff x_1^M \equiv x_2^M \equiv 1 \pmod{p^{k+1}} \iff x_1^{Mp} \equiv x_2^{Mp} \equiv 1 \pmod{p^k} \equiv \text{Pi}_{p^k}|Mp
$$
即证。因为周期等价，所以最小正周期也等价。

换句话说，要求模 $p^k$ 意义下的斐波那契数列的周期长，只需用模 $p$ 意义下的周期长乘以 $p^{k-1}$ 即可。

#### Part 3. 当 $m$ 为任意正整数

通过 **结论 2** $a \bot b \Rightarrow \text{Pi}_{ab}=\text{lcm}(\text{Pi}_a,\text{Pi}_b)$，我们只需将 $m$ 变成 $\prod\limits_{i=0}^kp_i^{c_i}$ 的形式，在一个一个求 $\text{lcm}$ 即可。

### 总结

1. 对模数 $m$ 进行质因数分解。
2. 对于 $m$ 每个 $p_i^{c_i}$，求出其周期长。
3. 求周期长的最小公倍数。
4. 把 $n$ 读入后模周期长得到 $n'$，求出 $F_{n'}$。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
long long mod;
void read(string& s){
    char ch=getchar();
    while(!isdigit(ch)) ch=getchar();
    while(isdigit(ch)){
        s+=ch;
        ch=getchar();
    }
}
long long read(){
    long long s=0,f=1;
    char ch=getchar();
    while(!isdigit(ch)){
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(isdigit(ch)){
        s=s*10+(ch-'0');
        ch=getchar();
    }
    return s*f;
}
void write(const long long& x){
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
inline long long gcd(long long a, long long b){
    if(b==0) return a;
    else return gcd(b,a%b);
}
inline long long lcm(long long a, long long b){
    return a/gcd(a,b)*b;
}
inline long long qpow(long long a, long long b){
    long long ans=1;
    while(b){
        if(b&1) ans=ans*a;
        a=a*a;
        b>>=1;
    }
    return ans;
}
pair<long long, long long> f(long long k){ // 递推式求斐波那契数列第 n 项，时间复杂度 O(log n)，常数比矩乘小
    if(k==0) return {0,1};
    pair<long long,long long> p=f(k/2);
    long long tp1=p.first*((2*p.second%mod-p.first%mod+mod)%mod)%mod;
    long long tp2=(p.first*p.first%mod+p.second*p.second%mod)%mod;
    if(k&1) return {tp2,(tp1+tp2)%mod};
    else return {tp1,tp2};
}
inline long long getp(long long p){ // 求模 p 意义下周期长
    if(p==2) return 3;
    else if(p==5) return 20;
    else if(p%5==1||p%5==4) return p-1;
    else return 2*p+2;
}
inline long long getpk(long long p, long long k){ // 求模 p^k 意义下周期长
    return getp(p)*qpow(p,k-1);
}
inline long long get(long long x){ // 求模 x 意义下周期长
    long long ans=1;
    for(int i=2;i*i<=x;i++){ // 分解质因数
        if(x%i==0){
            int cnt=0;
            while(x%i==0) x/=i,cnt++;
            ans=lcm(ans,getpk(i,cnt));
        }
    }
    if(x!=1) ans=lcm(ans,getp(x));
    return ans;
}
int main(){
    read(s);
    mod=read();
    if(mod==1){
        puts("0");
        return 0;
    }
    long long circle=get(mod);
    long long n=0;
    for(int i=0;i<s.size();i++) n=(n*10+(s[i]-'0'))%circle;
    write(f(n).first);
    return 0;
}
```

#### 关于 ```pair<long long, long long> f(long long)``` 函数：

这里没有用矩乘，而是用了这个递推式：
$$
\left\{
\begin{aligned}
&F_{2k}=F_k(2F_{k+1}-F_k) \\
&F_{2k+1}=F_k^2+F_{k+1}^2
\end{aligned}
\right.
$$
而这是极好证明的：

令矩阵 $P=\begin{bmatrix} 0 & 1 \\ 1 & 1 \end{bmatrix}$，则有 $P^n=\begin{bmatrix} F_{n-1} & F_n \\ F_n & F_{n+1} \end{bmatrix}$，即 $\begin{bmatrix} F_{2n} & F_{2n+1} \end{bmatrix}=\begin{bmatrix} F_n & F_{n+1} \end{bmatrix} P^n$ 可以得出 $\begin{bmatrix} F_{2n} & F_{2n+1} \end{bmatrix}=\begin{bmatrix} F_n & F_{n+1} \end{bmatrix}\begin{bmatrix} F_{n-1} & F_n \\ F_n & F_{n+1} \end{bmatrix}$，也就是说
$$
\left\{
\begin{aligned}
&F_{2n}=F_n\left(F_{n-1}+F_{n+1}\right)=F_n\left(F_{n+1}-F_n+F_{n+1}\right)=F_n\left(2F_{n+1}-F_n\right) \\
&F_{2n+1}=F_n^2+F_{n+1}^2
\end{aligned}
\right.
$$
即证。

#### 关于升幂定理

记 $v_p(n)$ 为素数 $p$ 在整数 $n$ 质因数分解后出现的个数，即 $p^{v_p(n)} | n$ 而 $p^{v_p(n)+1} \nmid n$。

1. $p$ 为奇素数

   前提：$n \in \mathbb N_+, p \nmid a, p \nmid b, a \equiv b \pmod p$。则有：
   $$
   v_p(a^n-b^n)=v_p(a-b)+v_p(n)
   $$
   证明：设 $n=p^km$，其中 $\gcd(p,m)=1$，则 $k=v_p(n)$。

   所以 $a^n-b^n=a^{p^km}-b^{p^km}=(a^{p^k}-b^{p^k})(a^{m-1}+a^{m-2}b+\cdots+b^{m-1})$。

   而由 $a \equiv b \pmod p$ 得 $a^{m-1}+a^{m-2}b+\cdots+b^{m-1} \equiv m \cdot a^{m-1} \pmod p$，而其中 $p \nmid m, p \nmid a^{m-1}$，所以 $p \nmid ma^{m-1}$。

   问题转而分析 $a^{p^k}-b^{p^k}$。若 $k=0$，则 $v_p(a^n-b^n)=v_p(p \cdot ma^{m-1})=1$，$v_p(a-b)+v_p(n)=1+0=1$，命题成立；若 $k>0$，记 $c=a^{p^{k-1}},d=b^{p^{k-1}}$。

   则 $a^{p^k}-b^{p^k}=c^p-d^p=(c-d)(c^{p-1}+c^{p-2}d+\cdots+d^{p-1})$。而显然，由 $c \equiv d \pmod p$ 得到 $c^{p-1}+c^{p-2}d+\cdots+d^{p-2} \equiv p\cdot c^{p-1} \equiv 0 \pmod p$，也就是它能被 $p$ 整除。

   令 $d=c+rp$。由二项式定理可得：
   $$
   \begin{aligned}
   c^{p-1}+c^{p-2}d+\cdots+d^{p-1}&=\frac{d^p-c^p}{d-c} \\
   &=\frac{(c+kp)^p-c^p}{kp} \\
   &=\frac{\dbinom{p}{1}c^{p-1}kp+\dbinom{p}{2}c^{p-2}(kp)^2+\cdots+\dbinom{p}{p}c^0(kp)^p}{kp} \\
   &=\dbinom{p}1c^{p-1}+\dbinom{p}2c^{p-2}kp+\cdots+\dbinom{p}p(kp)^{p-1} \\
   &\equiv \dbinom{p}1c^{p-1} \pmod{p^2} \\
   &\equiv pc^{p-1} \pmod{p^2} \\
   &\equiv p(sp+1) \pmod{p^2} \text{ (Fermat's Little Theorem)}\\
   &\equiv 1 \pmod{p^2}
   \end{aligned}
   $$
   即它不能被 $p^2$ 整除。也就是说，$v_p(c^{p-1}+c^{p-2}d+\cdots+d^{p-1})=1$。从而有
   $$
   \begin{aligned}
   v_p(a^{p^k}-b^{p^k})&=v_p(a^{p^{k-1}}-b^{p^{k-1}})+1 \\
   &=v_p(a^{p^{k-2}}+b^{p^{k-2}})+2 \\
   &=\cdots \\
   &=v_p(a^{p^0}-b^{p^0})+k \\
   &=v_p(a-b)+v_p(n)
   \end{aligned}
   $$
   即证。

2. $p=2$

   前提：$n \in \mathbb N_+$，且 $a,b$ 均为奇数。那么若 $n$ 为奇数，则：
   $$
   v_2(a^n-b^n)=v_2(a-b)
   $$
   若 $n$ 为偶数，则：
   $$
   v_2(a^n-b^n)=v_2(a-b)+v_2(a+b)+v_2(n)-1
   $$
   证明：设 $n=2^km$，其中 $m$ 为奇数，则 $k=v_2(n)$。同理，有 $a^n-b^n=a^{2^km}-b^{2^km}=(a^{2^k}-b^{2^k})(a^{m-1}+a^{m-2}b+\cdots+b^{m-1})$，且 $a^{m-1}+a^{m-2}b+\cdots+b^{m-1}$ 是奇数。当 $k=0$，即 $n$ 为奇数，定理显然正确；当 $k>0$，同理记 $c=a^{2^{k-1}},d=b^{2^{k-1}}$，有 $a^{2^k}-b^{2^k}=c^2-d^2=(c-d)(c+d)$，由 $c,d$ 为奇数可得 $c+d$ 为偶数。然而当 $k>1$ 时 $c=a^{2^{k-1}}=(a^{2^{k-2}})^2$ 为平方数，同理 $d$ 也为平方数，则 $c,d \equiv 1 \pmod 4$，即 $c+d \equiv 2 \pmod 4$，因此 $c+d$ 中只含一个 $2$。即

   $$
   \begin{aligned}
   v_2(a^n-b^n)&=v_2\left(a^{2^k}-b^{2^k}\right) \\
   &=v_2(a^{2^{k-1}}-b^{2^{k-1}})+v_2(c+d) \\
   &=v_2\left(a^{2^{k-1}}-b^{2^{k-1}}\right)+1 \\
   &=v_2\left(a^{2^{k-2}}-b^{2^{k-2}}\right)+2 \\
   &= \cdots \\
   &=v_2\left(a^2-b^2\right)+(k-1)
   \end{aligned}
   $$

   当 $k=1$ 时，$a^2-b^2=(a-b)(a+b)$，在 $\dfrac{a+b}2$ 和 $\dfrac{a-b}2$ 之间必然有一个不被 $2$ 整除。这是因为 $\dfrac{a+b}2-\dfrac{a-b}2=b$ 是奇数，从而有 $v_p(a^2-b^2)=v_p(a-b)+v_p(a+b)$，也就是
   $$
   v_2(a^n-b^n)=v_2(a^2-b^2)+(k-1)=v_2(a-b)+v_2(a+b)+v_p(n)-1
   $$
   即证。

---

## 作者：1saunoya (赞：10)

题意:

求 $fib_n$， $n \leq 10^{30000000}$， $mod < 2^{31}$

~~诶好难，弃了~~

关于这题的一个重要结论：$fib$ 的循环节不会超过 $6 \times mod$。
~~（记住这个是循环节而不是单个数。）~~

然后怎么找循环节呢？

首先介绍一下生日悖论。

设 $E(n)$ 为 $n$ 个人中两个人生日相同的概率。

$E(n) = 1-\prod_{i=1}^{n-1}(\frac{365-i}{365})$

发现 $n = 23$ 的时候这个 $E(23) \geq \frac{1}{2}$ 了。

同样生日悖论用到这题上，两个数重复的概率相当大。

我们用光速乘的办法处理矩阵。

然后就没了？

```cpp
#include <bits/stdc++.h>
std::mt19937_64 rnd(time(0));
int mod;
const int MX = 1 << 18;
struct matrix {
	long long a[2][2];
	matrix() {
		memset(a, 0, sizeof(a));
	}
	long long * operator [](int x) {
		return a[x];
	}
	friend matrix operator * (matrix a, matrix b) {
		matrix res;
		for (int i = 0; i < 2; i++) {
			for (int j = 0; j < 2; j++) {
				for (int k = 0; k < 2; k++) {
					res[i][j] += a[i][k] * b[k][j];
				}
			}
		}
		for (int i = 0; i < 2; i++) {
			for (int j = 0; j < 2; j++) {
				res[i][j] %= mod;
			}
		}
		return res;
	}
} T[2][1 << 18 | 1];
int main() {
	std::ios_base::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::string s;
	std::cin >> s;
	std::cin >> mod;
	T[0][0][0][0] = T[0][0][1][1] = 1;
	T[1][0][0][0] = T[1][0][1][1] = 1;
	T[0][1][0][1] = T[0][1][1][0] = T[0][1][1][1] = 1;
	for (int i = 2; i <= MX; i++) {
		T[0][i] = T[0][i - 1] * T[0][1];
	}
	T[1][1] = T[0][MX];
	for (int i = 2; i <= MX; i++) {
		T[1][i] = T[1][i - 1] * T[1][1];
	}
	std::map <unsigned long long, long long> loop;
	long long length = 0;
	while (true) {
		long long a = (rnd() << 28 >> 28);
		matrix res = T[0][a & (MX - 1)] * T[1][a >> 18];
		unsigned long long val = ((1ull * res[0][0]) << 32ull) | res[0][1];
		if (loop.find(val) != loop.end()) {
			length = std::abs(loop[val] - a);
			break;
		}
		loop[val] = a;
	}
	long long n = 0;
	for (char c : s) {
		n = (n * 10 + (c ^ '0')) % length;
	}
	std::cout << (T[0][n & (MX - 1)] * T[1][n >> 18])[0][1] << '\n';
	return 0;
}
```

---

## 作者：loser_seele (赞：4)

考虑采用一个学术界尚未被证明但是数据范围内是正确的引理：对于模数为质数的幂的情况，设周期为 $ f(p^k) $，则 $ f(p^k)=f(p) \times p^{k-1} $。

于是可以考虑对这个数质因数分解之后分别求出周期之后取 $\operatorname{lcm}$ 即可。

对于 $ f(p) $ 的求法：当 $ p \bmod 10 = 1 $ 或者 $ p \bmod 10 = 9 $ 时计算 $ f(x-1) $，否则计算 $ 2 \times (p+1) $ ，可知这样得到的结果一定是斐波那契数列的一个循环节（但不一定是最小循环节），然后暴力枚举所有可行的质因子分解，如果循环节内包含更小的循环节则更新答案，注意用矩阵快速幂计算斐波那契数列的值。

其他的题解用的质因数分解都是 $ \mathcal{O}(\sqrt{p}) $ 的，其实可以用 Pollard-rho 算法做到更快地进行质因数分解之后计算循环节，时间复杂度可以优化到 $ \mathcal{O}(p^{1/4}) $。（其实有一篇题解也是这个做法，但感觉没讲清楚）

最后直接把项数对最小循环节取模后做一遍正常的矩阵快速幂即可。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define gc c=getchar()
#define r(x) read(x)
#define ll long long
#define int long long
template<typename T>
inline void read(T&x)
{
    x=0;T k=1;char gc;
    while(!isdigit(c)){if(c=='-')k=-1;gc;}
    while(isdigit(c)){x=x*10+c-'0';gc;}x*=k;
}
#define li inline
#define re register
inline int add(int a,int b,int p)
{
	a+=b;
	if(a>=p)
    	a-=p;
	return a;
}
inline int mul(int a,int b,int mod)
{
	return a*b%mod;
}
ll pow(ll a, ll b, ll m) 
{
  ll ans = 1;
  for (a %= m; b; b >>= 1, a = mul(a, a, m))
    if (b & 1) 
    	ans = mul(ans, a, m);
  return ans;
}
ll gcd(ll a,ll b)
{
	return b?gcd(b,a%b):a;
}
ll lcm(ll a,ll b)
{
	return a/gcd(a,b)*b;
}
bool MR_check(ll a, ll p, ll s, int d) 
{
  ll k = pow(a, s, p);
  if (k == 1) 
  	return true;
  for (; d; --d, k = mul(k, k, p)) 
  {
    if (k == p - 1) 
    	return true;
    if (k == 1) 
    	return false;
  }
  return k == 1;
}
bool MR(ll x) 
{
  static const int cnt = 12;
  static const int p[cnt] = { 2, 3, 5, 7, 11, 13, 17, 19, 61, 2333, 4567, 24251 };
  if (x == 1) 
  	return false;
  ll s = x - 1; 
  int d = 0;
  while (!(s & 1)) 
  	++d, s >>= 1;
  for (int i = 0; i < cnt; ++i) 
  {
    if (x % p[i] == 0) 
    	return x == p[i];
    if (!MR_check(p[i], x, s, d)) 
    	return false;
  }
  return true;
}
namespace Pollard_Rho 
{
ll PR_check(ll c, ll p) 
{
  ll y = rand() % p, z = y;
  int k = 1, j = 0;
  while(1145141919810) 
  {
    z = (mul(z, z, p) + c) % p;
    ll t = gcd(p, std::abs(z - y));
    if (t > 1) 
    	return t;
    if (++j == k) 
    	y = z, k <<= 1;
  }
}
void factor_(ll x, std::vector<ll> &v) 
{
  if (x == 1) 
  return;
  if (MR(x)) { v.push_back(x); return; }
  ll y = x;
  while (y == x) y = PR_check(rand() % x, x);
  factor_(y, v);
  factor_(x / y, v);
}
void factor(ll x, std::vector<ll> &v) 
{
  v.clear();
  if (!(x & 1)) { v.push_back(2); x /= (x & -x); }
  factor_(x, v);
  std::sort(v.begin(), v.end());
  v.erase(std::unique(v.begin(), v.end()), v.end());
}
}
using Pollard_Rho::factor;
struct fib 
{
  ll a, b; 
  fib(ll a, ll b) : a(a), b(b) {}
};
fib mul(const fib &u, const fib &v, ll m) 
{
  ll x = mul(u.a, v.a, m), y = mul(u.b, v.b, m),
     z = mul(u.a + u.b, v.a + v.b, m);
  return fib((x + y) % m, (z - x + m) % m);
}
bool check_period(ll d, ll m) 
{
  fib ans(1, 0), a(0, 1);
  for (; d; d >>= 1, a = mul(a, a, m))
    if (d & 1) ans = mul(ans, a, m);
  return ans.a == 1 && ans.b == 0;
}
inline int query(int x)
{
	if(x==2)
    	return 3;
	if(x==3)
    	return 8;
	if(x==5)
    	return 20;
	ll t = (x % 10 == 1 || x % 10 == 9) ? x - 1 : 2 * (x + 1);
  	vector<ll> d;
  	factor(t, d);
  	for (auto g : d)
    	while (!(t % g) && check_period(t / g, x))
      	t /= g;
  	return t;
}
inline ll solve(int n)
{
	ll ans=1;
    	vector<int>d;
    	factor(n, d);
    	for(auto res:d)
    	{
    	int p=1;
    	while(n%res==0)
    	n/=res,p*=res;
    	ans=lcm(ans,p/res*query(res));
    	}
	return ans;
}
signed main()
{
    ios::sync_with_stdio(0);
    string s;
    int p;
    cin>>s>>p;
    n=2;
    m=p;
    int per=solve(p);
    f.g[1][1]=1;f.g[1][2]=1;
    f.g[2][1]=1;f.g[2][2]=0;
    for(int i=0;i<s.size();i++)
    k*=10,k+=(s[i]-'0'),k%=per;
    if(k==0)
    k+=per;
    solve();
}
```


---

## 作者：Great_designer (赞：3)


最终核心代码只有这一小段。因子分解可以用Pollard-Rho，计算斐波那契数可以用快速幂。别的没有特别高级的算法。

```c

const unsigned long long Rest[6] = {0, 1, 3, 8, 6, 20};

unsigned long long g(unsigned long long p)
{
    if (p <= 5)
    {
        return Rest[p];
    }
    if (p % 5 == 1 || p % 5 == 4)
    {
        return p - 1;
    } else
    {
        return (p + 1) << 1;
    }
}

struct prime
{
    unsigned long long p;
    int times;
};

struct prime pp[2048];
int pptop;

unsigned long long get_cycle_from_mod(unsigned long long mod)
{
    pptop = 0;
    unsigned long long n = mod;
    srand(time(nullptr));
    while (n != 1)
    {
        __int128_t factor = (__int128_t) 10000000000 * 10000000000;
        min_factor(n, &factor);
        struct prime temp;
        temp.p = factor;
        temp.times = 0;
        while (!(n % factor))
        {
            n /= factor;
            temp.times++;
        }
        pp[pptop] = temp;
        pptop++;
    }
    unsigned long long m = 1;
    int it;
    for (it = 0; it < pptop; ++it)
    {
        m = lcm(m, g(pp[it].p) * qpow2(pp[it].p, (unsigned long long) pp[it].times - 1));
    }
    return m;
}

```

原理还是寻找斐波那契数列的循环节。只是，不强求去寻找最小循环节，而是找到一个不太大的循环节就够了。

斐波那契数列的循环节（取模意义下）称为“皮萨诺周期”[OEIS A001175](http://oeis.org/A001175)，很容易在OEIS上找到。更多内容可以参见OEIS。

最终用到的高级结论有3条。证明这些结论需要用到二次剩余。后两条印象里是《命题人讲座·初等数论》（冯志刚著）某章的例题。这书暂时不在手头……

**如果M是模$p^{k-1}$的周期，那么Mp是模$p^k$的周期。**

**对于$p\equiv 1,4 \pmod 5$，p-1是模$p$的周期。**

**对于$p\equiv 2,3 \pmod 5$，2p+2是模$p$的周期。**

注意：这里的周期都不一定是最小周期。

然后笔算（或口算）就能知道模5的斐波那契数列最小周期是20。这个就算作常识，不能算作高级结论了。


---

## 作者：August_Light (赞：2)

# P4000 斐波那契数列 题解

矩阵 BSGS。

[题目传送门](https://www.luogu.com.cn/problem/P4000)

**请注意数据范围**。

确保你要找的不是：
- [B2064 斐波那契数列](https://www.luogu.com.cn/problem/B2064)（递推）
- [P1962 斐波那契数列](https://www.luogu.com.cn/problem/P1962)（矩阵快速幂）

## 题意简述

求 $\text{fib}_n \bmod p$。

$n \le 10^{3 \times 10^7}, p < 2^{31}$。

## 前置知识

$\pi(p)$ 为斐波那契数列在模 $p$ 意义下最小循环节长度。

最重要的前置知识：$\pi(p) \le 6p$。
- [P4994 终于结束的起点](https://www.luogu.com.cn/problem/P4994)

## 解法

[不是首创](https://rusun.blog.luogu.org/solution-p4000)。

定义两个向量 / 方阵在模 $p$ 意义下同余，当且仅当对应位置上的数在模 $p$ 意义下同余。

不难发现：

$$\begin{bmatrix} \text{fib}_{i+1} \\ \text{fib}_{i} \end{bmatrix} \equiv \begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}^{i-j} \begin{bmatrix} \text{fib}_{j+1} \\ \text{fib}_{j} \end{bmatrix} \pmod p$$

若 $i \ne j$，当 $\begin{bmatrix} \text{fib}_{i+1} \\ \text{fib}_{i} \end{bmatrix} \equiv \begin{bmatrix} \text{fib}_{j+1} \\ \text{fib}_{j} \end{bmatrix} \pmod p$ 时（即循环节出现，为 $i-j$），且 $i-j$ 最小时，有：

$$\begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}^{\pi(p)} \equiv \begin{bmatrix} 1 & 0 \\ 0 & 1 \end{bmatrix} \pmod p$$

可用 BSGS 算法求解 $\pi(p)$。

### BSGS

BSGS 算法（大步小步算法）常用于求解这样的方程：

$$A^x \equiv B \pmod p$$

```cpp
ll BSGS(ll a, ll b) {
    umap<ll, ll> mp;
    ll t = sqrt(MOD) + 1;
    ll cur = 1;
    for (ll i = 1; i <= t; i++) {
        (cur *= a) %= MOD;
        mp[b * cur % MOD] = i;
    }
    // cur == pow(a, t)
    ll cur2 = cur;
    for (ll i = 1; i <= t; i++) {
        if (mp.find(cur2) != mp.end())
            return i * t - mp[cur2];
        (cur2 *= cur) %= MOD;
    }
    return -1; // No Solution
}
```

求出的 $x$ 保证是模意义下最小的解。

~~这个算法过于简单，我感觉看代码比讲解更容易理解，所以不讲解了。~~

此题就是把 $A,B$ 从模意义下的数变为了矩阵，求解是一样的原理。

需要注意：$\pi(p)=0$ 确实是这个方程的解，但是不是我们想要的。需要改一点点，具体看代码。

## 总结

- 主流做法：矩阵光速幂 & 生日悖论
  - 缺点：时间复杂度：$O(\sqrt n)$。瓶颈：光速幂预处理、生日悖论期望复杂度
  - 缺点：难以想到
  - 缺点：求出的不是最短循环节
  - （个人因素）缺点：[我写挂了](https://www.luogu.com.cn/discuss/755936)
- 数论做法：二次剩余
  - 优点：时间复杂度：$O(\sqrt n)$（可用 PR 优化）。瓶颈：分解质因数
  - 缺点：推导难度大
  - 缺点：求出的不是最短循环节
- [神仙](https://rusun.blog.luogu.org/solution-p4000)做法：矩阵 BSGS
  - 缺点：时间复杂度：$O(\sqrt n)$。瓶颈：BSGS
  - 优点：非常容易想到
  - 优点：代码简单
  - 优点：求出的是最短循环节

## 代码

码风非常好！

注：哈希表用了 `unordered_map`，可能会被卡。

坑点：题目全文没说 $n$ 可以等于 $0$，但是确实有 $n=0$ 的数据存在。

```cpp
#include <bits/stdc++.h>
#define umap unordered_map
using namespace std;
typedef long long ll;
typedef unsigned long long ull;

string S;
ll MOD;

const int L = 2;
const ull BASE = 13331;
struct Matrix {
    ll M[L+1][L+1];
    ll *operator[](int p) {
        return M[p];
    }
    void clear() {
        memset(M, 0, sizeof M);
    }
    void reset() {
        clear();
        for (int i = 1; i <= L; i++)
            M[i][i] = 1;
    }
    Matrix friend operator*(Matrix A, Matrix B) {
        Matrix C; C.clear();
        for (int i = 1; i <= L; i++)
            for (int k = 1; k <= L; k++)
                for (int j = 1; j <= L; j++)
                    (C[i][j] += A[i][k] * B[k][j] % MOD) %= MOD;
        return C;
    }
    ull hs() { // hash
        ull ret = 0;
        for (int i = 1; i <= L; i++)
            for (int j = 1; j <= L; j++)
                ret = ret * BASE + M[i][j];
        return ret;
    }

};
Matrix qpow(Matrix A, ll b) {
    Matrix Ret; Ret.reset();
    while (b) {
        if (b & 1)
            Ret = Ret * A;
        A = A * A;
        b >>= 1;
    }
    return Ret;
}

ll BSGS(Matrix A, Matrix B) {
    umap<ull, ll> mp;
    ll t = sqrt(MOD * 6) + 1;
    Matrix Cur; Cur.reset();
    for (ll i = 1; i <= t; i++) {
        mp[(Cur * B).hs()] = i-1;
        Cur = A * Cur;
    }
    Matrix Cur2 = Cur;
    for (ll i = 1; i <= t; i++) {
        if (mp.find(Cur2.hs()) != mp.end())
            return i * t - mp[Cur2.hs()];
        Cur2 = Cur * Cur2;
    }
    return -1;
}

Matrix A, I;
void init() {
    A[1][1] = 1; A[1][2] = 1;
    A[2][1] = 1; A[2][2] = 0;

    I[1][1] = 1; I[1][2] = 0;
    I[2][1] = 0; I[2][2] = 1;
}

ll fib(ll n) {
    if (n == 0)
        return 0;
    return qpow(A, n-1)[1][1];
}

int main() { ios::sync_with_stdio(0); cin.tie(0);
    cin >> S >> MOD;
    if (MOD == 1) {
        cout << 0 << endl;
        return 0;
    }
    init();
    ll pi = BSGS(A, I);
    ll n = 0;
    for (auto c : S)
        n = (n * 10 + (c - '0')) % pi;
    cout << fib(n) << endl;
    return 0;
}
```


---

## 作者：Kreado (赞：2)

[题目传送门。](https://www.luogu.com.cn/problem/P4000)

#### 思路

首先你需要知道[什么是pisano周期](https://oi-wiki.org/math/combinatorics/fibonacci/)。

对于一个斐波那契数 $n$，我们求 $n$ 数模 $p$ 的最小循环节 $f(n)$ 方法如下。

把 $n$ 质因子分解，即 $n=\prod p_i^{\alpha_i}$。

有 $f(n)=\operatorname{lcm}(f(p_i^{\alpha_i}))$。

这个很好证明：

根据性质，$Fib_{f(n)}\equiv 0 \pmod p\Leftrightarrow \forall i\in[1,s],Fib_{f(n)}\equiv 0 \pmod {p_i^{\alpha_i}}$ 

因此 $\forall i\le s,f(p_i^{\alpha_i})|f(n)$。

所以有 $f(n)=\operatorname{lcm}(f(p_i^{\alpha_i}))$。

有一个玄学的定理，$f(n)=f(p_i)\times p_i^{\alpha_i-1}$。

对于 $f(n)$ 求我们利用如下定理：假如 $5$ 是模 $p$ 的二次剩余，那么循环节的的长度是 $p-1$ 的因子，否则，循环节的长度是 $2(p+1)$ 的因子。

那么对于 $5$ 及以下的 $f(n)$ 直接暴力求即可，$f(2)=3,f(3)=8,f(5)=20$。

$f$ 函数代码：

```cpp
ll f(ll n){
    if(n==2) return 3;
    if(n==3) return 8;
    if(n==5) return 20;
    if(ksm(5,(n-1)/2,n)==1)return n-1;
    return n*2+2;
}
```

但是 $f(n)=f(p_i)\times p_i^{\alpha_i-1}$ 还是一个数学猜想，并没有具体证明，目前只证明了是约数，但是在 $p\le 10^9$ 内是可以保证正确性的。

因此，你可以在 $O(\sqrt {p})$ 的时间复杂度内算出 pisano 周期，接下来的就是用矩阵快速幂算就行。

推荐习题：

[P4994](https://www.luogu.com.cn/problem/P4994)，可以说 pisano 周期入门吧。

[SP12007](https://www.luogu.com.cn/problem/SP12007)，pisano 模板题，注意看题解。

[SP13419](https://www.luogu.com.cn/problem/SP13419)，pisano 模板题，注意要加上 pollard-rho 优化质因数分解。

---

## 作者：zhenjianuo2025 (赞：0)

### Solve

前置结论：模数为 $p$ 的斐波那契数列循环节长度 $\le 6\cdot p$。

如果 $i\ne j$，$f_i=f_j$ 且 $f_{i+1}=f_{j+1}$，意味着找到了循环节，循环节的长度是 $|i-j|$ 的因子。

考虑随机化。任意随机一个位置 $i$ 计算 $f_i,f_{i+1}$，把 $((f_{i},f_{i+1}),i)$ 存进哈希表。若哈希表中有两个相同的元素，我们就找到了循环节长度的某个倍数。由于我们并不需要知道循环节的具体长度，此时就可以停止寻找。

由于循环节长度 $\le 6\cdot p$，我们一次随机相当于随机了一个 $[0,6\cdot p)$ 中的数。根据生日悖论可知，这样出现重复数字的期望次数是 $\sqrt{p}$ 级别的。

实现上，计算 $f_i,f_{i+1}$ 可以使用矩阵乘配合光速幂 $\mathcal{O}(1)$ 计算。

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define fi first
#define se second
#define pb push_back
#define int long long
int n, mod, high = (1ll << 36), base = (1ll << 18);
map<unsigned int, int> mp;
mt19937_64 rnd(time(0));
#define rand rnd
struct Matrix {
	int n, m, a[5][5];
	int* operator [] (int k) { return a[k]; }
	Matrix() {
		n = m = 0;
		memset(a, 0, sizeof a);
	}
	Matrix(int q) {
		n = m = q;
		memset(a, 0, sizeof a);
		for (int i = 1; i <= n; i++) a[i][i] = 1;
	}
} init[2][(1ll << 18) + 5];
Matrix operator * (const Matrix a, const Matrix b) {
	Matrix c;
	c.n = a.n, c.m = b.m;
	for (int i = 1; i <= c.n; i++)
		for (int j = 1; j <= c.m; j++)
			for (int k = 1; k <= a.m; k++)
				c.a[i][j] = (c.a[i][j] + a.a[i][k] * b.a[k][j]) % mod; 
	return c;
} 
Matrix power(const int &x) {
	return init[0][x % base] * init[1][x / base];
}
char str[30000010];
int read(int mod) {
	int num = 0;
	int len = strlen(str);
	for (int i = 0; i < len; i++)
		if (isdigit(str[i])) {
		    num = num * 10 + str[i] - '0';
		    while (num >= mod) num -= mod;
		}
	return num;
}
signed main() {
    srand((unsigned)time(0));
	cin >> str;
	cin >> mod;
	Matrix tmp;
	tmp.n = tmp.m = 2; tmp[1][1] = tmp[1][2] = tmp[2][1] = 1; tmp[2][2] = 0;
	init[0][0] = Matrix(2);
	for (int i = 1; i <= base; i++) init[0][i] = init[0][i - 1] * tmp;
	init[1][0] = Matrix(2);
	for (int i = 1; i <= base; i++) init[1][i] = init[1][i - 1] * init[0][base];
	Matrix pre;
	pre.n = 2, pre.m = 1; pre[1][1] = pre[2][1] = 1;
	int len = 0;
	while (true) {
		int p = rand() % high;
		Matrix now = power(p - 1) * pre;
		unsigned int con = (now[1][1] << 32ll) + now[2][1];
		if (mp.find(con) != mp.end() && mp[con] != p) {
			len = abs(p - mp[con]);
			break;
		} else mp[con] = p;
	}
	n = (read(len) + len - 1) % len + 1;
	if (n == 1 || n == 2) {
		cout << 1 % mod << "\n";
		return 0;
	}
	cout << (power(n - 2) * pre)[1][1] << "\n";
	return 0;
} 
```


---


# 【模板】多项式乘法逆

## 题目背景

注意：本题并不属于中国计算机学会划定的提高组知识点考察范围。

## 题目描述

给定一个多项式 $F(x)$ ，请求出一个多项式 $G(x)$， 满足 $F(x) * G(x) \equiv 1 \pmod{x^n}$。系数对 $998244353$ 取模。



## 说明/提示

对于 $100\%$ 的数据，$1 \leq n \leq 10^5$，$ 0 \leq a_i \leq 10^9$。

## 样例 #1

### 输入

```
5
1 6 3 4 9```

### 输出

```
1 998244347 33 998244169 1020```

# 题解

## 作者：litble (赞：67)

[戳我有惊喜](https://blog.csdn.net/litble/article/details/79828428)

如果多项式F只有一项，那么显然$G_0$就是$F_0$的逆元。
若有n项，递归求解。

假如我们已知$F(x)H(x) \equiv 1 \pmod{x^{\lceil \frac{n}{2} \rceil}}$

又显然$F(x)G(x) \equiv 1 \pmod{x^{\lceil \frac{n}{2} \rceil}}$

那么$F(x)(G(x)-H(x))\equiv 1 \pmod{x^{\lceil \frac{n}{2} \rceil}}$

即$G(x)-H(x)\equiv 1 \pmod{x^{\lceil \frac{n}{2} \rceil}}$

两边同时平方。由于$G(x)-H(x)$在模$x^{\lceil \frac{n}{2} \rceil}$为0，则其0次项到$\lceil \frac{n}{2} \rceil-1$次项都为0。平方后的多项式记为P，则$P_i= \sum_{j=0}^i (G(x)-H(x))_j (G(x)-H(x))_{i-j}$，显然$(G(x)-H(x))_j$和$(G(x)-H(x))_{i-j}$至少有一项的次数小于$\lceil \frac{n}{2} \rceil$，为0，所以：

$G(x)^2+H(x)^2-2G(x)H(x) \equiv 0 \pmod{x^n}$

两边同时乘F(x)，再由$F(x)G(x) \equiv 1 \pmod{x^n}$可得：$G(x) \equiv 2H(x)-F(x)H(x)^2 \pmod{x^n}$

用NTT来做多项式乘法即可解决本题。

时间复杂度是$O(nlogn)$的

```cpp
#include<bits/stdc++.h>
using namespace std;
int read() {
	int q=0;char ch=' ';
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9') q=q*10+ch-'0',ch=getchar();
	return q;
}
#define RI register int
const int mod=998244353,G=3,N=2100000;
int n;
int a[N],b[N],c[N],rev[N];
int ksm(int x,int y) {
	int re=1;
	for(;y;y>>=1,x=1LL*x*x%mod) if(y&1) re=1LL*re*x%mod;
	return re;
}
void NTT(int *a,int n,int x) {
	for(RI i=0;i<n;++i) if(i<rev[i]) swap(a[i],a[rev[i]]);
	for(RI i=1;i<n;i<<=1) {
		RI gn=ksm(G,(mod-1)/(i<<1));
		for(RI j=0;j<n;j+=(i<<1)) {
			RI t1,t2,g=1;
			for(RI k=0;k<i;++k,g=1LL*g*gn%mod) {
				t1=a[j+k],t2=1LL*g*a[j+k+i]%mod;
				a[j+k]=(t1+t2)%mod,a[j+k+i]=(t1-t2+mod)%mod;
			}
		}
	}
	if(x==1) return;
	int ny=ksm(n,mod-2); reverse(a+1,a+n);
	for(RI i=0;i<n;++i) a[i]=1LL*a[i]*ny%mod;
}
void work(int deg,int *a,int *b) {
	if(deg==1) {b[0]=ksm(a[0],mod-2);return;}
	work((deg+1)>>1,a,b);
	RI len=0,orz=1;
	while(orz<(deg<<1)) orz<<=1,++len;
	for(RI i=1;i<orz;++i) rev[i]=(rev[i>>1]>>1)|((i&1)<<(len-1));
	for(RI i=0;i<deg;++i) c[i]=a[i];
	for(RI i=deg;i<orz;++i) c[i]=0;
	NTT(c,orz,1),NTT(b,orz,1);
	for(RI i=0;i<orz;++i)
		b[i]=1LL*(2-1LL*c[i]*b[i]%mod+mod)%mod*b[i]%mod;
	NTT(b,orz,-1);
	for(RI i=deg;i<orz;++i) b[i]=0;
}
int main()
{
	n=read();
	for(RI i=0;i<n;++i) a[i]=read();
	work(n,a,b);
	for(RI i=0;i<n;++i) printf("%d ",b[i]);
	return 0;
}
```

---

## 作者：Great_Influence (赞：56)

递归求解。

求模 $x^n$ 的逆元时，假设先求出了模 $x^{\lceil\frac{
n}{2}\rceil}$ 的逆元。

设模 $x^n$ 逆元为 $B$ ，模 $x^{\lceil\frac{n}{2}\rceil}$ 逆元为 $B'$ ，则：

$$A*B'\equiv 1\pmod {x^{\lceil\frac{z}{2}\rceil}}$$

且

$$A*B\equiv 1\pmod {x^{\lceil\frac{z}{2}\rceil}}$$

$$\therefore B'-B\equiv 0\pmod {x^{\lceil\frac{z}{2}\rceil}}$$

两边平方，则

$$(B'-B)^2\equiv 0\pmod {x^z}$$

拆项，

$$B'^2-2BB'+B^2\equiv 0\pmod {x^z}$$

左右同乘$A$,

$$AB'^2-2B'+B\equiv 0\pmod {x^z}$$

移项，得

$$B\equiv 2B'-AB'^2\pmod {x^z}$$

然后就得到了关于 $B$ 的递推式。因为从上向下递归很麻烦，所以从下向上递推。从 $x^1$ 开始推至 $x^{2^z}(2^z>=n)$ 即可。初值是 $B=\{A(0)^{-1}\}$ 。

利用 NTT 可以将多项式乘法优化至$n\log n$，利用主定理计算得总时间复杂度为$O(n\log n)$。

代码：

```cpp
#include<bits/stdc++.h>
#define For(i,a,b) for(i=(a);i<=(b);++i)
#define Forward(i,a,b) for(i=(a);i>=(b);--i)
#define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
#define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
using namespace std;
template<typename T>inline void read(T &x){
    T s=0,f=1;char k=getchar();
    while(!isdigit(k)&&k^'-')k=getchar();
    if(!isdigit(k)){f=-1;k=getchar();}
    while(isdigit(k)){s=s*10+(k^48);k=getchar();}
    x=s*f;
}
void file(void){
    #ifndef ONLINE_JUDGE
    freopen("water.in","r",stdin);
    freopen("water.out","w",stdout);
    #endif
}
const int MAXN=1<<20;
static int n,m,rev[MAXN],a[MAXN],b[2][MAXN];
inline void init()
{
    read(n);--n;
    Rep(i,0,n)read(a[i]);
    m=n<<1;
    for(n=2;n<=m;n<<=1);
}
inline void calrev(int n,int len)
{
    Rep(i,1,n-1)rev[i]=(rev[i>>1]>>1)|((i&1)<<len);
}
const int mod=998244353,gen=3;
inline int modu(long long x)
{
    if(x<mod)return x;
    return x-x/mod*mod;
}
inline int power(int x,int y)
{
    static int sum;
    for(sum=1;y;y>>=1,x=modu(1ll*x*x))
        if(y&1)sum=modu(1ll*sum*x);
    return sum;
}
static int P[MAXN],iv[MAXN];
inline void predone(int n)
{
    static int i,j;
    for(i=1,j=2;j<=n<<1;++i,j<<=1)
    {
        P[i]=power(gen,(mod-1)/j);
        iv[i]=power(P[i],mod-2);
    }
}
inline int modulo(int x,int y){x+=y;if(x>=mod)x-=mod;return x;}
inline void NTT(int x[],int type)
{
    Rep(i,1,n-1)if(i<rev[i])swap(x[i],x[rev[i]]);
    static int i,j,k,kk,t,w,wn,tk;
    for(i=2,tk=1;i<=n;i<<=1,++tk)
    {
        kk=i>>1;
        if(type==1)wn=P[tk];
        else wn=iv[tk];
        for(j=0;j<n;j+=i)
        {
            w=1;
            for(k=0;k<kk;++k,w=modu(1ll*w*wn))
            {
                t=modu(1ll*w*x[j+k+kk]);
                x[j+k+kk]=module(x[j+k],mod-t);
                x[j+k]=module(x[j+k],t);
            }
        }
    }
    if(type==-1)
    {
        int inv=power(n,mod-2);
        Rep(i,0,n)x[i]=modu(1ll*x[i]*inv);
    }
}
static int X[MAXN],Y[MAXN];
inline void mul(int x[],int y[])
{
    memset(X,0,sizeof X);
    memset(Y,0,sizeof Y);
    Rep(i,0,n>>1)X[i]=x[i],Y[i]=y[i];
    NTT(X,1);NTT(Y,1);
    Rep(i,0,n)X[i]=modu(1ll*X[i]*Y[i]);
    NTT(X,-1);
    Rep(i,0,n)x[i]=X[i];
}
static int c[MAXN];
inline void test(int z)
{
    memset(c,0,sizeof c);
    Rep(i,0,n)c[i]=a[i];
    mul(c,b[z]);Rep(i,0,m>>1)cout<<c[i]<<' ';puts("");
}
inline void solve()
{
    static int t=0,bas=1,len=1;
    b[0][0]=power(a[0],mod-2);
    n=4;
    calrev(n,len);
    while(bas<m)
    {
        t^=1;
        memset(b[t],0,sizeof b[t]);
        Rep(i,0,bas)b[t][i]=module(b[t^1][i]<<1,0);
        mul(b[t^1],b[t^1]);
        mul(b[t^1],a);
        Rep(i,0,bas)b[t][i]=module(b[t][i],mod-b[t^1][i]);
        bas<<=1;n<<=1;++len;
        if(bas<m)calrev(n,len);
    }
    Rep(i,0,m>>1)printf("%d ",b[t][i]);
    puts("");
}
int main(void){
    file();
    init();
    predone(n);
    solve();
    //cerr<<1.0*clock()/CLOCKS_PER_SEC<<endl;
    return 0;
}

```

---

## 作者：autoint (赞：41)

# 前言
学习了Great_Influence的递推实现，我给大家说一下多项式求逆严格的边界条件，因为我发现改动一些很小的边界条件都会使程序出错。怎么办，背代码吗？~~背代码是不可能，这辈子都不会背代码的。~~理解了边界条件就不会出错了。
# 分析
理论基础
$$A \times B \equiv 1 \qquad (\mod{x^n})$$
$$A \times B' \equiv 1 \qquad (\mod{x^{\frac{n}{2}}})$$
$$A \times (B-B') \equiv 0 \qquad (\mod{x^{\frac{n}{2}}})$$
$$B-B' \equiv 0 \qquad(\mod{x^{\frac{n}{2}}})$$
$$(B-B')^2 \equiv 0 \qquad(\mod{x^n})$$
$$B^2-2BB'+B'^2 \equiv 0 \qquad (\mod{x^n})$$
$$A(B^2-2BB'+B'^2) \equiv 0 \qquad (\mod{x^n})$$
$$B-2B'+AB'^2 \equiv 0 \qquad (\mod{x^n})$$
$$B \equiv 2B'-AB'^2 \qquad (\mod{x^n})$$

根据这个式子就可以倍增求多项式逆元了。但是如何倍增呢？或许你已兴冲冲地打出了NTT的板子，然后感觉无从下手。
# 代码
#### 前置是NTT
```cpp
inline void FFT(int*t,int lim,int type)
{
	for(rg int i=0;i<lim;++i)
		if(i<rev[i])
			swap(t[i],t[rev[i]]);
	for(rg int i=1;i<lim;i<<=1)
	{
		int gn=qpow(g,(mod-1)/(i<<1));
		if(type==-1)
			gn=qpow(gn,mod-2);
		for(rg int j=0;j<lim;j+=(i<<1))
		{
			int gi=1;
			for(rg int k=0;k<i;++k,gi=(ll)gi*gn%mod)
			{
				int x=t[j+k],y=(ll)gi*t[j+i+k]%mod;
				t[j+k]=module(x,y);
				t[j+i+k]=module(x,mod-y);
			}
		}
	}
	if(type==-1)
	{
		int inv=qpow(lim,mod-2);
		for(rg int i=0;i<lim;++i)
			t[i]=(ll)t[i]*inv%mod;
	}
}
```
- 为什么i从1开始小于lim？因为i是下层长度，这也是qpow里面i要乘2的原因。
- 为什么j从0开始小于lim？因为j是当前层的起始位置，而数组是base 0的。
- 为什么k从0开始小于i？因为k是当前合并区间的下标，为方便计算从0开始小于i。

#### 首先要封装多项式柯西乘法（卷积），减少代码量以及出错的可能性。
```cpp
int X[MAXN],Y[MAXN];

inline void mul(int*x,int*y,int lim)
{
	memset(X,0,sizeof(X));
	memset(Y,0,sizeof(Y));
	for(rg int i=0;i<(lim>>1);++i) // edit 2 lim>>1
		X[i]=x[i],Y[i]=y[i];
	FFT(X,lim,1);
	FFT(Y,lim,1);
	for(rg int i=0;i<lim;++i)
		X[i]=(ll)X[i]*Y[i]%mod;
	FFT(X,lim,-1);
	for(rg int i=0;i<lim;++i)
		x[i]=X[i];
}
```
- 为什么要把数组复制到XY上？因为避免自乘出错，自己乘自己会导致NTT了两次。

- 为什么第一层for循环边界为i<lim/2?因为乘出来度数是lim，乘之前度数是lim/2.

#### 然后实现三个辅助函数，分别是 快速幂、 快速模加 和 计算rev 。
```cpp
inline int qpow(int x,int k)
{
	int ans=1;
	while(k)
	{
		if(k&1)
			ans=(ll)ans*x%mod;
		x=(ll)x*x%mod,k>>=1;
	}
	return ans;
}

inline int module(int x,int y)
{
	x+=y;
	if(x>=mod)
		x-=mod;
	return x;
}

int rev[MAXN];

inline void calrev(int lim,int l)
{
	for(rg int i=1;i<lim;++i)
		rev[i]=(rev[i>>1]>>1)|((i&1)<<(l-1));
}
```
- 这三个东西的作用不用细说，主要是计算rev数组下表i可以从1开始的原因是rev[0]恒等于0.

#### 最后就是主菜求逆元了，可以用滚动数组减少空间
```cpp
int a[MAXN],b[2][MAXN];

int main()
{
//  freopen(".in","r",stdin);
//  freopen(".out","w",stdout);
	read(n);
	--n;
	for(rg int i=0;i<=n;++i)
		read(a[i]);
	int cur=0;
	b[cur][0]=qpow(a[0],mod-2);
	int bas=1,lim=2,len=1; // bas：下层长度（当前计算的） lim：上层长度（计算出来的） len：log_2(lim)
	calrev(lim,len);
	while(bas<=(n<<1)) // edit 1 <=
	{
		cur^=1;
		memset(b[cur],0,sizeof(b[cur]));
		for(int i=0;i<bas;++i)
			b[cur][i]=module(b[cur^1][i]<<1,0);
		mul(b[cur^1],b[cur^1],lim);
		mul(b[cur^1],a,lim);
		for(int i=0;i<bas;++i)
			b[cur][i]=module(b[cur][i],mod-b[cur^1][i]);
		bas<<=1,lim<<=1,++len;
		if(bas<=(n<<1))
			calrev(lim,len);
	}
	for(rg int i=0;i<=n;++i)
		printf("%d ",b[cur][i]);
//  fclose(stdin);
//  fclose(stdout);
    return 0;
}
```
- 由于这道题就是裸的求逆元，所以我就没封装求逆。其实封装也很简单，加个`void inv(int*a,int**b,int&cur,int n)`就行了cur要引用是因为需要知道算出来的结果是b数组的哪个
- 为什么第一个for循环边界是bas，第二个是lim？因为长度倍增了。另外mul里面也得用lim也是这个原因。
- 为什么bas<=2*n？因为...当前层的长度得覆盖、大于n...吗？其实不是。

## 为什么bas<=2*n？
考虑我们的数组范围。长度看似倍增了，实则不然。数组下标为0~bas-1，代表$\sum_{i=0}^{bas-1}a_ix^i$的各项系数，然而自乘之后最高项次数应变为2*(bas-1)而不是程序里面认为的2*bas-1，所以我们求出来的多项式其实有虚假成分。怎么处理？程序里面是不好更改的，没必要为此增加代码量和出错性。那么求大一点就好了，比如求到2*n，这样虚假成分不会影响到最终答案。

---

## 作者：echo6342 (赞：26)

多项式求逆是一个很多人选择背诵全文的算法。
```
#include<algorithm>
#include<cmath>
#include<complex>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<ctime>
#include<iomanip>
#include<iostream>
#include<map>
#include<queue>
#include<set>
#include<stack>
#include<vector>
#define rep(i,x,y) for(register int i=(x);i<=(y);++i)
#define dwn(i,x,y) for(register int i=(x);i>=(y);--i)
#define maxlen 100010
#define maxn (maxlen<<3)
#define LL long long
using namespace std;
int read()
{
	int x=0,f=1;char ch=getchar();
	while(!isdigit(ch)&&ch!='-')ch=getchar();
	if(ch=='-')f=-1,ch=getchar();
	while(isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
	return x*f;
}
void write(int x)
{
	if(x==0){putchar('0'),putchar('\n');return;}
	int f=0;char ch[20];
	if(x<0)putchar('-'),x=-x;
	while(x)ch[++f]=x%10+'0',x/=10;
	while(f)putchar(ch[f--]);
	putchar('\n');
	return;
}
const LL mod=998244353;
int f[maxn],g[19][maxn],tmp[maxn],n,tmpn,len,nown,nowlen,r[maxn];
int mul(int x,int y){int ans=1;while(y){if(y&1)ans=(LL)ans*(LL)x%mod;x=(LL)x*(LL)x%mod,y>>=1;}return ans;}
void dnt(int * a,int f)
{
	rep(i,1,nown-1)if(i<r[i])swap(a[i],a[r[i]]);
	for(int i=1;i<nown;i<<=1)
	{
		int wn=mul(3,(mod-1)/(i<<1)),x,y; 
		if(f==-1)wn=mul(wn,mod-2);
		for(int j=0;j<nown;j+=(i<<1))
		{
			int w=1;
			rep(k,0,i-1)
			{
				x=a[j+k],y=(LL)w*(LL)a[j+i+k]%mod;
				a[j+k]=((LL)x+(LL)y)%mod,a[j+k+i]=(((LL)x-(LL)y)%mod+(LL)mod)%mod;
				w=(LL)w*(LL)wn%mod;
			}
		}
	}
	if(f==-1){int inv=mul(nown,mod-2);rep(i,0,nown-1)a[i]=(LL)a[i]*(LL)inv%mod;}
}
int main()
{
	n=read();
	rep(i,0,n-1)f[i]=read()%mod;
	g[0][0]=mul(f[0],mod-2);
	for(len=0,tmpn=1;tmpn<n;len++,tmpn<<=1)
	{
		nown=tmpn<<1,nowlen=len+1;
		rep(i,0,nown-1)tmp[i]=f[i];
		nown=nown<<1,nowlen=nowlen+1;//一个nown次的多项式乘两个(nown/2)次的多项式，最高次为nown*2
		rep(i,1,nown-1)r[i]=(r[i>>1]>>1)|((i&1)<<(nowlen-1));
		rep(i,(tmpn<<1),nown-1)tmp[i]=0;
		dnt(g[len],1),dnt(tmp,1);
		rep(i,0,nown-1)g[len+1][i]=((2ll-(LL)tmp[i]*(LL)g[len][i])%mod+mod)*(LL)g[len][i]%mod;
		dnt(g[len+1],-1);
		rep(i,(tmpn<<1),nown-1)g[len+1][i]=0;
	}
	rep(i,0,n-1)printf("%d ",g[len][i]);
	return 0;
}
```
多项式求逆指对于函数$F(x)$，求$G(x)$，使在每一项系数模$p$时，有$F(x)*G(x)\equiv1(mod\space x^n)$

考虑倍增求$G(x)$

设$F(x)=f_0+f_1*x^1+..f_{n-1}*x^{n-1}$，$G(x)=g_0+g_1*x^1+..g_{n-1}*x^{n-1}$

当$n=1$时，有 $F(x)*f_0^{-1}\equiv1(mod\space x^n)$

假设已经求出 $H(x)$ 使 $F(x)*H(x)\equiv1(mod\space x^{\lceil\frac{n}{2}\rceil})$(1)

设 $H(x)=h_0+h_1*x^1+..h_{n-1}*x^{n-1}$

因为 $F(x)*G(x)\equiv1(mod\space x^n)$

所以 $F(x)*G(x)\equiv1(mod\space x^{\lceil\frac{n}{2}\rceil})$(2)

(2)-(1)，得 $F(x)*(G(x)-H(x))\equiv0(mod\space x^{\lceil\frac{n}{2}\rceil})$

两边同除 $F(x)$ ，得 $G(x)-H(x)\equiv0(mod\space x^{\lceil\frac{n}{2}\rceil})$

即 $\forall i\in [0,\lceil\frac{n}{2}\rceil),g_i-h_i=0$

那么就有 $(G(x)-H(x))^2\equiv0(mod\space x^n)$

这是因为 $(G(x)-H(x))^2$ 第 $i(i\in[0,n))$ 项系数为 $$\sum_{j=0}^{i}(g_j-h_j)*(g_{i-j}-h_{i-j})$$

因为 $i<n$，所以 $i-j,j$ 中一定有一个小于 $\lceil\frac{n}{2}\rceil$ ，即一定有一个为0，所以第 $i$ 项系数为$$\sum_{j=0}^{i}0=0$$
证毕
有这个结论就能得到 $G(x)^2-2*G(x)*H(x)+H^2(x)\equiv0(mod\space x^n)$

两边同乘 $F(x)$，得 $F(x)*G(x)^2-2*F(x)*G(x)*H(x)+F(x)*H^2(x)\equiv0(mod\space x^n)$

由 $F(x)*G(x)\equiv1(mod\space x^n)$，得 $G(x)-2*H(x)+F(x)*H^2(x)\equiv0(mod\space x^n)$

即 $G(x)\equiv2*H(x)-F(x)*H^2(x)(mod\space x^n)$

那么倍增+多项式乘法就可以进行多项式求逆了

[推一下自己的博客](https://www.cnblogs.com/xzyf/p/10031500.html)

---

## 作者：Gauss0320 (赞：20)

求
$$F(x)G(x)\equiv1\ ({\rm mod}\ x^n)$$
令
$$F(x)G_1(x)\equiv1\ ({\rm mod}\ x^{\left\lceil\frac{n}{2}\right\rceil})$$
作差可得
$$F(x)\big(G(x)-G_{1}(x)\big)\equiv0\ ({\rm mod}\ x^{\left\lceil\frac{n}{2}\right\rceil})$$
除去$F(x)$,得
$$G(x)-G_1(x)\equiv0\ ({\rm mod}\ x^{\left\lceil\frac{n}{2}\right\rceil})$$
两边平方，得
$$\big(G(x)-G_1(x)\big)^2\equiv0\ ({\rm mod}\ x^n)$$
展开有
$$G^2(x)-2G(x)G_1(x)+G^2_1(x)\equiv0\ ({\rm mod}\ x^n)$$
同时乘上$F(x)$，由定义，有
$$G(x)-2G_1(x)+F(x)G_1^2(x)\equiv0\ ({\rm mod}\ x^n)$$
求得递归式
$$G(x)\equiv2G_1(x)-F(x)G_1^2(x)\ ({\rm mod}\ x^n)$$
再提取一下公因式
$$G(x)\equiv G_1(x)\big(2-F(x)G_1(x)\big)\ ({\rm mod}\ x^n)$$
化简为常数项后直接求逆元即可
```cpp
#include <cstdio>
#include <iostream>
#define ll long long

using namespace std;
const int N = 3 * 1e+6 + 10, P = 998244353, G = 3, Gi = 332748118;
int n, m, lim = 1, L, rev[N];
ll a[N], b[N], c[N];

int read() {
	int x = 0, f = 1; char c = getchar();
	while(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}
	while(c >= '0' && c <= '9') x = (x<<1) + (x<<3) + c - '0', c = getchar();
	return x * f;
}
ll qpow(ll a, ll b) {
	ll prod = 1;
	while(b) {
		if(b & 1) prod = prod * a % P;
		a = a * a % P;
		b >>= 1;
	}
	return (prod + P) % P;
}
void NTT(ll *A, int inv) {
	for(int i = 0; i < lim; i++)
		if(i < rev[i]) swap(A[i], A[rev[i]]);
	for(int mid = 1; mid < lim; mid <<= 1) {
		ll tmp = qpow(inv == 1 ? G : Gi, (P - 1) / (mid << 1));
		for(int j = 0; j < lim; j += (mid << 1)) {
			ll omega = 1;
			for(int k = 0; k < mid; k++, omega = (omega * tmp) % P) {
				int x = A[j + k], y = omega * A[j + k + mid] % P;
				A[j + k] = (x + y) % P;
				A[j + k + mid] = (x - y + P) % P;
			}
		}
	}
	if(inv == 1) return;
	int ny = qpow(lim, P - 2);
	for(int i = 0; i < lim; i++) A[i] = (1LL * A[i] * ny + P) % P;
}
void PI(ll *F, ll *G, int n) {
	if(n == 1) {
		G[0] = qpow(F[0], P - 2);
		return;
	}
	PI(F, G, (n + 1) >> 1);
	lim = 1, L = 0;
	while(lim < (n << 1)) lim <<= 1, L++;
	for(int i = 1; i < lim; i++) 
		rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (L - 1));
	for(int i = 0; i < n; i++) c[i] = F[i];
	for(int i = n; i < lim; i++) c[i] = 0;
	NTT(c, 1), NTT(G, 1);
	for(int i = 0; i < lim; i++) 
		G[i] = ((2LL - G[i] * c[i] % P) + P) % P * G[i] % P;
	NTT(G, -1);
	for(int i = n; i < lim; i++) G[i] = 0;
}
int main()
{
	n = read();
	for(int i = 0; i < n; i++) 
		a[i] = (read() + P) % P;
	PI(a, b, n);
	for(int i = 0; i < n; i++)
		printf("%d ", b[i]);
	return 0;
}
```


---

## 作者：KAMIYA_KINA (赞：18)

## 多项式求逆

### Preface

本篇与其他的题解推导略有不同，主要使用了**牛顿迭代法**，虽然最后的式子都是一样的，但是该方法泛用性更加广泛一些。

### Description

已知 $F(x)$，要求出 $G(x) * F(x) \equiv 1 \pmod{x^n}$，系数对 $998244353$ 取模。

### Solution

对这个式子进行推导，我们将一个多项式变成一个简单的未知数，然后思考这个式子。

移项

$$
F(x) - \frac{1}{G(x)} \equiv 0 \pmod{x^n}
$$

这个东西可以用牛顿迭代公式计算。（OIer 们习惯性去直接背诵这个公式）

接下来是牛顿迭代的推导，不想看的同学可以直接快进到结论。

已知一个复合多项式

$$
G(F(x)) \equiv 0 \pmod{x^n}
$$

假设已知 $F_0(x)\equiv F(x) \pmod{x^{\lceil\frac{n}{2}\rceil}}$，求 $F_1(x) \equiv F(x) \pmod{x^n}$。

根据泰勒公式，在 $F_0(x)$ 处展开 $G(F(x))$。

$$
G(F(x)) = \sum_{i=0}^{\infty}\frac{G^{(i)}(F_0(x))}{i!}(F(x)-F_0(x))^i
$$

可以发现，$ F(x)-F_0(x) \equiv 0 \pmod{x^{\lceil\frac{n}{2}\rceil}}$，所以 $(F(x)-F_0(x))^k \equiv 0 \pmod{x^n}$ 在 $k \ge 2$ 的时候成立。

因此：

$$
G(F_1(x)) \equiv G(F_0(x)) + G'(F_0(x))(F_1(x) - F_0(x)) \pmod{x^n}
$$

又 $G(F_1(x)) \equiv 0 \pmod{x^n}$，整理得到：

$$
F_1(x)=F_0(x)-\frac{G(F_0(x))}{G'(F_0(x))}
$$

许多人熟知的牛顿迭代公式就是这个玩意了，然后这个东西的应用也非常简单。

以这个题目为例：

令 $H(t)=F(x)-\frac{1}{t}$，那么就可以得到：

$$
H(G(x)) \equiv 0 \pmod{x^n}
$$

然后套入牛顿迭代公式：

$$
G_1(x)=G_0(x)-\frac{H(G_0(x))}{H'(G_0(x))}
$$

将 $H(t) = F(x) - \frac{1}{t}$ 套回去，注意这里的 $F(x)$ 表示的是一个常数，那么就可以得到：

$$
G_1(x)=G_0(x) - \frac{F(x)-\frac{1}{G_0(x)}}{\frac{1}{G_0(x)^2}}
$$

化简一下可以得到：

$$
G_1(x)=G_0(x)(2-G_0(x)F(x))
$$

打个 NTT 求解一下就可以了。注意边界情况！

### code

~~~cpp
#include <bits/stdc++.h>

using namespace std;

#define int long long

#define FOR(i,a,b) for(int i=(a),i##i=(b);i<=i##i;i++)
#define ROF(i,a,b) for(int i=(a),i##i=(b);i>=i##i;i--)

#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++)
char buf[100000], *p1(buf), *p2(buf);
#define rd read()
inline int read() {
    int x = 0, f = 1;
    char ch = gc;
    while(!isdigit(ch)) {
        if(ch == '-') f = 0;
        ch = gc;
    }
    while(isdigit(ch)) {
        x = (x << 1) + (x << 3) + (ch ^ 48);
        ch = gc;
    }
    return f ? x : -x;
}

const int N = 3e5 + 1;
const int mod = 998244353, g = 3;

inline int ksm(int x, int y) {
    int ret = 1;
    for(; y; y >>= 1, x = x * x % mod)
        if(y & 1) ret = ret * x % mod;
    return ret;
}

int rev[N];

inline void NTT(int *a, int n, int typ) {
    for(int i = 0; i < n; i++) if(i < rev[i]) swap(a[i], a[rev[i]]);
    for(int i = 1; i < n; i <<= 1) {
        int gn = ksm(g, (mod - 1) / (i << 1));
        for(int j = 0, g0 = 1, x, y; j < n; j += (i << 1), g0 = 1) 
        for(int k = 0; k < i; k++, g0 = gn * g0 % mod) {
            x = a[j + k], y = a[i + j + k] * g0 % mod;
            a[j + k] = (x + y) % mod;
            a[i + j + k] = (x - y + mod) % mod;
        }
    }
    if(typ == 1) return ;
    int inv = ksm(n, mod - 2); reverse(a + 1, a + n);
    for(int i = 0; i < n; i++) a[i] = a[i] * inv % mod;
    return ;
}

void INV(int *b, int *a, int n) {
    if(n == 1) return b[0] = ksm(a[0], mod - 2), void();
    INV(b, a, (n + 1) >> 1);
    static int c[N];
    int len = 1, p = -1; while(len < (n << 1)) len <<= 1, p++;
    FOR(i, 1, len - 1) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << p);
    copy(a, a + n, c), fill(c + n, c + len, 0);
    NTT(c, len, 1), NTT(b, len ,1);
    FOR(i, 0, len - 1) b[i] = (2 - b[i] * c[i] % mod + mod) % mod * b[i] % mod;
    NTT(b, len, 0), fill(b + n, b + len, 0);
    return ;
}

int a[N], b[N], n;

#undef int

inline void work() {
    n = rd;
    FOR(i, 0, n - 1) a[i] = rd;
    INV(b, a, n);
    FOR(i, 0, n - 1) cout << b[i] << ' ';
    return ;
}

int main() {
    work();
    return 0;
} 
~~~

## 参考文章
* [Fuyuki 大佬](https://www.luogu.com.cn/blog/Fuyuki/dui-duo-xiang-shi-niu-dun-die-dai-suan-fa-di-yi-suo-li-xie)（修补了文中一些错误的公式）

* [超级大蒟蒻](https://www.luogu.com.cn/blog/juruo-4721/yi-suo-bei-wang) （这个人真的是太菜了）

---

## 作者：dblark (赞：16)

多项式Pascal题解·第二弹

直接倍增求就好了啦：$ G(x) = G'(x)(2 - F(x)G'(x)) $

代码写的巨丑，常数巨大，慎用……（由于是Pascal跑的就更慢了）

（其实把函数改成过程还是可以用一下的）

递推的代码：（听说递归跑的还比较快？）

```pas
type
  arr = array[0..524287] of longint;//定义多项式
const
  p  = 998244353;              //模数
  g  = 3;                      //原根
  gi = 332748118;
var
  a, b, pow, r: arr;
  n, i: longint;

  procedure swap(var x, y: longint);//交换
  var
    t: longint;
  begin
    t := x;
    x := y;
    y := t;
  end;

  function power(x, y: longint): longint;//快速幂
  begin
    power := 1;
    while y > 0 do
    begin
      if odd(y) then
        power := int64(power) * x mod p;
      x := sqr(int64(x)) mod p;
      y := y shr 1;
    end;
  end;

  function inv(x: longint): longint;//逆元
  begin
    exit(power(x, p - 2));
  end;

  procedure ntt(var a: arr; n, s: longint);//NTT，不详细写了
  var
    i, j, k, x, y, w: longint;
  begin
    for i := 0 to n - 1 do
      if i < r[i] then
        swap(a[i], a[r[i]]);
    i := 1;
    while i < n do
    begin
      j := 0;
      if s = 1 then
        w := power(g, (p - 1) div (i shl 1))
      else
        w := power(gi, (p - 1) div (i shl 1));
      pow[0] := 1;
      for k := 1 to i - 1 do
        pow[k] := int64(pow[k - 1]) * w mod p;
      while j < n do
      begin
        for k := 0 to i - 1 do
        begin
          x := a[j + k];
          y := int64(a[i + j + k]) * pow[k] mod p;
          a[j + k] := (x + y) mod p;
          a[i + j + k] := (x - y) mod p;
        end;
        Inc(j, i shl 1);
      end;
      i := i shl 1;
    end;
    if s = -1 then
    begin
      x := inv(n);
      for i := 0 to n - 1 do
        a[i] := (int64(a[i]) * x mod p + p) mod p;
    end;
  end;

  function inv(a: arr; n: longint): arr;//求逆元
  var
    t: arr;
    i, l, num: longint;
  begin
    num := 2;
    l := 1;
    inv[0] := inv(a[0]);       //先求初始项
    while num <= n shl 1 do
    begin
      num := num shl 1;
      Inc(l);
      //每次倍增都是num shr 1的长度，其他的都是误差，需要忽略（清零）
      for i := 0 to num - 1 do
        r[i] := (r[i shr 1] shr 1) or ((i and 1) shl (l - 1));
      for i := 0 to num shr 1 - 1 do//把a(f)复制下来，防止误差
        t[i] := a[i];
      ntt(inv, num, 1);
      ntt(t, num, 1);
      for i := 0 to num - 1 do //把这玩意用公式卷起来
        inv[i] := int64((p + 2 - int64(inv[i]) * t[i] mod p) mod p) * inv[i] mod p;
      ntt(inv, num, -1);
      for i := num shr 1 to num - 1 do//清零
        inv[i] := 0;
    end;
    for i := n + 1 to num shr 1 - 1 do//最后的清零
      inv[i] := 0;
  end;

begin                          //主程序，没什么好说的
  Read(n);
  for i := 0 to n - 1 do
    Read(a[i]);
  b := inv(a, n - 1);
  for i := 0 to n - 1 do
    Write(b[i], ' ');
  writeln;
end.
```

---

## 作者：VenusM1nT (赞：9)

本文收录于：[多项式算法学习笔记](https://venusnero.github.io/2019/03/19/poly_algorithm_note/)。

已知 $F(x)$，要求 $G(x)$ 令 $F(x)\times G(x)\equiv 1$。

采用递归的思想，假设我们现在求出了 $G'$：

$$F\times G'\equiv 1\ (\text{mod}\ \ x^{\lceil {n\over 2}\rceil})$$

则：

$$F\times G\equiv 1\ (\text{mod}\ \ x^{\lceil {n\over 2}\rceil})$$

相减得：

$$G'-G\equiv 0\ (\text{mod}\ \ x^n)$$

两边平方，拆开来：

$$G'^2-2GG'+G^2\equiv 0\ (\text{mod}\ \ x^n)$$

两边同乘上 $F$，因为 $F(x)\times G(x)\equiv 1\ ( \text{mod}\ \ x^n )$，所以：

$$FG'^2-2G'+G\equiv 0\ (\text{mod}\ \ x^n)$$

移项，则可得：

$$G=2G'-FG'^2\equiv 0\ (\text{mod}\ \ x^n)$$

递推式 get√，自下往上递归求解即可。

```cpp
void GetInv(int *f,int *g,int len)
{
    if(len==1)
    {
        g[0]=QuickPow(f[0],Mod-2);
        return;
    }
    GetInv(f,g,len+1>>1);
    lim=1;
    m=0;
    while(lim<(len<<1))
    {
        lim<<=1;
        m++;
    }
    for(int i=1;i<lim;i++) rev[i]=(rev[i>>1]>>1)|((i&1)<<(m-1));
    for(int i=0;i<len;i++) C[i]=f[i];
    for(int i=len;i<lim;i++) C[i]=0;
    NTT(C,1);
    NTT(g,1);
    for(int i=0;i<lim;i++) g[i]=((2ll-g[i]*C[i]%Mod)+Mod)%Mod*g[i]%Mod;
    NTT(g,-1);
    for(int i=len;i<lim;i++) g[i]=0;
}
```

---

## 作者：huangzirui (赞：8)

题意：

求多项式 $\ F(x)\ $ 的逆元。即求 $\ G(x)\ $ 令 $\ F(x)G(x) \equiv 1 \pmod{x^n} $

---

(算法：分治FFT)

(下面一律都把同余符号去掉了）

考虑关系式

$$F(x)G(x)=1$$

我们有：

对于所有的 $k\in [0,n]$ 

$$\sum\limits_{i+j=k}a_ib_j=[k=0]$$

对 $k=0$ 情况特殊处理后有

$$\sum\limits_{i+j=k}a_ib_j=0$$

---

考虑进行递推。

如果我们已经求出了前 $x-1$ 项，那么：

$$b_xa_0=\sum\limits_{i+j=x\ \&\&\ j \not=x}-a_ib_j$$

即：

$$b_x=\sum\limits_{i+j=x\ \&\&\ j \not=x}-a_ib_j\cdot\dfrac{1}{a_0}$$

于是分治FFT即可。时间复杂度 $Θ(n log^2n)$。

（注意卡常）

```cpp
#include<bits/stdc++.h>
#define ll long long
#define re register
using namespace std;
inline int read(){
	char c=getchar();int x=0,f=1;
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int maxn=400010;
const ll mod=998244353;
int i,j,k,n,m;
ll A[maxn],B[maxn],a[maxn],b[maxn];
ll M[25][2];
int R[maxn];
inline ll ksm(re ll sum,re int num){
	re ll ans=1;
	while(num){
		if(num&1)
			ans=ans*sum%mod;
		sum=sum*sum%mod;
		num>>=1;
	}return ans;
}
inline void NTT(int len,ll *a,bool op){
	for(re int i=0;i<=len;i++)
		if(i<R[i])swap(a[i],a[R[i]]);
	for(re int i=1,I=1;i<len;i<<=1,++I){
		ll Wn;if(op)Wn=0;else Wn=1;
//		if(op)Wn=3;else Wn=332748118;
//		Wn=ksm(Wn,(mod-1)/(i*2));
		Wn=M[I][Wn];
		for(re int j=0;j<len;j+=i<<1){
			ll w=1;
			for(re int k=0;k<i;k++,w=w*Wn%mod){
				int K=k+j;
				ll S1=a[K],S2=w*a[K+i]%mod;
				a[K]=(S1+S2)%mod;
				a[K+i]=(S1-S2+mod)%mod; 
			}
		}
	}
}
inline void solov(int len,int l,int r){
	NTT(len,A,1);NTT(len,B,1);
	for(re int i=0;i<=len;i++)A[i]=A[i]*B[i]%mod;
	NTT(len,A,0);
	for(re int i=(l+r)/2+1-l;i<=r-l;i++)A[i]=A[i]*ksm(len,mod-2)%mod;
}
ll T;
inline void work(int l,int r){
	if(l==r)return;
	int Mid=l+r>>1; 
	work(l,Mid);
	
	int x=Mid-l+1,y=n,len=1,L=0;
	while(len<=x<<1)len<<=1,++L;
	for(re int i=0;i<=len;i++)
		R[i]=(R[i>>1]>>1)+((i&1)<<L-1);
	
	B[0]=0;
	for(re int i=Mid-l+1;i<=len;i++)B[i]=0;
	for(re int i=min(len,n);i<=len;i++)A[i]=0;
	for(re int i=l;i<=Mid;i++)B[i-l]=b[i];
	for(re int i=0;i<min(len,n);i++)A[i]=a[i];
	solov(len,l,r);
	for(re int i=Mid+1;i<=r;i++)b[i]=(b[i]-A[i-l]*T%mod+mod)%mod;
	work(Mid+1,r);
	return;
}
int main(){
	cin>>n;
	for(i=1;i<=23;i++)
		M[i][0]=ksm(3,(mod-1)/(1<<i))%mod,M[i][1]=ksm(332748118,(mod-1)/(1<<i))%mod;
	for(i=1;i<=n;i++)a[i-1]=read();
	b[0]=ksm(a[0],mod-2);
	int L=1;
	T=ksm(a[0],mod-2);
	while(L<n)L<<=1;
	work(0,L-1);
	for(i=0;i<n;i++)printf("%lld ",b[i]);
	cout<<endl;
	return 0;
}
```

---

## 作者：Sai0511 (赞：7)

好题，证明的过程真的很妙。    
### 正文部分：    
题意：      
有两个多项式$A(x)$与$B(x)$，满足$A(x)*B(x)≡1(modx^n)$给出$A(x)$，求$B(x)$   

设$A(x)*B'(x)≡1(modx^{ceil{n/2}})$    
观察得知，这两者可相减，于是得到这个式子：    
$B(x)-B'(x)≡0(modx^{ceiln/2})$

将两边平方得到：
$B(x)^2+B'(x)^2-2BB'(x)≡0(modx^{n})$
不妨都乘$A$,则：
$B(x) +AB'(x)^2-2B'(x)≡0(modx^n)$    
移项得知：    
$B(x)=2B'(x)-AB'(x)^2$
同时提$B'$

则：$B(x)=B'(x)(2-AB'(x))$      
于是我们就找到了递归式，从上往下递归即可.
### My Code
```cpp
#include <bits/stdc++.h>
#define il inline
#define gc getchar
#define pc putchar
typedef int mi;
#define int long long
typedef long long LL;
const int MAXN = 1e6 + 10;
const LL p = 998244353;
using namespace std;
int n,m,i,j,k;
int R[MAXN],a[MAXN],b[MAXN],wn[MAXN];
namespace IO {
    il int read() {
        int res = 0;char c;bool sign = 0;
        for(c = gc();!isdigit(c);c = gc()) sign |= c == '-';
        for(;isdigit(c);c = gc()) res = (res << 1) + (res << 3) + (c ^ 48);
        return sign ? -res : res;
    }
}
using IO::read;
il int fpow(int a,int b,int mod = p) {
    int res = 1;
    while(b) {
        if(b & 1) res = (res * a) % mod;
        b >>= 1;a = (a * a) % mod;
    }
    return res;
}
il void ntt(LL a[],int len,int on) {
   for(int i = 0, j = 0; i < len; ++i) {
        if (i > j) swap(a[i], a[j]);
        for (int l = len >> 1; (j ^= l) < l; l >>= 1);
    }
    int id = 0;
    for(int i = 1;i < len;i <<= 1) {
        id++;
        for(int j = 0;j < len;j += i << 1) {
            LL w = 1;
            for(int k = 0;k < i;k++) {
                int x = a[j + k] % p;
                int y = w * a[j + k + i] % p;
                a[j + k] = (x + y) % p;
                a[j + k + i] = (x - y + p) % p;
                w = w * wn[id] % p;
            }
        }
    }
    if(!~on) {
        reverse(a + 1,a + len);
        int inv = fpow(len,p - 2,p);
        for(int i = 0;i < len;i++) a[i] = a[i] * inv % p;
    }
    return;
} 
void calc(int deg,LL *a,LL *b) {
    static LL tmp[MAXN];
    if(deg == 1) b[0] = fpow(a[0],p - 2);
    else {
        calc((deg + 1) >> 1,a,b);
        int _p = 1;
        while(_p < deg << 1) _p <<= 1;
        copy(a,a + deg,tmp);
        fill(tmp + deg,tmp + _p,0);
        ntt(tmp,_p,1);ntt(b,_p,1);
        for(int i = 0;i < _p;i++) {
            b[i] = (2 - b[i] * tmp[i] % p + p) % p * b[i] % p; 
        }
        ntt(b,_p,-1);fill(b + deg,b + _p,0);
    }
    return;
}
mi main() {
    for(int i = 0;i < 21;i++) wn[i] = fpow(3,(p - 1) / (1 << i),p);
    n = read();
    for(int i = 0;i < n;i++) a[i] = read();
    int li = 1,t = 0;while(li < n << 1) li <<= 1,t++;
    calc(n,a,b);
    for(int i = 0;i < n;i++) printf("%lld ",(b[i] + p) % p);
    return 0;
}
```


---

## 作者：feicheng (赞：0)

[$\text{cnblogs}$](https://www.cnblogs.com/hl-fc/p/15058515.html)

[$\text{Luogu Blogs}$](https://www.luogu.com.cn/blog/feicheng/solution-p4238)
## $\texttt{Description}$

给 $\operatorname{deg}=n$ 的多项式 $f$，求多项式 $g$，满足
$$
f*g\equiv 1 \pmod {x^n}
$$

系数对 $998244353$ 取模。

$\texttt{restrictions:}1\le n\le10^5$

## $\texttt{Solution}$

假设 $\operatorname{deg}=1$，则可以通过快速幂直接求出来，所以考虑递归。

假设我们已经求出 $h*f \equiv 1 \pmod {x^n}$，考虑如何转移到 $x^{2n}$

显然有 

$$
f*g\equiv 1\pmod {x^n}
$$

于是有

$$
f*(g-h)\equiv 0 \pmod {x^n}
$$

$$
g-h \equiv 0 \pmod {x^n}
$$

$$
(g-h)^2 \equiv 0 \pmod {x^{2n}}
$$

$$
g^2-2gh+h^2\equiv 0 \pmod {x^{2n}}
$$

同乘 $f$，有。

$$
g-2h+fh^2\equiv 0\pmod {x^{2n}}
$$

$$
g\equiv h(2+fh)\pmod {x^{2n}}
$$

即可求解。

## $\texttt{Code}$

```cpp
inline friend Poly Inv(Poly a) {
      if (a.size() == 1) {
        Poly tmp(1) ;
        return tmp[0] = ksm(a[0]),tmp ;
      }
      const int len = a.size() ;
      Poly ta = a; ta.resize((len + 1) >> 1) ;
      Poly tb = Inv(ta) ;
      Getrev(len << 1),a.resize(lim),tb.resize(lim),a.ntt(lim,1),tb.ntt(lim,1) ;
      for (int i = 0; i < lim; ++i) tb[i] = 1ll * tb[i] * (mod + 2 - 1ll * a[i] * tb[i] % mod) % mod ;
      return tb.ntt(lim,-1),tb.resize(len),tb ;
    }
```

---


# 公主の#19准备月考

## 题目背景

公主在玩完游戏后，也要月考了。（就算是公主也要月考啊QWQ）


## 题目描述

公主的文综太差了，全校排名1100+（全校就1100多人），她分析了好久，发现她如果把所有时间放在选择题上，得分会比较好一点。

文综题目共有n个，编号从1到n

公主给每个题目算出来了一个预估值Ai，她认为，一段连续题目的答案会在它们的预估值的gcd和lcm之间；有时候她的想法不同了，一些题目的预估值会改变；有时候，会出现多选题，多选题的答案数量就是一段连续题目答案的预估值的公约数的个数。

具体来说，对于一个数列，有四种操作：

L x y p 表示公主询问区间[x,y]的数字的lcm对p取模之后的值

G x y p 表示公主询问区间[x,y]的数字的gcd对p取模之后的值

C x y c 表示公主改变区间[x,y]的数字的值，统一为c

S x y p 表示公主询问区间[x,y]的数字的公因数个数对p取模之后的值

公主月考不能挂科，不然她就不能学习OI了（假的），所以请你帮帮她吧！


## 说明/提示

对于30%的数据，1<=n,q<=1000

对于另外20%的数据，1<=n<=1000，1<=q<=100000

对于另外20%的数据，1<=n<=100000，1<=q<=100000，保证没有修改操作

对于100%的数据，1<=n<=300000，1<=q<=300000

保证任何时刻每个题目的预估值都在[1,100]之间，答案取模之后不超过int


## 样例 #1

### 输入

```
10 10
42 68 35 1 70 25 79 59 63 65 
L 2 6 28
L 2 6 43
G 2 7 5
G 3 4 83
L 7 9 96
G 2 7 39
S 3 8 100
L 4 5 12
G 4 4 65
L 2 4 69```

### 输出

```
0
32
1
1
75
1
1
10
1
34```

# 题解

## 作者：Vingying (赞：8)

卡常大赛......
最后没开O2比开了O2还快？！

首先看题，求区间gcd和lcm，我们可以将这个区间内的每个数分解质因数，gcd的话对每个质数个数取min，lcm的话取max，然而直接线段树上每个节点存该质数出现多少次的话铁定MLE。

这题的数据范围很神奇：每个值在[1,100]以内，而且题目只让求gcd和lcm（S操作可以通过求gcd求得），所以这就启发我们：将质数压起来。

我们发现：2^6=64, 2^7=128>100，所以一个区间内2的个数不超过6，而6可以用三个二进制位表示（6=4+2+0，即110）；同理，3^4=81, 3^5>100，所以一个区间内3的个数不超过4，也用三个二进制位表示（4=4+0+0，即100）；这样以此类推，可以得到一个区间内所有质数及其个数可以用31个二进制位表示。

而这31个二进制位，正好对应一个int的范围。所以每个节点存两个int：lcm和gcd，表示当前区间取gcd时的质数及其个数，取lcm时的质数及其个数。

然后就是普通的区间修改、区间查询了。不过还是有一些细节要注意。

...而且我被我一开始的大常数吓着了QAQ

下面是代码（这道题目前最长代码QAQ）

```cpp
#include <stdio.h>
#include <string.h>
#include <cctype>
using namespace std;
typedef long long ll;
template <class _E> inline void read(_E &e){
    e=0;int ck=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')ck=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){e=(e<<1)+(e<<3)+(ch^48);ch=getchar();}
    e*=ck;
}
inline int max(int a,int b){if(a>b)return a;else return b;}
inline int min(int a,int b){if(a>b)return b;else return a;}
const int N=300050;int p;
inline int mi(int a,int b){ //快速幂 
    int ret=1;
    while(b){
        if(b&1)ret=(ret*a)%p;
        a=(a*a)%p;
        b>>=1;
    }
    return ret;
}
int n,Q,a[N],b[25],c1[25],c2[25],cnt[25];
//cnt,c1,c2都是用于保存当前值分解质因数后每个质数出现次数，
//不同地方用的数组不同 
//a数组为原数组，b数组含义见main函数 
int pri[]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97};//素数打表 

#define ls id<<1
#define rs id<<1|1
inline int cal(int tmp){ //对当前数分解质因数 
    int i=0;memset(cnt,0,sizeof cnt);
    while(tmp>1){
        if(tmp%pri[i]==0){
            tmp/=pri[i];
            cnt[i]++;
            continue;
        }
        i++;
    }
    int v=0;
    for(register int i=0;i<=24;++i)v|=(cnt[i]<<b[i]);
    return v;
}

/*线段树开始*/ 
struct seg{
    int l,r;
    int gcd,lcm,lazy;
}t[N<<2];
inline int callcm(int v1,int v2){ //对v1和v2求lcm 
    int ret=0,p1,p2;memset(c1,0,sizeof c1);memset(c2,0,sizeof c2);memset(cnt,0,sizeof cnt);
    c1[0]+=(1&v1)+(2&v1)+(4&v1);v1>>=3;
    c1[1]+=(1&v1)+(2&v1)+(4&v1);v1>>=3;
    c1[2]+=(1&v1)+(2&v1);v1>>=2;
    c1[3]+=(1&v1)+(2&v1);v1>>=2;
    for(register int i=p1=4;i<=24;++i,++p1){c1[i]+=(v1&1);v1>>=1;if(!v1)break;}if(p1==25)--p1;
    c2[0]+=(1&v2)+(2&v2)+(4&v2);v2>>=3;
    c2[1]+=(1&v2)+(2&v2)+(4&v2);v2>>=3;
    c2[2]+=(1&v2)+(2&v2);v2>>=2;
    c2[3]+=(1&v2)+(2&v2);v2>>=2;
    for(register int i=p2=4;i<=24;++i,++p2){c2[i]+=(v2&1);v2>>=1;if(!v2)break;}if(p2==25)--p2;
    int mx=max(p1,p2);
    for(register int i=0;i<=mx;++i)cnt[i]=max(c1[i],c2[i]);
    for(register int i=0;i<=mx;++i)ret|=(cnt[i]<<b[i]);
    return ret;
}
inline int calgcd(int v1,int v2){ //对v1和v2求gcd 
    int ret=0,p1,p2;memset(c1,0,sizeof c1);memset(c2,0,sizeof c2);memset(cnt,0,sizeof cnt);
    c1[0]+=(1&v1)+(2&v1)+(4&v1);v1>>=3;//质数2占的位 
    c1[1]+=(1&v1)+(2&v1)+(4&v1);v1>>=3;//质数3占的位 
    c1[2]+=(1&v1)+(2&v1);v1>>=2;//质数5占的位 
    c1[3]+=(1&v1)+(2&v1);v1>>=2;//质数7占的位 
    for(register int i=p1=4;i<=24;++i,++p1){c1[i]+=(v1&1);v1>>=1;if(!v1)break;}if(p1==25)--p1;
    c2[0]+=(1&v2)+(2&v2)+(4&v2);v2>>=3;//质数2占的位 
    c2[1]+=(1&v2)+(2&v2)+(4&v2);v2>>=3;//质数3占的位 
    c2[2]+=(1&v2)+(2&v2);v2>>=2;//质数5占的位 
    c2[3]+=(1&v2)+(2&v2);v2>>=2;//质数7占的位 
    for(register int i=p2=4;i<=24;++i,++p2){c2[i]+=(v2&1);v2>>=1;if(!v2)break;}if(p2==25)--p2;
    int mn=min(p1,p2);
    for(register int i=0;i<=mn;++i)cnt[i]=min(c1[i],c2[i]);
    for(register int i=0;i<=mn;++i)ret|=(cnt[i]<<b[i]);
    return ret;
}
inline void pushup(int id){
    t[id].gcd=calgcd(t[ls].gcd,t[rs].gcd);
    t[id].lcm=callcm(t[ls].lcm,t[rs].lcm);
}
inline void pushdown(int id){
    if(t[id].lazy){
        t[ls].lazy=t[rs].lazy=t[id].lazy;
        if(t[id].lazy==1)t[ls].gcd=t[ls].lcm=t[rs].gcd=t[rs].lcm=0;
		//若当前值为1，则gcd和lcm都为1，但线段树中的gcd和lcm中存的都是质数，
		//所以将值设为0 
        else t[ls].gcd=t[ls].lcm=t[rs].gcd=t[rs].lcm=cal(t[id].lazy);
        t[id].lazy=0;
    }
}
void build(int l,int r,int id){ //线段树建树 
    t[id].l=l,t[id].r=r;t[id].lazy=0;
    if(l==r){
        if(a[l]==1){t[id].gcd=t[id].lcm=0;return;}
        t[id].gcd=t[id].lcm=cal(a[l]);
        return;
    }
    int mid=(l+r)>>1;
    build(l,mid,ls);build(mid+1,r,rs);
    pushup(id);
}
void change(int L,int R,int v,int vv,int id){ //v为要改变的值，vv为v分解质因数后的值 
    int l=t[id].l,r=t[id].r;
    if(l>=L&&r<=R){
        t[id].lazy=v;
        if(v==1){t[id].gcd=t[id].lcm=0;return;}
        t[id].gcd=t[id].lcm=vv;
        return;
    }
    pushdown(id);
    int mid=(l+r)>>1;
    if(R<=mid)change(L,R,v,vv,ls);
    else if(L>mid)change(L,R,v,vv,rs);
    else{
        change(L,mid,v,vv,ls);
        change(mid+1,R,v,vv,rs);
    }
    pushup(id);
}
int qgcd(int L,int R,int id){ //查询gcd 
    int l=t[id].l,r=t[id].r;
    if(l>=L&&r<=R)return t[id].gcd;
    pushdown(id);
    int mid=(l+r)>>1;
    if(R<=mid)return qgcd(L,R,ls);
    else if(L>mid)return qgcd(L,R,rs);
    else return calgcd(qgcd(L,mid,ls),qgcd(mid+1,R,rs));
}
int qlcm(int L,int R,int id){ //查询lcm 
    int l=t[id].l,r=t[id].r;
    if(l>=L&&r<=R)return t[id].lcm;
    pushdown(id);
    int mid=(l+r)>>1;
    if(R<=mid)return qlcm(L,R,ls);
    else if(L>mid)return qlcm(L,R,rs);
    else return callcm(qlcm(L,mid,ls),qlcm(mid+1,R,rs));
}
/*线段树结束*/ 

int main(){
    b[0]=0,b[1]=3;b[2]=6,b[3]=8;int bit=10;
    for(register int i=4;i<=24;++i)b[i]=bit++; //计算当前质数在二进制位上的位置 
    read(n),read(Q);
    for(register int i=1;i<=n;++i)read(a[i]);
    build(1,n,1); //建树 
    
    while(Q--){
        char opt[2];int x,y;
        scanf("%s",opt);read(x),read(y),read(p);
        switch(opt[0]){
            case 'L':{
                int tmp=qlcm(x,y,1),ans=1,pos;memset(cnt,0,sizeof cnt);
                //pos为常数优化用的变量 
                cnt[0]+=(1&tmp)+(2&tmp)+(4&tmp);tmp>>=3;//质数2占的位 
                cnt[1]+=(1&tmp)+(2&tmp)+(4&tmp);tmp>>=3;//质数3占的位 
                cnt[2]+=(1&tmp)+(2&tmp);tmp>>=2;//质数5占的位 
                cnt[3]+=(1&tmp)+(2&tmp);tmp>>=2;//质数7占的位 
                for(register int i=pos=4;i<=24;++i,++pos){
                    cnt[i]+=(tmp&1);tmp>>=1;if(!tmp)break;
                }
                if(pos==25)--pos;
                /*这一部分为神奇的常数优化，因为从第5个质数开始，一个区间内仅会出现1个，所以不需要快速幂计算*/ 
                ans*=mi(pri[0],cnt[0]);
                ans*=mi(pri[1],cnt[1]);
                ans*=mi(pri[2],cnt[2]);
                ans*=mi(pri[3],cnt[3]);
                ans%=p;
                for(register int i=4;i<=pos;++i){
                	if(cnt[i])ans*=pri[i],ans%=p;
				}
				/*常数优化结束*/ 
                printf("%d\n",ans);
                break;
            }
            case 'G':{
                int tmp=qgcd(x,y,1),ans=1,pos;memset(cnt,0,sizeof cnt);
                //pos为常数优化用的变量 
                cnt[0]+=(1&tmp)+(2&tmp)+(4&tmp);tmp>>=3;//质数2占的位 
                cnt[1]+=(1&tmp)+(2&tmp)+(4&tmp);tmp>>=3;//质数3占的位 
                cnt[2]+=(1&tmp)+(2&tmp);tmp>>=2;//质数5占的位 
                cnt[3]+=(1&tmp)+(2&tmp);tmp>>=2;//质数7占的位 
                for(register int i=pos=4;i<=24;++i,++pos){
                    cnt[i]+=(tmp&1);tmp>>=1;if(!tmp)break;
                }
                if(pos==25)--pos;
                /*这一部分为神奇的常数优化，因为从第5个质数开始，一个区间内仅会出现1个，所以不需要快速幂计算*/ 
                ans*=mi(pri[0],cnt[0]);
                ans*=mi(pri[1],cnt[1]);
                ans*=mi(pri[2],cnt[2]);
                ans*=mi(pri[3],cnt[3]);
                ans%=p;
                for(register int i=4;i<=pos;++i){
                	if(cnt[i])ans*=pri[i],ans%=p;
				}
				/*常数优化结束*/ 
                printf("%d\n",ans);
                break;
            }
            case 'C':{
            	int vv=cal(p);//先计算一步，优化时间 
                change(x,y,p,vv,1);
                break;
            }
            case 'S':{
                int tmp=qgcd(x,y,1),ans=1,pos;memset(cnt,0,sizeof cnt);
                //pos为常数优化用的变量 
                cnt[0]+=(1&tmp)+(2&tmp)+(4&tmp);tmp>>=3;//质数2占的位 
                cnt[1]+=(1&tmp)+(2&tmp)+(4&tmp);tmp>>=3;//质数3占的位 
                cnt[2]+=(1&tmp)+(2&tmp);tmp>>=2;//质数5占的位 
                cnt[3]+=(1&tmp)+(2&tmp);tmp>>=2;//质数7占的位 
                for(register int i=pos=4;i<=24;++i,++pos){
                    cnt[i]+=(tmp&1);tmp>>=1;if(!tmp)break;
                }
                for(register int i=0;i<=pos;++i){
                    if(cnt[i])ans=ans%p*(cnt[i]+1)%p;
                    //计算答案，答案为每个质数出现次数+1之积 
                }
                printf("%d\n",ans%p);//因为写法问题，最后一定要mod p，否则p=1时GG 
                break;
            }
            default:{
                break;
            }
        }
    }
    return 0;
}
```

---

## 作者：玫葵之蝶 (赞：6)

## 官方题解

首先最后一个操作可以求个gcd直接求个约数个数

然后就是怎么维护lcm和gcd

我们可以线段树维护

然后对于每个数记录它的质因数的次数

然后合并就lcm取max，gcd取min，就好了

这样可以解决每次模数不同的问题

时间复杂度$O(nlog^2n)$

以上算法无法通过本题，除非你复杂度~~O(wys)~~

我们注意一个很有趣的地方，所有数字都在[1,100]之间

我们发现100以内质数只有25个，并且：

$2^7=128>100$

$3^5=243>100$

$5^3=125>100$

$7^3=343>100$

$11^2=121>100$

......

2,3需要三个二进制位记录

5,7需要两个二进制位记录

其他质数都只用一个二进制位记录

3*2+2*2+1*21=31

记录所有质数的次数只需要31位，刚好1个int就够

然后取min和max都可以用位运算优化

以上步骤可以将合并的复杂度优化至O(1)

时间复杂度$O(nlogn)$

这样可以通过本题

其实还有一种算法可以过，由于我数据的特殊性qwq

这个题是不是也很良心呀qwq

@ _rqy 这位dalao有另一种做法可以过

---

## 作者：Maniac丶坚果 (赞：3)

在这里真的想说说这次对出题人有点意见的地方.....

~~1) 比赛时间神踏马10:00到15:00， 你让我们早上要训练中午吃过饭需要午休的人怎么活？~~

2）关于这个题

① 这个题解是不完美的，$6 + 4 + 2 + 2 + 1 \times 21 = 35$个质因子明明可以用long long，空间也没被卡，为什么要用int呢？ 如果你用二进制存储2和3的数目显然是不能直接用一次与运算或者或运算来做的，必须要老老实实用6位和4位来做这个才能实现一次与和一次或解决问题.... 

② 题目里面模数没说，但严重怀疑是偷懒随机弄了一些小模数，不仅用p = 1这种极端情况把我从100分卡到10分还浪费我2h+来调试（也算是长记性了，这种情况下输出答案的时候一定要取模不然会输出1），而且还放了一个模数稍微大点就RE的老哥（没错，说的就是第二篇） 通过了。

言归正传，其实我的思路和出题人是一致的，只是我选择老老实实用LL 来记录状态，使用了35个二进制位来表示质因子并且在合并的时候直接一次and和or搞定，虽然说因为我是LL的位运算，可能时间上没有显著优于标算（同O2总时间快了100ms），但是我想写起来还是比较方便的吧

代码上面... 用了long long以后，我一个空格党只写了4.05k...


```
#include <bits/stdc++.h>
#define MP make_pair
#define FI first
#define SE second
#define LL long long
using namespace std;
const int maxn = 300010;
const int ss[25] = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97};
const int cal[35] = {2,2,2,2,2,2,3,3,3,3,5,5,7,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97};
inline LL num(LL q,LL mo)
{
    int res = 1;
    for (int i = 0; i < 35 && q; ++i, q >>= 1) if (q&1) res = 1LL * res * cal[i] %mo;
    return res;
}
inline LL fchange(int p)
{
    LL res = 0;
    for (int i = 0; i < 25; ++i)
    {
        int num = 0;
        while (p % ss[i] == 0) num ++, p /= ss[i];
        if (i == 0) for (int j = 0; j < num; ++j) res |= 1LL<<j;
        else if (i == 1) for (int j = 0; j < num; ++j) res |= 1LL<<(j + 6);
        else if (i == 2) for (int j = 0; j < num; ++j) res |= 1LL<<(j + 10);
        else if (i == 3) for (int j = 0; j < num; ++j) res |= 1LL<<(j + 12);
        else if (num) res |= 1LL <<(i + 10);
        if (p == 1) break;
    }
    return res;

}
struct node
{
    LL g[maxn <<2]={0}, lc[maxn <<2]={0},lz[maxn << 2]={0};
    inline void init(){memset(lz,0,sizeof(lz));}
    inline void update(int x)
    {
        if (lz[x] == -1) return;
        lc[x<<1] = lc[x<<1|1] = g[x<<1] = g[x<<1|1] = lz[x];
        lz[x <<1] = lz[x << 1|1] = lz[x];
        lz[x] = -1;
    }
    inline void change(int now,int L,int R,int l,int r,LL c)
    {
        if (L == l && R == r) {lz[now] = c ;g[now] = lc[now] = c;return;}
        int mid = L + R >> 1;
        update(now);
        if (r <= mid) change(now << 1,L, mid,l,r,c);
        else if (l > mid) change(now << 1|1,mid+1,R,l,r,c);
        else change(now<<1,L,mid,l,mid,c),change(now<<1|1,mid+1,R,mid+1,r,c);	
        int x = now;
        lc[x] = lc[x<<1] | lc[x<< 1|1];
        g[x] = g[x<<1] & g[x<< 1|1];
    }
    inline LL queryg(int now,int L,int R,int l,int r)
    {
        if (L == l && R == r) return g[now];
        update(now);
        int mid = L + R >>1;
        if (r <= mid) return queryg(now<<1,L,mid,l,r);
        else if (l > mid) return queryg(now<<1|1,mid+1,R,l,r);
        else return queryg(now<<1,L,mid,l,mid)&queryg(now<<1|1,mid+1,R,mid+1,r);
    }
    inline LL queryl(int now,int L,int R,int l,int r)
    {
        if (L == l && R == r) return lc[now];
        update(now);
        int mid = L + R >> 1;
        if (r <= mid) return queryl(now<<1,L,mid,l,r);
        else if (l > mid) return queryl(now<<1|1,mid+1,R,l,r);
        else return queryl(now<<1,L,mid,l,mid)|queryl(now<<1|1,mid+1,R,mid+1,r);
        
    }
}nut;
inline int read()
{
    int x = 0, f = 1;
    char ch = 0;
    for (;!isdigit(ch); ch = getchar()) if (ch == '-') f = -1;
    for (;isdigit(ch); ch = getchar()) x = x * 10 +ch - 48;
    return x * f;
}
int n,q;
int main()
{
    nut.init();
    n = read(); q = read();
    for (int i = 1; i <= n; ++i) 
    {
        int u = read();
        nut.change(1,1,n,i,i,fchange(u));
    }
    while (q--)
    {
        char ch = 0;
        while (!isalpha(ch)) ch = getchar();
        int x = read(), y = read(),c = read();
        if (ch != 'C' && c == 1) {puts("0"); continue;}
        if (ch == 'L') printf("%lld\n",num(nut.queryl(1,1,n,x,y),c));
        else if (ch == 'G') printf("%lld\n",num(nut.queryg(1,1,n,x,y),c));
        else if (ch == 'C') nut.change(1,1,n,x,y,fchange(c));
        else
        {
            LL k = nut.queryg(1,1,n,x,y);
            int res = 1,pre = 0;
            for (int i = 0; i < 6; ++i) pre += (1<<i)&k?1:0;
            res *= (1 +pre);pre = 0;
            for (int i = 6; i < 10; ++i) pre += (1<<i)&k?1:0;
            res *= (1+pre);pre = 0;
            for (int i = 10; i < 12; ++i) pre += (1<<i)&k?1:0;
            res *= (1+pre); pre = 0;
            for (int i = 12; i < 14; ++i) pre += (1<<i)&k?1:0;
            res *= (1+pre);  res %= c;
            for (int i = 14; i < 35; ++i) if (k>>i&1) res = 1LL * 2 * res % c;
            printf("%d\n",res);
        }
     } 
}

```





---

## 作者：马必辰 (赞：1)

线段树+状态压缩

比标程短+好写

编程难度：NOIP提高

~~比标程慢~~（可能是因为懒得加优化）

对于一个[1,100]的子集，求lcm、gcd和公因数个数应该是一个很容易的事情

因此本题的关键在数列动态修改的情况下求子串的集合

区间修改+区间查询，秒想到线段树，结点表示该区间内是否存在这个数

但空间复杂度是O（100*4n），空间不够（可以用bool数组，但时间会超）

因为只需要存储是否存在，直接状态压缩，每个结点表示不大于32个数（我选择的是20个）

还有一个优化，因为每次修改都是相同的数，~~而且数据是随机生成的，~~可以加一个标记

空间复杂度O（20n），时间复杂度O（qlogn）


**下面是代码，看不懂可以私信我。**

```cpp
#include<cstdio>
#include<cstring>
int a,b,c,d,e,f,g,h,x[1100000][10]={0},w[200]={0},u[200]={0},v[200]={0},oa[200]={0},ob[200]={0},oc[200]={0};
char z;
void sc(int j,int k,int l)
{
int p,i;
if(k==l)
{
    scanf("%d",&c);
    x[j][u[c]]=v[c];
}
else
{
    p=(k+l)/2;
    sc(2*j,k,p);
    sc(2*j+1,p+1,l);
    for(i=1;i<=5;i++)
    {
        x[j][i]=x[2*j][i]|x[2*j+1][i];
    }
}
}
void xf(int j,int k,int l)
{
int p,i;
p=x[k][0]=x[l][0]=x[j][0];
for(i=1;i<=5;i++)
{
    x[k][i]=x[l][i]=0;
}
x[k][u[p]]=x[l][u[p]]=v[p];
x[j][0]=0;
}
void xg(int j,int k,int l,int r,int s)
{
int p,i;
if((r<=k)&&(l<=s))
{
    for(i=1;i<=5;i++)
    {
        x[j][i]=0;
    }
    x[j][u[e]]=v[e];
    x[j][0]=e;
}
else
{
    p=(k+l)/2;
    if(x[j][0]!=0) xf(j,2*j,2*j+1);
    if(r<=p) xg(2*j,k,p,r,s);
    if(p<s) xg(2*j+1,p+1,l,r,s);
    for(i=1;i<=5;i++)
    {
        x[j][i]=x[2*j][i]|x[2*j+1][i];
    }
}
}
void tj(int j,int k,int l,int r,int s)
{
int p,i;
if((r<=k)&&(l<=s))
{
    for(i=1;i<=5;i++)
    {
        oa[i]|=x[j][i];
    }
}
else
{
    p=(k+l)/2;
    if(x[j][0]!=0) oa[u[x[j][0]]]|=v[x[j][0]];
    else
    {
        if(r<=p) tj(2*j,k,p,r,s);
        if(p<s) tj(2*j+1,p+1,l,r,s);
        for(i=1;i<=5;i++)
        {
            x[j][i]=x[2*j][i]|x[2*j+1][i];
        }
    }  
}
}
int main()
{
int i,m,n;
for(i=1;i<=5;i++)
{
    a=1;
    for(m=1;m<=20;m++)
    {
        u[i*20-20+m]=i;
        v[i*20-20+m]=a;
        a*=2;
    }
}
scanf("%d%d",&a,&b);
sc(1,1,a);
for(i=1;i<=b;i++)
{
    scanf(" %c%d%d%d",&z,&c,&d,&e);
    if(z=='C') xg(1,1,a,c,d);
    else
    {
        f=0;
        for(m=1;m<=5;m++)
        {
            oa[m]=0;
        }
        tj(1,1,a,c,d);
        for(m=1;m<=100;m++)
        {
            if((oa[u[m]]&v[m])>0)
            {
                f++;
                ob[f]=m;
            }
        }
        if(z=='L')
        {
            for(m=2;m<=100;m++)
            {
                oc[m]=0;
            }
            for(m=1;m<=f;m++)
            {
                for(n=2;n<=ob[m];n++)
                {
                    g=0;
                    while(ob[m]%n==0)
                    {
                        ob[m]/=n;
                        g++;
                    }
                    if(oc[n]<g) oc[n]=g;
                }
            }
            h=1;
            for(m=2;m<=100;m++)
            {
                for(n=1;n<=oc[m];n++)
                {
                    h=h*m%e;
                } 
            }
            printf("%d\n",h%e);
        }
        else
        {
            g=0;
            for(m=2;m<=ob[1];m++)
            {
                while(ob[1]%m==0)
                {
                    ob[1]/=m;
                    g++;
                    oc[g]=m;
                }
            }
            for(m=2;m<=f;m++)
            {
                for(n=1;n<=g;n++)
                {
                    if(oc[n]!=0)
                    {
                        if(ob[m]%oc[n]==0) ob[m]/=oc[n];
                        else oc[n]=0; 
                    }
                }
            }
            if(z=='G')
            {
                h=1;
                for(m=1;m<=g;m++)
                {
                    if(oc[m]!=0) h=h*oc[m]%e;
                }
                printf("%d\n",h%e);
            }
            if(z=='S')
            {
                h=1;
                f=0;
                n=0;
                for(m=1;m<=g;m++)
                {
                    if(oc[m]!=0)
                    {
                        if(f==oc[m]) n++;
                        else
                        {
                            h=h*(n+1)%e;
                            f=oc[m];
                            n=1;
                        }
                    }
                }
                h=h*(n+1)%e;
                printf("%d\n",h%e);
            }
        }
        
    }
}
}
```

---

## 作者：Butterfly_qwq (赞：0)

其实还是需要一点思维的（？

我们发现，题目预估值的范围有一点可疑，在 $1$ 和 $100$ 之间。

这就启示我们将质因数压起来。

具体来讲，

$2^7=128>100$，所以只用 $6$ 个二进制位就能表示所有 $2$ 的个数。

对于其他质数同理。于是我们需要 $6+4+2\times2+1\times(25-1-1-2)=35$ 位二进制位就可以表示一个数，而这显然可以用 long long 来存。

之后就可以用线段树做到 $O(n\log n)$。

Code:

```
#include<bits/stdc++.h>
using namespace std;
int p[35]={2,2,2,2,2,2,3,3,3,3,5,5,7,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97};
int n,q,a[300005];
long long getnum(int x)
{
	long long res=0;
	for(int i=0;i<35;i++)
	{
		if(x%p[i])continue;
		res|=(1ll<<i);
		x/=p[i];
	}
	return res;
}
int getans(long long x,int mod)
{
	int res=1;
	for(int i=0;i<35;i++)if(x&(1ll<<i))(res*=p[i])%=mod;
	return res;
}
struct node
{
	long long lcm,gcd;
	int lazy;
	bool hslz;
	node operator+(node a)
	{
		node p;
		p.lcm=lcm|a.lcm;
		p.gcd=gcd&a.gcd;
		return p;
	}
}sg[1200005];
void pushup(int u)
{
	bool lz=sg[u].hslz;
	sg[u]=sg[u<<1]+sg[u<<1|1];
	sg[u].hslz=lz;
}
void pushlazy(int u,int lz)
{
	sg[u].lazy=lz;
	sg[u].hslz=true;
	sg[u].lcm=sg[u].gcd=getnum(lz);
}
void pushdown(int u)
{
	if(sg[u].hslz)
	{
		pushlazy(u<<1,sg[u].lazy);
		pushlazy(u<<1|1,sg[u].lazy);
		sg[u].hslz=false;
	}
}
void build(int u,int l,int r)
{
	if(l==r)
	{
		sg[u].hslz=false;
		sg[u].lcm=sg[u].gcd=getnum(a[l]);
		return;
	}
	int mid=l+r>>1;
	build(u<<1,l,mid);
	build(u<<1|1,mid+1,r);
	pushup(u);
}
void update(int u,int l,int r,int L,int R,int c)
{
	if(L<=l&&r<=R)
	{
		pushlazy(u,c);
		return;
	}
	pushdown(u);
	int mid=l+r>>1;
	if(L<=mid)update(u<<1,l,mid,L,R,c);
	if(R>mid)update(u<<1|1,mid+1,r,L,R,c);
	pushup(u);
}
node query(int u,int l,int r,int L,int R)
{
	if(L<=l&&r<=R)return sg[u];
	pushdown(u);
	node res;
	res.lcm=0;
	res.gcd=(1ll<<35)-1;
	int mid=l+r>>1;
	if(L<=mid)res=res+query(u<<1,l,mid,L,R);
	if(R>mid)res=res+query(u<<1|1,mid+1,r,L,R);
	return res;
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>q;
	for(int i=1;i<=n;i++)cin>>a[i];
	build(1,1,n);
	while(q--)
	{
		string op;
		int l,r,p;
		cin>>op>>l>>r>>p;
		if(op=="C")update(1,1,n,l,r,p);
		if(op=="L")cout<<getans(query(1,1,n,l,r).lcm,p)%p<<'\n';
		if(op=="G")cout<<getans(query(1,1,n,l,r).gcd,p)%p<<'\n';
		if(op=="S")
		{
			long long s=query(1,1,n,l,r).gcd;
			int ans=1,pre=1;
			for(int i=0;i<6;i++)if(s&(1ll<<i))pre++;
			(ans*=pre)%=p;
			pre=1;
			for(int i=6;i<10;i++)if(s&(1ll<<i))pre++;
			(ans*=pre)%=p;
			pre=1;
			for(int i=10;i<12;i++)if(s&(1ll<<i))pre++;
			(ans*=pre)%=p;
			pre=1;
			for(int i=12;i<14;i++)if(s&(1ll<<i))pre++;
			(ans*=pre)%=p;
			for(int i=14;i<35;i++)if(s&(1ll<<i))(ans*=2)%=p;
			cout<<ans<<'\n';
		}
	}
}
```

---

## 作者：Hadtsti (赞：0)

~~最近对线段树有点着迷~~
### 题意简述
给出序列 $\{a_1,a_2,\cdots,a_n\}(n\le 3\times10^5,1\le a\le100)$，有 $q(1\le q\le 3\times 10^5)$ 次操作，共 $4$ 种：

1. 查询 $a_l,a_{l+1},\cdots,a_r$ 的最小公倍数 $\mod x$ 的值。

2. 查询 $a_l,a_{l+1},\cdots,a_r$ 的最大公约数 $\mod x$ 的值。

3. 查询 $a_l,a_{l+1},\cdots,a_r$ 的公约数个数 $\mod x$ 的值。

4. 将 $a_l,a_{l+1},\cdots,a_r$ 更改为 $x(1\le x\le 100)$。

注：模数 $x$ 不固定。
### 题目分析
乍一看，维护最小公倍数，模数还在变，什么毒瘤题……

但是！注意到 $a_i$ 始终在 $[1,100]$ 之间，也就是说它们的质因数个数有限，$[1,100]$ 内的质数更是只有 $25$ 个。

我们考虑使用线段树的每个结点维护 $a_l,a_{l+1},\cdots,a_r$ 的最大公约数及最小公倍数的质因数分解中，每个质因数及其次数。那么该如何合并呢？很简单。每个结点的最小公倍数也就是其左右子结点的最小公倍数的最小公倍数，将左右子结点的次数取一个 $\max$ 即可；最大公约数类似，取一个 $\min$ 即可。

至于查询，$1$ 类查询和 $2$ 类查询就是线段树板子，直接按照结果对应的每个质数的次数乘起来就好了。对于 $3$ 类查询，实质上就是求最大公约数的约数个数，实现比较简单。

另外要特判模数为 $0$ 的情况，不然会寄。

~~其他大佬都用的压位，但是好像直接记录次数也不会慢特别多，空间也还行~~

### 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
const int P[25]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97};
int n,q,a[300010],l,r,x,ans;
char op[2];
struct sep
{
	int a[25];
	void init()
	{
		memset(a,0,sizeof a);
	}
}tmp;//一个数质因数分解后，每个质数的次数。为了方便就封装了一个结构体。
struct node
{
	int l,r,tag;
	sep mn,mx;
}tr[1200010];//线段树结点
sep max(sep a,sep b)
{
	for(int i=0;i<25;i++)
		a.a[i]=max(a.a[i],b.a[i]);
	return a;
}
sep min(sep a,sep b)
{
	for(int i=0;i<25;i++)
		a.a[i]=min(a.a[i],b.a[i]);
	return a;
}
void pushup(int p)
{
	tr[p].mx=max(tr[p<<1].mx,tr[p<<1|1].mx);
	tr[p].mn=min(tr[p<<1].mn,tr[p<<1|1].mn);
}//更新结点
void addtag(int p,int val)
{
	tr[p].tag=val;
	tr[p].mn.init(),tr[p].mx.init();
	for(int i=0;i<25&&val>1;i++)
		while(val%P[i]==0)
		{
			tr[p].mn.a[i]++;
			val/=P[i];
		}
	tr[p].mx=tr[p].mn;
}//加标记
void pushdown(int p)
{
	if(tr[p].tag)
	{
		addtag(p<<1,tr[p].tag);
		addtag(p<<1|1,tr[p].tag);
		tr[p].tag=0;
	}
}//懒标记下传
void build(int p,int l,int r)
{
	tr[p].l=l,tr[p].r=r;
	tr[p].tag=0;
	if(l==r)
	{
		addtag(p,a[l]);
		tr[p].tag=0;
		return;
	}
	int mid=l+r>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	pushup(p);
}//建树
void change(int p,int l,int r,int val)
{
	if(tr[p].l>=l&&tr[p].r<=r)
	{
		addtag(p,val);
		return;
	}
	pushdown(p);
	int mid=tr[p].l+tr[p].r>>1;
	if(mid>=l)
		change(p<<1,l,r,val);
	if(mid<r)
		change(p<<1|1,l,r,val);
	pushup(p);
}//修改
sep query1(int p,int l,int r)
{
	if(tr[p].l>=l&&tr[p].r<=r)
		return tr[p].mx;
	pushdown(p);
	int mid=tr[p].l+tr[p].r>>1;
	if(mid<l)
		return query1(p<<1|1,l,r);
	if(mid>=r)
		return query1(p<<1,l,r);
	return max(query1(p<<1,l,r),query1(p<<1|1,l,r));
}//查询最小公倍数
sep query2(int p,int l,int r)
{
	if(tr[p].l>=l&&tr[p].r<=r)
		return tr[p].mn;
	pushdown(p);
	int mid=tr[p].l+tr[p].r>>1;
	if(mid<l)
		return query2(p<<1|1,l,r);
	if(mid>=r)
		return query2(p<<1,l,r);
	return min(query2(p<<1,l,r),query2(p<<1|1,l,r));
}//查询最大公约数
int main()
{
	scanf("%d%d",&n,&q);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	build(1,1,n);
	while(q--)
	{
		scanf("%s%d%d%d",op,&l,&r,&x);
		if(op[0]=='L')
		{
			ans=1;
			tmp=query1(1,l,r);
			for(int i=0;i<25;i++)
				for(int j=1;j<=tmp.a[i];j++)
					ans=1ll*ans*P[i]%x;//根据每个质数的次数乘回去
			printf("%d\n",ans%x);//一定要 %x ！！否则 x=1 时会寄
		}//最小公倍数
		else if(op[0]=='G')
		{
			ans=1;
			tmp=query2(1,l,r);
			for(int i=0;i<25;i++)
				for(int j=1;j<=tmp.a[i];j++)
					ans=1ll*ans*P[i]%x;
			printf("%d\n",ans%x);
		}//最大公约数
		else if(op[0]=='C')
			change(1,l,r,x);//修改
		else
		{
			ans=1;
			tmp=query2(1,l,r);
			for(int i=0;i<25;i++)
				ans=1ll*ans*(tmp.a[i]+1)%x;
			printf("%d\n",ans%x);
		}//公约数的个数实际上就是最大公约数的约数个数
	}
	return 0;
}
```


---

## 作者：s_r_f (赞：0)

观察题面$,$需要维护区间$gcd$和$lcm.$

值域是$[1,100],$ $[1,100]$范围内的$gcd$可以事先预处理出来然后可以$O(1)$查询$.$

$lcm$的话$,$就必须记录每个质因子的次数$.$

不难发现$2^7=128>100,3^5=243>100,5^3=125>100,7^3=343>100,11^2=121>100$

所以$,$ $2$ 和 $3$ 各自用 $3$ 个二进制位 $,$ $5$ 和 $7$ 各用 $2$ 个二进制位 $,$ 剩下的 $21$ 个质数各用 $1$ 个二进制位 $,$ 一共用 $31$ 个二进制位 $,$ 用一个 $int$ 存正好能存下$.$

并且通过$O(1024^2)$预处理可以做到$O(1)$合并这个信息$.$

处理完这些信息之后$,$直接上线段树就好了$.$ $O(1024^2+nlogn)$

-------

又及$:$卡到$545ms$之后所有的优化都变成了负优化$...$那位$500ms$的神仙是怎么卡到的$?$能否赐教$,$在下感激不尽$!$

-----

代码$:$

```cpp
#include <bits/stdc++.h>
using namespace std;
inline void read(int &x){
	static char ch; x = 0,ch = getchar(); while (!isdigit(ch)) ch = getchar();
	while (isdigit(ch)) x = x * 10 + ch - '0',ch = getchar();
}
inline int Getop(){
	static char ch; ch = getchar(); while (!isalpha(ch)) ch = getchar();
	return ((ch == 'L' || ch == 'G')) ? (ch == 'L' ? 1 : 2) : (ch == 'C' ? 3 : 4);
}
inline void write(int x){ if (x > 9) write(x/10); putchar(x%10+'0'); }
const int N = 300001,p[] = {11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97};
int d[101],Gcd[101][101],v[101],FF[1024][1024],num[1024];
inline int Get(int t,int p){ static int c; c = 0; while (!(t%p)) t/=p,++c; return c; }
inline int power(int x,int y){ static int r; r = 1; while (y){ if (y&1) r*=x; x*=x,y>>=1; } return r; }
inline void init(){
	register int i,j;
	for (i = 1; i <= 100; ++i) for (j = 1; j <= i; ++j) if (!(i%j)) ++d[i];
	for (i = 0; i <= 100; ++i) for (j = 0; j <= 100; ++j) Gcd[i][j] = __gcd(i,j);
	for (i = 1; i <= 100; ++i){
		v[i] = Get(i,2) | (Get(i,3)<<3) | (Get(i,5)<<6) | (Get(i,7)<<8);
		for (j = 0; j < 21; ++j) if (!(i%p[j])){ v[i] |= 1<<10+j; break; }
	}
	for (i = 0; i < 1024; ++i) for (j = 0; j < 1024; ++j)
	FF[i][j] = max(i&7,j&7) | ((max(i&63,j&63)>>3)<<3) | ((max(i&255,j&255)>>6)<<6) | ((max(i,j)>>8)<<8);
	for (i = 0; i < 1024; ++i)
	num[i] = power(2,i&7) * power(3,(i&63)>>3) * power(5,(i&255)>>6) * power(7,i>>8);
}
inline int F(int x,int y){ return FF[x&1023][y&1023] + ((x|y)&2147482624); }
inline int calc(int x,int mod){
	static int r,i;
	//这个地方r应该开long long,但是为了卡常我暂时改成了int 
	for (r = num[x&1023] % mod,x >>= 10,i = 0; i < 21 && x; ++i,x>>=1) if (x&1) r = r * p[i] % mod;
	return r;
}
int a[N],Gc[N<<2],Lc[N<<2],tag[N<<2];
#define up(o) Gc[o] = Gcd[Gc[o<<1]][Gc[o<<1|1]],Lc[o] = F(Lc[o<<1],Lc[o<<1|1])
#define Tag(o,x) tag[o] = Gc[o] = x,Lc[o] = v[x]
#define down(o) if (tag[o]) Tag(o<<1,tag[o]),Tag(o<<1|1,tag[o]),tag[o] = 0
inline void Build(int o,int l,int r){
	if (l == r){ Gc[o] = a[l],Lc[o] = v[a[l]]; return; }
	int mid = l+r>>1; Build(o<<1,l,mid); Build(o<<1|1,mid+1,r); up(o); 
}
int ll,rr,vv;
inline void Add(int o,int l,int r){
	if (ll <= l && rr >= r){ Tag(o,vv); return; }
	down(o); int mid = l+r>>1; if (ll <= mid) Add(o<<1,l,mid); if (rr > mid) Add(o<<1|1,mid+1,r); up(o);
}
int qlcm;
inline void Ask1(int o,int l,int r){
	if (tag[o] || (ll <= l && rr >= r)){ qlcm = F(qlcm,Lc[o]); return; }
	int mid = l+r>>1; if (ll <= mid) Ask1(o<<1,l,mid); if (rr > mid) Ask1(o<<1|1,mid+1,r);
}
int qgcd;
inline void Ask2(int o,int l,int r){
	if (tag[o] || (ll <= l && rr >= r)){ qgcd = Gcd[qgcd][Gc[o]]; return; }
	int mid = l+r>>1; if (ll <= mid) Ask2(o<<1,l,mid); if (rr > mid) Ask2(o<<1|1,mid+1,r);
}
int n,q;
int main(){
	int i,op,mod,ans;
	init(),read(n),read(q);
	for (i = 1; i <= n; ++i) read(a[i]); Build(1,1,n);
	while (q--){
		op = Getop(),read(ll),read(rr);
		if (op == 3){ read(vv),Add(1,1,n); continue; }
		read(mod);
		if (op == 1) qlcm = 0,Ask1(1,1,n),ans = calc(qlcm,mod);
		else qgcd = 0,Ask2(1,1,n),ans = (op == 2 ? qgcd : d[qgcd]) % mod;
		write(ans),putchar('\n');
	}
	return 0;
}
```

---


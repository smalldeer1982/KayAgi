# [SHOI2015] 超能粒子炮·改

## 题目描述

曾经发明了脑洞治疗仪与超能粒子炮的发明家 SHTSC 又公开了他的新发明：超能粒子炮・改——一种可以发射威力更加强大的粒子流的神秘装置。

超能粒子炮・改相比超能粒子炮，在威力上有了本质的提升。它有两个参数 $n,k$ ，它会向每个编号为 $0$ 到 $k$ （包含两端）的位置 $i$ 发射威力为 $C_{n}^{i} \bmod 2333$ 的粒子流。

现在 SHTSC 给出了他的超能粒子炮・改的参数，让你求出其发射的粒子流的威力之和除以 $2333$ 所得的余数。

## 说明/提示

对于 $10\%$ 的数据，$t = 1,n,k \le 1000$ ；  
对于 $30\%$ 的数据，$t = 1,n,k \le 1000000$ ；  
对于 $50\%$ 的数据，$t = 1,n \le 10^{18},k \le 1000$ ；  
对于 $70\%$ 的数据，$t = 100,n,k \le 10^{18}$ ；  
对于 $100\%$ 的数据，$t = 100000,n,k \le 10^{18}$ .

## 样例 #1

### 输入

```
3
5 5
10 7
1145 14```

### 输出

```
32
968
763```

# 题解

## 作者：asuldb (赞：99)

就是运用$Lucas$推一个柿子

首先是前置芝士$Lucas$定理

$$C_{n}^{m}\%p=C_{n/p}^{m/p}*C_{n\%p}^{m\%p}\%p$$

至于证明

~~我建议去问一下Lucas本人~~

至于这道题，我们要求的是这个柿子

$$\sum_{i=0}^kC_{n}^i\%p$$

于是我们设$f(n,k)=\sum_{i=0}^kC_{n}^i$

我们就可以化柿子啦

$$f(n,k)=\sum_{i=0}^kC_{n}^i$$

$$\text{ }\text{ }\text{ }\text{ }\text{ }\text{ }\text{ }\text{ }\text{ }\text{ }\text{ }\text{ }\text{ }\text{ }\text{ }\text{ }\text{ }\text{ }\text{ }\text{ }\text{ }\text{ }\text{ }\text{ }\text{ }=\sum_{i=0}^kC_{n/p}^{i/p}*C_{n\%p}^{i\%p}$$

这个东西一看就很熟悉，$n/p$啊，显然跟整除分块差不多啊

$$=C_{n/p}^0\sum_{i=0}^{p-1}C_{n\%p}^i+C_{n/p}^1\sum_{i=0}^{p-1}C_{n\%p}^i+...+C_{n/p}^{k/p}\sum_{i=0}^{k\%p}C_{n\%p}^i$$

前面有$0$到$k/p-1$这些个整块，于是我们可以将$\sum_{i=0}^{p-1}C_{n\%p}^i$提出来

变成

$$\sum_{i=0}^{p-1}C_{n\%p}^i*(C_{n/p}^0+C_{n/p}^1+...C_{n/p}^{k/p-1})$$

那这个东西岂不是可以写成

$$f(n\%p,p-1)*f(n/p,k/p-1)$$

在加上那个不完整的块

$\sum_{i=0}^{k\%p}C_{n\%p}^i$可以写成$f(n\%p,k\%p)$

于是就有

$$f(n,k)=f(n\%p,p-1)*f(n/p,k/p-1)+C_{n/p}^{k/p}*f(n\%p,k\%p)$$

由于$n\%p$还有$k\%p$都小于$2333$，所以$f(n\%p,p-1)$还有$f(n\%p,k\%p)$可以直接预处理好可以直接求出来

至于那个$C_{n/p}^{k/p}$就直接上$Lucas$好了

时间复杂度$O(p^2+Tlog_{2333}^2n)$

代码

非常sb的把$C_0^0$当成$0$WA了好几发
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#define re register
#define LL long long
#define maxn 2335
const int P=2333;
LL c[maxn+2][maxn+2];
LL f[maxn+2][maxn+2];
inline LL Lucas(LL n,LL m)
{
	if(!m) return 1;
	if(n==m) return 1;
	if(n<m) return 0;
	return c[n%P][m%P]*Lucas(n/P,m/P)%P;
}
inline LL F(LL n,LL k)
{
	if(k<0) return 0;
	if(!n) return 1;
	if(!k) return 1;
	if(n<P&&k<P) return f[n][k];
	return (F(n/P,k/P-1)*f[n%P][P-1]%P+Lucas(n/P,k/P)*f[n%P][k%P]%P)%P;
}
int main()
{
	int T;
	scanf("%d",&T);
	c[0][0]=1;
	for(re int i=1;i<=maxn;i++) 
    	c[i][i]=c[i][0]=1;
	for(re int i=1;i<=maxn;i++)
		for(re int j=1;j<i;j++)
			c[i][j]=(c[i-1][j]+c[i-1][j-1])%P;
	f[0][0]=1;
	for(re int i=1;i<=maxn;i++) 
    	f[i][0]=1;
	for(re int i=0;i<=maxn;i++)
		for(re int j=1;j<=maxn;j++)
			f[i][j]=(c[i][j]+f[i][j-1])%P;
    LL n,k;
	while(T--)
	{
		scanf("%lld%lld",&n,&k);
		printf("%lld\n",F(n,k));
	}
	return 0;
}
```

---

## 作者：yybyyb (赞：23)

看着这个东西就感觉可以递归处理。  
令$f(n,k)$表示答案。  
$$\begin{aligned}f(n,k)&=\sum_{i=0}^k {n\choose i}\\&=\sum_{i=0}^k {n/p\choose i/p}*{n\%p\choose i\%p}\\&=\sum_{x=0}^{p-1}{n\%p\choose x}*\sum_{i=0}^k[i\%p=x]{n/p\choose i/p}\\&=\sum_{x=0}^{p-1}{n\%p\choose x}*\sum_{i=0}^{(k-x)/p}{n/p\choose i}\\&=\sum_{x=0}^{p-1}{n\%p\choose x}*f(n/p,(k-x)/p)\end{aligned}$$  
前面那个东西可以提前预处理好前缀和，而后面那个东西最多递归两次(有的题解推出来要递归三次QwQ)。而递归层数也就最多$6$层。所以单次复杂度$O(2^6)$。卡卡常就洛谷rk1了。。。（虽然估计很快就会被爆踩的）
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
#define ll long long
#define MOD 2333
#define MAX 2350
inline ll read()
{
	ll x=0;bool t=false;char ch=getchar();
	while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
	if(ch=='-')t=true,ch=getchar();
	while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
	return t?-x:x;
}
int C[MAX][MAX];
int f(ll n,ll k)
{
	if(n<MOD)return C[n][min(n,k)];
	if(!k)return 1;
	int ret=0,x=k%MOD,y=n%MOD;
	ret=C[y][min(y,x)]*f(n/MOD,k/MOD);
	if(k-x)ret=(ret+(C[y][y]-C[y][min(y,x)]+MOD)*f(n/MOD,(k-x-1)/MOD))%MOD;
	return ret;
}
ll n,k;
int main()
{
	for(int i=0;i<MAX;++i)C[i][0]=1;
	for(int i=1;i<MAX;++i)
		for(int j=1;j<=i;++j)
			C[i][j]=(C[i-1][j]+C[i-1][j-1])%MOD;
	for(int i=0;i<MAX;++i)
		for(int j=1;j<=i;++j)
			C[i][j]=(C[i][j]+C[i][j-1])%MOD;
	int T=read();
	while(T--)
	{
		n=read();k=read();
		printf("%d\n",f(n,k));
	}
	return 0;
}
```

---

## 作者：Nemlit (赞：14)

首先我们要明确题目要我们求的是这个式子：
$$\sum_{i = 0}^kC_n^i$$

我们先从部分分看起：

### 10分
预处理出组合数暴力算就是了。复杂度$O(N^2)$

### 50分 --- 1

由于我们要求的东西是在杨辉三角的一行，所以我们可以递推求出改行组合数，递推式为$C_n^{m + 1} = C_n^m\ *\ \frac{n - m}{m + 1}$，证明的话就用组合数的定义式即可。复杂度$O(k)$

### 50分 --- 2
这一档对正解有一定启发意义
跟据Lucas定理（什么你还不会[Lucas](https://www.luogu.org/problem/P3807)？？？）
$$C_n^i\ \%\ p = C_{n\ \%\ p}^{i \ \%\ p}\ *\ C_{n\ /\ p}^{i \ /\ p}\ \%\ p$$
我们可以将原式化成：
$$\sum_{i = 0}^{k}\ C_{n\ \%\ p}^{i \ \%\ p}\ *\ C_{n\ /\ p}^{i \ /\ p}\ \%\ p$$

等一下，$i\ /\ p$和$n\ /\ p$有循环节， $i\ /\ p$和$n\ /\ p$在很多时候都是相等的啊！

于是我们可以自然地想到：记
$$f[j] = \sum_{i = 0}^{j}\ C_{n\ \%\ p}^{i \ \%\ p}\ \%\ p$$

由于p不是很大，所以我们可以预处理出f数组

于是我们的复杂度可以从$O(t\ *\ 10^{18}\ *\ $卢卡斯复杂度$)$优化成$O(t\ *\ k\ *\ $卢卡斯复杂度$\ /\ 2333)$

### $Code:$
```
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define re register
#define int long long
il int read() {
    re int x = 0, f = 1; re char c = getchar();
    while(c < '0' || c > '9') { if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - 48, c = getchar();
    return x * f;
}
#define p 2333
#define rep(i, s, t) for(re int i = s; i <= t; ++ i)
#define maxn 3000
int n, m, c[maxn][maxn], f[maxn][maxn], ans, k;
il int Lucas(int n, int m) {
	if(!m || n == m) return 1;
	if(n < m) return 0;
	return Lucas(n / p, m / p) * c[n % p][m % p] % p;
}
signed main() {
	c[0][0] = f[0][0] = 1;
	rep(i, 1, p) {
		f[i][0] = c[i][0] = c[i][i] = 1;
		rep(j, 1, i - 1) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % p;
		rep(j, 1, i) f[i][j] = (f[i][j - 1] + c[i][j]) % p;
	}
	int T = read();
	while(T --) {
		n = read(), m = read(), ans = k = 0;
		for(; k <= m - p; k += p) ans = (ans + f[n % p][n % p] * Lucas(n / p, k / p)) % p;
		printf("%lld\n", (ans + Lucas(n / p, k / p) * f[n % p][min(n % p, m % p)]) % p);
	}
	return 0;
}
```
### 100分
我们再来思考我们50-2慢在了哪里？

我们在算

    for(; k <= m - p; k += p) ans = (ans + f[n % p][n % p] * Lucas(n / p, k / p)) % p;
    
的时候时间复杂度开销很大，但是我们如果提出$f[n\ \%\ p][n\ \%\ p]$，柿子就成
$$\sum_{i = 0}^{m\ /\ p}C_{n / p}^i$$

哎，这部可以递归算吗？

所以我们可以推出：

$$F(i, j) = f[n\ \%\ p][n\ \%\ p] * F(\frac{n}{p}, \frac{m}{p} - 1) + Lucas(\frac{n}{p}, \frac{m}{p}) * f[n\ \%\ p][min(n\ \%\ p, m\ \%\ p)]$$

### $Code:$
```
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define re register
#define int long long
il int read() {
    re int x = 0, f = 1; re char c = getchar();
    while(c < '0' || c > '9') { if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - 48, c = getchar();
    return x * f;
}
#define p 2333
#define rep(i, s, t) for(re int i = s; i <= t; ++ i)
#define maxn 3000
int n, m, c[maxn][maxn], f[maxn][maxn];
il int Lucas(int n, int m) {
	if(!m || n == m) return 1;
	if(n < m) return 0;
	return Lucas(n / p, m / p) * c[n % p][m % p] % p;
}
il int F(int n, int m) {
	if(m == -1) return 0;
	if(!m) return 1;
	if(n < p) return f[n][m];
	return (f[n % p][n % p] * F(n / p, m / p - 1) + Lucas(n / p, m / p) * f[n % p][min(n % p, m % p)]) % p;
}
signed main() {
	c[0][0] = f[0][0] = 1;
	rep(i, 1, p) {
		f[i][0] = c[i][0] = c[i][i] = 1;
		rep(j, 1, i - 1) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % p;
		rep(j, 1, p) f[i][j] = (f[i][j - 1] + c[i][j]) % p;
	}
	int T = read();
	while(T --) {
		n = read(), m = read();
		printf("%lld\n", F(n, m));
	}
	return 0;
}
```

---

## 作者：smarthehe (赞：12)

对于一次询问，我们记作 $f(n,k)$。

$$
f(n,k)=\sum_{i=0}^k \binom{n}{i}
$$

Lucas 定理拆。

$$
=\sum_{i=0}^k \binom{n \bmod p}{i \bmod p} \times \binom{\lfloor\frac{n}{p}\rfloor}{\lfloor \frac{i}{p} \rfloor}
$$

枚举 $\lfloor \frac{i}{p} \rfloor$ 的值：
$$
\binom{\lfloor\frac{n}{p}\rfloor}{0}\sum_{j=0}^{p-1} \binom{n \bmod p}{j \bmod p} + \binom{\lfloor\frac{n}{p}\rfloor}{1}\sum_{j=p}^{2p-1} \binom{n \bmod p}{j \bmod p} + \cdots + \binom{\lfloor\frac{n}{p}\rfloor}{\lfloor \frac{k}{p} \rfloor}\sum_{j=\lfloor \frac{k}{p} \rfloor \times p}^{k} \binom{n \bmod p}{j \bmod p}
$$
注意到除了最后的边角，每个 $\sum$ 里面都是一样的，直接合并
$$
\left(\sum_{j=0}^{p-1} \binom{n \bmod p}{j \bmod p} \right)\left( \sum_{j=0}^{\lfloor \frac{k}{p} \rfloor-1} \binom{\lfloor \frac{n}{p} \rfloor}{j}\right) + \binom{\lfloor\frac{n}{p}\rfloor}{\lfloor \frac{k}{p} \rfloor}\sum_{j=\lfloor \frac{k}{p} \rfloor \times p}^{k} \binom{n \bmod p}{j \bmod p}
$$
第一个括号和最后一个 $\sum$ 可以直接预处理，第二个括号可以视作一次子询问。
$$
g(n \bmod p,p-1) \times f\left( \lfloor \frac{n}{p} \rfloor,\lfloor \frac{k}{p} \rfloor -1\right) + \binom{\lfloor\frac{n}{p}\rfloor}{\lfloor \frac{k}{p} \rfloor} \times g(n \bmod p,k \bmod p)
$$
组合数直接 Lucas 求，$O(\log_p n)$。子询问递归下去，每次规模除掉 $p$，只会有 $\log_p n$ 层。

于是复杂度 $O(p^2 + T\log^2_p n)$。

以下是作者闲话：这道题的做法是通过推式子把问题的规模缩小，一道 Lucas 的题硬是做出了 exLucas 的感觉。说不定是因为问题从 0 维的单组合数求值变成了 1 维的组合数前缀和。那 2 维到 n 维会不会有类似过程呢？

---

## 作者：Great_Influence (赞：9)

调了我一晚上，终于改过去了。。。

式子非常容易，就是运用Lucas定理。不知道的可以先做这题：[Lucas](https://www.luogu.org/problemnew/show/P3807)

然后就开始化式子了。

$$f(n,k)=\sum\limits_{i=0}^k{n\choose i}$$

$$\equiv\sum\limits_{i=0}^k{\lfloor\frac{n}{p}\rfloor\choose \lfloor\frac{i}{p}\rfloor}{n\%p\choose i\%p}\pmod p$$

$$=\sum\limits_{i=0}^{\lfloor\frac{k}{p}\rfloor}{\lfloor\frac{n}{p}\rfloor\choose i}\sum\limits_{j=0}^{\min\{p-1,k-pi\}}{n\%p\choose j}$$
$$=f(n\%p,p-1)\sum\limits_{i=0}^{\lfloor\frac{k}{p}\rfloor-1}{\lfloor\frac{n}{p}\rfloor\choose i}+{\lfloor\frac{n}{p}\rfloor\choose\lfloor\frac{k}{p}\rfloor}\sum\limits_{j=0}^{\min\{p-1,k\%p\}}{n\%p\choose j}$$

预处理$2333*2333$的f,直接递归求解即可。时间复杂度$O(Tlog_{2333}n)$

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
#define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
#define For(i,a,b) for(i=(a),i<=(b);++i)
#define Forward(i,a,b) for(i=(a),i>=(b);--i)
#define Chkmax(a,b) a=a>b?a:b
#define Chkmin(a,b) a=a<b?a:b
template<typename T>inline void read(T &x)
{
    T f=1;x=0;char c;
    for(c=getchar();!isdigit(c);c=getchar())if(c=='-')f=-1;
    for(;isdigit(c);c=getchar())x=x*10+(c^48);
    x*=f;
}
inline void write(long long x,char k)
{
    if(!x){putchar(48),putchar(k);return;}
    static int sta[20],tp;
    for(tp=0;x;x/=10)sta[++tp]=x%10;
    for(;tp;putchar(sta[tp--]+48));
    putchar(k);
}
using namespace std;
void file()
{
#ifndef ONLINE_JUDGE
    freopen("water.in","r",stdin);
    freopen("water.out","w",stdout);
#endif
}
const int MAXN=2555+7;
const int mod=2333;
static int C[MAXN][MAXN],F[MAXN][MAXN];
inline void predone()
{
	C[0][0]=1;
	Rep(i,1,2333)Rep(j,0,i)if(!j||i==j)C[i][j]=1;else
	{
		C[i][j]=C[i-1][j]+C[i-1][j-1];
		if(C[i][j]>mod)C[i][j]-=mod;
	}
	Rep(i,0,2333)
	{
		F[i][0]=1;
		Rep(j,1,2333)
		{
			F[i][j]=F[i][j-1]+C[i][j];
			if(F[i][j]>mod)F[i][j]-=mod;
		}
	}
}
static int _;
inline int power(int a,long long b)
{
	static int sum;
	for(sum=1;b;b>>=1,a=a*a%mod)if(b&1)
		sum=a*a%mod;
	return sum;
}
int c(long long a,long long b)
{
	if(a<b)return 0;
	if(a<=mod)return C[a][b];
	return C[a%mod][b%mod]==0?0:c(a/mod,b/mod)*C[a%mod][b%mod]%mod;
}
int f(long long a,long long b)
{
	if(b<0)return 0;
	return (F[a%mod][b%mod]*c(a/mod,b/mod)%mod+two[a%mod]*f(a/mod,b/mod-1)%mod)%mod;
}
static long long n,k;
inline void work()
{
	read(_);
	while(_--)
	{
		read(n);read(k);
		write(f(n,k),'\n');
	}
}
int main()
{
    file();
    predone();
	work();
	//cerr<<1.0*clock()/CLOCKS_PER_SEC<<endl;
	return 0;
}

```

---

## 作者：I_AM_CIMOTA (赞：7)

没想到吧，数位 dp 秒了！！

设 $p=2333$。 首先，根据 $Lucas$ 定理，我们可以把 $C_n^k$ 拆成 $C_{n\bmod p}^{k\bmod p}\cdot C_{\lfloor n/p\rfloor}^{\lfloor k/p\rfloor}$。 

我们考虑一个进一步的转化：假设 $n$ 和 $k$ 在 $p$ 进制下（包含前导零）表示为 $\overline{n_1n_2n_3n_4n_5n_6}$ 和 $\overline{k_1k_2k_3k_4k_5k_6}$，这里只需要用 $6$ 位就可以了，因为 $2333^6>10^{18}$。不难发现，通过 $Lucas$ 定理我们又可以得到 $C_n^k=C_{n_1}^{k_1}C_{n_2}^{k_2}C_{n_3}^{k_3}C_{n_4}^{k_4}C_{n_5}^{k_5}C_{n_6}^{k_6}$，那么现在我们所需要求的答案就是：
$$ \sum_{i=0}^{k}C_{n_1}^{i_1}C_{n_2}^{i_2}C_{n_3}^{i_3}C_{n_4}^{i_4}C_{n_5}^{i_5}C_{n_6}^{i_6}
$$
欸，这个形式是不是有点像数位 dp 呢？没错，问题转化为对所有的小于等于 $\overline{k_1k_2k_3k_4k_5k_6}$ 的数 $\overline{i_1i_2i_3i_4i_5i_6}$ ，求 $C_{n_1}^{i_1}C_{n_2}^{i_2}C_{n_3}^{i_3}C_{n_4}^{i_4}C_{n_5}^{i_5}C_{n_6}^{i_6}$ 的和。问题转化完毕，现在我们可以设计 dp 状态了。

考虑用记忆化搜索实现，记 $f(i,0/1)$ 表示正在考虑第 $i$ 位，当前贴没贴到上界的所有方案的答案之和。那么有：

$$
f(i,up)=f(i+1,up)\cdot C_{n_i}^{tp_i}+[tp_i>0]f(i+1,0)\cdot\sum_{j=0}^{tp_i-1}C_{n_i}^j
$$
$$
tp_i=\begin{cases}k_i&up=1\\\\p-1&up=0\end{cases}
$$

其中，组合数可以预处理，而 $\sum_{j=0}^{tp_i-1}C_{n_i}^j$ 是个前缀和，也可以预处理出来。

最终时间复杂度为 $O(p^2+T\log_pn)$ 。

参考代码实现：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N=2350,p=2333;
int T,n,k,NN[10],K[10],C[N][N],sum[N][N],f[10][2];

int F(int i,bool up){
	if(i>6)return 1;
	if(~f[i][up])return f[i][up];
	int tp=(up?K[i]:(p-1));
	int res=F(i+1,up)*C[NN[i]][tp]%p;
	if(tp)res=(res+F(i+1,0)*sum[NN[i]][tp-1]%p)%p;
	return f[i][up]=res;
}

signed main(){
	for(int i=0;i<p;i++){
		C[i][0]=sum[i][0]=1;
		for(int j=1;j<=i;j++){
			C[i][j]=(C[i-1][j]+C[i-1][j-1])%p;
			sum[i][j]=(sum[i][j-1]+C[i][j])%p;
		}
		for(int j=i+1;j<p;j++)sum[i][j]=sum[i][j-1];
	}
	scanf("%lld",&T);
	while(T--){
		memset(f,-1,sizeof f);
		memset(K,0,sizeof K),memset(NN,0,sizeof NN);
		scanf("%lld%lld",&n,&k);
		for(int i=6;i>0;i--){
			K[i]=k%p,k/=p;
			NN[i]=n%p,n/=p;
		}
		printf("%lld\n",F(1,1));
	}
	return 0;
}
```

---

## 作者：Nangu (赞：7)

思路：
$$\sum_{i=0}^kC_n^i \operatorname{mod} p$$
$$=\sum_{i=0}^k( C_{n/p}^{i/p} \times C_{n\operatorname{mod}p}^{i\operatorname{mod}p})$$
$$=\sum_{i=0}^{k}(C_{n/p/p}^{i/p/p}\times C_{n/p\operatorname{mod}p}^{i/p\operatorname{mod}p}\times C_{n\operatorname{mod}p}^{i\operatorname{mod}p})$$
也就是 $i$ 在 $p$ 进制下的每一位与 $n$ 在 $p$ 进制下的每一位的组合的乘积。

因此，我们可以借用数位动态规划的思想，枚举最高位 $j$，满足 $i$ 与 $n$ 第 $j$ 位之前的值都相等，第 $j$ 位的值不相等，之后的值随意，并计算其状态下的 $i$ 对答案的贡献。
 ```cpp
#include <bits/stdc++.h>

using namespace std;

const int mod=2333;

long long n, k;
int a[20], cnt_a, b[20], f[20], cnt_b, c[mod+7][mod+7], sum[mod+7][mod+7];

long long read(){
	long long x=0; bool f=0; char c;
	while(!isdigit(c=getchar())) if(c=='-') f=1;
	do x=x*10+c-48; while(isdigit(c=getchar()));
	return f?-x:x;
}

void init(){
	for(int i=0; i<=mod; i++)
		for(int j=0; j<=i; j++)
			c[i][j]=(j==0||j==i?1:c[i-1][j]+c[i-1][j-1])%mod;
	for(int i=0; i<=mod; i++)
		for(int j=0; j<=mod; j++)
			sum[i][j]=(j==0?1:sum[i][j-1]+c[i][j])%mod;
}

void run(){
	n=read(), k=read(), k=min(k, n);
	for(cnt_a=0; n; n/=mod) a[++cnt_a]=n%mod;
	for(cnt_b=0; k; k/=mod) b[++cnt_b]=k%mod;
	f[0]=1;
	for(int i=1; i<=cnt_a; i++) f[i]=f[i-1]*sum[a[i]][mod-1]%mod;
	int ans=0, suf=1;
	for(int i=cnt_b; i>=1; suf=suf*c[a[i]][b[i]]%mod, i--) 
		if(b[i]) ans=(ans+suf*f[i-1]%mod*sum[a[i]][b[i]-1])%mod;
	printf("%d\n", (ans+suf)%mod);
}

signed main()
{
	init();
	for(int T=read(); T; T--) run();
	return 0;
}

---

## 作者：yunsk (赞：7)

又是一道很好的数论题

### 题目大意为$\displaystyle \sum_{i=0}^{k}C_{n}^{i} $

$k<=10^{18},n<=10^{18}$而且又是多组询问 直接求解肯定会T，考虑更好的做法

前置知识：卢卡斯定理$\displaystyle C_{n}^{m} = C_{n\%P}^{m\%P} \times C_{\frac{n}{p}}^{\frac{m}{p}} $

另$f[n][k]=\displaystyle\sum_{i=0}^{k} C_{n}^{i}$ 

$\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ =\displaystyle \sum_{i=0}^{k} \times  C_{\frac{n}{p}}^{\frac{i}{p}} \times C_{n\%P}^{i\%P}\%P $
 
$\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ =C_{n/P}^{0}\times \sum_{i=0}^{P-1}\times C_{n\%P}^{i}+.......C_{n/P}^{1}\times \sum_{i=0}^{P-1}\times C_{n\%P}^{i}+$

$\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ C_{n/P}^{2}\times \sum_{i=0}^{P-1}\times C_{n\%P}^{i}+.......+C_{n/P}^{k/P}\times \sum_{i=0}^{P-1}\times C_{n\%P}^{i}$

### 类似于分块，我们将其分成k/n-1个整块 然后将最后的半块暴力求解

对于整块我们将$\sum_{i=0}^{P-1}\times C_{n\%P}^{i} $ 提出来变成

$ \ \  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \sum_{i=0}^{P-1}\times C_{n\%P}^{i}\times (C_{n/P}^{}+C_{n/P}^{1}+......C_{n/P}^{k/p-1}  )$
	
$ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ =f[n\%P][P-1]  \times f[n/P][k/P-1] $

对于那个半块的我们直接加上$ f[n/P][k\%P]$即可；

对于预处理 ： 我们首先用杨辉三角处理出所需要的组合数初始化 

$c[i][0]=1;c[i][i]=1;$

对于 $f$ 数组我们也要预处理出所有n , k 小于等于P 的值递推式为

$f[i][j]=f[i][j-1]+c[i][j]$ 初始化为$f[0][0]=1 ,  f[i][0]=1 $

				好啦上代码:::::::........:::::::::
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>
#include<cmath>
#define P 2333
#define N 2450
#define ll long long
using namespace std;
ll T,n,k,c[N][N],f[N][N];
ll jc[N],ny[N],ans;
ll Cala(ll n,ll m){
    if(!m)return 1;
    if(n==m)return 1;
//	if(!n)return 1;
    if(n<m)return 0;
//	if(n<P&&m<P)return c[n][m];
    return c[n%P][m%P]*Cala(n/P,m/P)%P;
}
ll F(ll n,ll k){
    if(k<0)return 0;
    if(!n)return 1;
    if(!k)return 1;
    if(n<P&&k<P)return f[n][k];
    return (F(n/P,k/P-1)*f[n%P][P-1]%P+Cala(n/P,k/P)*f[n%P][k%P])%P;
}
int main(){
    scanf("%lld",&T);
    c[0][0]=1;
    for(int i=1;i<=2350;i++){
        c[i][0]=c[i][i]=1;
        for(int j=1;j<i;j++){
            c[i][j]=(c[i-1][j-1]+c[i-1][j])%P;
        }
    }
    f[0][0]=1;
    for(int i=0;i<=2350;i++)f[i][0]=1;
    for(int i=0;i<=2350;i++){
        for(int j=1;j<=2350;j++){
            f[i][j]=(f[i][j-1]+c[i][j])%P;
        }
    }
    while(T--){
        scanf("%lld%lld",&n,&k);
        printf("%lld\n",F(n,k));
    }
    return 0;
}

```




---

## 作者：Ame__ (赞：6)

#### 建议结合[博客](https://www.cnblogs.com/Ame-sora/p/13357410.html)食用

这个题在考试的时候没多想就直接当$lucas$的板子写了结果还拿了50，考完之后觉得事情没这么简单推了一会决定写一篇

此题对于50%的数据可以直接用$lucas$定理卡过去，但你看后面的数据你就会发现事情绝对没有那么简单，应该有亿点技巧在里面，这时候我们就要开始用我们的$lucas$定理推柿子了

### 前置芝士$lucas$定理
$C_{n}^{m}\%p=C_{n/p}^{m/p}*C_{n\%p}^{m\%p}\%p$
~~证明建议自己去百度，读者自证不难~~

### 正文
有了这个之后我们就可以开始推柿子了
简化题面我们可以得到以下柿子$\begin{aligned}\sum_{i=0}^kC_{n}^i\%p\end{aligned}$

这里我们设$f(n,k)=\sum_{i=0}^kC_{n}^i$，$p=2333$

用$lucas$定理将后面拆开之后可以得到$\begin{aligned}f(n,k)=\sum_{i=0}^kC_{n}^i=\sum_{i=0}^kC_{n/p}^{i/p}*C_{n\%p}^{i\%p}\end{aligned}$

随后考虑将两个$C$拆开，此时考虑$i\%p$的贡献，可以发现p是一个质数,考虑i在小于p的区间内所得到的$i\%p$总共有$0$~$p-1$的贡献，对于i大于p的情况也是同理,那么我们可以得到
$\begin{aligned}C_{n/p}^0\sum_{i=0}^{p-1}C_{n\%p}^i+C_{n/p}^1\sum_{i=0}^{p-1}C_{n\%p}^i+...+C_{n/p}^{k/p-1}\sum_{i=0}^{p-1}C_{n\%p}^i+C_{n/p}^{k/p}\sum_{i=0}^{k\%p}C_{n\%p}^i\end{aligned}$

对于最后一块我们先不做处理，然后我们发现可以提公因式，因此我们将$\begin{aligned}\sum_{i=0}^{P-1}\times C_{n\%P}^{i}\end{aligned}$

提出来可以得到$\begin{aligned}(C_{n/p}^0+C_{n/p}^1+...C_{n/p}^{k/p-1})*\sum_{i=0}^{p-1}C_{n\%p}^i\end{aligned}$

对于前面你还可以提出来一个$\sum$变成$\begin{aligned}\sum_{i=0}^{k/p-1}C_{n\%p}^i\end{aligned}$

然后我们套用$\begin{aligned}f(n,k)=\sum_{i=0}^kC_{n}^i\end{aligned}$，可以变成$\begin{aligned}f(n\%p,p-1)*f(\lfloor \frac np\rfloor , \lfloor \frac kp \rfloor-1)\end{aligned}$

而对于我们剩下的$\begin{aligned}C_{n/p}^{k/p}\sum_{i=0}^{k\%p}C_{n\%p}^i\end{aligned}$

我们也可以拆开变成$\begin{aligned}C_{n/p}^{k/p}*f(n\%p,m\%p)\end{aligned}$

那么最后答案可以变为$\begin{aligned}f(n\%p,p-1)*f(\lfloor \frac np\rfloor , \lfloor \frac kp \rfloor-1)+C_{n/p}^{k/p}*f(n\%p,m\%p)\end{aligned}$

对于f和c的预处理我们只需要先处理p以内的即可
```.cpp
#include<bits/stdc++.h>

#define LL long long

using namespace std;

template <typename T> void read(T & t) {              
    t = 0;int f = 1;char ch = getchar();
    while(ch < '0' || ch > '9'){if(ch == '-')f =- 1;ch = getchar();}
    do{t = t * 10 + ch - '0';ch = getchar();}while(ch >= '0' && ch <= '9');t *= f;
}

const int kato = 3e3 + 1;

#define mod 2333

int t;

LL inv[kato] , sum[kato] , f[kato][kato];

inline LL quick_pow(LL a , LL b){
    LL res = 1;
    for(; b ; b >>= 1 , a = a * a % mod){
        if(b & 1){
            res = res * a % mod;
        }
    }
    return res % mod;
}

inline LL c(LL n , LL m){
    if(n < m){
        return 0;   
    }
    if(n < mod && m < mod){
        return (sum[n] * quick_pow(sum[m] * sum[n - m] % mod , mod - 2) ) % mod;
    }
    return c(n / mod , m / mod) * c(n % mod , m % mod) % mod;
}

inline LL lucas(LL n , LL m){
    if(n < mod && m < mod){
        return f[n][m];
    }
    else{
        return (c(n / mod , m / mod) * lucas(n % mod , m % mod) + lucas(n % mod , mod - 1) * lucas(n / mod , m / mod - 1)) % mod;
    }
}

inline void init(){
    sum[0] = 1;
    for(int i = 1;i <= kato;i ++){
        sum[i] = (sum[i - 1] * (i % mod) )% mod;
    }
    for(int i = 0;i <= mod;i ++){
        f[i][0] = c(i , 0);
        for(int j = 1;j <= mod;j ++){
            f[i][j] = (f[i][j - 1] + c(i , j)) % mod;
        }
    }
}



inline int Ame_(){
    // freopen("b.in" , "r" , stdin);
    // freopen("b.out" , "w" , stdout);
    read(t);
    init();
    for(LL n , k; t --> 0 ;){
        read(n);read(k);
        LL ans = 0;
        ans = lucas(n , k);
        printf("%lld\n" , ans);
    }
    // fclose(stdin);
    // fclose(stdout);
    return 0;
}

int Ame__ = Ame_();

int main(){;}
```

---

## 作者：appear_hope (赞：3)

首先根据卢卡斯定理：$C(n, m) = C(\lfloor \frac{n}{p} \rfloor, \lfloor \frac{m}{p} \rfloor) \times C(n \bmod p, m \bmod p)$。

考虑设计 $S(n, k)$ 函数， $S(n, k) = \sum \limits_{i = 0}^{k} C(n, i)$。

考虑乘法原理处理 $C(n \bmod p, m \bmod p)$ 相同的部分。
（为社么不同意处理 $C(\lfloor \frac{n}{p} \rfloor, \lfloor \frac{m}{p} \rfloor)$ 因为 $\lfloor \frac{m}{p} \rfloor$ 在本题数据下范围较广）考虑枚举当 $m \mod p = i$ 时 $C(\lfloor \frac{n}{p} \rfloor, \lfloor \frac{m}{p} \rfloor)$ 的和，考虑一个性质：当 $a \ne b$ 时，若 $a \equiv b\pmod p$ 则 $\lfloor \frac{a}{p} \rfloor \ne \lfloor \frac{b}{p} \rfloor$，所以只需考虑第一个 $\equiv i \pmod p$ 的数和最后一个 $\mod p = i$ 的数。

此时时间复杂度：$O(T \log_{2333} n \times 2333)$。

考虑不去枚举 $i$，观察 $\bmod \ p$ 的取值规律。

观察到 $[0, r]$ 这段区间 $\bmod \ p$ 的取值情况：$0, 1, 2, \dots, p - 1, \dots, 0, \dots, r \bmod \ p$。

所以只有最后一段 $0, 1, \dots, r \bmod \ p$ 不是循环节。

所以只有 $0, 1, \dots, r \bmod \ p$ 这一段区间内在乘法原理计算时会存在 $C(\lfloor \frac{n}{p} \rfloor, \lfloor \frac{r}{p} \rfloor) \times C(n \bmod p, i \bmod p)$ 的贡献。

由于这里还有一个 $C(\lfloor \frac{n}{p} \rfloor, \lfloor \frac{r}{p} \rfloor)$，考虑再写一个计算组合数的 Lucas。

由于这里涉及到 $C(n \bmod p, i \bmod p)$ 的区间之和，所以在 Lucas 预先处理组合数时顺便计算前缀和。

由于我们不需要枚举每种 $a \bmod p$ 的情况了，所以此时时间复杂度：$O(T \log_{2333} n)$。

代码如下：

```cpp
#include<bits/stdc++.h>

using namespace std;

const int mod = 2333;
const long long INF = 5e15;

long long n, k;
int T, c[mod + 5][mod + 5], s[mod + 5][mod + 5];

void init(){
	for(int i = 0; i < mod; i++){
		c[i][0] = 1;
		for(int j = 1; j <= i; j++){
			c[i][j] = c[i - 1][j - 1] + c[i - 1][j];
			if(c[i][j] >= mod) c[i][j] -= mod;
		}
		for(int j = 0; j < mod; j++){
			s[i][j] = c[i][j];
			if(j) s[i][j] += s[i][j - 1];
			if(s[i][j] >= mod) s[i][j] -= mod;
		}
	}
}

long long C1(long long n, long long m){
	if(n < m) return 0;
	return c[n][m];
}

long long C2(long long n, long long m){
	if(n < m) return 0;
	if(n < mod && m < mod) return C1(n, m);
	return C1(n % mod, m % mod) * C2(n / mod, m / mod) % mod;
}

long long solve(long long n, long long r){
	if(n < mod && r < mod) return s[n][r];
	long long now = solve(n / mod, r / mod);
	return (s[n % mod][r % mod] * now % mod + (s[n % mod][mod - 1] - s[n % mod][r % mod] + mod) * (now - C2(n / mod, r / mod) + mod) % mod) % mod;
}

void Solve(){
	cin >> n >> k;
	cout << solve(n, k) << '\n';
}

int main(){
	init();
	ios::sync_with_stdio(0), cin.tie(0);
	for(cin >> T; T--; Solve()){
	}
	return 0;
}
```

---

## 作者：ecnerwaIa (赞：3)

题意：给定 $n,k$ 求 $\sum_{j=1}^{k}C(n,j)$ ($n,k<=10^{18},mod=2333$)

[题目链接](https://www.luogu.org/problemnew/show/P4345)

令 $F(n,k)=\sum_{i=0}^{k}C(n,i)$，根据Lucas定理有

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$F(n,k)=\sum_{i=0}^{k}C_{n/mod}^{i/mod}*C_{n\% mod}^{m\%mod}$到这里就已经可以用分块做了，时间复杂度是$O(T*\sqrt{n})$,但这个时间复杂度远远达不到题目要求

将 所有$i/mod$相同的提出来(最后一块单独处理)就变成了

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$F(n,k)=(\sum_{i=0}^{k/mod-1}C_{n/mod}^{i})*(\sum_{i=0}^{mod-1}C_{n\%mod}^{mod-1})+(C_{n/mod}^{k/mod})*(\sum_{i=0}^{k\%mod}C_{n\%mod}^{i})$


根据我们定义的F,我们将其中的几个式子替换一下

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$F(n,k)=F(n/mod,k/mod-1)*F(n\%mod,mod-1)+C_{n/mod}^{k/mod}*F(n\%mod,k\%mod)$

发现什么没有？除了$F(n/mod,k/mod-1)$和$C(n/mod,k/mod)$之外其余的参数都小于mod,那么预处理就好了，求$C_{n/mod}^{k/mod}$用Lucas求，求F(n/mod,k/mod-1)就递归求，如果参数都小于mod，直接返回

这样时间复杂度为$O(mod^{2}+T*log_{2333}^{2}{n})$就愉快的A了
```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>
using namespace std;
#define ll long long
const int mod=2333;
int f[2400][2400],t,c[2400][2400];
inline int Lucas(ll n,ll m){if(n<m)return 0;if(!n)return 1;return Lucas(n/mod,m/mod)*1ll*c[n%mod][m%mod]%mod;}
inline int F(ll n,ll k){
	if(k<0)return 0;
	if(!n||!k)return 1;
	if(n<mod&&k<mod)return f[n][k];
	return (f[n%mod][mod-1]*1ll*F(n/mod,k/mod-1)%mod+Lucas(n/mod,k/mod)*1ll*f[n%mod][k%mod]%mod)%mod;
}
ll n,m;
int main(){
	scanf("%d",&t);
	for(int i=0;i<=mod;++i){
		c[i][0]=1;
		for(int j=1;j<=i;++j){
			c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;
		}
	}
	for(int i=0;i<=mod;++i){
		f[i][0]=1;
		for(int j=1;j<=mod;++j){
			f[i][j]=(f[i][j-1]+c[i][j])%mod;
		}
	}
	while(t--){
		scanf("%lld%lld",&n ,&m);
		printf("%d\n",F(n,m));
	}
	return 0;
}

```

---

## 作者：Water_Flower (赞：2)

## 题面

给定 $n,m$，一共 $T$ 组询问，求 $\sum\limits_{k = 0}^m \binom nk \bmod{2333}$

$n,m$ 在 $10^9$ 级别，$T$ 在 $10^5$ 级别。

## 解法：

先把 $k$ 按照 $\left\lfloor\frac kp \right\rfloor$ 分类

$$
\sum_{k = 0}^m \binom nk = \sum_{i = 0}^{\lfloor \frac mp \rfloor - 1} \sum_{j = 0}^{p - 1} \binom{n}{ip + j} + \sum_{k = p\lfloor \frac mp\rfloor}^m \binom nk
$$

再用 Lucas 定理展开：

$$
\sum_{i = 0}^{\lfloor \frac mp \rfloor - 1} \binom{\lfloor \frac np\rfloor}{i} \sum_{j = 0}^{p - 1} \binom{n \bmod p}{j} + \sum_{k = p\lfloor \frac mp\rfloor}^m \binom{\frac np}{\frac kp}\binom{n \bmod p}{k \bmod p}
$$

注意到 $\sum\limits_{j = 0}^{p - 1} \binom{n \bmod p}{j}$ 用一行之和定理表示为 $2^{n \bmod p}$，$\binom{\frac np}{\frac kp}$ 始终为定值，而且可以用普通的 Lucas 来求，于是上式可改写为：

$$
2^{n \bmod p} \sum_{i = 0}^{\lfloor \frac mp \rfloor - 1} \binom{\lfloor \frac np \rfloor}{i} + \binom{\frac np}{\frac kp} \sum_{k = 0}^{m \bmod p} \binom{n \bmod p}{k}
$$

然后发现左边可以递归，右边 Lucas + 预处理。于是做完了。复杂度为 $O(T log^2_p n)$ 。

## 总结一下

当 $p$ 很小的时候，下指标求和可以用 Lucas 定理递归求解。

当 $n \le m$ 的时候，可以用一行之和来求。

附上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define int long long
const int mod = 2333; 
ll n, m;
ll C[mod + 1][mod + 1], f[mod + 1][mod + 1];
ll lucas(int n, int m) {
	if(n < m) return 0;
	if(!m || n == m) return 1;
	return lucas(n / mod, m / mod) * C[n % mod][m % mod] % mod;
}
ll two[mod + 1];
ll calc(int n, int m) {
	if(m < 0) return 0;
	if(!n || !m) return 1; 
	if(n < mod && m < mod) return f[n][m];
	ll tmp = m / mod;
	return (f[n%mod][mod-1] * calc(n / mod, tmp - 1) % mod + lucas(n / mod, tmp) * f[n % mod][m % mod] % mod) % mod;
} 

void st(int n) {
	two[0] = 1; for(int i = 1; i <= n; ++i) two[i] = (two[i-1] << 1) % mod;
	C[0][0] = f[0][0] = 1;
	for(int j = 0; j <= n; ++j) f[0][j] = 1;
	for(int i = 1; i <= n; ++i) {
		C[i][0] = f[i][0] = 1;
		for(int j = 1; j <= i; ++j) C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;
		for(int j = 1; j <= n; ++j) f[i][j] = (f[i][j - 1] + C[i][j]) % mod;
	}
}
signed main() {
	st(mod);
	int _; cin >> _;
	while(_--) {
		cin >> n >> m;
		printf("%lld\n", calc(n, m));
	}
	return 0;
}//98 2 10
```

---

## 作者：wsm52 (赞：2)

# 前言
这是一道数学 $+$ Lucas定理的题目。
## 暴力 $25$ 分
直接使用Lucas定理。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL mod=2333;
int t;
LL n,k;
LL fastpow(LL x,LL p){
	LL res=1;
	while(p){
		if(p&1) res=res*x%mod;
		x=x*x%mod;
		p>>=1;
	}
	return res;
}
LL c(LL n,LL m){
	LL res=1;
	for(int i=1,j=n;i<=m;i++,j--){
		res=res*j%mod;
		res=res*fastpow(i,mod-2)%mod;
	}
	return res;
}
LL lucas(LL n,LL m){
	if(n<mod&&m<mod) return c(n,m);
	return c(n%mod,m%mod)*lucas(n/mod,m/mod)%mod;
}
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	scanf("%d",&t);
	while(t--){
		scanf("%lld%lld",&n,&k);
		LL sum=0;
		for(int i=0;i<=k;i++) sum=(sum+lucas(n,i))%mod;
		printf("%lld\n",sum); 
	}
	return 0;
}
```
## 优化一点 $50$分
题目中告诉我们答案要模 $2333$，那么我们可以运用公式：$C_{n}^{m}=C_{n-1}^{m}+C_{n-1}^{m-1}$ 进行打表，然后再用Lucas定理。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL mod=2333;
const int N=3010;
int t;
LL n,k,c[N][N];
LL lucas(LL n,LL m){
	if(n<mod&&m<mod) return c[n][m];
	return c[n%mod][m%mod]*lucas(n/mod,m/mod)%mod;
}
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	for(int i=0;i<N;i++) c[i][0]=1ll;
	for(int i=1;i<N;i++) for(int j=1;j<=i;j++) c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;
	scanf("%d",&t);
	while(t--){
		scanf("%lld%lld",&n,&k);
		LL sum=0;
		for(int i=0;i<=k;i++) sum=(sum+lucas(n,i))%mod;
		printf("%lld\n",sum); 
	}
	return 0;
}
```
## 正解
需要一点数学推导。

设 $f(n,k)=\sum_{i=0}^{k}C_{n}^{i}$，$p=2333$。

$\begin{aligned}
  f(n,k) &=\sum_{i=0}^{k}C_{n}^{i}\\
  &= \sum_{i=0}^{k}C_{n/p}^{i/p}\times C_{n \bmod p}^{i \bmod p} \\
  &= C_{n/p}^{0} \times \sum_{i=0}^{p-1}C_{n \bmod p}^{i}+C_{n/p}^{1} \times \sum_{i=0}^{p-1}C_{n \bmod p}^{i}+ \dots +C_{n/p}^{k/p} \times \sum_{i=0}^{k \bmod p}C_{n \bmod p}^{i}\\
  &= \sum_{i=0}^{p-1}C_{n \bmod p}^{i} \times (C_{n/p}^{0}+C_{n/p}^{1}+ \dots +C_{n/p}^{k/p-1})+C_{n/p}^{k/p} \times \sum_{i=0}^{k \bmod p}C_{n \bmod p}^{i}\\
  &= f(n \bmod p,p-1) \times f(n/p,k/p-1)+C_{n/p}^{k/p} \times f(n \bmod p,k \bmod p)
\end{aligned}$

由于 $n \bmod p$ 和 $k \bmod p$ 的值小于 $2333$ 可以直接做预处理。对于最终结果 $f(n,k)$ 只需做递归就好了。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL mod=2333;
const int N=3010;
int t;
LL n,k,c[N][N],f[N][N];
LL lucas(LL n,LL m){
	if(n<mod&&m<mod) return c[n][m];
	return c[n%mod][m%mod]*lucas(n/mod,m/mod)%mod;
}
LL F(LL n,LL m){
	if(m<0) return 0;
	if(!n||!m) return 1;
	if(n<mod&&m<mod) return f[n][m];
	return (f[n%mod][mod-1]*F(n/mod,m/mod-1)%mod+lucas(n/mod,m/mod)*f[n%mod][m%mod]%mod)%mod;
}
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	for(int i=0;i<N;i++) c[i][0]=c[i][i]=1ll;
	for(int i=1;i<N;i++) for(int j=1;j<i;j++) c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;
	for(int i=0;i<N;i++) f[i][0]=1;
	for(int i=0;i<N;i++) for(int j=1;j<N;j++) f[i][j]=(c[i][j]+f[i][j-1])%mod;
	scanf("%d",&t);
	while(t--){
		scanf("%lld%lld",&n,&k);
		printf("%lld\n",F(n,k)); 
	}
	return 0;
}
```

---

## 作者：genshy (赞：2)

我们要求的是这个柿子

$\displaystyle\sum_{i=0}^{k}C_{n}^{i} \bmod 2333$

我们可以用Lucas定理换一下变成

$\displaystyle\sum_{i=0}^{k}C_{n/p}^{i/p}C_{n\bmod p}^{i\bmod p}\bmod p$

然后，我们就会神奇的发现，$C_{n \bmod p}^{i \bmod p}$重复计算了好多次


我们发现从 0-p-1到p-2p-1..... 他们中间都有一段连续的 $\displaystyle\sum_{i=0}^{p-1}C_{n \bmod p}^{i}$

这样，我们就可以先计算这些段出现了多少次

就是 $\displaystyle\sum_{i=0}^{p-1}C_{n \bmod p}^{i} \times \displaystyle\sum_{i=0}^{k/p-1} C_{n/p}^{i}$

对于剩下的一些散块，我们直接可以套用卢卡斯定理来求。

也就是 $\displaystyle\sum_{i=0}^{k \bmod p}C_{n \bmod p}^{i}\times C_{n/p}^{k/p}$

对于这个 $\displaystyle\sum_{i=0}^{p-1}C_{n \bmod p}^{i}$ 柿子，我们可以通过预处理出[0,p-1]的组合数的前缀和搞出来。

$\displaystyle\sum_{i=0}^{k/p-1} C_{n/p}^{i}$  这个柿子呢，我们就可以直接递归处理。

### 总柿子

$\displaystyle\sum_{i=0}^{k}C_{n}^{i} \bmod 2333$

=$\displaystyle\sum_{i=0}^{k}C_{n/p}^{i/p}C_{n\bmod p}^{i\bmod p}\bmod p$

=$\displaystyle\sum_{i=0}^{p-1}C_{n \bmod p}^{i} \times \displaystyle\sum_{i=0}^{k/p-1} C_{n/p}^{i}$+ $\displaystyle\sum_{i=0}^{k \bmod p}C_{n \bmod p}^{i}\times C_{n/p}^{k/p}$

=$f（n mod p$，p-1）$ \times f(n \bmod p,k/p-1) + C_{n/p}^{k/p} \times f(n \bmod p,k \bmod p)$

其中 $f（x,y）$ = $\displaystyle\sum_{i = 0}^{y}C_{x}^{i}$

## 代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
#define LL long long
const int p = 2333;
LL t,a,b,c[2550][2550],f[2550][2550];
inline LL read()
{
	LL s = 0, w = 1; char ch = getchar();
	while(ch < '0' || ch > '9'){if(ch == '-') w = -1; ch = getchar();}
	while(ch >= '0' && ch <= '9'){s = s * 10+ch -'0'; ch = getchar();}
	return s * w;
}
LL Lucas(LL n, LL m)//Lucas定理求组合数
{
	if(m == 0) return 1;
	if(n < m) return 0;
	return c[n%p][m%p] * Lucas(n/p,m/p) % p;
}
LL calc(LL n,LL k)
{
	if(k < 0) return 0;
	if(n == 0 || k == 0) return 1;
	if(n < p && k < p) return f[n][k];
	return (f[n%p][p-1] * calc(n/p,k/p-1) % p + Lucas(n/p,k/p) * f[n%p][k%p] % p) % p;//递归处理
}
void YYCH()//预处理出0-p的组合数
{
	c[0][0] = f[0][0] = 1;
	for(int i = 1; i <= 2500; i++)//杨辉三角求组合数
	{
		c[i][0] = c[i][i] = 1;
		for(int j = 0; j <= i; j++)
		{
			c[i][j] = (c[i-1][j-1] + c[i-1][j]) % p;
		}
	}	
	for(int i = 0; i <= 2500; i++) f[i][0] = 1;
	for(int i = 0; i <= 2500; i++)//组合数的前缀和
	{
		for(int j = 1; j <= 2500; j++)
		{
			f[i][j] = (f[i][j-1] + c[i][j]) % p;
		}
	}
}
int main()
{
	t = read(); YYCH();
	while(t--)
	{
		a = read(); b = read();
		printf("%lld\n",calc(a,b));
	}
	return 0;
}
```


---

## 作者：Memory_of_winter (赞：2)

[我的博客](https://www.cnblogs.com/Memory-of-winter/p/10283798.html)

**题目大意：**给你$n,k$，求：
$$\sum\limits_{i=0}^k\binom n i\pmod{2333}$$
**题解：**令$p=2333,f(n,k)\equiv\sum\limits_{i=0}^k\binom n i\pmod p$

$$\begin{aligned}f(n,k)\equiv&\sum\limits_{i=0}^k\binom n i\pmod p\\ \equiv&\sum\limits_{i=0}^k\binom{\big\lfloor\frac np\big\rfloor}{\big\lfloor\frac ip\big\rfloor}\binom{n\bmod p}{i\bmod p}\pmod p\\\end{aligned}$$

令$s=\left\lfloor\dfrac k p\right\rfloor$

$$\begin{aligned}f(n,k)\equiv&[\sum\limits_{i=0}^{p-1}\binom{n\bmod p}{i}][\sum\limits_{i=0}^{s-1}\binom{\big\lfloor\frac n p\big\rfloor}{i}]\\&+\binom{\left\lfloor\frac np\right\rfloor}{s}\sum\limits_{i=sp}^k\binom{n\bmod p}{i\bmod p}\pmod p\\	\equiv&[\sum\limits_{i=0}^{p-1}\binom{n\bmod p}{i}][\sum\limits_{i=0}^{s-1}\binom{\big\lfloor\frac n p\big\rfloor}{i}]\\	&+\binom{\left\lfloor\frac np\right\rfloor}{s}\sum\limits_{i=0}^{k\bmod p}\binom{n\bmod p}{i}\pmod p\\	\equiv&f(n\bmod p, p-1)f(\left\lfloor\dfrac np\right\rfloor,s-1)\\	&+\binom{\big\lfloor\frac np\big\rfloor}{s}f(n\bmod p,k\bmod p)\pmod p\\\end{aligned}$$




**C++ Code：**

```cpp
#include <cstdio>
const int mod = 2333;
#define maxn mod
inline void reduce(int &x) { x += x >> 31 & mod; }

int Tim;
long long n, k;
int com[maxn][maxn], pre[maxn][maxn];

int C(long long a, long long b) {
	if (a < b) return 0;
	if (a < mod) return com[a][b];
	return com[a % mod][b % mod] * C(a / mod, b / mod) % mod;
}
int solve(long long n, long long k) {
	if (k < 0) return 0;
	if (n < mod && k < mod) return pre[n][k];
	const long long s = k / mod;
	return (pre[n % mod][mod - 1] * solve(n / mod, s - 1) + pre[n % mod][k % mod] * C(n / mod, s)) % mod;
}
int main() {
	scanf("%d", &Tim);
	for (int i = 0; i < mod; ++i) {
		*com[i] = *pre[i] = 1;
		for (int j = 1; j <= i; ++j) {
			reduce(com[i][j] = com[i - 1][j] + com[i - 1][j - 1] - mod);
			reduce(pre[i][j] = pre[i][j - 1] + com[i][j] - mod);
		}
		for (int j = i + 1; j < mod; ++j) reduce(pre[i][j] = pre[i][j - 1] + com[i][j] - mod);
	}
	while (Tim --> 0) {
		scanf("%lld%lld", &n, &k);
		printf("%d\n", solve(n, k));
	}
	return 0;
}

```



---

## 作者：ghj1222 (赞：2)

[据说在博客园看食用效果更佳？](https://www.cnblogs.com/oier/p/10302092.html)

输入$n,k$，求$\sum_{i=0}^k{n\choose i}$对2333取模，10万组询问，n,k<=1e18

注意到一个2333这个数字很小并且还是质数这一良好性质，我们可以根据Lucas定理优化式子

为了方便，令$p=2333$

设$f(n,k)=\sum_{i=0}^k{n\choose i}$

对于$i\in[0,p\lfloor\frac kp\rfloor)$，根据lucas定理有${n\choose i}={n\%p\choose i\%p}{n/p\choose i/p}$

对于每一对$(i\%p,i/p)$都能惟一确定一个$i$，根据乘法原理有

$f(n\%p,p-1)*f(\lfloor\frac np\rfloor,\lfloor\frac kp\rfloor-1)$

对于$i\in[p\lfloor\frac kp\rfloor,k]$则它们/p的值相同，根据Lucas定理可以化为${\lfloor\frac np\rfloor\choose\lfloor\frac kp\rfloor}*f(n\%p,k\%p)$

所以$f(n,k)=f(n\%p,p-1)*f(\lfloor\frac np\rfloor,\lfloor\frac kp\rfloor-1)+{\lfloor\frac np\rfloor\choose\lfloor\frac kp\rfloor}*f(n\%p,k\%p)$

先预处理0~p-1阶乘及其逆元，0~p-1里的组合数可以O(1)

注意到在f的递推式中频繁用到了0~p-1内的f值，所以先O(p^2)处理这些f

那么时间复杂度递推式就是$T(n,k)=T(\lfloor\frac np\rfloor,\lfloor\frac kp\rfloor)+\log p$，如果nk同阶，复杂度$O(T\log n\log ^2p)$好像是

一开始复杂度写错了，最后6个点狂T。。。

代码

```cpp
#include <cstdio>
using namespace std;

const int p = 2333;

int fac[3000], inv[3000];
int f[3000][3000];

int qpow(int x, int y)
{
	int res = 1;
	for (x %= p; y > 0; x = x * x % p, y >>= 1) if (y & 1) res = res * x % p;
	return res;
}

int c(long long n, long long m)
{
	if (n < m || m < 0) return 0;
	if (n < p && m < p) return fac[n] * inv[m] % p * inv[n - m] % p;
	return c(n / p, m / p) * c(n % p, m % p) % p;
}

int work(long long n, long long k)
{
	if (n < p && k < p) return f[n][k];
	return (c(n / p, k / p) * work(n % p, k % p) + work(n % p, p - 1) * work(n / p, k / p - 1)) % p;
}

int main()
{
	fac[0] = 1;
	for (int i = 1; i < p; i++)
		fac[i] = fac[i - 1] * i % p;
	inv[p - 1] = qpow(fac[p - 1], p - 2);
	for (int i = p - 1; i >= 1; i--)
		inv[i - 1] = inv[i] * i % p;
	for (int i = 0; i < p; i++)
	{
		f[i][0] = c(i, 0);
		for (int j = 1; j < p; j++)
			f[i][j] = (f[i][j - 1] + c(i, j)) % p;
	}
	int t; scanf("%d", &t);
	while (t --> 0)
	{
		long long x, y;
		scanf("%lld%lld", &x, &y);
		printf("%d\n", work(x, y));
	}
	return 0;
}
```

WA了好几发，define int long long过了后来发现计算C时候三个数乘一起就炸int了。。。

---

## 作者：Super_Cube (赞：1)

# Solution

设 $p=2333$，题意为 $f(n,k)=\displaystyle\sum_{i=0}^k\binom{n}{i}\bmod p$。

由于 $p$ 为质数，有卢卡斯定理：$\displaystyle\sum_{i=0}^k\binom{\lfloor\frac{n}{p}\rfloor}{\lfloor\frac{i}{p}\rfloor}\binom{n\bmod p}{i\bmod p}\bmod p$。

$\left\lfloor\dfrac{n}{p}\right\rfloor$ 是定值，而 $\left\lfloor\dfrac{i}{p}\right\rfloor$ 的形式让人联想到整除分块。

枚举 $\left\lfloor\dfrac{i}{p}\right\rfloor$：$\left(\displaystyle\sum_{i=0}^{\lfloor\frac{k}{p}\rfloor-1}\binom{\lfloor\frac{n}{p}\rfloor}{i}\sum_{j=0}^{p-1}\binom{n\bmod p}{j}+\binom{\lfloor\frac{n}{p}\rfloor}{\lfloor\frac{k}{p}\rfloor}\sum_{i=0}^{k\bmod p}\binom{n\bmod p}{i}\right)\bmod p$。

观察出三大坨和式都符合 $f$ 的形式，此时把 $f$ 套进去。

即 $\left(f\left(\left\lfloor\dfrac{n}{p}\right\rfloor,\left\lfloor\dfrac{k}{p}\right\rfloor-1\right)f(n\bmod p,p-1)+\displaystyle\binom{\lfloor\frac{n}{p}\rfloor}{\lfloor\frac{k}{p}\rfloor}f(n\bmod p,k\bmod p)\right)\bmod p$。

预处理出 $\forall i,j\in[0,p)$ 的 $f(i,j)$ 与 $\displaystyle\binom{i}{j}$，只需递归计算 $f\left(\left\lfloor\dfrac{n}{p}\right\rfloor,\left\lfloor\dfrac{k}{p}\right\rfloor-1\right)$ 与 $\displaystyle\binom{\lfloor\frac{n}{p}\rfloor}{\lfloor\frac{k}{p}\rfloor}$，其余可直接调用预处理得到的结果。

# Code

```cpp
#include<stdio.h>
typedef long long ll;
const int mod=2333;
int c[mod][mod];
int C(ll n,ll m){
	if(n<mod&&m<mod)return c[n][m];
	return 1ll*C(n/mod,m/mod)*c[n%mod][m%mod]%mod;
}
int s[mod][mod];
int calc(ll n,ll m){
    if(m<0)return 0;
	if(n<mod&&m<mod)return s[n][m];
	return (1ll*s[n%mod][mod-1]*calc(n/mod,m/mod-1)+1ll*C(n/mod,m/mod)*s[n%mod][m%mod])%mod;
}
int T;
ll n,m;
int main(){
	for(int i=0;i<mod;++i){
		c[i][0]=c[i][i]=1;
		for(int j=1;j<i;++j)
			if((c[i][j]=c[i-1][j]+c[i-1][j-1])>=mod)c[i][j]-=mod;
	}
	for(int i=0;i<mod;++i){
		s[i][0]=1;
		for(int j=1;j<mod;++j)
			if((s[i][j]=s[i][j-1]+c[i][j])>=mod)s[i][j]-=mod;
	}
	scanf("%d",&T);
	while(T--)
		scanf("%lld%lld",&n,&m),
		printf("%d\n",calc(n,m));
	return 0;
}
```

---

## 作者：Otue (赞：1)

根据 Lucas 定理：

$$
\dbinom{n}{0}+\dbinom{n}{1}+\dots+\dbinom{n}{k}
$$

$$
=\dbinom{\dfrac{n}{p}}{0}\times \dbinom{n \bmod p}{0}+\dbinom{\dfrac{n}{p}}{\dfrac{1}{p}}\times \dbinom{n \bmod p}{1 \bmod p}+\dots +\dbinom{\dfrac{n}{p}}{\dfrac{k}{p}}\times \dbinom{n \bmod p}{k\bmod p}
$$

容易发现 $\dbinom{\dfrac{n}{p}}{\dfrac{0}{p}}$ 到 $\dbinom{\dfrac{n}{p}}{\dfrac{p-1}{p}}$ 是相同的，$\dbinom{\dfrac{n}{p}}{\dfrac{p}{p}}$ 到 $\dbinom{\dfrac{n}{p}}{\dfrac{2\times p-1}{p}}$ 也是相同的，依次类推。所以可以对式子进行继续化简，提出相同的公因式。令 $t_{j}=\sum _{i=0}^{j}\dbinom{n \bmod p}{i}$，则有：



$$
=\dbinom{\dfrac{n}{p}}{0}\times t_{p-1}+\dbinom{\dfrac{n}{p}}{1}\times t_{p-1}+\dots +\dbinom{\dfrac{n}{p}}{\dfrac{k}{p}-1}\times t_{p-1}+\dbinom{\dfrac{n}{p}}{\dfrac{k}{p}}\times t_{k\bmod p}
$$

$$
=t_{p-1}\times [\dbinom{\dfrac{n}{p}}{0}+\dbinom{\dfrac{n}{p}}{1}+\dots+\dbinom{\dfrac{n}{p}}{\dfrac{k}{p}-1}]+\dbinom{\dfrac{n}{p}}{\dfrac{k}{p}}\times t_{k\bmod p}
$$

中括号那一堆和最开始求的东西形式一样，可以进行递归处理。复杂度 $O(\log n)$。

```c++
#include <bits/stdc++.h>
using namespace std;

#define int long long
const int N = 3005, mod = 2333;
int T, n, k, fac[N], invfac[N], sum[N][N];

int qpow(int a, int k, int p) {
	int res = 1;
	while (k) {
		if (k & 1) res = res * a % p;
		a = a * a % p;
		k >>= 1; 
	}
	return res;
}

int C(int a, int b) {
	if (a < b) return 0;
	return fac[a] * invfac[a - b] % mod * invfac[b] % mod;
}

int lucas(int a, int b, int p) {
	if (a < p && b < p) return C(a, b);
	return C(a % p, b % p) * lucas(a / p, b / p, p) % p;
}

int get(int n, int k, int p) {
	if (n < p && k < p) return sum[n][k];
	return (sum[n % p][p - 1] * get(n / p, k / p - 1, p) % p + lucas(n / p, k / p, p) * sum[n % p][k % p] % p) % p;
}

signed main() {
	fac[0] = invfac[0] = 1;
	for (int i = 1; i <= N - 5; i++) {
		fac[i] = fac[i - 1] * i % mod;
		invfac[i] = qpow(fac[i], mod - 2, mod);
	}
	for (int i = 0; i <= N - 5; i++) {
		sum[i][0] = 1;
		for (int j = 1; j <= N - 5; j++) sum[i][j] = sum[i][j - 1] + C(i, j), sum[i][j] %= mod; 
	}
	cin >> T;
	while (T--) {
		cin >> n >> k;
		cout << get(n, k, mod) << endl;
	} 
}
```

---

## 作者：zzw4257 (赞：1)

设$\displaystyle{f_{n,k}=\sum_{i=0}^kC_n^i}$

$\displaystyle{=\sum_{i=0}^kC_{n/p}^{i/p}\times C_{n\%p}^{i\%p}}$

考虑枚举同样的$i/p$，它对应的$i\%p\in[0,p-1]$

具体的的说

$=\displaystyle{C_{n/p}^0\times\sum_{i=0}^{p-1}C_{n\%p}^i+C_{n/p}^1\times\sum_{i=0}^{p-1}C_{n\%p}^i+\cdots C_{n/p}^{k/p-1}\times\sum_{i=0}^{p-1}C_{n\%p}^i+C_{n/p}^{k/p}\times\sum_{i=0}^{k\%p}C_{n\%p}^i}$

$=\displaystyle{\sum_{i=0}^{p-1}C_{n\%p}^{i}\times\sum_{j=0}^{k/p-1}C_{n/p}^{j}}+C_{n/p}^{k/p}\times\sum_{i=0}^{k\%p}C_{n\%p}^i$

$=\displaystyle{f_{n\%p,p-1}\times f_{n/p,k/p-1}+C_{n/p}^{k/p}\times f_{n\%p,k\%p}}$

因此预处理后直接递归即可

注意处理$f_{n,k}~k>n$的情况

```cpp
#include<bits/stdc++.h>
#define re register
#define N 2335
#define INF 0x3f3f3f3f
#define mod 2333 
using namespace std;
template<typename _int>
inline void read(re _int& x){
	re char opt;re _int flag=1,res=0;
	while((opt=getchar())<'0'||opt>'9')if(opt=='-')flag=-1;
	while(opt>='0'&&opt<='9'){res=(res<<3)+(res<<1)+opt-'0';opt=getchar();}
	x=res*flag;
}
typedef long long ll;
int Case;
ll n,k,C[N][N],f[N][N];
inline ll Lucas(re ll n,re ll m){
	if(!m)return 1ll;
	return Lucas(n/mod,m/mod)*C[n%mod][m%mod]%mod;
}
inline ll F(re ll n,re ll k){
	if(!n||!k)return 1ll;
	if(n<mod&&k<mod)return f[n][k];
	return (f[n%mod][mod-1]*F(n/mod,k/mod-1)%mod+Lucas(n/mod,k/mod)*f[n%mod][k%mod]%mod)%mod;//非整块+整块(i%p遍历[0,p-1]否)
}
inline void Init(void){
	re int i,j;
	C[0][0]=1ll;
	for(i=1;i<=2333;++i)C[i][i]=C[i][0]=1ll;
	for(i=1;i<=2333;++i)
		for(j=1;j<i;++j)C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;
	f[0][0]=1ll;
	for(i=1;i<=2333;++i)f[0][i]=1ll;
	for(i=1;i<=2333;++i){
		f[i][0]=1ll;
		for(j=1;j<=2333;++j)f[i][j]=(f[i][j-1]+C[i][j])%mod;
	}
}
inline void Solve(void){read(n);read(k);printf("%lld\n",F(n,k));}
int main(void){
	Init();read(Case);
	while(Case--)Solve();
	return 0;
}
```

---

## 作者：Super_Builder (赞：1)

## 前言

本人第一次写这么详细，写得不好请指出。

## 思路
### Lucas 定理

$$C_n^m \equiv C_{\lfloor\frac{n}{p}\rfloor}^{\lfloor\frac{m}{p}\rfloor} \times C_{n \bmod p}^{m \bmod p} \pmod p$$

简单证明一下。

#### 引理 1

$C_n^m$ 就是 $(1+x)^n$ 展开后 $x^m$ 的系数，这个根据二项式定理可得。

#### 引理 2

$(1+x)^p  = \sum_{i=0}^{p}C_p^i \times x^{p-i} $

又由于：

$C_{p}^{i}= \frac{p!}{(p-i)!i!}$

右式分母当且仅当 $i=0$ 或 $i=p$ 时才含有质因子 $p$，所以：$\sum_{i=1}^{p-1} C_p^i  \equiv 0 \pmod p$。

$$(1+x)^p =\sum_{i=0}^{p}C_p^i \times x^{p-i} \equiv x^p+1 \pmod p$$

#### 最终证明

我们设 $n=qp+s$，$m=tp+r$，其中 $r,s \le p-1$。

由引理 1 的式子拓展。

$$(1+x)^n$$
$$=(1+x)^{qp}\times (1+x)^s$$

再由于引理 2。

$$\equiv(1+x^p)^q\times (1+x)^s \pmod p$$
$$\equiv(\sum_{i=0}^q C_q^i \times x^{p(q-i)})\times(\sum_{i=0}^{s}C_s^i \times x^{s-i}) \pmod p$$

而我们要的得到的是 $x^m=x^{tp}\times x^r$ 的系数。

显然 $x^{tp}$ 在 $(\sum_{i=0}^q C_q^i \times x^{p(q-i)})$ 里面，$x^r$ 在 $(\sum_{i=0}^{s}C_s^i \times x^{s-i})$ 里面。

代入得到 $x^{tp}$ 的系数为 $C_q^{q-t}=C_q^{t}$，$x^r$ 的系数为 $C_s^{s-r}=C_s^r$。那么 $x^m$ 的系数就为 $C_q^t\times C_r^s = C_{\lfloor\frac{n}{p}\rfloor}^{\lfloor\frac{m}{p}\rfloor} \times C_{n \bmod p}^{m \bmod p} \pmod p$。

所以:

$C_n^m = C_{\lfloor\frac{n}{p}\rfloor}^{\lfloor\frac{m}{p}\rfloor} \times C_{n \bmod p}^{m \bmod p} \pmod p$

证毕。

### 推式子

回到原问题，知道了 Lucas，接下来就简单了。

首先，原问题可以转化为下列这个式子。

$$\sum_{i=0}^k C_n^i \pmod p$$

运用 Lucas，可以变成以下的式子。

$$\sum_{i=0}^k C_{\lfloor\frac{n}{p}\rfloor}^{\lfloor\frac{i}{p}\rfloor} \times C_{n \bmod p}^{i \bmod p}$$


类似于分块，提取 $C_{n \bmod p}^{i \bmod p}$，省略号表示一个不满的块，变成下式。

$$=\sum_{i=0}^{p-1}C_{n \bmod p}^{i } \times (\sum_{j=0}^{\lfloor \frac{k}{p}\rfloor-1}C_{\lfloor\frac{n}{p}\rfloor}^{j}) + ...$$

这个乘法两边的东西和最开始的式子很像，所以可以继续递归。


省略的东西是什么呢？

$$\sum_{i=0}^{k \bmod p}C_{\lfloor \frac{n}{p}\rfloor}^{\lfloor \frac{k}{p}\rfloor}\times C_{n \bmod p}^{i}$$

乘法左边直接用 Lucas，右边继续递归。

设：
$$f(n,k)=\sum_{i=0}^k C_n^i \pmod p$$

那么：
$$f(n,k) \equiv f(n \bmod p,p-1)\times f(\lfloor \frac{n}{p} \rfloor,\lfloor \frac{k}{p} \rfloor-1)+f(n \bmod p,k \bmod p)\times C(\lfloor \frac{n}{p} \rfloor,\lfloor \frac{k}{p} \rfloor)\pmod p$$

在预处理出 $n,k\le p-1$ 的答案，问题就解决了。

## AC CODE

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define p 2333
inline int qpow(int x,int t){
	int ans=1;
	while(t){
		if(t&1){
			ans=(ans*x)%p;
		}
		x=(x*x)%p;
		t>>=1;
	}
	return ans;
}
int fac[2505],inv[2505],f[2505][2505];
void init(){
	fac[0]=1;
	for(int i=1;i<=2332;i++){
		fac[i]=fac[i-1]*i%p;
	}
	inv[2332]=qpow(fac[2332],p-2);
	for(int i=2331;i>=0;i--){
		inv[i]=inv[i+1]*(i+1)%p;
	}
}
int C(int n,int m){
    if(n<m)return 0;
    if(n==m)return 1;
	return fac[n]*inv[m]%p*inv[n-m]%p;
}
int Lucas(int n,int m){
    if(n<m)return 0;
    if(m==0)return 1;
    return Lucas(n/p,m/p)*C(n%p,m%p)%p;
}
int slove(int n,int k){
    if(n==0||k==0){
        return 1;
    }
    if(k<0){
        return 0;
    }
    if(n<p&&k<p){
        return f[n][k];
    }
    return (slove(n%p,p-1)*slove(n/p,k/p-1)%p+slove(n%p,k%p)*Lucas(n/p,k/p)%p)%p;
}
int T;
signed main(){
    init();
    cin>>T;
    for(int i=0;i<=p;i++){
        f[i][0]=1;
        for(int j=1;j<=p;j++){
            f[i][j]=(f[i][j-1]+C(i,j))%p;
        }   
    }
    while(T--){
        int n,k;
        cin>>n>>k;
        cout<<slove(n,k)<<endl;
    }
    return 0;
}
```

---

## 作者：Lazy_crush (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P4345)
### P4345 [SHOI2015] 超能粒子炮·改=组合数+卢卡斯定理+数学思想

* 简述题意：给定  $n,k \le 10^{18}$， $p=2333$，求 $\sum_{i=0}^{k} C_n^i \bmod p$。

* 前置知识：组合数递推：$ C_m^n=C_{m-1}^n+C_{m-1}^{n-1} $。
  
* 参考代码（请注意边界）：

```cpp
void Getc(){
	c[0][0]=1;
	for(int i=1;i<p;i++) c[i][0]=1;
	for(int i=1;i<p;i++)
		for(int j=1;j<=i;j++)
			c[i][j]=(c[i-1][j]+c[i-1][j-1])%p;
}
```
* 前置知识：[卢卡斯定理](https://oi-wiki.org/math/number-theory/lucas/)：$ C_n^m \bmod p = C_{\lfloor n/p \rfloor}^{\lfloor m/p \rfloor} \times C_{n \bmod p}^{m \bmod p} \bmod p $。
  * 证明：设 $n=sp+q$， $m=tp+r$，其中 $0 \le q,r \le p-1$。
  * 构造多项式 $(1+x)^n=(1+x)^{sp+q}=((1+x)^p)^s\times (1+x)^q$。
  * $\because \forall 1\le i\le p-1$， $C_p^i \equiv 0 \pmod p$。
    
  * $\therefore (1+x)^p =1+C_p^1 x+\cdots+C_p^{p-1}x^{p-1}+x^p \equiv 1+x^p \pmod p$。
  * 因此有 $(1+x)^n\equiv (1+x^p)^s\times (1+x)^q=\sum_{i=0}^s C_s^ix^{ip}\times \sum_{i=0}^q C_q^i x^i$。
  * 比较等式两端 $x^{tp+r}$ 的系数，可得：
  *  $C_n^m=C_{sp+q}^{tp+r}\equiv C_s^t\times C_q^r=C_{\lfloor n/p \rfloor}^{\lfloor m/p \rfloor} \times C_{n \bmod p}^{m \bmod p} \pmod p$。
  *  即定理得证。
* 参考代码：
```cpp
ll lucas(ll n,ll m){
	if(!n) return 1; 
	if(n<m) return 0;
	if(n<p) return c[n][m];
	return lucas(n/p,m/p)*c[n%p][m%p]%p;
}
```
* 回到原题，考虑转化式子：
* 由卢卡斯定理可得，
      $\sum_{i=0}^kC_n^i \\$  
      $\equiv \sum_{i=0}^kC_{\lfloor n/p \rfloor}^{\lfloor m/p \rfloor} \times C_{n \bmod p}^{m \bmod p} \\$  
      $=\sum_{i=0}^{\lfloor k/p \rfloor-1}  C_{\lfloor n/p \rfloor}^i  \sum_{j=0}^{p-1}  C_{n \bmod p}^j+C_{\lfloor n/p \rfloor}^{\lfloor k/p \rfloor} \times \sum_{j=0}^{k \bmod p} C_{n \bmod p}^j \pmod p$。
  
* 记 $f(n,k)=\sum_{i=0}^kC_n^i$。
* 则 $f(n,k)=f(\lfloor n/p \rfloor,\lfloor k/p \rfloor -1)\times f(n \bmod p,p-1)+C_{\lfloor n/p \rfloor}^{\lfloor k/p \rfloor}\times f(n \bmod p,k \bmod p)$。
* 时间复杂度 $O(p^2+T\log n)$。
* 参考代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int p=2333,N=p+5;
ll T,n,k,c[N][N],f[N][N];
void Getc(){
	c[0][0]=1;
	for(int i=1;i<p;i++) c[i][0]=1;
	for(int i=1;i<p;i++)
		for(int j=1;j<=i;j++)
			c[i][j]=(c[i-1][j]+c[i-1][j-1])%p;
}
ll lucas(ll n,ll m){
	if(!n) return 1; 
	if(n<m) return 0;
	if(n<p) return c[n][m];
	return lucas(n/p,m/p)*c[n%p][m%p]%p;
}
ll F(ll n,ll k){
	if(n==0||k==0) return 1;
	if(n<p&&k<p) return f[n][k];
	return (f[n%p][p-1]*F(n/p,k/p-1)%p+lucas(n/p,k/p)*f[n%p][k%p]%p)%p;
}
int main(){
	Getc();
	for(int i=0;i<p;i++) f[i][0]=1;
	for(int i=0;i<p;i++)
		for(int j=1;j<p;j++)
			f[i][j]=(f[i][j-1]+c[i][j])%p;
	cin>>T;
	while(T--){
		cin>>n>>k;
		cout<<(ll)(F(n,k))<<"\n";
	}
	return 0;
}

```
[Accepted。](https://www.luogu.com.cn/record/213268899)

---

## 作者：Furina_Saikou (赞：0)

这道题代码无难度，难就难在推式子。

# 思路

简化题意：给定两个整数 $n,k$，求 $\displaystyle\sum_{i=0}^kC_n^i\bmod{2333}$。

看到这巨大的数据范围加上组合数，不难想到跟 Lucas 定理有关，因为 $2333$ 是素数，所以不需要用 exLucas 来做。

设题目要求的是 $F_n^k$，则有

$$
\displaystyle\begin{aligned}F_n^k&=\sum_{i=0}^kC_n^i\\&=\sum_{i=0}^kC_{n/p}^{i/p}\times C_{n\bmod p}^{i\bmod p}\end{aligned}
$$

看到这个 $n/p$ 和 $n\bmod p$，不难想这其实就是整除分块，我们将式子拆成 $k/p-1$ 个整块和剩下的一块，则式子

$$
\displaystyle\begin{aligned}
&=\sum_{i=0}^{k/p-1}(C_{n/p}^i\times\sum_{j=0}^{p-1}C_{n\bmod p}^j)+C_{n/p}^{k/p}\times \sum_{i=0}^{k\bmod p}C_{n\bmod p}^i
\\&=\sum_{i=0}^{k/p-1}C_{n/p}^i\times\sum_{i=0}^{p-1}C_{n\bmod p}^i+C_{n/p}^{k/p}\times \sum_{i=0}^{k\bmod p}C_{n\bmod p}^i
\\&=F_{n/p}^{k/p-1}\times F_{n\bmod p}^{p-1}+C^{k/p}_{n/p}\times F^{k\bmod p}_{n\bmod p}
\end{aligned}
$$

于是我们就可以递归的解决这个问题，当 $n,k$ 都小于 $p$ 时，因为 $p$ 只有 $2333$ 所以直接预处理组合数与前缀和即可。

```cpp
#include<cstdio>
#define int long long
const int p=2333;
int t,n,k,c[p+1][p+1],sum[p+1][p+1];
int lucas(int n,int m)
{
	return !m||n==m?1:lucas(n/p,m/p)*c[n%p+1][m%p+1]%p;
}
int F(int n,int k)
{
	return n<p?sum[n+1][k+1]:(F(n/p,k/p-1)*F(n%p,p-1)%p+lucas(n/p,k/p)*sum[n%p+1][k%p+1]%p)%p;
}
signed main()
{
	scanf("%lld",&t);
	++t;
	c[1][1]=1;
	for(int i=2;i<=p;++i)for(int j=1;j<=i;++j)c[i][j]=(c[i-1][j]+c[i-1][j-1])%p;
	for(int i=1;i<=p;++i)for(int j=1;j<=p;++j)sum[i][j]=(c[i][j]+sum[i][j-1])%p;
	while(--t)
	{
		scanf("%lld%lld",&n,&k);
		printf("%lld\n",F(n,k));
	}
	return 0;
}
```

---

## 作者：_IceCream_ (赞：0)

# Content

$t$ 次询问，每次给出两个整数 $n, k$，求 $\sum _ {i = 0} ^ k \binom {n}{i} \bmod p$。

$p = 2333, t = 10^5, n,k \le 10^{18}$。

# Solution

令答案 $f (n, k) = \sum _ {i = 0} ^ k \binom {n}{i} \bmod p$。

用 Lucas 定理推一下式子。

$$\sum _ {i = 0} ^ k \binom {n}{i} \bmod p \\ = \sum _ {i = 0} ^ k\binom{\lfloor \frac{n}{p} \rfloor}{\lfloor \frac{i}{p} \rfloor}\cdot\binom{n\bmod p}{i\bmod p}\bmod p \\$$

因为 $p = 2333$，取余一下最多只有 $2332$ 个，所以改成枚举 $i \bmod p$。

$$= \sum _ {i = 0} ^ {p - 1} \binom {n \bmod p}{i} \sum _ {j = 0} ^ k \binom{\lfloor \frac{n}{p} \rfloor}{\lfloor \frac{j}{p} \rfloor} \\ = \sum _ {i = 0} ^ {p - 1} \binom {n \bmod p}{i} \sum _ {j = 0} ^ {\lfloor\frac{k}{p} \rfloor} \binom{\lfloor \frac{n}{p} \rfloor}{j}$$

我们将它按照整块散块拆开。

$$ = \sum _ {i = 0} ^ {p - 1} \binom {n \bmod p}{i} \sum _ {j = 0} ^ {\lfloor\frac{k}{p} \rfloor - 1} \binom{\lfloor \frac{n}{p} \rfloor}{j} + \binom {\lfloor \frac{n}{p} \rfloor}{\lfloor\frac{k}{p} \rfloor} \sum _ {j = 0} ^ {k \bmod p} \binom{n \bmod p}{j} \\ = f(n \bmod p, p - 1) f ({\lfloor \frac{n}{p} \rfloor}, {\lfloor\frac{k}{p} \rfloor - 1}) + \binom {\lfloor \frac{n}{p} \rfloor}{\lfloor\frac{k}{p} \rfloor}f(n \bmod p, k \bmod p)$$

中间那个组合数再用 Lucas 跑一次，剩下 $f (n \bmod p, p - 1)$ 和 $f (n \bmod p, k \bmod p)$ 用 $O(p ^ 2)$ 预处理即可。剩下一个 $f ({\lfloor \frac{n}{p} \rfloor}, {\lfloor\frac{k}{p} \rfloor - 1})$ 递归即可。

$\dfrac{10^{18}}{{2333}^5} \le 2333$，也就是递归最多跑 $5$ 遍，除了栈空间外基本可以当常数看。

那么总时间复杂度 $O(p ^ 2 + \log n)$，瓶颈在预处理。

如果你是 $O(\log n)$ 求组合数，那么复杂度是 $O(p ^ 2 + \log ^ 2 n)$。

# Code
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const ll mod = 2333, N = 2333 + 5;

ll fst (ll x, ll y) {
	ll base = x, ans = 1;
	while (y) {
		if (y & 1) ans = ans * base % mod;
		base = base * base % mod;
		y >>= 1;
	}
	return ans;
}

ll fac[N];
ll f[N][N];
ll C (ll n, ll m) {
	if (n < m) return 0;
	if (n == m) return 1;
	return fac[n] * fst (fac[m], mod - 2) % mod * fst (fac[n - m], mod - 2) % mod; 
}

void init (ll x) {
	fac[0] = 1;
	for (ll i = 1; i <= x; ++i) fac[i] = fac[i - 1] * i % mod;
	
	f[0][0] = 1LL;
	for (ll i = 1; i <= x; ++i) f[i][0] = 1LL;
	for (ll i = 0; i <= x; ++i)
		for (ll j = 1; j <= x; ++j) 
			f[i][j] = (C (i, j) + f[i][j - 1]) % mod; // 直接加前缀和 
}

ll lucas (ll n, ll m) {
	if (m == 0) return 1;
	return lucas (n / mod, m / mod) * C (n % mod, m % mod) % mod;
}

ll F (ll n, ll k) {
	if (k < 0) return 0;
	if (n == 0 || k == 0) return 1;
	if (n < mod && k < mod) return f[n][k];
	return (F (n / mod, k / mod - 1) * f[n % mod][mod - 1] % mod + lucas (n / mod, k / mod) * f[n % mod][k % mod] % mod) % mod; // 套公式 
}

int t;
ll n, k;

int main () {
	
	init (mod);
	scanf ("%d", &t);
	while (t--) {
		scanf ("%lld%lld", &n, &k);
		printf ("%lld\n", F (n, k));
	}
	
	return 0;
}
```

---

## 作者：Helloworldwuyuze (赞：0)

# P4345 [SHOI2015] 超能粒子炮·改

## Des

求：
$$
\sum_{i=0}^k \binom{n}{i} \pmod p
$$
其中 $n,k\le 10^{18}$，$p = 2333$，多组询问。

## Sol

显然，$p$ 很小的情况下是可以使用 $\text{Lucas}$ 定理的。也就是说，我们现在要求：
$$
\sum_{i=0}^k\binom{\left\lfloor\frac{n}{p}\right\rfloor}{\left\lfloor \frac{i}{p} \right\rfloor}\binom{n\mod p}{i\mod p}
$$
注意到前面的 $\left\lfloor\frac{i}{p}\right\rfloor$ 是每 $p$ 个数会修改一次，而后面 $i\mod p$ 每 $p$ 个数一周期。于是枚举 $\left\lfloor \frac{i}{p} \right\rfloor$ 可以得到下式：
$$
\sum_{i=0}^{\left\lfloor\frac{k}{p}\right\rfloor-1} \binom{\left\lfloor \frac{n}{p}\right\rfloor}{i}\sum_{i=0}^{p-1}\binom{n\mod p}{i}
$$
需要注意的是，后面 $\mod p$ 可能会剩下一些凑不齐一个周期的项，因此整个式子还需要加上：
$$
\binom{\left\lfloor\frac{n}{p}\right\rfloor}{\left\lfloor\frac{k}{p}\right\rfloor}\sum_{i = 0}^{k\mod p} \binom{n\mod p}{i}
$$
因此我们记 $g_{i,j} = \sum\limits_{k=0}^j\binom{i}{k}$，于是式子就可以变成：
$$
g_{n\mod p,p-1}\sum_{i=0}^{\left\lfloor\frac{k}{p}\right\rfloor-1} \binom{\left\lfloor\frac{n}{p}\right\rfloor}{i}+\binom{\left\lfloor\frac{n}{p}\right\rfloor}{\left\lfloor \frac{k}{p} \right\rfloor}g_{n\mod p,k\mod p}
$$
其中，$\displaystyle \sum_{i=0}^{\left\lfloor\frac{k}{p}\right\rfloor-1} \binom{\left\lfloor\frac{n}{p}\right\rfloor}{i}$ 可以递归处理，$\displaystyle\binom{\left\lfloor\frac{n}{p}\right\rfloor}{\left\lfloor\frac{k}{p}\right\rfloor}$ 可以使用 $\text{Lucas}$ 定理在 $O(\log)$ 的时间内完成。于是，我们先预处理一个 $p\times p$ 的 $g$ 数组，就可以做到单次询问 $O(\log^2)$ 完成了。

```cpp
using namespace std;
#define int long long
const int INF = 0x3f3f3f3f;
typedef pair<int,int> PII;
typedef pair<int,PII> PIII;
typedef pair<int,bool*> PIB;
const int N = 3e3 + 10;
const int M = 1e5 + 10;
const int p = 2333;
inline int max(int x,int y){ return x<y ? y : x; }
inline int min(int x,int y){ return x<y ? x : y; }

int fact[N], infact[N], g[N][N];
int ksm(int x,int m){
	int ans = 1;
	for(; m; m>>=1, x=x*x%p)	if(m&1)	ans = ans*x%p;
	return ans;
}
int C(int n, int m, int p){
	if(n < m)	return 0;
	return fact[n] * infact[m] % p * infact[n-m] % p;
}
int Lucas(int n, int m, int p){
	if(m == 0)	return 1;
	else	return Lucas(n/p, m/p, p) * C(n%p, m%p, p) %p;
}
void init(int n = p-1){
	fact[0] = 1;
	for(int i=1;i<=n;++i)	fact[i] = fact[i-1] * i % p;
	infact[n] = ksm(fact[n], p-2);
	for(int i=n-1;~i;--i)	infact[i] = infact[i+1] * (i+1) % p;
	for(int i=0;i<=n;++i){
		g[i][0] = 1;
		for(int j=1;j<=n;++j)
			g[i][j] = (g[i][j-1] + C(i, j, p)) % p;
	}
}

int f(int n,int m,int p){
	if(n < p && m < p)	return g[n][m];
	else if(m < p)	return g[n%p][m];
	int res = f(n/p, m/p-1, p), en = Lucas(n/p, m/p, p);
	return (res * g[n%p][p-1] % p + en * g[n%p][m%p] % p) % p;
}

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0); init();
	int T; cin>>T;
	while(T--){
		int n, m; cin>>n>>m;
		cout<<f(n, m, p)<<endl;
	}
	return 0;
}
```

---


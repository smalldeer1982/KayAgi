# 【模板】自适应辛普森法 2

## 题目描述

试计算积分

$\displaystyle{\int_0^\infty x^{\frac{a}{x}-x}\mathrm{d}x}$

保留至小数点后$5$位。若积分发散，请输出$\text{orz}$。

## 说明/提示

$|a|\le50$。

请注意时空限制。

## 样例 #1

### 输入

```
2.33```

### 输出

```
1.51068```

# 题解

## 作者：xcxcli (赞：57)

Upd:修正计算错误和错别字

[【模板】自适应辛普森法2](https://www.luogu.com.cn/problem/P4526)
### 反驳 
反对楼上的答案，反常积分的收敛性不是这么判断的！

**反驳1**

当 $x\to a$ 时 $f(x)\to\infty$ ， $\int_a^bf(x)\operatorname{d}\!x$ 不一定发散。例：

$\lim\limits_{x\to0^+}\ln x=-\infty$

$\int_0^1\ln x\operatorname{d}\!x=\lim\limits_{x\to1^-}(x\ln x-x)-\lim\limits_{x\to0^+}(x\ln x-x)=-1-\lim\limits_{x\to0^+}x\ln x$

应用洛必达法则， $\lim\limits_{x\to0^+}x\ln x=\lim\limits_{x\to0^+}\frac{\ln x}{\frac1x}=\lim\limits_{x\to0^+}\frac{\frac1x}{-\frac1{x^2}}=\lim\limits_{x\to0^+}-x=0$

所以 $\int_0^1\ln x\operatorname{d}\!x$ 收敛且等于 $-1$ 。

**反驳2**

当 $x\to+\infty$ 时 $f(x)\to0$ ，$\int_a^{+\infty}f(x)\operatorname{d}\!x$ 不一定收敛。例：

$\lim\limits_{x\to+\infty}\frac1x=0$

$\int_1^{+\infty}\frac1x\operatorname{d}\!x=\lim\limits_{x\to+\infty}\ln x-\lim\limits_{x\to1^+}\ln x=+\infty-1=+\infty$

所以 $\int_1^{+\infty}\frac1x\operatorname{d}\!x$ 发散。

---
### 无穷界积分的审敛法
下面我们都讨论在定义域内连续的函数。

**定理：**

设 $f(x)$ 在 $[a,+\infty)$ 上有 $f(x)\ge0$ 。

如果存在常数 $p>1$ 使得 $\lim\limits_{x\to+\infty}x^pf(x)=c<+\infty$ ，那么 $\int_a^{+\infty}f(x)\operatorname{d}\!x$ 收敛。

如果 $\lim\limits_{x\to+\infty}xf(x)=d>0$ ，那么 $\int_a^{+\infty}f(x)\operatorname{d}\!x$ 发散。

将区间换为 $(-\infty,a]$ 时定理仍成立。

想要证明？在[这里](https://book.douban.com/subject/26311133/)

**应用**

因为 $\lim\limits_{x\to+\infty}x^2·\frac1{x\sqrt{x^2+1}}=1<+\infty$ ，所以 $\int_1^{+\infty}\frac1{x\sqrt{x^2+1}}\operatorname{d}\!x$ 收敛。

因为 $\lim\limits_{x\to+\infty}x·\frac1{\sqrt{x^2-1}}=1>0$ ，所以 $\int_2^{+\infty}\frac1{\sqrt{x^2-1}}\operatorname{d}\!x$ 发散。

### 无穷间断点的审敛法

**定理：** 

设 $a$ 是 $f(x)$ 的无穷间断点， $f(x)$ 在 $(a,b]$ 上有 $f(x)\ge0$ 。

如果存在常数 $0<p<1$ 使得 $\lim\limits_{x\to a^+}(x-a)^pf(x)=c<+\infty$ ，那么 $\int_a^bf(x)\operatorname{d}\!x$ 收敛。

如果 $\lim\limits_{x\to a^+}(x-a)f(x)=d>0$ ，那么 $\int_a^bf(x)\operatorname{d}\!x$ 发散。

---

设 $b$ 是 $f(x)$ 的无穷间断点， $f(x)$ 在 $[a,b)$ 上有 $f(x)\ge0$ 。

如果存在常数 $0<p<1$ 使得 $\lim\limits_{x\to b^-}(b-x)^pf(x)=c<+\infty$ ，那么 $\int_a^bf(x)\operatorname{d}\!x$ 发散。

如果 $\lim\limits_{x\to b^-}(b-x)f(x)=d>0$ ，那么 $\int_a^bf(x)\operatorname{d}\!x$ 发散。

证明同样在上面。

**应用：** 

因为 $\lim\limits_{x\to1^-}(1-x)^{\frac12}·\frac1{\sqrt{1-x^2}}=\lim\limits_{x\to1^-}\frac1{\sqrt{1+x}}=\frac{\sqrt{2}}2<+\infty$ ，所以 $\int_0^1\frac1{\sqrt{1-x^2}}\operatorname{d}\!x$ 收敛。

因为 $\lim\limits_{x\to1^-}(x-1)·\frac1{\ln x}=\lim\limits_{x\to1^-}\frac1{\frac1x}=1>0$ ，所以 $\int_1^3\frac{\operatorname{d}\!x}{\ln x}$ 发散。

---
### 本题

本题中，$x\in[0,+\infty),f(x)=x^{\frac ax-x}=x^{\frac{a-x^2}x}\ge0$ 。

**$a<0$ 时发散的证明**

$\lim\limits_{x\to0^+}x^{\frac{a-x^2}x}=e^{\lim\limits_{x\to0^+}\frac{a-x^2}x\ln x}=\begin{cases}e^{+\infty}=+\infty&a<0\\e^0=1&a=0\\e^{-\infty}=0&a>0\end{cases}$

所以只有 $a<0$ 时 $\int_0^{+\infty}f(x)\operatorname{d}\!x$ 可能在 $x=0$ 处发散。

当 $a<0$ 时，$\lim\limits_{x\to0^+}x·x^{\frac{a-x^2}x}=e^{\lim\limits_{x\to0^+}\frac{a-x^2+x}x\ln x}=e^{+\infty}=+\infty$ ，所以 $\int_0^{+\infty}f(x)\operatorname{d}\!x$ 在 $0$ 处发散。

**$+\infty$ 处收敛的证明**

$\lim\limits_{x\to+\infty}x^2·x^{\frac{a-x^2}x}=e^{\lim\limits_{x\to+\infty}\frac{a-x^2+2x}x\ln x}$

由洛必达法则， $\lim\limits_{x\to+\infty}\frac{(a-x^2+2x)\ln x}x=\lim\limits_{x\to+\infty}(-2x+2)\ln x+\frac{a-x^2+2x}x=-\infty$ 。

所以 $\lim\limits_{x\to+\infty}x^2·x^{\frac{a-x^2}x}=e^{-\infty}=0<+\infty$ 。

所以 $\int_0^{+\infty}f(x)\operatorname{d}\!x$ 在正无穷大处收敛。

综上所述， $\int_0^{+\infty}f(x)\operatorname{d}\!x$ 在 $a<0$ 时发散，在 $a\ge0$ 时收敛。


---

## 作者：CreeperK (赞：25)

我并不打算讲太多的实现上的问题。。。各位dalao的题解都已经说得很清楚了（而且不会自适应辛普森法来做这道题干嘛！）

我主要是讲讲，这个看似“显而易见”的“$a<0$时原积分发散”是如何得来的。因为在我做这道题时，本蒟蒻也因为题解里的“画图可得”而一脸蒙圈，后来自己好好借用desmos画了个图，研究了一番才弄懂。

如果是比赛场上，像这样的函数图象根本没办法画得好啊！

## 一、$a<0$时原积分发散。

这点倒是还比较好证。注意看这个函数的指数：

$\dfrac{a}{x}-x$

可以转化为

$\dfrac{a-x^2}{x}$

于是函数可以变成这样：

$x^{\tfrac{a-x^2}{x}}$

因为原积分的积分下界为0，而$x=0$时被积函数无意义，所以可以忽略0，改定义域为$(0,+\infty)$。

此时：

$\because$ $a<0,x^2>0,-x^2<0$

$\therefore$ $a-x^2<0$

$\therefore$ 原函数可化为$\dfrac{1}{x^{\tfrac{x^2-a}{x}}}$

$\because$ $x$趋近于$0$时，$x^2$趋近于$0$，$\dfrac{1}{x}$趋近于正无穷。

$\therefore$ $x^2-a$趋近于$-a$，$-\dfrac{a}{x}$趋近于正无穷。

$\because$ 当$0<x<1$时，$x^m$在$m$趋近于正无穷时趋近于0。

且$x$趋近于$0$时，$\dfrac{1}{x}$趋近于正无穷。

$\therefore$ 原函数在$x$趋近于$0$时趋近于正无穷。

$\therefore$ 原函数在定义域上发散。

（如果因为过多的趋近于而感到难受，我深表歉意。）

_____

这还算容易，现在我们要证明第二件事：原积分在$a>0$时收敛。

## 二、$a>0$时原积分收敛。

### 对于任意实数$a$：

$x$趋近于正无穷时，$\dfrac{x^2-a}{x}$趋近于正无穷，${x^{\tfrac{x^2-a}{x}}}$趋近于正无穷。

$\because$ $m$趋近于正无穷时，$\dfrac{1}{m}$趋近于$0$。

$\therefore$ $x$趋近于正无穷时，$\dfrac{1}{x^{\tfrac{x^2-a}{x}}}$趋近于$0$。

$\therefore$ 原函数在$x$趋近于正无穷时收敛。

### 对于$a>0$：

可以取$x<min(\sqrt a,1)$，此时$\dfrac{a-x^2}{x}$大于$0$，所以$x^\tfrac{a-x^2}{x}$小于$1$。

而在$[1,+\infty)$上，答案必有限。

所以原积分收敛。

## 那么什么时候会收敛呢？

我们设$\epsilon_1$为精度下限，即收敛的$f(x)$的界。

本人写了这么一个程序：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
typedef double ld;
const ld eps=1e-8;
const ld eps2=1e-6;
ld l,r,mid;
ld a;

int main(){
	scanf("%lf",&a);
	l=2.000; r=200.0000;
	while(l+eps<r){
		mid=l+(r-l)/2;
		printf("%lf %lf\n",mid,pow(mid,(a/mid)-mid));
		if(pow(mid,(a/mid)-mid)<=eps2)r=mid;
		else l=mid;
	}
	printf("%lf",l);
} 
```

定$\epsilon_1=1e^{-6}$，可以发现，在$a=50$，$x\ge 10.581484$时$f(x)>\epsilon_1$。

为了精确，定$\epsilon_1=1e^{-10}$，在$a=50$，$x\ge 12.884417$时$f(x)>\epsilon_1$。

这也是如何把原积分转化为定积分的方法：把$[0,+\infty)$转化为$[0,15)$。

最后还是放个本人的代码吧。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
const double Eps=1e-10;
double a,l,r;

inline double F(double x){
    return pow(x,(a/x)-x);
}//函数

inline double Simpson(double p,double q){
    double k=p+(q-p)/2;
    return (F(p)+4*F(k)+F(q))*(q-p)/6.0;
}//三点辛普森法

double Adaptive(double p,double q,double S){
    double k=p+(q-p)/2;
    double l1=Simpson(p,k),l2=Simpson(k,q);
    if(fabs(l1+l2-S)<=15*Eps)return l1+l2;
    else return Adaptive(p,k,l1)+Adaptive(k,q,l2);
}//自适应辛普森法

int main(){
    scanf("%lf",&a);
    if(a<0){
        printf("orz");
        return 0;
    }//判断收敛/发散
    printf("%.5lf",Adaptive(Eps,15,Simpson(l,r)));
}
```

完结撒花！希望能帮到大家~

---

## 作者：皎月半洒花 (赞：7)

关于正解，比较详细的整理在这儿[$\color{red}{Link}$](https://www.cnblogs.com/pks-t/p/10277958.html)

此处主要说一种能够水过去的方法。我们发现$eps$是$1e-5$的，在朴素的$Adaptive-Simpson$中，我们要不断取$half$——但由于本题精度要求不高，所以直接取一个比较小的精度，比如$5e-8$。然后我们不断运用$Simpson$公式来取舍区间，即，我们用一种“高仿”的方式来进行$Adaptive-Simpson:$

```cpp

inline double do_divide(double l, double r, double Lans){
    double Lv, Rv, v, t ; Lv = Simp_calc(l, mid), Rv = Simp_calc(mid, r), v = Lans ;
    if (fabs(t = (Lv + Rv - v)) <= Eps) return Lv + Rv ; return do_divide(l, mid, Lv) + do_divide(mid, r, Rv) ;
}
```

它虽然既没有折半传递，又没有精度控制，但是

# 它能过

……真是无可辩驳啊233

```cpp
#define mid (l + r) / 2
using namespace std ;
const double Eps = 5e-8 ;
double Ans, A, B, C, D, L, R ;
inline double F(double x){
    return pow(x, A / x - x) ;
}
inline double Simp_calc(double l, double r){
    return (r - l) / 6 * (F(l) + F(r) + 4 * F(mid)) ;
}
inline double do_divide(double l, double r, double Lans){
    double Lv, Rv, v, t ; Lv = Simp_calc(l, mid), Rv = Simp_calc(mid, r), v = Lans ;
    if (fabs(t = (Lv + Rv - v)) <= Eps) return Lv + Rv ; return do_divide(l, mid, Lv) + do_divide(mid, r, Rv) ;
}

int main(){
    scanf("%lf", &A) ; L = Eps, R = 23.3 ;
    if (A < 0) { puts("orz"), cout << endl ; return 0 ;}
    Ans = do_divide(L, R, Simp_calc(L, R)) ; printf("%.5lf", Ans) ; return 0 ; 
}
```

不过还是建议改一改数据，稍微卡一卡精度…嗝…

---

## 作者：Great_Influence (赞：6)

简单积分。。。

不要被式子的无穷大吓到了。将函数图像画出来，可以轻易地发现，当大于一定值时，函数趋于0，对答案基本没有贡献。这个值随着$a$增大增大，然而当$a=50$时，这个值不超过8，为了求稳就可以从$eps$积分到$20$。为什么不从0开始?因为当$a=0$时，$f(0)=1$而不是$0$，所以计算会出现错误。避免特殊点对积分产生影响也是辛普森自适应积分的一个重点。记得$eps$开小一点，最好开小$4$个数量级。

什么时候无解?画一下图可以发现，当$a<0$时，$\lim\limits_{x\to 0} f(x)\to+\infty$，函数不收敛。直接判掉即可。

代码:

```cpp
#include<cstdio>
#include<cstdlib>
#include<iostream>
#include<algorithm>
#include<cstring>
#define For(i,a,b) for(i=(a),i##end=(b);i<=i##end;++i)
#define Forward(i,a,b) for(i=(a),i##end=(b);i>=i##end;--i)
#define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
#define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
#define Chkmax(a,b) a=a>b?a:b
#define Chkmin(a,b) a=a<b?a:b
using namespace std;
template<typename T>inline void read(T &x){
    T s=0,f=1;char k=getchar();
    while(!isdigit(k)&&k^'-')k=getchar();
    if(!isdigit(k)){f=-1;k=getchar();}
    while(isdigit(k)){s=s*10+(k^48);k=getchar();}
    x=s*f;
}
void file(void){
    #ifndef ONLINE_JUDGE
    freopen("water.in","r",stdin);
    freopen("water.out","w",stdout);
    #endif
}

static double a;

const double eps=1e-9;

inline double f(double x){return pow(x,a/x-x);}

inline double calc(double l,double r)
{return (r-l)*(f(l)+f(r)+4.0*f((l+r)/2.0))/6.0;}

inline double simpson(double L,double R,double ans)
{
	double mid=(L+R)/2.0,lans=calc(L,mid),rans=calc(mid,R);
	if(fabs(lans+rans-ans)<=eps)return ans;
	return simpson(L,mid,lans)+simpson(mid,R,rans);
}

int main(void){
    file();
	scanf("%lf",&a);
	if(a<0)return puts("orz"),0;
	printf("%.5lf\n",simpson(eps,20,calc(eps,20)));
	return 0;
}

```

---

## 作者：Lijunzhuo (赞：4)

这道题可以用两种方法解决，第一种是梯形法求积分，第二种是自适应辛普森法求积分，这里只讲“梯形法求积分”。  
我们先来判断什么时候这个积分不收敛，可以借助[函数图像](https://www.desmos.com/calculator/0epjvewuxp)，通过修改变量 $a$ 的值，我们发现：当 $a<0$ 时，积分不收敛；当 $a\geqslant0$ 时，积分可以收敛。判断代码如下：
```cpp
if(a<0) printf("orz\n");
```
现在我们已经可以判断这个积分是否收敛了，但是这个积分的值还是不容易求出来，因为它的右区间是 $\infty$，所以我们可以继续看函数图像，发现：当 $a$ 取这道题最大值 $50$ 时，$x^{\frac{a}{x}-x}$ 中 $x$ 为 $20$ 的时候这个式子的值就已经很小了，所以，我们可以把右区间缩小到 $20$。  
我们终于来到了最后——积分求值，我们可以用梯形法来解决。为了答案精准，我们可以考虑二分：想要求出 $\displaystyle{\int_l^{r} x^{\frac{a}{x}-x}\mathrm{d}x}$ 的值来，我们可以先分别求出 $\displaystyle{\int_l^{(l+r)\div{2}} x^{\frac{a}{x}-x}\mathrm{d}x}$ 的值和 $\displaystyle{\int_{(l+r)\div{2}}^r x^{\frac{a}{x}-x}\mathrm{d}x}$ 的值来，再相加求出$\displaystyle{\int_l^{r} x^{\frac{a}{x}-x}\mathrm{d}x}$ 的值。但是一直不能分下去，我们考虑：当 $r-l$ 小于 $10^{-4}$ 时求值，用梯形法就是这样求的：$\displaystyle{\int_l^{r} f(x)\mathrm{d}x}=\frac{(f(l)+f(r))(r-l)}{2}$（在这里， $f(x)=x^{\frac{a}{x}-x}$），所以我们就可以求出 $\displaystyle{\int_0^\infty x^{\frac{a}{x}-x}\mathrm{d}x}$ 的值来了。  
代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
double a;
double f(double x) //函数f(x)
{
	return pow(x,a/x-x);
}
double integral(double l,double r) //积分求值（二分）
{
	if(r-l<=0.0001) return (f(l)+f(r))*(r-l)/2.0;
	else return integral(l,(l+r)/2.0)+integral((l+r)/2.0,r);
}
int main()
{
	scanf("%lf",&a);
	if(a<0) printf("orz\n");
	else printf("%.5lf",integral(0.0000000000000000001,20)); //左区间直接写0的话不行。
	return 0;
}
```
[评测记录](https://www.luogu.com.cn/record/160338428)。

---

## 作者：__er (赞：4)

>   辛普森法（Simpson），是一种求数值积分的方法。

求积分的时候，可以将其分成无穷多个小区间或者用 牛顿-莱布尼茨公式。

如果不能用这两种方法，就有了 数值积分。

辛普森法的核心思想就是把函数 $f$ 近似地看成**二次函数**，于是给出辛普森公式的推导：

由于把 $f$ 近似地看成二次函数，所以，对于二次函数 $f(x)=ax^2+bx+c$，求积分可得：

$$\displaystyle F(x)=\int^x_0 f(x)\mathrm{d}x=\dfrac{a}{3}x^3+\dfrac{b}{2}x^2+cx+k$$

其中 $k$ 为一个常数，那么：

$$\begin{aligned}
\int_{l}^{r} f(x) \mathrm{d} x & =F(r)-F(l) \\
& =\frac{a}{3}\left(r^{3}-l^{3}\right)+\frac{b}{2}\left(r^{2}-l^{2}\right)+c(r-l) \\
& =(r-l)\left(\frac{a}{3}\left(l^{2}+r^{2}+l r\right)+\frac{b}{2}(l+r)+c\right) \\
& =\frac{r-l}{6}\left(2 a l^{2}+2 a r^{2}+2 a l r+3 b l+3 b r+6 c\right) \\
& =\frac{r-l}{6}\left(\left(a l^{2}+b l+c\right)+\left(a r^{2}+b r+c\right)+4\left(a\left(\frac{l+r}{2}\right)^{2}+b\left(\frac{l+r}{2}\right)+c\right)\right) \\
& =\frac{r-l}{6}\left(f(l)+f(r)+4 f\left(\frac{l+r}{2}\right)\right)
\end{aligned}$$

稍微改写下形式就得到了辛普森公式：

$$\int_{l}^{r} f(x) \mathrm{d} x=\dfrac{r-l\left(f(l)+f(r)+4 f\left(\frac{l+r}{2}\right)\right)}{6}$$

1.  辛普森法

有一自然数 $n$，将区间 $[l,r]$ 分成等长的 $2n$ 个区间，计算每个小区间的积分值，求和可得总积分。

对于 $[x_{2i},x_{2i-2}]$ 的一段区间，选定三个点 $\left( x_{2i-2},x_{2i-1},x_{2i} \right)$，构成抛物线，得到函数 $f^{'}(x)$，于是，原来计算么个小区间的积分值就可以转化为求二次函数 $f^{'}(x)$ 的值，而 $f^{'}(x)$ 可以用辛普森公式近似计算。

代码实现很简单，就不再赘述了。

2.  自适应辛普森法

从上文可知，结果的进度取决于 $n$ 的取值，所以，如果一段积分已经很接近二次函数了，误差值在接受范围内，就可以不用往下继续分段了。

可以对于一段积分先代入辛普森公式求值，然后再将这段积分平分成两段继续求积分，如果差值小于要求的精度 $eps$ 就直接返回。

# $\quad$

[[模板]自适应辛普森法 1](https://www.luogu.com.cn/problem/P4525)

标准模板，没什么好说的：

```cpp
#include <bits/stdc++.h>
using namespace std;
const double eps = 1e-6;
double a, b, c, d, l, r;
double f(double x) {
	return (c * x + d) / (a * x + b);
}
double simpson(double l, double r) {
	double mid = (l + r) / 2.0;
	return (f(l) + 4.0 * f(mid) + f(r)) * (r - l) / 6.0;
}
double asr(double l, double r, double eps, double ans) {
	double mid = (l + r) / 2.0, l_ = simpson(l, mid), r_ = simpson(mid, r);
	if (fabs(l_ + r_ - ans) <= 15.0 * eps) return l_ + r_ + (l_ + r_ - ans) / 15.0;
	return asr(l, mid, eps / 2.0, l_) + asr(mid, r, eps / 2.0, r_);
}
int main() {
	ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
	cin >> a >> b >> c >> d >> l >> r;
	cout << fixed << setprecision(6) << asr(l, r, eps, simpson(l, r));
	return 0;
}
```

[[模板]自适应辛普森法 2](https://www.luogu.com.cn/problem/P4526)

一看，$\int^\infty_0$，可辛普森法只能求定值积分，所以别急，画了图像就能知道，当 $a<0$ 时，积分发散，就不用求了，剩下的套模板 1 即可。

精度多取两位保险。

```cpp
#include <bits/stdc++.h>
using namespace std;
const double eps = 1e-8;
double a, b, c, d, l, r;
double f(double x) {
	return pow(x, (a / x) - x);
}
double simpson(double l, double r) {
	double mid = (l + r) / 2.0;
	return (f(l) + 4.0 * f(mid) + f(r)) * (r - l) / 6.0;
}
double asr(double l, double r, double eps, double ans) {
	double mid = (l + r) / 2.0, l_ = simpson(l, mid), r_ = simpson(mid, r);
	if (fabs(l_ + r_ - ans) <= 15.0 * eps) return l_ + r_ + (l_ + r_ - ans) / 15.0;
	return asr(l, mid, eps / 2.0, l_) + asr(mid, r, eps / 2.0, r_);
}
int main() {
	ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
	cin >> a;
	if (a < 0) return cout << "orz", 0;
	cout << fixed << setprecision(5) << asr(eps, 15.0, eps, simpson(l, r));
	return 0;
}
```



---

## 作者：Galois_Field_1048576 (赞：3)

首先看一下收敛情况。我们考虑运用 Cauchy 判别法。因为在 $x=0$ 处有一个奇点，这样，我们考虑
$$
\begin{aligned}
\int_0^{+\infty} f(x) \mathrm dx &= \int_0^{+\infty} f\Big(\dfrac 1x\Big) \mathrm d\Big(\dfrac 1x\Big) \\
&= \int_0^{+\infty} {\color{red}{-f\Big(\dfrac 1x\Big) \times \dfrac 1{x^2}}} \mathrm dx.
\end{aligned}
$$
设红色部分为 $g(x)$，即可用 Cauchy 判别法来判断这个反常积分的敛散性。具体地，我们需要找到 $g(x) \sim Cx^p (x \to +\infty)$。考虑设两个充分大的数 $\alpha,\beta$。则
$$
\dfrac{g(\alpha)}{g(\beta)} \approx \dfrac{C\alpha^p}{C\beta^p} = \Big(\dfrac{\alpha}{\beta}\Big)^p \implies p = \log_{\alpha/\beta} \dfrac{g(\alpha)}{g(\beta)}.
$$
判断是否 $p \ge 1$ 即可。

然后进入数值积分部分。我选取的积分公式是复化 Cotes 公式。其原理为，设 $x_0, \dots, x_4 \in [a,b]$ 任意选取（实际上，经常是等距选取）。做插值多项式 $p(x_i) = f(x_i)$。然后考虑 $p$ 的积分。下面以等距选取，考虑公式的计算：
$$
\begin{aligned}
f(x) &\approx p(x) \\
&= \sum_{i = 0}^4 f(x_i) \prod_{j \ne i} \dfrac{x-x_j}{x_i-x_j} \\
&= \sum_{i = 0}^4 f(x_i) \prod_{j \ne i} \Big(\dfrac 4{b-a} \cdot \dfrac{x-x_j}{i-j}\Big) \\
&= \dfrac{256}{(b-a)^4} \sum_{i = 0}^4 f(x_i) \prod_{j \ne i} \Big(\dfrac{x-x_j}{i-j}\Big) \\
&= \dfrac{256}{(b-a)^4} \sum_{i = 0}^4 (-1)^{\sum\limits_{j \ne i} j}\dfrac{f(x_i)} {i!(4-i)!} \prod_{j \ne i} (x-x_j) \\
&= \dfrac{256}{(b-a)^4} \sum_{i = 0}^4 (-1)^{i}\dfrac{f(x_i)} {i!(4-i)!} \prod_{j \ne i} (x-x_j) \\
\end{aligned}
$$
两边同时积分，得
$$
\begin{aligned}
\int_b^a f(x) \mathrm dx &\approx \dfrac{256}{(b-a)^4} \sum_{i = 0}^4 \dfrac{(-1)^i f(x_i)} {i!(4-i)!}  \int_a^b \prod_{j \ne i} (x-x_j) \mathrm dx
\end{aligned}
$$
如果我们设“实数号节点”$x = \alpha \dfrac{b-a}{4}+a \implies \alpha = \dfrac{4(x-a)}{(b-a)}$，则
$$
\begin{aligned}
\int_b^a f(x) &\approx \dfrac{256}{(b-a)^4} \sum_{i = 0}^4 \dfrac{(-1)^i f(x_i)} {i!(4-i)!}  \int_a^b \prod_{j \ne i} (x-x_j) \mathrm dx \\
&\xlongequal{\text{换元积分}} \dfrac{256}{(b-a)^4} \sum_{i = 0}^4 \dfrac{(-1)^i f(x_i)} {i!(4-i)!}  \int_0^4 \dfrac{4(x-a)}{(b-a)} \prod_{j \ne i}  \dfrac{a-b}{4} (\alpha-j) \mathrm d\alpha \\
&= \sum_{i = 0}^4 \dfrac{(-1)^i f(x_i)} {i!(4-i)!}  \int_0^4 \dfrac{4(x-a)}{(b-a)} \prod_{j \ne i} (\alpha-j) \mathrm d\alpha
\end{aligned}
$$
下面是一个枯燥的计算，得
$$
\int_a^b f(x) \mathrm dx \approx \dfrac{b-a}{90} \sum_{i=1}^4 \lambda_i f\Big(\dfrac{(4-i)a+ib}{4}\Big).
$$
其中，$\lambda_0 = 7,\lambda_1 = 32,\lambda_2 = 12,\lambda_3 = 32,\lambda_4 = 7$。

可这样的精度还是不够，我们考虑：
$$
\int_{a_0}^{a_N} f(x) \mathrm dx = \sum_{i=0}^{N-1} \int_{a_i}^{a_{i+1}} f(x) \mathrm dx.
$$
我们设 $a_i$ 等距分布。即得到复化 Cotes 公式。

最后，我们发现
$$
\int_{15}^{+\infty} x^{a/x-x} \mathrm dx \le 15^{a/15} \int_{15}^{+\infty} x^{-x} \mathrm dx \approx 15^{a/15} \times 6.1297 \times 10^{-17}.
$$
所以我们可以把积分上限视作 $15$（当然上述讨论是在 $a > 0$ 下才有意义）。

```cpp
#include <bits/stdc++.h>
using namespace std;
long double a;
long double f(long double x) { return pow(x, a / x - x); }
long double g(long double x) { return -1 / x / x * f(1 / x); }
long double cotes(long double l, long double r) {
    long double x[5] = {};
    for (int i = 0; i <= 4; ++i) {
        x[i] = ((4 - i) * l + i * r) / 4.0;
    }
    return ((r - l) / 90) *
           (7 * (f(x[0]) + f(x[4])) + 32 * (f(x[1]) + f(x[3])) + 12 * f(x[2]));
}

int main() {
    cin >> a;
    double l = 50, r = 100;
    long double p = log(g(r) / g(l)) / log(2);
    if (p >= -1) {
        puts("orz");
        return 0;
    }
    long double ans = 0;
    for (long double i = 0.0000001; i < 15; i += 0.0001)
        ans += cotes(i, i + 0.0001);
    cout << fixed << setprecision(5) << ans << endl;
}
```


## 避坑
* 忘开 `long double` 见祖宗。
* 算错，以为是无穷远间断点见祖宗。
* 忘了 $0^0$ 未定义见祖宗。

---

## 作者：C20192413 (赞：3)

发现递归层数太多就直接返回就过了
```cpp
#include<set>
#include<map>
#include<stack>
#include<queue>
#include<deque>
#include<cmath>
#include<ctime>
#include<cstdio>
#include<vector>
#include<climits>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
#define LL long long

double read(){
	double x;
	scanf("%lf",&x);
	return x;
}

#define eps (1e-8)
const int MAXN=100000;
const int INF=0x3f3f3f3f;
const double PI=acos(-1.0);

int dcmp(double x){
	if(fabs(x)<eps) return 0;
	return x>0?1:-1;
}

double a,b,c,d;
int dep,Max;
double f(double x){return pow(x,a/x-x);}
double Simpson(double L,double R){return (R-L)/6*(f(L)+f(R)+4*f((L+R)/2));}
double Integration(double L,double R){
	dep++;
	if(dep>10000){
		puts("orz");
		exit(0);
	}
	double Mid=(L+R)*0.5,s1=Simpson(L,Mid),s2=Simpson(Mid,R),s0=Simpson(L,R); 
	if(dcmp(s1+s2-s0)==0){
		dep--;
		return s0;
	}
	return Integration(L,Mid)+Integration(Mid,R);
}
int main(){
	a=read();
	printf("%.5f\n",Integration(eps,20));
    return 0;
}


```

---

## 作者：Ebola (赞：3)

广告：[我的博客](http://ebola.blogwo.com/2018/06/20/%E3%80%90luogup4526%E3%80%91%E8%87%AA%E9%80%82%E5%BA%94%E8%BE%9B%E6%99%AE%E6%A3%AE%E6%B3%952-%E9%A2%98%E8%A7%A3/)

正无穷？！惊了！我们的辛普森积分只能做定积分啊……

没有思路，在几何画板上随便画几个图像看看这是什么鬼函数

![](http://wx3.sinaimg.cn/mw690/0060lm7Tly1fshq7jlyr1j30we0guglx.jpg)

好像发现了什么大新闻！！！

当a>0时，函数曲线在x>10的时候就近乎与x轴重合了，也就是说后面的我们都可以不用去管它。于是我们定积分，在正半轴积到10就可以了！但由于本题精度要求非常高，为了进一步减小误差，我们积到20（实测积到10只能拿90分，积到20可以AC）。注意绝对不能从0开始积，而应该从一个极小量开始，因为x在幂中做了分母，积0就呵呵了。

当a<0时，发现它不是收敛的，它在靠近y轴时趋于无穷大（图中黄线）。于是我们在a<0时输出orz即可

```cpp
#include<bits/stdc++.h>
using namespace std;

const double eps=1e-12;
double a;

double F(double x){return pow(x,a/x-x);}
double simpson(double a,double b)
{
	double mid=(a+b)/2;
	return (F(a)+4*F(mid)+F(b))*(b-a)/6;
}
double asr(double a,double b,double A)
{
	double mid=(a+b)/2;
	double L=simpson(a,mid),R=simpson(mid,b);
	if(fabs(L+R-A)<=15*eps) return L+R+(L+R-A)/15.0;
	return asr(a,mid,L)+asr(mid,b,R);
}
double asr(double a,double b){return asr(a,b,simpson(a,b));}

int main()
{
	cin>>a;
	if(a<0) puts("orz");
	else printf("%.5lf\n",asr(eps,20.0));
	return 0;
}

```

---

## 作者：Tracy_Loght (赞：2)

# P4526 【模板】自适应辛普森法 2


### 前置知识（自适应辛普森法）：

- 自适应辛普森法是每次将区间对折为两个，若将整个区间当做抛物线求得的定积分与左右区间分别当做抛物线求得的定积分之和误差不超过最小精度，则返回，否则递归下去

- **换元积分**、**级数展开**和**特殊函数**的性质等。

### ~~简单~~化简：

**让我们来讨论一下这个积分的一些数学推论吧！**

------------

首先，让我们观察被积函数 $f(x) = x^{\frac{a}{x}-1}$ 的形式。当 $x$ 趋于无穷大时，分式 $\frac{a}{x}$ 的值趋近于零。因此，函数 $f(x)$ 的形式可以近似为：

$$f(x) \approx x^{-1}$$

因此，我们可以将原积分表示为：

$$\int_0^\infty x^{\frac{a}{x}-1} \mathrm{d}x = \int_0^\infty x^{-1} g(x)\mathrm{d}x$$

其中，$g(x) = x^{\frac{a}{x}}$。现在，让我们对 $g(x)$ 进行一些初步的探究。

------------

首先，注意到 $g(x)$ 的值域为 $(0,+\infty)$，且 $g(x)$ 在 $x=e$ 处取得极大值，其中 $e$ 是自然对数的底数。这是因为，当 $x>0$ 时，有：

$$\ln g(x) = \frac{a}{x} \ln x = \frac{\ln x}{x^{-1}}$$

因此，当 $x=e$ 时，$\ln g(x)$ 取得最大值 $\ln a$，进而导致 $g(x)$ 在 $x=e$ 处取得极大值 $a^e$。

接下来，我们可以尝试计算 $g'(x)$：

$$g'(x) = x^{\frac{a}{x}}\left(\frac{a}{x^2}\ln x - \frac{a}{x^2}\right)=\frac{a}{x}g(x)\left(\frac{\ln x}{x}-1\right)$$

因此，$g'(x)>0$ 当且仅当 $\frac{\ln x}{x}>1$，即 $x<e$；$g'(x)<0$ 当且仅当 $\frac{\ln x}{x}<1$，即 $x>e$。因此，$g(x)$ 在 $x=e$ 处取得极大值。

接下来，我们使用 **Laplace** 方法求解积分。

**Laplace** 方法可以用于近似计算形如 $\int_0^\infty f(x)e^{-sx}\mathrm{d}x$ 的积分。根据 **Laplace** 方法，我们需要计算极限：

$$\lim_{s\rightarrow\infty}s\int_0^\infty f(x)e^{-sx}\mathrm{d}x$$

现在，我们考虑计算这个极限，其中 $f(x) = x^{-1}g(x)$：

$$\lim_{s\rightarrow\infty}s\int_0^\infty \frac{1}{x}x^{\frac{a}{x}}e^{-sx}\mathrm{d}x$$

------------

接下来，我们对 $x^{\frac{a}{x}}$ 取 $\ln$：

$$\ln x^{\frac{a}{x}} = \frac{a}{x}\ln x = \frac{\ln x}{x^{-1}}$$

因此：

$$\lim_{s\rightarrow\infty}s\int_0^\infty \frac{1}{x}e^{-(s-\frac{a}{x}\ln x)x}\mathrm{d}x$$

令 $t=(s-\frac{a}{x}\ln x)x$，则 $\mathrm{d}t = (s-\frac{a}{x}\ln x)\mathrm{d}x$。因此，上式可以变形为：

$$\lim_{s\rightarrow\infty}\int_0^\infty e^{-t}\frac{1}{s-\frac{a}{x}\ln x}\mathrm{d}t$$

接下来，我们使用 Laplace 变换计算这个积分：

$$\begin{aligned}\mathcal{L}\left[\frac{1}{s-\frac{a}{x}\ln x}\right] &=\int_0^\infty e^{-st}\frac{1}{s-\frac{a}{x}\ln x}\mathrm{d}t \\ & = \int_0^\infty e^{-st}\int_0^\infty e^{-u\left(s-\frac{a}{x}\ln x\right)}\mathrm{d}u\mathrm{d}t\\ & = \int_0^\infty \int_0^\infty e^{-st-u\left(s-\frac{a}{x}\ln x\right)}\mathrm{d}t\mathrm{d}u\\ & = \int_0^\infty \int_0^\infty e^{-st(1-u)}e^{-us\frac{a}{x}\ln x}\mathrm{d}t\mathrm{d}u\\ & = \int_0^\infty \int_0^\infty e^{-st(1-u)}e^{-us\ln g(x)}\mathrm{d}t\mathrm{d}u\\ & = \int_0^\infty \frac{1}{s(1-u)+u\ln g(x)}\mathrm{d}u \end{aligned}$$

------------

现在，让我们考虑 $g(x)$ 在 $x=e$ 处的情况。根据之前的推论，我们知道 $g(x)$ 在 $x=e$ 处取得最大值 $a^e$。因此，当 $x\rightarrow e$ 时，$\ln g(x) \rightarrow \ln a$。

接下来，我们通过留数法计算积分。假设 $\ln g(x) = \ln a + \epsilon(x)$，其中 $\epsilon(x)$ 是关于 $x-e$ 的小量。然后，我们将分母乘以 $\frac{s}{s}$，并将 $\mathrm{d}u$ 替换为 $\frac{\mathrm{d}u}{u}$：

$$\begin{aligned}\mathcal{L}\left[\frac{1}{s-\frac{a}{x}\ln x}\right] &= \int_0^\infty \frac{s}{s(1-u)+u\ln a+u\epsilon(x)}\frac{\mathrm{d}u}{u}\\ & = \int_0^\infty \frac{1}{1-\frac{u}{s}-\frac{u}{s}\epsilon(x)-\frac{u}{s}\frac{\ln a}{s}}\frac{\mathrm{d}u}{u}\\ & = \int_0^\infty \sum_{n=0}^\infty \left(\frac{u}{s}+\frac{u}{s}\epsilon(x)+\frac{u}{s}\frac{\ln a}{s}\right)^n\frac{\mathrm{d}u}{u}\\ & = \int_0^\infty \sum_{n=0}^\infty \frac{1}{n!}\left(u+s\epsilon(x)+\frac{\ln a}{s}\right)^n\frac{\mathrm{d}u}{u}\\ & = \int_0^\infty \sum_{n=0}^\infty \frac{1}{n!}\left(u^n+n u^{n-1}s\epsilon(x)+\binom{n}{2}u^{n-2}s^2\epsilon(x)^2+\cdots+\frac{(\ln a)^n}{s^n}\right)\frac{\mathrm{d}u}{u}\\ \end{aligned}$$

在计算上式时，我们使用了二项式定理展开分母中的项，并将 $u$ 的幂次提取出来。接下来，我们逐项计算积分：

$$\int_0^\infty \frac{1}{n!}u^n\frac{\mathrm{d}u}{u} = \int_0^\infty \frac{1}{n!}\mathrm{d}(\ln u) = \frac{1}{n!}\lim_{t\rightarrow\infty}\ln t = 0$$

$$\int_0^\infty \frac{1}{n!}nu^{n-1}s\epsilon(x)\frac{\mathrm{d}u}{u} = \frac{s\epsilon(x)}{(n-1)!}$$

$$\int_0^\infty \frac{1}{n!}\binom{n}{2}u^{n-2}s^2\epsilon(x)^2\frac{\mathrm{d}u}{u} = \frac{s^2\epsilon(x)^2}{(n-2)!}$$

$$\cdots$$

$$\int_0^\infty \frac{1}{n!}\frac{(\ln a)^n}{s^n}\frac{\mathrm{d}u}{u} = \frac{(\ln a)^n}{n!s^n}$$

因此，我们可以得到：

$$\mathcal{L}\left[\frac{1}{s-\frac{a}{x}\ln x}\right] = \sum_{n=0}^\infty \frac{(\ln a)^n}{n!s^n}+\sum_{n=1}^\infty \frac{s^{1-n}\epsilon(x)^n}{(n-1)!}\left(1+\frac{\ln a}{s}\right)^{n-1}$$

------------

现在，让我们回顾一下 **Laplace** 方法的公式：

$$\int_0^\infty f(x)e^{-sx}\mathrm{d}x\approx \sqrt{\frac{2\pi}{s}}f(0)+\sum_{k=1}^n\frac{(-1)^kf^{(k-1)}(0)}{s^k}$$

其中，$f^{(k)}(x)$ 表示 $f(x)$ 的 $k$ 阶导数。现在，我们可以将 $f(x) = \frac{1}{x}g(x)$ 代入公式，得到：

$$\int_0^\infty x^{\frac{a}{x}-1} e^{-sx}\mathrm{d}x \approx \sqrt{\frac{2\pi}{s}}g(0)+\sum_{k=1}^n\frac{(-1)^k g^{(k-1)}(0)}{s^k}$$

根据之前的推论，$g(0) = a$。因此，我们只需要计算 $g^{(k-1)}(0)$ 即可。通过计算，我们可以得到：

$$g(x) = x^{\frac{a}{x}} = e^{a\ln x/x}$$

因此，

$$g^{(k)}(x) = \frac{a}{x^k}e^{a\ln x/x}(1-\ln x/x)^k$$

因此，

$$g^{(k-1)}(0) = \frac{a}{(k-1)!}$$

根据这些结果，我们可以将 Laplace 方法应用于原积分：

$$\begin{aligned}\int_0^\infty x^{\frac{a}{x}-1} \mathrm{d}x &\approx \sqrt{\frac{2\pi}{s}}a+\sum_{k=1}^n\frac{(-1)^k\frac{a}{(k-1)!}}{s^k}\\ &= \sqrt{\frac{2\pi}{s}}a-\frac{a}{s}\sum_{k=1}^n\frac{(-1)^k}{(k-1)!s^{k-1}}\end{aligned}$$

现在，让我们令 $n\rightarrow\infty$，得到：

$$\int_0^\infty x^{\frac{a}{x}-1} \mathrm{d}x \approx \sqrt{\frac{2\pi}{s}}a-\frac{a}{s}\sum_{k=0}^\infty\frac{(-1)^k}{k!s^{k}}$$

右侧的无穷级数可以表示为 $\frac{1}{s}e^{1/s}$。因此，我们可以将其代入上式......

------------

## 粗略解释一下（前文概览）：

根据 **Laplace** 方法，我们可以将积分 $\int_0^\infty x^{\frac{a}{x}-1} \mathrm{d}x$ 转化为一个关于参数 $s$ 的无穷级数形式，其中 $s$ 是一个实数参数。具体来说，右侧的无穷级数可以表示为 $\sum_{n=0}^{\infty} \frac{1}{n!} s^n$。

然后，我们可以将这个无穷级数代入原始积分中，得到一个关于 $a$ 和 $s$ 的表达式。最终结果将是一个关于参数 $a$ 和 $s$ 的函数形式，可以通过进一步计算和分析来研究其性质。

**完结躺平**

---

## 作者：myEnd (赞：2)

~~这么简单的模板题竟然能交题解，MnZn XOR~~

[原题链接](https://www.luogu.com.cn/problem/P4526) / [AC 记录](https://www.luogu.com.cn/record/61093603)

言归正传，接下来我们讲解这道题的做法：

# Part -1 / 辛普森公式的推导过程
窝个人还是认为肥肠简单滴。


具体什么是辛普森公式，可以去康康你的高数课本，在讲定积分的估算的时候那个用抛物线取拟合的就是啦。

设 $f(x)$ 为原函数，又设 $g(x) = ax^2+bx+c$ 为拟合后的函数，那么有：
$$\begin{aligned}\int_{A}^{B}f(x)\text{d}x &\approx \int_{A}^{B} g(x) \text{d} x\\ &= \int_{A}^{B} (ax^2+bx+c) \text{d} x \\ &= \frac{a}{3}({B}^3-A^3)+\frac{b}{2}(B^2-A^2)+c(A-B)\\&=\frac{B-A}{6}(2a(B^2+AB+A^2) + 3b(A+B) + 6c)\\ &= \frac{B-A}{6}(aA^2 + bA + c + aB^2 + bB + c + 4a(\frac{A+B}{2})^2 + 4b(\frac{A+B}{2}) + 4c)\\ &= \frac{B-A}{6}(f(A)+f(B)+4f(\frac{A+B}{2}))
\end{aligned}$$

就得到了辛普森公式：

$$\int_{a}^{b}f(x)\text{d}x \approx \frac{(b-a)(f(a)+f(b)+4f(\frac{a+b}{2}))}{6}$$

# Part 0 / ~~毅些废话~~
这道题的这种定积分的上下界中出现 $+\infty$ 或 $-\infty$ 的，叫做反常积分（或无穷界积分），一般计算的时候会先审敛，尤其是出现参数的时候（像这道题）。


# Part 1 / 审敛，即判断是否发散

> 注意！下面过程中的 $C$ 取常数，$C_1$ 可以取常数也可以取正无穷。

## 反常积分的审敛法


我们设 $f(x)$ 在积分区间 $[a,+\infty)$ 上恒有 $f(x) \ge 0$:

1. 若存在一个常数 $p  > 1$ 使得 
$$\lim_{x \rightarrow +\infty}{x^pf(x)}=C$$
那么 $\int_a^{+\infty}{f(x) \text{d}x}$ 收敛。

2. 若
$$\lim_{x\rightarrow+\infty}{xf(x)}=C_1 > 0$$
那么 $\int_a^{+\infty}{f(x)\text{d}x}$ 发散。

## 无穷间断点的审敛法
设 $a$ 是 $f(x)$ 的无穷间断点，$f(x)$ 在 $(a,b]$ 上均有 $f(x) \ge 0$：
1. 若存在常数 $p\in(0,1)$ 使得
$$\lim_{x\rightarrow a^+ }{(x-a)^p f(x)}=C$$
那么 $\int_a^b {f(x)} \text{d}x$ 收敛。

2. 若
$$\lim_{x\rightarrow a^+ }{(x-a) f(x)} = C_1 > 0$$
那么 $\int_a^b {f(x)} \text{d}x$ 发散。

---

类似的，设 $b$ 是 $f(x)$ 的无穷间断点，$f(x)$ 在 $[a,b)$ 上均有 $f(x) \ge 0$：

1. 若存在常数 $p \in (0,1)$ 使得
$$\lim_{x\rightarrow b^-} {(b-x)^pf(x)}=C$$
那么 $\int_a^b {f(x)} \text{d}x$ 收敛，

2. 类似的，若
$$\lim_{x\rightarrow b^-}{(b-x)f(x)} = C_1 > 0$$
那么 $\int_a^b {f(x)} \text{d}x$ 发散。

## 对于此题的推导
$x \ge 0$，故 $f(x) \ge 0$ 恒成立。

---
### $x \rightarrow 0^+$
$$\lim_{x\rightarrow 0^+}{f(x)}=e^{\lim_{x \rightarrow 0^+}{\frac{(a-x^2)\ln x}{x}}}=e^{a \lim_{x\rightarrow 0^+}{\frac{\ln x}{x}}}$$

(1) $e^{+\infty} = +\infty$，此时 $a<0$；

(2) $e^0=1$，$a=0$；

(3) $a^{-\infty}=0$，$a>0$。

所以只有当 $a<0$ 时原积分**可能**在 $x=0$ 处发散。

又因为会有
$$\lim_{x\rightarrow 0^+}{(x-0)f(x)}=e^{\lim_{x\rightarrow 0^+}{\ln x(1-x+\frac{a}{x})}}=e^{+\infty}=+\infty$$
所以可以得到原积分在 $x=0$ 处发散。

---

### $x \rightarrow +\infty$
运用洛必达，可以得到：
$$\lim_{x\rightarrow +\infty}{x^2f(x)}=e^{\lim_{x\rightarrow +\infty}\frac{(a-x^2+2x)\ln x}{x}}=e^{+\infty}=+\infty$$
所以原积分在 $x\rightarrow +\infty$ 处收敛。

~~好恶心的推导过程~~

# Part 2 / 当 $a \ge 0$ 时的代码实现
由于 $a>0$ 时原积分在 $a\rightarrow +\infty$ 处收敛且 $f(10)=10^{\frac{a}{10}-10}$，$f(20)=20^{\frac{a}{20}-20}$。即便 $a$ 取到题目上限 $50$ 仍可以忽略精度问题（$f(10)=10^{-5}$，$f(20)=20^{-15}$）故自适应辛普森算法的左右端点可以取 $0$、$20$。

应当注意到的是，如果你的右端点取值过大会导致初始状态用辛普森公式近似定积分值时得到了 $f(mid)$ 与 $f(r)$ 等于 $0$ 从而导致拟合误差较大。

同时，为了提高准确性，初始 $eps$ 可以适当的调高，例如 $10^{-7}$。

# Part 3 / 总结
1. 若在写自适应辛普森算法时出现了较大的误差，可以修改初次调用辛普森函数时积分区间的左右端点 $l$，$r$ 和初始精度 $eps$ 的值入手；左右端点 $l$、$r$ 的确定应是推导得到的，而不是瞎猜，且应先估算误差。
2. 求极限时，尽量使用这个公式：
$$\text{若}\space f(a) \space \text{、} f(b) \space\text{在} \space x \rightarrow a \space \text{时极限均存在，则有} \space \lim_{x \rightarrow a}{f(a) f(b)} = \lim_{x \rightarrow a}{f(a)}\cdot\lim_{x \rightarrow a}{f(b)}$$

# Part 4 / 关键 CODE
```cpp
const double EPS=1e-7;

// 比较两个双精度浮点数
int fcmp(double x, double y)
{
    return fabs(x-y) <= EPS;
}

double A;// 输入的 a

inline double f(double x)
{
    if(fcmp(x,0.0))
        if(fcmp(A, 0.0)) return 1.0;
        else return 0.0;
    else
        return exp((A-x*x)*log(x)/x);
}

// Simpson YYDS！
// 辛普森模板
inline double Simpson(double a, double b)
{
    return (f(a) + 4*f((a+b)/2.0) + f(b))*(b-a)/6.0;
}

// 自适应辛普森模板
double sol(double l, double r, double eps, double ans)
{
    REG double mid=(l+r)/2.0;
    double ansl=Simpson(l,mid), ansr=Simpson(mid,r);
    if(fabs(ansl+ansr-ans)<=15*eps)
         return ansl+ansr+(ansl+ansr-ans)/15.0;
    else
         return sol(l,mid,eps/2.0,ansl)+sol(mid,r,eps/2.0,ansr);
}

// 求解
inline double query()
{
    retrun sol(0,20,EPS,Simpson(0,20));
}
```

---

## 作者：洛必达法则 (赞：2)

居然……用矩形法轻松Accept？
```cpp
#include<bits/stdc++.h>
using namespace std;
double a;
inline double f(double);
double ans=0;
int main()
{
    scanf("%lf",&a);
    if(a<0)
    {
        puts("orz");
        exit(0);
    }
    if(a==0)//此时精度实在差太多
    {
        puts("1.99546");
        exit(0);
    }
    for(double i=0;i<15;i+=0.001)
    {
        ans+=f(i)/1000;
    }
    printf("%.5lf",ans);
    exit(0);
}
inline double f(double x)
{
    if(x==0)
    {
        return 0;
    }
    return pow(x,(a/x)-x);
}
```
接下来正经一些：

辛普森积分法本身是Newton-Cotes公式的子结论

Newton-Cotes公式如下(Wikipedia)

![](https://cdn.luogu.com.cn/upload/image_hosting/5cw7o3wh.png)

(补充：矩形法为$n=0$时的情况)

Newton-Cotes公式的本质，即为用$n$次多项式$(n \in N)$来近似的表示我们要积的函数。

当$n=4$时，有：

Boole's rule:

Wikipedia：
![](https://cdn.luogu.com.cn/upload/image_hosting/9nqxvhbm.png)

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
double a;
inline double f(double);
double ans=0;
int main()
{
    scanf("%lf",&a);
    if(a<0)
    {
        puts("orz");
        exit(0);
    }
    for(double i=0;i<0.004;i+=0.00001)//精度需求
    {
        double delta=7*f(i)+32*f(i+0.0000025)+12*f(i+0.000005)\
        +32*f(i+0.0000075)+7*f(i+0.00001);
        delta*=0.000005;
        delta/=45.0;
        ans+=delta;
    }
    for(double i=0.004;i<15;i+=0.001)
    {
        double delta=7*f(i)+32*f(i+0.00025)+12*f(i+0.0005)\
        +32*f(i+0.00075)+7*f(i+0.001);
        delta*=0.0005;
        delta/=45.0;
        ans+=delta;
    }
    printf("%.5lf",ans);
    exit(0);
}
inline double f(double x)
{
    if(x==0)
    {
        return 0;
    }
    return pow(x,(a/x)-x);
}

```
自适应：
```cpp
#include<bits/stdc++.h>
using namespace std;
double a;
inline double f(double);
inline double summa(double,double);
inline double simple(double,double);
int main()
{
    scanf("%lf",&a);
    if(a<0)
    {
        puts("orz");
        exit(0);
    }
    printf("%.5lf",summa(0,20));
    exit(0);
}
inline double simple(double l,double r)
{
    double h=(r-l)/4.0;
    return (h*2/45)*(7*f(l)+32*f(l+h)+12*f(l+2*h)+32*f(r-h)+7*f(r));
}
inline double summa(double l,double r)
{
    double mid=(l+r)/2.0;
    double ans;
    ans=simple(l,r);
    double check=simple(l,mid)+simple(mid,r);
    if(abs(ans-check)>0.0000001)
    {
        ans=summa(l,mid)+summa(mid,r);
    }
    return ans;
}
inline double f(double x)
{
    if(x==0)
    {
        return 0;
    }
    return pow(x,(a/x)-x);
}
```
P.S.

梯形法($n=1$时的Newton-Cotes)代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
double a;
inline double f(double);
double ans=0;
int main()
{
    scanf("%lf",&a);
    if(a<0)
    {
        puts("orz");
        exit(0);
    }
    if(a==0)
    {
        puts("1.99546");
        exit(0);
    }
    double opt,oprt=f(0);
    for(double i=0;i<15;i+=0.001)
    {
        opt=oprt;
        oprt=f(i+0.001);
        ans+=(opt+oprt)/2000;
    }
    printf("%.5lf",ans);
    exit(0);
}
inline double f(double x)
{
    if(x==0)
    {
        return 0;
    }
    return pow(x,(a/x)-x);
}
```

---

## 作者：Walter_Fang (赞：1)

## 自适应辛普森法题解与学习笔记
### 前言
首先看到[P4525 【模板】自适应辛普森法 1](https://www.luogu.com.cn/problem/P4525)。这题是很好的辛普森板题，但是用牛顿-莱布尼茨公式就可以算出答案：

当 $a=0$ 时，
$$
\begin{aligned}
\int \frac{c x+d}{a x+b} d x 
& =\int \frac{c x+d}{b} d x \\
& =\frac{1}{b}\left(\int c x d x\right)+\frac{1}{b}\left(\int d d x\right) \\
& =\frac{c x^2}{2 b}+\frac{d x}{b}
\end{aligned}
$$
当 $a\not=0$ 时，
$$
\begin{aligned}
\int \frac{c x+d}{a x+b} d x 
& =\int \frac{\frac{c}{a}(a x+b)-\frac{b c}{a}+d}{a x+b} d x \\
& =\left(\int \frac{c}{a} d x\right)+\left(\left(-\frac{b c}{a}+d\right) \int \frac{1}{a x+b} d x\right) \\
& =\frac{c x}{a}+(d-\frac{b c}{a}) \frac{\ln |a x+b|}{a}
\end{aligned}
$$
虽然这样我们就可以通过这题，但是肯定还要讲一下自适应辛普森法。
### 算法介绍
$\text{Simpson}$ 法的思想是将原曲线近似为一段段抛物线，再求每一段的面积。具体地，我们令 $f(x)=\frac{c x+d}{a x+b}, g(x)=A x^2+B x+C$ 为拟合函数，则有
$$
\begin{aligned}
\int_L^R f(x) d x & \approx \int_L^R g(x) \\
& =\frac{A}{3}\left(b^3-a^3\right)+\frac{B}{2}\left(b^2-a^2\right)+C(b-a) \\
& =\frac{b-a}{6}\left(A a^2+B a+C+A b^2+B b+C+A(b-a)^2+2B(b-a)+4 C\right) \\
& =\frac{b-a}{6}\left(f(a)+f(b)+f\left(\frac{b-a}{2}\right)\right)
\end{aligned}
$$
介绍完 $\text{Simpson}$ 法后我们再回过头看这题。
### 题解
题目要求$\int_0^{\infty}x^{\frac{a}{x}-x}\text{d}x$，肯定不能用牛顿-莱布尼茨公式。经过讨论可得：

当 $a<0$ 时，$\lim _{x \rightarrow 0} x^{\frac{a-x^2}{x}}=e^{\lim _{x \rightarrow 0} \frac{a-x^2}{x} \ln x}=+\infty$ ，原函数发散，输出 $\text{orz}$。

当 $a \geq 0$ 时。
$\lim _{x \rightarrow+\infty} x^2 x^{\frac{a-x^2}{x}}=e^{\lim _{x \rightarrow \infty} \frac{a-x^2+2 x}{x} \ln x}=0$ ，原函数收敛。用 $\text{Simpson}$ 法解决即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const double eps=1e-10;
double a;
double f(double x){return pow(x,a/x-x);}
double Simpson(double l,double r){return (f(l)+f(r)+4*f((l+r)/2))*(r-l)/6;}
double Query(double l,double r,double t){
	double mid=(l+r)/2,x=Simpson(l,mid),y=Simpson(mid,r);
	if(fabs(x+y-t)<=1e-9)return t;
	else return Query(l,mid,x)+Query(mid,r,y);
}
int main(){
	cin>>a;
	if(a<0)return cout<<"orz",0;
	cout<<fixed<<setprecision(5)<<Query(eps,20,Simpson(eps,20));
}
```

---

## 作者：Kreado (赞：1)

计算积分

$$\int_{L}^R \frac{cx+d}{ax+b}dx$$

另 $f(x)=\dfrac{cx+d}{ax+b},g(x)=Ax+Bx+C$ 为拟合函数。

则

$$\begin{aligned}\int_{L}^R f(x)dx&\approx\int_{L}^R g(x)\\&=\frac{A}{3}(b^3-a^3)+\frac{B}{2}(b^2-a^2)+C(b-a)\\&=\frac{b-a}{6}(Aa^2+Ba+C+Ab^2+Bb+C+4A(\frac{b-a}{2})^2+4B(\frac{b-a}{2})+4C)\\&=\frac{b-a}{6}(f(a)+f(b)+f(\frac{b-a}{2}))\end{aligned}$$

这就是 **Simpson** 公式，但是我们还有一个问题，**精度**。

这个简单，我们只需将原区间分成 $2n$ 个小区间 $[a_i,a_{i+1}](a_i<a_{i+1})$，然后用抛物线近似函数 $f(x)$ 的曲线。

[P4525 【模板】自适应辛普森法 1](https://www.luogu.com.cn/problem/P4525)。

上面已经说了，这里就不讲了。

#### CoDe

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
double L,R,a,b,c,d;
inline double f(double x){
	return (c*x+d)/(a*x+b);
}
inline double simpson(double l,double r){
	double mid=(l+r)/2;
	return (f(l)+f(r)+4*f(mid))*(r-l)/6;
}
inline double query(double l,double r,double eps,double A){
	double mid=l+(r-l)/2;
	double t1=simpson(l,mid),t2=simpson(mid,r);
	if(fabs(t1+t2-A)<=eps*15) return t1+t2+(t1+t2-A)/15;
	else return query(l,mid,eps/2,t1)+query(mid,r,eps/2,t2);
}
int main(){
	scanf("%lf%lf%lf%lf%lf%lf",&a,&b,&c,&d,&L,&R);
	printf("%lf",query(L,R,1e-7,simpson(L,R)));
	return 0;
} 
```


[P4526 【模板】自适应辛普森法 2](https://www.luogu.com.cn/problem/P4526)。

求

$$\int_{0}^{\infty}x^{\frac{a}{x}-x}dx$$

显然反常积分，当 $a<0$ 时。

$\lim\limits_{x\to 0}x^{\frac{a-x^2}{x}}=e^{\lim\limits_{x\to 0}\frac{a-x^2}{x}\ln x}=+\infty$，原函数发散。

当 $a\ge 0$ 时。

$\lim\limits_{x\to +\infty}x^2x^{\frac{a-x^2}{x}}=e^{\lim\limits_{x\to \infty}\frac{a-x^2+2x}{x}\ln x}=0$，原函数收敛。

然后直接 Simpson。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
double a;
inline double f(double x){
	return pow(x,a/x-x);
}
inline double simpson(double l,double r){
	double mid=(l+r)/2;
	return (f(l)+f(r)+4*f(mid))*(r-l)/6;
}
inline double query(double l,double r,double A){
	double mid=l+(r-l)/2;
	double t1=simpson(l,mid),t2=simpson(mid,r);
	if(fabs(t1+t2-A)<=1e-9) return A;
	else return query(l,mid,t1)+query(mid,r,t2);
}
int main(){
	scanf("%lf",&a);
	if(a<0) return printf("orz"),0;
	printf("%.5lf",query(1e-9,15,simpson(1e-9,15)));
	return 0;
} 
```


---

## 作者：Argon_Cube (赞：1)

* **【题目链接】**

[Link:P4526](https://www.luogu.com.cn/problem/P4526)

* **【解题思路】**

首先，我们看函数图像知道，虽然积分上界是 $\infty$，事实上到了 $x=15$ 以后的积分就基本可以忽略了。

然后，我们看函数图像还知道，$a$ 只要稍微大一点，函数图像在一小段内看起来基本是直线。

这个时候，我们就可以使用梯形法近似了。

注意一点，当 $a=0$ 时，梯形法精度误差太大，过不去，需要特判。

顺便说一句，梯形法间隔取 $0.12$ 都基本可以过了，这积分强度不行啊……

* **【代码实现】**

```cpp
#include <iostream>
#include <cmath>

using namespace std;

long double a,ans=0;

inline long double f(long double x)
{
	if(x==0)
		return 0;
	return pow(x,a/x-x);
}

int main(int argc,char* argv[],char* envp[])
{
	const long double tick=0.12;
	cin>>a;
	if(a==0)
		return cout<<"1.99546",0;
	if(a<0)
		return cout<<"orz",0;
	cout<<fixed;
	cout.precision(5);
	for(long double ptr=tick;ptr<15;ptr+=tick)
		ans+=(f(ptr)+f(ptr+tick))*tick/2;
	cout<<ans;
	return 0;
}
```

---

## 作者：Jμdge (赞：1)

所以又水过了 辛普森2...

$$\LaTeX$$
# noteskey

用的方法和 1 差不多，做法也是和 1 题解中说的把 f 里面的东西换一换就好了【滑稽

但是这里要判断发散啊...怎么办？ 我们考虑只要看看 a 是否小于 0 就好了，小于 0 的话就是发散的，证明呢？

我们令 a<0 然后化式子：

$$f(x)=x^{{a\over x}-x}$$

$$=x^{{a-x^2\over x}}$$



$$={1\over x^{{x^2-a\over x}}}$$


我们考虑 $x→0$ 的情况，这时候有：

$1\over x$ 无穷大，$x^2-a >0$ 

所以 $x^\infty →0$ ，$1\over x^\infty$ 无穷大

原函数发散，得证

$$\LaTeX$$

至于大于等于零则不发散，这种情况下 x 越大原式越接近 0 ，对答案没有贡献，所以原式中右区间的 $\infty$ 我们可以根据手造出来的函数图像（或者用个什么几何画板之类的软件画画）分析一下大概到 10 以上就没什么贡献了...吧？反正开个 12 是可以过的，所以我们把 $[eps,12]$ 简单带入 $asr$ 计算答案就好了

$$\LaTeX$$







# for more

话说这代码好短啊！~~真好背！~~

话说左边界 l 设为 eps 可海星（好像是为了避免 f(0) 对答案的影响？）

正经解释一下：

辛普森是去找一个**连续的** 二次函数去拟合原函数，所以原函数中的特殊点是会对误差的判定产生奇怪的影响的（考虑 题目中给的函数在 0 点比较特殊）

但是我们发现其实把 0 点去掉对答案不会有影响（因为线段是没有面积的啊！）

当然我们肯定做不到只吧 0 点挖掉，那么我们就忍痛将从 0 开始的一段极小区间都挖掉，这样的误差是在答案允许范围内的

当然这道题给了我们一点启示，就是在做辛普森的时候要多注意特殊点 ~~（然后把特殊点狠狠挖掉）~~ ，避免特殊点对答案的影响，尤其是像 0 点这么明显的点...

$$\LaTeX$$

# code

```
//by Judge
#include<bits/stdc++.h>
#define Rg register
#define db double
using namespace std; db a;
inline db f(Rg db x){return pow(x,a/x-x);}
inline db simpson(Rg db l,Rg db r){ db mid=(l+r)/2;
	return (f(l)+f(r)+4*f(mid))*(r-l)/6;
}
db asr(db l,db r,db eps,db ans){
	db mid=(l+r)/2,L=simpson(l,mid),R=simpson(mid,r);
	if(fabs(L+R-ans)<=eps) return L+R+(L+R-ans);
	return asr(l,mid,eps/2,L)+asr(mid,r,eps/2,R);
}
inline db asr(Rg db l,Rg db r,Rg db eps){
	return asr(l,r,eps,simpson(l,r));
}
int main(){ scanf("%lf",&a); if(a<0) return !puts("orz");
	return !printf("%.5lf\n",asr(1e-8,12,1e-6)); //左区间随便设，小于 1e6 肯定都行，别是 0 就好
}
```

$$\LaTeX$$



---

## 作者：jlz_love_cyz (赞：0)

## Part 1 思路整理

看到了题目，很多人可能会有疑问，什么是[辛普森积分法](https://baike.baidu.com/item/%E8%BE%9B%E6%99%AE%E6%A3%AE%E7%A7%AF%E5%88%86%E6%B3%95/23337870)呢？

所谓辛普森积分法呢，就是用抛物线来近似函数的图像（类似于我们熟知的泰勒级数），从而达成近似定积分数值的目的，是牛顿-科特斯公式的子结论（牛顿-科特斯公式         $\int_a^bf(x)\,\text{d}x\approx\sum\limits_{i=0}^nw_if(x_i)$） 。由于辛普森公式只能作上下边界为有限数的定积分的近似，那我们就必须舍去图像中面积过小而无意义的部分。

## Part 2 边界取舍

看了看楼上楼下，都没有把这个函数的图像真正的整出来的。我们现在就使用[desmos](https://www.desmos.com)这个工具来直观的感受一下这个函数的图像。

![](https://cdn.luogu.com.cn/upload/image_hosting/cua8cwtl.png)

这个是当 $a=2.33$ 时，函数的图像

我们可以看到，当 $x\in[15,+\infty)$ 时，函数的图像无限趋近于$x$轴，故这一段的面积可以近似为0。这一下我们就很高兴啦，可以很愉快地使用辛普森积分了呢。

就这样，我们求积分的式子就变为 $\int_0^{15}x^{\frac a x-x}\,\text{d}x$ 了。

## Part 3 发散与收敛

注意到题目让我们特判出积分发散时的情况并输出orz，所以，我们必须找出当积分发散时 $a$ 的取值。现在，我们告诉大家， $a\ge0$ 时，积分收敛； $a<0$ 时，积分发散，下面就来简单证明一下。

1. $a<0$ 时，积分发散

我们令$ f(x)=x^{\frac a x-x} $

那么我们就可以得到:$ f(x)=x^{\frac {a^2-x} a} $

$=\dfrac 1 {x^{\frac {x-a^2} a}}$ （这一步的证明[楼上creeperK大佬有讲](https://www.luogu.com.cn/blog/DJCreeper/P4526)，不再赘述）

$\because x\to0$ 时， $x^2\to0,\dfrac 1 x\to+\infty$

$\therefore x^2-a\to-a,-\dfrac a x\to+\infty$

又 $\because$ 当 $x\in(0,1)$ 时     $\lim\limits_{n\to+\infty}x^n\to0$ 

故 $\lim\limits_{x\to0}f(x)\to+\infty$

则原命题得证.


2. $a\ge0$ 时，积分收敛

我们首先讨论 $a\in\mathbb{R}$ 时的情况。

$\because \lim\limits_{x\to+\infty}\dfrac {a-x^2} a \to +\infty$

$\therefore \lim\limits_{x\to+\infty}x^{\frac {a-x^2} a}\to+\infty$

又 $\because \lim\limits_{m\to+\infty}\dfrac 1 m\to 0$

$\therefore$原函数在 $x$ 趋近于正无穷时收敛

然后呢，我们再讨论 $a>0$ 时的情况。

$\because \left.\frac {a-x^2} x\right|_{x<\min(\sqrt{a},1)}>0$

$\therefore \left.x^{\frac {a-x^2} x}\right|_{x<\min(\sqrt{a},1)}<1$

$\therefore x<1$ 时,原函数是有限的

故命题2得证

综上所述，我们就得到了原函数收敛和发散的条件啦

## Part 4 code 

那么，综合以上的分析，我相信各位一定理解了这题的思路与解法。下面就是AC代码：

```cpp
//@copyright 2020~2022 Iam贾粮宅  All rights reserved
#include <bits/stdc++.h>
#define cd const double
typedef long long ll;
using namespace std;
cd Eps=1e-8;
double a,lf,rt;
inline double f(double x)//function original
{
    return pow(x,(a/x)-x);
}
inline double s(double p,double q)//simpson
{
	double k=p+(q-p)/2;
    return (f(p)+4*f(k)+f(q))*(q-p)/6.0;
}
double as(double p,double q,double S)//adaptive-simpson
{
	double k=p+(q-p)/2;
    double l1=s(p,k),l2=s(k,q);
    if(fabs(l1+l2-S)<=Eps) return l1+l2;
    else return as(p,k,l1)+as(k,q,l2);
}
int main()
{
    cin>>a;
    if(a<0) puts("orz");
    else printf("%.5lf",as(Eps,15,s(lf,rt)));
    return 0;
}
```

注意，这里Eps不要调太高，建议是1e-8.（要不然你可能会WA几个点）

---


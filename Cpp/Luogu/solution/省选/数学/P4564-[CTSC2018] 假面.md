# [CTSC2018] 假面

## 题目背景


针针是绿绿的好朋友。

## 题目描述

针针喜欢玩一款叫做 DotA (**D**efense **o**f **t**he **A**lgorithm) 的游戏，在这个游戏中，针针会操纵自己的英雄与队友一起对抗另一支队伍。
针针在 DotA 中最喜欢使用的英雄叫做假面（Faceless），该英雄有 $2$ 个技能：

- 锁定：对一名指定的敌方单位使用，以 $p$ 的概率对该单位造成 $1$ 点伤害（使其减少 $1$ 点生命值）。
- 结界：在一片区域施放结界，让该区域内的所有其他单位无法动弹。
在游戏中，如果一个单位的生命值降至 $0$ 或 $0$ 以下，那么该单位就会死亡。

针针操纵假面的水平一般，因此他决定勤加练习。现在有 $n$ 个敌方单位（编号从 $1$ 至 $n$），编号为 $i$ 的敌方单位有 $h_i$ 点生命值。

针针已经安排好了练习的计划，他会按顺序施放 $Q$ 个技能：

- 对于锁定技能：针针会指定一个敌方单位 $id$ ，并对它施放。由于决定概率系数 $p$ 的因素很多，因此每次的 $p$ 都不一定相同。
特别地，如果该敌方单位已经死亡，那么该技能不会造成任何效果。
- 对于结界技能：针针会希望对 $k$ 个指定的敌方单位施放，但由于针针并不擅长施放该技能，因此他只能命中恰好 $1$ 个敌方单位。命中每个存活的敌方单位的概率是相等的（也就是说已经死亡的敌方单位不会有任何影响）。
特别地，如果这 $k$ 个敌方单位均已死亡，那么该技能同样不会命中任何敌方单位。

现在，围观针针进行练习的绿绿想知道：

1. 对于针针施放的每个结界技能，它命中各敌人的概率分别是多少。
2. 在针针的所有技能施放完毕后，所有敌方单位剩余生命值的期望分别是多少。

由于绿绿还要围观针针训练，所以请你帮他解决这两个问题。

为了防止精度误差，对于所有需要输出的数值，请输出其在模 $998244353$ 意义下的值。

由于结界为假面的终极技能，因此针针施放该技能的次数不会太多。具体请见”子任务“。

## 说明/提示

### 样例解释 1
针针按顺序施放如下技能：

1. 对敌方单位 $2$ 施放技能锁定：以 $1$ 的概率对其造成 $1$ 点伤害。此时 $2$ 号敌方单位必定剩余 $1$ 点生命值。
2. 对敌方单位 $2$ 施放技能结界：（由于 $2$ 号敌方单位尚存活，）必定命中 $2$ 号单位。
3. 对敌方单位 $2$ 施放技能锁定：以 $1$ 的概率对其造成 $1$ 点伤害。
4. 对敌方单位 $3$ 施放技能锁定：以 $1$ 的概率对其造成 $1$ 点伤害。此时三个敌方单位的生命值一定分别为 $1, 0 ,2$ ，敌方单位 $2$ 一定死亡。
5. 对敌方单位 $2$ 施放技能结界：（由于 $2$ 号敌方单位已死亡，）必定不命中任何单位。
6. 对敌方单位 $1, 2, 3$ 施放技能结界：命中敌方单位 $1, 3$ 的概率是相等的，即各 $\frac{1}{2}$ 。 最终，三个敌方单位的剩余生命值一定为 $1 , 0 , 2$ 。

### 样例解释 2
对于各结界技能的分析：

1. 第 $1$ 个结界（目标为敌方单位 $1,2$ ）：
- $2$ 号敌方单位存活的概率为 $\frac{1}{2}$ ， $1$ 号敌方单位必定存活。
- 如果 $2$ 号敌方单位存活，那么结界命中 $1 , 2$ 的概率相等，均为 $\frac{1}{2}$ ；如果 $2$ 号敌方单位死亡，那么结界必定命中 $1$ 号敌方单位。
- 因此：命中 $1$ 号敌方单位的概率为 $\frac{1}{2} \times 1 + \frac{1}{2} \times \frac{1}{2} = \frac{3}{4}$ ；命中 $2$ 号敌方单位的概率为 $\frac{1}{2} \times 0 + \frac{1}{2} \times \frac{1}{2} = \frac{1}{4}$ 。
2. 第 $2$ 个结界（目标为敌方单位 $1, 2, 3$ ）：
- 三个敌方单位存活的概率分别为 $1, \frac{1}{2} , \frac{1}{3}$ 。
- $1 , 2 , 3$ 同时存活的概率为 $\frac{1}{6}$ ；只有 $1, 2$ 存活的概率为 $\frac{1}{3}$ ；只有 $1 , 3$ 存活的概率为 $\frac{1}{6}$ ；只有 $1$ 存活的概率为 $\frac{1}{3}$ 。
- 因此：命中 $1$ 号敌方单位的概率为 $\frac{1}{6} \times \frac{1}{3} + (\frac{1}{3}+\frac{1}{6}) \times \frac{1}{2}+ \frac{1}{3} \times 1 = \frac{23}{36}$ ；命中 $2$ 号敌方单位的概率为 $\frac{1}{6} \times \frac{1}{3} + \frac{1}{3} \times \frac{1}{2} = \frac{2}{9}$ ；命中 $3$ 号敌方单位的概率为 $\frac{1}{6} \times \frac{1}{3} + \frac{1}{6} \times \frac{1}{2} = \frac{5}{36}$ 。 最终，三个敌方单位的剩余生命值的期望值为 $1 , \frac{1}{2} , \frac{1}{3}$ 。


### 数据范围

我们记 $C$ 为结界技能的数量。

测试点编号|n=|Q=|C=|u,v|其他限制
-|-|-|-|-|-
1|5|21|6|u<v|无
2|60|199992|500|u<v|所有 p 均相等
3|60|23|6|u<v|所有m_i =1
4|60|199994|500|u<v|无
5|60|199995|500|u<v|无
6|60|199996|0|u<v|无
7|60|199997|500|u=v|无
8|200|199998|1000|u<v|无
9|200|199999|1000|u<v|无
10|200|200000|1000|u<v|无

对于所有测试点，保证 $n \le 200 , Q \le 200000 , C \le 1000 , m_i \le 100$ 。

提示

Q 的个位可以帮助你快速确定测试点的编号。
测试点顺序可能与难度无关。

感谢 @和泉正宗 提供题面 

## 样例 #1

### 输入

```
3
1 2 3
6
0 2 1 1
1 1 2
0 2 1 1
0 3 1 1
1 1 2
1 3 1 2 3```

### 输出

```
1
0
499122177 0 499122177
1 0 2
```

## 样例 #2

### 输入

```
3
1 1 1
4
0 2 1 2
1 2 1 2
0 3 2 3
1 3 1 2 3```

### 输出

```
249561089 748683265
804141285 887328314 305019108
1 499122177 332748118
```

# 题解

## 作者：RabbitHu (赞：21)

本题解同步发布于[胡小兔的博客](http://www.cnblogs.com/RabbitHu/p/9040230.html)，欢迎交流 >v<

考场上这道题我先是写了个70分暴力，然后发现似乎可以NTT，然鹅问题是——我没学过NTT，遂脑补之，脑补出来了，下午出成绩一看，卡成暴力分（70）……同是$O(Qk^2\log k)$，学姐的拉格朗日什么玩意就能过TAT……学姐太强了……

遂不忿，今天上午重写NTT，努力卡常，卡不进去……

那还是写正解吧。

首先，发现血量上限很少，0操作时，暴力维护每一时刻每个人是每种血量大小的概率即可。

1操作怎么办呢？设$alive_i$是$i$号人活着的概率，$dead_i$是他死了的概率，$g_{i,j}$是除$i$以外活了$j$个人的概率，$i$号人的答案就是$$alive_i * \sum_{j = 0}^{k - 1}\frac{1}{j + 1} * g_{i,j}$$

但是$g_{i,j}$怎么求呢？发现可以DP：设$f_{i,j}$表示前$i$个人有$j$个活着的概率，则$$f_{ij} = f_{i-1,j} * dead_i + f_{i-1,j-1} * alive_i$$

注意到最后的$f$和人的顺序无关，所以可以把人的顺序任意调换，把要求的这个$i$放在最后一个，这样$f_{k - 1}$就是$g_{i}$。

那么对于每个$i$求一遍$f$，复杂度是$O(n^3)$的，能得70分。

如何优化呢？考虑把$i$号人放在最后时，从$f_k$倒推到$f_{k-1}$：$$\frac{f_{k-1, j} = f_{k, j} - f_{k -1, j - 1} * alive_i}{dead_i}$$

注意到$dead_i = 0$时该式不能用，又发现此时$f_{k-1, j} = f_{k, j+1}$，所以也能直接求。

那么$O(n^2)$求出$f_k$，再$O(n^2)$倒推，直接可以获得答案！

```cpp
#include <cstdio>
#include <cmath>
#include <cstring>
#include <algorithm>
#include <iostream>
#define space putchar(' ')
#define enter putchar('\n')
typedef long long ll;
using namespace std;
template <class T>
void read(T &x){
    char c;
    bool op = 0;
    while(c = getchar(), c < '0' || c > '9')
	if(c == '-') op = 1;
    x = c - '0';
    while(c = getchar(), c >= '0' && c <= '9')
	x = x * 10 + c - '0';
    if(op) x = -x;
}
template <class T>
void write(T x){
    if(x < 0) putchar('-'), x = -x;
    if(x >= 10) write(x / 10);
    putchar('0' + x % 10);
}

const int N = 256, P = 998244353;
int n, m, K, t[N], b[N], rate[N][105], iv[N];
ll qpow(ll a, ll x){
    ll ret = 1;
    while(x){
	if(x & 1) ret = ret * a % P;
	a = a * a % P;
	x >>= 1;
    }
    return ret;
}
void attack(int tar, ll x){
    ll y = (1 - x + P) % P;
    for(int i = 0; i <= b[tar]; i++){
	if(i) rate[tar][i] = rate[tar][i] * y % P;
	if(i < b[tar]) rate[tar][i] = (rate[tar][i] + rate[tar][i + 1] * x) % P;
    }
}
void query(){
    static ll f[N], g[N], h[N];
    memset(f, 0, sizeof(f));
    f[0] = 1;
    for(int i = 1; i <= K; i++)
	for(int j = i; j >= 0; j--)
	    f[j] = ((j ? f[j - 1] * (1 - rate[t[i]][0]) : 0) + f[j] * rate[t[i]][0]) % P;
    for(int i = 1; i <= K; i++){
	h[i] = 0;
	if(!rate[t[i]][0])
	    for(int j = 0; j < K; j++)
		h[i] += f[j + 1] * iv[j + 1] % P;
	else{
	    int inv = qpow(rate[t[i]][0], P - 2);
	    for(int j = 0; j < K; j++){
		g[j] = (f[j] - (j ? g[j - 1] * (1 - rate[t[i]][0]) : 0)) % P * inv % P;
		h[i] += iv[j + 1] * g[j] % P;
	    }
	}
	h[i] %= P;
	h[i] = h[i] * (1 - rate[t[i]][0]) % P;
	if(h[i] < 0) h[i] += P;
    }
    for(int i = 1; i <= K; i++)
	write(h[i]), i == K ? enter: space; 
}

int main(){

    read(n);
    for(int i = 1; i <= n; i++)
	read(b[i]), rate[i][b[i]] = 1, iv[i] = qpow(i, P - 2);
    read(m);
    int op, x, u, v;
    while(m--){
	read(op);
	if(op == 0) read(x), read(u), read(v), attack(x, u * qpow(v, P - 2) % P);
	else{
	    read(K);
	    for(int i = 1; i <= K; i++) read(t[i]);
	    query();
	}
    }
    for(int i = 1; i <= n; i++){
	ll sum = 0;
	for(int j = 1; j <= b[i]; j++)
	    sum += (ll)j * rate[i][j] % P;
	write(sum % P), i == n ? enter: space;
    }
    
    return 0;
}
```

---

## 作者：Kelin (赞：12)

## [题意](https://blog.csdn.net/BeNoble_/article/details/80390659)

$n$个人$,Q$个操作$,$第$i$个人有$m_i$滴血$,$有两种操作

$1.$以$p$的概率使$u$掉$1$点血

$2.$给出$k$个人$,$从这些人中等概率地选出$1$个$,$求每个人被选中的概率

最后求每个人剩余血量的期望

---

## 题解

考虑怎么求每个人剩余的血的期望

用$p_u[i]$表示$u$剩余$i$点血的概率$\Rightarrow E_u=\sum_{i=0}^{m_i}ip_u[i]$

这个$p_u$是可以用背包维护的$($而且非常好理解$,$初值$p_u[m_u]=1)$

$p_u'[0]=p_u[0]+p_u[1]*p$

$p_u'[i]=p_u[i]*(1-p)+p_u[i+1]*p,i\in[1,m_u]$

操作$1$就用上面的$dp$维护即可

考虑怎么处理操作$2$

实际上操作$2$只需要知道每个人活下来的概率即可$,$即$px_u=1-p_u[0]$

对于$k$个人中的每个人用简单的数学知识可以得到选中$u$的概率是

$$px_u\sum_{i=0}^{k-1}\frac{f_u[i]}{i+1}$$

$f_u[i]$表示除了$u$之外只有$i$个人活着的概率

枚举另外一个人$v,$可以得到

$$f_u'[i]=px_v*f_u[i-1]+(1-px_v)*f_u[i]$$

于是乎对于每一个人做一遍这样的$dp$即可

复杂度$O(Qm+Cn^3)$~~显然过不了~~

考虑如果知道还活着任意$i$个人的概率$g[i]$和$px_u,$能不能知道$f_u[i]?$

~~显然是可以的~~可以发现上面那个$dp$没有人的限制$,$所以可以倒过来

$$f_u[i]=\frac{f'_u[i]-px_v*f_u[i-1]}{1-px_v}$$

因为这个$v$是随意的$,$所以有

$$f_u[i]=\frac{g[i]-px_u*f_u[i-1]}{1-px_u}$$

当$px_u=1$时$f_u[i]=g[i+1]$

$g$可以通过一个$n^2$的$dp$求出

$$g[i]=px_u*g[i-1]+(1-px_u)*g[i]$$

对于每一个人只要再$O(n)$逆转移一下即可

总时间复杂度$O(Qm+Cn^2)$

```
#include<bits/stdc++.h>
#define fp(i,a,b) for(register int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(register int i=a,I=b-1;i>I;--i)
#define go(u) for(register int i=fi[u],v=e[i].to;i;v=e[i=e[i].nx].to)
#define file(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
template<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}
template<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}
using namespace std;
char ss[1<<17],*A=ss,*B=ss;
inline char gc(){return A==B&&(B=(A=ss)+fread(ss,1,1<<17,stdin),A==B)?-1:*A++;}
template<class T>inline void sd(T&x){
    char c;T y=1;while(c=gc(),(c<48||57<c)&&c!=-1)if(c==45)y=-1;x=c-48;
    while(c=gc(),47<c&&c<58)x=x*10+c-48;x*=y;
}
char sr[1<<21],z[20];int C=-1,Z;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
template<class T>inline void we(T x){
    if(C>1<<20)Ot();if(x<0)sr[++C]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]=' ';
}
const int N=205,P=998244353;
typedef int arr[N];
typedef long long ll;
int n,m,q;arr f,g,w,px,inv,p[N];
int Inv(int x){return x<N?inv[x]:(ll)(P-P/x)*Inv(P%x)%P;}
inline int pls(int a,int b){return a+=b,a<P?a:a-P;}
inline int sub(int a,int b){return a-=b,a<0?a+P:a;}
int main(){
    #ifndef ONLINE_JUDGE
        file("s");
    #endif
    sd(n);
    fp(i,1,n)sd(w[i]),p[i][w[i]]=1;inv[1]=1;
    fp(i,2,N-1)inv[i]=(ll)(P-P/i)*inv[P%i]%P;
    sd(q);int op,x,a,b,tp=0;
    while(q--){
    	sd(op);
    	if(op){
    		sd(m);fp(i,1,m)sd(x),px[i]=sub(1,p[x][0]),g[i]=0;g[0]=1;
    		fp(i,1,m)fd(j,i,0)g[j]=((j?(ll)px[i]*g[j-1]%P:0ll)+(ll)sub(1,px[i])*g[j])%P;
    		fp(i,1,m){
    			if(!px[i]){we(0);continue;}
    			if(px[i]==1)fp(j,0,m-1)f[j]=g[j+1];
    			else{
    				x=Inv(sub(1,px[i]));f[0]=(ll)g[0]*x%P;
    				fp(j,1,m-1)f[j]=(ll)sub(g[j],(ll)f[j-1]*px[i]%P)*x%P;
    			}
    			fp(j,0,m-1)tp=pls(tp,(ll)f[j]*inv[j+1]%P);
    			we((ll)px[i]*tp%P);tp=0;
    		}sr[++C]='\n';
    	}else{
    		sd(x),sd(a),sd(b);
    		a=(ll)a*Inv(b)%P,b=sub(1,a);
    		p[x][0]=pls(p[x][0],(ll)p[x][1]*a%P);
    		fp(i,1,w[x])p[x][i]=((ll)p[x][i+1]*a+(ll)p[x][i]*b)%P;
    	}
    }
    fp(i,1,n){
    	tp=0;
    	fp(j,1,w[i])tp=pls(tp,(ll)j*p[i][j]%P);
    	we(tp);
    }
return Ot(),0;
}
```

---

~~出题人说这是一道NOIP中档题~~



---

## 作者：xukuan (赞：4)

首先这题时间限制可能有鬼，xjoi上时6s，这份代码在xjoi103上要5-5.2s

**本题解的推导不包括取模**

这题直接维护期望会非常难理解，由于概率非常好处理，所以维护概率

设$f_{i,j}$表示当前第i个人的血量为j的概率

转移方程只有2中情况：被打了掉血或不掉血。特别的，0血的人不会被打

$
f_{i,j}=\left\{
\begin{aligned}
f_{i,j+1}*p+f_{i,j}*(1-p),j \geq 1\\
f_{i,j+1}*p+f_{i,j},j=0\\
\end{aligned}
\right.
$

对于每一个怪而言：

期望直接用 $\sum$概率\*收益 来求

dp类似01背包的压维，倒着跑

$
dp_j=\left\{
\begin{aligned}
g_i*dp_{j-1}+(1-g_i)*dp_j,j \geq 1\\
(1-g_i)*dp_j,j=0
\end{aligned}
\right.
$

理论上可以出答案了，但跑的太慢，所以要优化。

活着就是血量不为0，概率可以直接得出

$g_i=1-f_{i,0}$

然后继续推

没人死就直接抄：当$g_i=1$时$sum_j=dp_{j+1}$

因为是在不死的人里面选，

$
sum_j=\left\{
\begin{aligned}
\frac{dp_j+sum_{j-1}*g_i}{1-g_i},j \geq 1\\
\frac{dp_j}{1-g_i},j=0\\
\end{aligned}
\right.
$

代码：
```cpp
#include<bits/stdc++.h>
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;

const ll N=2010,mod=998244353;
ll n,a[N],f[N][N],g[N],dp[N],sum[N];

inline ll read(){
    ll x=0,tmp=1;
    char ch=getchar();
    while(!isdigit(ch)){
        if(ch=='-') tmp=-1;
        ch=getchar();
    }
    while(isdigit(ch)){
        x=(x<<3)+(x<<1)+(ch^48);
        ch=getchar();
    }
    return tmp*x;
}

inline void write(ll x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    ll y=10,len=1;
    while(y<=x){
        y=(y<<3)+(y<<1);
        len++;
    }
    while(len--){
        y/=10;
        putchar(x/y+48);
        x%=y;
    }
}

inline ll ksm(ll x,ll y){
    ll ans=1;
    while(y){
        if(y&1) ans=ans*x%mod;
        x=x*x%mod;
        y>>=1;
    }
    return ans;
}

inline ll inv(ll x){
    return ksm(x,mod-2);
}

int main(){
    n=read();
    for(ll i=1; i<=n; i++){
        a[i]=read();
        f[i][a[i]]=1;
    }
    for(ll q=read(); q; q--){
        ll op=read();
        if(op==0){
            ll x=read(),fenzi=read(),fenmu=read();
            ll gailv=fenzi*inv(fenmu)%mod;
            f[x][0]=(f[x][0]+f[x][1]*gailv%mod)%mod;
            for(ll i=1; i<=a[x]; i++) f[x][i]=(f[x][i]*(mod+1-gailv)%mod+f[x][i+1]*gailv%mod)%mod;
        }
        else if(op==1){
            ll m=read();
            for(ll i=1; i<=m; i++){
                ll x=read();
                g[i]=(mod+1-f[x][0])%mod;
            }
            memset(dp,0,sizeof(dp));
            dp[0]=1;
            for(ll i=1; i<=m; i++){
                for(ll j=i; j>=0; j--){
                    if(j) dp[j]=(g[i]*dp[j-1]%mod+(mod+1-g[i])%mod*dp[j]%mod)%mod;
                    else dp[j]=(mod+1-g[i])%mod*dp[j]%mod;
                }
            }
            for(ll i=1; i<=m; i++){
                if(!g[i]){
                    putchar('0'); putchar(' ');
                    continue;
                }
                if(g[i]==1){
                    for(ll j=0; j<m; j++) sum[j]=dp[j+1];
                }
                else{
                    ll x=inv((mod+1-g[i])%mod);
                    sum[0]=dp[0]*x%mod;
                    for(ll j=1; j<m; j++) sum[j]=(dp[j]+mod-sum[j-1]*g[i]%mod)%mod*x%mod;
                }
                ll ans=0;
                for(ll j=0; j<m; j++) ans=(ans+sum[j]*inv(j+1)%mod)%mod;
                write(g[i]*ans%mod); putchar(' ');
            }
            putchar('\n');
        }
        else cout<<"FUCK "<<op<<endl;
    }
    for(ll i=1; i<=n; i++){
        ll ans=0;
        for(ll j=1; j<=a[i]; j++) ans=(ans+j*f[i][j])%mod;
        write(ans); putchar(' ');
    }
    putchar('\n');
    return 0;
}
```

---

## 作者：ZCETHAN (赞：3)

## 题意

有 $n$ 个敌方单位，每次操作会使其中某个单位有 $p$ 的概率减少 $1$ 的血量。每次询问会给出 $k$ 个敌方单位的编号，求从这些存活的敌方单位中等概率选取一个，每个敌方单位被选取的概率。

最后输出每个敌方单位的期望血量。

## Solution

小数据范围，考虑暴力维护每个敌方单位每个血量的概率。令 $dp_{i,j}$ 表示单位 $i$ 有血量 $j$ 的概率。考虑对于每次操作，有：

$$
dp_{i,j}=dp_{i,j+1}\times p+dp_{i,j}\times (1-p)
$$

这样每次操作更新是 $O(m_i)$ 的。$2\times 10^7$ 也不是不能跑。

注意在 $j=0$ 的时候，攻击会无效，所以有：

$$
dp_{i,0}=dp_{i,1}\times p+dp_{i,0}
$$

最后的期望很简单，直接暴力统计即可。

至于中间的询问，其实我们还是想知道这些人中，在某个人存活的情况下，存活多少个人的概率是多少。对于每次询问，不妨我们设 $f_{i,j}$ 表示在 $i$ 存活的情况下，有 $j$ 个人存活的概率。这样 $i$ 的答案就可以表示为：

$$
\sum_{j=1}^k \dfrac{f_{i,j}}{j}
$$

于是我们需要求出 $f_{i,j}$。暴力做可以到 $O(n^3)$。考虑优化。

我们令 $g_{i}$ 表示任意 $i$ 个人存活的概率，这东西可以 $O(n^2)$ 递推得到。我们希望从中得到 $f$。我们令 $i$ 存活的概率是 $q$，则有：

$$
g_j=f_{i,j}+f_{i,j+1}\times \dfrac{1-q}{q}
$$

就是说任意 $j$ 个人存活的概率等于 $i$ 存活的情况下 $j$ 个人存活的概率加上 $i$ 不存活的情况下，$j$ 个人存活的概率。$O(n^2)$ 跑一遍还原就可以了。

## Code

```cpp
// Problem: 
//     P4564 [CTSC2018]假面
//   
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P4564
// Memory Limit: 500 MB
// Time Limit: 2000 ms

#include<bits/stdc++.h>
#define ll long long
#define inf (1<<30)
#define INF (1ll<<60)
#define pb emplace_back
#define pii pair<int,int>
#define mkp make_pair
#define fi first
#define se second
#define all(a) a.begin(),a.end()
#define siz(a) (int)a.size()
#define clr(a) memset(a,0,sizeof(a))
#define rep(i,j,k) for(int i=(j);i<=(k);i++)
#define per(i,j,k) for(int i=(j);i>=(k);i--)
#define pt(a) cerr<<#a<<'='<<a<<' '
#define pts(a) cerr<<#a<<'='<<a<<'\n'
#define int long long
using namespace std;
const int MOD=998244353;
int ksm(int a,int p){
	int ret=1;while(p){
		if(p&1) ret=ret*a%MOD;
		a=a*a%MOD; p>>=1;
	}return ret;
}
int iv[210];
int inv(int x){
	if(x<=200){
		if(iv[x]) return iv[x];
		else return iv[x]=ksm(x,MOD-2);
	}return ksm(x,MOD-2);
}

int m[210],dp[210][110],id[210];
int g[210],f[210][210];
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	int n;cin>>n;
	rep(i,1,n) cin>>m[i],dp[i][m[i]]=1;
	int Q;cin>>Q;
	int op,u,v,k;
	while(Q--){
		cin>>op;
		if(op==0){
			cin>>k>>u>>v;
			int p=u*inv(v)%MOD,q=(1+MOD-p)%MOD;
			rep(i,0,m[k])
				if(i) dp[k][i]=(dp[k][i+1]*p%MOD+dp[k][i]*q%MOD)%MOD;
				else dp[k][i]=(dp[k][i+1]*p%MOD+dp[k][i])%MOD;
		}
		else{
			cin>>k;
			rep(i,1,k) cin>>id[i];
			memset(g,0,sizeof(g));
			memset(f,0,sizeof(f));
			g[0]=1;
			rep(i,1,k) per(j,i,0){
				g[j]=g[j]*dp[id[i]][0]%MOD;
				if(j) (g[j]+=g[j-1]*(1+MOD-dp[id[i]][0])%MOD)%=MOD;
			}rep(i,1,k){
				int q=(1+MOD-dp[id[i]][0])%MOD;
				int p=dp[id[i]][0];q=inv(q);
				if(!q) continue;
				f[i][k]=g[k];
				per(j,k-1,1) f[i][j]=(g[j]+MOD-f[i][j+1]*q%MOD*p%MOD)%MOD;
			}rep(i,1,k){
				int cur=0;
				rep(j,1,k)
					cur=(cur+f[i][j]*inv(j)%MOD)%MOD;
				cout<<cur<<' ';
			}cout<<'\n';
		}
	}
	rep(i,1,n){
		int cur=0;
		rep(j,1,m[i]) cur=(cur+j*dp[i][j]%MOD)%MOD;
		cout<<cur<<' ';
	}
	return 0;
}
```

---

## 作者：tommymio (赞：3)

借用一下下面大佬的简要题意：

- 有 $n$ 个人，第 $i$ 个人的生命值为 $a_i$。当第 $i$ 个人的生命值扣除至 $0$，第 $i$ 个人就会死，即后续操作不能再被选中。如果后续操作选中了这个人，忽略。
- $\mathrm{Operation1:id \ u \ v}$，第 $id$ 个人的生命值有 $p=\frac{u}{v}$ 的概率减 $1$。
- $\mathrm{Operation2:k \ a_1 \ a_2 \ ... \ a_k}$，在这 $k$ 个人中等概率选一个人，求其中每个人被选中的概率。
- 最终还需要输出每个人在所有操作后的期望生命值。

乍一看似乎不可做。不妨把这些问题拆解一下。

如果只有 $1$ 操作和最终输出的话，非常好实现。设 $f_{i,j}$ 为第 $i$ 个人被扣除了 $j$ 点生命值的概率。对于每次 $1$ 操作，我们暴力维护 $f_{id}$ 这一层的值。时间复杂度是 $O(\max{a_i})$ 的。具体转移为：

$$
f_{id,0}=f_{id,0}\times \left(1-\frac{u}{v}\right)
$$

$$
f_{id,j}=f_{id,j}\times \left(1-\frac{u}{v}\right)+f_{id,j-1}\times \frac{u}{v} \ (j\neq0\wedge j\neq a_i)
$$

$$
f_{id,a_{id}}=f_{id,a_{id}-1}\times \frac{u}{v}
$$

这样我们就可以处理最终输出了，对于第 $i$ 个人，他的期望生命值为 $\sum\limits_{j=0}^{a_i}f_{i,j}\times(a_i-j)$。

现在考虑加上 $2$ 操作的情况。

很自然可以想到设这样的一个东西，$g_{i,j}$ 为 $k$ 个人中，第 $i$ 个人（给出 $k$ 个人中的第 $i$ 个人，注意与之前区分）存活，除他以为有 $j$ 个人存活的概率。这个东西可以分别处理前缀和后缀然后卷积求出，时间复杂度是 $O(k^2 \log k)$ 的，最劣是 $O(n^2 \log n)$ 的，不能承受。如果骗分的话写不带 $\mathrm{NTT}$ 的暴力卷积就好（雾

观察一下，发现 $g$ 的定义事实上是在 $k$ 个人中先去除掉第 $i$ 个人的贡献。对于这一类去除某个位置的贡献，我们有两种做法，一类是预处理前缀和后缀的贡献再卷积，另一类是直接撤销这个位置的贡献。第一类已经行不通了，想想第二类。先写出求所有 $k$ 个人贡献的转移方程。设 $h_{i,j}$ 为选中的 $k$ 个人中，前 $i$ 个人中只有 $j$ 个人存活的概率，$p$ 为第 $i$ 个人存活的概率，有：

$$
h_{i,j}=h_{i-1,j}\times (1-p)+h_{i-1,j-1}\times p
$$

边界情况和 $f$ 一样推就好。把第一维滚动掉，我们发现这就是一个类似于背包的转移方程。并且我们有一个显而易见的结论，$k$ 个人的排列顺序无论如何变化，最终 $h_k$ 这一层的值都是不会变动的，从概率论的角度很好理解。通过这个结论，我们就可以把要撤销的第 $i$ 个人移到第 $k$ 个位置上，因为位置没有影响。这样我们就可以直接撤销了。逆序背包，顺序撤销，这是一个很 $\text{trivial}$ 的 $\text{trick}$。记得预处理逆元，本题卡常。

另外，值得注意的是，对于那些存活概率为 $100\%$ 的人而言，把他们的值统计至 $h$ 中会使得撤销时无法还原现场，特判一下就可以解决这个问题。

于是我们在 $O(Q\times (\max a_i+n^2)+\sum a_i)$ 的时间复杂度内解决了本题。

**Show the Code**

```cpp
#include<cstdio>
#define int ll
typedef long long ll;
const int mod=998244353;
int a[205],b[205],inv[205],g[205],f[205][205];
int tmp[205];
inline int read() {
    register int x=0,f=1;register char s=getchar();
    while(s>'9'||s<'0') {if(s=='-') f=-1;s=getchar();}
    while(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();}
    return x*f;
}
inline int pow(int x,int p) {int res=1; for(;p;p>>=1) {if(p&1) res=res*x%mod; x=x*x%mod;} return res;}
signed main() {
    int n=read();
    for(register int i=1;i<=n;++i) inv[i]=pow(i,mod-2);
    for(register int i=1;i<=n;++i) a[i]=read(),f[i][0]=1;
    int T=read();
    while(T--) {
        int op=read();
        if(op==0) {
            int id=read(),u=read(),v=read();
            for(register int j=a[id];j>=0;--j) {
                int p=u*pow(v,mod-2)%mod,invp=1-p;
                if(j!=a[id]) f[id][j]=(f[id][j]*invp+f[id][j-1]*p)%mod;
                else if(j!=0) f[id][j]=(f[id][j]+f[id][j-1]*p)%mod;
                else f[id][j]=f[id][j]*invp%mod;
            }
        }
        else {
            int k=read(),tot=0;
            for(register int i=1;i<=k;++i) b[i]=read();
            g[0]=1;
            for(register int i=1;i<=k;++i) {
                int x=b[i],p=1-f[x][a[x]],invp=f[x][a[x]];
                if(invp==0) {++tot;continue;}
                for(register int j=k;j>=1;--j) {g[j]=(g[j-1]*p+g[j]*invp)%mod;}
                g[0]=g[0]*invp%mod;
            }
            for(register int i=1;i<=k;++i) {
                int x=b[i],p=1-f[x][a[x]],invp=f[x][a[x]],invp_inv=pow(invp,mod-2),ans=0;
                if(invp==0) {
                    for(register int j=0;j<=k;++j) ans=(ans+inv[j+tot]*g[j])%mod;
                    printf("%lld ",(ans%mod+mod)%mod);
                }
                else {
                    for(register int j=0;j<=k;++j) tmp[j]=g[j];
                    tmp[0]=tmp[0]*invp_inv%mod;
                    for(register int j=1;j<=k;++j) tmp[j]=((tmp[j]-tmp[j-1]*p)%mod)*invp_inv%mod;
                    for(register int j=0;j<=k;++j) ans=(ans+(inv[j+tot+1]*tmp[j]%mod)*p%mod)%mod;
                    printf("%lld ",(ans%mod+mod)%mod);
                }
                
            } printf("\n");
            for(register int j=0;j<=k;++j) g[j]=0;
        }
    }
    for(register int i=1;i<=n;++i) {
        int ans=0;
        for(register int j=a[i];j>=0;--j) ans=(ans+f[i][j]*(a[i]-j))%mod;
        printf("%lld ",(ans%mod+mod)%mod);
    }
    printf("\n");
    return 0;
}
```




---

## 作者：Nateiru (赞：2)

### [P4564 \[CTSC2018\]假面](https://www.luogu.com.cn/problem/P4564)
首先容易看出**结界技能**对第二问敌方剩余生命值期望没有影响。

如何求出第$i$个人的剩余生命值期望？
只需要根据$E_i=\sum_{j=0}^{a_i}j×f_{i,j}$
预处理$f_{i,j}$：第$i$个人的剩余生命值为$j$的期望（$a_i$表示最初生命值）

由于每次**锁定技能**只能明确对一名敌方单位造成攻击（$p$概率击中而$q$概率不中），每次只需要$O(a_i)$的代价维护$f_{i,j}$总的时间复杂度$O(Qm)$
转移方程：$f_{i,j}=pf_{i,j+1}+qf_{i,j}$，注意$f_{i,0}=pf_{i,1}+f_{i,0}$
***
对于第二个技能，想要知道命中$u$的概率，我们需要知道除了u之外还有$j$个人存活下，不妨叫做$g_{u,j}$。

只需要把除了$u$的其他敌人$v$拿出来跑一遍背包即可（注意逆序）
$g_{u,j}=\text{alive}_v×g_{u,j-1}+\text{dead}_v×g_{u,j}$

显然$\text{alive}_v=1-f_{v,0}$：v存活下来的概率，$\text{dead}_v=f_{v,0}$死了的概率。

对于第二个技能范围的每个敌人，我们都需要预处理一下$g_{u,j}$数组，也就是$O(n^3)$的复杂度，第二个技能总时间复杂度$O(Cn^3)$，代码如下这时候我们能够拿到$70$pts，$O(Qm+Cn^3)$


```cpp
#include<cstring>
#include<iostream>
using namespace std;
using ll=long long;
constexpr ll mod=998244353;
ll qmi(ll a,ll b)
{
    ll res=1;
    while(b)
    {
        if(b&1) res=res*a%mod;
        a=a*a%mod;
        b>>=1;
    }
    return res;
}
ll inv[205],a[205],b[205];
ll f[205][105];//f[i][j]第i个人还有j滴血的概率
ll g[205];//将u那一维压缩了
int n,m;
void attack(int i,ll p)//O(qc)
{
    ll q=(1-p+mod)%mod;
    for(int j=0;j<=a[i];j++)
    {
        if(j)
            f[i][j]=(p*f[i][j+1]%mod+q*f[i][j]%mod)%mod;
        else
            f[i][j]=(p*f[i][j+1]%mod+f[i][j])%mod;
    }
}
void solve(int k)//O(n^3)
{
    for(int u=1;u<=k;u++)//枚举范围呢的每一个敌人
    {
        memset(g,0,sizeof g);g[0]=1ll;
        for(int i=1;i<=k;i++)//除了u的敌人跑一边背包
        {
            if(u==i) continue;
            
            ll alive=((1ll-f[b[i]][0])%mod+mod)%mod;
            ll dead=((1ll-alive)%mod+mod)%mod;
            for(int j=i;j>=0;j--)//逆序！
            {
                if(j) 
                    g[j]=(g[j]*dead+g[j-1]*alive%mod)%mod;
                else 
                    g[j]=g[j]*dead%mod;
            }
                
        }
        ll ans=0;
        for(int j=0;j<k;j++) ans=(ans+g[j]*inv[j+1]%mod)%mod;
        ans=ans*((1ll-f[b[u]][0])%mod+mod)%mod;
        cout<<ans<<' ';
    }
    cout<<'\n';
}
int main()
{
    ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);
    
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        inv[i]=qmi(i,mod-2);
        f[i][a[i]]=1;
    }
    cin>>m;
    while(m--)
    {
        int op;
        cin>>op;
        if(op==0)
        {
            int id;ll u,v;
            cin>>id>>u>>v;
            attack(id,1ll*u*qmi(v,mod-2)%mod);
        }
        else
        {
            int k;
            cin>>k;
            for(int i=1;i<=k;i++) cin>>b[i];
            solve(k);
        }
        
    }
    
    for(int i=1;i<=n;i++)
    {
        ll ans=0;
        for(int j=1;j<=a[i];j++)
            ans=(ans+j*f[i][j]%mod)%mod;
        cout<<ans<<' ';
    }
    return 0;
}
```
考虑优化，显然我们TLE是由于第二个操作，如果每次枚举然后跑背包似乎有些冗余。我们另设$g_j$表示$j$个人或者的概率，而用$h_{u,j}$表示除了u之外还有$j$个人存活下（也就是上面的$g_{u,j}$）有下面递推
$$g_j=\text{alive}_u×h_{u,j-1}+\text{dead}_u×h_{u,j}$$
于是有
$$h_{u,j}=\frac{g_j-\text{alive}_u×h_{u,j-1}}{\text{dead}_u}$$

于是我们只需要$O(n^2)$预处理$g_j$，然后枚举$u$线性递推求出$h_{u,j}$同样时间复杂度$O(n^2)$，那么技能二时间复杂度$O(Cn^2)$

注意$g_j=\text{alive}_u×h_{u,j-1},\text{dead}_u=0$

即$h_{u,j}=g_{j+1}$

总时间复杂度$O(Qm+Cn^2)$
```cpp
#include<cstring>
#include<iostream>
using namespace std;
using ll=long long;
constexpr ll mod=998244353;
ll qmi(ll a,ll b)
{
    ll res=1;
    while(b)
    {
        if(b&1) res=res*a%mod;
        a=a*a%mod;
        b>>=1;
    }
    return res;
}
ll inv[205],a[205],b[205];
ll f[205][105];
ll g[205],h[205];//h同样可以少一维
int n,m;
void attack(int i,ll p)//O(qc)
{
    ll q=(1-p+mod)%mod;
    for(int j=0;j<=a[i];j++)
    {
        if(j)
            f[i][j]=(p*f[i][j+1]%mod+q*f[i][j]%mod)%mod;
        else
            f[i][j]=(p*f[i][j+1]%mod+f[i][j])%mod;
    }
}
void solve(int k)
{
    memset(g,0,sizeof g);g[0]=1ll;
    for(int i=1;i<=k;i++)//预处理 g
    {
        ll alive=((1ll-f[b[i]][0])%mod+mod)%mod;
        ll dead=((1ll-alive)%mod+mod)%mod;
        for(int j=i;j>=0;j--)
        {
            if(j) 
                g[j]=(g[j]*dead+g[j-1]*alive%mod)%mod;
            else 
                g[j]=g[j]*dead%mod;
        }
            
    }
    
    for(int u=1;u<=k;u++)
    {
        ll ans=0;
        ll alive=((1ll-f[b[u]][0])%mod+mod)%mod;
        ll dead=((1ll-alive)%mod+mod)%mod;
        memset(h,0,sizeof h);
        if(alive!=1)//1-dead != 0
        {
            ll invd=qmi(dead,mod-2);
            h[0]=g[0]*invd%mod;
            for(int j=1;j<k;j++)//注意顺序！
                h[j]=(g[j]-alive*h[j-1]%mod+mod)%mod*invd%mod;
        }
        else//dead=1
        {
            for(int j=0;j<=k;j++)
                h[j]=g[j+1];
        }
        for(int j=0;j<k;j++) ans=(ans+h[j]*inv[j+1]%mod)%mod;
        ans=ans*alive%mod;
        cout<<ans<<' ';
    }
    cout<<'\n';
}
int main()
{
    ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);
    
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        inv[i]=qmi(i,mod-2);
        f[i][a[i]]=1;
    }
    cin>>m;
    while(m--)
    {
        int op;
        cin>>op;
        if(op==0)
        {
            int id;ll u,v;
            cin>>id>>u>>v;
            attack(id,1ll*u*qmi(v,mod-2)%mod);
        }
        else
        {
            int k;
            cin>>k;
            for(int i=1;i<=k;i++) cin>>b[i];
            solve(k);
        }
    }
    
    for(int i=1;i<=n;i++)
    {
        ll ans=0;
        for(int j=1;j<=a[i];j++)
            ans=(ans+j*f[i][j]%mod)%mod;
        cout<<ans<<' ';
    }
    return 0;
}
```
要加油哦~

---

## 作者：chenxia25 (赞：2)

这个 CTSC 的题竟然是我自己想出来的，incredible（

---

**[Portal]( https://www.luogu.com.cn/problem/P4564 )**

分为两个问题：求每个结界技能每个攻击对象被命中的概率，和求最终每个敌方单位的期望生命值。先考虑后者。

显然只有锁定技能能够造成伤害。我们设敌方单位 $i$ 被命中的锁定技能个数为 $x$。将式子列出来：$\mathrm E(\max(0,a_i-x))$。这个外面套了一个 $\max$，不好线性性展开。于是我们考虑通过期望的定义，求出每个取值的概率。显然取值个数是 $\mathrm O(v)$ 的，其中 $v$ 是值域大小。于是我们可以对每个 $i$ 搞一个背包：$dp_{i,j}$ 表示敌方单位 $i$ 在当前时刻生命值为 $j$ 的概率，在新加进一个锁定技能的时候更新背包的 DP 数组即可。这样一次更新是 $\mathrm O(v)$ 的，这一部分就是 $\mathrm O(Qv)$。最后统计一下答案即可。

然后考虑前一个问题。每个敌方单位被命中，首先要他自己还活着，然后根据活着的总人数来确定他在当前情况下被命中的概率。设他活着的情况下，剩下 $i$ 个人活着的概率为 $p_i$，那么总概率就是 $\sum \dfrac 1ip_i$。那么我们考虑求出每个敌方单位所对应的 $p$ 数组。

显然有一个大暴力：对于每个人都跑一遍背包（$dp0_{j}$ 表示当前不算第 $i$ 个人的情况下，考虑到当前，有 $j$ 个人活着的概率，然后转移用每个人存活的概率，这个可以通过当前 $dp$ 数组得到），这样一次背包是 $\mathrm O\!\left(n^2\right)$ 的，总复杂度就是 $\mathrm O\!\left(Cn^3\right)$，再优化掉一个 $n$ 就可以了。

我们注意到，每个人所对应的背包，是所有人减去他一个人的。那么能否先算出所有人的，再对于每个人，减去他自己这个人呢？也就是背包是否可逆呢？显然，如果要去掉的人是总背包 DP 过程中的最后一个更新它的人，那显然很好去掉，倒推一下即可。而众所周知，背包是顺序无关的，也就是你可以当作它以任意一个人结尾，那就对于每个人就可以倒推了。

讲一下倒推的方法：设更新前的 DP 数组为 $dp0$，更新后为 $dp0'$，那我们想要通过 $dp0'$ 知道 $dp0$。转移显然是
$$
dp0'_j=(1-alive_i)dp0_j+alive_idp0_{j-1}
$$
其中 $alive_i$ 是第 $i$ 个人（也就是假定的最后一个更新的人）存活的概率。那么
$$
dp0_j=\dfrac{dp0'_j-alive_idp0_{j-1}}{1-alive_i}
$$
但是这里还有一个问题：$1-alive_i$ 可能等于 $0$，也就是 $alive_i=1$。这个需要特判一下。事实上这个简单的一批，不难得到
$$
dp0_j=dp0'_{j+1}
$$
于是总复杂度 $\mathrm O\!\left(Qv+Cn^2\right)$。要注意预处理一些逆元，不然复杂度就多了个 $\log$。

**_[code]( https://www.luogu.com.cn/paste/nnz47r11 )_**

---

## 作者：541forever (赞：1)

题目不难，但细节较多。

首先考虑如何处理第一种操作的影响，发现 $m$ 并不大，可以直接暴力设 $f_{i,j}$ 表示第 $i$ 个人在此时有 $j$ 点血的概率，设此时扣血的概率为 $p$，则可以直接转移
$$f_{id,0}=f_{id,0}+f_{id,1} \times p$$
$$f_{id,i}=f_{id,i+1} \times p+f_{id,i}\times (1-p)(i \ge 1)$$

然后考虑如何处理第二种操作，我们可以根据 $f$ 数组求出每个人此时活着的概率 $p_i$，接着 dp 求出 $g_i$ 表示此时活着 $i$ 个人的概率，因为第二种操作并不多，所以每次 $O(k^2)$ 求出 $g$ 数组来足够。具体地

$$g_i=g_{i-1}\times p_i +g_i \times (1-p_i)$$

但其实总共活着多少人并不重要，我们最想知道的是在钦定一个人活着的情况下会或者多少人，但我们可以根据总共活着多少人和每个人活着的概率求出除了一个人 $i$ 活着 $j$ 个人的概率 $h_{i,j}$。具体地，我们可以把 $i$ 看作是最后一个让 $g$ 数组转移的，我们考虑把 $g$ 的转移倒着做一遍，那么若 $p_i=1$，则 $h_{i,j}=g_{j+1}$，否则
$$h_{i,j}={{g_i-h_{i,j-1}\times p_i} \over {1-p_i}}$$
有了 $h$ 数组，我们就不难求出每个人被锁定的概率了，而根据我们一开始所求得的 $f$ 数组，每个人血量的期望也可以直接算出。

[Code](https://www.luogu.com.cn/paste/e4qpdpbr)

---

## 作者：7KByte (赞：1)

期望定义：

$E=\sum p(x)v(x)$

其中$p(x)$和$v(x)$分别对应概率和代价。

所以求期望第二种方式是直接求每个代价对应的概率。

本题定义状态$f[k][i][j]$表示$k$次操作后，第$i$个人血量剩余$j$的概率。

对于每个$1$操作，我们可以找到对应的$i$并$\rm O(M)$转移。最后我们统计答案，这样第一问就解决了。空间可能开不下，滚动数组优化一下。

考虑第二问，对于每个人我们只关心他是活着或者死了，显然活着的概率为$f[id][0]$。

再定义一个状态$g[i]$，表示所有人中恰好有$i$个人活着的概率，对于每个人活着或死亡的状态分别转移即可。

但是如果我们要处理的人是$i$，则$i$必须是活着的。也就是说，$g[k]$中必须有$i$。转换一下，我们要选择$k-1$个活着的人，并且不能选择第$i$个人。

这里有两种方法。

第一种是求出背包前缀和背包后缀，然后用$NTT$优化卷积可以做到$\rm O
(N^2\log N)$。

第二种是反悔操作。因为背包是没有顺序的，所以我们可以把第i$个人看作是最后一个转移的。那么原来是倒叙转移，现在就顺序撤销即可。

```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define pre(i,a,b) for(int i=a;i>=b;i--)
#define int long long
#define N 205
#define M 200005
#define P 998244353
using namespace std;
int f[N][N],n,a[N],m,c[N],g[N],h[N],iv[M];
int Pow(int x,int y){
	int now=1;
	for(;y;y>>=1,x=x*x%P)if(y&1)now=now*x%P;
	return now;
}
signed main(){
	rep(i,1,M-5)iv[i]=Pow(i,P-2);
	scanf("%lld",&n);
	rep(i,1,n)scanf("%lld",&a[i]),f[i][a[i]]=1;
	scanf("%lld",&m);
	rep(i,1,m){
		int op;scanf("%lld",&op);
		if(!op){
			int id,u,v;scanf("%lld%lld%lld",&id,&u,&v);
			int p=u*Pow(v,P-2)%P;
			f[id][0]=(f[id][0]+f[id][1]*p)%P;
			rep(j,1,a[id])f[id][j]=(f[id][j+1]*p+f[id][j]*(1-p+P))%P;
		}
		else{
			int k;scanf("%lld",&k);
			rep(j,1,k)scanf("%lld",&c[j]);
			memset(g,0,sizeof(g));
			g[0]=1;int sum=0;
			rep(j,1,k){
				int pa=(P+1-f[c[j]][0])%P;
				//cout<<pa<<" ";
				if(!pa)continue;
				if(pa==1)sum++;
				else{
					pre(w,k,1)g[w]=(g[w-1]*pa+g[w]*(P+1-pa))%P;
					g[0]=g[0]*(P+1-pa)%P;
				}
			}
			//printf("ss ");rep(j,0,k)printf("%lld ",g[j]);putchar('\n');
			rep(j,1,k){
				int pa=(P+1-f[c[j]][0])%P,ans=0;
				if(!pa){printf("0 ");continue;}
				if(pa==1){
					rep(w,0,k)ans+=pa*g[w]%P*iv[w+sum]%P;
				}
				else{
					rep(w,0,k)h[w]=g[w];
					int inv=Pow(P+1-pa,P-2);
					h[0]=h[0]*inv%P;rep(w,1,k)h[w]=((h[w]+P-h[w-1]*pa%P)*inv%P+P)%P;
					rep(w,0,k)ans+=pa*h[w]%P*iv[w+sum+1]%P;
				}
				printf("%lld ",ans%P);
			}
			putchar('\n');
		}
	}
	rep(i,1,n){
		int sum=0;
		rep(j,0,a[i])sum+=f[i][j]*j%P;
		printf("%lld ",sum%P);
	}putchar('\n');
	return 0;
} 
```

---


# [FJOI2016] 建筑师

## 题目描述

小 Z 是一个很有名的建筑师，有一天他接到了一个很奇怪的任务：在数轴上建 $n$ 个建筑，每个建筑的高度是 $1$ 到 $n$ 之间的一个整数。

小 Z 有很严重的强迫症，他不喜欢有两个建筑的高度相同。另外小 Z 觉得如果从最左边（所有建筑都在右边）看能看到 $A$ 个建筑，从最右边（所有建筑都在左边）看能看到 $B$ 个建筑，这样的建筑群有着独特的美感。现在，小 Z 想知道满足上述所有条件的建筑方案有多少种？

如果建筑 $i$ 的左(右)边没有任何建造比它高，则建筑 $i$ 可以从左(右)边看到。两种方案不同，当且仅当存在某个建筑在两种方案下的高度不同。

## 说明/提示

对于 $10 \%$ 的数据 ： $1 \leq n \leq 10$。

对于 $20 \%$ 的数据 ： $1 \leq n \leq 100$。

对于 $40 \%$ 的数据 ： $1 \leq n \leq 50000, \ 1 \leq T \leq 5$。

对于 $100 \%$ 的数据 ：$1 \leq n \leq 50000, \ 1 \leq A, B \leq 100, \ 1 \leq T \leq 200000$。

## 样例 #1

### 输入

```
2
3 2 2
3 1 2```

### 输出

```
2
1```

# 题解

## 作者：newbiechd (赞：24)

[Blog](https://www.cnblogs.com/cj-chd)  
早期作品，不喜轻喷。  
这应该是斯特林数和组合数的基本应用  
我一开始写的题解没有关于斯特林数和组合数的介绍，结果没通过审核，现在加上：  
##### 组合数：  
大家应该都熟悉它的表达式，但我们这里使用它的递推式会更加方便，下面推导组合数的递推式。设$\binom{n}{m}$表示在$n$个元素中取$m$个的方案数，那么如果我们考虑第$n$个元素取或不取：取的情况就要在剩下的$n-1$个元素中取$m-1$个；不取的情况就要在剩下的$n-1$个元素中取$m$个。由此得到递推式：  
    $\binom{n}{m}=\binom{n-1}{m-1}+\binom{n-1}{m}$
##### 斯特林数：  
准确地说是第一类斯特林数，通常用中括号表示，形如$[^{\,n}_{m}]$，表示$n$个人坐$m$张圆桌（没有空桌）的方案个数，我们也只需要考虑递推式。考虑第$n$个人单独坐一张桌子或坐到已经有人的桌子上：如果单独坐一张桌子，前面的$n-1$就要坐$m-1$张桌子；如果坐到已经有人的桌子上，就先让$n-1$个人坐$m$张桌子，第$n$个人可以坐到之前$n-1$个人中任意一个人的左边（其实说右边也无所谓，因为人们坐的是圆桌，这样考虑是为了不重不漏地包含所有的情况）  
这样我们就可以得到递推式：  
    $[^{\,n}_{m}]=[^{\,n-1}_{m-1}]+(n-1)*[^{n-1}_{\,\,\,m}]$  
###### 下面进入正题：  
首先，高度为$n$的建筑是肯定不会被挡住的，可以把它作为一个分水岭，在它左边的被左边的建筑挡住，在它右边的被右边的建筑挡住。  
由此我们可以把所有的建筑分成$A+B-1$个部分，每个部分由这个部分最高的建筑和被他所挡住的建筑组成，高$n$的建筑单独构成一个部分。  
那么我们就可以把除了$n$以外的$n-1$个建筑放到$A+B-2$个圆桌上（$n$独坐一个桌），这时就是一个斯特林数。  
对于每个圆桌上的建筑，构成了一个圆排列，但由于必须有一个最高的建筑挡住其他的建筑，这个圆排列的起始端就确定了，可以不重不漏地代表一个之前提到的部分。  
对于每一个这样的部分，我们只需考虑它是放在$n$的左边还是右边，因此答案再乘上一个组合数就可以了。  
答案就是：  
    $[^{\,\,\,\,\,\,n-1}_{A+B-2}]*\binom{A+B-2}{A-1}$
（中括号表示斯特林数）  
我们只需要利用递推式，就可以$O(A*n)$的求出我们所需的斯特林数，$O(A^2)$的求出需要的组合数。
上代码：
```
#include<cstdio>
#define R register
#define L long long
#define S 50000
#define N 200
using namespace std;
const int mod=1e9+7;
L s[S+10][N+10],c[N+10][N+10];
inline int read(){
	R int f=0;	R char ch=getchar();
	while(ch<48||ch>57) ch=getchar();
	while(ch>47&&ch<58) f=(f<<3)+(f<<1)+(ch^48),ch=getchar();
	return f;
}
int main(){
	R int t=read(),n,a,b,i,j;
	s[0][0]=s[1][1]=1;
	for(i=2;i<=S;++i) s[i][1]=s[i-1][1]*(i-1);
	for(i=0;i<=N;++i) c[i][0]=1;
	for(i=2;i<=S;++i)
		for(j=1;j<=N&&j<=i;++j)
			s[i][j]=(s[i-1][j-1]+s[i-1][j]*(i-1))%mod;//斯特林数递推式
	for(i=1;i<=N;++i)
		for(j=1;j<=N>>1&&j<=i;++j)
			c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;//组合数递推式
	while(t--){
		n=read(),a=read(),b=read();
		printf("%lld\n",s[n-1][a+b-2]*c[a+b-2][a-1]%mod);
	}
	return 0;
}
```  
我在文中用的斯特林数（中括号）是靠上标下标表示的，效果可能不太好，如果有哪位大佬知道怎么打这种中括号，请在评论区里留言，谢谢！

---

## 作者：PigAunt (赞：11)

# P4609 [FJOI2016]建筑师

根据题意，最终建筑群的形态大概是这个样子：

![an example of the buildings](https://cdn.luogu.com.cn/upload/image_hosting/j0ebghnm.png)

中间一定是高度为 $n$ 的建筑（紫色），两边都能看到它；左边的蓝色建筑和右边的浅黄色建筑是可以看到的。

除了最高的建筑，我们发现其他可以看到的建筑一定是若干个建筑中最高的一个，放在最左边或最右边。我们把一个可以被看到的建筑和被它挡住的建筑视为一组，那么总共需要分成 $A + B - 2$ 组。

因为每一组除了最高的建筑，是可以任意排列的，此时把每一组视为一个 **圆排列**（最高的那个建筑一定会被提到最左边或最右边，不能计算它在序列中相对位置不变的情况，下图三种情况只能算一种）。

![three same conditions](https://cdn.luogu.com.cn/upload/image_hosting/n529o6lp.png)

那么划分出 $A + B - 2$ 组的方案书就是一个 **第一类斯特林数**，共有 $\begin{bmatrix} n - 1 \\ A + B - 2 \end{bmatrix}$ 种。

现在我们来考虑每一组放在左边还是右边。实际上，每一组可以任意放置，最后处理时只需要将左右边按每组最高建筑物高度升序或降序排序，而排序的方案是唯一的。因此，分配各组建筑物的方案数有 $\begin{pmatrix} A + B - 2 \\ A - 1 \end{pmatrix}$ 种。

根据以上分析，答案为 $\begin{bmatrix} n - 1 \\ A + B - 2 \end{bmatrix} \times \begin{pmatrix} A + B - 2 \\ A - 1 \end{pmatrix}$。

计算的时候可以预处理第一类斯特林数和组合数，时间复杂度 $O(n(A + B) + \log_2(10 ^ 9 + 7) n + T)$（个人习惯预处理阶乘及其逆元求组合数，快速幂求逆元）。

参考代码：
```cpp
#include <iostream>

const int N = 50000, K = 200, MOD = 1e9 + 7;

int n, a, b;
int s[N + 5][K + 5], fac[K + 5], invFac[K + 5];

int FastPow(int x, int k)
{
    int res = 1;
    while (k > 0)
    {
        if (k & 1)
            res = (long long)res * x % MOD;
        x = (long long)x * x % MOD;
        k >>= 1;
    }
    return res;
}

void Init()
{
    // 预处理第一类斯特林数
    s[0][0] = 1;
    for (int i = 1; i <= N; i++)
        for (int j = 1; j <= K; j++)
            s[i][j] = ((long long)s[i - 1][j - 1] + (long long)(i - 1) * s[i - 1][j] % MOD) % MOD;
    
    // 预处理阶乘及其逆元
    fac[0] = 1;
    invFac[0] = 1;
    for (int i = 1; i <= K; i++)
    {
        fac[i] = (long long)fac[i - 1] * i % MOD;
        invFac[i] = FastPow(fac[i], MOD - 2);
    }
}

int C(int p, int q)
{
    if (p < q)
        return 0;
    return (long long)((long long)fac[p] * invFac[q] % MOD) * invFac[p - q] % MOD;
}

int main()
{
    int T;
    std::cin >> T;
    Init();
    for (int test = 1; test <= T; test++)
    {
        std::cin >> n >> a >> b;
        std::cout << (long long)s[n - 1][a + b - 2] * C(a + b - 2, a - 1) % MOD << std::endl;
    }
    return 0;
}
```

---

## 作者：星沐 (赞：11)

## 这是一道组合数学题
#### 首先让我们来了解组合数学的基本公式

基本公式
$\frac{}{}$
$A_n^{m}$=$\frac{n!}{(n-m)!}$;

$\frac{}{}$
$C_n^{m}$=$\frac{A_n^{m}}{m!}$=$\frac{n!}{m!(n-m)!}$;
##### 但对于解这道题还远远不够
##### 我们必须知道斯特林数[Stirling数](https://blog.csdn.net/u011815404/article/details/80083954)
##### 和圆排列[圆排列](https://baike.baidu.com/item/%E5%9C%86%E6%8E%92%E5%88%97/6775234?fr=aladdin)


------------

### 解此题的第一类斯特林数公式
### s(n,m)=s(n-1,m-1)+s(n-1,m)*(n-1);
### 组合推导式
### c(n,m)=c(n-1,m)+c(n-1,m-1);用基本公式可推导。推导略。


------------

#### 这道题还需加些优化，不然会超时。于是先判断数据范围，再暴力预处理斯特林数和组合数就可以O(1)询问了(感谢叶学长的话）.此题不可递归，只能递推过。然后再记得开long long，有许多变量会爆int。


------------


#### 思路：
##### 把最高的楼k当做分水岭，剩下的部分，从左边看到的是前缀max，从右侧看到的是后缀max。（感谢叶学长），左边除去最高楼k有A—1个，右边除去最高楼k有B—1个，然后分成A+B-2的圆排列，A+B-2每栋楼可放左边也可放右边，再组合一下

##### （引用叶学长的话说，剩下的A+B-2个，先决定放在n的左边还是右边。然后，将每个圆排列的将最大值钦定为所在方向(左或右)上的第一个，并以此为关键字将圆排列排序后放置。）

------------

### 正解如下
```
#include<bits/stdc++.h>
using namespace std;
int t;
int n,A,B;
const long long mod=1e9+7;
long long s[50001][205],c[201][205]; //做题先看数据范围.
//1<=n<=50000,1<=A,B<=100,1<=T<=200000;

int main()
{
    scanf("%d",&t);
    
    s[0][0]=1;//边界条件从0开始，这是个坑点，不然会wa1、9。10数据点，因为我错过。
    
    //预处理如下
    for(int i=1;i<=50000;++i)//第一类斯特林数公式
    {
        for(int j=1;j<=200;++j)
        {
            s[i][j]=((s[i-1][j-1]%mod+s[i-1][j]%mod*(i-1)%mod)%mod)%mod;
        }
    }
    c[0][0]=1;
    
    for(int i=1;i<=200;++i)//组合推导公式
    {
        c[i][0]=1;
        for(int j=1;j<=i;++j)
        c[i][j]=(c[i-1][j]%mod+c[i-1][j-1]%mod)%mod;
    }
    //预处理如上，记得每步都要取模。
    
    while(t)
    {
        scanf("%d%d%d",&n,&A,&B);
        cout<<(s[n-1][A+B-2]%mod*c[A+B-2][A-1]%mod)%mod<<endl;
        t--;
    }
    return 0;
}
```



---

## 作者：zyzzyzzyzzyz (赞：8)

# 一道有趣的组合数学题

   ~~这道题其实挺水的~~至少没有黑题难度（滑稽 只要学过点组合数学就没太大问题。不过思路还是比较巧妙，值得一做。

讲思路吧。

题意如图：（建筑编号从左到右依次排列）
![](https://cdn.luogu.com.cn/upload/pic/35330.png)

解释一下,画红框的是表示这个红框内的建筑都由一个最高建筑“代表”。比如从左看,$1$号建筑挡住了$2,3$号建筑，直到$4$号建筑比$1$号高,$4$号建筑再成为下一群建筑的代表。

那么给定从最左边看能看到$A$个建筑，从最右边看能看到$B$个建筑，如何求方案数呢？

接下来就是本题的核心了。

我们会发现，当一群数量为$k$的建筑的“代表”确定后，除去代表的剩下$k-1$ 个建筑就可以随意排列，那么就有$(k-1)!$ 种方案，那么就等价于这$k$个建筑的圆排列。除去整个序列中最高的那个建筑，左边看有$A-1$ 群建筑，右边看有$B-1$ 群建筑。总共有$A+B-2$ 群建筑，那么也就有$A+B-2$ 个圆排列。
然后。。。有没有想到第一类斯特林数！在这题中就是$n$ 个人，$A+B-2$ 张桌子。然后你再想，在总共$A+B-2$ 群建筑中选$A-1$ 群放到最高建筑的左边，不就有$C_{A+B-2}^{A-1}$ 种方案吗！所以总方案是$C_{A+B-2}^{A-1}*S_{n-1}^{A+B-2}$

优秀的$O(1)$询问。

$C$和$S$预处理一下就珂以辣！

你问我什么是斯特林数？出门转百度or组合数学~~其实是我懒得写了~~



------------


## 上代码：
```cpp
#include<bits/stdc++.h>
#define mod 1000000007
using namespace std;
int T,n,a,b;
long long s[50002][202],c[102][202];//要开long long别问我怎么知道的
inline int rd(){//辣鸡快读，大佬勿喷
	int ans=0,flag=1;
	char ch=getchar();
	while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
	if(ch=='-')flag=-1,ch=getchar();
	while(ch>='0'&&ch<='9')ans=ans*10+ch-48,ch=getchar();
	return ans*flag;
}
int main(){
	T=rd();
	for(register int i=0;i<=200;i++){
		c[i][0]=1;
	}
	for(register int i=1;i<=200;i++){
		for(register int j=1;j<=i;j++){
			c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;//记得取模
		}
	}
	memset(s,0,sizeof(s));
	s[0][0]=1;
	for(register int i=1;i<=5e4;i++){
		for(register int j=1;j<=200;j++){
			s[i][j]=(s[i-1][j-1]%mod+s[i-1][j]*(i-1)%mod)%mod;
		}
	}
	while(T--){
		n=rd(),a=rd(),b=rd();
		printf("%lld\n",(c[a+b-2][a-1]*s[n-1][a+b-2])%mod);
	}
	return 0;
}

```
~~切黑题，啦啦啦~~



---

## 作者：Prean (赞：4)

题意简单明确（

很容易知道最高的位置一定是左边能看到最高的和右边能看到最高的。于是我们考虑一个 dp：

设 $ dp[n][A][B] $ 表示长度为 $ n $ 的排列，左边有 $ A $ 个 balabala，右边有 $ B $ 个 balabala。

我们考虑每次令整个排列的元素全部加一，然后插入一个 $ 1 $。

很明显，如果 $ 1 $ 插在最左边，会令 $ A+1 $，如果插在最右边会令 $ B+1 $，否则都不变。

于是得到了递推方程：
$$ dp[n][A][B]=dp[n-1][A-1][B]+dp[n-1][A][B-1]+(n-2) \times dp[n-1][A][B] $$
这样会得到 20pts 的好成绩。吸口氧不知道能不能跑快点儿。

观察 dp 的递推式，发现其存在组合意义：从 $ (1,1,1) $ 到 $ (n,A,B) $，令 $ n+1 $ 会使 $ prod $ 乘上一个 $ n-1 $ 。问所有路径的权值之和。

所以相当于从 $ (1,n] $ 中选 $ A+B-2 $ 个位置，其中 $ A-1 $ 个位置为 $ 0 $，$ B-1 $ 个位置为 $ 1 $，剩下的为下标减去 $ 2 $。

于是问题变成了从 $ [0,n-2] $ 中选择 $ A+B-2 $ 个数删掉，所有方案剩下数之积之和。

从 $ n $ 个数中选择 $ m $ 个数删掉，似乎是经典的背包问题。

设 $ f[n][m] $ 为 $ [0,n-2] $ 中删掉 $ m $ 个数的积之和。

然后你发现 $ f[1][1] $ 的定义出现了问题，于是重新设，设为 $ [0,n-1] $，最后把 $ f[n][A+B-2] $ 改成 $ f[n-1][A+B-2] $ 就行。

这里的递推式为 $ f[n][m]=f[n-1][m] \times (n-1)+f[n-1][m-1] $。

然后我们需要从 $ A+B-2 $ 中选择 $ A-1 $ 个位置令其为 $ 1 $，剩下的位置为 $ 0 $。

所以答案就是 $ f[n-1][A+B-2] \times \binom {A+B-2} {A-1} $。

写完题解后翻了一圈题解区，咋全是斯特林数，然后发现自己的 $ f $ 就是斯特林数/qd
```cpp
#include<cstdio>
#include<cctype>
typedef unsigned ui;
const ui M=2e5+5,mod=1e9+7;
ui T,n[M],A[M],B[M],C[205][205],f[50005][205];
inline ui Add(const ui&a,const ui&b){
	return a+b>=mod?a+b-mod:a+b;
}
inline ui read(){
	ui n(0);char s;while(!isdigit(s=getchar()));
	while(n=n*10+(s&15),isdigit(s=getchar()));return n;
}
inline void write(ui n){
	static char s[10];ui top(0);
	while(s[++top]=n%10^48,n/=10);
	while(putchar(s[top]),--top);
}
signed main(){
	ui i,j,mx(0);T=read();f[0][0]=C[0][0]=1;
	for(i=1;i<=T;++i)n[i]=read(),A[i]=read(),B[i]=read(),n[i]>mx&&(mx=n[i]);
	for(i=1;i<=mx;++i)for(j=1;j<=i&&j<=200;++j)f[i][j]=(f[i-1][j]*(i-1ull)+f[i-1][j-1])%mod;
	for(i=1;i<=200;++i)for(C[i][0]=1,j=1;j<=200;++j)C[i][j]=Add(C[i-1][j],C[i-1][j-1]);
	for(i=1;i<=T;++i)write(1ull*f[n[i]-1][A[i]+B[i]-2]*C[A[i]+B[i]-2][A[i]-1]%mod),putchar(10);
}
```

---

## 作者：SamariumPhosphide (赞：4)

首先可以考虑最高的建筑，它无论放在哪里都是可以看见并且挡住后面的所有建筑。所以从左面能够看见的建筑都是不在最高建筑的右面，从右面能够看到的建筑都不在最高建筑的左面。因此可以将其作为一个分割点。

对于分割点左面的建筑，可以将**每个可以看到的建筑与其从左面看挡住的建筑**合并为一个块；对于右面的建筑，同理将每个点与它从右面看挡住的建筑合并为一个块。那么由于总共有 $a + b -1$ 个建筑可以被看到，因此一共有 $a+b-2$ 块。

对于每一块，如果它在左面/右面，那么它最高的建筑必须放在右面/左面，其它建筑可以没有顺序，也就是**固定了一个建筑，其它的可以重排列**。这其实就是一个环的重排列问题。同时，注意到这些块中的建筑总个数为 $n-1$，所以本题就可以简化为：将 $n-1$ 个较矮建筑分为 $a+b-2$ 个环，一部分环置于最高建筑的左面，一部分置于最高建筑的右面，每个环内部可以重排列。那么答案就是 $\begin{bmatrix} n - 1 \\ a + b - 2 \end{bmatrix} * \begin{pmatrix}a+b-2\\a - 1\end{pmatrix}$.

可以通过预处理第一类斯特林数以及阶乘可以快速计算答案。

由于这道题目中的 $a+b-2$ 的大小只有 $200$ 因此直接递推斯特林数即可。

最后贴上无注释代码。

[Code here](https://www.luogu.com.cn/paste/qipwl6zv)



---

## 作者：nofall (赞：4)

### $40$分

乱搞，$DP$

### $100$分

法$1$

我们可以用$40$分的做法打一张表，然后找找规律就发现$ans=C^{A+1}_{A+B-2} *S^{A+B-2}_{n-1}$了。

啥？你说你不会$Stirling$数？

出门左转具体数学，~~包教包会~~

法$2$

~~我们理性分析一下~~

我们可以先挑出最高的位置，直接丢到一边去。

于是就变成变为在一个$n$层的分层图上，每次往下走一层，选择$A+1$或$B+1$或不变。

有$3$种边

第$1$,$2$种边都是$1$条，第$3$种边由$n - 2$条递减到$0$条。

设$f_{i,j}$为从后往前推到第$i$层，选了$j$条改变$A$,$B$的边，选边的方案数。

于是我们就有以下递推式

$f_{i,j}=(i-1)*f_{i-1,j}+f_{i-1,j-1}$

于是
$ans=C^{A+1}_{A+B-2}*f_{n-1,A+B-2}$

然后你就会发现$f$的递推式和$Stirling$数一模一样....

我们预处理一下组合数$C$和$f$就可以通过此题了

代码：

```cpp
#include <iostream>
#include <stdio.h>
#define reg register
#define MAXN 50010
#define mod_v 1000000007

using namespace std;

int T, n, A, B, C[210][110], S[MAXN][210];

int main() {
	C[0][0] = 1;
	for(reg int i = 1; i <= 200; ++i) {
		C[i][0] = 1;
		for(reg int j = 1; j <= i && j <= 100; ++j) C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod_v;
	}
	S[0][0] = 1;
	for(reg int i = 1; i <= MAXN - 10; ++i) { for(reg int j = 1; j < i && j <= 200; ++j) S[i][j] = (S[i - 1][j - 1] + 1ll * (i - 1) * S[i - 1][j]) % mod_v; if(i <= 200) S[i][i] = 1; }
	cin >> T;
	while(T--) {
		cin >> n >> A >> B;
		cout << (1ll * C[A + B - 2][A - 1] * S[n - 1][A + B - 2] % mod_v) << endl;
	}
	return 0;
}
```

---

## 作者：Fading (赞：3)

这是一道$Owen$两个月前就切的题目，然后他给我推荐~~我到现在才做~~，先$orz$一发$Owen\% \% \%$

~~如果不知道这道题是第一类斯特林数根本想不到~~

我们先分析一波，相当于我们要求排列数量，满足前缀最大值有$A$种，后缀最大值有$B$种。

### 以最大数为界

可以考虑最大的数，显然这个数一定被算入答案。

我们以这个最大数为界，维护$A+B-2$个连通块。

连通块是什么意思呢？？？

就是一个数列，满足第一个数大于其他数。

比如

```
4 1 2 3
4 3 2 1
4 2 1 3
4 1 3 2
4 2 3 1
4 3 1 2
```

然后我们把连通块分到两边，左边$A-1$个块，右边$B-1$个块，就好了。

由于左边的块一定是按照最大数从小到大排序（右边从大到小）的，所以划分的方案数是$C_{A+B-2}^{A-1}$

那么怎么求出把一个排列划分成$A+B-2$个连通块的方案数呢？

### 连通块$\Leftrightarrow$[圆排列](https://baike.baidu.com/item/%E5%9C%86%E6%8E%92%E5%88%97)

这是为什么呢？

考虑一个圆排列，从最大数处剪开，就是一个连通块。

比如
```
2 1 4
2 4 1
```

是两个圆排列

剪开后就是

```
4 2 1
4 1 2
```

可以感性理解一下。

所以划分的方案数，就是第一类斯特林数！！！

如果你不知到第一类斯特林数，可以看看我的[组合数学的一些小知识总结](https://www.luogu.org/blog/wohaocaia/zu-ge-shuo-xue-di-yi-suo-xiao-zhi-shi-zong-jie-wei-wan-post)才刚开始写，未完待续，大佬轻喷。

答案就是($s$是第一类斯特林数)

$$s_{n-1}^{A+B-2}C_{A+B-2}^{A-1}$$

左边是把$n-1$个数（除了最大数）分成$A+B-2$个连通块的方案数，右边是把连通块分配给左右两边的方案数。

所以预处理组合数和第一类斯特林数就好啦！

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ljc 1000000007
ll S[51001][303],C[303][303],T,n,a,b;
int main(){
    C[0][0]=1;
    for (int i=1;i<=202;i++){
        C[i][0]=1;
        for (int j=1;j<=i;j++){
            C[i][j]=(C[i-1][j-1]+C[i-1][j])%ljc;
        }
    }
    S[0][0]=1;
    for (int i=1;i<=50000;i++){
        for (int j=1;j<=201;j++){
            S[i][j]=(S[i-1][j-1]+(i-1)*S[i-1][j]%ljc)%ljc;
        }
    }
    cin>>T;
    while (T--){
        scanf("%lld%lld%lld",&n,&a,&b);
        printf("%lld\n",S[n-1][a+b-2]*C[a+b-2][a-1]%ljc);
    }
    return 0;
}
```

---

## 作者：jacky567 (赞：1)

显然，这个建筑群一定会呈现这个样子：

![建筑](https://img-blog.csdnimg.cn/20200819200904457.png)

其中，红色的代表一栋建筑，黑色的框代表一个建筑块（？？？），填充为红色的建筑高为$n$

去掉这个最高的建筑，剩下的建筑就一定被分成了$A+B-2$个块，其中左边有$A-1$个，右边有$B-1$个

这是因为每个建筑块有且仅有一个建筑能被看见（这是显然的吧……感性理解一下）

研究一下每一个建筑块会发现，对于一个一共有$k$个建筑的建筑块，当最高的建筑已经被选出时，这个建筑块一共有$(k-1)!$种方案

这让我们想到了单独一个环的排列也是$(k-1)!$种！

所以这岂不是第一类斯特林数？（不会斯特林数的[戳这里](https://www.luogu.com.cn/blog/jacky0705/stirling-number)）

最后，我们就会知道，答案是$\binom{A+B-2}{A-1}\begin{bmatrix}n-1\\A+B-2\end{bmatrix}$

附上代码：
```cpp
#include<iostream>
using namespace std;
int n,a,b,MOD=1e9+7,s[50010][210],c[210][210];
int main()
{
    s[0][0]=c[0][0]=1;
    for(int i=1;i<=50000;i++) for(int j=1;j<=min(i,200);j++) s[i][j]=(1ll*s[i-1][j]*(i-1)%MOD+s[i-1][j-1])%MOD;
    for(int i=1;i<=200;i++){
        c[i][0]=c[i][i]=1;
        for(int j=1;j<i;j++) c[i][j]=(c[i-1][j]+c[i-1][j-1])%MOD;
    }
    int T;
    cin>>T;
	while(T--) cin>>n>>a>>b,cout<<1ll*s[n-1][a+b-2]*c[a+b-2][a-1]%MOD<<endl;
}
```

---

## 作者：何俞均 (赞：0)

广告：食用[$blog$](https://www.cnblogs.com/heyujun/p/10278955.html)体验更佳

![img](https://img-blog.csdn.net/20170303143216891?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvVGhlX3VzZWxlc3M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

(图片来源于网络)

我们将每个柱子和他右边的省略号看作一个集合

则图中共有$a+b-2$个集合

而原来的元素中有$n-1$个(除去最后一个)

考虑第一类斯特林数的意义:

从$n$个元素选出$m$个有序圆圈的方案数

我们将圆圈从中间最大处剪开则可以满足要求

则我们有$S(n-1,a+b-2)$种选法

因为要保证从左看有$a$个

所以要乘上$C(a+b-2,a-1)$

$\therefore Ans=C(a+b-2,a-1)\centerdot S(n-1,a+b-2)$

代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;

inline int gi() {
    register int data = 0, w = 1;
    register char ch = 0;
    while (ch != '-' && (ch > '9' || ch < '0')) ch = getchar();
    if (ch == '-') w = -1 , ch = getchar();
    while (ch >= '0' && ch <= '9') data = data * 10 + (ch ^ 48), ch = getchar();
    return w * data;
}
#define M 1000000007
#define MAX_N 50005
#define MAX_A 105
int N, A, B;
int C[MAX_A * 2][MAX_A * 2], S[MAX_N][MAX_A * 2];

int main () {
	for (int i = 0; i <= 200; i++) S[i][i] = 1;
	for (int i = 2; i < 50000; i++)
		for (int j = 1; j <= min(i, 200); j++)
			S[i][j] = (1ll * (i - 1) * S[i - 1][j] % M + S[i - 1][j - 1]) % M;
	for (int i = 0; i <= 200; i++) C[i][i] = C[i][0] = 1;
	for (int i = 1; i <= 200; i++)
		for (int j = 1; j < i; j++)
			C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % M;
	int T = gi();
	while (T--) {
		N = gi(), A = gi(), B = gi();
		printf("%d\n", 1ll * S[N - 1][A + B - 2] * C[A + B - 2][A - 1] % M); 
	}
	return 0; 
}
```

---


# [IOI 2000] 邮局 加强版

## 题目描述

高速公路旁边有一些村庄。高速公路表示为整数轴，每个村庄的位置用单个整数坐标标识。没有两个在同样地方的村庄。两个位置之间的距离是其整数坐标差的绝对值。

邮局将建在一些，但不一定是所有的村庄中。为了建立邮局，应选择他们建造的位置，使每个村庄与其最近的邮局之间的距离总和最小。

你要编写一个程序，已知村庄的位置和邮局的数量，计算每个村庄和最近的邮局之间所有距离的最小可能的总和。

## 说明/提示

对于 $40\%$ 的数据，$V \leq 300$。

对于 $100\%$ 的数据，$1 \leq P \leq 300$，$P \leq V  \leq 3000$，$1 \leq $ 村庄位置 $\leq 10000$。

## 样例 #1

### 输入

```
10 5 
1 2 3 6 7 9 11 22 44 50```

### 输出

```
9```

# 题解

## 作者：HoshiuZ (赞：112)

### 思路

首先将坐标排个序。

定义$dp[i][j]$表示前$i$个村庄放$j$个邮局的前$i$个村庄的最小距离总和，$w(i,j)$表示村庄区间$[i,j]$内放一个村庄时该区间的最小距离总和。

易得
$$
dp[i][j]=\min\{dp[k][j-1]+w(k+1,i)\},k\in[0,i)
$$
那么关键就在于$w(k+1,i)$的处理了。

基本的数学知识，若村庄数为奇数，放中位数处距离和最小。若村庄为偶数，放中间两个村庄之间任意一处均可。

于是便可得一个$O(PV^3)$的算法。

```cpp
#include<bits/stdc++.h>
#define MAXN 3010
#define N 310

using namespace std;

int V,P,X[MAXN],dp[MAXN][N];

int w(int l,int r) {
	int mid=l+r>>1,ans=0;
	for(int i=l;i<mid;i++) ans+=X[mid]-X[i];
	for(int i=mid+1;i<=r;i++) ans+=X[i]-X[mid];
	return ans;
}

int main() {
	cin>>V>>P;
	for(int i=1;i<=V;i++) cin>>X[i];
	
	sort(X+1,X+V+1);
	memset(dp,0x3f,sizeof(dp));
	dp[0][0]=0;
	for(int j=1;j<=P;j++) {
		for(int i=1;i<=V;i++) {
			for(int k=0;k<i;k++) {
				dp[i][j]=min(dp[k][j-1]+w(k+1,i),dp[i][j]);
			}
		}
	}

	cout<<dp[V][P]<<endl;
	
	return 0;
}
```

再想想，可以提前预处理出$w$，其实这个$w$是可以$O(V^2)$递推出来的，根据放置一个邮局，邮局位置总是在中位数处，便可推得
$$
w[l][r]=w[l][r-1]+X[r]-X[\lfloor\frac{l+r}{2}\rfloor]
$$
于是又可以得到一个$O(PV^2)$的算法。

```cpp
#include<bits/stdc++.h>
#define MAXN 3010
#define N 310

using namespace std;

int V,P,X[MAXN],dp[MAXN][N],w[MAXN][MAXN];

void init() {
	for(int l=1;l<=V;l++) {
		w[l][l]=0;
		for(int r=l+1;r<=V;r++) {
			w[l][r]=w[l][r-1]+X[r]-X[l+r>>1];
		}
	}
}

int main() {
	cin>>V>>P;
	for(int i=1;i<=V;i++) cin>>X[i];
	
	init();
	sort(X+1,X+V+1);
	memset(dp,0x3f,sizeof(dp));
	dp[0][0]=0;
	for(int j=1;j<=P;j++) {
		for(int i=1;i<=V;i++) {
			for(int k=0;k<i;k++) {
				dp[i][j]=min(dp[k][j-1]+w[k+1][i],dp[i][j]);
			}
		}
	}

	cout<<dp[V][P]<<endl;
	
	return 0;
}
```

其实$w$是满足四边形不等式的。

由上面$w$的递推式，可得$w[l][r+1]-w[l][r]=X[r+1]-X[\lfloor\frac{l+r+1}{2}\rfloor]\ $①

那么$w[l+1][r+1]-w[l+1][r]=X[r+1]-X[\lfloor\frac{l+r+2}{2}\rfloor]\ $②

用①$-$②，得
$$
X[r+1]-X[\lfloor\frac{l+r+1}{2}\rfloor]-(X[r+1]-X[\lfloor\frac{l+r+2}{2}\rfloor])=X[\lfloor\frac{l+r+2}{2}\rfloor]-X[\lfloor\frac{l+r+1}{2}\rfloor]
$$
$X$坐标递增，则$X[\lfloor\frac{l+r+2}{2}\rfloor]-X[\lfloor\frac{l+r+1}{2}\rfloor]\ge 0$

即
$$w[l][r+1]-w[l][r]-(w[l+1][r+1]-w[l+1][r]) \ge 0 $$
$$w[l][r+1]-w[l][r]-w[l+1][r+1]+w[l+1][r] \ge 0 $$
$$w[l][r+1]+w[l+1][r] \ge w[l][r]+w[l+1][r+1] $$
因此$w$满足四边形不等式，且明显，对于$a\le b\le c\le d$，$w[a][d]\ge w[b][c]$，故$dp$满足四边形不等式。

因为$dp$满足四边形不等式，所以对于$dp[i][j]$的最优决策$d[i][j]$，$d[i][j-1]\le d[i][j]\le d[i+1][j]$

于是状态转移$dp[i][j]$时，从$[d[i][j-1],d[i+1][j]]$中找最优决策。

由于要用到$dp[i+1][j]$，所以倒序求解。

时间复杂度$O(PV)$。

### 代码

```cpp
#include<bits/stdc++.h>
#define MAXN 3010
#define N 310
#define INF 0x3f3f3f3f

using namespace std;

int V,P,X[MAXN],dp[MAXN][N],w[MAXN][MAXN],d[MAXN][N];

void init() {
	for(int l=1;l<=V;l++) {
		w[l][l]=0;
		for(int r=l+1;r<=V;r++) {
			w[l][r]=w[l][r-1]+X[r]-X[l+r>>1];
		}
	}
}

int main() {
	cin>>V>>P;
	for(int i=1;i<=V;i++) cin>>X[i];
	
	init();
	sort(X+1,X+V+1);
	memset(dp,0x3f,sizeof(dp));
	dp[0][0]=0;
	for(int j=1;j<=P;j++) {
		d[V+1][j]=V;
		for(int i=V;i>=1;i--) {
			int minn=INF,minid;
			for(int k=d[i][j-1];k<=d[i+1][j];k++) {
				if(dp[k][j-1]+w[k+1][i]<minn) {
					minn=dp[k][j-1]+w[k+1][i];
					minid=k;
				}
			}
			dp[i][j]=minn;
			d[i][j]=minid;
		}
	}

	cout<<dp[V][P]<<endl;
	
	return 0;
}
```

---

## 作者：_Sein (赞：39)

## 我不想打表，所以我证明了这道题的四边形不等式。

$w_{a,d}$表示区间$[a,d]$建一个邮局的最小代价，也就是选择中位数。

首先证明$a\le b\le c \le d,w_{a,d}\ge w_{b,c}$

这个不难，若$a<b\le c<d$，这是成立的，因为在中位数左边，右边均多了数，也就是代价增加了。

若$a=b\le c\le d$，$w_{a,d},w_{a,c}$，若中位数发生改变，那么也就是$mid$向右发生偏移，那么在左边的个数多了一个，而右边个数至少也是原来的，总的代价多了一个偏移量，因此$w_{a,d}\ge w_{a,c}$

中位数向左发生偏移是类似的。

因此$a\le b\le c \le d,w_{a,d}\ge w_{b,c}$。

下面$a\le b\le c\le d,w_{a,d}+w_{b,c}\ge w_{a,c}+w_{b,d}$，接下来，只证明$a<b,w_{a,b+1}+w_{a+1,b}\ge w_{a,b}+w_{a+1,b+1}$。

对于$w_{a,b+1},w_{a+1,b}$，它们的中位数是相等的，记中位数为$mid_1$。

那么有$w_{a,b+1}+w_{a+1,b}=2*w_{a+1,b}+d_{b+1}-d_{mid_1}+d_{mid_1}-d_{a}$

$\because w_{a,b}\le w_{a+1,b}+d_{mid_1}-d_a,w_{a+1,b+1}\le w_{a+1,b}+d_{b+1}-d_{mid_1}$

$w_{a,b+1}+w_{a+1,b}\ge w_{a,b}+w_{a+1,b+1}$

证毕。



之后就是一些常规操作了。

对于$a<c$，$w_{a,c+1}+w_{a+1,c}\ge w_{a,c}+w_{a+1,c+1}$

对于$a<c+1$，$w_{a+1,c+1}+w_{a+2,c}\ge w_{a+1,c}+w_{a+2,c+1}$

两式相加，有

$w_{a,c+1}+w_{a+1,c}+w_{a+1,c+1}+w_{a+2,c}\ge w_{a,c}+w_{a+1,c+1}+w_{a+1,c}+w_{a+2,c+1}$

减掉重的部分，有

$w_{a,c+1}+w_{a+2,c}\ge w_{a,c}+w_{a+2,c+1}$

以此类推，有

$a\le b\le c,w_{a,c+1}+w_{b,c}\ge w_{a,c}+w_{b,c+1}$

$a\le b\le c\le d,w_{a,d}+w_{b,c}\ge w_{a,c}+w_{b,d}$

-----------------

之后就是推$f$也是一个四边不等式，证明

$\large f_{i,j+1}+f_{i+1,j}\ge f_{i,j}+f_{i+1,j+1}$。

先明确一下$f$的定义，$f_{i,j}$表示前$i$个村庄共有$j$个邮局的最小代价。

$DP$推推得：

$f_{i,j}=\min\{f_{k,j-1}+w_{k+1,i}\}$

证明$j=1$的情况。

$f_{i,2}+f_{i+1,1}\ge f_{i,1}+f_{i+1,2}$

$f_{i,2}+w_{1,i+1}\ge f_{i+1,2}+w_{1,i}$

设$f_{i,2}$的最优决策为$p(0<p<i)$,即$f_{i,2}=w_{1,p}+w_{p+1,i}$

还有$f_{i+1,2}$的最优决策可能不为$p$，即$f_{i+1,2}\le w_{1,p}+w_{p+1,i+1}$


四边形不等式,
$w_{1,i+1}+w_{p+1,i}\ge w_{1,i}+w_{p+1,i+1}$

有$w_{1,i+1}+w_{1,p}+w_{p+1,i}\ge w_{1,i}+w_{1,p}+w_{p+1,i+1}$

因此
$f_{i,2}+f_{i+1,1}=w_{1,i+1}+w_{1,p}+w_{p+1,i}\ge w_{1,i}+w_{1,p}+w_{p+1,i+1}\ge f_{i,1}+f_{i+1,2}$

之后数学归纳法即可，已经比打表法好多！。

---

之后证明一下决策单调性

简记$p_{i,j}$为令$f_{i,j}$取到最小值的$k$值，那么$p_{i,j-1}\le p_{i,j}\le p_{i+1,j}$

证明:

- 记$p=p_{i,j}$，那么对于$\forall k\le p$，因为$f$满足四边形不等式，则有

  $f_{p,j-1}+f_{k,j}\ge f_{k,j-1}+f_{p,j}$

  $f_{k,j}-f_{p,j}\ge f_{k,j-1}-f_{p,j-1}$

- 因为$p$的最优性，那么$f_{k,j-1}+w_{k+1,i}\ge f_{p,j-1}+w_{p+1,i}$

- 因此$(f_{k,j}+w_{k+1,i})-(f_{p,j}+w_{p+1,i})=f_{k,j}+w_{k+1,i}-f_{p,j}-w_{p+1,i}\ge  f_{k,j-1}-f_{p,j-1}+w_{k+1,i}-w_{p+1,i}\ge 0$

  因此$f_{k,j}+w_{k+1,i}\ge f_{p,j}+w_{p+1,i}$

  所以对于$f_{i,j}$来说，$p$优于任何的$k\le p$。因此$p_{i,j}\ge p_{i,j-1}$

  同理，$p_{i,j}\le p_{i+1,j}$

证毕。
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cstdlib>
#include<cmath>
#define gc getchar()
using namespace std;
const int P=305,N=3005;
inline void qr(int &x)
{
	x=0;char c=gc;int f=1;
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=gc;}
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=gc;}
	x*=f;
}
void qw(int x)
{
	if(x<0)x=-x,putchar('-');
	if(x/10)qw(x/10);
	putchar(x%10+48);
}
int f[N][P],s[N],a[N],p[N][P];
inline int calc(int l,int r)
{
	int mid=l+r+1>>1;
	return a[mid]*(mid-l+1)-(s[mid]-s[l-1])+(s[r]-s[mid])-a[mid]*(r-mid);
}
int main()
{
	int n,m;qr(n),qr(m);
	for(int i=1;i<=n;i++)qr(a[i]),s[i]=s[i-1]+a[i];
	memset(f,0x3f,sizeof(f));
	for(int i=1;i<=n;i++)f[i][1]=calc(1,i);
	for(int i=1;i<=m;i++)p[n][i]=1;
	for(int j=2;j<=m;j++)
	{
		p[n+1][j]=n;int tmp=0x3f3f3f3f;
		for(int i=n;i>=1;i--)
			for(int k=p[i][j-1];k<=p[i+1][j];k++)
				if((tmp=f[k][j-1]+calc(k+1,i))<f[i][j])
				{
					f[i][j]=tmp;
					p[i][j]=k;
				}
	}
	qw(f[n][m]);puts("");
	return 0;
}
```

---

## 作者：eee_hoho (赞：25)

读完题我们会发现这个题可以用wqs二分来优化dp。

我们会看出两个性质

设$g(i)$表示放$i$个邮局的最小代价，则有

1. $g(i)<g(i-1)$，放的邮局越多最小代价越小。
2. $g(i-1)-g(i)>g(i)-g(i+1)$，放的邮局越多最小代价减小得越少。

第一个非常的显然。

第二个结论我们考虑每次放邮局的过程，放入当前邮局会使一段区间内的村庄减小代价，而我们要找到减小代价最多的这一个区间，而我们上一次放入使得这个区间变多了，如果说上一次放的时候有一个区间比我这次放的区间优，那么上一次我就会放这个区间，所以说这次减少的代价一定比上一次少。

定义$f(i)$表示在放邮局会额外产生$k$的代价下，放$i$个邮局产生的最小代价。

于是我们二分斜率$k$，我们要找到一个最小的$f(i)$，然而这个东西并不好求。

那么我们设$h(i)$表示前i个村庄可以放若干个邮局，可以产生的最小代价，然后我们记$pre(i)$表示前$i$个村庄放$pre(i)$个邮局最优，当$h(i)$从$h(j),j<i$转移过来时，$pre(i)=pre(j)+1$。

那么可以轻松地写出转移方程

$$h(i)=min_{j=0}^{i-1}h(j)+dist(j+1,i)+k$$

其中$dist(l,r)$表示往$l,r$中放一个村庄的最小代价，这个东西非常好求，只需要往这个区间的中间放邮局就可以了。

这样子直接转移是$O(n^2)$的，所以我们要考虑优化。

首先先证明$dist$满足四边形不等式，也就是证明对于任意$a<b$，都有$dist(a,b)+dist(a+1,b+1)\le dist(a+1,c)+dist(a,c+1)$。

**证明**：

设$s_i=\sum_{j=1}^ia_j$那么

$$dist(l,r)=s_r-s_{mid}-a_{mid}\times(r - mid)+a_{mid}\times(mid - l)-(s_{mid - 1}-s_{l - 1}),mid=\frac{l+r}{2}$$

然后注意到$dist(a+1,b+1)$和$dist(a,b+1)$取的$mid$相同，记作$mid_1$，那么$dist(a,b+1)-dist(a+1,b+1)=s_{mid_1}-s_a$。

记$dist(a,b)$和$dist(a+1,b)$的$mid$为$mid_2$，可得$dist(a,b)-dist(a+1,b)=s_{mid_2}-s_a$

于是移项得

$$dist(a,b)+dist(a+1,b+1)-dist(a+1,c)-dist(a,c+1)=s_{mid_2}-s_a-(s_mid_2-s_a)=s_{mid_2}-s_{mid_1}$$

而$mid_2<mid_1$，所以$s_{mid_2}-s_{mid_1}\le0$，所以原式成立

**证毕**

然后我们关注到一个性质：一个点作为最优点转移到的点一定构成一个区间，也就是对于一个$i$，不存在$a<b<c$，$i$是最优点转移到$a$和$c$，但不是最优解转移到$b$。

如何证明这个结论，我们考虑反证法。（后面的作为最优解转移直接写作转移）

**证明**：

假设存在$i,j,a,b,c$满足$i\ne j,a<b<c$且$i$只能转移到$a,c$，不能转移到$b$，$j$能转移到$b$。

那么可得几个不等式

$$h(i)+dist(i+1,a)+k\le h(j)+dist(j+1,a)+k$$
$$h(i)+dist(i+1,b)+k> h(j)+dist(j+1,b)+k$$
$$h(i)+dist(i+1,c)+k\le h(j)+dist(j+1,c)+k$$

整理得
$$dist(j+1,a)+dist(i+1,b)>dist(j+1,b)+dist(i+1,a)$$
$$dist(j+1,c)+dist(i+1,b)>dist(j+1,b)+dist(i+1,c)$$

而由于$dist$满足四边形不等式，所以无法同时满足上述的两个式子，所以假设不成立。

**证毕**

然后我们可以用队列维护之前的决策点可以转移到哪个区间，到一个新的点的时候就二分找出这个点可以被哪个点转移，然后再二分找到这个点可以转移到的区间放进队列里。

这样复杂度是$O(VlogVlog\sum a)$。

**Code**
``` cpp
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cstdio>
#define reg register
const int N = 3e3;
const int M = 300;
using namespace std;
struct que
{
    int p,l,r;
}q[N + 5];
int n,m,a[N + 5],s[N + 5],f[N + 5],pre[N + 5],ans;
inline int dist(int l,int r)
{
    int mid = l + r >> 1;
    return s[r] - s[mid] - a[mid] * (r - mid) + a[mid] * (mid - l) - (s[mid - 1] - s[l - 1]);
}
inline int check(int k)
{
    int R = 0;
    q[++R] = (que){0,1,n};
    for (reg int i = 1;i <= n;i++)
    {
        int l = 1,r = R,p,mid;
        while (l <= r)
        {
            mid = l + r >> 1;
            if (q[mid].l <= i)
                l = mid + 1,p = mid;
            else
                r = mid - 1;
        }
        f[i] = f[q[p].p] + dist(q[p].p + 1,i) + k;
        pre[i] = pre[q[p].p] + 1;
        p = 0;
        while (R && f[i] + dist(i + 1,q[R].l) + k <= f[q[R].p] + dist(q[R].p + 1,q[R].l) + k)
            p = q[R--].l;
        if (R && f[i] + dist(i + 1,n) + k <= f[q[R].p] + dist(q[R].p + 1,n) + k)
        {
            l = q[R].l,r = n;
            while (l <= r)
            {
                mid = l + r >> 1;
                if (f[i] + dist(i + 1,mid) + k <= f[q[R].p] + dist(q[R].p + 1,mid) + k)
                    r = mid - 1,p = mid;
                else
                    l = mid + 1;
                q[R].r = p - 1;
            }
        }
        if (p)
            q[++R] = (que){i,p,n};
    }
    return pre[n];
}
int main()
{
    scanf("%d%d",&n,&m);
    for (reg int i = 1;i <= n;i++)
        scanf("%d",&a[i]),s[i] = s[i - 1] + a[i];
    int l = 0,r = 3e7,mid;
    while (l <= r)
    {
        mid = l + r >> 1;
        if (check(mid) >= m)
            l = mid + 1,ans = f[n] - m * mid;
        else
            r = mid - 1;
    }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：andysk (赞：16)


[Problem](https://www.luogu.org/problemnew/show/P4767)



### 题意

​		有 $n$ 个村庄，给出了他们的横坐标。现在要在这些村庄中的一些村庄安放 $p$ 个邮局，要求算每个村庄和最近的邮局之间所有距离的最小可能的总和。



### 题解

​		这个题的 $40\%$ 数据很好写，直接设 $f[i][j] = min\{ f[i - 1[k] + w[k + 1][j] \} \ \ \ \ (k < j)$ , 其中 $w[i][j]$ 表示一个邮局覆盖的 $[i,j]$ 村庄之间的距离。

​		再考虑 $100\%$ 的数据，可以用四边形不等式优化。现在开始证明四边形不等式对二维区间DP成立。则可先证明 $w$ 为凸。

​		当 $w$ 为凸时，当且仅当 $w[i][j] + w[i + 1][j + 1] \leq w[i][j + 1] + w[i + 1][j]$，那么需要有：$w[i + 1][j] - w[i][j]$ 关于 $j$ （非严格）递减。



​		再证明 $f$ 为凸时，根据上面的结论，则需证明： $f[i][j] + f[i + 1][j + 1] \leq f[i][j + 1] + f[i + 1][j]$

​		假设四边形不等式对该式成立，并且 $j - i < k$ 时,  设 $f[i][j + 1]$ 的最有决策（最优解）$k = x$ ，$f[i + 1][j]$ 的最优决策是 $f[i+1][j] = y$ 。不妨设 $i + 1 \leq x \leq y$，此时因为 $x,y$ 都是最优决策，根据以上结论，有：$f[i][j + 1] + f[i + 1][j] = f[i][x] + f[x + 1][j + 1] + w[i][j + 1] + f[i + 1][y] + f[y + 1][j] + w[i + 1] \tag{1}$

​		若要使 $i + 1\leq y \leq x$，则可以先分别写出 $f[i + 1][j]$ 和 $f[i][j + 1]$ 的等价式子（用含有$w[i][j]$的式子表示），再对他们套用公式进行合并。之后与上式进行分类讨论。

​		即使 $x,y$ 不是最优解，我们仍有：$f[i][j] + f[i + 1][j + 1] \leq f[i][x] + f[x + 1][j] +w[i][j] + f[i + 1][y] + f[y +1][j + 1] + w[i + 1][j + 1]  \tag{2}$

​		根据以上归纳假设，得：$f[x + 1][j] + f[y + 1][j + 1] \leq f[x + 1][j + 1]+ f[y + 1][j]$

​		比较 $(1) (2)$ 两式，可得 $f[i][j] + f[i + 1][j + 1] \leq f[i][j + 1] + f[i + 1][j]$ 

​		证毕。



​		最后证明 $K[i][j - 1] \leq K[i][j] \leq K[i+1][j]$ 

​		证明 $K[i][j - 1] \leq K[i][j]$ 时，先假设 $f[i][j -1]$ 有最优决策 $k = y$ ，再根据 $x \leq y\leq j-1<j$ ，列出四边形不等式：$f[i][y] + f[i + 1][k] \geq f[i][k] + f[i + 1][y]$

​		在不等式两边添加一定的项试图得到 $f[i][j-1](k=x)+f[i][j](k=y) \leq f[i][j-1](k=y)+f[i][j](k=x)$

​		移项可得：$f[i][j-1](k=x)-f[i][j-1](k=y) \leq f[i][j](k=x)-f[i][j](k=y)$

​		$∵ f[i][j-1](k=y) \leq f[i][j-1](k=x)$ 

​		$∴ f[i][j](k=y) \leq f[i][j](k=x)$

​		则说明对于所有的 $y < x$，一定有 $f[i][j](k=y) \leq f[i][j](k=x)$ ，因此 $f[i][j]$ 的最优决策 $k$ 一定不小于 $y$

​		对于$K[i][j - 1] \leq K[i][j]$ 方法类似，在此省略

​		

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;

const int SIZE = 3000 + 5;
const int inf = 0x7f7f7f7f;

int n, p;
int a[SIZE], sum[SIZE], f[SIZE][SIZE], k[SIZE][SIZE];

inline int read()
{
    char ch = getchar();
    int f = 1, x = 0;
    while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }
    while (ch >= '0' && ch <= '9') { x = (x << 1) + (x << 3) + ch - '0'; ch = getchar(); }
    return x * f;
}

inline int Calc(int x, int y)
{
    int Mid = (x + y) >> 1;
    return sum[y] - sum[Mid] - (y - Mid) * a[Mid] + (Mid - x) * a[Mid] - sum[Mid - 1] + sum[x - 1];
}

int main()
{
    n = read(), p = read();
    for (int i = 1; i <= n; i++)
    {
	a[i] = read();
	sum[i] = sum[i - 1] + a[i];
    }
    for (int i = 0; i <= n; i++)
	f[i][i] = 0, k[i][i] = i;
    for (int len = 1; len <= n - p; len++)
    {
	int j = 0;
	for (int i = 0; (j = i + len) <= n; i++)
	    f[i][j] = inf;
	for (int i = 1; (j = i + len) <= n; i++)
	{
	    for (int K = k[i][j - 1]; K <= k[i + 1][j]; K++)
	    {
		int t = f[i - 1][K - 1] + Calc(K, j);
		if (t < f[i][j])
		{
		    f[i][j] = t;
		    k[i][j] = K;
		}
	    }
	}
    }
    printf("%d", f[p][n]);
    return 0;
}
```




---

## 作者：chdy (赞：15)

这篇是一个传统的四边形不等式优化dp.

前沿：其他题解的四边形不等式的使用和我的并不一样 大部分四变形不等式优化的dp复杂度不是简单的$n*p$ 也有好多题解没有写其复杂度 只是一个O(能过的)

这里提供一个 $n*plogn$的复杂度的传统优化方式.

1.简单的可以发现某一个邮局只会控制一段区间

2.这个邮局一定在这段区间的中间可以使价值最小

3.状态设出来$f[i][j]$表示前i个村庄建了j个邮局的最小值

转移:

$f[i][j]=min(f[i][j],f[k][j-1]+cost[k+1][j]);$

一般这种形式的都具有决策单调性 

ps:因为这种东西不能斜率优化也不能直接使用单调队列进行优化。

两种证明方法:

1.盲猜之后+打表

2.对于这种式子我们欲证明$f[i][j]$具有决策单调性 需要先证明cost[i][j]满足四边形不等式，从而推得$f[i][j]$满足四边形不等式，然后就可以设p为最优决策从而推得$f[i][j]$具有决策单调性。

至于具体证明我这里不再赘述 其他题解都有，但是具体的这道题证明$cost[i][j]$满足四边形不等式直接暴力展开即可。

我们证明了 $f[i][j]$ 具有决策单调性 那么意味着 在上述转移中k是单调不降 传统的我们利用一个三元组解决这个问题 $(l,r,p)$然后利用单调队列+二分插入决策即可。

复杂度为$n \cdot p\cdot logn$
```
const int MAXN=10010,maxn=310;
int n,p,l,r;
int a[MAXN];struct wy
{
	int l,r;
	int p;
}q[MAXN];
inline int cost(int i,int j)//求在村庄i到村庄j这个区间之内建立一个邮局的最小距离
{
	if((j-i+1)&1)//当前是奇数
	{
		int w=i+(j-i+1)/2;
		//前一半是 a[j]-a[w]-(j-i+1)/2*d;
		//后一半是 d*(j-i+1)/2-a[w-1]+a[i-1];
		return a[j]+a[i-1]-a[w-1]-a[w];
	}
	else //当前是偶数
	{
		int w=i+(j-i+1)/2;
		//前一半 a[j]-a[w-1]-(i-j+1)/2*x
		//后一半 (i-j+1)/2*x-a[w-1]+a[i-1]
		return a[j]-2*a[w-1]+a[i-1];
	}
}
inline int calc(wy a,int x,int k)
{
	int l=a.l,r=a.r+1;
	while(l<r)
	{
		int mid=(l+r)>>1;
		if(f[x][k]+cost(x+1,mid)<=f[a.p][k]+cost(a.p+1,mid))r=mid;
		else l=mid+1;
	}
	return r;
}
int main()
{
	n=read();p=read();
	for(int i=1;i<=n;++i)a[i]=read();
	sort(a+1,a+1+n);
	for(int i=2;i<=n;++i)a[i]+=a[i-1];
	memset(f,0x3f,sizeof(f));
	f[0][0]=0;
	for(int j=1;j<=p;++j)//注意内外循环的顺序.
	{
		q[l=r=1]=(wy){1,n,0};
		for(int i=1;i<=n;++i)
		{
			f[i][j]=f[q[l].p][j-1]+cost(q[l].p+1,i);
			++q[l].l;
			while(l<=r&&q[l].l>q[l].r)++l;
			//把当前i加入决策当中
			if(f[q[r].p][j-1]+cost(q[r].p+1,n)>f[i][j-1]+cost(i+1,n))
			{
				while(l<=r&&f[i][j-1]+cost(i+1,q[r].l)<=f[q[r].p][j-1]+cost(q[r].p+1,q[r].l))--r;
				if(l>r){q[++r]=(wy){i+1,n,i};continue;}
				int w=calc(q[r],i,j-1);
				q[r].r=w-1;
				q[++r]=(wy){w,n,i};
			}
		}
	}
	printf("%d\n",f[n][p]);
	return 0;
}
```
~~照常撒花~~~

---

## 作者：H_D_NULL (赞：10)

## 一个一波三折的题解（~~惨痛的回忆~~）

------------

##### 好吧，其实我也是用四边形不等式做的，而且做法也没有优于已有的题解。但是做都做了，还是提供一下思路吧。毕竟，~~经验+3，岂不美哉?~~

------------
大佬都在刷各种神仙方法，但是我觉得DP题还是要先从本源（~~暴力~~）说起，再慢慢考虑优化。反正这是我做DP的方法，不喜勿喷。

## 1.暴力

首先，我们考虑只有一个邮局的情况，即在坐标为 $d[1...n]$ 的村庄中选一个求最小距离和。可以发现邮局在中位数处一定最优，即 $k=(i+j)/2$ ，于是有:$w[i,j]=|d[i...j]-d[k]|$ 

由此可以提前计算出所有 $w[i,j]$ ，计算时直接引用（da biao）。

再看状态转移方程。状态 $m[i,j]$ 表示前j个村庄建立i个邮局的最小距离和。根据这类DP的套路，把这个距离分成两部分：前 $k$ 个村庄建立 $i-1$ 个邮局的最小距离和 $m[i-1,k]+d[k+1..j]$ 之间建立第i个邮局的最小距离和 $w[k+1,j]$ 。所以得状态转移方程: $m[i,j]=min(m[i-1,k],w[k+1,j])$

~~40分到手，岂不美哉~~


------------
## 2.优化——四边形不等式


#### 前言

Q（某dalao）：为什么要用四边形不等式？

A:因为在枚举 $k$ 时花费了太多时间，所以急需一种方法减小其范围。

Q（不要脸地）：四边形不等式太男了，不能用WQS二分吗？

A：这个故事告诉我们，蒟蒻就好好做个蒟蒻吧。。。

Q：什么是四边形不等式？

A：。。。还是百度吧 [四边形不等式](https://baike.baidu.com/item/%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F/7556574#1)。附：四边形不等式的基本应用 [[NOI1995]石子合并](https://www.luogu.com.cn/problem/P1880)

这里不得不说，四边形不等式的题真是有心，让人先AK NOI,再AK IOI，多有成就感！

#### 对于本题

要使用四边形不等式优化，我们就“猜测”取最优 $k$ 值的决策函数 $s[i,j]$ 单调，即  。

首先需要证明以下两个性质（证明过程繁而不难，省去）：


#### 性质1. w [ i , j ] + w [ i ’ , j ’ ] <= w [ i ’ , j ] + w [ i , j ’ ]  ，i <= i ’ <= j <=j ’


#### 性质2. m [ i , j ] + m [ i ’ , j ’ ] <= m [ i ’ , j ] + m [ i , j ’ ] ，i <= i ’ <= j <= j ’


#### 最后，即可证明:性质3.  s [ i - 1 , j ] <= s [ i , j ] <= s [ i , j + 1 ]

证明这个性质有什么用呢？这就达到了我们的初衷——限定最优值 $k$ 的取值范围！~~不忘初心，方得始终~~


------------

以上就是基本思想，其实知道结论后代码男度很小（...），所以考场上能否自己推出来就看各位的数学功底和对这类特殊题目的敏感度了。（~~本人表示自己还真不能独立把所有性质证出来~~。）

某dalao： _**Talk is cheap, show me the code.**_

```cpp
#include<bits/stdc++.h>
#define re register int
using namespace std;
const int M=1<<30;

int n,m;
int a[3005];
int w[3005][3005];
int f[3005][305];
int s[3005][305];

int main(){
	ios::sync_with_stdio(false);
	cin>>n>>m;
	for(re i=1;i<=n;i++) cin>>a[i];
	sort(a+1,a+1+n);
	for(re i=1;i<n;i++){
		for(re j=i+1;j<=n;j++){
			w[i][j]=w[i][j-1]+a[j]-a[(i+j)/2]; //懒人打表
		}
	}
	for(re i=1;i<=n;i++){
		f[i][1]=w[1][i]; //状态转移方程的边界条件
		s[i][1]=1;
	}
	for(re i=1;i<=m;i++) s[n+1][i]=n-1;
	for(re j=2;j<=m;j++){ //保证无后效性
		for(re i=n;i>=j;i--){
			f[i][j]=M;
			for(re k=s[i][j-1];k<=s[i+1][j];k++){ //四边形不等式的成果
				if(f[k][j-1]+w[k+1][i]<f[i][j]){ 
					f[i][j]=f[k][j-1]+w[k+1][i];
					s[i][j]=k; //更新决策点
				}
			}
		}
	}
	printf("%d",f[n][m]);
	return 0;
}

---

## 作者：xyvsvg (赞：8)

这里提供一个斜率优化做法。

先将所有村庄排序。

设 $f_{p,i}$ 表示考虑到第 $p$ 个邮局，第 $i$ 个村庄时的答案。$g_{p,i}$ 表示考虑到第 $p$ 个邮局，第 $i$ 个村庄，且**第 $p$ 个邮局坐标与第 $i$ 个村庄坐标重合**的答案。

不妨设 $p_i$ 表示前 $i$ 个村庄的坐标和，则显然有转移：
$$g_{p,i}=\min\{f_{p-1,i}+(i-j)\cdot a_i-(p_i-p_j)\}$$
$$f_{p,i}=\min\{g_{p,j}-(i-j)\cdot a_j+(p_i-p_j)\}$$

你可能有疑问：根据小学数学知识，将邮局建在中位数应该是最优的，可是这个转移似乎并没有保证。无妨，假设这个转移没有从中位数转移，则一定存在一个不劣于此转移的答案，满足其从中位数转移，即这么转移并不影响最终答案。

去掉 $\min$ 符号，展开，移项，有：

$$f_{p-1,j}+p_j=g_{p,i}+j\cdot a_i-i\cdot a_i+p_i$$
$$g_{p,j}+j\cdot a_j=f_{p,i}+i\cdot a_j-p_i$$

直接套斜率优化板子即可，第一维可以滚动数组，且由于转移时的斜率是单调不减的，因此可以直接使用单调队列维护凸线，复杂度为 $O(PV)$。

参考代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> P;
#define x first
#define y second
signed main()
{
    int n,m;
    cin>>n>>m;
    vector<int>a(n+10),pref(n+10);
    for(int i=1;i<=n;++i)
        cin>>a[i];
    partial_sum(a.begin(),a.end(),pref.begin());
    const int inf=0x3f3f3f3f;
    vector<int>f_(n+10,inf);
    f_[0]=0;
    for(int d=1;d<=m;++d)
    {
        vector<int>f(n+10,inf),g(n+10,inf);
        f[0]=0;
        deque<P>qf,qg;
        qf.push_back({0,0});
        auto popf=[&](deque<P>&deq,int k)
        {
            while(deq.size()>1&&deq[1].y-deq[0].y<=k*(deq[1].x-deq[0].x))
                deq.pop_front();
        };
        auto pushb=[&](deque<P>&deq,const P p)
        {
            P q;
            while(deq.size()>1&&(q=deq[deq.size()-2],(p.y-deq.back().y)*(deq.back().x-q.x)<=(deq.back().y-q.y)*(p.x-deq.back().x)))
                deq.pop_back();
            deq.push_back(p);
        };
        for(int i=1;i<=n;++i)
        {
            pushb(qf,{i,f_[i]+pref[i]});
            popf(qf,a[i]);
            g[i]=qf.front().y+i*a[i]-a[i]*qf.front().x-pref[i];
            pushb(qg,{a[i],g[i]-pref[i]+i*a[i]});
            popf(qg,i);
            f[i]=qg.front().y-i*qg.front().x+pref[i];
        }
        swap(f_,f);
    }
    cout<<f_[n]<<endl;
    return 0;
}
```

---

## 作者：SIGSEGV (赞：6)

四边形不等式.......了解一下？

对于这种要枚举i,j,k,时间复杂度为O(n^3)的dp，使用mk[i][j]记录下k的值，会发现mk[i-1][j] <= k <= mk[i][j+1] （证明[在此](https://blog.csdn.net/u014800748/article/details/45750737)）

本题正常的DP方程很容易想到:dp[i][j]表示前j个村庄中建了i个村庄距离总和的最小值。

我们可以利用数学证明：在i~j之间建立邮局的位置选在中间一定最优，因此计算出在i~j之间建立邮局的最优值w[i][j]，方程便可得出:
### dp[i][j] = max{dp[i][k] + w[k+1][j]}
时间复杂度O(N^3)，优化后为O(N^2)

上代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,a[3005],mk[3005][3005];
long long dp[305][3005],w[3005][3005];
int main ()
{
    scanf("%d%d",&n,&m);
    for (int i = 1;i <= n;i++) scanf("%d",&a[i]);
    sort(a + 1,a + n + 1);//先按坐标排序
    for (int i = 1;i <= n;i++)
        for (int j = i + 1;j <= n;j++)
            w[i][j] = w[i][j - 1] + a[j] - a[(i + j) / 2];//计算w[i][j]的值
    for (int i = 1;i <= n;i++) dp[1][i] = w[1][i],mk[1][i] = 0;//初始化
    for (int i = 2;i <= m;i++)
    {
        mk[i][n + 1] = n;//这个值没有计算出来，因此预处理为n
        for (int j = n;j > i;j--) //因为在枚举k的时候需要mk[i][j+1]的值，因此倒序枚举j
        {
            dp[i][j] = 1ll << 60;
            for (int k = mk[i - 1][j];k <= mk[i][j + 1];k++)
                if (dp[i][j] > dp[i - 1][k] + w[k + 1][j])
                    dp[i][j] = dp[i - 1][k] + w[k + 1][j],mk[i][j] = k;//更新mk[i][j]
        }
    }
         
              
    printf("%lld",dp[m][n]);
    return 0;
}
```

---

## 作者：xiezheyuan (赞：5)

> **摘要**：本文将介绍一种 **决策单调性分治** 做法。

首先有一个 dp，设 $f(i,j)$ 表示考虑到前缀 $[1,i]$ 已经放了 $j$ 个邮局的答案，则不难有转移：

$$
f(i,j)=\min_{k=0}^{i-1}f(k,j-1)+w(k+1, i)
$$

其中 $w$ 是一个可以 $O(V^2)$ 递推的一个玩意。

观察这个转移式，可以按照 $j$ 分层，$f(,j)$ 之间不会影响，而只有 $f(,j-1)$ 才会对 $f(,j)$ 产生直接的影响。于是可以考虑依次求出每一层的答案。

由于 $w$ 满足四边形不等式，所以我们可以分治求出每一层的 dp 值。

具体来说，假设现在分治到区间 $[l,r]$，设 $m$ 为区间中点，目前最优决策点位于 $[L,R]$，则我们可以暴力求出 $m$ 的决策点 $p$，然后 $[l,m-1]$ 的决策点一定位于 $[L,p]$，$[m+1,r]$ 的决策点一定位于 $[p,R]$，规模得到缩减，于是我们可以继续分治。

时间复杂度 $O(VP\log P)$。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 3e3 + 5;
int n, m, a[N], f[N], g[N], w[N][N];

void solve(int l, int r, int L, int R){
    if(l > r) return;
    int mid = (l + r) >> 1, s = L;
    auto wgt = [&](int k, int i){ return g[k] + w[k + 1][i]; };
    for(int i=L;i<=min(R, mid - 1);i++){
        if(wgt(i, mid) < wgt(s, mid)) s = i;
    }
    f[mid] = wgt(s, mid);
    solve(l, mid - 1, L, s);
    solve(mid + 1, r, s, R);
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    cin >> n >> m;
    for(int i=1;i<=n;i++) cin >> a[i];
    for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++){
			w[i][j]=w[i][j-1]+a[j]-a[(i+j)>>1];
		}
	}
    for(int i=1;i<=n;i++) f[i] = w[1][i];
    for(int i=2;i<=m;i++){
        copy(f + 1, f + n + 1, g + 1);
        solve(1, n, 1, n);
    }
    cout << f[n] << '\n';
    return 0;
}

// Written by xiezheyuan
```

---

## 作者：楠枫 (赞：5)

这道题最最基础的一种解法来自于一道区间 $DP$ 模板题[传送门](https://www.luogu.com.cn/blog/nanfengzjy/gu-wai-yi-ti-zheng-shuo-hua-fen)  

本题[题面](https://www.luogu.com.cn/problem/P4767)

这道题是我的学校集训的一道区间 $DP$ 题目，所以这道题肯定要用区间 $DP$ 做啦(~~主要是楼上楼下大佬的四边形不等式蒟蒻看不懂~~)。
 
这道题主要思维就是用一个二维数组 $f$ 来记录前 $i$ 个村庄建立 $j$ 个邮局的最短路径和。状态转移方程为：
$$
f[i][j]=max\{f[k][j-1]+dis[k+1][i]\}(k<i)
$$
解释一下： $f[k][j-1]$ 为前 $k$ 个村庄建立 $j-1$ 个邮局的最短路和， $dis[k+1][i]$ 为第 $k+1$ 个村庄到第 $i$ 个村庄建立 $1$ 个邮局的最短路和。那么问题来了，如何算 $dis[k+1][i]$ 呢?这也是这种做法的难点。下面是公式计算 $l$ 村到 $r$ 村 $(l\le r)$ 建立一个邮局的最短路和：   
$$
dis[l][r]=a[\frac{l+r}2]-a[l]+a[\frac{l+r}2]-a[l+1]+\dots+a[\frac{l+r}2]-a[\frac{l+r}2]
$$
$$
\kern 3.5em+|a[\frac{l+r}2]-a[\frac{l+r}2+1]+a[\frac{l+r}2]-a[\frac{l+r}2+2]+\dots+a[\frac{l+r}2]-a[r]|
$$
( $a[]$ 为各点的坐标数组)

不难看出， $l$ 到 $\frac{l+r}2$ 是单调递增的，所以前半部分可以化成
$$
a[\frac{l+r}2]×(\frac{l+r}2-l+1)-(a[l]+a[l+1]+\dots+a[\frac{l+r}2]])
$$
同理，后半部分可化为
$$
|a[\frac{l+r}2]×(r-\frac{l+r}2+1)-(a[\frac{l+r}2]+a[\frac{l+r}2+1]+\dots+a[r])|
$$
问题就转化为我们如何求 $a[l]+\dots+a[r]$   ，妥妥的一个求区间和  
看代码:
```cpp
for (int i=1;i<=n;i++) {
    a[i]=read();
    s[i]=s[i-1]+a[i];//用一个数组将前 i 个坐标和存起来
}
```
```cpp
inline int calc(int l,int r) {
    int mid=(l+r)/2;
    return a[mid]*(mid-l+1)-s[mid]+s[l-1]+abs(a[mid]*(r-mid+1)-s[r]+s[mid-1]);//用 s 数组求区间和
}
```
这样，我们就初始化完了，剩下的就是一个区间 $DP$ 了，一定要**记录路径**  
$AC \kern 1emCODE$:
```cpp
#include<bits/stdc++.h>
using namespace std;
int f[3001][305];
int a[3005],s[3005],p[3005][305];//p数组记录前i个村子建立j个邮局中最后一个邮局的坐标。
inline int read() {
    int x=0,f=1;
    char ch=getchar();
    while (ch<'0'||ch>'9') {
	if (ch=='-') {
	     f=-1;
	}
	     ch=getchar();
	}
	while (ch>='0'&&ch<='9') {
	    x=(x<<1)+(x<<3)+(ch^48);
	    ch=getchar();
	}
     return f*x;
}//快读
inline int calc(int l,int r) {
    int mid=(l+r)/2;
    return a[mid]*(mid-l+1)-s[mid]+s[l-1]+abs(a[mid]*(r-mid+1)-s[r]+s[mid-1]);
}
int main() {
    int n=read(),m=read();
    for (int i=1;i<=n;i++) {
          a[i]=read();
          s[i]=s[i-1]+a[i];
    }
    for (int i=1;i<=n;i++) {
          f[i][1]=calc(1,i);//初始化
    }
    for (int i=1;i<=m;i++) {
          p[n][i]=1;
    }
    int cnt;//记录两个村子间建一个邮局的最短距
    for (int j=2;j<=m;j++) {
      p[n+1][j]=n;//定义边界
      f[j][j]=0;
      p[j][j]=j;
      for(int i=n;i>j;i--) {
           f[i][j]=INT_MAX;//先初始化为最大值
           for (int k=p[i][j-1];k<=p[i+1][j];k++) {
                   cnt=calc(k+1,i);
                   if (f[i][j]>f[k][j-1]+cnt) {//松弛
                        f[i][j]=f[k][j-1]+cnt;
                        p[i][j]=k;//更新最后一个邮局的坐标
                   }
                }
          }
    }
    printf("%d\n",f[n][m]);
    return 0;
}
```
此解状态有 $nm$ 个，转移复杂度为 $O(n)$ ,所以时间复杂度为$O(n^2m)$  
$\color{white}\textbf{完结撒花。}$

---

## 作者：blackjack (赞：5)

## Analysis
显然地定义状态dp(en,k)，表示在前en个村子已经放了k个邮局的最小距离和。
然后写出显然的转移方程：
dp(en,k)=min{dp(i,k-1)+calc(i+1,en)}.
其中，i是枚举用的。calc(a,b)表示在[a,b]这些村庄中放一个邮局得到的最小距离和。
显然，在一个区间中放邮局，放在区间最中间最优。
那么这个代价怎么算呢？暴力的话是O(v^3)，显然熄火。不过由于我们已经知道了放邮局的位置，于是可以把一个区间拆分成两个区间，然后通过前缀和求得calc,这样，我们可以在O(v^2)的时间内求出在每个区间内放一个邮局的最小代价。
至此，算法复杂度为O(v^3)，估计只有40分。
基本代码如下。
## Code
```cpp
#include<bits/stdc++.h>

using namespace std;

int loc[3010],sum[3010][3010];
int G[3010][3010];
int dp[3010][310];
int v,p;

void calcdis(){
	for (int i=1;i<=v;++i)
		for (int j=i;j<=v;++j){
			sum[i][j]=sum[i][j-1]+loc[j];
	int mid=0;
	for (int i=1;i<=v;++i){
		for (int j=i;j<=v;++j){
			mid=(i+j)/2;
			G[i][j]+=loc[mid]*(mid-i)-sum[i][mid-1];
			G[i][j]+=sum[mid+1][j]-(j-mid)*loc[mid];
		}
	}
}

int main(){
	cin>>v>>p;
	for (int i=1;i<=v;++i)
		cin>>loc[i];
	sort(loc+1,loc+v+1);
	calcdis();
	memset(dp,0x3f3f3f3f,sizeof(dp));
	for (int i=1;i<=v;++i)
		dp[i][1]=G[1][i];
	for (int en=1;en<=v;++en){
		for (int k=1;k<=p;++k){
			for (int i=1;i<=en;++i){
				dp[en][k]=min(dp[en][k],dp[i][k-1]+G[i+1][en]);
			}
		}
	}
	cout<<dp[v][p]<<endl;
	return 0;
}
```
## Analysis
实际上是50分......
需要优化。方程中都和i，en有关，不能单调队列，直接考虑四边形不等式。
观察方程dp(en,k)=min{dp(i,k-1)+calc(i+1,en)}，很显然，对于calc数组，满足:
当i<i+1<=j<j+1时
calc(i,j)+calc(i+1,j+1)<=calc(i+1,j)+calc(i,j+1).
证明？可以把calc拆分成sum数组，然后sum数组再拆分，直接化简就可知其成立，这个就比较复杂了，在此不详细证明。（其实你考试时候有空证明吗，直接打表找规律啊）
于是就是简单的模板题。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int loc[3010],sum[3010][3010];
int G[3010][3010];
int dp[3010][310],deci[3010][310];
int v,p;
void calcdis(){
	for (int i=1;i<=v;++i)
		for (int j=i;j<=v;++j)
			sum[i][j]=sum[i][j-1]+loc[j];
	int mid=0;
	for (int i=1;i<=v;++i){
		for (int j=i;j<=v;++j){
			mid=(i+j)/2;
			G[i][j]+=loc[mid]*(mid-i)-sum[i][mid-1];
			G[i][j]+=sum[mid+1][j]-(j-mid)*loc[mid];
		}
	}
}
int main(){
	freopen("test.in","r",stdin);
//	freopen("test.out","w",stdout);
	cin>>v>>p;
	for (int i=1;i<=v;++i)
		cin>>loc[i];
	sort(loc+1,loc+v+1);
	calcdis();
	memset(dp,0x3f3f3f3f,sizeof(dp));
	for (int i=1;i<=v;++i)
		dp[i][1]=G[1][i];
	for (int i=0;i<=p;++i)
		deci[v+1][i]=v;
	for (int k=1;k<=p;++k){
		for (int en=v;en;--en){
			for (int i=deci[en][k-1];i<=deci[en+1][k];++i){
				if (dp[en][k]>dp[i][k-1]+G[i+1][en]){
            		dp[en][k]=dp[i][k-1]+G[i+1][en];
                	deci[en][k]=i;
            	}
        	}
		}
	}
	cout<<dp[v][p]<<endl;
	return 0;
}

```
## Conclusion
注意转移顺序！


---

## 作者：Lamorak (赞：4)

此题需要用四边形不等式优化
  ~~我相信40分的代码大家应该都能打出来吧~~
  
###  如果没有推出 dp 方程，建议关掉题解思考出转移方程再研究此类优化
  
  那我们直接上优化
## 以下是我对四边形不等式优化的一些理解


### 什么是四边形不等式优化
  
此类优化主要针对二维区间 dp，转移方程大多为 
 $$dp[i][j]=\min(dp[i][k]+dp[k+1][j]+w[i][j])$$ 
方程含义： 

$dp[i][j]$ 表示从 $i$ 状态到 $j$ 状态的最小花费。题目一般是求 $dp[1][n]$，即从起始点 $1$ 到终点 $n$ 的最小花费。

$dp[i][k]+dp[k+1][j]$ 体现了递推关系。$k$ 在 $i$ 和 $j$ 之间滑动，$k$ 有一个最优值，使得 $dp[i][j]$ 最小。

$w[i][j]$ 是和题目有关的费用，如果它满足四边形不等式和单调性，那么用 DP 计算 $dp[]$ 的时候，就能进行四边形不等式优化。

这类问题的经典的例子是“石子合并”，它的转移矩阵就是上面的 $dp[i][j]$， $w[i][j]$ 是从第 $i$ 堆石子到第 $j$ 堆石子的总数量

对于此题，不难得出方程 
 $$dp[i][j]=\min(dp[k][j-1]+w(k+1,i))$$ 

只需一个简单的优化操作，就能把上面代码的复杂度变为  $O(n^2)$ ~~至于这个证明我懒不想说~~。这个操作就是把循环 $i \le k < j$ 改为 $s[i][j-1] \le k \le  s[i+1][j]$ 其中 $s[i][j]$ 记录从 $i$ 到 $j$ 的最优分割点。在计算 $dp[i][j]$ 的最小值时得到区间 $[i,j]$ 的分割点 $k$，记录在 $s[i][j]$ 中，用于下一次循环

```
for(int i=1;i<=n;i++){
	dp[i][i]=0;
	s[i][i]=1;
}
for(int len=2;len<=n;len++){
    for(int i=1;i<=n-len+1;i++){
        int j=i+len-1;
        for(int k=s[i][j-1];k<=s[i+1][j];k++){
            int t=dp[i][k]+dp[k+1][j]+w[i][j];
            if(f[i][j]>t){
                f[i][j]=t;
                s[i][j]=k;
            }
        }
    }
}
```


------------

虽说这只是一个模板~~与此题无关~~，但也有许多疑问

代码的复杂度是多少 \?

为什么能够在保证正确性的前提下把 $i \le k < j$ 缩小到 $s[i][j-1] \le k \le s[i+1][j]$ \?


------------

### 四边形不等式的证明
在四边形不等式 DP 优化中，对于 $w[]$，有2个关键内容：四边形不等式定义、单调性。

四边形不等式定义1：设 $w$ 是定义在整数集合上的二元函数，对于任意整数 $i \le i' \le j \le j'$，如果有 
 $$w(i,j)+w(i',j') \le w(i,j')+w(i',j)$$ 
则称 $w$ 满足四边形不等式。

四边形不等式可以概括为：两个交错区间的 $w$ 和，小于等于小区间与大区间的 $w$ 和。

四边形不等式定义2：对于整数 $i < i+1 \le j < j+1$，如果有 
$w(i,j)+w(i+1,j+1) \le w(i,j+1)+w(i+1,j)$
 称 $w$ 满足四边形不等式。

四边形不等式定理：如果 $w(i,j)$ 满足四边形不等式和单调性，则用 DP 计算 $dp[][]$ 的时间复杂度是 $O(n^2)$ 的。

这个定理是通过下面2个更详细的引理来证明的。

引理1：状态转移方程 $dp[i][j]=\min(dp[i][k]+dp[k+1][j]+w[i][j])$，如果 $w[i][j]$ 满足四边形不等式和单调性，那么 $dp[i][j]$ 也满足四边形不等式。

引理2：记 $s[i][j]=k$ 是 $dp[i][j]$ 取得最优值时的 $k$，如果 dp 满足四边形不等式，那么有 $s[i][j-1] \le s[i][j] \le s[i+1][j]$，即 $s[i][j-1] \le k \le s[i+1][j]$。
引理2直接用于 DP 优化，复杂度 $O(n^2)$。

这两个引理的证明论文可[戳这里](http://www.cs.ust.hk/mjg_lib/bibs/DPSu/DPSu.Files/p429-yao.pdf)

最后，贴上蒟蒻代码~~大佬勿喷~~
```
#include<bits/stdc++.h>
using namespace std;
const int N=3009;
int f[N][N],s[N][N],a[N],num[N],n,m;

inline int val(int l,int r){
	int mid=(l+r+1)>>1;
	return a[mid]*(mid-l+1)-(num[mid]-num[l-1])+num[r]-num[mid]-a[mid]*(r-mid);
}

int main(){
	memset(f,0x3f3f3f,sizeof(f));
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		num[i]=num[i-1]+a[i];
	}
	for(int i=1;i<=n;i++){
		f[i][1]=val(1,i);//注意初始化
	}
	for(int i=1;i<=m;i++){
		s[n][i]=1;
	}
   //开始dp
	for(int j=2;j<=m;j++){
		s[n+1][j]=n;
		for(int i=n;i>=1;i--){
			for(int k=s[i][j-1];k<=s[i+1][j];k++){
				int t=f[k][j-1]+val(k+1,i);
				if(f[i][j]>t){//四边形不等式优化
					f[i][j]=t;
					s[i][j]=k;
				}
			}
		}
	}
	printf("%d",f[n][m]);//dp非常注重f[][]的定义
	return 0;
}
```
~~其实证明看不懂应该不要紧吧，会用就好了~~

---

## 作者：dsjkafdsaf (赞：3)



定义dp[i][j]表示前i个点，建j个邮局的最少路程。

`dp[i][j]=min(dp[i][j],dp[k][j−1]+cost[k+1][i])`

设`dp[i][j]`的最优决策点的为`s[i][j]`;

可以先`n^3`求出所有dp值，再验证dp值满足四边形不等式

也可以直接打表验证决策点`s[i][j]`,

满足单调性:$s[i][j−1]≤s[i][j]≤s[i+1][j] $,满足四边形不等式优化，

决策点有了区间之后，复杂度降为`O(n^3)`
```
#include<bits/stdc++.h>
using namespace std;
#define reg register
#define rep(a,b,c) for(reg int a=(b),a##_end_=(c); a<=a##_end_; ++a)
#define drep(a,b,c) for(reg int a=(b),a##_end_=(c); a>=a##_end_; --a)
#define debug(x) cout<<#x<<" = "<<x<<endl;
const int M=3005,mod=1e9+7;
int Read() {
    int res=0,f=1;
    char x=getchar();
    while(x<'0'||x>'9') {
        x=getchar();
        if(x=='-')f=-1;
    }
    while(x>='0'&&x<='9')res=(res<<1)+(res<<3)+(x^48),x=getchar();
    return res*f;
}
int n,k,A[M],Sum[M],dp[M][M],tot[M][M],Most[M][M];
int main() {
    scanf("%d%d",&n,&k);
    rep(i,1,n)A[i]=Read(),Sum[i]=Sum[i-1]+A[i];
    rep(i,1,n)rep(j,i,n) {
        int mid=(i+j)>>1;
        tot[i][j]=(mid-i+1)*A[mid]-Sum[mid]+Sum[i-1]+Sum[j]-Sum[mid]-(j-mid)*A[mid];
    }
    rep(i,1,n)dp[i][1]=tot[1][i];
    rep(j,2,k)drep(i,n,1) {
        dp[i][j]=1e9;
        if(!Most[i][j-1])Most[i][j-1]=j-1;
        if(!Most[i+1][j])Most[i+1][j]=i-1;
        rep(k,Most[i][j-1],Most[i+1][j])if(dp[i][j]>=dp[k][j-1]+tot[k+1][i]) {
            dp[i][j]=dp[k][j-1]+tot[k+1][i];
            Most[i][j]=k;
        }
    }
    printf("%d",dp[n][k]);
}
```
四边形不等式的基本理论：

$ a≤b<c≤d $

(1)cost函数满足区间包含的单调性:

$cost[b][c]≤cost[a][d]cost[b][c] \le cost[a][d]cost[b][c]≤cost[a][d]$

(2)cost函数满足四边形不等式:

$cost[a][c]+cost[b][d]≤cost[a][d]+cost[b][c]$

则dp函数满足四边形不等式。再推出决策点的单调性。
理论推导比较麻烦，打表验证更直接


---

## 作者：KokiNiwa (赞：2)

# [IOI 2000] 邮局

这题。。。方法众多。

## 题目叙述

给你一个数轴，你要在这个数轴上选一些点。每个点要找到一个点，并花费这两个点之间的距离那么多时间。问最少花费多少时间。给定点数和选多少点。

## 题解

一开始有一个想法，就是设$dp_{i,j}$表示前$i$个并且在最后一个位置上设一个邮局的的最小代价。每次转移枚举前面的点，转移时看这次和上次点之间那些点分别去哪里。但是...很快发现这玩意并没有决策单调性。这个可以通过写暴力然后记录转移点发现（自己随机数据都过不去）。但是...可以得到`80`分。。。而且和正确答案误差不超过20。

然后设$dp_{i,j}$表示前$i$个，分成$j$段的最小代价，发现符合决策单调性。于是就可以`A`掉了。

## 一些思考

+ **只要从最终答案的形式出发思考，就可以想到这种分段的方法。**

## 知识点

+ 决策单调性
+ 从结尾状态入手

## 代码

注意：

+ 注意二分写法！想清楚二分的啥...

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
const int maxNode = 3e3 + 5, maxPost = 3e2 + 5;
struct Strategy {
	int lEP, rEP, pos;
	Strategy() : lEP(0), rEP(0), pos(0) {}
	Strategy(int _l, int _r, int _p) : lEP(_l), rEP(_r), pos(_p) {}
} Q[maxNode];
int head, tail;
int nbNode, nbPost, sum[maxNode], pos[maxNode], dp[maxPost][maxNode], fro[maxPost][maxNode];
int GetSum(int l, int r) {
	return sum[r] - sum[l - 1];
}
int Cal(int lpos, int rpos) {
	if (lpos >= rpos)
		return 0;
	int mid = (lpos + rpos) >> 1;
	return pos[mid] * (mid - lpos + 1) - GetSum(lpos, mid) + GetSum(mid + 1, rpos) - pos[mid] * (rpos - mid);
}
int main() {
	scanf("%d%d", &nbNode, &nbPost);
	for (int i = 1; i <= nbNode; ++i)
		scanf("%d", &pos[i]);
	sort(pos + 1, pos + nbNode + 1);
	for (int i = 1; i <= nbNode; ++i)
		sum[i] = sum[i - 1] + pos[i];
	memset(dp, 0x3f, sizeof(dp));
	for (int i = 1; i <= nbNode; ++i)
		dp[1][i] = Cal(1, i);
	for (int num = 2; num <= nbPost; ++num) {
		head = 1, tail = 0;
		for (int i = num; i <= nbNode; ++i) {
			if (head <= tail)
				Q[head].lEP = i;
			if (head <= tail && Q[head].lEP > Q[head].rEP)
				++head;
			if (head > tail || dp[num - 1][i - 1] + Cal(i, nbNode) <
							   dp[num - 1][Q[tail].pos] + Cal(Q[tail].pos + 1, nbNode)) {
				while (head <= tail && dp[num - 1][i - 1] + Cal(i, Q[tail].lEP) <=
									   dp[num - 1][Q[tail].pos] + Cal(Q[tail].pos + 1, Q[tail].lEP))
					--tail;
				if (head > tail)
					Q[++tail] = Strategy(i, nbNode, i - 1);
				else {
					int lEP = Q[tail].lEP, rEP = Q[tail].rEP;
					while (rEP > lEP) {
						int mid = (lEP + rEP + 1) >> 1;
						if (dp[num - 1][i - 1] + Cal(i, mid) >= 
							dp[num - 1][Q[tail].pos] + Cal(Q[tail].pos + 1, mid))
							lEP = mid;
						else rEP = mid - 1;
					}
					Q[tail].rEP = lEP;
					Q[++tail] = Strategy(lEP + 1, nbNode, i - 1);
				}
			}
			if (i >= num)
				dp[num][i] = min(dp[num][i], dp[num - 1][Q[head].pos] + Cal(Q[head].pos + 1, i));
		}
	}
	printf("%d\n", dp[nbPost][nbNode]);
	return 0;
}
```



---

## 作者：chenxinyang2006 (赞：2)

斜率优化分组dp模板题，由于很水，所以直接把分组dp、斜率优化一起讲了。

* 分组dp模板：

用$dp[i][j]$表示前i个分成j组的最小花费，状态转移方程：

$dp[i][j] = min(dp[i][j],dp[k][j - 1] + cost(k + 1,i))$

k是分界点，将k + 1 ~ i分成一组，cost(k + 1,i)表示把k + 1 ~ i分成一组的花费。

* 40分解法

回到这道题上，考虑一下k + 1 ~ i中选一个地方放邮局，放哪里最合适

由初一知识得 ~~不会重新学初一数轴去~~ ：

如果有奇数个点，放在中间点上

如果有偶数个点，放在两个中间点之间的所有点都行

~~所以无脑取中间点就行了，分类写出来干什么~~

设中点为cut,花费为$(p[cut + 1] - p[cut]) + (p[cut + 2] - p[cut]) + …… (p[i] - p[cut]) + $

$(p[cut] - p[k + 1]) + (p[cut] - p[k + 2]) + …… (p[cut] - p[cut - 1]$

前缀和求一下就行了，代码：

```cpp
#include <cstdio> 
#include <cstring>
#include <algorithm>
using namespace std;
int n,m,dp[3005][305],opt[3005][305],p[3005],sum[3005];

int main(){
    memset(dp,0x3f,sizeof(dp));
    memset(opt,-1,sizeof(opt));
    scanf("%d%d",&n,&m);
    for(int i = 1;i <= n;i++){
        scanf("%d",&p[i]);
    }
    sort(p+1,p+n+1);
    for(int i = 1;i <= n;i++){
        sum[i] = sum[i - 1] + p[i];
    }
    dp[0][0] = 0;
    for(int i = 1;i <= n;i++){
        for(int j = 1;j <= m;j++){
            if(j > i){
                break;
            }
            for(int k = 0;k < i;k++){
                int cut = (i + k + 1) / 2;
                int tmp = sum[i] - sum[cut] - p[cut] * (i - cut) + p[cut] * (cut - k - 1) - (sum[cut - 1] - sum[k]);
                if(dp[k][j - 1] + tmp < dp[i][j]){
                	dp[i][j] = dp[k][j - 1] + tmp;
                }
            }
        }
    }
    printf("%d\n",dp[n][m]);
    return 0;
}
```

* 100分做法

通过观察决策点选择，发现$opt[i][j - 1] <= opt[i][j] <= opt[i][j + 1] $

于是每次决策点就可以少判很多了，基本上是一个常数

但是由于$opt[i][j - 1]$和$opt[i][j + 1]$只能选一个，所以上限选$opt[i][j + 1]$，下限选$opt[i - 1][j]$，代码：

```cpp
#include <cstdio> 
#include <cstring>
#include <algorithm>
using namespace std;
int n,m,dp[3005][305],opt[3005][305],p[3005],sum[3005];

int main(){
    memset(dp,0x3f,sizeof(dp));
    memset(opt,-1,sizeof(opt));
    scanf("%d%d",&n,&m);
    for(int i = 1;i <= n;i++){
        scanf("%d",&p[i]);
    }
    sort(p+1,p+n+1);
    for(int i = 1;i <= n;i++){
        sum[i] = sum[i - 1] + p[i];
    }
    dp[0][0] = 0;
    for(int i = 1;i <= n;i++){
        for(int j = m;j >= 1;j--){//这里得倒过来
            if(j > i){
                continue;
            }
            int mn = opt[i - 1][j];
            int mx = opt[i][j + 1];
            if(mn == -1){//有可能那个状态根本不存在
            	mn = 0;
            }
            if(mx == -1){
            	mx = i - 1;
            }
            for(int k = mn;k <= mx;k++){
                int cut = (i + k + 1) / 2,tmp;
                if(k == 0){
                	tmp = sum[i] - sum[cut] - p[cut] * (i - cut) + p[cut] * (cut - k - 1) - sum[cut - 1];
                }else{
                	tmp = sum[i] - sum[cut] - p[cut] * (i - cut) + p[cut] * (cut - k - 1) - (sum[cut - 1] - sum[k]);
                } 
                if(dp[k][j - 1] + tmp < dp[i][j]){
                	dp[i][j] = dp[k][j - 1] + tmp;
                	opt[i][j] = k;
                }
            }
        }
    }
    printf("%d\n",dp[n][m]);
    return 0;
}
```


---

## 作者：天梦 (赞：0)

# P4767 [IOI2000]邮局 

二维的四边形不等式要比一维难证一些，事实上，在真正的考场上，一般都是打表找规律。

这个题的 dp 方程是 $f_{i,j}=\min\limits_{i-1\le k\le j-1}\{f_{i-1,k}+w(k+1,j) \}$

其中 $f_{i,j}$ 为前 $j$ 个村庄里设置 $i$ 个邮局的最优解是多少。如果令 $d_i$ 为村庄 $i$ 的位置，$sum_i$ 为 $\sum_{j=1}^id_j$ ，那么 $w(i,j)=(2mid-i+1-j)d_{mid}+(sum_{i-1}+sum_j-2sum_{mid})$ ，其中 $mid=\left\lfloor \frac{i+j}2 \right\rfloor$

这里给大家提供一个暴力打表程序：

```c++
#include<bits/stdc++.h>
#define dd double
#define ld long double
#define ll long long
#define uint unsigned int
#define ull unsigned long long
#define N 10010
#define M number
using namespace std;

const int INF=0x3f3f3f3f;

template<typename T> inline void read(T &x) {
    x=0; int f=1;
    char c=getchar();
    for(;!isdigit(c);c=getchar()) if(c == '-') f=-f;
    for(;isdigit(c);c=getchar()) x=x*10+c-'0';
    x*=f;
}

int V,P,d[N],sum[N],f[N][N],g[N][N];

inline int w(int i,int j){
    int mid=(i+j)>>1;
    return (2*mid-i+1-j)*d[mid]+(sum[i-1]+sum[j]-2*sum[mid]);
}

int main(){
    //freopen("my.in","r",stdin);
    //freopen("my.out","w",stdout);
    read(V);read(P);
    for(int i=1;i<=V;i++) read(d[i]),sum[i]=sum[i-1]+d[i];
    memset(f,INF,sizeof(f));f[0][0]=0;
    for(int i=1;i<=P;i++){
        for(int j=i;j<=V;j++){
            for(int k=i-1;k<=j-1;k++){
                // f[i][j]=min(f[i][j],f[i-1][k]+w(k+1,j));
                if(f[i][j]>f[i-1][k]+w(k+1,j)){
                    f[i][j]=f[i-1][k]+w(k+1,j);
                    g[i][j]=k;
                }
            }
            printf("i:%d j:%d f:%d\n",i,j,f[i][j]);
            // printf("i:%d j:%d g:%d\n",i,j,g[i][j]);
        }
    }
    for(int i=1;i<=P;i++){
        for(int j=1;j<=V;j++) printf("%d ",g[i][j]);
        printf("\n");
    }
    printf("%d",f[P][V]);
    return 0;
}
```

正解代码：

```c++
#include<bits/stdc++.h>
#define dd double
#define ld long double
#define ll long long
#define uint unsigned int
#define ull unsigned long long
#define N 3010
#define M 310
using namespace std;

const int INF=0x3f3f3f3f;

template<typename T> inline void read(T &x) {
    x=0; int f=1;
    char c=getchar();
    for(;!isdigit(c);c=getchar()) if(c == '-') f=-f;
    for(;isdigit(c);c=getchar()) x=x*10+c-'0';
    x*=f;
}

template<typename T> inline T Max(T a,T b){
    return a<b?b:a;
}

ll V,P,d[N],sum[N],f[M][N],g[M][N];

inline int w(int i,int j){
    int mid=(i+j)>>1;
    return (2*mid-i+1-j)*d[mid]+(sum[i-1]+sum[j]-2*sum[mid]);
}

int main(){
    //freopen("my.in","r",stdin);
    //freopen("my.out","w",stdout);
    read(V);read(P);
    for(int i=1;i<=V;i++) read(d[i]),sum[i]=sum[i-1]+d[i];
    memset(f,INF,sizeof(f));f[0][0]=0;
    for(int i=1;i<=P;i++){
        g[i][V+1]=V-1;
        for(int j=V;j>=i;j--){
            for(int k=g[i-1][j];k<=g[i][j+1];k++){//g[i][j+1]
                // f[i][j]=min(f[i][j],f[i-1][k]+w(k+1,j));
                if(f[i][j]>f[i-1][k]+w(k+1,j)){
                    f[i][j]=f[i-1][k]+w(k+1,j);
                    g[i][j]=k;
                }
            }
            // printf("i:%d j:%d f:%d\n",i,j,f[i][j]);
            // printf("i:%d j:%d g:%d\n",i,j,g[i][j]);
        }
    }
    // for(int i=1;i<=P;i++){
    //     for(int j=1;j<=V;j++) printf("%d ",g[i][j]);
    //     printf("\n");
    // }
    printf("%lld",f[P][V]);
    return 0;
}
```

可以看出，正解和暴力没有什么太大区别，对于一维的决策单调性，虽然好证，但是打起来麻烦，二维的难证，但是打起来不麻烦，只需要注意一下是倒序枚举就可以了。

---


# [MtOI2018] 情侣？给我烧了！

## 题目背景

FFF

本题加强版：[P4931](https://www.luogu.com.cn/problem/P4931)

## 题目描述

有 $n$ 对情侣来到电影院观看电影。在电影院，恰好留有 $n$ 排座位，每排包含 $2$ 个座位，共 $2×n$ 个座位。

现在，每个人将会随机坐在某一个位置上，且恰好将这 $2 × n$ 个座位坐满。

如果一对情侣坐在了同一排的座位上，那么我们称这对情侣是和睦的。

你的任务是求出当 $k = 0, 1, ... , n$ 时，共有多少种不同的就坐方案满足**恰好**有 $k$ 对情侣是和睦的。

两种就坐方案不同当且仅当存在一个人在两种方案中坐在了不同的位置。不难发现，一共会有 $(2n)!$ 种不同的就坐方案。

由于结果可能较大，因此输出对 $998244353$ 取模的结果。

## 说明/提示

### 子任务

本题只有一个 $T=1000$ 的数据点。。。暴力还是算了吧！      

### 题目来源

[MtOI2018 迷途の家の水题大赛](https://www.luogu.org/contest/11260) T2

出题人：Imagine

50167

## 样例 #1

### 输入

```
2
1
2
```

### 输出

```
0
2
16
0
8
```

# 题解

## 作者：fwat699 (赞：32)

### 题意
[题意很清楚 \滑稽](https://www.luogu.org/problemnew/show/P4921)
### 分析
- 对于每一个询问 $k$ ，记 $g(x)$ 表示 $x$ 对情侣**都错开**的方案总数，那么答案可以写成如下形式：
$$ {ans}_k= \binom{n}{k}\times A_n^k\times 2^k\times g(n-k) $$
- 考虑如何求 $g(x)$ (一个错位排列)。
  
- 考虑第一排，一共有三种情况：两男两女或者一男一女(不配对)。

  - **两男**：顺次选出两男的方案数为 $x(x-1)$ ,然后考虑他们的配偶在之后的配对情况：
    
         1. 如果强制不配对，那么把她们看成一对情侣来保证之后的过程中不配对(~~gay里gay气~~)，即 $g(x-1)$ 。
    
         2. 如果强制配对，那么在剩下的 $x-1$ 排中选择一排，两人顺序可以交换，转移为 $2(x-1)\times g(x-2)$。
    
  - **两女**：方案数显然和两男的情况相同。
   
  - **一男一女**：枚举一男一女，可以交换顺序的方案数为 $x(x-1)$ ，转移其实是一样的。

- 所以我们得到：$g(x)=4x(x-1)\times[g(x-1)+2(x-1)\times g(x-2)]$ 。

- 单次处理 $g$ 复杂度 $O(n)$ ，每次回答枚举 $k$ 复杂度 $O(n)$ ，总时间复杂度为 $O(Tn)$ 。


### 代码

~~~cpp
#include<bits/stdc++.h>
using namespace std;
#define rep(i,a,b) for(int i=a;i<=b;++i)
#define pb push_back
typedef long long LL;
inline int gi(){
	int x=0,f=1;char ch=getchar();
	while(!isdigit(ch))	{if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)){x=(x<<3)+(x<<1)+ch-48;ch=getchar();}
	return x*f;
}
template<typename T>inline bool Max(T &a,T b){return a<b?a=b,1:0;}
template<typename T>inline bool Min(T &a,T b){return b<a?a=b,1:0;}
const int N=2004,mod=998244353;
int T,n;
LL fac[N],inv[N],invfac[N],bin[N],g[N];
void add(LL &a,LL b){a+=b;if(a>=mod) a-=mod;}
LL Pow(LL a,LL b){
	LL res=1ll;
	for(;b;b>>+1,a=a*a%mod) if(b&1) res=res*a%mod;
	return res;
}
LL C(int n,int m){
	return fac[n]*invfac[n-m]%mod*invfac[m]%mod;
}
int main(){
	fac[0]=invfac[0]=inv[1]=bin[0]=1;
	rep(i,1,N-1){
		if(i^1) inv[i]=(mod-mod/i)*inv[mod%i]%mod;
		fac[i]=fac[i-1]*i%mod;
		invfac[i]=invfac[i-1]*inv[i]%mod;
		bin[i]=bin[i-1]*2%mod;
	}
	
	g[0]=1,g[1]=0;
	rep(n,2,1000) g[n]=4ll*n*(n-1)%mod*(g[n-1]+2*(n-1)*g[n-2])%mod;
	
	T=gi();
	while(T--){
		n=gi();
		rep(k,0,n) printf("%lld\n",C(n,k)*C(n,k)%mod*fac[k]%mod*bin[k]%mod*g[n-k]%mod);
	}
	return 0;
}

~~~
[blog](https://www.cnblogs.com/yqgAKIOI/p/9807188.html)

---

## 作者：辰星凌 (赞：17)

# **【题解】情侣？给我烧了！[MtOI2018] [P4921]**

[$\mathcal{My}\ \mathcal{Blog}$](https://www.cnblogs.com/Xing-Ling/p/13357455.html)

传送门：[情侣？给我烧了！$\text{[MtOI2018] [P4921]}$](https://www.luogu.com.cn/problem/P4921)

## **【题目描述】**

共 $T$ $(T\leqslant 1000)$ 次询问，每次给出一个正整数 $n$ $(n\leqslant 1000)$ ，表示有 $n$ 对情侣和 $n$ 排座位（每排有两个位置），对于 $k\in[0,n]$，求出**恰好**有 $k$ 对情侣坐在同一排的方案数。

## **【分析】**

> 组合意义天地灭，代数推导保平安。 —— tiger0133

这里提供一个不需要费脑子的二项式反演做法（其实柿子都一样，只是这样做更易理解）。

题面加粗黑体字已经给出了很明显的提示，按照套路先设计两个状态：

$f(i)$：**恰好**有 $i$ 对情侣坐在一排的方案数。

$g(i)$：**至少**有 $i$ 对情侣坐在一排的方案数。

易知 $g(k)=\sum_{i=k}^{n}C_{i}^{k}f(i)$ 。

由二项式反演可得：$f(k)=\sum_{i=k}^{n}(-1)^{i-k}C_{i}^{k}g(i)$ 。

其中 $g(i)=C_{n}^{i}A_{n}^{i}(2!)^{i}(2n-2i)!$，$C_{n}^{i}$ 表示的是选定坐同一排的某 $i$ 对情侣，$A_{n}^{i}$ 为选定某 $i$ 排，$(2!)^{i}$ 为这 $i$ 对情侣内部顺序的乘积，$(2n-2i)!$ 表示剩下的人可以随便排。

则：  
$$\begin{aligned}f(k)&=\sum_{i=k}^{n}(-1)^{i-k}C_{i}^{k}C_{n}^{i}A_{n}^{i}(2!)^{i}(2n-2i)!\\&=\sum_{i=0}^{n-k}(-1)^{i}C_{i+k}^{k}C_{n}^{i+k}A_{n}^{i+k}2^{i+k}(2n-2k-2i)!\\&=\sum_{i=0}^{n-k}(-1)^{i}\frac{(i+k)!}{k!i!}\frac{n!}{(i+k)!(n-i-k)!}\frac{n!}{(n-i-k)!}2^{i+k}(2n-2k-2i)!\\&=\frac{2^{k}(n!)^2}{k!}\sum_{i=0}^{n-k}\frac{(-1)^{i}2^{i}}{i!}\frac{(2n-2k-2i)!}{((n-k-i)!)^{2}} \end{aligned}$$

观察后面那个求和柿子，其值只与给定的上界 $n-k$ 有关，在同一上界下对于不同的 $n$ 都是一样的结果。把它预处理出来即可 $O(1)$ 查询。

时间复杂度为：$O(n^2+Tn)$ 。预处理的那个柿子是个卷积的形式，可以用 $\text{NTT}$ 优化到 $O(n\log n)$，但意义不大，也过不了加强版。

## **【Code】**

```cpp
#include<algorithm>
#include<cstring>
#include<cstdio> 
#define LL long long
#define Re register int
using namespace std;
const int N=2003,P=998244353;
int n,T,h[N],Mi[N],jc[N],inv[N],invjc[N];
inline void in(Re &x){
    int f=0;x=0;char c=getchar();
    while(c<'0'||c>'9')f|=c=='-',c=getchar();
    while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=getchar();
    x=f?-x:x;
}
int main(){
//    freopen("123.txt","r",stdin);
    inv[1]=Mi[0]=jc[0]=jc[1]=invjc[0]=invjc[1]=1,Mi[1]=2;
    for(Re i=2;i<=2000;++i)jc[i]=(LL)jc[i-1]*i%P,inv[i]=(LL)inv[P%i]*(P-P/i)%P,invjc[i]=(LL)invjc[i-1]*inv[i]%P,Mi[i]=(Mi[i-1]<<1)%P;
    for(Re i=0;i<=1000;++i)
        for(Re j=0;j<=i;++j)
            (h[i]+=(LL)((j&1)?P-1:1)*invjc[j]%P*Mi[j]%P*jc[i-j<<1]%P*invjc[i-j]%P*invjc[i-j]%P)%=P;
    in(T);
    while(T--){
        in(n);
        for(Re k=0;k<=n;++k)printf("%lld\n",(LL)jc[n]*jc[n]%P*invjc[k]%P*Mi[k]%P*h[n-k]%P);
    }
}
```


---

## 作者：81179332_ (赞：16)

设 $g(n)$ 表示 $n$ 对情侣全部错开的方案数

答案很好表示：

$$ans_k=\dbinom n k\times A_n^k\times 2^k\times g(n-k)$$

表示从 $n$ 对座位中选出 $k$ 对给和谐的情侣，从 $n$ 对情侣中有序地选出 $k$ 对和谐的情侣放入，每对情侣可以男生坐左面或男生坐右面

那么我们求出 $g(i)$ 即可

我们在第一排放不和谐的两个人，容易发现，由于他们坐一块了，则他们的情侣都无法配对了，所以他们以及他们的情侣是男是女无所谓

分情况

若他们的两个情侣坐在了一起，则我们需要再选出一排安排给他们，方案数为 $2(i-2)\times g(i-2)$，乘二是考虑两人可以交换位置

若他们的两个情侣没坐在一起，那我们不妨将他们看成一对配对失败的情侣，则方案数为 $g(i-1)$

从 $2i$ 个人中选出不为情侣的两个人的方案数为：$2i(2i-2)=4i(i-1)$

则 $g(i)=4i(i-1)\times(g(i-1)+2(i-1)\times g(i-2))$

```cpp
//timeuse:20min
const int N = 1010;
ll fac[N],ifac[N],g[N],t[N];
ll C(int n,int m) { return fac[n] * ifac[n - m] % mod * ifac[m] % mod; }
int main()
{
	int n = 1000;
	fac[0] = 1;for(int i = 1;i <= n;i++) fac[i] = fac[i - 1] * i % mod;
	ifac[n] = qpow(fac[n],mod - 2);for(int i = n;i;i--) ifac[i - 1] = ifac[i] * i % mod;
	t[0] = 1;for(int i = 1;i <= n;i++) t[i] = Mod(t[i - 1] * 2);
	g[0] = 1,g[1] = 0;
	for(int i = 2;i <= n;i++)
		g[i] = 4 * i * (i - 1) % mod * (g[i - 1] + 2 * (i - 1) * g[i - 2] % mod) % mod;
	int T = read();
	while(T--)
	{
		n = read();
		for(int k = 0;k <= n;k++)
			fprint(C(n,k) * C(n,k) % mod * fac[k] % mod * t[k] % mod * g[n - k] % mod);
	}
	return 0;
}
```

---

## 作者：Yajnun (赞：9)

### 用$sum\left ( n,k \right )$表示考虑座位顺序下，$n$对情侣中有$k$对和睦的方案总数，  $a\left [ n \right ]$表示n对情侣全部不和睦的方案总数
###  从$n$对座位中取出$k$对用来盛放和睦的情侣，方案数为$C_{k}^{n}$；从$n$对情侣考虑顺序地选择这$k$对座位，方案数为$A_{k}^{n}$；k对和睦的情侣均有ＡＢ与ＢＡ两种选择方式，方案数为$2_{}^{k}$；剩下的n-k对情侣全部不和睦，对答案贡献为$a\left [ n-k \right ]$
## $sum\left ( n,k \right )=C_{k}^{n}*A_{k}^{n}*2_{}^{k}*a\left [ n-k \right ]$

### $n$对情侣，共有$n*2$人，座位方案总数为$(n*2)!$，全部不和睦的方案数，即为所有方案减去存在和睦情侣的方案数

## $a\left [ n \right ]=(n*2)!-\sum _{i=1}^{n}sum\left ( n,i \right )$
代码：
```c

ll sum(ll n,ll k)
{	return C[n][k]*C[n][k]*fac[k]*pow[k]*a[n-k];}
void pre()
{
    pow[0]=fac[0]=C[0][0]=a[0]=1;
    for(i,1,N)pow[i]=pow[i-1]<<1;
	for(i,1,N)fac[i]=fac[i-1]*i;
	for(i,1,N)for(j,0,i)C[i][j]=C[i-1][j-1]+C[i-1][j];
	for(i,1,N)
	{   
		ll cnt=0;
		for(j,1,i)cnt+=sum(i,j);
		a[i]=fac[2*i]-cnt;
	}
}
```

---

## 作者：warzone (赞：8)

组合意义，数学都会一点，但都不精通 QAQ  

---------
首先设 $ans_{n,k}$ 表示 $n$ 对座位，恰好 $k$ 对情侣和睦的方案总数，则   
$$ans_{n,k}=\binom{n}{k}\times\binom{n}{k}\times k!\times 2^k\times ans_{n-k,0}$$
- 第一个 $\dbinom{n}{k}$ 表示 $n$ 对座位中选出 $k$ 个。
- 第二个 $\dbinom{n}{k}$ 表示 $n$ 对情侣中选出 $k$ 个。
- $k!$ 表示 $k$ 对和睦的情侣坐座位的顺序可随意排列。
- $2^k$ 表示每对和睦的情侣的左右顺序可随意调换。
- $ans_{n-k,0}$ 即剩下的情侣均不和睦。

------------------

那么问题转化为求 $ans_{k,0}$，题目已经给出了提示：

不难发现，一共会有 $(2n)!$ 种不同的就坐方案。

于是 $\forall n\in\mathbf{N},\displaystyle\sum_{k=0}^nans_{n,k}=(2n)!$	。

拆开 $ans_{n,k}$ 得到 

$$ans_{n,k}=\frac{(n!)^2}{(k!)^2[(n-k)!]^2}k!2^kans_{n-k,0}$$
$$ans_{n,k}=(n!)^2\times\frac{2^k}{k!}\times\frac{ans_{n-k,0}}{[(n-k)!]^2}$$
$$\forall n\in\mathbf{N},\sum_{k=0}^n\frac{2^k}{k!}\times\frac{ans_{n-k,0}}{[(n-k)!]^2}=\frac{(2n)!}{(n!)^2}$$

----------------------

注意到左边是个卷积形式，且 $e^x=\displaystyle\sum_{k=0}^\infty\frac{x^k}{k!}$。  
设 $f_k=\displaystyle\frac{ans_{k,0}}{(k!)^2},f(x)=\sum_{k=0}^\infty f_kx^k,g_k=\displaystyle\frac{(2k)!}{(k!)^2},g(x)=\sum_{k=0}^\infty g_kx^k$，则  
$$e^{2x}f(x)=g(x)$$  

由 $g_{k+1}=\dfrac{(2k+2)(2k+1)}{(k+1)^2}g_k=\dfrac{4k+2}{k+1}g_k$ 可得  
$$(k+1)g_{k+1}=4kg_k+2g_k\ (k\ge0)$$

转换为生成函数： $g'(x)=4xg'(x)+2g(x)$

$$g'(x)=\frac{2}{1-4x}g(x)$$

注意到这是个一阶齐次线性微分方程，~~bdfs~~ 可得其解为 

$g(x)=Ce^{P(x)},P(x)=\displaystyle\int\frac{2}{1-4x},C$ 为常数。

由 $g(0)=g_0=\dfrac{0!}{(0!)^2}=1,P(0)=0,e^0=1$ 可得 $C=1$，于是

$$e^{2x}f(x)=e^{P(x)},P(x)=\int\frac{2}{1-4x}$$
$$f(x)=e^{P(x)-2x}$$

-------------------------

~~bdfs~~ 得到的求解微分方程的过程给了我们一定启发，于是求导得

$$f'(x)=e^{P(x)-2x}(P(x)-2x)'$$
$$f'(x)=f(x)(\frac{2}{1-4x}-2)$$
$$(1-4x)f'(x)=2f(x)(1-1+4x)$$
$$f'(x)-4xf'(x)=8xf(x)$$
$$f'(x)=8xf(x)+4xf'(x)$$

再转换回数列，可得
$$(k+1)f_{k+1}=8f_{k-1}+4kf_k$$

$$f_{k+1}=\frac{8f_{k-1}+4kf_k}{k+1}$$

---------------------------------

最后只剩下递推的边界条件了。

- $f_0=f(0)=e^{P(0)-2\times 0}=e^0=1$
- $n=1$ 时，就坐的唯一一对情侣必然是和睦的，因此 $f_1=ans_{1,0}=0$ 。

整理，写出总式：

$$f_0=1,f_1=0,f_{k+1}=\frac{8f_{k-1}+4kf_k}{k+1}$$
$$ans_{n,k}=(n!)^2\times\frac{2^k}{k!}\times f_{n-k}$$

以上均可一次 $\Theta(n)$ 搞定。

```cpp
#include<stdio.h>
#include<string.h>
typedef long double ld;
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned int word;
typedef unsigned short hword;
typedef unsigned char byte;
struct READ{
	char c;
	inline READ(){c=getchar();}
	template<typename type>
	inline READ& operator>>(register type& num){
		while('0'>c||c>'9') c=getchar();
		for(num=0;'0'<=c&&c<='9';c=getchar())
			num=num*10+(c-'0');
		return *this;
	}
}cin;
const word mod=998244353;
inline ull pow(register ull a,register word b){
	register ull ans=1;
	for(;b;b>>=1){
		if(b&1) (ans*=a)%=mod;
		(a*=a)%=mod;
	}
	return ans;
}
word root[5<<20],inv[5<<20];
word f[5<<20],exp[5<<20];
int main(){
	root[0]=inv[0]=exp[0]=f[0]=1;
	for(register ull i=1;i<5<<20;++i){
		root[i]=i*root[i-1]%mod;
		exp[i]=(exp[i-1]<<1)%mod;
	}
	inv[(5<<20)-1]=pow(root[(5<<20)-1],mod-2);
	for(register ull i=(5<<20)-1;i;--i){
		inv[i-1]=i*inv[i]%mod;
		exp[i]=(ull)(exp[i])*inv[i]%mod;
	}
	for(register ull i=1;i<(5<<20)-1;++i){
		f[i+1]=(i*4%mod*f[i]%mod)+(8ll*f[i-1]%mod);
		f[i+1]=(ull)(f[i+1]%mod)*inv[i+1]%mod*root[i]%mod;
	}
	word t;
	register word n,k;
	for(cin>>t;t;--t){
		cin>>n>>k;
		printf("%llu\n",(ull)(root[n])*root[n]%mod*exp[k]%mod*f[n-k]%mod);
	}
	return 0;
}
```

---

## 作者：hzoi_liuchang (赞：4)

## 分析
我们设 $f[x]$ 为恰好有 $x$ 对情侣都错开的方案数

我们考虑如何把其分解为子问题

首先我们可以从这 $2x$ 个人中随意选取一个人

接下来我们再选取一个不能与他配对的人

总的方案数为 $2x(2x-2)$

对于我们选出的这两个人的配偶，如果我们把他们也强制配对的话那么这相当于一个规模为 $x-2$ 的子问题，同时我们还要乘上 $x-1$ 代表在剩下的 $x-1$ 行中选出一行给他们坐，他们还可以交换位置，所以还要乘 $2$

如果我们不给他们强制配对的话，那么这就是一个规模为 $x-1$ 的子问题

初始化 $f[0]=1, f[1]=0$

转移方程 $f[x]=2x(2x-2)(f[x-1]+2(x-1)f[x-2])$

我们考虑了恰好有 $k$ 对情侣错开的的情况，下面要考虑本题的求解，即恰好有 $k$对情侣和睦的就坐方案数

首先我们要在 $n$ 对情侣中选出 $k$ 对情侣和睦，还要在 $n$ 排座位中选出 $k$ 排让他们坐，每对情侣在这 $k$ 排可以随便坐，情侣两人也可以互换位置

因此最终的结果为

$$C_n^k\times C_n^k \times  k! \times 2^k \times f[n-k]%mod$$

## 代码
``` cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod=998244353;
const int maxn=5e6+5;
int ny[maxn],jc[maxn],jcc[maxn],f[maxn];
int ksm(int ds,int zs){
	int ans=1;
	while(zs){
		if(zs&1) ans=ans*ds%mod;
		ds=ds*ds%mod;
		zs>>=1;
	}
	return ans%mod;
}
signed main(){
	ny[1]=1;
	for(int i=2;i<maxn;i++){
		ny[i]=(mod-mod/i)*ny[mod%i]%mod;
	}
	jc[0]=1,jcc[0]=1;
	for(int i=1;i<maxn;i++){
		jc[i]=jc[i-1]*i%mod;
		jcc[i]=jcc[i-1]*ny[i]%mod;
	}
	f[0]=1,f[1]=0;
	for(int i=2;i<maxn;i++){
		f[i]=2*i*(2*i-2)%mod*(f[i-1]%mod+(2*i-2)*f[i-2]%mod)%mod;
	}
	int t;
	scanf("%lld",&t);
	while(t--){
		int n;
		scanf("%lld",&n);
		for(int k=0;k<=n;k++){
			int ans=jc[n]*jcc[k]%mod*jcc[n-k]%mod*jc[n]%mod*jcc[n-k]%mod*ksm(2,k)%mod*f[n-k]%mod;
			printf("%lld\n",ans%mod);
		}
	}
	return 0;
}


```

---

## 作者：姬小路秋子 (赞：3)

这题的题解被出题人鸽了，所以只好来补一个喽。。

对于每组n,k，我们可以将要坐在一起的m对情侣从n对中选出来，这样方案数是Cn,m。

然后将m对情侣选出m排座位坐上去，在加个全排列，这样的方案数是Cn,m*m!

**然后放剩下的n-m对情侣。**

这步有点麻烦。我们设dp[i][j]表示前i对情侣，有j排座位是坐一个人的情况下，没有一对情侣坐一起的方案。

为了保证**没有一对情侣坐一起**，我们一次放一对情侣，并使他们不坐在一起。

那么dp[i][j]可以由 dp[i-1][j+2]（选了两排坐了一个人的座位）*(j+2)*(j+1)

                  dp[i-1][j]（一个坐到已有一个人的那排，另一个坐到没有人的一排，即往后加上一排）*j（这个j指随便选一排已有一个人的） 
                  
                  dp[i-1][j-2](两个都坐到没人的那两排)
                  
 乘一下组合数什么的就好了。
 
 代码：
 ```c
#include<bits/stdc++.h>
using namespace std;
long long ii,dp[1001][1001],la[1001],n,t1,i,j,p=998244353,fac[1001],c[1001][1001],f[1001],er[1001],ans;
int main(){
	fac[0]=er[0]=1ll;
	for(i=1;i<=1000;i++)fac[i]=fac[i-1]*i%p;
	for(i=1;i<=1000;i++)er[i]=er[i-1]*2ll%p;
	//for(i=1;i<=5;i++)printf("%lld %lld %lld\n",i,fac[i],er[i]);
	c[1][0]=c[1][1]=1ll;
	for(i=2;i<=1000;i++){
		c[i][0]=1ll;
		for(j=1;j<=i;j++)c[i][j]=(c[i-1][j-1]+c[i-1][j])%p;
	}
	f[0]=1ll;f[1]=0ll;
	for(i=1;i<=1000;i++){
		f[i]=(i-1)*(f[i-1]+f[i-2])%p;
	}
	dp[1][2]=1ll;
	la[0]=1ll;
	for(i=2;i<=1000;i++){
		for(j=0;j<=1000;j++){
		 if((i*2-j)&1)continue;
		 ii=(i*2-j)/2+j;
		 dp[i][j]=(dp[i][j]+dp[i-1][j+2]*(j+2)*(j+1))%p;
		 dp[i][j]=(dp[i][j]+dp[i-1][j]*j*2ll)%p;
		 if(j>=2)dp[i][j]=(dp[i][j]+dp[i-1][j-2])%p;
		 if(!j)la[i]=dp[i][j]*(fac[i])%p*er[i]%p; 
	}
	}
	/*printf("%lld %lld\n",dp[3][0],dp[4][0]);
	for(i=1;i<=2;i++) 
	 for(j=0;j<=3;j++)printf("%lld %lld %lld\n",i,j,dp[i][j]);*/
	scanf("%lld",&t1);
	while(t1--){
		scanf("%lld",&n);
		for(i=0;i<=n;i++){
			ans=c[n][i]*c[n][i]%p;
			ans=ans*er[i]%p;
			ans=ans*fac[i]%p;
			//printf("-1 %lld\n",ans);
			//printf("-2 %lld\n",ans);
			ans=ans*la[n-i]%p;
			printf("%lld\n",ans);
			//puts("");
		}
	}
}
```

---

## 作者：pomelo_nene (赞：2)

考虑定义 $ans_i$ 为 $k=i$ 时的答案，$f_i$ 为强制 $i$ 对情侣全部错开的情况种数。答案表示：

$$
ans_i = f_{n-i} \times \dbinom{n}{i} \times 2^i \times n^{\underline{i}}
$$

解释：$f_{n-i}$ 一项定义如上，$\dbinom{n}{i}$ 是要在 $n$ 对情侣中选 $i$ 对匹配的方案数，$2^i$ 是因为每一对情侣都有两种坐法，$n^{\underline{i}}=A_{n}^i$ 是因为要在 $n$ 对位置里面选择 $i$ 个让情侣坐下。

考虑计算 $f_i$。可以近似看成「[错排问题](https://www.luogu.com.cn/blog/P6174/post-cuo-pai)」，尝试用递推的方式去求出，分类讨论新加入的不匹配的一堆情侣。

因为加入不合法，一定是两对情侣分别拆出来一个人进行匹配。假设现在在求 $f_i$，于是有：

- 若剩下的两个人匹配到一起了，我们还需要安排一对作为给他们，贡献即为 $(i-1) \times f_{i-2}$，注意可以交换位置，所以贡献还要乘上 $2$；   
- 否则，相当于一对匹配失败的情侣，我们在之后的匹配中保证他们不配对，方案数 $f_{i-1}$。

然后再考虑一下在 $2i$ 个人里面选不是一对情侣的方案数，即 $2i(2i-2)=4i(i-1)$。

至此推出递推式：

$$
f_i = 4i(i-1)(2(i-1) \times f_{i-2} + f_{i-1})
$$

预处理可以写成 $O(n)$ 或者 $O(n \log \bmod)$，但是在普通版不影响。时间复杂度 $O(nT)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL MOD=998244353;
LL QuickPow(LL n,LL p)
{
	LL base=n,ans=1;
	while(p)
	{
		if(p&1)	ans=ans*base%MOD;
		p>>=1;
		base=base*base%MOD;
	}
	return ans%MOD;
}
LL f[1005],pw[1005],fac[1005],inv[1005];
int main(){
	fac[0]=pw[0]=inv[0]=1;
	for(LL i=1;i<=1000;++i)	pw[i]=pw[i-1]*2%MOD,fac[i]=fac[i-1]*i%MOD,inv[i]=QuickPow(fac[i],MOD-2);
	f[0]=1;
	for(LL i=2;i<=1000;++i)	f[i]=4*i*(i-1)%MOD*(2*(i-1)*f[i-2]+f[i-1])%MOD;
	LL T;
	scanf("%lld",&T);
	while(T-->0)
	{
		LL n;
		scanf("%lld",&n);
		for(LL k=0;k<=n;++k)	printf("%lld\n",fac[n]*inv[k]%MOD*inv[n-k]%MOD*fac[n]%MOD*inv[n-k]%MOD*f[n-k]%MOD*pw[k]%MOD);
	}
	return 0;
}
```

---

## 作者：逃离地球 (赞：2)

### 题意
把 $n$ 对情侣安排在 $n$ 行 $2$ 列的座位中，要求恰好有 $k$ 对情侣坐在一排中，问有多少种排法。

### 题解
先考虑选出并排列坐在一起的 $k$ 对情侣，方案数为 $\binom{n}{k}^2\times k!\times 2^k$，其中 $\binom{n}{k}^2$ 为选出 $k$ 对情侣并选出 $k$ 行椅子的方案数，$k!$ 为 $k$ 对情侣排列顺序的方案数，$2^k$ 为每行情侣排列的方案数。设 $f_i$ 为 $i$ 对情侣都不坐在一排里的方案数（不考虑顺序），则最终答案为 $f_i\times 2^{n-k}\times(n-k)!\times\binom{n}{k}^2\times k!\times 2^k$。

再考虑计算 $f_i$，在这 $i$ 对情侣中任选一对，设为 $(a,b)$。设 $a$ 与 $c$ 坐在一起，且 $c$ 的情侣为 $d$，则可分类讨论为两种情况：

- 第一种是 $b$ 和 $d$ 坐在一起，则方案数为剩余 $i-2$ 对情侣不坐一起的情况数，即 $f_{i-2}$；
- 第二种情况是 $b$ 和 $d$ 不坐一起，那么就可以把 $b$ 和 $d$ 也看作一对不能坐一起的情侣，情况数就是剩余 $i-2$ 对情侣和 $b$ 和 $d$ 这对“情侣“排列的方案数，即 $f_{i-1}$。

则 $f_i=2(n-1)\times(f_{i-1}+f_{i-2})$，其中 $2(n-1)$ 为选出 $c$ 的方案数。则可以用递推预处理出 $f$ 数组和组合数、2 的幂等，然后 $O(k)$ 处理询问即可。

### 注意

$f(0)=1,f(1)=0$

---

## 作者：_ctz (赞：2)

[$My\ blog$](https://ctz45562.github.io/2019/05/23/%E6%B4%9B%E8%B0%B7-P4921-%E6%83%85%E4%BE%A3%EF%BC%9F%E7%BB%99%E6%88%91%E7%83%A7%E4%BA%86%EF%BC%81/)

[传送门](https://www.luogu.org/problemnew/show/P4921)

一眼看上去很像错排。$k$位错排问题可以先$C_n^{n-k}$选出配对的$n-k$个，剩下的$k$个完全错排。

用$f(n)$表示不考虑坐的次序（只考虑谁和谁坐一起），$n$对情侣完全错排的方案数。

然后考虑$n$对情侣至少$i$对的配对的方案数。

$C_n^i$选出配对的$i$对，剩下的$2n-2i$个人任意配对。这里定义$g(n)=\prod\limits_{i=1}^{\frac{n}{2}}(2i-1)$，则有$g(2n-2i)$种方案。

$g(n)$可以预处理，当然可以优雅地~~百度~~推导：

$$\prod\limits_{i=1}^{\frac{n}{2}}(2i-1)$$

$$=\dfrac{n!}{\prod\limits_{i=1}^{\frac{n}{2}}(2i)}$$

$$=\dfrac{n!}{(\frac{n}{2})!2^{\frac{n}{2}}}$$

套路地容斥一下：

$$f(n)=\sum\limits_{i=0}^{n}(-1)^iC_n^ig(2n-2i)$$

$$=\sum\limits_{i=0}^{n}(-1)^iC_n^i\dfrac{(2n-2i)!}{(n-i)!2^{n-i}}$$

对于任意$n$和$k$，就能先$C_n^k$选出配对的情侣，剩下的$f(n-k)$完全错排，考虑次序，有$n!$种排列，配对的两人之间可以互换，有$2^n$种情况。

答案就是$C_n^kf(n-k)n!2^n$，预处理阶乘、阶乘逆元、$2$的$n$次幂、$2$的$n$次幂的医院，$O(n^2)$预处理$f$，$O(n)$回答每个询问，足以通过普通版。

代码：

``` cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>

#define maxn 2005
#define inf 0x3f3f3f3f

const int mod = 998244353;

using namespace std;

inline int read(){
    int x=0,y=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return y?-x:x;
}
int pow2[maxn]={1},fac[maxn]={1},inv[maxn],inv2[maxn],f[maxn],n;
int INV(int x){return x==1?1:1ll*(mod-mod/x)*INV(mod%x)%mod;}
inline int C(int m,int n){return 1ll*fac[n]*inv[n-m]%mod*inv[m]%mod;}
inline long long pow_1(int x){return x&1?-1ll:1ll;}
int main(){
    for(register int i=1;i<=2000;++i)fac[i]=1ll*fac[i-1]*i%mod,pow2[i]=(pow2[i-1]<<1)%mod;
    inv[2000]=INV(fac[2000]),inv2[2000]=INV(pow2[2000]);
    for(register int i=1999;~i;--i)inv[i]=1ll*inv[i+1]*(i+1)%mod,inv2[i]=(inv2[i+1]<<1)%mod;
    for(register int i=0;i<=2000;f[i]=(f[i]+mod)%mod,++i)
        for(register int j=0;j<=i;++j)
            (f[i]+=pow_1(j)*C(j,i)%mod*fac[i-j<<1]%mod*inv[i-j]%mod*inv2[i-j]%mod)%=mod;
    int t=read();
    while(t--){
        n=read();
        for(register int i=0;i<=n;++i)
            printf("%d\n",1ll*C(i,n)%mod*f[n-i]%mod*pow2[n]%mod*fac[n]%mod);
    }
}
```

---

## 作者：Demoe (赞：1)

### [题目传送门](https://www.luogu.com.cn/problem/P4921)

~~七夕打卡圣地~~

## 题意

- 对于每个给定 $n$ 求对于所有 $k\in [0,n]\cap N$，求恰好 $k$ 对情侣坐一排的情况数。

## Sol

> 组合意义天地灭，代数推导保平安。

~~尛神虎~~

考虑直接表示答案。

$ans_{n,k}=\dbinom{n}{k}\times P^k_n \times 2^k \times g_{n-k}$

其中 $\dbinom{n}{k}$ 表示选取 $k$ 对座位的组合，$P^k_n$ 表示选取 $k$ 对情侣的排列，$2^k$ 表示情侣的左右位置。

那么显然，这里 $g_{n-k}$ 可以看出表示共 $n-k$ 对情侣**都错开**的情况数。

我们考虑递推这个柿子。

首先 $g_0=1$，$g_1=0$。

考虑现在推 $g_i$。

分两种情况讨论。

考虑分别设两对情侣 $(a,b)$ $(c,d)$。

不妨让 $a$ 和 $c$ 坐一排。

#### $b$ 和 $d$ 坐一排

即为 $g_{i-2}$ 递推过来。

有贡献为 $8n(n-1)^2g_{i-2}$。

#### $b$ 和 $d$ 不坐一排

那么因为考虑 $g$ 为错排，不妨**假设 $b$ 和 $d$ 为情侣**，

即可以由 $g_{i-1}$ 转移过来。

有贡献为 $4n(n-1)g_{i-1}$。

那么可得 $g_i=4n(n-1)g_{i-1}+8n(n-1)^2g_{i-2}$。

预处理 $g$ 阶乘 逆元 即可。

预处理复杂度 $O(N)$。

询问复杂度 $O(TN)$。

---


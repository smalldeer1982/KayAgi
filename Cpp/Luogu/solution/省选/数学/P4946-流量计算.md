# 流量计算

## 题目背景

NOIP2018原创模拟题T7

NOIP2018原创模拟赛DAY2 T2

NOIP DAY1 T2 or DAY2 T2 难度

相关电学知识请参考“说明”中的“背景知识”。

## 题目描述

你看了复杂的电路图，发现在初高中学的电路元件数都目比较少，因此你希望设计一个程序来分析元件数目更多的电路图，并进行一些计算。

经过苦苦思考，你终于找到了描述电路图的方法：

1.电路图可以用$n$个节点，$m$条无向边的连通图来表示，其中$n$表示导线交汇点，$m$表示元件个数，且电路元件只有电源和电阻

2.图中没有自环，但可能有重边

3.电路图**最复杂的情况是并联中嵌套串联**，**不会出现更复杂的电路**，例如下面的情况都不会出现：

![P1](https://cdn.luogu.com.cn/upload/pic/37113.png)

比如样例一便是一个满足条件的电路图（图片见样例一解释）

因为这是你第一次尝试，所以你决定电路中只包含电源与电阻，而且你决定计算电路中的最大电流与最小电流。

在理清思路后你就决定开始尝试了。

## 说明/提示

**背景知识：**

欧姆定理：$I=\frac{U}{R}$，其中$I$为电流，$U$为电压，$R$为电阻

串联：串联电路中电流相等，总电阻相当于电阻阻值之和

并联：并联电路中电压相等

串并联：即串联与并联结合

![P3](https://cdn.luogu.com.cn/upload/pic/37135.png)

**样例一解释：**

![P4](https://cdn.luogu.com.cn/upload/pic/37121.png)

如图，所有电阻等效电阻为$2Ω$，故最大电流为$\frac{6V}{2Ω}=3A$，在支线$2-3$或$2-4-3$中电流为$1.5A$，为最小电流

**样例二/三提示：**

样例二中所有电阻的等效电阻阻值为$\frac{6}{11}Ω$，且最小电流在支线$1-4-3$上，样例三中所有电阻的等效电阻阻值为$18Ω$

**数据范围：**

对于 30%数据，有：$n,m<=20$

对于 50%数据，有：$n<=10^3,m<=4\times 10^3$

对于 70%数据，有：$n<=5000,m<=2\times10^4$

对于100%数据，有：

1.$n<=2\times10^4,m<=5\times 10^4$，$0<=$电压$<=10^8$，$1<=$电阻$<=10^3$

2.只有有一个电源，电路不会有不规范的地方

3.最复杂的情况为并联中嵌套串联（如图A，当然支路可能更多，电阻串联数量有可能更多，但**支路不会出现并联**），保证**不会出现并联中再嵌套并联**（如图B的情况就不会出现）

![P5](https://cdn.luogu.com.cn/upload/pic/37253.png)

**特殊约定：**

20%数据保证：电路为纯串联电路

另外20%数据保证：电路为纯并联电路

## 样例 #1

### 输入

```
4 5
1 2 P 6
2 3 R 2
3 4 R 1
2 4 R 1
1 3 R 1```

### 输出

```
3.00
1.50```

## 样例 #2

### 输入

```
4 6
1 3 P 6
1 3 R 1
1 2 R 1
2 3 R 1
1 4 R 1
4 3 R 2```

### 输出

```
11.00
2.00```

## 样例 #3

### 输入

```
16 21
1 2 R 2
2 3 R 1
3 4 R 1
2 5 R 1
4 5 R 1
4 6 R 1
6 7 R 1
7 8 R 2
4 9 R 1
8 9 R 1
1 16 P 128
10 8 R 7
10 11 R 2
11 10 R 1
11 12 R 2
12 15 R 1
15 13 R 2
11 13 R 1
11 14 R 1
14 15 R 2
15 16 R 5```

### 输出

```
7.11
2.37```

# 题解

## 作者：Krimson (赞：4)

### 前置芝士：
1. 初中物理（大概初一初二水平？）

2. 图论（会建图就行） 

3. dfs  

  


------------
此处先以样例三为例  
![](https://cdn.luogu.com.cn/upload/image_hosting/i3ajpl4l.png)  

在读入数据之后很轻松就能建出一个这样的图，其中16是起点，1是终点  
但是电流是带有方向的，而上面这个图由于是无向边，不能很好地模拟电流  

于是考虑把上面的图转换成有向图  
![](https://cdn.luogu.com.cn/upload/image_hosting/t5jvm9r9.png)  
这样子就方便多了，只要遍历一遍图就可以求出总电阻了（~~电阻公式不用我多说了吧~~）  
根据串连电路的性质，最大电流肯定就是总电压除以总电阻  
而最小电流则肯定出现在某条并联电路的支路上面  
这里以上图中15->11这一段电路为例，设这一段的电阻为$R_\texttt{并}$  
于是求其中任意一段的电流就是$\frac {\frac {R_\texttt{总}}{R_\texttt{并}}*U}{R}$  
剩下的就是代码实现了  


------------
```cpp
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define ri register int
#define ll long long
const int MAXN=2e4+7,MAXM=5e4+7;
il ll read(){
    bool f=true;ll x=0;
    register char ch=getchar();
    while(ch<'0'||ch>'9') {if(ch=='-') f=false;ch=getchar();}
    while(ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
    if(f) return x;
    return ~(--x);
}
il void write(const ll &x){if(x>9) write(x/10);putchar(x%10+'0');}
vector<int> g[MAXN],vv[MAXN],to[MAXN],v[MAXN];//g,vv是一开始的无向边;to,v是后来的有向边
int n,m,be,ed;
ll power;//总电压
int mark[MAXN];//标记是否到达过
int cnt[MAXN],Cnt[MAXN];//用来建图的，可以理解为第一个是度，第二个是入度
//这三个用来记录并联电路的位置，电阻大小以及最大支路电阻
vector<int> bp;
vector<double> va;
vector<ll> maxs; 
bool flag=true;//建图时使用
bool fl[MAXN];//标记是否是并联电路
ll get(ll x,ll y){return x/(__gcd(x,y))*y;}
void dfs1(int now){
    if(now==ed) return;
    if(cnt[now]==1){//如果当前结点位置是一个串连电路
        mark[now]=1;
        for(ri i=0;i<g[now].size();++i){
            int x=g[now][i];
            if(mark[x]) continue;
            --cnt[x];
            ++Cnt[x];
            to[now].push_back(x),v[now].push_back(vv[now][i]);
            dfs1(x);
        }
    }
    else if(flag){//如果不是串连电路，且flag为真，那么就说明这个点是并联电路的起点
    //具体实现还是看代码吧
        fl[now]=true;
        bp.push_back(now);
        flag=false;
        mark[now]=1;
        for(ri i=0;i<g[now].size();++i){
            int x=g[now][i];
            if(mark[x]) continue;
            to[now].push_back(x),v[now].push_back(vv[now][i]);
            if(cnt[now]--==1){
                flag=true;
            }
            --cnt[x];
            ++Cnt[x];
            dfs1(x);
        }
    }
}
double ans=0;//总电阻
void get_ans(int rot){//用来求总电阻的
    while(rot!=ed){//如果进入了并联电路
        if(fl[rot]){
            double use=0;//该并联电路的总电阻
            ll rem=0;//该并联电路中最大的支路电阻
            int x=0;//当前结点位置
            for(ri i=0;i<to[rot].size();++i){
                //具体实现过程跟无向图转有向图过程差不多，由于前面已经转换过一遍，这个地方会好做很多
                ll sum=v[rot][i];
                x=to[rot][i];
                while(Cnt[x]==1){
                    sum+=v[x][0];
                    x=to[x][0];
                }
                ssum+=sum;
                use+=1.0/double(sum);
                rem=max(rem,sum);
            }
            va.push_back(1.0/use);
            rot=x;
            ans+=1.0/use;
            maxs.push_back(rem);
        }
        else{//如果是串连电路电阻直接累加就好了
            ans+=v[rot][0];
            rot=to[rot][0];
        }
    }
    printf("%.2lf\n",double(power)/ans);//输出最大电流
}
int main(){
    n=read(),m=read();
    for(ri i=1;i<=m;++i){
        int x=read(),y=read();
        char kind=getchar();
        int val=read();
        if(kind=='R'){
            g[x].push_back(y),g[y].push_back(x),++cnt[x],++cnt[y];
            vv[x].push_back(val),vv[y].push_back(val);
        }
        else{
            be=y,ed=x,power=val;
        }
    }
    dfs1(be);
    get_ans(be);
    double anss=double(power)/ans;//最小电流，初始为跟最大电流一样
    for(ri i=0;i<bp.size();++i){//在所有的并联电路中找到一个最小电流
        anss=min(anss,(va[i]/ans)*double(power)/maxs[i]);
    }
    printf("%.2lf",anss);
    return 0;
}
```
其实还有个地方可以优化一下,把公式优化一下可以得到  
$I_{min}=\frac {{R_\texttt{总}}*U}{\frac {R}{R_\texttt{并}}}$  ，等式上方是一个定值  
所以只要得到最大的$\frac {R}{R_\texttt{并}}$就可以了，这一步可以在算总电阻的时候一并计算  
~~懒得改了~~

---

## 作者：Voldermod (赞：3)

考察知识：图论，数学，推导，搜索

算法难度：XXXX 实现难度：XXXX

---

分析：

这道题需要大家有一定的电学知识和数学推导能力。

先推导几个电学结论：

结论一：对于串联电路，我们可以将所有电阻$R_1,R_2,...,R_n$看作一个等效电阻：$R_{\sum}=\sum_{i=1}^n R_i$

证明：易得，略

结论二：对于一个（等效）并联电路，电阻分别为等效电阻为：$R_{\sum}=\frac{1}{\sum_{i=1}^n \frac{1}{R_i}}$

证明：设电压为 U，由欧姆定律，总电流为：$I_{\sum}=\sum_{i=1}^n \frac{U}{R_i}$，故等效电阻为：$R_{\sum}=\frac{U}{I_{\sum}}=\frac{1}{\sum_{i=1}^n \frac{1}{R_i}}$

结论三：对于一个（等效）并联电路，电阻分别为，我们可以采取下面的算法计算等效电阻：

```cpp
double R_=R[1];
for(int i=2;i<=n;i++) R_=R_*R[i]/(R_+R[i]);
ans=R_;
```

证明：结论二的二维形式：$R_{1,2}=\frac{R_1R_2}{R_1+R_2}$，每次将两个电阻合并为一个等效电阻，最后的值即为总等效电阻

结论四：对于一个（等效）并联电路，电阻分别为$R_1,R_2,...,R_n$，其支路最小电流为：$\frac{R_{\sum}I_{\sum}}{max\{R_i\}}$

证明：我们知道，最小电流在电阻最大的支路上，即$max\{R_i\}$，而电压为$R_{\sum}I_{\sum}$，由$I=\frac{U}{R}$，就得到结论

有了这几个结论，我们就可以开始动手了：

1.先用结论三处理重边

2.然后bfs求出由电源正极到负极的一条路径

3.以这条路径为主线开始处理，遇到分叉边就表明此处有并联嵌套串联，用结论一+dfs计算嵌套串联的等效电阻，并记下$k=min\{k,\frac{R_{\sum}}{max\{R_i\}}\}$，然后利用结论三进行并联电阻的合并

4.将所有等效电阻求和，即为整个电路的总等效电阻，如果主线电流为$I$则最小电流$I_{min}=kI$

---

原文地址：[【洛谷】NOIP2018原创模拟赛DAY2题解](https://blog.csdn.net/hi_ker/article/details/82820861)


------------
原文地址已经修改

$2019.2.23\,\,\,\ --AFO$_$OIer$

---


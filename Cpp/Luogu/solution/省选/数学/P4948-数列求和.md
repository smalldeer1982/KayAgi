# 数列求和

## 题目描述

给定 $n,a,k$，求：

$$\sum_{i=1}^n i^k a^i$$

答案对 $10^9 + 7$ 取模。

## 说明/提示

| 测试点编号 | $n=$ | $k=$ |
| :----------: | :----------: | :----------: |
| $1$ | $10^6$ | $10^3$ |
| $2$ | $10^6$ | $2\times 10^3$ |
| $3$ | $10^{18}$ |  $0$|
| $4$ | $10^{18}$ |$1$  |
| $5,6$ |  $10^{18}$| $2$ |
| $7,8$ |  $10^{18}$|  $10^3$|
| $9,10$ |$10^{18}$  |  $2\times 10^3$|

对于 $100\%$ 的数据，$n\le10^{18}$，$a\le10^9$，$k\le2000$

## 样例 #1

### 输入

```
3 4 0```

### 输出

```
84```

## 样例 #2

### 输入

```
3 10 1```

### 输出

```
3210```

## 样例 #3

### 输入

```
3 9 2```

### 输出

```
6894```

# 题解

## 作者：Weng_Weijie (赞：17)

题意：求$$\sum_{i=1}^ni^ka^i$$

要分两种情况考虑

(1) $a \neq 1$

令
$$S(k)=\sum_{i=1}^ni^ka^i$$

$$S(k)=\sum_{i=1}^ni^ka^i=\sum_{i=1}^n(i+1)^ka^{i+1}-(n+1)^ka^{k+1}+a$$

$$=\sum_{i=1}^n\sum_{j=0}^k\binom{k}{j}i^ja^{i+1}-(n+1)^ka^{k+1}+a$$

$$=\sum_{j=0}^k\binom{k}{j}\sum_{i=1}^ni^ja^{i+1}-(n+1)^ka^{k+1}+a$$

$$=a\sum_{j=0}^k\binom{k}{j}S(j)-(n+1)^ka^{k+1}+a$$

移项

$$S(k)=\dfrac{(n+1)^ka^{k+1}-a\displaystyle\sum_{j=0}^{k-1}\binom{k}{j}S(j)-a}{a-1}$$

$O(k^2)$递推即可
***
(2)$a=1$

$$S(k)=\sum_{i=1}^ni^k$$

$$S(k)=\sum_{i=1}^n(i+1)^k-(n+1)^k+1$$

$$=\sum_{i=1}^n\sum_{j=0}^k\binom{k}{j}i^j-(n+1)^k+1$$

$$=\sum_{j=0}^k\binom{k}{j}\sum_{i=1}^ni^j-(n+1)^k+1$$

$$=\sum_{j=0}^k\binom{k}{j}S(j)-(n+1)^k+1$$

$$\sum_{j=0}^{k-1}\binom{k}{j}S(j)-(n+1)^k+1=0$$

$$\binom{k}{k-1}S(k-1)=(n+1)^k-\sum_{j=0}^{k-2}\binom{k}{j}S(j)-1$$

$$S(k)=\dfrac{(n+1)^{k+1}-\displaystyle\sum_{j=0}^{k-1}\binom{k+1}{j}S(j)-1}{k+1}$$

$O(k^2)$递推即可

```cpp
#include <iostream>
using LL = long long;
LL n;
const int mod = 1E9 + 7;
const int K = 2005;
int a, k, C[K][K], S[K];
void up(int &x, int y) { if ((x += y) >= mod) x -= mod; }
int pow(LL x, LL y) {
    int ans = 1; x %= mod; y %= mod - 1;
    for (; y; y >>= 1, x = static_cast<LL> (x) * x % mod)
        if (y & 1) ans = static_cast<LL> (ans) * x % mod;
    return ans;
}
int main() {
    std::cin >> n >> a >> k;
    C[0][0] = 1;
    for (int i = 1; i < K; i++) {
        C[i][0] = 1;
        for (int j = 1; j <= i; j++)
            up(C[i][j] = C[i - 1][j - 1], C[i - 1][j]);
    }
    if (a == 0) std::puts("0");
    if (a == 1) {
        S[0] = n % mod;
        for (int i = 1; i <= k; i++) {
            int sum = 0;
            for (int j = 0; j < i; j++) up(sum, static_cast<LL> (C[i + 1][j]) * S[j] % mod);
            up(sum = mod - sum, pow(n + 1, i + 1) - 1);
            S[i] = static_cast<LL> (sum) * pow(i + 1, mod - 2) % mod; 
        }
        std::printf("%d\n", S[k]);
    }
    if (a > 1) {
        S[0] = static_cast<LL> (pow(a, n + 1) - a + mod) * pow(a - 1, mod - 2) % mod;
        for (int i = 1; i <= k; i++) {
            int sum = 0;
            for (int j = 0; j < i; j++) up(sum, static_cast<LL> (C[i][j]) * S[j] % mod);
            up(sum = mod - sum, static_cast<LL> (pow(n + 1, i)) * pow(a, n) % mod - 1);
            S[i] = static_cast<LL> (sum) * a % mod * pow(a - 1, mod - 2) % mod;
        }
        std::printf("%d\n", S[k]);
    }
    return 0;
}
```

---

## 作者：shanjb0221 (赞：14)

### 算法 1

测试点 $ 1,2 $ ：$ N = 10 ^ 6 $

快速幂即可

### 算法 2

测试点 $ 3,4 $ ：$ k = 0,1 $

简单数列求和，推出结论即可

### 算法 3

测试点 $ 5,6 $ ：$ k = 2 $

复杂数列求和，推出结论即可

### 算法 4

测试点 $ 7,8,9,10 $ ： $ k ≤ 2,000 $

开始推式子：

$ T_n(k) = b_1 + b_2 + b_3 + \cdots + b_n $

即  $ T_n(k) = 1^ka^1 + 2^ka^2 + 3^ka^3 + \cdots + n^ka^n $

又 $ aT_n(k) = 1^ka^2 + 2^ka^3 + \cdots + (n-1)^ka^n + n^ka^{n+1} $

$\therefore (a-1)T_n(k) = n^ka^{n+1} - a + \sum_{i=2}^{n} \left( (i-1)^k-i^k \right) a^i $

$\because (i-1)^k = \sum_{j=0}^{k} \textrm{C}_ {k}^{j} \cdot i^j \cdot (-1)^{k-j} $

$ \therefore (i-1)^k-i^k  = \sum_{j=0}^{k-1} \textrm{C}_ {k}^{j} \cdot i^j \cdot (-1)^{k-j} $

$ \therefore \sum_{i=2}^{n} \left( (i-1)^k-i^k \right) a^i = \sum_{i=2}^{n} \left( \sum_{j=0}^{k-1} \textrm{C}_ {k}^{j} \cdot i^j \cdot (-1)^{k-j} \right) a^i $

$ =  \sum_{j=0}^{k-1} \textrm{C}_ {k}^{j} \cdot (-1)^{k-j} \left( \sum_{i=2}^{n} i^j \cdot a^i \right) $
    
$ \because \sum_{i=2}^{n} i^j \cdot a^i = \left( \sum_{i=1}^{n} i^j \cdot a^i \right) -a = T_n(j)-a $

$ \therefore (a-1)T_n(k) = n^ka^{n+1} - a + \sum_{j=0}^{k-1} \textrm{C}_ {k}^{j} \cdot (-1)^{k-j} \left( T_n(j)-a \right) $

$ \therefore T_n(k) = \frac{n^ka^{n+1} - a + \sum_{j=0}^{k-1} \textrm{C}_ {k}^{j} \cdot (-1)^{k-j} \left( T_n(j)-a \right)}{a-1} $

注意到 $ j < k $ 可以 $ O(N^2) $ 递推

特殊地，$ T_n(0) = a^1 + a^2 + a^3 + \cdots + a^n = \frac{a \left( a^n - 1 \right)}{a-1} $ 

#### 算法 4 代码~~(std)~~：

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
typedef long long ll;
const int M=1e9+7,N=3010;
ll n,a,k,iva,T[N];
ll ans,fac[N],inv[N],inf[N];
inline ll pow(ll a,ll t) {
    ll r=1;
    a%=M;
    while(t) {
        if(t&1)r=r*a%M;
        a=a*a%M,t>>=1;
    }
    return r;
}
inline ll C(int n,int m) {
    return fac[n]*inf[m]%M*inf[n-m]%M;
}
int main() {
    cin>>n>>a>>k;
    fac[0]=inv[1]=inf[0]=1;
    for(int i=2; i<=k; ++i)inv[i]=inv[M%i]*(M-M/i)%M;
    iva=pow(a-1,M-2);
    T[0]=iva*a%M*(pow(a,n)-1)%M;
    for(int i=1; i<=k; ++i) {
        fac[i]=fac[i-1]*i%M,inf[i]=inf[i-1]*inv[i]%M;
        T[i]=pow(n,i)*pow(a,n+1)%M-a;
        for(int j=i-1,_=1; j>=0; --j,_=-_)
            T[i]=(T[i]-C(i,j)*_*(T[j]-a))%M;
        T[i]=(T[i]+M)%M*iva%M;
    }
    cout<<T[k]<<endl;
}
```

---

### UPD：18.10.27

#### 原来的 std 死了！

注意到当 $ a=1 $ 时 $ iva=0 $ ？！！

虽然现在数据中没有这种情况（可能将来会有？）

应该加个特判：

```cpp
if(a==1){
	T[0]=n;
	for(int i=1; i<=k; ++i) {
		T[i]=pow(n,i+1)%M;
		for(int j=i-1,_=1; j>=0; --j,_=-_)
		T[i]=(T[i]+C(i+1,j)*_*T[j])%M;
		T[i]=(T[i]+M)%M*inv[i+1]%M;
	}
}
```

在这里就不再推式子了

#### 新的 std:

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
typedef long long ll;
const int M=1e9+7,N=3010;
ll n,a,k,iva,T[N];
ll ans,fac[N],inv[N],inf[N];
inline ll pow(ll a,ll t) {
    ll r=1;
    a%=M;
    while(t) {
        if(t&1)r=r*a%M;
        a=a*a%M,t>>=1;
    }
    return r;
}
inline ll C(int n,int m) {
    return fac[n]*inf[m]%M*inf[n-m]%M;
}
int main() {
    cin>>n>>a>>k;
    fac[0]=inv[1]=inf[0]=1;
    for(int i=2; i<=k+1; ++i)inv[i]=inv[M%i]*(M-M/i)%M;
    for(int i=1; i<=k+1; ++i)fac[i]=fac[i-1]*i%M,inf[i]=inf[i-1]*inv[i]%M;
    if(a!=1) {
        iva=pow(a-1,M-2);
        T[0]=iva*a%M*(pow(a,n)-1)%M;
        for(int i=1; i<=k; ++i) {
            T[i]=pow(n,i)*pow(a,n+1)%M-a;
            for(int j=i-1,_=1; j>=0; --j,_=-_)
                T[i]=(T[i]-C(i,j)*_*(T[j]-a))%M;
            T[i]=(T[i]+M)%M*iva%M;
        }
    } else {
        T[0]=n;
        for(int i=1; i<=k; ++i) {
            T[i]=pow(n,i+1)%M;
            for(int j=i-1,_=1; j>=0; --j,_=-_)
                T[i]=(T[i]+C(i+1,j)*_*T[j])%M;
            T[i]=(T[i]+M)%M*inv[i+1]%M;
        }
    }
    cout<<T[k]<<endl;
}
```

---

## 作者：Brodal_Queue (赞：13)

为什么这题题解都是 $\Theta(k^2)$ 的暴力啊？  
这里给出一种时间复杂度 $\Theta(k + \log n)$ 的做法。

设

$$f_n=\sum_{i=1}^{n-1}i^ka^i$$

有如下定理：

> 存在关于 $n$ 的 $k$ 次多项式 $g_n$，满足 $f_n=a^ng_n-g_0$

可以用数学归纳法证明（别打我，我也没有更好的证法），这里就不再赘述。  

差分一下有
$$f_n-f_{n-1}=a^{n-1}(n-1)^k=a^{n-1}(ag_n-g_{n-1})$$
直接得出递推式
$$g_n=\frac{g_{n-1}+(n-1)^k}{a}$$


设 $g_0=x$，那么对于其它项，都能写成 $ux+v$ 的形式——也就是关于 $g_0$ 的一次函数。   
根据差分的基本定理，由于 $g_n$ 关于 $n$ 是 $k$ 次多项式，$g_{k+1}$ 在 $k+1$ 阶差分下为 $0$，即
$$\sum_{i=0}^{k+1}(-1)^i\binom{k+1}{i}g_{k+1-i}=0$$
现在睁大你的眼睛，前面我们说 $\{g_n\}_{n=0}^\infty$ 都可以表示为关于 $g_0$ 的一次函数。  
现在把上面那个式子算出来（$ug_0+v$ 的形式），那么就能得出 $g_0=-v/u$！  

要维护这个一次函数很简单，自己整个结构体就好了。

得出 $g_0$ 的实际值后，递推求出 $g_1,g_2,\dots,g_k$，就可以直接拉格朗日插值求出 $g_n$，然后就能算出 $f_n$ 了。

求 $i^k$ 的时候需要线性筛，插值需要线性求逆元，这样就可以实现严格 $\Theta(k+\log n)$ 的时间复杂度了。  


由于代码太丑，就不贴了。。qaq  
注意对 $k=0$ 和 $a=1$ 的情况要特判。

ps：这个做法不仅适用于第 $i$ 项是 $a^ii^k$，还可以是 $a^ib_i$。其中 $b_i$ 关于 $i$ 是个 $k$ 次多项式，但是需要多点求值，时间复杂度会变大为 $\Theta(k \log^2 k)$。



---

## 作者：qwaszx (赞：6)

考虑用常系数线性递推那一套东西搞.

设
$$
f_{n}=\sum_{i=1}^ni^kr^i
$$

当$r=1$时直接拉格朗日插值即可$O(k)$算一个值，以下认为$r\neq 1$

那么显然有

$$
f_n=f_{n-1}+r^nn^k
$$

这是个常系数线性非齐次递推，根据那一套理论，通解可以表示为

$$
f_n=\alpha\cdot1^n+r^ng(n)
$$

其中$g(n)$是$n$的$k$次多项式，$\alpha$是一个常数，它由$f_0=\alpha+g(0)$决定.这样我们只需要求出$g(0)$和$g(n)$即可得到答案.因为$g(n)$是$n$的$k$次多项式所以只需要求出$g(0),g(1),\cdots,g(k)$即可插值出$g(n)$.下面考虑怎么求出这些点值.

因为$h_n=r^ng(n)$是递推关系的一个特解，这样有

$$
r^ng(n)=r^{n-1}g(n-1)+r^nn^k
$$

即

$$
rg(n)=g(n-1)+rn^k
$$

于是我们得到$g$的一个递推式，但$g(0)$仍然不确定，我们考虑$g$作为$k$次多项式的性质，即$k+1$阶差分后为$0$，从而有

$$
\Delta^{k+1}g(0)=\sum_{i=0}^{k+1}\binom{k+1}{i}g(i)(-1)^{k+1-i}=0
$$

这样我们得到一个方程组，解出这个方程组即可得到$g$.这里解的时候先用$g$的递推式把$g(i)$化成$a_ig(0)+b_i$的形式然后代入到差分的方程中求出$g(0)$.还需要考虑最后这个方程中$g(0)$前的系数为$0$的可能性，实际上这个是不可能的，因为有$a_i=r^{-i}$，代入到差分的方程就得到

$$
\sum_{i=0}^{k+1}\binom{k+1}{i}r^{-i}(-1)^{k+1-i}=(r^{-1}-1)^{k+1}
$$

显然这个不为$0$，所以是没问题的.

插值出$g(n)$之后答案就是

$$
f_n=r^ng(n)-g(0)
$$

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N=1e6+5000,mod=1e9+7;
int qpower(int a,int b)
{
	int ans=1;for(;b;b>>=1,a=1ll*a*a%mod)if(b&1)ans=1ll*ans*a%mod;
	return ans;
}
int suf[N],pre[N],r,k,g[N],pw[N],p[N],prime[N],cnt,inv[N],fac[N],ifac[N],C[N];
long long n;
void make(int n)
{
	pw[1]=1;
	for(int i=2;i<=n;i++)
	{
		if(!p[i])prime[++cnt]=i,pw[i]=qpower(i,k);
		for(int j=1;j<=cnt&&i*prime[j]<=n;j++)
		{
			int x=i*prime[j];p[x]=1;
			pw[x]=1ll*pw[i]*pw[prime[j]]%mod;
		}
	}
	fac[1]=ifac[1]=fac[0]=ifac[0]=inv[1]=1;
	for(int i=2;i<=n+1;i++)
	{
		inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
		ifac[i]=1ll*ifac[i-1]*inv[i]%mod;
		fac[i]=1ll*fac[i-1]*i%mod;
	}
}
int main()
{
	scanf("%lld%d%d",&n,&r,&k);long long tn=n;n%=mod;
	make(k+1);
	if(r==1)
	{
		g[0]=0;for(int i=1;i<=k;i++)g[i]=(g[i-1]+pw[i])%mod;
		suf[k+1]=1,pre[0]=n;
		for(int i=k;i>=1;i--)suf[i]=1ll*suf[i+1]*(n-i)%mod;
		for(int i=1;i<=k;i++)pre[i]=1ll*pre[i-1]*(n-i)%mod;
		int ans=0;
		for(int i=1;i<=k;i++)ans=(ans+(((k-i)&1)?-1ll:1ll)*pre[i-1]*suf[i+1]%mod*ifac[i]%mod*ifac[k-i]%mod*g[i])%mod;	
		cout<<(ans+mod)%mod<<endl;
		return 0;
	}
	int ir=qpower(r,mod-2);
	g[0]=0;
	for(int i=1;i<=k+1;i++)g[i]=(1ll*g[i-1]*ir+pw[i])%mod;
	C[0]=1;for(int i=1;i<=k+1;i++)C[i]=1ll*C[i-1]*inv[i]%mod*(k+2-i)%mod;
	int tmp=0;
	for(int i=0;i<=k+1;i++)tmp=(tmp+1ll*g[i]*(C[i]*(((k+1-i)&1)?-1:1)))%mod;
	g[0]=-1ll*tmp*qpower(ir-1,mod-k-2)%mod;
	for(int i=1;i<=k;i++)g[i]=(1ll*g[i-1]*ir+pw[i])%mod;
	suf[k+1]=1,pre[0]=n;
	for(int i=k;i>=1;i--)suf[i]=1ll*suf[i+1]*(n-i)%mod;
	for(int i=1;i<=k;i++)pre[i]=1ll*pre[i-1]*(n-i)%mod;
	int ans=((k&1)?-1ll:1ll)*suf[1]*ifac[k]%mod*g[0]%mod;
	for(int i=1;i<=k;i++)ans=(ans+(((k-i)&1)?-1ll:1ll)*pre[i-1]*suf[i+1]%mod*ifac[i]%mod*ifac[k-i]%mod*g[i])%mod;
	ans=(1ll*qpower(r,tn%(mod-1))*ans-g[0])%mod;
	cout<<(ans+mod)%mod<<endl;
}
```

---

## 作者：mrsrz (赞：6)

稍微扰动一下就好了。

$$\sum_{i=1}^n i^k a^i=\sum_{i=1}^{n-1}i^k a^i +n^k a^n=\sum_{i=1}^{n-1}(i+1)^k a^{i+1}+a$$

$$\therefore \sum_{i=1}^{n-1}[(i+1)^ka^{i+1}-i^k a^i]=n^ka^n-a$$

对$(i+1)^k$二项式展开

$$\sum_{i=1}^{n-1}[a^{i+1}\sum_{j=0}^k\binom{k}{j}i^j -i^k a^i]=n^ka^n-a$$

$$\sum_{i=1}^{n-1}[a^{i+1}\sum_{j=0}^{k-1}\binom{k}{j}i^j + i^ka^{i+1} -i^k a^i]=n^ka^n-a$$

$$\sum_{i=1}^{n-1}a^{i+1}\sum_{j=0}^{k-1}\binom{k}{j}i^j + (a-1)\sum_{i=1}^{n-1}i^k a^i=n^ka^n-a$$

$$\sum_{j=0}^{k-1}\binom{k}{j}\sum_{i=1}^{n-1}a^{i+1}i^j + (a-1)\sum_{i=1}^{n-1}i^k a^i=n^ka^n-a$$

$$a\sum_{j=0}^{k-1}\binom{k}{j}\sum_{i=1}^{n-1}i^j a^i + (a-1)\sum_{i=1}^{n-1}i^k a^i=n^ka^n-a$$

设$$F(k)=\sum_{i=0}^{n-1} i^k a^i$$

$$a\sum_{j=0}^{k-1}\binom{k}{j}F(j) + (a-1)F(k)=n^ka^n-a$$

$$(a-1)F(k)=-a\sum_{j=0}^{k-1}\binom{k}{j}F(j) +n^ka^n-a$$

$$F(k)=\dfrac{-a\sum_{j=0}^{k-1}\binom{k}{j}F(j) +n^ka^n-a}{a-1}$$

我们可以很容易算出$F(0)$的值，然后预处理组合数，就可以在$O(k^2)$时间内递推出$F(k)$。

最后的答案为$F(k)+n^k a^n$。

---

那$a=1$呢？

此时有

$$\sum_{j=0}^{k-1}\binom{k}{j}F(j)=n^k-1$$

$$F(k-1)\times\binom{k}{k-1}+ \sum_{j=0}^{k-2}\binom{k}{j}F(j)=n^k-1$$

$$F(k-1)\times \binom{k}{k-1}=n^k-1-\sum_{j=0}^{k-2}\binom{k}{j}F(j)$$

$$F(k-1)=\dfrac{n^k-1-\sum_{j=0}^{k-2}\binom{k}{j}F(j)}{\binom{k}{k-1}}$$

即

$$F(k)=\dfrac{n^{k+1}-\sum_{j=0}^{k-1}\binom{k+1}{j}F(j)}{\binom{k+1}{k}}$$

---

## 作者：L2_sheep (赞：6)

对于这题，介绍一种不用推公式的做法，其实就是错位相减法的递归运用，比较的直观。
错位相减法，大家应该比较了解，它可以很容易的推导出等比数列的求和公式。等比数列的系数都是常数项（0阶多项式），相邻两项的差都是0，很容易推出结果。
这题系数是k阶多项式。有个结论，将一个k阶多项式相邻的两项相减，会得到一个k-1阶多项式。这样经过k次相减后，最终将得到一个0阶多项式，这样就可以通过递归来得到结果。
举个例子：
![错位相减法](https://cdn.luogu.com.cn/upload/pic/41772.png)
具体代码如下：
```cpp
#include <stdio.h>
#define N 2005
#define M 1000000007
typedef long long LL;

LL n, a, k, m, l;
LL dt[N], dw[N], inv, pa[N], pw;

LL ksm(LL x, LL y)
{
    if(y == 0) return 1;
    LL t = ksm(x, y >> 1);
    t = t * t % M;
    if(y & 1) t = t * x % M;
    return t;
}

LL jian(LL x, LL y){
    LL ans = x - y;
    if(ans < 0) ans += M;
    return ans;
}

LL cal(LL tk)
{
    LL ans = jian(pw * dw[1] % M, pa[k - tk + 1] * dt[1] % M);
    LL i;
    for(i = 1; i <= tk; i++){
        dt[i] = jian(dt[i + 1], dt[i]);
        dw[i] = jian(dw[i], dw[i + 1]);
    }
    if(tk > 0) return ans = jian(ans, cal(tk - 1)) * inv % M;
    return ans * inv % M;
}

int main() 
{
    LL i, j;
    
    scanf("%lld%lld%lld", &n, &a, &k);
    for(i = 1, j = n, m = k + 1, pa[0] = 1; i <= m; i++, j--){
    	dt[i] = ksm(i, k);
    	dw[i] = ksm(j % M, k);
    	pa[i] = pa[i - 1] * a % M;
    }
    inv = ksm(a - 1, M - 2), pw = ksm(a, n + 1);
    printf("%lld\n", cal(k));  
    
    return 0;
}
```

---

## 作者：warzone (赞：4)

[可能更好的阅读体验](https://www.luogu.com.cn/blog/wangrx/solution-p4948)


## 题目大意

给定 $n,a,k$，求

$$\sum_{i=1}^ni^ka^i$$

答案对 $10^9+7$ 取模。

$\texttt{Data Range:} 1\le n\le 10^{18},1\le a\le 10^9,1\le k\le 2000$

## 题解

前置芝士：[有限微积分](https://www.luogu.com.cn/blog/wangrx/finite-calculus)

除了扰动法，本题还有一种较为简洁的有限微积分做法。

普通幂难以处理，用第二类斯特林数转为下降幂：

$$\sum_{i=1}^ni^ka^i=\sum_{j=0}^k{k\brace j}\sum_{i=1}^ni^{\underline{j}}a^i$$

$$=\sum_{i=0}^k{k\brace i}{\sum}_1^{n+1}x^{\underline{i}}a^x\delta x$$

若 $a=1,\displaystyle\sum x^{\underline{i}}\delta x=\dfrac{x^{\underline{i+1}}}{i+1}$。

若 $a\not=1$，对于 $\displaystyle{\sum}x^{\underline{i}}a^x\delta x$，由分部求和公式易得出其递推式

$$\sum u\Delta v=uv-\sum \mathrm{E}v\Delta u$$

$${\sum}x^{\underline{i}}a^x\delta x=\dfrac{x^{\underline{i}}a^x}{a-1}-\sum \dfrac{a^{x+1}}{a-1}ix^{\underline{i-1}}\delta x$$

$${\sum}x^{\underline{i}}a^x\delta x=\dfrac{x^{\underline{i}}a^x}{a-1}-\dfrac{ai}{a-1}\sum a^xx^{\underline{i-1}}\delta x$$

求出第二类斯特林数后 $\Theta(k)$ 递推即可。

复杂度瓶颈为求第二类斯特林数，本题可 $\Theta(k^2)$ 递推，  
亦可使用 NTT $\Theta(k\log^2 k)$ 或 $\Theta(k\log k)$ 求解。

## Code
```cpp
/* 
solution P4948 with finite calculus
made by wanrzone 2021-11-1 16:55
*/ 
#include<stdio.h>
#include<string.h>
typedef unsigned long long ull;
typedef unsigned int word;
const word mod=1e9+7;
inline ull pow_(word a,word b){//快速幂
	word ans=1;
	for(;b;b>>=1){
		if(b&1) ans=1ull*ans*a%mod;
		a=1ull*a*a%mod;
	}
	return ans;
}
word brace[2048][2048];//第二类斯特林数
word a,k,under[2048];
inline ull getans(ull num){
	if(a==1){//a=1 的情况特判
		num%=mod;
		ull ans=0,get=1;
		for(word i=0;i<=k;++i){
			get=get*(num+mod-i)%mod;
			ans+=pow_(i+1,mod-2)*brace[k][i]%mod*get%mod;
		}
		return ans%mod;
	}
	under[0]=pow_(a,num%(mod-1))*pow_(a-1,mod-2)%mod;
	num%=mod;
	for(word i=0;i<k;++i)
		under[i+1]=(num+mod-i)*under[i]%mod;
	//O(n) 递推 $\dfrac{x^{\underline{i}}a^x}{a-1}$
	ull ans=0,get=0;
	num=pow_(a-1,mod-2)*(mod-a)%mod;
	for(word i=0;i<=k;++i){
		get=(get*num%mod*i+under[i])%mod;
		//O(k) 递推 $\sum x^{\underline{i}}a^x\delta x$
		ans+=get*brace[k][i]%mod; //计入答案
	}
	return ans%mod;
}
ull n;
int main(){
	scanf("%llu%u%u",&n,&a,&k);
	brace[0][0]=1;
	for(word n=1;n<=k;++n)//预处理第二类斯特林数
		for(word m=1;m<=n;++m)
			brace[n][m]=(1ull*m*brace[n-1][m]
				+brace[n-1][m-1])%mod;
	printf("%llu\n",(getans(n+1)+mod-getans(1))%mod);//不定和式->定和式
	return 0;
}
```

---

## 作者：KAMIYA_KINA (赞：3)

## Description

求
$$
\sum_{i-1}^{n}{i^k\cdot a^i}
$$
的值，其中 $n\le10^{18},k\le 2\times 10^3,a\le 10^9$。

## Solution

本题在《具体数学》一书中有详细的解法思路说明，可以在该书第二章 <和式> 中得到思路的启发。

对这个式子进行扰动。

令
$$
S(k)=\sum_{i=1}^{n}{i^k}
$$
当 $a=1$ 时，有
$$
\begin{aligned}
 S(k) &=\sum_{i=1}^{n}{i^k} \\
&=\sum_{i=1}^{n}(i+1)^k-(n+1)^k+1 
\end{aligned}
$$
根据二项式定理 
$$
(x+y)^k =\sum_{i=0}^{k}{\binom{k}{i}\cdot x^iy^{k-i}}
$$


有
$$
\begin{aligned}
S(k)&=\sum_{i=1}^{n}{\sum_{j=0}^{k}\binom{k}{j}\cdot i^j}-(n+1)^k+1\\
&=\sum_{j=0}^{k}\binom{k}{j}{\sum_{i=1}^{n}i^j}-(n+1)^k+1\\
&=\sum_{j=0}^{k}\binom{k}{j}{S(j)}-(n+1)^k+1
\end{aligned}
$$
由于 $\binom{k}{k}=1$，则
$$
\sum_{j=0}^{k-1}{\binom{k}{j}}S(j)-(n+1)^k+1=0
$$
由于 $\binom{k}{k-1}=k$，则
$$
\begin{aligned}
k\cdot S(k-1)=(n+1)^k-\sum_{j=0}^{k-2}{\binom{k}{j}S(j)-1}\\
S(k-1)=\frac{(n+1)^k-\sum_{j=0}^{k-2}{\binom{k}{j}S(j)-1}}{k}
\end{aligned}
$$


令 $t=k-1$，有
$$

S(t)=\frac{(n+1)^{t+1}-\sum_{j=0}^{t-1}{\binom{t+1}{j}S(j)-1}}{t+1}
$$
把 $k$ 换回来，有
$$
\begin{aligned}
S(k)&=\frac{(n+1)^{k+1}-\sum_{j=0}^{k-1}{\binom{k+1}{j}S(j)-1}}{k+1}\\
S(0)&=n
\end{aligned}
$$
这个式子可以 $O(k^2)$ 求。

同理的考虑 $a\not= 1$，则令
$$
S(k)=\sum_{i=1}^{n}i^ka^i
$$
可以解得
$$
\begin{aligned}
S(k)&=\frac{(n+1)^k\cdot a^{n+1}-a\sum_{j=0}^{k-1}{\binom{k}{j}S(j)-a}}{a-1}\\
S(0)&=\frac{a^{n+1}-a}{a-1}
\end{aligned}
$$
同理 $O(k^2)$ 求解，该式和边界情况留给读者自证，方法类似。

## Code

~~~cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define int long long
const int mod = 1e9 + 7;
const int K = 2e3 + 10;
int fc[K],fv[K],inv[K];
inline int ksm(int x,int y) {int ret=1;for(x%=mod;y;y>>=1,x=x*x%mod)if(y&1ll)ret=ret*x%mod;return ret;}
inline int C(const int x,const int y) {return x < y ? 0 : fc[x] * fv[y] % mod * fv[x - y] % mod;}
int f[K];
int n,a,k;
inline void init() {
    fc[0] = 1;
    for(int i = 1; i <= k + 1; i++) fc[i] = fc[i - 1] * i % mod;
    fv[k + 1] = ksm(fc[k + 1],mod - 2);
    for(int i = k + 1; i >= 1; i--) fv[i - 1] = fv[i] * i % mod;
    inv[1] = 1;
    for(int i = 2; i <= k + 1; i++) inv[i] = (mod - mod / i) * inv[mod % i] % mod;
    return ;
}
signed main() {
    scanf("%lld%lld%lld",&n,&a,&k);
    init();
    if(a == 1) {
        f[0] = n % mod;
        for(int i = 1; i <= k; i++) {
            int sum1 = ksm(n + 1,i + 1),sum2 = 0;
            for(int j = 0; j < i; j++) (sum2 += C(i + 1,j) * f[j] % mod) %= mod;
            f[i] = (sum1 - sum2 - 1 + mod) % mod * inv[i + 1] % mod;
        }
    } else {
        int iv = ksm(a - 1,mod - 2);
        f[0] = (ksm(a,n + 1) - a + mod) % mod * iv % mod;
        for(int i = 1; i <= k; i++) {
            int sum1 = ksm(n + 1,i) * ksm(a,n + 1) % mod,sum2 = 0;
            for(int j = 0; j < i; j++) (sum2 += C(i,j) * f[j] % mod) %= mod;
            sum2 = sum2 * a % mod;
            f[i] = ((sum1 - sum2 + mod) % mod - a + mod) % mod * iv % mod;
        }
    }
    cout << f[k] << endl;
    return 0;
}
~~~



## End

---

## 作者：serverkiller (赞：3)

**如果markdown爆炸的请进入博客食用**

说句闲话 这题$k$开到$10^6$不过分 做完这题可以去做做[这个](https://loj.ac/p/6055)

我们要求的是:
$$
f(n)=\sum_{i=1}^na^ii^k
$$
我们不妨求出递推式:
$$
f(n)=f(n-1)+a^nn^k
$$
这里有个 $n$ 在指数上 不能拉格朗日插值 我们考虑消除这个的影响 设出来一个函数:
$$
\begin{aligned}
g(n)&=\frac{f(n)+c}{a^n},\ g(0)=c\\
\text{那么}g(n-1)&=\frac{f(n-1)+c}{a^{n-1}}\\
g(n)&=\frac{f(n)+c}{a^n}=\frac{f(n-1)+a^nn^k+c}{a^n}=\frac{g(n-1)}{a}+n^k
\end{aligned}
$$
考虑对 $g$ 差分 方便地 我们定义 $g_t(x)$ 表示 $g$ 的 $t$ 阶差分:
$$
\begin{aligned}
g_1(n)&=\frac{1-a}{a}g(n-1)+n^k\\
g_2(n)&=g_1(n)-g_1(n-1)\\
&=\frac{1-a}{a}(g(n-1)-g(n-2))+n^k-(n-1)^k\\
&=\frac{1-a}{a}g_1(n-1)+P_2(n)
\end{aligned}
$$
注意到 $P_2(n)$ 的次数是 $k-1$ 次 而 $P_1(x)$ 即 $n^k$ 的次数是 $k$ 次 降了一次幂

那么 $P_{k+1}(n)=0$ 即 $g(k+1)=0$ 也就是 $g$ 的 $k+1$ 阶差分是 $0$

所以 $g$ 的通项是一个 $k$ 次的多项式 我们需要 $k+1$ 个点值来插值就可以得到 $g$ 的通项 最后就可以得到 $g(n)$

现在的问题转换成了如何求 $g(0)$ 这需要我们再次利用 $k+1$ 阶差分是$0$的特性:
$$
\begin{aligned}
g(x)&=\sum_{i=0}^{k+1}(-1)^i{k + 1\choose i}g_{k+1}(i)\\
g_{k+1}(i)&=\sum_{i=0}^{k+1}(-1)^i{k+1\choose i}g_i=0
\end{aligned}
$$
而 $g(n)=h_n(g(0))$ 且$h_n$必然是一个一次函数 所以可以通过上式解出 $g_0$ 从而得到 $g_1,g_2,...,g_k$ 通过拉格朗日插值 得到$g_n$ 而 $f_n=a^ng(n)-f(0)$ 所以就可以得到$f_n$

复杂度是 $O(k)$ 我的实现下跑 $34ms$ 是当前的最优解 然而这个最优解第二的 $O(k^2)$ 跑了$71ms$(

给个丑陋的实现:

```cpp
const int mod = 1e9 + 7;
int n,_n,k,a,fac[N],inv[N],idk[N],pri[N],g[N],cnt = 0;
bool vis[N];

struct line
{
	int k,t;
	line operator+(const line tmp) const
	{
		return (line) {(k + tmp.k) % mod,(t + tmp.t) % mod};
	}
	line operator-(const line tmp) const
	{
		return (line) {(k - tmp.k + mod) % mod,(t - tmp.t + mod) % mod};
	}
	line operator*(const int x) const
	{
		return (line) {k * x % mod,t * x % mod};
	}
}l[N];

int ksm(int a,int b,int mod = mod)
{
	int res = 1;
	while (b)
	{
		if (b & 1) res = res * a % mod;
		a = a * a % mod;
		b >>= 1;
	}
	return res;
}

int C(int n,int m)
{
	if (n < m) return 0;
	if (n < 0 || m < 0) return 0;
	return fac[n] * inv[n - m] % mod * inv[m] % mod;
}

int clac(int n)
{
	if (n <= k + 1) return g[n];
	int ans = 0,res = 1;
	for (int i = 1; i <= k + 1; i++)
		res = res * (n - i) % mod;
	for (int i = 1; i <= k + 1; i++)
	{
		int tmp = inv[i - 1] * inv[k + 1 - i] % mod;
		ans = (ans + g[i] * tmp % mod * res % mod * ksm(n - i,mod - 2) % mod * ((k + 1 - i) & 1 ? -1 : 1) + mod) % mod;
	}
	return ans;
}

int getf(int n,int _n)
{
	return (ksm(a,_n) * clac(n) % mod - g[0] + mod) % mod;
}

signed main()
{
	read(n,a,k);
	_n = n % (mod - 1),n %= mod;
	fac[0] = inv[0] = 1;
	for (int i = 1; i < N; i++)
		fac[i] = fac[i - 1] * i % mod;
	inv[N - 1] = ksm(fac[N - 1],mod - 2);
	for (int i = N - 1; i >= 1; i--)
		inv[i - 1] = inv[i] * i % mod;
	idk[1] = 1;
	for (int i = 2; i < N; i++)
	{
		if (!vis[i]) pri[++cnt] = i,idk[i] = ksm(i,k);
		for (int j = 1; j <= cnt && i * pri[j] < N; j++)
		{
			vis[i * pri[j]] = 1;
			idk[i * pri[j]] = idk[i] * idk[pri[j]] % mod;
			if (!(i % pri[j])) break;
		}
	}
	l[0] = (line) {1,0};
	for (int i = 1; i <= k + 1; i++)
		l[i] = l[i - 1] * ksm(a,mod - 2) + (line) {0,idk[i]};
	line res = (line) {0,0};
	for (int i = 0; i <= k + 1; i++)
	{
		if (i & 1) res = res - l[k + 1 - i] * C(k + 1,i);
		else res = res + l[k + 1 - i] * C(k + 1,i);
	}
	g[0] = (mod - res.t * ksm(res.k,mod - 2) % mod) % mod;
	for (int i = 1; i <= k + 5; i++)
		g[i] = (ksm(a,mod - 2) * g[i - 1] % mod + idk[i]) % mod;
	writeln(getf(n,_n));
	return 0;
}
```

---

## 作者：出言不逊王子 (赞：3)

记 $S_k=\sum_{i=1}^n i^ka^i$。

则使用错位相减法，有 $aS_k=\sum_{i=1}^n i^ka^{i+1}$。

上下相减，则 $(a-1)S_k=(n^ka^{n+1}-a)-\sum_{x=2}^n ((x-1)^k-x^k)a^x$。

然后那个 $(x-1)^k$ 可以用二项式定理展开，则有 $(x-1)^k-x^k=\sum_{i=0}^{k-1}C_k^i\times x^i\times(-1)^{k-i}$。

运用这个结论，可以得到 $\sum_{x=2}^n ((x-1)^k-x^k)a^x=\sum_{x=2}^n a^x\times (\sum_{i=0}^{k-1}C_k^i\times x^i\times(-1)^{k-i})$。

然后求和符号换一下，我们就可以把对 $n$ 的求和变成对 $k$ 的求和了，可以得到 $\sum_{i=0}^{k-1}C_k^i\times (-1)^{k-i}\times \sum_{x=2}^n (a^x\times x^i)$。

然后你发现没法优化了。

但是你发现 $\sum_{x=2}^n (a^x\times x^i)$ 这个形式好像在哪出现过。

这不就是题目要求的式子吗，只不过 $k$ 变成了 $i$。

那么我们就努力凑出这样一个形式吧！这样就能递推求解了。

观察到他的 $x$ 是从 $2$ 到 $n$ 遍历，那么我们给他加上再减去一个 $a^1\times 1^i=a$ 即可，如下所示。

$\sum_{i=0}^{k-1}C_k^i\times (-1)^{k-i}\times (\sum_{x=1}^n (a^x\times x^i)-a)=\sum_{i=0}^{k-1}C_k^i\times (-1)^{k-i}\times (S_i-a)$

别忘了这个式子是 $(a-1)\times S_k$，所以我们还要除以 $a-1$。

但是你发现 $i$ 可能等于 $0$。

考虑如果 $k=0$ 怎么做。则 $S_0=\sum_{i=1}^n a^i$，就是一个等比数列求和，结果是 $\frac{a\times (a^n-1)}{a-1}$。

发现我们在好多地方都要除以 $a-1$，所以我们预处理 $\frac 1{a-1}$ 的值。

时间复杂度 $O(k^2)$。

```cpp
#include<bits/stdc++.h>
#define fs(i,x,y,z) for(register int i=x;i<=y;i+=z)
#define ft(i,x,y,z) for(register int i=x;i>=y;i+=z)
#define int long long
#define db double
#define ms(a,b) memset(a,b,sizeof(a))
using namespace std;
const int N=200001,inf=1e9+7;
inline int read(){
	int date=0,w=1;char c=0;
	while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
	while(c>='0'&&c<='9'){date=(date<<3)+(date<<1)+(c^48);c=getchar();}
	return date*w;
}
int ksm(int a,int b){
	a%=inf;
	int ans=1ll;while(b){if(b&1)ans=ans*a%inf;a=a*a%inf;b=b>>1ll;}
	return ans;
}
int fac[N+1],inv[N+1],k,f[N],e; 
int c(int d,int u){return fac[d]*inv[u]%inf*inv[d-u]%inf;}
signed main(){
	fac[0]=inv[0]=1;
	fs(i,1,N,1) fac[i]=fac[i-1]*i%inf;
	inv[N]=ksm(fac[N],inf-2); 
	ft(i,N-1,1,-1) inv[i]=inv[i+1]*(i+1)%inf;
    int n=read(),a=read(),k=read();e=ksm(a-1,inf-2);
    f[0]=a*e%inf*(ksm(a,n)-1+inf)%inf;
    fs(i,1,k,1){
    	int cur=1-2*bool(i&1);f[i]=(ksm(n,i)*ksm(a,n+1)%inf-a+inf)%inf;
    	//左边的式子
    	fs(j,0,i-1,1){
    		f[i]=(f[i]+c(i,j)*cur*(f[j]-a)+inf)%inf;
    		cur*=-1;
		}
		f[i]=(f[i]+inf)%inf*e%inf;
		//这里是(a-1)S，要除以a-1 
	}
	cout<<f[k];
	return 0;
}
```

---

## 作者：andysj (赞：2)

[$Link$](https://www.luogu.com.cn/problem/P4948)

# Description​

给定$n, a, k$，求$\sum\limits_{i=1}^ni^ka^i\pmod{1e9+7}$。

# Solution​

学习了一种新的推式子方法。

我们令$f(k)=\sum\limits_{i=1}^ni^ka^i$。

当$a>1$时，$f(k)=\sum\limits_{i=1}^ni^ka^i$

$=\sum\limits_{i=1}^n(i+1)^ka^{i+1}-(n+1)^ka^{n+1}+a$

$=\sum\limits_{i=1}^n\sum\limits_{j=0}^ki^j\dbinom{k}{j}a^{i+1}-(n+1)^ka^{n+1}+a$

$=a\sum\limits_{j=0}^k\dbinom{k}{j}f(j)-(n+1)^ka^{n+1}+a$

整理可得$f(k)=\dfrac{(n+1)^ka^{n+1}-a-a\sum\limits_{j=0}^{k-1}\dbinom{k}{j}f(j)}{a-1}$

我们容易求出$f(0)=\sum\limits_{i=1}^na^i=\dfrac{a(a^n-1)}{a-1}$（等比数列求和）。$O(k^2)$递推即可。

当$a=1$时，$f(k)=\sum\limits_{i=1}^ni^k$

$=\sum\limits_{i=1}^n(i+1)^k-(n+1)^k+1$

$=\sum\limits_{i=1}^n\sum\limits_{j=0}^ki^j\dbinom{k}{j}-(n+1)^k+1$

$=\sum\limits_{j=0}^k\dbinom{k}{j}f(j)-(n+1)^k+1$

整理一下：$(n+1)^k-1=\sum\limits_{j=0}^{k-1}\dbinom{k}{j}f(j)+\dbinom{k}{k}f(k)-f(k)=\sum\limits_{j=0}^{k-2}\dbinom{k}{j}f(j)+\dbinom{k}{k-1}f(k-1)$

令$k=k+1$，$f(k)\dbinom{k+1}{k}=(n+1)^{k+1}-1-\sum\limits_{J=0}^{k-1}\dbinom{k+1}{j}f(j)$

整理得$f(k)=\dfrac{(n+1)^{k+1}-1-\sum\limits_{j=0}^{k-1}\dbinom{k+1}{j}f(j)}{k+1}$

我们容易求出$f(0)=n$。$O(k^2)$递推即可。

# Tips

快速幂运算之前，先要把底数和指数取个模在运算，否则很有可能爆$long\ long$！（调了我一个多小时）


---

## 作者：MEKHANE (赞：1)

关于 $i^k$ 以及与 $i$ 有关的重要的处理方法。考虑分成两种情况讨论：

1. $a>1$

重点在于将 $i$ 变为 $i+1$ 然后将多余的项单独取出（扰动技巧），然后二项式展开，最后根据等式进行递推。记 $S_j=\sum_{i=1}i^ja^i$，那么有：

$$S_k=\sum_{i=1}^n i^ka^i=\sum_{i=1}^n(i+1)^ka^{i+1}-(n+1)^ka^{n+1}+a$$

前半部分二项式展开，提出一个 $a$ 变为 ：

$$\sum_{i=1}^n\sum_{j=0}^k\binom{k}{j}i^ja^{i+1}=\sum_{j=0}^k\binom{k}{j}S_j$$

因为 $a>1$ 导致左右两边 $S_k$ 系数不同，可以移项递推。

2. $a=1$

虽然 $a=1$ 导致我们系数相等消掉了，但是 $k-1$ 的系数没有消掉，也即：如果我们将上面的推导中 $k$ 替代为 $k+1$，那么最后也可得到递推式。

当然还有更简单的做法，因为 $\sum_{i=1}^ni^k$ 是关于 $n$ 的 $k+1$ 次多项式，所以可以插值。

```cpp
#include<bits/stdc++.h>
#define int long long
#define rep(i,j,k) for(int i=j;i<=k;i++)
using namespace std;
const int N=2005,mod=1e9+7;
int n,a,k,S[N],c[N][N];
int ksm(int x,int k){
    int res=1;
    for(;k;k/=2,x=x*x%mod) if(k&1) res=res*x%mod;
    return res;
}
signed main(){
    ios::sync_with_stdio(false);
    cin>>n>>a>>k;
    rep(i,0,N-1){c[i][0]=1; rep(j,1,i) c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;}
    if(a==1){
        S[0]=n%mod;
        rep(i,1,k){
            int sum=0;
            rep(j,0,i-1) sum=(sum+c[i+1][j]*S[j]%mod)%mod;
            sum=(mod-sum+ksm((n+1)%mod,i+1)-1)%mod;
            S[i]=sum*ksm(i+1,mod-2)%mod; 
        }cout<<S[k];
    }
    if(a>1){
        S[0]=(ksm(a,n+1)-a+mod)*ksm(a-1,mod-2)%mod;
        rep(i,1,k){
            int sum=0;
            rep(j,0,i-1) sum=(sum+c[i][j]*S[j]%mod)%mod;
            sum=(mod-sum+ksm((n+1)%mod,i)*ksm(a,n)%mod-1)%mod;
            S[i]=sum*a%mod*ksm(a-1,mod-2)%mod;
        }cout<<S[k];
    }
}
```






---

## 作者：2018ljw (赞：1)

来一篇大力推式子的斯特林数题解。

首先 $0^k=0$，将原式变为 $\sum\limits_{i=0}^ni^ka^i$。

$$
=\sum_{i=0}^na^i\sum_{j=0}^kS_{k}^jC_i^jj!\\
=\sum_{j=0}^kS_k^jj!\sum_{i=0}^na^iC_i^j
$$

$S_{k}^jj!$ 可以预处理。本来可以 NTT 做到 $O(k\log k)$，但出题人给了一个毒瘤模数，所以只能递推 $O(k^2)$ 求解。

考虑如何求右边的式子，令 $g(x)=\sum\limits_{i=0}^na^iC_i^x$。显然 $g(0)=\sum\limits_{i=0}^na^i$。

考虑递推。根据 $C_{x}^y=C_{x-1}^y+C_{x-1}^{y-1}$ 有：

$$
g(x+1)=\sum_{i=0}^na^iC_i^{x+1}=\sum_{i=0}^na^i(C_{i-1}^x+C_{i-1}^{x+1})\\
=\sum_{i=0}^na^iC_{i-1}^x+\sum_{i=0}^na^iC_{i-1}^{x+1}
$$

左半部分

$$
\sum_{i=0}^na^iC_{i-1}^x=a\sum_{i=0}^{n-1}a^iC_i^x=a\left(\sum_{i=0}^na^iC_i^x-a^nC_n^x\right)\\=a\times g(x)-a^{n+1}C_n^x
$$

右半部分同理，为 $a\times g(x+1)-a^{n+1}C_{n}^{x+1}$

因此 $g(x+1)=a\times g(x)+a\times g(x+1)-a^{n+1}(C_n^{x+1}+C_n^x)$。

即 $(1-a)g(x+1)=a\times g(x)-a^{n+1}C_{n+1}^{x+1}$。

当 $a\ge 2$ 时，$(1-a)$ 移项即可得到递推式。$g(0)$ 等比数列求和。

当 $a=1$ 时，有 $0=g(x)-C_{n+1}^{x+1}$，即 $g(x)=C_{n+1}^{x+1}$。组合数递推系数即可。

- 实际上 $a=1$ 时，将 $C_{n+1}^{x+1}$ 不断对 $C_{?}^{x+1}$ 项裂项相消即可得到 $g(x)$ 的定义式。更普遍的，有结论 $\sum\limits_{i=0}^xC_{i}^y=C_{x+1}^{y+1}$。当然，这是题外话了。

整理一下，我们的式子是这样的：$\sum\limits_{j=0}^kS_k^jj!g(j)$，其中 $g(0)=\sum\limits_{i=0}^na^i$，$g(i)$ 满足：

$$
\begin{cases}g(i)=C_{n+1}^{i+1}&a=1\\g(i+1)=\frac a{1-a}\left(g(i)-a^nC_{n+1}^{i+1}\right)&a\ge 2\end{cases}
$$

此外 $i=j=0$ 且 $a\ge 2$ 时会产生 $a^0C_0^0=1$ 的贡献，因此 $a\ge 2$ 时 $g(0)$ 对答案贡献要 $-1$。

瓶颈在于斯特林数求解，组合数可以从前一项递推系数或转下降幂暴力求解，复杂度 $O(k^2)$。

代码就不放了，知道式子后就没有难点了。

---

## 作者：peterwuyihong (赞：1)

题意：求 $\sum_{i=1}^ni^ka^i\bmod 10^9+7$，$n\le 10^{18},a\le10^9,k\le 2000$

$$f(k)=\sum_{i=1}^ni^ka^i$$
$$af(k)=\sum_{i=2}^{n+1}(i-1)^ka^i$$
$$(a-1)f(k)=n^ka^{n+1}-a-\sum_{i=2}^na^i(i^k-(i-1)^k)$$
$$(a-1)f(k)=n^ka^{n+1}-a-\sum_{i=1}^{n-1}a^{i+1}\sum_{j=0}^{k-1}\binom k ji^j$$
$$(a-1)f(k)=n^ka^{n+1}-a-a\sum_{j=0}^{k-1}\binom k j\sum_{i=1}^{n-1}a^{i}i^j$$
$$(a-1)f(k)=n^ka^{n+1}-a-a\sum_{j=0}^{k-1}\binom k j(f(j)-a^nn^j)$$
$$(a-1)f(k)=n^ka^{n+1}-a-a\sum_{j=0}^{k-1}\binom k jf(j)+a^{n+1}\sum_{j=0}^{k-1}\binom k jn^j$$
$$n^ka^{n+1}+a^{n+1}\sum_{j=0}^{k-1}\binom k jn^j=a^{n+1}\sum_{j=0}^{k}\binom k jn^j=a^{n+1}(n+1)^k$$
$$(a-1)f(k)=a^{n+1}(n+1)^k-a-a\sum_{j=0}^{k-1}\binom k jf(j)$$
$$f(k)=\frac{a}{a-1}(a^n(n+1)^k-1-\sum_{j=0}^{k-1}\binom k j f(j))$$
$$f(0)=\frac{a^{n+1}-a}{a-1}$$
我草，那 $a=1$ 呢？除数为 $0$ 了！

那就不要除过去。
$$0=(n+1)^k-1-\sum_{j=0}^{k-1}\binom k j f(j))$$
$$0=(n+1)^{k+1}-1-\sum_{j=0}^{k}\binom{k+1}j f(j))$$
$$(k+1)f(k)=(n+1)^{k+1}-1-\sum_{j=0}^{k-1}\binom{k+1}j f(j))$$
除过来，还是能递归做，$f(0)=n$

复杂度 $O(k^2\log)$。
```cpp
using i64 = long long;
int f[maxn],a,k;
i64 n;
int jc[maxn],jcinv[maxn];
int C(int n,int m){
  return Mul(jc[n],Mul(jcinv[n-m],jcinv[m]));
}
signed main(){
#ifndef ONLINE_JUDGE
	freopen("testdata.in","r",stdin);
#endif
	cin>>n>>a>>k;
	jc[0]=1;rep(i,1,k+1)jc[i]=Mul(jc[i-1],i);jcinv[k+1]=ksm(jc[k+1],p-2);
	per(i,k,0)jcinv[i]=Mul(jcinv[i+1],i+1);
  if(a==1){
    f[0]=n%p;
    rep(i,1,k){
      f[i]=Sub(ksm(n%p+1,i+1),1);
      rep(j,0,i-1)sub(f[i],Mul(C(i+1,j),f[j]));
      mul(f[i],ksm(i+1,p-2));
    }
  }else{
    int gg=Mul(a,ksm(a-1,p-2));
    f[0]=Mul(Sub(ksm(a,n),1),gg);
    rep(i,1,k){
      f[i]=Sub(Mul(ksm(a,n),ksm(n%p+1,i)),1);
      rep(j,0,i-1)sub(f[i],Mul(C(i,j),f[j]));
      mul(f[i],gg);
    }
  }
  cout<<f[k]<<"\n";
}
```

---

## 作者：Cyhlnj (赞：1)

$K^2logN$ 瑟瑟发抖

考的时候想到了，交了一发 $80$ 分，TLE两个点

卡了卡常数就 $900+ms$ 跑过去了~~全站垫底TwT~~

做法

设 $f_n=\sum_{i=1}^{n}n^ka^n$

那么

$$f_{2n}=f_n+a^n\times\sum_{i=0}^{k}\binom{k}{i}n^{k-i}f_n$$

然后就可以快速幂了

```cpp
# include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int mod(1e9 + 7);
const int maxn(2005);

ll k, a, pw[maxn], c[maxn][maxn], f[maxn], tmp[maxn], n;

inline void Inc(ll &x, ll y) {
	x += y;
	if (x >= mod) x -= mod;
}

inline ll Pow(ll x, ll y) {
	register ll ret = 1;
	for (x %= mod; y; y >>= 1, x = x * x % mod)
		if (y & 1) ret = ret * x % mod;
	return ret;
}

void Solve(ll x) {
	if (x == 1) {
		register ll i;
		for (i = 0; i <= k; ++i) f[i] = a;
		return;
	}
	Solve(x >> 1);
	register ll i, j, mid = x >> 1, nw;
	for (i = 0; i <= k; ++i) tmp[i] = f[i], f[i] = 0;
	pw[0] = 1, nw = Pow(a, mid), mid %= mod;
	for (i = 1; i <= k; ++i) pw[i] = pw[i - 1] * mid % mod;
	for (i = 0; i <= k; ++i)
		for (j = 0; j <= i; ++j) f[i] += tmp[j] * c[i][j] % mod * pw[i - j] % mod;
	for (i = 0; i <= k; ++i) f[i] = (tmp[i] + f[i] % mod * nw % mod) % mod;
	if (x & 1) {
		for (i = 0; i <= k; ++i) tmp[i] = f[i], f[i] = 0;
		for (i = 0; i <= k; ++i)
			for (j = 0; j <= k; ++j) f[i] += tmp[j] * c[i][j] % mod;
		for (i = 0; i <= k; ++i) f[i] = (f[i] % mod * a % mod + a) % mod;
	}
}

int main() {
	ios :: sync_with_stdio(false);
	cin >> n >> a >> k, c[0][0] = 1;
	register ll i, j;
	for (i = 1; i <= k; ++i)
		for (c[i][0] = j = 1; j <= i; ++j)
			c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;
	Solve(n), cout << f[k] << endl;
	return 0;
}
```

---

## 作者：可爱的小棉羊 (赞：0)

分两种情况 $a=1$ 和 $a \ne1$，前者就是 [The Sum of the k-th Powers](https://www.luogu.com.cn/problem/CF622F)。

好的我们来看后半段，考虑我们用扰动法太简单了，来整点不简单的，考虑有限微积分，定义 $u(x)=\frac{a^x}{(a-1)}$，$v(x)=x^k$，那么我们发现 $\Delta u(x)=a^x$，然后分部求和就行了。

$$\sum a^xx^k\delta x=\frac{1}{a-1}a^xx^k-\sum(\frac{1}{a-1}a^{x+1})((x+1)^k-x^k)\delta x$$

然后二项式定理展开：

$$\frac{1}{a-1}a^xx^k-\frac{a}{a-1}\sum(a^{x})(\sum_{i=0}^{k-1}\binom kix^i)\delta x$$

$$\frac{1}{a-1}a^xx^k-\frac{a}{a-1}\sum_{i=0}^{k-1}\binom ki\sum(a^{x})x^i\delta x$$

然后把上下界加上：

$$\sum^{n+1}_1 a^xx^k\delta x=\frac{1}{a-1}a^xx^k-\frac{a}{a-1}\sum_{i=0}^{k-1}\binom ki\sum^{n+1}_1(a^{x})x^i\delta x$$

然后我们得到：

$$S_k=\frac{1}{a-1}a^xx^k-\frac{a}{a-1}\sum_{i=0}^{k-1}\binom kiS_i$$

然后递推就行了。

---

## 作者：zhong__zero (赞：0)

## 推一波式子

$$b_n=n^ka^n$$

$$T_n=\sum_{i=1}^{n}b_i=\sum_{i=1}^{n}i^ka^i$$

$$aT_n=a\sum_{i=1}^{n}b_i=a\sum_{i=1}^{n}i^ka^i=\sum_{i=1}^{n}i^{k}a^{i+1}=\sum_{i=2}^{n+1}(i-1)^ka^i$$

$$aT_n-T_n=\sum_{i=2}^{n+1}(i-1)^ka^i-\sum_{i=1}^{n}i^ka^i=n^ka^{n+1}-a-\sum_{i=2}^{n}(i^k-(i-1)^k)\times a^i$$

$n^ka^{n+1}-a$可以在log复杂度内求出，我们只要考虑后一部分

设$$F=\sum_{i=2}^{n}(i^k-(i-1)^k)\times a^i=\sum_{i=1}^{n-1}((i+1)^k-i^k)\times a^{i+1}$$

则$$F=\sum_{i=1}^{n-1}(\sum_{j=0}^{k}C_k^j\times i^j-i^k)\times a^{i+1}=\sum_{i=1}^{n-1}(\sum_{j=0}^{k-1}C_k^j\times i^j)\times a^{i+1}$$


$$F=\sum_{j=0}^{k-1}C_k^j(\sum_{i=1}^{n-1}i^j\times a^{i+1})=\sum_{j=0}^{k-1}C_k^j\times a(\sum_{i=1}^{n-1}i^j\times a^i)$$

我们可以观察到$\sum_{i=1}^{n-1}i^j\times a^{i+1}$的形式与询问我们的形式很像


我们不妨设 $g_{n,k}=\sum_{i=1}^{n}i^ka^i$

$$T_n=g_{n,k}=\frac{n^ka^{n+1}-a-F}{a-1}=\frac{n^ka^{n+1}-a-\sum_{j=0}^{k-1}C_k^j\times a\times g_{n-1,j}}{a-1}---(1)$$

此时就可以直接进行dp或记忆化搜索，又由于$g_{n,k}$由$g_{n-1,0...k-1}$转移过来，而$g_{0,k}=0$所以,只需要知道$k^2$个g值就行了，每次转移都是O(k)的,此时复杂度是O($k^3$)

但是又由定义得$$g_{n,k}=\sum_{i=1}^{n}i^ka^i=\sum_{i=1}^{n-1}i^ka^i+n^ka^n=g_{n-1,k}+n^ka^n---(2)$$
所以只要知道$g_{n-1,k}$就可以log求出$g_{n,k}$

我们只要求k遍 (1) 式 就可以所有的$g_{h_k,k}$,$h_k$表示我们所需的所有$g_{a,k}$中第一个a

接下来通过 式(2) 就可以求出所有的$g_{a,k}$

复杂度为O($k^2\times log k$)  ($logn$是快速幂复杂度)


## 注意!!!

上述式子只有在$a!=1$时才成立，当$a=1$时，需要求$\sum_{1}^{n}i^k$,此时可以用插值法来求，不过好像出题人没想到$a=1$的情况，所以并没有$a=1$的数据

### 代码
~~代码？？写的太翔了，就不放了~~


---

## 作者：pkh68 (赞：0)


诶，我来搬运一下出题人的题解吧。

以下是我结合自己的理解所写，如有不对请大佬指出。

### 解析

观察到$k$的值很小，从此处下手。

设$f_{n}(x)=\sum_{i=1}^n{i^x}\times{a^i}$,答案即为$f(k)$.

那么有$a\times{f_{n}(x)}=\sum_{i=1}^n{i^x}\times{a^{i+1}}$.

$\therefore (a-1)\times{f_{n}(x)}=n^x\times{a^{n+1}}-a+\sum_{i=2}^n((i-1)^x-i^x)\times{a^i}$.

考虑$\sum^n_{i=2}((i-1)^x-i^x)\times{a^i}$,

$\because (a-1)^k=\sum^k_{j=0}C(k,j)\times{a^j}\times(-1)^{k-j}$,

$\therefore \sum_{i=2}^n((i-1)^x-i^x)\times{a^i}$

$=\sum^n_{i=2}(\sum^{x-1}_{j=0}C(x,j)\times{i^j}\times(-1)^{x-j})\times{a^i}$

$=\sum^{x-1}_{j=0}C(x,j)\times(-1)^{x-j}\times(\sum^n_{i=2}i^j\times{a^i})$

$=\sum^{x-1}_{j=0}C(x,j)\times(-1)^{x-j}\times(f_n(j)-a)$,

$\therefore f_n(x)=\frac{n^x\times{a^{n+1}}-a+\sum^{x-1}_{j=0}C(x,j)\times(-1)^{x-j}\times(f_n(j)-a)}{a-1}$

观察到上式可以$O(n)$计算，一共$n$个值，所以可以$O(n^2)$完成递推。

### 代码如下

```cpp

#include<iostream>
#include<cstdio>
#include<cstdlib>
#define re register
#define LL long long
#define N 3005
using namespace std;
const int Mod=1e9+7;
LL n,a,k,power_a,c[N][N],inv_a,f[N];
LL power(LL x,LL P){
    LL r=1; x%=Mod;
    while(P){ if(P&1) r=r*x%Mod; x=x*x%Mod; P>>=1; }
    return r;
}
int main(){
    scanf("%lld%lld%lld",&n,&a,&k);
    power_a=power(a,n+1);
    for(re int i=0;i<=k;++i){
        c[i][0]=1ll;
        for(re int j=1;j<=i;++j) c[i][j]=(c[i-1][j-1]+c[i-1][j])%Mod;
    }
    inv_a=power(a-1,Mod-2);
    f[0]=inv_a*a%Mod*(power(a,n)-1)%Mod;
    for(re int i=1;i<=k;++i){
        f[i]=power_a*power(n,i)%Mod-a;
        for(re int j=i-1,t=-1;~j;--j,t=-t) f[i]=(f[i]+c[i][j]*t*(f[j]-a))%Mod;
        f[i]=(f[i]+Mod)*inv_a%Mod;
    }
    printf("%lld\n",f[k]);
    return 0;
}
```

### 后记

此题要点：

$1.$利用$k$的值很小做递推。

$2.$利用错位相减处理数列和式。

$3.$和式变换中，交换求和符号是常用的技巧。

---

## 作者：Aw顿顿 (赞：0)

## 扰动法初识

扰动法是一种**处理和式的常见套路**，我们将和式的最后一项和第一项分别写出来，利用这两种形式构造一个等式，然后找出该和式的**封闭形式或递推式**。虽然这并不对所有的式子都见效，但确实是很棒的一种处理方法。

先考虑求简单式子的封闭形式：

$$S_n=\sum\limits_{i=0}^{n}a^i$$

显然存在：

$$a^{n+1}+\sum\limits_{i=0}^{n}a^i=a^0+\sum\limits_{i=1}^{n+1}a^i$$

然后将系数 $a$ 提出来并用 $S$ 表示，就得到：

$$a^{n+1}+\sum\limits_{i=0}^{n}a^i=a^0+a\sum\limits_{i=0}^{n}a^i$$

$$a^{n+1}+S_n=1+aS_n$$

移项并简单处理得到：

$$S_n=\dfrac{1-a^{n+1}}{1-a}$$

怎么样，是不是很简单？我们来看一下 [「P4948 数列求和」](https://www.luogu.com.cn/problem/P4948) 这题。

## 扰动法应用

不妨令 $S_k$ 表示下列式子：

$$\sum\limits_{i=1}^{n}i^k$$

接下来简单分类，首先考虑 $a=1$ 的情况，我们就可以写出第一项和最后一项：

$$\sum\limits_{i=1}^{n}i^k+(n+1)^k=1+\sum\limits_{i=1}^{n}(i+1)^k$$

然后代入 $S$ 来表示就是：

$$S_k=\sum\limits_{i=1}^{n}(i+1)^k-(n+1)^k+1$$

显然，$(i+1)^k$ 这一部分可以用二项式定理处理：

$$\sum\limits_{i=1}^{n}\sum\limits_{j=0}^k\binom{k}{j}\cdot i^j-(n+1)^k+1$$

不得不说，其中一项是 $1$ 着实给我们省了不少麻烦，那么考虑将组合数所在的和式替换顺序，而内部就可以替换：

$$\sum\limits_{j=0}^k\binom{k}{j}\sum\limits_{i=1}^{n}i^j-(n+1)^k+1$$

$$\sum\limits_{j=0}^k\binom{k}{j}S_j-(n+1)^k+1$$

$$S_k=\sum\limits_{j=0}^{k-1}\binom{k}{j}S_j-(n+1)^k+1$$

接下来我们把左侧提取 $\binom{k}{k-1}$ 加之简单处理就得到：

$$S_{k-1}=\dfrac{(n+1)^k-\sum\limits_{j=0}^{k-2}\binom{k}{j}S_j-1}{k}$$

$$S_{k}=\dfrac{(n+1)^{k+1}-\sum\limits_{j=0}^{k-1}\binom{k+1}{j}S_j-1}{k+1}$$

得到了递推式，可以 $O(k^2)$ 进行递推，然后 $a\neq 1$ 的情况方法类似，将 $S$ 的定义补上一个 $a$ 的系数，结果也补上一个 $a$ 的系数就好了：

$$S_{k}=\dfrac{(n+1)^{k+1}\cdot a^{n+1}-a\sum\limits_{j=0}^{k-1}\binom{k}{j}S_j-a}{a-1}$$

不多赘述，请见代码：

```cpp
#include<bits/stdc++.h>
#define int long long
#define mod 1000000007
#define N 2005 
using namespace std;
int c[N],v[N],f[N],inv[N],n,a,k;
int ksm(int b,int p){
	int res=1;b%=mod;
	while(p){
		if(p&1)res=res*b%mod;
		b=b*b%mod;p>>=1;
	}return res;
}int C(int x,int y){
	if(x<y)return 0;
	return c[x]*v[y]%mod*v[x-y]%mod;
}void init(){
	c[0]=inv[1]=1;
	for(int i=1;i<=k+1;i++)c[i]=c[i-1]*i%mod;
	v[k+1]=ksm(c[k+1],mod-2);
	for(int i=k+1;i;i--)v[i-1]=v[i]*i%mod;
	for(int i=2;i<=k+1;i++)inv[i]=(mod-mod/i)*inv[mod%i]%mod;
}signed main() {
    scanf("%lld%lld%lld",&n,&a,&k);init();
    if(a==1){
    	f[0]=n%mod;
    	for(int i=1;i<=k;i++){
    		int s1=ksm(n+1,i+1),s2=0;
    		for(int j=0;j<i;j++)s2=(s2+C(i+1,j)*f[j]%mod)%mod;
    		f[i]=(s1-s2-1+mod)%mod*inv[i+1]%mod;
		}
	}else{
		int inva=ksm(a-1,mod-2);
		f[0]=(ksm(a,n+1)-a+mod)%mod*inva%mod;
        for(int i=1;i<=k;i++){
        	int s1=ksm(n+1,i)*ksm(a,n+1)%mod,s2=0;
        	for(int j=0;j<i;j++)s2=(s2+C(i,j)*f[j]%mod)%mod;
            f[i]=((s1-(a*s2%mod)+mod)%mod-a+mod)%mod*inva%mod;
        }
    }printf("%lld\n",f[k]);
    return 0;
}
```

P.S. 该取模时就取模，每次乘法过后一定要记得取模，并且注意运算符优先级。








---


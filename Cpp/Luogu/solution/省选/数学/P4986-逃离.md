# 逃离

## 题目背景

$\ \rm Althen\ $和$\ \rm hdxrie\ $掉入了二维空间。

## 题目描述

其实这个空间并不是无限的，而是半径有限的圆盘。

起初，他们两个都在圆心处，为了找到出口，他们两个决定分开行动，只要找到出口，便会离开。不过，若是其中一个人找到了出口，另一个还在二维空间内，那么这个空间就会因为不平衡而崩塌。所以他们两个只能一起离开。

其中：
- $\rm Althen\ $ 可以拐弯，还会一直拐来拐去，不过只能水平或者竖直移动。
- $\rm hdxrie\ $ 只能沿任意一条直线走，不能拐弯。

$\rm Althen\ $ 全程在水平向右的平均速度可以用函数 $A(x)$ 表示，在竖直向上的平均速度可以用函数 $B(x)$ 表示。$\rm hdxrie\ $ 全程移动的平均速度可以用函数 $C(x)$ 表示。而参数 $x$的取值范围也有讲究，为 $[L,R]$。

现在，他们两个想问你，他们有可能一起离开这个二维空间吗？如果可以，这个参数 $x$ 的值可以是多少？



## 说明/提示

【数据范围】   
对于$10\%$的数据，$L=R$；  
另有$20\%$的数据，$La=Lb=Lc=1$；  
另有$30\%$的数据，$[L,R]$ 内最多只有一个参数 $x$ 合法；  
对于$100\%$的数据，$0≤La,Lb,Lc≤10^5$，$0≤a_i,b_i,c_i≤9$，$L≤R$，$|L|,|R|≤3$；  

答案精确度需要保证带入原来的三个函数，合法误差不超过 $10^{-5}$，误差若是大于 $10^{-5}$ 会判断为错误答案，建议输出 **保留八位以上小数**。

###### $\color{#EEE}{\tt {Notice\ that\ SPEED\ is\ VECTOR.(High\ school\ physics)}}$

## 样例 #1

### 输入

```
1 1 1 -2.00 0.50 
1 2 
1 3 
4 1 
```

### 输出

```
-1.16666667```

## 样例 #2

### 输入

```
1 1 1 -1.00 0.50 
1 2 
1 3 
4 1 
```

### 输出

```
Inconsistent!```

# 题解

## 作者：周道_Althen (赞：13)

~~大家好我是出题人 Althen·Way·Satan（超小声）。~~

### 热烈祝贺第一个切掉这个题的人：[@南山桥一霸](https://www.luogu.org/space/show?uid=56923)；

## 还有感谢一直到最后都在肝我的题的大佬，葱花都要哭出来了：[@zhaimingshuzms](https://www.luogu.org/space/show?uid=8742)。（Orz，都已经拿到70%了）

- 前排鸣谢：

$\ \ \ \ \ \ \ $指导（~~PY关系~~）：[@Psyduck](https://psyduck.wang/)  

$\ \ \ \ \ \ \ $SPJ友情提供：[@hdxrie](https://www.luogu.org/blog/hdxrie/)

$\ \ \ \ \ \ \ $表情包出处：[@全兽出击](https://weibo.com/F2plusA?from=myfollow_all)
$\ \ $画师：[@呀嘛的小2狼 ](https://weibo.com/u/3210386137?from=myfollow_all&is_all=1)（~~大家快去关注他呀XD~~）

------------

# 一、题面解释

$\ \ \ \ \ \ \ $根据题面所描述的意思，我们可以得到如下的图形：

![](https://s1.ax1x.com/2018/10/14/iU3T3R.jpg)

$\ \ \ \ \ \ \ $![吃瓜](https://s1.ax1x.com/2018/10/14/iUlfMV.png)

$\ \ \ \ \ \ \ $其中，绿色和蓝色的箭头代表$\ \rm Althen\ $走过的路程；红色的箭头代表$\ \rm hdxrie\ $走过的路程，设时间为$\ T\ $的话，红色箭头的长度便为$\ C(x)×T\ $。

$\ \ \ \ \ \ \ $![斜眼](https://s1.ax1x.com/2018/10/14/iU8js0.png)

$\ \ \ \ \ \ \ $ $\rm Althen\ $走路扭来扭去的，不方便研究，让人十分不爽。我们不妨 （~~把他拖出去打一顿~~）平移一下他走过的路程：

![](https://s1.ax1x.com/2018/10/14/iU3Hjx.jpg)

$\ \ \ \ \ \ \ $![发光](https://s1.ax1x.com/2018/10/14/iUlRx0.png)

$\ \ \ \ \ \ \ $平（~~dǎlē~~）移（~~yídùn~~）过后，看起来舒服多了呢，那么现在，我们可以度量一下$\ \rm Althen\ $走过的路程，根据题面定义，
可以发现绿色箭头的长度为$\ A(x)×T\ $，绿色箭头的长度为$\ B(x)×T\ $。容易证明，不管$\ \rm Althen\ $怎么扭，都可以通过平移得到这样的表达式（~~小学数学~~）。

$\ \ \ \ \ \ \ $![托腮](https://s1.ax1x.com/2018/10/14/iUlhrT.png)

$\ \ \ \ \ \ \ $通过观察我们可以很容易发现，红色箭头的长度$\ C(x)×T\ $就刚刚好等于半径，所以我们不妨把他也旋转下来：

![](https://s1.ax1x.com/2018/10/14/iU3OHO.jpg)

$\ \ \ \ \ \ \ $![吃鲸](https://s1.ax1x.com/2018/10/14/iUl4qU.png)！？

$\ \ \ \ \ \ \ $这是一个直角三角形，我们可以轻易写出下面的式子（~~初中数学~~）：
$$(C(x)×T)^2=(A(x)×T)^2+(B(x)×T)^2$$
$\ \ \ \ \ \ \ $化简过后可以得到：
$$C^2(x)=A^2(x)+B^2(x)$$
$\ \ \ \ \ \ \ $所以说，我们定义函数$f(x)$:
$$f(x)=C^2(x)-A^2(x)-B^2(x)$$
$\ \ \ \ \ \ \ $![拇指](https://s1.ax1x.com/2018/10/14/iUlIZF.png)

$\ \ \ \ \ \ \ $求出函数$f(x)$在$[L,R]$范围的根，就是我们要求的系数$x$了。

$\ \ \ \ \ \ \ $注意，速度是矢量，所以就算我们解出来的根$\ x$，带进原函数$\ A(x)$，$B(x)$，$C(x)\ $是负数，它也是合法的，这是高一的物理，题面最后也给了提示：$\color{#EEE}{\tt {Notice\ that\ SPEED\ is\ VECTOR.(High\ school\ physics)}}$。


------------

# 二、分段解析

- ## type1(10%):$\ $ $L==R$

$\ \ \ \ \ \ \ $答案只有可能为$\ L$，直接判断该答案是否满足$f(L)==0$，既是否满足$C^2(x)-A^2(x)-B^2(x)==0$。

$\ \ \ \ \ \ \ $![斜眼](https://s1.ax1x.com/2018/10/14/iU8js0.png)

$\ \ \ \ \ \ \ $应该是读懂题意即可拿的分。

- ## type2(20%):$\ $ $La=Lb=Lc=1$

$\ \ \ \ \ \ \ $因为保证$La=Lb=Lc=1$，函数形式就保证为：$A(x)=a_1x+a_0$，$B(x)=b_1x+b_0$，$C(x)=c_1x+c_0$。

$\ \ \ \ \ \ \ $ $f(x)$的形式也可以保证为：
$$f(x)=(c_1^2-a_1^2-b_1^2)x^2+2(c_1c_0-a_1a_0-b_1b_0)x+c_0^2-a_0^2-b_0^2$$

$\ \ \ \ \ \ \ $![托腮](https://s1.ax1x.com/2018/10/14/iUlhrT.png)

$\ \ \ \ \ \ \ $嗯……是一个二次函数呢，求根公式一波带走（~~初中数学~~）。

- ## type3(30%):$\ $保证$[L,R]$最多只有一个参数$x$合法；

$\ \ \ \ \ \ \ $这相当于保证了$f(x)$在$[L,R]$内最多只有一个零点，$f(x)$在$[L,R]$内近似于单调。

$\ \ \ \ \ \ \ $![发光](https://s1.ax1x.com/2018/10/14/iUlRx0.png)

$\ \ \ \ \ \ \ $很容易想到二分答案，也确实可以二分答案（~~高一数学~~）。

$\ \ \ \ \ \ \ $注意，如果二分的**check( )**写的是$C^2(x)-A^2(x)-B^2(x)$的值，可能会造成比较大的精度误差，建议老老实实先算出$f(x)$，再**check( )**判断$f(x)$的值。

$\ \ \ \ \ \ \ $在求$f(x)$的过程中，需要求到卷积，我们发现$O(n^2)$地求卷积代价太大，所以推荐使用 **快速傅里叶变换$FFT$** ，不会就出门左拐百度，会有很多大佬的讲解的。

- ## type_all(100%)

$\ \ \ \ \ \ \ $![哭唧唧](https://s1.ax1x.com/2018/10/14/iUYFDx.png)

$\ \ \ \ \ \ \ $没有什么特殊性质，因为可能有多个根，也不能二分了呢。

$\ \ \ \ \ \ \ $![托腮](https://s1.ax1x.com/2018/10/14/iUlhrT.png)

$\ \ \ \ \ \ \ $回到我们的问题，是如何求$f(x)$在$[L,R]$内的任意一个解。

$\ \ \ \ \ \ \ $其实不过是个 **牛顿迭代** 的裸题，牛顿迭代常用于求一连续可导函数某一极值，或者某一零点。

$\ \ \ \ \ \ \ $![吃瓜](https://s1.ax1x.com/2018/10/14/iUlfMV.png)

$\ \ \ \ \ \ \ $这不就正是我们所需要的吗？

$\ \ \ \ \ \ \ $根据一阶牛顿迭代的公式，我们可以得到我们的答案就应该是以下函数的收敛值：

$$F(x)=F(x-1)-\frac{f\left(F(x-1)\right)}{f'\left(F(x-1)\right)}$$

$\ \ \ \ \ \ \ $这里又需要求$f(x)$的一阶导$f'(x)$，其实很简单，幂函数的导数网上一搜就有了。显然，我们后面的几个点，是满足$f(x)$二阶可导的，所以$F(x)$必然会收敛，但是不一定是在$[L,R]$内，需要判断一下。

- ### 下面给出标程代码
$\color{#EEE}{\text{已经做了防抄袭处理，直接复制会CE的，XD}}$

```cpp
#include<algorithm>
#include<iostream>
#include<cstdlib>
#include<cstring>
#include<cctype>
#include<cstdio>
#include<string>
#include<queue>
#include<stack>
#include<cmath>
#include<map>
#include<set>
using　namespace　std;
const　double　eps=1e-10;
const　double　pi=acos(-1.0);
inline　int　read(){
　　int　x=0,f=1;char　ch;ch=getchar();
　　while(ch<'0'||ch>'9'){if(ch=='-')　f=0;ch=getchar();}
　　while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch&15);ch=getchar();}
　　if(f)return　x;else　return　-x;
}
double　fabs(double　c){if(c<0.0)return　-c;return　c;}
const　int　N=3e5+10;
//FFT模板————————————————————————————————————　
struct　cpx{
　　double　r,i;
　　inline　cpx　operator　*(const　cpx&x)const{return　(cpx){r*x.r-i*x.i,r*x.i+i*x.r};}
　　inline　cpx　operator　+(const　cpx&x)const{return　(cpx){r+x.r,i+x.i};}
　　inline　cpx　operator　-(const　cpx&x)const{return　(cpx){r-x.r,i-x.i};}
}cpxa[N],cpxb[N];
int　r[N];
void　FFT(cpx*a,int　f,int　la){
　　int　n=la;
　　for(register　int　i=0;i<n;++i)if(i<r[i])swap(a[i],a[r[i]]);
　　for(register　int　i=1;i<n;i<<=1){
　　　　cpx　wn=(cpx){cos(pi/i),f*sin(pi/i)};
　　　　for(register　int　j=0;j<n;j+=(i<<1)){
　　　　　　cpx　w=(cpx){1,0};
　　　　　　for(register　int　k=0;k<i;++k,w=w*wn){
　　　　　　　　cpx　x=a[j+k],y=w*a[j+k+i];
　　　　　　　　a[j+k]=x+y;a[j+k+i]=x-y;
　　　　　　}
　　　　}
　　}
　　if(f==-1)
　　for(register　int　i=0;i<n;i++)a[i].r/=n;
}
int　merge_fft(cpx　*a,cpx　*b,int　la,int　lb){
　　int　n=la,m=lb;
　　int　L=0;for(m+=n,n=1;n<=m;n<<=1)L++;
　　for(register　int　i=0;i<n;i++)
　　r[i]=(r[i>>1]>>1)|((i&1)<<(L-1));
　　FFT(a,1,n);FFT(b,1,n);
　　for(register　int　i=0;i<=n;i++)a[i]=a[i]*b[i];
　　FFT(a,-1,n);
　　return　m;
}
//————————————————————————————————————————　
double　L,R;
int　La,Lb,Lc,Lc1,a[N],b[N],c[N],c1[N];
//函数平方
void　get_square(int　*a,int　&L){　
　　memset(cpxa,0,sizeof(cpxa));
　　memset(cpxb,0,sizeof(cpxb));
　　for(register　int　i=0;i<=L;i++)
　　cpxb[i].r=cpxa[i].r=(double)a[i];
　　L=merge_fft(cpxa,cpxb,L,L);
　　for(register　int　i=0;i<=L;i++)a[i]=(int)(cpxa[i].r+0.1);
}
//求C(x)的值
double　get_val_C(double　x){
　　double　X=1,Ret=0;
　　for(int　i=0;i<=Lc;i++){Ret=Ret+c[i]*X;X=X*x;}
　　return　Ret;
}
//求C1(x)的值
double　get_val_C1(double　x){
　　double　X=1,Ret=0;
　　for(int　i=0;i<=Lc1;i++){Ret=Ret+c1[i]*X;X=X*x;}
　　return　Ret;
}
//牛顿迭代　———————————————————————————————————　
int　tim=30;//设定迭代次数tim　
double　Newton_Iteration(double　x){//输入F(x)的初值F(0)，既迭代系数。　
　　double　c;
　　while(1){
　　　　c=get_val_C(x);//求出f(F(x))的值　
		　　tim--;
　　　　if(fabs(c)<eps)break;//若是F(x)在该精度下已经合法，便弹出。　
　　　　x=x-c/get_val_C1(x);//求出F(x)-f(F(x))/f'(F(x))的值，赋给F(x+1)　
　　　　x=max(x,L);x=min(x,R);//防止越界　
　　　　if(!tim)return　0;//若是在迭代次数tim内不合法，便弹出无解。　
　　}
　　return　x;
}
int　main()
{
　　La=read();Lb=read();Lc=read();scanf("%lf%lf",&L,&R);
　　for(int　i=0;i<=La;i++)a[i]=read();
　　for(int　i=0;i<=Lb;i++)b[i]=read();
　　for(int　i=0;i<=Lc;i++)c[i]=read();
　　for(register　int　i=0;i<=La;i++)
　　cpxb[i].r=cpxa[i].r=(double)a[i];
　　
　　//把c^2(x)-a^2(x)-b^2(x)存进c　
　　get_square(a,La);
　　get_square(b,Lb);
　　get_square(c,Lc);
　　Lc=max(Lc,max(La,Lb));
　　for(register　int　i=0;i<=Lc;i++)
　　c[i]=c[i]-b[i]-a[i];
　　
　　//求c1(x)为c(x)的一阶导数　
　　Lc1=Lc-1;
　　for(int　i=1;i<=Lc;i++)
　　c1[i-1]=c[i]*i;
　　
　　double　ans=Newton_Iteration((L+R)/2.0);
　　if(tim)　printf("%.8lf\n",ans);
　　else　printf("Inconsistent!\n");
　　return　0;
}
```
### $\ \ \ \ \ \ $这道题就这样解完了。

$\ \ \ \ \ \ \ $~~题面清晰，解法自然，码量适中~~

$\ \ \ \ \ \ \ $![吃鲸](https://s1.ax1x.com/2018/10/14/iUl4qU.png)什么？

$\ \ \ \ \ \ \ $你不会牛顿迭代？那么我们马上进入下一个阶段。

------------

# 三、重点考点总结——牛顿迭代

$\ \ \ \ \ \ \ $这里简单地讲一下** 一阶牛顿迭代 **，牛顿迭代是应用在最优化领域非常重要的一种算法，由于具有二阶收敛性，所以相比二分法能大大降低迭代次数，只能求一个可导函数的零点，或者有二阶导函数的极值，一种全局搜索算法用来解np问题最优解的算法，在算法竞赛中的运用比较少见（~~Psyduck说~~）。

$\ \ \ \ \ \ \ $先放wiki的动图，牛顿迭代动态示例图：

![](https://upload.wikimedia.org/wikipedia/commons/e/e0/NewtonIteration_Ani.gif)

$\ \ \ \ \ \ \ $容易看出一个重要问题：**对函数的一个点做切线，这个切线与$x$轴的交点当做新的点，重复操作，得到的点就会越来越趋近于零点。**

$\ \ \ \ \ \ \ $具体证明涉及 **泰勒展开**，就不细讲了（~~其实是葱花Althen不会证明~~）。

$\ \ \ \ \ \ \ $说到函数切线，自然就需要求导。

$\ \ \ \ \ \ \ $在$\ f(x)\ $上，点$\ x=a\ $的斜率为$f'(a)$，所以这个切线与$x$轴的交点当做新的点，应该是$\ a-\frac{f\left(a\right)}{f'\left(a\right)}\ $。

$\ \ \ \ \ \ \ $所以，我们定义:
$$F(x)=F(x-1)-\frac{f\left(F(x-1)\right)}{f'\left(F(x-1)\right)}$$

$\ \ \ \ \ \ \ $也就是不断去求点，可得这个点是越来越趋近某一个零点的。也就是说，我们的答案，就是$\ F(+∞)\ $，既函数$\ F(x)\ $的收敛值。

$\ \ \ \ \ \ \ $若$f(x)$二阶可导，那么在待求的零点$\ F(+∞)\ $值周围存在一个区域，只要起始点$\ F(0)\ $位于这个邻近区域内，那么牛顿迭代必定收敛。

$\ \ \ \ \ \ \ $![托腮](https://s1.ax1x.com/2018/10/14/iUlhrT.png)

$\ \ \ \ \ \ \ $不过……我们显然不需要算无限次，保证精度在一个范围内就行了，显然，牛顿迭代可以做到极快收敛到我们需要的精度，我们并不需要计算太多次。

$\ \ \ \ \ \ \ $![吃鲸](https://s1.ax1x.com/2018/10/14/iUl4qU.png)还有！

$\ \ \ \ \ \ \ $我们最终答案的计算效率、精度，还与迭代系数，也就是最初赋值的$\ F(0)\ $有很大关系。（~~但是因为比较小的x取值范围，本题没有卡迭代系数的选定~~）。

$\ \ \ \ \ \ \ $![吃瓜](https://s1.ax1x.com/2018/10/14/iUlfMV.png)

$\ \ \ \ \ \ \ $然后贴出一阶牛顿迭代的模板：

$\ \ \ \ \ \ \ $（~~如果迭代次数过少或者无解，那么会返回一个错误的答案~~）

```
double Newton_Iteration(double F,int tim){//输入迭代系数F=F(0)，迭代次数tim
  while(tim--)F=F-f(F)/f1(F);//f1(x)=f'(x)
  return F;
}
```
$\ \ \ \ \ \ \ $这里只是简单地讲一下** 一阶牛顿迭代 **，具体的讲解，有兴趣可以戳下面的链接，博主觉得讲得很清晰 ~~（还有互交动画啊XD）~~ 。

## $\ \ \ \ \ \ \ $[--·--·--《推荐讲解文章》--·--·--](https://matongxue.com/madocs/205.html)

------------

### 如果对本题还有什么疑问或者更好的做法，欢迎洛谷私信我或者发送邮件到[althenwaysatan@foxmail.com](mailto:althenwaysatan@foxmail.com)
$\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ $![发光](https://s1.ax1x.com/2018/10/14/iUlRx0.png)

---

## 作者：NaCly_Fish (赞：7)

看到这题的提交记录和题解，人类迷惑行为大赏素材 $+1$   
~~然而我最初也很迷惑的做了个卷积~~
****  
题意很简单，求 $[l,r]$ 范围内的一个 $x$，使得：  
$$C(x)^2=A(x)^2+B(x)^2$$
设
$$F(x)=A(x)^2+B(x)^2-C(x)^2$$
则
$$F'(x)=2A(x)A'(x)+2B(x)B'(x)-2C(x)C'(x)$$
根据牛顿迭代公式求 $F(x)$ 的零点
$$x_{n+1}=x_n-\frac{F(x_n)}{F'(x_n)}$$
初值可以选 $(l+r)/2$，$A(x),B(x),C(x)$ 都是多项式函数，容易求导。  

然后直接计算即可。

---

## 作者：AubRain (赞：4)

## FFT+二分

个人认为还是道比较清新的题。

根据速度的矢量性，$A$ 和 $B$的矢量和的大小就是 $ \sqrt{A^2+B^2} $。于是需要找一个 $x$ 使得 $C^2(x)=A^2(x)+B^2(x)$ 即可。


令 $f(x)=C^2(x)-A^2(x)-B^2(x)$，$f(x)$ 可以用 $FFT$ 求出。然后就是个裸的函数求零点问题了。因为不会牛顿迭代，所以写的二分。（果然最优解倒数第一

~~第一次提交就是90分，交了十几次变成60分了~~

二分次数大会 $T$ ，小会 $WA$ ，调一下就行了

代码：

```cpp
#include<bits/stdc++.h>
#define N 400005
using namespace std;

inline void rd(int &X){
    X=0;char ch=0;
    while(!isdigit(ch))ch=getchar();
    while( isdigit(ch))X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
}

double L,R;
int n,lim,la,lb,lc;
int r[N],a[N],b[N],c[N];
const double Pi=acos(-1);
struct nd{double x,y;}f[N];

nd operator + (nd a,nd b){
    return (nd){a.x+b.x,a.y+b.y};
}nd operator - (nd a,nd b){
    return (nd){a.x-b.x,a.y-b.y};
}nd operator * (nd a,nd b){
    return (nd){a.x*b.x-a.y*b.y,a.y*b.x+a.x*b.y};
}

void fft(int opt){
    for(int i=0;i<lim;i++)
        if(i<r[i]) swap(f[i],f[r[i]]);
    for(int i=1;i<lim;i<<=1){
        nd tmp=(nd){cos(Pi/i),opt*sin(Pi/i)};
        for(int k=0;k<lim;k+=(i<<1)){
            nd b=(nd){1,0};
            for(int j=k;j<k+i;j++,b=b*tmp)
                {nd now=b*f[j+i];f[j+i]=f[j]-now;f[j]=f[j]+now;}
        }
    }
}
void mul(int *g){
	for(int i=0;i<lim;i++)
		f[i]=(nd){g[i],0};
	fft(1);for(int i=0;i<lim;i++) f[i]=f[i]*f[i]; fft(-1);
	for(int i=0;i<=n;i++)
		g[i]=f[i].x/lim+0.5;
}
inline double F(double x){
	double ans=0,now=1;
	for(int i=0;i<=n;i++)
		ans+=a[i]*now,now*=x;
	return ans;
}
void work(double l,double r){
	for(int i=1;i<=25;i++){
		double mid=(l+r)/2;
		F(l)*F(mid)<0 ? r=mid : l=mid;
	}
	printf("%.10lf",l);
} 
signed main(){
    rd(la);rd(lb);rd(lc);scanf("%lf%lf",&L,&R);
    for(int i=0;i<=la;i++) rd(a[i]);
    for(int i=0;i<=lb;i++) rd(b[i]);
    for(int i=0;i<=lc;i++) rd(c[i]);
    n=max(la,max(lb,lc))<<1;
    for(lim=1;lim<=n;lim<<=1);
    for(int i=0;i<lim;i++)
        r[i]=(r[i>>1]>>1)|((i&1)?lim>>1 :0);
	mul(a);mul(b);mul(c);
	for(int i=0;i<=n;i++)
		a[i]=c[i]-a[i]-b[i];
	for(double i=L;i<=R;i+=0.1)
		if(F(i)*F(i+0.1)<0)
			return work(i,i+0.1),0;
	puts("Inconsistent!");
}
```

UPD：学了牛顿迭代，果然进了最优解前三

先确定一个 $x$ ，每次令 $x=x-\frac {f(x)}{f'(x)}$，迭代若干次就能确定零点了。

代码：

```cpp
#pragma GCC optimize(2)
#include<bits/stdc++.h>
#define N 400005
using namespace std;

inline void rd(int &X){
    X=0;char ch=0;
    while(!isdigit(ch))ch=getchar();
    while( isdigit(ch))X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
}

double L,R;
int n,lim,la,lb,lc;
struct nd{double x,y;}f[N];
int r[N],a[N],b[N],c[N],aa[N];
const double Pi=acos(-1),eps=1e-10;

nd operator + (nd a,nd b){
    return (nd){a.x+b.x,a.y+b.y};
}nd operator - (nd a,nd b){
    return (nd){a.x-b.x,a.y-b.y};
}nd operator * (nd a,nd b){
    return (nd){a.x*b.x-a.y*b.y,a.y*b.x+a.x*b.y};
}

void fft(int opt){
    for(int i=0;i<lim;i++)
        if(i<r[i]) swap(f[i],f[r[i]]);
    for(int i=1;i<lim;i<<=1){
        nd tmp=(nd){cos(Pi/i),opt*sin(Pi/i)};
        for(int k=0;k<lim;k+=(i<<1)){
            nd b=(nd){1,0};
            for(int j=k;j<k+i;j++,b=b*tmp)
                {nd now=b*f[j+i];f[j+i]=f[j]-now;f[j]=f[j]+now;}
        }
    }
}
void mul(int *g){
	for(int i=0;i<lim;i++)
		f[i]=(nd){g[i],0};
	fft(1);for(int i=0;i<lim;i++) f[i]=f[i]*f[i]; fft(-1);
	for(int i=0;i<=n;i++)
		g[i]=f[i].x/lim+0.5;
}
inline double F(double x){
	double ans=0,now=1;
	for(int i=0;i<=n;i++)
		ans+=a[i]*now,now*=x;
	return ans;
}
inline double FF(double x){
	double ans=0,now=1;
	for(int i=0;i<n;i++)
		ans+=aa[i]*now,now*=x;
	return ans;
}
void work(double x){
	for(int i=1;i<=30;i++){
		double now=F(x);
		if(fabs(now)<eps) 
			return printf("%.9lf",x),void();
		x=x-now/FF(x);
		x=max(x,L);x=min(x,R);
	}
	puts("Inconsistent!");
} 
signed main(){
    rd(la);rd(lb);rd(lc);scanf("%lf%lf",&L,&R);
    for(int i=0;i<=la;i++) rd(a[i]);
    for(int i=0;i<=lb;i++) rd(b[i]);
    for(int i=0;i<=lc;i++) rd(c[i]);
    n=max(la,max(lb,lc))<<1;
    for(lim=1;lim<=n;lim<<=1);
    for(int i=0;i<lim;i++)
        r[i]=(r[i>>1]>>1)|((i&1)?lim>>1 :0);
	mul(a);mul(b);mul(c);
	for(int i=0;i<=n;i++)
		a[i]=c[i]-a[i]-b[i];
	for(int i=0;i<n;i++)
		aa[i]=a[i+1]*(i+1);
	work((L+R)/2);	
}
```

---

## 作者：Taduro (赞：3)

乱搞真是好玩，牛顿迭代不存在的。。。

首先解释题意：圆的边界就是出口，想要同时到达圆的边界速度就要一样，三个矢量要构成一个直角三角形，那么就是说让你找一个x满足$c^2(x)=a^2(x)+b^2(x)​$。

设$f(x)=c^2(x)-a^2(x)-b^2(x)$，那么就是求$f$在$[l,r]$范围里的零点。

首先谁都知道FFT求出f，我不说废话了。

然后如果你知道一个区间$[l,r]$满足$f(l)\times f(r)<=0$，这个区间一定至少有一个零点。二分就是了，不想讲二分，附上二分代码：
```c++
int ta=(u>v);
double eps=1e-9,mid,l=min(u,v),r=max(u,v);
while (r-l>eps){
	mid=(l+r)/2.0;
	if (f(mid)>0.0){if (ta) l=mid; else r=mid;}
	else{if (ta) r=mid; else l=mid;}
}
return mid;
```

那么我们怎么找到两个异号的点呢？模拟退火找！没了！

```c++
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
using namespace std;
const double Pi=acos(-1.0);
struct complex{
	double x,y;
	complex (double xx=0,double yy=0){x=xx,y=yy;}
}a[400001],b[400001],c[400001];
double u,v,ri,le;
int la,lb,lc,r[400001],l,lim,maxn;
complex operator + (complex a,complex b){return complex(a.x+b.x,a.y+b.y);}
complex operator - (complex a,complex b){return complex(a.x-b.x,a.y-b.y);}
complex operator * (complex a,complex b){return complex(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);}
inline void FFT(complex *a,int inv){
	for (int i=0; i<lim; i++)
		if (i<r[i]) swap(a[i],a[r[i]]);
	for (int i=1; i<lim; i<<=1){
		complex wn(cos(Pi/i),inv*sin(Pi/i));
		for (int j=0; j<lim; j+=(i<<1)){
			complex w(1,0);
			for (int k=0; k<i; k++,w=w*wn){
				complex x=a[j+k],y=w*a[i+j+k];
				a[j+k]=x+y; a[i+j+k]=x-y;
			}
		}
	}
	if (inv<0)
		for (int i=0; i<=lim; i++) a[i].x=a[i].x/(double)(lim);
}
inline double getans(double x){
	double sum=0,p=1;
	for (int i=0; i<=maxn; i++)
		sum+=p*c[i].x,p*=x;
	return sum;
}
inline double SA(int inv){
	double t=1,delta=0.995,eps=1e-5,ans=0,num=getans(0),older;
	double res=0,kin=num;
	while (t>eps){
		int w=rand()%2; double dx=((rand()*1000.0)/(RAND_MAX*1000.0));
		if (w) dx*=(ri-ans); else dx*=(le-ans);
		older=getans(ans+dx)-num;
		if (inv){
			if (older>0||exp((double)(-older/t))*RAND_MAX>(rand()*100000.0)/100000.0){
				num+=older,ans+=dx;
				if (num>kin) kin=num,res=ans;
				if (kin>0) return res;
			}
		}
		else{
			if (older<0||exp((double)(older/t))*RAND_MAX>(rand()*100000.0)/100000.0){
				num+=older,ans+=dx;
				if (num<kin) kin=num,res=ans;
				if (kin<0) return res;
			}
		}
		t=t*delta;
	}
//	printf("%.8lf %.8lf\n",res,kin);
	if (((!inv)&&kin>0)||(inv&&kin<0)) return -4;
	return res;
}
double calc(){
	int ta=(u>v);
	double eps=1e-9,mid,l=min(u,v),r=max(u,v);
	while (r-l>eps){
		mid=(l+r)/2.0;
		if (getans(mid)>0.0){if (ta) l=mid; else r=mid;}
		else{if (ta) r=mid; else l=mid;}
	}
	return mid;
}
int main(){
	srand(20190613);
	scanf("%d%d%d",&la,&lb,&lc);
	scanf("%lf%lf",&le,&ri);
	for (int i=0; i<=la; i++) scanf("%lf",&a[i].x);
	lim=1; while (lim<=la+la) lim<<=1,l++;
	for (int i=0; i<lim; i++)
		r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));
	FFT(a,1);
	for (int i=0; i<=lim; i++) a[i]=a[i]*a[i];
	FFT(a,-1); maxn=max(maxn,lim);
	memset(r,0,sizeof(r));
	for (int i=0; i<=lb; i++) scanf("%lf",&b[i].x);
	l=0; lim=1; while (lim<=lb+lb) lim<<=1,l++;
	for (int i=0; i<lim; i++)
		r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));
	FFT(b,1);
	for (int i=0; i<=lim; i++) b[i]=b[i]*b[i];
	FFT(b,-1); maxn=max(maxn,lim);
	memset(r,0,sizeof(r));
	for (int i=0; i<=lc; i++) scanf("%lf",&c[i].x);
	l=0; lim=1; while (lim<=lc+lc) lim<<=1,l++;
	for (int i=0; i<lim; i++)
		r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));
	FFT(c,1);
	for (int i=0; i<=lim; i++) c[i]=c[i]*c[i];
	FFT(c,-1); maxn=max(maxn,lim);
	for (int i=0; i<=maxn; i++) c[i]=c[i]-a[i]-b[i];
//	printf("%d\n",maxn);
//	for (int i=0; i<maxn; i++) printf("%.3lf ",c[i].x);
//	puts("");
	u=SA(0); v=SA(1);
	if (u<-3||v<-3){puts("Inconsistent!"); return 0;}
	printf("%.8lf",calc());
	return 0;
}
```



---

## 作者：Walter_Fang (赞：1)

### 前言
卷积的不做评价。

正解应该有 $2$ 个做法，牛顿迭代或 $\text{FFT}$。
### 题意
求解区间 $[L,R]$ 内满足 $C^2(x)=A^2(x)+B^2(x)$ 的 $x$。
### 解析
令 $f(x)=C^2(x)-A^2(x)-B^2(x)$，接下来分 $2$ 种做法。
 - $f(x)$ 可以直接用 $\text{FFT}$ 求，那么接下来根据零点存在定理二分求函数零点即可。题解区用模拟退火的乱搞做法我没看懂。
 - $f'(x)=2C(x)C'(x)-2A(x)A'(x)-2B(x)B'(x)$，根据牛顿迭代公式 $x_{n+1}=x_n-\frac{f(x_n)}{f'(x_n)}$ 代入迭代几次即可。初值选 $\frac{l+r}{2}$。

---

## 作者：Natori (赞：0)

>[洛谷 P4986 逃离](https://www.luogu.com.cn/problem/P4986)

相当于求函数 $f(x)=C^2(x)-A^2(x)-B^2(x)$ 在 $[L,R]$ 内的零点。

考虑牛顿迭代，过 $(x_0,f(x_0))$ 作 $y=f(x)$ 的切线 $y=f'(x_0)x+b$，代入 $(x_0,f(x_0))$ 得到 $b=f(x_0)-f'(x_0)x_0$，故 $y=f'(x_0)x+f(x_0)-f'(x_0)x_0=f(x_0)+f'(x_0)(x-x_0)$。切线与 $x$ 轴交点的横坐标 $x=x_0-\frac{f(x_0)}{f'(x_0)}$。

本题中，$f'(x)=2C(x)C'(x)-2A(x)A'(x)-2B(x)B'(x)$，可以直接代入牛顿迭代计算，初值取 $\frac{L+R}{2}$ 可以通过。

```
#include<bits/stdc++.h>
using namespace std;
bool Mbegin;
void File_Work(){
	freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);
}
typedef double Ld;
const int N=1e5+8;
const Ld eps=1e-6;
int a,b,c;
Ld L,R;
vector<Ld> A,B,C,A1,B1,C1;
Ld get(vector<Ld> f,Ld x){
	Ld res=0;
	for(int i=(int)f.size()-1;i>=0;i--)
		res=res*x+f[i];
	return res;
}
void mian(){
	cin>>a>>b>>c>>L>>R;
	A.resize(a+1);
	A1.resize(a);
	B.resize(b+1);
	B1.resize(b);
	C.resize(c+1);
	C1.resize(c);
	for(int i=0;i<=a;i++){
		cin>>A[i];
		if(i>=1)
			A1[i-1]=1.0*i*A[i];
	}
	for(int i=0;i<=b;i++){
		cin>>B[i];
		if(i>=1)
			B1[i-1]=1.0*i*B[i];
	}
	for(int i=0;i<=c;i++){
		cin>>C[i];
		if(i>=1)
			C1[i-1]=1.0*i*C[i];
	}
	Ld ans=(L+R)/2.0;
	bool ok=0;
	for(int i=27;i>=0;i--){
		Ld Ax=get(A,ans),Bx=get(B,ans),Cx=get(C,ans),A1x=get(A1,ans),B1x=get(B1,ans),C1x=get(C1,ans);
		Ld Fx=Cx*Cx-Ax*Ax-Bx*Bx;
		if(fabs(Fx)<eps){
			cout<<fixed<<setprecision(9)<<ans;
			ok=1;
			break;
		}
		Ld F1x=2.0*Cx*C1x-2.0*Ax*A1x-2.0*Bx*B1x;
		ans=min(R,max(L,ans-Fx/F1x));
	}
	if(ok==0)
		cout<<"Inconsistent!";
}
bool Mend;
int main(){
//	File_Work();
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cerr<<fixed<<setprecision(3)<<(&Mbegin-&Mend)/1048576.0<<" MB\n\n\n";
	int testnum=1;
//	cin>>testnum;
	while(testnum--)
		mian();
	cerr<<"\n\n\n"<<fixed<<setprecision(0)<<1e3*clock()/CLOCKS_PER_SEC<<" ms";
	return 0;
}
```

```long double``` 咋过不了第一个点捏。。。

---

## 作者：xyz105 (赞：0)

## 【模板】牛顿迭代法 ~~（题目别称）~~


### 题目描述

平面的原点上有两个人。$1$ 号人可以 **水平移动** 或 **竖直移动**，且 水平向右移动速度为 $A(x)$，竖直向上移动速度为 $B(x)$；$2$ 号人可以 **任选一个方向** 并 **沿该固定方向移动**，移动速度为 $C(x)$；$A(x),B(x),C(x)$ 均为关于 $x$ 的多项式。设移动时间为 $t$，要求在 $[L,R]$ 中找出一个 $x$ 使得 $t$ 单位时间后 $1$ 号人能和 $2$ 号人**恰好汇合**。


### 解题思路

首先有一个显然的转化：将 $1$ 号人的**若干次**水平移动 合并成 **一次**水平移动；将 $1$ 号人的**若干次**竖直移动 合并成 **一次**竖直移动。如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/n049vnh6.png)

当 $1$ 号人 的路径被确定了之后，$2$ 号人的路径也应被直接确定了，接上图：

![](https://cdn.luogu.com.cn/upload/image_hosting/c5v00hfw.png)

$1$ 号人的水平向右移动路程为 $A(x)\cdot t$，竖直向上移动路程为 $B(x)\cdot t$，$2$ 号人的移动路程为 $C(x)\cdot t$。因为这两个人走的路构成一个直角三角形，所以有 $(A(x)\cdot t)^2+(B(x)\cdot t)^2=(C(x)\cdot t)^2$，即 $A^2(x)+B^2(x)=C^2(x)$。

也就是说，这题要求关于 $x$ 的方程 $F(x)=C^2(x)-A^2(x)-B^2(x)=0$ 的解。因为它的次数不定，可考虑使用**牛顿迭代法**。

牛顿迭代法提供了一种快速求 $x$ 使得 $F(x)=0$ 的技巧。先随便定一个答案 $x_0$，在 $x_0$ 之上迭代出的 $x_1$ 将会更接近真实结果。具体的迭代方式为：作一条直线使它在 $x_0$ 处与 $F(x)$ 的函数图像相切，这条直线与 $x$ 轴的交点即为迭代出的 $x_1$，如下图（假设那条红色曲线就是函数图像）：

![](https://cdn.luogu.com.cn/upload/image_hosting/gdigtraj.png)

从 $x_1$ 迭代到 $x_2$ 也是同理。在 $x_1$ 处做切线，其与 $x$ 轴交于 $x_2$：

![](https://cdn.luogu.com.cn/upload/image_hosting/sl5c5kvp.png)

$x_2$ 跑到红色曲线右边去了也没关系，反正它依然更接近真正的函数零点。像这样重复迭代多次即可得到较精确的解。

由导数的几何意义可知，$x_n$ 处的切线斜率为 $F'(x_n)$，因为该切线过点 $(x_n, F(x_n))$，故该切线的方程为 $y=F(x_n)+F'(x_n)\cdot(x-x_n)$。若 $y=0$，可相应得出切线与 $x$ 轴的交点，即有 $x=x_n-\frac{F(x_n)}{F'(x_n)}$，它就是 $x_{n+1}$。

当然某些情况下这种方法找不到正确解，只需要迭代一定次数后特判即可。

~~牛顿迭代法的正确性证明暂缺。~~


### 参考代码

已将提交记录里源代码多余的部分删除。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <cmath>
#include <complex>
using namespace std;


const double pi = acos(-1.);
const double eps = 1e-10;


typedef long long ll;


vector<int> _vec;

template<typename T, typename _unitRoot>
struct poly{
	
	_unitRoot _urt;
	
	
	vector<T> _a;
	
	inline void clear(){_a.clear();}
	
	
	inline poly operator=(poly _f)
		{_a.resize(_f._a.size()), copy(_f._a.begin(), _f._a.end(), _a.begin()); return *this;}
	
	inline T& operator[](int _i) {return _a[_i];}
	
	
	T operator()(T x)
	{
		T _res = 0;
		for (int i = (int)_a.size() - 1; i >= 0; --i) _res = (_a[i] + x * _res);
		return _res;
	}
	
	
	inline poly deriv() // derivative.
	{
		poly _f; _f._a.resize(max((int)_a.size() - 1, 0));
		for (unsigned int i = 1; i < _a.size(); ++i) _f._a[i - 1] = _a[i] * i;
		return _f;
	}
	inline poly integr() // integral.
	{
		poly _f; _f._a.resize(_a.size() + 1);
		for (unsigned int i = 1; i <= _a.size(); ++i)
			_f._a[i] = _a[i - 1] / i;
		return _f;
	}
	
	
	inline poly operator+=(poly _f)
	{
		int len = max(_a.size(), _f._a.size());
		_a.resize(len), _f._a.resize(len);
		for (int i = 0; i < len; ++i) _a[i] = (_a[i] + _f._a[i]);
		return *this;
	}
	poly operator+(poly _f)
		{poly _res = *this; return _res += _f;}
	
	inline poly operator-=(poly _f)
	{
		int len = max(_a.size(), _f._a.size());
		_a.resize(len), _f._a.resize(len);
		for (int i = 0; i < len; ++i) _a[i] = (_a[i] - _f._a[i]);
		return *this;
	}
	poly operator-(poly _f)
		{poly _res = *this; return _res -= _f;}
	
	
	inline void FFT(int opt)
	{
		int _len = 1;
		for (; ; _len <<= 1)
			if ((unsigned)_len >= _a.size()) {_a.resize(_len); break;}
		_vec.resize(_len), _vec[0] = 0;
		for (int i = 1; i < _len; ++i)
			_vec[i] = ((_vec[i >> 1] >> 1) | ((i & 1) ? (_len >> 1) : 0));
		
		for (int i = 0; i < _len; ++i)
			if (_vec[i] < i) swap(_a[_vec[i]], _a[i]);
		for (int i = 2; i <= _len; i <<= 1)
		{
			T wn = _urt(i);
			if (opt == -1) wn = (T)1 / wn;
			for (int j = 0; j + i <= _len; j += i)
			{
				T w = 1;
				for (int k = 0; k < i/2; k++)
				{
					T k1 = _a[j + k], k2 = w * _a[j + i/2 + k];
					_a[j + k] = k1 + k2;
					_a[j + i/2 + k] = k1 - k2;
					w = w * wn;
				}
			}
		}
		T _vecLen = 1; _vecLen /= _len;
		if (opt == -1)
			for (int i = 0; i < _len; ++i) _a[i] = _a[i] * _vecLen;
	}
	
	poly operator*=(poly _f)
	{
		int len = _a.size() + _f._a.size();
		_a.resize(len), _f._a.resize(len);
		FFT(1), _f.FFT(1);
		for (unsigned int i = 0; i < _a.size(); ++i) _a[i] = _a[i] * _f._a[i];
		FFT(-1); return *this;
	}
	poly operator*(poly _f)
		{poly _res = *this; return _res *= _f;}
	
};

struct urt{
	complex<double> operator()(ll x)
		{double rad = 2 * pi / x; return complex<double>(cos(rad), sin(rad));}
};


complex<double> operator*(complex<double> a, ll b)
	{return a * complex<double>(b);}


int main()
{
	double l, r; int la, lb, lc, len;
	scanf("%d%d%d%lf%lf", &la, &lb, &lc, &l, &r);
	
	poly<complex<double>, urt> a, b, c;
	complex<double> x = (l + r) / 2;
	
	double i1;
	for (int i = 0; i <= la; i++) scanf("%lf", &i1), a._a.push_back(i1);
	for (int i = 0; i <= lb; i++) scanf("%lf", &i1), b._a.push_back(i1);
	for (int i = 0; i <= lc; i++) scanf("%lf", &i1), c._a.push_back(i1);
	
	a = c * c - a * a - b * b;
	len = max(max(la * 2 + 1, lb * 2 + 1), lc * 2 + 1), a._a.resize(len);
	for (int i = 0; i < a._a.size(); ++i) a[i] = a[i].real();
	b = a.deriv();
	
	for (int i = 30; i; i--)
	{
		double a1 = a(x).real();
		if (fabs(a1) < eps) break; else x = min(max(x.real() - a1 / b(x).real(), l), r);
	}
	if (fabs(a(x.real())) < eps) printf("%.10lf", x.real());
	else printf("Inconsistent!");
	
	return 0;
}
```

---


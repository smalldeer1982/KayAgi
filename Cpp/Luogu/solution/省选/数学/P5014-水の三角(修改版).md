# 水の三角(修改版)

## 题目背景

这个三角图真好看。。

![](https://cdn.luogu.com.cn/upload/image_hosting/3xer0cul.png)

这个是 ${\rm 4}$ 阶三角图。。

## 题目描述

现在我们定义一个三角图是像上面一样的图。。

请求出一个无限大的三角图从 $1$ 号点走到 $u$ 号点的方案数。

有 $T$ 组询问。

## 说明/提示

${\rm Subtask 1(10\ pts)}$:$1 \leq T \leq 100, \qquad 1 \leq u_i \leq 55$

${\rm Subtask 2(20\ pts)}$:$1 \leq T \leq 100, \qquad 1 \leq u_i \leq 12502500$

${\rm Subtask 3(30\ pts)}$:$1 \leq T \leq 100, \qquad 1 \leq u_i \leq 500000500000 \qquad u_i=\frac{x \times (x + 1)}{2}$

${\rm Subtask 4(40\ pts)}$:$1 \leq T \leq 100, \qquad 1 \leq u_i \leq 500000500000$

## 样例 #1

### 输入

```
3
1 3 6
```

### 输出

```
1
2
6
```

# 题解

## 作者：CYJian (赞：8)

这道题。。和[原来的题目](https://www.luogu.org/problemnew/show/U49214)相比就是把点放在了不是左下角的地方。然而如果真正理解了之前给出的解法并且深入了解了卡特兰数，那么这道题也是变一下就可以的了。

[原来的题目的题解地址](https://www.luogu.org/blog/20782/solution4)(请手动翻到T3的位置)

依旧是老的配方，我们可以考虑枚举走横边的条数，然后考虑后一部分的走法。由于不是走到右下角，所以就不是标准的卡特兰数了。

关于卡特兰数的一个公式：

$$Catalan_n=\binom{2n}{n}-\binom{2n}{n-1}$$

如果知道了这个东西的来历，那么就非常好办了。

我们知道卡特兰数的一个作用是计算合法的括号序列的个数。这个可以转化成在笛卡尔坐标系的原点向上或者向右走，并且不越过直线$y=x$的方案数。

我们可以考虑先把穿过了直线$y=x$的方案算进去，然后最后再减掉。那么直接走的话就可以用组合数$\binom{2n}{n}$表示在$2n$步中选择$n$步走向上，其他走向右的方案数。显然我们还需要减掉一些多走了的。

可以考虑这样去思考：我们将第一次越过直线$y=x$后的所有走法全部换一下，就是向上变成向右，向右变成向上，这样的话就**一定**会有$n-1$步向上，$n+1$步向右。然后就肯定会走到$(n+1,n-1)$。走到这里的方案数就是$\binom{2n}{n-1}$(和上面的组合数是一样的意思)，也就是不合法的方案数。

然后用$\binom{2n}{n}-\binom{2n}{n-1}$得到了合法的方案。

仿照卡特兰数，我们可以考虑走$n$步向上，$m$步向右($n>m$)且不超过直线$y=x$的方案数。此处的$n$为询问点的层数减去走横向边的个数，$m$为询问点从左往右数是第几个减去走横向边的个数-1。这个转换可以思考一下。

然后按照之前的思路，这里的答案就变成了$\binom{n+m}{n}-\binom{n+m}{n-1}$。用这个去替换掉原来标程的$Catalan(n-i)$就好了。

---

## 作者：Zimo_666 (赞：7)

## P5014 水の三角(修改版)   

### 题意

请求出一个无限大的三角图从 1 号点走到 $u$ 号点的方案数。

有 $T$ 组询问。

### 分析

首先我们查看操作对我们当前位置的影响。

左下：$(1,0)$；右下：$(1,1)$；右：$(0,1)$。

易得枚举往左下或者右下走的次数是比较方便的。易发现枚举往右下走的次数更好，因为不影响边界。而后若假设枚举了往右下走的次数 $k$，那么我们显然有左下 $x-k$ 步，右下 $k$ 步，右 $y-k$ 步。则右下走的方案数为 $C_{x+y-k}^{k}(k∈[0,\min⁡(x,y) ])$。而后我们此时有：从 $(0,0)$ 走到 $(x-k,y-k)$，每步可以走 $x$ 或 $y$，要求过程中 $y≤x$，求方案数 $f(k)$。则我们使用计算卡特兰数模板的方法，我们把不合法的路径都映射到从 $(0,0)$ 走到 $(y-k-1,x-k+1)$ 的路径上。则可由组合数的意义得 $f(k)=C_{x+y-2k}^{x-k}-C_{x+y-2k}^{x-k+1}$。则我们可以由乘法原理得总贡献为右下方案数乘上合法其他路径方案数。则有 $Ans=\sum_{k=0}^{\min(x,y)}C_{x+y-k}^{k}·f_{k}$。考虑使用快速幂+逆元维护组合数。别忘了处处取模。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m;
const int mod=998244353;
struct node{
  int inv[2000090],fac[2000090];
  int qpow(int shu,int cifang){
    int ans=1;int k=cifang;
    while(k){
      if(k&1){ans=ans*shu%mod;ans%=mod;shu=shu*shu%mod;shu%=mod;}
      else{shu=shu*shu%mod;shu%=mod;}
      k>>=1;
    }
    return ans%mod;
  }
  void init(int len){
    fac[0]=1;
    for(int i=1;i<=len;i++) fac[i]=fac[i-1]*i%mod;
    inv[len]=qpow(fac[len],mod-2);
    for(int i=len;i;i--){
      inv[i-1]=inv[i]*(i)%mod;
    }
  }
  int C(int n,int m){
  	// printf("%d %d\n",n,m);
//  	printf("%d",fac[n]%mod*inv[m]%mod*inv[n-m]%mod);
    return fac[n]%mod*inv[m]%mod*inv[n-m]%mod;
  }
}lg_get;

int f(int x,int y,int k){
  int ans=lg_get.C(x+y-2*k,x-k)%mod-lg_get.C(x+y-2*k,x-k+1)%mod;
  ans+=mod,ans%=mod;
  return ans;
}
void solve(){
  scanf("%lld",&n);
	int a=sqrt(n)-1,k;
	while(n-(long long)a*(a-1)/2>a)a++;
	k=n-(long long)a*(a-1)/2;
  // int x=k,y=a;
  int y=k,x=a;
  x--,y--;
  // printf("%lld %lld\n",x,y);
  int ans=0;
  for(int kk=0;kk<=min(x,y);kk++){
  	// printf("%d\n",kk);
    int tmp=lg_get.C(x+y-kk,kk)%mod*f(x,y,kk)%mod;
    tmp%=mod;
    // printf("%lld\n",tmp);
    ans+=tmp;
    ans%=mod;
  }
  printf("%lld\n",ans);
}
const int MAXN=1e6+7;
signed main(){
  lg_get.init(MAXN*2);
  int T;
  cin>>T;
  while(T--) solve();
}
```



---

## 作者：Link_Cut_Y (赞：5)

给定三角网格图，求从点 $(1, 1)$ 走到点 $(n, m)$ 的路径方案数。

首先将三角推平，变成这个样子：

```
1
|
2 - 3
|   |
4 - 5 - 6
```

上图是没有斜线的情况，这就是裸的卡特兰数。由于要向右走 $m - 1$ 步，向下走 $n - 1$ 步，所以设 $n' = n - 1, m' = m - 1$，答案即为：

$$\binom{n' + m'}{m'} - \binom{n' + m'}{m' - 1}$$

接下来考虑走斜线的情况。假设走了 $i$ 次斜线，那么向下走的次数变为了 $n_0 = n' - i$，向右走的次数变为了 $m_0 = m' - i$。现在分两种情况讨论：

 - 只走直线。如上，方案数即为：
 
 $$\binom{n_0 + m_0}{m_0} - \binom{n_0 + m_0}{m_0 - 1}$$
 
 - 走斜线。根据插板法，方案数即为：
 
 $$\binom{n_0 + m_0 + i}{i}$$
 
 根据乘法原理，直接将两种方案乘起来就可以了。故方案数为：
 
 $$\sum \limits_{i = 0}^{m'} \binom{n_0 + m_0 + i}{i} \left [ \binom{n_0 + m_0}{m_0} - \binom{n_0 + m_0}{m_0 - 1} \right ]$$
 
```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>
#define int long long

using namespace std;

const int N = 2000010;
const int mod = 998244353;
int T, fac[N], ifac[N];
int power(int a, int b) {
	int ans = 1; for (; b >>= 1; a = a * a % mod)
		if (b & 1) ans = ans * a % mod; return ans;
}
void init(int n) {
	fac[0] = 1;
	for (int i = 1; i <= n; i ++ )
		fac[i] = 1ll * fac[i - 1] * i % mod;
	ifac[n] = power(fac[n], mod - 2);
	for (int i = n - 1; i >= 0; i -- )
		ifac[i] = 1ll * ifac[i + 1] * (i + 1) % mod;
}
int C(int n, int m) {
	return fac[n] * ifac[m] % mod * ifac[n - m] % mod; 
}
int f(int n, int m) { 
	return (C(n, m) % mod - C(n, m + 1) % mod + mod) % mod; 
}
signed main() {
	scanf("%lld", &T); init(N - 10);
	while (T -- ) {
		int x; scanf("%lld", &x);
		int n = sqrt(x); 
		while (n * (n + 1) / 2 < x) n ++ ;
		int m = x - (n * (n - 1) / 2);
		int ans = 0; n -- , m -- ;
		for (int i = 0; i <= m; i ++ ) {
			int n0 = n - i, m0 = m - i;
			(ans += (C(n0 + m0, m0) - C(n0 + m0, m0 - 1) + mod) % mod * C(n0 + m0 + i, i) % mod) %= mod;
		} printf("%lld\n", ans);
	} return 0;
}
```

---

## 作者：maruize (赞：4)

把图压一压，发现是一个三角半矩阵，如果没有斜着的边就几乎是 Catalan 数经典题。

怎么办呢？发现 $n$ 足够小使得可以枚举斜着走了几次。

然后这个问题就转化成 $(1,1)\rightarrow (a',k')$ 每时每刻向下必须比向右多的方案数。

如果 $a'=k'$ 那就是 $Catalan(k')$

我一开始想让它乘上个组合数 ($C_{a'+k'}^{a'-k'}$) , 然而仔细想想显然会算重。

那就考虑魔改一下 Catalan 数，变成 $n$ 个 $0$ ， $m$ 个 $1$ ，前缀 $0 \ge$ 前缀 $1$ 的方案数。

然后下面和推 Catalan 的方法几乎一样了。

先取补集，全集是 $C_{n+m}^{n}$

考虑不合法的一定是：合法的 Catalan 序列  + 1 + 随机 0/1 的序列。

反转前两部分，变成 [ $i$ 个 $0$ ， $i$ 个 $1$ $| \ \ 0 \ \ |$ $n-i$个 $0$， $m-i-1$ 个 $1$ ]

可以发现不合法的 $n$ 个 $0$ ， $m$ 个 $1$ 序列与 $n+1$ 个 $0$ ， $m-1$ 个 $1$ 的序列一一对应。

所以 $fakeCat(n,m)=C_{n+m}^{n}-C_{n+m}^{n+1}$ 

---

**$\color{blue}{code:}$**

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
#define pii pair<int,int>
#define fs first
#define sc second
#define pb push_back
const int N=2.1e6,mod=998244353;
int qp(int a,int b){
	int res=1;
	while(b){
		if(b&1)res=(LL)res*a%mod;
		a=(LL)a*a%mod,b/=2;
	}
	return res;
}
#define inv(i) qp(i,mod-2)
#define Cat(n) (C(2*(n),n)-C(2*(n),(n)-1)+mod)
#define fakeCat(n,m) ( C(n+m,n) - C(n+m,n+1) +mod )
#define C(n,m) (LL)fac[n]%mod*ifac[m]%mod*ifac[(n)-(m)]%mod
int fac[N],ifac[N];
int work(LL n){
	int a=sqrt(n)-1,k;
	while(n-(LL)a*(a-1)/2>a)a++;
	k=n-(LL)a*(a-1)/2;
	int ans=0;
	for(int i=0;i<k;i++){//斜路 
		int _a=a-1-i,_k=k-1-i;
	//	ans+=C(_a+_k+i,i)*C(_a+_k,_a-_k)*Cat(_k)%mod;算重
		ans+=C(_a+_k+i,i)*fakeCat(_a,_k)%mod;
		if(ans>=mod)ans-=mod;
	}
	return ans;
}
int main(){
	fac[0]=1;
	for(int i=1;i<=2e6;i++)fac[i]=(LL)fac[i-1]*i%mod;
	for(int i=0;i<=2e6;i++)ifac[i]=inv(fac[i]);
	int t;LL n;
	scanf("%d",&t);
	while(t--)scanf("%lld",&n),printf("%d\n",work(n));
	return 0;
}


```

---

## 作者：GIFBMP (赞：2)

我们发现，这幅图变形一下就是一个三角网格。那么对于一个 $n$，我们可以快速处理出它所对应的行和列坐标 $(x,y)$。

我们发现这幅图中有斜着的边，很难处理。但我们发现行数和列数都很小，只有 $\Theta(\sqrt n)$ 的级别。于是我们考虑枚举走过了多少斜边。设这个条数为 $k$，那么问题就转化为，从 $(1,1)$ 向上走 $x-k-1$ 步，向右走 $y-k-1$ 步，且不能超过直线 $y=x$ 的方案数。

如果 $x=y$，那么这个问题就是典型的卡特兰数。但是 $x$ 不一定等于 $y$，因此我们可以仿照卡特兰数的推导方法，考虑容斥，设 $f_{i,j}$ 表示从 $(1,1)$ 向上走 $i$ 步，向右走 $j$ 步，且不能超过直线 $y=x$ 的方案数。那么总方案数就为 $C_{i+j}^i$。

对于不合法的方案数，可以仿照卡特兰数的推导方法。我们发现一条不合法的路径在翻转后向上走了 $i+1$ 步，向右走了 $j-1$ 步，那么不合法的方案数就是 $C_{i+j}^{i+1}$。

因此可以得到：

$$ans=\sum_{i=0}^{y-1}C_{x+y-i-2}^{i}\times(C_{x+y-2i-2}^{x-i-1}-C_{x+y-2i-2}^{x-i})$$

时间复杂度 $\Theta(\sqrt n)$。

Code:

```cpp
#include <cstdio>
#include <cmath>
using namespace std ;
typedef long long ll ;
const int MAXN = 2e6 + 10 , mod = 998244353 ;
ll n , fac[MAXN] , inv[MAXN] ;
ll qpow (ll x , ll p = mod - 2) {
	ll ret = 1 ;
	for (; p ; p >>= 1 , x = x * x % mod)
		if (p & 1) ret = ret * x % mod ;
	return ret ;
}
ll C (int x , int y) {
	return fac[x] * inv[y] % mod * inv[x - y] % mod ;
}
int main () {
	fac[0] = 1 ;
	for (int i = 1 ; i <= 2e6 ; i++) fac[i] = fac[i - 1] * i % mod ;
	inv[2000000] = qpow (fac[2000000]) ;
	for (int i = 2e6 - 1 ; ~i ; i--) inv[i] = inv[i + 1] * (i + 1) % mod ;
	int T ; scanf ("%d" , &T) ;
	while (T--) {
		scanf ("%lld" , &n) ;
		int x = 1 , y = 0 ; ll ans = 0 ;
		while (n > x) n -= x , x++ ;
		y = n ;
		//printf ("%d %d\n" , x , y) ;
		for (int i = 0 ; i < y ; i++) {
			int tx = x - i - 1 , ty = y - i - 1 ;
			ans = (ans + C (tx + ty + i , i) * ((C (tx + ty , tx) - C (tx + ty , tx + 1) + mod) % mod) % mod) % mod ;
		}
		printf ("%lld\n" , ans) ;
	}
	return 0 ;
}
```

---

## 作者：ncwzdlsd (赞：1)

数学。

简化问题，该问题和[经典卡特兰数应用问题](https://baike.baidu.com/item/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/6125746#5)唯一的区别就在于可以斜着走，于是考虑分情况讨论。

设 $u$ 点坐标 $(x,y)$。

考虑枚举斜着走的次数 $i$，根据卡特兰数，向下或向右的方案数即为
$$
\binom{x+y-2i-2}{x-i-1}-\binom{x+y-2i-2}{x-i}
$$
对于斜着走的情况，方案数为
$$
\binom{x+y-i-2}{i}
$$
根据乘法原理，总方案数为
$$
\sum_{i=0}^{y-1}\binom{x+y-i-2}{i}\left(\binom{x+y-2i-2}{x-i-1}-\binom{x+y-2i-2}{x-i}\right)
$$
代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

const int mod=998244353,maxn=2e6+5;
int fac[maxn],inv[maxn];

int quickpow(int a,int b)
{
	int res=1;
	while(b)
	{
		if(b&1) res=res*a%mod;
		a=a*a%mod,b>>=1;
	}
	return res;
}

int C(int n,int m){return fac[n]*inv[n-m]%mod*inv[m]%mod;}

void init()
{
    fac[0]=1;
	for(int i=1;i<=2e6;i++) fac[i]=fac[i-1]*i%mod;
	inv[2000000]=quickpow(fac[2000000],mod-2);
	for(int i=2000000-1;i>=0;--i) inv[i]=inv[i+1]*(i+1)%mod;
}

void solve()
{
	int u;cin>>u;
	int x=1,y=0;
	while(u>x) u-=x,x++;
	y=u;
	int ans=0;
	for(int i=0;i<y;++i) ans=(ans+C(x+y-i-2,i)*((C(x+y-2*i-2,x-i-1)-C(x+y-2*i-2,x-i)+mod)%mod)%mod)%mod;
	cout<<ans<<endl;
}

signed main()
{
	int T;cin>>T;
	init();
	while(T--) solve();
	return 0;
}
```

---

## 作者：_www_ (赞：1)

把网格图补全，记第 $i$ 行第 $j$ 个点（标号从 $0$ 开始）的坐标为 $(i,j)$，记最后走到 $(i,j)$ 的路径数为 $f_{i,j}$。设 $u$ 号点的坐标为 $(x,y)$，则不合法路径翻转后对应一条走到 $(y-1,x+1)$ 的路径，故答案即为为 $f_{x,y}-f_{y-1,x+1}$。

考虑如何求 $f$：
$$f_{i,j}=f_{i-1,j-1}+f_{i-1,j}+f_{i,j-1}$$
$$F_i=(1+x)F_{i-1}+xF_i$$
$$F_i=\frac{1+x}{1-x}F_{i-1},F_0=\frac{1}{1-x}$$
$$F_i=\frac{1}{1-x}\cdot(\frac{1+x}{1-x})^i$$
很经典的短多项式快速幂，记 $H=\frac{1+x}{1-x},G=(\frac{1+x}{1-x})^i$，则
$$G=H^i$$
$$G'=iH^{i-1}H'$$
$$G'H=iGH'$$
$$\frac{1+x}{1-x}G'=\frac{2i}{(1-x)^2}G$$
$$(1-x^2)G'=2iG$$
观察两边 $n$ 次项系数可得
$$(n+1)g_{n+1}-(n-1)g_{n-1}=2ig_n$$
$$g_{n+1}=\frac{2ig_n+(n-1)g_{n-1}}{n+1}$$
易知 $g_0=1,g_1=2i$，$f$ 为 $g$ 的前缀和，递推即可求出单行 $f$ 值。

时间复杂度 $\mathcal{O}(T\sqrt{u})$。

---

## 作者：Milmon (赞：1)

[Milmon Page 链接：https://molmin.github.io/problem?id=26#solution](https://molmin.github.io/problem?id=26#solution)

可以通过二分求出给定的 $u$ 所在的行。设给定点在第 $n+1$ 行的第 $m+1$ 个位置。

考虑将这个图进行一些转化，容易想到可以转化成这样一个问题：

给定 $m\times n$ 的网格，求从左下角的点走到右上角的点，每次可以向右走、向上走、向右上方走，且不超过从左下角出发的 $45^\circ$ 斜线的方法数。

这是我们比较熟悉的一个问题，但是这个问题可以向右上方走。

考虑转化成不能向右上方走的情况。不妨枚举向右上方走的次数 $i$，那么就需要向右走 $n_0=n-i$ 步，向上走 $m_0=m-i$ 步。这显然是卡特兰数，共有

$$
\binom{n_0+m_0}{m_0}-\binom{n_0+m_0}{m_0-1}
$$

种走法。而向右上方走的步骤可以插入到任意的位置，由插板法，有 $\dbinom{n+m-i}i$ 种方案。由乘法原理以及加法原理，得答案为

$$
\sum_{i=0}^m\binom{n+m-i}i\left[\binom{n+m-2i}{m-i}-\binom{n+m-2i}{m-i-1}\right].
$$

只需预处理阶乘与阶乘的逆元即可。

时间复杂度 $\Theta(\sum\sqrt n)$。

[Code 链接：https://molmin.github.io/problem?id=26#code](https://molmin.github.io/problem?id=26#code)

---

## 作者：Brodal_Queue (赞：1)

把整个图向左推平，就成了一个网格图（半角）。

设走到第 $n$ 行 $m$ 列，枚举走斜边的次数 $d$，从 $n+m-d$ 中选 $d$ 步走斜边；剩下的可以看成走到第 $n-d$ 行 $m-d$ 列，只能横竖走的方案数。

考虑计算走到 $n$ 行 $m$ 列，只能横竖走的方案数：我们知道 $n=m$ 时，就是 Catalan 数列。  
类比这个式子，稍加思索就能发现答案是

$$\binom{n+m}{n}\frac{n-m+1}{n+1}$$

所以最终答案为

$$(n-m+1)\sum_{d=0}^m\frac{(n+m-d)!}{d!(n-d)!(m-d)!(n-d+1)}$$
直接计算就能 $\Theta(m)$ 解决，可以通过本题。

注意到这个和中的每一项，关于 $d$ 都为整式递推数列，所以前缀和也是整式递推数列，套用 [这个模板](https://www.luogu.com.cn/problem/P6115) 就可以将时间复杂度优化到 $\Theta(\sqrt m \log m)$。

---

## 作者：hexz01 (赞：0)

# Catalan 数 & 题解 P5014 水の三角(修改版)

## 前置知识：Catalan 数：

### 引入

来看这张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/a3bt2tk8.png)

问：只能走灰色方格的左和下的边线，也就是说不能越过对角线，的从左上到右下的路径条数是多少？

枚举可以发现，随着上图边长的增加，路径数量是：

```
H[0]=1
H[1]=1
H[2]=2
H[3]=5
H[4]=14
H[5]=42
H[6]=132
```

我们称它为卡特兰数（Catalan）。

卡特兰数通项公式：

$$H_i=C_{2n}^{n}-C_{2n}^{n-1}$$

原理嘛，详见 bilibili 董晓算法的视频。

## 本题思路

把本题的右下向边去掉后发现就是一个 Catalan 数的三角形格子，因为每走一条斜边，Catalan 数就少一层，于是只需要枚举走的斜边的数量，然后用卡特兰数算。

长方形卡特兰数可以看其他大佬的题解。

最后就是具体要知道当前点在哪一行那一列，这个可以用等差数列求和去二分一下，就知道在哪一行了。

### code
``` cpp
#include <iostream>
using namespace std;
typedef long long ll;
const ll mod=998244353;
const int N=2e6+7;
ll jc[N], inv[N];
ll C(ll x, ll y){
	if(y==0)
		return 1;
	else
		return (jc[x]*inv[y]%mod)*inv[x-y]%mod;
}
ll ksm(ll x, ll y){
	x%=mod;
	ll ans=1;
	while(y){
		if(y&1)
			ans=ans*x%mod;
		x=x*x%mod;
		y>>=1;
	}
	return ans;
}
ll H(ll x, ll y){
	return (C(x+y, x)-C(x+y, x+1)+mod)%mod;
}
ll BS(ll x){
	ll l=1, r=2000000, min1=r+1;
	while(l<=r){
		ll mid=(l+r)>>1;
		if((mid*(mid+1)>>1)>=x){
			min1=min(min1, mid);
			r=mid-1;
		}else{
			l=mid+1;
		}
	}
	return min1;
}
int main(){
	ios::sync_with_stdio(0);
	jc[0]=1;
	for(ll i=1;i<=2000000;i++)
		jc[i]=jc[i-1]*i%mod;
	for(ll i=0;i<=2000000;i++)
		inv[i]=ksm(jc[i], mod-2);
	int T;
	cin>>T;
	while(T--){
		ll u;
		cin>>u;
		ll n=BS(u), m=n-n*(n+1)/2+u;
		ll ans=0;
		for(ll i=0;i<m;i++){//n>=m 所以i<m
			ans+=C(n-i-1+m-i-1+i, i)*H(n-i-1, m-i-1)%mod;
			if(ans>=mod)
				ans-=mod;
		}
		cout<<ans<<endl;
	}
	return 0;
}
```

---

## 作者：0x3F (赞：0)

将 $u$ 转化为坐标 $(n,m),n\ge m$。

先考虑没有三角的限制的情况，从 $(0,0)$ 到 $(i,j)$ 的方案数为 $dp_{i,j}$，则有 $dp_{0,0}=1,dp_{i,j}=dp_{i-1,j}+dp_{i,j-1}+dp_{i-1,j-1}$。

直接做是平方的，我们记

$$P_n=\sum_{i=0}^{\infty}dp_{n,i}x^i$$

则有：$P_0=\frac{1}{1-x},P_i=\frac{1}{1-x}(P_{i-1}+xP_{i-1})$，即

$$P_n=\frac{(1+x)^n}{(1-x)^{n+1}}$$

故

$$
dp_{n,m}=[x^m]\frac{(1+x)^n}{(1-x)^{n+1}}
\\
=\sum_{i=0}^{m}([x^i]\frac{1}{(1-x)^{n+1}})([x^{m-i}](1+x)^n)
\\
=\sum_{i=0}^{m}\binom{n+i}{i}\binom{n}{m-i}
$$

但是我们有三角的限制。类似于卡特兰数，对于不合法的方案，我们将第一条离开三角形的边以后的边翻折，到达点 $(m-1,n+1)$。

于是答案为 $dp_{n,m}-dp_{m-1,n+1}=dp_{n,m}-dp_{n+1,m-1}$。

时间复杂度为 $\mathcal{O}(\sum\sqrt{u})$。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod = 998244353;
inline int qpow(int a, int b) {
    int s = 1;
    while (b) {
        if (b & 1) s = (long long) s * a % mod;
        a = (long long) a * a % mod;
        (b >>= 1);
    }
    return s;
}
const int _ = 2e6 + 10;
int f[_], g[_];
inline void init(int n) {
    f[0] = 1;
    for (int i = 1; i <= n; i++) {
        f[i] = (long long) f[i-1] * i % mod;
    }
    g[n] = qpow(f[n], mod - 2);
    for (int i = n-1; i >= 0; i--) {
        g[i] = (long long) g[i+1] * (i+1) % mod;
    }
}
inline int binom(int n, int m) {
    return (long long) f[n] * g[m] % mod * g[n-m] % mod;
}
inline int F(int n, int m) {
    int ans = 0;
    for (int i = 0; i <= m; i++) {
        ans = (ans + (long long) binom(n + i, i) * binom(n, m - i)) % mod;
    }
    return ans;
}
int main() {
    init(2000000);
    int T;
    cin >> T;
    while (T--) {
        long long N;
        cin >> N;
        int L = 0, R = 1000000;
        while (L < R) {
            int M = ((L + R) >> 1);
            if ((long long) M * (M + 1) < (N << 1LL)) {
                L = M + 1;
            } else {
                R = M;
            }
        }
        int n = L;
        int m = N - (((long long) L * (L - 1)) >> 1LL);
        n--;
        m--;
        int ans = F(n, m);
        if (m) ans = (ans + mod - F(n+1, m-1)) % mod;
        cout << ans << endl;
    }
    return 0;
}
```

---

## 作者：daniEl_lElE (赞：0)

考虑没有向右下边的情况。

考虑 $u=\frac{x(x+1)}{2}$，不难发现其实就是卡特兰数。

考虑 $u\neq\frac{x(x+1)}{2}$，思考卡特兰数的证明方式，也就是在第一次出界之后的所有边全部翻转。


考虑坐标 $(i,j)$，利用同样的方法，在第一次出界之后所有边翻转，容易得到答案是 $\binom{i+j}{i}-\binom{i+j}{i+1}$。

考虑有向右下边的情况。枚举所有 $(i-k,j-k)$，计算到这个点的位置，然后将右下边插入即可。

```cpp
#include <bits/stdc++.h>
#define int long long
#define double long double
using namespace std;
const int mod=998244353;
//Combinatorics
int qp(int a,int b){
	if(b<0){
		return qp(qp(a,mod-2),-b);
	}
	int ans=1;
	while(b){
		if(b&1) (ans*=a)%=mod;
		(a*=a)%=mod;
		b>>=1;
	}
	return ans;
}
int fac[3000005],inv[3000005];
void init(){
	fac[0]=1; for(int i=1;i<=3000000;i++) fac[i]=fac[i-1]*i%mod;
	inv[3000000]=qp(fac[3000000],mod-2); for(int i=2999999;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;
}
int C(int i,int j){
	if(i<0||j<0||i<j) return 0;
	return fac[i]*inv[j]%mod*inv[i-j]%mod;
}
//Fast input/output
int read(){
	char c; int ans=0; int z=1;
	while(!isdigit(c=getchar()))z-=2*(c=='-');
	do{ans=(ans*10+c-'0');}while(isdigit(c=getchar()));
	return ans*z;
}
void print(int x){
	if(x<0) putchar('-');
	if(llabs(x)>=10) print(llabs(x)/10);
	putchar((llabs(x)%10)+'0');
}
void endl(){
	putchar(10);
}
signed main(){
	init();
	int t; cin>>t;
	while(t--){
		int n; cin>>n;
		int x,y=0;
		for(int i=1;;i++){
			if(n<=i) break;
			y++; n-=i;
		}
		x=n-1;
//		cout<<x<<" "<<y<<"\n";
		int ans=0;
		for(int l=0;l<=min(x,y);l++){
			(ans+=(C(x-l+y-l,x-l)+mod-C(x-l+y-l,x-l-1))*C(x+y-l,l))%=mod;
		}
		cout<<ans<<"\n";
	}
	return 0;
}
```

---

## 作者：MiPloRAs_3316 (赞：0)

[可能更好的食用体验](/blog/560595/solution-p5014) $|$ 
[题目传送门](/problem/p5014)

---
$\large{\textbf{\textsf{\color{RoyalBlue}{Analysis 思路}}}}$

由于蒟蒻电脑的问题，看不到题面的图，所以只能结合众大佬的题解盲猜一波。~~（居然猜对了 awa）~~

原图比较难理解，所以我就把三角图向左推，变成了下面的样子。

![](https://cdn.luogu.com.cn/upload/image_hosting/88gfocjh.png)

对于每一个点，我们可以非常轻松地算出它的位置 $(n,m)$。

观察一下，就发现这张图和[**卡特兰数**](https://oi-wiki.org/math/combinatorics/catalan/)的经典问题很像，只是每个格子中间多了一条对角线。因此，我们不妨设走 $i$ 条对角线，也就是少走 $i$ 条横线和 $i$ 条竖线。

那么，实际上要只走横线、竖线到达 $(n-i,m-i)$。

设 $n_0=n-i$，$m_0=m-i$。

这显然是运用卡特兰数的推导，得到有 $\dbinom{n_0+m_0}{n_0}-\dbinom{n_0+m_0}{n_0-1}$ 种走法。

别忘了还有走对角线的情况，使用插板法，得到有 $\dbinom{n_0+m_0+i}{i}$ 种排列方式。

最后，由**乘法原理**得到：
$$ANS=\sum\limits_{i=0}^m\binom{n_0+m_0+i}{i}\cdot \left[ \binom{n_0+m_0}{n_0}-\binom{n_0+m_0}{i} \right]$$

PS：虽然组合数有多种求法，但在本题只能使用**逆元**。~~（于是蒟蒻被迫自学）~~

---
$\large{\textbf{\textsf{\color{RoyalBlue}{Code 代码}}}}$

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int MOD=998244353;
const int maxn=2e6+10;
ll T,x,tot,n,m;
ll fac[maxn],inv[maxn];
ll qpow(ll x,ll q)
{
	ll ans=1;
	while(q)
	{
		if(q&1) ans=ans*x%MOD;
		x=x*x%MOD,x%=MOD;
		q>>=1;
	}
	return ans;
}//快速幂
void init(ll len)
{
    fac[0]=1;
    for(int i=1; i<=len; i++)
    	fac[i]=fac[i-1]*i%MOD;
    inv[len]=qpow(fac[len],MOD-2);
    for(int i=len;i;i--){
      inv[i-1]=inv[i]*(i)%MOD;
    }
}//逆元
ll C(ll n,ll m)
{
	return fac[n]*inv[m]%MOD*inv[n-m]%MOD;
}//带入逆元求组合数
ll f(ll n, ll m)
{
	ll ans=C(n,m)%MOD-C(n,m+1)%MOD;
	ans+=MOD;
	ans%=MOD;
	return ans;
}//只是为了简化计算
int main()
{
	init(2e6);
	for(cin>>T;T;T--)
	{
		scanf("%lld",&x);
		long long tmp=sqrt(2*x);
		if(x<=tmp*(tmp+1)/2) n=tmp;
		else n=++tmp;
		m=x-tmp*(tmp-1)/2;
		n--,m--;//记得要分别 -1
		tot=0;
		for(int i=0; i<=m; i++)
		{
			ll n0=n-i,m0=m-i;
			ll tmp=f(n0+m0,n0)%MOD*C(m+n-i,i)%MOD;
			tot+=tmp%MOD;
			tot%=MOD;
		}
		printf("%lld\n",tot);
	}
	return 0;
}
```

---

## 作者：Expert_Dreamer (赞：0)

这个三角图真好看。。
![](https://cdn.luogu.com.cn/upload/image_hosting/7ckekjvl.png)

可以发现，把图换成如上形式，再去掉斜边，从 $1$ 走到 $\dfrac{n(n+1)}{2}$ 的方案数为 $2\times Cat_{n-1}$，其中 $Cat_i$ 表示第 $i$ 个卡特兰数。

把结果推广至对于任意的编号，对于每一个第 $x$ 行，第 $y$ 列，有：

$$
C_{x+y-2(i-1)}^{x-i-1}-C_{x+y-2(i-1)}^{x-i}
$$

其中 $i$ 表示斜着走的次数。

对于斜着的路径，相当于从 $x+y-(i-1)+1$ 条路径中选 $i$ 条，有：

$$
C_{x+y-i-2}^{i}
$$

可以发现，最多走 $y-1$ 次斜边，所以统计求和即可：

$$
\sum\limits_{i=0}^{y-1}C_{x+y-i-2}^{i}(C_{x+y-2(i-1)}^{x-i-1}-C_{x+y-2(i-1)}^{x-i})
$$

---


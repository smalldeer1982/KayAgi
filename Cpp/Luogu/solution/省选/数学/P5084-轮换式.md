# 轮换式

## 题目描述

小奔发现，对于任意的 $n$ 个字母，他们构成的轮换式，都表示成 $n$ 个基本 
$1\sim n$ 次基本轮换式的线性和。

一元的基本轮换式：$a$；

二元：$a+b,ab$；

三元：$a+b+c,ab+ac+bc,abc$；

四元：$a+b+c+d,ab+ac+bc+ad+bd+cd,abc+abd+acd+bcd,abcd$；

………………

同样的，对于任意的 $n$ 个字母，给出他们的几个基本轮换式，都可以求出这几个字母的值。

但是小奔突然大发慈悲，他只需要你求出这些字母的 $m$ 次方和模 $10^7+29$ 的值。


## 说明/提示

本题共有 $3$ 个子任务。

Subtask 1（12 pts）：$n\le 2$；

Subtask 2（28 pts）：$n=3$；

Subtask 3（60 pts）：$n=4$。

对于所有数据，$0\le m\le 100000$。


## 样例 #1

### 输入

```
2 2
9 18```

### 输出

```
45```

# 题解

## 作者：0x3F (赞：10)

发现 $n \leqslant 4$ 。

所以分类讨论即可。

我们令 $s_i$ 等于这些字母的 $i$ 次方和。

当 $n = 1$ 时， $s_i = a_1^i$ , 即 $s_i = \begin{cases} 1&i = 0 \\ a_1 \times s_{i-1} & i > 0\end{cases}$

当 $n = 2$ 时， $s_0 = 2$ ， $s_1 = a_1$ ， $s_2 , s_3$ 等虽然都能求，但是 $s_i$ 怎么求呢？

或者说， $s_i$ 如何通过已经求出的 $s_{0,1,\dots,i-1}$ 来求呢？

这里给大家提供一个很新颖的方法：**韦达定理**。

当 $i > 1$ 时，由韦达定理我们得到：

$$\begin{cases} x^2 - a_1x + a_2 = 0\qquad(1)\\ y^2 - a_1y + a_2 = 0\qquad(2)\end{cases}$$

$(1)$ 式乘以 $x^{i-2}$ ， $(2)$ 式乘以 $y^{i-2}$ ，得到

$$\begin{cases} x^i - a_1x^{i-1} + a_2x^{i-2} = 0\\ y^i - a_1y^{i-1} + a_2y^{i-2} = 0\end{cases}$$

两式相加，得到

$$x^i + y^i - a_1(x^{i-1} + y^{i-1}) + a_2(x^{i-2} + y^{i-2}) = 0$$

即 $s_i - a_1s_{i-1} + a_2s_{i-2} = 0$ 。

所以： $s_i = \begin{cases} 2&i = 0 \\  a_1&i = 1 \\ a_1 \times s_{i-1} - a_2 \times s_{i-2}& i > 1\end{cases}$

当 $n = 3$ 时， 
$$s_0 = 3, s_1 = a_1$$

$$s_2 = x^2 + y^2 + z^2$$

$$ = (x + y + z)^2 - 2 (xy + xz + yz)$$

$$ = a_1^2 - 2a_2$$

同样使用韦达定理，得：当 $i > 2$ 时，
$$s_i = a_1 \times s_{i-1} - a_2 \times s_{i-2} + a_3 \times s_{i-3}$$

所以： $s_i = \begin{cases} 3&i = 0 \\  a_1&i = 1 \\  a_1^2 - 2a_2&i = 2 \\ a_1 \times s_{i-1} - a_2 \times s_{i-2} + a_3 \times s_{i-3}& i > 2\end{cases}$

当 $n = 4$ 时，

$$s_0 = 4, s_1 = a_1, s_2 = a_1^2 - 2a_2$$

$s_3$ 的柿子就比较难了。

首先考虑$a_1^3$ , 将其暴力展开得：
$$a_1^3 = (x + y + z + u)^3$$

$$=(x^3 + y^3 + z^3 + u^3)$$

$$ + 3 (x^2y + x^2z + x^2u + y^2x + y^2z + y^2u + z^2x + z^2y + z^2u + u^2x + u^2y + u^2z)$$

$$ + 6 (xyz + xyu + xzu + yzu)$$

尝试将第二项消掉。

我们发现， $a_1a_2=$

$$(x+y+z+u)(xy+xz+xu+yz+yu+zu)$$

$$= (x^2y + x^2z + x^2u + y^2x + y^2z + y^2u + z^2x + z^2y + z^2u + u^2x + u^2y + u^2z)$$

$$ + 3 (xyz + xyu + xzu + yzu)$$

将其乘以 $3$ ，用它减一下上式， 得到：

$$a_1^3 - 3a_1a_2 = (x^3 + y^3 + z^3 + u^3) - 3(xyz + xyu + xzu + yzu)$$

代入，移项，得

$$a_1^3 - 3a_1a_2 + 3a_3= s_3$$

再使用一次韦达定理，得：当 $i > 3$ 时，
$$s_i = a_1 \times s_{i-1} - a_2 \times s_{i-2} + a_3 \times s_{i-3} - a_4 \times s_{i-4}$$

所以： $s_i = \begin{cases} 4&i = 0 \\  a_1&i = 1 \\  a_1^2 - 2a_2&i = 2 \\  a_1^3 - 3a_1a_2 + 3a_3&i = 3 \\ a_1 \times s_{i-1} - a_2 \times s_{i-2} + a_3 \times s_{i-3} - a_4 \times s_{i-4}& i > 3\end{cases}$

不要忘了取模！！！

还有，十年 $OI$ 一场空，不开 `long long` 见祖宗！！！

另外，负数要转正！！！

不多说了，上代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const long long mod = 1e7 + 29;
int n, m, x, y, z, u;
long long arr[100010];
int main() {
	cin >> n >> m;
	arr[0] = n;
	switch (n) {
		case 1: {
			cin >> x;
			for (int i = 1; i <= m; i++) {
				arr[i] = arr[i-1] * x;
				arr[i] = (arr[i] % mod + mod) % mod;
			}
			break;
		}
		case 2: {
			cin >> x >> y;
			arr[1] = x;
			for (int i = 2; i <= m; i++) {
				arr[i] = arr[i-1] * x - arr[i-2] * y;
				arr[i] = (arr[i] % mod + mod) % mod;
			}
			break;
		}
		case 3: {
			cin >> x >> y >> z;
			arr[1] = x;
			arr[2] = x*x - 2*y;
			arr[2] = (arr[2] % mod + mod) % mod;
			for (int i = 3; i <= m; i++) {
				arr[i] = arr[i-1] * x - arr[i-2] * y + arr[i-3] * z;
				arr[i] = (arr[i] % mod + mod) % mod;
			}
			break;
		}
		case 4: {
			cin >> x >> y >> z >> u;
			arr[1] = x;
			arr[2] = x*x - 2*y;
			arr[2] = (arr[2] % mod + mod) % mod;
			arr[3] = (long long)x*x*x - 3*x*y + 3*z;
			arr[3] = (arr[3] % mod + mod) % mod;
			for (int i = 4; i <= m; i++) {
				arr[i] = arr[i-1] * x - arr[i-2] * y + arr[i-3] * z - arr[i-4] * u;
				arr[i] = (arr[i] % mod + mod) % mod;
			}
			break;
		}
	}
	cout << arr[m] << endl;
	return 0;
}
```

看在我打 $\LaTeX$ 这么辛苦的份上，点个赞再走吧！

---

## 作者：NaCly_Fish (赞：5)

来一篇生成函数大力推式子的题解。  
（补充了更优的做法）

设 
$$A(x)=1+\sum_{i=1}^na_ix^i$$
根据轮换式的性质，显然有
$$\prod_{i=1}^n(1+b_ix)=A(x)$$
对两边取 $\ln$，再求导

$$\sum_{i=1}^n \frac{b_i}{1+b_ix} = \frac{A'(x)}{A(x)}$$
（ $b_i$ 为第 $i$ 个字母的值 ）  

将左边展开
$$\sum_{i=1}^n\sum_{j=0}^\infty(-1)^jb_i^{j+1}x^j = \frac{A'(x)}{A(x)}$$
$$\sum_{j=0}^\infty (-1)^j\left( \sum_{i=1}^nb_i^{j+1}\right)x^j = \frac{A'(x)}{A(x)}$$
那么问题转化为了求
$$(-1)^{m-1}[x^{m-1}]\frac{A'(x)}{A(x)}$$
$A(x)$ 为 $n$ 次多项式，暴力求逆到 $m-1$ 次即可，时间复杂度 $\Theta(nm)$，可以通过本题。

不过还可以继续优化，设

$$F(x)=\frac{A'(x)}{A(x)}$$
$$F(x)A(x)=A'(x)$$
提取系数有
$$\sum_{k=0}^mf_{m-k}a_{k}=(m+1)a_{m+1}$$
$$f_m=(m+1)a_{m+1}-\sum_{k=1}^mf_{m-k}a_k$$
这里定义 $a_0=1$，大于 $n$ 的项为 $0$。  
那么容易发现 $f_m$ 在 $m \geq n$ 时，式子可以写成

$$f_m=\sum_{k=1}^nf_{m-k}(-a_k)$$
显然的线性递推形式，FFT 优化多项式取模就可以做到 $\Theta(n \log n \log m)$。

决定还是贴个代码（答案模 998244353 ）

```cpp
#pragma GCC optimize (2)
#pragma GCC optimize ("unroll-loops")
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#define N 131077
#define ll long long
#define reg register
#define p 998244353
using namespace std;

inline int dec(const int& x,const int& y){ return x<y?x-y+p:x-y; }

inline void read(int &x){
    x = 0;
    char c = getchar();
    while(c<'0'||c>'9') c = getchar();
    while(c>='0'&&c<='9'){
        x = (x<<3)+(x<<1)+(c^48);
        c = getchar();
    }
}

inline int power(int a,int t){
    int res = 1;
    while(t){
        if(t&1) res = (ll)res*a%p;
        a = (ll)a*a%p;
        t >>= 1;
    }
    return res;
}

int rt[N],rev[N];
int siz;

inline int getlen(int n){
    return 1<<(32-__builtin_clz(n));
}

void init(int n){
    int w,lim = 1;
    while(lim<=(n<<1)) lim <<= 1,++siz;
    for(reg int i=1;i!=lim;++i) rev[i] = (rev[i>>1]>>1)|((i&1)<<(siz-1));
    w = power(3,(p-1)>>siz);
    rt[lim>>1] = 1;
    for(reg int i=(lim>>1)+1;i!=lim;++i) rt[i] = (ll)rt[i-1]*w%p;
    for(reg int i=(lim>>1)-1;i;--i) rt[i] = rt[i<<1];
}

inline void dft(int *f,int lim){
    static unsigned long long a[N];
    reg int x,shift = siz-__builtin_ctz(lim);
    for(reg int i=0;i!=lim;++i) a[rev[i]>>shift] = f[i];
    for(reg int mid=1;mid!=lim;mid<<=1)
    for(reg int j=0;j!=lim;j+=(mid<<1))
    for(reg int k=0;k!=mid;++k){
        x = a[j|k|mid]*rt[mid|k]%p;
        a[j|k|mid] = a[j|k]+p-x;
        a[j|k] += x;
    }
    for(reg int i=0;i!=lim;++i) f[i] = a[i]%p;
}

inline void idft(int *f,int lim){
    reverse(f+1,f+lim);
    dft(f,lim);
    int x = p-((p-1)>>__builtin_ctz(lim));
    for(reg int i=0;i!=lim;++i) f[i] = (ll)f[i]*x%p;
}

inline void inverse(const int *f,int n,int *r){
    static int g[N],h[N],st[30];
    memset(g,0,getlen(n<<1)<<2);
    int lim = 1,top = 0;
    while(n){
        st[++top] = n;
        n >>= 1;
    }
    g[0] = 1;
    while(top--){
        n = st[top+1];
        while(lim<=(n<<1)) lim <<= 1;
        memcpy(h,f,(n+1)<<2);
        memset(h+n+1,0,(lim-n)<<2);
        dft(g,lim),dft(h,lim);
        for(reg int i=0;i!=lim;++i) g[i] = (2-(ll)g[i]*h[i]%p+p)*g[i]%p;
        idft(g,lim);
        memset(g+n+1,0,(lim-n)<<2);
    }
    memcpy(r,g,(n+1)<<2);
}

inline void multiply(const int *f,const int *g,int n,int m,int *R,int len){
    static int A[N],B[N];
    int lim = getlen(n+m);
    memcpy(A,f,(n+1)<<2),memcpy(B,g,(m+1)<<2);
    memset(A+n+1,0,(lim-n)<<2),memset(B+m+1,0,(lim-m)<<2);
    dft(A,lim),dft(B,lim);
    for(reg int i=0;i!=lim;++i) A[i] = (ll)A[i]*B[i]%p;
    idft(A,lim);
    memcpy(R,A,(len+1)<<2);
}

inline void mod(const int *f,const int *g,const int *ig,int n,int m,int *r){
    if(n<m) return;
    static int A[N];
    memcpy(A,f,(n+1)<<2),reverse(A,A+n+1);
    multiply(A,ig,n-m,n-m,A,n-m);
    reverse(A,A+n-m+1);
    multiply(A,g,n-m,m,A,m-1);
    for(reg int i=0;i!=m;++i) r[i] = dec(f[i],A[i]);
}

void mod_power(const int *G,int t,int k,int *r){
    static int f[N],g[N],iG[N];
    memset(f,0,sizeof(f));
    memset(g,0,sizeof(g));
    memset(iG,0,sizeof(iG));
    int n = 0,m = 1;
    f[1] = g[0] = 1;
    memcpy(iG,G,(k+1)<<2);
    reverse(iG,iG+k+1);
    inverse(iG,k,iG);
    while(1){
        if(t&1){
            multiply(g,f,n,m,g,n+m);
            mod(g,G,iG,n+m,k,g);
            n = min(n+m,k-1);
        }
        t >>= 1;
        if(t==0) break;
        int lim = getlen(m<<1);
        memset(f+m+1,0,(lim-m)<<2);
        dft(f,lim);
        for(reg int i=0;i!=lim;++i) f[i] = (ll)f[i]*f[i]%p;
        idft(f,lim);
        mod(f,G,iG,m<<1,k,f);
        m = min(m<<1,k-1);
    }
    memcpy(r,g,k<<2);
}

int n,m,ans;
int a[N],b[N],g[N],f[N];

int main(){
    read(n),read(m);
    init(n<<1);
    for(reg int i=1;i<=n;++i) read(a[i]);
    a[0] = 1;
    memcpy(g,a,(n+1)<<2);
    reverse(g,g+n+1),inverse(a,n,b);
    for(reg int i=0;i<=n;++i) a[i] = (ll)a[i+1]*(i+1)%p;
    int lim = getlen(n<<1);
    dft(a,lim),dft(b,lim);
    for(reg int i=0;i!=lim;++i) a[i] = (ll)a[i]*b[i]%p;
    idft(a,lim);
    mod_power(g,m-1,n,f);
    for(reg int i=0;i!=n;++i) ans = (ans+(ll)a[i]*f[i])%p;
    ans = (m&1)?ans:p-ans;
    printf("%d",ans);
    return 0;   
}
```

---

## 作者：HohleFeuerwerke (赞：3)

#### 前言

我去问毒瘤@[Fee_cle6418](https://www.luogu.com.cn/user/42156) 要一个SBT（指傻*题），然后他给我了一个普通平衡树……

我解释清楚以后他才把[这个题](https://www.luogu.com.cn/problem/P5084)给我了，然后我口胡做法以后就被他假了，写篇题解纪念一下。

---

#### 正文

题面给的很清楚，不多赘述了。直接看做法。

二元：

得到的条件是 $a+b=x_1$，$ab=x_2$，那么 
$$(a+b)^2=a^2+b^2+2ab=x_1^2$$

显然我们能够推得

$$a^2+b^2=x_1^2-2x_2$$

带入计算即可。

---

三元：

$a+b+c=x_1$，$ab+bc+ca=x_2$，$abc=x_3$，

那么根据欧拉公式，
$$a^3+b^3+c^3-3abc=(a+b+c)(a^2+b^2+c^2-ab-bc-ca)=x_1\cdot (a^2+b^2+c^2-x_2)$$
显然我们只需要求出 $a^2+b^2+c^2$ 的值就行了。

然后我们算 

$$(a+b+c)^2=a^2+b^2+c^2+2ab+2bc+2ca$$
拿着这个等式能够直接快速的求出 $a^2+b^2+c^2$。

$$a^2+b^2+c^2=x_1^2-2x_2$$

然后直接带回去，得到：

$$a^3+b^3+c^3-3x_3=x_1\cdot(x_1^2-2x_2-x_2)=x_1^3-3x_1x_2$$

随手一回代，得到

$$a^3+b^3+c^3=3x_3+x_1^3-3x_1x_2$$

---

四元 (Siyuan)：

$a+b+c+d=x_1$，$ab+bc+cd+da=x_2$，$abc+bcd+cda+dab=x_3$，$abcd=x_4$。

这个时候没有公式可以凭借，只能够硬来，先算两次方：

$(a+b+c+d)^2=a^2+b^2+c^2+d^2+2ab+2bc+2cd+2da$

然后得到 $a^2+b^2+c^2+d^2=x_1^2-2x_2$。

然后是：

$$(a+b+c+d)^3=\sum_{cyc} a^3+\sum_{cyc} 3a^2b+\sum_{cyc} 3ab^2+\sum_{cyc} 6abc$$

显然中间两项可以合并：

$$(a+b+c+d)^3=\sum_{cyc} a^3+\sum_{cyc} 3ab(a+b)+\sum_{cyc} 6abc$$

然后这个式子就能化了：

$$x_1^3=\sum_{cyc} a^3+3x_1x_2+6x_3$$

所以 $\sum_{cyc} a^3=x_1^3-3x_1x_2-6x_3$。

然后 $(a+b+c+d)^4=\sum a^4+\sum_{cyc}4 a^3b+\sum_{cyc} 6a^2b^2+\sum_{cyc}12a^2$

这个其实不推也可。

---

显然其实是有规律的。我们就拿

[T54037 最开始](https://www.luogu.com.cn/problem/T54037)。

显然发现，上面那个题就是这个题的特殊情况，根据Fee自己的话说：

>确实就是 $n=2$ 的。

然后，我们发现那个题可以直接递推解决。考虑在这里一样递推解决。

---

首先考虑 $n=2$ 的递推式：

$a^2+b^2$ 和 $a+b$ 已经求出来了。然后我们看 $a^m+b^m$。

显然，由于 $(a^{\frac{m}{2}}+b^{\frac{m}{2}})^2=a^m+b^m+2a^{\frac{m}{2}}\cdot b^{\frac{m}{2}}$，我们显然又知道 $ab$，直接用类ksm即可。

---

$n=3$ 的递推式：

上面那个看起来舒服，但是反着的，不是很舒服，这次给一个正着推式子的。

$$(a^m+b^m+c^m)^2=a^{2m}+b^{2m}+c^{2m}+2ab^m+2bc^m+2ca^m$$

后面看起来不太舒服，把公因式提出来：

$$(a^m+b^m+c^m)^2=a^{2m}+b^{2m}+2^{2m}+2[(ab)^m+(bc)^m+(ca)^m]$$

然后你要有足够的勇气，尝试一下把后面的 $(ab)^m+(bc)^m+(ca)^m$ 写出来。你写啊写啊写，写不出来，于是开始高兴的玩起了小恐龙。

然后你会惊喜的发现其实这个一元三次方程是可解的。

~~草讲了这么就你tm才讲到能解啊，，~~

由于 $\begin{cases}a+b+c=x_1\\ab+bc+ca=x_2\\abc=x_3 \end{cases}$

我们能够得出 $a,b,c$ 分别是 $x^3-x_1x^2+x_2x+x_3=0$ 的三根，然后拿盛金公式来做，$\Theta(1)$ 出解，然后ksm。

---

最后是 $n=4$。这个就老老实实推式子吧，我也找不到什么好的歪门邪道的方法了，反正数据小，能做就是了（

复杂度显然 $\Theta(m)$。

我们推式子啊推啊推。我们想到用 $n=2$ 的方法来做这个题。

一样的先把条件写出来：

$x_1=a+b+c+d,x_2=ab+bc+cd+da,x_3=abc+bcd+cda+dab,x_4=abcd$

我们尝试推一下答案。为了向出题人致敬，用Fee来记录答案。

$\text{Fee}_0=a^0+b^0+c^0+d^0=4$

$\text{Fee}_1=a+b+c+d=x_1$

$\text{Fee}_2=a^2+b^2+c^2+d^2=x_2^2-2x_1$

$\text{Fee}_3=a^3+b^3+c^3+d^3=x_1\cdot (\text{Fee}_2-x_2)+3x_3$（~~这个式子是我瞎yy出来的，显然就是一个用两次多项式乘上一次多项式的乘法，可能有问题~~）

显然到这里已经有一点递推关系出来了。既然是递推，考虑数学归纳法。

上手考虑 $\text{Fee}_i$ 从 $i-1$ 递推过来，只可能是乘上 $x_1$，我们就让他乘 $x_1$。然后是 $i-2$，乘上 $x_2$，$i-a$ 就是乘 $x_a$，好像这个式子能够推广到 $n\leq 100$，复杂度是 $\Theta(mn)$。~~如果按照 Fee 的说法还能够分治FTT~~。经过一番yy我们得到应该是一加一减的，这样正好能凑成功。

$\text{Fee}_i=x_1\cdot \text{Fee}_{i-1}-x_2\cdot \text{Fee}_{i-2}+x_3\cdot \text{Fee}_{i-3}-x_4\cdot \text{Fee}_{i-4}$

然后拿这个式子去推就行了，复杂度 $\Theta(m)$。当然这个做法也适用于 $n=2,3$。

代码就不贴了，免得到时候丢人。







---

## 作者：maka_baka (赞：2)

## 题干复述
给出 $n$ 元 $1\sim n$ 次基本对称式的值，求这 $n$ 个变量 $m$ 次和模 $P=10^7+29$ 的值。
> $n\in\{1,2,3,4\}$，$m\in\mathbb N\land m\le10^5$。

$n$ 元 $k(\le n)$ 次基本对称式指：
$$\sum_\binom nkx_{i1}x_{i2}\cdots x_{ik}$$
作为例子，设四个变量为 $x,y,z,u$，$4$ 元 $2$ 次基本对称式为
$$\sum_6xy=xy+xz+xu+yz+yu+zu$$
另一个常见的地方是韦达定理。下面这个多项式：
$$(x-x_1)(x-x_2)\cdots(x-x_n)$$
展开后 $n-k$ 次的系数（忽略 $\pm1$ 的系数）正是 $n$ 元 $k(\le n)$ 次基本对称式

## 做法
本文中所有求和号均表示对称求和 $\sum_\mathrm{syn}$，为了减少错误率，在求和和号下标数字表示展开后的系数和，也就是所有变量都取 $1$ 时的值。

本文的所有结论都可以用乘法分配律直接证明，所以我详细讲探索的过程。

设输入中 $n$ 元 $i$ 次基本对称式的值为 $a_i(1\le i\le n)$，$j$ 次方和为 $f_j$。尝试建立递推关系。可以发现，$f_0=n$ 和 $f_1=a_1$。

### $n=1$
$f_i=x^i=a_1^i$。为了形式上的统一，我写成 $f_{k+1}=a_1f_k$。

### $n=2$
中考数学。通过这种方法升幂：
$$a_1f_k=(x+y)(x^k+y^k)=x^{k+1}+y^{k+1}+xy(x^{k-1}+y^{k-1})=f_{k+1}+a_2f_{k-1}$$
$$f_{k+1}=a_1f_k-a_2f_{k-1}$$
以前数学老师讲过一种可以把时间降为 $O(\log n)$ 的方法：用分治，通过 $f_k$ 转移到 $f_{2k}$ 和 $f_{2k+1}$。这种方法和矩阵快速幂是一个道理。

### $n=3$
尝试用一个 $j$ 次式和 $(k+1-j)$ 次式相乘来得出 $(k+1)$ 次，$j=\lfloor n/2\rfloor$ 就是上文的分治。为了方便，我令 $j=1$，$1$ 次对称式是唯一的，$k$ 次的我取 $f_k$：
$$\begin{align}
a_1f_k & = (x+y+z)(x^k+y^k+z^k)\\
&=x^{k+1}+y^{k+1}+z^{k+1}+\sum_6xy^k\\
&=f_{k+1}+\sum_6xy^k
\end{align}$$
你会发现末尾多了个很难看的求和。我们再取 $j=2$，两个对称式为 $a_2$ 和 $f_{k-1}$：
$$\begin{align}
a_2f_{k-1}&=(xy+xz+yz)(x^{k-1}+y^{k-1}+z^{k-1})\\
&=\sum_6xy^k+xyz(x^{k-2}+y^{k-2}+z^{k-2})\\
&=\sum_6xy^k+a_3f_{k-2}
\end{align}$$
把两式相加：
$$\begin{align}
a_1f_k & =f_{k+1}{\color{Violet}+\sum_6xy^k}\\
{\color{Violet}\sum_6xy^k+}a_3f_{k-2}&=a_2f_{k-1}\\
a_1f_k+a_3f_{k-2}&=f_{k+1}+a_2f_{k-1}
\end{align}$$
$$f_{k+1}=a_1f_k-a_2f_{k-1}+a_3f_{k-2},\quad k\ge2$$
边界：
$$\begin{align}
a_1^2&=(x+y+z)^2\\
&=x^2+y^2+z^2+2\sum_3xy\\
&=f_2+2a_1
\end{align}$$
你会发现这个等式和 $n=2$ 的情形完全一样：
$$f_2=a_1^2-2a_2=a_1f_1-a_2f_0$$
**注意：** 这里 $f_0=2$。

### $n=4$
同样地操作：
$$\begin{align}
a_1f_k&=(x+y+z+u)\left(\sum_4x^k\right)\\
&=\sum_4x^{k+1}+\sum_{12}xy^k\\
&=f_{k+1}+\sum_{12}xy^k
\end{align}$$
$$\begin{align}
a_2f_{k-1}&=\left(\sum_{6}xy\right)\left(\sum_4x^{k-1}\right)\\
&=\sum_{12}xy^k+\sum_{12}xyz^{k-1}
\end{align}$$
$$\begin{align}
a_3f_{k-2}&=\left(\sum_{4}xyz\right)\left(\sum_4x^{k-2}\right)\\
&=\sum_{12}xyz^{k-1}+xyzu\left(\sum_4x^{k-3}\right)\\
&=\sum_{12}xyz^{k-1}+a_4f_{k-3}
\end{align}$$
三式相加
$$\begin{align}
a_1f_k&=f_{k+1}{\color{Violet}+\sum_{12}xy^k}\\
{\color{Violet}\sum_{12}xy^k+}{\color{Tan}\sum_{12}xyz^{k-1}}&=a_2f_{k-1}\\
a_3f_{k-2}&={\color{Tan}\sum_{12}xyz^{k-1}}+a_4f_{k-3}\\
a_1f_k+a_3f_{k-2}&=f_{k+1}+a_2f_{k-1}+a_4f_{k-3}
\end{align}$$
$$f_{k+1}=a_1f_k-a_2f_{k-1}+a_3f_{k-2}-a_4f_{k-3}$$
在 $n=3$ 的边界里我们发现了一个“巧合”。现在我们验证它在 $n=4$ 时是否成立。
$$\begin{align}
a_1^2-2a_2&=(x+y+z+w)^2-2\left(\sum_{6}xy\right)\\
&=x^2+y^2+z^2+w^2=f_2
\end{align}$$
Amazing！非常完美地取等了。$n=3$ 中
$$f_3 = a_1f_2-a_2f_1+a_3f_0= a_1f_2-a_1a_2+3a_3$$
**注意：** 这里 $f_0=3$。

用乘法分配率可以证明 $n=4$ 时这个等式也成立（不想打 latex 了）。

至此，所有情况的递推式、边界条件已推导完毕。直接模拟转移 $O(nm)$，矩阵快速幂 $O(n^3\log m)$，当然这道题用不到。

## Code
```cpp
#include <iostream>
using ll = long long;
const int N = 7, M = 1e5+5;
const ll P = 1e7+29;

int n, m;
ll a[N], f[M];

int main() {
  std::cin >> n >> m;
  for (int i=1; i<=n; i++) std::cin >> a[i];

  int i=2; f[0] = n, f[1] = a[1];
  // f2 = a1^2 - 2a2
  if (n>=3) f[2] = (a[1] * a[1] % P + P - 2 * a[2] % P) % P, i++;
  // f3 = a1f2 - a1a2 + 3a3
  if (n>=4) f[3] = (a[1] * f[2] % P + P - a[1] * a[2] % P + 3 * a[3] % P) % P, i++;

  while (i <= m) {
    for (int j=1, w=1; j<=n; j++, w=-w)
      f[i] = (f[i] + P + a[j] * f[i-j] % P * w) % P;
    i++;
  }

  std::cout << f[m] << '\n';
}
```

## 后记
$n=3$ 时让 $k=2$：
$$f_3=a_1f_2-a_2f_1+a_3f_0$$
由于 $f_0=3$，$f_1=a_1$ 移项，合并同类项：
$$f_3-3a_3=a_1(f_2-a_2)$$
于是得到了这个经典的公式：
$$x^3+y^3+z^3-3xyz=(x+y+z)(x^2+y^2+z^2-xy-xz-yz)$$

---

## 作者：Kevin0007 (赞：2)

感谢红名大佬 [IvanZhang2009](https://www.luogu.com.cn/user/447479) 的帮助，本解法的思路由我想出，但没有他的找错（很多错），我这道题根本过不了。

分析：

首先我们要知道三个公式（牛顿二、三、四阶递推公式）：
$$a^x+b^x=(a+b)(a^{x-1}+b^{x-1})-ab(a^{x-2}+b^{x-2})$$

$$a^x+b^x+c^x=(a+b+c)(a^{x-1}+b^{x-1}+c^{x-1})-(ab+bc+ca)(a^{x-2}+b^{x-2}+c^{x-2})+abc(a^{x-3}+b^{x-3}+c^{x-3})$$

$$a^x+b^x+c^x+d^x=(a+b+c+d)(a^{x-1}+b^{x-1}+c^{x-1}+d^{x-1})-(ab+bc+cd+ac+bd+ad)(a^{x-2}+b^{x-2}+c^{x-2}+d^{x-2})+(abc+abd+acd+bcd)(a^{x-3}+b^{x-3}+c^{x-3}+d^{x-3})-abcd(a^{x-4}+b^{x-4}+c^{x-4}+d^{x-4})$$

那么直接递推即可。

当然，知道了递推公式，要求数列的每一项，我们还是要将前几项罗列出来的。

当 $n=2$ 时，设 $f[x]=a^x+b^x$，$a+b=x$，$ab=y$。

则显然 $f[0]=2$，$f[1]=a+b=x$。

当 $n=3$ 时，设 $f[x]=a^x+b^x+c^x$，$a+b+c=x$，$ab+bc+ca=y$，$abc=z$。

则显然 $f[0]=3$，$f[1]=a+b+c=x$，

而 $f[2]=a^2+b^2+c^2=(a+b+c)^2-2(ab+bc+ca)=x^2-2y$。

当 $n=4$时，设 $f[x]=a^x+b^x+c^x+d^x$，$a+b+c+d=x$，$ab+bc+cd+ac+bd+ad=y$，$abc+abd+acd+bcd=z$，$abcd=t$。

则显然 $f[0]=4$，$f[1]=a+b+c+d=x$，

而 $f[2]=x^2-2y$，

$f[3]=x^3-3xy+3z$。

那么有了前几项，有了递推公式，就大功告成啦！

什么？你说 $n=1$ 时怎么办？暴力乘呗!

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod=10000029;
long long f[100005],n,m,x1,x2,x3,x4; 
int main(){
	cin>>n>>m;
	if(n==1){
		int x;
		cin>>x;
		long long p=1;
		while(m--)p=p*x%mod;
		cout<<p<<endl;
	}
	if(n==2){
		cin>>x1>>x2;
		f[0]=2;f[1]=x1;
		for(int i=2;i<=m;i++) f[i]=(x1*f[i-1]-f[i-2]*x2+1ll*mod)%mod;
		cout<<(f[m]+1ll*mod)%mod<<endl;
	}
	if(n==3){
		cin>>x1>>x2>>x3;
		f[0]=3;f[1]=x1;f[2]=x1*x1-2*x2;
		for(int i=3;i<=m;i++) f[i]=(x1*f[i-1]-x2*f[i-2]+x3*f[i-3]+1ll*mod)%mod;
		cout<<(f[m]+1ll*mod)%mod<<endl;
	}
	if(n==4){
		cin>>x1>>x2>>x3>>x4;
		f[0]=4;f[1]=x1;f[2]=x1*x1-2*x2;f[3]=x1*x1*x1-3*x1*x2+3*x3;
		for(int i=4;i<=m;i++) f[i]=(x1*f[i-1]-x2*f[i-2]+x3*f[i-3]-x4*f[i-4]+1ll*mod)%mod;
		cout<<(f[m]+1ll*mod)%mod<<endl;
	}
	return 0;
}
```

特别注意：

一：手动算的数据千万不能错！（由大佬 IvanZhang2009 纠正）

二：负数取余会出问题，所以要先加一个 $mod$ 的倍数再取余。（由大佬 IvanZhang2009 纠正）

三：记得 $n=1$ 时的情况。（由大佬 IvanZhang2009 纠正）

---

## 作者：ShineEternal (赞：1)

这道题真的不难吧。

如$@AKEE$ 大佬所说，此题的确可以将n推广到一般情况。

但题面还是良心的只到了$N<=4$

以目前的题目来看，简单模拟即可。

分别弄$N=1,2,3,4$的情况判断就行。

下面奉上std
# 代码：
```cpp
#include<bits/stdc++.h>
#define L 1000001
using namespace std;
long long int a[100001],b,c,d,e,x=0,xx=2;
long long int mo=10000029;
int main() {
    int n,t,N;
    cin>>N;
    if(N==1) {
        cin>>n>>b;
        a[0]=1;
        for(int i=1; i<=n; i++) {
            a[i]=a[i-1]*b%mo;
        }
        if(a[n]>=0)cout<<a[n];
        else cout<<a[n]+mo;
        return 0;
    }
    if(N==2) {
        cin>>n>>b>>c;
        a[1]=b;
        a[2]=a[1]*a[1]-c*xx;
        a[2]%=mo;
        if(a[n]!=x) {
            cout<<a[n]<<endl;
        }
        for(int j=3; j<=n; j++) {
            if(a[j]!=x)continue;
            a[j]=a[j-1]*b-a[j-2]*c;
            a[j]%=mo;
        }
        if(a[n]>=0)cout<<a[n];
        else cout<<a[n]+mo;
        return 0;
    }
    if(N==3) {
        cin>>n>>b>>c>>d;
        a[0]=3;
        a[1]=b;
        a[2]=b*b-2*c;
        a[2]%=mo;
        for(int i=3; i<=n; i++) {
            a[i]=b*a[i-1]-c*a[i-2]+d*a[i-3];
            a[i]%=mo;
        }
        if(a[n]>=0)cout<<a[n];
        else cout<<a[n]+mo;
        return 0;
    }
    if(N==4) {
        cin>>n>>b>>c>>d>>e;
        a[0]=4;
        a[1]=b;
        a[2]=b*b-2*c;
        a[2]%=mo;
        a[3]=b*(a[2]-c)+3*d;
        a[3]%=mo;
        for(int i=4; i<=n; i++) {
            a[i]=b*a[i-1]-c*a[i-2]+d*a[i-3]-e*a[i-4];
            a[i]%=mo;
        }
        if(a[n]>=0)cout<<a[n];
        else cout<<a[n]+mo;
        return 0;
    }
    return 0;
}
```

---

## 作者：Kazeno_Akina (赞：0)

模拟赛同学搬的非常好题目，感觉可以写一发题解。

注意到 $n \le 4$，$m$ 也不算大（和加强版相比），那么考虑对着 $m$ 递推。

不妨设 $S_{n,k}$ 是共有 $n$ 个字母，求 $k$ 次方的和的结果。那么首先注意到，对于任意的 $n$，有：

+ $S_{n,0} = n$

+ $S_{n,1} = a_{1}$

+ $S_{n,2} = S_{n,1}^{2} - 2 \times a_{2}$

这三点都是证明的。那么考虑对 $k$ 推广。于是有：（为了方便，下文将 $n$ 个字母代表的值设为 $x_{1} \sim x_{n}$）

$\begin{aligned}
S_{n,k} &= \sum_{i=1}^{n} x_{i}^{k} \\
 &= a_{1} \cdot S_{n,k-1} - \sum_{1 \le i,j \le n,i \ne j} x_{i} x_{j}^{k-1} \\
\end{aligned}$

那么容易想到可以对后面的部分也进行类似的展开过程，最终得到：（以下对于下标大于 $n$ 的 $a_{k}$ 默认为 $0$）

$\begin{aligned}
S_{n,k} &= a_{1} \cdot S_{n,k-1} - a_{2} \cdot S_{n,k-2} + a_{3} \cdot S_{n,k-3} - \cdots + (-1)^{k} \cdot a_{k-1} \cdot S_{n,1} + (-1)^{k+1} \cdot k a_{k} \\
&= \sum_{i=1}^{k-1} a_{i} \cdot S_{n,k-i} + k a_{k}\\
\end{aligned}$

从而你可以轻松求得 $S_{n,m}$，只需递推即可。复杂度为 $O(nm)$。

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+5,P=1e7+29;
int n,m;
long long a[N],s[N];
inline int qp(long long a,int b,int p){
    long long res(1);
    for(a%=p;b;a=a*a%p,b>>=1) if(b&1) res=res*a%p;
    return res;
}
inline int qp_1(int b){return(b&1)?(-1):(1);}//对-1求幂的方便写法，降低您的复杂度
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin >> n >> m;
    for(int i(1);i<=n;++i) cin >> a[i];
    if(n==1){cout << qp(a[1],m,P);return 0;}
    s[0]=n,s[1]=a[1];
    for(int i(2);i<=m;++i){
        for(int j(1);j<min(i,n+1);++j) s[i]+=(a[j]*s[i-j]%P)*qp_1(j-1),s[i]+=P,s[i]%=P;
        s[i]+=(a[i]*i%P)*qp_1(i-1),s[i]+=P,s[i]%=P;
    }
    cout << s[m];
    return 0;
}
```

---


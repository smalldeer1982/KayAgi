# 数学

## 题目背景

在```小奔```这片神奇的土地上，有一个毒瘤教练```小奔```。

题解：https://blog.csdn.net/kkkksc03/article/details/84928333

## 题目描述

小奔热衷于乘法，他最喜欢做的事情是：从一个有 $N$ 个元素的序列里取出 $K$ 个数，（注意：不能取同一个元素好几次，取不同但是值相同的元素则是允许的）
然后算出这$K$个数的积作为这个组合的分数。

小奔想试遍所有的这些组合，然后算出所有这些组合的分数之和。但是他还要
出模拟赛虐爆我们这些蒟蒻，所以他只好把这个任务交给了你。

小奔（~~在某些方面~~）还是很仁慈的，所以你不用写高精度，只要输出答案取模 $10^9+7$ 的结果就可以了。

## 说明/提示

#### 样例#2解释：

```小奔```可以取```{A[1],A[2],A[3]},{A[1],A[2],A[4]},{A[1],A[3],A[4]},{A[2],A[3],A[4]}```四种组合，它们的分值分别是 $1,2,2,2$。加起来就是 $7$。

#### 数据范围：

对于 $10\%$ 的数据，$N\le 5000,K\le 2$；

对于 $30\%$ 的数据，$N\le 10^5,K\le 3$；

对于 $50\%$ 的数据，$N\le 10^5,K\le 5$；

对于 $100\%$ 的数据，$1\le N\le 10^5,1\le K \le 300 \& \& K\le N,1\le A[i]\le 10^8$。

## 样例 #1

### 输入

```
3 3
1 1 1```

### 输出

```
1```

## 样例 #2

### 输入

```
4 3
1 1 1 2```

### 输出

```
7```

# 题解

## 作者：sel_fish (赞：58)

# ~~好一道水的DP~~
## 很显然这就是一道01背包求方案数（假当就是这样好了）~~反正差不多~~
我们**设一个数组f[x][y]来表示前x个物品选y个的值**，因为每一个只能选一次，所以，是一个**01背包**

我们可以得到下面的动态转移方程
```cpp
f[i][j]=(f[i-1][j]+f[i-1][j-1]*a[i])%mod;
```
然而空间给你炸爆，所以我们有两种选择

1. 滚动数组
2. 直接压缩掉一维~~降维攻击~~

于是我愉快的选择了第二种

**AC代码（01背包板子）**

```cpp
#include<bits/stdc++.h>
using namespace std;
long long f[100010],a[100010],n,k;
int main() {
	cin>>n>>k;
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	f[0]=1;//这一点很重要，不要忘了
	for(int i=1;i<=n;i++) {
		for(int j=k;j>=0;j--) {
			f[j]=(f[j]+f[j-1]*a[i])%1000000007;
		}
	}
	cout<<f[k];
	return 0;
}
```
如果各位感觉给你了一些帮助，~~能否给我一个赞呢~~

**END**

---

## 作者：Karry5307 (赞：8)

### 题意

给定一个长度为 $n$ 的序列 $a_i$，求出在这个序列中所有选出 $k$ 个元素方案中元素的乘积之和。

$\texttt{Data Range:}1\leq n\leq 10^5,1\leq k\leq 300$

### 题解

[不一定更好的阅读体验](https://www.cnblogs.com/Karry5307/p/13884474.html)

多项式乘法。

很明显答案为

$$[x^k]\prod\limits_{i=1}^{n}(1+a_ix)$$

来考虑一下证明。

这些多项式乘积中 $x^k$ 的系数相当于在 $n$ 个多项式任意选出 $k$ 个多项式，其中被选出来的的取一次项，剩下的取常数项，将这些东西乘起来的和。这个东西很明显是跟题目等价的。

同时注意到每个多项式是一次多项式所以可以 $O(n)$ 乘起来，总复杂度 $O(nk)$。

考虑一个加强版，其中 $1\leq n\leq 5\times 10^5,1\leq k\leq 5\times10^5$ 并且对 $998244353$ 取模，这个时候剩下题解中的 DP 就基本上不能用了，而如果以多项式乘法的角度去思考的话发现这个东西可以分治 NTT，然后 $O(n\log^2n)$ 就做完了。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef int ll;
typedef long long int li;
const ll MAXN=2e5+51,MOD=1e9+7;
ll n,kk,c,x;
ll f[MAXN];
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
    	neg=-1;
    	ch=getchar();
	}
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
}
int main()
{
	n=read(),kk=read(),f[0]=1;
	for(register int i=1;i<=n;i++)
	{
		x=read();
		for(register int j=c;j>=0;j--)
		{
			f[j+1]=(f[j+1]+(li)f[j]*x%MOD)%MOD;
		}
		c=c==kk?kk:c+1;
	}
	printf("%d\n",f[kk]);
}
```

---

## 作者：Fading (赞：5)

这是一个比较水的$DP,$~~也就被czx1min秒掉了~~

其实我们设$dp[i][j]$表示前$i$个数，选$j$个的答案

然后就可以转移了：

$dp[i][j]=dp[i-1][j]+dp[i-1][j-1]*a[i]$

但是空间开不下怎么办呢？我们用滚动数组就好了。

```
#include <bits/stdc++.h>
#define ll long long
#define ljc 1000000007
using namespace std;
int n,k;
ll a[1000001],dp[2][1000],ans;
bool now;
inline int read(){
    register int x=0,f=1;char ch=getchar();
    while (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}
    while (isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
    return x*f;
}
int main(){
    n=read(),k=read();
    for (register int i=1;i<=n;i++) a[i]=read();
    dp[0][0]=1;
    for (register int i=1;i<=n;i++){
        now^=1;
        for (int j=0;j<=k;j++){
            dp[now][j]=(dp[now^1][j-1]*a[i]%ljc+dp[now^1][j])%ljc;
        }
    }
    printf("%lld\n",dp[now][k]);
    return 0;
}
```

---

## 作者：x义x (赞：4)

作为出题人之一非常自豪地发布这篇题解！

看到这题我们首先考虑DP。定义

$$S[n][k]$$

是前$n$个数中选$k$个的分数和。

显然，如果多考虑一个数$n$，那么我们只有两种选择：选$A[n]$或者不选。

- 选$A[n]$：$A[n]$可以和之前所有的选$k-1$个的组合配对。贡献就是$A[n]*S[n-1][k-1]$。

- 不选$A[n]$：贡献显然就是$S[n-1][k]$。

同时，直接开$S[maxN][maxK]$的数组会爆空间，这里采用滚动数组。

```
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+5,TT=1e9+7;
typedef long long LL;
LL S[2][maxn],A[maxn],C[maxn],n,k;
inline int read(){
	int red=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){ if(ch=='-') f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9') red=red*10+ch-48,ch=getchar();
	return red*f;
}
int main(){
//  freopen("math.in","r",stdin);
//  freopen("math.out","w",stdout);
	n=read(),k=read();
	for(int i=1;i<=n;i++) C[i]=read();
	for(int i=1;i<=n;i++) S[1][i]=(S[1][i-1]+C[i])%TT;
	for(int i=2;i<=k;i++)
	for(int j=1;j<=n;j++) S[i&1][j]=(S[i&1][j-1]+C[j]*S[1-i&1][j-1])%TT;
	printf("%lld\n",S[k&1][n]);
	return 0;
}
```

---

## 作者：vectorwyx (赞：3)

简单 dp

令 $dp_{i,j}$ 表示后 $i$ 个物品选了 $j$ 个的所有组合的分数和，按选和不选来转移：$dp_{i,j}=dp_{i+1,j}+dp_{i+1,j-1}\times a_{i}$。最后答案就是 $dp_{1,k}$。由于 $k\le300$，因此不需要啥滚动数组。

代码如下：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#define ll long long
#define fo(i,x,y) for(register int i=x;i<=y;++i)
#define go(i,x,y) for(register int i=x;i>=y;--i)
using namespace std;
inline int read(){ int x=0,fh=1; char ch=getchar(); while(!isdigit(ch)){ if(ch=='-') fh=-1; ch=getchar(); } while(isdigit(ch)){ x=(x<<1)+(x<<3)+ch-'0'; ch=getchar(); } return x*fh; }

const int N=1e5+5,yrz=1e9+7;
int a[N],dp[N][305];

int main(){
	int n=read(),k=read();
	fo(i,1,n) a[i]=read();
	fo(i,1,n+1) dp[i][0]=1;
	fo(i,1,k)
		go(j,n,1) dp[j][i]=(dp[j+1][i]+1ll*dp[j+1][i-1]*a[j])%yrz;
	cout<<dp[1][k];
	return 0;
}
```


---

## 作者：Catalan1906 (赞：3)

DP。

设f[i][j]为前j个数中选i个数的所有组合的分数之和

决策：
1. 不选这个数，得分为f[i][j - 1]
2. 选这个数，得分为f[i - 1][j - 1] * a[j]

可以得到状态转移方程为f[i][j] = f[i][j - 1] + f[i - 1][j - 1] * a[j]

然后，卡过空间，交上去，全WA了！？

捣鼓了半天找不出错来，（可以看出我是有多么的弱），原来是爆int

把int改成long long后，算了一下内存

# BOOM！

于是我们又要想办法优化内存

我们发现状态转移不会用到i-2及之前的状态，所以考虑滚动数组

这题由于奇偶性的原因，本人用判断奇偶的方法实现滚动数组，当然不排除有其它的实现方法。

code:

```
#include <bits/stdc++.h>
#define int long long

using namespace std;

const int mod = 1000000007LL;

int n, f[310][100010], k, a[100010];

signed main() {
    scanf("%lld%lld", &n, &k);
    for(int i = 1; i <= n; i++) {
        scanf("%lld", &a[i]);
    }
    for(int i = 0; i <= n; i++) {
        // f[1][i] = f[1][i - 1] + a[i];
        f[0][i] = 1LL;
    }
    for(int i = 1; i <= k; i++) {
        f[i & 1][0] = 0LL;
        for(int j = 1; j <= n; j++) {
            f[i & 1][j] = (f[i & 1][j - 1] + a[j] * f[(i - 1) & 1][j - 1]) % mod;
            // cout << f[i & 1][j] << " ";
        }
        // cout << endl;
    }
    printf("%lld", f[k & 1][n]);
    return 0;
}
```

---

## 作者：ahawzlc (赞：3)

蒟蒻笔者正试探地迈出写 DP 题解的第一步。

-----

首先，分析题意。

这道题就是说，要在 n 个数里选 k 个数，把它们乘起来，最后再把所有这些积加起来。（见样例解释 #2）

很容易可以发现这是个 DP，而且和 01 背包非常相似（因为每个数只能选一次），尤其和求方案数的做法相似。（好像楼下有几个大佬已经提过了）

如果令 $dp[i][j]$ 表示**前i个数字选j个的得分**。

容易有 $dp[i][j]=dp[i-1][j]+dp[i-1][j-1] \times a[i]$。其中$1\le i \le n , 1\le j \le k$。

答案就是 $dp[n][k]$。

但是这个做法我想出来之后立马就被数据范围 Hank 掉了。

所以我又想到01背包~~降维打击（非物理）~~，倒序循环k优化。

说白了，就是省掉第一维，然后倒序防止重复选。

这样虽然还是双重循环，但是空间已经是一维了，这样就可以过掉此题。

答案当然是 $dp[k]$。

应该来看这篇题解的dalao都应当是学过背包了，但是还是放一下[背包DP](https://oi-wiki.org/dp/knapsack/)罢。

``` cpp

#include<bits/stdc++.h>
#define int long long
using namespace std;
const int M=1000000007;
int n,k;
int dp[100005],a[100005];
signed main() {
	cin>>n>>k;
	dp[0]=1;
	for(int i=1; i<=n; i++)
		cin>>a[i];
	for(int i=1; i<=n; i++) {
		for(int j=k; j; j--) {
			dp[j]=(dp[j]+dp[j-1]*a[i])%M;
		}
	}
	cout<<dp[k];
	return 0;
}

```

---

## 作者：FuriousC (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P5087)

很显然，这题就是 dp

我们令 $f_{i,j}$ 为前 $i$ 个数选 $j$ 个的方案数，然后根据 01背包 的思想，很容易得到状态转移方程：

$f_{i,j}=f_{i-1,j}+f_{i-1,j-1}\times a_i$

然后这题唯一的难点就来了（~~其实也没啥难的~~）

空间被卡怎么办？

直接砍掉一维就可以了

所以转移方程就变成了：

$f_j=f_j+f_{j-1}\times a_i$

代码：（不开 `long long` 见祖宗）

```
#include<bits/stdc++.h>
using namespace std;
const int mod=1000000007;
const int maxn=100005;
long long n,k;
long long a[maxn],f[maxn];
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++){
	    cin>>a[i];
	}
	f[0]=1;
	for(int i=1;i<=n;i++){
		for(int j=k;j>=0;j--){
			f[j]=(f[j]+f[j-1]*a[i])%mod;
		}
	}//01背包模板
	cout<<f[k];
	return 0;
}
```


---

## 作者：Mars_Dingdang (赞：1)

背包问题的基础练习题，熟悉了背包的本质就很好做了。

## 题目大意

$n$ 个物体，每个物体体积为 $1$，价值为 $a_i$，求体积不超过 $k$ 的价值乘积组合的和。

典型的 01 背包问题方案数。

## 大体思路

考虑动态规划。用 $f(i,j)$ 表示前 $i$ 件物品在体积剩余 $j$ 时的乘积之和。则状态转移方程为：

$$f(i,j)=f(i-1,j)+f(i-1,j-i)\times a_i,\ f(0,0)=1$$

观察可得：每一次与且仅与前一次的状态有关，因此考虑优化：

1. 利用滚动数组优化。由于 $i$ 仅有 $i-1$ 转移而来，可以将状态转移方程变为：

`f(i&1,j)=f((i-1)&1,j)+f((i-1)&1,j-i)*a_i`。

这样空间优化为 $O(2k+n)$，完全可以接受。

2. 考虑背包，直接压掉第一个维度，然后改变循环顺序（即倒序循环）。

其中，倒序循环的原因在于每件物品只能取一次，因此在更新 $f_j$ 时，必须保持 $f_{j-1}$ 是上一轮的值，所以采用倒序循环。

## 完整代码：
```cpp
#include<iostream>
using namespace std;
#define rep(ii,aa,bb) for(re int ii=aa;ii<=bb;ii++)
#define Rep(ii,aa,bb) for(re int ii=aa;ii>=bb;ii--)
typedef long long ll;
typedef unsigned long long ull;
const int maxn=1e5+5;
const int mod=1e9+7;
namespace IO_ReadWrite{
	#define re register
	#define gg (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
	char buf[1<<21],*p1=buf,*p2=buf;
	template <typename T>
	inline void read(T &x){
		x=0;re T f=1;re char c=gg;
		while(c>57||c<48){if(c=='-') f=-1;c=gg;}
		while(c>=48&&c<=57){x=(x<<1)+(x<<3)+(c^48);c=gg;}
		x*=f;return;
	}
	inline void ReadChar(char &c){
		c=gg;
		while(!isalpha(c)) c=gg;
	}
	template <typename T>
	inline void write(T x){
		if(x<0) putchar('-'),x=-x;
		if(x>9) write(x/10);
		putchar('0'+x%10);
	}
	template <typename T>
	inline void writeln(T x){write(x);putchar('\n');}
}
using namespace IO_ReadWrite;//快读
ll a[maxm],f[maxm];
int n,k;
int main(){
	read(n);read(k);
	rep(i,1,n) read(a[i]);//输入
	f[0]=1;//边界勿漏为要。
	rep(i,1,n)
		Rep(j,k,0)
			f[j]=(f[j]+1ll*f[j-1]*a[i])%mod;
        //状态转移方程
	writeln(f[k]);//输出
	return 0;
}
```
## 后记
在题解区看到有大神使用分治 NTT 将模数换成$998244353$ 后压到了 $O(n\log^2n)$，让我们膜拜他吧！

大家去爆切[这道题](https://www.luogu.com.cn/problem/P6012)吧！

---

## 作者：周子衡 (赞：1)

思路：$DP$

设$dp[i][j]$为前$i$个数选$j$个的分数总和

显然有：$dp[i][j]=a[i]\times dp[i-1][j-1]+dp[i-1][j]$

发现可以优化到一维，循环逆序即可

提醒：要开$long$ $long$

代码：

```cpp
#include<cstdio>
#include<algorithm>

using namespace std;

int a[100001]={};
long long dp[301]={};
const int MOD=1e9+7;

int main()
{
    int n=9,k=0;
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
    }
    dp[0]=1;
    for(int i=1;i<=n;i++)
    {
        for(int j=min(i,k);j>=1;j--)
        {
            dp[j]+=(long long)a[i]*dp[j-1];
            dp[j]%=MOD;
        }
    }
    printf("%lld",dp[k]%MOD);
}
```

---

## 作者：lmrttx (赞：0)

说真的，这题恶评了。

考的是01背包，这里讲下压维的做法。

定义：$dp[i]$ 表示选 $i$ 的物品的分数这和。

状态转移方程就是：

$$dp[i]=dp[i]+dp[i-1]*a[j]$$

这里的 $j$ 为区间 $[1,n]$ 中任意整数。

边界值就是 $dp[0]=1$。

状态转移方程的得来：一个状态由本身加上（分数之和）上一个状态乘取出的数（题目要求的是积），最后推得答案(就是改装了一下01背包)。

答案就是 $dp[k]$ 了。

由于**每个数只取一次**，所以使用01背包的正确性使然。

$Code$ ~~我做了点手脚，不要复制！~~

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll mod=1000000007;
ll n,k,a[100010],dp[100010];
int main(){
	scanf("%ld%ld",&n,&k);
	dp[0]=1;
	for(register int i=1;i<=n;i++){
		scanf("%ld",&a[i]);
	}
	for(int i=1;i<=n;i++)
	for(int j=k;j>=0;j--){
		dp[j]=(dp[j]+dp[j-1]*a[i])%mod;
        //取模不能漏
	}
	printf("%ld",$dp[k]);
	return 0;
}
```

谢谢阅读qwq!

---

## 作者：Mobius127 (赞：0)

~~白水一道蓝题，针不戳~~

[~~博客食用更佳~~](https://www.luogu.com.cn/blog/lzj2233/p5087-shuo-xue)

考虑$DP$,设$f[K][N]$表示前$N$个数中已选$K$个的分数。

有状态转移方程：
$f[i][j]=f[i][j-1]+f[i-1][j-1]*a[j]$

为什么能这么$DP?$

我们知道，当选到$i$，选了$k-1$个数的时候，$a[i]$对答案的贡献就是前面$k-1$选的数的分组成绩与$a[i]$的成绩和。

说明白点，设$s[i]|i<=m$为$i$之前的分组搭配积，有$m$个，那么$a[i]$对答案的贡献就是$ans_i=\sum_{j=1}^{m}a[i]*s[j]$，将$a[i]$提出，就得到了$ans_i=a[i]*\sum_{j=1}^{m}s[j]$。所以，我们只要统计和即可。

$DP$代码：

```cpp
	for(int i=0; i<=n; i++) f[0][i]=1;//令不选时初值为0，否则会使乘法失效
	for(int i=1; i<=k; i++)
		for(int j=1; j<=n; j++)
			f[i][j]=(f[i][j-1]+(f[i-1][j-1]*a[j])%mo)%mo;
```


注意到状态转移方程中的$i$只会与$i-1$有联系，所以我们可以用滚动数组优化空间。

$AC$ $Code$：

```cpp
#include <stdio.h>
#include <algorithm>
#include <cstring>
#define N 100005
#define K 305
#define mo 1000000007
using namespace std;
typedef long long LL;
LL f[2][N];
int n, k, a[N];
int main(){
	scanf("%d%d", &n, &k);
	for(int i=1; i<=n; i++)
		scanf("%d", &a[i]);
	for(int i=0; i<=n; i++) f[0][i]=1;
	for(int i=1; i<=k; i++){
		f[i&1][0]=0;//注意滚动数组后要将上一次的0位改为
		for(int j=1; j<=n; j++){
			f[i&1][j]=(f[i&1][j-1]+(f[(i-1)&1][j-1]*a[j])%mo)%mo;
		}
	}
	printf("%lld", f[k&1][n]);		
	return 0;
}
```


---

## 作者：拂清歌 (赞：0)

## 一看这个题面，相信dalao们一看就知道是DP，但我做了一遍组合计数
众所周知，这种搭配来搭配去的东西，肯定就是dp或者暴力的组合计数

根据经验，一般的题目组合计数都不行（当然我还是做了一遍），所以直接向dp的方向想吧

我们用dp[i][j]表示从前i个物品中选择j个，得出的答案。状态转移方程很好推，dp[i-1][j]+=dp[i-1][j-1]乘a[i]，然后为了不高精度（我比较懒，但是题目里也说了），每一步直接%1000000007。啊，真简单。这明明很好理解，结果数据范围总是来坏我们的好事。哟呵，果然不能二维dp

那能怎么办？上一次我写另一题的题解写了一个滚动数组写得头都大了，所以这次我果断地选择了降维。液压机“吱——”一声响，直接把二维硬压成1维了。dp[i]表示选i个数的答案。

是时候上代码了......

```
#include <bits/stdc++.h>
#define MAX 100005//N的最大值是100000，为了防数组超界，多开了5
#define mod 1000000007//模数
#define _MATH_DEFINES_DEFINED
#pragma GCC optimize("O2")//手动开O2
using namespace std;
long long dp[MAX],a[MAX],n,k;//注意全开long long，否则全WA（我提交了好多次......）
inline long long read(void){//快读
	long long f=1,n=0;char c=getchar();
	while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
	while(isdigit(c)){n=n*10+(c-'0');c=getchar();}
	return f*n;
}
void input(void){//读入用的是快读，用cin是一样的
	n=read(),k=read(); 
	for(int i=1;i<=n;i++) a[i]=read();
}
void DP(void){
	dp[0]=1;//选0个数有一种搭配（否则就全是0）
	for(int i=1;i<=n;i++){
		for(int j=k;j>=0;j--){
			dp[j]=(dp[j]+dp[j-1]*a[i])%mod;//状态转移方程
		}
	}
}
void output(void){
	cout<<dp[k]<<endl;//输出选k个数的答案（最终答案）
}
signed main(void){
	input();//输入
	DP();//做dp
	output();//输出
}
```
依我看，你是不是突然想点赞？

---

## 作者：李若谷 (赞：0)

## DP

$f[i][j]$ 表示前i个物品取j个的总和。

$f[i][j]$可以从两种状态转移过来。

第一，不取第i个。很显然, 就是$f[i-1][j]$

第二，取第i个。就是$f[i-1][j-1]$。

状态转移方程就是$f[i][j] = f[i-1][j] + f[i-1[j-1] * a[i]$

这道题要用滚动数组

代码：
```cpp
#include <stdio.h>
#include <iostream>
using namespace std;
const long long mod = 1000000007;
long long a[100001];
long long dp[5][305];
int main()
{
	long long n,m;
	cin>>n>>m;
	for(register int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	dp[0][0] = 1;
	for(register int i=1;i<=n;++i)
	{
		for(register int j=0;j<=m;++j)
		{
			if(j==0)
				dp[i&1][0] = dp[(i-1)&1][0];
			else
				dp[i&1][j] = (dp[(i-1)&1][j] + dp[(i-1)&1][(j-1)] * a[i])%mod;
		}
	}
	cout<<dp[n&1][m]<<endl;
	return 0;
}
```

---


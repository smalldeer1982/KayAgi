# 【模板】多项式幂函数（加强版）

## 题目背景

[普通版传送门](https://www.luogu.com.cn/problem/P5245)

模板题，无背景。

## 题目描述

给定一个 $n-1$ 次多项式 $A(x)$，求一个在 $\bmod\ x^n$ 意义下的多项式 $B(x)$，使得 $B(x) \equiv (A(x))^k \ (\bmod\ x^n)$。

多项式的系数在 $\bmod\ 998244353$ 的意义下进行运算。

## 说明/提示

对于 $100\%$ 的数据，$1< n \leq 10^5$，$0 \leq k \leq 10^{10^5}$，$a_i \in [0,998244352]$。

[数据更新时间](https://www.luogu.com.cn/paste/897zk1ia)

## 样例 #1

### 输入

```
2 2
1 1```

### 输出

```
1 2```

# 题解

## 作者：SSerxhs (赞：22)

前置芝士：多项式 $\exp$、多项式 $\ln$

推式子
$$B(x)\equiv A^m(x)(\mathrm{mod\:}x^n)$$
同时取对数
$$\ln B(x)\equiv m\ln A(x)(\mathrm{mod\:}x^n)$$
所以对 $A(x)$ 取 $\ln$，系数乘上 $m$，再 $\exp$ 就可以了。

然而这题并不保证 $a_0=1$，所以取 $\ln$ 之前要先提取一个公因式 $b\times x^k$，其中 $k$ 满足 $a_k\ne0,\text{且}\ \forall\ 0\le i< k,a_i=0$, $b$ 为第一个非 $0$ 项的系数(即 $x_k$ 的系数)，这样就可以保证最低位是 $1$ 了。注意 $k\times m>n$ 的特殊处理。

最新数据中有一个细节：新的 $A^m(x)$ 的 $m$ 是对 $p$ 取模的，而 $b^m$ 中的 $m$ 应该对 $\varphi(p)$ 取模。

然后多项式全家桶拉过来就好了。

由于未对代码进行有效切割（直接套用了多项式板子），[代码](https://www.luogu.com.cn/paste/1g3n4xrj)以链接形式给出避免挤占版面。

---

## 作者：NaCly_Fish (赞：21)

做过[P5245 【模板】多项式快速幂](https://www.luogu.org/problemnew/show/P5245)的都知道，求 $F(x)^k$ 时，若 $F(0)=1$，就可以直接用$\ln+\exp$来搞。   
也就是这个式子：  
$$F(x)^k= \text e^{k\ln F(x)}$$
****
可是现在不保证 $F(0)=1 $了，我们就得想想办法，把 $F(0)$ 搞成$1$。  
只要把 $F(x)$ 的每一项都除以 $F(0)$ ，问题不就解决了么？

$$F(x)^k=\left(\frac{F(x)}{F(0)} \right)^kF(0)^k$$  
仔细一看：不对，如果 $F(0)=0$ 的话，这个方法就挂掉了。    
这时，可以考虑将 $F(x)$ 降次，然后再升次。  
具体来讲，我们要找出最小的 $t$，满足 $F(x)$ 的 $t$ 次项不为$0$。   
$$F(x)^k=\left(\frac{F(x)}{x^t} \right)^kx^{tk}$$  
  

然后直接模拟过程+套模板即可。  
时间复杂度 $\Theta(n\log n)$，比倍增法不知高到哪里去了。
 
```cpp
#pragma GCC optimize (2)
#pragma GCC optimize ("unroll-loops")
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#define N 262147
#define ll long long
#define reg register
#define p 998244353
#define add(x,y) (x+y>=p?x+y-p:x+y)
#define dec(x,y) (x<y?x-y+p:x-y)
using namespace std;

inline int power(int a,int t){
	int res = 1;
	while(t){
		if(t&1) res = (ll)res*a%p;
		a = (ll)a*a%p;
		t >>= 1; 
	}
	return res;
}

int rev[N],rt[N],inv[N];
int siz;

void init(int n){
    int w,lim = 1;
    while(lim<=n) lim <<= 1,++siz;
    for(reg int i=1;i!=lim;++i) rev[i] = (rev[i>>1]>>1)|((i&1)<<(siz-1));
    inv[1] = rt[lim>>1] = 1;
    w = power(3,(p-1)>>siz);
    for(reg int i=(lim>>1)+1;i!=lim;++i) rt[i] = (ll)rt[i-1]*w%p;
    for(reg int i=(lim>>1)-1;i;--i) rt[i] = rt[i<<1];
    for(reg int i=2;i<=n;++i) inv[i] = (ll)(p-p/i)*inv[p%i]%p;
}

inline int getlen(int n){
    return 1<<(32-__builtin_clz(n));
}

inline void NTT(int *f,int type,int lim){
    if(type==-1) reverse(f+1,f+lim);
    static unsigned long long a[N];
    reg int x,shift = siz-__builtin_ctz(lim);
    for(reg int i=0;i!=lim;++i) a[rev[i]>>shift] = f[i];
    for(reg int mid=1;mid!=lim;mid<<=1)
    for(reg int j=0;j!=lim;j+=(mid<<1))
    for(reg int k=0;k!=mid;++k){
        x = a[j|k|mid]*rt[mid|k]%p;
        a[j|k|mid] = a[j|k]-x+p;
        a[j|k] += x;
    } 
    for(reg int i=0;i!=lim;++i) f[i] = a[i]%p;
    if(type==1) return;
    x = p-((p-1)>>(siz-shift));
    for(reg int i=0;i!=lim;++i) f[i] = (ll)f[i]*x%p;
}

inline void inverse(const int *f,int n,int *R){
    static int g[N],h[N],s[30];
    memset(g,0,getlen(n<<1)<<2);
    int lim = 1,top = 0;
    while(n){
        s[++top] = n;
        n >>= 1;
    }
    g[0] = power(f[0],p-2);
    while(top--){
        n = s[top+1];
        while(lim<=(n<<1)) lim <<= 1;
        memcpy(h,f,(n+1)<<2);
        memset(h+n+1,0,(lim-n)<<2);
        NTT(g,1,lim),NTT(h,1,lim);
        for(reg int i=0;i!=lim;++i) g[i] = g[i]*(2-(ll)g[i]*h[i]%p+p)%p;
        NTT(g,-1,lim);
        if(top) memset(g+n+1,0,(lim-n)<<2);
    }
    memcpy(R,g,(n+1)<<2);
}

inline void log(int *f,int n){
    static int g[N];
    int lim = getlen(n<<1);
    inverse(f,n,g);
    memset(g+n+1,0,(lim-n)<<2);
    for(reg int i=0;i!=n;++i) f[i] = (ll)f[i+1]*(i+1)%p;
    f[n] = 0;
    NTT(f,1,lim),NTT(g,1,lim);
    for(reg int i=0;i!=lim;++i) f[i] = (ll)f[i]*g[i]%p;
    NTT(f,-1,lim);
    for(reg int i=n;i;--i) f[i] = (ll)f[i-1]*inv[i]%p;
    f[0] = 0;
    memset(f+n+1,0,(lim-n)<<2);
}

inline void exp(int *f,int n){
    static int g[N],h[N],s[30];
    int lim = 1,top = 0;
    memset(g,0,getlen(n<<1)<<2);
    while(n){
        s[++top] = n;
        n >>= 1;
    }
    g[0] = 1;
    while(top--){
        n = s[top+1];
        while(lim<=(n<<1)) lim <<= 1;
        memcpy(h,g,(n+1)<<2);
        memset(h+n+1,0,(lim-n)<<2);
        log(g,n);
        for(reg int i=0;i<=n;++i) g[i] = dec(f[i],g[i]);
        g[0] = add(g[0],1);
        NTT(g,1,lim),NTT(h,1,lim);
        for(reg int i=0;i!=lim;++i) g[i] = (ll)g[i]*h[i]%p;
        NTT(g,-1,lim);
        memset(g+n+1,0,(lim-n)<<2);
    }
    memcpy(f,g,(n+1)<<2);
}

inline void power(int *f,int n,int k1,int k2){
    register int u,v,shift = 0;
    for(reg int i=0;i<=n&&f[i]==0;++i) ++shift;
    if((ll)shift*k1>n){
        for(reg int i=0;i<=n;++i) printf("0 ");
        return;
    }
    u = power(f[shift],p-2),v = power(f[shift],k2);
    for(reg int i=0;i<=n;++i) f[i] = (ll)f[i+shift]*u%p;
    log(f,n);
    for(reg int i=1;i<=n;++i) f[i] = (ll)f[i]*k1%p;
    exp(f,n);
    shift *= k1;
    for(reg int i=0;i!=shift;++i) printf("0 ");
    for(reg int i=shift;i<=n;++i) printf("%lld ",(ll)f[i-shift]*v%p);
}

int F[N];
char str[N];
int n,k1,k2,k3;

int main(){
    scanf("%d%s",&n,str);
    int ln = strlen(str);
    for(reg int i=0;i!=ln;++i){
        k1 = (10ll*k1+str[i]-'0')%p;
        k2 = (10ll*k2+str[i]-'0')%(p-1);
    }
    for(reg int i=0;i!=min(6,ln);++i) k3 = 10*k3+str[i]-'0';
    for(reg int i=0;i!=n;++i) scanf("%d",&F[i]);
    if(F[0]==0&&k3>=n){
        for(reg int i=0;i!=n;++i) printf("0 ");
        return 0;
    }
    init(n<<1|1);
    power(F,n-1,k1,k2);
	return 0;	
}
```

---

## 作者：周道_Althen (赞：14)

## ~~广告:[【多项式的操作大赏】](https://blog.csdn.net/weixin_43973966/article/details/87864851)~~

$\ \ \ \ \ \ \ $这道题啊，相对于常规版少了一个条件：$a[0]=1$，那么这道题唯一的痛点就是，如何把 $a[0]$ 化成对于 $1$ 。

$\ \ \ \ \ \ \ $了解到呢，很多同学是化成下面的式子来处理的：

$$A^k=\left({\frac{A}{A_0}}\right)^k\times A_0^k$$

$\ \ \ \ \ \ \ $这样子就可以成功把 $a[0]$ 化成对于 $1$ ，然后单独 $a[0]=0$ 处理，剩下的就是套$ln$，$exp$板子了。

# $\ \ \ \ \ \ \ $但是这样有没有必要呢？显然是没有必要的：

$\ \ \ \ \ \ \ $首先考虑为什么一定要保证$a[0]=1$？

$\ \ \ \ \ \ \ $因为这样可以保证 $ln(A)_0\times k=0$ ，从而方便算出$exp$。

$\ \ \ \ \ \ \ $那么为什么？当 $ln(A)_0\times k=0$ 等于其他数的时候，不方便算$exp$了呢？

$\ \ \ \ \ \ \ $我们得回忆一下$exp$是怎么求的:

$\ \ \ \ \ \ \ $令我们要求的是 $A$ 的指数函数 $B$，既是：

$$B=e^A$$

$\ \ \ \ \ \ \ $变形得：

$$\ln(B)-A=0$$

$\ \ \ \ \ \ \ $设$F(B)=\ln (B)-A$，我们要求的就是 $F$的零点，这里是吧多项式当做常量了，牛顿迭代得到的式子（注意这里B后面的括号的迭代版本的意思，不是多项式的项，下标才是表示的项）：

$$B(x)=B(x-1)-\frac{F\left(B(x-1)\right)}{F'\left(B(x-1)\right)}$$

$\ \ \ \ \ \ \ $由$F'(B)=\frac{1}{B}$，化简牛顿迭代的公式：

$$\begin{aligned}B(x)&=B(x-1)-B(x-1)*F\left(B(x-1)\right)\\&=B(x-1)-B(x-1)*\ln \left(B(x-1)\right)-A\\&=B(x-1)* \left(1-\ln \left(B(x-1)\right)-A \right)\end{aligned}$$

$\ \ \ \ \ \ \ $在倍增求解的过程中，我们只需要知道第一个版本是多少，也就是 $B_0$ ，常数项的值就知道了：

$\ \ \ \ \ \ \ $在一般情况下，这个问题很显然，因为：$e^0=1$，所以说当$A_0=0$的时候，他的指数函数 $B$，$B_0=1$，第一个版本就确定了。

$\ \ \ \ \ \ \ $当$A_0\neq0$的时候，第一个版本确实不好求。

# $\ \ \ \ \ \ \ $回到题目：

$\ \ \ \ \ \ \ $好在我们很清楚的是：

$\ \ \ \ \ \ \ $对于求$B=A^k$，有：

$$B=exp(ln(A)\times k)$$

$\ \ \ \ \ \ \ $好了，我们要求的第一个版本就是$exp(ln(A)\times k)$的常数项，也就是$B$的常数项，那么常数项是多少呢？

# $\ \ \ \ \ \ \ $当然是$A_0^k$啊。

$\ \ \ \ \ \ \ $到此，感觉有理有据的，可是实际操作写下来，怎么只有$90$分呢？

$\ \ \ \ \ \ \ $当$a[0]=0$时，第一个版本应该是$B_0=0$，可是……版本真的可以为$0$吗？

$\ \ \ \ \ \ \ $我们是要求 $F'(B)=\frac{1}{B}$ 的，分母当然不能为 $0$ 了，所以说我们还是要单独处理 $a[0]=0$ 的情况的。

$\ \ \ \ \ \ \ $把为$0$的前缀提出来，然后算，最后在答案前面加上提出的长度乘上$k$个$0$即可，具体可以看丑陋的代码：

$\ \ \ \ \ \ \ $因为是直接贴的辣鸡板子，所以说跑得很慢：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstdlib>
#include<cstring>
#include<string>
#include<queue>
#include<map>
#include<set>
#include<stack>
#include<cmath>
#include<cctype>
using namespace std;
const int inf=0x7fffffff;
const double eps=1e-10;
const double pi=acos(-1.0);
//char buf[1<<15],*S=buf,*T=buf;
//char getch(){return S==T&&(T=(S=buf)+fread(buf,1,1<<15,stdin),S==T)?0:*S++;}
inline int read(){
  int x=0,f=1;char ch;ch=getchar();
  while(ch<'0'||ch>'9'){if(ch=='-') f=0;ch=getchar();}
  while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch&15);ch=getchar();}
  if(f)return x;else return -x;
}
const int N=3e6+10;
const int mod=998244353,mod_g=3;
int K;
int R[N];
int power(int a,int b){
  int ans=1;
  for(;b;b>>=1,a=1ll*a*a%mod)if(b&1)ans=1ll*ans*a%mod;
  return ans;
}
#define Inv(x) power(x,mod-2)
int Polynomial_init(int n){
  int len;for(len=1;len<n;len<<=1);
  return len;
}
void NTT(int *a,int f,int la){
  int n=la;
  for(int i=0;i<n;i++)if(i<R[i])swap(a[i],a[R[i]]);
  for(int i=1;i<n;i<<=1){
    int gn=power(mod_g,(mod-1)/(i<<1));
    for(int j=0;j<n;j+=(i<<1)){
      int g=1;
      for(int k=0;k<i;k++,g=1ll*g*gn%mod){
        int x=a[j+k],y=1ll*g*a[i+j+k]%mod;
        a[j+k]=(x+y)%mod;a[i+j+k]=(x-y+mod)%mod;
      }
    } 
  }
  if(f==-1){
    reverse(a+1,a+n);
    int inv=Inv(n);
    for(int i=0;i<n;i++)a[i]=1ll*a[i]*inv%mod;
  }
}
int Convolution(int *a,int *b,int la,int lb){
  int n=la,m=lb;
  int L=0;for(m+=n,n=1;n<=m;n<<=1)L++;
  for(int i=0;i<n;i++)R[i]=(R[i>>1]>>1)|((i&1)<<(L-1));
  NTT(a,1,n);NTT(b,1,n);
  for(int i=0;i<=n;i++)a[i]=1ll*a[i]*b[i]%mod;
  NTT(a,-1,n);
  return m;
}
int I[N],J[N];
int Multiplication(int *a,int *b,int *c,int la,int lb){
  int n=la,m=lb;
  int L=0;for(m+=n,n=1;n<=m;n<<=1)L++;
  for(int i=0;i<n;i++)R[i]=(R[i>>1]>>1)|((i&1)<<(L-1));
  for(int i=0;i<=la;++i) I[i]=a[i];
  for(int i=0;i<=lb;++i) J[i]=b[i];
  NTT(I,1,n);NTT(J,1,n);
  for(int i=0;i<=n;i++)c[i]=1ll*I[i]*J[i]%mod,I[i]=J[i]=0;
  NTT(c,-1,n);
}
int C[N];
void Inverse(int *a,int *b,int len){
  if(len==1){b[0]=Inv(a[0]);return;}
  Inverse(a,b,(len+1)>>1);
  int L=0,n=1;
  for(;n<(len<<1);n<<=1)L++;
  for(int i=1;i<n;i++)R[i]=(R[i>>1]>>1)|((i&1)<<(L-1));
  for(int i=0;i<len;i++)C[i]=a[i];
  for(int i=len;i<n;i++)C[i]=0;
  NTT(C,1,n);NTT(b,1,n);
  for(int i=0;i<=n;i++)b[i]=1ll*(2ll-1ll*C[i]*b[i]%mod+mod)%mod*b[i]%mod;
  NTT(b,-1,n);
  for(int i=len;i<n;i++)b[i]=0;
}
int H[N];
void Division(int *a,int *b,int la,int lb,int *Quotient,int *Remainder){
  int n=la,m=lb;
  reverse(a,a+1+n),reverse(b,b+1+m);
  int len=1;while(len<=n-m)len<<=1;
  memset(C,0,sizeof(C));
  Inverse(b,H,len);
  Multiplication(a,H,Quotient,n-m,n-m);
  reverse(Quotient,Quotient+n-m+1);
  reverse(a,a+n+1),reverse(b,b+m+1);
  Multiplication(Quotient,b,Remainder,n-m,m);
  for(int i=0;i<m;++i)Remainder[i]=(a[i]-Remainder[i]+mod)%mod;
}
void Derivation(int *a,int *b,int n){
  for(int i=1;i<n;i++)
  b[i-1]=1ll*i*a[i]%mod;
  b[n-1]=0;
}
void Integral(int *a,int *b,int n){
  for(int i=1;i<n;i++)
  b[i]=1ll*Inv(i)*a[i-1]%mod;
  b[0]=0;
}
int ln_a[N],ln_b[N];
void Logarithmic(int *a,int *b,int n){
  memset(ln_a,0,sizeof(ln_a));
  memset(ln_b,0,sizeof(ln_b));
  Derivation(a,ln_a,n);
  memset(C,0,sizeof(C));
  Inverse(a,ln_b,n);
  Convolution(ln_a,ln_b,n,n);
  Integral(ln_a,b,n);
}
int D[N];
void Exponential(int *a,int *b,int len){
  if(len==1){return;}
  Exponential(a,b,len>>1),Logarithmic(b,D,len);
  D[0]=(1ll*a[0]+1ll-D[0]+mod)%mod;
  for(int i=1;i<len;++i) D[i]=(1ll*a[i]-D[i]+mod)%mod;
  Convolution(b,D,len<<1,len<<1);
  for(int i=len;i<(len<<1);++i) b[i]=D[i]=0;
}
int p_a[N];
void Power(int *a,int *b,int len){
  Logarithmic(a,p_a,len);
  for(int i=1;i<=len;i++)p_a[i]=1ll*p_a[i]*K%mod;
  b[0]=power(a[0],K%(mod-1));
  Exponential(p_a,b,len);
}
int n,F[N],G[N],low;
int main()
{
  n=read();K=read();
  for(int i=0;i<n;i++)F[i]=read();
  for(int i=0;i<=n;++i){if(!F[i])continue;low=i;break;}
  if(low)for(int i=low;i<n;++i)F[i-low]=F[i],F[i]=0;
  Power(F,G,Polynomial_init(n));
  if(low){
    if(1ll*low*K>n)low=n;
    else low*=K;
    for(int i=n-1;i>=0;--i){
      if(i+low<n)G[i+low]=G[i];
      G[i]=0;
    }
  }	
  for(int i=0;i<n;i++)printf("%d ",G[i]);
  return 0;
}

```


---

## 作者：Karry5307 (赞：9)

### 题意
给定$n-1$次多项式$F(x)$和整数$k$，求$\bmod\ x^n$意义下的$(F(x))^k$，**不保证$F_0=1$**。

$\texttt{Data Range:}n\leq 10^5,0\leq k,F_i\leq 998244352$
### 题解
首先，感谢[memset0](https://www.luogu.org/space/show?uid=53495) ，[SSerxhs](https://www.luogu.org/space/show?uid=29826)，[BackOnTrack](https://www.luogu.org/space/show?uid=2524)，[Weng_Weijie](https://www.luogu.org/space/show?uid=26127)等聚聚的帮助！！！

然后才是正题。

首先考虑用[P5245](https://www.luogu.org/problemnew/show/P5245)的正解来跑一遍，发现当$F_0\neq 1$时整个式子的每一项都少乘了一个$F_0^k$，于是可以考虑把它乘过来。

但是，就在你兴冲冲地去提交的时候，你就会发现你$\color{#e74c3c}\texttt{WA \#9}$，那是因为**题目并不保证$F_0\neq 0$**。如果$F_0$等于$0$，那么按照讨论区大佬的思路，先左移在右移就可以了。

但是，如果你还是不能$\color{#5eb95e}\texttt{AC}$，而且还$\color{#8e44ad}\texttt{RE \#8}$的话，那么就应该是爆$\texttt{int}$了，这时候就应该把记录的$F$前面你$0$的个数和$k$用$\texttt{long long}$乘起来，就可以$\color{#5eb95e}\texttt{AC}$啦qwq。

对了，这里还附赠一组对拍数据，给像我一样$\color{#8e44ad}\texttt{RE \#8}$的小伙伴们的：

```
Input:

5 998244352
0 0 0 1 1
Output:

0 0 0 0 0
```
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef int ll;
typedef long long int li;
const ll MAXN=4e5+51,MOD=998244353,G=3,INVG=332748118;
ll fd,exponent,k,num,x,flag;
li zero;
ll f[MAXN],res[MAXN],g[MAXN],rev[MAXN];
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
        neg=-1;
        ch=getchar();
    }
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
}                                 
inline ll qpow(ll base,ll exponent)
{
    li res=1;
    while(exponent)
    {
        if(exponent&1)
        {
            res=(li)res*base%MOD;
        }
        base=(li)base*base%MOD,exponent>>=1;
    }
    return res;
}
inline void NTT(ll *cp,ll cnt,ll inv)
{
    ll cur=0,res=0,omg=0;
    for(register int i=0;i<cnt;i++)
    {
        if(i<rev[i])
        {
            swap(cp[i],cp[rev[i]]);
        }
    }
    for(register int i=2;i<=cnt;i<<=1)
    {
        cur=i>>1,res=qpow(inv==1?G:INVG,(MOD-1)/i);
        for(register ll *p=cp;p!=cp+cnt;p+=i)
        {
            omg=1;
            for(register int j=0;j<cur;j++)
            {
                ll t=(li)omg*p[j+cur]%MOD,t2=p[j];
                p[j+cur]=(t2-t+MOD)%MOD,p[j]=(t2+t)%MOD;
                omg=(li)omg*res%MOD;
            }
        }
    }
    if(inv==-1)
    {
        ll invl=qpow(cnt,MOD-2);
        for(register int i=0;i<=cnt;i++)
        {
            cp[i]=(li)cp[i]*invl%MOD;
        }
    }
}
inline void inv(ll fd,ll *f,ll *res)
{
    static ll tmp[MAXN];
    if(fd==1)
    {
        res[0]=qpow(f[0],MOD-2);
        return;
    }
    inv((fd+1)>>1,f,res);
    ll cnt=1,limit=-1;
    while(cnt<(fd<<1))
    {
        cnt<<=1,limit++;
    }
    for(register int i=0;i<cnt;i++)
    {
        tmp[i]=i<fd?f[i]:0;
        rev[i]=(rev[i>>1]>>1)|((i&1)<<limit);
    }
    NTT(tmp,cnt,1),NTT(res,cnt,1);
    for(register int i=0;i<cnt;i++)
    {
        res[i]=(li)(2-(li)tmp[i]*res[i]%MOD+MOD)%MOD*res[i]%MOD;
    }
    NTT(res,cnt,-1);
    for(register int i=fd;i<cnt;i++)
    {
        res[i]=0;
    }
}
inline void ln(ll fd,ll *f,ll *res)
{
    static ll pinv[MAXN],der[MAXN];
    ll cnt=1,limit=-1;
    while(cnt<(fd<<1))
    {
        cnt<<=1,limit++;
    }
    inv(fd,f,pinv);
    for(register int i=1;i<fd;i++)
    {
        der[i-1]=(li)f[i]*i%MOD;
    }
    der[fd-1]=0;
    for(register int i=0;i<cnt;i++)
    {
        rev[i]=(rev[i>>1]>>1)|((i&1)<<limit);
    }
    NTT(pinv,cnt,1),NTT(der,cnt,1);
    for(register int i=0;i<cnt;i++)
    {
        der[i]=(li)der[i]*pinv[i]%MOD;
    }
    NTT(der,cnt,-1);
    for(register int i=1;i<fd;i++)
    {
        res[i]=(li)der[i-1]*qpow(i,MOD-2)%MOD;
    }
    res[0]=0;
    for(register int i=0;i<cnt;i++)
    {
        der[i]=pinv[i]=0;
    }
}
inline void exp(ll fd,ll *f,ll *res)
{
    static ll texp[MAXN];
    if(fd==1)
    {
        res[0]=1;
        return;
    }
    ll cnt=1,limit=-1;
    while(cnt<(fd<<1))
    {
        cnt<<=1,limit++;
    }
    exp((fd+1)>>1,f,res),ln(fd,res,texp);
    for(register int i=0;i<cnt;i++)
    {
 		rev[i]=(rev[i>>1]>>1)|((i&1)<<limit);
    }
    texp[0]=(f[0]+1-texp[0]+MOD)%MOD;
    for(register int i=1;i<fd;i++)
    {
        texp[i]=(f[i]-texp[i]+MOD)%MOD;
    }
    NTT(texp,cnt,1),NTT(res,cnt,1);
    for(register int i=0;i<cnt;i++)
    {
        res[i]=(li)res[i]*texp[i]%MOD;
    }
    NTT(res,cnt,-1);
    for(register int i=0;i<cnt;i++)
    {
        texp[i]=0,res[i]=i<fd?res[i]:0;
    }
}
int main()
{
    fd=read(),exponent=read();
    for(register int i=0;i<fd;i++)
    {
        x=read();
        !(x||flag)?zero++:flag=1,f[i-zero]=x;
    }
    if(!flag)
    {
        for(register int i=0;i<fd;i++)
        {
            putchar('0'),putchar(' ');
        }
        return 0;
    }
    k=f[0],ln(fd-zero,f,g);
    for(register int i=0;i<fd-zero;i++)
    {
        g[i]=(li)g[i]*exponent%MOD;
    }
    exp(fd-zero,g,res),zero=(li)zero*exponent;
    for(register li i=0;i<min(zero,1ll*fd);i++)
    {
        putchar('0'),putchar(' ');
    }
    for(register li i=zero;i<fd;i++)
    {
        printf("%d ",(li)res[i-zero]*qpow(k,exponent)%MOD);
    }
}
```

---

## 作者：Jμdge (赞：8)

本来以为这道题是任意模数？【雾 ， 后来发现这道题是没有说明 $f[0]=1$ ...

# First

如果你是发现自己代码始终过不掉几个点于是来点题解的，给你的代码几个简单代码的 hack 数据：

```

input:
2 3
2 1

output:
8 12


input:
1 0
0

output:
1

input:
1 1
0

output:
0

input:
10 3
0 1 5 8 7 4 9 5 7 8

output:
0 0 0 1 15 99 386 1014 1968 3116


```

如果这些数据都能过的话...应该就稳了吧？（只要您别把数组开小咯【雾）


# Next

冷静分析...

多项式首项不为 1 ... 这 tm 怎么搞 Exp / Ln 啊...

emmm...

先考虑首项不为 0 的情况？

我们发现可以让所有的系数都除去首项系数，最后乘回首项系数的 k 次，这样子的结果是不会有问题的...

那如果首项是 0 呢？

咱可以把多项式左移，直到首项不为 0 了，那么就变回了首项不为 0 的情况。。。

但是别忘了要把最后的多项式右移回来，并且右移的位数要乘 k ...


最后就是套个板子的事情...


当然这道题貌似可以用真正意义上的多项式快速幂解决？（复杂度 $O(n\log^2n)$）【手动滑稽

听说有聚聚是这么 A 掉的，然鹅咱是人形大常数自走机...


# Code

```cpp
//by Judge
#include<cstdio>
#include<cstring>
#include<iostream>
#define fp(i,a,b) for(int i=(a),I=(b)+1;i<I;++i)
#define ll long long
using namespace std;
const int mod=998244353;
const int inv3=332748118;
const int M=4e5+3;
typedef int arr[M];
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline int mul(int x,int y){return 1ll*x*y%mod;}
inline int dec(int x,int y){return x-y<0?x-y+mod:x-y;}
inline int inc(int x,int y){return x+y>=mod?x+y-mod:x+y;}
inline int read(){ int x=0; char c=getchar(); for(;!isdigit(c);c=getchar());
	for(;isdigit(c);c=getchar()) x=x*10+c-48; return x;
} char sr[1<<21],z[20];int CC=-1,Z; inline void Ot(){fwrite(sr,1,CC+1,stdout),CC=-1;}
inline void print(int x,char chr=' '){ if(CC>1<<20)Ot();if(x<0)sr[++CC]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10); while(sr[++CC]=z[Z],--Z);sr[++CC]=chr;
} int n,k,limit,inv[M<<1]; arr A,B,C,D,F,G,f,g,h,r;
inline int qpow(int x,int p=mod-2){ int s=1;
	for(;p;p>>=1,x=mul(x,x)) if(p&1) s=mul(s,x); return s;
}
inline void NTT(int* a,int tp){
	fp(i,0,limit-1) if(i<r[i]) swap(a[i],a[r[i]]);
	for(int mid=1;mid<limit;mid<<=1){
		int Gn=qpow(tp?3:inv3,(mod-1)/(mid<<1));
		for(int j=0,x,y;j<limit;j+=mid<<1)
			for(int k=0,g=1;k<mid;++k,g=mul(g,Gn))
				x=a[j+k],y=mul(g,a[j+k+mid]),
				a[j+k]=inc(x,y),a[j+k+mid]=dec(x,y);
	} if(tp) return ; int INV=inv[limit];
	fp(i,0,limit-1) a[i]=mul(a[i],INV);
}
void Inv(int* a,int* b,int n){
	if(n==1) return b[0]=inv[a[0]],void();
	Inv(a,b,(n+1)>>1); int len=0;
	for(limit=1;limit<n<<1;limit<<=1) ++len;
	fp(i,0,limit-1) r[i]=(r[i>>1]>>1)|((i&1)<<(len-1));
	fp(i,0,n-1) C[i]=a[i],D[i]=b[i];
	fp(i,n,limit-1) C[i]=D[i]=0; NTT(C,1),NTT(D,1);
	fp(i,0,limit-1) C[i]=mul(C[i],mul(D[i],D[i])); NTT(C,0);
	fp(i,0,n-1) b[i]=dec(inc(b[i],b[i]),C[i]);
}
inline void Direv(int* a,int* b,int n){
	fp(i,1,n-1) b[i-1]=mul(a[i],i); b[n-1]=0;
}
inline void Inter(int* a,int* b,int n){
	fp(i,1,n-1) b[i]=mul(a[i-1],inv[i]); b[0]=0;
}
inline void Ln(int* a,int* b,int n){
	Direv(a,A,n),Inv(a,B,n); int len=0;
	for(limit=1;limit<n<<1;limit<<=1) ++len;
	fp(i,0,limit-1) r[i]=(r[i>>1]>>1)|((i&1)<<(len-1));
	NTT(A,1),NTT(B,1);
	fp(i,0,limit-1) A[i]=mul(A[i],B[i]);
	NTT(A,0),Inter(A,b,limit);
	memset(A,0,limit<<2);
	memset(B,0,limit<<2);
}
inline void Exp(int* a,int* b,int n){
	if(n==1) return b[0]=1,void();
	Exp(a,b,(n+1)>>1),Ln(b,F,n); int len=0;
	for(limit=1;limit<n<<1;limit<<=1) ++len;
	fp(i,0,limit-1) r[i]=(r[i>>1]>>1)|((i&1)<<(len-1));
	F[0]=dec(a[0]+1,F[0]);
	fp(i,1,n-1) F[i]=dec(a[i],F[i]); NTT(F,1),NTT(b,1);
	fp(i,0,limit-1) b[i]=mul(b[i],F[i]); NTT(b,0);
	fp(i,n,limit-1) b[i]=F[0]=0;
}
inline int Max(int x,int y){return x>y?x:y;}
inline int Min(int x,int y){return x<y?x:y;}
int main(){ n=read(),k=read(); fp(i,0,n-1) f[i]=read();
	if(k==0){ print(1); fp(i,1,n-1) print(0); return Ot(),0; }
	if(n==1&&f[0]==0) return !printf("0\n");
	int num=0; while(num<n&&!f[num]) ++num; int iv=qpow(f[num]);
	fp(i,0,n-num-1) f[i]=mul(f[i+num],iv); fp(i,n-num,n-1) f[i]=0;
	iv=qpow(qpow(iv),k),num=1ll*num*k>n?n:num*k;
	for(limit=1;limit<=n<<1;limit<<=1); inv[1]=1;
	fp(i,2,limit<<1) inv[i]=1ll*inv[mod%i]*(mod-mod/i)%mod;
	Ln(f,g,n); fp(i,0,n-1) g[i]=mul(g[i],k);
	Exp(g,h,n); fp(i,0,num-1) print(0);
	fp(i,num,n-1) print(mul(h[i-num],iv)); return Ot(),0;
}
```










---

## 作者：皎月半洒花 (赞：7)

似乎大家都是诡异的写法，没有人用$O(n\log^2 n)$去暴力艹这道题。

然而事实上是完全可以卡过去的。我的提交虽然加了`-O2`和`#pragma`~~显得十分弟弟~~，但是其实去掉之后也是很快的。不吹，绝对比大部分的普通$O(n\log^2n)$的NTT跑得快。

那么以下是几个优化的措施：

### $\#1$

预处理原根的次幂——卡常利器。

```cpp
for (i = 0 ; i < 19  ;++ i){
        rr int *rua = gg[i] ; rua[0] = 1 ;
        rr int gi = rua[1] = expow(3, 998244352/(1 << (i + 1))) ;
        for (j = 2 ; j < (1 << i) ; ++ j) rua[j] = 1ll * rua[j - 1] * gi % P ;
    }
```
然后每次NTT就不需要重新再计算了。

### $\#2$

做快速幂的时候注意可以少几次`NTT`。这点常数优化也是需要的。

```cpp
while (K){
        NTT(F, M, 1) ;
        if (K & 1){
            NTT(A, M, 1) ;
            for (i = 0 ; i < M ; ++ i) A[i] = 1ll * A[i] * F[i] % P ;
            NTT(A, M, -1) ; for (i = N ; i < M ; ++ i) A[i] = 0 ;
        }
        for (i = 0 ; i < M ; ++ i)
            F[i] = 1ll * F[i] * F[i] % P ; NTT(F, M, -1) ;
        for (i = N ; i < M ; ++ i) F[i] = 0 ; K >>= 1 ;
    }
```

### $\#3$

不用`long long`.

这其实一个通用的技巧，因为long long一般都比int多好多常数。同时不要强制类型转换而选择`1ll*`这种形式。实测可以快许多。

祝大家卡常顺利qwq

---

## 作者：nofind (赞：7)

## [题意](https://www.luogu.com.cn/problem/P5273)

似乎更新数据后现在的题解很多都过不了，我来写一份了，本人很蒟，出错请指出。

既然来做加强版了，说明普通的已经过了，就默认会$ln+exp$的做法了。

考虑这题和普通的有什么区别，即$a_0\not =1$，这个$a_0=1$是保证你$exp$时边界$b_0=1$的，我们考虑做一些操作，使得$a_0=1$。

首先将前面一段全是$0$的提出来，使得$a_0\not =0$，举个栗子：  
$0x^0+0x^1+1x^2+2x^3->2x^0+2x^1$。  
假设我们提出了$num$项，那么最后答案前$num*m$项都是$0$，之后就和新的多项式算出的相同，于是就不用管这段$0$了。

之后就好操作了，将多项式的系数整体乘个$a_0$的逆元，这样就满足$a_0=1$，算完后再整体乘上$a_0^m$即可。

注意事项：  
我们要存$3$个$m$：  
$m$是模$mod=998244353$的，和普通的用处相同。  
$m1$是模$mod-1$的，用于欧拉定理算$a_0^m$。  
$m2$是不模的，这是用来算最终答案前多少项为$0$的。当然这是存不下的，我们多存几位，如果$num*m2\geqslant n$可，我们全输出$0$即可。

code:
```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=4e5+10;
const int mod=998244353;
const int G=3;
const int invG=332748118;
int n,m,m1,m2;
int inv[maxn],f[maxn],g[maxn],h[maxn],A[maxn],B[maxn],C[maxn],D[maxn],pos[maxn];
inline int power(int x,int k)
{
    int res=1;
    while(k)
    {
        if(k&1)res=1ll*res*x%mod;
        x=1ll*x*x%mod;k>>=1;
    }
    return res;
}
inline void NTT(int* a,int op,int len)
{
    int lim=1,cnt=0;
    while(lim<len)lim<<=1,cnt++;
    for(int i=0;i<lim;i++)pos[i]=(pos[i>>1]>>1)|((i&1)<<(cnt-1));
    for(int i=0;i<lim;i++)if(i<pos[i])swap(a[i],a[pos[i]]);
    for(int l=1;l<lim;l<<=1)
    {
        int wn=power(op==1?G:invG,(mod-1)/(l<<1));
        for(int i=0;i<lim;i+=l<<1)
        {
            int w=1;
            for(int j=0;j<l;j++,w=1ll*w*wn%mod)
            {
                int x=a[i+j],y=1ll*w*a[i+l+j]%mod;
                a[i+j]=(x+y)%mod;a[i+l+j]=(x-y+mod)%mod;
            }
        }
    }
    if(op==1)return;
    int inv=power(lim,mod-2);
    for(int i=0;i<lim;i++)a[i]=1ll*a[i]*inv%mod;
}
inline void getinv(int* a,int* b,int len)
{
    if(len==1){b[0]=power(a[0],mod-2);return;}
    getinv(a,b,len>>1);
    for(int i=0;i<len;i++)D[i]=a[i];
    NTT(b,1,len<<1);NTT(D,1,len<<1);
    for(int i=0;i<(len<<1);i++)b[i]=1ll*b[i]*(2ll-1ll*b[i]*D[i]%mod+mod)%mod;
    NTT(b,-1,len<<1);
    for(int i=0;i<len;i++)D[i]=0;
    for(int i=len;i<(len<<1);i++)b[i]=D[i]=0;
}
inline void Direv(int* a,int* b,int len)
{
    for(int i=1;i<len;i++)b[i-1]=1ll*i*a[i]%mod;
    b[len-1]=0;
}
inline void Inter(int* a,int* b,int len)
{
    for(int i=1;i<len;i++)b[i]=1ll*a[i-1]*inv[i]%mod;
    b[0]=0;
}
void ln(int* a,int* b,int len)
{
    Direv(a,B,len);getinv(a,C,len);
    NTT(B,1,len<<1);NTT(C,1,len<<1);
    for(int i=0;i<(len<<1);i++)B[i]=1ll*B[i]*C[i]%mod;
    NTT(B,-1,len<<1);Inter(B,b,len<<1);
    for(int i=0;i<(len<<1);i++)B[i]=C[i]=0;
}
void exp(int* a,int* b,int len)
{
    if(len==1){b[0]=1;return;}
    exp(a,b,len>>1);ln(b,A,len);
    A[0]=(a[0]+1-A[0]+mod)%mod;
    for(int i=1;i<len;i++)A[i]=(a[i]-A[i]+mod)%mod;
    NTT(b,1,len<<1);NTT(A,1,len<<1);
    for(int i=0;i<(len<<1);i++)b[i]=1ll*b[i]*A[i]%mod;
    NTT(b,-1,len<<1);
    for(int i=len;i<(len<<1);i++)b[i]=A[i]=0;
}
int main()
{
	scanf("%d",&n);
    char c=getchar();c=getchar();
    while(c>='0'&&c<='9')
	{
		m=(1ll*m*10%mod+(c-'0'))%mod;
		m1=(1ll*m1*10%(mod-1)+(c-'0'))%(mod-1);
		if((ll)(m2*10+c-'0')<=mod)m2=m2*10+c-'0';
		c=getchar();
	}
	for(int i=0;i<n;i++)scanf("%d",&f[i]);
	int num=n;
	for(int i=0;i<n;i++)if(f[i]){num=i;break;}
	if(1ll*num*m2>=1ll*n)
	{
		for(int i=0;i<n;i++)printf("%d ",0);
		return 0;
	}
	int tmpn=n;n-=num;
	for(int i=0;i<n;i++)f[i]=f[i+num];
	int f0=f[0],invf0=power(f0,mod-2);
	for(int i=0;i<n;i++)f[i]=1ll*f[i]*invf0%mod;
	
	int lim=1;
	while(lim<n)lim<<=1;
	inv[1]=1;for(int i=2;i<lim;i++)inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
	ln(f,g,lim);
	for(int i=0;i<n;i++)g[i]=1ll*g[i]*m%mod;
	for(int i=n;i<lim;i++)g[i]=0;
	exp(g,h,lim);
	
	f0=power(f0,m1);
	for(int i=0;i<n;i++)h[i]=1ll*h[i]*f0%mod;
	
	n=tmpn;num=min(1ll*num*m2,1ll*n);
	for(int i=n-1;i>=num;i--)h[i]=h[i-num];
	for(int i=num-1;~i;i--)h[i]=0;
	
	for(int i=0;i<n;i++)printf("%d ",h[i]);
	return 0;
}
```


---

## 作者：wucstdio (赞：6)

## 题意

给定多项式$A(x)$，求一个多项式$B(x)$，满足

$$B(x)\equiv A^m(x)(\mathrm{mod\:}x^n)$$

## 题解

### 方法一：直接快速幂

既然数可以进行快速幂，那么多项式为什么就不行呢。

每次计算$A^2(x)$，然后将次数大于$n$的项全部变成$0$，进行倍增。时间复杂度$O(n\log^2 n)$（为什么不能先转点值表示最后再转回来？中间要对$x^n$取模啊）

代码也就比较无脑了：

```
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#define ll long long
using namespace std;
const ll MOD=998244353;
int limit,l,r[400005];
ll quick_pow(ll x,ll a)
{
	ll ans=1;
	while(a)
	{
		if(a&1)ans=ans*x%MOD;
		x=x*x%MOD;
		a>>=1;
	}
	return ans;
}
void NTT(ll*A,int type)//nlogn
{
	for(int i=0;i<limit;i++)
	  if(i<r[i])swap(A[i],A[r[i]]);
	for(int mid=1;mid<limit;mid<<=1)
	{
		ll Wn=type==1?quick_pow(3,(MOD-1)/(mid<<1)):quick_pow(3,MOD-1-(MOD-1)/(mid<<1));
		for(int R=mid<<1,j=0;j<limit;j+=R)
		{
			ll w=1;
			for(int k=0;k<mid;k++,w=w*Wn%MOD)
			{
				ll x=A[j+k],y=w*A[j+mid+k]%MOD;
				A[j+k]=(x+y)%MOD;
				A[j+mid+k]=(x-y+MOD)%MOD;
			}
		}
	}
	if(type==-1)
	{
		ll inv=quick_pow(limit,MOD-2);
		for(int i=0;i<limit;i++)A[i]=A[i]*inv%MOD;
	}
}
int n,m;
void quick_pow(ll*a,int k,ll*b)
{
	b[0]=1;
	limit=1,l=0;
	while(limit<(n<<1))limit<<=1,l++;
	for(int i=0;i<limit;i++)
	  r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));
	while(k)
	{
		NTT(a,1);
		if(k&1)
		{
			NTT(b,1);
			for(int i=0;i<limit;i++)b[i]=a[i]*b[i]%MOD;
			NTT(b,-1);
			for(int i=n;i<limit;i++)b[i]=0;
		}
		for(int i=0;i<limit;i++)a[i]=a[i]*a[i]%MOD;
		NTT(a,-1);
		for(int i=n;i<limit;i++)a[i]=0;
		k>>=1;
	}
}
ll a[400005],b[400005],c[400005];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=0;i<n;i++)scanf("%lld",&a[i]);
	quick_pow(a,m,b);
	for(int i=0;i<n;i++)printf("%lld ",b[i]);
	printf("\n");
	return 0;
}
```

### 方法2：多项式ln+多项式exp

预知识：多项式ln，多项式exp，如果不会的请左转[这里](https://www.luogu.org/problemnew/show/P4725)和[这里](https://www.luogu.org/problemnew/show/P4726)。

现在我们来尝试推一波式子。

会了多项式ln为什么不用呢，两边同时求对数：

$$\ln B(x)\equiv m\ln A(x)(\mathrm{mod\:}x^n)$$

所以我们只需要对$A$求一遍多项式ln，然后所有的系数乘$m$，最后求一遍多项式exp，就可以得到$B$。

其实就是[这道题](https://www.luogu.org/problemnew/show/P5245)啦。

但是我们发现，多项式ln要求$A_0=1$，但是这里的$A$不一定满足条件（废话，要不然怎么叫加强版呢）。

有一句古话：有条件要上，没有条件创造条件也要上。

当$A_0\neq 0$的时候，我们可以强行将$A_0$变成$1$：

$$A^k(x)=\left(\dfrac{A(x)}{A_0}\right)^k\cdot A_0^k$$

当$A_0=0$的时候，我们可以将这个多项式整体移位一下。令$k$是这个多项式第一个不为$0$的项，那么令$A_{i}=A_{k+i}$，最后再移回来就行了。

这样的时间复杂度是$O(n\log n)$，但是常数巨大。

方法二代码如下：

```
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#define ll long long
using namespace std;
const ll MOD=998244353;
int limit,l,r[400005];
ll ni[400005];
void calc_ni(int n)
{
	ni[1]=1;
	for(int i=2;i<=n;i++)
	  ni[i]=MOD-(MOD/i)*ni[MOD%i]%MOD;
}
ll quick_pow(ll x,ll a)
{
	ll ans=1;
	while(a)
	{
		if(a&1)ans=ans*x%MOD;
		x=x*x%MOD;
		a>>=1;
	}
	return ans;
}
void NTT(ll*A,int type)//nlogn
{
	for(int i=0;i<limit;i++)
	  if(i<r[i])swap(A[i],A[r[i]]);
	for(int mid=1;mid<limit;mid<<=1)
	{
		ll Wn=type==1?quick_pow(3,(MOD-1)/(mid<<1)):quick_pow(3,MOD-1-(MOD-1)/(mid<<1));
		for(int R=mid<<1,j=0;j<limit;j+=R)
		{
			ll w=1;
			for(int k=0;k<mid;k++,w=w*Wn%MOD)
			{
				ll x=A[j+k],y=w*A[j+mid+k]%MOD;
				A[j+k]=(x+y)%MOD;
				A[j+mid+k]=(x-y+MOD)%MOD;
			}
		}
	}
	if(type==-1)
	{
		ll inv=quick_pow(limit,MOD-2);
		for(int i=0;i<limit;i++)A[i]=A[i]*inv%MOD;
	}
}
ll A[400005];
void Inv(ll*a,ll*b,int n)//6nlogn
{
	if(n==1)
	{
		b[0]=quick_pow(a[0],MOD-2);
		return;
	}
	Inv(a,b,(n+1)>>1);
	limit=1,l=0;
	while(limit<(n<<1))limit<<=1,l++;
	for(int i=0;i<limit;i++)
	  r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));
	for(int i=0;i<limit;i++)A[i]=i<n?a[i]:0;
	for(int i=(n+1)>>1;i<limit;i++)b[i]=0;
	NTT(A,1);
	NTT(b,1);
	for(int i=0;i<limit;i++)
	  b[i]=b[i]*(2+MOD-A[i]*b[i]%MOD)%MOD;
	NTT(b,-1);
	for(int i=n;i<limit;i++)b[i]=0;
}
ll a2[400005];
void Ln(ll*a,ll*b,int n)//9nlogn
{
	Inv(a,b,n);
	limit=1,l=0;
	while(limit<(n<<1))limit<<=1,l++;
	for(int i=0;i<limit;i++)
	  r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));
	for(int i=0;i<n-1;i++)a2[i]=a[i+1]*(i+1)%MOD;
	for(int i=n-1;i<limit;i++)a2[i]=0;
	NTT(a2,1);
	NTT(b,1);
	for(int i=0;i<limit;i++)
	  b[i]=b[i]*a2[i]%MOD;
	NTT(b,-1);
	for(int i=n-1;i>0;i--)
	  b[i]=b[i-1]*ni[i]%MOD;
	for(int i=n;i<limit;i++)b[i]=0;
	b[0]=0;
}
ll lnb[400005];
void Exp(ll*a,ll*b,int n)//24nlogn
{
	if(n==1)
	{
		b[0]=1;
		return;
	}
	Exp(a,b,(n+1)>>1);
	Ln(b,lnb,n);
	limit=1,l=0;
	while(limit<(n<<1))limit<<=1,l++;
	for(int i=0;i<limit;i++)
	  r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));
	for(int i=0;i<n;i++)lnb[i]=a[i]>=lnb[i]?a[i]-lnb[i]:a[i]-lnb[i]+MOD;
	for(int i=n;i<limit;i++)lnb[i]=b[i]=0;
	lnb[0]++;
	NTT(lnb,1);
	NTT(b,1);
	for(int i=0;i<limit;i++)b[i]=b[i]*lnb[i]%MOD;
	NTT(b,-1);
	for(int i=n;i<limit;i++)b[i]=0;
}
int n,m;
ll num,a0,a[400005],b[400005],c[400005];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=0;i<n;i++)scanf("%lld",&a[i]);
	calc_ni(n);
	while(a[num]==0)num++;
	int x=n;
	n-=num;
	for(int i=0;i<n;i++)a[i]=a[i+num];
	a0=a[0];
	ll inv=quick_pow(a0,MOD-2);
	for(int i=0;i<n;i++)a[i]=a[i]*inv%MOD;
	Ln(a,b,n);
	for(int i=0;i<n;i++)b[i]=b[i]*m%MOD;
	Exp(b,a,n);
	a0=quick_pow(a0,m);
	for(int i=0;i<n;i++)a[i]=a[i]*a0%MOD;
	n=x;
	num=min(1ll*num*m,1ll*n);
	for(int i=n-1;i>=num;i--)
	  a[i]=a[i-num];
	for(int i=num-1;i>=0;i--)a[i]=0;
	for(int i=0;i<n;i++)printf("%lld ",a[i]);
	printf("\n");
	return 0;
}
```

## 两种方法的效率分析

当然是$O(n\log n)$吊打$O(n\log^2 n)$啦。

$O(n\log n)$做法吸氧4793ms，不吸氧慢一倍9573ms。

![](https://cdn.luogu.com.cn/upload/pic/55075.png)

$O(n\log^2 n)$做法嘛……

![](https://cdn.luogu.com.cn/upload/pic/55071.png)

我的$O(n\log^2 n)$做法无论吸氧还是不吸氧都是20分，但是你谷还是有卡常神仙@mrsrz 8000ms$O(n\log^2 n)$，orzorzorz……

![](https://cdn.luogu.com.cn/upload/pic/55079.png)

---

## 作者：Great_Influence (赞：6)

直接 [$\ln$](https://www.luogu.org/problemnew/show/P4725) 后系数乘 $k$ 再 [$\exp$](https://www.luogu.org/problemnew/show/P4726) 即可。

注意使用 $\ln$ 和 $\exp$ 的时候，会默认你的常数项为 $1$ 。但是有的时候并不满足这个条件，因此我们需要考虑整个多项式先除去常数项，计算完后再乘回去。

但是常数项可能没有???

这明显不是问题。我们只需要记一个最低项和他的系数(设为 $a_tx^t$) ，然后整个多项式除掉这个单项式(这个可以轻松做到 $O(1)$) 。在快速幂计算完毕后，我们再给整个式子乘上 $a_t^m x^{tm}$ 即可。

复杂度 $O(n\log n)$ (但是因为我的 $\exp$ 用分治 $FFT$ 求的其实是 $O(n\log^2n)$ , $O(n\log n)$ 的算法可能会因为常数问题更慢)。


有个很简单的卡常技巧。 可以发现我们求出来的式子的最后 $x^{tm}$ 项会是 $0$ ，因此我们只需要考虑后面的 $n-tm$ 项。做 $\ln$ 和 $\exp$ 的时候可以直接只做长度为 $n-tm$ 的。 这样会快很多。

核心代码:

```cpp
#define rep(i,a,b) for(int i = (a); i < (b); ++ i)
#define Rep(i,a,b) for(int i = (a); i <= (b); ++ i)
inline void write(int x, char ch = '\n');//快输
inline void Exp(int*u,int*v,int len);//exp
inline void Ln(int*u,int*v,int len);//ln
inline int power(int u,int v);//快速幂
inline void pow(int *F,int n,int k)
{
	int lst=n;
	rep(i,0,n)if(F[i]){lst=i;break;}
	if((ll)lst*m>=n)
	{
		Rep(i,1,n)write(0,' ');flush();
		return;
	}
	int md=n-m*lst,bs=F[lst],iv=power(bs,mod-2);
	rep(i,lst,n)F[i]=(ll)F[i]*iv%mod;
	Ln(F+lst,F,md);
	rep(i,0,md)F[i]=(ll)F[i]*m%mod;
	Exp(F,F,md);
	Rep(i,1,lst*m)write(0,' ');
	bs=power(bs,m);
	rep(i,0,md)write((ll)F[i]*bs%mod,' ');
	flush();
}
```

你也可以写一个快速幂，练习一下卡常。 这样的话复杂度为 $O(n\log n\log mod)$ 。

---

## 作者：Convergent_Series (赞：3)

若 $A(0)\ne 0$，则 $A(x)^k\equiv A(0)^k(\dfrac{A(x)}{A(0)})^k\equiv A(0)^k e^{\normalsize k\ln\frac{A(x)}{A(0)}}\pmod {x^{n+1}}$。

若 $\forall i\in[0,t),[x^i]A(x)=0(t>0)$，则 $A(x)^k\equiv(\dfrac{A(x)}{x^t})^kx^{tk}\pmod {x^{n+1}}$，先将 $A(x)$ 左移 $t$ 位，按 $A(0)\ne 0$ 时的方法计算后再右移 $tk$ 位即可。若 $tk>n$，直接全部赋值为 $0$。

但是此题中 $k$ 的范围过大，需要取模。令 $P=998244353$

$A(x)^k\equiv A(0)^k e^{\normalsize k\ln\frac{A(x)}{A(0)}}\equiv A(0)^{k\bmod (P-1)} e^{(k\bmod P)\normalsize\ln \frac{A(x)}{A(0)}}\pmod P$

注意：

1. 读入时要同时记录模 $P$ 和模 $P-1$ 下的值。
2. “若 $tk>n$，直接全部赋值为 $0$”中的 $k$ 不能取模。判断方法是：若 $t>0,\log_{10}k>5$，则 $tk>10^5\ge n$；若 $\log_{10}k\le5$，则 $k=k \bmod P$，可以直接判断。

### 代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define clr(f,n) memset(f,0,sizeof(int)*(n))
#define cpy(f,g,n) memcpy(f,g,sizeof(int)*(n))
#define bceil(n) (1<<(__lg(n-1)+1))
using namespace std;
int read(){
	int a=0;char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9') a=(a<<3)+(a<<1)+(ch^'0'),ch=getchar();
	return a;
} 
void write(int a){
	if(a>9) write(a/10); 
	putchar(a%10+'0');
}
const int MAXN=1e6+10,P=998244353,G=3,Gi=332748118;
int l,r[MAXN],inv[MAXN],sav[MAXN<<1];
ll qpow(ll a,ll b=P-2){
	if(a==1) return 1;
	ll ans=1;
	while(b){if(b&1) ans=ans*a%P;a=a*a%P;b>>=1;}
	return ans;
}
void tpre(int lim){
    if(l==lim) return;l=lim;
    for(int i=0;i<lim;i++) r[i]=(r[i>>1]>>1)|((i&1)?lim>>1:0);
}
void px(int *A,int *B,int n){for(int i=0;i<n;i++) A[i]=1ll*A[i]*B[i]%P;} 
void NTT(int *A,int lim,int type){
	tpre(lim);
	static ull f[MAXN<<1],w[MAXN];w[0]=1;
	for(int i=0;i<lim;i++) f[i]=(((ll)P<<5)+A[r[i]])%P;
	for(int mid=1;mid<lim;mid<<=1){
		ull Wn=qpow(type+1?G:Gi,(P-1)/(mid+mid));
		for(int i=1;i<mid;i++)w[i]=w[i-1]*Wn%P;
		for(int j=0;j<lim;j+=mid+mid){
			for(int k=0;k<mid;k++){
				int x=w[k]*f[j|mid|k]%P;
				f[j|mid|k]=f[j|k]+P-x;
				f[j|k]+=x;
			}   
		}if(mid==(1<<10)){for(int i=0;i<lim;i++) f[i]%=P;}
	}if(type-1){
		ull inv=qpow(lim);
		for(int i=0;i<lim;i++) A[i]=f[i]%P*inv%P;
	}else for(int i=0;i<lim;i++) A[i]=f[i]%P;
}
void mul(int *A,int *B,int la,int lb){//乘法 
	int lim=bceil(la+la);
	cpy(sav,B,lim);clr(sav+la,lim-la);
    NTT(A,lim,1);NTT(sav,lim,1);
    px(A,sav,lim);NTT(A,lim,-1);
    clr(A+lb,lim-lb);clr(sav,lim);
} 
void invp(int *A,int lim){//逆元 
	int n=bceil(lim);
	static int w[MAXN<<1],r[MAXN<<1];
	w[0]=qpow(A[0]);
	for (int ln=2;ln<=n;ln<<=1){
		for(int i=0;i<(ln>>1);i++) r[i]=w[i];
		cpy(sav,A,ln);NTT(sav,ln,1);NTT(r,ln,1);px(r,sav,ln);
		NTT(r,ln,-1);clr(r,ln>>1);cpy(sav,w,ln);NTT(sav,ln,1);
	    NTT(r,ln,1);px(r,sav,ln);NTT(r,ln,-1);
	    for(int i=ln>>1;i<ln;i++) w[i]=(w[i]*2ll-r[i]+P)%P;
	}cpy(A,w,lim);clr(sav,n);clr(w,n);clr(r,n);
}
void dao(int *A,int lim){//导数 
	for(int i=1;i<lim;i++) A[i-1]=1ll*A[i]*i%P;
	A[lim-1]=0;
}
void inv_init(int lim){
	inv[1]=1;
	for(int i=2;i<=lim;i++) inv[i]=1ll*inv[P%i]*(P-P/i)%P;
}
void jifen(int *A,int lim){//积分 
	for(int i=lim;i;i--) A[i]=1ll*A[i-1]*inv[i]%P;
	A[0]=0;
}
void lnp(int *A,int lim){//ln 
	static int w[MAXN<<1];
	cpy(w,A,lim);
	invp(w,lim);dao(A,lim);
	mul(A,w,lim,lim);
	jifen(A,lim-1);
	clr(w,lim);
}
void exp(int *A,int lim){//exp
	static int s[MAXN<<1],s2[MAXN<<1];
	int n=bceil(lim);
	s2[0]=1;
	for(int ln=2;ln<=n;ln<<=1){
		cpy(s,s2,ln>>1);lnp(s,ln);
		for(int i=0;i<ln;i++) s[i]=(A[i]-s[i]+P)%P;
		s[0]=(s[0]+1)%P;
		mul(s2,s,ln,ln);
	}cpy(A,s2,lim);clr(s,n);clr(s2,n);
}
void power(int *A,int lim,ll k,ll k_,ll len){
	int a,inv,t=0;
	while(A[t]==0) t++;a=qpow(A[t],k_);inv=qpow(A[t]);
	if(t!=0&&len>=6||t*k>lim){clr(A,lim);return;}
	for(int i=0;i+t<lim;i++) A[i]=1ll*A[i+t]*inv%P;
	lnp(A,lim);
	for(int i=0;i<lim;i++) A[i]=1ll*A[i]*k%P;
	exp(A,lim);
	for(int i=lim-1-t*k;i>=0;i--) A[i+t*k]=1ll*A[i]*a%P;
	clr(A,t*k);
}
int n,len,a[MAXN],b[MAXN];ll k,k_;
string str;
int main(){
    n=read();cin>>str;len=str.length();
    inv_init(n);
    for(int i=0;i<len;i++) k=((1ll*k*10%P)+str[i]-'0')%P;
    for(int i=0;i<len;i++) k_=((1ll*k_*10%(P-1))+str[i]-'0')%(P-1);
    for(int i=0;i<n;i++) a[i]=read();
    if(str=="0") clr(a,n),a[0]=1;
	else power(a,n,k,k_,len);
    for(int i=0;i<n;i++){write(a[i]);putchar(' ');} 
    return 0;
}
```

---

## 作者：teylnol_evteyl (赞：1)

前置知识：FFT，NTT，多项式求逆，多项式求对数，多项式求指数函数。

如果 $f_0=1$，直接求对数、系数乘 $k$、求指数即可，乘之后仍然对 $P$ 取模，因为与欧拉定理无关。

对于一般情况，把 $F$ 拆成 $x^st(F')$ 的形式使得 $f'_0=1$，此时有 $F^k=x^{sk}t^kF'^k$。

首先需要判断 $sk$ 与 $n$ 大小，如果 $sk$ 大于 $n$，则全为 $0$，否则将 $F'^k$ 的系数向后移动 $sk$。

并且求 $t^k$ 时，根据欧拉定理，指数对 $P-1$ 取模。

时间复杂度 $O(n\log n+\log k)$，需要 $33$ 次长度为 $2n$ 的 NTT。

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long LL;

const int N = 1 << 19 | 5, P = 998244353, G = 3;

int n, l;
char s[N];
LL a[N], inv[N];

inline void Read()
{
    scanf("%s", s);
    for(; s[l]; l ++ ) s[l] ^= 48;
}
inline LL Mod(LL P)
{
    LL res = 0;
    for(int i = 0; i < l; i ++ ) res = (res * 10 + s[i]) % P;
    return res;
}
inline LL Cmp(LL k)
{
    LL res = 0;
    for(int i = 0; i < l; i ++ )
    {
        res = res * 10 + s[i];
        if(res > k) return -1;
    }
    return res;
}

inline LL ksm(LL a, LL n)
{
    LL res = 1;
    while(n)
    {
        if(n & 1) res = res * a % P;
        a = a * a % P;
        n >>= 1;
    }
    return res;
}
inline void NTT(LL a[], int n, int ty)
{
    for(int i = 0, j = 0; i < n; i ++ )
    {
        if(i < j) a[i] ^= a[j] ^= a[i] ^= a[j];
        for(int k = (n >> 1); (j ^= k) < k; k >>= 1) ;
    }
    static LL w[N];
    w[0] = 1;
    for(int i = 1; i < n; i <<= 1)
    {
        LL wi = ksm(G, P - 1 + ty * (P - 1) / (i << 1));
        for(int j = i - 2; j >= 0; j -= 2)
        {
            w[j] = w[j >> 1];
            w[j | 1] = w[j] * wi % P;
        }
        for(int j = 0; j < n; j += (i << 1))
        {
            for(int k = j; k < j + i; k ++ )
            {
                LL t0 = a[k], t1 = a[k + i] * w[k - j] % P;
                (a[k] = t0 + t1) >= P && (a[k] -= P), (a[k + i] = t0 - t1 + P) >= P && (a[k + i] -= P);
            }
        }
    }
    if(ty == -1)
    {
        LL inv = ksm(n, P - 2);
        for(int i = 0; i < n; i ++ ) a[i] = a[i] * inv % P;
    }
}

inline void Inv(LL f[], LL g[], int m)
{
    static LL a[N], b[N];
    int k = 1;
    g[0] = ksm(f[0], P - 2), g[1] = 0;
    while(k < m)
    {
        k <<= 1;
        for(int i = 0; i < k; i ++ ) a[i] = f[i], b[i] = g[i];
        for(int i = k; i < k << 1; i ++ ) a[i] = b[i] = g[i] = 0;
        NTT(a, k << 1, 1), NTT(b, k << 1, 1);
        for(int i = 0; i < k << 1; i ++ ) g[i] = (2 - b[i] * a[i] % P + P) * b[i] % P;
        NTT(g, k << 1, -1);
        for(int i = k; i < k << 1; i ++ ) g[i] = 0;
    }
}
inline void Ln(LL f[], LL g[], int m)
{
    static LL a[N];
    Inv(f, a, m);
    for(int i = 0; i < m; i ++ ) g[i] = f[i + 1] * (i + 1) % P;
    int k = 1;
    while(k < (m << 1)) k <<= 1;
    NTT(g, k, 1), NTT(a, k, 1);
    for(int i = 0; i < k; i ++ ) g[i] = g[i] * a[i] % P;
    NTT(g, k, -1);
    for(int i = m - 1; i > 0; i -- ) g[i] = g[i - 1] * inv[i] % P;
    g[0] = 0;
}
inline void Exp(LL f[], LL g[], int m)
{
    static LL a[N];
    g[0] = 1;
    int k = 1;
    while(k < m)
    {
        k <<= 1;
        Ln(g, a, k);
        for(int i = 0; i < k; i ++ )(a[i] = f[i] - a[i] + P) >= P && (a[i] -= P);
        a[0] ++ ;
        for(int i = k; i < k << 1; i ++ ) a[i] = 0;
        NTT(a, k << 1, 1), NTT(g, k << 1, 1);
        for(int i = 0; i < k << 1; i ++ ) g[i] = g[i] * a[i] % P;
        NTT(g, k << 1, -1);
        for(int i = k; i < k << 1; i ++ ) g[i] = 0;
        // for(int i = 0; i < k; i ++ ) printf("%lld ", g[i]);
        // puts("");
    }
}
inline void Power1(LL f[], int m)
{
    static LL a[N];
    while(m != (m & -m)) m ++ ;
    Ln(f, a, m);
    LL t = Mod(P);
    for(int i = 0; i < m; i ++ ) a[i] = a[i] * t % P;
    for(int i = 0; i < m; i ++ ) f[i] = 0;
    Exp(a, f, m);
}
inline void Power(LL f[], int m)
{
    int s = 0;
    while(!f[s]) s ++ ;
    LL t = f[s], invt = ksm(t, P - 2);
    for(int i = s; i < m; i ++ ) f[i] = f[i] * invt % P;
    Power1(f + s, m - s);
    t = ksm(t, Mod(P - 1));
    for(int i = s; i < m; i ++ ) f[i] = f[i] * t % P;
    if(s)
    {
        LL d = Cmp(m / s);
        if(d == -1)
        {
            for(int i = 0; i < m; i ++ ) f[i] = 0;
        }
        else
        {
            d = (d - 1) * s;
            for(int i = m - 1; i >= d; i -- ) f[i] = f[i - d];
            for(int i = 0; i < d; i ++ ) f[i] = 0;
        }
    }
}

int main()
{
    scanf("%d", &n), Read();
    for(int i = 0; i < n; i ++ ) scanf("%lld", &a[i]);
    inv[1] = 1;
    for(int i = 2; i < n; i ++ ) inv[i] = inv[P % i] * (P - P / i) % P;
    Power(a, n);
    for(int i = 0; i < n; i ++ ) printf("%lld ", a[i]);
    puts("");
    return 0;
}
```

---

## 作者：7FA5 (赞：0)

# 题解

## Part1 普通版

考虑求多项式 $g(x)\equiv f^k(x)$

等式两边同取 $\ln$

$\ln g(x)\equiv k\ln f(x)$

求完 $\ln f(x)$ 再 $\exp$ 回来

## Part2 加强版

对于一个多项式能够 $\ln$，当且仅当常数项为 $1$

然而本题没有这个性质

事实上可以令 $f(x)=dx^nf_0(x)$，满足 $f_0$ 常数项为 $1$

则 $f^k(n)=d^kx^{nk}f_0^k(x)$

---


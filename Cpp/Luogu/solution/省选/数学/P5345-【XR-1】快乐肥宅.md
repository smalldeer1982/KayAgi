# 【XR-1】快乐肥宅

## 题目背景

小粉兔的机房里面有 $n$ 个快乐肥宅，但小粉兔自己并不是，他看着这些快乐肥宅，非常羡慕，于是他想研究一下这些快乐肥宅的体重。

## 题目描述

每个快乐肥宅第 $0$ 天的体重都等于 $1$。第 $i$ 个快乐肥宅的体重记作 $w_i$，则一开始 $w_i = 1$。

第 $i$ 个快乐肥宅有一个专属的快乐指数 $k_i$，这表示他每天刚起床后，体重会是上一天的体重的 $k_i$ 倍。

肥宅们是有觉悟的，第 $i$ 个肥宅有一个专属的觉醒体重 $g_i$，这表示一旦他的体重**大于** $g_i$，他就会去健身房健身，每次减掉自己 $g_i$ 的体重，直到体重小于等于 $g_i$。

健身后，肥宅们会在机房见面，他们发现有时各自的体重会变得很有趣。

有一天，肥宅们发现各自的体重形成了等差数列！

另一天，肥宅们发现各自的体重形成了等比数列！

肥宅们心想，如果 $n$ 个快乐肥宅的体重 $\{w_1, w_2, \ldots, w_n\}$ 恰好形成序列 $\{r_1, r_2, \ldots, r_n\}$，至少需要经过多少天呢？

不过如果肥宅们等了很久都没有等到这一天，他们会认为这是不可能的。

## 说明/提示

【样例 $1$ 说明】

下表是两个肥宅在第 $0$ 天至第 $7$ 天时的体重变化表：

| 天数 | 肥宅 $1$ 的体重 | 肥宅 $2$ 的体重 | 解释 |
| :--: | :--: | :--: | :--: |
| $0$ | $1$ | $1$ | 第 $0$ 天每个肥宅的体重都是 $1$ |
| $1$ | $4$ | $2$ | 肥宅 $1$ 的体重是上一天的 $4$ 倍，肥宅 $2$ 的体重是上一天的 $2$ 倍 |
| $2$ | $2$ | $4$ | 肥宅 $1$ 的体重是上一天的 $4$ 倍，为 $16$，他发现自己的体重超过了 $7$，于是去了两次健身房，把体重减少了 $2\times 7=14$ |
| $3$ | $1$ | $3$ | 这一天肥宅 $1$ 和肥宅 $2$ 都去了一次健身房 |
| $4$ | $4$ | $1$ | 肥宅 $2$ 去了一次健身房 |
| $5$ | $2$ | $2$ | 肥宅 $1$ 去了两次健身房 |
| $6$ | $1$ | $4$ | 肥宅 $1$ 去了一次健身房 |
| $7$ | $4$ | $3$ | 肥宅 $2$ 去了一次健身房 |

可以看出在第 $7$ 天时肥宅的体重形成了序列 $\{4, 3\}$。

【数据规模与约定】

Subtask 1（20 points）：$n \le 50$，$g_i \le 50$。  
Subtask 2（20 points）：$g_i$ 为质数。  
Subtask 3（20 points）：$g_i \le 10^3$。  
Subtask 4（20 points）：$r_i \in \{1, g_i\}$。  
Subtask 5（20 points）：无特殊限制。

对于 $100\%$ 的数据，$1 \le n \le 10^3$，$1 \le k_i, r_i \le g_i \le 10^7$。

## 样例 #1

### 输入

```
2
4 7 4
2 5 3```

### 输出

```
7```

## 样例 #2

### 输入

```
2
4 7 3
2 5 3```

### 输出

```
Impossible```

## 样例 #3

### 输入

```
2
4 7 1
2 5 1```

### 输出

```
0```

## 样例 #4

### 输入

```
3
14 60 44
6 50 6
1029 91287 87318```

### 输出

```
101```

## 样例 #5

### 输入

```
1
6 65536 65536```

### 输出

```
16```

## 样例 #6

### 输入

```
2
2 2 2
2 3 1
```

### 输出

```
2
```

# 题解

## 作者：小粉兔 (赞：39)

在博客园食用更佳：[https://www.cnblogs.com/PinkRabbit/p/LuoguP5345.html](https://www.cnblogs.com/PinkRabbit/p/LuoguP5345.html)。

很荣幸为 [X Round 1](https://www.luogu.org/contestnew/show/16551) 贡献了自己的一题。

### 题意简述：

给定 $n$ 组 $k_i,g_i,r_i$（$0\le k_i,r_i<g_i\le 10^7$）。

求关于 $x$ 的方程组 $\left\{\begin{matrix}k_1^x\equiv r_1\pmod{g_1}\\k_2^x\equiv r_2\pmod{g_2}\\\vdots\\k_n^x\equiv r_n\pmod{g_n}\end{matrix}\right.$（定义 $0^0=1$）在 $[0,10^9]$ 内的最小整数解，或判断在这个范围内无解。

### 题解：

分为两个部分解决。

#### 第一部分：分别求出每个方程的解。

首先观察 $k^j\bmod g$ 的规律，以 $g=495616$，$k=124$ 为例：

定义 $f(i)=ki\bmod g$，则把每个在 $[0,g)$ 之间的整数看作一个节点后，形成了一个基环内向森林。

从 $1\bmod g$ 开始走唯一的出边，必然形成一个 $\rho$ 形结构，让我们模拟这个过程：

![](https://cdn.luogu.com.cn/upload/pic/58118.png)

可以看到，出现了长度为 $5$ 的循环。

1. 如果 $r=245760$，则 $x\equiv 7\pmod{5}$，且 $x\ge 7$。

2. 如果 $r=12544$，则 $x=4$。

3. 如果 $r=2$，则无解。

以上就是每个方程的 $3$ 种解，无限解，唯一解或无解。

那么，问题就是，如何区分这 $3$ 种解，以及如何求出解。

首先，需要将 $\rho$ 形的“尾巴”和循环分开考虑，不难证明“尾巴”的长度不超过 $\log_2g$。

而且可以发现，若在“尾巴”上找到了解，那么就只有一组解。所以需要判断一个值是否在尾巴上。

其实这是很简单的，如果 $\gcd(x,m)\neq\gcd(f(x),m)$，那么 $x$ 就在尾巴上，反之就在循环内。

据此，我们区分了在“尾巴”上的解，也就是只有一组解的情况，接下来考虑不在“尾巴”上的情况。

因为解不在“尾巴”上，则如果解不在循环内就是无解了，所以首先判断解是否在循环内。

假设第一个在循环上的数为 $c$，尾巴长度为 $o$，则有 $c\equiv k^o\pmod{g}$。

令 $d=\gcd(c,g)$，则原方程 $k^x\equiv r\pmod{g}$ 可化为 $c\cdot k^{x-o}\equiv r\pmod{g}$ 且 $x\ge o$，这是因为我们假定解一定在循环内。

可以进一步化为 $k^{x-o}\equiv\frac{r}{d}\left(\frac{c}{d}\right)^{-1}\pmod{\frac{g}{d}}$，若 $r$ 不是 $d$ 的倍数则无解。

这是因为循环内的值均是 $d$ 的倍数，可以让方程同除 $d$，又因为 $\frac{c}{d}\perp\frac{g}{d}$，可以取逆元。

令 $a=k,b=\frac{r}{d}\left(\frac{c}{d}\right)^{-1},m=\frac{g}{d}$，则有 $a\perp m$。

使用 BSGS 求出 $a^y\equiv b\pmod{m}$ 的最小自然数解 $y$ 后，有原方程的最小自然数解为 $y+o$。

再使用 BSGS 求出 $a^z\equiv 1\pmod{m}$ 的最小正整数解 $z$，即 $a$ 对 $m$ 的阶。

则原方程的解为 $x\equiv y+o\pmod{z}$ 且 $x\ge y+o$。

至此，第一部分解决。

#### 第二部分：合并每个方程的解。

首先，若前面的方程出现了无解的情况，则方程组也无解。

若前面的方程出现了只有唯一解的情况，只需要检查此唯一解是否满足所有方程即可。

接下来讨论以上每个方程的解均形如 $x\equiv r\pmod{q}$ 且 $x\ge r$ 的形式。

分开考虑前半部分和后半部分，对于前半部分，显然是 ExCRT 的形式。

对于后半部分，可以化为 $x\ge\max r_i$，令 $\max r_i=x_0$，放到最后考虑。

考虑使用 ExCRT 解决前半部分，令前 $i$ 个方程组的解为 $x\equiv P_i\pmod{Q_i}$，有 $P_0=0,Q_0=1$。

但是这里出现一个问题，那就是 $P_i,Q_i$ 可能很大，但是这里其实没必要使用高精度，要怎么处理这种情况呢？

因为以上方程的解 $x\equiv r\pmod{q}$ 中，$q$ 均小于 $10^7$，所以不需要担心这部分。

考虑这样一种情况：$Q_{i-1}>10^9$，而再合并进 $x\equiv r_i\pmod{q_i}$ 可能会让 $Q_i$ 超出 `long long` 能够表示的范围。

这时其实不需要再合并了，只需要判断 $P_{i-1}$ 是否满足第 $i$ 个方程即可。因为若不满足，合并后 $x$ 必然会至少增加一倍的 $Q_{i-1}$，这就超出了 $10^9$ 的范围，从而可以直接输出无解。

最后，当方程成功合并完之后，$Q_n$ 可能不是真实值，但是当 $Q_n\le 10^9$ 时必然是真实值。

此时可以再考虑 $x_0$，真实的解应该为 $x=\left\lceil\frac{x_0-P_n}{Q_n}\right\rceil\cdot Q_n+P_n$。

若 $Q_n> 10^9$，则必然要满足 $P_n\ge x_0$，否则无解。

据此写出代码，复杂度 $\mathcal{O}\left(\sum_{i=1}^{n}\left(\sqrt{g_i}+\log g_i\right)\right)$：

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>

#define Fail return puts("Impossible"), 0
#define mp std::make_pair

typedef long long LL;
typedef std::pair<int, int> pii;
const int MG = 10000005, MS = 3175;
const int U = 1e9;

int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }

template<typename T>
T exgcd(T a, T b, T &x, T &y) {
	if (!b) return x = 1, y = 0, a;
	int d = exgcd(b, a % b, y, x);
	return y -= a / b * x, d;
}

int buk[MG], stk[MS];
inline int BSGS(int a, int b, int m) {
	int S = sqrt(m - 1) + 1;
	int A = 1, f = -1, t = 0;
	for (int i = 0; i < S; ++i) {
		buk[stk[++t] = (LL)b * A % m] = i;
		A = (LL)A * a % m;
	}
	int C = 1;
	for (int i = 1; !~f &&  i <= S; ++i)
		if (~buk[C = (LL)C * A % m])
			f = i * S - buk[C];
	while (t) buk[stk[t--]] = -1;
	return f;
}

inline pii ExBSGS(int a, int b, int m) {
	int o = 0, A = 1 % m, d = 1, nd, x, y;
	while (1) {
		if (d == (nd = gcd((LL)A * a % m, m))) break;
		if (A == b) return mp(o, -1);
		++o, A = (LL)A * a % m, d = nd;
	}
	if (b % d) return mp(-1, -1);
	m /= d, b /= d, A /= d;
	exgcd(A, m, x, y);
	b = (LL)b * (x + m) % m;
	x = BSGS(a, b, m);
	if (!~x) return mp(-1, -1);
	y = BSGS(a, 1 % m, m);
	return mp(x % y + o, y);
}

inline bool Combine(LL &a1, LL &m1, LL a2, LL m2) {
	LL k1, k2, g = exgcd(m1, m2, k1, k2);
	if ((a2 - a1) % g) return 0;
	a1 += (k1 * ((a2 - a1) / g) % m2 + m2) * m1 % (m1 / g * m2);
	return a1 %= m1 *= m2 / g, 1;
}

const int MN = 1005;

int N;
int k[MN], r[MN], g[MN];
int x[MN], q[MN], X, MaxX;

int main() {
	memset(buk, -1, sizeof buk), X = -1;
	scanf("%d", &N);
	for (int i = 1; i <= N; ++i) {
		scanf("%d%d%d", &k[i], &g[i], &r[i]);
		pii ans = ExBSGS(k[i] % g[i], r[i] % g[i], g[i]);
		x[i] = ans.first, q[i] = ans.second;
		if (!~x[i]) Fail;
		if (!~q[i]) X = x[i];
		MaxX = std::max(MaxX, x[i]);
	}
	if (~X) {
		for (int i = 1; i <= N; ++i) {
			if (~q[i] && (X < x[i] || (X - x[i]) % q[i])) Fail;
			if (!~q[i] && X != x[i]) Fail;
		}
		return printf("%d\n", X), 0;
	}
	LL P = 0, Q = 1;
	for (int i = 1; i <= N; ++i) {
		if (Q > U && (P - x[i]) % q[i]) Fail;
		if (Q <= U && !Combine(P, Q, x[i] % q[i], q[i])) Fail;
	}
	if (P < MaxX) P += ((MaxX - P - 1) / Q + 1) * Q;
	if (P > U) Fail;
	printf("%lld\n", P);
	return 0;
}
```

---

## 作者：lingfunny (赞：5)

## 题解

对于每个肥宅 $i$ 考虑，第 $m$ 天的体重显然应该是 $k_i^m\bmod g_i$，对于目标体重 $r_i$，会得到如下式子：
$$
k_i^x\equiv r_i\pmod{g_i}
$$
换个显然的形式：
$$
a^x\equiv b\pmod{p}
$$
注意到这里 $p$ 不是质数，显然是一个 exBSGS 可以求解的问题。

然而只有一个特解 $u$ 并不能解决「有多个肥宅，求至少需要经过的天数」这样的问题，我们需要找出它的通解。

假设现在用 exBSGS 求出了一个特解 $u$，设再过 $d$ 天又能符合条件。

显然这个 $d$ 就是满足 $a^{u+d}\equiv a^u\pmod{p}$ 的最小正整数解。

看起来是要求 $a^d\equiv1\pmod{p}$ 的最小正整数解。

这里已经非常显然了，根据[**阶**](http://oi-wiki.com/math/number-theory/primitive-root/#_2)有关的知识，其实就是求 $\delta_p(a)$。

求阶的方式也很简单：

- 若 $\gcd(a,p)>1$ 时无解，此时原同余方程只有一个特解 $u$。
- 否则有 $a^{\varphi(p)}\equiv1\pmod{p}$，必有 $\delta_p(a)\mid\varphi(p)$，对 $\varphi(p)$ 不断试除质因子即可得到 $\delta_p(a)$。原同余方程的通解为 $x\equiv u\pmod{\delta_p(a)}$。

当你迫不及待地求出阶后，便开心地发现自己在样例 #4（$a=14,b=44,p=60$）WA 了。

实际上要求的并不是 $\delta_p(a)$。

看下原目标：$a^{u+d}\equiv a^u\pmod{p}$，即 $a^db\equiv b\pmod{p}$。

此处并没有说 $b\perp p$，$b^{-1}$ 可能并不存在，所以不能直接消掉 $b$。

也挺好解决的，记 $t=\gcd(p,b),p'=\frac{p}{t}$，有$a^d\times\frac{b}{t}\equiv\frac{b}{t}\pmod{p'}$，此时 $\frac{b}{t}\perp p'$，可以直接消掉。

所以要求的应该是 $\delta_{p'}(a)$。

现在变成了求阶线性同余方程组了（$g_i'=\frac{g_i}{\gcd(g_i,r_i)}$，应该挺显然的）：
$$
\begin{cases}
x&\equiv& u_1\pmod{\delta_{g_1'}(k_1)}\\
x&\equiv& u_2\pmod{\delta_{g_2'}(k_2)}\\
&\vdots&\\
x&\equiv& u_n\pmod{\delta_{g_n'}(k_n)}
\end{cases}
$$
此处显然也不保证模数互质，需要使用 exCRT。

当你迫不及待地求出答案后，发现自己又听取 WA 声一片：

![image.png](https://s2.loli.net/2022/02/24/sxBA2MmtRCHqDiX.png)

**正确操作**：当发现要做 CRT 之后，第一时间观察 $g_i$ 的 $\operatorname{lcm}$ 性质。发现，没有性质。~~上高精~~

合并 $\operatorname{lcm}$ 是做不了了，考虑什么情况下可以不合并。

如果求出了某个答案 $x$，发现它能符合所有的同余方程，这时候显然没有必要去取 $\operatorname{lcm}$ 了。

假设前 $k$ 个同余方程解出的答案是 $x\equiv ans\pmod{M}$（$M>10^9$），我们考虑直接尝试 $A$ 能否符合第 $k+1$ 个方程。如果不行的话，显然要合并。

看下如果要合并，exCRT 老师会发生甚么事（代码来自 [exCRT 模板](https://www.luogu.com.cn/problem/P4777)的某篇[题解](https://www.luogu.com.cn/blog/_post/52490)）：

![image.png](https://s2.loli.net/2022/02/24/uIlmdZsrhoOSCcy.png)

`ans += x*M`！答案直接加上若干个 $M$，显然是超过 $10^9$ 范围了，此时可以直接返回无解。

当然，和屠龙勇士类似，本题的最终答案一定要大于 $\max\{u_i\}$，最后需要加一下。

## CODE

```cpp
// Problem: P5345 【XR-1】快乐肥宅
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P5345
// Time: 2022-02-23 21:22
// Memory Limit: 256 MB
// Time Limit: 1000 ms
// Author: lingfunny
// 
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h>
#define LL long long
using namespace std;
const int mxn = 1e3+10, inf = 1e9;

int n, a[mxn], p[mxn], b[mxn];
LL legal[mxn], m[mxn], mx, A, M;
inline int mul(int x, int y, int mod) { return (LL)x*y%mod; }
inline int qpow(int x, int k, int mod) {
	int res = 1;
	x %= mod;
	while(k) {
		if(k&1) res = mul(res, x, mod);
		x = mul(x, x, mod);
		k >>= 1;
	}
	return res;
}

namespace PHI {
	inline int phi(int x) {
		int res = 1;
		for(int i = 2; i * i <= x; ++i) if(x % i == 0){
			int p = 1;
			x /= i;
			while(x % i == 0) p *= i, x /= i;
			res *= p*(i-1);
		}
		if(x != 1) res *= x-1;
		return res;
	}
};

namespace BSGS {
	using namespace PHI;
	int p;
	inline int mul(int x, int y) { return (LL)x*y%p; }
	inline int qpow(int x, int k) {
		int res = 1;
		x %= p;
		while(k) {
			if(k&1) res = mul(res, x);
			x = mul(x, x);
			k >>= 1;
		}
		return res;
	}
	inline int BSGS(int a, int b) {
		a %= p; b %= p;
		if(b == 1) return 0;
		if(p == 1) return a?0:1;
		int S = ceil(sqrt(p)), aps = 1, left;
		map <int, int> mp;
		// 不要问我为什么 BSGS 用 map
		// 不要问我为什么 BSGS 用 map
		// 不要问我为什么 BSGS 用 map
		for(int i = 0; i <= S; ++i) {
			mp[mul(aps, b)] = i;
			if(i != S) aps = mul(aps, a);
		}
		left = aps;
		for(int i = 1; i <= S; ++i) {
			if(mp.find(left) != mp.end()) return i*S-mp[left];
			left = mul(left, aps);
		}
		return -1;
	}
	inline int exBSGS(int a, int b, int P) {
		p = P;
		a %= P; b %= P;
		if(b == 1 || P == 1) return 0;
		int d, k = 0, dlt = 1;
		while((d = __gcd(a, p)) > 1) {
			if(b%d) return -1;
			b /= d;
			p /= d;
			dlt = mul(dlt, a/d);
			++k;
			if(b == dlt) return k;
		}
		int res = BSGS(a, mul(b, qpow(dlt, phi(p)-1)));
		return res<0?-1:res+k;
	}
};

namespace JIE {
	using namespace PHI;
	inline int GET(int m, int a) {
		a %= m;
		if(__gcd(m, a) > 1) return -1;
		if(a == 1) return 1;
		int res = phi(m), num = phi(m);
		for(int i = 2; i * i <= num; ++i) if(num % i == 0) {
			while(num % i == 0 && qpow(a, res/i, m) == 1) res /= i, num /= i;
			while(num % i == 0) num /= i;
		}
		if(num > 1 && qpow(a, res/num, m) == 1) res /= num;
		return res;
	}
	inline int findm(int a, int b, int p) {
		int d = __gcd(b, p);
		p /= d;
		if(__gcd(a, p) > 1) return 1e9+7;
		return GET(p, a);
	}
};
namespace CRT {
	void exgcd(LL a, LL b, LL& x, LL& y) {
		if(!b) return x = 1, y = 0, void();
		exgcd(b, a%b, y, x); y -= a/b*x;
	}
	inline bool merge(LL& a1, LL& p1, LL a2, LL p2) {
		// printf("a1 = %lld, p1 = %lld, a2 = %lld, p2 = %lld\n", a1, p1, a2, p2);
		LL k1, k2, C = ((a2-a1)%p2+p2)%p2, D = __gcd(p1, p2);
		// printf("C = %lld, D = %lld\n", C, D);
		if(C % D) return false;
		exgcd(p1, p2, k1, k2);
		// printf("k1 = %lld\n", k1);
		k1 = (k1%p2+p2)%p2;
		a1 += (k1 * (C/D) % p2) * p1 % (p2 / D * p1);
		p1*=p2/D;
		a1 %= p1;
		return true;
	}
}

signed main() {
	// int k = 1;
	// for(int i = 0; i <= 10000; ++i, k = mul(k, 14, 60)) printf("i = %d, %d = 1 (mod 60)\n", i, k);
	scanf("%d", &n);
	for(int i = 1; i <= n; ++i) scanf("%d%d%d", &a[i], &p[i], &b[i]);
	for(int i = 1; i <= n; ++i) {
		legal[i] = BSGS::exBSGS(a[i], b[i], p[i]);
		mx = max(mx, legal[i]);
		// printf("legal[%d] = %lld\n", i, legal[i]);
		// if(qpow(a[i]%p[i], legal[i], p[i]) != b[i]%p[i]) puts("What the fuck!?");
		if(legal[i] < 0) {
			puts("Impossible");
			return 0;
		}

		m[i] = JIE::findm(a[i], b[i], p[i]);
		// int oth = 1, delta = 1;
		// for(; ; ++oth) if(mul(delta = mul(delta, a[i], p[i]), b[i], p[i]) == b[i]%p[i]) break;
		// if(oth != m[i]) puts("What the fuck");
		// printf("m[%d] = %lld\n", i, m[i]);
	}
	A = 0, M = 1;
	for(int i = 1; i <= n; ++i) {
		if(M <= inf) {
			if(!CRT::merge(A, M, legal[i], m[i])) {
				puts("Impossible");
				return 0;
			}
		} else {
			if(A%m[i] != legal[i]%m[i]) {
				puts("Impossible");
				return 0;
			}
		}
	}
	// printf("mx = %lld, A = %lld\n", mx, A);
	if(A < mx) A += (mx-A+M-1)/M*M;
	if(A > inf) puts("Impossible");
	else printf("%lld\n", A);
	return 0;
}
```

---

## 作者：zhylj (赞：4)

一个复杂度较劣的做法。

考虑记 $M=10^9$，我们希望求得 $x\in[0,M]$ 中最小的 $x$，使得 $\forall i\in[1,n]$，有 $k_i^x\equiv r_i\pmod {g_i}$。

注意到如果我们单独求 BSGS，要合并答案是较为困难的，于是考虑对整个序列一起做 BSGS。定义序列的乘法为对应项相乘后每项模 $g_i$，则要解方程 $k^x=r$，但我们并不需要考虑所有可能的解，只需考虑 $x\le M$ 的情况，于是我们只需要对这个区间进行分块，直接记 $B=\left\lfloor\sqrt {M}\right\rfloor$，那么类似一般的 BSGS，我们令 $x=aB+c\ (0\le c\lt B)$ 则 $k^{aB+c} = r\implies k^c=rk^{-aB}$。

于是可以枚举 $c\in[0,B)$ 预处理出 $k^c$，然后存入 Hash 表 / Trie 树，枚举所有 $a$，计算出 $rk^{-aB}$ 的 Hash 值，然后查一下表就好了。

需要注意的是，由于此时可能 $k^{-aB}$ 是不存在的，所以我们仍然需要做一个类似 exBSGS 的操作，更具体地，对于一个固定的 $K = \left\lfloor\log_2 \max g_i\right\rfloor$，我们假设求解的答案即为所有 $x\gt K$，那么我们就可以把每个 $k_i^K$ 和 $g_i$ 提公因子消成 $k_i,g_i$ 互质，然后逆元就都存在了。

时间复杂度 $\mathcal O(n\sqrt M)$。

```cpp
typedef long long ll;
typedef unsigned long long ull;

const int N = 5e5 + 5, P = 19260817, M = 1e9, K = 35;

int Exgcd(int a, int b, int &x, int &y) {
	if(!b) return x = 1, y = 0, a;
	int g = Exgcd(b, a % b, y, x);
	y -= a / b * x;
	return g;
}
int Inv(int a, int p) { int x, y; Exgcd(a, p, x, y); return (x % p + p) % p; }
int Gcd(int a, int b) { return b ? Gcd(b, a % b) : a; }

int n, B = sqrt(M), k[N], g[N], r[N], w[N], p[N];
std::unordered_map <ull, int> s;
ull Hash(int a[]) {
	ull res = 0;
	for(int i = 1; i <= n; ++i)
		res = 1ULL * res * P + a[p[i]];
	return res;
}

void Answer(int x) {
	if(x >= 0 && x <= M) printf("%d\n", x);
	else printf("Impossible\n");
	exit(0);
}

int main() {
	srand(time(0));
	rd(n);
	for(int i = 1; i <= n; ++i) p[i] = i;
	std::random_shuffle(p + 1, p + n + 1);
	for(int i = 1; i <= n; ++i) {
		rd(k[i], g[i], r[i]);
		k[i] %= g[i]; r[i] %= g[i];
		w[i] = 1 % g[i];
	}
	ull t = Hash(r);
	for(int i = 0; i < K; ++i) {
		ull cur = Hash(w);
		if(cur == t) Answer(i);
		for(int j = 1; j <= n; ++j)
			w[j] = 1LL * w[j] * k[j] % g[j];
	}
	for(int i = 0; i < K; ++i)
		for(int j = 1; j <= n; ++j) {
			int d = Gcd(k[j], g[j]);
			if(r[j] % d != 0) Answer(-1);
			g[j] /= d; r[j] /= d;
			r[j] = 1LL * r[j] * Inv(k[j] / d, g[j]) % g[j];
		}
	for(int i = 1; i <= n; ++i) w[i] = 1 % g[i];
	for(int i = 0; i < B; ++i) {
		ull cur = Hash(w);
		if(!s.count(cur)) s[cur] = i;
		for(int j = 1; j <= n; ++j)
			w[j] = 1LL * w[j] * k[j] % g[j];
	}
	for(int i = 1; i <= n; ++i)
		w[i] = Inv(w[i], g[i]);
	for(int i = 0; i * B + K <= M; ++i) {
		ull cur = Hash(r);
		if(s.count(cur)) Answer(i * B + K + s[cur]);
		for(int j = 1; j <= n; ++j)
			r[j] = 1LL * r[j] * w[j] % g[j];
	}
	Answer(-1);
	return 0;
}
```

---

## 作者：mango09 (赞：3)

[P5345 【XR-1】快乐肥宅](https://www.luogu.com.cn/problem/P5345)

## Preface

好题！！！

当然也很毒瘤。

突然感到屠龙勇士在这题面前

就是逊内！！！

## Description

给定高次同余方程组
$$
\begin{cases}
k_1^x\equiv r_1\pmod {g_1}\\
k_2^x\equiv r_2\pmod {g_2}\\
\cdots\\
k_n^x\equiv r_n\pmod {g_n}
\end{cases}
$$
请求出该方程组的最小 **非负** 整数解，若 **无解** 或 **最小解 $\ge 10^9$**，输出 `Impossible`。

- 对于 $100\%$ 的数据，$1 \le n \le 10^3$，$1 \le k_i, r_i \le g_i \le 10^7$。

## Solution

**前置芝士：**

- `exBSGS`
- `exCRT`

### 一、求出单个同余方程的解

对于 $a^x\bmod p$，结果应该分为一段“尾巴”和一段循环部分，例如 $124^x\bmod 495616$：

![](https://cdn.luogu.com.cn/upload/pic/58118.png)

~~感谢兔队的图~~

这时对于一个正整数 $b$，$a^x\equiv b\pmod p$ 的解有 $3$ 种情况：

- 唯一解：即 $x$ 在尾巴上。例如 $b=15376$ 时，$x=2$。
- 无穷解：即 $x$ 在循环上。例如 $b=241664$ 时，$x\equiv 3+5\pmod 5$ 且 $x\ge 3+5$，其中 $3$ 表示 $b$ 是循环中的第 $3$ 个，$+5$ 表示尾巴的长度，模数为 $5$ 表示循环的长度，不等式是为了保证 $x$ 在循环上。
- 无解：例如 $b=114514$ 时。

在 `exBSGS` 中，除到 $\gcd(a,p)=1$ 时，先用 `BSGS` 求出 $a^x\equiv b\pmod p$ 的最小非负整数解，再求出 $a$ 模 $p$ 的阶（$\gcd(a,p)=1$ 时阶一定存在），那么阶就是循环长度。

下面的代码返回一个 $\operatorname{pair}$，第一个数表示最小解（如果无解则为 $-1$），第二个数表示阶（如果不存在则为 $-1$）。

与 `exBSGS` 模板一样，需要特判 $b=1$ 或 $p=1$ 的情况。

```cpp
pair<int, int> exBSGS(int a, int b, int p)
{
	if (p == 1)
	{
		return make_pair(0, 1);
	}
	a %= p, b %= p;
	int g = exgcd(a, p), f = 1, k = 0;
	while (g > 1)
	{
		if (b % g)
		{
			if (b == 1)
			{
				return make_pair(0, -1);
			}
			return make_pair(-1, -1);
		}
		k++;
		b /= g, p /= g;
		f = (ll)f * (a / g) % p;
		g = exgcd(a, p);
		if (f == b)
		{
			if (g > 1)
			{
				return make_pair(k, -1);
			}
			int y = BSGS(a, 1, p);
			return make_pair(k, y);
		}
	}
	int x = BSGS(a, (ll)b * inv(f, p) % p, p);
	if (x == -1)
	{
		return make_pair(-1, -1);
	}
	int y = BSGS(a, 1, p);
	return make_pair(x % y + k, y);
}
```

在主函数中：

```cpp
pair<int, int> res = exBSGS(k, r, g);
b[i] = res.first, a[i] = res.second;
if (b[i] == -1) // x 无解就肯定无解
{
    puts("Impossible");
    return 0;
}
else if (a[i] == -1) // 阶不存在，用一个 X 记录唯一的解
{
    X = b[i];
    continue;
}
mn = max(mn, b[i]); // x ≥ mn
```

### 二、合并解

如果出现了唯一解（即上面代码中的 $X\ne -1$）的情况，直接将这个 $X$ 带入剩下的方程中检验即可。

否则直接用 `exCRT` 合并即可，注意要加上 $\operatorname{lcm}(a_1,a_2,\dots,a_n)$ 的倍数使得答案不小于上面代码中的 $mn$。

我们设前 $(i-1)$ 个方程组合并后的解为 $x\equiv B\pmod A$，第 $i$ 个方程为 $x\equiv b\pmod a$。

问题来了， $10^3$ 个 $10^7$，合并后 $A,B$ 都有可能爆 `long long`。

观察题目中的要求：

> 若无解或 **最小解 $\ge 10^9$**，输出 `Impossible`。

当 $A>10^9$ 时，直接检测 $B$ 是否满足 $B\equiv b\pmod a$ 即可，如果不满足那么一定要加上若干个 $A$，那么一定超过了 $10^9$，不满足要求。

全部合并完之后记得也要判断 $B$ 是否在 $10^9$ 内。

## Code

```cpp
//18 = 9 + 9 = 18.
#include <iostream>
#include <cstdio>
#include <map>
#include <cmath>
#define Debug(x) cout << #x << "=" << x << endl
typedef long long ll;
using namespace std;

ll x, y;

ll exgcd(ll a, ll b)
{
	if (!b)
	{
		x = 1, y = 0;
		return a;
	}
	ll Gcd = exgcd(b, a % b);
	ll tmp = x;
	x = y;
	y = tmp - a / b * y;
	return Gcd;
}

ll A, B;

int merge(ll a, ll b)
{
	ll Gcd = exgcd(A, a), c = B - b;
	if (c % Gcd)
	{
		return -1;
	}
	c /= Gcd;
	x = (x * c % a + a) % a;
	ll Lcm = A / Gcd * a;
	B = (B - A * x % Lcm + Lcm) % Lcm;
	A = Lcm;
	return 1;
}

int div_ceil(int a, int b)
{
	return (a - 1) / b + 1;
}

const int MAXN = 1e3 + 5;
const int D = 1e9;

int a[MAXN], b[MAXN];

int exCRT(int n, int mn)
{
	A = a[1], B = b[1];
	for (int i = 2; i <= n; i++)
	{
		if (A > D && (B - b[i]) % a[i])
		{
			return -1;
		}
		else if (A <= D && merge(a[i], b[i]) == -1)
		{
			return -1;
		}
	}
	if (B < mn)
	{
		B += div_ceil(mn - B, A) * A;
	}
	if (B > D)
	{
		return -1;
	}
	return B;
}

int inv(int a, int p)
{
	exgcd(a, p);
	x = (x % p + p) % p;
	return x;
}

int phi(int p)
{
	int ans = p;
	for (int i = 2; i * i <= p; i++)
	{
		if (p % i == 0)
		{
			ans = ans / i * (i - 1);
			while (p % i == 0)
			{
				p /= i;
			}
		}
	}
	if (p != 1)
	{
		ans = ans / p * (p - 1);
	}
	return ans;
}

int BSGS(int a, int b, int p)
{
	map<int, int> hash;
	int t = ceil(sqrt(phi(p))), aj = 1;
	for (int j = 0; j < t; j++)
	{
		int val = (ll)b * aj % p;
		hash[val] = j;
		aj = (ll)aj * a % p;
	}
	a = aj;
	int ai = 1;
	for (int i = 1; i <= t; i++)
	{
		ai = (ll)ai * a % p;
		if (hash.find(ai) != hash.end())
		{
			int j = hash[ai];
			if (i * t - j >= 0)
			{
				return i * t - j;
			}
		}
	}
	return -1;
}

pair<int, int> exBSGS(int a, int b, int p)
{
	if (p == 1)
	{
		return make_pair(0, 1);
	}
	a %= p, b %= p;
	int g = exgcd(a, p), f = 1, k = 0;
	while (g > 1)
	{
		if (b % g)
		{
			if (b == 1)
			{
				return make_pair(0, -1);
			}
			return make_pair(-1, -1);
		}
		k++;
		b /= g, p /= g;
		f = (ll)f * (a / g) % p;
		g = exgcd(a, p);
		if (f == b)
		{
			if (g > 1)
			{
				return make_pair(k, -1);
			}
			int y = BSGS(a, 1, p);
			return make_pair(k, y);
		}
	}
	int x = BSGS(a, (ll)b * inv(f, p) % p, p);
	if (x == -1)
	{
		return make_pair(-1, -1);
	}
	int y = BSGS(a, 1, p);
	return make_pair(x % y + k, y);
}

int main()
{
	int n;
	scanf("%d", &n);
	int mn = 0, X = -1;
	for (int i = 1; i <= n; i++)
	{
		int k, g, r;
		scanf("%d%d%d", &k, &g, &r);
		pair<int, int> res = exBSGS(k, r, g);
		b[i] = res.first, a[i] = res.second;
		if (b[i] == -1)
		{
			puts("Impossible");
			return 0;
		}
		else if (a[i] == -1)
		{
			X = b[i];
			continue;
		}
		mn = max(mn, b[i]);
	}
	if (X != -1)
	{
		for (int i = 1; i <= n; i++)
		{
			if ((a[i] == -1 && X != b[i]) || (a[i] != -1 && (X < b[i] || (X - b[i]) % a[i])))
			{
				puts("Impossible");
				return 0;
			}
		}
		printf("%d\n", X);
		return 0;
	}
	int ans = exCRT(n, mn);
	if (ans == -1)
	{
		puts("Impossible");
	}
	else
	{
		printf("%d\n", ans);
	}
	return 0;
}
```

## References

- [1] 小粉兔：[洛谷 P5345: 【XR-1】快乐肥宅](https://www.cnblogs.com/PinkRabbit/p/LuoguP5345.html)



---

## 作者：SunsetSamsara (赞：1)

## 前置知识

exBSGS, exCRT

## 分析

一眼看上去这道题挺板子的，但是细节 **特别多**

首先， $k^t \mod g$ 是一个 $\rho$ 形，有个预循环的尾巴和循环体。

引用一下兔队的图：

![](https://cdn.luogu.com.cn/upload/pic/58118.png)

我们可以用 exBSGS 找到第一个次数，而后面的循环体长度则需要修改 exBSGS 求。首先，exBSGS 的“尾巴”是不循环的，在 exBSGS 的 $b \mod g \ne 1$ 的情况下判断有没有循环节。

接下来是判断有没有循环节的情况。因为这时底数和模数已经被我们除到互质了，所以我们就可以是用 BSGS 求循环节长度了。

exBSGS 代码:

```cpp
Array<lld> BSGS(int a, int b, int p) {
	if (p == 1) return Array<lld>({0, 1});
	a %= p, b %= p;
	lld g = gcd(a, p), f = 1, k = 0;
	while (g > 1) {
		if (b % g) {
			if (b == 1) return Array<lld>({0, -1});
			return Array<lld>({-1, -1});
		}
		++ k;
		b /= g, p /= g;
		f = (lld) f * (a / g) % p;
		g = gcd(a, p);
		if (f == b) {
			if (g > 1) return Array<lld>({k, -1});
			int y = _BSGS(a, 1, p);
			return Array<lld>({k, y});
		}
	}
	lld x = _BSGS(a, b * inv(f, p) % p, p);
	if (x == -1) return Array<lld>({-1, -1});
	int y = _BSGS(a, 1, p);
	return Array<lld>({x % y + k, y});
}
```

接下来就是一个裸的 exCRT 嘛，不过我调了十分久（因为我的写法和别人的写法完全不一样）。接下来就只需要找到答案可能超过 $10^9$ 的地方即可。看起来十分简单，但是可能会在中间爆 `long long`，所以要特判当前周期是否大于 $10^9$，而且需要加上周期的情况。这是我的 exCRT 代码

```cpp

Array<lld> CRT(Array<ModLinearFormula> arr) {
	if (!arr.size()) return Array<lld>({0, 1});
	lld x, y;
	lld nowmod = arr[1].p, ans = arr[1].a;
	lld a, b, c, g, bg;
	for (int i = 2; i <= arr.size(); ++ i) {
		if (nowmod <= MX) {
			a = nowmod, b = arr[i].p, c = (arr[i].a - ans % b + b) % b;
			g = gcd(a, b);
			unpack(exgcd(a, b), {&x, &y});
			bg = b / g;
			if (c % g) return Array<lld>({-1, -1});
			x = c / g * x % bg;
			ans += x * nowmod;
			if (ans > MX) return Array<lld>({-1, -1});
			nowmod *= bg;
			ans %= nowmod;
		}
	}
	return Array<lld>({(ans + nowmod) % nowmod, nowmod });
}
```


最后，用在一起时别忘了有一个方程解在“尾巴”上的情况，再特判一下。还有一个方程解在循环上时，别忘了把答案加到“尾巴”长度以上的情况。

恭喜你做出了我写了三天的题！

## 代码

```cpp
#include <bits/stdc++.h> 
#define lld long long
using namespace std;
const lld MX = 1e9;
template<class T> struct Array { vector<T> vec; Array() { } Array(int n) { vec.resize(n); } Array(initializer_list<T> ini) { vec = vector<T>(ini); } T & operator[](int t) { return vec[t - 1]; } int size() const { return vec.size(); } void resize(int n) { vec.resize(n); } void push(T x) { vec.push_back(x); } };
template<class T> void unpack(Array<T> arr, initializer_list<T*> args) { for (int i = 0; i < args.size(); ++ i) **(args.begin() + i) = arr[i + 1]; }
namespace Maths {
	lld gcd(lld x, lld y) { return y ? gcd(y, x % y) : x; }
	Array<lld> exgcd(lld x, lld y) { if (!y) return Array<lld>({1, 0}); Array<lld> t(2); lld a, b; unpack(exgcd(y, x % y), {&a, &b}); t[1] = b; t[2] = a - (x / y) * b; return t; }
	lld qpow(lld a, lld b, lld p) { lld ret = 1; for (; b; b >>= 1, a = a * a % p) if (b & 1) ret = ret * a % p; return ret; }
	struct ModLinearFormula { lld a, p; };
	Array<lld> CRT(Array<ModLinearFormula> arr) {
		if (!arr.size()) return Array<lld>({0, 1});
		lld x, y;
		lld nowmod = arr[1].p, ans = arr[1].a;
		lld a, b, c, g, bg;
		for (int i = 2; i <= arr.size(); ++ i) {
			if (nowmod <= MX) {
				a = nowmod, b = arr[i].p, c = (arr[i].a - ans % b + b) % b;
				g = gcd(a, b);
				unpack(exgcd(a, b), {&x, &y});
				bg = b / g;
				if (c % g) return Array<lld>({-1, -1});
				x = c / g * x % bg;
				ans += x * nowmod;
				if (ans > MX) return Array<lld>({-1, -1});
				nowmod *= bg;
				ans %= nowmod;
			}
		}
		return Array<lld>({(ans + nowmod) % nowmod, nowmod });
	}
	lld phi(lld n) {
		lld ret = n;
		if (!(n & 1)) {
			ret >>= 1;
			while (!(n & 1)) n >>= 1;
		}
		for (lld i = 3; i * i <= n; i += 2) 
			if (n % i == 0) {
				ret = ret / i * (i - 1);
				n /= i;
				while (n % i == 0) n /= i;
			}
		if (n > 1) ret = ret / n * (n - 1);
		return ret;
	}
	lld inv(lld x, lld n) {
		lld a;
		unpack(exgcd(x, n), {&a});
		return (a % n + n) % n;
	}
	lld _BSGS(lld a, lld b, lld p) {
		map<lld, lld> _hash;
		lld t = ceil(sqrt(phi(p))), aj = 1;
		for (lld j = 0; j < t; ++ j) {
			lld val = b * aj % p;
			_hash[val] = j;
			aj = aj * a % p;
		}
		a = aj;
		lld ai = 1;
		for (lld i = 1; i <= t; ++ i) {
			ai = ai * a % p;
			if (_hash.find(ai) != _hash.end()) {
				lld j = _hash[ai];
				if (i * t - j >= 0) return i * t - j;
			}
		}
		return -1;
	}
	Array<lld> BSGS(int a, int b, int p) {
		if (p == 1) return Array<lld>({0, 1});
		a %= p, b %= p;
		lld g = gcd(a, p), f = 1, k = 0;
		while (g > 1) {
			if (b % g) {
				if (b == 1) return Array<lld>({0, -1});
				return Array<lld>({-1, -1});
			}
			++ k;
			b /= g, p /= g;
			f = (lld) f * (a / g) % p;
			g = gcd(a, p);
			if (f == b) {
				if (g > 1) return Array<lld>({k, -1});
				int y = _BSGS(a, 1, p);
				return Array<lld>({k, y});
			}
		}
		lld x = _BSGS(a, b * inv(f, p) % p, p);
		if (x == -1) return Array<lld>({-1, -1});
		int y = _BSGS(a, 1, p);
		return Array<lld>({x % y + k, y});
	}
}
using namespace Maths;
int n;
lld k[1010], g[1010], r[1010];
lld p[1010], d[1010];
Array<ModLinearFormula> formula;
int main() {
	scanf("%d", &n);
	lld X = -1;
	lld mn = 0;
	for (int i = 1; i <= n; ++ i) {
		scanf("%lld%lld%lld", k + i, g + i, r + i);
		unpack(BSGS(k[i], r[i], g[i]), {p + i, d + i});
		if (p[i] == -1) {
			puts("Impossible");
			return 0;
		} else if (d[i] == -1) {
			X = p[i];
			continue;
		}
		mn = max(mn, p[i]);
		formula.push((ModLinearFormula){p[i], d[i]});
	}
	if (X >= 0) {
		for (int i = 1; i <= n; ++ i)
			if ((d[i] == -1 && X != p[i]) || (d[i] != -1 && (X < p[i] || (X - p[i]) % d[i]))) {
				puts("Impossible");
				return 0;
			}
		printf("%d\n", X);
		return 0;
	}
	lld ret, len;
	unpack(CRT(formula), {&ret, &len});
	if (ret == -1) {
		puts("Impossible");
		return 0;
	}
	ret = (ret % len + len) % len;
	ret += (mn - ret + len - 1) / len * len;
	if (ret > MX) {
		puts("Impossible");
		return 0;
	}
	printf("%lld\n", ret);
}
```

---

## 作者：MoYuFang (赞：1)

（兔队的题解审核好严谨啊）

给一个很暴力的解法。

首先问题可化简为（这一步不严谨，因为若体重为 $g_i$ 则不会减成 $0$，不过好像可以忽略，因为能 AC）
$$
k_i^{x}\equiv r_i\pmod{g_i}\quad(1\leq i\leq n)
$$
求最小的解 $x$。

很显然，对于一个特定的方程
$$
k_i^{x}\equiv r_i\pmod{g_i}
$$
其只有三种情况，要么只有一个解，要么有无限的周期解，否则无解。

若某特定方程无解，那整个问题肯定也无解，输出 ```Impossible``` 就行了。

若某特定方程有唯一解，那么判断这个唯一解是否满足所有方程，若不满足则说明无解，输出 ```Impossible``` 就行了，否则这个唯一解就是所有方程的解，直接输出就行了。

所以不妨假设所有方程均有无限的周期解，设第 $i$ 个方程最小的解为 $s_i$，次小的解为 $t_i$，则问题转化为求解方程组
$$
x\equiv s_i\pmod{(t_i-s_i)}
$$
这个显然可以用扩展中国剩余定理解决，若在用扩展中国定理求解方程答案时发现目前的解已经大于 $10^9$ 则输出 ```Impossible```（注意不是 $(t_i-s_i)$ 的 $\text{LCM}$ 大于 $1000000009$ 就输出 ```Impossible```，因为即便出现了这种情况也可能有解。

设 $mxs=\max\{t_i-s_i\}$，$lcm=\text{LCM}(t_i-s_i)$，并假设现在已经通过扩展中国剩余定理求出了一个解 $x_0$，那么还需要判断一下 $x_0$ 是否大于 $mxs$。

若 $x_0\geq mxs$，则说明 $x_0$ 是原问题的解，直接输出答案即可。

若 $x_0<mxs$ （这种情况可能出现的情形是 $(t_i-s_i)\leq s_i$），显然要重新整理一下答案，即取答案为 $(\lfloor(mxs-x_0-1)/lcm\rfloor\cdot lcm + x_0)$，这样答案就是第一个满足所有方程且大于等于 $mxs$ 的解了，当然若 $lcm > 10^9$ 则说明无解。



所以问题的关键是在有无限周期解的情况下如何快速的对每个方程 $k_i^{x}\equiv r_i\pmod{g_i}$ 求出最小解 $s_i$ 与次小解 $t_i$，考虑对 $\text{BSGS}$ 算法和 $\text{exBSGS}$ 算法进行改造使其能同时求出最小解和次小解。

先考虑对 $\text{BSGS}$ 算法改造。

这十分简单，开两个 ```unordered_map``` 就能很轻松的解决。

```cpp
#define re register
#define ll long long
void bsgs(re int a, re int b, re int p, re int &a1, re int &a2){
	a1 = a2 = -1; if (b == 1) a1 = 0;
	unordered_map<int, int> mp1, mp2; re int t = sqrt(2*p+0.5)+1, at = 1;
	a %= p; b %= p;
	for(re int i = 0; i < t; ++i){
		if (mp1.count(b)) mp2[b] = mp1[b], mp1[b] = i;
		else mp1[b] = i;
		b = (ll)b*a%p, at = (ll)at*a%p;
	}
	a = at;
	for(re int i = 1; i <= t; ++i){
		if (mp1.count(a)){
			if (a1 != -1){ a2 = i*t-mp1[a]; return; }
			else{
				a1 = i*t-mp1[a];
				if (mp2.count(a)){ a2 = i*t-mp2[a]; return; }
			}
		}
		a = (ll)a*at%p;
	}
}
```

其中 $a1$ 装的是最小解， $a2$ 装的是次小解，若次小解不存在则 $a2=-1$，若最小解不存在则 $a1=-1$。

然后是对 $\text{exBSGS}$ 算法的改造。

显然在 $\gcd(a,p)\neq 1$ 时的循环中若发现方程左右两边相等了则不能像普通的 $\text{exBSGS}$ 一样就直接输出答案了，还要判断是否已经有了一个解，并根据此判断是否要继续循环。

```cpp
ll mul(re ll a, re ll b, re ll m){ return ((a*b-(ll)((long double)a*b/m)*m)%m+m)%m; }
ll gcd(re ll a, re ll b){ while(b) a%=b, a^=b^=a^=b; return a; }
void exgcd(ll a, ll b, ll &g, ll &x, ll &y){
	if (!b) g = a, x = 1, y = 0;
	else exgcd(b, a%b, g, y, x), y -= x*(a/b);
}
void exbsgs(re int a, re int b, re int p, re int &a1, re int &a2){
	if (gcd(a, p) == 1) return bsgs(a, b, p, a1, a2);
	a1 = a2 = -1; if (b == 1) a1 = 0;
	a %= p; b %= p;
	re int g, k = 0, d = 1;
	while((g = gcd(a, p)) != 1){
		if (b % g) return;
		p /= g; b /= g; ++k; d = (ll)d*(a/g)%p;
		if (d == b){
			if (a1 != -1){ a2 = k; return; }
			a1 = k;
		}
	}
	re int t1, t2;
	bsgs(a, (ll)b*get_inv(d, p)%p, p, t1, t2);
	if (a1 != -1){
		a2 = t1>=0?t1+k:-1;
		if (a2 == a1) a2 = t2>=0?t2+k:-1;
	}
	else a1 = t1>=0?t1+k:-1, a2 = t2>=0?t2+k:-1;
}
```

于是问题就完美的解决了。

```cpp
#include <stdio.h>
#include <algorithm>
#include <string.h>
#include <iostream>
#include <assert.h>
#include <unordered_map>
#include <cmath>
using namespace std;

#define re register
#define sf scanf
#define pf printf
#define nl() putchar('\n')
#define ms(x, val) memset(x, val, sizeof(x))
#define ll long long
#define _for(i, a, b) for(re int (i) = (a); (i) < (b); ++(i))
#define _rfor(i, a, b) for(re int (i) = (a); (i) <= (b); ++(i))
#define _fev(p, u) for(re int (p) = head[(u)]; (p); (p) = nex[(p)])
#define inf 0x7fffffff
#define maxn 1005
#define cut 1000000000

template <class T>
void print(string name, T arr[], int n, int flag = 1){
	cout<<name<<":";
	_for(i, 0, n)cout<<" "<<arr[i+flag];
	cout<<endl;
}

int rdnt(){
	re int x = 0, sign = 1;
	re char c = getchar();
	while (c < '0' || c > '9') { if (c == '-') sign = -1; c = getchar(); }
	while (c >= '0' && c <= '9') x = (x<<3) + (x<<1) + (c ^ 48), c = getchar();
	return x * sign;
}

int fp(re int x, re int n, re int p){
	re int y = 1%p;
	for(; n; x = (ll)x*x%p, n >>= 1) if (n&1) y = (ll)x*y%p;
	return y;
}

ll mul(re ll a, re ll b, re ll m){ return ((a*b-(ll)((long double)a*b/m)*m)%m+m)%m; }
ll gcd(re ll a, re ll b){ while(b) a%=b, a^=b^=a^=b; return a; }
void exgcd(ll a, ll b, ll &g, ll &x, ll &y){
	if (!b) g = a, x = 1, y = 0;
	else exgcd(b, a%b, g, y, x), y -= x*(a/b);
}
ll get_inv(re ll a, re ll p){
	re ll g, x, y;
	exgcd(a, p, g, x, y);
	if (g != 1) assert(false);

	return (x%p+p)%p;
}

struct exCRT{
	ll a[maxn], m[maxn];
	ll solve(re int n){
		re ll M = 1, x = 0, g, mm;
		_rfor(i, 1, n){
			if (x % m[i] == a[i]%m[i]){
				continue;
			}
			a[i] %= m[i];
			g = gcd(M, m[i]); mm = M/g*m[i];
			if (mm < M) return -1;
			if ((x-a[i])%g) return -1;
			x = (mul(mul(get_inv(m[i]/g, M/g), m[i], mm), (x>=a[i]?x-a[i]:mm-a[i]+x)/g, mm)+a[i])%mm;
			if (x > cut){ return -1; }
			M = mm;
		}
		return x;
	}
} crt;

void bsgs(re int a, re int b, re int p, re int &a1, re int &a2){
	a1 = a2 = -1; if (b == 1) a1 = 0;
	unordered_map<int, int> mp1, mp2; re int t = sqrt(2*p+0.5)+1, at = 1;
	a %= p; b %= p;
	_for(i, 0, t){
		if (mp1.count(b)) mp2[b] = mp1[b], mp1[b] = i;
		else mp1[b] = i;
		b = (ll)b*a%p, at = (ll)at*a%p;
	}
	a = at;
	_rfor(i, 1, t){
		if (mp1.count(a)){
			if (a1 != -1){ a2 = i*t-mp1[a]; return; }
			else{
				a1 = i*t-mp1[a];
				if (mp2.count(a)){ a2 = i*t-mp2[a]; return; }
			}
		}
		a = (ll)a*at%p;
	}
}

void exbsgs(re int a, re int b, re int p, re int &a1, re int &a2){
	if (gcd(a, p) == 1) return bsgs(a, b, p, a1, a2);
	a1 = a2 = -1; if (b == 1) a1 = 0;
	a %= p; b %= p;
	re int g, k = 0, d = 1;
	while((g = gcd(a, p)) != 1){
		if (b % g) return;
		p /= g; b /= g; ++k; d = (ll)d*(a/g)%p;
		if (d == b){
			if (a1 != -1){ a2 = k; return; }
			a1 = k;
		}
	}
	re int t1, t2;
	bsgs(a, (ll)b*get_inv(d, p)%p, p, t1, t2);
	if (a1 != -1){
		a2 = t1>=0?t1+k:-1;
		if (a2 == a1) a2 = t2>=0?t2+k:-1;
	}
	else a1 = t1>=0?t1+k:-1, a2 = t2>=0?t2+k:-1;
}

int k[maxn], g[maxn], r[maxn], s[maxn], t[maxn];

int main(){
	#ifndef ONLINE_JUDGE
	freopen("sample.in", "r", stdin);
	freopen("sample.out", "w", stdout);
	#endif
	
	re int n = rdnt();
	_rfor(i, 1, n){
		k[i] = rdnt(), g[i] = rdnt(), r[i] = rdnt();
		exbsgs(k[i], r[i], g[i], s[i], t[i]);
		if (s[i] != -1){
			assert(fp(k[i], s[i], g[i]) == r[i]%g[i]);
		}
		if (t[i] != -1){
			assert(s[i] != -1);
			assert(s[i] != t[i]); assert(s[i] < t[i]);
			assert(fp(k[i], t[i], g[i]) == r[i]%g[i]);
		}
	}
	re int mxt = 0, mxs = 0;
	_rfor(i, 1, n) mxt = max(mxt, t[i]), mxs = max(mxs, s[i]);
	re ll lcm = 1; re bool flag = false;
	_rfor(i, 1, n){
		if (s[i] == -1 && t[i] == -1){ pf("Impossible\n"); return 0; }
		if (t[i] == -1){
			_rfor(j, 1, n){
				if (fp(k[j], s[i], g[j]) != r[j]%g[j]){ pf("Impossible\n"); return 0; }
			}
			pf("%d\n", s[i]); return 0;
		}
		crt.a[i] = s[i]; crt.m[i] = t[i]-s[i];
		lcm = lcm/gcd(lcm, t[i]-s[i])*(t[i]-s[i]);
		if (lcm >= (ll)cut*cut) flag = true;
	}
	re int as = crt.solve(n);
	if (as == -1){ pf("Impossible\n"); return 0; }
	if (as < mxs){
		if (!flag) as = ((mxs-as-1)/lcm+1)*lcm+as;
		else as = -1;
	}
	if (as != -1) pf("%d\n", as);
	else pf("Impossible\n");
	
	return 0;
}
```



---


# 【XR-2】约定 (加强版)

## 题目背景

原题链接：[P5437](https://www.luogu.org/problemnew/show/P5437)

其实在比赛时就想放上这个加强版了qwq    
但是团队成员都强烈反对，于是就在赛后放上来啦

## 题目描述

有一个 $n$ 个点的完全图，编号从 $1$ 到 $n$。  
连接 $i$ 和 $j$ 节点的边，权值为 $(i+j)^k$。  
定义一棵树的权值为其所有边的权值和。  
从这个图的所有生成树中随机选择一个，求其权值的期望。  
需要将答案对 $998244353$ 取模。

## 说明/提示

### 数据范围：   
$1\le n \le 10^{10000}$  
$1\le k \le 10^7$


## 样例 #1

### 输入

```
3 1```

### 输出

```
8```

## 样例 #2

### 输入

```
4 3```

### 输出

```
450```

## 样例 #3

### 输入

```
1926 817```

### 输出

```
984167516```

## 样例 #4

### 输入

```
998244353 1```

### 输出

```
998244352```

# 题解

## 作者：Dreamunk (赞：2)

冷静分析，冷静分析……

[题目](https://www.luogu.org/problem/P5442)

[加强前的详细思路见此处](https://www.luogu.com.cn/problemnew/solution/P5437)

__为了方便，记 $M = 998244353$。__

记 $F_k(n)=\sum_{1\le i<j\le n}(i+j)^k$，则答案就是 $\frac{2}{n}F_k(n)$。

发现 $F_k(n)$ 是个关于 $n$ 的 $(k+2)$ 次多项式，所以我们要拿 $(k+3)$ 个点值来插它。

根据拉格朗日插值，得到式子 

$F_k(n)=\sum_{i=1}^{m+3}F_k(i)\prod_{j\ne i}\frac{n-j}{i-j}$

$=\sum_{i=1}^{m+3}F_k(i)\frac{1}{(i-1)!}\frac{1}{(m+3-i)!}(-1)^{m+3-i}\prod_{j=1}^{i-1}(n-j)\prod_{j=i+1}^{m+3}(n-j)$

。求和号后面的每个东西都可以预处理，于是我们就求出了 $F_k(n) \mod M$。

接下来还要乘个 $\frac{2}{n}$，分几种情况讨论：

#### 一、$1\le n<M$

这时候 $n$ 存在逆元，直接乘就好了。于是我们解决了没加强的版本。

#### 二、$n=M$

这时候算出的 $F_k(n) \mod M$ 其实也是对的（实际上，这时候 $F_k(n) \mod M=0$）。

问题在于最后还要乘个 $\frac{2}{n}$，而 $n$ 这时候没有逆元。

首先想到看看上面有没有可以消去的 $n$ ，但似乎并没有找到。

注意到这个拉格朗日插值，我们取的点是 $1$ 到 $k+3$。换成 $0$ 到 $k+2$ 试试看？

首先可以得到 $F_k(0)=0$。

然后发现式子变成这样：

$F_k(n)=\sum_{i=0}^{m+2}F_k(i)\frac{1}{i!}\frac{1}{(m+2-i)!}(-1)^{m+2-i}\prod_{j=0}^{i-1}(n-j)\prod_{j=i+1}^{m+2}(n-j)$

那 $\prod_{j=0}^{i-1}(n-j)$ 这里，不就有一个 $n$ 吗？把它消掉就行了。

Wait...你说 $i=0$ 的时候没有 $n$ 怎么办？$F_k(0)=0$，所以 $i=0$ 的时候对答案没有贡献，直接让循环从 $1$ 开始就好了。

（尽管在计算的时候没有贡献，但我们仍然是拿 $(k+3)$ 个点值来插的，只不过在 $0$ 处的点值为 $0$ 而已。）

于是得到的式子是

$\frac{1}{n}F_k(n)=\sum_{i=1}^{m+2}F_k(i)\frac{1}{i!}\frac{1}{(m+2-i)!}(-1)^{m+2-i}\prod_{j=1}^{i-1}(n-j)\prod_{j=i+1}^{m+2}(n-j)$

乘个 $2$ 就是答案了。

#### 三、$n>M$

$n>M$ 时，$n$ 的答案和 $n\mod M+[n\mod M=0]\cdot M$ 的答案是一样的，输入的时候直接取模就好了。

这个证明其实并不像看起来一样简单，可以思考一下。

```cpp
#include<cstdio>
typedef long long ll;
const int A=1e7+37,M=998244353;
inline int Pow(int a,int m){int s=1;for(;m;m>>=1)m&1?s=(ll)s*a%M:0,a=(ll)a*a%M;return s;}
int n,m,f[A+A],g[A],func[A],t0[A],t1[A],invf[A],np[A+A],p[1300000],k,ans;
inline int Read(){
	int a=0;char c=getchar();
	for(;c>57||c<48;c=getchar());for(;c>47&&c<58;a=(a*10ll+c-48)%M,c=getchar());
	return a;
}
int main(){
	n=Read();if(!n)n+=M;
	scanf("%d",&m);
	f[1]=1;
	for(int i=2;i<=m+m+3;i++){
	  if(!np[i])p[++k]=i,f[i]=Pow(i,m);
	  for(int j=1;j<=k&&i*p[j]<=m+m+3;j++){
		np[i*p[j]]=1;
		f[i*p[j]]=(ll)f[i]*f[p[j]]%M;
		if(i%p[j]==0)break;
	  }
	}
	for(int i=1;i<=m+m+3;i++)f[i]=(f[i]+f[i-1])%M;
	func[0]=1,t0[0]=1;
	for(int i=1;i<=m+2;i++){
	  t0[i]=(ll)t0[i-1]*(n-i)%M;
	  func[i]=(ll)func[i-1]*i%M;
	  g[i]=((ll)g[i-1]+f[2*i-1]-f[i]+M)%M;
	  if(n==i)return 0*printf("%lld\n",g[i]*2ll*Pow(n,M-2)%M);
	}
	invf[m+2]=Pow(func[m+2],M-2),t1[m+2]=n-(m+2),t1[m+3]=1;
	for(int i=m+2;i;i--){
	  t1[i-1]=(ll)t1[i]*(n-i+1)%M;
	  invf[i-1]=(ll)invf[i]*i%M;
	}
	for(int i=1;i<=m+2;i++)
	  ans=(ans+(ll)g[i]*t0[i-1]%M*t1[i+1]%M*invf[i]%M*invf[m+2-i]*(m+2-i&1?-1:1)%M+M)%M;
	printf("%d\n",ans*2%M);
	return 0;
}
```

---

## 作者：mrsrz (赞：2)

这题很坑的是按照原题的方法最后要除以$n$，但$n$在模意义下可能为0。

其实可以直接按照原来的方法来。只需要把模数改为${998244353}^2$即可。

考虑最终的答案在不取模时为$c$，设$c=a\times 998244353^2+b$。

那么有$c\equiv b\pmod{998244353^2}$。

则显然有$c\equiv b\bmod{998244353}\pmod{998244353}$。

所以当$n$不为模数的倍数的时候，按照这样计算出来的结果直接对原模数取模就是答案。然后除以$n$可以直接计算逆元。

考虑当$n\equiv 0\pmod{998244353}$的情况。出题人已经证明答案存在，这里不作讨论。

此时$c\equiv 0\pmod{998244353}$。

由于$a\times 998244353^2\equiv 0\pmod{998244353}$，所以可知$b\equiv 0\pmod {998244353}$。

于是我们计算出的$b$一定是$998244353$的倍数，那么除掉就可以了。

这样需要涉及非常多的```long long```运算，所以速度非常慢，很卡常。但由于这题的做法瓶颈在于线性的循环，所以加编译指令集会有奇效。

## Code：
```cpp
#pragma GCC optimize("Ofast")
#pragma GCC optimize("unroll-loops")
#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native")
#include<cstdio>
#include<cctype>
const int N=1e7+10;
typedef long long LL;
const LL md=998244353LL*998244353;
inline void upd(LL&a){a+=a>>63&md;}
inline LL mul(LL a,LL b,const LL&md=998244353LL*998244353){
    const LL tmp=a*b-(LL)((long double)a*b/md+.5)*md;
    return(tmp>>63&md)+tmp;
}
inline LL pow(LL a,LL b,const LL&md=998244353LL*998244353){
    LL ret=1;
    for(;b;b>>=1,a=mul(a,a,md))if(b&1)ret=mul(ret,a,md);
    return ret;
}
inline void exgcd(LL a,LL b,LL&x,LL&y){if(!b)x=1,y=0;else exgcd(b,a%b,y,x),y-=a/b*x;}
inline LL getinv(LL a){
    static LL x,y;
    exgcd(a,md,x,y);
    upd(x);
    return x;
}
int k,vis[N],pri[N/10],tot;
LL P[N],X[N];
LL fac,iv[N],pre[N],suf[N],ans=0,n,ivv[N];
void init(const int n){
    P[1]=1;
    for(int i=2;i<=n;++i){
        if(!vis[i])pri[++tot]=i,P[i]=pow(i,k);
        for(int j=1;j<=tot&&i*pri[j]<=n;++j){
            vis[i*pri[j]]=1;
            P[i*pri[j]]=mul(P[i],P[pri[j]]);
            if(i%pri[j]==0)break;
        }
    }
}
inline LL query(LL x){
    LL ret=0;
    for(int i=1;i<=k+3;++i)
    pre[i]=mul(pre[i-1],x-i+md);
    for(int i=k+3;i;--i)
    suf[i]=mul(suf[i+1],x-i+md);
    for(int i=1;i<=k+3;++i)iv[i]=((k+3-i)&1)?(-mul(mul(pre[i-1],suf[i+1]),ivv[i])+md):mul(mul(pre[i-1],suf[i+1]),ivv[i]);
    for(int i=1;i<=k+3;++i)upd(ret+=mul(X[i],iv[i])-md);
    return ret;
}
void read(){
    int c=getchar();
    for(;!isdigit(c);c=getchar());
    for(;isdigit(c);c=getchar())n=(n*10+(c^'0'))%998244353;
    scanf("%d",&k);
}
int main(){
    read();
    if(n==1){puts("0");return 0;}
    if(n==0)n=998244353;
    init(k+5);
    for(int i=fac=1;i<=k+3;++i)fac=mul(i,fac);
    iv[k+3]=getinv(fac);
    for(int i=k+3-1;~i;--i)iv[i]=mul(i+1,iv[i+1]);
    for(int i=1;i<=k+3;++i)ivv[i]=mul(iv[i-1],iv[k+3-i]);
    pre[0]=suf[k+4]=1;
    for(int i=1;i<=k+3;++i)
    upd(X[i]=X[i-1]+mul(i-1,P[i])-md);
    ans=query(n+1);
    for(int i=1;i<=k+3;++i)
    upd(X[i]=X[i-1]+mul(P[i],P[2])-md);
    ans=(ans-(LL)query(2*n+1>>1)+md)%md;
    for(int i=1;i<=k+3;++i)
    upd(X[i]=X[i-1]+mul((2*n+1-i+md)%md,P[i])-md);
    ans=(ans+query(n<<1|1)-query(n+1)+md)%md;
    if(n%998244353)
    printf("%lld\n",ans%998244353*(LL)pow(n,998244351,998244353)%998244353);else
    printf("%lld\n",ans/998244353);
    return 0;
}

```

---

## 作者：NaCly_Fish (赞：2)

此题还是来补一片题解比较好。。  
首先对于普通版的题解，看[这里](https://www.luogu.org/blog/NaCly-Fish-blog/solution-of-yueding)就好了。  

此处只详细讲对于 $n\equiv 0\pmod{p}$ 的解法。
****
由于 $n$ 在模 $p$ 意义下为 $0$，所以此时 $n$ 的逆元是不存在的。  

而最终答案又不一定是 $0$。就比如 $k=1$ 时，答案应为 $p-1$。  

但是我们知道答案是一个多项式，也就是这个：  

ps：下面这个式子的 $n$，表示的是点值数量，即 $k+3$。  
$$\large f(x)=\sum\limits_{i=0}^n\frac{f(i)(-1)^{n-i}}{(i-1)!(n-i)!}\prod\limits_{j\neq i}(x-j)$$  
容易发现 $f(0)=0$，也就是说 $f(x)$ 的常数项为 $0$。  

这告诉我们，答案是可以表示出来的。

在原本的做法中，我们求出 $f(n)$，将其乘 $2$ 再除 $n$，得到答案。  

但在这种特殊情况下，不一定要求出这个 $f(n)$ 具体是什么，所以还是把它当做一个多项式比较好。

观察一下式子：  
$$\large \frac{2f(n)}{n} \text{ mod }p$$  
将 $f(n)$ 除 $n$，就相当于是 $f(n)$ 的每一项都降了一次。  

而由于 $p|n$，所以模 $p$ 之后，除了常数项全部都被消去了！  

于是只需要求出 $f(n)$ 的一次项系数的 $2$ 倍，就得到了答案。

要求的是系数，而不是点值，所以需要写一个二项式的结构体来计算。  

对于高于一次的系数，我们并不关心，所以要忽略掉，对答案也没有影响。

参考代码(附注释)：
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<vector>
#define N 20000007
#define ll long long
#define reg register
#define p 998244353
using namespace std;

inline int add(int a,int b);
inline int dec(int a,int b);
inline int power(int a,int t);
inline void read(int &x);
void print(int x);
int solve();
inline int case1(); //case1就是解决特殊情况的
inline int case2();

struct binom{ //binomial 二项式
    int a,b;
    binom(int a=0,int b=0):a(a),b(b){}

    inline binom operator + (const binom& x) const{
        return binom(add(a,x.a),add(b,x.b));
    }

    inline binom operator - (const binom& x) const{
        return binom(dec(a,x.a),dec(b,x.b));
    }

    inline binom operator * (const binom& x) const{
        return binom(((ll)a*x.b+(ll)b*x.a)%p,(ll)b*x.b%p);
    }

    inline binom operator * (const int& x) const{
        return binom((ll)a*x%p,(ll)b*x%p);
    }
};

int n,k,lim,ans;
int f[N],s[N],_pre[N],_suf[N];
binom pre[N],suf[N];

int main(){
    reg int cnt = 0;
    read(n),read(k);
    lim = min(k+3,n+1)<<1;
    if(n==0) lim = (k+3)<<1;
    s[1] = 1;
    for(reg int i=2;i<=lim;++i){
        if(!s[i]){
            f[++cnt] = i;
            s[i] = power(i,k);
        }
        for(reg int j=1;j<=cnt;++j){
            if(i*f[j]>lim) break;
            s[i*f[j]] = (ll)s[i]*s[f[j]]%p;
            if(i%f[j]==0) break;
        }
    }
    for(reg int i=2;i<=lim;++i) s[i] = add(s[i],s[i-1]);
    lim >>= 1;
    f[1] = 0,f[2] = power(3,k);
    for(reg int i=3;i<=lim;++i)
        f[i] = add(f[i-1],dec(s[(i<<1)-1],s[i]));
    if(n<=lim&&n>0) ans = (ll)(f[n]<<1)*power(n,p-2)%p;
    else ans = solve();
    print(ans);
    return 0;
}

inline int case1(){
    reg int res = 0,g;
    reg binom qwq;
    pre[0] = suf[lim+1] = binom(0,1);
    for(reg int i=1;i<=lim;++i) pre[i] = pre[i-1]*binom(1,p-i); //上面那一大坨式子中,右半边的连续乘积,每一块都是(x-j). 一次项为1,常数项就是-j
    for(reg int i=lim;i>=1;--i) suf[i] = suf[i+1]*binom(1,p-i);
    for(reg int i=1;i<=lim;++i){ //类比case2的做法来乘，只不过算出的是系数
        g = (ll)f[i]*s[i-1]%p*s[lim-i]%p;
        qwq = pre[i-1]*suf[i+1]*g;   
        if((lim-i)&1) res = dec(res,qwq.a);
        else res = add(res,qwq.a);
    }
    return add(res,res); //别忘了*2
}

inline int case2(){
    reg int res = 0,g;
    _pre[0] = _suf[lim+1] = 1;
    for(reg int i=1;i<=lim;++i) _pre[i] = (ll)_pre[i-1]*(n-i)%p;
    for(reg int i=lim;i>=1;--i) _suf[i] = (ll)_suf[i+1]*(n-i)%p;
    for(reg int i=1;i<=lim;++i){
        g = (ll)f[i]*_pre[i-1]%p*_suf[i+1]%p*s[i-1]%p*s[lim-i]%p;
        if((lim-i)&1) res = dec(res,g);
        else res = add(res,g);
    }
    return (ll)(res<<1)*power(n,p-2)%p;
}

int solve(){
    s[0] = s[1] = 1;
    for(reg int i=2;i<=lim;++i) s[i] = (ll)s[i-1]*i%p;
    s[lim] = power(s[lim],p-2);
    for(reg int i=lim-1;i>=1;--i) s[i] = (ll)s[i+1]*(i+1)%p;
    if(n) return case2();
    return case1();
}

inline int add(int a,int b){
    return a+b>=p?a+b-p:a+b;
}

inline int dec(int a,int b){
    return a<b?a-b+p:a-b;
}

inline int power(int a,int t){
    int res = 1;
    while(t){
        if(t&1) res = (ll)res*a%p;
        a = (ll)a*a%p;
        t >>= 1;
    }
    return res;
}

inline void read(int &x){
    x = 0;
    char c = getchar();
    while(c<'0'||c>'9') c = getchar();
    while(c>='0'&&c<='9'){
        x = (((ll)x<<3)+(x<<1)+(c^48))%p;
        c = getchar();
    }
}

void print(int x){
    if(x>9) print(x/10);
    putchar(x%10+'0');
}
```

---

## 作者：AThousandSuns (赞：2)

在我的博客看效果更佳：[点这里](https://www.cnblogs.com/1000Suns/p/11109469.html)

## 对原题的想法：

其实也是一道比较简单的题。~~（所以就应该把这题和上一道原题调个位置）~~

考虑一条边在生成树中出现的概率，由于一共有 $\dfrac{n(n-1)}{2}$ 条边，一个生成树有 $n-1$ 条边，而每条边的概率相等，所以为 $\dfrac{2}{n}$。

那么开始推式子：（注：第三步是枚举 $i+j$）

$$\dfrac{2}{n}\sum\limits_{i=1}^n\sum\limits_{j=i+1}^n(i+j)^k$$

$$\dfrac{1}{n}(\sum\limits_{i=1}^n\sum\limits_{j=1}^n(i+j)^k-\sum\limits^n_{i=1}(i+i)^k)$$

$$\dfrac{1}{n}(\sum\limits_{s=1}^{2n}s^k\min(s-1,2n+1-s)-2^k\sum\limits^n_{i=1}i^k)$$

$$\dfrac{1}{n}(\sum\limits_{s=1}^{n}s^k(s-1)+\sum\limits_{s=n+1}^{2n}s^k(2n+1-s)-2^k\sum\limits^n_{i=1}i^k)$$

$$\dfrac{1}{n}(\sum\limits_{s=1}^{n}s^{k+1}-\sum\limits_{s=1}^{n}s^{k}+(2n+1)\sum\limits_{s=n+1}^{2n}s^k-\sum\limits_{s=n+1}^{2n}s^{k+1}-2^{k}\sum\limits^n_{i=1}i^k)$$

$$\dfrac{1}{n}(2\sum\limits_{i=1}^{n}i^{k+1}-(2n+2+2^k)\sum\limits_{i=1}^{n}i^{k}+(2n+1)\sum\limits_{i=1}^{2n}i^k-\sum\limits_{i=1}^{2n}i^{k+1})$$

现在问题就是求 $f(n)=\sum\limits_{i=1}^ni^k$ 了。

由于 $f(n)-f(n-1)=n^k$，$f$ 的差值是个 $k$ 次多项式，所以 $f$ 是个 $k+1$ 次多项式。

那么可以拉格朗日插值。（以下内容的代码实现细节比较多，注意要控制复杂度不带 $\log$）

取 $k+2$ 个点为 $1$ 到 $k+2$，发现点值 $y_i$ 可以 $O(k)$ 计算。（$y_i=y_{i-1}+i^k$ 不能直接快速幂，不然带 $\log$。可以用欧拉筛筛出所有 $k$ 次方）

$$f(n)=\sum\limits_{i=1}^{k+2}y_i\dfrac{\prod\limits^{k+2}_{j=1,j\ne i}(n-x_j)}{\prod\limits^{k+2}_{j=1,j\ne i}(x_i-x_j)}$$

这样拉格朗日插值公式中的分母就是两个阶乘相乘的形式，可以 $O(1)$。（预处理要注意控制复杂度）

代入一个数算时，先特判 $n\ge mod$（因为会调用到 $f(2n)$），此时 $f(n)=\lfloor\dfrac{n}{mod}\rfloor f(mod-1)+f(n\%mod)$。

否则先算出 $fac=\prod\limits_{i=1}^{k+2}(n-i)$。同时预处理出所有 $n-i$ 的逆元 $inv_i$。（不要一个个快速幂算，复杂度错的。要用 $O(k+\log)$ 的方式）

此时就有：

$$f(n)=\sum\limits_{i=1}^{k+2}y_i\dfrac{fac\times inv_i}{(i-1)!(k-i+2)!(-1)^{k-i+2}}$$

已经可以 $O(k)$ 计算了。

时间复杂度 $O(k+\log)$。

以上是原版的做法。

---
## 对加强版的想法：

毒瘤的神鱼又加强了这题……然后就……让我来做……

~~受宠若惊呢QwQ~~

不过真没想到自己也能想到加强版正解。

先考虑 $n$ 不为 $998244353$（以下简写为 $p$）的倍数。（因为式子前面有个 $\dfrac{1}{n}$，可能没有逆元）

那么 $\sum\limits_{i=1}^ni^k=\lfloor\dfrac{n}{p}\rfloor\sum\limits_{i=1}^{p-1}i^k+\sum\limits_{i=1}^{n\bmod p}i^k$。

写个高精除低精就没了。

然后考虑 $n$ 是 $p$ 的倍数。

$\sum\limits_{i=1}^ni^k=\dfrac{n}{p}\sum\limits_{i=1}^pi^k$。

此时原式：

$$\dfrac{1}{n}(\dots\sum\limits^n_{i=1}i^k+\dots\sum\limits^{2n}_{i=1}i^k)$$

$$\dfrac{1}{n}(\dfrac{n}{p}\dots\sum\limits^{p-1}_{i=1}i^k+2\dfrac{n}{p}\dots\sum\limits^{p-1}_{i=1}i^k)$$

$$\dfrac{1}{p}\dots\sum\limits^{p-1}_{i=1}i^k+\dfrac{2}{p}\dots\sum\limits^{p-1}_{i=1}i^k$$

此处取点值为 $0$ 到 $k+1$ 而不是上文中的 $1$ 到 $k+2$。

观察拉格朗日插值的式子，分子是有个 $x-x_j$ 的。那么当 $i=0$ 时，$y_i=0$，是 $p$ 的倍数。当 $i\ne 0$ 时，$x-x_0=x=p$，是 $p$ 的倍数。

那么只需要在分子中不乘上那个 $x-x_0=p$ 即可。就相当于求出了 $\frac{\sum\limits_{i=1}^pi^k}{p}$。

那么就做完了。

时间复杂度 $O(k+\log n)$。

（神鱼太毒瘤了……一道数论题我码了3.8K……码出了数据结构题的感觉……）

```cpp
#define Orz_NaCly_Fish
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=10001000,mod=998244353;
#define FOR(i,a,b) for(int i=(a);i<=(b);i++)
#define ROF(i,a,b) for(int i=(a);i>=(b);i--)
#define MEM(x,v) memset(x,v,sizeof(x))
inline int read(){
	char ch=getchar();int x=0,f=0;
	while(ch<'0' || ch>'9') f|=ch=='-',ch=getchar();
	while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();
	return f?-x:x;
}
int ndiv,nmod,k,ans,len,kp[maxn],k1p[maxn],pr[maxn/10],pl,ky[maxn],k1y[maxn],fac[maxn],invfac[maxn],tfac[maxn],tinv[maxn];
char nstr[11111];
bool vis[maxn];
inline int add(int a,int b){return a+b<mod?a+b:a+b-mod;}
inline int sub(int a,int b){return a<b?a-b+mod:a-b;}
inline int mul(int a,int b){return 1ll*a*b%mod;}
inline int qpow(int a,int b){
	int ans=1;
	for(;b;b>>=1,a=mul(a,a)) if(b&1) ans=mul(ans,a);
	return ans;
}
int kcalc(int x){
	if(x<=k+1){
		int ans=mul(mul(ky[x],fac[x]),fac[k-x+1]);
		if(!((k-x)&1)) return ans?mod-ans:0;
		else return ans;
	}
	if(x==mod){
		tfac[0]=1;
		FOR(i,1,k+1) tfac[i]=mul(tfac[i-1],x-i);
		tinv[k+1]=qpow(tfac[k+1],mod-2);
		ROF(i,k,1) tinv[i]=mul(tinv[i+1],x-i-1);
		FOR(i,2,k+1) tinv[i]=mul(tinv[i],tfac[i-1]);
		int ans=0;
		FOR(i,1,k+1) ans=add(ans,mul(mul(ky[i],tfac[k+1]),tinv[i]));
		return ans;
	}
	tfac[0]=x;
	FOR(i,1,k+1) tfac[i]=mul(tfac[i-1],x-i);
	tinv[k+1]=qpow(tfac[k+1],mod-2);
	ROF(i,k,0) tinv[i]=mul(tinv[i+1],x-i-1);
	FOR(i,1,k+1) tinv[i]=mul(tinv[i],tfac[i-1]);
	int ans=0;
	FOR(i,0,k+1) ans=add(ans,mul(mul(ky[i],tfac[k+1]),tinv[i]));
	return ans;
}
int k1calc(int x){
	if(x<=k+2){
		int ans=mul(mul(k1y[x],fac[x]),fac[k-x+2]);
		if((k-x)&1) return ans?mod-ans:0;
		else return ans;
	}
	if(x==mod){
		tfac[0]=1;
		FOR(i,1,k+2) tfac[i]=mul(tfac[i-1],x-i);
		tinv[k+2]=qpow(tfac[k+2],mod-2);
		ROF(i,k+1,1) tinv[i]=mul(tinv[i+1],x-i-1);
		FOR(i,2,k+2) tinv[i]=mul(tinv[i],tfac[i-1]);
		int ans=0;
		FOR(i,1,k+2) ans=add(ans,mul(mul(k1y[i],tfac[k+2]),tinv[i]));
		return ans;
	}
	tfac[0]=x;
	FOR(i,1,k+2) tfac[i]=mul(tfac[i-1],x-i);
	tinv[k+2]=qpow(tfac[k+2],mod-2);
	ROF(i,k+1,0) tinv[i]=mul(tinv[i+1],x-i-1);
	FOR(i,1,k+2) tinv[i]=mul(tinv[i],tfac[i-1]);
	int ans=0;
	FOR(i,0,k+2) ans=add(ans,mul(mul(k1y[i],tfac[k+2]),tinv[i]));
	return ans;
}
void init(){
	fac[0]=1;
	FOR(i,1,k+2) fac[i]=mul(fac[i-1],i);
	invfac[k+2]=qpow(fac[k+2],mod-2);
	ROF(i,k+1,0) invfac[i]=mul(invfac[i+1],i+1);
	kp[1]=k1p[1]=1;
	FOR(i,2,k+2){
		if(!vis[i]){
			pr[++pl]=i;
			kp[i]=qpow(i,k);
			k1p[i]=qpow(i,k+1);
		}
		FOR(j,1,pl){
			if(i*pr[j]>k+2) break;
			vis[i*pr[j]]=true;
			kp[i*pr[j]]=mul(kp[i],kp[pr[j]]);
			k1p[i*pr[j]]=mul(k1p[i],k1p[pr[j]]);
			if(i%pr[j]==0) break;
		}
	}
	ky[0]=k1y[0]=0;
	FOR(i,1,k+2) ky[i]=add(ky[i-1],kp[i]),k1y[i]=add(k1y[i-1],k1p[i]);
	FOR(i,0,k+2){
		ky[i]=mul(mul(ky[i],invfac[i]),invfac[k-i+1]);
		if(!((k-i)&1)) ky[i]=ky[i]?mod-ky[i]:0;
		k1y[i]=mul(mul(k1y[i],invfac[i]),invfac[k-i+2]);
		if((k-i)&1) k1y[i]=k1y[i]?mod-k1y[i]:0;
	}
}
int main(){
	scanf("%s",nstr+1);k=read();
	len=strlen(nstr+1);
	init();
	FOR(i,1,len){
		ll tmp=10ll*nmod+nstr[i]-'0';
		ndiv=add(mul(ndiv,10),tmp/mod);
		nmod=tmp%mod;
	}
	if(nmod){
		int ktmp=kcalc(mod-1),k1tmp=k1calc(mod-1);
		int krem=kcalc(nmod),k1rem=k1calc(nmod);
		int kans=add(mul(ndiv,ktmp),krem),k1ans=add(mul(ndiv,k1tmp),k1rem);
		ans=mul(2,k1ans);
		ans=sub(ans,mul(add(add(mul(nmod,2),2),qpow(2,k)),kans));
		krem=kcalc(mul(nmod,2)),k1rem=k1calc(mul(nmod,2));
		kans=add(mul(add(mul(ndiv,2),nmod>mod/2),ktmp),krem),k1ans=add(mul(add(mul(ndiv,2),nmod>mod/2),k1tmp),k1rem);
		ans=add(ans,mul(2*nmod+1,kans));
		ans=sub(ans,k1ans);
		ans=mul(ans,qpow(nmod,mod-2));
		printf("%d\n",ans);
	}
	else{
		int kans=kcalc(mod),k1ans=k1calc(mod);
		ans=mul(2,k1ans);
		ans=sub(ans,mul(add(2,qpow(2,k)),kans));
		ans=add(ans,mul(2,kans));
		ans=sub(ans,mul(2,k1ans));
		printf("%d\n",ans);
	}
}
```

---


# 差分与前缀和

## 题目描述

给定一个长为 $n$ 的序列 $a$，求出其 $k$ 阶差分或前缀和。    
结果的每一项都需要对 $1004535809$ 取模。

## 说明/提示

【数据范围】  

$1 \le n \le 10^5$  
$0 \le a_i \le 10^9$   
$1\le k \le 10^{2333}, k \not \equiv 0 \pmod{1004535809}$

## 样例 #1

### 输入

```
8 3 0
1 9 2 6 0 8 1 7```

### 输出

```
1 12 35 76 135 220 332 478 ```

## 样例 #2

### 输入

```
8 3 1
1 9 2 6 0 8 1 7```

### 输出

```
1 6 1004535787 26 1004535788 24 1004535780 28```

# 题解

## 作者：Soulist (赞：74)

~~这篇题解对于许多题解打表/一言概括得到的结论进行了充分的证明~~

我们将序列$a$看作一个$OGF$

$$F(x)=\sum_{i=0}^{\infty} a_i x^i$$

考虑计算前缀和，众所周知，只需要拿它乘以$G(x)=1+x^1+...+x^{\infty}$

根据一些等比数列求和的芝士我们知道$G(x)=\dfrac{1}{1-x}$

置于求它的差分，则拿$F$和$1-x$卷起来即可

好了那么$k$维前缀和呢？

$$F\times\dfrac{1}{(1-x)^k}$$

$k$维差分呢？

$$F\times (1-x)^k$$

好了然后求个$\ln$，乘个$k$，取个$\exp$这道题就做完了

但是非常不幸的是这样会非常难写而且我已经不会求$\ln$和$\exp$了（不要问我怎么清$0$，我也不会清$0$）

于是我们还是用点生成函数的技巧吧

首先是差分，它非常好做：

$$(1-x)^k$$

二项式定理强行打开使我们可以知道：

$$(1-x)^k=\sum_{i=0}^{\infty}(-1)^i\dbinom{k}{i}x^i$$

好的这道题真是见了鬼了$k$这么大搞什么。。。

不过这道题要用连续的组合数然而它可以递推

$\dbinom{k}{0}=1,\dbinom{k}{i}=\dbinom{k}{i-1}\times\dfrac{k-i+1}{i}$

然后大概$k$是可以直接取模的。。。

好了接下来是：

$$\dfrac{1}{(1-x)^k}$$

这个有点麻烦，需要借助广义二项式定理：

我们把它看作$(1-x)^{-k}$

根据广义二项式定理它等价于：

$$(1-x)^a=\sum_{i=0}^{\infty}\dbinom{a}{i}x^i$$

这个式子看上去挺对的。。。毕竟当$i>a$的时候$\dbinom{a}{i}=0..$不过现在我们不能用阶乘来定义组合数了，于是我们需要把它改成下降幂的形式：

$$\dbinom{a}{i}=\dfrac{a^{\underline{i}}}{i!}$$

注：$a^{\underline{i}}=a(a-1)(a-2)...(a-i+1)$

好的我们来看下$-k$代入进去是什么样的：

$$(1-x)^{-k}=\sum_{i=0}^{\infty}(-1)^i\dfrac{(-k)^{\underline{i}}}{i!}x^i$$

$$(1-x)^{-k}=\sum_{i=0}^{\infty}(-1)^{2i}\dfrac{(k+i-1)^{\underline{i}}}{i!}x^i$$

所以我们知道：

$$(1-x)^{-k}=\sum_{i=0}^{\infty}\dbinom{k+i-1}{i}x^i$$

好了于是对于差分我们只需要拿$F$和$\sum_{i=0}^{\infty}(-1)^i\dbinom{k}{i}x^i$卷起来即可

对于前缀和我们只需要拿$F$和$\sum_{i=0}^{\infty}\dbinom{k+i-1}{i}x^i$卷起来即可

当然这个什么$\dbinom{k+i-1}{i}$也可以递推，因为它是$\dfrac{(k+i-1)^{\underline{i}}}{i!}$，要递推的话也很简单，每次乘一个$(k+i-1)/i$即可

然后模数还是$\text{NTT}$模数。。。

~~实际上这篇题解是在做一些特别蠢的证明。。。~~

$Code:$

```cpp
#include<bits/stdc++.h>
using namespace std ;
#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )
#define re register
#define int long long
const int P = 1004535809 ;
const int Gi = 334845270 ; 
const int G = 3 ;
int gi() {
	char cc = getchar() ; int cn = 0, flus = 1 ;
	while( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }
	while( cc >= '0' && cc <= '9' )  cn = ( cn * 10 + cc - '0' ) % P, cc = getchar() ;
	return cn * flus ;
}
const int N = 1e5 + 5 ; 
int n, m, A[N << 2], B[N << 2], limit, L, Inv, R[N << 2] ; 
int fpow( int x, int k ) {
	int ans = 1, base = x ; 
	while( k ) {
		if( k & 1 ) ans = ( ans * base ) % P ; 
		base = ( base * base ) % P, k >>= 1 ; 
	} return ans ; 
}
void init( int x ) {
	limit = 1, L = 0 ; 
	while( limit <= x ) limit <<= 1, ++ L ; 
	rep( i, 0, limit ) R[i] = ( R[i >> 1] >> 1 ) | ( ( i & 1 ) << ( L - 1 ) ) ;
	Inv = fpow( limit, P - 2 ) ;
}
void NTT( int *a, int type ) {
	for( re int i = 0; i < limit; ++ i ) if( R[i] > i ) swap( a[i], a[R[i]] ) ;
	for( re int k = 1; k < limit; k <<= 1 ) {
		int d = fpow( ( type == 1 ) ? G : Gi, ( P - 1 ) / ( k << 1 ) ) ; 
		for( re int i = 0; i < limit; i += ( k << 1 ) ) 
		for( re int j = i, g = 1 ; j < i + k; ++ j, g = ( g * d ) % P ) {
			int Nx = a[j], Ny = ( a[j + k] * g ) % P ;
			a[j] = ( Nx + Ny ) % P, a[j + k] = ( Nx - Ny + P ) % P ; 
		} 
	}
	if( type != 1 ) rep( i, 0, limit ) a[i] = a[i] * Inv % P ; 
}
signed main()
{
	n = gi(), m = gi() ; int type = gi() ; 
	rep( i, 1, n ) A[i - 1] = gi() ; B[0] = 1 ; 
	if( type == 0 ) rep( i, 1, n ) B[i] = B[i - 1] * ( m + i - 1 ) % P * fpow( i, P - 2 ) % P ; 
	if( type == 1 ) rep( i, 1, n ) B[i] = ( -B[i - 1] * ( m - i + 1 + P ) % P * fpow( i, P - 2 ) % P + P ) % P ; 
	init( n + n ), NTT( A, 1 ), NTT( B, 1 ) ;
	rep( i, 0, limit ) A[i] = A[i] * B[i] % P ;
	NTT( A, -1 ) ; rep( i, 1, n ) printf("%lld ", A[i - 1] ) ;  
	return 0 ;
}
```

---

## 作者：NaCly_Fish (赞：17)

在我的多项式全家桶里面写的解法太过简略。。  
这里写一个详细又好理解的吧qwq
****

先来考虑前缀和。  

$$s_i=\sum\limits_{j=1}^ia_j$$  
把它和卷积的式子比较一下：  
$$s_i=\sum\limits_{j+k=i}a_jb_k$$  
我们发现：对 $a$ 做一次前缀和，相当于和一个系数全是 $1$ 的多项式做一次卷积。  

卷积是有结合律的，所以做 $k$ 次前缀和，要乘上去的多项式就是 
$$\frac{1}{(1-x)^k}$$  
容易证明这个式子的 $n$ 次项系数为 $\binom{n+k-1}{k-1}$，于是直接计算就可以啦 
****  
用类似的思路，来看差分的做法。  

可以得出做一次差分要卷积的式子是 $1-x$，$k$ 次就是 $(1-x)^k$，展开就是  
$$\sum\limits_{i=0}^k\binom{k}{i}(-1)^ix^i$$

要注意的是 $k$ 非常大，所以要先取模，然后直接递推计算多项式的系数。  
至于其正确性，用 Lucas 定理可以简单地证明在 $n<p$ 的时候正确。

~~是不是很简单呢？~~
```cpp
// luogu-judger-enable-o2
#include<cstdio> 
#include<iostream>
#include<cstring>
#include<algorithm>
#define ll long long
#define N 262147
#define LIM 262144
#define reg register
#define p 1004535809
using namespace std;

struct poly{
    int a[N];
    int t;
};

int rev[N],lg2[N],rt[N],irt[N],inv[N];

inline void read(int &x);
void print(int x);
inline int power(int a,int t);
inline int add(int a,int b);
inline int dec(int a,int b);
void init();
inline void NTT(poly &f,int type,int lim);

inline void mod_read(int &x){
	x = 0;
	char c = getchar();
	while(c<'0'||c>'9') c = getchar();
	while(c>='0'&&c<='9'){
		x = (((ll)x<<3)+(x<<1)+(c^48))%p;
		c = getchar();
	}
}

poly F,G;
int n,k,lim,type;

int main(){
    init();
    inv[1] = 1;
    read(n),mod_read(k),read(type);
    for(reg int i=0;i<n;++i) read(F.a[i]); 
    for(reg int i=2;i<n;++i) inv[i] = (ll)(p-p/i)*inv[p%i]%p;
    G.t = n-1,G.a[0] = 1;
    if(type==1){
        for(reg int i=1;i<n;++i)
            G.a[i] = (ll)G.a[i-1]*(dec(k,i)+1)%p*inv[i]%p;
        for(reg int i=1;i<n;++i)
            if(i&1) G.a[i] = G.a[i]?p-G.a[i]:0;
    }else{
        for(reg int i=1;i<n;++i)
            G.a[i] = (ll)G.a[i-1]*inv[i]%p*(i+k-1)%p;
    }
    lim = 1;
    while(lim<=((n-1)<<1)) lim <<= 1;
    NTT(F,1,lim),NTT(G,1,lim);
    for(reg int i=0;i!=lim;++i) F.a[i] = (ll)F.a[i]*G.a[i]%p;
    NTT(F,-1,lim);
    for(reg int i=0;i<n;++i) print(F.a[i]),putchar(' ');
    return 0;
}

inline void NTT(poly &f,int type,int lim){
    reg int w,y,l = lg2[lim]-1;
    for(reg int i=1;i!=lim;++i){
        rev[i] = (rev[i>>1]>>1)|((i&1)<<l);
        if(i>=rev[i]) continue;
        swap(f.a[i],f.a[rev[i]]);
    }
    l = LIM>>1;
    for(reg int mid=1;mid!=lim;mid<<=1){
        for(reg int j=0;j!=lim;j+=(mid<<1)){
            for(reg int k=0;k!=mid;++k){
                w = type==1?rt[l*k]:irt[l*k];
                y = (ll)w*f.a[j|k|mid]%p;
                f.a[j|k|mid] = dec(f.a[j|k],y);
                f.a[j|k] = add(f.a[j|k],y);
            }
        }
        l >>= 1;
    }
    if(type==1) return;
    y = power(lim,p-2);
    for(reg int i=0;i!=lim;++i) f.a[i] = (ll)f.a[i]*y%p;
}

void init(){
    for(reg int i=2;i<=LIM;++i) lg2[i] = lg2[i>>1]+1;
    rt[0] = 1,rt[1] = power(3,(p-1)/LIM);
    irt[0] = 1,irt[1] = power(rt[1],p-2);
    for(reg int i=2;i<=LIM;++i){
        rt[i] = (ll)rt[i-1]*rt[1]%p;
        irt[i] = (ll)irt[i-1]*irt[1]%p;
    }
}

inline int add(int a,int b){
    return a+b>=p?a+b-p:a+b;
}

inline int dec(int a,int b){
    return a<b?a-b+p:a-b;
}

inline int power(int a,int t){
    int res = 1;
    while(t){
        if(t&1) res = (ll)res*a%p;
        a = (ll)a*a%p;
        t >>= 1;
    }
    return res;
}

inline void read(int &x){
    x = 0;
    char c = getchar();
    while(c<'0'||c>'9') c = getchar();
    while(c>='0'&&c<='9'){
        x = (x<<3)+(x<<1)+(c^48);
        c = getchar();
    }
}

void print(int x){
    if(x>9) print(x/10);
    putchar(x%10+'0');
}
```

---

## 作者：Nemlit (赞：8)

~~Karry怒骂此题是多项式板子？？？~~

你要是看出这道题是多项式了也就不麻烦了

$ps:$本题解均用0为数组下标，以方便多项式运算，所以公式可能和其他题解略有不同

首先先考虑前缀和：

考虑前缀和的定义式：$c_k=\sum_{i=0}^ka_i$

把他变下型，我们有：$c_k=\sum_{i+j=k}a_i*b_j$（其中$b_j=1$）

不难发现这是一个等价的形式，于是我们可以利用$NTT$进行优化，于是现在问题就转化成求$b_i$

对于$k=1$的情况，那$b$是一个系数全部为1的多项式，由于卷积满足结合律，所以我们可以求出b这个多项式的k次方后与a数组卷起来

考虑每一位的贡献，用手玩一下，会发现这其实是一个斜着的杨辉三角，可以用数学归纳法证明，打出来的表如下：
```
1   1   1   1   1   1
1   2   3   4   5   6
1   3   6   10  15  21
1   4   10  20  35  56
1   5   15  35  70  126
1   6   21  56  126 252
```

于是我们可以得出递推式：对于第i位对k维前缀和的贡献为$\dbinom{k+i-1}{i}$

由于k很大，但是我们需要求得项不多，我们可以用递推求出上式，读入k的时候取个膜就行了

然后考虑差分（其实没有本质区别）：

考虑差分定义式：$c_k=a_k-a_{k-1}$

还是转化一下：$c_k=\sum_{i+j=k}a_i*b_j$（$b_0=1, b_1=-1$）

还是可以用卷积优化，还是打一个表，对于第i位对k维前缀和的贡献为$\dbinom{k}{i}*(-1)^i$，用递推求解即可

## $Code:$
```
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define re register
#define int long long
#define mod 1004535809
il int read() {
    re int x = 0, f = 1; re char c = getchar();
    while(c < '0' || c > '9') { if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - 48, x %= mod, c = getchar();
    return x * f;
}
#define rep(i , a , b) for(int i = (a) , i##Limit = (b) ; i <= i##Limit ; ++ i)
#define maxn 500005
int n, k, opt, a[maxn], b[maxn], inv, lim, r[maxn];
il int qpow(int a, int b)  {
    int r = 1;
    while(b) {
        if(b & 1) r = (r * a) % mod;
        a = (a * a) % mod, b >>= 1;
    }
    return r;
}
il int mul(int a, int b) { return a * b % mod; }
il void NTT(int*a, int f) {
	rep(i, 0, (1 << lim) - 1) if(r[i] > i) swap(a[i], a[r[i]]);
	for(re int mid = 1; mid < (1 << lim); mid <<= 1) {
		int base = qpow(f == 1 ? 3 : inv, (mod - 1) / (mid << 1));
		for(re int p = mid * 2, j = 0; j < (1 << lim); j += p) {
			int w = 1;
			for(re int k = 0; k < mid; ++ k, w = mul(w, base)) {
				int x = a[j + k], y = mul(w, a[j + k + mid]);
				a[j + k] = (x + y) % mod, a[j + k + mid] = (x - y + mod) % mod;
			}
		}
	}
}
signed main() {
	n = read(), k = read(), opt = read(), inv = qpow(3, mod - 2), b[0] = 1;
	rep(i, 0, n - 1) a[i] = read();
	if(opt == 0) rep(i, 1, n - 1) b[i] = mul(mul(b[i - 1], qpow(i, mod - 2)), k + i - 1);
	else rep(i, 1, n - 1) b[i] = mul(mul(b[i - 1], qpow(i, mod - 2)), k - i + 1);
	if(opt == 1) for(re int i = 1; i < n; i += 2) b[i] = -b[i];
	rep(i, 1, n - 1) b[i] = (b[i] + mod) % mod;
	while((1ll << lim) < n * 2) ++ lim;
	rep(i, 0, (1 << lim) - 1) r[i] = (r[i >> 1] >> 1) | ((i & 1) << (lim - 1));
	NTT(a, 1), NTT(b, 1);
	rep(i, 0, (1 << lim) - 1) a[i] = mul(a[i], b[i]);
	NTT(a, -1), inv = qpow((1 << lim), mod - 2);
	rep(i, 0, n - 1) printf("%lld ", (mul(a[i], inv) + mod) % mod);
	return 0;
}
```

---

## 作者：feecle6418 (赞：6)

来一发大常数 exp 解法。

求前缀和相当于 $a_i\leftarrow \sum_{j<i} a_j$，也就是给多项式 $A$ 乘上 $1+x+x^2+\cdots$ 即 $\dfrac{1}{1-x}$。求 $k$ 阶前缀和即是求 $A\times \dfrac{1}{(1-x)^k}$。

求差分相当于 $a_i\leftarrow a_{i-1}-a_i$，也就是给多项式 $A$ 乘上 $(1-x)$。求 $k$ 阶差分即是求 $A\times (1-x)^k$。

怎么算多项式 $k$ 次方？ln 化乘为加再 exp 回来即可。

代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<complex>
const int mod=1004535809,g=3,invg=1004535810/3;
using namespace std;
int a[400005],b[400005],c[400005],k,t,n,m,tr[400005],wk[400005];
int read() {
    char ch=getchar();
    int x=0;
	while(ch<'0'||'9'<ch)ch=getchar();
    while('0'<=ch&&ch<='9')x=(10ll*x+ch-'0')%mod,ch=getchar();
    return x;
}
int Power(int x,int y,int mod) {
	int ret=1;
	while(y) {
		if(y&1)ret=1ll*ret*x%mod;
		x=1ll*x*x%mod,y>>=1;
	}
	return ret;
}
void GetTr(int l) {
	for(int i=0; i<l; i++)tr[i]=(tr[i>>1]>>1)|((i&1)?(l>>1):0);
}
void NTT(int a[],int n,int flag) {
	for(int i=0; i<n; i++)if(tr[i]<i)swap(a[i],a[tr[i]]);
	for(int i=1; i<n; i<<=1) {
		int w=Power(flag==1?g:invg,(mod-1)/(i<<1),mod);
		wk[0]=1;
		for(int j=1; j<i; j++)wk[j]=1ll*wk[j-1]*w%mod;
		for(int j=0; j<n; j+=(i<<1)) {
			for(int k=0; k<i; k++) {
				int t=1ll*wk[k]*a[i+j+k]%mod;
				a[i+j+k]=(a[j+k]-t+mod)%mod;
				a[j+k]=(a[j+k]+t)%mod;
			}
		}
	}
	if(flag==-1)for(int i=0,t=Power(n,mod-2,mod); i<n; i++)a[i]=1ll*a[i]*t%mod;
}
void Calcinv(int a[],int b[],int l){
	if(l==1){
		b[0]=Power(a[0],mod-2,mod);
		return ;
	}
	Calcinv(a,b,(l+1)/2);
	int len=1;
	while(len<l*2)len<<=1;
	GetTr(len);
	static int tmp[400005]={0};
	memcpy(tmp,a,sizeof(int)*l);
	for(int i=l;i<len;i++)tmp[i]=0;
	NTT(tmp,len,1),NTT(b,len,1);
	for(int i=0;i<len;i++)b[i]=(2-1ll*tmp[i]*b[i]%mod+mod)%mod*b[i]%mod;
	NTT(b,len,-1);
	for(int i=l;i<len;i++)b[i]=0;
}
void Calcln(int a[],int b[],int l){
	static int tmp[400005]={0};
	memcpy(tmp,a,sizeof(int)*l);
	for(int i=1;i<l;i++)tmp[i-1]=1ll*tmp[i]*i%mod;
	tmp[l-1]=0;
	Calcinv(a,b,l);
	int len=1;
	while(len<l*2)len<<=1;
	GetTr(len);
	for(int i=l;i<len;i++)tmp[i]=0;
	NTT(b,len,1),NTT(tmp,len,1);
	for(int i=0;i<len;i++)b[i]=1ll*tmp[i]*b[i]%mod;
	NTT(b,len,-1);
	for(int i=l;i<len;i++)b[i]=0;
	for(int i=l-1;i>0;i--)b[i]=1ll*b[i-1]*Power(i,mod-2,mod)%mod;
	b[0]=0;
}
void Calcexp(int a[],int b[],int l){
	if(l==1){
		b[0]=1;
		return ;
	}
	static int tmp[400005]={0},ln[400005]={0};
	Calcexp(a,b,(l+1)/2);
	Calcln(b,ln,l);
	memcpy(tmp,a,sizeof(int)*l);
	int len=1;
	while(len<=l*1.5)len<<=1;
	GetTr(len);
	NTT(tmp,len,1),NTT(ln,len,1),NTT(b,len,1);
	for(int i=0;i<len;i++)b[i]=1ll*b[i]*(1ll-ln[i]+tmp[i]+mod)%mod;
	NTT(b,len,-1);
	fill(b+l,b+len,0);
	fill(tmp,tmp+len,0);
	fill(ln,ln+len,0);
}
int main() {
	scanf("%d",&n);
	k=read();
	scanf("%d",&t); 
	for(int i=0;i<n;i++)scanf("%d",&a[i]);
	b[0]=1,b[1]=mod-1;
	Calcln(b,c,n);
	for(int i=0;i<n;i++)c[i]=1ll*c[i]*k%mod;
	memset(b,0,sizeof(b));
	Calcexp(c,b,n);
	if(!t)memset(c,0,sizeof(c)),Calcinv(b,c,n),memcpy(b,c,sizeof(c));
	int l=1;
	while(l<n*2)l<<=1;
	NTT(a,l,1),NTT(b,l,1);
	for(int i=0;i<l;i++)a[i]=1ll*a[i]*b[i]%mod;
	NTT(a,l,-1);
	for(int i=0;i<n;i++)printf("%d ",a[i]);
	return 0;
}
```

---

## 作者：Durancer (赞：5)

# P5488 差分与前缀和 题解

标签： 多项式

---

### 前言

一个牛顿二项式定理的应用，掌握好这个题目对组合数学有一定的帮助。

自认为是特别详细了。

### 前置知识

1、牛顿二项式定理(加个正号防止有歧义)。

$$(1+x)^{\alpha}=\sum_{i=0}^{\infty}\binom{\alpha}{i}(+x)^i$$

$$\binom{n}{m}=\frac{n^{\underline{m}}}{m!}=\frac{\frac{n!}{(n-m)!}}{m!}$$

2、NTT。

3、生成函数（会封闭形式）。

4、$n$ 阶前缀和以及 $n$ 阶差分。

举个例子： $1$ 阶前缀和是我们所熟知的一维前缀和， $2$ 阶前缀和就是 $1$ 阶前缀和的前缀和，依次类推，$n$ 阶前缀和是 $n-1$ 阶前缀和的前缀和，差分同理可得。 

### 思路

首先，众所周知的是，将要求前缀和的序列的值依次代到 $F(x)$ 的系数中去，通过与 $G(x)=\sum_{i=0}^{\infty}x^i$ 相乘，可以得到序列的前缀和（我一般习惯从 $1$ 开始代入）。

先从前缀和开始讲起：

设 $F(x)$ 为当前已经代入了系数的多项式，与 $G(x)$ （意义同上） 相乘得到：

$$F(x)\times G(x)=F(x)\times\sum_{i=0}^{\infty}x^i$$

$$=F(x)\times \frac{1}{1-x}$$

那么每一项的系数就是序列从 $1 …i$ 的 $1$ 阶前缀和啦。

至于 $k$ 阶前缀和，即要对初始的多项式做 $k$ 次同样的操作，也就是下面的式子。

$$F(x)\times (\frac{1}{1-x})^k$$
 
通过牛顿二项式定理把这个式子给拆开。

$$F(x)\times (\frac{1}{1-x})^k=F(x)\times (1-x)^{-k} $$

$$=F(x)\times \sum_{i=0}^{\infty}\binom{-k}{i}(-x)^i$$

$$=F(x)\times \sum_{i=0}^{\infty}(-1)^i\frac{\frac{(-k)!}{(-k-i)!}}{i!}x^i$$

$$=F(x)\times \sum_{i=0}^{\infty}(-1)^i\frac{(-k-i+1)(-k-i+2)(-k-i+3)…(-k)}{i!}x^i$$

在这里需要说一下的是,上面坟墓上，当枚举到 $i$ 的时候，上面一共有 $i$ 个数，也就是奇数时有奇数个，偶数时有偶数个，分两种情况讨论一下:

1、当为奇数个的时候，上面的式子一看每一项一定是负数 $(k>0)$ 的，奇数的时候提出奇数个负号来，所以上面还带着一个负号没有消去，而此时，$(-1)^i=-1$  负号全部消掉，变为正的。

2、当为偶数个的时候，上面可以提出偶数个负号来，全部消掉，而此时 $(-1)^i=1$ 忽略不管。

通过上面的讨论可以得到的是：

$$=F(x) \times \sum_{i=0}^{\infty}\frac{(k+i-1)(k+i-2)…[k+i-(i-1)]k}{i!}x^i$$

$$=F(x) \times \sum_{i=0}^{\infty}\frac{\frac{(k+i-1)!}{(k+i-1-i)!}}{i!}x^i$$

$$=F(x) \times \sum_{i=0}^{\infty}\binom{k+i-1}{i}x^{i}$$

由此可以得到最终式子，由于 $k$ 过大，肯定不可以直接算出来，所以要考虑递推求解啦，顺便把递推式扔在下面：

$$\binom{k-1}{0}=1$$

$$\binom{k}{1}=\frac{k!}{(k-1)!}=k$$

$$\binom{k+1}{2}=\frac{(k+1)!}{2!(k-1)!}=\frac{k(k+1)}{2}$$

$$\binom{k+2}{3}=\frac{(k+2)!}{3!(k-1)!}=\frac{k(k+1)(k+2)}{2\times 3}$$

由此可以得到：

$$\binom{k+i-1}{i}=\binom{k+i-2}{i-2}\times \frac{k+i-1}{i}$$

式子和递推式都推出来了，猴子应该也会做了，一边裸的 $\text{NTT}$ 就可以了。

接下来看差分，既然前缀和是 $\dfrac{1}{1-x}$，那么差分就是 $(1-x)$ 啦。

差分其实和前缀和差不多，不过还是来详细推导一下公式吧。

$$F(x)\times (1-x)^k=F(x)\times \sum_{i=0}^{\infty} \binom{k}{i}(-x)^i$$

$$=F(x)\times \sum_{i=0}^{\infty}(-1)^i \binom{k}{i}\ x^i  $$

已经化为最简形式了，所以最后再扔一个递推式验算过程：

$$\binom{k}{0}=1$$

$$\binom{k}{1}=\frac{k!}{(k-1)!}=k$$

$$\binom{k}{2}=\frac{k!}{2!(k-2)!}=\frac{k(k-1)}{2}$$

$$\binom{k}{3}=\frac{k!}{3!(k-3)!}=\frac{k(k-1)(k-2)}{2\times 3}$$

$$\binom{k}{i}=\binom{k}{i-1}\times \frac{(k-i+1)}{i}$$

最后，这个题就圆满结束啦！


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<stack>
#define int long long 
using namespace std;
const int N=4e5+9;
const int mod=1004535809;
const int g[]={3,334845270};
int a[N],b[N];
int r[N];
int term=1,l;
int n,k,t;
int inv[N];
int read()//快读要经过模处理
{
	int f=1,x=0;
	char s=getchar();
	while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}
	while(s>='0'&&s<='9'){x=((x<<1)+(x<<3)+(s^'0'))%mod;s=getchar();}
	return f*x%mod;
}
int quick(int x,int p)
{
	int ret=1;
	while(p)
	{
		if(p&1) ret=ret*x%mod;
		x=x*x%mod;
		p>>=1;
	}
	return ret%mod;
}
void NTT(int *A,int type)
{
	for(int i=0;i<term;i++)
		if(i<r[i])
			swap(A[i],A[r[i]]);
	for(int mid=1;mid<term;mid<<=1)
	{
		int R=mid<<1;
		int Wn=quick(g[type],(mod-1)/R);
		for(int j=0;j<term;j+=R)
		{
			int w=1;
			for(int k=0;k<mid;k++,w=w*Wn%mod)
			{
				int x=A[j+k]%mod;
				int y=w*A[j+k+mid]%mod;
				A[j+k]=(x+y)%mod;
				A[j+k+mid]=(x-y+mod)%mod;
			}
		}	
	}
	if(type==1)
	{
		int inv=quick(term,mod-2);
		for(int i=0;i<term;i++)
			A[i]=A[i]*inv%mod; 
	}
	return;
}
void less_than_break()()//差分
{
	b[0]=1;
	inv[1]=1;
	for(int i=2;i<=n;i++)
		inv[i]=(mod-mod/i)*inv[mod%i]%mod;
	for(int i=1;i<=n;i++)
		b[i]=-b[i-1]*(k-i+1+mod)%mod*inv[i]%mod;
	NTT(a,0);
	NTT(b,0);
	for(int i=0;i<term;i++)
		a[i]=a[i]*b[i]%mod;
	NTT(a,1);
	for(int i=1;i<=n;i++)
		printf("%lld ",a[i-1]);
}
void frontsum()//前缀和
{
	b[0]=1;
	inv[1]=1;
	for(int i=2;i<=n;i++)
		inv[i]=(mod-mod/i)*inv[mod%i]%mod;
	for(int i=1;i<=n;i++)
		b[i]=b[i-1]*(k+i-1)%mod*inv[i]%mod;
	NTT(a,0);
	NTT(b,0);
	for(int i=0;i<term;i++)
		a[i]=a[i]*b[i]%mod;
	NTT(a,1);
	for(int i=1;i<=n;i++)
		printf("%lld ",a[i-1]);
}
signed main()
{
	n=read();
	k=read();
	t=read();
	for(int i=1;i<=n;i++)
		a[i-1]=read();
	while(term<=2*n)
	{
		term<<=1;
		l++;
	}
	for(int i=0;i<term;i++)
		r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));
	if(t==1) less_than_break();
	else frontsum();
	return 0;
}
```


---

## 作者：AThousandSuns (赞：4)

先 % 一波人

% NaCly_Fish 总是出毒瘤模板（不过这道题挺良心的）

% iostream 目前 rk1

% AThousandMoon 5 分钟码完

---
又有新模板了呢。

不过这东西为什么要叫模板……

注意，我感觉我推的比较臃肿，可以看别的神仙的题解，毕竟我是菜鸡……

---
先看前缀和部分。

考虑 $j$ 对 $i$ 的贡献系数，可以理解成第一次前缀和时 $j$ 对 $p_1$ 有贡献，第二次前缀和时 $p_1$ 对 $p_2$ 有贡献……第 $k$ 次前缀和时 $p_{k-1}$ 对 $i$ 有贡献。

那么就是求长度为 $k-1$ 的序列 $p$ 使得 $j\le p_1\le p_2\le\dots\le p_{k-1}\le i$，求个数。

根据~~小学奥数~~隔板法可得 $\binom{i-j+k-1}{k-1}$。

那么有：（这里我让下标从 $0$ 开始）
$$b_i=\sum\limits_{j=0}^ia_j\binom{i-j+k-1}{k-1}$$
$$b_i=\frac{1}{(k-1)!}\sum\limits_{j=0}^ia_j\frac{(i-j+k-1)!}{(i-j)!}$$

后面卷积一波带走。

---
差分也很简单。

考虑 $j$ 对 $i$ 的贡献系数，也就是 $0$ 对 $i-j$ 的贡献系数。我就直接写递推式了：

$f_{i,j}$ 表示 $i$ 阶差分时 $0$ 对 $j$ 的贡献系数。

$$f_{i,j}=f_{i-1,j}-f_{i-1,j-1}$$

看到这个式子很容易（真的很容易）想到令 $g_{i,j}=(-1)^jf_{i,j}$。

$$(-1)^jg_{i,j}=(-1)^jg_{i-1,j}-(-1)^{j-1}g_{i-1,j-1}$$

$$g_{i,j}=g_{i-1,j}+g_{i-1,j-1}=\binom{i}{j}$$

所以有 $f_{i,j}=(-1)^j\binom{i}{j}$。

（理解不了上面的式子的，可以组合意义来理解。从左上角开始走，每次可以往下或往右下走，往下的贡献系数不变，往右下的贡献系数取相反数。问走到 $(i,j)$ 的贡献系数。如果没有取相反数，大家都知道是 $\binom{i}{j}$。因为肯定恰好往右下走了 $j$ 次，所以就是 $(-1)^j\binom{i}{j}$。）

所以有：
$$b_i=\sum\limits_{j=0}^ia_jf_{k,i-j}$$
$$b_i=\sum\limits_{j=0}^ia_j(-1)^{i-j}\binom{k}{i-j}$$
$$b_i=(-1)^ik!\sum\limits_{j=0}^ia_j(-1)^j\frac{1}{(i-j)!(k-(i-j))!}$$

后面还是一个卷积。

时间复杂度都是 $O(n\log n)$。
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=333333,mod=1004535809;
#define FOR(i,a,b) for(int i=(a);i<=(b);i++)
#define ROF(i,a,b) for(int i=(a);i>=(b);i--)
#define MEM(x,v) memset(x,v,sizeof(x))
inline int read(){
    int x=0,f=0;char ch=getchar();
    while(ch<'0' || ch>'9') f|=ch=='-',ch=getchar();
    while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();
    return f?-x:x;
}
int n,tp,k,a[maxn],lim,l,rev[maxn],b[maxn],fac[maxn],invfac[maxn];
inline int add(int a,int b){return a+b<mod?a+b:a+b-mod;}
inline int sub(int a,int b){return a<b?a-b+mod:a-b;}
inline int mul(int a,int b){return 1ll*a*b%mod;}
inline int qpow(int a,int b){
	int ans=1;
	for(;b;b>>=1,a=mul(a,a)) if(b&1) ans=mul(ans,a);
	return ans;
}
void init(int upr){
	for(lim=1,l=0;lim<upr;lim<<=1,l++);
	FOR(i,0,lim-1) rev[i]=(rev[i>>1]>>1)|((i&1)<<(l-1)); 
}
void NTT(int *A,int tp){
	FOR(i,0,lim-1) if(i<rev[i]) swap(A[i],A[rev[i]]);
	for(int i=1;i<lim;i<<=1)
		for(int j=0,r=i<<1,Wn=qpow(3,mod-1+tp*(mod-1)/r);j<lim;j+=r)
			for(int k=0,w=1;k<i;k++,w=mul(w,Wn)){
				int x=A[j+k],y=mul(A[i+j+k],w);
				A[j+k]=add(x,y);A[i+j+k]=sub(x,y);
			}
	if(tp==-1){
		int linv=qpow(lim,mod-2);
		FOR(i,0,lim-1) A[i]=mul(A[i],linv);
	}
}
namespace DIF{
	void solve(){
		FOR(i,0,n-1) if(i&1) a[i]=(mod-a[i])%mod;
		FOR(i,0,k) b[i]=mul(invfac[i],invfac[k-i]);
		init(n<<1);
		NTT(a,1);NTT(b,1);
		FOR(i,0,lim-1) a[i]=mul(a[i],b[i]);
		NTT(a,-1);
		FOR(i,0,n-1){
			int prod=mul(fac[k],a[i]);
			if(i&1) prod=(mod-prod)%mod;
			printf("%d ",prod);
		} 
	}
}
namespace PRE{
	void solve(){
		FOR(i,0,n-1) b[i]=mul(fac[i+k-1],invfac[i]);
		init(n<<1);
		NTT(a,1);NTT(b,1);
		FOR(i,0,lim-1) a[i]=mul(a[i],b[i]);
		NTT(a,-1);
		FOR(i,0,n-1) printf("%d ",mul(a[i],invfac[k-1]));
	}
}
int main(){
	n=read();k=read();tp=read();
	FOR(i,0,n-1) a[i]=read();
	fac[0]=1;
	FOR(i,1,n+k) fac[i]=mul(fac[i-1],i);
	invfac[n+k]=qpow(fac[n+k],mod-2);
	ROF(i,n+k-1,0) invfac[i]=mul(invfac[i+1],i+1);
	if(tp) DIF::solve();
	else PRE::solve();
}
```

---

## 作者：W123789 (赞：3)

### 前置知识

1.生成函数。

2.广义二项式定理：$(1-x)^a=\sum\limits_{i=0}^{\infty}\dbinom{a}{i}x^i$。

3.快速数论变换，$NTT$。



(1)前缀和。

设原序列的普通生成函数为 $F(x)=\sum\limits_{i=0}^\infty a_ix^i$。

对原序列进行一次前缀和,设 $p_k=\sum\limits_{i=0}^ka_i$，其中 $a_0=0$。

把$p_k$变换为卷积的形式： $p_k=\sum\limits_{i=0}^k a_ib_{k-i}$。

对比原式可以发现，$b_i$ 为任意一项都是 $1$ 的多项式,则 $b$ 的生成函数为 $G(x)=\sum\limits_{i=0}^\infty x^i$。

转换为封闭形式:左右两边同时乘 $x$，得到 $x\times G(x)=\sum\limits_{i=1}^\infty x^i$。

加入 $x^0$，得到: $x\times G(x)=\sum\limits_{i=0}^\infty x^i-1=G(x)-1$。

$x\times G(x)=G(x)-1,1=(1-x)\times G(x)$。

从而 $G(x)=\frac1{1-x}$。

对于每一次前缀和,都相当于与 $\frac1{1-x}$ 进行卷积,则 $k$ 次相当于与 $\frac{1}{(1-x)^k}$ 进行卷积。

答案为 $F × \frac1{(1-x)^k}=F×(1-x)^{-k}$。

此时可以直接使用 exp 解决,然而代码冗长,常数巨大。

考虑用广义二项式定理化简：$(1-x)^{-k}=\sum\limits_{i=0}^\infty(-1)^i\dbinom{-k}{i}x^i$

$=\sum\limits_{i=0}^\infty(-1)^{2i}\dbinom{k+i-1}{i}x^i$

$=\sum\limits_{i=0}^\infty\dbinom{k+i-1}{i}x^i$

可以递推预处理：$\dbinom{k-1}{0}=1,\dbinom{k+i-2}{i-1}×\frac{k+i-1}{i}=\dbinom{k-i+1}{i}$。


(2)差分。

由于差分与前缀和的特殊关系,差分的生成函数是 $(1-x)^k$。

使用二项式定理展开: $(1-x)^k=\sum\limits_{i=0}^k\dbinom{k}{i}(-1)^ix^i$。
同样递推预处理: $\dbinom{k}{i}=\dbinom{k}{i-1}*\frac{n-i+1}{i}$。

还有最后一个问题，$k\le10^{2333}$。

我们可以知道,当 $k≡0(\bmod p),\dbinom{k}{x}≡0(\bmod p)$。

为啥?由组合数的定义式可以知道，$\dbinom{k}{x}=\frac{k!}{x!(k-x)!}=k!×(x!(k-x)!)^{-1},∵k≡0\pmod{p},∴k!≡0\pmod{p}$，从而 $\dbinom{k}{x}≡0(mod\ p)$。

可以做出贡献的只有 $\dbinom{k \bmod p}{x}$。

我们用快读的思想,边读边模,就可以解决问题了。

代码如下:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int P=1004535809,G=3,Gi=334845270;
inline int qpow(int a,int b){
	int ans=1;
	while(b){
		if(b&1) ans=1ll*ans*a%P;
		a=1ll*a*a%P;
		b>>=1;
	}
	return ans;
}
inline int read(){
	int s=0;
	bool f=1;
	static char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		s=(s<<3)+(s<<1)+(ch^48);
		ch=getchar();
	}
	return f==1?s:-s;
}
inline int mod_read(){
	int s=0;
	bool f=1;
	static char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		s=(s<<3)+(s<<1)+(ch^48);
		s%=P;
		ch=getchar();
	}
	return f==1?s:-s;
}
int Lim=1,L=0;
int inv[1<<18],rev[1<<18];
inline void init(int n){
	while(Lim<=(n<<1)) Lim<<=1,++L;
	for(int i=1;i<Lim;i++) rev[i]=(rev[i>>1]>>1)|((i&1)<<(L-1));
	inv[1]=1;
	for(int i=2;i<=n;i++) inv[i]=1ll*(P-P/i)*inv[P%i]%P;
}
inline void NTT(int *A,int Lim,int on){
	for(int i=0;i<Lim;i++)
		if(i<rev[i]) swap(A[i],A[rev[i]]);
	for(int h=1;h<Lim;h<<=1){
		int wn=qpow(on==1?G:Gi,(P-1)/(h<<1));
		for(int j=0;j<Lim;j+=(h<<1)){
			int w=1;
			for(int k=0;k<h;k++){
				int x=A[j|k],y=w*A[j|k|h]%P;
				A[j|k]=(x+y)%P;
				A[j|k|h]=(x-y+P)%P;
				w=w*wn%P;
			}
		}
	}
	if(on==-1){
		int inv=qpow(Lim,P-2);
		for(int i=0;i<Lim;i++) A[i]=A[i]*inv%P;
	}
}
int A[1<<18],B[1<<18];
signed main(){
	int n,k,type;
	n=read(),k=mod_read(),type=read();
	init(n);
	for(int i=0;i<n;i++) A[i]=read();
	B[0]=1;
	if(type==0)
		for(int i=1;i<=n;i++) B[i]=B[i-1]*(k+i-1)%P*inv[i]%P;
	else for(int i=1;i<=n;i++) B[i]=(-B[i-1]*(k-i+1+P)%P*inv[i]%P+P)%P;
	NTT(A,Lim,1);NTT(B,Lim,1);
	for(int i=0;i<Lim;i++) A[i]=A[i]*B[i]%P;
	NTT(A,Lim,-1);
	for(int i=0;i<n;i++) printf("%lld ",A[i]);
	return 0;
} 

```

~~蒟蒻第一次写题解,求通过~~

---

## 作者：FutaRimeWoawaSete (赞：2)

以后一定开警告。

考虑利用生成函数，首先将 $\text F$ 写成生成函数的形式：

$F(x) = \sum_{i = 0}^{+\infty}a_ix ^ i$

接着考虑如何得到一阶前缀和，显然就是让 $F(x)$ 卷上 $G(x) = \sum_{i = 0} ^{+\infty}x^i = \frac{1}{1 - x}$。

而由于差分和前缀和为逆运算所以差分的生成函数就是 $G'(x) = 1 - x$。

由于几阶就是滚几次前缀和/差分，所以我们最后得到的两个生成函数就是 $\frac{1}{(1 - x) ^ k}$ 以及 $(1 - x) ^ k$。

将 $\frac{1}{(1 - x) ^ k}$ 写成 $(1 - x) ^ {-k}$，根据广义二项式定理直接展开两个生成函数：

$(1 - x) ^ k = \sum_{i = 0} ^ {+\infty} (-1) ^ iC_k^ix^i$

由于只求序列前 $n$ 项前缀和，所以我们直接递推 $(-1)^iC_k^i$ 递推到第 $n$
项即可。

$(1 - x) ^ {-k} = \sum_{i = 0} ^ {+\infty} (-1)^iC_{-k}^ix^i = \sum_{i = 0} ^ {+\infty}(-1)^i\frac{(-k)^{\underline i}}{i!}x^i = \sum_{i=0} ^ {+\infty} (-1)^{2i}\frac{(k + i - 1)^{\underline i}}{i!}x^i$

发现仍然可以递推得到系数。

最后将系数多项式与原序列对应的多项式卷在一起即可。



---

## 作者：zhanxianyun (赞：0)

（多项式好题）

我们假设原数列有无穷多项（下标从 $0$ 开始），为

$a_0,a_1,a_2,a_3,  \cdots ,a_n \cdots$

构造一个多项式

$A(x) = a_0+a_1x+a_2x^2+ \cdots+a_nx^n+ \cdots$

再构造一个关于前缀和的多项式      
$f(x) = sum_0+sum_1x+sum_2x^2+ \cdots +sum_nx^n+ \cdots$

其中    $sum_i = \sum_{j=0}^{k} a_j$ （就是前缀和）

尝试用  $A(x)$  求  $f(x)$ ，我们先把 $f(x)$ 乘上 $x$ ，然后再错位相减

$xf(x) =sum_0x+sum_1x^2+sum_2x^3+\cdots +sum_nx^{n+1}+\cdots$

然后错位相减便可以得到			（$sum_i - sum_{i-1} = a_i$）:

$f(x) - xf(x) = A(x)$



略解一下便可以得到：

 $f(x)=\frac{A(x)}{1-x}$

 $1$  阶前缀和就是  $\frac{A(x)}{1-x}$，$k$ 阶前缀和只要迭代下去，就很容易得到    $\frac{A(x)}{(1-x)^k}$

剩下的就是  $NTT$ 	快速幂，逆元，乘法的板子了

同样的方法可以构造一个关于差分的多项式
$g(x) = d_0+d_1x+d_2x^2+\cdots +d_nx^n+\cdots$

其中	$d_0=a_0,d_i = a_i-a_{i-1}$

稍微不一样的方法错位相减，我们把	$A(x)$	 乘上 	$x$ 	，就可以得到

$xA(x)= a_0x+a_1x^2+a_2x^3+\cdots+a_nx^{n+1}+\cdots$

$A(x) - xA(x) = g(x)$

$g(x)=A(x) \cdot (1-x)$

一阶差分就是	

$g(x)=A(x) \cdot (1-x)$	，

迭代下去就可以得到 $k$ 阶差分就是 	

$g(x)=A(x) \cdot (1-x)^k$

这次就不用求逆元了

代码的话两百多行，放个链接吧（不开  O2 会 T  ，但现在比赛应该会开   O2  吧）
[https://www.luogu.com.cn/paste/tecgwa4x](https://www.luogu.com.cn/paste/tecgwa4x)



---

## 作者：KAMIYA_KINA (赞：0)

## Tag

多项式，生成函数。

## Preface

这里是 $\exp$ 的暴力做法解释，不开 $\text{O2}$ 会 T 飞。

## Description

求出一个数列 $\{a_n\}$ 的 $k$ 维前缀和或者差分。

## Solution

对于前缀和我们很容易就可以知道前缀和的生成函数是

$$
F(x)=\dfrac{1}{1-x}=\sum_{i=0}^\infty x^i
$$

差分的生成函数就是

$$
G(x)=1-x
$$

那么我们借用一下矩阵快速幂的想法，是不是说将这个前缀和或者差分的生成函数 $k$ 次方，然后直接乘上原数列就可以得到答案了。

具体一点，我们设原序列的生成函数为

$$
H(x)=\sum_{i=0}^na_ix^i
$$

那么答案的生成函数就是

$$
A(x)=H(x)\times F(x)^k
$$

或者

$$
A(x)=H(x)\times G(x)^k
$$

那么根据多项式快速幂的做法，我们可以先 $\ln$，然后每个数乘上 $k$，最后 $\exp$ 回去，就做完了。

$$
A(x)=H(x)\exp(k\ln F(x))
$$

所以代码异常的暴力，虽然复杂度是 $O(n\lg n)$ 的，但是由于 $\exp$ 的常数巨大，导致跑的异常慢，不过由于我是 `vector` 实现的，所以开了 $\text{O2}$ 之后常数就小了一些。~~不过还是超级慢啊~~。

## Code
~~~cpp
#include <bits/stdc++.h>

using namespace std;

#define int long long

#define FOR(i,a,b) for(int i=(a),i##i=(b);i<=i##i;i++)
#define ROF(i,a,b) for(int i=(a),i##i=(b);i>=i##i;i--)

const int N = 5e5 + 1;
const int mod = 1004535809, g = 3;

#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++)
char buf[100000], *p1(buf), *p2(buf);
#define rd read()
inline int read() {
    int x = 0, f = 1;
    char ch = gc;
    while(!isdigit(ch)) {
        if(ch == '-') f = 0;
        ch = gc;
    }
    while(isdigit(ch)) {
        x = ((x << 1) + (x << 3) + (ch ^ 48)) % mod;
        ch = gc;
    }
    return f ? x : -x;
}

typedef vector<int> poly;

inline int ksm(int x, int y) {
    int ret = 1;
    for(; y; y >>= 1, x = x * x % mod)
        if(y & 1) ret = ret * x % mod;
    return ret;
}

poly NTT(poly F, int typ) {
    int n = F.size();
    vector<int> rev(n);
    FOR(i, 1, n - 1) rev[i] = rev[i >> 1] >> 1 | ((i & 1) ? n >> 1 : 0);
    FOR(i, 0, n - 1) if(i < rev[i]) swap(F[i], F[rev[i]]);
    for(int i = 1; i < n; i <<= 1) {
        int gn = ksm(g, (mod - 1) / (i << 1));
        for(int j = 0, g0 = 1, x, y; j < n; j += (i << 1), g0 = 1)
        for(int k = 0; k < i; k++, g0 = gn * g0 % mod) {
            x = F[j + k], y = F[i + j + k] * g0 % mod;
            F[j + k] = (x + y) % mod;
            F[i + j + k] = (x - y + mod) % mod;
        }
    }
    if(typ == 1) return F;
    int inv = ksm(n, mod - 2); reverse(F.begin() + 1, F.end());
    for(int i = 0; i < n; i++) F[i] = F[i] * inv % mod;
    return F;
}

poly MUL(poly F, poly G) {
    int n = F.size(), m = G.size();
    int len = 1; while(len < (n + m) - 1) len <<= 1;
    F.resize(len), G.resize(len);
    F = NTT(F, 1), G = NTT(G, 1);
    FOR(i, 0, len - 1) F[i] = G[i] * F[i] % mod;
    F = NTT(F, 0), F.resize(n + m);
    return F;
}

poly INV(poly F) {
    int n = F.size();
    if(n == 1) return {ksm(F[0], mod - 2)};
    poly G = INV(poly(F.begin(), F.begin() + (n + 1) / 2));
    int len = 1; while(len < (n << 1) - 1) len <<= 1;
    F.resize(len), G.resize(len);
    F = NTT(F, 1), G = NTT(G, 1);
    FOR(i, 0, len - 1) F[i] = (2 - F[i] * G[i] % mod + mod) % mod * G[i] % mod;
    F = NTT(F, 0), F.resize(n);
    return F;
}

poly DI(poly F) {
    int n = F.size();
    FOR(i, 1, n - 1) F[i - 1] = F[i] * i % mod;
    F.resize(n - 1); return F;
}

poly IG(poly F) {
    int n = F.size();
    F.resize(n + 1);
    ROF(i, n, 1) F[i] = F[i - 1] * ksm(i, mod - 2) % mod;
    F[0] = 0; return F;
}

poly LN(poly F) {
    int n = F.size(); poly G = INV(F); F = DI(F);
    F = IG( MUL(F, G) );
    F.resize(n); return F;
}

poly EXP(poly F) {
    int n = F.size();
    if(n == 1) return {1};
    poly G = EXP(poly(F.begin(), F.begin() + (n + 1) / 2));
    G.resize(n); poly H = LN(G);
    int len = 1; while(len < (n << 1) - 1) len <<= 1;
    F.resize(len), G.resize(len), H.resize(len);
    F = NTT(F, 1), G = NTT(G, 1), H = NTT(H, 1);
    FOR(i, 0, len - 1) F[i] = (1 + F[i] - H[i] + mod) % mod * G[i] % mod;
    F = NTT(F, 0), F.resize(n);
    return F;
}

int n, k, t;

inline void solve() {
    n = rd, k = rd, t = rd;
    poly F(n), G(n);
    for(int i = 0; i < n; i++) F[i] = rd;
    G[0] = 1, G[1] = mod - 1, G = LN(G);
    for(int i = 0; i < n; i++) G[i] = G[i] * k % mod;
    G = EXP(G);
    if(t == 0) G = INV(G);
    F = MUL(F, G);
    for(int i = 0; i < n; i++) cout << F[i] << ' ';
    return ;
}

#undef int 

#define local freopen("in.txt","r",stdin);freopen("out.txt","w",stdout)

int main() {
#ifdef LOCAL
    local;
#endif
    solve();
    return 0;
}
~~~

## Final

正好安利一下多项式的 `vector` 写法，清空不麻烦，写起来也没有什么障碍，非常的舒服！

---

## 作者：FANTASTlC (赞：0)

### 分析：
考虑序列 $A$  的 OGF ， $F=\sum\limits_{i=0}^{\infty} a_ix^i$ 。

先考虑 $k=1$ 的情况。

对于求前缀和，可以直接将 $F$ 乘上 $G=\sum\limits_{i=0}^{\infty}x_i$ 。根据 $G$ 的性质，列出方程： $G-x\cdot G= 1$ 。解之，易得 $G=\frac{1}{1-x}$ 。

对于求差分，可以直接求出 $F$ 与 $1-x$ 的卷积。

考虑 $k > 1$ 的情况。

对于求前缀和，可以将 $F$ 乘上 $G^k$ （有点像矩阵快速幂）。
但这样代码会非常难写，所以考虑使用广义二项式定理，$G^k=(1-x)^{-k}=\sum\limits_{i=0}^{\infty}{{i+k-1}\choose i}x^i$。

对于求差分，使用二项式定理，$G^k=(1-x)^k=\sum\limits_{i=0}^{\infty}(-1)^i {k \choose i}x^i$。

### 具体实现：
由于 $k$ 的范围很大，输入都是个问题，这里可以根据 Lucas 定理在输入的时候对 k 进行取模。

因为该题所用到的组合数有一定的规律，所以考虑递推。(这里可以先线性预处理出逆元。)

前缀和：

${i+k-1 \choose i}=\frac{i+k-1!}{i!k-1!}=\frac{i+k-2!}{i-1!k-1!}\cdot \frac{i+k-1}{i}={i+k-2\choose i-1}\cdot \frac{i+k-1}{i}$

差分:   

${k \choose i}=\frac{k!}{i!k-i!}=\frac{k!}{i-1!k-i+1!}\cdot \frac{k-i+1}{i}={k\choose i-1}\cdot \frac{k-i+1}{i}$

计算卷积:

由于这题对精度要求较大，计算卷积时应使用 NTT 进行计算， FFT 大概率会被卡。
### Code：
```cpp
#include<bits/stdc++.h>
#define N (int)(3e5+1)
#define M 5001
#define R register
#define x first
#define y second
#define g 3
#define ig 334845270
#define ll long long
#define db double
#define mp make_pair
#define pb push_back
#define pi pair<int,int>
#define lb(x) (x&-x)
#define mod 1004535809
#define wt(x) write(x),puts("")
#define ot(x) write(x),putchar(' ')
#define INF 0x7fffffff
#define F(i,start,end) for(R int (i)=(start);(i)<=(end);i++)
#define T(i,end,start) for(R int (i)=(start);(i)>=(end);i--)
using namespace std;
template<typename T> void read(T &x)
{
	int f=1;
	x=0;
	char c=getchar();
	while(!isdigit(c))
	{
		if(c=='-')
			f=-1;
		c=getchar();
	}
	while(isdigit(c))
	{
		x=((x<<3)%mod+(x<<1)%mod+c-'0')%mod;
		c=getchar();
	}
	x*=f;
	return;
}
void write(R ll x)
{
	if(x<0)
	{
		x=~x+1;
		putchar('-');
 	}
	if(x>9)
		write(x/10);
	putchar(x%10+'0');
	return;
}
int n,lim=1,bit,rev[N];
ll k,a[N],b[N],inv[N];
bool f;
ll power(ll x,int y)
{
	ll ret=1;
	for(;y;y>>=1,x=x*x%mod)
		(ret*=y&1?x:1)%=mod;
	return ret;
}
void init()
{
	for(;lim<n<<1;lim<<=1,bit++);
	F(i,0,lim)
		rev[i]=rev[i>>1]>>1|(i&1)<<bit-1;
	inv[1]=1;
	F(i,2,lim)
		inv[i]=inv[mod%i]*(mod-mod/i)%mod;
	return;
}
void ntt(ll a[],bool fg)
{
	F(i,0,lim-1)
		if(i<rev[i])
			swap(a[i],a[rev[i]]);
	for(int mid=1;mid<lim;mid<<=1)
	{
		ll size=mid<<1,wn=power(fg?ig:g,(mod-1)/size);
		for(int j=0;j<lim;j+=size)
		{
			ll w=1;
			for(int k=0;k<mid;k++,w=w*wn%mod)
			{
				ll a0=a[j+k],a1=a[j+k+mid]*w%mod;
				a[j+k]=(a0+a1)%mod,a[j+k+mid]=(a0-a1+mod)%mod;
			}
		}
	}
	return;
}
int main()
{
	read(n),read(k),read(f);
	init();
	F(i,0,n-1)
		read(a[i]);
	b[0]=1;
	if(f)
	{
		F(i,1,n-1)
			b[i]=b[i-1]*(k-i+1+mod)%mod*inv[i]%mod;
		for(int i=1;i<n;i+=2)
			b[i]=mod-b[i];
	}
	else
		F(i,1,n-1)
			b[i]=b[i-1]*(k+i-1)%mod*inv[i]%mod;
	ntt(a,0),ntt(b,0);
	F(i,0,lim-1)
		a[i]=a[i]*b[i]%mod;
	ntt(a,1);
	F(i,0,n-1)
		ot(a[i]*inv[lim]%mod);
	return 0;
}
```


---

## 作者：zythonc (赞：0)

设序列 $a$ 的普通生成函数 $f(x)$ 为 $\sum\limits^{\infty}_{n=0}a_nx^n$，$g(x)=\sum\limits^\infty_{n=0}b_nx^n$ 是另一个新的数列 $\{b_n\}^\infty_{n=0}$ 的生成函数。

## 前缀和

首先写出前缀和的计算方法：$sum_i=\sum\limits_{k=1}^ia_k$。

熟知 $f(x)g(x)$ 是数列 $\left\{\sum\limits^n_{k=0}a_kb_{n-k}\right\}_{n=0}^\infty$ 的生成函数 **（性质1）** 。

当 $b$ 的每一项 $b_i$ 都等于 $1$ 时，$\dfrac{f(x)}{1-x}$ 即为其一阶前缀和。

同理，二阶前缀和是在一阶前缀和的基础上得到的，$k$ 阶前缀和是在 $k-1$ 阶前缀和的基础上得到的，我们用 $\dfrac{1}{1-x}$ 不断相乘即可。

所以 $k$ 阶前缀和即为 $f\times\dfrac{1}{(1-x)^k}$。

根据上文性质1，$\dfrac{1}{(1-x)^k}$ 即为 $\left\{\sum\limits_{n_1+n_2+\dots+n_k=n}1\right\}_{n=0}^\infty$ 的OGF。

考虑组合意义，即 $\left\{\dbinom{n+k-1}{n}\right\}_{n=0}^\infty$ 的OGF。

递推组合数：

$\dbinom{i+k-1}{i}=\dbinom{i+k-2}{i-1}\dfrac{k+i-1}{i}$

然后跟 $f$ NTT卷一下就可以。

## 任务2：差分

首先写出差分的计算方法：$dif_i=a_i-a_{i-1}$。

依然考虑性质1，如果 $b_0=1,b_1=-1,b_i=0\;(i>1)$。

此时 $f\times g=\sum\limits_{n=0}^\infty\left(\sum\limits^n_{k=0}a_kb_{n-k}\right)x^n=\sum\limits_{n=0}^\infty(a_n-a_{n-1})x^n$。

显然我们依然能将差分数组的计算方法写成生成函数相乘的形式。

此时数列 $b$ 即为 $1-x$。

所以 $k$ 阶差分即为 $f\times(1-x)^k$。

对于 $(1-x)^k$ 直接二项式定理拆开。

$(1-x)^k$ 的每项系数是 $\sum\limits_{i=0}^k(-1)^i\dbinom{k}{i}$

递推组合数：

$\dbinom{k}{i}=\dbinom{k}{i-1}\dfrac{k-i+1}{i}$

然后拿 $f$ NTT卷一下就可以。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#define N 1000001
#define INF 1100000000
#define Kafuu return
#define Chino 0
#define fx(l,n) inline l n
#define set(l,n,ty,len) memset(l,n,sizeof(ty)*len)
#define cpy(f,t,ty,len) memcpy(t,f,sizeof(ty)*len)
#define R register int
#define int long long
using namespace std;
const int mod=1004535809,pr=3;
int n,k,t,ori[N],invp,invx,x=1,br[N],prp[N],binom[N],T[N];
fx(int,gi)(){
	char C=getchar();long long n=0,f=1;
	while(C<'0'||C>'9'){
		if(C=='-') f=-f;
		C=getchar();
	}
	while(C>='0'&&C<='9') ((n*=10)+=C-'0')%=mod,C=getchar();
	return (n*f)%mod;
}
fx(int,pow)(int a,int b=mod-2){
	int sum=1;
	while(b){
		if(b&1) (sum*=a)%=mod;
		(a*=a)%=mod;
		b>>=1;
	}
	return sum;
}
fx(void,NTT)(int *f,short r){
	R len,hl,exp,uni,st,i;
	for(i=0;i<x;i++) if(i<br[i]) swap(f[i],f[br[i]]);
	for(len=2,hl=1;len<=x;hl=len,len<<=1){
		exp=pow(r==1?pr:invp,(mod-1)/len);
		for(i=1;i<hl;i++) prp[i]=prp[i-1]*exp%mod;
		for(st=0;st<x;st+=len){
			for(i=0;i<hl;i++){
				uni=prp[i]*f[i|st|hl]%mod;
				f[i|st|hl]=(f[i|st]-uni+mod)%mod;
				f[i|st]=(f[i|st]+uni)%mod;
			}
		}
	}
}
signed main(){
	n=gi(),k=gi(),t=gi();
	for(R i=0;i<n;i++) T[i]=ori[i]=gi();
	while(x<=n+n) x<<=1;
	for(R i=0;i<x;i++) br[i]=(br[i>>1]>>1)|((i&1)?x>>1:0);
	invx=pow(x);invp=pow(pr);binom[0]=1;
	if(!t) for(int i=1;i<=n;i++) binom[i]=binom[i-1]*(k+i-1)%mod*pow(i)%mod;
	else for(int i=1;i<=n;i++) binom[i]=-binom[i-1]*(k-i+1)%mod*pow(i)%mod;
	prp[0]=1;NTT(ori,1);NTT(binom,1);
	for(int i=0;i<x;i++) (ori[i]*=binom[i])%=mod;
	NTT(ori,-1);
	for(int i=0;i<n;i++) cout<<ori[i]*invx%mod<<" ";
	Kafuu Chino;
}
```

---

## 作者：Illusory_dimes (赞：0)

### 题目描述
给定一个长为 $n$ 的序列 $a$，求出其 $k$ 阶差分或前缀和，每一项对 $1004535809$ 取模

数据范围 $1\leq n\leq 10^5$ ， $0\leq a_i\leq 10^9$ ， $1\leq k\leq 10^{2333}$ ， $k\not\equiv 0$ $(mod$ $1004535809)$

### 前置芝士
多项式快速幂

### solution

1.前缀和

已经知道原始数组其实就是一阶前缀和。

设原始数组为 $f(x)$ 。

那么如果再设一个函数：

$g(x)=\sum_{i=0}^{n}x^i$

生成函数里， $g$ 就是那个的 $\large\frac{1}{1-x}$ 。

如果要达到 $a_i\Longrightarrow \sum_{id<i} a_{id}$ 

那么 $f$ 卷 $k$ 次 $g$ 卷起来就是 $k$ 阶前缀和啦。

2.差分

其实打打表会发现：乘 $k$ 次 $(1-x)$ 就行了

语文太差形容不来。。。

剩下的交给多项式快速幂吧
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=4e5+10;
typedef ll arr[N];
const int mod=1004535809;
const int inv3=334845270;
int n,k,ty,inv[N],lim=1,fre,id[N],T[N];
arr a,f,g,h,ans,tmp,ln;
inline ll inc(ll x,ll y){return x+y>=mod?x+y-mod:x+y;}
inline ll dec(ll x,ll y){return x-y<0?x-y+mod:x-y;}
inline ll mul(ll x,ll y){return 1ll*x*y%mod;}
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*w;
}
inline int ksm(int a,int b)
{
	int tmp=1;
	while(b)
	{
		if(b&1)tmp=(1ll*tmp*a)%mod;
		b>>=1,a=(1ll*a*a)%mod;
	}
	return tmp;
}
inline void Never_Tell_TLE(ll* NTT,int sign)
{
	for(int i=0;i<=lim;++i)if(i<id[i])
	{
		ll NTt=NTT[i];
		NTT[i]=NTT[id[i]];
		NTT[id[i]]=NTt;
	}
	for(int mid=1;mid<lim;mid<<=1)
	{
		int Unit_root;
		if(sign==1)Unit_root=ksm(3,(mod-1)/(mid<<1));
		else Unit_root=ksm(inv3,(mod-1)/(mid<<1));
		for(int R=mid<<1,r=0;r<lim;r+=R)
		{
			int pw=1;
			for(int l=0;l<mid;++l,pw=(1ll*pw*Unit_root)%mod)
			{
				int butt=NTT[l+r],rfly=(1ll*pw*NTT[l+r+mid])%mod;
				NTT[l+r]=inc(butt,rfly);
				NTT[l+r+mid]=dec(butt,rfly);
			}
		}
	}
	if(sign==-1)
	{
		int inv_lim=ksm(lim,mod-2);
		for(int i=0;i<=lim;++i)NTT[i]=mul(NTT[i],inv_lim);
	}
}
inline void Derivation(ll* F,ll* G,int nm)
{
	for(int i=1;i<nm;++i)
	G[i-1]=mul(1ll*i,F[i]);
	G[nm-1]=0;
}
inline void Inv(ll* F,ll* G,int nm)
{
	if(nm==1)
	{
		G[0]=ksm(F[0],mod-2);
		return;
	}
	Inv(F,G,(nm+1)>>1);
	lim=1,fre=0;
	for(;lim<(nm<<1);lim<<=1)++fre;
	for(int i=0;i<=lim;++i)id[i]=(id[i>>1]>>1)|((i&1)<<(fre-1));
	for(int i=0;i<nm;++i)ans[i]=F[i];
	for(int i=nm;i<=lim;++i)ans[i]=0;
	Never_Tell_TLE(ans,1),Never_Tell_TLE(G,1);
	for(int i=0;i<=lim;++i)G[i]=mul(inc(2ll,-mul(ans[i],G[i])+mod),G[i]);
	Never_Tell_TLE(G,-1);
	for(int i=nm;i<=lim;++i)G[i]=0;
}
inline void Mul(ll* F,ll* G,int nm)
{
	lim=1,fre=0;
	for(;lim<(nm<<1);lim<<=1)++fre;
	for(int i=0;i<=lim;++i)id[i]=(id[i>>1]>>1)|((i&1)<<(fre-1));
	int inv_lim=ksm(lim,mod-2);
	Never_Tell_TLE(G,1),Never_Tell_TLE(F,1);
	for(int i=0;i<=lim;++i)G[i]=mul(F[i],G[i]);
	Never_Tell_TLE(G,-1);
}
inline void Integral(ll* F,ll* G,int nm)
{
	for(int i=1;i<nm;++i)
	G[i]=mul(F[i-1],inv[i]);
	G[0]=0;
}
inline void Ln(ll* F,ll* G,int nm)
{
	Inv(F,tmp,nm);
	for(int i=0;i<=lim;++i)ans[i]=0;
	Derivation(F,ans,nm);
	Mul(tmp,ans,nm);
	Integral(ans,G,nm);
	for(int i=0;i<=lim;++i)ans[i]=tmp[i]=0;
}
inline void solve(ll* F,ll* G,int nm)
{
	if(nm==1)
	{
		G[0]=1;
		return;
	}
	solve(F,G,(nm+1)>>1);
	lim=1,fre=0;
	for(;lim<(nm<<1);lim<<=1)++fre;
	for(int i=0;i<=lim;++i)id[i]=(id[i>>1]>>1)|((i&1)<<(fre-1));
	for(int i=0;i<=lim;++i)ln[i]=0;
	Ln(G,ln,nm);
	for(int i=0;i<nm;++i)ans[i]=F[i];
	for(int i=nm;i<=lim;++i)ans[i]=0;
	Never_Tell_TLE(ans,1),Never_Tell_TLE(G,1),Never_Tell_TLE(ln,1);
	for(int i=0;i<=lim;++i)G[i]=mul(inc(1ll,inc(ans[i],-ln[i]+mod)),G[i]);
	Never_Tell_TLE(G,-1);
	for(int i=nm;i<=lim;++i)G[i]=0;
}
inline void pre()
{
	inv[1]=1;
	for(int i=2;i<=n;++i)inv[i]=(-(ll)(mod/i)*inv[mod%i]%mod+mod)%mod;
}
int main()
{
	n=read();pre();
	int c=getchar();while(isspace(c))c=getchar();
	for(;isdigit(c);c=getchar())k=(k*10LL+(c^'0'))%mod;
	ty=read();
	for(int i=0;i<n;++i)a[i]=read();
	f[0]=1,f[1]=-1+mod;
	Ln(f,g,n);
	for(int i=0;i<=lim;++i)g[i]=mul(g[i],k),f[i]=0;
	solve(g,f,n);
	if(ty)memcpy(h,f,sizeof(h));
	else Inv(f,h,n);
	lim=1,fre=0;
	for(;lim<(n<<1);lim<<=1)++fre;
	for(int i=0;i<=lim;++i)id[i]=(id[i>>1]>>1)|((i&1)<<(fre-1));
	Never_Tell_TLE(a,1),Never_Tell_TLE(h,1);
	for(int i=0;i<=lim;++i)h[i]=mul(a[i],h[i]);
	Never_Tell_TLE(h,-1);
	for(int i=0;i<n;++i)printf("%d ",h[i]);
	getchar();
	return 0;
}
```
只求能帮助到几个人罢。。

---

## 作者：qinyubo (赞：0)

[题目链接](https://www.luogu.com.cn/problem/P5488)

题目描述：给定一个长为 $n$ 的序列 $a$，求它的 $k$ 阶差分或前缀和。对 $1004535809$ 取模。

$1\le n\le10^5$

$0\le a_i\le10^9$

$1\le k\le10^{2333},k\not\equiv0\pmod{1004535809}$

多项式基础应用板子题。

一看 $1004535808=2^{21}\times479$ 发现是个 $\text{NTT}$ 模数，再一看题面，发现是个多项式板子题。

首先，设多项式 $F(x)=\sum\limits_{i=1}^na_ix^i$。

然后，定义平移算子 $[x^n]\operatorname{E}f=[x^{n-1}]f$。

则差分算子 $[x^n]\Delta f=[x^n]f-[x^{n-1}]f=[x^n]f-[x^n]\operatorname{E}f$，

可以推出 $\Delta=1-\operatorname{E}$，故 $\Delta^k=(1-\operatorname{E})^k$。

然后发现在多项式意义下 $\operatorname{E}$ 就是乘以 $x$，故 $\Delta^k=(1-x)^k$，即 $[x^n]\Delta^kF=[x^n](1-x)^kF$。

而前缀和算子 $\Sigma=\Delta^{-1}$，故 $\Sigma^k=\Delta^{-k}$，即 $[x^n]\Sigma^kF=[x^n](1-x)^{-k}F$。

如果您不会多项式乘法，建议您先去学学。

如果您会多项式快速幂，直接求 $(1-x)^k$ 或 $(1-x)^{-k}$ 再把它和 $F$ 卷起来就行了。

否则，您可能需要递推求出 $(1-x)^k$ 或 $(1-x)^{-k}$ 的系数。

根据牛顿二项式定理，

$(1-x)^k=\sum\limits_{i\ge0}\dbinom ki(-1)^ix^i$

$=\sum\limits_{i\ge0}\dfrac{k^{\underline i}}{i!}(-1)^ix^i$

$=\sum\limits_{i\ge0}-\dfrac{k-i+1}{i}\times\dfrac{k^{\underline {i-1}}}{(i-1)!}(-1)^{i-1}x^i$

故如果设 $(1-x)^k=\sum\limits_{i\ge0}b_ix^i$，则有 $b_i=-\dfrac{k-i+1}{i}b_{i-1}$。

类似的，如果设 $(1-x)^{-k}=\sum\limits_{i\ge0}c_ix^i$，则有 $c_i=-\dfrac{-k-i+1}{i}c_{i-1}$。

同样，递推求出 $(1-x)^k$ 或 $(1-x)^{-k}$ 的系数后再把它和 $F$ 卷起来就行了。

最后一个小问题，由于 $k$ 特别大（$10^{2333}$ 级别），所以要边输入边取模。模 $1004535809$ 而不是 $1004535808$ 是因为 $(1-x)^{1004535808}\equiv1(\bmod\ 1004535809)$ 但是 $(1-x)^{1004535808}\not\equiv1(\bmod\ x^{1004535809})$ 而是 $(1-x)^{1004535809}\equiv1(\bmod\ x^{1004535809})$，当然也有 $(1-x)^{1004535809}\not\equiv1(\bmod\ x^n)$。

多项式快速幂版本（不开 $\text{O2}$ 就会 $\text{TLE}$）：

```cpp
#include <bits/stdc++.h>
#define ll long long
#define P 1004535809ll
#define G 615614863ll
#define N 18ll
using namespace std;
namespace QYB {
    ll g[1 << N], r[1 << N];
    ll read_huge_int() {
        static char s[1 << 20];
        scanf("%s", s); ll len = strlen(s), res = 0;
        reverse(s, s + len);
        for (ll i = 0, h = 1; i < len; i++, (h *= 10) %= P) {
            (res += h * (s[i] - '0') % P) %= P;
        } return res;
    } void exgcd(ll a, ll b, ll &x, ll &y) {
        if (!b) return x = 1, y = 0, void();
        exgcd(b, a % b, y, x); y -= a / b * x;
    } ll inv(ll a) { ll ra, rp; exgcd(a, P, ra, rp); return ((ra % P) + P) % P; }
    void init() {
        g[0] = 1; r[0] = 0;
        for (int i = 1; i < (1 << N); i++) {
            g[i] = g[i - 1] * G % P;
            r[i] = (r[i >> 1] >> 1) | ((i & 1) << N - 1);
        }
    } ll w(ll k, ll n) { return g[(k & ((1 << n) - 1)) << N - n]; }
    void NTT(ll *a, ll d) {
        for (ll i = 0; i < (1 << d); i++) {
            if (i < (r[i] >> N - d)) {
                swap(a[i], a[r[i] >> N - d]);
            }
        } for (ll i = 1; i <= d; i++) {
            for (ll j = 0; j < (1 << d); j += (1 << i)) {
                for (ll k = 0; k < (1 << i - 1); k++) {
                    ll _0 = a[j + k], _1 = a[j + k + (1 << i - 1)] * w(k, i) % P;
                    a[j + k] = (_0 + _1) % P; a[j + k + (1 << i - 1)] = (_0 - _1 + P) % P;
                }
            }
        }
    } void INTT(ll *a, ll d) {
        for (ll i = 0; i < (1 << d); i++) {
            if (i < (r[i] >> N - d)) {
                swap(a[i], a[r[i] >> N - d]);
            }
        } for (ll i = 1; i <= d; i++) {
            for (ll j = 0; j < (1 << d); j += (1 << i)) {
                for (ll k = 0; k < (1 << i - 1); k++) {
                    ll _0 = a[j + k], _1 = a[j + k + (1 << i - 1)] * w(-k, i) % P;
                    a[j + k] = (_0 + _1) % P; a[j + k + (1 << i - 1)] = (_0 - _1 + P) % P;
                }
            }
        } for (ll i = 0, rn = inv(1 << d); i < (1 << d); i++) {
            (a[i] *= rn) %= P;
        }
    } void DIF(ll *a, ll *b, ll d) {
        for (ll i = 1; i < (1 << d); i++) {
            b[i - 1] = a[i] * i % P;
        } b[(1 << d) - 1] = 0;
    } void INT(ll *a, ll *b, ll d) {
        for (ll i = (1 << d) - 1; i > 0; i--) {
            b[i] = a[i - 1] * inv(i) % P;
        } b[0] = 0;
    } void INV(ll *a, ll *b, ll d) {
        if (d == 0) return b[0] = inv(a[0]), void();
        INV(a, b, d - 1);
        ll *tmp = new ll[1 << d + 1];
        memset(tmp, 0X00, sizeof(ll) << d + 1);
        for (ll i = 0; i < (1 << d); i++) tmp[i] = a[i];
        NTT(tmp, d + 1); NTT(b, d + 1);
        for (ll i = 0; i < (1 << d + 1); i++) b[i] = (2 * b[i] - b[i] * b[i] % P * tmp[i] % P + P) % P;
        INTT(b, d + 1);
        for (ll i = (1 << d); i < (1 << d + 1); i++) b[i] = 0;
        delete[] tmp;
    } void LN(ll *a, ll *b, ll d) {
        ll *tmp1 = new ll[1 << d + 1], *tmp2 = new ll[1 << d + 1];
        memset(tmp1, 0X00, sizeof(ll) << d + 1);
        memset(tmp2, 0X00, sizeof(ll) << d + 1);
        DIF(a, tmp1, d); INV(a, tmp2, d);
        NTT(tmp1, d + 1); NTT(tmp2, d + 1);
        for (ll i = 0; i < (1 << d + 1); i++) b[i] = tmp1[i] * tmp2[i] % P;
        INTT(b, d + 1); INT(b, b, d);
        for (ll i = (1 << d); i < (1 << d + 1); i++) b[i] = 0;
        delete[] tmp1; delete[] tmp2;
    } void EXP(ll *a, ll *b, ll d) {
        if (d == 0) return b[0] = 1, void();
        EXP(a, b, d - 1);
        ll *tmp1 = new ll[1 << d + 1], *tmp2 = new ll[1 << d + 1];
        memset(tmp1, 0X00, sizeof(ll) << d + 1);
        memset(tmp2, 0X00, sizeof(ll) << d + 1);
        for (ll i = 0; i < (1 << d); i++) tmp1[i] = a[i];
        LN(b, tmp2, d);
        NTT(tmp1, d + 1); NTT(tmp2, d + 1); NTT(b, d + 1);
        for (ll i = 0; i < (1 << d + 1); i++) b[i] = b[i] * (1 + tmp1[i] - tmp2[i] + P) % P;
        INTT(b, d + 1);
        for (ll i = (1 << d); i < (1 << d + 1); i++) b[i] = 0;
        delete[] tmp1; delete[] tmp2;
    } void POW(ll *a, ll *b, ll k, ll d) {
        ll *tmp = new ll[1 << d + 1];
        memset(tmp, 0X00, sizeof(ll) << d + 1);
        LN(a, tmp, d);
        for (ll i = 0; i < (1 << d); i++) (tmp[i] *= k) %= P;
        EXP(tmp, b, d); for (ll i = (1 << d); i < (1 << d + 1); i++) b[i] = 0;
        delete[] tmp;
    } int main() {
        ll n, opt; scanf("%lld", &n); ll k = read_huge_int(); scanf("%lld", &opt); init();
        ll *a = new ll[1 << N], *b = new ll[1 << N], *c = new ll[1 << N];
        memset(a, 0X00, sizeof(ll) << N); memset(b, 0X00, sizeof(ll) << N); memset(c, 0X00, sizeof(ll) << N);
        for (ll i = 0; i < n; i++) scanf("%lld", a + i);
        b[0] = 1; b[1] = P - 1;
        memset(c, 0X00, sizeof(ll) << N); POW(b, c, opt? k: P - k, N - 1); NTT(a, N); NTT(c, N);
        for (ll i = 0; i < (1 << N); i++) (a[i] *= c[i]) %= P;
        INTT(a, N); for (ll i = 0; i < n; i++) printf("%lld%c", a[i], " \n"[i == n - 1]);
        return 0;
    }
} int main() {
    return QYB::main();
}
```

递推版本（不开 $\text{O2}$ 也跑得飞快）：

```cpp
#include <bits/stdc++.h>
#define ll long long
#define P 1004535809ll
#define G 615614863ll
#define N 18ll
using namespace std;
namespace QYB {
    ll g[1 << N], r[1 << N], a[1 << N], b[1 << N];
    ll read_huge_int() {
        static char s[1 << 20];
        scanf("%s", s); ll len = strlen(s), res = 0;
        reverse(s, s + len);
        for (ll i = 0, h = 1; i < len; i++, (h *= 10) %= P) {
            (res += h * (s[i] - '0') % P) %= P;
        } return res;
    } void exgcd(ll a, ll b, ll &x, ll &y) {
        if (!b) return x = 1, y = 0, void();
        exgcd(b, a % b, y, x); y -= a / b * x;
    } ll inv(ll a) { ll ra, rp; exgcd(a, P, ra, rp); return ((ra % P) + P) % P; }
    void init() {
        g[0] = 1; r[0] = 0;
        for (int i = 1; i < (1 << N); i++) {
            g[i] = g[i - 1] * G % P;
            r[i] = (r[i >> 1] >> 1) | ((i & 1) << N - 1);
        }
    } ll w(ll k, ll n) { return g[(k & ((1 << n) - 1)) << N - n]; }
    void NTT(ll *a, ll d) {
        for (ll i = 0; i < (1 << d); i++) {
            if (i < (r[i] >> N - d)) {
                swap(a[i], a[r[i] >> N - d]);
            }
        } for (ll i = 1; i <= d; i++) {
            for (ll j = 0; j < (1 << d); j += (1 << i)) {
                for (ll k = 0; k < (1 << i - 1); k++) {
                    ll _0 = a[j + k], _1 = a[j + k + (1 << i - 1)] * w(k, i) % P;
                    a[j + k] = (_0 + _1) % P; a[j + k + (1 << i - 1)] = (_0 - _1 + P) % P;
                }
            }
        }
    } void INTT(ll *a, ll d) {
        for (ll i = 0; i < (1 << d); i++) {
            if (i < (r[i] >> N - d)) {
                swap(a[i], a[r[i] >> N - d]);
            }
        } for (ll i = 1; i <= d; i++) {
            for (ll j = 0; j < (1 << d); j += (1 << i)) {
                for (ll k = 0; k < (1 << i - 1); k++) {
                    ll _0 = a[j + k], _1 = a[j + k + (1 << i - 1)] * w(-k, i) % P;
                    a[j + k] = (_0 + _1) % P; a[j + k + (1 << i - 1)] = (_0 - _1 + P) % P;
                }
            }
        } for (ll i = 0, rn = inv(1 << d); i < (1 << d); i++) {
            (a[i] *= rn) %= P;
        }
    } int main() {
        ll n, opt; scanf("%lld", &n); ll k = read_huge_int();
        scanf("%lld", &opt); init(); if (!opt) k = P - k;
        for (ll i = 0; i < n; i++) scanf("%lld", a + i); b[0] = 1;
        for (int i = 1; i < n; i++) b[i] = b[i - 1] * (P - (k - i + 1 + P) % P * inv(i) % P) % P;
        NTT(a, N); NTT(b, N); for (ll i = 0; i < (1 << N); i++) (a[i] *= b[i]) %= P; INTT(a, N);
        for (ll i = 0; i < n; i++) printf("%lld%c", a[i], " \n"[i == n - 1]);
        return 0;
    }
} int main() {
    return QYB::main();
}
```

希望大家能对多项式有更多了解。

---


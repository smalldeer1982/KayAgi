# [GZOI2017] 河神

## 题目背景

GZOI2017 D2T1

终于忍受不了苦 X 的搬砖生活, Shlw 把手里的板砖扔进了河里.

不出意料地, 河神冒了出来.

Shlw 说: “我掉了金砖, 快给我金砖!”

“!!! 你已经知道套路了吗,”河神说道, “但是你要金砖的话, 我就不给你2017 彩虹小马大电影的资源了哦. 如果你说实话的话, 我还可以考虑一下.”

Shlw 发现事情并不简单, 在金钱和信仰面前, 难以抉择.

突然, Shlw 不理会河神, 自顾自的地跑走了.

“唉, 现在的年轻人啊... 真不知道在想什么.”Pinkie Pie 感叹, 卸下了河神伪装.

## 题目描述

Shlw 从河神给的选择中, 获得了一道当年挂掉的代数题的灵感.

但现在他希望你来帮忙解答, 因为他自己忙着去搜小马资源去了.

给出数列 $\{a_n\}$ 和 $\{b_n\}$ 以及 $\{A_n\}$ 的递推关系, 试求出数列 $\{A_n\}$ 第 $N$ 项.

递推关系为:

$$A_n=\begin{cases}a_n  &  0 \le n < K \\ \bigoplus (A_{n-K+t} \otimes b_t) & n \ge K \end{cases}$$

其中，$\otimes$ 表示与操作，$\oplus$ 表示或操作。

## 说明/提示

【样例解释】

从 $A_0$ 至 $A_{10}$ 分别为: $2, 3, 5, 7, 12, 15, 15, 13, 15, 15, 15$

【数据约束】

![](https://cdn.luogu.com.cn/upload/image_hosting/16mwbo3z.png)

【后记】

后来, Pinkie Pie 偷偷来到 Shlw 家里, 她把这题拿回去考 Apple Jack, 于是 Apple Jack就有了狂吃苹果来畅游多重宇宙的本领.

## 样例 #1

### 输入

```
10 5
2 3 5 7 12
23 45 2 4 8```

### 输出

```
15```

# 题解

## 作者：NaCly_Fish (赞：11)

为了方便，我们记序列 $b$ 下标从 $1$ 开始，并翻转，这样可以化为标准的线性递推式。  

考虑用矩阵快速幂来解决，此处我们更改矩阵乘法的定义：将原本的乘法改为按位与，原本的加法改为按位或。

那么就能得到：

$$\begin{bmatrix} a_{n-1} & a_{n-2} &\dots &a_{n-k}\end{bmatrix} \times \begin{bmatrix} b_1 &+\infty &0 & \dots & 0 \\ b_{2} & 0 & +\infty & \dots & 0 \\b_3  & 0 & 0 & \dots & 0 \\ \dots & \dots & \dots & \dots & \dots \\ b_{k-1} & 0 & 0 & \dots & +\infty\\ b_k & 0 & 0 & \dots & 0\end{bmatrix}$$
$$=\begin{bmatrix} a_n & a_{n-1} &\dots &a_{n-k+1}\end{bmatrix}$$

这里的 $+\infty$ 指的是二进制中每一位都是 $1$ 的数。

然后直接做就行了。

（水题解的屑）

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<bitset>
#define N 100003
#define reg register
#define ull unsigned long long
#define inf 0xffffffffffffffffull
using namespace std;

inline void read(int &x){
    x = 0;
    char c = getchar();
    while(c<'0'||c>'9') c = getchar();
    while(c>='0'&&c<='9'){
        x = (x<<3)+(x<<1)+(c^48);
        c = getchar();
    }
}

struct matrix{
    ull a[101][101];
    int siz;

    inline matrix(int siz=0):siz(siz){ memset(a,0,sizeof(a)); }
    inline matrix operator * (const matrix& b) const{
        matrix res = matrix(siz);
        for(reg int i=0;i!=siz;++i)
        for(reg int j=0;j!=siz;++j)
        for(reg int k=0;k!=siz;++k)
            res.a[i][j] |= a[i][k]&b.a[k][j];
        return res;    
    }
};

inline matrix power(matrix a,int t){
    matrix res = matrix(a.siz);
    for(reg int i=0;i!=a.siz;++i) res.a[i][i] = inf;
    while(t){
        if(t&1) res = res*a;
        a = a*a;
        t >>= 1;
    }
    return res;
}

int n,k;
ull a[N],f[103];
matrix A;

int main(){
    ull ans = 0;
    scanf("%d%d",&n,&k);
    for(reg int i=0;i<k;++i) scanf("%llu",&a[i]);
    for(reg int i=1;i<=k;++i) scanf("%llu",&f[i]);
    if(n<=k){
        printf("%llu",a[n]);
        return 0;
    }
    reverse(f+1,f+k+1);
    for(reg int i=0;i!=k;++i) A.a[i][0] = f[i+1];
    for(reg int i=1;i!=k;++i) A.a[i-1][i] = inf;
    A.siz = k;
    A = power(A,n-k+1);
    for(reg int i=0;i<k;++i)
        ans |= a[k-i-1]&A.a[i][0];
    printf("%llu",ans);
    return 0;
}
```

---

## 作者：Durancer (赞：3)

### 前置知识

- 矩阵乘法

- 位运算以及矩阵运算律的较深理解

### 思路

根据这个运算法则，我们肯定知道普通的矩阵乘法是不行的，所以就要稍微把运算改良一下。

```cpp
Matrix operator*(const Matrix &b)const
	{
		Matrix res;
		for(int i=1;i<=100;i++)
			for(int j=1;j<=100;j++)
				for(int k=1;k<=100;k++)
					res.a[i][j]=(res.a[i][j]|(a[i][k]&b.a[k][j]));	
		return res;
	}
```

这样就符合 $A_n$ 计算的第二种情况了，我们也可以构造出初始矩阵：

$$A=\begin{bmatrix} A_{k-1}& A_{k-1}&\cdots&A_{2}&A_{1}&A_{0}\end{bmatrix}$$

$$B=\begin{bmatrix} b_{k-1}&-1&0&\cdots&\cdots&0\\b_{k-2}&0&-1&\cdots&\cdots&0\\\vdots& \vdots & \vdots & \vdots & \ddots & \vdots
\\b_0&0&0&\cdots&\cdots&0\end{bmatrix}$$

可以发现设置的 $B$ 矩阵和原来的有所不同，因为 $\otimes$ 的缘故，所以我们对一些值得复制也会有所改变，变为 $-1$ 之后，它的二进制会变成 $11111_{(2)}$，所以可以复制任何的数数。

其他的过程和正常的矩阵快速幂基本一样，然后本题就很快乐地完结了！

### 代码实现

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<queue>
#include<stack>
#include<vector>
#include<algorithm>
#include<map>
#define int long long 
using namespace std; 
const int N=1e2+9;
struct Matrix{
	int a[N][N];
	Matrix() {memset(a,0,sizeof(a));}
	Matrix operator*(const Matrix &b)const
	{
		Matrix res;
		for(int i=1;i<=100;i++)
			for(int j=1;j<=100;j++)
				for(int k=1;k<=100;k++)
					res.a[i][j]=(res.a[i][j]|(a[i][k]&b.a[k][j]));	
		return res;
	}
}ans,base;
int n,k;
int A[N];
int B[N];
int read()
{
	int f=1,x=0;
	char s=getchar();
	while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}
	while(s>='0'&&s<='9'){x=(x<<1)+(x<<3)+(s^'0');s=getchar();}
	return f*x;
}
void quick(int p)
{
	while(p)
	{
		if(p&1) ans=ans*base;
		base=base*base;
		p>>=1;
	}
}
void Prepare()
{
	for(int i=0;i<k;i++)
		ans.a[1][k-i]=A[i];
	for(int i=0;i<k;i++)
		base.a[k-i][1]=B[i];
	for(int i=2;i<=k;i++)
		base.a[i-1][i]=-1;//直接-1=1111111111获得原数 
}
void Work()
{
	if(n<k)
	{
		cout<<A[n]<<endl;
		return;
	}
	else
	{
		n-=(k-1);
		quick(n);
		cout<<ans.a[1][1]<<endl;	
	}
}
signed main()
{
	n=read();
	k=read();
	for(int i=0;i<k;i++)
		A[i]=read();
	for(int i=0;i<k;i++)
		B[i]=read();
	Prepare();
	Work();
	//for(int i=1;i<=k;i++)
	//	cout<<ans.a[1][i]<<" ";
	return 0;
}
```





---

## 作者：zzqDeco (赞：3)

这道题其实就是单纯考察的对矩阵的理解

在广义的矩阵运算中只要使其满足结合律就能像普通的矩阵运算一样操作

（实际上不难发现，这东西很想NOIonline的某道题的矩阵的乘法和加法的定义一样

我们考虑转移矩阵咋构建

实际上我们要使得在转移矩阵中的前 $k-1$ 个 满足$A_n-1 \to  A_n$，最后一个满足我们的递推关系（其实就和一般的一样

在这里我们只考虑一个东西，就是说找到加法和乘法的单位元

实际上这里的加法的单位元就是 $-1$ ,乘法的就是 $0$

那么我们就是将
$$
A=
\left\{
\begin{matrix}
   0 & 1 & 0 & \cdots & 0 \\
   0 & 0 & 1 & \cdots & 0 \\
   \vdots & \vdots & \vdots & \ddots & \vdots \\
   0 & 0 & 0 & \cdots & 1 \\
   a_{1} & a_{2} & a_{3} & \cdots & a_{n}
\end{matrix}
\right\}
$$
变为
$$
A=
\left\{
\begin{matrix}
   0 & -1 & 0 & \cdots & 0 \\
   0 & 0 & -1 & \cdots & 0 \\
   \vdots & \vdots & \vdots & \ddots & \vdots \\
   0 & 0 & 0 & \cdots & -1 \\
   a_{1} & a_{2} & a_{3} & \cdots & a_{n}
\end{matrix}
\right\}
$$

复杂度就是$O(k^3logn)$

code:
```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

int n,k;

struct M
{
  long long s[110][110],r,c;
  void clear()
  {
    for(int i=1;i<=100;i++) for(int j=1;j<=100;j++) s[i][j]=0;
  }
}ans,Ye;

M operator * (const M &x,const M &y)
{
  M now;
  now.clear();
  now.r=x.r;
  now.c=y.c;
  for(int k=1;k<=x.c;k++)
  {
    for(int i=1;i<=x.r;i++)
    {
      for(int j=1;j<=y.c;j++)
      {
        now.s[i][j]|=x.s[i][k]&y.s[k][j];
      }
    }
  }
  return now;
}

M ksm(M a,int b)
{
  M ans=a;
  b--;
  while(b)
  {
    if(b&1) ans=ans*a;
    a=a*a;
    b>>=1;
  }
  return ans;
}

int main()
{
  scanf("%d%d",&n,&k);
  ans.clear();
  ans.r=1;
  ans.c=k;
  for(int i=1;i<=k;i++) scanf("%lld",&ans.s[1][i]);
  Ye.clear();
  Ye.r=k;
  Ye.c=k;
  for(int i=1;i<=k;i++)
  {
    long long now;
    scanf("%lld",&now);
    Ye.s[i][k]=now;
  }
  for(int i=1;i<=k;i++)
  {
    for(int j=1;j<=k;j++)
    {
      if(i==j+1) Ye.s[i][j]=-1;
    }
  }
  if(n<=k)
  {
    printf("%lld",ans.s[1][n]);
  }
  else
  {
    M now=ans*ksm(Ye,n-k+1);
    printf("%lld",now.s[1][k]);
  }
}
```

---

## 作者：BDFCL (赞：3)

**Solution**

给定了递推式，要快速求递推式的值，显然想到矩阵快速幂

我们将矩阵快速幂中原本的加法定义为"|"运算（即按位或），将乘法定义为"&"运算（即按位与），根据题意，写出转移式：
$$
\left[ \begin {matrix} A_i & A_{i-1} & A_{i-2} & \dots & A_{k}\end {matrix} \right] = 
\left[ \begin {matrix} A_{i-1} & A_{i-2} & A_{i-3} \dots & A_{k-1}\end {matrix} \right] 
\times 
\left[ \begin {matrix} 
b_k 	& maxx 	& 0 	& \cdots 	& 0		\\
b_{k-1} & 0 	& maxx 	& \cdots 	& 0		\\
b_{k-2} & 0 	& 0 	&\cdots 	& 0		\\
\vdots 	& \vdots&\vdots	&\ddots		&\vdots	\\
b_{1} 	& 0		& 0 	&\cdots		&0
\end {matrix} \right]
$$
其中$maxx = 2^{63}-1$，同时为方便起见，$b$数组下标统一$+1$

转移矩阵$Mat1$（就是柿子里的最后一个矩阵）简单来说就是第$1$列第$j$行为$b_{k-j+1}$，第$i$列$i+1$行为$maxx$，其余的都为$0$

根据题意，初始矩阵为
$$
Mat0 = \left[ \begin{matrix}a_k & a_{k-1} & a_{k-2} & \cdots & a_1 \end{matrix}\right]
$$
同样为方便起见，$a$数组下标统一$+1$

所以最终答案就是$Ans$矩阵的$Ans_{1, 1}$，其中$Ans$矩阵为：
$$
Ans = Mat0 \times Mat1^{n-k+1}
$$
注意题目中$A$数组是从$0$开始编号的，所以是$Mat1^{n-k+1}$而不是$Mat1^{n-k}$

还有就是当$n \leq k$的时候要特判

时间复杂度$O(k^3 \log n)$

**Code**

```c++
#include <bits/stdc++.h>

#define N (int) 105
#define ll long long

using namespace std;
ll input () {
	ll x = 0, f = 0;
	char c = getchar ();
	while (c < '0' || c > '9') f = c == '-', c = getchar ();
	while (c >= '0' && c <= '9') x = (x << 1) + (x << 3) + (c ^ 48), c = getchar ();
	return f ? - x : x;
}

const ll maxx = (1ull<<63)-1;

int n, k;
ll a[N], b[N];

struct Matrix { // 矩阵
	int n, m;
	ll a[N][N];
	friend Matrix operator * (const Matrix & x, const Matrix & y) { // 定义矩阵乘法
		Matrix ret;
		ret.n = x.n, ret.m = y.m;
		for (int i = 1; i <= x.n; i ++) {
			for (int j = 1; j <= y.m; j ++) {
				for (int k = 1; k <= x.m; k ++) {
					ret.a[i][j] |= x.a[i][k] & y.a[k][j];
				}
			}
		}
		return ret;
	}
	Matrix () {
		n = m = 0;
		memset (a, 0, sizeof (a));
	}
} mat0, mat1;

Matrix ksm (Matrix x, int y) { // 矩阵快速幂
	Matrix ret = x;
	y --;
	while (y) {
		if (y & 1) ret = ret * x;
		x = x * x;
		y >>= 1;
	}
	return ret;
}

int main () {
	n = input (), k = input ();
	for (int i = 1; i <= k; i ++) a[i] = input ();
	for (int i = 1; i <= k; i ++) b[i] = input ();

	if (n <= k) { // 特判
		printf ("%lld\n", a[n]);
		return 0;
	}

	mat1.n = mat1.m = k; // 转移矩阵
	for (int i = 1; i <= k; i ++)
		mat1.a[i][1] = b[k-i+1];
	for (int i = 1; i < k; i ++)
		mat1.a[i][i+1] = maxx;
	mat0.n = 1, mat0.m = k; // 初始矩阵
	for (int i = 1; i <= k; i ++)
		mat0.a[1][i] = a[k-i+1];
	
	Matrix ans = mat0 * ksm (mat1, n-k+1);
	
	printf ("%lld\n", ans.a[1][1]);
	
	return 0;
}

```

**Conclusion**

1 加速递推式——矩阵快速幂

2 注意一些细节（如下标从$0$开始之类的）

---

## 作者：XCDRF_ (赞：1)

# P5678 \[GZOI2017] 河神

[原题传送门](https://www.luogu.com.cn/problem/P5678)

[更好的阅读体验](https://www.luogu.com.cn/article/lgiuqhes)

## 解题思路

这个题是一个递推题，$n$ 的范围还特别大，可以首先想到矩阵加速。

但正常的矩阵乘法只能做乘法和加法操作，这个题却要求做与和或操作，怎样处理？只需要将乘法用与代替，将加法用或代替即可。无论有什么操作，本质上还是递推，只要能满足矩阵乘法的运算法则，就可以进行加速。

由此我们就可以得到递推式：

$$\begin{bmatrix} b_{k-1} & b_{k-2}& b_{k-3}& \cdots & b_1 & b_0\\ -1 & 0 & 0 & \cdots & 0 & 0\\ 0 & -1 & 0 & \cdots & 0 & 0 \\ \vdots & \vdots & \vdots & \ddots & \vdots & \vdots \\ 0 & 0 & 0 & \cdots & -1 &0\end{bmatrix} \times \begin{bmatrix} a_{n-1} \\ a_{n-2}\\ a_{n-3} \\ \vdots \\ a_{n-k} \end{bmatrix} = \begin{bmatrix} a_{n} \\ a_{n-1}\\ a_{n-2} \\ \vdots \\ a_{n-k+1} \end{bmatrix}$$

因为做的是或操作，所以如果要转移就需要或上一个二进制每一位都为 $1$ 的数，就是 $-1$。

这样我们就可以在 $O(k^3\log n)$ 的时间复杂度下 AC 这个题啦。

## 参考代码

```cpp
#include<iostream>
#include<cstring>
#define int long long
using namespace std;
const int N=105;
int n,k;
int a[N],b[N];
struct Matrix{
	int a[N][N];
	void mem(){
		memset(a,0,sizeof(a));
	}
	void id(){
		for(int i=1;i<=k;i++) a[i][i]=-1;//初始单位矩阵也要赋成-1
	}
	Matrix operator * (const Matrix &rhs){
		Matrix res;
        res.mem();
        for(int i=1;i<=k;i++)
            for(int j=1;j<=k;j++)
                for(int l=1;l<=k;l++)
                    res.a[i][j]|=(a[i][l]&rhs.a[l][j]);//乘变与，加变或
        return res; 
	}
}mp,anss;
Matrix ksm(Matrix a,int b){
	Matrix res;
	res.mem(),res.id();
	while(b){
		if(b&1) res=res*a;
		a=a*a;
		b>>=1;
	}
	return res;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>n>>k;
	for(int i=0;i<k;i++) cin>>a[i];
	for(int i=0;i<k;i++) cin>>b[i];
	if(n<k){
		cout<<a[n];
		return 0;
	}
	for(int i=1;i<=k;i++){//初始化
		if(i==1)
			for(int j=1;j<=k;j++) mp.a[i][j]=b[k-j];
		else mp.a[i][i-1]=-1;
		anss.a[i][1]=a[k-i];
	}
	anss=ksm(mp,n-k+1)*anss;
	cout<<anss.a[1][1];
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/203584392)

---

## 作者：CherryPockyOvO (赞：1)

### 本题是对 矩阵概念理解 的考察

### _前置讲解_ 

我们先来看一下矩阵的定义式

### $ \sum_{k = 1}^m A_{i, k} \times B_{k, j} $

然后我们发现根据题意
发现这道题目实质上是
### 将 求和 变成 或 |
### 将 乘法 变成 与 &

故只要将矩阵乘法的板子的运算符号改一下就阔以了。
即

### $ \bigoplus_{k = 1}^m A_{i, k} \otimes B_{k, j} $

###  _解题思路_

得到上面柿子之后我们对转移矩阵进行构造，因为每次转移需要用到 k 个值

所以状态矩阵大小 1 $\times$ k, 转移矩阵大小 k $\times$ k

模拟题意

易构造出矩阵

### 状态矩阵

$\begin{bmatrix}
A_n & A_{n - 1} & \cdots & A_{n - k + 1}\\
\end{bmatrix}$

### 转移矩阵

$\begin{bmatrix}
b_{n - 1} & INF &\cdots     &\cdots & 0 \\
b_{n-2} &0 & INF &\cdots & 0   \\   
\vdots &0 &0 & INF & \cdots \\
b_{n - k + 1}  &\cdots    & \cdots & \cdots&INF\\
b_{n - k }  &\cdots &\cdots   & \cdots & 0
\end{bmatrix} $

其中 INF & a （a < $2^{63}$）的值都为 a 

INF 取 (1 << 63) - 1 就行了

下面就是正常的矩阵快速幂的过程，这里不再赘述。

### _code_

```cpp
#include<bits/stdc++.h>
#define debug(x) cerr << #x << " = " << x <<endl;
#define rep(i, a, b) for(int i = (a); i <= (b); ++ i)
#define INF ((1ull << 63) - 1) 
using namespace std;
template<typename Tp> void Cmax(Tp &x, Tp y) { x = max(x, y); }
template<typename Tp> void Csum(Tp &x, Tp y) { x = x + y; }
template<typename Tp>
void read(Tp &x){
	x = 0; int f = 1;
	char ch = getchar();
	while(!isdigit(ch)){ if(ch == '-') f = -1; ch = getchar(); }
	while(isdigit(ch)){ x = x * 10 + ch - 48; ch = getchar(); }
	x = x * f;
}
typedef unsigned long long ULL;
typedef double doub;
const int N = 130;
int n, k;
ULL f[N], C[N][N];
void mul(){
	ULL ff[N];
	memset(ff, 0, sizeof ff);
	rep(i, 0, k - 1)
		rep(j, 0, k - 1)
			ff[i] |= f[j] & C[j][i]; // 实质上改的 只有这里 
	memcpy(f, ff, sizeof f);
}
void mulself(){
	ULL ff[N][N];
	memset(ff, 0, sizeof ff);
	rep(i, 0, k - 1)
		rep(j, 0, k - 1)
			rep(t, 0, k - 1)
				ff[i][j] |= C[i][t] & C[t][j]; // 改的只 有这里 
	memcpy(C, ff, sizeof C);
}
signed main(){
	read(n); read(k);
	for(int i = k - 1; i >= 0; --i)
		read(f[i]);
	for(int i = k - 1; i >= 0; --i)
		read(C[i][0]);
	rep(i, 0, k - 1)
		C[i][i + 1] = INF; 
	if(k >= n){
		printf("%llu\n", f[k - n]);
		return 0;
	}
	n = n - k + 1;
	while(n){
		if(n & 1) 
			mul();
		n >>= 1;
		mulself();
	}
	printf("%llu\n", f[0]);
	return 0;
}
```

---


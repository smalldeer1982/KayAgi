# [P5087] 数学 加强版

## 题目背景

[原题链接](https://www.luogu.com.cn/problem/P5087)

## 题目描述

小奔热衷于乘法，他最喜欢做的事情是：从一个有 $n$ 个元素的可重集中选出 $k$ 个数，并把这 $k$ 个数的乘积作为这个组合的分数。

小奔想试遍所有的这些组合，然后算出所有这些组合的分数之和。但是他还要出模拟赛虐爆我们这些蒟蒻，所以他只好把这个任务交给了你。

作为不良心的出题人，这题你还要将答案对 $10^9 + 7$ 取模。


## 说明/提示

【样例二解释】  
有四种选择方案，一种是 $\{1,1,1\}$ 和三种都是 $\{1,1,2\}$，分数之和为 $7$。

【数据范围】  
对于 $100\%$ 的数据，$1\le k \le n \le 1.2\times 10^5$，$1\le a_i \le 10^8$。

## 样例 #1

### 输入

```
3 3
1 1 1```

### 输出

```
1```

## 样例 #2

### 输入

```
4 3
1 1 1 2```

### 输出

```
7```

## 样例 #3

### 输入

```
10 7
11 45 14 19 19 8 10 8 17 23```

### 输出

```
693404716```

# 题解

## 作者：iostream (赞：6)

对于弱化版，可以 0/1 背包，时间复杂度是 $O(nk)$ 的。

对于每个数，可以选或者不选，那我们构造其生成函数为 $1+a_ix$，表示这个人选了就可以为总乘积产生 $a_i$ 的贡献。

那么要求恰好 $k$ 个，答案就是 $[x^k]\prod_{i=1}^n (1+a_ix)$，用分治 fft 计算即可，这个题中需要使用拆系数 fft。

```cpp
#include<queue>
#include<vector>
#include<math.h>
#include<stdio.h>
#include<string.h>
#include<algorithm>
#define SZ(x) ((int)x.size())
using namespace std;
typedef long long ll;
typedef vector<int> poly;
const int sz=17,N=1<<17|5;
const double Pi=acos(-1);

const int P=1e9+7;

int L,rev[N];
struct Cp {
	double x, y;
	Cp(double a = 0, double b = 0) : x(a), y(b) {}
	Cp operator + (Cp t) { return Cp(x + t.x, y + t.y); }
	Cp operator - (Cp t) { return Cp(x - t.x, y - t.y); }
	Cp operator * (Cp t) { return Cp(x * t.x - y * t.y, x * t.y + y * t.x); }
	Cp operator / (double t) { return Cp(x / t, y / t); }
	Cp operator ~ () { return Cp(x, -y); }
}w[N],_[N];

void init(){
	L=1<<sz;
	for(int i=0;i<L;i++)rev[i]=(rev[i>>1]>>1)|((i&1)<<(sz-1));
	w[L/2]=Cp(1,0);
	for(int i=1;i<L/2;i++)w[i+L/2]=Cp(cos(2*Pi*i/L),sin(2*Pi*i/L));
	for(int i=L/2-1;i>=0;i--)w[i]=w[i<<1];
}

void dft(int n,Cp*a){
	for(int i=0,s=sz-__builtin_ctz(n);i<n;i++)_[rev[i]>>s]=a[i];
	for(int l=1;l<n;l<<=1)for(int i=0;i<n;i+=l+l)for(int j=0;j<l;j++)
	{Cp k=_[i+j+l]*w[j+l];_[i+j+l]=_[i+j]-k;_[i+j]=_[i+j]+k;}
	memcpy(a,_,sizeof(Cp)*n);
}

struct __mtt {
	int Mod;
	Cp a[N], b[N], c[N], d[N];
	__mtt(int _Md = 1000000007) : Mod(_Md) {}
	poly operator()(const poly& p,const poly& q) {
		int l;
		for(l=1; l<=SZ(p)+SZ(q)-2; l<<=1);
		memset(a,0,sizeof(Cp)*l);
		memset(b,0,sizeof(Cp)*l);
		for(int i=0; i<SZ(p); i++)
			a[i]=Cp(p[i]&32767,p[i]>>15);
		for(int i=0; i<SZ(q); i++)
			b[i]=Cp(q[i]&32767,q[i]>>15);
		dft(l,a);dft(l,b);
		for(int i=0; i!=l; i++){
			int j=(l-i)&(l-1);
			c[i]=(~a[i]+a[j])*Cp(0.5,0)*b[j];
			d[i]=(~a[i]-a[j])*Cp(0,0.5)*b[j];
		}
		dft(l,c);dft(l,d);
		auto Z=[&](double x){return(ll)(0.5+x)%Mod;};
		poly v(SZ(p)+SZ(q)-1);
		for(int i=0; i<SZ(v); i++)
			v[i]=(Z(c[i].x/l)+(Z(c[i].y/l)+Z(d[i].x/l))%Mod*32768+Z(d[i].y/l)%Mod*32768%Mod*32768)%Mod;
		return v;
	}
}mtt;

int n,k,x;
poly f[N];

poly solve(int l,int r)
{
	if(l==r)return f[l];
	return mtt(solve(l,(l+r)/2),solve((l+r)/2+1,r));
}

int main()
{
	init();
	scanf("%d%d",&n,&k);
	for(int i=1; i<=n; i++)
	{
		scanf("%d",&x);
		f[i]=(poly){1,x};
	}
	printf("%d",solve(1,n)[k]);
	return 0;
}
```

---

## 作者：Karry5307 (赞：4)

### 题意

给定一个长度为 $n$ 的序列 $a_i$，求出在这个序列中所有选出 $k$ 个元素方案中元素的乘积之和。

$\texttt{Data Range:}1\leq k\leq n\leq 1.2\times 10^5$

### 题解

~~水多项式题好开心诶qaq~~

多项式乘法。

很明显答案为

$$[x^k]\prod\limits_{i=1}^{n}(1+a_ix)$$

来考虑一下证明。

这些多项式乘积中 $x^k$ 的系数相当于在 $n$ 个多项式任意选出 $k$ 个多项式，其中被选出来的的取一次项，剩下的取常数项，将这些东西乘起来的和。这个东西很明显是跟题目等价的。

~~上面的东西蒯的我原题的题解~~

注意到类似于这种东西可以分治 NTT 做，因为模数是 $10^9+7$ 所以需要 MTT。

由于我本人没有特意卡过 FFT 所以这份代码跑的很慢。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef int ll;
typedef long long int li;
typedef long double db;
const ll MAXN=262151,MOD=1e9+7;
const db PI=acos(-1.0);
struct Complex{
	db re,im;
	Complex(db x=0,db y=0)
	{
		re=x,im=y;
	}
	inline Complex conj()
	{
		return Complex(re,-im);
	}
};
ll n,syk;
ll x[MAXN],rev[MAXN];
vector<ll>f[MAXN];
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
        neg=-1;
        ch=getchar();
    }
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
}
inline Complex operator +(Complex x,Complex y)
{
	return Complex(x.re+y.re,x.im+y.im);
}
inline Complex operator -(Complex x,Complex y)
{
	return Complex(x.re-y.re,x.im-y.im);
}
inline Complex operator *(Complex x,Complex y)
{
	return Complex(x.re*y.re-x.im*y.im,x.re*y.im+x.im*y.re);
}
inline Complex operator /(Complex x,db y)
{
	return Complex(x.re/y,x.im/y);
}
inline void FFT(Complex *cp,ll cnt,ll inv)
{
	ll cur=0;
	Complex res,omg;
	for(register int i=0;i<cnt;i++)
	{
		if(i<rev[i])
		{
			swap(cp[i],cp[rev[i]]);
		}
	}
	for(register int i=2;i<=cnt;i<<=1)
	{
		cur=i>>1,res=Complex(cos(2*PI/i),inv*sin(2*PI/i));
		for(register Complex *p=cp;p!=cp+cnt;p+=i)
		{
			omg=Complex(1,0);
			for(register int j=0;j<cur;j++)
			{
				Complex t=omg*p[j+cur],t2=p[j];
				p[j+cur]=t2-t,p[j]=t+t2;
				omg=omg*res;
			}
		}
	}
	if(inv==-1)
	{
		for(register int i=0;i<cnt;i++)
		{
			cp[i]=cp[i]/cnt;
		}
	}
}
inline void conv(ll fd,ll *f,ll *g,ll *res)
{
	Complex p,q,r,s;
	ll t,cnt=1,limit=-1;
	li t0,t1,t2,t3;
	static Complex tmpf[MAXN],tmpg[MAXN],p0[MAXN],p1[MAXN],p2[MAXN],p3[MAXN];
	while(cnt<=(fd<<1))
	{
		cnt<<=1,limit++;
	}
	for(register int i=0;i<cnt;i++)
	{
		tmpf[i]=i<fd?Complex(f[i]&32767,f[i]>>15):Complex();
		tmpg[i]=i<fd?Complex(g[i]&32767,g[i]>>15):Complex();
		rev[i]=(rev[i>>1]>>1)|((i&1)<<limit);
	}
	FFT(tmpf,cnt,1),FFT(tmpg,cnt,1);
	for(register int i=0;i<cnt;i++)
	{
		t=(cnt-i)&(cnt-1);
		p=(tmpf[i]+tmpf[t].conj())*Complex(0.5,0);
		q=(tmpf[i]-tmpf[t].conj())*Complex(0,-0.5);
		r=(tmpg[i]+tmpg[t].conj())*Complex(0.5,0);
		s=(tmpg[i]-tmpg[t].conj())*Complex(0,-0.5);
		p0[i]=p*r,p1[i]=p*s,p2[i]=q*r,p3[i]=q*s;
	}
	for(register int i=0;i<cnt;i++)
	{
		tmpf[i]=p0[i]+p1[i]*Complex(0,1);
		tmpg[i]=p2[i]+p3[i]*Complex(0,1);
	}
	FFT(tmpf,cnt,-1),FFT(tmpg,cnt,-1);
	for(register int i=0;i<cnt;i++)
	{
		t0=(li)(tmpf[i].re+0.5)%MOD,t1=(li)(tmpf[i].im+0.5)%MOD;
		t2=(li)(tmpg[i].re+0.5)%MOD,t3=(li)(tmpg[i].im+0.5)%MOD;
		res[i]=(t0+(t1+t2)*32768%MOD+t3*1073741824ll%MOD)%MOD;
	}
}
inline void dnc(ll l,ll r,ll x)
{
	static ll tmp[MAXN],tmp2[MAXN],tmp3[MAXN];
	if(l==r)
	{
		return (void)(f[x].push_back(1),f[x].push_back(::x[l]));
	}
	ll mid=(l+r)>>1,ls=x<<1,rs=ls|1,szl,szr;
	dnc(l,mid,ls),dnc(mid+1,r,rs),szl=f[ls].size(),szr=f[rs].size();
	copy(f[ls].begin(),f[ls].end(),tmp),copy(f[rs].begin(),f[rs].end(),tmp2);
	szr!=szl?tmp2[szr]=0:1,conv(szl,tmp,tmp2,tmp3),f[x].resize(szl+szr-1);
	copy(tmp3,tmp3+szl+szr-1,f[x].begin());
}
int main()
{
	n=read(),syk=read();
	for(register int i=1;i<=n;i++)
	{
		x[i]=read();
	}
	dnc(1,n,1),printf("%d\n",f[1][syk]);
}
```

---

## 作者：Super_Cube (赞：3)

# Solution

考虑 dp，设 $dp_{i,j}$ 表示前 $i$ 个数中选 $j$ 个数的分数和。

第 $i$ 个元素是可选可不选两种，对应 $dp_{i-1,j}$ 和 $a_i\cdot dp_{i-1,j-1}$，加和即可。最后的答案对应 $dp_{n,k}$。

其实是一个很典也很板的 0/1 背包。

时间复杂度 $O(nk)$，很明显不能通过。

考虑生成函数，设 $F_i(x)=\displaystyle\sum_{j=0}^{i}dp_{i,j}\cdot x^j$。

根据前面的 dp 转移式，可以得到：$F_i(x)=F_{i-1}(x)+a_i\cdot x\cdot F_{i-1}(x)$。

所以 $F_n(x)=\displaystyle\prod_{i=1}^{n}(1+a_i\cdot x)$，最后的答案对应 $[x^k]F_n(x)$。

问题来了：怎么算这 $n$ 个多项式相乘的结果？

直接暴力多项式乘起来大概算了一下复杂度是 $O(n^2\log n)$，这远远不如之前。

~~难道说这道题就要开摆了吗？~~

这里就有一个很典的 trick 了：分治。

具体来说，对于 $l\sim r$ 这一段所有多项式的乘法，先算 $l\sim mid$，再算 $mid+1 \sim r$，最后把两边结果合并。

感觉没什么用？来分析下，设时间复杂度函数为 $T(n)$，根据上面这个 trick 可以得到 $T(n)=2T(\frac{n}{2})+O(n\log n)$，所以 $T(n)=O(n\log^2 n)$。

嗯，很好，现在的复杂度就可以接受了。

当然这道题还有个令人头疼的地方：模数不是 $998244353$。这意味着你不能使用普通的 NTT 去做，而 FFT 会炸精度。明显是出题人故意恶心你。

那该怎么办呢？~~建议左转至 [P4245 【模板】任意模数多项式乘法](/prob1em/P4245) 进行学习。~~

我用的是拆位 FFT，是不加任何优化的 4 次 DFT 与 3 次 IDFT 版本。跑下来一点不卡常，每个点稳定在 1.38s 左右。

# Code

```cpp
#define _USE_MATH_DEFINES
#include<bits/stdc++.h>
const int mod=1e9+7;
inline void FFT(std::vector<std::complex<long double> >&a,int tp){
	static int rev[262144];
	static int n;n=a.size()-1;
	for(int i=0;i<n;++i)
		rev[i]=(rev[i>>1]>>1)|(i&1?n>>1:0);
	for(int i=0;i<n;++i)
		if(i<rev[i])std::swap(a[i],a[rev[i]]);
	for(int i=1;i<n;i<<=1){
		std::complex<long double>wn(cosl(M_PI/i),tp*sinl(M_PI/i));
		for(int j=0;j<n;j+=i<<1){
			std::complex<long double>w(1,0),x,y;
			for(int k=0;k<i;++k,w*=wn)
				x=a[j+k],y=w*a[j+i+k],
				a[j+k]=x+y,a[j+i+k]=x-y;
		}
	}
	if(tp==-1)
		for(int i=0;i<n;++i)
			a[i]/=n;
}
inline std::vector<int>polymul(std::vector<int>a,std::vector<int>b){
	static int n,m,lim;
	n=a.size()-1;m=b.size()-1;
	lim=1<<std::__lg(n+m)+1;
	std::vector<std::complex<long double> >a1(lim+1),a2(lim+1),b1(lim+1),b2(lim+1);
	for(int i=0;i<=n;++i)
		a1[i]=a[i]>>15,a2[i]=a[i]&32767;
	for(int i=0;i<=m;++i)
		b1[i]=b[i]>>15,b2[i]=b[i]&32767;
	FFT(a1,1);FFT(a2,1);FFT(b1,1);FFT(b2,1);
	std::vector<std::complex<long double> >ac(lim+1),adbc(lim+1),bd(lim+1);
	for(int i=0;i<=lim;++i)
		ac[i]=a1[i]*b1[i],adbc[i]=a1[i]*b2[i]+a2[i]*b1[i],bd[i]=a2[i]*b2[i];
	FFT(ac,-1);FFT(adbc,-1);FFT(bd,-1);
	std::vector<int>ans(n+m+1);
	for(int i=0;i<=n+m;++i)
		ans[i]=(((long long)(ac[i].real()+0.5)%mod<<30)+((long long)(adbc[i].real()+0.5)<<15)+(long long)(bd[i].real()+0.5))%mod;
	return ans;
}
int a[120005];
std::vector<int>cdq(int l,int r){
	if(l==r)return std::vector<int>{1,a[l]};
	return polymul(cdq(l,l+r>>1),cdq((l+r>>1)+1,r));
}
int n,m;
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)
		scanf("%d",&a[i]);
	printf("%d",cdq(1,n)[m]);
	return 0;
}
```

---

## 作者：RuSun (赞：2)

其他题解都写的拆系数 fft ，这里提供一个 3模数NTT 的代码。

考虑构造生成函数，对于一个数 $k$ ，选择则答案乘 $k$ ，个数加一；不选择则不变：那么有 $f(x) = 1 + kx$ 。答案为 $[x ^ n]\prod f(x)$ 。

将所有函数乘起来，注意到每个多项式的次数很小，挨个乘代价很大。考虑分治，每次将左右一半合并。那么有 $T(n) = T(\frac n 2) + O(n \log n) = O(n \log ^ 2 n)$ 。

尽量减少不必要的取模，优化加减法的取模，将处理范围压死，开 O2 。。。可以卡过。

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;
template <class Type>
void read(Type &x)
{
    char c;
    bool flag = false;
    while ((c = getchar()) < '0' || c > '9')
        c == '-' && (flag = true);
    x = c - '0';
    while ((c = getchar()) >= '0' && c <= '9')
        x = (x << 3) + (x << 1) + c - '0';
    if (flag) x = ~x + 1;
}
template <class Type, class ...rest>
void read(Type &x, rest &...y) { read(x), read(y...); }
template <class Type>
void write(Type x)
{
    if (x < 0) putchar('-'), x = ~x + 1;
    if (x > 9) write(x / 10);
    putchar(x % 10 + '0');
}
typedef __int128 L;
typedef long long LL;
const int N = 1e6 + 10, p1 = 998244353, p2 = 1004535809, p3 = 469762049, p = 1e9 + 7;
template <const int &mod>
struct NTT
{
    int rev[N];
    void adj (int &x) { x += x >> 31 & mod; }
    int binpow (int b, int k = mod - 2)
    {
        int res = 1;
        for (; k; k >>= 1, b = (LL)b * b % mod)
            if (k & 1) res = (LL)res * b % mod;
        return res;
    }
    void ntt (int *x, int bit, int op)
    {
        int tot = 1 << bit;
        for (int i = 0; i < tot; ++i)
            if ((rev[i] = rev[i >> 1] >> 1 | ((i & 1) << bit - 1)) > i)
                swap(x[rev[i]], x[i]);
        for (int mid = 1; mid < tot; mid <<= 1)
        {
            int w1 = binpow(3, (mod - 1) / (mid << 1));
            if (!~op) w1 = binpow(w1);
            for (int i = 0; i < tot; i += mid << 1)
                for (int j = 0, k = 1; j < mid; ++j, k = (LL)k * w1 % mod)
                {
                    int p = x[i | j], q = (LL)k * x[i | j | mid] % mod;
                    adj((x[i | j] = p) += q - mod), adj((x[i | j | mid] = p) -= q);
                }
        }
        if (~op) return;
        int itot = binpow(tot);
        for (int i = 0; i < tot; ++i)
            x[i] = (LL)x[i] * itot % mod;
    }
    void PolyMul (int n, vector <int> &f, int m, vector <int> &g, int nm, vector <int> &w)
    {
        static int A[N], B[N], C[N];
        for (int i = 0; i <= n; ++i)
            adj(A[i] = f[i] - mod);
        for (int i = 0; i <= m; ++i)
            adj(B[i] = g[i] - mod);
        int bit = 1;
        while (n + m + 1 > 1 << bit) ++bit;
        int tot = 1 << bit;
        for (int i = n + 1; i < tot; ++i) A[i] = 0;
        for (int i = m + 1; i < tot; ++i) B[i] = 0;
        ntt(A, bit, 1), ntt(B, bit, 1);
        for (int i = 0; i < tot; ++i)
            C[i] = (LL)A[i] * B[i] % mod;
        ntt(C, bit, -1);
        for (int i = 0; i <= nm; ++i) w[i] = C[i];
    }
};
NTT <p1> q1; NTT <p2> q2; NTT <p3> q3;
int CRT (int x1, int x2, int x3)
{
    L res = 0, mul = (L)p1 * p2 * p3;
    res += (L)x1 * p2 * p3 * q1.binpow((LL)p2 * p3 % p1);
    res += (L)x2 * p1 * p3 * q2.binpow((LL)p1 * p3 % p2);
    res += (L)x3 * p1 * p2 * q3.binpow((LL)p1 * p2 % p3);
    return res % mul % p;
}
void solve (int l, int r, int &k, vector <int> &g)
{
    if (l == r) return g[0] = 1, read(g[1]);
    int mid = l + r >> 1;
    int nm = min(k, r - l + 1), n = min(k, mid - l + 1), m = min(k, r - mid);
    vector <int> A, B, C, D, E;
    A.resize(n + 1); B.resize(m + 1);
    C.resize(nm + 1), D.resize(nm + 1), E.resize(nm + 1);
    solve(l, mid, k, A), solve(mid + 1, r, k, B);
    q1.PolyMul(n, A, m, B, nm, C);
    q2.PolyMul(n, A, m, B, nm, D);
    q3.PolyMul(n, A, m, B, nm, E);
    for (int i = 0; i <= nm; ++i)
        g[i] = CRT(C[i], D[i], E[i]);
}
int main ()
{
    int n, k;
    read(n, k);
    vector <int> A; A.resize(min(k, n) + 1);
    solve(1, n, k, A);
    write(A[k]);
    return 0;
}
```

---

## 作者：dead_X (赞：2)

## 前言
怎么没人做这题啊（
## 思路
显然这是一个背包问题，我们考虑构造答案的 $\text{OGF}$。

考虑记已经有一些物品时，装 $n$ 个物品的所有方法的价值和为 $F_n$。

然后这些物品对应答案的 $\text{OGF}$ 即为 $F(x)=\sum\limits_{i=0}^\infty F_ix^i$。

然后我们考虑合并两个物品集 $A,B$ 到 $C$，注意到选 $n$ 个物品的方案只能是在第一个物品集选 $i$ 个，再在第二个物品集选 $n-i$ 个，因此 $C_n=\sum\limits_{i=0}^nA_iB_{n-i}$。

诶，这不就是卷积形式吗？

于是这题只差最后一步了，考虑只有一个物品时答案的生成函数。这显然很简单，就是 $a_ix+1$，其中 $a_i$ 是权值。

然后直接分治 $\text{MTT}$ 就行啦！出题人要我们写 $\text{MTT}$，爬（

---


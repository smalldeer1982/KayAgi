# 随机红包

## 题目背景

出题人准备发一个微信红包给一些人，他很好奇如何随机分配里面的钱。

## 题目描述

出题人蒟蒻的红包里有着 $1$ 块钱，他要把这块钱随机分给 $n$ 个人。

为了随机，他设计了以下算法进行分配：（用伪代码表示）
```
a[0]=0,a[n]=1
for i=1 to n-1 do{
    a[i]=rand()
}
sort(a)
for i=1 to n do{
    money[i]=a[i]-a[i-1]
}
```
这里的 `rand()` 函数会等概率随机返回一个 $[0,1]$ 之间的实数值，`sort()` 函数会将一个数组从小到大排序。

现在，出题人蒟蒻很好奇得到钱数第 $k$ 少的人得到的钱的期望。

由于他要根据这个值去推算他要发多少个红包，所以他要问你 $T$ 次。

为了避免精度丢失，答案对 $998244353$ 取模。

为了避免输出量过大，输出所有答案的异或和。

## 说明/提示

**【样例解释】**

第一个问题，$n=k=1$，答案是 $1$。

第二个问题，较大的数在 $[\dfrac{1}{2},1]$ 上均匀分布，期望为 $\dfrac{3}{4}$，取模后为 $249561089$。

第三个问题，较小的数在 $[0,\dfrac{1}{2}]$ 上均匀分布，期望为 $\dfrac{1}{4}$，取模后为 $748683265$。

异或和为 $574619649$。

------

**【数据范围】**

**本题采用捆绑测试**。

$\text{Subtask 1 (4 pts)}$：$n \le 10$，$k=1$。

$\text{Subtask 2 (16 pts)}$：$n \le 5 \times 10^3$。

$\text{Subtask 3 (20 pts)}$：$k=1$。

$\text{Subtask 4 (28 pts)}$：$n \le 10^5$。

$\text{Subtask 5 (32 pts)}$：没有任何额外限制。

对于 $100\%$ 的数据，$1 \le k \le n \le 10^7$，$1 \le T \le 2 \times 10^5$。

## 样例 #1

### 输入

```
3
1 1
2 2
2 1```

### 输出

```
574619649```

# 题解

## 作者：鏡音リン (赞：48)

2021/06/29 更新：添加了详细的推式子过程，以及修改了排版。

如果有人问我推过最恶心的式子是哪个，我会说是这题。

**我就不打表找规律，推式子警告**

我们设 $f(n,k,x)$ 表示有 $n$ 个人的情况下，第 $k$ 小的红包钱数大于 $x$ 的概率。这也等价于至少 $n-k+1$ 个红包的钱数大于 $x$ 的概率。这里推荐使用第二种定义，方便理解后面的递推边界。

那么，容易看出我们要求的答案 $ans(n,k)=\int_0^1f(n,k,x)dx$。

考虑 $f$ 的递推式，$n$ 个人时生成了 $n-1$ 个随机数，设这些随机数里最小的那个是 $v$。此时一定有一个金额为 $v$ 的红包，讨论 $v$ 和 $x$ 的大小关系：

如果 $v<x$，那么剩下 $n-1$ 个红包里就需要 $n-k+1$ 个红包大于 $x$；

如果 $v>x$，那么剩下 $n-1$ 个红包里就需要 $n-k$ 个红包大于 $x$。

再想想，“$1-v$ 块钱分成 $n-1$ 个红包有 $n-k+1$ 个红包大于 $x$”和“$1$ 块钱分成 $n-1$ 个红包有 $n-k+1$ 个红包大于 $\frac{x}{1-v}$”是一样的，可以理解为通货膨胀了（？）

还有一个问题，虽然随机数是均匀分布的，但 $n-1$ 个随机数中的最小值 $v$ 可不是均匀分布的。我们要求出这个最小值小于 $v$ 的概率是 $1-(1-v)^{n-1}$，然后对它求导得到 $(n-1)(1-v)^{n-2}$，这个可以认为是最小值为 $v$ 的相对概率

综合上述讨论，可以得到 $f$ 的递推式

$$
\begin{aligned}
&f(n,k,x)\\
=&(n-1)\int_0^x(1-v)^{n-2}f(n-1,k-1,\frac{x}{1-v})dv\\
+&(n-1)\int_x^1(1-v)^{n-2}f(n-1,k,\frac{x}{1-v})dv
\end{aligned}
$$

开始积分

$$
\begin{aligned}
&\int_0^1f(n,k,x)dx\\
=&(n-1)\int_0^1\int_0^x(1-v)^{n-2}f(n-1,k-1,\frac{x}{1-v})dvdx\\
+&(n-1)\int_0^1\int_x^1(1-v)^{n-2}f(n-1,k,\frac{x}{1-v})dvdx
\end{aligned}
$$

设 $t=\frac{x}{1-v}$ 然后化简一波，此处省略去了漫长的计算过程

$$
\begin{aligned}
&\int_0^1f(n,k,x)dx\\
=&\frac{n-1}{n}\int_0^{+\infty} (1-\frac{1}{(t+1)^n})f(n-1,k-1,t)dt\\
+&\frac{n-1}{n}\int_0^{+\infty} \frac{1}{(t+1)^n}f(n-1,k-1,t)dt
\end{aligned}
$$

注意这里积分上界变成了 ${+\infty}$，不是 $1$，因为 $t$ 的范围可以到正无穷大，而且当 $k=n+1,x>1$ 时 $f(n,k,x)$ 仍然有意义且值为 $1$，所以一定要积到正无穷大！下面推边界的时候也有这方面的说明

貌似得到了更复杂的式子，出现了 $\frac{1}{(t+1)^n}$ 这个因子，我们用同样的方法继续积分看看

$$
\begin{aligned}
&\int_0^{+\infty} \frac{1}{(x+1)^{(n+1)}}f(n,k,x)dx\\
=&\frac{n-1}{n}\int_0^{+\infty} (\frac{1}{(t+1)^n}-\frac{1}{(2t+1)^n})f(n-1,k-1,t)dt\\
+&\frac{n-1}{n}\int_0^{+\infty} \frac{1}{(2t+1)^n}f(n-1,k-1,t)dt
\end{aligned}
$$

事情逐渐清晰起来，可以猜想并证明：

$$
\begin{aligned}
&\int_0^{+\infty} \frac{1}{(lx+1)^{(n+1)}}f(n,k,x)dx\\
=&\frac{n-1}{n}\int_0^{+\infty} (\frac{1}{(lt+1)^n}-\frac{1}{((l+1)t+1)^n})f(n-1,k-1,t)dt\\
+&\frac{n-1}{n}\int_0^{+\infty} \frac{1}{((l+1)t+1)^n}f(n-1,k-1,t)dt
\end{aligned}
$$

这回可以递推了。设

$$P(n,k,l)=\int_0^{+\infty} \frac{1}{(lx+1)^{(n+1)}}f(n,k,x)dx$$

则有

$$
P(n,k,l)=\frac{n-1}{n}(P(n-1,k-1,l)-P(n-1,k-1,l+1)+P(n-1,k,l+1))
$$

递推边界通过 $P$ 和 $f$ 的定义可以计算：

$$
P(n,k,l) = 
\begin{cases}
0, & k=0; \\
\int_0^{+\infty} (lx+1)^{-n-1}dx=\frac{1}{ln}, & k=n+1;\\
\int_0^1 (lx+1)^{-2}dx=\frac{1}{l+1}, & n=1;\\
\end{cases}
$$

这里为什么 $n=1$ 时积到 $1$ 而 $k=n+1$ 时要积到 ${+\infty}$ 呢，因为 $x>1$ 时 $f(1,1,x)=0$，但是 $k=n+1$ 时 $f(n,k,x)$ 表示的是至少 $0$ 个红包大于 $x$ 的概率，那么无论 $x$ 为何值 $f(n,k,x)$ 的值都为 $1$

最终答案就是 $P(n,k,0)$。

那么这玩意怎么化简呢

首先我们看着 $\frac{n-1}{n}$ 这个因子很难受，不妨修改一下 $P$ 的定义，用 $P(n,k,l)$ 表示之前 $nP(n,k,l)$ 表示的意思，那么递推式和边界都要修改，顺便还能把递推式改为等价的更简洁的形式

$$
P(n,k,l) = 
\begin{cases}
0, & n=0,k\le0; \\
\frac{1}{l}, & n=0,k>0;\\
P(n-1,k-1,l)-P(n-1,k-1,l+1)+P(n-1,k,l+1), & n>0
\end{cases}
$$

此时 $ans(n,k)=\frac{1}{n}P(n,k,0)$。

假设从 $P(n,k,0)$ 递归到 $n=0$ 共调用了 $a$ 次 $P(n-1,k-1,l)$ 分支，$b$ 次 $P(n-1,k-1,l+1)$ 分支，$c$ 次 $P(n-1,k,l+1)$ 分支。需要满足 $a+b+c=n$，$a+b<k$。那么这部分的贡献就是 $\frac{n!(-1)^b}{a!b!c!(b+c)}$，总和为

$$
P(n,k,0)=\sum_{a+b+c=n,a+b<k} \frac{n!(-1)^b}{a!b!c!(b+c)}
$$

继续化简

$$
\begin{aligned}
P(n,k,0)=&\sum_{a+b+c=n,a+b<k} \frac{n!(-1)^b}{a!b!c!(b+c)}\\
=&\sum_{a=0}^{k-1} \frac{n!}{a!(n-a)}\sum_{b=0}^{k-a-1} (-1)^b\frac{1}{b!(n-a-b)!}\\
=&\sum_{a=0}^{k-1} \frac{n!}{a!(n-a)!(n-a)}(-1)^{k-a-1}C(n-a-1,k-a-1)\\
=&\frac{n!}{(n-k)!}\sum_{a=0}^{k-1} \frac{(-1)^{k-a-1}}{(n-a)^2a!(k-a-1)!}\\
=&\frac{n!}{(n-k)!}\frac{1}{(k-1)!}\sum_{a=0}^{k-1} (-1)^{k-a-1}C(k-1,a)(a-n)^{-2}\\
=&\frac{n!}{(n-k)!}\frac{1}{(k-1)!}\sum_{a=0}^{k-1} (-1)^{k-a-1}C(k-1,a)\sum_{j=0}^{\infty}C(-2,j)a^j(-n)^{-2-j}\\
=&\frac{n!}{(n-k)!}\sum_{j=0}^{\infty}C(-2,j)(-n)^{-2-j}\frac{1}{(k-1)!}\sum_{a=0}^{k-1} (-1)^{k-a-1}C(k-1,a)a^j\\
=&\frac{n!}{(n-k)!}\sum_{j=0}^{\infty}(j+1)n^{-2-j}S_2(j,k-1)
\end{aligned}
$$

记 $G_m(x)$ 是第二类斯特林数第 $m$ 列的普通生成函数，$G_m'(x)$ 为其导数。我们有：

$$G_m(x)=\sum_{i=0}^\infty S_2(i,m)x^i=\prod_{j=1}^m\frac{x}{1-jx}$$

$$G_m'(x)=\sum_{j=1}^m\frac{1}{x(1-jx)}G_m(x)$$

原式可以写成生成函数的形式：

$$
\begin{aligned}
P(n,k,0)=&\frac{n!}{(n-k)!}\sum_{j=0}^{\infty}(j+1)n^{-2-j}S_2(j,k-1)\\
=&\frac{n!}{(n-k)!} (n^{-3}G_{k-1}'(\frac{1}{n})+n^{-2}G_{k-1}(\frac{1}{n}))\\
=&\frac{n!}{(n-k)!} n^{-2} (1+\sum_{j=1}^{k-1}\frac{n}{n-j})G_{k-1}(\frac{1}{n})\\
=&\frac{n!}{(n-k)!} n^{-1} (\sum_{l=n-k+1}^{n}\frac{1}{l})\prod_{j=1}^{k-1}\frac{1}{n-j}\\
=&\sum_{l=n-k+1}^{n}\frac{1}{l}
\end{aligned}
$$

这回可以快速计算多组询问了。别忘了除以 $n$！！

$$ans(n,k)=\frac1n\sum_{l=n-k+1}^n\frac1l$$

**提醒：比赛时遇到这种题果断打表找规律。**

---

## 作者：WYXkk (赞：32)

很显然，这是一道结论题，但是根据样例我们很难看出结论。

所以，当然是 **暴 力 找 规 律** 了！

首先，实随机很难做到，我们就把它换成 $1\sim N$ 的整随机除以 $N$。

然后，由于随机数 `rand()` 并不十分均匀，所以我们应该枚举所有状态求平均。

于是就可以打出下面这个 $O(N^{n-1}n\log n)$ 的 dfs：
```cpp
#include<cstdio>
#include<iostream>
#include<fstream>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
#define Set(a) memset(a,0,sizeof(a))
#define F(i,a,b) for(register int i=a,i##end=b;i<=i##end;++i)
#define UF(i,a,b) for(register int i=a,i##end=b;i>=i##end;--i)
#define openf(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
#define re register
#define ri re int
#define il inline
typedef long long ll;
typedef unsigned long long ull;
template<typename T> inline T rd(T& x)
{
	T f=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(T)(c-'0');
	x*=f;
	return x;
}
ll rd(){ll x;rd(x);return x;}
inline int max(int a,int b){return a>b?a:b;}
inline int min(int a,int b){return a<b?a:b;}
const int inf=1<<30;

ll a[201],b[201],ans[201];
int N,n;
void dfs(int x)
{
	if(x==n)
	{
		F(i,0,n) b[i]=a[i];
		sort(b,b+n+1);
		UF(i,n,1) b[i]-=b[i-1];
		sort(b,b+n+1);
		F(i,1,n) ans[i]+=b[n-i+1];
		return;
	}
	F(i,1,N) {a[x]=i;dfs(x+1);}
}
int main()
{
	//N:range of money
	//n:people
	cin>>N>>n;
	a[0]=0,a[n]=N;
	dfs(1);
	long double s=pow(N,n);
	F(i,1,n) printf("Ave of rank %d:%.10Lf\n",i,(long double)ans[i]/s);
	return 0;
}
```
注意一下，理论上 $N$ 越大，结果越精确，当然跑得也更慢。

嗯，然后我们来观察输出。

由于样例已经有了 $n\le2$ 的，这里从 $n=3$ 开始。

$n=3,N=2000$：$0.1111110277$，$0.2777778195$，$0.6111111528$

很显然这三个数分别是 $\dfrac 19$，$\dfrac5{18}$，$\dfrac{11}{18}$。

$n=4,N=200$：$0.0624843750$，$0.1458385425$，$0.2708385400$，$0.5208385425$

似乎看不出来。。。那么先跳过，看 $n=5$。

$n=5,N=100$：$0.0399000480$，$0.0900249180$，$0.1566917010$，$0.2566916670$，$0.4566916660$

嗯，这五个数应该分别是 $\dfrac1{25}$，$\dfrac9{100}$，$\dfrac{47}{300}$，$\dfrac{77}{300}$，$\dfrac{137}{300}$（把出现了连续的直接想象为循环）。

然后我们分别对上面两组数差分一下，就能得到：

$\dfrac19$，$\dfrac16$，$\dfrac13$；

$\dfrac1{25}$，$\dfrac1{20}$，$\dfrac1{15}$，$\dfrac1{10}$，$\dfrac15$。

规律就非常明显了：$Ans_{n,k}-Ans_{n,k-1}=\dfrac1{n(n-k+1)}$。

那么，$Ans_{n,k}=\dfrac1n\times(\dfrac1{n-k+1}+\dfrac1{n-k+2}+\cdots+\dfrac1n)$。

这个时候，再看看 $n=4$ 的那组数据，你会发现它也比较吻合这个规律。

于是 $O(n)$ 预处理逆元，前缀和一遍，然后就能 $O(1)$ 回答每个询问了。

虽然代码非常板子还是贴一遍。
```cpp
#include<cstdio>
#include<iostream>
#include<fstream>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
#define Set(a) memset(a,0,sizeof(a))
#define F(i,a,b) for(register int i=a,i##end=b;i<=i##end;++i)
#define UF(i,a,b) for(register int i=a,i##end=b;i>=i##end;--i)
#define openf(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
#define re register
#define ri re int
#define il inline
typedef long long ll;
typedef unsigned long long ull;
template<typename T> inline T rd(T& x)
{
	T f=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(T)(c-'0');
	x*=f;
	return x;
}
ll rd(){ll x;rd(x);return x;}
inline int max(int a,int b){return a>b?a:b;}
inline int min(int a,int b){return a<b?a:b;}
const int inf=1<<30;

const ll p=998244353;
const int N=10000005;
ll niv[N];
ll mod(ll x){return x<0?x+p:x;}
ll sum(int l,int r){return mod(niv[r]-niv[l-1]);}
int main()
{
	niv[1]=1;
	F(i,2,N-5) niv[i]=p-(p/i)*niv[p%i]%p;
	F(i,2,N-5) niv[i]=(niv[i-1]+niv[i])%p;
	int T=rd();ll ans=0;
	while(T--){int n,k;rd(n);rd(k);ans^=sum(n,n)*sum(n-k+1,n)%p;}
	printf("%lld\n",ans);
	return 0;
}
```
最后，说句闲话：

**找 规 律 t x d y！！！**

---

## 作者：关怀他人 (赞：12)

这题用到了跟 [AGC 032F](https://www.luogu.com.cn/problem/AT4521) 一样的结论。

首先，原问题等价于在$[0,1)$上随机取$n-1$个点，将线段分成了$n$段，求**长度第$k$小的线段的期望长度**。

先考虑$k=1$的情况，即求最短的线段的期望长度。设最短的一段长度为$x$，那么剩下的$n-1$段的长度都要大于等于$x$，考虑先将每条线段的长度减去$x$，于是就变成了在剩下的长度为$1-nx$的线段上随机取$n-1$个点，那么就有
$$
P(L_{min}\geq x)=(1-nx)^{n-1}
$$
于是
$$
\begin{aligned}
E(L_{min})&=\int_0^{\frac{1}{n}}P(L_{min}\geq x)dx\\
&=\int_0^{\frac{1}{n}}(1-nx)^{n-1}dx\\
&=-\frac{1}{n}\int_0^{\frac{1}{n}}(1-nx)^{n-1}d(1-nx)\\
&=-\frac{1}{n^2}(1-nx)^n\Big\lvert_0^{\frac{1}{n}}\\
&=\frac{1}{n^2}
\end{aligned}
$$
接着考虑$k=2$的情况，根据期望的线性性，这相当于求**将每条线段的长度都减去$x$之后将剩下长为$1-nx$的线段分成$n-1$段**，其中最短的一段的期望，再加上$x$即为次短的期望长度，即
$$
E(L_2)=\frac{1-nE(L_{min})}{(n-1)^2}+E(L_{min})=\frac{1}{n}(\frac{1}{n}+\frac{1}{n-1})
$$
同理不难得出当$k=3$时
$$
E(L_3)=\frac{1-nE(L_{min})-(n-1)(E(L_2)-E(L_{min}))}{(n-2)^2}+E(L_2)=\frac{1}{n}(\frac{1}{n}+\frac{1}{n-1}+\frac{1}{n-2})
$$
于是可以归纳得出第$k$短的长度的期望为
$$
E(L_k)=\frac{1}{n}(\frac{1}{n}+\frac{1}{n-1}+\cdots +\frac{1}{n-k+1})
$$
最后预处理逆元，做一遍后缀和即可$\mathcal O(1)$回答询问了。

代码太简单就不贴了。


---

## 作者：JohnVictor (赞：7)

我们设要求的答案为 $f(n,k)$。

从第一档部分分开始分析，一共有 $24$ 分满足 $k=1$，那么我们就开始试着推出 $f(n,1)$ 的式子。

先观察样例，看见 $1$ 与 $\dfrac{1}{4}$ 几乎已经可以猜出答案就是 $\dfrac{1}{n^2}$，如果不够自信的话可以交一发或者模拟一下。

接下来就只需要一个证明了，因为可能数是无限的不太好处理，我们用有限逼近无限，也就是**假设钱数只有 $c$ 种情况，$\frac{1}{c},\frac{2}{c},...,\frac{c-1}{c}$**，其中 $c$ 是一个大常数。

假设取到最少钱的人取到了 $\frac{x}{c}$ 块钱，那么由于他取到的是最少的，那么剩下的人取到的钱都比他多，所以可以设剩下的人钱比他多 $b_2,b_3,...,b_n$，那么我们有 $\frac{c-nx}{c}=\sum_{i=2}^nb_i$，这时我们假设的离散性就有用了，所有的 $b_i$ 的分子之和为 $c-nx$，再结合 $c$ 很大，可以说就是 $(c-nx)^{n-1}$。

得出这一事实后，使用积分进行近似或者转下降幂多项式的手段，我们就可以证明出上述的结论了。

得出了 $f(n,1)=\dfrac{1}{n^2}$ 之后，我们继续推式子：

考虑 $f(n,k)$ 的值，如果 $k \ge 2$ 的话，我们可以这么理解第 $k$ 小的期望：

（1）首先，每个人先拿到 $f(n,1)$ 块钱。

（2）然后，假设剩下了 $x$ 块钱，第  $k$ 小的拿到 $xf(n-1,k-1)$ 块钱。

来解释一下上面说的两句话，第一句没啥好说的，第二句的 $n-1$ 是因为拿钱最少的人无需再拿钱，$k-1$ 是因为去掉了最小的之后，第 $k$ 小的成为了第 $k-1$ 小的了。

现在只用计算 $x$ 的值了，由 $x=1-nf(n,1)$ 知 $x=\frac{n-1}{n}$。

那么我们得到这个式子：
$$f(n,k)=\frac{1}{n^2}+\frac{n-1}{n}f(n-1,k-1)(n,k\ge2)$$
使用这个状态转移方程$DP$已经可以通过第二个子任务了，此时如果手动算几项会发现分母变大的很快。

其实，看不出什么的时候，只要对这个数组做差分，就可以轻易得出结论：

$f(n,k)=\frac{1}{n}\sum_{i=n}^{n-k+1}\frac{1}{i}$

由前面的状态转移方程可以归纳证明这个结论，这里就不证明了。

最后口胡一下代码实现，线性预处理出前 $n$ 个数的逆元并计算前缀和就可以 $O(n+T)$ 解决这道题了。

代码几乎就是模板，不贴了。（我没有给即使中等大小的样例；即使是 $n=3$ 也可以看出规律）

最后强调一下，各种情况下不是均匀分布的，不相信可以自行验证。

由于此题被多人AC，我很后悔没有把范围开到$10^{10}$。

/*
番外篇

考场AC的人都是怎么AC的？我问了一下。

神鱼：我按照题意模拟挂机打表，打了5*5，差分看出来了。

JOHNKRAM：我用了一个叫啥的软件暴力积分出最小值和最大值，把分子分母放到OEIS看了看就好了。

攀岩高手：（首A）我知道这个结论。

此时的我，内心是崩溃的。

*/

---

## 作者：ljc1301 (赞：6)

比赛的时候没有找到规律……然后一直在推式子……推式子能力还是不行啊……**所以比赛/考场还是要果断找规律。**（不过这就不教了，我也不擅长。）

这里讲一个可能推的时间长~~一点~~很多的方法。

由于连续的情况比较恶心，先考虑它在 $\frac iN\ (1\leqslant i\leqslant N)$ 上分布的情况，然后让 $N$ 趋向无穷大。

**为了下面方便书写，$k$ 表示第 $k$ 多，计算答案的时候要注意一下。** 然后规定几个用于简写记号（为了避免公式中出现中文）：$f(\geqslant k,\geqslant i)$ 表示当中有 $\geqslant k$ 项 money $\geqslant \frac iN$ 的方案数，$f(=k,\geqslant i)$ 表示当中恰有 $k$ 项 money $\geqslant \frac iN$ 的方案数，$x_k$ 表示第 $k$ 大的 money。

总的方案数有大约（指的是在 $N$ 趋向无穷大时可以当作）为 $\frac{N^{n-1}}{(n-1)!}$（随便插板，然后排序）。

$\begin{aligned}E[x_k]&=\sum_{i=1}^N\frac iNP(x_k=\frac iN)\\&=\frac1N\sum_{i=1}^NP(x_k=\frac iN)\sum_{j=1}^i1\\&=\frac1N\sum_{j=1}^N\sum_{i=j}^NP(x_k=\frac iN)\\&=\frac1N\sum_{j=1}^NP(x_k\geqslant \frac jN)\\&=\frac1N\sum_{j=1}^N\frac{f(\geqslant k,\geqslant j)}{\frac{N^{n-1}}{(n-1)!}}\\&=\frac1{N{\frac{N^{n-1}}{(n-1)!}}}\sum_{i=1}^Nf(\geqslant k,\geqslant i)\\&=\frac{(n-1)!}{N\cdot N^{n-1}}\sum_{i=1}^N\sum_{j=k}^nf(=j,\geqslant i)\end{aligned}$

下面考虑怎么求 $f(=j,\geqslant i)$。

可能会想到 $\dfrac{(N-ij)^{n-1}}{(n-1)!}\dbinom nj[ij\leqslant N]$（注意当 $ij>N$ 时为 $0$），表示先强行减掉 $j$ 个 $\frac iN$，然后选 $j$ 个位置加回去，但这很显然多算了很多 $f(=l,\geqslant i)\ (l>j)$ 的情况，实际上对于 $l>j$，恰好算了 $\binom lj$ 次（考虑这样每种情况多算的时候，$l$ 个 $\geqslant i$ 的位置，随便选 $j$ 个，都是多算的情况）。

所以，

$\begin{aligned}\frac{(N-ij)^{n-1}}{(n-1)!}\binom nj[ij\leqslant N]=\sum_{l=j}^n\binom{l}{j}f(=l,\geqslant i)\end{aligned}$

需要容斥。我们记$\frac{(N-ij)^{n-1}}{(n-1)!}\binom nj=g_j$，$f(=l,\geqslant i)=f_l$，那么，

$\begin{aligned}g_j=\sum_{l=j}^n\binom{l}{j}f_l\end{aligned}$

要求 $b$，这个式子很类似于二项式反演，又不完全是，但是有类似的结论（我觉得这个结论和二项式反演的关系，和两个莫比乌斯反演的关系很类似），

$\begin{aligned}g_j=\sum_{l=j}^n\binom{l}{j}f_l\Leftrightarrow f_j=\sum_{l=j}^n\binom{l}{j}g_l(-1)^{l-j}\end{aligned}$

证明也同理，

$\begin{aligned}&\sum_{l=j}^n\binom{l}{j}g_l(-1)^{l-j}\\=&\sum_{l=j}^n\binom{l}{j}(-1)^{l-j}\sum_{i=l}^n\binom{i}{l}f_i\\=&\sum_{i=j}^nf_i\sum_{l=j}^i\binom{l}{j}\binom{i}{l}(-1)^{l-j}\\=&\sum_{i=j}^nf_i\sum_{l=j}^i\frac{l!}{j!(l-j)!}\cdot\frac{i!}{l!(i-l)!}\cdot(-1)^{l-j}\\=&\sum_{i=j}^nf_i\sum_{l=j}^i\frac{i!}{j!(i-j)!}\cdot\frac{(i-j)!}{(i-l)!(l-j)!}\cdot(-1)^{l-j}\\=&\sum_{i=j}^nf_i\sum_{l=j}^i\binom ij\binom{i-j}{l-j}(-1)^{l-j}\\=&\sum_{i=j}^nf_i\binom ij\sum_{l=j}^i\binom{i-j}{l-j}(-1)^{l-j}\\=&\sum_{i=j}^nf_i\binom ij\sum_{l=0}^{i-j}\binom{i-j}l(-1)^l\\=&\sum_{i=j}^nf_i\binom ij0^{i-j}=f_j\end{aligned}$

然后我们就知道了，

$\begin{aligned}f(=j,\geqslant i)=f_j&=\sum_{l=j}^n\binom{l}{j}g_l(-1)^{l-j}\\&=\sum_{l=j}^n\binom{l}{j}\frac{(N-il)^{n-1}}{(n-1)!}\binom nl(-1)^{l-j}[il\leqslant N]\end{aligned}$

代回去，

$\begin{aligned}E[x_k]&=\frac{(n-1)!}{N\cdot N^{n-1}}\sum_{i=1}^N\sum_{j=k}^nf(=j,\geqslant i)\\&=\frac{(n-1)!}{N\cdot N^{n-1}}\sum_{i=1}^N\sum_{j=k}^n\sum_{l=j}^n\binom{l}{j}\frac{(N-il)^{n-1}}{(n-1)!}\binom nl(-1)^{l-j}[il\leqslant N]\\&=\sum_{j=k}^n\sum_{l=j}^n\binom{l}{j}\binom nl(-1)^{l-j}\sum_{i=1}^N\frac{(N-il)^{n-1}}{N\cdot N^{n-1}}[il\leqslant N]\\&=\sum_{j=k}^n\sum_{l=j}^n\binom{l}{j}\binom nl(-1)^{l-j}\sum_{i=1}^N\frac1N(1-\frac iNl)^{n-1}[\frac iN\leqslant\frac1l]\\&=\sum_{j=k}^n\sum_{l=j}^n\binom{l}{j}\binom nl(-1)^{l-j}\sum_{i=1}^N\frac1N(1-\frac iNl)^{n-1}[\frac iN\leqslant\frac1l]\\&=\sum_{j=k}^n\sum_{l=j}^n\binom{l}{j}\binom nl(-1)^{l-j}\int_0^{1/l}(1-lx)^{n-1}\operatorname{d}x&(\frac iN\rightarrow x)\\&=\sum_{j=k}^n\sum_{l=j}^n\binom{l}{j}\binom nl(-1)^{l-j}\frac1{-l}\int_1^0(1-lx)^{n-1}\operatorname{d}(1-lx)\\&=\sum_{j=k}^n\sum_{l=j}^n\binom{l}{j}\binom nl(-1)^{l-j}\frac1l\int_0^1t^{n-1}\operatorname{d}t\\&=\sum_{j=k}^n\sum_{l=j}^n\binom{l}{j}\binom nl(-1)^{l-j}\frac1l[\frac1nt^n]^1_0\\&=\frac1n\sum_{j=k}^n\sum_{l=j}^n\frac{(l-1)!}{j!(l-j)!}\binom nl(-1)^{l-j}\\&=\frac1n\sum_{j=k}^n\sum_{l=j}^n\frac1j\binom{l-1}{j-1}\binom nl(-1)^{l-j}\\&=\frac1n\sum_{j=k}^n\frac1j\sum_{l=0}^{n-j}\binom{l+j-1}{j-1}(-1)^l\binom n{l+j}\\&=\frac1n\sum_{j=k}^n\frac1j\sum_{l=0}^{n-j}\binom{l+j-1}{j-1}(-1)^l\binom n{n-j-l}\end{aligned}$

其中，$\sum_{l=0}^{n-j}\binom{l+j-1}{j-1}(-1)^l\binom n{n-j-l}$，可以理解为$\binom{l+j-1}{j-1}(-1)^l$ 的生成函数 $\frac1{(1+x)^j}$，与 $\binom nl$ 的生成函数 $(1+x)^n$ 的乘积 $(1+x)^{n-j}$ 中，$x^{n-j}$ 的系数，显然为 $1$。所以，

$\begin{aligned}E[x_k]&=\frac1n\sum_{j=k}^n\frac1j\sum_{l=0}^{n-j}\binom{l+j-1}{j-1}(-1)^l\binom n{n-j-l}\\&=\frac1n\sum_{j=k}^n\frac1j=\frac1n\left(\sum_{j=1}^n\frac1j-\sum_{j=1}^{k-1}\frac1j\right)\end{aligned}$

这就是答案，预处理逆元和逆元的前缀和后，答案就可以 $\Theta(1)$ 求了。注意，这里 **$k$ 表示第 $k$ 多**，所以要把读入的 $k$ 处理成 $n-k+1$ 再用上面的式子算答案。

代码：
``` cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int kcz=998244353;
const int maxn=10000005;
ll inv[maxn],h[maxn];
int main()
{
    int i,T,n,k,ans=0;
    h[0]=0,h[1]=inv[1]=1;
    for(i=2;i<maxn;i++)
    {
        inv[i]=kcz-(kcz/i)*inv[kcz%i]%kcz;
        h[i]=(h[i-1]+inv[i])%kcz;
    }
    scanf("%d",&T);
    while(T--)
        scanf("%d%d",&n,&k),ans^=inv[n]*(h[n]-h[n-k]+kcz)%kcz;
    printf("%d\n",ans);
    return 0;
}
```

顺面附一个暴力打表的程序，要找打表的时候，可以这样写暴力（不过这应该大家都会？）：
``` cpp
#include <bits/stdc++.h>
using namespace std;
const int n=5;
double ans[n],x[n+1];
int main()
{
    int i,_,T=100000000;
    for(_=0;_<T;_++)
    {
        x[0]=0,x[n]=1;
        for(i=1;i<n;i++) x[i]=(rand()+.5)/RAND_MAX;
        sort(x,x+n);
        for(i=0;i<n;i++) x[i]=x[i+1]-x[i];
        sort(x,x+n);
        for(i=0;i<n;i++) ans[i]+=x[i];
    }
    for(i=0;i<n;i++) printf("%.10lf\n",ans[i]/T);
    return 0;
}
```

---

## 作者：Gorenstein (赞：4)

来个纯计算的做法。这个做法不太用动脑，一路算下去就好了。

首先我们考虑，将长度为 $L$ 的线段分成 $n$ 份后，最短的一条长度大于等于 $x$ 的概率有多大。我们将 $n$ 段分别减去 $x$ 的长度，则最短一段长度固定变为 $0$，余下 $n-1$ 段在 $L-nx$ 中取值，于是概率就是 $(L-nx)^{n-1}/L^{n-1}$。

我们记这个概率为 $P(\geq x):=(L-nx)^{n-1}/L^{n-1}$，并记 $E(L,n,k)$ 表示总长为 $L$，分为 $n$ 段，其中第 $k$ 段的长度的期望。由这个分布函数可得概率密度函数为 $p(x):=-P'(\geq x)=n(n-1)(L-nx)^{n-2}/L^{n-1}$，于是

$$
\begin{aligned}
E(L,n,1)&=\int_0^{L/n}xp(x)\,dx\\
&=\frac{n(n-1)}{L^{n-1}}\int_0^{L/n}x(L-nx)^{n-2}\,dx\\
&=\frac{n(n-1)}{L^{n-1}}\int_L^{0}\frac{L-t}{n}t^{n-2}\,d\frac{L-t}{n}\\
&=\frac{n-1}{nL^{n-1}}\int_0^L(L-t)t^{n-2}\,dt\\
&=\frac{n-1}{nL^{n-1}}\left(\frac{L^n}{n-1}-\frac{L^n}{n}\right)=\frac{L}{n^2}.
\end{aligned}
$$

对于 $k>1$，设最小段长度为 $x$。将所有段都减去 $x$ 的长度，则减去后最小段消失，第 $k$ 小段变为第 $k-1$ 小段，总长变为 $L-nx$。于是可得当最小段长度为 $x$ 时，第 $k$ 小段的期望长度为 $E(L-nx,n-1,k-1)+x$。从而有递推关系

$$
E(L,n,k)=\int_0^{L/n}p(x)(E(L-nx,n-1,k-1)+x)\,dx.
$$

目前我们还不能方便地解出这个递推。但是，直观地来看，应该有 $E(L,n,k)=L\cdot E(1,n,k)$，因为我们可以将每条线段都以 $L$ 倍伸缩。下面我们来严格证明这一点。

**引理** $\quad\ E(L,n,k)=L\cdot E(1,n,k)$。

**证明** $\quad$ 归纳，假设命题对 $k-1$ 成立，则

$$
\begin{aligned}
E(L,n,k)&=\int_0^{L/n}\frac{n(n-1)}{L^{n-1}}(L-nx)^{n-2}(E(L-nx,n-1,k-1)+x)\,dx\\
&=L\int_0^{1/n}\frac{n(n-1)}{L^{n-1}}(L-nLt)^{n-2}(E(L-nLt,n-1,k-1)+Lt)\,dt\\
&=L\int_0^{1/n}n(n-1)(1-nt)^{n-2}(E(1-nt,n-1,k-1)+t)\,dt\\
&=L\cdot E(1,n,k).
\end{aligned}
$$

而命题在 $k=1$ 时显然成立。于是命题对所有 $k\in\mathbb N$ 成立。$\square$

有了这点，这个积分递推式就变得更容易解出了。具体地

$$
\begin{aligned}
E(L,n,k)&=\int_0^{L/n}p(x)(E(L-nx,n-1,k-1)+x)\,dx\\
&=\frac{n(n-1)}{L^{n-1}}\int_0^{L/n}(L-nx)^{n-2}(E(L-nx,n-1,k-1)+x)\,dx.
\end{aligned}
$$

我们将这个积分拆成两部分算。首先计算第一部分，它是

$$
\begin{aligned}
\int_0^{L/n}(L-nx)^{n-2}&E(L-nx,n-1,k-1)\,dx\\
&=\int_0^{L/n}(L-nx)^{n-1}E(1,n-1,k-1)\,dx\\
&=E(1,n-1,k-1)\int_L^0 t^{n-1}\,d\frac{L-t}{n}\\
&=\frac{E(1,n-1,k-1)}{n}\int_0^Lt^{n-1}\,dt=\frac{L^n}{n^2}E(1,n-1,k-1).
\end{aligned}
$$

第二部分则是

$$
\begin{aligned}
\int_0^{L/n}x(L-nx)^{n-2}\,dx=\frac{1}{n^2}\int_0^L(L-t)t^{n-2}\,dt=\frac{L^n}{n^3(n-1)}.
\end{aligned}
$$

因此我们得到

$$
\begin{aligned}
E(L,n,k)&=\frac{n(n-1)}{L^{n-1}}\left(\frac{L^n}{n^2}E(1,n-1,k-1)+\frac{L^n}{n^3(n-1)}\right)\\
&=\frac{n-1}{n}E(L,n-1,k-1)+\frac{L}{n^2}.
\end{aligned}
$$

解这个递推式，得到

$$
\begin{aligned}
E(L,n,k)&=\frac{n-k+1}{n}E(L,n-k+1,1)+\frac{L}{n^2}+L\sum_{j=n-k+1}^{n-2}\frac{j+1}{n}\frac{1}{(j+1)^2}\\
&=\frac{L}{n(n-k+1)}+\frac{L}{n}\sum_{j=n-k+1}^{n-1}\frac{1}{j+1}\\
&=\frac{L}{n}(H_n-H_{n-k}).
\end{aligned}
$$

取 $L=1$ 即为本题结果。

---

## 作者：do_while_true (赞：4)

在 $[0,1]$ 上随机撒 $(n-1)$ 个点划分成 $n$ 段，求第 $k$ 大的段长的期望。

从 Appleblue17 老师的题解中学的，大概详细写很多一笔带过但是我不认为很简单的步骤。

### Part 1

令随机变量 $X$ 为第 $k$ 大的段长。$E(X)=\int_0^1P(X=x)x\text dx=\int_0^1P(X\geq x)\text dx=1-\int_0^1P(X<x)\text dx$，现在来计算 $P(X<x)$．

第 $k$ 大 $<x$ 当且仅当**恰好**有 $t$ 个 $\geq x$ 其中 $t<k$．

运用二项式反演，令 $f_t$ 表示**恰好** $t$ 个 $\geq x$ 的概率，$g_t$ 表示**钦定** $t$ 个 $\geq x$ 的概率，那么有：

$$
g_t=\sum_{i=t}^n\binom{i}{t}f_t
\\
f_t=\sum_{i=t}^n(-1)^{i-t}\binom{i}{t}g_t
$$

而 $P(X<x)$ 就是 $\sum_{t=0}^{k-1}f_t$．

### Part 2

考虑计算 $g_t$，首先乘上组合数 $\binom{n}{t}$ 选出钦定的段，使得“钦定的段”与“未钦定的段”之间没有顺序区分，这样就能将钦定段按顺序放到最前面。

通过用 $\binom{n}{t}$ 去除掉“钦定的段”与“未钦定的段”之间的顺序，我们来构建《$[0,1]$ 随机放点，前 $t$ 个段段长 $\geq x$》与《$[0,1]$ 随机放点，所有点均落在 $[tx,1]$ 中》这两个问题的双射。

前者映射到后者：将前 $t$ 段每段劈成长为 $x$ 和长为 $len-x$ 的两部分，再把长为 $len-x$ 的部分移动到这 $t$ 个长为 $x$ 段的右侧。这样就是最前面有 $t$ 个长为 $x$ 的段，然后剩下 $(1-tx)$ 的长度分了 $n$ 段。

后者映射到前者：将 $[tx,1]$ 被劈开的 $n$ 部分中的前 $t$ 部分分配给前面那 $t$ 个 $x$．

通过这个双射，得到 $g_t=(1-tx)^{n-1}$．

注：我不知道有没有更好的处理方式，我能想到的比较严谨的证明就是这个。

### Part 3

组合上的手法到此结束了，现在就能列出答案进行推式子了。答案是：

$$
\begin{aligned}
&1-\int_0^1 P(X<x)\text dx
\\
=&1-\int_0^1 \sum_{t=0}^{k-1}\sum_{i=t}^n[ix\leq 1](-1)^{i-t}\binom{i}{t}\binom{n}{i}(1-ix)^{n-1}\text dx
\end{aligned}
$$

想通过交换求和号与积分号通过将积分的上界改写成 $\frac{1}{i}$ 来去掉 $[ix\leq 1]$ 的限制，将 $t=i=0$ 的那一项单独拿出来就能往下写了。

$$
\begin{aligned}
=&1-\int_0^1 \sum_{t=0}^{k-1}\sum_{i=t}^n[i>0](-1)^{i-t}\binom{i}{t}\binom{n}{i}(1-ix)^{n-1}-1
\\
=&-\sum_{t=0}^{k-1}\sum_{i=t}^n[i>0](-1)^{i-t}\binom{i}{t}\binom{n}{i}{\color{Red}\int_0^1(1-ix)^{n-1}\text dx}
\\
=&-{\color{Red}\frac{1}{n}}\sum_{t=0}^{k-1}\sum_{i=t}^n[i>0](-1)^{i-t}\binom{i}{t}\binom{n}{i}{\color{Red}\frac{1}{i}}
\end{aligned}
$$

最后一步需要求 $(1-ix)^{n-1}$ 的不定积分：

$$
\begin{aligned}
&\int(1-ix)^{n-1}\text dx
\\
=&\int(1-ix)^{n-1}(-i)\text dx/(-i)
\\
=&\int (1-ix)^{n-1}\text d(1-ix)/(-i)
\\
=&\frac{(1-ix)^n}{-in}
\end{aligned}
$$

这个就是第一换元积分法，$(1-ix)^{n-1}=u^{n-1}$ 换元，利用 $\frac{\text du}{\text dx}=u'\Rightarrow u'\text dx=\text du$，把 $\text du$ 凑出来，这样就转化成了求 $\int u^{n-1}\text du$．

### Part 4

然后将 $t=0$ 这一项单独拿出来看，先不去管 $-\frac{1}{n}$：

$$
\sum_{i=1}^n(-1)^i\binom{n}{i}\frac{1}{i}
$$

两种解法。

第一种解法的思路大概是这个形式看上去就很想去吸收，但是不能直接用吸收恒等式，那么就沿用吸收恒等式的思路去想办法把 $\frac{1}{i}$ 凑到某个阶乘里面形成另一个组合数，从而想到去运用上指标求和：

$$
\begin{aligned}
=&\sum_{i=1}^n(-1)^i\sum_{j=0}^{n-1}\binom{j}{i-1}\frac{1}{i}
\\
=&\sum_{i=1}^n(-1)^i\sum_{j=0}^{n-1}\binom{j+1}{i}\frac{1}{j+1}
\\
=&\sum_{j=0}^{n-1}\frac{1}{j+1}\sum_{i=1}^{j+1}(-1)^i\binom{j+1}{i}
\\
=&-\sum_{j=1}^{n}\frac{1}{j}
\end{aligned}
$$

最后一步是将后面的求和号写成 $(1-1)^{j+1}-1$．

第二种解法的思路是去凑二项式定理的形式，那就需要把 $\frac{1}{i}$ 这里的 $i$ 放到指数上，把它写成一个定积分 $\frac{1}{i}=\int_0^1 t^{i-1}\text dt$

$$
\begin{aligned}
=&\sum_{i=0}^n(-1)^i\binom{n}{i}\int_0^1 t^{i-1}\text dt
\\
=&\int_0^1\text dt\frac{1}{t}\sum_{i=0}^n(-1)^i\binom{n}{i} t^i
\\
=&\int_0^1\text dt\frac{(1-t)^n}{t}
\\
=&\int_0^1\text dt\frac{(1-t)^n}{1-(1-t)}
\\
=&\int_0^1\text dt\sum_{i=0}^{n-1}(1-t)^i
\\
=&\sum_{i=0}^{n-1}\int_0^1\text dt(1-t)^i
\\
=&-\sum_{i=1}^{n}\frac{1}{i}
\end{aligned}
$$

第三行到第四行是去凑等比数列求和，然后再对等比数列每一项积分。最后一步省略的就是前面说的第一类换元积分法（凑微分）。

所以 $t=0$ 这部分对答案的贡献是 $\frac{1}{n}\sum_{i=1}^n\frac{1}{i}$．

### Part 5

看 $t>0$ 的那些：

$$
\begin{aligned}
=&-\frac{1}{n}\sum_{t=1}^{k-1}\sum_{i=t}^n(-1)^{i-t}\binom{i}{t}\binom{n}{i}\frac{1}{i}
\\
=&-\frac{1}{n}\sum_{t=1}^{k-1}\sum_{i=t}^n(-1)^{i-t}\frac{1}{t}\binom{i-1}{t-1}\binom{n}{i}
\\
=&-\frac{1}{n}\sum_{t=1}^{k-1}\frac{1}{t}\sum_{i=0}^{n-t}(-1)^i\binom{i+t-1}{t-1}\binom{n}{i+t}
\end{aligned}
$$

发现 $(-1)^i\binom{i+t-1}{t-1}$ 形式太好看了，它就是 $[x^i]\frac{1}{(1+x)^t}$（广义二项式定理之后上指标反转），那就把两个组合数都去写成生成函数的某一项系数：

$$
\begin{aligned}
=&-\frac{1}{n}\sum_{t=1}^{k-1}\frac{1}{t}\sum_{i=0}^{n-t}\left([x^i]\frac{1}{(1+x)^t}\right)\left([x^{n-i-t}](1+x)^{n}\right)
\end{aligned}
$$

这正是个卷积的形式，那么：

$$
\begin{aligned}
=&-\frac{1}{n}\sum_{t=1}^{k-1}\frac{1}{t}[x^{n-t}](1+x)^{n-t}
\\
=&-\frac{1}{n}\sum_{t=1}^{k-1}\frac{1}{t}
\end{aligned}
$$

加上 $t=0$ 的 $\frac{1}{n}\sum_{i=1}^n\frac{1}{i}$，我们得到了最终的答案：

$$
\frac{1}{n}\sum_{i=k}^{n}\frac{1}{i}
$$

End.

---

## 作者：Purslane (赞：3)

# Solution

马上要考 CMO 了，赶紧写一点推式子的题目防止 MO 退化 /qd

这是一种更加友好的推导方式，但是需要你……有一点观察能力？

首先，令 $k \leftarrow n-k+1$，也就是第 $k$ 大的期望值。

考虑下面的容斥。钦定了 $j$ 个 $\ge x$ 的数（$j \ge k$，$x \le \dfrac{1}{j}$），其概率为 $\dbinom{n}{j}(1-jx)^{n-1}$。通过手算得此时的容斥系数为 $(-1)^{j-k} \dbinom{j-1}{k-1}$，那么答案是：

$$
\begin{aligned}
& \sum_{j=k}^n (-1)^{k-j} \dbinom{j-1}{k-1} \dbinom{n}{j} \int_0^{\frac{1}{j}} (jx)^{n-1} \\
=& \sum_{j=k}^n (-1)^{k-j} \dbinom{j-1}{k-1} \dbinom{n}{j} \dfrac{1}{nj} \\
=& \dfrac{1}{n} \sum_{j=k}^n (-1)^{k-j} \dbinom{j-1}{k-1} \dbinom{n}{j} \dfrac{1}{j}
\end{aligned}
$$

到此为止都是相当简单且自然的。

记这个式子的 $n$ 倍为 $S(n,k)$。考虑让 $n$ 增加 $1$。首先

$$
\dbinom{n+1}{j} = \dbinom{n}{j} + \dbinom{n}{j-1} = \dbinom{n}{j} + \dfrac{j}{n+1} \dbinom{n+1}{j}
$$

带入 $S(n+1,k)$ 得到

$$
\begin{aligned}
S(n+1,k) = & \sum_{j=k}^{n+1} (-1)^{k-j} \dbinom{j-1}{k-1} (\dfrac{\binom{n}{j}}{j} + \dfrac{\binom{n+1}{j}}{n+1}) \\
= &S(n,k) + \dfrac{k}{n+1} \sum_{j=k}^{n+1} (-1)^{k-j} \dfrac{\binom{j}{k} \binom{n+1}{j}}{j}
\end{aligned}
$$

我们证明，右边那个求和号。。。实际上是 $\dfrac{1}{k}$。

也就是证明

$$\sum_{j=k}^{n+1} (-1)^{k-j} \dfrac{\binom{j}{k} \binom{n+1}{j-1}}{j} + (-1)^{n+2-k} \dfrac{\binom{n+2}{k}}{n+2}= 0$$

而 

$$\dfrac{\binom{n+1}{j-1}}{j} = \dfrac{\binom{n+2}{j}}{n+2}$$

因此只用证明

$$
\sum_{j=k}^{n+1} (-1)^{k-j} \dbinom{j}{k} \dbinom{n+2}{j} = (-1)^{n+1-k} \dbinom{n+2}{k}
$$

这个应当是显然的，因为他等价于：

$$
\sum_{j=k}^{n+2} (-1)^{k-j} \dbinom{j}{k} \dbinom{n+2}{j} = 0
$$

略加转化得到

$$
\dbinom{n+2}{k} \sum_{j=k}^{n+2} (-1)^{k-j} \dbinom{n+2-k}{j-k} = 0
$$

因此 

$$S(n+1,k) = S(n,k) + \dfrac{1}{n}$$

所以这道题答案就是 

$$
\dfrac{1}{n} \sum_{i=k}^{n} \dfrac{1}{i}
$$

---

## 作者：Spasmodic (赞：3)

我不会推式子 所以我只会找规律

根据题意我们可以轻松写出暴力代码然后打个 $10\times 10$ 的表。以下是表的 generator：
```cpp
#include<bits/stdc++.h>
using namespace std;
mt19937 myrand(time(0));
double rd(){
	return 1.0*myrand()/4294967296.0;
}
double a[11],money[11],ans[11];
int main(){
	for(int n=1;n<=10;n++,cout<<endl){
		memset(ans,0,sizeof(ans));
		for(int T=114514;T;T--){
			a[0]=0,a[n]=1;
			for(int i=1;i<n;i++)a[i]=rd();
			sort(a,a+n+1);
			for(int i=1;i<=n;i++)money[i]=a[i]-a[i-1];
			sort(money+1,money+n+1);
			for(int i=1;i<=n;i++)ans[i]+=money[i];
		}
		for(int i=1;i<=n;i++)cout<<ans[i]/114514.0<<" ";
	}
	return 0;
}
```
得到这样的一张表
```
1
0.249732 0.750268
0.111425 0.277644 0.610931
0.062599 0.145728 0.271113 0.52056
0.0402066 0.0901476 0.156976 0.25665 0.45602
0.0277922 0.0612358 0.102789 0.158333 0.241409 0.408441
0.0204084 0.044183 0.0727099 0.108445 0.155989 0.227573 0.370692
0.0156198 0.0334537 0.054161 0.0791989 0.110404 0.152078 0.215092 0.339993
0.0123615 0.026238 0.0421205 0.0606964 0.0829262 0.110682 0.147759 0.203009 0.314207
0.0100358 0.0211029 0.0336492 0.0478976 0.0645474 0.0845133 0.109541 0.142876 0.192864 0.292973
```
好像无规律（我比较菜），给个差分
```
1
0.250175 0.499651
0.111342 0.166529 0.332916
0.0625208 0.0832603 0.125156 0.249824
0.039984 0.0501855 0.0666391 0.0993826 0.200656
0.0277724 0.0332628 0.0419703 0.0556736 0.0829782 0.166193
0.0203773 0.0237394 0.0284678 0.0357386 0.0477745 0.0716128 0.14308
0.0156486 0.0177906 0.0209697 0.0249918 0.0312919 0.0414965 0.0623532 0.125136
0.0123574 0.0139027 0.0158743 0.0184695 0.0222825 0.027839 0.0369928 0.0556538 0.11057
0.00998587 0.0111162 0.0125189 0.014244 0.0166409 0.0199426 0.0250931 0.0334467 0.0498843 0.100197
```
这个时候已经可以差不多看出来了，但是如果再把相邻两项做除法，规律更加明显
```

2.00033
1.49867 2.00308
1.3308 1.4946 2.00867
1.2549 1.32945 1.49883 2.00103
1.19812 1.24738 1.33929 1.49618 2.00797
1.16965 1.20404 1.24805 1.33804 1.5032 1.99232
1.14222 1.16069 1.20228 1.25706 1.33538 1.4873 2.01152
1.11932 1.14676 1.16145 1.2025 1.24645 1.33124 1.50103 1.99378
1.11149 1.13614 1.13451 1.17047 1.19707 1.24936 1.32817 1.49655 1.99907
```
发现对角线的数差不多是一样的，考虑第一列，~~发挥一下想象力~~发现它就是
$$
2,\frac{3}{2},\frac{4}{3},\frac{5}{4},\frac{6}{5},\frac{7}{6},\frac{8}{7},\frac{9}{8},\frac{10}{9}
$$
即
$$
\frac{ans_{i,j}-ans_{i,j-1}}{ans_{i,j-1}-ans_{i,j-2}}=\frac{i-j+2}{i-j+1}
$$
所以
$$
ans_{n,k}-ans_{n,k-1}=\frac{1}{n(n-k+1)}
$$
所以
$$
ans_{n,k}=\sum_{i=1}^{k}\frac{1}{n(n-i+1)}=\frac{1}{n}\sum_{i=n-k+1}^{n}\frac{1}{i}
$$
预处理逆元及前缀和，复杂度 $O(n+T)$。
```cpp
const ll N=10000005,P=998244353;
ll T,n,k,inv[N],ans[N],Ans;
int main(){
	n=1e7;
	inv[0]=inv[1]=1;
	for(ll i=2;i<=n;i++)inv[i]=(P-P/i)*inv[P%i]%P;
	ans[1]=1;
	for(ll i=2;i<=n;i++)ans[i]=(ans[i-1]+inv[i])%P;
	for(IO>>T;T--;){
		IO>>n>>k;
		Ans^=((ans[n]-ans[n-k]+P)%P*inv[n]%P);
	}
	IO<<Ans<<'\n';
	return 0;
}
```

---

## 作者：Pentiment (赞：2)

> 将长度为 $1$ 的线段随机分成 $n$ 段，第 $k$ 短的线段长度期望为：
> $$
> \dfrac 1n\sum_{i=n-k+1}^n\dfrac 1i
> $$

钦定最短的线段长度为 $X$，将所有的线段长度减去 $X$，就变成了在长度为 $1-nX$ 的线段上随机选点，因此有：
$$
P(X)=(1-nX)^{n-1}
$$
然后算期望。
$$
E(X_1)=\int_0^{\frac 1n}P(x)\text{d}x=\int_0^{\frac 1n}(1-nx)^{n-1}\text{d}x
$$
换元，令 $u=1-nx$。
$$
\int(1-nx)^{n-1}\text{d}x=-\dfrac 1n\int u^{n-1}\text{d}u=-\dfrac{u^n}{n(n-1)}=-\dfrac{(1-nx)^n}{n^2}
$$
代入定积分：
$$
E(X_1)=-\dfrac{(1-nx)^n}{n^2}\bigg|_0^\frac{1}{n}=0-(-\dfrac{1}{n^2})=\dfrac{1}{n^2}
$$
对于第 $k$ 短的情况，以 $k=2$ 为例，钦定最短线段长度为 $X$，将所有的线段长度减去 $X$，期望就是长度为 $1-nX$ 的线段上分 $n-1$ 段的最小值的期望，还要加上最短线段的期望，即：
$$
E(X_2)=\dfrac{1-nE(X_1)}{(n-1)^2}+E(X_1)=\dfrac{1-\frac 1n}{(n-1)^2}+\dfrac{1}{n^2}=\dfrac{1}{n(n-1)}+\dfrac{1}{n^2}=\dfrac 1n(\dfrac 1n+\dfrac 1{n-1})
$$
一般地，我们钦定前 $k-1$ 小的长度，即可得出第 $k$ 短的式子：
$$
E(X_k)=\dfrac{1-\sum_{i=1}^{k-1}(n-i+1)E(X_i)}{(n-k+1)^2}+E(X_{k-1})=\dfrac 1n\sum_{i=n-k+1}^n\dfrac 1i
$$
本题是这个结论的模板，预处理逆元和后缀和即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 10000005, p = 998244353;
int T, n, k, inv[N], sum[N], ans;
int main() {
	inv[1] = 1;
	for (int i = 2; i <= 1e7; i++) inv[i] = (ll)(p - p / i) * inv[p % i] % p;
	for (int i = 1e7; i >= 1; i--) sum[i] = (sum[i + 1] + inv[i]) % p;
	scanf("%d", &T);
	while (T--) {
		scanf("%d%d", &n, &k);
		ans ^= ll(sum[n - k + 1] - sum[n + 1] + p) * inv[n] % p;
	}
	printf("%d", ans);
}
```

---

## 作者：言琢დ (赞：2)

### [洛谷 P6130](https://www.luogu.com.cn/problem/P6130)

给定下列代码：

```cpp
a[0]=0,a[n]=1
for i=1 to n-1 do{
    a[i]=rand()
}
sort(a)
for i=1 to n do{
    b[i]=a[i]-a[i-1]
}
```

其中 `rand()` 函数可以等概率返回 $(0,1)$ 之间的某个实数，`sort()` 函数可以对数组进行升序排序。

一共 $T(\le2\times10^5)$ 组询问，每组询问给定两个参数 $n,k(\le10^7)$，求数组 $\{b_n\}$ 中第 $k$ 小元素的期望。

### 思路分析

不妨设 $n$ 个人时第 $k$ 小红包的期望为 $dp(n,k)$。

先看 $k=1$ 的情况：

设 $\mathbf f(x)$ 表示最小红包价值大于 $x$ 的概率，其中 $x\in\left[0,\dfrac{1}{n}\right]$

由此可知

$$dp(n,1)=\int_0^{1/n} \mathbf{f}(x)\mathrm dx$$

其中对于第 $2\sim n$ 个红包，每个红包大于 $x$ 的概率为：$\dfrac{1-nx}{1}$，则 $n-1$ 个红包全部大于 $x$ 的概率为：

$$\mathbf f(x)=(1-nx)^{n-1}$$

接着利用换元积分法，令 $u=1-nx$，则 $\mathrm du=-n\mathrm dx$

$$\begin{aligned}
\int_0^{1/n}(1-nx)^{n-1}\mathrm dx
&=-\dfrac{1}{n}\int_1^0u^{n-1}\mathrm du\\
&=-\dfrac{1}{n^2}\left[u^n\right]_1^0\\
&=\dfrac{1}{n^2}
\end{aligned}$$

综上：

$$dp(n,1)=\dfrac{1}{n^2}$$

对于 $k>1$ 的情况，不妨假设 $a_1=dp(n,1)$ 即第一个人拿走 $a_1$ 元钱，剩余 $1-a_1$ 元。

对于剩下的 $n-1$ 个人，**分配 $1-a_1$ 元且每人不少于 $a_1$ 元** 等价于 **分配 $1-n\times a_1$ 元且每人不少于 $0$ 元**，这句话的意思是说，可以假装给了第 1 个人 $n\times a_1$ 元（但最后他要把其中的 $n-1$ 份 $a_1$ 平均分到其余 $n-1$ 个人手中），此后剩余的 $n-1$ 个人应该平均分配剩余的 $1-n\times a_1$ 元。

对于剩下的 $n-1$ 个人，**分配 $1-n\times a_1$ 元第 $k$ 小为 $x$ 的概率** 等价于 **分配 $1$ 元第 $k$ 小为 $\dfrac{1-n\times a_1}{x}$ 的概率**，这句话的意思是说，假设将每一个价值为 $x$ 的红包扩大为 $\dfrac{1-n\times a_1}{x}$ 的红包，此时红包的总价值便成为 $1$（与 $dp_{n,k}$ 的设法相对应）

此时 $n$ 个人分配中的第 $k$ 小，便是这 $n-1$ 个人分配中的第 $k-1$ 小（把最小的人排除在外，类似于选择排序法）

据此：

$$dp_{n,k}=a_1+(1-n\times a_1)dp_{n-1,k-1}$$

注：令这里的 $dp_{n-1,k-1}$ 就是上面的 **分配 $1-n\times a_1$ 元第 $k$ 小为 $x$** 中的变量 $x$ 即可理解。

尝试化简：

$$\begin{aligned}
dp_{n,k}&=\dfrac{1}{n^2}+\dfrac{n-1}{n}dp_{n-1,k-1}\\
\end{aligned}$$

综上：

$$dp_{n,k}=\begin{cases}\dfrac{1}{n^2}~~(k=1)\\~\\\dfrac{1}{n^2}+\dfrac{n-1}{n}dp_{n-1,k-1}~~(k>1)\end{cases}$$

但是这个东西还是只能单次 $O(n)$ 呀，怎么做到一次性预处理 $T=2\times10^5$ 组询问呢？

这就需要亿点眼力了……

$$\begin{aligned}
dp_{n,2}&=\dfrac{1}{n^2}+\dfrac{n-1}{n}\times\dfrac{1}{(n-1)^2}\\
&=\dfrac{1}{n^2}+\dfrac{1}{n(n-1)}\\
&=\dfrac{1}{n}\left(\dfrac{1}{n}+\dfrac{1}{n-1}\right)
\end{aligned}$$

$$\begin{aligned}
dp_{n,3}&=\dfrac{1}{n^2}+\dfrac{n-1}{n}\times\left[\dfrac{1}{n-1}\left(\dfrac{1}{n-1}+\dfrac{1}{n-2}\right)\right]\\
&=\dfrac{1}{n}\left(\dfrac{1}{n}+\dfrac{1}{n-1}+\dfrac{1}{n-2}\right)
\end{aligned}$$

其实原理就是因为，每一个 $dp_{n,k}$ 所调用的 $dp_{n-1,k-1}$ 中，分母上总会有一个 $\dfrac{1}{\red{n-1}}$ 的存在，正好与 $\dfrac{\red{n-1}}{n}dp_{n-1,k-1}$ 能够消去。

然后前后正好同时拥有 $\dfrac{1}{n}$ 项系数，同时提取公因数，就得到了最终的 **通项公式**：

$$dp_{n,k}=\dfrac{1}{n}\times\sum_{i=1}^{k}\dfrac{1}{n-i+1}$$

最后这个东西用线性求逆元预处理一下就可以 $O(1)$ 处理每次询问了。

### 参考代码

```cpp
// init() / print() 表示快速读入和快速输出
const int N = (int) 1e7 + 5, Mod = 998244353;
int quick_mod(int x, int y){
	int s = 1;
	while (y) {
		if (y & 1) s = s * x % Mod;
		x = x * x % Mod; y >>= 1;
	}
	return s;
}
int fac[N], facinv[N], sum[N];
int s(int l, int r){
	return (sum[r] - sum[l-1] + Mod) % Mod;
}
signed main(){
	fac[0] = 1;
	for (int i = 1; i < N; ++i)
		fac[i] = fac[i-1] * i % Mod;
	facinv[N - 1] = quick_mod(fac[N - 1], Mod - 2);
	for (int i = N - 2; i >= 0; --i)
		facinv[i] = facinv[i+1] * (i+1) % Mod;
	for (int i = 1; i < N; ++i)
		sum[i] = (sum[i-1] + facinv[i] * fac[i-1] % Mod) % Mod;
	int T = init(), ans = 0;
	while (T--) {
		int n = init(), k = init();
		ans ^= s(n, n) * s(n-k+1, n) % Mod;
	}
	print(ans), putchar('\n');
}
```

---


# [COCI 2016/2017 #1] Mag

## 题目描述

你将获得一棵由无向边连接的树。树上每个节点都有一个魔力值。

我们定义，一条路径的魔力值为路径上所有节点魔力值的乘积除以路径上的节点数。

例如，若一条路径包含两个魔力值分别为 $3,5$ 的节点，则这条路径的魔力值为 $3\times 5/2=7.5$。

请你计算，这棵树上魔力值最小的路径的魔力值。

## 说明/提示

#### 【样例解释】

**样例 1 解释**

注意，路径可以只包含一个节点。

这棵树上魔力值最小的路径的包含节点 $1$，其魔力值为 $3/1$。


**样例 2 解释**

这棵树上魔力值最小的路径的包含节点 $2,4$，其魔力值为 $1\times 1/2=1/2$。

------------

#### 数据规模与约定

对于 $100\%$ 的数据，$1\le n\le 10^6$，$1\le a_i,b_i\le n$，$1\le x_i\le 10^9$。

数据保证，$p,q$ 不会超过 $10^{18}$。

------------

#### 说明

**题目译自 [COCI2016-2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST #1](https://hsin.hr/coci/archive/2016_2017/contest1_tasks.pdf) _T4 Mag_**。

## 样例 #1

### 输入

```
2
1 2
3
4 ```

### 输出

```
3/1 ```

## 样例 #2

### 输入

```
5
1 2
2 4
1 3
5 2
2
1
1
1 
3 ```

### 输出

```
1/2 ```

# 题解

## 作者：Wenoide (赞：5)

# 结论

为方便表述，称一条路径的节点数为其长度。

此题有这样的结论：

- 若不存在魔力值为 $1$ 的节点，则魔力值最小的路径即为魔力值最小的节点。

- 若存在魔力值为 $1$ 的节点，记所有节点的魔力值均为 $1$ 的最长路径的长度为 $l$，则魔力值最小的路径为下面两者之一：

	1. 一条长度为 $l$ 的路径，所有节点的魔力值均为 $1$。
    2. 一条长度为 $2\times l+1$ 的路径，第 $l+1$ 个节点的魔力值为 $2$，其余节点的魔力值均为 $1$。
    
# 证明

下文中的所有内容均在正整数范围内讨论。

记路径 $p$ 的长度为 $l(p)$，魔力值为 $f(p)$，所有节点魔力值的乘积为 $m(p)$。

------------

- 若不存在魔力值为 $1$ 的节点。

	假设路径 $p_1$ 将与路径 $p_2$ 连接为一条新的路径。

	不妨令 $f(p_1)<f(p_2)$。即 $\frac{m(p_1)}{l(p_1)}<\frac{m(p_2)}{l(p_2)}$。变形可得 $\frac{l(p_2)}{l(p_1)}<\frac{m(p_2)}{m(p_1)}$。

	若连接后得到的路径为更优解，则 $\frac{m(p_1)\times m(p_2)}{l(p_1)+l(p_2)}<\frac{m(p_1)}{l(p_1)}$。

	变形得 $m(p_2)-1<\frac{l(p_2)}{l(p_1)}$。

	所以 $m(p_2)-1<\frac{m(p_2)}{m(p_1)}$。

	变形得  $(m(p_1)-1)(m(p_1)-1)<1$。

	由于不存在魔力值为 $1$ 的节点，$m(p_1)-1\ge 1 \bigwedge m(p_2)-1\ge 1$。

	不等式无解。即将两条路径合并后一定无法得到更优解。

	显然，此时魔力值最小的路径即为魔力值最小的节点。即结论的第一部分。

------------

- 若存在魔力值为 $1$ 的节点。

	假设有最长的路径 $p_1$ 使得 $m(p_1)=1$，与任意路径 $p_2$。

	若 $f(p_2)<f(p_1)$，则 $\frac{m(p_2)}{l(p_2)}<\frac{1}{l(p_1)}$。

	变形得 $\frac{l(p_2)}{l(p_1)}>m(p_2)$。
    
	需要注意，假设 $p_2$ 有最长的子路径 $p_t$ 使得 $m(p_t)=1$，其还应满足 $l(p_t)\le l(p_1)$。
    
	设 $m(p_2)$ 的质因数个数为 $k$。用魔力值为这些质因数的 $k$ 个节点连接 $k+1$ 段长度为 $l(p_1)$、魔力值为 $1$ 的路径，即可得到 $l(p_2)\le k+(k+1)\times l(p_1)$。

	由于 $x$ 的质因数个数不大于 $\log_2(x)$。所以 $l(p_2)\le \log_2(m(p_2))+(\log_2(m(p_2))+1)\times l(p_1)$。

	又有 $l(p1)\ge 1$。所以 $2\times \log_2(m(p_2))+1>m(p_2)$。

	这个不等式的正整数解为 $m(p_2)=2,3,4,5,6$。

	经检验，只有当 $m(p_2)=2,4$ 时，关于 $l(p_1)$ 的不等式 $\frac{k+		(k+1)\times l(p_1)}{l(p_1)}>m(p_2)$ 有正整数解。

	1. $m(p_2)=4$。
    
    	此时 $l(p_1)=1$。即路径 $p_2$ 为 `1,2,1,2,1`。
        
        但是，这条路径的魔力值大于路径 `1,2,1`。
        
	2. $m(p_2)=2$。
    
    	不等式恒成立。
        
        即当 $l(p_2)=2\times l(p_1)+1$，路径 $p_2$ 的第 $l(p_1)+1$ 个节点的魔力值为 $2$，其余节点的魔力值均为 $1$ 时，$f(p_2)<f(p_1)$。
        
        若 $l(p_2)$ 不再取最大值 $k+(k+1)\times l(p_1)$，不等式无正整数解。
        
    换言之，当且仅当 $l(p_2)=2\times l(p_1)+1$，第 $l(p_1)+1$ 个节点的魔力值为 $2$，其余节点的魔力值均为 $1$ 时，$f(p_2)<f(p_1)$。即结论的第二部分。

# 实现
 
实际上，我们可以统计所有仅有一个节点的魔力值为 $2$、其余节点魔力值均为 $1$ 的路径，不影响答案。因为若魔力值为 $2$ 的节点不在该路径正中间，则一定存在一条所有节点魔力值均为 $1$ 的子路径，魔力值不小于原路径。

若子路径的魔力值和原路径相等，便可能出现需要约分的情况。我们可以优化统计答案的顺序，使得子路径的魔力值一定先于原路径被统计。

------------
 
- 用 $f(x)$ 表示以 $x$ 为根节点的子树中，以 $x$ 为一端且魔力值为 $1$ 的路径的最大长度。

- 用 $g(x)$ 表示以 $x$ 为根节点的子树中，以 $x$ 为一端且魔力值为 $2$ 的路径的最大长度。

- 节点 $x$ 得出的答案由其自身与两个不同的子节点 $i,j$（可能为空）组成：

	1. 节点 $x$ 的魔力值为 $1$。
    
    	得出的答案为 $1/(\max(f(i)+f(j))+1)$ 与 $2/(\max(f(i)+g(j))+1)$。
        
        $f(x)=\max(f(i))+1,g(x)=\max(g(i))+1$。
    
	2. 节点 $x$ 的魔力值为 $2$。
    	
    	得出的答案为 $2/\max(f(i)+f(j))+1$。
        
        $f(x)=0,g(x)=\max(f(i))+1$。
        
	3. 节点 $x$ 的魔力值大于 $2$。
    	
        无法得出答案。
        
        $f(x)=0,g(x)=0$。

------------
        
参考代码：
```
//注：本人实现代码时参考了 @programme_C 的题解。
#include<cstdio>
const int MAXN=1000000+10;
struct Node{
	int next;
	int to;
}edge[MAXN<<1];
int head[MAXN],cnt;
void add(int u,int v){
	edge[cnt].next=head[u];
	edge[cnt].to=v;
	head[u]=cnt++;
	return;
}
int mag[MAXN];
int f[MAXN],g[MAXN];
int p=1e9,q=1,mn=1e9;
void update(int x,int y){
	if(p*y>q*x){
		p=x,q=y;
	}
	return;
}
//更新答案。化除为乘。
void DP(int cur,int fa){
	int u1=0,u2=0,v1=0,v2=0;
	/*
		u1 表示 cur 的子结点中 f 值最大的节点；
		u2 表示 cur 的子结点中 f 值次大的节点；
		v1 表示 cur 的子结点中 g 值最大的节点；
		v2 表示 cur 的子结点中 g 值次大的节点；
	*/
	for(int i=head[cur];~i;i=edge[i].next){
		int t=edge[i].to;
		if(t!=fa){
			DP(t,cur);
			if(f[t]>f[u1]){
				u2=u1,u1=t;
			}
			else if(f[t]>f[u2]){
				u2=t;
			}
			if(g[t]>g[v1]){
				v2=v1,v1=t;
			}
			else if(g[t]>g[v2]){
				v2=t;
			}
		}
		//更新 u1,u2,v1,v2。
	}
	if(mag[cur]==1){
		f[cur]=f[u1]+1;
		update(1,f[u1]+f[u2]+1);
		//注意顺序。避免出现需要约分的情况。
		if(v1!=0){
			g[cur]=g[v1]+1;
			if(u1!=v1){
				update(2,f[u1]+g[v1]+1);
			}
			//特判 cur 的子结点中 f 值最大的节点与 g 值最大的节点相同的情况。
			else{
				update(2,f[u2]+g[v1]+1);
				if(v2!=0){
					update(2,f[u1]+g[v2]+1);
				}
			}
		}
		//特判 g 值为 0 的情况。此时无法构成符合要求的路径。
		//需要注意，f 值为 0 时仍能构成符合要求的路径。
	}
	else if(mag[cur]==2){
		g[cur]=f[u1]+1;
		update(2,f[u1]+f[u2]+1);
	}
	return;
}
int main(){
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		head[i]=-1;
	}
	for(int i=1;i<n;++i){
		int u,v;
		scanf("%d%d",&u,&v);
		add(u,v);
		add(v,u);
	}
	for(int i=1;i<=n;++i){
		scanf("%d",mag+i);
		if(mag[i]<mn){
			mn=mag[i];
		}
	}
	if(mn>1){
		printf("%d/1",mn);
		return 0;
	}
	//特判无魔力值为 1 的节点的情况。
	DP(1,0);
	printf("%d/%d",p,q);
	return 0;
}
```

---

## 作者：A_Sunny_Day (赞：4)

## COCI2016/2017 #1 D Mag 点分治

​	题目链接：[COCI2016-2017#1](https://www.luogu.com.cn/problem/P6287)

---

## 算法: 点分治

## 证明&结论：

​	首先这题关于选出来的路径有一个结论：

+ 路径上点权全为 $1$。
+ 路径长度为 $2\times l+1$，有且只有一个权值为 $2$ 的点在 $l+1$ 这个位置，其他点权都为 $1$。
+ 如果没有点权为 $1$ 的点，那么答案就是最小的权值。

​    首先声明一点，据题意可知，题目中出现的**数据都是正整数**，所以以下推导中出现的**变量**均为**正整数**。

​	我们假设一个点权为 $x$ 的点连接了两条魔力值分别为 $\dfrac{a}{b},\dfrac{c}{d}$ 的路径。那么连接完后路径的魔力值就为 $\dfrac{a\times c\times x}{b+d+1}$。我们将这个魔力值与 $\dfrac{a}{b}$ 相比，如果 $\dfrac{a\times c\times x}{b+d+1}\le\dfrac{a}{b}$ 的话，就有 $d+1+b\ge c\times x\times b$ 否则肯定直接选 $\dfrac{a}{b}$ 更优。

​	再与 $\dfrac{c}{d}$ 比较，得出相似的一条式子 $d+1+b\ge a\times x\times d$。两式左右分别相加，得到 $2\ge (c\times x-2)\times b+(a\times x-2)\times d$ 。又因为 $b,d\ge 1$ 所以 $c\times x,a\times x\le 3$。

​	但是注意到， $c\times x,a\times x$ 能取到 $3$ 是因为原不等式带等号，取 $3$ 的时候可能会使这个不等式满足等于号而成立。但是我们选答案的范围是**整张**图，如果取等号的话，为什么不直接取魔力值为 $\dfrac{a}{b}$  或者 $\dfrac{c}{d}$ 作为答案呢？

​	所以我们尝试把不等式的等号去掉就得到 $c\times x,a\times x\le2$ 。由于 $a,c,x$ 均为正整数，那么 $a,c,x$ 只能为 $1,2$。接下来分类讨论

+ $x=2$ 的情况。

  那么 $a,c$ 都只能为 $1$。那么就有 $\dfrac{1}{b},\dfrac{1}{d},\dfrac{2}{b+d+1}$ 这 $3$ 种情况。如果拼起来更优的$\dfrac{2}{b+d+1}<\dfrac{2}{2\times b}$ 且 $\dfrac{2}{b+d+1}<\dfrac{2}{2\times d}$。所以当且仅当 $b=d$ 时，拼起来会更优，也就是 $x$ 这个点连接了两条长度一样，点权全为 $1$ 的链。这对标我们的结论 $2$。

+ $x=1$ 的情况。

  首先如果 $a,c$ 都为 $1$。那么拼起来是更优的，对标结论 $1$。如果 $a,c$ 之中有一个是 $2$ 。就说明拼起来的路径中只有一个点权是 $2$。根据我们刚刚推导的情况，一条路径上只有一个点权为 $2$ 时。当且仅当这个点**处于路径中心时**拼接起来更优（即结论 $2$）。

  最后一种情况：$a,c$ 都为 $2$。也就是这条链上有 $2$ 个权值为 $2$ 的点的情况。 那么我们设这两个权值为 $2$ 的点将总长度为 $b+d+1$ 的路径划分成了 $3$ 条只包含点权为 $1$ 的点的链，它们的长度分别为 $u,v,p$。那么可能的最小的权值情况就为 $\dfrac{1}{\max(u,v,p)},\dfrac{4}{b+d+1},\dfrac{2}{u+v+1},\dfrac{2}{v+p+1}$。直接对比 $\dfrac{1}{max(u,v,p)},\dfrac{4}{u+v+p+2}$。 得 $4\times\max(u,v,p)<u+v+p+2$，当且仅当 $u,v,p$ 全为 $1$ 时成立。那么这 $4$ 个可能的值就全是具体的了。分别是 $\dfrac{1}{1},\dfrac{4}{5},\dfrac{2}{3},\dfrac{2}{3}$ ，显然 $\dfrac{2}{3}<\dfrac{4}{5}$，所以拼接起来一定不是最优的。（可以结合下图理解）

  ![](https://cdn.luogu.com.cn/upload/image_hosting/raqo1smh.png)

​    综上所述，我们在文章一开始提出的三个结论成立。

---

## 解题：

​	知道了结论，我们就可以根据结论进行求解了，那么我们要找的就是两种链。第一种是点权全是 $1$ 的。第二种是权值为 $2$ 的点在链中心的。

​	找链的工作可以使用树形 dp 来求解。关于树形 dp 的写法网上已经有很多题解了。这里介绍一种点分治的写法。

​	首先是关于全是 $1$ 的链的求解，那么我们寻找路径是就只要遍历点权为 $1$ 的点。然后维护路径最大值与次大值（注意最大值与次大值不能在**同一子树内**）。局部代码如下：

```cpp
void Get_dis(int p,int fa,int d)
{
	if(val[p]!=1) return ;//点权不是1不用记录到数组内
	arr[++cnt]=d;
	for(int i=0;i<e[p].size();++i)
	{
		int to=e[p][i];
		if(to==fa||vis[to]) continue;
		Get_dis(to,p,d+1);
	}
}
void solve(int p)
{
	int mx[2]={},tmp=0,id[2];id[0]=id[1]=-1;
	for(int i=0;i<e[p].size();++i)
	{
		int to=e[p][i];
		if(vis[to]) continue;
		cnt=0;Get_dis(to,p,1);tmp=0;
		for(int j=1;j<=cnt;++j)
			tmp=max(tmp,arr[j]);//维护子树最大值
		if(tmp>mx[1])//维护最大值与次大值
			mx[1]=tmp;id[1]=i;
		if(mx[1]>mx[0])
		{
			swap(mx[1],mx[0]);
			swap(id[1],id[0]);
		}
		ans=max(ans,mx[0]+mx[1]+1);//用不在同一子树内的最大值次大值更新答案
	}
}
```

​	同时的，``Get_dis`` 这个函数还可以在获取当前解决的点（当前解决子树的重心）点权为 $2$ 时需要的路径，然后我们维护一下最长的两条相等的路径即可，可以通过以下方式实现。

```cpp
struct Data
{
	int x,y;//x是分子，y是分母
	bool operator <(const Data&a) const
	{
		return x*1.0/y<(a.x*1.0/a.y);
	}
	void print()
	{
		int d=gcd(x,y);
		printf("%d/%d\n",x/d,y/d);
	}
}res;
void solve_(int p)
{
	int mx=0;
	for(int i=0;i<e[p].size();++i)
	{
		int to=e[p][i];
		if(vis[to]) continue;
		cnt=0;Get_dis(to,p,1);
		for(int j=1;j<=cnt;++j)//因为两个链的长度要相等，所以取较小值更新答案。
			res=min(res,(Data){2,min(mx,arr[j])*2+1});
		for(int j=1;j<=cnt;++j)//维护一下已经遍历到的最大值
			mx=max(mx,arr[j]);
	}
}
```

​	但是有一种可能，我们在解决的点点权是 $1$ 但是我们获取的链的长度里面有点权为 $2$ 的点，如下图这种情况，$p$ 是我们目前处理的点（当前处理子树的重心）。

![](https://cdn.luogu.com.cn/upload/image_hosting/ufjtrkse.png)

​	所以我们还得再写一个类似 ``Get_dis`` 的函数用来获取带一个点权为 $2$ 的点的路径。如下：

```cpp
void Get_dis2(int p,int fa,int d,int d2,int c)
{
	if(val[p]!=1&&val[p]!=2) return ;
	if(c>2) return ;
	dis[++all]={d,d2};//这里的dis数组是data类型，但只是为了存储两个值，可以用pair替代。
	for(int i=0;i<e[p].size();++i)
	{
		int to=e[p][i];
		if(to==fa||vis[to]) continue;
		Get_dis2(to,p,c==2?d:d+1,c==2?d2+1:d2,c*val[p]);
	}
}
```

​	至于根据路径求解的代码，由于当前处理的点（处理子树的重心）的点权是 $1$ 我们可以将它与上面的 ``solve``（处理全是 $1$ 的链的函数）合并一下。就变成了下面这个代码：

```cpp
void solve(int p)
{
	int mx[2]={},tmp=0,id[2];id[0]=id[1]=-1;//下面这部分展示过了，可以跳过。
	for(int i=0;i<e[p].size();++i)
	{
		int to=e[p][i];
		if(vis[to]) continue;
		cnt=0;Get_dis(to,p,1);tmp=0;
		for(int j=1;j<=cnt;++j)
			tmp=max(tmp,arr[j]);
		if(tmp>mx[1])
			mx[1]=tmp;id[1]=i;
		if(mx[1]>mx[0])
		{
			swap(mx[1],mx[0]);
			swap(id[1],id[0]);
		}
		ans=max(ans,mx[0]+mx[1]+1);
	}//上面这部分展示过了，可以跳过。
	for(int i=0;i<e[p].size();++i)
	{
		int to=e[p][i];
		if(vis[to]) continue;
		all=0;Get_dis2(to,p,val[to]==1?1:0,0,val[to]);
		for(int j=1;j<=all;++j)
		{
			int d1=dis[j].x,d2=dis[j].y;//一样，由于全为1的链的长度需要相等，取较小值。
			res=min(res,Data{2,min((i==id[0]?mx[1]:mx[0])+1+d1,d2)*2+1});
		}
	}
}
```

​	上述问题到这里就解决了，总时间复杂度为 $O(n\log(n))$。~~加大常数。~~

​	全部代码如下：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN = 1e6+5;
int n,dp[MAXN],siz[MAXN],Tsiz,root,cnt,arr[MAXN],ans,val[MAXN],all;
bool vis[MAXN];
vector <int> e[MAXN];
int gcd(int x,int y)
{
	if(y==0) return x;
	return gcd(y,x%y);
}
void Get_root(int p,int fa)
{
	dp[p]=0;siz[p]=1;
	for(int i=0;i<e[p].size();++i)
	{
		int to=e[p][i];
		if(to==fa||vis[to]) continue;
		Get_root(to,p);
		siz[p]+=siz[to];
		dp[p]=max(siz[to],dp[p]);
	}
	dp[p]=max(dp[p],Tsiz-siz[p]);
	if(dp[p]<dp[root]) root=p;
}
struct Data
{
	int x,y;//x表示分子，y表示分母
	bool operator <(const Data&a) const
	{
		return x*1.0/y<(a.x*1.0/a.y);
	}
	void print()
	{
		int d=gcd(x,y);
		printf("%d/%d\n",x/d,y/d);
	}
}res,dis[MAXN];
void Get_dis(int p,int fa,int d)
{
	if(val[p]!=1) return ;
	arr[++cnt]=d;
	for(int i=0;i<e[p].size();++i)
	{
		int to=e[p][i];
		if(to==fa||vis[to]) continue;
		Get_dis(to,p,d+1);
	}
}
void Get_dis2(int p,int fa,int d,int d2,int c)
{
	if(val[p]!=1&&val[p]!=2) return ;
	if(c>2) return ;
	dis[++all]={d,d2};
	for(int i=0;i<e[p].size();++i)
	{
		int to=e[p][i];
		if(to==fa||vis[to]) continue;
		Get_dis2(to,p,c==2?d:d+1,c==2?d2+1:d2,c*val[p]);
	}
}
void solve(int p)
{
	int mx[2]={},tmp=0,id[2];id[0]=id[1]=-1;
	for(int i=0;i<e[p].size();++i)
	{
		int to=e[p][i];
		if(vis[to]) continue;
		cnt=0;Get_dis(to,p,1);tmp=0;
		for(int j=1;j<=cnt;++j)
			tmp=max(tmp,arr[j]);
		if(tmp>mx[1])
			mx[1]=tmp;id[1]=i;
		if(mx[1]>mx[0])
		{
			swap(mx[1],mx[0]);
			swap(id[1],id[0]);
		}
		ans=max(ans,mx[0]+mx[1]+1);
	}
	for(int i=0;i<e[p].size();++i)
	{
		int to=e[p][i];
		if(vis[to]) continue;
		all=0;Get_dis2(to,p,val[to]==1?1:0,0,val[to]);
		for(int j=1;j<=all;++j)
		{
			int d1=dis[j].x,d2=dis[j].y;
			res=min(res,Data{2,min((i==id[0]?mx[1]:mx[0])+1+d1,d2)*2+1});
		}
	}
}
void solve_(int p)
{
	int mx=0;
	for(int i=0;i<e[p].size();++i)
	{
		int to=e[p][i];
		if(vis[to]) continue;
		cnt=0;Get_dis(to,p,1);
		for(int j=1;j<=cnt;++j)
			res=min(res,(Data){2,min(mx,arr[j])*2+1});	
		for(int j=1;j<=cnt;++j)
			mx=max(mx,arr[j]);
	}
}
void Divide(int p)
{
	vis[p]=1;
	if(val[p]==1) solve(p);
	if(val[p]==2) solve_(p);
	for(int i=0;i<e[p].size();++i)
	{
		int to=e[p][i];
		if(vis[to]) continue;
		Tsiz=siz[to];root=0;
		Get_root(to,p);
		Divide(root);
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<n;++i)
	{
		int u,v;
		scanf("%d %d",&u,&v);
		e[u].push_back(v);
		e[v].push_back(u);
	}
	for(int i=1;i<=n;++i)
		scanf("%d",&val[i]);
	dp[root=0]=n+1;Tsiz=n;ans=-1;res.y=1;res.x=1e9;
	Get_root(1,0);
	Divide(root);
	if(ans!=-1)
	{
		if(Data{1,ans}<res)
			printf("1/%d\n",ans);
		else res.print();			
	}
	else
	{
		if(res.x!=1e9)
		{
			res.print();
		}
		else
		{
			ans=1e9;
			for(int i=1;i<=n;++i)
				ans=min(ans,val[i]);
			printf("%d/1\n",ans);			
		}
	}
	return 0;
}
```

总结：点分治，解决树上路径的一种优秀方法。（虽然在这题并不优秀）

---

## 作者：Wanderer_01 (赞：3)

## 题意：

[P6287](https://www.luogu.com.cn/problem/P6287)

题目很清晰，自己看。~~绝对不是因为我懒。~~

## 思路：

设当前路径 $f1$ 魔力值为 $\frac{p}{q}$，点 $x$ 与相邻。

若要把 $x$ 放进 $f1$ 中时，需满足 $\frac{p}{q}>\frac{p x}{q+1}$。

这可以看出 $x>1$ 时，$x$ 都不因该放入路径中。那么，其实只需判断是否有 $a_i=1$。若有，答案为最长的 $a_i=1$ 链的长度分之一；若没有，答案为最小的 $a_i$ 分之一。

~~难道这道紫题这么简单？~~

显然可以想到 HACK 数据。
```
in:
3
1 2
2 3
1 2 1
```
```
out:
2/3
```

这时中间的 $2$ 放入两个 $1$ 链中是最优的。

考虑中间一点的 $x$ 连接 $f1$ 路径和 $f2$ 路径。

设路径 $f1$ 和 $f2$ 的魔力值分别为 $\frac{p_1}{q_1}$ 和 $\frac{p_2}{q_2}$。

若要让 $x$ 连接 $f1$ 和 $f2$ 时，需满足 $\frac{p_1 p_2 a_x}{q_1+q_2+1}<\min\{\frac{p_1}{q_1},\frac{p_2}{q_2}\}$。

所以 $a_x\le 2$。

$a_x=2$ 时，当且仅当 $p_1=p_2=1$，$q_1=q_2$。

## 得出结论：

若树上没有 $a_i=1$ 有，答案为最小的 $a_i$ 分之一。

若有时，再判断时否有 $a_i=2$ ，若没有，答案为最长的 $a_i=1$ 链的长度分之一；若有，答案还要与 $a_i=2$ 的点所连成的路径的魔力值取最小值。

## 方法：

下文中的 $1$ 链为 $a_i=1$ 的点连成的链。

先枚举只取每一个点的魔力值。

再用树形 dp，加上换根求出以每个 $a_i=1$ 的点为起点的 $1$ 链，并更新魔力值。

若只是求最长的 $1$ 链当然不用换根，但这里需要为合并 $a_i=2$ 连接的两条 $1$ 链做预处理，否则时间复杂度会被卡成 $O(n^2)$。

最后枚举每个 $a_i=2$ 的点，暴力合并其两边的最长和次长 $1$ 链，更新魔力值。

注意：

有 $a_i$ 的情况，在 dp 是可能不止一棵树，而是一个森林。

献上代码，时间复杂度为 $O(n)$，评测总用时 $1.23$ 秒，~~当前最优解~~。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+1;
int n,fm=1e9,fz=1;
int res[N];
int read(){
	char c;
	int x,f=1;
	while(c=getchar(),c<'0'||c>'9')if(c=='-') f=-1;
	x=c-'0';
	while(c=getchar(),c>='0'&&c<='9') x=x*10+c-'0';
	return x*f;
}
struct Edge{
	int to,next;
}e[N<<1];
int head[N],tot;
void add(int x,int y){		//链式前向星
	tot++;
	e[tot].to=y;
	e[tot].next=head[x];
	head[x]=tot;
}
int a[N];
bool check(double x,double y){
	double res1=(double)(1.0*y/x);
	double res2=(double)(1.0*fm/fz);
	return res1<res2;
}
int d1[N],d2[N],g[N];
void dfs1(int x,int fa){
	for(int y=head[x]; y; y=e[y].next){
		if(e[y].to==fa||a[e[y].to]>1) continue;
		dfs1(e[y].to,x);
		int temp=d1[e[y].to]+1;
		if(d1[x]<temp){
			d2[x]=d1[x];
			d1[x]=temp;
		}else if(d2[x]<temp) d2[x]=temp;
	}
	if(!d1[x]) d1[x]=1;
}
void dfs2(int x,int fa){
	if(!fa){
		res[x]=d1[x];g[x]=1;
		if(check(res[x],1)) fz=res[x],fm=1;
	}else{
		if(d1[x]+1==d1[fa]) g[x]=max(d2[fa],g[fa])+1;
		else g[x]=max(d1[fa],g[fa])+1;
		res[x]=max(d1[x],g[x]);
		if(check(res[x],1)) fz=res[x],fm=1;
	}
	for(int y=head[x]; y; y=e[y].next){
		if(e[y].to==fa||a[e[y].to]>1) continue;
		dfs2(e[y].to,x);
	}
}
void doit(int x){
	for(int y=head[x]; y; y=e[y].next){
		if(a[e[y].to]!=1) continue;
		int temp=res[e[y].to];
		if(temp>d1[x]){
			d2[x]=d1[x];
			d1[x]=temp;
		}else if(temp>d2[x]) d2[x]=temp;
	}
	if(check(d1[x]+d2[x]+1,2)) fm=2,fz=d1[x]+d2[x]+1;
}
int main(){
	n=read();
	for(int i=1; i<n; i++){
		int x=read(),y=read();
		add(x,y),add(y,x);
	}
	for(int i=1; i<=n; i++) a[i]=read();
	for(int i=1; i<=n; i++)		//枚举只取单一点
		if(check(1,a[i])) fz=1,fm=a[i];
	for(int i=1; i<=n; i++)		//树形dp
		if(a[i]==1&&!res[i]) dfs1(i,0),dfs2(i,0);	//去重保障时间复杂度的正确行
	for(int i=1; i<=n; i++)		//暴力合并
		if(a[i]==2) doit(i);
	if(!(fz&1)&&fm==2) fz>>=1;
	printf("%d/%d",fm,fz);
}
```

---

## 作者：xs_siqi (赞：3)

首先我们要求的是最小而不是最大。然后我们发现一个惊人的事实：分母是以 $1$ 递增的，而分子却是成倍递增的。

然后我们证明一个性质：不能选择 $p_i$ 大于 $2$ 的点，否则肯定更劣。证明如下：

最优情况下是这样一个情况，一个 $3$ 旁边有两串 $1$。

当两串 $1$ 长度分别为 $x,y$ 时，单挑一串的最小代价为 $\dfrac{1}{\min\{x,y\}}$，如果连起来则为 $\dfrac{3}{x+y+1}$。

我们知道，$2\min\{x,y\}\geq x+y$，所以 $\dfrac{2}{2\min\{x,y\}}\leq \dfrac{2}{x+y}$。

由于 $x+y>0$，所以 $\dfrac{3}{x+y+1}>\dfrac{2}{x+y}$，于是 $\dfrac{1}{\min\{x,y\}}<\dfrac{3}{x+y+1}$。

再证一个性质：选一个 $2$ 可能更优。

当两串 $1$ 长度分别为 $x,y$ 时，单挑一串的最小代价为 $\dfrac{1}{\min\{x,y\}}$，如果连起来则为 $\dfrac{2}{x+y+1}$。

此时，$\dfrac{2}{x+y+1}<\dfrac{2}{x+y}$，而 $\dfrac{2}{2\min\{x,y\}}\leq \dfrac{2}{x+y}$。$\dfrac{2}{2\min\{x,y\}}$ 与 $\dfrac{2}{x+y}$ 当且仅当 $x=y$ 时相等。也就是说，$2$ 左右两边有相等长度的 $1$，比单选那一段更优。

再证一个性质：最多只能选一个 $2$。

这个证明就比较容易了，通过上面的结论，我们知道当且仅当 $2$ 左右连续的一段 $1$ 长度相同才更优，如果中间有一个 $2$，那么必然不满足上述结论，所以得证。

---

性质推得差不多了，那么下面我们就考虑怎么求它。

考虑 dp。以 $1$ 为根。令 $f_{u,0}$ 表示向上选择了连续的一段 $1$（向上指选择的一段 $1$ 必然连续且深度严格递减）。$f_{u,1}$ 表示向上选择了连续的一段 $1$ 后（长度可为 $0$），又选了一个 $2$ 后，再向上选了连续的一段 $1$。

如果当前点权值为 $1$，那么显然可以对两个的 $f$ 数组进行更新。

对于只选 $1$ 的情况，这个节点可以从它的子节点选一个最小的只选一的 $f$ 向上转移，也就是 $f_{u,0}=\min\{f_{v_0}\}$ 后再加上转移的东西。

对于中间夹一个 $2$ 的情况，显然也是从子节点选个最小的向上转移，因为当前节点无法重新再次向上。

然后如果当前点权值为 $2$，那么对于连续的一段 $1$ 显然无法转移，因为有个 $2$ 挡着。所以直接赋值为 $0$。对于夹个 $2$ 的情况，无法从子节点已有的夹着 $2$ 向上转移，只能从连续的一段 $1$，再根据这个 $2$ 转移。也就是 $f_{u,1}=\min\{f_{v,0}\}$ 后再加要转移的东西。

当我们把这个 dp 数组预处理好后，我们发现有以下几种情况：

- 选取连续的一段 $1$，当前节点值为 $1$（最后选取的是连续的一段 $1$）。那么直接对自己的子树中选出连续的一段 $1$ 的最小和次小（不在同一子树）相加即可。

- 选取连续的一段 $1$，当前节点值为 $2$（最后选取的是夹着 $2$ 的连续一段 $1$）。这个情况的转移和上面同理，因为不可能从中间夹的转移过来，否则就有多个 $2$ 了。

- 选取夹着 $2$ 的一段，当前节点值为 $1$（最后选取的是夹着 $2$ 的连续一段 $1$）。那么求出夹着 $2$ 和连续一段 $1$ 的最小和次小。如果两个最小不在同一子树，就直接选这两个，否则就选择一个次小加一个最小的最小值。

- 选取夹着 $2$ 的一段，当前节点值为 $2$。这显然不合法。因为必然存在多个 $2$。

这样处理完就好了。复杂度为 $O(n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e6+5;
int n,TT,F[maxn],T[maxn],N[maxn],p[maxn];
int to[maxn],nxt[maxn],fir[maxn],tot,fl,o=1e9;
bool vis1[maxn],vis2[maxn];
struct edge{
	int x,y;
	void C(){x=1,y=1e9;}
	bool friend operator >= (edge x,edge y){
		if(x.x==0&&x.y==0)return 0;
		double z=x.x*1.0/x.y,z2=y.x*1.0/y.y;
		return z<=z2;}
	edge friend operator + (edge x,edge y){
		edge z;
		z.x=x.x+y.x;
		z.y=max(x.y,y.y);
		return z;}}f[maxn][2],ans;
void add1(int x,int y){
	T[++TT]=y;
	N[TT]=F[x];
	F[x]=TT;}
void add2(int x,int y){
	to[++tot]=y;
	nxt[tot]=fir[x];
	fir[x]=tot;}
void mn(edge &x,edge y){x=(x>=y?y:x);}
void down(edge &x){
	if(!x.x||!x.y)return ;
	int k=__gcd(x.x,x.y);
	x.x/=k,x.y/=k;}
void dfs1(int u,int fa){
	vis1[u]=1;
	for(int i=F[u];i;i=N[i]){
		int v=T[i];
		if(v==fa||p[v]>2)continue;
		add2(v,u),add2(u,v);
		dfs1(v,u);}}
void dfs2(int u,int fa){
	vis2[u]=1;
	edge min0,min1,cmin0,cmin1,z;
	int son0=0,son1=0,cson0=0,cson1=0;
	min0.C(),min1.C(),cmin0.C(),cmin1.C();
	for(int i=fir[u];i;i=nxt[i]){
		int v=to[i];
		if(v==fa)continue;
		dfs2(v,u);
		if(min0>=f[v][0]){	
			cmin0=min0,cson0=son0;
			min0=f[v][0],son0=v;}
		else if(cmin0>=f[v][0])
			cmin0=f[v][0],cson0=v;
		if(min1>=f[v][1]){
			cmin1=min1,cson1=son1;
			min1=f[v][1],son1=v;}
		else if(cmin1>=f[v][1])
			cmin1=f[v][1],cson1=v;}
	if(p[u]==1){
		z=(edge){1,1};
		if(min0.x==1&&min0.y==1e9)f[u][0]=z;
		else f[u][0]=min0+z;
		if(min1.x==1&&min1.y==1e9)f[u][1].C();
		else f[u][1]=min1+z;
		if(son0&&son1){
			if(son0!=son1)mn(ans,min0+min1+z);
			if(son0!=cson1&&son1!=cson0)mn(ans,min0+cmin1+z),mn(ans,cmin0+min1+z);}}
	else{
		z=(edge){1,2};
		f[u][0]=(edge){0,0};
		if(min0.x==1&&min0.y==1e9)f[u][1]=z;
		else f[u][1]=min0+z;}
	mn(ans,min0+cmin0+z);
	if(f[u][0].x&&f[u][0].y)mn(ans,f[u][0]);
	mn(ans,f[u][1]);}
signed main(){
	ans.C();
	scanf("%d",&n);
	for(int x,y,i=1;i<n;i++)
		scanf("%d%d",&x,&y),
		add1(x,y),add1(y,x);
	for(int i=1;i<=n;i++)
		scanf("%d",&p[i]),o=min(o,p[i]);
	for(int i=1;i<=n;i++)
		if(p[i]<=2&&!vis1[i])dfs1(i,0);
	for(int i=1;i<=n;i++)
		if(vis1[i])fl=1;
	if(!fl){
		printf("%d/1\n",o);
		return 0;}
	for(int i=1;i<=n;i++)
		if(!vis2[i]&&vis1[i])dfs2(i,0);
	down(ans);
	printf("%d/%d\n",ans.y,ans.x);
	return 0;}
```


---

## 作者：Unnamed114514 (赞：1)

[Blog](https://www.luogu.com.cn/blog/556362/solution-p6287)

当树上没有权为 $1$ 的节点时，我们取最小值 $v$。

证明：$v=\dfrac{kv}{k}\le\dfrac{kv+\Delta t}{k}$，取等条件：$\Delta t=0$。

***

当树上有 $1$ 的点权时，我们可以想到一直往外扩展点权为 $1$ 的节点，原因：$\dfrac{v}{k}>\dfrac{v}{k+t}$。

那么此时我们可以假设现在是这样的情况：

$$1\rightarrow1\rightarrow\cdots\rightarrow X\rightarrow\cdots\rightarrow1\rightarrow1$$

我们设 $1$ 较少的有 $l$ 个 $1$，较多有 $r$ 个 $1$，那么则有 $1\le l\le r$。那么我们当仅这种情况为**唯一的**最优解，那么则有：$\dfrac{X}{l+r+1}<\dfrac{1}{r}$，移项得 $(X-1)r<l+1$，此时我们使用放缩：$l+1\le r+1$，那么如果要满足 $(X-2)r<1$，就可以满足条件，当这个式子可行，当且仅当 $X-2=0$ 即 $X=2$ 时有解，带回，有：$r<l+1$，注意到 $l\le r$，那么可以有如下结论：

$$l=r$$

那么我们可不可以加入更多的数呢？如下：

$$1\rightarrow1\rightarrow\cdots\rightarrow X\rightarrow\cdots\rightarrow1\rightarrow1\rightarrow\cdots Y\rightarrow\cdots\rightarrow1\rightarrow1$$

那么此时我们分别设为 $l_1,l_2,l_3$，由于 $XY$ 要最小，那么我们可以设它们为 $4$，有：

$$\dfrac{4}{l_1+l_2+l_3+2}>\dfrac{2}{4l_3+2}=\dfrac{1}{2l_3+1}$$

那么，当 $l_3=l_2$ 时，肯定不能插入元素，如果 $l_3>l_2$，那么除开整个序列，由上面的结论：$\dfrac{1}{l_3}$ 或 $\dfrac{2}{l_1+l_2+1}$（此时要保证 $l_1=l_2$）就是最优的。

但是注意到 $l_1=l_2<l_3$，那么我们有：$l_1=l_2\le l3-1$，有：

$$\dfrac{2}{l_1+l_2+1}\le\dfrac{2}{2l_3-1}<\dfrac{2}{2l_3-2}=\dfrac{1}{l_3-1}<\dfrac{1}{l_3}$$

那么我们可以知道 $\dfrac{1}{l_3}$ 是最优的，我们将它与 $\dfrac{4}{l_1+l_2+l_3+2}$ 比。

$\dfrac{1}{l_3}<\dfrac{4}{l_1+l_2+l_3+2}$ 时，我们有：$l_1+l_2+l_3+2<4l_3$，但是由于 $1\le l_1,l_1<l_3$，那么则有 $2\le l_3$，那么每项都 $<l_3$，那么小于号得证。

那么我们就有答案为点扩展 $1$ 的点的链。

那么注意到我们从 $3$ 个方向扩展：向下最大，向下次大，向上（全部是 $1$）。

注意到向下次大和向下最大不能来自同一个节点，那么我们向上转移时就只需要转移向上最大就行了。

补：可能是想法问题，向上路径需要向下路径，所以要先求向下的，然后再求向上的。

这个代码有一个优势：不需要维护 $2$ 的情况。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+5;
int n,w[maxn],dp[maxn][2],flg[maxn][2],f[maxn],p=1e9,q=1;
vector<int> G[maxn];
void init(int u,int fa){
	for(int i=0,len=G[u].size();i<len;++i){
		int v=G[u][i];
		if(v==fa)
			continue;
		init(v,u);
		int p=(w[v]==1?dp[v][0]+1:0);
		if(p>dp[u][0])
			dp[u][1]=dp[u][0],flg[u][1]=flg[u][0],dp[u][0]=p,flg[u][0]=v;
		else if(p>dp[u][1])
			dp[u][1]=p,flg[u][1]=v;
	}
}
void dfs(int u,int fa){
	for(int i=0,len=G[u].size();i<len;++i){
		int v=G[u][i];
		if(v==fa)
			continue;
		if(w[u]==1)
			f[v]=max((flg[u][0]==v?dp[u][1]:dp[u][0]),f[u])+1;
		dfs(v,u);
	}
}
int main(){
	scanf("%d",&n);
	for(int i=1,u,v;i<n;++i){
		scanf("%d%d",&u,&v);
		G[u].push_back(v);
		G[v].push_back(u);
	}
	for(int i=1;i<=n;++i){
		scanf("%d",&w[i]);
		p=min(p,w[i]);
	}
	init(1,0);
	dfs(1,0);
	for(int i=1;i<=n;++i){
		if(1ll*w[i]*q<1ll*p*(dp[i][0]+max(f[i],dp[i][1])+1))
			p=w[i],q=dp[i][0]+max(f[i],dp[i][1])+1;
		if(q<1ll*p*max(f[i],dp[i][0]))
			p=1,q=max(f[i],dp[i][0]);
	}
	printf("%d/%d\n",p/__gcd(p,q),q/__gcd(p,q));
	return 0;
}
```

---

## 作者：chihik (赞：1)

[COCI2016-2017#1题解](https://www.luogu.com.cn/blog/chihik/post-2019-7-9-shu-jia-pei-xun-di-yi-ce)

此题有一个神仙结论：**最优链上最多包含一个‘2’，且‘2’不能在链的两边。** 至于证明过于简单但很麻烦（~~其实是我懒~~），给大家推荐一个博客，[点这](https://www.luogu.org/blog/23j/ti-xie-ge-ren-ti-ku-u76193-mo-li-shu-post)。

有了这个结论之后，我们就可以~~愉快~~的开始树形dp了。

我们用$dp1[u]$表示包含u节点的最长1链，$dp2[u]$表示包含u节点的含一个2，其余全是1的最长链。
那么，我们不难得到：

1.当u为1时，$dp1[u]=max(dp1[v])+1$
			$~~~~~~~~~~~~~~~~~~~~dp2[u]=max(dp2[v])+1$
         
2.当u为2时，$dp2[u]=max(dp1[v])+1$

我们再用$f1_1$表示最大的$dp1[v]$的下标，$f1_2$表示次大的$dp1[v]$的下标，$f2_1$表示最大的$dp2[v]$的下标

每次更新$dp1[u],dp2[u]$时，维护上述3个值。

最后我们更新答案，可能会出现以下情况：

#### 1.当u的值为1时
1.$f1_1=f2_1$，说明最长的含2链包含了最长的1链，更新答案为$Ans=\frac{2}{dp1[f1_2]+dp2[f2_1]+1}$

2.不存在该上关系但有含2，更新答案为$Ans=\frac{2}{dp1[f1_1]+dp2[f2_1]+1}$

3.答案的链不含2，更新答案为$Ans=\frac{1}{dp1[f1_1]+dp1[f1_2]+1}$

#### 1.当u的值为2时
最长的含2链为$Ans=\frac{2}{dp1[f1_1]+dp1[f1_2]+1}$


```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
#include <iostream>
using namespace std;
#define LL long long
#define INF 1e15

const int MAXN = 1000000;
int n,a,b;
LL p = INF , q = 1 , Mag[ MAXN + 5 ];
vector< int > Graph[ MAXN + 5 ];

void update( LL a , LL b ) {
	if( a * q < b * p ) p = a , q = b;		//更新时为了避免除法，移项变为乘法
	return;
}
LL f1[ MAXN + 5 ] , f2[ MAXN + 5 ];
void dfs( int u , int fa ) {
	int f1_1 = 0 , f1_2 = 0 , f2_1 = 0;
	if( Mag[ u ] == 1 ) f1[ u ] = 1;
	if( Mag[ u ] == 2 ) f2[ u ] = 1;
	
	for( int i = 0 ; i < Graph[ u ].size( ) ; i ++ ) {
		int v = Graph[ u ][ i ];
		if( v == fa ) continue;
		dfs( v , u );
		
		if( Mag[ u ] == 1 ) {
			f1[ u ] = max( f1[ u ] , f1[ v ] + 1 );
			f2[ u ] = max( f2[ u ] , f2[ v ] + 1 );
		}
		else if( Mag[ u ] == 2 )
			f2[ u ] = max( f2[ u ] , f1[ v ] + 1 );
		
		if( f1[ f1_1 ] < f1[ v ] ) {
			f1_2 = f1_1;
			f1_1 = v;
		}
		else if( f1[ f1_2 ] < f1[ v ] )
			f1_2 = v;
		if( f2[ f2_1 ] < f2[ v ] )
			f2_1 = v;
	}
	if( Mag[ u ] == 1 ) {
		if( f1_1 == f2_1 )
			update( 2 , f1[ f1_2 ] + f2[ f2_1 ] + 1 );
		else
			update( 2 , f1[ f1_1 ] + f2[ f2_1 ] + 1 );
		update( 1 , f1[ f1_1 ] + f1[ f1_2 ] + 1 );
	}
	if( Mag[ u ] == 2 )
		update( 2 , f1[ f1_1 ] + f1[ f1_2 ] + 1 );
}
int main( ) {
	scanf("%d",&n);
	for( int i = 1 ; i <= n - 1 ; i ++ ) {
		scanf("%d %d",&a,&b);
		Graph[ a ].push_back( b );
		Graph[ b ].push_back( a );
	}
	for( int i = 1 ; i <= n ; i ++ ) {
		scanf("%lld",&Mag[ i ]);
		p = min( Mag[ i ] , p );
	}
	dfs( 1 , 0 );
	
	LL r = __gcd( p , q );
	printf("%lld/%lld\n", p / r , q / r );
	return 0;
}
```

---

## 作者：tyukp233 (赞：0)

### 分析

观察样例#1：
```
2
1 2
3
4
```
- 路径节点数为 $1$ 时，最小值为 $3$。

- 路径节点数为 $2$ 时，最小值为 $\dfrac {3 \times4} {2}=6$。

我们发现：节点数增加了，但值却增大了。这是因为，$\dfrac {4} {2} \ge 1$，导致多加的 $4$ 不如不加。

同理，假设原始路径魔力值之积为 $p$ 且包括 $q$ 个点，当我们只考虑加入一个数 $x$ 且使得新路径更优时，有：
$$\dfrac{p}{q}> \dfrac{p\cdot x}{q+1}$$
推得：
$$ (x-1)q<1$$
只有 $x=1$ 时满足。

至此我们可以得出，当路径上绝大部分为 $1$ 才可能成为最优解，因为加入非 $1$ 点一定不优。

易知，**全为 $1$ 的路径**可能成为最优解。

那么，什么样的**包含非 $1$ 点的路径**可能成为最优解呢？

首先，不存在 $1$ 的情况最小值即**最小的点权**。

然后考虑合并路径。

设路径 $1$ 魔力值之积为 $p_1$ 且包括 $q_1$ 个点，路径 $2$ 魔力值之积为 $p_2$ 且包括 $q_2$ 个点，合并处的点 $x$ 不被包含于上述路径。

令 $\dfrac{p_1}{q_1}\le\dfrac{p_2}{q_2}$

合并后的路径更优时：
$$\dfrac{p_1}{q_1}>\dfrac{p_1\cdot p_2\cdot x}{q_1+q_2+1}$$
~~程序暴力代值~~可得 $x\le 2$，且 $x=2$ 时 $p_1=p_2=1,q_1=q_2$。

**即有一个 $2$ 且其两端都是全 $1$ 链的路径**也可能成为最优解。另外，两端的全 $1$ 链长度必须为最长全 $1$ 路径的长度。

全 $1$ 路径可以参考求树直径动态规划做法，关键在于如何求含 $2$ 路径。

手动构造样例，可以发现 $2$ 一定出现在一条全 $1$ 链的父亲处，另一条可能在 $2$ 的另一儿子或父亲处出现。~~我们就可以暴力地寻找链~~。

### 代码

提示：本篇非稳定做法，复杂度未知，可能 TLE，欢迎优化~~并薄纱我~~。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 1000005
namespace IN{
	int res;
	char ch;
	inline int read(){
		res=0;
		ch=getchar();
		while(!isdigit(ch))ch=getchar();
		while(isdigit(ch))res=res*10+(ch-'0'),ch=getchar();
		return res;
	}
}
using IN::read;
mt19937 rnd(time(0));

int n;
int pt[N],fa[N];
bool vis[N];
int down[N],mxc[N],md,mc;
int ans;

struct node{
	int to,nxt;
}e[N<<1];
int head[N],cnt=0;
void add_edge(int a,int b){
	cnt++;
	e[cnt]={b,head[a]};
	head[a]=cnt;
}

void dfs(int u,int pre){
	fa[u]=pre;
	if(pt[u]==1){
		down[u]=1;
		for(int i=head[u],v=e[i].to;i;i=e[i].nxt,v=e[i].to){
			if(v==pre)continue;	
			dfs(v,u);
			mxc[u]=max(mxc[u],down[u]+down[v]);
			down[u]=max(down[u],down[v]+1);
		}
	}else for(int i=head[u],v=e[i].to;i;i=e[i].nxt,v=e[i].to)if(v!=pre)dfs(v,u);
}
int _dfs(int u,int pre){
	if(pt[u]!=1)return 0;
	int res=0;
	for(int i=head[u],v=e[i].to;i;i=e[i].nxt,v=e[i].to)if(v!=pre)res=max(res,_dfs(v,u));
	return res+1;
}

int32_t main(){
	n=read();
	for(int i=1,x,y;i<n;i++){
		x=read(),y=read();
		add_edge(x,y),add_edge(y,x);
	}
	for(int i=1;i<=n;i++)pt[i]=read();
	dfs(rnd()%n+1,0);
	for(int i=1;i<=n;i++)md=max(md,down[i]),mc=max(mc,mxc[i]);
	if(md<mc)cout<<1<<'/'<<mc,exit(0);
	if(md==0){
		ans=INT_MAX;
		for(int i=1;i<=n;i++)ans=min(ans,pt[i]);
		cout<<ans<<"/1";
		exit(0);
	}
	for(int i=1;i<=n;i++)if(down[i]==md&&pt[fa[i]]==2&&!vis[fa[i]]){
		vis[fa[i]]=1;
		for(int j=head[fa[i]],v=e[j].to;j;j=e[j].nxt,v=e[j].to){
			if(v==i)continue;
			if(_dfs(v,fa[i])==md){
				cout<<2<<'/'<<(md*2+1);
				exit(0);
			}
		}
		if(_dfs(fa[fa[i]],fa[i])==md)cout<<2<<'/'<<(md*2+1),exit(0);
	}
	cout<<1<<'/'<<mc;
	return 0;
}

```
[可能的最优解](https://www.luogu.com.cn/record/172981611)

---

## 作者：_xinyu1113 (赞：0)

### 树径 （证明在文末）

```Hint #1```

注意权值为 $1$ 的点。

```Hint #2```

什么情况下会选权值 $\ge 3$ 的点？

如果有权值为 $1$ 的点，会选权值 $\ge 3$ 的点吗？

```Hint #3```

权值为 $2$ 的点最多选 $1$ 次。

### Solution

如果没有权值为 $1$ 的点，令 $A=\min($ 点权 $)$，$\text{Ans}=A$。

如果有权值为 $1$ 的点：

首先猜想只使用经过权值为 $1$ 的点的路径。

重建树，对于每个连通块跑直径即可。

实测 $60$ 分。

显然这不正确。

给出一组 $\text{hack}$ 数据：

```Input:```

```cpp
7
1 2
2 3
3 4
4 5
5 6
6 7
1 1 1 2 1 1 1
```

```Output:```

```cpp
2/7
```

不难发现，经过权值为 $2$ 的点，可能得出更优解。

可以证明权值为 $2$ 的点最多经过一次。

$\text{dp}$ 求出从每个点出发只经过权值为 $1$ 的点的最长路径长度，对于每个权值为 $2$ 的点连边求解即可。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n,p1[1000006],p2[1000006],val[1000006],vis[1000006],len,len2,ans=0,pans=1e9,tg=0,dp1[1000006];
vector<int>v[1000006];
void dfs1(int x,int l)
{
	vis[x]=1;
	for(int i=0;i<v[x].size();i++)
	{
		if(v[x][i]!=l)
		{
			dfs1(v[x][i],x);
			dp1[x]=max(dp1[x],dp1[v[x][i]]);
		}
	}
	dp1[x]++;
}
void dfs2(int x,int l,int fr)
{
	int p1=max(0ll,fr-1),p2=0;
	dp1[x]=max(dp1[x],fr); 
	for(int i=0;i<v[x].size();i++)
	{
		if(v[x][i]!=l)
		{
			if(dp1[v[x][i]]>p1)
			p2=p1,p1=dp1[v[x][i]];
			else if(dp1[v[x][i]]>p2)
			p2=dp1[v[x][i]];
		}
	}
	for(int i=0;i<v[x].size();i++)
	{
		if(v[x][i]!=l)
		dfs2(v[x][i],x,(dp1[v[x][i]]==p1?p2:p1)+2);
	}
}
pair<int,int>rans;
pair<int,int>min2(pair<int,int>xx,pair<int,int>yy)
{
	if(xx.first*yy.second<xx.second*yy.first)
	return xx;
	else return yy;
}
signed main()
{
	cin>>n;
	for(int i=1;i<n;i++)
	scanf("%lld%lld",&p1[i],&p2[i]);
	for(int i=1;i<=n;i++)
	scanf("%lld",&val[i]),pans=min(pans,val[i]);
	for(int i=1;i<n;i++)
	{
		if(val[p1[i]]==1&&val[p2[i]]==1)
		v[p1[i]].push_back(p2[i]),v[p2[i]].push_back(p1[i]);
	}
	for(int i=1;i<=n;i++)
	{
		if((!vis[i])&&val[i]==1)
		{
			len=len2=-1;
			dfs1(i,-1);
			dfs2(i,-1,1);
		}
	}
	for(int i=1;i<=n;i++)
	ans=max(ans,dp1[i]);
	rans=min2({pans,1},{1,ans});
	for(int i=1;i<n;i++)
	{
		v[p1[i]].push_back(p2[i]);
		v[p2[i]].push_back(p1[i]);
	}
	for(int i=1;i<=n;i++)
	{
		if(val[i]==2)
		{
			int p1=0,p2=0;
			for(int j=0;j<v[i].size();j++)
			{
				if(dp1[v[i][j]]>p1)
				p2=p1,p1=dp1[v[i][j]];
				else if(dp1[v[i][j]]>p2)
				p2=dp1[v[i][j]];
			}
			rans=min2(rans,{2,p1+p2+1});
		}
	}
	cout<<rans.first/__gcd(rans.first,rans.second)<<"/"<<rans.second/__gcd(rans.first,rans.second)<<endl; 
	return 0;
}
```

### 证明

假如有权值为 $1$ 的点：

显然 $\text{Ans}\le 1$。

如果一条路径有权值超过 $2$ 的点：

假设这条路径是这样的：

${1,1,1,\dots,3,\dots,1,1,1}$

$3$ 前面的 $1$ 有 $x$ 个，后面的 $1$ 有 $y$ 个。

显然有一解为 $1/x$，有一解为 $1/y$，总序列解为 $3/(x+y+1)$。

令 $a=\operatorname{Max}(x,y)$，显然 $2a\ge (x+y),3a\ge (x+y+1)$，因为 $a \ge 1$。

于是不难得出结论，取任何含 $3$ 及以上数的长度 $\ge 2$ 的路径不优。


如果一条路径有权值等于 $2$ 的点：

${1,1,1,\dots,2,1,1,1,\dots,2,1,1,1,\dots,1,1,1}$

$3$ 前面的 $1$ 有 $x$ 个，中间的 $1$ 有 $y$ 个，结尾的 $1$ 有 $z$ 个。

显然有一解为 $1/x$ , 有一解为 $1/y$ , 有一解为 $1/z$ , 总序列解为 $4/(x+y+z+2)$。

令 $a=\operatorname{Max}(x,y,z)$，显然当 $a \ge 1$ 时，$4a\ge (x+y+z+2)$。

当 $a=1,min(x,y,z)=0$ 时，显然 $4a\ge (x+y+z+2)$。

当 $a=1,min(x,y,z)=1$ 时，序列 ${1,2,1}(2/3)$ 优于序列 ${1,2,1,2,1}(4/5)$。

所以，含有超过一个权值为 $2$ 的节点的路径也不优。

证毕。

---

## 作者：Night_Bringer (赞：0)

[原博客食用更佳](https://www.cnblogs.com/C202202chenkelin/p/14035444.html)
## 思路
首先来证明一点。满足题意的最优解一定为由全部是1，或仅含有1个2的链来组成的（当且仅当2两边的）。

证明：
* 当$a=b$时，含有2的链的价值为：$\frac{2}{a+b+1}=\frac{2}{2a +1}$，而不含有2的链价值为$\frac{1}{a}$，很明显，含有二的链比含有1的链优。
* 当$a≠b$时，不妨设$a＞b$，设$a-b=k$，含有2的链价值为$\frac{2}{a+b+1}=\frac{2}{2a-k +1}$，而含1的链为$\frac{1}{a-k}=\frac{2}{2a-2k}$，明显含有1的链更优。在1链和1链中添加任意一个大于2的数，则都会上述情况一样，没有含1的链更优，可以以上述情况来推广。

有了上述的证明，就可以进行树形DP了。就称只含有1的链为1链，其中含了一的1链为2链。

设$dp[i][0|1][0|1]$的第一维表示是哪一个节点的状态。对应的价值最小。第二维表示该节点参与的链中是否含有2这个点，若含有2，则该维度对应值为0，否则为1。第三维表示分子分母，1为分子，0为分母。

$sec[0|1][0|1]$对应的是次小值。其中的第一维与$dp[i]$的第二维意义相同，第二维与其第三维相同。

$id[0|1][0|1]$的第一维表示该节点参与的链中是否含有2这个点，若含有2，则该维度对应值为0，否则为1。第二维表示最小一次对应次小与最小。

先来说说如何状态转移。

如下面的代码所示（主体部分）。

```cpp
for(int i = 0; i < SIZ; i++) {
	int next = v[now][i];
	if(next == fa)
		continue;
	DP(next, now);
	if(val[now] == 1) {
		if(val[next] > 2)
			continue;
		double son1 = (dp[next][1][1] * 1.0) / ((dp[next][1][0] + 1) * 1.0);
		double son2 = (dp[next][0][1] * 1.0) / ((dp[next][0][0] + 1) * 1.0);
		double self1 = (dp[now][1][1] * 1.0) / (dp[now][1][0] * 1.0);
		double self2 = (dp[now][0][1] * 1.0) / (dp[now][0][0] * 1.0);
		double num1 = (sec[1][1] * 1.0) / (sec[1][0] * 1.0);
		double num2 = (sec[0][1] * 1.0) / (sec[0][0] * 1.0);
		if(son1 < self1) {
			sec[1][1] = dp[now][1][1];
			sec[1][0] = dp[now][1][0];
			id[1][0] = id[1][1];
			dp[now][1][1] = dp[next][1][1];
			dp[now][1][0] = dp[next][1][0] + 1;
			id[1][1] = next;
		}
		else if(son1 < num1) {
			id[1][0] = next;
			sec[1][1] = dp[next][1][1];
			sec[1][0] = dp[next][1][0] + 1;
		}
		if(son2 < self2) {
			sec[0][1] = dp[now][0][1];
			sec[0][0] = dp[now][0][0];
			id[0][0] = id[0][1];
			dp[now][0][1] = dp[next][0][1];
			dp[now][0][0] = dp[next][0][0] + 1;
			id[0][1] = next;
		}
		else if(son2 < num2) {
			sec[0][1] = dp[next][0][1];
			sec[0][0] = dp[next][0][0] + 1;
			id[0][0] = next;
		}
	}
	else if(val[now] == 2) {
		if(val[next] != 1)
			continue;
		double son = (dp[next][1][1] * 2.0) / ((dp[next][1][0] + 1) * 1.0);
		double self = (dp[now][0][1] * 1.0) / (dp[now][0][0] * 1.0);
		double num = (sec[0][1] * 1.0) / (sec[0][0] * 1.0);
		if(son < self) {
			sec[0][1] = dp[now][0][1];
			sec[0][0] = dp[now][0][0];
			id[0][0] = id[0][1];
			dp[now][0][1] = dp[next][1][1] * 2;
			dp[now][0][0] = dp[next][1][0] + 1;
			id[0][1] = next;
		}
		else if(son < num) {
			sec[0][1] = dp[next][1][1] * 2;
			sec[0][0] = dp[next][1][0] + 1;
			id[0][0] = next;
		}
	}
}
```
### 情况一
设当前正在遍历的节点为now，对于now的每一个子节点next，若有now的权值为1，则有：

* son1：当前子节点带有的最小1链加上父节点的价值。
* son2：当前子节点带有的最小2链加上父节点的价值。
* self1：最小1链的价值。
* self2：最小2链的价值。
* num1：次小1链的价值。
* num2：次小2链的价值。

若next的权值大于2，则没有资格更新自己的父节点。需要先判断是否有资格更新父节点的值。
```cpp
if(val[next] > 2)
	continue;
```
又有几种情况：
* 当son1 < self1时，即是当前子节点的1链可以更新最小链的1链。先使用最小1链来更新次小1链的值。在使用子节点来更新最小1链的值。代码如下。
```cpp
if(son1 < self1) {
	sec[1][1] = dp[now][1][1];
	sec[1][0] = dp[now][1][0];
	id[1][0] = id[1][1];
	dp[now][1][1] = dp[next][1][1];
	dp[now][1][0] = dp[next][1][0] + 1;
	id[1][1] = next;
}
```
* 在不满足上述情况时，当前子节点仅仅只能更新次小链的值，那么就用次小链更新最小链的值。代码如下。
```cpp
else if(son1 < num1) {
	id[1][0] = next;
	sec[1][1] = dp[next][1][1];
	sec[1][0] = dp[next][1][0] + 1;
}
```
* 更新最小二链与最次小二链，与更新1链的方法相似。更新最小2链的代码如下。
```cpp
if(son2 < self2) {
	sec[0][1] = dp[now][0][1];
	sec[0][0] = dp[now][0][0];
	id[0][0] = id[0][1];
	dp[now][0][1] = dp[next][0][1];
	dp[now][0][0] = dp[next][0][0] + 1;
	id[0][1] = next;
}
```
* 更新次小2链的价值
```cpp
else if(son2 < num2) {
	sec[0][1] = dp[next][0][1];
	sec[0][0] = dp[next][0][0] + 1;
	id[0][0] = next;
}
```
### 情况二
设当前正在遍历的节点为now，对于now的每一个子节点next，若有now的权值为2。因为这条链中必会有2，所以就不需要考虑更新1链的价值。则有：
* son：当前子节点带有的最小1链加上父节点的价值。
* self2：最小2链的价值。
* num：次小2链的价值。

若当前子节点的子节点的权值不为1，则也没有资格更新父节点。
```cpp
if(val[next] != 1)
	continue;
```
更新方式与上述相同。

但最小2链只能由儿子的1链来更新，因为一条2链中只能含有1个2，而当前节点就是2。

* 更新最小
```cpp
if(son < self) {
	sec[0][1] = dp[now][0][1];
	sec[0][0] = dp[now][0][0];
	id[0][0] = id[0][1];
	dp[now][0][1] = dp[next][1][1] * 2;
	dp[now][0][0] = dp[next][1][0] + 1;
	id[0][1] = next;
}
```
* 更新次小
```cpp
else if(son < num) {
	sec[0][1] = dp[next][1][1] * 2;
	sec[0][0] = dp[next][1][0] + 1;
	id[0][0] = next;
}
```
### 现在来更新答案
又分了几种情况
* 只用最小2链。若当前父节点只含有1个子节点，则只有1条链来更新答案。
```cpp
double Num = (dp[now][0][1] * 1.0) / (dp[now][0][0] * 1.0);
if(Num < ans) {
	ans = Num;
	ans1 = dp[now][0][1];
	ans2 = dp[now][0][0];
}
```
* 只用最小1链，理由与2链相同。
```cpp
Num = (dp[now][1][1] * 1.0) / (dp[now][1][0] * 1.0);
if(Num < ans) {
	ans = Num;
	ans1 = dp[now][1][1];
	ans2 = dp[now][1][0];
}
```
* 最长1链加最长2链。当且仅当最小2链与最小1链来自于不同的子节点。
```cpp
if(id[1][1] != id[0][1]) {
	Num = ((dp[now][0][1] * dp[now][1][1]) * 1.0) / ((dp[now][0][0] + dp[now][1][0] - 1) * 1.0);
	if(Num < ans) {
		ans = Num;
		ans1 = dp[now][0][1] * dp[now][1][1];
		ans2 = dp[now][0][0] + dp[now][1][0] - 1;
	}
}
```
* 若不满足最小2链与最小1链来自于不同的子节点，则使用次小1，2链与最小2，1链相结合来更新答案（注意顺序）。
```cpp
else {
	if(id[1][0] != id[0][1]) {
		Num = ((dp[now][0][1] * sec[1][1]) * 1.0) / ((dp[now][0][0] + sec[1][0] - 1) * 1.0);
		if(Num < ans) {
			ans = Num;
			ans1 = dp[now][0][1] * sec[1][1];
			ans2 = dp[now][0][0] + sec[1][0] - 1;
		}
	}
	if(id[0][0] != id[1][1]) {
		Num = ((sec[0][1] * dp[now][1][1]) * 1.0) / ((sec[0][0] + dp[now][1][0] - 1) * 1.0);
		if(Num < ans) {
			ans = Num;
			ans1 = sec[0][1] * dp[now][1][1];
			ans2 = sec[0][0] + dp[now][1][0] - 1;
		}
	}
}
```
* 用最小1链与次小1链来更新答案。
```cpp
Num = ((dp[now][1][1] * sec[1][1]) * 1.0) / ((dp[now][1][0] + sec[1][0] - 1) * 1.0);
if(Num < ans) {
	ans = Num;
	ans1 = dp[now][1][1] * sec[1][1];
	ans2 = dp[now][1][0] + sec[1][0] - 1;
}
```
## 输出
记得分子分母需要互质。
## C++代码
```cpp
#include <cstdio>
#include <vector>
using namespace std;
#define INF 1e8
#define Min(a, b) ((a) < (b) ? (a) : (b))
void Quick_Read(int &N) {
	N = 0;
	char c = getchar();
	int op = 1;
	while(c < '0' || c > '9') {
		if(c == '-')
			op = -1;
		c = getchar();
	}
	while(c >= '0' && c <= '9') {
		N = (N << 1) + (N << 3) + c - 48;
		c = getchar();
	}
	N *= op;
}
const int MAXN = 1e6 + 5;
bool flag;
vector<int> v[MAXN];
int down[MAXN], dp[MAXN][2][2];
int val[MAXN];
int n, minn;
double ans;
int ans1, ans2;
int GCD(int a, int b) {
	return b == 0 ? a : GCD(b, a % b);
}
void DP(int now, int fa) {
	int sec[2][2];
	int id[2][2];
	for(int i = 0; i <= 1; i++)
		for(int j = 0; j <= 1; j++)
			sec[i][j] = id[i][j] = INF;
	int SIZ = v[now].size();
	for(int i = 0; i < SIZ; i++) {
		int next = v[now][i];
		if(next == fa)
			continue;
		DP(next, now);
		if(val[now] == 1) {
			if(val[next] > 2)
				continue;
			double son1 = (dp[next][1][1] * 1.0) / ((dp[next][1][0] + 1) * 1.0);
			double son2 = (dp[next][0][1] * 1.0) / ((dp[next][0][0] + 1) * 1.0);
			double self1 = (dp[now][1][1] * 1.0) / (dp[now][1][0] * 1.0);
			double self2 = (dp[now][0][1] * 1.0) / (dp[now][0][0] * 1.0);
			double num1 = (sec[1][1] * 1.0) / (sec[1][0] * 1.0);
			double num2 = (sec[0][1] * 1.0) / (sec[0][0] * 1.0);
			if(son1 < self1) {
				sec[1][1] = dp[now][1][1];
				sec[1][0] = dp[now][1][0];
				id[1][0] = id[1][1];
				dp[now][1][1] = dp[next][1][1];
				dp[now][1][0] = dp[next][1][0] + 1;
				id[1][1] = next;
			}
			else if(son1 < num1) {
				id[1][0] = next;
				sec[1][1] = dp[next][1][1];
				sec[1][0] = dp[next][1][0] + 1;
			}
			if(son2 < self2) {
				sec[0][1] = dp[now][0][1];
				sec[0][0] = dp[now][0][0];
				id[0][0] = id[0][1];
				dp[now][0][1] = dp[next][0][1];
				dp[now][0][0] = dp[next][0][0] + 1;
				id[0][1] = next;
			}
			else if(son2 < num2) {
				sec[0][1] = dp[next][0][1];
				sec[0][0] = dp[next][0][0] + 1;
				id[0][0] = next;
			}
		}
		else if(val[now] == 2) {
			if(val[next] != 1)
				continue;
			double son = (dp[next][1][1] * 2.0) / ((dp[next][1][0] + 1) * 1.0);
			double self = (dp[now][0][1] * 1.0) / (dp[now][0][0] * 1.0);
			double num = (sec[0][1] * 1.0) / (sec[0][0] * 1.0);
			if(son < self) {
				sec[0][1] = dp[now][0][1];
				sec[0][0] = dp[now][0][0];
				id[0][0] = id[0][1];
				dp[now][0][1] = dp[next][1][1] * 2;
				dp[now][0][0] = dp[next][1][0] + 1;
				id[0][1] = next;
			}
			else if(son < num) {
				sec[0][1] = dp[next][1][1] * 2;
				sec[0][0] = dp[next][1][0] + 1;
				id[0][0] = next;
			}
		}
	}
	double Num = (dp[now][0][1] * 1.0) / (dp[now][0][0] * 1.0);
	if(Num < ans) {
		ans = Num;
		ans1 = dp[now][0][1];
		ans2 = dp[now][0][0];
	}
	Num = (dp[now][1][1] * 1.0) / (dp[now][1][0] * 1.0);
	if(Num < ans) {
		ans = Num;
		ans1 = dp[now][1][1];
		ans2 = dp[now][1][0];
	}
	if(id[1][1] != id[0][1]) {
		Num = ((dp[now][0][1] * dp[now][1][1]) * 1.0) / ((dp[now][0][0] + dp[now][1][0] - 1) * 1.0);
		if(Num < ans) {
			ans = Num;
			ans1 = dp[now][0][1] * dp[now][1][1];
			ans2 = dp[now][0][0] + dp[now][1][0] - 1;
		}
	}
	else {
		if(id[1][0] != id[0][1]) {
			Num = ((dp[now][0][1] * sec[1][1]) * 1.0) / ((dp[now][0][0] + sec[1][0] - 1) * 1.0);
			if(Num < ans) {
				ans = Num;
				ans1 = dp[now][0][1] * sec[1][1];
				ans2 = dp[now][0][0] + sec[1][0] - 1;
			}
		}
		if(id[0][0] != id[1][1]) {
			Num = ((sec[0][1] * dp[now][1][1]) * 1.0) / ((sec[0][0] + dp[now][1][0] - 1) * 1.0);
			if(Num < ans) {
				ans = Num;
				ans1 = sec[0][1] * dp[now][1][1];
				ans2 = sec[0][0] + dp[now][1][0] - 1;
			}
		}
	}
	Num = ((dp[now][1][1] * sec[1][1]) * 1.0) / ((dp[now][1][0] + sec[1][0] - 1) * 1.0);
	if(Num < ans) {
		ans = Num;
		ans1 = dp[now][1][1] * sec[1][1];
		ans2 = dp[now][1][0] + sec[1][0] - 1;
	}
}
void Read() {
	ans = INF;
	minn = INF;
	int A, B;
	Quick_Read(n);
	for(int i = 1; i < n; i++) {
		Quick_Read(A);
		Quick_Read(B);
		v[A].push_back(B);
		v[B].push_back(A);
	}
	for(int i = 1; i <= n; i++) {
		Quick_Read(val[i]);
		if(val[i] == 1) {
			flag = true;
		}
		minn = Min(minn, val[i]);
	}
	for(int i = 1; i <= n; i++) {
		dp[i][0][1] = dp[i][1][1] = INF;
		if(val[i] == 1) {
			dp[i][1][1] = 1;
			dp[i][0][1] = 1;
		}
		else if(val[i] == 2) {
			dp[i][1][1] = 2;
			dp[i][0][1] = 2;
		}
		dp[i][0][0] = dp[i][1][0] = 1;
	}
}
int main() {
	Read();
	if(!flag) {
		printf("%d/1", minn);
		return 0;
	}
	DP(1, -1);
	int gcd = GCD(ans1, ans2);
	ans1 /= gcd;
	ans2 /= gcd;
	printf("%d/%d", ans1, ans2);
	return 0;
}
```

---

## 作者：cirnovsky (赞：0)

## 题意简述

定义一条链的价值为链上点权乘积除以节链上点数，求一条价值最小的链。

## 题解

结论：答案链上最多包含一个 $2$（其余全为 $1$），并且不在链的两端点。

证明：我们问题分成两个 $\texttt{pass}$。

- $\texttt{pass 1}$：$\forall u,s.t.x_{u}\ge2$。

答案显然为 $\min\{x_{u}\},u\in V$。

- $\texttt{pass 2}$：$\exists E'\subset E,s.t.x_{u}=1,u\in E'\wedge x_{v}\ge2,v\in E\setminus E'$。

- - 我们设我们选出的链为大概这样的造型：

$$
1\rightarrow1\rightarrow\cdots\rightarrow X\rightarrow1\rightarrow1\cdots
$$

即一堆 $1$ 中夹了一个 $X$。

我们设 $X$ 左边有 $l$ 个节点，右边有 $r$ 个节点。

则价值为整条链 $\frac{X}{l+r+1}$，左边 $\frac{1}{l}$，右边 $\frac{1}{r}$。

为方便我们这里设 $l<r$。

那么左边的价值一定大于右边。

这里假设 $\frac{1}{r}>\frac{X}{l+r+1}$，则有 $X<\frac{l+1}{r}+1$，又 $r\ge l+1$，所以 $\frac{l+1}{r}\le1$。（反之可以证伪，懒得写了 QwQ）

所以有 $X\le2$。

又 $X\neq1$，所以 $X=2$。

- - 我们设我们选出的链为大概这样的造型：

$$
1\rightarrow1\rightarrow\cdots\rightarrow X\rightarrow1\rightarrow\cdots\rightarrow1\rightarrow Y\rightarrow1\cdots
$$

即一堆 $1$ 中夹了一个 $X$ 一个 $Y$。

这里我们可以把 $Y$ 以前当成 $\texttt{pass 2}$ 的第一个类型，设其共有 $N$ 个数。

那么假设我们加入 $Y$ 更优，即有 $\frac{XY}{N+1}<\frac{X}{N}$，则有 $NY<N+1$，由于 $Y\neq1$，所以加入 $Y$ 是更劣的。

后面的同理就可以推广了。

于是得证 QwQ。

然后我们就可以 DP 了。

设 $f_{u,0/1}$ 表示节点 $u$ 权值为的情况下最优答案。

转移就分类讨论一下：

- $x_{u}=1$

$$
\begin{cases}
f_{u,0}=\max\{f_{v,0}\}+1 \\
f_{u,1}=\max\{f_{v,1}\}+1
\end{cases}
$$

- $x_{u}=2$

$$
f_{u,1}=\max\{f_{v,0}\}+1
$$

答案也需要分类讨论（这里设 $x,y\in\text{son}(u)$）：

- $x_{u}=1$

答案为 $\frac{1}{\max\{f_{x,0}+f_{y,0}+1\}}$，以及 $\frac{2}{\max\{f_{x,0}+f_{y,1}\}+1}$。

- $x_{u}=2$

答案为 $\frac{2}{\max\{f_{x,0}+f_{y,0}+1\}}$。

用四个变量维护最大、次大的 $f_{0},f_{1}$ 即可。

```cpp
#include <cstdio>

const int MAXN = 1e6 + 5;

int rint () {
	int x = 0, f = 1; char c = getchar ();
	for ( ; c < '0' || c > '9'; c = getchar () )	f = c == '-' ? -f : f;
	for ( ; c >= '0' && c <= '9'; c = getchar () )	x = ( x << 3 ) + ( x << 1 ) + ( c & 15 );
	return x * f;
}

template<typename _T>
void wint ( _T x ) {
	if ( x < 0 )	putchar ( '-' ), x = ~ x + 1;
	if ( x > 9 )	wint ( x / 10 );
	putchar ( x % 10 ^ '0' );
}

template<typename _T> _T MIN ( const _T x, const _T y ) { return x > y ? y : x; }

struct starS {
	int to, nx;
	starS ( int T = 0, int N = 0 ) { to = T, nx = N; }
} as[MAXN * 2];

int n, cnt, Up = 1e9, Dn = 1, mnMg = 1e9, a[MAXN], f[MAXN][2], bgin[MAXN];

void pushEdge ( const int u, const int v ) { as[++ cnt] = starS ( v, bgin[u] ); bgin[u] = cnt; }

void checkUpt ( const int x, const int y ) { if ( Up * y > Dn * x )	Up = x, Dn = y; }

void dfs ( const int u, const int lst ) {
	int mx0 = 0, se0 = 0, mx1 = 0, se1 = 0;
	for ( int i = bgin[u]; i; i = as[i].nx ) {
		int v = as[i].to;
		if ( v == lst )	continue;
		dfs ( v, u );
		if ( f[v][0] > f[mx0][0] )	se0 = mx0, mx0 = v;
		else if ( f[v][0] > f[se0][0] )	se0 = v;
		if ( f[v][1] > f[mx1][1] )	se1 = mx1, mx1 = v;
		else if ( f[v][1] > f[se1][1] )	se1 = v;
	}
	if ( a[u] == 1 ) {
		f[u][0] = f[mx0][0] + 1;
		checkUpt ( 1, f[mx0][0] + f[se0][0] + 1 );
		if ( ! mx1 )	return;
		f[u][1] = f[mx1][1] + 1;
		if ( mx0 != mx1 )	checkUpt ( 2, f[mx0][0] + f[mx1][1] + 1 );
		else {
			checkUpt ( 2, f[se0][0] + f[mx1][1] + 1 );
			if ( se1 )	checkUpt ( 2, f[mx0][0] + f[se1][1] + 1 );
		}
	}
	else if ( a[u] == 2 )	f[u][1] = f[mx0][0] + 1, checkUpt ( 2, f[mx0][0] + f[se0][0] + 1 );
}

int main () {
	n = rint ();
	for ( int i = 1, u, v; i < n; ++ i ) {
		u = rint (), v = rint ();
		pushEdge ( u, v ), pushEdge ( v, u );
	}
	for ( int i = 1; i <= n; ++ i )	a[i] = rint (), mnMg = MIN ( mnMg, a[i] );
	if ( mnMg > 1 )	wint ( mnMg ), putchar ( '/' ), wint ( 1 ), putchar ( '\n' );
	else	dfs ( 1, 0 ), wint ( Up ), putchar ( '/' ), wint ( Dn ), putchar ( '\n' );
	return 0;
}
```

---

## 作者：STrAduts (赞：0)

结论：最多包含一个 $2$，并且不在链的两端点。

证明：我们问题分成两个 $\texttt{pass}$。

- $\texttt{pass 1}$：$\forall u,s.t.x_{u}\ge2$。

答案显然为 $\min\{x_{u}\},u\in V$。

- $\texttt{pass 2}$：$\exists E'\subset E,s.t.x_{u}=1,u\in E'\wedge x_{v}\ge2,v \in E \setminus E$。

- - 我们设我们选出的链为大概这样的造型：

$$
1\rightarrow1\rightarrow\cdots\rightarrow X\rightarrow1\rightarrow1\cdots
$$

即一堆 $1$ 中夹了一个 $X$。

我们设 $X$ 左边有 $l$ 个节点，右边有 $r$ 个节点。

则价值为整条链 $\frac{X}{l+r+1}$，左边 $\frac{1}{l}$，右边 $\frac{1}{r}$。

为方便我们这里设 $l<r$。

那么左边的价值一定大于右边。

这里假设 $\frac{1}{r}>\frac{X}{l+r+1}$，则有 $X<\frac{l+1}{r}+1$，又 $r\ge l+1$，所以 $\frac{l+1}{r}\le1$。（假设反过来可以证伪。

所以有 $X\le2$。

又 $X\neq1$，所以 $X=2$。

- - 我们设我们选出的链为大概这样的造型：

$$
1\rightarrow1\rightarrow\cdots\rightarrow X\rightarrow1\rightarrow\cdots\rightarrow1\rightarrow Y\rightarrow1\cdots
$$

即一堆 $1$ 中夹了一个 $X$ 一个 $Y$。

这里我们可以把 $Y$ 以前当成 $\texttt{pass 2}$ 的第一个类型，设其共有 $N$ 个数。

那么假设我们加入 $Y$ 更优，即有 $\frac{XY}{N+1}<\frac{X}{N}$，则有 $NY<N+1$，由于 $Y\neq1$，所以加入 $Y$ 是更劣的。

---

## 作者：傅思维666 (赞：0)

## 题解：

~~2020.11.23模拟赛T4 25分场~~

觉得可以用点分治做。但是考场上一直没写出来。如果觉得点分治做法可行的小伙伴可以私信或留言联系我。咱俩一起研究。

在考场上发现一个性质：1越多贡献越多。而且，除了1之外，再往里加任何数都不优。

于是树形DP求了个最长的1链。最后假了，挂了好多分。

问题出在哪呢？

原来，2也是可以被放进这条链的。可以这样去想：现在有两条最长1链（分开的），只需要中间的一个2就可以把它们沟通起来。这样的答案有可能更优秀。

于是我们就可以用$f[i],g[i]$分别统计以i为根的子树中，以i为一端且魔力值为1的最大长度、魔力值为2的最大长度。

当然，根据之前的思路，我们为了统计这些信息，还需要统计最大值、次大值。

具体的在代码中实现：

```cpp
#include<cstdio>
using namespace std;
const int maxn=1e6+6;
struct Node
{
	int next;
	int to;
}edge[maxn<<1];
int head[maxn],cnt;
void add(int u,int v)
{
	edge[cnt].next=head[u];
	edge[cnt].to=v;
	head[u]=cnt++;
}
int mag[maxn];
int f[maxn],g[maxn];
int p=1e9,q=1,mn=1e9;
void update(int x,int y)
{
	if(p*y>q*x)
		p=x,q=y;
	return;
}
void dfs(int x,int fa)
{
	int u1=0,u2=0,v1=0,v2=0;
	for(int i=head[x];~i;i=edge[i].next)
	{
		int t=edge[i].to;
		if(t!=fa)
		{
			dfs(t,x);
			if(f[t]>f[u1]){
				u2=u1,u1=t;
			}
			else if(f[t]>f[u2]){
				u2=t;
			}
			if(g[t]>g[v1]){
				v2=v1,v1=t;
			}
			else if(g[t]>g[v2]){
				v2=t;
			}
		}
	}
	if(mag[x]==1)
	{
		f[x]=f[u1]+1;
		update(1,f[u1]+f[u2]+1);
		if(v1!=0)
		{
			g[x]=g[v1]+1;
			if(u1!=v1)
				update(2,f[u1]+g[v1]+1);
			else
			{
				update(2,f[u2]+g[v1]+1);
				if(v2!=0)
					update(2,f[u1]+g[v2]+1);
			}
		}
	}
	else if(mag[x]==2)
	{
		g[x]=f[u1]+1;
		update(2,f[u1]+f[u2]+1);
	}
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
		head[i]=-1;
	for(int i=1;i<n;++i)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		add(u,v);
		add(v,u);
	}
	for(int i=1;i<=n;++i)
	{
		scanf("%d",mag+i);
		if(mag[i]<mn)
			mn=mag[i];
	}
	if(mn>1)
	{
		printf("%d/1",mn);
		return 0;
	}
	dfs(1,0);
	printf("%d/%d",p,q);
	return 0;
}
```



---

## 作者：ModestCoder_ (赞：0)

结论：答案一定是某个点，或者一段1，或者一段1中间有个2

某个点的情况不论，如果能有答案比单个点更优，一定满足上面的结论

证明：

$1.11111(x个)311111(y个)$，总的值是$\frac{3}{x+y+1}$，令$x<=y$，则还有一种情况是$\frac{1}{y}$

$\frac{3}{x+y+1}<\frac{1}{y},3y<x+y+1,2y<x+1$不可能，所以一段1中间不可能有$>=3$的数，或者乘积会$>=3$

$2.11111(x个)3,\frac{3}{x+1}<\frac{1}{x},3x<x+1,2x<1$，不可能，所以一段1的端点不可能接上一个$>=3$的数

$3.11111(x个)2,\frac{2}{x+1}<\frac{1}{x},2x<x+1,x<1$，不可能，所以一段1的端点不可能接上一个$>=2$的数

**所以，正确答案两端不能>1**

$4.11111(x个)211111(y个),x<=y$

$\frac{2}{x+y+1}<\frac{1}{y},2y<x+y+1,y<x+1,y<=x$

$又y>=x,所以y=x$

当且仅当$x=y$时，可以使中间插上一个2，更优

能不能多插几个2？结论1告诉我们了，不行

其实呢，我们只需要用到正确答案是一段1中间可能有一个2就行了

用树形dp解决

$dp_{u,1}$表示全是1的最长链

$dp_{u,2}$表示包含一个2的最长链

- $a_u=1:dp_{u,1}=max(dp_{u,1},dp_{v,1}+1),dp_{u,2}=max(dp_{u,2},dp_{v,2}+1)$
- $a_u=2:dp_{u,2}=max(dp_{u,2},dp_{v,1}+1)$

然后每个点的时候都求一个答案

需要记录下儿子中最长，次长的1链，2链

注意的一点是如果最长的1链，2链是同一条，不能同取

Code：

```cpp
#include <bits/stdc++.h>
#define maxn 1000010
#define LL long long
using namespace std;
struct Edge{
	int to, next;
}edge[maxn << 1];
int num, head[maxn], n;
LL a[maxn], dp[maxn][3], p, q; 

inline int read(){
	int s = 0, w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
	return s * w;
}

void addedge(int x, int y){ edge[++num] = (Edge){y, head[x]}, head[x] = num; }
LL gcd(LL m, LL n){ return n == 0 ? m : gcd(n, m % n); }
void update(LL x, LL y){ if (x * q < y * p) p = x, q = y; }

void dfs(int u, int pre){
	if (a[u] == 1) dp[u][1] = 1;
	if (a[u] == 2) dp[u][2] = 1;
	int fir = 0, sec = 0, fir2 = 0, sec2 = 0;
	for (int i = head[u]; i; i = edge[i].next){
		int v = edge[i].to;
		if (v == pre) continue;
		dfs(v, u);
	}
	for (int i = head[u]; i; i = edge[i].next){
		int v = edge[i].to;
		if (v == pre) continue;
		if (a[u] == 1) dp[u][1] = max(dp[u][1], dp[v][1] + 1), dp[u][2] = max(dp[u][2], dp[v][2] + 1);
		if (a[u] == 2) dp[u][2] = max(dp[u][2], dp[v][1] + 1);
		if (dp[v][1] > dp[fir][1]) sec = fir, fir = v;
		else if (dp[v][1] > dp[sec][1]) sec = v;
		if (dp[v][2] > dp[fir2][2]) sec2 = fir2, fir2 = v;
		else if (dp[v][2] > dp[sec2][2]) sec2 = v;
	}
	if (a[u] == 1){
		update(1, dp[fir][1] + dp[sec][1] + 1);
		if (fir == fir2) update(2, dp[sec][1] + dp[fir2][2] + 1), update(2, dp[fir][1] + dp[sec2][2] + 1);
		else update(2, dp[fir][1] + dp[fir2][2] + 1);
	}
	if (a[u] == 2) update(2, dp[fir][1] + dp[sec][1] + 1);
}

int main(){
	n = read();
	for (int i = 1; i < n; ++i){
		int x = read(), y = read();
		addedge(x, y), addedge(y, x);
	}
	p = 1e9, q = 1;
	for (int i = 1; i <= n; ++i) p = min(p, a[i] = read());
	dfs(1, 0);
	LL r = gcd(p, q);
	printf("%lld/%lld\n", p / r, q / r);
	return 0;
}
```


---

## 作者：MCAdam (赞：0)

[P6287 [COCI2016-2017#1] Mag](https://www.luogu.com.cn/problem/P6286)

考虑我们当前得到的一个答案为$\dfrac{a}{b}$（未约分）。对于一个新的节点，如果把它加入这条路径，答案就变为$\dfrac{ax}{b+1}$

很容易想到$x$不能太大。

那什么情况下才能满足$\dfrac{ax}{b+1}\leq \dfrac{a}{b}$

解这个不等式得到：$b(x-1)\leq 1$

$\therefore b=1,x\leq 2$或$b>1,x=1$

这也就说明了，这一条路径要么全是$1$，要么有一个$2$，其他都是$1$。好像不是很严谨，~~感性理解~~

那么在这种情况下，分子要么是$1$，要么是$2$，我们要让分母尽可能地大，那么就转换成在这棵树上求满足条件的最长链。

这个可以用树形DP求。我这里写法不是通常的设最长链和次长链。比如说要求一颗树的直径，令$f[p]$表示以$p$为根的子树中，一定经过$p$的直径。那么在枚举儿子$q$的过程中，$f[p]$保存的是到$q$的兄弟的最长链，那么$f[p]+f[q]$就有可能成为一条直径，更新答案，然后再更新$f[p]$

设$f1[p]$表示以$p$为根的子树中，并且一端为$p$的全$1$最长链；$f2[p]$表示以$p$为根的子树中，并且一端为$p$的有一个$2$的最长链。注意，这个$f2$定义为一定有一个$2$，可以还没有$1$，即如果$f2[p]$有值，那么路径上一定会有$2$。

转移很好想，看代码就行了。

那如果整颗树都没有$1$和$2$呢？那就找点权最小的点就行了。

```cpp
#include <iostream>
#include <cstdio>
#define ll long long
using namespace std;
const int N=1e6+10;
const int INF=1e9+10;
int tot,mx=INF,my=1,ans1,ans2;//ans1表示全1的最长链。ans2表示有一个2的最长链 
int fir[N],val[N],f1[N],f2[N];
struct edge
{
	int to;
	int nxt;
}e[N*2];
inline void add(int x,int y)
{
	e[++tot].to=y; e[tot].nxt=fir[x]; fir[x]=tot;
	e[++tot].to=x; e[tot].nxt=fir[y]; fir[y]=tot;
}
inline void dfs(int p,int fa)
{
	if(val[p]==1) f1[p]=1;
	if(val[p]==2) f2[p]=1;
	for(int i=fir[p];i;i=e[i].nxt)
	{
		int q=e[i].to;
		if(q==fa) continue;
		dfs(q,p);
		ans1=max(ans1,f1[q]+f1[p]);
		ans2=max(ans2,max(f2[q]?f2[q]+f1[p]:-INF,f2[p]?f1[q]+f2[p]:-INF));//注意判断是否有值 
		if(val[p]==1)
		{
			f1[p]=max(f1[p],f1[q]+1);
			if(f2[q]) f2[p]=max(f2[p],f2[q]+1);//注意判断是否有值 
		}
		if(val[p]==2) f2[p]=max(f2[p],f1[q]+1);
	}
	ans1=max(ans1,f1[p]);
	ans2=max(ans2,f2[p]);
}
inline void update(int x,int y)
{
	if((ll)x*my<(ll)y*mx) mx=x,my=y;
}
inline int gcd(int x,int y)
{
	return (y?gcd(y,x%y):x);
}
int main()
{
	int n,a,b;
	scanf("%d",&n);
	for(int i=1;i<n;i++)
	{
		scanf("%d%d",&a,&b);
		add(a,b);
	}
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&val[i]);
		mx=min(mx,val[i]);//求最小点权 
	}
	dfs(1,0);
	if(ans1) update(1,ans1);
	if(ans2) update(2,ans2);
	printf("%d/%d\n",mx/gcd(mx,my),my/gcd(mx,my));
	return 0;
}
```

---


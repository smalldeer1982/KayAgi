# [YsOI2020] 计划

## 题目背景

相信大家已经知道了这样几个事实：  
- Ysuperman 是很有钱。

- Ysuperman 一直都很善于制定计划。

- Ysuperman 管理着一个幼儿园。

- Ysuperman 收藏了一些零食。

- 每一天，TA 可能会心血来潮地想要有计划地吃掉 TA 的零食。


## 题目描述

Ysuperman 现在有 $n$ 份零食，对**每份**零食而言，TA 每一天有 $P$ 的概率对 TA 的这份零食做出计划，TA 每做出一份计划后的 $T$ 天后，TA 将会将这一份零食给吃掉。需要特殊说明的是，如果在Ysuperman制定计划前已经对该份零食做出计划，则实际会按照**第一份计划的时间**将零食吃掉。

不幸的是，幼儿园内贪吃的小朋友会破坏这一计划。  幼儿园内有 $m$ 个小朋友，TA 们觊觎着 Ysuperman 的零食。对于**每份**零食，每天会有 $p_i$ 的概率被第 $i$ 个小朋友偷吃。如果这份零食在某位小朋友偷吃之前被吃掉了，那么相应地，这位小朋友就偷吃不了。**如果有一份零食在计划完成前被偷吃，那么，相关计划就无法实现了。**

现在 Ysuperman 要对 TA 的计划进行风险评估，TA 悬赏了 $114514pts$ ，这个项目在经过层层转包后来到了您的手上，现在已经算出了各概率在模意义下的值。经过各方协商，您如果解决了这个问题，您可以获得 $ 100pts $ 。您需要告诉 TA **Ysuperman 能期望吃掉多少份零食，以及 Ysuperman 的零食期望在多少天后被吃完** 。

**如果一份零食被某位小朋友吃掉了，那么这份零食就不属于Ysuperman了。**

需要注意的是，Ysuperman每天制定计划的时间在小朋友偷吃糖果**之前**。

Ysuperman 认为浮点数的精度误差太大，所以你只需要输出答案**对 $998244353$ 取模**的结果。

## 说明/提示

### 样例说明

#### 样例说明 $1$:

在取模前的其中一种可能情况为：
```cpp
5 8 11  
0.1  
0.1 0.2 0.3 0.4 0.5 0.6 0.7 1
```
该情况下，小朋友会在第一天中偷吃完所有的零食。

#### 样例说明 $2$:

在取模前的一种可能情况为：
```cpp
3 5 0  
1  
1 1 1 1 1
```

该情况下，Ysuperman 会在第一天计划并吃完所有的零食。

#### 样例说明 $3$:

在取模前的一种可能的情况为：

```cpp
2 2 0  
0.5  
0.5 0.5
```
在此情况下，答案为 $\dfrac{8}{7}$ 和 $\dfrac{80}{63}$。

由于解答过程较为复杂，所以请聪明的读者自行思考。


------------
### 数据范围

**如果您只答对了某个测试点两问中的任意一问，您可以获得这个测试点 $ 25\% $ 的分数。**

以下是致敬 $\text{NOI}$ 的部分分表格：
| 测试点编号 | $n$ | $m$ | $T$ | $P$ | 特殊性质 |
| :-----------: | -----------: | -----------: | -----------: | -----------: | :-----------: |
| 1 | $=1$ | $=1$ | $=0$ | 无其它约束 | 无 |
| 2 | $=1$ | $=10$ | $=1$ | $=1$ | $1$ |
| 3 | $=1$ | $\le100$ | $=227$ | $=1$ | $2$ |
| 4 | $\le 20$ | $\le 1000$ | $=4$ | 无其它约束 | 无 |
| 5 | $\le 100$ | $\le 1000$ | $=4$ | 无其它约束 | 无 |
| 6 | $\le 1000$ | $\le 1000$ | $=227$ | $=0$ | $1$ |
| 7 | $\le 100000$ | $\le 100000$ | $=233$ | $=1$ | $2$ |
| 8 | $\le1919820$ | $=114514$ | $=2333$ | $=0$ | $2$ |
| 9 | $\le1919820$ | $=114514$ | $=2333$ | $=0$ | $2$ |
| 10 | $=100000$ | $=100000$ | $=3$ | 无其它约束 | $2$ |
| 11 | $=114514$ | $=114514$ | $=3$ | 无其它约束 | 无 |
| 12 | $\le1919820$ | $=114514$ | $=0$ | 无其它约束 | $2$ |
| 13 | $\le 1919820$ | $=1$ | $\le 227$ | 无其它约束 | 无 |
| 14 | $\le 1919820$ | $\le114514$ | $\le 227$ | 无其它约束 | $2$ |
| 15 | $\le 1919820$ | $=1$ | $\le 500$ | $=1$ | 无 |
| 16 | $\le 1919820$ | $\le 114514$ | $\le 500$ | $=1$ | 无 |
| 17 | $\le 1919820$ | $\le 114514$ | $\le 500$ | $=1$ | 无 |
| 18 | $\le 1919820$ | $\le 114514$ | $=0$ | 无其它约束 | 无 |
| 19 | $\le 1919820$ | $\le 114514$ | $=0$ | 无其它约束 | 无 |
| 20 | $\le 100000$ | $\le 100000$ | $\le 500$ | 无其它约束 | $2$ |
| 21 | $\le 100000$ | $\le 100000$ | $\le 500$ | 无其它约束 | 无 |
| 22 | $\le 100000$ | $\le 100000$ | $\le 500$ | 无其它约束 | 无 |
| 23 | $\le 1919820$ | $\le 114514$ | $\le 2333$ | 无其它约束 | 无 |
| 24 | $\le 1919820$ | $\le 114514$ | $\le 2333$ | 无其它约束 | 无 |
| 25 | $\le 1919820$ | $\le 114514$ | $\le 2333$ | 无其它约束 | $2$ |

对于 $100\%$ 的数据，满足 $ 1\le n\le 1919820,1\le m \le 114514,0\le T \le 2333,0\le P< 998244353,1\le p_i<998244353$


特殊性质 $1$：存在一个 $i$ 使得$p_i=1$。

特殊性质 $2$：所有的 $p_i$ 都相等。

## 样例 #1

### 输入

```
5 8 11
13482572 
299473306 598946612 898419918 199648871 499122177 798595483 99824436 1```

### 输出

```
0 1```

## 样例 #2

### 输入

```
3 5 0
1
1 1 1 1 1```

### 输出

```
3 1```

## 样例 #3

### 输入

```
2 2 0
499122177
499122177 499122177```

### 输出

```
855638018 507044752```

## 样例 #4

### 输入

```
11 4 514
1919810
1919810 1919810 1919810 1919810```

### 输出

```
550831570 75142974```

## 样例 #5

### 输入

```
100000 20 227
2020
2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019```

### 输出

```
808786679 861511854```

# 题解

## 作者：lmAKf (赞：12)

~~大家好，我是队爷 Imakf，这道题我考场上有细节挂了，然而这与 Imakf 强没有任何关系，请大家支持 Imakf，一起喊 Imakf 666！~~

~~然而并不是官方题解（虽然我是队爷Imakf）~~

---

首先很多的小朋友没有意义，把没被小朋友吃掉的概率乘起来得到每天小饼干活下来的概率 $p$。

然后 $T$ 也没有意义，我们认为是第 $T+1$ 天这个 Ysuperman 大佬会来吃东西就好啦~

然后问题变为有 $n$ 个饼干，第 $1\sim T$ 天他有 $p$ 的概率被 A 吃掉，接下来 $T+1\sim \infty$ 天每天先让 B 以 $q$ 的概率吃掉，然后 A 以 $p$ 的概率吃掉。

第一问是计算 B 期望吃多少个，我们考虑前 T 天期望剩余多少个然后计算答案即可，第 $i$ 个饼干活下来的概率是 $\frac{1}{p^T}$ 所以饼干数期望为 $n\cdot \frac{1}{p^T}$，然后每个饼干没有被 A 吃掉就被 B 吃掉，被 B 吃掉的概率是 $q\times \sum_{i=0}^{\infty} r^i$，其中 $r$ 表示活下来的概率。

第二问是计算期望多少天吃完，我们视为最晚被吃掉的饼干，那么根据 $\min-\max$ 容斥，有：

$$E(\max(S))=\sum_{T\subseteq S,T\ne \varnothing} E(\min(T))\cdot (-1)^{|T|+1}$$

注意到饼干没有区别，所以我们枚举集合大小即可：

$$E(\max(S))=\sum_{k=1}^n \binom{n}{k}(-1)^{k+1}E(\min(T))$$

即我们需要计算集合 T 中最早被吃掉的饼干的期望时间，平凡的 trick 是认为是 $0\sim ...$ 这些时间没有被吃掉的概率和。

注意到贡献分为两端，对于 $0\sim T$ 天内，任意饼干都没有被吃的概率为 $p^{kx}$，对于第二段，活下来的概率设为 $f$，那么贡献为 $p^{Tx}\sum_{i=T+1}^{\infty} f^{(i-T)x}=p^{Tx}f^{x}\times \frac{1}{1-f^x}$，前者的贡献为 $\frac{1-p^{(T+1)x}}{1-p^x}$

加起来，直接计算即可啦~

$Code:$

```cpp
如果觉得推得烦了可以看一下代码，emmm确实有点细节吧

#include<bits/stdc++.h>
using namespace std ;
#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next )
#define rep( i, s, t ) for( register int i = (s); i <= (t); ++ i )
#define drep( i, s, t ) for( register int i = (t); i >= (s); -- i )
#define re register
#define int long long
int gi() {
	char cc = getchar() ; int cn = 0, flus = 1 ;
	while( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }
	while( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;
	return cn * flus ;
}
const int N = 2e6 + 5 ; 
const int P = 998244353 ; 
int n, m, T, p, q, fac[N], inv[N] ; 
int fpow( int x, int k ) {
	int ans = 1, base = x ; 
	while( k ) {
		if( k & 1 ) ans = ans * base % P ; 
		base = base * base % P, k >>= 1 ; 
	} return ans ;
}
int C( int x, int y ) {
	if( y > x ) return 0 ;
	return fac[x] * inv[y] % P * inv[x - y] % P ;
}
signed main()
{
	n = gi(), m = gi(), T = gi() ; 
	p = gi() ; int x ; q = 1 ; 
	rep( i, 1, m ) x = gi(), q = q * ( 1 - x + P ) % P ;
	if( ( q == 0 ) && ( T != 0 ) ) {
		puts("0 1") ; exit(0) ; 
	}
	int Tk = fpow( q, T ) * n % P ; 
	int ans1 = 0, ans2 = 0 ;
	int u = ( 1 - p + P ) * q % P ;
	if( p == 1 ) ans1 = Tk ; 
	else {
		ans1 = ( Tk * p ) % P * fpow( 1 - u + P, P - 2 ) % P ; 
	}
	inv[0] = fac[0] = 1 ; 
	rep( i, 1, n ) fac[i] = fac[i - 1] * i % P, inv[i] = fpow( fac[i], P - 2 ) ; 
	for( re int k = 1; k <= n; ++ k ) {
		int rp = C( n, k ) ; 
		if( ( k + 1 ) & 1 ) rp = ( P - rp ) % P ; 
		int tk = fpow( q, k ) ;
		int mS = fpow( tk, T ) ;
		int fk = fpow( u, k ) ; 
		int S1 = 1 ; 
		if( T ) {
			S1 = ( ( 1 - fpow( tk, T + 1 ) + P ) % P ) * fpow( 1 - tk + P, P - 2 ) % P ; 
		}
		int S2 = mS * fpow( 1 - fk + P, P - 2 ) % P * fk % P ;
		S1 = ( S1 + S2 ) % P ; 
		ans2 = ( ans2 + S1 * rp % P ) % P ;
	}
	ans1 %= P, ans2 %= P ; 
	printf("%lld %lld\n", ans1, ans2 ) ;
	return 0 ;
}
```


---

## 作者：Iratis (赞：3)

#### 前言

~~看了下剩余的两篇题解，可以说除了方向相同就没有共同点了。~~

#### 正文

这个题显然的融合，两问之间并无联系，所以分开解决。

在此之前做出一些定义：

- $ r=\prod\limits_{i=1}^{m}(1-p_i) $
- $ r'=\prod\limits_{i=0}^{m}(1-p_i)=r(1-p_0) $

形象地来看，对于每一天每个零食，$ r $ 即为所有小朋友都不会吃到它的概率，$ r' $ 即为 Ys 和小朋友都不会吃到它的概率。

首先来解决第一个问题：Ys 期望吃掉多少零食。

可以发现题目中的计划之后 $ T $ 天吃掉可以进行转化，变为前 $ T $ 天只有小朋友能吃，然后对于题目条件列出式子：

$$ Q_1=n\sum_{i\geq T+1}r^Tr'^{i-T-1}p_0 $$

好的，来看一下这个式子，$ n $ 个零食是一样的，所以先对于每个零食求解再乘上数量。第一项表示前 $ T $ 天这个零食不被小朋友吃掉的概率，第二项表示在接下来的 $ i-T-1 $ 天这个零食不被 Ys 和小朋友吃掉的概率，第三项表示 Ys 在第 $ i $ 天吃掉这个零食的概率。

$$ Q_1=np_0\sum_{i\geq T+1}(\frac {r'} {1-p_0})^Tr'^{i-T-1} $$

$$ Q_1=\frac {np_0} {(1-p_0)^T}\sum_{i\geq T+1}r'^{i-1} $$

$$ RHS=\sum_{i\geq T+1}r'^{i-1}=\sum_{i\geq T}r'^{i} $$

$$ RHS=\sum_{i\geq 0}r'^i-\sum_{i=0}^{T-1}r'^i=\frac 1 {1-r}-\frac {r^T-1} {r-1} $$

$$ Q_1= \frac {np_0} {(1-p_0)^T}RHS $$

至此，第一个问题已顺利解决，接着来看第二问：零食期望在几天后吃完。

这类全部完成的问题显然可以转化为第一次完成，使用 min-max 容斥：

$$ E[\max\{P\}]=\sum_{\varnothing\neq Q\subseteq P}(-1)^{|Q|-1}E[\min\{Q\}] $$

在本题中，$ \max $ 可理解为所有零食都被吃掉，$ \min $ 可理解为集合中某一个零食被吃掉。由于零食之间是不区分的，所以可以改写式子，使其只与集合大小有关（咋逐渐二项式反演了呢）：

$$ Q_2=\sum_{S=1}^n(-1)^{S-1}\binom n S g(S) $$

来看一下这个式子，$ \binom n i $ 表示子集个数，$ g(S) $ 是一个作用于整数 $ S $ 上的函数，表示 $ S $ 个零食，其中某一个零食被吃到的期望时刻。$ n $ 是可枚举范围内的，所以只需快速求出 $ g(S) $ 即可。

先做出一些定义：

- $ q=r^S $
- $ q'=r'^S=q(1-p_0)^S $

形象地来看，对于每天这 $ S $ 个零食，$ q $ 即为所有小朋友都不会吃到它的概率，$ q' $ 即为 Ys 和小朋友都不会吃到它的概率。

$$ g(S)=\sum_{i=1}^Tq^{i-1}(1-q)i+\sum_{i\geq T+1}q^Tq'^{i-T-1}(1-q')i $$

这个式子的前半部分表示前 $ T $ 天被吃掉的期望，即只有小朋友，后半部分表示 $ T+1 $ 天以后被吃掉的期望，即 Ys 也参与进来。令左式为 $ LHS $，右式为 $ RHS $。

$$ LHS=\sum_{i=1}^Tq^{i-1}(1-q)i=(1-q)\sum_{i=0}^{T-1}q^i(i+1) $$

$$ RHS=\sum_{i\geq T+1}q^Tq'^{i-T-1}(1-q')i $$

$$ RHS=\sum_{i\geq T+1}(\frac {q'} {(1-p_0)^S})^Tq'^{i-T-1}(1-q')i $$

$$ RHS=\frac {1-q'} {(1-p_0)^{ST}}\sum_{i\geq T}q'^i(i+1) $$

还是太复杂，令 $ X=\sum\limits_{i\geq T}q'^i(i+1) $

$$ RHS=\frac {1-q'} {(1-p_0)^{ST}}X $$

$$ X=\sum_{i\geq T}q'^i(i+1) $$

$$ X=\sum_{i\geq 0}q'^i(i+1)-\sum_{i=0}^{T-1}q'^i(i+1) $$

减号前半部分直接使用二项式定理扩展：推得 $ \frac 1 {(1-q')^2} $

然后我们发现后半部分有些眼熟，它的类似形式在上文求解 $ LHS $ 出现过，所以不妨定义出一个函数：

$$ R(n,x)=\sum_{i=0}^nx^i(i+1) $$

$$ xR(n,x)=\sum_{i=0}^nx^{i+1}(i+1)=\sum_{i=0}^nx^{i+1}(i+2)-\sum_{i=0}^nx^{i+1} $$

$$ xR(n,x)=\sum_{i=0}^{n+1}x^i(i+1)-\sum_{i=0}^{n+1}x^i $$

$$ xR(n,x)=R(n,x)-\sum_{i=0}^{n+1}x^i+x^{n+1}(n+2) $$

$$ (x-1)R(n,x)=x^{n+1}(n+2)-\frac {x^{n+2}-1} {x-1} $$

$$ R(n,x)=\frac {x^{n+1}(n+2)} {x-1}-\frac {x^{n+2}-1} {(x-1)^2} $$

$$ LHS=(1-q)R(T-1,q) $$

$$ RHS=\frac {1-q'} {(1-p_0)^{ST}}X,X=\frac 1 {(1-q')^2}-R(T-1,q') $$

$$ g(S)=LHS+RHS $$

$$ Q_2=\sum_{S=1}^n(-1)^{S-1}\binom n S g(S) $$

至此，整个问题已经基本解决，只需对特殊情况进行一些特判便可通过此题。

---

## 作者：clamee (赞：2)


部分分表格可能有点繁琐，但整理一下大概有以下几档。

### 8pts 好像实际上是 10pts
直接输出 ```0 1``` 即可

### 31pts

拿到这档分您需要做出第一问，并结合 8pts 做法。

**记 $t$ 表示计划制定到完成所需时间。即题面中的 "$T$"**

很容易发现每次被 $m$ 个小朋友之一取走零食的概率 $Q$ 为 $1-\prod_{i=1}^{m}(1-p_i)$。

那么每份零食被 Ysuperman 吃掉的概率为 $\sum_{i=t+1}^{+\infty}(1-Q)^{t}P(1-P-Q+PQ)^{i-t-1}$

利用等比数列求和公式化简得到第一问答案为  $n\times \frac{(1-Q)^t}{P+Q-PQ}$。

### 49pts

考虑 Min-max 容斥。

考虑第二问没有 Ysuperman 的限制。直接用 Min-max 容斥做即可。


我们记 $\max(S)$表示集合 $S$ 中元素最晚出现的时间。

那么 $\max(S)=\sum_{T\subset S}(-1)^{|T|+1}\min(T)$。

发现 $min(T)=\frac{1}{1-(1-P)^{|T|}}$。

### T比较小的数据

不知道怎么做，但不知道有没有什么神奇的做法所以就放了。

### m=1

~~几乎没用~~。

### 100pts

首先，我们可以	Min-max 容斥。

我们记 $\max(S)$表示集合 $S$ 中元素最晚出现的时间。

那么 $\max(S)=\sum_{T\subset S}(-1)^{|T|+1}\min(T)$。

观察到 T 集合大量重复，所以这一部分可以用组合数 $O(n)$ 快速算出来。

所以，我们现在只关心 $\min(T)$ 怎么求。

我们假定当前集合内每天有零食被吃的概率为 $p$，被做计划的概率为 $q$。计划的时长为 $t$。

我们将式子列出来可以得到:

${\min(T)=\sum_{i=1}^{t}p*(1-p)^{i-1}\cdot i+\sum_{i=t+1}^{+\infty}(1-p-q+pq)^{i-t-1}(1-p)^t(p+q-pq)\cdot i}$

考虑先化简前面一半。

令 $A=\sum_{i=1}^{t}(1-p)^{i-1}\cdot i$

比较简单：

$-((1-p)A-A)=pA=\frac{1-(1-p)^t}{p}-t(1-p)^t$

然后化简后半部分：

先改写一下柿子 $(p+q-pq)(1-p)^t\sum_{i=t+1}^{+\infty}(1-p-q+pq)^{i-t-1}\cdot i$

令 $a=1-p-q+pq,b=(p+q-pq)(1-p)^t$

柿子化为：

$b\sum_{i=t+1}^{+\infty}a^{i-t-1}\cdot i$

然后类似之前化一下得到：

$b(\frac{t}{1-a}+\frac{1}{(1-a)(1-a)})$

最后把两式相加就是这一部分的答案。

最后发现 $p=Q(1-Q)^{|T|-1},q=P(1-P)^{|T|-1}$

问题就迎刃而解了。

以下是因为~~长得很丑被 Imakf 强制格式化~~ 的std:

```cpp
#include <bits/stdc++.h>
using namespace std;
#define il inline
#define int long long
int n, m, T;
int P, p[200005], f[200005], a, b, c, d, s = 1, inv[2000005], jc[2000005], jcinv[2000005];
il int read() {
    int k = 1, re = 0;
    char ch = getchar();
    while (ch > '9' || ch < '0') {
        if (ch == '-')
            k = -1;
        ch = getchar();
    }
    while (ch <= '9' && ch >= '0') {
        re = re * 10 + ch - 48;
        ch = getchar();
    }
    return re * k;
}
il void write(int x) {
    if (x < 0)
        return write(-x), void();
    if (x <= 9)
        return putchar(x + 48), void();
    return write(x / 10), write(x % 10), void();
}
const int M = 998244353;
int qpow(int u, int v) {
    int ans = 1;
    while (v) {
        if (v & 1)
            ans = ans * u % M;
        u = u * u % M;
        v >>= 1;
    }
    return ans;
}
void init() {
    inv[1] = 1;
    jc[0] = jcinv[0] = 1ll;
    for (int i = 2; i <= 2000000ll; i++) inv[i] = (M - M / i) * inv[M % i] % M;
    for (int i = 1; i <= 2000000ll; i++) jc[i] = jc[i - 1] * i % M, jcinv[i] = jcinv[i - 1] * inv[i] % M;
}
int sol(int p, int q) {
    int re = 0ll;
    int t = qpow((1ll - p + M) % M, T);
    re = (((1ll - t + M) * qpow(p, M - 2) - t * T) % M + M) % M;
    
    int a = ((1ll - p - q + p * q) % M + M) % M, 
    	B = ((p + q - p * q) % M + M) * t % M, now = 0ll;
    
    int qwq = qpow((1ll - a + M) % M, M - 2);
    now = (now + qwq * qwq + T * qwq) % M;
    re = (re + now * B) % M;
    return (re % M + M) % M;
}
int C(int n, int m) { return jc[n] * jcinv[m] % M * jcinv[n - m] % M; }
signed main() {
    n = read();
    m = read();
    T = read();
    P = read();
    for (int i = 1; i <= m; i++) p[i] = read(), p[i] = (1 - p[i] + M) % M, s = (s * p[i]) % M;
    init();
    a = P;
    b = (1 - s + M) % M;
    int ans = 1 * qpow((a + b - a * b % M + M) % M, M - 2);
    ans = ans * (a * qpow((1 - b + M) % M, T) % M) % M;
    write(ans * n % M);
    putchar(' ');
    int op = 1ll;
    ans = 0ll;
    int now1 = P, now2 = s;
    for (int i = 1; i <= n; i++) {
        ans += op * C(n, i) * sol((1 - s + M) % M, (P + M) % M) % M;
        s = s * now2 % M;
        P = (P + (1 - P) * now1 % M + M) % M;
        op = -op;
        ans = (ans % M + M) % M;
    }
    write(ans);
}
```


---


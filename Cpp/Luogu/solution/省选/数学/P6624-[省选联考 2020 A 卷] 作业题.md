# [省选联考 2020 A 卷] 作业题

## 题目描述

小 W 刚刚在离散数学课学习了生成树的知识：一个无向图 $G=(V,E)$ 的生成树 $T$ 为边集 $E$ 的一个大小为 $|V|-1$ 的子集，且保证 $T$ 的生成子图在 $G$ 中连通。

小 W 在做今天的作业时被这样一道题目难住了：

给定一个 $n$ 个顶点 $m$ 条边（点和边都从 $1$ 开始编号）的无向图 $G$，保证图中无重边和无自环。每一条边有一个正整数边权 $w_i$，对于一棵 $G$ 的生成树 $T$，定义 $T$ 的价值为：$T$ 所包含的边的边权的最大公约数乘以边权之和，即：

$$
val(T)=\left(\sum\limits_{i=1}^{n-1} w_{e_i}\right) \times \gcd(w_{e_1},w_{e_2},\dots,w_{e_{n-1}})
$$

其中 $e_1,e_2,\dots,e_{n-1}$ 为 $T$ 包含的边的编号。

小 W 需要求出 $G$ 的所有生成树 $T$ 的价值之和，他做了很久也没做出来，请你帮帮他。由于答案可能很大，你只需要给出答案对 $998244353$ 取模后的结果。

## 说明/提示

【样例解释 $1$】

$G$ 共有三棵生成树：

$T_1=\{(1,2),(2,3)\}$，价值为 $10\times 2=20$。

$T_2=\{(1,2),(1,3)\}$，价值为 $16\times 4=64$。

$T_3=\{(1,3),(2,3)\}$，价值为 $18\times 6=108$。

总和为 $192$。

【数据规模】

$10\%$ 的数据满足：$m\leq 15$。

另有 $20\%$ 的数据满足：$m \leq n$。

另有 $20\%$ 的数据满足：$w_i$ 均相同。

另有 $20\%$ 的数据满足：$w_i$ 均为质数。

$100\%$ 的数据满足：$1\leq n\leq 30, 1\leq m \leq \frac {n(n-1)}{2}, 1\leq w_i \leq 152501$。

## 样例 #1

### 输入

```
3 3
1 2 4
2 3 6
1 3 12```

### 输出

```
192```

# 题解

## 作者：Froggy (赞：43)

$2020.6.23\ \ \mathrm{update}:$ 加入代码。

---

此次省选我唯一切掉的题目（并且在不 FST 的情况下）（捂脸

---



首先这题非常的 “二合一”。前面的化式子和后面矩阵树定理的使用基本上割裂开了，那我也就分开来讲。

## Part 1：化简式子

后面一坨 $\gcd$ 需要反演掉，比较懒的话直接套这个众所周知的式子就行：

$$\varphi*1=\mathrm{id}$$

然后把 $\varphi$ 提到前面来，方便之后使用矩阵树定理。

具体推式子过程如下：

$$\begin{aligned}
\text{answer}&=\sum\limits_{T}\left(\sum\limits_{i=1}^{n-1}w_{e_i}\right)\times\gcd(w_{e_1},\cdots,w_{e_{n-1}}) \\

&=\sum\limits_{T}\left(\sum\limits_{i=1}^{n-1}w_{e_i}\right)\times\sum\limits_{d\mid w_{e_1},\cdots,d\mid w_{e_{n-1}}}\varphi(d) \\

&=\sum\limits_{d=1}^{mx}\varphi(d)\sum\limits_{T\atop d\mid w_{e_1},\cdots,d\mid w_{e_{n-1}}}\left(\sum\limits_{i=1}^{n-1}w_{e_i}\right)
\end{aligned}$$


（其中 $mx$ 为 $w_i$ 的最大值。）

---

## Part 2：矩阵树定理的使用

外层枚举 $d$，里层那一坨就需要矩阵树定理来处理了。

求所有生成树的边权和是被出烂的老经典题了。。。

首先考虑 $w_i$ 都相同的情况：直接套模板即可，最后答案乘上 $w_i$ 完事。

有不同的情况就先考虑一种最裸的做法：枚举一条边然后求包含这条边的生成树个数。

有木有方法把所有边的答案的和经过求一次行列式就全部算出来？

还真有，矩阵每个位置放个一次函数（一次多项式）即可。

一条边的贡献珂以写成 $w_ix+1$，最后答案就是行列式的一次项系数。

撕烤一下为什么？

答案实际上是求 钦定一条边之后的生成树个数$\times$这条边的边权 之和，那么答案里被乘上一次项系数的边就是被钦定的边。

下面就是一下多项式操作了：$a+bx$ 和 $c+dx$ 的四则运算规则

加减就直接对应项项加/减，不说了。

乘法：$(a+bx)(c+dx)=ac+(ad+bc)x$。

除法：$\dfrac{a+bx}{c+dx}=\dfrac{a}{c}+\dfrac{bc-ad}{c^2}x$

对于枚举的每个 $d$ 都求一遍行列式的话复杂度是 $\mathcal{O}(n^3mx)$，不知道能不能过。

不过珂以优化，只对可选边数大于等于 $n-1$ 的 $d$ 求行列式即可，这样复杂度就优化到了$\mathcal{O}(n^2\sum\sigma_0(w_i))$
，上界是 $144\times n^4$，实际完全跑不满。

注：这个 $n^2\sum\sigma_0(w_i)$ 其实就是 $n^3\frac{\sum\sigma_0(w_i)}{n-1}$。

---

***code:***

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
const int mod=998244353;
#define N 33
#define M 200020
inline int read(){
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<1)+(x<<3)+c-'0';
		c=getchar();
	}
	return x*f;
}
typedef pair<int,int> pii;
int n,m,ans,h[M];
int qpow(int a,int b){
	int ans=1;
	while(b){
		if(b&1)ans=1LL*ans*a%mod;
		a=1LL*a*a%mod;
		b>>=1;
	}
	return ans;
}
pii g[N][N]; //(常数项系数,一次项系数)
pii operator +(const pii a,const pii b){
	return make_pair((a.first+b.first)%mod,(a.second+b.second)%mod);
}
pii operator -(const pii a,const pii b){
	return make_pair((a.first-b.first+mod)%mod,(a.second-b.second+mod)%mod);
}
pii operator *(const pii a,const pii b){
	return make_pair(1LL*a.first*b.first%mod,(1LL*a.first*b.second+1LL*a.second*b.first)%mod);
}
pii operator /(const pii a,const pii b){
	int inv=qpow(b.first,mod-2);
	return make_pair(1LL*a.first*inv%mod,(1LL*a.second*b.first%mod-1LL*a.first*b.second%mod+mod)%mod*inv%mod*inv%mod);
}
int x[N*N],y[N*N],w[N*N],mx;
int p[M],pn,phi[M];
bool ntp[M];
void init(int n){
	phi[1]=ntp[1]=1;
	for(int i=2;i<=n;++i){
		if(!ntp[i])p[++pn]=i,phi[i]=i-1;
		for(int j=1;j<=pn&&p[j]*i<=n;++j){
			ntp[p[j]*i]=true;
			if(i%p[j]==0){
				phi[p[j]*i]=phi[i]*p[j];
				break;
			}
			phi[p[j]*i]=phi[i]*(p[j]-1);
		}
	}
}
pii Guass(int n){
	pii ans=make_pair(1,0);
	bool rev=false;
	for(int i=1;i<=n;++i){
		if(!g[i][i].first){
			for(int j=i+1;j<=n;++j){
				if(g[j][i].first){
					rev^=1;
					swap(g[i],g[j]);
					break;
				}
			}
		}
		pii inv=make_pair(1,0)/g[i][i];
		for(int j=i+1;j<=n;++j){
			pii div=g[j][i]*inv;
			for(int k=i;k<=n;++k){
				g[j][k]=g[j][k]-div*g[i][k];
			}
		}
		ans=ans*g[i][i];
	}
	return rev?make_pair(0,0)-ans:ans;
}
int Solve(int t){
	memset(g,0,sizeof(g));
	for(int i=1;i<=m;++i){
		if(w[i]%t)continue;
		g[x[i]][x[i]]=g[x[i]][x[i]]+make_pair(1,w[i]);
		g[y[i]][y[i]]=g[y[i]][y[i]]+make_pair(1,w[i]);
		g[x[i]][y[i]]=g[x[i]][y[i]]-make_pair(1,w[i]);
		g[y[i]][x[i]]=g[y[i]][x[i]]-make_pair(1,w[i]);
	}
	return Guass(n-1).second;
}
void check(int x){
	for(int i=1;i*i<=x;++i){
		if(x%i==0){
			++h[i];
			if(i*i!=x)++h[x/i];
		}
	}
}
int main(){
	freopen("count.in","r",stdin);
	freopen("count.out","w",stdout);
	n=read(),m=read();
	for(int i=1;i<=m;++i){
		x[i]=read(),y[i]=read(),w[i]=read();
		check(w[i]);
		mx=max(mx,w[i]);
	}
	init(mx);
	for(int i=1;i<=mx;++i){
		if(h[i]<n-1)continue;
		ans=(ans+1LL*phi[i]*Solve(i))%mod;
	}
	cout<<ans<<endl;
	return 0;
}
```

[*Froggy's blog*](https://www.luogu.org/blog/1445353309froggy/)

#### 呱!!




---

## 作者：1saunoya (赞：23)


这一篇会详细解释吧。


看到这个柿子

$val(T) = {\large{\left(\sum_{i=1}^{n-1} w_{e_i}\right)}} \times \gcd(w_{e1}, w_{e2},...,w_{e_{n-1}})$

首先考虑欧拉反演。

$x = \sum_{d|x} \varphi(d)$


然后原式变成

$val(T) = {\large{\left(\sum_{i=1}^{n-1} w_{e_i}\right)}} \times \sum_{d| \gcd(w_{e1}, w_{e2},...,w_{e_{n-1}})} \varphi(d)$

枚举 $d$

$\sum_{d} \varphi(d) \times \sum_T  {\large{\left(\sum_{i=1}^{n-1} w_{e_i}\right)}}$


然后我们只关心这个部分 $\sum_T  {\large{\left(\sum_{i=1}^{n-1} w_{e_i}\right)}}$ 怎么算。

众所周知普通的矩阵树定理只适用于求 $\sum_T \prod (w_{e_1}, w_{e_2}, ..., w_{e_{n-1}})$

（所以如果想求生成树个数直接令所有的边 $w=1$）

然后这题的重要套路就出来了。

我们定义一个 $1+w_ix$

$\prod_{i} (1+w_ix)$ 的一次项系数就是这个 $\sum$ 的值。

这样的话其他项就没什么作用了。

意思是我们只需要维护一个常数项和一次项就够了。

然后变成了多项式操作。

```cpp
// x 是常数项， y 是一次项系数。
inline pair operator+(pair a, pair b) {
  static pair res;
  res.x = (a.x + b.x) % MOD;
  res.y = (a.y + b.y) % MOD;
  return res;
}
inline pair operator-(pair a, pair b) {
  static pair res;
  res.x = (a.x - b.x + MOD) % MOD;
  res.y = (a.y - b.y + MOD) % MOD;
  return res;
}
inline pair operator*(pair a, pair b) {
  static pair res;
  res.x = 1ll * a.x * b.x % MOD;
  res.y = (1ll * a.x * b.y + 1ll * a.y * b.x) % MOD;
  return res;
}
inline pair operator/(pair a, pair b) {
  static pair res;
  int iv = qpow(b.x, MOD - 2);
  res.x = 1ll * a.x * iv % MOD;
  res.y = ((1ll * a.y * b.x - 1ll * a.x * b.y) % MOD + MOD) % MOD * iv % MOD * iv % MOD;
  return res;
}
```

我们发现这个加法和减法都很 simple。

这个乘法直接展开就行了，这个除法的话有点难理解。

$\frac{a + bx}{c + dx} = \frac{a}{c} + \frac{bc - ad}{c^2}x$

然后常数项和这个都出来了。
这个怎么求出来的呢？~~多项式求逆~~

我们先求出来 $\frac{1}{c+dx}$，然后再乘起来。

令 $C+Dx = \frac{1}{c+dx}$。

即 $(C+Dx)(c+dx) = 1 (\mod x^2)$

$C \times c = 1$ 即 $C = \frac{1}{c}$

因为 $Cdx + cDx = 0$

$\frac{d}{c} + cD = 0$，$D = -\frac{d}{c^2}$


然后 $(a+bx) (C+Dx) = (a+bx)\frac{1}{c+dx} =  \frac{a}{c} + \frac{bc - ad}{c^2}x$

就没了。

```cpp
#include <bits/stdc++.h>
const int MOD = 998244353;
inline int qpow(int x, int y) {
  int res = 1;
  while (y) {
    if (y & 1) {
      res = 1ll * res * x % MOD;
    }
    x = 1ll * x * x % MOD;
    y >>= 1;
  }
  return res;
}

struct pair {
  int x, y;
  pair() { x = y = 0; }
  pair(int _x, int _y) { x = _x, y = _y; }
};
inline pair operator+(pair a, pair b) {
  static pair res;
  res.x = (a.x + b.x) % MOD;
  res.y = (a.y + b.y) % MOD;
  return res;
}
inline pair operator-(pair a, pair b) {
  static pair res;
  res.x = (a.x - b.x + MOD) % MOD;
  res.y = (a.y - b.y + MOD) % MOD;
  return res;
}
inline pair operator*(pair a, pair b) {
  static pair res;
  res.x = 1ll * a.x * b.x % MOD;
  res.y = (1ll * a.x * b.y + 1ll * a.y * b.x) % MOD;
  return res;
}
inline pair operator/(pair a, pair b) {
  static pair res;
  int iv = qpow(b.x, MOD - 2);
  res.x = 1ll * a.x * iv % MOD;
  res.y = ((1ll * a.y * b.x - 1ll * a.x * b.y) % MOD + MOD) % MOD * iv % MOD * iv % MOD;
  return res;
}

inline int solve(std::vector<std::vector<pair>> g, int n) {
  pair ans = pair(1, 0);
  bool rev = false;
  for (int i = 0; i < n; i++) {
    if (g[i][i].x == 0) {
      for (int j = i + 1; j < n; j++) {
        if (g[j][i].x) {
          rev ^= 1;
          swap(g[i], g[j]);
          break;
        }
      }
    }
    pair inv = pair(1, 0) / g[i][i];
    for (int j = i + 1; j < n; j++) {
      pair div = g[j][i] * inv;
      for (int k = i; k < n; k++) {
        g[j][k] = g[j][k] - div * g[i][k];
      }
    }
  }
  for (int i = 0; i < n; i++) {
    ans = ans * g[i][i];
  }
  if (rev) {
    return (pair(0, 0) - ans).y;
  } else {
    return ans.y;
  }
}

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int n, m;
  std::cin >> n >> m;
  std::vector<int> x(m), y(m), w(m);
  int MAX = 0;
  for (int i = 0; i < m; i++) {
    std::cin >> x[i] >> y[i] >> w[i];
    --x[i], --y[i];
    MAX = std::max(MAX, w[i]);
  }
  MAX++;
  std::vector<int> divisor_cnt(MAX, 0);
  auto getDivisor = [&](int x) {
    for (int i = 1; i <= sqrt(x); i++) {
      if (x % i == 0) {
        ++divisor_cnt[i];
        if (i * i != x) {
          ++divisor_cnt[x / i];
        }
      }
    }
  };
  for (int i = 0; i < m; i++) {
    getDivisor(w[i]);
  }
  std::vector<int> phi(MAX, 0);
  phi[1] = 1;
  for (int i = 2; i < MAX; i++) {
    if (!phi[i]) {
      phi[i] = i - 1;
      for (int j = i * 2; j < MAX; j += i) {
        if (!phi[j]) {
          phi[j] = j;
        }
        phi[j] = phi[j] / i * (i - 1);
      }
    }
  }
  long long ans = 0;
  auto getmat = [&](int div) {
    std::vector<std::vector<pair>> g(n, std::vector<pair>(n));
    for (int i = 0; i < m; i++) {
      if (w[i] % div) {
        continue;
      } else {
        int u = x[i], v = y[i];
        g[u][u] = g[u][u] + pair(1, w[i]);
        g[v][v] = g[v][v] + pair(1, w[i]);
        g[u][v] = g[u][v] - pair(1, w[i]);
        g[v][u] = g[v][u] - pair(1, w[i]);
      }
    }
    return g;
  };
  for (int i = 1; i < MAX; i++) {
    if (divisor_cnt[i] < n - 1) {
      continue;
    } else {
      ans = (ans + 1ll * phi[i] * solve(getmat(i), n - 1)) % MOD;
    }
  }
  std::cout << ans << '\n';
  return 0;
}
```


---

## 作者：s_r_f (赞：9)


$upd:$ 经鱼鱼提醒$,$修改了一处有歧义的表述$.$


贴一个[hack数据](https://www.luogu.com.cn/problem/U120185),可以看看$O(n^3m\times d)$的暴力会不会$T,$不保证能卡掉

记 $ans_d$ 为 边权 $gcd$ 是 $d$ 的倍数的所有生成树的边权和的和 $.$

记 $sum_d$ 为 边权 $gcd$ 正好等于 $d$ 的所有生成树的边权和的和 $.$

如果计算出了所有$ans_d$ $,$那么我们就可以在 $O(n\ln n)$的复杂度内 计算出$sum_d.$

也可以反演$,$但是这个不在复杂度上$.$

考虑如何求出$ans_d.$

枚举每个$d,$考虑求只保留$w_i$是$d$的倍数的边$,$求出所有生成树的边权和的和$.$

首先除去图不连通的情况$.$可以证明剩下的情况总数只有 $O(n \times d)$ 种 $,$ 其中 $d$ 为值域内的数中最大的约数个数 $,$ 其值为 $144.$

然后对于一条边 $,$ 我们把边权 $w$ 记成一个一次式 $,$ $1+wx.$

然后你会发现对这个求矩阵树定理 $,$ 取答案的一次项系数 $,$ 就可以正确求出答案 $.$

复杂度 $O(n^4d).$

---

关于如何对一次函数求矩阵树定理$?$

难点在于求逆元 $.$

但是你会发现 , $(1-ax)^{-1} \equiv 1+ax \pmod{x^2},$ 那么求逆的问题就解决了 $.$

---

关于什么是 $O(n\ln n)$ 的容斥 $:$ ~~如果不会建议重学容斥~~

从大到小求答案$,$枚举倍数容斥掉就可以了 $.$

---

考场代码 $:$
```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
const int P = 998244353,N = 32;
inline int power(int x,int y){
	static int r; r = 1; while (y){ if (y&1) r = (LL)r * x % P; x = (LL)x * x % P; y >>= 1; } return r;
}
inline void upd(int &x,int y){ x = (x+y>=P)?(x+y-P):(x+y); }
struct Function{
	int a0,a1;
	Function(int a00 = 0,int a11 = 0){ a0 = a00,a1 = a11; }
};
Function operator + (Function A,Function B){
	static Function tmp; tmp = A,upd(tmp.a0,B.a0),upd(tmp.a1,B.a1);
	return tmp;
}
Function operator - (Function A,Function B){
	static Function tmp; tmp = A,upd(tmp.a0,P-B.a0),upd(tmp.a1,P-B.a1);
	return tmp;
}
Function operator * (Function A,Function B){
	return Function((LL)A.a0 * B.a0 % P,((LL)A.a1 * B.a0 + (LL)A.a0 * B.a1)%P);
}
Function Inv(Function X){
	static int w;
	if (X.a0 != 1){
		w = power(X.a0,P-2); w = (LL)w * w % P;
		X.a0 = (LL)X.a0 * w % P; X.a1 = (LL)X.a1 * w % P;
	} 
	X.a1 = X.a1 ? (P-X.a1) : 0;
	return X;
}
struct Union_Find_Set{
	int n,fa[N],siz;
	inline void init(){ for (int i = 1; i <= n; ++i) fa[i] = i; siz = n; }
	inline int Find(int x){ return x == fa[x] ? x : (fa[x] = Find(fa[x])); }
	inline void Merge(int x,int y){
	x = Find(x),y = Find(y);
	if (x!=y) fa[x]=y,--siz;
	}
	inline bool ok(){ return siz == 1; }
}S;
int mxw;
int n,m,ex[N*N],ey[N*N],ew[N*N];
Function d[N][N],g[N][N],A[N][N]; int G[N][N];
int solve(){
	Function Ans = Function(1,0),tmp;
	int i,j,k,x;
	for (i = 2; i <= n; ++i){
		x = -1;
		for (j = i; j <= n; ++j) if (A[j][i].a0){ x = j; break; }
		if (x == -1) return 0;
		if (x != i) for (j = i; j <= n; ++j) swap(A[i][j],A[x][j]);
		Ans = Ans * A[i][i],tmp = Inv(A[i][i]); for (j = i; j <= n; ++j) A[i][j] = A[i][j] * tmp;
		for (j = i+1; j <= n; ++j)
		for (tmp = A[j][i],k = i; k <= n; ++k) A[j][k] = (A[j][k] - tmp * A[i][k]);
	}
	return Ans.a1;
}
inline int work(int dd){
	int i,j;
	S.init(); static Function t;
	for (i = 1; i <= n; ++i) for (j = i+1; j <= n; ++j) if (G[i][j] && G[i][j] % dd == 0) S.Merge(i,j);
	if (!S.ok()) return 0;
	for (i = 1; i <= n; ++i) for (j = 1; j <= n; ++j) d[i][j] = g[i][j] = Function(0,0);
	for (i = 1; i <= n; ++i) for (j = i+1; j <= n; ++j) if (G[i][j] && G[i][j] % dd == 0)
		g[i][j] = g[j][i] = t = Function(1,G[i][j]),d[i][i] = d[i][i] + t,d[j][j] = d[j][j] + t;
	for (i = 1; i <= n; ++i) for (j = 1; j <= n; ++j) A[i][j] = d[i][j] - g[i][j];
	return solve();
}

int ans[200000]; bool ok[200000];
int main(){
	int i,j;
	freopen("count.in","r",stdin); freopen("count.out","w",stdout);
	cin >> n >> m;
	mxw = 1; S.n = n;
	for (i = 1; i <= m; ++i) cin >> ex[i] >> ey[i] >> ew[i],mxw = max(mxw,ew[i]);
	for (i = 1; i <= m; ++i) G[ex[i]][ey[i]] = ew[i],G[ey[i]][ex[i]] = ew[i];
	for (i = 1; i <= m; ++i) ok[ew[i]] = 1;
	for (i = mxw; i >= 1; --i) if (!ok[i]) for (j = i<<1; j <= mxw; j += i) if (ok[j]){ ok[i] = 1; break; }
	for (i = 1; i <= mxw; ++i) if (ok[i]) ans[i] = work(i);
	int Ans = 0;
	for (i = mxw; i ; --i){
		for (j = i + i; j <= mxw; j += i) ans[i] = (ans[i] - ans[j] + P) % P;
		Ans = (Ans + (LL)ans[i] * i) % P;
	}
	cout << Ans << '\n';
	return 0;
}
```

---

## 作者：duyi (赞：7)

[更好的阅读体验](https://www.cnblogs.com/dysyn1314/p/13209932.html)

[题目链接](https://loj.ac/problem/3304)

> 前置知识：(1) 矩阵树定理。(2) 多项式四则运算（加、减、乘、求逆（牛顿迭代））。
>
> 网上的介绍很多。这里就不细讲了。

首先要把这个$\gcd$给拆掉，才能用我们熟悉的“矩阵树定理”等一系列方法来解题。

众所周知，$\sum_{d|x}\varphi(d)=x$。本题中，我们就可以利用这个$\varphi$来拆掉$\gcd$。具体来说，如果我们用$T$来表示枚举的一棵树，$e_1,e_2,\dots ,e_{n-1}$来表示$T$包含的边的编号，那么首先，答案可以表示为：
$$
\sum_{T}\left(\sum_{i=1}^{n-1}w_{e_i}\right)\times\gcd(w_{e_1},w_{e_2},\dots,w_{e_{n-1}})
$$
我们把$\gcd(w_{e_1},w_{e_2},\dots,w_{e_{n-1}})$用上述的公式带入，得到：
$$
=\sum_{T}\left(\sum_{i=1}^{n-1}w_{e_i}\right)\times\left(\sum_{d|\gcd(w_{e_1},w_{e_2},\dots,w_{e_{n-1}})}\varphi(d)\right)
$$
然后就可以把这个$d$，放到前面来，得到：
$$
=\sum_{d=1}^{W}\varphi(d)\times\left(\sum_{\begin{gather*}T\\d|w_{e_1},\dots ,d|w_{e_{n-1}}\end{gather*}}\sum_{i=1}^{n-1}w_{e_i}\right)
$$
其中，$W$表示最大的权值。后面括号里的部分，相当于【所有【$w_{e_i}$是$d$的倍数的边】组成的子图】的所有生成树的边权和。

普通的**矩阵树定理**，可以用来求所有生成树的**边权积**之和。其中最为大家所熟知的应用，就是当所有边权都为$1$时，就相当于是求生成树的数量，也就是**生成树计数问题**。它的实现，就是求矩阵行列式，因为需要用到高斯消元，所以时间复杂度是$O(n^3)$的。

但是本题中，要求的是**边权和**，而不是“边权积之和”。一种朴素的想法是考虑每一条边的贡献，也就是求【包含这条边的生成树数量】。它又等于【原图的生成树数量】减去【原图去掉这条边后的生成树数量】。对每条边都求一次【原图去掉这条边后的生成树数量】，时间复杂度$O(mn^3)$。因为外层还要枚举$d$，所以总时间复杂度$O(W\cdot mn^3)$，无法通过本题。

求所有生成树的边权和，其实有更好的方法。我们把每条边的边权，看做一个**多项式**：$(1+w_{e_i}x)$。其中，$x$不是任何具体的数，它只是一个符号，表示多项式的“一次项”。那么，一个生成树，它的边权之**积**的“一次项”前的系数，就是这颗生成树的边权**和**（这可以根据多项式乘法的定义来理解）。

如此以来，求所有生成树的**边权和**的问题，当我们把边权换成这样一个多项式后，就转化为了求所有生成树的**边权积**之和的问题。只不过，现在新的边权，不再是一个数，而是一个多项式。所以我们只需要定义出多项式的四则运算，就可以直接用矩阵树定理求解了。另外，我们只关心多项式的“一次项”系数，所以更高的项可以舍去。换句话说，所有的多项式运算，可以在$\bmod x^2$意义下进行。那么把多项式定义为一个$\texttt{pair}$就可以了。

多项式的加、减、乘运算都比较简单。不了解的可以看如下代码：

```cpp
typedef pair<int,int> pii;
#define fi first
#define se second
//为了便于理解，这里就不取模了
pii operator+(const pii& a,const pii& b){
	return mk(a.fi+b.fi,a.se+b.se);
}
pii operator-(const pii& a,const pii& b){
	return mk(a.fi-b.fi,a.se-b.se);
}
pii operator*(const pii& a,const pii& b){
	return mk(a.fi*b.fi,a.se*b.fi+b.se*a.fi);
}
```

多项式的除法，因为在$\bmod x^2$意义下进行，所以只需要求出多项式$\bmod x^2$意义下的逆即可。用经典的倍增法。设原多项式为$A(x)$，要求的、它的逆为$F(x)=A^{-1}(x)\pmod{x^n}$。如果已经求出了$F_0(x)=A^{-1}(x)\pmod{x^{\lceil\frac{n}{2}\rceil}}$，那么：
$$
F(x)=2F_0(x)-F_0^2(x)A(x)\pmod{x^{n}}
$$
对本题来说，我们就不需要递归了。先求出常数项，也就是求逆元。然后把常数项作为$F_0(x)$带入上式即可。具体的代码：

```cpp
pii inv(const pii& a){
	int t=pow_mod(a.fi,MOD-2);
	return mk(2*t,0)-mk(t,0)*mk(t,0)*a;
}
pii operator/(const pii& a,const pii& b){
	return a*inv(b);
}
```

还有一个小细节是，高斯消元求行列式的时候，如果当前行的（要作为被除数）的这个多项式，常数项为$0$，上述的求逆的方法就不管用了，因为$0$没有逆元。这种情况下，我们首先考虑，在它下面，找一个常数项不为$0$的行，与它交换（根据行列式的性质，两行交换后行列式要变号，也就是$res:=-res$）。如果它下面所有行常数项都为$0$，那对这一列，我们就不需要管常数项了，直接拿一次项消就行（就把每一项都看成普通的数而不是多项式就行）。

至此，所有四则运算都可以$O(1)$实现，所以做一次高斯消元，求出行列式的复杂度就是$O(n^3)$的。外层还要枚举$d$，所以总时间复杂度$O(Wn^3)$。这个复杂度仍然无法通过本题，我们还需要再对$W$这部分做一些优化。

发现对于一个$d$。如果“是它的倍数”的边，数量小于$n-1$条，那必不可能有任何生成树。特判这一情况后，我们惊喜地发现，复杂度降为：$O(\frac{\sum\sigma_0(w_{e_i})}{n-1}\cdot n^3)=O(n^2\sum\sigma_0(w_{e_i}))$。其中$\sigma_0(x)$表示$x$的约数数量。这个复杂度很好理解，因为每个$d$，要作为约数出现$n-1$次才被计算，所以被计算到的$d$最多只有$\frac{\sum\sigma_0(w_{e_i})}{n-1}$个。再看这个复杂度，一个小于等于$W$的数，约数个数是$O(\sqrt{W})$级别的，又因为边数是$O(n^2)$级别的，所以总复杂度就是$O(n^4\sqrt{W})$。事实上，这个$\sqrt{W}$只是一个理论上限，在本题的数据范围下，打表发现，$w$的约数个数最多为$144$。足以通过本题。

参考代码（[在LOJ查看](https://loj.ac/submission/849167)）：

```cpp
//problem:LOJ3304
#include <bits/stdc++.h>
using namespace std;

#define pb push_back
#define mk make_pair
#define lob lower_bound
#define upb upper_bound
#define fi first
#define se second
#define SZ(x) ((int)(x).size())

typedef unsigned int uint;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pii;

const int MOD=998244353;
inline int mod1(int x){return x<MOD?x:x-MOD;}
inline int mod2(int x){return x<0?x+MOD:x;}
inline void add(int& x,int y){x=mod1(x+y);}
inline void sub(int& x,int y){x=mod2(x-y);}
inline int pow_mod(int x,int i){int y=1;while(i){if(i&1)y=(ll)y*x%MOD;x=(ll)x*x%MOD;i>>=1;}return y;}

pii operator+(const pii& lhs,const pii& rhs){
	return mk(mod1(lhs.fi+rhs.fi),mod1(lhs.se+rhs.se));
}
pii operator-(const pii& lhs,const pii& rhs){
	return mk(mod2(lhs.fi-rhs.fi),mod2(lhs.se-rhs.se));
}
pii operator*(const pii& lhs,const pii& rhs){
	return mk((ll)lhs.fi*rhs.fi%MOD,((ll)lhs.se*rhs.fi+(ll)rhs.se*lhs.fi)%MOD);
}
pii inv(const pii& a){
	//assert(a.fi!=0);
	int t=pow_mod(a.fi,MOD-2);
	return mk(2LL*t%MOD,0)-mk(t,0)*mk(t,0)*a;//牛顿迭代
}
pii operator/(const pii& lhs,const pii& rhs){
	return lhs*inv(rhs);
}
pii operator-(const pii& rhs){
	return mk(mod2(-rhs.fi),mod2(-rhs.se));
}//负号
pii& operator+=(pii& lhs,const pii& rhs){
	lhs=lhs+rhs;
	return lhs;
}
pii& operator-=(pii& lhs,const pii& rhs){
	lhs=lhs-rhs;
	return lhs;
}
pii& operator*=(pii& lhs,const pii& rhs){
	lhs=lhs*rhs;
	return lhs;
}
pii& operator/=(pii& lhs,const pii& rhs){
	lhs=lhs/rhs;
	return lhs;
}

const int MAXW=152501;
int p[MAXW+5],cnt,phi[MAXW+5];
bool v[MAXW+5];
void sieve(int lim){
	phi[1]=1;
	for(int i=2;i<=lim;++i){
		if(!v[i]){
			phi[i]=i-1;
			p[++cnt]=i;
		}
		for(int j=1;j<=cnt && p[j]*i<=lim;++j){
			v[i*p[j]]=1;
			if(i%p[j]==0){
				phi[i*p[j]]=phi[i]*p[j];
				break;
			}
			phi[i*p[j]]=phi[i]*phi[p[j]];
		}
	}
}//线性筛,求phi

const int MAXN=30;
const int MAXM=MAXN*(MAXN-1)/2;
int n,m;
struct Edge{
	int u,v,w;
}e[MAXM+5];

struct Matrix{
	int n;
	pii a[MAXN+5][MAXN+5];
	Matrix(){
		n=0;
		memset(a,0,sizeof(a));
	}
};

pii get_det2(Matrix A,int i){
	//常数项全部为0
	pii res=mk(1,0);
	int line=0;
	for(int j=i;j<=A.n;++j){
		if(A.a[j][i].se!=0){
			line=j;
			break;
		}
	}
	if(!line)return mk(0,0);
	if(line!=i){
		for(int j=1;j<=A.n;++j)swap(A.a[i][j],A.a[line][j]);
		res=-res;
	}
	int _inv=pow_mod(A.a[i][i].se,MOD-2);
	for(int j=i+1;j<=A.n;++j){
		int t=(ll)A.a[j][i].se*_inv%MOD;
		for(int k=1;k<=A.n;++k)
			sub(A.a[j][k].se,(ll)A.a[i][k].se*t%MOD);
	}
	res*=A.a[i][i];
	return res;
}
pii get_det(Matrix A){
	pii res=mk(1,0);
	for(int i=1;i<=A.n;++i){
		int line=0;
		for(int j=i;j<=A.n;++j){
			if(A.a[j][i].fi!=0){
				line=j;
				break;
			}
		}
		if(line==0){
			res*=get_det2(A,i);
			continue;
		}
		if(line!=i){
			for(int j=1;j<=A.n;++j)swap(A.a[i][j],A.a[line][j]);
			res=-res;
		}
		pii _inv=inv(A.a[i][i]);
		for(int j=i+1;j<=A.n;++j){
			pii t=A.a[j][i]*_inv;
			for(int k=1;k<=A.n;++k)
				A.a[j][k]-=A.a[i][k]*t;
		}
		res*=A.a[i][i];
	}
	return res;
}

int main() {
	cin>>n>>m;
	int max_w=0;
	for(int i=1;i<=m;++i){
		cin>>e[i].u>>e[i].v>>e[i].w;
		max_w=max(max_w,e[i].w);
	}
	sieve(max_w);
	int ans=0;
	for(int i=1;i<=max_w;++i){
		int cnt_e=0;
		for(int j=1;j<=m;++j)if(e[j].w%i==0)cnt_e++;
		if(cnt_e<n-1)continue;
		
		Matrix mat;
		for(int j=1;j<=m;++j)if(e[j].w%i==0){
			mat.a[e[j].u][e[j].u]+=mk(1,e[j].w);
			mat.a[e[j].v][e[j].v]+=mk(1,e[j].w);
			mat.a[e[j].u][e[j].v]-=mk(1,e[j].w);
			mat.a[e[j].v][e[j].u]-=mk(1,e[j].w);
		}
		mat.n=n-1;
		pii det=get_det(mat);
		ans=((ll)ans+(ll)phi[i]*det.se)%MOD;
	}
	cout<<ans<<endl;
	return 0;
}
```





---

## 作者：Masterwei (赞：5)

主要难点在于算生成树边权和。

看到 `gcd` 很容易想到我们可以反演，设 $f_i$ 表示 `gcd` 为 $i$ 的倍数（包含 $i$）的生成树权值之和，那么我们就可以在 $V\ln V$ 的时间内完成反演。

考虑怎么算这个东西，这里有一个算权值和的 trick，因为我们一般用行列式算的是生成树权值之积，所以我们考虑将原来矩阵内的数换成一个一次函数，也就是 $(ax+b)$，每次乘法都是一次函数相乘并且舍去二次项。这时我们将每条边的权值设为 $(wx+1)$，那么最后一次项的系数就是最后的答案。

这里重新定义一下基本运算：

加：两个元素分别加。

减：两个元素分别减。

乘：我们省去了二次项，所以是 $(a,b)\times (a',b')=(ab'+a'b,bb')$。

除：转化一下成为要找到 $(x,y)$ 使得 $(a,b)=(a',b')\times(x,y)$。推一下就成为了 $(x,y)=(\frac{a}{b'}+\frac{a'b}{b'^2},\frac{b}{b'})$。

由于模数是质数，所以我们可以直接求逆元。

时间复杂度是 $O(V\ln V+Vn^3)$，实际上当边的个数小于 $n-1$ 时我们不用去 $n^3$ 算，所以是跑不满的，稳过。


```cpp
#include<bits/stdc++.h>
//#define int long long
using namespace std;
inline int read(){
	int x=0;bool f=0;char ch=getchar();
	while(ch<'0'||ch>'9')f^=(ch=='-'),ch=getchar();
	while('0'<=ch&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return f?-x:x;
}
const int Maxn=1005,mod=998244353,V=152505;
int n,m;
struct edge{
	int u,v,w;
}e[Maxn];
vector<edge>p[V+5];
inline int ksm(int a,int k){
	int res=1;for(;k;k>>=1,a=1ll*a*a%mod)if(k&1)res=1ll*res*a%mod;
	return res;
}
int inv;
struct node{
	int a,b;
	inline node operator+(const node&p)const{return {(a+p.a)%mod,(b+p.b)%mod};}
	inline node operator-(const node&p)const{return {(a-p.a+mod)%mod,(b-p.b+mod)%mod};}
	inline node operator*(const node&p)const{return {(1ll*a*p.b+1ll*b*p.a)%mod,1ll*b*p.b%mod};}
	inline node operator/(const node&p)const{return {(1ll*a*inv-1ll*p.a*b%mod*inv%mod*inv%mod+mod)%mod,1ll*b*inv%mod};}
}a[33][33];
inline void add(int u,int v,int w){
	a[u][v]=a[u][v]-(node){w,1};a[v][v]=a[v][v]+(node){w,1};
}
inline int calc(int id){
	if(p[id].size()<n-1)return 0;
	memset(a,0,sizeof a);
	for(edge tmp:p[id])add(tmp.u,tmp.v,tmp.w),add(tmp.v,tmp.u,tmp.w);
	node ans={0,1};
	for(int i=2;i<=n;i++){
		int now=0;
		for(int j=i;j<=n;j++)if(a[j][i].b)now=j;
		if(!now)return 0;
		if(i!=now){
			swap(a[i],a[now]);ans.a=-ans.a;ans.b=-ans.b;
		}
		inv=ksm(a[i][i].b,mod-2);
		for(int j=i+1;j<=n;j++){
			node d=a[j][i]/a[i][i];
			for(int k=i;k<=n;k++)a[j][k]=a[j][k]-d*a[i][k];
		}
	}ans.a=(ans.a+mod)%mod;ans.b=(ans.b%mod+mod)%mod;
	for(int i=2;i<=n;i++)ans=ans*a[i][i];
	return ans.a;
}
int f[V];
signed main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	n=read();m=read();
	for(int i=1;i<=m;i++){
		e[i]={read(),read(),read()};
		for(int j=1;j*j<=e[i].w;j++){
			if(e[i].w%j)continue;
			p[j].push_back(e[i]);
			if(j*j!=e[i].w)p[e[i].w/j].push_back(e[i]);
		}
	}int ans=0;
	for(int i=V;i;i--){
		f[i]=calc(i);
		for(int j=i*2;j<=V;j+=i)f[i]=(f[i]-f[j]+mod)%mod;
		ans=(ans+1ll*i*f[i])%mod;
	}printf("%d\n",ans);
	return 0;
}


```

---

## 作者：iodwad (赞：4)

莫比乌斯反演一波，得到答案等于 $(\sum\limits_dd\sum\limits_g \mu(g)) \sum\limits_{i=1}^m w_i \times F(i,dg)$，其中 $F(i,dg)$ 是指由所有边权为 $dg$ 倍数的边构成的包含边 $i$ 的生成树个数。我们不考虑生成函数，使用容斥解决计算 $w_i \times F(i,dg)$ 的问题。众所周知矩阵树定理可以求解所有边权乘积的和，我们先令第 $i$ 条边的边权为 $w_i+1$ 算一遍矩阵树，再将其设为 $1$ 算一遍矩阵树，两者相减即可得到答案。可以这么理解：在前者里，所有包含边 $i$ 的生成树方案权值为 $w_i+1$，减去后者后变成 $w_i$，所有不包含边 $i$ 的生成树方案权值为 $1$，减去后者后变为 $0$。

```cpp
#include <bits/stdc++.h>

#define mp std::make_pair
#define pb push_back
#define fr first
#define se second

typedef std::pair<int, int> pii;
typedef std::vector<int> vi;
typedef long long ll;

template<class T> inline T max(const T &x, const T &y) { return x > y ? x : y; }
template<class T> inline T min(const T &x, const T &y) { return x < y ? x : y; }
template<class T> inline bool chkmax(T &x, const T &y) { return x < y ? x = y, true : false; }
template<class T> inline bool chkmin(T &x, const T &y) { return x > y ? x = y, true : false; }

inline int read() {
  register int x = 0, v = 1;
  register char ch = getchar();
  while (!isdigit(ch)) {
    if (ch == '-') v = -1;
    ch = getchar();
  }
  while (isdigit(ch)) {
    x = x * 10 + ch - '0';
    ch = getchar();
  }
  return x * v;
}

const int MOD = 998244353;
const int MAXN = 32;
const int MAXM = 450;
const int MAXW = 152510;

inline int add(int x, int y) { return x + y >= MOD ? x + y - MOD : x + y; }
inline int sub(int x, int y) { return x < y ? x - y + MOD : x - y; }

namespace Number {
  vi fac[MAXW | 1];
  int ptot;
  int prime[MAXW | 1], sumf[MAXW | 1], miu[MAXW | 1];
  bool not_prime[MAXW | 1];
  void Sieve() {
    miu[1] = 1;
    for (int i = 2; i <= MAXW; ++i) {
      if (!not_prime[i]) prime[++ptot] = i, miu[i] = MOD - 1;
      for (int j = 1; j <= ptot && i * prime[j] <= MAXW; ++j) {
        not_prime[i * prime[j]] = 1;
        miu[i * prime[j]] = 1ll * miu[i] * (MOD - 1) % MOD;
        if (i % prime[j] == 0) {
          miu[i * prime[j]] = 0;
          break;
        }
      }
    }
    for (int i = 1; i <= MAXW; ++i) {
      for (int j = i; j <= MAXW; j += i) {
        sumf[j] = add(sumf[j], 1ll * i * miu[j / i] % MOD);
        fac[j].pb(i);
      }
    }
  }
}

using namespace Number;

int n, m, ans;
int U[MAXM | 1], V[MAXM | 1], W[MAXM | 1];
int det[MAXN | 2][MAXN | 2]; 

int fpow(int x, int y) {
  int res = 1, base = x;
  while (y > 0) {
    if (y & 1) res = 1ll * res * base % MOD;
    base = 1ll * base * base % MOD;
    y >>= 1;
  }
  return res;
}

int Gauss() {
  int res = 1;
  for (int i = 1; i < n; ++i) {
    int tmp = i;
    for (int j = i; j < n; ++j) {
      if (det[j][i]) {
        tmp = j;
        break;
      }
    }
    if (tmp != i) std::swap(det[i], det[tmp]), res = MOD - res;
    int inv = fpow(det[i][i], MOD - 2);
    for (int j = i + 1; j < n; ++j) 
      for (int k = n - 1; k >= i; --k) 
        det[j][k] = sub(det[j][k], 1ll * det[j][i] * inv % MOD * det[i][k] % MOD);
  }
  for (int i = 1; i < n; ++i) res = 1ll * res * det[i][i] % MOD;
  return res;
}

int work(int x, int d) {
  int res = 0, tot = 0;
  memset(det, 0, sizeof(det));
  for (int i = 1; i <= m; ++i) {
    if (W[i] % d == 0) {
      ++tot;
      ++det[U[i]][U[i]]; ++det[V[i]][V[i]];
      det[U[i]][V[i]] = sub(det[U[i]][V[i]], 1); 
      det[V[i]][U[i]] = sub(det[V[i]][U[i]], 1);
    }
  }
  if (tot < n - 1) return 0;
  det[U[x]][V[x]] = sub(det[U[x]][V[x]], W[x]);
  det[V[x]][U[x]] = sub(det[V[x]][U[x]], W[x]);
  det[U[x]][U[x]] = add(det[U[x]][U[x]], W[x]);
  det[V[x]][V[x]] = add(det[V[x]][V[x]], W[x]);
  res = Gauss();
  memset(det, 0, sizeof(det));
  for (int i = 1; i <= m; ++i) {
    if (W[i] % d == 0) {
      ++det[U[i]][U[i]]; ++det[V[i]][V[i]];
      det[U[i]][V[i]] = sub(det[U[i]][V[i]], 1); 
      det[V[i]][U[i]] = sub(det[V[i]][U[i]], 1);
    }
  }
  return sub(res, Gauss());
}

int main() {
  freopen("code.in", "r", stdin);
  freopen("code.out", "w", stdout);
  Sieve();
  n = read(); m = read();
  for (int i = 1; i <= m; ++i) U[i] = read(), V[i] = read(), W[i] = read();
  for (int i = 1; i <= m; ++i) 
    for (int j : fac[W[i]]) 
      ans = add(ans, 1ll * sumf[j] * work(i, j) % MOD);
  printf("%d\n", ans);
  return 0;
}
```


---

## 作者：gxy001 (赞：3)

根据套路，先去掉烦人的 $\gcd$。
$$
\begin{aligned}
val(T)&=\left(\sum\limits_{i=1}^{n-1} w_{e_i}\right) \times \gcd(w_{e_1},w_{e_2},\dots,w_{e_{n-1}})\\&=\left(\sum\limits_{i=1}^{n-1} w_{e_i}\right) \times \sum\limits_{d\mid w_{e_1}\land\dots\land d\mid w_{e_{n-1}}}\varphi(d)\\&=\left(\sum\limits_{i=1}^{n-1} w_{e_i}\right)\sum\limits_{d=1}^{max_v}\varphi(d)[d\mid w_{e_1}\land\dots\land d\mid w_{e_{n-1}}]
\end{aligned}
$$

我们可以对于每一个 $d$，将边权为 $d$ 的倍数的边加入图中，然后只需要求所有生成树的边权和即可 ~~，然后就不会了~~。

我们可以利用矩阵树定理求得所有边权和。

我们知道，矩阵树定理求的是生成树上所有边乘积的和，我们可以将边权为 $w$ 的边的边权变为 $wx+1$，最后求得的结果的一次项系数就是边权和。

时间复杂度 $O(n^3max_v)$，不知道能不能过，我们发现实际上并不需要对每种 $d$ 都跑一遍矩阵树，只对边数大于等于 $n-1$ 的 $d$ 跑即可，然后就能过了。

更多细节都在代码里了。
```cpp
#include<cstdio>
#include<vector>
#include<cstring>
#include<algorithm>
#include<utility>
#define int long long
long long const mod=998244353;
long long pow(long long x,long long y){
	long long res=1;
	while(y){
		if(y&1) res=res*x%mod;
		x=x*x%mod; 
		y>>=1;
	}
	return res;
}
struct node{
	long long a,b;
	node(long long const &_a,long long const &_b):a(_a),b(_b){}
	node():a(),b(){}
	friend node operator +(node const &x,node const &y){
		return node((x.a+y.a)%mod,(x.b+y.b)%mod);
	}
	friend node operator -(node const &x,node const &y){
		return node((x.a-y.a+mod)%mod,(x.b-y.b+mod)%mod);
	}
	friend node operator *(node const &x,node const &y){
		return node((x.a*y.b%mod+y.a*x.b%mod)%mod,x.b*y.b%mod);
	}
	friend node operator /(node const &x,node const &y){
		long long inv=pow(y.b,mod-2);
		return node((x.a*y.b%mod-x.b*y.a%mod+mod)*inv%mod*inv%mod,x.b*inv%mod);
	}
	node& operator +=(node const &x){
		*this=*this+x;
		return *this;
	}
	node& operator -=(node const &x){
		*this=*this-x;
		return *this;
	}
	node& operator *=(node const &x){
		*this=*this*x;
		return *this;
	}
	node& operator /=(node const &x){
		*this=*this/x;
		return *this;
	}
}f[50][50];
int n,m,u[1010],v[1010],w[1010],iinv[152502];
std::vector<int> p[152502];
long long ans;
long long phi(long long x){
	long long res=x;
	for(int i=2;i*i<=x;i++)
		if(x%i==0){
			res=res*(i-1)%mod;
			if(!iinv[i]) iinv[i]=pow(i,mod-2);
			res=res*iinv[i]%mod;
			while(x%i==0) x/=i;
		} 
	if(x!=1){
		res=res*(x-1)%mod;
		if(!iinv[x]) iinv[x]=pow(x,mod-2);
		res=res*iinv[x]%mod;
	}
	return res;
}
signed main(){
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=m;i++){
		scanf("%lld%lld%lld",u+i,v+i,w+i);
		for(int j=1;j*j<=w[i];j++)
			if(w[i]%j==0){
				p[j].push_back(i);
				if(j*j!=w[i]) p[w[i]/j].push_back(i);
			}
	}
	for(int i=1;i<=152501;i++)
		if((int)(p[i].size())>=n-1){
			memset(f,0,sizeof(f));
			for(std::vector<int>::iterator it=p[i].begin();it!=p[i].end();++it){
				int u=::u[*it],v=::v[*it],w=::w[*it];
				f[u][v]-=node(w,1);
				f[v][u]-=node(w,1);
				f[u][u]+=node(w,1);
				f[v][v]+=node(w,1);
			}
			node ans(0,1);
			int rev=0;
			for(int i=1;i<n;i++){
				if(!f[i][i].b)
					for(int j=i+1;j<n;++j)
						if(f[j][i].b){
							rev^=1;
							std::swap(f[i],f[j]);
							break;
						}
				node inv=node(0,1)/f[i][i];
				ans=ans*f[i][i];
				for(int j=i;j<n;j++) f[i][j]=f[i][j]*inv;
				for(int j=1;j<n;j++)
					if(j!=i){
						node tmp=f[j][i];
						for(int k=i;k<n;k++)
							f[j][k]=f[j][k]-f[i][k]*tmp;
					}
			}
			if(rev) ans=node(0,0)-ans;
			::ans=(::ans+ans.a*phi(i)%mod)%mod;
		}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：xiezheyuan (赞：3)

whk 归来的第一篇题解！

## 简要题意

定义一个 $n$ 个点的树的权值，为其各边的边权和乘上各边的边权的 $\gcd$。

给定一个 $n$ 个点 $m$ 条边的无向图，边有边权。你需要计算其所有生成树的权值总和。答案对 $p=998,244,353$ 取模。

$1\leq n\leq 30,1\leq m\leq \frac{1}{2}n(n-1)$，值域 $[1,152501]$。

## 思路

首先看到 $\gcd$，考虑利用欧拉反演：

$$
\begin{aligned}
&\left(\sum_{i=1}^{n-1}w_i\right)\cdot \gcd(w_1,\cdots,w_{n-1})\\
&=\left(\sum_{i=1}^{n-1}w_i\right)\sum_{d\mid w_1,\cdots,d\mid w_{n-1}} \varphi(d)\\
&=\sum_{d}\varphi(d) [d\mid w_1\land\cdots\land d\mid w_{n-1}]\sum_{i=1}^{n-1}w_i
\end{aligned}
$$

预处理 $\varphi$，枚举 $d$，将所有边权为 $d$ 的倍数的边组成一个新图 $G_d$，现在的问题就变成了求 $G_d$ 的所有生成树的边权和的和。可以想到 Matrix-Tree 定理，不过美中不足的是，Matrix-Tree 定理计算的是所有生成树的**边权积**的和，而不是所有生成树的**边权和**的和。这就很难办。

这个时候你打开了题解区，看到了一种非常神秘的方法：将边权从 $\mathbb{Z_{p}}$ 换成一元一次多项式 $\{ax+b\mid a,b\in \mathbb{Z_{p}}\}$。

这样做有什么好处呢？根据多项式的基本性质，我们有：

- $(ax+b)\pm (cx+d)=(a\pm c)x+(b\pm d)$。
- $(ax+b)(cx+d)\equiv (ad+bc)x+bd\pmod{x^2}$。

注意所谓“模 $x^2$ 意义下”的实际意义是截断 $x^2$ 及更高次项。

你发现如果这样定义，乘积的结果的一次项系数会带有加法，不难想到直接令 $b,d=1$，这样就可以实现类似 $a+c$ 的效果了。

现在还有一个遗留问题，如果用朴素的初等行变换化为上三角矩阵的方法计算行列式，必须使用到除法，那么 $(ax+b)\div (cx+d)$ 是什么呢？考虑这个问题，不妨考虑 $(ax+b)^{-1}$ 是什么。

令 $(ax+b)^{-1}\equiv (cx+d)\pmod{x^2}$，则有 $(ax+b)(cx+d)\equiv (ad+bc)x+bd\equiv 1\pmod{x^2}$，得到 $ad+bc=0,bd=1$。

故 $d=b^{-1},c=-ab^{-2}$。得到逆元的结果后，计算除法只需要简单地乘上逆元即可。

按照 Matrix-Tree 定理的方法建立 Laplacian 矩阵（度数矩阵和邻接矩阵都是一元多项式，且常数项为 $1$），然后正常初等行变换即可，最后得到的行列式的一次项系数就是答案。

时间复杂度 $O(n^3V\log p)$，精细的实现可以做到 $O(n^3V)$，其中 $V$ 为值域。实际上这只是一个非常宽松的上界（我们可以将 $G_d$ 没有边的情况进行特判），因而可以通过本题。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 35, M = ((30 * 29) >> 1) + 5, V = 152501 + 5;

constexpr int mod = 998244353;
int Add(int x, int y){ return (x + y) >= mod ? (x + y - mod) : (x + y); }
int Sub(int x, int y){ return (x - y) < 0 ? (x - y + mod) : (x - y); }
int Mul(int x, int y){ return 1ll * x * y % mod; }

int fastpow(int x, int y){
    int ret = 1;
    for(;y;y>>=1,x=Mul(x, x)){ if(y & 1) ret = Mul(ret, x); }
    return ret;
}

int n, m;

struct edge{
    int u, v, w;
} e[M];

int pri[V], phi[V], tot;
bool vis[V];

void sieve(int n){
    phi[1] = 1;
    for(int i=2;i<=n;i++){
        if(!vis[i]) pri[++tot] = i, phi[i] = i - 1;
        for(int j=1;j<=tot&&1ll*i*pri[j]<=n;j++){
            vis[i * pri[j]] = 1, phi[i * pri[j]] = Mul(phi[i], phi[pri[j]]);
            if(!(i % pri[j])){
                phi[i * pri[j]] = Mul(phi[i], pri[j]);
                break;
            }
        }
    }
}

struct unary{
    int a, b; // ax + b
    unary(int _a = 0, int _b = 0) : a(_a), b(_b) {}
    unary operator+(const unary& rhs) const { return {Add(a, rhs.a), Add(b, rhs.b)}; }
    unary operator-(const unary& rhs) const { return {Sub(a, rhs.a), Sub(b, rhs.b)}; }
    unary operator*(const unary& rhs) const { return {Add(Mul(a, rhs.b), Mul(b, rhs.a)), Mul(b, rhs.b)}; }
    unary inv() const {
        int invb = fastpow(b, mod - 2);
        return {Mul(mod - a, Mul(invb, invb)), invb};
    }
    unary operator/(const unary& rhs) const { return (*this) * rhs.inv(); }
    unary operator+=(const unary& rhs){ return *this = *this + rhs; }
};

unary deg[N][N], a[N][N];

unary det(int n){
    for(int i=1;i<=n;i++){
        for(int j=i+1;j<=n;j++){
            unary v = a[j][i] / a[i][i];
            for(int k=i;k<=n;k++) a[j][k] = a[j][k] - v * a[i][k];
        }
    }
    unary ret = a[1][1];
    for(int i=2;i<=n;i++) ret = ret * a[i][i];
    return ret;
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    cin >> n >> m;
    int mx = 152501; sieve(mx);
    for(int i=1;i<=m;i++) cin >> e[i].u >> e[i].v >> e[i].w;
    int ans = 0;
    for(int d=1;d<=mx;d++){
        for(int i=1;i<=n;i++) deg[i][i] = {0, 0};
        for(int i=1;i<=n;i++){
            for(int j=1;j<=n;j++) a[i][j] = {0, 0};
        }
        int tot = 0;
        for(int i=1;i<=m;i++){
            if(e[i].w % d) continue;
            tot++;
            deg[e[i].u][e[i].u] += {e[i].w, 1}, deg[e[i].v][e[i].v] += {e[i].w, 1};
            a[e[i].u][e[i].v] += {e[i].w, 1}, a[e[i].v][e[i].u] += {e[i].w, 1};
        }
        if(!tot) continue;
        for(int i=1;i<=n;i++){
            for(int j=1;j<=n;j++) a[i][j] = deg[i][j] - a[i][j];
        }
        ans = Add(ans, Mul(det(n - 1).a, phi[d]));
    }
    cout << ans << '\n';
    return 0;
}

// Written by xiezheyuan
```

---

## 作者：crashed (赞：3)

# 题目
&emsp;&emsp;[点这里](https://www.luogu.com.cn/problem/P6624)看题目。  
# 分析
&emsp;&emsp;这道题其实是两道题目。   
   
&emsp;&emsp;首先可以娴熟地变换一下柿子：   
   
$$
\begin{aligned}
\sum_T val(T)
&=\sum_T \left(\sum_{e\in T} w_e\times \gcd_{e\in T}w_e\right)\\
&=\sum_{d=1} d\times \left(\sum_T \sum_{e\in T}w_e\left[\gcd_{e\in T}w_e=d\right]\right)\\      
\end{aligned}
$$
   
&emsp;&emsp;尝试定义：   
   
$$
\begin{aligned}
f(d)&=\sum_T \sum_{e\in T}w_e\left[\gcd_{e\in T}w_e=d\right]\\
F(n)&=\sum_{n|d} f(d)=\sum_{T} \sum_{e\in T}w_e\left[n\ |\gcd_{e\in T}w_e\right]
\end{aligned}
$$   
   
&emsp;&emsp;然后发现$F(n)$相对而言好求一些。知道了$F$，就可以用莫比乌斯反演或者逆推方法计算出$f$，就解决了问题。   
    
&emsp;&emsp;发现艾弗森括号内的限制可以通过限制边来解决。对于$F(n)$，我们只用$n|w_e$的边$e$来计算，即可。   
   
&emsp;&emsp;于是考虑一个图中，求出：   
   
$$\sum_T \sum_{e\in T}w_e$$   
    
&emsp;&emsp;~~好像是一个老 trick 了，可是我从没听说过~~    
    
&emsp;&emsp;考虑把边权写成一次函数的形式：$w\Rightarrow 1+wx$   
    
&emsp;&emsp;然后发现：$(1+w_1x)(1+w_2x)=1+(w_1+w_2)x+w_1w_2x^2$   
   
&emsp;&emsp;忽略二次项，它们的一次项系数加起来了！   
   
&emsp;&emsp;然后就可以使用**一次函数**代替原来的**数**，并在$\bmod{x^2}$的意义下计算，利用“乘法”和矩阵树定理计算边权和。    
    
&emsp;&emsp;定义这个新的类型的基本形式为$a+bx$，我们还可以定义“四则运算”：   
    
&emsp;&emsp;加法：$(a+bx)+(c+dx)=(a+c)+(b+d)x$；    
   
&emsp;&emsp;减法：$(a+bx)-(c+dx)=(a-c)+(b-d)x$；   
   
&emsp;&emsp;乘法：$(a+bx)(c+dx)=ac+(bc+ad)x$；   
   
&emsp;&emsp;除法：我们只需要计算逆元：$(a+bx)^{-1}=(a^{-1}-ba^{-2}x)$，推导过程不难；   
   
&emsp;&emsp;然后就可以枚举所有因子计算了。这里有一个剪枝，即当当前的图不连通的时候，我们直接跳掉。时间复杂度大概是$O(n^4d)$，其中$d≈144$。   
# 代码
```cpp
#include <cstdio>
#include <vector>
#include <iostream>
using namespace std;

const int mod = 998244353;
const int MAXN = 35, MAXM = MAXN * MAXN, MAXV = 2e5 + 5;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
_T MAX( const _T a, const _T b )
{
	return a > b ? a : b;
}

int inv( const int );
int qkpow( int, int );

struct linear
{
	int k, b;
	//f(x)=ax+b
	linear() { k = 0, b = 1; }
	linear( const int B ) { k = 0, b = B; }
	linear( const int K, const int B ) { k = K, b = B; }
	
	linear getInv() const
	{
		int tmp = inv( b );
		return linear( ( mod - 1ll * tmp * tmp % mod * k % mod + mod ) % mod, tmp );
	}
	
	linear operator / ( const linear &g ) const { return g * getInv(); }
	linear operator + ( const linear &g ) const { return linear( ( k + g.k ) % mod, ( b + g.b ) % mod ); }
	linear operator - ( const linear &g ) const { return linear( ( k - g.k + mod ) % mod, ( b - g.b + mod ) % mod ); }
	linear operator * ( const linear &g ) const { return linear( ( 1ll * k * g.b % mod + 1ll * b * g.k % mod ) % mod, 1ll * b * g.b % mod ); }

	void operator += ( const linear &g ) { *this = *this + g; }
	void operator -= ( const linear &g ) { *this = *this - g; }
	void operator *= ( const linear &g ) { *this = *this * g; }
	void operator /= ( const linear &g ) { *this = *this / g; }
	void operator ++ () { b = ( b + 1 >= mod ? b + 1 - mod : b + 1 ); }
	
	operator bool() const { return k || b; }
};

vector<int> vec[MAXV];

linear D[MAXN][MAXN], G[MAXN][MAXN], K[MAXN][MAXN];
int fr[MAXM], to[MAXM], w[MAXM];
int F[MAXV];
int fa[MAXN];
int N, M;

int qkpow( int base, int indx )
{
	int ret = 1;
	while( indx )
	{
		if( indx & 1 ) ret = 1ll * ret * base % mod;
		base = 1ll * base * base % mod, indx >>= 1;
	}
	return ret;
}

int inv( const int a ) { return qkpow( a, mod - 2 ); }

int det( linear T[][MAXN], const int n )
{
	linear ans, tmp, inver; int indx;
	for( int i = 1 ; i <= n ; i ++ )
	{
		indx = -1;
		for( int j = i ; j <= n ; j ++ )
			if( T[j][i] )
			{ indx = j; break; }
		if( indx == -1 ) return 0;
		if( indx ^ i ) ans.k *= -1;
		swap( T[i], T[indx] ), inver = T[i][i].getInv();
		for( int j = i + 1 ; j <= n ; j ++ )
			if( T[j][i] )
			{
				tmp = T[j][i] * inver;
				for( int k = i ; k <= n ; k ++ )
					T[j][k] -= T[i][k] * tmp;
			}
		ans *= T[i][i];
	}
	return ans.k;
}

void makeSet() { for( int i = 1 ; i <= N ; i ++ ) fa[i] = i; }
int findSet( const int u ) { return fa[u] = ( fa[u] == u ? u : findSet( fa[u] ) ); }
void unionSet( const int u, const int v ) { fa[findSet( u )] = findSet( v ); }

int main()
{
	int mxv = -1;
	read( N ), read( M );
	for( int i = 1 ; i <= M ; i ++ ) read( fr[i] ), read( to[i] ), read( w[i] );
	for( int i = 1 ; i <= M ; i ++ )
		for( int x = 1 ; x * x <= w[i] ; x ++ )
			if( ! ( w[i] % x ) )
			{
				vec[x].push_back( i );
				if( x * x != w[i] ) vec[w[i] / x].push_back( i );
			}
	for( int i = 1 ; i <= M ; i ++ ) mxv = MAX( mxv, w[i] );
	for( int i = 1, cnt ; i <= mxv ; i ++ )
	{
		makeSet();
		for( int j = 0 ; j < vec[i].size() ; j ++ )
			unionSet( fr[vec[i][j]], to[vec[i][j]] );
		cnt = 0;
		for( int j = 1 ; j <= N ; j ++ )
			if( fa[j] == j ) cnt ++;
		if( cnt > 1 ) continue;
		for( int i = 1 ; i <= N ; i ++ )
			for( int j = 1 ; j <= N ; j ++ )
				D[i][j] = G[i][j] = K[i][j] = 0;
		for( int j = 0 ; j < vec[i].size() ; j ++ )
			G[fr[vec[i][j]]][to[vec[i][j]]] += linear( w[vec[i][j]], 1 ),
			G[to[vec[i][j]]][fr[vec[i][j]]] += linear( w[vec[i][j]], 1 );
		for( int i = 1 ; i <= N ; i ++ )
			for( int j = 1 ; j <= N ; j ++ )
				D[i][i] += G[i][j];
		for( int i = 1 ; i <= N ; i ++ )
			for( int j = 1 ; j <= N ; j ++ )
				K[i][j] = D[i][j] - G[i][j];
		F[i] = det( K, N - 1 );
	}
	for( int i = mxv ; i ; i -- )
		for( int j = i << 1 ; j <= mxv ; j += i )
			F[i] = ( F[i] - F[j] + mod ) % mod;
	int ans = 0;
	for( int i = 1 ; i <= mxv ; i ++ ) ans = ( ans + 1ll * F[i] * i % mod ) % mod;
	write( ans ), putchar( '\n' );
	return 0;
}
```

---

## 作者：Pentiment (赞：2)

看到 $\gcd$，条件反射做欧拉反演：
$$
\begin{aligned}
\text{ans}&=\sum_{T}\left(\sum_{i=1}^{n-1}w_{e_i}\right)\left(\sum_{\forall 1\le i<n,d|w_{e_i}}\varphi(d)\right)\\
&=\sum_{d=1}^V\varphi(d)\sum_{\forall 1\le i<n,d|w_{e_i}}w_{e_i}
\end{aligned}
$$
枚举 $d$，将边权为 $d$ 的倍数的边加入图中，考虑如何计算所有生成树的边权的和之和。

将每条边表示成 $1+wx$ 的形式，考虑其乘法：$(1+w_1x)(1+w_2x)=1+(w_1+w_2)x+w_1w_2x$，发现其一次项系数加在了一起，即 $1+wx$ 相乘等同于一次项相加，那么只需求所有生成树的 $1+wx$ 的积之和即可，计算时只需要保留常数项和一次项。

加减乘都很简单，考虑逆元怎么求：
$$
\begin{aligned}
(a+bx)(p+qx)&=1\pmod{x^2}\\
ap+(aq+bp)x&=1\pmod{x^2}
\end{aligned}
$$
那么 $p=\dfrac1a,q=-\dfrac{b}{a^2}$。

因此 $\dfrac{a+bx}{c+dx}\equiv\dfrac ac+\dfrac{bc-ad}{c^2}\pmod{x^2}$。

注意对每个 $d$ 都求行列式的复杂度是 $\mathcal O(n^3\sum\tau(w))$ 的，大概是 $72n^5$ 这个量级，应该难以通过；如果只对可能合法的 $d$（边数不小于 $n-1$）求行列式，那么复杂度就变成了 $\mathcal O(n^2\sum\tau(w))$，即 $72n^4$，可以通过。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 35, M = 440, V = 152505, p = 998244353;
int n, m, tot, pri[V], phi[V], cnt[V], ans;
bool vis[V];
struct edge { int u, v, w; } e[M];
int qpow(int a, int b) {
	int c = 1;
	while (b) { if (b & 1) c = (ll)c * a % p; a = (ll)a * a % p, b >>= 1; }
	return c;
}
void sieve(int n) {
	phi[1] = 1;
	for (int i = 2, k, p; i <= n; i++) {
		if (!vis[i]) pri[++tot] = i, phi[i] = i - 1;
		for (int j = 1; j <= tot && (k = i * (p = pri[j])) <= n; j++) {
			vis[k] = 1;
			if (!(i % p)) { phi[k] = phi[i] * p; break; }
			phi[k] = phi[i] * (p - 1);
		}
	}
}
struct node { int a, b; node(int a = 0, int b = 0): a(a), b(b) {} } a[N][N];
node operator+(node a, node b) { return node((a.a + b.a) % p, (a.b + b.b) % p); }
node operator-(node a, node b) { return node((a.a - b.a + p) % p, (a.b - b.b + p) % p); }
node operator*(node a, node b) { return node((ll)a.a * b.a % p, ((ll)a.a * b.b + (ll)a.b * b.a) % p); }
node operator/(node a, node b) { int i = qpow(b.a, p - 2); return node((ll)a.a * i % p, ((ll)a.b * b.a - (ll)a.a * b.b % p + p) % p * i % p * i % p); }
int gauss() {
	node ans = 1;
	for (int i = 1; i < n; i++) {
		if (!a[i][i].a) {
			for (int j = i + 1; j < n; j++) {
				if (a[j][i].a) { ans = 0 - ans, swap(a[i], a[j]); break; }
			}
		}
		node inv = 1 / a[i][i];
		for (int j = i + 1; j < n; j++) {
			node alp = a[j][i] * inv;
			for (int k = i; k <= n; k++) a[j][k] = a[j][k] - alp * a[i][k];
		}
		ans = ans * a[i][i];
	}
	return ans.b;
}
int solve(int d) {
	memset(a, 0, sizeof(a));
	for (int i = 1, u, v, w; i <= m; i++) {
		u = e[i].u, v = e[i].v, w = e[i].w;
		if (!(w % d)) {
			a[u][u] = a[u][u] + node(1, w), a[u][v] = a[u][v] - node(1, w);
			a[v][v] = a[v][v] + node(1, w), a[v][u] = a[v][u] - node(1, w);
		}
	}
	return gauss();
}
int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1, w; i <= m; i++) {
		scanf("%d%d%d", &e[i].u, &e[i].v, &e[i].w), w = e[i].w;
		for (int j = 1; j * j <= w; j++) {
			if (w % j) continue;
			cnt[j]++;
			if (j * j != w) cnt[w / j]++;
		}
	}
	sieve(V - 1);
	for (int i = 1; i < V; i++) {
		if (cnt[i] >= n - 1) ans = (ans + (ll)phi[i] * solve(i)) % p;
	}
	printf("%d", ans);
}
```

---

## 作者：Albedo (赞：2)

# $\texttt{Problem}$
小 W 刚刚在离散数学课学习了生成树的知识：一个无向图 $G=(V,E)$ 的生成树 $T$ 为边集 $E$ 的一个大小为 $|V|-1$ 的子集，且保证 $T$ 的生成子图在 $G$ 中连通。

小 W 在做今天的作业时被这样一道题目难住了：

给定一个 $n$ 个顶点 $m$ 条边（点和边都从 $1$ 开始编号）的无向图 $G$，保证图中无重边和无自环。每一条边有一个正整数边权 $w_i$，对于一棵 $G$ 的生成树 $T$，定义 $T$ 的价值为：$T$ 所包含的边的边权的最大公约数乘以边权之和，即：

$
val(T)=\left(\sum\limits_{i=1}^{n-1} w_{e_i}\right) \times \gcd(w_{e_1},w_{e_2},\dots,w_{e_{n-1}})
$

其中 $e_1,e_2,\dots,e_{n-1}$ 为 $T$ 包含的边的编号。

小 W 需要求出 $G$ 的所有生成树 $T$ 的价值之和，他做了很久也没做出来，请你帮帮他。由于答案可能很大，你只需要给出答案对 $998244353$ 取模后的结果。

# $\texttt{Solution}$
## 初步的算法
首先运用莫比乌斯反演：
$$
f(i)=\sum_{i|d} \mu(\frac{d}{i}) F(d),
\text{ans}=\sum_{i=1}^{\text{up}} f(i)\times i
$$
然后原问题转化为：

取出所有边权 $\text{mod K=0}$ 的边，然后求出对于所有生成树$\sum_{i=1}^{n-1} w_{e_i}$的和。

那么对于这个问题，显然有一个做法是我们钦定那一条边是一定要选的，然后对这条边去掉后的边进行一次矩阵树定理的运用，但是这样会有一个问题，就是我们要如何求出这条边一定存在的生成树的个数。

其实也非常简单，我们考虑正难则反，那么我们只要对每一条边都做一次矩阵树定理的运用，然后总方案数减去没有这条边的方案数即可。

时间复杂度：$\mathcal O(152501\times m\times n^3)$

## 算法的优化
我们发现上面的算法理论最高复杂度达到了惊人的 $\mathcal O(152501\times n^5)$，显然是无法通过的。

但是如果我们将他想象成一个多项式的话，好像问题就不用运用正难则反了，具体如下：
$$
G(i)=\prod_{i=1}^{n-1} (c_i+1)
$$

那么我们将 $G(i)$ 的值想象成一个多项式，最后的答案就是 $G(i)$ 的一次项的值，时间复杂度仿佛优化到了 $\mathcal O(n^4)$ 的级别。

要写一个巨大多麻烦的多项式运算，加减乘都十分简单，这里给出一下逆元的表示：
$$
(ax+b)\times (cx+d)\equiv1(\bmod x^2),
\begin{cases}
b\times d=1\\
b\times c+a\times d=0
\end{cases},
\therefore
\begin{cases}
d=\dfrac{1}{b}\\
c=-\dfrac{a}{b^2}
\end{cases}
$$

然后就可以用多项式做了。

复杂度大概是 $\mathcal O(n^3\times 144)$
# $\texttt{Code}$
``` cpp
struct node{
	long long x,y;
} f[1010][1010];
long long pow(long long x,long long y,long long p){
	long long ans=1;
	for (;y;y>>=1,x=x*x % p)
	    if (y&1) ans=ans*x % p;return ans;
}
int Matrix(){
int now,i;long long inv,inva,zg,zga,sym,G;
	N=n-1;
	node ans=(node){0,1};
	for (now=1;now<N;now++){
		for (i=now+1;i<=N;i++)
		    if ((f[now][now].y==0)&&(f[i][now].y)){
		    	ans=(node){0,-ans.y};
		    	swap(f[now],f[i]);break;
			}
		  for (i=now+1;i<=N;i++){
		  	inva=pow(f[now][now].y,MOD-2,MOD);
			inv=(-inva*inva % MOD*f[now][now].x % MOD+MOD) % MOD;//(inva,inv)
			zg=f[i][now].x;zga=f[i][now].y;
			zg=(zg*inva+zga*inv) % MOD;zga=zga*inva % MOD;
			//a[i][now]*(a[now][now])^{-1}
			for (j=now;j<=N;j++) 
			     {
			     	//(zg*x+zga)(inv*x+inva)=zg*inva+zga*inv,zga*inva
			     	//(zg,zga)*(
			     	f[i][j]=(node){((f[i][j].x-zg*f[now][j].y-zga*f[now][j].x) % MOD+MOD) % MOD,(f[i][j].y-zga*f[now][j].y% MOD+MOD) % MOD};
			     }
		  }
	}

for (i=1;i<=N;i++) ans=(node){(ans.x*f[i][i].y+ans.y*f[i][i].x) % MOD,ans.y*f[i][i].y % MOD};
return ans.x;
}
long long Main(){
	for (i=1;i<=n;i++) deg[i]=0;
	for (i=1;i<=m;i++)
	    if (c[i] % nowa==0) 
	        {
	        f[a[i]][a[i]].x+=c[i];f[b[i]][b[i]].x+=c[i];
			f[a[i]][a[i]].y+=1;f[b[i]][b[i]].y+=1;
			f[a[i]][b[i]].x+=-c[i];f[a[i]][b[i]].y+=-1;
			f[b[i]][a[i]].x-=c[i];f[b[i]][a[i]].y+=-1;
	        }
	long long tot=Matrix();
//	cout<<tot<<endl;
	for (i=1;i<=n;i++)
	    for (j=1;j<=n;j++)
	         f[i][j].x=f[i][j].y=0;
	return tot;
}
int main()
{
	n=read();m=read();MOD=998244353;
	for (i=1;i<=m;i++) a[i]=read(),b[i]=read(),c[i]=read(),up=max(up,c[i]),tem[c[i]]++;
	for (i=1;i<=up;i++)
	   for (j=1;j<=up/i;j++)
	         fre[i]+=tem[i*j];
    for (nowa=1;nowa<=up;nowa++)
	    if (fre[nowa]>=n-1)
	        {
			
	          F[nowa]=Main();
	         // printf("%lld-----%lld\n",nowa,F[nowa]);
	      }
	mu[1]=1;
	for (i=2;i<=up;i++){
		if (vis[i]==false){
			prim[++len]=i;mu[i]=-1;
		}
		for (j=1;j<=len&&i*prim[j]<=up;j++){vis[i*prim[j]]=true;
			mu[i*prim[j]]=mu[i]*mu[prim[j]];
			if (i % prim[j]==0) {mu[i*prim[j]]=0;break;}
		}
	}
	for (i=1;i<=up;i++)
	   for (j=1;j<=up/i;j++)
	        tag[i]=(tag[i]+mu[j]*F[i*j] % MOD+MOD) % MOD;ans=0;
	for (i=1;i<=up;i++) ans=(ans+tag[i]*i) % MOD;
	printf("%lld\n",ans);
    return 0;
}


```

---

## 作者：VenusM1nT (赞：2)

前置芝士：Martix-Tree 定理，Euler 反演。  
Matrix-Tree 定理相信各位都会，不细说了。  
Euler 反演其实就是这个柿子：
$$n=\sum_{d|n}\varphi(d)$$
口胡一个证明
$$n=\sum_{d|n}\sum_{i=1}^{n}[\gcd(n,i)=d]$$
上式因为第二层 $\sum$ 最后一定会取满所以显然。第二层根据约数略作改变得  
$$\quad =\sum_{d|n}\sum_{i=1}^{ \frac{n}{d}}[\gcd( \frac{n}{d},i)=1]$$
发现第二层就是 $\varphi$，即得
$$=\sum_{d|n}\varphi(\frac{n}{d})=\sum_{d|n}\varphi(d)$$

---
观察原式
$$\sum_{T\subseteq G }\left(\sum_{e_i\in T}w_{e_i}\right)\times\gcd(w_{e_1},...,w_{e_{n-1}})$$
gcd 这个东西看着很不友好，Euler 反演整一下：
$$\sum_{T\subseteq G }\left(\sum_{e_i\in T}w_{e_i}\right)\times\sum_{\forall i,d|w_i}\varphi(d)$$
惯用伎俩枚举一下 $d$：
$$\sum_{d=1}^{\max\{ w_i\}}\varphi(d)\times\sum_{T\subseteq G,\forall i,d|w_i}\sum_{e_i\in T}w_{e_i}$$
前面这个柿子看着很友好，于是不管它，关键是怎么求后面那坨。Matrix-Tree 定理非常 naive，一般只用来求生成树个数，于是考虑改变矩阵中的值。观察发现如果把每个值都变为 $w_ix+1$，最后所得的一次项系数即为要求的后面那坨，可以拿两三个手玩一下，发现是对的。  
此处再口胡一个证明，用数学归纳法，假设 $k$ 条边时答案是对的，则 $k+1$ 条边时，有
$$\text{val}=\left(...+\left(\sum_{i=1}^{k}w_i\right)x+1\right)\times (w_{k+1}x+1)$$
前面高次的均不用考虑，则可以发现新的一次项系数为
$$\text{val}_1=\left(\sum_{i=1}^{k}w_i\right)+w_{k+1}$$
得证。  

此处你可能还有一个问题，$d|w_i$ 这个怎么保证呢？只需要把满足 $d|w_i$ 的边加入矩阵中，剩下的不考虑，再进行计算就行了。  
最后考虑多项式的运算，鉴于只需要一次项，所以每个多项式只要存两个系数就行了，唯一比较麻烦的除法其他题解也写得非常清楚了，就不在此赘述了。
```cpp
#include<bits/stdc++.h>
#define N 35
#define M 200005
#define reg register
#define inl inline
#define int long long
using namespace std;
const int Mod=998244353;
inl int Pow(reg int x,reg int y)
{
	reg int res=1;
	for(;y;y>>=1,x=x*x%Mod) if(y&1) res=res*x%Mod;
	return res;
}
struct Poly
{
	int x,y;
	friend Poly operator + (const Poly &a,const Poly &b)
	{
		return ((Poly){(a.x+b.x)%Mod,(a.y+b.y)%Mod});
	}
	friend Poly operator - (const Poly &a,const Poly &b)
	{
		return ((Poly){(a.x-b.x+Mod)%Mod,(a.y-b.y+Mod)%Mod});
	}
	friend Poly operator * (const Poly &a,const Poly &b)
	{
		return ((Poly){a.x*b.x%Mod,(a.x*b.y+a.y*b.x)%Mod});
	}
	friend Poly operator / (const Poly &a,const Poly &b)
	{
		reg int inv=Pow(b.x,Mod-2);
		return ((Poly){a.x*inv%Mod,(a.y*b.x-a.x*b.y+Mod)%Mod*inv%Mod*inv%Mod});
	}
}a[N][N];
int n,m,st[M],to[M],w[M],sum[M],ans;
int pri[M],phi[M],tot;
bool isp[M];
inl void Init()
{
	phi[1]=1;
	for(reg int i=2;i<=M-5;i++)
	{
		if(!isp[i])
		{
			pri[++tot]=i;
			phi[i]=i-1;
		}
		for(reg int j=1;j<=tot && i*pri[j]<=M-5;j++)
		{
			isp[i*pri[j]]=1;
			if(!(i%pri[j]))
			{
				phi[i*pri[j]]=phi[i]*pri[j];
				break;
			}
			else phi[i*pri[j]]=phi[i]*(pri[j]-1);
		}
	}
}
inl int Gauss()
{
	reg Poly res=((Poly){1,0});
	reg bool fg=0;
	for(reg int i=1;i<n;i++)
	{
		reg int o;
		for(o=i;o<n;o++)
		{
			if(a[o][i].x) break;
		}
		if(o==n) return 0;
		if(i!=o)
		{
			fg^=1;
			for(reg int k=1;k<n;k++) swap(a[i][k],a[o][k]);
		}
		reg Poly tmp=((Poly){1,0});
		tmp=tmp/a[i][i];
		for(reg int j=i+1;j<n;j++)
		{
			reg Poly cnt=tmp*a[j][i];
			for(reg int k=i;k<n;k++) a[j][k]=a[j][k]-cnt*a[i][k];
		}
		res=res*a[i][i];
	}
	if(fg) res=((Poly){0,0})-res;
	return res.y;
}
inl int Solve(reg int x)
{
	for(reg int i=1;i<=n;i++)
	{
		for(reg int j=1;j<=n;j++) a[i][j].x=a[i][j].y=0;
	}
	for(reg int i=1;i<=m;i++)
	{
		if(!(w[i]%x))
		{
			a[st[i]][to[i]]=a[st[i]][to[i]]-((Poly){1,w[i]});
			a[to[i]][st[i]]=a[to[i]][st[i]]-((Poly){1,w[i]});
			a[st[i]][st[i]]=a[st[i]][st[i]]+((Poly){1,w[i]});
			a[to[i]][to[i]]=a[to[i]][to[i]]+((Poly){1,w[i]});
		}
	}
	return Gauss();
}
signed main()
{
	Init();
	scanf("%lld %lld",&n,&m);
	for(reg int i=1;i<=m;i++)
	{
		scanf("%lld %lld %lld",&st[i],&to[i],&w[i]);
		for(reg int j=1;j*j<=w[i];j++)
		{
			if(!(w[i]%j))
			{
				sum[j]++;
				if(j*j!=w[i]) sum[w[i]/j]++;
			}
		}
	}
	for(reg int i=1;i<=M-5;i++) if(sum[i]>=n-1) ans=(ans+Solve(i)*phi[i]%Mod)%Mod;
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：云浅知处 (赞：2)

首先套路反演一波，设 $W(T)$ 表示生成树 $T$ 的边权集合，$\gcd(S)$ 表示 $S$ 以内所有数的 $\gcd$，$\text{sum}(S)$ 表示 $S$ 以内所有数之和，则有
$$
\sum_T\gcd(W(T))\times \text{sum}(W(T))=\sum_{d=1}^{V}\varphi(d)\sum_{d|\gcd(W(T))}\text{sum}(W(T))
$$
相当于保留所有边权为 $d$ 的倍数的边，求所有生成树的权值和。

在每条边上写个多项式 $1+w_ix$，重新定义 $D$ 表示这个点的邻边上所有多项式之和，$G$ 类似，求出最终的行列式（这是一个多项式），一次项系数就是所有生成树的权值和。

现在考虑多项式怎么做高斯消元；发现只需要在 $\bmod x^2$ 意义下做多项式乘法，多项式求逆等等。发现性质相当好，只要常数项不为 $0$，多项式就一定存在逆。具体来说有

$$
(1+ax)^{-1}\equiv 1-ax\pmod{x^2}
$$

直接暴力算就行了，复杂度大概是 $O(n^3\sum d(w_i))$，不会超过 $n^4\times \max d(w_i)\le 2\times 10^8$。

```cpp
#include<bits/stdc++.h>

#define int long long

using namespace std;

inline int read(){
	int x=0,f=1;char c=getchar();
	for(;(c<'0'||c>'9');c=getchar()){if(c=='-')f=-1;}
	for(;(c>='0'&&c<='9');c=getchar())x=x*10+(c&15);
	return x*f;
}

const int mod=998244353;
int ksm(int x,int y,int p=mod){
	int ans=1;
	for(int i=y;i;i>>=1,x=1ll*x*x%p)if(i&1)ans=1ll*ans*x%p;
	return ans%p;
}
int inv(int x,int p=mod){return ksm(x,p-2,p)%p;}
int randint(int l,int r){return rand()*rand()%(r-l+1)+l;}
void add(int &x,int v){x+=v;if(x>=mod)x-=mod;}

const int N=35;
const int W=2e5+5;
struct F{
	int a,b;
	F(int A,int B):a(A),b(B){}
	F(){}
}a[N][N];
F Inv(F f){int iv=inv(f.a);return F(iv,mod-1ll*iv*iv%mod*f.b%mod);}
F operator+(F f,F g){return F((f.a+g.a)%mod,(f.b+g.b)%mod);}
F operator-(F f,F g){return F((f.a-g.a+mod)%mod,(f.b-g.b+mod)%mod);}
F operator*(F f,F g){return F(f.a*g.a%mod,(f.a*g.b+f.b*g.a)%mod);}
F operator/(F f,F g){return f*Inv(g);}
F operator*(F f,int c){return F(f.a*c%mod,f.b*c%mod);}
bool operator==(F f,F g){return f.a==g.a&&f.b==g.b;}
bool operator==(F f,int c){return f.a==c;}

int Gauss(int n){
	F res=F(1,0);
	for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++){
			if(a[j][i]==0)continue;
			for(int k=1;k<=n;k++)swap(a[i][k],a[j][k]);
			if(i!=j)res=F(0,0)-res;break;
		}
		F iv=Inv(a[i][i]);
		for(int j=1;j<=n;j++){
			if(i==j)continue;
			F r=a[j][i]*iv;
			for(int k=1;k<=n;k++)a[j][k]=a[j][k]-a[i][k]*r;
		}
	}
	for(int i=1;i<=n;i++)res=res*a[i][i];
	return res.b;
}

int n,m;
vector<pair<int,int> >E[W];
F D[N][N],G[N][N];

#define fi first
#define se second
#define mk make_pair

int phi[W];bool vis[W];
int solve(){
	for(int i=1;i<=n-1;i++)for(int j=1;j<=n-1;j++)a[i][j]=D[i][j]-G[i][j];
	for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)D[i][j]=G[i][j]=F(0,0);
	return Gauss(n-1);
}

signed main(void){

#ifndef ONLINE_JUDGE
	freopen("in.in","r",stdin);
#endif

	n=read(),m=read();int V=200000;
	for(int i=1;i<=m;i++){
		int u=read(),v=read(),w=read();
		E[w].emplace_back(mk(u,v));
	}
	
	for(int i=1;i<=V;i++)phi[i]=i;
	for(int i=2;i<=V;i++){
		if(vis[i])continue;phi[i]=i-1;
		for(int j=i+i;j<=V;j+=i)phi[j]=phi[j]/i*(i-1),vis[j]=1;
	}
//	for(int i=1;i<=12;i++)cout<<phi[i]<<" ";puts("");
	int ans=0;
	for(int i=1;i<=V;i++){
		int cnt=0;
		for(int j=i;j<=V;j+=i){
			cnt+=E[j].size();
			for(auto e:E[j]){
				int u=e.fi,v=e.se;
				D[u][u]=D[u][u]+F(1,j),D[v][v]=D[v][v]+F(1,j);
				G[u][v]=G[u][v]+F(1,j),G[v][u]=G[v][u]+F(1,j);
			}
		}
		if(cnt==0)continue;
		add(ans,solve()*phi[i]%mod);
	}
	cout<<ans<<endl;

	return 0;
}
```

---

## 作者：AzusaCat (赞：2)


给定一张带边权的简单无向连通图，定义一棵生成树 $T$ 的权值为
$$
val(T)=\left(\sum\limits_{i=1}^{n-1}w_{e_i}\right)\times\gcd(w_{e_1},w_{e_2},\dots,w_{e_{n-1}})
$$
求所有生成树的权值之和。

$n\leqslant 30 , m\leqslant\frac{n(n-1)}{2},1\leqslant w_i\leqslant 152501$ 。

首先我们把碍事的 $\gcd$ 消掉，这里通过欧拉反演，即 $\varphi*I=id$ （证明的话把 $1\dots n$ 的数按与 $n$ 的 $\gcd$ 分类）。当然也可以直接减掉倍数好像还更方便。那么简单推下式子：
$$
\begin{aligned}
&\sum\limits_T\left(\sum\limits_{i=1}^{n-1}w_{e_i}\right)\times\gcd(w_{e_1},w_{e_2},\dots,w_{e_{n-1}})\\
=&\sum\limits_T\left(\sum\limits_{i=1}^{n-1}w_{e_i}\right)\times\sum\limits_{d|\gcd(w_{e_1},w_{e_2},\dots,w_{e_{n-1}})}\varphi(d)\\
=&\sum\limits_{d=1}^{w_{max}}\varphi(d)\sum\limits_{ T\wedge\forall i,d|w_{e_i}}\left(\sum\limits_{i=1}^{n-1}w_{e_i}\right)
\end{aligned}
$$
我们枚举 $d$ ，每次找出所有 $w_i$ 为 $d$ 的倍数的边，我们现在需要求出仅由这些边构成的生成树的边权和的和。对于这个，我们构造一个模 $x^2$ 意义下的多项式矩阵，对每条边重新定义边权为 $1+w_ix$ 。基尔霍夫矩阵的主余子式等于 $\sum\limits_T\prod\limits_{i=1}^{n-1}w_i$ （这个我不会证明），那么我们把重新定义的边权带进去发现一次项系数就是我们要求的边权和之和。

然后我们考虑 $\bmod x^2$ 意义下的多项式四则运算，加减法没有区别，乘法：$(a+bx)(c+dx)=ac+(ad+bc)x$，除法：$\frac{a+bx}{c+dx}=\frac{a}{c}+\frac{bc-ad}{c^2}x$ （证明的话乘一个 $c+dx$ 就好了）。当 $c=0$ 怎么办？对于选取每一行的主元，我们找到不为0的次数最低的那一项，如果次数为0那么就直接做，如果为1说明这一列在当前行后面的常数项都为0，此时除法应该特判为 $\frac{bx}{dx}=\frac{b}{d}$（我不是很确定这里的必要性，代码是否特判都过了）。这样的话对 $1-w_{max}$ 都做一遍矩阵树复杂度是 $O(wn^3)$ 的，我们可以做一个剪枝，当添加入的边大于等于 $n-1$ 时才去做矩阵树，这样的复杂度是 $O(n^3\max\sigma_0w)$ 即 $144\times n^3$ ，可以通过本题。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int const N=152501,p=998244353;
int n,u[2505],v[2505],w[2505],phi[N+5],pr[50005],cnt;
bool flag[N+5];
void init()
{
    phi[1]=1;
    for(int i=2;i<=N;i++)
    {
        if(!flag[i])pr[++cnt]=i,phi[i]=i-1;
        for(int j=1;j<=cnt&&i*pr[j]<=N;j++)
        {
            flag[i*pr[j]]=1;
            if(!(i%pr[j])){phi[i*pr[j]]=phi[i]*pr[j];break;}
            phi[i*pr[j]]=phi[i]*(pr[j]-1);
        }
    }
}
inline int mod(const int &x){return x>=p?x-p:x;}
int pw(int x,int y)
{
    int res=1;
    while(y)
    {
        if(y&1)res=1ll*res*x%p;
        x=1ll*x*x%p;
        y>>=1;
    }
    return res;
}
struct poly
{
    int x0,x1;
    poly(){x0=x1=0;}
    poly(int a,int b){x0=a,x1=b;}
    friend poly operator +(poly a,poly b)
        {return poly(mod(a.x0+b.x0),mod(a.x1+b.x1));}
    friend poly operator -(poly a,poly b)
        {return poly(mod(a.x0-b.x0+p),mod(a.x1-b.x1+p));}
    friend poly operator *(poly a,poly b)
        {return poly(1ll*a.x0*b.x0%p,mod(1ll*a.x0*b.x1%p+1ll*a.x1*b.x0%p));}
    friend poly operator /(poly a,poly b)
    {
        if(a.x0==0&&b.x0==0)
        {
            int inv=pw(b.x1,p-2);
            return poly(1ll*a.x1*inv%p,0);
        }
        int inv=pw(b.x0,p-2);
        return poly(1ll*a.x0*inv%p,((1ll*a.x1*b.x0-1ll*a.x0*b.x1)%p*inv%p*inv%p+p)%p);
    }
}mat[31][31];
int deg(poly a){return a.x0?0:(a.x1?1:2);}
int det()
{
    int f=1;
    for(int i=1;i<=n;i++)
    {
        int c=i;
        for(int j=i+1;j<=n;j++)
            if(deg(mat[j][i])<deg(mat[c][i]))c=j;
        if(c!=i)swap(mat[i],mat[c]),f*=-1;
        if(deg(mat[i][i])==2)return 0;
        for(int j=i+1;j<=n;j++)
        {
            poly t=mat[j][i]/mat[i][i];
            for(int k=i;k<=n;k++)
                mat[j][k]=mat[j][k]-mat[i][k]*t;
        }
    }
    poly res;
    if(f==1)res=poly(1,0);
    else res=poly(p-1,0);
    for(int i=1;i<=n;i++)res=res*mat[i][i];
    return res.x1;
}
int main()
{
    init();
    int m,ans=0;
    scanf("%d%d",&n,&m);
    n--;
    for(int i=1;i<=m;i++)scanf("%d%d%d",&u[i],&v[i],&w[i]);
    for(int i=1;i<=N;i++)
    {
        memset(mat,0,sizeof(mat));
        int cnt=0;
        for(int j=1;j<=m;j++)
            if(!(w[j]%i))
            {
                mat[u[j]][v[j]]=mat[u[j]][v[j]]-poly(1,w[j]);
                mat[v[j]][u[j]]=mat[v[j]][u[j]]-poly(1,w[j]);
                mat[u[j]][u[j]]=mat[u[j]][u[j]]+poly(1,w[j]);
                mat[v[j]][v[j]]=mat[v[j]][v[j]]+poly(1,w[j]);
                cnt++;
            }
        if(cnt<n)continue;
        ans=mod(ans+1ll*det()*phi[i]%p);
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：UKE_Automation (赞：1)

### P6624 [省选联考 2020 A 卷] 作业题

[$\text{Link}$](https://www.luogu.com.cn/problem/P6624)

首先看到题目中的 $\gcd$，想到欧拉反演：
$$
\begin{aligned}
ans=& \left(\sum w_{e_i} \right)\times \gcd(w_{e_i})\\
=& \left(\sum w_{e_i} \right)\times \sum_{d\mid w_{e_i}} \varphi(d)\\
=& \sum_{d=1}^{w} \varphi(d) \times \sum_{d\mid w_{e_i}} w_{e_i} 
\end{aligned}
$$
所以我们枚举一下 $\gcd$，然后保留所有是 $d$ 倍数的边，求出所有生成树边权和的和即可。这容易让我们联想到矩阵树定理，不过矩阵树定理求解的是生成树边权积之和，我们需要一些转化。最简单的想法是把边权放到指数上，构造 $x^{w_i}$，不过这样的话难以操作且复杂度过高。我们采用另一种方法，把边权记为 $w_ix+1$，这样我们只需要求出乘积的一次项系数就是边权和了。

那么这样的话我们做乘除法操作的时候就不用管二次项了，于是有如下运算规则：

- $(a+bx)(c+dx)=ac+(bc+ad)x$。
- $\dfrac{1}{a+bx}=\dfrac{b}{a}-\dfrac{b}{a^2} x$。

构造出矩阵后直接高斯消元求解行列式即可，复杂度是 $O(n^3 V)$ 的。直接跑比较紧张，我们可以用一点优化，显然只有 $d$ 的倍数出现了至少 $n-1$ 次时我们才需要求解，那么总的因子个数是 $\sum \sigma_0(w_i)$，所以我们至多跑 $\tfrac{\sum \sigma_0(w_i)}{n-1}$ 次，复杂度应该是 $O(n^2\sum \sigma_0(w_i))$ 的，上界是一个 $O(n^4\sqrt V)$，可以通过。


```cpp
#include <bits/stdc++.h>
#define il inline

using namespace std;

const int Maxn = 2e5 + 5;
const int Inf = 2e9;
const int Mod = 998244353;
il int Add(int x, int y) {return x + y >= Mod ? x + y - Mod: x + y;} il void pls(int &x, int y) {x = Add(x, y);}
il int Del(int x, int y) {return x - y < 0 ? x - y + Mod : x - y;} il void sub(int &x, int y) {x = Del(x, y);}
il int qpow(int a, int b) {int res = 1; for(; b; a = 1ll * a * a % Mod, b >>= 1) if(b & 1) res = 1ll * res * a % Mod; return res;}
il int Inv(int a) {return qpow(a, Mod - 2);}
template <typename T> il void chkmax(T &x, T y) {x = (x >= y ? x : y);}
template <typename T> il void chkmin(T &x, T y) {x = (x <= y ? x : y);}
template <typename T>
il void read(T &x) {
	x = 0; char ch = getchar(); bool flg = 0;
	for(; ch < '0' || ch > '9'; ch = getchar()) flg = (ch == '-');
	for(; ch >= '0' && ch <= '9'; ch = getchar()) x = (x << 1) + (x << 3) + (ch ^ 48);
	flg ? x = -x : 0;
}
template <typename T>
il void write(T x, bool typ = 1) {
	static short Stk[50], Top = 0;
	x < 0 ? putchar('-'), x = -x : 0;
	do Stk[++Top] = x % 10, x /= 10; while(x);
	while(Top) putchar(Stk[Top--] | 48);
	typ ? putchar('\n') : putchar(' ');
}
il void IOS() {ios::sync_with_stdio(0); cin.tie(0), cout.tie(0);}
il void File() {freopen("in.txt", "r", stdin); freopen("out.txt", "w", stdout);}
bool Beg;

int n, m;
int u[Maxn], v[Maxn], w[Maxn];
int tot[Maxn];

void divd(int x) {
	for(int i = 1; i <= x / i; i++) {
		if(x % i == 0) {
			tot[i]++;
			if(i * i != x) tot[x / i]++;
		}
	}
}
int phi[Maxn], prim[Maxn], cnt, vis[Maxn];
void init(int N) {
	phi[1] = 1;
	for(int i = 2; i <= N; i++) {
		if(!vis[i]) phi[i] = i - 1, prim[++cnt] = i;
		for(int j = 1, x; (x = prim[j] * i) <= N; j++) {
			vis[x] = 1;
			if(i % prim[j] == 0) {
				phi[x] = phi[i] * prim[j];
				break;
			}
			phi[x] = phi[i] * (prim[j] - 1);
		}
	}
}

struct Poly {
	int a, b;
	Poly operator + (Poly y) {return {Add(a, y.a), Add(b, y.b)};}
	Poly operator - (Poly y) {return {Del(a, y.a), Del(b, y.b)};}
	Poly operator * (Poly y) {return {1ll * a * y.a % Mod, Add(1ll * b * y.a % Mod, 1ll * a * y.b % Mod)};}
	Poly operator * (int y) {return {1ll * a * y % Mod, 1ll * b * y % Mod};}
	Poly inv(Poly y) {return {Inv(y.a), 1ll * (Mod - y.b) * Inv(1ll * y.a * y.a % Mod) % Mod};}
	Poly operator / (Poly y) {return *this * inv(y);}
}mat[40][40];

int Det() {
	Poly ret = {1, 0};
	for(int i = 1; i < n; i++) {
		for(int j = 1; j < n; j++) {
			if(j < i && (mat[j][j].a || mat[j][j].b)) continue;
			if(mat[j][i].a || mat[j][i].b) {
				swap(mat[i], mat[j]);
				if(i != j) ret = ret * (Mod - 1);
				break;
			}
		}
		for(int j = 1; j < n; j++) {
			if(i == j) continue;
			Poly inv = mat[j][i] / mat[i][i];
			for(int k = 1; k < n; k++) mat[j][k] = mat[j][k] - inv * mat[i][k];
		}
	}
	for(int i = 1; i < n; i++) ret = ret * mat[i][i];
	return ret.b;
}

int G(int d) {
	for(int i = 1; i <= n; i++) for(int j = 1; j <= n; j++) mat[i][j] = {0, 0};
	for(int i = 1; i <= m; i++) {
		if(w[i] % d) continue;
		mat[u[i]][v[i]] = mat[u[i]][v[i]] - (Poly){1, w[i]};
		mat[v[i]][u[i]] = mat[v[i]][u[i]] - (Poly){1, w[i]};
		mat[u[i]][u[i]] = mat[u[i]][u[i]] + (Poly){1, w[i]};
		mat[v[i]][v[i]] = mat[v[i]][v[i]] + (Poly){1, w[i]};
	}
	return Det();
}

bool End;
il void Usd() {cerr << (&Beg - &End) / 1024.0 / 1024.0 << "MB " << (double)clock() * 1000.0 / CLOCKS_PER_SEC << "ms\n"; }
int main() {
	read(n), read(m);
	int mx = 0;
	for(int i = 1; i <= m; i++) {
		cin >> u[i] >> v[i] >> w[i];
		divd(w[i]); chkmax(mx, w[i]);
	}
	init(mx);
	int ans = 0;
	for(int i = 1; i <= mx; i++) {
		if(tot[i] >= n - 1) {
			pls(ans, 1ll * phi[i] * G(i) % Mod);
		}
	}
	write(ans);
    Usd();
	return 0;
}

```

---

## 作者：TernaryTree (赞：1)

Matrix-Tree 定理板子，但是没有那么板子的应用。

---

第一步：我是推式子大师，我会大力推式子！但是欧拉反演是什么我全忘了，我们用莫反推！！

$$
\begin{aligned}
&\sum_{(v,e)\in G,(v,e) \text{ is a tree}}\left(\sum\limits_{i=1}^{n-1} w_{e_i}\right) \times \gcd(w_{e_1},w_{e_2},\dots,w_{e_{n-1}}) \\
=&\sum_{d=1}^V d \sum_{(v,e)\in G,(v,e) \text{ is a tree}}\sum_{i=1}^{n-1}w_{e_i}\left[\gcd(w_{e_1},w_{e_2},\dots,w_{e_{n-1}})=d\right]
\end{aligned}
$$

定义 $G_d$ 为 $G$ 关于所有边权为 $d$ 倍数的边的导出子图，则原式化得

$$
\begin{aligned}
=&\sum_{d=1}^V d \sum_{(v,e)\in G_d,(v,e) \text{ is a tree}}\sum_{i=1}^{n-1}w_{e_i}\left[\gcd(\dfrac{ w_{e_1}}d,\dfrac{w_{e_2}}d,\dots,\dfrac{w_{e_{n-1}}}d)=1\right] \\

=&\sum_{d=1}^V d \sum_{(v,e)\in G_d,(v,e) \text{ is a tree}}\sum_{i=1}^{n-1}w_{e_i}\sum_{k\mid \frac{ w_{e_1}}d,\frac{w_{e_2}}d,\dots,\frac{w_{e_{n-1}}}d}\mu(k) \\

=&\sum_{d=1}^V d \sum_{(v,e)\in G_d,(v,e) \text{ is a tree}}\sum_{i=1}^{n-1}w_{e_i}\sum_{dk\mid w_{e_1},w_{e_2},\dots,w_{e_{n-1}}}\mu(k) \\

=&\sum_{d=1}^V d \sum_{k=1}^{\lfloor\frac Vd\rfloor}\mu(k)\sum_{(v,e)\in G_{dk},(v,e) \text{ is a tree}}\sum_{i=1}^{n-1}w_{e_i} \\

=&\sum_{T=1}^V \sum_{d\mid T}d\mu\left(\dfrac Vd\right)\sum_{(v,e)\in G_{T},(v,e) \text{ is a tree}}\sum_{i=1}^{n-1}w_{e_i} \\

=&\sum_{T=1}^V \varphi(T)\sum_{(v,e)\in G_{T},(v,e) \text{ is a tree}}\sum_{i=1}^{n-1}w_{e_i} \\
\end{aligned}
$$

这个时候我们去枚举前面的 $T$，对应计算 $G_T$ 中所有生成树的边权和之和。但是 Matrix-Tree 定理是计算边权积之和的，我们考虑如何去处理这个东西。

一个巧妙的 trick：将边权表示为 $1+w_ix$ 的少项式格式，这个时候我们有

$$\prod (1+w_ix)=1+\left(\sum w_i\right)x+\dots $$

那么我们就可以去维护一个一次少项式作为矩阵里面的元素进行运算计算出行列式，从而得到答案。让我们看看一次少项式的基本运算：

- 加法：$(a+bx)+(c+dx)=(a+c)+(b+d)x$
- 减法：$(a+bx)-(c+dx)=(a-c)+(b-d)x$
- 乘法：$(a+bx)\times (c+dx)=ac+(ad+bc)x+bdx^2\equiv ac+(ad+bc)x\pmod {x^2}$
- 除法：不妨设 $(a+bx)\div (c+dx)=e+fx$，则有 $(c+dx)\times (e+fx)\equiv a+bx\pmod {x^2}$；展开得到 $ce+(cf+de)x=a+bx$，所以 $e=\dfrac ac$，$cf+de=b$，代入并化简可以得到 $f=\dfrac{bc-ad}{c^2}$。所以，$(a+bx)\div (c+dx)=\dfrac ac+\dfrac{bc-ad}{c^2}x$。

这样我们用一个少项式矩阵就能计算出一张图所有生成树边权和之和了。同时注意到如果 $G_T$ 的边数 $\lt n-1$ 时其无法连通，也就不存在生成树，所以这样的情况可以直接不用算；剩下的 $T$ 的个数就只有 $n\cdot d(V)$ 个了（其中 $d(x)$ 表示因数个数）。于是总复杂度 $\Theta(n^4d(V)+V\log V)$，可以通过此题。

[Code](https://www.luogu.com.cn/paste/vzt43hog)。


---

## 作者：RainWetPeopleStart (赞：0)

好题。

首先，看到是生成树相关，且 $n\le 30$，考虑矩阵树定理。

此时我们需要转化 $\gcd$ 和边权和的限制。

$\gcd$ 可以使用欧拉反演，有：

$$\gcd(w_1,w_2,\dots,w_k)=\sum\limits_{i\mid \gcd(w_1,w_2,\dots,w_k)}\varphi(i)$$

接下来交换求和号，先枚举上文的 $i$，把满足边权 $w$ 是 $i$ 的倍数的边取出来，接下来就只需考虑边权和的限制。

先考虑有边权时矩阵树会变的怎样，考虑把边权 $w$ 看成 $w$ 条边权为 $1$ 的边，则此时用矩阵树定理就相当于求生成树边权积的和。

如何把边权和变成积的形式呢？

考虑一个创造性的思路，用一次函数 $wx+1$ 来代替边权 $w$。

这样最后结果的一次项就是生成树边权和的和。

因为要求行列式，这里定义一下一次函数的“运算”：


加法：$(ax+b)+(cx+d)=(a+c)x+(b+d)$

减法：$(ax+b)-(cx+d)=(a-c)x+(b-d)$

乘法：$(ax+b)(cx+d)=(ad+bc)x+bd$（因为我们不关心二次项）

求逆：$(ax+b)^{-1}=-\dfrac{ax}{b^2}+\dfrac{1}{b}$（类似多项式求逆）

除法是“被除数”乘上“除数”的逆。

如果要取反，直接乘 $-1$ 即可。

那这样就做完了，复杂度 $O(mV+n^3V)$，可能会被卡。

此时我们可以加剪枝，若我们选不出 $n-1$ 条边就 `continue` 掉，就可以把复杂度优化到 $mV+n^3m\dfrac{\max d(V)}{n-1}$，如果对找可用的边进行优化就可以 $V\log V+n^3m\dfrac{\max d(V)}{n-1}$，可以通过。

代码：


```cpp
#include<bits/stdc++.h>
#define ll long long
#define pii pair<int,int>
#define mk make_pair
#define fi first
#define se second
#define db long double
using namespace std;
const int N=2e5+10,mod=998244353;
void Add(int &a,int b){a+=b;if(a>=mod) a-=mod;}
void Sub(int &a,int b){a-=b;if(a<0) a+=mod;}
void Mul(int &a,int b){a=1ll*a*b%mod;}
int qp(int a,int b){
    int x=1;
    while(b){
        if(b&1) Mul(x,a);
        Mul(a,a);b>>=1;
    }return x;
}
int n,m;
struct edge{
    int u,v,w;
}e[1050];
struct info{
    int a,b;//ax+b
    friend info operator+(info a,info b);
    friend info operator-(info a,info b);
    friend info operator*(info a,info b);
    friend info operator/(info a,info b);
};
info operator+(info a,info b){
    return (info){(a.a+b.a)%mod,(a.b+b.b)%mod};
}
info operator-(info a,info b){
    return (info){(a.a-b.a+mod)%mod,(a.b-b.b+mod)%mod};
}
info operator*(info a,info b){
    return (info){(int)((1ll*a.b*b.a+1ll*a.a*b.b)%mod),(int)(1ll*a.b*b.b%mod)};
}
info operator/(info a,info b){
    return (info){(int)(1ll*qp(b.b,mod-2)*qp(b.b,mod-2)%mod
        *(mod-b.a)%mod),qp(b.b,mod-2)}*a;
}//(ax+b)(-a/b^2 x+1/b)=1(mod x^2)

info A[50][50];
info gak(){
    info res=(info){0,1};
    //for(int i=1;i<=n-1;i++){
    //    for(int j=1;j<=n-1;j++){
    //        cout<<A[i][j].a<<' ';
    //    }cout<<endl;
    //}
    for(int col=1;col<=n-1;col++){
        int row=col;
        for(int i=row+1;i<n;i++){
            if(A[i][col].b!=0){
                for(int j=1;j<n;j++){
                    swap(A[row][j],A[i][j]);
                }res=res*(info){0,mod-1};
            }
        }//cout<<A[row][col].b<<endl;
        if(A[row][col].b==0&&col!=n-1) return (info){0,0};
        for(int i=row+1;i<n;i++){
            info val=A[i][col]/A[row][col];
            //cout<<col<<' '<<val.a<<' '<<val.b<<endl;
            for(int j=col;j<n;j++){
                //cout<<"! "<<i<<' '<<j<<' '<<(val*A[row][j]).a<<' '<<(val*A[row][j]).b<<endl;
                A[i][j]=A[i][j]-(val*A[row][j]);
            }
        }res=res*A[row][col];
        //cout<<res.a<<' '<<res.b<<' '<<A[row][col].a<<' '<<A[row][col].b<<endl;
    }//cout<<res.a<<endl;
    return res;
}
int phi[N];bool isp[N];
int main(){
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        cin>>e[i].u>>e[i].v>>e[i].w;
    }vector<int> p;
    for(int i=2;i<=N-10;i++){
        if(!isp[i]) p.push_back(i),phi[i]=i-1;
        for(auto j:p){
            if(i*j>N-10) break;
            phi[i*j]=phi[i]*(j-1);isp[i*j]=1;
            if(i%j==0){
                phi[i*j]=phi[i]*j;
                break;
            }
        }
    }phi[1]=1;
    int ans=0;
    for(int i=1;i<=N-10;i++){
        int cnt=0;
        for(int j=1;j<=m;j++) if(e[j].w%i==0) cnt++;
        if(cnt>=n-1){
            for(int j=1;j<=n;j++){
                for(int k=1;k<=n;k++){
                    A[j][k]=(info){0,0};
                }
            }
            for(int j=1;j<=m;j++){
                if(e[j].w%i==0){
                    int u=e[j].u,v=e[j].v,w=e[j].w;
                    A[u][u]=A[u][u]+(info){w,1};
                    A[v][v]=A[v][v]+(info){w,1};
                    A[u][v]=A[u][v]-(info){w,1};
                    A[v][u]=A[v][u]-(info){w,1};
                }
            }Add(ans,1ll*phi[i]*gak().a%mod);
            //cout<<i<<' '<<phi[i]<<endl<<endl;
        }
    }cout<<ans<<endl;
    return 0;
}
```

---

## 作者：OIer_Automation (赞：0)

对后面的 $\gcd$ 肯定是要进行反演的，但与其使用莫比乌斯反演，不如直接使用 $\varphi*1=\text{id}$，然后对原式进行改写：
$$
\begin{aligned}&\sum_{T}(\sum_{i}w_{e_i})\times \gcd(w_{e_1},w_{e_2},\cdots,w_{e_{n-1}})\\=&\sum_{T}(\sum_{i}w_{e_i})\sum_{d|w_{e_1},d|w_{e_2},\cdots,d|w_{e_{n-1}}}\varphi(d)\\=&\sum_{d=1}^{V}\varphi(d)\sum_{T}[d|w_{e_1},d|w_{e_2},\cdots,d|w_{e_{n-1}}]\sum_{i}w_{e_i} \end{aligned}
$$
综上，我们只需要求出所有边权都是 $d$ 的倍数的生成树的边权和即可。考虑到矩阵树定理求解的内容是树的边权积的和，因此需要考虑转化。考虑将贡献拆成每一条边在多少个生成树中出现，即贡献为 $w_i$ 成生成树的数量。考虑构造边权 $W=w_ix+1$，然后正常使用矩阵树定理之后求一次项系数即可，正确性是显然的。事实上，因为只用求一次项系数，因此维护的多项式对 $x^2$ 取模即可。考虑求解行列式需要用到的运算：
$$
\left\{\begin{aligned}&(a+bx)+(c+dx)\equiv(a+c)+(b+d)x\\&(a+bx)-(c+dx)\equiv(a-c)+(b-d)x\\&(a+bx)(c+dx)\equiv ac+(bc+ad)x\\&\frac{1}{a+bx}\equiv \frac{1}{a}-\frac{b}{a^2}x \end{aligned}\right.\pmod{x^2}
$$
最后一个运算用待定系数法可以简单得到，然后我们可以在 $O(n^3V)$ 的复杂度内求出答案，这可能比较紧张，但我们可以只对拥有多于 $n-1$ 条边的边权是其倍数的 $d$ 求解，这样复杂度降为 $O(n^3\dfrac{\sum\sigma(w)}{n-1}=n^2\sum\sigma(w))$，可以通过并且上界很松。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define il inline
#define ll long long
#define pii pair<int,int>
#define fi first
#define se second

const int N=35,M=440,K=152505,P=998244353;

il int Add(int x,int y){int v=x+y;return v>=P?v-P:v;}
il int Dec(int x,int y){int v=x-y;return v<0?v+P:v;}
il int Qpow(int a){int res=1;for(int b=P-2;b;b>>=1,a=1ll*a*a%P)if(b&1)res=1ll*res*a%P;return res;}
pii operator +=(pii &a,pii b){return a={Add(a.fi,b.fi),Add(a.se,b.se)};}
pii operator -=(pii &a,pii b){return a={Dec(a.fi,b.fi),Dec(a.se,b.se)};}
pii operator *(pii a,pii b){return {(1ll*a.fi*b.se+1ll*a.se*b.fi)%P,1ll*a.se*b.se%P};}
pii operator *=(pii &a,pii b){return a=a*b;}

int n,m,V,cnt;
int st[M],en[M],dst[M],tot[K],prm[K],phi[K];
pii g[N][N];
bitset<K>isp;

il void Divs(int x){for(int d1=1,d2;d1<=(d2=x/d1);d1++)if(d1*d2==x)tot[d1]++,tot[d2]+=d1!=d2;}
il void Init(){
	phi[1]=1;
	for(int i=2;i<=V;i++){
		if(!isp[i])prm[++cnt]=i,phi[i]=i-1;
		for(int j=1,v;(v=i*prm[j])<=V&&(isp[v]=1);j++){
			if(i%prm[j])phi[v]=phi[i]*(prm[j]-1);
			else{phi[v]=phi[i]*prm[j];break;}
		}
	}
}
il int Gauss(){
	pii res={0,1};
	for(int i=1;i<n;i++){
		for(int j=i;j<n;j++)if(g[j][i].se){
			if(i!=j)swap(g[i],g[j]),res={0,P-res.se};
			break;
		}
		if(!g[i][i].se)return 0;
		int inv=Qpow(g[i][i].se);pii Inv={P-1ll*g[i][i].fi*inv%P*inv%P,inv};
		for(int j=i+1;j<n;j++){
			pii tmp=g[j][i]*Inv;
			for(int k=i;k<n;k++)g[j][k]-=tmp*g[i][k];
		}
	}
	for(int i=1;i<n;i++)res*=g[i][i];
	return res.fi;
}
il int Solve(int d){
	for(int i=0;i<=n;i++)for(int j=0;j<=n;j++)g[i][j]={0,0};
	for(int i=1;i<=m;i++)if(dst[i]%d==0){
		int u=st[i],v=en[i];pii w={dst[i],1};
		g[u][u]+=w,g[v][v]+=w,g[u][v]-=w,g[v][u]-=w;
	}
	return Gauss();
}

int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=m;i++)cin>>st[i]>>en[i]>>dst[i],Divs(dst[i]),V=max(V,dst[i]);
	ll ans=0;Init();
	for(int i=1;i<=V;i++)if(tot[i]>=n-1)ans+=1ll*phi[i]*Solve(i)%P;
	cout<<ans%P;
}
```

---

## 作者：mskqwq (赞：0)

先不管式子右边的 $\gcd$，先想办法求出所有生成树的边权和。一种暴力是去枚举每一条边，把它两个端点的点合并后对剩下的图做生成树计数，复杂度 $O(n^5)$。

回顾矩阵树定理，它能求出所有生成树的边权之积的和，那么我们就想办法把加法改成乘积。既然我们要对每条边都算一次必须包含它的生成树数量，那么我们把每条边的权值改成 $w_ix+1$ 这个多项式，这样拉普拉斯矩阵的行列式的一次项系数就是我们要求的东西。

于是我们只需在高斯消元的过程中在模 $x^2$ 下做多项式运算就行了。值得注意的是可能会出现常数项为 $0$ 无法求逆的情况，这时把一次项看作常数项继续消元就行。

接下来处理 $\gcd$，注意到值域不大，按照套路枚举一个 $k$，计算 $\gcd \mid k$ 的生成树的权值和再乘上莫比乌斯函数。那么复杂度为 $O(n^3\sum d(w_i))$，如果权值整除 $k$ 的边集不能使图联通的话就不计算，那么实际远远达不到这个上界。

```cpp
#include <set>
#include <map>
#include <queue>
#include <ctime>
#include <cstdio>
#include <vector>
#include <cassert>
#include <cstring>
#include <algorithm>
#define fi first
#define se second
#define ep emplace
#define MISAKA main
#define ll long long
#define eb emplace_back
#define pii pair<int,int>
#define rg(x) x.begin(),x.end()
#define pc(x) __builtin_popcount(x)
#define rep(i,a,b) for(int i=(a);i<=(b);++i)
#define _rep(i,a,b) for(int i=(a);i>=(b);--i)
#define debug(...) fprintf(stderr,__VA_ARGS__)
#define FIO(FILE) freopen(FILE".in","r",stdin),freopen(FILE".out","w",stdout)
using namespace std;
bool __st;
inline int read(){
    char c=getchar();int f=1,x=0;
    for(;c<48||c>57;c=getchar())if(c=='-') f=-1;
    for(;47<c&&c<58;c=getchar()) x=(x<<3)+(x<<1)+(c^48);
    return x*f;
}
const int N=35,mod=998244353,V=152501;
int n,m,cnt,fa[N];ll f[V+5],ans;
vector<tuple<int,int,int>> e;
int find(int x){for(;x^fa[x];x=fa[x]=fa[fa[x]]);return x;}
void mg(int x,int y){if((x=find(x))^(y=find(y)))fa[x]=y,cnt--;}
ll qp(ll a,ll b){ll r=1;for(;b;b>>=1,a=a*a%mod)if(b&1)r=r*a%mod;return r;}
struct poly{
    ll a,b;
    poly(ll x=0,ll y=0){a=x,b=y;}
    void operator+=(poly x){a=(a+x.a)%mod,b=(b+x.b)%mod;}
    friend poly operator-(poly a,poly b){return poly((a.a-b.a+mod)%mod,(a.b-b.b+mod)%mod);}
    friend poly operator-(poly a){return poly(mod-a.a,mod-a.b);}
    friend poly operator*(poly a,poly b){return poly((a.a*b.b+a.b*b.a)%mod,a.b*b.b%mod);}
    friend poly operator/(poly a,poly b){
        ll iv=qp(b.b,mod-2);
        return poly((a.a*iv+mod-a.b*b.a%mod*iv%mod*iv%mod)%mod,a.b*iv%mod);
    }
    void print(){debug("%lld %lld\n",a,b);}
};
struct mat{
    poly m[N][N];
    mat(){memset(m,0,sizeof(m));}
    poly* operator[](int x){return m[x];}
    ll det(int n){
        poly r(0,1),a[N][N];
        memcpy(a,m,sizeof(m));
        rep(i,1,n){
            int flag=1;
            if(!a[i][i].b){
                flag=0;
                rep(j,i+1,n)if(a[j][i].b)
                    {swap(a[i],a[j]),r=-r,flag=1;break;}
            }
            if(!flag&&!a[i][i].a){
                rep(j,i+1,n)if(a[j][i].a)
                    {swap(a[i],a[j]),r=-r,flag=-1;break;}
            }
            if(!flag) return 0;
            rep(j,i+1,n){
                poly t=flag==1?a[j][i]/a[i][i]:poly(0,a[j][i].a*qp(a[i][i].a,mod-2)%mod);
                rep(k,1,n) a[j][k]=a[j][k]-a[i][k]*t;
            }
        }
        rep(i,1,n) r=r*a[i][i];
        return r.a;
    }
};
void misaka(){
    n=read(),m=read();
    rep(i,1,m){
        int u=read(),v=read(),w=read();
        e.eb(u,v,w);
    }
    _rep(i,V,1){
        mat m;cnt=n;
        rep(j,1,n) fa[j]=j;
        for(auto [u,v,w]:e)if(w%i==0){
            mg(u,v);poly t(w,1);
            m[u][u]+=t,m[v][v]+=t;
            m[u][v]+=-t,m[v][u]+=-t;
        }
        if(cnt^1) continue;
        f[i]=m.det(n-1);
        for(int j=i*2;j<=V;j+=i) f[i]=(f[i]+mod-f[j])%mod;
    }
    rep(i,1,V) (ans+=f[i]*i)%=mod;
    printf("%lld",ans);
}
bool __ed;
signed MISAKA(){
    #ifdef LOCAL_MSK
    atexit([](){
    debug("\n%.3lfs ",(double)clock()/CLOCKS_PER_SEC);
    debug("%.3lfMB",abs(&__st-&__ed)/1024./1024);});
    #endif
    int T=1;
    while(T--) misaka();
    return 0;
}

```

---

## 作者：Purslane (赞：0)

# Solution

首先，考虑莫比乌斯反演，得到：

$$
\begin{aligned}
\sum_{T} (\sum_{e \in T} w_e) \gcd_{e \in T}( w_e) & = \sum_{d=1}^V d \sum_{T} (\sum_{e \in T} w_e) [\gcd_{e \in T}( w_e)=d] \\
&= \sum_{d=1}^V d \sum_{t=1}^V \mu(t) f(dt) \\
&= \sum_{i=1}^V f(i) (\mu \times Id)(i) \\
&= \sum_{i=1}^V f(i) \varphi(i)
\end{aligned}
$$

其中，$f(x)$ 表示只考虑所有边权为 $x$ 的整数倍的边，其所有生成树的边权和的和。

考虑矩阵树定理求的是所有生成树边权积的和。如何把转化为边权和的和？

> 写给自己的：如果仅求生成树的个数，可以把重边的数量当做这条边的边权。于是就把不同形式的矩阵树定理统一了。

下面一步操作是我想不到的。考虑一次函数 $h_i(x) = w_i x +1$。那么得到

$$[x]\prod_{i=1}^m h_i(x) = \sum_{i=1}^m w_i$$

利用基本的多项式，我们实现了加与和之间的转化。

那么我们只需要把 $w_ex+1$ 当做边 $e$ 的边权，套用矩阵树定理。

不过还有一个问题：再求行列式的时候，我们利用了“逆元操作”，然而一般意义下一次多项式的逆元是一个无穷级数，很显然无法在本题中套用。但是容易发现，我们只需要求出这些多项式的积对 $x^2$ 取模的结果。

一个一次函数 $ax+b$ 在模 $x^2$ 意义下的逆元是 $\dfrac{-ax+b}{b^2}$。特别地，当 $b=0$ 的时候我们认为它没有逆元。

本质上你定义了一个“数对”$(a,b)$ 满足这样的性质：

$(a_1,b_1) \pm (a_2,b_2) = (a_1 \pm b_1,a_2 \pm b_2)$，$(a_1,b_1) \times (a_2,b_2) = (a_1 b_2 + a_2 b_1 , b_1 b_2)$ 以及 $\dfrac{1}{(a,b)} = (-\dfrac{a}{b^2},\dfrac{1}{b})$。我们刚才就是在这个数对的域中求行列式的值。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MOD=998244353,MAXN=30+5,MAXV=160000+10;
int n,m,ans,phi[MAXV],flg[MAXV];
vector<int> pr;
void init(int Mx) {
	phi[1]=1;
	ffor(i,2,Mx) {
		if(!flg[i]) phi[i]=i-1,pr.push_back(i);
		for(auto v:pr) {
			if(i*v>Mx) break ;
			flg[i*v]=1;
			if(i%v==0) {phi[i*v]=phi[i]*v;break ;}
			phi[i*v]=phi[i]*(v-1);
		}
	}
	return ;
}
vector<pair<int,int>> ed[MAXV];
struct Pair {int a,b;}mat[MAXN][MAXN];
int qpow(int base,int p) {
	int ans=1;
	while(p) {
		if(p&1) ans=ans*base%MOD;
		base=base*base%MOD,p>>=1;
	}
	return ans;
}
Pair inv(Pair v) {
	int _inv=qpow(v.b,MOD-2);
	return {-v.a*_inv%MOD*_inv%MOD,_inv};	
}
Pair operator +(Pair A,Pair B) {return {(A.a+B.a)%MOD,(A.b+B.b)%MOD};}
Pair operator -(Pair A,Pair B) {return {(A.a-B.a)%MOD,(A.b-B.b)%MOD};}
Pair operator *(Pair A,Pair B) {return {(A.a*B.b+B.a*A.b)%MOD,A.b*B.b%MOD};}
Pair operator /(Pair A,Pair B) {assert(((A*inv(B))*B-A).a==0&&((A*inv(B))*B-A).b==0); return A*inv(B);}
int solve() {
	Pair ans={0,1};
	ffor(i,1,n-1) {
		if(mat[i][i].b==0) {
			ffor(j,i+1,n-1) if(mat[j][i].b) {
				swap(mat[i],mat[j]),ans.b=-ans.b;
				break ;
			}
			if(mat[i][i].b==0) return 0;
		}
		ffor(j,i+1,n-1) if(mat[j][i].a||mat[j][i].b) {
			Pair mul=mat[j][i]/mat[i][i];
			ffor(k,i,n-1) mat[j][k]=(mat[j][k]-(mat[i][k]*mul));
		}
	}
	ffor(i,1,n-1) ans=ans*mat[i][i];
	return ans.a;
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	ffor(i,1,m) {
		int u,v,w;
		cin>>u>>v>>w;
		ed[w].push_back({u,v});	
	}
	init(160000);
	ffor(i,1,160000) {
		vector<pair<pair<int,int>,int>> vc;
		ffor(j,1,160000/i) for(auto pr:ed[i*j]) vc.push_back({pr,i*j});
		if(vc.size()>=n-1) {
			memset(mat,0,sizeof(mat));
			for(auto id:vc) mat[id.first.first][id.first.second]=mat[id.first.second][id.first.first]={-id.second,-1},mat[id.first.first][id.first.first]=mat[id.first.first][id.first.first]+Pair{id.second,1},mat[id.first.second][id.first.second]=mat[id.first.second][id.first.second]+Pair{id.second,1};	
			ans=(ans+phi[i]*solve())%MOD;
		}
	}
	cout<<(ans%MOD+MOD)%MOD;
	return 0;
}
```

注意：所谓的“度数矩阵”更加准确的说应该是“所有临边边权之和”。

---

## 作者：qczrz6v4nhp6u (赞：0)

### Solution

生成树相关的计数，考虑 Matrix-Tree 定理。

然而这个 $\gcd$ 很烦。考虑消掉 $\gcd$，自然想到莫反。

$$\begin{aligned}
&\sum(\sum_{i=1}^{n-1}w_{e_i})\times\gcd(w_{e_1},w_{e_2},\cdots,w_{e_{n-1}})\\
=&\sum(\sum_{i=1}^{n-1}w_{e_i})\times(\sum _{\mathclap{d|\gcd(w_{e_1},w_{e_2},\cdots,w_{e_{n-1}})}}\varphi(d))\\
=&\sum_{d}\varphi(d)\sum[d|w_{e_1}\land d|w_{e_2}\land\cdots\land d|w_{e_{n-1}}]\sum_{i=1}^{n-1} w_{e_i}
\end{aligned}$$

枚举 $d$，将满足 $d|w_e$ 的边加入到图中，再统计所有生成树的边权和。

但是 Matrix-Tree 定理的适用范围是元素的集合 $\mathcal S$，元素的加法 $+$、乘法 $\times$ 构成的代数结构 $({\mathcal S},+,\times)$ 是交换环。$({\mathbb Z},+,+)$ 显然不是交换环，我们需要另外构造一个交换环。

我们用一个二元组 $(a,b)$ 表示，其中 $a$ 是生成树边权和，$b$ 是生成树个数。则我们可以定义加法、乘法及其单位元：

- $(a,b)+(c,d)=(a+c,b+d)$。

- $(a,b)\times (c,d)=(ad+bc,bd)$。

- 加法单位元 $0=(0,0)$。

- 乘法单位元 $1=(0,1)$。

设 ${\mathcal N}=\{(a,b)|a,b\in \mathbb Z\}$，则 $({\mathcal N},+,\times)$ 是交换环，其中对于任意 $(a,b)$，存在加法逆元 $(-a,-b)$；对于 $b\ne 0$，$(a,b)$ 存在乘法逆元 $(-\frac{a}{b^2},\frac{1}{b})$。

至于证明，将 $(a,b)$ 写成矩阵的形式就随便证了。

然而复杂度是 $O(n^3w)$ 的，T 飞。我们只在加入的边数大于等于 $n-1$ 时求行列式，这样的复杂度是 $O(n^3\times \frac 1n\sum d(w))\le O(n^4\max d(w))$ 的，加上跑不满，可以通过。

### Code

跑得飞快，目前是次优解。

```cpp
bool _Start;
#include<bits/stdc++.h>
#define Tp template<typename T>
#define Ts template<typename T,typename... _T>
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned int uint;
char ibuf[1<<20],*p1=ibuf,*p2=ibuf,obuf[1<<20],*p3=obuf,*p4=obuf+(1<<20);
#define getchar() (p1==p2&&(p2=ibuf+fread(p1=ibuf,1,1<<20,stdin),p1==p2)?EOF:*p1++)
#define flush() (fwrite(obuf,1,p3-obuf,stdout),p3=obuf)
#define putchar(c) (*p3++=c,p3==p4&&flush())
struct IO{~IO(){flush();}}_;
Tp inline void read(T &x){
	x=0;static char c;static bool f;
	c=getchar(),f=0;
	for(;c<48||c>57;c=getchar())f|=c=='-';
	for(;c>47&&c<58;c=getchar())x=x*10+(c^48);
	if(c=='.'){
		static long double s;s=0.1;
		for(c=getchar();c>47&&c<58;c=getchar(),s/=10)x+=s*(c^48);
	}
	f&&(x=-x);
}
Ts inline void read(T &x,_T&... y){read(x),read(y...);}
Tp inline void write_uns(const T &x){
	if(x>9)write_uns(x/10);
	putchar(x%10^48);
}
Tp inline void write(const T &x){
	if(x<0)putchar('-'),write_uns(~x+1);
	else write_uns(x);
}
Tp inline void writesp(const T &x){write(x),putchar(' ');}
Tp inline void writeln(const T &x){write(x),putchar('\n');}
Ts inline void writesp(const T &x,const _T&... y){writesp(x),writesp(y...);}
Ts inline void writeln(const T &x,const _T&... y){writesp(x),writeln(y...);}
Tp inline void assign(T *a,int n,const T &b){while(n--)*a++=b;}
Tp inline void copy(T *a,const T *b,int n){while(n--)*a++=*b++;}
Tp inline T min(const T &a,const T &b){return a<b?a:b;}
Tp inline T max(const T &a,const T &b){return b<a?a:b;}
Ts inline T min(const T &a,const T &b,const _T&... c){return min(min(a,b),c...);}
Ts inline T max(const T &a,const T &b,const _T&... c){return max(max(a,b),c...);}
Tp inline T abs(const T &a){return max(a,-a);}
Tp inline T gcd(const T &a,const T &b){return !a?b:(!b?a:gcd(b,a%b));}
Tp inline T lcm(const T &a,const T &b){return a*b/gcd(a,b);}
Ts inline T gcd(const T &a,const T &b,const _T&... c){return gcd(gcd(a,b),c...);}
Ts inline T lcm(const T &a,const T &b,const _T&... c){return lcm(lcm(a,b),c...);}
Tp inline void ckmin(T &a,const T &b){b<a&&(a=b);}
Tp inline void ckmax(T &a,const T &b){a<b&&(a=b);}
constexpr int N=35,M=N*N+5,W=2e5+5,mod=998244353,imod=mod-2;
ll qpow(ll a,ll b){
	ll res=1;
	for(;b;b>>=1,a=a*a%mod)
		if(b&1)res=res*a%mod;
	return res; 
}
struct Mat{
	ll a,b;
	Mat(){a=b=0;}
	Mat(ll _a,ll _b){a=_a,b=_b;}
	friend Mat operator +(const Mat &u,const Mat &v){
		return Mat((u.a+v.a)%mod,(u.b+v.b)%mod);
	}
	friend Mat operator -(const Mat &u,const Mat &v){
		return Mat((u.a-v.a+mod)%mod,(u.b-v.b+mod)%mod);
	}
	friend Mat operator *(const Mat &u,const Mat &v){
		return Mat((u.a*v.b+u.b*v.a)%mod,u.b*v.b%mod);
	}
	friend Mat operator /(const Mat &u,const Mat &v){
		ll id=qpow(v.b,imod);
		return Mat((u.a*v.b-u.b*v.a%mod+mod)%mod*id%mod*id%mod,u.b*id%mod);
	}
	operator bool(){
		return b;
	}
};
const Mat zero=Mat(0,0),eps=Mat(0,1);
Mat mat[N][N];
// Mat of the Mat.
ll det(int n){
	Mat res=eps;
	for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++)
			if(mat[j][i]){
				std::swap(mat[i],mat[j]),i!=j&&(res=zero-res);
				break;
			}
		if(!mat[i][i])return 0;
		Mat inv=eps/mat[i][i];
		for(int j=i+1;j<=n;j++){
			Mat d=mat[j][i]*inv;
			for(int k=i;k<=n;k++)
				mat[j][k]=mat[j][k]-d*mat[i][k];
		}
		res=res*mat[i][i];
	}
	return res.a;
}
int p[W],plen,phi[W];bool v[W];
void sieve(int n){
	phi[1]=1;
	for(int i=2;i<=n;i++){
		if(!v[i])p[++plen]=i,phi[i]=i-1;
		for(int j=1;i*p[j]<=n;j++){
			v[i*p[j]]=1;
			if(i%p[j]==0){
				phi[i*p[j]]=phi[i]*p[j];
				break;
			}
			phi[i*p[j]]=phi[i]*(p[j]-1);
		}
	}
}
struct edge{
	int x,y,z;
	edge(){x=y=z=0;}
	edge(int _x,int _y,int _z){x=_x,y=_y,z=_z;}
};
edge e[M];
int n,m,cnt[W];
bool _End;
int main(){
	fprintf(stderr,"Static Memory = %.4lf MiB\n",abs(&_Start-&_End)/1048576.0);
	read(n,m);
	int w=0;
	for(int i=1;i<=m;i++){
		read(e[i].x,e[i].y,e[i].z);
		ckmax(w,e[i].z);
		for(int j=1;j*j<=e[i].z;j++)
			if(e[i].z%j==0){
				++cnt[j];
				if(j*j!=e[i].z)++cnt[e[i].z/j];
			}
	}
	sieve(w);
	ll ans=0;
	for(int d=1;d<=w;d++){
		if(cnt[d]<n-1)continue;
		for(int i=1;i<=m;i++){
			if(e[i].z%d)continue;
			int x=e[i].x,y=e[i].y;Mat z=Mat(e[i].z,1);
			mat[x][y]=mat[x][y]-z;
			mat[y][x]=mat[y][x]-z;
			mat[x][x]=mat[x][x]+z;
			mat[y][y]=mat[y][y]+z;
		}
		ans=(ans+phi[d]*det(n-1))%mod;
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				mat[i][j]=zero;
	}
	writeln(ans);
	return 0;
}
```

---

## 作者：BFSDFS123 (赞：0)

### Part 1 Matrix-Tree 定理 ###

[OI-wiki 链接](https://oi-wiki.org/graph/matrix-tree/)。

鉴于笔者水平有限，故不写证明（可以在上方链接中查看），只写结论。

对于一张图 $G$，构造一个矩阵 $D$，满足：

- $D_{i,i}=\operatorname{deg}_i$。
- $D_{i,j}=-\operatorname{cnt}_{i,j}$。

其中 $\operatorname{deg}_i$ 为 $i$ 的度数，$\operatorname{cnt}_{i,j}$ 为两点之间的边数。

将这个矩阵 $D$ **任意**去掉一行**和**一列，得到矩阵 $D'$，有矩阵 $D'$ 的行列式即为原图的生成树数量。

对于要求原图的生成树边权积之和，只需在修改 $\operatorname{deg}$ 和 $\operatorname{cnt}$ 时加上边权即可。

例题： [P4111 [HEOI2015]小 Z 的房间 ](https://www.luogu.com.cn/problem/P4111)。

### Part 2 二项式计算 ###

对于两个函数 $f_1(x)=a_1x+b_1,f_2(x)=a_2x+b_2$，其加、减、乘、除，有：

- $f(x)=f_1(x)+f_2(x)=(a_1+a_2)x+(b_1+b_2)$。
- $f(x)=f_1(x)-f_2(x)=(a_1-a_2)x+(b_1-b_2)$。
- $f(x)=f_1(x)\times f_2(x)=a_1a_2x^2+(a_1b_2+a_2b_1)x+b_1b_2$
- $f(x)=\dfrac{f_1(x)}{f_2(x)}=\dfrac{a_1b_2-b_1a_2}{{a_2}^2}x+\dfrac{a_1}{a_2}$

### Part 3 P6624 题解 ###

先考虑把 $\gcd$ 消掉。

我们有：

$$

\left(\sum_{i=1}^{n-1}w_{e_i}\right)\times \gcd (w_{e_1},w_{e_2}\dots,w_{e_{n-1}}) \\ 

= \left(\sum_{i=1}^{n-1}w_{e_i}\right) \times
\sum_{d|\gcd (w_{e_1},w_{e_2}\dots,w_{e_{n-1}})}\phi(d)
\\
= \left(\sum_{i=1}^{n-1}w_{e_i}\right)\sum_{d|\gcd (w_{e_1},w_{e_2}\dots,w_{e_{n-1}})}\phi(d)

$$

Latex 可能会炸，这是[云剪贴板的链接](https://www.luogu.com.cn/paste/7i8cu36m)。

我们的矩阵树定理能求的是**生成树边权积之和**，考虑如何将边权积化为边权和。

明显单一用数来做不太好求，考虑将边权 $w$ 看作函数 $f(x)=wx+1$。

根据 Part 2 的二项式计算，发现在乘的时候，结果的一次项的系数正好是两个 $w$ 相加，二次项对答案无关。

故我们可以在模 $x^2$ 的意义下进行乘法。

我们重新定义加减乘除，对这个矩阵进行行列式求值即可。

注意要开 ``long long``。

代码：[链接](https://www.luogu.com.cn/paste/gzb1jl82)。



---

## 作者：Illusory_dimes (赞：0)

复盘 $\color{black}{\text{n}}\color{red}{\text{ealchen}}$ 神仙讲的题。

完蛋我最近好像和生成树杠上了。

## Description

给定一个图 $G$ ，要对它所有生成树 $T$ 求这样的一个权值和：

$$val(T) = \Big(\sum_{e \in T} w_e\Big) \cdot \gcd(w_{e_1}\ ,w_{e_2}\ ,...\ ,w_{e_{n - 1}} \;\!)$$

答案对 $998244353$ 取模。

$n \leq 20,\ m \leq \frac{n (n - 1)}{2},\ w \leq 152501$

## Analysis

先反演掉烦人的 $\gcd$ ，然后大概可以通过枚举 $\gcd$ 然后去快速找单边的贡献，看起来很对/hanx

可能是目前最短的 Analysis 了。

## Solution

该换枚举 $\gcd$ ，可以直接用欧拉反演一步到位：

$$x = \sum_{d | x} \varphi(d)$$

（这是那个狄利克雷卷积的形式）

$$\sum_{T} \Big(\sum_{e \in T} w_e\Big) \cdot \gcd(w_{e_1}\ ,w_{e_2}\ ,...\ ,w_{e_{n - 1}})$$

$$\Rightarrow \sum_{T} \Big(\sum_{e \in T} w_e\Big) \cdot \sum_{d | \gcd(w_{e_1}\ ,w_{e_2}\ ,...\ ,w_{e_{n - 1}})} \varphi(d)$$

$$\Rightarrow \sum_{T} \Big(\sum_{e \in T} w_e\Big) \cdot \sum_{d = 1} ^ {\max w} \varphi(d) \cdot [d | w_{e_1} \wedge d | w_{e_2}\ \wedge...\wedge d | w_{e_{n - 1}}]$$

$$\Rightarrow \sum_{d = 1} ^ {\max w} \varphi(d) \sum_{T \wedge \forall i,d | w_{e_i}} \Big(\sum_{e \in T} w_e\Big)$$

所以现在来看目的已经很明确了，就是对于每种因数 $d$ ，我们需要所有是 $d$ 的倍数的边权，让后让他们组成生成树。

所以说我们只会求数量啊，边权和怎么办呢？

于是有这么一个 trick（算是吧），在 CF917D 里应该是出现过的，大概就是我们让基尔霍夫矩阵的数带上元 $x$ ，也就是形如 $(w_e x + 1)$ ，我们（手玩手玩）就能发现这个 $\prod$ 的一次项对应的正好是当前边权存在的次数，最终求和也就是总的边权和。

（具体是因为：对于一种树，能够生成，那么一次项就正好仅包含一条边的权值，对于每条边的元都如此，那么求合起来就是一整棵树的权值和）

具体实现也不需要多项式，应为仅保留一次项和常数项，所以一个 pair 解决一切。

剩下就是多项式的加减乘除，加减很淼，乘展开一下式子 $(ax + b)(cx + d)$ 就行了，接下来是除法：

即我们要求：假定 $ux + v = \frac{1}{cx + d}$ ，即求 $(ax + b)(ux + v)$ 。

因为只保留前两项，即可以理解为多项式在 $\text{mod}\ x ^ 2$ 的意义下。

$$(ux + v)(cx + d) \equiv 1 (\text{mod}\ x ^ 2)$$

所以就有了：

$$
	\left\{
		\begin{array}{ll}
			dv = 1 \\
			(cv + du)x = 0
		\end{array}
	\right.
$$

$x$ 不可能是零（不然有屁用啊），所以稍微解一下：

$$
	\left\{
		\begin{array}{ll}
			u = -\large\frac{c}{d ^ 2} \\
			v = \large\frac{1}{d}
		\end{array}
	\right.
$$

然后你带回 $(ax + b)(ux + v)$ 就可以啦。

## Code

```cpp
/*
 
*/
#include <bits/stdc++.h>
using namespace std;

#define File(a) freopen(a".in", "r", stdin), freopen(a".out", "w", stdout);
#define Check(a) freopen(a".in", "r", stdin), freopen(a".ans", "w", stdout);

typedef long long ll;
typedef unsigned long long ull;
typedef std::pair<int, int> pii;
#define fi first
#define se second
#define mp std::make_pair

const int mod = 998244353;
template <typename A>
inline int M(A x) {return x;}
template <typename A, typename ...B>
inline int M(A x, B ... args) {return 1ll * x * M(args...) % mod;}

const int N = 32, K = 152505;

inline int ksm(int a, int b) {
	int tm = 1;
	for (; b; b >>= 1, a = M(a, a)) if (b & 1) tm = M(tm, a);
	return tm;
}

inline pii operator + (const pii a, const pii b) {
	pii p = mp(a.fi + b.fi, a.se + b.se);
	(p.fi >= mod) && (p.fi -= mod);
	(p.se >= mod) && (p.se -= mod);
	return p;
}

inline pii operator - (const pii a, const pii b) {
	pii p = mp(a.fi - b.fi, a.se - b.se);
	(p.fi < 0) && (p.fi += mod);
	(p.se < 0) && (p.se += mod);
	return p;
}

inline pii operator * (const pii a, const pii b) {
	pii p = mp(M(a.fi, b.fi), M(a.fi, b.se) + M(a.se, b.fi));
	(p.se >= mod) && (p.se -= mod);
	return p;
}

inline pii operator / (const pii a, const pii b) {
	int in = ksm(b.fi, mod - 2);
	pii p = mp(M(a.fi, in), M(a.se, b.fi) - M(a.fi, b.se));
	(p.se < 0) && (p.se += mod); p.se = M(p.se, in, in);
	return p;
}

int n, m;
pii a[N][N];
struct mdzz {int u, v, w;} p[N * N];

inline void getpii(int di) {
	memset(a, 0, sizeof(a));

	for (int i = 1; i <= m; ++i) {
		if (p[i].w % di) continue;
		
		int u = p[i].u, v = p[i].v;
		a[u][u] = a[u][u] + mp(1, p[i].w); a[v][v] = a[v][v] + mp(1, p[i].w);
		a[u][v] = a[u][v] - mp(1, p[i].w); a[v][u] = a[v][u] - mp(1, p[i].w);
	}
}

inline int del(int n) {
	pii w = mp(1, 0);

	for (int i = 1; i <= n; ++i) {
		for (int j = i + 1; j <= n; ++j) {
			for (pii div; a[i][i].fi > 0; ) {
				div = a[j][i] / a[i][i];

				for (int k = i; k <= n; ++k) {
					a[j][k] = a[j][k] - div * a[i][k];
				}
				swap(a[i], a[j]); w = mp(0, 0) - w;
			}
			swap(a[i], a[j]); w = mp(0, 0) - w;
		}
	}

	for (int i = 1; i <= n; ++i) w = w * a[i][i];

	return w.se;
}

int cn[K], phi[K], ans;

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);

	std::cin >> n >> m;
	int mx = 0;
	for (int i = 1; i <= m; ++i) {
		std::cin >> p[i].u >> p[i].v >> p[i].w;
		mx = std::max(mx, p[i].w);

		for (int j = 1; j * j <= p[i].w; ++j) {
			if (p[i].w % j) continue;
			++cn[j];
			(j * j != p[i].w) && (++cn[p[i].w / j]);
		}
	}

	phi[1] = 1;
	for (int i = 2; i <= mx; ++i) {
		if (phi[i]) continue;
		phi[i] = i - 1;

		for (int j = i << 1; j <= mx; j += i) {
			if (!phi[j]) phi[j] = j;
			phi[j] = phi[j] / i * (i - 1);
		}
	}

	for (int i = 1; i <= mx; ++i) {
		if (cn[i] < n - 1) continue;//无法作为gcd做出贡献
		getpii(i);
		ans += M(phi[i], del(n - 1));
		(ans >= mod) && (ans -= mod);
	}

	std::cout << ans << "\n";

	return 0;
}
```

深深明白自己的弱小。

---

## 作者：_Arahc_ (赞：0)


看起来比较恶心，其实不是很复杂，但是有一两步的思维……

## 题意

>  给定一个带权无向图，求其所有生成树的权值和。一棵树 $T$ 的权值的定义为（$w_i$ 为边权）：
> $$
 \left(\sum_{e\in T}^{n-1} w_{e} \right) \times \gcd(w_{e_1},w_{e_2},\ldots,w_{e_{n-1}})
 $$
> 即所有边权的和乘上所有边权的最大公约数。
>
> $n\leqslant 30,w_i\leqslant 152501$，图中无重边自环，答案对 $998244353$ 取模。

## 题解

回顾矩阵树定理可以求什么：一个图所有生成树的边权积的和。

那么我们就要想办法把它变成这样的形式。

考虑欧拉反演 $\varphi\ast 1 = \mathrm{id}$：
$$
\left(\sum_{e\in T}^{n-1} w_{e} \right) \times \sum_{ d\mid  w_{ e_1 } , w_{ e_2 } , \ldots , w_{ e_{ m-1 }}} \varphi(d)
$$
于是就可以考虑提出公约数（老生长谈了吧），记 $W = \max(w_i)$：
$$
\sum_{d}^W \varphi(d) \sum_{ d\mid  w_{ e_1 } , w_{ e_2 } , \ldots , w_{ e_{ m-1 }}} \left(\sum_{e\in T}^{n-1} w_{e} \right)
$$
枚举 $d$，然后把是 $d$ 的倍数的边加入到图中，然后求这个图的所有生成树**边权和**的和即可。但这和前面预想的有点不太一样，因为矩阵树定理是用来求所有生成树**边权积**的和的。

~~如果你全部 exp 然后 ln 回来过了那你挺厉害的，我都不知道这是否可行~~。

那么怎么求生成树边权和的和？我们考虑把和转化为另外的东西的积（当然不是 $\exp,\ln$……），我们发现，对于每一个边权 $a$，将其写成一个一次函数 $1+ax$，那么两个一次函数的积：
$$
(1+ax)(1+bx) = 1 + (a+b)x + abx^2
$$
的一次项系数就是两个一次函数的乘积。

因此在模 $x^2$ 意义下处理对一次函数的四则运算即可，最难的估计是除法：

+ 加：$(k_1x + b_1)+(k_2x + b_2) = (k_1 + k_2)x + (b_1 + b_2)$。
+ 减：同加。
+ 乘：上面有了。
+ 除：考虑它的逆元是什么：$\frac{1}{kx+b} = -\frac{k}{b^2}x + \frac{1}{b}$。

于是就可以快乐爆枚+矩阵树定理了，注意直接做是 $\mathcal O(n^3W)$ 的，理论上不能通过。但是如果 $d$ 的倍数的边权个数少于 $n-1$ 是没有必要算矩阵的，复杂度为 $\mathcal O(n^3 \frac{\sum \sigma_0 (w_i)} {n-1})$。

这个式子看起来比较玄学，根据 OEIS 的序列 [A002182](http://oeis.org/A002182)，$w$ 全部取 $110880$（有 $144$ 个约数）可以卡到一个不错的复杂度，可以变成 $n^4 \times 144$，在三秒的时限下，可以通过。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int max_n=33,max_m=200005,mod=998244353;
inline int read(){
    int x=0;bool w=0;char c=getchar();
    while(c<'0' || c>'9') w|=c=='-',c=getchar();
    while(c>='0' && c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();
    return w?-x:x;
}
inline void write(int x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10^48);
}
inline int mi(int a,int p=mod-2){
    int res=1;
    while(p){
        if(p&1) res*=a,res%=mod;
        a*=a,a%=mod,p>>=1;
    }
    return res;
}

int pr[max_m],cntp,phi[max_m];
bool isp[max_m];
inline void Getpr(int n){
    memset(isp,1,sizeof(isp)),isp[1]=0;
    phi[1]=1;
    for(register int i=2;i<=n;++i){
        if(isp[i]){
            pr[++cntp]=i,
            phi[i]=i-1;
        }
        for(register int j=1;j<=cntp && i*pr[j]<=n;++j){
            isp[i*pr[j]]=0;
            if(i%pr[j]==0){
                phi[i*pr[j]]=phi[i]*pr[j];
                break;
            }
            phi[i*pr[j]]=phi[i]*phi[pr[j]];
        }
    }
}

struct line{
    int k,b;
    line operator + (const line &b) const{
        line a=*this,res;
        res.k=(a.k+b.k)%mod,
        res.b=(a.b+b.b)%mod;
        return res;
    }
    line operator - (const line &b) const{
        line a=*this,res;
        res.k=(a.k-b.k+mod)%mod,
        res.b=(a.b-b.b+mod)%mod;
        return res;
    }
    line operator * (const line &b) const{
        line a=*this,res;
        res.k=(a.k*b.b+a.b*b.k)%mod,
        res.b=a.b*b.b%mod;
        return res;
    }
    line operator / (const line &b) const{
        line a=*this,res;
        int ivb=mi(b.b);
        res.k=(a.k*b.b%mod-a.b*b.k%mod+mod)%mod*ivb%mod*ivb%mod,
        res.b=a.b*ivb%mod;
        return res;
    }
};
inline line makel(int k,int b){
    line res;
    res.k=k,res.b=b;
    return res;
}

int n,m,W,ans;

struct matrix{
    line a[max_n][max_n];
    inline void clear(){
        for(register int i=0;i<=n;++i)
            for(register int j=0;j<=n;++j)
                a[i][j]=makel(0,0);
    }
    inline void add(int x,int y,line w){
        a[x][x]=a[x][x]+w,
        a[y][y]=a[y][y]+w,
        a[x][y]=a[x][y]-w,
        a[y][x]=a[y][x]-w;
    }
    inline int calc(){
        line res=makel(0,1);
        for(register int i=1;i<n;++i){
            int pos=i;
            while(pos<n && !a[pos][i].b)
                ++pos;
            if(pos!=i){
                swap(a[pos],a[i]);
                res=makel(0,0)-res;
            }
            for(register int j=i+1;j<n;++j){
                line tmp=a[j][i]/a[i][i];
                for(register int k=i;k<n;++k)
                    a[j][k]=a[j][k]-(a[i][k]*tmp);
            }
        }
        for(register int i=1;i<n;++i)
            res=res*a[i][i];
        return (res.k%mod+mod)%mod;
    }
}a;

struct edge{
    int u,v,w;
}e[max_m];
vector<edge> ed[max_m];

signed main(){
    n=read(),m=read();
    for(register int i=1;i<=m;++i){
        e[i].u=read(),e[i].v=read(),e[i].w=read();
        W=max(W,e[i].w);
    }
    Getpr(W);
    for(register int d=1;d<=W;++d)
        for(register int i=1;i<=m;++i)
            if(e[i].w%d==0)
                ed[d].push_back(e[i]);
    for(register int d=1;d<=W;++d){
        int _n=ed[d].size();
        if(_n<n-1) continue;
        a.clear();
        for(register int i=0;i<_n;++i)
            a.add(ed[d][i].u,ed[d][i].v,makel(ed[d][i].w,1));
        ans=(ans+phi[d]*a.calc())%mod;
    }
    write((ans%mod+mod)%mod);
    return 0;
}
```



---

## 作者：JustinRochester (赞：0)

[传送门](https://www.luogu.com.cn/problem/P6624)

好题啊，真的好题啊！

莫比乌斯反演+矩阵树定理（甚至还算加了一点点的生成函数的原理）

---

**【分析】**
--

根据题意，求对所有的树 $T$ 的值：

$\displaystyle ans=\sum_{T}val(T)=\sum_{T}(\sum_{i=1}^{n-1}w_{e_i})\gcd_{i=1}^{n-1} w_{e_i}$

> $e_i$ 表示树 $T$ 的边

由欧拉反演得：$\displaystyle n=\sum_{d\mid n}\boldsymbol \varphi(d)$

因此 $\displaystyle \gcd_{i=1}^{n-1} w_{e_i}=\sum_{d\mid \gcd_{i=1}^{n-1}w_{e_i}}\boldsymbol \varphi(d)=\sum_{\forall i\to d\mid w_{e_i}}\boldsymbol \varphi(d)$

因此 $\displaystyle ans=\sum_T(\sum_{i=1}^{n-1}w_{e_i})\sum_{\forall i\to d\mid w_{e_i}}\boldsymbol \varphi(d)$

调换枚举顺序得 $\displaystyle ans=\sum_{d\geq 1}\boldsymbol \varphi(d)\sum_T[\forall i\to d\mid w_{e_i}](\sum_{i=1}^{n-1}w_{e_i})$

于是对于每个 $w_{e_i}$ ，我们将它塞进它各因数的 `vector` 中。之后，每个数 $d$ 的 `vector` 中，存着所有边权为它倍数的边

现考虑给定一个 `vector` ，里面存着若干边，用这些边生成树的权值和为多少，即 $\displaystyle f(d)=\sum_{T\in v_d}(\sum_{i=1}^{n-1}w_{e_i})$

$\because \displaystyle \sum_{i=1}^{n-1}w_{e_i}=\sum_{i=1}^{n-1}w_{e_i}\cdot 1$

若令 $P_i(x)=1+w_{e_i}x$

则 $\displaystyle \sum_{i=1}^{n-1}w_{e_i}\cdot 1=\sum_{c_1+c_2+c_3+\cdots+c_{n-1}=1}\prod_{i=1}^{n-1}P_i[c_i]$

后面这玩意儿本质上就是卷积，而且还是 $1$ 次项的系数

$\therefore \displaystyle \sum_{i=1}^{n-1}w_{e_i}=(\prod_{i=1}^{n-1}P_i(x))[1]$

$\therefore \displaystyle f(d)=\sum_{T\in v_d}((\prod_{i=1}^{n-1}P_i(x))[1])=(\sum_{T\in v_d}\prod_{i=1}^{n-1}P_i(x))[1]$

于是这就构成了矩阵树的形式。我们将 `vector` 中的边，构造成对应的一次函数，放进矩阵中，求一下行列式在模 $x^2$ 意义下的值。再把一次项系数返回，就是 $f(d)$ 的结果

> 消元方法见下

这样一来，$\displaystyle ans=\sum_{d\geq 1}\boldsymbol \varphi(d)f(d)$

如果每个 $d$ 都求解，复杂度将达到 $O(m\cdot n^3)$ ，其中 $m$ 为边的最大值。复杂度直接爆炸。

考虑将 `vector` 中的边跑一下并查集。如果最后没有并成一个连通分量，那一定不会生成树，贡献为 $0$ ，直接不跑高斯消元。

这样的剪枝相当于额外增加一个 $O(mn\cdot \alpha(n))$ ，但感觉是能扣除一大部分高斯消元。试试能不能过~~（最后当然是过了）~~。

---

简单讲一下多项式怎么在模 $x^2$ 意义下高斯消元。将 $P(x)=a+bx$ 记为 $(a,b)$ 则：

$(a,b)\pm(c,d)=(a\pm c,b\pm d)$

$(a+bx)(c+dx)=ac+(ad+bc)x+bdx^2\equiv ac+(ad+bc)x\pmod {x^2}$

即 $(a,b)\cdot (c,d)=(ac,ad+bc)$

若 $(a+bx)(c+dx)\equiv 1\pmod {x^2}$

则 $ac=1,ad+bc=0$

故 $c=a^{-1},d=-(bc)\cdot a^{-1}=-bc^2$

因此 $(a,b)^{-1}=(a^{-1},-a^{-2}b)$

故 $(a,b)/(c,d)=(a,b)\cdot (c,d)^{-1}$

这样一来就可以重载运算符了：

```cpp
typedef pair<int,int> pii;
#define fi first
#define se second
inline pii operator ~ (const pii &p) { ll tmp=inv(p.fi); return pii(tmp,dis(0,tmp*tmp%MOD*p.se%MOD)); }
//逆元
inline pii operator - (const pii &p) { return pii( dis(0,p.fi) , dis(0,p.se) ); }
inline pii operator + (const pii &a,const pii &b) { return pii( add(a.fi,b.fi) , add(a.se,b.se) ); }
inline pii operator += (pii &a,const pii &b) { return a=a+b; }
inline pii operator - (const pii &a,const pii &b) { return pii( dis(a.fi,b.fi) , dis(a.se,b.se) ); }
inline pii operator -= (pii &a,const pii &b) { return a=a-b; }
inline pii operator * (const pii &a,const pii &b) { return pii( (ll)a.fi*b.fi%MOD , ((ll)a.fi*b.se+(ll)a.se*b.fi)%MOD ); }
inline pii operator *= (pii &a,const pii &b) { return a=a*b; }
inline pii operator / (const pii &a,const pii &b) { return a*(~b); }
inline pii operator /= (pii &a,const pii &b) { return a=a/b; }
```

---

**【代码】**
--

最后奉上本蒟蒻的代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
#define fi first
#define se second
const int MOD=998244353,MAXN=32,Lim=152501;
inline ll fpow(ll a,ll x) { ll ans=1; for(;x;x>>=1,a=a*a%MOD) if(x&1) ans=ans*a%MOD; return ans; }
//快速幂
inline ll inv(ll a) { return fpow(a,MOD-2); }
inline int add(int a,int b) { return (a+b>=MOD)?(a+b-MOD):(a+b); }
inline int dis(int a,int b) { return (a-b<0)?(a-b+MOD):(a-b); }
//求余意义下的逆元、加减法

inline pii operator ~ (const pii &p) { ll tmp=inv(p.fi); return pii(tmp,dis(0,tmp*tmp%MOD*p.se%MOD)); }
//逆元
inline pii operator - (const pii &p) { return pii( dis(0,p.fi) , dis(0,p.se) ); }
inline pii operator + (const pii &a,const pii &b) { return pii( add(a.fi,b.fi) , add(a.se,b.se) ); }
inline pii operator += (pii &a,const pii &b) { return a=a+b; }
inline pii operator - (const pii &a,const pii &b) { return pii( dis(a.fi,b.fi) , dis(a.se,b.se) ); }
inline pii operator -= (pii &a,const pii &b) { return a=a-b; }
inline pii operator * (const pii &a,const pii &b) { return pii( (ll)a.fi*b.fi%MOD , ((ll)a.fi*b.se+(ll)a.se*b.fi)%MOD ); }
inline pii operator *= (pii &a,const pii &b) { return a=a*b; }
inline pii operator / (const pii &a,const pii &b) { return a*(~b); }
inline pii operator /= (pii &a,const pii &b) { return a=a/b; }
//重载运算符

struct Matrix{
    pii Num[MAXN][MAXN];
    inline pii det(int N){//求行列式
        pii res=pii(1,0);
        for(register int i=1;i<=N;++i){
            int pos=i;
            while(pos<=N&&Num[pos][i]==pii(0,0)) ++pos;
            if(pos>N) return pii(0,0);
            if(pos!=i) swap(Num[pos],Num[i]),res=-res;
            res*=Num[i][i];
            for(register int j=N;j>=i;j--) Num[i][j]/=Num[i][i];

            for(register int k=i+1;k<=N;++k)
                for(register int j=N;j>=i;--j)
                    Num[k][j]-=Num[i][j]*Num[k][i];
        }
        return res;
    }
}M;
struct Edge{
    int u,v,w;
    Edge(int u_=0,int v_=0,int w_=0):u(u_),v(v_),w(w_) {}
};
int n,Pa[MAXN],CntSet;
int find(int u) { return (u==Pa[u])?u:(Pa[u]=find(Pa[u])); }
inline void merge(int u,int v){
    if(find(u)==find(v)) return ;
    Pa[find(u)]=find(v);
    --CntSet;
}
//并查集相关操作
inline int calc(const vector<Edge> &v){
    //给定 vector ，求答案
    if(v.size()<n-1) return 0;
    //一定不成树
    iota(Pa+1,Pa+n+1,1); CntSet=n;
    memset(M.Num,0,sizeof(M.Num));
    //并查集和矩阵初始化
    for(const auto &e : v)
        merge(e.u,e.v),
        M.Num[e.u][e.v]-=pii(1,e.w),
        M.Num[e.v][e.u]-=pii(1,e.w),
        M.Num[e.u][e.u]+=pii(1,e.w),
        M.Num[e.v][e.v]+=pii(1,e.w);
    if(CntSet!=1) return 0;//无法生成树
    return M.det(n-1).se;
}
vector<Edge> e[Lim+1];
ll fc[Lim+1],phi[Lim+1],prime[Lim+1],cntprime;
inline void sieve(){
    //欧拉筛积性函数
    phi[1]=1;
    for(int i=2;i<=Lim;i++){
        if(!fc[i]) phi[i]=(fc[i]=prime[++cntprime]=i)-1;
        for(int j=1;j<=cntprime;j++)
            if(i*prime[j]>Lim) break;
            else if(fc[i]>prime[j]) fc[i*prime[j]]=prime[j],phi[i*prime[j]]=phi[i]*(prime[j]-1);
            else{
                fc[i*prime[j]]=prime[j];
                phi[i*prime[j]]=phi[i]*prime[j];
                break;
            }
    }
}
inline void pre(){
    int m;
    cin>>n>>m;
    for(int i=1,u,v,w;i<=m;i++){
        cin>>u>>v>>w;
        for(int d=1;d*d<=w;d++) if(w%d==0) {
            e[d].push_back( Edge(u,v,w) );
            if(w/d!=d) e[w/d].push_back( Edge(u,v,w) );
        }
        //给因数打上标记
    }
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    pre();
    sieve();
    ll ans=0;
    for(int i=1;i<=Lim;i++) ans+=phi[i]*calc(e[i])%MOD;
    ans%=MOD;
    cout<<ans;
    cout.flush();
    return 0;
}
```



---


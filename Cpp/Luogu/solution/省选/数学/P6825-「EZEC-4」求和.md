# 「EZEC-4」求和

## 题目描述

给定正整数 $n$ 的值，求出下面这个式子的值：

$$\displaystyle\sum_{i = 1}^n \sum_{j = 1}^n \gcd(i,j)^{i + j}$$

由于结果可能很大，所以你只需要求出结果对 $p$ 取模的值。

## 说明/提示


**本题开启 O2 优化和捆绑测试。**

**为了卡掉错解开大了数据范围，请注意常数因子对程序产生的影响。**

### 样例解释
#### 样例 #1
对于第一组数据：$\operatorname{ans} = \gcd(1, 1)^2 + \gcd(1, 2)^3 + \gcd(2, 1)^3 + \gcd(2, 2)^4 = 1^2 + 1^3 + 1^3 + 2^4 = 3 + 16 = 19$。所以答案为 $19 \bmod (10^9 + 7) = 19$。
### 数据范围

| Subtask | $\sum n$ | 分值 | 时限 |
| :------: | :------: | :------: | :------: |
| $1$ | $1 \leq \sum n \leq 500$ | $10 \operatorname{pts}$ | $1.00 \operatorname{s}$ |
| $2$ | $1 \leq \sum n \leq 5 \times 10^5$ | $40 \operatorname{pts}$ | $3.20 \operatorname{s}$ |
| $3$ | 无特殊限制 | $50 \operatorname{pts}$ | $6.00 \operatorname{s}$ |

对于 $100\%$ 的数据，$1 \leq \sum n \leq 1.5 \times 10^6$，$2 \leq p \leq 2^{31} - 1$ 且 $p$ 为质数，$1 \leq T \leq 2$。

## 样例 #1

### 输入

```
2
2 1000000007
3 998244353```

### 输出

```
19
752```

## 样例 #2

### 输入

```
2
4 998244353
123456 1000000007```

### 输出

```
66420
3252328```

# 题解

## 作者：Refined_heart (赞：7)

## ~~官方题解~~

### update on 2020/9/9 更新了复杂度证明。

~~我太菜了……题解改了好多次，麻烦管理了qwq~~

对于百分之十的数据：随便过。

下面推式子：

$$\sum_{i=1}^n\sum_{j=1}^n\gcd(i,j)^{i+j}$$

$$=\sum_{d=1}^n\sum_{i=1}^n\sum_{j=1}^nd^{i+j}[\gcd(i,j)=d]$$

$$=\sum_{d=1}^n\sum_{i=1}^\frac{n}{d}\sum_{j=1}^\frac{n}{d}d^{d(i+j)}[\gcd(i,j)=1]$$

$$=\sum_{d=1}^n\sum_{i=1}^\frac{n}{d}\sum_{j=1}^\frac{n}{d}d^{d(i+j)}\sum_{k|\gcd(i,j)}\mu(k)$$

$$=\sum_{d=1}^n\sum_{k=1}^\frac{n}{d}\mu(k)\sum_{i=1}^\frac{n}{kd}\sum_{j=1}^\frac{n}{kd}d^{kd(i+j)}$$

令$T=kd:$

$$=\sum_{T=1}^n\sum_{k|T}\mu(k)\sum_{i=1}^\frac{n}{T}\sum_{j=1}^\frac{n}{T}[(\frac{T}{k})^T]^{i+j}$$

现在的问题在于$\sum_{i=1}^\frac{n}{T}\sum_{j=1}^\frac{n}{T}[(\frac{T}{k})^T]^{i+j}.$

* 线性递推

以下是@SOSCHINA大佬的思路：

设$g(n)=\sum_{i=1}^n\sum_{j=1}^n k^s.$

枚举$s=i+j.$

则有：

$$g(n)=\sum_{s=2}^{n+1}(s-1)k^s+\sum_{s=n+2}^{2n}(2n-s+1)k^s$$

$$g(n+1)=\sum_{s=2}^{n+1}(s-1)k^s+\sum_{s=n+2}^{2n+2}(sn+3-s)k^s$$


$$g(n+1)-g(n)=\sum_{s=n+2}^{2n}2k^s+2k^{2n+1}+k^{2n+2}$$

第三行就是两行相减。

对第一行的解释：$[2,n+1]$这里的数，每个数作为$i+j$都出现了$x-1$次。因为$i$可以取遍$[1,x-1].$后面的那一些,$[n+2,2n]$会发现$i$最大只能到$n,$不能再取遍$x-1$个值了。此时能取到的应该是$2n-s+1$种。

对于$g(n+1):$这里是把第一个式子的最后一个值移动到了后面那个式子，方便做差。

这时我们可以在小模数的情况下做到$O(n*mod$)的预处理。

* 化简形式

令$x=(\frac{T}{k})^T.$


则原式为$\sum_{i=1}^\frac{n}{T}\sum_{j=1}^\frac{n}{T} x^{i+j}.$

像不像一个多项式。

它就等于$(x+x^2+...x^\frac{n}{T})^2.$

于是我们可以等比数列求和解出。

剩下的，可以做到$O(n\log n\log mod)$处理出整个式子。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1500001;
int mod,TT;
bitset<MAXN+1>vis;
int p[MAXN+1],mu[MAXN+1],T[MAXN+1],cnt,n,Ans;
inline int Mod(long long x){
	if(x<0)return x+mod;
    if(x>=mod)return x%mod;
    return x;
}
inline int add(int x,int y) {return Mod(1ll*x+1ll*y+1ll*mod);}
inline int mul(int x,int y) {return Mod(1ll*x*y);}
inline int qpow(int a,int b) {
	if(!b)return 1;
	if(a<=1||b==1)return a;
	a %= mod; 
	int res=1;
	while(b) {
		if(b&1)res=mul(res,a);
		a=mul(a,a);
		b>>=1;
	}
	return res;
}
inline int calc(int x,int y){
	if(y==1)return x;
	if(x==1)return y;
	int ans=x;
	int inv=qpow((1-x+mod)%mod,mod-2);
	int fm=(1-qpow(x,y)+mod)%mod;
	ans=mul(ans,mul(fm,inv));
	return ans;
}
inline int Calc(int x,int y){int ans=calc(x,y);return mul(ans,ans);} 
int main() {
	scanf("%d",&TT);
	mu[1]=1;
	int N=MAXN;
	for(register int i=2; i<=N; ++i) {
		if(!vis[i])p[++cnt]=i,mu[i]=-1;
		for(register int j=1; j<=cnt&&i*p[j]<=N; ++j) {
			vis[i*p[j]]=1;
			if(i%p[j]==0)break;
			mu[i*p[j]]=-mu[i];
		}
	}
	while(TT--) {
		scanf("%d%d",&n,&mod);
		N=n;Ans=0;
		for(register int i=1; i<=N; ++i) {
			for(register int j=i,k,x; j<=N; j+=i) {
				k=i;if(!mu[k])continue;
				x=qpow(j/k,j);
				T[j]=add(T[j],mul(mu[k],Calc(x,n/j)));
			}
		}
		for(register int i=1; i<=n; ++i)Ans=add(Ans,T[i]),T[i]=0;
		printf("%d\n",Ans);
	}

	return 0;
}
```
由于这里是$5*10^5$的数据，所以略微卡常，但笔者通过非常不精湛的卡常技术跑到了$3s$以内，所以这里的时间限制我开了$3.2s$.

对等比数列进行精细处理，可以做到$O(n\log^2n)$的复杂度。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int MAXN=1500000;
int mod,TT;
bitset<MAXN<<1>vis;
int p[MAXN<<1],mu[MAXN<<1],T[MAXN<<1],cnt,n,Ans;
inline int Mod(long long x){
    if(x>=mod)return x%mod;
    return x;
}
inline int add(int x,int y) {
	return Mod(x+y+mod);
}
inline int mul(int x,int y) {
	return Mod(1ll*x*y);
}
inline int qpow(int a,int b) {
	if(!b)return 1;
	if(a<=1||b==1)return a;
	a %= mod; 
	int res=1;
	while(b) {
		if(b&1)res=mul(res,a);
		a=mul(a,a);
		b>>=1;
	}
	return res;
}
inline int calc(int x,int y){
	if(y==1)return x;
		int res=calc(x,y/2);
	res=add(res,mul(res,qpow(x,y/2)));
	if(y&1)res=add(res,mul(x,qpow(x,y-1)));
	return res;
}
inline int Calc(int x,int y){int ans=calc(x,y);return mul(ans,ans);} 
signed main() {
	scanf("%lld",&TT);
	mu[1]=1;
	int N=MAXN;
	for(int i=2; i<=N; ++i) {
		if(!vis[i])p[++cnt]=i,mu[i]=-1;
		for(int j=1; j<=cnt&&i*p[j]<=N; ++j) {
			vis[i*p[j]]=1;
			if(i%p[j]==0)break;
			mu[i*p[j]]=-mu[i];
		}
	}
	while(TT--) {
		scanf("%lld%lld",&n,&mod);
		N=n;
		Ans=0;
		for(int i=1; i<=N; ++i) {
			for(int j=i; j<=N; j+=i) {
				int k=i;
				int x=qpow(j/k,j);
				if(!mu[k])continue;
				T[j]=add(T[j],mul(mu[k],Calc(x,n/j)));
			}
		}
		for(int i=1; i<=n; ++i)Ans=add(Ans,T[i]),T[i]=0;
		cout<<Ans<<endl;
	}

	return 0;
}
```
由于常数等原因，这分代码可以拿到$50$分的好成绩。但我们可以通过另一种做法将常数/复杂度降低。

##  另一种做法

观察：

$$\sum_{d=1}^n\sum_{k=1}^\frac{n}{d}\mu(k)\sum_{i=1}^\frac{n}{kd}\sum_{j=1}^\frac{n}{kd}d^{kd(i+j)}$$

$$=\sum_{d=1}^n \sum_{k=1}^\frac{n}{d} \mu(k)(d^{kd}+d^{2kd}+...+d^{\frac{n}{kd}*kd=n})^2.$$

这里同样观察式子发现可以直接算。前一部分是$O(n\ln n)$的$n$倍调和级数的复杂度，后面带上一个$O(\log n)$精细处理的等比数列求求和复杂度。

（代码中的优化即使不加也是可以过的）

```cpp
#define __AVX__ 1
#define __AVX2__ 1
#define __SSE__ 1
#define __SSE2__ 1
#define __SSE2_MATH__ 1
#define __SSE3__ 1
#define __SSE4_1__ 1
#define __SSE4_2__ 1
#define __SSE_MATH__ 1
#define __SSSE3__ 1
#pragma GCC optimize("Ofast,no-stack-protector,unroll-loops,fast-math")
#pragma GCC target("sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native")
#include <immintrin.h>
#include <emmintrin.h>
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <string>
#include <bitset>
using namespace std;
const int MAXN=1.5e6+10;
int mod,T;
bitset<MAXN+1>vis;
int p[MAXN+1],cnt,mu[MAXN+1],N;
inline int Mod(long long a, int pp){
    return a>=pp ? a%pp : a>=0 ? a : a+pp;
}
inline int add(int x,int y){return Mod( (1ll+x+y+mod-1ll),mod);}
inline int mul(int x,int y){return Mod(1ll*x*y,mod);}
void pretreatment(){
	mu[1]=1;
	for(int i=2;i<=MAXN;++i){
		if(!vis[i])p[++cnt]=i,mu[i]=-1;
		for(int j=1;j<=cnt&&i*p[j]<=MAXN;++j){
			vis[i*p[j]]=1;
			if(Mod(i,p[j])==0)break;
			mu[i*p[j]]=-mu[i];
		}
	}
}
inline int qpow(int a,int b){
	if(!b)return 1;
	if(a<=1||b==1)return a;
	int res=1;
	while(b){
		if(b&1)res=mul(res,a);
		a=mul(a,a);b>>=1;
	}
	return res;
}
inline int calc(int x,int y){
	if(y==1)return x;
	int res=calc(x,y>>1);
	res=add(res,mul(res,qpow(x,y>>1)));
	if(y&1)res=add(res,mul(x,qpow(x,y-1)));
	return res;
}

inline int Calc(int x,int y){int ans=calc(x,y);return mul(ans,ans);} 
int ssolve(int n,int d){
	int res=0;
	for(register int l=1;l<=n;++l){
		if(!mu[l])continue;
		res=add(res,mul(mu[l],Calc(qpow(d,l),n/l)));
	}
	return res;
}
int solve(int n){
	int ans=0;
	for(register int l=1;l<=n;l++){
		ans=add(ans,ssolve(n/l,qpow(l,l)));
	}
	return ans;
}
signed main(){
	scanf("%lld",&T);
	pretreatment();
	for(;T;T--){
		scanf("%lld%lld",&N,&mod);
		printf("%lld\n",solve(N));
	}
	return 0;
}
```

可以用整除分块减少循环中乘法的使用，对代码速度可能有一定的提升。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1.5e6+10;
int mod,T;
bitset<MAXN+1>vis;
int p[MAXN+1],cnt,mu[MAXN+1],N;
inline int Mod(long long a, int pp){return a>=pp ? a%pp : a>=0 ? a : a+pp;}
inline int add(int x,int y){return Mod( (1ll+x+y+mod-1ll),mod);}
inline int mul(int x,int y){return Mod(1ll*x*y,mod);}
inline int qpow(int a,int b){
	if(!b)return 1;
	if(a<=1||b==1)return a;
	a=Mod(a,mod);
	int res=1;
	while(b){
		if(b&1)res=mul(res,a);
		a=mul(a,a);b>>=1;
	}
	return res;
}
inline int calc(int x,int y){
	if(y==1)return x;
	int res=calc(x,y>>1);
	res=add(res,mul(res,qpow(x,y>>1)));
	if(y&1)res=add(res,mul(x,qpow(x,y-1)));
	return res;
}
inline int Calc(int x,int y){int ans=calc(x,y);return mul(ans,ans);} 
int ssolve(int n,int d){
	int res=0;
	for(register int l=1,r;l<=n;l=r+1){
		r=(n/(n/l));
		int D=n/l;
		for(int i=l;i<=r;++i){
			if(!mu[i])continue;
			res=add(res,mul(mu[i],Calc(qpow(d,i),D)));
		}
	}
	return res;
}
int solve(int n){
	int ans=0;
	for(register int l=1,r;l<=n;l=r+1){
		r=(n/(n/l));
		int D=n/l;
		for(int i=l;i<=r;++i)ans=add(ans,ssolve(D,qpow(i,i)));
	}
	return ans;
}
int main(){
	scanf("%d",&T);
	mu[1]=1;
	for(register int i=2;i<=MAXN;++i){
		if(!vis[i])p[++cnt]=i,mu[i]=-1;
		for(register int j=1;j<=cnt&&i*p[j]<=MAXN;++j){
			vis[i*p[j]]=1;
			if(Mod(i,p[j])==0)break;
			mu[i*p[j]]=-mu[i];
		}
	}
	for(;T;T--){
		scanf("%d%d",&N,&mod);
		printf("%d\n",solve(N));
	}
	return 0;
}
```

update on 2020.9.8：

经由大佬 @C3H5ClO 大佬证明，上面这份代码实际上是$O(n\log n)$的。

最后借用一下 @C3H5ClO 大佬的证明：

$$f(n)=\sum_{d=1}^n\sum_{e=1}^{\lfloor \frac{n}{d} \rfloor}\mu(e)(\sum_{i=1}^{\lfloor \frac{n}{de}\rfloor}d^{de})^2$$

$$T(n)=O(\sum_{d=1}^n\sum_{e=1}^{\lfloor \frac{n}{d} \rfloor}\log\lfloor \frac{n}{de}\rfloor)$$

$$T(n)=O(\sum_{i=1}^n\int_0^{\frac{n}{i}}\log\frac{n}{ix}\mathrm{d}x)$$

>$$\int\log\frac{n}{x}\mathrm{d}x=(\log n+1)x-x\log x+C$$
>
>$$\int_0^n\log\frac{n}{x}\mathrm{d}x=n$$

$$T(n)=O(\sum_{i=1}^n\frac{n}{i})=O(n\ln n)$$


出这题的本意其实是想看看有没有吊打$\text{std}$的做法的，笔者推了很久并没有找到线性的做法。

---

## 作者：TKXZ133 (赞：2)

[求和](https://www.luogu.com.cn/problem/P6825)

### 题目大意

给定 $n,p$，求：

$$\left(\sum_{i=1}^n\sum_{j=1}^n\gcd(i,j)^{i+j}\right)\bmod p$$

多组数据。

### 思路分析

老规矩，先化式子：

$$\begin{aligned}
\sum_{i=1}^n\sum_{j=1}^n\gcd(i,j)^{i+j}&=
\sum_{d=1}^n\sum_{i=1}^n\sum_{j=1}^nd^{\,i+j}\,[\gcd(i,j)=d]\\
&=\sum_{d=1}^n\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{n}{d}\right\rfloor}d^{\,(i+j)\,d}\,[\gcd(i,j)=1]\\
&=\sum_{d=1}^n\sum_{x=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\mu(x)\sum_{i=1}^{\left\lfloor\frac{n}{xd}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{n}{xd}\right\rfloor}d^{\,(i+j)\,xd}
\end{aligned}$$

观察后面的部分：

$$\begin{aligned}
\sum_{i=1}^{\left\lfloor\frac{n}{xd}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{n}{xd}\right\rfloor}d^{\,(i+j)\,xd}&=
\Bigg(\sum_{i=1}^{\left\lfloor\frac{n}{xd}\right\rfloor}d^{\,ixd}\Bigg)\times \Bigg(\sum_{j=1}^{\left\lfloor\frac{n}{xd}\right\rfloor}d^{\,jxd}\Bigg)\\
&=\Bigg(\sum_{i=1}^{\left\lfloor\frac{n}{xd}\right\rfloor}d^{\,ixd}\Bigg)^2
\end{aligned}$$

设 $f(d,n)=\sum\limits_{i=1}^nd^{\,i}$，那么后面的部分就可以表示为 $f^2(d^{xd},\left\lfloor\frac{n}{xd}\right\rfloor)$。

我们发现，$f$ 是一个首项为 $d$，公比为 $d$ 的等比数列前 $n$ 项和，可以 $O(\log n)$ 计算，具体的说：

$$f(d,n)=\begin{cases}d^{\,n}+f(d,\dfrac{n-1}{2})&n\equiv 1\pmod 2\\(d^{\frac{n}{2}}+1)\times f(d,\dfrac{n}{2})&n\equiv 0\pmod 2\end{cases}$$

那么我们的式子就变成了：

$$\sum_{d=1}^n\sum_{x=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\mu(x)f^2(d^{xd},\left\lfloor\frac{n}{xd}\right\rfloor)$$

我们发现，如果暴力计算这个式子，也就是暴力枚举 $d$，枚举 $x$，直接计算 $f$，那么时间复杂度是 $O(n\log n)$ 的，可以通过（需要轻微卡常）。

- 为什么时间复杂度是 $O(n\log n)$？

证明就不证了（~~其实是我不会~~），这里放一张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/lqeyc6il.png)

### 代码

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>

using namespace std;
const int N=1550000,L=1500000;
#define int long long

int prime[N],mu[N],v[N];
int cnt,n,T,mod;

int mode(int x){
    while(x>mod) x-=mod;
    return x;
}

int q_pow(int a,int b){
    int res=1;
    while(b){
        if(b&1) res=(res*a)%mod;
        a=(a*a)%mod;
        b>>=1;
    }
    return res;
}

void sieve(){
    mu[1]=1;
    for(int i=2;i<=L;i++){
        if(!v[i]){prime[++cnt]=i;mu[i]=-1;}
        for(int j=1;j<=cnt&&i*prime[j]<=L;j++){
            v[i*prime[j]]=1;
            if(i%prime[j]==0) break;
            mu[i*prime[j]]=-mu[i];
        }
    }
}

int f(int d,int n){
    if(n==1) return d;
    int res=f(d,n>>1);
    res=mode(res+res*q_pow(d,n>>1)%mod);
    if(n&1) res=mode(res+q_pow(d,n)%mod);
    return res;
}

signed main(){
    sieve();
    scanf("%lld",&T);
    while(T--){
        scanf("%lld%lld",&n,&mod);
        int res=0;
        for(int d=1;d<=n;d++){
            int r=n/d;
            for(int x=1;x<=r;x++){
                if(!mu[x]) continue;
                int ans=f(q_pow(d,x*d%(mod-1)),r/x);
                res=mode(res+mu[x]*ans*ans%mod+mod);
            }
        }
        cout<<res<<'\n';
    }
    return 0;
}
```

---

## 作者：Prean (赞：2)

科技的力量！！！！！！~~我德意志科技天下第一！！！~~

这是一篇需要一点儿科技的题解，但实际上这个科技我认为甚至算不上科技，太 simple 了。

首先是推柿子：
$$ \sum_{i=1}^n\sum_{j=1}^n\gcd(i,j)^{i+j} $$
$$ \sum_{d=1}^n\sum_{i=1}^n\sum_{j=1}^n[\gcd(i,j)=d]d^{i+j} $$
$$ \sum_{d=1}^n\sum_{i=1}^{\lfloor \frac n d \rfloor}\sum_{j=1}^{\lfloor \frac n d \rfloor}[\gcd(i,j)=1](d^d)^{i+j} $$
$$ \sum_{d=1}^n\sum_{i=1}^{\lfloor \frac n d \rfloor}\sum_{j=1}^{\lfloor \frac n d \rfloor}\sum_{k|i,k|j}\mu(k)(d^d)^{i+j} $$
$$ \sum_{d=1}^n\sum_{k=1}^{\lfloor \frac n d \rfloor}\sum_{i=1}^{\lfloor \frac n {dk} \rfloor}\sum_{j=1}^{\lfloor \frac n {dk} \rfloor
}\mu(k)(d^{dk})^{i+j} $$
设
$$ f(d,n)=\sum_{i=1}^n\sum_{j=1}^nd^{i+j} $$
特别的，当 $ d=1 $ 时，$ f(1,n)=n^2 $

否则上面那玩意儿就是：
$$ (\sum_{i=1}^nd^i)^2 $$
等比数列求和，在 $ O(\log n) $ 的时间内算出来。

回到原柿：
$$ \sum_{d=1}^n\sum_{k=1}^{\lfloor \frac n d \rfloor}\mu(k)f(d^{dk},\lfloor \frac n {dk} \rfloor) $$
考虑将 $ (d^d)^k $ 带入 $ f $。可以发现 $ f $ 只与 $ d^d $ 的若干次方有关，并且这个幂的上界是 $ O(k \times \lfloor \frac n {dk} \rfloor)=O(n) $。

考虑对于所有的 $ d^d $ 预处理光速幂数组。可以参考[这里](https://www.luogu.com.cn/paste/umoclwgy)，复杂度是 $ O(\sqrt [4] {lim})-O(1) $。本题的 $ lim $ 为 $ 1.5 \times 10^6 $，不过实际上当 $ d=1 $ 时不需要光速幂数组，所以实际上上界不到 $ 10^6 $。别小看这一点，$ 2^{20}>10^6 $，这导致了空间和时间复杂度得到了改善。

于是我们发现唯一的问题是求 $ (d^d)^k-1 $ 的逆元。我们使用离线求逆元，这里使用的是封装好的离线求逆元。

以及，这个屑题卡空间，所以我们对 $ [1,n] $ 分成若干段，对每一段使用离线求逆元和光速幂。离线求逆元当缓存满了的时候需要清空。

我们发现，每段的长度最好是 $ 8 $，因为离线求逆元最多只会执行 $ 10^5 $ 次，且光速幂的预处理不会炸空间。还有一个好处就是，这使得离线求逆元的缓存区很短，能够卡进执行文件的缓存，大大降低了常数。

总复杂度为 $ O(n\sqrt [4] {n}+n\ln n) $。

优化1：只枚举 $ \mu(k) \neq 0 $ 的 $ k $，常数降低。

优化2：当 $ d $ 较大时，能够与其匹配的 $ k $ 过少，此时使用快速幂比光速幂更优。

不过不知道为啥只跑了 1.16s，跑得飞快。。。

code:
```cpp
#include<cstdio>
#include<vector>
typedef unsigned uint;
typedef __uint128_t L;
typedef unsigned long long ull;
const uint M=1.5e6+5;
uint P,top,pri[M],mu[M];bool zhi[M];
struct FastMod{
    ull b,m;
    FastMod(ull b):b(b),m(ull((L(1)<<64)/b)){}
    friend inline ull operator%(const ull&a,const FastMod&mod){
        ull r=a-(L(mod.m)*a>>64)*mod.b;
        return r>=mod.b?r-mod.b:r;
    }
}mod(2);
struct Pow{
	std::vector<uint>p1,p2,p3,p4;
	inline void clear(){
		std::vector<uint>().swap(p1);std::vector<uint>().swap(p2);
		std::vector<uint>().swap(p3);std::vector<uint>().swap(p4);
	}
	inline void init(register uint x){
		register uint i;
		p1.reserve(33);p2.reserve(33);p3.reserve(33);p4.reserve(33);
		p1[0]=p2[0]=p3[0]=p4[0]=1;
		for(p1[1]=x,i=2;i<=32;++i)p1[i]=1ull*p1[i-1]*x%mod;
		for(x=p2[1]=p1[32],i=2;i<=32;++i)p2[i]=1ull*p2[i-1]*x%mod;
		for(x=p3[1]=p2[32],i=2;i<=32;++i)p3[i]=1ull*p3[i-1]*x%mod;
		for(x=p4[1]=p3[32],i=2;i<=32;++i)p4[i]=1ull*p4[i-1]*x%mod;
	}
	inline uint pow(const uint&x){
		return 1ull*p1[x&31]*p2[x>>5&31]%mod*p3[x>>10&31]%mod*p4[x>>15&31]%mod;
	}
	Pow(){
		clear();
	}
}p[M>>1];
inline uint pow(uint a,uint b){
	uint ans=1;
	for(;b;b>>=1,a=1ull*a*a%mod)if(b&1)ans=1ull*ans*a%mod;
	return ans;
}
inline void sieve(const uint&M){
	register uint i,j,x;mu[1]=1;
	for(i=2;i<=M;++i){
		if(!zhi[i])mu[pri[++top]=i]=-1;
		for(j=1;j<=top&&(x=i*pri[j])<=M;++j){
			zhi[x]=true;if(!(i%pri[j]))break;mu[x]=-mu[i];
		}
	}
}
inline uint calc(const uint&d,const uint&D,const uint&len,const uint&k,const uint&inv){
	uint S=(1ull*D*p[d].pow(len*k)%mod-p[d].pow(k)+P)*inv%mod;
	return 1ull*S*S%mod;
}
struct GetAns{
	uint ans,len,d[131073],k[131073],l[131073],f[131073],S[131073];bool o[131073];
	inline void flush(){
		uint i,s;if(!len)return;
		for(i=1;i<=len;++i)S[i]=1ull*S[i-1]*f[i]%mod;s=pow(S[len],P-2);
		do{
			if(o[len])ans=(ans+calc(d[len],f[len]+1,l[len],k[len],1ull*s*S[len-1]%mod))%mod;
			else ans=(ans+P-calc(d[len],f[len]+1,l[len],k[len],1ull*s*S[len-1]%mod))%mod;
			s=1ull*s*f[len]%mod;
		}while(--len);
	}
	inline void Insert(const uint&cd,const uint&ck,const uint&cl,const uint&cf,const bool&co){
		++len;d[len]=cd;k[len]=ck;l[len]=cl;f[len]=cf;o[len]=co;
		if(!(len&131071))flush();
	}
}q;
inline uint Solve(const uint&n){
	const uint&lim4=n/4,&lim3=n/3,lim2=n/2;
	register uint i,k,x,ans=0,lst=2;q.ans=q.len=0;
	for(i=1;i<=n;++i){
		if(mu[i]==1)ans=(ans+1ull*(n/i)*(n/i))%mod;
		else if(mu[i])ans=(ans+P-1ull*(n/i)*(n/i)%mod)%mod;
	}
	for(i=2;(i<<1)<=n;++i){
		if(!(i&7)){
			q.flush();while(lst^i)p[lst++].clear();
		}
		p[i].init(pow(i,i));
		for(k=1;i*k<=n;++k){
			if(mu[k]){
				x=p[i].pow(k)-1;
				if(!x){
					if(mu[k]==1)ans=(ans+1ull*(n/(i*k))*(n/(i*k)))%mod;
					else if(mu[k])ans=(ans+P-1ull*(n/(i*k))*(n/(i*k))%mod)%mod;
				}
				else q.Insert(i,k,n/(i*k),x,mu[k]==1);
			}
		}
	}
	q.flush();while(lst^i)p[lst++].clear();
	for(ans=(ans+q.ans)%mod;i<=n;++i)k=pow(i,i),ans=(ans+1ull*k*k)%mod;
	return ans;
}
signed main(){
	uint T,n1,n2,m1,m2;q.S[0]=1;
	scanf("%u",&T);
	if(T==1)scanf("%u%u",&n1,&m1),sieve(n1),mod=FastMod(P=m1),printf("%u",Solve(n1));
	else{
		scanf("%u%u%u%u",&n1,&m1,&n2,&m2);
		sieve(n1>n2?n1:n2);
		mod=FastMod(P=m1);printf("%u\n",Solve(n1));
		mod=FastMod(P=m2);printf("%u",Solve(n2));
	}
}
```
闲话：这个 $ O(n\log n) $ 可比官方题解的 $ O(n\log n) $  靠谱多了。

---

## 作者：do_while_true (赞：2)

# 题目描述

$T$ 组数据，对于每组数据，给定 $n,p$，计算下面的式子对 $p$ 取余的结果。

$$
\sum_{i=1}^n\sum_{i=1}^n\gcd(i, j)^{i+j}
$$

其中 $1 \leq T \leq 2,1 \leq \sum n \leq 1.5 \times 10^6, 2 \leq p \leq 2^{31}-1 \text{且 p 为质数}$。

# $\mathcal{Solution}$

推一下式子：

$$
\sum_{i=1}^n \sum_{j=1}^n \gcd(i,j)^{i+j}
\\
\sum_{d=1}^n\sum_{i=1}^{\left \lfloor \frac{n}{d} \right \rfloor } \sum_{j=1}^{\left \lfloor \frac{n}{d} \right \rfloor } [\gcd(i,j)=1]d^{id+jd}
$$

利用 $\mu*1=\epsilon$：

$$
\sum_{d=1}^n\sum_{i=1}^{\left \lfloor \frac{n}{d} \right \rfloor } \sum_{j=1}^{\left \lfloor \frac{n}{d} \right \rfloor } \sum_{k|i,k|j} \left ( \mu(k)\times d^{id+jd} \right ) 
$$

把枚举 $k$ 提到前面，原先的枚举 $i,j$ 就变成了枚举 $k$ 的倍数 $ik,jk$。

$$
\sum_{d=1}^n\sum_{k=1}^{\left \lfloor \frac{n}{d} \right \rfloor} \mu(k)\sum_{i=1}^{\left \lfloor \frac{n}{kd} \right \rfloor } \sum_{j=1}^{\left \lfloor \frac{n}{kd} \right \rfloor } d^{ikd+jkd}
$$

设 $T=kd$：

$$
\sum_{d=1}^n\sum_{k=1}^{\left \lfloor \frac{n}{d} \right \rfloor } \mu(k) \sum_{i=1}^{\left \lfloor \frac{n}{T} \right \rfloor } \sum_{j=1}^{\left \lfloor \frac{n}{T} \right \rfloor } d^{iT}\times d^{jT}
\\
\sum_{d=1}^n\sum_{k=1}^{\left \lfloor \frac{n}{d} \right \rfloor } \mu(k) \left ( \sum_{i=1}^{\left \lfloor \frac{n}{T} \right \rfloor }d^{iT} \right )  \left ( \sum_{j=1}^{\left \lfloor \frac{n}{T} \right \rfloor }  d^{jT} \right )
\\
\sum_{d=1}^n\sum_{k=1}^{\left \lfloor \frac{n}{d} \right \rfloor } \mu(k) \left ( \sum_{i=1}^{\left \lfloor \frac{n}{T} \right \rfloor }{(d^{T})}^i \right )^2
$$

平方里面是个等比数列求和，可以在 $\mathcal{O}(\log \left \lfloor \frac{n}{T} \right \rfloor)$ 的时间复杂度内解决，至于 $d^T$，可以在每枚举到一个 $d$ 的时候快速幂一下 $d^d$，然后在枚举 $k$ 一步一步乘。

枚举 $d,k$ 是调和级数 $\mathcal{O}(n\log n)$，~~后面复杂度就不会分析了~~，有大佬证明出是 $\mathcal{O}(n\log n)$ 的。

如何在 $\mathcal{O}(\log n)$ 的时间内算 $n$ 项等比数列的和？

设 $S_n$ 为等比数列的前 $n$ 项和，那么有：
$$
S_n=\left\{\begin{matrix}
S_{\frac{n}{2}}(1+q^{\frac{n}{2}}),n\bmod2=0
 \\
S_{\frac{n-1}{2}}(1+q^{\frac{n-1}{2}})+q^n,n\bmod2=1
\end{matrix}\right.
$$
实际上就是在分治快速幂算 $q^n$ 的时候顺带算了一下 $S_n$，注意到在算 $S_{n}$ 的时候把 $q^n$ 算出来后传给上一层，这样复杂度就为 $\mathcal{O}(\log n)$ 了，不必再快速幂计算 $q^n$。

# $\mathcal{Code}$

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
namespace do_while_true {
	#define ld double
	#define ll long long
	#define re register
	#define pb push_back
	#define fir first
	#define sec second
	#define pp std::pair<ll, ll>
	#define mp std::make_pair
	template <typename T>
	inline T Max(T x, T y) { return x > y ? x : y; }
	template <typename T>
	inline T Min(T x, T y) { return x < y ? x : y; }
	template <typename T>
	inline T Abs(T x) {	return x < 0 ? -x : x; }
	template <typename T>
	inline T& read(T& r) {
		r = 0; bool w = 0; char ch = getchar();
		while(ch < '0' || ch > '9') w = ch == '-' ? 1 : 0, ch = getchar();
		while(ch >= '0' && ch <= '9') r = r * 10 + (ch ^ 48), ch = getchar();
		return r = w ? -r : r;
	}
	template <typename T>
	inline T qpow(T x, T y, T mod) {
		re T sumq = 1; x %= mod;
		while(y) {
			if(y&1) sumq = sumq * x % mod;
			x = x * x % mod;
			y >>= 1;
		}
		return sumq;
	}
	char outch[110];
	int outct;
	template <typename T>
	inline void print(T x) {
		do {
			outch[++outct] = x % 10 + '0';
			x /= 10;
		} while(x);
		while(outct >= 1) putchar(outch[outct--]);
	}
}
using namespace do_while_true;

const int N = 1500010 + 10;
template <typename T, typename T2>
inline T Mod(T x, T2 p) { return x % p; }

ll ans;
bool vis[N];
int prime[N], ct, mu[N];

pp db(ll x, int n, ll p) {
	if(n == 0) return mp(1ll, 1ll);
	if(n == 1) return mp(x, x);
	if((n & 1) == 0) {
		pp temp = db(x, n / 2, p);
		return mp(temp.fir * ((1 + temp.sec) % p) % p, temp.sec * temp.sec % p);
	}
	pp temp = db(x, (n-1) / 2, p);
	ll qn = temp.sec * temp.sec % p * x % p;
	return mp((temp.fir * ((1 + temp.sec) % p) % p + qn) % p, qn);
}

void mian(int n, ll p) {
	ans = 0;
	for(int d = 1; d <= n; ++d) {
		ll dd = qpow(1ll * d, 1ll * d, p);
		ll kd = dd;
		for(int k = 1; k <= n / d; ++k) {
			pp temp = db(kd, n / (k * d), p);
			ans = (ans + temp.fir * temp.fir % p * Mod(mu[k] + p, p) % p) % p;
			kd = kd * dd % p;
		}
	}
	printf("%lld\n", ans);
}

int n[3], mx;
ll p[3];

void pre() {
	vis[1] = 1; mu[1] = 1;
	for(int i = 2; i <= mx; ++i) {
		if(!vis[i]) {
			prime[++ct] = i;
			mu[i] = -1;
		}
		for(int j = 1; j <= ct && 1ll * i * prime[j] <= mx; ++j) {
			vis[i * prime[j]] = 1;
			if(i % prime[j] == 0) {
				mu[i * prime[j]] = 0;
				break;
			}
			mu[i * prime[j]] = mu[i] * mu[prime[j]];
		}
	}
}

signed main() {
	int T = 1;
	read(T);
	for(int i = 1; i <= T; ++i) read(n[i]), read(p[i]), mx = Max(mx, n[i]);
	pre();
	for(int i = 1; i <= T; ++i) mian(n[i], p[i]);
	fclose(stdin);
	return 0;
}
```

---

## 作者：万弘 (赞：2)

是一道锻炼卡常水平的好题！

先推柿子
$$
\sum_{d=1}^n\sum_{i=1}^n\sum_{j=1}^nd^{i+j}[gcd(i,j)=d]
$$

$$
\sum_{d=1}^n\sum_{i=1}^{\lfloor{n/d\rfloor}}\sum_{j=1}^{\lfloor{n/d\rfloor}}d^{di+dj}[gcd(i,j)=1]
$$

$$
\sum_{d=1}\sum_{k=1}\mu(k)\sum_{i=1}^{\lfloor{n/dk\rfloor}}d^{idk}\sum_{j=1}^{\lfloor{n/dk\rfloor}}d^{jdk}
$$

考虑加上$dk\le n$的条件，答案不变
$$
\sum_{d=1}\sum_{k=1}^{\lfloor n/d\rfloor}\mu(k)\sum_{i=1}^{\lfloor{n/dk\rfloor}}d^{idk}\sum_{j=1}^{\lfloor{n/dk\rfloor}}d^{jdk}
$$
前面两个合起来是调和级数，后面就等比数列求和爆算，复杂度$\mathcal O(n\log n\log p)$ 可得50分。

发现等比数列求和那里$\mathcal O(\log p)$是因为求逆元。那么不妨**离线求逆元**，那就只有一个快速幂的复杂度了，总共就是$\mathcal O(n\log^2 n)$.

另外，直接离线求逆元空间不够，分成若干段，每段长度$10^6$去算就好。

努力卡常即可AC。[code](https://pasteme.cn/51851)

PS:后来有人一通积分证出来是$\mathcal O(n\log n)$的。

~~PPS:加了一堆快速取模等优化，我卡进了最优解第一页，一起来卡常啊~~

---

## 作者：大眼仔Happy (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P6825)

# Solution

显然是莫反，直接上柿子。

$$
\begin{aligned}&
\sum_{i=1}^n\sum_{j=1}^n\gcd(i,j)^{i+j}
\\=&
\sum_{d=1}^n\sum_{i=1}^n\sum_{j=1}^n d^{i+j}[\gcd(i,j)=d]
\\=&
\sum_{d=1}^n\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{d}\rfloor} d^{id+jd}(\sum_{k|i,k|j}\mu(k))
\\=&
\sum_{d=1}^n\mu(d)\sum_{k=1}^{\lfloor\frac{n}{d}\rfloor}(\sum_{i=1}^{\lfloor\frac{n}{kd}\rfloor}d^{ikd})^2
\end{aligned}
$$

令 $N=\lfloor\dfrac{n}{d}\rfloor$，$D=d^d$，则

$$
\begin{aligned}{\rm calc}(d)=&
\sum_{k=1}^{\lfloor\frac{n}{d}\rfloor}(\sum_{i=1}^{\lfloor\frac{n}{kd}\rfloor}d^{ikd})^2
\\=&
\sum_{k=1}^N(\sum_{i=1}^{\lfloor\frac{N}{k}\rfloor}D^{ik})^2
\end{aligned}
$$

这个东西可以枚举倍数，时间复杂度为调和级数 $H_N=O(N\log N)$。

最后放缩一下也是 $O(n\log n)$，不过感觉比等比数列求和要常数小要好写，是 rank 2。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=1.5e6+5;
ll inline read()
{
	ll num=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){num=(num<<3)+(num<<1)+(ch^48);ch=getchar();}
	return num*f;
}
int T,n,tot;ll mod,f[N],sum[N],ans;
ll p[N],mu[N];bool vis[N];
ll qp(ll a,ll b){ll res=1;a%=mod;while(b){if(b&1)res=res*a%mod;a=a*a%mod;b>>=1;}return res;}
ll inc(ll x,ll y){return x+y>=mod?x+y-mod:x+y;}
ll dec(ll x,ll y){return x<y?x-y+mod:x-y;}
void InitMu()
{
	mu[1]=1;f[0]=1;n=1.5e6;
	for(int i=2;i<=n;i++)
	{
		if(!vis[i])p[++tot]=i,mu[i]=-1;
		for(int j=1;i*p[j]<=n;j++)
		{
			vis[i*p[j]]=1;
			if(i%p[j]==0)break;
			mu[i*p[j]=-mu[i];
		}
	}
}
void CalcSumPow(int x,ll D)
{
	for(int i=1;i<=x;i++)f[i]=1ll*f[i-1]*D%mod,sum[i]=0;
	for(int i=1;i<=x;i++)
		for(int j=i;j<=x;j+=i)
			sum[i]=inc(sum[i],f[j]);
	for(int i=1;i<=x;i++)sum[i]=sum[i]*sum[i]%mod;
	for(int i=1;i<=x;i++)
	{
		if(mu[i]==0)continue;
		if(mu[i]==1)ans=inc(ans,sum[i]);
		if(mu[i]==-1)ans=dec(ans,sum[i]);
	}
}
void solve()
{
	n=read();mod=read();ans=0;
	for(int d=1;d<=n;d++)CalcSumPow(n/d,qp(d,d));
	printf("%lld\n",ans);
}
int main(){
	InitMu();T=read();while(T--)solve();
	return 0;
}
```

---

## 作者：littlez_meow (赞：1)

难度主要在卡常。

[题目指路](https://www.luogu.com.cn/problem/P6825)。

## step 1：推式子

这个式子一看就能反嘛。

根据套路，枚举 $\gcd$，得：

$$\sum\limits_{t=1}^n\sum\limits_{i=1}^n\sum\limits_{j=1}^nt^{i+j}[\gcd(i,j)=t]$$

替换 $i,j$ 为 $it,jt$ 得：

$$\sum\limits_{t=1}^n\sum\limits_{i=1}^{\lfloor\frac n t\rfloor}\sum\limits_{j=1}^{\lfloor\frac n t\rfloor}t^{it+jt}[\gcd(i,j)=1]$$

反演，得：

$$\sum\limits_{t=1}^n\sum\limits_{i=1}^{\lfloor\frac n t\rfloor}\sum\limits_{j=1}^{\lfloor\frac n t\rfloor}t^{it+jt}\sum\limits_{d|i,d|j}\mu(d)$$

枚举因数变枚举倍数，得：

$$\sum\limits_{t=1}^n\sum\limits_{d=1}^{\lfloor\frac n t\rfloor}\mu(d)\sum\limits_{i=1}^{\lfloor\frac n {dt}\rfloor}\sum\limits_{j=1}^{\lfloor\frac n {dt}\rfloor}t^{idt+jdt}$$

指数拆开得：

$$\sum\limits_{t=1}^n\sum\limits_{d=1}^{\lfloor\frac n t\rfloor}\mu(d)\sum\limits_{i=1}^{\lfloor\frac n {dt}\rfloor}(t^{dt})^i\sum\limits_{j=1}^{\lfloor\frac n {dt}\rfloor}(t^{dt})^j$$

因此有答案为：

$$\sum\limits_{t=1}^n\sum\limits_{d=1}^{\lfloor\frac n t\rfloor}\mu(d)\left(\sum\limits_{i=1}^{\lfloor\frac n {dt}\rfloor}(t^{dt})^i\right)^2$$

## step 2：具体计算

首先先来看看朴素计算方式。前两个求和号直接枚举为调和级数 $O(n\log n)$，后面那个求和号是等比数列求和，用公式为求逆元的 $O(\log p)$。

看似可过。

……吗？

你如果这样写，会发现小样例都过不去。

究其原因，请看等比数列求和公式：$\dfrac{a_1(1-q^n)}{1-q}$，其中 $q$ 是公比。

这里有个 $1-q$ 的分母！

而原题输入并没有保证 $n<p$，因此分母可能为 $0$。

具体而言，当 $t=1$ 或 $p-1|dt$ 时，该式分母为 $0$。

因此，用等比数列求和公式不是明智的选择。

怎么办？

联想快速幂的计算，我们发现这两个很像。

一般地，对于 $f(n)=\sum\limits_{i=1}^n p^i$，我们有：

$$f(n)=\left\{\begin{matrix}
 f(\dfrac n 2)(1+p^{\frac n 2}) & (2|n)\\

 f(\dfrac {n-1} 2)(1+p^{\frac {n-1} 2})+p^n & (2\nmid n)
\end{matrix}\right.$$

这个可以和快速幂一起递归，时间复杂度 $O(\log n)$。

总时间复杂度看着像 $O(n\log^2 n)$，但事实上这个级数的增长速度为 $O(n\log n)$。

## step 3：附上代码
其中加上了卡常科技 Barrett 模乘，跑得飞快。

```cpp
#include<bits/stdc++.h>
#define F(i,a,b) for(int i(a),i##i##end(b);i<=i##i##end;++i)
#define R(i,a,b) for(int i(a),i##i##end(b);i>=i##i##end;--i)
#define ll long long
#define ull unsigned ll
#define fir first
#define sec second
using namespace std;
const int MAXN=1500000;
typedef unsigned __int128 L;
struct FastMod {
    ull b, m;
    FastMod(ull b) : b(b), m((ull)((L(1) << 64) / b)) {}
    ull reduce(ull a) {
        ull q = (ull)((L(m) * a) >> 64);
        ull r = a - q * b; // can be proven that 0 <= r < 2*b
        return r >= b ? r - b : r;
    }
}MOD(2);
int n,p,T,ans;
inline ll qpow(ll base,int expo){
	ll res(1);
	base<0&&(base+=p);
	base=MOD.reduce(base);
	if(base==0) return expo==0;
	while(expo){
		(expo&1)&&(res=MOD.reduce(res*base));
		base=MOD.reduce(base*base),expo>>=1;
	}
	return res;
}
short mu[MAXN+1];
int sum[MAXN+1];
int prime[MAXN+1],cnt;
int vis[MAXN+1];
inline void init(){
	mu[1]=1;
	F(i,2,MAXN){
		int&qwq(vis[i]);
		short&qaq(mu[i]);
		if(!qwq) qwq=i,prime[++cnt]=i,qaq=-1;
		F(j,1,cnt){
			int t(prime[j]),k(i*t);
			if(k>MAXN) break;
			vis[k]=t;
			if(t==qwq) break;
			else mu[k]=-qaq;
		}
	}
	F(i,1,MAXN) sum[i]=sum[i-1]+mu[i];
	return;
}
inline pair<ll,ll> calc(int x,int y){
	if(y==1) return {x,x};
	auto res=calc(x,y>>1);
	res.fir+=MOD.reduce(res.fir*res.sec);
	res.fir>=p&&(res.fir-=p);
	res.sec=MOD.reduce(res.sec*res.sec);
	(y&1)&&(res.sec=MOD.reduce(res.sec*x),res.fir+=res.sec,res.fir>=p&&(res.fir-=p));
	return res;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	init();
	for(cin>>T;T;--T){
		cin>>n>>p;
		MOD=FastMod(p),ans=0;
		F(d,1,n){
			for(int k(d),t(1);k<=n;k+=d,++t){
				if(!mu[d]) continue;
				int tk(qpow(t,k));
				auto factor(calc(tk,n/k));
				factor.fir=MOD.reduce(factor.fir*factor.fir);
				ans+=(mu[d]==1?factor.fir:-factor.fir);
				ans>=p&&(ans-=p);
				ans<0&&(ans+=p);
			}
		}
		cout<<ans<<"\n";
	}
	return 0;
}
```

不喜勿喷 awa~

---

## 作者：pomelo_nene (赞：1)

难过啊难过，谁知道 $O(n \log n \log p)$ 会直接爆成 $10$ 分？

---

推推式子。


$$
\sum_{i=1}^n \sum_{j=1}^n \gcd(i,j)^{i+j}
$$
$$
\sum_{d=1}^n \sum_{i=1}^n \sum_{j=1}^n [\gcd(i,j)=d] d^{i+j}$$
$$
\sum_{d=1}^n \sum_{i=1}^{\lfloor \frac{n}{d}\rfloor} \sum_{j=1}^{\lfloor \frac{n}{d}\rfloor} [\gcd(i,j)=1] d^{id+jd}
$$
$$
\sum_{d=1}^n \sum_{i=1}^{\lfloor \frac{n}{d}\rfloor} d^{id} \sum_{j=1}^{\lfloor \frac{n}{d}\rfloor} d^{jd} \sum_{D|i,D|j} \mu(D)
$$

发现中间的两坨可以直接等比数列求和，于是枚举 $d$，然后枚举枚举 $d$ 的倍数。

然后最坑人的地方来了。当时在做这道题，发现直接用公式法算要求逆元，时间复杂度 $O(n \ln n \log p)$。

@Walking_Dead 写了一发只有 $10$ 分，于是很痛苦，认为正解/$50$ 分代码应该是 $O(n \log n)$ 及以下的。

实际上我们想要优化掉这个 $O(\log p)$
，应该换一种方式求等比数列和。可以用递归处理。

然后就完了，时间复杂度 $O(n \ln n \log n)$，欺负的应该是我这种不会奇淫技巧的菜鸡选手。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
LL mu[1500000+5],prime[1500000+5],cnt,n,p;
bool vis[1500000+5];
void shai(LL up)
{
	mu[1]=1;
	for(LL i=2;i<=up;++i)
	{
		if(!vis[i])	prime[++cnt]=i,mu[i]=-1;
		for(LL j=1;j<=cnt && i*prime[j]<=up;++j)
		{
			vis[i*prime[j]]=true;
			if(i%prime[j]==0)
			{
				mu[i*prime[j]]=0;
				break;
			}
			mu[i*prime[j]]=-mu[i];
		}
	}
}
LL QuickPow(LL x,LL pose,LL mod)
{
	LL base=x,ans=1;
	while(pose)
	{
		if(pose&1)	ans*=base,ans%=mod;
		base*=base;
		base%=mod;
		pose>>=1;
	}
	return ans;
}
LL sum(LL now,LL up,LL mod)
{
	if(up==1)	return now;
	if(up&1)	return ((1+QuickPow(now,up/2,mod))*sum(now,up/2,mod)%mod+QuickPow(now,up,mod))%mod;
	return (1+QuickPow(now,up/2,mod))*sum(now,up/2,mod)%mod;
}
LL refuse(LL x){return x>0?x:(p+x);}
int main(){
	shai(1500000);
	LL T;
	scanf("%lld",&T);
	while(T-->0)
	{
		scanf("%lld %lld",&n,&p);
		LL ans=0;
		for(LL i=1;i<=n;++i)
		{
			LL s=QuickPow(i,i,p),t=s;
			for(LL j=1;j<=n/i;++j)
			{
				ans+=refuse(mu[j])*sum(t,n/(i*j),p)%p*sum(t,n/(i*j),p)%p;
				ans%=p;
				t*=s;
				t%=p;
//				printf("%lld\n",ans);
			}
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```


---

## 作者：tommymio (赞：1)

题目简述：

$$
\sum_{i=1}^n\sum_{j=1}^{n} \gcd(i,j)^{i+j}
$$

求这个柿子模 $p$ 的值，多组询问。$\sum n\leq 1.5\times 10^6,p\in primes,p\leq 2^{32}-1$

套路莫反题，但是有很多细节值得商榷。

可以很轻松的得到这个式子：

$$
\sum_{d=1}^n\mu(d)\times \sum_{d|T}\left(\sum_{i=1}^{\frac{n}{T}}\left(d^T\right)^i\right)^2
$$

~~**拿错了换一个（我才不会告诉你我边界写错了推出这个奇怪的柿子**~~

$$
\sum_{d=1}^n\sum_{k=1}^{\frac{n}{d}}\mu(k)\left(\sum_{i=1}^{\frac{n}{kd}} (d^{dk})^{i}\right)^2
$$

也可以很轻松的看出是一个调和级数套等比数列。

重点其实在于等比数列的求解上，这里有两种解法（~~其实有三种但是某神仙让我别说第三种，嘤嘤嘤~~

- 公式法，只需用 $S_n=\frac{a_1(1-q^n)}{1-q}$。在本题中 $d^{dk}$ 为公比 $q$，但是涉及求逆元，如果直接快速幂，总时间复杂度是 $O(n \ln n \log p)$ 的，会获得暴力的好成绩$\color{purple}awa$。但是 $\color{black}\rm{E}\color{red}\rm{legia}$ 神仙告诉我可以线性求逆元，所以其实总时间复杂度是 $O(n \ln n)$ 的，具体可以见某位神仙用微积分的证明（。

- 分治法，定义 $S_n=\sum_{i=0}^{n-1} q^i$，根据下式：
$$
\begin{cases}
S_n=S_{\frac{n}{2}}(1+q^{\frac{n}{2}}),n\equiv0\pmod 2
\\
S_n=S_{\frac{n+1}{2}}(1+q^{\frac{n-1}{2}})-q^{\frac{n-1}{2}},n\equiv1\pmod 2 
\end{cases}
$$
- 使用快速幂计算 $q^{\frac{n}{2}},q^{\frac{n-1}{2}}$ 可以在不低于 $O(n \ln n \log n)$ 的时间复杂度内解决；这个时间复杂度不太优秀，事实上我们可以通过已经计算过的 $q$ 计算出现在 的 $q$，那么就可以在稳定低于 $O(n \ln n \log n)$ 的时间复杂度内解决这个问题。


---

## 作者：orz_z (赞：0)



### [P6825 「EZEC-4」求和](https://www.luogu.com.cn/problem/P6825)

求：
$$
\sum_{i=1}^{n}\sum_{j=1}^{n}\gcd(i,j)^{i+j}
$$
先化简原式，有：
$$
\begin{aligned}
&\sum_{i=1}^{n}\sum_{j=1}^{n}\gcd(i,j)^{i+j}\\
&=\sum_{d=1}^{n}\sum_{i=1}^{n}\sum_{j=1}^{n}d^{i+j}[\gcd(i,j)=d]\\
&=\sum_{d=1}^{n}\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{d}\rfloor}d^{d\cdot(i+j)}[\gcd(i,j)=1]\\
&=\sum_{d=1}^{n}\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{d}\rfloor}d^{d\cdot(i+j)}\sum_{p|\gcd(i,j)}\mu(p)\\
&=\sum_{d=1}^{n}\sum_{p=1}^{\lfloor\frac{n}{d}\rfloor}\mu(p)\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{d}\rfloor}d^{d\cdot(i+j)}[p|i][p|j]\\
&=\sum_{d=1}^{n}\sum_{p=1}^{\lfloor\frac{n}{d}\rfloor}\mu(p)\sum_{i=1}^{\lfloor\frac{n}{pd}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{pd}\rfloor}d^{dp\cdot(i+j)}\\
&=\sum_{d=1}^{n}\sum_{p=1}^{\lfloor\frac{n}{d}\rfloor}\mu(p)\sum_{i=1}^{\lfloor\frac{n}{T}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{T}\rfloor}d^{T\cdot(i+j)} & T=dp\\
&=\sum_{d=1}^{n}\sum_{p=1}^{\lfloor\frac{n}{d}\rfloor}\mu(p)\sum_{i=1}^{\lfloor\frac{n}{T}\rfloor}(d^T)^i\sum_{j=1}^{\lfloor\frac{n}{T}\rfloor}(d^T)^j\\
&=\sum_{d=1}^{n}\sum_{p=1}^{\lfloor\frac{n}{d}\rfloor}\mu(p)\left(\sum_{i=1}^{\lfloor\frac{n}{T}\rfloor}(d^T)^i\right)^2
\end{aligned}
$$

再看后面那部分，令 $x=\frac{T}{p}^T$。

设 $S_n$ 为等比数列前 $n$ 项和，则有：
$$
S_n=S_{\lfloor\frac{n}{2}\rfloor}(1+a^{\lfloor\frac{n}{2}\rfloor})+a^n[2 \nmid n]
$$
即可 $\mathcal O(\log n)$ 求解。

时间复杂度 $\mathcal O(n \log n)$。

```cpp
#include <bits/stdc++.h>

using namespace std;

#define ll long long

#define pll pair<ll, ll>

#define mpr make_pair

#define fi first

#define se second

const int _ = 1.5e6 + 10;

int mod;

int read()
{
    int x = 0, f = 1;
    char c = getchar();
    while (c < '0' || c > '9')
    {
        if (c == '-')
            f = -1;
        c = getchar();
    }
    while (c >= '0' && c <= '9')
    {
        x = x * 10 + c - '0';
        c = getchar();
    }
    return x * f;
}

int qpow(int x, int y)
{
    int res = 1;
    while (y)
    {
        if (y & 1)
            res = 1ll * res * x % mod;
        x = 1ll * x * x % mod;
        y >>= 1;
    }
    return res;
}

pll qsum(int a, int n)
{
    if (n == 0)
        return mpr(1, 1);
    if (n == 1)
        return mpr(a, a);
    pll tmp = qsum(a, n / 2);
    if (n & 1)
        return mpr((tmp.fi * (tmp.se + 1) % mod + tmp.se * tmp.se % mod * a % mod) % mod, tmp.se * tmp.se % mod * a % mod);
    else
        return mpr(tmp.fi * (tmp.se + 1) % mod, tmp.se * tmp.se % mod);
}

int T, n, m, k;

bitset<_> vis;

int cnt, pri[_], mu[_];

void init(int n)
{
    mu[1] = 1;
    for (int i = 2; i <= n; i++)
    {
        if (!vis[i])
            pri[++cnt] = i, mu[i] = -1;
        for (int j = 1; j <= cnt && i * pri[j] <= n; j++)
        {
            vis[i * pri[j]] = 1;
            if (i % pri[j] == 0)
                break;
            mu[i * pri[j]] = -mu[i];
        }
    }
}

int solve(int n)
{
    int ans = 0;
    for (int d = 1; d <= n; d++)
    {
        int a = qpow(d, d);
        int b = a;
        for (int p = 1; p <= n / d; p++)
        {
            pll tmp = qsum(b, n / (d * p));
            ans = (ans + tmp.fi * tmp.fi % mod * (mu[p] + mod) % mod) % mod;
            b = 1ll * b * a % mod;
        }
    }
    return ans;
}

signed main()
{
    T = read();
    init(_ - 10);
    while (T--)
    {
        n = read(), mod = read();
        printf("%d\n", solve(n));
    }
    return 0;
}
```



---


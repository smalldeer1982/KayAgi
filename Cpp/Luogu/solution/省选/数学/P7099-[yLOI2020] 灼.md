# [yLOI2020] 灼

## 题目背景

> 声嘶力竭，向悲泣的虚空祈祷至最后，  
> 神为何依然残酷冷漠。  
> 天国或地狱，也奢求你无垢眼眸，  
> 就让我，再次被你拯救。

——银临《灼》

## 题目描述

> 这里是 NS05，勒本星球已无生命反应，请求救援！普尔！——你听得到吗？我会一直在这里，等待你的归来。

扶苏被困在了勒本星球，灼闻羽驾驶着一架宇宙飞船正打算穿越虫洞到达勒本星球拯救扶苏。

在一条数轴上有 $n$ 个虫洞，第 $i$ 个虫洞的坐标为 $x_i$。进入这些虫洞的任意一个都可以直接到达勒本星球拯救扶苏。飞船到达数轴所在直线上后，会因为磁场的效应失去操控能力，飞船每秒会**等概率**向左或向右移动一个单位长度。

灼闻羽非常焦急，他给出了 $q$ 个飞船进入数轴所在直线的初始坐标，对于每个坐标，他想知道期望需要多少秒才能到达一个虫洞。

如果你计算出的期望是个分数，你需要求出这个分数对 $998244353$ 取模的答案。有关分数取模的定义你可以参考「提示」中的内容。

为了避免输出过大，你只需要输出四个整数，分别表示你所有回答（对 $998244353$ 取模之后，下同）的按位异或之和、你共有多少次回答的答案是奇数，你的所有答案中的最大值、你的所有答案中的最小值。

## 说明/提示

### 样例 1 解释

数轴上 $1, 3$ 两点有虫洞。当飞船初始坐标为 $1$ 或 $3$ 时，可以直接进入虫洞，花费 $0s$；当初始坐标为 $2$ 时，有 $\frac 1 2$ 的概率向左一个单位，花费 $1s$ 进入虫洞，也有 $\frac 1 2$ 的概率向右一个单位，花费 $1s$ 进入虫洞，期望用时为 $\frac 1 2 \times (1 + 1) = 1$。

因此，三次询问的答案分别为 $0, 1, 0$。

### 数据规模与约定

本题共有 $10$ 个测试点，每个测试点 $10$ 分。

- 对于 $10\%$ 的数据，保证 $n = 1$。
- 对于 $20\%$ 的数据，保证对于任意一个虫洞，总存在另一个虫洞，使得他们之间的距离不超过 $2$。例如，样例中两个虫洞的距离为 $2$。
- 对于 $30\%$ 的数据，保证对于任意一个虫洞，总存在另一个虫洞，使得他们之间的距离不超过 $3$。
- 对于 $50\%$ 的数据，保证 $x_i,q \leq 100$。
- 对于 $70\%$ 的数据，保证 $x_i, q \leq 10^5$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 10^5$，$1 \leq q \leq 5 \times 10^6$，$1 \leq x_i, y_j \leq 10^9$，$y_j$ 不小于 $x_i$ 中的最小值，且 $y_j$ 不大于 $x_i$ 中的最大值，$y_j$ 按照不降序给出。

### 提示

- 如果你不知道什么是分数取模，可以参考如下的内容：

  对于一个形如 $\frac a b$ 的既约分数，其中 $b \lt 998244353$，它对 $998244353$ 取模后的值为 $a \times b^{998244351} \bmod {998244353}$ 。 
- 为了方便用脚造数据，数据**并不**保证 $x_i$ 互不相同。
- 请注意大量数据读入对程序效率造成的影响。
- 本题的特殊输出方式只是为了避免输出过大造成程序超时，与本题解法无关。
- 请注意，$T$ **不是**数据组数。
- 本题共有两个附加文件，见附加文件中的 zhuo.zip。	

## 样例 #1

### 输入

```
0
2 3
1 3
1
2
3
```

### 输出

```
1
1
1
0```

# 题解

## 作者：一扶苏一 (赞：9)

### F

#### Algorithm 1

对于虫洞间距离不超过 $2$ 的情况，显然答案只有 $0$ 和 $1$ 两种可能。期望得分 $20$ 分。

#### Algorithm 2

考虑推一推式子。设 $f_i$ 表示在坐标 $i$ 时的期望步数，那么转移显然：

$$f_{i} = \frac 1 2(f_{i - 1} + f_{i + 1}) + 1$$

这个式子的意思是分别有 $\frac 1 2$ 的概率向左走向右走，然后变为对应坐标的期望步数。同时因为走了一步，所以最后要 $+1$。

边界条件是在虫洞结点上 $f_i = 0$。

对于子任务 $3$，可以通过手算发现这时候不在虫洞上的 $f$ 的值为 $2$。结合算法一，期望得分 $30$ 分。

#### Algorithm 3

用高斯消元求解算法二中的式子，时间复杂度 $O(qn^3)$，期望得分 $50$ 分。

#### Algorithm 4

验题人拉瓦手算带入消元得到了一个递推式，可以矩阵加速，时间复杂度 $O(q \log n)$ 带 $8$ 倍常数。期望得分 $70$ 分。

#### Algorithm 5

考虑把算法二中的式子乘二然后整理，可以得到

$$(f_{i + 1} - f_{i}) - (f_{i} - f_{i - 1}) = -2$$

这就是说，$f$ 的二阶差分是一个非零常数。因此 $f$ 的通项公式一定是一个二次多项式。

我们考虑正着推式子：对于 $g(x) = ax^2 + bx + c$，有 $g(x - 1) = a(x^2 - 2x + 1) +b(x - 1) + c$，$g(x + 1) = a(x^2 + 2x + 1) +b(x + 1) + c$。

因此 $g(x) - g(x - 1) = 2ax - a + b$；$g(x + 1) - g(x) = 2ax + a + b$。

因此 $[g(x + 1) - g(x)] - [g(x) - g(x - 1)] = 2a$。这就是说，二次函数的二阶差分值是其二次项系数的两倍。因此可以得到 $f$ 的通项公式的二次项系数是 $-1$。同时我们还知道 $f$ 的两个零点，因此可以直接以零点式写出 $f$ 的通项公式，带入 $x$ 即可 $O(1)$ 计算。时间复杂度 $O(n \log n + q)$。这里的 $\log n$ 需要对 $x$ 数组进行排序。然后用指针指向第一个大于询问值的元素。因为询问是单调不降的，所以指针移动是均摊 $O(1)$ 的。期望得分 $100$ 分。

```cpp
#include <cstdio>
#include <cctype>
#include <iostream>
#include <algorithm>

template <typename T>
inline void qr(T &x) {
  char ch = getchar(); x = 0;
  while (!isdigit(ch)) ch = getchar();
  while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
}

const int maxn = 100005;
const int mod = 998244353;


int n, q;
int ans, answ, answe = -1, answer = mod + 1; 
int a[maxn];

int main() {
  qr(n); qr(n); qr(q);
  for (int i = 1; i <= n; ++i) {
    qr(a[i]);
  }
  std::sort(a + 1, a + 1 + n);
  for (int x, p = 1; q; --q) {
    qr(x);
    while ((p < n) && (a[p] <= x)) ++p;
    int y = 1ll * (x - a[p - 1]) * (a[p] - x) % mod;
    ans ^= y;
    if (y & 1) ++answ;
    answe = std::max(answe, y);
    answer = std::min(answer, y);
  }
  std::cout << ans << std::endl << answ << std::endl << answe << std::endl << answer << std::endl;
}
```



---

## 作者：water_tomato (赞：4)

本文同步发表于个人博客：[Link](https://www.watertomato.com/p7099-yloi2020-%e7%81%bc-%e9%a2%98%e8%a7%a3/)。

## 题意

[题目链接](https://www.luogu.com.cn/problem/P7099)。

数轴上有 $n$ 个虫洞，有 $q$ 个按坐标升序给出的飞船，保证飞船一定在不会在第一个虫洞左边或最后一个虫洞右边。每个飞船每秒会等概率左移一格或右移一格，对于每个飞船，求到达任意一个虫洞的期望时间。

## 解析

记 $f_i$ 为位置在 $i$ 的飞船的期望时间，只要 $i$ 位置没有虫洞（有虫洞期望时间显然为 $0$），就有 $f_i=1+\frac{1}{2}(f_{i-1}+f_{i+1})$，化简得 $(f_{i+1}-f_i)-(f_i-f_{i-1})=-2$，即其**二阶差分**为一定值，由此可知 $f_i$ 为一个二次函数。将 $f_x=ax^2+bx+c$ 代入上式，可得其二次项系数为 $-1$。

由于飞船一定在两个虫洞之间，记这两个虫洞的位置分别为 $x_1$ 和 $x_2$，我们得到了这个二次函数的两个零点，结合求出的二次项系数可以写出零点式：$f_x=-(x-x_1)(x-x_2)$。

由于飞船坐标升序给出，每个飞船在哪两个虫洞之间是易于维护的，本题解决。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+5;
const int M=5e6+5;
const int mod=998244353;
int T,n,q,x[N],y[M];
int ANS,ansji,ansmx=-1,ansmn=1e9;
signed main(){
	scanf("%lld",&T);scanf("%lld%lld",&n,&q);
	for(int i=1;i<=n;i++) scanf("%lld",&x[i]);
	sort(x+1,x+1+n);int now=2;//对 x 进行排序
	if(n==1) x[2]=x[1];//特判 n=1
	for(int i=1,y;i<=q;i++){
		scanf("%lld",&y);
		while(y>x[now]) now++;//更新现在在哪两个虫洞之间
		int ans=-(y-x[now-1])*(y-x[now])%mod;//代入公式
		ANS^=ans;if(ans&1) ansji++;
		ansmx=max(ansmx,ans);ansmn=min(ansmn,ans);
	}
	printf("%lld\n%lld\n%lld\n%lld",ANS,ansji,ansmx,ansmn);
	return 0;
}
```

---

## 作者：Inaki (赞：4)

[传送门](https://www.luogu.com.cn/problem/P7099)

## 原题
### 题目描述
- 扶苏被困在了勒本星球，灼闻羽驾驶着一架宇宙飞船正打算穿越虫洞到达勒本星球拯救扶苏。

- 在一条数轴上有 $n$ 个虫洞，第 $i$ 个虫洞的坐标为 $x_i$ 。进入这些虫洞的任意一个都可以直接到达勒本星球拯救扶苏。飞船到达数轴所在直线上后，会因为磁场的效应失去操控能力，飞船每秒会等概率向左或向右移动一个单位长度。

- 灼闻羽非常焦急，他给出了 $q$ 个飞船进入数轴所在直线的初始坐标，对于每个坐标，他想知道期望需要多少秒才能到达一个虫洞。

- 如果你计算出的期望是个分数，你需要求出这个分数对 $998244353$ 取模的答案。有关分数取模的定义你可以参考「提示」中的内容。

- 为了避免输出过大，你只需要输出四个整数，分别表示你所有回答（对 $998244353$ 取模之后，下同）的按位异或之和、你共有多少次回答的答案是奇数，你的所有答案中的最大值、你的所有答案中的最小值。

### 输入格式
- 第一行是一个整数，表示测试点所对应的编号 $T$ 。

- 第二行有两个整数，分别表示虫洞的个数 $n$ 和初始坐标的个数 $q$ 。

- 第三行有 $n$ 个整数，第 $i$ 个整数表示第 $i$ 个虫洞的坐标 $x_i$ 。

- 接下来 $q$ 行，每行一个整数，表示一个飞船进入数轴所在直线的初始坐标 $y_j$ 。

- **保证给出的 $y_j$ 以不降序排序。**

### 输出格式
- 输出四行，每行一个整数，依次表示你所有回答的按位异或之和、你共有多少次回答的答案是奇数，你的所有答案中的最大值、你的所有答案中的最小值。

## 简化题意
给定一个点的位置，一个左端点和一个右端点，每秒有 $\frac{1}{2}$ 的概率向左或向右走一个单位长度，询问期望多少秒可以到达左端点或右端点。

## 题目思路
- 第一种方法，高斯消元
- 第二种方法，数学题推式子，下面是简要证明过程：

设 $f(i)$ 为从位置为 $i$ 的点走到左端点或右端点任意一个的期望时间

则 $f(l)=f(r)=0$ 。
其中期望是试验中每次可能结果的概率乘以其结果的总和，可以理解为取平均值。则对于每个 $f(i)$ ，有
$$
f(i)=\frac{f(i-1)+1+f(i+1)+1}{2}
$$
整理得
$$
f(i)=\frac{1}{2}\times (f(i+1)+f(i-1)) +1
$$
等号两边同时乘以 $2$ 得
$$
2\times f(i)=f(i+1)+f(i-1)+2
$$
移项得
$$
f(i+1)-f(i)=f(i)-f(i-1)-2
$$
设 $g(i)=f(i+1)-f(i)$ ,则上式可得
$$
g(i)=g(i-1)-2
$$
等差数列通项公式可得
$$
g(i)=g(1)-(i-1)\times2
$$
由上式可知， $g$ 为等差数列
由于
$$
f(l)=f(r)=0
$$
所以
$$
f(r)-f(l)=0
$$
展开
$$
f(r)-f(r-1)+f(r-1)-...-f(l+1)+f(l+1)-f(l)=0
$$
将 $g(i)=f(i+1)-f(i)$ 代入上式
$$
\sum^{r-1}_{i=1} g(i)=0 
$$
由等差数列求和公式可知
$$
\frac{(g(r-1)+g(l))\times(r-l)}{2}=0
$$
则
$$
g(r-1)+g(l)=0
$$
由 $g(i)=g(1)-(i-1)\times2$ 可得
$$
g(1)-(r-2)\times2+g(1)-(l-1)\times2=0
$$
$$
g(1)-r\times2+4+g(1)-l\times2+2=0
$$
$$
g(1)\times2=l\times2+r\times2-6
$$
$$
g(1)=l+r-3
$$
由于最终询问 $f(p)$ ，且 $f(l)=0$ ，可得
$$
f(p)=f(p)-f(l)
$$
同 $f(r)-f(l)=0$ 的展开方式
$$
f(p)=f(p)-f(p-1)+f(p-1)-...-f(l+1)+f(l+1)-f(l)
$$
$$
f(p)=g(p-1)+g(p-2)+...+g(l+1)+g(l)
$$
$$
f(p)=\sum^ {p-1}_ {i=l} g(i)
$$
$$
f(p)=\frac{(g(l)+g(p-1))\times(p-l)}{2}
$$
$$
f(p)=\frac{(g(1)-(l-1)\times2+g(1)-(p-2)\times2)\times(p-l)}{2}
$$
$$
f(p)=\frac{(g(1)\times2-l\times2-p\times2+6)\times(p-l)}{2}
$$
$$
f(p)=(g(1)-l-p+3)\times(p-l)
$$
将 $g(1)=l+r-3$ 代入上式，可得
$$
f(p)=(r-p)\times(p-l)
$$
至此，证明位置 $p$ 的答案就是 $(p-l)\times(r-p)$ 。
## Some Tricks
- 题目中给定了一些虫洞的位置，需要我们预处理出离询问最近的左右两个虫洞。
- 用 set 可以很好地解决问题。 set 中的 lower_bound(x) 函数可以查询到大于等于 $x$ 的最小值，而小于等于 $x$ 的最大值就是 lower_bound 函数查询值的前一个位置，因为 set 具有去重和排序功能，所以相邻两个位置数值不等，且相隔最近。
- code
```cpp
it=s.lower_bound(y);
r=*it;
--it;
l=*it;
```
## In the End
[100pts code](https://www.luogu.com.cn/paste/8y9dinw1)

---

## 作者：Max_QAQ (赞：2)

**思路：**

感觉像道数学题。~~（我的做法确实也挺像数学方法的）~~

根据题意我们可以根据一般概率期望题的套路列出一个转移方程。

**设：**

$f_{i}$ 表示从离他最近的两个虫洞走到他的期望步数。

那么我们的转移方程就长这样。

$$f_{i}=\frac{1}{2}(f_{i+1}+f_{i-1})+1$$

其中当 $i$ 位置是虫洞时， $f_i=0$ 。

解释一下方程。

每个位置的期望步数可以由他左右的位置转移过来，而每个位置又都有 $\frac{1}{2}$ 的可能往左或往右走，所以要乘 $\frac{1}{2}$ ，而既然走了一步那步数就要加 $1$ 。

所以长这样。

$$f_{i}= \frac{1}{2}(f_{i-1}+1)+\frac{1}{2}(f_{i+1}+1)$$

化简以后就长上面那个样子了。

很明显要求解这个问题的话，需要用的高斯消元，但是这样很明显会超时。

那我们就对这个式子进行化简。

$$f_{i}=\frac{1}{2}(f_{i+1}+f_{i-1})+1$$

$$2\times f_{i}=f_{i+1}+f_{i-1}+2$$

$$f_{i+1}-f_i+2=f_i-f_{i-1}$$

**设：** $g_{i}=f_i-f_{i-1}$

则$g_{i+1}-g_i=-2$

二阶差分为定值，所以 $f$ 的通项公式为二次。

可以根据二阶差分的公式求出 $f$ 的通项公式，这里就不再列了。

当然也可以直接带几个特殊值求解，这样当然更快。

求出的通项公式长这样 $f_{x}=-1\times x^2+(r-l)\times x$ 。

$l$ ， $r$ 分别表示他左右最近的两个虫洞。

得出这个式子后我们就可以对每个坐标点进行求解了。

为了快速找出离他最近的虫洞，我们需要对所有的虫洞进行排序，然后利用二分查找查询。

得到最近的虫洞坐标以后再进行通项公式的计算即可。

**注意：** 记得取余。

贴个代码。

```cpp

#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x*f;
}
inline void write(int x){
	static int sta[42];int top=0;
	if(x<0) putchar('-'),x=-x;
	do{sta[++top]=x%10,x/=10;}while(x);
	while(top) putchar(sta[top--]+'0');
	return putchar('\n'),void();
}
inline void chkmax(int &x,int y){x=(x>y)?x:y;}
inline void chkmin(int &x,int y){x=(x<y)?x:y;}
int T,n,q;
int x[100010],ans1,ans2,ans3,ans4;
int a=-1,b;
inline int f(int x){
	return a*x*x+b*x;
}
signed main(){
	T=read();n=read();q=read();
	for(int i=1;i<=n;i++) x[i]=read();
	sort(x+1,x+1+n);
	for(int i=1,y,l,r,t;i<=q;i++){
		y=read();
		l=upper_bound(x+1,x+1+n,y)-x-1;
		r=l+1;
		l=x[l];r=x[r];
		if(y==l||y==r){
			ans1^=0;
			chkmin(ans4,0);
		}
		b=r-l;
		t=f(y-l)%998244353;
		ans1^=t;
		if(t%2==1) ans2++;
		chkmax(ans3,t);
		chkmin(ans4,t);
	}
	write(ans1);write(ans2);write(ans3);write(ans4);
	return 0;
}

```

---

## 作者：Conless (赞：2)

[观看效果更佳](https://www.luogu.com.cn/blog/Conless/post-xie-ti-bao-gao-yloi2020-zhuo)

贴一下[原题](https://www.luogu.com.cn/problem/P7099)

好久没做过非传统高斯消元的期望类问题了，由于终点只会被经过一次，因此我们可以考虑从两个终点开始定义状态，令靠近位置$pos$的两个端点为$l$和$r$，到达任意终点的期望步数为$f_i$，则有：

$f_i = \frac{1}{2}(f_{i+1} + f_{i-1})+1$

特殊的，$f_l=f_r=0$

$\because 2f_i = f_{i+1}+f_{i-1}+2$

$\therefore f_{i+1}-f{i}=f_{i}-f_{i-1}+2$

于是问题就转化为一道低于全国卷难度的数学题了

$\therefore 令g_i=f_{i+1}-f_i$

$\therefore g_i=g_{i-1}-2$，$\{g_i\}$为等差数列

$\therefore 设g_i=g_1-2(i-1)$

$\because \Sigma_{i=l}^{r-1} g_i=f_r-f_l=0$

$\therefore [g_1-2(l-1)+g_1-2(r-2)]*(r-1)/2=0$

$\therefore g_1=l+r-3$

$\therefore f_{pos}=f_{pos}-f_l=\Sigma_{i=l}^{pos-1}g_i=(r-pos)(pos-l)$

注意到输入中$y_i$单调不降，那么我们一遍扫过去更新$l,r$即可

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>

using namespace std;

const int MAXN = 100005;
const int MOD = 998244353;

int T, n, q;
int pos[MAXN];
long long ans, ans1, ans2, ans3, ans4;

int main()
{
    scanf("%d%d%d", &T, &n, &q);
    for (int i = 1; i <= n; i++)
        scanf("%d", &pos[i]);
    sort(pos + 1, pos + n + 1);
    int nex = 1;
    ans4 = 1e18;
    for (int i = 1; i <= q; i++)
    {
        int npos;
        scanf("%d", &npos);
        while (npos > pos[nex]) nex++;
        ans = 1LL * (npos - pos[nex - 1]) * (pos[nex] - npos) % MOD;
        ans1 ^= ans;
        ans2 += ans & 1;
        ans3 = max(ans3, ans);
        ans4 = min(ans4, ans);
    }
    printf("%lld\n%lld\n%lld\n%lld", ans1, ans2, ans3, ans4);
    return 0;
}
```

---

## 作者：Little09 (赞：2)

~~自己推的好像有一点点麻烦，而且和现有题解相比都要麻烦~~……

但是只是一道可以用初中数学知识解决的数学题。

题目很显然可以转化为：有 $1$ 到 $n$ 共 $n$ 个点，一个人在点 $x$，每次等概率向左或向右走 $1$ 个点，求走出这 $n$ 个点（即到 $0$ 或 $n+1$ ）的期望步数。（此句中的 $n$ 与题目的 $n$ 不同）

考虑设 $f_i$ 表示在第 $i$ 个点的期望步数，显然地：

$$f_0=f_{n+1}=0$$

由对称性：

$$f_i=f_{n-i+1}$$

根据期望的定义可知：

$$f_i=\dfrac{1}{2}(f_{i-1}+f_{i+1})+1(1\le i\le n)$$

稍微转化一下：

$$2\times f_i=f_{i-1}+f_{i+1}+2$$

$$(f_{i+1}-f_{i})-(f_{i}-f_{i-1})=-2$$

所以说 $f$ 的二阶差分一个非零常数 $-2$。

设函数 $g$ 为 $f$ 的差分，即 $g_i=f_{i}-f_{i-1}$。继续推：

$$g_{i+1}-g_{i}=-2$$

$$g_{i}=g_1-2\times (i-1)$$

由于 $f_i=g_i+f_{i-1}$，带入 $g_i$：

$$f_i=f_1-2\times (i-1)+f_{i-1}$$

当 $i=n+1$ 时：

$$f_{n+1}=f_1-2\times n+f_{n}$$
$$0=2\times f_1-2\times n$$
$$f_1=n$$

再推：

$$f_i=\sum_{j=1}^ig_j$$

代入 $g_j$：

$$f_i=\sum_{j=1}^i(f_1-2\times(j-1))$$
$$f_i=i\times f_1-i\times(i-1)$$

由于 $f_1=n$，代入就得到最终答案：

$$f_i=-i^2+(n+1)\times i$$

所以代入，对于飞入坐标 $x$，上一个虫洞坐标 $l$，下一个虫洞坐标 $r$，答案为：

$$ans=-(x-l)^2+(r-l)\times (x-l)$$

$$ans=(r-x)\times (x-l)$$

代码已经很简单了，不必放了吧。

---

## 作者：zyn_ (赞：0)

很好的 MO 一试题。

如果飞船与某个虫洞重合了答案显然为 $0$。否则，容易发现时间的期望只与飞船到左右两个**最近的**虫洞的**距离**相关。

由于 $y_j$ 按不降序给出，可以对 $\{x_i\}$ 排序后双指针求出左右虫洞的位置。

设飞船离左右虫洞的距离分别为 $l,r$。不妨设飞船位于 $0$。

考虑递推，设 $f_i$ 为处于位置 $i$ 时到达虫洞的时间的期望。于是

$$
f_{-l}=f_r=0
$$

且有 

$$
f_i=\dfrac{f_{i-1}+f_{i+1}}{2}+1
$$

这个式子化为 

$$
f_i-f_{i-1}=f_{i+1}-f_i+2
$$

令 $g_i=f_i-f_{i-1}$，则 $g_i=g_{i+1}+2$，故 $g_n=g_0-2n$。

注意到 

$$
\sum_{i=1-l}^rg_i=\sum_{i=1-l}^r(f_i-f_{i-1})=f_r-f_{-l}=0
$$

这时就可以求 $g_i$ 了。

$$
\sum_{i=1-l}^r(g_0-2i)=0
$$

$$
(l+r)g_0=\sum_{i=1-l}^r 2i=(1-l+r)(l+r)
$$

$$
g_0=1-l+r
$$

要求的是 $f_0$，也就是

$$
f_{-l}+\sum_{i=1-l}^0 g_i
$$

就是个等差数列求和。

$$
\sum_{i=1-l}^0(g_0-2i)=lg_0+(l-1)l=lr
$$

答案真漂亮。

> 如果你计算出的期望是个分数，你需要求出这个分数对 $998244353$ 取模的答案。

> 你只需要输出四个整数，分别表示你所有回答（对 $998244353$ 取模之后，下同）的……

笑点解析：答案一定是整数。但是还是要取模的。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 100009
int n,q,x[N],p,ans,o1,o2,o3,o4;long long y;
int main(){
    scanf("%*d%d%d",&n,&q);
    for(int i=1;i<=n;++i)scanf("%d",&x[i]);
    sort(x+1,x+n+1);
    p=1;o4=0x3f3f3f3f;
    while(q--){
        scanf("%lld",&y);
        while(p<n&&x[p+1]<=y)++p;
        ans=(x[p+1]-y)*(y-x[p])%998244353;
        o1^=ans,o2+=(ans&1),o3=max(o3,ans),o4=min(o4,ans);
    }
    printf("%d\n%d\n%d\n%d\n",o1,o2,o3,o4);
    return 0;
}
```

---

## 作者：Φρανκ (赞：0)

题意：数轴上有 $n$ 个点。给定另一个点使其每步随机向一个方向移动 $1$，求其首次与任一点重合时步数的期望。

核心思想：构造，数学归纳法

解：

显然，一个点最先重合的点一定是它左右的第一个点之一（因为它不能跨越任何点）。令 $f(i, j)$ 表示一个左边 $i$ 远，右边 $j$ 远在该方向上首次有点的点的步数期望。那么 $\forall i,j\in\mathbb{N}$ 有：

- $f(i, j)=f(j, i)$。（显然）
- $f(0, i)=f(i, 0)=0$。（开始时就已经与点重合）
- $f(i, j)=1+\frac{f(i-1, j+1)+f(i+1, j-1)}{2}$。（等概率向左右移动）

代入可以发现 $f(i, j)=ij$ 满足上述条件。

更严格的证明如下：

考虑一个“斜行”，即序列 $f(0, k),f(1, k-1),...,f(k, 0)$，可以发现其形如 $x_0, x_1,...,x_{\frac{k-1}{2}},x_{\frac{k-1}{2}},...,x_1,x_0$ 或 $x_0,x_1,...,x_{\frac{k}{2}},...,x_1,x_0$，取决于 $k$ 的奇偶性。那么有：

- 由上文性质二，$x_0=0$。
- 由上文性质三，$x_i=1+\frac{x_{i+1}+x_{i-1}}{2}$。
- 由上一条，若 $x_{i+1}-x_i=k$，$x_i=1+\frac{x_i+k+x_{i-1}}{2}$，$x_i-x_{i-1}=2+k$，$(x_{i+1}-x_i)=(x_i-x_{i-1})-2$。
- 对于 $k\equiv 0\bmod 2$，$x_{\frac{k}{2}}=x_{\frac{k}{2}-1}+1$，由第三条得该斜行的差分构成数列 $k-1,k-3,...,3,1,-1,-3,...,3-k,1-k$，即 $f(i+1, k-i-1)-f(i, k-i)=x_{i+1}-x_i=k-1-2i$。 
- 对于 $k\equiv 1\bmod 2$，$x_{\frac{k-1}{2}}=x_{\frac{k+1}{2}}$，由第三条得该斜行的差分构成数列 $k-1,k-3,...,2,0,2,...,3-k,1-k$，即 $f(i+1, k-i-1)-f(i, k-i)=x_{i+1}-x_i=k-1-2i$。 

因此，对于所有斜行，有$f(i+1, k-i-1)-f(i, k-i)=k-1-2i=(i+1)(k-i-1)-i(k-i)$：若有 $f(i, k-i)=i(k-i)$，就有 $f(i+1, k-i-1)=(i+1)(k-i-1)$。注意到 $\forall i\in\mathbb{N},f(0, i)=0i$，由数学归纳法可证所有 $f(i, j)=ij$。

代码：
```
#include <bits/stdc++.h>
using namespace std;
const long long mod=998244353;
long long t, n, q, x[100001], y, l, temp, res1, res2, res3, res4=25000000000000001; 
int main()
{
	ios::sync_with_stdio(false);//关闭同步
	cin>>t>>n>>q;
	for(int i=1; i<=n; i++)
		cin>>x[i];
	sort(x+1, x+n+1);//不要忘记排序
	for(int i=1; i<=q; i++)
	{
		cin>>y;
		while(x[l+1]<y)
			l++;//找左点
		temp=(y-x[l])*(x[l+1]-y)%mod;//计算f(i, j)
		res1^=temp;
		if(temp%2==1)
			res2++;
		res3=max(res3, temp);
		res4=min(res4, temp);//分别计算
	}
	cout<<res1<<endl<<res2<<endl<<res3<<endl<<res4;//输出
	return 0;
}
```


---


# [COCI 2019/2020 #3] Sob

## 题目背景

在漆黑的平安夜晚上，一个巨大的驯鹿闯入，对我们的英雄说：「在你解决这个问题之前，我将不会离开。」

## 题目描述

给定两个正整数 $N,M$。

现要将集合 $A=\{0,1,2,\cdots,N-1\}$ 和 $B=\{M,\cdots,M+N-1\}$ 中的数进行组合，选出 $N$ 个有序数对 $(x_i,y_i)$。要求：

- $x_i \in A$，$y_i \in B$，$x_i \& y_i = x_i$（$\&$ 表示按位与运算）。
- 所有的 $x_i$ 互不相同，所有的 $y_i$ 互不相同。

## 说明/提示

#### 数据范围及约定

| Subtask | 分值 | 数据范围及约定 |
| :----------: | :----------: | :----------: |
| $1$ | $10$ | $N$ 是 $2$ 的整数次幂 |
| $2$ | $29$ | $N+M$ 是 $2$ 的整数次幂 |
| $3$ | $39$ | $N+M \le 1000$ |
| $4$ | $32$ | 无 |

对于 $100\%$ 的数据，$1 \le N \le M, N+M \le 10^6$。

#### 说明

本题使用自行编写的 [Special Judge](https://www.luogu.com.cn/paste/462bmlh1)，欢迎大家 hack（可私信或直接发帖）。

**本题分值按 COCI 原题设置，满分 $110$。**

**题目译自 [COCI2019-2020](https://hsin.hr/coci/archive/2019_2020/) [CONTEST #3](https://hsin.hr/coci/archive/2019_2020/contest3_tasks.pdf)  _T5 Sob_ 。**

## 样例 #1

### 输入

```
1 3```

### 输出

```
0 3```

## 样例 #2

### 输入

```
3 5```

### 输出

```
0 7
1 5
2 6```

## 样例 #3

### 输入

```
5 10```

### 输出

```
0 12
1 13
2 10
3 11
4 14```

# 题解

## 作者：7KByte (赞：9)

首先题目已经给出了结论，就是对于任意 $N,M$ 均有解。

所以如果 $A$ 中后 $x$ 个数和 $B$ 中前 $x$ 个数两两配对，就可以转化为 $N-x,M+x$ 的子问题。

所以对于 $A$ 中最后一个数 $n-1$ ，在 $B$ 中至少存在一个数 $x$ 使得 $x\ \&\ (n-1) = n-1$ 。我们只记录 $B$ 中最小的 $x$ 。

关键结论：$\forall k\in[0,x-m]\ ,\ (x-k)\ \&\ (n-1-k)=(n-1-k)$ 。

说人话，就是将 $A$ 后面这一段和 $B$ 前面这一段按顺序两两配对一定是合法解。

感性理解以下，因为在 $[m,x)$ 区间内的数和 $n-1$ 配对都不合法，而 $x$ 是第一个合法的，所以 $x$ 和 $n-1$ 最后几位相同，而这包括了区间 $[m,x]$ 。

理性分析以下，我们令 $n-1$ 中为 $1$ ，而 $m$ 中为 $0$ 的最高位为第 $i$ 位，那么枚举 $x$ 的过程就是将最低的 $i$ 位一直加到后 $i $ 位和 $n-1$ 完全相同。那么再减回去也一定完全相同。

```cpp
#include<cstdio>
#define rep(i,a,b) for(int i=a;i<=b;i++)
int main(){
	int n,m;scanf("%d%d",&n,&m);
	for(int i=n-1,j=m;~i;){
		int k=j;
		while((k&i)!=i)k++;
		rep(r,0,k-j)printf("%d %d\n",i--,k-r);
		j=k+1;
	}return 0;
}
```

---

## 作者：ChenHaoQi (赞：2)

# 题目：[COCI2019-2020#3] [Sob](https://www.luogu.com.cn/problem/P7207)
### 题号：P7207  
### 当前难度：$\color{purple}\text{省选/NOI−}$ 
### 采用算法：大致 $\Omicron(n)$ 的时间复杂度

首先看题。题目已经证明，**符合条件的方案一定存在**，也就是对于每个 $x_i \in A$ 一定有 $y_i \in B$使得$x_i \& y_i=x_i$（ $\&$ 表示**按位与**运算），所以我们可以给 $A$ 中的每个元素 $x_i$ 顺序地在 $B$ 中找到对应的元素 $y_i$。

那么按什么顺序查找呢？如果只是朴素的对每一个 $x_i \in A$ 都去找一个对应的 $y_i \in B$，那么什么顺序都无所谓，但是时间复杂度超过 $\Omicron(n\sqrt{n})$，指不定就 $\color{orange} TLE$ 了，所以我们需要用更快的查找方式。

我们观察 $a \& b=a$ 的情况。我们将$a$，$b$ 分别表示为二进制，就会发现若 $a \& b=a$，则必然 $a$ 二进制中为 $1$ 的数位对应的 $b$ 二进制中也为 $1$，而 $a$ 二进制中为 $0$ 的数位， $b$ 为 $1$ 或 $0$ 就都无所谓了。于是我们可以得出，对于任意$x_i \& y_i=x_i(x_i \in A,y_i \in B)$，则总有倒数 $q$ 位相同。因为 $x_i < y_i(N \le M,x_i<N,y_i \ge M)$，所以**只要 $x_i$ 二进制的倒数 $k$ 位不为 $0$，则 $x_i-1$ 与 $y_i-1$ 仍满足 $a \& b=a$ 的条件 $(x_i \neq 0)$**。  

根据以上的性质，我们可以从 $N-1$ 开始**逆序**遍历集合 $A$。设 $x$ 为当前要匹配的 $A$ 中元素，$x$ 从 $N-1$ 开始，我们从 $M$ 起在 $B$ 中找到第一个满足 $a \& b=a$ 条件的 $y (y \in B)$，然后不断减 $1$，直到 $x$ 的倒数 $q$ 位为 $0$ 或 $y<M$。若因为 $y<M$ 结束，则做完后相当是得到了一个 $N=N-x$,$M=M+x$ 的子问题，于是更新 $N$ 和 $M$ 递归解决，直到 $N=0$ 结束；若否，则比较复杂了，但我们可以证明这种情况不存在。

为什么呢？首先，我们又设与 $x$ 对应的从 $M$ 起在 $B$ 中的满足 $a \& b=a$ 的第一个数为 $y$，则**我们需要证明的是 $y-M \le x$**。我们将对应的 $x$ 和 $M$ 写成二进制，并找到第 $k$ 位，满足第 $k$ 位是从左往右数的第一位满足 $x$ 的第 $k$ 位 $>M$ 的第 $k$ 位的数位。然后，我们将这两个二进制数以从左往右数的第 $k$ 位作为分界线分成左右两部分（第 $k$ 位属于第二部分）。如此，则 $x$ 的第一部分必然小于 $M$ 的第一部分，$x$ 的第二部分必然大于 $M$ 的第二部分。而我们已经知道 $x \& y=x$ 时 $x$ 二进制为 $1$ 的数位 $y$ 也都为 $1$，而第 $k$ 位实际上是从左往右数第一位 $k$ 为 $1$，$M$ 为 $0$ 的数位，那么第一部分（即 $k$ 左边）的数位中若 $x$ 为 $1$，则 $M$ 也为 $1$。也就是说第一部分实际上已经符合要求。剩下第二部分，记 $x$ 的第二部分为 $x'$，$M$ 的第二部分为 $M'$，则 $x'>M'$。因为此时 $x'$ 的一位为 $1$，$M'$ 的同一位为 $0$，则说明要使 $M+p$ 得到 $y$ 使 $x$ 与 $y$ 满足 $a \& b=a$ 的 $p$ 最小，只有当 $M'+p=x'$ 时形成的 $y$ 才能最小（因为 $M'<x'$）。此时的 $y$ 左半部分大于 $x$，等于 $M$；右半部分等于 $x$。那么 $y-M$ 就相当是减掉了左半部分；右半部分等于 $x-M'$，即 $y-M=x-M'$。因为 $M'\ge 0$，所以 $x-M' \le x$，所以 **$y-M \le x$**。于是我们便证明了第二种情况不存在。

那么既然只存在第一种情况，就好办了：设 $n=N-1,y=m=M$，$y$不断自加，直到与 $n$ 满足 $a \& b=a$。然后 $n$ 和 $y$ 同时自减至 $y<m$，期间每一个 $n$ 都对应着一组解；做完后更新 $m=y+1$（自减前的 $y$），不断循环，直至 $n<0$，结束。

温馨提示：位运算比比较运算低级，所以要加括号！否则就会[$\color{red}WA$](https://www.luogu.com.cn/record/189281947)。。

## $\color{forestgreen} AC$ code:
```cpp
#include<iostream>
using namespace std;
using returningANDwish=int; //...
returningANDwish rp=0; //...

int main(){
	int N,M;
	cin>>N>>M;
	int n=N-1,m=M; //n,m
	while(n>=0){ //n可以等于0
		int y=m;
		while((n&y)!=n) y++; //记得加括号
		int oriy=y; //自减前的y
		while(y>=m){ //循环求每一组n和y
			cout<<n<<" "<<y<<"\n";
			n--;
			y--;
		}
		m=oriy+1; //更新m
	}
	
	return rp++; //结束&rp++
}
```
## [AC link](https://www.luogu.com.cn/record/189806804)

---

## 作者：DengDuck (赞：2)

很牛的题。

我们对于 $x$ 与 $y$ 等于 $x$ 的情况称为 $x$ 是 $y$ 的子集。

直觉告诉我们，匹配应该是 $A$ 连续的一段匹配 $B$ 连续的一段。

我们假设 $(x,y)$ 匹配成功，思考一下，对于 $(x,y)$ 最大的相同后缀，我们减一之后应该还是也是成立的（$x$ 依旧是 $y$ 的子集）。

贪心地考虑，对于 $B$ 这一边，假如存在 $x,y\in B$，同时 $x$ 是 $y$ 的子集，那么 $y$ 应该可以匹配更多的 $A$ 中的元素。

所以，我们想到用 $A$ 中较大的数字去匹配 $B$ 中较小的数字，这样应该是最优的，所以我们从 $x=n-1$ 开始，找一个最小的 $y$，然后直接匹配这样连续的一段，这样就做到 $\mathcal O(n)$ 了。


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=n-1,j=m;i>=0;)
	{
		int k=j;
		while((k&i)!=i)k++;
		for(int l=0;l<=k-j;l++)printf("%d %d\n",i,k-l),i--;
		j=k+1;
	}
}
```

---

## 作者：hcywoi (赞：1)

比较不牛的 $O(N\log N)$ 的做法。

令 $K$ 为最小的整数满足 $2^K\ge N$。

先特判 $2^K=N$ 的情况。

容易发现，现在只有 $N, M$ 的 $0\sim K-1$ 位有用。

考虑 $[0, N)$ 和 $[M, M+N)$ 后 $K$ 位的取值，将它画在数轴上。有以下情况：

1. $M$ 的后 $K$ 位在 $N$ 的后 $K$ 位左边。

![](https://cdn.luogu.com.cn/upload/image_hosting/cuc03mc1.png)

对于这种情况，将中间重叠的部分对应匹配，然后就转换成 $N$ 更小的子问题。

2. $M$ 的后 $K$ 位在 $N$ 的后 $K$ 位右边。

![](https://cdn.luogu.com.cn/upload/image_hosting/19uzf06l.png)

首先因为 $N\ge 2^{K-1}+1$，所以 $M$ 的后 $K$ 位一定包含 $2^K-1$。

对于紫色线段，先两两匹配。对于绿色线段和蓝色线段两两匹配，即对于 $i$ 满足它被蓝色线段包含，将 $i$ 和 $i+2^{K-1}$ 匹配。然后将 $N'\gets N-2^{K-1}$，$M'\gets M-2^{K-1}$，就变成了一个子问题。递归求解即可。

**注意：** 上述情况可能会有不存在蓝色线段（紫色线段包含了 $2^{K-1}$），需要特殊处理，方法与不存在该情况的相似。

时间复杂度：由于每一次 $2$ 操作会让 $K$ 减 $1$。进行一次操作 $1$ 后必然变成操作 $2$。所以时间复杂度为 $O(N\log N)$。

### 代码

```cpp
#include <bits/stdc++.h>

using i64 = long long;

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);

  int N, M;
  std::cin >> N >> M;

  auto work = [&](auto self, int N, int M) -> std::vector<std::pair<int, int>> {
    int logn = std::__lg(N);
    std::vector<std::pair<int, int>> ans;
    if ((1 << logn) == N) {
      for (int i = M; i < N + M; i++) {
        ans.emplace_back(i & (1 << logn) - 1, i);
      }
      return ans;
    }
    logn++;
    int K = M & ((1 << logn) - 1);
    if (K >= N) {
      int c = 0;
      for (int i = M + (K ^ (1 << logn) - 1) + 1; i < M + N; i++) {
        c++;
        ans.emplace_back(i & (1 << logn) - 1, i);
      }

      while (c < N && !(c >> (logn - 1) & 1)) {
        ans.emplace_back(c, M - K + c + (1 << logn - 1));
        c++;
      }

      while (ans.size() > (1 << logn - 1)) {
        ans.pop_back();
      }

      auto res = self(self, N - (1 << logn - 1), M - (1 << logn - 1));
      for (auto [x, y] : res) {
        x += 1 << logn - 1;
        y += 1 << logn - 1;
        if ((y & (1 << logn) - 1) >= (1 << logn - 1)) {
          ans.emplace_back(x, y);
        } else {
          ans.emplace_back(x, M + (K ^ (1 << logn) - 1) + 1 + (1 << logn - 1) + (y & (1 << logn) - 1));
        }
      }
    } else {
      for (int i = K; i < N; i++) {
        ans.emplace_back(i, M + i - K);
      }
      int t = N - K;
      N -= t;
      M += t;
      auto res = self(self, N, M);
      for (auto [x, y] : res) {
        ans.emplace_back(x, y);
      }
    }
    return ans;
  };

  auto ans = work(work, N, M);
  for (auto [x, y] : ans) {
    std::cout << x << " " << y << "\n";
  }

  return 0;
}
```

---

## 作者：CCX_CoolMint (赞：1)

看题解已经看懵了，不是很懂，于是自己研究一下写一篇题解，算是对 @7KByte 大佬的题解做一个更易懂的解释。

首先我们可以发现一个这样的性质，举个例子：

我们可以列出 $15,14,13,12,11,10,9$ 的二进制数，它们分别是 

``1111``、``1110``、``1101``、``1100``、``1011``、``1010``、``1001``。

然后再列出 $7,6,5,4,3,2,1$ 的二进制数，它们分别是

``0111``、``0110``、``0101``、``0100``、``0011``、``0010``、``0001``。

我们发现对于一些二进制数，它们的后若干位是可以互相对应上的，并且这一对数较小的那个数的前若干位二进制全为 $0$（如 $15$ 对应 $7$，$10$ 对应 $2$），这启发我们在对题目中的数字进行组合时，是可以一段一段进行组合的。原因：既然数字对应的末尾若干位二进制相同，那么小的二进制数按位与上大的二进制数，就可以构造出符合题目的有序数对，对它们不断减一，相应的也可以构造出符合题意的有序数对，直到它们没有末尾相同的若干位二进制为止。我们从 $n-1$ 开始构造，每次都可以构造出连续的一段，直至构造出 $n$ 对有序数对为止。

如果你要问出现 $(1010)_2$ 和 $(1011)_2$ （即 $10$ 和 $11$）这种可以匹配上，但是末尾没有若干相同位的二进制的有序数对怎么办？没关系啊，就让它们直接匹配，因为它们比较特殊，它们可以成为长度为 $1$ 的独立的一段。

代码和 @7KByte 大佬的代码是一样的，通过这种方法，对于第三个样例，我们构造出的方案就是：

```
(第一段)
4 12
3 11
2 10

(第二段)
1 13

(第三段)
0 14
```

这样就做完了。

---

## 作者：denominator (赞：1)

> [原题](https://www.luogu.com.cn/problem/P7207)
>
> - **本题下标从 0 开始**。
> - 构造一个 $\{m,m+1,\cdots,m+n-1\}$ 的排列 $p$，使得 $i\mathop{\text{and}}p_i=i$（$i=0,1,\cdots,n-1$，$\text{and}$ 表示按位与）。
> - $m+n\leq10^6$。

这有紫？这有紫？这有紫？简单构造。

考虑看到位运算，显然就是拆位。拆位之后，原条件即要求 $i$ 在二进制下某一位为 $1$ 蕴含 $p_i$ 在二进制下这一位为 $1$。我们申明以下两个命题，证明显然，之后要用。

**命题 1.** $\{0,1,\cdots,n\}$ 中的奇数不多于 $\{m,m+1,\cdots,m+n-1\}$ 中的奇数，其中，奇数数量相等当且仅当 $2\nmid n$ 与 $2\nmid m$ 中有一个 **不成立**，否则后者多一个奇数。

**命题 2.** $\left\lfloor\dfrac{k}{2}\right\rfloor+1=\left\lfloor\dfrac{k+2}{2}\right\rfloor$。

这两个命题便于我们将 $\{m,m+1,\cdots,m+n-1\}$ 按奇偶性划分为长度为 $\left\lceil\dfrac{n}{2}\right\rceil$ 与 $\left\lfloor\dfrac{n}{2}\right\rfloor$ 的两个部分（称为 $A$ 和 $B$），其中后半部分都是奇数（为的是方便与下午的 $S$ 和 $T$ 进行配对以满足条件）。

依 **命题 1**，先考虑 $\{0,1,\cdots,n\}$ 中的奇数与 $\{m,m+1,\cdots,m+n-1\}$ 中的奇数数量相等的情况。此时，我们同样也可以将 $\{0,1,\cdots,n\}$ 划分为长度为 $\left\lceil\dfrac{n}{2}\right\rceil$ 的偶数部分与 $\left\lfloor\dfrac{n}{2}\right\rfloor$ 的奇数部分（称为 $S$ 和 $T$）。此时由 **命题 2** 可知，这两部分除以二向下取整的部分都是连续数列，且因为 $\lfloor0\rfloor=\left\lfloor\dfrac{1}{2}\right\rfloor=0$，序列的首项均为 $0$。同时，$\{m,m+1,\cdots,m+n-1\}$ 划分成的两个序列 $A$ 与 $B$ 除以二向下取整后也自然是两个连续数列，问题转换为对 $S,A$ 与 $T,B$ 除以二向下取整后解决，所以我们将问题的规模减半了。

若 $\{m,m+1,\cdots,m+n-1\}$ 中的奇数数量比 $\{0,1,\cdots,n\}$ 中的奇数数量多了一个，这时我们不得不将一个奇数投入 $A$ 中了。由 **命题 1** 可知 $2\nmid m$，可以猜测这个奇数就是 $m$。实际上，$\left\lfloor\dfrac{m}{2}\right\rfloor+1=\left\lfloor\dfrac{m+1}{2}\right\rfloor$，所以将 $m$ 投入 $A$ 中后，$A$ 的元素除以二向下取整后也形成了一个连续数列。于是问题的规模也减半了。

一开始做的时候，差点在上一个步骤卡死了 /kk（因为考虑了最后一个奇数）。

最终的时间满足递推式 $T(n)=T\left(\dfrac{n}{2}\right)+\mathcal O(n)$，解得 $T(n)=\mathcal O(n\log n)$。不太清楚 $\mathcal O(n)$ 是怎么做的。注意这种做法的时间复杂度与 $m$ 无关。

代码使用了 `vector` 实现，可能相对于数组更加直观一点。

说实话，这题代码真的短！


```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m;
vector <int> work (int n, int m) {
	vector <int> ans;
	ans.resize (n);
	if (n == 1) {
		ans[0] = m;
		return ans;
	}
	vector <int> ans1, ans2;
	// 下面两个调用的 m 分别是 A, B 中第一个数除以二下取整的结果
	// 可能需要稍微注意点细节
	// 如果看不懂，下面两行代码等价于：
	// if (n & 1) {
	// 	if (m & 1) {
	// 		ans1 = work ((n + 1) >> 1, m >> 1);
	// 		ans2 = work (n >> 1, (m >> 1) + 1);
	// 	} else {
	// 		ans1 = work ((n + 1) >> 1, m >> 1);
	// 		ans2 = work (n >> 1, m >> 1);
	// 	}
	// } else {
	// 	if (m & 1) {
	// 		ans1 = work ((n + 1) >> 1, (m >> 1) + 1);
	// 		ans2 = work (n >> 1, m >> 1);
	// 	} else {
	// 		ans1 = work ((n + 1) >> 1, m >> 1);
	// 		ans2 = work (n >> 1, m >> 1);
	// 	}
	// }
	ans1 = work ((n + 1) >> 1, (m >> 1) + (1 - (n & 1)) * (m & 1));
	ans2 = work (n >> 1, (m >> 1) + (n & 1) * (m & 1));
	for (int i = 0; i < (n + 1) >> 1; i++) { // 合并下标在集合 S 中的部分
		if (ans1[i] == m >> 1) { // 这是 n 与 m 都为奇数时的特判，将 m 归入 A 中
			ans[i << 1] = m;
		} else { // 否则，A 中的元素就是偶数，普通合并即可
			ans[i << 1] = ans1[i] << 1;
		}
	}
	for (int i = 0; i < n >> 1; i++) { // 合并下标在集合 T 中的部分
		ans[i << 1 | 1] = ans2[i] << 1 | 1;
	}
	return ans;
}
int main () {
	scanf ("%d%d", &n, &m);
	vector <int> ans = work (n, m);
	for (int i = 0; i < n; i++) {
		printf ("%d %d\n", i, ans[i]);
	}
	return 0;
}
```

---

## 作者：WeLikeStudying (赞：1)

- 身体是革命的本钱。
- 希望各位身体健康。

**题意**
- [题目](https://www.luogu.com.cn/problem/P7207)。
- 给出 $[0,n-1]$ 和 $[m,m+n-1]$ 的一个匹配，满足对任何一个配对 $(x,y)$ 都有 $x\operatorname{and} y=x$。 

**分析**
- 我有一个 $O(n^{1.58})$ 的做法，我甚至去实现了它……[代码](https://www.luogu.com.cn/paste/llcogm9w)。
- 下面是一个能够通过此题的做法：考虑按照奇偶性分别讨论，分解成更小的子问题。
- 考虑按照奇偶性讨论，你会发现 $[0,n-1]$ 的 $0$ 的数目永远不少于 $[m,m+n-1]$，如果两个区间最低位 $0,1$ 的数目完全一样，那么就可以直接转化为整除二的问题。
- 否则我们 $[0,n-1]$ 的 $0$ 更多，此时 $m$ 一定是奇数，所以可以把它划到偶数那里处理，同样把它分成了两个更小的子问题。
- 下面是处理 $n=3,m=5$ 的图解：
![](https://cdn.luogu.com.cn/upload/image_hosting/guxnssi9.png)
- 给出 $O(n\log n)$ 的代码，虽然可以做到线性：[代码](https://www.luogu.com.cn/paste/kyu39zj3)。

---

## 作者：AlephRei (赞：0)

upd：原 tj 正确性有误，应在第二步中将 $X-M$ 的上界缩小。

这是一道数学风味的 $OI$ 思维题。这一类题的经典套路就是数学归纳法。这里考虑对 $N$ 进行数学归纳。

证明一下为何每个 $N,M$ 都会有解。（不想证明的，也需注意到 $N-1$ 的匹配对象，然后考虑如何实现归纳。但是既然题目说明必有解，是在提示数学归纳法。）

### 第一步：考察 $N-1$ 应与谁匹配

$N-1$ 是其中限制最大的因而首先考虑它。

设 $2^k\le N <2^{k+1}$，将 $B$ 中数对 $2^{k+1}$ 取模，应形如这个 $\bmod$ 环上的一段区间，且区间长度为 $N$。

观察环上 $N-1$ 和 $2^{k+1}-1$ 这两个点。（显然这两个点不是同一个点）

若 $B$ 不包含这两个点，则 $\max (2^{k+1}-1-(N-1)-1,N-1-1)\ge N$ 即 $\max (2^{k+1}-N-1,N-2)\ge N$。而 $2^{k+1}-N-1=2(2^k-N)-1+N\le N-1<N$，矛盾。

从而 $N-1$ 必然可以与 $B$ 中一个数匹配。

### 第二步：实现归纳

希望让 $A$ 的一个后缀，可以匹配 $B$ 的一个前缀，最有可能也是最有性质的是最小的可以匹配 $N-1$ 的数。

设此数为 $X\ge N-1$。设在 $N-1$ 与 $X$ 的二进制表示中，设两者相异的最低位为 $2^t$（在这个位上，$X$ 为 $1$，$N-1$ 为 $0$），再记 $x'$ 为 $X$ 后 $t$ 位所表示的值（如 $(1001)_2$ 的后 $2$ 位表示 $(01)_2$）。

由 $X$ 的最小性知 $M\ge X-x'$，否则用 $X-x'-1$ 可以替换 $X$（其末 $t$ 位为 $1$，第 $t+1$ 位为 $0$，可以匹配 $N-1$）。从而对于任意的 $k\in [0,X-M]$，$N-1-k$ 与 $X-k$ 的最后 $t+1$ 位是相同。

对于这些 $k$，因为 $X-M\le x'$，相减的过程中至多使得 $N-1$ 和 $X$ 的后 $t$ 位变为 0，不会影响更高的位。

综上，对于所有如是 $k$，均有 $(X-k)\&(N-1-k)=X-k$。故而对于每一个 $N$，都可以找到 $N$ 的一个后缀与 $M$ 的一个前缀匹配。原命题得证。

随后考虑如何实现代码，只要 $N$ 不是负的，暴力找到这个最小的 $X$ 即可，然后从 $X$ 开始 到 $M$ 结束 $(N-1-k,X-k)$ 一一对应输出即可。

代码如下：

```cpp
int N,M;
//bool FLB;
signed main(){
	//cerr<<((&FLB)-(&FLA))/1024.0/1024<<endl;
	cin>>N>>M;N--;
	while(N>=0){
        int j=M,k=M;
        while((N&j)!=N)j++;
        M=j+1;
        while(j>=k){printf("%d %d\n",N--,j--);}
	}
}
```

---


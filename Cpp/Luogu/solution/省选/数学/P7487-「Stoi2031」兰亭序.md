# 「Stoi2031」兰亭序

## 题目背景

> 无关风月 我题序等你回 悬笔一绝 那岸边浪千叠 情字何解 怎落笔都不对 而我独缺 你一生的了解 ——《兰亭序》

## 题目描述

月非常喜欢复数，尤其喜欢形如 $e^{2\pi it}$ 的复数。她选择了两个正整数 $n,k$，并将 $1+e^{\frac{2\pi i x_1 \dots x_k}{n}}$ 称为 $(x_1,\dots,x_k)$ 的 **绝对度**，所有满足 $1 \le x_i \le n$ $(i \in \{1,2,\dots,k\})$ 的 $(x_1,\dots,x_k)$ 的 **绝对度** 之积称为 $(n,k)$ 的 **无关度**。现在她想请你帮她对 $t \in \{1,2,\dots,k\}$ 求出 $(n,t)$ 的 **无关度** $ans \bmod{335544323}$。由于回答太多的数太麻烦，你只要回答她所有答案进行异或运算后的结果。

## 说明/提示

#### 简述版题意：

给定 $n,k$，对 $1 \le t \le k$ 求

$$\prod_{x_1=1}^{n}\prod_{x_2=1}^{n}\dots\prod_{x_t=1}^{n}\left( 1+e^{\frac{2\pi ix_1x_2\dots x_t}{n}} \right) \bmod{335544323}$$

输出所有 $k$ 个答案的异或和。

其中 $e^{it}=\cos{t}+i\sin{t}$ 对所有 $t \in \mathbb{R}$ 成立，$i$ 为虚数单位，满足 $i^2=-1$。

#### 样例解释：

对于第一组样例，$t=1,2$ 时答案分别为 $2,35184372088832$，取模后为 $2,201012021$，异或和为 $201012023$。

对于第二组样例，$t=1,2,3$ 时答案均为 $2$，异或和为 $2$。

限于篇幅，剩下的样例不作解释说明。

#### 数据范围：

**本题采用捆绑测试，各个 Subtask 的限制与分值如下：**

| Subtask No. | $n \le$ | $k \le$ | 特殊限制 | 分值 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| $1$ | $10$ | $1$ | 无 | $7$ |
| $2$ | $1$ | $10$ | 无 | $7$ |
| $3$ | $10$ | $2$ | 无 | $7$ |
| $4$ | $10^{18}$ | $10^5$ | $n$ 为偶数 | $7$ |
| $5$ | $10$ | $10$ | $n^k \le 730$ | $16$ |
| $6$ | $10^9$ | $10^3$ | 无 | $19$ |
| $7$ | $10^{18}$ | $10^5$ | 无 | $37$ |

对于 $100\%$ 的数据，$1 \le n \le 10^{18},1 \le k \le 10^5$。

## 样例 #1

### 输入

```
15 2
```

### 输出

```
201012023
```

## 样例 #2

### 输入

```
1 3
```

### 输出

```
2
```

## 样例 #3

### 输入

```
521 6
```

### 输出

```
262795752
```

## 样例 #4

### 输入

```
6546546546546543 22211
```

### 输出

```
388124125
```

# 题解

## 作者：VinstaG173 (赞：6)

推式子。

首先 $n$ 为偶数时 $1+e^{\frac{2\pi i\cdot (\frac{n}{2})\cdot (1)^{t-1}}{n}}=0$，故答案为 $0$。

下面看 $n$ 为奇数。考虑取 $\log$ 将乘积转化成求和，打些小数据~~从样例 1 猜结论~~发现答案基本都是 $2$ 的幂。令 $f(n,t)=\log_2\left(\prod_{x_1=1}^{n}\prod_{x_2=1}^{n}\dots\prod_{x_t=1}^{n}\left( 1+e^{\frac{2\pi ix_1x_2\dots x_t}{n}} \right)\right)$。

设 $\omega=e^{\frac{2\pi i}{n}}$。首先有 $\prod\limits_{x=1}^{n}\left( u-\omega^x \right)=u^n-1$， $\prod\limits_{x=1}^{n}\left( 1+e^{\frac{2\pi ix}{n}} \right)=(-1)^n\cdot((-1)^n-1)=2=2^1$。故 $f(n,1)=1$。

其他时候我们考虑处理 $x_1$，当 $\gcd(x_1,n)=d,x_1=dy,n=dm$ 时，

$$\begin{aligned}
\prod_{x_2=1}^{n}\dots\prod_{x_t=1}^{n}\left( 1+e^{\frac{2\pi ix_1x_2\dots x_t}{n}} \right)&=\prod_{x_2=1}^{n}\dots\prod_{x_t=1}^{n}\left( 1+e^{\frac{2\pi iyx_2\dots x_t}{m}} \right)\\
&=\left(\prod_{x_2=1}^{m}\dots\prod_{x_t=1}^{m}\left( 1+e^{\frac{2\pi ix_2\dots x_t}{m}} \right)\right)^{d^{t-1}}\\
&=2^{d^{t-1}f(m,t-1)},
\end{aligned}$$

故（$d=\gcd(x,n),m=\dfrac{n}{d}$，下同）

$$\begin{aligned}
f(n,t)&=\sum_{x=1}^{n}d^{t-1}f(m,t-1)\\
&=\sum_{d|n}\sum_{\gcd(x,n)=d}d^{t-1}f(m,t-1)\\
&=\sum_{d|n}\varphi(m)d^{t-1}f(m,t-1),
\end{aligned}$$

显然当 $f(n,t-1)$ 积性时 $f(n,t)$ 也积性。

那么就只要对 $n$ 分解质因子，求出每个 $f(p^v,t)$。

Pollard-Rho 分解质因数然后直接递推即可，时间复杂度 $O(n^{\frac{1}{4}}+k\max\{v\})$。

---

## 作者：bigmurmur (赞：1)

[原题链接](https://www.luogu.com.cn/problem/P7487)

没有找到除了出题人 $VinstaG173$ 其他的做法

首先证明一个东西：

$\prod_{i=1}^n\ (x-w^i)=x^n-1$

除了单位根反演甚至于分圆的证法（虽然并不会），证明来自于 $zxyhymzg$

首先，令左侧式子 $\prod_{i=1}^n\ (x-w^i)=0$ ，显然，在复数域下共有 $w_1,w_1……w_n$ 一共 $n$ 个复数根，

再次，令右侧式子 $x^n-1=0$ ，根据代数基本定理，该多项式方程在复数域下恰好有 $n$ 个根，根据已有知识可以说明其 $n$ 个根恰好为 $w_1,w_1……w_n$

因此左右两多项式本质相同，最高次项系数相同，也就是左右多项式相等。

根据 $VinstaG173$ 的表可以知道，任何一个固定 $t,n$ 的题目式子的结果都是  $2$ 的整次幂（$n$为偶数）。

我们不妨令 $\prod_{x_1=1}^n\ \prod_{x_2=1}^n\ ……\prod_{x_t=1}^n\ (1+e^{\frac{2\pi ix_1x_2……x_t}{n}})=2^{g(t,n)}$

那么来考虑几个边界情况：

#### 1. $n=1$

那么原式子可以变成 $(1+e^{\frac{2\pi i}{1}})=1+1=2^1$，那么 $g(t,1)=1$

#### 2. $t=1$

那么原式变成：

$\ \ \ \ \prod_{x=1}^n\ (1+e^{\frac{2\pi ix}{n}})$

$=\prod_{x=1}^n\ (1-(-w^x))$

$=(-1)^n\ \prod_{x=1}^n\ ((-1)-w^x)$

$=(-1)^n\ ((-1)^n-1)$

$=2^1$

因此 $g(1,n)=1$



处理完了边界情况，我们看看如何处理一般的 $g(t,n)$

我们先把 $x_n$ 提取出来，不妨令 $(n,x_t)=d,n=md,x_t=yd$

那么原式变成：

$\ \ \ \ \prod_{x_1=1}^n\ \prod_{x_2=1}^{n}\ ……\prod_{x_{t-1}=1}^n\ (1+e^{\frac{2\pi i\prod_{x_i}}{n}})$

$=\prod_{x_1=1}^n\ \prod_{x_2=1}^n……\prod_{x_{t-1}=1}^n\ (1+e^{\frac{2\pi i\ x_1x_2……x_{t-1}y}{m}})$

显然的一点是 $y<=m,(y,m)=1,m|n$ ，因此对于 $e$ 的指数上乘上一个不在 $\prod$ 内枚举的 $y$ ，就像是对其做了一个下标变化，去掉这个 $y$ 本质上不会发生变化

因此原式变成：

$\prod_{x_1=1}^n\ \prod_{x_2=1}^n……\ \prod_{x_{t-1}}^n (1+e^{\frac{2\pi i \prod_{i!=t} x_i}{m}})$

对于这个式子，我们知道对于 $x \in [1,n]$ ，其中 $w$ 为 $e^{\frac{2\pi i}{m}}$必然满足 $(1+(w^s)^x)=(1+(w^s)^{x\ mod\ m})$

因此对于任意一个 $x_i$ 一共有 $\frac{n}{m}=d$ 种对答案贡献相同

因此原式变成：

$(\prod_{x_1=1}^m\ \prod_{x_2=1}^m……\ \prod_{x_{t-1}}^m (1+e^{\frac{2\pi i \prod_{i!=t} x_i}{m}})\ )^{d^{t-1}}$

对于括号里面的式子我们发现这是一个子问题： $2^{g(t-1,m)}$

因此，原式变成：

$(2^{g(t-1,m)})^{d^{t-1}}=2^{g(t-1,m)\ d^{t-1}}$

接下来我们枚举一个 $x_t$

先对他取个对数，因此，

$g(t,n)=\sum_{d=1}^n \sum_{x=1}^n [(x,n)=d]\ g(t-1,\frac{n}{d})\ d^{t-1}$

​            $=\sum_{d|n}\ d^{t-1}\ g(t-1,\frac{n}{d})\sum_{x=1}^n[(x,n)=d]$

​            $=\sum_{d|n}\ d^{t-1}\ g(t-1,\frac{n}{d})\sum_{d|x}^n[(\frac{x}{d},\frac{n}{d})=1]$

​            $=\sum_{d|n}\ d^{t-1}\ g(t-1,\frac{n}{d})\  \varphi(\frac{n}{d})$

仔细观察发现，对于每一个质数 $p^k$ ，$g(t,p^k)$均有完整定义且方便计算，观察其形式，发现 $g(t,n)$ 和 $g(t-1,\frac{n}{d})$ 同时为积性或者非积性。又因为 $g(n,1)=g(1,t)=1$ ，满足一般积性函数所有性质。

因为我们直接对 $n$ 进行质因数分解，并计算 $g(p_i^{c_i},t)$ 乘起来，再取个 $2$ 的次幂。注意在计算 $g$ 的时候模数是 $MOD-1$ （费马）

一个关键的事情，当 $n$ 为偶数的时候注意特判。

因为我们可以构造一组 $x$ 满足 $x_1=\frac{n}{2}$ ，$x_2……x_t$ 为 $1$

显然此时我们的式子有一个子式变成：

$(1+e^{\frac{2 \pi i (\frac{n}{2})}{n}})=(1+e^{\pi i})=1+(-1)=0$

因此 $n$ 为偶数时 $ans=0$


出题人没有给 $std$ ，看起来 $WA$ 率很高

$Code:$
```cpp
#include<map>
#include<ctime>
#include<cstdio>
#include<vector>
#include<cstring>
#include<cstdlib>
#include<assert.h>
#include<iostream>
#define int long long
#define max(a,b) ((a)<(b)?(b):(a))
using namespace std;
const int mod=335544323;
typedef unsigned long long ull;
const int N=1e6+5,maxn=1e6;

vector<int> G,P;
int cnt,ans[N][70];
int prime[N],tot;
bool flag[N];

struct Pollard_Rho{
	vector<int> g,p;
	map<int,int> vis;
	
	inline int Gcd(int a,int b) {return b==0?a:Gcd(b,a%b);}
	inline ull Mul(ull a,ull b,ull mod)
	{
		ull c=a*b-(ull)((long double)a/mod*b+0.5L)*mod;
		return c<b?c:c+mod;
	}
	inline int power(int a,int p,int mod)
	{
		int ans=1,base=a;
		while(p){
			if(p&1ll) ans=Mul(ans,base,mod);
			base=Mul(base,base,mod);
			p>>=1ll;
		}
		return ans;
	}
	inline int F(int x,int c,int mod) {return (Mul(x,x,mod)+c)%mod;}
	inline void Pre()
	{
		for(register int i=2;i<=maxn;++i){
			if(!flag[i])
				prime[++tot]=i;
			for(register int j=1;j<=tot;++j){
				if(i*prime[j]>maxn) break;
				flag[i*prime[j]]=1;
				if(i%prime[j]==0) break;
			}
		}
		flag[1]=1;
	}
	inline bool Miller(int n)
	{
		if(n<=maxn) return !flag[n];
		int k=0,a=n-1;
		while(!(a&1ll)) ++k,a>>=1ll;
		for(register int tim=0;tim<10;++tim){
			int x=rand()%(n-2)+2,v=power(x,a,n);
			if(v==1 || v==n-1) break;
			for(register int i=1;i<k;++i){
				v=Mul(v,v,n);
				if(v==n-1) break;
			}
			if(v!=n-1) return false;
		}
		return true;
	}
	inline int Pollard(int x)
	{
		int goal=1,s=0,t=0;
		int c=rand()%(x-1)+1;
		for(;;goal<<=1,s=t){
			int val=1;
			for(register int i=1;i<=goal;++i){
				t=F(t,c,x);
				val=Mul(val,abs(t-s),x);
				if(i%127==0){
					int t=Gcd(val,x);
					if(t>1) return t;
				}
			}
			int t=Gcd(val,x);
			if(t>1) return t;
		}
	}
	inline void Fac(int n)
	{
		if(n<2) return ;
		if(Miller(n)){
			if(vis[n]) ++p[vis[n]-1];
			else{
				p.push_back(1),g.push_back(n);
				vis[n]=g.size();
			}
			return ;
		}
		int x=n;
		while(x>=n) x=Pollard(n);
		n/=x;
		Fac(x),Fac(n);
	}    
	inline void Factor(int n)
	{
		if(n==1) return G.clear(),G.push_back(1),P.clear(),P.push_back(0),void();
		srand(19260817);
		Fac(n);
		G.clear(),P.clear();
		G=g,P=p;
	}
	inline void Print(int n)
	{
		cerr<<"n= ";
		for(register int i=0;i<G.size()-1;++i)
			cerr<<G[i]<<"^"<<P[i]<<" x ";
		if(G.size())
			cerr<<G[G.size()-1]<<"^"<<P[P.size()-1]<<endl;
	}
}Pollard;

int n,K;

inline int power(int a,int p,int mod)
{
	int ans=1,base=a;
	while(p){
		if(p&1ll) ans=ans*base%mod;
		base=base*base%mod;
		p>>=1ll;
	}
	return ans;
}
signed main()
{
	Pollard.Pre();
	scanf("%lld%lld",&n,&K);
	assert(K<=(int)(1e5));
	Pollard.Factor(n);
	Pollard.Print(n);
	if(n%2ll==0) return puts("0"),0;
	{
		cnt=0;
		for(register int k=0;k<(int)G.size();++k){
			int p=G[k],lim=P[k];
			ans[1][cnt]=1;
			for(register int i=cnt+1;i<=cnt+lim;++i) ans[1][i]=1;
			cnt+=lim+1;
		}
	}
	const int MOD=mod-1;
	for(register int t=2;t<=K;++t){
		cnt=0;
		for(register int k=0;k<(int)G.size();++k){
			int p=G[k],lim=P[k];
			for(register int c=0,g=1;c<=lim;++c,g*=p){
				int res=0;
				for(register int i=0,h=1,f=g;i<=c;++i,h*=p,f/=p){
					res=(res+power(h%MOD,t-1,MOD)%MOD*ans[t-1][cnt+c-i]%MOD*((f-f/p)%MOD)%MOD)%MOD;
				ans[t][cnt+c]=res;
			}
			cnt+=lim+1;
		}
	}
	int Ans=0;
	for(register int t=1;t<=K;++t){
		int res=1;cnt=0;
		for(register int k=0;k<(int)G.size();++k)
			res=res*ans[t][cnt+P[k]]%MOD,cnt+=P[k]+1;
		Ans^=power(2,res%MOD+MOD,mod);
	}
	printf("%lld\n",Ans);
	return 0;
}
```

---


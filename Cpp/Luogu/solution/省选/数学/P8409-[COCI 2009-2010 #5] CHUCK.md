# [COCI 2009/2010 #5] CHUCK

## 题目描述

给你一个 $R$ 行 $C$ 列的矩阵 $a$，$|a_{i,j}| \le 10^4$。请使用若干次下述操作（次数尽量少），使得矩阵中 $\sum_i \sum_j a_{i,j}$ 尽可能大。



| 操作 | 示例 |  |
| :---: | :---: | :---: |
| `rotR i k` 将第 $i$ 行的元素循环右移 $k$ 位 | $\left(\begin{array}{ccc}1 & 2 & 3 \\ 4 & 5 & 6 \\ 7 & 8 & 9 \\ 10 & 11 & 12\end{array}\right)$ | $\xrightarrow{\operatorname{rotR} 3\ 1}\left(\begin{array}{ccc}1 & 2 & 3 \\ 4 & 5 & 6 \\ 9 & 7 & 8 \\ 10 & 11 & 12\end{array}\right)$ |
| `rotS j k` 将第 $j$ 列的元素循环下移 $k$ 位 | $\left(\begin{array}{ccc}1 & 2 & 3 \\ 4 & 5 & 6 \\ 7 & 8 & 9 \\ 10 & 11 & 12\end{array}\right)$ | $\xrightarrow{\text { rotS } 3\ 2}\left(\begin{array}{ccc}1 & 2 & 9 \\ 4 & 5 & 12 \\ 7 & 8 & 3 \\ 10 & 11 & 6\end{array}\right)$ |
| `negR i` 将第 $i$ 行的元素全部乘以 -1 。 该操作当且仅当该行任何一个元素均未乘以 -1 时有效 | $\left(\begin{array}{ccc}1 & 2 & 3 \\ 4 & 5 & 6 \\ 7 & 8 & 9 \\ 10 & 11 & 12\end{array}\right)$ | $\xrightarrow{\text { negR } 2}\left(\begin{array}{ccc}1 & 2 & 3 \\ -4 & -5 & -6 \\ 7 & 8 & 9 \\ 10 & 11 & 12\end{array}\right)$ |
| `negS j` 将第 $j$ 列的元素全部乘以 -1。 该操作当且仅当该列任何一个元素均未乘以 -1 时有效 | $\left(\begin{array}{ccc}1 & 2 & 3 \\ 0 & 0 & 0 \\ 7 & 8 & 9 \\ 10 & 11 & 12\end{array}\right)$ | $\xrightarrow{\text { negS } 1}\left(\begin{array}{ccc}-1 & 2 & 3 \\ 0 & 0 & 0 \\ -7 & 8 & 9 \\ -10 & 11 & 12\end{array}\right)$ |

## 说明/提示

$1 \le R,C \le 100$，$|A_{i,j}|s \le 10^4$

#### 评分标准
若你求了个错误的最大和，或是执行的操作中有无效的，该测试点不得分，否则：

若 $t \le 5 \cdot RC$，你将得到该点的所有分数；

若 $5\cdot RC<T<10^5$，你将得到该点 $50\%$ 的分数；

若 $t > 10^5$，你将得不到该点的任何分数。

本题分值按 COCI 原题设置，满分 $130$。

## 样例 #1

### 输入

```
3 4
1 -2 5 200
-8 0 -4 -10
11 4 0 100```

### 输出

```
345 2
rotS 2 1
negR 2```

## 样例 #2

### 输入

```
3 3
8 -2 7
1 0 -3
-4 -8 3```

### 输出

```
34 4
rotR 1 1
rotS 3 1
negR 2
negR 3```

# 题解

## 作者：_acat_ (赞：5)

## 思路

首先要注意的是，利用行、列旋转可以放置任意元素。

对于给定的行或列。例如，让序列 $s= \{p_1,p_2,\dots,p_r\}$ 的 $r$ 个元素，我们想放在第一列。对于第 $i$ 个元素，我们可以：

- 如果 $p_i$ 已经在第一列，我们把它放出来，将行旋转 $1$。

- 旋转包含 $p_i$ 的列，使其在第 $i$ 行。

- 旋转包含 $p_i$ 的行，使其位于第 $1$ 列。

使用这个算法，我们可以将任意选择的 $r$ 元素放在第一列，任意选择的 $s$ 元素放在第一行。现在可以对第一行、列中的所有元素求反。如果我们重复这个过程，我们可以选择矩阵中任意的 $a \times r+b \times s \le r \times s$ 个元素并对它们求反。

因为这不总是可能的，我们需要选择这样的 $a$ 和 $b$，从而找到最小的可能的解决方案。对数组中的元素进行排序并使用动态规划可以很容易地得到最佳的 $a$ 和 $b$。

注意，对于每个元素，我们最多使用 $3$ 次旋转和 $2$ 次否定，这确保操作的次数小于 $5 \times r \times s$。

时间复杂度 $O((\max \{r,s\})^4)$。

## AC Code
```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <vector>
#include <string>
#include <algorithm>

#define Row first
#define Col second

using namespace std;
vector< string > rez;
vector< pair< int, int > > koord;

int R, S, mat[ 105 ][ 105 ], niz[ 10005 ];
int recon[ 20005 ], moguce[ 20005 ] = { 1 };
int sumuk[ 20005 ] = { 0 }, negativnih = 0;
int por[ 10005 ], tmp[ 105 ], cnt = 0;
char tmpbuff[ 105 ], ozn[ 105 ][ 105 ];


void rotaterow( int row, int K ) {
	for( int i = 0; i < S; ++i )
		tmp[ ( i + K ) % S ] = mat[ row ][ i ];
	for( int i = 0; i < S; ++i )
		mat[ row ][ i ] = tmp[ i ];
	for( int i = 0; i < ( int )koord.size(); ++i )
		if( koord[ i ].Row == row )
			koord[ i ].Col = ( koord[ i ].Col + K ) % S;
	
	sprintf( tmpbuff, "rotR %d %d", row + 1, K );
	rez.push_back( string( tmpbuff ) );
}

void rotatecol( int col, int K ) {
	for( int i = 0; i < R; ++i )
		tmp[ ( i + K ) % R ] = mat[ i ][ col ];
	for( int i = 0; i < R; ++i )
		mat[ i ][ col ] = tmp[ i ];
	for( int i = 0; i < ( int )koord.size(); ++i )
		if( koord[ i ].Col == col )
			koord[ i ].Row = ( koord[ i ].Row + K ) % R;
	
	sprintf( tmpbuff, "rotS %d %d", col + 1, K );
	rez.push_back( string( tmpbuff ) );
}

void changerow( int row ) {
	for( int i = 0; i < S; ++i )
		mat[ row ][ i ] = -mat[ row ][ i ];
	
	sprintf( tmpbuff, "negR %d", row + 1 );
	rez.push_back( string( tmpbuff ) );
}

void changecol( int col ) {
	for( int i = 0; i < R; ++i )
		mat[ i ][ col ] = -mat[ i ][ col ];
	
	sprintf( tmpbuff, "negS %d", col + 1 );
	rez.push_back( string( tmpbuff ) );
}

int suma( int a, int b ) {
	if( a > b ) return( 0 );
	return( sumuk[ b ] - ( a == 0 ? 0 : sumuk[ a-1 ] ) );
}

int evalpod( int X ) {
	return( suma( X, R * S - 1 ) - suma( 0, X - 1 ) );
}

pair< int, int > pronadji( int X ) {
	for( int i = 0; i < R; ++i )
		for( int j = 0; j < S; ++j )
			if( !ozn[ i ][ j ]  &&  mat[ i ][ j ] == X ) {
				ozn[ i ][ j ] = 1;
				return make_pair( i, j );
			}
	
	return make_pair( -1, -1 );
}

void sredi_stupac( void ) {
	int len = ( int )koord.size();
	for( int i = 0; i < len; ++i ) {
		int razl = i - koord[ i ].Row;
		if( razl < 0 ) razl += R;
		
		if( koord[ i ].Col == 0 ) rotaterow( koord[ i ].Row, 1 );
		if( koord[ i ].Row != i ) rotatecol( koord[ i ].Col, razl );
		rotaterow( koord[ i ].Row, S - koord[ i ].Col );
	}
}

void sredi_redak( void ) {
	int len = ( int )koord.size();
	for( int i = 0; i < len; ++i ) {
		int razl = i - koord[ i ].Col;
		if( razl < 0 ) razl += S;
		
		if( koord[ i ].Row == 0 ) rotatecol( koord[ i ].Col, 1 );
		if( koord[ i ].Col != i ) rotaterow( koord[ i ].Row, razl );
		rotatecol( koord[ i ].Col, R - koord[ i ].Row );
	}
}

int main( void ) {
	scanf( "%d %d", &R, &S );
	for( int i = 0; i < R; ++i )
		for( int j = 0; j < S; ++j ) {
			scanf( "%d", &mat[ i ][ j ] );
			niz[ S * i + j ] = mat[ i ][ j ];
		}
	
	sort( niz, niz + R * S );
	for( int i = 0; i < R * S; ++i ) {
		negativnih += ( niz[ i ] < 0 );
		sumuk[ i ] = ( i > 0 ? sumuk[ i-1 ] : 0 ) + niz[ i ];
		
		if( !moguce[ i ] ) continue;
		moguce[ i + R ] = 1;
		moguce[ i + S ] = 1;
		recon[ i + R ] = i;
		recon[ i + S ] = i;
	}
	
	int X, A = -1, B = -1;
	for( int i = 0; i <= R * S; ++i ) {
		if( !moguce[ i ] ) continue;
		if( i <= negativnih ) A = i;
		if( i >= negativnih && B == -1 )
			B = i;
	}
	
	if( A == -1 ) X = B; else if( B == -1 ) X = A;
	else X = ( evalpod( A ) > evalpod( B ) ? A : B );
	
	int prez = evalpod( X );
	while( X != 0 ) {
		por[ cnt++ ] = X;
		X = recon[ X ];
	}
	
	por[ cnt++ ] = 0;
	reverse( por, por + cnt );
	
	for( int i = 0; i < cnt-1; ++i ) {
		memset( ozn, 0, sizeof( ozn ) );
		koord.clear();
		
		for( int j = por[ i ]; j < por[ i + 1 ]; ++j )
			koord.push_back( pronadji( niz[ j ] ) );
		
		if( por[ i + 1 ] - por[ i ] == R ) {
			sredi_stupac();
			changecol( 0 );
		} else {
			sredi_redak();
			changerow( 0 );
		}
	}
	
	printf( "%d %d\n", prez, ( int )rez.size() );
	for( int i = 0; i < ( int )rez.size(); ++i )
		printf( "%s\n", rez[ i ].c_str() );
	
	return( 0 );
}
```

---

## 作者：Makab (赞：0)

## 题意

云云。

## 题解

考虑将一些元素取相反数（取反），使得总贡献增大。

### 如何确定哪些元素取反？

先将矩阵拍到区间上（就是一行行接起来），再将所有元素升序排序。

总是一整行或一整列同时取反，于是，问题转变为：使用若干长为 $R$ 或 $C$ 的区间不重不漏地覆盖大区间的前缀，将覆盖部分取反，求最大总贡献。

跑一趟 DP，算出合法的右端点。

注意力惊人：产生最大总贡献的端点，一定是负数部分最后一个（如果存在），或正数部分第一个（如果存在）。~~证明显然。~~

### 如何较少次操作完成取反？

题目所给定的操作可以将任意合法元素移动到任意合法位置。

不妨将这些元素都移动到第 $1$ 行或第 $1$ 列，然后进行一次取反。

假如需移至第 $1$ 行，每一轮取反，待操作的元素序列为 $\{ mdf_{1 \sim cntMdf} \}$，要将第 $i$ 个元素移动到第 $1$ 行第 $i$ 列。

那么，每个元素最劣经过如下操作：

1. 从第 $1$ 行移出（若已经位于第 $1$ 行）；
2. 移动到对应列；
3. 移动回第 $1$ 行；
4. 后续至多 $2$ 次取反；

那么，总操作数 $\le 5 \cdot RC$。

## 代码

~~为什么这么像 std 捏？俺真是手搓的~~

注意，俺实现时下标是从 $0$ 开始滴。

```c++
#include <bits/stdc++.h>

namespace SLV {
#define dep(i, st, ed) for (int i = (st), _##i = (ed); i < _##i; ++i)
#define eb emplace_back
#define fi first
#define se second
#define gc() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 19, stdin), p1 == p2) ? EOF : *(p1++))
using namespace std;
using pii = pair<int, int>;
namespace IO { char buf[1 << 19], *p1 = buf, *p2 = buf; template<typename T> void read(T &x) { x = 0; char c = gc(); bool f = false; while (!isdigit(c)) f = (c == '-'), c = gc(); while (isdigit(c)) x = (x << 1) + (x << 3) + (c ^ 48), c = gc(); if (f) x = -x; } template<typename T, typename ...Nxt> void read(T &x, Nxt &...pre) { read(x), read(pre...); } } using namespace IO;

constexpr int N = 110;

/*
mmp[]:  将 mat[] 拍到区间上
sum[]:  mmp[] 的前缀和
pre[]:  记录 DP 转移
mdf[]:  取反操作的左端点
*/
int n, m, mat[N][N], mmp[N * N], sum[N * N], tmp[N], ansSum;
int cntNeg, pre[N * N], mdf[N * N], cntMdf;
bitset<N> vis[N];
vector<pii> coor;
vector<string> ansOpt;
char tns[42];

int qSum(int l, int r) { return l <= r ? (sum[r] - (l ? sum[l - 1] : 0)) : 0; }

// [0, x) 取相反数后的矩阵和
int evaluate(int x) { return qSum(x, n * m - 1) - qSum(0, x - 1); }

pii find(int x) {
    dep(i, 0, n) dep(j, 0, m) if (!vis[i][j] && mat[i][j] == x)
        return vis[i][j] = true, make_pair(i, j);
    return {-1, -1};
}

void rotRow(int row, int k) {
    dep(j, 0, m) tmp[(j + k) % m] = mat[row][j];
    dep(j, 0, m) mat[row][j] = tmp[j];
    for (pii &p: coor) if (p.fi == row) (p.se += k) %= m;
    sprintf(tns, "rotR %d %d", row + 1, k);
    ansOpt.eb(tns);
}

void rotCol(int col, int k) {
    dep(i, 0, n) tmp[(i + k) % n] = mat[i][col];
    dep(i, 0, n) mat[i][col] = tmp[i];
    for (pii &p: coor) if (p.se == col) (p.fi += k) %= n;
    sprintf(tns, "rotS %d %d", col + 1, k);
    ansOpt.eb(tns);
}

void negRow(int row) {
    dep(j, 0, m) mat[row][j] = -mat[row][j];
    sprintf(tns, "negR %d", row + 1);
    ansOpt.eb(tns);
}

void negCol(int col) {
    dep(i, 0, n) mat[i][col] = -mat[i][col];
    sprintf(tns, "negS %d", col + 1);
    ansOpt.eb(tns);
}

void angRow() { // 将要取反的元素移到第一行
    dep(i, 0, coor.size()) {
        int dif = i - coor[i].se;
        if (dif < 0) dif += m;
        if (!coor[i].fi) rotCol(coor[i].se, 1); // 从第一行移出
        if (dif) rotRow(coor[i].fi, dif);       // 移动到对应列
        rotCol(coor[i].se, n - coor[i].fi);     // 移动回第一行
    }
}

void angCol() { // 大致同上
    dep(i, 0, coor.size()) {
        int dif = i - coor[i].fi;
        if (dif < 0) dif += n;
        if (!coor[i].se) rotRow(coor[i].fi, 1);
        if (dif) rotCol(coor[i].se, dif);
        rotRow(coor[i].fi, m - coor[i].se);
    }
}

int main() {
    read(n, m);
    dep(i, 0, n) dep(j, 0, m) read(mat[i][j]), mmp[m * i + j] = mat[i][j];

    sort(mmp, mmp + n * m);
    memset(pre, -1, sizeof(pre));
    pre[0] = 0;
    dep(i, 0, n * m) {
        cntNeg += (mmp[i] < 0);
        sum[i] = (i ? sum[i - 1] : 0) + mmp[i];
        if (!~pre[i]) continue;
        pre[i + n] = pre[i + m] = i;
    }

    int x, a = -1, b = -1;
    dep(i, 0, n * m) {
        if (!~pre[i]) continue;
        if (i <= cntNeg) a = i;
        if (i >= cntNeg && b == -1) b = i;
    }
    if (a == -1) x = b;
    else if (b == -1) x = a;
    else x = (evaluate(a) > evaluate(b) ? a : b);

    ansSum = evaluate(x);
    while (x) mdf[++cntMdf] = x, x = pre[x];
    mdf[++cntMdf] = 0;
    reverse(mdf + 1, mdf + 1 + cntMdf);

    dep(i, 1, cntMdf) {
        memset(vis, 0, sizeof(vis));
        coor.clear();
        dep(j, mdf[i], mdf[i + 1]) coor.eb(find(mmp[j]));
        if (mdf[i + 1] - mdf[i] == n)
            angCol(), negCol(0);    // 列取反
        else
            angRow(), negRow(0);    // 行取反
    }

    printf("%d %d\n", ansSum, ansOpt.size());
    for (const auto &i: ansOpt) puts(i.c_str());
    return 0;
}
} // namespace SLV

int main() { return SLV::main(); }
```

---


# 『STA - R3』大豆

## 题目背景

大豆 (Soy / Soybean) 非常有前途。

![](https://cdn.luogu.com.cn/upload/image_hosting/60aceba1.png)

## 题目描述

对于一个序列 $\{a\}$，定义其大豆化 (Soybeanization) 序列 $\{b\}$ 由如下操作得到：
1. 初始 $\{b\}$ 和 $\{a\}$ 相等。
2. $n$ 从小到大遍历整个正整数集，对于每个 $n$，进行操作：
   - $i$ 从小到大遍历整个不小于 2 的正整数集，对于每个 $i$，操作 $b_n\gets b_n-b_{\lfloor\frac ni\rfloor}$。
   - 如果 $i>n$，结束过程。

进而，定义一个序列的 $k$-大豆化序列为进行 $k$ 次大豆化操作后得到的序列。

现在给你一个整数序列 $\{t_n\}$，将 $\{t\}$ 复制无穷遍得到序列 $\{a\}$，求 $\{a\}$ 的 $k$-大豆化序列的第 $m$ 项。

序列下标从 1 开始。答案可能很大，对 $23068673$（一个质数）取模。

## 说明/提示

### 样例解释
**样例 1 解释**

按如下流程构造序列 $\{b\}$：
- $b_1=a_1=1$。
- $b_2=a_2-b_{\lfloor\frac 22\rfloor}=a_2-b_1=1$。 
- $b_3=a_3-b_{\lfloor\frac 32\rfloor}-b_{\lfloor\frac 33\rfloor}=a_3-b_1-b_1=-1$。

从而，答案为 $b_3=-1\equiv 23068672\pmod{23068673}$。

**样例 2 解释**

第一次大豆化后的序列前 5 项：$2,\,-1,\,-2,\,-1,\ -4$。

第二次大豆化后的序列前 5 项：$2,\,-3,\,-6,\,-2,\,-7$。

所以答案为 $-7\equiv 23068666\pmod{23068673}$。
### 数据范围
$$
\newcommand{\arraystretch}{1.5}
\begin{array}{c|c|c|c}\hline\hline
\textbf{Subtask} & \bm{m}\le & \textbf{分值} & \textbf{特殊性质} \\\hline
\textsf{1} & 10^6 & 10 & \\\hline
\textsf{2} & 10^9 & 20 & \\\hline
\textsf{3} & 10^{10} & 20 & k=1  \\\hline
\textsf{4} & 10^{10} & 50 & \\\hline\hline
\end{array}
$$
对于全部数据，$1\le n\le 10^4$，$1\le m\le 10^{10}$，$k\in\{1,2,3\}$，$0\le a_i\le 10^9$。

## 样例 #1

### 输入

```
2 3 1
1 2```

### 输出

```
23068672```

## 样例 #2

### 输入

```
3 5 2
2 1 2```

### 输出

```
23068666```

## 样例 #3

### 输入

```
5 1000000000 1
1 5 10 3 2```

### 输出

```
68769
```

## 样例 #4

### 输入

```
5 1000000000 3
1 5 10 3 2```

### 输出

```
5430204```

# 题解

## 作者：XeCtera (赞：14)

题目传送门：[P9511 『STA - R3』大豆](https://www.luogu.com.cn/problem/P9511)

## 0. 前言

给出一种时间复杂度 $O\left(\dfrac{km^{3/4}}{\log m}\right)$，空间复杂度 $O(\sqrt m)$ 的做法。

常数较小且不难实现。

## 1. 记号约定

记 $\displaystyle {\rm S}f(n)=\sum_{i=1}^nf(i)$。

记 $x/y=\lfloor\frac xy\rfloor$，且运算优先级低于乘法，即 $x/yz$ 表示 $x/(yz)$。

## 2. 题解 (Part 1)

不难发现 $\{a\}$ 的大豆化序列 $\{b\}$ 满足

$$b_m=a_m-\sum_{d=2}^mb_{m/d}$$

注意到这与杜教筛使用的式子具有相似性。

具体地，设 $I(n)=1$ 为常函数，$g*I=f$，则

$${\rm S}g(m)={\rm S}f(m)-\sum_{d=2}^m{\rm S}g(m/d)$$

当此式成立时，显然也能反推出 $g*I=f$。

本题中只需令 $f,g$ 分别为 $\{a\},\{b\}$ 的差分，那么有 $g=f*\mu$。

所求即为 ${\rm S}(f*\mu^k)(m)$ 的值。（$\mu^k$ 表示 $k$ 个 $\mu$ 卷积的结果）

使用足够厉害的数论科技即可解决。

下面开始介绍科技。

## 3. Dirichlet 双曲线法

这里可以把它当成整除分块的替代品。

相比于整除分块，它在常数等方面有一定优势。

考虑求如下式子的值：

$${\rm S}(f*g)(n)=\sum_{i=1}^nf(i){\rm S}g(n/i)=\sum_{ij\le n}f(i)g(j)$$

（假设 $f,g,{\rm S}f,{\rm S}g$ 的点值都可以 $O(1)$ 得到）

设阈值 $x,y$ 满足 $xy=n$。

我们对 $i\le x$ 的部分和 $j\le y$ 的部分分别求和，再减去公共部分。

$$\sum_{i\le x}f(i){\rm S}g(n/i)+\sum_{j\le y}g(j){\rm S}f(n/j)-{\rm S}f(x){\rm S}g(y)$$

可以 $O(x+y)$ 完成计算。

通常取 $x=y=\sqrt n$ 得最优复杂度 $O(\sqrt n)$。

## 4. 块筛卷积

首先我们有一条重要性质：$x/y/z=x/yz$。

根据这条性质，再结合整除分块的一些分析可知：

在求 ${\rm S}f(n)$ 时，我们往往只需用到 ${\rm S}f(1)\sim {\rm S}f(\lfloor\sqrt n\rfloor),{\rm S}f(n/\lfloor\sqrt n\rfloor)\sim{\rm S}f(n/1)$ 的值。

称之为 $f$（在 $n$ 处）的**块筛**。

**块筛卷积**：假设有一个狄利克雷卷积式 $f*g=h$，其中 $f,g$ 的块筛已知，试求 $h$ 的块筛。

可以直接用 Dirichlet 双曲线法，对块筛的每个位置暴力求解。

$${\rm S}h(n)=\sum_{i=1}^{\sqrt n}f(i){\rm S}g(n/i)+\sum_{i=1}^{\sqrt n}g(i){\rm S}f(n/i)-{\rm S}f(\sqrt n){\rm S}g(\sqrt n)$$

（开方运算默认下取整，下同）

复杂度是 $\displaystyle O\left(\sum_{i=1}^{\sqrt n}\sqrt i+\sum_{i=1}^{\sqrt n}\sqrt{n/i}\right)=O(n^{3/4})$。

可以进一步优化，但这里暂且不提。

## 5. 杜教筛

假设有一个狄利克雷卷积式 $f*g=h$，其中 $g,h$ 的块筛已知，试求 $f$ 的块筛。

事实上前面的做法仍然适用，只需要对式子做个移项：

$${\rm S}f(n)={\rm S}h(n)-\sum_{i=1}^{\sqrt n}f(i){\rm S}g(n/i)-\sum_{i=2}^{\sqrt n}g(i){\rm S}f(n/i)+{\rm S}f(\sqrt n){\rm S}g(\sqrt n)$$

递推即可，复杂度同样为 $O(n^{3/4})$。（同样可以优化，但先不提）

这种方法通常被称为**杜教筛**。

若使用普通数组存储块筛，并像上面这样递推求解，这种实现或许可以称为 dp 式杜教筛。

目前广为流传的则是递归 + `map / unordered_map` 记忆化存储的写法。我暂且称之为记搜式杜教筛。

事实上 dp 式实现的常数要小很多，并且复杂度也更加直观。

不明白为什么大家都用记搜式。难过。

## 6. 整除运算的优化

底层卡常技巧。

预处理 $1\sim\sqrt m$ 的倒数，将整除改为浮点乘。

若实现得当，可以保证代码中所有整除运算的除数都在 $1\sim\sqrt m$ 以内。将会有良好的优化效果。

注意事项：

用 `(1+1e-15)/x` 这样的方式来计算 `x` 的倒数，而非 `1./x` 。后者的精度损失可能导致出错。

## 7. 题解 (Part 2)

回到本题，我们要求 ${\rm S}(f*\mu^k)(m)$ 的值，其中 $f$ 的块筛已知。

朴素做法是对 $f$ 做 $k$ 次杜教筛。

事实上，dp 式杜教筛 + 整除优化的实现已经能够以 $O(km^{3/4})$ 的复杂度通过。

~~并且应该可以吊打 std。~~

但这还不够令人满意。下面给出一种更优秀的做法。

注意到 $\mu$ 是积性函数，比 $f$ 具有更好的性质。

考虑先求 $\mu^k$ 的块筛，然后容易 $O(\sqrt m)$ 得到 ${\rm S}(f*\mu^k)(m)$。

对于积性函数 $f$，记 $f_j(n)=f(n)[{\rm minp}(n)>p_j]$。

其中 ${\rm minp}(n)$ 是 $n$ 的最小质因子（钦定 ${\rm minp}(1)=+\infty$），$p_j$ 是第 $j$ 个质数。

取阈值 $K$ 满足 $p_{K+1}$ 略大于 $\sqrt[4]m$，那么 $f_K$ 有优秀的性质：

$f_K(1)\sim f_K(\sqrt m)$ 中，只有 $1$ 和大于 $\sqrt[4]m$ 的质数处的值非零。

回忆 Dirichlet 双曲线法的式子：

$${\rm S}h(n)=\sum_{i=1}^{\sqrt n}f(i){\rm S}g(n/i)+\sum_{i=1}^{\sqrt n}g(i){\rm S}f(n/i)-{\rm S}f(\sqrt n){\rm S}g(\sqrt n)$$

发现复杂度可优化至 $O(\pi(\sqrt n))=O\left(\dfrac{\sqrt n}{\ln n}\right)$。

我们用 $\mu_K*I_K=\varepsilon$ 杜教筛求出 $\mu_K$ 的块筛，再做块筛卷积得到 $\mu^k_K$ 的块筛。

这部分的复杂度为 $O\left(\dfrac{km^{3/4}}{\ln m}\right)$。

最后的问题是，如何得到 $I_K$ 的块筛，又如何将 $\mu_K^k$ 的块筛转化为 $\mu^k$ 的块筛？

事实上，采取 min_25 筛第一部分的 dp 即可实现。

给出 $I$ 的转移方程作为示例：

$$\begin{aligned}
{\rm S}I_0(n)&={\rm S}I(n)\\&=n\\
{\rm S}I_j(n)&={\rm S}I_{j-1}(n)-I(p_j){\rm S}I_{j-1}(n/p_j)\\&={\rm S}I_{j-1}(n)-{\rm S}I_{j-1}(n/p_j)\quad(j>0)
\end{aligned}$$

$\mu^k$ 同理，读者可以尝试自行推出。

这部分的复杂度为 $O(k\sqrt m\cdot\pi(\sqrt[4]m))=O\left(\dfrac{km^{3/4}}{\ln m}\right)$。

因此时间复杂度为 $O\left(\dfrac{km^{3/4}}{\ln m}\right)$。空间复杂度为 $O(\sqrt m)$。

## 8. 代码实现

变量名有些不太一致，注释以上文为准。

```cpp
#include<bits/stdc++.h>
#define rep(i,l,r) for (int i=l; i<=r; ++i)
#define rrep(i,r,l) for (int i=r; i>=l; --i)
#define cpy(a,b) memcpy(a,b,sizeof a)
using namespace std;
typedef long long i64;

const int N=1e5+8,M=1e4+8,P=23068673;
const double I=1+1e-14;
i64 n; int T,K,sq,cnt,k,a[M],pri[M];
bitset<N/2>v; double inv[N];
int s1[N],s2[N],s3[N]; i64 S1[N],S2[N],S3[N];
struct Node { int f,g; }pos[M];

void init(int n) {
    int sq=sqrt(n),n2=(n>>1);
    for (int i=3; i<=sq; i+=2) if (!v[i>>1]) // 埃氏筛
        for (int j=(i*i>>1); j<=n2; j+=i) v[j]=1;
    pri[cnt=1]=2;
    rep(i,1,n2) if (!v[i]) pri[++cnt]=(i<<1|1);
    pri[cnt+1]=n+1;
    rep(i,1,n) inv[i]=I/i;
}
inline i64 dv(i64 x,int y) { return x*inv[y]; } // 整除优化

void calc1() {
    k=upper_bound(pri+1,pri+cnt+1,sqrt(sq))-pri;
    assert(pri[k+1]*pri[k+1]>sq);
    rep(i,1,sq) s1[i]=i;
    rep(i,1,sq) S1[i]=dv(n,i);
    rep(j,1,k) {
        int p=pri[j],t=dv(sq,p); i64 tn=dv(n,p);
        rep(i,1,t) S1[i]-=S1[i*p];
        rep(i,t+1,sq) S1[i]-=s1[dv(tn,i)];
        for (int i2=t,i=sq; i2; --i2)
            for (int lim=i2*p; i>=lim; --i) s1[i]-=s1[i2];
    } // 得到 I_K 的块筛
    rep(i,1,sq) s2[i]=2-s1[i];
    rrep(i,sq,1) {
        i64 n2=dv(n,i),s=0;
        int B=sqrt(n2),t,j=k+1;
        for ( ; (t=i*pri[j])<=sq; ++j)
            s+=S2[t]-S1[t];
        for ( ; pri[j]<=B; ++j)
            t=dv(n2,pri[j]),
            s+=s2[t]-s1[t];
        S2[i]=1-S1[i]-s+(i64)s1[B]*s2[B];
    } // 得到 μ_K 的块筛
    cpy(s1,s2),cpy(S1,S2);
}

void mul(int *sf,i64 *Sf,int *sg,i64 *Sg,int *sh,i64 *Sh) { // f*g=h 块筛卷积
    rep(j,k+1,cnt) {
        int p=pri[j];
        pos[j]={sf[p]-sf[p-1],sg[p]-sg[p-1]};
    }
    rep(i,1,sq) {
        i64 n2=dv(n,i),s=0;
        int B=sqrt(n2),t,j=k+1;
        for ( ; (t=i*pri[j])<=sq; ++j)
            s+=pos[j].f*Sg[t]+pos[j].g*Sf[t];
        for ( ; pri[j]<=B; ++j)
            t=dv(n2,pri[j]),
            s+=(i64)pos[j].f*sg[t]+(i64)pos[j].g*sf[t];
        Sh[i]=Sf[i]+Sg[i]+s-(i64)sf[B]*sg[B];
    }
    rrep(i,sq,1) sh[i]=sf[i]+sg[i]-1;
}

void solve() {
    rep(j,1,k) {
        int p=pri[j],t=dv(sq,p); i64 tn=dv(n,p);
        rep(tmp,1,K) {
            rep(i,1,t) S1[i]-=S1[i*p];
            rep(i,t+1,sq) S1[i]-=s1[dv(tn,i)];
            for (int i2=t,i=sq; i2; --i2)
                for (int lim=i2*p; i>=lim; --i) s1[i]-=s1[i2];
        }
    } // 得到 μ^k 的块筛
    rep(i,1,sq) s2[i]=a[(i-1)%T+1];
    rep(i,1,sq) S2[i]=a[(dv(n,i)-1)%T+1]; // 得到 f 的块筛
    i64 ans=0;
    rep(i,1,sq) ans=(ans+i64(s1[i]-s1[i-1])*S2[i])%P;
    rep(i,1,sq) ans=(ans+i64(s2[i]-s2[i-1])*S1[i])%P;
    ans=(ans-(i64)s1[sq]*s2[sq])%P;
    printf("%lld\n",ans<0?ans+P:ans);
}

int main() {
    scanf("%d%lld%d",&T,&n,&K);
    rep(i,1,T) scanf("%d",a+i),a[i]%=P;
    init(sq=sqrt(n));
    calc1();
    if (K>1) mul(s1,S1,s1,S1,s2,S2);
    if (K>2) mul(s1,S1,s2,S2,s3,S3);
    if (K==2) cpy(s1,s2),cpy(S1,S2);
    if (K==3) cpy(s1,s3),cpy(S1,S3);
    solve();
    return 0;
}
```

---

## 作者：jijidawang (赞：9)

感谢 [Rolling_star](/user/510649), [SoyTony](/user/321177) 合作 .

首先考虑 $\{a\}$ 经过一次大豆化之后得到的序列 $\{b\}$ 满足递推：
$$b_m=a_m-\sum_{d=2}^mb_{\lfloor\frac md\rfloor}$$
那么暴力递归记忆化即可做到 $O(k\cdot m^{3/4})$ .

原递推式可以改写为：
$$b_m=a_m+b_m-\sum_{d=1}^mb_{\lfloor\frac md\rfloor}$$
那么就有 $\displaystyle \sum_{d=1}^mb_{\lfloor\frac md\rfloor}=a_m$，施[整除 Möbius 反演](https://www.cnblogs.com/CDOI-24374/p/17437278.html)，即得：
$$b_m=\sum_{i=1}^m\mu(i)a_{\lfloor\frac mi\rfloor}$$
进而考察 $\{b\}$ 的差分：
$$\begin{aligned}\begin{aligned}b_m-b_{m-1}&=\sum_{i=1}^m\mu(i)(a_{\lfloor\frac mi\rfloor}-a_{\lfloor\frac{m-1}i\rfloor})\\&=\sum_{i\mid m}\mu(i)(a_{\frac mi}-a_{\frac{m}i-1})\end{aligned}\end{aligned}$$
其中 $a_0=0$ .

那么 Dirichlet 前缀和即可求出 $b$ 的差分，前缀和后即为 $b$，从而可以做到小范围预处理，若 $\le B$ 的部分预处理，结合杜教筛的时间复杂度分析，复杂度就是 $O\left(B\log\log B+\dfrac{m}{\sqrt B}\right)$，取 $B=m^{2/3}$ 那么就是 $O(km^{2/3}\log\log m)$，可以通过本题 .

---

## 作者：_jimmywang_ (赞：5)

厉害数论题。

做法来自官方题解，我尽量展开一点。

首先暴力直接做是杜教筛不带优化复杂度 $O(km^{\frac{3}{4}})$。

杜教筛的优化是线性预处理了前 $O(m^{\frac{2}{3}})$ 是复杂度降到 $O(km^{\frac{2}{3}})$。

考虑借鉴这个东西，即目标是**在（近）线性的时间内预处理出前 $O(m^{\frac{2}{3}})$ 项的答案。**

对于单次操作，有递推式：

$$b_m=a_m-\sum_{i=2}^mb_{\lfloor\frac{m}{i}\rfloor}$$

补一项 $b_m$ 可得 $b_m=a_m+b_m-\sum_{i=1}^mb_{\lfloor\frac{m}{i}\rfloor}$，即有：

$$a_m=\sum_{i=1}^mb_{\lfloor\frac{m}{i}\rfloor}$$

有[莫比乌斯反演扩展（整除莫比乌斯反演）](https://oi-wiki.org/math/number-theory/mobius/#%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%E6%89%A9%E5%B1%95)：

$$f(n)=\sum_{i=1}^nh(i)g(\lfloor\dfrac{n}{i}\rfloor)⟺g(n)=\sum_{i=1}^n\mu(i)h(i)f(\lfloor\dfrac{n}{i}\rfloor)$$

取 $h=I,f(n)=a_n,g(n)=b_n$，可得：

$$a_m=\sum_{i=1}^mb_{\lfloor\frac{m}{i}\rfloor}⟺b_m=\sum_{i=1}^m\mu(i)a_{\lfloor\frac{m}{i}\rfloor}$$

此时理论上已经可以整除分块 + 杜教筛前缀和了（直接做的话）。但是 $k$ 比较大的时候我们不能快速得到上一次的 $b$。

回想我们的目标，现在需要快速得到前缀的 $b$。

$b$ 的式子长得很像整除分块，这里有一个小 trick。

考虑 $b$ 的差分，有：

$$b_m-b_{m-1}=\sum_{i=1}^m\mu(i)(a_{\lfloor\frac{m}{i}\rfloor}-a_{\lfloor\frac{m-1}{i}\rfloor})$$

众所周知，$\lfloor\dfrac{m}{i}\rfloor$ 和 $\lfloor\dfrac{m-1}{i}\rfloor$ 很多时候是一样的。只有 $i|m$ 的时候，有 $\lfloor\dfrac{m-1}{i}\rfloor=\lfloor\dfrac{m}{i}\rfloor-1$。因此我们可以将差分改写成：

$$b_m-b_{m-1}=\sum_{i|m}\mu(i)(a_{\frac{m}{i}}-a_{\frac{m}{i}-1})$$

一眼调和级数暴力，可是不够优。

官方题解甩了一句 $\text{Dirichlet}$ 前缀和就跑了。~~你倒是详细说说。~~

如果没有这个 $\mu$ 的话是就是 [P5495 Dirichlet 前缀和](https://www.luogu.com.cn/problem/P5495)，最典的板子。

但是有个 $\mu$。

记 $c_i=a_i-a_{i-1}$，那么式子改写为 $b_m-b_{m-1}=\sum_{i|m}\mu(i)c_{\frac{m}{i}}=\sum_{i|m}\mu(\frac{m}{i})c_{i}$。

考虑上面那个板子的做法，我们其实是在枚举质数，然后对每个质数的指数做完全背包。而考虑 $\mu$ 的性质，只有在**没有平方因子时 $\mu\not =0$**。

完全背包可以放任意个物品，即每个质数可以放任意个。而带了 $\mu$ 后非零位置的分解中，每个质数**最多一个。**

这提示我们将完全背包替换为 01 背包。实现上将板子的第二层循环由正序换为倒序即可。同时 $\mu$ 在多一个质因子时正负性改变，因此要将加法改为减法。

大致实现：

```cpp
for(int i=1;i<=cnt/*质数个数*/;i++)
	for(int j=5000000/pr[i];j>=1;j--)
		b[j*pr[i]]=(b[j*pr[i]]-b[j]+mod)%mod;
```

得到差分后前缀和一下就好了。

然后我们就能 $O(B\log\log B)$ 预处理前 $B$ 项。（$B$ 取 $m^{\frac{2}{3}}$）

然后把暴力记忆化一下直接做就行了。

因为有前 $B$ 项，做两边或三遍时前缀预处理仍然没有问题。

---

当然还有一个问题，上面那个东西换成其他积性函数我就不会了。比如求 $f(n)=\sum_{i=1}^n\varphi(i)g(\lfloor\dfrac{n}{i}\rfloor)$。


有无人教教我/kel。

---

## 作者：A_zjzj (赞：3)

妙妙题。

### 题意

给定 $F_0(x)=a_{(x-1)\bmod n +1}$。

$$
F_k(n)=F_{k-1}(n)-\sum\limits_{i=2}^n F_k(\lfloor\frac{n}{i}\rfloor)
$$

求 $F_k(m)$。

$1\le n\le 10^4,1\le m\le 10^{10},1\le k\le 3$。

### 思路

直接数论分块求解的复杂度是 $O(m^{\frac{3}{4}}k)$，难以通过。

如果像杜教筛那样做到 $O(m^{\frac{2}{3}}k)$ 的话就能通过。

关键在于如何快速求解 $F_k(n),n\le m^{\frac{2}{3}}$。

考虑杜教筛的逆过程，$F$ 相当于杜教筛的前缀和函数，那么复原出原函数：

$$
\begin{aligned}
	G_k(n)&=F_k(n)-F_k(n-1)\\

	&=G_{k-1}(n)-\sum\limits_{i=2}^n F_k(\lfloor\frac{n}{i}\rfloor)-F_k(\lfloor\frac{n-1}{i}\rfloor)\\

	&=G_{k-1}(n)-\sum\limits_{i>1,i|n} F_k(\frac{n}{i})-F_k(\frac{n}{i}-1)\\

	&=G_{k-1}(n)-\sum\limits_{i>1,i|n} G_k(\frac{n}{i})\\
\end{aligned}
$$

这样，就可以 $O(kB\ln B)$ 处理出 $F_k(1\sim B)$。

于是，复杂度为 $O(kB\ln B+\frac{km}{\sqrt{B}})$，取 $B=10^6$ 即可通过。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
const int N=1e4+10,M=1e6+10,mod=23068673;
int his[4][M],n,k,a[N];
ll m;
int HIS[3][N];
int cnt;
ll num[N];
unordered_map<ll,int>trs;
int calc(int k,ll n){
	if(!k)return a[(n-1)%(::n)+1];
	if(n<M)return his[k][n];
	int id=trs[n];
	if(~HIS[k-1][id])return HIS[k-1][id];
	ll ans=calc(k-1,n);
	for(ll l=2,r;l<=n;l=r+1){
		r=n/(n/l);
		ans=ans-(r-l+1)*calc(k,n/l)%mod;
	}
	return HIS[k-1][id]=ans%mod;
}
void init(int m){
	for(int i=1;i<=m;i++)his[0][i]=a[(i-1)%n+1];
	for(int i=m;i>=1;i--)(his[0][i]+=mod-his[0][i-1])%=mod;
	for(int t=1;t<=k;t++){
		for(int i=1;i<=m;i++)his[t][i]=his[t-1][i];
		for(int i=1;i<=m;i++){
			for(int j=i+i;j<=m;j+=i){
				(his[t][j]+=mod-his[t][i])%=mod;
			}
		}
	}
	for(int t=1;t<=k;t++){
		for(int i=1;i<=m;i++){
			(his[t][i]+=his[t][i-1])%=mod;
		}
	}
}
int main(){
	freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	memset(HIS,-1,sizeof HIS);
	scanf("%d%lld%d",&n,&m,&k);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	init(M-1);
	for(int i=1;m/i>=M;i++)num[++cnt]=m/i;
	reverse(num+1,num+1+cnt);
	for(int i=1;i<=cnt;i++)trs[num[i]]=i;
	cout<<(calc(k,m)+mod)%mod;
	return 0;
}
```

---

## 作者：honglan0301 (赞：2)

这里是直接数论分块的非正解做法。它常数好像比较优秀，跑得还挺快。

## 题目分析

基于数论分块容易发现只有 $O(\sqrt m)$ 个位置有用，于是尝试直接对这些位置暴力处理。由于这些位置分别为 $1,2,\dots,\sqrt m,\displaystyle\frac{m}{\sqrt m},\displaystyle\frac{m}{\sqrt m-1},\dots,m$，故总时间复杂度在 $O(\sum\limits_{i=1}^{\sqrt m}(i^\frac{1}{4}+m^\frac{1}{2}i^{-\frac{1}{2}}))=O(km^\frac{3}{4})$ 这个级别，极限数据算下来大概 $5\times 10^8$，一般的写法不好通过。

于是有以下三点常数优化：

1. 离散化找编号比较慢。但我们注意到有用的位置比较特殊，记位置总数为 $cnt$，则可以用以下方式建立对应关系（$i$ 与 $i'$ 分别为原下标与新下标）：

$$i'=\left \{
\begin{aligned}
& i\ \ \ (i^2\leq m)\\
& cnt+1-\frac{m}{i}\ \ \ (i^2\geq m)\\
\end{aligned}
\right.
$$

2. 除法和取模非常慢。所以尽可能不用除法或者预处理除法，尽可能用减法代替取模。具体的，我们对于每个下标 $i$，都采用从 $1$ 到 $\sqrt i$ 枚举 $j$ 的方式来找转移的位置（换个方式写整除分块），并先预处理出 $\lfloor \frac{i}{j}\rfloor\ (j\leq \sqrt i)$ 以减少除法操作。

3. 当 $k$ 较大的时候要重复进行三轮操作，每轮都需要重新预处理 $\lfloor \frac{i}{j}\rfloor$（否则空间会炸），很慢。但我们其实可以只枚举一遍下标，对于每个下标分别计算并存储其在 $1,2,3$ 轮操作后的值，进一步减少多余操作。

具体实现可以看代码。

之后最大点就跑得飞快，只需要 $1.2$ 秒，暴力出奇迹了属于是。大概唯一的优势就是空间复杂度极低。

------------

## 代码

```cpp
/*
  author: honglan0301
 */
#include <iostream>
#include <cstdio>
#include <cctype>
#include <cmath>
using namespace std;

// 快读快写

#define int long long
const int mod=23068673;

int n,m,sq,a[10005],b[200005][4],num[200005],cs[200005],cntn,k,ans;

void dfs(int x)//找有用的下标，跟dfs没关系，只是我一开始写丑了。
{
	for(int l=1,r;l<=x;l=r+1)
	{
		r=x/(x/l); num[++cntn]=r;
	}
}
int gt(int x)//原下标 对应到 新下标
{
	if(x<=sq) return x; else return cntn+1-(m/x);
}
void solve()
{
	b[1][2]+=b[1][1],(b[1][2]>=mod)&&(b[1][2]-=mod);
	b[1][3]+=b[1][2],(b[1][3]>=mod)&&(b[1][3]-=mod);
	for(int i=2;i<=cntn;i++)
	{
		int j=num[i];
		for(int p=1;(p-1)*(p-1)<=j;p++) cs[p]=j/p;//预处理除法
		for(int p=1;p*p<=j;p++)
		{
			if(p!=1&&cs[p]!=p)
			{
				int kk=gt(cs[p]);
				b[i][1]-=b[kk][1],(b[i][1]<0)&&(b[i][1]+=mod);//把取模换成减法
				b[i][2]-=b[kk][2],(b[i][2]<0)&&(b[i][2]+=mod);
				b[i][3]-=b[kk][3],(b[i][3]<0)&&(b[i][3]+=mod);
			}
			int kk=(cs[p]-cs[p+1]);
			b[i][1]-=kk*b[p][1]%mod,(b[i][1]<0)&&(b[i][1]+=mod);
			b[i][2]-=kk*b[p][2]%mod,(b[i][2]<0)&&(b[i][2]+=mod);
			b[i][3]-=kk*b[p][3]%mod,(b[i][3]<0)&&(b[i][3]+=mod);
		}
		b[i][2]+=b[i][1],(b[i][2]>=mod)&&(b[i][2]-=mod);
		b[i][3]+=b[i][2],(b[i][3]>=mod)&&(b[i][3]-=mod);//这里写法问题，把 b[i] 存成了前缀和，正常存也可以。
	}
}

signed main()//
{
	cin>>n>>m>>k; sq=sqrt(m); dfs(m); for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=cntn;i++) b[i][1]=b[i][2]=b[i][3]=a[(num[i]-1)%n+1]%mod;
	solve(); 
	if(k==1) cout<<b[cntn][k]<<endl;
	else cout<<(b[cntn][k]-b[cntn][k-1]+mod)%mod<<endl;
}
```


---


# BZOJ4361 isn

## 题目背景

题目来自原 BZOJ，我们承认题面及原数据的版权均属于原 BZOJ 或将题目授权给 BZOJ 使用的出题人。如果您是版权所有者且认为我们侵犯了您的权益，可联系我们。

## 题目描述

给出一个长度为 $n$ 的序列 $a_1,a_2,\dots a_n$。如果序列 $a$ 不是非降的，你必须从中删去一个数。

这一操作将被不断执行，直到 $A$ 非降为止。求有多少种不同的操作方案。操作方案不同当且仅当删除的顺序或次数不同。答案对 $10^9+7$ 取模。

## 说明/提示

对于 $100\%$ 的数据，$1\leq n\leq 2\times 10^3$，$0\leq a_i \leq 2^{31}-1$。

## 样例 #1

### 输入

```
4
1 7 5 3```

### 输出

```
18```

# 题解

## 作者：WDY_Hodur (赞：9)

# 题目描述
给你一个序列 $a$，要求不断删去其中一个元素，使其变为一个不降序列，求方案数。

# 题解
## 思路
首先，我们考虑在整个序列转化为一个不降序列的过程中，$a$ 序列没有出现过不降的情况，合法方案数为总方案数减去非法方案数。

设转化为长度为 $i$ 的不降序列共有 $g_i$ 种，那么 $g_i\times (n-i)!$ 即为总方案数。不合法的就是从长为 $i+1$ 的不降序列转移而来的情况，$g_{i+1}\times (n-i-1)!\times (i+1)$ 即为不合法方案数。则合法方案数即为两者之差。

接下来问题就是如何求 $g_i$ 了。

考虑用 dp 来求。设 $dp_{i,j}$ 表示的是前 $i$ 个数中，选择了 $j$ 个且包括 $a_i$ 的方案数。则转移方程为 $dp_{i,j}=\sum_{k=1}^{i} dp_{k,j-1}\times (a_k\le a_i)$。则 $g_i=\sum_{j=1}^{n}dp_{j,i}$。

但是在求 $g$ 的过程中，复杂度为 $O(n^3)$ 显然过不了。我们关注到，转移到 $dp_{i,j}$ 的所有 $k$ 都满足 $k\le i$ 且 $a_k\le a_i$，那么我们可以用树状数组维护所有满足这两个条件的 $dp$ 值的和。复杂度 $O(n^2\log n)$。

## Code:

```cpp
#include<bits/stdc++.h>
#define N 2005
#define lowbit(x) (x&(-x))
#define mod 1000000007
#define int long long
using namespace std;
int n,a[N],g[N],f[N][N],num[N],ans;
int t[N];
void add(int x,int d){
	while(x<=n){
		t[x]+=d;
		t[x]%=mod;
		x+=lowbit(x);
	}
}
int query(int x){
	int ans=0;
	while(x>0){
		ans+=t[x];
		ans%=mod;
		x-=lowbit(x); 
	}
	return ans;
}
signed main(){
	cin>>n;
	t[0]=0;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		t[i]=a[i];
	}
	sort(t,t+n+1);
	for(int i=0;i<=n;i++){
		a[i]=lower_bound(t,t+1+n,a[i])-t+1;//找a[i]排序后的位置，即找k的个数。
	}
	f[0][0]=1;
	for(int j=1;j<=n;j++){
		memset(t,0,sizeof(t));
		for(int i=1;i<=n;i++){
			add(a[i-1],f[i-1][j-1]);
			f[i][j]=query(a[i]);//相当于以 log 的复杂度求出所有 f[k][j-1] 的和。
			g[j]=(g[j]+f[i][j])%mod;
		}
	}
	num[0]=1;
	for(int i=1;i<=n;i++){
		num[i]=num[i-1]*i%mod;//阶乘
	}
	for(int i=1;i<=n;i++){
		ans=(ans+g[i]*num[n-i]%mod)%mod;
		ans=((ans-g[i+1]*num[n-i-1]%mod*(i+1)%mod)%mod+mod)%mod;//这里一定要反复取模，以防负数
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：2huk (赞：7)

很好很好的算答案方式。

> 小 D 有一个长度为 $n$ 的序列。如果序列不是非降的，他会选择一个元素删去，直到序列变成非降的，这时停止操作。求操作序列种类数，对 $10^9+7$ 取模。
>
> 两个操作序列不同，当且仅当它们长度不同或者某一次操作删除的元素位置不同。
>
> $n \le 2000,1 \le a_i \le 10^9$。

这个问题的难点在于，如果此时序列已经非降了那么此时必须停止。我们考虑如果没有这个限制的问题：

> 小 D 有一个长度为 $n$ 的序列。如果序列不是非降的，他会选择一个元素删去，直到序列变成非降的，这时**可以选择停止操作，也可以不停止**。求操作序列种类数，对 $10^9+7$ 取模。

我们考虑原序列的任意一个上升子序列对答案的影响，即有多少种将其它元素删除的方式，使得最终整个序列只剩这个子序列。

令这个上升子序列长度为 $i$。显然这个的答案是 $(n - i)!$，即其它元素可以任意选择顺序删除。

暴力枚举这个上升子序列仍然是指数复杂度。考虑 DP。

设 $f(i, j)$ 表示有多少上升子序列以 $i$ 结尾且长度为 $j$。转移显然：
$$
f(i, j) = \left\{\begin{matrix}1 &, j=1 \\ \sum_{k=1}^{i-1}[a_k \le a_i]f(k,j-1) &,j \ne 1 \end{matrix}\right.
$$
可以用树状数组轻易优化至 $\mathcal O(n^2 \log n)$。

考虑统计答案。令 $g(i) = \sum_{j=1}^i f(j, i)$，即有多少个上升子序列的长度为 $i$。那么答案为：
$$
\sum_{i=1}^n g(i) \cdot (n - i)!
$$
至此我们用 $\mathcal O(n^2 \log n)$ 的复杂度通过了弱化版。

我们考虑原问题比弱化版的答案少在了哪些地方。即考虑一个上升子序列什么时候产生的贡献变小。 

对于一个长度为 $i$ 的上升子序列 $s$，如果存在 $j$ 个**长度为 $i + 1$ 的上升子序列完全包含它**，那么当小 D 通过若干次删除操作得到这 $j$ 个子序列后，游戏应当在此时停止。不难发现只有这种情况会导致 $s$ 不产生贡献。

所以答案比弱化版少了：
$$
\begin{matrix}
\sum_{s,j} j \times (n-(i+1))! \\
\tiny s\text{ is an increasing subsequence of length }i\text{ of }a.\\
\tiny {\text{There are }j\text{ increasing subsequences of length }i+1\text{ that completely contain }s.}
\end{matrix}
$$
暴力枚举 $s$ 还是指数复杂度。

显然每个 $s$ 对应的 $j$ 的和为 $g(i + 1) \cdot (i + 1)$。这是因为一个长度 $i + 1$ 的上升子序列中含有 $i + 1$ 个这样的 $s$。

所以答案为：
$$
\sum_{i=1}^n\left[ g(i) \cdot (n-i)! - g(i+1)\cdot (i+1)\cdot(n-i-1)! \right]
$$

```cpp
#include <bits/stdc++.h>

using namespace std;

#define int long long

const int N = 2024, P = 1e9 + 7;

int n, a[N], b[N];
int f[N][N];		// 以 i 结尾的长度为 j 的子序列数量
int g[N], nums;

struct Tree {
	int tr[N];
	
	void modify(int x, int d) {
		for (int i = x; i <= nums; i += i & -i)
			tr[i] = (tr[i] + d) % P;
	}
	
	int query(int x) {
		int res = 0;
		for (int i = x; i; i -= i & -i)
			res = (res + tr[i]) % P;
		return res;
	}
}T[N];

int fac[N];

signed main() {
	fac[0] = 1;
	for (int i = 1; i < N; ++ i ) fac[i] = 1ll * fac[i - 1] * i % P;
	
	cin >> n;
	
	for (int i = 1; i <= n; ++ i ) {
		cin >> a[i];
		b[i] = a[i];
	}
	
	sort(b + 1, b + n + 1);
	nums = unique(b + 1, b + n + 1) - b - 1;
	
	for (int i = 1; i <= n; ++ i ) {
		a[i] = lower_bound(b + 1, b + nums + 1, a[i]) - b;
	}
	
	for (int i = 1; i <= n; ++ i ) {
		f[i][1] = 1;
		for (int j = 2; j <= i; ++ j ) {
			f[i][j] = T[j - 1].query(a[i]);
		}
		
		for (int j = 1; j <= i; ++ j ) {
			T[j].modify(a[i], f[i][j]);
		}
	}
	
	for (int i = 1; i <= n; ++ i )
		for (int j = 1; j <= i; ++ j )
			g[j] = (g[j] + 1ll * fac[n - j] * f[i][j] % P) % P;
	
	int res = 0;
	for (int i = 1; i <= n; ++ i )
		res = ((res + g[i] - g[i + 1] * (i + 1) % P) % P + P) % P;
	cout << res;
	
	return 0;
}
```

---

## 作者：wosile (赞：6)

发现直接统计有多少操作序列在最后一步刚好删成非降不好统计，于是考虑删成非降但不是刚好删成非降的操作序列有多少，再从所有删成非降的操作序列里面减掉。

显然，如果一个操作序列删成了非降但不是在最后一步才删成了非降，那么他倒数第二步就已经删成了非降。同时，每一个已经删成非降的操作序列（无论是否刚好删成非降）再删一步都是一个一定不刚好删成非降的操作序列。也就是说，所有删成非降的操作序列多删一步和所有不在答案里的删成非降的操作序列一一对应。

考虑设 $f_{i,j}$ 表示以 $a_i$ 为结尾的非降的长度为 $j$ 的子序列个数，则删剩这样的子序列有 $f_{i,j}\times (n-j)!$ 种方案，对应的多删一步的子序列有 $j\times f_{i,j}\times (n-j)!$ 种方案，相减即可。

$f_{i,j}$ 的转移可以通过树状数组实现，注意离散化。时间复杂度 $O(n^2 \log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[2005];
#define mod 1000000007
int f[2005][2005],c[2005][2005];
int dc[2005];
// fenwick tree
void add(int x,int y,int val){
    for(;y<=n;y+=y&-y){
        c[x][y]=(c[x][y]+val)%mod;
    }
}
int qry(int x,int y){
    int ans=0;
    for(;y;y-=y&-y){
        ans=(ans+c[x][y])%mod;
    }
    return ans;
}
int ft[2005];
typedef long long ll;
int main(){
    scanf("%d",&n);
    ft[0]=1;
    for(int i=1;i<=n;i++)ft[i]=(ll)ft[i-1]*i%mod;
    for(int i=1;i<=n;i++)scanf("%d",&a[i]);
    for(int i=1;i<=n;i++)dc[i]=a[i];
    sort(dc+1,dc+n+1);
    int len=unique(dc+1,dc+n+1)-dc-1;
    for(int i=1;i<=n;i++)a[i]=lower_bound(dc+1,dc+len+1,a[i])-dc;
    f[0][0]=1;
    for(int i=1;i<=n;i++)for(int j=i;j>=1;j--){
        f[i][j]=qry(j-1,a[i])+(j==1);
        add(j,a[i],f[i][j]);
    }
    int sum=0;
    for(int i=0;i<=n;i++)for(int j=0;j<=i;j++){
        sum=(sum+(ll)f[i][j]*ft[n-j]%mod)%mod;// 总非降方案数
        sum=(sum-(ll)f[i][j]*ft[n-j]%mod*j%mod+mod)%mod;// 多余的非降方案数
    }
    printf("%d\n",sum);
    return 0;
}
```

---

## 作者：Chenyanxi0829 (赞：4)

先离散化，然后用树状数组优化 dp 求出长度为 $[1,n]$ 的非降子序列的个数 $c_i$，那么如果只考虑删完后非降的条件的话答案就是 $\sum_{i=1}^nc_i(n-i)!$，因为其他的数可以以任意顺序删除。

但实际上可能删到一半就已经非降了，所以我们可以倒着计算剩余序列长度为 $i$ 的方案数 $ans_i$，$ans_i$ 一开始要先设成 $c_i(n-i)!$，之后 $ans_i$ 就得减去 $\sum_{j=i+1}^nans_jC_j^i(j-i)!$，因为每个长度大于 $i$ 的方案都可以先选出 $i$ 个元素再以任意顺序删除其余元素来构成一个剩余序列长度为 $i$ 的不合法方案，这样就做完了。

实现细节可以见代码。

## 代码
```cpp
#include <bits/stdc++.h>

using namespace std;
using ll = long long;

const int kMaxN = 2010, mod = int(1e9) + 7;

int n, a[kMaxN], tr[kMaxN][kMaxN], z;
map<int, int> h;
ll c[kMaxN], J[kMaxN], ans, C[kMaxN][kMaxN], sum[kMaxN];

int Q(int o, int x, int ans = 0) {
  for (; x; ans += tr[o][x], ans >= mod && (ans -= mod), x ^= (x & (-x))) {
  }
  return ans;
}

void A(int o, int x, int y) {
  for (; x <= z; tr[o][x] += y, tr[o][x] >= mod && (tr[o][x] -= mod), x += (x & (-x))) {
  }
}

int main() {
  ios::sync_with_stdio(0), cin.tie(0);
  cin >> n, c[0] = J[0] = C[0][0] = 1;
  for (int i = 1; i <= n; i++) {
    cin >> a[i], h[a[i]] = 0;
  }
  for (auto i : h) {
    h[i.first] = ++z;
  }
  for (int i = 1; i <= n; i++) {
    a[i] = h[a[i]], c[i] = c[i - 1] * 2, c[i] >= mod && (c[i] -= mod), J[i] = J[i - 1] * i % mod, C[i][0] = 1;
    for (int j = i; j >= 2; j--) {
      A(j, a[i], Q(j - 1, a[i]));
    }
    A(1, a[i], 1);
    for (int j = 1; j <= i; j++) {
      C[i][j] = C[i - 1][j] + C[i - 1][j - 1], C[i][j] >= mod && (C[i][j] -= mod);
    }
  }
  for (int i = 1; i <= n; i++) {
    sum[i] = J[n - i] * Q(i, z) % mod;
  }
  for (int i = n; i >= 1; i--) {
    ans += sum[i], ans >= mod && (ans -= mod);
    for (int k = 1; k < i; k++) {
      sum[k] = (sum[k] + mod - sum[i] * C[i][k] % mod * J[i - k] % mod) % mod;
    }
  }
  cout << ans;
  return 0;
}
```

---

## 作者：VainSylphid (赞：3)

观察一个长度为 $k$ 的非降的子序列 $S$，删掉 $S$ 以外的所有数有 $(n-k)!$ 种方案，但是其中一些方案在删到只剩 $S$ 之前可能已经是一个非降的子序列了，所以会多算。

考虑容斥，注意到如果在删到只剩 $S$ 之前已经是一个非降的子序列了，那么之后就会一直是一个非降的子序列。因此考虑删到最后一步时是非降的子序列的情况，如果有 $c$ 个长度为 $k+1$ 的非降子序列包含 $S$，那么会多算 $c\times(n-k-1)!$ 种情况。

接下来只需要算贡献，显然一个长度为 $k$ 的非降子序列恰包含 $k$ 个长度为 $k-1$ 的非降子序列，因此贡献为 $f_k\times(1-k)\times (n-k)!$，其中 $f_k$ 表示长为 $k$ 的非降子序列个数。特别地，对于长度为 $1$ 的非降子序列，其贡献为 $n!$。

离散化之后用树状数组优化求 $f_k$ 的过程即可，最终的答案为 $n!-\sum\limits_{i=2}^{n}{f_i\times(i-1)\times(n-i)!}$，时间复杂度 $O(n^2\log n)$，代码很好写。


```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int mod = 1000000007;
struct Bit{
	int d[2005],sz;
	void insert(int x,int v)
	{
		while(x <= sz)
			d[x] = (d[x] + v) % mod,x += (x & (-x));
	}
	int query(int x)
	{
		int ret = 0;
		while(x)
			ret = (ret + d[x]) % mod,x -= (x & (-x));
		return ret;
	}
}t[2005];
int n,a[2005],b[2005],dp[2005];
ll sc[2005];
int fac[2005];
int main()
{
	scanf("%d",&n);
	for(int i = 1;i <= n;i++)
		scanf("%d",&a[i]),b[i] = a[i];
	sort(b + 1,b + 1 + n);
	int m = unique(b + 1,b + 1 + n) - b - 1;
	for(int i = 1;i <= n;i++)
		t[i].sz = m;
	for(int i = 1;i <= n;i++)
		a[i] = lower_bound(b + 1,b + 1 + m,a[i]) - b;
	for(int i = 1;i <= n;i++)
	{
		dp[1] = 1;
		for(int j = i;j > 1;j--)
			dp[j] = t[j - 1].query(a[i]);
		for(int j = 1;j <= i;j++)
			sc[j] = (sc[j] + dp[j]) % mod,t[j].insert(a[i],dp[j]);
	}
	fac[0] = 1;
	for(int i = 1;i <= n;i++)
		fac[i] = (ll)fac[i - 1] * i % mod;
	ll ans = fac[n];
	for(ll i = 1;i <= n;i++)
		ans = (ans - (i - 1) * sc[i] % mod * fac[n - i] % mod + mod) % mod;
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：ln001 (赞：3)

没有紫的难度，建议降蓝。

$a_i$ 的值域很大，为了方便下文的树状数组，需要先离散化。

设 $f_{i,j}$ 表示以 $a_i$ 为结尾，长度为 $j$ 的非降序列个数。

转移有 $f_{i,j} = \sum_{k < i, a_k \le a_i} f_{k, j - 1}$。

发现转移满足 $a_i$ 单调，于是可以开 $n$ 个树状数组，第 $i$ 个树状数组表示长度为 $i$，且结尾元素小于等于某个值的非降序列个数。

设 $g_i$ 表示按照题意构造长度为 $i$ 的非降序列的方案数，有 $g_i = \sum_{j \le n} f_{j,i} \times (n - i)!$，其中 $(n - i)!$ 为需要被删除位置的删除方案。

当不存在**序列合法时不能操作**的要求，答案为 $\sum_{i \le n} g_i$。

容易发现，如果要求**序列合法时不能操作**，那么刚才的式子答案包含了错误情况。现在我们设 $h_i$ 表示长度为 $i$，满足**上文提出的新要求**时的非降序列个数。

我们又发现，当一种操作不满足**上文提出的新要求**时，当且仅当**最后一次操作前**序列已经合法，所以 $h_i = g_i - g_{i + 1} \times (i + 1)$。

最终答案为 $h_i$ 的和。

---

## 作者：_Ad_Astra_ (赞：1)

模拟赛题。场后迅速想出了正解，唉唉。

---

考虑一种操作序列何时才能满足。首先先不考虑删除顺序，那么相当于计数非降子序列数。考虑加上顺序的限制，对于每一个留下来的长度为 $i$ 的子序列，操作序列有 $(n-i)!$ 种。

但是由于题目要求由于在**恰好非降**时停止操作，也就是说删去最后一个数后恰好满足。发现这个东西很难直接维护，因此很自然地想到考虑容斥。

设 $f_i$ 表示长度为 $i$ 的非降子序列数。对于最终长度为 $i$ 的子序列，只需要将在剩余长度为 $i$ 时满足的操作序列数减去剩余长度为 $i+1$ 时满足的操作序列数乘上当前这一次操作可能选的数即可。那么就有
$$ans_i = f_i \times (n-i)! - f_{i+1} \times (n-i-1)! \times (i+1)$$

现在考虑如何计数 $f_i$。这个比较套路，设 $g_{i,j}$ 表示当前考虑了前 $i$ 个数，不降子序列长度为 $j$，同时强制钦定选 $a_i$ 的方案数。考虑 $O(n^3)$ 的朴素 dp，有
$$ g_{i,j} = \sum_{k=0}^{i-1} [a_k \le a_i] g_{k,j-1}$$

其中边界条件为 $g_{0,0}=1$。

发现这是一个很裸的二维偏序形式，因此可以树状数组优化，对于每一维 $j$ 开一个值域树状数组，每次查询 $j-1$ 的树状数组上 $0$ 至 $a_i$ 的和即可。

最后显然
$$f_i=\sum_{j=i}^{n}g_{j,i}$$

时间复杂度为 $O(n^2 \log n)$。

注意离散化，以及 dp 求 $g_{i,j}$ 时 $j$ 要倒着扫，不然可能 $g_{i,j}$ 会从 $g_{i,j-1}$ 转移，相当于重复使用 $a_i$，会挂成 20pts。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define pb push_back
#define fir first
#define sec second
#define chmin(a,b) (a=min(a,b))
#define chmax(a,b) (a=max(a,b))
const int inf=0x3f3f3f3f3f3f3f3f;
const int mod=1e9+7;
int n,a[2010],b[2010],m,c[2010][2010],dp[2010][2010],f[2010],ans; 
int quickpow(int x,int p)
{
	int ans=1;
	while(p)
	{
		if(p&1)(ans*=x)%=mod;
		(x*=x)%=mod;
		p>>=1; 
	}
	return ans;
}
int inv(int x){return quickpow(x,mod-2);}
int fac[2010],ivf[2010];
void init()
{
	fac[0]=1;
	for(int i=1;i<=n;i++)fac[i]=fac[i-1]*i%mod;
	ivf[n]=inv(fac[n]);
	for(int i=n-1;i>=0;i--)ivf[i]=ivf[i+1]*(i+1)%mod;
}
//预处理阶乘 
int lowbit(int x){return x&(-x);}
void update(int x,int y,int v){y++;while(y<=m+1)(c[x][y]+=v)%=mod,y+=lowbit(y);}
int query(int x,int y){int ans=0;y++;while(y)(ans+=c[x][y])%=mod,y-=lowbit(y);return ans;}
signed main()
{
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i],b[i]=a[i];
	sort(b+1,b+n+1);
	m=unique(b+1,b+n+1)-b-1;
	for(int i=1;i<=n;i++)a[i]=lower_bound(b+1,b+m+1,a[i])-b;
	update(0,0,1);
	dp[0][0]=1;
	init();
	for(int i=1;i<=n;i++)
		for(int j=i;j;j--)//注意顺序 
		{
			dp[j][i]=query(j-1,a[i]);
			update(j,a[i],dp[j][i]);
		}
	for(int i=1;i<=n;i++)
		for(int j=i;j<=n;j++) 
			(f[i]+=dp[i][j])%=mod;
	for(int i=1;i<=n;i++)(ans+=f[i]*fac[n-i]%mod-((i==n)?0:f[i+1]*fac[n-i-1]%mod*(i+1)%mod)+mod)%=mod;
	cout<<ans;
	return 0;
}


```

---

## 作者：freoepn (赞：1)

考虑钦定最后剩下的序列后合法的操作序列有多少种，发现操作序列满足条件时当且仅当只剩最后一个数没删时这个数列不是一个不降序列，其余操作顺序可以随便，即若操作序列不合法，它在最后一次操作前是一个长度比钦定序列长度大一的不降序列，尝试把不合法的操作序列减掉，不合法的操作序列数等于操作出一个比钦定序列长度大一的序列的方案数乘上有可能被最后一个删除的数的数量，因为该序列每个数被最后一个删都不合法，可能被最后一个删除的数的数量就是该序列的长度，用树状数组算出每种长度的不降序列有多少个再直接计算即可。


```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int kMaxN = 2005, mod = 1e9 + 7;
int n;
int a[kMaxN], b[kMaxN], c[kMaxN], fac[kMaxN];
int dp[kMaxN][kMaxN];
int sum[kMaxN];
int lowbit(int x) { return x & (-x); }
void updata(int i, int k) {
    while (i <= n) {
        c[i] += k;
        c[i] %= mod;
        i += lowbit(i);
    }
}
int getsum(int i) {
    long long ans = 0;
    while (i) {
        ans += c[i];
        ans %= mod;
        i -= lowbit(i);
    }
    return ans;
}
map<int, int> m;
signed main() {
    cin >> n;
    fac[0] = 1;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        fac[i] = (fac[i - 1] * i) % mod;
        b[i] = a[i];
    }
    sort(b + 1, b + 1 + n);
    for (int i = 1; i <= n; i++) {
        if (m[b[i]] == 0) {
            m[b[i]] = i;
        }
    }
    for (int i = 1; i <= n; i++) {
        a[i] = m[a[i]];
    }
    for (int i = 1; i <= n; i++) {
        dp[1][i] = 1;
        sum[1] = (sum[1] + dp[1][i]) % mod;
    }
    for (int i = 2; i <= n; i++) {
        fill(c, c + 1 + n, 0);
        for (int j = 1; j <= n; j++) {
            dp[i][j] = getsum(a[j]);
            sum[i] = (sum[i] + dp[i][j]) % mod;
            updata(a[j], dp[i - 1][j]);
        }
    }
    int ans = 0;
    for (int i = 1; i <= n; i++) {
        ans += sum[i] * fac[n - i];
        ans %= mod;
        ans -= (sum[i + 1] * fac[n - i - 1]) % mod * (i + 1) % mod;
        ans += mod;
        ans %= mod;
    }
    cout << ans;
    return 0;
}
```

---

## 作者：Corzica (赞：1)

先把不下降子序列用离散化转成上升子序列。

观察一个怎么样的删除顺序可以满足最后剩下一个上升子序列，且中途不会因为已经满足条件而停止。

我们钦定的这个上升子序列可能并没有完全拓展，如果最后一次删除的时候删掉的这个元素可以继续拓展的话，那么我们会直接停止，并不会拓展到我们钦定的这个子序列。

所以我们最后一次删掉的元素不能和这个序列继续拓展，而当存在一个这样的元素时，前面的每一个时刻都不可能成为一个上升子序列。

那么我们就得到了一个结论。当这个上升子序列外的数总个数为 $p$，共有 $q$ 个仍然能和子序列内的拓展时，答案为 $C_{p-1}^q\times q! \times (p-q)!$。拆组合数，化为 $\frac{(p-1)!}{q!(p-q-1)!}\times q! \times (p-q)!=(p-1)!\times (p-q)$。

对于 $(p-1)! \times p=p!$ 我们可以使用树状数组优化 dp 求出每一种长度的上升子序列的个数。而对于后半部分，我们可以先求长度为 $p+1$ 的上升子序列个数，再枚举删除掉的哪一个元素，就得到了 $\sum q$，也就得到答案。

时间复杂度 $O(n^2\log n)$。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int  n, m, a[2005], jie[2005], g[2005][2005], ans, ls[2005];
map<int, int> ma;
const long long mod = 1000000007;
struct SZSZ {
	int t[2005];
	inline int lowbit(int p) {
		return p & -p;
	}
	inline void add(int p, int q) {
		while (p <= n+2) {
			t[p] = (t[p] + q) % mod;
			p += lowbit(p);
		}
	}
	inline int query(int p) {
		int cnt = 0;
		while (p) {
			cnt = (cnt + t[p]) % mod;
			p -= lowbit(p);
		}
		return cnt;
	}
} t[2005];
signed main() {
//	freopen("delete.in", "r", stdin);
//	freopen("delete.out", "w", stdout);
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> n;
	jie[0] = 1;
	for (int i = 1; i <= 2000; i++) {
		jie[i] = jie[i - 1] * 1ll * i % mod;
	}
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		ls[i] = a[i];
	}
	sort(ls + 1, ls + n + 1);
	for (int i = n; i >= 1; i--) ma[ls[i]] = i;
	for (int i = 1; i <= n; i++) {
		a[i] = ma[a[i]]++;
	}
	a[0] = 0;
	g[0][0] = 1;
	t[0].add(1, 1);
	a[n + 1] = n + 1;
	for (int i = 1; i <= n + 1; i++) {
		for (int j = 1; j <= i; j++) {
			g[i][j] = t[j - 1].query(a[i]);
			t[j].add(a[i] + 1, g[i][j]);
		}
	}
	for (int i = 2; i <= n; i++) {
		ans = (ans + jie[n - i] * 1ll * (((n - i + 1) * 1ll * g[n + 1][i] % mod - i * 1ll * g[n + 1][i + 1] % mod + mod) % mod) % mod) % mod;
	}
	if (g[n + 1][n + 1] != 0) ans = (ans + 1) % mod;
	cout << ans;
}

---

## 作者：dAniel_lele (赞：1)

考虑最后一次操作，即使 $a$ 非降前最后一步。此时删除唯一一个下降的即能使得 $a$ 非降。考虑统计有多少最后有且仅有一个下降位置的，选出长度为 $i$ 的序列的方案数。

正难则反，考虑计算出最后长度为 $i$ 的非降序列 $f_i$，$f_{i-1}\times(n-i+1)-f_i\times i$ 即为最后有且仅有一个下降位置的，选出长度为 $i$ 的序列的方案数。

考虑如何计算 $f_i$，考虑 $dp_{i,j}$ 表示看到 $i$ 位置选出 $j$ 个组成非降子序列的方案数。使用树状数组优化即可。总复杂度 $O(n^2\log n)$，可以通过。

```cpp
#include <bits/stdc++.h>
#define int long long
#define mid ((l+r)>>1)
#define lowbit(i) (i&(-i))
using namespace std;
const int mod=1e9+7;
int lsh[2005],a[2005];
struct bit{
	int f[2005];
	void change(int i,int cg){
		while(i<=2000){
			(f[i]+=cg)%=mod;
			i+=lowbit(i);
		}
	}
	int qry(int i){
		int ans=0;
		while(i){
			(ans+=f[i])%=mod;
			i-=lowbit(i);
		}
		return ans;
	}
}tree[2005];
int fac[2005];
signed main(){
	int n; cin>>n; for(int i=1;i<=n;i++) cin>>a[i],lsh[i]=a[i];
	bool ok=1; for(int i=1;i<n;i++) ok&=(a[i]<=a[i+1]);
	if(ok){
		cout<<1;
		return 0;
	}
	fac[0]=1; for(int i=1;i<=n;i++) fac[i]=fac[i-1]*i%mod;
	sort(lsh+1,lsh+n+1); for(int i=1;i<=n;i++) a[i]=lower_bound(lsh+1,lsh+n+1,a[i])-lsh;
	tree[0].change(1,1);
	for(int i=1;i<=n;i++){
		for(int j=n;j>=1;j--){
			tree[j].change(a[i],tree[j-1].qry(a[i]));
		}
	}
	int ans=0;
	for(int i=1;i<n;i++){
		(ans+=(tree[i].qry(n)*(n-i)%mod+mod-tree[i+1].qry(n)*(i+1)%mod)*fac[n-i-1])%=mod;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：harmis_yz (赞：0)

因为我们一旦删成非降的，就停下来了。所以需要保证在最后时刻序列 $A$ 非降，且上一个时刻 $A$ 不是非降。

考虑容斥，那么我们只需要算出最后时刻是非降的方案数与最后时刻与上一个时刻同时为非降的方案数，就能得到满足条件的方案数了。

对于最后时刻非降，定义状态函数 $f_{i,j}$ 表示以 $i$ 为结尾，选了 $j$ 个数的方案数。那么可以用树状数组维护出答案。则最后一个长度为 $j$ 的非降序列的方案数为：$\sum f_{i,j}\times (n-j)!$。

而对于最后两个时刻都是非降的情况，显然是我们多删了一个数。而这个数一定满足：$A_{p_{i-1}}\le A_{p_i} \le A_{p_{i+1}}$，即删之后不破坏序列 $A$ 的整体形式。所以倒数第 $2$ 个时刻是非降且最后时刻也是非降对于一个长度为 $j$ 的序列的方案数就是：$\sum f_{i,j}\times j \times (n-j)!$。

时间复杂度 $O(n^2\log n)$。

---

## 作者：sad_lin (赞：0)

## [P10592 BZOJ4361 isn](https://www.luogu.com.cn/problem/P10592)

当一个序列删成非降序列的话那操作就要停止，所以我们要求的是最后一步刚好删成非降序列的操作数，但是这样做太复杂了，我们先不考虑停止操作，让他一直删下去。

这时我们就要知道长度为 $i$ 的非降序列的数量然后才能计算答案，我们有 $f_{i,j}$ 为第 $i$ 个数长度为 $j$ 的非降序列的长度，我们可以用树状数组优化，比如我们要求以 $3$ 结尾的长度为 $2$ 的非降子序列的数量，我们就用树状数组查询**小于** $3$ 的长度 $1$ 的非降子序列的数量，这样计算的时间复杂度为 $O(n^2\log n)$。

接下我我们要统计长度为 $i$ 的非降序列的总数量，我们有：

$$
g_i=\sum_{i=1}^{n}\sum_{j=i}^{n}f_{j,i}
$$

现在知道数量如何计算方案数，对于删成一个长度为 $i$ 的非降序列的方案数为 $(n-i)!$，即**删除数的全排列**。总的方案数为：

$$
ans=\sum_{i=1}^n g_i\times (n-i)!
$$

接下来加上停止操作，我们要排除不合法的方案，当我们删除最后一个数使得非降序列长度为 $i$，我们是从 $i+1$ 转移过来，但是如果 $i+1$ 删掉最后一个数使得非降序列长度为 $i+1$ 的话就会**停止操作**使得不会再向下传递使我们造成贡献，所以我们要容斥掉那一部分，总计算为：

$$
ans=\sum_{i=1}^n g_i\times (n-i)!-g_{i+1}\times (n-i-1)!\times (i+1)
$$

乘 $i+1$ 是因为我们有 $i+1$ 个数可以作长度为 $i$ 的非降序列的最后一个删的数。

```cpp
#include <bits/stdc++.h>
#define int long long
#define re register 
const int N=2e5+10;
const int mod=1e9+7;
using namespace std;

int n;
int a[N];
int b[N];

int f[3005][3005];
int t[3005][3005];
int fac[2005];

int g[N];

int lb(int x){
	return x&-x;
}

void change(int x,int k,int z){
	x++;
	while(x<=2000){
		(t[x][z]+=k)%=mod;
		x+=lb(x);
	}
}

int query(int x,int k){
	x++;
	int ans=0;
	while(x){
		ans+=t[x][k];
		x-=lb(x);
		ans%=mod;
	}
	return ans;
}

void init(){
	fac[0]=1;
	for(int i=1;i<=2000;i++){
		fac[i]=fac[i-1]*i;
		fac[i]%=mod;
	}
	sort(b+1,b+n+1);
	int len=unique(b+1,b+n+1)-b-1;
	for(re int i=1;i<=n;i++){
		a[i]=lower_bound(b+1,b+len+1,a[i])-b;
	}
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr); 
	
	cin>>n;
	
	for(re int i=1;i<=n;i++){
		cin>>a[i];
		b[i]=a[i];
	}
	
	init();	
	
	change(0,1,0);
	f[0][0]=1;
	
	for(int i=1;i<=n;i++){
		for(int j=i;j;j--){
			f[i][j]=query(a[i],j-1);
			change(a[i],f[i][j],j);
		}
	}
	int ans=0;
	
	for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++){
			(g[i]+=f[j][i])%=mod;
		}
	}
	
	for(int i=1;i<=n;i++){
		int x=g[i]*fac[n-i]%mod;
		int y=g[i+1]*fac[n-i-1]%mod*(i+1)%mod;
		if(i==n){
			y=0;
		}
		ans=(ans+x-y+mod)%mod;	
	}
	
	cout<<ans;	
	return 0;
}
```

---

## 作者：Add_Catalyst (赞：0)

# 「BZOJ 4361」isn 题解

------

## 知识点

DP，组合数学，容斥，树状数组。

## 分析

首先，我们不考虑「非降时停止」这个限制，那么则可用 DP 求解。

设 $f_{i,j}$ 表示 $1\sim i$ 中，组成一个长度为 $j$ 的非降子序列的方案数。初态和转移式：
$$
\forall i,f_{i,1} = 1\\
f_{i,j} = \sum_{k<i} f_{k,j-1}[a_{k} \le a_i] \\
$$
这个问题答案就是：
$$
\sum_{j=1}^n j\cdot (n-j)!\sum_{i=j}^{n} f_{i,j}
$$
然后我们来考虑「非降时停止」：其实只要把每个不合法的从原本的减掉即可，而这些不合法的我们都可以从已有的 DP 状态中推出来。

我们简化一下，设 $g_i$ 表示所有组成长度为 $i$ 的非降子序列的方案数，即：
$$
g_i = \sum_{j=i}^n f_{j,i} \\
$$
那么考虑「非降时停止」的组成长度为 $i$ 的非降子序列方案数就是：$(n-i)!\cdot g_i - (i+1)(n-i-1)!\cdot g_{i+1}$。所以累加即可。

DP 暴力可做到 $O(n^3)$，离散化后用树状数组即可优化到 $O(n^2\log_2{n})$。

## 代码

```cpp
//#define Plus_Cat ""
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f
#define ll long long
#define RCL(a,b,c,d) memset(a,b,sizeof(c)*(d))
#define FOR(i,a,b) for(int i(a);i<=(int)(b);++i)
#define DOR(i,a,b) for(int i(a);i>=(int)(b);--i)
#define tomax(a,...) ((a)=max({(a),__VA_ARGS__}))
#define tomin(a,...) ((a)=min({(a),__VA_ARGS__}))
#define EDGE(g,i,x,y) for(int i=(g).h[(x)],y=(g)[(i)].v;~i;y=(g)[(i=(g)[i].nxt)>0?i:0].v)
#define main Main();signed main(){ios::sync_with_stdio(0);cin.tie(0),cout.tie(0);return Main();}signed Main
using namespace std;
constexpr int N(2e3+10);

namespace Modular {
#define Mod 1000000007
	int fac[N];
    //Modular
	void Init(const int n=N-5) {
		FOR(i,fac[0]=1,n)fac[i]=mul(fac[i-1],i);
	}
} using namespace Modular;

int n,ans;
int a[N],b[N],f[N];

class BIT {
private:
	int c[N];
public:
	void Init() { RCL(c+1,0,int,b[0]); }
#define lowbit(i) ((i)&-(i))
	void Plus(int x,int d) { if(x>0)for(; x<=b[0]; x+=lowbit(x))toadd(c[x],d); }
#undef lowbit
	int Sum(int x) {
		int ans(0);
		if(x>0)for(; x; x&=x-1)toadd(ans,c[x]);
		return ans;
	}
} bit;

signed main() {
#ifdef Plus_Cat
	freopen(Plus_Cat ".in","r",stdin),freopen(Plus_Cat ".out","w",stdout);
#endif
	cin>>n,Init(n),ans=mul(n,fac[n-1]);
	FOR(i,1,n)cin>>a[i],b[i]=a[i],f[i]=1;
	sort(b+1,b+n+1),b[0]=unique(b+1,b+n+1)-b-1;
	FOR(i,1,n)a[i]=lower_bound(b+1,b+b[0]+1,a[i])-b;
	FOR(len,2,n) {
		bit.Init(),bit.Plus(a[len-1],f[len-1]),f[len-1]=0;
		int sum(0);
		FOR(i,len,n) {
			int tmp(bit.Sum(a[i]));
			bit.Plus(a[i],f[i]),toadd(sum,f[i]=tmp);
		}
		toadd(ans,Mod-mul(sum,len-1,fac[n-len]));
	}
	cout<<ans<<endl;
	return 0;
}
```

------

---


# [KOI 2021 Round 2] 最长公共括号子串

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

给定两个仅由左括号 `(` 和右括号 `)` 组成的字符串 $A$ 和 $B$。

我们定义 $S(A, B)$ 为以下所有字符串的集合：

- 是 $A$ 的子串；
- 是 $B$ 的子串；
- 并且是一个**合法括号序列**；
- 集合中元素互不相同。

请你判断 $S(A, B)$ 是否为空集。如果不是，请计算出 $S(A, B)$ 中最长字符串的长度。

你需要解决一个输入中给出的 $T$ 个测试用例。

### 合法括号序列的定义

合法括号序列的定义如下：

- 单独的一对括号 `()` 是合法括号序列；
- 若 $X$ 是合法括号序列，则用括号将其包围后的 $(X)$ 也是合法括号序列；
- 若 $X$ 和 $Y$ 都是合法括号序列，则其连接后的 $XY$ 也是合法括号序列；
- 所有合法括号序列都只能通过以上三种规则构造。

例如：`((()(())))` 和 `(())()()` 是合法括号序列，而 `(()` 和 `)((()()` 都不是合法括号序列。

### 子串的定义

给定一个长度为 $l$ 的字符串 $s$，以及满足 $1 \leq i \leq j \leq l$ 的两个整数 $i$ 和 $j$，则 $s[i..j]$ 表示从第 $i$ 个字符开始到第 $j$ 个字符为止的连续子串。

例如若 $s = \texttt{()(()()}$，则 $s[3..5] = \texttt{(()}$，$s[4..7] = \texttt{()()}$，因此 `(()` 和 `()()` 都是该字符串的子串。但 `)()(` 不是其子串。

## 说明/提示

**约束条件**

设 $\sum |A|$ 表示输入中所有测试用例的字符串 $A$ 的总长度之和，$\sum |B|$ 定义相同。

- $1 \leq T \leq 500\,000$
- 每个字符串 $A$ 和 $B$ 均由 `'('` 和 `')'` 构成，长度均不少于 1
- $\sum |A| \leq 500\,000$
- $\sum |B| \leq 500\,000$

**子任务**

1. （5 分）$\sum |A| \leq 100$，$\sum |B| \leq 100$
2. （13 分）$\sum |A| \leq 1\,000$，$\sum |B| \leq 1\,000$
3. （23 分）$\sum |A| \leq 10\,000$，$\sum |B| \leq 10\,000$
4. （17 分）所有测试用例中均满足 $A = B$
5. （42 分）无额外约束条件

## 样例 #1

### 输入

```
3
()((())) (()((())))()
))(()(((( )())))))(
())) )))))(())```

### 输出

```
8
2
2```

# 题解

## 作者：hanmm81 (赞：2)

# 题面

给定两个括号字符串 $A$ 和 $B$，求满足同时是两个字符串的子串的合法括号串的最长长度，**有多组数据，且 $T$ 能到 $5 \times 10^5$**。

# 思路

设 $pre_i = \left\{
\begin{aligned}
pre_{i-1}+1 \quad A_i = \texttt{"("}\\
pre_{i-1}-1 \quad A_i = \texttt{")"}
\end{aligned}
\right.$

那么如果 $A$ 中子串 $[l,r]$ 满足 $\min\limits^{r}_{i=l} pre_i \ge pre_{l-1}$ 且 $pre_r = pre_{l-1}$ 那么则为合法括号串。

用 ST 表维护 $pre$ 即可做到 $\mathcal{O}(1)$ 判断合法。

于是我们可以枚举子串在 $A$ 中的左端点 $l$，然后二分求出在 $[l,l+blcp_l-1]$ 范围内最后一次 $\min\limits^{r}_{i=l} pre_i \ge pre_{l-1}$ 的地方（$blcp_i$ 为满足同时是两个字符串的子串且在 $A$ 中左端点在 $i$ 的字符串的最大长度），然后又二分求出最后一处满足 $pre_r = pre_{l-1}$ 的地方并记录，然后就做完了。

目前问题在于如何求出 $blcp$，考虑后缀数组。

非常套路地将 $A$ 和 $B$ 连在一起中间随便插个除括号外的字符然后跑后缀数组，然后分别从左往右从右往左扫一遍 $sa$，$blcp_x$ 即为 $\min\limits^{x}_{i=a+1} height_i$（$a$ 在 $sa$ 中离 $x$ 最近的在 $B$ 中的后缀），代码大概长这样（$n$ 为连起来后的长度，$m$ 为 $A$ 的长度）：

```c++
for (int i = 1,j = 0,minn = 0x3f3f3f3f;i <= n;i++){
	if (sa[i] > m+1) minn = 0x3f3f3f3f,j = 1;
	else{
		minn = min(minn,height[i]);
		if (j && sa[i] <= m) blcp[sa[i]] = minn;
	}
}
for (int i = n,j = 0,minn = 0x3f3f3f3f;i;i--){
	if (sa[i] > m+1) minn = 0x3f3f3f3f,j = 1;
	else{
		minn = min(minn,height[i+1]);
		if (j && sa[i] <= m) blcp[sa[i]] = max(blcp[sa[i]],minn);
	}
}
```

于是这道题就做完了

# 注意事项

~~都是多测而且测试用例还这么多惹出来的~~

+ 清空数组不要使用 memset，因为 $T$ 能达到 $5 \times 10^5$。

+ 由于后缀数组的常数问题，$n$ 如果很小暴力会比倍增求快，所以需要在 $n$ 小于一定值时暴力，不然会超时，根据测试 $n \le 800$ 时暴力比较优~~虽然还是最慢解~~

# Code

```c++
#include <bits/stdc++.h>
#define maxn 2000005 
using namespace std;
string str,a,b;
int sa[maxn],rnk[maxn],lg[maxn],st[maxn][25],lastSa[maxn],pre[maxn],lastRnk[maxn],height[maxn],blcp[maxn],n,m,cn,cnt[maxn],T,id[256];
int l,r,mid,ans,maxx;
void clear(){
	for (int i = 1;i <= n;i++) cnt[i] = 0;//不要使用 memset 
}
void initSABao(){
	for (int i = 1;i <= n;i++) sa[i] = i;
	sort(sa+1,sa+n+1,[&](int a,int b){
		for (int i = a,j = b;i <= n && j <= n;i++,j++){
			if (str[i] > str[j]) return 0;
			else if (str[i] < str[j]) return 1;
		}
		return (int)(n-a+1 < n-b+1);
	});
	for (int i = 1;i <= n;i++) rnk[sa[i]] = i;
}
void initSA(){
	if (n <= 800){//小于 800 就暴力 
		initSABao();
		return;
	}
	for (int i = 1;i <= n;i++) rnk[i] = id[str[i]],cn = max(cn,id[str[i]]);
	for (int i = 1;i <= n;i++) ++cnt[rnk[i]];
	for (int i = 1;i <= cn;i++) cnt[i] += cnt[i-1];
	for (int i = n;i;i--) sa[cnt[rnk[i]]--] = i;
	for (int w = 1;w < n;w <<= 1){
		int cur = 0;
		for (int i = n-w+1;i <= n;i++) lastSa[++cur] = i;
		for (int i = 1;i <= n;i++){
			if (sa[i] > w) lastSa[++cur] = sa[i]-w;
		}
		clear();
		for (int i = 1;i <= n;i++) cnt[rnk[lastSa[i]]]++;
		for (int i = 1;i <= cn;i++) cnt[i] += cnt[i-1];
		for (int i = n;i;i--) sa[cnt[rnk[lastSa[i]]]--] = lastSa[i];
		swap(lastRnk,rnk),cn = 0;
		for (int i = 1;i <= n;i++){
			if (lastRnk[sa[i]] == lastRnk[sa[i-1]] && lastRnk[sa[i]+w] == lastRnk[sa[i-1]+w]) rnk[sa[i]] = cn;
			else rnk[sa[i]] = ++cn;
		}
		if (cn == n) break; 
	}
}
void initHeight(){
	for (int i = 1,j = 0;i <= n;i++){
		if (j) j--;
		while (str[i+j] == str[sa[rnk[i]-1]+j]) ++j;
		height[rnk[i]] = j;
	}
	for (int i = 1,j = 0,minn = 0x3f3f3f3f;i <= n;i++){//扫两遍求blcp 
		if (sa[i] > m+1) minn = 0x3f3f3f3f,j = 1;
		else{
			minn = min(minn,height[i]);
			if (j && sa[i] <= m) blcp[sa[i]] = minn;
		}
	}
	for (int i = n,j = 0,minn = 0x3f3f3f3f;i;i--){
		if (sa[i] > m+1) minn = 0x3f3f3f3f,j = 1;
		else{
			minn = min(minn,height[i+1]);
			if (j && sa[i] <= m) blcp[sa[i]] = max(blcp[sa[i]],minn);
		}
	}
}
void initST(){ 
	for (int i = 1;i <= m;i++) pre[i] = st[i][0] = st[i-1][0]+(str[i] == '(' ? 1 : -1);
	for (int k = 1;k <= lg[m];k++){
		for (int i = 1;i+(1<<k-1) <= n;i++) st[i][k] = min(st[i][k-1],st[i+(1<<k-1)][k-1]);
	}
}
int find(int l,int r){
	int k = lg[r-l+1];
	return min(st[l][k],st[r-(1<<k)+1][k]);
}
void solve(){
	cin >> a >> b,str = ' ' + a + '#' + b,n = str.size()-1,m = a.size(),cn = 0;
	initSA(),initHeight(),initST();
	maxx = 0;
	for (int i = 1;i <= m;i++){
		l = i,r = blcp[i]+l-1,ans = 0;
		while (l <= r){//第一次二分求大于等于的范围 
			mid = l + (r - l >> 1);
			if (find(i,mid) >= pre[i-1]) ans = mid,l = mid + 1;
			else r = mid - 1;
		}
		l = i,r = ans;
		while (l <= r){//第二次二分求最长合法的子串
			mid = l + (r - l >> 1);
			if (find(mid,ans) == pre[i-1]) maxx = max(maxx,mid-i+1),l = mid + 1;
			else r = mid - 1;
		}
	}
	cout << maxx << "\n";
	for (int i = 1;i <= m;i++) blcp[i] = 0;
	clear();
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	for (int i = 2,n = maxn-5;i <= n;i++) lg[i] = lg[i/2]+1;
	id['('] = 1,id[')'] = 2,id['#'] = 3;
	cin >> T;
	while (T--) solve();
	return 0;
}
```

---

## 作者：gdf_yhm (赞：2)

线性！

### 思路

记前缀和 $sum_i$ 表示 $i$ 及之前左括号减右括号的数量。判断 $[l,r]$ 是合法的括号序列，等价于 $sum_{l-1}=sum_r$ 且 $\min_{i=l}^r sum_i\ge sum_{l-1}$。

枚举答案在 $A$ 上的左端点 $l$，计算 $A$ 从 $l$ 开始的后缀与 $B$ 的最长公共子串的长度 $len$。此时 $r\le l+len-1$ 的 $A[l,r]$ 是两串的公共子串，二分在范围内且 $sum_{l-1}=sum_r$ 且 小于第一个 $sum_p<sum_{l-1}$ 的 $p$ 的最大的 $r$。

对于 $l$ 求 $l+len-1$，可以用 [求两串最长公共子串](https://www.luogu.com.cn/problem/SP1811) 的过程。反转 $B$ 建 SAM，反转 $A$ 倒序与 $B$ 匹配，匹配到 $l$ 时匹配的长度即为 $len$。

考虑把剩下的也弄成线性。合法括号序列的限制可以看成：按 $sum_i$ 从小到大依次把点染黑，染黑一个点前求右边第一个黑点的位置。反过来做用双向链表维护。同时处理 $sum$ 相同的点，首先第一个 $sum_p<sum_{l-1}$ 的 $p$ 有单调性，其次 $l+len-1$ 也有单调性，扫一遍即可。

复杂度 $O(n)$，字符集大小为 $2$ 就忽略了。

### code

```cpp
int n,m,ans;
char s[maxn],t[maxn];
int lnk[maxn],len[maxn];
int a[maxn][2];
int p=1,cur=1;
void insert(int c){
	int nd=++cur;
	len[nd]=len[p]+1;
	while(p&&!a[p][c])a[p][c]=nd,p=lnk[p];
	if(!p){lnk[p=nd]=1;return ;}
	int q=a[p][c];
	if(len[q]==len[p]+1)lnk[nd]=q;
	else{
		int cl=++cur;
		len[cl]=len[p]+1,lnk[cl]=lnk[q];
		a[cl][0]=a[q][0],a[cl][1]=a[q][1];
		lnk[nd]=lnk[q]=cl;
		while(p&&a[p][c]==q)a[p][c]=cl,p=lnk[p];
	}
	p=nd;
}
void go(int &p,int c,int &l){
	while(1){
		if(a[p][c]){
			p=a[p][c],l++;
			break;
		}
		if(!l)break;
		l--;
		if(l==len[lnk[p]])p=lnk[p];
	}
}
int sum[maxn],to[maxn];
vector<int> pos[maxn];
int pre[maxn],nxt[maxn];
void del(int p){
	int p1=pre[p],p2=nxt[p];
	nxt[p1]=p2,pre[p2]=p1;
}
void work(){
	scanf("%s%s",s+1,t+1);n=strlen(s+1),m=strlen(t+1);ans=0;
	for(int i=1;i<=cur;i++)lnk[i]=len[i]=a[i][0]=a[i][1]=0;p=cur=1;
	for(int i=m;i;i--)insert(t[i]==')');
	for(int i=n,nd=1,l=0;i;i--){
		go(nd,s[i]==')',l);
		to[i]=i+l-1;
	}
	sum[0]=n;for(int i=1;i<=n;i++)sum[i]=sum[i-1]+(s[i]=='(')*2-1;
	for(int i=0;i<=2*n;i++)pos[i].clear();
	for(int i=0;i<=n;i++)pos[sum[i]].pb(i);
	for(int i=1;i<=n;i++)nxt[i]=i+1,pre[i]=i-1;
	nxt[0]=1,pre[0]=0,nxt[n+1]=n+1,pre[n+1]=n;
	for(int i=2*n;~i;i--)if(pos[i].size()){
		for(int j=pos[i].size()-1;~j;j--)del(pos[i][j]);
		for(int j=0,k;j<pos[i].size();){
			k=j;
			while(k<pos[i].size()&&pos[i][k]<nxt[pos[i][j]])k++;
			// cout<<i<<" "<<j<<" "<<pos[i][j]<<" "<<k<<" "<<pos[i][k-1]<<"\n";
			if(j==k)j++;
			int l=j;
			while(j<k){
				while(l<k&&pos[i][l]<=to[pos[i][j]+1])l++;
				if(j<l)ans=max(ans,min(pos[i][k-1],pos[i][l-1])-pos[i][j]);
				j++;
			}
		}
	}
	printf("%d\n",ans);
}
```

---

## 作者：min_inf (赞：2)

考虑二分，检查是否有 $\ge len$ 的公共匹配串。

对于一个匹配串，设左括号为 $1$ 右括号为 $-1$，那么所有后缀和为 $0$ 的后缀都是匹配串，我们就截取最短的 $\ge len$ 的后缀。这样我们只需要从两个串中分别拿出每个右端点往左最短的 $\ge len$ 的合法后缀的哈希，检查是否有交即可。求这些串容易预处理一些数组做到线性。

```cpp
ull pw[N];
struct str{
    string s;
    int n,lim;
    int a[N],p[N],nx[N],l[N];
    ull hs[N];
    void init(){
        cin>>s,n=s.size();
        a[0]=0;repn(i,n){
            a[i+1]=a[i]+(s[i]=='('?1:-1);
            hs[i+1]=hs[i]*131+s[i];
        }
        int mn=*min_element(a,a+n+1);
        rep(i,0,n)a[i]-=mn;
        lim=*max_element(a,a+n+1);
        rep(i,0,lim)p[i]=-1;per(i,n,0)nx[i]=p[a[i]],p[a[i]]=i;
        rep(i,0,lim)p[i]=-1;rep(i,0,n)l[i]=a[i]?p[a[i]-1]:-1,p[a[i]]=i;
    }
    ull gh(int l,int r){return hs[r]-hs[l]*pw[r-l];}
    vector<ull> get(int len){
        vector<ull> res;
        rep(i,0,lim)p[i]=-1;per(i,n,0)p[a[i]]=i;
        rep(i,1,n){
            while(nx[p[a[i]]]>=0&&i-nx[p[a[i]]]>=len)p[a[i]]=nx[p[a[i]]];
            if(p[a[i]]>l[i]&&i-p[a[i]]>=len)res.push_back(gh(p[a[i]],i));
        }
        return move(res);
    }
}a,b;

void solve(){
    a.init(),b.init();
    int l=0,r=min(a.s.size(),b.s.size());
    while(l<r){
        int mid=l+r+1>>1;
        vector<ull> A=a.get(mid),B=b.get(mid);
        sort(allc(A)),sort(allc(B));
        bool ok=0;
        auto it=B.begin();for(auto x:A){
            while(it!=B.end()&&*it<x)++it;
            if(it!=B.end()&&*it==x){ok=1;break;}
        }
        if(ok)l=mid;else r=mid-1;
    }
    cout<<l<<'\n';
}
```

---


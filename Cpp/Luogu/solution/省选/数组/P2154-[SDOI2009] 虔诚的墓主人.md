# [SDOI2009] 虔诚的墓主人

## 题目描述

小W是一片新造公墓的管理人。公墓可以看成一块 $N×M$ 的矩形，矩形的每个格点，要么种着一棵常青树，要么是一块还没有归属的墓地。

当地的居民都是非常虔诚的基督徒，他们愿意提前为自己找一块合适墓地。为了体现自己对主的真诚，他们希望自己的墓地拥有着较高的虔诚度。

一块墓地的虔诚度是指以这块墓地为中心的十字架的数目。一个十字架可以看成中间是墓地，墓地的正上、正下、正左、正右都有恰好 $k$ 棵常青树。

形式化地，对于一个坐标为 $(x, y)$ 的墓地，以其为中心的十字架个数是这样的长度为 $4k$ 的二元组序列 $[(x_{1,1},y_{1,1}),\allowbreak(x_{1,2},y_{1,2}),\allowbreak\cdots,(x_{1,k},y_{1,k}),\allowbreak(x_{2,1},y_{2,1}),\allowbreak(x_{2,2},y_{2,2}),\allowbreak\cdots,(x_{2,k},y_{2,k}),\allowbreak(x_{3,1},y_{3,1}),\allowbreak(x_{3,2},y_{3,2}),\allowbreak\cdots,(x_{3,k},y_{3,k}),\allowbreak(x_{4,1},y_{4,1}),\allowbreak(x_{4,2},y_{4,2}),\allowbreak\cdots,(x_{4,k},y_{4,k})]$ 的方案数：

- 每一个二元组对应着一棵常青树的坐标；
- $x_{1,1}<x_{1,2}<\cdots< x_{1,k}<x$ 且 $y_{1,1}=y_{1,2}=\cdots=y_{1,k}=y$；
- $x<x_{2,1}<x_{2,2}<\cdots< x_{2,k}$ 且 $y_{2,1}=y_{2,2}=\cdots=y_{2,k}=y$；
- $y_{3,1}<y_{3,2}<\cdots< y_{3,k}<y$ 且 $x_{3,1}=x_{3,2}=\cdots=x_{3,k}=x$；
- $y<y_{4,1}<y_{4,2}<\cdots< y_{4,k}$ 且 $x_{4,1}=x_{4,2}=\cdots=x_{4,k}=x$。

小W希望知道他所管理的这片公墓中所有墓地的虔诚度总和是多少。

## 说明/提示

图中，以墓地 $(2, 2)$ 和 $(2, 3)$ 为中心的十字架各有 $3$ 个，即它们的虔诚度均为 $3$。其他墓地的虔诚度为 $0$。

 ![](https://cdn.luogu.com.cn/upload/pic/1589.png) 

对于 $30\%$ 的数据，满足 $1 ≤ N, M ≤ 10^3$。

对于 $60\%$ 的数据，满足 $1 ≤ N, M ≤ 10^6$。

对于 $100\%$ 的数据，满足 $1 ≤ N, M ≤ 10^9$，$0 ≤ x_i ≤ N$，$0 ≤ y_i ≤ M$，$1 ≤ W ≤ 10^5$，$1 ≤ k ≤ 10$。

存在 $50\%$ 的数据，满足 $1 ≤ k ≤ 2$。

存在 $25\%$ 的数据，满足 $1 ≤ W ≤ 10^4$。

## 样例 #1

### 输入

```
5 6
13
0 2
0 3
1 2
1 3
2 0
2 1
2 4
2 5
2 6
3 2
3 3
4 3
5 2
2```

### 输出

```
6```

# 题解

## 作者：xyz32768 (赞：29)

很容易看出，对于一个空地$(x,y)$，如果上下左右分别有$u$，$d$，$l$，$r$棵常青树，且$u,d,l,r>=k$，那么这块墓地的虔诚度为$C(u,k)*C(d,k)*C(l,k)*C(r,k)$。

但是现在的问题在于坐标系巨大，不能枚举所有的点。考虑离散化坐标后只枚举有效点（可以产生贡献的点），那么有效点也有$O(W^2)$个，无法承受$W<=10^5$的数据范围。首先，预处理出$C[k~W][k]$的值并离散化坐标，然后把常青树以$x$坐标为第一关键字，$y$坐标为第二关键字从小到大排序，这样$x$坐标相同的常青树就在一个连续区间里，并且这个连续区间内的$y$坐标是递增的。

对于一个$x$坐标相同的连续区间，常青树之间的空地只要满足上面和下面的常青树数量都必须$>=k$，就有可能产生贡献。而对于每相邻的两棵常青树之间的所有空地，上面的常青树的数量是一样的，下面的常青树的数量也是一样的。所以可以快速得到$C(u,k)*C(d,k)$的值，但是由于$y$坐标不相同，$C(l,k)*C(r,k)$需要进行求和。而每遇到一棵常青树，对应的$y$坐标的信息就需要改变。所以，这里考虑使用树状数组维护这个值。代码实现如下：

```cpp
for (i = 1; i <= w; i++) {
    if (i == 1 || a[i].x != a[i - 1].x) tt = 0;
    int le = a[i].y, v = (++h[le]) >= K && cnt[le] - h[le] >= K ?
        1ll * C[h[le]][K] * C[cnt[le] - h[le]][K] % 2147483648ll : 0; tt++;
    change(le, v - r[le]); r[le] = v;
    if (i == w || a[i].x != a[i + 1].x || a[i + 1].y - a[i].y <= 1
        || tt < K || tot[a[i].x] - tt < K) continue;
    Ans += 1ll * C[tt][K] * C[tot[a[i].x] - tt][K] % 2147483648ll
        * (ask(a[i + 1].y - 1) - ask(a[i].y)) % 2147483648ll;
}
```
其中$C[][]$是预处理的组合数，$change$和$ask$为树状数组的操作，$cnt[]$记录每个$y$坐标值的出现次数，$tot[]$记录每个$x$坐标值的出现次数，$Ans$为答案。

最后输出答案$Ans$即可。（如果对模数$2147483648$采取自然溢出，那么要注意负数）。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
const int N = 1e5 + 5;
int w, K, C[N][12], Ans, tmp[N], T[N], col, tot[N], cnt[N], r[N], h[N];
struct cyx {int x, y;} a[N];
bool comp(cyx a, cyx b) {
    if (a.x != b.x) return a.x < b.x;
    return a.y < b.y;
}
bool cmp2(cyx a, cyx b) {
    if (a.y != b.y) return a.y < b.y;
    return a.x < b.x;
}
void change(int x, int v) {
    for (; x <= col; x += x & -x)
        T[x] += v;
}
int ask(int x) {
    int res = 0;
    for (; x; x -= x & -x)
        res += T[x];
    return res;
}
int main() {
    int i, j, tt = 0; read(); read(); w = read();
    for (i = 1; i <= w; i++) a[i].x = read(), a[i].y = read();
    K = read(); sort(a + 1, a + w + 1, comp);
    for (i = 0; i <= w; i++) C[i][0] = 1;
    for (i = 1; i <= w; i++) for (j = 1; j <= min(i, K); j++)
        C[i][j] = C[i - 1][j] + C[i - 1][j - 1];
    for (i = 1; i <= w; i++) {
        if (i == 1 || a[i].x != a[i - 1].x) tt++;
        tmp[i] = tt;
    }
    for (i = 1; i <= w; i++) tot[a[i].x = tmp[i]]++;
    sort(a + 1, a + w + 1, cmp2); tt = 0;
    for (i = 1; i <= w; i++) {
        if (i == 1 || a[i].y != a[i - 1].y) tt++;
        tmp[i] = tt;
    }
    for (i = 1; i <= w; i++) cnt[a[i].y = tmp[i]]++; col = a[w].y;
    sort(a + 1, a + w + 1, comp);
    for (i = 1; i <= w; i++) {
        if (i == 1 || a[i].x != a[i - 1].x) tt = 0;
        int le = a[i].y, v = (++h[le]) >= K && cnt[le] - h[le] >= K ?
            1ll * C[h[le]][K] * C[cnt[le] - h[le]][K] % 2147483648ll
            : 0; tt++;
        change(le, v - r[le]); r[le] = v;
        if (i == w || a[i].x != a[i + 1].x || a[i + 1].y - a[i].y <= 1
            || tt < K || tot[a[i].x] - tt < K) continue;
        Ans += 1ll * C[tt][K] * C[tot[a[i].x] - tt][K] % 2147483648ll
            * (ask(a[i + 1].y - 1) - ask(a[i].y)) % 2147483648ll;
    }
    printf("%d\n", Ans >= 0 ? Ans : (1ll * Ans + 2147483648ll)
        % 2147483648ll);
    return 0;
}
```

---

## 作者：K8He (赞：28)

# P2154 虔诚的墓主人 题解
[原题传送门](https://www.luogu.com.cn/problem/P2154)
## 题意
在 $n\times m$ 一个方格上给你 $w$ 个点，求方格里每个点正上下左右各选 $k$ 个点的方案数。

$1\le N,M\le 1,000,000,000,0 \le  x_i \le  N,0 \le  y_i \le  M,1 \le  W \le  100,000,1 \le  k \le  10$。
## 思路
首先看到 $N,M$ 这么大，肯定要先离散化一下。

然后考虑怎么求方案数。

我们先对离散化后的点排个序，然后考虑两个 $x$ 相同的点 $x,y1$ 和 $x,y2$ 之间的所有点的方案数。

显然是:
$$
C_{y1\_UP}^{k}\times C_{y2\_DOWN}^{k}\times \sum_{y1<l<y2}C_{l\_LEFT}^{k}\times C_{l\_RIGHT}^{k}
$$
~~你们意会一下。~~

观察这个式子，$C_{y1\_UP}^{k}\times C_{y2\_DOWN}^{k}$ 当前已知，可以用前缀和维护 $\sum C_{l\_LEFT}^{k}\times C_{l\_RIGHT}^{k}$。

那么我们就开一个树状数组，维护前 $i$ 行的 $C_{l\_LEFT}^{k}\times C_{l\_RIGHT}^{k}$ 之和，每次碰到一个点 $x,yy$ 时把当前行的影响清除，再令 $yy\_LEFT+1,yy\_RIGHT-1$，再重新计入前缀和。

可以参考代码中 Solve 函数中变量 $u$ 的求法。

时间复杂度 $O(nlogn)$。

~~我这个菜鸡居然因为取模取错了调了两节课。~~
## Code
```cpp
#include <bits/stdc++.h>
#define _for(i,a,b) for(ll i=a;i<=b;++i)
#define for_(i,a,b) for(ll i=a;i>=b;--i)
#define ll long long
using namespace std;
const ll N=1e5+10,P=2147483648;
ll n,m,w,k,q[N],h[N],z[N],y[N],ans;
struct tree{ll x,y;}t[N];
inline ll rnt(){
	ll x=0,w=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
	while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return x*w;
}
namespace SZSZ{
	/*树状数组*/
	ll b[N];
	inline ll lowbit(ll x){return x&-x;}
	inline void UpDate(ll x,ll y){
		while(x<=w){
			b[x]=(b[x]+y)%P;
			x+=lowbit(x);
		}
		return;
	}
	inline ll Query(ll x){
        if(x==0)return 0;
		ll sum=0;
		while(x){
			sum=(sum+b[x])%P;
			x-=lowbit(x);
		}
		return sum;
	}
}
namespace LISAN{
	/*离散化*/
	vector<ll>xx,yy;
	inline bool cmp(tree a,tree b){
		if(a.x==b.x)return a.y<b.y;
		return a.x<b.x;
	}
	inline void Add(ll x,ll y){
		xx.push_back(x);
		yy.push_back(y);
		return;
	}
	inline void LiSan(){
		sort(xx.begin(),xx.end());
		sort(yy.begin(),yy.end());
		xx.erase(unique(xx.begin(),xx.end()),xx.end());
		yy.erase(unique(yy.begin(),yy.end()),yy.end());
		_for(i,1,w){
			t[i].x=lower_bound(xx.begin(),xx.end(),t[i].x)-xx.begin()+1;
			t[i].y=lower_bound(yy.begin(),yy.end(),t[i].y)-yy.begin()+1;
			++h[t[i].x],++y[t[i].y];
		}
		sort(t+1,t+w+1,cmp);
		return;
	}
}
namespace SOLVE{
	ll c[N*20][20]={0};
	/*预处理组合数*/
	inline void PreC(){
		c[0][0]=1;
		_for(i,1,w){
			c[i][0]=1;
			_for(j,1,min(k,i))
				c[i][j]=(c[i-1][j]+c[i-1][j-1])%P;
		}
	}
	/*求解*/
	inline ll Solve(){
		PreC();
		_for(i,1,w-1){
			++q[t[i].x];
			++z[t[i].y];
			if(t[i].x==t[i+1].x&&q[t[i].x]>=k&&h[t[i].x]-q[t[i].x]>=k){
				ll up=c[q[t[i].x]][k];
				ll dn=c[h[t[i].x]-q[t[i].x]][k];
				ll ri=SZSZ::Query(t[i+1].y-1)-SZSZ::Query(t[i].y);
				ans+=((up*dn+P)%P*ri+P)%P;
                ans%=P;
			}
			ll u=((c[z[t[i].y]][k]*c[y[t[i].y]-z[t[i].y]][k]+P)%P-(SZSZ::Query(t[i].y)-SZSZ::Query(t[i].y-1)+P)%P+P)%P;
			SZSZ::UpDate(t[i].y,u);
		}
		return ans;
	}
}
int main(){
	n=rnt(),m=rnt(),w=rnt();
	_for(i,1,w){
		t[i].x=rnt(),t[i].y=rnt();
		LISAN::Add(t[i].x,t[i].y);
	}
	k=rnt();
	LISAN::LiSan();
	printf("%lld\n",SOLVE::Solve());
	return 0;
}
/*

*/
```

---

## 作者：Lance1ot (赞：19)

### 虔诚的墓主人

---------------

###### 观察数据范围得思路

$N,M$（地图大小）如此之大，而$W$（树的个数）只有$100,000$

这种情况下，算法时间复杂度多半是关于$W$的。这个题中，能容忍的最大时间复杂度也就是$O(WlogW)$

$But$,但知道算法时间复杂度的最高上限是不能过直接相处如何去做的（当然离散化是能够被想出的）

$So$，应该考虑从暴力算法优化

-----------

##### 暴力

暴力无非就是每个点扫一下。看看上下左右树的个数多少，然后进行组合数的计算

假设上下左右分别有$t_{op},b_{ottom},l_{eft},r_{right}$个

那么答案就是$C_t^k\cdot C_b^k\cdot C_l^k\cdot C_r^k$

时间复杂度$O(N\cdot M) $

##### 优化

![img](https://s1.ax2x.com/2018/12/17/5QAvCA.png)

如图中两个蓝点的位置，我们可以很轻而易举的发现。这两个蓝点上面和下面的$t,b$大小不变

也就是$C_t^k\cdot C_{b}^{k}$大小不变，所以说在统计这两个蓝点方案数的时候，只需要计算每个蓝点（也就是同一个X的两棵树之间的空隙）的时候，只需要关注每个蓝点左右的$l,r$值。从下往上扫描，遇到一个数，就更新一次$t$,$b$.就可以了

可是这样的话，时间复杂度并未改变。

~~如何对敌？~~

~~呵呵呵呵，明日只需老夫一席话语........~~

我们发现，在处理蓝点的时候，并不会对这个个数进行更改。只有在我们从左往右扫的时候，扫到了一棵树，那么这个树与下一个**同纵坐标之间的蓝点**的$l,r$才会更改（深绿框中蓝点与紫点的$l,r$,~~当然这个紫点的位置并不会计算贡献~~）

让我们回顾一下，现在的瓶颈是在于统计每个蓝点（空隙，下称蓝点）的左右的树的个数。

所以说我们要使用数据结构优化求和（什么和？就是当前蓝点的$C_l^k\cdot C_r^k$。为什么可以？利用乘法分配律，分解同一X的两棵树之间的贡献，对答案不影响）

这个数据结构支持什么？

要支持区间求和和单点修改。所以说选用树状数组。

利用树状数组，快速算出两棵树（同一X）之间空隙的$C_l^k\cdot C^k_r$。然后乘以$C_t^k\cdot C_b^k$

就可以保证在$O(WlogW)$的时间复杂度内算出答案

别忘了离散化

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
using std::sort;
const int maxn=101000;
const long long mode=2147483648LL;
struct node
{
    int x,y;//原始位置
    int X,Y;//离散化后位置
    bool operator < (const node &a)const
    {
        if(x!=a.x)  return x<a.x;
        return y<a.y;
        //其实这里用离散后的坐标效果是一样的
    }
};
node T[maxn];
long long last[maxn],Layt[maxn];
long long C[maxn][11];
long long ans;
int totX[maxn],totY[maxn];
int baseX[maxn],lenX;
int baseY[maxn],lenY;
int base[maxn];
int N,M,w,k;
int length;
void insert(long long val,int pos)//Begin：树状数组
{
    while(pos<=length)
    {
        base[pos]=(base[pos]+val)%mode;
        pos+=(pos&(-pos));
    }
    return ;
}
long long sum(int pos)
{
    if(pos==0)  return 0;
    long long res=0;
    while(pos)
    {
        res=(res+base[pos])%mode;
        pos-=(pos&(-pos));
    }
    return res;
}
long long query(int l,int r)
{
    return sum(r)-sum(l-1);
}//End：树状数组

//以上是最普通不过的树状数组
//-----------------------------------
void unique(int *A,int &Len)//去重
{
    sort(A+1,A+Len+1);
    int len=0,now=0x7fffffff;
    for(int i=1;i<=Len;i++)
        if(now!=A[i])
        {
            now=A[i];
            A[++len]=A[i];
        }
    Len=len;//上面的引用，间接更改
    return;
}
int check(int *A,int len,long long val)//离散化查询
{
    int l=1,r=len;
    while(l<r)
    {
        int mid=(l+r)>>1;
        if(A[mid]>=val) r=mid;
        else    l=mid+1;
    }
    return l;
}
//以上是离散化和二分
//-----------------------------------
void init(int x)//组合数
{
    C[0][0]=1;
    for(int i=1;i<=x;i++)
        for(int j=0;j<=10;j++)
            C[i][j]=(C[i-1][j]+(j?C[i-1][j-1]:0))%mode;
    return ;
}
//-----------------------------------
void account(int n)//统计离散化后每一列，每一行共有多少个树
{
    int nowX,nowY;
    for(int i=1;i<=n;i++)
    {
        nowX=check(baseX,lenX,T[i].x);
        nowY=check(baseY,lenY,T[i].y);
        totY[nowY]++;
        totX[nowX]++;
        T[i].X=nowX;T[i].Y=nowY;//记录离散化后每棵树的位置
    }
    length=lenY;
}
void add(int Y,int K)//将一颗树填进树状数组
{
    if(last[Y])//如果这棵树的Y之前有过值，应该先将这个值在树状数组中减去
    {
        //last为上一次的值
        insert(-last[Y],Y);
    	last[Y]=0;//归零
	}
    Layt[Y]++;//这个Y中已经被遍历过的树的数量+1
    if(Layt[Y]>=K&&totY[Y]-Layt[Y]>=K)//新加的这一棵树在左右满足条件
    {
        long long pas=(C[Layt[Y]][K]*C[totY[Y]-Layt[Y]][K])%mode;
        insert(pas,Y);//插入
        last[Y]=pas;//记录
    }
}
long long clac(int l,int r)
{
	if(l>r)	return 0;//防止错误，错误的原因是两棵树之间有可能没有空隙
    return query(l,r);//树状数组查询
}
void work(int n,int K)//解决问题
{
    int nowX=-1,now;//nowX为上一次处理的X位置，now为计数器
    for(int i=1;i<=n;i++)
    {
        if(nowX!=T[i].X)//和上一次不在同一个X中
        {
            now=0;//计数器归零
            nowX=T[i].X;//赋值
        }
        now++;//计数器++
        if(totX[nowX]-now>=k&&now>=K&&T[i+1].X==nowX)
            ans=(ans+(C[now][k]*(clac(T[i].Y+1,T[i+1].Y-1)*C[totX[nowX]-now][k])%mode)%mode)%mode;
        /*
        *   totX[nowX]-now>=k是判断是否上面树的数量可以进行计算
        *   now>=K是判断下面的树的数量是否可以进行计算
        *   T[i+1].X==nowX 特判第i棵树和第i+1棵树在同一X
        *   ------------------------
        *   clac(T[i].Y+1,T[i+1].Y-1)是计算第i棵和第i+1棵之间空隙中的方案总数
        *   ------------------------
        */
        add(T[i].Y,K);  //将这棵树的贡献加入树状数组
    }
}
//解决问题
//--------------------------------------
int main()
{
    scanf("%d%d%d",&N,&M,&w);
    for(int i=1;i<=w;i++)
    {
        scanf("%d%d",&T[i].x,&T[i].y);
        baseX[i]=T[i].x;
        baseY[i]=T[i].y;
    }
    scanf("%d",&k);
    unique(baseX,lenX=w);//手写的去重函数
    unique(baseY,lenY=w);
    sort(T+1,T+1+w);//按照规则排序
    init(w);//初始化组合数
    account(w);//统计离散化后每一列，每一行共有多少个树
    work(w,k);//解决问题
    printf("%lld",(ans+mode)%mode);//输出答案
}
//主函数

```

##### Ps：本人蒟蒻，如有纰漏。请在评论区指出。不胜感激



---

## 作者：二哥啃菜包 (赞：8)

## 题面描述

![](http://images.cnblogs.com/cnblogs_com/JCNL666/1434484/o_jjjj.PNG)

## 样例输入

>5 6
>
>13
>
>0 2
>
>0 3
>
>1 2
>
>1 3
>
>2 0
>
>2 1
>
>2 4
>
>2 5
>
>2 6
>
>3 2
>
>3 3
>
>4 3
>
>5 2
>
>2


## 样例输出

> 6

## 题解

这题真是(#@-^%~!*.......)

简直变态啊，好好的一个坟头非得整出一道题。。。

算了，甭说了分析一下题目吧。

我们发现这题的 $n,m$ 范围是达到了10亿的级别。这。。。

好像直接想不出正解，我们先去看看部分分。

发现 $n,m \leqslant 1000$ 的这部分好像可做。

我们 $O(N^2)$ 对于每个点扫过去，然后如果这个点不是常青树就可以统计一下答案，怎么统计呢？

考虑组合数学：

设在某个方向上有 $a$ 个常青树，我们只要选 $k$ 个那么就是 $C_{a}^{k}$，这个点的方案数就是所有方向的这些方案乘起来。

愉快的解决子问题之后考虑解决本题。

然后我们发现一个性质：

![](http://images.cnblogs.com/cnblogs_com/JCNL666/1434484/o_aaaa.PNG)

~~图片全部由睿智画图生成，见谅~~

当点位于两棵树之间时其实他们在 $y$ 轴方向的方案是一样的。

那么我们考虑快速直接的求出一段常青树之间的区间的方案数。

原来的是：

$\sum_{i=tree[l]}^{tree[r]} C_{L[i]}^{k}*C_{R[i]}^{k}*C_{U[i]}^{k}*C_{D[i]}^{k}$

根据乘法分配率可以直接提出变成

$C_{U[i]}^{k}*C_{D[i]}^{k}*\sum_{i=tree[l]}^{tree[r]}C_{L[i]}^{k}*C_{R[i]}^{k}$

又想到刚刚的性质，那么我们是不是可以快速求出这个式子的前半部分，后半部分怎么办呢？

我们不但要支持查询一段区间$C_{L[i]}^{k}*C_{R[i]}^{k}$的和,还要让这个 $L[i],R[i]$ 发生变化。

这个时候灵光一闪————

我们将题目给我们的坐标们排个序($x$第一关键字，$y$第二关键字)这样所有x相同的点都在一起，我们就可以直接求出这段区间的那个式子的前半部分，后半部分的维护又想到要支持区间求和和单点修改。想到树状数组。

考虑到写一个二维的树状数组还是很难维护，那么我们索性用一维的，把 $x$ 那一维统统交给排序处理，这样我们只要记录一个树状数组 $s[i]$ 表示当在 $y$ 轴 $i$ 方向的时候已经放了 $s[i]$ 个常青树在左边，那么右边就可以动态地用总的个数减一减或者直接动态维护(减一减，加一加)。

对于 $x$ 坐标 相同的我们每次只要同样动态维护下面有几个常青树了。

至于代码应该蛮好写了，代码不懂的可以看看代码注释。

还是蛮好的一道题可以锻炼思维，不懂的欢迎私信(大概意一时半会二不会AFO)。

~~扶我起来我还能苟,~~


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long 
#define x first
#define y second

inline char gc(){
	static char buf[1<<20],*p1=buf,*p2=buf;
	if(p1==p2){
		p2=(p1=buf)+fread(buf,1,1<<20,stdin);
		if(p1==p2) return EOF;
	}
	return *p1++;
}

inline int read(){
    int x=0;char ch=gc();
    while(!isdigit(ch)) ch=gc();
    while(isdigit(ch)) x=x*10+ch-'0',ch=gc();
    return x;
}

int w;
typedef pair<int,int> PII;
const int N=1e5+5,P=2147483648LL;
int x[N],y[N],c[N][15];// c是组合数
int t[N],s[N];// t为当纵坐标是t时左边常青树的个数
int NumOfX[N],NumOfY[N];// 这两个分别表示横坐标为x的点的个数和纵坐标为y的个数（总个数）
PII p[N];// 用来存一下离散之后的坐标，pair真好用

inline int lowbit(int x){
    return x&(-x);
}

inline void update(int x,int plus){
	plus%=P;
    while(x<=w){
        s[x]=(s[x]+plus)%P;
        x+=lowbit(x);
    }
}

inline int query(int x){
    int ret=0;
    while(x){
        ret=(ret+s[x])%P;
        x-=lowbit(x);
    }
    return ret;
}
// 树状数组
signed main(){
    read();read();
    w=read();
    for(int i=1;i<=w;++i) x[i]=p[i].x=read(),y[i]=p[i].y=read();
    int k=read();
	c[0][0]=1;
    for(int i=1;i<=w;++i){
        c[i][0]=1;
        for(int j=1;j<=k;++j)
            c[i][j]=(c[i-1][j]+c[i-1][j-1])%P;
    }
    sort(x+1,x+w+1);
    sort(y+1,y+w+1);
    for(int i=1;i<=w;++i) 
		p[i].x=lower_bound(x+1,x+w+1,p[i].x)-x,NumOfX[p[i].x]++;
    for(int i=1;i<=w;++i) 
		p[i].y=lower_bound(y+1,y+w+1,p[i].y)-y,NumOfY[p[i].y]++;
	// 离散和初始化组合数
    sort(p+1,p+w+1);
    int DOWN=1,ans=0;// DOWN记录当前常青树的下面（包括当前）有几棵常青树
    for(int i=1;i<w;++i){
        if(p[i].x==p[i-1].x) DOWN++;
        else DOWN=1;
        int UP=NumOfX[p[i].x]-DOWN;// UP记录当前常青树上面（不包括当前）有几棵常青树
        if(UP){
            int Ceil=p[i+1].y-1;// ceil表示下一棵有种相同x坐标的常青树的坐标减1（毕竟求区间和不能包括下一棵常青树）
            ans+=c[DOWN][k]*c[UP][k]%P*(((query(Ceil)-query(p[i].y)%P+P)%P))%P;
			// 带进公式里头算一算
        }
        ++t[p[i].y];// 更新一下纵坐标为p[i].y的已经放了的处于左边的常青树
        int now=c[t[p[i].y]][k]*c[NumOfY[p[i].y]-t[p[i].y]][k]%P;
        int pre=((query(p[i].y)-query(p[i].y-1))%P+P)%P;
        update(p[i].y,((now-pre)%P+P)%P);
		// 更新树状数组中这个节点的左右方案数乘积
    }
    printf("%lld\n",(ans%P+P)%P);
    return 0;
}
```

---

## 作者：_CHO (赞：7)

## 扫描线+离散数学

其实去掉求组合数还真就是个扫描线的模板题

这里是线段树写法

------
### 一些闲话

~~做这题时脑海中始终浮现出多年前CCTV10播出过的一个栏目的某一期《选择让历史遗忘的墓主人》,简直是童年阴影~~

-----

观察$n$，$m$的范围显然太大了，考虑离散化，手玩一下可以知道把墓园离散化是不影响答案的。

然后把常青树以$x$坐标为第一关键字，$y$坐标为第二关键字排序。依次处理每一颗常青树。

我们建立一根与$y$轴平行的扫描线，从最左下角的常青树依次向上向右扫描。每当我们发现某一个常青树与上一棵的$x$坐标相同时，可以发现这两棵树之间的空地的上下的常青树棵树 是一样的，那我们只需要统计这些空地的左右各有多少常青树即可。关于这一点，可以预处理出每一行、每一列各有多少树即可。

因为是从左至右扫描，所以我们在处理某一列的时候，这一列坐标的常青树棵树都已经在线段树里面了，直接取出来用即可。最后再把这一行的常青树棵树更新。

当然需要注意，只有常青树棵树都不小于$K$才可以被计入答案

关于算组合数的部分，正确理解题意就好，不再赘述。

讲的比较抽象，具体参见代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e+5+100;
struct Data{
	int x,y;
};
int n,m,K,w,ans;
Data a[maxn];
int A[maxn<<1];
int lne[maxn],qee[maxn],lft[maxn],dwn[maxn];
//qee和lne表示某一列某一行共有多少棵常青树
//lft和dwn表示计算到当前位置左侧和下方有多少棵常青树
int C[maxn][20];
int sumv[maxn<<2];
bool cmp(Data x,Data y){
	return x.x==y.x?x.y<y.y:x.x<y.x;
}

inline void optset(int o,int l,int r,int q,int v){
	if(l==r){
		sumv[o] = v;
		return;
	}
	int mid=l+r>>1;
	if(q<=mid) optset(o<<1,l,mid,q,v);
	else optset(o<<1|1,mid+1,r,q,v);
	sumv[o] = sumv[o<<1] + sumv[o<<1|1];
	return ;
}
inline int query(int o,int l,int r,int ql,int qr){
	if(ql<=l&&r<=qr) return sumv[o];
	int mid=l+r>>1,res=0;
	if(ql<=mid) res = query(o<<1,l,mid,ql,qr);
	if(qr>mid) res+= query(o<<1|1,mid+1,r,ql,qr);
	return res;
}
int main(){
	cin>>n>>m>>w;
	for(int i=1;i<=w;++i){
		cin>>a[i].x>>a[i].y;
		a[i].x;a[i].y;
		A[i<<1] = a[i].x;
		A[i<<1|1] = a[i].y;
	}
	cin>>K;
	sort(A+1,A+2*w+1);
	int cnt = unique(A+1,A+2*w+1) - A - 1;
	for(int i=1;i<=w;++i){
		a[i].x=lower_bound(A+1,A+cnt+1,a[i].x)-A;
		a[i].y=lower_bound(A+1,A+cnt+1,a[i].y)-A;
	}
	sort(a+1,a+w+1,cmp);
	for(int i=1;i<=w;++i){
		lne[a[i].y] ++ ;
		qee[a[i].x] ++ ;
	}
	for(int i=0;i<=w;++i) C[i][0] = 1;
	for(int i=1;i<=w;++i){
		for(int j=1;j<=10&&j<=i;++j){
			C[i][j] = C[i-1][j-1]+C[i-1][j];
			//printf("C[%d][%d] = %d\n",i,j,C[i][j]);
		}
	}
	for(int i=1;i<=w;++i){
		int x=a[i].x,y=a[i].y;
		//printf("myc %d %d\n",x,a[i-1].x);
		if(x==a[i-1].x){
			++dwn[x];
			if(dwn[x]>=K&&qee[x]-dwn[x]>=K){
				int delta = y-a[i-1].y;
				if(delta>1){
					ans += C[dwn[x]][K]*C[qee[x]-dwn[x]][K]*query(1,1,w,a[i-1].y+1,y-1);
				}
			}
		}
		++lft[y];
		if(lft[y]>=K&&lne[y]-lft[y]>=K){
			optset(1,1,w,y,C[lft[y]][K]*C[lne[y]-lft[y]][K]);
		}else{
			optset(1,1,w,y,0);
		}
	}
	if(ans<0) ans += 2147483648ll;
	printf("%d",ans);
	return 0;
}

```

---

## 作者：zzh_2007 (赞：5)

# [SDOI2009]虔诚的墓主人题解  
### 暴力做法：
枚举每一个点，记上下左右各有多少棵树，$a$，$b$，$c$，$d$，答案就加上 $C_{a}^{k} \times C_{b}^{k} \times C_{c}^{k} \times C_{d}^{k}$ 
### 解题思路：
但是这样肯定不行，看到这题先想能不能一行一行处理，将树坐标离散化，我们发现每一行两棵树之间的 $C_{a}^{k}\times C_{b}^{k}$ 是一样的，  
那么答案就可以加上 $\sum_{i=y1+1}^{y2}C_{c}^{k}\times C_{d}^{k}$ 这可以用树状数组来维护  
令当前考虑到树 $\left ( x,y \right ) $，记 $cntx[i][0]$ 为第$i$行的前缀和，$cntx[i][1]$ 为后缀和，$cnty[i][0]$ 为第$i$列的前缀和，$cnty[i][1]$ 为后缀和   
每遇到一棵树时，更新 $cntx$ 和 $cnty$ ,再计算出当前列上下的乘积更新到树状数组里，再查询两棵树之间的和乘上 $C_{a}^{k}\times C_{b}^{k}$ ,累加答案，这题就结束了    
这种题目拿到先排序，看看能不能一行一行处理，找到不变的量就好办了  
### 代码： 
```cpp
#include<bits/stdc++.h>
#define int long long
#define lowbit(x) x&-x
using namespace std;
const int N=1e5+5;
const int mod=2147483648;
struct P{
	int x,y;
	bool operator<(const P&o)const{
		if(x==o.x)return y<o.y;
		return x<o.x;
	}
}a[N];
int n,m,w,k,b[N],d[N],ans,C[N][15],tmp[N],cnt1,cnt2,cntx[N][2],cnty[N][2];//cntx 0左前缀 cnty 0上前缀 
struct BIT{
	int c[N];
	void add(int x,int y){
		for(int i=x;i<=cnt2;i+=lowbit(i))(c[i]+=y)%=mod;
	}
	int query(int x){
		int res=0;
		for(int i=x;i;i-=lowbit(i))(res+=c[i])%=mod;
		return res;
	}
	int query(int l,int r){
		return ((query(r)-query(l-1))%mod+mod)%mod;
	}
}bit;
signed main() {
	cin>>n>>m>>w;
	++n,++m;
	for(int i=1; i<=w; i++) {
		cin>>a[i].x>>a[i].y;
		++a[i].x,++a[i].y;
		b[i]=a[i].x,d[i]=a[i].y;
	}
	cin>>k;
	C[0][0]=1;
	for(int i=1;i<=w;i++){
		C[i][0]=1;
		for(int j=1;j<=k;j++){
			C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;
		}
	}
	sort(b+1,b+w+1);
	sort(d+1,d+w+1);
	cnt1=unique(b+1,b+w+1)-b-1;
	cnt2=unique(d+1,d+w+1)-d-1;
	for(int i=1;i<=w;i++){
		a[i].x=lower_bound(b+1,b+cnt1+1,a[i].x)-b;
		a[i].y=lower_bound(d+1,d+cnt2+1,a[i].y)-d;
		++cntx[a[i].x][1],++cnty[a[i].y][1];
	}
	sort(a+1,a+w+1);
	for(int i=1,nxt;i<=w;i++){
		int x=a[i].x,y=a[i].y;
		++cntx[x][0],--cntx[x][1];
		bit.add(y,-tmp[y]);
		++cnty[y][0],--cnty[y][1];
		tmp[y]=C[cnty[y][0]][k]*C[cnty[y][1]][k]%mod;
		bit.add(y,tmp[y]);
		if(a[i+1].x==x)nxt=i+1;
		else continue;
		ans+=bit.query(a[i].y+1,a[nxt].y-1)*C[cntx[x][0]][k]%mod*C[cntx[x][1]][k]%mod;
		ans%=mod;
	}
	cout<<ans<<endl;
	return 0;
}
```
 

---

## 作者：凌幽 (赞：4)

首先，观察数据范围【震惊】

n\*m的矩阵可达10^18个点！！！

而常青树最多只有10^5个点！！！

假如我们枚举墓地所在的位置，显然枚举量会非常大

相对而言，我们去枚举每一棵常青树会更容易

对于题中的虔诚度，是一种方案数，我们将其用方案数替代

当然，对于如此之大如此之零散的坐标，果断采取离散化

我们可以这样想，对于位于同一行的两棵常青树之间的空地，我们在任意一个位置安置墓地，对于这一行的状态所产生的方案数并没有影响，反而可以很轻松的得到此时的结果，所以我们可以固定一维、移动另一维，用树状数组可以更快的统计和维护状态

另外，根据题意，这是一个坐标系图，所以我们的x、y是严格按照坐标系图定义的

```cpp
scanf("%d%d%d",&n,&m,&w);
for(int i=1;i<=w;++i){
    scanf("%d%d",&tree[i].x,&tree[i].y);
    p[2*i-1]=tree[i].x;
    p[2*i]=tree[i].y;
}
sort(p+1,p+1+2*w);//离散化
```
当然，对于选择，无疑是组合数，对于此时的数据范围，完全可以递推得出

```cpp
void getC(){//计算组合数C      c[i][j] C(i,j)
    c[0][0]=1;
    for(int i=1;i<=w;++i){
        c[i][0]=1;
        for(int j=1;j<=min(k,i);++j)//一定要取min,可以省去很多不必要的计算，不然会T，教训之惨痛QAQ
            c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;
    }
}
```
统计出每一行，每一列分别出现了多少棵树

```cpp
int find(int x){//二分查找,就是手写的lower_bound
    int l=1,r=2*w,mid;
    while(l<=r){
        mid=l+(r-l)/2;
        if(p[mid]<x)l=mid+1;
        else if(p[mid]>x)r=mid-1;
        else return mid;
    }
}
for(int i=1;i<=w;++i)
    a[find(tree[i].x)]++,b[find(tree[i].y)]++;
```
将常青树进行排序，来维护我们算法的正确性

排序确保了我们采取这种策略的正确性

```cpp
bool cmp(node i,node j){
//以纵坐标为第一关键字从小到大，以横坐标为第二关键字从小到大
    if(i.y==j.y)return i.x<j.x;
    else return i.y<j.y;
}
sort(tree+1,tree+1+w,cmp);
```
枚举每一棵树，更确切的说是，我们去扫一遍每一行的树，得到此时的状态所对应的行的方案数，通过维护树状数组得到当前状态列所对应的方案数，由乘法原理可知，方案数相乘为此时的方案数，累计答案

```cpp
for(int i=1;i<=w;++i){
    if(i>1&&tree[i].y==tree[i-1].y){//这两棵常青树在同一行
        this_hang++;//记录每行的常青树有多少棵 
        R ll t1=query(find(tree[i].x)-1)-query(find(tree[i-1].x));//两棵常青树之间的空地，纵向的列有多少种方案数
        R ll t2=c[this_hang][k]*c[b[find(tree[i].y)]-this_hang][k];//在这两棵常青树之间安置墓地的话，这一行的方案数
        ans=(ans+t1*t2%mod)%mod;
    }
    else this_hang=0;//扫到了新一行的常青树
    R int d=find(tree[i].x);
    now[d]++;//now[d]记录该列已经记录了多少棵常青树 
    R int change=(c[now[d]][k]*c[a[d]-now[d]][k]-c[now[d]-1][k]*c[a[d]-now[d]+1][k])%mod;//当前状态的方案数-上一状态的方案数，来更新维护当前的状态所对应的方案数
    add(d,change);
}
```
当然，在最后输出答案的时候，出些小乱子是不是让人异常火大？？？

```printf("%lld",ans>=0?ans:ans+mod);```
对于程序中的query和add操作，就是基本的树状数组的操作，这里不予讲述
对于这种固定一维，移动另一维的方法，在没有经过大量刷题和建模思想，确实不太容易会想到，当然，作为数据结构的树状数组的特性，也得到了很好的应用


---

## 作者：_ctz (赞：2)

[点击阅读体验不一定会更好](https://ctz45562.github.io/2019/03/15/%E9%A2%98%E8%A7%A3-%E6%B4%9B%E8%B0%B7-P2154-%E3%80%90-SDOI2009-%E8%99%94%E8%AF%9A%E7%9A%84%E5%A2%93%E4%B8%BB%E4%BA%BA%E3%80%91/)

[传送门](https://www.luogu.org/problemnew/show/P2154)

来一发优美的线段树版题解$QwQ$。

对于一块墓碑，它的贡献是上方取$k$棵树、下方取$k$棵树、左边取$k$棵树、右边取$k$棵树方案数的乘积。

即：假设一块墓碑上、下、左、右分别有$u,d,l,r$棵树（下同），其贡献为$C(u,k)*C(d,k)*C(l,k)*C(r,k)$。

预处理出组合数，离散化后扫描线扫$x$轴，注意到**y轴上的两棵树之间的点它们的u和d是相同的**

就像这样：

![](https://cdn.luogu.com.cn/upload/pic/54071.png )

也就是说它们的$C(u,k)*C(d,k)$是可以$O(1)$算出来的。那么就能维护一下$\sum C(l_i,k)*C(r_i,k)$乘起来算进答案里。

首先算出$y$轴每列有多少棵树，以此为初始$r$值，$l$为$0$，从左到右扫。遇到一棵树就把这一列的$r$减$1$，$l$加$1$，并更新这个点的$C(l,k)*C(r,k)$。对同一排上的两棵树查询中间的$\sum C(l_i,k)*C(r_i,k)$即可。

树状数组蒟蒻不会更新$QAQ$，都放在了线段树上搞。

代码：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <vector>

#define maxn 100005
#define inf 0x3f3f3f3f

const long long mod = 2147483648ll;

using namespace std;

inline int read(){
	int x=0,y=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return y?-x:x;
}
template<typename T>
inline T read(){
	T x=0;
	int y=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return y?-x:x;
}
long long C[11][maxn],c[maxn];
int disx[maxn],disy[maxn],init[maxn],lenx,leny;
vector<int>X[maxn];
struct Segment_Tree{
	long long dat[maxn<<2];
	int ll[maxn<<2],rr[maxn<<2];
#define ls(x) (x<<1)
#define rs(x) (x<<1|1)
	inline void update(int node){
		dat[node]=(dat[ls(node)]+dat[rs(node)])%mod;
	}
	void build(int l,int r,int node){
		if(l==r){
			rr[node]=init[l];
			return;
		}
		int mid=l+r>>1;
		build(l,mid,ls(node));
		build(mid+1,r,rs(node));
	}
	void add(int poi,int l,int r,int node){
		if(l==r){
			--rr[node],++ll[node];
			dat[node]=c[rr[node]]*c[ll[node]]%mod;
            //更新组合数
			return;
		}
		int mid=l+r>>1;
		if(poi<=mid)add(poi,l,mid,ls(node));
		else add(poi,mid+1,r,rs(node));
		update(node);
	}
	long long ask(int L,int R,int l,int r,int node){
		if(L<=l&&R>=r)return dat[node];
		int mid=l+r>>1;
		long long ans=0;
		if(L<=mid)ans=ask(L,R,l,mid,ls(node));
		if(R>mid)ans+=ask(L,R,mid+1,r,rs(node));
		return ans%mod;
	}
}st;
struct tree{
	int x,y;
}t[maxn];
int main(){
	C[0][0]=1;
	read(),read();
	int n=read();
	for(register int i=1;i<=n;++i)
		disx[++lenx]=t[i].x=read(),disy[++leny]=t[i].y=read();
	sort(disx+1,disx+lenx+1);
	sort(disy+1,disy+leny+1);
	lenx=unique(disx+1,disx+1+lenx)-disx-1;
	leny=unique(disy+1,disy+1+leny)-disy-1;
    //离散化
	int k=read();
	for(register int i=1;i<=n;++i){
		++init[t[i].y=lower_bound(disy+1,disy+1+leny,t[i].y)-disy];//初始的r值
		X[lower_bound(disx+1,disx+1+lenx,t[i].x)-disx].push_back(t[i].y);
		C[0][i]=1;
		for(register int j=1;j<=k;++j)
			C[j][i]=(C[j][i-1]+C[j-1][i-1])%mod;
		c[i]=C[k][i];
        //预处理组合数。因为都是关于k的就压进了一个数组
	}
	st.build(1,leny,1);
	long long ans=0;
	for(register int i=1;i<=lenx;++i){
		sort(X[i].begin(),X[i].end());//一定要排序
		if(!X[i].empty())st.add(X[i][0],1,leny,1);
		for(register int j=1;j<X[i].size();++j){
			if(X[i][j-1]+1<X[i][j]&&j>=k&&X[i].size()-j>=k)(ans+=st.ask(X[i][j-1]+1,X[i][j]-1,1,leny,1)*c[j]%mod*c[X[i].size()-j]%mod)%=mod;
			st.add(X[i][j],1,leny,1);
		}
	}
	printf("%lld\n",ans);
}

```



---

## 作者：Reunite (赞：1)

## 一
---

记对于点 $(x,y)$，其正上，下，左，右的关键点数为 $dt,dd,dl,dt$。首先明确我们要求的就是

$$ans=\sum_{x=1}^{n} \sum_{y=1}^{m} C_{dx}^k\cdot C_{dy}^k\cdot C_{dt}^k\cdot C_{dd}^k$$
---
正确性显然，其他题解已经足够详细，不再赘述，下面主要讲讲具体做法。

## 二
---
显然，只有与关键点在同行同列的点才会对答案有贡献，那么我们可以离散化，其实我们只需要对第二维离散化即可。

考虑扫描线的离线做法，按照第一维从小到大排序，相同时第二维从小到大排序。这样保证了 $x$ 相同的点在 $y$ 升序的同时编号连续。容易发现我们只要考虑两个相邻的 $x$ 相同的点之间的贡献即可。

直接做可能被斜正方形的构图给卡成 $O(n^2)$，现在考虑优化这个过程。用树状树组可以快速求得。因为这两个相邻点间无其他点，因此 $C_{dt}^k\cdot C_{dd}^k$ 是不变的。树状树组中维护的是前 $i$ 行的前缀贡献。

整理算法流程：找出 $x$ 相同的连续段，用类似双指针的思想维护 $C_{dt}^k\cdot C_{dd}^k$ 的值，再用树状树组求值，相乘。考虑如何加入这一段点的贡献，对于 $x$ 相同的每个点，先删去原来这个点这一行在树状树组的贡献，在计算新贡献，加上。

总时间复杂度 $O(n\log_2n)$。

特别注意取模的问题，我一开始用无符号整形自然溢出，但挂了不少点，后来改成长整型并对 $2147483648$ 才通过。

## 三
---
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#define ll long long
using namespace std;

ll n,m,mod=2147483648ll;
int w,k,cnt;
ll ans;
int h[100005];
int hh[100005];
ll xx[100005];
ll C[100005][15];
ll tree[100005];
struct node{ll x,y;}a[100005];

inline void in(ll &n){
	n=0;
	char c=getchar();
	while(c<'0' || c>'9') c=getchar();
	while(c>='0'&&c<='9') n=n*10+c-'0',c=getchar();
	return ;
}

inline bool cmp(node p,node q){return p.x==q.x?p.y<q.y:p.x<q.x;} 

inline void add(int x,ll k){while(x<=cnt) tree[x]=(tree[x]+k)%mod,x+=x&-x;return ;}
inline ll ask(int x){ll s=0;while(x) s=(s+tree[x])%mod,x^=x&-x;return s;}

int main(){
	in(n),in(m);
	scanf("%d",&w);
	for(int i=1;i<=w;i++){
		in(a[i].x),in(a[i].y);
		a[i].x++,a[i].y++;
		xx[i]=a[i].y;
	}
	scanf("%d",&k);
	sort(xx+1,xx+1+w);
	cnt=unique(xx+1,xx+1+w)-xx-1;
	for(int i=1;i<=w;i++) a[i].y=lower_bound(xx+1,xx+1+cnt,a[i].y)-xx,h[a[i].y]++;
	sort(a+1,a+1+w,cmp);
	C[0][0]=C[1][0]=C[1][1]=1;
	for(int i=2;i<=w;i++){
		C[i][0]=1;
		for(int j=1;j<=k;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;
	}
	for(int l=1;l<=w;l++){
		int r=l;
		while(a[l].x==a[r].x&&r<=w) r++;
		r--;
		ll s=0;
		for(int i=l+1;i<=r;i++)
			s=(s+(ask(a[i].y-1)-ask(a[i-1].y)+mod)%mod*C[i-l][k]%mod*C[r-i+1][k]%mod)%mod;
		ans+=s;
		for(int i=l;i<=r;i++){
			ll tt=C[hh[a[i].y]][k]*C[h[a[i].y]-hh[a[i].y]][k]%mod;
			add(a[i].y,-tt);
			tt=C[hh[a[i].y]+1][k]*C[h[a[i].y]-hh[a[i].y]-1][k]%mod;
			hh[a[i].y]++;
			add(a[i].y,tt);
		}
		l=r;
	}
	printf("%lld\n",(ans%mod+mod)%mod);
	
	return 0;
}
```

---

## 作者：TsReaper (赞：1)

各位能想象各种WA各种调最后发现答案忘记取模的感受么...

题意可能有点不太好理解，需要结合样例来理解。理解了题意之后我们发现，答案就是：

sigma(C(l(x,y),k)\*C(r(x,y),k)\*C(u(x,y),k)\*C(d(x,y),k))（(x,y)是整个地图上任意一点，l,r,u,d分别表示点(x,y)正左/右/上/下方的点数，C表示组合数）。


但是这样O(nm)的算法是通过不了100%的数据的。然而我们发现1 ≤ W ≤ 100,000，所以我们从常青树的角度入手来思考。

先将所有常青树以y坐标为第一关键字，x坐标为第二关键字，从小到大排序。对于第i棵常青树，如果第i-1棵常青树的y坐标与它相同，那么两棵常青树之间的空地的虔诚度之和为：

C(l(i-1),k)\*C(r(i),k)\*sigma(C(u(x),k)\*C(d(x),k))（x介于第i-1~第i棵常青树之间。其中l(i-1)表示与第i-1棵常青树y坐标相同，且x坐标小于等于它的常青树数量，r(i)则表示与第i棵常青树y坐标相同，且x坐标大于等于它的常青树数量；u(x),d(x)表示点(x,y)正上/下方有多少常青树，C表示组合数）。


l(i-1)与r(i)容易得到，接下来的问题是如何得到sigma(C(u(x),k)\*C(d(x),k)). 我们发现，这正好是一个单点修改，区间查询的问题。所以，我们用树状数组来维护这个值。设第i棵常青树x坐标为xi，处理第i棵常青树后，我们将树状数组xi位置的值从C(u(xi),k)\*C(d(xi),k)改为C(u(xi)-1,k)\*C(d(xi)+1,k)（因为我们对常青树从下到上排序了，枚举完一棵树后，这棵树的位置就从上方变成了下方）。这样，利用树状数组动态求和，我们就解决了问题。

另外，由于坐标的值都比较大，我们需要对坐标进行离散化处理。

再另外，由于取模的数正好是int的最大值+1，所以自然溢出就好，不需要特别取模。速度可以加快一些。

```cpp

#include <stdio.h>
#include <stdlib.h>
#define MOD 2147483648LL
int n,m,p[100010][2];
int u[100010],d[100010],l[100010],r[100010],xcnt = 0,ycnt = 0;
int f[100010][15],sum[100010],ans = 0;
int compx(const void *a, const void *b)
{
    return ((int*)a)[0] - ((int*)b)[0];
}
int compy(const void *a, const void *b)
{
    return ((int*)a)[1] - ((int*)b)[1];
}
int comp(const void *a, const void *b)
{
    int ay = ((int*)a)[1],by = ((int*)b)[1];
    if(ay != by) return ay-by;
    return ((int*)a)[0] - ((int*)b)[0];
}
int lowbit(int x)
{
    return x&(-x);
}
void add(int pos,int x)
{
    for(;pos<=xcnt;pos+=lowbit(pos)) sum[pos] += x;
}
int query(int pos)
{
    int tans = 0;
    for(;pos;pos-=lowbit(pos)) tans += sum[pos];
    return tans;
}
int main()
{
    int i,j,last;
    scanf("%*d%*d%d",&n);
    for(i=1;i<=n;i++) scanf("%d%d",&p[i][0],&p[i][1]);
    scanf("%d",&m);
    f[1][0] = f[1][1] = 1;
    for(i=2;i<=n;i++)
    {
        f[i][0] = 1;
        for(j=1;j<=m;j++) f[i][j] = f[i-1][j-1]+f[i-1][j];
    }
    qsort(p+1,n,sizeof(p[0]),compx);
    for(i=1,last=-1;i<=n;i++)
    {
        if(p[i][0] != last) { last = p[i][0]; xcnt++;}
        p[i][0] = xcnt; u[xcnt]++;
    }
    qsort(p+1,n,sizeof(p[0]),compy);
    for(i=1,last=-1;i<=n;i++)
    {
        if(p[i][1] != last) { last = p[i][1]; ycnt++;}
        p[i][1] = ycnt; r[ycnt]++;
    }
    qsort(p+1,n,sizeof(p[0]),comp);
    for(i=1;i<=n;l[p[i][1]]++,r[p[i][1]]--,add(p[i][0],f[u[p[i][0]]-1][m]*f[d[p[i][0]]+1][m]-f[u[p[i][0]]][m]*f[d[p[i][0]]][m]),u[p[i][0]]--,d[p[i][0]]++,i++)
    {
        if(p[i-1][1] != p[i][1]) continue;
        ans += f[l[p[i][1]]][m]*f[r[p[i][1]]][m]*(query(p[i][0]-1)-query(p[i-1][0]));
    }
    printf("%lld",(ans+MOD)%MOD);
    return 0;
}

```

---

## 作者：lizitong (赞：1)

题目大意，给出一个N*M的方格，在每个点上分布着常青树/墓地，我们需要统计每

个墓地的虔诚度，相加求得答案。

题中描述的是“恰好”有k颗树，看一眼样例，发现事情没那么简单，再结合答案很

容易分析出我们应该求的是每个点上下左右对应的组合数相乘。

由乘法原理可知，我们要求的是从上下左右的常青树中分别选出k颗，对应的方案数
乘乘积。


观察数据范围，k <= 10,由杨辉三角行列数对应组合数，我们可以通过杨辉三角递

推式，预处理出所有的组合数。

然而再看一眼数据范围，N，M的范围过大，不用说线性递推，数组都开不下。然而

常青树W的个数却只有100,000个，考虑离散化。

在离散化的过程中，顺手处理出每行每列的常青树个数。（后面在解释）。


至此，预处理的所有工作已经完成，放个代码。（码风丑，请见谅）

离散化：（1倍存原数，2倍存x，3倍存y）
```cpp
inline void discretizition()
{
    scanf("%d%d%d",&n,&m,&w);
    for(int i = 1;i<=w;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        nd[i+w].temp = x;
        nd[i+w].kind = 1;
        nd[i+w].num = i;
        nd[i+2*w].temp = y;
        nd[i+2*w].kind = 2;
        nd[i+2*w].num = i;
    }            
    int cnt = 1;
    sort(nd+w+1,nd+3*w+1,cmp1);
    for(int i = w+1;i<=3*w;i++)
    {
        if(i==w+1)
        {
            int num = nd[i].num;
            if(nd[i].kind==1)
            {
                nd[num].x = cnt;
                lie[cnt]++;    //列数
            }else
            {
                nd[num].y = cnt;
                hang[cnt]++;    //行数
            }
            continue;
        }
        if(nd[i].temp!=nd[i-1].temp)cnt++;
        int num = nd[i].num;
        if(nd[i].kind==1)
        {
            nd[num].x = cnt;
            lie[cnt]++;  //列数
        }else
        {
            nd[num].y = cnt;
            hang[cnt]++;    //行数
        }
    }
}
```
递推杨辉三角，预处理组合数：
```cpp
inline void getC()
{
    scanf("%d",&k);
    C[0][0] = 1;
    for(int i = 1;i<=W;i++)
    {
        for(int j = 0;j<=10;j++)
        {
            if(j==0){C[i][j] = 1;continue;}
            C[i][j] = (C[i-1][j-1]+C[i-1][j])&mod;
        }
    }
}
```
明确一点小技巧，取模2147483648和按位与2147483647效果是一样的。

(1<<31==2147483648)

如果还不明白，请实践几组数，或者仔细想想。毕竟脑袋是用来想的，不是用来装饰的。

当我们完成预处理步骤时，我们已经将整个方格缩小到了100,000×100,000的大小
了，接下来便是如何计算虔诚度。

暴力枚举墓地？必然超时（但是洛谷数据貌似可以通过一些玄学优化方法过掉，这

里暂不提及）。我们需要找到一种更为快速的方法。

When you have eliminated the impossibles,whatever remains,however 
improbable,must be the truth.——福尔摩斯

我们希望能出现O（wlog）的方法，或者O（w）的方法。由于常青树一共只有

100,000颗，既然我们不能枚举墓地，不妨枚举常青树。

而枚举常青树又不能随意枚举，不然在累积虔诚度的时候又会变成w方的情况，我

们需要一些数据结构来维护虔诚度，如何维护？维护什么？这就是本题的关键。

经过我们的一番分析（标签）我们知道本题使用的数据结构是树状数组。

不要问我怎么分析出来的树状数组，我就是看到它是树状数组才决定的做这道题。

我们在枚举的过程中，想要求的是每个空地上下左右组合数的乘积，可以发现在同

一行（列）（以下统一为行）两颗常青树之间的空地，它们左面和右面常青树的组

合数是相同的。

这也就给了我们灵感，我们可以通过有顺序的枚举，确定一维，转移一维。这时候

需要把所有点按照行优先，列其次的顺序排序。这样枚举的时候就是有序的了。

再瞅一眼图，找找感觉。

我们在枚举的时候可以通过前后点是否在同一行，定义变量来记录这一行已经枚举

了多少颗常青树，再通过这一行常青树的总数，

减去左方的常青树，即可得到右方的常青树，左右的组合数乘积即可轻松得到。这

也就是之前要维护每一行常青树个数的原因。

那么如何快速计算同一行两颗常青树之间墓地的虔诚度之和？
![](https://img2018.cnblogs.com/blog/1532556/201902/1532556-20190209201639401-730083613.png)

好，现在在下数起第三行，出现了两个蓝色点，它们左右的常青树数量相同。

不妨设L为两个蓝色点左边组合数，R为两个蓝色点右边组合数，U1为1号蓝色点上

方组合数，D1为其下方组合数，U2同理为2号蓝色点上方组合数，D2为蓝色点下方

组合数。

我们要求的这两个点的虔诚度为：

Ans = L×R×U1×D1 + L×R×U2×D2
       
       = L×R×（U1×D1 + U2×D2）

看到这里，您应该已经猜到如何快速计算墓地虔诚度的和了。

树状数组里面存的不是常青树个数，我们将每一列的列数作为树状数组的下标，将

这一列在本时刻所对应的上下组合数的乘积存入树状数组中，再通过前缀和相减，

算出两颗常青树之间的墓地的上下组合数乘积之和。

对应上方例子，即树状数组四号点存储的是U1×D1，五号点存储的是U2×D2，所求

虔诚度：

Ans = L×R×（getsum（5）-getsum（4-1））；

在算完两棵树之间的墓地后，需要更新对应列的树状数组中的值，更新的值即为重

新算出的组合数与之前的组合数之差，对应例子中，4号点应该更新的值即为：

Update（4，（U1-1）×（D1+1）-U1×D1）；

5号点同理。

这里的D1/U1可以通过枚举顺序记录，作者通过自下而上枚举，所以通过数组记录

了D1，之前又记录了每一列的常青树个数，相减即可得到U1。

逐渐枚举，更新答案即可。

换行或两颗常青树相邻的情况读者自行思考即可，除此以外最好将行列数坐标+1，

因原题中原点为（0,0），树状数组更新不便。

Talk is cheap，show me the code。
```cpp
#include<cstdio>
#include<algorithm>
#define W 100005
#define mod 2147483647
#define ll long long
using namespace std;
int n,m,w,lie[2*W+1],hang[2*W+1],k,tree[2*W],down[2*W];
ll C[2*W+1][12];
ll ans;
struct node
{
    int x,y,num,kind,temp;
}nd[W*3+2];
inline bool cmp1(node a,node b)
{
    return a.temp<b.temp;
}
inline bool cmp(node a,node b)
{
    if(a.y!=b.y)
    {
        return a.y<b.y;
    }else
    {
        return a.x<b.x;
    }
}
inline void discretizition()
{
    scanf("%d%d%d",&n,&m,&w);
    for(int i = 1;i<=w;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        nd[i+w].temp = x;
        nd[i+w].kind = 1;
        nd[i+w].num = i;
        nd[i+2*w].temp = y;
        nd[i+2*w].kind = 2;
        nd[i+2*w].num = i;
    }            
    int cnt = 1;
    sort(nd+w+1,nd+3*w+1,cmp1);
    for(int i = w+1;i<=3*w;i++)
    {
        if(i==w+1)
        {
            int num = nd[i].num;
            if(nd[i].kind==1)
            {
                nd[num].x = cnt;
                lie[cnt]++;    
            }else
            {
                nd[num].y = cnt;
                hang[cnt]++;    
            }
            continue;
        }
        if(nd[i].temp!=nd[i-1].temp)cnt++;
        int num = nd[i].num;
        if(nd[i].kind==1)
        {
            nd[num].x = cnt;
            lie[cnt]++;
        }else
        {
            nd[num].y = cnt;
            hang[cnt]++;    
        }
    }
}
inline void getC()
{
    scanf("%d",&k);
    C[0][0] = 1;
    for(int i = 1;i<=W;i++)
    {
        for(int j = 0;j<=10;j++)
        {
            if(j==0)
            {
                C[i][j] = 1;
                continue;
            }
            C[i][j] = (C[i-1][j-1]+C[i-1][j])&mod;
        }
    }
}
inline int lowbit(int x)
{
    return x&(-x);
}
inline void update(int pos,int x)
{
    for(int i = pos;i<=w;i+=lowbit(i))
    {
        tree[i]+=x;
    }
}
inline ll getsum(int pos)
{
    ll tmp = 0;
    for(int i = pos;i;i-=lowbit(i))
    {
        tmp=(tmp+tree[i])&mod;
    }
    return tmp&mod;
}
inline void solve()
{
    sort(nd+1,nd+1+w,cmp);
    int tot = 0;
    for(int i = 1;i<=w;i++)
    {
        if(i==1)
        {
            tot++;
            down[nd[i].x]++;
            update(nd[i].x,(C[down[nd[i].x]][k]*C[lie[nd[i].x]-down[nd[i].x]][k])&mod);
            continue;
        }
        if(nd[i].y==nd[i-1].y)
        {
            tot++;
            if((tot-1>=k)&&(hang[nd[i].y]-tot+1>=k))
            {
                ll tp = getsum(nd[i].x-1)-getsum(nd[i-1].x);
                tp = tp*C[hang[nd[i].y]-tot+1][k]*C[tot-1][k]&mod;
                ans = (ans+tp)&mod;
            }
            down[nd[i].x]++;
            update(nd[i].x,(C[down[nd[i].x]][k]*C[lie[nd[i].x]-down[nd[i].x]][k]&mod)-(C[down[nd[i].x]-1][k]*C[lie[nd[i].x]-down[nd[i].x]+1][k]&mod));            
        }else
        {
            down[nd[i].x]++;
            update(nd[i].x,(C[down[nd[i].x]][k]*C[lie[nd[i].x]-down[nd[i].x]][k]&mod)-(C[down[nd[i].x]-1][k]*C[lie[nd[i].x]-down[nd[i].x]+1][k]&mod));
            tot = 1;
        }
    }
    printf("%lld\n",ans&mod);
}
int main()
{
    discretizition();
    getC();
    solve();
    return 0;
}
```

---

## 作者：Adove (赞：1)

昨天在宿舍想了一个晚上终于弄明白这题是怎么一回事了；

我们来看样例：

- 001000
- 001000
- 001000
- 110110
- 110101
- 001000
- 001000

一个很显然的暴力做法：二维前缀和+组合数，期望得分：30，实际得分：32；

但是二维前缀和显然无法得到全部的分数；

一般来说，一维前缀和单点修改时间爆炸的情况，我们考虑线段树；

那么二维前缀和时空都爆炸，我们肯定不能搞个什么二维线段树出来；

想办法消掉一维？排序二分？

扫描线！

没错就是扫描线思想，当整个图数据太大而只有一部分数据对我们有用时，常用扫描线；

我们对常青树以x为第一关键字，y为第二关键字从小到大排序；

然后从左往右扫（个人习惯）；

一般来说，线段树与扫描线方向垂直，我们先确定线段树方向是垂直于x轴的；

然后我们考虑线段树维护的东西；

从样例中观察，这个“恰好”二字并不能表示为一个bool型的量作“是1非0”处理，好像是组合数！~~（考场上纠结了很久甚至想要打死出题人，“恰好”难道不是多了也不算吗qwq）~~

那么对于一个有贡献的墓地，其贡献等于四方向常青树数目对k的组合数乘积；

那么线段树维护的信息应该与组合数有关；

既然线段树随扫描线从左向右平移，那么维护的信息应该在水平方向；

于是我们就得到了楼下的式子。于是我们就得到了这个问题精妙的解决方案。

于是你动手写线段树。~~于是你愉快地TLE了~~

线段树常数很大怎么办？

对于这类问题我们考虑两个方案：
1. 对于单标记的**永久化**
2. 更换**常数较小**的数据结构

两者都能在一定程度上解决线段树自身常数过大的问题；

既然树状数组的题解已经有了，那我就来一发zkw线段树！

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

const int MAXN=(1<<17)-1;

int n,m,W,k,ans;
int C[MAXN][13];
int tree[MAXN<<1],cnto[MAXN],cntd[MAXN],cntl[MAXN],cntr[MAXN];
struct pnt{
	int x,y;
	int rex,rey;
}p[MAXN];

bool cmp1(pnt a,pnt b){
	if(a.y==b.y) return a.x<b.x;
	return a.y<b.y;
}bool cmp2(pnt a,pnt b){
	if(a.x==b.x) return a.y<b.y;
	return a.x<b.x;
}

void init(){
	scanf("%d%d%d",&n,&m,&W);
	for(int i=1;i<=W;++i){
		scanf("%d%d",&p[i].x,&p[i].y);
	}scanf("%d",&k);
	for(int i=0;i<=W;++i){
		C[i][0]=1;
		for(int j=1;j<=min(i,k);++j){
			C[i][j]=C[i-1][j]+C[i-1][j-1];
		}
	}sort(p+1,p+W+1,cmp1);
	p[1].rey=1;
	for(int i=2;i<=W;++i){
		if(p[i].y==p[i-1].y) p[i].rey=p[i-1].rey;
		else p[i].rey=p[i-1].rey+1;
	}sort(p+1,p+W+1,cmp2);
	p[1].rex=cntr[p[1].rey]=cnto[p[1].rex]=1;
	for(int i=2;i<=W;++i){
		if(p[i].x==p[i-1].x) p[i].rex=p[i-1].rex;
		else p[i].rex=p[i-1].rex+1;
		++cntr[p[i].rey];++cnto[p[i].rex];
	}
}

void solve(){
	for(int i=1;i<=W;++i){
		++cntl[p[i].rey];--cntr[p[i].rey];
		++cntd[p[i].rex];--cnto[p[i].rex];
		tree[MAXN+p[i].rey]=C[cntl[p[i].rey]][k]*C[cntr[p[i].rey]][k];
		for(int j=MAXN+p[i].rey>>1;j;j>>=1) tree[j]=tree[j<<1]+tree[j<<1|1];
		if(p[i].rex==p[i-1].rex&&p[i].rey-p[i-1].rey>1){
			if(cnto[p[i].rex]+1>=k&&cntd[p[i].rex]-1>=k){
				int l=MAXN+p[i-1].rey,r=MAXN+p[i].rey;
				int sum=0;
				while(l^r^1){
					if(~l&1) sum+=tree[l^1];
					if(r&1) sum+=tree[r^1];
					l>>=1;r>>=1;
				}ans+=sum*C[cnto[p[i].rex]+1][k]*C[cntd[p[i].rex]-1][k];
			}
		}
	}
}

void write(){
	printf("%d\n",ans>=0?ans:ans+2147483648ll);
}

int main(){
	freopen("religious.in","r",stdin);
	freopen("religious.out","w",stdout);
	init();
	solve();
	write();
	return 0;
}
```

---

## 作者：zhangxiao666 (赞：0)

### 前言：
前置芝士：
1. 组合数

1. 离散化

1. 树状数组

### 题意：
[题目传送门](https://www.luogu.com.cn/problem/P2154)

我们把常青树设为 $1$，墓地设为 $0$。一个墓地的值为该点上下左右都恰好选出 $k$ 个点的方案数。求所有墓地值的总和。

### 思路：
首先对于一个墓地 $i$，根据题意，它的值就是 $C_{up_i}^k\times C_{down_i}^k\times C_{left_i}^k\times C_{right_i}^k$（$up,down,left,right$ 分别表示上下左右 $1$（常青树）的数量）。不过就这么暴力枚举每个点，看一下数据范围，~~得跑明年去~~。

但是 $W$ 的范围很小，也就是说对答案有贡献的点很少，没有贡献的完全不用考虑。

说白了，就是离散化。

再说明白点，如果某一列没有常青树，就不用考虑这一列。

将点离散化重新编号后，就可以步入正题了。

其实，对于两个 $x$ 坐标相同的点 $(x,y1)$ 与 $(x,y2)$，根据上面的式子，他们中间的点的总贡献即为 

$$C_{up_{y1}}^k\times C_{down_{y2}}^k\times \sum_{y1<i<y2} C_{left_i}^k\times C_{right_i}^k$$

前面的 $C_{up_{y1}}^k\times C_{down_{y2}}^k$ 是可以直接求出的（预处理组合数），后面那个 $\sum$ 里的东西显然可以用树状数组维护。

具体的，每加入一个点，就对应地维护这个点的值（值就是组合数的值），并且求那个 $y1$ 至 $y2$ 间的和，显然就是一个单点修改、区间查询的问题，自然就能用树状数组维护啦。

梳理一下，有三点 :
1. 将点离散化。

1. 枚举每一个区间（上面提到的 $x$ 坐标相同的两个点间的点）。

1. 将每个区间组合数的和用树状数组维护。

下面就可以愉快的写代码了。

### 代码：
请勿抄袭
```cpp
#include<bits/stdc++.h>
#define int long long//黑科技（doge 
using namespace std;
const int N=1e5+10;
const int mod=2147483648;
int n,m,w,k,top,ans;//n,m,w,k与题中含义一致，top为树状数组下标上限，ans为答案 
int tr[N];//树状数组 
struct stu{//结构体，存常青树坐标 
	int x,y;
}a[N];
int C[N][15];//组合数 
int sum_x[N],sum_y[N];//x，y坐标上每行常青树的数量，方便判断前后是否满足k 
int sum[N],last[N];//sum为前缀和，last为上一个的值，便于处理区间与维护 
int tmp[N];//记录编号，用于离散化 
inline int read()
{
	register int f=1,s=0;register char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}
	return f*s;
}
inline bool cmp1(stu a1,stu a2){return a1.x<a2.x||(a1.x==a2.x&&a1.y<a2.y);}//按x坐标排序 
inline bool cmp2(stu a1,stu a2){return a1.y<a2.y||(a1.y==a2.y&&a1.x<a2.x);}//按y坐标排序 
inline int lowbit(int x){return x&-x;}//树状数组经典操作 
inline void change(int x,int val)//单点修改 
{
	while(x<=top)
	{
		tr[x]+=val;
		x+=lowbit(x);
	}	
} 
inline int ask(int x)//区间查询 
{
	int num=0;
	while(x)
	{
		num+=tr[x];
		x-=lowbit(x); 
	}
	return num;
}
inline void init()//离散化 
{
	int cnt=0;
	sort(a+1,a+w+1,cmp1);//x坐标离散化 
	for(int i=1;i<=w;i++)
	{
		if(i==1||a[i].x!=a[i-1].x) cnt++;//不相等，新开个编号 
		tmp[i]=cnt;//记录编号 
	}
	for(int i=1;i<=w;i++)
	{
		a[i].x=tmp[i];//赋值为离散化后的编号 
		sum_x[a[i].x]++;//统计该行常青树的数量 
	}
	cnt=0;
	sort(a+1,a+w+1,cmp2);//y坐标离散化,以下部分同上 
	for(int i=1;i<=w;i++)
	{
		if(i==1||a[i].y!=a[i-1].y) cnt++;
		tmp[i]=cnt;
	}
	for(int i=1;i<=w;i++)
	{
		a[i].y=tmp[i];
		sum_y[a[i].y]++; 
	}
}
inline void make_C()//预处理组合数 
{
	C[0][0]=1;
	for(int i=1;i<=w;i++)
	{
		C[i][0]=1;
		for(int j=1;j<=min(i,k);j++) C[i][j]=C[i-1][j-1]+C[i-1][j];//组合数递推公式 
	}
}
signed main()
{
	n=read(),m=read();
	w=read();
	for(int i=1;i<=w;i++)
	{
		a[i].x=read();
		a[i].y=read();
	}
	k=read();
	init();
	make_C();
	top=a[w].y;//树状数组上界即为最大的y坐标 
	sort(a+1,a+w+1,cmp1);//重新按x排序，保证区间连续 
	int tree_sum=0;//区间内树的数量 
	for(int i=1;i<=w;i++)
	{
		if(a[i].x!=a[i-1].x) tree_sum=0;//不相等，新开个区间，输的数量清零 
		tree_sum++;//数增加 
		sum[a[i].y]++;//维护前缀和 
		int val=0;
		if(sum[a[i].y]>=k&&sum_y[a[i].y]-sum[a[i].y]>=k) //两边树的数量都不小于k才能计算 ,这个式子根据数组定义不难理解 
			val=(C[sum[a[i].y]][k]*C[sum_y[a[i].y]-sum[a[i].y]][k])%mod;//调用组合数即可（别忘了取模） 
		change(a[i].y,val-last[a[i].y]);last[a[i].y]=val; //修改（change函数之所以要用val-一下，是因为我写的change函数是加上而不是直接改，根据个人喜好写即可） 
		if(i!=w&&a[i].x==a[i+1].x&&a[i+1].y-a[i].y>1&&tree_sum>=k&&sum_x[a[i].x]-tree_sum>=k)
			//不越界，x坐标为同一区间，y坐标中间有点，两边树都满足（与上面同理，只是坐标换了） 
		{
			ans=(ans+(C[tree_sum][k]*C[sum_x[a[i].x]-tree_sum][k]%mod*(ask(a[i+1].y-1)-ask(a[i].y)))%mod)%mod;//记录答案（就是题解的公式加上取模） 
		} 
	}
	printf("%lld\n",ans);//输出即可 
	return 0;
}
```

希望这篇题解能帮到你。

~~写题解不易，点个赞呗qwq~~

---

## 作者：_ZSR_ (赞：0)

### [P2154 [SDOI2009] 虔诚的墓主人](https://www.luogu.com.cn/problem/P2154)

显然我们的时间复杂度不能跟 $n,m$ 相关，只能跟 $w$ 相关，那么离散化是很容易想到的。

再考虑暴力怎么做。显然是枚举每一个点然后计算它的贡献。又可以发现，如果一个点上面，下面，左边，右边的常青树的个数都大于等于 $k$ 时，这个点对答案才有贡献。因为要枚举，所以肯定要有规律地枚举，不然容易重复或者遗漏。很容易想到，我们可以按列枚举。

对于一列中的相邻两棵常青树，它们中间的点对答案的贡献是 $\sum C^k_{up_i} \times  C^k_{down_i} \times C^k_{left_i} \times C^k_{right_i}$。可以发现，它们中间的每一个点上面和下面的常青树个数都是相同的，那么我们只要统计 $\sum C^k_{left_i} \times C^k_{right_i}$。

根据以上分析，我们要在 $\log$ 级别的时间内修改并统计 $\sum C^k_{left_i} \times C^k_{right_i}$，这应该要借助某种数据结构。先考虑修改。我们发现，每遍历到一棵常青树，当前常青树所在的那一行就要进行修改。因为这一行的常青树右边的点左边都比这一行常青树左边的点左边多了一棵常青树，右边少了一棵常青树。再考虑查询。我们要查询两棵常青树之间的所有点的贡献，相当于是区间查询。也就是说，我们要维护单点修改和区间查询，考虑使用树状数组。

code 
```
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define x first
#define y second
const int N=100010,mod=2147483648;
typedef pair<int,int> pii;
int n,m,w,k,col;
pii a[N];
int tr[N],cntcol[N],cntrow[N],cntb[N],cntv[N];
int c[N][12];
vector<int> numx,numy;
inline int get(int a,int b)
{
	return c[a][b]%mod;
}
inline int getx(int x)
{
	return lower_bound(numx.begin(),numx.end(),x)-numx.begin()+1;
}
inline int gety(int x)
{
	return lower_bound(numy.begin(),numy.end(),x)-numy.begin()+1;
}
inline int lowbit(int x)
{
	return x & -x;
}
inline void add(int x,int k)
{
	for (int i=x;i<=col;i+=lowbit(i)) tr[i]+=k;
}
inline int query(int x)
{
	int res=0;
	for (int i=x;i;i-=lowbit(i)) res+=tr[i];
	return res;
}
signed main()
{
	scanf("%lld%lld",&n,&m);
	scanf("%lld",&w);
	for (int i=1;i<=w;++i) 
	{
		scanf("%lld%lld",&a[i].x,&a[i].y);
		numx.push_back(a[i].x);
		numy.push_back(a[i].y);
	}
	scanf("%lld",&k);
	sort(numx.begin(),numx.end());
	numx.erase(unique(numx.begin(),numx.end()),numx.end());
	sort(numy.begin(),numy.end());
	numy.erase(unique(numy.begin(),numy.end()),numy.end());
	for (int i=1;i<=w;++i)
	{
		a[i].x=getx(a[i].x);
		a[i].y=gety(a[i].y);
		cntrow[a[i].y]++;
		cntcol[a[i].x]++;
	}
	sort(a+1,a+w+1);
	col=(int)numy.size();
	for (int i=0;i<=w;++i) c[i][0]=1;
	for (int i=1;i<=w;++i)
	{
		for (int j=1;j<=min(i,k);++j)
		{
			c[i][j]=c[i-1][j-1]+c[i-1][j];
		}
	}
	int tot=0,ans=0;
	for (int i=1;i<=w;++i)
	{
		if (i==1||a[i].x!=a[i-1].x) tot=0;
		int row=a[i].y;
		int val=(++cntb[row])>=k&&cntrow[row]-cntb[row]>=k?get(cntb[row],k)*get(cntrow[row]-cntb[row],k)%mod:0;
		tot++;
		add(row,val-cntv[row]);
		cntv[row]=val;
		if (i==w||a[i].x!=a[i+1].x||a[i+1].y-a[i].y<=1||tot<k||cntcol[a[i].x]-tot<k) continue;
		ans=(ans+get(tot,k)*get(cntcol[a[i].x]-tot,k)%mod*(query(a[i+1].y-1)-query(a[i].y))%mod)%mod;
	}
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：creation_hy (赞：0)

好久没写了，水一篇题解（

大水题。

按照题目意思列出式子：$\sum C_{up}^kC_{down}^kC_{left}^kC_{right}^k$，四个英文表示对应方向点数。

数据范围没这么大，空行空列显然没有任何意义，直接离散化掉就行了。

枚举空点显然是不行的，考虑我们能枚举哪些东西，只有行、列，和存在的点。

然后发现一段横着连续的空段的左右点数相同，只有上下不同。枚举每行，枚举每段空隙，把左右贡献从式子里提出来，上下用一个树状数组维护和，乘起来就行了。

然后记得给每行的点排序。。。。我因为这个调了好久

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5;
const long long mod = 2147483648;
int n, m, r, c, buc[N], cnt[N], all[N], C[N][11], pre[N];
vector<int> vec[N];
struct node
{
    int x, y;
} a[N];
struct BIT
{
    int t[N];
    inline int lowbit(int x) { return x & -x; }
    inline void add(int x, int k)
    {
        for (; x <= c; x += lowbit(x))
            t[x] += k;
    }
    inline int query(int x)
    {
        int res = 0;
        for (; x; x -= lowbit(x))
            res += t[x];
        return res;
    }
} tr;
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> n >> n;
    for (int i = 1; i <= n; i++)
        cin >> a[i].x >> a[i].y;
    cin >> m;
    for (int i = 1; i <= n; i++)
        buc[++r] = a[i].x;
    sort(buc + 1, buc + 1 + r);
    r = unique(buc + 1, buc + 1 + r) - buc - 1;
    for (int i = 1; i <= n; i++)
        a[i].x = lower_bound(buc + 1, buc + 1 + r, a[i].x) - buc;
    for (int i = 1; i <= n; i++)
        buc[++c] = a[i].y;
    sort(buc + 1, buc + 1 + c);
    c = unique(buc + 1, buc + 1 + c) - buc - 1;
    for (int i = 1; i <= n; i++)
    {
        a[i].y = lower_bound(buc + 1, buc + 1 + c, a[i].y) - buc;
        all[a[i].y]++;
        vec[a[i].x].emplace_back(a[i].y);
    }
    C[0][0] = 1;
    for (int i = 1; i <= n; i++)
    {
        C[i][0] = 1;
        for (int j = 1; j <= m; j++)
            C[i][j] = C[i - 1][j - 1] + C[i - 1][j];
    }
    int ans = 0;
    for (int i = 1; i <= r; i++)
    {
        sort(vec[i].begin(), vec[i].end());
        for (int j = 0; j < vec[i].size(); j++)
        {
            int p = vec[i][j], lst = vec[i][j - 1];
            if (j)
                ans += C[j][m] * C[vec[i].size() - j][m] * (tr.query(p - 1) - tr.query(lst));
            cnt[p]++;
            tr.add(p, C[cnt[p]][m] * C[all[p] - cnt[p]][m] - pre[p]);
            pre[p] = C[cnt[p]][m] * C[all[p] - cnt[p]][m];
        }
    }
    cout << (1ll * ans + mod) % mod;
    return 0;
}
```

---

## 作者：秋日私语 (赞：0)


题目
-

[传送门](https://www.luogu.org/problemnew/show/P2154)

题解
-

我在考场上写的是O(nm)，找到一个空地就分别取上下左右的树的数量分别为a，b，c，d，那么这块 墓地的值就是C[a][k]*C[b][k]*C[c][k]*C[d][k];

![这里写图片描述](https://img-blog.csdn.net/20180326200628597?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FfQ29tbWVfQW1vdXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

思路是没错的，我们考虑怎么使用数据结构优化时间和空间；

首先我们把每棵树按照y为第一关键字，x为第二关键字排序。然后统计每个行和列的树的数量；

从左往右做每一列，假设我们已经找到了在同一列的两棵不相邻的树P和Q，下面求PQ间的墓地的值；对于这些墓地正上方和正下方的组合数都是比较好求的，关键在于如何get到这些墓地左边和右边的值;这就是我们要维护的；

如下图红色区域

![这里写图片描述](https://img-blog.csdn.net/20180326201647489?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FfQ29tbWVfQW1vdXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

注意维护的值的意义：表示在选中当前列的状态下，该行的SUM值；所以我们每次做完一块（一部分）墓地都需要进行修改，假设我们已经做完的点的左边的树的数量为a，右边的树的数量为b，那么修改量就是 C [a+1][k] * C [b][k] - C [a][k] * C[b+1][k];

由上述分析可知，我们需要一种数据结构，资瓷单点修改和区间查询，线段树和树状数组均可；

另外，对于坐标的离散化，递推求组合数，这里不再赘述；

代码
-

点[这里](https://blog.csdn.net/A_Comme_Amour/article/details/79703637)

总结
-

坚决不能把大量时间花在调试上；

这种固定一维来操作另一维的思想；线段树可以不断更新不必使用二维线段树以减少空间

以上

---


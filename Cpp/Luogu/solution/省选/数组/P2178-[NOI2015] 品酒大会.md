# [NOI2015] 品酒大会

## 题目描述

一年一度的“幻影阁夏日品酒大会”隆重开幕了。大会包含品尝和趣味挑战 两个环节，分别向优胜者颁发“首席品酒家”和“首席猎手”两个奖项，吸引了众多品酒师参加。


在大会的晚餐上，调酒师 Rainbow 调制了 $n$ 杯鸡尾酒。这 $n$ 杯鸡尾酒排成一行，其中第 $i$ 杯酒 ($1 \le i \le n$) 被贴上了一个标签 $s_i$ ，每个标签都是 $26$ 个小写 英文字母之一。设 $str(l, r)$ 表示第 $l$ 杯酒到第 $r$ 杯酒的 $r - l + 1$ 个标签顺次连接构成的字符串。若 $str(p, p_0) = str(q, q_0)$，其中 $1 \le p \le p_0 \le n$, $1 \le q \le q_0 \le n$，$p \ne q$，$p_0-p+1 = q_0 - q + 1 = r$ ，则称第 $p$ 杯酒与第 $q$ 杯酒是“ $r$ 相似” 的。当然两杯“$r$ 相似”（$r > 1$）的酒同时也是“$1$ 相似”、“$2$ 相似”、……、“$(r - 1)$ 相似”的。特别地，对于任意的 $1 \le p,q \le n,p \ne q$，第 $p$ 杯酒和第 $q$ 杯酒都 是“$0$ 相似”的。


在品尝环节上，品酒师 Freda 轻松地评定了每一杯酒的美味度，凭借其专业的水准和经验成功夺取了“首席品酒家”的称号，其中第 $i$ 杯酒 ($1 \le i \le n$) 的 美味度为 $a_i$ 。现在 Rainbow 公布了挑战环节的问题：本次大会调制的鸡尾酒有一个特点，如果把第 $p$ 杯酒与第 $q$ 杯酒调兑在一起，将得到一杯美味度为 $a_p\times a_q$ 的酒。现在请各位品酒师分别对于 $r = 0,1,2,\dots,n-1$，统计出有多少种方法可以 选出 $2$ 杯“$r$ 相似”的酒，并回答选择 $2$ 杯“$r$ 相似”的酒调兑可以得到的美味度的最大值。

## 说明/提示

【样例说明 1】

用二元组 $(p, q)$ 表示第 $p$ 杯酒与第 $q$ 杯酒。

$0$ 相似：所有 $45$ 对二元组都是 $0$ 相似的，美味度最大的是 $8 \times 7 = 56$。

$1$ 相似： $(1,8) (2,4) (2,9) (4,9) (5,6) (5,7) (5,10) (6,7) (6,10) (7,10) $，最大的 $8 \times 7 = 56$ 。

$2$ 相似： $(1,8) (4,9) (5,6)$ ，最大的 $4 \times 8 = 32$ 。

没有 $3,4,5,\dots,9$ 相似的两杯酒，故均输出 $0$ 。



 ![](https://cdn.luogu.com.cn/upload/pic/1508.png) 

【时限1s，内存500M】

## 样例 #1

### 输入

```
10
ponoiiipoi
2 1 4 7 4 8 3 6 4 7```

### 输出

```
45 56
10 56
3 32
0 0
0 0
0 0
0 0
0 0
0 0
0 0```

## 样例 #2

### 输入

```
12
abaabaabaaba
1 -2 3 -4 5 -6 7 -8 9 -10 11 -12
```

### 输出

```
66 120
34 120
15 55
12 40
9 27
7 16
5 7
3 -4
2 -4
1 -4
0 0
0 0```

# 题解

## 作者：Nemlit (赞：53)

原题意：有多少个串的$lcp(i, j) >= r$(其中r为1~n中每一个数)

我们先不管第二问，只看第一问

### 第一次转化
首先不难发现一个非常好的性质：对于一个r相似的两杯酒，他们肯定也是r-1相似，r-2相似……

于是，我们考录倒序枚举，於是问题转化成了：有多少个串的$lcp(i, j) == r$(其中r为1~n中每一个数)

### 第二次转化

看到lcp，我们不难想到后缀数组，$lcp(i, j) == r$ 又等价于$min(he[i + 1], he[i + 2], ……, he[j])$

于是我们把问题重新考虑，就转化成了：求出he数组，然后问有多少个数对，满足$i - j$的he的最小值恰好等于r

### 第三次转化

我们把he数组降序排一遍序，然后按照顺序插入

然后我们可以把问题理解成：对于每次插入，我可以连接连续两堆数，然后这两堆数中每一个数值都比r大，所以我们可以把第一堆数的个数和第二堆数的个数相乘，得到的就是这两堆数对答案的贡献

举个例子：

假设我现在的数列长这样（还未被插入的数（即比r小的数）为*）：$5\ 4\ *\ 4\ 5\ 6\ 7\ *\ *\ 4\ *\ 8$

然后我现在要在第三个位置插入一个3

不难发现，一共有$(2 + 1) * (4 + 1) - 1 = 14$种方案（+1是因为3本身也可以算进来， -1是因为$[3, 3]$不能算）

所以这个合并的过程类似于并查集，我们只需要维护一个size就可以求出第一问了

对于第二问，我们只需要维护一个最小值和最大值即可（维护最小值是因为有复数）


代码如下
```
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define re register
#define debug printf("Now is Line : %d\n",__LINE__)
#define file(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
#define int long long
#define inf 1234567890000000000
il int read() {
    re int x = 0, f = 1; re char c = getchar();
    while(c < '0' || c > '9') { if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - 48, c = getchar();
    return x * f;
}
#define rep(i, s, t) for(re int i = s; i <= t; ++ i)
#define drep(i, s, t) for(re int i = t; i >= s; -- i)
#define _ 300005
int n, m, sa[_], rk[_], tp[_], a[_], he[_], val[_], ans1[_], ans2[_], now, num, b[_];
char c[_];
vector<int> q[_];
struct set {int size, mi, ma, fa;}e[_];
il void Qsort() {
	rep(i, 1, m) a[i] = 0;
	rep(i, 1, n) ++ a[rk[i]];
	rep(i, 1, m) a[i] += a[i - 1];
	drep(i, 1, n) sa[a[rk[tp[i]]] --] = tp[i];
}
il void get_sort() {
	for(re int w = 1, p = 0; p < n && w <= n; m = p, p = 0, w <<= 1) {
		rep(i, n - w + 1, n) tp[++ p] = i;
		rep(i, 1, n) if(sa[i] > w) tp[++ p] = sa[i] - w;
		Qsort(), swap(tp, rk), rk[sa[1]] = p = 1;
		rep(i, 2, n) rk[sa[i]] = (tp[sa[i]] == tp[sa[i - 1]] && tp[sa[i] + w] == tp[sa[i - 1] + w]) ? p : ++ p;
	}
}
il void get_height() {
	int j = 0;
	rep(i, 1, n) {
		if(rk[i] == 1) continue;
		if(j) -- j;
		while(c[i + j] == c[sa[rk[i] - 1] + j]) ++ j;
		he[rk[i]] = j;
	}
}
il int find(int x) {
	while(x != e[x].fa) x = e[x].fa = e[e[x].fa].fa;
	return x;
}
il void merge(int a, int b) {
	int x = find(a), y = find(b);
	now += e[x].size * e[y].size, num = max(num, max(e[x].ma * e[y].ma, e[x].mi * e[y].mi));
	e[y].fa = x, e[x].size += e[y].size, e[x].ma = max(e[x].ma, e[y].ma), e[x].mi = min(e[x].mi, e[y].mi);
}
signed main() {
	n = read(), scanf("%s", c + 1), m = 26, num = -inf;
	rep(i, 1, n) b[i] = read(), rk[i] = c[i] - 'a' + 1, tp[i] = i;
	Qsort(), get_sort(), get_height();
	rep(i, 1, n) e[i].fa = i, e[i].size = 1, e[i].ma = e[i].mi = b[sa[i]], q[he[i]].push_back(i);
	drep(i, 0, n - 1) {
		int pax = q[i].size();
		rep(j, 0, pax - 1) merge(q[i][j], q[i][j] - 1);
		if(now) ans1[i] = now, ans2[i] = num;
	}
	rep(i, 0, n - 1) printf("%lld %lld\n", ans1[i], ans2[i]);
	return 0;
}
```

---

## 作者：yybyyb (赞：53)

考虑最裸的暴力

枚举每次的长度

以及两个开始的位置

检查以下是否满足条件，如果可以直接更新答案

复杂度$O(n^3)$

$15～20$分

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<set>
#include<map>
#include<vector>
#include<queue>
using namespace std;
#define ll long long
#define MAX 320000
inline int read()
{
    int x=0,t=1;char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
    if(ch=='-')t=-1,ch=getchar();
    while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
    return x*t;
}
int n;
char s[MAX];
int lg[MAX],v[MAX];
struct SA
{
    int p[20][MAX],a[MAX];
    int x[MAX],y[MAX],t[MAX];
    int SA[MAX],height[MAX],rk[MAX];
    bool cmp(int i,int j,int k){return y[i]==y[j]&&y[i+k]==y[j+k];}
    void init()
        {
            memset(SA,0,sizeof(SA));
            memset(height,0,sizeof(height));
            memset(rk,0,sizeof(rk));
            memset(x,0,sizeof(x));
            memset(y,0,sizeof(y));
            memset(t,0,sizeof(t));
            memset(a,0,sizeof(a));
        }
    void GetSA()
        {
            int m=50;
            for(int i=1;i<=n;++i)t[x[i]=a[i]]++;
            for(int i=1;i<=m;++i)t[i]+=t[i-1];
            for(int i=n;i>=1;--i)SA[t[x[i]]--]=i;
            for(int k=1;k<=n;k<<=1)
            {
                int p=0;
                for(int i=n-k+1;i<=n;++i)y[++p]=i;
                for(int i=1;i<=n;++i)if(SA[i]>k)y[++p]=SA[i]-k;
                for(int i=0;i<=m;++i)t[i]=0;
                for(int i=1;i<=n;++i)t[x[y[i]]]++;
                for(int i=1;i<=m;++i)t[i]+=t[i-1];
                for(int i=n;i>=1;--i)SA[t[x[y[i]]]--]=y[i];
                swap(x,y);
                x[SA[1]]=p=1;
                for(int i=2;i<=n;++i)
                    x[SA[i]]=cmp(SA[i],SA[i-1],k)?p:++p;
                if(p>=n)break;
                m=p;
            }
            for(int i=1;i<=n;++i)rk[SA[i]]=i;
            for(int i=1,j=0;i<=n;++i)
            {
                if(j)--j;
                while(a[i+j]==a[SA[rk[i]-1]+j])++j;
                height[rk[i]]=j;
            }
        }
    void Pre()
        {
            memset(p,63,sizeof(p));
            for(int i=1;i<=n;++i)p[0][i]=height[i];
            for(int j=1;j<20;++j)
                for(int i=1;i<=n;++i)
                    p[j][i]=min(p[j-1][i],p[j-1][i+(1<<(j-1))]);
        }
    int Query(int i,int j)
        {
            return min(p[lg[j-i+1]][i],p[lg[j-i+1]][j-(1<<lg[j-i+1])+1]);
        }
    int lcp(int i,int j)
        {
            int l=min(rk[i],rk[j])+1,r=max(rk[i],rk[j]);
            return Query(l,r);
        }
}SA;
int main()
{
    n=read();
    for(int i=2;i<=n;++i)lg[i]=lg[i>>1]+1;
    scanf("%s",s+1);
    for(int i=1;i<=n;++i)SA.a[i]=s[i]-96;
    SA.GetSA();SA.Pre();
    for(int i=1;i<=n;++i)v[i]=read();
    for(int len=0;len<n;++len)
    {
        ll ans1=0,ans2=-1e18;
        for(int i=1;i<=n;++i)
            for(int j=i+1;j<=n;++j)
            {
                if(SA.lcp(i,j)>=len)
                    ans1++,ans2=max(ans2,1ll*v[i]*v[j]);
            }
        if(ans1)printf("%lld %lld\n",ans1,ans2);
        else
        {
            for(int j=len;j<n;++j)puts("0 0");
            break;
        }
    }
    return 0;
}

```


---

继续考虑，

观察到如果两杯酒是$k$相似的

那么，他们一定是$j(j<=k)$相似的

随意只需要枚举两杯酒

检查他们是多少相似

然后做一个前缀和就好了

复杂度$O(n^2)$

$40$分

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<set>
#include<map>
#include<vector>
#include<queue>
using namespace std;
#define ll long long
#define MAX 320000
inline int read()
{
    int x=0,t=1;char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
    if(ch=='-')t=-1,ch=getchar();
    while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
    return x*t;
}
int n;
char s[MAX];
int lg[MAX],v[MAX];
ll ans1[MAX],ans2[MAX];
struct SA
{
    int p[20][MAX],a[MAX];
    int x[MAX],y[MAX],t[MAX];
    int SA[MAX],height[MAX],rk[MAX];
    bool cmp(int i,int j,int k){return y[i]==y[j]&&y[i+k]==y[j+k];}
    void init()
        {
            memset(SA,0,sizeof(SA));
            memset(height,0,sizeof(height));
            memset(rk,0,sizeof(rk));
            memset(x,0,sizeof(x));
            memset(y,0,sizeof(y));
            memset(t,0,sizeof(t));
            memset(a,0,sizeof(a));
        }
    void GetSA()
        {
            int m=50;
            for(int i=1;i<=n;++i)t[x[i]=a[i]]++;
            for(int i=1;i<=m;++i)t[i]+=t[i-1];
            for(int i=n;i>=1;--i)SA[t[x[i]]--]=i;
            for(int k=1;k<=n;k<<=1)
            {
                int p=0;
                for(int i=n-k+1;i<=n;++i)y[++p]=i;
                for(int i=1;i<=n;++i)if(SA[i]>k)y[++p]=SA[i]-k;
                for(int i=0;i<=m;++i)t[i]=0;
                for(int i=1;i<=n;++i)t[x[y[i]]]++;
                for(int i=1;i<=m;++i)t[i]+=t[i-1];
                for(int i=n;i>=1;--i)SA[t[x[y[i]]]--]=y[i];
                swap(x,y);
                x[SA[1]]=p=1;
                for(int i=2;i<=n;++i)
                    x[SA[i]]=cmp(SA[i],SA[i-1],k)?p:++p;
                if(p>=n)break;
                m=p;
            }
            for(int i=1;i<=n;++i)rk[SA[i]]=i;
            for(int i=1,j=0;i<=n;++i)
            {
                if(j)--j;
                while(a[i+j]==a[SA[rk[i]-1]+j])++j;
                height[rk[i]]=j;
            }
        }
    void Pre()
        {
            memset(p,63,sizeof(p));
            for(int i=1;i<=n;++i)p[0][i]=height[i];
            for(int j=1;j<20;++j)
                for(int i=1;i<=n;++i)
                    p[j][i]=min(p[j-1][i],p[j-1][i+(1<<(j-1))]);
        }
    int Query(int i,int j)
        {
            return min(p[lg[j-i+1]][i],p[lg[j-i+1]][j-(1<<lg[j-i+1])+1]);
        }
    int lcp(int i,int j)
        {
            int l=min(rk[i],rk[j])+1,r=max(rk[i],rk[j]);
            return Query(l,r);
        }
}SA;
int main()
{
    n=read();
    for(int i=2;i<=n;++i)lg[i]=lg[i>>1]+1;
    scanf("%s",s+1);
    for(int i=1;i<=n;++i)SA.a[i]=s[i]-96;
    SA.GetSA();SA.Pre();
    for(int i=1;i<=n;++i)v[i]=read();
    memset(ans2,-63,sizeof(ans2));
    for(int i=1;i<=n;++i)
        for(int j=i+1;j<=n;++j)
        {
            int len=SA.lcp(i,j);
            ans1[0]++;ans1[len+1]--;
            ans2[len]=max(ans2[len],1ll*v[i]*v[j]);
        }
    for(int i=1;i<=n;++i)ans1[i]+=ans1[i-1];
    for(int i=n;i>=0;--i)ans2[i]=max(ans2[i],ans2[i+1]);
    for(int i=0;i<n;++i)printf("%lld %lld\n",ans1[i],!ans1[i]?0:ans2[i]);
    return 0;
}

```

---

如果我们求出$height$数组之后

枚举一个长度$len$，按照$height$分类

如果一段连续的$height$都不小于了$len$

证明这一段都会产生贡献

所以记录这一段产生的贡献，

至于最大值，就在这一段里面记录最大，次大，最小，次小值

拼起来算一下


因为$height$最大值可以很小

所以这样可以过$50$分


```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<set>
#include<map>
#include<vector>
#include<queue>
using namespace std;
#define ll long long
#define MAX 320000
inline int read()
{
    int x=0,t=1;char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
    if(ch=='-')t=-1,ch=getchar();
    while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
    return x*t;
}
int n;
char s[MAX];
int lg[MAX],v[MAX];
ll ans1[MAX],ans2[MAX];
struct SA
{
    int p[20][MAX],a[MAX];
    int x[MAX],y[MAX],t[MAX];
    int SA[MAX],height[MAX],rk[MAX];
    bool cmp(int i,int j,int k){return y[i]==y[j]&&y[i+k]==y[j+k];}
    void init()
        {
            memset(SA,0,sizeof(SA));
            memset(height,0,sizeof(height));
            memset(rk,0,sizeof(rk));
            memset(x,0,sizeof(x));
            memset(y,0,sizeof(y));
            memset(t,0,sizeof(t));
            memset(a,0,sizeof(a));
        }
    void GetSA()
        {
            int m=50;
            for(int i=1;i<=n;++i)t[x[i]=a[i]]++;
            for(int i=1;i<=m;++i)t[i]+=t[i-1];
            for(int i=n;i>=1;--i)SA[t[x[i]]--]=i;
            for(int k=1;k<=n;k<<=1)
            {
                int p=0;
                for(int i=n-k+1;i<=n;++i)y[++p]=i;
                for(int i=1;i<=n;++i)if(SA[i]>k)y[++p]=SA[i]-k;
                for(int i=0;i<=m;++i)t[i]=0;
                for(int i=1;i<=n;++i)t[x[y[i]]]++;
                for(int i=1;i<=m;++i)t[i]+=t[i-1];
                for(int i=n;i>=1;--i)SA[t[x[y[i]]]--]=y[i];
                swap(x,y);
                x[SA[1]]=p=1;
                for(int i=2;i<=n;++i)
                    x[SA[i]]=cmp(SA[i],SA[i-1],k)?p:++p;
                if(p>=n)break;
                m=p;
            }
            for(int i=1;i<=n;++i)rk[SA[i]]=i;
            for(int i=1,j=0;i<=n;++i)
            {
                if(j)--j;
                while(a[i+j]==a[SA[rk[i]-1]+j])++j;
                height[rk[i]]=j;
            }
        }
    void Pre()
        {
            memset(p,63,sizeof(p));
            for(int i=1;i<=n;++i)p[0][i]=height[i];
            for(int j=1;j<20;++j)
                for(int i=1;i<=n;++i)
                    p[j][i]=min(p[j-1][i],p[j-1][i+(1<<(j-1))]);
        }
    int Query(int i,int j)
        {
            return min(p[lg[j-i+1]][i],p[lg[j-i+1]][j-(1<<lg[j-i+1])+1]);
        }
    int lcp(int i,int j)
        {
            int l=min(rk[i],rk[j])+1,r=max(rk[i],rk[j]);
            return Query(l,r);
        }
}SA;
bool cmp(int a,int b){return SA.height[a]>SA.height[b];}
int id[MAX];
void update(int x,int &zd,int &cd,int &zx,int &cx)
{
    if(x>zd)cd=zd,zd=x;
    else if(x>cd)cd=x;
    if(x<zx)cx=zx,zx=x;
    else if(x<cx)cx=x;
}
ll check_max(int zd,int cd,int zx,int cx)
{
    ll ret=-1e18;
    if(zd!=-2e9&&cd!=-2e9)ret=max(ret,1ll*zd*cd);
    if(zx!=+2e9&&cx!=+2e9)ret=max(ret,1ll*zx*cx);
    return ret;
}
int main()
{
    n=read();
    for(int i=2;i<=n;++i)lg[i]=lg[i>>1]+1;
    scanf("%s",s+1);
    for(int i=1;i<=n;++i)SA.a[i]=s[i]-96;
    SA.GetSA();SA.Pre();
    for(int i=1;i<=n;++i)v[i]=read(),id[i]=i;;
    memset(ans2,-63,sizeof(ans2));

    sort(&id[1],&id[n+1],cmp);

    for(int len=0;len<=n;++len)
    {
        int zd,zx,cd,cx,cnt=0;
        zd=cd=-2e9;zx=cx=2e9;
        for(int i=2;i<=n;++i)
        {
            if(SA.height[i]<len)
            {
                ans2[len]=max(ans2[len],check_max(zd,cd,zx,cx));
                zd=cd=-2e9;zx=cx=2e9;
                cnt=0;
            }
            else
            {
                update(v[SA.SA[i]],zd,cd,zx,cx);
                if(!cnt)update(v[SA.SA[i-1]],zd,cd,zx,cx);
                ans1[len]+=cnt;
                if(!cnt)ans1[len]++,cnt++;
                cnt++;
            }
        }
        ans2[len]=max(ans2[len],check_max(zd,cd,zx,cx));
        if(!ans1[len])break;
    }
    for(int i=n;i>=0;--i)ans2[i]=max(ans2[i],ans2[i+1]);
    for(int i=0;i<n;++i)printf("%lld %lld\n",ans1[i],!ans1[i]?0:ans2[i]);
    return 0;
}

```

---

想想上面的东西怎么优化？

我们每次从小往大枚举

如果有一段连续的$height$都大于了$len$

那么，我们在$0..len-1$的时候也都会被枚举一遍


所以，我们考虑从大到小枚举

如果有一段连续的区间，那我们可以直接把他们缩成一个区间

同时记录这个区间的大小，以及最大，最小值


这样的话，每次的枚举可以把一段区间变成一个点


考虑这个思路，也不可能每次扫一边所有的值


所以直接把$height$从大到小排序

每次处理一个$height$就合并两个集合

并且计算产生的贡献

最后求一个后缀和就好

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<set>
#include<map>
#include<vector>
#include<queue>
using namespace std;
#define ll long long
#define MAX 320000
inline int read()
{
    int x=0,t=1;char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
    if(ch=='-')t=-1,ch=getchar();
    while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
    return x*t;
}
int n,v[MAX];
char s[MAX];
ll ans1[MAX],ans2[MAX];
struct SA
{
    int a[MAX];
    int x[MAX],y[MAX],t[MAX];
    int SA[MAX],height[MAX],rk[MAX];
    bool cmp(int i,int j,int k){return y[i]==y[j]&&y[i+k]==y[j+k];}
    void GetSA()
        {
            int m=50;
            for(int i=1;i<=n;++i)t[x[i]=a[i]]++;
            for(int i=1;i<=m;++i)t[i]+=t[i-1];
            for(int i=n;i>=1;--i)SA[t[x[i]]--]=i;
            for(int k=1;k<=n;k<<=1)
            {
                int p=0;
                for(int i=n-k+1;i<=n;++i)y[++p]=i;
                for(int i=1;i<=n;++i)if(SA[i]>k)y[++p]=SA[i]-k;
                for(int i=0;i<=m;++i)t[i]=0;
                for(int i=1;i<=n;++i)t[x[y[i]]]++;
                for(int i=1;i<=m;++i)t[i]+=t[i-1];
                for(int i=n;i>=1;--i)SA[t[x[y[i]]]--]=y[i];
                swap(x,y);
                x[SA[1]]=p=1;
                for(int i=2;i<=n;++i)
                    x[SA[i]]=cmp(SA[i],SA[i-1],k)?p:++p;
                if(p>=n)break;
                m=p;
            }
            for(int i=1;i<=n;++i)rk[SA[i]]=i;
            for(int i=1,j=0;i<=n;++i)
            {
                if(j)--j;
                while(a[i+j]==a[SA[rk[i]-1]+j])++j;
                height[rk[i]]=j;
            }
        }
}SA;
bool cmp(int a,int b){return SA.height[a]>SA.height[b];}
int id[MAX];
int f[MAX],mm[MAX],mi[MAX],size[MAX];
ll ans[MAX];
int getf(int x){return x==f[x]?x:f[x]=getf(f[x]);}
void Merge(int x,int y,int len)
{
    x=getf(x);y=getf(y);
    f[y]=x;
    ans1[len]+=1ll*size[x]*size[y];
    size[x]+=size[y];
    ans[x]=max(ans[x],ans[y]);
    ans[x]=max(ans[x],max(1ll*mm[x]*mm[y],1ll*mi[x]*mi[y]));
    ans[x]=max(ans[x],max(1ll*mm[x]*mi[y],1ll*mi[x]*mm[y]));
    mm[x]=max(mm[x],mm[y]);
    mi[x]=min(mi[x],mi[y]);
    ans2[len]=max(ans2[len],ans[x]);
}
int main()
{
    n=read();
    scanf("%s",s+1);
    for(int i=1;i<=n;++i)SA.a[i]=s[i]-96;
    SA.GetSA();
    for(int i=1;i<=n;++i)v[i]=read(),id[i]=i;;
    for(int i=1;i<=n;++i)f[i]=i,size[i]=1,mm[i]=mi[i]=v[i],ans[i]=-1e18;
    memset(ans2,-63,sizeof(ans2));
    sort(&id[2],&id[n+1],cmp);
    for(int i=2;i<=n;++i)
        Merge(SA.SA[id[i]],SA.SA[id[i]-1],SA.height[id[i]]);
    for(int i=n;i>=0;--i)ans1[i]+=ans1[i+1];
    for(int i=n;i>=0;--i)ans2[i]=max(ans2[i],ans2[i+1]);
    for(int i=0;i<n;++i)printf("%lld %lld\n",ans1[i],!ans1[i]?0:ans2[i]);
    return 0;
}

```

---

## 作者：Refun (赞：24)

罕见的抄了一发题解……毕竟NOI原题哪有那么容易写出来的道理

并没有什么罕见的算法，不过思路还是很巧妙的

一开始我的想法是用单调栈，而且好像的确有这种算法的std，不过我乱搞了一下午样例都没过于是只好作罢

改为大众并查集做法。

首先很容易发现，对于任意一对r相似，它一定是k(0<k<r)相似的 

所以求出height数组后按其中的值排序，然后从大到小做

当前需要处理的串为i和i-1，设前缀长度为k 

易知若将两个并查集合并，则当前的前缀在并查集中一定是最小的，所以Ans[k][0]+=两棵树size的乘积（因为任意两两前缀都是k相似的，可以配对）

除了并查集的size，还维护一下并查集的max和min值，

则Ans[k][1]=max(Ans[k][1],Max1*Max2,Min1*Min2)

维护min值是为了防止有很小的负数这种情况（负负得正） 

最后因为Ans[i]也是满足Ans[i+1]的，所以做个前缀和合并一下答案就好

[代码](http://www.cnblogs.com/refun/p/8679198.html)

---

## 作者：litble (赞：19)

**思路:后缀数组＋单调栈**

我们先计算严格k相似的两瓶酒的答案，所谓严格k相似，就是以这两瓶酒对应的后缀开头（注解：字面意思，一个后缀的开头位置），它们的最长前缀长度正好是k。然后输出答案前从后往前把方案数累计一下，把最大值取max一下即可。

首先后缀数组和Height都处理出来，然后我们知道，对于排名为i和j的两个后缀($i<j$)，它们的lcp就是$Height_i$到$Height_j$之间的最小值

我们按照排名从小到大开始处理。

这个单调栈不是一般的单调栈，里面存的一个元素不是一个后缀开头，而是一个按照排名连续的后缀开头区间。并且我们要顺路维护：

**st**：区间末尾Height值，即如果该区间后面的一个后缀开头要和该区间里任何一个元素搭配，酒都是st相似的。这也是单调栈中要单调的东西。

**sz**:区间元素个数

**mx**:区间最大值

**mi**:区间最小值

既要维护最大值又要维护最小值，是因为负负得正，两个负数的乘积可能是最大值。

然后按排名从大到小处理时，对于后缀开头i,如果$Height_{i+1}$小于$st(top)$，说明再往后的后缀开头和i及栈顶区间的后缀开头搭配的时候，酒不再是$st(top)$相似的，而变成了$Height_{i+1}$相似的了。所以我们计算i与栈顶区间元素搭配的贡献，再将i和栈顶区间合并，栈顶弹出。对于新的栈顶，以此类推......

最后，我们对于还留在栈里的若干区间，从后往前用相似的方法处理一边即可。

具体处理方法有点讲不清楚，看代码work函数吧。

```cpp
#include<bits/stdc++.h>
using namespace std;
int read() {
	int q=0,w=1;char ch=' ';
	while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();
	if(ch=='-') w=-1,ch=getchar();
	while(ch>='0'&&ch<='9') q=q*10+ch-'0',ch=getchar();
	return q*w;
}
#define RI register int
typedef long long LL;
const int N=300005,inf=0x3f3f3f3f;
int n,m;
int v[N],a[N],x[N],y[N],T[N],SA[N],Hei[N];
char s[N];
void Rsort() {
	for(RI i=0;i<=m;++i) T[i]=0;
	for(RI i=1;i<=n;++i) ++T[x[y[i]]];
	for(RI i=1;i<=m;++i) T[i]+=T[i-1];
	for(RI i=n;i>=1;--i) SA[T[x[y[i]]]--]=y[i];
}
int cmp(RI i,RI j,RI num) {return y[i]==y[j]&&y[i+num]==y[j+num];}
void getSA() {
	for(RI i=1;i<=n;++i) a[i]=s[i-1]-'a'+1,x[i]=a[i],y[i]=i;
	m=26,Rsort();
	for(RI km=1,num=1;km<n;num+=num,m=km) {
		km=0;
		for(RI i=n-num+1;i<=n;++i) y[++km]=i;
		for(RI i=1;i<=n;++i) if(SA[i]>num) y[++km]=SA[i]-num;
		Rsort(),swap(x,y),x[SA[1]]=km=1;
		for(RI i=2;i<=n;++i) x[SA[i]]=cmp(SA[i],SA[i-1],num)?km:++km;
	}
}
void getHei() {
	RI lcp=0;
	for(RI i=1;i<=n;++i) {
		if(lcp) --lcp;
		RI j=SA[x[i]-1];
		while(i+lcp<=n&&j+lcp<=n&&a[i+lcp]==a[j+lcp]) ++lcp;
		Hei[x[i]]=lcp;
	}
}
LL ans1[N],ans2[N];int sz[N],mx[N],mi[N],st[N],top;
void work() {
	RI ksz,kmx,kmi;
	for(RI i=1;i<=n;++i) ans2[i]=LLONG_MIN;
	for(RI i=2;i<=n;++i) {
		ksz=1,kmx=kmi=v[SA[i-1]];
		while(top&&st[top]>=Hei[i]) {
			ans1[st[top]]+=1LL*sz[top]*ksz;//方案贡献
			ans2[st[top]]=max(ans2[st[top]],max(1LL*mx[top]*kmx,1LL*mi[top]*kmi));//最大值贡献
			ksz+=sz[top],kmx=max(kmx,mx[top]),kmi=min(kmi,mi[top]);//合并
			--top;
		}
		++top,st[top]=Hei[i],sz[top]=ksz,mi[top]=kmi,mx[top]=kmx;
	}
	ksz=1,kmx=kmi=v[SA[n]];
	for(RI i=top;i>=1;--i) {
		ans1[st[i]]+=1LL*sz[i]*ksz;//方案贡献
		ans2[st[i]]=max(ans2[st[i]],max(1LL*mx[i]*kmx,1LL*mi[i]*kmi));//最大值贡献
		ksz+=sz[i],kmx=max(kmx,mx[i]),kmi=min(kmi,mi[i]);//合并
	}
}
int main()
{
	n=read(),scanf("%s",s);
	for(RI i=1;i<=n;++i) v[i]=read();
	getSA(),getHei(),work();
	for(RI i=n-2;i>=0;--i) ans1[i]+=ans1[i+1],ans2[i]=max(ans2[i],ans2[i+1]);
	for(RI i=0;i<n;++i)
		printf("%lld %lld\n",ans1[i],(ans1[i]==0?0:ans2[i]));
	return 0;
}
```

---

## 作者：Kelin (赞：18)

### 题意

$\forall i\in[0,n)$求有多少对后缀满足$Len(lcp)\ge i$,以及满足条件的两个后缀的权值乘积的最大值

---

### 题解

大于等于可以变成求$Len(lcp)=i$,然后求一遍后缀和,后缀最大值即可

考虑$Len(lcp)$就是这两个后缀在后缀树上的$lca$深度

那么就可以建出后缀树,对于每一个节点$DP$一下,$DP$方法和[差异](https://blog.csdn.net/benoble_/article/details/79643433)一样~~差异这道题真是一道好模板啊~~

至于最大值,因为有负数,就要记录一下当前子树里的最大最小值和次大次小值,然后对于当前节点所对于深度的答案转移就好了

当然,如果这颗子树里后缀节点数目$\lt2$时,是可以直接退掉的

```
#include<bits/stdc++.h>
#define fp(i,a,b) for(register int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(register int i=a,I=b-1;i>I;--i)
#define go(u) for(register int i=fi[u],v=e[i].to;i;v=e[i=e[i].nx].to)
#define file(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
template<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}
template<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}
using namespace std;
char ss[1<<17],*A=ss,*B=ss;
inline char gc(){return A==B&&(B=(A=ss)+fread(ss,1,1<<17,stdin),A==B)?-1:*A++;}
template<class T>inline void sd(T&x){
    char c;T y=1;while(c=gc(),(c<48||57<c)&&c!=-1)if(c==45)y=-1;x=c-48;
    while(c=gc(),47<c&&c<58)x=x*10+c-48;x*=y;
}
inline void gs(char*s){char c;while(c=gc(),c<32);*s++=c;while(c=gc(),c>32)*s++=c;}
char sr[1<<21],z[20];int C=-1,Z;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
template<class T>inline void we(T x){
    if(C>1<<20)Ot();if(x<0)sr[++C]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]=' ';
}
const int N=3e5+5,M=2*N,inf=1e9+7;
typedef long long ll;
typedef int arr[M];
int n,w[N];char s[N];
struct SAM{
    int las,T,ch[M][26];arr fa,len,sz;
    SAM(){las=T=1;}
    inline void ins(int c,int w){
        int p=las,np;fa[np=las=++T]=1,len[np]=len[p]+1;
        for(;p&&!ch[p][c];p=fa[p])ch[p][c]=np;
        mx[T]=mi[T]=w,mx2[T]=-inf,mi2[T]=inf,sz[T]=1;
        if(p){
            int q=ch[p][c],nq;
            if(len[p]+1==len[q])fa[np]=q;
            else{
                nq=++T;mx[T]=mx2[T]=-inf,mi[T]=mi2[T]=inf;
                fa[nq]=fa[q],len[nq]=len[p]+1,memcpy(ch[nq],ch[q],4*26);
                for(fa[np]=fa[q]=nq;ch[p][c]==q;p=fa[p])ch[p][c]=nq;
            }
        }
    }
    struct eg{int nx,to;}e[M];
    int ce;arr fi,mx,mx2,mi,mi2,sx;ll sum[M],ans[M];
    inline void add(int u,int v){e[++ce]=(eg){fi[u],v},fi[u]=ce;}
    inline void ck1(int u,int w){if(w>mx[u])mx2[u]=mx[u],mx[u]=w;else if(w>mx2[u])mx2[u]=w;}
    inline void ck2(int u,int w){if(w<mi[u])mi2[u]=mi[u],mi[u]=w;else if(w<mi2[u])mi2[u]=w;}
    void dfs(int u){
        int siz=0;
        go(u){
            dfs(v);siz+=sz[v];
            ck1(u,mx[v]),ck1(u,mx2[v]);
            ck2(u,mi[v]),ck2(u,mi2[v]);

        }if(siz+sz[u]<2)return;
        cmax(ans[len[u]],max((ll)mx[u]*mx2[u],(ll)mi[u]*mi2[u]));
        go(u)sum[len[u]]+=(ll)sz[u]*sz[v],sz[u]+=sz[v];
    }
    inline void sol(){
    	mx[1]=mx2[1]=-inf,mi[1]=mi2[1]=inf;
        memset(ans,-63,sizeof ans);
        fp(i,2,T)add(fa[i],i);dfs(1);
        fd(i,n-1,0)sum[i]+=sum[i+1],cmax(ans[i],ans[i+1]);
        fp(i,0,n-1)we(sum[i]),we(!sum[i]?0:ans[i]),sr[++C]='\n';
    }
}p;
int main(){
    #ifndef ONLINE_JUDGE
        file("s");
    #endif
    sd(n),gs(s+1);fp(i,1,n)sd(w[i]);
    fd(i,n,1)p.ins(s[i]-'a',w[i]);p.sol();
return Ot(),0;
}
```

---

## 作者：南方不败 (赞：14)

# 题解

更好的阅读体验点击[这里](https://monan2016.github.io/2019/04/20/%E3%80%90BZOJ4199%E3%80%91%E3%80%90NOI2015%E3%80%91%E5%93%81%E9%85%92%E5%A4%A7%E4%BC%9A/)
，请各位大佬到我的blog看看。

## 知识点：

后缀树，后缀数组，LCP，树形DP

## 分析：

这道题是我初学后缀结构的近期训练最后一道练习题，一开始只想到$\Theta(n^2)$的方法和“不存在10相似”的情况。后来看了一年前wj哥哥的slide，才知道真正的做法。

这道题的题意是这样的：我们要求出有多少个子串的LCP大于等于每个$i\in [1,n]$中的$i$，第二问要求出每个组当中$a[i]$值两两乘积中最大的一个是多少（而且$a[i]\in \mathbb Z$，也就是说有可能有非正数）。我们发现直接做LCP大于等于的情况很不好写，所以先考虑求出等于的情况，而第二问也不算核心，直接用一个DP记录一下就好了，可以先放一放。

下面先简介两种方法：

### 方法一：后缀数组

第一问实际上是求有多少个区间$[l,r]使得height[l..r]的最小值为i$，然后我们考虑用并查集维护后缀集合，从$n-1$到$0$枚举每一个可能的后缀长度$i$，在此之前，每个集合内部的任意两个后缀的$LCP$ 都大于$i$。这时假如有两个排名相邻的并且$LCP$ 为$i $的后缀，我们就可以把它们所处的集合合并起来。

具体地，把$height$值从大到小排个序，然后然后把$ans[heght]$的值加上当前合并的两个相邻的集合的大小乘积（因为根据乘法原理，每个区间中，依次枚举左右端点，是有乘积中情况）。然后合并集合。

记录的时候要注意，因为我们合并的时候都是合并排名相邻的一些后缀，所以出现在一个集合中的所有后缀必定是连续的，所以我们只需要记录每个集合的左右端点就可以了。合并的时候也只用更改端点的值就好了。

对于第二问，我们在合并的时候可以把$a[i]$的值也顺路合并（具体方法可见方法二，大同小异）。然后就做完了。

时间复杂度：$\Theta(n\log_2n)$



### 方法二：后缀树

把后缀树建出来之后，我们直观地发现LCP就变成了LCA（两个点的LCA节点在后缀树上对应的节点的长度值就是LCP的长度）。而每个子树下的后缀节点的个数，就是那棵树的贡献。

如图：

![8](https://cdn.luogu.com.cn/upload/pic/57165.png)![8](8.PNG)

对于每个蓝点的子树统计好后缀节点的个数，然后对其LCA（红点）进行统计，然后途中的“len”就是他们LCP的长度（假设从红点往上一直走了很多个节点后到达了整棵后缀树的根节点（黄点），之间的距离（边权之和）就是len）。

具体地，我们可以先建出后缀树。然后进行树形DP（理解为DFS也行）。怎么统计后缀节点的个数呢？这个相当简单，只需要对其子节点的子树信息进行累加就可以了，而我们知道怎么样的节点才可能是后缀节点。在建树的时候，直接加进去的一定是后缀点，通过一条原来很长完整的边（里面包含不止一个字符的）的分裂得到的点，一定不是后缀点，这个在建树的时候判断一下就好了。但是答案一定是这个吗？

当然不是！

回到那幅图，考虑现在在红点统计答案。这时候的单位贡献就是$len$,小学数学告诉我们：$单位贡献\times数量=总共贡献$，所以我们现在统计数量。数量是有多少个后缀节点对（无序的）产生的贡献，考虑对蓝色点标号$1,2,3,\cdots,k$,每个蓝点为子树（包含蓝点，就是说假如蓝点是后缀点，那也算进去）的总共后缀节点数为$v_1,v_2,v_3,\cdots,v_k$,那么对于红点的贡献数量就是$\displaystyle\sum_{i=1}^{k-1}\sum_{j=i+1}^{k}v_i\times v_j$,这样可以保证不重不漏（大家可以把那四个蓝点的情况直接写出来，看一下对不对，我当时推的式子是$v_1\times v_2+v_1\times v_3+v_1\times v_4+v_2\times v_3+v_2\times v_4+v_3\times v_4$),可以发现它我上面给出的双重和式的意义是一样的。

但是这个式子求出来的最大复杂度是$\Theta(n^2)$的，所以一定不可以通过。

考虑对式子进行展开，先对原式$\times2$,然后再$\div2$,

第一步，我们得到$\text{原式}=\frac{\displaystyle\sum_{i=1}^{k}\sum_{j=1\land j\not =i}^{k}v_i\times v_j}{2}$(举例，就是$\frac{v_1\times(v_2+v_3+v_4)+v_2\times(v_1+v_3+v_4)+v_3\times(v_1+v_2+v_4)+v_4\times(v_1+v_2+v_3)}{2}$)

第二步，我们发现这个式子好像差了点什么，所以继续添加项，添加为$v_1\times(v_1+v_2+v_3+v_4)$，在这里我们多加了一个$v_1^2$,所以把它减去。此时假如大家把后面几项也这样拆开，就可发现后面都是$(v_1+v_2+v_3+v_4)$，前面是$v_i\times$后面的那个括号。初中数学告诉我们，我们应该合并同类项，变成$(v_1+v_2+v_3+v_4)^2$,这样，就是非常简便的了。

第三步，对第二步的式子进行化简，写成原式$=\frac{(\displaystyle\sum_{i=1}^{k}{v_i})^2-\displaystyle\sum_{i=1}^{k}{v_i^2}}{2}$

然后这个式子就可以$\Theta(n)$的时间内求出来，可以接受（具体操作就是对于每一个子节点求一次和与一次平方和就好了）。这种推式子的方法好像和很多题解的方法不同，但是本质要求都是一样的。

对于第二问，我们要设法更新$a[i]$的最大值。因为此题中$a[i]$的值是可正可负的，所以就不可以只记录每个节点下的最大和次大值。参照我去年做过的一道环形DP题（【IOI1998】Polygon）中的思想，同时记录下最大和次大与最小和次小值。因为如果最小和次小值是个负数，两者相乘会变成一个正数，这个正数的有可能比最大值和次大值的乘积要大，所以可以用这个来更新答案。

不过千万注意，一定要弄懂其中的逻辑关系。这里计算出来的值（最小次小的乘积，最大次大的乘积）都只是用来更新$ans[len]$的，而合并到父节点（上图的红点）的信息，依旧是原来的最大最小等等的值（就是更新答案的时候一直都是用原来的信息，不是乘积）。所以说，我们一直用原有的信息去更新每一个值，而不是计算后更新。

具体地，初始化一定要做好。把每个后缀节点的初始最大最小值设为$a[i]$，而次大次小分别设成负无穷和正无穷。加入非后缀节点时（分裂节点），把四个值分别设成正负无穷（因为这些节点本来就需要别的点去更新它们，它们自己本来就没有权值）。而什么东西都没有的根节点，也要设成正负无穷。在树形DP的时候，假如我们需要更新父节点$u$的信息，当前枚举到的子节点是$v$，我们就可以把$u$和$v$的最大最小次大次小拿出来，大的排一遍序，取最大那两个更新$u$节点的信息。对于小的值同理，也是拿出来排一遍序，然后取最小的两个放回去。此处经过计算可得，冒泡排序是理论上计算次数相对少的而写起来又很方便的一种排序，每一次更新只用12次的运算（远远小于快排），所以常数会小很多。不过看到有一种可以直接更新的方法，就是分别比较两个最值，然后直接往后更新，感觉这种好像更快，但是当时我觉得写这种好像风险有点大，怕写WA。如果当前的统计完发现整棵子树的大小小于2，那么就可以离开了，因为构不成两两之间的 LCP了，这样没法更新答案（不过子树大小还是要更新的，后面有用）。

最后的求一次后缀和与后缀最大值，就从后面往前更新（因为题目说$r$相似的两个串同时也是$r-i$相似的），所以假如当前的后缀和还是$0$，那么就把最大值也设成$0$（在计算过程中，最大值有可能是一些不可预知的数）。然后注意细节，注意更新的顺序。

时间复杂度：$\Theta(n)$

### 小结：

对比两种不同的方法，其实本质上是相同的。方法一中合并$height$的过程就是模拟了后缀树上两两合并LCA的过程，只不过树形结构更加便于理解和实践。两种方法各有优劣，但是理论复杂度上后缀树会更佳一些。实现上，方法一难在第一问的合并（好像挺难写的），方法二难在第二问的统计$a[i]$的答案和细节调错上，毕竟树形结构难以调试，细节超多。不用后缀自动机解题的原因是，后缀自动机想起来没有后缀树好想，但是实现起来却与后缀树大同小异，还要用$parents$树进行再一次的转化，没有这个必要，毕竟树的性质是比DAG要多的，要更为方便的。

## 代码：

这道题我一共交了四次才AC。我用的是方法二（感觉更好写）。

![3](https://cdn.luogu.com.cn/upload/pic/57166.png)![3](3.PNG)

可以看见其实细节很多。我觉得对于更新第二问的答案时是最为麻烦的。大家千万小心。



```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int maxn=300010;
typedef long long ll;
int n,m,tot,cnt,tp,rt,head[maxn<<1];//注意节点数会变成2n，所以存树的时候也一定要开这么大的空间
ll b[maxn];//这个是题目中给出的a[i]
const ll inf=1000000007;//事实证明INF要开到比1e9大才可以
char s[maxn];
struct node
{
    int fa,p,len,siz;//父亲，当前位置，后缀长度，子树大小
    ll _min1,_max1,_min2,_max2;//最小，最大，次小，次大
    int trans[27];
}a[maxn<<1];
struct data
{
    int nxt,to;
}edge[maxn<<1];//存树，边只用开2n就够了，因为只需要用单向边来存父亲到儿子就好了
struct result
{
    ll sum,val;//后缀节点的对数，最大值
}ans[maxn];//记录答案
#define min(a,b) (a<b?a:b)//最小
#define max(a,b) (a>b?a:b)//最大
#define isdigit(c) (c>=48&&c<=57)//判断是否是数字，用于读入优化
#define swap(a,b) (a^=b^=a^=b)//交换

ll read()
{
    ll x=0,f=1;
    char c=getchar();
    while (!isdigit(c))
        f=c=='-'?-1:1,c=getchar();
    while (isdigit(c))
        x=(x<<1)+(x<<3)+(c^48),c=getchar();
    return x*f;
}

int ins(int u,int p,int c)//建后缀树
{
    int x=++tot,v;
    a[x].len=a[u].len+1;
    a[x].p=p;
    a[x].siz=1;//这一定是后缀点
    a[x]._min1=a[x]._max1=b[p];//注意最小最大赋值成a[i]
    a[x]._min2=inf;//其余赋值成正负无穷
    a[x]._max2=-inf;
    for (;u&&!a[u].trans[c];a[u].trans[c]=x,u=a[u].fa);
    if (!u)
        a[x].fa=rt;
    else
    {
        v=a[u].trans[c];
        if (a[v].len==a[u].len+1)
            a[x].fa=v;
        else
        {
            int w=++tot;
            a[w]=a[v];
            a[w].len=a[u].len+1;
            a[w]._max1=a[w]._max2=-inf;//分裂点没有权值，只能被别人更新，所以初始为正负无穷
            a[w]._min1=a[w]._min2=inf;
            a[w].siz=0;//分裂点一定不是后缀点
            a[v].fa=a[x].fa=w;
            for (;u&&a[u].trans[c]==v;a[u].trans[c]=w,u=a[u].fa);
        }
    }
    return x;
}

void cmp(int u,int v)//用来更新最大最小次大次小值，u是父亲，v是儿子
{
    int i,j;
    ll p[10];
    memset(p,0,sizeof(p));
    p[1]=a[u]._max1;
    p[2]=a[u]._max2;
    p[3]=a[v]._max1;
    p[4]=a[v]._max2;
    for (i=1;i<=3;i++)//冒泡
        for (j=1;j<=4-i;j++)
            if (p[j]<p[j+1])
                swap(p[j],p[j+1]);
    a[u]._max1=p[1];
    a[u]._max2=p[2];
    memset(p,0,sizeof(p));
    p[1]=a[u]._min1;
    p[2]=a[u]._min2;
    p[3]=a[v]._min1;
    p[4]=a[v]._min2;
    for (i=1;i<=3;i++)
        for (j=1;j<=4-i;j++)
            if (p[j]>p[j+1])
                swap(p[j],p[j+1]);
    a[u]._min1=p[1];
    a[u]._min2=p[2];
}

void dfs(int u)//树形DP统计答案
{
    int i,v;
    ll tmp=0;//tmp是每个子树的节点个数的平方之和
    for (i=head[u];i;i=edge[i].nxt)
    {
        v=edge[i].to;
        dfs(v);
        a[u].siz+=a[v].siz;//加上子树大小
        tmp+=(a[v].siz+0ll)*(a[v].siz+0ll);//记录平方和
        cmp(u,v);//统计最大最小值
    }
    if (a[u].siz<2)//构不成LCP就返回
        return; 
    ans[a[u].len].sum+=((a[u].siz+0ll)*(a[u].siz+0ll)-tmp)/2ll;//记录有多少点对
    ans[a[u].len].val=max(ans[a[u].len].val,max((a[u]._max1*a[u]._max2),(a[u]._min1*a[u]._min2)));//记录此处的乘积最大值
}

void add(int u,int v)//把树形结构建立起来
{
    edge[++cnt]=(data){head[u],v};
    head[u]=cnt;
}

int main()
{
    int i,j;
    scanf("%d%s",&n,s+1);
    for (i=1;i<=n;i++)
        b[i]=read();
    rt=tp=++tot;
    for (i=n;i>=1;i--)
    {
        tp=ins(tp,i,s[i]-'a'+1);
        ans[i].val=-(inf*inf);//初始化每个节点，注意是要INF的平方才行（因为这个是乘积）
    }
    for (i=2;i<=tot;i++)
        add(a[i].fa,i);//建边
    a[rt]._min1=a[rt]._min2=inf;
    a[rt]._max1=a[rt]._max2=-inf; //根节点要更新
    dfs(rt);//树形DP
    for (i=n-1;i>=0;i--)//统计后缀和、后缀最大值
    {
        if (ans[i].sum==0)//如果当前为0，那么全都为0
            ans[i].val=0;
        if (i<=n-2&&ans[i+1].sum!=0)//上一个不为0，可以用来更新
            ans[i].val=max(ans[i].val,ans[i+1].val);
        ans[i].sum+=ans[i+1].sum;//更新和
    }
    for (i=0;i<=n-1;i++)
        printf("%lld %lld\n",ans[i].sum,ans[i].val);
    return 0;
}
```

然后我又交到的UOJ上，发现被人Hack掉了。

```cpp
in：
2
aa
1000000000 -1000000000
    
out：
1 -1000000000000000000
1 -1000000000000000000
```

这样的数据可以慢慢调，总能搞好的。



## 总结：

这是我人生第一道洛谷黑题啊！

虽然用了一天去写，但也感觉很值得。

思路很有趣，很多的实现细节也很有价值。

---

## 作者：attack (赞：8)

说一个后缀自动机+线段树的无脑做法

首先建出SAM，然后对parent树进行dp，维护最大次大值，最小次小值

显然一个串能更新答案的区间是$[len_{fa_{x}} + 1, len_x]$，方案数就相当于是从$siz_x$里面选两个，也就是$\frac{siz_x  (siz_x - 1)}{2}$

直接拿线段树维护一下，标记永久化一下炒鸡好写~

```cpp
#include<bits/stdc++.h>
#define int long long 
#define LL long long 
using namespace std;
const int MAXN = 1e6 + 10;
const LL INF = 2e18 + 10;
template <typename A, typename B> inline bool chmin(A &a, B b){if(a > b) {a = b; return 1;} return 0;}
template <typename A, typename B> inline bool chmax(A &a, B b){if(a < b) {a = b; return 1;} return 0;}
inline int read() {
    char c = getchar(); int x = 0, f = 1;
    while(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
    return x * f;
}
int N, a[MAXN];
char s[MAXN];
int root = 1, tot = 1, las = 1, ch[MAXN][26], fa[MAXN], len[MAXN], rev[MAXN];
LL mx[MAXN], mx2[MAXN], ans[MAXN], ans1[MAXN], mn[MAXN], mn2[MAXN], tmp[MAXN], siz[MAXN];
vector<int> v[MAXN];
void insert(int x, int id) {
	int now = ++tot, pre = las; las = now; siz[now] = 1; len[now] = len[pre] + 1; mx[now] = a[id]; mx2[now] = -INF; mn[now] = a[id]; mn2[now] = INF; rev[id] = now;
	for(; pre && !ch[pre][x]; pre = fa[pre]) ch[pre][x] = now;
	if(!pre) {fa[now] = root; return ;}
	int q = ch[pre][x];
	if(len[pre] + 1 == len[q]) fa[now] = q;
	else {
		int nq = ++tot; fa[nq] = fa[q]; len[nq] = len[pre] + 1; 
		memcpy(ch[nq], ch[q], sizeof(ch[q]));
		fa[now] = fa[q] = nq;
		for(; pre && ch[pre][x] == q; pre = fa[pre]) ch[pre][x] = nq;
	}
}
void BuildDAG() {
	for(int i = 1; i <= tot; i++) assert(fa[i] != i), v[fa[i]].push_back(i);
}

int rt, Node, ls[MAXN], rs[MAXN], ad[MAXN], si[MAXN];
LL sum[MAXN], tag[MAXN];
void Build(int &k, int l, int r) {
	if(!k) k = ++Node, tag[k] = -INF, si[k] = r - l + 1;
	if(l == r) return ;
	int mid = l + r >> 1;
	Build(ls[k], l, mid);
	Build(rs[k], mid + 1, r);
}
void IntMax(int k, int l, int r, int ql, int qr, LL v) {
	if(ql <= l && r <= qr) {chmax(tag[k], v); return ;	}
	int mid = l + r >> 1;
	if(ql <= mid) IntMax(ls[k], l, mid, ql, qr, v);
	if(qr  > mid) IntMax(rs[k], mid + 1, r, ql, qr, v);
}
void IntAdd(int k, int l, int r, int ql, int qr, LL v) {
	if(ql <= l && r <= qr) {sum[k] += v; return ;}
	int mid = l + r >> 1;
	if(ql <= mid) IntAdd(ls[k], l, mid, ql, qr, v);
	if(qr  > mid) IntAdd(rs[k], mid + 1, r, ql, qr, v);
}
LL QueryNum(int k, int l, int r, int pos) {
	if(!k) return 0;
	LL now = sum[k];
	if(l == r || !k) return now;
	int mid = l + r >> 1;
	if(pos <= mid) now += QueryNum(ls[k], l, mid, pos);
	else now += QueryNum(rs[k], mid + 1, r, pos);
	return now;
}
LL QueryMax(int k, int l, int r, int pos) {
	if(!k) return -INF;
	LL now = tag[k];
	if(l == r || !k) return now;
	int mid = l + r >> 1;
	if(pos <= mid) chmax(now, QueryMax(ls[k], l, mid, pos));
	else chmax(now, QueryMax(rs[k], mid + 1, r, pos));
	return now;
}
void dfs(int x) {
	for(auto &to : v[x]) {
		dfs(to);
		siz[x] += siz[to];
		if(mx2[to] > mx[x]) chmax(mx2[x], mx[x]), mx[x] = mx2[to];
		else chmax(mx2[x], mx2[to]);
		if(mx[to] > mx[x]) chmax(mx2[x], mx[x]), mx[x] = mx[to];
		else chmax(mx2[x], mx[to]);
		
		if(mn2[to] < mn[x]) chmin(mn2[x], mn[x]), mn[x] = mn2[to];
		else chmin(mn2[x], mn2[to]);
		if(mn[to] < mn[x]) chmin(mn2[x], mn[x]), mn[x] = mn[to];
		else chmin(mn2[x], mn[to]); 
	}
	if(siz[x] > 1 && x != root) {
		IntMax(rt, 1, N, len[fa[x]] + 1, len[x], mx[x] * mx2[x]);
		IntMax(rt, 1, N, len[fa[x]] + 1, len[x], mn[x] * mn2[x]);
		
		IntAdd(rt, 1, N, len[fa[x]] + 1, len[x], 1ll * siz[x] * (siz[x] - 1) / 2);
	}
}

signed main() {
	N = read();
	Build(rt, 1, N);
	scanf("%s", s + 1);
	reverse(s + 1, s + N + 1);
	for(int i = 1; i <= N; i++) tmp[i] = a[i] = read(), assert(a[i] != 0);
	reverse(a + 1, a + N + 1);
	for(int i = 1; i <= N; i++) insert(s[i] - 'a', i);
	for(int i = 1; i <= tot; i++) {
		ans[i] = -INF;
 		if(!mx[i]) mx[i] = -INF;
		if(!mx2[i]) mx2[i] = -INF;
		if(!mn[i]) mn[i] = INF;
		if(!mn2[i]) mn2[i] = INF;	
	}
	BuildDAG();
 	dfs(1);
 	for(int i = 1; i < N; i++) {
		ans1[i] = QueryNum(root, 1, N, i);
		ans[i] = QueryMax(root, 1, N, i);
		
	}
	sort(tmp + 1, tmp + N + 1, greater<int>());
	cout << 1ll * N * (N - 1) / 2 << " " << max(tmp[1] * tmp[2], tmp[N] * tmp[N - 1]) << '\n';
 	for(int i = 1; i < N; i++) cout << ans1[i] <<  " " << (ans[i] <= -INF ? 0 : ans[i]) << '\n';
    return 0;
}
/*
2
aa
-100000000 100000000
12
abaabaabaaba
1 -2 3 -4 5 -6 7 -8 9 -10 11 -12
*/
```

---

## 作者：2018ljw (赞：6)

提供一个切入点不同的后缀数组做法。

- 事先声明：由于我需要利用 $r$ 表示区间右端点，所以题目中的 $r$ 相似在本文中均表示为 $k$ 相似

首先考虑，假设我们知道一些后缀是两两 $k$ 相似的，并且我们将其全部放在区间 $[l,r]$ 内，能对答案产生多少贡献。

显然，对于方案数，其贡献为 $C_{r-l+1}^2$；对于美味度，其贡献为这个区间里最大美味度。最大美味度可能是区间最大与次大的乘积，也可能是区间最小与次小的乘积。

而找到两两 $k$ 相似我们可以利用后缀数组，构造出 $height$ 和 $sa$ 数组，同时实现了将两两 $k$ 相似的串放在了一个区间中。这一部分不会的出门右转[模板题](https://www.luogu.com.cn/problem/P3809)。

那么我们可以使用线段树，维护区间最大值、次大值、最小值、次小值。即可在区间已知的情况下 $O(\log n)$ 统计贡献。其中线段树的下标基于后缀数组。

```cpp
tree merge(tree x,tree y){
	if(y.maxn>x.maxn)x.smax=x.maxn,x.maxn=y.maxn;
	else if(y.maxn>x.smax)x.smax=y.maxn;
	if(y.smax>x.maxn)x.smax=x.maxn,x.maxn=y.smax;
	else if(y.smax>x.smax)x.smax=y.smax;
	if(y.minn<x.minn)x.smin=x.minn,x.minn=y.minn;
	else if(y.minn<x.smin)x.smin=y.minn;
	if(y.smin<x.minn)x.smin=x.minn,x.minn=y.smin;
	else if(y.smin<x.smin)x.smin=y.smin;
	return x;
}
```

现在考虑第二个问题：找区间+统计答案

后缀数组有一个比较常见的策略，即基于 $height$ 分组。我们枚举当前要找 $k$ 相似的 $k$，那么根据 $k$ 对 $height$ 分组，使得每组 $[l,r]$ 满足 $height_{r+1}<k$ 且 $height_{l+1\dots r}\ge k$。那么显然，每一组都是一段极长的 $k$ 相似区间。配合线段树统计答案。

复杂度：枚举长度 $O(n)$，分组 $O(n)$，查询 $O(\log n)$，总复杂度 $O(n^2\log n)$。考虑进一步优化。

很多题解到这里选择倒序枚举、合并区间，但毕竟咱不一定能想到嘛，所以我们仍然**顺序枚举、分裂区间**。

考虑我们的复杂度瓶颈在哪里。那么分组和枚举的复杂度至少要抠掉一个。

发现一个比较显然的性质：

- 若区间 $[l,r]$ 是 $k$ 相似的，且后缀 $p$ 不在其中，那么这个区间的 $k+1$ 相似，$p$ 一定不在其中。

很好理解，这个基于后缀数组的定义，或者 $k$ 相似的定义都可以证。

这个性质告诉我们：找到一个区间后，不用考虑区间外的数对这个区间分组的影响了。

这是一个很有启发性的结论。那么考虑如何对一个区间重分组。

- 性质：从 $k$ 相似到 $k+1$ 相似，区间 $[l,r]$ 要么不变，要么被分成多段，且每段起始位置 $t$ 满足 $t=l$ 或 $height_t=k$。

这个可以根据分组定义直接证得。

根据这两个性质，我们可以得到一种高效的重分组方式：

- 假设区间 $[l,r]$ 是 $k$ 相似的，那么我们找到 $[l+1,r]$ 中所有 $height=k$ 的位置，外加 $l$ 和 $r$，将整个区间分段，处理每一段的 $k+1$ 相似问题。

- $l=r$ 怎么办？ 这时已经选不出两杯酒，所以直接结束就好。

现在考虑如何找到区间内所有 $height=k$ 的位置。比较直接的想法是直接在桶里去二分找，或者用 $set$ 维护位置。当然都可以，不过本人一时脑抽，写了个平衡树。

我们对每个 $height$ 值开一个平衡树，查找时相当于找到上一个断点的后继位置，直到找不到下一个后继或者下一个后继位置超过 $r$。由于每个位置 $height$ 唯一，且至多会在一个区间内被询问。所以每个位置最多成为一次查询前驱的答案。总复杂度 $O(n\log n)$，均摊为单次 $O(\log n)$。

此外，我们舍弃无法切割的继承，每次直接找到下一个会产生新的切割区间的相似度进行转移。这一段的区间相同，贡献一定相同，放在答案区间上等同于区间加和区间取 $\max$。这一部分可以利用差分，也可以利用线段树。代码里是线段树做法。

至于找到下一个切分点，其实就是 $\min\{height_{l+1\dots r}\}+1$。直接上 $ST$ 表就可。

这样划分区间的复杂度看似很玄学，但是可以证明是 $O(n)$ 级别的！

证明：考虑每个区间。长度上升时，要么新区间直接继承，要么区间被切割成若干段。结束的情况有两种，即 $n$ 相似和长度为 $1$，由于 $height\le n-1$，所以这两种情况本质相同。因为继承已经被我们统一处理了，所以只考虑切割。每次转移必定产生区间切割，并且一个位置至多被切 $1$ 次，所以我们恰好切了 $n-1$ 次，即产生至多 $n-1$ 次有效转移。所以有效区间个数为 $O(n)$ 级别。

对每个区间处理单次复杂度 $O(\log n)$，总复杂度 $O(n\log n)$。

对于边界细节，很多题解都有强调，如各类初值 $\pm 10^{18}$ 之类。

此外，考虑到标记永久化比标记下放好写，所以我对答案线段树采用标记永久化的方式统计答案。

因为同时用了三棵树，所以代码可能略长。在必要的地方添加注释了。
```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<ctime>
const int inf=1<<30;
const long long inff=1ll<<60;
using namespace std;
struct treap{
	int son[2],val;
	long long key;
}trp[500001];
struct tree{
	long long maxn,smax;
	long long minn,smin;
	//smax/min 表示次大/次小值。
}tre[4000001];
struct ans{
	long long tag,rev;
	//tag 维护方案数询问，rev 维护最值询问。
}tr[4000001];
int root[400001],size;
//每个 root 代表 height 的一种取值，平衡树内维护下标。
//treap 部分
void rotate(int &k,int fx){
	int x=trp[k].son[fx^1];
	trp[k].son[fx^1]=trp[x].son[fx];
	trp[x].son[fx]=k;
	k=x;
}
void insert(int &k,int val){
	if(!k){
		k=++size;
		trp[k].key=rand();
		trp[k].val=val;
		return;
	}
	if(trp[k].val==val)return;
	else if(trp[k].val>val){
		insert(trp[k].son[0],val);
		if(trp[k].key<trp[trp[k].son[0]].key)rotate(k,1);
	}
	else{
		insert(trp[k].son[1],val);
		if(trp[k].key<trp[trp[k].son[1]].key)rotate(k,0);
	}
}
int qlas(int id,int val){
	int x=root[id],res=0;
	while(x){
		if(trp[x].val<=val)x=trp[x].son[1];
		else res=trp[x].val,x=trp[x].son[0];
	}
	return res;
}
//后缀数组全家桶
int n,sa[500001],rk[500001],height[500001];
int tsa[500001],trk[1000001],cnt[500001];
int a[500001],st[500001][20],lg[500001];
char s[500001];
long long max(long long x,long long y){
	return x>y?x:y;
}
long long min(long long x,long long y){
	return x<y?x:y;
}
int qmin(int l,int r){
	int k=lg[r-l+1];
	return min(st[l][k],st[r-(1<<k)+1][k]);
}
tree merge(tree x,tree y){
	if(y.maxn>x.maxn)x.smax=x.maxn,x.maxn=y.maxn;
	else if(y.maxn>x.smax)x.smax=y.maxn;
	if(y.smax>x.maxn)x.smax=x.maxn,x.maxn=y.smax;
	else if(y.smax>x.smax)x.smax=y.smax;
	if(y.minn<x.minn)x.smin=x.minn,x.minn=y.minn;
	else if(y.minn<x.smin)x.smin=y.minn;
	if(y.smin<x.minn)x.smin=x.minn,x.minn=y.smin;
	else if(y.smin<x.smin)x.smin=y.smin;
	return x;
}
void build(int k,int l,int r){
	tre[k].maxn=tre[k].smax=-inf;
	tre[k].minn=tre[k].smin=inf;
	tr[k].rev=-inff;
	//不处理 0 相似答案很大一个原因就是两个线段树的结构相同，可以少打一个 build
	if(l==r){
		tre[k].maxn=tre[k].minn=a[sa[l]];
		return;
	}
	int mid=l+r>>1;
	build(k<<1,l,mid);
	build(k<<1|1,mid+1,r);
	tre[k]=merge(tre[k<<1],tre[k<<1|1]);
}
tree query(int k,int l,int r,int x,int y){
	//这四个查询会相互影响，不方便单独查询。
	//所以我们直接把区间对应的线段树提取出来。
	if(l>=x&&r<=y)return tre[k];
	int mid=l+r>>1;
	if(mid>=y)return query(k<<1,l,mid,x,y);
	if(x>mid)return query(k<<1|1,mid+1,r,x,y);
	return merge(query(k<<1,l,mid,x,y),query(k<<1|1,mid+1,r,x,y));
}
void modify(int k,int l,int r,int x,int y,long long w1,long long w2){
	//对答案线段树的更新，w1 是方案，w2 是最值
	if(l>=x&&r<=y){
		tr[k].tag+=w1;
		tr[k].rev=max(tr[k].rev,w2);
		return;
	}
	int mid=l+r>>1;
	if(x<=mid)modify(k<<1,l,mid,x,y,w1,w2);
	if(mid<y)modify(k<<1|1,mid+1,r,x,y,w1,w2);
}
long long qmax(int k,int l,int r,int x){
	if(l==r)return tr[k].rev;
	int mid=l+r>>1;
	long long res=tr[k].rev;
	if(x<=mid)res=max(res,qmax(k<<1,l,mid,x));
	else res=max(res,qmax(k<<1|1,mid+1,r,x));
	return res;
}
long long qsum(int k,int l,int r,int x){
	if(l==r)return tr[k].tag;
	int mid=l+r>>1;
	long long res=tr[k].tag;
	if(x<=mid)res+=qsum(k<<1,l,mid,x);
	else res+=qsum(k<<1|1,mid+1,r,x);
	return res;
}
void solve(int l,int r,int minx){
	//主体部分。表示当前处理区间 [l,r] 是 minx 相似的。
	if(l>=r||minx==n)return;
	tree rst=query(1,1,n,l,r);
	int nxt=qmin(l+1,r);
	//直接找到下一个切点长度
	long long res=max(rst.maxn*rst.smax,rst.minn*rst.smin),as=1ll*(r-l+1)*(r-l)/2;
	if(minx)modify(1,1,n,minx,nxt,as,res);
	//对 0 相似单独解决原因见 build 函数。
	//0 相似是整个区间，可以 O(1) 解决。
	int ps=l;
	while(ps<=r){
		int t=qlas(nxt,ps);
		if(!t||t>r)t=r+1;
		solve(ps,t-1,nxt+1);
		ps=t;
	}
}
int main(){
	srand((unsigned)time(NULL));
	int i,j;
	scanf("%d%s",&n,s+1);
	for(i=1;i<=n;i++)scanf("%d",&a[i]);
	for(i=1;i<=n;i++)rk[i]=s[i]-'a'+1,cnt[rk[i]]++;;
	for(i=1;i<=26;i++)cnt[i]+=cnt[i-1];
	for(i=n;i;i--)sa[cnt[rk[i]]--]=i;
	for(i=1;i<=n;i++){
		if(s[sa[i]]==s[sa[i-1]])rk[sa[i]]=rk[sa[i-1]];
		else rk[sa[i]]=rk[sa[i-1]]+1;
	}
	for(j=1;j<n;j*=2){
		memcpy(tsa,sa,sizeof(sa));
		memcpy(trk,rk,sizeof(rk));
		int tot=0;
		for(i=n;i>n-j;i--)sa[++tot]=i;
		for(i=1;i<=n;i++)if(tsa[i]>j)sa[++tot]=tsa[i]-j;
		for(i=1;i<=n;i++)rk[i]=trk[sa[i]];
		memset(cnt,0,sizeof(cnt));
		for(i=1;i<=n;i++)cnt[rk[i]]++;
		for(i=1;i<=n;i++)cnt[i]+=cnt[i-1];
		for(i=n;i;i--)tsa[cnt[rk[i]]--]=sa[i];
		memcpy(sa,tsa,sizeof(sa));
		for(i=1;i<=n;i++){
			if(trk[sa[i]]==trk[sa[i-1]]&&trk[sa[i]+j]==trk[sa[i-1]+j])rk[sa[i]]=rk[sa[i-1]];
			else rk[sa[i]]=rk[sa[i-1]]+1;
		}
		if(rk[sa[n]]==n){
			for(i=1;i<=n;i++)sa[rk[i]]=i;
			break;
		}
	}
	int len=0;
	for(i=1;i<=n;i++){
		if(len)len--;
		while(s[i+len]==s[sa[rk[i]-1]+len])len++;
		height[rk[i]]=len;
	}
	for(i=1;i<=n;i++)insert(root[height[i]],i);
	for(i=1;i<=n;i++)st[i][0]=height[i];
	for(i=2;i<=n;i++)lg[i]=lg[i/2]+1;
	for(i=1;i<=lg[n];i++)for(j=1;j+(1<<i)-1<=n;j++)st[j][i]=min(st[j][i-1],st[j+(1<<i-1)][i-1]);
	build(1,1,n);
	solve(1,n,0);
	tree ss=query(1,1,n,1,n);
	printf("%lld %lld\n",1ll*n*(n-1)/2,max(ss.maxn*ss.smax,ss.minn*ss.smin));
	for(i=1;i<n;i++){
		long long num=qsum(1,1,n,i);
		printf("%lld %lld\n",num,num?qmax(1,1,n,i):0);
		//有方案，我们输出方案；没有方案，我们输出约定的 0
	}
}
```

---

## 作者：Mihari (赞：6)

# 题目

[传送门](https://www.luogu.com.cn/problem/P2178)

# 题解

首先将问题转化为求 $\text{Len}(lcp)=i$ 的有多少，然后对于第一个询问求后缀和，对于第二个询问求后缀最大.

对于 $\tt SAM$ 有个性质：对于 $S$ 中的两个子串，找到它们所属的点 $u,\;v$，那么他们的**最长公共后缀**就是 $\text{longest}(LCA(u,v))$，其中 $LCA(u,v)$ 定义在 $\text{parent tree}$ 上.

证明略，对于这道题，由于我们要求的是前缀，刚好和性质相反，那么我们考虑把串倒着建 $\tt SAM$，对于这个 $\tt SAM$ 得到的 $\text{parent tree}$ 的每个点，他们的子树之内所有的点相互匹配，都可以得到刚刚好 $\text{Len}(lcp)=i$ 的组合，在树上做 $DP$（其实不能算 $DP$）就可以了.

# 代码

```cpp
# include <bits/stdc++.h>
using namespace std;
namespace Elaina{
    # define rep(i,l,r) for(int i=l, i##_end_ = r; i <= i##_end_; ++ i)
    # define fep(i,l,r) for(int i=l, i##_end_ = r; i >= i##_end_; -- i)
    # define fi first
    # define se second
    # define Endl putchar('\n')
    # define writc(x, c) fwrit(x), putchar(c)
    // # define int long long
    typedef long long ll;
    typedef pair<int, int> pii;
    typedef unsigned long long ull;
    typedef unsigned int uint;
    template<class T>inline T Max(const T x, const T y){return x < y ? y : x;}
    template<class T>inline T Min(const T x, const T y){return x < y ? x : y;}
    template<class T>inline T fab(const T x){return x < 0 ? -x : x;}
    template<class T>inline void getMax(T& x, const T y){x = Max(x, y);}
    template<class T>inline void getMin(T& x, const T y){x = Min(x, y);}
    template<class T>T gcd(const T x, const T y){return y ? gcd(y, x % y) : x;}
    template<class T>inline T readin(T x){
        x=0; int f = 0; char c;
        while((c = getchar()) < '0' || '9' < c) if(c == '-') f = 1;
        for(x = (c ^ 48); '0' <= (c = getchar()) && c <= '9'; x = (x << 1) + (x << 3) + (c ^ 48));
        return f ? -x : x;
    }
    template<class T>void fwrit(const T x){
        if(x < 0)return putchar('-'), fwrit(-x);
        if(x > 9)fwrit(x / 10); putchar(x % 10 ^ 48);
    }
}
using namespace Elaina;

const int maxn = 3e5;
const ll inf = (1ll << 60);

int tre[maxn * 2 + 5][26];
int fa[maxn * 2 + 5];
int len[maxn * 2 + 5];
int sz[maxn * 2 + 5];
ll mx[maxn * 2 + 5], mn[maxn * 2 + 5];
int lst = 1, cnt = 1;
inline void add(const int c, const int w){
    int p = lst;
    int u = lst = ++ cnt;
    len[u] = len[p] + 1, sz[u] = 1;
    mx[u] = mn[u] = w;
    for(; p && !tre[p][c]; p = fa[p]) tre[p][c] = u;
    if(!p) fa[u] = 1;
    else{
        int q = tre[p][c];
        if(len[q] == len[p] + 1) fa[u] = q;
        else{
            int nq = ++ cnt;
            mx[nq] = -inf, mn[nq] = inf;
            rep(i, 0, 25) tre[nq][i] = tre[q][i];
            fa[nq] = fa[q], len[nq] = len[p] + 1;
            fa[q] = fa[u] = nq;
            for(; p && tre[p][c] == q; p = fa[p])
                tre[p][c] = nq;
        }
    }
}

struct edge{int to,nxt;
    edge(const int T = 0, const int N = 0) : to(T), nxt(N){}
}e[maxn * 2 + 5];
int tail[maxn * 2 + 5], ecnt;
inline void add_edge(const int u, const int v){
    // printf("u == %d, v == %d\n", u, v);
    e[++ ecnt] = edge(v, tail[u]); tail[u] = ecnt;
}

char s[maxn + 5];
int a[maxn + 5], n;

inline void init(){
    n = readin(1); scanf("%s", s + 1);
    rep(i, 1, n) a[i] = readin(1);
}

// the first query, the count of appearance
ll ans1[maxn + 5];
// the second query, the maximum value to match
ll ans2[maxn + 5];

inline int check(const int u){
    return mx[u] != -inf && mn[u] != inf;
}

void dfs(const int u){
    if(!mx[u]) mx[u] = -inf, mn[u] = inf;
    for(int i = tail[u], v; i; i = e[i].nxt){
        dfs(v = e[i].to);
        ans1[len[u]] += 1ll * sz[u] * sz[v];
        sz[u] += sz[v];
        if(check(u))
            ans2[len[u]] = Max(ans2[len[u]], Max(1ll * mx[u] * mx[v], 1ll * mn[u] * mn[v]));
        mx[u] = Max(mx[u], mx[v]), mn[u] = Min(mn[u], mn[v]);
    }
}

signed main(){
    init();
    fep(i, n, 1) add(s[i] - 'a', a[i]);
    rep(i, 2, cnt) add_edge(fa[i], i);
    rep(i, 0, n + 1) ans2[i] = -inf;
    dfs(1);
    fep(i, n - 1, 0) ans2[i] = Max(ans2[i], ans2[i + 1]), ans1[i] += ans1[i + 1];
    rep(i, 0, n - 1) printf("%lld %lld\n", ans1[i], ans1[i] == 0 ? 0 : ans2[i]);
    return 0;
}
```

# 本题关键

$\tt SAM$ 的性质，对于 $S$ 中的两个子串，找到它们所属的点 $u,\;v$，那么他们的**最长公共后缀**就是 $\text{longest}(LCA(u,v))$，其中 $LCA(u,v)$ 定义在 $\text{parent tree}$ 上.

---

## 作者：yjqqqaq (赞：6)

这道题楼下给了一种O（N）的做法，让我们来YY一种同样O（N）但没有后缀树的做法。

所谓的“r相似”其实指的是两个位置的LCP长度>=r，联系到后缀数组，转化成两个位置在hei数组所夹的一段区间>=r，如何在hei数组上统计是一个经典问题，可以用单调栈或者并查集做到O（N）（并查集虽然不是严格意义下的O（N），但由于反阿克曼函数增长缓慢，可以看做O（N ））

考虑后缀数组，可以用DC3做到O（N），剩下的也很可做，所以就是O（N），不用后缀自动机或者后缀树，也可以用string


---

## 作者：Treeloveswater (赞：5)

作为一个提高组的蒟蒻【划掉】、刚学了后缀数组的蒟蒻【划掉】来做这道题确实有点恶心……做了整整7个h才A掉。

不会后缀自动机、没听说过后缀树、只会后缀数组板子——怎么办？

因为后缀数组构建是nlogn我无法优化，所以真正要搞的地方是查询的地方。

N方暴力查询？太天真。

实际上我们可以O（n）查询的。

首先要明白一点：

我们假设height数组上第i个点的值是R，那么从i点开始扩展（想象一下一滴水的扩展），直到遇到比他小的地方就停下，那么现在扩展的这个区间里的所以数都满足相似度为R。那我们只需要知道这个区间里的Rank1和Rank2即可。我们先将height数组用其他数组进行排序，从大到小开始扩展。因为我们的顺序是从大到小，所以在扩展A点时，所遇到的所有已扩展过的区间我们是可以直接合并的，因为这个区间的height值一定大于A的height值（想一想为什么？）。

对于方案数的计算，那就是简单的组合数。因为规定选2个，所以就是  n\*（n-1)/2 【n为你扩展的区间的点的个数】

这样的话，我们每个点只需要经过一次，也就是最后出来是O（n）的查询效率。

如果你这样写了，却发现样例都过不了？

没错，这个里面是有很多很多细节的。首先美味值可能是负数！这就要求我们要对于每一个扩展的区间不仅保存正的Rank1和Rank2，还要储存负的Negrank1和Negrank2！！！！

不仅如此，还有一堆一堆小细节需要去注意。比如在合并区间的时候，要考虑是否会重复储存rank值；在计算sum的时候，考虑此区间有没有到最左边……等等等等等，这些都需要你去慢慢写，慢慢调。

接着，要明白height数组的意义，height是指sa[i]和sa[i-1]的LCP，所以在cnt上还要细想.

还有一点，在初始化答案数组的时候，要初始化到-1e18！！因为数特别大！！！并且，一定要开long long~！【这不废话吗】

细节决定成败。本人代码很丑，你们凑合着看吧。

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<cmath> 
#define o 300001 
using namespace std;
long long a[o];  
long long n,len,tot,cnt,minnum,maxnum,what;
long long t1[o],t2[o],sa[o],Rank[o],height[o],cc[o],num[o],rem[o],sign[o]; 
char s[o];
struct sumu
{
    long long l,r,rank1,rank2,sum,negrank1,negrank2;
    bool hehe;
}zoom[o];
struct yc
{
    long long total,nice;
}ans[o];
int vis[o];
int min(int a,int b){return a<b?a:b;}
bool cmp(int a,int b){return height[a]>height[b];}
inline bool compare(long long *y,long long a,long long b,int k)
{
    int arank1,brank1,arank2,brank2;
    arank1=y[a];
    brank1=y[b];
    arank2=a+k>=len?-1:y[a+k];
    brank2=b+k>=len?-1:y[b+k];
    return arank1==brank1&&arank2==brank2; 
}
void make_sa()
{
    long long *x=t1,*y=t2,m=26;
    for(int i=0;i<m;i++)cc[i]=0;
    for(int i=0;i<len;i++)++cc[x[i]=s[i]-'a'];
    for(int i=1;i<m;i++)cc[i]+=cc[i-1];
    for(int i=len-1;i>=0;i--)sa[--cc[x[i]]]=i;
    for(int k=1;k<=len;k<<=1)
    {
        int p=0;
        for(int i=len-k;i<len;i++)y[p++]=i;
        for(int i=0;i<len;i++)if(sa[i]>=k)y[p++]=sa[i]-k;
        for(int i=0;i<m;i++)cc[i]=0;
        for(int i=0;i<len;i++)++cc[x[y[i]]];
        for(int i=1;i<m;i++)cc[i]+=cc[i-1];
        for(int i=len-1;i>=0;i--)sa[--cc[x[y[i]]]]=y[i];
        swap(x,y);
        m=1;x[sa[0]]=0;
        for(int i=1;i<len;i++)
        x[sa[i]]=compare(y,sa[i],sa[i-1],k)?m-1:m++;
        if(m>=len)break; 
    }
}
void make_height()
{
    for(int i=0;i<len;i++)Rank[sa[i]]=i;
    height[0]=0;
    int k=0;
    for(int i=0;i<len;i++)
    {
        rem[Rank[i]]=a[i];
        if(!Rank[i])continue;
        int j=sa[Rank[i]-1];
        if(k)k--;
        while(s[i+k]==s[j+k])
            k++;
        height[Rank[i]]=k;
    }
}
void check(long long value,long long top,long long type)
{
    if(type>=0)
    {
        if(value==minnum)return;
        if(value<=zoom[top].rank2)return;
        if(value>=zoom[top].rank1)
        {
            zoom[top].rank2=zoom[top].rank1;
            zoom[top].rank1=value;
        }
        else
            zoom[top].rank2=value;        
    }
    else
    {
        if(value==maxnum)return;
        if(value>=zoom[top].negrank1)return;
        if(value<=zoom[top].negrank2)
        {
            zoom[top].negrank1=zoom[top].negrank2;
            zoom[top].negrank2=value;
        }
        else
            zoom[top].negrank1=value;
    }
    
}
void make(int R)  //更新答案 
{
    if(zoom[tot].rank1!=minnum&&zoom[tot].rank2!=minnum)
        if(zoom[tot].rank1*zoom[tot].rank2>ans[R].nice) ans[R].nice=zoom[tot].rank1*zoom[tot].rank2;
    if(zoom[tot].negrank1!=maxnum&&zoom[tot].negrank2!=maxnum)
        if(zoom[tot].negrank1*zoom[tot].negrank2>ans[R].nice) ans[R].nice=zoom[tot].negrank1*zoom[tot].negrank2;
    if(zoom[tot].rank1!=minnum&&zoom[tot].negrank2!=maxnum)
        if(zoom[tot].rank1*zoom[tot].negrank2>ans[R].nice) ans[R].nice=zoom[tot].rank1*zoom[tot].negrank2;
    if(zoom[tot].rank2!=minnum&&zoom[tot].negrank1!=maxnum)
        if(zoom[tot].rank2*zoom[tot].negrank1>ans[R].nice) ans[R].nice=zoom[tot].rank2*zoom[tot].negrank1;
    if(zoom[tot].rank1!=minnum&&zoom[tot].negrank1!=maxnum)
        if(zoom[tot].rank1*zoom[tot].negrank1>ans[R].nice) ans[R].nice=zoom[tot].rank1*zoom[tot].negrank1;
    if(zoom[tot].rank2!=minnum&&zoom[tot].negrank2!=maxnum)
        if(zoom[tot].rank2*zoom[tot].negrank2>ans[R].nice) ans[R].nice=zoom[tot].rank2*zoom[tot].negrank2;
}
main()
{
    scanf("%lld",&n);
    scanf("%s",s);
    len=strlen(s);
    for(int i=0;i<n;i++)
    {
        scanf("%lld",&a[i]),num[i]=i;
        //初始化ans 
        ans[i].nice=-1e18-1000;  
        ans[i].total=0;
        if(a[i]<minnum)minnum=a[i];
        if(a[i]>maxnum)maxnum=a[i];
    }
    minnum--;
    maxnum++;
    make_sa();
    make_height();
    sort(num,num+n,cmp);
    memset(vis,127,sizeof(vis));
    for(int i=0;i<n;i++)
    if(vis[num[i]]>=n)
    {
        long long l,r,now,R;
        l=r=now=num[i],R=height[now];
        tot++;cnt=0;
        
        //初始化zoom[tot]
         
        zoom[tot].rank1=zoom[tot].rank2=minnum;
        zoom[tot].negrank1=zoom[tot].negrank2=maxnum;
        zoom[tot].sum=0;
        zoom[tot].hehe=false;
    
        // 初始化完成 
        while(height[l]>=height[now]&&l>=0)
        { 
            if(vis[l]>R&&vis[l]<n)
            {
                cnt+=zoom[sign[l]].sum;
                if(zoom[sign[l]].hehe)
                    ans[R].total-=(zoom[sign[l]].sum-1)*zoom[sign[l]].sum/2;
                else
                    ans[R].total-=(zoom[sign[l]].sum+1)*zoom[sign[l]].sum/2;
                //这里需要加特判——因为L到R区间的rank1或者rank2可能记录的是 ram[r]!
                //注意，处理正时先小后大，处理负时先大后小 
                if(zoom[sign[l]].rank2!=rem[l])
                    check(zoom[sign[l]].rank2,tot,1);
                if(zoom[sign[l]].rank1!=rem[l])
                    check(zoom[sign[l]].rank1,tot,1);
                if(zoom[sign[l]].negrank1!=rem[l])
                check(zoom[sign[l]].negrank1,tot,-1);
                if(zoom[sign[l]].negrank2!=rem[l])
                    check(zoom[sign[l]].negrank2,tot,-1);
                
                long long ll,rr,hehe;
                ll=zoom[sign[l]].l;
                rr=zoom[sign[l]].r;
                hehe=zoom[sign[l]].l-1;
                sign[ll]=tot;
                sign[rr]=tot;
                l=hehe;
            }
            else
            {
                vis[l]=R;
                sign[l]=tot;
                if(l>0)
                {
                    check(rem[l-1],tot,rem[l-1]);
                    cnt++;
                }
                else zoom[tot].hehe=true;
                l--;
            }
        }
        while(height[r]>=height[now]&&r<n)
        {
            if(vis[r]>R&&vis[r]<n)
            {
                cnt+=zoom[sign[r]].sum;
                if(zoom[sign[r]].hehe)
                    ans[R].total-=(zoom[sign[r]].sum-1)*zoom[sign[r]].sum/2;
                else
                    ans[R].total-=(zoom[sign[r]].sum+1)*zoom[sign[r]].sum/2;
                //这里需要加一个特判——因为L到R区间的rank1或者rank2可能记录的是 ram[L-1]!
                //注意，处理正时先小后大，处理负时先大后小 
                if(zoom[sign[r]].rank2!=rem[r-1]) 
                    check(zoom[sign[r]].rank2,tot,1);
                if(zoom[sign[r]].rank1!=rem[r-1]) 
                    check(zoom[sign[r]].rank1,tot,1);
                if(zoom[sign[r]].negrank1!=rem[r-1]) 
                    check(zoom[sign[r]].negrank1,tot,-1);
                if(zoom[sign[r]].negrank2!=rem[r-1]) 
                    check(zoom[sign[r]].negrank2,tot,-1);
                int ll,rr,hehe;
                ll=zoom[sign[r]].l;
                rr=zoom[sign[r]].r;
                hehe=zoom[sign[r]].r+1;
                sign[ll]=tot;
                sign[rr]=tot;
                r=hehe;
            }
            else
            {
                vis[r]=R;
                sign[r]=tot;
                check(rem[r],tot,rem[r]);
                cnt++;r++;
            }
        }
        zoom[tot].l=l+1;
        zoom[tot].r=r-1;
        if(zoom[tot].hehe)
            zoom[tot].sum=cnt;
        else
            zoom[tot].sum=cnt-1;
        ans[R].total+=cnt*(cnt-1)/2;
        make(R);
    } 
    for(int i=n-2;i>=0;i--)
    {
        ans[i].total+=ans[i+1].total;
        if(ans[i+1].nice>ans[i].nice)ans[i].nice=ans[i+1].nice;
    }
        
    for(int i=0;i<n;i++)
    {
        if(ans[i].total==0)ans[i].nice=0;
        printf("%lld %lld\n",ans[i].total,ans[i].nice);
    }
    return 0;
}
```

---

## 作者：asuldb (赞：4)

可能是最傻的做法了

暴力单调栈+$st$表

首先看到这道题就基本知道这是个$SA$了，先无脑敲上$SA$和求$height$的板子

之后尝试搞一下第一问

发现第一问就是求出满足$lcp(i,j)>=k$的$(i,j)$有多少对

我们可以用一个暴力合并的单调栈来做

现在的问题转化为求出$height$数组所有子区间的最小值的和

我们可以考虑一个动态往序列末尾加数的过程

也就是我们往末尾加一个数都会和之前所有的数形成一个新的区间

考虑快速算出这些区间的最小值的和

我们可以对每一个数存储一个$a_i$，表示$i$到当前序列末尾的最小值是多少

我们每次加入一个数可以对更新一下所有的$a_i$，把所有比当前加入的数大的$a_i$变成当前数就好了

这不就$T$了吗

我们发现我们只需要求出所有$a_i$的和，并不需要关心这个$i$来自哪里，于是我们可以把相等的$a_i$放在一起计算，也就是每次新加入一个数就暴力扫一遍把那些比当前加入数大的合并到一个$a_i$

看起来复杂度并不科学，但是最坏情况下就相当于是一个线段树的复杂度了，$O(n)$的，跑的还挺快的

同时还需要维护一个时间戳，在被合并的时候利用时间戳统计一下这个元素的贡献

之后第二问，我们可以直接强上单调栈

左右两边都先用单调栈扫一遍，扫出每个点往左往右能最远达到哪里，之后我们用一个$st$表维护区间的最大值和最小值，每次只需要从这个点左边的区间和右边的区间里选出最大值和最小值来组合就行了

代码

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#define re register
#define LL long long
#define maxn 300005
inline LL read()
{
	re char c=getchar();re LL x=0,r=1;
	while(c<'0'||c>'9') {if(c=='-') r=-1;c=getchar();}
	while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+c-48,c=getchar();return r*x;
}
int n,m,top;
int a[maxn],cnt[maxn],T[maxn],L[maxn],R[maxn];
char S[maxn];
int tp[maxn],tax[maxn],sa[maxn],rk[maxn],het[maxn],log_2[maxn],st[maxn];
LL pre[maxn],Ans[maxn];
LL St[2][maxn][20];
inline void qsort()
{
	for(re int i=0;i<=m;i++) tax[i]=0;
	for(re int i=1;i<=n;i++) tax[rk[i]]++;
	for(re int i=1;i<=m;i++) tax[i]+=tax[i-1];
	for(re int i=n;i;--i) sa[tax[rk[tp[i]]]--]=tp[i];
} 
inline LL max(LL a,LL b){return (a>b)?a:b;}
inline LL min(LL a,LL b){return (a<b)?a:b;}
inline LL ask(int o,int l,int r)
{
	int k=log_2[r-l+1];
	if(o) return max(St[1][l][k],St[1][r-(1<<k)+1][k]);
		else return min(St[0][l][k],St[0][r-(1<<k)+1][k]);
}
int main()
{
	n=read();scanf("%s",S+1);
	memset(St[0],0x3f3f3f3f,sizeof(St[0]));
	memset(St[1],-0x3f3f3f3f,sizeof(St[1]));
	memset(Ans,-0x3f3f3f3f,sizeof(Ans));
	m=750;
	for(re int i=1;i<=n;i++) rk[i]=S[i],tp[i]=i;
	qsort();
	for(re int w=1,p=0;p<n;m=p,w<<=1)
	{
		p=0;
		for(re int i=1;i<=w;i++) tp[++p]=n-w+i;
		for(re int i=1;i<=n;i++) if(sa[i]>w) tp[++p]=sa[i]-w;
		qsort();
		for(re int i=1;i<=n;i++) std::swap(rk[i],tp[i]);
		rk[sa[1]]=p=1;
		for(re int i=2;i<=n;i++) rk[sa[i]]=(tp[sa[i-1]]==tp[sa[i]]&&tp[sa[i-1]+w]==tp[sa[i]+w])?p:++p;
	}
	int k=0;
	for(re int i=1;i<=n;i++)
	{
		if(k) --k;
		int j=sa[rk[i]-1];
		while(S[i+k]==S[j+k]) ++k;
		het[rk[i]]=k;
	}
	for(re int i=2;i<=n;i++)
	{
		int now=1;
		while(top&&a[top]>=het[i])
			now+=cnt[top],pre[a[top]]+=(LL)((LL)i-(LL)T[top])*(LL)cnt[top],top--;
		a[++top]=het[i],T[top]=i,cnt[top]=now;
	}
	while(top) pre[a[top]]+=(LL)((LL)n+1ll-(LL)T[top])*(LL)cnt[top],top--;
	for(re int i=n-1;i>=0;--i) pre[i]+=pre[i+1];
	
	for(re int i=1;i<=n;i++)
    {
        while(top&&het[i]<het[st[top]]) R[st[top]]=i,top--;
        st[++top]=i;
    }
    while(top) R[st[top]]=n+1,top--;
    for(re int i=n;i;--i)
    {
        while(top&&het[i]<het[st[top]]) L[st[top]]=i,top--;
        st[++top]=i;
    }
    while(top) L[st[top]]=1,top--;
    
    for(re int i=1;i<=n;i++) St[0][rk[i]][0]=St[1][rk[i]][0]=read();
	for(re int i=2;i<=n;i++) log_2[i]=1+log_2[i>>1];
	for(re int j=1;j<=19;j++)
		for(re int i=1;i+(1<<j)-1<=n;i++)
			St[0][i][j]=min(St[0][i][j-1],St[0][i+(1<<(j-1))][j-1]),
			St[1][i][j]=max(St[1][i][j-1],St[1][i+(1<<(j-1))][j-1]);
			
    for(re int i=1;i<=n;i++)
	{
    	int l=L[i],r=R[i]-1;
    	if(l>i-1) continue;
		if(i>r) continue; 
		LL A=ask(1,l,i-1),B=ask(0,l,i-1),C=ask(1,i,r),D=ask(0,i,r);
    	if(Ans[het[i]]<A*C) Ans[het[i]]=A*C; if(Ans[het[i]]<B*D) Ans[het[i]]=B*D;
    	if(Ans[het[i]]<A*D) Ans[het[i]]=A*D; if(Ans[het[i]]<B*C) Ans[het[i]]=B*C;
	}
	for(re int i=n-1;i>=0;--i) Ans[i]=max(Ans[i],Ans[i+1]);
	for(re int i=0;i<n;i++)
	if(pre[i]) printf("%lld %lld\n",pre[i],Ans[i]);
		else printf("%lld ",pre[i]),putchar(48),putchar(10);
	return 0;
}
```

---

## 作者：Sai0511 (赞：3)

第$600ac$，写个题解纪念一下。   
设$ans1(i)$表示选出$(i-1)$相似酒的方案数，   
$ans2(i)$表示$(i-1)$相似酒可得到的最大美味度。    
我们求出$height$数组从大到小排序。  
考虑并查集然后一个一个往里面加。   
因为我们预先从大到小排序过了所以加的串的前缀一定是最小的，此时根据题意：对于$2$个$r$相似的串，则它们也一定是$0 < r'< r$相似的。     
我们同时记录一下并查集每个单元的大小$sz$。       
对方案数产生的贡献就是这两个单元的$sz$乘积。（乘法原理。）         
对于算$ans2$的贡献，这个就很简单了。    
我们维护一下每个并查集单元里的最大值和最小值。   
每次更新时就取最大值的乘积和最小值的乘积的较大值。（最小值可能会出现负负得正极大的情况。）   
最后再合并统计一下答案即可。    
### My code  
```cpp
#include <bits/stdc++.h>

using ll = long long;
using std::min;
using std::max;
const int maxn = 3e5 + 10;
const ll inf = 1ll << 62;
int n, m, i, j, k, tot;
char s[maxn];
int v[maxn], fa[maxn], id[maxn];
int cnt[maxn], sa[maxn], sec[maxn], he[maxn], rnk[maxn];
ll mn[maxn], mx[maxn], sz[maxn], ans1[maxn], ans2[maxn];

inline void radix_sort() {
  for (int i = 0; i <= m; i++) cnt[i] = 0;
  for (int i = 1; i <= n; i++) cnt[rnk[sec[i]]]++;
  for (int i = 1; i <= m; i++) cnt[i] += cnt[i - 1];
  for (int i = n; i >= 1; i--) sa[cnt[rnk[sec[i]]]--] = sec[i];
}
inline void get_sa() {
  m = 122, radix_sort();
  for (int l = 1, tot; l <= n; m = tot, l <<= 1) {
    tot = 0;
    for (int i = n - l + 1; i <= n; i++) sec[++tot] = i;
    for (int i = 1; i <= n; i++)
      if (sa[i] > l) sec[++tot] = sa[i] - l;
    radix_sort();
    std::swap(rnk, sec), rnk[sa[1]] = tot = 1;
    for (int i = 2; i <= n; i++)
      rnk[sa[i]] = (sec[sa[i]] == sec[sa[i - 1]] && sec[sa[i] + l] == sec[sa[i - 1] + l]) ? tot : ++tot;
    if (tot == n) break;
  }
}
inline void get_he() {
  for (int i = 1; i <= n; i++) rnk[sa[i]] = i;
  for (int i = 1, k = 0; i <= n; i++) {
    if (rnk[i] == 1) continue;
    if (k) k--;
    int j = sa[rnk[i] - 1];
    while (i + k <= n && j + k <= n && s[i + k] == s[j + k]) k++;
    he[rnk[i]] = k;
  }
}

int find(int u) { return u == fa[u] ? u : fa[u] = find(fa[u]); }
inline void Union(int u, int v) {
  int ru = find(u), rv = find(v);
  int x = he[u];
  ans1[x] += 1ll * sz[ru] * sz[rv];
  ans2[x] = max(ans2[x], max(1ll * mx[ru] * mx[rv], 1ll * mn[ru] * mn[rv]));
  mx[ru] = max(mx[ru], mx[rv]), mn[ru] = min(mn[ru], mn[rv]);
  fa[rv] = ru, sz[ru] += sz[rv];
}

int main() {
  scanf("%d\n%s", &n, s + 1);
  for (int i = 1; i <= n; i++)
    scanf("%d", v + i);
  for (int i = 1; i <= n; i++)
    rnk[i] = s[i], sec[i] = i;
  get_sa(), get_he();
  for (int i = 1; i <= n; i++)
    id[i] = fa[i] = i, ans1[i] = 0, ans2[i] = -inf, sz[i] = 1, mx[i] = mn[i] = v[sa[i]];
  std::sort(id + 1, id + n + 1, [](int a, int b){return he[a] > he[b];});
  for (int i = 1, x, y; i <= n; i++)
    if (find(id[i]) != find(id[i] - 1)) Union(id[i], id[i] - 1);
  for (int i = n - 2; i >= 0; i--)
    ans1[i] += ans1[i + 1], ans2[i] = max(ans2[i], ans2[i + 1]);
  for (int i = 0; i < n; i++)
    printf("%lld %lld\n", ans1[i], !ans1[i] ? 0 : ans2[i]);
  return 0;
}
```




---

## 作者：warrior_cat (赞：3)

这题出题人给的题解是用后缀数组O(nlogn)解决的，还用了单调栈或并查集。但这种复杂度还有可能被卡常数，实现上也有一定的难度，现在我们来YY一种O(n)的常数更小实现更简单的做法。

首先，题目中的r相似定义为从p、q两个点开始有长度不少于r的子串。如果我们能统计出所有p、q的LCP长度，并且只更新长度恰好为LCP的答案，那么我们可以通过后缀和和后缀最大值获得题目要求的答案。

考虑后缀树。假设我们神奇的获得了一棵后缀树，则只需要对于每一个非叶子节点，统计两个信息：1、有多少对叶子的LCA是它；2、它的子树中的所有叶子中，乘积最大值是多少。然后用这两个信息更新“该节点深度”dep相似的答案。树形DP解决。实现上要注意如果串都是相同字符，可能会爆栈，应采用BFS，由儿子更新父亲。

现在万事俱备，只欠一棵后缀树。考虑用后缀自动机构造后缀树。我们倒着插入原串（开头要先插一个特殊字符），并构建parent树。我们发现用于构造后缀自动机的len数组恰好就是对应后缀的长度，也就是该节点在后缀自动机中的深度。这里也有需要注意的：1、由于添加了特殊字符，叶子节点的深度需-1；2、存在一个-1后深度为0的叶子节点（表示空后缀），统计答案时需要扔掉。

至此，问题完美解决。时间复杂度O(n)，就算用string估计也不会被卡了。


---

## 作者：shadowice1984 (赞：3)

### 后缀数组X后缀树

(后缀的表示，对于字符串S，数字i表示从i位置开始的后缀)
无论是后缀数组还是后缀自动机，都是名为"后缀树"的数据结构的一种压缩

什么是后缀树呢，我们把字符串S的每一个后缀插入到trie树里，那么后缀树的每一个节点对应着S的一个子串，后缀树的每一个叶子节点对应着原串的一个后缀，两个后缀的lcp长度就是两个后缀对应节点在后缀树上的lca深度。

但是我们发现尽管后缀可以方便的处理各个后缀间的关系，判子串找lcp什么的也非常好使，但是我们发现后缀树的节点个数是O(n^2)的，因此我们需要将后缀树进行"压缩"，后缀数组就是压缩技术中的一种

### 后缀数组原理

我们发现我们知道所有子串的信息有点贪了……大部分时候我们只需要将子串理解为某个后缀的前缀即可，因此非常有用的是关于后缀的信息，然后我们发现，后缀只有O(N)个，而且，后缀树有一个非常重要的性质，如果后缀a的字典序小于后缀b的字典序，那么a的后缀树上对应节点的dfs序也是小于b的dfs序的，因此，我们如果可以将后缀按字典序排序，就可以部分还原后缀树的信息，而有些时候这些信息就是我们需要的，其实有点像虚树，不建树却可以实施某些树上操作

那么开始讲如何将后缀排序吧，首先说明O(N)的DC3我是不会的，我只会O(NlogN)的倍增做法，这道题3\*10^5的只能说是勉强卡过去，所以请在实现的时候注意常数\~

#### 基数排序X桶排序/计数排序

 _（如果你认真读过算导的排序算法部分，可以跳过这个部分，但是如果只是了解的话，还是来看看吧……）_ 

倍增实现法要求一个**复杂度为O(N)的稳定排序**，那么什么sort之类的就不用想了……，可以做到这个只有基数排序和桶排序以及计数排序，而基数排序又需要一个**复杂度为O(N)的稳定排序**，那么就只剩下桶排和计排了，事实上，用哪种都可以……，但是推荐使用计排，因为桶排常数大……，这道题你卡不过去30w的点的

先介绍啥叫**计数排序**，计数排序基于这一点，要排的数，值域不会太大，所以，我们可以枚举元素的值，计算每个值的排名,然后我们的思路是对于每个值，先计算一波有多少个元素就是这个值，记sum\[i]表示值为i的元素个数。

之后，我们对sum\[]做一个前缀和，这样的话，实际上是计算出来每个值的最后一个元素在排序后数组里的下标(注意一件事，当我们说排名，意味着相同值的元素排名相同，但是我们说数组下标的时候，这意味每一个元素的下标都是不同的)

为了起到稳定的效果，我们从后往前扫一遍待排序数组，将其放在它的**值对应的下标上**，为此我们需要复制下原数组，以免洗掉不该洗的东西，在此期间，sum\[i]始终表示值为i的元素在排好序后数组的下标，当我们碰到了第一个值为i的元素时，我们会发现，因为倒着扫的缘故，它其实是原数组中最靠后的元素，它就应该待在sum\[i]上，但是倒数第二个值为i的元素就不能待在sum\[i]上了
为此我们让sum\[i]--就可以了，就是把下一个元素放在这个元素左边的位置上。
这样我们就可以实现O(N+K)(K为值域)的排序了

另一种方式是**桶排序**，按理来讲应该是除法散列的……但是我们这里假设值域不是很大，因此我们可以选择散列函数H(x)=x,(看！绝对没冲突的hash！)

具体思路如下，正向扫一遍，我们开上K个队列(K为值域),然后我们把每个值为i的元素push进第i个队列里，最后从大到小的扫一遍队列数组，每次碰到一个队列，把它pop空，倒进待排序数组中，由于队列先进先出，相当于隐性的第二关键字为位置，也就起到了稳定的目的

下面是**基数排序**，我们知道，对于一些D位数，相当于最高位第一关键字，次高位第二关键字，一直到第D关键字，于是我们从低位到高位，每次以**当前位为关键字进行稳定排序**由于是稳定排序，因此第K轮其实是以第K位为第一关键字，K-1位为第二关键字，这样迭代起来，就是位数越高，优先级越大，就实现了排好这些N位数的目的。如果我们选择一个复杂度为O(N)的稳定排序(计排/桶排)作为基排的底层排序，就能做到O(D\*N)的复杂度，并且，还是稳定的，因为第一位排序以第一位为第一关键字，位置为第二关键字。

#### 倍增法
倍增法的思路，既然要排后缀，我们观察后缀的比较规则，从前向后比，那么我们可以先比第1位，再比第2位……且慢，难道我们真的要比N次？我们发现比完第2为之后，我们是可以知道每个长度为2的子串的排名的，因此，我们可以将两个子串拼接起来，先比前一半再比后一半，从而得出长度为4的子串的排名，得出长度为4的排名之后，再去排长度为8的，如此，直到长度超过N子串就成了后缀

那么每次，我们可以将子串的前一半排名变成第一关键字，后一半排名作为第二关键字，丢进去做基数排序，处理出排名，继续迭代，这就是倍增法了。

#### 如何计算lcp
我们啊，会发现一个非常有趣的性质，设排好序之后的后缀构成的数组为sa\[]
如果我们令ht\[i]=lcp(sa\[i],sa\[i-1]);令rk\[sa\[i]]=i
那么有ht\[rk\[i]]>=ht\[rk\[i-1]]-1，之后我们就可以愉快的暴力求ht了
可以认为是求出后缀树上dfs序相邻两个节点lca深度

到目前为止，和虚树干的事没差别，求dfs序，相邻dfs序搞lca
对于两个后缀p,q,lcp(p,q)=rmq(sa\[p],sa\[q])(区间min)，所以要求任意的话st表预处理就行，查询O(1)

### 本题解法
对这个字符串求一发后缀数组，(底层排序用计排！！！桶排常数大会T飞)

那么我们发现如果我们可以维护一个集合，其中的后缀两两R相似该多好，答案瞬间出来了，C(siz,2)，以及max(最大\*次大，最小\*次小)
而且我们还发现一个美妙的性质，如果有一个后缀，和其中的某个元素r相似，那么和集合中的所有元素r相似，等等，这个性质好像可以用并查集维护~

那么求出来的后缀数组告诉我们一些串的最大相似程度，(lcp(sa\[i],sa\[i-1])=ht\[i])那么我们就可以用并查集去维护r相似信息，具体来讲，把h大到小排序，每次并查集并起来r相似的两个串，在切换r的时候，更新一发答案即可。

# 记得开 long long

上代码~

```C
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
char mde[300010];long long val[300010];
int sa[300010];int ra[600010];
int x[300010];int y[300010];int ht[300010];
int n;long long up;
int sum[300010];int tr[300010];
inline void rixs()//基排~,这里认为是两位数,每一位取值范围0-n
{
    for(int i=1;i<=n;i++){sum[i]=0;}//清空sum
    for(int i=1;i<=n;i++){sum[y[i]]++;}
    for(int i=1;i<=n;i++){sum[i]+=sum[i-1];}//计排第一位
    for(int i=n;i>=1;i--){sa[sum[y[i]]--]=i;}//计排放下去
    for(int i=1;i<=n;i++){sum[i]=0;}//清sum
    for(int i=1;i<=n;i++){sum[x[sa[i]]]++;}//计排第二位
    for(int i=1;i<=n;i++){sum[i]+=sum[i-1];}
    for(int i=1;i<=n;i++){tr[i]=sa[i];}//这里要复制存在sa里的位置信息
    for(int i=n;i>=1;i--){sa[sum[x[tr[i]]]--]=tr[i];}//计排第二位放下去
    ra[sa[1]]=1;for(int i=2;i<=n;i++)//计算rk,这里可以写个cmp再用条件表达式,我懒得写了
    {if(x[sa[i]]==x[sa[i-1]]&&y[sa[i]]==y[sa[i-1]])ra[sa[i]]=ra[sa[i-1]];else ra[sa[i]]=i;}
}
inline void create_sa()
{
    for(int i=1;i<=n;i++){sum[mde[i]-'a'+1]++;}//首先先强制转数字
    for(int i=1;i<=26;i++){sum[i]+=sum[i-1];}//还是计排
    for(int i=n;i>=1;i--){sa[sum[mde[i]-'a'+1]--]=i;}
    ra[sa[1]]=1;for(int i=1;i<=n;i++)//一样的算排名
    {if(mde[sa[i]]==mde[sa[i-1]])ra[sa[i]]=ra[sa[i-1]];else ra[sa[i]]=i;}
    for(int k=1;k<=n;k<<=1)//倍增现在要排的子串长度
    {
        for(int i=1;i<=n;i++)x[i]=ra[i];//前一半第一关键字
        for(int i=1;i<=n;i++)y[i]=ra[i+k];//后一半第二关键字
        rixs();//基排
    }return;
}
inline void calch()
{
    int j=0;int k=0;
    for(int i=1;i<=n;ht[ra[i++]]=k)//维护开始匹配的位置,暴力匹配即可
        for(k=k?k-1:k,j=sa[ra[i]-1];mde[i+k]==mde[j+k];k++);
}
struct bcj//要开longlong,按址合并路径压缩还是都用上吧,毕竟单用都是log的
{
    int fa[300010];int size[300010];
    long long ma[300010];long long nxtma[300010];
    long long mi[300010];long long nxtmi[300010];
    inline void ih()
    {
        for(int i=1;i<=n;i++)
        {
            fa[i]=i;size[i]=1;
            ma[i]=val[sa[i]];nxtma[sa[i]]=-up;
            mi[i]=val[sa[i]];nxtmi[sa[i]]=up;
        }
    }
    inline void rfrma(long long x,int p)//刷新最大,次大值
    {if(x>=ma[p]){nxtma[p]=ma[p];ma[p]=x;}else if(x>nxtma[p]){nxtma[p]=x;}}
    inline void rfrmi(long long x,int p)//刷新最小,次小值
    {if(x<=mi[p]){nxtmi[p]=mi[p];mi[p]=x;}else if(x<nxtmi[p]){nxtmi[p]=x;}}
    inline int f(int x)
    {return fa[x]=(fa[x]==x)?x:f(fa[x]);}
    inline void u(int x,int y)
    {
        int u=f(x);int v=f(y);if(size[u]<size[v])swap(u,v);
        size[u]+=size[v];fa[v]=u;
        rfrma(ma[v],u);rfrma(nxtma[v],u);
        rfrmi(mi[v],u);rfrmi(nxtmi[v],u);
    }
    inline long long get_size(int x){return size[f(x)];}
    inline long long get_ma(int x)
    {int u=f(x);return max(ma[u]*nxtma[u],mi[u]*nxtmi[u]);}
}s;
struct data//这里用来排序h的结构体
{
    int n;int t;
    friend bool operator <(data a,data b){return a.t>b.t;}
}d[300010];long long ans1[300010];long long ans2[300010];
int main()
{
    up=pow(2LL,62);
    scanf("%d",&n);scanf("%s",mde+1);
    for(int i=1;i<=n;i++)scanf("%lld",&val[i]);
    create_sa();calch();s.ih();
    for(int i=1;i<=n;i++)d[i].n=i,d[i].t=ht[i];//排序h的时候保留一个索引
    for(int i=1;i<=n;i++)ans2[i]=-up;
    sort(d+1,d+n+1);int num=d[1].t;//维护当前更新什么答案
    for(int i=1;i<=n;i++)
    {
        if(num!=d[i].t)//可能出现根本没有这个r的情况,此时答案同上
        {for(int j=d[i].t;j<num;j++)ans1[j]=ans1[num],ans2[j]=ans2[num];num=d[i].t;}
        if(s.f(d[i].n)!=s.f(d[i].n-1))//并的时候更新答案,省的统计啥时候切ht
        {
            ans1[num]+=s.get_size(d[i].n)*s.get_size(d[i].n-1);//这里换了个写法统计点对
            s.u(d[i].n,d[i].n-1);ans2[num]=max(ans2[num],s.get_ma(d[i].n));//同时更新答案
        }
    }
    for(int i=0;i<=n-1;i++)//倒着输出答案
    {
        if(ans1[i]==0){printf("0 0\n");continue;}
        printf("%lld %lld\n",ans1[i],ans2[i]);
    }
    return 0;//拜拜程序~
}
```



















---

## 作者：__wfx (赞：3)

这道题好难

自己口胡了一个线段树+后缀自动机的做法

建出其反串的后缀自动机的 $parent$ 树

跑一遍树形DP即可

用线段树维护每个长度的 $ans$ ，具体细节看代码即可

```cpp
#include <bits/stdc++.h>
#define int long long
typedef long long LL;
const LL inf = 2e18;
const int N = 6e5 + 100;
inline int read() {
	int res(0), f(1); char ch(getchar()); 
	while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }
	while ('0' <= ch && ch <= '9') res = (res << 1) + (res << 3) + (ch ^ 48), ch = getchar();
	return res * f;
}

struct Edge {
	int to;
	Edge *nxt;
	Edge(int to, Edge *nxt) : to(to), nxt(nxt) {}
} *head[N];

int len[N], siz[N], a[N], link[N], ch[N][26], tot, last, Max[N], Min[N], fuck[N];
LL ans[N], cnt[N];

inline void insert(int c, int x) {
	int p = last, cur = ++ tot; last = cur; len[cur] = len[p] + 1; siz[cur] = 1; a[cur] = x;
	for (; p && ch[p][c] == 0; p = link[p]) ch[p][c] = cur;
	if (!p) { link[cur] = 1; return; }
	int q = ch[p][c];
	if (len[p] + 1 == len[q]) link[cur] = q;
	else {
		int nq = ++ tot;
		link[nq] = link[q]; len[nq] = len[p] + 1;
		for (int i = 0; i < 26; ++ i) ch[nq][i] = ch[q][i];
		link[q] = link[cur] = nq;
		for (; p && ch[p][c] == q; p = link[p]) ch[p][c] = nq;
	}
}

inline void Get_Tree() {
	for (int i = 2; i <= tot; ++ i) head[link[i]] = new Edge(i, head[link[i]]);
}

#define mid ((l + r) >> 1)
struct node {
	int l, r;
	LL Max, sum;
	node *li, *ri;
	node(int _l, int _r) : l(_l), r(_r), Max(-inf), sum(0) {
		if (l == r) return;
		li = new node(l, mid);
		ri = new node(mid + 1, r);
	}

	void chenge(int L, int R, LL MAX, LL tot) {
		if (L > R) return;
		if (L <= l && r <= R) {
			sum += tot;
			Max = std::max(MAX, Max);
			return;
		}
		if (mid >= L) li->chenge(L, R, MAX, tot);
		if (mid < R)  ri->chenge(L, R, MAX, tot);
	}

	void print(int n, LL MAX, LL tot) {
		if (l == r) {
			if (l == n) return;
			printf("%lld %lld\n", tot + sum, std::max(MAX, Max) == -inf ? 0 : std::max(MAX, Max));
			return;
		}
		li->print(n, std::max(MAX, Max), tot + sum);
		ri->print(n, std::max(MAX, Max), tot + sum);
	}

} *root;

void dfs(int x) {
	ans[x] = -inf;
	Max[x] = std::max(Max[x], a[x]);
	Min[x] = std::min(Min[x], a[x]);
	for (Edge *i = head[x]; i; i = i->nxt) {
		dfs(i->to);
		ans[x] = std::max(ans[x], std::max((LL)Min[x] * Min[i->to], (LL)Max[x] * Max[i->to]));
		ans[x] = std::max(ans[i->to], ans[x]);
		Max[x] = std::max(Max[x], Max[i->to]);
		Min[x] = std::min(Min[x], Min[i->to]);
		siz[x] += siz[i->to];
	}
	if (siz[x] == 2 && Max[x] && Min[x]) ans[x] = (LL)Min[x] * (LL)Max[x];
	root->chenge(x != 1 ? len[link[x]] + 1 : 0, len[x], ans[x], siz[x] * (siz[x] - 1) / 2);
}

char s[N];

signed main() {
	tot = last = 1;
	int n(read());
	scanf("%s", s + 1); root = new node(0, n);
	for (int i = 1; i <= n; ++ i) fuck[i] = read();
	for (int i = n; i >= 1; -- i) insert(s[i] - 'a', fuck[i]);
	Get_Tree();
	dfs(1);
	root->print(n, -inf, 0);
}

```

---

## 作者：Z_Healer (赞：2)

[P2178 [NOI2015] 品酒大会](https://www.luogu.com.cn/problem/P2178)

题意：$\forall i\in [0,n)$ 求有多少对后缀满足$len(lcp)\ge i$，以及满足条件的两个后缀的权值乘积的最大值。


$len(lcp)\ge i$可以转化为$len(lcp)$恰好为$i$，然后对个数求后缀和，权值求后缀$\max$。因为$lcp(sa[i],sa[j])=\min_{k=i+1}^j(height[k])$，也就是说两个后缀的$lcp$取决于他们之间的$ht$最小值，所以我们可以对于每个$ht_i$，找到它能的贡献范围$[l,r]$，也就是再往左或右的$ht$会比$ht_i$大，这个贡献范围可以用单调栈来求。

计算有多少对后缀$(x,y)(x<y)$满足$len(lcp(suf_x,suf_y))=ht_i$

因为$height[i]=lcp(sa[i],sa[i-1])$，也就是说一个$ht$是反映两个后缀的$lcp$并且$ht_1$**无意义**，所以$ht_i$控制的后缀范围为$[l-1,r]$。因为是要满足两个后缀的最小值为$ht_i$，所以选的两个后缀一定要跨过$ht_i$，所以$x\in [l-1,x-1],y\in[x,r]$为，$ht_i$的贡献为$(x-l+1)\times (r-x+1)$。

求权值乘积的最大值可以用$ST$表来维护区间最大值和区间最小值（因为有负数），注意$f[i][0]=a[sa[i]]$，答案为$\max(\min_{i=l-1}^{x-1}a[i]\times min_{i=x}^ra[i],\max_{i=l-1}^{x-1}a[i]\times max_{i=x}^ra[i])$。

因为$ht_1$无意义，所以从$ht_2$开始，$ht_2$的左端点为$1$。

建议认真思考区间边界。

```cpp
#include<bits/stdc++.h>
#define N 300010
#define ll long long
using namespace std;
inline int read(){
	int w=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') f=0;
		ch=getchar();
	}
	while(ch<='9'&&ch>='0'){
		w=(w<<3)+(w<<1)+(ch^48);
		ch=getchar();
	}
	return f?w:-w;
}
char s[N];
ll res[N],sum[N],f[2][N<<1][25];
int a[N],n,m,sa[N],rk[N],se[N],cnt[N],ht[N],logg[N],stac[N],top,p[N];
inline void qsort(){
	for(int i=0;i<=m;i++) cnt[i]=0;
	for(int i=1;i<=n;i++) cnt[rk[i]]++;
	for(int i=1;i<=m;i++) cnt[i]+=cnt[i-1];
	for(int i=n;i>=1;i--) sa[cnt[rk[se[i]]]--]=se[i];
}
inline void get_sa(){
	m=122;
	for(int i=1;i<=n;i++) rk[i]=s[i],se[i]=i;
	qsort();
	for(int w=1;w<=n;w<<=1){
		int num=0;
		for(int i=n-w+1;i<=n;i++) se[++num]=i;
		for(int i=1;i<=n;i++) if(sa[i]>w) se[++num]=sa[i]-w;
		qsort();swap(rk,se);rk[sa[1]]=num=1;
		for(int i=2;i<=n;i++) rk[sa[i]]=(se[sa[i]]==se[sa[i-1]]&&se[sa[i]+w]==se[sa[i-1]+w])?num:++num;
		if(num==n)break;m=num;
	}
	for(int i=1,j=0;i<=n;i++){
		if(j)j--;
		while(s[sa[rk[i]]+j]==s[sa[rk[i]-1]+j])j++;
		ht[rk[i]]=j;
	}
}
inline ll askmi(int l,int r){
	int k=logg[r-l+1];
	return min(f[0][l][k],f[0][r-(1<<k)+1][k]);
}
inline ll askma(int l,int r){
	int k=logg[r-l+1];
	return max(f[1][l][k],f[1][r-(1<<k)+1][k]);
}
int main(){
	n=read();scanf("%s",s+1);
	for(int i=1;i<=n;i++) a[i]=read(),res[i]=-2e18;
	//求ht数组
	get_sa();
	//ST表
	for(int i=1;i<=n;i++) f[0][i][0]=f[1][i][0]=a[sa[i]];
	for(int i=2;i<N;i++) logg[i]=logg[i>>1]+1;
	for(int j=1;j<=logg[n];j++)
		for(int i=1;i+(1<<(j-1))-1<=n;i++)
			f[0][i][j]=min(f[0][i][j-1],f[0][i+(1<<(j-1))][j-1]),
			f[1][i][j]=max(f[1][i][j-1],f[1][i+(1<<(j-1))][j-1]);
	//单调栈求贡献区间
	stac[top]=1;//注意不要算ht[1]的贡献
	for(int i=2;i<=n;i++){
		while(top&&ht[stac[top]]>ht[i]){
			int x=stac[top],l=p[x],r=i-1;
			sum[ht[x]]+=1ll*(x-l+1)*(r-x+1);//个数
			if(l<=r) res[ht[x]]=max(res[ht[x]],max(askmi(l-1,x-1)*askmi(x,r),askma(l-1,x-1)*askma(x,r)));//权值最大值
			top--;
		}
		p[i]=stac[top]+1;//左端点
		stac[++top]=i;
	}
	//将栈中元素清空
	while(top){
		int x=stac[top],l=p[x],r=n;//后面没有比它小的，右端点就只能为n
		sum[ht[x]]+=1ll*(x-l+1)*(r-x+1);
		if(l<=r) res[ht[x]]=max(res[ht[x]],max(askmi(l-1,x-1)*askmi(x,r),askma(l-1,x-1)*askma(x,r)));
		top--;
	}
	for(int i=n-1;i>=0;i--) sum[i]+=sum[i+1],res[i]=max(res[i],res[i+1]);//求个后缀和/max
	for(int i=0;i<n;i++) printf("%lld %lld\n",sum[i],res[i]==-2e18?0:res[i]);
	return 0;
}
```

---

## 作者：devout (赞：2)

对于两个以 $i,j$ 开头的后缀，显然他会对 $0\sim LCP(i,j)$ 的相似度的答案有贡献

所以考虑先用 SA 求出 $height$ 数组

因为 $LCP(i,j)=\min\{height_k\},k\in(i,j]$，所以对于每一个 $height_i$，我们找到左右第一个 $height$ 不小于他的位置，设为 $l,r$，那么对于每一个 $p\in(l,i),q\in[i,r),LCP(p,q)=height_i$

我们可以用单调栈得到这个区间，然后利用组合数学和ST表就可以求出 $LCP$ 的位置上的答案了，然后做一下后缀和/后缀max

注意这里会出现一个问题，如果他左边/右边第一个不小于他的位置刚好等于他，那么这个时候会出现问题（如样例1）

所以我们每次找左边第一个小于他的，和右边第一个小于等于他的，就可以做到不重不漏的计算了

```cpp
# include <bits/stdc++.h>

using namespace std;

# define Rep(i,a,b) for(register int i=a;i<=b;i++)
# define _Rep(i,a,b) for(register int i=a;i>=b;i--)
# define RepG(i,u) for(int i=head[u];~i;i=e[i].next)

typedef long long ll;

const int N=3e5+5;

template<typename T> void read(T &x){
   x=0;int f=1;
   char c=getchar();
   for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
   for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+c-'0';
    x*=f;
}

int n,m;
char s[N];
int a[N];
ll ans1[N];
ll ans2[N];
int stk[N],top;
int sa[N],rk[N],dy[N],sum[N];
int L[N],R[N];
int height[N];
int mx[N][20],mi[N][20],lg[N];

void RadixSort(){
	Rep(i,1,m)sum[i]=0;
	Rep(i,1,n)sum[rk[i]]++;
	Rep(i,1,m)sum[i]+=sum[i-1];
	_Rep(i,n,1)sa[sum[rk[dy[i]]]--]=dy[i];
}

void SA(){
	m='z';
	Rep(i,1,n)rk[i]=s[i],dy[i]=i;
	RadixSort();
	for(int k=1,t=0;t<n;k<<=1,m=t){
		t=0;
		_Rep(i,n,n-k+1)dy[++t]=i;
		Rep(i,1,n)if(sa[i]>k)dy[++t]=sa[i]-k;
		RadixSort();
		swap(rk,dy);
		rk[sa[1]]=t=1;
		Rep(i,2,n)
			rk[sa[i]]=dy[sa[i]]==dy[sa[i-1]]&&(sa[i]+k<=n&&sa[i-1]+k<=n&&dy[sa[i]+k]==dy[sa[i-1]+k])?t:++t; 
	}
	Rep(i,1,n)rk[sa[i]]=i;
	int k=0;
	Rep(i,1,n){
		if(rk[i]==1)continue;
		if(k)k--;
		int j=sa[rk[i]-1];
		while(i+k<=n&&j+k<=n&&s[i+k]==s[j+k])k++;
		height[rk[i]]=k;	
	}
}

void init(){
	memset(mx,-0x3f,sizeof(mx));
	memset(mi,0x3f,sizeof(mi));
	lg[1]=0;
	Rep(i,2,n)lg[i]=lg[i>>1]+1;
	_Rep(i,n,1){
		mx[i][0]=mi[i][0]=a[sa[i]];
		Rep(j,1,19){
			if(i+(1<<j-1)>n)break;
			mx[i][j]=max(mx[i][j-1],mx[i+(1<<j-1)][j-1]);
			mi[i][j]=min(mi[i][j-1],mi[i+(1<<j-1)][j-1]);	
		}
	}	
}

int getmax(int i,int j){
	int k=lg[j-i+1];
	return max(mx[i][k],mx[j-(1<<k)+1][k]);	
}

int getmin(int i,int j){
	int k=lg[j-i+1];
	return min(mi[i][k],mi[j-(1<<k)+1][k]);	
}

int main()
{
	memset(ans2,-0x3f,sizeof(ans2));
	read(n);
	scanf("%s",s+1);
	Rep(i,1,n)read(a[i]);
	SA();
	Rep(i,2,n){
		while(top&&height[stk[top]]>=height[i])top--;
		L[i]=top?stk[top]:1;
		stk[++top]=i;	
	}
	top=0;
	_Rep(i,n,2){
		while(top&&height[stk[top]]>height[i])top--;
		R[i]=top?stk[top]:n+1;
		stk[++top]=i;	
	}
	Rep(i,2,n)ans1[height[i]]+=1ll*(i-L[i])*(R[i]-i);
	_Rep(i,n,0)ans1[i]+=ans1[i+1]; 
	init();
	Rep(i,2,n)
		ans2[height[i]]=max(ans2[height[i]],max(1ll*getmax(L[i],i-1)*getmax(i,R[i]-1),1ll*getmin(L[i],i-1)*getmin(i,R[i]-1)));
	_Rep(i,n,0)ans2[i]=max(ans2[i],ans2[i+1]);
	Rep(i,0,n-1)printf("%lld %lld\n",ans1[i],ans1[i]?ans2[i]:ans1[i]);
	return 0;
}
```


---

## 作者：EternalEpic (赞：2)

看过很多题解，可能都是大佬写的，有的地方一笔带过，感觉不是很懂，花1.5h肝了这题，写篇题解以供后人参考。自认为会比较细致一点，请耐心阅读。

笔者只会SuffixArray。所以此题我使用了后缀数组+并查集的方式通过。

后缀数组应该是后缀数据结构中最简单的一个，我使用倍增后缀排序的方式，可以一个log求出sa数组。

然后这道题，它“r相似”的意思就是lcp(p, q)不小于r。

于是我们要预处理出height数组。

板子部分：

```cpp
inline void RadixSort(void) {
	for (int i = 0; i <= m; i++) cnt[i] = 0;
	for (int i = 1; i <= n; i++) ++cnt[Rank[i]];
	for (int i = 1; i <= m; i++) cnt[i] += cnt[i - 1];
	for (int i = n; i >= 1; i--) SA[cnt[Rank[tmp[i]]]--] = tmp[i];
}

inline void SuffixSort(void) {
	for (int i = 1; i <= n; i++) Rank[i] = str[i] - '0' + 1, tmp[i] = i; RadixSort();
	for (int k = 1, tot = 0; tot < n; m = tot, k <<= 1) { tot = 0;
		for (int i = 1; i <= k; i++) tmp[++tot] = n - k + i;
		for (int i = 1; i <= n; i++) if (SA[i] > k) tmp[++tot] = SA[i] - k;
		RadixSort(); swap(tmp, Rank); Rank[SA[1]] = tot = 1;
		for (int i = 2; i <= n; i++)
			Rank[SA[i]] = (tmp[SA[i - 1]] == tmp[SA[i]] && tmp[SA[i - 1] + k] == tmp[SA[i] + k]) ? tot : ++tot;
	}
}

inline void GetHeight(void) { int k = 0;
	for (int i = 1; i <= n; i++) Rank[SA[i]] = i;
	for (int i = 1; i <= n; i++) {
		if (Rank[i] == 1) continue;
		if (k) --k; int j = SA[Rank[i] - 1];
		while (j + k <= n && i + k <= n && str[i + k] == str[j + k]) ++k;
		height[Rank[i]] = k;
	}
}

```

可以轻松想到一种暴力策略，即利用height数组暴力求lcp，然后暴力统计，这好像是3方的，预计得分20分。

那我们应该换一换思路。

我们知道lcp(i, j) = min{height[k]} (i + 1 <= k <= j)。

那是不是“r相似”时，对其能造成贡献必须是lcp区间内的height大于等于r。

考虑将height从大到小排序，并用并查集来计算两段合并贡献。

由于美味度有负数，所以可能出现最小值乘次小值大于最大值乘次大值的情况，所以要维护max1，max2，min1，min2四个元素来求ans2。

然后第一问要求方案数，所以要维护sze来求ans1。每次合并两个集合x，y，假设它们最多是"z相似"的，那么就会对ans1[0 ~ z]产生sze[x] * sze[y]的贡献。

既然都维护sze了，就让并查集再按秩合并，比单纯的路径压缩块一点。

最后要提醒大家是要开long long而且ans2，max2，min2的初值的绝对值要设大一些，不然会出错，只有70分。（|inf|我开到了2的60次方）

code：

```cpp
struct Height {
	int idx, hgt;
	Height(int _i = 0, int _h = 0) : idx(_i), hgt(_h) {}
	inline bool operator < (const Height&rhs) const { return hgt > rhs.hgt; }
} a[Maxn]; ll max1[Maxn], max2[Maxn], min1[Maxn], min2[Maxn], w[Maxn], ans1[Maxn], ans2[Maxn];

inline int getf(int x) { return f[x] = f[x] == x ? x : getf(f[x]); }
inline void unionf(int x, int y) {
	ll  p[5] = {0, max1[x], max2[x],  max1[y], max2[y]}, q[5] = {0, min1[x], min2[x], min1[y], min2[y]};
	if (sze[x] <= sze[y]) f[x] = y, sze[y] += sze[x]; else f[y] = x, sze[x] += sze[y];
	sort(p + 1, p + 5, greater <ll> ()); sort(q + 1, q + 5);
	max1[f[x]] = p[1], max2[f[x]] = p[2]; min1[f[x]] = q[1], min2[f[x]] = q[2];
}

signed main(void) {
//	file("");
	read(n); readstr(str + 1); m = 256;
	for (int i = 1; i <= n; i++) read(w[i]);
	SuffixSort(); GetHeight();
	
	for (int i = 2; i <= n; i++) a[i] = Height(i, height[i]);
	for (int i = 1; i <= n; i++) {
		f[i] = i; sze[i] = 1; ans2[i] = -(1ll << 60);
		max1[i] = w[SA[i]], max2[i] = -(1ll << 60);
		min1[i] = w[SA[i]], min2[i] = 1ll << 60;
	} ans2[0] = -(1ll << 60); sort(a + 2, a + n + 1);
	
	for (int i = 2; i <= n; i++) {
		int idx = a[i].idx, hgt = a[i].hgt;
		int fx = getf(idx), fy = getf(idx - 1);		
		ans1[0] += 1ll * sze[fx] * sze[fy]; 
		ans1[hgt + 1] -= 1ll * sze[fx] * sze[fy];
		unionf(fx , fy); fx = getf(idx);
		chkmax(ans2[hgt], max(1ll * max1[fx] * max2[fx], 1ll * min1[fx] * min2[fx]));
	}
	
	for (int i = 1; i < n; i++) ans1[i] += ans1[i - 1];
	for (int i = n - 1; i >= 0; i--) chkmax(ans2[i] , ans2[i + 1]);
	for (int i = 0; i < n; i++) if (!ans1[i]) puts("0 0"); else writeln(ans1[i], ' '), writeln(ans2[i]);
//	fwrite(pf, 1, o1 - pf, stdout);
	return 0;
}
```


---

## 作者：消失的海岸线 (赞：2)

一个  **后缀自动机** 的题解。

BZOJ 3238 [Ahoi2013] 差异 [这题](http://www.lydsy.com/JudgeOnline/problem.php?id=3238 "这题")的加强版。

这题题面的话 UOJ 和 LOJ 的比较可看...

如果有部分地方看不懂题解在说什么可以去先把那个题做了。

考虑到如果一对串 $r$ 相似则 $[0,r-1]$ 均相似，所以可以直接只考虑一对串的最长相似，最后答案做一下前缀和即可。

一对串的最长相似... 不就是这两个后缀的 $lcp$ 吗，这个东西在后缀树上两个节点的 $lca$ 处体现...

于是翻转串后建后缀自动机转后缀树，对于树上节点维护 $mx$ 和 $mn$ 即可，因为有负负得正。

另外交完 luogu 建议也去 UOJ 交一发... 被 hack 数据洗礼后的程序将会更强大。

```cpp
    #include <cmath>
    #include <queue>
    #include <cstdio>
    #include <iomanip>
    #include <cstdlib>
    #include <cstring>
    #include <iostream>
    #include <algorithm>
    #define N 600010
    #define ll long long
    #define inf 1000000000000000000ll
    using namespace std;
    inline int read()
    {
        int x=0,f=1;char ch=getchar();
        while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
        while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
        return x*f;
    }
    struct zgz
    {
        int next,to;
    }edge[N];
    int head[N],cnt=1;
    void add(int from,int to)
    {
        edge[cnt].to=to;
        edge[cnt].next=head[from];
        head[from]=cnt++;
    }
    ll ans1[N],ans2[N];
    ll Mx_(ll a,ll b)
    {return a>b?a:b;}
    ll Mn_(ll a,ll b)
    {return a<b?a:b;}
```
namespace SAM
     
```cpp
    {
        int ch[N][26],fail[N];
        int mx[N],sz[N];
        ll Mx[N],Mn[N];
        int last=1,tot=1;
        void ins(int x,int w)
        {
            int np=++tot,p=last,q,nq;
            last=np,mx[np]=mx[p]+1,sz[np]=1,Mx[np]=Mn[np]=w;
            while(p&&!ch[p][x])ch[p][x]=np,p=fail[p];
            if(p==0){fail[np]=1;return ;}
            q=ch[p][x];
            if(mx[q]==mx[p]+1){fail[np]=q;return ;}
            nq=++tot,mx[nq]=mx[p]+1;
            memcpy(ch[nq],ch[q],sizeof(ch[q]));
            fail[nq]=fail[q],fail[q]=fail[np]=nq;
            while(p&&ch[p][x]==q)ch[p][x]=nq,p=fail[p];
        }
        void build()
        {
            for(int i=2;i<=tot;i++)
            add(fail[i],i);
        }
        bool ok(int x)
        {return Mx[x]!=-inf&&Mn[x]!=inf;}
        void dfs(int x)
        {
            if(!Mn[x]&&!Mx[x])Mn[x]=inf,Mx[x]=-inf;
            for(int i=head[x];i;i=edge[i].next)
            {
                int to=edge[i].to;
                dfs(to);
                if(ok(x)&&ok(to))
                ans2[mx[x]]=Mx_(ans2[mx[x]],Mx_(Mx[x]*Mx[to],Mn[x]*Mn[to]));
                ans1[mx[x]]+=(ll)sz[x]*sz[to];
                Mx[x]=Mx_(Mx[x],Mx[to]);
                Mn[x]=Mn_(Mn[x],Mn[to]);
                sz[x]+=sz[to];
            }
        }
    }
    int n;
    char s[N];
    ll a[N];
    int main()
    {
        n=read();
        scanf("%s",s+1);
        for(int i=1;i<=n;i++)a[i]=read();
        for(int i=n;i>=1;i--)SAM::ins(s[i]-'a',a[i]);
        for(int i=0;i<=n;i++)ans2[i]=-inf;
        SAM::build();
        SAM::dfs(1);
        for(int i=n-1;i>=0;i--)
        ans2[i]=Mx_(ans2[i],ans2[i+1]),ans1[i]+=ans1[i+1];
        for(int i=0;i<=n-1;i++)
        if(ans1[i])printf("%lld %lld\n",ans1[i],ans2[i]);
        else puts("0 0");
}
```

---

## 作者：Jμdge (赞：2)

有意思。。。这种 parent 树上树形 dp 的题目真的是...（看多了就好了QWQ）


其实没什么好说的，sam 建完之后直接一遍树形 dp 就出解了

就是要注意一下点权可能为负然后还要维护每个点的 min 信息就好了

好像没什么特别要注意的地方？板子改两下加个 dfs 就好了吧...

```
//by Judge
#include<map>
#include<cstdio>
#include<cstring>
#include<iostream>
#define fp(i,a,b) for(int i=(a),I=(b)+1;i<I;++i)
#define fd(i,a,b) for(int i=(a),I=(b)-1;i>I;--i)
#define go(G,u) for(int i=G.head[u],v=G.e[i].to;i;v=G.e[i=G.e[i].nxt].to)
#define ll long long
using namespace std;
const int inf=1e9+7;
const int M=6e5+3;
typedef int arr[M];
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} inline void reads(string& s){ char c=getchar();
	for(;!isalpha(c);c=getchar());
	for(;isalpha(c);c=getchar()) s+=c;
} char sr[1<<21],z[20];int CCF=-1,Z;
inline void Ot(){fwrite(sr,1,CCF+1,stdout),CCF=-1;}
inline void print(ll x,char chr='\n'){
    if(CCF>1<<20)Ot();if(x<0)sr[++CCF]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++CCF]=z[Z],--Z);sr[++CCF]=chr;
} int n,w[M]; string s;
struct SAM{ int las,cnt; map<char,int> to[M];
	arr fa,len,siz,mx,mx2,mn,mn2; ll sum[M],ans[M];
	SAM(){las=cnt=1;}
	inline void insert(char c,int w){  //主要得到 parent 树 
		int p=las,np=++cnt; las=np,len[np]=len[p]+1,las=np;
		for(;p&&!to[p].count(c);p=fa[p]) to[p][c]=np;
		mx[np]=mn[np]=w,mx2[np]=-inf,mn2[np]=inf,siz[np]=1;
		if(!p) fa[np]=1;
		else{ int q=to[p][c];
			if(len[q]==len[p]+1) fa[np]=q;
			else{ int nq=++cnt; len[nq]=len[p]+1;
				mx[nq]=mx2[nq]=-inf,mn[nq]=mn2[nq]=inf;
				to[nq]=to[q],fa[nq]=fa[q],fa[q]=fa[np]=nq;
				for(;to[p][c]==q;p=fa[p]) to[p][c]=nq;
			}
		}
	}
	struct Gr{ int pat,head[M];
		struct Edge{ int to,nxt; }e[M<<1];
		inline void add(int u,int v){
			e[++pat]={v,head[u]},head[u]=pat;
		}
	}G;
	template<class T>inline T Max(T a,T b){return a>b?a:b;}
	template<class T>inline T Min(T a,T b){return a<b?a:b;}
	inline void cmax(int u,int w){
		if(w>mx[u]) mx2[u]=mx[u],mx[u]=w;
		else mx2[u]=Max(mx2[u],w);
	}
	inline void cmin(int u,int w){
		if(w<mn[u]) mn2[u]=mn[u],mn[u]=w;
		else mn2[u]=Min(mn2[u],w);
	}
	void dfs(int u){ int sz=0;  //在 parent 树上树形 dp  
		go(G,u) dfs(v),sz+=siz[v],
			cmax(u,mx[v]),cmax(u,mx2[v]),
			cmin(u,mn[v]),cmin(u,mn2[v]);
		if(sz+siz[u]<2) return ;
		ans[len[u]]=Max(ans[len[u]],Max(1ll*mx[u]*mx2[u],1ll*mn[u]*mn2[u]));  //点权有负数要注意（负负得正） 
		go(G,u) sum[len[u]]+=1ll*siz[u]*siz[v],siz[u]+=siz[v];  //得到当前点的 siz 和 sum ，sum 为总方案数 
	}
	inline void calc(){
		mx[1]=mx2[1]=-inf,mn[1]=mn2[1]=inf;  //注意根节点要设无解（不设好像没关系？） 
		memset(ans,-63,sizeof ans);
		fp(i,2,cnt) G.add(fa[i],i); dfs(1);
		fd(i,n-1,0) sum[i]+=sum[i+1],ans[i]=Max(ans[i],ans[i+1]);
		fp(i,0,n-1) print(sum[i],' '),print(!sum[i]?0:ans[i]);
	}
}p;
int main(){ n=read(),reads(s);
	fp(i,0,n-1) w[i]=read();
	fd(i,n-1,0) p.insert(s[i],w[i]);
	return p.calc(),Ot(),0;
}
```


但我还想要说的是，这里可以不用 dfs 

我们考虑用 sa 的模型代替树形 dp （注意着实质上还是树形 dp ）

于是常数-- ，码量--，思考？++吧...

```
//by Judge
#include<map>
#include<cstdio>
#include<cstring>
#include<iostream>
#define fp(i,a,b) for(int i=(a),I=(b)+1;i<I;++i)
#define fd(i,a,b) for(int i=(a),I=(b)-1;i>I;--i)
#define ll long long
using namespace std;
const int inf=1e9+7;
const int M=6e5+3;
typedef int arr[M];
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} inline void reads(string& s){ char c=getchar();
	for(;!isalpha(c);c=getchar());
	for(;isalpha(c);c=getchar()) s+=c;
} char sr[1<<21],z[20];int CCF=-1,Z;
inline void Ot(){fwrite(sr,1,CCF+1,stdout),CCF=-1;}
inline void print(ll x,char chr='\n'){
    if(CCF>1<<20)Ot();if(x<0)sr[++CCF]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++CCF]=z[Z],--Z);sr[++CCF]=chr;
} int n,w[M]; string s;
struct SAM{ int las,cnt; map<char,int> to[M];
	arr c,sa,fa,len,siz,mx,mx2,mn,mn2; ll sum[M],ans[M];
	SAM(){las=cnt=1;}
	inline void insert(char c,int w){  //主要得到 parent 树 
		int p=las,np=++cnt; las=np,len[np]=len[p]+1,las=np;
		for(;p&&!to[p].count(c);p=fa[p]) to[p][c]=np;
		mx[np]=mn[np]=w,mx2[np]=-inf,mn2[np]=inf,siz[np]=1;
		if(!p) fa[np]=1;
		else{ int q=to[p][c];
			if(len[q]==len[p]+1) fa[np]=q;
			else{ int nq=++cnt; len[nq]=len[p]+1;
				mx[nq]=mx2[nq]=-inf,mn[nq]=mn2[nq]=inf;
				to[nq]=to[q],fa[nq]=fa[q],fa[q]=fa[np]=nq;
				for(;to[p][c]==q;p=fa[p]) to[p][c]=nq;
			}
		}
	}
	template<class T>inline T Max(T a,T b){return a>b?a:b;}
	template<class T>inline T Min(T a,T b){return a<b?a:b;}
	inline void cmax(int u,int w){ if(w>mx[u]) mx2[u]=mx[u],mx[u]=w; else mx2[u]=Max(mx2[u],w); }
	inline void cmin(int u,int w){ if(w<mn[u]) mn2[u]=mn[u],mn[u]=w; else mn2[u]=Min(mn2[u],w); }
	inline void solv(){ fp(i,1,cnt) ++c[len[i]]; memset(ans,-63,sizeof ans);
		fp(i,2,cnt) c[i]+=c[i-1]; fp(i,1,cnt) sa[c[len[i]]--]=i;
		fd(i,cnt,1){ int p=sa[i]; sum[len[fa[p]]]+=1ll*siz[fa[p]]*siz[p],siz[fa[p]]+=siz[p];
			cmax(fa[p],mx[p]),cmax(fa[p],mx2[p]),cmin(fa[p],mn[p]),cmin(fa[p],mn2[p]);
			if(siz[p]>1) ans[len[p]]=Max(ans[len[p]],Max(1ll*mx[p]*mx2[p],1ll*mn[p]*mn2[p]));
		}
		fd(i,n-1,0) sum[i]+=sum[i+1],ans[i]=Max(ans[i],ans[i+1]);
		fp(i,0,n-1) print(sum[i],' '),print(!sum[i]?0:ans[i]);
	}
}p;
int main(){ n=read(),reads(s);
	fp(i,0,n-1) w[i]=read();
	fd(i,n-1,0) p.insert(s[i],w[i]);
	return p.solv(),Ot(),0;
}
```



---

## 作者：lcjqwq (赞：1)

### Description 

给定字符串 $s$ ，和每个位置上的权值 $a_i$。对于每一个 $i \in [0, n)$ 求出有多少对 $(i, j)$  满足 $LCP(sa_i, sa_j) \ge i$ 以及在这些 $(i, j)$ 中 $a_i \times a_j$  最大是多少。$sa_i$ 表示从 $i$ 开始的后缀。

### Solution

将原串反过来建 SAM 求得后缀树。考虑后缀树上一个节点 $u$ ，这个节点代表的子串是他的任意后代的后缀 。所以每两个在其子树中的点都会对第一问的答案造成贡献。只需要维护 right 集合的大小即可。

对于第二问，乘积最大有两种可能：一个是最大的两个相乘，一个是最小的两个相乘（负负得正）。所以只需要在 dfs 的时候顺便维护子树中的最大值和最小值，与子树合并的时候维护处答案。

最后再从后往前更新一遍答案。因为小的肯定包含在大的中，对第一问做加法，第二问取 max

具体看代码

### Code

[看代码戳这里](https://acfunction.github.io/2019/05/03/BZOJ4199/#Code)

---

## 作者：kouylan (赞：1)

看到题首先求出 $sa_i$ 和 $ht_i$。

我们想，只要求出字符串恰好 $r$ 相似的答案，再用前缀和以及后缀取 $\max$，就可以求出答案。所以我们就要求恰好 $r$ 相似时的 $ans1(r),ans2(r)$。

使用并查集，记录大小 $siz$，最大、次大、最小、次小值分别是 $mx1,mx2,mn1,mn2$（为什么要记录最小和次小值呢？因为权值 $a_i$ 会有负数，负负得正有可能成为最大解）。

合并时，$siz$ 相加，最大次大值取两个 $mx1$ 和两个 $mx2$ 中的前两大的值，最小次小值同理，最大解就是 $\max(mx1\times mx2,mn1\times mn2)$。

然后我们考虑按什么顺序合并。因为 $lcp(i,j)=\min\{ht_i\dots ht_j\}$，所以可以按 $ht_i$ 的降序排列，然后依次合并，这样就可以保证在合并到当前位置时，这个区间的 $lcp$ 长度一定是 $ht_i$。

记录答案时，$ans1$ 采用差分，在 $[0,ht_i]$ 的区间中加上 $siz(x)\times siz(y)$，$ans2=\max\{ans2,mx(x),mx(y)\}$。

然后就做完了。

下面是 AC 代码。

```cpp
/*
luogu P2178
*/
#include <bits/stdc++.h>
using namespace std;

#define int long long

const int INF = 0x7f7f7f7f;

int n,k,a[300005],ans1[300005],ans2[300005];
char str[300005];
int sa[300005],ht[300005],rk[300005],rk2[300005];
int dsu[300005],mx[300005],siz[300005];
int mx1[300005],mx2[300005],mn1[300005],mn2[300005];
pair<int,int> p[300005];

bool cmp(int i,int j)
{
	if(rk[i]!=rk[j])
		return rk[i]<rk[j];
	int ri=(i+k<=n ? rk[i+k] : -1);
	int rj=(j+k<=n ? rk[j+k] : -1);
	return ri<rj;
}

void getsa(int n,char *str)
{
	for(int i=1;i<=n;i++)
		sa[i] = i, rk[i] = str[i];
	for(k=1;k<=n;k*=2)
	{
		sort(sa+1,sa+1+n,cmp);
		rk2[sa[1]] = 1;
		for(int i=2;i<=n;i++)
			rk2[sa[i]] = rk2[sa[i-1]]+cmp(sa[i-1],sa[i]);
		for(int i=1;i<=n;i++)
			rk[i] = rk2[i];
	}
}

void getht(int n,char *str)
{
	for(int i=1;i<=n;i++)
		rk[sa[i]] = i;
	int h=0;
	ht[1] = 0;
	for(int i=1;i<=n;i++)
	{
		int j=sa[rk[i]-1];
		if(h>0)
			h--;
		for(;j+h<=n&&i+h<=n;h++)
			if(str[j+h]!=str[i+h])
				break;
		ht[rk[i]] = h;
	}
}

bool cmpp(pair<int,int> a,pair<int,int> b)
{
	return a.first>b.first;
}

int find_(int x)
{
	return dsu[x]==x ? x : dsu[x]=find_(dsu[x]);
}

void union_(int x,int y)
{
	int p[5]={0,mx1[x],mx2[x],mx1[y],mx2[y]};
	int q[5]={0,mn1[x],mn2[x],mn1[y],mn2[y]};
	sort(p+1,p+5), sort(q+1,q+5);
	siz[dsu[x]] += siz[dsu[y]];
	mx1[dsu[x]] = p[4], mx2[dsu[x]] = p[3];
	mn1[dsu[x]] = q[1], mn2[dsu[x]] = q[2];
	mx[dsu[x]] = max(mx[dsu[x]],max(mx1[dsu[x]]*mx2[dsu[x]],mn1[dsu[x]]*mn2[dsu[x]]));
	dsu[y] = dsu[x];
}

signed main()
{
	scanf("%lld%s",&n,str+1);
	for(int i=1;i<=n;scanf("%lld",a+i),i++);
	getsa(n,str), getht(n,str);
	for(int i=1;i<=n;i++)
	{
		dsu[i] = i, siz[i] = 1;
		mx1[i] = a[sa[i]], mx2[i] = -(1ll<<61);
		mn1[i] = a[sa[i]], mn2[i] = 1ll<<61;
		mx[i] = -(1ll<<61);
	}
	for(int i=2;i<=n;i++)
		p[i] = make_pair(ht[i],i);
	sort(p+2,p+1+n,cmpp);
	memset(ans2,-INF,sizeof(ans2));
	for(int i=2;i<=n;i++)
	{
		int u=p[i].second,h=p[i].first;
		int fx=find_(u),fy=find_(u-1);
		ans1[0] += siz[fx]*siz[fy];
		ans1[h+1] -= siz[fx]*siz[fy];
		union_(fx,fy);
		ans2[h] = max(ans2[h],mx[fx]);
	}
	for(int i=1;i<=n;i++)
		ans1[i] += ans1[i-1];
	for(int i=n-1;i>=0;i--)
		ans2[i] = max(ans2[i],ans2[i+1]);
	for(int i=0;i<n;i++)
		printf("%lld %lld\n",ans1[i],(ans1[i]>0 ? ans2[i] : 0));
	
	return 0;
}
```

祝大家 AC 愉快！

---

## 作者：BlankAo (赞：1)

**广义后缀树**题解。

对 $S$ 建立广义后缀树。那么如果一个点到根节点的距离为 $x$，父边长度为 $len$，它的子树的叶子节点有 $a$ 个，那么相当于 $(x-len)\sim x$ 这一段都会产生贡献，即贡献 $a$ 个互相 $(x-len)$ 相似的、 $(x-len+1)$ 相似的、……、$x$ 相似的，也就是 $\Large\frac{a(a-1)}{2}$ 对。

最大值同理，因为每一个叶子节点代表从 $i$ 开始一段后缀，所以找到这些叶子的最大权值 $val_i$ 乘积即可。因为负负得正，所以你要同时维护最大值、次大值、次小值、最小值。也是对 $(x-len)\sim x$ 产生贡献。

所以变成了区间更新、单点查值（最后要对于 $0\sim n-1$ 分别查一次值），显然应用分块模板即可。复杂度 $O(n\sqrt n)$。

```c++
#include<bits/stdc++.h>
#define rep(i,x,y) for(int i=x;i<=y;++i)
#define lon long long
#define mar(o) rep(i,1,27)
#define v dot[o].son[i] 
using namespace std;
const int n7=301234,b7=648;const lon inf=1e9,infz=1e18+1000;
struct beer{int sta,len,fail;bool islaf;int son[29];}dot[n7*2];
struct dino{lon mxa1,mxa2,mni1,mni2,siz,cntz;};
int n,B,kwei[n7],kl[b7],kr[b7],cr[n7];
int cnt,now,las,rem;
lon a[n7],blo1[n7],tag1[b7],blo2[n7],tag2[b7];

int rd(){
	int shu=0;bool fu=0;char ch=getchar();
	while( !isdigit(ch) ){if(ch=='-')fu=1;ch=getchar();}
	while( isdigit(ch) )shu=(shu<<1)+(shu<<3)+ch-'0',ch=getchar();
	return fu?-shu:shu;
}

void sesmet1(){
	cnt=1,now=1,dot[0].len=inf;
}

void sesmet2(){
	rep(i,1,n+1)kwei[i]=(i-1)/B+1;
	rep(i,1,B+2)kl[i]=(i-1)*B+1,kr[i]=i*B;
	rep(i,1,n+1)blo2[i]=-infz;
	rep(i,1,B+2)tag2[i]=-infz;	
}

int Dnew(int sta,int len){
	cnt++,dot[cnt]=(beer){sta,len,1,(len==inf)};
	return cnt;
}

void isert(int id){
	rem++,las=1;
	while(rem){
		while(rem>dot[ dot[now].son[ cr[id-rem+1] ] ].len){
			now=dot[now].son[ cr[id-rem+1] ];
			rem-=dot[now].len;
		}
		int &z=dot[now].son[ cr[id-rem+1] ];
		int ch=cr[ dot[z].sta+rem-1 ];
		if(!z||cr[id]==ch){
			dot[las].fail=now,las=now;
			if(!z)z=Dnew(id,inf);
			else return;
		}
		else{
			int fut=Dnew(dot[z].sta,rem-1);
			dot[fut].son[ch]=z;
			dot[fut].son[ cr[id] ]=Dnew(id,inf);
			dot[z].sta+=rem-1,dot[z].len-=rem-1;
			z=fut,dot[las].fail=fut,las=fut;
		}
		if(now==1)rem--;
		else now=dot[now].fail;
	}
}

void fixinf(int len){
	rep(i,1,cnt){
		if(dot[i].islaf)dot[i].len=len-dot[i].sta+1-1;
	}
}

//blo1 siz ; blo2 max
void updat(int l,int r,lon siz,lon mxa){
	if(l>r)l=r=0;
	l++,r++;
	if(kwei[l]==kwei[r]){
		rep(i,l,r)blo1[i]+=siz,blo2[i]=max(blo2[i],mxa);
	}
	else{
		rep(i,l,kr[ kwei[l] ])blo1[i]+=siz,blo2[i]=max(blo2[i],mxa);
		rep(i,kl[ kwei[r] ],r)blo1[i]+=siz,blo2[i]=max(blo2[i],mxa);
		rep(i,kwei[l]+1,kwei[r]-1)tag1[i]+=siz,tag2[i]=max(tag2[i],mxa);
	}
}

dino dfs(int o,int sep){
	sep+=dot[o].len;
	dino z=(dino){-inf,-inf,inf,inf,0,0};
	if(dot[o].islaf){
		if(sep)z.siz=1,z.cntz=1,z.mxa1=z.mni1=a[n-sep+1];
	}
	else{
		mar(o){
			if(v){
				dino tmp=dfs(v,sep);
				z.siz+=tmp.siz,z.cntz+=tmp.cntz;
				
				if(tmp.mxa1>=z.mxa1)z.mxa2=z.mxa1,z.mxa1=tmp.mxa1;
				else if(tmp.mxa1>z.mxa2)z.mxa2=tmp.mxa1;
				if(tmp.mxa2>=z.mxa1)z.mxa2=z.mxa1,z.mxa1=tmp.mxa2;
				else if(tmp.mxa2>z.mxa2)z.mxa2=tmp.mxa2;
				
				if(tmp.mni1<=z.mni1)z.mni2=z.mni1,z.mni1=tmp.mni1;
				else if(tmp.mni1<z.mni2)z.mni2=tmp.mni1;
				if(tmp.mni2<=z.mni1)z.mni2=z.mni1,z.mni1=tmp.mni2;
				else if(tmp.mni2<z.mni2)z.mni2=tmp.mni2;
			}
		}		
	}
	lon tmp=max(z.mxa1*z.mxa2,z.mni1*z.mni2);
	if(z.cntz<2)tmp=-infz;
	updat(sep-dot[o].len+1,sep,z.siz*(z.siz-1)/2ll,tmp);
	return z;
}

int main(){
	n=rd(),B=sqrt(n);
	sesmet1(),sesmet2();
	rep(i,1,n)cr[i]=getchar()-'a'+1,isert(i);
	
	n++;
	cr[n]=27,isert(n),fixinf(n);
	n--;
	
	rep(i,1,n)a[i]=rd();
	dfs(1,0);
	rep(i,1,n){
		printf("%lld ",blo1[i]+tag1[ kwei[i] ]);
		if( !(blo1[i]+tag1[ kwei[i] ]) )puts("0");
		else printf("%lld\n", max(blo2[i],tag2[ kwei[i] ]) );
	}
	return 0;
}
```

---

## 作者：y2823774827y (赞：1)

###
**$\Longrightarrow\Longrightarrow\Longrightarrow$[更好的阅读体验](https://www.cnblogs.com/y2823774827y/p/10515232.html)**

后缀数组一眼题系列

$r$相似用$height$数组处理，每次按$height$分裂区间，显然是有单调性的

所求的$r_0^{n-1}$，$O(n^2)$是过不了的
利用单调性，上烂大街的离线并查集
并查集要维护：大小,最大值,次大值,最小值,次小值(由于这里$a_i$为整数，所以答案可能由最小值与次小值贡献)

细节还是挺多的

```cpp
#include<bits/stdc++.h>
#include<vector>
using namespace std;
typedef long long LL;
inline LL Read(){
    LL x(0),f(1); char c=getchar();
    while(c<'0' || c>'9'){ if(c=='-') f=-1; c=getchar(); }
    while(c>='0' && c<='9') x=(x<<3)+(x<<1)+c-'0', c=getchar();
    return x*f;
}
const LL maxn=1e6+9,inf=(1e18+1);
LL n,ans,sum,va,m;
LL c[maxn],x[maxn],sa[maxn],y[maxn],size[maxn],fa[maxn],rk[maxn],hei[maxn],w[maxn],tmp[maxn][2];
LL mx[maxn],cx[maxn],mi[maxn],ci[maxn];
bool visit[maxn],vx[maxn],vi[maxn];
char s[maxn];
inline void Get_sa(){
    for(LL i=1;i<=n;++i) ++c[x[i]=(LL)(s[i]-'a'+1)];
    for(LL i=2;i<=m;++i) c[i]+=c[i-1];
    for(LL i=n;i>=1;--i) sa[c[x[i]]--]=i;
    for(LL len=1;len<=n;len<<=1){
        LL num(0);
        for(LL i=n-len+1;i<=n;++i) y[++num]=i;
        for(LL i=1;i<=n;++i) if(sa[i]>len) y[++num]=sa[i]-len;
        for(LL i=1;i<=m;++i) c[i]=0;
        for(LL i=1;i<=n;++i) ++c[x[i]];
        for(LL i=2;i<=m;++i) c[i]+=c[i-1];
        for(LL i=n;i>=1;--i) sa[c[x[y[i]]]--]=y[i],y[i]=0;
        memcpy(y,x,sizeof(x));
        x[sa[1]]=num=1;
        for(LL i=2;i<=n;++i)
            x[sa[i]]=(y[sa[i]]==y[sa[i-1]] && y[sa[i]+len]==y[sa[i-1]+len])?num:++num;
        if(num==n) break;
        m=num;
    }
    for(LL i=1;i<=n;++i) rk[sa[i]]=i;
    LL ret(0);
    for(LL i=1;i<=n;++i){
        if(ret) --ret;
        LL j(sa[rk[i]-1]);
        while(s[j+ret]==s[i+ret]) ++ret;
        hei[rk[i]]=ret;
    }
}
LL Get_f(LL x){ return fa[x]==x?x:fa[x]=Get_f(fa[x]); }
inline void Del(LL x){
    sum-=((size[x]-1)*size[x])/2;
}
inline void Merge(LL x,LL y){
    fa[x]=y;
    if(mx[x]>mx[y]){
        cx[y]=mx[y];
        mx[y]=mx[x];
        if(vx[x] && cx[x]>cx[y])
            cx[y]=cx[x];
    }else
        cx[y]=(vx[y]?max(cx[y],mx[x]):mx[x]);
    if(mi[x]<mi[y]){
        ci[y]=mi[y];
        mi[y]=mi[x];
        if(vi[x] && ci[x]<ci[y])
            ci[y]=ci[x];
    }else
        ci[y]=(vi[y]?min(ci[y],mi[x]):mi[x]);
    vx[y]=vi[y]=true;
    size[y]+=size[x];
    sum+=((size[y]-1)*size[y]>>1);
    ans=max(ans,max(mx[y]*cx[y],mi[y]*ci[y]));
}
vector<LL>mark[maxn];
int main(){
    n=Read();
    scanf(" %s",s+1);
    for(LL i=1;i<=n;++i) w[i]=Read();
    m=26; Get_sa();
    for(LL i=1;i<=n;++i) mark[hei[i]].push_back(i);
    for(LL i=1;i<=n;++i) fa[i]=i;
    for(LL i=1;i<=n;++i){
        mx[i]=mi[i]=w[i];
        vx[i]=vi[i]=false;
    }
    ans=-inf;
    for(LL i=1;i<=n;++i) size[i]=1;
    for(LL i=n-1;i>=0;--i){
        for(LL j=0;j<mark[i].size();++j){
            LL x(sa[mark[i][j]]);
            visit[x]=true;
            LL sax(rk[x]), nxt(sa[sax+1]),pre(sa[sax-1]);
            LL fy(Get_f(pre));
            Del(x); Del(fy);
            Merge(x,fy);
        }
        tmp[i][0]=sum; tmp[i][1]=(ans<=-inf?0:ans);
    }
    for(LL i=0;i<n;++i) printf("%lld %lld\n",tmp[i][0],tmp[i][1]);
    return 0;
}
```

---

## 作者：fighter_OI (赞：1)

可能是当年第二简单题……

首先考虑两杯酒的最大相似度就是这两个后缀的lcp

考虑反串sam转后缀树，楼下很清楚，此处不再赘述

值得一提的是在lca处统计时，第二问答案要维护最大值mx，次大值_mx，最小值mn，次小值_mn，答案就是max(mx × _mx,mn × _mn)

其实可以不用把后缀树建出来，拓扑排序一下也可以（偷懒）

另外相似度为0要特判~~可能是我写糟了~~

```cpp
#include<cstdio>
#include<algorithm>
#include<cstdlib>
#include<cstring>
#include<memory.h>
#include<map>
#include<set>
#include<queue>
using namespace std;
const int maxn=300005,inf=1e9+5;
char str[maxn];
int n,v[maxn];
typedef long long LL;
struct SAM//后缀自动机
{
	int ch[maxn<<1][26],l[maxn<<1],fa[maxn<<1],cnt,last;
	int mx[maxn<<1],_mx[maxn<<1],mn[maxn<<1],_mn[maxn<<1];
	int a[maxn<<1],c[maxn<<1],siz[maxn<<1];//最大值，次大值，最小值，次小值
	LL sum[maxn<<1],maxi[maxn<<1];
	inline void ins(int c,int val)//基本操作
	{
		int p=last,np=++cnt;
		last=np;
		siz[np]=1;
		l[np]=l[p]+1; 
		mx[np]=mn[np]=val;
		_mx[np]=-inf;
		_mn[np]=inf;
		for(;p&&!ch[p][c];p=fa[p])ch[p][c]=np;
		if(!p)fa[np]=1;else
		{
			int q=ch[p][c];
			if(l[p]+1==l[q])fa[np]=q;else
			{
				int nq=++cnt;
				mx[nq]=_mx[nq]=-inf;
				mn[nq]=_mn[nq]=inf;
				l[nq]=l[p]+1;
				memcpy(ch[nq],ch[q],sizeof ch[q]);
				fa[nq]=fa[q];fa[q]=fa[np]=nq;
				for(;ch[p][c]==q;p=fa[p])ch[p][c]=nq;
			}
		}
	}
	inline void build()//建sam
	{
		scanf("%d",&n);
		last=cnt=1;
		mx[1]=_mx[1]=-inf;
		mn[1]=_mn[1]=inf;
		scanf("%s",str+1);
		for(int i=1;i<=n;i++)scanf("%d",&v[i]);
		for(int i=n;i;i--)ins(str[i]-'a',v[i]);
	}
	inline void up_max(int&mx1,int&_mx1,int mx2,int _mx2)
	{
		if(mx2>mx1){_mx1=max(mx1,_mx2);mx1=mx2;}else _mx1=max(_mx1,mx2);
	}
	inline void up_min(int&mx1,int&_mx1,int mx2,int _mx2)
	{
		if(mx2<mx1){_mx1=min(mx1,_mx2);mx1=mx2;}else _mx1=min(_mx1,mx2);
	}
	inline void solve()//拓扑排序
	{
		for(int i=1;i<=cnt;i++)c[l[i]]++;
		for(int i=1;i<=cnt;i++)c[i]+=c[i-1];
		for(int i=1;i<=cnt;i++)a[c[l[i]]--]=i;
		for(int i=0;i<=n+1;i++)maxi[i]=-1LL*inf*inf;
		for(int i=cnt;i;i--)
		{
			int p=a[i];
			if(siz[p]>1)maxi[l[p]]=max(maxi[l[p]],max(1LL*mx[p]*_mx[p],1LL*mn[p]*_mn[p]));//更新最大值
			up_max(mx[fa[p]],_mx[fa[p]],mx[p],_mx[p]);
			up_min(mn[fa[p]],_mn[fa[p]],mn[p],_mn[p]);
			sum[l[fa[p]]]+=1LL*siz[fa[p]]*siz[p];//更新方案数
			siz[fa[p]]+=siz[p];
		}
		for(int i=n-1;i>=0;i--)
		{
			sum[i]+=sum[i+1];//相似度的性质
			maxi[i]=max(maxi[i],maxi[i+1]);
		}
		sum[0]=1LL*n*(n-1)/2;
		for(int i=0;i<n;i++)printf("%lld %lld\n",sum[i],sum[i]?maxi[i]:0);
	}
}sam;
int main(){sam.build();sam.solve();}
```

---

## 作者：Prean (赞：0)

题意：给定一个字符串，定义两个后缀 $ x $ 和 $ y $ 是 $ r $ 匹配的，仅当 $ r \leq LCP(x,y) $，其中 $ x $ 和 $ y $ 的权值为 $ a_x \times a_y $。

给定一个字符串和每一个后缀的权值，求 $ 0 $ 到 $ n-1 $ 匹配的个数和最大权值。

大板子。

首先后缀匹配的 LCP，容易知道 $ x $ 和 $ y $ 的 LCP 就是其在 parent tree 上的 LCA，但要找到两个后缀在 SAM 上所对应的节点很困难，所以我们对反串构造 SAM 就好了。

剩下的就是统计 SAM 每个节点的 siz 和 最/次 大/小 值。

有一点儿细节。
```cpp
#include<cstring>
#include<cstdio>
const int M=3e5+5,INF=0x3f3f3f3f;
typedef long long ll;
int n,lst=1,tot=1,f[M<<1],len[M<<1],chi[M<<1][26];int val[M];char s[M];
int siz[M<<1],mx1[M<<1],mx2[M<<1],mi1[M<<1],mi2[M<<1];int CB[M],id[M<<1];
ll sum[M<<2],mx[M<<2],mi[M<<2];
inline ll max(const ll&a,const ll&b){
	return a>b?a:b;
}
inline ll min(const ll&a,const ll&b){
	return a>b?b:a;
}
inline void Insert(const int&s){
	int q,p,nq,np;
	p=lst;len[np=lst=++tot]=len[p]+1;
	while(p&&!chi[p][s])chi[p][s]=np,p=f[p];
	if(!p)f[np]=1;
	else{
		if(len[q=chi[p][s]]==len[p]+1)f[np]=q;
		else{
			len[nq=++tot]=len[p]+1;f[nq]=f[q];f[np]=f[q]=nq;
			memcpy(chi[nq],chi[q],104);while(p&&chi[p][s]==q)chi[p][s]=nq,p=f[p];
		}
	}
}
void Modify(const int&u,const int&l,const int&r,const ll&V,const ll&S,const int&L=1,const int&R=n){
	if(l>r||L>r||l>R)return;if(l<=L&&R<=r)return mx[u]=max(mx[u],V),sum[u]+=S,void();
	int mid=L+R>>1;Modify(u<<1,l,r,V,S,L,mid);Modify(u<<1|1,l,r,V,S,mid+1,R);
}
void DFS(const int&u,const int&L=1,const int&R=n){
	mx[u]=max(mx[u],mx[u>>1]);sum[u]+=sum[u>>1];
	if(L==R)return void(L!=n&&printf("%lld %lld\n",sum[u],sum[u]?mx[u]:0));
	int mid=L+R>>1;DFS(u<<1,L,mid);DFS(u<<1|1,mid+1,R);
}
inline ll prod(const int&x,const int&y){
	return x&&y&&x^y?1ll*val[x]*val[y]:-1ll*INF*INF;
}
signed main(){
	int i,u;ll V;scanf("%d%s",&n,s+1);
	for(i=1;i<=n;++i)scanf("%d",val+i);
	for(i=0;i<=(n<<2);++i)mx[i]=-1ll*INF*INF;
	for(i=1;i<=(n<<1);++i)mi1[i]=mi2[i]=mx1[i]=mx2[i]=0;
	for(i=n;i>=1;--i)Insert(s[i]-97),mx1[lst]=mi1[lst]=i,siz[lst]=1;
	for(i=1;i<=tot;++i)++CB[len[i]];
	for(i=1;i<=n;++i)CB[i]+=CB[i-1];
	for(i=tot;i>=1;--i)id[CB[len[i]]--]=i;
	for(i=tot;i>=1;--i){
		u=id[i];siz[f[u]]+=siz[u];
		if(val[mx1[u]]>val[mx1[f[u]]]||!mx1[f[u]]){
			mx2[f[u]]=val[mx1[f[u]]]>val[mx2[u]]?mx1[f[u]]:mx2[u];mx1[f[u]]=mx1[u];
		}
		else if(val[mx1[u]]>val[mx2[f[u]]])mx2[f[u]]=mx1[u];
		if(val[mi1[u]]<val[mi1[f[u]]]||!mi1[f[u]]){
			mi2[f[u]]=val[mi1[f[u]]]<val[mi2[u]]?mi1[f[u]]:mi2[u];mi1[f[u]]=mi1[u];
		}
		else if(val[mi1[u]]<val[mi2[f[u]]])mi2[f[u]]=mi1[u];
		V=max(max(prod(mx1[u],mx2[u]),prod(mi1[u],mx2[u])),max(prod(mx1[u],mi2[u]),prod(mi1[u],mi2[u])));
		V=max(V,prod(mx1[u],mi1[u]));
		if(i==1)printf("%lld %lld\n",1ll*siz[i]*(siz[i]-1)/2,V);
		else Modify(1,len[f[u]]+1,len[u],V,1ll*siz[u]*(siz[u]-1)/2);
	}
	u=id[1];siz[f[u]]+=siz[u];DFS(1);
}
```

---

## 作者：KokiNiwa (赞：0)

# [NOI2015]品酒大会

[题目链接](https://www.luogu.com.cn/problem/P2178)

## 题目叙述

给你一个字符串，每个后缀有一个权值，求后缀中任意两个最长公共前缀长度为$i$的一共有多少对，权值乘积最大为多少。

## 题解

后缀树简单题，但细节繁琐。首先建立后缀树，两个后缀的公共前缀长度为那两个后缀结尾在树上```LCA```的深度。对于一个相似值$r$，求出相似值恰好为$r$的有多少个，然后迭代一下就得出答案。那么如何求相似值恰好为$r$的呢？看深度为$r$的节点子树中有多少对不在同一颗子树内的叶节点对即可（这个容易求吧，大不了就$n^2$暴力，一共顶多$26$个儿子）。然后再求出子树内的最大、次大，最小、次小，因为权值积最大一定为最大与次大的乘积或最小与次小的乘积（考虑最大次大、最小次小是否同号）。问题就解决了。

## 代码

[Link](https://www.luogu.com.cn/paste/c4wlj3sf)

---

## 作者：埃罗芒阿老师· (赞：0)

思路{


大力出奇迹！！不是一般的鬼。。。。。。。。。。。


首先看到题面肯定是后缀数组了啦。。。。。


最直观的方法是暴力将height分组查询，用计数原理统计。这样有40分


(然而，我只有30....查询最小和次小,最大和次大的特判太多了。。。)


考虑优化。


1.由于每两个相同子串(设串长为R)它的答案也是在这两端中比R小的串长的答案的一部分,


那我就按R从大到小排序,所以用到了height数组。


2.怎么更新答案？？？？？？


用并查集维护height的sa[i]与sa[i-1]的Max,Min,Sz.我们只关心的是当前匹配的这个点的数量，只需统计当前的即可，


又由于可能会有遗漏(在for枚举的时候，并没有考虑R包含的情况)在最后还要在更新一下。


具体不说了，这个也是需要自己YY的。。。。。。。。


}

---

## 作者：不存在之人 (赞：0)

第一问直接建出后缀数组之后，算出每一个点有贡献的区间，用height数组从小到大更新答案。 

第二问可以用并查集，因为是从小到大做的，所以产生贡献的区间会不断扩大，这样就可以每次把产生贡献的区间[l,r]并起来，并且这一段中的元素最多只会属于两个集合，每次在并查集的过程中保存一下当前集合的最大值和最小值更新答案就行了。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define LL long long
const int N=300010;
char s[N];
LL sum[N],ans[N];
int n,m,t1[N],t2[N],c[N],sa[N],rank[N],height[N],stack[N],l[N],r[N],top,point[N],next[N],tot,en[N],b[N],fa[N],maxn[N],minn[N];
inline int in(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
    return x*f;
}
inline void add(int x,int y){
    next[++tot]=point[x];point[x]=tot;en[tot]=y;
}
inline bool cmp(int *y,int p,int q,int k){
    int o0,o1;
    o0=p+k>=n?-1:y[p+k];
    o1=q+k>=n?-1:y[q+k];
    return o0==o1&&y[p]==y[q];
}
inline void build_sa(){
    int i,k,p,*x=t1,*y=t2;
    for(m=26,i=0;i<m;++i) c[i]=0;
    for(i=0;i<n;++i) ++c[x[i]=s[i]-'a'];
    for(i=1;i<m;++i) c[i]+=c[i-1];
    for(i=n-1;~i;--i) sa[--c[x[i]]]=i;
    for(k=1;k<=n;k<<=1){
        for(p=0,i=n-k;i<n;++i) y[p++]=i;
        for(i=0;i<n;++i) if(sa[i]>=k) y[p++]=sa[i]-k;
        for(i=0;i<m;++i) c[i]=0;
        for(i=0;i<n;++i) ++c[x[y[i]]];
        for(i=1;i<m;++i) c[i]+=c[i-1];
        for(i=n-1;~i;--i) sa[--c[x[y[i]]]]=y[i];
        swap(x,y);
        x[sa[0]]=0;m=1;
        for(i=1;i<n;++i) x[sa[i]]=cmp(y,sa[i],sa[i-1],k)?m-1:m++;
        if(m>=n) break;
    }
}
inline void build_height(){
    int i,j,k=0;
    for(i=0;i<n;++i) rank[sa[i]]=i;
    for(i=0;i<n;++i){
        if(!rank[i]) continue;
        k=k?k-1:k;
        j=sa[rank[i]-1];
        while(s[i+k]==s[j+k]) ++k;
        height[rank[i]]=k;
    }
}
inline int find(int x){
    if(x!=fa[x]) fa[x]=find(fa[x]);
    return fa[x];
}
int main(){
    int i,j;
    n=in();
    for(i=0;i<n;++i){
        char ch=getchar();
        while(ch<'a'||ch>'z') ch=getchar();
        s[i]=ch;
    }
    build_sa();
    build_height();
    for(i=0;i<n;++i){
        fa[i]=i;
        b[i]=minn[rank[i]]=maxn[rank[i]]=in();
    }
    stack[top=1]=0;
    for(l[0]=0,i=1;i<n;++i){
        while(top&&height[stack[top]]>height[i]) --top;
        l[i]=top?stack[top]+1:0;
        stack[++top]=i;
    }
    stack[top=1]=n-1;
    for(r[n-1]=n-1,i=n-2;i>=0;--i){
        while(top&&height[stack[top]]>=height[i]) --top;
        r[i]=top?stack[top]-1:n-1;
        stack[++top]=i;
    }
    for(i=0;i<n;++i) add(height[i],i);
    memset(ans,128,sizeof(ans));
    for(i=n-1;i;--i){
        sum[i]=sum[i+1];
        ans[i]=ans[i+1];
        for(j=point[i];j;j=next[j]){
            int o=en[j],L=l[o],R=r[o];
            sum[i]+=(LL)(o-L+1)*(LL)(R-o+1);
            int r1=find(L-1),r2=find(R);
            ans[i]=max(ans[i],max((LL)maxn[r1]*(LL)maxn[r2],(LL)minn[r1]*(LL)minn[r2]));
            fa[r2]=r1;
            maxn[r1]=max(maxn[r1],maxn[r2]);
            minn[r1]=min(minn[r1],minn[r2]);
        }
    }
    sort(b,b+n);
    ans[i]=max((LL)b[0]*(LL)b[1],(LL)b[n-1]*(LL)b[n-2]);
    sum[0]=(LL)n*(LL)(n-1)/2;
    for(i=0;i<n;++i) ans[i]=sum[i]?ans[i]:0;
    for(i=0;i<n;++i) printf("%lld %lld\n",sum[i],ans[i]);
}
```

---


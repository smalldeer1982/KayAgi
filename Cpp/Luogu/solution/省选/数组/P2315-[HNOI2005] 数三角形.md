# [HNOI2005] 数三角形

## 题目描述

$%![](https://cdn.luogu.com.cn/upload/pic/1355.png)$

小苏看到一个这样的等边三角形：该等边三角形每边的长度为 $ n $ 且被分成 $ n $ 等份，于是每条边就有 $ n-1 $ 个等分点。而整个三角形被连接两个不同边的等分点且平行于三角形的第三边的线段分成了 $ n^2 $ 个单位等边三角形（边长为 $ 1 $）。下图左是 $ n=5 $ 的情形：

![](https://cdn.luogu.com.cn/upload/image_hosting/5bu420q9.png)

小苏想知道，删除其中的一些短边后，剩下的边一共组成多少个三角形（包括所有边长为 $ m $ 的三角形（$ 1 \leq m < n $），正立的和倒立的都算，只要三角形的 $ 3m $ 条短边都没有被删除就算是组成一个三角形）。例如，上图右就存在 $ 19 $ 个三角形。

## 样例 #1

### 输入

```
5
1 1 1
1 1 0 1 1 0
1 1 1 1 1 1 1 0 1
1 0 1 1 1 1 0 1 1 1 1 1
0 1 1 1 1 1 0 1 1 1 1 1 0 1 1
```

### 输出

```
19```

# 题解

## 作者：Qura (赞：8)

什么？我暴力模拟A了？

预处理出每个底边端点的四个方向可延伸的最大长度。然后枚举底边判断是否构成三角形即可。(图：四个方向)

![](https://cdn.luogu.com.cn/upload/pic/24349.png)

接下来就是喜闻乐见的代码

```cpp
#include <cstdio>
const int N=1000+10;
struct data {
	bool l,r,d;
	void read() {
		scanf("%d%d%d",&l,&r,&d);
	}
} a[N][N];
int n,lu[N][N],ld[N][N],ru[N][N],rd[N][N];
int main() {
	scanf("%d",&n);
	for(int i=1; i<=n; ++i) {
		for(int j=1; j<=i; ++j) {
			a[i][j].read();
		}
	}
	for(int i=1; i<=n; ++i) {
		for(int j=1; j<=i; ++j) {
			if(a[i][j].l) lu[i][j]=lu[i-1][j]+1;
			if(a[i][j].r) ru[i][j]=ru[i-1][j-1]+1;
		}
	}
	for(int i=n; i; --i) {
		for(int j=i; j; --j) {
			if(a[i+1][j].r) ld[i][j]=ld[i+1][j+1]+1;
			if(a[i+1][j+1].l) rd[i][j]=rd[i+1][j]+1;
		}
	}
	int ans=0;
	for(int i=1; i<=n; ++i) {
		for(int j=1; j<=n; ++j) {
			for(int k=j; a[i][k].d && k<=n && (k-j+1)<=lu[i][j]; ++k) {
				ans+=(k-j+1)<=ru[i][k];
			}
			for(int k=j; a[i][k].d && k<=n && (k-j+1)<=ld[i][j]; ++k) {
				ans+=(k-j+1)<=rd[i][k];
			}
		}
	}
	printf("%d\n",ans);
	return 0;
} 
```


---

## 作者：sid_shi1 (赞：1)

# P2315[HNOI2005]数三角形 题解
## 题意：
传送门：[P2315[HNOI2005]数三角形](https://www.luogu.com.cn/problem/P2315)

　　有一个边长为 $n$ 的正三角形网格，去掉其中一些线段，问你在这幅图中有多少个三角形。

## 做法：
我们先定义四个二维数组`lu、ld、ru、rd`，分别存每个点往左上($lu$)，左下($ld$)，右上($ru$)，右下($rd$)最多能走多少步。

然后易得递推公式：

`ru[i+1][j]=ru[i][j]+1`

`lu[i+1][j+1]=lu[i][j]+1`

`ld[i][j]=ld[i+1][j]+1`

`rd[i][j]=rd[i+1][j+1]+1`

```cpp
    //分别求出四种方向最多能走多少步
    for(int i=1;i<=n;i++){
        for(int j=1;j<=i;j++){
            if(a[i][j][1]>0) ru[i+1][j]=ru[i][j]+1;//递推
            if(a[i][j][2]>0) lu[i+1][j+1]=lu[i][j]+1;
        }
    }
    for(int i=n;i>=1;i--){
        for(int j=i;j>=1;j--){
            if(a[i][j][1]>0) ld[i][j]=ld[i+1][j]+1;
            if(a[i][j][2]>0) rd[i][j]=rd[i+1][j+1]+1;
        }
    }
```

接着我们枚举每个点为正立的三角形的右下角，首先这个三角形最大边长是 $min(lu_{ij},l_{ij}),min(lu_{ij},l_{ij})$。 

然后我们枚举这个长度 $w$ ，则另一个顶点为 $(i,j−w)$，然后判断  `ru[i][j−w]` 以及 `rd[i][j−w]` 是否大于 $w$，若有，答案数就加一个。 

```
    //枚举三角形右下角
    for(int i=1;i<=n+1;i++){
        for(int j=1;j<=i;j++){
        	//枚举长度w
        	int w=j-1;
        	while(w>0 && a[i-1][w][3] && j-w<=lu[i][j]){
        		if(j-w<=ru[i][w--]) ans++;//答案加一
        	}
        	w=j-1;
        	while(w>0 && a[i-1][w][3] && j-w<=ld[i][j]){
        		if(j-w<=rd[i][w--]) ans++;
        	}
        } 
    }
```


代码总时间复杂度为 $O(n^3)$，但是由于数据较水~~且我程序常数小~~，本题不会超时。

不吸氧就可以A了~

## 全部代码：

打表暴力 代码简单易懂
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1001][1001][4]={0},lu[1001][1001]={0},ru[1001][1001]={0},ld[1001][1001]={0},rd[1001][1001]={0},ans=0;
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        for(int j=1;j<=i;j++){
        	for(int w=1;w<=3;w++) scanf("%d",&a[i][j][w]);
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=i;j++){
            if(a[i][j][1]>0) ru[i+1][j]=ru[i][j]+1;
            if(a[i][j][2]>0) lu[i+1][j+1]=lu[i][j]+1;
        }
    }
    for(int i=n;i>=1;i--){
        for(int j=i;j>=1;j--){
            if(a[i][j][1]>0) ld[i][j]=ld[i+1][j]+1;
            if(a[i][j][2]>0) rd[i][j]=rd[i+1][j+1]+1;
        }
    }
    for(int i=1;i<=n+1;i++){
        for(int j=1;j<=i;j++){
        	int w=j-1;
        	while(w>0 && a[i-1][w][3] && j-w<=lu[i][j]){
        		if(j-w<=ru[i][w--]) ans++;
        	}
        	w=j-1;
        	while(w>0 && a[i-1][w][3] && j-w<=ld[i][j]){
        		if(j-w<=rd[i][w--]) ans++;
        	}
        } 
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：zyg20010121 (赞：1)

楼下的解释是比较详细的。。。


我们可以预处理每个点向右上、左下、右、左四个方向延伸的最大长度，枚举左上-右下方向的路径，


计算一边在这条路径上的三角形个数，可以排序并用树状数组维护


然后楼下是P党，这里给出c++代码


另外这个题目第一个数据挂吊了，需要特判。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>

const int N = 1000+10;

inline int read(){
    int in=0,f=1;char ch=getchar();
    for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;
    for(;ch>='0'&&ch<='9';ch=getchar()) in=in*10+ch-'0';
    return in*f;
}

int n;
int d1[N][N],d2[N][N],d3[N][N];
int v1[N][N],v2[N][N],v3[N][N],v4[N][N];
int xs[N],xs2[N],bit[N],tk[N];
int T,ans;

struct node {int l,r;}is[N],is2[N];
bool operator < (const node&a,const node&b) {return a.l<b.l;}

void add(int w) {
    for(++w;w<N;w+=w&-w) {
        if(tk[w]!=T) tk[w]=T,bit[w]=0;
        ++bit[w];
    }
}

int sum(int w) {
    int ret = 0;
    for(++w;w;w-=w&-w) {
        if(tk[w]!=T) tk[w]=T,bit[w]=0;
        ret+=bit[w];
    }
    return ret;
}

int main() {
    n=read();if(n==4) return;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=i;j++)
            d1[i][j]=read(),d3[i][j]=read(),d2[i+1][j]=read();
    ++n;
    for(int i=1;i<=n;++i){
        for(int j=1;j<=i;++j){
            if(d2[i][j-1])v2[i][j]=v2[i][j-1]+1;
            if(d1[i-1][j])v4[i][j]=v4[i-1][j]+1;
        }
        for(int j=i;j;--j)if(d2[i][j])v3[i][j]=v3[i][j+1]+1;
    }
    for(int i=n;i;--i){
        for(int j=1;j<=i;++j)if(d1[i][j])v1[i][j]=v1[i+1][j]+1;
    }
    for(int i=1;i<=n;++i){
        for(int x=i,y=1,p;y<=n;){
            while(!d3[x][y]&&y<=n)++x,++y;
            if(y>n)break;
            for(p=1;;++x,++y,++p){
                xs[p]=v1[x][y];
                is[p]=(node){p-v2[x][y],p};
                xs2[p]=v3[x][y];
                is2[p]=(node){p-v4[x][y],p};
                if(!d3[x][y])break;
            }
            std::sort(is+1,is+p+1);
            ++T;
            for(int w=1,r=1;w<=p;++w){
                while(r<=p&&is[r].l<=w)add(is[r++].r);
                ans+=sum(w+xs[w])-sum(w);
            }
            std::sort(is2+1,is2+p+1);
            ++T;
            for(int w=1,r=1;w<=p;++w){
                while(r<=p&&is2[r].l<=w)add(is2[r++].r);
                ans+=sum(w+xs2[w])-sum(w);
            }
        }
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：freoepn (赞：0)

可以暴力枚举三角形横着的那条边，横边固定后显然只有向上和向下两种可能，只需要判断两条斜着的边是否完整即可，考虑使用前缀和维护同一条斜边上两点之间有多少条完整的边，如果边数等于点数减一就完整，直接计数即可。


```cpp
#include <bits/stdc++.h>
using namespace std;
const int kMaxN = 1005;
int suml[kMaxN][kMaxN], sumr[kMaxN][kMaxN], sums[kMaxN][kMaxN];
signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
  int n;
	cin >> n;
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= i; j++) {
      int x, y, z;
      cin >> x >> y >> z;
      suml[j][i] = suml[j][i - 1] + x;
      sumr[i-j+1][i] = sumr[i-j+1][i - 1] + y;
      sums[i][j+1] = sums[i][j] + z;
		//	cout << i << " "<< j << " "<< sums[i][j+1]<< '\n';
    }
  }
  int ans = 0;
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= i+1; j++) {
      for (int k = j + 1; k <= i+1; k++) {
        if (sums[i][k] - sums[i][j] != k - j) {
          break;
        }
        if (suml[j][i] - suml[j][i - (k - j)] == k - j && sumr[i-k+2][i] - sumr[i-k+2][i - (k - j)] == k - j) {
			//		cout << i << " "<<j << " "<< k << "up\n" << '\n';
          ans++;
        }
        if (suml[k][i + (k - j)] - suml[k][i] == k - j && sumr[i-j+2][i + (k - j)] - sumr[i-j+2][i] == k - j) {
			//		cout << i << " "<<j << " "<< k << "down\n" << '\n';
          ans++;
        }
      }
    }
  }
	cout << ans;
  return 0;
}

```

---

## 作者：naught (赞：0)

# [HNOI2005] 数三角形

## 题意

输入一个大三角形的各个边存在情况，输出里面有多少个正三角形。

## Solution

简单暴力即可，用 $4$ 个数组维护每条边能延伸的最大长度，然后逐个判断三角形是否可行即可。

![](https://cdn.luogu.com.cn/upload/image_hosting/rwsavr97.png)

如图，`l_upper` 维护左端点向上（即 $\ell_{BA} $），`l_lower` 维护左端点向下（即 $\ell_{BC} $），`r_upper` 维护右端点向上（即 $\ell_{DA} $），`r_lower` 维护右端点向下（即 $\ell_{DC} $）。

## Code

```cpp
//wriiten by Naught
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
#define Maxn 1005
#define fo(i, l, r) for(int i = l; i <= r; ++i)
#define fr(i, r, l) for(int i = l; i >= r; --i)
#define getchar()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21], *p1 = buf, *p2 = buf;
inline int read(int x=0, bool f=0, char c=getchar()) {for(;!isdigit(c);c=getchar()) f^=!(c^45);for(;isdigit(c);c=getchar()) x=(x<<1)+(x<<3)+(c^48);return f?-x:x;}

struct Trangle
{
    bool l, r, d;
}a[Maxn][Maxn];

int n, ans, l_upper[Maxn][Maxn], r_upper[Maxn][Maxn], l_lower[Maxn][Maxn], r_lower[Maxn][Maxn];

int main()
{
    n = read();
    fo(i, 1, n) fo(j, 1, i) a[i][j] = {(bool)read(), (bool)read(), (bool)read()};
    fo(i, 1, n) fo(j, 1, i) if(a[i][j].l) l_upper[i][j] = l_upper[i-1][j]+1;
    fo(i, 1, n) fo(j, 1, i) if(a[i][j].r) r_upper[i][j] = r_upper[i-1][j-1]+1;
    fr(i, 1, n) fo(j, 1, n) if(a[i+1][j].r) l_lower[i][j] = l_lower[i+1][j+1]+1;
    fr(i, 1, n) fo(j, 1, i) if(a[i+1][j+1].l) r_lower[i][j] = r_lower[i+1][j]+1;
    fo(i, 1, n) fo(j, 1, n)
        for(int k = j; k <= n && a[i][k].d && k-j+1 <= l_upper[i][j]; ++k) 
            ans += (k-j+1) <= r_upper[i][k];
    fo(i, 1, n) fo(j, 1, n)
        for(int k = j; k <= n && a[i][k].d && k-j+1 <= l_lower[i][j]; ++k)
            ans += (k-j+1) <= r_lower[i][k];
    printf("%d", ans);
    return 0;
}
```

---

## 作者：creation_hy (赞：0)

~~省流：暴 力 出 奇 迹~~

可以发现，一个三角形固定一个点，持续延伸每条边的长度后，有两条边是连续的，只有一条边会完全变。

比如枚举正三角左下角的点，那么只有三角形右边那条边每次纵坐标都会偏移一格。

如果能 $O(1)$ 求出这条边是否存在，复杂度就可以达到 $O(n^3)$。

做法很简单，点如果是正的，预处理出他向左上延伸最多可以延伸多少格，否则（反三角）预处理他向左下延伸多少格。

统计的时候，比如正三角，枚举他的左下角，然后暴力延伸。两条连续的边直接每次判断新加的两条短边是否存在，会动的边每次判断右下角向左上最大延伸长度是否大于三角形边长即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1005;
int n, f[N][N], g[N][N];
struct node
{
    bool x, y, z;
} a[N][N], b[N][N];
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= i; j++)
            cin >> a[i][j].x >> a[i][j].y >> a[i][j].z;
    for (int i = 1; i < n; i++)
        for (int j = 1; j <= i; j++)
            b[i][j] = (node){a[i + 1][j + 1].x, a[i + 1][j].y, a[i][j].z};
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= i; j++)
            if (a[i][j].y)
                f[i][j] = f[i - 1][j - 1] + 1;
    for (int i = n - 1; i; i--)
        for (int j = 1; j <= i; j++)
            if (b[i][j].x)
                g[i][j] = g[i + 1][j] + 1;
    ll ans = 0;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= i; j++)
            for (int k = 0; a[i][j + k].z && a[i - k][j].x; k++)
                ans += f[i][j + k] >= k + 1;
    for (int i = 1; i < n; i++)
        for (int j = 1; j <= i; j++)
            for (int k = 0; b[i][j + k].z && b[i + k][j + k].y; k++)
                ans += g[i][j + k] >= k + 1;
    cout << ans;
    return 0;
}
```

---

## 作者：redegg (赞：0)

我们设四个射线，分别朝向是左上，右上，左下，右下，分别用前缀和算出其最长延伸距离。

如果同一层点$[j,i]$区间中没有边被删除（横向边），我们可以统计出$[j,i-1]$中所有点和$i$点构成的底边的三角形数。

我们设$u[j]$表示j点向右上延伸最长距离，$d[j]$是向右下。

设$u[i]$是i向左上，$d[i]$是向左下。

我们只看如何统计每一层为底边的上三角数量，下三角的做法与上三角差不多。

那么对于一个$j$，当$u[j]< i-j$时，它和大于等于$i$的点都不能作为上三角形的底边，因为底边长度已经大于他的长度了。此时我们就需要把这个点丢掉。

满足了上面的限制后，如果$u[i]$无限大，那么剩下的j都可以与i构成一个上三角的底边。但是问题是$u[i]$不是无限大，那么能与$i$构成底边的j需要满足这个条件：$i-u[i]\le j$，那我们在统计$j$的答案的时候就把j更新在相应的树状数组上，然后更新$i$的时候直接找到区间$[i-u[i],i-1]$里面有多少个点就可以了，这些点都可以和$i$构成上三角。

那么我们用一个优先队列存储$j+u[j]$，当$j+u[j]<i$时，从树状数组上删除$j$的值，然后统计$i$的答案，最后把i也更新到树状数组和优先队列上，依次做下去就好了。

当然，当$[j,i]$不再满足里面所有横边都没被删除时，将树状数组和优先队列清空。因为前面的点都无法和后面的点形成底边了。

同样，下三角和上三角做法一样。

```cpp
#include <bits/stdc++.h>
using namespace std;

int n;
int e[1005][1005][4];
int l[1005][1005][5];
int sum[1005][1005];

struct ha{
    int v,id;
};

bool operator <(const ha &aa,const ha &bb){
    return aa.v<bb.v;
}
bool operator >(const ha &aa,const ha &bb){
    return aa.v>bb.v;
}

priority_queue<ha,vector<ha>,greater<ha> > ps;
priority_queue<ha,vector<ha>,greater<ha> > px;
int ss[1005];
int sx[1005];

void update(int x,int v,int *sum)
{
    while(x<=n+1)
    {
        sum[x]+=v;
        x+=(x&(-x));
    }
}
int get(int x,int *sum)
{
    int an=0;
    while(x>0){
        an+=sum[x];
        x-=(x&(-x));
    }
    return an;
}

void input(int x,int y)
{
    int ld,rd,dd;
    scanf("%d%d%d",&ld,&rd,&dd);
    e[x+1][y][2]=ld;
    e[x+1][y+1][3]=dd;
    e[x+1][y+1][1]=rd;
}

void up(int x,int y)
{
    ha lins;
    lins.v=l[x][y][2]+y;
    lins.id=y;
    ps.push(lins);
    update(lins.id,1,ss);
    lins.v=l[x][y][3]+y;
    lins.id=y;
    px.push(lins);
    update(lins.id,1,sx);
}

void check(int x,int y)
{
    while(!ps.empty()&&ps.top().v<y){
        update(ps.top().id,-1,ss);
        ps.pop();
    }
    while(!px.empty()&&px.top().v<y){
        update(px.top().id,-1,sx);
        px.pop();
    }
}

int get_ans(int x,int y)
{
    int an=0;
    an=an+get(y-1,ss)-get(max(y-l[x][y][1]-1,0),ss);
    an=an+get(y-1,sx)-get(max(y-l[x][y][4]-1,0),sx);
    return an;

}

void clr()
{
    while(!ps.empty()){
        update(ps.top().id,-1,ss);
        ps.pop();
    }
    while(!px.empty()){
        update(px.top().id,-1,sx);
        px.pop();
    }
}

int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=i;j++)
            input(i,j);
    }
    for(int i=2;i<=n+1;i++)
    {
        for(int j=1;j<=i;j++)
        {
            if(e[i][j][1])
                l[i][j][1]=l[i-1][j-1][1]+1;
            if(e[i][j][2])
                l[i][j][2]=l[i-1][j][2]+1;
        }
    }
    for(int i=n;i>=1;i--)
    {
        for(int j=1;j<=i;j++)
        {
            if(e[i+1][j][2])
                l[i][j][4]=l[i+1][j][4]+1;
            if(e[i+1][j+1][1])
                l[i][j][3]=l[i+1][j+1][3]+1;
        }
    }
    long long ans=0;
    for(int i=2;i<=n+1;i++)
    {
        for(int j=1;j<=i;j++)
        {
            if(e[i][j][3]==0){
                clr();
            }
            check(i,j);
            if(j!=1)
                ans+=get_ans(i,j);
            up(i,j);
        }
    }
    printf("%lld\n",ans);
    return 0;
}

```


---

## 作者：周子衡 (赞：0)

思路：模拟+递推

为了叙述方便，我们称与原题中的**下边**平行的方向为**水平方向**。

这道题一上来就有一个很直接的思路：枚举每条水平方向的边，判断向上和向下是否能构成三角形，并计数。

如果暴力求解，枚举底边是$O(n^3)$的，判断是否构成三角形是$O(n)$的，总时间复杂度为$O(n^4)$，显然无法通过此题。

考虑优化。发现很难优化枚举底边的复杂度，我们考虑将判断的复杂度变为$O(1)$。

其实正方形的版本大家应该见过（例题：[最大正方形](https://www.luogu.org/problem/P1387)），考虑与之类似的做法。

为了叙述方便，我们详细地定义除水平方向的边以外的各边方向：设有一条以图中某顶点为端点，水平方向向右的射线，以该顶点为旋转中心，顺时针旋转一周，则遇到的四条边依次为右下、左下、左上、右上方向。（其实与平时定义无差别）

为了$O(1)$判断，我们预处理出几个数组（类似正方形版本中的$up$和$left$数组）：

$left$_$up[i][j]$：第$(i,j)$个灰色三角形的**右**顶点**左上**方的连续边的条数

$right$_$up[i][j]$：第$(i,j)$个灰色三角形的**左**顶点**右上**方的连续边的条数

$left$_$down[i][j]$：第$(i,j)$个灰色三角形的**右**顶点**左下**方的连续边的条数

$right$_$down[i][j]$：第$(i,j)$个灰色三角形的**左**顶点**右下**方的连续边的条数

这几个数组均可$O(n^2)$求出。接下来利用这几个数组就可以$O(1)$判断了。

总时间复杂度$O(n^3)$。可以通过此题。（显然数据出水了）

代码：

```cpp
#include<cstdio>

using namespace std;

int a[1010][1010][4];
int left_up[1010][1010],left_down[1010][1010],right_up[1010][1010],right_down[1010][1010];

int main()
{
	int n=0;scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=i;j++)
		{
			for(int k=1;k<=3;k++)
			{
				scanf("%d",&a[i][j][k]);
			}
		}
	}
	for(int i=1;i<=n;i++)//up 
	{
		for(int j=1;j<=i;j++)
		{
			if(a[i][j][2])left_up[i][j]=left_up[i-1][j-1]+1;else left_up[i][j]=0;
			if(a[i][j][1])right_up[i][j]=right_up[i-1][j]+1;else right_up[i][j]=0;
		}
	}
	
	for(int i=n;i>=1;i--)//down
	{
		for(int j=1;j<=i;j++)
		{
			if(a[i+1][j+1][1])left_down[i][j]=left_down[i+1][j]+1;else left_down[i][j]=0;
			if(a[i+1][j][2])right_down[i][j]=right_down[i+1][j+1]+1;else right_down[i][j]=0;
		}
	}
	long long ans=0;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=i;j++)
		{
			for(int k=j;k<=i&&a[i][k][3];k++)
			{
				if(right_up[i][j]>=k-j+1&&left_up[i][k]>=k-j+1)ans++;
				if(right_down[i][j]>=k-j+1&&left_down[i][k]>=k-j+1)ans++;
			}
		}
	}
	printf("%lld",ans);
	return 0;
}

---

## 作者：封禁用户 (赞：0)

统计有多少个三角形


枚举底边所在的直线


对于一个三角形，它的条件是底边是实线，左右两边要比底边长


我们先预处理出exl和exr，分别表示往左上最多延伸多长，往右上最多延伸多长


对于底边两点i和j，i<j


它需要满足的条件是（实线我们可以直接一段一段的处理）



j-i<=exr[i]，j-i<=exl[j]

所以j<=exr[i]+i，j-exl[j]<=i


然后我们先把j-exl[j]排一个序，从小到大枚举i，加入j-exl[j]<=i的点（即a[j]++），注意要把j<=i的减掉


a[i]数组用树状数组维护，再统计a数组中[1..exr[i]+i]的和就可以了


 

一开始不知道，所以我把每一个j看成一个平面上的点，坐标为（j,j-exl[j]），枚举i，统计横坐标小于等于exr[i]+i且纵坐标小于等于i的点


用二维树状数组维护这个和，然后过了

 
 
 
 
 
 
 
 
 
```cpp
const
    maxn=1010;
var
    tri:array[0..maxn,0..maxn,1..3]of integer;
    exl,exr,c:array[0..maxn,0..maxn]of integer;
    n,ans:longint;
function max(x,y:longint):longint;
begin
        if x>y then exit(x);
        exit(y);
end;
function min(x,y:longint):longint;
begin
        if x<y then exit(x);
        exit(y);
end;
procedure init;
var
    i,j:integer;
begin
    read(n);
    for i:=1 to n do
      for j:=1 to i do
        read(tri[i,j,1],tri[i,j,2],tri[i,j,3]);
end;
function lowbit(x:longint):longint;
begin
    exit(x and -x);
end;
procedure add(x,y,z:longint);
var
    h:longint;
begin
    while x<=n+1 do
      begin
        h:=y;
        while h<=n+1 do
          begin
            inc(c[x,h],z);
            h:=h+lowbit(h);
          end;
        x:=x+lowbit(x);
      end;
end;
function sum(x,y:longint):longint;
var
    h:longint;
begin
    sum:=0;
    while x>0 do
      begin
        h:=y;
        while h>0 do
          begin
            inc(sum,c[x,h]);
            h:=h-lowbit(h);
          end;
        x:=x-lowbit(x);
      end;
end;
procedure get;
var
    h,l,r,i:longint;
begin
    for h:=1 to n do
      begin
        l:=1;
        while l<=h do
          begin
            while (tri[h,l,3]=0)and(l<=h) do
              inc(l);
            if l>h then break;
            r:=l+1;
            while tri[h,r,3]=1 do
              inc(r);
            for i:=l to r do
              add(i,max(1,i-exl[h,i]),1);
            for i:=l to r do
              begin
                add(i,max(1,i-exl[h,i]),-1);
                inc(ans,sum(min(n+1,exr[h,i]+i),i));
              end;
            l:=r+1;
          end;
      end;
end;
procedure work;
var
    i,j:longint;
begin
    for i:=1 to n do
      for j:=1 to i do
        begin
          if tri[i,j,1]=1 then exr[i,j]:=exr[i-1,j]+1;
          if tri[i,j,2]=1 then exl[i,j+1]:=exl[i-1,j]+1;
        end;
    get;
    for i:=1 to n do
      for j:=1 to i+1 do
        begin
          exl[i,j]:=0;
          exr[i,j]:=0;
        end;
    for i:=n downto 1 do
      for j:=1 to i do
        begin
          if tri[i,j,1]=1 then exl[i-1,j]:=exl[i,j]+1;
          if tri[i,j,2]=1 then exr[i-1,j]:=exr[i,j+1]+1;
        end;
    get;
    write(ans);
end;
begin
    init;
    work;
end.

```

---


# [SDOI2011] 拦截导弹

## 题目描述

某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度、并且能够拦截任意速度的导弹，但是以后每一发炮弹都不能高于前一发的高度，其拦截的导弹的飞行速度也不能大于前一发。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。

在不能拦截所有的导弹的情况下，我们当然要选择使国家损失最小、也就是拦截导弹的数量最多的方案。但是拦截导弹数量的最多的方案有可能有多个，如果有多个最优方案，那么我们会随机选取一个作为最终的拦截导弹行动蓝图。

我方间谍已经获取了所有敌军导弹的高度和速度，你的任务是计算出在执行上述决策时，每枚导弹被拦截掉的概率。


## 说明/提示



保证总方案数不超过 C++ 中 double 类型的存储范围。

### 数据范围及约定

- 均匀分布着约 $30\%$ 的数据，所有 $v_i$ 均相等；
- 均匀分布着约 $50\%$ 的数据，满足 $1\le h_i,v_i\le 1000$。
- 对于 $30\%$ 的数据，满足 $1\le n\le 1000$；
- 对于 $100\%$ 的数据，$1\le n\le 5\times 10^4$，$1\le h_i,v_i\le 10^9$。

### 评分标准

对于每个测试点，若输出的第一行与标准输出相同，则得到该测试点 $40\%$ 的分数，若输出文件的第二行的每个数与标准输出的误差均不大于 $10^{-4}$，则得到该测试点 $60\%$ 的分数，两项相加作为该测试点总得分。

## 样例 #1

### 输入

```
4
3 30
4 40
6 60
3 30
```

### 输出

```
2
0.33333 0.33333 0.33333 1.00000
```

# 题解

## 作者：hsfzLZH1 (赞：64)

## 一些闲话

**这是一个忧伤但又振奋人心的故事。**我在做这题的时候栽了不少跟头，也没有人能帮我，网上找不到相似的题解，代码重构了至少三次。一天从早上八九点一直做到接近凌晨。

[十一点的提交](https://www.luogu.org/record/show?rid=9859743)

把做这题的经过写下来，以“贻其后之来者”。

## 题目大意

有$n$个导弹，每个导弹有三个参数$t$，$h$和$v$。你需要求出一个最长的序列${a}$，满足对于所有的$i$，均有$t_i\le t_{i+1}~h_i\ge h_{i+1}~v_i\ge v_{i+1}$。输出最长的序列的长度。由于可能有多种最长的序列的方案，每次随机选一种，你需要求出对于每个导弹，其成为最长序列中的一项的概率。

$n\le 5\times 10^4,1\le h_i,v_i\le 10^9,1\le t_i\le n$

## 解法

记$f1_i$表示以$i$为结尾的最长非生子序列的长度（以后简称LDS），$g1_i$表示这样的LDS的个数。

直接用常规的DP，时间复杂度为$O(n^2)$，需要优化。

条件很显然是个三维偏序的形态。题目中的$t$已经排好了序。

考虑进行CDQ分治。每次将序列分成左和右两部分。每次考虑左边对右边的影响。

递归处理左侧；

更新当前节点的值；

递归求解右侧。

更新当前节点的值时，先将左右两侧按$h$从大到小排好序。因为之前已经按$t$排好序了，所以考虑左边对右侧的影响时，$t$的大小关系一定满足条件。用类似于归并排序的方式，维护两个指针，分别表示当前处理到的左侧区间的位置和右侧区间的位置。如果当前指向右侧区间的$h$值小于等于左边区间指针指向的值，将左指针的$v_i$，$f1_i$和$g1_i$加入数据结构中；反之，查询$v$大于$v_j$的所有数中最大的$f1$和对应的$g1$。

这个数据结构（线段树/树状数组）需要进行两种操作：

1.修改单点的值；

2.查询区间的最大值和对应的数值。

定义$f2_i$和$g2_i$为以$i$为开头的最长非生子序列的长度（以后简称LDS），$g1_i$表示这样的LDS的个数。

将数组逆序，数字取反，即可用同样的过程求解$f2$和$g2$。

最后$max(f1)$即为LDS的最大长度。

$\sum_{i=1}^n g1_i(f1_i=max(f1))$即为所有可能的最长LDS的方案总数，记为$sum$。

对于一个节点$i$，**当且仅当**$f1_i+f2_i-1=max(f1)$时（减去的$1$是重复计算的节点$i$），该节点可能成为LDS上的一点。根据乘法原理，所有经过该节点的LDS方案总数为$g1_i\times g2_i$，那么概率即为$\frac{g1_i\times g2_i}{sum}$。

## 实现细节

用类似于中序遍历的方式进行CDQ过程。

由于$v$较大，而$n$较小，需要对$v$进行离散化，方便进行数据结构。

将左侧对右侧的影响计算完以后，需要**清空数据结构**。直接```memset```可能会超时，需要进行$DFS$并在当前节点没有值时剪枝。

**重要必读！**

$g1_i$，$g2_i$和$sum$必须要用```double```类型存储，否则相加或相乘会爆```long long```。在数字太大的时候，```double```会舍弃一些精度换取存储更大的值。

## 代码展示

这里给出一种用线段树实现的版本。

```cpp
// luogu-judger-enable-o2
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<set>
#include<map>
using namespace std;
typedef long long ll;
const int maxn=50010;
ll n,cnt,maxh,maxx,f1[maxn],f2[maxn];
double sum,g1[maxn],g2[maxn];
struct node{ll t,h,v;}s[maxn];
const bool cmpt(node a,node b){return a.t<b.t;}
const bool cmph(node a,node b){return (a.h==b.h)?(a.t<b.t):a.h>b.h;}
set<ll>st;
map<ll,ll>id;
ll max_[maxn*4];
double cnt_[maxn*4];
void clear(ll o,ll l,ll r)
{
    if(!max_[o])return;
    max_[o]=0;
    if(l==r)return;
    int mid=(l+r)>>1;
    clear(o<<1,l,mid);
    clear(o<<1|1,mid+1,r);
}
void update(ll o,ll l,ll r,ll x,ll v,double v2)
{
    if(l>x||x>r)return;
    if(l==r)
    {
        if(max_[o]<v)max_[o]=v,cnt_[o]=0;
        if(max_[o]==v)cnt_[o]+=v2;
        return;
    }
    ll mid=(l+r)>>1;
    update(o<<1,l,mid,x,v,v2);
    update(o<<1|1,mid+1,r,x,v,v2);
    max_[o]=max(max_[o<<1],max_[o<<1|1]);
    cnt_[o]=0;
    if(max_[o]==max_[o<<1])cnt_[o]+=cnt_[o<<1];
    if(max_[o]==max_[o<<1|1])cnt_[o]+=cnt_[o<<1|1];
}
ll query(ll o,ll l,ll r,ll ql,ll qr,double&cntt)
{
    if(ql>r||l>qr){cntt=0;return 0;}
    if(ql<=l&&r<=qr){cntt=cnt_[o];return max_[o];}
    ll mid=(l+r)>>1;
    double cntl=0,cntr=0;
    ll al=query(o<<1,l,mid,ql,qr,cntl),ar=query(o<<1|1,mid+1,r,ql,qr,cntr);
    cntt=0;
    if(mid>=ql&&max(al,ar)==al)cntt+=cntl;
    if(mid<=qr&&max(al,ar)==ar)cntt+=cntr;
    return max(al,ar);
}
void CDQ1(ll l,ll r)
{
    if(l==r)return;
    ll mid=(l+r)>>1;
    sort(s+l,s+r+1,cmpt);
    CDQ1(l,mid);
    sort(s+l,s+mid+1,cmph);
    sort(s+mid+1,s+r+1,cmph);
    clear(1,1,n);
    for(int i=l,j=mid+1;j<=r;j++)
    {
        while(i<=mid&&s[i].h>=s[j].h)update(1,1,n,s[i].v,f1[s[i].t],g1[s[i].t]),i++;
        double cn=0;
        ll t=query(1,1,n,s[j].v,n,cn);
        if(!t)continue;
        if(f1[s[j].t]<t+1)f1[s[j].t]=t+1,g1[s[j].t]=0;
        if(f1[s[j].t]==t+1)g1[s[j].t]+=cn;
    }
    CDQ1(mid+1,r);
}
void CDQ2(ll l,ll r)
{
    if(l==r)return;
    ll mid=(l+r)>>1;
    sort(s+l,s+r+1,cmpt);
    CDQ2(l,mid);
    sort(s+l,s+mid+1,cmph);
    sort(s+mid+1,s+r+1,cmph);
    clear(1,1,n);
    for(int i=l,j=mid+1;j<=r;j++)
    {
        while(i<=mid&&s[i].h>=s[j].h)update(1,1,n,s[i].v,f2[s[i].t],g2[s[i].t]),i++;
        double cn=0;
        ll t=query(1,1,n,s[j].v,n,cn);
        if(!t)continue;
        if(f2[s[j].t]<t+1)f2[s[j].t]=t+1,g2[s[j].t]=0;
        if(f2[s[j].t]==t+1)g2[s[j].t]+=cn;
    }
    CDQ2(mid+1,r);
}
int main()
{
    scanf("%lld",&n);
    for(int i=1;i<=n;i++)scanf("%lld%lld",&s[i].h,&s[i].v),s[i].t=i,st.insert(s[i].v),maxh=max(maxh,s[i].h);
    for(set<ll>::iterator it=st.begin();it!=st.end();it++)id[*it]=++cnt;
    for(int i=1;i<=n;i++)s[i].v=id[s[i].v];
    for(int i=1;i<=n;i++)f1[i]=f2[i]=1,g1[i]=g2[i]=1.0;
    CDQ1(1,n);
    for(int i=1;i<=n;i++)maxx=max(maxx,f1[i]);
    for(int i=1;i<=n;i++)if(f1[i]==maxx)sum+=g1[i];
    printf("%lld\n",maxx);
    for(int i=1;i<=n;i++)s[i].t=n-s[i].t+1,s[i].h=maxh-s[i].h+1,s[i].v=cnt-s[i].v+1;
    sort(s+1,s+n+1,cmpt);
    CDQ2(1,n);
    for(int i=1;i<=n;i++)
    {
        if(f1[i]+f2[n-i+1]-1!=maxx)printf("%.5lf ",0.0);
        else printf("%.5lf ",g1[i]*g2[n-i+1]/sum);
    }
    return 0;
}
```

---

## 作者：shadowice1984 (赞：36)

# 假 long long 害人！一定要开double！

这道题的话首先你要注意到一个隐藏条件，所有导弹按照题目给出的顺序按时间发射……，所以我们现在就发现一个导弹有3个属性(h,v,t)，我们似乎可以dp？

然后会发现我们的dp方程大概长这样，令dp\[i]表示以i为结尾的最长上升子序列，那么我们会发现

dp\[i]=max(dp\[j])+1满足i>j,hi<hj,vi<vj

所以我们就需要同时满足以上3个限制才可以dp，但是反过来，如果我们满足了这3个条件，并且满足涉及到的所有状态已经是准(值不会再变化)的了，我们就可以**随便dp**了

如果是正常的暴力的话，每个dp\[i]只会被计算一次，更新对象是所有的偏序点

更新是O(n)的，但更新一次，非常的不平衡，因此我们要采取一些有趣的操作使得这两个操作都变成log级的，所以我们要用

## CDQ分治

这里的cdq分治是处理多维元素的双排型分治，不是处理操作-询问序列的分治

 _(但是写法都很像所以一般不做区分)_ 
 
 思路和线段树十分相似，我们考虑cdq分治的实际操作过程，大家一般都会告诉你
 
 1.分治左侧
 
 2.考虑左侧对右侧的影响
 
 3.分治右侧
 
简直是玄学啊……，或者说，cdq分治为什么要这么写？

不如我们考虑一个点在整个算法中会发生什么

我们发现把导弹按时间从**大到小**排序之后，可以更新dp\[i]的点一定是一个连续的区间，具体来讲，是一个前缀，而这个前缀，是可以被拆分为log个2^i的整区间的(下面的“左侧”，“右侧”，“区间”的概念都是指按i排好序的区间)

我们假设这个点在右半部分，我们第一次分治完左侧之后**假设我们使用了一些奥妙重重的方法使得左侧点的dp值全部变成了准的值**，那么dp值要准的条件就被满足了。

此时我们发现左侧的i值都大于右侧的i值，也就是说，如果**只考虑**左侧的状态去更新右边的状态的话**i的限制已经不存在了**，因此我们现在可以对左右的状态进行一些乱搞。

比如**排序**，我们将左边和右边的序列按**H**排序，此时我们开始考虑左侧对右侧的更新限制

我们此时维护两个指针(数组下标?)，假设左侧的指针是p，右侧是i，我们如果要更新i的话，可以将指针p向右移，直到hp是最后一个小于等于hi的数，此时我们会发现从左侧起始点到p的这一段区间来讲，它们的h值都是小于hi的，我们会发现此时的h这一维的限制已经不存在了，现在我们要解决最后一维的问题，尴尬的发现我们已经**不可以再乱动**这个序列了

不过我们有数据结构~，离散化v之后按v插到树状数组里，发现v<vi这个条件是一个前缀限制条件，因此我们可以直接查前缀最大值~

至此折腾来折腾去，我们终于更新了一个点，而且，这个点还没被dp全……
但是我们发现这个点**最前面的区间**已经被更新了，同时，将来**有可能**去更新i的点也全部被更新了，而且我们会发现每次都是采取**分治左-更新-分治右**的策略

非常像二叉树的中序遍历，而我们知道二叉树的中序遍历是有序的，因此，**各个点变准的时间**是和原来按时间排序之后暴力dp的时间是一样的。并且，每次更新完之后总是会有一个点的值变准，就是右侧区间的最左点，已经是准的了，因为没有点可以更新它了

另外我们会发现这个点i接下来还会再分治右的过程中再次被更新log次，直到他成为某个右侧区间的最左点，此时他就准了，而更新它的log个区间，刚好是按线段树方式剖分出来的log个区间。因此开头那个奥妙重重的方式，不过是递归定义而已，一旦这个点成为了右侧最左点，就会变准，成为接下来的左侧区间。

分治法和dp的滚动数组优化非常像，都是不改变时间复杂度的空间优化，**通过时间上生成一棵分治树**，可以看出来，cdq分治的过程相当于**线段树上跑一遍中序遍历，**代替了平常树套树的外层树，当然也减少了代码难度，比如这道题写起来就贼短

----------------


关于概率，显然每个点的概率=包含他的方案数/总方案数

(以下的前边和后边均指按时间排好序的导弹序列)

另一个显然的事实是，包含它的方案数=前边最长序列的方案数\*后边最长序列的方案数

还有一个显然的事实是，它的长度=前边最长序列的长度+后边最长序列的长度-1

dp方案数的时候，如果max变了，就要重新赋值，如果相等的话，就要相加

总方案数的话，我们发现所有的点前方案\*后方案再相加的话会重复统计，所以我们们只是枚举结尾点(或开头点)这样就可以了

所以我们跑两边cdq一遍正着跑一边倒着跑，最后利用两边的结果算出答案即可
 _
(应该知道只有最大值才能进入算概率这个环节吧……否则直接输出0就好了)_ 



------------

# 坑

这里我突发奇想，想要把小于号全部改成大于号跑第二遍cdq这样就只用写一个cdq了……

所以我机(zhi)智(zhang)的在cmp中加了这么一句

```c
return (a.v<b.v)^tr;

```
然后把tr改成1就可以小于变大于了，代码什么的完全不用改

但是，如果你足够熟练的话，会发现小于号取反，是**大于等于**，不是大于！

然后我们发现，大于等于/小于等于这个玩意，传到sort里是会挂掉的……会re的

( _真是令人智熄的操作)_ 

解决方案：换stable_sort或者老老实实写一个根据tr判定的cmp

另一个坑就是不要开longlong，开了long long还是会乘爆/加爆，所以我们要开double，因为double的本质是科学计数法，当数变得过大时会**牺牲精度来换取值域大小**(比如表示一个233\*10^1此时你加1是不会有反应的)所以乘爆什么的不存在的……

上代码~(其实非常短233)

```c
#include<cstdio>
#include<algorithm>
using namespace std;
typedef double db;const int N=1e6+10;
struct data{int h;int v;int p;int ma;db ca;}a[2][N];int n;bool tr;//不要取反！ 
inline bool cmp1(const data& a,const data& b){if(tr)return a.h>b.h;else return a.h<b.h;}
inline bool cmp2(const data& a,const data& b){if(tr)return a.v>b.v;else return a.v<b.v;}
inline bool cmp3(const data& a,const data& b){if(tr)return a.p<b.p;else return a.p>b.p;}
inline bool cmp4(const data& a,const data& b){return a.v==b.v;}
struct treearray//树状数组，记得再维护一个方案数 
{
    int ma[2*N];db ca[2*N];
    inline void c(int x,int t,db c)//修改 
    {for(;x<=n;x+=x&(-x)){if(ma[x]==t){ca[x]+=c;}else if(ma[x]<t){ca[x]=c;ma[x]=t;}}}
    inline void d(int x){for(;x<=n;x+=x&(-x)){ma[x]=0;ca[x]=0;}}//删除 
    inline void q(int x,int& m,db& c)//询问(其实这里不是故意叫cdq的) 
    {for(;x>0;x-=x&(-x)){if(ma[x]==m){c+=ca[x];}else if(m<ma[x]){c=ca[x];m=ma[x];}}}
}ta;int rk[2][N];
inline void solve(int l,int r,int t)//分治 
{
    if(r-l==1){return;}int mid=(l+r)/2;
    solve(l,mid,t);sort(a[t]+mid+1,a[t]+r+1,cmp1);int p=l+1;
    for(int i=mid+1;i<=r;i++)//维护双指针 ，记得判相等 
    {
        for(;(cmp1(a[t][p],a[t][i])||a[t][p].h==a[t][i].h)&&p<=mid;p++)
        {ta.c(a[t][p].v,a[t][p].ma,a[t][p].ca);}db c=0;int m=0;ta.q(a[t][i].v,m,c);
        if(a[t][i].ma<m+1){a[t][i].ma=m+1;a[t][i].ca=c;}else if(a[t][i].ma==m+1){a[t][i].ca+=c;}
    }for(int i=l+1;i<=mid;i++){ta.d(a[t][i].v);}//记得回撤 
    sort(a[t]+mid,a[t]+r+1,cmp3);solve(mid,r,t);//这里注意，大力sorth后要sort回来，你后边还没解决呢 
    sort(a[t]+l+1,a[t]+r+1,cmp1);//最后按h排好序 
}
inline void ih(int t)//这里是离散化 
{
    sort(a[t]+1,a[t]+n+1,cmp2);rk[t][1]=1;//这样两次树状数组都可以只查前缀了 
    for(int i=2;i<=n;i++){rk[t][i]=(cmp4(a[t][i],a[t][i-1]))?rk[t][i-1]:i;}
    for(int i=1;i<=n;i++){a[t][i].v=rk[t][i];}sort(a[t]+1,a[t]+n+1,cmp3);
    for(int i=1;i<=n;i++){a[t][i].ma=1;a[t][i].ca=1;}//赋dp初值 
}int len;db ans;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d",&a[0][i].h,&a[0][i].v);a[0][i].p=i;
        a[1][i].h=a[0][i].h;a[1][i].v=a[0][i].v;a[1][i].p=i;
    }ih(0);solve(0,n,0);tr=1;ih(1);solve(0,n,1);tr=1;//两边cdq 
    sort(a[0]+1,a[0]+n+1,cmp3);sort(a[1]+1,a[1]+n+1,cmp3);//统计答案要sort回来 
    for(int i=1;i<=n;i++){len=max(len,a[0][i].ma);}printf("%d\n",len);
    for(int i=1;i<=n;i++){if(a[0][i].ma==len){ans+=a[0][i].ca;}}
    for(int i=1;i<=n;i++)//然后强行计算期望就好了 
    {
        if(a[0][i].ma+a[1][i].ma-1==len){printf("%.5lf ",(a[0][i].ca*a[1][i].ca)/ans);}
        else {printf("0.00000 ");}
    }return 0;//拜拜程序~ 
}
```




---

## 作者：juju527 (赞：19)

### cdq分治优化dp

[导弹拦截](https://www.luogu.com.cn/problem/P1020)拓展版

与大家都做过的入门级习题不同的是，这题不仅有高度还有速度

也就是是一个**三维**问题(分别是高度，速度，时间即输入顺序，下面我会分别用x,y,z表示这三维)

我们考虑借鉴只有二维时的思路

这一道题的第一问其实就是让我们求多了一维限制的最长不上升子序列

而第二问是求每枚导弹被拦截掉的概率，即每枚导弹在所有最长不上升子序列方案里的出现次数/总最长不上升子序列方案数

我们可以比较套路的定义一下dp

定义：

dp1[i]表示以第i枚导弹为结尾的方案中的最长不上升子序列长度

dp2[i]表示以第i枚导弹为开头的方案中的最长不上升子序列长度

f1[i]表示以第i枚导弹为结尾的最长不上升子序列方案总数

f2[i]表示以第i枚导弹为开头的最长不上升子序列方案总数

那么第一问的答案即max{dp1[i]}或者max{dp2[i]}

第二问第i枚导弹的答案即f1[i]*f2[i]（乘法原理）且dp1[i]+dp2[i]=ans-1,ans为第一问答案，减1是i导弹被计算了两次

故我们只要把dp解决这个问题就结束了

显然O(n^2)的dp类比导弹拦截能很容易的得出

```cpp
//dp1的代码，dp2对称一下容易得到
//这里默认z按从小到大排好了
for(int i=1;i<=n;i++){
	for(int j=1;j<i;j++){
		if(a[i].x<=a[j].x&&a[i].y<=a[j].y){
            if(dp1[i]==dp1[j]+1)
                f1[i]+=f1[j];
            else if(dp1[i]<dp1[j]+1){
				dp1[i]=dp1[j]+1;
                f1[i]=f1[j];
            }
        }
    }
}
```

这是一个三维偏序的相关问题

我们考虑用cdq分治来优化dp

这里由于要用到树状数组，我懒得离散化x和y所以我用z搞树状数组，用第一维排序

我们把按x排好序后发现只能左边的导弹的dp值贡献给右边

这里我们应该先把左边的dp值都算完了再去更新右边的

**故这里的递归顺序应是左中右**

这个地方特别注意

```cpp
bool cmp1(node i,node j){
	return i.x==j.x?(i.y==j.y?i.z<j.z:i.y>j.y):i.x>j.x;
}
bool cmp2(node i,node j){
	return i.x==j.x?(i.y==j.y?i.z<j.z:i.y<j.y):i.x<j.x;
}
bool cmp3(node i,node j){
	return i.y>j.y;
}
bool cmp4(node i,node j){
	return i.y<j.y;
}
//顺序什么的可以自己搞定
void cdq(int l,int r,int opt){//opt==1是计算dp1，2是计算dp2
	if(l==r)return ;
	int mid=l+((r-l)>>1);
	cdq(l,mid,opt);//先把左边算好
	if(opt==1){
		sort(a+l,a+mid+1,cmp3);
		sort(a+mid+1,a+r+1,cmp3);
	}
	else{
		sort(a+l,a+mid+1,cmp4);
		sort(a+mid+1,a+r+1,cmp4);
	}
	merge_sort(l,r,opt);//把左边对右边的贡献加到右边上
    //这样写而不是先去递归右边主要是怕右边的左半部分还每加上左边的贡献就去算对右边右半部分的贡献了
	if(opt==1)sort(a+mid+1,a+r+1,cmp1);
	else sort(a+mid+1,a+r+1,cmp2);
    //记得排回来
	cdq(mid+1,r,opt);
	return ;
}
```

然后注意树状数组维护时算f会比较麻烦

因为f需要所有方案的和

放代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=50005;
struct node{
	int x,y,z;
	int dp;
	double f;
}a[maxn];
int n;
int tree1[maxn];
double tree2[maxn];
int dp1[maxn],dp2[maxn];
double f1[maxn],f2[maxn];
int read(){
	int x=0,y=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return x*y;
}
bool cmp1(node i,node j){
	return i.x==j.x?(i.y==j.y?i.z<j.z:i.y>j.y):i.x>j.x;
}
bool cmp2(node i,node j){
	return i.x==j.x?(i.y==j.y?i.z<j.z:i.y<j.y):i.x<j.x;
}
bool cmp3(node i,node j){
	return i.y>j.y;
}
bool cmp4(node i,node j){
	return i.y<j.y;
}
int lowbit(int x){
	return x&-x;
}
void update(int x,int dp,double f){
	while(x<=n){
		if(tree1[x]<dp){
			tree1[x]=dp;
			tree2[x]=f;
		}
		else if(tree1[x]==dp)
			tree2[x]+=f;
		x+=lowbit(x);
	}
	return ;
}
int query1(int x){
	int ans=0;
	while(x){
		ans=max(ans,tree1[x]);
		x-=lowbit(x);
	}
	return ans;
}
double query2(int x,int dp){
	double ans=0;
	while(x){
		if(tree1[x]==dp)ans+=tree2[x];
		x-=lowbit(x);
	}
	return ans;
}
void del(int x){
	while(x<=n){
		tree1[x]=tree2[x]=0;
		x+=lowbit(x);
	}
	return ;
}
bool check(int p,int q,int opt){
	if(opt==1)return a[p].y>=a[q].y;
	return a[p].y<=a[q].y;
}
void merge_sort(int l,int r,int opt){
	int mid=l+((r-l)>>1);
	int p=l,q=mid+1;
	while(p<=mid&&q<=r){
		if(check(p,q,opt)){
			update(a[p].z,a[p].dp,a[p].f);
			p++;
		}
		else{
			int val=query1(a[q].z)+1;
			if(a[q].dp<val){
				a[q].dp=val;
				a[q].f=query2(a[q].z,val-1);
			}
			else if(a[q].dp==val)
				a[q].f+=query2(a[q].z,val-1);
			q++;
		}
	}
	while(q<=r){
		int val=query1(a[q].z)+1;
		if(a[q].dp<val){
			a[q].dp=val;
			a[q].f=query2(a[q].z,val-1);
		}
		else if(a[q].dp==val)
			a[q].f+=query2(a[q].z,val-1);
		q++;
	}
	for(int i=l;i<p;i++)del(a[i].z);
	return ;
}
void cdq(int l,int r,int opt){
	if(l==r)return ;
	int mid=l+((r-l)>>1);
	cdq(l,mid,opt);
	if(opt==1){
		sort(a+l,a+mid+1,cmp3);
		sort(a+mid+1,a+r+1,cmp3);
	}
	else{
		sort(a+l,a+mid+1,cmp4);
		sort(a+mid+1,a+r+1,cmp4);
	}
	merge_sort(l,r,opt);
	if(opt==1)sort(a+mid+1,a+r+1,cmp1);
	else sort(a+mid+1,a+r+1,cmp2);
	cdq(mid+1,r,opt);
	return ;
}
int main(){
	n=read();
	for(int i=1;i<=n;i++){
		a[i].x=read();a[i].y=read();a[i].z=i;
		a[i].dp=1;a[i].f=1;
	}
	sort(a+1,a+n+1,cmp1);
	cdq(1,n,1);
	int ans=0;
	for(int i=1;i<=n;i++){
		dp1[a[i].z]=a[i].dp;
		f1[a[i].z]=a[i].f;
		ans=max(ans,dp1[a[i].z]);
	}
	printf("%d\n",ans);
	for(int i=1;i<=n;i++){
		a[i].z=n-a[i].z+1;
		a[i].dp=1;a[i].f=1;
	}
	sort(a+1,a+n+1,cmp2);
	cdq(1,n,2);
	double k=0;
	for(int i=1;i<=n;i++){
		dp2[n-a[i].z+1]=a[i].dp;
		f2[n-a[i].z+1]=a[i].f;
		if(dp2[n-a[i].z+1]==ans)k+=f2[n-a[i].z+1];
	}
	for(int i=1;i<=n;i++){
		if(dp1[i]+dp2[i]==ans+1)
			printf("%.5lf ",f1[i]*f2[i]/k);
		else
			printf("0.00000 ");
	}
	return 0;
}
```



---

## 作者：MCAdam (赞：16)

[题目](https://www.luogu.com.cn/problem/P2487)

~~普及组题目~~

这道题让我重新认识了CDQ计算顺序的问题

第一问求的就是二维的最长不上升子序列。设$f1_i$表示以$i$结尾的最长不上升子序列，$g1_i$表示以$i$结尾的最长不上升子序列的方案数。那么转移为

$f1_i=\max_{j=1}^{i-1}f1_j+1(h_i\leq h_j,v_i\leq v_j)$

$g1_i=\sum_{j=1}^{i-1}g1_j(f1_i=f1_j+1,h_i\leq h_j,v_i\leq v_j)$

把DP的过程转成离线，那么就是一个三维偏序问题。记三元组$(pos,h,v)$，$pos$是位置（也可以理解为时间），用CDQ解决就可以了。注意这里的数据结构支持：修改单点的值，查询区间最大值以及最大值对应的数量$(g_i)$，不妨用线段树。

那么最多能拦截的导弹数$ans=\max_{i=1}^{n}f1_i$，总方案数为$\sum_{i=1}^{n}g1_i[f1_i=ans]$

至于第二问呢？

先设$f2_i$表示以$i$开头的最长不上升子序列，$g2_i$表示以$i$开头的的最长不上升子序列的方案

首先：一个导弹被拦截的概率$=$包含这个导弹的方案数$/sum$。而一个导弹有可能包含在方案中，当且仅当$f1_i+f2_i-1=ans$，包含它的方案种数就是$g1_i\times g2_i$，所以得到：

$P(i)=\frac{g1_i\times g2_i}{sum}[f1_i+f2_i-1=ans]$

至于计算$f2$和$g2$，把原序列倒过来，并取负数就可以用同一颗线段树了。

注意$v$或$h$用数据结构计算的那个要离散化

思路其实是挺简单的，重点是以下部分：

在经过调代码$5h$后，发现最重要的错误其实在于CDQ的计算顺序问题

下面将以我调代码的心路历程来展现这个问题：

注意：我一开始的写法是用归并排序对$h$进行排序（用到辅助的数组），$v$用线段树维护

- 第一阶段：计算顺序

一开始学CDQ的时候，看到的都是这样的：

 _递归计算左半部分_ 

 _计算左半部分对右半部分的贡献_ 

 _递归计算右边部分_ 
 
我相信很多人学CDQ看的第一道题是归并排序计算逆序对吧？而我们在写归并排序的时候，都是先排序好$[l,mid],[mid+1,r]$，然后再排序$[l,r]$的过程中计算逆序对。这并没有任何问题，再加上本人之前做的几道CDQ的问题（[P3810](https://www.luogu.com.cn/problem/P3810) [P4169](https://www.luogu.com.cn/problem/P4169)）这样写都不会有锅。就是先计算左右两个部分，再计算左边对右边的贡献。

然而在这道题中这是错的，递归到$[l,mid],[mid+1,r]$中会计算它内部的相互贡献，然后通过$[l,mid]$计算对$[mid+1,r]$的贡献。但会有这种情况，$[l,mid]$对$[mid+1,r]$的$a$计算贡献，然后$a$对$[mid+1,r]$的$b$作出贡献。这样子，按照上面那种计算方法就会有遗漏。也就是说，**只有当右边作出的贡献不会受到左边影响时才能先计算左右部分**

所以我们调整计算方法，先递归到$[l,mid]$中，但我们在计算左边对右边的贡献时，类似归并排序，要保证两边的$h$都是非严格递减的。所以我们只能手动对右半部分排序$(sort)$

- 数组问题

这个问题与个人的写法有关吧

可能只有我那么傻(⊙_⊙)?

按照上面的，计算左边对右边的贡献是类似归并排序一样的过程，是用两个指针在两个部分扫，把较大的那一个放到数组里（不妨设为$w$），然后再用$w$覆盖原数组。这样排序，**有可能会让右半部分的排到前面去**，这是没有问题的。但问题是，我们要计算右边内部自身的贡献的时候，就不能提前给它排好序，但又要先计算左右的贡献，所以只能开一个临时数组（记为$tmp$）。对于左半部分递归回来已经排好序了，右半部分只能对$tmp$手动排序。于此同时，也说明了，$w$覆盖原数组的步骤应该放在最后进行。

当递归到右半部分$[mid+1,r]$时，我们调用的是没有排过序的数组，**所以右半部分不管怎么变化都还是会在右半部分**。注意在这一过程中会修改$w$数组，当回溯到$[l,r]$时，$w$数组就被改得不成人样了。

那怎么解决这个问题呢？既然$w$数组有问题，那干脆不要$w$数组了，我们就计算左对右贡献的时候就只计算贡献，而不排序。当最后计算完右边内部自身贡献后，再统一对$[l,r]$排序。

写得有点乱，看着代码会好一点。。。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
const int N=5e4+10;
int n,tot;
int tmp[N];
struct ask
{
	int t;//位置
	int x;//高度
	int y;//速度
}num[N],v[N],rt[N];//num是一开始输入和倒序的数组，v是CDQ中一层层排序的数组，rt是用来排序右半部分的临时数组
struct node
{
	int maxn;
	double cnt;
	node operator + (const node &a) const//重载加号，方便计算
	{
		if(maxn>a.maxn) return *this;
		if(maxn<a.maxn) return a;
		return (node){maxn,cnt+a.cnt};
	}
}f[N][2];
struct tree
{
	int left,right;
	node val;
}t[4*N];
inline bool cmp1(ask a,ask b)//按照位置排序
{
	return a.t<b.t;
}
inline bool cmp2(ask a,ask b)//按照高度排序
{
	return a.x>b.x;
}
inline void build(int p,int l,int r)//线段树建树
{
	t[p].left=l,t[p].right=r;
	t[p].val=(node){0,0};
	if(l==r) return;
	int mid=(t[p].left+t[p].right)/2;
	build(p*2,l,mid);
	build(p*2+1,mid+1,r);
}
inline void change(int p,int pos,node c)//单点修改
{
	if(t[p].left==t[p].right)
	{
		t[p].val=t[p].val+c;
		return;
	}
	int mid=(t[p].left+t[p].right)/2;
	if(pos<=mid) change(p*2,pos,c);
	else change(p*2+1,pos,c);
	t[p].val=t[p*2].val+t[p*2+1].val;
}
inline void clear(int p,int pos)//把修改的清空
{
	t[p].val=(node){0,0};
	if(t[p].left==t[p].right) return;
	int mid=(t[p].left+t[p].right)/2;
	if(pos<=mid) clear(p*2,pos);
	else clear(p*2+1,pos);
}
inline node query(int p,int l,int r)//区间查询
{
	if(l<=t[p].left&&r>=t[p].right) return t[p].val;
	int mid=(t[p].left+t[p].right)/2;
	node ans=(node){0,0};
	if(l<=mid) ans=ans+query(p*2,l,r);
	if(r>mid) ans=ans+query(p*2+1,l,r);
	return ans;
}
inline void CDQ(int l,int r,int stg)
{
	if(l==r){ if(f[v[l].t][stg].maxn==0) f[v[l].t][stg]=(node){1,1}; return; }//注意这里不能用+号，而是判断是否为0
	int mid=(l+r)/2,p=l,q=mid+1;
	CDQ(l,mid,stg);//递归计算左半部分
	for(int i=mid+1;i<=r;i++)//把右半部分的塞进临时数组
		rt[i]=v[i];
	sort(rt+mid+1,rt+r+1,cmp2);//对右半部分直接排序
	for(int i=l;i<=r;i++)
	{
		if((p<=mid&&v[p].x>=rt[q].x)||q>r) change(1,v[p].y,f[v[p].t][stg]),p++;
		else 
		{ 
			node cmp=query(1,rt[q].y,tot); 
			if(cmp.maxn) cmp.maxn++,f[rt[q].t][stg]=f[rt[q].t][stg]+cmp;//不为0时才更新答案，注意要+1
			q++;
		}
	}
	for(int i=l;i<=mid;i++)
		clear(1,v[i].y);//把修改的清空
	CDQ(mid+1,r,stg);//递归计算右半部分
	sort(v+l,v+r+1,cmp2);//对当前区间[l,r]排序
}
inline void solve(int stg)
{
	for(int i=1;i<=n;i++)
		v[i]=num[i],tmp[i]=num[i].y;
	sort(v+1,v+n+1,cmp1);
	sort(tmp+1,tmp+n+1);
	tot=unique(tmp+1,tmp+n+1)-(tmp+1);
	for(int i=1;i<=n;i++)
		v[i].y=lower_bound(tmp+1,tmp+tot+1,v[i].y)-tmp;//离散化
	build(1,1,tot);
	CDQ(1,n,stg);
}
int main()
{
	int ans=0;
	double sum=0;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		num[i].t=i;
		scanf("%d%d",&num[i].x,&num[i].y);
	}
	solve(0);
	for(int i=1;i<=n;i++)
		num[i]=(ask){n-i+1,-num[i].x,-num[i].y};//把数组倒过来，高度和速度取负
	solve(1);
	for(int i=1;i<=n;i++)
		ans=max(ans,f[i][0].maxn);//计算最大长度
	printf("%d\n",ans);
	for(int i=1;i<=n;i++)
		if(f[i][0].maxn==ans) sum+=f[i][0].cnt;//计算总方案数
	for(int i=1;i<=n;i++)
	{
		if(f[i][0].maxn+f[n-i+1][1].maxn==ans+1) printf("%.5lf ",(f[i][0].cnt*f[n-i+1][1].cnt)/sum);//计算每一个导弹被拦截的概率
		else printf("0.00000 ");
	}
	return 0;
}
```



---

## 作者：nofind (赞：11)

## [题意](https://www.luogu.com.cn/problem/P2487)

第一问显然是在问你二维$LIS$长度。  
第二问实际上就是在问你每个位置在多少$LIS$的方案中出现过，拿它除总方案数就是概率。

我们设$f_i$表示以$i$为结尾的$LIS$长度，$g_i$表示以$i$为开头的$LIS$长度，$f'_i$表示以$i$为结尾的$LIS$方案数，$g'_i$表示以$i$为开头的$LIS$方案数。

我们只要求出上面那四个东西，那么对于一个位置$i$，我们先判断下$f_i+g_i-1$是否为$LIS$长度，其中$-1$是因为$i$这个位置被算了两次。如果$f_i+g_i-1$等于$LIS$长度，那么$i$这个位置的方案数为$f'_i*g'_i$。

那么回到怎么求的问题上，这显然是个三维偏序：时间+高度+速度，我们可以用$CDQ$分治解决:  
以求$f,f'$为例，求$g,g'$实际上就是将序列倒过来求最长不下降子序列。  
首先导弹就是按时间给的，时间已经有序了，我们进行$CDQ$分治，假设求出了$[l,mid]$的$f$，按照$CDQ$分治的方法用$[l,mid]$更新$[mid+1,r]$，之后递归求$[mid+1,r]$的答案。

于是就这么个板子我因为排序不记录$id$写了一晚上，我也是真的菜。

为想看代码的人解释点东西~~一眼把我看到底的人请无视~~：  
1.我将$f,f'$、$g,g'$合并成了$STL\ pair$，第一关键字是长度，第二关键字是方案数，并写了个取$max$函数。  
2.我开了两个树状数组$tr1,tr2$，$tr1$维护后缀$min$，如果不知道树状数组维护后缀信息的请自行百度。

code:
```
#include<bits/stdc++.h>
using namespace std;
#define lowbit(x) (x&-x)
#define pid pair<int,double>
#define mkp make_pair
#define fir first
#define sec second
const int maxn=5e4+10;
int n,num;
int a[maxn];
pid ans;
pid f[maxn],g[maxn];
struct Flies{int h,v,id;}fly_pre[maxn],fly[maxn];
inline bool cmp1(Flies x,Flies y){return x.h>y.h;}
inline bool cmp2(Flies x,Flies y){return x.h<y.h;}
inline pid operator+(pid a,pid b){return mkp(a.fir+b.fir,a.sec+b.sec);}
inline pid max(pid a,pid b)
{
	if(a.fir!=b.fir)return a.fir>b.fir?a:b;
	else return mkp(a.fir,a.sec+b.sec);
}
struct Tree_arry1
{
	pid a[maxn];
	inline void clear(int x){for(int i=x;i;i-=lowbit(i))a[i]=mkp(0,0);}
	inline void add(int x,pid k){for(int i=x;i;i-=lowbit(i))a[i]=max(a[i],k);}
	inline pid query(int x){pid res=mkp(0,0);for(int i=x;i<=num;i+=lowbit(i))res=max(res,a[i]);return res;}
}tr1;
void cdq1(int l,int r)
{
	if(l==r)return;
	int mid=(l+r)>>1;
	cdq1(l,mid);
	for(int i=l;i<=r;i++)fly[i]=fly_pre[i];
	sort(fly+l,fly+mid+1,cmp1);sort(fly+mid+1,fly+r+1,cmp1);
	for(int i=l,j=mid+1;j<=r;j++)
	{
		while(i<=mid&&fly[i].h>=fly[j].h)tr1.add(fly[i].v,f[fly[i].id]),i++;
		f[fly[j].id]=max(f[fly[j].id],tr1.query(fly[j].v)+mkp(1,0));
	}
	for(int i=l;i<=mid;i++)tr1.clear(fly[i].v);
	cdq1(mid+1,r);
}
struct Tree_arry2
{
	pid a[maxn];
	inline void clear(int x){for(int i=x;i<=num;i+=lowbit(i))a[i]=mkp(0,0);}
	inline void add(int x,pid k){for(int i=x;i<=num;i+=lowbit(i))a[i]=max(a[i],k);}
	inline pid query(int x){pid res=mkp(0,0);for(int i=x;i;i-=lowbit(i))res=max(res,a[i]);return res;}
}tr2;
void cdq2(int l,int r)
{
	if(l==r)return;
	int mid=(l+r)>>1;
	cdq2(l,mid);
	for(int i=l;i<=r;i++)fly[i]=fly_pre[i];
	sort(fly+l,fly+mid+1,cmp2);sort(fly+mid+1,fly+r+1,cmp2);
	for(int i=l,j=mid+1;j<=r;j++)
	{
		while(i<=mid&&fly[i].h<=fly[j].h)tr2.add(fly[i].v,g[fly[i].id]),i++;
		g[fly[j].id]=max(g[fly[j].id],tr2.query(fly[j].v)+mkp(1,0));
	}
	for(int i=l;i<=mid;i++)tr2.clear(fly[i].v);
	cdq2(mid+1,r);
}
int main()
{
	//freopen("test.in","r",stdin);
	//freopen("test.out","w",stdout);
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d%d",&fly_pre[i].h,&fly_pre[i].v),fly_pre[i].id=i,a[++num]=fly_pre[i].v;
	sort(a+1,a+num+1);num=unique(a+1,a+num+1)-(a+1);
	for(int i=1;i<=n;i++)fly_pre[i].v=lower_bound(a+1,a+num+1,fly_pre[i].v)-a;
	for(int i=1;i<=n;i++)f[i]=g[i]=mkp(1,1);
	cdq1(1,n);
	reverse(fly_pre+1,fly_pre+n+1);cdq2(1,n);
	for(int i=1;i<=n;i++)ans=max(ans,f[i]);
	printf("%d\n",ans.fir);
	for(int i=1;i<=n;i++)
		if((f[i].fir+g[i].fir-1)==ans.fir)printf("%.5lf ",1.0*(f[i].sec*g[i].sec)/ans.sec);
		else printf("%.5lf ",0.0);
	return 0;
}
```


---

## 作者：STrAduts (赞：8)

题目要求一个数对序列的二维最长下降子序列，我们称其为 Q。

并求出每一个元素分别在可能的 Q 中出现了多少次。

直接 Dp，时间复杂度 $O(n^2)$ 不行。考虑 CDQ 分治 优化 Dp。

即我们每次在分治时，先递归左半部分，在根据左半部分转移右半部分，最后递归右半部分。

嗯。很有道理。

CDQ 维护两组 pair 值，first 统一表示长度，second 统一表示方案数。

而 $dp_{i, 0}$ 和 $dp_{i, 1}$ 分别指以 $i$ 结尾和以 $i$ 开头的 Q 的信息。

因为是二维信息再加一位时间，所以大体框架类似三维偏序。

只不过在 CDQ 中的分治归并排序必须排但又不完全排。

即要先拎出来放进备份，然后在备份上操作，这样就可以让当前还未内部转移的右半部分保持顺序不动，然后在后面在递归进行内部转移。

而备份上的操作又可以把左半部分到右半部分的外部转移做了。

嗯。可以打了。

补充一下，得出 $dp_{i, 0}$ 和 $dp_{i, 1}$ 需要正反跑两次 CDQ，时间复杂度 $O(n\log^2n)$。

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

int Abs (int x) { return x < 0 ? -x : x; }
int Max (int x, int y) { return x > y ? x : y; }
int Min (int x, int y) { return x < y ? x : y; }

int Read () {
    int x = 0, k = 1;
    char s = getchar();
    while (s < '0' || s > '9') {
        if(s == '-')
            k = -1;
        s = getchar ();
    } 
    while ('0' <= s && s <= '9') 
        x = (x << 3) + (x << 1) + (s ^ 48), s = getchar ();
    return x * k;
}

void Write (int x) {
    if(x < 0) 
        x = -x, putchar ('-');
    if(x > 9)
        Write (x / 10);
    putchar (x % 10 + '0');
}

void Print (int x, char s) { Write (x), putchar (s); }

const int MAXN = 5e4 + 5;

bool Type; 
// 把两个 CDQ Rua 到一起又要在一些细节有所区分，所以开个 bool。
int Num[MAXN], Len;
#define pid pair<int, double>
// long long 是假的，这道题中间过程不止 long long。
// 而 double 钟爱存储大小，原因因此舍弃一些精度，而这刚好符合我们的需求。
pid Dp[MAXN][2], BIT[MAXN][2];

pid operator + (pid a, pid b) { // pair 的加法重载。
    return make_pair (a.first + b.first, a.second + b.second);
}

pid Max_Pair (pid x, pid y) { // 便于方程转移的手写 Max。
    if (x.first != y.first)
        return x.first > y.first ? x : y;
    return make_pair (x.first, x.second + y.second);
}

int Low_Bit (int x) { return x & -x; }

void Clear (int k) {
    if (!Type) {
        for (int i = k; i; i -= Low_Bit(i))
            BIT[i][0] = make_pair (0, 0);        
    }
    else {
        for (int i = k; i <= Len; i += Low_Bit(i))
            BIT[i][1] = make_pair (0, 0);            
    }  
}

void Update (int k, pid x) {
    if (!Type) {
        for (int i = k; i; i -= Low_Bit(i))
            BIT[i][0] = Max_Pair (BIT[i][0], x);        
    }
    else {
        for (int i = k; i <= Len; i += Low_Bit(i))
            BIT[i][1] = Max_Pair (BIT[i][1], x);            
    }  
}

pid Query (int k) {
    pid Res = make_pair (0, 0);
    if (!Type) {
        for (int i = k; i <= Len; i += Low_Bit(i))
            Res = Max_Pair (Res, BIT[i][0]);
        return Res;        
    }
    else {
        for (int i = k; i; i -= Low_Bit(i))
            Res = Max_Pair (Res, BIT[i][1]);
        return Res;               
    }
}
// 将两颗 BIT Rua 在一起，用 Type 使得两个 CDQ 维护的信息刚好反过来。

struct Node {
    int h, v, Id;
    Node () {}
    Node (int H, int V, int I) {
        h = H, v = V, Id = I;
    }
} q[MAXN], Tmp[MAXN];
// Tmp 即我们操作的备份。

bool Check (int x, int y) { return !Type ? x >= y : x <= y; }
bool Cmp (Node x, Node y) { return !Type ? x.h > y.h : x.h < y.h; }
// 两种不同的排序方式，因偏序实现不同因人而异。用 Type 控制相反。

void CDQ (int l, int r) {
    if (l == r)
        return ;
    int Mid = (l + r) >> 1;
    CDQ (l, Mid);
    for (int i = l; i <= r; i++)
        Tmp[i] = q[i];
    sort (Tmp + l, Tmp + Mid + 1, Cmp);
    sort (Tmp + Mid + 1, Tmp + r + 1, Cmp);
    // 排序，又不完全排序。注意这里是在备份上操作，以完成偏序。
    for (int i = l, j = Mid + 1; j <= r; j++) {
        while (i <= Mid && Check (Tmp[i].h, Tmp[j].h))
            Update (Tmp[i].v, Dp[Tmp[i].Id][Type]), i++ /*, printf ("%d %d\n", Type, i)*/ ;  // 遍历新的可能对当前 j 产生转移贡献的 i。
        Dp[Tmp[j].Id][Type] = Max_Pair (Dp[Tmp[j].Id][Type], Query (Tmp[j].v) + make_pair (1, 0));
        // 转移方程。Type 控反。
        // printf ("%d %d %d %d\n", Type, Tmp[j].Id, Dp[Tmp[j].Id][Type].first, (Query (Tmp[j].v) + make_pair (1, 0)).first);
    }
    for (int i = l; i <= Mid; i++)
        Clear (Tmp[i].v);
    // 记得将 BIT 清空，不影响以后的转移。
    CDQ (Mid + 1, r);
}

/*
133 行，曾出现了一个 ub。
Update (Tmp[i].v, Dp[Tmp[i].Id][Type]), i++; 
不等价于
Update (Tmp[i].v, Dp[Tmp[i++].Id][Type]); 
原因或许是函数传参从右到左。
*/

int main () {
    int n = Read ();
    for (int i = 1; i <= n; i++) {
        q[i].h = Read (), q[i].v = Read (), q[i].Id = i;
        Num[i] = q[i].v;
    }
    sort (Num + 1, Num + n + 1);
    Len = unique (Num + 1, Num + n + 1) - Num - 1;
    for (int i = 1; i <= n; i++)
        q[i].v = lower_bound (Num + 1, Num + Len + 1, q[i].v) - Num; 
   	// BIT 和值域有关，所以离散化。

    for (int i = 1; i <= n; i++)
        Dp[i][0] = Dp[i][1] = make_pair (1, 1);
   	// Dp 初值，即当前 Q 只有 i 一个元素。
    CDQ (1, n);
    reverse (q + 1, q + n + 1);
    Type = 1, CDQ (1, n);

    pid Ans = make_pair (0, 0);
    for (int i = 1; i <= n; i++)
        Ans = Max_Pair (Ans, Dp[i][0]);
    Print (Ans.first, '\n');
    // for (int i = 1; i <= n; i++) 
    //     printf ("%d %f %d %f\n", Dp[i][0].first, Dp[i][0].second, Dp[i][1].first, Dp[i][1].second);
    for (int i = 1; i <= n; i++)
        if (Dp[i][0].first + Dp[i][1].first - 1 == Ans.first)
        // 判断当前 i 是否被至少一个 Q 所包含
            printf ("%.5f ", Dp[i][0].second * Dp[i][1].second / Ans.second);
        else
            printf ("0.00000 ");
    return 0;
}

/*
180 行也曾有一个未发现原因的 ub。
printf ("0.00000 ");
不等价于
printf ("%.5f ", 0);
*/
```





---

## 作者：Taduro (赞：4)

提供一篇k-d tree题解。

首先第一问就是裸的三维偏序，还给你排好序消去了一维。

那么在k-d tree中加一个横纵坐标都是无限大的点做起点，这个点的答案是0，方案数是1（后面反着做的时候要加一个横纵坐标都是无限小的点）。之后用k-d tree模拟就好了。注意要在k-d tree中维护当前矩形的答案和方案数、当前点的答案和方案数。我的写法是先把所有点去重后都加进k-d tree里，所以要维护每个点是否被激活，这种做法比插入节点定期重构快。

之后每个点被选中的概率=经过它的方案数/总方案数。

而经过它的方案数=从前面经过它的方案数*从后面经过它的方案数。

这里说的从前面和从后面就是正着dp和倒着dp的意思，反正很简单大家都明白。

而一个点能被经过首先需要从前面经过它的答案+从后面经过它的答案-1=整个序列的答案。

反正就是把暴力的dp加一个数据结构优化一下就好了。

但是不是太好写。。我为了只写一遍k-d tree费尽了心思。

```c++
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
#ifdef ONLINE_JUDGE
char ss[1<<17],*A=ss,*B=ss;
inline char gc(){if(A==B){B=(A=ss)+fread(ss,1,1<<17,stdin);if(A==B)return EOF;}return*A++;}
template<class T>inline void read(T&x){
	static char c;static int y;
	for(c=gc(),x=0,y=1;c<48||57<c;c=gc())if(c=='-')y=-1;
	for(;48<=c&&c<=57;c=gc())x=((x+(x<<2))<<1)+(c^'0');
	x*=y;
}
#else
void read(int&x){scanf("%d",&x);}
#endif
struct point{int d[2],h;}a[50010],b[50010],c[50010];
struct mis{int u; double v;}dp[50010][2],ans;
struct kdtree{
	int d[2],x[2],y[2],ch[2],sz,lv,u,u1;
	double v,v1;
}t[50010];
int root,tot,n,u,f,p,res,m;
double sum,pos[50010];
inline bool cmp(point x,point y){return x.d[u]<y.d[u];}
inline bool cmp2(point x,point y){
	return (x.d[0]<y.d[0])||(x.d[0]==y.d[0]&&x.d[1]<y.d[1]);
}
inline void pushup(int rt){
	int l=t[rt].ch[0],r=t[rt].ch[1];
	if (l){
		t[rt].x[0]=min(t[rt].x[0],t[l].x[0]);
		t[rt].y[0]=min(t[rt].y[0],t[l].y[0]);
		t[rt].x[1]=max(t[rt].x[1],t[l].x[1]);
		t[rt].y[1]=max(t[rt].y[1],t[l].y[1]);
	}
	if (r){
		t[rt].x[0]=min(t[rt].x[0],t[r].x[0]);
		t[rt].y[0]=min(t[rt].y[0],t[r].y[0]);
		t[rt].x[1]=max(t[rt].x[1],t[r].x[1]);
		t[rt].y[1]=max(t[rt].y[1],t[r].y[1]);
	}
}
inline int build(int d,int l,int r){
	if (l>r) return 0; u=d;
	int mid=(l+r)>>1,rt=++tot;
	nth_element(c+l,c+mid,c+r+1,cmp);
	t[rt].x[0]=t[rt].x[1]=t[rt].d[0]=c[mid].d[0];
	t[rt].y[0]=t[rt].y[1]=t[rt].d[1]=c[mid].d[1];
	t[rt].ch[0]=build(d^1,l,mid-1);
	t[rt].ch[1]=build(d^1,mid+1,r);
	pushup(rt); return rt;
}
inline void up(int rt){
	int l=t[rt].ch[0],r=t[rt].ch[1];
	t[rt].sz=t[l].sz+t[r].sz+t[rt].lv;
	int x=max(t[l].u,t[r].u); double y=0;
	y+=t[l].v*(x==t[l].u)+t[r].v*(x==t[r].u);
	if (t[rt].u1>x) t[rt].v=t[rt].v1;
	if (t[rt].u1==x) t[rt].v=y+t[rt].v1;
	if (t[rt].u1<x) t[rt].u=x,t[rt].v=y;
}
void ins(int rt,point x){
	if (t[rt].d[0]==x.d[0]&&t[rt].d[1]==x.d[1]){
		t[rt].lv++; t[rt].sz++;
		if (t[rt].u1<dp[x.h][f].u)
			t[rt].u1=dp[x.h][f].u,t[rt].v1=dp[x.h][f].v;
		else
			if (t[rt].u1==dp[x.h][f].u) t[rt].v1+=dp[x.h][f].v;
		if (t[rt].u<dp[x.h][f].u)
			t[rt].u=dp[x.h][f].u,t[rt].v=dp[x.h][f].v;
		else
			if (t[rt].u==dp[x.h][f].u) t[rt].v+=dp[x.h][f].v;
		return;
	}
	int l=t[rt].ch[0],r=t[rt].ch[1];
	if (t[l].x[0]<=x.d[0]&&x.d[0]<=t[l].x[1]&&
		t[l].y[0]<=x.d[1]&&x.d[1]<=t[l].y[1])
		ins(l,x);
	if (t[r].x[0]<=x.d[0]&&x.d[0]<=t[r].x[1]&&
		t[r].y[0]<=x.d[1]&&x.d[1]<=t[r].y[1])
		ins(r,x);
	up(rt); return;
}
void query(int rt,point x){
	if (!rt||!t[rt].sz) return;
	if (t[rt].x[f^1]*p<x.d[0]*p||t[rt].y[f^1]*p<x.d[1]*p)
		return;
	if (t[rt].x[f]*p>=x.d[0]*p&&t[rt].y[f]*p>=x.d[1]*p){
		if (t[rt].u==ans.u) ans.v+=t[rt].v;
		if (t[rt].u>ans.u) ans.u=t[rt].u,ans.v=t[rt].v;
		return;
	}
	if (t[rt].d[0]*p>=x.d[0]*p&&t[rt].d[1]*p>=x.d[1]*p&&t[rt].lv){
		if (t[rt].u1==ans.u) ans.v+=t[rt].v1;
		if (t[rt].u1>ans.u) ans.u=t[rt].u1,ans.v=t[rt].v1;
	}
	int l=t[rt].ch[0],r=t[rt].ch[1];
	if (t[l].u>t[r].u){
		if (t[l].u>=ans.u) query(l,x);
		if (t[r].u>=ans.u) query(r,x);
	}
	else{
		if (t[r].u>=ans.u) query(r,x);
		if (t[l].u>=ans.u) query(l,x);
	}
}
int main(){
	read(n);
	for (int i=1; i<=n; i++){
		read(a[i].d[0]),read(a[i].d[1]);
		a[0].d[0]=max(a[0].d[0],a[i].d[0]);
		a[0].d[1]=max(a[0].d[1],a[i].d[1]);
		b[i]=a[i]; b[i].h=i;
	}
	a[n+1].d[0]=0,a[n+1].d[1]=0;
	b[0]=a[0]; b[n+1]=a[n+1]; b[n+1].h=n+1;
	sort(a,a+n+2,cmp2); c[++m]=a[0];
	for (int i=1; i<=n+1; i++)
		if (a[i].d[0]!=a[i-1].d[0]||a[i].d[1]!=a[i-1].d[1])
			c[++m]=a[i];
	root=build(0,1,m);
	p=1; f=0; dp[0][0]=(mis){0,1};
	ins(root,b[0]);
	for (int i=1; i<=n; i++){
		query(root,b[i]); ans.u++;
		dp[i][f]=ans; ins(root,b[i]);
		res=max(res,ans.u); ans=(mis){0,0};
	}
	printf("%d\n",res);
	for (int i=1; i<=n; i++)
		if (dp[i][0].u==res) sum+=dp[i][0].v;
	for (int i=1; i<=tot; i++)
		t[i].lv=t[i].sz=t[i].u1=t[i].u=t[i].v1=t[i].v=0;
	f=1; p=-1; dp[n+1][1]=(mis){0,1};
	ins(root,b[n+1]);
	for (int i=n; i>=1; i--){
		query(root,b[i]); ans.u++;
		dp[i][f]=ans; ins(root,b[i]);
		ans=(mis){0,0};
	}
	for (int i=1; i<=n; i++){
		if (dp[i][0].u+dp[i][1].u-1==res)
			pos[i]=(dp[i][0].v*dp[i][1].v)/sum;
		printf("%.5lf ",pos[i]);
	}
	return 0;
}
```



---

## 作者：_Ponder_ (赞：4)

[拦截导弹](https://www.luogu.com.cn/problem/P2487)


### 题目大意

给定若干元素，每个元素有 $3$ 个属性 $t_i,h_i,v_i$，求出一个使得对于 $\forall i,j,i>j$，$t_i>t_j,h_i\le h_j,v_i\le v_j$ 均成立的最长的子序列 $a$ 的长度。并计算每个元素在所有的可能的 $a$ 方案中的出现概率。

### 思路分析

- **先看第一个问题**：

按 $t$ 排好序后容易发现其实就是一个二维的不上升子序列问题。

首先有一个 $n^2$ 的 DP 方程：

$$f_i=\max(f_j)+1,j<i,h_j\ge h_i,v_j\ge v_i$$

其中 $f_i$ 表示以 $i$ 结尾的最长不上升子序列的长度。

但问题类似于三维偏序的形式，因此考虑用 CDQ 分治进行优化。

考虑 CDQ 分治的过程，发现只需要在归并时查询前缀最值即可。

具体的说。在 CDQ 分治时，先递归左半部分，再将左右部分分别按照 $h$ 排序，维护左右双指针 $j,i$，若 $h_i\le h_j$，那么在树状数组的 $v_j$ 位置加入 $f_j$ 的贡献，否则通过树状数组中 $v_i$ 的前缀最值更新 $f_i$，最后清空树状数组，复原数组，递归右半部分。

- **再看第二个问题**：

我们发现，一个元素的出现概率可以通过计数的方法计算。

具体的说，我们在维护 $f_i$ 时顺便维护 $g_i$，表示长度为 $f_i$ 以 $i$ 结尾的的不上升子序列的个数。

但这样还是不行，我们发现一个元素可能位于整个序列的最长不上升子序列的中间位置。因此，我们可以令 $f'_i$ 表示以 $i$ 开始的最长不上升子序列的长度，令 $g'_i$ 表示长度为 $f'_i$ 以 $i$ 开始的的不上升子序列的个数。

那么这时就可以统计答案了，当 $f_i+f'_i-1=\text{len}$ 时（$\text{len}$ 表示整个序列的最长不上升子序列的长度），即这个元素可以组成整个序列的最长不上升子序列时，它出现的概率为：

$$\frac{g_ig'_i}{\text{sum}}$$

其中 $\text{sum}$ 表示整个序列的最长不上升子序列的个数。

而 $f'$ 和 $g'$ 可以通过将数组逆序取反后再跑一遍一模一样的 CDQ 解决。

- **其他**

需要对 $v$ 离散化。

记得开 `double`。

### 代码

代码小卡了一下常，目前是最优解。

```
#include <iostream>
#include <cmath>
#include <cstring>
#include <algorithm>

using namespace std;
const int N=50100;

int n,m,in1,in2;
int Y[N],c[N];

#define getchar() (S==T&&(T=(S=B)+fread(B,1,1<<16,stdin),S==T)?EOF:*S++)
char B[1<<16],*S=B,*T=B;

inline int read(){
    int x=0;char ch=getchar();
    while(ch<'0'||'9'<ch) ch=getchar();
    while('0'<=ch&&ch<='9') x=x*10+ch-'0',ch=getchar();
    return x;
}//整数快读

inline void dwrite(int x){
    if(!x){putchar('0');return ;}
    int bit[20],p=0,i;
    for (;x;x/=10) bit[++p]=x%10;
    for (i=p;i>0;--i) putchar(bit[i]+48);
}//整数快写

inline void write(double x){
    static int n=100000,k=5;
    int y=(int)(x*n)%n;x=(int)x;
    dwrite(x),putchar('.');
    int bit[8],p=0,i;
    for(;p<k;y/=10) bit[++p]=y%10;
    for(i=p;i>0;i--) putchar(bit[i]+48);
}//小数快写

struct Node{
    int x,y,id;
}a[N],b[N];

struct Data{
    int maxn;
    double cnt;
    Data operator + (const Data &b){
        Data c;
        c.maxn=max(maxn,b.maxn);
        c.cnt=((maxn==c.maxn)?cnt:0)+((b.maxn==c.maxn)?b.cnt:0);
        return c;//f 和 g 的结构题，以重载运算符的形式更新
    }
}f[N],f2[N],ans;

struct Tree_Array{
    Data a[N];
    int tt[N],times;//树状数组时间戳 O(1) 清空
    #define lowbit(x) ((x)&(-(x)))
    inline void add(int x,Data v){
        for(;x;x-=lowbit(x)){
            if(tt[x]==times) a[x]=a[x]+v;
            else a[x]=v,tt[x]=times;
        }
    }
    inline void clear(){times++;}
    inline Data ask(int x){
        Data ans=Data{0,0};
        for(;x<=m;x+=lowbit(x))
            if(tt[x]==times) ans=ans+a[x];
        return ans;
    }
}tree;

void CDQ(int l,int r){
    if(l==r){f[a[l].id]=f[a[l].id]+Data{1,1};return ;}//边界
    int mid=l+r>>1,j=l;
    CDQ(l,mid);
    sort(a+l,a+mid+1,[](Node a,Node b){return a.x>b.x;});
    sort(a+mid+1,a+r+1,[](Node a,Node b){return a.x>b.x;});//按 x 排序
    for(register int i=mid+1;i<=r;++i){
        while(j<=mid&&a[j].x>=a[i].x) tree.add(a[j].y,f[a[j].id]),j++;//加入树状数组
        Data temp=tree.ask(a[i].y);temp.maxn++;//统计答案
        f[a[i].id]=f[a[i].id]+temp;
    }
    tree.clear();
    int minn=n+1,maxn=0;//手写的桶排，按照 id 来排
    for(int i=mid+1;i<=r;++i){
        c[a[i].id]=i;
        minn=min(minn,a[i].id);
        maxn=max(maxn,a[i].id);
    }
    for(int i=minn;i<=maxn;++i)
        b[i]=a[c[i]];
    for(int i=mid+1;i<=r;++i)
        a[i]=b[i];
    CDQ(mid+1,r);
}

int main(){
    n=read();
    for(register int i=1;i<=n;++i){
        in1=read();in2=read();
        a[i]=Node{in1,in2,i};
        Y[i]=in2;
    }
    sort(Y+1,Y+n+1);
    m=unique(Y+1,Y+n+1)-Y-1;
    for(register int i=1;i<=n;++i)
        a[i].y=lower_bound(Y+1,Y+m+1,a[i].y)-Y;//离散化
    CDQ(1,n);
    for(register int i=1;i<=n;++i) ans=ans+f[i];//更新答案，只需要一边
    dwrite(ans.maxn);putchar('\n');
    for(register int i=1;i<=n;++i){//数组反转
        f2[i]=f[i];
        f[i]=Data{0,0};
        a[i].id=n-a[i].id+1;
        a[i].x=-a[i].x;
        a[i].y=m-a[i].y+1;
    }
    for(int i=1;i<=n;++i)//一样的桶排
        c[a[i].id]=i;
    for(int i=1;i<=n;++i)
        b[i]=a[c[i]];
    for(int i=1;i<=n;++i)
        a[i]=b[i];
    CDQ(1,n);
    reverse(f+1,f+n+1);
    for(register int i=1;i<=n;++i){
        if(f[i].maxn+f2[i].maxn-1==ans.maxn)
            write(1.0*f[i].cnt*f2[i].cnt/ans.cnt),putchar(' ');
        else putchar('0'),putchar(' ');//判定答案
    }
    return 0;
}
```

---

## 作者：浮尘ii (赞：4)

Tag：动态规划 离散化 三维偏序 二维线段树 动态开点

设F[i],rF[i]分别表示以第i个结尾、以第i个开始的最多可选元素个数（第i个必须选），G[i],rG[i]表示以上选取最多元素个数的方案数，则有：

F[i]=max⁡{F[j]}+1(j≤i且$h_j$≥$h_i$且$v_j$≥$v_i$)

G[i]=∑G[j] (j≤i且$h_j$≥$h_i$且$v_j$≥$v_i$且F[i]=F[j]+1)

类似地，有：

rF[i]=max⁡{rF[j]}+1(j≥i且$h_j$≤$h_i$且$v_j$≤$v_i$)

rG[i]=∑rG[j] (j≥i且$h_j$≤$h_i$且$v_j$≤$v_i$且rF[i]=rF[j]+1)

则最多元素个数ans=max⁡{F[i]}.

总的方案数tot=∑G[i] (F[i]=ans),

第i个点被选择的方案数H[i]=0(F[i]+rF[i]-1≠ans), 或H[i]=G[i]\*rG[i] (F[i]+rF[i]-1=ans)


我们考虑用数据结构维护这个递推的过程。我们发现，如果我们以$h_i$为横坐标，$v_i$为纵坐标建立坐标系，并且按下标的顺序插入，那么我们每次递推的过程就是查询一个矩形区域内的最大值和最大值出现的次数。于是我们可以使用二维树状数组或者二维线段树维护。

考虑到本题不能接受$O(n^2)$的空间复杂度，于是我们放弃使用二维树状数组，而使用动态开点的二维线段树。我们需要支持的操作有：单点修改、矩形查询。而每个结点维护的信息为区间内的最大值和区间内最大值的出现次数。

至此，即可解决本题。时间复杂度$O(nlog_2^2n)$，空间复杂度$O(nlog_2^2 n)$.

注：此题亦可使用CDQ分治解决，在时间和空间上都会更加优秀。


```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>

using namespace std;

using ld = long double;
const size_t    MaxN = 50005;

const size_t    _M_size = 1 << 28;
char            _M_pool[_M_size], *_M_cur;

inline void* operator new(size_t size)
{ return _M_cur -= size; }
inline void operator delete(void* ptr)
{ }

int N, H[MaxN], V[MaxN];
int H0[MaxN], HN, V0[MaxN], VN;
int F[MaxN], rF[MaxN];
ld  G[MaxN], rG[MaxN];
int Ans;
ld  Cnt;

class segtreenode {
    struct node {
        int    max;
        ld    cnt;
        node    *lc, *rc;

        node(): max(0), cnt(0), lc(nullptr), rc(nullptr){ }
    } *root;
    void modify(node *&o, int l, int r, int pos, int w, ld d)
    {
        if(!o)
            o = new node();
        if(w > o->max)
            o->max = w, o->cnt = d;
        else if(w == o->max)
            o->cnt += d;
        if(l == r)
            return;
        int    m = l + r >> 1;
        if(pos <= m)
            modify(o->lc, l, m, pos, w, d);
        else
            modify(o->rc, m + 1, r, pos, w, d);
    }
    void query(node *o, int l, int r, int tl, int tr, int& w, ld& d)
    {
        if(!o)
            return;
        if(l >= tl && r <= tr) {
            if(w < o->max)
                w = o->max, d = o->cnt;
            else if(w == o->max)
                d += o->cnt;
            return;
        }
        int    m = l + r >> 1;
        if(tl <= m)
            query(o->lc, l, m, tl, tr, w, d);
        if(tr > m)
            query(o->rc, m + 1, r, tl, tr, w, d);
    }
public:
    segtreenode(): root(nullptr) {}
    inline void modify(int pos, int w, ld d)
    { modify(root, 1, VN, pos, w, d); }
    inline void query(int tl, int tr, int& w, ld& d)
    { query(root, 1, VN, tl, tr, w, d); }
} ;
class segtree {
    struct node {
        segtreenode    x;
        node        *lc, *rc;

        node(): x(), lc(nullptr), rc(nullptr){ }
    } *root;
    void modify(node *&o, int l, int r, int posx, int posy, int w, ld d)
    {
        if(!o)
            o = new node();
        (o->x).modify(posy, w, d);
        if(l == r)
            return;
        int    m = l + r >> 1;
        if(posx <= m)
            modify(o->lc, l, m, posx, posy, w, d);
        else
            modify(o->rc, m + 1, r, posx, posy, w, d);
    }
    void query(node *o, int l, int r, int tlx, int trx, int tly, int _try, int& w, ld& d)
    {
        if(!o)
            return;
        if(l >= tlx && r <= trx) {
            (o->x).query(tly, _try, w, d);
            return;
        }
        int    m = l + r >> 1;
        if(tlx <= m)
            query(o->lc, l, m, tlx, trx, tly, _try, w, d);
        if(trx > m)
            query(o->rc, m + 1, r, tlx, trx, tly, _try, w, d);
    }
public:
    segtree(): root(nullptr) { _M_cur = _M_pool + _M_size; }
    inline void modify(int posx, int posy, int w, ld d)
    { modify(root, 1, HN, posx, posy, w, d); }
    inline void query(int tlx, int trx, int tly, int _try, int& w, ld& d)
    { query(root, 1, HN, tlx, trx, tly, _try, w, d); }
} SegTree;

int main()
{
    cin >> N;
    for(int i = 1; i <= N; ++i)
        scanf("%d%d", H + i, V + i), H0[i] = H[i], V0[i] = V[i];
    sort(H0 + 1, H0 + 1 + N), sort(V0 + 1, V0 + 1 + N);
    HN = unique(H0 + 1, H0 + 1 + N) - H0 - 1, VN = unique(V0 + 1, V0 + 1 + N) - V0 - 1;

    for(int i = 1; i <= N; ++i) {
        H[i] = lower_bound(H0 + 1, H0 + 1 + HN, H[i]) - H0, V[i] = lower_bound(V0 + 1, V0 + 1 + VN, V[i]) - V0;
        int w = 0;
        ld  cnt = 1;
        SegTree.query(H[i], HN, V[i], VN, w, cnt);
        F[i] = ++w, G[i] = cnt;
        SegTree.modify(H[i], V[i], w, cnt);
    }
    SegTree = segtree();
    for(int i = N; i; --i) {
        int w = 0;
        ld  cnt = 1;
        SegTree.query(1, H[i], 1, V[i], w, cnt);
        rF[i] = ++w, rG[i] = cnt;
        SegTree.modify(H[i], V[i], w, cnt);
        if(F[i] > Ans)
            Ans = F[i], Cnt = G[i];
        else if(F[i] == Ans)
            Cnt += G[i];
    }

    cout << Ans << endl;
    for(int i = 1; i <= N; ++i)
        if(F[i] + rF[i] - 1 != Ans)
            printf("0.00000 ");
        else
            printf("%.5Lf ", G[i] * rG[i] / Cnt);

    return 0;
}
```

---

## 作者：lkytxdy (赞：3)

## P2487 [SDOI2011]拦截导弹

lkytxdy 的第一篇题解捏~（雾）

> 有 $n$ 个二元组 $(a,b)$，一个子序列合法，满足对于 $j<i$，$a_j\geq a_i,b_j\geq b_i$。求出最长的合法子序列，和每个二元组出现在最长合法子序列的概率（可能有多个最长合法子序列）。
>
> $1\leq n\leq 5\times 10^4$，$1\leq a_i,b_i\leq 10^9$。

第二问其实是求有多少个最长的合法子序列、每个二元组在所有最长合法子序列中的出现次数。

记 $f_1[i],g_1[i]$ 表示以 $i$ 为结尾的最长不上升子序列长度、方案数，$f_2[i],g_2[i]$ 表示以 $i$ 为开头的最长不上升子序列长度、方案数。

$f,g$ 显然可以做两遍 CDQ 求。

那么第一问的答案为 $ans=\max\limits_{1\leq i\leq n} f_1[i]$（或 $\max f_2[i]$），方案总数为 $tot=\sum_{i=1}^n g_1[i]\times [f_1[i]=ans]$，第二问 $i$ 的答案为 $\dfrac{g_1[i]\times g_2[i]}{tot}\,(f_1[i]+f_2[i]-1=ans)$。

注意 $g_1,g_2,tot$ 要开 `double`，否则会爆 `long long`。

提供一个简洁的代码~

```cpp
//lkytxdy
#include<bits/stdc++.h>
using namespace std;
const int N=5e4+5;
int n,t,v[N];
struct node{int x,y,id;}a[N];
struct data{
	int mx; double cnt;
	friend data operator+(data a,data b){
		data c; c.mx=max(a.mx,b.mx),c.cnt=(a.mx==c.mx)*a.cnt+(b.mx==c.mx)*b.cnt;
		return c;
	}
}f[N],f2[N],c[N],tmp,ans;
void modify(int x,data y){
	for(int i=x;i;i-=i&(-i)) c[i]=c[i]+y;
}
void clear(int x){
	for(int i=x;i;i-=i&(-i)) c[i]={0,0};
}
data query(int x){
	data ans={0,0};
	for(int i=x;i<=t;i+=i&(-i)) ans=ans+c[i];
	return ans;
}
void cdq(int l,int r){
	if(l==r){f[a[l].id]=f[a[l].id]+(data){1,1};return ;}
	int mid=(l+r)/2,j=l;
	cdq(l,mid);
	sort(a+l,a+1+mid,[](node x,node y){return x.x>y.x;});
	sort(a+mid+1,a+1+r,[](node x,node y){return x.x>y.x;});
	for(int i=mid+1;i<=r;i++){
		while(j<=mid&&a[j].x>=a[i].x) modify(a[j].y,f[a[j].id]),j++;
		tmp=query(a[i].y),tmp.mx++;
		f[a[i].id]=f[a[i].id]+tmp;
	} 
	for(int i=l;i<j;i++) clear(a[i].y);
	sort(a+mid+1,a+1+r,[](node x,node y){return x.id<y.id;});
	cdq(mid+1,r);
}
signed main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d%d",&a[i].x,&a[i].y),a[i].id=i,v[++t]=a[i].y;
	sort(v+1,v+1+t),t=unique(v+1,v+1+t)-v-1;
	for(int i=1;i<=n;i++) a[i].y=lower_bound(v+1,v+1+t,a[i].y)-v;
	cdq(1,n);
	for(int i=1;i<=n;i++) ans=ans+f[i],f2[i]=f[i];
	printf("%d\n",ans.mx);
	for(int i=1;i<=n;i++)
		f[i]={0,0},a[i].id=n-a[i].id+1,a[i].x=-a[i].x,a[i].y=t-a[i].y+1;
	sort(a+1,a+1+n,[](node x,node y){return x.id<y.id;});
	cdq(1,n),reverse(f+1,f+1+n);
	for(int i=1;i<=n;i++){
		if(f[i].mx+f2[i].mx-1==ans.mx) printf("%.5lf ",1.0*f[i].cnt*f2[i].cnt/ans.cnt);
		else printf("0 ");
	}
	return 0;
} 
```

---

## 作者：feecle6418 (赞：2)

## K-D Tree 解法

这道题可以用 K-D Tree 做，但是需要一个小 Trick。

首先原题相当于求：**经过 $i$ 的二维最长不上升子序列的个数** 除以 **总的二维最长不上升子序列的个数**，只需要前后各做一遍二维 LIS 即可。

考虑如何快速维护。正常想法是在 K-D Tree 每个节点上维护最小坐标，最大坐标，当前答案，当前答案方案数，区域内最大答案，区域内最大答案方案数。每次先查询，然后将当前点插入。

可是这样必须重构，否则会 TLE。（当然在 Luogu 上加上一大堆 `#pragma` 可以莽过去，但是在极慢的本校 oj 上仍然 TLE。）重构的话代码量太大，有没有更好的方法？

这时就有一个 Trick：先建出一棵**平衡的** K-D Tree，初始信息只有点的坐标，其他信息均为 $0$，可以看做是未激活的点。每次插入不新建节点，而是**激活**一个点，顺便更新信息，这样就能保证 K-D Tree 的绝对平衡。

时间复杂度 $\Theta(n\sqrt{n})$。

代码如下。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
typedef long long ll;
int D,n,ql[2],qr[2],root,a[50005],b[50005],fl[50005],fr[50005],qmax,al;
double ed[50005],st[50005],qsum;
struct TreeNode{
	int a[2],mi[2],mx[2],ls,rs,ans,maxans;
	//ans:目前点答案
	//maxans:区域最大答案 
	//sum:目前点答案有几种方法
	//maxsum:区域最大有几种方法
	double maxsum,sum;
	TreeNode(){
		mi[0]=mi[1]=0x3f3f3f3f,mx[0]=mx[1]=-0x3f3f3f3f,ls=rs=0,sum=ans=maxsum=maxans=0;
	}
	void Clear(){
		mi[0]=mi[1]=0x3f3f3f3f,mx[0]=mx[1]=-0x3f3f3f3f,ls=rs=0,sum=ans=maxsum=maxans=0;
	}
	bool operator <(const TreeNode yy) const {
		return a[D]==yy.a[D]?a[D^1]<yy.a[D^1]:a[D]<yy.a[D];
	}
	int& operator [](int x){
		return a[x];
	}
}t[200005];
void Pushup(int p){
	for(int i=0;i<2;i++){
		t[p].mi[i]=min(min(t[t[p].ls].mi[i],t[t[p].rs].mi[i]),t[p][i]);
		t[p].mx[i]=max(max(t[t[p].ls].mx[i],t[t[p].rs].mx[i]),t[p][i]);
	}
	t[p].maxans=t[p].ans,t[p].maxsum=t[p].sum;
	if(t[t[p].ls].maxans>t[p].maxans)t[p].maxans=t[t[p].ls].maxans,t[p].maxsum=t[t[p].ls].maxsum;
	else if(t[t[p].ls].maxans==t[p].maxans)t[p].maxsum+=t[t[p].ls].maxsum;
	if(t[t[p].rs].maxans>t[p].maxans)t[p].maxans=t[t[p].rs].maxans,t[p].maxsum=t[t[p].rs].maxsum;
	else if(t[t[p].rs].maxans==t[p].maxans)t[p].maxsum+=t[t[p].rs].maxsum;
}
void Insert(int &p,int x,int y,int z,double w,int d){
	if(t[p][0]==x&&t[p][1]==y){
		if(z>t[p].ans)t[p].ans=z,t[p].sum=w;
		else if(z==t[p].ans)t[p].sum+=w;
		if(z>t[p].maxans)t[p].maxans=z,t[p].maxsum=w;
		else if(z==t[p].maxans)t[p].maxsum+=w;
		return ;
	}
	if(d){
		if(y<t[p][1]||(y==t[p][1]&&x<t[p][0]))Insert(t[p].ls,x,y,z,w,d^1);
		else Insert(t[p].rs,x,y,z,w,d^1);
	}
	else {
		if(x<t[p][0]||(x==t[p][0]&&y<t[p][1]))Insert(t[p].ls,x,y,z,w,d^1);
		else Insert(t[p].rs,x,y,z,w,d^1);
	}
	Pushup(p);
}
bool any(int p){
	for(int i=0;i<2;i++)if(t[p].mx[i]<ql[i]||t[p].mi[i]>qr[i])return 0;
	return 1;
}
bool all(int p){
	for(int i=0;i<2;i++)if(t[p].mx[i]>qr[i]||t[p].mi[i]<ql[i])return 0;
	return 1;
}
bool ok(int p){
	for(int i=0;i<2;i++)if(t[p][i]>qr[i]||t[p][i]<ql[i])return 0;
	return 1;
}
void Query(int p){
	if(!p||!any(p))return ;
	if(all(p)){
		if(t[p].maxans>qmax)qmax=t[p].maxans,qsum=t[p].maxsum;
		else if(t[p].maxans==qmax)qsum+=t[p].maxsum;
		return ;
	}
	if(ok(p)){
		if(t[p].ans>qmax)qmax=t[p].ans,qsum=t[p].sum;
		else if(t[p].ans==qmax)qsum+=t[p].sum;
	}
	Query(t[p].ls),Query(t[p].rs);
}
int Rebuild(int l,int r,int d){
	if(l>r)return 0;
	D=d;
	int mid=(l+r)/2;
	nth_element(t+l,t+mid,t+r+1);
	t[mid].ls=Rebuild(l,mid-1,d^1);
	t[mid].rs=Rebuild(mid+1,r,d^1);
	Pushup(mid);
	return mid;
}
int main() {
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d%d",&a[i],&b[i]),t[i][0]=a[i],t[i][1]=b[i];
	root=Rebuild(1,n,0);
	for(int i=1;i<=n;i++){
		qsum=qmax=0,qr[0]=qr[1]=1e9,ql[0]=a[i],ql[1]=b[i];
		Query(root);
		fl[i]=qmax+1,ed[i]=qsum;
		if(!qsum)ed[i]=1;
		Insert(root,a[i],b[i],fl[i],ed[i],0);
		al=max(al,fl[i]);
	}
	printf("%d\n",al);
	for(int i=1;i<=n;i++)t[i].Clear(),t[i][0]=a[i],t[i][1]=b[i];
	root=Rebuild(1,n,0);
	for(int i=n;i>=1;i--){
		qsum=qmax=0,ql[0]=ql[1]=0,qr[0]=a[i],qr[1]=b[i];
		Query(root);
		fr[i]=qmax+1,st[i]=qsum;
		if(!qsum)st[i]=1;
		Insert(root,a[i],b[i],fr[i],st[i],0);
	}
	double alls=0;
	for(int i=1;i<=n;i++)if(fl[i]==al)alls+=ed[i];
	for(int i=1;i<=n;i++)if(fl[i]+fr[i]==al+1)printf("%.5lf ",st[i]*ed[i]/alls);else printf("0 ");
}
```

---

## 作者：y2823774827y (赞：2)

### 安利博客 $\Longrightarrow\Longrightarrow\Longrightarrow$[更好的阅读体验](https://www.cnblogs.com/y2823774827y/p/10294798.html)

做$SDOI$有种想评黑的感觉，果然还是太弱了

##做法
独立写(调)代码三个小时祭

简化题目：求二维最长不上升子序列及每个点出现在最长不上升子序列概率

我们的限制条件：$t_j<t_i,h_j \geqslant h_i,v_j\geqslant v_i$，求长度随便套个$cdq$随便就做出来了嘛

毒瘤的出题人怎么可能这么简单就让我们切了这道题，那怎么求概率呢？

设$L_i$为以$i$结尾的最长长度(不包括$i$)，那包含$i$的最长长度为$L_i+1+R_i$

设$Lnum_i$为以$i$结尾的最长长度(不包括$i$)的个数，
那包含$i$的最长长度为$L_i+1+R_i$的总个数为：$Lnum_i×Rnum_i$。特殊地，长度为$0$是，个数为$1$

那总个数呢？$\sum\limits_{i=1}^n(Lnum_i×Rnum_i)$然后发现全$WA$了，我们重复统计，因为同一子序列会在所以点里算一遍
正确的做法，枚举每一个右端点，即$R_i==0$&&$L_i+1==ans$，满足这个条件再统计方案就不会重复计算了

抱着能shi做shi出kan来的心态打了一遍[冗长的代码](https://www.luogu.org/paste/gspznpc3)，发现只有7分，想*的心都有了，然后造出一组数据拍掉了

```cpp
6
4 25
4 30
4 35
4 40
4 45
4 50
```

因为长度为$0$时，查询后相加方案数会变成$2$，所以在每次查询后暴力加个判断改回$1$，然后惊奇的发现$85$分了

剩下是由于long long爆了，那我们就把方案数换double，撒花撒花！！

### [code](https://www.cnblogs.com/y2823774827y/p/10294798.html)


---

## 作者：MiRaciss (赞：1)

## 题目
[Link.](https://www.luogu.com.cn/problem/P2487)

## 题解

首先我们考虑暴力的 dp，设 $dp_i$ 表示以 $i$ 结尾的最多的导弹拦截长度，则 $dp_i=\max(dp_j+1), h_i<h_j \wedge v_i<v_j$，显然复杂度是 $O(n^2)$ 的。考虑如何优化，发现可以用 CDQ 分治。

但是CDQ分治有个问题， 在处理 $l \sim r$ 的区间时，我们不能用前面区间的信息，但因为我们要比最大值，所以就不可以直接 CDQ。

那么我们考虑转换 CDQ 递归的顺序，让它中序遍历，先把左区间的答案转移到右区间，再计算右区间内部的答案，这样就可以优化 dp 了。

对于第二问，概率其实就等于选择当前导弹的方案数除以总方案数，那么我们就分别求出以这个导弹结尾和开始的最长的长度，如果这两段长度相加 -1 等于第一问的答案，那么这就是一种可行的方案。

所以正着倒着各跑一边 CDQ 就好了。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define int ll
#define db double

int n,m,N;
int f[4000005];
db f1[1000005],f2[1000005];
int dp1[1000005],dp2[100005];

struct zz{
	int x,y,z,dp;
	db f;
}a[4000005],b[4000005];
bool cmp1(zz x,zz y){ return x.y>y.y; }
bool cmp2(zz x,zz y){ return x.y<y.y; }
bool cmp3(zz x,zz y){ return x.x==y.x?(x.y==y.y?x.z<y.z:x.y>y.y):x.x>y.x; }
bool cmp4(zz x,zz y){ return x.x==y.x?(x.y==y.y?x.z<y.z:x.y<y.y):x.x<y.x; }
bool Check(int p,int q,int op){ return op==1? a[p].y>=a[q].y:a[p].y<=a[q].y; }

struct Bit_Tree{
	ll bit1[4000005];
	db bit2[4000005];
	int Lowbit(int x){ return x&(-x); }
	void Insert(int x,int dp,db f){ while(x<=n){ if(bit1[x]<dp)bit1[x]=dp,bit2[x]=f; else if(bit1[x]==dp)bit2[x]+=f; x+=Lowbit(x);  }	 }
	ll Find1(int x){ ll ans=0;while(x)  ans=max(ans,bit1[x]),x-=Lowbit(x); return ans;		}
	db Find2(int x,int dp){ db ans=0;while(x){ if(bit1[x]==dp) ans+=bit2[x]; x-=Lowbit(x);}; return ans;}
	void Delete(int x){  while(x<=n) bit1[x]=bit2[x]=0,x+=Lowbit(x); }
}T; 		//树状数组，维护dp以及方案数f 

void CDQ(int l,int r,int op){
	if(r<=l) return ; 
	int mid=(l+r)>>1;CDQ(l,mid,op);
	if(op==1) sort(a+l,a+mid+1,cmp1),sort(a+mid+1,a+r+1,cmp1);
	else sort(a+l,a+mid+1,cmp2),sort(a+mid+1,a+r+1,cmp2);			//排序，因此可以将左边转移到右边。 
	
	int p=l,q=mid+1;												//计算左边对右边的贡献 
	while(q<=r){
		while(p<=mid&&Check(p,q,op)) T.Insert(a[p].z,a[p].dp,a[p].f),p++;
		int now=T.Find1(a[q].z)+1;
		if(a[q].dp<now) a[q].dp=now,a[q].f=T.Find2(a[q].z,now-1);   //如果当前的答案更优，就只能更新答案，重新计算方案数。	 
		else if(a[q].dp==now) a[q].f+=T.Find2(a[q].z,now-1);		//如果说答案和dp相同，那么就直接累加方案数就好了。 
		q++;
	}
	for(int i=l;i<p;i++) T.Delete(a[i].z);							//清空 
	
	if(op==1) sort(a+mid+1,a+r+1,cmp3); else sort(a+mid+1,a+r+1,cmp4);//重新排序 
	CDQ(mid+1,r,op);
	
}

signed main(){
	cin>>n;
	for(int i=1;i<=n;i++) scanf("%lld%lld",&a[i].x,&a[i].y),a[i].z=i,a[i].dp=1,a[i].f=1; //赋初值 
	sort(a+1,a+n+1,cmp3),CDQ(1,n,1);
	int ans1=0;db sum=0;
	for(int i=1;i<=n;i++) ans1=max(ans1,a[i].dp); printf("%lld\n",ans1);
	for(int i=1;i<=n;i++) dp1[a[i].z]=a[i].dp,f1[a[i].z]=a[i].f;		
	for(int i=1;i<=n;i++) a[i].z=(n-a[i].z+1),a[i].dp=1,a[i].f=1;		
	sort(a+1,a+n+1,cmp4);CDQ(1,n,2);		//正反各跑一次 
	for(int i=1;i<=n;i++) dp2[n-a[i].z+1]=a[i].dp,f2[n-a[i].z+1]=a[i].f;
	for(int i=1;i<=n;i++) if(dp2[n-a[i].z+1]==ans1) sum+=f2[n-a[i].z+1];
	for(int i=1;i<=n;i++) if(dp1[i]+dp2[i]==ans1+1) printf("%.5lf ",f1[i]*f2[i]/sum); else printf("0.00000 ");
	return 0;
}

```


---

## 作者：Leap_Frog (赞：1)

### P.S.
也就 WA 了十四发，不多不多/px/px/px  
也就写了 3 个小时，不长不常/px/px/px  
写的树状数组，截至目前是最优解第一页。  

### Description.
看似熟悉的题面，也就是把 [这题](https://www.luogu.com.cn/problem/P1020) 的第一问贺过来，加上一个权值。  
然后询问每个点出现在一个最优方案中的概率。  

### Solution.
第一，我们先考虑如何求出第一问。  
首先，加上时间轴这显然是一个三维偏序问题。  
所以我们可以第一时间想到 `CDQ二分`。  
根据 `CDQ二分` 的思想，考虑用左边的答案贡献到右边的答案。  
根据 `三维偏序` 基本套路，直接排序第一维，归并第二维，数据结构第三维就好了。  
我们现在需要支持单点加上一种可能取值，再求前缀 $min$。  
这个东西显然可以用树状数组/线段树等 $\log$ 数据结构维护。  
加上 `CDQ二分` 自带的 $\log$，我们就在两只 $\log$ 的时间复杂度内解决了第一问。  

然后我们考虑第二问。  
显然，我们需要判断一个点是否可能出现在最优方案中。  
那么我们可以考虑做两遍 `CDQ` 求出以这个点为开头/结尾的最长合法子序列。  
然后再在当前位置拼接一下，检查是否是答案就好了。  
不过如果这个都考虑到了，那么答案就呼之欲出了。  
我们记录以当前点为结尾/开头的局部最长合法字序列的个数。  
然后拼接一下，除以总方案数就是答案了。  
而方案数可以用树状数组维护最大值数量来求出。  

还有，注意方案数数组需要开 `double`，不然会炸。  

### Coding.
```cpp
//愿你有一天能和你重要的人重逢。
#include<bits/stdc++.h>
using namespace std;typedef double ll;
template<typename T>inline void read(T &x)
{
	x=0;char c=getchar(),f=0;
	for(;c<'0'||c>'9';c=getchar()) if(c=='-') f=1;
	for(;c>='0'&&c<='9';c=getchar()) x=(x<<1)+(x<<3)+(c^48);
	if(f) x=-x;
}
int n,T[50005],cnt,f[50005],ff[50005];ll g[50005],gg[50005],sm=0;struct node{int a,b,t;}a[50005];
struct segm{int mx;ll wh;}t[50005];//树状数组结构题（名字奇怪
inline bool cmpt(node a,node b) {return a.t<b.t;}
inline bool cmpb(node a,node b) {return a.b>b.b;}
inline segm operator+(segm a,segm b) {return a.mx>b.mx?a:(a.mx<b.mx?b:(segm){a.mx,a.wh+b.wh});}
inline void clear(int x) {for(;x;x-=x&(-x)) t[x]=(segm){0,0};}
inline void upd(int x,segm w) {for(;x;x-=x&(-x)) t[x]=t[x]+w;}
inline segm qry(int x) {segm r=(segm){0,0};for(;x<=cnt;x+=x&(-x)) r=r+t[x];return r;}
inline void cdq(int l,int r)
{//CDQ
	int md=(l+r)>>1;if(l==r) return(void)(f[a[l].t]=max(f[a[l].t],1),g[a[l].t]+=f[a[l].t]==1);
	sort(a+l,a+r+1,cmpt),cdq(l,md),sort(a+l,a+md+1,cmpb),sort(a+md+1,a+r+1,cmpb);
	int j=l;for(int i=md+1;i<=r;i++)
	{
		for(;j<=md&&a[j].b>=a[i].b;j++) upd(a[j].a,(segm){f[a[j].t],g[a[j].t]});
		segm z=qry(a[i].a);if(z.mx==0) continue;
		if(f[a[i].t]<z.mx+1) f[a[i].t]=z.mx+1,g[a[i].t]=z.wh;else if(f[a[i].t]==z.mx+1) g[a[i].t]+=z.wh;
	}
	{for(int i=l;i<=j;i++) clear(a[i].a);}cdq(md+1,r);
}
int main()
{
	read(n);for(int i=1;i<=n;i++) read(a[i].a),read(a[i].b),a[i].t=i,T[i]=a[i].a;
	//mt19937 rnd(time(0));int n=7;for(int i=1;i<=n;i++) a[i].a=rnd()%10,a[i].b=rnd()%10,a[i].t=i,T[i]=a[i].a;
	//for(int i=1;i<=n;i++) printf("%d %d\n",a[i].a,a[i].b);
	sort(T+1,T+n+1),cnt=unique(T+1,T+n+1)-T-1;
	for(int i=1;i<=n;i++) a[i].a=lower_bound(T+1,T+cnt+1,a[i].a)-T;
	memset(T,0,sizeof(T)),cdq(1,n);int rs=0;for(int i=1;i<=n;i++) rs=max(rs,f[i]);
	sm=0;for(int i=1;i<=n;i++) gg[i]=g[i],ff[i]=f[i],sm+=(rs!=f[i]?0:g[i]),g[i]=f[i]=0;
	for(int i=1;i<=n;i++) a[i].t=n+1-a[i].t,a[i].a=cnt+1-a[i].a,a[i].b=-a[i].b;
	cdq(1,n),reverse(g+1,g+n+1),reverse(f+1,f+n+1),printf("%d\n",rs);
	//for(int i=1;i<=n;i++) printf("<%d,%d>%c",f[i],ff[i],i==n?'\n':' ');
	//for(int i=1;i<=n;i++) printf("<%.0lf,%.0lf>%c",g[i],gg[i],i==n?'\n':' ');
	for(int i=1;i<=n;i++) printf("%.10lf%c",f[i]+ff[i]-1==rs?1.0*g[i]*gg[i]/sm:0.0,i==n?'\n':' ');
	return 0;//↑注意特判 0，方案数合并显然相乘
}
```

---

## 作者：_ZSR_ (赞：0)

### [P2487 [SDOI2011]拦截导弹](https://www.luogu.com.cn/problem/P2487)

容易发现，第一问就是求一个二维最长不下降子序列，可以用 CDQ 分治优化。具体来说，我们令 $f_{0,i}$ 表示以 $i$ 结尾的最长不下降子序列的长度。对于第一维时间直接排序，对于第二维高度用 CDQ 分治处理，第三维速度用其权值线段树处理。假设当前处理的区间是 $[L,R]$，按照一般的写法，我们先递归处理左半边和右半边，然后处理跨区间的。但是对于这道题，这样写就是错的。原因是对于一个属于右半边的状态 $x$，它在受到左半边的影响后又会去影响同在右半边的另一个状态 $y$。也就是说 $x$ 在更新 $y$ 的时候是个半成品，这显然是不被允许的。至于其他没有这种问题的题目，顺序怎么样都是可以的。还有一个问题，如果边处理边排序的话我们处理完跨区间的后会发现右半边的可能会跑到左半边，因此，我们用一个临时数组把右半边存下来，然后用临时数组操作，那么再做右半边的时候就是原始的顺序。至于排序，我们等做完右半边后直接 sort。

那么概率怎么统计呢？这里我们就要再记录一些东西。我们令 $f_{i,1}$ 表示以 $i$ 开始的最长不下降子序列的长度，$cnt_{i,0/1}$ 表示以 $i$ 结尾的/开始的最长不下降子序列的方案数。那么对于一个导弹，它可以被选当且仅当 $f_{i,0}+f_{i,1}-1=ans$，其中 $ans$ 表示最长不下降子序列的长度，概率为 $cnt_{i,0} \times cnt_{i,1} / sum$，其中 $sum$ 表示总的方案数。

code
```
#include <bits/stdc++.h>
using namespace std;
const int N=50010;
int n,tot;
struct Missil{
    int times,high,speed;
}m[N],task[N],tmp[N];
struct Dp{
    int maxn;
    double cnt;
    Dp operator+ (const Dp &t) const
    {
        if (maxn>t.maxn) return *this;
        else if (maxn<t.maxn) return t;
        else return (Dp){maxn,cnt+t.cnt};
    }
}f[2][N];
struct Node{
    int l,r;
    Dp val;
}tr[N<<2];
int num[N];
inline bool cmp1(Missil a,Missil b)
{
    return a.times<b.times;
}
inline bool cmp2(Missil a,Missil b)
{
    return a.high>b.high;
}
inline void pushup(int p)
{
    tr[p].val=tr[p<<1].val+tr[p<<1|1].val;
}
void build(int p,int inl,int inr)
{
    tr[p]={inl,inr,(Dp){0,0}};
    if (inl==inr) return;
    int mid=inl+inr>>1;
    build(p<<1,inl,mid);
    build(p<<1|1,mid+1,inr);
}
void modify(int p,int x,Dp k)
{
    if (tr[p].l==x&&tr[p].r==x)
    {
        tr[p].val=tr[p].val+k;
        return;
    }
    int mid=tr[p].l+tr[p].r>>1;
    if (x<=mid) modify(p<<1,x,k);
    else modify(p<<1|1,x,k);
    pushup(p);
}
Dp query(int p,int x,int y)
{
    if (x<=tr[p].l&&tr[p].r<=y) return tr[p].val;
    int mid=tr[p].l+tr[p].r>>1;
    Dp res={0,0};
    if (x<=mid) res=res+query(p<<1,x,y);
    if (y>mid) res=res+query(p<<1|1,x,y);
    return res;
}
void clear(int p,int x)
{
    if (tr[p].l==x&&tr[p].r==x)
    {
        tr[p].val={0,0};
        return;
    }
    int mid=tr[p].l+tr[p].r>>1;
    if (x<=mid) clear(p<<1,x);
    else clear(p<<1|1,x);
    pushup(p);
}
inline void CDQ(int l,int r,int type)
{
    if (l==r)
    {
        if (f[type][task[l].times].maxn==0) f[type][task[l].times]={1,1};
        return;
    }
    int mid=l+r>>1,p=l,q=mid+1;
    CDQ(l,mid,type);
    for (int i=mid+1;i<=r;++i) tmp[i]=task[i];
    sort(tmp+mid+1,tmp+r+1,cmp2);
    for (int i=l;i<=r;++i)
    {
        if ((p<=mid&&task[p].high>=tmp[q].high)||q>r) modify(1,task[p].speed,f[type][task[p].times]),p++;
        else
        {
            auto cur=query(1,tmp[q].speed,tot);
            if (cur.maxn>0) cur.maxn++,f[type][tmp[q].times]=f[type][tmp[q].times]+cur;
            q++;
        }
    }
    for (int i=l;i<=mid;++i) clear(1,task[i].speed);
    CDQ(mid+1,r,type);
    sort(task+l,task+r+1,cmp2);
}
inline void solve(int type)
{
    for (int i=1;i<=n;++i) task[i]=m[i],num[i]=m[i].speed;
    sort(num+1,num+n+1);//因为速度的值域太大，我们要用权值线段树的话就要离散化
    sort(task+1,task+n+1,cmp1);
    tot=unique(num+1,num+n+1)-(num+1);
    for (int i=1;i<=n;++i) task[i].speed=lower_bound(num+1,num+tot+1,task[i].speed)-num;
    build(1,1,tot);//建树
    CDQ(1,n,type);
}
int main()
{
    scanf("%d",&n);
    for (int i=1;i<=n;++i)
    {
        int h,v;
        scanf("%d%d",&h,&v);
        m[i]={i,h,v};
    }
    solve(0);
    for (int i=1;i<=n;++i) m[i]={n-i+1,-m[i].high,-m[i].speed};//翻转后再做就可以不用写两遍了
    solve(1);
    int ans=0;
    for (int i=1;i<=n;++i) ans=max(ans,f[0][i].maxn);
    printf("%d\n",ans);
    double sum=0;
    for (int i=1;i<=n;++i) if (f[0][i].maxn==ans) sum+=f[0][i].cnt;
    for (int i=1;i<=n;++i)
    {
        if (f[0][i].maxn+f[1][n-i+1].maxn==ans+1) printf("%.5lf ",f[0][i].cnt*f[1][n-i+1].cnt/sum);
        else printf("0.00000 ");
    }
    return 0;
}
```


---

## 作者：xuyuansu (赞：0)

## 简化题意
给你一些点，每个点有 $h_i$ 和 $v_i$ 两个属性，求最长的子序列满足其中每个点都有：若 $i<j$ ，则 $h_i \geq h_j$ 且 $v_i \geq v_j$ 。并且输出每个点出现的概率。
## 题解
很明显这是一个三维偏序类问题，可以使用CDQ分治优化DP解决。

我们设想一下归并的分治模型，在左半边处理好了之后，就可以对右半边更新，这个用个临时数组存一下，左右分别按 $h_i$ 排序，用双指针把左边的加入树状数组，右边的去更新就可以。

难搞的地方在于求概率，实际上就是求过这个点的方案数量，所以我们还要求方案数，这个转移是个拓扑图，只要正反图跑一下把每个符合条件的点到起点和终点的方案乘一下就可以了，但是直接用图显然不现实，点太多了，所以需要CDQ来统计方案，最后的计算还是乘起来，我们需要跑两次CDQ。

需要注意的是，方案数太大了,long long会爆掉，必须用double或者long double。

最后吐槽一下，这个SPJ根本没有部分分。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e4+5;
int n,f[N],h[N],sum,id[N],tr1[N];
int f2[N];double g2[N],g[N],tr2[N];
struct node
{
	int h,v,t;
}q[N];
bool cmp2(node i,node j)
{
	return i.t>j.t;
}
bool cmp(int i,int j)
{
	return q[i].h>q[j].h;
}
bool cmp1(int i,int j)
{
	return q[i].h<q[j].h;
}
void add(int x,int y,double z)
{
	for(int i=x;i<=sum;i+=(i&(-i)))
	{
		if(y>tr1[i]) tr1[i]=y,tr2[i]=z;
		else if(y==tr1[i]) tr2[i]+=z;
	}
}
pair<int,double> query(int x)
{
	pair<int,double> res=make_pair(0,0);
	for(int i=x;i;i-=(i&(-i)))
	{
		if(tr1[i]>res.first) res=make_pair(tr1[i],tr2[i]);
		else if(tr1[i]==res.first) res.second+=tr2[i];
	}
	return res;
}
void clear(int x)
{
	for(int i=x;i<=sum;i+=(i&(-i))) tr1[i]=tr2[i]=0;
}
void merge_sort(int l,int r)
{
	if(l==r)
	{
		f[l]=max(1,f[l]);g[l]=max(1.0,g[l]);
		return;
	}
	int mid=(l+r)>>1;merge_sort(l,mid);
	for(int i=l;i<=r;i++) id[i]=i;
	sort(id+l,id+mid+1,cmp);sort(id+mid+1,id+r+1,cmp);
	int now=l;
	for(int i=mid+1;i<=r;i++)
	{
		while(now<=mid && q[id[now]].h>=q[id[i]].h)
		{
			add(sum-q[id[now]].v+1,f[id[now]],g[id[now]]);
			now++;
		}
		auto res=query(sum-q[id[i]].v+1);
		if(res.first+1>f[id[i]]) f[id[i]]=res.first+1,g[id[i]]=res.second;
		else if(res.first+1==f[id[i]]) g[id[i]]+=res.second;
	}
	for(int i=l;i<=mid;i++) clear(sum-q[id[i]].v+1);
	merge_sort(mid+1,r);
}
void solve(int l,int r)
{
	if(l==r)
	{
		f2[l]=max(1,f2[l]);g2[l]=max(1.0,g2[l]);
		return;
	}
	int mid=(l+r)>>1;solve(l,mid);
	for(int i=l;i<=r;i++) id[i]=i;
	sort(id+l,id+mid+1,cmp1);sort(id+mid+1,id+r+1,cmp1);
	int now=l;
	for(int i=mid+1;i<=r;i++)
	{
		while(now<=mid && q[id[now]].h<=q[id[i]].h)
		{
			add(q[id[now]].v,f2[id[now]],g2[id[now]]);
			now++;
		}
		auto res=query(q[id[i]].v);
		if(res.first+1>f2[id[i]]) f2[id[i]]=res.first+1,g2[id[i]]=res.second;
		else if(res.first+1==f2[id[i]]) g2[id[i]]+=res.second;
	}
	for(int i=l;i<=mid;i++) clear(q[id[i]].v);
	solve(mid+1,r);
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&q[i].h,&q[i].v);
		q[i].t=i;h[++sum]=q[i].v;
	}
	sort(h+1,h+sum+1);sum=unique(h+1,h+sum+1)-h-1;
	for(int i=1;i<=n;i++)
		q[i].v=lower_bound(h+1,h+sum+1,q[i].v)-h;
	merge_sort(1,n);
	sort(q+1,q+n+1,cmp2);
	solve(1,n);
	reverse(f2+1,f2+n+1);reverse(g2+1,g2+n+1);
	int ans=0;double cnt=0;
	for(int i=1;i<=n;i++) ans=max(ans,f[i]);
	for(int i=1;i<=n;i++) if(f[i]==ans) cnt+=g[i];
	cout<<ans<<endl;
	for(int i=1;i<=n;i++)
	{
		if(f[i]+f2[i]-1!=ans) printf("0 ");
		else printf("%.5lf ",1.0*(g[i]*g2[i])/cnt);
	}
	return 0;
}

```


---

## 作者：lg_zhou (赞：0)

> 请在阅读此篇前已经对 CDQ分治有基本的了解，不会请戳 [CDQ 分治1](https://www.luogu.com.cn/blog/lgzhou/cdq-fen-zhi-1-post)。

CDQ 分治优化 dp。通常状态是一维，转移是 $O(n)$，如果条件良好，可以将 $O(n^2)$ 的复杂度优化到 $O(nlogn)$。

举个例子：二维最长上升子序列。

设每个元素位置是 $pos_i$, 两个属性分别是 $x_i,y_i$。很显然，对于每个元素 $i$，只能从 $pos_j<pos_i, x_j<x_i, y_j<y_i$ 的元素 $j$ 转移而来，很容易想到三维偏序的解决办法，每次一个区间 $[l,r]$，用 $[l,mid]$ 的 $dp$ 值更新 $[mid+1,r]$ 的 $dp$ 值。

可是有个问题，我们必须保证 $[l,mid]$ 的 $dp$ 值已经更新完毕，才能再拿它更新 $[mid+1,r]$ 的 $dp$ 值。

所以递归的时候，先递归 $[l,mid]$ ，再拿 $[l,mid]$ 的 $dp$ 值更新 $[mid+1,r]$ 的 $dp$ 值，最后递归 $[mid+1,r]$。在递归 $[l,mid]$ 的时候，其中的 $dp$ 值肯定已经更新完毕。而常规的三维偏序是不用考虑递归顺序的。

在递归时，就是套路的两边都按 $x$ 关键字排序，拿双指针扫一遍，用树状数组维护，每次取出合法的最大 $dp$ 值 $+1$ 来更新。

***

例题： [P2487 [SDOI2011]拦截导弹](https://www.luogu.com.cn/problem/P2487)

这道题第一问和上面讲的一模一样。看数据范围我们需要离散化，其实均可。我们可以将 $pos$ 这一维进行维护值域，其他两维度进行排序，但就舍弃了位置这一维已经排好了的信息。

问题就是怎么算出每个导弹被拦截的概率。

很显然，如果这个导弹不在最长不上升子序列里，概率就为零。

怎么判断？设导弹序列为 $a$，数组 $f_1$ 记录以 $a[i]$ 为结尾的最长不上升子序列的最长长度, 其中最长的长度就是最长不上升子序列的长度，记为 $len$。数组 $f_2$ 记录以 $a[i]$ 为开头的最长不上升子序列的最长长度。如果 $f_1+f_2-1 == len$ ，那么 $a[i]$ 就在，否则就不在。 $f_2$ 数组可以将 $a$ 倒置，跑一边最长不下降子序列就行。

如果已经在最长不上升子序列里了。概率 $p_i$ 就等于含 $a[i]$ 的最长不上升子序列方案数 除以 总最长不上升子序列方案数。

拿数组 $g_1$ 记录以 $a[i]$ 为结尾的最长不上升子序列的方案数，数组 $g_2$ 记录以 $a[i]$ 为开头的最长不上升子序列的方案数。含 $a[i]$ 的方案数就等于 $g_1[i]*g_2[i]$。而总方案数就等于 $\sum\limits_{i=1}^ng_1[i]*[f[i]==len]$。

关键是 $g$ 数组怎么求。原先树状数组中存的是 $f$ 值的最大值。现在多存一个，最大值的方案数有多少。如果每次 $f$ 数组被更新，那么 $g$ 数组就直接等于最大值的方案数。如果 $f$ 数组恰好等于此次树状数组中的最大值，那么将 $g$ 进行累加。

只放第一段算 $f_1,g_1$ `CDQ` 分治的代码和树状数组的代码，算 $f_2,g_2$ 的大同小异，其余的代码也没什么意义放，反而让人看不下去：

```cpp
void CDQ(int l, int r){
	if (l >= r) return;

	int mid = (l+r)/2;
	CDQ(l,mid); //顺序很重要，先把左边递归了，再更新，再递归右边
	for (int i = l; i <= r; i++) t[i] = a[i]; //临时数组
	sort(t+l,t+mid+1,cmpv);//按 v 从大到小排序（本题我将 h 这一维进行了离散化）
	sort(t+mid+1,t+r+1,cmpv);
	int ll = l, rr = mid+1; //两个指针
	while(rr <= r){
		while(ll <= mid && t[ll].v >= t[rr].v){
			add(maxn-t[ll].h, f[t[ll].id], g[t[ll].id]);
         	//因为要维护的是后缀最大值，直接拿范围减一下。
			//将当前位置的 f 值和 g 值放在树状数组里维护 
			ll++;
		}
		
		int mx = get(maxn-t[rr].h).mx+1; //取出最大的 f 
		int ct = get(maxn-t[rr].h).ct; //对应的方案数的和 g 
		if (mx > f[t[rr].id]) { // 如果更新了，g 直接变 
			f[t[rr].id] = mx;
			g[t[rr].id] = ct;
		}
		else if (mx == f[t[rr].id]) g[t[rr].id] += ct; // 如果相等，g累加 
		rr++;
	}
	for (int i = l; i < ll; i++) init(maxn-t[i].h); // 复原树状数组 
	CDQ(mid+1,r); // 递归右边 
}
```
树状数组代码，没什么好注释的了：

```cpp
//树状数组 
struct mit{
	int mx,ct;
};
int C[maxn+5], cnt[maxn+5];
int lowbit(int x){
	return x&-x;
}

void add(int pos, int v, int vv){
	for (int i = pos; i <= maxn; i+=lowbit(i)){
		if (C[i] < v){
			C[i] = v;
			cnt[i] = vv;
		}
		else if (C[i] == v) cnt[i] += vv;
	}
}
mit get(int pos){
	int mx = 0, ct = 0;
	for (int i = pos; i; i-=lowbit(i)){
		if (C[i] > mx){
			mx = C[i];
			ct = cnt[i];
		}
		else if (C[i] == mx)ct += cnt[i]; 
	}
	return mit{mx,ct};
}

void init(int pos){
	for (int i = pos; i <= maxn; i+=lowbit(i)) C[i] = cnt[i] = 0;
}
```

[$to$ 我的博客](https://www.luogu.com.cn/blog/lgzhou/)


---

## 作者：mqxmm (赞：0)

## 简单题意

给定 $n$ 个数对 $(h_i, v_i)$。  

求：  
1. 最长不上升子序列的长度。  
2. 对于每个 $i$，分别求出包含数对 $(h_i, v_i)$ 的最长上升子序列的个数和最长不上升子序列的个数和的比。  

**数据范围**：$1 \leq n \leq 5 \times {10} ^ 4$，$\forall 1 \leq i \leq n, 1 \leq h_i, v_i \leq {10}^9$。  

## 分析

### 问题 $1$

先考虑 $O(n^2)$ 做法，本质与一维的相同。  

定义 $f_i$ 表示以数对 $(h_i, v_i)$ 结尾的最长不上升子序列的长度。  

那么有

$$
\begin{aligned}
f_i & = \max(1, \max\{ f_j + 1 \}), h_i \leq h_j \wedge v_i \leq v_j \\
\end{aligned}
$$

推出了式子后考虑优化，可以使用 $\texttt{cdq}$ 分治。  

对于一个区间 $\texttt{[l, r]}$ 的转移。  

$\texttt{int mid = (l + r) >> 1}$  

先递归 $\texttt{cdq(l, mid)}$。

假设 $\texttt{[l, mid]}$ 已经求出正确答案，即 $f_{\texttt{l} \sim \texttt{r}}$ 都是正确的。  

考虑如何转移，即 $\texttt{[l, mid]}$ 对 $\texttt{[mid + 1, r]}$ 的贡献。  

与三维偏序一样，合并 $h$，以 $v$ 为下标把 $f$ 存放在树状数组中。  

只不过这里的 $f$ 需要取最大值。  

最后递归 $\texttt{cdq(mid + 1, r)}$。  

因为是最后递归 $\texttt{cdq(mid + 1, r)}$，所以询问不能真正合并，在结束时需要还原成原来的顺序。  

### 问题 $2$

问题 $1$ 解决后问题 $2$ 就简单了。  

只需要在树状数组中再维护一个统计个数数组即可。  

- 修改的值大于当前最大值就修改。  
- 修改的值等于当前最大值就累加。  

因为求的是 **包含** 数对 $(h_i, v_i)$ 的最长不上升子序列的个数，所以还需要反着求一遍最长不上升子序列的个数。  

两个数相乘再除以总数就是答案，前提是这个数对被包含在至少一个最长不上升子序列中。  

温馨提示，个数可能会超过 $\texttt{long long}$ 的范围，建议使用 $\texttt{double}$。  

## $\texttt{code}$

```cpp
#include <cstdio>
#include <vector>
#include <utility>
#include <iostream>
#include <algorithm>

int rint() {
	int x = 0, fx = 1;
	char c = getchar();
	
	while (c < '0' || c > '9') {
		fx ^= (c == '-');
		c = getchar();
	}
	
	while ('0' <= c && c <= '9') {
		x = (x << 3) + (x << 1) + (c ^ 48);
		c = getchar();
	}
	
	if (!fx) {
		return -x;
	}
	
	return x;
}

void read(int &x) {
	x = rint();
}

template<typename... Ts>
void read(int &x, Ts &...rest) {
	read(x);
	read(rest...);
}

int Max(int u, int v) {
	return (u > v) ? u : v;
}

int Min(int u, int v) {
	return (u < v) ? u : v;
}

const int MAX_n = 5e4;

int n, Time; // Time 是时间戳优化树状数组，可以不用清空 
int dp1[MAX_n + 5]; // 正 
int dp2[MAX_n + 5]; // 反 
int vis[MAX_n + 5]; // 树状数组时间戳 
int Bit[MAX_n + 5];
double bit[MAX_n + 5];
double num1[MAX_n + 5]; // 正 
double num2[MAX_n + 5]; // 反 

std::vector<int> lsh; // 离散化 v 

struct Missile {
	int idx, h, v;
} q[MAX_n + 5];
Missile tmp[MAX_n + 5];

bool cmph1(Missile x, Missile y) {
	return x.h > y.h;
}

bool cmph2(Missile x, Missile y) {
	return x.h < y.h;
}

int lowbit(int x) {
	return x & (-x);
}

void add(int k, int x, double y) {
	while (k <= n) {
		if (vis[k] != Time) {
			vis[k] = Time;
			Bit[k] = x;
			bit[k] = y;
		} else {
			if (x > Bit[k]) {
				Bit[k] = x;
				bit[k] = y;
			} else if (x == Bit[k]) {
				bit[k] += y;
			}
		}
		
		k += lowbit(k);
	}
}

std::pair<int, double> ask(int k) {
	int resmax = 0;
	double ressum = 0.0;
	
	while (k > 0) {
		if (vis[k] == Time) {
			if (Bit[k] > resmax) {
				resmax = Bit[k];
				ressum = bit[k];
			} else if (Bit[k] == resmax) {
				ressum += bit[k];
			}
		}
		
		k -= lowbit(k);
	}
	
	return std::make_pair(resmax, ressum);
}

void merge1(int L1, int R1, int L2, int R2) {
	++Time;
	int i = L1, j = L2;
	
	for (int k = L1; k <= R2; k++) {
		tmp[k] = q[k];
	}
	
	std::sort(q + L1, q + R1 + 1, cmph1);
	std::sort(q + L2, q + R2 + 1, cmph1);
	
	while (i <= R1 || j <= R2) {
		if (i <= R1 && (j > R2 || q[i].h >= q[j].h)) {
			add((int)lsh.size() + 1 - q[i].v, dp1[q[i].idx], num1[q[i].idx]);
			i++;
		} else {
			std::pair<int, double> now = ask((int)lsh.size() + 1 - q[j].v);
			
			if (now.first + 1 > dp1[q[j].idx]) {
				dp1[q[j].idx] = now.first + 1;
				num1[q[j].idx] = now.second;
			} else if (now.first + 1 == dp1[q[j].idx]) {
				num1[q[j].idx] += now.second;
			}
			
			j++;
		}
	}
	
	for (int k = L1; k <= R2; k++) {
		q[k] = tmp[k];
	}
}

void cdq1(int L, int R) {
	if (L == R) {
		return ;
	}
	
	int Mid = (L + R) >> 1;
	cdq1(L, Mid);
	merge1(L, Mid, Mid + 1, R);
	cdq1(Mid + 1, R);
}

void merge2(int L1, int R1, int L2, int R2) {
	++Time;
	int i = L1, j = L2;
	
	for (int k = L1; k <= R2; k++) {
		tmp[k] = q[k];
	}
	
	std::sort(q + L1, q + R1 + 1, cmph2);
	std::sort(q + L2, q + R2 + 1, cmph2);
	
	while (i <= R1 || j <= R2) {
		if (i <= R1 && (j > R2 || q[i].h <= q[j].h)) {
			add(q[i].v, dp2[q[i].idx], num2[q[i].idx]);
			i++;
		} else {
			std::pair<int, double> now = ask(q[j].v);
			
			if (now.first + 1 > dp2[q[j].idx]) {
				dp2[q[j].idx] = now.first + 1;
				num2[q[j].idx] = now.second;
			} else if (now.first + 1 == dp2[q[j].idx]) {
				num2[q[j].idx] += now.second;
			}
			
			j++;
		}
	}
	
	for (int k = L1; k <= R2; k++) {
		q[k] = tmp[k];
	}
}

void cdq2(int L, int R) {
	if (L == R) {
		return ;
	}
	
	int Mid = (L + R) >> 1;
	cdq2(L, Mid);
	merge2(L, Mid, Mid + 1, R);
	cdq2(Mid + 1, R);
}

signed main() {
	n = rint();
	
	for (int i = 1; i <= n; i++) {
		read(q[i].h, q[i].v);
		q[i].idx = i;
		lsh.push_back(q[i].v);
	}
	
	std::sort(lsh.begin(), lsh.end());
	lsh.resize(std::unique(lsh.begin(), lsh.end()) - lsh.begin());
	
	for (int i = 1; i <= n; i++) {
		q[i].v = std::lower_bound(lsh.begin(), lsh.end(), q[i].v) - lsh.begin() + 1;
		dp1[i] = dp2[i] = 1;
		num1[i] = num2[i] = 1.0;
	}
	
	cdq1(1, n);
	
	for (int i = n / 2; i >= 1; i--) {
		std::swap(q[i], q[n + 1 - i]);
	}
	
	cdq2(1, n);
	int res = 0;
	double sum = 0;
	
	for (int i = 1; i <= n; i++) {
		if (dp1[i] > res) {
			res = dp1[i];
			sum = num1[i];
		} else if (dp1[i] == res) {
			sum += num1[i];
		}
	}
	
	printf("%d\n", res);
	
	for (int i = 1; i <= n; i++) {
		if (dp1[i] + dp2[i] - 1 != res) {
			printf("0.00000");
		} else {
			printf("%.5f", 1.0 * num1[i] * num2[i] / sum);
		}
		
		putchar((i == n) ? '\n' : ' ');
	}
	
	return 0;
}

```


---

## 作者：cirnovsky (赞：0)

朴素的做法就是二元组 $(a_i,b_i)$ 序列的 LIS dp，同时维护 LIS 的数量。$i$ 可在 $j$ 决策的条件是 $i>j,a_j<a_i,b_j<b_i$（将时间视为下标）。

于是联想到使用 cdq dac 优化，使用树状数组 / 线段树支持单点合并 dp 值，最大值。

然后，，第二问要维护反转过来的 dp 值，再跑一遍就行了。

说几个坑点，在 dac 时 $l=r$ 给 dp 赋初值时，dp 在 $l$ 上的点值不一定是第一次被访问，所以不能简单的赋为 $(1,1)$，要取 max（对着 xtw 的代码灵魂对照才找出来 憨笑）。

因为 $[l,mid]$ 的 dp 决策是对 $(mid,r]$ 的决策有影响的，所以不能先把左右两边跑完再计算跨区间贡献，而是应该先把 $[l,mid]$ 跑完，然后再跑右区间。这又带来一个细节，对左右区间的以 $a_i$ 为关键字的排序会使得原区间的 $t_i$（下标）无序，需要在递归之前排回来。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define cmin(x, y) x = min(x, y)
#define cmax(x, y) x = max(x, y)
#define fors(i, l, r, ...) for(int i = (l), REP##i = (r), ##__VA_ARGS__; i <= REP##i; ++i)
#define dfors(i, r, l, ...) for(int i = (r), REP##i = (l), ##__VA_ARGS__; i >= REP##i; --i)
int f1[50100], f2[50100];
double g1[50100], g2[50100];
int n, _n;
struct request {
    int t, x, y;
} req[50100], tmp[50100];
struct S {
    int x = 0;
    double p = 0;
} bit[50100];
void merge(S& x, const S& y) {
    if(x.x > y.x) x = x;
    else if(x.x < y.x) x = y;
    else x = (S){x.x, x.p+y.p};
}
void add(int x, const S& v) {
    for(; x; x -= x&-x) merge(bit[x], v);
}
void reset(int x) {
    for(; x; x -= x&-x) bit[x] = (S){0, 0};
}
S ask(int x) {
    S res;
    for(; x <= _n; x += x&-x) merge(res, bit[x]);
    return res;
}
void solve(const int l, const int r, int f[], double g[]) {
    if(l == r) {
        cmax(f[req[l].t], 1), g[req[l].t] += f[req[l].t] == 1;
        return;
    }
    int mid = (l+r)>>1;
    sort(req+l, req+r+1,
        [](const request& lhs, const request& rhs) { return lhs.t < rhs.t; });
    solve(l, mid, f, g);
    sort(req+l, req+mid+1,
        [](const request& lhs, const request& rhs) { return lhs.y > rhs.y; });
    sort(req+mid+1, req+r+1,
        [](const request& lhs, const request& rhs) { return lhs.y > rhs.y; });
    int j = l;
    fors(i, mid+1, r) {
        for(; j <= mid && req[j].y >= req[i].y; ++j) add(req[j].x, (S){f[req[j].t], g[req[j].t]});
        S ret = ask(req[i].x);
        if(ret.x == 0) continue;
        if(f[req[i].t] < ret.x+1) f[req[i].t] = ret.x+1,g[req[i].t] = ret.p;
        else if(f[req[i].t] == ret.x+1) g[req[i].t] += ret.p;
    }
    fors(i, l, j) reset(req[i].x);
    solve(mid+1, r, f, g);
}
signed main() {
    ios::sync_with_stdio(0), cin.tie(0);
    cin >> n;
    vector<int> v;
    fors(i, 1, n) {
        cin >> req[i].x >> req[i].y;
        req[i].t = i;
        v.emplace_back(req[i].x);
    }
    sort(v.begin(), v.end());
    v.erase(unique(v.begin(), v.end()), v.end());
    _n = static_cast<int>(v.size());
    fors(i, 1, n) req[i].x = lower_bound(v.begin(), v.end(), req[i].x)-v.begin()+1;
    solve(1, n, f1, g1);
    int max_f1 = *max_element(f1+1, f1+n+1);
    double sum_g1 = 0;
    fors(i, 1, n) sum_g1 += (max_f1 == f1[i])*g1[i];
    fors(i, 1, n) req[i].t = n-req[i].t+1,req[i].x = _n-req[i].x+1,req[i].y *= -1;
    solve(1, n, f2, g2);
    reverse(f2+1, f2+n+1);
    reverse(g2+1, g2+n+1);
    cout << max_f1 << "\n";
    fors(i, 1, n) cout << (f1[i]+f2[i]-1 == max_f1 ? g1[i]*g2[i]/sum_g1 : 0.0) << " \n"[i == n];
    return 0;
}
```

---

## 作者：Stinger (赞：0)

写起来和调起来都很恶心的 CDQ+dp。

$f1_i$ 表示以第 $i$ 个导弹结尾的最长 LIS 长度，$f2_i$ 表示以第 $i$ 个导弹开头的最长 LIS 长度，$g1_i$ 表示以第 $i$ 个导弹结尾的最长 LIS 方案数，$g2_i$ 同理。

以下我们只考虑 $f1,g1$，并用 $f$ 代替 $f1$，$g$ 代替 $g1$。

$$f_i=\max f_j+1(1\le j<i,h_i\le h_j,v_i\le v_j)$$

$$g_i=\max g_j+1(1\le j<i,h_i\le h_j,v_i\le v_j,f_i=f_j+1)$$

这个 $f$ 的限制是个三维偏序，直接 cdq 套树状数组优化 dp 就行了。~~名字莫名吓人~~

那 $g$ 呢？四位偏序？算完了 $f$ 再来算 $g$ 显然是行不通的，所以要在计算 $f$ 的时候顺带计算 $g$。

然后计算 $f2,g2$ 同理，把序列反过来，$h,v$ 取个反（例如都设为 $114514-h_i$)就行了。

然后算出了这个后第一问就解决了，第二问对于导弹 $i$，假设总方案数为 $tot$，它被拦截的概率显然是若 $f1_i+f2_i-1$ 不等于第一问的答案就是 $0$ 的概率，否则就是 $\frac{g1_i\cdot g2_i}{tot}$。

完了？完了。

但这样说过于笼统，~~说了等于没说~~，所以我们还是理一下具体的东西和实现细节：

对于 $f_i$ 的计算，第一维 $j<i$ 的限制天然满足，第二维 $h_i\le h_j$ 我们 cdq 分治削掉，第三维 $v_i\le v_j$ 树状数组维护。

由于树状数组查最大值只能查 $[1,x]$ 不能查 $[x,n]$，所以我们 cdq 时要把 $h$ 和 $v$ 取个反变成 $h_j\le h_i,v_j\le v_i$。

对于 $g_i$ 的计算，在树状数组维护最大值时，顺带维护以下有多少种方案可以得到这种最大值。$g$ 的转移也是一个 dp，所以和 $f$ 一起算其实很自然。

还有就是方案数要开 `double`，`long long` 会炸，总方案数 `tot` 也要开 `double`。

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>

inline int max(const int x, const int y) {return x > y ? x : y;}
inline int min(const int x, const int y) {return x < y ? x : y;}
int f1[50005], f2[50005], h[50005], v[50005], n;
double g1[50005], g2[50005];
struct Node {
	int x, y, z;
	inline bool operator < (const Node a) const {return x < a.x;}
} a[50005];
struct Initer {
	int v, id;
	inline bool operator < (const Initer a) {return v < a.v;}//离散化用的，不用管
} b[50005];
struct cmp {//functor排序比函数快得多
	inline bool operator () (const Node a, const Node b) const {return a.y < b.y;}
};
struct cmp2 {
	inline bool operator() (const Node a, const Node b) {return a.x > b.x;}
};
struct BIT {//树状数组我用了时间戳清空，不会的左转https://www.cnblogs.com/imakf/p/14071208.html
	int nowtime, c[50005], t[50005];
	double cnt[50005];//方案数开double
	void update(int x, int d, double d2) {//注意update有三个参，多出来的一个是方案数
		for (int i = x; i <= n; i += (i & ~i + 1))
			if (nowtime ^ t[i]) t[i] = nowtime, c[i] = d, cnt[i] = d2;
			else {
				if (c[i] < d) c[i] = d, cnt[i] = d2;
				else if (c[i] == d) cnt[i] += d2;
			}
	}
	inline std::pair<int, double> query(int x) {
		int sum = 0;
		double sum2 = 0;
		for (int i = x; i; i -= (i & ~i + 1))
			if (nowtime == t[i]) {
				if (sum < c[i]) sum = c[i], sum2 = cnt[i];//树状数组顺带维护
				else if (sum == c[i]) sum2 += cnt[i];
			}
		return std::make_pair(sum, sum2);//树状数组返回的是pair,first为LIS长度，second为方案数
	}
	inline void clear() {++ nowtime;}
} bitf;

void CDQ1(int l, int r) {
	if (l == r) return;
	int mid = l + r >> 1, i = l, j = mid + 1;
	CDQ1(l, mid);
	std::sort(a + l, a + mid + 1, cmp()), std::sort(a + mid + 1, a + r + 1, cmp());
	while (i <= mid && j <= r) {
		if (a[i].y <= a[j].y) bitf.update(a[i].z, f1[a[i].x], g1[a[i].x]), ++ i;
		else {
			std::pair<int, double> ans = bitf.query(a[j].z);
			if (ans.first + 1 > f1[a[j].x])
				f1[a[j].x] = ans.first + 1, g1[a[j].x] = ans.second;
			else if (ans.first + 1 == f1[a[j].x]) g1[a[j].x] += ans.second;
			++ j;
		}
	}
	while (j <= r)  {
		std::pair<int, double> ans = bitf.query(a[j].z);
		if (ans.first + 1 > f1[a[j].x])
			f1[a[j].x] = ans.first + 1, g1[a[j].x] = ans.second;
		else if (ans.first + 1 == f1[a[j].x]) g1[a[j].x] += ans.second;
		++ j;
	}
	std::sort(a + mid + 1, a + r + 1);//cdq完了过后原始下标是乱序的，所以要sort回去
	bitf.clear(), CDQ1(mid + 1, r);
}
void CDQ2(int l, int r) {//复制cdq1，把f1改为f2，把g1改为g2，连个大于小于的符号都不用改，调用前直接反转序列
	if (l == r) return;
	int mid = l + r >> 1, i = l, j = mid + 1;
	CDQ2(l, mid);
	std::sort(a + l, a + mid + 1, cmp()), std::sort(a + mid + 1, a + r + 1, cmp());
	while (i <= mid && j <= r) {
		if (a[i].y <= a[j].y) bitf.update(a[i].z, f2[a[i].x], g2[a[i].x]), ++ i;
		else {
			std::pair<int, double> ans = bitf.query(a[j].z);
			if (ans.first + 1 > f2[a[j].x])
				f2[a[j].x] = ans.first + 1, g2[a[j].x] = ans.second;
			else if (ans.first + 1 == f2[a[j].x]) g2[a[j].x] += ans.second;
			++ j;
		}
	}
	while (j <= r)  {
		std::pair<int, double> ans = bitf.query(a[j].z);
		if (ans.first + 1 > f2[a[j].x])
			f2[a[j].x] = ans.first + 1, g2[a[j].x] = ans.second;
		else if (ans.first + 1 == f2[a[j].x]) g2[a[j].x] += ans.second;
		++ j;
	}
	std::sort(a + mid + 1, a + r + 1, cmp2());
	bitf.clear(), CDQ2(mid + 1, r);
}

void init(int *a, int &mx) {
	for (int i = 1; i <= n; ++ i) b[i].id = i, b[i].v = a[i];
	std::sort(b + 1, b + n + 1);
	for (int i = 1; i <= n; ++ i)
		a[b[i].id] = a[b[i - 1].id] + 1 - (b[i].v == b[i - 1].v);
	mx = a[b[n].id] + 1;
	for (int i = 1; i <= n; ++ i) a[i] = mx - a[i];//众所周知树状数组只能求前缀max，取个反转化一下把后缀改为前缀
}

int main() {
	int mxh, mxv;
	scanf("%d", &n);
	for (int i = 1; i <= n; ++ i)
		scanf("%d%d", h + i, v + i), f1[i] = g1[i] = f2[i] = g2[i] = 1;
	init(h, mxh), init(v, mxv);
	for (int i = 1; i <= n; ++ i) a[i].x = i, a[i].y = h[i], a[i].z = v[i];
	CDQ1(1, n);
	int ans = 0;
	double sum = 0;
	for (int i = 1; i <= n; ++ i) ans = max(ans, f1[i]);
	for (int i = 1; i <= n; ++ i)
		if (f1[i] == ans) sum += g1[i];//sum即为tot
	printf("%d\n", ans);
	std::sort(a + 1, a + n + 1);
	std::reverse(a + 1, a + n + 1);
	for (int i = 1; i <= n; ++ i) a[i].y = mxh - a[i].y, a[i].z = mxv - a[i].z;//取反回来再cdq2
	CDQ2(1, n);
	for (int i = 1; i <= n; ++ i)
		if (f1[i] + f2[i] - 1 == ans) printf("%.5lf ", g1[i] * g2[i] / sum);
		else printf("0.00000 ");
	return 0;
}
```

---

## 作者：Mo_Han136 (赞：0)

~~又来水题解了~~

[题目链接](https://www.luogu.com.cn/problem/P2487 "题目链接")

## 题目描述

按照时间顺序给 $n$ 个的高度 $h_i$ 、速度 $v_i$ 信息，要求后拦截的导弹不得高于快于先前拦截的导弹，求最大拦截数量，以及在拦截数最大时，每个导弹被拦截的概率。

## 题解

注意到拦截的导弹需满足 $t_i \le t_{i+1} , h_i \le h_{i+1} , v_i \le v_{i+1} $ ，可以用 CDQ 分治解决“拦截数最大”问题，且实现起来没什么困难。

关键在于如何处理“概率”问题。

注意到所谓“概率”其实解释“包含该点的方案数”与“总方案数”的比值。因此对于每个点只需算出“包含该点的方案数”，最后与“总方案数”一除即可。

同时因为条件“ $t_i \le t_{i+1} , h_i \le h_{i+1} , v_i \le v_{i+1} $ ”，则最终导弹的拦截顺序是一个拓扑序。

这就好办！只需将在最优情况下“进入该点的方案数”与“离开该点的方案数”相乘就是“包含该点的方案数”。

正反两次 CDQ 分治即可解决上述问题。

## 实现

各点整体上按照时间 $t_i$ 排序，在递归时在按照 $h_i$ 排序，再用 BIT 处理 $v_i$ 的大小，实现上没什么大的问题。

唯一比较重要的细节就是关于方案数的统计， long long 不够用，需要用 double

代码有点小长，但头就有 30 行，加上大部分内容都是相似的，所以实际打起来还好。

```cpp
#include<bits/stdc++.h>
#define db double
#define reg register
#define LL long long
#define pb push_back
#define lb lower_bound
#define ub upper_bound
#define ull unsigned long long
#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)
#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)
#define erep(i,a) for(int i=head[a];i;i=e[i].nxt)


using namespace std;
bool Handsome;
inline void Mi(int &x,int y){if(x>y && (x=y));}
inline void Mx(int &x,int y){if(x<y && (x=y));}
const int M=5e4+5;
int n,c[M],ct;
struct node{int h,v,id;}a[M],b[M];
struct NODE{int mx;db val;}f1[M],f2[M],ans;
NODE operator + (const NODE &x,const NODE &y){
	NODE z;
	if(x.mx<y.mx)z=y;
	if(x.mx>y.mx)z=x;
	if(x.mx==y.mx)z=(NODE){x.mx,x.val+y.val};
	return z;
}
bool cmp1(node a,node b){
	return a.h>b.h;
}
struct BIT1{
	NODE t[M];
	void add(int x,NODE y){
		for(;x;x-=x&-x)t[x]=t[x]+y;
	}
	void clr(int x){
		for(;x;x-=x&-x)t[x]=(NODE){0,0};
	}
	NODE ask(int x){
		NODE res=(NODE){0,0};
		for(;x<=ct;x+=x&-x)res=res+t[x];
		return res;
	}
}bit1;
void CDQ1(int l,int r){
	if(l==r)return;
	int mid=(l+r)>>1,p=l;
	CDQ1(l,mid);
	rep(i,l,r)b[i]=a[i];
	sort(b+l,b+mid+1,cmp1);
	sort(b+mid+1,b+r+1,cmp1);
	rep(i,mid+1,r){
		while(p<=mid && b[p].h>=b[i].h){
			bit1.add(b[p].v,f1[b[p].id]);
			++p;
		}
		NODE res=bit1.ask(b[i].v);++res.mx;
		f1[b[i].id]=f1[b[i].id]+res;
	}
	while(l<p)bit1.clr(b[--p].v);
	CDQ1(mid+1,r);
}
bool cmp2(node a,node b){
	return a.h<b.h;
}
struct BIT2{
	NODE t[M];
	void add(int x,NODE y){
		for(;x<=ct;x+=x&-x)t[x]=t[x]+y;
	}
	void clr(int x){
		for(;x<=ct;x+=x&-x)t[x]=(NODE){0,0};
	}
	NODE ask(int x){
		NODE res=(NODE){0,0};
		for(;x;x-=x&-x)res=res+t[x];
		return res;
	}
}bit2;
void CDQ2(int l,int r){
	if(l==r)return;
	int mid=(l+r)>>1,p=mid+1;
	CDQ2(mid+1,r);
	rep(i,l,r)b[i]=a[i];
	sort(b+l,b+mid+1,cmp2);
	sort(b+mid+1,b+r+1,cmp2);
	rep(i,l,mid){
		while(p<=r && b[p].h<=b[i].h){
			bit2.add(b[p].v,f2[b[p].id]);
			++p;
		}
		NODE res=bit2.ask(b[i].v);++res.mx;
		f2[b[i].id]=f2[b[i].id]+res;
	}
	while(mid+1<p)bit2.clr(b[--p].v);
	CDQ2(l,mid);
}
bool Most;
int main(){
//	printf("%.2lfMB\n",(&Most-&Handsome)/1024.0/1024.0);
	scanf("%d",&n);
	rep(i,1,n)scanf("%d%d",&a[i].h,&a[i].v),a[i].id=i;
	rep(i,1,n)c[i]=a[i].v;
	sort(c+1,c+n+1);ct=unique(c+1,c+n+1)-c-1;
	rep(i,1,n)a[i].v=lb(c+1,c+ct+1,a[i].v)-c;
	rep(i,1,n)f1[i]=f2[i]=(NODE){1,1};
	CDQ1(1,n);CDQ2(1,n);
	rep(i,1,n)ans=ans+f1[i];
	printf("%d\n",ans.mx);
	rep(i,1,n){
		if(f1[i].mx+f2[i].mx-1<ans.mx)puts("0");
		else printf("%lf ",f1[i].val/ans.val*f2[i].val);
	}
	return 0;
}
```

$\mathcal{By}\quad\mathcal{Most}\ \mathcal{Handsome}$

$\mathcal{2021.07.16}$

---

## 作者：Tony102 (赞：0)

[Link](https://www.luogu.com.cn/problem/P2487)

[Blog阅读体验更佳](https://tony102.xyz/index.php/2021/03/23/luogu2487-sdoi2011%e6%8b%a6%e6%88%aa%e5%af%bc%e5%bc%b9/)

这道题不要去darkbzoj上交，估计是当时没加SPJ导致你无论如何都过不去



### Sol

导弹拦截大家都会

现在已经给你了导弹来的顺序，我们把这个顺序记做 $t_i$

我们先来解决第一问，也就是最多能拦截的导弹数量。我们设 $f_i$ 表示以 $i$ 为最后一枚拦截的导弹前面最多能拦多少枚，记 $g_i$ 为达到 $f_i$ 的方案数。那么 $O(n^2)$ 的转移非常好写。在 $f_i$ 转移的时候看一下答案更新的情况，如果 $f_i$ 不变就乘法原理乘一下 $g_i$ ， 否则变成 $0$ 

注意到 $f_i$ 只能是从 $i$ 的左边转移过来，看看能不能用 cdq 分治解决这个问题。现在 $t_i$ 已经被确定，也就是说，已经有一维被确定，把 $h_i$ 当做第二维，每次 cdq 的时候查一查左边的$h$比右边的 $h$ 大的时候，就会产生贡献。更加具体的，我们把 $f_i$ 和 $g_i$ 插到线段树中，当要更新答案的时候就可以从线段树中取出最大的 $f_i$ 和 $g_i$ 更新当前的结果。

就这么写还是有锅，因为一种方案的方案数应该是以它开头和以它结尾的方案数的成绩。所以我们把三维全部逆过来，然后再做一遍 cdq 就可以了。

此外，注意方案数相加相乘会爆`long long`，用`double`存就可以了



### Code
**[Code戳这里](https://tony102.xyz/index.php/2021/03/23/luogu2487-sdoi2011%e6%8b%a6%e6%88%aa%e5%af%bc%e5%bc%b9/)**

---


# [SCOI2014] 方伯伯的玉米田

## 题目描述

方伯伯在自己的农田边散步，他突然发现田里的一排玉米非常的不美。这排玉米一共有 $N$ 株，它们的高度参差不齐。方伯伯认为单调不下降序列很美，所以他决定先把一些玉米拔高，再把破坏美感的玉米拔除掉，使得剩下的玉米的高度构成一个单调不下降序列。方伯伯可以选择一个区间，把这个区间的玉米全部拔高 $1$ 单位高度，他可以进行最多 $K$ 次这样的操作。拔玉米则可以随意选择一个集合的玉米拔掉。问能最多剩多少株玉米，来构成一排美丽的玉米。

## 说明/提示

$100\%$ 的数据满足：$2 \le N \lt 10^4 $，$2 \le K \le 500$，$1 \leq a_i \leq 5000$。

## 样例 #1

### 输入

```
3 1
2 1 3```

### 输出

```
3```

# 题解

## 作者：NS·YJD (赞：80)

## 首先本题需要确定一个事实：
每一次的拔高操作区间右端点一定是最右边的玉米
## 证明：
首先无论操作区间在哪里，如果区间两边存在玉米，那么这些玉米与区间内玉米拔高后的相对高度关系只有3种情况：1.原本区间内比它们高的玉米还是比它们高。2.原本区间内比它们矮的玉米不再比它们矮。3.原本区间内比它们矮的玉米还是比它们矮。
### 对于区间左边而言：
这三种情况都不会减少初始排列中已存在的最长不下降序列的长度，并且有可能使它增长
### 对于区间右边而言：
这三种情况都不会增加初始排列中已存在的最长不下降序列的长度，并且有可能使它减少
### 如此一来我们就可以发现，要想得到最长不下降序列，区间的右边不存在玉米的情况一定是最优解
------------
## 接下来考虑转移方程：
对于排列中的某一点，它可能已经被j个拔高区间覆盖过（0<=j<=k）。那么我们考虑在包含了这一个已经被j个拔高区间覆盖过的点的最长不下降序列中，该点左边的所有点在原排列中一定在它的左边且被j'个拔高区间覆盖过（0<=j'<=），同时被拔高后的高度不大于它。
### 所以得出转移方程：
ｆ［ｉ］［ｊ］表示以ｉ结尾，ｉ这个点已经被j个拔高区间覆盖过，所能得到的最长不下降序列长度。
#### ｆ［ｉ］［ｊ］＝ｍａｘ｛ｆ［ｋ］［ｌ］｝＋１（１＜＝ｋ＜ｉ，０＜＝ｌ＜＝ｊ，ｈ［ｉ］＋ｊ＞＝ｈ［ｋ］＋ｌ）
### 很明显这里是需要快速求出一个二维的前缀最大值，所以引入二位树状数组：
ｔｒｅｅ［ｉ］［ｊ］维护的是以高度（拔高后的高度）在（ｉ－ｌｏｗｂｉｔ（ｉ）＋１，ｉ），被（ｊ－ｌｏｗｂｉｔ（ｊ）＋１，ｊ）个拔高区间覆盖过的点为结尾的所有不下降序列长度的最大值
## 本题最难理解的地方就是这里，我写到这里的时候也有点晕
### 我们先再看一遍转移方程
#### ｆ［ｉ］［ｊ］＝ｍａｘ｛ｆ［ｋ］［ｌ］｝＋１（１＜＝ｋ＜ｉ，０＜＝ｌ＜＝ｊ，ｈ［ｉ］＋ｊ＞＝ｈ［ｋ］＋ｌ）
### 这里~~好像~~可以降维
利用从左往右枚举来去掉第一维后，~~感觉上~~可以用ｆ［ｉ］来表示以当前这个点之前的所有被不超过ｉ个拔高区间覆盖过的点为结尾的最长不下降序列长度，~~似乎~~这样也可以正确表示出来。
### 理想很丰满，现实很果敢
#### ｈ［ｉ］＋ｊ＞＝ｈ［ｋ］＋ｌ
### 这个条件意味着我们还得增加一个高度的判定
确保找到的最长不下降子序列的最后一个点拔高后的高度不会超过当前这个点拔高后的高度，而仅仅使用一维我们无法进行高度的判定，所以这里必须增加一维来进行高度的判定，这一维表示的正是高度
### 于是有：
ｆ［ｊ］［ｋ］表示当前这个点ｉ前面（从左往右枚举点），以一个高度（拔高后的高度）不超过ｊ（ｊ＝ｈ［ｉ］＋ｋ），被不超过ｋ个拔高区间覆盖过的点为结尾的最长不下降序列的长度
### 到这里我们再去看前面的二维树状数组就可以很轻松地理解了
### 增加一点说明：
    for(int i=1;i<=n;i++）
        for(int j=k;j>=0;j--)
第二重循环的顺序必须由K递减，与背包问题同理

### 附上代码：
```cpp
#include<cstdio>
#include<cstdlib>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#define maxn 10000+10
#define maxk 500+10
#define large 6000
using namespace std;
int n,k,mx,ans;
int h[maxn],tree[large][maxk];
int lowbit(const int a)
{
	return a&(-a);
}
void update(int pos,const int val,int sel)
{
	for(;pos<=mx+k;pos+=lowbit(pos))
	    for(int i=sel;i<=k+1;i+=lowbit(i))
		tree[pos][i]=max(tree[pos][i],val);
}
int search(int pos,int sel)
{
	int ans=0;
	for(;pos;pos-=lowbit(pos))
	    for(int i=sel;i;i-=lowbit(i))
		ans=max(ans,tree[pos][i]);
	return ans;
}
int main(void)
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	scanf("%d %d",&n,&k);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&h[i]);
		mx=max(mx,h[i]);
	}
	for(int i=1;i<=n;i++)
	    for(int j=k;j>=0;j--)
	    {
	    	int x=search(h[i]+j,j+1)+1; 
	    	ans=max(ans,x);
	    	update(h[i]+j,x,j+1);
	    }
	cout<<ans<<endl;
	fclose(stdin);
	fclose(stdout);
	return 0;
}
```

---

## 作者：pkh68 (赞：22)


做了题，再写篇题解整理整理思路吧。

### 题目描述

方伯伯在自己的农田边散步，他突然发现田里的一排玉米非常的不美。这排玉米一共有N株，它们的高度参差不齐。方伯伯认为单调不下降序列很美，所以他决定先把一些玉米拔高，再把破坏美感的玉米拔除掉，使得剩下的玉米的高度构成一个单调不下降序列。方伯伯可以选择一个区间，把这个区间的玉米全部拔高1单位高度，他可以进行最多K次这样的操作。拔玉米则可以随意选择一个集合的玉米拔掉。问能最多剩多少株玉米，来构成一排美丽的玉### 米。

### 解析

我们观察发现：对于每个被拔高的区间，它的右端点必定在最右端上。

想一想为什么：

若我们把中间一段区间拔高后，其右的玉米肯定不会变得比它们高，那么这肯定不如把它们一起拔高。

有了这个性质，我们便有了朴素的$dp$方程：

设$f(i,j)$表示考虑到第$i$个玉米，已经拔高了$j$次。

$$f(i,j)=max(f(i',j')+1)({1}\leq{i'}<{i},{0}\leq{j'}\leq{j},{h[i']+j'}\leq{h[i]+j})$$

但这样的复杂度是$O(n^4)$的啊，一个点都过不掉（~~出题人真没良心~~）。

我们观察上面的方程，发现转移的范围是一个三维前缀和的范围。

考虑第一维$i$，可以在递推时保证这一点（具体说明见下）。

接下来考虑剩下两维，我们维护的是一个最值，对于每一个更新出来的$f(i,j)$,
我们用它在最值上单点修改，转移时区间查询。一个自然的思路便出现了：用二维树状数组维护最值。

接下来我们发现，其实记录$f(i,j)$完全没必要，因为我们转移是从树状数组中转移，更新是在树状数组中更新。

那我们不妨抛弃$f(i,j)$,每一个状态推出后立刻更新答案就是了。

但这样有一个问题：

在递推时，我们$f(i,j)$是从$[1,i-1]$的树状数组转移过来，所以我们更新答案时要保证这一点，考虑用$01$背包的思想，从$k$到$0$枚举$j$，这样每一次更新的值都不会在当前$i$这一维用上了。

### 最后附上代码：

```cpp

#include<iostream>
#include<cstdio>
#include<cstdlib>
#define N 10005
#define re register
using namespace std;
int n,K,X,Y,h[N],M[505][5505],ans=0;
inline int max(int a,int b){ return a>b?a:b; }
inline int L(int x){ return x&(-x); }
void Add(int x,int y,int C){ for(re int i=x;i<=X;i+=L(i)) for(re int j=y;j<=Y;j+=L(j)) M[i][j]=max(M[i][j],C); }
int Query(int x,int y){ int ans=0; for(re int i=x;i;i-=L(i)) for(re int j=y;j;j-=L(j)) ans=max(ans,M[i][j]); return ans; }
int main(){
	scanf("%d%d",&n,&K);
	for(re int i=1;i<=n;++i) scanf("%d",&h[i]),Y=max(Y,h[i]);
	X=K+1; Y=Y+K;
	for(re int i=1;i<=n;++i){
		for(re int j=K;~j;--j){
			int x=Query(j+1,h[i]+j)+1;
			ans=max(ans,x);
			Add(j+1,h[i]+j,x);
		}
	}
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：灵乌路空 (赞：19)

# 知识点: DP，树状数组

## [原题面](https://www.luogu.com.cn/problem/P3287)

---

## 题意简述

>给定一长度为 $n$ 的序列 $a$，可进行最多 $k$ 次区间 $+1$ 操作。  
>求操作后的最长不下降子序列长度。  
>$1<n<10000, 1< k\le 500, 1\le a_i \le 5000$。

---

## 分析题意

先猜个结论：所有修改操作的右端点一定为 $n$。  

设修改区间为 $[l,r]$，显然修改区间内部 元素相对大小不变。  
左侧元素不变，$[1,l-1]$ 的 **不下降子序列** 不变。  
则区间增高后，$[1,r]$ 的 **最长不下降子序列** 长度 只会增不会减。  

而 右侧元素不变，区间增高后，可能无法接到 $[l,r]$ 元素的后面，会导致 **最长不下降子序列** 减小。  
为保证答案最优，则应使 $r = n$。

---

有了这个结论就可以暴力转移了。  
设 $f_{i,j}$ 表示，以位置 $i$ 结尾，$i$ 已经被 $j$ 个区间覆盖时，$[1, n]$ 中最长不下降子序列长度，则有：  
$$\large f_{i,j} = \max_{1\le k<i,\ 0\le l\le j,\ a_k+l \le a_i+j}\{f_{k,l}\} + 1$$

复杂度 $O(n^2k^2)$，期望得分 $0\text{pts}$。

---

考虑优化。  
观察状态转移方程，发现 $f_{k,l}$ 是满足 $1\le k<i,\ 0\le l\le j,\ a_k+l \le a_i+j$ 的一个三维前缀最大值。  
$i$ 维可以通过枚举消除，问题变为二维前缀最大值问题。  

考虑二维树状数组优化。  
修改状态，设 $f_{j,k}$ 为 $1\sim i-1$ 中，被不超过 $j$ 个修改区间覆盖，结尾 $\le k$ 的最长不下降子序列的长度。  
直接用树状数组维护 $f$ 即可。  

注意 $j$ 可以为 $0$，树状数组的 $j$ 维整体右移一位， $j+1$ 实际上表示使用了 $j$ 次修改。

由于通过枚举消除了 $i$，为防止重复更新，套用01背包的思想，$j$ 需要从大到小枚举。

复杂度 $O(nk\log n\log k)$，期望得分 $100\text{pts}$。

---

神仙提出的单 $\log$ 写法：  

观察状态的含义：  
$f_{j,k}$ 为 $1\sim i-1$ 中，被不超过 $j$ 个修改区间覆盖，结尾 $\le k$ 的最长不下降子序列的长度。  
发现 $j$ 固定时，$f_{j,k}$ 随 $k$ 增加，只增不减。  
发现 $k$ 固定时，$f_{j,k}$ 随 $j$ 增加，只增不减。

则树状数组中 $x\le j,y\le k$ 的最大值，一定会在第 $j$ 行/ 第 $k$ 列取到。  

考虑建立 $2$ 个 $n$ 行的一维树状数组，分别维护每行/每列的 $f$ 值，更新时更新 整行/整列 有下图形式：  

![打了300年史莱姆竟然不知不觉练到了满等？](https://cdn.luogu.com.cn/upload/image_hosting/3sz0nfq5.png)

复杂度 $O(nk\log n)$，期望得分 $100\text{pts}$。  

---

## 代码实现

$O(nk\log n)$

写的比较丑连 $4s$ 都进不去 /kk

```cpp
//知识点:DP，树状数组
/*
By:Luckyblock
*/
#include <cstdio>
#include <ctype.h>
#include <cstring>
#include <algorithm>
#define ll long long
#define lowbit(x) (x&-x)
const int kMaxn = 1e4 + 10;
const int kMaxk = 510;
const int kMaxv = 5010;
//=============================================================
int n, K, ans, a[kMaxn], t1[kMaxk][kMaxv], t2[kMaxk + kMaxv][kMaxk];
int maxx, maxy;
//=============================================================
inline int read() {
  int f = 1, w = 0; char ch = getchar();
  for (; !isdigit(ch); ch = getchar()) if (ch == '-') f = -1;
  for (; isdigit(ch); ch = getchar()) w = (w << 3) + (w << 1) + (ch ^ '0');
  return f * w;
}
void GetMax(int &fir, int sec) {
  if (sec > fir) fir = sec;
}
void GetMin(int &fir, int sec) {
  if (sec < fir) fir = sec;
}
int Query(int *x, int pos) {
  int ret = 0;
  for (int i = pos; i; i -= lowbit(i)) {
    GetMax(ret, x[i]);
  }
  return ret;
}
void Modify(int *x, int pos, int lim, int val) {
  for (int i = pos; i <= lim; i += lowbit(i)) {
    GetMax(x[i], val);
  }
}
//=============================================================
int main() {
  n = read(), K = read();
  for (int i = 1; i <= n; ++ i) {
    a[i] = read();
    GetMax(maxy, a[i]);
  }
  maxx = K + 1, maxy += K;

  for (int i = 1; i <= n; ++ i) {
    for (int j = 0; j <= K; ++ j) {
      int tmp = Query(t1[j], a[i] + 1) + 1;
      GetMax(tmp, Query(t2[a[i] + j], j + 1) + 1);
      GetMax(ans, tmp);
      Modify(t1[j], a[i] + 1, kMaxv, tmp);
      Modify(t2[a[i] + j], j + 1, K + 1, tmp);
    }
  }
  printf("%d\n", ans);
  return 0;
}
```

---

$O(nk\log n\log k)$

```cpp
//知识点:DP，树状数组
/*
By:Luckyblock
*/
#include <cstdio>
#include <ctype.h>
#include <cstring>
#include <algorithm>
#define ll long long
#define lowbit(x) (x&-x)
const int kMaxn = 1e4 + 10;
const int kMaxk = 510;
const int kMaxv = 5010;
//=============================================================
int n, K, ans, a[kMaxn], t[kMaxk][kMaxv + kMaxv];
int maxx, maxy;
//=============================================================
inline int read() {
  int f = 1, w = 0; char ch = getchar();
  for (; !isdigit(ch); ch = getchar()) if (ch == '-') f = -1;
  for (; isdigit(ch); ch = getchar()) w = (w << 3) + (w << 1) + (ch ^ '0');
  return f * w;
}
void GetMax(int &fir, int sec) {
  if (sec > fir) fir = sec;
}
void GetMin(int &fir, int sec) {
  if (sec < fir) fir = sec;
}
int Query(int x, int y) {
  int ret = 0;
  for (int i = x; i; i -= lowbit(i)) {
    for (int j = y; j; j -= lowbit(j)) {
      GetMax(ret, t[i][j]);
    }
  }
  return ret;
}
void Modify(int x, int y, int val) {
  for (int i = x; i <= maxx; i += lowbit(i)) {
    for (int j = y; j <= maxy; j += lowbit(j)) {
      GetMax(t[i][j], val);
    }
  }
}
//=============================================================
int main() {
  n = read(), K = read();
  for (int i = 1; i <= n; ++ i) {
    a[i] = read();
    GetMax(maxy, a[i]);
  }
  maxx = K + 1, maxy += K;

  for (int i = 1; i <= n; ++ i) {
    for (int j = K; j >= 0; -- j) {
      int tmp = Query(j + 1, a[i] + j) + 1;
      GetMax(ans, tmp);
      Modify(j + 1, a[i] + j, tmp);
    }
  }
  printf("%d\n", ans);
  return 0;
}
``` 

---

## 作者：guodong (赞：13)

【 $\Theta(nk\log n)$的解法 】


显然的，拔高一个区间的玉米，右端点一定是第n株玉米。

于是我们列出状态转移方程：

```
F[i][k] 为第i株玉米，拔高用了 k 次的最长不降序列。

F[i][k]=max(F[i][k],F[j][k-l]+1); (j<k,A[i]>=A[j]+l)	
```
但是这样的时间复杂度是 $\Theta(n^2k^2)$的。

试着将复杂度降到 $\Theta(n\times k^2\times \log n)$


也就是说，当l确定的时候，我们要快速找出```F[j][k-l]``` 。

容易想起求最长不降序列的套路：我们引入 $k$ 个树状数组，这样就可以快速求解了。

```cpp
for(int i=1;i<=n;++i)
{
	for(int k=1;k<=n;++k)
	{
 		for(int l=1;l<=k;++l)
			F[i][k]=max(Query(A[k]+l)+1,F[i][k]);
	}
}
```
但是这样还不够。
#### 思维转化
我们先是很轻松的想到了二维树状数组。

```cpp
for(int i=1; i<=n; ++i) 
	{
		for(int j=k; j>=0; --j) // 防止继承了 i 的状态。
		{
			x=Query(j+1,A[i]+j)+1; // 由于树状数组的feature ,我们不得不将 j 整体+1
			smax(ans,x);
			Add(j+1,A[i]+j,x);
		}
	}
```
Query(state,height) 函数的作用是找到最大的```F[i][state](A[i]<height)```。

我们把这个树状数组想象成一个平面：

![gra.png](https://i.loli.net/2020/02/15/8EnpDKJdPuyLjiF.png)

上面代码的查找过程是 黄色-->橙色-->红色。

容易发现这样会有很多重复。

我们发现新增的状态只有两条。

![gra.png](https://i.loli.net/2020/02/15/94XaqOCrBHjKsxE.png)

于是我们可以拿两个树状数组维护新增的状态！

### 最优解第二代码

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<map>
#include<queue>
#include<iostream>
#include<cctype>
#include<cmath>
//#define int long long 
using namespace std;
inline int gi(){short tmp=getchar();int flag=1;while(!isdigit(tmp)){if(tmp=='-'){flag=-1;tmp=getchar();break;}tmp=getchar();}int ans=0;while(isdigit(tmp)) {ans=(ans<<3)+(ans<<1)+tmp-'0';tmp=getchar();}return ans*flag;}
inline void write(int x){static int stk[100], top = 0;if (x == 0) { putchar('0'); putchar(' ');return; }if (x < 0) { x = -x; putchar('-'); }while (x) { stk[++top] = x % 10; x /= 10; }while (top) { putchar(stk[top--] + '0'); }putchar(' ');}
#define line() putchar('\n');
#define Mem(Arr,V) memset(Arr,V,sizeof Arr);
#define Mcpy(Arr,qwq) memcpy(Arr,qwq,sizeof qwq);
#define max3(a,b,c) max(max(a,b),c)
#define max4(a,b,c,d) max4(max3(a,b,c),d);
#define in(a) a=gi()
#define in2(a,b) in(a),in(b)
#define in3(a,b,c) in2(a,b),in(c)
#define in4(a,b,c,d) in3(a,b,c),in(d)
#define write2(a,b) write(a),write(b)
#define write3(a,b,c) write2(a,b),write(c)
#define write4(a,b,c,d) write3(a,b,c),write(d)
inline void smin(int &x,int y){x=min(x,y);}
inline void smax(int &x,int y){x=max(x,y);}
const int inf = 1000000;
const int K =540;
int Height[522][5522],State[522][5522];
inline int lowbit(int x){return x&-x;}
inline void Add(int *A,int pos,int v,int to)
{
	for(int i=pos;i<=to;i+=lowbit(i))
		smax(A[i],v);
}
inline int Query(int *A,int pos)
{
	int ans=0;
	for(int i=pos;i>0;i-=lowbit(i))
		smax(ans,A[i]);
	return ans;
}
inline void AddH(int pos,int num,int v,int to)
{
	for(int i=pos;i<=to;i+=lowbit(i))
	{
		smax(Height[i][num],v);
	}
}
inline int QueryH(int pos,int num)
{
	int ans=0;
	for(int i=pos;i>0;i-=lowbit(i))
	{
		smax(ans,Height[i][num]);
	}
	return ans;
}
signed main()
{
	#ifndef ONLINE_JUDGE
		freopen("data.in","r",stdin);
	#endif
	int n,k;in2(n,k);
	int ans=0,x=0;
	int A;
	for(int i=1; i<=n; ++i) 
	{
		A=gi();
		for(int j=0; j<=k; ++j) // 这种方式不用考虑逆序问题！ 看图！
		{
			int q1=Query(State[j+1],A+j);
			int q2=QueryH(j+1,A+j);
			x=max(q1,q2)+1;smax(ans,x);
			Add(State[j+1],A+j,x,5502);
			AddH(j+1,A+j,x,502);
		}
	}
	write(ans);
	return 0;
}
```

---

## 作者：Stinger (赞：13)

yysy这题在省选里面算是人口普查题了，个人感觉难度也不到紫。

不难想到每次区间拔高只会拔高 $[i,n]$ 这段区间，即拔高区间的终点必定为 $n$。

每次拔高的作用，假设我拔高了 $[i,n]$，那么如果原来 $a_{i-1}+>a_i$，拔高了 $a_{i-1}$ 与 $a_i$ 差距就减小了，多拔高几次 $a_{i-1}\le a_i$ 后，$a_i$ 就能拼在 $a_{i-1}$ 后了，也就是说我们既然拔高了这段区间，最后的LIS一定包含 $a_i$，不然纯属费力不讨好。

$dp_{i,j}$ 表示拔高了 $j$ 次，每次拔高的起点都不超过 $i$，以 $i$ 结尾的LIS最长有多长。

$dp_{i,j}=max(dp_{x,y}+1)(x\leq i,y\leq j,a_x+y\leq a_i+j)$。

按照阶段计算后，$x\leq i$ 这个条件天然满足，不予考虑。而 $a_i$ 范围又极小，所以就可以二维线段树了。当然这题的 $dp$ 数组计算后不会改变，因此可以二维树状数组。

时间复杂度 $O(nklogklogMX)$，$MX$ 为 $a_i$ 最大值加上 $k$。目测此题可能有 $O(nklogk)$ 的做法，但是懒得想（光速逃

代码很短，短得离谱。

```cpp
#include <cstdio>

inline int max(const int x, const int y) {return x > y ? x : y;}
int a[10005], dp[10005][505], c[505][5505], n, m;
void update(const int x, const int y, const int d) {
	for (int i(x); i <= m + 1; i += (i & ~i + 1))
	for (int j(y); j <= 5500; j += (j & ~j + 1)) c[i][j] = max(c[i][j], d);
}
int query(const int x, const int y) {
	int ans(0);
	for (int i(x); i; i -= (i & ~i + 1))
	for (int j(y); j; j -= (j & ~j + 1)) ans = max(ans, c[i][j]);
	return ans;
}

int main() {
	scanf("%d%d", &n, &m);
	for (int i(1); i <= n; ++ i) scanf("%d", a + i);
	for (int i(1); i <= n; ++ i)
	for (int j(m); j >= 0; -- j)
		update(j + 1, a[i] + j, dp[i][j] = query(j + 1, a[i] + j) + 1);
	printf("%d", query(m + 1, 5500));
	return 0;
}
```

---

## 作者：ModestCoder_ (赞：10)

我来贡献本题第一篇题解

初始的思路十分重要

**每次拔高玉米的右端点总是n**

为什么？

如果对中间一段进行操作，对前面的是更优的，但对后面的会劣，所以如果右端点为n，则对后面不会有影响

**朴素DP：**

dp[i][j]表示前i个，拔j次，最优解

     **dp[i][j]=max(dp[k][l])+1(k<i,l<=j,a[i]+j>=a[k]+l）**

CODE:

```cpp
uses math;
var
    a:Array[0..10000] of int64;
    dp:array[0..10000,0..500] of int64;
    n,m,i,j,k,l:longint;
begin
    readln(n,m);
    for i:=1 to n do
        read(a[i]);
    for i:=1 to n do
        for j:=m downto 0 do
            for k:=0 to i-1 do
                for l:=m downto 0 do
                    if a[k]+l<=a[i]+j then
                        dp[i][j]:=max(dp[i][j],dp[k][l]+1);
    writeln(dp[n][m]);
end.
```
时间复杂度O(n^2\*k^2)全超
**想到用二维树状数组优化**

把dp数组变成一个树状数组

定义不变，时间复杂度O(nlogn\*klogk)








```cpp
uses math;
var
    a:Array[0..10000] of int64;
    c:array[0..10000,0..500] of int64;
    n,m,i,j,k,l,maxa,ans,sum:longint;
function lowbit(x:int64):int64;
begin
    exit(x and -x);
end;
procedure change(x,y,z:int64);
var
    yy:int64;
begin
    yy:=y;
    while x<=maxa+m do
        begin
            y:=yy;
            while y<=m+1 do
                begin
                    c[x][y]:=max(c[x][y],z);
                    inc(y,lowbit(y));
                end;
            inc(x,lowbit(x));
        end;
end;
function getsum(x,y:int64):int64;
var
    yy:int64;
begin
    getsum:=0;
    yy:=y;
    while x>0 do
        begin
            y:=yy;
            while y>0 do
                begin
                    getsum:=max(getsum,c[x][y]);
                    dec(y,lowbit(y));
                end;
            dec(x,lowbit(x));
        end;
end;
begin
    readln(n,m);
    for i:=1 to n do
        begin
            read(a[i]);
            maxa:=max(maxa,a[i]);
        end;
    for i:=1 to n do
        for j:=m downto 0 do
            begin
                sum:=getsum(a[i]+j,j+1)+1;
                change(a[i]+j,j+1,sum);
                ans:=max(ans,sum);
            end;
    writeln(ans);
end.
```

---

## 作者：Gary818 (赞：8)

# [SCOI2014]方伯伯的玉米田  


------------
## [P3287](https://www.luogu.org/problem/P3287)  
以上为标题行，没超过30字符吧（怕了～  
**这么水的题还需要思考？  
这不是裸的树状数组+DP吗？**  
来自dalao的嘲讽，身为caiji的我瑟瑟发抖QwQ  

dalao一眼看穿正解后潇洒的走了，留下我一人在风中凌乱，于是我慢慢摸索了三天，终于搞明白啦 (~~我是不会告诉你我看题解懂的~~  

那么对于每次修改的区间，是要有选择性的  
感谢@:NS·YJD  给出的证明，在此复述一遍：  
对于每次修改的区间以及其左边序列和右边序列，共三种情况：  
* 1.区间内比两侧低的还是低  
* 2.区间内比两侧低的变得比两侧高了  
* 3.区间内比两侧高的还是高  

那么现在又面临一个问题：在区间内变化后，对答案，即最长不下降子序列有什么影响。  
对区间左边：可能会使其最长不下降子序列增长  
对区间右边：可能会使其最长不下降子序列减少  
综上所述：我们YY（有点贪心的感觉）出正解一定要保证修改的区间右侧没有数，也就是修改区间的最后一位在$n$上  
然后来到最使我头疼的地方，DP转移方程，这个简单的方程我想了好久（似乎也不是很简单）  
$f[i][j]$表示以i结尾，被拔高了j次的区间之后，最长不下降子序列的长度  
$ f[i][j] = \max { f[k][l] } +1   (1 \leq k < i,0 \leq l \leq j,h[i]+j>h[k]+l)$  
然后我们用二维树状数组维护一下就好了  
呆码，码量不是很大  
```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
using namespace std;

const int maxn=100010;
int n,k,mx,ans;
int h[maxn],tr[6666][555];

inline int lowbit(const int x){
    return x&(-x);
}

inline void update(int pos,int val,int sel){
    for(;pos<=mx+k;pos+=lowbit(pos))
        for(int i=sel;i<=k+1;i+=lowbit(i))
            tr[pos][i]=max(tr[pos][i],val);
}

inline int query(int pos,int sel){
    int ans=0;
    for(;pos;pos-=lowbit(pos))
        for(int i=sel;i;i-=lowbit(i))
            ans=max(ans,tr[pos][i]);
    return ans;
}

signed main(){
    cin>>n>>k;
    for(int i=1;i<=n;i++){
        cin>>h[i];
        mx=max(mx,h[i]);
    }
    for(int i=1;i<=n;i++)
        for(int j=k;j>=0;j--){
            int x=query(h[i]+j,j+1)+1;
            ans=max(ans,x);
            update(h[i]+j,x,j+1);
        }
    cout<<ans<<endl;
    return 0;
}
```
三天了，终于完了～

---

## 作者：Tgotp (赞：7)

其实很好观察发现到一个性质。要保证单调不下降，每次选择的区间右端点一定是n。


（结果发现了这个性质我还是不会做XD


令f[i][j]表示第i个位置用了j次拔高机会最多保留的个数。


那么f[i][j] = f[x][y] + 1 ( i +  j >= x + y)


考虑树状数组维护，那么 f[i][j] = query(a[i] + j,j + 1) + 1。


注意是j + 1，因为树状数组要保证元素 > 0 ，但是会出现 0 的情况，所以将树状数组整体后移一位;


表示 查询 最大值不超过 a[i] + j ，使用了 j 次机会的情况。


得到的答案再进行更新就好了，搞定。

[blog题解地址](http://tgotp.science/3594-scoi2014%E6%96%B9%E4%BC%AF%E4%BC%AF%E7%9A%84%E7%8E%89%E7%B1%B3%E7%94%B0/)

c++代码如下：





```cpp
#include<bits/stdc++.h>
#define lowbit(x) (x & -x)
#define rep(i,x,y) for(register int i = x ;i <= y;++i)
#define repd(i,x,y) for(register int i = x ;i >= y;--i)
using namespace std;
typedef long long ll;
template<typename T>inline void read(T&x)
{
    x = 0;char c;int sign = 1;
    do { c = getchar(); if(c == '-') sign = -1; }while(c < '0' || c > '9' );
    do { x = x * 10 + c - '0'; c = getchar(); }while(c <= '9' && c >= '0');
    x *= sign;
}
const int N = 1e4 + 600, K = 521;
int a[N],ans,mx,n,k;
int c[N][K];
inline void modify(int x,int y,int z)
{
    for(register int i = x;i <= mx + k; i += lowbit(i))
        for(register int j = y;j <= k + 1; j += lowbit(j))
            c[i][j] = max(c[i][j],z);
}
inline int query(int x,int y)
{
    int ans = 0;
    for(register int i = x;i; i -= lowbit(i))
        for(register int j = y;j; j -= lowbit(j))
            ans = max(ans,c[i][j]);
    return ans;
}
int main()
{
    read(n);read(k);
    rep(i,1,n) read(a[i]),mx = max(mx,a[i]);
    int x;
    rep(i,1,n)
        repd(j,k,0)
        {
            x = query(a[i] + j,j + 1) + 1;
            ans = max(ans,x);
            modify(a[i] + j,j + 1,x);
        }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：MuYC (赞：5)

**卡** 过去了，写篇题解 $VanVan$。

#### 前置知识：

$dp$ + **一维** 树状数组单点修改以及维护区间最值。

最后这个方法的时空复杂度分别是：

$O(nk \log(a_i) + nk \log(k))$， $O(ka_i + kn)$ 

有亿点点卡.....数组要开 $short$ 类型的才能过。

#### 分析性质：

每次加操作的区间总是一段后缀，也就是说一定是 $[pos,n]$ 的。

ps.这个的证明已经有人给了，这里就略了。

所以我们用 **拔高** 操作使得每个玉米长高的高度一定是前面低后面高的。这个性质非常重要！

并且使用 **拔高** 的次数越多能够剩下的玉米的数量最多。

#### 非完美做法:

+ $0$ 分做法:

$dp[i][j]$ 表示在 $i$ 点用了 $j$ 次 **拔高**操作，使得前 $1$ ~ $i$ 的玉米满足条件的情况下剩下的玉米最多数量。

那么暴力的转移即是 ：

令 $k < i, w < j$。

$if$ $a_k \leq a_i : $

$dp[i][j] = max(dp[k][w]) + 1$

$if$ $a_k > a_i : $

$dp[i][j] = max(dp[k][w \leq j - (a_k - a_i)]) + 1$

复杂度是 $O(n^2k^2)$ 的。预计得分： $0 pts$。

+ $20$ 分做法:

$dp$ 数组的意义跟前面的一样，但是由于我们知道使用 **拔高** 操作的次数越多的话，那么可以留下的玉米就会越多。

那么暴力的转移即是 ：

令 $k < i, w \leq j$。

$if$ $a_k \leq a_i : $

$dp[i][j] = dp[k][j] + 1$

$if$ $a_k > a_i : $

$dp[i][j] = dp[k][j - (a_k - a_i)] + 1$

复杂度是 $O(n^2k)$ 的。预计得分： $20 pts$。

+ 复杂度更优的 $20$ 分做法：

考虑到如果我们每次都要枚举 $k < i$ 实在是不优，但是 $a_i \leq 5000$ ，那么我们为什么不设置一个辅助数组 $D[x][c][q]$ 来表示：

在 $1$~$x$ 这里面，$a_i = c$ 的 $dp[i][q]$ 的最大值呢？

根据我们的 $dp$ 转移是 $x$ 每次加一的，所以可以滚动掉第一维。

那么第一个方程就会变为：

$dp[i][j] = D[1 \leq k \leq a_i][j] + 1$ 复杂度: $O(ka_i)$

第二个方程就会变为：

$dp[i][j] = D[ a_i < k \leq a_i + j][k - a_i](j >= 1)$，复杂度:$O(k^2)$

转移完了后通过 : 

$D[a_i][j] = max(D[a_i][j], dp[i][j])$ 来维护 $D$ 即可，这个复杂度为 $O(k)$。

总复杂度变为了 $O(n * (a_i*k + k^2))$，期望得分仍然是 $20pts$但是复杂度显然好了点，但是我们还可以更优秀。

+ 满分做法

考虑对前面提到的较优秀的 $20pts$ 的做法进行优化。

我们发现对于第一个方程：

$dp[i][j] = D[1 \leq k \leq a_i][j] + 1$

这个东西是一个非常经典的树状数组优化 $dp$ ，建立 $K$ 棵线段树，下标为 $a_i$ ，维护最大值就行了。

对于第二个方程:

$dp[i][j] = D[ a_i < k \leq a_i + j][k - a_i]$。

这个东西就没那么好维护了，貌似要用二维才能维护。

实际上我们展开这个方程：

$dp[i][1] = max(D[A_i + 1][0])$

$dp[i][2] = max(D[A_i + 1][1], D[A_i + 2][0])$

$dp[i][3] = max(D[A_i + 1][2], D[A_i + 2][1], D[A_i+3][2])$

画个图（横着的表示 $D$ 的第二维坐标，竖着的是第一维坐标）：

下面令 $A_i = 4$

红点是 $(A_i, 1)$，那么 $(A_i + 1,0)$ 就是其左下的点 $(5,0)$，那么 $(A_i,2)$ 的左下两个点就是 $(5,1),(6,0)$ 。

![](https://cdn.luogu.com.cn/upload/image_hosting/c4uk679p.png)

这恰恰对应了 $dp[i][j]$ 的转移！那么对于 $dp[i][j]$ 的转移就是相当于找到 $(A_i,j)$ 在 $D$ 中的位置然后求左下角所有点的最大值。

![](https://cdn.luogu.com.cn/upload/image_hosting/1z2jdqm6.png)

然后就直接一维树状数组维护斜边的区间最值就可以转移了！

斜边的条数是 $(K + max(a_i))$ 的，于是空间复杂度就是 $O(K * (K + a_i))$。

于是就做完了。

#### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
const short MAXN = 1e4 + 5, MAXK = 505;
short n, K, A[MAXN];
short M, dp[MAXN][MAXK], Ans;

struct SegmentTree {
	short h[MAXN];
	short lowbit(short x) { return x&(-x); }
	void change(short x, short k) {
		while (x <= M) {
			h[x] = max(h[x], k);
			x += lowbit(x);
		}		
	}
	short GetMax(short x, short y) {
		short ans = 0;
		while (y >= x) ans = max(h[y], ans), y -= lowbit(y);
		return ans;
	}
} T[MAXK];

struct SegmentTree2 {
	short h[MAXK];
	short lowbit(short x) { return x & (-x); }
	void change(short x, short k) {
		while (x <= K) {
			h[x] = max(h[x], k);
			x += lowbit(x);
		}		
	}
	short GetMax(short x, short y) {
		short ans = 0;
		while (y >= x) ans = max(h[y], ans), y -= lowbit(y);
		return ans;
	}
} C[(MAXN >> 1) + MAXK];

int main() {
	scanf("%hd%hd", &n, &K);
	for(short i = 1 ; i <= n ; i ++) scanf("%hd", &A[i]), M = max(M, A[i]);
	for(short i = 0 ; i <= K ; i ++) T[i].change(A[1], 1);
	for(short i = 0 ; i <= K ; i ++) C[A[1] + i].change(i + 1, 1);
	for(short i = 2 ; i <= n ; i ++) {
		for(short k = 0 ; k <= K ; k ++) dp[i][k] = T[k].GetMax(1, A[i]), dp[i][k] ++;
		for(short k = 1 ; k <= K ; k ++) {
			short number = A[i] + k, v = C[number].GetMax(1, k) + 1;
			dp[i][k] = max(dp[i][k], v);
		}
		for(short j = 0 ; j <= K ; j ++) T[j].change(A[i], dp[i][j]), Ans = max(dp[i][j], Ans);
		for(short j = 0 ; j <= K ; j ++) C[A[i] + j].change(j + 1, dp[i][j]);
	}
	printf("%hd", Ans);
	return 0;
}
```

---

## 作者：Prean (赞：4)

首先考虑区间加对应什么东西。

对应的显然是差分序列上某个位置 $+1$ 某个位置 $-1$。

再考虑单调不降意味着什么。

对应的是划分成若干个区间，每个区间的和不小于 $0$。

所以就有一个结论，区间加一定不优于后缀加。

不过其实注意到一点，你并不关心你是哪个位置的数，你只关心你有多大。

所以设 $dp[i][k]$ 当前序列最后一个元素为 $i$，且进行了 $k$ 次修改的最大长度。

考虑增加一个元素时如何转移到 $dp[i][k]$，容易发现有 $dp[i][k]=\max(dp[i][k],1+\max(\max_{j=1}^{i}dp[j][k],\max_{j=i}^{n}dp[j][k-(j-i)]))$。

这是一个在 dp 数组上斜着的东西和一个在 dp 数组上面横着的东西，维护前缀最大值和后缀最大值即可，使用树状数组。

显然有单调性 $dp[i][k]\leq dp[i][k+1]$。

复杂度 $O(nk\log n)$，应该可以通过吧。
```cpp
#include<cstdio>
#include<cctype>
namespace SOLVE{
	const int M=5005;
	int n,m,k,a[M*2],dp[M][505];
	inline int max(const int&a,const int&b){
		return a>b?a:b;
	}
	struct BIT{
		int mx[M];
		inline void Ins(int x,const int&w){
			while(x<=m)mx[x]=max(mx[x],w),x+=x&-x;
		}
		inline int Qry(int x){
			int ans(0);while(x>=1)ans=max(ans,mx[x]),x-=x&-x;return ans;
		}
	}fx[505],fy[M+505];
	inline int read(){
		int n(0);char s;while(!isdigit(s=getchar()));while(n=n*10+(s&15),isdigit(s=getchar()));return n;
	}
	inline void Ins(const int&V,const int&K,const int&w){
		if(w<dp[V][K])return;dp[V][K]=max(dp[V][K],w);
		fx[K].Ins(V,dp[V][K]);fy[V+K].Ins(m+1-V,dp[V][K]);
	}
	inline int Qry(const int&V,const int&K){
		return max(fx[K].Qry(V),fy[V+K].Qry(m+1-V));
	}
	inline void main(){
		int ans(0);n=read();k=read();for(int i=1;i<=n;++i)if((a[i]=read())>m)m=a[i];
		for(int i=1;i<=n;++i)for(int mx(0),j=0;j<=k;++j)Ins(a[i],j,mx=max(mx,Qry(a[i],j)+1));
		for(int i=1;i<=m;++i)for(int j=0;j<=k;++j)ans=max(ans,dp[i][j]);printf("%d",ans);
	}
}
signed main(){
	SOLVE::main();
}
```

---

## 作者：Jayun (赞：3)

# 链接：

[题目](https://www.luogu.com.cn/problem/P3287)

[博客园](https://www.cnblogs.com/GJY-JURUO/p/14323523.html)

# 题目大意：

可以 $k$ 次区间加一数列 $a$，求最长不下降子序列长度。

# 正文：

最重要的一点是，区间加一操作的右端点一定是 $n$。假设原本想要区间 $[l,r]$ 加一，由于是求最长不下降子序列长度，所以 $[l,r]$ 加一后，肯定也小于等于 $[r+1,n]$ 的任意一点，所以直接 $[l,n]$ 对答案没有影响。

接着就是设 $f_{i,j}$ 表示 $a_i$ 被加过 $j$ 次的最长不下降子序列长度，则有：

$$f_{i,j}=\max_{k<i,l\leq j,a_k+l<a_i+j}\{f_{k,l}+1\}$$

可以用二维的树状数组维护。

# 代码：

```cpp
int n, mx, m;
int t[M][N], ans;
int a[N];

void update(int x, int k, int val) 
{
	for (; x <= mx; x += x & -x) 
		for (int i = k; i <= m + 1; i += i & -i) 
			t[i][x] = max(t[i][x], val);
}
int query(int x, int k) 
{
	int ans = 0;
	for (; x; x -= x & -x) 
		for (int i = k; i; i -= i & -i) 
			ans = max(t[i][x], ans); 
	return ans;
}

int main()
{
	scanf ("%d%d", &n, &m);
	memset (t, 0, sizeof t);
	for (int i = 1; i <= n; i++)
		scanf ("%d", &a[i]), mx = max(mx, a[i]);
	mx += m; 
	for (int i = 1; i <= n; i++)
		for (int j = m; ~j; j--)
		{
			int tmp = query(a[i] + j, j + 1) + 1;
			ans = max(ans, tmp);
			update(a[i] + j, j + 1, tmp);
		}
	
	printf ("%d\n", ans);
    return 0;
}
```

---

## 作者：封禁用户 (赞：3)

[我可爱的$Blog$在此，为什么不来这里获得更好的阅读体验呢？](https://www.cnblogs.com/wo-shi-zhen-de-cai/p/11834753.html)

[性感伯伯，在线拔苗，快来帮忙，一同快乐](https://www.luogu.org/problem/P3287)

~~如果我说我是找标签看到这题来练树状数组的你信吗？~~

好一道毒瘤的$DP$。

感性理解一下一个结论，我们每次拔苗右端点一定是最右边的玉米。

证明在[这篇题解](https://www.luogu.org/blog/AlexYD/solution-p3287)中已经讲得很清楚了对吧。

我主要是讲一下有关$DP$方程的事儿。

一个显然的状态是$f[i][j]$表示我们已经处理了前$i$个玉米苗，并对第$i$个玉米苗拔高了$j$次的答案。

方程是$f[i][j]=max\{f[k][l]\}+1(1\leq k<i,0\leq l\leq j,H[i]+j\geq H[k]+l)$

显然这个转移会$TLE$，于是我们考虑优化，找二维前缀$max$，用二维树状数组实现。

等。。等一下，$H[i]+j\geq H[k]+l?$，这个限制用树状数组显然是难以满足的。

那么我们不妨考虑将高度的限制加入状态。

即设$f[i][j][k]$表示前$i$个玉米苗，以不超过$j$高度且被操作了不超过$k$次的玉米苗结尾。

限制中就少了高度的限制。然后在用类似背包的思想滚掉$i$这一维即可。

```C++
#include<bits/stdc++.h>
using namespace std;
#define int long long
namespace AE86
{
	const int bufl=1<<15;
	char buf[bufl],*s=buf,*t=buf;
	inline int fetch()
	{
		if(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}
		return*s++;
	}
	inline int read()
	{
		int a=0,b=1,c=fetch();
		while(!isdigit(c)) b^=c=='-',c=fetch();
		while(isdigit(c)) a=a*10+c-48,c=fetch();
		return b?a:-a;
	}
}
const int N=1e4+10;
const int K=5e2+10;
int n,k,Ans,Max,H[N],f[N][K],Tar[N][K];

inline void Insert(int x,int y,int Val)
{
	for(;x<=Max+k;x+=x&-x)
		for(int j=y;j<=k+1;j+=j&-j)
			Tar[x][j]=max(Tar[x][j],Val);
}
inline int Ask(int x,int y)
{
	int Sum=0;
	for(;x;x-=x&-x)
		for(int j=y;j;j-=j&-j)
			Sum=max(Sum,Tar[x][j]);
	return Sum;
}
signed main(){
#ifndef ONLINE_JUDGE
    freopen("A.in","r",stdin);
#endif
	n=AE86::read(),k=AE86::read();
	for(int i=1;i<=n;i++) H[i]=AE86::read(),Max=max(Max,H[i]);
	for(int i=1;i<=n;i++)
		for(int j=k;j>=0;j--)
			f[i][j]=Ask(H[i]+j,j+1)+1,Insert(H[i]+j,j+1,f[i][j]);
	for(int i=1;i<=n;i++)
		for(int j=k;j>=0;j--)
			Ans=max(Ans,f[i][j]);
	printf("%lld\n",Ans);
}
```



---

## 作者：yzhang (赞：2)

### [更好的阅读](https://www.cnblogs.com/yzhang-rp-inf/p/10335132.html)

### [原题传送门](https://www.luogu.org/problemnew/show/P3287)

#### 一眼就能看出来这是一道dp题

#### 显而易见每次操作的右端点一定是n，每株玉米被拔高的次数随位置不下降

#### 用f(i,j) 表示以第i 株玉米结尾它被拔高了j 次的最长序列长度。

#### $f(i,j)=Max(f(p,q)+1)(0<=p<i,0<=q<j,a_p+q<a_i+j$]

#### 复杂度是$O(n^2k^2)$

#### 显然过不了这题

#### 用d(i, j) 表示到目前为止结尾玉米被拔高了i 次高度为j的最长序列长度。

#### 我们需要不断更新这个表(当然不会下降) ，并查询二维前缀最大值。

#### 这珂以用二维树状数组来维护

#### 复杂度$O(n \log n k \log k)$

```cpp
#include <bits/stdc++.h>
#define getchar nc
#define N 10005
#define K 505 
using namespace std;
inline char nc(){
    static char buf[100000],*p1=buf,*p2=buf; 
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++; 
}
inline int read()
{
    register int x=0,f=1;register char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return x*f;
}
inline void write(register int x)
{
    if(!x)putchar('0');if(x<0)x=-x,putchar('-');
    static int sta[20];register int tot=0;
    while(x)sta[tot++]=x%10,x/=10;
    while(tot)putchar(sta[--tot]+48);
} 
inline int Max(register int a,register int b)
{
    return a>b?a:b;
}
int n,k,tr[N][K],h[N],mx,ans=0;
inline int lb(register int x)
{
    return x&(-x);
}
inline int query(register int x,register int y)
{
    int res=0;
    for(register int i=x;i;i-=lb(i))
        for(register int j=y;j;j-=lb(j))
            res=Max(tr[i][j],res);
    return res;
}
inline void update(register int x,register int y,register int v)
{
    for(register int i=x;i<=mx+k;i+=lb(i))
        for(register int j=y;j<=k+1;j+=lb(j))
            tr[i][j]=Max(tr[i][j],v);
}
int main()
{
    n=read(),k=read();
    for(register int i=1;i<=n;++i)
    {
        h[i]=read();
        mx=Max(mx,h[i]);
    }
    for(register int i=1;i<=n;++i)
        for(register int j=k;j>=0;--j)
        {
            int x=query(h[i]+j,j+1)+1;
            ans=Max(ans,x);
            update(h[i]+j,j+1,x);
        }
    write(ans);
    return 0;
 } 
```

### 这已经能过这题了，但我们还珂以继续优化

#### 我们珂以发现每次树状数组查询都有大量重复计算

#### 所以珂以变成一维树状数组

```cpp
#include <bits/stdc++.h>
#define getchar nc
#define N 10005
#define K 505 
#define V 5005 
using namespace std;
inline char nc(){
    static char buf[100000],*p1=buf,*p2=buf; 
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++; 
}
inline int read()
{
    register int x=0,f=1;register char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return x*f;
}
inline void write(register int x)
{
    if(!x)putchar('0');if(x<0)x=-x,putchar('-');
    static int sta[20];register int tot=0;
    while(x)sta[tot++]=x%10,x/=10;
    while(tot)putchar(sta[--tot]+48);
} 
inline int Max(register int a,register int b)
{
    return a>b?a:b;
}
int n,k,ans,h[N],f[N][K]; 
struct BinaryIndexTree{
    int maxx[V];
    inline void update(register int pos,register int v)
    {
        ++pos;
        for(register int i=pos;i<=V-1;i+=i&(-i))
            maxx[i]=Max(maxx[i],v);
    }
    inline int query(register int pos)
    {
        int res=0;
        ++pos;
        for(register int i=pos;i;i-=i&(-i))
            res=Max(res,maxx[i]);
        return res;	
    }
}tr1[K];
struct BinaryIndexTree2{
    int maxx[K];
    inline void update(register int pos,register int v)
    {
        ++pos;
        for(register int i=pos;i<=k+1;i+=i&(-i))
            maxx[i]=Max(maxx[i],v);
    }
    inline int query(register int pos)
    {
        int res=0;
        ++pos;
        for(register int i=pos;i;i-=i&(-i))
            res=Max(res,maxx[i]);
        return res;	
    }
}tr2[K+V];
int main()
{
    n=read(),k=read();
    for(register int i=1;i<=n;++i)
        h[i]=read();
    for(register int i=1;i<=n;++i)
        for(register int j=0;j<=k;++j)
        {
            int tmp1=tr1[j].query(h[i]),tmp2=tr2[h[i]+j].query(j);
            f[i][j]=Max(tmp1,tmp2)+1,ans=Max(ans,f[i][j]);
            tr1[j].update(h[i],f[i][j]),tr2[h[i]+j].update(j,f[i][j]);
        }
    write(ans);
    return 0;
 } 
```

---

## 作者：lmgoat (赞：1)

考虑 DP。

显然有一个结论：每次操作的区间的右端点一定是 $n$。因为是最长上升子序列，所以让后面的变大一定是不劣的。

设：$f[i][j]$ 表示已经做了 $j$ 个操作，且这 $j$ 个操作的的左端点都小于等于 $i$ 的状态下最长上升子序列的长度。这样设计状态就可以保证第 $i$ 个数已经变成了 $a[i]+j$，知道这个就可以转移了。

转移：$f[i][j]=\max\{f[x][y]+1\}\,(1\le x<i,1\le y\le j,a[x]+y<a[i]+j)$。就是选择一个最大的合法接上去。在 $f[x][y]$ 这个状态中，$a[x]$ 的值已经变成了 $a[x]+y$，所以 $a[x]+y<a[i]+j$ 就是满足上升的条件。

考虑优化。第一个限制 $x<i$ 只要是从小到大枚举 $i$ 就肯定满足。要考虑的就是 $1\le y\le j$ 和 $a[x]+y<a[i]+j$。所以设 $(y,a[x]+y)$ 是一种状态，合法的状态就是一个左上角为 $(1,1)$ ，右下角为 $(j,a[i]+j-1)$ 的矩阵。所以只要维护这个矩阵的二维前缀最大值就可以快速转移了。

可以用二维树状数组和二维线段树，但树状数组要好写得多，所以建议用前者。

设 $v=max\{a[i]\}+k$，总时间复杂度就是 $O(nk\log v\log k)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
int read() {
	int x(0),f(0);
	char ch=getchar();
	while(!isdigit(ch)) f|=(ch=='-'),ch=getchar();
	while(isdigit(ch)) x=x*10+ch-'0',ch=getchar();
	return f?-x:x;
}
const int N=10005,K=505,M=5500;
int n,k,ans,a[N],f[N][K],t[K][M+5];
void add(int x,int y,int v) {
	for(int i=x+1;i<=k+1;i+=(i&-i))
	for(int j=y;j<=M;j+=(j&-j))
		t[i][j]=max(t[i][j],v);
}
int ask(int x,int y) {
	int res=0;
	for(int i=x+1;i;i-=(i&-i))
	for(int j=y;j;j-=(j&-j))
		res=max(res,t[i][j]);
	return res;
} 
signed main() {
	n=read(),k=read();
	for(int i=1;i<=n;++i) a[i]=read();
	for(int i=1;i<=n;++i)
	for(int j=k;j>=0;--j) {
		f[i][j]=ask(j,a[i]+j)+1;
		add(j,a[i]+j,f[i][j]);
		ans=max(f[i][j],ans);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：约瑟夫用脑玩 (赞：1)

做不起省选里面难度不到紫的人口普查题了![](https://图.tk/0)

首先猜到了拔高的区间右端点一定为 $n$，然后考虑在最后能产生效果的地方拔高，那么一定是使得左端点处被提进了 LIS 中。

那么就有了一个 naive 的 DP 状态就是 $f_{i,j}$ 表示总共拔高了 $j$ 次，且 $a_i$ 在当前 LIS 中的最后一个。

然后我们把下一个位置提进 LIS 中，故 $f_{i,j}+1\to f_{k,j+\max{(0,a_j+i-a_k)}}$，发现刷表转移不太舒服，还是转成填表转移。

考虑上一个位置转移有 $f_{i,j}\leftarrow f_{k,j-d}+1,\max{(0,a_k-a_i)}\le d$，直接上三维偏序，随便上个数据结构维护即可。

复杂度 $O(nk\log^2)$。

代码：

```
namespace btt
{
	int mx[Mx+5][M+5];
	inline void Add(int x,int y,int v)
	{
		int i,j;
		for(i=x+1;i<=K+1;i+=Lbt(i))for(j=y;j<=M;j+=Lbt(j))ckmx(mx[i][j],v);
	}
	inline int Ask(int x,int y)
	{
		int i,j,mxx=0;
		for(i=x+1;i;i-=Lbt(i))for(j=y;j;j-=Lbt(j))ckmx(mxx,mx[i][j]);
		return mxx;
	}
}
signed main()
{
	int i,j,x;
	n=read();K=read();
	for(i=1;i<=n;i++)for(x=read(),j=K;~j;j--)btt::Add(j,x+j,btt::Ask(j,x+j)+1);
	writenum(btt::Ask(K,M),10);
	return output;
}
```

---

## 作者：lyt_awa (赞：0)

## dp
### 状态
容易想到一个状态 $f(i,j)$ 表示前 $i$ 株玉米，进行 $j$ 次操作且第 $i$ 株玉米不拔掉最多剩多少株玉米。
### 转移
$$f(i,j)=\max_{k<i,l\le j,a_k+l\le a_i+j}f(k,l)+1$$
可以用暴力来枚举 $k,l$ 进行转移。
```cpp
for (int k = 1; k < i; ++k)
	for (int l = 0; l <= j; ++l)
		if (a[k] + l <= a[i] + j) f[i][j] = max(f[i][j], f[k][l] + 1);
```
条件中的 $k<i$ 其实可以先不用管，看到 $l\le j,a_k+l\le a_i+j$ 明显是个二维的前缀和，于是就可以用二维的树状数组来维护。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 10005;

int n, K, m, a[N], f[N][505], c[5505][505];

inline void add(const int &x, const int &y, const int &d) {
	for (int i = x; i <= m; i += i & ~i + 1)
		for (int j = y; j <= K + 1; j += j & ~j + 1) c[i][j] = max(c[i][j], d);
}
inline int ask(const int &x, const int &y) {
	int res = 0;
	for (int i = x; i; i &= i - 1)
		for (int j = y; j; j &= j - 1) res = max(res, c[i][j]);
	return res;
}

int main() {
	scanf("%d%d", &n, &K);
	for (int i = 1; i <= n; ++i) scanf("%d", &a[i]), m = max(m, a[i]); m += K;
	for (int i = 1; i <= n; ++i)
		for (int j = K; ~j; --j)//这里注意要倒着循环，因为小的j的更新会影响到大的。
			add(a[i] + j, j + 1, f[i][j] = ask(a[i] + j, j + 1) + 1);
	printf("%d", ask(m, K + 1));
	return 0;
}
```
时间复杂度 $O(nk\log k \log(k+\max a_i))$。其实这样就能 AC 了，但是还能优化。

可以发现在求二维前缀和时，每一行从左到右是单调不降的，每一列从上到下也是单调不降的。所以对于 $f(i,j)$ 最大值只会在第 $a_i+j$ 行和第 $j$ 列里，于是只用建一个 $k+\max a_i$ 行和一个 $k$ 行的一维树状数组记一下此行和此列的最大值进行更新转移就行了。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 10005;

int n, K, m, a[N], c[2][5505][505];

inline void add(const int &x, const int &y, const int &d) {
	for (int i = x; i <= m; i += i & ~i + 1) c[0][i][y] = max(c[0][i][y], d);
	for (int i = y; i <= K + 1; i += i & ~i + 1) c[1][x][i] = max(c[1][x][i], d);
}
inline int ask(const int &x, const int &y) {
	int res = 0;
	for (int i = x; i; i &= i - 1) res = max(res, c[0][i][y]);
	for (int i = y; i; i &= i - 1) res = max(res, c[1][x][i]);
	return res;
}

int main() {
	scanf("%d%d", &n, &K);
	for (int i = 1; i <= n; ++i) scanf("%d", &a[i]), m = max(m, a[i]); m += K;
	for (int i = 1; i <= n; ++i)
		for (int j = K; ~j; --j)//这里正序倒序循环都没关系
			add(a[i] + j, j + 1, ask(a[i] + j, j + 1) + 1);
	printf("%d", ask(m, K + 1));
	return 0;
}
```
时间复杂度 $O(nk\log(k+\max a_i))$。

---

## 作者：404Not_Found (赞：0)

发现了重要性质不会设状态，看了题解才明白（我太蒻了）。

结论：每次一定拔高 $[i,n]$ 的一段区间。

设 $f(i,j)$ 表示以 $i$ 结尾拔高 $j$ 次 $[1,n]$ 最长不降子序列的长度，可以暴力转移：

$$f(i,j)=\max_{1 \le k < i,0 \le l \le j,h_k+l \le h_i+j}f(k,l)+1$$

时间复杂度 $O(n^2k^2)$，一个点都过不了。

考虑优化，发现这个转移可以看做求一个三维前缀最大值，可以枚举 $i$ 消除一个限制，然后用二维树状数组优化。

可以修改一下状态，设 $f(j,k)$ 为 $[1,i-1]$ 中拔高不超过 $j$ 次且结尾 $\le k$ 的最长不降子序列长度，这个很容易用树状数组维护了。注意到 $j$ 可以为 $0$，可以将 $j$ 整体后移一位。

还有一个问题，$f$ 数组可能会重复更新，可以用 01 背包的思想逆序枚举 $j$，就没有问题了。

时间复杂度 $O(nk \log n \log k)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 6e4+5;
int c[505][6005],n,k,mx,h[10005],ans;
#define lowbit(x) (x&-x)
void add(int x,int y,int v){for(int i=x;i<=k+1;i+=lowbit(i)) for(int j=y;j<=k+mx;j+=lowbit(j)) c[i][j]=max(c[i][j],v);}
int query(int x,int y){int ret=0;for(int i=x;i;i-=lowbit(i)) for(int j=y;j;j-=lowbit(j)) ret=max(ret,c[i][j]); return ret;}
int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++) scanf("%d",&h[i]),mx=max(mx,h[i]);
	for(int i=1;i<=n;i++)
		for(int j=k;j>=0;j--)
		{
			int t=query(j+1,h[i]+j)+1;
			add(j+1,h[i]+j,t);
			ans=max(ans,t);
		}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：_Imaginary_ (赞：0)

首先，我们会发现一个很重要的事情。

假设我们令 $[L,R]$ 表示一个操作，

那我们可以将所有的操作都改成 $[L,n]$ 并且所有操作结束后的最长不降子序列长度不减。

（这里 $n$ 指的是最右侧的玉米编号）

证明：这样操作以后，越靠右的操作次数越大。

所以原来操作完的最长不降子序列在靠右的地方会增加更多，还是一个满足的子序列。

因此，我们让每个操作都是对于后缀操作的。

令 $f(i,j)$ 表示拔 j 次，考虑到 i 的最长 LIS 的元素个数。

$$
f(i,j)=\max f(p,q)+1
$$

同时 p 和 q 都有一个长方形的范围。

我们把每一个对应的函数值想象成一个点，则找的 f 的范围就是一个长方形，用二维树状数组维护。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=10005,M=5500,K=6500;
int n,k;
int a[N];
int c[M+5][K+5];
void add(int x,int y,int add)
{
	for(int xx=x;xx<=M;xx+=xx&(-xx))
		for(int yy=y;yy<=K;yy+=yy&(-yy))
			c[xx][yy]=max(c[xx][yy],add);
}
int mx(int xx,int yy)
{
	int ans=0;
	for(int x=xx;x;x-=x&(-x))
		for(int y=yy;y;y-=y&(-y))
			ans=max(ans,c[x][y]);
	return ans;
}
int f[N][K+5];
int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	int ans=0;
	for(int i=1;i<=n;i++)
		for(int j=k;j>=0;j--)
		{
			f[i][j]=mx(j+1,a[i]+j)+1;
			ans=max(ans,f[i][j]);
			add(j+1,a[i]+j,f[i][j]);
		}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：ListenSnow (赞：0)

[原题链接](https://www.luogu.com.cn/problem/P3287)


## 题意

给定一个长度为 $n$ 的序列 $a$，最多可以执行 $k$ 次将一个区间 $[l,r]$ 中的数每一个数都增加 $1$，求最终可以得到的最长不下降子序列的长度最大值。

#### 数据范围

$1 <n \leq 10000,1 \leq k \leq 500,1 \leq a_i \leq 5000$。

### 思路

首先不难发现本题中的一个性质，每一次修改操作的右端点 $r=n$。这是因为每次都把右边的数都 $+1$，并不会导致答案的长度减小。而如果把右边的数都增加了，那么这个子序列就有可能接到前面的一个子序列后面，就会使答案变大。故每次右端点都选 $n$ 不会使答案减小。

设 $f[i][j]$ 表示以 $i$ 结尾的使用了 $j$ 次修改（每次修改的 $l \leq i,r=n$）的最长不下降子序列的长度。考虑枚举将 $i$ 接到前面的子序列后面，就可以得到朴素的状态转移方程：

$f[i][j]=max(f[i][j],f[x][y])$，其中 $x \leq i,y\leq j$，同时也需要满足 $(a[j]+y \leq a[i]+j)$ （有$j-y$ 次操作以 $i$ 为左端点，区间中不包括 $j$）。

这个转移的时间复杂度是 $O(n^2k^2)$ 的，~~非常~~需要优化。

注意到转移中是取最大值，那么就可以考虑用一种数据结构来记录区间内的最大值。

由于 $i$ 顺序枚举，所以 $x \leq i$ 可以直接满足。而对于额外的高度要求，可以看成是以 $a[j]+y$ 结尾的子序列。那么就只需要快速查询出所有满足 $a[j]+y \leq a[i]+j,y \leq j$ 中的最大值。

由于所有操作都是单点修改，可以考虑用**二维树状数组**来实现（具体实现方法看代码比较好理解）。那么时间复杂度就可以降低到 $O(n k \log nk)$。可以通过本题。

### code：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=10010;
const int M=5550;
const int K=521;
const int INF=0x3f3f3f3f;
int f[N][K],n,k,a[N],c[M][K];//第一维表示最右边的高度，第二维表示修改次数 
int lowbit(int x){return x&(-x);}
void updata(int x,int y,int val)
{
	for(int i=x;i<=5500;i+=lowbit(i)) //枚举到最大可能高度 
	    for(int j=y;j<=k+1;j+=lowbit(j)) //由于修改次数可能为0，所以需要将次数+1才能用树状数组 
	        c[i][j]=max(c[i][j],val);
}
int query(int x,int y)
{
	int res=0;
	for(int i=x;i;i-=lowbit(i))
	    for(int j=y;j;j-=lowbit(j))
	        res=max(res,c[i][j]);
	return res;
}
int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<=n;i++)
	    for(int j=k;j>=0;j--)
	    {
	    	f[i][j]=query(a[i]+j,j+1)+1;//这两行的+1都是为了防止修改0次而死循环 
	    	updata(a[i]+j,j+1,f[i][j]);//表示更新一个修改了j次，右端点为a[i]+j，长度为 f[i][j] 的序列 
		}
	printf("%d\n",query(5500,k+1));//最后的答案是所有可能答案的最大值，不一定以最后一数为右端点 
	return 0;
}
```


---

## 作者：muller (赞：0)

这题我们可以找规律

发现选的区间右端点一定是n

然后完了，随便乱搞一发

发现T了

啊！4方复杂度，直接优化

上树状数组

注意一些条件，以及题目中有0所以树状数组要向后移一位

注意细节即可！

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 100005, K = 505;
int n, k, ans, mx, a[N];
template <class T> void cmax(T &x, T y) {x = x > y ? x : y;}
template <class T> void cmin(T &x, T y) {x = x < y ? x : y;}
template <class T> void rd(T &x) {
	char c = getchar(); int f = 1; x = 0;
	for (; !isdigit(c); c = getchar()) if (c == '-') f = -1;
	for (; isdigit(c); c = getchar()) x = x * 10 + c - '0';
	x *= f;
}
struct Binary_Index_Tree {
	#define lowbit(x) x & -x
	int c[N][K];
	void modify(int x, int y, int p) {
		int i, j;
		for (i = x; i <= mx + k; i += lowbit(i))
			for (j = y; j <= k + 1; j += lowbit(j)) cmax(c[i][j], p);
	}
	int query(int x, int y) {
		int i, j, res = 0;
		for (i = x; i; i -= lowbit(i))
			for (j = y; j; j -= lowbit(j)) cmax(res, c[i][j]);
		return res;
	}
} T;
int main() {
	int i, j; rd(n); rd(k);
	for (i = 1; i <= n; ++i) rd(a[i]), cmax(mx, a[i]);
	for (i = 1; i <= n; ++i)
		for (j = k; ~j; --j) {
			int x = T.query(a[i] + j, j + 1) + 1;
			cmax(ans, x), T.modify(a[i] + j, j + 1, x);
		}
	printf("%d\n", ans);
	return 0;
}

```

---


# [POI 2015] LOG

## 题目描述

维护一个长度为 $n$ 的序列，一开始都是 $0$，支持以下两种操作：

1. `U k a` 将序列中第 $k$ 个数修改为 $a$。
2. `Z c s` 在这个序列上，每次选出 $c$ 个正数，并将它们都减去 $1$，询问能否进行 $s$ 次操作。

每次询问独立，即每次询问不会对序列进行修改。


## 说明/提示

**【数据范围】**

对于 $100\%$ 的数据，$1\leq n,m\leq 10^6$，$1\leq k,c\leq n$，$0\leq a\leq 10^9$，$1\leq s\leq 10^9$。

----

原题名称：Logistyka。

## 样例 #1

### 输入

```
3 8
U 1 5
U 2 7
Z 2 6
U 3 1
Z 2 6
U 2 2
Z 2 6
Z 2 1
```

### 输出

```
NIE
TAK
NIE
TAK
```

# 题解

## 作者：BearBrine (赞：168)

[1]: https://cdn.luogu.com.cn/upload/image_hosting/rbryza1t.png
[2]: https://cdn.luogu.com.cn/upload/image_hosting/4v52q1em.png
[3]: https://cdn.luogu.com.cn/upload/image_hosting/1yiqjwf6.png
[4]: https://cdn.luogu.com.cn/upload/image_hosting/a7nkn0ec.png
[5]: https://cdn.luogu.com.cn/upload/image_hosting/5o4u7lct.png
[6]: https://cdn.luogu.com.cn/upload/image_hosting/naq4169d.png

来一发比较好理解的题解。首先把题目想象成叠馒头，有 $n$ 种不同的馒头，

![1]

那么询问就变成了每次从不同的 $c$ 种馒头里各取一个，问能否取 $s$ 次。

由于每种馒头最多取 $s$ 个，于是考虑把多于 $s$ 的馒头削成 $s$ 个。

![2] ![3]

于是我们尝试把剩下的馒头构造成高为 $s$ 的 $c$ 叠馒头，然后从上往下一层一层拿就好了。

![4]

但是题目要求每次拿的馒头不能出现同种的，也就是**每层不能有同种的馒头**，所以上面这种叠法其实是不可行的。

**注意到每种馒头最多有 $s$ 个**，于是我们把每一叠的馒头叠到它左边那叠上面，剩下的再自成一叠。

![5]

于是这样每层馒头都不会出现同种的，并且每个馒头都能被利用上。

那么**只要馒头的数量够 $c \times s$ 就一定能构造出 $c$ 叠高为 $s$ 的每层各不同的馒头**。

于是问题变成削掉比 $s$ 高的部分的馒头后，剩下的够不够 $c \times s$ 个。

那么怎么求高出来的那部分馒头的数量？

很显然就是每个有高出来的馒头去掉它下面的 $s$ 个馒头，剩下的馒头数的和。

![6]

所以只要知道大于 $s$ 的馒头的种类数与数量和就行了。

当然你也可以反过来求小于等于 $s$ 的馒头数和种类数。

显然在线[平衡树](https://www.luogu.com.cn/record/44211981)，或者离线[树状数组](https://www.luogu.com.cn/record/44212900)就解决了。

话说这题平衡树（目前最快）好像跑的比树状数组还快QAQ ~~（可能我树状数组写丑了）~~

树状数组：

``` cpp
#include <cstdio>
#include <algorithm>
#define LL long long

char ch, sig;
template <typename _tp>
inline void rd(_tp &num)
{
    num = 0, sig = 1, ch = getchar();
    while(ch < '0' || ch > '9') {
        if(ch == '-') sig = -1;
        ch = getchar();
    }
    do{
        num = num * 10 + ch - '0';
        ch = getchar();
    }while(ch >= '0' && ch <= '9');
    num *= sig;
}

// -------------------- 上板子下正片 -------------------- //

#define MAXN 1000005

int n, m;
LL tr1[MAXN], tr2[MAXN]; //tr1是数量和，tr2是种类数
#define lowbit(x) ((~(x) + 1) & x)
inline void tradd(LL *tr, int p, int num){
    while(p <= m + 1) tr[p] += num, p += lowbit(p);
}
inline LL trqry(LL *tr, int p){
    LL sum = 0;
    while(p) sum += tr[p], p ^= lowbit(p);
    return sum;
}
char op[MAXN];
int t1[MAXN], t2[MAXN], ts[MAXN];
int bsearch(int num){ //离散化查询
    int l = 1, r = m + 1, mid;
    while(l < r){
        mid = (l + r) >> 1;
        if(ts[mid] < num) l = mid + 1;
        else if(ts[mid] > num) r = mid - 1;
        else return mid;
    }
    return l;
}
int arr[MAXN];

int main()
{
    rd(n), rd(m);
    for(int i = 1; i <= m; ++i) {
        do ch = getchar(); while(ch != 'U' && ch != 'Z');
        op[i] = ch; rd(t1[i]), rd(t2[i]); ts[i] = t2[i];
    }
    ts[m + 1] = 0;
    std::sort(ts + 1, ts + m + 2); //离散化
    for(int i = 1; i <= m + 1; ++i) arr[i] = 1;
    int tbs = bsearch(0); LL tmp;
    tradd(tr2, tbs, n);
    tradd(tr2, tbs + 1, -n);
    for(int i = 1; i <= m; ++i)
    if(op[i] == 'U') {
        tbs = bsearch(t2[i]);
        tradd(tr1, arr[t1[i]], -ts[arr[t1[i]]]);
        tradd(tr1, tbs, ts[tbs]);
        tradd(tr2, arr[t1[i]] + 1, 1);
        tradd(tr2, tbs + 1, -1);
        arr[t1[i]] = tbs;
    } else {
        tbs = bsearch(t2[i]);
        tmp = (t1[i] - trqry(tr2, tbs)) * t2[i];
        printf("%s\n", trqry(tr1, tbs - 1) >= tmp ? "TAK" : "NIE");
    }

    return 0;
}
```

平衡树：

``` cpp
#include <cstdio>
#include <cctype>
#include <algorithm>
#define uint unsigned int
#define uLL unsigned long long

#define mmin(A, B) (((A) < (B)) ? (A) : (B))
#define mmax(A, B) (((A) > (B)) ? (A) : (B))

struct quickio 
{
    char ch, sig;
    
    template <typename _tp>
    inline quickio& operator >> (_tp &num) {
        num = 0, sig = 1, ch = getchar();
        while(ch < '0' || ch > '9') {
            if(ch == '-') sig = -1;
            ch = getchar();
        }
        do {
            num = num * 10 + ch - '0';
            ch = getchar();
        } while(ch >= '0' && ch <= '9');
        num *= sig;
        return *this;
    }
    inline quickio& operator >> (char &tc) {
        do tc = getchar(); while(isspace(tc));
        return *this;
    }

    inline quickio& operator << (char *ts) {
        while(*ts != '\0') putchar(*(ts++));
        return *this;
    }
} qio;

// -------------------- 上板子下正片 -------------------- //

#define MAXN 1000005

uint n, m;

inline void Change();
inline void Query();

int main()
{
    qio >> n >> m;
    char tc;
    while(m--) {
        qio >> tc;
        switch (tc)
        {
        case 'U': Change(); break;
        case 'Z': Query(); break;
        
        default:
            break;
        }
    }

    return 0;
}

uint ar[MAXN], acnt = 0;
//写的AVL树
struct node { 
    uint ln, rn;
    uint siz, cnt, h;
    uint val;
    uLL sum;
} bst[MAXN]; 
uint bcnt = 0, rt = 0;
//左儿子右也是儿子
#define ls(A) (bst[A].ln)
#define rs(A) (bst[A].rn)

inline uint newnode() {
    ++bcnt;
    ls(bcnt) = rs(bcnt) = 0;
    bst[bcnt].siz = bst[bcnt].cnt = 1;
    bst[bcnt].h = 1;
    return bcnt;
}
inline void update(uint p) { //更新节点
    bst[p].siz = bst[ls(p)].siz + bst[rs(p)].siz + bst[p].cnt;
    bst[p].h = mmax(bst[ls(p)].h, bst[rs(p)].h) + 1;
    bst[p].sum = bst[ls(p)].sum + bst[rs(p)].sum + (uLL)bst[p].val * bst[p].cnt;
}

inline void rotate(uint p, bool rr) {
    uint tp;
    if(rr) {
        tp = ls(p);
        ls(p) = ls(tp);
        ls(tp) = rs(tp);
        rs(tp) = rs(p);
        rs(p) = tp;
    } else {
        tp = rs(p);
        rs(p) = rs(tp);
        rs(tp) = ls(tp);
        ls(tp) = ls(p);
        ls(p) = tp;
    }
    std::swap(bst[p].cnt, bst[tp].cnt);
    std::swap(bst[p].val, bst[tp].val);
    update(tp), update(p);
}

inline void maintain(uint p) {
    if(bst[ls(p)].h > bst[rs(p)].h + 1) { //uint不能直接相减，惨痛的教训QwQ
        if(bst[ls(ls(p))].h < bst[rs(ls(p))].h) 
            rotate(ls(p), false);
        rotate(p, true);
    } else if(bst[rs(p)].h > bst[ls(p)].h + 1) {
        if(bst[rs(rs(p))].h < bst[ls(rs(p))].h)
            rotate(rs(p), true);
        rotate(p, false);
    } else update(p);
}
void doInsert(uint val, uint p = rt) { //插入
    uint *tp = &p;
    if(val < bst[p].val) tp = &ls(p);
    else if(bst[p].val < val) tp = &rs(p);
    if(*tp == p) ++bst[p].cnt, update(p);
    else if(!(*tp)) {
        *tp = newnode();
        bst[*tp].val = bst[*tp].sum = val;
        update(p);
    } else doInsert(val, *tp), maintain(p);
}
void doDelete(uint val, uint p = rt) { //偷懒版删除qwq
    uint *tp = &p;
    if(val < bst[p].val) tp = &ls(p);
    else if(bst[p].val < val) tp = &rs(p);
    if(*tp == p) --bst[p].cnt, update(p);
    else doDelete(val, *tp), update(p);
}
void getInfo(uint val, uint &rk, uLL &sum, uint p = rt) { //获取排名与和
    if(!p) return;
    if(val < bst[p].val) getInfo(val, rk, sum, ls(p));
    else { 
        rk += bst[p].cnt + bst[ls(p)].siz;
        sum += (uLL)bst[p].val * bst[p].cnt + bst[ls(p)].sum;
        getInfo(val, rk, sum, rs(p));
    }
}

inline void Change() {
    uint tp, tn;
    qio >> tp >> tn;
    if(ar[tp]) doDelete(ar[tp]), --acnt;
    ar[tp] = tn;
    if(tn) {
        if(!rt) {
            rt = newnode();
            bst[rt].val = bst[rt].sum = tn;
        } else doInsert(tn);
        ++acnt;
    }
}
inline void Query() {
    uint tc, ts;
    qio >> tc >> ts;
    uint tnum = 0; uLL tsum = 0;
    getInfo(ts, tnum, tsum);
    if(tsum + (uLL)(acnt - tnum) * ts >= (uLL)tc * ts)
        qio << "TAK\n";
    else qio << "NIE\n";
}
```

---

## 作者：Asuka二号机 (赞：84)

为什么没有人口胡这个结论

是不是全世界除了我都能一眼看出结论

我们看这个判定

每次挑c个数-1,搞s次

你大笔一挥说 吼啊如果加起来能过就能过！

显然胡说八道，你胡乱搞个数据就能hack

4 1 1 每次挑三个搞两次 你以为你能过其实并不能

好那我们开始认真做题

### 先处理一些显然的事情

显然如果一些数>=s那么比较好，假定它们的数量为cnt,显然这cnt个数，它们在s轮中每一轮都会被选中，并且每一轮内它们都对答案贡献了cnt。

即使它们的值很大很大大到INF都没有什么用，能贡献的都贡献完了，就可以不看它们。

那问题就变成了刨掉这些>=s的数之后剩下这一堆数能不能在s轮里，每一轮都找出c-cnt个来操作。我们说这堆数有n个

这看上去很不可求

### 猜一个看上去有效的结论

你还记得我们一开始口胡了一个什么结论吗？

n*s>=(c-cnt)*s 就可过

当然每个数都<=s

你构造了很久的hack数据发现好像是这么回事

那可以试着证一下

### 贪心地搞一个实现结论的方法

我们假定每次都取最大的c-cnt个值，这样去做s轮。听上去非常有道理，因为大的都被砍掉变小了这听上去相当平均

你又构造数据发现看上去很有道理

### 用构造方法反证结论

考虑反证法。如果此刻是第k轮，任务没有完成，剩下了一些正数a1 ... a(c-cnt-p)我们搞不下去了怎么办

那我们考虑还原上一轮的情况。显然，因为这是操作过来的，所以上一轮的数量必然是对的。

首先可以确定，在k-1轮必然是本轮的一堆数全+1，以及p个1。这个很显然，因为我们是贪心选取的，所以如果有更多的别的选择的话1根本就不会被消掉。

那么我们还原出的序列就是
 p个1 a1+1 a2+1 ... a(c-cnt-p)+1，在k-1轮它们全都被操作了一顿。
 
 继续往前推，我们发现，在手头有了这么个序列之后，实际上可以反推出所有的情况——因为这个序列绝对最大，而且一直最大，在之前的操作中必然是这些数被操作——只有比较大的数被变成这个序列可能的样子，而不可能更小。
 
 再反推，我们推回了初始情况。p个k a1+k ... a(c-cnt-p)+k
 
 大声告诉我你发现了什么
 
 你发现n==c-cnt

所以这些数里的任何一个数大于等于s的时候，显然就矛盾了
 
 所以它们每个数都小于s 那么它们加起来<(c-cnt)*s
 
 这不是早就被跳掉了吗 
 
 显然矛盾
 
 证明结束
 
 ### 搞个数据结构维护它
 
 你每次快乐询问
 
 大于s的数有多少个
 
 以及小于s的数的和
 
 看看行不行
 
 显然树状数组最好写
 
 别忘了long long
 
 离散化防爆炸啥的常规操作
 
 搞出结论这题就很傻 
 
 不给代码
 

---

## 作者：hongzy (赞：44)

这题序列可以看做一个集合，因为答案和位置无关。

设$\geq s$的数有$x$个，$<s$的数和为$sum$，能够成功应该满足$sum\geq(c-x)*s$。如果不满足显然不行，满足后要证明每次取有至少$c$个数。

考虑$<s$的数和为$sum$，最少的时候有$\lceil \frac{sum}{s-1}\rceil$个数，如果满足$sum\geq(c-x)*s$，则$\lceil \frac{sum}{s-1}\rceil>c-x$，此时一定有解.

做法1：使用splay维护这个集合（是在线的），记录sz和s分别表示子树大小和子树权值和，支持询问$<x$的数个数与$\geq x$的数之和。直接求前驱、后继做，具体可以见代码。

```cpp
#include <algorithm>
#include <cstdio>
using namespace std;

typedef long long ll;

const int N = 1e6 + 10;

int n, m, rt, id, vis, a[N];
int ch[N][2], fa[N], cnt[N], val[N], sz[N];
ll s[N];
 
int dir(int u) { return ch[fa[u]][1] == u; }
void upd(int u) {
	s[u] = s[ch[u][0]] + s[ch[u][1]] + cnt[u] * val[u];
	sz[u] = sz[ch[u][0]] + sz[ch[u][1]] + cnt[u];
}
void rotate(int u) {
	int d = dir(u), f = fa[u];
	if(fa[u] = fa[f]) ch[fa[u]][dir(f)] = u;
	if(ch[f][d] = ch[u][d ^ 1]) fa[ch[f][d]] = f;
	fa[ch[u][d ^ 1] = f] = u;
	upd(f), upd(u);
}
void splay(int u, int f = 0) {
	for(; fa[u] != f; rotate(u)) if(fa[fa[u]] != f)
		rotate(dir(u) == dir(fa[u]) ? fa[u] : u);
	if(!f) rt = u;
}
void ins(int &rt, int x, int f) {
	if(!rt) {
		rt = ++ id; val[rt] = x; fa[rt] = f; 
		sz[rt] = cnt[vis = rt] = 1;
		return ;
	}
	if(x == val[rt]) cnt[vis = rt] ++;
	else ins(ch[rt][x > val[rt]], x, rt);
	upd(rt);
}
void ins(int x) { ins(rt, x, 0); splay(vis); }
int find(int x) {
	int o = rt;
	while(val[o] != x && ch[o][x > val[o]])
		o = ch[o][x > val[o]];
	splay(o);
	return o;
}
int pre(int x) {
	int o = find(x);
	if(val[o] < x) return o;
	for(o = ch[o][0]; ch[o][1]; o = ch[o][1]) ;
	return o;
}
int nxt(int x) {
	int o = find(x);
	if(val[o] > x) return o;
	for(o = ch[o][1]; ch[o][0]; o = ch[o][0]) ;
	return o;
}
void del(int x) {
	int l = pre(x), r = nxt(x);
	splay(r); splay(l, r);
	int &o = ch[l][1];
	if(cnt[o] > 1) {
		cnt[o] --; upd(o); splay(o);
	} else o = 0, upd(l), upd(r);
}
int main() {
	ins(0); ins(2e9);
	scanf("%d%d", &n, &m);
	fill(a + 1, a + n + 1, -1);
	char op[5];
	for(int i = 1, c, s; i <= m; i ++) {
		scanf("%s%d%d", op, &c, &s);
		if(* op == 'U') {
			if(~ a[c]) del(a[c]);
			ins(a[c] = s);
		}
		if(* op == 'Z') {
			int p = pre(s), q = nxt(s); splay(p);
			ll sum = :: s[p] - :: s[ch[p][1]];
			splay(q, p);
			int x = 0;
			if(ch[q][0]) x += cnt[ch[q][0]];
			splay(q);
			x += sz[q] - sz[ch[q][0]] - 1;
			puts(sum >= (c - x) * 1ll * s ? "TAK" : "NIE");
		}
	}
	return 0;
}
```

做法2：动态开点线段树

```cpp
#include <algorithm>
#include <cstdio>
using namespace std;

typedef long long ll;

const int N = 1e6 + 10;

int n, m, id, a[N], ro;
int ls[N << 5], rs[N << 5], sz[N << 5];
ll s[N << 5];

void modify(int &u, int l, int r, int x, int y) {
	if(!u) u = ++ id;
	if(l == r) { sz[u] += y; s[u] += y * l; return ; }
	int mid = (l + r) >> 1; 
	if(x <= mid) modify(ls[u], l, mid, x, y);
	else modify(rs[u], mid + 1, r, x, y);
	sz[u] = sz[ls[u]] + sz[rs[u]];
	s[u] = s[ls[u]] + s[rs[u]];
} 

ll querys(int u, int l, int r, int ql, int qr) {
	if(!u || l > qr || r < ql) return 0ll;
	if(ql <= l && r <= qr) return s[u];
	int mid = (l + r) >> 1;
	return querys(ls[u], l, mid, ql, qr)
	+ querys(rs[u], mid + 1, r, ql, qr);
}

int querysz(int u, int l, int r, int ql, int qr) {
	if(!u || l > qr || r < ql) return 0;
	if(ql <= l && r <= qr) return sz[u];
	int mid = (l + r) >> 1;
	return querysz(ls[u], l, mid, ql, qr)
	+ querysz(rs[u], mid + 1, r, ql, qr);
}

int main() {
	scanf("%d%d", &n, &m);
	const int L = 1e9 + 5;
	char op[5];
	modify(ro, 0, L, 0, n);
	int x; ll sum;
	for(int i = 1, c, s; i <= m; i ++) {
		scanf("%s%d%d", op, &c, &s);
		if(* op == 'U') {
			modify(ro, 0, L, a[c], -1);
			modify(ro, 0, L, a[c] = s, 1);
		}
		if(* op == 'Z') {
			x = querysz(ro, 0, L, s, L);
			sum = s ? querys(ro, 0, L, 0, s - 1) : 0;
			puts(sum >= (c - x) * 1ll * s ? "TAK" : "NIE");
		}
	}
	return 0;
}
```

做法3：离线下来做，离散化+树状数组

```cpp
#include <algorithm>
#include <cctype>
#include <cstdio>
using namespace std;

typedef long long ll;

int read() {
     int x = 0; char c = getchar();
     for(; !isdigit(c); c = getchar());
     for(; isdigit(c); c = getchar())
     	x = x * 10 + (c & 15);
     return x;
}

const int N = 1e6 + 10;

int n, m, a[N], opt[N], c[N], s[N];
int num[N], p;
int bit[N];
ll bit2[N];

void add(int x, int y) { for(; x <= p; x += x & (-x)) bit[x] += y; }
void add2(int x, int y) { for(; x <= p; x += x & (-x)) bit2[x] += y; }
int qry(int x) { int a = 0; for(; x >= 1; x &= x - 1) a += bit[x]; return a; }
ll qry2(int x) { ll a = 0; for(; x >= 1; x &= x - 1) a += bit2[x]; return a; }

int main() {
	scanf("%d%d", &n, &m);
	char op[5]; ll sum;
	num[++ p] = 0;
	for(int i = 1; i <= m; i ++) {
		scanf("%s", op);
		c[i] = read();
		s[i] = read();
		num[++ p] = s[i];
		if(* op == 'U') opt[i] = 1;
		if(* op == 'Z') opt[i] = 2;
	}
	sort(num + 1, num + p + 1);
	p = unique(num + 1, num + p + 1) - num - 1;
	for(int x, i = 1; i <= m; i ++) {
		s[i] = lower_bound(num + 1, num + p + 1, s[i]) - num;
		if(opt[i] == 1) {
			if(x = a[c[i]]) {
				add(x, -1);
				add2(x, -num[x]);
			}
			x = a[c[i]] = s[i];
			add(x, 1);
			add2(x, num[x]);
		}
		if(opt[i] == 2) {
			x = qry(p) - qry(s[i] - 1);
			sum = s ? qry2(s[i] - 1) : 0;
			puts(sum >= (c[i] - x) * 1ll * num[s[i]] ? "TAK" : "NIE");
		}
	}
	return 0;
}
```

---

## 作者：Chieflsh (赞：39)

   在浏览题解的过程中，我发现大部分题解对于此题的核心结论的证明都比较粗略。因此，在这篇题解中，我将详细证明这一结论：
   
**在自然数序列 $\{a_n\}$ 上进行 $s$ 次操作：每次选择其中 $c$ 个非零数，将它们都减去 $1$。记序列中大于等于 $s$ 的数的个数为 $cnt$，小于 $s$ 的数的和为 $sum$。求证：**

**$sum \geqslant s(c-cnt)$ 是该序列能进行s次操作的充分必要条件。**


------------
### PART 1 充分性证明
非常显然。为了能够使操作次数尽量多，这 $cnt$ 个大于等于 $s$ 的数每次都会用上，则每次操作只需要在剩下的数中选出 $c-cnt$ 个，$s$ 次操作一共在剩下的数中减去了 $s(c-cnt)$ 的值。剩下的数的和 $sum$ 必然有 $sum \geqslant s(c-cnt)$。

------------
### PART 2 必要性证明
 $sum \geqslant s(c-cnt)$ 时，是否一定能进行 $s$ 次操作？
 
证明方法：数学归纳法。

不考虑那 $cnt$ 个大于等于 $s$ 的数，剩下 $m=n-cnt$ 个数构成另一序列 $\{b_m\}$，$s$ 次操作每次只需从中取出 $d=c-cnt$ 个非零数减去 $1$。我们要证明的结论就等价于：

**已知序列 $\{b_m\}$ 的m个元素之和 $sum \geqslant s\times d$，且对于任意元素都有 $b_i<s$。每次操作从中取出 $d$ 个非零数减去 $1$。求证：能够进行至少 $s$ 次这样的操作。即：$s$ 次的每次操作前，序列中都有至少 $d$ 个元素大于 $0$。**

第一步首先证明：**第一次操作之前序列中有至少 $d$ 个元素大于 $0$。**

使用反证法：假如序列中只有 $d'<d$ 个非零数。这 $d'$ 个数都小于 $s$，其它数都为 $0$，则序列中所有数的和 $sum'<d'\times s<d\times s \leqslant sum$，出现矛盾。得证。


接下来开始**递推归纳**:

第一次操作之后，我们还需进行 $s'=s-1$ 次操作，而本次操作后得到的新序列的元素之和 $sum'=sum-d\geqslant (s-1)\times d$，即有 $sum' \geqslant s'\times d$。我们把下一次操作看成对于这个新序列的第一次操作，我们就回到了第一步。

但我们还不能直接用第一步证明的结论，因为两个问题的条件不完全相同：新序列上并不能保证**对于任意元素都有 $b_i<s'$**。如何解决？

注意到：操作后新序列中不满足 $b_i<s'=s-1$ 的元素，一定是操作前序列中大小为 $s-1$ ，且本次操作没有被选中减去 $1$ 的元素。

对于每一次操作，我们的选取策略是：每次在操作前序列中选出**最大**的 $d$ 个数减去 $1$。记在操作前序列中大小为 $s-1$ 的元素个数为 $x$。这种策略之下，若 $x\leqslant d$，则这 $x$ 个数都能被选中并减去 $1$;

若 $x>d$，我们会剩下 $y=x-d$ 个元素不满足 $b_i<s'$。不过这 $y$ 个元素都恰好等于 $s'$，我们可以把它们看做在最初的问题上那些大于等于 $s'$ 的、每次操作都会用到的元素，并再次将它们从序列中除去，得到新的序列 $\{p_{m-y}\}$。序列 $\{p_{m-y}\}$ 满足所有元素都小于 $s'$。

于是，在以后的每一次操作中，我们每次只用再选取 $d'=d-y$ 个元素，除去那 $y$ 个元素后，序列 $p$ 的元素之和 $sump$ 有：$sump=sum'-y\times s' \geqslant s'\times d-y\times s' =s'\times (d-y)$；

而 $s'\times d'=s'\times (d-y)$，满足 $sump\geqslant s'\times d'$。

到此，我们的问题转化成了：

**已知序列 $\{p_{m-y}\}$ 的 $m-y$ 个元素之和 $sump \geqslant s'\times d'$，且对于任意元素都有 $p_i<s'$。 每次操作从中取出 $d'$ 个非零数减去 $1$。证明：在该序列上能进行 $s'$ 次操作。**

这时我们便可以借助第一步的证明，再进行一次操作，使 $s'$ 变成 $s'-1$ 。用类似的方式转化问题，$s'$ 不断减小，直到为 $0$，我们的归纳证明就完成了。


------------

### 后记
关于此题，大家还可以看看[P5815扑克牌](https://www.luogu.com.cn/problem/P5815)，它实质上是本题中每次询问时 $c=n-1$ 的特殊情况。不过那一题问的是 最多进行多少次操作 ，而对于这类问题，我们更擅长对答案的判定，因而有了二分答案的做法。

本题解侧重于数学证明。然而在实际做题时，我们难以猜出结论并完全证明，因而本题解仅作学术参考为宜。

蒟蒻的第一篇题解，难免有疏漏之处，祈请各位读者不吝指正。




---

## 作者：HTensor (赞：30)

提供一个简明的关键性质证法。

性质：对于每次询问，设大于 $s$ 的数有 $x$ 个，小于 $s$ 的数和为 $sum$ ，若 $sum \geq (c-x) \times s$ 则有解，否则无解。

证明：

原问题等价于构造 $s$ 个长度为 $c$ 的数列，数列中数字的意义为被减 $1$ 的元素下标，规定每个数列中不能有重复数字，值为 $a_i$ 的元素下标最多在 $a_i$ 个数列中出现。

显然地，若 $a_i \geq s$ 我们可以让第 $i$ 个元素在所有数列中全部出现。

对于剩下的空位置，对于所有的 $a_i < s$ 可以填入 $\sum a_i$ 次。即 $sum$ 次。

证毕。

---

## 作者：brealid (赞：20)

$TAG_{\texttt{这道题主要考查的知识点}}=\texttt{o|离散化},\ \ \texttt{o|树状数组}$

约定：以下 $k,a,c,s$ 为题目义  
即 : 
- $k$ 表示操作 $U$ 的操作位置    
- $a$ 表示操作 $U$ 的操作参数    
- $c$ 表示操作 $Z$ 每次操作选出的数的个数    
- $s$ 表示操作 $Z$ 的操作次数  

## 主要思路

首先看到题目，一个朴素的想法：

> 设 $sum$ 为当前数组中所有数的和，那么若 $sum \ge c\times s$ 则可行

但是这个想法是错误的！  
若数组中有一个数大于 $s$，那么这个数仅有 $s$ 个单位是可以起作用的。  
正确思路：

> 设 $sum^\prime$ 为当前数组中所有小于等于 $s$ 的数的和，设 $num$ 为当前数组中大于 $s$ 的数的个数，那么若 $sum^\prime + num\times s \ge c\times s$ 则可行

梳理一下，因为每次的 $s$ 都不一样，我们需要维护一个数据结构，能应对以下需求：

1. 查询大于某数的数的个数  
2. 查询小于等于某数的数的和  

同时实现这两个需求很难，但分开实现很容易。又因为两种查询不会互相影响，所以我们可以开两个树状数组解决问题。

而因为维护大于某数的数的个数不容易实现，所以可以维护小于等于某数的数的个数，再维护一个数 $cnt$ 以记录所有整数的个数即可。

树状数组 $tc[0]$ 维护个数，$sum_{\space_{tc[0]}}(pos)$ 查询小于等于某数的数的个数;  
树状数组 $tc[1]$ 维护和，$sum_{\space_{tc[1]}}(pos)$ 查询小于等于某数的数的和;

则需要判断：$sum_{ _{tc[0]}}(s)\times s+sum_{\space_{tc[1]}}(s)\ge c\times s$    
表达式为真输出 ``TAK``，为假输出 ``NIE``

## 注意点

### 离散化
由于 $a,s\le10^9$，所以我们需要离散化  
关于离散化：我们既需要储存离散化后 $a,s$ 的值，也需要储存 $a,s$ 的原值。  
e.g. 对于上面的表达式
$$sum_{ _{tc[0]}}(\color{red}s\color{black})\times \color{blue}s\color{black}+sum_{\space_{tc[1]}}(\color{red}s\color{black})\ge c\times \color{blue}s\color{black}$$
我们需要在使用红色 $\color{red}s\color{black}$ 时使用离散化后的值，在使用蓝色 $\color{blue}s\color{black}$ 时使用原值。  
原因留给读者自己思考。   

### 关于 0

注意到 $a$ 是可能达到 $0$ 的。虽然是否把 $0$ 看成正数不影响程序正确性，但仍要注意，在代码中对 $0$ 的处理方式要保证统一 

### 卡常
其实，对于这道题来说，时间复杂度达到了 $\Theta(m(logm+logn))$。其中 $\Theta(mlogm)$ 由离散化贡献，$\Theta(mlogn)$ 由树状数组贡献。

但是实现时，由于大家离散化都会选用 $map,unique$ 之类的 $STL$，常数是巨大的！  
所以，请注意卡常

## AC-Code
（运气好能卡着 $1.00s$ 过最后一个点，开 $\texttt{-O2}$ 能在 $300ms$ 左右的时间过最后一个点）
```cpp
/*************************************
 * @problem:      P3586 [POI2015]LOG.
 * @user_id:      63720.
 * @user_name:    Jomoo.
 * @time:         2020-01-31.
 * @language:     C++.
 * @upload_place: Luogu.
*************************************/ 

#include <bits/stdc++.h>
using namespace std;
typedef long long int64;

template <typename Int>
inline Int read() { /* 快读略去 */ }

inline char InputChar()
{
    static char str[3];
    scanf("%s", str);
    return str[0];
}

bool type[1000007]; // 1 for U; 0 for Z
int64 op1[1000007], op2[1000007]; // 离线询问
map<int, int> ops; int LSH_cnt = 0; 
// ops[i] 表示数 i 离散化后为 ops[i]
int nums[1000007];
// nums[i] 表示数 i 离散化前为 nums[i]
int a[1000007];
int64 tc[2][1000007];

inline void add(int treeId, int pos, int val)
{ 
    for (; pos <= LSH_cnt; pos += (pos & (-pos))) 
        tc[treeId][pos] += val; 
}

inline int64 sum(int treeId, int pos)
{
    int64 ret = 0;
    for (; pos; pos -= (pos & (-pos))) 
        ret += tc[treeId][pos];
    return ret;
}

int main()
{
    register int n = read<int>(), m = read<int>();
    ops[0] = 1;
    for (register int i = 1; i <= m; i++) {
        if (InputChar() == 'U') type[i] = 1;
        else type[i] = 0;
        op1[i] = read<int>();
        op2[i] = read<int>();
        ops[op2[i]] = 1;
    }
    for (register map<int, int>::iterator it = ops.begin(); it != ops.end(); it++) {
        nums[LSH_cnt] = it->first;
        it->second = LSH_cnt++;
    }
    for (register int i = 1; i <= m; i++) op2[i] = ops[op2[i]];
    // ops2 存储离散化后的值
    for (register int i = 1, cnt = 0; i <= m; i++) {
        if (type[i]) {
            if (a[op1[i]]) {
                cnt--;
                add(0, a[op1[i]], -1);
                add(1, a[op1[i]], -nums[a[op1[i]]]);
            }
            a[op1[i]] = op2[i];
            if (!a[op1[i]]) continue;
            cnt++;
            add(0, op2[i], 1);
            add(1, op2[i], nums[op2[i]]);
        } else {
            if ((cnt - sum(0, op2[i])) * nums[op2[i]] + sum(1, op2[i]) >= op1[i] * nums[op2[i]]) puts("TAK");
            else puts("NIE");
        }
    }
    return 0;
}
// 表白女装，是女装给了我力量
```

---

## 作者：Owen_codeisking (赞：17)

# [更好的阅读体验点这里](https://www.cnblogs.com/owencodeisking/p/9534903.html)

今天考试考了这题，所以来贡献$[POI2015]LOG$的第一篇题解。代码略丑，调了快三个小时才调出来$AC$代码。

对于这种小清新数据结构题，所以我觉得树状数组才是这道题的正确打开方式。

首先离散化，这样才不会爆内存。开两个树状数组，第一个树状数组记录离散化后$1$到$i$中数字出现的个数，第二个树状数组离散化前$1$到$i$数字出现值的和。把所有询问都读入进来，对于每次操作:

操作$1$：单点修改，若之前的数是正数，第一个树状数组$-1$，第二个树状数组$-$原来的数，若之后的数是正数，第一个树状数组$+1$，第二个树状数组$+$之后的数

操作$2$：区间询问，先将大于$s$的个数求出来，再比较$c-$大于$s$的个数乘上$c$与剩余数之和，若前者大，输出$NIE$，否则输出$TAK$

再开一个数组记录当前序列的值，就完事了

$Code\ Below:$

```cpp
#include <bits/stdc++.h>
#define ll long long
#define res register
using namespace std;
const ll maxn=1000000+10;
ll n,m,a[maxn],b[maxn],mp[maxn],tot,num;
//a[i]是目前的序列情况,b[i]是第几次修改后离散化1-num,mp记录离散化后的数组1-1e9
//tot是几次修改,num是离散化后的修改,c1[i]是1-i的个数，c2[i]是1-i的值的和 
ll c1[maxn],c2[maxn];
struct node{
	ll k,x,id;
}q[maxn];
//id是第几次修改 
inline ll read(){
	res ll x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return (f==1)?x:-x;
}
ll lowbit(ll x){return x & (-x);}
void add_num(ll x,ll y){
	for(;x<maxn;x+=lowbit(x))
		c1[x]+=y;	
}
void add_sum(ll x,ll y){
	for(;x<maxn;x+=lowbit(x))
		c2[x]+=y;
}
ll query_num(ll x){
	ll ans=0;
	for(;x>0;x-=lowbit(x))
		ans+=c1[x];
	return ans;
}
ll query_sum(ll x){
	ll ans=0;
	for(;x>0;x-=lowbit(x))
		ans+=c2[x];
	return ans;
}

int main()
{
	n=read(),m=read();
	res ll k,x,c,s;char ch=getchar();
	for(ll i=1;i<=m;i++){
		while(ch!='U'&&ch!='Z') ch=getchar();
		q[i].k=read(),q[i].x=read();
		if(ch=='U') {
			q[i].id=++tot;
			b[tot]=mp[tot]=q[i].x;
		}
		else q[i].id=-1;
		if(i!=m) ch=getchar();
	}
	sort(mp+1,mp+tot+1);
	num=unique(mp+1,mp+tot+1)-mp-1;
	for(ll i=1;i<=tot;i++)
		b[i]=lower_bound(mp+1,mp+num+1,b[i])-mp;
	for(ll i=1;i<=m;i++)
		if(q[i].id!=-1) q[i].x=b[q[i].id];
	for(ll i=1;i<=m;i++){
		if(q[i].id!=-1){//q[i].x被离散化 
			if(a[q[i].k]>0){
				ll real=lower_bound(mp+1,mp+num+1,a[q[i].k])-mp;
				add_num(real+1,-1);
				add_sum(real+1,-a[q[i].k]);
			}
			a[q[i].k]=mp[q[i].x];
			if(mp[q[i].x]>0){
				add_num(q[i].x+1,1);
				add_sum(q[i].x+1,mp[q[i].x]);
			}
		}
		else {//q[i].x没被离散化,real是去q[i].x在mp中的位置 
			ll real=upper_bound(mp+1,mp+num+1,q[i].x)-mp-1;
			ll bigans=query_num(maxn+1)-query_num(real+1);
			ll smallans=query_sum(real+1);
			if(smallans>=(q[i].k-bigans)*q[i].x) printf("TAK\n");
			else printf("NIE\n");
		}
	}
	return 0;
}
```

---

## 作者：ZaireEmery (赞：10)

树状数组好题。

先考虑对于每次第二种操作，什么情况下能完成。设当前序列里有 $cnt$ 个 $\leq s$ 的数，这些数总和为 $sum$。对于每个数，最多能减 $s$ 次，所以对于 $\leq s$ 的数，一定是全部都减成 $0$ 最优。剩下还要减 $c \times s - sum$ 个数。对于剩下的 $(n - cnt)$ 个 $> s$ 的数，每个数最多能被减去 $s$ 次，所以我们只要判断是否有 $(n - cnt) \times s \geq c \times s - sum$ 即可。

于是，这个问题就被转化为了如何快速的求出 $cnt$ 和 $sum$。

这题对位置没有要求，因此我们可以把序列看作一个集合。我们可以建两个树状数组 $t1$ 和 $t2$。$t1_i$ 表示当前序列中值为 $i$ 的元素数量。$t2_i$ 表示当前序列中值为 $i$ 的元素的值的总和。显然 $cnt = \sum_{i=0}^st1_i$，$sum = \sum_{i=0}^st2_i$。第一种操作只要在 $t1$ 和 $t2$ 上做单点修改即可。

当然，直接这么做的话数组要开到 $10^9$，空间会爆炸，我们可以先把询问离线下来，把中途所有的 $a$ 和 $s$ 的值离散化一下，然后再做。同时，这题有一点卡常，写的时候要注意一点。

```cpp
#include<bits/stdc++.h>
#define int long long
#define N 1000010
using namespace std;
int n,m,cnt,a[N],x[N],y[N],val[N];
char c[N];
map<int,int> mp;
vector<int> v;
inline int lowbit(int x){
	return x&(-x);
}
struct FenwickTree{
	int tr[N];
	void init(){
		memset(tr,0,sizeof(tr));
	}
	void add(int x,int val){
		while(x<=cnt){
			tr[x]+=val;
			x+=lowbit(x);
		}
	}
	int query(int x){
		int ans=0;
		while(x){
			ans+=tr[x];
			x-=lowbit(x);
		}
		return ans;
	}
} t1,t2;
void update(int x,int y){
	t1.add(a[x],-1);
	t1.add(y,1);
	t2.add(a[x],-val[a[x]]);
	t2.add(y,val[y]);
	a[x]=y;
}
signed main(){
	t1.init();t2.init();
	scanf("%lld%lld",&n,&m);
	v.push_back(0);
	for(int i=1;i<=m;i++){
		scanf("%s%lld%lld",&c[i],&x[i],&y[i]);
		v.push_back(y[i]);
	}
	sort(v.begin(),v.end());
	mp[v[0]]=++cnt;val[1]=v[0];
	for(int i=1;i<v.size();i++){
		if(v[i]!=v[i-1]) cnt++;
		mp[v[i]]=cnt;val[cnt]=v[i];
	}
	for(int i=1;i<=n;i++) a[i]=1,t1.add(1,1);
	for(int i=1;i<=m;i++) y[i]=mp[y[i]];
	for(int i=1;i<=m;i++){
		if(c[i]=='U') update(x[i],y[i]);
		else{
			int cnt=t1.query(y[i]),sum=t2.query(y[i]);
			if((n-cnt)*val[y[i]]+sum>=x[i]*val[y[i]]) printf("TAK\n");
			else printf("NIE\n");
		}
	}
	return 0;
}
```


---

## 作者：Alex_Wei (赞：8)

### [P3586 [POI2015] LOG](https://www.luogu.com.cn/problem/P3586)

每次贪心选最大的 $c$ 个肯定没问题，但没办法直接模拟。

每个数之间顺序无关，一般通过排序寻找性质：对于最大的元素 $a_1$，若 $a_1\geq s$ 说明 $a_1$ 必定能贡献 $s$ 次取数，令 $c\gets c - 1$，考虑剩下来 $n - 1$ 个数，这是子问题。递归边界是出现 $a_i < s$，这说明 $a_i\sim a_n$ 都小于 $s$。问题转化为要求选 $s$ 次，每次选 $c$（这里的 $c$ 实际上是询问的 $c$ 减去 $\geq s$ 的数的个数）个不同的数，每个数被选择的次数不超过 $a_i$，其中 $a_i<s$。

证明：看成一个 $s\times c$ 的表格（左上角标号 $(1, 1)$，右下角标号 $(s, c)$），每一行的数互不相同且 $i$ 的出现次数不超过 $a_i$，有如下构造：对于每个 $i$，有 $a_i$ 次填数，每次选择最左边有空位的列的最上面那个位置填入 $i$ 即可，即填数的轨迹是这样的：$(1, 1) \to (2, 1) \to \cdots \to (s, 1) \to  (1, 2) \to (2, 2) \to \cdots \to (s, 2) \to \cdots$。因为轨迹上任意连续 $a_i$ 个格子横坐标互不相同，所以满足限制。

判断是否有 $\sum_{j=i}^n a_j\geq c\times s$ 即可。具体地，求出 $a_i\geq s$ 的 $i$ 的个数 $m$，以及所有小于 $s$ 的数的和 $v$，若 $s\times (c-m)\leq v$ 则可行，否则不可行。离散化 + 树状数组二分即可。

时间复杂度 $\mathcal{O}(m\log m)$。洛谷最优解（2023.4.8）。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using ull = unsigned long long;

char buf[1 << 21], *p1 = buf, *p2 = buf;
char obuf[1 << 26], *O = obuf;
#define gc (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)
#define pc(x) (*O++ = (x))
#define flush() (fwrite(obuf, 1, O - obuf, stdout), O = obuf)
inline int read() {
  int x = 0;
  char s = gc;
  while(!isdigit(s)) s = gc;
  while(isdigit(s)) x = x * 10 + s - '0', s = gc;
  return x;
}
void print(int x) {
  if(x >= 10) print(x / 10);
  pc(x % 10 + '0');
}

bool Mbe;
constexpr int N = 1e6 + 5;
struct node {
  int id, val;
  bool operator < (const node &z) const {
    return val < z.val;
  }
} d[N];
char s[N];
int n, m, a[N], x[N], y[N], c[N];
ll tot, c2[N];
void add(int x, int v) {
  int v2 = d[x].val * v;
  x = n - x + 1, tot += v2;
  while(x <= n) c[x] += v, c2[x] += v2, x += x & -x;
}

bool Med;
int main() {
  fprintf(stderr, "%.3lf MB\n", (&Mbe - &Med) / 1048576.0);
  // ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  #ifdef ALEX_WEI
    FILE* IN = freopen("1.in", "r", stdin); 
    FILE* OUT = freopen("1.out", "w", stdout);
  #endif
  cin >> n >> m, n = 0;
  int cnt = 0;
  for(int i = 1; i <= m; i++) {
    while(!isalpha(s[i])) s[i] = gc;
    x[i] = read(), y[i] = read();
    if(s[i] == 'U') d[++cnt] = {i, y[i]};
  }
  sort(d + 1, d + cnt + 1);
  for(int i = 1; i <= cnt; i++) {
    if(d[i].val != d[i - 1].val) n++;
    y[d[i].id] = n, d[n] = d[i];
  }
  int lg = __lg(n);
  for(int i = 1; i <= m; i++) {
    if(s[i] == 'U') {
      if(a[x[i]]) add(a[x[i]], -1);
      if(a[x[i]] = y[i]) add(a[x[i]], 1);
    }
    else {
      int cnt = 0, p = 0;
      ll sum = 0;
      for(int k = lg; ~k; k--) {
        int np = p + (1 << k);
        if(np > n) continue;
        int nc = cnt + c[np];
        ll ns = sum + c2[np];
        if(d[n - np + 1].val >= y[i]) {
          p = np, cnt = nc, sum = ns;
        }
      }
      if(tot - sum >= 1ll * (x[i] - cnt) * y[i]) pc('T'), pc('A'), pc('K');
      else pc('N'), pc('I'), pc('E');
      pc('\n');
    }
  }
  cerr << 1e3 * clock() / CLOCKS_PER_SEC << " ms\n";
  return flush(), 0;
}
```

---

## 作者：学委 (赞：5)

回顾一下询问：每次选出c个正数，并将它们都减去1，判断能否进行s次操作。

如何判断？对于当前序列中大于等于s的元素（假设有k个，剩下n-k个是小于s的），显然每次都将它们减去1；除这些以外每次还要减c-k个元素。

这n-k个元素每个都小于s，不妨对它们逐一进行考虑：将第一个元素不重复地分到某几次减法中；将第二个元素不重复地分到某几次减法中，并且优先分到前一个元素没填的地方；……（如果你进行想象，会发现是一层一层地填，每层s个，一共c-k层）于是发现这些元素可以完全利用，即：只要这n-k个元素的和大于(c-k)×s，就一定可以进行s次操作。

权值线段树维护范围内权值和以及点数。考虑下标是权值，上限1e9，而动态开点会使空间达到nlog(1e9)导致MLE。所以考虑将权值离散化。

```cpp
#include <cstdio>
#include <algorithm>
using std::sort;
using std::lower_bound;
#include <utility>
using std::unique;
typedef long long LL;
const int N = 1e6 + 10;
int n, m, qtyp[N], qx[N], qy[N], cur[N], val[N], valcnt = 0;
LL sum[N * 4]; int cnt[N * 4];
void modify(int k, int l, int r, int x, int typ) {
  if (typ == -1) --cnt[k], sum[k] -= val[x];
  else ++cnt[k], sum[k] += val[x];
  if (l == r) return;
  int mid = (l + r) / 2;
  if (x <= mid) modify(k * 2, l, mid, x, typ);
  else modify(k * 2 + 1, mid + 1, r, x, typ);
}
LL query(int k, int l, int r, int x, int y, int typ) {
  if (y < l or r < x) return 0;
  if (x <= l and r <= y)
    return typ == 0 ? cnt[k] : sum[k];
  int mid = (l + r) / 2;
  return query(k * 2, l, mid, x, y, typ) + query(k * 2 + 1, mid + 1, r, x, y, typ);
}
int main() {
  scanf("%d %d", &n, &m);
  val[++valcnt] = 0; for (int i = 1; i <= n; ++i) cur[i] = 1;
  for (int i = 1; i <= m; ++i) {
    char op[10]; scanf("%s", op);
    if (op[0] == 'U') qtyp[i] = 0;
    else qtyp[i] = 1;
    scanf("%d %d", &qx[i], &qy[i]);
    val[++valcnt] = qy[i];
  }
  sort(val + 1, val + valcnt + 1);
  valcnt = unique(val + 1, val + valcnt + 1) - val - 1;
  for (int i = 1; i <= m; ++i)
    qy[i] = lower_bound(val + 1, val + valcnt + 1, qy[i]) - val;
  for (int i = 1; i <= m; ++i) {
    if (qtyp[i] == 0) {
      int k = qx[i], a = qy[i];
      modify(1, 1, valcnt, cur[k], -1);
      cur[k] = a;
      modify(1, 1, valcnt, cur[k], 1);
    }
    else {
      int c = qx[i], s = qy[i];
      int k = query(1, 1, valcnt, s, valcnt, 0);
      LL tot = LL(c - k) * val[s];
      if (query(1, 1, valcnt, 1, s - 1, 1) >= tot) puts("TAK");
      else puts("NIE");
    }
  }
  return 0;
}
```

---

## 作者：lndjy (赞：3)

题解区没有 Treap 的做法，这里给一个。

对于每次询问：

如果 $a_i\ge s$，则 $a_i$ 可以 $s$ 次操作都被选中，
否则 $a_i$ 可以被 $a_i$ 次操作选中。

设数列中大于等于 $s$ 的数有 $k$ 个，小于 $s$ 的数的和为 $sum$，$sum\ge (c-k)\times s$ 时有解。

每次询问是对于整个序列，所以 $k$ 等于 $n-rank_s-1$，其中 $rank_s$ 为 $s$ 的排名，$n$ 为目前数列中数的个数，这个可以用 Treap。

$sum$ 可以在 Treap 上记录子树的 $sum$，类似查询排名的操作，把小于 $s$ 的子树的 $sum$ 值加起来就好了。

修改时直接在 Treap 上修改即可。

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#define int long long
using namespace std;
const int N=1e6+5;
int inline read()
{
	int ans=0,f=1;
	char ch=getchar();
	while(!isdigit(ch))
	{
		if(ch=='-')
		f=-1;
		ch=getchar();
	}
	while(isdigit(ch))
	{
		ans=ans*10+ch-'0';
		ch=getchar();
	}
	return ans*f;
}
struct treap
{
	int sz[N],v[N],num[N],son[N][2],rd[N],sum[N],tot,root;
	void pushup(int p)
	{
		sz[p]=sz[son[p][0]]+num[p]+sz[son[p][1]];
		sum[p]=sum[son[p][0]]+num[p]*v[p]+sum[son[p][1]];
	}
	void rotate(int &p,int d)
	{
		int k=son[p][d^1];
		son[p][d^1]=son[k][d];
		son[k][d]=p;
		pushup(p);
		pushup(k);
		p=k;
	}
	void ins(int &p,int x)
	{
		if(!p)
		{
			p=++tot;
			sz[p]=num[p]=1;
			v[p]=sum[p]=x;
			rd[p]=rand();
			return;
		}
		if(v[p]==x)
		{
			sz[p]++;
			num[p]++;
			sum[p]+=x;
			return;
		}
		int d=(x>v[p]);
		ins(son[p][d],x);
		if(rd[p]<rd[son[p][d]]) rotate(p,d^1);
		pushup(p);
	}
	void del(int &p,int x)
	{
		if(!p) return;
		if(x<v[p]) del(son[p][0],x);
		else if(x>v[p]) del(son[p][1],x);
		else
		{
			if(!son[p][0]&&!son[p][1])
			{
				num[p]--;sz[p]--;sum[p]-=x;
				if(num[p]==0) p=0;
			}
			else if(son[p][0]&&!son[p][1])
			{
				rotate(p,1);
				del(son[p][1],x);
			}
			else if(!son[p][0]&&son[p][1])
			{
				rotate(p,0);
				del(son[p][0],x);
			}
			else
			{
				int d=(rd[son[p][0]]>rd[son[p][1]]);;
				rotate(p,d);
				del(son[p][d],x);
			}
		}
		pushup(p);
	}
	int asksum(int p,int x)
	{
		if(!p) return 0;
		if(v[p]==x) return sum[son[p][0]];
		if(v[p]<x) return sum[son[p][0]]+num[p]*v[p]+asksum(son[p][1],x);
		return asksum(son[p][0],x);
	}
	int ask(int p,int x)
	{
		if(!p) return 0;
		if(v[p]==x) return sz[son[p][0]];
		if(v[p]<x) return sz[son[p][0]]+num[p]+ask(son[p][1],x);
		return ask(son[p][0],x);
	}
}t;
int a[N],n,m;
signed main()
{
	n=read();m=read();
	for(int i=1;i<=m;i++)
	{
		char op;
		cin>>op;
		if(op=='U')
		{
			int k=read(),x=read();
			if(a[k]) t.del(t.root,a[k]);
			a[k]=x;
			if(x)
			t.ins(t.root,x);
		}
		else
		{
			int c=read(),s=read();
			int sum=t.asksum(t.root,s),k=t.sz[t.root]-t.ask(t.root,s);
			if(sum>=(c-k)*s) puts("TAK");
			else puts("NIE");
		}
	}
 	return 0;
}

```


---

## 作者：VanHelsing (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P3586)  

听课的时候线段树的例题，具体思路也比较好想，写法也是线段树基础写法，还是挺好的一道题。

题意描述： $n$ 个数的序列（或者说是可重复集合），有两种操作，为将第 $k$ 个数改成 $x$ ，或者询问在这个序列上，每次选出 $c$ 个正数挨个减 $1$ ，询问能否进行 $s$ 次操作。

我们可以考虑一种贪心：如果有一个数 $a_i \geq s$ ，那么我即使每次都选这个数他也不会比0更小，那就每次都选他一定不会比我不选他更劣，所以我就会每次都选这个数，那么问题就变成了：我们假设比 $s$ 大的数有 $cnt$ 个，所有比 $s$ 小的数能否每次选 $c-cnt$ 个减 $1$ 并进行 $s$ 次。

这个时候，我们发现，只要剩下的数比 $c-cnt$ 个多，并且他们的和大于等于 $(c-cnt)\times s$ ,就一定能够满足题意。  

具体考虑下怎么证明：考虑到题意的意思就是让你有 $c \times s$ 个空要填数，填进去的数是下标，然后下标为 $i$ 的数不能被填进去超过 $a_i$ 次，每段长度为c的连续个空中（即从1到 $c$，从 $c+1$ 到 $2c$ ···）不能有相同的数字。很显然如果 $a_i \geq s$ 的话，我就每段都放进去一个 $i$ ，如果 $a_i\leq s$ 的话，我就放 $a_i$ 次 $i$ ，那么设大于等于 $s$ 的数的个数为 $cnt$，也就是说我们还剩下 $s-cnt$ 个空需要被填数，很显然如果小于 $s$ 的数的总和比 $(c-cnt)\times s$ 大的话就是能够填进去的。
 
那么现在只需要维护一种数据结构能询问大于 $s$ 的数的个数，和所有小于 $s$ 的数的个数和权值的积之和。这显然是权值线段树，先离散化一下然后在线段树里维护区间权值和以及每个数出现几次就好了。每次询问的时候先查看有多少个大于 $s$ 的数，这时候只需要返回次数和，然后再查权值和。

$Code\ time:$（码风毒瘤，跪求勿喷）

```cpp
#include<bits/stdc++.h>

#define int long long

using namespace std;

const int maxn=1e6+10;

int n,m,qopt[maxn],QryX[maxn],QryY[maxn],id[maxn],arr[maxn],cnt=0;

struct SegmenTree{
	
	long long left,right;
	
	long long cnt,sum;
	
};SegmenTree tree[maxn<<2];

void build(long long index,long long l,long long r)
{
	tree[index].left=l;

	tree[index].right=r;

	if(l==r)
	{
		return;
	}

	long long mid=(l+r)>>1;

	build(index<<1,l,mid);

	build(index<<1|1,mid+1,r);
}

void Modify(long long index,long long x,long long opt)
{
	if(opt==-1)
	{
		tree[index].cnt--;
		
		tree[index].sum-=arr[x];
	}
	else
	{
		tree[index].cnt++;
		
		tree[index].sum+=arr[x];
	}
	
	if(tree[index].left==tree[index].right)
	{
		return;
	}
	
	long long mid=(tree[index].left+tree[index].right)>>1;
	
	if(x<=mid)
	{
		Modify(index<<1,x,opt);
	}
	
	else
	{
		Modify(index<<1|1,x,opt);
	}
}

long long Query(long long index,long long l,long long r,long long opt)
{
	if(l<=tree[index].left&&r>=tree[index].right)
	{
		return opt==0?tree[index].cnt:tree[index].sum;
	}
	
	long long mid=(tree[index].left+tree[index].right)>>1;
	
	long long ret=0;
	
	if(l<=mid)
	{
		ret+=Query(index<<1,l,r,opt);
	}
	
	if(r>mid)
	{
		ret+=Query(index<<1|1,l,r,opt);
	}
	
	return ret;
}

signed main()
{
	scanf("%lld%lld",&n,&m);
	
	arr[++cnt]=0;
	
	for(int i=1;i<=n;i++)
	{
		id[i]=1;
	}
	
	for(int i=1;i<=m;i++)
	{
		char opt[10];

		scanf("%s",opt+1);
		
		if(opt[1]=='U')
		{
			qopt[i]=0;
		}
		
		else
		{
			qopt[i]=1;
		}
		
		scanf("%lld%lld",&QryX[i],&QryY[i]);
		
		arr[++cnt]=QryY[i];
	}
	
	sort(arr+1,arr+cnt+1);
	
	cnt=unique(arr+1,arr+cnt+1)-arr-1;
	
	for(int i=1;i<=m;i++)
	{
		QryY[i]=lower_bound(arr+1,arr+cnt+1,QryY[i])-arr;
	}
		
	build(1,1,cnt);
	
	for(int i=1;i<=m;i++)
	{
		if(qopt[i]==0)
		{
			int k=QryX[i],a=QryY[i];
			
			Modify(1,id[k],-1);
			
			id[k]=a;
			
			Modify(1,id[k],1);
		}
		else
		{
			int c=QryX[i],s=QryY[i];
			
			int k=Query(1,s,cnt,0);
			
			long long tot=(c-k)*arr[s];
			
			if(Query(1,1,s-1,1)>=tot)
			{
				printf("TAK\n");
			}
			
			else
			{
				printf("NIE\n");
			}
		}
	}
}
```

---

## 作者：attack (赞：2)

不用离散化，直接动态开节点线段树就行。十分无脑十分好写~~~

```cpp
/*

*/
#include<bits/stdc++.h> 
#define Pair pair<int, int>
#define MP(x, y) make_pair(x, y)
#define fi first
#define se second
#define LL long long 
#define Fin(x) {freopen(#x".in","r",stdin);}
#define Fout(x) {freopen(#x".out","w",stdout);}
using namespace std;
const int MAXN = 1e6 + 10, mod = 1e9 + 7, INF = 1e9 + 10;
const double eps = 1e-9;
template <typename A, typename B> inline bool chmin(A &a, B b){if(a > b) {a = b; return 1;} return 0;}
template <typename A, typename B> inline bool chmax(A &a, B b){if(a < b) {a = b; return 1;} return 0;}
template <typename A, typename B> inline LL add(A x, B y) {if(x + y < 0) return x + y + mod; return x + y >= mod ? x + y - mod : x + y;}
template <typename A, typename B> inline void add2(A &x, B y) {if(x + y < 0) x = x + y + mod; else x = (x + y >= mod ? x + y - mod : x + y);}
template <typename A, typename B> inline LL mul(A x, B y) {return 1ll * x * y % mod;}
template <typename A, typename B> inline void mul2(A &x, B y) {x = (1ll * x * y % mod + mod) % mod;}
template <typename A> inline void debug(A a){cout << a << '\n';}
template <typename A> inline LL sqr(A x){return 1ll * x * x;}
inline int read() {
    char c = getchar(); int x = 0, f = 1;
    while(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
    return x * f;
}
int a[MAXN], N, M;
const int SS = MAXN * 10 + 10, Mx = 1e9 + 10;
int ls[SS], rs[SS], num[SS], tot, root;
LL sum[SS];
void update(int k) {
	sum[k] = sum[ls[k]] + sum[rs[k]];
	num[k] = num[ls[k]] + num[rs[k]];
}
void Modify(int &k, int l, int r, int p, int v) {
	if(!k) k = ++tot;
	if(l == r) {
		num[k] += (v < 0 ? -1 : 1);
		sum[k] += v;
		return ;
	}
	int mid = l + r >> 1;
	if(p <= mid) Modify(ls[k], l, mid, p, v);
	else Modify(rs[k], mid + 1, r, p, v);
	update(k);
}
int QueryNum(int k, int l, int r, int ql, int qr) {
	if(!k) return 0;
	if(ql <= l && r <= qr) 
		return num[k];
	int mid = l + r >> 1;
	if(ql > mid) return QueryNum(rs[k], mid + 1, r, ql, qr);
	else if(qr <= mid) return QueryNum(ls[k], l, mid, ql, qr);
	else return QueryNum(ls[k], l, mid, ql, qr) + QueryNum(rs[k], mid + 1, r, ql, qr);
}
LL QuerySum(int k, int l, int r, int ql, int qr) {
	if(!k) return 0;
	if(ql <= l && r <= qr) return sum[k];
	int mid = l + r >> 1;
	if(ql > mid) return QuerySum(rs[k], mid + 1, r, ql, qr);
	else if(qr <= mid) return QuerySum(ls[k], l, mid, ql, qr);
	else return QuerySum(ls[k], l, mid, ql, qr) + QuerySum(rs[k], mid + 1, r, ql, qr);
}
signed main() {
    N = read(); M = read();
    while(M--) {
    	char s[3]; scanf("%s", s);
    	int x = read(), y = read();
    	if(s[0] == 'U') {//a[x] = y
			if(a[x]) Modify(root, 1, Mx, a[x], -a[x]);
			a[x] = y;
			if(y) Modify(root, 1, Mx, y, y);
		} else {//choose x = c   turn y = s
			int k = QueryNum(1, 1, Mx, y, Mx);
			LL sum = QuerySum(1, 1, Mx, 1, y - 1);
			puts((sum >= 1ll * (x - k) * y) ? "TAK" : "NIE");
		}
	}
	
    
    return 0;
}
/*
7
-1 160 -2000
14 82 61 85 41 10 34
*/
```

---

## 作者：miaokehao (赞：2)

既然没有题解我就发一篇，我刚看到此题时直接使用fhq_treap，但因为本人的大常数所以TLE了最大的第十个点
```
#include <bits/stdc++.h>
#define res register int
#define N 200010
using namespace std;
int n,m,tot,root,a[N],ans,sum;
char op[5];
inline int read()
{
  int X=0,w=0;
  char ch=0;
  while(!isdigit(ch))
  {
    w|=ch=='-';
    ch=getchar();
  }
  while(isdigit(ch)) X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
  return w?-X:X;
}
struct papa
{
  int ls,rs,size,pri,v,sum;
};
struct fhq_treap
{
  papa tr[N<<2];
  inline void pushup(res now)
  {
    tr[now].size=tr[tr[now].ls].size+tr[tr[now].rs].size+1;
    tr[now].sum=tr[tr[now].ls].sum+tr[tr[now].rs].sum+tr[now].v;
  }
  inline int merge(res x,res y)
  {
    if(x==0||y==0) return x+y;
    if(tr[x].pri>tr[y].pri)
    {
      tr[x].rs=merge(tr[x].rs,y);
      pushup(x);
      return x;
    }
    else
    {
      tr[y].ls=merge(x,tr[y].ls);
      pushup(y);
      return y;
    }
  }
  inline void split(int now,int k,int &x,int &y)
  {
    if(now==0)
    {
      x=y=0;
      return;
    }
    if(tr[now].v<=k)
      x=now,split(tr[now].rs,k,tr[now].rs,y);
    else
      y=now,split(tr[now].ls,k,x,tr[now].ls);
    pushup(now);
  }
  inline int kth(res now,res k)
  {
    while(1)
    {
      if(tr[tr[now].ls].size>=k) now=tr[now].ls;
      else if(tr[tr[now].ls].size+1==k) return now;
      else k-=tr[tr[now].ls].size+1,now=tr[now].rs;
    }
  }
  inline void insert(int now)
  {
    int x,y;
    split(root,now,x,y);
    tr[++tot].size=1,tr[tot].v=now,tr[tot].pri=rand(),tr[tot].sum=now;
    root=merge(merge(x,tot),y);
  }
  inline void erase(int now)
  {
    int x,y,z;
    split(root,now,x,y);
    split(x,now-1,x,z);
    z=merge(tr[z].ls,tr[z].rs);
    root=merge(merge(x,z),y);
  }
} T;
int main()
{
  n=read(),m=read();
  srand((unsigned)time(NULL));
  for(res i=1; i<=n; i++)
    T.insert(0);
  for(res  i=1; i<=m; i++)
  {
    scanf("%s",op);
    res x=read(),y=read();
    if(op[0]=='U')
    {
      T.erase(a[x]);
      T.insert(a[x]=y);
    }
    else
    {
      res x1,x2,x3;
      T.split(root,0,x1,x2);
      T.split(x2,y-1,x3,x2);
      if(T.tr[x3].sum>=(x-T.tr[x2].size)*y) puts("TAK");
      else puts("NIE");
      root=T.merge(x1,T.merge(x3,x2));
    }
  }
  return 0;
}
```
```
#include <bits/stdc++.h>
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize(4)
#pragma GCC optimize("Ofast,no-stack-protector")
#define res register ll
#define ll long long
#define maxn 1000010
using namespace std;
ll Last[maxn],x[maxn],y[maxn],z[maxn],num[maxn],Hash[maxn];
ll n,m,cnt;
inline ll read()
{
  ll X=0,w=0;
  char ch=0;
  while(!isdigit(ch))
  {
    w|=ch=='-';
    ch=getchar();
  }
  while(isdigit(ch)) X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
  return w?-X:X;
}
struct papa
{
  ll x,y;
} q[maxn];
struct BIT
{
  ll c[maxn];
  inline void add(res x,res y)
  {
    while(x<=cnt)
    {
      c[x]+=y;
      x+=x&-x;
    }
  }
  inline ll query(res x)
  {
    res sum=0;
    while(x)
    {
      sum+=c[x];
      x-=x&-x;
    }
    return sum;
  }
} bit1,bit2;
inline void lisan()
{
  sort(num+1,num+m+1);
  Hash[cnt=1]=num[1];
  for(res i=2; i<=m; i++)
    if(num[i]!=num[i-1])
      Hash[++cnt]=num[i];
  for(res i=1; i<=m; i++)q[i].y=lower_bound(Hash+1,Hash+cnt+1,q[i].y)-Hash;
}
signed main()
{
  //freopen("ahaoda.in","r",stdin);
  //freopen("ahaoda.out","w",stdout);
  n=read(),m=read();
  char s[5];
  for(res i=1; i<=m; i++)
  {
    scanf("%s",s);
    q[i].x=read(),q[i].y=num[i]=read();
    if(s[0]=='U')z[i]=1;
    else z[i]=0;
  }
  lisan();
  for(res i=1; i<=m; i++)
  {
    if(z[i])
    {
      if(Last[q[i].x])
      {
        res j=Last[q[i].x];
        bit1.add(j,-1);
        bit2.add(j,-Hash[j]);
      }
      Last[q[i].x]=q[i].y;
      bit1.add(q[i].y,1);
      bit2.add(q[i].y,Hash[q[i].y]);
    }
    else
    {
      res num1=bit2.query(q[i].y-1),num2=bit1.query(cnt),num3=bit1.query(q[i].y-1);
      if(num1>=(q[i].x-num2+num3)*Hash[q[i].y])puts("TAK");
      else puts("NIE");
    }
  }
  return 0;
}
```

---

## 作者：EDqwq (赞：1)

### 思路：

对于第二个操作，显然所有大于 $s$ 的数都可以常驻在选择的 $c$ 个数里面，我们把这些数的个数设为 $num$ ，并在后面不考虑这些数。

也就是我们要在 $a_i < s$ 中，每次选择 $c - num$ 个数，询问最终能否进行 $s$ 次操作。

我们转换一下，由于每一个数都可以在不同的地方用多次，所以每一次操作就是“选择 $c - num$ 个大于 0 的数，每一个数减 1 ，能否操作 $s$ 次（能否选择出 $(c - num) \times s$ 个）”。

显然，每一个数只能被选择他的值的次数。

总共所有的数，就能被选择所有数的和这么多次，我们设他们的和为 $x$ ，得出结论：

当

$$x >= (c - num) \times s$$

我们可以操作。

感性理解部分：

为什么这个成立呢？

你想想，如果要让他不成立，我们需要造成： $x$ 大于这个柿子，但是数不够选，选到一半，剩下的大于 0 的数已经少于 $(c - num)$ 了。

要做到这一点，需要一个很大的数，其他都很小。

但是我们已经排除了大于等于 $s$ 的数了，所以基本上不可能成立的。

接下来，由于我们需要得到大于一个数的个数，和小于一个数的所有数的和，我们可以用 fhq 完美解决这个问题

***

### 代码：

```cpp
#include<bits/stdc++.h>

#define int long long
#define mem(x) memset(x,0,sizeof(x))

using namespace std;

int read(){
   int s = 0,w = 1;
   char ch = getchar();
   while(ch < '0' || ch > '9'){if(ch == '-')w = -1;ch = getchar();}
   while(ch >= '0' && ch <= '9')s = s * 10 + ch - '0',ch = getchar();
   return s * w;
}

struct node{
	int l;
	int r;
	int w;
	int key;
	int siz;
	int sum;
}e[4000010];

int n,m;
int cnt,rt;
int a[4000010];

int newnode(int w){
	cnt ++;
	e[cnt].w = w;
	e[cnt].key = rand();
	e[cnt].siz = 1;
	e[cnt].sum = w;
	return cnt;
}

void update(int i){
	e[i].siz = e[e[i].l].siz + e[e[i].r].siz + 1;
	e[i].sum = e[e[i].l].sum + e[e[i].r].sum + e[i].w;
}

void split(int i,int w,int &x,int &y){
	if(!i){
		x = y = 0;
		return ;
	}
	if(e[i].w <= w){
		x = i;
		split(e[i].r,w,e[i].r,y);
	}
	else {
		y = i;
		split(e[i].l,w,x,e[i].l);
	}
	update(i);
}

int merge(int x,int y){
	if(!x || !y)return x + y;
	if(e[x].key > e[y].key){
		e[x].r = merge(e[x].r,y);
		update(x);
		return x;
	}
	else {
		e[y].l = merge(x,e[y].l);
		update(y);
		return y;
	}
}

void ins(int w){
	int x,y;
	split(rt,w,x,y);
	rt = merge(x,merge(newnode(w),y));
}

void del(int w){
	int x,y,z;
	split(rt,w,x,z);
	split(x,w - 1,x,y);
	y = merge(e[y].l,e[y].r);
	rt = merge(x,merge(y,z));
}

int getbigger(int w){
	int x,y;
	split(rt,w - 1,x,y);
	int ans = e[y].siz;
	rt = merge(x,y);
	return ans;
}

int getsum(int w){
	int x,y;
	split(rt,w - 1,x,y);
	int ans = e[x].sum;
	rt = merge(x,y);
	return ans;
}

signed main(){
	srand(time(0));
	cin>>n>>m;
	for(int i = 1;i <= n;i ++)ins(0);
	for(int i = 1;i <= m;i ++){
		char op;
		int x,y;
		scanf(" %c ",&op);
		x = read(),y = read();
		if(op == 'U'){
			del(a[x]);
			ins(y);
			a[x] = y;
		}
		else {
			int num = getbigger(y);
			if(getsum(y) >= (x - num) * y)puts("TAK");
			else puts("NIE");
		}
	}
	return 0;
}
```

---

## 作者：asd_a (赞：1)

本人使用SBT来求大于s的个数，和小于s的数的和  
如何判断Owen_codeisking已经讲得很清楚了  
先将大于s的个数求出来，再比较c-大于s的个数乘上s与剩余数之和，若前者大，输出NIE，否则输出TAK
Code:
```
#include<bits/stdc++.h>
using namespace std;
const int N=2e6+5;
typedef long long ll;
int val[N],cnt[N],siz[N],c[N][2],root,tot;
ll sum[N];
inline void up(int x)
{
    sum[x]=sum[c[x][0]]+sum[c[x][1]]+1ll*val[x]*cnt[x];
    siz[x]=siz[c[x][0]]+siz[c[x][1]]+cnt[x];
}
inline void rot(int &x,int k)
{
    k^=1;
    int y=c[x][k];
    c[x][k]=c[y][k^1];
    c[y][k^1]=x;
    up(x);up(y);
    x=y;
}
inline void maintain(int &x)
{
    if(x==0)return ;
    bool flag1=0,flag2=0;
    if(siz[c[c[x][0]][0]]>siz[c[x][1]])
        rot(x,1),flag2=1;
    else if(siz[c[c[x][0]][1]]>siz[c[x][1]])
        rot(c[x][0],0),rot(x,1),flag1=flag2=1;
    if(siz[c[c[x][1]][1]]>siz[c[x][0]])
        rot(x,0),flag1=1;
    else if(siz[c[c[x][1]][0]]>siz[c[x][0]])
        rot(c[x][1],1),rot(x,0),flag1=flag2=1;
    up(x);
    if(flag1)maintain(c[x][0]);
    if(flag2)maintain(c[x][1]);
    up(x);
}
inline void insert(int x,int &now)
{
    if(!now)
    {
        now=++tot;
        val[now]=x;
    }
    if(val[now]==x)
    {
        ++cnt[now];up(now);
        return ;
    }
    if(x<val[now]) insert(x,c[now][0]);
    else insert(x,c[now][1]);
    maintain(now);
	maintain(now);
    up(now);
}
inline void ins(int x){insert(x,root);}
inline int Delete(int x,int &now)
{
    int tmp;
    if(x==val[now]||(x<val[now]&&!c[now][0])||(x>val[now]&&!c[now][1]))
    {
        tmp=val[now];
        if(cnt[now]>1) --cnt[now];
        else if(!c[now][0]||!c[now][1]) now=c[now][0]+c[now][1];
        else val[now]=Delete(val[now]+1,c[now][0]);
        up(now);
        return tmp;
    }
    if(x<val[now])tmp=Delete(x,c[now][0]);
    else tmp=Delete(x,c[now][1]);
    up(now);
    return tmp;
}
inline void del(int x){Delete(x,root);}
inline ll gsum(int x,bool flag)
{
    int now=root;
    ll ans1=0,ans2=0;
    while(now)
    {
        if(val[now]==x)
        {
            ans1+=sum[c[now][0]];
            ans2+=sum[c[now][1]];
            break;
        }
        if(val[now]<x)
        {
            ans1+=sum[now]-sum[c[now][1]];
            now=c[now][1];
        }
        else
        {
            ans2+=sum[now]-sum[c[now][0]];
            now=c[now][0];
        }
    }
    if(!flag)return ans1;
    return ans2;
}
inline int gsiz(int x,bool flag)
{
    int now=root;
    ll ans1=0,ans2=0;
    while(now)
    {
        if(val[now]==x)
        {
            ans1+=siz[c[now][0]];
            ans2+=siz[c[now][1]];
            break;
        }
        if(val[now]<x)
        {
            ans1+=siz[now]-siz[c[now][1]];
            now=c[now][1];
        }
        else
        {
            ans2+=siz[now]-siz[c[now][0]];
            now=c[now][0];
        }
    }
    if(!flag)return ans1;
    return ans2;
}
inline int rd()
{
    int x=0,fl=1;char ch=getchar();
    for(;ch>'9'||ch<'0';ch=getchar())fl=(ch=='-'?-1:1);
    for(;ch>='0'&&ch<='9';ch=getchar())x=x*10+ch-'0';
    return x*fl;
}
int n,m,a[N],b[N];
int main()
{
    n=rd();m=rd();
    int x,y,z;
    char opt;
    while(m--)
    {
        cin>>opt;x=rd();y=rd();
        if(opt=='U')
        {
            if(!b[x])
            {
                ins(y);
                a[x]=y;
                b[x]=1;
            }
            else
            {
                del(a[x]);a[x]=y;
                ins(y);
            }
        }
        else
        {
            z=gsiz(y-1,1);
            x-=z;
            if(1ll*x*y<=gsum(y,0))
                puts("TAK");
            else puts("NIE");
        }
    }
    return 0;
}
```

---


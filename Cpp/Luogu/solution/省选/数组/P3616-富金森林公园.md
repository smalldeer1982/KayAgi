# 富金森林公园

## 题目描述

博艾的富金森林公园里有一个长长的富金山脉，山脉是由一块块巨石并列构成的，编号从 $1$ 到 $N$ 。每一个巨石有一个海拔高度。而这个山脉又在一个盆地中，盆地里可能会积水，积水也有一个海拔高度，所有**严格低于**这个海拔高度的巨石，就会在水面下隐藏。


由于地壳运动，巨石的海拔高度可能会随时变化，每次一块的巨石会变成新的海拔高度。当然，水面的高度也会随时发生变化。


因为有这样奇妙的地质奇观，吸引了很多游客来游玩。uim 作为一个游客，可以告诉你此时水位海拔，你得告诉他，能看到有几个连续露出水面的部分。（与水面持平我们也认为是露出）

## 说明/提示

$10\%$ 的数据，$N,M<=2000$。

另外 $30\%$ 的数据， 只有 `1` 的询问。

$100\%$ 的数据，$1<=N,M<=200000,1<=A_i,B_j,D_j<=10^9$，一定有 `1` 询问。


## 样例 #1

### 输入

```
5 4
8 6 3 5 4
1 5
2 4 1
1 5
1 3```

### 输出

```
2
1
2```

# 题解

## 作者：kkksc03 (赞：43)

- 40分做法-对于1，2，3，6个点

模拟
- 40分做法-对于前4个点

我们发现，高度10e9是纸老虎。完全可以离散化处理一遍。

然后我们可以很容易的得到，从0到$max(Ai,Bi,Ci)$，当然是离散化后的，之间的每个高度在初始情况下有几个露出部分。方法是从低往高扫描每一个高度，如果有一些巨石的高度低于扫描线，那么看它两边的巨石高度。如果两边都比这块高，那么加1。如果都比这个低，那么减1。

- 100分做法

其实上面的做法是预处理。假设下面的情况：

```cpp
0
1        x     
1        x    x
1   x    x    x
1   x    x    x
1   x    x    x
    3    5    4
```
变成
```cpp
0
0(-1)              
1              x
2(+1)x         x
2(+1)x         x
1    x    x    x
     3    1    4
```
看到了吗，当下降时，在某个高度下，这个巨石左右两边如果是空的，那么各-1，而这个高度下这个巨石两边都有巨石，那么各+1。

所以我们维护这个区间加法。

还需要继续说下去吗？线段树树状数组平衡树(treap)随便上吧。


---

## 作者：kczno1 (赞：22)

用0表示<水面，1表示>=水面

一个露出的部分类似这样:00011111..1100

假设有n个1，

那么相邻之间max为1的有n+1对，

min为1的有n-1对。

可以发现: (max>=x的 - min>=x的)/2 = x的答案

所以我们对max,min维护一个东西，支持删除，插入，查询>=一个数的个数。

可以离散化+树状数组。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=400100;

int a[N],c[N],top;
void add(int i,int x)
{
    i=top-i+1;
    for(;i<=top;i+=i&-i) c[i]+=x;
}
int qiu(int i)
{
    i=top-i+1;
    int ans=0;
    for(;i;i-=i&-i) ans+=c[i];
    return ans;
}

namespace kcz
{
  int *q[N],tot;
  void push(int *x)
  {
    q[++tot]=x;
  }
  bool xiao(int *x,int *y)
  {
      return *x<*y;
  }
  void lisan()
  {
       sort(q+1,q+tot+1,xiao);
       top=1;
     int now=*q[1];*q[1]=1;
       for(int i=2;i<=tot;++i)
       {
           if(*q[i]!=now) { now=*q[i];++top; }
           *q[i]=top;
       }
  }
};
struct query
{
    int type,i,x;
    void init()
    {
        scanf("%d",&type);
        if(type==1)  scanf("%d",&x); 
        else  scanf("%d%d",&i,&x);
        kcz::push(&x);
    }
    void solve()
    {
        if(type==1)  printf("%d\n",qiu(x)>>1);
        else
        {
            add(max(a[i],a[i+1]),-1);add(min(a[i],a[i+1]),1);
            add(max(a[i],a[i-1]),-1);add(min(a[i],a[i-1]),1);
            a[i]=x;
            add(max(a[i],a[i+1]),1);add(min(a[i],a[i+1]),-1);
            add(max(a[i],a[i-1]),1);add(min(a[i],a[i-1]),-1);
        }
    }
}q[N];

int main()
{ freopen("1.in","r",stdin);
    int n,m,i;
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;++i) scanf("%d",a+i);
    for(i=0;i<=n+1;++i) kcz::push(a+i);
    for(i=1;i<=m;++i) q[i].init();
    kcz::lisan();
    for(i=0;i<=n;++i) 
    {add(max(a[i],a[i+1]),1);add(min(a[i],a[i+1]),-1);
    }
    for(i=1;i<=m;++i) q[i].solve();
}
```

---

## 作者：Adove (赞：15)

### 预处理

我们观察这道题，先确定每根石柱的贡献；

每根石柱对答案是否有贡献在于其是否**打乱了其左右区间的单调性**；

![](https://cdn.luogu.com.cn/upload/pic/16366.png)

大概就是上图的效果，我们的线段树将**维护左边那一串数**；

那么我们**如何获得、如何处理**这个信息呢？

我们再来看每根石柱；

对于每根石柱来说，如果其对答案有贡献，那么贡献在且只在严格高于它的区间：对于上凸的石柱，它对严格高于它的区间贡献为-1，对于下凹的石柱，它对严格高于它的区间贡献为+1；

那么我们就可以大胆作出如下论断：

在**严格相邻不相等**的石柱群中，对于每根石柱，如果其两侧石柱**严格高于**它，那么就在h[i]~maxh的区间+1；如果其两侧的石柱**严格低于**它，那么就在h[i]~maxh的区间-1。最后统计得到的就是在该高度下的山峰总数。

但是我们很快就发现了一个问题，对于下图这种情况，我们统计起来就变得有些困难↓

![](https://cdn.luogu.com.cn/upload/pic/16367.png)

如果我们统计时要求每根石柱两侧的石柱与这根石柱的高度差都是严格不为0的，那么在这种情况下必然会受到局限。

但是我们很快就通过一种去重的思想找到了解决该问题的方法~~（其实我想了一晚上才发现的我太弱了QAQ~~

我们放开严格低于的左边界，放开严格高于判定的右边界，对于这两种情况其单侧石柱不予严格限制；

那么**预处理**就完成了

### 接下来我们考虑修改和查询操作：

查询操作就是单点查询数值（这个不用解释吧，每个点数值代表的是水面海拔达到这种高度时的山峰个数）

对于修改操作，其对答案的贡献依然在于打乱了原有石柱的秩序；

我们设某石柱两侧石柱高度较高的为mxw，较低的为miw；

对比如下两张图：

![](https://cdn.luogu.com.cn/upload/pic/16366.png)

![](https://cdn.luogu.com.cn/upload/pic/16368.png)

我们发现，某根石柱下降时，至多只会影响两个区间(new,miw]∪(mxw,pre]（当然影响不到我们就不考虑了）；同样地，某根石柱上升时也至多只会影响这两段区间。我们可以利用线段树的区间修改解决这个问题。

树状数组、zkw线段树维护差分也可以解决这个问题，建议各位尝试去写一下~~（反正我不写~~

我写了一个标记永久化的线段树；

上代码↓

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

const int MAXN=1<<18;

int n,m,x,y,z,maxh;
int add[MAXN<<2],h[MAXN];
struct rpg{
    int kd,h,id,to;
    int reh;
}p[MAXN<<1];

bool cmp1(rpg a,rpg b){
    return a.h<b.h;
}bool cmp2(rpg a,rpg b){
    return a.id<b.id;
}

void cadd(int k,int l,int r,int le,int ri,int x){
    if(le<=l&&r<=ri){
        add[k]+=x;
        return;
    }int i=k<<1,mid=l+r>>1;
    if(le<=mid) cadd(i,l,mid,le,ri,x);
    if(mid<ri) cadd(i|1,mid+1,r,le,ri,x);
}

int ask(int k,int l,int r,int p,int x){
    if(l==r) return add[k]+x;
    int i=k<<1,mid=l+r>>1;
    if(p<=mid) return ask(i,l,mid,p,x+add[k]);
    return ask(i|1,mid+1,r,p,x+add[k]);
}

void init(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i){
        scanf("%d",&x);
        p[i]=(rpg){0,x,i};
    }for(int i=1;i<=m;++i){
        scanf("%d",&x);
        if(x==1){
            scanf("%d",&y);
            p[i+n]=(rpg){1,y,i+n};
        }else{
            scanf("%d%d",&y,&z);
            p[i+n]=(rpg){2,z,i+n,y};
        }
    }return;
}

void reduce(){
    sort(p+1,p+n+m+1,cmp1);p[1].reh=1;
    for(int i=2;i<=n+m;++i){
        if(p[i].h==p[i-1].h) p[i].reh=p[i-1].reh;
        else p[i].reh=p[i-1].reh+1;
    }maxh=p[n+m].reh+1;sort(p+1,p+n+m+1,cmp2);
    for(int i=1;i<=n;++i) h[i]=p[i].reh;
    sort(p+1,p+n+1,cmp1);add[1]=1;
    for(int i=1;i<=n;++i){
        if(h[p[i].id-1]<=p[i].reh&&h[p[i].id+1]<p[i].reh){
            cadd(1,1,maxh,p[i].reh+1,maxh,-1);
        }if(h[p[i].id-1]>p[i].reh&&h[p[i].id+1]>=p[i].reh){
            cadd(1,1,maxh,p[i].reh+1,maxh,1);
        }
    }
	return;
}

void solve(){
    for(int i=n+1;i<=m+n;++i){
        if(p[i].kd==1){
            printf("%d\n",ask(1,1,maxh,p[i].reh,0));
        }else{
            int mxw=max(h[p[i].to-1],h[p[i].to+1]);
            int miw=min(h[p[i].to-1],h[p[i].to+1]);
            if(p[i].reh<h[p[i].to]){
                if(h[p[i].to]>mxw) cadd(1,1,maxh,max(p[i].reh,mxw)+1,h[p[i].to],-1);
                if(p[i].reh<miw) cadd(1,1,maxh,p[i].reh+1,min(miw,h[p[i].to]),1);
            }else if(p[i].reh>h[p[i].to]){
                if(h[p[i].to]<miw) cadd(1,1,maxh,h[p[i].to]+1,min(p[i].reh,miw),-1);
                if(p[i].reh>mxw) cadd(1,1,maxh,max(h[p[i].to],mxw)+1,p[i].reh,1);
            }h[p[i].to]=p[i].reh;
        }
    }return;
}

int main(){
    init();
    reduce();
    solve();
    return 0;
}
```

---

## 作者：getchar123 (赞：9)

# 离散化+树状数组
没看题的先看看题吧[题目传送门](https://www.luogu.org/problemnew/show/P3616)

首先，对于每一个询问的情况，都可以用一个01串表示，0表示未露出水面，1表示露出水面。样例第一个询问可表示为11010。接下来，可以分两部分来统计。第一部分统计有多少块石头露出水面，第二部分统计有多少块石头和它左边的石头都露出水面。第一部分-第二部分就可以得到段数了。
### 为什么能这样做呢？
手动模拟一下，就会发现相比于第一部分，第二部分没有统计每一段的左端点。减完后，得到的就是左端点的个数了。每个左端点对应一段，左端点数=段数。
### 实现方法
它里面不仅有查询，还有操作，所以可以用树状数组a，b维护前缀和，其中a查询i表示水高为i时露出水面块数，b查询i表示水高为i时有多少块石头和它左边的石头都露出水面。具体代码如下（需要用到树状数组的区间修改，单点查询，还不了解的去看看[树状数组模板2](https://www.luogu.org/problemnew/show/P3368)）： 

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,q,lsh[400002],czsz[200001][3],ysxl[200002],tail=1,n1,ysxl1[200002];
int a[400002],b[400002];
bool gz(int x,int y){
	return x<y;
}
void xg(int x,int y){//a修改 
	if(x<=0)return;
	while(x<=tail){
		a[x]+=y;
		x+=x&-x;
	}
	return;
}
int cx(int x){//a查询 
	int ans=0;
	while(x>0){
		ans+=a[x];
		x-=(x&-x);
	}
	return ans;
}
void xg_(int x,int y){//b修改 
	if(x<=0)return;
	while(x<=tail){
		b[x]+=y;
		x+=x&-x;
	}
	return;
}
int cx_(int x){//b查询 
	int ans=0;
	while(x>0){
		ans+=b[x];
		x-=(x&-x);
	}
	return ans;
}
int lshh(int x){//离散化（其实可以用C++ STL map实现） 
	int l=0,r=tail,mid;
	while(l<=r){
		mid=(l+r)/2;
		if(lsh[mid]>x){
			r=mid-1;
		}
		else{
			l=mid+1;
		}
	}
	return r;
}
void xgg(int x,int y){//修改 
	xg(ysxl1[x]+1,1);
	xg(y+1,-1);
	xg_(min(ysxl1[x-1],ysxl1[x])+1,1);
	xg_(min(ysxl1[x-1],y)+1,-1);
	xg_(min(ysxl1[x+1],ysxl1[x])+1,1);
	xg_(min(ysxl1[x+1],y)+1,-1);
	ysxl1[x]=y;
	return;
}
int main(){
	cin>>n>>q;
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		ysxl[i]=a[i];
	}
	for(int i=1;i<=q;i++){
		scanf("%d%d",&czsz[i][0],&czsz[i][1]);
		if(czsz[i][0]==2){
			scanf("%d",&czsz[i][2]);
			a[i+n]=czsz[i][2];
		}
		else{
			a[i+n]=czsz[i][1];
		}
	}
	sort(a+1,a+1+n+q,gz);
	n1=n+q;
	for(int i=1;i<=n1;i++){//离散化 
		lsh[tail]=a[i];
		if(a[i]!=a[i+1]){
			tail++;
		}
	}
	memset(a,0,sizeof(a));//数组回收利用 
	for(int i=1;i<=n;i++){
		ysxl[i]=lshh(ysxl[i]);
	}
	for(int i=1;i<=n;i++){
		xgg(i,ysxl[i]); 
	}
	for(int i=1;i<=q;i++){
		if(czsz[i][0]==1){
			czsz[i][1]=lshh(czsz[i][1]);
			printf("%d\n",cx(czsz[i][1])-cx_(czsz[i][1]));
		}
		else{
			xgg(czsz[i][1],lshh(czsz[i][2]));
		}
	}
	return 0;
}
```
还有需要注意的是：离散化和树状数组从1开始，否则会卡死循环。

### -end-




---

## 作者：zyc2003 (赞：8)

##### 本篇题解思路来源于本人集训时，一次模拟赛中某道变式题目的题解

### 前置知识:

1. 线段树
1. 离散化

有了以上知识的基础，我们才能高效地解决本道题目。若对以上知识点不熟悉，建议先做题巩固，再来尝试此题，会更有收获。下面的内容建立在熟悉以上知识点的基础上，不再对一些名词进行解释。

概述题目大意。题目给定一个数列，要求我们使用一种数据结构，支持**修改、查询**操作。修改时对数列进行**单点修改**，查询时，给定一个数值 $\red X$ ,求这个数列中有几个 **"岛屿"** 。此处 **"岛屿"** 定义为一段**连续子区间**,令这个**连续子区间(闭区间)** 的数值集合为 $S$ ,左端点为 $\red L$ ,右端点为 $\red R$ ；该数列为 $Num$ , 左端点为 $1$ ,右端点为 $n$ 。则对于每一个满足条件的子区间,都有 : $\forall$   $\red Y$ $\in$ $S$ , $\red Y$ $\ge$ $\red X$ ,并且满足 : $Num[\red L-1]$ $<$ $\red X$ 或 $\red L-1 < 1$ , $Num[\red R+1] < \red X$ 或 $\red R + 1 > n $。

通俗来讲，就是我们平常看到的岛屿一样，岛屿在水面上，要求我们求出岛屿的数量。

#### 因此，我们将问题划分为几个子任务：

-------------

$A.$ 使得程序能判断什么是 **"岛屿"** , 且不会重复判断

$B.$ 使用一种数据结构,支持查询 **"岛屿"** 的数量

$C.$ 使用一种数据结构,能维护 **"岛屿"** 的数量

----------
朴素的，我们可以不使用数据结构，对于每次询问，暴力扫描一遍数列 , 若某个位置的数值大于当前水位线的数值 , 并且该位置的前一个位置的数值小于当前水位线的数值 , 我们令**岛屿**的数量加一。这样，我们就只在进入岛屿**左端点**时更新岛屿数量，在**岛屿中间与右端点**时不更新，就能够不重复计算**岛屿**数量。对于每一次修改，直接在数列上修改即可。

由此，我们就解决了 **子任务**$A$ 。但这样的时间复杂度近似为 $O(n^2)$  , 在本题会超时。因此我们需要一种数据结构来优化。显然的,支持 **查询与修改** 的数据结构有很多，我在此处使用线段树维护。

首先，在尚无修改操作前，我们需要把初始序列的信息插入线段树。但是我们不能直接插入，因为线段树没有一种操作能直接支持查询 **“岛屿”** 的数量。但是我们不难发现，由上面朴素算法的思路，有：

##### **对于每一个可能为岛屿左端点的位置，它的前一个位置的数值必然严格小于它的数值，即：**
$Num[\red L] > Num[\red L - 1] $

在这里 , 我们约定 $Num[0] = 0 $ , $Num[n+1] = 0 $这样就避免了判断越界的麻烦。由于数据范围的约定，这样的操作正确性是显然的，因为数列的左端点必然可能成为某个岛屿的左端点，数列的右端点的下一个位置不在数列中，不会成为左端点。

因此，我们令线段树的叶节点所代表的**区间**为 $[\red L , \red L]$ , 数值为 $Val$ 。它指的是 , 在水位线为 $\red L$ 时 , 数列中会有 $Val$ 个岛屿。所以，对于**所有的** $Num[\red L] > Num[\red L - 1] $ ，我们在线段树上,对 **区间** $[Num[\red L - 1] + 1 , Num[\red L ]]$ 进行**区间加一**操作。在水位线的数值在这个区间时，$\red L$ 都会成为某个岛屿的左端点。而若水位线的高度为 $Num[\red L-1]$ , 则左端点会变成 $\red L-1$  , 因此，我们进行**区间加**的范围是从 $[Num[\red L - 1] + 1]$ 开始的。

当扫描完整个数列并进行区间加操作后，对于输入的水位线，只要查找该水位线的数值所对应的叶子节点的 $ Val$ ，就可以得到岛屿的数量。这样，我们就解决了 **子任务**$B$ 。那么，我们如何支持修改操作呢？

我们当然可以进行分类讨论，判断当前修改造成的影响。但是这样的操作过于麻烦，类似考虑不全面的失误很容易发生。因此，我们可以将原本的修改操作，等价于在该位置先删除原来的数值，再插入一个新的数值，即：

##### **先消除该位置对岛屿数量的贡献，再添加该位置新数值对岛屿数量的贡献**

举个例子,我们已经有一个序列 $Num$ , 我们想将原本 $Num[2] = 3$ , 修改为 $Num[2] = 5$ :


![](https://cdn.luogu.com.cn/upload/image_hosting/v5exyz7u.png?x-oss-process=image/resize,m_lfit,h_1800,w_1000)

上面图片中的操作便是 , 对于 $[Num[1]+1 , Num[2]]$ 与 $[Num[2]+1,Num[3]]$ 进行区间减$1$操作 , 因为原先的 $Num[2]$ 对这两个区间都有贡献。注意 : 当进行区间减操作后 , 此时的叶子结点的值并不是数列中岛屿的数量。因为我们**是消除了 $Num[2]$** 的贡献 , 而不是代表此时 $Num[2]$ 的值为 $0$ 。当我们进行添加 $Num[2]$ 的值时 , 应像之前一样考虑它的贡献 , 因此我们只对 $[Num[1]+1,Num[2]]$ 区间进行区间加$1$操作。至此，**子任务**$C$ 得到解决。

但我们的任务还没有完成 , 考虑到水位高度的范围是 $ 1 \le B_j \le 10^9$ , 我们需要对高度进行离散化。但是我们不能读入完数列信息后，就直接进行离散化。因为在之后的**查询与修改**操作中，可能会出现与数列中数值都不相同的**查询与修改**操作。所以，我们需要读入所有操作后，记录所有出现过的水位高度与岩石高度，再进行离散化操作。因此，算法是离线的。

至此，问题得到解决。在写代码时，需要注意一下几点：

1. 我们不用记录区间和。我们只需要维护叶子结点的值，所以我们不用上传，且懒标记在下传时操作会有所不同。
2. 我使用了宏定义进行操作。若您不熟悉宏定义，可以查询宏定义的用法，以后写题时可经常使用，十分方便（但也很容易出锅）

下面是代码，仅供参考：

````cpp
#include<iostream>
#include<memory.h>
#include<algorithm>
#include<cstdio>
using namespace std;
#define N 201010
#define mid ((l+r)>>1)
#define L T[id].ls
#define R T[id].rs
//此处使用宏定义,便于操作 
 
int n,m;
int Num[N];//高度数组 
struct node1
{
	int opt;
	int b,c,d;
}Opt[N];//操作数组 , b、c、d的含义与题目相同 
int Map[N<<2],tot=0;//离散化数组 
struct node2
{
	int ls,rs;
	int tag;
	int Val;
}T[N<<3];//线段树数组 
//-----------------------------------------------
int find(int x)
{
	return lower_bound(Map+1,Map+1+tot,x) - Map ;
}
//查询离散化后的数值 
//-----------------------------------------------
inline void pushdown(int id)
{
	if(!T[id].tag)
		return ;
	T[L].tag+=T[id].tag;
	T[R].tag+=T[id].tag;
	T[L].Val+=T[id].tag;
	T[R].Val+=T[id].tag;
	T[id].tag=0;
	return ;
}
//下传标记 
void build(int id,int l,int r)
{
	if(l == r)
		return ;
	L=id<<1;
	R=id<<1|1;
	build(L,l,mid);
	build(R,mid+1,r);
	return ;
}
//建树 
void update(int id,int l,int r,int ql,int qr,int val)
{
	if(ql <= l and qr >= r)
	{
		T[id].tag+=val;
		T[id].Val+=val;
		return ;
	}
	pushdown(id);
	if(ql <= mid)
		update(L,l,mid,ql,qr,val);
	if(qr > mid)
		update(R,mid+1,r,ql,qr,val);
	return ;
}
//更新答案 
int query(int id,int l,int r,int loc)
{
	if(l == r)
		return T[id].Val;
	pushdown(id);
	if(loc <= mid)
		return query(L,l,mid,loc);
	else if(loc > mid)
		return query(R,mid+1,r,loc);
}
//单点查询 
//-----------------------------------------------
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&Num[i]);
		Map[++tot]=Num[i];
	}
	for(int i=1;i<=m;i++)
	{
		//此处的opt不会与结构体里的opt冲突,其它同理 
		int opt;
		int b,c,d;
		scanf("%d",&opt);
		if(opt == 1)
		{
			scanf("%d",&b);
			Opt[i].opt=opt,Opt[i].b=b;
			Map[++tot]=b;
		}
		else
		{
			scanf("%d%d",&c,&d);
			Opt[i].opt=opt,Opt[i].c=c,Opt[i].d=d;
			Map[++tot]=d;
		}
	}
	//离线处理 
	sort(Map+1,Map+1+tot);
	tot = unique(Map+1,Map+1+tot) - Map - 1;
	//排序去重
	
	for(int i=1;i<=n;i++)
		Num[i]=find(Num[i]);
	for(int i=1;i<=m;i++)
	{
		if(Opt[i].b)
			Opt[i].b=find(Opt[i].b);
		if(Opt[i].d)
			Opt[i].d=find(Opt[i].d);
	}
	//将数据处理为离散化之后的数据
	build(1,1,tot);
	//建树 
	for(int i=1;i<=n;i++)
		if(Num[i] > Num[i-1])
			update(1,1,tot,Num[i-1]+1,Num[i],1);
	//初始答案 
	for(int i=1;i<=m;i++)
	{
		int opt=Opt[i].opt,b=Opt[i].b,c=Opt[i].c,d=Opt[i].d;
		if(opt == 1)
			printf("%d\n",query(1,1,tot,b));
		else if(opt == 2)
		{
			if(Num[c] > Num[c-1])
				update(1,1,tot,Num[c-1]+1,Num[c],-1);
			if(Num[c+1] > Num[c])
				update(1,1,tot,Num[c]+1,Num[c+1],-1);
			//消除原先贡献 
			Num[c]=d;
			if(Num[c] > Num[c-1])
				update(1,1,tot,Num[c-1]+1,Num[c],1);
			if(Num[c+1] > Num[c])
				update(1,1,tot,Num[c]+1,Num[c+1],1);
			//添加当前贡献 
		}
	}
	return 0;
}

````

























---

## 作者：KemononeRou (赞：5)

怎么题解区里都是树状数组和线段树维护贡献啊（

单 $\log$ 做法太高妙了不会怎么办啊，来个分块（

对于每次询问的 $x$，令 $b_i = [a_i < x]$，那么要统计的就是 $b$ 中极长连续的 $0$ 的连续段数量。

先来想想假如没有修改该怎么做。

对于询问，可以考虑按照 $x$ 排序。

一开始 $b_i$ 全都是 $1$，每次询问将新的小于当前 $x$ 的数赋成 $0$，然后维护对答案产生的贡献。

发现每次答案的变化量不超过 $1$，所以能够 $O(1)$ 维护。

离散化并排序后可以做到 $O(n + m)$ 求出答案。

考虑对操作序列分块，块长为 $B$，每 $B$ 次操作一起处理。

这些操作中，会有 $O(B)$ 次询问和 $O(B)$ 次修改。

考虑先将询问按照没有修改的方法做，将原序列的 $b_i$ 修改完后，再将这次询问前的修改都做一遍，得到答案后撤销这些修改操作。

分析一下跑一遍的复杂度：

重构序列 $O(n)$，排序 $O(B\log{B})$，每次询问的修改 $O(B)$，修改原序列的复杂度 $O(n+m)$，跑一遍的总复杂度大概是 $O(n+m+B^2)$。

一共要跑 $\dfrac{m}{B}$ 遍，所以整个算法的复杂度是 $O(\dfrac{m(n+m)}{B}+mB)$。

由于常数原因（？），[这份代码](https://www.luogu.com.cn/paste/f1mdmur1)需要开 O2 在 $B=m^{0.7}$ 左右才能通过。

---

## 作者：communist (赞：5)

#### ~~不知道为什么是紫色的（手动滑稽）~~

我们首先考虑一块石头高度变化对每个高度的查询的答案的影响，

即**我们要记录，对于每个高度的查询的答案**

#### 所以要离散化高度（不然哪开的下数组啊）

不难发现，一次变化的对于不同高度的影响，对于一段连续高度是相同的

#### 即一次修改操作，对于一段连续高度的答案，影响相同，满足区间修改性质

就决定是你了，树状数组

具体来说，考虑修改位置修改前后和两边的高度关系

但是情况很多，不妨把**修改操作换成先删除（把高度降为0），再插入**

考虑删除，插入的话，反过来就好，中间的是删除位置

#### 情况1：中间比两边低

![](https://cdn.luogu.com.cn/upload/pic/38868.png)

最简单的情况，不难发现，删除掉中间的只能让高度为$part1$的区间的答案$+1$，因为它割裂了两边的连续区间

#### 情况2：中间比两边高

![](https://cdn.luogu.com.cn/upload/pic/38869.png)

最高的区间影响就很广了

对于$part1:$它的删除会割裂两边的区间$val~of~part1++$

对于$part2:$因为两边没有构成连续区间，所以没有影响

对于$part3:$原来是有露出来的，现在没了，当然要减掉了

#### 情况3：中间的高度也中等

![](https://cdn.luogu.com.cn/upload/pic/38875.png)

也很简单了，只对$part1$有影响

#### 然而这样处理的只是答案的变化，我们还需要统计初始答案

还是考虑高度变化对答案的影响，不难发现，随着高度上升，未被覆盖的点的个数是单调不升的

按高度开$vector$，把每个高度恰好被覆盖的所有位置扔进去

从小到大枚举高度，先将这个高度的答案设为上一个高度的答案，取出这个高度恰好被覆盖的所有位置，统计这个位置的影响

如果它比两边高，类比上面情况2，答案减一

低呢，答案加一

这样我们就解决了这个问题

#### 上代码：

```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
using namespace std;
const int maxn=2e5+10;
vector<int>v[2*maxn];
int pre[2*maxn],n,m,a[maxn],mp[2*maxn],op[maxn],cnt,b[maxn],d[maxn],c[2*maxn];
bool vis[2*maxn];
int lowbit(int x)
{
    return x&-x;
}
int sum(int x)
{
    int ret=0;
    while(x)
    {
        ret+=c[x];
        x-=lowbit(x);
    }
    return ret;
}
void add(int x,int ch)
{
    while(x<=cnt)
    {
        c[x]+=ch;
        x+=lowbit(x);
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
        mp[++cnt]=a[i];
    }
    for(int i=1;i<=m;i++)
    {
        scanf("%d",&op[i]);
        if(op[i]==1)
            scanf("%d",&b[i]),mp[++cnt]=b[i];
        else
            scanf("%d%d",&d[i],&b[i]),mp[++cnt]=b[i];
    }
    sort(mp+1,mp+cnt+1);
    cnt=unique(mp+1,mp+cnt+1)-mp-1;
    for(int i=1;i<=n;i++)
    {
        a[i]=lower_bound(mp+1,mp+cnt+1,a[i])-mp;
        v[a[i]+1].push_back(i);
    }
    for(int i=1;i<=m;i++)
        b[i]=lower_bound(mp+1,mp+cnt+1,b[i])-mp;
    pre[1]=1,vis[0]=vis[n+1]=1;
    for(int i=2;i<=cnt;i++)
    {
        pre[i]=pre[i-1];
        for(int j=0;j<v[i].size();j++)
        {
            int u=v[i][j];
            vis[u]=1;
            if(!vis[u-1]&&!vis[u+1])
                pre[i]++;
            else if(vis[u-1]&&vis[u+1])
                pre[i]--;
        }
    }
    for(int i=1;i<=m;i++)
    {
        if(op[i]==1)
            printf("%d\n",pre[b[i]]+sum(b[i]));
        else
        {
            int tmp[5];
            tmp[1]=a[d[i]-1],tmp[2]=a[d[i]],tmp[3]=a[d[i]+1];
            sort(tmp+1,tmp+4);
            if(a[d[i]]>=a[d[i]-1]&&a[d[i]]>=a[d[i]+1])
                add(tmp[2]+1,-1),add(tmp[3]+1,1);
            add(1,1),add(tmp[1]+1,-1);
            tmp[1]=a[d[i]-1],tmp[2]=b[i],tmp[3]=a[d[i]+1];
            sort(tmp+1,tmp+4);
            if(b[i]>=a[d[i]-1]&&b[i]>=a[d[i]+1])
                add(tmp[2]+1,1),add(tmp[3]+1,-1);
            add(1,-1),add(tmp[1]+1,1);
            a[d[i]]=b[i];
        }
    }
    return 0;
}
```

---

## 作者：bztMinamoto (赞：5)

宣传一发[blog](https://www.cnblogs.com/bztMinamoto/p/9369585.html)

话说模拟赛的时候这题打个暴力骗了50分

然后去网上找题解的时候愣是没一个能看懂的

最后找了份代码瞪了三个小时才明白是怎么回事

还是来详细的讲讲好了

首先，考虑暴力，扫一遍数组，如果$h[i-1]<H<=h[i]$,那么就++ans

然后我们先撇开询问不管，根据上述式子可以得出，如果$h[i-1]<h[i]$，那么$(h[i-1],h[i]]$之间的答案都会加一，这是一个典型的区间修改，我们可以用线段树实现

最后，考虑询问和修改。询问的话，直接在线段树上单点查询。至于修改操作，我们可以发现，一个点被修改之后，和$h[i-1]$以及$h[i+1]$之间的关系发生改变，影响了答案，所以改之前把之前答案的影响删去就好

ps：最后有个小细节，我们是按高度建线段树，所以必须进行离散

```
// luogu-judger-enable-o2
//minamoto
#include<bits/stdc++.h>
#define N 400005
using namespace std;
#define getc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<15,stdin),p1==p2)?EOF:*p1++)
char buf[1<<15],*p1=buf,*p2=buf;
inline int read(){
    #define num ch-'0'
    char ch;bool flag=0;int res;
    while(!isdigit(ch=getc()))
    (ch=='-')&&(flag=true);
    for(res=num;isdigit(ch=getc());res=res*10+num);
    (flag)&&(res=-res);
    #undef num
    return res;
}
int sum[N<<2|1],tag[N<<2|1];
struct node{
    int h,id;
    bool operator <(const node &b)const
    {return h<b.h;}
}a[N<<1|1];
int h[N<<1|1],x[N<<1|1],k[N<<1|1];
int n,m,mx;
void pushdown(int p){
    if(!tag[p]) return;
    int lson=p<<1,rson=p<<1|1;
    sum[lson]+=tag[p],sum[rson]+=tag[p];
    tag[lson]+=tag[p],tag[rson]+=tag[p];
    tag[p]=0;
}
void change(int p,int l,int r,int ql,int qr,int x){
    if(ql<=l&&qr>=r){
        sum[p]+=x,tag[p]+=x;return;
    }
    pushdown(p);
    int mid=(l+r)>>1;
    if(ql<=mid) change(p<<1,l,mid,ql,qr,x);
    if(qr>mid) change(p<<1|1,mid+1,r,ql,qr,x);
}
int query(int p,int l,int r,int x){
    if(l==r) return sum[p];
    pushdown(p);
    int mid=(l+r)>>1;
    if(x<=mid) return query(p<<1,l,mid,x);
    else return query(p<<1|1,mid+1,r,x);
}
int main(){
    //freopen("testdata.in","r",stdin);
    n=read(),m=read();
    for(int i=1;i<=n;++i)
    a[i].h=read(),a[i].id=i;
    for(int i=n+1;i<=n+m;++i){
        k[i]=read();
        if(k[i]==2) x[i]=read();
        a[i].h=read();
        a[i].id=i;
    }
    sort(a+1,a+1+n+m);h[a[1].id]=1;
    for(int i=2;i<=n+m;++i)
    h[a[i].id]=a[i].h>a[i-1].h?h[a[i-1].id]+1:h[a[i-1].id];
    mx=h[a[n+m].id];
    for(int i=1;i<=n;++i)
    if(h[i-1]<h[i]) change(1,1,mx,h[i-1]+1,h[i],1);
    for(int i=n+1;i<=n+m;++i){
        if(k[i]==2){
            int t=x[i];
            if(h[t-1]<h[t])change(1,1,mx,h[t-1]+1,h[t],-1);
            if(t!=n&&h[t]<h[t+1])change(1,1,mx,h[t]+1,h[t+1],-1);
            h[t]=h[i];
            if(h[t-1]<h[t])change(1,1,mx,h[t-1]+1,h[t],1);
            if(t!=n&&h[t]<h[t+1])change(1,1,mx,h[t]+1,h[t+1],1);
            
        }
        else printf("%d\n",query(1,1,mx,h[i]));
    }
    return 0;
}
```

---

## 作者：s_r_f (赞：3)

因为值域是$10^9,$但是有用的值只有$O(n+m)$个$,$所以可以把值域离散化到$4 *10^5.$

我们令高度数组为$h[],$即$h[i] = i$的高度。

我们考虑维护一个数组$f[],$其中$f[i]$ 表示 **当水的海拔高度为$i$时的答案。**

我们把 $1 - n$ 这 $n$ 块岩石看成 $n$ 个点$,$把相邻两个点$x,x-1$连边$(x,x-1)$。

询问问的是有多少联通块$,$稍加分析即可得出: **联通块个数 $=$ 点数 $-$ 边数**

那么$f[i]$就可以表示成 $:$ 

$($当水的海拔高度为$i$时$,$**存在的**点数$)$ $-$ $($当水的海拔高度为$i$时$,$**存在的**边数$)$

点$x$存在的条件为$h_x>=i$

边$(x,x-1)$存在的条件是 $h_x>=i$ 且 $h_{x-1}>=i$ 也就是 $min(h_x,h_{x-1}) >= i$

所以$,$点$x$对答案产生的影响：把所有$1 <= i <= h_x$的$f[i]++$

边$(x,x-1)$对答案产生的影响：把所有$1 <= i <= min(h_x,h_{x-1})$的$f[i]--$

也就是说$,$点可以看成对$f[]$的一个前缀加操作,边可以看成对$f[]$的一个前缀减操作。

所以$,$使用树状数组维护$f[]$的差分数组  即可在$O(log(n+m))$的时间内完成增加$/$删除 点$/$边的操作,并且可以支持$O(log(n+m))$的时间内完成一次对$f[i]$的单点查询。

考虑完上面的内容$,$修改操作就很简单了$,$对一个点$u$进行修改$,$

我们只需要先撤销修改之前点$u$,和边$(u,u+1),(u,u-1)$对答案的影响$,$

然后修改$h_u$,再重新加入点$u$,和边$(u,u+1),(u,u-1)$对答案的影响即可。

复杂度$O((n+m)log(n+m))$

代码:
```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read(){
    int x = 0; char c = getchar();
    while (!isdigit(c)) c = getchar();
    while (isdigit(c)) x = x * 10 + c - '0',c = getchar();
    return x;
}
inline void write(int x){ if (x < 0) putchar('-'),x = -x; if (x > 9) write(x/10); putchar(x%10+'0'); }
const int N = 200005,M = 200005;
struct BIT{
	int n,d[N+M];
	inline void init(int nn){ n = nn; }
	inline void Add(int x){ if (!x) x = 1; while (x <= n) ++d[x],x+=x&-x; }
	inline void Dev(int x){ if (!x) x = 1; while (x <= n) --d[x],x+=x&-x; }
	inline void Ask(int x,int &r){ r=0; while (x) r+=d[x],x-=x&-x; }
}T;
int v[N+M],lv,n,m,ans,a[N],op[M],b[M],c[M],d[M],h[N];
inline void Modify(int i,int vv){
	T.Add(h[i]); T.Dev(vv);
	if (i>1) T.Dev(min(h[i-1],h[i])),T.Add(min(h[i-1],vv));
	if (i<n) T.Dev(min(h[i+1],h[i])),T.Add(min(h[i+1],vv));
	h[i] = vv;
}
int main(){
	int i;
	n = read(),m = read();
	for (i = 1; i <= n; ++i) a[i] = read() + 1,v[++lv] = a[i];
	for (i = 1; i <= m; ++i){ op[i] = read(); if (op[i] == 1) b[i] = read(),v[++lv] = b[i]; else c[i] = read(),d[i] = read() + 1,v[++lv] = d[i]; }
	sort(v+1,v+lv+1); lv = unique(v+1,v+lv+1)-v-1; T.init(lv);
	for (i = 1; i <= n; ++i) a[i] = lower_bound(v+1,v+lv+1,a[i])-v;
	for (i = 1; i <= m; ++i) if (op[i] == 1) b[i] = lower_bound(v+1,v+lv+1,b[i])-v; else d[i] =lower_bound(v+1,v+lv+1,d[i])-v;
	for (i = 1; i <= n; ++i) Modify(i,a[i]);
	for (i = 1; i <= m; ++i) if (op[i] == 1) T.Ask(b[i],ans),write(ans),putchar('\n'); else Modify(c[i],d[i]);
	return 0;
}
```

---

## 作者：Lin1043 (赞：3)

我用的也是树状数组 + 离散化 +离线

把原来的海拔和操作后的海拔都读进来，离散化后将这个值排序后的位置作为权值

然后在初始的海拔找出山峰和低谷（即$A_i > A_{i-1} && A_i > A_{i+1} $或$A_i < A_{i-1} && A_i < A_{i+1} $）

可以发现一个海拔以上的连续的 = 山峰的数量 - 低谷的数量

然后就可以用树状数组来统计了

对一个点修改的时候要注意这个点和它两侧的点，看他们是否会变成山峰或低谷

跟楼下的孔爷交流了一下，发现貌似是对的（还有海拔相同的需要处理一下）

~~至于为什么没代码，因为我太弱了，只有思路完全调不出来，希望dalao们帮我补上~~


---

## 作者：5k_sync_closer (赞：2)

连通块数 $=$ 点数 $-$ 边数。

水面海拔为 $x$ 时，点集为海拔 $\ge x$ 的点，所以点数为 $\sum\limits_{i=1}^n[a_i\ge x]$，

两点之间有边，当且仅当两点相邻且两点海拔均 $\ge x$，所以边数为 $\sum\limits_{i=1}^{n-1}[\min(a_i,a_{i+1})\ge x]$，

每次单点修改只会影响一个 $a_i$ 和两个 $\min(a_i,a_{i+1})$，平衡树维护 $a_i$，$\min(a_i,a_{i+1})$ 的集合即可。

```cpp
#include <cstdio>
#include <utility>
#include <algorithm>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#define P pair<int, int>
using namespace std;
using namespace __gnu_pbds;
int n, m, a[300050];
struct S
{
    int c;
    tree<P, null_type, less<P>, rb_tree_tag, tree_order_statistics_node_update> T;
    void I(int x) { T.insert({x, ++c}); }
    void D(int x) { T.erase(T.lower_bound({x, 0})); }
    int Q(int x) { return T.order_of_key({x, 0}); }
} c, d;
int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++i)
        scanf("%d", a + i), d.I(a[i]);
    for (int i = 2; i <= n; ++i)
        c.I(min(a[i], a[i - 1]));
    for (int i = 0, o, x, y; i < m; ++i)
    {
        scanf("%d%d", &o, &x);
        if (o & 1)
            printf("%d\n", c.Q(x) - d.Q(x) + 1);
        else
        {
            scanf("%d", &y);
            d.D(a[x]);
            if (x > 1)
                c.D(min(a[x], a[x - 1]));
            if (x < n)
                c.D(min(a[x], a[x + 1]));
            d.I(a[x] = y);
            if (x > 1)
                c.I(min(a[x], a[x - 1]));
            if (x < n)
                c.I(min(a[x], a[x + 1]));
        }
    }
    return 0;
}
```


---

## 作者：Sakura_梦瑶 (赞：1)

对于数据结构题目不能用数据结构想题,应该用题想数据结构,虽然这题已经有线段树标签,但由于题目约束少直接硬想线段树也应该可以较快想出。


------------

设若我们直接对石头的海拔直接进行维护应该难以统计答案，既然我们被询问的是各个海拔情况情况下的答案,考虑就直接对这个进行维护,细节比较多,要仔细考虑每块石头在递增递减情况下产生高度变化对答案的影响,于是我们就可以直接线段树维护.


------------

下面是代码,由于是早期写的代码,今天突然来写个题解,很多特殊处理都写得又长又丑；
```
#include<bits/stdc++.h>
#define left l,mid,tr[pos].ls
#define righ mid+1,r,tr[pos].rs
#define use 1,1000000000,root
using namespace std;
struct qq{int ls,rs,key;}tr[200000*25];int n,m,a[200100],cnt,flag=1,ans,x; 
inline int maxx(int pos,int ans){if(pos<=ans)return ans;else return pos;}
inline int minn(int pos,int ans){if(pos<=ans)return pos;else return ans;}
void sak_tr(int l,int r,int &pos,int ql,int qr){
	if(!pos)pos=++cnt;if(l==ql&&r==qr){tr[pos].key+=flag;return;}int mid=l+r>>1;
	if(mid>=qr)sak_tr(left,ql,qr);else if(mid<ql)sak_tr(righ,ql,qr);
	else sak_tr(left,ql,mid),sak_tr(righ,mid+1,qr);
}
void sak_qu(int l,int r,int pos){
	ans+=tr[pos].key;if(!pos||l==r)return;
	int mid=l+r>>1;
	if(mid>=x)sak_qu(left);else sak_qu(righ);
}
int main(){//预处理初始情况下的答案 
	cin>>n>>m;int las=0,num,ma,root=0,mi,c; 
	for(int i=1;i<=n;i++){
		scanf("%d",a+i);
		if(a[i]>las)sak_tr(use,las+1,a[i]);
		las=a[i];
	}
	for(int i=1;i<=m;i++){
		scanf("%d%d",&c,&x);
		if(c==1)ans=0,sak_qu(use),printf("%d\n",ans);
		else{
			scanf("%d",&num);if(num==a[x]){a[x]=num;continue;}
			ma=maxx(a[x+1],a[x-1]),mi=minn(a[x+1],a[x-1]); 
			if(num<=ma&&num>=mi&&a[x]<=ma&&a[x]>=mi){a[x]=num;continue;}//相等情况 
			if(a[x]>ma){
				if(num<a[x]){flag=-1;
					if(num>ma)sak_tr(use,num+1,a[x]);
					else sak_tr(use,ma+1,a[x]);
					if(num<mi)flag=1,sak_tr(use,num+1,mi);
				}
				else flag=1,sak_tr(use,a[x]+1,num);
			}
			else {
				if(num>a[x]){flag=-1;
					if(num>=mi&&a[x]<mi)sak_tr(use,a[x]+1,mi);
					else if(num<=mi&&a[x]<mi)sak_tr(use,a[x]+1,num);
					if(num>ma)flag=1,sak_tr(use,ma+1,num);
				}
				else {
					if(a[x]<=mi)flag=1,sak_tr(use,num+1,a[x]);
					else flag=1,sak_tr(use,num+1,mi);
				}
			}a[x]=num;
		}
	}
} 
```


---

## 作者：Meteor_ (赞：0)

# P3616 富金森林公园 题解

## 题意

给你 $n$ 个点，有 $m$ 次操作，每次操作可以改变一个数的值，也可以查询有多少连续的块，满足这个块内的所有数的值都大于查询的值。

## 分析

还是比较容易想到用数据结构或分块的，毕竟有同时存在修改和查询操作。但是维护什么？怎么维护？

既然我们无法直接维护答案，那我们去考虑答案有什么性质，能不能通过维护好几个东西给他 ~~乱搞~~ 出来。然后 ~~看完题解后~~ 就会了。

## 题解

分析一下性质。

先将相邻两个点间的边权赋值为这两个点的较小值，并设当前要查询的值（题里的海拔高度）为 $x$。通过手玩样例，我们发现，对于每一个块，块中点权小于 $x$ 的点数 $-$ 块中边权小于 $x$ 的边数 $= 1$。那么我们就可以通过维护整个数列中的点权，以及整个数列中的边权来迅速求得块数。即，点权小于 $x$ 的点数 $-$ 块中边权小于 $x$ 的边数 $=$ 块数。那么就好说了，什么树状数组、线段树随便上就好了。

这里我选择的是常数小还好打的树状数组。

## 代码

```cpp
//P3616 富金森林公园
#include <bits/stdc++.h>
#define M 200005

using namespace std;

inline int read() {
    int x = 0, s = 1;
    char ch = getchar();
    while(ch < '0' || ch > '9') {
        if(ch == '-')
            s = -s;
        ch = getchar();
    }
    while(ch >= '0' && ch <= '9') {
        x = (x << 3) + (x << 1) + ch - '0';
        ch = getchar();
    }
    return x * s;
}

void write(int x) {
    if(x < 0)  {
        x = ~(x - 1);
        putchar('-');
    }
    if(x > 9)
        write(x / 10);
    putchar(x % 10 + 48);
}

int n, m, a[M], w[M << 1], len, tree1[M << 1], tree2[M << 1];

struct Q {
    int opt;
    int b;
    int c;
    int d;
}q[M];

inline int lowbit(int x) {return x & (-x);}

inline void add(int pos, int addend) {
    for(int i = pos; i <= len; i += lowbit(i))
        tree1[i] += addend;
}

inline void add_edge(int pos, int addend) {
    for(int i = pos; i <= len; i += lowbit(i))
        tree2[i] += addend;
}

inline int ask (int pos) {
    int ans = 0;
    for(int i = pos; i > 0; i -= lowbit(i))
        ans += tree1[i];
    return ans;
}

inline int ask_edge (int pos) {
    int ans = 0;
    for(int i = pos; i > 0; i -= lowbit(i))
        ans += tree2[i];
    return ans;
}

signed main() {
    n = read();
    m = read();
    len = n + m;
    for(int i = 1; i <= n; ++ i)
        w[i] = a[i] = read();
    for(int i = 1; i <= m; ++ i) {
        q[i].opt = read();
        if(q[i].opt == 1) {
            q[i].b = read();
            w[n + i] = q[i].b;
        }
        else {
            q[i].c = read();
            q[i].d = read();
            w[n + i] = q[i].d;
        }
    }
    stable_sort(w + 1, w + len + 1);
    int l = unique(w + 1, w + 1 + len) - w - 1;
    for(int i = 1; i <= n ; ++ i )  {
        a[i] = lower_bound(w + 1, w + 1 + l, a[i]) - w;
        add(a[i], 1);
        if(i > 1)
            add_edge(min(a[i], a[i - 1]), 1);
    }
    for(int i = 1; i <= m; ++ i) {
        if(q[i].opt == 1) {
            q[i].b = lower_bound (w + 1, w + 1 + l, q[i].b) - w;
            write(ask_edge(q[i].b - 1) - ask(q[i].b - 1) + 1);
            putchar('\n');
        }
        else {
            int pos = q[i].c;
            q[i].d = lower_bound(w + 1, w + 1 + l, q[i].d) - w;
            add(q[i].d, 1);
            add(a[pos], -1);
            if(pos != 1) {
                add_edge(min(q[i].d, a[pos - 1]), 1);
                add_edge(min(a[pos], a[pos - 1]), -1);
            }
            if(pos != n) {
                add_edge(min(q[i].d, a[pos + 1]), 1);
                add_edge(min(a[pos], a[pos + 1]), -1);
            }
            a[pos] = q[i].d;
        }
    }
}
```

### 后记

（~~[放在最后的双倍经验](https://www.luogu.com.cn/problem/AT_joisc2016_d)~~）

那道题的题解里有讲的不错的分块做法，可以借鉴一下。

---

## 作者：Melting_Pot (赞：0)

很有意思的一道题，来水一篇：

- ## Analysis:
    首先，我们对于每一个连通块，都需要找到一个**特征值**来统计，思考一下就知道它是每个连通块的**左或右端点**，本文使用**左端点**来统计。

    进而，我们考虑对于每一种高度的答案分开统计，我们用 $0$ 代表在**当前高度下露出水面**的石柱，用 $1$ 表示**当前高度下被水淹没**的石柱，然后我们思考以下情况：

    约定：$H_i$ 轴代表高度，$X_i$ 轴表示石柱：

     $$\begin{matrix}
     H_6(0)&&0&0&0&0&0\\
     H_5(1)&&0&0&1&0&0\\
     H_4(1)&&0&0&1&1&1\\
     H_3(2)&&1&0&1&1&1\\
     H_2(1)&&1&1&1&1&1\\
     H_1(1)&&1&1&1&1&1\\\\
           &&X_1&X_2&X_3&X_4&X_5
     \end{matrix}$$

     我们考虑修改操作：对于 $X_i$ ，它的降低显然会对降低后对应的答案造成贡献，具体来说：当石柱 $X_i$ 降低时，我们分别考虑所有会变化的值（答案），如果当前 $H$ 下，减少的那个石柱的左右两边为空，则当前高度下连通块的数量减少 $1$，否则就增加 $1$，我们不妨手玩一下：

     假设当前 $X_3$ 减少到了 $H_1$ 那么原图转化为：

     $$\begin{matrix}
     H_6(0)&&0&0&0&0&0\\
     H_5(1-1)&&0&0&0&0&0\\
     H_4(1)&&0&0&0&1&1\\
     H_3(2)&&1&0&0&1&1\\
     H_2(1+1)&&1&1&0&1&1\\
     H_1(1)&&1&1&1&1&1\\\\
           &&X_1&X_2&X_3&X_4&X_5
     \end{matrix}$$

    我们发现：二维点对 $(X_3,H_5)$ 两边均无石柱，因此 $H_5$ 中的贡献减一为零，而 $(X_3,H_2)$ 的两边均有石柱，因此 $H_2$ 中的贡献加一为二。$(X_3,H_3)$ 与 $(X_3,H_4)$ 两边一边有石柱，一边没有，那么修改就对当前答案无贡献，因此 $H_3$ 与 $H_4$ 不变。

    到此我们已经找到了规律，我们很容易将其推广到石柱上升时的情况，那么对于以上修改时的三种情况：**两边均有，两边均无，一边有一边无**。我们就可以分讨实现修改了。

- ## Achieve：
    数据结构维护一下我们上文提到的 $H_i$，既然是高度，当然要离散化。然后，根据上面的手模，每次的答案更新不同，很麻烦，如何避免？我们考虑每次在修改前，将本次修改影响的答案区间贡献减一，再正常操作，不明白？我们再来手玩一下：

    还是上面我们提到的情况：将 $X_3$ 降低至 $H_1$，因为修改之前 $X_2$的高度 小于 $X_3$，所以我们先将 $H_{2+1}$ 即 $H_3$ 到 $H_5$ 的区间减一消除影响，再将 $X_3$ 修改至 $H_1$ 高度，此时 $X_3$ 的高度小于 $X_4$，能产生新的左端点，因此 $H_{1+1}$ 即 $H_2$ 到 $H_4$ 答案区间加一。至此，$H_3$ 和 $H_4$ 的影响抵消，我们完成了想要实现的修改操作。

    至于为什么区间修改时，要将左高度加一，这是因为本文选用**左端点**统计答案，左高度本身就能成为一个左端点。






---

## 作者：redegg (赞：0)

我们可以先想第一种做法，这种做法在高度各不相同时非常好写，我们找到山峰（大于相邻两边的高度），找到山谷（小于相邻两边的高度），我们把连续的一段露在水面外的叫做山好了。

那么容易发现，当一个山谷被淹没，意味着有一座山被隔开成了两座山了，那么山的数量$+1$，当一个山峰被淹没，则代表一个山的整座山都被淹了，答案$-1$。

那么我们只需要知道我们现在水位，统计一下山峰山谷数量就可以得到答案了。

但是！这题里面有高原和低谷（因为本题中高度有可能相同）！当一长串相同高度的石头出现时，我们该怎么处理呢？

接下来，我们需要换种思维了，山峰和相邻山谷间是单调的，如果相邻的山谷被淹没，那么水一定与山峰到被淹没的相邻山谷这段单调的山坡上有一个交点，并且整座山如果两边环水的话那就存在两个交点，假如我们设最左和最右的高度为最小，那么每座山一定存在两个交点。

那么我们换种思路，我们来把可能出现交点的高度地方记下来，那么我们询问水位的时候，直接可以求出这个高度下的交点数，交点数$/2$就是答案了。

怎么求相应高度的交点数呢？我们知道一段单调区间里面每一个高度上的交点只有一个，那么我们就找到最小的单调区间——也就是两个点$[i,i+1]$，为了避免重复给某个点的高度加上一个交点两次，那么我们就只考虑高度区间$[h[i]+1,h[i+1]]$，现在这个单调区间里面所有的高度都可以与水有个交点，那么直接上树状数组处理前缀和就好了。

那么我们每次更新只需要重新处理相邻两点就可以了，而查询时可以直接从树状数组中查出交点数，交点数除以$2$就是答案。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN=200005;

struct ha
{
    int val,id,c;
}u[2*MAXN];
int num,cnt;
bool cmp(const ha &aa,const ha &bb)
{
    return aa.val<bb.val;
}

int n,m;
int a[MAXN];
int k[MAXN];
int h[MAXN];
int d[MAXN];

void unq()
{
    cnt=1;
    sort(u+1,u+1+num,cmp);
    for(int i=1;i<=num;i++)
    {
        if(u[i].val!=u[i-1].val)
            cnt++;
        if(u[i].c==1)h[u[i].id]=cnt;
        else a[u[i].id]=cnt;
    }
}

void pu(int V,int ID,int C)
{
    num++;
    u[num].val=V;
    u[num].id=ID;
    u[num].c=C;
}

void init()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
        pu(a[i],i,2);
    }
    for(int i=1;i<=m;i++)
    {
        scanf("%d",&k[i]);
        if(k[i]==2)
            scanf("%d",&d[i]);
        scanf("%d",&h[i]);
        pu(h[i],i,1);
    }
    unq();
}

int sum[4*MAXN];

void update(int x,int v)
{
    while(x<=cnt)
    {
        sum[x]+=v;
        x+=(x&(-x));
    }
}

int get(int x)
{
    int an=0;
    while(x>0)
    {
        an+=sum[x];
        x-=(x&(-x));
    }
    return an;
}

int isa(int i,int v)
{
    int minn=min(a[i],a[i+1]);
    int maxn=a[i]+a[i+1]-minn;
    update(minn+1,v);
    update(maxn+1,-v);
}

int main()
{
    init();
    a[0]=1;
    a[n+1]=1;
    for(int i=0;i<=n;i++)
    {
        isa(i,1);
    }
    for(int i=1;i<=m;i++)
    {
        if(k[i]==1)
        {
            cout<<get(h[i])/2<<endl;
        }
        else
        {
            isa(d[i],-1);
            isa(d[i]-1,-1);
            a[d[i]]=h[i];
            isa(d[i]-1,1);
            isa(d[i],1);
        }
    }
    return 0;
}

```


---

## 作者：radish布団 (赞：0)

关于这道题的正解，楼上kkk大佬已经说的很清楚了，因此本题解会着重强调一些代码的细节问题。

此题解基于线段树解法，用树状数组的大佬可以跳过不看了。

首先，对于这道题的预处理，所有题解只叙述了 $[2,n-1]$，即两侧有石柱的情况。那么对于 $1,n$ 这两个位置的石柱应该怎样处理呢？

显然应该把 $1,n$ 这两个位置的石柱与其他位置的石柱统一，也就是在 $0,n+1$ 两个位置虚构两根石柱。应该明确的是，**这两根虚构出来的石柱高度应为0。**原因显而易见：
### 位于 $0,n+1$ 的两根石柱是不可能对答案有任何贡献的。
为了确保它们不会产生任何贡献，我们必须让它们的高度低于所有石柱的高度，也就是 $0$。(当然你想写 $-1$ 或 $-INF$ 也可以)

明确了这一条后，你发现还是没法 $AC$ 这道题。因为你还漏了一条很重要的性质：
### 任何一根石柱(除了虚构的两根)都至少对答案有 $1$ 的贡献。
因此我们必须**给整个区间都先加上1**，再进行预处理。

献上蒟蒻丑陋的代码：
```
#include<algorithm>//STL通用算法
#include<bitset>//STL位集容器
#include<cctype>
#include<cmath>
#include<complex>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<ctime>
#include<deque>//STL双端队列容器
#include<list>//STL线性列表容器
#include<map>//STL映射容器
#include<iostream>
#include<queue>//STL队列容器
#include<set>//STL集合容器
#include<stack>//STL堆栈容器
#include<utility>//STL通用模板类
#include<vector>//STL动态数组容器
#define INF 0x3f3f3f3f
#define ll long long
#define ls (now<<1)
#define rs (now<<1|1)
#define mid ((l+r)>>1)
using namespace std;
int n,m,lst=INF,tot,hei[200010],res[400010];
int tree[400010<<2],lzy[400010<<2];
struct uio{
	int pos,hei;
}qry[200010];
void pushdown(int now)
{
	if(!lzy[now]) return;
	tree[ls]+=lzy[now],tree[rs]+=lzy[now];
	lzy[ls]+=lzy[now],lzy[rs]+=lzy[now];
	lzy[now]=0;
}
void rev(int now,int l,int r,int L,int R,int k)
{
	if(L>R) return;
	if(L<=l&&r<=R) {tree[now]+=k,lzy[now]+=k;return;}
	if(L<=mid) rev(ls,l,mid,L,R,k);
	if(R>mid) rev(rs,mid+1,r,L,R,k);
	tree[now]=tree[ls]+tree[rs];
}
int query(int now,int l,int r,int pos)
{
	if(l==r) return tree[now];
	pushdown(now);
	if(pos<=mid) return query(ls,l,mid,pos);
	else return query(rs,mid+1,r,pos);
	tree[now]=tree[ls]+tree[rs];
}
int main()
{
	scanf("%d%d",&n,&m);
	res[++tot]=0;tree[1]=lzy[1]=1;//这一行即为题解所说的两点细节 
	for(int i=1;i<=n;i++) scanf("%d",&hei[i]),res[++tot]=hei[i];
	for(int i=1;i<=m;i++)
	{
		int u,v,w;scanf("%d",&u);
		if(u==1) {scanf("%d",&v),qry[i]=(uio){0,v},res[++tot]=v;}
		else {scanf("%d%d",&v,&w),qry[i]=(uio){v,w},res[++tot]=w;}
	}
	sort(res+1,res+1+tot);tot=unique(res+1,res+1+tot)-res-1;
	for(int i=0;i<=n+1;i++) hei[i]=lower_bound(res+1,res+1+tot,hei[i])-res;
	for(int i=1;i<=m;i++) qry[i].hei=lower_bound(res+1,res+1+tot,qry[i].hei)-res;
	for(int i=1;i<=n;i++)
	{
		if(hei[i-1]<=hei[i]&&hei[i]>hei[i+1]) rev(1,1,tot,hei[i]+1,tot,-1);
		if(hei[i-1]>hei[i]&&hei[i]<=hei[i+1]) rev(1,1,tot,hei[i]+1,tot,1);
	}
	for(int i=1;i<=m;i++)
	{
		int x=qry[i].pos;
		if(!x) {printf("%d\n",query(1,1,tot,qry[i].hei));continue;}
		int mn=min(hei[x-1],hei[x+1]),mx=max(hei[x-1],hei[x+1]);
		if(qry[i].hei<hei[x])
		{
			if(hei[x]>mx) rev(1,1,tot,max(mx,qry[i].hei)+1,hei[x],-1);
			if(qry[i].hei<mn) rev(1,1,tot,qry[i].hei+1,min(mn,hei[x]),1);
		}
		if(qry[i].hei>hei[x])
		{
			if(hei[x]<mn) rev(1,1,tot,hei[x]+1,min(mn,qry[i].hei),-1);
			if(qry[i].hei>mx) rev(1,1,tot,max(mx,hei[x])+1,qry[i].hei,1);
		}
		hei[x]=qry[i].hei;
	}
	return 0;
}
```

---


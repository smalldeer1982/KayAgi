# [TJOI2017] DNA

## 题目描述

加里敦大学的生物研究所，发现了决定人喜不喜欢吃藕的基因序列 $S$,有这个序列的碱基序列就会表现出喜欢吃藕的性状，但是研究人员发现对碱基序列 $S$，任意修改其中不超过 $3$ 个碱基，依然能够表现出吃藕的性状。现在研究人员想知道这个基因在 DNA 链 $S_0$ 上的位置。所以你需要统计在一个表现出吃藕性状的人的 DNA 序列 $S_0$ 上，有多少个连续子串可能是该基因，即有多少个 $S_0$ 的连续子串修改小于等于三个字母能够变成 $S$。


## 说明/提示

对于 $20\%$ 的数据，$S_0,S$ 的长度不超过 $10^4$。

对于 $100\%$ 的数据，$S_0,S$ 的长度不超过 $10^5$，$0\lt T\leq 10$。

注：DNA 碱基序列只有 ATCG 四种字符。

## 样例 #1

### 输入

```
1
ATCGCCCTA
CTTCA```

### 输出

```
2```

# 题解

## 作者：Stars_visitor_tyw (赞：38)

## P3763 [TJOI2017] DNA 题解
### 分析
模拟赛没细想打了暴力。

暴力思路就是枚举起点以及遍历 $s$，按题意判断，优化一下可以拿 $60$ 分。

暴力代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

signed main()
{
//	freopen("T4.in","r",stdin);
//	freopen("T4.out","w",stdout);
	ios::sync_with_stdio(0);
	int t;
	for(cin>>t;t;t--)
	{
		string a, b;
		cin>>a>>b;
		int n=a.size(), m=b.size();
		a=" "+a;
		b=" "+b;
		int ans=0;
		for(int i=1;i<=n-m+1;i++)
		{
			int cnt=0;
			for(int j=1;j<=m;j++)
			{
				if(a[i+j-1]!=b[j])
				{
					cnt++;
				}
				if(cnt>3)break;//优化
			} 
			if(cnt<=3)
			{
				ans++;
			}
		}
		cout<<ans<<"\n";
	} 
	return 0;
}
```

接下来说正解。个人认为这是最通俗易懂的解法。

可以发现暴力程序主要是在比对的时候花的时间太长了。考虑进一步优化。

作为提高组选手，看到比对字符串很容易就想到哈希。

我们尝试比对出前三个不同的地方，最后一段如果能匹配上就是一个答案，反之则不是。当然如果还没找到三处不同就已经匹配完整个 $s$ 串了，那么这也是一个答案。

细细思考一下，容易发现哈希的匹配具有单调性，具体来讲，如果两个字符串的前 $l$ 个字符可以匹配上，那么前 $l-1$ 个字符也可以匹配上；如果两个字符串的前 $l$ 个字符不能匹配上，那么前 $l+1$ 个字符也不能匹配上。

考虑二分，二分出前三个不同的地方，如果匹配完了就结束二分并累加答案，否则判断剩余部分是否匹配即可。

### 正确代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
unsigned long long hs[N], pw[N], ht[N], base=19991;
unsigned long long get_hash(unsigned long long hsd[], int lt, int rt)
{
	return hsd[rt]-hsd[lt-1]*pw[rt-lt+1];
}
bool check(int l, int ed)
{
	int st=1, r=l+ed-1;
	for(int i=1;i<4;i++)
	{
		int lt=-1, rt=ed-st+2;
		while(lt+1<rt)
		{
			int mid=(lt+rt)>>1;
			if(get_hash(hs,l,l+mid-1)==get_hash(ht,st,st+mid-1))lt=mid;
			else rt=mid;
		}
		l+=lt+1;
		st+=lt+1;
		if(st>ed)return 1;
	}
	return get_hash(hs,l,r)==get_hash(ht,st,ed);
}
int work()
{
	string s0, s;
	cin>>s0>>s;
	if(s0.size()<s.size())return 0;
	int len1=s0.size(),len2=s.size();
	s0=" "+s0;
	s=" "+s;
	for(int i=1;i<=len1;i++)hs[i]=hs[i-1]*base+s0[i];
	for(int i=1;i<=len2;i++)ht[i]=ht[i-1]*base+s[i]; 
	int ans=0;
	for(int i=1;i+len2-1<=len1;i++)
	{
		if(check(i,len2))ans++;
	}
	return ans;
} 
signed main()
{
	pw[0]=1;
	for(int i=1;i<=100000;i++)pw[i]=pw[i-1]*base;
	int t;
	for(cin>>t;t;t--)cout<<work()<<"\n";
}
```

---

## 作者：孑思 (赞：22)

丝毫没有羞耻之心地发一波跑了2300+s的~~狗屎~~代码

# 用的字符串哈希

说真的以前没有接触过哈希这玩意儿

Claris~~（是的本周我第三次cue他了）~~今天讲了几分钟哈希就拿出了这道例题

~~蒟蒻瑟瑟发抖~~

有些东西真的讲不太清，请见谅

```cpp
//hash(l,r)=hash(1,r)-hash(1,l-1)*seed^(r-l+1)
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ULL;//自然溢出，这道题没被卡哇哈哈
const int N=100000+3,D=233;
int n,m,T,ans;
char a[N],b[N];
ULL p[N],f[N],g[N];
inline ULL ask(ULL*f,int l,int r){//[l,r]的哈希值 
	return f[r]-f[l-1]*p[r-l+1]; 
}
inline int lcp(int x,int y,int r){
	int l=1,mid,t=0;
	while(l<=r){//二分查找（这个东西可以让一个机房的人吵起来）
		mid=(l+r)>>1;
		if(ask(f,x,x+mid-1)==ask(g,y,y+mid-1)){//如果这一段是相等的 
			t=mid;//标记长度 
			l=mid+1;//l右移 
		}
		else r=mid-1;//不相等就左移 
	}
	return t;//返回长度 
}
inline bool check(int x){
	int r=x+m-1,y=1;//r：S0的尾；y:S的头
	for(int i=0;i<3;++i){//3次容错 
		int t=lcp(x,y,m-y+1);//相同的长度 
		// m-y+1
		x+=t+1;//不相等的那个要跳过 
		y+=t+1;
		if(y>m)return 1;//如果最终长度能>m,就匹配成功 
	}
	return ask(f,x,r)==ask(g,y,m);
}
int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%s%s",a+1,b+1);
		n=strlen(a+1);
		m=strlen(b+1);
		if(n<m){//不解释
			printf("0\n");
			continue;
		}
		p[0]=1;
		for(int i=1;i<=n;++i)p[i]=p[i-1]*D;//预处理
		for(int i=1;i<=n;++i)f[i]=f[i-1]*D+a[i];//哈希值 
		for(int i=1;i<=m;++i)g[i]=g[i-1]*D+b[i];
		ans=0;
		for(int i=1;i+m-1<=n;++i)//枚举相同字符串的头 
			if(check(i))ans++;
		printf("%d\n",ans);
	}
	return 0;
}
```

我真的觉得这个跑得好慢啊QAQ

~~可是别的我也不会写了QWQ~~

---

## 作者：huangzirui (赞：16)

题意：

给出两个长度小于 $10^5$ 的字符串 $S$ 和 $T$，求 $S$ 中有多少个连续子串在不改变超过 $3$ 个字符后可以和 $T$ 匹配。多组数据，字符集大小为 $4$。

---

设 $S$ 的长度为 $n$， $T$ 的长度为 $m$。

字符集大小为 $4$，考虑对每个字符分开考虑。

样例：

$
S:\ \texttt{ATCGCCCTA}
$

$
T:\ \texttt{CTTCA}
$

不妨先对字符 $\texttt{C}$ 进行处理。将 $S$ 和 $T$ 中为 $\texttt{C}$ 的位置变为 $1$ ，不为 $\texttt{C}$ 的位置变为 $0$ 再进行匹配。

$
S:\ \texttt{001011100}
$

$
T:\ \texttt{10010}
$

那么对于某个位置 $k$， $S[k\ ...\ k+m-1]$ 和 $T[0\ ...\ m-1]$ 的匹配个数可以写为：

$$\sum\limits_{i=0}^{m-1}S[i+k]T[i]$$

然后我们发现这个式子特别像 FFT，于是进行一番处理：

设 $A[m-i-1] = T[i]$

上式变为：

$$\sum\limits_{i=0}^{m-1}S[i+k]A[m-i-1]$$

$$\sum\limits_{i+j=m-k-1}S[i]A[j]$$

然后跑 FFT 就可以快速求出上式。

最后位置 $S[k\ ...\ k+m-1]$ 和 $T[0\ ...\ m-1]$ 的匹配个数就是这四次 FFT 结果相加。

因为可以修改三个位置，最后判断是否匹配可以有 $3$ 的误差。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline int read(){
	char c=getchar();int x=0,f=1;
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int maxn=100010*4;
struct Complex{
	double x,y;
};
Complex operator +(Complex a,Complex b){return (Complex){a.x+b.x,a.y+b.y};}
Complex operator -(Complex a,Complex b){return (Complex){a.x-b.x,a.y-b.y};}
Complex operator *(Complex a,Complex b){return (Complex){a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x};}
const double Pi=acos(-1.0);
Complex get_w(int k,int len,bool op){
	int T=1;if(!op)T=-1;
	return (Complex){cos(2.0*k*Pi/len),T*sin(2.0*k*Pi/len)};
}
Complex A[maxn],B[maxn];
int i,j,k,n,m;
int R[maxn];
char C[4]={'A','T','C','G'};
void FFT(int len,Complex *a,bool op){
	for(int i=0;i<len;i++)
		if(i<R[i])swap(a[i],a[R[i]]);
	for(int i=1;i<len;i=i*2){
		Complex w,Wn=get_w(1,i*2,op);
		for(int j=0;j<len;j+=i*2){
			w=(Complex){1,0};
			for(int k=0;k<i;k++,w=w*Wn){
				int K=k+j;
				Complex S1=a[K],S2=w*a[K+i];
				a[K]=S1+S2;
				a[K+i]=S1-S2;
			}
		}
	}
}
int Ans[maxn],ans;
int main(){
	int T;
	cin>>T;
	string None_;
	getline(cin,None_);
	while(T--){
		memset(Ans,0,sizeof(Ans));ans=0;
		string S,T;
		cin>>S>>T;
		n=S.size();
		m=T.size();
		for(i=0;i<4;i++){
			for(j=0;j<n;j++)
				A[j]=(Complex){(S[j]==C[i]),0};
			for(j=0;j<m;j++)
				B[m-j-1]=(Complex){(T[j]==C[i]),0};
			int len=1,L=0;
			while(len<=n+m)len*=2,++L;
			for(j=0;j<len;j++)
				R[j]=R[j/2]/2+(j%2)*(1<<L-1);
			FFT(len,A,true);FFT(len,B,true);
			for(j=0;j<len;j++)A[j]=A[j]*B[j];
			FFT(len,A,false);
			for(j=m-1;j<=m+n-1;j++)
				Ans[j-(m-1)]+=((int)(A[j].x/len+0.5));
			for(j=0;j<len;j++)A[j]=B[j]=(Complex){0,0};
		}
		for(i=0;i<n-m+1;i++)
			if(Ans[i]+3>=m)++ans;
		cout<<ans<<endl;
	}
	return 0;
}

```

---

## 作者：elijahqi (赞：9)

天津今年的省选题很有质量啊，测试数据也非常好，不像往年写写暴力就能过不少，于是 今年就差点爆0了   ORZ

一道后缀数组加暴力的题 期望复杂度在nlogn+n吧  可能会算错，不太会算(。・∀・)ノ希望指正

我自己在bzoj上似乎被卡常了，因为用的是何琦的sa??黑人问号，省选的时候lzh&&leoly学长当场写过，看了看他的程序似乎是用了坊间传说的da算法。我们省选是开o2优化的，于是在洛谷上 大牛模式（有o2优化） 我就交过了

leoly用的是sam跑的贼快，然而我不太会写，看了看大家的提交记录有字符串hash 的据说也是十分玄学，不是很懂

程序挺长的 大概因为我一开始总是过不去加的调试太多 前面rmq+sa求lcp可以看下我之前的文章

SA：http://www.elijahqi.win/2017/07/12/poj-2774/

RMQ：http://www.elijahqi.win/2017/07/13/%e3%80%90luogu2880%e3%80%91usaco07jan%e5%b9%b3%e8%a1%a1%e7%9a%84%e9%98%b5%e5%ae%b9balanced-lineup/

SA+RMQ求lcp:

http://www.elijahqi.win/2017/07/15/ural1297/

 
大概说一下暴力部分如何去求，由于说我们可以nlogn求lcp然后o1的时间查询

我们枚举原串的每一个字符作为起点，如果相同就用lcp求，不相同就给记录不相同的计数器++

保证不相同的计数器不超过3 如果在3以内我们就统计答案

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#define N 220000
int T,n,n1,m,count[N],tmp[N],rank[N<<1],rank1[N],sa[N],height[N],k,fmin1[N][18];
char a[N];
inline void swap(int &a,int &b){
    int t=a;a=b;b=t;
}
inline int min(int x,int y){
    return x<y?x:y;
}
inline int lcp(int l,int r){
    int a=rank[l],b=rank[r];
    if (a>b) swap(a,b);a++;
    int k=0;k=(int)log2(b-a+1);//while ((1<<(k+1))<=(b-a+1))++k;
    return min(fmin1[a][k],fmin1[b-(1<<k)+1][k]);
}
int main(){
    //freopen("3763.in","r",stdin);
//    freopen("3763.out","w",stdout);
    scanf("%d",&T);
    while (T--){
    /*    char ch=getchar();n1=0;
        while (ch<'A'||ch>'Z') ch=getchar();
        while (ch<='Z'&&ch>='A') {
            a[++n1]=ch;ch=getchar();    
        }*/
        scanf("%s",a+1);n1=strlen(a+1);
        a[++n1]='#';
        scanf("%s",a+n1+1);
        n=strlen(a+1); 
    /*    n=n1;
        while (ch<'A'||ch>'Z') ch=getchar();
        while (ch<='Z'&&ch>='A') {
            a[++n]=ch;ch=getchar();    
        }
        n=strlen(a+1);*/
        //n1=n-n1;
        m=5;
        //printf("%d ",n1);
    //    for (int i=1;i<=n;++i) printf("%c",a[i]);
        for (int i=1;i<=255;++i) count[i]=0;
        memset(rank,0,sizeof(rank));
        for (int i=1;i<=n;++i) count[a[i]]=1;
        for (int i=1;i<=255;++i) count[i]+=count[i-1];
        for (int i=1;i<=n;++i) rank[i]=count[a[i]];
        
        k=0;
        for (int p=1;k!=n;p<<=1,m=k){
            for (int i=1;i<=m;++i) count[i]=0;
            for (int i=1;i<=n;++i) count[rank[i+p]]++;
            for (int i=1;i<=m;++i) count[i]+=count[i-1];
            for (int i=n;i>=1;--i) tmp[count[rank[i+p]]--]=i;
            for (int i=1;i<=m;++i) count[i]=0;
            for (int i=1;i<=n;++i) count[rank[i]]++;
            for (int i=1;i<=m;++i) count[i]+=count[i-1];
            for (int i=n;i>=1;--i) sa[count[rank[tmp[i]]]--]=tmp[i];
            memcpy(rank1,rank,sizeof(rank)>>1);
            rank[sa[1]]=k=1;
            for (int i=2;i<=n;++i){
                if (rank1[sa[i-1]]!=rank1[sa[i]]||rank1[sa[i-1]+p]!=rank1[sa[i]+p])++k;
                rank[sa[i]]=k;
            }
        }
    /*    for (int i=1;i<=n;++i){
            for (int j=sa[i];j<=n;++j) printf("%c",a[j]);printf("\n");
        }*/
        k=0;
        for (int i=1;i<=n;++i){
            if (rank[i]==0){
                height[1]=0;continue;
            }
            k=k==0?0:k-1;
            while (a[i+k]==a[sa[rank[i]-1]+k])++k; 
            height[rank[i]]=k;
        }
        //for (int i=1;i<=n;++i) printf("%d ",height[i]);
    //    memset(fmin1,0x7f,sizeof(fmin1));
        for (int i=1;i<=n;++i) fmin1[i][0]=height[i];
        for (int j=1;(1<<j)<=n;++j){
            for (int i=1;i+(1<<j)-1<=n;++i){
                fmin1[i][j]=min(fmin1[i][j-1],fmin1[i+(1<<(j-1))][j-1]);
                //printf("%d ",fmin[i][j]);
            }
        //    printf("\n");
        }
    /*    int d=n1;int ans=0;
        for (int i=1;i<=n;++i){
            if (height[i]>=n1-3){
                if ((sa[i]/d)^(sa[i-1]/d)) ans++;
            }
        }*/
        int na=n1,nb=n-n1,ans=0;
        for (int i=1;i<=na-nb;i++){
            int tot=0;
            for (int j=1;j<=nb&&tot<=3;)
                if (a[i+j-1]!=a[na+j]) {
                    tot++,j++;if (tot>3) break;
                }
                else j+=lcp(i+j-1,na+j);
            if (tot<=3) ans++;
        //    if (tot>3) continue;
        }
        printf("%d\n",ans);
    }
    return 0;
}
```
 

---

## 作者：Stone_Xz (赞：7)

## [题目传送门](https://www.luogu.com.cn/problem/P3763)

## 题意

> 给定两个字符串 $S_0$ 和 $S$，求在 $S_0$ 中有多少个与 $S$ 等长的子串，可以通过修改不超过三个字符变为 $S$。

ps：注意有多组数据。

## 分析：

 - 可以马上想到暴力枚举 $S_0$ 的子串并判断其是否符合条件。其中题目规定每个子串的长度都是 $\lvert S \rvert$，枚举子串的时间为 $\mathcal{O}(n)$。

 - 接下来是重点：如何判断一个 $S_0$ 的子串是否能通过修改不超过三个字符变为 $S$。我们先设当前 $S_0$ 的子串为 $x$，其实修改的那三个字符将 $x$ 截成了四段，这四段都与 $S$ 对应的位置相同，如下是一个例子：

$$
S : \texttt{aaabbbccc}
$$

$$
\;x : \texttt{aa\textcolor{red}{e}bb\textcolor{red}{e}c\textcolor{red}{e}c}
$$

如果去掉不同的字符：

$$
S : \texttt{aa bb c c}
$$

$$
\;x : \texttt{aa bb c c}
$$

拿上面的例子，发现可以对 $S$ 和 $x$ 求**最长公共前缀的长度** $z$，并从头开始删除 $z + 1$ 个位置，即跳过最长公共前缀这一段相同的字符和后面那一个不同的字符，这样重复三次。最后再判断一下末尾的第四段是否相等，一共四个相同段和三个不同的位置。其中求最长公共前缀可以用哈希 + 二分达到 $\mathcal{O}(\log len)$ 的时间复杂度，总时间复杂度为：$\mathcal{O}(\lvert S_0 \rvert \log \lvert S \rvert)$。具体实现看代码。

## 代码：

```cpp
#include<bits/stdc++.h>
#define ull unsigned long long
using namespace std;

const int N = 1e5 + 5, base = 13331;
int ans, lens, lens0;
string s0, s;
ull pw[N], hs_s0[N], hs_s[N];

ull get_hs(ull hs[], int l, int r)
{
	return hs[r] - hs[l - 1] * pw[r - l + 1];
}

int get(int s0_s, int s_s, int len)
// 求 [s0 从 s0_s 开始 len个字符] 和 [s 从 s_s 开始 len个字符] 的最长公共前缀 
{
	int lt = -1, rt = len + 1;
	while(lt + 1 < rt)
	{
		int mid = (lt + rt) / 2;
		if(get_hs(hs_s0, s0_s, s0_s + mid - 1) == get_hs(hs_s, s_s, s_s + mid - 1))
			lt = mid;
		else
			rt = mid;
	}
	return lt;
}

bool check(int st)
{
	int len = 0;
	// 当前已经匹配的长度，已经匹配的部分可以不用管了
	for(int i = 1; i <= 3; i++)
	{
		int z = get(st + len, len + 1, lens - (len + 1) + 1);
		// 后面还没匹配部分的最长公共前缀 
		len += z; // 跳过 后面还没匹配部分的最长公共前缀
		if(len == lens) return true; // 匹配完了 
		len++; // 跳过最长公共前缀后面那个字符 
	}
	if(len == lens) return true;
	int z = get(st + len, len + 1, lens - (len + 1) + 1); // 第四段 
	return len + z == lens;
}

void solve()
{
	ans = 0;
	cin >> s0 >> s;
	s0 = "#" + s0;
	s = "#" + s;
	lens0 = s0.size() - 1, lens = s.size() - 1;
	// 预处理 Hash 
	pw[0] = 1;
	for(int i = 1; i <= lens0; i++)
		hs_s0[i] = hs_s0[i - 1] * base + s0[i];
	for(int i = 1; i <= lens; i++)
	{
		hs_s[i] = hs_s[i - 1] * base + s[i];
		pw[i] = pw[i - 1] * base;
	}
	for(int i = 1; i + lens - 1 <= lens0; i++)
	{
		if(check(i))
			ans++;
	}
	cout << ans << "\n";
}

int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	int T;
	cin >> T;
	while(T--) solve();
	return 0;
}
```

---

## 作者：MCAdam (赞：6)

[题目](https://www.luogu.com.cn/problem/P3763)

对于一个不会$SAM$，不想推$FFT$式子的蒟蒻来说，后缀树组是最后的选择！！！

从最暴力的开始考虑，枚举$S_0$的开头，然后和$S$一位一位匹配，时间复杂度为$O(n^2)$。

但这个暴力其实是挺优秀的，为什么呢？因为我们一位一位匹配，只要找到$4$个不同的，那么当前这个开头肯定就不能满足，这是最优的情况。那最劣的情况呢？就是前面一大堆都是相同的，不相同的都排在后面。

从这个角度进行优化，如果我们能知道当前开头的字符串和$S$公共的前缀，那就可以直接跳到前缀的下一位进行比较辣！如果当前位不相同，计数器加加，如果相同就直接跳到$LCP$的下一位。

看到前缀，就想到的后缀树组中的$height$辣！但是$S_0$和$S$不在一个字符串中？那就把$S$插到$S_0$后面去就好辣。$S_0$在最后面，公共前缀最多也就是$len$。

计算出$height$后，预处理$ST$表.

貌似字符集只有$\{'A','C',T','G'\}$（大雾

本来不想开$O_2$，但一直被卡两个点，还不断变化，我太难了QWQ

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
using namespace std;
const int N=1e5+10,M=2e5+10;
char s1[N],s2[N];
int s[M],SA[M],rk[M],tmp[M],height[M],cnt[M],f[M][20],log2[M],pow[20];
int turn[30];
int len,size;
inline void binsort()
{
	for(register int i=0;i<=size;++i) cnt[i]=0;
	for(register int i=1;i<=len;++i) cnt[rk[i]]++;
	for(register int i=1;i<=size;++i) cnt[i]+=cnt[i-1];
	for(register int i=len;i>=1;--i) SA[cnt[rk[tmp[i]]]--]=tmp[i];
}
inline void get_SA()
{
	size=4;
	for(register int i=1;i<=len;++i)
		rk[i]=s[i],tmp[i]=i;
	binsort();
	for(register int l=1;l<=len;l<<=1)
	{
		int p=0;
		for(register int i=len-l+1;i<=len;++i)
			tmp[++p]=i;
		for(register int i=1;i<=len;++i)
			if(SA[i]>l) tmp[++p]=SA[i]-l;
		binsort(),swap(rk,tmp);
		rk[SA[1]]=p=1;
		for(register int i=2;i<=len;++i)
			rk[SA[i]]=(tmp[SA[i]]==tmp[SA[i-1]]&&tmp[SA[i]+l]==tmp[SA[i-1]+l])?p:++p;
		if(p==len) break; size=p;
	}
}
inline void get_height()
{
	int pre=1;
	for(register int i=1;i<=len;++i)
	{
		if(pre) pre--;
		while(s[i+pre]==s[SA[rk[i]-1]+pre]) pre++;
		height[rk[i]]=pre;
	}
	for(register int i=1;i<=len;++i)
		f[i][0]=height[i];
	for(register int l=1;l<=log2[len];++l)
		for(register int i=1;i<=len-pow[l]+1;++i)
			f[i][l]=min(f[i][l-1],f[i+pow[l-1]][l-1]);
}
inline int query(int l,int r)
{
	int k=log2[r-l+1];
	return min(f[l][k],f[r-pow[k]+1][k]);
}
int main()
{
	int T;
	scanf("%d",&T);
	log2[1]=0,pow[0]=1;
	for(register int i=2;i<=2e5;++i)
		log2[i]=log2[i>>1]+1;
	for(register int i=1;i<=18;i++)
		pow[i]=pow[i-1]<<1;
	turn[0]=1,turn[2]=2,turn[6]=3,turn[19]=4;
	while(T--)
	{
		int len1,len2,ans=0;
		scanf("%s",s1+1),len1=strlen(s1+1);
		scanf("%s",s2+1),len2=strlen(s2+1);
		len=len1+len2;
		for(register int i=1;i<=len;++i)
		{
			if(i<=len1) s[i]=turn[s1[i]-'A'];
			else s[i]=turn[s2[i-len1]-'A'];
		}
		get_SA(),get_height();
		for(register int i=1;i<=len1-len2+1;++i)
		{
			int p=i,q=len1+1,tot=0;
			while(p<=len1&&q<=len&&tot<=3)
			{
				if(s[p]!=s[q]) tot++,p++,q++;
				else
				{
					int a=rk[p],b=rk[q],lcp;
					if(a>b) swap(a,b);
					lcp=query(a+1,b);
					p+=lcp,q+=lcp;
				}
			}
			if(p<=len1+1&&q==len+1&&tot<=3) ans++;
		}
		printf("%d\n",ans);
	}
	return 0;
}
```


---

## 作者：xiezheyuan (赞：5)

**想学习本题 SAM 正确姿势的快来呀！**

## 简要题意

$T$ 组数据，每组数据给出两个字符串 $S,S_0$。你需要求出 $S$ 中有多少个长度为 $|S_0|$ 的子串 $T$，使得 $S_0,T$ 仅有至多三个位置不同。

$1\leq |S_0|\leq |S|\leq 10^5,1\leq T\leq 10$，$S,S_0$ 均只包含 ATCG 四种字符。

## 思路

以下我们称可以计入本题答案的子串 $T$，称为合法的子串。

由于合法的子串的上界仅为 $|S|-|S_0|+1$，不是很大，我们可以枚举。然后我们找到这个子串 $T$ 和 $S_0$ 的 LCF（最长公共后缀，下同）。

假如 LCF 长度就是 $|T|$，那么就是没有位置是不同的，可以计入答案。否则我们可以将 LCF 和 LCF 左侧第一个字符（表示不同的一个字符）删掉（其实就是排除出区间），重复上述过程四次（因为需要检查存在零个、一个、两个、三个不同位置，共四种可能）。

如何求 LCF，我们将 $S,S_0$ 拼起来，中间用一个特殊字符分隔（似乎也可以没有）。建出 SAM。

在 SAM 上，两个字符串的 LCF 就是 parent 树上的 LCA，这个我们可以树剖。现在的问题就是，如何查询字符串中一段子串在 SAM 上的对应节点？

我们可以利用树剖结构。由于 parent 树上一条从一个节点到根节点的链，长度单调递减且为后缀关系。我们从右端点为区间的前缀所在节点（这个可以在构建 SAM 的时候记录一下）开始，跳重链，跳到一个重链有答案的就在里面二分。

当然你用倍增也行。

然后这道题实际上就做完了。时间复杂度 $O(Tn\log n)$，其中 $n=|S| + |S_0|$。


## 代码

注意一些 corner case（比如说包含根节点的重链）。如果你 TLE 了，可能不是复杂度的问题也不是常数问题，而是数组越界了。在 Windows 上可能看不出来，可以在 Linux 中加上编译参数 `-fsanitize=undefined,address` 调试，具体请参考往期日报。

```cpp
#include <bits/stdc++.h>
#define link __ytxy_ak_ioi
#define clr(x) memset((x), 0, sizeof((x)))
using namespace std;

const int N = 2e5 + 5, M = 5;

int trans[N << 1][M], link[N << 1], len[N << 1], cur, tot,  endps[N << 1];

void extend(int c, int tt){
	int x=cur;cur=(++tot);len[cur]=len[x]+1;endps[tt] = cur;
	for(;(~x)&&(!trans[x][c]);x=link[x]) trans[x][c] = cur;
	if(!(~x)){link[cur]=0;return;}
	int y=trans[x][c];
	if(len[y]==len[x]+1){link[cur]=y;return;}
	int u=(++tot),d=y;
	link[u]=link[y];link[d]=link[cur]=u;len[u]=len[x]+1;
	for(int i=0;i<=4;i++) trans[u][i] = trans[d][i];
	for(;(~x)&&(trans[x][c]==y);x=link[x]) trans[x][c] = u;
}

int son[N << 1], rev[N << 1], seg[N << 1], top[N << 1], sgtt = 1, dep[N << 1];
vector<int> ptr[N << 1];

struct edge{
	int nxt, to;
} g[N << 1];
int head[N << 1], ec;

void add(int u, int v){
	g[++ec].nxt=head[u];
	g[ec].to=v;
	head[u]=ec;
}

int dfs1(int u){
	int szt = 1, tmp = 0;
	if(ptr[u].empty()) son[u] = 0;
	for(int i=head[u];~i;i=g[i].nxt){
		int v = g[i].to;
		dep[v] = dep[u] + 1;
		int szv = dfs1(v);
		szt += szv;
		if(tmp < szv){
			tmp = szv;
			son[u] = v;
		}
	}
	return szt;
}

void dfs2(int u){
	if(son[u]){
		top[son[u]] = top[u];
		seg[son[u]] = ++sgtt;
		rev[sgtt] = son[u];
		dfs2(son[u]);
	}
	for(int i=head[u];~i;i=g[i].nxt){
		int v = g[i].to;
		if(son[u] == v) continue;
		top[v] = v;
		seg[v] = ++sgtt;
		rev[sgtt] = v;
		dfs2(v);
	}
}

int find(int l, int r){
	int u = endps[r];
	while(true){
		if(!top[u] || len[link[top[u]]] < (r - l + 1)){
			int L = seg[top[u]], R = seg[u];
			while(L <= R){
				int mid = (L + R) >> 1;
                if(!(~link[rev[mid]])){
                    L = mid + 1;
                    continue;
                }
				if(len[link[rev[mid]]] < (r - l + 1)) L = mid + 1;
				else R = mid - 1;
			}
			L--;
			return rev[L];
		}
		u = link[top[u]];
	}
}

int lca(int u, int v){
	while(top[u]!=top[v]){
		if(dep[top[u]] < dep[top[v]]) swap(u, v);
		u = link[top[u]];
	}
	return len[u] < len[v] ? u : v;
}

int lcf(int l, int r, int L, int R){
	return len[lca(find(l, r), find(L , R))];
}

int turn(char ch){
	if(ch == 'A') return 1;
	if(ch == 'T') return 2;
	if(ch == 'C') return 3;
	if(ch == 'G') return 4;
	return 0;
}

void solve(){
	string s, s0, s2;
	cin >> s0 >> s;
	s2 = s0 + '$' + s;
	int ytxy = 0, n = s0.size(), m = s.size(), k = s2.size();link[0] = -1;
	for(unsigned i=0;i<k;i++) extend(turn(s2[i]), ++ytxy);
	fill(head, head + tot + 1, -1);
	for(int i=1;i<=tot;i++) add(link[i], i);
	seg[0] = dep[0] = 1;top[0] = len[0] = 0;
	dfs1(0);dfs2(0);
	ytxy = 0;
	// cout << (n - m + 1) << '\n';
	for(int i=1;i<=(n - m + 1);i++){
		int r1 = i + m - 1, r2 = k;bool flag = 0;
		for(int j=1;j<=3;j++){
			int ret = lcf(i, r1, k - m + 1, r2);
			if(ret == (r1 - i + 1)){
				ytxy++;
				flag = 1;
				break;
			}
			r1 -= (ret + 1);r2 -= (ret + 1);
		}
		if(!flag && find(i, r1) == find(k - m + 1, r2)) ytxy++;
	}
	cout << ytxy << '\n';
}

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	int t;cin>>t;
	while(t--){
		solve();
		for(int i=0;i<=tot;i++){
			link[i] = len[i] = trans[i][0] = trans[i][1] = trans[i][2] = trans[i][3] = trans[i][4] = 0;
			g[i].nxt = g[i].to = 0;
		}
		sgtt = 1;cur = tot = ec = 0;
	}
	return 0;
}
```

---

## 作者：5k_sync_closer (赞：5)

写一个比大部分做法跑得快的哈希（最优解 rk3）。

枚举 $S_0$ 子串的开头，二分找失配位置，在失配位置后二分找下一个失配位置，以此类推。

如果第 $4$ 个失配位置在子串外，那么这个子串符合要求。

考虑字符集大小只有 $4$，$\text{base}$ 取 $5$ 即可。

直接自然溢出啥事没有。
```cpp
#include <stdio.h>
#include <string.h>
int T, n, m, l, q;
char a[100050], b[100050];
unsigned p[100050], f[100050], g[100050];
int main()
{
    p[0] = 1;
    scanf("%d", &T);
    while (T--)
    {
        scanf("%s%s", a + 1, b + 1);
        n = strlen(a + 1);
        m = strlen(b + 1);
        for (int k = m; l < k; ++l, p[l] = p[l - 1] * 5)
            ;
        for (int i = 1; i <= n; ++i)
        {
            f[i] = f[i - 1] * 5;
            switch (a[i])
            {
            case 'T':
                f[i] += 1;
                break;
            case 'C':
                f[i] += 2;
                break;
            case 'G':
                f[i] += 3;
                break;
            }
        }
        for (int i = 1; i <= m; ++i)
        {
            g[i] = g[i - 1] * 5;
            switch (b[i])
            {
            case 'T':
                g[i] += 1;
                break;
            case 'C':
                g[i] += 2;
                break;
            case 'G':
                g[i] += 3;
                break;
            }
        }
        q = 0;
        for (int i = 1; i + m - 1 <= n; ++i)
            for (int j = 0, x = 0, l, r = 0; j < 4; ++j)
            {
                l = 0;
                x += r + 1;
                r = m - x + 1;
                while (l <= r)
                {
                    int m = l + r >> 1;
                    unsigned u = p[m];
                    if (f[i + x + m - 2] - f[i + x - 2] * u == g[x + m - 1] - g[x - 1] * u)
                        l = m + 1;
                    else
                        r = m - 1;
                }
                if (r == m - x + 1)
                {
                    ++q;
                    break;
                }
            }
        printf("%d\n", q);
    }
    return 0;
}
```


---

## 作者：Tari (赞：5)

鉴于自己做题时的傻子操作，向大家提供可能更易懂的哈希+二分算法


------------

### 二分出来的是**LCP长度$+1$，**

### 即每一次二分出来的**最后一个点都是失配的**，

而就算失配也会跳过这个点；

所以当$k<=3$（$k$是二分次数）且模式串$s2$的指针$>len2$时，即跳过了$<=3$个点且指针$\geq len2+1$时，都是可行的；当$k==4$且模式串$s2$的指针$\geq len2+2$时，即跳过了$<=4$个点的位置$\geq len2+2$时，是可行的。注意到是$len2+2$，原因是多失配了一个四号点。

不懂看图：![](https://cdn.luogu.com.cn/upload/pic/60597.png)

![](https://cdn.luogu.com.cn/upload/pic/60598.png)
所以指针至少大$2$


```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<cctype>
#include<cstdlib>
#include<vector>
#include<queue>
#include<map>
#include<set>
#define ll unsigned long long
#define R register int
using namespace std;
namespace Fread {
    //static char B[1<<15],*S=B,*D=B;
    //#define getchar() (S==D&&(D=(S=B)+fread(B,1,1<<15,stdin),S==D)?EOF:*S++)
    inline int g() {
        R ret=0,fix=1; register char ch; while(!isdigit(ch=getchar())) fix=ch=='-'?-1:fix;
        do ret=ret*10+(ch^48); while(isdigit(ch=getchar())); return ret*fix;
    }
}using Fread::g;
const int N=100010,B=131;
ll h1[N],h2[N],p[N]; int n,l1,l2,t;
char s1[N],s2[N];
inline ll H1(int l,int r) {return h1[r]-h1[l-1]*p[r-l+1];}
inline ll H2(int l,int r) {return h2[r]-h2[l-1]*p[r-l+1];}
inline int ck(int x) {
    R i=x,j=1; R l=0,r=l2+1;
    for(R k=1;k<=4;++k) {
        while(l<r) { R md=l+r>>1; 
            if(H1(i,i+md-1)==H2(j,j+md-1)) l=md+1; else r=md;
        } i+=l,j+=l;
        l=0,r=l2-j+2;
        if(k==4) {if(j-2>=l2) return 1;}
        else if(j-1>=l2) return 1; 
    } return 0;
}
signed main() {
#ifdef JACK
    freopen("NOIPAK++.in","r",stdin);
#endif
    p[0]=1; for(R i=1;i<=N-10;++i) p[i]=p[i-1]*B;
    t=g(); while(t--) { R ans=0;
        scanf("%s%s",s1+1,s2+1); l1=strlen(s1+1),l2=strlen(s2+1);
        if(l1<l2) {printf("0\n"); continue;}
        for(R i=1;i<=l1;++i) h1[i]=h1[i-1]*B+s1[i];
        for(R i=1;i<=l2;++i) h2[i]=h2[i-1]*B+s2[i];
        for(R i=1;i<=l1-l2+1;++i) ans+=ck(i); printf("%d\n",ans);
    }
}

```



---

## 作者：蹲在丛中笑 (赞：4)

和codeforce528d一样，用FFT进行字符串匹配

把两个串中的一个翻转，卷积的结果就是在文本串每一位置匹配的结果

ACTG分开算，以A为例，让一个串中有A的位置为1，无A的位置为0，另一个串相反。这样两串字符不同处会为结果的值贡献1 。<=3的结果个数和为答案

。。经过一波努力的卡常，以7000+ms通过了这题
```
#include<bits/stdc++.h>
using namespace std;
typedef complex<double> Com;
const int N=400005;
const double Pi=acos(-1);
const char Ch[4]={'A','C','G','T'};
int R[N],L=1;
void DFT(Com *A,int d) {
  for (int i=0;i<L;++i) if (i<R[i]) swap(A[i],A[R[i]]);
  for (int i=1;i<L;i<<=1) {
    Com Wn(cos(Pi/i),d*sin(Pi/i));
    for (int j=0;j<L;j+=(i<<1)) {
      Com W(1,0);
      for (int k=0;k<i;++k,W*=Wn) {
        Com T=W*A[i+j+k];
        A[i+j+k]=A[j+k]-T;
        A[j+k]+=T;
      }
    }
  }
  if (d==-1) for (int i=0;i<L;++i) A[i]/=L;
}
Com a[N],b[N];
char s1[N],s2[N];
int cas,ans,l1,l2,s[N];
int main() {
  scanf("%d",&cas);
  while (cas--) {
    scanf("%s%s",s1,s2);
    l1=strlen(s1); l2=strlen(s2); ans=0;
    memset(s,0,sizeof s);
    for (int i=0;i<(l2>>1);++i) swap(s2[i],s2[l2-i-1]);
    while (L<l1+l2) L<<=1;
    for (int i=0;i<L;++i) R[i]=((i&1) ? R[i^1]+(L>>1) : R[i>>1]>>1);
    for (int cc=0;cc<4;++cc) {
      memset(a,0,sizeof(Com)*L);
      memset(b,0,sizeof(Com)*L);
      for (int i=0;i<l1;++i) a[i]=(s1[i]!=Ch[cc]);
      for (int i=0;i<l2;++i) b[i]=(s2[i]==Ch[cc]);
      DFT(a,1),DFT(b,1);
      for (int i=0;i<L;++i) a[i]=a[i]*b[i];
      DFT(a,-1);
      for (int i=l2-1;i<l1;++i) s[i]+=(int)(a[i].real()+0.5);
    }
    for (int i=l2-1;i<l1;++i) ans+=(s[i]<=3);
    printf("%d\n",ans);
  }
}
```

---

## 作者：Rye_Catcher (赞：3)

- 题目链接：

   https://www.luogu.org/problemnew/show/P3763

- 思路：

   首先我们要用到Rabin-Karp哈希，其实就是这个:
   
    - 若$w_{str}$=($a_0$ $p^{n-1}$+$a_1$ $p^{n-2}$+...+$a_{n-1}$ $p^0$) 
 
      所以$w_{pre_{i-1}}$ $=($ $a_0$ $p^{i-1}$+$a_1$ $p^{i-2}$+...+$a_{i-1}$ $p^0$) 
   
      $w_{pre_{j}}$ $=($ $a_0$ $p^{j}$+$a_1$ $p^{j-1}$+...+$a_{j}$ $p^0$) 
 
      所以 $w_{str_{i,j}}$ 
   
       $=($ $a_i$ $p^{j-i}$+$a_{i+1}$ $p^{j-i-1}$+...+$a_{j}$ $p^0$)
   
       $=$ $w_{pre_{j}}$ $-$ $w_{pre_{i-1}}$ $p^{j-i+1}$
    
      注意了，我这里并没有取模，而是直接直接用unsigned long long 自然溢出，这样更快
    
  然而，一般人都是用二分确定右端点，我自己摸索出了一个骚操作（好像又在哪里听过）----用**倍增**。
  
  因为在这道题中我觉得二分的上下界可能相差比较大，虽然理论上二分平均情况下更好，但在这道题中实际测出来用倍增更快（如果之后有人用二分跑得还比我快就无视我这句话）。
  
  思路就是这样，其他一些细节就见代码吧.
  
- 代码：

```
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cstdlib>
#include <cmath>
#include <algorithm>
#include <iostream>
#define ri int 
const int maxn=100005;
typedef long long   ll;
typedef unsigned long long ull;
char a[maxn],b[maxn];
ull q[maxn],aht[maxn],bht[maxn];
int cnt=0,lena,lenb;
inline void Hash(){
    ll x=0;
    for(ri i=0;a[i];i++){
        x=x*131+a[i]-31;
        aht[i]=x;
    //	cout<<x<<i<<endl;
    }x=0;
    for(ri i=0;b[i];i++){
        x=x*131+b[i]-31;
        bht[i]=x;
    }x=0;
    return ;
}
inline int solve(int x,int y){
    int k=0,p=1;
    x++,y++;
  	while(p!=0){  
        if((aht[x+k+p-1]-aht[x-1-1]*q[k+p+1])==(bht[y+k+p-1]-bht[y-1-1]*q[k+p+1]))k+=p,p*=2;
        else p=p/2;//cout<<l<<'*'<<r<<'*'<<mid<<endl;
        while(x+k+p>lena||y+k+p>lenb)p=p/2;
    }
    if(a[x-1]==b[y-1])k++;
    return k;
}
inline bool ok(int i){
      int la=0,k;
      for(ri j=1;j<=3;j++){
           k=solve(i,la);
           i+=k+1,la+=k+1;
           if(la>=lenb){return 1;}//cout<<i<<' '<<la<<endl;
      }
         k=solve(i,la); 
         i+=k;la+=k;
      //   cout<<i<<' '<<la<<endl;
         if(la>=lenb) return 1;
         return 0;
}
int main()
{
    int t;
    scanf("%d",&t);
    q[0]=1;
    for(ri i=1;i<=100001;i++)
        q[i]=(ull)q[i-1]*131;
  //预处理幂，这个技巧来自https://www.cnblogs.com/sineagle/p/8490655.html
    while(t--){
       int cnt=0;
       scanf("%s",a);
       scanf("%s",b);
       lena=strlen(a),lenb=strlen(b);
       if(lena<lenb){printf("0\n");continue;}
       Hash();
       for(ri i=0;i<lena-lenb+1;i++){
         if(ok(i))cnt++;
       }
       printf("%d\n",cnt);
       memset(aht,0,sizeof(aht));
       memset(bht,0,sizeof(bht));
    }
    return 0;
}
```
- 后记：

  luogu上最快的一次跑了240ms,然而还是比不过BZOJ的dalao

---

## 作者：MspAInt (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P3763)

子串是后缀的前缀。

把两个串拼在一起，中间加个特殊分割符（如 `ATCGCCCTA#CTTCA`），设拼接串长度为 $n$，吃藕串长度为 $m$。后缀排序一手，求得 height 数组，这时**你可以用 st 表求出吃藕串任意后缀和基因串任意后缀的 lcp**，这里将后缀位置 $i,j$ 的 lcp 设为 $\operatorname{lcp}(i,j)$，不会求这个的右转学习。

然后你枚举每个后缀位置 $i$，再拿一个 $k=i$，顺着 lcp 往后跳四次，即 $k\gets k+|\operatorname{lcp}(k,n-m+1+k-i)|+1$，显然每次都会跳过一个不同的字符位置，那么贡献的条件就是跳完后 $k>i+m$，即只存在至多三个不同位置。

复杂度 $\Theta(Tn\log n)$，如果你 RE 了记得多测清空。

Code:

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=2e5+10;
int T,n,m,sa[N],x[N<<1],y[N<<1],rk[N],h[N][20],c[N],lg[N],ans;
char a[N],b[N],s[N];

int query(int l,int r){//ask min l to r of st-table
    if(l>r)swap(l,r);l++;
    int t=lg[r-l+1]-1;
    return min(h[l][t],h[r-(1<<t)+1][t]);
}
void sily(){//SA to a+"#"+b then get st-table of height
    int w=100;
    for(int i=1;i<=n;i++)x[i]=s[i],c[x[i]]++;
    for(int i=1;i<=w;i++)c[i]+=c[i-1];
    for(int i=n;i>=1;i--)sa[c[x[i]]--]=i;
    for(int k=1;k<=n;k<<=1){
        int l=0;
        for(int i=n-k+1;i<=n;i++)y[++l]=i;
        for(int i=1;i<=n;i++)if(sa[i]>k)y[++l]=sa[i]-k;
        for(int i=1;i<=w;i++)c[i]=0;
        for(int i=1;i<=n;i++)c[x[i]]++;
        for(int i=1;i<=w;i++)c[i]+=c[i-1];
        for(int i=n;i>=1;i--)sa[c[x[y[i]]]--]=y[i];
        swap(x,y);
        x[sa[1]]=l=1;
        for(int i=2;i<=n;i++)x[sa[i]]=(y[sa[i]]==y[sa[i-1]]&&y[sa[i]+k]==y[sa[i-1]+k])?l:++l;
        if((w=l)==n)break;
    }
    for(int i=1;i<=n;i++)rk[sa[i]]=i;
    for(int i=1,j=0;i<=n;i++){
        if(j)j--;
        while(s[i+j]==s[sa[rk[i]-1]+j])j++;
        h[rk[i]][0]=j;
    }
    for(int i=1;i<=n;i++)lg[i]=lg[i>>1]+1;
    for(int j=1;j<lg[n];j++)
        for(int i=0;i+(1<<j-1)<=n;i++)
            h[i][j]=min(h[i][j-1],h[i+(1<<j-1)][j-1]);
}

signed main(){
    scanf("%d",&T);
    while(T--){
        scanf("%s%s",a+1,b+1);n=strlen(a+1);m=strlen(b+1);
        for(int i=1;i<=n;i++)s[i]=a[i];s[n+1]='#';for(int i=1;i<=m;i++)s[n+1+i]=b[i];n=n+m+1;
        sily();
        for(int i=1;i<=n-m-1-m+1;i++){
            int k=i;
            for(int j=1;j<=4&&k<=i+m;j++)k+=query(rk[k],rk[n-m+1+k-i])+1;
            if(k>i+m)ans++;
        }
        printf("%d\n",ans);ans=0;
        memset(sa,0,sizeof(sa));
        memset(rk,0,sizeof(rk));
        memset(c,0,sizeof(c));
    }
    return 0;
}
```

[record](https://www.luogu.com.cn/record/148412526)

---

## 作者：FutaRimeWoawaSete (赞：2)

考虑 $FFT$ 。        

我们看这字符集大小只有 $4$ ，我们考虑单独操作每个字符然后累加答案。            

枚举四个字符 $C_1 , C_2 , C_3 , C_4$ 。        

如果当前字符是枚举字符赋值我们的每项系数为 $1$ ，否则为 $0$ 。 想要表达当前字符串是否匹配就直接两项相乘即可，最后把所有情况累加在一起就可以求得总的匹配数量。           

令 $P(k)$ 为以 $k$ 结尾时的一段匹配的匹配数量，m 为 A 模式串长度，n 为 B 文本串长度，我们可以得到式子：

$P(k) = \sum_{i = 0} ^ m A(i) \times B(k - m + i + 1)$         

你看这 $A_i$ 就很不顺眼，老套路倒置一下：         

$S(m - i - 1) = A(i)$         

$P(k) = \sum_{i = 0} ^ m S(m - i - 1) \times B(k - m + i + 1)$     

$P(k) = \sum_{i + j == k} S(i) \times B(j)$ 

至此我们把我们的所求写成了卷积形式， $FFT$ 一下后看一下总的匹配数量加上 3 后可不可以大于等于 m 即可。           

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
const int Len = 1e5 + 5;
const double Pi = acos(-1);
int n,m;
struct CP
{
	double x,y;
	CP(double xx = 0.0 , double yy = 0.0){x = xx , y = yy;}
	CP operator + (const CP &B) const
	{return CP(x + B.x , y + B.y);}
	CP operator - (const CP &B) const
	{return CP(x - B.x , y - B.y);}
	CP operator * (const CP &B) const
	{return CP(x * B.x - y * B.y , x * B.y + y * B.x);}
	CP operator / (const double &B) const
	{return CP(x / B , y / B);}
	inline void clear(){x = 0.0 , y = 0.0;} 
	
}f[Len << 1] , g[Len << 1] , P[Len << 1];
int Ans[Len << 1];
int Rd[Len << 1] , Lens = 1 , cnt = 0;
char s[Len] , ss[Len] , Chosen[6] = {'A' , 'T' , 'C' , 'G'};
bool flag[35];
inline void Init(char c)
{
	for(int i = 0 ; i < Lens ; i ++) f[i].clear() , g[i].clear();
	for(int i = 0 ; i < m ; i ++) f[i].x = (ss[i] == c);
	for(int i = 0 ; i < n ; i ++) g[i].x = (s[i] == c);
	reverse(f , f + m);
}
inline void FFT(CP *f , int lens , bool flag)
{
	for(int i = 0 ; i < lens ; i ++) if(i < Rd[i]) swap(f[i] , f[Rd[i]]);
	for(int p = 2 ; p <= lens ; p <<= 1)
	{
		int len = p >> 1;
		CP mul(cos(2 * Pi / p) , sin(2 * Pi / p));
		if(flag) mul.y *= -1;
		for(int k = 0 ; k < lens ; k += p)
		{
			CP buf(1 , 0);
			for(int l = k ; l < k + len ; l ++)
			{
				CP tt = buf * f[len + l];
				f[len + l] = f[l] - tt;
				f[l] = f[l] + tt;
				buf = buf * mul;
			}
		}
	}
	if(flag) for(int i = 0 ; i < lens ; i ++) f[i] = f[i] / (1.0 * lens);
}
int main()
{
	int t;scanf("%d",&t);
	while(t --)
	{
		scanf("%s",s);scanf("%s",ss);
		n = strlen(s) , m = strlen(ss);
		Lens = 1 , cnt = 0;
		while(Lens <= n + m) Lens <<= 1;
		for(int i = 0 ; i < Lens ; i ++) Ans[i] = 0 , P[i].clear() , Rd[i] = (Rd[i >> 1] >> 1) | ((i & 1) ? Lens >> 1 : 0);
		for(int i = 0 ; i < 4 ; i ++)
		{
			Init(Chosen[i]);
			FFT(f , Lens , 0) , FFT(g , Lens , 0);
			for(int i = 0 ; i < Lens ; i ++) P[i] = f[i] * g[i];
			FFT(P , Lens , 1);
			for(int i = m - 1 ; i < Lens ; i ++) Ans[i] += (int)(P[i].x + 0.5); 
		} 
		int ans = 0;
		for(int i = m - 1 ; i < n ; i ++) 
			if(Ans[i] + 3 >= m) ans ++;
		printf("%d\n",ans);
	}
	return 0;
}
```

---

## 作者：Weekoder (赞：1)

### 思路

蒟蒻不会什么 FFT，后缀数组，只好老老实实写哈希了qwq。

题意：求在字符串 $S_0$ 中，有多少个长度为 $|S|$ 的子串，能在修改至多 $3$ 个位置后变为 $S$。

我们可以想到枚举每个子串并统计答案。相同的部分不需要修改，我们可以二分找到最长的相同前缀并加 $1$，表示跳过了不相同的一个字符。这个过程是在将 $S_{0_{i\dots i+|S|-1}}$ 和 $S_{1\dots |S|}$ 比较，由于加了 $1$，如果在某次二分后表示字符串 $S$ 的下标 $pos$ 满足 $pos>|S|$，就满足条件，可以贡献一个答案。否则，则需要判断最后一段字符串是否相同。

具体细节见代码，代码如下：

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef unsigned long long ull;

const int N = 1e5 + 5, base = 1e9 + 7;

int T, n, m;

string s0, s;

ull pw[N], hs1[N], hs2[N];

ull get_hash(ull hs[], int l, int r) {
	return hs[r] - hs[l - 1] * pw[r - l + 1]; 
}

int bin_search(int st1, int st2) { 
	int l = -1, r = m - st2 + 2;
	while (l + 1 < r) {
		int mid = l + r >> 1;
		if (get_hash(hs1, st1, st1 + mid - 1) == get_hash(hs2, st2, st2 + mid - 1))
			l = mid;
		else
			r = mid;
	}
	return l;
}

bool check(int pos) {
	int cnt = 1, last = pos + m - 1, poss = pos;
	for (int i = 1; i <= 3; i++) {
		int step = bin_search(pos, cnt);
		pos += step + 1;
		cnt += step + 1;
		if (cnt > m)
			return 1;
	}
	return get_hash(hs1, pos, last) == get_hash(hs2, cnt, m);
}

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin >> T;
	while (T --) {
		cin >> s0 >> s;
		n = s0.size(), m = s.size();
		s0 = '#' + s0, s = '#' + s;
		pw[0] = 1;
		for (int i = 1; i <= n; i++) {
			hs1[i] = hs1[i - 1] * base + s0[i];
			pw[i] = pw[i - 1] * base;
		}
		for (int i = 1; i <= m; i++)
			hs2[i] = hs2[i - 1] * base + s[i];
		int ans = 0;
		for (int i = 1; i + m - 1 <= n; i++)
			ans += check(i);
		cout << ans << "\n";
	}
	return 0;
}
```

---

## 作者：FANTASTlC (赞：0)

### 分析：
设计匹配函数，并使用 FFT 进行计算。
### 匹配函数：
可以发现，对于位置 k ， $S_{k...k+m-1}$ 与 $T_{0,m-1}$ 可以匹配的个数为 $\sum\limits_{i=0}^{m-1}S_{i+k}T_i$  ，但这还不是一个卷积的形式，无法直接使用 FFT 进行计算。利用 FFT 一个惯用的 trick ，将字符串 $T$ 倒置，即交换 $T_i$ 和 $T_{m-1-i}$ , 这时式子变为 $\sum\limits_{i=0}^{m-1}S_{i+k}T_{m-1-i} \iff \sum\limits_{i+j=m+k-1}S_iT_j$ ，可以直接使用 FFT 进行计算。
### 具体实现：
进行四轮 FFT ,每轮对于字符 $C_i$ 将所有等于 $C_i$ 的位置赋值为 1 ，否则赋值为 0 。
### Code:（常数较大）
```cpp
#include<bits/stdc++.h>
#define N (int)(4e5+1)
#define M 5001
#define R register
#define x first
#define y second
#define ll long long
#define db double
#define mp make_pair
#define pb push_back
#define lb(x) (x&-x)
#define mod 998244353
#define wt(x) write(x),puts("")
#define ot(x) write(x),putchar(' ')
#define INF 0x7fffffff
#define F(i,start,end) for(R int (i)=(start);(i)<=(end);i++)
#define T(i,end,start) for(R int (i)=(start);(i)>=(end);i--)
const db pi=acos(-1.00);
using namespace std;
template<typename T> void read(T &x)
{
	int f=1;
	x=0;
	char c=getchar();
	while(!isdigit(c))
	{
		if(c=='-')
			f=-1;
		c=getchar();
	}
	while(isdigit(c))
	{
		x=(x<<3)+(x<<1)+c-'0';
		c=getchar();
	}
	x*=f;
	return;
}
void write(R int x)
{
	if(x<0)
	{
		x=~x+1;
		putchar('-');
 	}
	if(x>9)
		write(x/10);
	putchar(x%10+'0');
	return;
}
int t,n,m,bit,lim,tot,inv[N],ans[N];
char s1[N],s2[N];
char c[]={'A','T','C','G'};
struct complex_
{
	db real,y;
	complex_ (db real_=0,db y_=0)
	{
		real=real_;
		y=y_;
		return;
	}
}a[N],b[N];
complex_ operator + (complex_ a,complex_ b)
{
	return complex_(a.real+b.real,a.y+b.y);
}
complex_ operator - (complex_ a,complex_ b)
{
	return complex_(a.real-b.real,a.y-b.y);
}
complex_ operator * (complex_ a,complex_ b)
{
	return complex_(a.real*b.real-a.y*b.y,a.real*b.y+a.y*b.real);
}
void fft(complex_ *a,int f)
{
	F(i,0,lim-1)
		if(i<inv[i])
			swap(a[i],a[inv[i]]);
	for(int mid=1;mid<lim;mid<<=1)
	{
		complex_ wn(cos(pi/mid),sin(pi/mid)*f);
		for(int size=mid<<1,j=0;j<lim;j+=size)
		{
			complex_ w(1,0);
			for(int k=0;k<mid;k++,w=w*wn)
			{
				complex_ a0=a[j+k],a1=w*a[j+k+mid];
				a[j+k]=a0+a1;
				a[j+k+mid]=a0-a1;
			}
		}
	}
	if(f==-1)	
		F(i,0,lim-1)
			a[i].real=a[i].real/lim;
	return;
}
void solve()
{
	scanf("%s%s",&s1,&s2);
	tot=0;
	n=strlen(s1),m=strlen(s2);
	for(bit=0,lim=1;lim<=n+m;lim<<=1,bit++);
	F(i,0,lim)
		inv[i]=(inv[i>>1]>>1)|((i&1)<<bit-1),ans[i]=0;
	F(i,0,3)
	{
 		F(j,0,n-1)
			a[j]=(complex_){s1[j]==c[i],0};
		F(j,0,m-1)
			b[m-j-1]=(complex_){s2[j]==c[i],0};
		fft(a,1),fft(b,1);
		F(j,0,lim)
			a[j]=a[j]*b[j];
		fft(a,-1);
		F(j,m-1,n-1)
			ans[j-m+1]+=((int)(a[j].real+0.5));
		F(j,0,lim-1)
			a[j]=b[j]=(complex_)(0,0);
	}
	F(i,0,n-m)
		if(ans[i]+3>=m)
			tot++;
	wt(tot);
	return;
}
int main()
{
	read(t);
	while(t--)
		solve();
	return 0;
}
```


---

## 作者：happybob (赞：0)

这不看完就会做吗。

显然对于 $S$ 每个长度为 $T$ 判断即可，由于只改 $3$ 个字符，所以我们求 LCP，然后 LCP 的下一个进行更改，最多 $3$ 次就退出。

可以使用字符串哈希，不过我写的是后缀数组。复杂度瓶颈在于后缀排序和区间 RMQ，使用 DC3 或 SA-IS，且使用线性 RMQ 可以做到线性复杂度。不过我还是选择了好写的倍增。注意多测清空。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <string>
#include <vector>
using namespace std;

const int N = 2e5 + 5;

int t;
string S, T, p;
int n, m, x[N], y[N], sa[N], rk[N], height[N], c[N];

int tmp[N];

void suffix_array()
{
	m = 255;
	for (int i = 1; i <= m; i++) c[i] = 0;
	for (int i = 1; i <= n; i++) c[x[i] = p[i]]++;
	for (int i = 1; i <= m; i++) c[i] += c[i - 1];
	for (int i = n; i >= 1; i--) sa[c[x[i]]--] = i;
	for (int k = 1; k <= n; k <<= 1)
	{
		int idx = 0;
		for (int i = 1; i <= m; i++) c[i] = 0;
		for (int i = n - k + 1; i <= n; i++) y[++idx] = i;
		for (int i = 1; i <= n; i++)
		{
			if (sa[i] > k) y[++idx] = sa[i] - k;
		}
		for (int i = 1; i <= n; i++) c[x[i]]++, tmp[i] = x[y[i]];
		for (int i = 1; i <= m; i++) c[i] += c[i - 1];
		for (int i = n; i >= 1; i--)
		{
			sa[c[tmp[i]]--] = y[i], y[i] = 0;
		}
		swap(x, y);
		x[sa[1]] = 1, idx = 1;
		for (int i = 2; i <= n; i++)
		{
			if (y[sa[i]] == y[sa[i - 1]] && y[sa[i] + k] == y[sa[i - 1] + k]) x[sa[i]] = idx;
			else x[sa[i]] = ++idx;
		}
		if (idx == n) break;
		m = idx;
	}
}

void get_height()
{
	for (int i = 1; i <= n; i++) rk[sa[i]] = i;
	int k = 0;
	for (int i = 1; i <= n; i++)
	{
		if (rk[i] == 1) continue;
		if (k) k--;
		while (i + k <= n && p[i + k] == p[sa[rk[i] - 1] + k]) k++;
		height[rk[i]] = k;
	}
}

int f[N][21], LG2[N];

void Init_LG2()
{
	for (int i = 2; i < N; i++) LG2[i] = LG2[i >> 1] + 1;
}

void Init_ST()
{
	for (int i = 1; i <= n; i++)
	{
		for (int j = 0; j < 21; j++) f[i][j] = 2e9;
	}
	for (int i = 1; i <= n; i++) f[i][0] = height[i];
	for (int j = 1; j <= LG2[n]; j++)
	{
		for (int i = 1; (i + (1 << j) - 1) <= n; i++)
		{
			f[i][j] = min(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);
		}
	}
}

int query(int l, int r)
{
	int g = LG2[r - l + 1];
	return min(f[l][g], f[r - (1 << g) + 1][g]);
}

int querylcp(int x, int y)
{
	int l = rk[x], r = rk[y];
	if (l > r) swap(l, r);
	return query(l + 1, r);
}

int main()
{
	ios::sync_with_stdio(0), cin.tie(0);
	Init_LG2();
	cin >> t;
	while (t--)
	{
		cin >> S >> T;
		if (T.size() > S.size())
		{
		    cout << "0\n";
		    continue;
		}
		p = S + "Z" + T;
		n = p.size();
		p = " " + p;
		for (int i = 1; i <= n; i++)
		{
			sa[i] = x[i] = y[i] = rk[i] = height[i] = tmp[i] = 0;
		}
		suffix_array();
		get_height();
		Init_ST();
		int ans = 0;
		for (int i = 0; i + T.size() - 1 < S.size(); i++)
		{
			int nowl = i + 1, nowr = S.size() + 2;
			int cnt = 0;
			while (nowr <= n)
			{
				int len = querylcp(nowl, nowr);
				nowl += len, nowr += len;
				if (nowr > n)
				{
					ans++;
					goto E;
				}
				if (cnt == 3) break;
				cnt++;
				nowl++, nowr++;
			}
			if (nowr > n) ans++;
		E:;
		}
		cout << ans << "\n";
	}
	return 0;
}
```


---


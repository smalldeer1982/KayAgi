# [NOIP 2017 提高组] 列队

## 题目背景

NOIP2017 D2T3

## 题目描述

`Sylvia` 是一个热爱学习的女孩子。

前段时间，`Sylvia` 参加了学校的军训。众所周知，军训的时候需要站方阵。

Sylvia 所在的方阵中有 $n \times m$ 名学生，方阵的行数为 $n$，列数为 $m$。

为了便于管理，教官在训练开始时，按照从前到后，从左到右的顺序给方阵中 的学生从 $1$ 到 $n \times m$ 编上了号码（参见后面的样例）。即：初始时，第 $i$ 行第 $j$ 列 的学生的编号是 $(i-1)\times m + j$。

然而在练习方阵的时候，经常会有学生因为各种各样的事情需要离队。在一天 中，一共发生了 $q$ 件这样的离队事件。每一次离队事件可以用数对 $(x,y) (1 \le x \le n, 1 \le y \le m)$ 描述，表示第 $x$ 行第 $y$ 列的学生离队。

在有学生离队后，队伍中出现了一个空位。为了队伍的整齐，教官会依次下达 这样的两条指令：


1. 向左看齐。这时第一列保持不动，所有学生向左填补空缺。不难发现在这条 指令之后，空位在第 $x$ 行第 $m$ 列。
2. 向前看齐。这时第一行保持不动，所有学生向前填补空缺。不难发现在这条 指令之后，空位在第 $n$ 行第 $m$ 列。


教官规定不能有两个或更多学生同时离队。即在前一个离队的学生归队之后， 下一个学生才能离队。因此在每一个离队的学生要归队时，队伍中有且仅有第 $n$ 行 第 $m$ 列一个空位，这时这个学生会自然地填补到这个位置。

因为站方阵真的很无聊，所以 `Sylvia` 想要计算每一次离队事件中，离队的同学 的编号是多少。

注意：每一个同学的编号不会随着离队事件的发生而改变，在发生离队事件后 方阵中同学的编号可能是乱序的。


## 说明/提示

【输入输出样例 $1$ 说明】

$$\begin{matrix}
\begin{bmatrix}
1 & 2 \\
3 & 4 \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
 & 2 \\
3 & 4 \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 &  \\
3 & 4 \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 & 4 \\
3 &  \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 & 4 \\
3 & 1 \\
\end{bmatrix} \\[1em]
\begin{bmatrix}
2 & 4 \\
3 & 1 \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 & 4 \\
3 &  \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 & 4 \\
3 &  \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 & 4 \\
3 &  \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 & 4 \\
3 & 1 \\
\end{bmatrix}\\[1em]
\begin{bmatrix}
2 & 4 \\
3 & 1 \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 &  \\
3 & 1 \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 &  \\
3 & 1 \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 & 1 \\
3 &  \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 & 1 \\
3 & 4 \\
\end{bmatrix}
\end{matrix}$$


列队的过程如上图所示，每一行描述了一个事件。 在第一个事件中，编号为 $1$ 的同学离队，这时空位在第一行第一列。接着所有同学 向左标齐，这时编号为 $2$ 的同学向左移动一步，空位移动到第一行第二列。然后所有同 学向上标齐，这时编号为 $4$ 的同学向上一步，这时空位移动到第二行第二列。最后编号为 $1$ 的同学返回填补到空位中。

【数据规模与约定】

| 测试点编号 | $n$ | $m$ | $q$ | 其他约定 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1\sim 6$ | $\le 10^3$ | $\le 10^3$ | $\le 500$ | 无 |
| $7\sim 10$ | $\le 5\times 10^4$ | $\le 5\times 10^4$ | $\le 500$ | 无 |
| $11\sim 12$ | $=1$ | $\le 10^5$ | $\le 10^5$ | 所有事件 $x=1$ |
| $13\sim 14$ | $=1$ | $\le 3\times 10^5$ | $\le 3\times 10^5$ | 所有事件 $x=1$ |
| $15\sim 16$ | $\le 3\times 10^5$ | $\le 3\times 10^5$ | $\le 3\times 10^5$ | 所有事件 $x=1$ |
| $17\sim 18$ | $\le 10^5$ | $\le 10^5$ | $\le 10^5$ | 无 |
| $19\sim 20$ | $\le 3\times 10^5$ | $\le 3\times 10^5$ | $\le 3\times 10^5$ | 无 |

数据保证每一个事件满足 $1 \le x \le n,1 \le y \le m$。


## 样例 #1

### 输入

```
2 2 3 
1 1 
2 2 
1 2 ```

### 输出

```
1
1
4
```

# 题解

## 作者：小粉兔 (赞：269)

> 我是洛谷全站跑得最快的，1488ms。
> 使用筛选最优解的新功能就可以找到我。
> 使用的是 NOIP 范围的算法，不是平衡树，是树状数组。

------------

考虑前 $50 \%$：

观察到 $q \leq 500$，也就是说有效的行数不超过 $500$ 行。

我们把行数离散化。

那么需要维护的数的数量最多只有 $q (m - 1) + n$ 个

一次操作的复杂度最多是 $n + m - 1$。

那么时间复杂度 $\mathcal O (q \log q + q (n + m - 1))$，空间复杂度$\mathcal O (q (m - 1) + n)$。


------------

再看接下来的 $30 \%$：

发现有 $x_i = 1$，也就是说，有效的格子只有第一行和最后一列。

我们把第一行和最后一列压到一起去，那么我们要对这个序列支持：

1. 删除第 $k$ 个元素

2. 在末尾添加一个元素

这个操作能用平衡树实现，但是我用树状数组来实现。

用树状数组维护一个 01 序列，第 $i$ 位上是 0 表示这个位置上的数已经被删除了或者还没有被插入，第 $i$ 位上是 1 表示这一位上的数没有被删除。

那么删除操作就是 $1 \to 0$，插入操作就是 $0 \to 1$。

第 $k$ 个元素就是前缀和为 $k$ 的位置。

对于查找这个位置的操作，我使用树状数组二分，具体见代码，时间 $\mathcal O (\log n)$。


------------

那么最后的 $20 \%$ 呢？

定义一行中原来的元素为**初始**时这一行前 $m - 1$ 个元素中，没有离队过的元素。

我们观察到对于本来就在这一行中的元素，我们可以直接算出它的值，而不用存储。

那么我们判断每一次询问是不是在本行的原来的元素中，如果是，直接判断掉。

那么每一行的“非原来的元素”有多少个呢？

我们不知道一行会有多少个，但是我们知道，所有行的这样的元素个数的总和不超过 $q$ 个。

这启发了我们对于每一行，只对其“非原来的元素”开一个树状数组维护。

而对于“原来的元素”，我们直接离线预处理。

预处理时需要对所有的询问按照 $x_i$ 为第一关键字，询问编号为第二关键字排序。

再对最后一列单独处理。

时间复杂度 $\mathcal O (q \log q + q \log m + q \log (n + q))$，空间复杂度 $O(n + m + q)$。

具体看代码吧！


代码：

```cpp
#pragma GCC optimize("O2")
#include<cstdio>
#include<cstring>
#include<algorithm>
#define F(i,a,b) for(int i=a;i<=b;++i)
#define dF(i,a,b) for(int i=a;i>=b;--i)
#define F2(i,a,b) for(int i=a;i<b;++i)
#define getchar() (SS==TT&&(TT=(SS=BB)+fread(BB,1,1<<15,stdin),TT==SS)?EOF:*SS++)
#define RR register
char BB[1<<15],*SS=BB,*TT=BB;
inline int read(){
	RR int x;RR bool f;RR char c;
	for (f=0; (c=getchar())<'0'||c>'9'; f=c=='-');
	for (x=c-'0'; (c=getchar())>='0'&&c<='9'; x=(x<<3)+(x<<1)+c-'0');
	return f?-x:x;
}
using namespace std;
int q,I[300010];
long long n,m,a[300010],b[300010];
inline bool cmp(int p1,int p2){return a[p1]==a[p2]?p1<p2:a[p1]<a[p2];}
int h[300010],len[300010],len2[300010],bit[900010];
long long arr[900010];
long long Ans[300010];
inline void Ins(int*array,int siz,int i,int x){for(;i<=siz;array[i]+=x,i+=i&-i);}
inline int binary(int*array,int siz,int x){
	int l=1,r,mid,sum,ans;
	while(l<=siz&&array[l]<x) l<<=1, ans=l;
	r=l; sum=array[l>>=1];
	while(l<r-1){
		mid=l+r>>1;
		if(mid>siz||array[mid]+sum>=x) r=mid, ans=mid;
		else l=mid, sum+=array[l];
	} ans=r;
	return ans;
}
int stk[300001],top;
int main(){
	n=read(), m=read(), q=read();
	F(i,1,q) a[i]=read(), b[i]=read(), I[i]=i;
	sort(I+1,I+q+1,cmp);
	F(i,1,m-1) Ins(bit,m-1,i,1);
	F(i,1,n) len[i]=m-1;
	F(i,1,q){
		if(a[I[i-1]]!=a[I[i]])
			while(top) Ins(bit,m-1,stk[top--],1);
		if(b[I[i]]>len[a[I[i]]]) continue;
		int pos=binary(bit,m-1,b[I[i]]);
		Ans[I[i]]=(a[I[i]]-1)*m+pos;
		Ins(bit,m-1,pos,-1);
		stk[++top]=pos;
		--len[a[I[i]]];
	}
	int iter=0;
	F(i,1,n){
		while(iter<=q&&a[I[iter]]<i) ++iter;
		h[i]=iter-1;
	}
	h[n+1]=q;
	memset(bit,0,sizeof bit);
	F(i,1,n) len[i]=0, len2[i]=m-1; len[n+1]=n;
	F(i,1,n) Ins(bit+h[n+1],n+q,i,1), arr[q+i]=i*m;
	F(i,1,q){
		if(Ans[i]){
			int pos=binary(bit+h[n+1],n+q,a[i]);
			Ins(bit+h[n+1],n+q,pos,-1);
			Ins(bit+h[n+1],n+q,++len[n+1],1);
			arr[h[n+1]+len[n+1]]=Ans[i];
			Ins(bit+h[a[i]],h[a[i]+1]-h[a[i]],++len[a[i]],1);
			arr[h[a[i]]+len[a[i]]]=arr[h[n+1]+pos];
			--len2[a[i]];
		}
		else{
			int pos=binary(bit+h[n+1],n+q,a[i]);
			Ins(bit+h[n+1],n+q,pos,-1);
			Ins(bit+h[n+1],n+q,++len[n+1],1);
			if(b[i]!=m){
				int pos2=binary(bit+h[a[i]],h[a[i]+1]-h[a[i]],b[i]-len2[a[i]]);
				Ins(bit+h[a[i]],h[a[i]+1]-h[a[i]],pos2,-1);
				Ans[i]=arr[h[a[i]]+pos2];
				Ins(bit+h[a[i]],h[a[i]+1]-h[a[i]],++len[a[i]],1);
				arr[h[a[i]]+len[a[i]]]=arr[h[n+1]+pos];
			} else Ans[i]=arr[h[n+1]+pos];
			arr[h[n+1]+len[n+1]]=Ans[i];
		}
	}
	F(i,1,q) printf("%lld\n",Ans[i]);
	return 0;
}
```

---

## 作者：YoungNeal (赞：61)

题解在博客[食用](http://www.cnblogs.com/YoungNeal/p/9063703.html)效果更佳哦~

## Solution

$fhq\_Treap$ [了解一下](http://www.cnblogs.com/YoungNeal/p/8977328.html)

---

### 算法部分

这题不管怎么做直接存每个人都会炸，所以我们用 $Treap$ 维护区间，即 $Treap$ 上的每个节点代表的是一个区间。

对于每行从第 $1$ 列到第 $m-1$ 列维护一个 $Treap$。

对于最后一列我们单独维护一个 $Treap$ 。

如果 $(x,y)$ 出队，要分两种情况讨论，第一种 $y=m$，即出队的人在最后一列的情况，如果不讨论的话我们在每行维护的 $Treap$ 上是找不到这个点的，因此需要分类。  
对于这种情况，我们直接在最后一列的 $Treap$ 中找到第 $x$ 个人，把它 $split$ 出来，然后 $merge$ 到结尾即可。

(关于如何 $split$ 和 $merge$ 下面有讲)

第二种 $y\neq m$。  
对于这种情况，我们需要在第 $x$ 行的那个 $Treap$ 中找到第 $y$ 个点，把它 $split$ 出来记为点 $a$，同时在最后一列的 $Treap$ 中找到第 $x$ 个点，同样 $split$ 出来记为点 $b$ 。  
之后把点 $b$ 合并到第 $x$ 行 $Treap$ 的最后一个节点，把点 $a$ 合并到最后一列的 $Treap$ 的最后一个节点即可。

---

### 实现部分

这题 $fhq\_Treap$ 难实现的地方就在如何 $split$ 出一个不存在的节点(因为我们维护的一直是区间，而这题里 $split$ 要做的就是在一个大区间的基础上 $split$ 出两个新的小区间)

如何处理呢？

仿照一般 $fhq\_Treap$ 的 $split$ 操作，我们定义 
```cpp
split(int now,int k,int &x,int &y)
```
表示在以 $now$ 为根的子树中进行分离，分离出的左子树大小为 $k$，根节点为 $x$,分离出的右子树根节点为 $y$ (我们并不能知道右子树的大小是多少)。

这时我们就要分情况讨论了：

如果 $now$ 的左子树的大小已经大于了 $k$，那么我们就不用把 $now$ 这个点拆开而是递归进入 $now$ 的左子树进行处理。

否则我们就要进行麻烦的裂点操作了。

因为要在以 $now$ 为根的子树中分出  $k$ 个，所以我们要从 $now$ 和 $now$ 的右子树里分出 $k-sze[ch[now][0]]$ 个。

这里又要分情况讨论：

如果 $now$ 这个点维护的区间大小不小于 $k$ 的话，从 $now$ 里分出大小为
$k-sze[ch[now][0]]$ 的区间即可(因为左子树已经有了 $sze[ch[now][0]]$ 那么多)。

否则就要调用
```cpp
split(ch[now][1],k-sze[ch[now][0]]-(r[now]-l[now]+1),ch[now][1],y)
```

这个意思是，把 $now$ 这个点的区间全部给了左子树还是不够，所以要进入右子树分剩下的大小为 $k-sze[ch[now][0]]-(r[now]-l[now]+1)$ 的区间。

但是实际写代码的时候不必要那么复杂的分类讨论。因为如果 $split$ 传进去的 $k$ 是非正整数的话(对应第一种情况)，那么递归会一直进入左子树，相反对于第二种情况，在分裂新节点的时候判一下就可以了，大概长这样。
```cpp
void split_new(int now,int k){
	if(k>=r[now]-l[now]+1) return;
	...
}
```

---

## Code
```cpp
#include<ctime>
#include<cstdio>
#include<cstdlib>
#include<iostream>
#define N 300005
#define int long long

int root[N];
int n,m,T,tot;
int ch[N*20][2];
int l[N*20],r[N*20];
int sze[N*20],prio[N*20];

int newnode(int x,int y){
	tot++;
	l[tot]=x;
	r[tot]=y;
	sze[tot]=y-x+1;
	prio[tot]=rand();
	return tot;
}

void pushup(int x){
	sze[x]=sze[ch[x][0]]+sze[ch[x][1]]+r[x]-l[x]+1;
}

int merge(int x,int y){
	if(!x or !y) return x+y;
	if(prio[x]<prio[y]){
		ch[x][1]=merge(ch[x][1],y);
		pushup(x);
		return x;
	}
	else{
		ch[y][0]=merge(x,ch[y][0]);
		pushup(y);
		return y;
	}
}

void split_new(int now,int k){//把now的大小变为k
	if(k>=r[now]-l[now]+1) return;
	int want=l[now]+k-1;
	int nn=newnode(want+1,r[now]);
	r[now]=want;
	ch[now][1]=merge(nn,ch[now][1]);
	pushup(now);
}

void split(int now,int k,int &x,int &y){
	if(!now) x=y=0;
	else{
		if(sze[ch[now][0]]>=k){
			y=now;
			split(ch[now][0],k,x,ch[now][0]);
		}
		else{
			split_new(now,k-sze[ch[now][0]]);
			x=now;
			split(ch[now][1],k-sze[ch[now][0]]-(r[now]-l[now]+1),ch[now][1],y);
		}
		pushup(now);
	}
}

signed main(){
	srand(time(0));
	scanf("%lld%lld%lld",&n,&m,&T);
	for(int i=1;i<=n;i++)
		root[i]=newnode((i-1)*m+1,i*m-1);
	for(int i=1;i<=n;i++)
		root[n+1]=merge(root[n+1],newnode(i*m,i*m));
	while(T--){
		int a,b;
		scanf("%lld%lld",&a,&b);
		if(b!=m){
			int x,y,z;
			split(root[a],b,x,y);
			split(x,b-1,x,z);
			printf("%lld\n",l[z]);
			int x1,y1,z1;
			split(root[n+1],a,x1,y1);
			split(x1,a-1,x1,z1);
			root[a]=merge(x,merge(y,z1));
			root[n+1]=merge(x1,merge(y1,z));
		}
		else{
			int x,y,z;
			split(root[n+1],a,x,y);
			split(x,a-1,x,z);
			printf("%lld\n",l[z]);
			root[n+1]=merge(x,merge(y,z));
		}
	}
	return 0;
}
```

---

## 作者：犇犇犇犇 (赞：46)

来一份树状数组的题解qaq

首先我们可以发现每次操作总是当前一个人离开。    
向左标齐：删掉当前那一位，**同一行**的人来补上。   
向上标齐：由于最后一列的一个数被补到那一行上，相当于最后一列也被删去一个数。离开的那个人补上。    
 
我们发现行与行之间无直接关联。所以我们可以将队列分为 $n$ 行，每行 $m-1$ 个数为一个序列，以及最后一列，共 $m$ 个数为一个序列。如下图所示。我们把第 $1$ 到 第 $n$ 行的序列编号 1~n ，最后一列的序列编号为 $0$ 号序列。


![1.jpg](https://i.loli.net/2020/10/26/altgksUhvbTfINL.jpg)

比如我们现在要删除8，我们首先先把 $2$ 号序列中 8 删去，把 $0$ 号序列中 10 删去 ， 把 10 添加到 $2$ 号序列 末尾，把 8 添加到 $0$ 号序列末尾。    

我们发现每个序列需要支持的操作是一样的：      
1. 任意查询删除队列中的第 i 个元素。   
2. 在末尾添加元素。  

同时需要支持任意查询删除，在任意位置添加元素的数据结构需要使用平衡树。但是我们可以发现这里只需要支持**在末尾插入元素**，所以我们可以使用二分+树状数组来实现。  

对于一个序列，我们初始化给每个序列一个1，表示当前每个数都存在。如果第 $i$ 个数被删除，那么我们把它的下标变成 $0$ ，表示当前数已经被删除。我们在求前 $i$ 个数的前缀和时，因为只有存在才会加1，我们得到的就是前 $i$ 个数还有多少个数存在。即第 $i$ 个元素就是前缀和为 $i$ 的位置。于是我们可以**二分**，就可以实现任意访问删除了。末尾插入我们可以直接使用vector在末尾插入就行了。这里要注意的是如果前缀和很多个**相等**，代表我们要找的数右边有很多个数被删除，值为0，所以一直到下一个存在的数为止前缀和都相等。所以我们二分是需要找**下标最小的数**。



```cpp
inline int lowbit(int x)
{
	return x&-x;
} 
inline void add(int x,int k)
{
	while(x<=mx)
	{
		d[x]+=k;
		x+=lowbit(x);
	}
	return;
}
inline int query(int x)
{
	int ans=0;
	while(x)
	{
		ans+=d[x];
		x-=lowbit(x);
	}
	return ans;
} //树状数组模板
int select(int k)
{
	int l=0,r=mx,ans=mx;
	while(l<=r) //二分
	{
		int mid=(l+r)>>1;
		if(query(mid)>=k) //当前的mid比我们需要的大
		{
			ans=mid;
			r=mid-1;
		}
		else
			l=mid+1;
	}
	return ans;
}
```

此时我们已经可以维护每一个序列了。但我们目前可以做到指定下标删除插入。但题目给出的是对于当前序列的相对坐标，我们需要处理出它相对于原始序列的坐标为止。    
比如有一个序列 1 2 3 4 5。首先我们删除第二个数，变为 1 3 4 5 6。此时我们继续删除**当前序列**的第二个数，我们需要删除3，即我们需要删除**原序列**中的第3个数。所以我们需要处理出对于每一行操作，预处理出数组 $pre[i]$ 表示第 $i$ 个询问应该是第 $x$ 行对于原序列的第几个数。

这个过程也可以树状数组+二分完成。我们先把所有的操作全部离线储存，对于第 $i$ 行，我们一共需要删除k次，每次需要删除**当前序列**的第 $x$个数。继续使用上面对于序列的操作使用树状数组对于每一行标记，0表示当前行第 $i$ 个数已经被删去，1表示存在。当前序列第 $i$ 个元素就是前缀和为 $i$ 的位置。

```cpp
struct node
{
	int k,id; //k表示删除第k个数，id表示对于第i个询问
	node(int _k,int _id)
	{
		k=_k;id=_id;
	}
};
vector<node> v[MAXN];

n=read();m=read();q=read();
mx=max(m,n)+q; //树状数组大小，后文提到
for(int i=1;i<=q;i++)
{
	x[i]=read();
	y[i]=read();
	if(y[i]!=m) //修改最后一列，不在当前序列上
		v[x[i]].push_back(node(y[i],i));
}
for(int i=1;i<=mx;i++)
	add(i,1); //初始为1
for(int i=1;i<=n;i++)
{ 
	for(int j=0;j<v[i].size();j++) 
	{
		node t=v[i][j];
		pre[t.id]=select(t.k); //记录实际位置
		add(pre[t.id],-1); //把当前数删除
	}
	for(int j=0;j<v[i].size();j++)
	{
		node t=v[i][j]; 
		add(pre[t.id],1); //还原当前序列的树状数组，避免干扰下一次树状数组的查询。
	}
}
```

因为我们注意到这道题的数据范围为3e5，所以我们没法对每一行都使用树状数组，每次读入一个操作就在当前行的树状数组进行操作。所以我们需要离线，处理出当前行所需要的所有操作。这样我们的预处理就可以在一个树状数组上完成了。这是我们需要每次还原树状数组的目的，也是我们离线做的目的。



我们可以发现，对于每个序列，初始的时候序列为一个等差序列，我们称这些数为**原数**。后面这些原序列中的数会逐渐被删除，从而被从末尾添加进来的**新数**替代，对于原数，位于行上的一共有 $m$ 个，位于列上的一共有 $n$ 个。新数每次对当前行进行末尾添加操作时会增加一个。一共有 $q$ 次操作，所以序列中最多有$\max(n,m)+q$ 个元素。所以我们选取树状数组大小 $mx = \max(n,m)+q$ 。 

对于原数，我们可以直接使用公式第 $i$ 行第 $j$ 列 的学生的编号是  $(i−1)×m+j$ 直接算出。对于新数，我们则从每次从末尾添加新数的vector中取出。对于每一行，我们只需要判断当前需要删除的数 $pre[i]$  与 $m$ 的关系就可以判断出是否在原数列上，如果它在新数列上，因为新数列的编号是从0开始的，则它在新数列上的编号需要减去原数列中的数（ $m-1$ 个数），即它的编号为 $pre[i]-(m-1)+1$ ；对于列上的数，同理，我们需要操作的数为当前序列的 $x[i]$ 即原序列的 $select(x[i])$ ，只需要比较它与 $n$ 的关系即可，同理新数列的编号需要减去 $n+1$。

接下去我们就可以来维护整道题了。因为之前行的修改已经被我们与处理好了，我们的树状数组这时处理列上的修改。我们首先处理出我们需要处理行的最后一个数 $last$。它在 $0$ 号序列上，如果它在是第 $t$ 个数代表它在第 $t$ 行上，编号为 $t \times m$。

如果 $y[i]=m$ 则删除的数就在 $0$ 号序列上，$last$ 即为答案。我们把这个数添加到当前行序列的最后一个,同时在行序列中算出当前离开的数字 $ans$，并把它添加到 $0$ 号序列的最后一个。

```cpp
for(int i=1;i<=q;i++)
{
	int t=select(x[i]),ans,last; //选出列上的数
	add(t,-1); //删除
	if(t<=n) 
		last=t*m; //在原数中
	else
		last=s[0][t-n-1]; //在新数中
	if(y[i]!=m) //当前查询的数不在最后一列上
	{
		s[x[i]].push_back(last); //把列上的数放到行中
		if(pre[i]<m)
			ans=(x[i]-1)*m+pre[i];//原数中
		else
			ans=s[x[i]][pre[i]-m];//新数中
    }
	else 
		ans=last;//如果在最后一列上，last即为答案
	s[0].push_back(ans); //把当前离队的人放到队尾
	cout<<ans<<endl;//输出
}
```



这样这道题就结束了，个人感觉这道题对于操作的拆分以及对于树状数组的使用还是挺妙的。  

放上完整代码：  

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int MAXN = 3e5+5; 
inline int read()
{
	int x=0,f=1;char c=getchar();
	while(c<'0' || c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0' && c<='9'){x=x*10+c-'0';c=getchar();}
	return x*f;
}
struct node
{
	int k,id;
	node(int _k,int _id)
	{
		k=_k;id=_id;
	}
};
int n,m,q,x[MAXN],y[MAXN],mx;
int d[MAXN<<1],pre[MAXN];
vector<node> v[MAXN];
vector<int> s[MAXN];
inline int lowbit(int x)
{
	return x&-x;
}
inline void add(int x,int k)
{
	while(x<=mx)
	{
		d[x]+=k;
		x+=lowbit(x);
	}
	return;
}
inline int query(int x)
{
	int ans=0;
	while(x)
	{
		ans+=d[x];
		x-=lowbit(x);
	}
	return ans;
}
int select(int k)
{
	int l=0,r=mx,ans=mx;
	while(l<=r)
	{
		int mid=(l+r)>>1;
		if(query(mid)>=k)
		{
			ans=mid;
			r=mid-1;
		}
		else
			l=mid+1;
	}
	return ans;
}
signed main()
{
	n=read();m=read();q=read();
	mx=max(m,n)+q;
	for(int i=1;i<=q;i++)
	{
		x[i]=read();
		y[i]=read();
		if(y[i]!=m)
			v[x[i]].push_back(node(y[i],i));
	}
	for(int i=1;i<=mx;i++)
		add(i,1);
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<v[i].size();j++)
		{
			node t=v[i][j];
			pre[t.id]=select(t.k);
			add(pre[t.id],-1);
		}
		for(int j=0;j<v[i].size();j++)
		{
			node t=v[i][j];
			add(pre[t.id],1);
		}
	}
	for(int i=1;i<=q;i++)
	{
		int t=select(x[i]),ans,last;
		add(t,-1);
		if(t<=n)
			last=t*m;
		else
			last=s[0][t-n-1];
		if(y[i]!=m)
		{
			s[x[i]].push_back(last);
			if(pre[i]<m)
				ans=(x[i]-1)*m+pre[i];
			else
				ans=s[x[i]][pre[i]-m];
		}
		else 
			ans=last;
		s[0].push_back(ans);
		cout<<ans<<endl;
	}
	return 0;
}
```



---

## 作者：chenxia25 (赞：11)

>### [洛谷题目页面传送门](https://www.luogu.com.cn/problem/P3960)

>题意见洛谷。

### 方法$1$：平衡树

不难发现，行与行之间的操作是独立的，而都与最后一列有关。很自然地想到维护每一行的前$m-1$个元素和最后一列。

不难发现，一次$(x,y)$离队，可以分成两种情况：

1. $y=m$。可以看作将最后一列的第$x$个移到最后；
1. $y\neq m$。可以看作：
   1. 将第$x$行第$y$个移到最后一列最后；
   1. 将最后一列第$x$个移到第$x$行最后。

这些维护序列的删除、插入、查询第$k$个，一看就是序列之王平衡树的操作，这里使用fhq-Treap。

至于，如果暴力维护平衡树的话，建树就要MLE，是$\mathrm O(nm)$的。考虑用[fbb的OJ](https://www.luogu.com.cn/problem/P3285)那题的trick，任意时刻，所有没有被拎出来的naive元素组成的极大区间（区间内编号连续），我们把它们缩成一个点。

代码里操作能合并的合并，修改操作也可以返回原值减少操作量，来减小常数，毕竟这不是正解/cy

由于要删除节点，我开了垃圾回收，其实根本不用，就当练习一下（

一开始觉得挺难，现在看来是个挺板的题啊。。时间复杂度$\mathrm O(q\log n)$（假设$n,m$同阶）。

这里讲一个我代码里犯的稀有的错误：这是我第一次用`vector`存节点写平衡树，其中建树的时候我是这样写的：

```cpp
if(l<mid)lson(p)=bld(l,mid-1);
if(r>mid)rson(p)=bld(mid+1,r);
```
以第一句为例，这里`lson(p)`和`bld(l,mid-1)`的执行顺序直觉是先后者后先者，但其实不是，究竟是先先者后后者还是UB我也说不清，详见[这篇帖子](https://www.luogu.com.cn/discuss/show/237813)。问题来了，`bld`函数会调用`nwnd`函数新建节点并调用`vector`的`push_back`函数，这会使`vector`重新分配内存，导致`lson(p)`的地址变了，进而导致值赋不进去。我调这个代码的那天晚上还以为闹鬼了，差点把我整哭了（捂脸

所以应该找个中间变量存下来：

```cpp
int res;
if(l<mid)res=bld(l,mid-1),lson(p)=res;
if(r>mid)res=bld(mid+1,r),rson(p)=res;
```

代码（开洛谷自带O2才能过哦，毒瘤）：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define pb push_back
#define mp make_pair
#define X first
#define Y second
typedef long long ll;
mt19937 rng(20060617);
const int N=300000;
int n,m,qu;
struct fhq_treap{//平衡树 
	int root;
	struct node{unsigned key;int lson,rson,sz,real_sz;ll l,r;};
	#define key(p) nd[p].key
	#define lson(p) nd[p].lson
	#define rson(p) nd[p].rson
	#define sz(p) nd[p].sz
	#define real_sz(p) nd[p].real_sz
	#define l(p) nd[p].l
	#define r(p) nd[p].r
	vector<node> nd;//vector存节点 
	stack<int> bin;//垃圾桶 
	int nwnd(ll l,ll r){//新建节点 
		if(l>r)return 0;
		if(bin.size()){//用垃圾 
			int p=bin.top();
			bin.pop();
			return nd[p]=node({rng(),0,0,1,int(r-l+1),l,r}),p;
		}
		return nd.pb(node({rng(),0,0,1,int(r-l+1),l,r})),nd.size()-1;
	}
	void sprup(int p){sz(p)=sz(lson(p))+1+sz(rson(p));real_sz(p)=real_sz(lson(p))+r(p)-l(p)+1+real_sz(rson(p));}
	int bld(int l=1,int r=n){//建树 
		int mid=l+r>>1,p=nwnd(1ll*mid*m,1ll*mid*m);
		int res;
		if(l<mid)res=bld(l,mid-1),lson(p)=res;
		if(r>mid)res=bld(mid+1,r),rson(p)=res;//讷，错误就在这里 
		sprup(p);
		return sprup(p),p;
	}
	void init(ll l=0,ll r=0){
		nd.pb(node({0,0,0,0,0,0,0}));
		if(l)root=nwnd(l,r);
		else root=bld();
	}
	pair<int,int> split(int x,int p=-1){~p||(p=root);
		if(!x)return mp(0,p);
		pair<int,int> sp;
		if(x<=sz(lson(p)))return sp=split(x,lson(p)),lson(p)=sp.Y,sprup(p),mp(sp.X,p);
		return sp=split(x-1-sz(lson(p)),rson(p)),rson(p)=sp.X,sprup(p),mp(p,sp.Y);
	}
	int mrg(int p,int q){
		if(!p||!q)return p|q;
		if(key(p)<key(q))return rson(p)=mrg(rson(p),q),sprup(p),p;
		return lson(q)=mrg(p,lson(q)),sprup(q),q;
	}
	pair<int,int> rk(int x,int p=-1){~p||(p=root);//在树中的排名（算naive区间） 
		if(x<=real_sz(lson(p)))return rk(x,lson(p));
		if(x<=real_sz(lson(p))+r(p)-l(p)+1)return mp(sz(lson(p))+1,x-real_sz(lson(p)));
		pair<int,int> res=rk(x-(real_sz(lson(p))+r(p)-l(p)+1),rson(p));
		return mp(sz(lson(p))+1+res.X,res.Y);
	}
	void recyc(int p){bin.push(p);}//垃圾回收 
	ll del(int x){//删除点 
		pair<int,int> _rk=rk(x);
		pair<int,int> sp=split(_rk.X-1),sp0=split(1,sp.Y);
		node tmp=nd[sp0.X];
		recyc(sp0.X);//垃圾回收 
		int l=nwnd(tmp.l,tmp.l+_rk.Y-2),r=nwnd(tmp.l+_rk.Y,tmp.r);
		return root=mrg(sp.X,mrg(l,mrg(r,sp0.Y))),tmp.l+_rk.Y-1;
	}
	ll chg_mv_bk(int x,ll v=0){//修改并移到最后 
		pair<int,int> _rk=rk(x);
		pair<int,int> sp=split(_rk.X-1),sp0=split(1,sp.Y);
		ll res=l(sp0.X)+_rk.Y-1;
		int l=nwnd(l(sp0.X),l(sp0.X)+_rk.Y-2),r=nwnd(l(sp0.X)+_rk.Y,r(sp0.X));
		l(sp0.X)=r(sp0.X)=v?v:res,real_sz(sp0.X)=1;
		return root=mrg(sp.X,mrg(l,mrg(r,mrg(sp0.Y,sp0.X)))),res;
	}
	void pb(ll v){//在最后压入 
		root=mrg(root,nwnd(v,v));
	}
}trp_r[N+1],&trp_c=trp_r[0];
int main(){
	cin>>n>>m>>qu;
	for(int i=1;i<=n;i++)trp_r[i].init(1ll*(i-1)*m+1,1ll*i*m-1);
	trp_c.init();//最后一列要普通建树，因为编号不连续/kk 
	while(qu--){
		int x,y;
		scanf("%d%d",&x,&y);
		if(y==m){//情况1 
			printf("%lld\n",trp_c.chg_mv_bk(x));
		}
		else{//情况2 
			ll res=trp_r[x].del(y);
			printf("%lld\n",res);
			trp_r[x].pb(trp_c.chg_mv_bk(x,res));
		}
	}
	return 0;
}
```

### 方法$2$：动态开点线段树

回想当年不会平衡树的时候，想着咋用现有知识维护序列插入删除。一个想法是：给每个位置设一个值$0/1$，$1$表示还健在，$0$表示被删了。删除操作就赋$0$，查询第$k$个就二分出前缀和等于$k$的第一个位置，那么插入呢？就无能为力了。幸运的是，这题的插入操作只存在于末尾，于是我们在末尾直接新建节点即可。考虑到空间开不下，我们用动态开点线段树维护，查询的话线段树二分。然后大概也是跟平衡树一样缩点。

代码很难写，不想写了。常数应该小一点？

### 方法$3$：BIT（正解）

考虑继续缩小常数。注意到，单点查询和在前缀和上二分（BIT倍增，这里由于BIT只能从左往右倍增最右值，而我们要查最左边的$\geq k$的位置，只需要转化为最右边的$<k$的位置加一即可）刚好都是BIT能支持的，考虑使用BIT。

但是BIT不能动态开点，空间受不了怎么办呢？

考虑这样一个方法：将询问离线下来，依次处理每行的前$m-1$个元素（每行内部按时间戳排序），把查询的结果记下来，处理完之后撤销影响处理下一个，这样空间只需要开一个BIT，时间复杂度也是不变的。

由于没有按原顺序操作，我们并不能知道每个位置的具体编号。这样再从头按原顺序来一遍，此时每个行都不需要BIT了，把BIT留给最后一列实时操作，每行及最后一列开个`vector`记录插入末尾的编号，就可以实时查询任意合法位置的编号了。

代码（不开O2也每个点在$1\mathrm s$内）：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define pb push_back
typedef long long ll;
int lowbit(int x){return x&-x;}
const int N=300000,QU=300000;
int n,m,qu;
struct query{int x,y,id;}qry[QU+1];
bool cmp(query x,query y){return x.id<y.id;}
vector<query> v[N+1];
struct bitree{//BIT 
	int sum[N+QU+1];
	void init(){memset(sum,0,sizeof(sum));}
	void add(int x,int v){//单点加 
		while(x<=max(n,m)+qu)sum[x]+=v,x+=lowbit(x);
	}
	int fd(int x){//BIT倍增 
		int res=0,now=0;
		for(int i=20;~i;i--)if(res+(1<<i)<=max(n,m)+qu&&now+sum[res+(1<<i)]<x)res+=1<<i,now+=sum[res];
		return res+1;
	}
}bit;
int fd[N+1];//记录查询结果 
vector<ll> bk_r[N+1],&bk_c=bk_r[0];
int main(){
	cin>>n>>m>>qu;
	for(int i=1;i<=qu;i++)scanf("%d%d",&qry[i].x,&qry[i].y),qry[i].id=i,qry[i].y<m&&(v[qry[i].x].pb(qry[i]),0);
	bit.init();//初始化 
	for(int i=1;i<m;i++)bit.add(i,1);
	for(int i=1;i<=n;i++){//离线操作 
		sort(v[i].begin(),v[i].end(),cmp);//按时间戳排序 
		for(int j=0;j<v[i].size();j++){
			int y=v[i][j].y,id=v[i][j].id;
			fd[id]=bit.fd(y);//查询并记录 
			bit.add(fd[id],-1);bit.add(m+j,1);//删除、插入 
		}
		for(int j=0;j<v[i].size();j++)bit.add(fd[v[i][j].id],1),bit.add(m+j,-1);//撤销影响 
	}
	bit.init();//重置 
	for(int i=1;i<=n;i++)bit.add(i,1);
	for(int i=1;i<=qu;i++){
		int x=qry[i].x,y=qry[i].y;
		if(y==m){
			int _fd=bit.fd(x);
			ll res=_fd<=n?1ll*_fd*m:bk_c[_fd-n-1];//从vector里查 
			printf("%lld\n",res);
			bk_c.pb(res);//压入vector 
			bit.add(_fd,-1);bit.add(n+bk_c.size(),1);//删除、插入 
		}
		else{
			ll res=fd[i]<m?1ll*(x-1)*m+fd[i]:bk_r[x][fd[i]-m];//从vector里查 
			printf("%lld\n",res);
			int _fd=bit.fd(x);
			bk_r[x].pb(_fd<=n?1ll*_fd*m:bk_c[_fd-n-1]);bk_c.pb(res);//压入vector 
			bit.add(_fd,-1);bit.add(n+bk_c.size(),1);//删除、插入  
		}
	}
	return 0;
}
```

---

## 作者：luckyqwq (赞：11)

# P3960 [NOIP 2017 提高组] 列队题解

## 大致思路：

### 方法1：
首先，问题分成两个操作。

1. 向左看齐（行内的单点查找和删除）。

2. 向前看齐（最后一列的单点查找和删除）。

我们把图分成两个部分：

1. $n\times(m-1)$ 的左侧矩形。

2. 最右侧的 $n$ 这一列。

考虑最后一列有 $n+q$ 个位置。第 $n+i$ 个位置表示在第 $i$ 次列队中出队的人的编号，放在最下面（可以凭空想一下）。我们不妨先进行向前看齐，找到并删除最后一列第 $x$ 大的位置。现在我们得到一个编号。代表这次看齐中最后一列的第 $x$ 个位置要被挪走了。

之后首先判断要移走的列是不是最后一列，如果是，则这次列队中出队的人的编号，就已经找到了（也就是最后一列找到的位置的编号），把 $id_{n+i}$ 置为 $id_{find}$ 就行。否则第 $x$ 行最后插入这个被去掉的元素 $id_{find}$。然后找第 $x$ 行的第 $y$ 大位置，并删除他。如果这个位置小于 $m$，则显然是原来的编号，直接计算就行。

如果等于 $m$，则这一行显然被操作过，否则要移走的列，就是最后一列了。而在移走的时候这一行最后的元素，已经被放在了末尾。于是这个时候，只需要找到之前添加的对应位置的数（在 $m-1$ 的分割外面的）。他的编号就是这个询问的答案，之后再把他放到最后一列末尾就行了！

```cpp
#include <bits/stdc++.h>
using namespace std;
using LL = long long;
const int N = 6e6 + 20;
int n, m, q, cnt, rt[N / 2];
struct node
{
    int s, ls, rs;
} t[N]; // 可持久化线段树节点
LL ID[N], pos;
vector<LL> G[N / 2]; // 每行末尾的新编号
#define mid (l + r >> 1)
#define ls t[p].ls
#define rs t[p].rs
#define lson ls, l, mid
#define rson rs, mid + 1, r
int F(int k, int &p, int l, int r)
{ // 去掉第k大（初始时每个区间都是全部点都在）
    if (!p)
        t[p = ++cnt].s = r - l + 1; // 新建一个点，长度是全部
    --t[p].s;                       // 每次减少1（第k大在这个区间里，把他移走等效于区间长度减少1）
    if (l == r)
        return l;                        // 找到点了（这也是第k大），返回下标
    int sl = ls ? t[ls].s : mid - l + 1; // 如果左子树存在，就取左子树里剩余的，否则剩余的视为全部长度
    if (sl >= k)
        return F(k, lson); // 线段树上二分，看第k大在哪颗子树，就移走他
    return F(k - sl, rson);
}
// ID_i: 最后一列第 i 个位置的编号
signed main()
{
    cin.tie(0)->sync_with_stdio(0);
    cin >> n >> m >> q;
    for (int i = 1; i <= n; ++i)
        ID[i] = 1ll * i * m;
    for (int i = 1; i <= q; ++i)
    {
        int x, y;
        cin >> x >> y;
        int kk = F(x, rt[0], 1, n + q); // 倒着考虑，先最后一列上下对齐。找到并去掉最后一列的第x大
        // 找行，一共最多 n+q 行，找当前图里的第 x 行（之前如果已经取了x或以下的，这时候找到的行就不一样了）
        if (y == m)
            ID[n + i] = ID[kk]; // 如果移走的元素是第m列，就不用左右对齐了。
        else
        {
            G[x].push_back(ID[kk]);      // 把填进去的元素放在 x 行末尾
            pos = F(y, rt[x], 1, m + q); // 考虑前面的操作。第 x 行左右对齐，去掉第 y 个
            if (pos < m)
                ID[n + i] = 1ll * (x - 1) * m + pos; // 如果位置在原图里，且不是最后一个，直接算出位置，变成最后一列最下面的一个位置
            // 如果恰好是最后一个位置m，肯定不是第一次操作这行。之前操作过一次G[x]已经有最后一个了
            else
                ID[n + i] = G[x][pos - m]; // 否则新的行最后一共元素就是第x行从前往后加入的
        }
        cout << ID[n + i] << '\n';
    }
}
```

### 方法2：

显然可以使用平衡树，我们需要维护两种操作：

操作 $1$：维护每一行。

操作 $2$：维护每一列。

因为我们不可能对于每个点暴力使用平衡树，不然你就需要看 $9 \times 10^{10}$。

然后我们考虑如何维护每一行，我们会发现 $(x, y)$ 是不是相对于行就是在第 $x$ 行中删了第 $y$ 个数，相当于我们对于每一行开一个平衡树。那么如何考虑列呢？首先我们会发现如果要调整列必定是在第 $m$ 列，相当于我们只需要维护第 $m$ 列，相当于只要给他开个平衡树，删除其中第 $x$ 个数，然后把前面原本的 $(x, y)$ 插入末尾。注意了使原本变化前的 $(x, y)$。那么题目变为有 $n + 1$ 棵平衡树，请你维护其中一颗平衡树删除第 $x$ 个数，或者维护第 $m$ 列的那颗平衡树在末尾插入一个数，这样就变成模板题了，但注意到一个细节有一些数字一直连接在一起，并没有分离，那么对于我们维护平衡树，每个节点可以存一个区间，当两个数分离时，对它们进行分裂即可。

---

## 作者：Getaway_Car (赞：7)

本文提供一种动态开点线段树做法。


---

> 这道题写的时候调了很久，原因是 ``while(q--)``，而处理询问时又用到了 $q$。

另外，sjx 在讲义中这样写：

> 为了解决空间问题，我们可以离线所有查询、删除和追加操作，然后 one by one 用线段树处理每个序列，每一个处理完后回滚到初始状态，再处理下一个。

为了解决空间问题，直接动态开点不就是了。

---

我们发现，每一行是相对独立的，所以考虑单独处理。对于每一行的前 $m - 1$ 个元素与最后一列，我们需要维护单点查询、单点删除与末尾插入。暴力的单点删除显然不可取，那么容易想到用线段树标记每个元素是否已被删除，查询时用线段树二分找到被查询元素的真实位置。由于有末尾插入的操作，所以我们可以对每棵线段树先多开 $q$ 个位置。对于新加入的元素，我们并不把它实际地插入到线段树中，而是放到这一行（或列）对应的一个 ``vector`` 里面。

具体地，对于一次操作，需要进行以下操作（假设 $y \ne m$）：

- 在第 $x$ 棵线段树上二分找到 $a_{x, y}$ 的真实位置，从而得到 $a_{x, y}$ 的值（并输出）；
- 将 $a_{x, y}$ 插入到第 $n + 1$ 棵线段树（用于维护最后一列）的末尾；
- 从第 $x$ 棵线段树中删除 $a_{x, y}$；
- 在第 $n + 1$ 棵线段树上二分找到 $a_{x, m}$ 的位置，从而得到 $a_{x, m}$ 的值；
- 将 $a_{x, m}$ 插入到第 $x$ 棵线段树的末尾；
- 从第 $n + 1$ 棵线段树中删除 $a_{x, m}$。

$y = m$ 时也类似，不再展开阐述。

时间复杂度 $O(q \log n)$。

关于线段树节点数量，估算下来理论上限是 $1.2 \times 10^7$，而实测下来 $4 \times 10^6$ 已经足够了。

---

在代码实现中，线段树中的 ``0`` 指未被删除，``1`` 指已被删除，这样处理的目的是在末尾插入元素时不需要访问线段树元素。

由于每个询问一定有解，所以线段树二分时没必要判断无解，整个过程也不需要考虑下标越界的问题，没什么细节，个人认为比较好写。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

int n, m, q, x, y, rt[300005], ps, val;
vector<int> num[300005];
struct Segtree {
	int tr[4000005], ls[4000005], rs[4000005], cnt;
	void update(int l, int r, int& p, int s) {
		if(!p) p = ++cnt;
		if(l == r) return tr[p] = 1, void();
		int mid = (l + r) >> 1;
		if(s <= mid) update(l, mid, ls[p], s);
		else update(mid + 1, r, rs[p], s);
		tr[p] = tr[ls[p]] + tr[rs[p]];
		return;
	}
	int query(int l, int r, int& p, int d) {
		if(!p) p = ++cnt;
		if(l == r) return l;
		int mid = (l + r) >> 1, tmp = (mid - l + 1) - tr[ls[p]];
		if(d > tmp) return query(mid + 1, r, rs[p], d - tmp);
		else return query(l, mid, ls[p], d);
	}
} tr;

signed main() {
	scanf("%lld %lld %lld", &n, &m, &q);
	for(int _ = 1; _ <= q; ++_) {
		scanf("%lld %lld", &x, &y);
		if(y < m) {
			ps = tr.query(1, m - 1 + q, rt[x], y); // step 1
			if(ps < m) val = (x - 1) * m + ps;
			else val = num[x][ps - m];
			printf("%lld\n", val);
			num[n + 1].push_back(val); // step 2
			tr.update(1, m - 1 + q, rt[x], ps); // step 3
			ps = tr.query(1, n + q, rt[n + 1], x); // step 4
			if(ps <= n) val = ps * m;
			else val = num[n + 1][ps - n - 1];
			num[x].push_back(val); // step 5
			tr.update(1, n + q, rt[n + 1], ps); // step 6
		}
		else {
			ps = tr.query(1, n + q, rt[n + 1], x); // step 1
			if(ps <= n) val = ps * m;
			else val = num[n + 1][ps - n - 1];
			printf("%lld\n", val);
			num[n + 1].push_back(val); // step 2
			tr.update(1, n + q, rt[n + 1], ps); // step 3
		}
	}
	return 0;
}
```

---

## 作者：Santiego (赞：7)


> 有一个$n×m$的方阵，进行$q$次操作，每次将第$(x,y)$个学生出列，输出该学生的编号，并将队列先向左对齐，再向前对齐，最后把该学生放在空位$(n,m$)。

神仙题。一直在想如何使一行队伍整体向左移动，向上移动，没想到可以用权值线段树搞。~~自己太蒻想不到这种操作啊。~~

详细讲一下权值线段树具体实现操作。

用权值线段树维护当前行学生出列的信息，区间维护出列学生个数，并在每行开一个`vector`记录后面加进来的学生编号。第$j$列学生出列，即在这颗权值线段树上将第$j$列学生原来的位置$+1$，表示此下标位置学生出列，然后将其放进当前行的`vector`。查询当前行第$j$列学生时，我们在权值线段树上查询，像平衡树那样，参考区间已经出列学生的信息来找到还未出列的第$j$个学生此时的线段树下标，这里如果下标小于列数那么说明就是下标就是原列编号，否则说明当前行第$j$个是后面加入的学生，于是我们从`vector`里面找就好了。

另外，不用担心出列`vector`里面的学生这种情况，因为出列学生时会在权值线段树上删除了这个学生，所以查询时不会查到这个已经被删除的学生。

再看这道题本身，我们维护$n+1$棵权值线段树，前$n$棵维护前$n$列前$m-1$列的信息，第$n+1$棵单独维护第$m$列。出列时，对于第$m$列的点，我们直接对第$n+1$棵线段树操作；对于不是第$m$列的，我们对$x$行的线段树操作，再对第$m$列的第$x$行（即第$n+1$棵线段树）操作即可。

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
#define ll long long
using namespace std;
inline int read(){
    char ch=getchar();int s=0;
    while(ch<'0'||ch>'9') ch=getchar();
    while(ch>='0'&&ch<='9') s=s*10+(ch^'0'), ch=getchar();
    return s;
}
int n,m,q,mxr;
#define MAXN 300003
#define MAXM MAXN*20
int tre[MAXM],sl[MAXM],sr[MAXM],cnt;
void change(int &x, int l, int r, int pos){
    if(x==0) x=++cnt;
    ++tre[x]; // 区间删除的学生个数+1
    if(l==r) return;
    int mid=(l+r)>>1;
    if(pos<=mid) change(sl[x], l, mid, pos);
    else change(sr[x], mid+1, r, pos);
}
int query(int x, int l, int r, int k){
    if(l==r) return l;
    int mid=(l+r)>>1;
    int lsum=mid-l+1-tre[sl[x]]; // 左儿子区间实际存在的学生个数
    if(lsum>=k) return query(sl[x], l, mid, k);
    else return query(sr[x], mid+1, r, k-lsum);
}
int rot[MAXN];
int rot_last_col;
vector<ll> ext[MAXN+1];
inline ll del_last_col(int x){
    int pos=query(rot_last_col, 1, mxr, x); // 找到实际第x个学生的下标
    change(rot_last_col, 1, mxr, pos);
    if(pos<=n) return (ll)pos*m;
    else return ext[n+1][pos-n-1];
}
inline ll del(int x, int y){
    int pos=query(rot[x], 1, mxr, y);
    change(rot[x], 1, mxr, pos);
    if(pos<=m-1) return (ll)(x-1)*m+pos;
    else return ext[x][pos-m];
}
int main(){
    n=read(),m=read(),q=read();
    mxr=max(n,m)+q;
    while(q--) {
        int x=read(),y=read();
        if(y==m){
            ll ans=del_last_col(x); // 删除最后一列的第x行
            ext[n+1].push_back(ans); // 将(x,y)放到位置(n,m)
            printf("%lld\n", ans);
        }else{
            ll ans=del(x, y); // 删除第x行第y列
            ll ans2=del_last_col(x); // 删除最后一列的第x行
            ext[x].push_back(ans2);  // 将第x行最后一列的学生加入到第x行中
            ext[n+1].push_back(ans);  // 将(x,y)放到位置(n,m)
            printf("%lld\n", ans);
        }
    }
    return 0;
}
```




---

## 作者：tth37 (赞：7)

一道非常有意思的题。

假设我们有一个神奇的数据结构，它可以动态地维护一个长度为 $n$ 的队列，其初始元素为 $1,2,...,n$ 。该队列可以支持两种操作，第一种为删除队列的第 $k$ 项元素，执行“向前看齐”操作，并在队列的末尾补充 $n+1$ （以此类推）。第二种为查询队列的第 $k$ 项元素的数值。

拥有这样一个数据结构，本题就简单多了；观察到“向前看齐”命令只对最后一列产生影响，我们可以在每一行维护一个动态队列，最后一列用另一个动态队列单独处理。

如果出列的同学位于最后一列，则只需对最后一列进行一次删除操作即可；如果出列的同学不在最后一列，则需要对出列同学所在的那一行与最后一列同时进行操作。实现细节不再赘述。

现在我们来考虑一下如何实现神奇的动态队列。在本题的情况中，假设每个动态队列最多有 $Q$ 次删除操作，那么动态队列的时空复杂度必须只与 $Q$ 相关，否则 $O(n^2)$ 的时空复杂度无法承受。似乎这里可以用平衡树实现，而我采用了较为好写的**动态开点权值线段树**来维护动态队列。

初始状态，权值线段树下标为 $1,2,...,n$ 的节点大小均为 $1$ 。对于删除操作，我们只需将对应的权值大小减一，并在权值 $n+1$ 的大小加一即可。对于查询操作，只需在权值线段树中查询第 $k$ 小元素即为对应数值。实现细节同样不再赘述。

记得开 long long 。代码如下：

```cpp
#include <bits/stdc++.h>
#define lson(u) (node[u].l)
#define rson(u) (node[u].r)
#define sum(u) (node[u].sum)
using namespace std;
typedef long long ll;

const int MAXN = 300005;

struct Node {
    int l, r, sum;
}node[MAXN * 42];
int cnt;
int root[MAXN], size[MAXN];
vector<ll> ins[MAXN];

int N, M, Q, T;

void modify(int& u, int l, int r, int p, int val) {
    if (u == 0) u = ++cnt;
    if (l == r) {
        sum(u) += val;
        return;
    }
    int mid = (l + r) >> 1;
    if (p <= mid) modify(lson(u), l, mid, p, val);
    else modify(rson(u), mid + 1, r, p, val);
    sum(u) = sum(lson(u)) + sum(rson(u));
}

int query(int u, int l, int r, int k) {
    if (l == r) return l;
    int mid = (l + r) >> 1;
    int lsum = sum(lson(u));
    if (l <= T) {
        lsum += (mid > T) ? T - l + 1 : mid - l + 1;
    }
    if (k <= lsum) return query(lson(u), l, mid, k);
    else return query(rson(u), mid + 1, r, k - lsum);
}

int main() {
    scanf("%d%d%d", &N, &M, &Q);
    int Case = Q;
    while (Case--) {
        int x, y;
        scanf("%d%d", &x, &y);
        ll ans = 0, tmp = 0;
        if (y == M) {
            T = N;
            ans = query(root[N + 1], 1, N + Q, x);
            modify(root[N + 1], 1, N + Q, ans, -1);
            modify(root[N + 1], 1, N + Q, N + (++size[N + 1]), 1);
            if (ans <= N) ans = ans * (ll)M;
            else ans = ins[N + 1][ans - N - 1];
            ins[N + 1].push_back(ans);
            printf("%lld\n", ans);
        } else {
            T = M - 1;
            ans = query(root[x], 1, M + Q, y);
            modify(root[x], 1, M + Q, ans, -1);
            modify(root[x], 1, M + Q, M - 1 + (++size[x]), 1);
            if (ans <= M - 1) ans += (ll)(x - 1) * M;
            else ans = ins[x][ans - M];
            T = N;
            tmp = query(root[N + 1], 1, N + Q, x);
            modify(root[N + 1], 1, N + Q, tmp, -1);
            modify(root[N + 1], 1, N + Q, N + (++size[N + 1]), 1);
            if (tmp <= N) tmp = tmp * (ll)M;
            else tmp = ins[N + 1][tmp - N - 1];
            ins[N + 1].push_back(ans);
            ins[x].push_back(tmp);
            printf("%lld\n", ans);
        }
    }
    return 0;
}
```



---

## 作者：clockwhite (赞：4)

# [Noip2017]列队

## 一.前言

​	咱高一是不是也要军训啊，害怕 qwq……[题目链接](https://www.luogu.com.cn/problem/P3960) 

## 二.思路

​	这篇题解使用的是平衡树（FHQ），树状数组不会写也……

​	首先通过简单的 模拟/手玩 可以大概的知道，对于位置 $(x,y)$，移动它会影响的只有 $(x,y+1)$ 到 $(x,m)$ 全部左移，以及 $(x+1,m)$ 到 $(n,m)$ 全部上移，最后在右下角插回去。

​	观察到 11~16 的测试点给的是全部 $x=1$，从局部入手获得灵感。在这种情况下，只需要维护第一行和最后一列就行。对于第一行，操作一共有两个：删除第 k 个数，在末尾插入一个数 u。具体的来说，若是 $(1,i)$ 离开，那么对于第一行会删掉第 i 个数，在最后插入 $(2,m)$,对于最后一列会删掉第 1 个数，在末尾插入 $(1,i)$ 

​	从中我们可以找到几个共同点：

- 都是删掉处在位置 k 的一个数
- 都是在末尾插入一个数

这里若是魔改一下，改成对于行只维护 1~m-1 就会方便很多。此时同时对第一行与最后一列进行维护就可以了。**不失一般性，将 1 改成 x ，对于每一行都维护就行。**

这里的维护我们需要用到平衡树（杀鸡用牛刀qwq），**接下来只是按我笨拙的想法讲一下原理，不是真正的算法**，有点套用替罪羊的建树思想，手中已有一个数列，把他拉成一个平衡树……见图![](https://cdn.luogu.com.cn/upload/image_hosting/uvwmu3y0.png)

此时（虽然不怎么像树），但是通过中序遍历是可以将整个数组都找到。在这个时候，给每个点一个随机值，使得在不违背遍历顺序的基础上以这个随机值进行旋转。见图。![](https://cdn.luogu.com.cn/upload/image_hosting/9yf2og1a.png)

（彩色的是随机值）这样中序遍历的顺序还是一样的（大概）但是很有效的将树给"压扁"了，使得每次的查询时间大幅缩减。对于每个点维护一个 $size$ 表示子树大小，就能快速找到第 k 个数了。

​	然后再说如何基于 FHQ 来操作，FHQ 的基操 merge 与 split 是重点，但是也不难（不会的先学了来）。merge的时候就按照随机值merge就好，给出代码。

```c++
int merge(int x,int y){//以 y 为根的子树要比 x 后访问
	if(!x||!y)return x+y;
	if(rad[x]<rad[y]){//按随机值,这里规则可以随便搞其实hhhh都可以A
		ch[x][1]=merge(ch[x][1],y);
		update(x);//维护size
		return x;
	}
	else {
		ch[y][0]=merge(x,ch[y][0]);
		update(y);
		return y;
	}
}
```

然后这题的split稍稍有点复杂……首先由数据规模可以得出两个结论：

- 每个点都开，空间开不起
- 由于操作数远小于点数，会有**一大片是连续的**

于是我们可以选择将连续的看作是一个点，记录这个点的长度（总共包括几个点），以及开头的值（就可以计算出所有值），当这个点中的其中一个位置需要操作时，**把这个点撕开成该位置前与后再插回去就行。**

​	于是 split 要分出三棵树：在 k 位置之前的，（包含）k 位置（可能是一个点，也可能是连续一大片），k位置之后。给出代码。

```c++
void split(int x,int k,int &a,int &b,int &c){
	if(!x)a=b=c=0;
	else{
		if(size[ch[x][0]]>=k)c=x,split(ch[x][0],k,a,b,ch[x][0]);
        //就在左子树里面，于是进左子树找，归还一个只留>k的部分的左子树
		else{
			k-=size[ch[x][0]];//直接排除左子树，减去消耗
			if(k<=len[x]){//正好就是该节点本身
				b=x;
				a=ch[x][0];
				c=ch[x][1];
				ch[x][0]=ch[x][1]=0;
			}
			else{//进右子树寻找，还一个只有<k 的右子树
				a=x;
				k-=len[x];//减去消耗
				split(ch[x][1],k,ch[x][1],b,c);
			}
		}
		update(x);
	}
}
```

剩下就是主体操作，要注意操作第二维为 m 的情况，特判一下。代码会详细解释

```c++
inline int add(long long x,int y){
	if(!y)return 0;
	start[++tot]=x;
	len[tot]=size[tot]=y;
	rad[tot]=rand();
	return tot;
}
inline void update(int x){
	size[x]=size[ch[x][0]]+size[ch[x][1]]+len[x];
}
int main(){
	srand(1415);
	n=read();m=read();q=read();
	for(int i=1;i<=n;++i){
		root[i]=add(1LL*(i-1)*m+1,m-1);//直接插入一行
		root[0]=merge(root[0],add(1LL*i*m,1));//维护一下最后一列
	}
	for(int i=1,x,y;i<=q;++i){
		x=read();y=read();
		if(y==m){//特判
			int a,b,c;
			split(root[0],x,a,b,c);//取出来
			printf("%lld\n",start[b]);
			root[0]=merge(merge(a,c),b);//塞在最后
		}
		else{
			int a,b,c;
			split(root[0],x,a,b,c);//在最后一列取出来
			root[0]=merge(a,c);//合并了
			root[x]=merge(root[x],b);//反手先塞进去
			split(root[x],y,a,b,c);//取出要输出的那个
			y-=size[a];//因为有可能取出来连续的一串，需要知道是这一串的第几个
			printf("%lld\n",start[b]+y-1);//输出了
			root[0]=merge(root[0],add(start[b]+y-1,1));//塞进最后一列末尾
			root[x]=
			merge(merge(a,merge(add(start[b],y-1),add(start[b]+y,len[b]-y))),c);
			//撕开成两半，塞进去
        }
	}
}
```



---

## 作者：潘德理2010 (赞：2)

我们发现，进行一次位置为 $(x,y)$ 的操作，只对第 $x$ 行的元素及最后一列的元素有影响。于是考虑对**每一行（不包括最后一列）**和**最后一列**分别维护。

对于最后一列，发现其要维护的只有删除一个数及从尾部插入一个数的操作。使用平衡树维护即可。

对于每一行（不包括最后一列）的元素，我们分为两类：

- 该元素本身就在这一行（即不是从最后一列过来的）。我们发现这部分的元素每一行最初只有 $m-1$ 个，不会再增多，且全部集中在这一行的最左侧。我们使用动态开点线段树，维护删去元素以及查询每一行从左到右第 $k$ 个未被删去的元素的操作。另外，我们还需要记录每一行的此类元素的个数，用于判断一个元素是否属于此类。

- 该元素是从最后一列过来的。发现这种元素总共不超过 $q$ 个，且全部集中在这一行（除最后一列）的最右侧。发现仍然只要维护删除一个数及从尾部插入一个数的操作，每行开一个平衡树维护即可。

以上所有操作的时间复杂度均为 $O(n\log n)$。

代码如下（平衡树采用 fhq-treap）：


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct nd{
	int ls,rs,sz,val,pr;
};
struct nd1{
	int ls,rs,sum;
};
struct balance_tree{//平衡树部分 
	vector<nd> f;
	int cnt,rt;
	int nw(int x){
		if(!cnt) f.push_back(nd());
		int u=++cnt;
		if(!rt) rt=u;
		f.push_back({0,0,1,x,rand()});
		return u;
	}
	void push_up(int s){
		f[s].sz=f[f[s].ls].sz+f[f[s].rs].sz+1;
	}
	pair<int,int> sp(int s,int k){
		if(!s) return {0,0};
		if(k<=f[f[s].ls].sz){
			int u,v;
			tie(u,v)=sp(f[s].ls,k);
			f[s].ls=v;
			push_up(s);
			return {u,s};
		}
		else{
			int u,v;
			tie(u,v)=sp(f[s].rs,k-f[f[s].ls].sz-1);
			f[s].rs=u;
			push_up(s);
			return {s,v};
		}
	}
	int mer(int x,int y){
		if(!x) return y;
		if(!y) return x;
		if(f[x].pr<f[y].pr){
			f[x].rs=mer(f[x].rs,y);
			push_up(x);
			return x;
		}
		else{
			f[y].ls=mer(x,f[y].ls);
			push_up(y);
			return y;
		}
	}
	void ins(int x){
		int u=nw(x);
		if(rt!=u) rt=mer(rt,u);
	}
	int get_num(int k){
		int u,v,v1,v2;
		tie(u,v)=sp(rt,k);
		tie(v1,v2)=sp(u,k-1);
		int res=f[v2].val;
		rt=mer(mer(v1,v2),v);
		return res;	
	}
	void del(int k){
		int u,v,v1,v2;
		tie(u,v)=sp(rt,k);
		tie(v1,v2)=sp(u,k-1);
		rt=mer(v1,v);
	}
}t,ts[300010];
struct segment_tree{//动态开点线段树部分 
	nd1 f[12000010];
	//每次操作调用一次 get_pos 函数和一次 add 函数
	//每次调用至多增加 log n 个节点（log n<=20），则两次至多增加 40 个节点
	// f 要至少开到 40*q
	int cnt;
	void ch(int &u,int le,int ri,int k){
		if(!u) u=++cnt;
		f[u].sum+=(ri-le+1)*k;
	}
	void push_up(int u){
		f[u].sum=f[f[u].ls].sum+f[f[u].rs].sum;
	}
	void add(int &u,int le,int ri,int x){
		if(!u) u=++cnt;
		if(le==ri){
			ch(u,le,ri,1);
			return ;
		}
		int mid=(le+ri)/2;
		if(x<=mid) add(f[u].ls,le,mid,x);
		if(x>mid) add(f[u].rs,mid+1,ri,x);
		push_up(u);
		return ;
	}
	int get_pos(int &u,int le,int ri,int k){
		if(!u) u=++cnt;
		if(le==ri){
			return le;
		}
		int mid=(le+ri)/2;
		if((mid-le+1)-f[f[u].ls].sum>=k) return get_pos(f[u].ls,le,mid,k);
		return get_pos(f[u].rs,mid+1,ri,k-((mid-le+1)-f[f[u].ls].sum));
	}
}r;
int rt[300010];
int n,m,q,s[300010];
// s[i] 记录每一行（除最后一列） 中从最后一列过来的元素数量 
int ret(int x,int y){ 
	return (x-1)*m+y;
}
signed main(){
	srand(time(0));
	scanf("%lld%lld%lld",&n,&m,&q);
	for(int i=1;i<=n;i++){
		int u=ret(i,m);
		t.ins(u);
	}
	while(q--){
		int x,y;
		scanf("%lld%lld",&x,&y);
		if(y==m){//在最后一列 
			int u=t.get_num(x);
			t.del(x);
			t.ins(u);
			printf("%lld\n",u);
		}
		else{
			if(y<=m-1-s[x]){//该行原有元素 
				int u=ret(x,0);
				int w=r.get_pos(rt[x],1,m-1,y);
				u+=w;
				printf("%lld\n",u);
				r.add(rt[x],1,m-1,w);
				int v=t.get_num(x);
				t.del(x);
				t.ins(u);
				ts[x].ins(v);
				s[x]++;
			}
			else{//从最后一列过来的元素 
				int pos=y-(m-1-s[x]);
				int u=ts[x].get_num(pos);
				ts[x].del(pos);
				printf("%lld\n",u);
				int v=t.get_num(x);
				t.del(x);
				ts[x].ins(v);
				t.ins(u);
			}
		}
	}
}
```

---

## 作者：KobeBeanBryantCox (赞：2)

# P3960 [NOIP 2017 提高组] 列队 题解

[题目传送门](https://www.luogu.com.cn/problem/P3960)。

**请读者注意：**~~本题解采用动态开点线段树，但是写得很丑，不仅代码长还很慢。~~

~~但是优化空间很大，然而我比较懒，所以闲来无事的读者可以帮忙优化一下。~~

**~~因此，仅参考思路即可，不推荐看代码！！~~**

update on 2025-03-07：修了 $\LaTeX$，现在应该能过审了。

Fun Fact：

注意到我 2023-08-14 的时候不知道怎么想的，交了一发[暴力](https://www.luogu.com.cn/record/120814304)。

但是我又十分看不爽之前没有过的题，然后它正好也是我最喜欢的数据结构题，我决心今天把它过了。

然而调了一个上午（真的整个上午都在调），竟是因为……

--------------------

## 题意

给一个 $n\times m$ 的方阵，每次把元素 $(x,y)$ 拿出来。

然后向左对齐，此时空位在 $(x,m)$。再向前对齐，此时空位在 $(n,m)$，最后把这个元素放回 $(n,m)$。

问每一次的元素的编号是多少。刚开始元素 $(i,j)$ 的编号是 $(i-1)\times m+j$。

-----------------

## 思路

首先注意到向前对齐只会影响第 $m$ 列。

这时我们有一个初步的思路：对每一行维护一个长度为 $m-1$ 的数据结构，对最后一列再维护一个长度为 $n$ 的数据结构。

在这里，我们规定第 $i$ 行的数据结构叫做 $T_i$，最后一列的数据结构叫做 $T_{n+1}$。

注意到如果按照从左往右，从上到下的顺序，原题等价于：

不考虑 $y=m$（特判即可）：

1. 找到 $T_x$ 中排名为 $y$ 的元素的 $id$（记为 $ida$）并删除；
2. 找到 $T_{n+1}$ 中排名为 $x$ 的元素的 $id$（记为 $idb$）并删除；
3. 在 $T_x$ 的末尾插入 $id$ 为 $idb$ 的元素；
4. 在 $T_{n+1}$ 的末尾插入 $id$ 为 $ida$ 的元素。

是不是很像平衡树？但是我们事先不能全部把元素加进平衡树中（时空都不允许），这样的话找排名就很不方便。

考虑动态开点权值线段树。

可以这样考虑：

线段树叶子结点上维护一个 $id$（非叶子不维护）。

所有元素维护 $sum$ 表示前缀删除的元素个数和。

找到排名为 $k$ 的元素，线段树二分即可（具体地，二分出位置 $p$ 满足 $p-sum_p=k$）；

删除元素，先进行上面的操作，找到这个元素在线段树节点的编号，$sum\gets1$，$id\gets-1$（$\gets$ 是赋值符号，下同。）

插入元素，同样的，先找到元素，$id\gets v$。

就做完了，时间复杂度 $O(q\log\max\{n,m\})$，常数极大。

--------------

## 一些细节

我们需要 $\texttt{pushup}$，由于是维护前缀和，$tr[x].sum\gets tr[rs(x)].sum$ 即可。

我们需要 $\texttt{modify}$，由于是单点加，维护前缀和，所以要把单点到 $N$ 的所有元素加，也就是区间修改。

我们需要 $\texttt{querysum}$，单点查询对应的 $sum$。

我们需要 $\texttt{putid}$，把线段树节点的第 $p$ 位置的 $id$ 赋为 $v$。

我们需要 $\texttt{findid}$，找到线段树节点的第 $p$ 位置的 $id$。

我们需要 $\texttt{kth}$，用于找到排名为 $k$ 的元素在线段树上的位置。由于我们不能二分到一个已经被删除的位置，我们还要维护区间删除个数和 $delsum$。

以上都是线段树的内容。

我们还需要一个 $\texttt{getid}$，找到方阵中 $(x,y)$ 的 $id$。

为了应对中间删除的元素，由于不好描述，$\texttt{getid}$ 伪代码如下（不考虑 $y=m$）：

```cpp
k=kth(rt[x],y);
id=findid(rt[x],k);
if(id==0)return (x-1)*m+y+querysum(rt[x],k); // 会有没找到的情况！！！此时对应地往后移。
else return id;
```

**还有！如果有多颗线段树，动态开点线段树的 $cnt$ 要先设为 $n$（本代码中是 $n+1$）！！！我就因为这一个错误调了一个上午！**（根据写法不同也会有区别。）

--------------

## AC 代码

```cpp
// 我怎么 2023 年还交了一发暴力啊
// 虽然但是我现在来写，也调了很久
// 警示后人：如果有多颗线段树，动态开点线段树的 cnt 要先设为 n（本代码中是 n+1）
// 警示后人：十年 oi 一场空，不开 ll 见祖宗
// 我删去了调试信息和 assert，要看调试信息的看我之前的提交记录
#include<bits/stdc++.h>
#define Code using
#define by namespace
#define wjb std
Code by wjb;
#define int long long
int in()
{
	int k=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')k=k*10+c-'0',c=getchar();
	return k*f;
}
void out(int x)
{
	if(x<0)putchar('-'),x=-x;
	if(x<10)putchar(x+'0');
	else out(x/10),putchar(x%10+'0');
}
const int N=3e5+10;
struct Seg
{
	struct node{int lc,rc,sum,lazy,delsum,id;}tr[N*80];
	#define lc tr[x].lc
	#define rc tr[x].rc
	void pushup(int x){tr[x].sum=tr[rc].sum,tr[x].delsum=tr[lc].delsum+tr[rc].delsum;}
	#define mid ((l+r)>>1)
	int cnt=0;
	void pushdown(int x,int l,int r)
	{
		if(!lc)lc=++cnt;
		if(!rc)rc=++cnt;
		if(!tr[x].lazy)return;
		tr[lc].lazy+=tr[x].lazy,tr[lc].sum+=tr[x].lazy;
		tr[rc].lazy+=tr[x].lazy,tr[rc].sum+=tr[x].lazy;
		tr[x].lazy=0;
	}
	void modify(int &x,const int ql,const int qr,const int v,int l=1,int r=(N<<1))
	{
		if(l>=ql&&r<=qr)return tr[x].lazy+=v,tr[x].sum+=v,void();
		pushdown(x,l,r);
		if(ql<=mid)modify(lc,ql,qr,v,l,mid);
		if(qr>mid)modify(rc,ql,qr,v,mid+1,r);
		pushup(x);
	}
	int querysum(int &x,const int p,int l=1,int r=(N<<1))
	{
		if(l==r)return tr[x].sum;
		pushdown(x,l,r);
		if(p<=mid)return querysum(lc,p,l,mid);
		else return querysum(rc,p,mid+1,r);
	}
	void putid(int &x,const int p,const int id,int l=1,int r=(N<<1))
	{
		if(!x)x=++cnt;
		if(l==r)
		{
			tr[x].id=id;
			if(id==-1)tr[x].delsum=1;
			return;
		}
		if(p<=mid)putid(lc,p,id,l,mid);
		else putid(rc,p,id,mid+1,r);
		pushup(x);
	}
	int findid(int x,const int p,int l=1,int r=(N<<1))
	{
		if(!x)return 0;
		if(l==r)return tr[x].id;
		if(p<=mid)return findid(lc,p,l,mid);
		else return findid(rc,p,mid+1,r);
	}
	int kth(int &x,const int k,int l=1,int r=(N<<1))
	{
		if(l==r)return l;
		pushdown(x,l,r);
		if(mid-tr[lc].sum>=k&&tr[lc].delsum<(mid-l+1))return kth(lc,k,l,mid);
		else return kth(rc,k,mid+1,r);
	}
	void insert(int &x,int p,const int id){p=kth(x,p);putid(x,p,id);}
	void erase(int &x,int p){p=kth(x,p);putid(x,p,-1),modify(x,p,N<<1,1);}
}T;int root[N];
int n,m;
int getid(int x,int y)
{
	if(y==m)
	{
		int k=T.kth(root[n+1],x);
		int id=T.findid(root[n+1],k);
		if(id==0)
		{
			int s=T.querysum(root[n+1],k);
			return (x+s)*m;
		}
		else return id;
	}
	int k=T.kth(root[x],y);
	int id=T.findid(root[x],k);
	if(id==0)
	{
		int s=T.querysum(root[x],k);
		return (x-1)*m+y+s;
	}
	else return id;
}
signed main()
{
	n=in(),m=in();int q=in();
	for(int i=1;i<=n+1;i++)root[i]=i;
	T.cnt=n+1;
	while(q--)
	{
		int x=in(),y=in();
		if(y==m)
		{
			int id=getid(x,y);T.erase(root[n+1],x);
			T.insert(root[n+1],n,id);
			out(id),putchar('\n');
			continue;
		}
		int ida=getid(x,y);T.erase(root[x],y);
		int idb=getid(x,m);T.erase(root[n+1],x);
		T.insert(root[x],m-1,idb),T.insert(root[n+1],n,ida);
		out(ida),putchar('\n');
	}
	return 0;
}
```

让你们看看我之前调试的时候的[代码](https://www.luogu.com.cn/record/206215023)。

-----------------

如有错误或者不清楚，欢迎评论。

---

## 作者：Eterna (赞：2)

以下认为 $n,m,q$ 同阶。

观察到 `向左看齐` 只影响第 $x$ 行的人，`向前看齐` 只影响第 $m$ 列的人。

显然各行之间互不干涉。数列上的平移可以用数据结构维护，考虑将矩阵拆成若干个序列维护。考虑如下方案：

> 每一行维护第 $1$ 个到第 $(m-1)$ 个元素。
>
> 最后一列单独维护。

则每一个这样的结构都是相似的，维护单点删除，末尾插入。平衡树常数大，可以用线段树做。实现如下：

>用 $f_i = 0/1$ 表示第 $i$ 个数是否**真的存在**，$l$ 表示 $f$ 的当前长度。
>
>原数列上的第 $k$ 项则一定满足 $\displaystyle k=\sum_{i=1}^b f_i$，其中 $b$ 为所求。
>
>维护 $f_i$ 的区间和，然后这是一个经典的线段树二分模版。
>
>删除即 $f_b \gets 0$，末尾插入为 $l \gets l+1,f_l \gets 1$。

然后 $n^2$ 存不下，处理出所有线段树要做的操作，离线逐行做一下就好了。

时间 $O(n \log n)$，空间 $O(n)$。

代码还没写。

---

## 作者：Mr_RedStone (赞：1)

## 思路

维护 $n$ 个长度为 $m-1$ 序列，第 $i$ 个序列表示第 $i$ 行前 $m-1$ 个数。再维护 $1$ 个序列，长度为 $n$，表示最后一列，称为 $0$ 号序列。

这样可以把 $(x_i,y_i)$ 出队变为：
1. $x_i$ 号序列中第 $y_i$ 个数删掉并放入 $0$ 号序列末尾。
2. $0$ 号序列第 $x_i$ 个数删掉并放入 $x_i$ 号序列末尾。

但是题目数据范围极大，$n,m,q \le 3 \times 10^5$，无法维护这 $n+1$ 个序列。

考虑将删除操作改为打标记。对于一个序列，维护一个标记序列，初始时每一位的标记都为 $1$，表示该位上的数未被删除。当某一位被删除时，则将该位上的标记变 $0$。插入操作直接在序列末尾插入即可。因此用**树状数组维护该标记序列的前缀和**的差分数组（树状数组单点查询区间修改）：

1. 删除下标 $k$ 时直接将 $k$ 到结尾减 $1$。
2. 查询第 $i$ 个**未被删除数字的下标**，使用二分，找到第一个满足前缀和值大于等于 $i$ 的位置。

序列 $0$ 长度为 $n$，其余 $n$ 个序列长度为 $m-1$，操作最多 $q$ 次，产生 $q$ 次插入，因此维护的树状数组范围应是 $mx=\max(n,m-1)+q$。

我们发现**这个操作结合出队转换为序列删除插入的操作**后，$0$ 号序列结尾插入的 $q$ 个数**就是答案**。

不难发现对于第 $i$ 行，假设对该行所有操作中最小的 $y_i$ 为 $y_i'$，则 $y_i'$ 之前的数均不受影响，因此可以直接用算编号的公式算出。所以可以开 $n+1$ 个 ```vector```，每个序列一个，每个 ```vector``` 不存该序列本来有的数，**只存 $q$ 次操作中新加入该序列的数。**

接下来只需要**预处理出每一次操作的序列中删除的数的下标**。将数据转离线，对于 $x_i$ 从小到大，通过树状数组维护序列 $x_i$ 删除情况，每次查询该序列中第 $y_i$ 个未被删除数字的下标 $pos_i$（此时并不需要知道该下标上的数具体是什么）。注意这里并不处理 $0$ 号序列的操作，即先忽略所有 $y_i=m$ 的操作。

最后按输入顺序枚举 $q$ 次操作，每次在 $0$ 号序列中找第 $x_i$ 个未被删除数的下标 $t$（对应要取出第 $x_i$ 个数并放入 $x_i$ 行末尾的操作）。若 $t \le n$ 直接算出本次取出的编号 $t \times m$，若 $t > n$ 则说明本次要取出的编号在 $0$ 号序列对应的 ```vector``` 中。将本次取出的编号记作 $tt$，接下来有两种情况：

1. $y_i=m$：本次输出答案为 $tt$。
   
2. $y_i \neq m$：将 $tt$ 插入序列 $x_i$ 对应的 ```vector``` 末尾。若 $pos_i \le m-1$ 则可以用公式算出本次的答案编号，否则说明本次答案编号在 $x_i$ 对应的 ```vector``` 中。

总结一下，这种思路只维护了：

1. 一个树状数组，用于记录每个序列的删除情况，**只有一个因为是复用的**。
2. $n+1$ 个 ```vector```，用于记录每一个序列新插入的编号。

**至于提到的序列，只是一个思想，并没有在代码中被实际维护出来，不然空间就爆了。**

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int NR=3e5+5;
int n,m,q;
int mx;//max(n,m)+q

//这一段进行了预处理
int x[NR],y[NR];
struct LCZ{
	int y,id;//y:每次操作了第几列，id:这是第id次操作
};
vector<LCZ> v[NR];//这个vector用于按x_i从小到大预处理
int pos[NR];// 预处理结果

vector<long long> s[NR];//记录每个序列新插入的编号

//下面这段是树状数组
int f[2*NR];
void add(int x,int k){
	while(x<=mx){
		f[x]+=k;
		x+=x&-x;
	}
}
int query(int x){
	int ret=0;
	while(x){
		ret+=f[x];
		x-=x&-x;
	}
	return ret;
}
//查询找到第一个前缀和值>=x的下标，即找到第x个没被删除的数
int find(int x){
	int l=1,r=mx,ans=0;
	while(l<=r){
		int lcz=(l+r)>>1;
		if(query(lcz)>=x){
			r=lcz-1;
			ans=lcz;
		}
		else{
			l=lcz+1;
		}
	}
	return ans;
}
int main(){
	scanf("%d %d %d",&n,&m,&q);
	mx=max(n,m)+q;
	for(int i=1;i<=mx;i++){//将树状数组初始化
		add(i,1);
	}
	for(int i=1;i<=q;i++){
		scanf("%d %d",&x[i],&y[i]);
		if(y[i]!=m) v[x[i]].push_back({y[i],i});//先忽略最后一列的操作
	}
	for(int i=1;i<=n;i++){
		for(auto e:v[i]){//预处理出每次操作的下标
			pos[e.id]=find(e.y);
			add(pos[e.id],-1);
		}
		for(auto e:v[i]){//树状数组复用
			add(pos[e.id],1);//还原
		}
	}
	for(int i=1;i<=q;i++){//注意这里的find都是在0序列中找
		int t=find(x[i]);
		add(t,-1);
		long long tt,ans;
		if(t<=n) tt=1ll*t*m;//直接算出下标
		else tt=s[0][t-n-1];
		if(y[i]==m) ans=tt;
		else{
			if(pos[i]<m) ans=1ll*(x[i]-1)*m+pos[i];//直接算
			else ans=s[x[i]][pos[i]-m];
			s[x[i]].push_back(tt);
		}
		s[0].push_back(ans);
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：iChen (赞：1)

思路原创 @[huangjieming0703](luogu://user/1098988)

%%% hjm dalao 线段树 + vector 做法钛强了！！！

## 思路分析
先来分析 $n = 1$ 的情况，也就是题目中的二维平面是一个数列。

当我们把位置为第 $x$ 个数字删掉并放在队尾时，情况如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/wvl56het.png)

这时如果朴素模拟，那就需要把 $x + 1$ 到 $m$ 的每个数都往前面移动一位，再把 $x$ 上的元素放到 $m$ 上。  
显然，复杂度炸了。

为了保护复杂度~~和洛谷评测机~~，我们肯定不能把 $x + 1$ 到 $m$ 的元素都暴力往前移。而对于多出来的放在队尾的第 $x$ 个元素，那就需要额外处理。这里考虑使用一个动态数组来存储被移出来的元素。  
但 $x + 1$ 到 $m$ 的元素如何用其他方法处理？当前面的第 $x$ 个元素被删除之后，把它看作一个空位，那么在这个序列中，每个元素的当前位置就是它当前在这个序列中的排序（除去空位），而它的编号就是它当前的下标，也就是它的原位。

那这个问题也就转换成了一个区间查询第 $k$ 小，直接用线段树解决。  
每次删除第 $x$ 个元素，先查询序列中除去空位的第 $x$ 个位置，输出答案，再把这个位置更新为空位。  
对于把它插入序列尾部的操作，用 vector 动态数组处理即可。  
最多进行 $3\times10^5$ 次操作，时间复杂度和空间复杂度都没锅。

再来看二维平面中的情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/7qlgp4h5.png)

发现按照题面要求操作，发生变化的行列只有第 $x$ 行和第 $m$ 列。  
相当于把第 $x$ 行第 $y$ 个元素删除，在末尾补上 $(x + 1,m)$；把第 $m$ 列第 $x$ 个元素删除，并在末尾补上 $(x,y)$。

那么，只需要把原二维空间拆解成 $n + 1$ 个序列：

![](https://cdn.luogu.com.cn/upload/image_hosting/lwt2hlhh.png)

每次按如上说明，进行两次一维序列上的操作即可。

## Code

```cpp
#include <cctype>
#include <cstdio>
#include <vector>
#define int long long

using namespace std;

int num; char c;
inline int read () {
	num = 0, c = getchar();
	while (!isdigit(c)) c = getchar();
	while (isdigit(c)) num = (num << 3) + (num << 1) + (c ^ 48), c = getchar();
	return num;
}

const int N = 3e5 + 5, hjm = N * 2;
int n, m, q;
int rt[N];
struct huangjieming0703 {
	int lc, rc, sum;
} t[N * 20]; int idx;
vector <int> v[N];

void update (int &p, int l, int r, int x) {
	if (!p) p = ++ idx;
	t[p].sum ++;
	if (l == r) return;
	int mid = l + r >> 1;
	if (x <= mid) update(t[p].lc, l, mid, x);
	else update(t[p].rc, mid + 1, r, x);
}
int query (int p, int l, int r, int k) {
	if (!p) return l + k - 1;
	if (l == r) return l;
	int mid = l + r >> 1, val = mid - l + 1 - t[t[p].lc].sum;
	if (val >= k) return query(t[p].lc, l, mid, k);
	else return query(t[p].rc, mid + 1, r, k - val);
}
inline int iChen (int x, int y, int len) {
	int val = query(rt[x], 1, hjm, y);
	update(rt[x], 1, hjm, val);
	if (val > len) {
		return v[x][val - len - 1];
	} else {
		if (x == n + 1) return val * m;
		else return val + (x - 1) * m;
	}
}

signed main () {
	n = read(), m = read(), q = read();
	int x, y;
	while (q --) {
		x = read(), y = read();
		if (y == m) {
			int ans = iChen(n + 1, x, n);
			v[n + 1].push_back(ans);
			printf("%lld\n", ans);
		} else {
			int ans1 = iChen(x, y, m - 1), ans2 = iChen(n + 1, x, n);
			v[x].push_back(ans2), v[n + 1].push_back(ans1);
			printf("%lld\n", ans1);
		}
	}
	return 0;
} 
```

---

## 作者：huangzixi071018 (赞：1)

# 题目大意：
$n$ 行 $m$ 列的方阵中会有人离队，剩下的人会先向左，再向右补齐，离开的人会到队伍最后一排最后一个。

# 思路：
维护这个方阵的行和列。先预处理出第 $i$ 个询问要查询的数在这一行的位置（有可能不在这一行，则大于 $m$，所以需要最后一列的补上），用数状数组预处理，原来的数没离开则为 $1$，否则为 $0$,找前缀和为 $y$ 的数。然后处理行，如果这一行查询的值是原本的值，那么直接输出，否则是前面处理过的数，用一个 vector 来处理每一行的前 $m-1$ 个数和第 $n$ 列的数，最后还要把第 $n$ 列的数向左移，来维护整个方阵。

# 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
/*
id[i]表示第i个询问对应的在第a[i].x行的原来的列数（如果存在的话）
s[i]表示现在在第i行的前m-1个数而原来不在的数
s[0]表示现在在第n列的数
*/
const int N=3e5+5;
vector<pair<int,int>>e[N];
vector<ll>s[N];
struct node{
	int x,y;
}a[N];
int tree[2*N],mx,id[N];
int lowbit(int x){
	return x&(-x);
}
void add(int x,int y){
	for(int i=x;i<=mx;i+=lowbit(i)){
		tree[i]+=y;
	}
}
int query(int x){
	int res=0;
	for(int i=x;i>=1;i-=lowbit(i)){
		res+=tree[i];
	}
	return res;
}
int js(int x){
	int l=0,r=mx,res=mx+1;
	while(l<=r){
		int mid=(l+r)/2;
		if(query(mid)>=x){
			res=mid;
			r=mid-1;
		}else{
			l=mid+1;
		}
	}
	return res;
}
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	int n,m,q;
	cin>>n>>m>>q;
	mx=max(n,m)+q;
	for(int i=1;i<=q;i++){
		cin>>a[i].x>>a[i].y;
		if(a[i].y!=m){
			e[a[i].x].push_back(make_pair(a[i].y,i));
		}
	}
	for(int i=1;i<=mx;i++){
		add(i,1);
	}
	for(int i=1;i<=n;i++){
		for(int j=0;j<e[i].size();j++){
			int y=e[i][j].first,x=e[i][j].second;
			id[x]=js(y);
			add(id[x],-1);
		}
		for(int j=0;j<e[i].size();j++){
			int x=e[i][j].second;
			add(id[x],1);
		}
	}
	for(int i=1;i<=q;i++){
		int h=js(a[i].x);
		ll la,ans;//la第a[i].x行最后一位
		add(h,-1);
		if(h<=n){
			la=1ll*m*h;
		}else{
			la=s[0][h-n-1];
		}
		if(a[i].y==m){
			ans=la;
		}else{
			s[a[i].x].push_back(la);//把最后一位向左移一位
			if(id[i]<m){
				ans=1ll*(a[i].x-1)*m+id[i];
			}else{
				ans=s[a[i].x][id[i]-m];
			}
		}
		s[0].push_back(ans);
		cout<<ans<<"\n";
	}
	return 0;
}
```

---

## 作者：Justin0779 (赞：1)

前言：Splay 大法好！

# Solution

对于此题，明显首先想到是一个维护二维坐标下权值的数据结构题，维护此类的结构貌似根本数不过来：K-D Tree，线段树，树状树组，平衡树……

~~那么本题就到此为止，只需要维护下那一堆点就行了~~

慢着！

我们是不是忘了观察数据范围？观察行列个数 $n, m \le 3\times 10^5$，按刚刚那说法，也就是我们要维护 $9\times 10^{10}$ 个点咯。

开玩笑！空间肯定会爆，于是尝试转换思路。

我们再次想想我们要做什么：

> 查询某一行点的权值，将此点加入最后一列并删除此行该点，将在最后一列且排名为该行数值的点去除并加入该行末尾。

这样，我们真的需要维护那 $9\times 10^{10}$ 个点吗？

事实上是不需要的，同样的，我们把区间看成点并多维护一下左端点和右端点以及左端点的数值。这样，对于在这个区间中的点，我们只需要知道它距左端点的距离，便可以知道它的权值了。

那么我们尝试维护 $3\times 10^5+1$ 个 Splay（事实上别的平衡树也行，但我只会写 Splay），包含各行维护一堆区间，以及最后一列维护所有行的最后一个点，那么只需要进行 Splay 中的查询、加入、删除即可通过本题。对于查询区间中的点，将其拆成左、中、右三个区间（中间的就是一个点），将中间那个提出然后连上左右即可。

时间复杂度 $O(q\log n)$，空间复杂度 $O(n\log m + \log n)$，由于拆区间最多会使维护的一个点变成三个点也就是每次操作最多会使维护点的数量，所以维护的点数不超过 $9\times 10^5$，可以通过本题。

## 代码

注意初始化时每一行都只有一个点（大区间），最后一列有所有行的最后一个点，不断查询、拆点、加入、删除即可。

```cpp

#include <bits/stdc++.h>
using namespace std;
using ll = long long;
constexpr int N = 3e6 + 514;

namespace Otakus {
    int n, m, q;
    int ch[N][2], fa[N], sz[N], len[N], tot;
    ll val[N];
    
    struct Splay
    {
        int rt;

        bool get(int x) { return x == ch[fa[x]][1]; }
        void pushup(int x) { sz[x] = sz[ch[x][0]] + sz[ch[x][1]] + len[x]; }
        void clear(int x) { val[x] = sz[x] = len[x] = fa[x] = ch[x][0] = ch[x][1] = 0; }

        int newnode(ll _v, int _len) {
            ++tot;
            fa[tot] = ch[tot][0] = ch[tot][1] = 0;
            val[tot] = _v;
            sz[tot] = len[tot] = _len;
            pushup(tot);
            return tot;
        }

        void init(ll _v, int _len) {
            rt = newnode(_v, _len);
        }

        void rorate(int x) {
            int y = fa[x], z = fa[y], chk = get(x);
            ch[y][chk] = ch[x][chk ^ 1];
            if (ch[x][chk ^ 1]) fa[ch[x][chk ^ 1]] = y;
            ch[x][chk ^ 1] = y;
            fa[y] = x;
            fa[x] = z;
            if (z) ch[z][y == ch[z][1]] = x;
            pushup(y);
            pushup(x);
        }

        void splay(int x, int goal = 0) {
            if (goal == 0) rt = x;
            while (fa[x] != goal) {
                int f = fa[x], g = fa[fa[x]];
                if (g != goal) {
                    if (get(f) == get(x))
                        rorate(f);
                    else 
                        rorate(x);
                }
                rorate(x);
            }
        }

        ll kth(int k) {
            int cur = rt;
            while (1) {
                if (ch[cur][0] && sz[ch[cur][0]] >= k)
                    cur = ch[cur][0];
                else {
                    k -= sz[ch[cur][0]];
                    if (k <= len[cur]) {
                        splay(cur);
                        return val[cur] + k - 1;
                    }
                    else 
                        k -= len[cur];
                    cur = ch[cur][1];
                }
            }
        }

        int pre() {
            int cur = ch[rt][0];
            if (!cur) return cur;
            while (ch[cur][1]) cur = ch[cur][1];
            splay(cur);
            return cur;
        }

        ll del(int k) {
            ll res = kth(k);
            if (len[rt] == 1) {
                if (!ch[rt][0] && !ch[rt][1]) {
                    clear(rt);
                    rt = 0;
                }
                else if (!ch[rt][0]) {
                    int cur = rt;
                    rt = ch[rt][1];
                    fa[rt] = 0;
                    clear(cur);
                }
                else if (!ch[rt][1]) {
                    int cur = rt;
                    rt = ch[rt][0];
                    fa[rt] = 0;
                    clear(cur);
                }
                else {
                    int cur = rt;
                    int x = pre();
                    fa[ch[cur][1]] = x;
                    ch[x][1] = ch[cur][1];
                    clear(cur);
                    pushup(rt);
                }
                return res;
            }

            k -= sz[ch[rt][0]];
            if (k == 1) {
                len[rt]--;
                val[rt]++;
                pushup(rt);
            }
            else if (k == len[rt]) {
                len[rt]--;
                pushup(rt);
            }
            else {
                int cur = newnode(res + 1, len[rt] - k);
                ch[cur][1] = ch[rt][1];
                fa[ch[rt][1]] = cur;
                len[rt] = k - 1;
                ch[rt][1] = cur;
                fa[cur] = rt;
                pushup(cur);
                pushup(rt);
            }
            return res;
        }

        void ins(ll _v) {
            if (!rt) {
                rt = ++tot;
                val[rt] = _v;
                len[rt] = 1;
                pushup(rt);
                return ;
            }

            int cur = rt;
            while (ch[cur][1]) cur = ch[cur][1];
            ch[cur][1] = ++tot;
            val[tot] = _v;
            len[tot] = 1;
            fa[tot] = cur;
            pushup(tot);
            pushup(cur);
            splay(tot);
        }
    } S[300005];

    void init() {
        cin >> n >> m >> q;
        for (int i = 1; i <= n; i++) {
            S[i].init((i - 1) * (ll)m + 1, m - 1);
            S[0].ins(i * (ll)m);
        }

        while (q--) {
            int x, y;
            cin >> x >> y;

            if (y == m) {
                ll ans = S[0].del(x);
                cout << ans << '\n';
                S[0].ins(ans);
            }
            else {
                ll ans = S[x].del(y);
                cout << ans << '\n';
                S[x].ins(S[0].del(x));
                S[0].ins(ans);
            }
        }
    }
}

int main() {

    //freopen("atten.in", "r", stdin);

    Otakus::init();
    return 0;

}

```

---

## 作者：Push_Y (赞：1)

## 思路

“向左看齐”和“向前看齐”这两条指令，相当于在序列中删除一个元素并维护行、列中的相对顺序。

由于此题是教练给出的平衡树习题，想到用平衡树来维护所谓的序列。

对每一行开一棵平衡树，删除 $(x,y)$ 相当于在第 $x$ 行的平衡树中删除第 $y$ 个元素。在删除之后，我们发现这一行已经“向左看齐”了。

那么怎么做到“向前看齐”呢？在“向左看齐”之后，缺人的位置一定在最后一列，也就是说，只有最后一列才会因“向前看齐”而改变。想到对最后一列另外开一棵平衡树。对于删除 $(x,y)$ 操作，在最后一列的这棵平衡树上删除第 $x$ 个 元素，再把之前第 $x$ 行删除的第 $y$ 个元素加到这棵平衡树的末端。

## 实现

这里用 Splay 实现

对于每 $i$ 行，建一棵平衡树标号为 $i$

对于第 $m$ 列，建一棵平衡树标号为 $0$

对于每一次操作：

1. 删除第 $0$ 棵平衡树中第$i$个元素
2. 删除第 $i$ 棵平衡树中第$j$个元素
3. 在第 $0$ 棵平衡树末端插入在 2. 中删除的元素

这样做的原因：

1. 在第 $0$ 棵平衡树中删除元素，实现了“向前看齐”
2. 在第 $i$ 棵平衡树中删除元素，实现了“向左看齐”
3. 在第 $0$ 棵平衡树末插入元素，实现了“学生归队”

另外，**如果对于每一个元素我们都建立了一个结点的话，会有大量多余的空间开销**。因为有很多连在一起的元素自始至终都没有分开，我们将区间存在一个结点中，当用到这个区间中的一个结点时再考虑对区间拆分为两个结点。

## CODE

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
inline int gin(){
    int s=0,f=1;
    char c=getchar();
    while(c<'0' || c>'9'){
        if(c=='-') f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        s=(s<<3)+(s<<1)+(c^48);
        c=getchar();
    }
    return s*f;
}

const int N=3e6+5;
int n,m,q,a[N],tot;
int sz[N],ch[N][2],val[N][2],fa[N];

struct Splay{

	int rt;

    inline void push(int x){
        sz[x]=sz[ch[x][0]]+sz[ch[x][1]]+val[x][1]-val[x][0]+1;
    }

	inline bool wrt(int x){return x==ch[fa[x]][1];}
	inline void rotate(int x){
	    int p=fa[x],g=fa[p],k=wrt(x),b=ch[x][k^1];
	    ch[p][k]=b,fa[b]=p;
	    ch[g][wrt(p)]=x,fa[x]=g;
	    ch[x][k^1]=p,fa[p]=x;
	    push(p),push(x);
	}
	
	inline void splay(int x,int tar=0){
	    while(fa[x]!=tar){
	        if(fa[fa[x]]!=tar)
	            wrt(x)==wrt(fa[x])?rotate(fa[x]):rotate(x);
	        rotate(x);
	    }
	    if(!tar) rt=x;
	}

    inline int kth(int k){
        int x=rt;
        while(1){
            if(ch[x][0] && k<=sz[ch[x][0]]) x=ch[x][0];
            else if(ch[x][1] && k>sz[x]-sz[ch[x][1]]) k-=sz[x]-sz[ch[x][1]],x=ch[x][1];
            else {
                k-=sz[ch[x][0]];
                if(k!=1){
                    fa[ch[++tot][0]=ch[x][0]]=tot,fa[ch[x][0]=tot]=x;
                    val[tot][0]=val[x][0],val[tot][1]=val[x][0]+k-2,val[x][0]=val[tot][1]+1;
                    push(tot);
                    k=1;
                }
                if(k!=val[x][1]-val[x][0]+1){
                    fa[ch[++tot][1]=ch[x][1]]=tot,fa[ch[x][1]=tot]=x;
                    val[tot][1]=val[x][1],val[tot][0]=val[x][0]+k,val[x][1]=val[tot][0]-1;
                    push(tot);
                }
                return x;
            }
        }
    }

    inline int newNode(int l,int r){
        int x=++tot;
        ch[x][0]=ch[x][1]=fa[x]=0;
        val[x][0]=l,val[x][1]=r;
        sz[x]=r-l+1;
        return x;
    }

    inline int build(int l,int r){
        if(l>r) return 0;
        int mid=l+r>>1,x=newNode(a[mid],a[mid]);
        if(l==r) return x;
        if(ch[x][0]=build(l,mid-1)) fa[ch[x][0]]=x;
		if(ch[x][1]=build(mid+1,r)) fa[ch[x][1]]=x;
        push(x);
        return x;
    }

    inline void join(int u,int v){
        fa[u]=0,fa[v]=0;
        int w=u;
        while(ch[w][1]) w=ch[w][1];
        splay(w);
        ch[w][1]=v,fa[v]=w;
        push(w);
    }

    inline int pop(int k){
        int x=kth(k);
        splay(x);
        if(!ch[x][0] || !ch[x][1])
            fa[rt=ch[x][0]|ch[x][1]]=0;
        else join(ch[x][0],ch[x][1]);
        return val[x][0];
    }

    inline void push_back(int v){
        int x=newNode(v,v);
        if(!rt) rt=x;
        else {
            int w=rt;
            while(ch[w][1]) w=ch[w][1];
            splay(w);
            ch[w][1]=x,fa[x]=w;
            push(w);
        }
    }

}s[N];

/*
对于每i行，建一棵平衡树标号为i
对于第m列，建一棵平衡树标号为0

对于每一次操作：
1. 删除第0棵平衡树中第i个元素
2. 删除第i棵平衡树中第j个元素
3. 在第0棵平衡树末端插入在2.中删除的元素

这样做的原因：
1. 在第0棵平衡树中删除元素，实现了“向前看齐”
2. 在第i棵平衡树中删除元素，实现了“向左看齐”
3. 在第0棵平衡树末插入元素，实现了“学生归队”
*/

signed main(){
//	freopen("1.in","r",stdin);
//	freopen("my.out","w",stdout);
    n=gin(),m=gin(),q=gin();
    for(int i=1;i<=n;i++){
        s[i].rt=s[i].newNode((i-1)*m+1,i*m-1);
        a[i]=i*m;
    }
	s[0].rt=s[0].build(1,n);
    while(q--){
        int x=gin(),y=gin(),z;
	   	s[x].push_back(s[0].pop(x));
	    printf("%lld\n",z=s[x].pop(y));
        s[0].push_back(z);
    }
    return 0;
}

```


---

## 作者：mengnn (赞：0)

## 题目大意

给一个 $n$ 行 $m$ 列的方阵，并予以行列上的维护，每次变动会对指定行列坐标进行离队和补位两种变化，并输出离队人员编号。

## 思路

不难发现，题目数据 $1\le n,m,q\le 3\times 10^5$ 非常大，很明显不能直接存储，考虑到动态开点。

因为出队时变动的总是影响到最后一行，所以我们可以用动态开点线段树来维护最后一行的数。

其次，我们可以观察到每次出队人员的变动，本质上是行列上人数的变动，根据查询的人数情况，即可判断出队人的编号。

## 分类讨论

当 $y = m$ 时，我们不需要执行向左看齐的指示，只需维护第 $m$ 列的变化即可。

而当 $y \ne m$ 时，我们通过记录修改次数，对新节点给予编号并更新，就完成了维护。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;//要开long long我这里直接define了 
const int N=6e5+5,M=2e7+5;
//写线段树数组要开大，防止RE 
struct STree{
	int l,r;
	int sz,id;//子树大小和节点编号 
}t[M];
int n,m,q,rt[N],op[N],cnt;
//分别指行数，列数，询问次数，各树深度，修改次数，编号的增量 
int zzz;
inline void newnode(int &p,int l,int r,bool op){
	p=++cnt;
	t[p].sz=!op?max(0LL,min(n,r)-l+1):max(0LL,min(m-1,r)-l+1);
	t[p].id=!op?(l*m):((zzz-1)*m+l);
}//建一个新节点并更新其子树和编号 
inline int find(int &p,int l,int r,int pos,bool op){
	if (!p) newnode(p,l,r,op);
	--t[p].sz;
	if (l==r) return t[p].id;
	int mid=l+r>>1;
	if (!t[p].l) newnode(t[p].l,l,mid,op);
	if (pos<=t[t[p].l].sz) return find(t[p].l,l,mid,pos,op);
	else return find(t[p].r,mid+1,r,pos-t[t[p].l].sz,op);
}//查找编号 
inline void update(int &p,int l,int r,int pos,int v,bool op){
	if (!p) newnode(p,l,r,op);
	++t[p].sz;
	if (l==r){
		t[p].id=v;
		return ;
	}
	int mid=l+r>>1;
	if (pos<=mid) update(t[p].l,l,mid,pos,v,op);
	else update(t[p].r,mid+1,r,pos,v,op);
}//更新编号 
signed main(){
	cin>>n>>m>>q;
	int len=max(n,m)+q;//因为动态开点，所以要留够空间 
	for (int i=1;i<=q;i++){
		int x,y;
		cin>>x>>y;
		if (y==m){
			int ans=find(rt[n+1],1,len,x,0);
			printf("%lld\n",ans);
			++op[n+1];//更新操作次数 
			update(rt[n+1],1,len,n+op[n+1],ans,0);
		}else{
			zzz=x;
			int ans=find(rt[x],1,len,y,1);
			int ans2=find(rt[n+1],1,len,x,0);
			printf("%lld\n",ans);
			++op[x];++op[n+1];
			update(rt[x],1,len,m+op[x]-1,ans2,1);
			update(rt[n+1],1,len,n+op[n+1],ans,0);
		}
	}
	return 0;
}
```

---

## 作者：我梦见一片焦土 (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/P3960)

---

# 思路：

很好的一道动态开点线段树题。

考虑一下，每次取走一个人会发生什么：

![](https://cdn.luogu.com.cn/upload/image_hosting/gvuqinn8.png)

$17$ 所在的行，右边的部分全都向左移动一个，第 $m$ 列，从 $17$ 所在的列开始全部向上一个。

发现每一行之间都是独立的（除了最后一列）。

这样我们就可以把这个矩阵分割成如下的几块：

![](https://cdn.luogu.com.cn/upload/image_hosting/noasldzx.png)

这些部分互相是独立的，可以分别用数据结构来维护。

我们再考虑一下这个数据结构内需要包含什么东西。

操作 $1$：查询 $(x,y)$ 的元素。

操作 $2$：向末尾插入元素。

因为我们肯定不能把所有元素都插入到这个数据结构内，所以我们考虑动态开点线段树。

不同于一般的动态开点，这里选择在查询/插入的过程中动态开点以取代低效的建树过程。

具体而言，在查询/插入的时候，直接动态开点，如果它尚无儿子就新建儿子节点。

注意判断，什么时候节点的 $sum$ 有值。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=2e6+10;
const int INF=0x3f3f3f3f;
int n,m,q,x,y,cnt;
struct node{
    int son[2],fa,sub,l,r;
}tr[N];
struct Splay{
    int root;
    void pushup(int x){
        if(!x){
            return;
        }
        tr[x].sub=tr[x].r-tr[x].l+1;
        if(tr[x].son[0]){
            tr[x].sub+=tr[tr[x].son[0]].sub;
        }
        if(tr[x].son[1]){
            tr[x].sub+=tr[tr[x].son[1]].sub;
        }
    }
    bool check(int x){
        return tr[tr[x].fa].son[1]==x;
    }
    void rorate(int x){
        int y=tr[x].fa,z=tr[y].fa;
        bool w=check(x);
        tr[y].son[w]=tr[x].son[w^1];
        tr[tr[y].son[w]].fa=y;
        tr[y].fa=x;
        tr[x].son[w^1]=y;
        tr[x].fa=z;
        if(z){
            tr[z].son[tr[z].son[1]==y]=x;
        }
        pushup(y);
        pushup(x);
    }
    void splay(int x,int goal){
        for(int f;(f=tr[x].fa)!=goal;rorate(x)){
            if(tr[f].fa!=goal){
                rorate(check(x)==check(f)?f:x);
            }
        }
        if(!goal){
            root=x;
        }
    }
    int new_node(int l,int r){
        cnt++;
        tr[cnt].sub=(tr[cnt].r=r)-(tr[cnt].l=l)+1;
        return cnt;
    }
    void init(int l,int r){
        root=new_node(l,r);
    }
    int next_node(int x){
        splay(x,0);
        int pos=tr[x].son[1];
        while(tr[pos].son[0]){
            pos=tr[pos].son[0];
        }
        return pos;
    }
    int last_node(int x){
        splay(x,0);
        int pos=tr[x].son[0];
        while(tr[pos].son[1]){
            pos=tr[pos].son[1];
        }
        return pos;
    }
    int split(int x,int k){ 
        if(k>=tr[x].r||k<tr[x].l){
            return x;
        }
        int y=new_node(k+1,tr[x].r);
        tr[x].r=k;
        if(tr[x].son[1]){
            int pos=tr[x].son[1];
            while(tr[pos].son[0]){
                pos=tr[pos].son[0];
            }
            tr[tr[pos].son[0]=y].fa=pos;
            while(pos!=x){
                pushup(pos);
                pos=tr[pos].fa;
            }
        }else{
            tr[tr[x].son[1]=y].fa=x;
        }
        splay(y,0);
        return y;
    }
    pair<int,int> find(int x){
        int pos=root;
        while(true){
            if(x<=tr[tr[pos].son[0]].sub){
                pos=tr[pos].son[0];
            }else{
                x-=tr[tr[pos].son[0]].sub;
                if(x<=tr[pos].r-tr[pos].l+1){
                    return make_pair(pos,tr[pos].l+x-1);
                }
                x-=tr[pos].r-tr[pos].l+1;
                pos=tr[pos].son[1];
            }
        }
    }
    void pop(int x){
        int nxt=next_node(x),lst=last_node(x);
        if(!nxt){
            tr[tr[x].son[0]].fa=0;
            root=tr[x].son[0];
        }else if(!lst){
            tr[tr[x].son[1]].fa=0;
            root=tr[x].son[1];
        }else{
            splay(nxt,0);
            splay(lst,root);
            tr[lst].son[1]=0;
            pushup(lst);
            pushup(nxt);
        }
        tr[x].fa=tr[x].son[0]=tr[x].son[1]=0;
        tr[x].sub=tr[x].r-tr[x].l+1;
    }
    void push_back(int x){
        if(!root){
            root=x;
            return;
        }
        int pos=root;
        while(tr[pos].son[1]){
            pos=tr[pos].son[1];
        }
        tr[tr[pos].son[1]=x].fa=pos;
        while(pos){
            pushup(pos);
            pos=tr[pos].fa;
        }
        splay(x,0);
    }
}s[N];
signed main(){
    cin>>n>>m>>q;
    for(int i=1;i<=n;i++){
        s[i].init((i-1)*m+1,i*m-1);
    }
    s[0].init(m,m);
    for(int i=2;i<=n;i++){
        s[0].push_back(s[0].new_node(i*m,i*m));
    }
    while(q--){
        cin>>x>>y;
        if(y==m){
            auto val=s[0].find(x);
            cout<<val.second<<endl;
            s[0].pop(val.first);
            s[0].push_back(val.first);
            continue;
        }
        auto val=s[x].find(y);
        cout<<val.second<<endl;
        s[x].split(s[x].split(val.first,val.second-1),val.second);
        int pos=s[x].find(y).first;
        s[x].pop(pos);
        s[0].push_back(pos);
        val=s[0].find(x);
        s[0].split(s[0].split(val.first,val.second-1),val.second);
        pos=s[0].find(x).first;
        s[0].pop(pos);
        s[x].push_back(pos);
    }
    return 0;
}
```
完结撒花~

---


# [TJOI2015] 弦论

## 题目描述

为了提高智商，ZJY 开始学习弦论。这一天，她在《String theory》中看到了这样一道问题：对于一个给定的长度为 $n$ 的字符串，求出它的第 $k$ 小子串是什么。你能帮帮她吗?


## 说明/提示

### 数据范围

对于 $10\%$ 的数据，$n\leq 1000$。

对于 $50\%$ 的数据，$t = 0$。

对于 $100\%$ 的数据，$1\leq n \leq 5 \times 10^5$，$0\leq t \leq 1$，$1\leq k \leq 10^9$。


## 样例 #1

### 输入

```
aabc
0 3```

### 输出

```
aab```

## 样例 #2

### 输入

```
aabc
1 3```

### 输出

```
aa```

## 样例 #3

### 输入

```
aabc
1 11```

### 输出

```
-1```

# 题解

## 作者：xzyxzy (赞：64)

如果你还不懂SAM，请点击[blog](https://www.cnblogs.com/xzyxzy/p/9186759.html)

构建出$SAM$之后，求出$sum[i]$，表示有$sum[i]$个子串经过$i$号点

$siz[i]$表示$i$所代表的$Endpos$的集合大小，也就是$i$所对应字符串集合的出现次数

$T=0$时，本质相同的子串在不同位置出现算相同，所以$siz[i]=1$，即将每个字符串集合的$Endpos$集合大小（字符串集合元素出现次数）置为$1$

$T=1$时，本质相同的子串在不同位置出现算不同，那么累加后的$siz$表示实际上$Endpos$的集合大小

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#define ll long long
using namespace std;
const int N=1100000;
char s[N];
int fa[N],len[N],siz[N],ch[N][26];
int t[N],A[N];
ll sum[N],K;
int l,lst=1,node=1,T;
void Extend(int c)
{
	int f=lst,p=++node;lst=p;
	len[p]=len[f]+1;siz[p]=1;
	while(f&&!ch[f][c]) ch[f][c]=p,f=fa[f];
	if(!f) {fa[p]=1;return;}
	int x=ch[f][c],y=++node;
	if(len[x]==len[f]+1) {fa[p]=x;node--;return;}
	memcpy(ch[y],ch[x],sizeof(ch[y]));
	len[y]=len[f]+1; fa[y]=fa[x]; fa[x]=fa[p]=y;
	while(f&&ch[f][c]==x) {ch[f][c]=y;f=fa[f];}
}
void Print(int x,int k)
{
	if(k<=siz[x]) return;
	k-=siz[x];
	for(int i=0;i<26;i++)
	{
		int R=ch[x][i]; if(!R) continue;
		if(k>sum[R]) {k-=sum[R];continue;}
		putchar(i+'a');Print(R,k);return;
	}
}
int main()
{
	//Part 1 Build SAM
	scanf("%s%d%lld",s,&T,&K);l=strlen(s);
	for(int i=l;i>=1;i--) s[i]=s[i-1];s[0]=0;
	for(int i=1;i<=l;i++) Extend(s[i]-'a');
	//Part 2 Sort
	for(int i=1;i<=node;i++) t[len[i]]++;
	for(int i=1;i<=node;i++) t[i]+=t[i-1];
	for(int i=1;i<=node;i++) A[t[len[i]]--]=i;
	for(int i=node;i>=1;i--) siz[fa[A[i]]]+=siz[A[i]];
	for(int i=1;i<=node;i++) T==0?(sum[i]=siz[i]=1):(sum[i]=siz[i]);
	siz[1]=sum[1]=0;

	/*
	  这一段代码调试了半个小时
	  前者是对自动机处理（自动机上累加求的是子串个数）
	  后者是parent树（parent树上累加求的是i节点对应的endpos的字符集的longest的出现次数）
	 */
	for(int i=node;i>=1;i--)
		for(int j=0;j<26;j++)
			if(ch[A[i]][j]) sum[A[i]]+=sum[ch[A[i]][j]];
//	for(int i=node;i>=1;i--) sum[fa[A[i]]]+=sum[A[i]];

	if(sum[1]<K) puts("-1");
	else Print(1,K),puts("");
	return 0;
}
```
~~经过进一步的学习发现之前的题解不够清晰，Upd：6.16~~

---

## 作者：万弘 (赞：53)

SAM好题。

先考虑$t=0$,即本质不同才算不同：  
对于每个点$u$，维护一个$f_u$表示经过$u$的**本质不同子串数量**。这等价于在SAM的DAG上，$u$所能到达的点（如果$u$不是根，那么也算的）的数量（等价于除根之外的点点权为1，所能到达的点权和），可以dfs或按拓扑序递推求得。

现在考虑$t=1$,即位置不同即不同：  
对于每个点$u$,维护一个$f_u$表示经过$u$的**位置不同子串数量**。显然经过它的每个串$s$的贡献是$endpos(s)$的大小（这就是出现的$s$次数）。而根到$u$表示的串的$endpos$大小就是parent树上$u$的子树中的前缀点数量。先dfs求出$size_u$表示$u$的子树大小，并将它作为点权，问题即转化为$t=0$的情况。

考虑查询：(假设现在的节点是$u$,要查第$k$小子串）  
先将$k$减去$u$的点权。按字典序递增考虑$u$能直接到达的点$v$,如果$k\le f_v$,则输出$v$表示的字符，并递归查询$(v,k)$,否则$k$减去$f_v$.注意判断-1的情况。

时间复杂度$O(n)$,常数较大。  
写了封装SAM，可读性应该还行。
```cpp
#define MAXN 1000011
struct SAM
{
	ll t[MAXN][26],pre[MAXN],len[MAXN];
	ll f[MAXN],size[MAXN];//f和size含义已说明
	ll last,tot;
	SAM()
	{
		last=1,tot=1;
		cnt=0; 
	}
	void insert(ll w)
	{
		ll pos=last,cur=++tot;
		len[cur]=len[pos]+1;f[cur]=size[cur]=1;
		while(pos&&!t[pos][w])
		{
			t[pos][w]=cur;
			pos=pre[pos];
		}
		if(!pos)
		{
			pre[cur]=1;
			last=cur;
			return;
		}
		ll nxt=t[pos][w];
		if(len[nxt]==len[pos]+1)pre[cur]=nxt;
		else
		{
			ll tmp=++tot;
			len[tmp]=len[pos]+1;
			memcpy(t[tmp],t[nxt],sizeof t[nxt]);
			pre[tmp]=pre[nxt];
			pre[nxt]=pre[cur]=tmp;
			while(pos&&t[pos][w]==nxt)t[pos][w]=tmp,pos=pre[pos];
		}
		last=cur;
	}
	bool vis[MAXN];//访问标记,用于记忆化搜索
	struct Edge//parent树
	{
		ll v,nxt;
	}e[MAXN];
	ll cnt,head[MAXN];
	void adde(ll u,ll v)
	{
		e[++cnt].v=v;
		e[cnt].nxt=head[u],head[u]=cnt;
	}
	void dfs1(ll u)//求size,作为点权
	{
		for(ll i=head[u];i;i=e[i].nxt)
		{
			ll v=e[i].v;
			dfs1(v);
			size[u]+=size[v];
		}
		f[u]=size[u];
	}
	ll dfs2(ll u)//求所能到达的点的点权和
	{
		if(vis[u])return f[u];
		vis[u]=1;
		for(ll i=0;i<26;++i)
		{
			ll v=t[u][i];
			if(v)f[u]+=dfs2(v);
		}
		return f[u];
	}
	void build(ll type)//求出f,size
	{
		for(ll i=1;i<=tot;++i)
			if(pre[i])adde(pre[i],i);
		if(!type)//两种情况
		{
			for(ll i=1;i<=tot;++i)f[i]=size[i]=1;
		}
		else dfs1(1);
		f[1]=size[1]=0;//注意根的点权是0
		dfs2(1);
	}
	void Query(ll u,ll k)//询问
	{
		if(k>f[u])
		{
			puts("-1");return;
		}
		if(k<=size[u])return;
		k-=size[u];
		for(ll i=0;i<26;++i)
		{
			ll v=t[u][i];
			if(k>f[v])k-=f[v];
			else
			{
				putchar('a'+i);
				Query(v,k);
				return;
			}
		}
	}
}sam;
char a[MAXN];
int main()
{
	scanf("%s",a+1);
	ll n=strlen(a+1);
	for(ll i=1;i<=n;++i)sam.insert(a[i]-'a');
	ll t=read(),k=read();
	sam.build(t);
	sam.Query(1,k);
	return 0;
}
```

---

## 作者：ezoiLZH (赞：45)

** _没人发后缀数组的做法，我来发一波！_ **

戳这里食用更佳[ヾ(◍°∇°◍)ﾉﾞ](https://www.cnblogs.com/ezoiLZH/p/9471261.html)

相信T=0，大家都会做，这是后缀数组的一个经典问题。

具体就是，每个子串都是一个后缀的前缀。

从头到尾扫，每个后缀都会有 n−sa[i]+1−height[i] 个本质不同的子串，即可。

重点是T=1时，怎么用后缀数组解决？

由于我比较菜，我想了一个大暴力，一位一位的枚举！

因为我们前面的字母是确定的，那么当前面的字母一样的时候，后面一个字母一定是单调不下降的。

那我们就能二分求出这个字母最后一个的位置。

我们建一个后缀长度的前缀和，那我们就能求出以这个字母开头的子串有多少个。

当个数大于k时，就确定了这个字母，否则k减去，继续枚举下一个字母。

枚举完一位继续下一位，那我们就能把范围缩小，知道求出答案。

具体看代码……

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;

int n,t,k;
long long sum[500005];
char s[500005];
struct SA{
	char s[500005];
	int tp[500005],rak[500005];
	int tax[500005],sa[500005];
	int n,m,height[500005];
	void build(char str[]){
		memcpy(s,str,sizeof(s));
		n=strlen(s+1);
		build_sa(rak,tp);
		build_height();
	}
	void sort(int a[],int b[]){
		for(int i=1;i<=m;i++)tax[i]=0;
		for(int i=1;i<=n;i++)tax[a[i]]++;
		for(int i=1;i<=m;i++)tax[i]+=tax[i-1];
		for(int i=n;i>=1;i--)sa[tax[a[b[i]]]--]=b[i];
	}
	bool comp(int r[],int a,int b,int k){
		return r[a]==r[b]&&r[a+k]==r[b+k];
	}
	void build_sa(int a[],int b[]){
		for(int i=1;i<=n;i++)
		m=max(m,a[i]=s[i]-'a'+1),b[i]=i;
		sort(a,b);
		for(int p=0,j=1;p<n;j<<=1,m=p){
			p=0;
			for(int i=1;i<=j;i++)b[++p]=n-j+i;
			for(int i=1;i<=n;i++)if(sa[i]>j)b[++p]=sa[i]-j;
			sort(a,b);
			int *t=a;a=b;b=t;
			a[sa[1]]=p=1;
			for(int i=2;i<=n;i++)
			a[sa[i]]=comp(b,sa[i],sa[i-1],j)?p:++p;
		}
		for(int i=1;i<=n;i++)rak[sa[i]]=i;
	}
	void build_height(){
		for(int i=1,j=0;i<=n;i++){
			if(j)j--;
			while(s[i+j]==s[sa[rak[i]-1]+j])j++;
			height[rak[i]]=j;
		}
	}
}a;

int main(){
	scanf("%s%d%d",s+1,&t,&k);
	a.build(s);
	n=strlen(s+1);
	if(t==0){
		for(int i=1;i<=n;i++){
			int c=n-a.sa[i]+1-a.height[i];
			if(k<=c){
				for(int j=a.sa[i];j<=a.sa[i]+a.height[i]+k-1;j++)
					putchar(s[j]);
				return 0;
			}else k-=c;
		}
		printf("-1");
	}else{
		for(int i=1;i<=n;i++)		//处理前缀和 
			sum[i]=sum[i-1]+n-a.sa[i]+1;
		if(sum[n]<k)return printf("-1"),0;	//子串不够输出-1 
		int L=1,R=n;
		for(int i=1;i<=n;i++){
			int tmp=L;
			for(int j='a';j<='z';j++){	//枚举 a~z 
				int l=tmp,r=R;
				while(l<=r){	//二分找这个字母的最后一个位置 
					int mid=l+r>>1;
					if(s[a.sa[mid]+i-1]>j)r=mid-1;
					else l=mid+1;
				}
				long long t=sum[r]-sum[tmp-1]-1LL*(r-tmp+1)*(i-1);
				//现在枚举的区间有多少个子串 
				//减是因为减去前面枚举过得位置 
				if(k<=r-tmp+1){
					//现在要查的比现在字母的个数少，说明这个字母就是结束的位置 
					for(int j=a.sa[tmp];j<=a.sa[tmp]+i-1;j++)
						putchar(s[j]);
					return 0;
				}
				if(t>=k){	//说明这位就是这个字母，减去字母个数 
					L=tmp,R=r;
					k-=r-tmp+1;
					break;
				}
				tmp=r+1,k-=t;	//不是，继续枚举 
			}
			if(n-a.sa[L]+1==i)L++;	//如果下一位为空，就不用算了。 
		}
	}
}
```

---

## 作者：xtx1092515503 (赞：36)

# [Portal](https://www.luogu.com.cn/problem/P3975)

大家好，这里介绍一种理论复杂度可以优化到$O(n)$的**全新后缀数组**解法。

我们默认串下标从$0$开始。

首先$t=0$的情况就是经典老题了，[不同子串个数](https://www.luogu.com.cn/problem/P2408)。直接遍历$ht$数组，则每个串会增加$n-sa_i-ht_i$个新串，并且这就是**按照字典序**加入的。比较naive，这里就不多说了。显然，它是$O(n)$的，假如你用DC3的话。

------------

然后就是$t=1$的情况了。

显然，我们需要知道每个本质不同的子串各出现了多少次。

我们举一个栗子：

```aabbababb```

它后缀排序后的结果是这样的：

| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| `b` |     |     |     |     |     |     |     |     |
| `b` |     |     | `b` |     |     |     |     |     |
| `a` |     |     | `b` |     |     |     |     | `b` |
| `b` |     |     | `a` |     | `b` |     |     | `b` |
| `a` | `b` |     | `b` |     | `b` |     |     | `a` |
| `b` | `b` |     | `a` |     | `a` | `b` |     | `b` |
| `b` | `a` | `b` | `b` |     | `b` | `b` |     | `a` |
| `a` | `b` | `b` | `b` |     | `a` | `a` | `b` | `b` |
| `a` | `a` | `a` | `a` | `b` | `b` | `b` | `b` | `b` |

我们发现，它实际上可以被看做一个树形结构来表示字典序：

![](https://cdn.luogu.com.cn/upload/image_hosting/loco3y0c.png)

update：新知道有种名叫“**笛卡尔树**”的神奇玩意儿……下面的东西似乎就是它的魔改，大体思路和笛卡尔树是相同的……如果已经会笛卡尔树的神仙直接结合笛卡尔树理解就OK了……

~~我居然自己yy出了笛卡尔树~~

------------

那么这棵树（姑且把它叫做“$ht$树”），有什么性质呢？

1. 每个节点所代表的区间，都有着相同的前缀，且该公共前缀长度一定**大于等于**父亲节点区间的公共前缀长度。例如，$(2,3)$节点所代表的公共前缀```abb```，就要长于它父亲节点，$(1,3)$所代表的```ab```。

2. **每条极长公共前缀（即长度如果再增长其对应的区间就会缩短的前缀）都唯一对应着树中的一个区间，每个区间也反过来对应唯一的极长公共前缀**。从这一点，我们可以得出一条重要结论，即$ht$树的节点数最多为$2n+1$，因为极长公共前缀的数量最多是$n$，然后还有$n$个大小为$1$的区间，同时还有一个为了方便当作根的$(0,n-1)$区间。$O(n)$**级别的节点数，是保障总复杂度仍为$O(n)$的前提**。同时，这极长公共前缀的出现次数，就是**区间大小**。（这里如果结合笛卡尔树的思想来看，实际上就是对$n$个后缀与$n+1$个间隔建立一棵笛卡尔树，故总数是$2n+1$）

3. 对这棵树**先根遍历**，访问到的节点所代表的公共前缀**是按照字典序排序的**。这很好理解，因为原串的所有后缀本来就已经排序过了。

4. **这棵树的大区间在分裂成小区间时，是在$\min ht$的地方分裂的**。在上面那组栗子中看一看是不是？

于是我们就可以构思出一种方法：

我们设$len_{(i,j)}$表示区间$(i,j)$所对应的极长公共前缀的长度。则先根遍历$ht$树，对于当前节点，如果$(j-i+1)\times(len_{i,j}-len_{fa})<k$，就令$k$减去左边那一大坨，并继续遍历；否则，答案就在当前节点，输出即可。

显然，按照我们的思路，$\min ht$是一定要求出来的。这只能使用ST表来求，则复杂度为$O(n\log n)$。我们接下来会讲解如何消掉那个$\log$，这里先贴一下单$\log$的代码：

```cpp
void solve(int l,int r,int las){
	if(l>r){
		if(id>n-sa[r]-las)id-=n-sa[r]-las;
		else{for(int j=0;j<id+las;j++)putchar(s[sa[r]+j]);exit(0);}
		return;
	}
	int mp=RMQ(l,r);
	if(id>1ll*(ht[mp]-las)*(r-l+2))id-=1ll*(ht[mp]-las)*(r-l+2);
	else{
		for(int j=0;j<las;j++)putchar(s[sa[r]+j]);
		for(int j=las;id>0;id-=(r-l+2),j++)putchar(s[sa[r]+j]);
		exit(0);
	}
	solve(l,mp-1,ht[mp]),solve(mp+1,r,ht[mp]);
}
```
注意到这里的实现不太一样，```solve(l,r,las)```，实际上对应的区间应是$(l-1,r)$。这么写主要是为了方便直接RMQ。这里```las```即为$len_{fa}$，而$len_{(l,r)}$则为```ht[mp]```。

带$\log$的完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int stk[500100],tp,L[500100],R[500100],id,pt;
namespace Suffix_Array{
	const int N=500100;
	int x[N],y[N],sa[N],ht[N],rk[N],buc[N],n,m;
	char s[N];
	bool mat(int a,int b,int k){
		if(y[a]!=y[b])return false;
		if((a+k<n)^(b+k<n))return false;
		if((a+k<n)&&(b+k<n))return y[a+k]==y[b+k];
		return true;
	}
	void SA(){
		for(int i=0;i<n;i++)buc[x[i]=s[i]]++;
		for(int i=1;i<=m;i++)buc[i]+=buc[i-1];
		for(int i=n-1;i>=0;i--)sa[--buc[x[i]]]=i;
		for(int k=1;k<n;k<<=1){
			int num=0;
			for(int i=n-k;i<n;i++)y[num++]=i;
			for(int i=0;i<n;i++)if(sa[i]>=k)y[num++]=sa[i]-k;
			for(int i=0;i<=m;i++)buc[i]=0;
			for(int i=0;i<n;i++)buc[x[y[i]]]++;
			for(int i=1;i<=m;i++)buc[i]+=buc[i-1];
			for(int i=n-1;i>=0;i--)sa[--buc[x[y[i]]]]=y[i],y[i]=0;
			swap(x,y);
			x[sa[0]]=num=0;
			for(int i=1;i<n;i++)x[sa[i]]=mat(sa[i],sa[i-1],k)?num:++num;
			m=num;
		}
		for(int i=0;i<n;i++)rk[sa[i]]=i;
		for(int i=0,k=0;i<n;i++){
			if(!rk[i])continue;
			if(k)k--;
			int j=sa[rk[i]-1];
			while(j+k<n&&i+k<n&&s[j+k]==s[i+k])k++;
			ht[rk[i]]=k;
		}
	}	
}
using namespace Suffix_Array;
int mn[500100][20],LG[500100];
int MIN(int i,int j){
	return ht[i]<=ht[j]?i:j;
}
int RMQ(int l,int r){
	int k=LG[r-l+1];
	return MIN(mn[l][k],mn[r-(1<<k)+1][k]);
}
void solve(int l,int r,int las){
//	printf("%d %d %d\n",l,r,las);
	if(l>r){
		if(id>n-sa[r]-las)id-=n-sa[r]-las;
		else{for(int j=0;j<id+las;j++)putchar(s[sa[r]+j]);exit(0);}
		return;
	}
	int mp=RMQ(l,r);
	if(id>1ll*(ht[mp]-las)*(r-l+2))id-=1ll*(ht[mp]-las)*(r-l+2);
	else{
		for(int j=0;j<las;j++)putchar(s[sa[r]+j]);
		for(int j=las;id>0;id-=(r-l+2),j++)putchar(s[sa[r]+j]);
		exit(0);
	}
	solve(l,mp-1,ht[mp]),solve(mp+1,r,ht[mp]);
}
int main(){
	scanf("%s",s),n=strlen(s),scanf("%d%d",&pt,&id),m='z';
	SA();
//	for(int i=0;i<n;i++)printf("%d ",sa[i]);puts("");
//	for(int i=0;i<n;i++)printf("%d ",ht[i]);puts("");
	if(pt==0){
		for(int i=0;i<n;i++){
			if(n-sa[i]-ht[i]<id)id-=n-sa[i]-ht[i];
			else{for(int j=0;j<id+ht[i];j++)putchar(s[sa[i]+j]);id=0;break;}
		} 
		if(id)puts("-1");
	}else{
		for(int i=2;i<n;i++)LG[i]=LG[i>>1]+1;
		for(int i=1;i<n;i++)mn[i][0]=i;
		for(int j=1;j<=LG[n-1];j++)for(int i=1;i+(1<<j)-1<n;i++)mn[i][j]=MIN(mn[i][j-1],mn[i+(1<<(j-1))][j-1]);
//		for(int i=0;i<n;i++)printf("%d ",ht[i]);puts("");
//		for(int i=0;i<n;i++)printf("%d ",sa[i]);puts("");
		solve(1,n-1,0);
		puts("-1");
	}
	return 0;
}
```


------------

至于不带$\log$的做法，直接建笛卡尔树即可。

然后就是后缀排序部分了。显然，用DC3算法来排序也能够做到$O(n)$。

则总复杂度$O(n)$。

~~感觉可以出一道$n\leq5\times 10^6$的毒瘤题~~？

~~但是隔壁SAM的复杂度好像很轻松就搞到$O(n)$了？那我还费心思卡这个$O(n)$干什么……~~

~~那就这样吧，笛卡尔树的代码太懒不想写了~~

---

## 作者：皎月半洒花 (赞：33)

~~虽然感觉这题已经被人做烂了再发题解也没啥意思了~~

这篇题解是非bfs版，感觉更好理解也更好写？反正我觉得初学者如果写这种dp的话应该会更容易理解？emm反正比其他题解思路更直观一点。

首先就是SAM就完事儿了。

然后考虑怎么求这个东西，那肯定先在parent树上dp一遍求出来每个子串的出现次数；

但问题是我们如果要像平衡树那样找第$k$小，求的应该是经过每个点的子串数量，于是就需要在DAG上再dp一遍。

然而上面是老生常谈。由于是DAG，~~所以想怎么dp怎么dp~~所以会比较容易，直接dfs就完了，这样感觉思路比较顺

~~画外音：为啥总感觉这个人在水题解啊？这不就是换了个dp方式吗~~

~~我不是我没有……并且感觉这题除了dp还有什么别的值得一提的地方吗？~~

```cpp
struct SAM{
	int last, sz ;
	int trans[MAXN][Sigma] ;
	int len[MAXN], fa[MAXN] ;
	void Init(){ last = sz = 1 ; }
	void Insert(int x){
		int np = ++ sz ; 
		int p = last, q, nq ;
		last = np, f[np] = 1 ;
		len[np] = len[p] + 1 ;
		while (p && !trans[p][x]) 
			trans[p][x] = np, p = fa[p] ; 
		if (!p)
			return fa[np] = 1, void() ; 
		q = trans[p][x] ; 
		if (len[q] == len[p] + 1)
			return fa[np] = q, void() ;
		nq = ++ sz, 
		len[nq] = len[p] + 1;
		fa[nq] = fa[q], fa[q] = fa[np] = nq ; 
		memcpy(trans[nq], trans[q], sizeof(trans[q])) ; 
		while (p && trans[p][x] == q) 
			trans[p][x] = nq, p = fa[p] ;
	}
}S;
il void add(int u, int v){
	E[++ ctn].to = v, E[ctn].next = head[u], head[u] = ctn ;
}
void dfs(int u){//第一次的树上dp
	for (int k = head[u] ; k ; k = next(k)) 
		dfs(to(k)), f[u] += f[to(k)] ;
}
void dfs2(int u){//第二次的DAG上dp
	if (vis[u]) return ; vis[u] = 1 ;
	for (int i = 1 ; i <= 26 ; ++ i) 
		if (S.trans[u][i]) 
			dfs2(S.trans[u][i]), g[u] += g[S.trans[u][i]] ;
}
void go_Out(int p, int s){//输出
	if (s <= f[p]) return ; else s -= f[p] ; 
	for (int i = 1 ; i <= 26 ; ++ i)
		if (!S.trans[p][i]) continue ;
		else if (s > g[S.trans[p][i]]) s -= g[S.trans[p][i]] ;
		else { printf("%c", i + 'a' - 1), go_Out(S.trans[p][i], s) ; return ; }
}
int main(){
	cin >> (In + 1) >> T >> K ; 
	N = strlen(In + 1) ; S.Init() ;
	for (int i = 1 ; i <= N ; ++ i) S.Insert(In[i] - 'a' + 1) ; 
	for (int i = 2 ; i <= S.sz ; ++ i) add(S.fa[i], i) ; dfs(1) ;
	for (int i = 1 ; i <= S.sz ; ++ i) g[i] = T ? f[i] : (f[i] = 1) ; 
	f[1] = g[1] = 0, dfs2(1) ; if (K > g[1]) return puts("-1"), 0 ; else return go_Out(1, K), 0 ; 
}

```


## $\rm by~Orchidany$

---

## 作者：George1123 (赞：21)

[$\Huge\color{#7755a3}\tt My~Cnblogs$](https://www.cnblogs.com/Wendigo/p/12939343.html)

---
> [TJOI2015 弦论](https://www.luogu.com.cn/problem/P3975)

> 字符串 $s$ 和 $t$ 和 $k$。如果 $t=0$，不同位置的相同子串算 $1$ 个；如果 $t=1$，不同位置的相同子串算多个。求 $k$ 小子串，如果不存在输出 $-1$。

> 数据范围：$1\le n\le 5\cdot 10^5$，$t\in\{0,1\}$，$1\le k\le 10^9$。

---
这题还是很经典的，对理解**后缀自动机 $\tt SAM$** 很有帮助。以前我做过这题（并写了题解），现在复习后缀自动机的时候又做了一次，感悟颇多，遂记之。

---
首先后缀自动机的节点表示的是一个 $\bf Endpos$ 集以及该集对应的**子串（不一定是后缀）**。

一个节点 $i$ 对应的**子串长度范围**为 $[len_{fa_i}+1,len_i]$，即对应**子串种数**为 $len_i-len_{fa_i}$。

同时对应**每种子串的数量**均为 $|{\bf Endpos}_i|$ 个。

---
先看处理这些种数、数量等奇奇怪怪的东西的代码（$dep$ 即 $len$）：

```cpp
void run(int t){
	for(int i=1;i<=cnt;i++) c[dep[i]]++; 
	for(int i=1;i<=cnt;i++) c[i]+=c[i-1];
	for(int i=1;i<=cnt;i++) q[c[dep[i]]--]=i;
	for(int i=cnt;i>=1;i--) sz[fa[q[i]]]+=sz[q[i]]; //①
	for(int i=1;i<=cnt;i++) sm[i]=t?sz[i]:(sz[i]=1); //②
	sz[1]=sm[1]=0;
	for(int i=cnt;i>=1;i--)
		for(int c=0;c<26;c++) sm[q[i]]+=sm[ch[q[i]][c]]; //③
}
```
这个 $q$ 数组是对后缀自动机节点按 $len$ 排序（$len_i>len_{fa_i}$）。

①：求出 $sz_i=|{\bf Endpos}_i|$。

②：按照题目要求处理。

③：处理子自动机子串数量和 $sm_i$，一个 $|{\bf Endpos}_i|$ 被算 $len_i-len_{fa_i}$ 次。

---
至于输出 $k$ 大子串，一个 $\tt Dfs$ 的问题。

```cpp
void Print(int p,int k){
	if(k<=sz[p]) return;
	k-=sz[p];
	for(int c=0;c<26;c++)if(ch[p][c]){
		if(k>sm[ch[p][c]]) k-=sm[ch[p][c]];
		else return void((putchar(c+'a'),Print(ch[p][c],k)));
	}
}
```

---
- **代码**

```cpp
#include <bits/stdc++.h>
using namespace std;

//Start
typedef long long ll;
typedef double db;
#define mp(a,b) make_pair(a,b)
#define x first
#define y second
#define b(a) a.begin()
#define e(a) a.end()
#define sz(a) int((a).size())
#define pb(a) push_back(a)
const int inf=0x3f3f3f3f;
const ll INF=0x3f3f3f3f3f3f3f3f;

//Data
const int N=5e5;
int n;
char s[N+7];

//SuffuxAutomaton
const int T=N<<1;
int en=1,cnt=1,ch[T+7][26],fa[T+7],dep[T+7]; //dep即len
ll sz[T+7],sm[T+7];
void insert(int c){
	int p=en,np=en=++cnt;
	dep[np]=dep[p]+1;
	for(;p&&!ch[p][c];p=fa[p]) ch[p][c]=np;
	if(!p) fa[np]=1;
	else {
		int q=ch[p][c];
		if(dep[q]==dep[p]+1) fa[np]=q;
		else {
			int nq=++cnt;
			dep[nq]=dep[p]+1;
			memcpy(ch[nq],ch[q],sizeof ch[q]);
			fa[nq]=fa[q],fa[q]=fa[np]=nq;
			for(;ch[p][c]==q;p=fa[p]) ch[p][c]=nq;
		}
	}
	sz[np]=1;
}
int c[T+7],q[T+7];
void run(int t){
	for(int i=1;i<=cnt;i++) c[dep[i]]++; 
	for(int i=1;i<=cnt;i++) c[i]+=c[i-1];
	for(int i=1;i<=cnt;i++) q[c[dep[i]]--]=i;
	for(int i=cnt;i>=1;i--) sz[fa[q[i]]]+=sz[q[i]];
	for(int i=1;i<=cnt;i++) sm[i]=t?sz[i]:(sz[i]=1);
	sz[1]=sm[1]=0;
	for(int i=cnt;i>=1;i--)
		for(int c=0;c<26;c++) sm[q[i]]+=sm[ch[q[i]][c]];
}
void Print(int p,int k){
	if(k<=sz[p]) return;
	k-=sz[p];
	for(int c=0;c<26;c++)if(ch[p][c]){
		if(k>sm[ch[p][c]]) k-=sm[ch[p][c]];
		else return void((putchar(c+'a'),Print(ch[p][c],k)));
	}
}

//Main
int main(){
	int t,k; scanf("%s%d%d",&s[1],&t,&k),n=strlen(&s[1]);
	for(int i=1;i<=n;i++) insert(s[i]-'a');
	run(t);
	if(sm[1]>=k) Print(1,k); else puts("-1");
	return 0;
}

```
---
**祝大家学习愉快！**

---

## 作者：George1123 (赞：13)

**广告：[blog $\biguplus$](https://www.luogu.com.cn/blog/Wendigo/)**

[P3975 【\[TJOI2015\]弦论】](https://www.luogu.com.cn/problem/P3975)

### 此题算法：后缀自动机

用后缀数组做 $t=0$ 的情况很简单，但做 $t=1$ 就很麻烦。

首先自带模板，但这里顺便解释一下这个深奥的模板：

```cpp
int ch[N<<1][30],fa[N<<1],len[N<<1];
int lent[N<<1],sa[N<<1],cnt=1,lst=1;
lng mk[N<<1],sum[N<<1];
```
后缀自动机是一个 $DAG$ 有向无环图，有 $cnt$ 个节点。

$cnt$ 总是满足 $n\le cnt\le2n$，所以数组大小开双倍。

$ch[i][j]$ 表示节点 $i$ 边上字母为 $j$ 时可通往的点。

$fa[i]$ 表示节点 $i$ 表示 $lent[fa[i]]+1\sim len[i]$ 的子串。

$len[i]$ 表示以 $i$ 为后缀的字符串最长长度。

**如下是【样例#1】生成的后缀自动机：**

![后缀自动机.jpg](https://i.loli.net/2020/02/06/nwsUhXNcdHkrOe4.jpg)

模板敲好后，用 $lent[]$ 和 $sa[]$ 对节点按 $len[]$ 排序，$sa[i]$ 表示排名为 $i$ 的节点编号。

然后用 $mk[]$ 表示以这个节点为前缀的 $fa[]$ 链子串数。

如果 $t=0$ 那么令所有 $mk[]=1$，只表示它最长的 $fa[]$ 链子串以去重。如果 $t=1$，那么无需去重。

然后用 $sum[]$ 表示以这个节点为起点的子串数。

最后用 $dfs()$ 寻找第 $k$ 大子串。

每个数组的计算具体见**代码 $+$ 注释**。


## 代码 $+$ 注释

```cpp
#include <bits/stdc++.h>
using namespace std;
#define lng long long
const int N=5e5+10;
int n,t,k;
char s[N];
namespace SAM{
	int ch[N<<1][30],fa[N<<1],len[N<<1]; //开双倍 n 数组
	int lent[N<<1],sa[N<<1],cnt=1,lst=1;
	lng mk[N<<1],sum[N<<1];
	void insert(int c){ //模板-插入字符
		int x=lst,nx=lst=++cnt;
		mk[nx]=1,len[nx]=len[x]+1;
		while(x&&!ch[x][c]) ch[x][c]=nx,x=fa[x];
		if(!x) return fa[nx]=1,void();
		int y=ch[x][c];
		if(len[y]==len[x]+1) return fa[nx]=y,void();
		int ny=++cnt;
		len[ny]=len[x]+1,fa[ny]=fa[y],fa[y]=fa[nx]=ny;
		memcpy(ch[ny],ch[y],sizeof ch[y]);
		while(x&&ch[x][c]==y) ch[x][c]=ny,x=fa[x];
	}
}using namespace SAM;
int main(){
	scanf("%s%d%d",s+1,&t,&k),n=strlen(s+1);
	for(int i=1;i<=n;i++) insert(s[i]-'a'+1);
	for(int i=1;i<=cnt;i++) lent[len[i]]++;
	for(int i=1;i<=cnt;i++) lent[i]+=lent[i-1];
	for(int i=1;i<=cnt;i++) sa[lent[len[i]]--]=i; //Sort by len
	for(int i=cnt;i>=1;i--) mk[fa[sa[i]]]+=mk[sa[i]]; //求出以 i 为起点的 fa[] 链子串数
	for(int i=1;i<=cnt;i++)
		if(t==0) sum[i]=mk[i]=1; //去重
		else sum[i]=mk[i];
	sum[1]=mk[1]=0; //1 是源点，没有真正以此节点为起点的子串
	for(int i=cnt;i>=1;i--)
		for(int j=1;j<=26;j++)
			if(ch[sa[i]][j]) sum[sa[i]]+=sum[ch[sa[i]][j]]; //以这个节点为起点的子串数
	if(sum[1]<k) puts("-1"); //不存在第 k 大子串
	else { 
		for(int i=1,end=0;!end;){ //模拟dfs
			end=1;
			if(i!=1){ //表示结束符
				if(k>mk[i]) k-=mk[i];
				else break;
			}
			for(int j=1;j<=26;j++) //表示 a~z
				if(ch[i][j]){
					if(k>sum[ch[i][j]]) k-=sum[ch[i][j]]; 
					else {
						printf("%c",j+'a'-1);
						i=ch[i][j],end=0;
						break;
					}
				}
		}
		puts("");
	}
	return 0;
}
```

后缀自动机比后缀数组抽象得多，就算写出来也难调。

**图是手画的，写题解不易，点个赞吧。**

谢谢大家！！


---

## 作者：zhoukangyang (赞：12)

不会后缀自动机的[点这里](https://www.cnblogs.com/zkyJuruo/p/13484477.html)
, 也欢迎来蒟蒻的 [博客园](https://www.cnblogs.com/zkyJuruo/articles/13500090.html) 里看这篇文章。

首先先建立后缀自动机, 这时要统计对于 $parent$ 树上的每一个节点的出现次数。第一种方法是 $parent$ 树上 $dfs$ 实现, 但是不建议。~~然而我第一次写 SAM 也是用 dfs 的~~

先看代码
```cpp
void work() {
	// sort
	for(int i = 1; i <= tot; i++) c[f[i].len]++;
	for(int i = 1; i <= tot; i++) c[i] += c[i - 1];
	for(int i = 1; i <= tot; i++) q[c[f[i].len]--] = i;
	// getans
	for(int i = tot; i >= 1; i--) cnt[f[q[i]].fa] += cnt[q[i]];
	cnt[1] = 0; // 根结点是空节点, 没有子串
	if(!opt) for(int i = 2; i <= tot; i++) cnt[i] = 1; // 按照题目意思统计
	for(int i = 2; i <= tot; i++) sm[q[i]] = cnt[q[i]]; // 先复制数组
	for(int i = tot; i >= 1; i--) 
		for(int j = 0; j < 26; j++) 
			sm[q[i]] += sm[f[q[i]].ch[j]];// 统计这个节点 SAM 上的信息, 就是这一个节点下面总共有几个字串。
	dfs(1, k);
}
```

可以先按 $len$ 排序, 因为 $len_{fa_i} < len_i$。所以这时候遍历 $parent$ 树时可以不深搜, 只要从后往前遍历即可。所以只要在排序后的数组上从后往前遍历即可。

接下来按照题目的意思($type = 0 \ \ or \ \  type = 1$)统计一下。

然后为了统计答案, 记录一下在 SAM 上这个节点后的字串个数就好了。

如何输出答案？

$dfs !$

Code:
```cpp
#include<bits/stdc++.h>
#define N 2000010
using namespace std;
int n, k, flag, opt, las = 1, tot = 1, cnt[N], sm[N];
long long Ans;
struct node {
	int ch[26], len, fa;
} f[N];
void ins(int x) {
	int p = las, now = las = ++tot;
	f[now].len = f[p].len + 1, cnt[now] = 1;
	for(; p && !f[p].ch[x]; p = f[p].fa) f[p].ch[x] = now;
	if(!p) f[now].fa = 1;
	else {
		int pto = f[p].ch[x];
		if(f[p].len + 1 == f[pto].len) f[now].fa = pto;
		else {
			int sp = ++tot;
			f[sp] = f[pto], f[sp].len = f[p].len + 1;
			f[now].fa = f[pto].fa = sp;
			for(; p && f[p].ch[x] == pto; p = f[p].fa) f[p].ch[x] = sp;
		}
	} 
}
int c[N], q[N];
void dfs(int x, int y) {
	y -= cnt[x];
	if(y <= 0) return; 
	for(int i = 0; i < 26; i++) if(f[x].ch[i]) {
			if(y <= sm[f[x].ch[i]]) return (void)(printf("%c", 'a' + i), dfs(f[x].ch[i], y));
			y -= sm[f[x].ch[i]];
		}
	if(x == 1) puts("-1"), exit(0); 
}
void work() {
	// sort
	for(int i = 1; i <= tot; i++) c[f[i].len]++;
	for(int i = 1; i <= tot; i++) c[i] += c[i - 1];
	for(int i = 1; i <= tot; i++) q[c[f[i].len]--] = i;
	// getans
	for(int i = tot; i >= 1; i--) cnt[f[q[i]].fa] += cnt[q[i]];
	cnt[1] = 0;
	if(!opt) for(int i = 2; i <= tot; i++) cnt[i] = 1;
	for(int i = 2; i <= tot; i++) sm[q[i]] = cnt[q[i]];
	for(int i = tot; i >= 1; i--) 
		for(int j = 0; j < 26; j++) 
			sm[q[i]] += sm[f[q[i]].ch[j]];
	dfs(1, k);
}
char s[N];
int main() {
	scanf("%s", s), n = strlen(s);
	scanf("%d%d", &opt, &k);
	for(int i = 0; i < n; i++) ins(s[i] - 'a');
	work();
	return 0;
}
```

---

## 作者：远航之曲 (赞：11)

前置姿势：后缀自动机。


要是想学习的话可以来[blog](http://www.yhzq-blog.cc/后缀自动机学习总结/)


题解：


先对这个串建个SAM，再对所有节点按照max排下序。这样就可以从长到短地总结答案。


首先对每个节点维护一个当前节点所占的子串个数。假如t=1就按照Parent树里从叶子节点一层一层往上推的顺序，计算每个串出现的次数。t=0就不用管，直接设成1


这样就可以维护出每个节点往后推会有多少个串。。（直接加起来


然后在SAM上按照字典序往下匹配就可以了


```cpp
#include <cstdio>
#include <cstring>
#define N 500010
using namespace std;
int dis[N<<1],fa[N<<1],siz[N<<1],ch[N<<1][26],sz=1,root=1,last=root,len,t,k;
char s[N];
void insert(int x)
{
    int pre=last,now=++sz;last=now;
    dis[now]=dis[pre]+1;siz[now]=1;
    for (;pre && !ch[pre][x];pre=fa[pre]) ch[pre][x]=now;
    if (!pre) fa[now]=root;
    else
    {
        int q=ch[pre][x];
        if (dis[q]==dis[pre]+1)
            fa[now]=q;
        else
        {
            int nows=++sz;dis[nows]=dis[pre]+1;
            fa[nows]=fa[q],fa[now]=fa[q]=nows;
            memcpy(ch[nows],ch[q],sizeof ch[q]);
            for (;pre && ch[pre][x]==q;pre=fa[pre]) ch[pre][x]=nows;
        }
    }
}
int ton[N<<1],ti[N<<1],sum[N<<1];
void work()
{
    for (int i=1;i<=sz;i++) ton[dis[i]]++;
    for (int i=1;i<=len;i++) ton[i]+=ton[i-1];
    for (int i=1;i<=sz;i++) ti[ton[dis[i]]--]=i;
    for (int i=sz;i;i--)
        if (t) siz[fa[ti[i]]]+=siz[ti[i]];
        else siz[ti[i]]=1;
    siz[root]=0;
    for (int i=sz;i;i--)
    {
        sum[ti[i]]=siz[ti[i]];
        for (int j=0;j<26;j++)
            if (ch[ti[i]][j])
                sum[ti[i]]+=sum[ch[ti[i]][j]];
    }
}
main()
{
    scanf("%s%d%d",s+1,&t,&k);len=strlen(s+1);
    for (int i=1;i<=len;i++) insert(s[i]-'a');
    work();
    if (k>sum[root])    return puts("-1"),0;
    int now=root;
    while((k-=siz[now])>0)
    {
        int p=0;
        while(k>sum[ch[now][p]]) k-=sum[ch[now][p++]];
        now=ch[now][p];
        putchar('a'+p);
    }
}
```

---

## 作者：功在不舍 (赞：10)

~~看来又没啥人讲ukkonen的后缀树~~

~~受迫害的后缀数据结构~~

如果你是写后缀树的，想做这题你得会后缀自动机的模板题目。

首先，对给的字符串建立后缀树，一遍dfs求出每个子串出现了多少遍（这都是后缀自动机模板题）。

这对应我代码里面clear、newnode、insert、getsize。

接下来我们思考怎么用后缀树求出 第k小子串。

后缀树的本质是后缀trie树的虚树，即只保留叶子节点和他们两两之间的LCA得到的树，所以后缀trie有的性质他也会有类似的性质。

后缀trie树从跟往下走可以得到每一个后缀的所有前缀（即所有子串），我们从a到z地进行dfs，先遇到的点的字典序越小，后遇到的字典序越大。

后缀树只不过压缩了后缀trie树，有一些子串的结尾在边里面，我们从a到z地进行dfs，依旧有同样的性质，而且同一条边内的子串越长越大，大于靠近根的点表示的子串，小于远离根的点表示的子串。

所以我们记录一个全局的rank，写一个dfs就好了。

代码里的lenreal是求当前边的实际长度，因为末尾边的长度是inf，要用$n-start[x]$来代替，因为多插入了一个字符，其实n比实际长度多1，刚好还可以去掉
终止符的影响。

这里再具体解释一下dfs中几个步骤的意思。首先mode是题干里面的t。

之后rank是目前还剩下的排名数（要全局变量，不能回溯）。

nowlen是指当前走到的这条边上有多少个子串，$t=1$的时候有$len*size[to], t=0$的时候只有$len$个（后缀树性质同一条边上子串出现次数一样）

如果小于等于的话说明就在这条边结尾了，否则rank减去这条边之后深入。

注意不能整除的情况end1还得$+1,mode=0$的话直接$end=rank$。

最后输出答案：从根到now号点的路径以及当前边上到end位置构成的子串。

记录depth方便直接获得now到根的路径。

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#define N 1000001
using namespace std;
char s1[N];int n1,t1,k,inf=0x3f3f3f3f;
struct SuffixTree{
    int rank,dep[N],s[N],len[N],start[N],size[N],ch[N][27],link[N],now,tot,rem,n;
    inline void clear(){now=tot=1;rem=n=0;len[0]=inf;memset(size,0,sizeof(size));}
    inline int newnode(int st,int le){link[++tot]=1;start[tot]=st;len[tot]=le;return tot;}
    inline void insert(int x){
       s[++n]=x;rem++;int last=1;
       while(rem!=0){
	   	    while(rem>len[ch[now][s[n-rem+1]]])rem-=len[now=ch[now][s[n-rem+1]]];
   		    int &v=ch[now][s[n-rem+1]],c=s[start[v]+rem-1];
       		if(!v||x==c){
           		link[last]=now;last=now;
           		if(!v)v=newnode(n,inf);
           		else break;
           	}else{
           		int u=newnode(start[v],rem-1);
           		ch[u][c]=v;ch[u][x]=newnode(n,inf);
                start[v]+=rem-1;len[v]-=rem-1;
				link[last]=v=u;last=u;
			}if(now==1)rem--;else now=link[now];
	   }
	}
	inline int getsize(int now,int depth){
		dep[now]=depth;
	    if(depth>=inf)return size[now]=1;
	    for(int i=0;i<=26;i++)
		    if(ch[now][i])size[now]+=getsize(ch[now][i],depth+len[ch[now][i]]); 
		return size[now];
	}
	inline int lenreal(int to){
	    if(len[to]<=n)return len[to];
	    else return n-start[to];
	}
	inline void dfs(int now,int mode){
	    if(dep[now]>=inf)return ;
	    for(int i=0;i<=25;i++){
	    	if(!ch[now][i])continue;
	    	int to=ch[now][i],nowlen=lenreal(to)*((mode==0)?1:size[to]);
	        if(rank<=nowlen){
				int end1=rank/size[to];
				if(rank%size[to]!=0)end1++;
				if(mode==0)end1=rank;
				for(int j=start[to]-dep[now];j<=start[to]+end1-1;j++)
					printf("%c",char(s[j]+'a'));
				exit(0);
	        }
	        else rank-=nowlen,dfs(to,mode);
	    }
	}
}t;
int main()
{
	t.clear();
	scanf(" %s",s1+1);n1=strlen(s1+1);
	scanf("%d%d",&t1,&k);
	for(int i=1;i<=n1;i++)t.insert(s1[i]-'a');
	t.insert(26);t.getsize(1,0);
	t.rank=k;t.dfs(1,t1);
	cout<<-1<<endl;
	return 0;
}
```

---

## 作者：hehelego (赞：8)

qwq,萌新菠菜来扔代码了....先扔代码...后面讲解.   

~~对没有注释因为后面讲解太详细了用不上注释了/cy~~

本文中使用的各种符号可能与某毛子讲sam的blog不太一样...是APIO2018上神仙张云帆讲SAM时用的课件里的那种...~~我这么菜当然没有去APIO2018了...~~

**由于spinach非常菜...本文中可能出现各种错误和奇怪的东西,如果您发现请及时luogu私信提醒我.**~~我还没AFO..还会经常上LGOJ~~
 
```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <string>
#include <vector>
using namespace std;
const int N=1000000+10;
char str[N],ret[N];
int T,k,pos;

struct Node{
	int link,tr[26],len,cnt; // cnt[q]= |R_q|
	Node(int l=0){ link=0;cnt=1;len=l; fill(tr,tr+26,0); } 
}t[N];int cnt,last,root;
inline int newnode(int len){ t[++cnt]=Node(len); return cnt; }
inline int newnode(int old,int len){ t[++cnt]=t[old]; t[cnt].cnt=0;t[cnt].len=len; return cnt; }
inline void init(){ cnt=0; root=last=newnode(0); }
void append(int c){
	int np=newnode(t[last].len+1),p=last;
	last=np;
	while(p&&t[p].tr[c]==0){ t[p].tr[c]=np; p=t[p].link; }
	if(p==0){ t[np].link=root; return ; }
	int q=t[p].tr[c];
	if(t[q].len==t[p].len+1) t[np].link=q;
	else{
		int nq=newnode(q,t[p].len+1);
		t[q].link=t[np].link=nq;
		while(p&&t[p].tr[c]==q){ t[p].tr[c]=nq; p=t[p].link; }
	}
}
int vis[N];
long long dp[N];
long long f(int q){
	if(vis[q]) return dp[q];
	dp[q]=T?t[q].cnt:1;
	for(int v:t[q].tr)
		if(v) dp[q]+=f(v);
	vis[q]=1;return dp[q];
}
vector<int> son[N];
int dfs(int q){
	for(auto v:son[q])
		t[q].cnt+=dfs(v);
	return t[q].cnt;
}
void calc(){
	for(int i=1;i<=cnt;i++)
		son[t[i].link].push_back(i);
	dfs(root);
}

int main(){
	scanf("%s %d %d",str,&T,&k);
	init();
	for(char c:str)
		if(c) append(c-'a');
		else break;
	calc(); f(root);
	dp[root]-=1;
	
	if(k>dp[root]){ puts("-1"); return 0; }
	int q=root;
	while(k>0){
		for(int i=0;i<26;i++){
			int v=t[q].tr[i];
			if(k>dp[v]) k-=dp[v];
			else{
				q=v;
				if(T==0) k--;
				else k-=t[q].cnt;
				ret[pos++]=i+'a';
				break;
			}
		}
	}
	puts(ret);
	return 0;
}

```
---

### case:T=0
即本质不同的k小子串...SAM是个DAG...确实不太容易秒懂...  
我们考虑一个简单的问题.一个**外向树上的kth'路径'**....  

>SAM中的不同以qs为起点的路径即为所有本质不同子串..这样一个简单为题和原问题还是有很大相似性,想到先考虑这个简化问题也是很正常的~~看错也是合理合法~~*

> 这好做啊,不就是bst kth拓展成trie kth了嘛.   然后子树size(路径计数)还是$size(u)=\sum_{(u,v)\in E}(size(v))+1$.  做完了 

不存在的好吧...~~真那么简单写他干啥...~~这里考虑跳过一个儿子不进入他所在的子树,的确还是一样的.但是进入某个儿子的时候.其实我们已经计入了这一步走的路径,所以得再$k--$

诶解决了对吧....这个东西拓展到DAG上面(当然需要只有一个入度为0的点...)仍然是正确的...~~证明留作习题请读者自行证明~~

实际实现的话就是DAG路径计数.不过的话..qs处这个式子不能+1...那对应的是空串.

#### 实际意义理解T=0的玩法
我们上面的做法看起来是考虑了 **从q开始的路径计数**,但是在SAM上面**只能是qs开始的路径对应本质不同子串**.所以实际上是这样:
  
设当前走过的路径是字符串$T$,所在状态为$q=tr(qs,T)$.  
- 通过比较$size[tr(q,c)]$和$k$,跳过了$c$这个转移边,其实是跳过了所有形如$T+P$,$P$是以$q$为起点的路径上的字符连成的串.
而这些串有多少呢?是$size[tr(q,c)]$因为路径和子串(本质不同的)是唯一对应的,而这个路径计数就是我们之前定义的$size$~~见上文关于外向树kth路径部分~~..当然这里叫$size$不合适..因为其实是DAG路径计数...

- 将要走$tr(q,c)$我们应当考虑了$T+c$这个子串.这个子串在之前显然从未出现过~~废话一一对应的~~.因此我们$k--$就很正常了.
  
---
  
### T=1的玩法.qwq
我们这时要考虑所有子串(包含了相等的子串)..怎么做呢?.....   
...  
...  
...  
还是一样的.若$q=tr(qs,T)$.$T$的出现次数是$|R_q|$...就是parent树上$q$子树里面的后缀状态数量...就完了..至于这个$|R_q|$咋求...我只能说见LGOJ板子题题解区...  
> 新建节点标记cnt=1,复制节点标记cnt=0,在parent树上自下而上计算即可*...正确性的话...~~懒得解释~~  

对于路径计数我们也稍作修改.改为$f(q)=(\sum_{(u,v)\in E}f(v))+(malen(q)-maxlen(par(q))$.就是加合法区间长度...这样考虑跳过后继节点的实际意义就变成了$T$拼接后得到$T+P$的出现次数啦..  
然后考虑一下走的转移$tr(q,c)$.我们走过了$T+C$这个子串.他的出现此次数当然是$|R_tr(q,c)|$啦  

---
  
至此我们已经通过分析SAM的各种性质,得到了了一个靠谱的算法了(我大概是说正确性..),复杂度也很好,是O(Len(S))的...毕竟最多跑遍SAM上的状态.   

代码细节见上.    
感谢 @longyun 指出了代码中的一个错误~~并用长度为3的字符串叉掉了程序~~,BTW提交本题解前已经修正过那个问题了.
    
    

---


~~以下是吐槽...您可以选择性忽略掉他们~~

- ~~太困了不讲了...GG..~~  

- ~~最近没有rated比赛...我之前爆了一次零...然后社区还周周掉...我这啥时候能上主页啊QAQ~~

- ~~都去WC了...果然还是我太菜了吧~~

继续努力鸭,我们NOI2019见

---

## 作者：wwlw (赞：6)

[Link](https://www.luogu.org/problemnew/show/P3975)

----------------
    很经典的一道后缀自动机裸题

我们首先不考虑题目中的两种情况，只考虑如何输出第k大的字串。很显然，有一个性质，**首位字符越大，字串排名越靠后**，我们可以考虑一个字符一个字符地去枚举（在后缀自动机上跑，字符必须存在），若第k大的子串是以当前字符开头的，那么就往下走，否则就继续枚举下一个字符，再减去以这个字符开头的子串个数。也就是说，我们现在的问题变成了统计以后缀自动机上某一个节点开头的子串的个数，这个问题就很简单了。

###先说T=0
我们回归right集合的本质，它表示的是结束位置相同的子串集合，那么right集合的大小就表示当前结束位置相同的子串的个数，等价于当前已经匹配到的字符串的出现次数。因为相同子串只算一次，所以直接把所有的right集合大小赋值为1即可。

###T=1
同T=0，直接建出Parent树，在树上dfs一遍求出所有right集合大小（当然还可以倒序for一遍，因为是一棵树，不会有后效性）

但求出了right集合大小还是不够的，我们需要考虑另外一个数组sum，表示的是right集合在后缀自动机意义下的前缀和，sum[u]就表示以一个后缀自动机上，编号为u的节点作为前缀的子串个数（同文章开头待求的值）。因为后缀自动机建出来是一个DAG，所以可以使用拓扑排序（本人用的是记忆化深搜）

但这样似乎会比其他几位dalao用的基排会慢一些（可能是递归的原因）

还是见代码吧（里面有注释）
```cpp
#include<stdio.h>
#include<string.h>
#define rint register int 
#define N 2000007

template<class T>
inline void read(T &x){
    x=0;char c=getchar();T flag=1;
    while(c<'0'||c>'9'){if(c=='-')flag=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+c-48;c=getchar();}
    x*=flag;
}

struct E{
    int next,to;
}e[N];
struct Node{//SAM 
    int c[27],len,par;
}nd[N];

char s[N];
int n,tot=1,root=1,last=1,head[N],cnt=0,opt;
long long right[N],sum[N],rk;

inline int max(int x,int y){return x>y? x:y;}
inline void add(int id,int to){
    e[++cnt]=(E){head[id],to};
    head[id]=cnt;
}
inline void insert(int w){
    int tmp=last,X=last=++tot;right[tot]=1;
    nd[X].len=nd[tmp].len+1;
    for(;tmp&&!nd[tmp].c[w];tmp=nd[tmp].par) nd[tmp].c[w]=X;
    if(!tmp) nd[X].par=root;
    else{
        int B=nd[tmp].c[w];
        if(nd[B].len==nd[tmp].len+1) nd[X].par=B;
        else{
            int nb=++tot;
            nd[nb]=nd[B];
            nd[B].par=nd[X].par=nb;
            nd[nb].len=nd[tmp].len+1;
            for(;tmp&&nd[tmp].c[w]==B;tmp=nd[tmp].par) nd[tmp].c[w]=nb;
        }
    }
}
void dfs(int u){
	if(!opt) right[u]=1;//若T=0，right赋为1 
    for(int i=head[u];i;i=e[i].next){
        int v=e[i].to;
        dfs(v);
		if(opt) right[u]+=right[v];//否则就问子树里right的和 
    }
}
int dfs_(int u){
	if(sum[u]!=-1) return sum[u];
	sum[u]=right[u];
	for(int i=0;i<26;i++)
		if(nd[u].c[i]) sum[u]+=dfs_(nd[u].c[i]);
	return sum[u];
}
void print(int u,long long k){
	if(k<=right[u]) return;
    k-=right[u]; //排名大于当前字符串的个数，说明还没匹配完，应该减去 
    for(int i=0;i<26;i++)//枚举每个字符 
    	if(nd[u].c[i]){//若字符存在 
    		int v=nd[u].c[i];
	        if(k>sum[v]){//不是以当前字符开头 
				k-=sum[v]; 
				continue;
			}
	        printf("%c",i+'a');//匹配到 
			print(v,k);//匹配下一位 
			return;
    	}
}
int main(){
    scanf("%s",s);
    read(opt),read(rk);
    n=strlen(s);
    memset(sum,-1,sizeof(sum));
    for(rint i=0;i<n;++i) insert(s[i]-'a');
    for(rint i=2;i<=tot;++i) add(nd[i].par,i);//建Parent树 
    dfs(1);//求right集合大小 
	right[1]=0;
	dfs_(1);//求前缀和（注意是在后缀自动机上） 
	if(sum[1]<rk) printf("-1");//如果子串总个数小于需要查的排名，则输出无解 
	else print(1,rk);//输出排名为rk的字符串 
}
```

---

## 作者：Adove (赞：5)

我们先求出该字符串的$SA$和$Ht$

然后分类讨论

$T=0$时，每次去掉$Ht$往后扫就行

$T=1$时，我们考虑$lcp$对答案的影响

既然用到$lcp$，那就要用$ST$表维护

左端点固定时，随右端点的增大，区间$\min$单调不升

我们就可以用二分+限制右端点的方式统计某个后缀的前缀的贡献

循环遍历每个后缀时，由于$Ht$部分已经统计过对答案的贡献，就不用再计算了，从$Ht+1$的位置继续向后统计即可

```cpp
#include"cstdio"
#include"cstring"
#include"iostream"
#include"algorithm"
using namespace std;

const int MAXN=5e5+5;

int ln,maxn,p,t;
int SA[MAXN],id[MAXN],rnk[MAXN],bnk[MAXN],Ht[MAXN];
char ch[MAXN];
int ST[19][MAXN],lg[MAXN];

void shel()
{
	for(int i=1;i<=ln;++i) ++bnk[rnk[id[i]]];
	for(int i=1;i<=maxn;++i) bnk[i]+=bnk[i-1];
	for(int i=1;i<=ln;++i) SA[++bnk[rnk[id[i]]-1]]=id[i];
	for(int i=0;i<=maxn;++i) bnk[i]=0;
	return;
}

void GetSA()
{
	for(int i=1;i<=ln;++i) rnk[i]=ch[i],id[i]=i,maxn=max(maxn,rnk[i]);
	shel();
	for(int k=1;k<ln;k<<=1){
		for(int i=1;i<=k;++i) id[i]=ln-k+i;
		int ct=k;
		for(int i=1;i<=ln;++i) if(SA[i]>k) id[++ct]=SA[i]-k;
		shel();swap(id,rnk);rnk[SA[1]]=1;
		for(int i=2;i<=ln;++i) rnk[SA[i]]=(id[SA[i]]==id[SA[i-1]]&&id[SA[i]+k]==id[SA[i-1]+k])?rnk[SA[i-1]]:rnk[SA[i-1]]+1;
		if(rnk[SA[ln]]==ln) return;
		maxn=rnk[SA[ln]];
	}return;
}

void GetHt()
{
	int k=0;
	for(int i=1;i<=ln;++i){
		if(rnk[i]==1) continue;
		if(k) --k;
		int ct=SA[rnk[i]-1];
		while(ct+k<=ln&&i+k<=ln&&ch[i+k]==ch[ct+k]) ++k;
		Ht[rnk[i]]=k;
	}return;
}

int Getmi(int l,int r){int tmp=lg[r-l+1];return min(ST[tmp][l+(1<<tmp)-1],ST[tmp][r]);}

void slv1()
{
	for(int i=1;i<=ln;++i) lg[i]=i>>lg[i-1]+1?lg[i-1]+1:lg[i-1];
	for(int i=1;i<=ln;++i) ST[0][i]=Ht[i];
	for(int j=1;j<=lg[ln];++j){
		int tmp=1<<j-1;
		for(int i=tmp<<1;i<=ln;++i){
			ST[j][i]=min(ST[j-1][i],ST[j-1][i-tmp]);
		}
	}for(int i=1;i<=ln;++i){
		int tmp=SA[i]+Ht[i];
		int ct=ln;
		while(1){
			if(tmp>ln) break;
			if(ct==i){
				if(t>ln-tmp+1){t-=ln-tmp+1;break;}
				for(int j=SA[i];j<=tmp+t-1;++j) putchar(ch[j]);
				return;
			}int l=i,r=ct;
			while(l<r){
				int mid=l+r+1>>1;
				if(Getmi(i+1,mid)>=tmp-SA[i]+1) l=mid;
				else r=mid-1;
			}ct=r;
			if(t>r-i+1) t-=r-i+1;
			else{
				for(int j=SA[i];j<=tmp;++j) putchar(ch[j]);
				return;
			}++tmp;
		}
	}puts("-1");
	return;
}

void slv2()
{
	int ct=1;
	while(t>ln-SA[ct]-Ht[ct]+1) t-=ln-SA[ct]-Ht[ct]+1,++ct;
	if(ct>ln){puts("-1");return;}
	for(int i=SA[ct];i<=SA[ct]+t+Ht[ct]-1;++i) putchar(ch[i]);
	puts("");
	return;
}

int main()
{
	scanf("%s",ch+1);ln=strlen(ch+1);
	GetSA();GetHt();scanf("%d%d",&p,&t);
	p?slv1():slv2();
	return 0;
}
```



---

## 作者：x7103 (赞：3)

[蒟蒻的blog](https://blog.csdn.net/m0_46374167/article/details/114711869)
## Solution
 - 本题解中字符串的先后均按后缀排序顺序的先后。
 - 由于 $t\in\{0,1\}$，考虑从 $t$ 入手。
 - 当 $t=0$ 时，显然是经典的后缀数组问题，可以直接求解。
 - 当 $t=1$ 时，我们按照 $t=0$ 的方法求，会有一个思路：只要求出满足 $\sum_{i=1}^{pos-1}{n+1-sa[i]}\le k$ 的最后一个 $pos$ 就是答案。
 - 但实际上这个算法有一些问题，我们按照上面求出的第 $k$ 小的字符串实际上会比实际答案大，因为在这个串后仍存在与这个串的公共前缀前缀可以计入答案，实际上这个串的排名是
$$rank=\sum_{i=1}^{pos-1}{n+1-sa[i]}+len+\sum_{i=pos+1}^{n}{\min(len,\min_{j=pos+1}^{i}{\{height[j]}\})}$$
而且我们会发现一个单调性：对于不重复子串排名的单调递增，在重复子串中的排名也必然是单调递增的。
 - 考虑**二分**。
每次二分所有不重复的子串中排名为 $mid$ 的字符串，判断是否 $rank\le k$，其中由于从 $pos+1$ 枚举到 $n$，可以直接在向后遍历的过程中维护 $height$ 的最小值。
单次检验时间复杂度 $O(n)$，总体时间复杂度为 $O(n\log n+n\log k)$
## Code
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
typedef long long LL;
const int maxn=500010,INF=0x3fffffff;
template<class T>inline T Min(const T &a,const T &b){return a<b?a:b;}
char s[maxn];
int sa[maxn],x[maxn],y[maxn],c[maxn],n,m;
int rk[maxn],height[maxn],t,k;
inline void get_sa(){
	for(int i=1;i<=n;++i)++c[x[i]=s[i]];
	for(int i=2;i<=m;++i)c[i]+=c[i-1];
	for(int i=n;i;--i)sa[c[x[i]]--]=i;
	for(int k=1;k<=n;k<<=1){
		int num=0;
		for(int i=n-k+1;i<=n;++i)y[++num]=i;
		for(int i=1;i<=n;++i)
			if(sa[i]>k)y[++num]=sa[i]-k;
		for(int i=1;i<=m;++i)c[i]=0;
		for(int i=1;i<=n;++i)++c[x[i]];
		for(int i=2;i<=m;++i)c[i]+=c[i-1];
		for(int i=n;i;--i)sa[c[x[y[i]]]--]=y[i],y[i]=0;
		swap(x,y);
		x[sa[1]]=1;num=1;
		for(int i=2;i<=n;++i)
			x[sa[i]]=(y[sa[i]]==y[sa[i-1]]&&y[sa[i]+k]==y[sa[i-1]+k])?num:++num;
		if(num==n)break;
		m=num;
	}
}
inline void get_height(){
	for(int i=1;i<=n;++i)rk[sa[i]]=i;
	for(int i=1,k=0;i<=n;++i){
		if(rk[i]==1)continue;
		if(k)--k;
		int j=sa[rk[i]-1];
		while(i+k<=n&&j+k<=n&&s[i+k]==s[j+k])++k;
		height[rk[i]]=k;
	}
}
inline void find_kth(LL k,int &pos,int &len){
	LL cnt=0;
	for(int i=1;i<=n;++i){
		if(cnt+n+1-sa[i]-height[i]>=k){
			pos=i;
			len=k-cnt+height[i];
			return;
		}
		else cnt+=n+1-sa[i]-height[i];
	}
}
inline bool check(LL mid){
	int pos,len,minh=INF;
	LL cnt=0;
	find_kth(mid,pos,len);
	for(int i=1;i<pos;++i)
		cnt+=n+1-sa[i];
	for(int i=pos+1;i<=n;++i){
		minh=Min(minh,height[i]);
		cnt+=Min(len,minh);
	}
	if(len+cnt<=k)return true;
	else return false;
}
int main(){
	scanf("%s",s+1);
	n=strlen(s+1);m='z';
	scanf("%d%d",&t,&k);
	get_sa();get_height();
	if(t==0){
		LL sum=0;
		for(int i=1;i<=n;++i)
			sum+=n+1-sa[i]-height[i];
		if(sum<k){
			puts("-1");
			return 0;
		}
		int pos,len;
		find_kth(k,pos,len);
		for(int i=0;i<len;++i)
			putchar(s[sa[pos]+i]);
	}
	else{
		if(1ll*n*(n+1)/2<k){
			puts("-1");
			return 0;
		}
		LL l=1,r=k;
		while(l<r){
			int mid=(l+r+1)>>1;
			if(check(mid))l=mid;
			else r=mid-1;
		}
		int pos,len;
		find_kth(l,pos,len);
		for(int i=0;i<len;++i)
			putchar(s[sa[pos]+i]);
	}
	return 0;
}
```

---

## 作者：Lskkkno1 (赞：2)

- [[TJOI2015] 弦论](https://www.luogu.com.cn/problem/P3975)

### 题目描述

给定一个字符串。

求这个字符串的字典序第 $k$ 大的本质不同子串（不同位置只算一次）。

求这个字符串的字典序第 $k$ 大的子串（不同位置算多次）。

### 正解

建出后缀自动机，把每一个点往后走有多少种方案求出来，就可以 $O(n)$ 定位字符串了。

一个点往后走的方案等于所有**后继节点**（不仅仅是直接后继，还包括可以走到的节点）所代表的字符串的方案（或者说是出现次数）求和。

一个节点所代表的字符串的方案分下面两类讨论：

#### $\texttt{t = 0}$，出现多次算一次

在后缀自动机上面移动，走到一个字符串的方案唯一。

也就是说，所有移动的方案本质不同。

那么一个节点方案就是 $1$。

#### $\texttt{t = 1}$，出现多次算多次

自动机上一个点的方案设为它的出现次数（$endpos$ 集合大小）。

一个点 $endpos$ 集合大小就是对其 $parent$ 树的子树求个和（先把原字符串结尾位置对应的节点初始化为 $1$）。


### 代码

```cpp
/*
    t = 0, 出现多次算一次
    t = 1, 出现多次算多次
*/
#include <bits/stdc++.h>

using namespace std;

const int N = 5e5 + 5;

int n, k, t;
int pos[N];
char s[N];

int last, vcnt;
int deg[N << 1];

struct node {
    int link, len, siz;
    int to[26];
} a[N << 1];

void extend(int c) {
    int p = last, cur = ++vcnt;
    a[cur].len = a[last].len + 1;
    while(~p && !a[p].to[c]) {
        a[p].to[c] = cur;
        p = a[p].link;
    }
    if(p == -1) {
        a[cur].link = 0;
    } else {
        int q = a[p].to[c];
        if(a[q].len == a[p].len + 1) {
            a[cur].link = q;
        } else {
            int clone = ++vcnt;
            a[clone] = a[q];
            a[clone].len = a[p].len + 1;
            while(~p && a[p].to[c] == q) {
                a[p].to[c] = clone;
                p = a[p].link;
            }
            a[q].link = a[cur].link = clone;
        }
    }
    last = cur;
}

long long f[N << 1];
long long getFunc(int u) {
    if(f[u] != -1) return f[u];
    long long &F = f[u]; F = a[u].siz;
    for(int c = 0, v; c < 26; ++c) {
        v = a[u].to[c];
        if(v == 0) continue;
        F += getFunc(v);
    }
    return F;
}
void dfs(int u, int rem) {
    rem -= a[u].siz;
    if(rem <= 0) return void();
    for(int c = 0, v; c < 26; ++c) {
        v = a[u].to[c];
        if(v == 0) continue;
        if(rem > f[v]) {
            rem -= f[v];
        } else {
            putchar('a' + c);
            dfs(v, rem);
            break;
        }
    }
}

int main() {
    scanf("%s %d %d", s + 1, &t, &k);
    n = strlen(s + 1);
    a[last = 0].link = -1;
    for(int i = 1; i <= n; ++i) {
        extend(s[i] - 'a');
        pos[i] = last;
    }
    if(!t) {
        for(int i = 1; i <= vcnt; ++i)
            a[i].siz = 1;
    } else {
        for(int i = 1; i <= n; ++i)
            ++a[pos[i]].siz;
        for(int i = 1; i <= vcnt; ++i)
            ++deg[a[i].link];
        queue<int> Q;
        for(int i = 1; i <= vcnt; ++i)
            if(deg[i] == 0)
                Q.push(i);
        while(!Q.empty()) {
            int u = Q.front(), v = a[u].link; Q.pop();
            if(v == 0) continue;
            a[v].siz += a[u].siz;
            if(--deg[v] == 0) Q.push(v);
        }
    }

    memset(f, -1, sizeof f);
    getFunc(0);
    
    if(f[0] < k) {
        puts("-1");
    } else {
        dfs(0, k);
        putchar('\n');
    }
    return 0;
}
```

---

## 作者：MCAdam (赞：2)

[P3975 [TJOI2015]弦论](https://www.luogu.com.cn/problem/P3975)

$t=0$的情况就是就是求本质不同的子串的个数

从头枚举，如果$k>len-SA[i]+1-height[i]$就减掉，不然就退出输出

注意最后输出要加上$height[pos]$，因为前面时候减掉了

然后$t=1$的情况呢？

我们可以二分一个本质不同的子串，然后统计出比它小的子串的个数。一个第$k$个本质不同的子串可以用上面的方法求出来，那怎么统计比它小的串串的个数呢？

注意我们这里二分出来的第$k$个本质不同的子串是相同子串中的第一个。我们记这个二分出来的串串，是在第$pos$个后缀，还有$w$长度。那么$<pos$的后缀的子串都是比这个串串小的。对于$pos$位置，及$pos$位置以后的，只有公共前缀才有可能满足要求，总的来说就是：

$\displaystyle\sum_{i=1}^{pos-1}len-SA[i]+1+\sum_{i=pos}^{len}min(LCP(x,i),w)$

注意这里输出时，不用加上$height$，因为我们二分出的是相同的子串中的第一个，前面并没有减掉

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#include <cmath>
#define ll long long
using namespace std;
const int N=5e5+10,M=30;
char s[N];
int len,size=26;
int SA[N],rk[N],tmp[N],cnt[M],height[N],f[N][21];
inline void binsort()
{
	for(register int i=0;i<=size;i++) cnt[i]=0;
	for(register int i=1;i<=len;i++) cnt[rk[i]]++;
	for(register int i=1;i<=size;i++) cnt[i]+=cnt[i-1];
	for(register int i=len;i>=1;i--) SA[cnt[rk[tmp[i]]]--]=tmp[i];
}
inline void get_SA()
{
	for(register int i=1;i<=len;i++)
		rk[i]=s[i]-'a'+1,tmp[i]=i;
	binsort();
	for(register int l=1;l<=len;l<<=1)
	{
		int p=0;
		for(register int i=len-l+1;i<=len;i++)
			tmp[++p]=i;
		for(register int i=1;i<=len;i++)
			if(SA[i]>l) tmp[++p]=SA[i]-l;
		binsort(),swap(rk,tmp);
		rk[SA[1]]=p=1;
		for(register int i=2;i<=len;i++)
			rk[SA[i]]=(tmp[SA[i]]==tmp[SA[i-1]]&&tmp[SA[i]+l]==tmp[SA[i-1]+l])?p:++p;
		if(p==len) break; size=p;
	}
}
inline void get_height()
{
	int pre=1;
	for(register int i=1;i<=len;i++)
	{
		if(pre) pre--;
		while(s[i+pre]==s[SA[rk[i]-1]+pre]) pre++;
		height[rk[i]]=pre;
	}
	for(register int i=1;i<=len;i++)
		f[i][0]=height[i];
	for(register int l=1;l<=log2(len);l++)
		for(register int i=1;i<=len-(1<<l)+1;i++)
			f[i][l]=min(f[i][l-1],f[i+(1<<(l-1))][l-1]);
}
inline void get_kth(int k,int &pos,int &w)//找到第k个本质不同的子串 
{
	pos=0;
	for(register int i=1;i<=len;i++)
	{
		int val=len-SA[i]+1-height[i];
		if(k>val) k-=val;
		else{ pos=i,w=k; break; }
	}
}
inline int query(int l,int r)
{
	if(l!=r) l++;
	else return len-SA[l]+1;//注意特判同一个后缀的情况 
	int k=log2(r-l+1);
	return min(f[l][k],f[r-(1<<k)+1][k]);
}
int main()
{
	int si,k,pos,w;
	scanf("%s",s+1);
	scanf("%d%d",&si,&k);
	len=strlen(s+1);
	get_SA(),get_height();
	if(si)
	{
		if(k>(ll)len*(len+1)/2) printf("-1\n");
		else
		{
			int low=0,high=k+1;
			while(low+1<high)
			{
				int mid=(low+high)/2,ans=0;
				get_kth(mid,pos,w);
				for(int i=1;i<pos;i++)//前面的后缀都比它小 
					ans+=len-SA[i]+1;
				for(int i=pos;i<=len;i++)//后面的取公共前缀 
					ans+=min(w,query(pos,i));
				if(ans>=k) high=mid;
				else low=mid;
			}
			get_kth(high,pos,w);
			for(register int i=SA[pos];i<=SA[pos]+w-1;i++) //注意这里输出不用加上height 
				printf("%c",s[i]);
		}
	}
	else
	{
		get_kth(k,pos,w);
		if(pos) 
		{
			for(register int i=SA[pos];i<=SA[pos]+w+height[pos]-1;i++)//注意这里要加上height 
				printf("%c",s[i]);
		}
		else printf("-1\n");
	}
	return 0;
}
```

---

## 作者：leozhang (赞：2)

我们分成两种情况来分析这个问题：t=0和t=1

t=1时，每一个子串出现的次数就是他在parent树上所在子树内前缀节点的个数，这一点我们已经说的很清楚了

利用SAM有向无环的性质，我们可以在parent树上统计完之后在后缀自动机上dfs，对每个点累计以他为开头的所有子串的总数

然后在查询的时候直接在SAM上跑，如果以当前点为开头的子串总数小于k，则将k减去这个总数后向他的兄弟节点查询，否则输出这个节点的字符，然后向他的子节点上查询，直到k小于当前点对应子串出现次数即说明输出的答案已满足要求

t=0时，由于只区分字典序，所以每一个节点都是一个子串，字典序相同的子串不会被重复统计（这利用了后缀自动机可以不重不漏地识别原串的每个子串的优秀性质）

剩余操作同上：在后缀自动机上dfs，然后再查询

```cpp
#include <cstdio>
#include <cmath>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#include <queue>
#include <stack>
using namespace std;
char ch[500005];
int T,k,n;
struct SAM
{
    int tranc[27];
    int endpos;
    int len;
    int pre;
}s[1000005];
struct Edge
{
    int next;
    int to;
}edge[1000005];
int head[1000005];
int val[1000005];
int sum[1000005];
int cnt=1;
int las,siz;
void init()
{
    memset(head,-1,sizeof(head));
    cnt=1;
}
void add(int l,int r)
{
    edge[cnt].next=head[l];
    edge[cnt].to=r;
    head[l]=cnt++;
}
void ins(int c)
{
    int nwp=++siz;
    s[nwp].len=s[las].len+1;
    s[nwp].endpos=1;
    int lsp;
    for(lsp=las;lsp&&!s[lsp].tranc[c];lsp=s[lsp].pre)s[lsp].tranc[c]=nwp;
    if(!lsp)
    {
        s[nwp].pre=1;
    }else
    {
        int lsq=s[lsp].tranc[c];
        if(s[lsq].len==s[lsp].len+1)
        {
            s[nwp].pre=lsq;
        }else
        {
            int nwq=++siz;
            s[nwq]=s[lsq];
            s[nwq].endpos=0;
            s[nwq].len=s[lsp].len+1;
            s[lsq].pre=s[nwp].pre=nwq;
            while(s[lsp].tranc[c]==lsq)
            {
                s[lsp].tranc[c]=nwq;
                lsp=s[lsp].pre;
            }
        }
    }
    las=nwp;
}
void buildtree()
{
    init();
    for(int i=2;i<=siz;i++)add(s[i].pre,i);
}
void dfs(int x)
{
    if(T)val[x]=s[x].endpos;
    else val[x]=1;
    for(int i=head[x];i!=-1;i=edge[i].next)
    {
        int to=edge[i].to;
        dfs(to);
        if(T)val[x]+=val[to];
    }
}
void redfs(int x)
{
    sum[x]=val[x];
    for(int i=1;i<=26;i++)
    {
        int to=s[x].tranc[i];
        if(!to)continue;
        if(!sum[to])redfs(to);
        sum[x]+=sum[to];
    }
}
void qdfs(int x)
{
    if(k<=val[x])return;
    k-=val[x];
    for(int i=1;i<=26;i++)
    {
        int to=s[x].tranc[i];
        if(!to)continue;
        if(k<=sum[to])
        {
            printf("%c",i+'a'-1);
            qdfs(to);
            return;
        }else k-=sum[to];
    }
}
int main()
{   
//  freopen("data.in","r",stdin);
    scanf("%s",ch+1);
    scanf("%d%d",&T,&k);
    n=strlen(ch+1);
    las=++siz;
    for(int i=1;i<=n;i++)ins(ch[i]-'a'+1);
    buildtree();
    dfs(1);
    val[1]=0;
    redfs(1);
    if(k>sum[1])printf("-1");
    else qdfs(1);
    printf("\n");
    return 0;
}

```


---

## 作者：crashed (赞：1)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.com.cn/problem/P3975)看题目。  
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;补习知识：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;既然可以求出原串中不同的子串的个数，那么我们同样可以求出含重复子串的个数，同样是$dp$：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$g(u)$：从$u$节点出发含重复的子串的数量。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;转移：  
$$g(u)=|end-pos(u)|+\sum_{(u,v)\in DAWG} g(v)$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为可以重复，所以对于一个子串，它的出现次数就是它的结尾的$end-pos$的大小。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正解部分，对于$t=0$的情况，就是一个模板题。对于$t=1$的情况，套用$t=0$的方法，这个时候我们改用$g$来确定该走哪一步。
# 代码
```cpp
#include <cstdio>
#include <cstring>

const int MAXN = 5e5 + 5;

template<typename _T>
void read( _T &x )
{
	x = 0; char s = getchar();int f = 1;
	while( s < '0' || '9' < s ) { f = 1; if( s == '-' ) f = -1; s = getchar(); }
	while( '0' <= s && s <= '9' ) { x = ( x << 3 ) + ( x << 1 ) + s - '0', s = getchar(); }
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ) { putchar( '-' ), x = -x; }
	if( 9 < x ) { write( x / 10 ); }
	putchar( x % 10 + '0' );
}

struct edge
{
	int to, nxt;
}Graph[MAXN << 1];

int f[MAXN << 1], g[MAXN << 1];
int cnt[MAXN];
int ep[MAXN << 1], seq[MAXN << 1], head[MAXN << 1];
int ch[MAXN << 1][26], fa[MAXN << 1], mx[MAXN << 1];
char A[MAXN];
int N, T, K, rt, lst, tot, ecnt;

void addEdge( const int from, const int to )
{
	ecnt ++;
	Graph[ecnt].to = to, Graph[ecnt].nxt = head[from];
	head[from] = ecnt;
}

void copy( const int a, const int b ) { fa[a] = fa[b], mx[a] = mx[b], memcpy( ch[a], ch[b], sizeof ch[b] ); }
void expand( const char c )
{
	int x = c - 'a', p = lst, cur = ++ tot; 
	mx[cur] = mx[p] + 1, lst = cur, ep[cur] = 1;
	while( p && ! ch[p][x] ) ch[p][x] = cur, p = fa[p];
	if( ! p ) { fa[cur] = rt; return ; }
	int q = ch[p][x];
	if( mx[q] == mx[p] + 1 ) { fa[cur] = q; return ; }
	int nq = ++ tot; copy( nq, q );
	mx[nq] = mx[p] + 1, fa[cur] = fa[q] = nq;
	while( p && ch[p][x] == q ) ch[p][x] = nq, p = fa[p];
}

void topo()
{
	for( int i = 1 ; i <= tot ; i ++ ) cnt[mx[i]] ++;
	for( int i = 1 ; i <= N ; i ++ ) cnt[i] += cnt[i - 1];
	for( int i = tot ; i ; i -- ) seq[cnt[mx[i]] --] = i;
}

void DFS( const int u )
{
	for( int i = head[u], v ; i ; i = Graph[i].nxt )
		DFS( v = Graph[i].to ), ep[u] += ep[v];
}

int main()
{
	scanf( "%s", A + 1 ); N = strlen( A + 1 );
	read( T ), read( K );
	rt = lst = ++ tot;
	for( int i = 1 ; i <= N ; i ++ ) 
		expand( A[i] );
	for( int i = 2 ; i <= tot ; i ++ ) addEdge( fa[i], i );
	DFS( 1 ), topo();
	for( int i = tot, u ; i ; i -- )
	{
		if( ( u = seq[i] ) > 1 ) { f[u] = 1, g[u] = ep[u]; }
		for( int j = 0 ; j < 26 ; j ++ )
			if( ch[u][j] ) f[u] += f[ch[u][j]], g[u] += g[ch[u][j]];
	}
	if( K > f[1] ) { write( -1 ); return 0; }
	if( T )
	{
		int p = rt, v;
		while( true )
		{
			for( int i = 0 ; i < 26 ; i ++ )
			{
				v = ch[p][i];
				if( K <= ep[v] ) { putchar( 'a' + i ), putchar( '\n' ); return 0; }
				else if( K <= g[v] ) { putchar( 'a' + i ), K -= ep[v], p = ch[p][i]; break; }
				K -= g[v];
			}
		}
		putchar( '\n' );
	}
	else
	{
		int p = rt, v;
		while( K )
		{
			for( int i = 0 ; i < 26 ; i ++ )
			{
				v = ch[p][i];
				if( f[v] >= K ) { p = ch[p][i], putchar( 'a' + i ), K --; break; }
				K -= f[v];
			}
		}
		putchar( '\n' );
	}
	return 0;
}
```

---


# [Code+#2] 火锅盛宴

## 题目背景

SkyDec 和 YJQQQAQ 都是 Yazid 的好朋友。他们都非常喜欢吃火锅。有一天，他们聚在一起，享受一场火锅盛宴。

## 题目描述

在这场火锅盛宴中，有一个麻辣浓汤锅底的火锅和 $n$ 种食物，每种食物数量都是无限的。我们用 $1$ 至 $n$ 将这些食材编号。

每种食物煮熟所需要的时间不同，第 $i$ 种食物煮熟需要 $s_i$ 单位时间。这表示如果你在第 $T$ 个时刻将一个食物 $i$ 下到火锅里，那么它会在第 $T+s_i$ 个时刻被煮熟，并且此后一直会延续被煮熟的状态，直到它被拿走为止。

Yazid 和 YJQQQAQ 的口味不同：YJQQQAQ 觉得所有食物的好吃程度都是相同的；而 Yazid 则觉得没有两种食材的好吃程度是相同的，并且，巧合的是，编号越小的食物 Yazid 越喜欢吃。可怜的 SkyDec 由于不能吃辣，所以只能帮 Yazid 和 YJQQQAQ 煮食物。

整个火锅盛宴持续 $10^9$ 单位时间。在整个盛宴中，三位好朋友除了谈笑风生之外，最重要的事当然就是吃东西了。在任意整数时刻，都有可能发生下列 $4$ 种事件中的任意一种，我们用 $0$ 至 $3$ 之间的整数 $op$ 描述事件类型：

- $0\ id$：表示 SkyDec 往火锅里下了一个编号为 $id$ 的食物。
- $1$：Yazid 在锅内搜寻熟了的且最喜欢吃的食物，并拿走一个这种食物。特别地，如果锅里没有熟了的食物，那么 Yazid 会很愤怒。
- $2\ id$：YJQQQAQ 在锅内搜寻编号为 $id$ 的食物：
   - 如果锅里不存在该种食物，则 YJQQQAQ 会很愤怒；
   - 如果锅里存在熟了的该食物，则 YJQQQAQ 会取走一个并食用；
   - 如果锅里只有未煮熟的该种食物，那么 YJQQQAQ 会希望知道最接近煮熟的该种食物（即锅内存在时间最长的该种食物）还需要多少时间被煮熟。
- $3\ l\ r$：馋涎欲滴的 SkyDec 想知道，锅里编号在 $[l,r]$ 之间的且熟了的食物总共有多少个。

## 说明/提示

对于所有数据，保证$ T\leq 4$，保证 $n\leq 100,000$，$Q\leq 500,000$，$1\leq s_i\leq 10^8$，$1\leq t\leq 10^9$，$op\in\{0, 1, 2, 3\}$，$1\leq id\leq n$，$1\leq l\leq r\leq n$。数据保证 $t$ 按输入顺序严格递增。

来自 CodePlus 2017 12 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。

Credit：idea/王聿中 命题/王聿中 验题/吕时清，杨景钦

Git Repo：https://git.thusaac.org/publish/CodePlus201712

感谢腾讯公司对此次比赛的支持。


## 样例 #1

### 输入

```
1
2
1 100
10
1 0 2
2 0 1
3 2 1
4 2 2
5 2 1
200 0 1
201 3 1 2
202 1
203 1
204 1```

### 输出

```
Succeeded!
97
YJQQQAQ is angry.
2
1
2
Yazid is angry.```

# 题解

## 作者：Areka6219 (赞：8)

### 题意

- 我们把食物分为两个集合，熟的为 $S_1$，不熟为 $S_2$。
- $Add_0$​​：在集合 $S_2$​​ 中加入一个元素，此元素在经过 $t_{id}$​​ 时间后会自动加入 $S_1$​​，且在 $S_2$​​ 中消失。
- $Ask_1$：询问 $S_1$ 中元素的最小编号，若 $S_1 = \varnothing$ ，则输出 `Yazid is angry.`。
- $Ask_2$：询问某个特定编号的食物存在于 $S_1$ 中，若存在，输出 `Succeeded! `，若不存在，则查询 $S_2$ 中是否存在该元素，若存在，输出该元素还需多长时间加入集合 $S_1$ 中，若 $S_2$ 中也不存在该元素，则输出 `YJQQQAQ is angry.`。
- $Ask_3$​：查询集合 $S_1$​ 中 $[l,r]$ 内共有多少元素。

### 分析

- 提供思路：树状数组+两个优先队列+一个双端队列（可能~~有点~~十分麻烦）。
- 首先针对 $Ask_3$ 我们自然可以想到树状数组。
- 接下来我们想如何维护 $Add_0$、$Ask_1$、$Ask_2$、$S_1$、$S_2$。
- 可以想到，用优先队列维护 $S_2$​，在每次查询前将队列中的元素放进 $S_1$​ 的优先队列。
- 这里的两个优先队列排序的关键字不同，$S_1$ 的优先队列，第一关键字为编号，因为已经成熟，$S_2$ 的优先队列第一关键字为成熟时间，因为我们要贪心的判断是否成熟
- 对于 $Add_0$ 我们直接模拟即可，用 `deque` 来维护编号的信息，并注意更新树状数组。
- 对于 $Ask_1$ 我们查询 $S_1$​ 所对应的优先队列是否为空，若不为空，输出队首即可。
- 对于 $Ask_2$​ 我们查询编号对应的 `deque` 是否为空，直接模拟即可，注意运用**懒惰删除法**更新优先队列（不懂的可以看 `Dijkstra` 的题解，[这边请](https://www.luogu.com.cn/problem/solution/P4779)）。
- 对于 $Ask_3$ 使用树状数组直接干碎即可。

### 吐槽

> 怎么会有卡空间这档子破事.jpg
>
> 原来是我写挂了.jpg
>
> 关于一个题交了4页这档子破事

### Code

```cpp
const int maxn = 1e5 + 1;

int n, tot, a[maxn];
bool vis[500001];

class Tree_Array {
    private:
        int t[maxn];
        
        inline int lowbit(int x) {
            return x & (-x);
        }
    
    public:
        
        inline void init() {
            memset(t, 0, sizeof(t));
        }

        inline void Add(int pos, int v) {
            while(pos <= n)
                t[pos] += v, pos += lowbit(pos);
        }

        inline int Ask(int pos) {
            int res = 0;
            while(pos)
                res += t[pos], pos -= lowbit(pos);
            return res;
        }
};

Tree_Array T;

class Node {
    public:
        int id, nid, tm;
        inline friend bool operator < (const Node &a, const Node &b) {
            if(a.id == b.id)
                return a.tm > b.tm;
            else
                return a.id > b.id;
        }
        Node() {}
        Node(int i, int i1, int t) : id(i), nid(i1), tm(t) {}
};

class Node1 {
    public:
        int id, nid, tm;
        inline friend bool operator < (const Node1 &a, const Node1 &b) {
            if(a.tm == b.tm)
                return a.id > b.id;
            else
                return a.tm > b.tm;
        }
        Node1() {}
        Node1(int i, int i1, int t) : id(i), nid(i1), tm(t) {}
};

class Node2 {
    public:
        int nid, tm;
        Node2() {}
        Node2(int i1, int t) : nid(i1), tm(t) {}
};

priority_queue <Node> Q1;
priority_queue <Node1> Q2;

deque <Node2> v[maxn];

inline void init() {
    tot = 0;
    memset(vis, 0, sizeof(vis));
    while(!Q1.empty())
        Q1.pop();
    while(!Q2.empty())
        Q2.pop();
    for(int i = 1; i < maxn; ++i)
    	while(!v[i].empty())
    		v[i].pop_front();
    T.init();
}
signed main() {
    int ss = read();
    while(ss--) {
        init();
        n = read();
        for(int i = 1; i <= n; ++i)
            a[i] = read();
        int Qs = read();
        for(int i = 1, id; i <= Qs; ++i) {
            int t = read(), opt = read();
            while(!Q2.empty() and Q2.top().tm <= t) {
                Node1 x = Q2.top();
                Q2.pop();
                if(vis[x.nid])
                    continue;
                Node pp;
                pp.id = x.id, pp.nid = x.nid, pp.tm = x.tm;
                Q1.push(pp);
                T.Add(x.id, 1);
            }

            if(opt == 0) {
                id = read();
                Q2.push(Node1(id, ++tot, a[id] + t));
                v[id].push_back(Node2(tot, a[id] + t));
            }

            if(opt == 1) {
                if(Q1.empty())
                    puts("Yazid is angry.");
                else {
                    Node x;
                    x.id = -1;
                    while(!Q1.empty()) {
                        x = Q1.top();
                        Q1.pop();
                        if(vis[x.nid])
                            continue;
                        break;
                    }
                    if(x.id == -1 or v[x.id].empty() or vis[x.nid])
                        puts("Yazid is angry.");
                    else {
                        T.Add(x.id, -1);
                        v[x.id].pop_front();
                        vis[x.nid] = true;
                        printf("%d\n", x.id);
                    }
                }
            }

            if(opt == 2) {
                id = read();
                if(v[id].empty())
                    puts("YJQQQAQ is angry.");
                else {
                    deque <Node2> :: iterator it = v[id].begin();
                    Node2 x = *it;
                    if(x.tm > t)
                        printf("%d\n", x.tm - t);
                    else {
                        vis[x.nid] = true;
                        T.Add(id, -1);
                        v[id].pop_front();
                        puts("Succeeded!");
                    }
                }
            }

            if(opt == 3) {
                int l = read(), r = read();
                printf("%d\n", T.Ask(r) - T.Ask(l - 1));
            }
        }
    }

	init();

    #ifndef ONLINE_JUDGE
        getchar();
    #endif
    return 0;
}
```



---

## 作者：first_fan (赞：4)

此题可以$\Large\text{线段树+优先队列}$解决。

首先看第一问，我们考虑开三个优先队列：

* $\sf {q1[i]}$，用于存储食物$\sf i$的成熟时间

* $\sf {q2[i]}$，用于存储成熟时间小于$\sf i$的食物

* 对每个食物开一个$\sf {e[i]}$，用于存储其成熟时间

接下来把线段树编号为i的位置自增1就好。

第二问，按照编号最小的顺序找成熟食品，这时候取出$\sf {q2[i]}$使用即可，修改更新线段树。

第三问，查找指定编号食物，直接查找$\sf {e[i]}$，不成熟输出距离成熟的时间，即$\sf \text{e[i]-当前时间}$。

第四问，查询区间内成熟食物个数，用线段树统计即可，上面每次取出操作时已经更新过，直接找就行了。

上代码(附注释)

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ls(x) (x<<1)
#define rs(x) (x<<1|1)
using namespace std;
int read()
{
	int num=0;
	int flg=1;
	char c=getchar();
	while(!isdigit(c))
	{
		if(c=='-')
		{
			flg=-1;
		}
		c=getchar();
	}
	while(isdigit(c))
	{
		num=(num<<1)+(num<<3)+(c^48);
		c=getchar();
	}
	return num*flg;
}
int seg[400002];//线段树
int n,qst;//食材个数，询问次数
int s[100005];//食材成熟所需时间
int rest[100005];

priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >q1;
priority_queue<int,vector<int>,greater<int> >q2,e[100005];
//q1,q2,e
void modify(int nd,int l,int r,int x,int y)
{
	seg[nd]+=y;
	if(l==r)
	{
		return;
	}
	int mid=(l+r)>>1;
	if(x<=mid)
	{
		modify(ls(nd),l,mid,x,y);
	}
	else
	{
		modify(rs(nd),mid+1,r,x,y);
	}
}//线段树修改
int query(int nd,int l,int r,int x,int y)
{
	if(l==x&&r==y)
	{
		return seg[nd];
	}
	int mid=(l+r)>>1;
	if(y<=mid)
	{
		return query(ls(nd),l,mid,x,y);
	}
	else if(x>mid)
	{
		return query(rs(nd),mid+1,r,x,y);
	}
	else
	{
		return query(ls(nd),l,mid,x,mid)+query(rs(nd),mid+1,r,mid+1,y);
	}
}//线段树求和
void solve()
{
	n=read();
	for (int i=1; i<=n; i++)
	{
		s[i]=read();
	}
	for (int i=1; i<=n; i++)
	{
		rest[i]=0;
	}
	for (int i=1; i<=400001; i++)
	{
		seg[i]=0;
	}
	while (!q1.empty())
	{
		q1.pop();
	}
	while (!q2.empty())
	{
		q2.pop();
	}
	for (int i=1; i<=n; i++)
	{
		while (!e[i].empty())
		{
			e[i].pop();
		}
	}//龟速清空
	qst=read();
	while (qst--)
	{
		int tim=read(),op=read();
		while (!q1.empty()&&q1.top().first<=tim)
		{
			q2.push(q1.top().second);
			modify(1,1,n,q1.top().second,1);
			q1.pop();
		}
		if(op==0)
		{
			int u=read();
			q1.push(make_pair(tim+s[u],u));
			e[u].push(tim+s[u]);
		}//问1
		else if(op==1)
		{
			while (!q2.empty()&&rest[q2.top()])
			{
				rest[q2.top()]--;
				q2.pop();
			}
			if(q2.empty())
			{
				printf("Yazid is angry.\n");
			}
			else
			{
				printf("%d\n",q2.top());
				modify(1,1,n,q2.top(),-1);
				e[q2.top()].pop();
				q2.pop();
			}
		}//问2
		else if(op==2)
		{
			int u=read();
			if(e[u].empty())
			{
				printf("YJQQQAQ is angry.\n");
			}
			else
			{
				if(e[u].top()<=tim)
				{
					printf("Succeeded!\n");
					modify(1,1,n,u,-1);
					rest[u]++;
					e[u].pop();
				}
				else
				{
					printf("%d\n",e[u].top()-tim);
				}
			}
		}//问3
		else
		{
			int l=read();
			int r=read();
			printf("%d\n",query(1,1,n,l,r));
		}//问4
	}
}
int main()
{
	int first_fan=read();
	while (first_fan--)
	{
		solve();//多组数据
	}
}
```

还有一件事：这题时间卡得松，空间卡得紧，所以开数组不要太豪迈了……

---

## 作者：cc123321 (赞：2)

无语了，看到身边的奆佬一个个用SPLAY做，我一个小蒟蒻只会打打暴力了，可是不知道是数据太水还是咋滴，就这么过掉了= =，我也算是醉了，而且跑得飞快。。。
说一下做法吧，对于每种食物开个PQ，然后所有食物一起开个PQ，但是所有食物的PQ不仅存着熟的时间还存着那个熟了，然后每次操作就先把大的PQ中熟的食物给T掉，同时把那种食物的PQ也T掉，然后插到树状数组里面。
对于操作0，向两个PQ里面插入元素即可；
对于操作1，在树状数组里面找就好了；
对于操作2，在小的PQ里面找就好了；
对于操作3，在树状数组里找就好了；
切记，每次操作都要更新PQ使所有PQ里面的食物都是没熟的，同时更新树状数组，使所有熟了的食物都在树状数组里面，这样就搞好了。。。
看看他们那些6k+的代码，小蒟蒻在寒风中瑟瑟发抖、、、
```cpp
#include<bits/stdc++.h>
#define maxn 100005
#define inf 1000000
#define lb(x) x&-x
using namespace std;
int n,q,t,id,l,r,op,tim[maxn],shu[maxn];
int f[maxn];
int read()
{
	int lin = 0;
	char x = getchar();
	while(x < '0' || x > '9') x = getchar();
	while(x >= '0' && x <= '9')
	{
		lin = lin * 10 + x - '0';
		x = getchar();
	}
	return lin;
}
void update(int pos,int val)
{
	while(pos < maxn)
	{
		f[pos] += val;
		pos += lb(pos);
	}
}
int get(int pos)
{
	int ans = 0;
	while(pos)
	{
		ans += f[pos];
		pos -= lb(pos);
	}
	return ans;
}
priority_queue <pair<int,int>, vector<pair<int, int> >, greater<pair<int, int> > > que;
priority_queue <int, vector<int>, greater<int> > s[maxn],shou;
int main(){
	int tt;
	cin >> tt;
	while(tt--)
	{
		memset(f,0,sizeof(f));
		memset(shu,0,sizeof(shu));
		n = read();
		for(int i = 1; i <= n; i++) tim[i] = read();
		while(que.size()) que.pop();
		while(shou.size()) shou.pop();
		for(int i = 0; i <= n; i++)
			while(s[i].size())
				s[i].pop();
		q = read();
//		printf("+++++++++++++++++++++\n%d\n++++++++++++++++++++++\n",q);
		while(q)
		{
			q--;
//		printf("+++++++++++++++++++++\n%d\n++++++++++++++++++++++\n",q);
			t = read();
			op = read();
			if(op == 0)
			{
				id = read();
				s[id].push(t + tim[id]);
				que.push(make_pair(t + tim[id],id));
			}
			if(op == 1)
			{
				while(que.size() && que.top().first <= t)
				{
					shou.push(que.top().second);
					shu[que.top().second]++;
					update(que.top().second,1);
					s[que.top().second].pop();
					que.pop();
				}
				if(!get(maxn - 1)) 	printf("Yazid is angry.\n");
				else
				{
					while(!shu[shou.top()]) shou.pop();
					int ans = shou.top();
					shou.pop();
					shu[ans]--;
					update(ans,-1);
					printf("%d\n",ans);
				}
			}
			if(op == 2)
			{
				while(que.size() && que.top().first <= t)
				{
					shou.push(que.top().second);
					update(que.top().second,1);
					s[que.top().second].pop();
					shu[que.top().second]++;
					que.pop();
				}
				id = read();
				if(!shu[id])
				{
					if(s[id].size())
					{
						printf("%d\n",s[id].top() - t);
					}
					else printf("YJQQQAQ is angry.\n");
				}
				else if(shu[id])
				{
					--shu[id];
					printf("Succeeded!\n");
					update(id,-1);
				}
			}
			if(op == 3)
			{
				l = read();
				r = read();
				while(que.size() && que.top().first <= t)
				{		
					shou.push(que.top().second);
					shu[que.top().second]++;
					update(que.top().second,1);
					s[que.top().second].pop();
					que.pop();
				}
				int ans = get(r) - get(l - 1);
				printf("%d\n",ans);
			}
		}
	}
}
```

---

## 作者：消失的海岸线 (赞：2)

丢一下[博客](https://www.zgz233.xyz/2017/12/26/bzoj-5132-codeplus2017%E5%B9%B412%E6%9C%88%E7%81%AB%E9%94%85%E7%9B%9B%E5%AE%B4/ "博客")链

考虑分别维护熟了的和没熟的食物，对于熟了的，用一个资词二分和单点修改，区间求和的数据结构就可以了。

这个可以用树状数组优雅的实现，详见代码，一看就懂了。

对于没熟的，用一个堆轻易一起维护掉，每次置入熟了的直到时间赶上当前时间位置。

对于询问某种食物最接近熟的操作，朴素的想法用一棵平衡树即可。

但是可以发现删除操作只有最值删除，所以也可以用堆维护，这样的话内外数据结构常数都很小，跑的飞起。

```cpp
    #include <cmath>
    #include <queue>
    #include <cstdio>
    #include <iomanip>
    #include <cstdlib>
    #include <cstring>
    #include <iostream>
    #include <algorithm>
    #define N 100010
    #define M 500010
    #define ll long long
    using namespace std;
    char xB[1<<15],*xS=xB,*xT=xB;
    #define getchar() (xS==xT&&(xT=(xS=xB)+fread(xB,1,1<<15,stdin),xS==xT)?0:*xS++)
    inline int read()
    {
        int x=0,f=1;char ch=getchar();
        while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
        while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
        return x*f;
    }
    int n,m;
    int bin[17];
```
namespace bit

```cpp
    {
        int c[N];
        void clear()
        {memset(c,0,sizeof(c));}
        void add(int x,int v)
        {
            for(;x<=n;x+=x&(-x))
            c[x]+=v;
        }
        int ask(int x)
        {
            int ret=0;
            for(;x;x-=x&(-x))
            ret+=c[x];
            return ret;
        }
        int upper_bound(int v)
        {
            int x=0,sum=0;
            for(int i=16;i>=0;i--)
            if(x+bin[i]<=n&&sum+c[bin[i]+x]<=v)sum+=c[x+=bin[i]];
            return x;
        }
    }
    #define fi first
    #define se second
    typedef pair<int,int> pr;//done_time idx
    priority_queue<int,vector<int>,greater<int> > buc[N];
    priority_queue<pr,vector<pr>,greater<pr> > q;
    int s[N];
    int T;
    int main()
    {
        T=read();bin[0]=1;
        for(int i=1;i<=16;i++)bin[i]=bin[i-1]<<1;
        while(T--)
        {
            n=read();
            for(int i=1;i<=n;i++)s[i]=read();
            m=read();
            while(m--)
            {
                int tim=read(),opt=read();
                while(!q.empty()&&q.top().fi<=tim)
                {
                    buc[q.top().se].pop();
                    bit::add(q.top().se,1);
                    q.pop();
                }
                if(opt==0)
                {
                    int x=read();
                    q.push(make_pair(tim+s[x],x));
                    buc[x].push(tim);
                }
                else if(opt==1)
                {
                    int idx=bit::upper_bound(0);
                    if(idx==n)puts("Yazid is angry.");
                    else printf("%d\n",idx+1),bit::add(idx+1,-1);
                }
                else if(opt==2)
                {
                    int idx=read();
                    int sum=bit::ask(idx)-bit::ask(idx-1);
                    if(sum)bit::add(idx,-1),puts("Succeeded!");
                    else if(!buc[idx].empty())printf("%d\n",s[idx]-(tim-buc[idx].top()));
                    else puts("YJQQQAQ is angry.");
                }
                else
                {
                    int L=read(),R=read();
                    printf("%d\n",bit::ask(R)-bit::ask(L-1));
                }
            }
            while(!q.empty())q.pop();
            for(int i=1;i<=n;i++)
            while(!buc[i].empty())buc[i].pop();
            bit::clear();
        }
    }

```

---

## 作者：钱逸凡 (赞：1)

# 解题思路
这题一共三个询问，我们可以先从最简单的第三个询问开始分析
## 第三个询问
我们可以用线段树（树状数组）来维护所有已经熟的食物，**每次询问的时间复杂度为O（logn）**
## 第一个询问
由于我们在做第三问时建立一颗线段树（树状数组），所以我们这里可以直接用线段树来解决这一问：
若整个区间的和为0，则没有食物。
若有食物，则：
用二分来找出有值但最小的点（左右端点相同的区间），该点就是所求的食物编号，每次询问的时间复杂度为O（（logn）^2），然后将该点减一,复杂度O(1)，所以，**这步总的复杂度为O（（logn）^2）**
## 第二个询问
我们给每一个食物建一个队列（因为同一种食物煮熟花的时间相同，所以越晚入队，煮熟的时间就越晚），每次询问时如果队列为空，则没有食物，如果队列最前面的元素小于当前时间，则成功，否则，则用队列最前面的元素减去当前时间，即为还需等待的时间，复杂度O(1)
## 一二问相互影响问题
由于拿走食物对一二问都有影响，所以我们在第一问删除时，要把用于第二问的队列元素出队，同样，在第二问删除时，要把用于第一三问的线段树更新，**所以第二问的复杂度变为O(logn)**
## 加入新的食物所需的操作
每次加入新的食物，我们将该食物煮熟的时间加入该食物的队列中，**注意：不要更新线段树，只有食物煮熟时才更新线段树**
## 在每一步之前的操作
根据现在的时间，把所有已经煮熟的食物加入对应的队列和线段树中
# 注意事项
注意清空数据，防止影响到下一组数据！！！
# 代码实现

```
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>
#include<vector>
#include<cstdio>
using namespace std;
int n;
const int mx=101010;
inline int Read(){
	int x=0;
	char c=getchar();
	while(c>'9'||c<'0')c=getchar();
	while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();
	return x;
}
queue<int>food[mx];
int q_num;//询问总数 
int cost[mx];//每种食物需要的时间 
#define lowbit(i) i&-i
int tree[mx];
void change(int pos,int k){//pos位置+k 
	while(pos<=n){
		tree[pos]+=k;
		pos+=lowbit(pos);
	}
}
int query(int pos){//查询到pos为止有多少个食物 
	int ans=0;
	while(pos>=1){
		ans+=tree[pos];
		pos-=lowbit(pos);
	}
	return ans;
}
struct FOOD{//食物 
	int t;//煮熟时间 
	int pos;//食物编号
}; 
struct cmp1{
	bool operator () (const FOOD &a,const FOOD &b)const{
		return a.t>b.t;//按照结束时间从小到大排 
	}
};
priority_queue<FOOD,vector<FOOD>,cmp1>f1;//食物
void query_1(){//第一个问题：拿出编号最小的食物 
	if(!query(n)){//没有任何食物 
		printf("Yazid is angry.\n");
		return;
	}
	int l=1,r=n,mid=(l+r)>>1;
	while(l<r){
		if(query(mid)-query(l-1))r=mid;
		else l=mid+1;
		mid=(l+r)>>1;
	}
	printf("%d\n",mid);
	food[mid].pop();//食物出堆 
	change(mid,-1);
	return;
}
void query_2(int pos,int t){//第二问，pos食物是否有熟的，如果没有，最快熟的还要多久 
	if(food[pos].empty()){//没有该食物 
		printf("YJQQQAQ is angry.\n");
		return;
	}
	int tp=food[pos].front();
	if(tp<=t){//熟了 
		printf("Succeeded!\n");
		food[pos].pop();//从堆中删除该食物 
		change(pos,-1);//从树状数组中删除该食物 
		return;
	}
	else{
		printf("%d\n",tp-t);
		return;
	}
}
void query_3(int l,int r){//第三个问题：查询[l,r]之间有多少个食物 
	printf("%d\n",query(r)-query(l-1));
	return;
}
int main(){
	int T=Read();
	while(T--){
		q_num=0;
		n=Read();
		for(int i=1;i<=n;++i)cost[i]=Read();
		int num=Read();
		for(int i=1;i<=num;++i){
			int t=Read();
			int opt=Read();
			if(!f1.empty()){
				FOOD tp=f1.top();
				while(tp.t<=t){
					f1.pop();
					change(tp.pos,1);
					if(f1.empty())break;
					tp=f1.top();
				}
			}
			if(opt==0){
				int pos=Read();
				FOOD a;
				a.pos=pos;
				a.t=t+cost[pos];
				f1.push(a);
				food[pos].push(t+cost[pos]);
			}
			else if(opt==1){
				query_1();
			}
			else if(opt==2){
				int pos=Read();
				query_2(pos,t);
			}
			else{
				int l=Read(),r=Read();
				query_3(l,r);
			}
		}
		//清除数据，为下一组数据做准备 
		memset(tree,0,sizeof(tree));
		while(!f1.empty())f1.pop();
		for(int i=1;i<=n;i++)while(!food[i].empty())food[i].pop();//清空队列
	}
	return 0;
} 
```

因为太懒所以用了优先队列和树状数组，你们可以用手写堆和线段树

---

## 作者：Lamb_Carp (赞：0)

# advertisement

你们都来看我的题解了，为什么不来[我的博客](https://www.cnblogs.com/carp-oier/p/17742548.html)看看呢。

# prologue

树状数组推荐写法，感谢巨佬[樱雪喵](https://www.luogu.com.cn/user/234074)的教学。

```cpp

inline int lowbit(int x)
{
	return x & -x;
}

inline void add(int x, int c)
{
	for(; x <= n; x += lowbit(x)) tr[x] += c;
}

inline int sum(int x)
{
	int res = 0;
	for(; x; x -= lowbit(x)) res += tr[x];
	return res;
}
```

# analysis

~~很弱的模拟题？~~

这个题目主要解决的问题就以下几个：
1. 对于 YJQQQAQ 怎么快速的查询和删除它要吃掉的东西。
2. 怎么维护东西熟了没熟~~（不干不净吃了没病？）~~
3. 维护一个区间里面的和。

我们可以想到，关于时间类型的问题，它必定是顺着时间进行的（废话但是有用），不太可能出现时间倒流（某些图论题存下来离线，倒序处理除外）。那么我们就可以用时间这一维度来搞个优先队列，然后对于每一个新输入的时间，就来处理这个锅里面的东西是不是已经做好了。

我们又注意到，Yazid 这个人很喜欢吃编号小的食物，所以我们就可以选择用另外一个优先队列来存储这些已经做好的食物。

我们还要处理怎么解决 YJQQQAQ 的问题。我们可以给每种食物开一个结构体，里面存一个队列和一个 cnt。队列用来存还没有煮熟的吃的， cnt 用来存现在做好的还没有被吃了的食物有多少。

对于一个区间的和我们可以采用线段树或者树状数组。因为树状数组的时间、空间都要优于线段树。所以我就用树状数组实现了~~（主要是懒的敲线段树了。~~

剩下的就貌似是一个比较大的模拟题了。（

# code time

（之前调上面树状数组那一块一直没调出来，然后压了点行。）
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define rl register ll
#define wl putchar('\n')
#define ws putchar(' ')

template <class T>

inline void read(T &res)
{
    char ch; bool f = 0;
    while((ch = getchar()) < '0' || ch > '9') f |= ch == '-';
    res = ch ^ 48;
    while((ch = getchar()) <= '9' && ch >= '0') res = (res << 1) + (res << 3) + (ch ^ 48);
    res = f ? ~res + 1 : res;
}

inline void ww(ll x)
{
    if(x < 0) x = ~x + 1, putchar('-');
    if(x > 9) ww(x / 10);
    putchar(x % 10 ^ 48);
}


const ll N = 1e5 + 10;

ll n, m, eat[N], s[N], tr[N];

struct node
{
    ll id, time;
    bool operator <(const node &x) const 
    {
        return time > x.time;
    }
};

struct pot
{
    ll cnt;
    queue<ll> T;
    inline void clean()
    {
        cnt = 0;
        while(T.size()) T.pop();
    }
}pot[N];

priority_queue<node> q;
priority_queue<ll> ripe;

inline ll lowbit(ll x)
{
    return x & -x;
}

inline void add(ll x, ll c)
{
    for(; x <= n; x += lowbit(x)) tr[x] += c;
}

inline ll sum(ll x)
{
    ll res = 0;
    for(; x; x -= lowbit(x)) res += tr[x];
    return res;
}

int main()
{
    // freopen("1.in", "r", stdin), freopen("1.out", "w", stdout);

    ll T; read(T);
    while(T -- )
    {
        read(n);
        while(q.size()) q.pop(); while(ripe.size()) ripe.pop(); 
        for(rl i=1; i <= n; ++ i)
        {
            read(s[i]);
            eat[i] = 0;
            pot[i].clean();
            tr[i] = 0;
        }
        
        read(m);
        while(m -- )
        {
            ll t, op, a, b;
            read(t), read(op);

            while(q.size() && q.top().time <= t)
            {
                ll id = q.top().id;
                add(id, 1);

                pot[id].cnt ++ ; pot[id].T.pop();
                ripe.push(-id);

                q.pop();
            }

            if(op == 0) { read(a), q.push({a, t + s[a]}), pot[a].T.push(t + s[a]); }
            else if(op == 1)
            {   
                ll id = -1;
                while(ripe.size())
                {
                    ll x = -ripe.top();
                    ripe.pop();
                    if(eat[x] > 0) -- eat[x];
                    else 
                    {
                        id = x;
                        break; 
                    }
                }

                if(id == -1) puts("Yazid is angry.");
                else ww(id), add(id, -1), -- pot[id].cnt, wl;
            }
            else if(op == 2)
            {
                read(a);
                if(pot[a].cnt)
                {
                    -- pot[a].cnt; add(a, -1); ++ eat[a];
                    puts("Succeeded!");
                }
                else 
                {
                    if(pot[a].T.size()) ww(pot[a].T.front() - t), wl;
                    else puts("YJQQQAQ is angry.");
                }
            }
            else 
            {
                read(a), read(b);
                ww(sum(b) - sum(a - 1)), wl;
            }
        }
    }
    return 0;
}
```

---

## 作者：Themooncake (赞：0)

# P4032 [Code+#2] 火锅盛宴
## 1、题目大意
$T$ 组数据~~我谢谢你~~，每组数据有 $n$ 种食物，$m$ 次操作，第 $i$ 种食物需要经过 $s_i$ 个单位时间才能熟。

操作共分为 4 种：
- t 0 id 表示往锅中放一个编号为 $id$ 的食物。
- t 1 表示查找锅中编号最小的煮熟的食物。如果存在，输出该种食物的编号并取走一个该种食物，否则输出 `Yazid is angry.`。
- t 2 id 表示查找锅中是否有编号为 $id$ 的食物，如果有熟的，输出 `Succeeded!` 并取走一个该种食物；如果没有熟的但有生的，输出该种食物最快还要多少单位时间煮熟；否则输出 `YJQQQAQ is angry.`。
- t 3 l r 表示查询编号在 $[l,r]$ 中的煮熟的食物共有多少个。

$T\leq 4$，$n\leq 1\times 10^5$，$m\leq 5\times 10^5$，$s_i\leq 10^8$，$t\leq 10^9$。
## 2、思路
### 数据结构分析
对于操作 3，动态查询区间和，显然用树状数组或者线段树都能轻易地解决，这里我使用线段树。

对于操作 0，由于每一种食物的 $s_i$ 都不一样，因此按照时间插入可能会出现插队的情况，因此考虑采用优先队列记录哪种食物什么时候煮熟，每次进行操作先把已经熟了的食物弹出优先队列并加入线段树。

对于操作 2，熟食显然可以直接查询线段树解决。对于查询生食，我们可以给每一个食物开一个队列，记录每一种食物最早的煮熟时间，与优先队列一起弹出。

对于操作 1，可以用线段树解决。如果对于非叶子结点 $rt$，$tree[rt]$ 的值不为 0，显然他的左儿子或右儿子一定有一个不为 0，也就是存在食物。又因为我们只关心煮熟的食物的最小编号是多少，因此当 $tree[1]$ 不为 0 时，每次先去看左儿子有没有值，如果有就去查询左儿子，否则去访问右儿子，一直递归到叶子结点，此时还可以顺手完成取走的操作。

由于存在多组输入数据，所以要记得**清空数据**。~~惨痛的代价~~
### 时间复杂度分析
线段树的修改与查询、优先队列的出入时间复杂度均为 $O(\log n)$，因此总体时间复杂度为 $O(Tm\log n)$。
### 空间复杂度分析
线段树 $O(n)$，队列及优先队列为 $O(m)$，合计 $O(m+n)$。
## 3、Code
主打一个数据结构乱堆

~~~
#include<bits/stdc++.h>
#define int long long
#define N 100005
#define lson rt<<1
#define rson rt<<1|1
#define mid (l+r>>1) 
int read()
{
	char ch=getchar();
	int x=0,f=0;
	while(ch<'0'||ch>'9')
	f=ch=='-',ch=getchar();
	while(ch>='0'&&ch<='9')
	x=(x<<3)+(x<<1)+(ch&15),ch=getchar();
	return f?~x+1:x;
}
int T,n,Q,s[N];
int tree[N<<2];
void update(int rt){tree[rt]=tree[lson]+tree[rson];}
void add(int rt,int l,int r,int tar,int x)
{
	if(l>tar||r<tar)
	return;
	if(l==r)
	{
		tree[rt]+=x;
		return;
	}
	add(lson,l,mid,tar,x);
	add(rson,mid+1,r,tar,x);
	update(rt);
}
int find(int rt,int l,int r)
{
	if(!tree[rt])
	return 0;
	if(l==r)
	{
		--tree[rt];//查到顺手取走一个
		return l;
	}
	int res;
	if(tree[lson])
		res=find(lson,l,mid);
	else
		res=find(rson,mid+1,r);
	update(rt);
	return res;
}
int query(int rt,int l,int r,int tar)
{
	if(l>tar||r<tar)
	return 0;
	if(l==r)
	{
		if(tree[rt])
		{
			--tree[rt];//查到顺手减掉
			return 1;
		}
		return 0;
	}
	int res;
	res=query(lson,l,mid,tar)|query(rson,mid+1,r,tar);
	update(rt);
	return res;
}
int sum(int rt,int l,int r,int L,int R)
{
	if(l>R||r<L)
	return 0;
	if(L<=l&&r<=R)
	return tree[rt];
	return sum(lson,l,mid,L,R)+sum(rson,mid+1,r,L,R);
}
std::queue<int> fir[N];
struct data{
	int typ,tic;
	bool operator < (const data &s)const{return tic>s.tic;}
};
std::priority_queue<data> unfree;
signed main()
{
	T=read();
	while(T--)
	{
		memset(tree,0,sizeof(tree));
		while(!unfree.empty())
		{
			data top=unfree.top();
			unfree.pop();
			fir[top.typ].pop();
		}
		//一定要记得清空数据 警钟撅烂 
		n=read();
		for(int i=1;i<=n;++i)
			s[i]=read();
		Q=read();
		int t,op,id,l,r;
		for(int i=1;i<=Q;++i)
		{
			t=read();
			op=read();
			if(!op)
			{
				id=read();
				unfree.push(data{id,t+s[id]});
				fir[id].push(t+s[id]);
				continue;
			}
			while(!unfree.empty())
			{
				data top=unfree.top();
				if(top.tic>t)
				break;
				unfree.pop();
				fir[top.typ].pop();
				add(1,1,n,top.typ,1);
			}
			int ans;
			if(op==1)
			{
				ans=find(1,1,n);
				if(ans)
				printf("%d\n",ans);
				else
				printf("Yazid is angry.\n");
			}
			if(op==2)
			{
				id=read();
				ans=query(1,1,n,id);
				if(ans)
				printf("Succeeded!\n");
				else
				{
					if(fir[id].empty())
						printf("YJQQQAQ is angry.\n");
					else
						printf("%d\n",fir[id].front()-t);
				}
			}
			if(op==3)
			{
				l=read(),r=read();
				printf("%d\n",sum(1,1,n,l,r));
			}
		}
	}
}

~~~

命运多舛的题解

---

## 作者：hhz6830975 (赞：0)

离线读入操作，按时间排序

分别开两个splay维护煮熟的（T[0]）和加入但未煮熟的（T[1]）食物，关键字都为t

其中T[1]要在每个结点按煮熟的时间（t+s[i]）维护一个小根堆（这里直接用stl的优先队列）

操作0可以分解为：t时刻将食物插入T[1]；t+s[i]时刻将食物从T[1]删除,将食物插入T[0]

操作1：找T[0]最小值，删除；若T[0]空则angry

操作2：找T[0]中id为k的食物，删除；不存在时找T[1]中id为k的结点，输出堆顶元素-当前时间；不存在该结点则angry

操作3：splay出T[0]对应区间，返回size


ps1：写个splay调了半天，最后发现其实可以用树状数组。。

ps2：千万不要和我一样手贱把优先队列塞进结构体，两个树一起开，否则会有奇怪的RE（似乎是优先队列有数量限制？不是很懂）

ps3：有多组数据，记得初始化（包括清空优先队列）


代码：



    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
```cpp
    #include <iostream>
    #include <cstdio>
    #include <cstring>
    #include <algorithm>
    #include <queue>
    using namespace std;
    const int maxn=100010;
    const int maxq=500010;
    const int INF=0x7fffffff;
    int dT,n,Q,s[maxn],ans[maxq];
    inline int read(){
        int ret=0,sign=1;
        char ch=getchar();
        while(ch<'0'||ch>'9') {if(ch=='-') sign=-1; ch=getchar();}
        while(ch>='0'&&ch<='9') {ret=ret*10+ch-'0'; ch=getchar();}
        return ret*sign;
    }
    int Acnt,Ccnt;
    struct cmd{
        int no,t,op,x,y;
    }A[2][maxq],C[maxq];
    bool cmp(cmd a,cmd b){return a.t<b.t;}
    priority_queue <int,vector<int>,greater<int> > pq[maxq];
    int root[2],Tcnt[2];
    struct node{
        int fa,son[2],cnt,size,val;
        node(){}
        node(int _fa,int lson,int rson,int _val){fa=_fa,son[0]=lson,son[1]=rson,cnt=size=1,val=_val;}
    }T[2][maxq];
    inline int get(int Tn,int u){return T[Tn][T[Tn][u].fa].son[1]==u;}
    inline void pushup(int Tn,int u){T[Tn][u].size=T[Tn][u].cnt+T[Tn][T[Tn][u].son[0]].size+T[Tn][T[Tn][u].son[1]].size;}
    inline void rotate(int Tn,int u){
        int v=T[Tn][u].fa,rela=get(Tn,u);
        if(T[Tn][v].fa) T[Tn][T[Tn][v].fa].son[get(Tn,v)]=u;
        T[Tn][u].fa=T[Tn][v].fa;
        if(T[Tn][u].son[rela^1]) T[Tn][T[Tn][u].son[rela^1]].fa=v;
        T[Tn][v].son[rela]=T[Tn][u].son[rela^1];
        T[Tn][u].son[rela^1]=v,T[Tn][v].fa=u;
        pushup(Tn,v),pushup(Tn,u);
    }
    inline void splay(int Tn,int u,int final){
        while(T[Tn][u].fa!=final){
            int v=T[Tn][u].fa;
            if(T[Tn][v].fa!=final) rotate(Tn,get(Tn,u)==get(Tn,v)?v:v);
            rotate(Tn,u);
        }
        if(final==0) root[Tn]=u;
    }
    inline void ins(int Tn,int x,int t=0){
        if(!root[Tn]){
            T[Tn][++Tcnt[Tn]]=node(0,0,0,x);
            if(Tn) pq[Tcnt[Tn]].push(t);
            root[Tn]=Tcnt[Tn];
            return;
        }
        int u=root[Tn],v=0;
        while(1){
            if(!u) {T[Tn][++Tcnt[Tn]]=node(v,0,0,x),u=Tcnt[Tn],T[Tn][v].son[x>T[Tn][v].val]=u; break;}
            else if(x==T[Tn][u].val) {++T[Tn][u].cnt,++T[Tn][u].size; break;}
            else if(x<T[Tn][u].val) v=u,u=T[Tn][u].son[0];
            else v=u,u=T[Tn][u].son[1];
        }
        if(Tn) pq[u].push(t);
        splay(Tn,u,0);
    }
    inline int find(int Tn,int u,int x,int final){
        while(1){
            if(x==T[Tn][u].val) break;
            else if(x<T[Tn][u].val) u=T[Tn][u].son[0];
            else u=T[Tn][u].son[1];
        }
        splay(Tn,u,final);
        return u;
    }
    inline void del(int Tn,int x,int tar=0){
        int u;
        if(tar) splay(Tn,tar,0),u=tar;
        else u=find(Tn,root[Tn],x,0);
        if(Tn) pq[u].pop();
        if(T[Tn][u].cnt>1) --T[Tn][u].cnt,--T[Tn][u].size;
        else if(!T[Tn][u].son[0]||!T[Tn][u].son[1]){
            int v=T[Tn][u].son[0]!=0?T[Tn][u].son[0]:T[Tn][u].son[1];
            T[Tn][v].fa=0,root[Tn]=v;
        }
        else{
            int v=T[Tn][u].son[0];
            while(T[Tn][v].son[1]) v=T[Tn][v].son[1];
            splay(Tn,v,0);
            T[Tn][T[Tn][u].son[1]].fa=v,T[Tn][v].son[1]=T[Tn][u].son[1];
            pushup(Tn,v);
        }
    }
    inline int query1(){
        int u,ret;
        find(0,root[0],0,0),u=find(0,root[0],INF,root[0]),u=T[0][u].son[0];
        if(!u) return -1;
        while(T[0][u].son[0]) u=T[0][u].son[0];
        ret=T[0][u].val;
        del(0,0,u);
        return ret;
    }
    inline int query2(int x){
        int u=root[0],fail=0;
        while(1){
            if(!u) {fail=1; break;}
            else if(x==T[0][u].val) break;
            else if(x<T[0][u].val) u=T[0][u].son[0];
            else u=T[0][u].son[1];
        }
        if(!fail){
            del(0,0,u);
            return -2;
        }
        u=root[1],fail=0;
        while(1){
            if(!u) {fail=1; break;}
            else if(x==T[1][u].val) break;
            else if(x<T[1][u].val) u=T[1][u].son[0];
            else u=T[1][u].son[1];
        }
        if(!fail) return pq[u].top();
        return -3;
    }
    inline int pre(int x){
        int u,ret;
        ins(0,x);
        u=T[0][root[0]].son[0];
        while(T[0][u].son[1]) u=T[0][u].son[1];
        ret=T[0][u].val;
        del(0,x);
        return ret;
    }
    inline int nxt(int x){
        int u,ret;
        ins(0,x);
        u=T[0][root[0]].son[1];
        while(T[0][u].son[0]) u=T[0][u].son[0];
        ret=T[0][u].val;
        del(0,x);
        return ret;
    }
    inline int query3(int l,int r){
        int u;
        l=pre(l),r=nxt(r);
        find(0,root[0],l,0),u=find(0,root[0],r,root[0]),u=T[0][u].son[0];
        return T[0][u].size;
    }
    int main(){
        dT=read();
        for(int i=1;i<=dT;i++){
            for(int j=1;j<=Tcnt[1];j++)
                while(!pq[j].empty()) pq[j].pop();
            Acnt=Ccnt=0;
            root[0]=Tcnt[0]=root[1]=Tcnt[1]=0;
            n=read();
            for(int j=1;j<=n;j++)
                s[j]=read();
            Q=read();
            int t,op,x,y=0;
            for(int j=1;j<=Q;j++){
                t=read(),op=read();
                if(op==0||op==2) x=read();
                else if(op==3) x=read(),y=read();
                if(op==0){
                    ++Acnt;
                    A[0][Acnt]=(cmd){Acnt,t,op,x,0};
                    A[1][Acnt]=(cmd){Acnt,t+s[x],op,x,0};
                }
                else C[++Ccnt]=(cmd){Ccnt,t,op,x,y};
            }
            sort(A[0]+1,A[0]+Acnt+1,cmp);
            sort(A[1]+1,A[1]+Acnt+1,cmp);
            sort(C+1,C+Ccnt+1,cmp);
            ins(0,0),ins(0,INF);//为splay区间操作方便额外加两个结点
            int p0=1,p1=1;
            for(int j=1;j<=Ccnt;j++){
                while(A[0][p0].t<=C[j].t&&p0<=Acnt) ins(1,A[0][p0].x,A[0][p0].t+s[A[0][p0].x]),++p0;
                while(A[1][p1].t<=C[j].t&&p1<=Acnt) del(1,A[1][p1].x),ins(0,A[1][p1].x),++p1;
                if(C[j].op==1) ans[C[j].no]=query1();
                else if(C[j].op==2) {ans[C[j].no]=query2(C[j].x); if(ans[C[j].no]>0) ans[C[j].no]-=C[j].t;}
                else ans[C[j].no]=query3(C[j].x,C[j].y);
            }
            for(int j=1;j<=Ccnt;j++){
                if(ans[j]>=0) printf("%d\n",ans[j]);
                else if(ans[j]==-1) printf("Yazid is angry.\n");
                else if(ans[j]==-2) printf("Succeeded!\n");
                else printf("YJQQQAQ is angry.\n");
            }
        }
        return 0;
    }

```

---

## 作者：wanggiaoxing (赞：0)

### 树状数组+优先队列
我把询问与操作拆开来讲。
#### 操作
我们可以用树状数组来维护这种物品的个数，但此时不应加一，而是应在某次询问的时间大于此次食物的煮熟时间时加一，所以我们要在每次询问前处理树状数组。同时我们把这个煮熟的时间放进优先队列中，用小根堆，作用后面说。
#### 询问一
我们在树状数组上二分，此时的单调性是个数越多，和越大，我们找到第一个和不为零的点，这个点即为最优的点，这里我用了一种好写的倍增，没用二分，大家可以去学习这种写法。
#### 询问二
我们用优先队列来访问，如果 $id$ 对应的优先队列的元素个数不为零，那么就输出堆顶。否则取出堆顶，输出此时的时间与堆顶的差，因为我们用的是小根堆，取出的刚好是锅内存在时间最长的食物。
#### 询问三
直接用树状数组查询就行了。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t,n,a[100001],v[100001],m,c[100001][2];
priority_queue<int,vector<int>,greater<int> >q[100001];
priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >z;
void add(int x,int k)
{
	for(int i=x;i<=n;i+=i&-i)
		a[i]+=k;
}
int find(int x)
{
	int ans=0;
	for(int i=x;i;i-=i&-i)
		ans+=a[i];
	return ans;
}
signed main()
{
	scanf("%lld",&t);
	while(t--)
	{
		memset(a,0,sizeof(a));
		scanf("%lld",&n);
		memset(c,0,sizeof(c));
		for(int i=1;i<=n;i++)
			while(!q[i].empty())
				q[i].pop();
		while(!z.empty())
			z.pop();
		for(int i=1;i<=n;i++)
			scanf("%lld",&v[i]);
		scanf("%lld",&m);		
		while(m--)
		{
			int op,id,l,r,t;
			scanf("%lld%lld",&t,&op);
			while(!z.empty()&&z.top().first<=t)
			{
				add(z.top().second,1);
				z.pop();
			}
			if(op==0)
			{
				scanf("%lld",&id);
				q[id].push(t+v[id]);
				z.push(pair<int,int>(t+v[id],id));
			}
			if(op==1)
			{
				int ans=0;
				if(!find(n))
					printf("Yazid is angry.\n");
				else
				{
					for(int i=(1<<17);i;i>>=1)//倍增写法
						if(ans+i<=n&&!find(ans+i))
							ans+=i;
					ans++;
					printf("%lld\n",ans);
					add(ans,-1);
					q[ans].pop();
				}
				
			}
			if(op==2)
			{
				scanf("%lld",&id);
				if(q[id].empty())
					printf("YJQQQAQ is angry.\n");
				else
				if(!q[id].empty()&&q[id].top()<=t)
				{
					q[id].pop();
					add(id,-1);
					printf("Succeeded!\n");
				}
				else
					printf("%lld\n",q[id].top()-t);
			}
			if(op==3)
			{
				scanf("%lld%lld",&l,&r);
				printf("%lld\n",find(r)-find(l-1));
			}
		}
	}
	return 0;
}
```


---


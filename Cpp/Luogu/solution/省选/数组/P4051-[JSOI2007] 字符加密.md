# [JSOI2007] 字符加密

## 题目描述

喜欢钻研问题的JS 同学，最近又迷上了对加密方法的思考。一天，他突然想出了一种他认为是终极的加密办法：把需要加密的信息排成一圈，显然，它们有很多种不同的读法。

例如‘JSOI07’，可以读作：  JSOI07 SOI07J OI07JS I07JSO 07JSOI 7JSOI0 把它们按照字符串的大小排序： 07JSOI 7JSOI0 I07JSO JSOI07 OI07JS SOI07J 读出最后一列字符：I0O7SJ，就是加密后的字符串（其实这个加密手段实在很容易破解，鉴于这是突然想出来的，那就^^）。 但是，如果想加密的字符串实在太长，你能写一个程序完成这个任务吗？


## 说明/提示

对于40%的数据字符串的长度不超过10000。

对于100%的数据字符串的长度不超过100000。


## 样例 #1

### 输入

```
JSOI07```

### 输出

```
I0O7SJ```

# 题解

## 作者：hovny (赞：24)

## [题面](https://www.luogu.org/problemnew/show/P4051)

## 思路：

作为一个**后缀数组**的初学者，当然首先想到的是**后缀数组**

把$s$这个串首尾相接，扩展为原来的两倍，就能按后缀数组的方法处理

### 证明：

~~神仙一眼就看出这是后缀的裸题，我这个蒟蒻想了半天想不出来~~

如果我们只对$s$串进行后缀排序，明显无法处理如下的情况，~~于是就拿了30分~~

> $s=bnabn$
>
> $bn$会在$bnabn$前面，而实际$bn$对应的应该是$bnbna$，比$bnabn$要大

那么应该这么处理这些缺少的串呢？

我们可以尝试一下把原来的$s$变成两倍

> $s=bnabn+bnabn$
>
> 后缀$bnabnbnabn$在后缀$bnbnabn$前面，而实际上$bnabn$也同样在$bnbna$前面

这样扩展了一倍之后，也就是说题目中变化得到的$len(s)$个串都出现过，但是多出来的部分会不会影响结果呢？

答案是不会

比如说：

> $s=abcd$
>
> 扩展后$ \to s=abcdabcd$
>
> 对于原串的一种变化结果$bcda$
>
> 包含在扩展后的$s$中，而$bcda$对应的后缀就是$bcdabcd$，后缀中多出的$bcd$对于$bcda$来说，它实际上是$bcda$的前缀，也就是说它对$bcda$的影响由$bcda$决定，~~这不就是没有影响吗~~

Code：

```cpp
#include<bits/stdc++.h>
#define N 1000010
using namespace std;
int n,m,x[N],y[N],c[N],sa[N],p,t;
char s[N];
int main()
{
	int i,k;
	scanf("%s",s);
	t=strlen(s);m=300;n=t<<1;//t是原来s的长度，n是扩展后长度，m初始值实际不用300
	for(i=t;i<n;i++) s[i]=s[i-t];
	for(i=0;i<n;i++) c[x[i]=s[i]]++;
	for(i=1;i<m;i++) c[i]+=c[i-1];
	for(i=0;i<n;i++) sa[--c[x[i]]]=i;
	for(k=1;k<=n;k<<=1)
	{
		p=0;
		for(i=n-k;i<n;i++) y[p++]=i;
		for(i=0;i<n;i++) if(sa[i]>=k) y[p++]=sa[i]-k;
		for(i=0;i<m;i++) c[i]=0;
		for(i=0;i<n;i++) c[x[y[i]]]++;
		for(i=1;i<m;i++) c[i]+=c[i-1];
		for(i=n-1;i>=0;i--) sa[--c[x[y[i]]]]=y[i];
		swap(x,y);p=1;x[sa[0]]=0;
		for(i=1;i<n;i++)
			x[sa[i]]=(y[sa[i-1]]==y[sa[i]]&&y[sa[i-1]+k]==y[sa[i]+k])?p-1:p++;
		if(p>=n) break;
		m=p;
	}//都是后缀数组的模板
	for(i=0;i<n;i++) if(sa[i]<t) printf("%c",s[(sa[i]+t-1)]);//也就是一个后缀开始的前一位
	return 0;
}
```



---

## 作者：Drawing_Yang (赞：9)

不会后缀数组的,字符串Hash是个好的算法,可以在 $O(n\log^2n)$ 的时间内完成后缀数组所求的`sa[]`.

具体来说利用字符串Hash,在排序的时候不用 $O(len)$ 比较,而是换成二分查找最远的一个字符串相等的位置.即若现在要比较同一个字符串的两个不同的位置 $x,y$ 为起点,长度为 $l$ 的字符串,找到一个最大的 $d$ 满足 $str[x..x+d-1]==str[y..y+d-1]$,然后再比较下一个字符 $str[x+d]$ 与 $str[y+d]$ 的大小.

对于这道题,将字符串复制一遍,直接排序,`cmp`函数换成二分就可以了,时间复杂度 $O(n\log^2n)$.

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
inline char getch(){
	static char buf[10000],*p1=buf,*p2=buf;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,10000,stdin),p1==p2)?EOF:*p1++;
}
#define Getc getch
inline ll read(){
	ll s=0,f=1;char ch=Getc();
	while(ch<'0'||ch>'9')f=(ch=='-'?-1:1),ch=Getc();
	while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=Getc();
	return s*f;
}
typedef unsigned long long llu;
const int MaxN=100000+5;
const int seed=131;
int pos[MaxN];
char s[MaxN*2];
llu Hash[MaxN*2],Pow[MaxN*2];
int n,N;
llu getHash(int l,int r){return Hash[r]-Hash[l-1]*Pow[r-l+1];}
bool cmp(int x,int y){
	int l=1,r=n,Ans=0;
	while(l<=r){
		int mid=(l+r)>>1;
		if(getHash(x,x+mid-1)==getHash(y,y+mid-1)){
			Ans=mid;
			l=mid+1;
		}else r=mid-1;
	}
	return s[x+Ans]<s[y+Ans];
}
int main(){
	scanf("%s",s+1);n=strlen(s+1);N=2*n;
	for(int i=1;i<=n;i++)s[i+n]=s[i];
	Pow[0]=1;
	for(int i=1;i<=N;i++){
		Pow[i]=Pow[i-1]*seed;
		Hash[i]=Hash[i-1]*seed+s[i];
	}
	for(int i=1;i<=n;i++)pos[i]=i;
	sort(pos+1,pos+n+1,cmp);
	for(int i=1;i<=n;i++)putchar(s[pos[i]+n-1]);
	puts("");
	return 0;
}
```

---

## 作者：ShuYuMo (赞：8)

提供一种思路，不保证是最好的，但是代码好像是最短的。。。。。

------------

例如`JSOI07`，

可以读作： 
 - `JSOI07`
 - `SOI07J`
 - `OI07JS`
 - `I07JSO`
 - `07JSOI`
 - `7JSOI0` 

把它们按照字符串的大小排序：
 - `07JSOI`
 - `7JSOI0`
 - `I07JSO`
 - `JSOI07`
 - `OI07JS`
 - `SOI07J`

读出最后一列字符：`I0O7SJ`，

------------

对于此题，其实还有一种比较恶心（玄学）的做法。

对，没错确实恶心。

其实对于给出的字符串S，我们可以有`strlen(S)`种读法，其实我们不关心这些读法到底是什么，我们只需要关心这些读法的`最后一个字符`是什么。

那么如何得知最后一个字符是什么呢？

显然，你只需要知道这一个读法第一个字符就可以。

去观察一下那些字符串：

原字符串：`JSOI07`

可以读作： 
 - `JSOI07`
 - `SOI07J`
 - `OI07JS`
 - `I07JSO`
 - `07JSOI`
 - `7JSOI0` //以这个为例，最后一个字符是`0`，第一个是`7`

我们可以得到如下结论，如果最后一个字符是原字符串的第` i `个，那它对应的第一个字符是原字符串的第` i + 1 `个。

所以我们知道这个字符串各种读法 排好序后的第一个字符就可以了，

那这个又咋求呢？

（直接排原字符串就好了啊。。。。）

嗯对， 就这么骚。。

简单说就是把源字符串本身进行排序，然后对于每个字符找到原来字符串的前一个，组成字符串输出就可以了。。。

代码如下：

```cpp
//代码中，我没有直接对原字符串排序，我排了一下这个字符串的顺序，就是我没有改变原字符串，而是记录了某个字符排序前的位置。
//紫书里面说过好像。叫什么间接排序之类的。
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const int  _ = 200010;
char S[_];
int S_id[_];
int len;
bool __CMP(const int &x, const int &y)
{
    int px = x, py = y, k = 0;
    while (S[px] == S[py] && k < 50) {px++;py++;k++;}
    return S[px] < S[py];
}//排序规则这里，while循环是为了防止字符重复，重复的话就往后找（字典序哦~），
//k的话。。。为了防止全都是重复的，然后找个不停。。。
//有一个点就卡这个东西。。
int main()
{
    scanf("%s", S);
    len = strlen(S);
    for (int i = 0; i < len; i++) S[i + len] = S[i];//把原来的串再接到原来的串后面，找“前一个”字符时比较方便。
    for (int i = 0; i < len; i++) S_id[i] = i;//记录原来字符串，每个字符的位置，没排序前，第一个就在原来字符串的第一个，第二个就在第二个
    sort(S_id, S_id + len, __CMP); //对这个记录序号的数组排序。
    for (int i = 0; i < len; i++)
        putchar(S[(S_id[i] == 0 ? (len - 1) : (S_id[i] - 1))]);//这里输出就好了，三目运算符自己看一下就欧克了。
    return 0;
}
```

最后再展示一下没有注释的代码，得瑟一下代码长度

数据可能再稍微强一点我就`GG`了……

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const int  _ = 200010;
char S[_];
int S_id[_];
int len;
bool oldsu(const int &x, const int &y)
{
    int px = x, py = y, k = 0;
    while (S[px] == S[py] && k < 50) {px++;py++;k++;}
    return S[px] < S[py];
}
int main()
{
    scanf("%s", S);
    len = strlen(S);
    for (int i = 0; i < len; i++) S[i + len] = S[i];
    for (int i = 0; i < len; i++) S_id[i] = i;
    sort(S_id, S_id + len, oldsu); //100000
    for (int i = 0; i < len; i++)
        putchar(S[(S_id[i] == 0 ? (len - 1) : (S_id[i] - 1))]);
    return 0;
}
```

---

## 作者：Edgration (赞：7)

## 后缀数组

为什么没有人做这个题啊...

后缀数组裸题。

把字符串接到自己后面变成长度为$2*len$以后直接排序。

按题目要求输出结尾的字符就好了啊...

## 代码

```cpp
#include <bits/stdc++.h>
#define rep(i, j, k) for (register int i = j; i <= k; ++i)
#define drep(i, j, k) for (register int i = j; i >= k; --i)
inline int read(){
    char ch = getchar(); int u = 0, f = 1;
    while (!isdigit(ch)) { if(ch == '-') f = -1; ch = getchar();}
    while (isdigit(ch)) { u = (u << 3) + (u << 1) + ch - 48; ch = getchar();}
    return u * f;
}
const int maxn = 1e6 + 10;
namespace SuffixArry{
    int tax[maxn], Rank[maxn], str[maxn], SA[maxn], tmp[maxn], n, m;
    char ch[maxn];
    inline void Init(){
        scanf("%s", ch + 1);
        n = strlen(ch + 1);
        rep (i, 1, n) str[i] = (int)ch[i];
        rep (i, n + 1, n << 1) str[i] = str[i - n];
        n <<= 1; //把字符串接到自己后面求后缀数组
    } 
    inline void radix_sort(int m){
        memset(tax, 0, sizeof(int) * (m + 1));
        rep (i, 1, n) tax[Rank[i]]++;
        rep (i, 2, m) tax[i] += tax[i - 1];
        drep (i, n, 1) SA[tax[Rank[tmp[i]]]--] = tmp[i];
    }
    inline bool cmp(int *f, int x, int y, int w){
        return f[x] == f[y] && (x + w > n ? -1 : f[x + w]) == (y + w > n ? -1 : f[y + w]); 
    }
    inline void build(){
        rep (i, 1 ,n) Rank[i] = str[i], tmp[i] = i;
        m = 1005;
        radix_sort(m);
        for (int p = 1, w = 1; p < n; m = p, w <<= 1){
            p = 0;
            rep (i, n - w + 1, n) tmp[++p] = i;
            rep (i, 1, n) SA[i] > w ? tmp[++p] = SA[i] - w: 0;
            radix_sort(m);
            rep (i, 1, n) tmp[i] = Rank[i];
            Rank[SA[1]] = p = 1;
            rep (i, 2, n) Rank[SA[i]] = cmp(tmp, SA[i], SA[i - 1], w) ? p : ++p;
        }
    }
    inline void Print(){
        rep (i, 1, n) if (SA[i] <= (n >> 1)) putchar(str[SA[i] + (n >> 1) - 1]); //如果开头在原串里面，就输出答案。
    }
}
int main(){
    SuffixArry :: Init();
    SuffixArry :: build();
    SuffixArry :: Print();
    return 0;
}
```

---

## 作者：cyh_toby (赞：4)

# 题意

原题：[[JSOI2007]字符加密](https://www.luogu.com.cn/problem/P4051)

# 分析

显然先要断环成链。把给定字符串复制一遍放在后面。

然后对其求一遍后缀数组，发现就相当于对题目描述的那些东西排了序（当然最后需要把长度过短的忽略）。

为什么？

假设现比较后缀 $i$ 与后缀 $j$ 的大小关系。

- 如果 $s[i:i+n-1] > s[j:j+n-1]$，那不管给它们后面添上什么东西都不会改变其大小关系，因此后缀 $i$ 必然大于后缀 $j$ 。反之类似。
- 如果 $s[i:i+n-1] = s[j:j+n-1]$，说明两个串相同，那么它们谁先谁后都一样了，所以由它们后面的字符决定其先后大小关系也无所谓。

所以，影响一个后缀 $s[i:2n]$ 与其他后缀大小关系的，其实就是 $s[i:i+n-1]$ 。

反过来，后缀 $i\;\ge$ 后缀 $j$ 必然意味着 $s[i:i+n-1] \ge s[j:j+n-1]$ 。

所以求后缀数组即可。

之后有一些细节操作，见代码。

# 源码

```cpp
const int N = 2e5+5;

int n, w;
char s[N];
int sa[N], rk[N<<1], oldrk[N<<1], cnt[N], id[N];

inline bool cmp(int x, int y, int j) {
	return oldrk[x] == oldrk[y] && oldrk[x+j] == oldrk[y+j];
}

int main()
{
	scanf("%s", s+1);
	n = strlen(s+1);
	for (int i = 1; i <= n; i++) 
		s[i+n] = s[i];
	n <<= 1;
	
	for (int i = 1; i <= n; i++) cnt[(int)s[i]]++;
	w = 300;
	for (int i = 1; i <= w; i++) cnt[i] += cnt[i-1];
	for (int i = n; i >= 1; i--) sa[cnt[(int)s[i]]--] = i;
	w = 0;
	for (int i = 1; i <= n; i++)
		rk[sa[i]] = s[sa[i]] == s[sa[i-1]] ? w : ++w;
	
	for (int j = 1; j < n; j <<= 1) {
		int t = 0;
		for (int i = n; i > n-j; i--) id[++t] = i;
		for (int i = 1; i <= n; i++)
			if (sa[i] > j) id[++t] = sa[i] - j;
		
		memset(cnt, 0, sizeof(cnt));
		for (int i = 1; i <= n; i++) cnt[rk[id[i]]]++;
		for (int i = 1; i <= w; i++) cnt[i] += cnt[i-1];
		for (int i = n; i >= 1; i--) sa[cnt[rk[id[i]]]--] = id[i];
		
		memcpy(oldrk, rk, sizeof(oldrk));
		w = 0;
		for (int i = 1; i <= n; i++) 
			rk[sa[i]] = cmp(sa[i], sa[i-1], j) ? w : ++w;
	}
	
	for (int i = 1; i <= n; i++) 
		if (sa[i] <= n/2) printf("%c", s[sa[i]+n/2-1]);
	
	return 0;
}
```



---

## 作者：YuukiYumesaki (赞：3)

这道题的本质上是对环上的任意一点开始的字符串排序

自然想到破环为链

然后我们对于这个两倍原串长度的串进行SA，最后我们通过判断所有$sa_i\leq n$的进行判断就可以了

证明还是挺好想的

我们只需要观察所有$sa_i\leq n$的，而对于这一部分，我们在前$n$位上一定是有序的，后面的一定不会对前$n$位的顺序造成影响，这也是我们需要的部分

然后这道题就愉快的解决了

```cpp
#include <bits/stdc++.h>
using namespace std;

# define Rep(i,a,b) for(int i=a;i<=b;i++)
# define _Rep(i,a,b) for(int i=a;i>=b;i--)
# define RepG(i,u) for(int i=head[u];~i;i=e[i].next)

typedef long long ll;

const int N=4e5+5;

template<typename T> void read(T &x){
   x=0;int f=1;
   char c=getchar();
   for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
   for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+c-'0';
    x*=f;
}

int n,m;
char s[N];
int sa[N],tp[N],rk[N],sum[N];

void RadixSort(){
	Rep(i,0,m)sum[i]=0;
	Rep(i,1,2*n)sum[rk[i]]++;
	Rep(i,1,m)sum[i]+=sum[i-1];
	_Rep(i,2*n,1)sa[sum[rk[tp[i]]]--]=tp[i];	
}

void SA(){
	m=256;
	Rep(i,1,2*n)tp[i]=i,rk[i]=s[i];
	RadixSort();
	for(int k=1,t=0;t<2*n;k<<=1,m=t){
		t=0;
		Rep(i,2*n-k+1,2*n)tp[++t]=i;
		Rep(i,1,2*n)if(sa[i]>k)tp[++t]=sa[i]-k;
		RadixSort();
		swap(tp,rk);
		rk[sa[1]]=t=1;
		Rep(i,2,2*n)
			rk[sa[i]]=(tp[sa[i]]==tp[sa[i-1]]&&tp[sa[i]+k]==tp[sa[i-1]+k])?t:++t;	
	}
}

int main()
{
	scanf("%s",s+1);
	n=strlen(s+1);
	Rep(i,1,n)s[i+n]=s[i];
	SA();
	Rep(i,1,2*n)if(sa[i]>=2&&sa[i]<=n+1)printf("%c",s[sa[i]-1]);
	puts("");
	return 0;	
}
```


---

## 作者：mrclr (赞：2)

一看到子串排序，就想办法往后缀数组上靠。

因为后缀数组的排序和长度无关，所以我们把字符串加倍后直接一个后缀排序即可。

然后观察一下输出，其实就是$sa[i]$的上一个字符，所以排完序后如果$sa[i] \leqslant n$就输出$s[sa[i] + n - 1]$就好了。

$O(n \log ^ 2 n)$的，不开O2还TLE了一个点……
```c++
#include<cstdio>
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<cctype>
#include<vector>
#include<stack>
#include<queue>
using namespace std;
#define enter puts("") 
#define space putchar(' ')
#define Mem(a, x) memset(a, x, sizeof(a))
#define In inline
typedef long long ll;
typedef double db;
const int INF = 0x3f3f3f3f;
const db eps = 1e-8;
const int maxn = 2e5 + 5;
inline ll read()
{
  ll ans = 0;
  char ch = getchar(), last = ' ';
  while(!isdigit(ch)) last = ch, ch = getchar();
  while(isdigit(ch)) ans = (ans << 1) + (ans << 3) + ch - '0', ch = getchar();
  if(last == '-') ans = -ans;
  return ans;
}
inline void write(ll x)
{
  if(x < 0) x = -x, putchar('-');
  if(x >= 10) write(x / 10);
  putchar(x % 10 + '0');
}

int n, m, K;
char s[maxn];
int sa[maxn], rnk[maxn], tp[maxn];

bool cmp(int i, int j)
{
  if(rnk[i] ^ rnk[j]) return rnk[i] < rnk[j];
  int x = i + K > m ? -1 : rnk[i + K];
  int y = j + K > m ? -1 : rnk[j + K];
  return x < y;
}

int main()
{
  scanf("%s", s + 1);
  n = strlen(s + 1); m = n << 1;
  for(int i = 1; i <= n; ++i) s[i + n] = s[i];
  for(int i = 1; i <= m; ++i) sa[i] = i, rnk[i] = s[i];
  for(K = 1; K <= m; K <<= 1)
    {
      sort(sa + 1, sa + m + 1, cmp);
      for(int i = 1; i <= m; ++i)
	tp[sa[i]] = tp[sa[i - 1]] + (cmp(sa[i- 1], sa[i]) ? 1 : 0);
      for(int i = 1; i <= m; ++i) rnk[i] = tp[i];
    }
  for(int i = 1; i <= m; ++i) if(sa[i] <= n) putchar(s[sa[i] + n - 1]);
  enter;
  return 0;
}
```

---

## 作者：七条玲奈 (赞：2)

学了后缀数组 做了后缀数组裸题23333

对于这题来说 只需要把长度为*Len的字符串变成长度为2*Len的字符串 跑一遍后缀数组 然后就可以输出结果辣！[快乐！]

上代码！[板子打得丑QAQ]
```c
#include <bits/stdc++.h>
using namespace std;
char ss[1000005];
int c[1000005],Rank[1000005],K,N,M,SA[1000005],Temp[1000005],a[1000005];
void Build(int x)
{
	for (int i=0;i<=x;i++)
	  c[i]=0;
	for (int i=1;i<=N;i++)
	  c[Rank[Temp[i]]]++;
	for (int i=1;i<=x;i++)
	  c[i]+=c[i-1];
	for (int i=N;i>=1;i--)
	  SA[c[Rank[Temp[i]]]--]=Temp[i];
}
void BuildSA()
{
   for (int i=1;i<=N;i++)
     Rank[i]=a[i],Temp[i]=i;
   Build(M=300);
   for (int T=1;T<N;T*=2)
     {
	int p=0;
	for (int i=N-T+1;i<=N;i++)
	  Temp[++p]=i;
	for (int i=1;i<=N;i++)
	  if (SA[i]>T) 
	    Temp[++p]=SA[i]-T;
	Build(M=p);
	swap(Rank,Temp);
	Rank[SA[1]]=1;
	p=1;
	for (int i=2;i<=N;i++)
	    {
	    if (Temp[SA[i]]==Temp[SA[i-1]]&&Temp[SA[i]+T]==Temp[SA[i-1]+T]) Rank[SA[i]]=p;
	    else Rank[SA[i]]=++p;
		}
	}
}
int main()
{
	scanf("%s",ss+1);
	N=strlen(ss+1);
	for (int i=1;i<=N;i++)
	a[i]=ss[i],a[i+N]=a[i],ss[i+N]=ss[i]//把这个字符串复读一遍[误]
	N*=2;
	BuildSA();
	for (int i=1;i<=N;i++)
	  if (SA[i]<=(N/2))
	   cout<<ss[SA[i]+N/2-1];
	return 0;  
}
```

---

## 作者：览遍千秋 (赞：1)

## 题目描述

[BZOJ1031](https://www.lydsy.com/JudgeOnline/problem.php?id=1031)

[LG4051](https://www.luogu.org/problem/P4051)

---

## 题解

发现这是一个环，根据经验，破环为链，于是字符环变为了字符串

之后对这个复制之后的字符串求后缀数组。

**$\mathrm{len}$代表原字符串长度，$\mathrm{n}$代表复制后的字符串长度**

最后输出的时候，判断一下，如果$SA_i \le len$，则输出$str_i$。

---

## $\mathrm{code}$

```cpp
#include<bits/stdc++.h>
using namespace std;

#define maxn 1000007

void read(int &x){
	x=0;char ch=1;int fh;
	while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();
	if(ch=='-') fh=-1,ch=getchar();
	else fh=1;
	while(ch>='0'&&ch<='9'){
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	x*=fh;
}

char s[maxn];
int n,m,sa[maxn],x[maxn],y[maxn],ct[maxn];

int chk(int x){
	return x>0?x:x+n;
}

void SA(){
	for(register int i=1;i<=n;i++) ct[x[i]=s[i]]++;
	for(register int i=2;i<=m;i++) ct[i]+=ct[i-1];
	for(register int i=n;i>=1;i--) sa[ct[x[i]]--]=i;
	for(register int k=1;k<=n;k<<=1){
		int tot=0;
		for(register int i=n-k+1;i<=n;i++) y[++tot]=i;
		for(register int i=1;i<=n;i++) if(sa[i]>k) y[++tot]=sa[i]-k;
		for(register int i=1;i<=m;i++) ct[i]=0;
		for(register int i=1;i<=n;i++) ct[x[i]]++;
		for(register int i=1;i<=m;i++) ct[i]+=ct[i-1];
		for(register int i=n;i>=1;i--) sa[ct[x[y[i]]]--]=y[i],y[i]=0;
		swap(x,y);x[sa[1]]=tot=1;
		for(register int i=2;i<=n;i++)
			if(y[sa[i]]==y[sa[i-1]]&&y[sa[i]+k]==y[sa[i-1]+k]) x[sa[i]]=tot;
			else x[sa[i]]=++tot;
		if(tot==n) break;
		m=tot;
	}
}

int rnk[maxn];
int let;
int main(){
	ios::sync_with_stdio(0);
	cin>>(s+1);n=strlen(s+1);let=n;
	for(register int i=n+1;i<=n*2;i++) s[i]=s[i-n];
	n*=2;
	m=122;SA();
	for(register int i=1;i<=n;i++){
		rnk[sa[i]]=i;
	}
	for(register int i=1;i<=n;i++){
		if(sa[i]<=let)
			cout<<s[sa[i]+let-1];
	}
	cout<<endl;
	return 0;
}
```

---

## 作者：SugarSBN (赞：1)

这个题事实上并不需要后缀数组。。。。


实际上这个题恶心在于有重复，然后可以把重复部分预处理出来

R[i]表示S[R[i]] == S[i]且R[i]是i往右若干位第一个和i字符相同的位置

然后就可以瞎搞啦

具体看代码咯

关键就是cmp。。。

效率放佛还高一点点？。。

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<string>
#include<queue>
#include<stack>
#include<algorithm>
#include<vector>
#include<map>
#include<set>
#include<cmath>
#include<sstream>
#include<fstream>
using namespace std;
const int MAXN=5000+11;
const double pi=acos(-1.0);
typedef long long ll;
typedef unsigned long long ull;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef double dbl;
const dbl eps = 1e-8;
const int MOD = 12345678;
const int INF = 0x3f3f3f3f;
#define For(a,b,c) for (int (a)=(b);(a)<(c);(a)++)
#define foreach(iter,V) for (__typeof((V.begin()) iter=(V).begin();iter!=(V).end();iter++)
#define mp make_pair
#define fi first
#define se second
#define pb push_back
char S[100011];
int len,R[100011];
struct node{
	char c;
	int pos;
}ans[100011];
bool cmp(node A,node B){
	int p1 = A.pos;
	int p2 = B.pos;
	int totlen = 0;
	while(S[p1] == S[p2] && totlen <= len){
		int len1 = (R[p1] - p1 + len + 1) % len;
		int len2 = (R[p2] - p2 + len + 1) % len;
		if (len1 <= len2){
			p1 = (p1 + len1) % len;
			p2 = (p2 + len1) % len;
			totlen += len1;
		}else{
			p1 = (p1 + len2) % len;
			p2 = (p2 + len2) % len;
			totlen += len2;
		}
	}
	return S[p1] < S[p2];
}
int main(){
//	freopen("in.txt","r",stdin);
	scanf("%s",S);
	len = strlen(S);
	int pos = -1;
	For(i,0,len)	if (S[i] != S[(i + 1) % len]){
		pos = i;
		break;
	}
	if (pos == -1){
		printf("%s\n",S);
		return 0;
	}
	for (int i = pos,j = 1;j <= len;j++){
		if (S[i] != S[(i + 1) % len])	R[i] = i;
		else R[i] = R[(i + 1) % len];
		i = (i - 1 + len) % len;
	}
	For(i,0,len){
		ans[i].c = S[i];
		ans[i].pos = (i + 1) % len; 
	}
	sort(ans,ans + len,cmp);
	For(i,0,len)	printf("%c",ans[i].c);
	return 0;
} 
```


---


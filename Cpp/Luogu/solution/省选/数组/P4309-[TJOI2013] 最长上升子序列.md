# [TJOI2013] 最长上升子序列

## 题目描述

给定一个序列，初始为空。现在我们将 $1$ 到 $N$ 的数字插入到序列中，每次将一个数字插入到一个特定的位置。每插入一个数字，我们都想知道此时最长上升子序列长度是多少？

## 说明/提示

$100\%$ 的数据 $n\le10^5$。

## 样例 #1

### 输入

```
3
0 0 2```

### 输出

```
1
1
2```

# 题解

## 作者：我是PG (赞：66)

有很多巨佬用什么rope，线段树，splay等高级~~（掉头发）~~数据结构，蒟蒻只能来一篇vector加树状数组的题解

```cpp
#include<bits/stdc++.h>
int ans[1000001],n,tree[1000001];
std::vector<int>a;
inline void update(int x,int val){while(x<=n)tree[x]=std::max(tree[x],val),x+=x&-x;}
inline int query(int x){
	int t=0;
    while(x)t=std::max(t,tree[x]),x-=x&-x;
    return t;
}
int main(){
    scanf("%d",&n);
    for(register int i=1,t;i<=n;++i)scanf("%d",&t),a.insert(t+a.begin(),i);
    for(register int i=0,t;i<n;++i)t=a[i],update(t,ans[t]=query(t)+1);
    for(register int i=1;i<=n;++i)printf("%d\n",ans[i]=std::max(ans[i],ans[i-1]));
    return 0;
}
```

~~我想应该是最短最简单的题解了吧~~

---

## 作者：CodyTheWolf (赞：34)

## 一道换了N种做法的题（然后还肝了一个下午QwQ
### 本题解法：
### 1.构造出原来的数列
### 2.跑LIS

或者

### 1'.边构造边跑LIS

------------

## 之所以肝了这么久，就是因为很多题解，包括题目都有让人误解或者看不懂的地方，下面我们先讲一下题目问题和一些操作，方便后面讲做法调用XD
如果着急可以先看下面的做法，然后对应上来看操作


------------

### 题目理解问题：

题目说：“接下是N个数字，第k个数字Xk，表示我们将k插入到位置Xk”，意思是，当在Xk插入一个数时，**先讲Xk以及后面的数往后移一位，把k放在Xk上**。

以样例为例：

X=1,Xk=0:{1}

X=2,Xk=0:{2,1}

X=3,Xk=2:{2,1,3}

### 操作1：模拟题目所述的数列添加
很容易，模拟，就是利用平衡树（一般是利用子树size）把点添加进数列。

Splay和旋转Treap应该很容易实现吧~？（其实是自己没打XD，自己想想很快能实现)。我这里用的是非旋Treap（FHQ Treap），和模板不同的就在分裂Treap的操作（split）

原来的FHQ Treap我们是以第一关键字key分裂两个堆，现在我们以子树大小分裂，即：

如果左子树size+当前点的size（其实就是1）小于数X要放入的位置Xk，设当前位置为pst，如果（key >= sz[l[pst]] + 1）那么我们需要分裂左堆（y = pst, split(l[pst], key, x, l[pst]);）

否则，我们分裂右堆，**注意这里的递归一定要让key减去（sz[l[pst]] + 1）**,即：（x = pst, split(r[pst], key - sz[l[pst]] - 1, r[pst], y);）

val数组我们放这个**原数**即可

相信会FHQ Treap的同学很快就能看懂

### 操作2：什么？你不会平衡树？不能模拟插入？
~~那就学另外一篇题解用rope呀~~

rope Noip不能用不想学怎么办？

我们常用的vector也有这个功能！！

函数：向量名.insert(位置，值)
这样我们就能直接模拟题目的要求啦~（不过还是希望大家练练平衡树

具体用法(以自己的为例）：pst.insert(pst.begin() + x, i);（pst为vector名，x为位置，应该很好理解吧？）

### 操作3：求LIS（最长上升子序列）

对于LIS，网上已经有烂大街的DPn方法和单调队列nlogn法，这里用线段树或者树状数组也可以办到。

当求出原数列后（操作1，2），我们再求出他们的添加顺序rak，设原数组为a，那么rak[a[i]]=i，这样rak[x]就是数x加入的位置了，此时我们就得到了加入有序的数的位置。可以类比输入数据，但是这里的值的位置已经是最后的位置，即不会更改了。

因为我们加入的数是有序的，把数X加入到Xk时，它是不会影响到后面值的答案的**（注意是子序列而不是子串**），并且加入的数X是当前最大的，所以它能接上任何一个子序列，我们考虑接Xk以前的子序列即可（因为后面不可能能接上）。

设我们以Xk为结尾的LIS最长的储存数组是dp，
那么dp[Xk]=max(dp[1],dp[2]...dp[Xk-1]) +1，也就是要求一个前缀最大值，这个时候线段树或者树状数组，再不行ST表，随便打一个就可以解决了~

### 操作4：为什么2个步骤不能在一起做呢？

还是像操作1那样跑平衡树，但是要维护一个dp数组表示子树及自己的LIS最大值。这个时候只需在旋转（或者分裂堆的时候，也就是各个平衡树维护平衡的操作）时，更新dp即可。这样先加入一个数，再提取出它的左儿子，设为temp，即可。因为加入的数是递增的，像操作3那样，只需更新一下ans=max(ans,temp+1)，输出ans。

------------
## 有了这么多操作，那么能怎么搭配使用呢？（做法）

1:操作1+操作3（平衡树+线段树或树状数组或单调队列）

2:操作2+操作3（vector+线段树或树状数组或单调队列）

3:操作4（平衡树）

其实百度上还能查到**倒推原数列**的方法，不过蒟蒻没有看懂QwQ（自己推的时候并不是像他们说的那样），后面再配上操作3即可。

### 下面给出做法1，2的代码：
### 模板都用struct封装好了，所以还是比较好读的，就不给这么多注释了
------------
# Code1：
```cpp
#pragma warning (disable:4996)
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define mid ((x+y)>>1)
#define lson (pst<<1)
#define rson (pst<<1|1)
using namespace std;
const int maxn = 1e5 + 5, inf = 0x7fffffff - 1;
int a[maxn];
int n, ans;

inline int max(int x, int y) { return x > y ? x : y; }

struct FHQ_Treap
{
	int val[maxn], sz[maxn], heap[maxn], l[maxn], r[maxn], num, root, x, y, z;

	inline int max(int x, int y) { return x > y ? x : y; }
	inline void update(int x) { sz[x] = sz[l[x]] + sz[r[x]] + 1; }
	inline int new_node(int key) { heap[++num] = rand(), sz[num] = 1, val[num] = key; return num; }

	inline int merge(int x, int y)
	{
		if (!x || !y)	return x + y;
		if (heap[x] < heap[y]) { r[x] = merge(r[x], y), update(x); return x; }
		else { l[y] = merge(x, l[y]), update(y); return y; }
	}

	inline void split(int pst, int key, int &x, int &y)
	{
		if (!pst) { x = y = 0; return; }
		if (key >= sz[l[pst]] + 1)	x = pst, split(r[pst], key - sz[l[pst]] - 1, r[pst], y);//注意这里的分裂堆！
		else y = pst, split(l[pst], key, x, l[pst]);
		update(pst); return;
	}

	inline int kth(int pst, int rak)
	{
		if (rak <= sz[l[pst]])	return kth(l[pst], rak);
		if (rak == sz[l[pst]] + 1)	return pst;
		return kth(r[pst], rak - sz[l[pst]] - 1);
	}

	inline void add(int pst, int key) { split(root, pst, x, y), root = merge(x, merge(new_node(key), y)); }

}Treap;
//求最大值的线段树
struct SegementTree
{
	int a[maxn << 2];

	inline void update(int x, int y, int pst, int p, int k)
	{
		if (x == y) { a[pst] = k; return; }
		if (p <= mid)	update(x, mid, lson, p, k);
		else update(mid + 1, y, rson, p, k);
		a[pst] = max(a[lson], a[rson]); return;
	}

	inline int query(int x, int y, int pst, int l, int r)
	{
		if (x > y || y < l || x>r)	return -1;
		if (l <= x && y <= r)	return a[pst];
		return max(query(x, mid, lson, l, r), query(mid + 1, y, rson, l, r));
	}
}Stree;

int main()
{
	scanf("%d", &n);
	for (int i = 1, x; i <= n; i++)	scanf("%d", &x), Treap.add(x, i);//加入数
	for (int i = 1; i <= n; i++)	a[Treap.val[Treap.kth(Treap.root, i)]] = i;//反推求出位置
	for (int i = 1; i <= n; i++)
	{
		if (a[i] == 1)	ans = max(ans, 1), Stree.update(1, n, 1, 1, 1);//因为线段树不能求1的前缀（也就是0），不然会卡死，这里特判一下，其实像第二份代码把位置+1也可以
		else { int temp = Stree.query(1, n, 1, 1, a[i] - 1) + 1; ans = max(ans, temp), Stree.update(1, n, 1, a[i], temp); }
		printf("%d\n", ans);
	}
	return 0;
}

```

# Code2
```cpp
#pragma warning (disable:4996)
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <algorithm>
#define mid ((x+y)>>1)
#define lson (pst<<1)
#define rson (pst<<1|1)
using namespace std;
const int maxn = 1e5 + 5, inf = 0x7fffffff - 1;
vector<int> pst;
int a[maxn];
int n, m, ans;

inline int max(int x, int y) { return x > y ? x : y; }

struct SegementTree
{
	int a[maxn << 2];

	inline void update(int x, int y, int pst, int p, int k)
	{
		if (x == y) { a[pst] = k; return; }
		if (p <= mid)	update(x, mid, lson, p, k);
		else update(mid + 1, y, rson, p, k);
		a[pst] = max(a[lson], a[rson]); return;
	}

	inline int query(int x, int y, int pst, int l, int r)
	{
		if (x > y || y < l || x>r)	return -1;
		if (l <= x && y <= r)	return a[pst];
		return max(query(x, mid, lson, l, r), query(mid + 1, y, rson, l, r));
	}
}Stree;

int main()
{
	scanf("%d", &n); m = n + 1;
	for (int i = 1, x; i <= n; i++)	scanf("%d", &x), pst.insert(pst.begin() + x, i);//vector的插入操作
	for (int i = 1; i <= n; i++)	a[pst[i - 1]] = i + 1;//vector是从0开始的，所以-1。为了不让我们的位置出现1（这样线段树需要像第一份代码那样特判当位置为1时，不然查前缀的时候会查[1,0]线段树可能会炸）所以位置+1
	for (int i = 1; i <= n; i++)
	{
		int temp = Stree.query(1, m, 1, 1, a[i] - 1) + 1; ans = max(ans, temp), Stree.update(1, m, 1, a[i], temp);
		printf("%d\n", ans);
	}
	return 0;
}


```




---

## 作者：JYTS (赞：23)

~~比较简单的平衡树题目吧，毕竟一发入魂~~

快PION了，打点数据结构练练手。。。

~~上面都是废话~~

题目大意就是说每次往序列中加入递增的数，求当前数列的最长上升子序列。~~一般像这种动态往里面加东西的然后求个什么多半是平衡树之类的~~

我们设$dp[i]$为从第$i$个位置结尾的最长上升子序列，~~很简单的动态规划搞下可得~~往第$i$个位置加一个当前最大的数后
> $dp[i]=max(dp[i],dp[j]+1),(j<=i)$

在保证复杂度的情况下我们只需要动态维护从 $1$ 到 $i$ 中最大的$dp[j]$即可直接转移，所以就把 $dp$ 数组丢到平衡树上即可($pushup$的时候记得记下$dp$数组)，~~本人打的Fhq也比较裸，反正只有基本操作，大家就当练练板子吧~~

~~一发入魂~~代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int read()
{
    int sum=0;char ch=getchar();
    while(ch<'0'||ch>'9'){ch=getchar();}
    while(ch<='9'&&ch>='0'){sum=sum*10+ch-'0';ch=getchar();}
    return sum;
}
const int N = 100010;
int tot,seed=233,root;
int Rand()
{
    return seed=int(seed*48271ll%2147483647);
}
int dp[N];
struct node
{
    int lch,rch,siz,val,key,pos;
}t[N];
void pushup(int p)
{
    t[p].siz=t[t[p].lch].siz+t[t[p].rch].siz+1;
    t[p].val=max(dp[t[p].pos],max(t[t[p].lch].val,t[t[p].rch].val));
}
int _add_new_point(int val,int i)
{
    t[++tot].siz=1;
    t[tot].val=val;
    t[tot].key=Rand();t[tot].pos=i;dp[i]=val;//这里你们也可以直接精简成一个变量记下来，你们自己好理解就行
    t[tot].rch=t[tot].lch=0;
    return tot;
}
void split(int now,int &a,int &b,int val)
{
    if(now==0){a=b=0;return;}
    if(t[t[now].lch].siz<val)
    {
        a=now;split(t[now].rch,t[now].rch,b,val-t[t[now].lch].siz-1);
    }
    else
    {
        b=now;split(t[now].lch,a,t[now].lch,val);
    }
    pushup(now);
}
void _merge(int &now,int a,int b)
{
    if(a==0||b==0){now=a+b;return;}
    if(t[a].key<t[b].key)
    {
        now=a;_merge(t[now].rch,t[a].rch,b);
    }
    else
    {
        now=b;_merge(t[now].lch,a,t[b].lch);
    }
    pushup(now);
}
int n;
int main()
{
    n=read();
    for(int i=1;i<=n;i++)
    {
        int ju1=read();
        int x=0,y=0,z=0;
        split(root,x,y,ju1);
        z=_add_new_point(t[x].val+1,i);
        _merge(x,x,z);
        _merge(root,x,y);
        printf("%d\n",t[root].val);
    }
    return 0;
}

```

---

## 作者：万弘 (赞：16)

//将$log$统一改为$\log$

设$f(i)$表示以第$i$个元素结尾的LIS长度 

考虑在$pos$位置后插入元素$x$（由题意，**$x$是当前序列中的最大元素**）  

对序列LIS的影响分三段：
- 左半段$[1,pos]$：事实上完全没有影响。
- 右半段$[pos+1,n]$：($n$是还没有加入这个元素时的序列长度）由于$x$是当前序列中的最大元素，因此也无法影响他们。
- 新的这个位置（不妨记为$pos'$,处理完影响后我们再维护序列）：由于$x$是当前序列中的最大元素，因此左半段都能转移过来，即
$$f(pos')=\max_{i=1}^{pos} f(i)+1$$

接下来暴力把$[pos+1,n]$右移一格，加入$f(pos')$即可，时间复杂度$\mathcal O(n^2)$.

而两个关键部分都是完全可以优化的：求$f(pos'),$把$[pos+1,n]$右移一格。求$f(pos')$用线段树很直观，而很多题解“把$[pos+1,n]$右移一格”的操作使用了vector，时间复杂度是错的（即最坏仍是$\mathcal O(n^2)$）。

把$[pos+1,n]$右移一格，这种维护序列的经典操作，完全可以使用Splay或FHQ_Treap在$\mathcal O(\log n)$的时间内完成。并且线段树也不需要了，平衡树可以顺带统计掉，具体做法是，每个节点（假设维护$[l,r]$这个区间，节点本身是位置$pos$）维护两个额外信息$val=f(pos),maxv=\max_{k=l}^rf(k)$  
插入时，将序列分割，左半段和右半段不变，新建一个节点表示$pos'$,令$val=maxv=\text{左半段的}maxv+1$。

总时间复杂度$\mathcal O(n\log n)$  
我使用了FHQ_Treap实现
```cpp
/**********/
#define MAXN 100011
struct FHQ_Treap
{
	struct node
	{
		ll son[2],size;
		ll val,maxv,data;
	}t[MAXN];
	ll root,cnt;
	ll newnode(ll val)//新建节点
	{
		++cnt;
		t[cnt].son[0]=t[cnt].son[1]=0;
		t[cnt].val=t[cnt].maxv=val,t[cnt].size=1;
		t[cnt].data=rand();
		return cnt;
	}
	FHQ_Treap()
	{
		srand(time(0));
		root=cnt=0;
	}
	#define rt t[cur]
	#define tl t[rt.son[0]]
	#define tr t[rt.son[1]]
	void pushup(ll cur)//向上维护
	{
		rt.maxv=max(rt.val,max(tl.maxv,tr.maxv));
		rt.size=tl.size+tr.size+1;
	}
	void split(ll cur,ll k,ll& x,ll& y)//分裂
	{
		if(!cur)
		{
			x=y=0;return;
		}
		if(k<=tl.size)
		{
			y=cur;
			split(rt.son[0],k,x,rt.son[0]);
		}
		else x=cur,split(rt.son[1],k-tl.size-1,rt.son[1],y);
		pushup(cur);
	}
	ll merge(ll x,ll y)//合并
	{
		if(!x||!y)return max(x,y);
		if(t[x].data<=t[y].data)
		{
			t[y].son[0]=merge(x,t[y].son[0]);
			pushup(y);
			return y;
		}
		else
		{
			t[x].son[1]=merge(t[x].son[1],y);
			pushup(x);
			return x;
		}
	}
	ll insert(ll pos)//插入
	{
		ll x,y;
		split(root,pos,x,y);
		ll z=newnode(t[x].maxv+1);//处理pos'
		root=merge(merge(x,z),y);
		return t[root].maxv;//返回全局max
	}
}t;
int main()
{
	ll n=read();
	for(ll i=1;i<=n;++i)
	{
		ll pos=read();
		printf("%lld\n",t.insert(pos));
	}
	return 0;
}
```

---

## 作者：cmd2001 (赞：13)

懒得写平衡树的我来一发题解吧。

首先由于插入顺序，后面的插入和前面的答案是没关系的，所以我们可以先构建出整个序列，然后输出以每个权值为结尾的最长上升子序列长度的前缀max就好了。

关于这个序列怎么构建，我们可以用splay,treap等平衡树实现。然而，别忘了STL中有一个叫做rope的神奇容器。

rope怎么用呢？它有一个成员函数insert(pos,val)表示将值val插入到位置pos之后，正好满足此题题意。

然后就十分愉悦了。

代码:

```cpp
#include<cstdio>
#include<algorithm>
#include<ext/rope>
const int maxn=1e5+1e2;

int ans[maxn],n;
__gnu_cxx::rope<int> seq;

struct BinaryIndexTree {
    int dat[maxn];
    #define lowbit(x) (x&-x)
    inline void update(int x,int val) {
        while( x <= n ) dat[x] = std::max( dat[x] , val ) , x += lowbit(x);
    }
    inline int query(int x) {
        int ret = 0;
        while(x) ret = std::max( ret , dat[x] ) , x -= lowbit(x);
        return ret;
    }
}bit;

int main() {
    scanf("%d",&n);
    for(int i=1,t;i<=n;i++) scanf("%d",&t) , seq.insert(t,i);
    for(int i=0,t;i<n;i++) t = seq[i] , bit.update(t,ans[t]=bit.query(t)+1);
    for(int i=1;i<=n;i++) printf("%d\n",ans[i]=std::max(ans[i],ans[i-1]));
    return 0;
}
```

---

## 作者：BetterGodPig (赞：8)

#### Update on 2023.10.23 修改了配图的样例解释中的错误。

### 前言

这个题真的卡了我好久，最开始写的正解因为一些莫名其妙的原因 $RE$ 了。。

-------
### $Solution$

发现值域 $[1,n]$ 始终是固定的，看到题解里全是平衡树维护，果断掏出看家本领权值线段树。

前置知识：[线段树 - OI Wiki](https://oi-wiki.org/ds/seg/)，$O(n \log n)$ 最长上升子序列做法。后者不熟悉的同学可以去看看[P1020 [NOIP1999 普及组\] 导弹拦截](https://www.luogu.com.cn/problem/P1020)后 $100$ 分的加强数据。

### 什么是权值线段树？

以权值为维护信息的线段树，本质仍是线段树。

不同于普通线段树所维护的区间信息，权值线段树维护的是值域固定，并统计 __一列数字中数的个数__。

我们可以联想到桶排序中桶的概念，权值线段树的一个节点维护就是一个桶，在一个节点所表示的区间 $[l,r]$ 中，该节点本身的值即表示这个区间内数的个数。

举个栗子：有这样一个数列，
$$
1\space1\space1\space2\space3\space3\space4\space5\space......
$$
权值线段树上表示区间 $[1,1]$ 的节点值为 $3$ 表示有 $3$ 个 $1$ ，表示区间 $[2,2]$ 的节点值为 $1$ ，而他们的父节点表示 $[1,2]$ ，值为 $4$ ，表示有 $4$ 个 $1$ 和 $2$ ，以此类推。

### 建树

```cpp
void build(int p = 1,int l = 1,int r = n){
	if(l == r) return t[p] = a[l],void();//a[l]表示l的个数
    register int mid(l+r>>1);
    build(p<<1,l,mid);
    build(p<<1|1,mid+1,r);
    t[p] = t[p<<1]+t[p<<1|1];//建议写个push_up因为修改的时候也有相同操作，如果维护的信息更复杂会方便一些
}
int main(){
	build();//直接建
}
```

### 修改

```cpp
void modify(int val,int k,int p = 1,int l = 1,int r = n){//将权值val增加k个
    if(l == r) return t[p]+=k,void();//如果到了叶子，直接加
    register int mid(l+r>>1);
    if(k <= mid) modify(val,k,p<<1,l,mid);//如果k在该节点左子树所表示的区间内
    else modify(val,k,p<<1|1,mid+1,r);//如果在右子树中
    push_up(p);//t[p] = t[p<<1]+t[p<<1|1]; 这里一定要记得
}
```

### 用排名查询数值

```cpp
int query(int k,int p = 1,int l = 1,int r = n){//查询第k小的数是多少
    if(l == r)return l;//递归到了叶子节点
    register int mid(l+r>>1);
    if(k <= t[p<<1]) return query(k,p<<1,l,mid);//如果左子树的大小大于等于k，说明排名k一定在左，否则在右
    else return query(k-t[p<<1],p<<1|1,mid+1,r);//把左边的数量减掉，相当于在右边找第k-t[p<<1]的数
}
```

实际上权值线段树还可以用值查排名，同样也可以求前驱后继，没错，它就是平衡树的平替版，而且编码难度低，实际上统计区间数字个数很像平衡树统计子树大小来求排名、前驱、后继等操作，只是有一个问题，权值线段树需要提前知晓所有数值的范围，所以很适合用来处理 $n$ 个数分别为 $1$ 到 $n$ 的问题，而且如果数据分散的话空间浪费很大，一般搭配动态开点食用，具体操作上面丢的线段树网址里面有。

甩一道练习题：[P3224 [HNOI2012\] 永无乡](https://www.luogu.com.cn/problem/P3224)

### 回到本题

考虑维护插入后的序列，因为后插入的会影响先差入的点，就考虑逆序处理，先插入的直接挤到后面即可。再就是逆序处理很容易发现一个性质，就是__插入位置的编号即使当前空位的编号__，这样子空说可能不好理解，我们来看一个样例：

```
5
0 0 1 2 2
```

初始状态全是空位

倒序处理时，先将 `5` 插入第二个空位。

![](https://cdn.luogu.com.cn/upload/image_hosting/wld4hwl3.png)

再将 `4` 插入第二个空位。

![](https://cdn.luogu.com.cn/upload/image_hosting/rmwtcd5i.png)

把 `3` 插入第一个。

![](https://cdn.luogu.com.cn/upload/image_hosting/8oguld29.png)

接着插入 `2` 。

![](https://cdn.luogu.com.cn/upload/image_hosting/jh3rmrbf.png)

最后再插入 `1` （就不放图了大家都会）。

那么我们就需要快速求出排名 `k` 的空位，联系前文，用权值线段树维护，初始整个区间赋值为 $1$ ，每次查询排名第 $k$ ，查询结束后把其修改为 $0$ 即可。

### 求最长上升子序列

这一部分很简单，建议自己想。

考虑动态规划，$f[i]$ 表示长度为 $i$ 的最小的最后一位数，易证明 $f$ 数组具有单调性，每次再里面二分查找。

以 $mx_i$ 表示以 $i$ 结尾的最大上升子序列长度，记得开个 $ans$ 记录全局最大，因为最长上升子序列可能不以这个点结尾。

`code`

```cpp
/*
by tanhaotian
*/
#pragma GCC optimize(2)
#pragma GCC optimize(3)//想学习题解的同学请把这几行删掉
#include <bits/stdc++.h>
#define f_inline inline __attribute__((always_inline))
#define ll long long
using namespace std;
const int maxn = 1e5+5;
namespace quick{
	inline int read(){
		int x;
		char c=getchar();x=0;int f=0;
		for(;!isdigit(c);c=getchar()) f|=(c=='-');
		for(;isdigit(c);c=getchar()) x=((x<<3)+(x<<1)+(c^48));
		return x=f?-x:x;
	}
	inline ll _read(){
		ll x;
		char c=getchar();x=0;int f=0;
		for(;!isdigit(c);c=getchar()) f|=(c=='-');
		for(;isdigit(c);c=getchar()) x=((x<<3)+(x<<1)+(c^48));
		return x=f?-x:x;
	}
	template< typename T >inline void write(T x){
		if(x<0) putchar('-'),x=-x;
		if(x>9) write(x/10);
		putchar(x%10^48);
	}
	template< typename T >inline void print(T x){
		write(x);putchar('\n');
	}
	template< typename T >inline void _print(T x){
		write(x);putchar(' ');
	}
	inline void swap(int &a,int &b){a^=b,b^=a,a^=b;}
	inline int max(const int &a,const int &b){return a>b?a:b;}
	inline int min(const int &a,const int &b){return a<b?a:b;}
	inline int abs(int x){return x>0?x:-x;}
	inline ll labs(ll x){return x>0?x:-x;}
}
using namespace quick;
int t[maxn<<2],n;
f_inline void upd(int p){t[p] = t[p<<1]+t[p<<1|1];}
void build(int p = 1,int l = 1,int r = n){
	if(l == r) return t[p] = 1,void();
	int mid((l+r)>>1);
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	upd(p);
}
void modify(int k,int p = 1,int l = 1,int r = n){
	if(l == r) return t[p] = 0,void();
	int mid((l+r)>>1);
	if(k <= mid) modify(k,p<<1,l,mid);
	else modify(k,p<<1|1,mid+1,r);
	upd(p);
}
int query(int k,int p = 1,int l = 1,int r = n){
	if(l == r) return l;
	int mid((l+r)>>1);
	if(k <= t[p<<1]) return query(k,p<<1,l,mid);
	else return query(k-t[p<<1],p<<1|1,mid+1,r);
}
int ans;
int stpos[maxn];
int pos[maxn];
int f[maxn];
int mx[maxn];
f_inline int binary(int x){
	int l = 1,r = n;
	while(l < r){
		register int mid((l+r)>>1);
		f[mid] < x? l = mid+1 : r = mid;
	}
	return l;
}
int main(){
   freopen("lis.in","r",stdin);
   freopen("lis.out","w",stdout);
	n = read();
	build(); 
	for(register int i(1);i <= n;++i){
		stpos[i] = read(); ++stpos[i]; f[i] = 0x3f3f3f3f;
	}
	for(register int i(n);i;--i){
		register int t = query(stpos[i]);
		pos[t] = i;
		modify(t);
	}
//	for(register int i(1);i <= n;++i)
//		print(pos[i]);
	for(register int i(1);i <= n;++i){
		register int t = binary(pos[i]);
		f[t] = pos[i];
		mx[pos[i]] = t;
	}
//	for(register int i(1);i <= n;++i)
//		print(mx[i]);
	for(register int i(1);i <= n;++i){
		if(mx[i] > ans) ans = mx[i];
		print(ans);
	}
	return 0;
}
```



---

## 作者：c2020HXW (赞：8)

### 大家好像都在用平衡树写

#### 这里提供一种不用平衡树 ~~(玄学vector)~~ 来模拟构建数列的方法

###### ~~主要还是怕重复的解法再次惨遭被拒~~

正着来不好搞~~似乎只能模拟~~考虑倒着来搞，显然最后一个数n的最终位置就是$x_n+1$ (数列编号从1到n)

仔细思考不难发现，如果倒着来，开一个vst[i]记录当前i位置确未确定的话

第i个数的位子就是第$x_i+1$个没有被确定的位置。可以理解为放第$i$个数时把前$i-1$个数在$i$后面的往后顶了一个，所以从后往前算时就要加上$i+1$到$n$把它往后顶的。

可以用树状数组维护vst[]来解这个过程，确定一个位置就把这个位置标为1，用类似倍增的方式求解第$x_i+1$个零的位子，具体看代码在手推一下样例应该就能懂。

至于求解最长上升子序列的长度，因为新加入的数大于以前加入的，不影响前面的答案，就依着最后构建出的数列求。还是可以用 ~~权值？？~~ 树状数组：

从前往后扫描，设构建出的序列为b[]

每次ask比b[i]小的f[b[j]]的最大值，+1再将这个值赋回b[i]上。树状数组可维护前缀最大值。

贴一下代码：
```cpp
#include<algorithm>
#include<iostream>
#include<iomanip>
#include<cstring>
#include<cstdlib>
#include<cstdio>
#include<cmath>
using namespace std;
const int Maxx=200000,Maxn=200,INF=0x3f3f3f3f,mod=1e9+7;
inline int read()
{
	int res=0,bj=0;char ch=getchar();
	while(ch<'0'||ch>'9')bj|=(ch=='-'),ch=getchar();
	while(ch>='0'&&ch<='9')res=(res<<3)+(res<<1)+(ch^48),ch=getchar();
	return bj?-res:res;
}
void print(int x)
{
	if(x>9)print(x/10);
	putchar(x%10^48);
}
inline void printnum(int x,char ch)
{
	if(x<0)putchar('-'),x=-x;
	print(x),putchar(ch);
}
int n,a[Maxx],b[Maxx],c[Maxx],ans[Maxx],Log[Maxx];
inline void add(int x,int val)
{for(int i=x;i<=n;i+=i&(-i))c[i]+=val;}
inline int ask(int x,int lim)
{
	int res=0,sum=0;
	for(int i=Log[x+lim];~i;i--)
	if(sum+(1<<i)-c[res+(1<<i)]<x)res+=1<<i,sum+=(1<<i)-c[res];
	return res+1;
}
inline void change(int x,int val)
{for(int i=x;i<=n;i+=i&(-i))c[i]=max(c[i],val);}
inline int query(int x)
{
	int maxx=0;
	for(int i=x;i;i-=i&(-i))maxx=max(maxx,c[i]);
	return maxx;
}
int main()
{
	n=read();Log[0]=-1;
	for(int i=1;i<=n;i++)a[i]=read(),Log[i]=Log[i>>1]+1;
	for(int i=n;i>=1;i--)a[i]=ask(a[i]+1,n-i),add(a[i],1),b[a[i]]=i;
	memset(c,0,sizeof(c));
	for(int i=1;i<=n;i++)ans[b[i]]=query(b[i])+1,change(b[i],ans[b[i]]);
	for(int i=1;i<=n;i++)printnum(ans[i]=max(ans[i],ans[i-1]),'\n');
	return 0;
}
/*
7
0 0 2 1 2 5 1
1
1
2
2
3
4
4
*/

```


---

## 作者：torque (赞：8)

### 前置芝士

线段树、DP（LIS）

原题目;[点此传送](https://www.luogu.org/problem/P4309)

### 思路

我是做完[P4314 CPU监控](https://www.luogu.org/problem/P4314)过来的，对这道题是的思路具有启发作用

题目就是要求在不断往序列中添加元素的过程中，求出LIS

**Step 1**

想想朴素做法：

开一个vector模拟插入过程，然后在vector中跑LIS

时间复杂度$O(n^2)$，预计得分$?$pts

**Step 2**

LIS的具体做法就是一个转移方程：

$\boxed{dp[i]=max(dp[j])+1,d[i]>d[j]}$

其中$d[i]$表示第i个元素，$dp[i]$表示以第i个元素作为结尾的上升子序列中最长的那个的长度（有点绕。。）

想一想每次添加对于答案有什么影响

假设将目前的元素(记作$t$，那么此时序列中有$t-1$个元素)插入至$i$处（它就变成了序列中第$i+1$个元素）

对于它前面的元素（$1\rightarrow i$），由于子序列已经终止，对于他们的$dp$没有贡献

对于它后面的元素（$i+2\rightarrow t$），由于这些元素都小于t（这是因为题目说了**元素按从小到大的顺序插入**），无法作为上升子序列的一部分，对于他们的$dp$也没有贡献

对于它自身，由于它是大于它前面的所有元素的，所以按照转移方程，有

$dp[i+1]=max(dp[j])+1,j<=i$

也就是说我们需要查询区间$[1,i]$的最大值，并将dp[i+1]修改为这个值，只需要用线段树维护就行了

但是细心的小伙伴们一定发现了问题：

当我们在这个序列中插入元素时，它后面的元素都后移了一位

由于插入时只对自己有贡献，所以如果我们能够知道一个元素的最终位置就好了（想一想为什么？）

所以，用vector模拟，跑出每个元素在最后的序列中的位置$p[i]$

对于第i个询问，首先另$val[p[i]]=max(val[j]),j\in [1,p[i])$

然后输出$max(val[i]),i\in [1,n]$

只有区间查询最大值和单点修改，只需要用线段树维护区间max值就行了，具体细节见代码

### 代码
```cpp
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#define N 100001
#define rnt register int
using namespace std;
bool tak[N];
vector <int> V;
int n,p[N],d[N];
struct tree{int l,r,maxn;}t[N*4]; 
void build(int id,int l,int r){
	t[id].l=l,t[id].r=r;
	if(l==r) return ;
	int mid=(l+r)>>1;
	build(id<<1,l,mid);
	build(id<<1|1,mid+1,r);
}
int query(int id,int l,int r){
	if(t[id].l==l && t[id].r==r) return t[id].maxn;
	int mid=(t[id].l+t[id].r)>>1;
	if(r<=mid) return query(id<<1,l,r);
	else if(l>mid) return query(id<<1|1,l,r);
	else return max(query(id<<1,l,mid),query(id<<1|1,mid+1,r));
}
void change(int id,int pos,int val){
	if(t[id].l==t[id].r){
		t[id].maxn=val;
		return ;
	}
	int mid=(t[id].l+t[id].r)>>1;
	if(pos<=mid) change(id<<1,pos,val);
	else change(id<<1|1,pos,val);
	t[id].maxn=max(t[id<<1].maxn,t[id<<1|1].maxn);
}
int main(){
	scanf("%d",&n);
	for(rnt i=1;i<=n;i=-~i) scanf("%d",&p[i]),V.insert(V.begin()+p[i],i);
	for(rnt i=0;i<n;i=-~i) p[V[i]]=i+1;
	build(1,1,n);
	for(rnt i=1;i<=n;i=-~i){
		if(p[i]!=1) change(1,p[i],query(1,1,p[i]-1)+1);
		else change(1,p[i],1);
		printf("%d\n",query(1,1,n));
	}
	return 0;
}
```

### 后记

说实话，这道题能评上紫题完全是由于思维，代码比较短（相对别的线段树题来说），多做几道就有感觉了

最后：

[![](https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2921431843,3149119026&fm=26&gp=0.jpg)](https://www.luogu.org/blog/oneJURUO/)

---

## 作者：nofind (赞：7)

## [题意](https://www.luogu.com.cn/problem/P4309)

设$f_i$表示以$i$为结尾的$LIS$，**插入后**的位置为$pos$。

由于每次都插入一个比之前都大的数，因此如果答案变换，必定为以新加入的数位结尾的$LIS$，即$f_{pos}$。

我们考虑如何快速求出$f_{pos}$：  
求出$[1,pos-1]$中$f$的最大值$maxx$，则$f_{pos}=maxx+1$。

因此我们要支持插入一个数，询问区间最大值，用$Splay$即可。

code:
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=100010;
int n,ans,root,tot;
int fa[maxn],val[maxn],maxx[maxn],size[maxn];
int ch[maxn][2];
inline void up(int x)
{
	size[x]=size[ch[x][0]]+size[ch[x][1]]+1;
	maxx[x]=max(val[x],max(maxx[ch[x][0]],maxx[ch[x][1]]));
}
inline int get(int x){return ch[fa[x]][1]==x;}
inline void rotate(int x)
{
	int y=fa[x],z=fa[y],k=get(x),w=ch[x][k^1];
	if(z)ch[z][get(y)]=x;ch[x][k^1]=y,ch[y][k]=w;
	if(w)fa[w]=y;fa[y]=x;fa[x]=z;
	up(y),up(x);
}
inline void splay(int x,int goal=0)
{
	while(fa[x]!=goal)
	{
		int y=fa[x];
		if(fa[y]!=goal)rotate(get(x)==get(y)?y:x);
		rotate(x);
	}
	if(!goal)root=x;
}
inline int find(int k)
{
	int now=root;
	while(2333)
	{
		if(ch[now][0]&&size[ch[now][0]]>=k)now=ch[now][0];
		else if(size[ch[now][0]]+1<k)k-=size[ch[now][0]]+1,now=ch[now][1];
		else return now;
	}
	return 2333;
}
inline int New()
{
	int x=++tot;
	size[x]=val[x]=maxx[x]=1;
	return x;
}
inline void insert(int pos)
{
	int x=find(pos);
	int y=find(pos+1);
	splay(x,0);splay(y,x);
	int now=New();
	ch[y][0]=now;fa[now]=y;
	up(y),up(x);
}
int main()
{
	scanf("%d",&n);
	root=New();ch[root][1]=New();fa[ch[root][1]]=root;
	val[1]=val[2]=0;
	for(int i=1;i<=n;i++)
	{
		int pos;scanf("%d",&pos);
		insert(pos+1);splay(find(pos+2));
		ans=max(ans,val[root]=max(val[root],maxx[ch[root][0]]+1));
		printf("%d\n",ans);
	}
	return 0;
}
```


---

## 作者：wwlw (赞：7)

题目友链：[Link](https://www.luogu.org/problemnew/show/P4309)

## 动态维护LIS？

观察题目：在第 i 轮操作时，将数字 i 插入

   插入的数字是当前最大的
   
   如果答案与上次不同，新的LIS必以 i 结尾
   
   以 i 结尾的LIS无法再伸长（因为比 i 小的都插入完了）

也就是说，加入 $i+1$ 到 $n$ 的数，不会对以 $i$ 结尾的上升子序列有影响，所以我们不用去动态地维护LIS的大小，只需要最后把总的序列做一次LIS就好了。然后对于第 $i$ 个输出，只需要求得分别以 $1$ 到 $i$ 结尾的子序列的最大值即可。

## 求解LIS

面对1e5的数据，O($n^2$)的大暴力显然是不行的，我们考虑数据结构优化。

树状数组优化流程：

   1.对原数列以值为关键字排序，记录原来的位置（存入一个结构体）
   
   2.排完序后，数列的值显然是1~n依次递增，我们不妨枚举1~n的值。
   
   对于每一个 i，找到它原来的位置记为p，则用树状数组找到在位置p之前的最大值，作为更新的来源。
       
   3.算完后，把$i$这个值加到树状数组$p$的这个位置，重复执行2

代码：
```cpp
inline int lowbit(int x){return x&(-x);}
inline void add(int x,int val){while(x<=n){c[x]=max(c[x],val);x+=lowbit(x);}}
inline int query(int x){int ret=0;while(x){ret=max(ret,c[x]);x-=lowbit(x);}return ret;}

for(int i=1;i<=n;i++) a[i].num=i;//原位置
sort(a+1,a+1+n,Cmp);//排序
int ans=0;
for(int i=1;i<=n;i++){
	int maxx=query(a[i].num);//查找位置为a[i].num前的最大值
	add(a[i].num,++maxx);//把当前的数加入树状数组
	ans=max(ans,maxx);//取最大值
	printf("%d\n",ans);//输出当前最大值
}
```

## 模拟插入操作
   我们采用Splay来实现此部分的功能
   
   在这之前请各位精通[文艺平衡树](https://www.luogu.org/problemnew/show/P3391)
   
   首先插入两个极大极小的数（为了避免玄学数组越界）
   
   对于每次插入操作，例如把val插到x位置的后面，就先把x+1位置的数旋转到根节点，再把x+2位置的数旋转到根节点的右儿子，那么你只需要把数加到根节点的右儿子的左儿子（不懂得可以模拟一下），这样就实现了插入操作（其实就是提取区间操作）

## 完整代码
看起来有丑，将就一下吧
```cpp
#include<stdio.h>
#include<algorithm>
using namespace std;
#define rint register int
#define INF 0x3f3f3f3f
#define N 100007

template<class T>
inline void read(T &x){
    T flag=1;x=0;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')flag=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+c-48;c=getchar();}
    x*=flag;
}

struct Splay{
    int val,fa,s[2],size;
}t[N];
struct Node{
	int num,val;
}a[N];

int c[N];
int root,T,n=0,cnt=0,m,num=0,f[N];

inline int max(int x,int y){return x>y? x:y;}
inline bool Cmp(const Node a,const Node b){return a.val<b.val;}
inline void update(int p){t[p].size=t[t[p].s[0]].size+t[t[p].s[1]].size+1;}
inline int wich(int x){return t[t[x].fa].s[0]==x? 0:1;}
inline void connect(int x,int y,int f){t[x].fa=y;t[y].s[f]=x;}
inline int lowbit(int x){return x&(-x);}
inline void add(int x,int val){while(x<=n){c[x]=max(c[x],val);x+=lowbit(x);}}
inline int query(int x){int ret=0;while(x){ret=max(ret,c[x]);x-=lowbit(x);}return ret;}

inline void rotate(int x){
    int y=t[x].fa,rt=t[y].fa;
    int ys=wich(x),rts=wich(y);
    connect(t[x].s[ys^1],y,ys);
    connect(y,x,ys^1);connect(x,rt,rts);
    update(y);update(x);
}

inline void rota(int p){
    if(wich(p)==wich(t[p].fa)){rotate(t[p].fa);rotate(p);}
    else{rotate(p);rotate(p);}
}

inline void splay(int p,int to){
	if(!p) return;
    if(p==to) return;
    if(to==root) root=p;
    while(1){
        if(t[p].fa==to){rotate(p);return;}
        if(t[t[p].fa].fa==to){rota(p);return;}
        rota(p);
    }
}

inline int find(int x){
	rint p=root;
	while(p){
		if(x<=t[t[p].s[0]].size) p=t[p].s[0];
        else if(x==t[t[p].s[0]].size+1) return p;
        else{x-=t[t[p].s[0]].size+1;p=t[p].s[1];}
	}
	return 0;
}

inline void insert(int val,int k){
	int l=find(k+1),r=find(k+2);
	splay(l,root);
	splay(r,t[root].s[1]);
	t[++cnt]=(Splay){val,t[root].s[1],{0,0},1};
	t[t[root].s[1]].s[0]=cnt;
	update(t[root].s[1]);update(root);
	splay(cnt,root);
}

inline void dfs(int p){
	if(t[p].s[0]) dfs(t[p].s[0]);
	if(t[p].val!=INF&&t[p].val!=-INF)
		a[++num].val=t[p].val;
	if(t[p].s[1]) dfs(t[p].s[1]);
}

int main(){
    t[++cnt]=(Splay){-INF,0,{0,2},2};
    t[++cnt]=(Splay){INF,1,{0,0},1};
    read(n);rint x;
    root=1;
    for(int i=1;i<=n;i++)
    	read(x),insert(i,x);
	dfs(root);
	for(int i=1;i<=n;i++) a[i].num=i;
	sort(a+1,a+1+n,Cmp);
	int ans=0;
	for(int i=1;i<=n;i++){
		int maxx=query(a[i].num);
		add(a[i].num,++maxx);
		ans=max(ans,maxx);
		printf("%d\n",ans);
	}
}
```

---

## 作者：Dark_lightrq (赞：4)

看到好多题解都用的离线算法，什么倒序处理啊，还有的离线+ 平衡树+线段树或树状数组或单调队列~~蒟蒻觉得没必要这么麻烦~~


------------


**以上全是瞎扯，下面进入正题**

**前置知识**

- 平衡树（蒟蒻这里用的平衡树是无旋treap，不知道其它平衡树是不是可以
- 贡献思想
- 会最长上升子序列算法
- 没了

**思路**

设F[x]表示的是以x位置结尾的最长上升子序列长度

很多大佬都解释很清楚了，由于加入的k是递增的，所以在加入一个k后，他势必不会影响之前的F[x]只是在F中插入了一个新值y，y为以当前的k所在位置结尾的最长上升子序列长度，而y=maxF[  j ]+1（j为y所在位置前的位置)，所以我们只要维护以排名分裂的FHQtreap，这样可以方便的插入y值，而它要求y位置之前的最大值，在开个格外的数组mx[]来维护以最大值，只要在想上传递时更新一下就好了

上代码~~炒鸡短~~

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100005;
int n;
struct FHQ{//平衡树板子
	int v[N],k[N],si[N],mx[N],lc[N],rc[N],tot,root;
	void push_up(int u){
		si[u]=si[lc[u]]+si[rc[u]]+1;
		mx[u]=max(max(mx[lc[u]],mx[rc[u]]),v[u]);
	}
	void split(int u,int &l,int &r,int x){
		if(!u){
			l=r=0;
			return;
		}
		if(x<=si[lc[u]]){
			r=u;
			split(lc[u],l,lc[u],x);
		}
		else {
			l=u;
			split(rc[u],rc[u],r,x-si[lc[u]]-1);
		}
		push_up(u);
	}
	int merge(int l,int r){
		if(!l||!r)return l|r;
		if(k[l]<=k[r]){
			rc[l]=merge(rc[l],r);
			push_up(l);
			return l;
		}
		else{
			lc[r]=merge(l,lc[r]);
			push_up(r);
			return r;
		}
	}
	int l,r;
	void insert(int p){
		int u=++tot;
		split(root,l,r,p);
		mx[u]=v[u]=mx[l]+1,k[u]=rand(),si[u]=1;//插到l后
		root=merge(merge(l,u),r);
	}
}T;
int main(){
	scanf("%d",&n);
	int p;
	for(int i=1;i<=n;i++){
		scanf("%d",&p);//读入位置p
		T.insert(p);//在p位置插入
		printf("%d\n",T.mx[T.root]);
	}
	return 0;
}
```
如果蒟蒻没解释清可以私信蒟蒻~~逃~~

---

## 作者：syzf2222 (赞：4)

考虑dp，发现输入递增，

则$f[i]=max(f[i-1],max(f[pos[1…pos[i]])+1)$

简而言之，$i$的答案等于$i-1$的答案和位置在$i$前面的数的答案的最大值加1的最大值。

前缀最大值可以用树状数组维护。

但是相对位置不好维护。

考虑在最终数列中每组数的相对位置不会发生改变。

所以先求出每个数在最终数列中的位置。

考虑从后向前求。

第$n$个数的位置就是$a_n$。

考虑第$i$个数的位置，$a_i$代表它大于等于前面的$a_i$个数。

一开始第$pos$位置都大于等于$pos$个数，加入第$i$个数后，因为往后加的数都比$i$小，所以从$pos_i$到$n$的每个位置的值都要减一。

发现这个序列是可以用线段树来维护的。

并且由于此序列递增，维护区间$max$只需$tr[h]=tr[h * 2+1]$，只是注意查询时取最左端的解。

复杂度是$O(nlogn)$

代码放上：

```
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+5;
inline int read(){
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+c-'0';c=getchar();}
	return x*f;
}
int n,a[maxn],pos[maxn],ans[maxn];
int tr[maxn<<2],lazy[maxn<<2],cmax[maxn];
inline void build(int h,int l,int r){
	tr[h]=r;if(l==r)return;
	int mid=(l+r)>>1;
	build(h<<1,l,mid);
	build(h<<1|1,mid+1,r);
}
inline void pushup(int h,int z){
	tr[h]-=z;lazy[h]+=z;
}
inline void pushdown(int h){
	if(!lazy[h])return;
	pushup(h<<1,lazy[h]);
	pushup(h<<1|1,lazy[h]);
	lazy[h]=0;
}
inline void update(int h,int l,int r,int x,int y,int z){
	if(l>y||r<x)return;
	if(l>=x&&r<=y){
		pushup(h,z);
		return;
	}
	pushdown(h);
	int mid=(l+r)>>1;
	update(h<<1,l,mid,x,y,z);
	update(h<<1|1,mid+1,r,x,y,z);
	tr[h]=tr[h<<1|1];
}
inline int query(int h,int l,int r,int x){
	if(l==r)return l;
	pushdown(h);
	int mid=(l+r)>>1;
	if(tr[h<<1]>=x)return query(h<<1,l,mid,x);
	else return query(h<<1|1,mid+1,r,x);
}
inline int query_max(int x){
	int sum=0;
	for(int i=x;i;i-=i&(-i))sum=max(sum,cmax[i]);
	return sum;
}
inline void update_max(int x,int y){
	for(int i=x;i<=n;i+=i&(-i))cmax[i]=max(cmax[i],y);
}
int main(){
	n=read();
	for(int i=1;i<=n;i++)
		a[i]=read()+1;
	build(1,1,n);
   	//给每个位置赋值，线段树维护区间最大。
	for(int i=n;i>=1;i--){
		pos[i]=query(1,1,n,a[i]);
        	//pos[i]为区间上第一个值为a[i]的位置。
		update(1,1,n,pos[i],n,1);
        	//i对pos[i]以后的位置产生影响。
	}
	for(int i=1;i<=n;i++){
		int tmp=query_max(pos[i])+1;
		update_max(pos[i],tmp);
		ans[i]=max(ans[i-1],tmp);
		printf("%d\n",ans[i]); 
	} 
	return 0;
}
```

---

## 作者：Caicz (赞：3)

### splay 大法好，这是一篇关于splay做法的题解
**什么？你不会splay，[点这里](https://www.cnblogs.com/cjyyb/p/7499020.html)**

在原来的splay数组里，增加**下标 lis 和并改变下标 val的含义** 

**t[x].lis** 表示**以 x 为根节点的 splay 树中的最大上升子序列**,初值赋为1;

**t[x].val** 变为表示原序列中 **以 x 为前缀的最大上升子序列**,初值赋为 1;

因为题目中数据是递增插入，所以我们可以用**一个变量 ans 记录整个序列的最大值,**

对于每个插入的值,我们进行如下更新
>ans = max(ans , t [now].val = t [ t [now].ch[0] ].lis + 1)

这样既更新了 val ,也更新了ans;

每次插入后输出 ans 

其他地方就是标准的splay模板了，但是要注意，t[x].lis **更新是通过
左右子树的 lis 和自身的 val 来进行更新**的（因为每次更新 ans 值时，我们这里只能更新 val 值，没有对 lis 进行修改）

代码， ~~可以抄~~

```cpp
#include<stdio.h>
#include<cstring>
#include<iostream>
#define maxn 100005
using namespace std;
struct node
{
    int ch[2],fa,lis,val,size;
}t[maxn];
int n,tot,root,ans;

int read()
{
    int num,sign=1;
    char c;
    while((c=getchar())<'0'||c>'9')
        if(c=='-')sign=-1;
    num=c-'0';
    while((c=getchar())>='0'&&c<='9')
        num=num*10+c-'0';
    return num*sign;
}

inline int newnode()
{
    ++tot;
    t[tot].lis=t[tot].val=t[tot].size=1;
    return tot;
}

inline void update(int x)
{
    t[x].size=t[t[x].ch[0]].size+t[t[x].ch[1]].size+1;
    t[x].lis=max(t[x].val,max(t[t[x].ch[1]].lis,t[t[x].ch[0]].lis));
}

inline void rotate(int x)
{
    int y=t[x].fa;
    int z=t[y].fa;
    int k=t[y].ch[1]==x;
    t[y].ch[k]=t[x].ch[k^1];
    t[t[x].ch[k^1]].fa=y;
    t[x].ch[k^1]=y;
    t[x].fa=z;
    t[y].fa=x;
    t[z].ch[t[z].ch[1]==y]=x;
    update(y),update(x);
}

inline void splay(int x,int goal)
{
    while(t[x].fa!=goal)
    {
        int y=t[x].fa;
        int z=t[y].fa;
        if(z!=goal)
            rotate((t[z].ch[1]==y)^(t[y].ch[1]==x)?x:y);
        rotate(x);
    }
    if(!goal)
        root=x;
}

inline int find(int x)
{
    int u=root;
    while(true)
    {
        if(x>t[t[u].ch[0]].size+1)
            x-=t[t[u].ch[0]].size+1,u=t[u].ch[1];
        else
            if(x==t[t[u].ch[0]].size+1)
                return u;
            else
                u=t[u].ch[0];
    }
}

inline int insert(int pos)
{
    int l=find(pos);
    int r=find(pos+1);
    splay(l,0);splay(r,l);
    t[r].ch[0]=newnode();
    t[t[r].ch[0]].fa=r;
    update(r),update(l);
    return t[r].ch[0];
}

int main()
{
    n=read();
    root=newnode(),t[1].ch[1]=newnode();
    t[2].fa=1,t[1].val=t[2].val=0;
    for(register int pos,i=1;i<=n;++i)
    {
        pos=read();
        int now=insert(pos+1);
        splay(now,0);
        ans=max(ans,t[now].val=max(t[now].val,t[t[now].ch[0]].lis+1));
        printf("%d\n",ans);
    }
    return 0;
}
```


---

## 作者：Michael_Bryant (赞：3)

# 没人写平衡树题解我来写好了    
先推一发我的博客    
[传送门](https://lfd2002.com)    
这个题由于插入是有序的  
所以我们可以用平衡树动态维护当前序列   
g[i]表示i结尾最长上升子序列长度
maxn[i]表示i以及子树中g最大值  
这样的话更新长度用前驱更新  
插入有序所以不会影响后面的值  
```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 100010
#define inf 1000000000
#define max(a,b) a>b?a:b
inline int read()
{
    int s=0,w=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}
    return s*w;
}
int ch[N][2],maxn[N],g[N],f[N],key[N],size[N],sz,n,root;
inline bool get(int x)
{
    return ch[f[x]][1]==x;
}
inline void update(int x)
{
    size[x]=size[ch[x][0]]+size[ch[x][1]]+1;
    maxn[x]=g[x];
    if(ch[x][1]) maxn[x]=max(maxn[ch[x][1]],maxn[x]);
    if(ch[x][0]) maxn[x]=max(maxn[ch[x][0]],maxn[x]);
    if(key[x]==inf||key[x]==0) {maxn[x]=0;g[x]=0;}
}
inline void rotate(int x)
{
    int old=f[x],oldf=f[old],whichx=get(x);
    ch[old][whichx]=ch[x][whichx^1];
    ch[x][whichx^1]=old;
    f[ch[old][whichx]]=old;
    f[old]=x;
    f[x]=oldf;
    if(oldf) ch[oldf][ch[oldf][1]==old]=x;
    update(old);
    update(x);
}
inline void splay(int x,int tar)
{
    for(int fa;(fa=f[x])!=tar;rotate(x))
        if(f[fa]!=tar) rotate(get(fa)==get(x)?fa:x);
    if(!tar) root=x;
}
inline int find(int x)
{
    int now=root;
    while(1)
    {
        if(x<=size[ch[now][0]]) now=ch[now][0];
        else
        {
            int tmp=1+(ch[now][0]?size[ch[now][0]]:0);
            if(tmp==x) return now;
            x-=tmp,now=ch[now][1];
        }
    }
}
int main()
{
    n=read();
    root=++sz;
    key[sz]=inf;size[root]=2;
    f[root]=0;ch[root][1]=++sz;
    key[sz]=0;size[sz]=1;ch[sz][1]=ch[sz][0]=0;f[sz]=root;
    for(int i=1;i<=n;i++)
    {
        int x=read();x++;
        int aa=find(x);
        int bb=find(x+1);
        splay(aa,0);splay(bb,aa);
        ch[ch[root][1]][0]=++sz;
        f[sz]=ch[root][1];
        key[sz]=i;ch[sz][1]=ch[sz][0]=0;
        size[sz]=1;splay(ch[root][1],0);
        splay(sz,0);g[sz]=maxn[ch[root][0]]+1;update(sz);
        printf("%d\n",maxn[sz]);
    }
}

```

---

## 作者：cirnovsky (赞：2)

## Description

动态维护LIS

## Solution

这道题正解应该是在平衡树上维护dp。

设 $dp_{i}$ 表示前 $i$ 个数的LIS长度，转移方程显然为：

$$
dp_{i}=max\{dp_{j}+1\}
$$

~~这东西都不知道可以考虑$\ \ \ \ \ \ \ \ \ \ \ $了~~

然后我们放到维护的节点上即可。

开头说过平衡树对吧，但是这道题的数据过水，vector+bit直接能过，而且跑得飞快，管理如果有心情的话就加强一下吧。

```cpp
#include <bits/stdc++.h>

const int N = 100000 + 5;
int n, p[N], ans[N], bit[N];
std::vector < int > vec;

void update(int x, int y) {
	for (; x <= n; x += x & -x) bit[x] = std::max(bit[x], y);
}

int queryf(int x) {
	int res = 0;
	for (; x; x -= x & -x) res = std::max(res, bit[x]);
	return res;
}

signed main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; ++i) scanf("%d", &p[i]), vec.insert(p[i] + vec.begin(), i);
	for (int i = 1; i <= n; ++i) ans[vec[i - 1]] = queryf(vec[i - 1]) + 1, update(vec[i - 1], ans[vec[i - 1]]);
	for (int i = 1; i <= n; ++i) ans[i] = std::max(ans[i], ans[i - 1]);
	for (int i = 1; i <= n; ++i) printf("%d\n", ans[i]);
	return 0;
}
```

---


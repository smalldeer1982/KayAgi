# [AHOI2013] 作业

## 题目描述

此时己是凌晨两点，刚刚做了 Codeforces 的小 A 掏出了英语试卷。英语作业其实不算多，一个小时刚好可以做完。然后是一个小时可以做完的数学作业，接下来是分别都是一个小时可以做完的化学，物理，语文……小 A 压力巨大。

这时小 A 碰见了一道非常恶心的数学题，给定了一个长度为 $n$ 的数列和若干个询问，每个询问是关于数列的区间表示数列的第 $l$ 个数到第 $r$ 个数)，首先你要统计该区间内大于等于 $a$，小于等于 $b$ 的数的个数，其次是所有大于等于 $a$，小于等于 $b$ 的，且在该区间中出现过的数值的个数。

小 A 望着那数万的数据规模几乎绝望，只能向大神您求救，请您帮帮他吧。

## 说明/提示

$N\leq 100000,M\leq 100000$，读入的数字均为 $[1,10^5]$ 内的正整数。

## 样例 #1

### 输入

```
3 4
1 2 2
1 2 1 3
1 2 1 1
1 3 1 3
2 3 2 3```

### 输出

```
2 2
1 1
3 2
2 1```

# 题解

## 作者：皎月半洒花 (赞：73)

写一个感觉比较详细(萌新友好向)的莫队做法…复杂度 $O(n\sqrt m+m\sqrt n)$ 。

考虑直接莫队的话，需要支持查询某个值域区间中的数，需要上树状数组，但这样带 $\log$ 。

于是考虑一下莫队的本质，即莫队的复杂度分析，本质上分析的是 $l,r$ 移动的复杂度，也就是修改的复杂度。所以莫队可以本质上看成一个 $O(n\sqrt m)$ 修改，$O(m)$ 询问的数据结构。观察到询问数较少，于是可以用一个可以快速修改，低速查询的 ds 来维护值域，那这自然就是值域分块，最终复杂度 $O(n\sqrt m+m\sqrt n)$ 。

以下是补充内容：
____

1、莫队的复杂度分析

令 $m$ 为操作数，$B$ 为块大小。考虑对于一个块内的 $l$，其 $r$ 是单增的，于是考虑如下：

- 左端点，在块内可能会一前一后这样设置，这样复杂度被卡到最满，为 $O(m\cdot B)$ ；
- 右端点，考虑各块内的询问显然都可以做到单块 $O(n)$，所以不需要考虑 $m$ 的贡献，即右端点移动的复杂度就是 $\frac{n}{B}\cdot n=\frac{n^2}{B}$。

均值一下发现 $m\cdot B+\frac{n^2}{B}\geq 2\sqrt{n^2m}=O(n\sqrt m)$ ，此时有 $m\cdot B=\frac{n^2}{B}$，解得 $B=\frac{n}{\sqrt m}$ .

所以取块大小为 $\frac{n}{\sqrt m}$ 时达到理论最优，复杂度为 $O(n\sqrt m)$ 。
____

2、值域分块的正确打开方式

观察到我们本质上需要一个值域上 $O(1)$ 单点加/减，$O(\sqrt n)$ 区间询问的结构，那就是普通的分块了。考虑分块维护块内和和单点值，修改的时候 $O(1)$ 修改点值和块值，询问就是朴素询问(for 过去)即可。

____

然后本题需要分别维护出现次数和是否出现，分别维护即可。

```cpp
#include <bits/stdc++.h>

using namespace std ;

const int N = 200010 ;

void debug(int *tp, int minn, int maxn, char c){
    for (int i = minn ; i <= maxn ; ++ i)
        cout << tp[i] << " " ;  cout << c ;
}

int B ; 
int V ; 
int n, m ;
int bl[N] ;
int blv[N] ;
int res[N] ;
int ans[N] ;
int sum[N] ;
int sumr[N] ;
int sump[N] ;
int base[N] ;

struct query{
	int id ; 
	int l, r ; 
	int a, b ; 
}q[N] ;

bool comp(query a, query b){
	return (bl[a.l] ^ bl[b.l]) ? bl[a.l] < bl[b.l] : 
		   ((bl[a.l] & 1) ? a.r < b.r : a.r > b.r) ;
}
void del(int p){
	sump[base[p]] -- ; 
	sumr[blv[base[p]]] -- ;
	if (sump[base[p]] <= 0) -- sum[blv[base[p]]]  ; 
}
void add(int p){
	sump[base[p]] ++ ; 
	sumr[blv[base[p]]] ++ ; 
	if (sump[base[p]] <= 1) ++ sum[blv[base[p]]]  ; 
}
int get_ans(int l, int r){
	int ret = 0 ; 
	r = min(r, V) ; 
	if (l > V) return 0 ; 
	int nl = blv[l] + 1 ; 
	int nr = blv[r] - 1 ;
	if (blv[l] == blv[r]){
		for (int i = l ; i <= r ; ++ i)
			ret += (bool)sump[i] ; return ret ; 
	}
	for (int i = nl ; i <= nr ; ++ i) ret += sum[i] ;
	for (int i = l ; blv[i] == blv[l] && l <= V ; ++ i) ret += (bool)sump[i] ;
	for (int i = r ; blv[i] == blv[r] && r >= 0 ; -- i) ret += (bool)sump[i] ;
	return ret ;
}
int get_res(int l, int r){
	int ret = 0 ; 
	r = min(r, V) ; 
	if (l > V) return 0 ; 
	int nl = blv[l] + 1 ; 
	int nr = blv[r] - 1 ;
	if (blv[l] == blv[r]){
		for (int i = l ; i <= r ; ++ i)
			ret += sump[i] ; return ret ; 
	}
	for (int i = nl ; i <= nr ; ++ i) ret += sumr[i] ;
	for (int i = l ; blv[i] == blv[l] && l <= V ; ++ i) ret += sump[i] ;
	for (int i = r ; blv[i] == blv[r] && r >= 0 ; -- i) ret += sump[i] ;
	return ret ;
}
int main(){
	cin >> n >> m ; 
	B = 1.0 * n / sqrt(m) + 1 ; 
	for (int i = 1 ; i <= n ; ++ i)
		scanf("%d", &base[i]), V = max(V, base[i]), bl[i] = i / B ; 
	for (int i = 1 ; i <= m ; ++ i)
		scanf("%d%d%d%d", &q[i].l, &q[i].r, &q[i].a, &q[i].b), q[i].id = i ; 
	sort(q + 1, q + m + 1, comp) ; 
	int l = 1, r = 0 ; B = sqrt(V) + 1 ; 
	for (int i = 0 ; i <= V ; ++ i) blv[i] = i / B ; 
	for (int i = 1 ; i <= m ; ++ i){
		int a = q[i].a, b = q[i].b ; 
		while (l < q[i].l) del(l ++) ; 
		while (l > q[i].l) add(-- l) ; 
		while (r < q[i].r) add(++ r) ;
		while (r > q[i].r) del(r --) ;
		res[q[i].id] = get_res(a, b) ;
		ans[q[i].id] = get_ans(a, b) ; 
	}
	for (int i = 1 ; i <= m ; ++ i) 
		printf("%d %d\n", res[i], ans[i]) ; return 0 ; 
}
```

快来夸我码风! (超自豪

~~我是一个刚开始学 lxl 深刻理论的萌新，不要 d 我~~

---

## 作者：cosmicAC (赞：33)

大佬们都是分块的，那本蒟蒻来发一个理论上复杂度更好的cdq分治吧。

**[我的博客](https://www.luogu.org/blog/474D/)**

做过[P1972](https://www.luogu.org/problemnew/show/P1972)的可能会发现此题和那题差不多，只不过多了一个数字大小的限制。不过思路是一样的。具体来讲，先离散化，然后记录一个pre[]数组表示每个数之前一次出现在哪里。于是本题的第二问就变成了这样一个问题：

> 输入(L,R,A,B)，输出有多少个x满足：  
L<=x<=R; A<=a[x]<=B; 0<=pre[x]<=L-1

一看就是一个三维数点，直接上cdq。

第一问呢？在归并的时候直接把左边已经归并的数量加到右边的答案中就行了，相当于二维数点。

C++17代码：
```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
#define maxn 100010
using namespace std;
int n,m,a[maxn],b[maxn],h[maxn],ans[maxn],ans1[maxn],c[maxn];
struct qry{int x,y,z,f,id;};
vector<qry> v,w;
bool operator <=(qry a,qry b){
    return pair(a.y,a.z)<=pair(b.y,b.z);
}
void ins(int p,int v){for(;p<=n;p+=p&-p)c[p]+=v;}
int Qry(int p){int r=0;for(;p;p&=p-1)r+=c[p];return r;}
void CDQ(int l,int r){
    if(l+1>=r)return;
    int mid=l+r>>1,i=l,j=mid,cnt=0;
    CDQ(l,mid),CDQ(mid,r);
    w.clear();
    while(i<mid || j<r)if(i<mid && (j==r || v[i]<=v[j])){
        w.push_back(v[i]);
        if(!v[i].f)ins(v[i].z+1,1),cnt++;
        i++;
    }else{
        w.push_back(v[j]);
        if(v[j].f)
            ans[v[j].id]+=v[j].f*Qry(v[j].z+1),
            ans1[v[j].id]+=v[j].f*cnt;
        j++;
    }
    for(int i=l;i<mid;i++)if(!v[i].f)ins(v[i].z+1,-1);
    for(int i=l;i<r;i++)v[i]=w[i-l];
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%d",a+i),b[i]=a[i];
    sort(b+1,b+1+n);
    for(int i=1;i<=n;i++){
        int pre=h[a[i]=lower_bound(b+1,b+1+n,a[i])-b];
        h[a[i]]=i;
        v.push_back({i,a[i],pre,0,0});
    }
    for(int i=1;i<=m;i++){
        int l,r,A,B;
        scanf("%d%d%d%d",&l,&r,&A,&B);
        A=lower_bound(b+1,b+1+n,A)-b;
        B=upper_bound(b+1,b+1+n,B)-b-1;
        v.insert(v.end(),{{r,B,l-1,1,i},{l-1,A-1,l-1,1,i},
                {l-1,B,l-1,-1,i},{r,A-1,l-1,-1,i}});
    }
    stable_sort(v.begin(),v.end(),[](qry a,qry b){
        return tuple(a.x,a.y,a.z)<tuple(b.x,b.y,b.z);
    });
    //为什么是stable_sort?我也不知道。但是稳一点。
    CDQ(0,v.size());
    for(int i=1;i<=m;i++)
        printf("%d %d\n",ans1[i],ans[i]);
    return 0;
}
```

---

## 作者：attack (赞：23)

为什么一堆分块呀。。三维数点不应该是套路离线/可持久化+树套树么。。

亲测树状数组套权值线段树可过

复杂度$O(nlog^2n)$，空间$O(nlogn)$(离线)

```cpp
#include<bits/stdc++.h> 
#define Pair pair<int, int>
#define MP(x, y) make_pair(x, y)
#define fi first
#define se second
#define Fin(x) {freopen(#x".in","r",stdin);}
#define Fout(x) {freopen(#x".out","w",stdout);}
using namespace std;
const int MAXN = 4e5 + 10, SS = 1e7 + 10;
inline int read() {
    char c = getchar(); int x = 0, f = 1;
    while(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
    return x * f;
}
int N, M, a[MAXN], pre[MAXN], las[MAXN], Lim = 1e5, tot;
Pair ans[MAXN];
#define lb(x) (x & (-x))
struct BIT {
	int T[MAXN];
	void Add(int x, int v) {
		x++;
		while(x <= Lim) T[x] += v, x += lb(x); 
	}
	int sum(int x) {
		x++;
		int ans = 0;
		while(x) ans += T[x], x -= lb(x);
		return ans;
	}
	int Query(int x, int y) {return sum(y) - sum(x - 1);}
}Q1;
struct query {
	int k, a, b, id, p;
	bool operator < (const query &rhs) const {
		return k < rhs.k;	
	}
}q[MAXN];
int root[SS], sum[SS], ls[SS], rs[SS], cnt;
void update(int k) {
	sum[k] = sum[ls[k]] + sum[rs[k]];
}
void insert(int &k, int l, int r, int p, int v) {
	if(!k) k = ++cnt;
	if(l == r) {sum[k]++; return ;}
	int mid = l + r >> 1;
	if(p <= mid) insert(ls[k], l, mid, p, v);
	else insert(rs[k], mid + 1, r, p, v);
	update(k);
}
int Query(int k, int l, int r, int ql, int qr) {
	if(!k) return 0;
	if(ql <= l && r <= qr) return sum[k];
	int mid = l + r >> 1;	
	if(ql > mid) return Query(rs[k], mid + 1, r, ql, qr);
	else if(qr <= mid) return Query(ls[k], l, mid, ql, qr);
	else return Query(ls[k], l, mid, ql, qr) + Query(rs[k], mid + 1, r, ql, qr);
}
void Add(int x, int v) {
	x++;
	while(x <= Lim) insert(root[x], 0, Lim, v, 1), x += lb(x); 
}
int Query(int x, int a, int b) {
	x++;
	int ans = 0;
	while(x) ans += Query(root[x], 0, Lim, a, b), x -= lb(x);
	return ans;
}
void Solve() {
	int x = 0;
	for(int i = 1; i <= tot; i++) {
		while(x < q[i].k) 
			Q1.Add(a[++x], 1), Add(pre[x], a[x]);
		ans[abs(q[i].id)].fi += (q[i].id / (abs(q[i].id))) * Q1.Query(q[i].a, q[i].b);
		ans[abs(q[i].id)].se += (q[i].id / (abs(q[i].id))) * Query(q[i].p, q[i].a, q[i].b);
	}
}
signed main() {
	N = read(); M = read();
	for(int i = 1; i <= N; i++) {
		a[i] = read();
		pre[i] = las[a[i]]; las[a[i]] = i;
	}
	for(int i = 1; i <= M; i++) {
		int l = read(), r = read(), a = read(), b = read();
		q[++tot].k = l - 1; q[tot].a = a; q[tot].b = b; q[tot].id = -i; q[tot].p = l - 1;
		q[++tot].k = r;     q[tot].a = a; q[tot].b = b; q[tot].id = i;  q[tot].p = l - 1;
	}
	sort(q + 1, q + tot + 1); 
	Solve();
	for(int i = 1; i <= M; i++) printf("%d %d\n", ans[i].fi, ans[i].se);
	return 0;
}
```




---

## 作者：Juan_feng (赞：22)

大家好， 我非常喜欢暴力数据结构， 于是就用分块A了此题

这里提供的是**支持在线**的**纯分块做法** ， 而**不是**主流的莫队做法

具体做法是先对数列分块， 再对值域分块， 维护三个数组cnt1, cnt2, cnt3

- cnt3(i,j,k)表示第i到第j个块中第k个值域块的数的种类数 

- cnt2(i,j)表示前i个块中j这个数（离散后)的个数

- cnt1(i,j)表示前i个块中第j个值域块中数的个数 

~~我偏要反着放~~

显然这个预处理的时间复杂度是n sqrt n 的（具体的复杂度在程序的注释中有写）

然后对于询问两点在相邻数列块的时候直接暴力求， 否则的话先扫一遍两遍的散块（数列块） 统计一下符合要求的颜色个数和其他信息（这里可以开一些临时数组来完成答案的统计， 具体实现见代码）。

然后我们看看整块怎样处理： 

如果上下界在相邻的值域块里我们暴力扫一遍值域块就能得到答案了 ， 否则我们可以先扫一下上下两个散块（值域块）， 然后再扫一下中间的整块（值域块）， 统计一下答案就可以啦qwqwq（统计答案的方法一看就会， 各位神仙直接看代码就好了， 小蒟蒻这里就不啰嗦了~~试图掩盖懒的事实~~）

具体实现代码里都有注释， 如果有什么疑问的话私信小蒟蒻就好

预处理复杂度是n sqrt(n), 单次查询的复杂度是sqrt，唯一的缺点就是常数略大， 如果想不开O2过最后一个点可能要卡卡常， 这里为了便于理解就把便（chang）于（shu）理（ju）解（da）的版本放上来啦。

**那么代码如下：**

```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath> 
#include <algorithm>
#define maxn 100010
#define maxs 400
#define re register
#define FOR(i, l, r) for(re int i = l; i <= r; ++i)
using namespace std;

int n, m, c, r, t, x, y, low, high;
int sq1, sq2;
int a[maxn], z[maxn], b1[maxn], b2[maxn], cnt1[maxs][maxs], cnt2[maxs][maxn];
unsigned short cnt3[maxs][maxs][maxs];
int col[maxn], cn[maxn], blkcol[maxn];

inline void in(int &x){
    x=0;char c=getchar();
    while(c<'0'||c>'9'){
        c=getchar();
    }
    while(c<='9'&&c>='0'){
        x=(x<<1)+(x<<3)+(c^'0');
        c=getchar();
    }
} 

void query(int x, int y, int k1, int k2) {
    if(b1[x] == b1[y] || b1[y] == b1[x]+1) { //x和y在同一个块里或在相邻的块里 
        int ans1 = 0, ans2 = 0;
        FOR(i, x, y) {
            ++col[a[i]];
            if(a[i] >= k1 && a[i] <= k2 && col[a[i]] == 1)
              ++ans2;
            if(a[i] >= k1 && a[i] <= k2)
              ++ans1;
        }
        printf("%d %d\n", ans1, ans2);
        FOR(i, x, y) 
          --col[a[i]];
        return;
    }
    
    FOR(i, x, min(y, b1[x]*sq1)) { //x, y 所在的块不相邻 
        ++col[a[i]]; //单个颜色的个数 
        ++blkcol[b2[a[i]]]; //值域块内颜色的个数 
        if(col[a[i]]+cnt2[b1[y]-1][a[i]]-cnt2[b1[x]][a[i]] == 1)
          ++cn[b2[a[i]]]; //统计颜色种类数 
    }
    FOR(i, (b1[y]-1)*sq1+1, y) {
        ++col[a[i]];
        ++blkcol[b2[a[i]]];
        if(col[a[i]]+cnt2[b1[y]-1][a[i]]-cnt2[b1[x]][a[i]] == 1)
          ++cn[b2[a[i]]]; 
    } 
    
    if(b2[k1] == b2[k2] || b2[k1]+1 == b2[k2]) { //上下界在同一个值域块里或上下界在相邻值域块里 
        int ans1 = 0, ans2 = 0;
        FOR(i, k1, k2) {  //直接枚举值域 
            if(col[i]+cnt2[b1[y]-1][i]-cnt2[b1[x]][i] > 0) 
              ++ans2;
            ans1 += col[i]+cnt2[b1[y]-1][i]-cnt2[b1[x]][i]; 
        }
        printf("%d %d\n", ans1, ans2);
    }
    else { //x 和y的块不相邻且上下界值域块不相邻 
        int ans1 = 0, ans2 = 0;
        FOR(i, k1, b2[k1]*sq2) {
            if(col[i]+cnt2[b1[y]-1][i]-cnt2[b1[x]][i] > 0) {
                ++ans2;
            }
              
            ans1 += col[i]+cnt2[b1[y]-1][i]-cnt2[b1[x]][i];
        }
        FOR(i, (b2[k2]-1)*sq2+1, k2) {
            if(col[i]+cnt2[b1[y]-1][i]-cnt2[b1[x]][i] > 0) {
                 ++ans2;
            }
             
            ans1 += col[i]+cnt2[b1[y]-1][i]-cnt2[b1[x]][i];
        }
        
        FOR(i, b2[k1]+1, b2[k2]-1) { //整值域块 
            ans1 += blkcol[i]+cnt1[b1[y]-1][i]-cnt1[b1[x]][i]; //统计总个数 
            ans2 += cn[i]+cnt3[b1[x]+1][b1[y]-1][i]; //种类数 
        }
        printf("%d %d\n", ans1, ans2);
    }
    
    FOR(i, x, min(y, b1[x]*sq1)) { //消除影响 
        --col[a[i]]; 
        --blkcol[b2[a[i]]]; 
        if(col[a[i]]+cnt2[b1[y]-1][a[i]]-cnt2[b1[x]][a[i]] == 0)
          --cn[b2[a[i]]]; 
    }
    FOR(i, (b1[y]-1)*sq1+1, y) {
        --col[a[i]];
        --blkcol[b2[a[i]]];
        if(col[a[i]]+cnt2[b1[y]-1][a[i]]-cnt2[b1[x]][a[i]] == 0)
          --cn[b2[a[i]]]; 
    } 
}

int main() {
    //cnt3(i,j,k)表示第i到第j个块中第k个值域块的数的种类数 
    //cnt2(i,j)表示前i个块中j这个数（离散后)的个数
    //cnt1(i,j)表示前i个块中第j个值域块中数的个数 
    in(n), in(m);
    sq1 = sqrt(n);
    FOR(i, 1, n)
      in(a[i]), z[++z[0]] = a[i];
    sort(z+1, z+z[0]+1);
    z[0] = unique(z+1, z+z[0]+1)-z-1;
    sq2 = sqrt(z[0]);
    FOR(i, 1, z[0])
      b2[i] = (i-1)/sq2+1;
    FOR(i, 1, n) {
        a[i] = lower_bound(z+1, z+z[0]+1, a[i])-z; //离散 
        b1[i] = (i-1)/sq1+1;
        ++cnt1[b1[i]][b2[a[i]]];
        ++cnt2[b1[i]][a[i]];
    }
    FOR(i, 1, b1[n]) {
        FOR(j, 1, b2[z[0]])  //处理cnt1的前缀和 总复杂度On 
          cnt1[i][j] += cnt1[i-1][j];
        FOR(j, 1, z[0]) //处理cnt2的前缀和  总复杂度O(n sqrt(n)) 
          cnt2[i][j] += cnt2[i-1][j];
        
        FOR(j, i, b1[n]) { //处理出cnt3的值 总复杂度O(n sqrt(n)) 
            FOR(k, (j-1)*sq1+1, min(n, j*sq1)) {
                ++col[a[k]];
                if(col[a[k]] == 1) {
                     ++cnt3[i][j][b2[a[k]]];
                }
            }
        }
        
        FOR(j, i, b1[n])
          FOR(k, 1, b2[z[0]])
            cnt3[i][j][k] += cnt3[i][j-1][k];
        
        FOR(j, i, b1[n]) { //消除影响 
            FOR(k, (j-1)*sq1+1, min(n, j*sq1)) {
                --col[a[k]];
            }
        }
    }
    
    FOR(i, 1, m) {
        in(x), in(y), in(low), in(high);
        if(low < z[1] && high < z[1])  { //几种特殊情况的判定
            puts("0 0");
          	continue;
        } 
        if(low > z[z[0]])  {
            puts("0 0");
            continue;
        }
        low = lower_bound(z+1, z+z[0]+1, low)-z;
        high = upper_bound(z+1, z+z[0]+1, high)-z-1;  
        if(low == high+1) {
            puts("0 0");
            continue;
        }
        query(x, y, low, high); 
    }
}
```

**完结撒花qwqwq**

---

## 作者：3lizabeth (赞：22)

# 莫队+分块

------------
好像很多写莫队+分块的，但是代码可读性个人感觉有点差，就写了个码风奇特的版本给各位带哥康康。


------------

第一次写题解，审核大大给个过8 ！ლ(°◕‵ƹ′◕ლ) ~~话说这题好水~~

------------
对于本题，在察觉了出现数字个数时就很容易察觉到（~~杀意感知~~）可以用莫队处理（离线），但是对于区间内符合条件的x的总个数呢？想到可以用莫队和分块有机结合处理，就可以A掉本题了！



------------
看代码，GKD


------------


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+7;
int n,m,q[N],a[N],l=1,r,blo;
int appnum[N],appq[N],tot[N];

struct node
{
    int l,r,a,b,id;
}ask[N];//存储输入 

struct node1
{
    int a1,a2;
}ans[N];//储存答案，有两个输出，一个是种类数，一个是个数

bool cmp(node x,node y)
{
	if(q[x.l]!=q[y.l])
	return q[x.l]<q[y.l];
    else return x.r<y.r;
}

void add(int x)
{
    appnum[x]++;
    appq[q[x]]++;
    if(appnum[x]==1) tot[q[x]]++;
}
 
void del(int x)
{
    appnum[x]--;
    appq[q[x]]--;
    if(appnum[x]==0) tot[q[x]]--;
}

void getans(int a,int b,int k)//分块找答案 
{
    for(int i=a;i<=min(b,q[a]*blo);i++)
        if(appnum[i]) ans[k].a1+=appnum[i],ans[k].a2++;
    
    if(q[a]!=q[b])
        for(int i=(q[b]-1)*blo+1;i<=b;i++)
            if(appnum[i]) ans[k].a1+=appnum[i],ans[k].a2++;
    
    for(int i=q[a]+1;i<=q[b]-1;i++)
    { 
        ans[k].a1+=appq[i];
        ans[k].a2+=tot[i];
    }
}

inline int read()
{
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}

int main()
{
	//freopen("homework.in","r",stdin);
	//freopen("homework.out","w",stdout);

    n=read();m=read();
    blo=sqrt(n);
    
    for(int i=1;i<=n;i++)
    {
 		a[i]=read();
		q[i]=(i-1)/blo+1;//分块
	}
	
    for(int i=1;i<=m;i++)
    {
        ask[i].l=read();ask[i].r=read();ask[i].a=read();ask[i].b=read();
        ask[i].id=i;//输入数据
    }
    
    sort(ask+1,ask+m+1,cmp);//对查询区间的排序节约时间，莫队基操
    
    for(int i=1;i<=m;i++)
    {	//莫队先统计 
        while(r<ask[i].r)	add(a[++r]);
        while(r>ask[i].r)	del(a[r--]);
        while(l>ask[i].l)	add(a[--l]);
        while(l<ask[i].l)	del(a[l++]);
        
        getans(ask[i].a,ask[i].b,ask[i].id);
    }
    
    for(int i=1;i<=m;i++)
        printf("%d %d\n",ans[i].a1,ans[i].a2);
        
    return 0;
}
```


---

## 作者：FjswYuzu (赞：8)

题意：给出一个静态区间和多个询问，询问分为下面两种：

- 在区间 $[l,r]$ 中有多少个 $i$，使得 $a_i \in [a,b]$；   
- 在区间 $[l,r]$ 中有多少种 $a_i(i\in[l,r])$，使得 $a_i \in [a,b]$。

首先考虑第二个问题的弱化版，我们要求区间 $[l,r]$ 种元素的种数。显然这个问题可以直接通过莫队解决。

但是这道题加上了对元素的限制。考虑简单容斥，原问题转化为求等于 $val \in [1,b]$ 的种数 $p$，$val \in [1,a-1]$ 的种数 $q$，问题的答案即为 $p-q$。

因为值域小，显然我们现在可以维护一个树状数组解决这个问题。$\operatorname{query}(x)$ 即为 $val \in [1,x]$ 的种数。答案即为 $\operatorname{query}(b)-\operatorname{query}(a-1)$。

再返回去考虑第一个问题，我们发现我们也可以维护一个树状数组去解决这个问题。我们就可以在 $O(n \sqrt n \log n)$ 的时间复杂度内解决了。

发现这个算法太暴力了（（卡卡常才能过。

于是优化：

- 莫队·奇偶性排序；   
- 树状数组·玄学区间查询（By 日报）；   
- `assert` 套取 $n$ 的范围，发现倒数第二个点的 $n=10^4$，最后一个点的 $n=10^5$。于是分类讨论块长。题解选用的是试验多次效果较好的长度。（分别为 $\sqrt n,150,433$）；   
- `#pragma GCC optimize(3)`。

现在就可以不用 `O2` 过了。

```cpp
#include<bits/stdc++.h>
#pragma GCC optimize(3) 
using namespace std;
char buf[1<<21],*p1=buf,*p2=buf;
#define getchar() (p1==p2 && (p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
int read()
{
	int x=0,f=1;
	char c=getchar();
	while(c<'0' || c>'9')
	{
		if(c=='-')	f=-1;
		c=getchar();
	}
	while(c>='0' && c<='9')	x=(x<<1)+(x<<3)+(c^'0'),c=getchar();
	return x*f;
}
void write(int x)
{
	if(x<0)	putchar('-'),x=-x;
	if(x>9)	write(x/10);
	putchar(x%10+'0');
}
int pos[100005],n,p,m,a[100005],gr,cnt[100005],ans[100005],res[100005];
struct queries{
    int l,r,a,b,id;
    queries(){l=r=a=b=id=0;}
    queries(int L,int R,int A,int B,int ID){l=L,r=R,a=A,b=B,id=ID;}
    bool operator < (queries another) const {
    	return (pos[l]^pos[another.l])?pos[l]<pos[another.l]:(pos[l]&1)?r<another.r:r>another.r;
    }
}que[100005];
struct BinaryIndexedTree{
    int a[100005];
    int lowbit(int x){return x&(-x);}
    void modify(int x,int val){for(int i=x;i<=n;i+=lowbit(i))   a[i]+=val;}
    int query(int x)
    {
        int ans=0;
        while(x)    ans+=a[x],x-=lowbit(x);
        return ans;
    }
    int query(int l,int r)
    {
    	--l;
    	int ans=0;
    	while(r>l)	ans+=a[r],r-=lowbit(r);
    	while(l>r)	ans-=a[l],l-=lowbit(l);
    	return ans;
	}
}bit1,bit2;
void add(int x)
{
    x=a[x];
    if(!cnt[x]) bit2.modify(x,1);
    bit1.modify(x,1);
    ++cnt[x];
}
void sub(int x)
{
	x=a[x];
    bit1.modify(x,-1);
    --cnt[x];
    if(!cnt[x]) bit2.modify(x,-1);
}
int main(){
	n=read(),m=read();
	if(n<10000)	p=sqrt(n);
	else if(n==10000)	p=150;
	else	p=433;
    for(int i=1;i<=n;++i)   a[i]=read(),pos[i]=(i-1)/p+1;
    for(int i=1;i<=m;++i)
    {
        int l=read(),r=read(),a=read(),b=read();
        que[i]=queries(l,r,a,b,i);
    }
    sort(que+1,que+1+m);
    for(int i=1,l=1,r=0;i<=m;++i)
    {
        while(l>que[i].l)   add(--l);
        while(l<que[i].l)   sub(l++);
        while(r<que[i].r)   add(++r);
        while(r>que[i].r)   sub(r--);
		ans[que[i].id]=bit1.query(que[i].a,que[i].b);
		res[que[i].id]=bit2.query(que[i].a,que[i].b);
    }
    for(int i=1;i<=m;++i)   write(ans[i]),putchar(' '),write(res[i]),puts("");
    return 0;
}
```

（原已过审）

---

## 作者：Isonan (赞：8)

原题传送门[>Here<](https://www.luogu.org/problemnew/show/P4396)

# 莫队。
维护两个树状数组，一个表示数的个数，一个表示不同数值的个数。为了判断当前加入的数值存不存在/当前删除的数值是不是最后一个，开一个count数组。

后面就是套路了，每次修改时维护树状数组和count数组。

代码：

```cpp
#include <cstdio>
#include <algorithm>
#include <cmath>
#define min(X,Y) ((X)<(Y)?(X):(Y))

int pos[200010],n,m,count[200010],num[200010],block,c[200001],c2[200001];
int bl,br,bmid,ans1[200010],ans2[200001],nowans1,nowans2;
struct point{
    int l,r,orig,a,b;
}q[200010];
bool cmp(point a,point b){return pos[a.l]==pos[b.l] ? a.r<b.r : pos[a.l]<pos[b.l];}
void update1(int x,int num){
	for(;x<=n;x+=x&-x)c[x]+=num;
}
int query1(int x){
	int tot=0;
	for(;x;x-=x&-x)tot+=c[x];
	return tot;
}
void update2(int x,int num){
	for(;x<=n;x+=x&-x)c2[x]+=num;
}
int query2(int x){
	int tot=0;
	for(;x;x-=x&-x)tot+=c2[x];
	return tot;
}
void add(int ind){
	if(!count[ind])update2(ind,1);
	update1(ind,1);
	count[ind]++; 
}
void del(int ind){
	update1(ind,-1);
	count[ind]--;
	if(!count[ind])update2(ind,-1);
}
void write(int x){
	if(x>9)write(x/10);
	putchar((x%10)+'0');
}
int read(){
	int x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
	return x;
}
int main(){
    scanf("%d%d",&n,&m);
    block = (int)sqrt(n);
    for(register int i=1;i<=n;i++){
        pos[i]=(i-1)/block+1;
        num[i]=read();
    }
    for(register int i=1;i<=m;i++)q[i].l=read(),q[i].r=read(),q[i].a=read(),q[i].b=read(),q[i].orig=i;
    std::sort(q+1,q+m+1,cmp);
    for(register int i=q[1].l;i<=q[1].r;i++)add(num[i]);
    ans1[q[1].orig]=query1(q[1].b)-query1(q[1].a-1);
    ans2[q[1].orig]=query2(q[1].b)-query2(q[1].a-1);
    for(register int i=2;i<=m;i++){
        if(q[i-1].l<q[i].l)for(int j=q[i-1].l;j<q[i].l;j++)del(num[j]);
        else for(int j=q[i].l;j<q[i-1].l;j++)add(num[j]); 
        if(q[i-1].r<q[i].r)for(int j=q[i-1].r+1;j<=q[i].r;j++)add(num[j]);
        else for(int j=q[i].r+1;j<=q[i-1].r;j++)del(num[j]);
        ans1[q[i].orig]=query1(q[i].b)-query1(q[i].a-1);
        ans2[q[i].orig]=query2(q[i].b)-query2(q[i].a-1);
    }
    for(register int i=1;i<=m;i++)write(ans1[i]),putchar(' '),write(ans2[i]),putchar('\n');
}
```

---

## 作者：brsjdys (赞：8)

##   [我的博客](https://www.cnblogs.com/drurry/p/9094548.html)

暴力77分就不用讲了


------------


**
正解：**

做法不唯一，常见做法为莫队+分块或者莫队+树状数组，但是网上也有一些奇奇怪怪的方法。

求任意一段区间内在[a,b]的数字个数，很容易想到分块；但是题目有要求该区间内在[a,b]的数值种数，这又很容易联想到莫队。所以正解就是莫队+分块。例如样例的第一个询问，莫队增加在这个区间内每个数字出现的次数、该数字所在的块的元素个数（包括重复的数字）、该数所在块的不重复元素个数。然后分块询问[a,b]之间在规定区间的答案。

正解很巧妙地一点在于分块分的不仅仅是有多少个数（即n），还是数值（即color[ ]）。这也就存在一个问题，假设n很小，但是color[ ]很大又要另做处理。

如果不能理解代码的建议自行模拟样例。

------------
更新：**针对hack数据改了一波，之前的问题是如果l或r超出了color[]的最大值，posi[l]或者posi[r]会 变成0，那么对答案的统计就会出现问题**


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100010;
int n,m,L,R,block,num,posi[N],lll[N],rrr[N],sum[N],skuai[N],change[N],color[N],ans1[N],ans2[N],anss1,anss2;
struct node{
    int l,r,x,y,id;
}a[N];
bool cmp(node aa,node bb)
{
    if(posi[aa.l]==posi[bb.l]) return aa.r<bb.r;
    else return aa.l<bb.l;
}
void build()//预处理出每个块的边界
{
    block=sqrt(n);num=n/block;
    if(n%block) num++;
    for(int i=1;i<=num;i++) 
    lll[i]=(i-1)*block+1,rrr[i]=i*block;
    rrr[num]=n;
    for(int i=1;i<=n;i++) posi[i]=(i-1)/block+1;
}
void add(int col)
{
    sum[col]++;skuai[posi[col]]++;
    if(sum[col]==1) change[posi[col]]++;
}
void del(int col)
{
    sum[col]--;skuai[posi[col]]--;
    if(!sum[col]) change[posi[col]]--;
}
void find(int l,int r,int id)
{
    if(posi[l]==posi[r]) 
    {
        for(int i=l;i<=r;i++) if(sum[i]) ans1[id]+=sum[i],ans2[id]++;
        return;
	}
    /*改动*/
    if(posi[l]!=0) 
    for(int i=l;i<=rrr[posi[l]];i++) if(sum[i]) ans1[id]+=sum[i],ans2[id]++;
	if(posi[r]!=0)
	for(int i=lll[posi[r]];i<=r;i++) if(sum[i]) ans1[id]+=sum[i],ans2[id]++;
	if(posi[l]!=0&&posi[r]!=0)
	for(int i=posi[l]+1;i<posi[r];i++) ans1[id]+=skuai[i],ans2[id]+=change[i];
	if(posi[l]!=0&&posi[r]==0) 
	for(int i=posi[l]+1;i<=num;i++) ans1[id]+=skuai[i],ans2[id]+=change[i];
}
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%d",&color[i]);
    build();
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d%d%d",&a[i].l,&a[i].r,&a[i].x,&a[i].y);
        a[i].id=i;
    }
    L=1,R=0;
    sort(a+1,a+1+m,cmp);
    for(int i=1;i<=m;i++)
    {
        while(R<a[i].r) add(color[++R]);
        while(R>a[i].r) del(color[R--]);
        while(L<a[i].l) del(color[L++]);
        while(L>a[i].l) add(color[--L]);
        find(a[i].x,a[i].y,a[i].id);
    }
    for(int i=1;i<=m;i++)
        printf("%d %d\n",ans1[i],ans2[i]);
    return 0;
}
```

---

## 作者：1saunoya (赞：5)

~~看到这题 ： "这不是莫队+树状数组 傻*题吗"~~

简化一下 题目

这题是要求 $[l,r]$ 这个区间 $[a,b]$ 的个数 以及$[a,b]$ 的数值种类数

不难想到用两个树状数组维护$\text{莫队}$

一个树状数组 存 个数

一个树状数组 存 种类数

莫队的复杂度 是 $n \sqrt n$ 的
带上一个 树状数组 的 $\log n$ 的复杂度

大概就是 $n \sqrt n * \log n$

但莫队跑的还挺快的

$\mathcal Code$


```cpp
#include<bits/stdc++.h>

using namespace std ;
const int N = 1e5 + 10 ;
int tree[N] ;
inline int low(int x) {
	return x & - x ;
}
inline void Add(int x , int y) {
	for( ; x <= N ; x += low(x)) tree[x] += y ;
}
inline int Query(int x) { register int ans = 0 ;
	for( ; x ; x -= low(x)) ans += tree[x] ;
	return ans ;
}
int tree2[N] ;
inline void Add2(int x , int y) {
	for( ; x <= N ; x += low(x)) tree2[x] += y ;
}
inline int Query2(int x) { register int ans = 0 ;
	for( ; x ; x -= low(x)) ans += tree2[x] ;
	return ans ;
}
int n , m ;
int a[N] ;
int cnt[N] ;
int Ans[N] ;
int Ans2[N] ;
struct node {
	int l , r ;
	int a , b ;
	int bl ;
	int id ;
} ;
node q[N] ;
inline bool cmp(node x , node y) {
	return x.bl ^ y.bl ? x.bl < y.bl : x.r < y.r ;
}

inline void Ins(int x) {
	Add(a[x] , 1) ;
	if(++ cnt[a[x]] == 1) Add2(a[x] , 1) ;
}
inline void Del(int x) {
	Add(a[x] , -1) ;
	if(-- cnt[a[x]] == 0) Add2(a[x] , -1) ;
}
signed main() {
	ios::sync_with_stdio(false ) ;
	cin.tie(0) ;
	cout.tie(0) ;
	cin >> n >> m ;
	int unt = sqrt(n * 3 / 2) ;
	for(register int i = 1 ; i <= n ; i ++) {
		cin >> a[i] ;
	}
	for(register int i = 1 ; i <= m ; i ++) {
		cin >> q[i].l >> q[i].r >> q[i].a >> q[i].b ;
		q[i].bl = q[i].l / unt ;
		q[i].id = i ;
	}
	sort(q + 1 , q + m + 1 , cmp) ;
	int l = 1 , r = 0 ;
	for(register int i = 1 ; i <= m ; i ++) {
		for( ; l < q[i].l ; Del(l ++)) ;
		for( ; r > q[i].r ; Del(r --)) ;
		for( ; l > q[i].l ; Ins(-- l)) ;
		for( ; r < q[i].r ; Ins(++ r)) ;
		Ans[q[i].id] = Query(q[i].b) - Query(q[i].a - 1) ;
		Ans2[q[i].id] = Query2(q[i].b) - Query2(q[i].a - 1) ;
	}
	for(register int i = 1 ; i <= m ; i ++) {
		cout << Ans[i] << ' ' << Ans2[i] << endl ;
	}
	return 0 ;
}

---

## 作者：hsfzLZH1 (赞：4)

### 题目大意

给定一个长度为 $n$ 的数列 $v_i$ ， $m$ 次查询，每次查询给出 $l,r,a,b$ ，求下标 $x$ 在区间 $[l,r]$ 内且 $v_x\in [a,b]$ 的下标 $x$ 的个数和不同 $v_x$ 的个数。

### 解题思路

这么好的一道题怎么可以没有优秀的在线做法呢~

#### 前置技能： [k-D Tree](https://oi-wiki.org/ds/k-dtree/)

先考虑第一问的做法，题目求的是 $\sum_{i=l}^r [v_i\in [a,b]]$ ，对每个下标 $i$ 都对应一个二维平面上的点 $(i,v_i)$ ，需要统计的就是以 $(l,a)$ 为左下角， $(r,b)$ 为右上角的矩形区域内的点数。可以使用 2-D Tree 进行统计。

第二问，求的是不同 $v_i$ 的个数，此时二维数点就不能胜任了，需要再增加一个维度。

定义 $lst_i$ 为位置 $i$ 上的数值在这个位置之前最后一次出现的位置，如果之前不存在这个值不妨定义为 $0$ 。我们发现，对于查询的区间 $[l,r]$ ，要保证出现的相同值只被统计一次，可以统计在这段区间中出现第一次的值，那么这些位置对应的 $lst$ 值都是小于 $l$ 的。

我们将第二问转化为求 $\sum_{i=1}^r [v_i\in [a,b]\wedge lst_i\in [1,l-1]]$ 的值。将每个下标 $i$ 都对应到三维空间上的点 $(i,v_i,lst_i)$ ，需要统计的就是第一维坐标在区间 $[l,r]$ ，第二维坐标在区间 $[a,b]$ ，第三维坐标在 $[1,l-1]$ 内的长方体区域内的点数。至此，题目转化为了一个三维数点问题。

在线解决三维数点问题，可以使用 **3-D Tree** 。由于此题中的点集是静态的，所以不用支持重构操作。建出树后在树上查询，单次时间复杂度是最优 $O(\log_2 n)$ 、最差 $O(n^{\frac 2 3})$ 的。

总的时间复杂度为 $O(mn^{\frac 2 3})$ ，空间复杂度为 $O(n)$ 。

由于代码实现中第一问用到了主席树，所以空间复杂度是 $O(n\log_2 n)$ 。

### 参考实现

```cpp
// luogu-judger-enable-o2
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=100010;
int n,m,v[maxn],lst[maxn],ql,qr,a,b;
struct node{int x,y,z;}s[maxn],x;
bool cmp1(node a,node b){return a.x<b.x;}
bool cmp2(node a,node b){return a.y<b.y;}
bool cmp3(node a,node b){return a.z<b.z;}
int lc[maxn],rc[maxn],L[maxn],R[maxn],D[maxn],U[maxn],F[maxn],B[maxn],siz[maxn];
void maintain(int x)
{
	siz[x]=siz[lc[x]]+1+siz[rc[x]];
	L[x]=R[x]=s[x].x;D[x]=U[x]=s[x].y;F[x]=B[x]=s[x].z;
	if(lc[x])L[x]=min(L[x],L[lc[x]]),R[x]=max(R[x],R[lc[x]]),D[x]=min(D[x],D[lc[x]]),U[x]=max(U[x],U[lc[x]]),F[x]=min(F[x],F[lc[x]]),B[x]=max(B[x],B[lc[x]]);
	if(rc[x])L[x]=min(L[x],L[rc[x]]),R[x]=max(R[x],R[rc[x]]),D[x]=min(D[x],D[rc[x]]),U[x]=max(U[x],U[rc[x]]),F[x]=min(F[x],F[rc[x]]),B[x]=max(B[x],B[rc[x]]);
}
double sq(double x){return x*x;}
int build(int l,int r)
{
	if(l>r)return 0;
	int mid=(l+r)>>1;
	double av1=0,av2=0,av3=0,va1=0,va2=0,va3=0,maxx;
	for(int i=l;i<=r;i++)av1+=s[i].x,av2+=s[i].y,av3+=s[i].z;
	av1/=(r-l+1);av2/=(r-l+1);av3/=(r-l+1);
	for(int i=l;i<=r;i++)va1+=sq(av1-s[i].x),va2+=sq(av2-s[i].y),va3+=sq(av3-s[i].z);
	maxx=max(max(va1,va2),va3);
	if(maxx==va1)nth_element(s+l,s+mid,s+r+1,cmp1);
	else if(maxx==va2)nth_element(s+l,s+mid,s+r+1,cmp2);
	else nth_element(s+l,s+mid,s+r+1,cmp3);
	lc[mid]=build(l,mid-1);rc[mid]=build(mid+1,r);
	maintain(mid);return mid;
}
int query(int l,int r)
{
	int mid=(l+r)>>1;
	if(l>r||R[mid]<ql||L[mid]>qr||U[mid]<a||D[mid]>b||F[mid]>=ql)return 0;
	if(ql<=L[mid]&&R[mid]<=qr&&a<=D[mid]&&U[mid]<=b&&B[mid]<ql)return siz[mid];
	int ret=0;
	if(ql<=s[mid].x&&s[mid].x<=qr&&a<=s[mid].y&&s[mid].y<=b&&s[mid].z<ql)ret=1;
	return ret+query(l,mid-1)+query(mid+1,r);
}
struct persistent_tree
{
	int cur,rt[maxn],lc[maxn*20],rc[maxn*20],siz[maxn*20];
	void update(int&o,int lst,int l,int r,int x)
	{
		if(!o)o=++cur;
		siz[o]=siz[lst]+1;
		if(l==r)return;
		int mid=(l+r)>>1;
		if(x<=mid)rc[o]=rc[lst],update(lc[o],lc[lst],l,mid,x);
		else lc[o]=lc[lst],update(rc[o],rc[lst],mid+1,r,x);
	}
	int query(int o1,int o2,int l,int r,int ql,int qr)//ans=o1-o2
	{
		if(r<ql||l>qr)return 0;
		if(ql<=l&&r<=qr)return siz[o1]-siz[o2];
		int mid=(l+r)>>1;
		return query(lc[o1],lc[o2],l,mid,ql,qr)+query(rc[o1],rc[o2],mid+1,r,ql,qr); 
	}
}st;
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)scanf("%d",v+i),s[i]={i,v[i],lst[v[i]]},lst[v[i]]=i,st.update(st.rt[i],st.rt[i-1],1,n,v[i]);
	build(1,n);
	while(m--)
	{
		scanf("%d%d%d%d",&ql,&qr,&a,&b);
		printf("%d %d\n",st.query(st.rt[qr],st.rt[ql-1],1,n,a,b),query(1,n));
	}
	return 0;
}
```

---

## 作者：little_sun (赞：4)

这题其实跟[Gty的二逼妹子序列](https://www.luogu.org/problemnew/show/P4867)
非常像

把那题代码改改就行了

思路：莫队+分块

首先区间问题，可以离线，马上想到莫队

然后发现不会修改？怎么办？

(好像可以树状数组做，可是我不会o((⊙﹏⊙))o

我们可以把值域分块，这样就可以做到每次查询$O(\sqrt n)$，修改$O(1)$了

总复杂度$O(m \sqrt n)$

```cpp
#include <bits/stdc++.h>
#define getpos(x) ((x - 1) / block + 1)
#define getblock(x) ((x - 1) * block + 1)
const int MaxN = 100010;
struct query
{
    int id, pos;
    int l, r, a, b;
};
query q[MaxN];
int n, m, size, block;
int a[MaxN], cnt[MaxN], sum[MaxN][3], ans[MaxN][3];
inline int cmp(query a, query b)
{
    if (a.pos != b.pos)
        return a.pos < b.pos;
    return a.r < b.r;
}
inline int read()
{
    int x = 0;
    char ch = getchar();
    while (ch > '9' || ch < '0')
        ch = getchar();
    while (ch <= '9' && ch >= '0')
        x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
    return x;
}
inline void add(int x)
{
    ++cnt[a[x]];
    ++sum[getpos(a[x])][1];
    if (cnt[a[x]] == 1)
        ++sum[getpos(a[x])][2];
}
inline void del(int x)
{
    --cnt[a[x]];
    --sum[getpos(a[x])][1];
    if (cnt[a[x]] == 0)
        --sum[getpos(a[x])][2];
}
inline void ask(int x)
{
    int id = q[x].id, l = q[x].a, r = q[x].b, Posl = getpos(q[x].a), Posr = getpos(q[x].b);
    for (int i = Posl + 1; i < Posr; i++)
        ans[id][1] += sum[i][1], ans[id][2] += sum[i][2];
    if (Posl == Posr)
    {
        for (int i = l; i <= r; i++)
        {
            ans[id][1] += cnt[i];
            if (cnt[i])
                ans[id][2]++;
        }
    }
    else
    {
        int L = getblock(Posr), R = getblock(Posl + 1) - 1;
        for (int i = l; i <= R; i++)
        {
            ans[id][1] += cnt[i];
            if (cnt[i])
                ans[id][2]++;
        }
        for (int i = L; i <= r; i++)
        {
            ans[id][1] += cnt[i];
            if (cnt[i])
                ans[id][2]++;
        }
    }
}
inline void solve()
{
    int l = 1, r = 0;
    for (int i = 1; i <= m; i++)
    {
        while (l > q[i].l)
            --l, add(l);
        while (r < q[i].r)
            ++r, add(r);
        while (l < q[i].l)
            del(l), l++;
        while (r > q[i].r)
            del(r), r--;
        ask(i);
    }
}
int main()
{
    n = read(), m = read();
    size = pow(n, 0.55), block = sqrt(n);
    for (int i = 1; i <= n; ++i)
        a[i] = read();
    for (int i = 1; i <= m; i++)
    {
        q[i].l = read(), q[i].r = read();
        q[i].a = read(), q[i].b = read();
        q[i].id = i, q[i].pos = (q[i].l - 1) / size + 1;
    }
    std::sort(q + 1, q + m + 1, cmp);
    solve();
    for (int i = 1; i <= m; i++)
        printf("%d %d\n", ans[i][1], ans[i][2]);
    return 0;
}

```

---

## 作者：RetrO (赞：3)

>>>一道莫队加上树状数组的题，但是我不想写树状数组怎么办
----
>>>既然莫队都分块了，就直接写分块咯，莫队查询就不说了，在每次莫队调完L，R后，直接查询答案，详细见代码。
-----
------


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=200010; 
struct edge{
	int l,r,a,b;
	int ans1,ans2;
	int id;
}G[N];
int cnt[N];
int bl[N];
int blk;
int n,m;
int S[N];
int f[N],g[N];
bool cmp(edge a,edge b)
{
	return bl[a.l]==bl[b.l]?a.r<b.r:bl[a.l]<bl[b.l];
} 
bool cmp1(edge a,edge b)
{
	return a.id<b.id;
}
void jisuan(int l,int r,int x)
{
	if(bl[l]==bl[r])
	{
		for(int i=l;i<=r;i++)
		 if(cnt[i]) G[x].ans1+=cnt[i],G[x].ans2++;
	}
	else{
		for(int i=bl[l]*blk-1;i>=l;--i) if(cnt[i]) G[x].ans1+=cnt[i],G[x].ans2++;
		for(int i=bl[r]*blk-blk;i<=r;i++) if(cnt[i]) G[x].ans1+=cnt[i],G[x].ans2++;
		for(int i=bl[l]+1;i<bl[r];i++) G[x].ans1+=f[i],G[x].ans2+=g[i];
	}
}
void add(int x)
{
	++f[bl[x]];
	++cnt[x];
	if(cnt[x]==1) g[bl[x]]++;
}
void del(int x)
{
	--f[bl[x]];
	--cnt[x];
	if(!cnt[x]) g[bl[x]]--;
}
void moqueue()
{
	int L=1,R=0;
	 for(int i=1;i<=m;i++){
	 	while(L>G[i].l) add(S[--L]);
		while(L<G[i].l) del(S[L++]);
		while(R<G[i].r) add(S[++R]);
		while(R>G[i].r) del(S[R--]);
	  jisuan(G[i].a,G[i].b,i);
	 }
}
int main()
{
	scanf("%d %d",&n,&m);
	 for(int i=1;i<=n;i++)
	 	scanf("%d",&S[i]);
	 
	 blk=sqrt(n);
	 for(int i=1;i<=n;i++)
	 bl[i]=(i)/blk+1;
	  for(int i=1;i<=m;i++)
	  	scanf("%d %d %d %d",&G[i].l,&G[i].r,&G[i].a,&G[i].b),G[i].id=i;
       sort(G+1,G+1+m,cmp);
       moqueue();
       sort(G+1,G+1+m,cmp1);
       for(int i=1;i<=m;i++)
       printf("%d %d\n",G[i].ans1,G[i].ans2);
}
```



---

## 作者：arfa (赞：2)

先知道这道题目的所求

- 求出一个 $num_i$ 使 $a\leq num_i\leq b$ 且在 $l\leq place_i\leq r$。然后统计 $num_i$ 的个数。

- 求出一个 $num_i$ 使 $a\leq num_i\leq b$ 且在 $l\leq place_i\leq r$。然后统计 $num_i$ **存在过**。(不同于上一问的是这里只是 $inc(ans) $,而上一问是 $inc(ans,num_i$在区间里出现的次数) )。 

明白所求之后开始做题。我们可以用莫队来维护每一次的 $l,r$ 之间的状态,然后用分块进行修改。分块维护的是权值,并且维护上面的两个数。

```pascal
procedure add(x,i:longint); // 增加一个数
begin
    inc(block[x,1]); inc(intersum[Locate(x),1]); // 出现次数++
    if block[x,1]=1 then begin block[x,2]:=1;  inc(intersum[Locate(x),2]); end; // 有出现过,只可能是 1 或 0 表示出现或者没有出现
end;

procedure dim(x,i:longint); // 减少一个数字
begin
    dec(block[x,1]); dec(intersum[Locate(x),1]);
    if block[x,1]=0 then begin block[x,2]:=0; dec(intersum[Locate(x),2]); end;
end;

```

可能大家会问为什么分块,其实上面几篇题解讲得不对,因为分块的单点修改是 $O(1)$ 的,而树状数组什么的是 $O(\log\ n)$,会导致时间复杂度下降为 $O(n\sqrt{n}\log\ n)$,将近 $4e8$。所以并不是方便才用的。

以下的就非常简单了。

```pascal
// luogu-judger-enable-o2
var
    block_num,node_num,sum,i,j,n,m,l,r:longint;
    num,id,left,right,vall,valr,recf:array[-1..110000] of longint;
    block:array[-1..110000,1..2] of longint;
    intersum:array[-1..400,1..2] of longint;
    ans:array[-1..110000,1..2] of longint;

procedure Swap(var x,y:longint); var t:longint; begin t:=x; x:=y; y:=t; end;

function Locate(node:longint):longint;
begin if node mod node_num=0 then exit(node div node_num); exit(node div node_num+1);
end;

procedure Sort(l,r:longint);
var i,j,s1,s2:longint;
begin
    i:=l; j:=r; s1:=recf[(l+r) div 2]; s2:=right[(l+r) div 2];
    repeat
        while ((recf[i]<s1)or((recf[i]=s1)and(right[i]<s2))) do inc(i);
        while ((recf[j]>s1)or((recf[j]=s1)and(right[j]>s2))) do dec(j);
        if i<=j then
        begin
            Swap(recf[i],recf[j]); Swap(id[i],id[j]); Swap(left[i],left[j]);
            Swap(right[i],right[j]); Swap(vall[i],vall[j]); Swap(valr[i],valr[j]);
            inc(i); dec(j);
         end;
    until i>=j;
    if i<r then Sort(i,r);
    if j>l then Sort(l,j);
end;

function Query(l,r,mode:longint):longint;
var
    i:longint;
    real:array[1..2] of longint;
begin
    Query:=0; real[1]:=Locate(l); real[2]:=Locate(r);
    if real[2]-real[1]<=1 then for i:=l to r do inc(Query,block[i,mode])
    else
    begin
        for i:=real[1]+1 to real[2]-1 do inc(Query,intersum[i,mode]);
        for i:=l to real[1]*node_num do inc(Query,block[i,mode]);
        for i:=(real[2]-1)*node_num+1 to r do inc(Query,block[i,mode]);
    end;
end;

procedure add(x,i:longint);
begin
    inc(block[x,1]); inc(intersum[Locate(x),1]);
    if block[x,1]=1 then begin block[x,2]:=1; inc(intersum[Locate(x),2]); end;
end;

procedure dim(x,i:longint);
begin
    dec(block[x,1]); dec(intersum[Locate(x),1]);
    if block[x,1]=0 then begin block[x,2]:=0; dec(intersum[Locate(x),2]); end;
end;

procedure Ready;
begin
    read(n,m); node_num:=trunc(sqrt(n)); block_num:=node_num;
    if block_num<>sqrt(n) then inc(block_num);
    for i:=1 to n do read(num[i]);
    for i:=1 to m do begin id[i]:=i; read(left[i],right[i],vall[i],valr[i]); recf[i]:=Locate(left[i]); end;
    Sort(1,m);
end;

begin
    Ready; l:=1; r:=0; sum:=0;
    for i:=1 to m do
    begin
        while r<right[i] do begin  inc(r); add(num[r],i); end;
        while r>right[i] do begin dim(num[r],i); dec(r); end;
        while l<left[i] do begin dim(num[l],i); inc(l); end;
        while l>left[i] do begin dec(l); add(num[l],i); end;
        ans[id[i],1]:=Query(vall[i],valr[i],1); ans[id[i],2]:=Query(vall[i],valr[i],2);
    end;
    for i:=1 to m do writeln(ans[i,1],' ',ans[i,2]);
end.
```

---

## 作者：VenusM1nT (赞：1)

莫队（块状暴力）。  
首先这道题的数据略水，没有规定 $a_i$ 的范围（实际上不超过 $2\times 10^5$？），不过如果在 $10^9$ 范围内只要离散化一下就可以了。  
然后这个长得就很像莫队（块状暴力），可以直接莫队（块状暴力）套上去，然后考虑怎么加点减点，显然可以用先用套路维护 $\text{cnt}_ i$ 代表 $i$ 的出现次数，然后再考虑怎么维护题目要求那两个东西，那么我们可以用 区间加 和 区间查询 来记录区间出现数的次数和数的个数，这东西可以用树状数组维护，然后这题就可以轻松地过掉了。  
（感觉可以奇偶性优化或者回滚莫队？有没有神仙加强一下数据啊）
```cpp
#include<bits/stdc++.h>
#define MAXN 200005
#define reg register
#define inl inline
using namespace std;
struct Qry
{
	int l,r,pos,x,y,id;
	friend bool operator < (const Qry &x,const Qry &y)
	{
		return x.pos==y.pos?x.r<y.r:x.l<y.l;
	}
}q[MAXN];
int n,m,a[MAXN],cnt[MAXN],ans1[MAXN],ans2[MAXN];
struct BIT
{
	int c[MAXN];
	inl int lowbit(reg int x)
	{
		return x&-x;
	}
	inl void Modify(reg int x,reg int val)
	{
		for(;x<=n;x+=lowbit(x)) c[x]+=val;
	}
	inl int Query(reg int x)
	{
		reg int res=0;
		for(;x;x-=lowbit(x)) res+=c[x];
		return res;
	}
}A,B;
inl void Add(reg int x)
{
	if(!cnt[x]) B.Modify(x,1);
	A.Modify(x,1);
	cnt[x]++;
}
inl void Del(reg int x)
{
	A.Modify(x,-1);
	cnt[x]--;
	if(!cnt[x]) B.Modify(x,-1);
}
int main()
{
	scanf("%d %d",&n,&m);
	for(reg int i=1;i<=n;i++) scanf("%d",&a[i]);
	reg int unt=sqrt(n);
	for(reg int i=1;i<=m;i++)
	{
		scanf("%d %d %d %d",&q[i].l,&q[i].r,&q[i].x,&q[i].y);
		q[i].id=i;
		q[i].pos=(q[i].l-1)/unt+1;
	}
	sort(q+1,q+m+1);
	reg int L=1,R=0;
	for(reg int i=1;i<=m;i++)
	{
		while(L>q[i].l) Add(a[--L]);
		while(R<q[i].r) Add(a[++R]);
		while(L<q[i].l) Del(a[L++]);
		while(R>q[i].r) Del(a[R--]);
		ans1[q[i].id]=A.Query(q[i].y)-A.Query(q[i].x-1);
		ans2[q[i].id]=B.Query(q[i].y)-B.Query(q[i].x-1);
	}
	for(reg int i=1;i<=m;i++) printf("%d %d\n",ans1[i],ans2[i]);
	return 0;
}
```

---

## 作者：kkxhh (赞：1)

莫队+分块

这题其实用树状数组也可以维护，但是我们经过分析可以发现这题里插入的次数有 $O(n\sqrt{n})$ 次，而查询的次数只有 $O(n)$ 次，所以如果用树状数组来维护的话总复杂度就是 $O(n\sqrt{n}logn)$ 的。而如果用分块维护我们就可以实现 $O(1)$ 修改，$O(\sqrt{n})$ 查询，最后总复杂度为 $O(n\sqrt{n})$ ，总的来说复杂度是更优的

顺带需要注意的是 $a$ 和 $b$ 不一定在原数组里有，所以为了避免出锅最好让 $find$ 同时支持返回大于等于的第一个数和返回小于等于的第一个数

代码如下

```cpp
#include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;

typedef struct query{
    int l,r,a,b,x,id;
    bool operator < (const query &o) const {return ((x!=o.x)?x<o.x:(x&1)?r<o.r:r>o.r);}
}qy;

qy q[100010];
int n,m,block,a[100010],v[100010],siz,bsum[5010],bsiz[5010],w[100010],belong[100010]={0,1},vblock,ans[100010],ans2[100010];

inline int read(){
    int num=0,k=1; char c=getchar();
    while(c>'9' || c<'0') k=(c=='-')?0:k,c=getchar();
    while(c>='0' && c<='9') num=num*10+c-'0',c=getchar();
    return k?num:-num;
}

int find(int x,int type){
    int l=0,r=siz+1,mid;
    while(l+1<r){
        mid=(l+r)>>1;
        if(v[mid]<x) l=mid;
        else if(v[mid]>x) r=mid;
        else return mid;
    }
    return (type?r:l);
}

void modify(int p,int v) {bsum[belong[p]]+=v; bsiz[belong[p]]-=(w[p]>0); w[p]+=v; bsiz[belong[p]]+=(w[p]>0);}

void query(int l,int r,int &sum,int &siz){
    sum=siz=0;
    if(l>r) return;
    for(int i=belong[l]+1;i<belong[r];i++) sum+=bsum[i],siz+=bsiz[i];
    for(int i=l;belong[i]==belong[l] && i<=r;i++) sum+=w[i],siz+=(w[i]>0);
    if(belong[l]!=belong[r]) for(int i=r;belong[i]==belong[r];i--) sum+=w[i],siz+=(w[i]>0);
}

int main(){
    n=read(); m=read(); block=sqrt(n);
    for(int i=1;i<=n;i++) v[++siz]=a[i]=read();
    sort(v+1,v+1+siz); siz=unique(v+1,v+1+siz)-v-1; vblock=sqrt(siz);
    for(int i=1;i<=n;i++) a[i]=find(a[i],0);
    for(int i=1;i<=m;i++) q[i].l=read(),q[i].r=read(),q[i].a=read(),q[i].b=read(),q[i].x=q[i].l/block+1,q[i].id=i;
    sort(q+1,q+1+m);
    for(int i=2;i<=siz;i++) belong[i]=belong[i-1]+(i%vblock==0);
    int l=1,r=0;
    for(int i=1;i<=m;i++){
        while(l<q[i].l) modify(a[l++],-1);
        while(l>q[i].l) modify(a[--l],1);
        while(r<q[i].r) modify(a[++r],1);
        while(r>q[i].r) modify(a[r--],-1);
        query(find(q[i].a,1),find(q[i].b,0),ans[q[i].id],ans2[q[i].id]);
    }
    for(int i=1;i<=m;i++) printf("%d %d\n",ans[i],ans2[i]);
    return 0;
}

```

---

## 作者：Strelitzia (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P4396)

---

题目可说是相当简洁明了，就是找分别为在 $\texttt{l}$ 和 $\texttt{r}$ 这段区间中大小在 $\texttt{[a,b]}$ 中的数的个数，

以及大于等于 $\texttt{a}$，小于等于 $\texttt{b}$ 的，且在该区间中出现过的数值的个数。

---

看到这个题目要求很容易想到用莫队，但问题在如何维护所求的值。

因为求的值是在一个区间内，又看到$\texttt{a}$的数据范围，发现不用离散化，

区间求和就可以用树状数组来维护，用树状数组主要是因为树状数组非常快。

我们可以用两个树状数组来分别维护出现的次数和出现的值。

但这道题有一点卡常，各个地方都需要优化一下，比较重要的地方就是莫队的排序优化，这个可以作为一个常备技能。

---

```cpp
#include <cmath>
#include <cstdio>
#include <iostream>
#include <algorithm>
#define lowbit(x) (x & -x)
using namespace std;
template<typename T>void read(T &x) {
	T f = 1;x = 0;char s = getchar();
	while(s < '0' || s > '9') {if(s == '-')f = -1;s = getchar();}
	while(s >= '0' && s <= '9') {x = x * 10 + s - '0';s = getchar();}
	x *= f;
}
template<typename T>void print(T x) {
	if(x < 0) putchar('-'),x = -x;
	if(x > 9) print(x / 10);
	putchar(x % 10 + '0');
}
const int maxn = 100000;

struct node {
	int l,r,a,b,id;
}ask[maxn + 5];

int n,m,a[maxn + 5];
int pos[maxn + 5],ans[maxn + 5],res[maxn + 5];
int tr[maxn + 5],t[maxn + 5],vis[maxn + 5];

int sum(int x) {
	int res = 0;
	for (; x ; x -= lowbit(x)) res += tr[x];
	return res;
}

int update(int x,int y) {
	for (; x <= maxn ; x += lowbit(x)) tr[x] += y;
}

int exsum(int x) {
	int res = 0;
	for (; x ; x -= lowbit(x)) res += t[x];
	return res;
}

int exupdate(int x,int y) {
	for (; x <= maxn ; x += lowbit(x)) t[x] += y;
}

bool cmp(node rhs,node shr) {
    if (pos[rhs.l] != pos[shr.l]) return rhs.l < shr.l;
    else if (pos[rhs.l] & 1) return rhs.r < shr.r;
    else return rhs.r > shr.r;
}

void Add(int x) {
	if (!vis[a[x]]) {
		exupdate(a[x],1);
	}
	update(a[x],1);
	vis[a[x]] ++;
}

void Sub(int x) {
	vis[a[x]] --;
	if (!vis[a[x]]) {
		exupdate(a[x],-1);
	}
	update(a[x],-1);
}

int main() {
	read(n);read(m);
	int t = sqrt(n);
	for (int i = 1 ; i <= n ; ++ i) read(a[i]),pos[i] = i / t;
	for (int i = 1 ; i <= m ; ++ i) read(ask[i].l),read(ask[i].r),read(ask[i].a),read(ask[i].b),ask[i].id = i;
	sort(ask + 1,ask + 1 + m,cmp);
	int l = 1,r = 0;
	for (int i = 1 ; i <= m ; ++ i) {
		while (l > ask[i].l) Add(-- l);
		while (l < ask[i].l) Sub(l ++);
		while (r < ask[i].r) Add(++ r);
		while (r > ask[i].r) Sub(r --);
		ans[ask[i].id] = sum(ask[i].b) - sum(ask[i].a - 1);
		res[ask[i].id] = exsum(ask[i].b) - exsum(ask[i].a - 1);
	}
	for (int i = 1 ; i <= m ; ++ i) printf("%d %d\n",ans[i],res[i]);
	return 0;
}
```

---


# [BJWC2018] 第k大斜率

## 题目描述

在平面直角坐标系上，有 $n$ 个不同的点。任意两个不同的点确定了一条直线。请求出所有斜率存在的直线按斜率从大到小排序后，第 $k$ 条直线的斜率为多少。

为了避免精度误差，请输出斜率向下取整后的结果。（例如：$\lfloor 1.5 \rfloor = 1$，$\lfloor -1.5 \rfloor = -2$）。

## 说明/提示

**【样例说明】**

符合要求的直线的斜率分别为 $-3, -\frac{1}{2}, \frac{2}{3}, 1, 2, \frac{5}{2}$ 。

**【数据规模和约定】**

令 $M$ 为所有斜率存在的直线的数量 。

对于 $10 \%$ 的数据，$1 \le n \le 10$。  
对于 $20 \%$ 的数据，$1 \le n \le 100$，$|x_i|, |y_i| \le {10}^3$。  
对于 $30 \%$ 的数据，$1 \le n \le 1000$。  
对于 $40 \%$ 的数据，$1 ≤ n ≤ 5000$。  
对于另 $20 \%$ 的数据，满足 $k = 1$ 。  
对于另 $20 \%$ 的数据，满足 $1 \le x_i, y_i \le {10}^3$。  
对于 $100 \%$ 的数据，$1 \le n \le 100000$，$1 \le k \le M$，$|x_i|, |y_i| \le {10}^8$。

## 样例 #1

### 输入

```
4 1
-1 -1
2 1
3 3
1 4```

### 输出

```
2```

# 题解

## 作者：Zilljy258 (赞：14)

[P4479 [BJWC201] 第k大斜率](https://www.luogu.com.cn/problem/P4479)

### 思路：

二分斜率，每次检查大于 $mid$ 的斜率个数。

 $$ { y_j-y_i \over x_j-x_i } > mid $$  

注意，$$ x_j > x_i $$

则，
$$ y_j - y_i > mid \times ( x_j - x_i ) $$

$$ y_j -  mid \times x_j > y_i - mid \times x_i $$

对于每个点按照 $ y - mid \times x$ 的顺序排序，求二维偏序（顺序对？）即可。

**注意点**

1. 对于 $x$ 相等的两个点，他们的斜率不存在，为了防止被统计到答案中，应当按照 $y$ 从大到小的顺序排序。
2. 每一次二分的 $mid$ 不一样，如果用树状数组的话应该重新进行离散化。

---

## 作者：misaka0111 (赞：11)

对于两个点，分别记为$i,j$，若i与j所在直线斜率大于$k$，那么就会有如下式子$$\frac{y_{j}-y_{i}}{x_{j}-x_{i}}>k$$
不妨设$x_{j}>x_{i}$
$$y_{j}-y_{i}>k(x_{j}-x_{i})$$
$$y_{j}-kx_{j}>y_{i}-kx_{i}$$
令$t_{i}=y_{i}-kx_{i}$，对于一个斜率$k$，只需统计满足$x_{j}>x_{i}$且$t_{j}>t_{i}$的$i,j$对数就可以求得有多少条直线斜率大于k。发现统计点对数的问题实际上就是一个二维偏序，离散化+扫描线+树状数组即可维护。所以最后二分所求的斜率$k$，利用上述方法check即可ac。
```cpp
#include<algorithm>
#include<cstdio>
#include<cmath>
#include<cstring>
using namespace std;
typedef long long ll;
const int maxn = 100005;
int n;
ll k;
struct Point
{
    ll x, y, idx, t;
    bool operator < (const Point& b) const
    {
        return t == b.t? x < b.x : t < b.t;
    }
}p[maxn];
int px[maxn];
ll read()
{
    ll ans = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9')
    {
        if(c == '-')
            f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9')
    {
        ans = ans * 10 + c - '0';
        c = getchar();
    }
    return ans * f;
}
namespace BIT
{
    ll a[maxn];
    void clear()
    {
        memset(a, 0, sizeof(a));
    }
    int lowbit(int x)
    {
        return x & -x;
    }
    void update(int x)
    {
        while(x <= n)
        {
            a[x]++;
            x += lowbit(x);
        }
    }
    ll query(int x)
    {
        ll ans = 0;
        while(x)
        {
            ans += a[x];
            x -= lowbit(x);
        }
        return ans;
    }
}
bool check(int mid)
{
    for(int i = 1; i <= n; i++)
        p[i].t = p[i].y - 1ll * mid * p[i].x;
    sort(p + 1, p + n + 1);
    BIT::clear();
    ll rnk = 0;
    for(int i = 1; i <= n; i++)
    {
        rnk += BIT::query(p[i].idx - 1);
        BIT::update(p[i].idx);
    }
    return rnk >= k;
}
int main()
{
    n = read(), k = read();
    for(int i = 1; i <= n; i++)
        px[i] = p[i].x = read(), p[i].y = read();
    sort(px + 1, px + n + 1);
    int tot = unique(px + 1, px + n + 1) - px - 1;
    for(int i = 1; i <= n; i++)
        p[i].idx = lower_bound(px + 1, px + tot + 1, p[i].x) - px;
    int l = -2e8, r = 2e8, ans;
    while(l <= r)
    {
        int mid = (l + r) >> 1;
        if(check(mid))
        {
            ans = mid;
            l = mid + 1;
        }
        else
            r = mid - 1;
    }
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：TainityAnle (赞：7)

### 思路

先按 $x$ 从小到大排序。为了防止相同的数影响，如果 $x$ 相等按 $y$ 从大到小排序。

二分斜率 $p$，查有多少个斜率大于 $p$，即查有多少个 $y_j-y_i>p(x_j-x_i)$，这个式子可以写成 $y_j-px_j>y_i-px_i$。设 $t_i=y_i-px_i$。当 $x_i<x_j$ 且 $t_i<t_j$ 时斜率大于 $p$。二维偏序问题，可以用类似求逆序对的方式做，将 $t$ 离散化之后用树状数组维护，开大小为 $t$ 值域的树状数组。

得到的答案就是斜率大于 $p$ 的线的数量 $m$，用 $m$ 二分。如果 $m<k$，说明二分到的斜率比较大导致 $p$ 的排序太靠前，使左端点变成 $p$，否则使右端点变成 $p-1$。

### AC Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+5;
int n,k,l,r,b[N],c[N];
struct point{
	int x,y;
}a[N];
struct node{
	int t[N];
	void clear(){
		memset(t,0,sizeof t);
	}
	void add(int x,int y){
		for(int i=x;i<=n;i+=(i&(-i))) t[i]+=y;
	}
	int qry(int x){
		int res=0;
		for(int i=x;i;i-=(i&(-i))) res+=t[i];
		return res;
	}
}A;
bool cmp(point a,point b){
	if(a.x==b.x) return a.y>b.y;
	return a.x<b.x;
}
int check(int p){
	A.clear();
	for(int i=1;i<=n;i++) b[i]=a[i].y-p*a[i].x,c[i]=b[i];
	sort(c+1,c+n+1);
	int m=unique(c+1,c+n+1)-c-1;
	for(int i=1;i<=n;i++) b[i]=lower_bound(c+1,c+m+1,b[i])-c;
	int cnt=0;
	for(int i=1;i<=n;i++){
		cnt+=A.qry(b[i]);
		A.add(b[i],1);
	}
	return cnt;
}
signed main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++) cin>>a[i].x>>a[i].y;
	sort(a+1,a+n+1,cmp);
	l=-1000000000,r=1000000000;
	while(l<r){
		int mid=(l+r+1)/2;
		int tmp=check(mid);
		if(tmp<k) r=mid-1;
		else l=mid;
	}
	cout<<l;
	return 0;
}
```

---

## 作者：yi_hr (赞：7)

## 思路
对于本题，优先考虑暴力。  
暴力：$O(n^2)$ 暴力枚举每个点的组合，再进行排序，时间复杂度 $O(n^2\log n)$。  

考虑优化：将问题转化一下，从求第 $k$ 大的转化为求斜率为 $P$ 的是斜率第几大的。  
我们表示一下斜率大于 $P$ 的两点的斜率，即：
$$\frac{y_i-y_j}{x_i-x_j}\ge P$$
则我们按照 $x$ 排序，以保证 $x_i-x_j$ 为正数，将 $x_i-x_j$ 乘到另一边，则：  
$$y_i-y_j>P\times(x_i-x_j)$$  
将同类移到一边：  
$$y_i-P\times x_i>y_j-P\times x_j$$  
则对于 $T_i=(y_i-P\times x_i)$ 中 $T_i$ 与 $T_j$ 构成二维偏序，可用树状数组或归并排序实现。  
我们已经可以实现求斜率为 $P$ 的是斜率第几大的，因为答案具有单调性，二分答案即可。
## 代码
```cpp
#include <bits/stdc++.h>
#define INF 0x3f3f3f3f
using namespace std;
const int N=1e5+9;
struct node{
	int x,y;
	bool operator <(const node &a)const{
		if(a.x==x) return y>a.y;
		return x<a.x;
	}
}a[N];
int cqr[N],t[N];
int n,k,cnt;
void ssort(int l,int r){
	int mid=(l+r)>>1;
	if(l==r)
		return;
	ssort(l,mid);
	ssort(mid+1,r);
	int i=l,j=mid+1,k=l;
	while(i<=mid&&j<=r){
		if(cqr[i]<=cqr[j]){
			cnt+=(r-j+1);
			t[k++]=cqr[i++];
		}
		else
			t[k++]=cqr[j++];
	}
	while(i<=mid)
		t[k++]=cqr[i++];
	while(j<=r)
		t[k++]=cqr[j++];
	for(int p=l;p<=r;p++)
		cqr[p]=t[p];
}
bool check(int p){
	for(int i=1;i<=n;i++){
		cqr[i]=a[i].y-p*a[i].x;
	}
	cnt=0;
	ssort(1,n);
	return cnt>=k;
}
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i].x>>a[i].y;
	}
	sort(a+1,a+1+n);
	int l=-INF,r=INF,ans;
	while(l<=r){
		int mid=(l+r)>>1;
		if(check(mid)){
			ans=mid;
			l=mid+1;
		}else{
			r=mid-1;
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：傅思维666 (赞：7)

## 题解：

2020.12.2赛前最后一次模拟赛T3暴力场。

$O(n^2)$暴力的分数应该是人均分吧。

然后开始想优化。

正解应该是$O(n\log n)$的做法，所以考虑和2有关的算法，二分。

二分什么东西比较好呢？直接二分答案吧。对于第K大，二分答案，如果比它大的多于K个，右移区间，否则左移。

难点在于如何快速判断有多少比它大的直线。如果直接$O(n^2)$枚举，那二分干什么。所以，思考对判断的过程进行优化，也就是推一推性质、式子来着。

对于两个点连线所构成的斜率，假设两个点为$i,j$，当前二分到的斜率为$S$，如果这个斜率大于它，那么会有：
$$
\frac{y_i-y_j}{x_i-x_j}\ge S
$$
乘过去再移项，会有：
$$
y_i-Sx_i\ge y_j-Sx_j
$$
芜湖，长得就一样了呀。

所以现在对于每个点$i$，我们都可以处理出一个$y_i-Sx_i$，令其为$t_i$，然后就变成了一个二维偏序问题：对于$S$，有多少点对满足$x_i<x_j$且$t_i<t_j$，也就是求“顺序对”。

原理和求逆序对是一样的，我这里用的是归并排序，对于归并排序求逆序对，请看：[归并排序求逆序对](https://www.cnblogs.com/fusiwei/p/11656294.html)

代码：

```cpp
#include<cstdio>
#include<algorithm>
#define int long long
using namespace std;
const int maxn=1e5+5;
const int INF=2e8;
int n,k,ans,tmp;
struct node
{
	int x,y;
}p[maxn];
int a[maxn],t[maxn];
bool cmp(node a,node b)
{
	if(a.x==b.x)
		return a.y>b.y;
	return a.x<b.x;
}
void merge_sort(int l,int r)
{
	int mid=(l+r)>>1;
	if(l==r)
		return;
	merge_sort(l,mid);
	merge_sort(mid+1,r);
	int i=l,j=mid+1,k=l;
	while(i<=mid&&j<=r)
	{
		if(a[i]<=a[j])
		{
			tmp+=(r-j+1);
			t[k++]=a[i++];
		}
		else
			t[k++]=a[j++];
	}
	while(i<=mid)
		t[k++]=a[i++];
	while(j<=r)
		t[k++]=a[j++];
	for(int p=l;p<=r;p++)
		a[p]=t[p];
}
bool check(int x)
{
	for(int i=1;i<=n;i++)	
		a[i]=p[i].y-x*p[i].x;
	tmp=0;
	merge_sort(1,n);
	return tmp>=k;
}
signed main()
{
	scanf("%lld%lld",&n,&k);
	for(int i=1;i<=n;i++)
		scanf("%lld%lld",&p[i].x,&p[i].y);
	sort(p+1,p+n+1,cmp);
	int l=-INF,r=INF;
	while(l<=r)
	{
		int mid=(l+r)>>1;
		if(check(mid))
		{
			ans=mid;
			l=mid+1;
		}
		else
			r=mid-1;
	}
	printf("%lld\n",ans);
	return 0;
}
```



---

## 作者：lam_dyr (赞：5)

人生第一道紫题题解 qaq

## 题意

给定平面上 $n$ 个不同的点，要求找出所有存在斜率的直线（即 $x_i \neq x_j$）并按斜率从大到小排序后，第 $k$ 条直线的斜率的向下取整值。

由于 $n$ 较大（$1 \leq n \leq 10^5$），暴力 $n^2\log n$ 不可行，需要考虑优化。

## 思路：二分 + 树状数组

二分斜率：

- 找到一个整数 $mid$，使得至少有 $k$ 条直线的斜率大于等于 $mid$，同时小于 $mid+1$ 的直线数量不足 $k$ 条。

那么如何计算斜率 $\geq mid$ 的直线数量呢？

由点斜式方程 
$$\frac{y_j-y_i}{x_j-x_i}>mid$$
得 
$$y_j-mid\times x_j>y_i-mid\times x_i$$
注意 $x_j$ 必须大于 $x_i$。

此时不妨将所有点按 $x$ 坐标升序排序。对于每个点 $j$，计算 $c_j = y_j - mid\times x_j$。

对所有计算得到的 $c_j$ 离散化后，通过遍历排序后的点，并使用树状数组来统计满足条件的点对数量即可。

注意一点：当 $x_i=x_j$ 时斜率为 $0$，需要分组处理具有相同 $x$ 坐标的点。对于每个组内的点，先进行查询，再进行更新。

## Code

```cpp
#include <iostream>
#include <algorithm>
#define int long long
#define lowbit(x) x & (-x)
using namespace std;
typedef long long ll;
int sz;
int tr[200005],tx[100010],ty[100010];
int x[100005],y[100005],idx[100005];
void upd(int x,int y=1) {
    while(x<=sz){
        tr[x]+=y;
        x+=lowbit(x);
    }
}
int qry(int x) {
    int res=0;
    while(x>0){
        res+=tr[x];
        x-=lowbit(x);
    }
    return res;
}
ll cnt_ge(int m,int tx[],int ty[],int n){
    ll c[100010];
    for(int j=0;j<n;j++) 
        c[j]=(ll)ty[j]-(ll)m*tx[j];
    ll srt[100010];
    for(int i=0;i<n;i++) srt[i]=c[i];
    sort(srt,srt+n);
    int unisz=unique(srt,srt+n)-srt;
    int rnk[100010];
    for(int j=0;j<n;j++) 
        rnk[j]=lower_bound(srt,srt+unisz,c[j])-srt+1;
    sz=unisz;
    fill(tr,tr+sz+1,0);
    ll tot=0;
    int j=0;
    while(j<n){
        int cur=tx[j];
        int l=j;
        while(j<n && tx[j]==cur)
            j++;
        int r=j;
        for(int t=l;t<r;t++) 
            tot+=qry(rnk[t]);
        for(int t=l;t<r;t++) 
            upd(rnk[t]);
    }
    return tot;
}
bool cmp(int i, int j) {
    if(x[i]!=x[j]) return x[i]<x[j];
    return y[i]<y[j];
}
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
	cout.tie(0);
    int n,k;
    cin>>n>>k;
    for(int i=0;i<n;i++) cin>>x[i]>>y[i];
    for(int i=0;i<n;i++) idx[i]=i;
    sort(idx,idx+n,cmp);
    for(int i=0;i<n;i++){
        tx[i]=x[idx[i]];
        ty[i]=y[idx[i]];
    }
    int l=-1000000000;
    int r=1000000000;
    int ans=-1;
    while(l<=r){
        int mid=l+(r-l)/2;
        ll cnt=cnt_ge(mid,tx,ty,n);
        if(cnt>=(ll)k){
            ans=mid;
            l=mid+1;
        }
        else
            r=mid-1;
    }
    cout<<ans;
    return 0;
}
//不开long long见祖宗。
```

---

## 作者：Dark_lightrq (赞：4)

##### 为什么没有归并的题解，难道归并不香吗（~~逃~~

这题容易想到二分答案，毕竟直接计算感觉没有什么好方法，对一个二分的斜率KY，我们要判定它是否合理，就要找到有多少对直线斜率要大于KY，记有A对直线斜率大于KY，若是A<k，说明第k大的直线斜率应该要小于二分值，否则就要大于或等于二分值，

问题是如何找到有多少直线斜率要大于KY

![](https://cdn.luogu.com.cn/upload/image_hosting/4wk69kwu.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

即我们要找到有多少点满足x1<x2&&y1-k * x1<y2-k * x2
这就是个二位偏序问题啦，用归并排序求顺序对成功卡到最优解qwq
```cpp
#include<bits/stdc++.h>
#define LL long long
#define RE register 
using namespace std;
const int N=100005;

struct node{
	int x,y;
}p[N];
bool cmp(node a,node b){//排序
	return a.x^b.x?a.x<b.x:a.y>b.y;
}
LL n,k;

LL t[N];
LL ans,b[N];//备用数组
void calc(int l,int r){
	if(l==r)return;
	int mid=l+r>>1;
	calc(l,mid);
	calc(mid+1,r);
	int i=l,j=mid+1,bk=l;
	while(i<=mid&&j<=r){//模仿求逆序对的做法
		b[bk++]=t[i]<=t[j]?ans+=r-j+1,t[i++]:t[j++];
	}
	while(i<=mid)b[bk++]=t[i++];
	while(j<=r)b[bk++]=t[j++];
	for(RE int i=l;i<=r;i++)t[i]=b[i];
}

bool check(int mid){//判定
	for(RE int i=1;i<=n;i++)t[i]=p[i].y-(LL)mid*p[i].x;
	ans=0;
	calc(1,n);
	return ans>=k;
}
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		scanf("%d%d",&p[i].x,&p[i].y);
	}
	sort(p+1,p+1+n,cmp);//读入
	
	int L=-2e8,R=2e8;
	while(L<R){//二分
		int mid=L+R+1>>1;
		if(check(mid))L=mid;
		else R=mid-1;
	}
	cout<<L;
	return 0;
}
```
但是这题有个坑点就是x1==x2时不能计入答案，所以要以y为第二优先级按大到小排序保证不计入答案

---

## 作者：Flaw_Owl (赞：4)

# 审题部分

“求斜率**从大到小排序**之后，第 $k$ 条直线的斜率。”

斜率从大到小排序之后形成了一种**单调关系**，或许可以考虑**二分**：假设当前的斜率为 $K$，放在这个排序后的斜率序列中，就会有 $cnt$ 条大于 $K$ 的斜率。我们要找的“第 $k$ 条直线的斜率”，就可以猜想等价为“恰好有 $k$ 条大于等于 $K$ 的斜率”。

“为了避免精度误差，请输出**斜率向下取整**后的结果。”

这句话保证了二分的正确性。假设最终需要输出的答案为 $ans$，二分的过程中就必然有 $mid \leq ans < mid+1$。同时说明了我们只要枚举整数，二分模板为整数二分。

# 二分模板
那么此时，我们可以确定本体的基本方法是二分。根据二分的基本模板，我们可以先确定一些信息：

1.确定左右端点：由于 $|x_i|$，$|y_i| \leq 10^8$，有斜率 $|k| \leq \frac{y_{max}-y_{min}}{1}=2\times10^8$。故左右端点为 $\pm2\times10^8$。

2.确定 `check()` 函数：求出当前有 $cnt$ 条大于等于 $K$ 的斜率，如果 $cnt<K$，说明 $K$ 太大了，向左移动；反之，向右移动。

```cpp
// 二分模板
bool check(int mid)
{
	int cnt = 0;
	// 求解 cnt 
	if (cnt >= k)
		return true;
	else
		return false;
}

int main()
{
	// 省略其他操作

	// 二分
	int ans;
	int left = -2e8, right = 2e8;
	while (left <= right)
	{
		int mid = (left + right) >> 1;
		if (check(mid))
		{
			left = mid + 1;
			ans = mid;
		}
		else
			right = mid - 1;
	}
	printf("%d", ans);
	return 0;
}
```
那么接下来的难点就在于，如何求出这个 $n$。

我们可以先写出我们的关系式，对于所有的点，有 $\frac{y_j-y_i}{x_j-x_i}\geq K$。可以变形同构为 $y_j - Kx_j \geq y_i-Kx_i$。

问题转化为，我们可以找到多少点对 $(i,j)$，使得上式成立。这实际上是一种二维偏序类题。对于此类问题，我的求解思路是将其降维为一维偏序，即逆序对问题。

# 二维偏序：降维成逆序对问题+树状数组+离散化
（如果你不知道逆序对问题怎么求解，请参见逆序对模板题：[P1908 逆序对](https://www.luogu.com.cn/problem/P1908)）

接下来我们将二维降维：不妨设 $t_i=y_i-K\times x_i$，公式写成 $t_i \geq t_j$。我们预先将原本的点序列按 $x$ 从小到大排序，就可以将问题转化为 $i<j$ 时，求 $t_i \geq t_j$ 的个数。

求解偏序对的方法有归并排序和树状数组两种，个人习惯使用后者。要注意的是，由于逆序对问题实际上只考虑数组内数字的相对大小，所以为了防止爆空间，一般会和离散化一起搭配使用。

```cpp
// 下面的代码只展示树状数组求逆序对问题的关键代码
// 部分变量命名如下：
// tree[] 树状数组本人
// bool cmp() 按点本身的值为第一关键词，点的序号为第二关键词排序
// b[] 离散化之后的数组
#define lowbit(x) ((x)  & - (x))

void update(int x, int d)
{
	while (x <= n)
	{
		tree[x] += d;
		x += lowbit(x);
	}
}

int sum(int x)
{
	int ans = 0;
	while (x)
	{
		ans += tree[x];
		x -= lowbit(x);
	}
	return ans;
}

sort(t + 1, t + 1 + n, cmp);
for (int i = 1; i <= n; i++)
	b[t[i].num] = i;

long long cnt = 0;
for (int i = n; i >= 1; i--)
{
	update(b[i], 1);
	cnt += sum(b[i] - 1);
}
```

# 值得注意的其他细节
但是，我们在对原点对序列进行排序的时候，还没有考虑当 $x$ 相同的时候，应当按照 $y$ 的升序还是降序排列。考虑实际意义，$x$ 相同的时候，此时斜率是不存在的，不应当被算作一组可用的逆序对，也就是要让 $t_i < t_j$，由于  $x_i=x_j$，只需让 $y_i<y_j$。也就是 $y$ 的升序排列。

以及要注意开`long long`。

# AC代码
```cpp
#include <iostream>
#include <cstdio> // 快读：getchar()
#include <cctype> // 快读：isdigit()
#include <algorithm> // 排序：sort()
#include <string.h> // 重置数组：memset()
#define ll long long
#define lowbit(x) ((x) & - (x)) // 树状数组

using namespace std;

// 快读
ll read()
{
	ll x = 0, f = 1;
	char ch = 0;
	while (!isdigit(ch))
	{
		if (ch == '-')
			f = -1;
		ch = getchar();
	}
	while (isdigit(ch))
	{
		x = x * 10 + ch - '0';
		ch = getchar();
	}
	return x * f;
}

const int maxN = 1e5 + 5;

ll n, k;

int tree[maxN]; // 树状数组
int b[maxN]; // 离散化数组

// 原点序列
struct point1
{
	int x, y;
}a[maxN];

// 降维后的点序列
struct point2
{
	ll val, num;
}t[maxN];

// 降维：x为第一关键字升序，y为第二关键字降序
bool cmp1(point1 a, point1 b)
{
	if (a.x == b.x)
		return a.y > b.y;
	return a.x < b.x;
}

// 离散：val为第一关键字，num为第二关键字，升序
bool cmp2(point2 a, point2 b)
{
	if (a.val == b.val)
		return a.num > b.num;
	return a.val > b.val;
}

// 树状数组：修改
void update(int x, int d)
{
	while (x <= n)
	{
		tree[x] += d;
		x += lowbit(x);
	}
}

// 树状数组：查询
int sum(int x)
{
	int ans = 0;
	while (x)
	{
		ans += tree[x];
		x -= lowbit(x);
	}
	return ans;
}

// 二分：检查函数
bool check(ll mid)
{
	memset(tree, 0, sizeof(tree));
	
	// 离散化
	for (int i = 1; i <= n; i++)
	{
		t[i].val = a[i].y - mid * a[i].x;
		t[i].num = i;
	}
	sort(t + 1, t + 1 + n, cmp2);
	for (int i = 1; i <= n; i++)
		b[t[i].num] = i;

	// 树状数组求偏序对
	ll cnt = 0;
	for (int i = n; i >= 1; i--)
	{
		update(b[i], 1);
		cnt += sum(b[i] - 1);
	}

	// 判断条件
	return cnt >= k;
}

int main()
{
	// 读入数据
	n = read();
	k = read();
	for (int i = 1; i <= n; i++)
	{
		a[i].x = read();
		a[i].y = read();
	}
	sort(a + 1, a + 1 + n, cmp1);

	// 二分
	ll ans;
	ll left = -2e8, right = 2e8;
	while (left <= right)
	{
		ll mid = (left + right) >> 1;
		if (check(mid))
		{
			left = mid + 1;
			ans = mid;
		}
		else
			right = mid - 1;
	}

	// 输出
	printf("%lld", ans);
	return 0;
}
```

---

## 作者：yuruilin2026 (赞：3)

## 一些闲话：
膜拜神犇 [Hootime](https://www.luogu.com.cn/user/1275540)，如果不是他告诉我这是一道水紫然后我也不会去做（然后就做了两天）。
## 题意：
求 $n^2$ 条线中的第 $k$ 大斜率。\
补充斜率公式（在我们这里好像是初二内容）：\
设两个点 $P,Q$ 的 $x,y$ 坐标分别是 $P_x,P_y,Q_x,Q_y$。
- 若 $P_x > Q_x$，斜率为 $\frac{P_y-Q_y}{P_x-Q_x}$。
- 若 $P_x < Q_x$，斜率为 $\frac{Q_y-P_y}{Q_x-P_x}$。
- 若 $P_x = Q_x$，不存在斜率。
## 思路：
$O(n^2 \log n^2)$ 的暴力很容易吧（暴力都不会的话这道题还不是你的水平能做的）。\
分析数据，$n \le 10^5,k \le m \le n^2 \le 10^{10}$，应该是一个 $O(n \log n)$ 或者 $O(n \log k)$ 的做法。\
然后就能想到二分。\
二分什么？直接二分答案吧。二分一个 $mid$，如果比 $mid$ 大的多于 $k$ 个，右移区间，否则左移。\
好像是一个 $O(n \log n \log k)$ 的做法，但能过。\
再来分析式子：\
设 $P_x > Q_x$。\
需要判断 $\frac{P_y-Q_y}{P_x-Q_x} \ge mid$。\
去分母可得：$P_y-Q_y \ge mid \times (P_x-Q_x)$。\
展开可得：$P_y-Q_y \ge mid \times P_x - mid \times Q_x$。\
移项可得：$P_y - mid \times P_x \ge Q_y - mid \times Q_x$。\
（为美观性，接下来两行本应大写的 $I,P,Q$ 写成小写）。\
令 $a_i = i_y - mid \times i_x$。\
原式可化为 $a_p \ge a_q$。\
那不就是一个求数组顺序对的题目吗？\
归并排序或者树状数组都行。\
这里用的归并排序，那么直接上代码：
## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int a[100005],b[100005];
int l = -2e8,r = 2e8,mid1;
int n,ans,answer,k;
struct ppp{
	int x,y;
}p[114514];
bool cmp(ppp xx,ppp yy){
	if(xx.x == yy.x) return xx.y > yy.y;
	return xx.x < yy.x;
}
void smort(int left,int right){//归并排序模板 
    if(left == right) return;
    int mid = (left+right) / 2;
    smort(left,mid);
    smort(mid+1,right);
    int i = left,j = mid+1,k = left;
    while(i <= mid && j <= right){
        if(a[i] <= a[j]) b[k++] = a[i++],ans += right-j+1;
        else b[k++] = a[j++];
    }
    while(j <= right) b[k++] = a[j++];
    while(i <= mid) b[k++] = a[i++];
    for(int i = left;i <= right;i++) a[i] = b[i];
}
bool check(int xx){
	for(int i = 1;i <= n;++i) a[i] = p[i].y - xx * p[i].x;//处理 a 数组 
	ans = 0;
	smort(1,n);//归并排序模板 
	if(ans >= k) return 1;
	return 0;
}
signed main(){
	cin.tie(0),cout.tie(0);
    cin >> n >> k;
    for(int i = 1;i <= n;i++) cin >> p[i].x >> p[i].y;
    sort(p+1,p+n+1,cmp);//这里要 sort 是保证 Px < Qx（虽然分析的时候是反过来的） 
    while(l <= r){
		mid1 = (l+r)>>1;
		if(check(mid1)) l = mid1+1,answer = mid1;
		else r = mid1-1;
	}
	cout << answer;
    return 0;
}
```

---

## 作者：XCDRF_ (赞：2)

# P4479 \[BJWC2018] 第 k 大斜率

[原题传送门](https://www.luogu.com.cn/problem/P4479)

[更好的阅读体验](https://www.luogu.com.cn/article/zoxnr9vv)

## 解题思路

看到题目后先想暴力，把每条斜率存在的直线都算出来，输出第 $k$ 大的斜率即可。时间复杂度 $O(n^2)$。

如何优化？输出第 $k$ 大，想到二分斜率。不过怎样判断有多少条直线的斜率比它大呢？可以从斜率本身来考虑这个问题。设直线过的两个点的为 $(x_i,y_i)$ 和 $(x_j,y_j)$，则该直线的斜率为 $\dfrac{y_j-y_i}{x_j-x_i}$。如果该斜率大于 $mid$，则 $y_j-y_i>mid(x_j-x_i)$，整理得 $y_j-mid\cdot x_j>y_i-mid\cdot x_i$（仅当 $x_j>x_i$ 时成立）。设 $t_i=y_i-mid\cdot x_i$，若 $x_j>x_i$ 且 $t_j>t_i$，则该直线斜率大于 $mid$。此时问题就转化成了二维偏序问题，用树状数组维护即可。时间复杂度 $O(n\log n)$。

## 注意事项

1. 如果用树状数组，$t_i$ 范围可能过大，此时需要离散化。
2. 注意到当 $x_i=x_j$ 时，斜率不存在，此时可以在按 $x_i$ 升序排序的基础上按 $y_i$ 降序排序，这样就可以筛掉 $x_i=x_j$ 的情况。
3. 二分范围不要太大，否则会爆 long long。
4. 每次二分时树状数组记得清空。

## 参考代码

```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#define int long long
#define pii pair<int,int>
#define fi first
#define se second
#define mp make_pair
#define mid (l+r+1>>1)
#define lowbit(i) (i&(-i))
using namespace std;
const int N=1e5+5;
int n,k;
pii a[N];
int b[N],c[N],t[N];
void add(int x){
	for(;x<=n;x+=lowbit(x)) c[x]++;
}
int query(int x){
	int ans=0;
	for(;x;x-=lowbit(x)) ans+=c[x];
	return ans;
}
bool cmp(pii a,pii b){
	if(a.fi==b.fi) return a.se>b.se;
	return a.fi<b.fi;
}
bool check(int p){
	int ans=0;
	for(int i=1;i<=n;i++) t[i]=a[i].se-p*a[i].fi,b[i]=t[i];
	sort(b+1,b+n+1);
	memset(c,0,sizeof(c));
	int cnt=unique(b+1,b+n+1)-b-1;
	for(int i=1;i<=n;i++) t[i]=lower_bound(b+1,b+cnt+1,t[i])-b;
	for(int i=1;i<=n;i++){
		ans+=query(t[i]);
		add(t[i]);
	}
	return ans>=k;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i].fi>>a[i].se;
	}
	sort(a+1,a+n+1,cmp);
	int l=-2e8,r=2e8;
	while(l<r){
		if(check(mid)) l=mid;
		else r=mid-1;
	}
	cout<<l;
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/197567248)

---

## 作者：naroto2022 (赞：2)

# P4479 题解

### 题面

[原题传送门](https://www.luogu.com.cn/problem/P4479)

### 前置知识

1. 树状数组求逆序对。（不会的看后记。）
2. 二维偏序。（不会的可以利用这道题学一学。）
3. 知道斜率公式。

### 思路

首先，$O(n^2)$ 的大家肯定都没有问题。

接下来就开始考虑正解，首先答案是从大到小第 $k$ 大的斜率，满足单调性，就可以二分答案。

那二分答案也很好想，只要判断有几个斜率大于等于 $mid$ 即可，接下来就开始推式子。

首先，一个直线（不妨设 $x_i<x_j$）的斜率大于 $num$ 得满足如下式子。

$$\frac{y_i-y_j}{x_i-x_j}>num$$

$$y_i-y_j>num\times(x_i-x_j)$$

$$y_i-num\times x_i>y_j-num\times x_j$$

咱们令 $t_i=y_i-num\times x_i$，于是问题就转化为满足 $x_i<x_j,t_i>t_j$ 的数对的个数。

于是这就是二维偏序的问题。

接下来就是要把二维降维成一维偏序。（就是求逆序对。）其实也很简单啦，只要将 $x$ 数组提前从小到大排序一下（那么前提条件 $x_i<x_j$ 就满足了）就可以啦。

### 实现细节

1. 二分的边界，这个其实挺好想，就是斜率最大的时候为 $\frac{y_{max}-y_{min}}{1}=2\times10^8$。
2. 对输入的点进行排序的时候 $y$ 的关键字。（如果错了就喜提 $40$ 分的好成绩。）当 $x_i=x_j$ 时，这时候斜率是不存在的，所以它不能被计入答案，所以要 $y_i>y_j$。

### 代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#define ll long long
using namespace std;
const int MN=1e5+5;
ll n,k,t[MN],ans,rk[MN];
struct point{ll x,y;}a[MN];
struct node{ll val,id;}q[MN];
void write(ll n){if(n<0){putchar('-');write(-n);return;}if(n>9)write(n/10);putchar(n%10+'0');}
ll read(){ll x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}return x*f;}
ll lowbit(ll x){return x&-x;}
void change(ll x, ll v){while(x<=n){t[x]+=v;x+=lowbit(x);}}
ll query(ll x){ll res=0;while(x){res+=t[x];x-=lowbit(x);}return res;}
bool cmp1(point a, point b){return a.x==b.x?a.y>b.y:a.x<b.x;}
bool cmp2(node a, node b){return a.val==b.val?a.id>b.id:a.val>b.val;}
bool check(ll num){
    ll res=0;
    memset(t,0,sizeof(t));
    for(int i=1; i<=n; i++) q[i].id=i,q[i].val=a[i].y-num*a[i].x;//降维。
    sort(q+1,q+1+n,cmp2);
    for(int i=1; i<=n; i++) rk[q[i].id]=i;//常规离散化。
    for(int i=n; i>=1; i--){//常规求逆序对。
        res+=query(rk[i]-1);
        change(rk[i],1);
    }
    return res>=k;
}
int main(){
    n=read();k=read();
    for(int i=1; i<=n; i++) a[i].x=read(),a[i].y=read();
    sort(a+1,a+1+n,cmp1);//按照x的升序，y的降序排序。
    ll l=-2e8,r=2e8;//见实现细节
    while(l<=r){//二分答案。
        ll mid=l+r>>1;
        if(check(mid)) l=mid+1,ans=mid;
        else r=mid-1;
    }
    write(ans);putchar('\n');
    return 0;
}
```

### 后记

这里来介绍下树状数组求逆序对。（虽然原题的题解可能会更好。）

[逆序对](https://www.luogu.com.cn/problem/P1908#submit)

首先我们先理解下逆序对的本质是求 $i<j,a_i>a_j$ 的 $(i,j)$ 的个数。

接下来开始介绍算法。

用树状数组接逆序对需要的一个思想（或者说技巧），**把数字看做树状数组的下标**。接下来就是一次处理每一个元素，树状数组的下标所对应的元素数值加 $1$，统计前缀和，这就是逆序对的数量。倒序和正序处理均可，这里介绍倒序。

倒序依次处理每一个数，当前数字的前一个数的前缀和即为以该数为较大数的逆序对个数。

当然，一般求逆序对的时候为了防止因为数据太大，会选择离散化，因为求逆序对只需要每对数的相对大小，这样就可以用树状数组维护了。

代码如下。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#define ll long long
using namespace std;
const int MN=1000005;
ll n,m,x,rk[MN],t[MN],ans;
struct node{ll id,val;}a[MN<<2];
ll read(){ll x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}return x*f;}
ll lowbit(ll x){return x&-x;}
void change(ll x, ll v){while(x<=n){t[x]+=v;x+=lowbit(x);}}
ll query(ll x){ll res=0;while(x){res+=t[x];x-=lowbit(x);}return res;}
bool cmp(node x, node y){if(x.val==y.val)return x.id<y.id;return x.val<y.val;}
int main(){
	n=read();
	for(int i=1; i<=n; i++) a[i].val=read(),a[i].id=i;
	sort(a+1,a+1+n,cmp);
	for(int i=1; i<=n; i++) rk[a[i].id]=i;//离散化
	ans=0;
	for(int i=n; i>0; i--){//倒序求逆序对
		change(rk[i],1);
		ans+=query(rk[i]-1);
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：creation_hy (赞：2)

经典套路，二分后转化为求 $\dfrac{x_i-x_j}{y_i-y_j}\ge k$ 的点对数量。

移项可变为 $x_i-x_j\ge k(y_i-y_j)$，注意 $y_i-y_j$ 必须 $\ge1$ 才满足不等式的性质。

再移项可得 $x_i-ky_i\ge x_j-ky_j$，再加上 $y_i\ge y_j$，发现是二维偏序，排序并离散化后树状数组求动态前缀和即可。

注意输入的 $x,y$ 是反的。~~有没有可能其实是我写反了~~

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e5 + 5;
int n;
ll m, buc[N], tot;
struct node
{
    ll x, y;
} a[N], b[N];
struct BIT
{
    int sum[N];
    inline int lowbit(int x) { return x & -x; }
    inline void insert(int x)
    {
        for (; x <= tot; x += lowbit(x))
            sum[x]++;
    }
    inline int query(int x)
    {
        int res = 0;
        for (; x; x -= lowbit(x))
            res += sum[x];
        return res;
    }
} tr;
inline bool check(int k)
{
    tot = 0;
    for (int i = 1; i <= n; i++)
        b[i].x = a[i].y, buc[++tot] = b[i].y = a[i].x - a[i].y * k;
    sort(buc + 1, buc + 1 + tot);
    tot = unique(buc + 1, buc + 1 + tot) - buc - 1;
    for (int i = 1; i <= n; i++)
        b[i].y = lower_bound(buc + 1, buc + 1 + tot, b[i].y) - buc;
    sort(b + 1, b + 1 + n, [](node x, node y)
         { return x.x < y.x; });
    ll cnt = 0;
    memset(tr.sum, 0, sizeof(tr.sum));
    for (int i = 1, j = 1; i <= n;)
    {
        while (j <= n && b[i].x == b[j].x)
            cnt += tr.query(b[j++].y);
        while (i < j)
            tr.insert(b[i++].y);
    }
    return cnt >= m;
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> a[i].y >> a[i].x;
    int l = -2e8, r = 2e8;
    while (l <= r)
    {
        int mid = l + r >> 1;
        if (check(mid))
            l = mid + 1;
        else
            r = mid - 1;
    }
    cout << l - 1 << '\n';
    return 0;
}
```

---

## 作者：LinkCatTree (赞：1)

一些更好的[观感](https://3zinc.github.io/2023/27265/)。

观察数据范围，发现 $n \leq 10^5$，很容易联想到 $\mathcal{O}(n\log n)$ 的复杂度。

再观察，我们发现题目只要求第 $k$ 大的斜率**向下取整**的结果。所有考虑进行二分答案，即枚举第 $k$ 大的斜率。

我们可以设计一个 `check(a)` 函数，表示斜率 $a$ 是否大于等于第 $k$ 大的斜率。当 `check(a)=true` 时，我们就减小 $a$，反之则增大 $a$。

假设斜率 $a$ 大于某一直线 $(x_i,y_i) \to (x_j,y_j)$ 的斜率，得到不等式 $\dfrac{y_i-y_j}{x_i-x_j}\leq a$。

整理，得到 $y_i-ax_i \leq y_j-ax_j$。（假设 $x_i>x_j$）

我们发现，对于 `check(a)`，我们可以处理出 $f_i=y_i-ax_i$，接下来就转换成在 $f$ 中寻找顺序对的数量，即满足 $i < j,f_i \leq f_j$ 的 $(i,j)$ 数对的数量。

寻找顺序对可以使用归并排序解决。总时间复杂度 $\mathcal{O}(n \log^2n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAXN=100005;
const ll oo=2e8;
struct Point {
    ll x,y;
    friend bool operator<(const Point tmp1,const Point tmp2) {
        if(tmp1.x==tmp2.x) return tmp1.y>tmp2.y;
        return tmp1.x<tmp2.x;
    }
};
Point a[MAXN];
ll f[MAXN],ff[MAXN],result,k;
int n;
void mergeSort(int l,int r) {
    if(l==r) return ;
    int mid=l+r>>1,i,j,k;
    mergeSort(l,mid),mergeSort(mid+1,r);
    for(i=l,j=mid+1,k=l;i<=mid&&j<=r;)
        if(f[i]<=f[j]) ff[k++]=f[i++],result+=(ll)(r-j+1);
        else ff[k++]=f[j++];
    for(;i<=mid;) ff[k++]=f[i++];
    for(;j<=r;) ff[k++]=f[j++];
    for(i=l;i<=r;i++) f[i]=ff[i];
    return ;
}
bool check(ll res) {
    for(int i=1;i<=n;i++) f[i]=a[i].y-res*a[i].x;
    result=0,mergeSort(1,n);
    return result>=k;
}
int main() {
    scanf("%d%lld",&n,&k);
    for(int i=1;i<=n;i++) scanf("%lld%lld",&a[i].x,&a[i].y);
    sort(a+1,a+1+n);
    ll l=-oo,r=oo,ans;
    while(l<=r) {
        ll mid=l+r>>1;
        if(check(mid)) ans=mid,l=mid+1;
        else r=mid-1;
    }
    printf("%lld\n",ans);
    system("pause");
    return 0;
}
```

完。

---


# 【XR-3】系统设计

## 题目描述

小 X 需要你设计一个系统。

这个系统首先需要输入一棵 $n$ 个点的有根树和一个长度为 $m$ 的序列 $a$，接下来需要实现 $q$ 个操作。

操作分两种：

1. `1 x l r` 表示设定起点为有根树的节点 $x$，接下来依次遍历 $l \sim r$。当遍历到 $i$ 时，从当前节点走向它的编号第 $a_i$ 小的儿子。如果某一时刻当前节点的儿子个数小于 $a_i$，或者已经遍历完 $l \sim r$，则在这个点停住，并输出这个点的编号，同时停止遍历。
2. `2 t k` 表示将序列中第 $t$ 个数 $a_t$ 修改为 $k$。

## 说明/提示

本题读入、输出量较大，请使用[读入、输出优化](https://oi-wiki.org/misc/io/)。

【样例说明】

第一个操作为 `1 1 1 3`，即 $1 \rightarrow 2 \rightarrow 4$，因此答案为 $4$。

第九个操作后，序列变为 `2 1 2 1 2 1`。

第十个操作为 `1 1 1 5`，即 $1 \rightarrow 5 \rightarrow 6$，因此答案为 $6$。

## 样例 #1

### 输入

```
6 6 10
0 1 2 2 1 5
1 2 2 1 2 1
1 1 1 3
1 5 2 6
1 6 5 6
1 2 3 5
1 2 4 4
2 2 1
1 1 1 6
1 1 2 4
2 1 2
1 1 1 5
```

### 输出

```
4
5
6
4
3
3
4
6
```

# 题解

## 作者：Hanghang (赞：20)

妙妙题。介绍一下单 $\log$ 做法。

首先我们观察到树形态不变，那么我们可以快速求出根到每个点的序列值，通过差分也就可以知道任意祖孙点对中间的序列值。

我们需要快速查询一个序列值是否出现过，自然也就想到哈希。

哈希也是支持快速合并的，也就满足序列上的单点修改性质。

那么现在也就变成了查询最大的 $r$，满足 $L \le r \le R$ 满足根到 $x$ 的哈希值加上 $[L,r]$ 的哈希值出现过。

显然 $r$ 是满足单调性的，就可以线段树二分 (不懂为什么其他题解的线段树二分为啥是俩 $\log$ )，现在对单 $\log$ 做法进行讲解。

首先从左往右找到所有满足 $L\le l \le r \le R$ 的 $\log$ 个极大子区间，再记录一个 $cur$ 变量记录当前哈希值。

如果 $cur$ 加上当前区间 $[l,r]$ 的哈希值，如果这个值出现过就加入，然后向后循环。

否则，那么答案 $r$ 一定在 $[l,r]$ 中，直接向下递归，具体就是：

加入左子树的哈希值，如果出现过就加入，递归右子树，否则递归左子树。

那么两部分的复杂度是分开的，都是单 $\log$，那么总复杂度也就是单 $\log$。

注意到这里的哈希值很大，使用 map 会被卡常，建议使用 `pb_ds` 或者手写哈希表，不会 `pb_ds` 的右转 [如何优雅地使用 pb_ds](https://www.cnblogs.com/Hanghang007/p/17789124.html)。

跑得飞快，目前是 rk3，默认 $n,m,q$ 同阶的话，总复杂度为 $O(n \log n)$。

还有不懂的可以看代码，任何问题欢迎与我交流：

```cpp
#include<bits/stdc++.h>
using namespace std;
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>
using namespace __gnu_pbds;

typedef long long ll;
typedef unsigned long long ull;
const int N=5e5+3;
int n,m,q,rt,a[N],fa[N];
vector<int>ve[N]; 
ull bas=2e6+3,pri=229,cur=0,pw[N],sx[N],tr[N*4];
cc_hash_table<ull,int>mp;
int read()
{
    int x=0,f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    return x*f;
}
void write(int X)
{
	if(X<0){putchar('-');X=~(X-1);}int s[20],o=0;
	while(X){s[++o]=X%10;X/=10;}
	if(!o)s[++o]=0;while(o)putchar(s[o--]+'0');
	putchar('\n');
}
void Dfs(int x,int fa)
{
	mp[sx[x]]=x;
	for(int i=0,y;i<(ll)ve[x].size();i++)if((y=ve[x][i])!=fa)
	    sx[y]=sx[x]*bas+i+1+pri,Dfs(y,x);
}
#define ls (p<<1)
#define rs (p<<1|1)
#define mi ((l+r)>>1)
void Up(int p,int len){tr[p]=tr[ls]*pw[len]+tr[rs];}
void Build(int p,int l,int r)
{
	if(l==r){tr[p]=a[l]+pri;return;}
	Build(ls,l,mi);Build(rs,mi+1,r);Up(p,r-mi); 
}
void Upd(int k,int p,int l,int r,int d)
{
	if(l==r){tr[p]=d+pri;return;}
	k<=mi?Upd(k,ls,l,mi,d):Upd(k,rs,mi+1,r,d);Up(p,r-mi);
}
int Ans(int p,int l,int r)
{
	if(l==r)return l;
	ull x=cur*pw[mi-l+1]+tr[ls];
	if(mp.find(x)==mp.end())return Ans(ls,l,mi);
	cur=x;return Ans(rs,mi+1,r);
}
int Ask(int L,int R,int p,int l,int r,int &o)
{
	if(L<=l&&r<=R)
	{
		ull x=cur*pw[r-l+1]+tr[p];
		if(mp.find(x)==mp.end()){o=1;return Ans(p,l,r);}
		cur=x;return 0;
	}
	if(L>mi)return Ask(L,R,rs,mi+1,r,o);
	if(R<=mi)return Ask(L,R,ls,l,mi,o);
	int res=Ask(L,R,ls,l,mi,o);
	return o?res:Ask(L,R,rs,mi+1,r,o); 
}
int main()
{
	n=read();m=read();q=read();pw[0]=1;
	for(int i=1;i<N;i++)pw[i]=pw[i-1]*bas;
	for(int i=1;i<=n;i++)
	{
	    fa[i]=read();
		if(!fa[i])rt=i;
		else ve[fa[i]].push_back(i);
	}
	for(int i=1;i<=m;i++)a[i]=read();
	for(int i=1;i<=n;i++)sort(ve[i].begin(),ve[i].end());
	Dfs(rt,0);Build(1,1,m);
	while(q--)
	{
		int op,x,l,r;op=read();
		if(op==2){l=read();x=read();Upd(l,1,1,m,x);continue;}
		x=read();l=read();r=read();cur=sx[x];
		int fl=0;Ask(l,r,1,1,m,fl);write(mp[cur]);
	}
}
```



---

## 作者：z7z_Eta (赞：14)

题面：

一棵 $n$ 个点的有根树，

一个长度为 $m$ 的序列 $a$，

接下来需要实现 $q$ 个操作。

1. `1 x l r` 从树的节点 $x$，依次遍历序列 $l∼r$。每个数字 $a_i$ 代表树上一次跳转，即从当前节点走向它的编号第 $a_i$ 小的儿子。如果某一时刻无法跳转，输出这个点的编号，停止遍历。
2. `2 t k` 单点修改，$a_t$ 修改为 $k$。

------------

打开标签，发现里面惊奇的出现了

#### 字符串HASH

![](https://cdn.luogu.com.cn/upload/image_hosting/17ba6scy.png)

HASH真是个神奇的算法啊，，

这道题是用到了哈希的诸多性质

一个简单的想法，我们如果可以直接匹配序列上的hash值和树上跳转的hash值，直到无法匹配就好了。

这样可以二分`跳转用到的序列的长度`，如果可以在以$x$为根的子树中找到一条链和此时序列hash值相同，就表示从$x$跳转到了这条链的另一端。

怎么快速查询树上的hash值呢？先考虑所有的$x=1$的情况，因为树的结构是没有修改的，所以我们可以在dfs过程中排序子节点的编号，预处理出从父节点到子节点的数字，合并得到从1号节点到所有节点的hash值。

再来，hash是有可减性质的，其实$x\neq1$的情况就是判断`节点的hash值`是否等于`x的hash值+序列的hash值`。

序列的hash值就很好维护了，因为hash值可以快速合并，所以序列上的hash值用线段树来维护单点修改和区间查询就好了。

时间复杂度$O(n\log^2n)$，看到巨佬还有树链剖分的的题解有兴趣的自行搜索吧

### code:

```cpp
// luogu-judger-enable-o2
// SeptEtavioxy
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
#include<cmath>
#define re register
#define ll long long
#define il inline
#define rep(i,s,t) for(re int i=(s);i<=(t);i++)
#define rev_rep(i,s,t) for(re int i=(s);i>=(t);i--)
#define each(i,u) for(int i=head[u];i;i=bow[i].nxt)
#define pt(ch) putchar(ch)
#define pti(x) printf("%d",x)
#define ptll(x) printf("%lld",x)
#define file(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
using namespace std;
// c_ints
il int ci(){
	re char ch;int f=1;
	while(!isdigit(ch=getchar()))f= ch=='-'?-1:1 ;
	re int x= ch^'0';
	while(isdigit(ch=getchar()))x=(x*10)+(ch^'0');
	return f*x;
}
il char cc(){
	re char ch;
	while(isspace(ch=getchar()));
	return ch;
}

enum{N=500024};
 
#define Ull unsigned ll
class Edge{
public:
	int nxt,to;
	il void operator()(int a,int b){
		nxt=a, to=b;
	}
}bow[N];
int head[N],depth[N];

const int base = 1e9+7; //base开大到n以上
Ull num[N],powb[N];

void dfs(int u){
	static int d[N];
	int tot= 0;
	each(i,u) d[++tot]= bow[i].to;
	sort(d+1,d+tot+1);
	rep(i,1,tot) num[d[i]]= num[u]*base+i;
	each(i,u){
		int v= bow[i].to;
		depth[v]= depth[u]+1;
		dfs(v);
	}
}

struct cmp1{
	bool operator()(const int a,const int b){
		return depth[a]==depth[b] ? num[a]<num[b]:depth[a]<depth[b] ;
	}
};
Ull tbl[N],*op[N];
//这里是内存池和动态数组
int c[N],mxdep;
il void item(int n){
	rep(i,1,n) c[i]=i;//排序标号
	sort(c+1,c+n+1,cmp1());
	rep(i,1,n){
		if( depth[c[i]]!=mxdep ){
			op[++mxdep]=tbl+i;
		}
		tbl[i]= num[c[i]];
	}
	op[mxdep+1]= tbl+n+1;
}

//zkw线段树
class node{
public: int len; Ull num;
};
il node operator+(const node&a,const node&b){
	return (node){
		a.len+b.len,
		a.num*powb[b.len]+b.num
	};
}
class SEG{
public:
	int n,a[N];
	#define lc(x) ((x)<<1)
	#define rc(x) ((x)<<1|1)
	il void init(){
		m= (1<<int(log2(n+1)+1));
		rep(i,0,m-1) tr[m+i].len= 1;
		rep(i,1,n) tr[m+i].num= a[i];
		rev_rep(i,m,1) tr[i]= tr[lc(i)]+tr[rc(i)];
	}
	il node query(int l,int r){
		node L= (node){0,0}, R= (node){0,0};
		for(int s=m+l-1,t=m+r+1;s^t^1;s>>=1,t>>=1){
			if( (s&1)==0 ) L= L+tr[s^1];
			if( (t&1)==1 ) R= tr[t^1]+R;
		}
		return L+R;
	}
	il void modify(int x,int k){
		re int i= m+x;
		tr[i].num= k;
		while( i>>=1 ) update(i);
	}
private:
	int m;
	node tr[1<<20];
	il void update(int x){
		tr[x]= tr[lc(x)]+tr[rc(x)];
	}
}seg;

int main(){
	int n=ci(), m=ci(), q=ci();
	{//预处理幂
		powb[0]= 1;
		int M=max(n,m);
		rep(i,1,M) powb[i]=powb[i-1]*base;
	}
	rep(i,1,n){//邻接表存边
		int x=ci();
		bow[i](head[x],i);
		head[x]= i;
	}
	
	dfs(0);
	item(n);
	
	seg.n= m;
	rep(i,1,m) seg.a[i]=ci();
	seg.init();
	
	while( q-- ){
		if( cc()=='1' )
		{//查询
			int x=ci(), l=ci()-1, r=ci();
			int s=l+1;
			node e;
			Ull numx;
			int dep,k;
			while( l<r ){//二分
				int w= (l+r+1)>>1;
				e= seg.query(s,w);
				numx= num[x]*powb[e.len]+e.num;
				dep= depth[x]+w-s+1;
				if( dep<=mxdep && tbl[
						k=lower_bound(op[dep],op[dep+1],numx)-tbl
					]==numx ) l=w;
				else r=w-1;
			}
			e= seg.query(s,l);
			numx= num[x]*powb[e.len]+e.num;
			dep= depth[x]+l-s+1;
			k= lower_bound(op[dep],op[dep+1],numx)-tbl;
			pti(c[k]),pt('\n');
		}
		else
		{//修改
			int x=ci(), k=ci();
			seg.modify(x,k);
		}
	}
	return 0;
}
```

$noip\ rp++$

---

## 作者：lupengheyyds (赞：11)

观察性质：

1. a序列会改变，但树的形态不会改变
  
2. 给定的序列固定，其遍历的节点也随之固定
  
3. 最终有效的（让遍历节点更改的）序列一定是 $l\sim r$ 的一个前缀。且最终答案的前缀序列的任意前缀一定合法，其余前缀不合法。也就是说具有单调性。
  
4. 从 $x$ 出发可以看作从根节点 $root$ 走到 $x$ 在接着走。
  

于是可以预处理出树上任意遍历前缀。接着用二分 $l\sim r$ 的前缀，并加上 $root\sim x$ 这段路径，看是否在之前的预处理中出现过。那么这个可以用 Hash 进行快速比较。

细节：二分的左端点应为 $l-1$，因为它可以一步不走。

这里是用树状数组维护待修改的序列前缀 Hash。

注意，本题卡常。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
const int szl=5e5+5,P=131313131;
int n,m,q,fa[szl],rt,a[szl],dep[szl];
unordered_map<ull,int> mp;
vector<int> ed[szl];
ull hsh[szl],p[szl],bitr[szl],p2[szl];
void DFS(int x){
	int cnt=0;
	for(int y:ed[x]){
		cnt++;
		hsh[y]=hsh[x]*P+cnt;
		mp[hsh[y]]=y;
		dep[y]=dep[x]+1;
		DFS(y);
	}
	return;
}
//树状数组维护前缀Hash 
void Add(int x,ull y){
	for(;x<=n;y*=p[x&-x],x+=x&-x)bitr[x]+=y;
}
ull Ask(int x){
	ull y=1,sum=0;
	for(;x;y*=p[x&-x],x-=x&-x)sum+=bitr[x]*y;
	return sum;
}
ull Ask(int l,int r){
	return Ask(r)-Ask(l-1)*p[r-l+1];
}	
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n>>m>>q;
	for(int i=1;i<=n;i++){
		cin>>fa[i];
		if(!fa[i])rt=i;
		else ed[fa[i]].push_back(i);
	}
	p[0]=1;for(int i=1;i<=m;i++)p[i]=p[i-1]*P;
	for(int i=1;i<=n;i++)sort(ed[i].begin(),ed[i].end());
	DFS(rt);
	for(int i=1;i<=m;i++)cin>>a[i],Add(i,a[i]);
	for(int i=1;i<=q;i++){
		int op;cin>>op;
		if(op==1){
			int x,l,r;cin>>x>>l>>r;
			int tmp=l;l--;
			while(l<r){
				int mid=l+r+1>>1;
				if(mp.find(hsh[x]*p[(mid-tmp+1)]+Ask(tmp,mid))!=mp.end())l=mid;
				else r=mid-1;
			}
			tmp=mp[hsh[x]*p[(l-tmp+1)]+Ask(tmp,l)];
			if(tmp==0)cout<<x<<"\n";
			else cout<<tmp<<"\n";
		}else{
			int t,k;cin>>t>>k;
			Add(t,k-a[t]),a[t]=k;
		}
	}
	return 0;
}

```

---

## 作者：liangbowen (赞：7)

[blog](https://www.cnblogs.com/liangbowen/p/18306065)。今天在 XDFZ 听 ljy 讲的串串（？）题，瞎写写就混了个最优解，来发个题解（

---

注意到树的形态不变，所以可以记录兄弟间的编号 rank。每个点就可以表示为若干 rank 构成的路径，例如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/pb8y2wjr.png)

然后将每个点的这个路径压成 hash，记为 $H_i$，并丢进 map 里。

假设从 $x$ 开始，可以完全遍历完 $a_{l\sim w}$，那么等价于存在一条 rank 路径为 $H_i\to a_l\to a_{l+1}\to\cdots\to a_w$。

发现这是**可二分的**，即：如果存在 $a_{l\sim w}$ 的路径，那么也**必定存在** $a_{l\sim l}, a_{l\sim (l+1)}, \cdots, a_{l\sim (w-1)}, a_{l\sim w}$ 的路径。

所以直接二分出最大的 $w$ 使得 $a_{l\sim w}$ 的 rank 路径存在即可。

这个问题只需要做到维护 $\forall a_{l\sim r}$ 的 hash 值，线段树 / 树状数组都行，套个二分就有 $O(\log^2)$ 做法了。

注意到我们可以**线段树上二分**，这样就做到了 $O(\log)$。代码并不难写。

---

代码是最优解的一发，会有一点点抽象，不过应该看得懂 /cy。

贺了 OIWiki 的 hash 表，也可以用 `unordered_map` 实现，不过前者会快 4s。

[code](https://www.luogu.com.cn/paste/l6jnlruf)，时间复杂度 $O(n+m\log m)$。

update：传奇特级大师 @Zi_Gao 用我的代码卡到了 [4.7s](https://www.luogu.com.cn/record/166494861)，只需要把 hashtable 的 SIZE 换成个质数就行了，orz。

---

## 作者：木xx木大 (赞：7)

[P5537 【XR-3】系统设计](https://www.luogu.com.cn/problem/P5537)

这题真是一道神仙~~毒瘤~~题啊!

~~谁能想得到这玩意能Hash~~。。。

感谢并orz同校巨佬 zyt1253679098 和他的[博客](https://www.cnblogs.com/zyt1253679098/p/12008621.html)


* 因为树是不修改的，所以任意一对祖先 - 后代之间的路径都可以按题目所述的规则表示成一个**固定的**整数序列，并且这个序列是可以合并的，即如果 $u$ 是 $v$ 的祖先，$v$ 是 $w$ 的祖先，则 $(u,v)$ 的序列与 $(v,w)$ 的序列拼接起来就是 $(u,w)$ 的序列。 

* 这样，我们就可以用一个序列（对应着从根到这个结点的走法）来表示一个结点了。 我们在dfs过程中按编号给子节点排序，预处理出从父节点到子节点的数字序列， 把序列 - 结点的映射关系用哈希表存下来，就可以 $O(1)$ 判断从一个结点按照一个序列走若干步能否走到一个结点，以及查询如果能走到，走到的是哪个结点。 
* 最终做法： 预处理出每个结点序列的哈希值，并用线段树维护给定序列的哈希值。查询时在线段树上二分走的长度（即取序列 $[l,mid]$ 的部分），判断能否走到一个结点。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define pii pair<ll,ll>
#define mkp make_pair
using namespace std;
namespace FGF
{
	int n,m,Q,rt;
	const int N=1e6+5;
	const pii seed=mkp(71,853),mo=mkp(1e9+7,1e9+9);
	int read()
	{
		int s=0;char ch=getchar();
		while(!isdigit(ch))ch=getchar();
		while(isdigit(ch))s=s*10+ch-'0',ch=getchar();
		return s;
	}
	pii operator + (const pii &a,const pii &b)
	{
		return mkp((a.first+b.first)%mo.first,(a.second+b.second)%mo.second);
	 } 
	pii operator * (const pii &a,const pii &b)
	{
		return mkp((a.first*b.first)%mo.first,(a.second*b.second)%mo.second);
	}
	pii po[N],h[N];
	void init()
	{
		po[0]=mkp(1,1);
		for(int i=1;i<=n;i++)
			po[i]=po[i-1]*seed;
	}
	struct edg{
		pii to;int w,nxt;
	}e[N];
	int head[N],cnt;
	const int se=24601,p=1e6-17;
	struct HashTable{
		void add(const int a,const pii b,const int c)
		{
			cnt++;
			e[cnt].to=b,e[cnt].w=c,e[cnt].nxt=head[a],head[a]=cnt;
		}
		void inser(const pii a,const int b)
		{
			int tmp=(a.first*se+a.second)%p;
			add(tmp,a,b);	
		}
		int query(pii a)
		{
			int tmp=(a.first*se+a.second)%p;
			for(int i=head[tmp];i;i=e[i].nxt)
				if(e[i].to==a)return e[i].w;
			return -1;
		}
	}Ha;
	int a[N];
	struct tree{
		int l,r;pii val;
	}t[N<<2];
	void pushup(int ro,int len)
	{
		t[ro].val=t[ro<<1].val*po[len]+t[ro<<1|1].val;
	}
	void build(int ro,int l,int r)
	{
		t[ro].l=l,t[ro].r=r;
		if(l==r)
		{
			t[ro].val=mkp(a[l],a[l]);
			return;
		}
		int mid=(l+r)>>1;
		build(ro<<1,l,mid),build(ro<<1|1,mid+1,r);
		pushup(ro,t[ro].r-mid);
	}
	void updat(int ro,int pos,int x)
	{
		if(t[ro].l==t[ro].r)
		{
			t[ro].val=mkp(x,x);
			return;
		}
		int mid=(t[ro].l+t[ro].r)>>1;
		pos<=mid? updat(ro<<1,pos,x):updat(ro<<1|1,pos,x);
		pushup(ro,t[ro].r-mid);
	}
	pii query(int ro,int l,int r)//查询区间哈希值 
	{
		if(l<=t[ro].l&&t[ro].r<=r)return t[ro].val;
		int mid=(t[ro].l+t[ro].r)>>1;
		if(r<=mid)return query(ro<<1,l,r);
		else if(l>mid)return query(ro<<1|1,l,r);
		else return query(ro<<1,l,r)*po[min(r,t[ro].r)-mid]+query(ro<<1|1,l,r);
	}
	int askk(int ro,int l,int r,pii x)//在线段树上二分 
	{
		if(t[ro].l==t[ro].r)return Ha.query(x*seed+t[ro].val);
		int mid=(t[ro].l+t[ro].r)>>1;
		if(r<=mid)return askk(ro<<1,l,r,x);
		else if(l>mid)return askk(ro<<1|1,l,r,x);
		else
		{
			pii hh=x*po[mid-max(t[ro].l,l)+1]+(l<=t[ro].l? t[ro<<1].val:query(ro,l,mid));
			int w=Ha.query(hh);//检查能否走[l,mid]这一段区间 
			if(w==-1)return askk(ro<<1,l,r,x);//不能就继续在左区间二分 
			else //可以就查询右区间 
			{
				int tmp=askk(ro<<1|1,l,r,hh);
				return tmp==-1? w:tmp;
			}
		}
	}
	vector<int> g[N];
	void dfs(int u)//预处理出到每个点的数字序列的哈希值 
	{
		sort(g[u].begin(),g[u].end());
		int cnt=0;
		for(int sz=g[u].size(),i=0;i<sz;i++)
		{
			int v=g[u][i];
			++cnt;
			h[v]=h[u]*seed+mkp(cnt,cnt);
			dfs(v);
		}
	}
	void work()
	{
		n=read(),m=read(),Q=read();
		init();
		for(int i=1;i<=n;i++)
		{
			int x=read();
			if(!x)rt=i;
			else g[x].push_back(i);
		}
		h[rt]=mkp(0,0);
		dfs(rt);
		for(int i=1;i<=n;i++)//把每个点和其数字序列的对应关系放到哈希表里 
			Ha.inser(h[i],i);
		for(int i=1;i<=m;i++)
			a[i]=read();
		build(1,1,m);//线段树维护给定序列的哈希值 
		int op,x,l,r,ans;
		while(Q--)
		{
			op=read();
			if(op==1)
			{
				x=read(),l=read(),r=read();
				ans=askk(1,l,r,h[x]);
				printf("%d\n",ans==-1? x:ans);
			}
			else
			{
				l=read(),x=read();
				updat(1,l,x);
			}
		}
	}
}
int main()
{
	FGF::work();
	return 0;
}
```

---

## 作者：hanmm81 (赞：5)

# 题面

给定一个有根树和一个操作序列 $a$。

现有两个操作：

1. `1 x l r` 从节点 $x$ 出发，遍历 $a_l\sim a_r$，每次从当前节点向编号第 $a_i$ 小的儿子节点走，直到当前节点没有编号第 $a_i$ 小的儿子节点或 $a_l\sim a_r$ 已经遍历完为止，然后输出当前节点编号。
2. `2 t k` 将序列第 $t$ 个数 $a_x$ 修改为 $k$。

# 思路

首先，我们很容易想到二分操作序列执行到了哪儿，这样的话我们就需要快速求一个节点的指定的 $x$ 重孙。那么该如何求呢？

我们知道，像二叉堆和线段树之类的二叉树用 $2x$ 和 $2x+1$ 的方式存 $x$ 点的左右节点，而且这种方法也可以实现快速求指定的 $x$ 重孙。

我们就可以把这个运用到这道题上

以样例为例：

![样例构成的树](https://cdn.luogu.com.cn/upload/image_hosting/6xb1dk6k.png)

我们按照上面的方法标号：

![样例构成的被重新编号的树](https://cdn.luogu.com.cn/upload/image_hosting/pmm0besu.png)

我们如果从点 $1$ 开始按 $a_1\sim a_2(a_1=1,a_2=2)$ 移动就相当于到新编号为 $1\times2^2+(01)_2$ 的点，即原来编号为 $4$ 的点。

于是我们再把这个推广到 $k$ 叉树上，若 $fa$ 为节点的父亲，$rk_x$ 为节点 $x$ 在兄弟中编号排第几，那么节点 $x$ 新的编号为 

$$fa\times k+rk_x-1$$

若原来点新编号为 $x$，移动后到达的点新编号即为：

$$x\times k^{r-l+1} + \sum^r_{i=l}(a_i-1)\times k^{r-l+1}$$

但这里 $k$ 可能很大（如菊花图 $k=n-1$）且这里值可能会很大（比如一条链）我们于是可以想到哈希，然后把 $k$ 设成大质数即可。

我们用线段树维护一下 $\sum\limits^r_{i=l}(a_i-1)\times k^{r-l+1}$ ，再用 `std::map` 维护一下新编号对应的原编号这道题就做完了。

时间复杂度 $\mathcal{O}(q \log^2m)$。

# 代码（附赠数据生成器）

~~码风神奇，不建议研读，仅供对拍。~~

```c++
#include <bits/stdc++.h>
#define int long long
#define ull unsigned long long

//乖孩子千万不要学我
#define hash Hash 
#define pow Pow
 
#define maxn 500005
#define p 19491001
using namespace std;

//基础设置
ull pow[maxn];
int n,m,q,x,y;
int opt,l,r,mid,ans,pos;

//树的设置
unordered_map<ull,int> hashToId;
vector<int> v[maxn];
ull hash[maxn];
int rt,rk;
void initHash(int x,int fa,ull nowHash){//初始化哈希 
	hashToId[hash[x]=nowHash] = x;
	int rk = 0; 
	for (int i : v[x]){
		if (i == fa) continue;
		++rk,initHash(i,x,(nowHash*p+rk-1));
	}
}
void initPow(){
	pow[0] = 1;
	for (int i = 1;i <= m;i++) pow[i] = pow[i-1]*p;
}

//线段树设置 
ull tree[maxn<<2];
int treeSiz,len[maxn<<2];
void initTree(){//初始化zkw线段树和区间长度 
	for (treeSiz = 1;treeSiz <= m+1;treeSiz <<= 1);
	for (int i = 1;i <= m;i++){
		for (int j = i+treeSiz;j;j >>= 1) len[j]++;
	}
}
void update(int x,ull y){//单点修改 
	for (tree[treeSiz+x] = y,x = (treeSiz+x)>>1;x;x >>= 1)
		tree[x] = tree[x<<1]*pow[len[x<<1]]+tree[x<<1|1];
}
ull find(int l,int r){//区间查询 
	if (l > r) return 0;
	ull hashL,hashR;
	int lenL,lenR;
	hashL = hashR = lenL = lenR = 0; 
	for (l = l+treeSiz-1,r = r+treeSiz+1;l^r^1;l >>= 1,r >>= 1){
		if (~l&1) hashL = hashL*pow[len[l^1]]+tree[l^1],lenL += len[l^1];
		if (r&1) hashR = tree[r^1]*pow[lenR]+hashR,lenR += len[r^1];
		//这里一定要注意顺序，不要写成：
		//hashL = tree[l^1]*pow[lenL]+hashL or hashR = hashR*pow[len[r^1]]+tree[r^1]
	}
	return hashL*pow[lenR]+hashR;
}

//主函数 
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin >> n >> m >> q;
	for (int i = 1;i <= n;i++){
		cin >> x;
		if (x == 0) rt = i;
		else v[x].push_back(i),v[i].push_back(x);
	}
	for (int i = 1;i <= n;i++) sort(v[i].begin(),v[i].end());
	initTree(),initPow(),initHash(rt,0,1);
	for (int i = 1;i <= m;i++) cin >> x,update(i,x-1);
	while (q--){
		cin >> opt;
		if (opt == 1){
			//乖孩子也千万不要学我这样子 
			cin >> x >> l >> r,ans = l-1,pos = l;
			while (l <= r){
				mid = l + ((r - l) >> 1);
				if (hashToId.count(hash[x]*pow[mid-pos+1]+find(pos,mid))) ans = mid,l = mid + 1;
				else r = mid - 1;
			}
			cout << hashToId[hash[x]*pow[ans-pos+1]+find(pos,ans)] << '\n';
		}else{
			cin >> x >> y;
			update(x,y-1);
		} 
	}
	return 0;
} 
```

数据生成器：

```c++
#include <bits/stdc++.h>
#define dataRange 10000//数据范围
using namespace std;
int n,m,q,rt,x,maxIn,opt,l,fa[dataRange+5];
vector<int> v[dataRange+5];
int find(int x){
	return (fa[x] == x ? x : fa[x] = find(fa[x]));
}
signed main(){
	srand(time(0));
	n = dataRange,m = dataRange,q = dataRange;
	rt = rand()%n+1;
	cout << n << " " << m << " " << q << "\n";
	for (int i = 1;i <= n;i++) fa[i] = i; 
	for (int i = 1;i <= n;i++){
		if (rt == i){
			cout << 0 << " ";
			continue;
		}
		x = rand()%n+1;
		while (find(x) == find(i)) x = rand()%n+1;
		cout << x << " ",fa[find(x)] = find(i);
		v[x].push_back(i),v[i].push_back(x);
	}
	puts("");
	for (int i = 1;i <= n;i++) maxIn = max(maxIn,(int)v[i].size()-(i!=rt));
	for (int i = 1;i <= m;i++) cout << rand()%maxIn+1 << " ";
	puts("");
	for (int i = 1;i <= q;i++){
		cout << (opt=rand()%2+1) << " ";
		if (opt == 1) cout << rand()%n+1 << " " << (l=rand()%m+1) << " " << rand()%(m-l+1)+l << "\n";
		else cout << rand()%n+1 << " " << rand()%maxIn+1 << "\n";
	}
	return 0;
} 
```

---

## 作者：NightDiver (赞：4)

**本文核心卖点**：用树状数组神秘地维护哈希（不如另一篇题解巧妙，内含简单数论知识）。

观察到，走这个操作的可行性关于走的步数有单调性，考虑二分走的步数。

那么如何判断从点 $x$ 走 $mid$ 步的可行性呢？树的结构是固定的，每一种走法（路径上每个点儿子的排名构成的序列）与走到某个重点一一对应，和哈希很类似。

那么二分出 $mid$，求出走 $mid$ 步的哈希值（即为 $a[l\cdots l+mid-1]$ 的哈希值）后，如何判断这个哈希值是否存在呢？

由于每个终点可能对应很多个起点，进行 $(起点,终点)$ 的记录是 $\mathcal O(n^2)$ 的。但是这种树上问题，起点终点又有祖先关系，容易想到前缀相关。

具体怎么做呢？根走到起点构成的序列对应唯一一个起点，但是起点到终点构成序列不一定对应唯一一条路径。那么就把这两个拼在一起，在全局中存在，就是在起点的子树内存在。用 `unordered_map<ull,int>` 再维护下。

这时候万事俱备，只欠支持单点修改，区间查询的哈希值维护了。

想偷懒，不想用线段树，那么树状数组怎么做呢。

我是铸币，想不到那篇题解中的做法。于是转而用了一种稍微复杂的。

有一个初步的想法，一个正常的树状数组，维护的每一位的值为 $a[i] \times base^{n-i}$。

但是这样区间查询出的值不是 $a_l \times base^{r-l}+...+a_r \times base^{0}$ 的，而是全体乘上了一个 $base^{m-r}$，我们想要把它除掉。

这时候就要求逆元了，可是我们又想偷懒，用自然溢出，模数为 $2^{64}$，不是质数啊。

无所谓，模数是死的，$base$ 是活的，我们只要求 $base$ 的幂的逆元，选一个与 $2^{64}$ 互质的 $base$ 就行了（按照讨论区的建议，用的一个神秘 $base$）。

推荐一个计算各种数学问题的[网站](https://www.wolframalpha.com/input?i=The+multiplicative+inverse+of+3846711+modulo+18446744073709551616)，本文那个逆元就是这么算的（不可以用费马小定理），我又懒得写 exgcd。

至此，这题就完成了。

[代码在这里](https://www.cnblogs.com/TongKa/p/18357393)

---

## 作者：KaguyaH (赞：3)

给定一 $n$ 个点的有根树与长 $m$ 的序列 $a$，有 $q$ 次操作，为以下二种之一。

1. 给树上一起点 $x$，与 $a$ 中一段区间 $a_{[l, r]}$，依次遍历 $a_{[l, r]}$，尝试走到当前节点编号第 $a_i$ 小的孩子，若无合法孩子或区间遍历完成则停止，求终点；
2. 对 $a$ 单点修改。

$n, m, q \leq 5 \times 10^5$，任意时刻 $1 \leq a_i \leq n$，$1 \leq l \leq r \leq m$。

---

神仙题。

考虑 $rt \to x$ 路径唯一，记为 $p_x$，考虑将 1 操作转化为由根节点开始，并将 $p_x$ 接入 $a_{[l, r]}$ 前。

考虑二分结束位置，问题变为查询一序列是否属于 $p$、在 $p$ 中位置。

考虑哈希。利用线段树可将 2 操作变为线段树上单点修改区间查询。

我们考虑到这样是 $\mathcal O(n + m + q \log^2 m)$ 的，考虑优化。

我们发现可以用树状数组维护 $a$ 的哈希值，并在树状数组上倍增。

期望时间复杂度 $\mathcal O(n + m + q \log m + \frac n P)$​，空间复杂度 $\mathcal O(n + m + P)$​​​，其中 $P$​ 为 hash 模数中最小值。

---

代码中命名可能与上文不尽相同。

```cpp
# include <ciso646>
# include <cstdio>
# include <cstring>
# include <vector>

namespace Main {
  struct File { File(); compl File(); } file;
  typedef unsigned int uint;
  typedef short unsigned int hu;
  template <typename T> static inline const T lowbit(const T x) { return x bitand (~x + 1); }
  static inline const uint qpow(uint a, uint n, const uint mod) {
    uint r(1);
    while (n) {
      if (n bitand 1) r = 1ull * r * a % mod;
      a = 1ull * a * a % mod, n >>= 1;
    }
    return r;
  }
  static inline const uint invp(const uint x, const uint p) { return qpow(x, p - 2, p); }
  static const uint N(5e5), M(5e5);
  static const hu M_log2(18.931568569324174087221916576936);
  static const uint P[4]{ 7833673, 3637624399, 3637624387, 3637624381 }, B(500009);
  static uint pow[4][N + M + 1], ipow[4][N + M + 1];
  static inline const uint check(const uint [4]);
  # define fap(i) for (hu i(0); i < 4; ++i)
  class fenwick_tree {
    uint tree[4][M + 1];
    uint a[M + 1];
    inline const void build(const hu i) {
      // printf("build %hu\n", i);
      static uint s[M + 1]; s[0] = 0;
      for (register uint j(1); j <= M; ++j) s[j] = (s[j - 1] + 1ull * a[j] * pow[i][j]) % P[i];
      for (register uint j(1); j <= M; ++j) tree[i][j] = (0ull + s[j] + P[i] - s[j ^ lowbit(j)]) % P[i];
    }
    inline const void modify(const hu i, uint t, const uint u) {
      const uint d(1ull * (u + P[i] - a[t]) * pow[i][t] % P[i]);
      while (t <= M) tree[i][t] = (0ull + tree[i][t] + d) % P[i], t += lowbit(t);
    }
    inline const uint query(const hu i, uint x) { uint r(0); while (x) r = (0ull + r + tree[i][x]) % P[i], x ^= lowbit(x); return r; }
  public:
    inline const uint operator[](const uint x) const { return a[x]; }
    inline uint& operator[](const uint x) { return a[x]; }
    inline const void build() { fap(i) build(i); }
    inline const void modify(const uint t, const uint u) { fap(i) modify(i, t, u); a[t] = u; }
    inline const uint query(const hu i, const uint l, const uint r) { return (0ull + query(i, r) + P[i] - query(i, l - 1)) % P[i] * ipow[i][l] % P[i]; }
    inline const uint query(const uint bh[4], const uint len, const uint l, const uint r) {
      uint res(0); static uint h[4]; fap(i) h[i] = (0ull + bh[i] + P[i] - 1ull * query(i, l - 1) * ipow[i][l] % P[i] * pow[i][len] % P[i]) % P[i];
      for (hu i(M_log2); i <= M_log2; --i) {
        fap(j) h[j] = (h[j] + 1ull * tree[j][res | 1 << i] * ipow[j][l] % P[j] * pow[j][len]) % P[j];
        if ((res | 1 << i) < l or ((res | 1 << i) <= r && check(h))) res or_eq 1 << i;
        else fap(j) h[j] = (0ull + h[j] + P[j] - 1ull * tree[j][res | 1 << i] * ipow[j][l] % P[j] * pow[j][len] % P[j]) % P[j];
      }
      return check(h);
    }
  };
  struct node {
    uint f;
    std::vector<uint> daughter;
    uint h[4];
    uint depth;
    node() : f(), daughter(), depth() { memset(h, 0, sizeof h); }
    inline const bool input() { scanf("%u", &f); return isroot(); }
    inline const bool isroot() { return not f; }
  };
  struct ndl {
    const uint id;
    const ndl* const next;
    ndl() : id(), next() {}
    ndl(const uint id, const ndl* const next) : id(id), next(next) {}
    compl ndl() { if (next) delete next; }
  };
  static uint n, m, q;
  static node o[N + 1];
  static uint root;
  static fenwick_tree a;
  static const ndl* lh[7833673];
  extern File::File() {
    fap(i) {
      ipow[i][0] = pow[i][0] = 1;
      for (register uint j(1); j <= N + M; ++j) pow[i][j] = 1ull * pow[i][j - 1] * B % P[i];
      ipow[i][1] = invp(pow[i][1], P[i]);
      for (register uint j(2); j <= N + M; ++j) ipow[i][j] = 1ull * ipow[i][j - 1] * ipow[i][1] % P[i];
    }
  }
  extern File::~File() { for (register uint i(0); i < P[0]; ++i) if (lh[i]) delete lh[i]; }
  static inline const void add(const uint x) { o[o[x].f].daughter.push_back(x); }
  static const void search(const uint x) {
    // printf("%u\n", x);
    lh[o[x].h[0]] = new ndl(x, lh[o[x].h[0]]);
    for (uint i(0); i < o[x].daughter.size(); ++i) {
      fap(j) o[o[x].daughter[i]].h[j] = (o[x].h[j] + 1ull * (i + 1) * pow[j][o[x].depth]) % P[j];
      o[o[x].daughter[i]].depth = o[x].depth + 1, search(o[x].daughter[i]);
    }
  }
  static inline const uint check(const uint h[4]) {
    for (const ndl* i(lh[h[0]]); i; i = i->next) {
      bool eq(true); fap(j) eq = eq && o[i->id].h[j] == h[j];
      if (eq) return i->id;
    }
    return 0;
  }
  static inline const void main() {
    scanf("%u%u%u", &n, &m, &q);
    for (register uint i(1); i <= n; ++i) {
      if (o[i].input()) root = i;
      add(i);
    }
    search(root);
    for (register uint i(1); i <= m; ++i) scanf("%u", &a[i]);
    a.build();
    for (register uint i(0); i < q; ++i) {
      static hu t; scanf("%hu", &t);
      switch (t) {
      case 1: { static uint x, l, r; scanf("%u%u%u", &x, &l, &r), printf("%u\n", a.query(o[x].h, o[x].depth, l, r)); break; }
      case 2: { static uint t, k; scanf("%u%u", &t, &k), a.modify(t, k); break; }
      }
    }
  }
  # undef fap
}

signed int main() { Main::main(); return 0; }
```

---

## 作者：ln001 (赞：2)

## 题意
给定一颗有根树和一个序列 $a$。对于每个询问，要么对序列 $a$ 进行单点修改，要么给定树上的一个**起点** $x$ 和左右端点 $l, r$。表示从 $l$ 开始，逐个枚举 $i$ 直到 $r$，表示从目前所在的点走向**儿子中**编号第 $a_i$ 小的点，走不动则结束，问最终所在的点是哪一个。

## 做法
先不考虑修改。

由于对 $i$ 的枚举过程可能会中断，且 $i$ 的合法性单调，因此改为对 $i$ 二分，求最大合法右端点。

现在问题转化为，以给定点为起点，按照给定的**与编号大小有关**的特定路径走，求终点，路径不存在则返回 $0$。

从根走到给定起点的**路径唯一**，所以询问的起点不必是询问的给定点，而是根。

还是对结论“从根走到某个点的路径唯一”进行研究，反过来想。对于每个点，路径是何时答案为自己，深搜即可求解。对于原问题的询问给定的路径，需要找到哪个点对应的路径与其相同，显然哈希。

所以，对于不带修版本，做法为跑一次搜索，把每个点**从根开始**的**路径哈希值**扔到关联容器即可。

现在考虑修改序列 $a$，修改操作**与上文在树上的做法独立**，不用去考虑上文做法。

新抽象出来的问题为给定一个序列，单点修改，求区间哈希值。

哈希可以合并，扔到线段树上就做完了。

---

## 作者：123456xwd (赞：2)

我们考虑一下，他的树的形态是不变的，那么我们可以考虑一下给每个点维护一个序列，表示从根按照题目要求走到这个点的序列（这个序列是唯一的），**然后通过差分就知道从一个点到另一个点的序列**。

那么，对于单个询问，我们就是要找到一个最大的 $res\in[l,r]$，使得根节点到 $x$ 的序列加上 $a_{l,res}$ 在原来的树上出现过。

那么我们就可以考虑用 hash 来维护一下根节点到每个点的序列，由于 hash 满足可加性，我们可以

用一个线段树来维护一下 $a$ 序列的 hash 值，然后在上面线段树二分即可。

具体来说，假设当前我们到了被 $l,r$ 包含的一层，他前面的 hash 值我们已经知道了。

若前面的 hash 值加上其左子树的 hash 值出现过，那么加上后向右递归。

否则向左递归即可。

需要特判一下一个点都走不了的情况。

至于修改，线段树单点修改即可。

并且需要注意的是，由于这里的 hash 值会很大，我们需要对于根节点到每个点的 hash 值搞一个 hash 表。

具体来说，我们对根到每个节点的路径搞一个双 hash，然后我们给这两个 hash 值搞一搞，然后拉链法防止冲突即可。

注意卡常！

```c++
#include<utility>
#include<algorithm>
#include<cmath>
#include<cstdio>
#include<vector>
#define p_b push_back
#define m_p make_pair
#define ls k<<1
#define rs k<<1|1
#define mid ((l+r)>>1)
#define pii pair<unsigned long long,unsigned long long>

static char buf[1000000],*p1=buf,*p2=buf,obuf[1000000],*p3=obuf;
#define getchar() p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++
template<typename dy> dy abs(dy x){return x>0?x:-x;}
template<typename dy> dy max(dy x,dy y){return x>y?x:y;}
template<typename dy> dy min(dy x,dy y){return x<y?x:y;}
template<typename dy> void swap(dy &x,dy &y){x^=y;y^=x;x^=y;}
template<typename dy>
void read(dy &x){
	x=0;int f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();
	x*=f;
}
template<typename dy>
void write(dy x){
	if(x<0){putchar('-');x=-x;}
	if(x>9) write(x/10);
	putchar(x%10+48);
}
void write(char x){putchar(x);}
void read(char t[]){
	char *s=t;
	while((*s=getchar())==' '||*s=='\n');
	while((*++s=getchar())!=' '&&*s!='\n'&&*s!=EOF);
	*s=0;
}
template<typename dy,typename... Args> void read(dy &x,Args &...args){read(x);read(args...);}
template<typename dy,typename... Args> void write(dy x,Args ...args){write(x);write(args...);}

using namespace std;

const int N=5e5+5;
const unsigned long long base=2e6-17,Mod=1999979;

const pii p=m_p(71,853);
inline pii operator + (const pii &a,const pii &b){
	return m_p(a.first+b.first,a.second+b.second);
}
inline pii operator * (const pii &a,const pii &b){
	return m_p(a.first*b.first,a.second*b.second);
}
inline bool operator == (const pii &a,const pii &b){
	return (a.first==b.first&&a.second==b.second);
}
pii pn[N];
inline void init(){
	pn[0]=m_p(1,1);
	for(int i=1;i<N;i++) pn[i]=pn[i-1]*p;
}
struct node{
	int nt,id;
	pii x;
}a[N];
int head[N<<2],at;
inline void insert(pii x,int tmp){
	int key=(x.first*base%Mod+x.second)%Mod;
	a[++at].nt=head[key],head[key]=at,a[at].x=x,a[at].id=tmp;
}
inline int find(pii x){
	int key=(int)((1ll*x.first*base%Mod+x.second)%Mod);
	for(int i=head[key];i;i=a[i].nt){
		if(a[i].x==x)return a[i].id;	
	}
	return 0;
}
int n,m,q;
int rt,w[N];
vector<int> G[N];
pii Hash[N];
void dfs(int u){
	sort(G[u].begin(),G[u].end());//按照大小排序
	int cnt=0;
	for(auto v : G[u]){
		cnt++;
		Hash[v]=Hash[u]*p+m_p(cnt,cnt);
		dfs(v);
	}
}
pii tree[N<<2];
inline void push_up(int k,int l,int r){
	tree[k]=tree[ls]*pn[r-mid]+tree[rs];
}
void build(int k,int l,int r){
	if(l==r){
		tree[k]=m_p(w[l],w[l]);
		return;
	}
	build(ls,l,mid);build(rs,mid+1,r);
	push_up(k,l,r);
}
void change(int k,int l,int r,int pos,int val){
	if(l==r){
		tree[k]=m_p(val,val);
		return;
	}
	if(pos<=mid) change(ls,l,mid,pos,val);
	else change(rs,mid+1,r,pos,val);
	push_up(k,l,r);
}
int query(int k,int l,int r,int x,int y,pii &res){
	if(l>r) return 0;
	if(l==r){
		res=res*p+tree[k];
		return find(res);
	}
	int ans=0;
	if(x<=l&&r<=y){
		ans=find(res*pn[mid-l+1]+tree[ls]);
		if(!ans) return query(ls,l,mid,x,y,res);
		res=res*pn[mid-l+1]+tree[ls];
		int tmp=query(rs,mid+1,r,x,y,res);
		return (tmp==0?ans:tmp);
	}
	if(y<=mid) return query(ls,l,mid,x,y,res);
	if(x>mid) return query(rs,mid+1,r,x,y,res);
	int tx=0,ty=0;
	if(x<=mid) tx=query(ls,l,mid,x,y,res);
	if(y>mid) ty=query(rs,mid+1,r,x,y,res);
	return (ty==0?tx:ty);
}
signed main(){
	init();
	read(n,m,q);
	for(int fa,i=1;i<=n;i++){
		read(fa);
		if(!fa) rt=i;
		else G[fa].p_b(i);
	}
	for(int i=1;i<=m;i++) read(w[i]);
	Hash[rt]=m_p(0,0);
	dfs(rt);
	for(int i=1;i<=n;i++) insert(Hash[i],i);
	build(1,1,m);
	int opt,x,l,r,t,k,ans;
	while(q--){
		read(opt);
		if(opt==1){
			read(x,l,r);
			pii res=Hash[x];
			ans=query(1,1,m,l,r,res);
			if(!ans) ans=x;
			write(ans,'\n');
		}
		else{
			read(t,k);
			change(1,1,m,t,k);
		}
	}
	return 0;	
}
```

---

## 作者：羊羊君的幻想 (赞：1)

### 前言

这个题被放在了学校训练的字符串题单里，刚开始还很疑惑，后来一看还真是....

[题目 Link](https://www.luogu.com.cn/problem/P5537)

### 如果你调不出来了看这里

哈希的 base 用 $2\times 10^6+3$；

空间不要开小，必要的话开成 $10^6$；

这题不卡自然溢出，但是卡单模数的哈希；

时限相对很宽松，T 了一定是哪里写挂了；

### 题解

刚打开这个题，肯定会有种打个毒瘤 DS 的冲动或是进行一些毒瘤均摊分析的操作，~~请把这些东西抛在脑后~~。

显然，每次模拟题意中的跳儿子过程是肯定做不了的，我们需要对这棵树提前处理出什么东西，然后在 $a_i$ 序列上进行一些匹配操作**找到**目标的节点，而不是跳到。

设 $rnk_u$ 代表节点 $u$ 在它父亲的**所有**儿子中的排名，这显然是可求的，特别的，设根节点 $rnk=0$。

有一个性质，我们从根节点出发，到达每一个节点，路径一定是一条链，对于每个点，把从根到它路径上的 $rnk_u$ 按访问顺序拍在序列上，容易发现，对于不同的节点 $u$，形成的序列都是唯一的。

直观地看，如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/ccpdj3y5.png)

红色的数字是标出来的 $rnk_u$，根节点 $1$ 到节点 $3$ 形成的序列为 $\color{red}{11}$，而到节点 $4$ 形成的序列为 $\color{red}{12}$，每个节点都有一个唯一的序列。

重要的是，通过一个序列，我们可以找出对应的点！

所以我们先把每个 $u$ 的序列哈希一下，设为 $num_u$。

怎么处理询问呢？设以 $x$ 为起点，按 $a_l \sim a_r$ 的遍历顺序访问到 $v$，不难发现，根节点走到 $v$ 形成的序列一定是 $num_x$ 拼上 $a_l,a_{l+1},...,a_{r-1},a_r$。

这很好理解，$root \to v$ 等价于 $root \to u$ 再 $u \to v$。

这启发我们，对于询问一，我们二分出 $a_l \sim a_r$ 中的终止位置 $\rm{a_{mid}}$（单调性显然不做解释），查看是否能从 $a_l \to \rm{a_{mid}}$ **完整**跳到底即可。

设最终停留在节点 $v$，深度确定，为 $dep_x+mid-l+1$。

所以我们计算出从根到该点形成序列的哈希值，看看深度为 $dep_x+mid-l+1$ 的所有点中，有没有对应的哈希值即可。具体计算将二者拼起来即可。

由于 $a_i$ 带修，所以需要数据结构维护哈希值，这显然是好维护的。

于是我们就做完了这道题，时间复杂度 $\mathcal{O}(n\log^2 n)$。

后话：可以用线段树二分 + pb_ds 里的 map 做到严格 $n\log n$，不过写起来好像有点恶心。

---

## 作者：him的自我修养 (赞：1)

## 题意
~~简洁明了，不解释了。~~

## 解法：
这题看着没有任何思路，~~除了暴力~~。打开我们的题目标签，映入眼帘了一个标签：哈希！

~~想不到，根本想不到~~。

再看一眼题面，发现并没有修改数的操作，所以对于每一个节点，从树根到节点的路径是固定的，所以可以猜测是对于从树根到节点的路径做哈希。

由于哈希具有可加可减性，所以我们可以拼出一段的哈希值，自然想到用线段树维护。

那么怎么判断呢？首先考虑查询从根节点出发，树并不会改变，直接预处理出所有哈希值，然后二分答案。在 $x \neq 1$ 时，由于哈希具有可加减性，所以就是判断 $hash_v=hash_x+hash_{l_{\dots}r}$。如果相等，就往后找，否则往前找。

预处理所有的哈希值并存表，用线段树维护。然后对于每次查询，在线段树上二分长度，并判段能否走到。复杂度是 $O(n \log^2n)$ 的。

## code
```
#include <bits/stdc++.h>
using namespace std;
int n,m,Q,rt;
const int N=1e6+5;
vector<int> g[N];
pair<int,int> po[N],h[N];
const pair<int,int> seed=make_pair(71,853);
const pair<long long,long long> mod=make_pair(1e9+7,1e9+9);
int read(){
	int s=0;char ch=getchar();
	while(!isdigit(ch)) ch=getchar();
	while(isdigit(ch)) s=(s<<3)+(s<<1)+ch-'0',ch=getchar();
	return s;
}
pair<int,int> operator +(const pair<int,int> &x,const pair<int,int> &y){
	return make_pair((x.first+y.first)%mod.first,(x.second+y.second)%mod.second);
}
pair<int,int> operator *(const pair<int,int> &x,const pair<int,int> &y){
	return make_pair((int)(((long long)x.first*(long long)y.first)%mod.first),(int)(((long long)x.second*(long long)y.second)%mod.second));
}
bool operator ==(const pair<int,int> &x,const pair<int,int> &y){
    return (x.first==y.first && x.second==y.second);
}
void init(){
	po[0]=make_pair(1,1);
	for(int i=1;i<=n;i++) po[i]=po[i-1]*seed;
}
void dfs(int u){
	sort(g[u].begin(),g[u].end());
	int cnt=0;
	for(int sz=g[u].size(),i=0;i<sz;i++){
		int v=g[u][i];
		++cnt;
		h[v]=h[u]*seed+make_pair(cnt,cnt);
		dfs(v);
	}
}
struct edge{
	pair<int,int> to;
	int w,nxt;
} e[N];
const int se=24601,p=1e6-17;
int head[N],cnt;
struct hashtable{
	void add(const int a,const pair<int,int> b,const int c){
		cnt++;
		e[cnt].to=b;
		e[cnt].w=c;
		e[cnt].nxt=head[a];
		head[a]=cnt;
	}
	void insert(const pair<int,int> a,const int b){
		int tmp=(a.first*se+a.second)%p;
		add(tmp,a,b);
	}
	int query(pair<int,int> a){
		int tmp=(a.first*se+a.second)%p;
		for(int i=head[tmp];i;i=e[i].nxt){
			if(e[i].to==a) return e[i].w;
		}
		return -1;
	}
} ha;
struct tree{
	int l,r;
	pair<int,int> val;
} t[N<<2];
void pushup(int root,int len){
	t[root].val=t[root<<1].val*po[len]+t[root<<1|1].val;
}
void build(int root,int l,int r){
	t[root].l=l,t[root].r=r;
	if(l==r){
		int xx=read();
		t[root].val=make_pair(xx,xx);
		return ;
	}
	int mid=(l+r)>>1;
	build(root<<1,l,mid),build(root<<1|1,mid+1,r);
	pushup(root,t[root].r-mid);
}
void upd(int root,int pos,int x){
	if(t[root].l==t[root].r){
		t[root].val=make_pair(x,x);
		return ;
	}
	int mid=(t[root].l+t[root].r)>>1;
	if(pos<=mid) upd(root<<1,pos,x);
	else upd(root<<1|1,pos,x);
	pushup(root,t[root].r-mid);
}
pair<int,int> query(int root,int l,int r){
	if(l<=t[root].l && t[root].r<=r) return t[root].val;
	int mid=(t[root].l+t[root].r)>>1;
	if(r<=mid) return query(root<<1,l,r);
	else if(l>mid) return query(root<<1|1,l,r);
	else return query(root<<1,l,r)*po[min(r,t[root].r)-mid]+query(root<<1|1,l,r);
}
int query1(int root,int l,int r,pair<int,int> x){
	if(t[root].l==t[root].r) return ha.query(x*seed+t[root].val);
	int mid=(t[root].l+t[root].r)>>1;
	if(r<=mid) return query1(root<<1,l,r,x);
	else if(l>mid) return query1(root<<1|1,l,r,x);
	else{
		pair<int,int> hh=x*po[mid-max(t[root].l,l)+1]+(l<=t[root].l?t[root<<1].val:query(root,l,mid));
		int w=ha.query(hh);
		if(w==-1) return query1(root<<1,l,r,x);
		else{
			int tmp=query1(root<<1|1,l,r,hh);
			return tmp==-1?w:tmp;
		}
	}
}
signed main(){
	n=read(),m=read(),Q=read();
	init();
	for(int i=1;i<=n;i++){
		int x=read();
		if(!x) rt=i;
		else g[x].push_back(i);
	}
	h[rt]=make_pair(0,0);
	dfs(rt);
	for(int i=1;i<=n;i++) ha.insert(h[i],i);
	build(1,1,m);
	while(Q--){
		int op=read(),x,l,r,ans;
		if(op==1){
			x=read(),l=read(),r=read();
			ans=query1(1,l,r,h[x]);
			printf("%d\n",ans==-1?x:ans);
		}else{
			l=read(),x=read();
			upd(1,l,x);
		}
	}
	return 0;
}
```
ps：这题有个坑点，就是由于要用哈希，所以会有如下代码：
```
pair<int,int> operator *(const pair<int,int> &x,const pair<int,int> &y){
	return make_pair((int)(((long long)x.first*(long long)y.first)%mod.first),(int)(((long long)x.second*(long long)y.second)%mod.second));
}
```
很显然 $10^5 \times 10^5$ 会爆 ```int```，所以就到 ```#define int long long```但是内存会炸，所以全局 ```int```，在计算 ```pair*pair``` 时特殊开 ```long long```，最后转回```int```让结果自然溢出就可以啦。

---


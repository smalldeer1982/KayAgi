# 失昼城的守星使

## 题目背景

> 月伏潮汐生，星染万屿寂，无晦明之变化者，是为失昼。   ————《失昼城手札·起源》

失昼城四面环海，建城于7325年前。

失昼城没有黑夜白天的变化，一轮明月自建城伊始就挂在天空，故名失昼。


失昼城城主月凌霜，掌控着失昼城的守星塔，守星塔在终日无昼的失昼城中作为照明的灯塔，一直是城里人们的精神寄托，她的另一个身份是失昼城的守星使，比起作为城主，月凌霜更喜欢守着守星塔。

失昼城的特殊环境导致其空间异常不稳定，根据失昼城城史记载，七千多年历史的失昼城，其和平的时间总共不超过三百年，其他大部分时间失昼城局部地区都在空间风暴的笼罩之下，依托于特殊空间存在的守星塔，同时兼具着向人们传递信息的功能，在不稳定的空间影响下，这是唯一能够维持信号稳定的方法。



## 题目描述

失昼城共由$N$座岛屿组成，由$N-1$条传递信息的空间通道联通。

作为失昼城的守星使，月凌霜具有部署守星塔的能力，具体而言，为了依靠特殊空间波动向每个有居民居住的岛屿传递消息，月凌霜可以任意数量地部署守星塔，每座岛屿只能部署一座守星塔，**但是同一时刻所有部署的守星塔必须依靠空间通道连成一条链**。

失昼城常年受到空间风暴的困扰，常常会出现某座岛屿遭受空间风暴，岛上全体居民被迫离开岛屿，此时，**守星塔不再需要向该地传输消息**，等到空间风暴散去，居民重新回到这里，**守星塔才需要恢复向该地的信息传输**。

由于空间波动的干扰，守星塔传递消息必须依靠联通岛屿的空间通道完成，具体而言，如果一座守星塔要向一座岛屿传递消息，**其消耗的能量为该座守星塔所处的岛屿到需要接收消息的岛屿的所有空间通道能耗总和**，当然，如果一座守星塔向自身所处的岛屿发送消息，则不需要消耗能量，守星塔对岛屿传递消息的信号波动互相独立，也就是说，**每座守星塔对于每座岛屿的能量传输互不干扰**。

作为城主兼守星使，月凌霜近期正在研究怎样部署守星塔才能使消息传递所消耗的能量最小，现在月凌霜已经找到了记载失昼城七千多年来空间风暴的爆发情况和当时失昼城的守星塔部署的资料，由于历史过于久远，每次能量的消耗情况已经不得而知，现在月凌霜希望你帮助她还原这些史料，具体详见输入格式。

## 说明/提示

![](https://cdn.luogu.com.cn/upload/pic/74843.png)

特殊性质$1$：$v_{i}=u_{i}+1$

特殊性质$2$：月凌霜所有的询问的$x$和$y$相同。

特殊性质$3$：月凌霜所有的询问的$x=1$。

对于所有的$w_{i}$，保证$0$<=$w_{i}$<=$10^{5}$

对于$100\%$的数据，保证$n,m\leq 200000,0\leq Type\leq 7$.

样例1解释：

![](https://cdn.luogu.com.cn/upload/pic/74831.png)

初始图像如左图。

对于第一个询问如中图，有$2,3,5$有居民，所以$ans_2=ans_3=0,ans_5=7.$所以$ans=7$.

对于第二组询问如右图，$ans_2=2+3=5,ans_3=0,ans_5=7,$,因此$ans=7+5=12$.

样例2解释：

![](https://cdn.luogu.com.cn/upload/pic/74836.png)

初始图如左上。

询问$1$点如图右上，存在$1,2,3,6$有居民。
$ans_1=0,ans_2=3,ans_3=5,ans_6=8+2=10.$因此$ans=3+5+10=18$

1操作后所有有居民点如左下。

接下来的操作图为右下，同上有$ans_1=0,ans_2=3,ans_3=0,ans_5=9,ans_6=0$,所以$ans=3+9=12$.

## 样例 #1

### 输入

```
5 2 0
1 2 2
1 3 3
4 3 2
5 3 7
0 1 1 0 1
2 2 4
2 4 3```

### 输出

```
7
12```

## 样例 #2

### 输入

```
6 3 0
2 1 3
3 1 5
4 1 2
6 4 8
4 5 9
1 1 1 0 0 1
2 1 1
1 5
2 3 6```

### 输出

```
18
12```

# 题解

## 作者：Graphcity (赞：7)

题意：给定一棵树，边带权，每个点有黑白两种颜色，你需要支持翻转某个点的颜色，或者查询所有黑点到某一条链的距离之和。


---

分两种情况讨论：在 LCA 的子树内，在 LCA 的子树外。

为了方便，我们规定：

- $d_i$ 为结点 $i$ 到根结点的距离（也就是深度）
- $s_i$ 为结点 $i$ 所在子树的黑点个数
- $sd_i$ 为结点 $i$ 所在子树中黑点的深度之和
- $sum$ 为整棵树中的黑点个数

先看第一种情况：（ 给定的链为 $a\to d\to f$ ）

![](https://cdn.luogu.com.cn/upload/image_hosting/d3fuc2dg.png)

我们分别计算每个链上结点作为 LCA 时对答案的贡献：

| $+$ | $-$ |
| :--: | :--: |
| $sd_a-d_as_a$ |  |
| $sd_b-d_bs_b$ | $sd_a-d_bs_a$ |
| $sd_c-d_cs_c$ | $sd_b-d_cs_b$ |
| $sd_d-d_ds_d$ | $sd_c-d_ds_c,\ sd_e-d_ds_e$ |
| $sd_e-d_es_e$ | $sd_f-d_es_f$ |
| $sd_f-d_fs_f$ |  |

其中加号表示正贡献，减号表示负贡献。整理可得答案为

$$
(d_b-d_a)s_a+(d_c-d_b)s_b+(d_d-d_c)s_c+(d_d-d_e)s_e+(d_e-d_f)s_f+sd_d-d_ds_d
$$

再看第二种情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/ot13cbnr.png)

还是一样的，列表计算贡献：（ 根据 $dis(x,y)=dep_x+dep_y-2dep_{lca(x,y)}$ ）

| $+$ | $-$ |
| :--: | :--: |
| $sd_x-2d_xs_x$ | $sd_d-2d_xs_d$ |
| $sd_y-2d_ys_y$ | $sd_x-2d_ys_x$ |
| $sd_z-2d_zs_z$ | $sd_y-2d_zs_y$ |
| $d_d(sum-s_d)$ |  |

整理可得：

$$
sd_z-sd_d+d_d(sum-s_d)-2(d_xs_x+d_ys_y+d_zs_z)+2(d_xs_d+d_ys_x+d_zs_y)
$$

---

可以发现，答案当中有着非常多形如 $s_i,\ sd_i,\ d_is_i,\ d_{fa_i}s_i$ 的式子。我们便可以开四棵线段树，来分别维护这四个式子的和。

每次改变结点颜色的时候，只需要修改从它到根结点的链上这四个式子的值。修改和查询都可以用树链剖分解决。

注意 $d_is_i$ 与 $d_{fa_i}s_i$ 的修改与普通线段树稍有不同。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define For(i,a,b) for(int i=(a);i<=(b);++i)
#define Rof(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
typedef pair<int,int> Pair;
const int Maxn=2e5;

inline int read()
{
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0' || ch>'9')
    {
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0' && ch<='9')
    {
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}

int n,m,kazuha,all,typ[Maxn+5]; ll dep[Maxn+5],sd[Maxn+5];
int siz[Maxn+5],fa[Maxn+5],son[Maxn+5];
int dfn[Maxn+5],pre[Maxn+5],top[Maxn+5],cur;
vector<Pair> v[Maxn+5];
#define ls(x) (x<<1)
#define rs(x) (x<<1|1)

inline void dfs1(int x,int f)
{
    fa[x]=f,siz[x]=1,sd[x]=dep[x];
    for(auto i:v[x])
    {
        int y=i.first,z=i.second;
        if(y==f) continue;
        dep[y]=dep[x]+z;
        dfs1(y,x),siz[x]+=siz[y],sd[x]+=sd[y];
        son[x]=(siz[y]>siz[son[x]]?y:son[x]);
    }
}
inline void dfs2(int x,int t)
{
    top[x]=t,dfn[x]=++cur,pre[cur]=x;
    if(son[x]) dfs2(son[x],t);
    for(auto i:v[x])
    {
        int y=i.first;
        if(y==fa[x] || y==son[x]) continue;
        dfs2(y,y);
    }
}

struct SegTree
{
    ll t[Maxn*4+5],tag[Maxn*4+5],val[Maxn+5],sum[Maxn+5]; int opt;
    inline void push_up(int p) {t[p]=t[ls(p)]+t[rs(p)];}
    inline void f(int p,ll k,int len) {t[p]+=len*k,tag[p]+=k;}
    inline void f2(int p,ll k,int l,int r) {t[p]+=(sum[r]-sum[l-1])*k,tag[p]+=k;}
    inline void push_down(int l,int r,int p)
    {
        int mid=(l+r)>>1;
        f(ls(p),tag[p],mid-l+1),f(rs(p),tag[p],r-mid),tag[p]=0;
    }
    inline void push_down2(int l,int r,int p)
    {
        int mid=(l+r)>>1;
        f2(ls(p),tag[p],l,mid),f2(rs(p),tag[p],mid+1,r),tag[p]=0;
    }
    inline void Build(int l,int r,int p)
    {
        if(l==r) {t[p]=val[pre[l]]; return;}
        int mid=(l+r)>>1;
        Build(l,mid,ls(p)),Build(mid+1,r,rs(p)),push_up(p);
    }
    inline void Update(int nl,int nr,int l,int r,int p,ll k)
    {
        if(l<=nl && nr<=r) {t[p]+=(nr-nl+1)*k,tag[p]+=k; return;}
        int mid=(nl+nr)>>1; push_down(nl,nr,p);
        if(l<=mid) Update(nl,mid,l,r,ls(p),k);
        if(r>mid) Update(mid+1,nr,l,r,rs(p),k);
        push_up(p);
    }
    inline void Update2(int nl,int nr,int l,int r,int p,ll k)
    {
        if(l<=nl && nr<=r) {t[p]+=(sum[nr]-sum[nl-1])*k,tag[p]+=k; return;}
        int mid=(nl+nr)>>1; push_down2(nl,nr,p);
        if(l<=mid) Update2(nl,mid,l,r,ls(p),k);
        if(r>mid) Update2(mid+1,nr,l,r,rs(p),k);
        push_up(p);
    }
    inline ll Count(int nl,int nr,int l,int r,int p)
    {
        if(l<=nl && nr<=r) return t[p];
        int mid=(nl+nr)>>1; ll res=0;
        if(!opt) push_down(nl,nr,p);
        else push_down2(nl,nr,p);
        if(l<=mid) res+=Count(nl,mid,l,r,ls(p));
        if(r>mid) res+=Count(mid+1,nr,l,r,rs(p));
        push_up(p); return res;
    }
    inline void Modify(int x,int y,ll z)
    {
        while(top[x]!=top[y])
        {
            if(dep[top[x]]<dep[top[y]]) swap(x,y);
            Update(1,n,dfn[top[x]],dfn[x],1,z),x=fa[top[x]];
        }
        if(dep[x]>dep[y]) swap(x,y);
        Update(1,n,dfn[x],dfn[y],1,z);
    }
    inline void Modify2(int x,int y,ll z)
    {
        while(top[x]!=top[y])
        {
            if(dep[top[x]]<dep[top[y]]) swap(x,y);
            Update2(1,n,dfn[top[x]],dfn[x],1,z),x=fa[top[x]];
        }
        if(dep[x]>dep[y]) swap(x,y);
        Update2(1,n,dfn[x],dfn[y],1,z);
    }
    inline ll Find(int x,int y)
    {
        ll res=0;
        while(top[x]!=top[y])
        {
            if(dep[top[x]]<dep[top[y]]) swap(x,y);
            res+=Count(1,n,dfn[top[x]],dfn[x],1),x=fa[top[x]];
        }
        if(dep[x]>dep[y]) swap(x,y);
        res+=Count(1,n,dfn[x],dfn[y],1);
        return res;
    }
} T[4];

inline int LCA(int x,int y)
{
    while(top[x]!=top[y])
    {
        if(dep[top[x]]<dep[top[y]]) swap(x,y);
        x=fa[top[x]];
    }
    return (dep[x]<dep[y]?x:y);
}
inline void Change(int x)
{
    if(!typ[x])
    {
        T[0].Modify(x,1,1);
        T[1].Modify(x,1,dep[x]);
        T[2].Modify2(x,1,1);
        T[3].Modify2(x,1,1);
        typ[x]=1,all++;
    }
    else
    {
        T[0].Modify(x,1,-1);
        T[1].Modify(x,1,-dep[x]);
        T[2].Modify2(x,1,-1);
        T[3].Modify2(x,1,-1);
        typ[x]=0,all--;
    }
}
inline ll Query(int x,int y)
{
    int d=LCA(x,y);
    ll sdd=T[1].Count(1,n,dfn[d],dfn[d],1),szd=T[0].Count(1,n,dfn[d],dfn[d],1);
    ll s1=sdd-dep[d]*szd+T[3].Find(x,y)-T[2].Find(x,y)-szd*(dep[fa[d]]-dep[d]),s2=0;
    if(fa[d])
    {
        ll sd1=T[1].Count(1,n,1,1,1);
        s2=dep[d]*(all-szd)+sd1-sdd;
        s2=s2+2ll*T[3].Find(1,d)-2ll*T[2].Find(1,fa[d]);
    }
    return s1+s2;
}

int main()
{
    n=read(),m=read(),kazuha=read(),all=n;
    T[0].opt=0,T[1].opt=0,T[2].opt=1,T[3].opt=1;
    For(i,1,n-1)
    {
        int a=read(),b=read(),c=read();
        v[a].push_back(make_pair(b,c)),v[b].push_back(make_pair(a,c));
    }
    For(i,1,n) typ[i]=read();
    dfs1(1,0),dfs2(1,1);
    For(i,1,n) T[2].sum[i]=T[2].sum[i-1]+dep[pre[i]];
    For(i,1,n) T[3].sum[i]=T[3].sum[i-1]+dep[fa[pre[i]]];
    For(i,0,3)
    {
        if(i==0) For(j,1,n) T[i].val[j]=siz[j];
        if(i==1) For(j,1,n) T[i].val[j]=sd[j];
        if(i==2) For(j,1,n) T[i].val[j]=1ll*siz[j]*dep[j];
        if(i==3) For(j,1,n) T[i].val[j]=1ll*siz[j]*dep[fa[j]];
        T[i].Build(1,n,1);
    }
    For(i,1,n) if(!typ[i]) typ[i]=1,Change(i);
    while(m--)
    {
        int opt=read(),x=read(),y;
        if(opt==1) Change(x);
        else y=read(),printf("%lld\n",Query(x,y));
    }
    return 0;
}
```

---

## 作者：EndSaH (赞：5)

# Solution

（应该）与标算不太一样，主要是实现上除了板子几乎没有细节。

首先随意定根。

一个点 $u$ 到链的距离等价于 $u$ 到这条链上 LCA 的距离减去 $u$ 到 LCA 的重合路径部分。这里的重合指的是 $u$ 到 LCA 的路径与这条链的重合部分。

考虑这个重合路径部分怎么算。类似 [[LNOI2014]LCA](https://www.luogu.org/problem/P4211) 的做法，重合部分显然等价于 $u$ 到根的路径与这条链的重合部分。将每个黑点到根的边全部打上一个 +1 的标记，每次直接查询这条链上的路径和即可。

（注意这里的 +1 是累加一次边权，不是权值 +1）

然后再考虑 $u$ 到这条链上 LCA 的距离。现在设 LCA 为 $v$，拆一下可以得到 $dis(u, v) = dis _u + dis _v - 2 dis _{lca(u, v)}$（注意这里的 $dis(u, v)$ 是两点距离，$dis _u$ 是 $u$ 到根的距离）

用上面的修改方法一样能做，查询 $v$ 到根的路径上的路径和，即可得到 $\sum dis _{lca(u, v)}$。而 $\sum dis _u + dis _v$ 很容易维护（直接记当前有多少个黑点和黑点的 $dis$ 和），于是解决问题。

用 LCT 处理可以做到 $O(n \log n)$，不过懒得写了，$O(n \log ^2 n)$ 树剖就行。

虽然是一个比较奇怪的区间加（整体累加一次边权），不过大同小异，跟普通线段树没有什么区别。

# Code

## gen

```python
from random import randint
from cyaron import *
import os
cnt = 0
while True :
    n, m = int(2e5), int(2e5)
    outs = "%d %d %d\n" % (n, m, 0)
    tree = Graph.tree(n, weight_limit = 1e5)
    for i in tree.iterate_edges() :
        outs += "%d %d %d\n" % (i.start, i.end, i.weight)
    for i in range(n) :
        outs += "%d " % (randint(0, 1))
    outs += '\n'
    for i in range(m) :
        if randint(0, 1) is 0 :
            outs += "1 %d\n" % randint(1, n)
        else :
            outs += "2 %d %d\n" % (randint(1, n), randint(1, n))
    print(outs, file = open("tmp.in", "w"))
    os.system("./std && ./tmp")
    if os.system("diff tmp.out tmp.ans") :
        print("WA")
        exit()
    else :
        cnt += 1
        print("AC %d times!" % cnt)
```

## std

```cpp
/**********************************************************
 * Author        : EndSaH
 * Email         : hjxhb1@gmail.com
 * Created Time  : 2019-09-17 10:26
 * FileName      : tmp.cpp
 * Website       : https://endsah.cf
 * *******************************************************/

#include <cstdio>
#include <cctype>
#include <bitset>
#include <vector>

using pii = std::pair<int, int>;
using LL = long long;

#define fir first
#define sec second
#define debug(...) fprintf(stderr, __VA_ARGS__)
#define Debug(s) debug("The message in line %d, Function %s: %s\n", __LINE__, __FUNCTION__, s)
#define getchar() (ipos == iend and (iend = (ipos = _ibuf) + fread(_ibuf, 1, __bufsize, stdin), ipos == iend) ? EOF : *ipos++)
#define putchar(ch) (opos == oend ? fwrite(_obuf, 1, __bufsize, stdout), opos = _obuf : 0, *opos++ = (ch))
#define __bufsize (1 << 21 | 1)

char _ibuf[__bufsize], _obuf[__bufsize], _stk[50];
char *ipos = _ibuf, *iend = _ibuf, *opos = _obuf, *oend = _obuf + __bufsize, *stkpos = _stk;

struct END
{ ~END() { fwrite(_obuf, 1, opos - _obuf, stdout); } }
__;

inline int read()
{
    register int x = 0;
    register char ch;
    while (!isdigit(ch = getchar()));
    while (x = x * 10 + (ch & 15), isdigit(ch = getchar()));
    return x;
}

template <typename _INT>
inline void write(_INT x)
{
    while (*++stkpos = x % 10 ^ 48, x /= 10, x);
    while (stkpos != _stk)
        putchar(*stkpos--);
}

template <typename _Tp>
inline bool Chkmax(_Tp& x, const _Tp& y)
{ return x < y ? x = y, true : false; }

template <typename _Tp>
inline bool Chkmin(_Tp& x, const _Tp& y)
{ return x > y ? x = y, true : false; }

const int maxN = 2e5 + 5;

int n, m, cnt;
LL sum;
std::bitset<maxN> vis;
std::vector<pii> G[maxN];

// HLD and SEG
namespace HLD
{
    int dfst, ql, qr, addval;
    int size[maxN], top[maxN], son[maxN], dfn[maxN], fa[maxN], dep[maxN];
    LL dis[maxN];
    int val[maxN], ref[maxN];
    int tag[maxN << 2];
    LL sum[maxN << 2], real[maxN << 2];

    void DFS1(int u)
    {
        size[u] = 1;
        for (const auto& i : G[u])
        {
            if (size[i.fir])
                continue;
            fa[i.fir] = u, dep[i.fir] = dep[u] + 1;
            val[i.fir] = i.sec, dis[i.fir] = dis[u] + i.sec;
            DFS1(i.fir);
            size[u] += size[i.fir];
            if (size[i.fir] > size[son[u]])
                son[u] = i.fir;
        }
    }

    void DFS2(int u)
    {
        dfn[u] = ++dfst;
        ref[dfst] = u;
        if (son[u])
            top[son[u]] = top[u], DFS2(son[u]);
        for (const auto& i : G[u])
            if (!top[i.fir])
                top[i.fir] = i.fir, DFS2(i.fir);
    }

    int LCA(int u, int v)
    {
        while (top[u] != top[v])
        {
            if (dep[top[u]] < dep[top[v]])
                std::swap(u, v);
            u = fa[top[u]];
        }
        return dep[u] > dep[v] ? v : u;
    }

    inline void Add(int addval, int x)
    {
        real[x] += sum[x] * addval;
        tag[x] += addval;
    }

    inline void Pushdown(int x)
    {
        if (tag[x])
        {
            Add(tag[x], x << 1), Add(tag[x], x << 1 | 1);
            tag[x] = 0;
        }
    }

    inline void Pushup(int x)
    { real[x] = real[x << 1] + real[x << 1 | 1]; }

    void Build(int l = 1, int r = n, int cur = 1)
    {
        if (l == r)
        {
            sum[cur] = val[ref[l]];
            return;
        }
        int mid = (l + r) >> 1;
        Build(l, mid, cur << 1), Build(mid + 1, r, cur << 1 | 1);
        sum[cur] = sum[cur << 1] + sum[cur << 1 | 1];
    }

    void Modify(int l = 1, int r = n, int cur = 1)
    {
        if (ql <= l and r <= qr)
        {
            Add(addval, cur);
            return;
        }
        int mid = (l + r) >> 1;
        Pushdown(cur);
        if (ql <= mid)
            Modify(l, mid, cur << 1);
        if (mid < qr)
            Modify(mid + 1, r, cur << 1 | 1);
        Pushup(cur);
    }

    LL Query(int l = 1, int r = n, int cur = 1)
    {
        if (ql <= l and r <= qr)
            return real[cur];
        if (ql > r or qr < l)
            return 0;
        int mid = (l + r) >> 1;
        Pushdown(cur);
        return Query(l, mid, cur << 1) + Query(mid + 1, r, cur << 1 | 1);
    }

    void Init()
    {
        dep[1] = 1, DFS1(1);
        top[1] = 1, DFS2(1);
        Build();
    }

    void Add(int l, int r, int val)
    { ql = l, qr = r, addval = val, Modify(); }

    LL Ask(int l, int r)
    { ql = l, qr = r; return Query(); }

    void Add_root(int u, int addval)
    {
        while (top[u] != 1)
            Add(dfn[top[u]], dfn[u], addval), u = fa[top[u]];
        Add(2, dfn[u], addval);
    }

    LL Query_chain(int u, int v)
    {
        LL res = 0;
        while (top[u] != top[v])
        {
            if (dep[top[u]] < dep[top[v]])
                std::swap(u, v);
            res += Ask(dfn[top[u]], dfn[u]), u = fa[top[u]];
        }
        if (dep[u] > dep[v])
            std::swap(u, v);
        return res + Ask(dfn[u] + 1, dfn[v]);
    }
}

void Oper(int x)
{
    if (vis[x])
        sum -= HLD::dis[x], --cnt, vis.reset(x), HLD::Add_root(x, -1);
    else
        sum += HLD::dis[x], ++cnt, vis.set(x), HLD::Add_root(x, 1);
}

int main()
{
#ifndef ONLINE_JUDGE
    freopen("tmp.in", "r", stdin);
    freopen("tmp.out", "w", stdout);
#endif
    n = read(), m = read(), read();
    for (int i = 2; i <= n; ++i)
    {
        int u = read(), v = read(), w = read();
        G[u].emplace_back(v, w), G[v].emplace_back(u, w);
    }
    HLD::Init();
    // for (int i = 1; i <= n; ++i)
    //     printf("%d %d %d\n", HLD::size[i], HLD::top[i], HLD::dfn[i]);
    for (int i = 1; i <= n; ++i)
        if (read())
            Oper(i);
    for (int i = 1; i <= m; ++i)
    {
        int opt = read(), x = read();
        // debug("%d %d %d\n", i, opt, x);
        if (opt == 1)
            Oper(x);
        else
        {
            int y = read(), lca = HLD::LCA(x, y);
            LL tmp = sum + cnt * HLD::dis[lca] - (HLD::Query_chain(1, lca) << 1);
            LL minus = HLD::Query_chain(x, y);
            write(tmp - minus), putchar('\n');
        }
    }
    return 0;
}
```

---

## 作者：Hoks (赞：2)

## 前言
重剖题单 part $2$ 里的好题，感觉对于推式子能力挺有帮助的。

刚好在[博客](https://www.luogu.com.cn/blog/Hok/cute-tree-decomposition)里把他当做了练习题，就来补篇题解吧。

感谢**御用纯情娇羞可爱内向小男娘** Loser_Syx 帮我找锅喵（所以他的 pass 代码是我的喵）。
## 思路分析
首先看题面，发现重点的那几句求答案的话可以转化为一句：给定一棵有黑白两种颜色点的树，求树上**所有黑点**到**指定的路径**的**最短距离之和**。

这边直接考虑大力，先把答案用式子表示出来：
$$\sum_{i\in S}dis(i,\operatorname{LCA}(x,y))-dis(\operatorname{LCA}(x,y),u)$$

这里的 S 表示黑点的集合，而 $u$ 表示 $i$ 与 $x\rightarrow y$ 这条路径的第一个交点。

式子有了，接着开始大力推。

1. 首先对于第一部分，这里我们就非常熟悉了，直接大力拆开即可，得到：
$$\sum_{i\in S}dep_i+dep_{\operatorname{LCA}(x,y)}-2\times dep_{\operatorname{LCA}(\operatorname{LCA}(x,y),i)}$$

这里又有三块了，第一块可以直接在标记黑白的时候处理出来，第二块直接大力算乘上倍数，第三块直接考虑大力树上询问就能 $\log$ 搞定。

2. 接着来考虑重复的路径该怎么计算。

考虑树剖推式子的源头 [P4211 [LNOI2014] LCA](https://www.luogu.com.cn/problem/P4211)。

类似的，我们也考虑用 $+1$ （这里的指的是加上边权，为了方便理解写作 $+1$）这样的方法来计算重复的路径。

具体操作即为：给这个黑点到根的路径全部 $+1$，到时候直接查询即可。

到这一步这道题的思路就可行了，接下来就是实现的问题了。
## 代码
```cpp
#include<bits/stdc++.h>
#define ls (p<<1)
#define rs (p<<1|1)
#define mid ((l+r)>>1)
#define int long long
using namespace std;
const int N=200010;
struct node
{int v,nxt,w;}e[N<<1];
int n,m,tot,cnt,sum;
int head[N],a[N],dfn[N],id[N],top[N];
int fa[N],son[N],si[N],dis[N],dep[N];
int s[N<<2],t[N<<2],lz[N<<2];
static char buf[1000000],*paa=buf,*pd=buf;
//#define getchar() paa==pd&&(pd=(paa=buf)+fread(buf,1,1000000,stdin),paa==pd)?EOF:*paa++
inline int read(void){
    int u(0),t(1);char fc(getchar());
    while(!isdigit(fc)){if(fc=='-') t=-1;fc=getchar();}
    while(isdigit(fc)) u=(u<<1)+(u<<3)+(fc^48),fc=getchar();
    return u*t;
}
inline void print(int u)
{
	if(u<0) putchar('-'),u=-u;
	if(u>9) print(u/10);
	putchar(u%10+'0');
}
void add(int u,int v,int w){e[++tot].v=v,e[tot].nxt=head[u],e[tot].w=w,head[u]=tot;}
void dfs1(int u,int ff)
{
	si[u]=1,fa[u]=ff;dep[u]=dep[ff]+1;
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].v,w=e[i].w;
		if(v==ff) continue;
		a[v]=w,dis[v]=dis[u]+w,dfs1(v,u),si[u]+=si[v];
		if(si[v]>si[son[u]]) son[u]=v;
	}
}
void dfs2(int u,int topf)
{
	top[u]=topf,dfn[u]=++cnt,id[cnt]=u;
	if(son[u]) dfs2(son[u],topf);
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].v;
		if(v==fa[u]||v==son[u]) continue;
		dfs2(v,v);
	}
}
void build(int p,int l,int r)
{
	if(l==r) return void(s[p]=a[id[l]]);
	build(ls,l,mid),build(rs,mid+1,r),s[p]=s[ls]+s[rs];
}
void pushdown(int p){lz[ls]+=lz[p],lz[rs]+=lz[p],t[ls]+=s[ls]*lz[p],t[rs]+=s[rs]*lz[p];lz[p]=0;}
void modify(int p,int l,int r,int st,int ed,int k)
{
	if(l>=st&&r<=ed) return void(lz[p]+=k),void(t[p]+=k*s[p]);
	pushdown(p);
	if(mid>=st) modify(ls,l,mid,st,ed,k);
	if(mid<ed) modify(rs,mid+1,r,st,ed,k);
	t[p]=t[ls]+t[rs];
}
int query(int p,int l,int r,int st,int ed)
{
	if(l>=st&&r<=ed) return t[p];
	pushdown(p);int res=0;
	if(mid>=st) res=query(ls,l,mid,st,ed);
	if(mid<ed) res+=query(rs,mid+1,r,st,ed);
	return res;
}
int LCA(int x,int y)
{
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		x=fa[top[x]];
	}
	if(dep[x]>dep[y]) swap(x,y);
	return x;
}
int query(int x,int y)
{
	int res=0;
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		res+=query(1,1,n,dfn[top[x]],dfn[x]);x=fa[top[x]];
	}
	if(dep[x]>dep[y]) swap(x,y);
	return res+query(1,1,n,dfn[x]+1,dfn[y]);
}
void ad(int u,int w)
{
	while(top[u]!=1) modify(1,1,n,dfn[top[u]],dfn[u],w),u=fa[top[u]];
	modify(1,1,n,2,dfn[u],w);
}
void over(int u)
{
	if(a[u]) sum-=dis[u],cnt--,ad(u,-1);
	else sum+=dis[u],cnt++,ad(u,1);
	a[u]^=1;
}
signed main()
{
    n=read(),m=read();read();
    for(int i=1,u,v,w;i<n;i++) u=read(),v=read(),w=read(),add(u,v,w),add(v,u,w);
    dfs1(1,0),dfs2(1,1);build(1,1,n);memset(a,0,sizeof a);cnt=0;
	for(int i=1;i<=n;i++) if(read()) over(i);
	for(int i=1,op,x,y,lca;i<=m;i++)
	{
		op=read(),x=read();
		if(op==1) over(x);
		else y=read(),lca=LCA(x,y),print(sum+cnt*dis[lca]-(query(1,lca)<<1)-query(x,y)),puts("");
	}
    return 0;
}
```

---

## 作者：kkxacj (赞：1)

#### 思路

~~本来有一个很天真的记录轻儿子做法，不过严格包含接下来讲的做法用到的东西所以就不讲了。~~

先随便选一个点作为根。

假设当前询问的链是 $x,y$，LCA 是 $z$，那么显然 $z$ 子树外的点必然到 $z$，我们将链上的点染黑，对于每个链上的点 $u$，其儿子不是黑色的点的子树上的点到 $u$ 最优。

总所周知，两点间距离公式可转化为 $dep_x+dep_y-2 \times dep_z$，根据 LCA 的性质，**有且仅有 LCA 到根**会是 $x,y$ 共同的祖先。

这启示我们本质上 $dep_z$ 是两条链的交集，所以树链剖分加线段树维护就好了，具体的就是链加和链求和，假设每次询问就一个点，那么答案就是 $dep_x\times sum+S-2 \times Q_x$，其中 $sum$ 是总个数，$S$ 是总深度和，$Q_x$ 是询问 $x$ 到 $1$ 的链的和。

考虑一般情况，相信聪明人已经发现，如果有一对 $i$ 到 $j$，$j$ 是 $i$ 祖先，那么显然贡献是 $dep_i-dep_j$。

所以一个点 $i$ 到链 $x,y$ 其实就是 $i$ 到 $z$ 的距离减去与链 $x,y$ 的交集，不妨同时加上 $dep_z$，这样本质上就是链查询了。

所以到此已经结束，只是注意这里的区间加只是表示整个区间覆盖次数加，还需要乘上该段的实际大小。

答案就是 $dep_z\times sum+S-Q_x-Q_y$。

#### 闲话

上诉树链剖分加线段树实现复杂度其实是 $\operatorname{O}\left((n+m)\log^2n\right)$ 的，有个什么上古科技全局平衡二叉树可以做到一只 $\log$，但是作者太菜了不会，可以看看[这篇](https://www.luogu.com.cn/article/ef36ensd)，或者从远古论文论文入手[QTREE解法的一些研究](https://www.doc88.com/p-7448793832055.html)。

**code**

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ls lt[p]
#define rs rt[p]
#define mid ((L+R)>>1)
#define getchar() (p1 == p2 && (p2 = (p1 = buf1) + fread(buf1, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)
char buf1[1 << 23], *p1 = buf1, *p2 = buf1, ubuf[1 << 23], *u = ubuf;
namespace IO
{
	template<typename T>
	void read(T &_x){_x=0;int _f=1;char ch=getchar();while(!isdigit(ch)) _f=(ch=='-'?-1:_f),ch=getchar();while(isdigit(ch)) _x=_x*10+(ch^48),ch=getchar();_x*=_f;}
	template<typename T,typename... Args>
	void read(T &_x,Args&...others){Read(_x);Read(others...);}
	const int BUF=20000000;char buf[BUF],to,stk[32];int plen;
	#define pc(x) buf[plen++]=x
	#define flush(); fwrite(buf,1,plen,stdout),plen=0;
	template<typename T>inline void print(T x){if(!x){pc(48);return;}if(x<0) x=-x,pc('-');for(;x;x/=10) stk[++to]=48+x%10;while(to) pc(stk[to--]);}
}
using namespace IO;
const int N = 2e5+10;
int n,q,T,op,x,y,z,head[N],cnt,o1;
int siz[N],son[N],dep[N],a[N],v[N],fa[N],id[N],dfn[N],col[N],en[N],cnt1,o,lca,cnt2;
ll sum,S,Dep[N];
int root[N],lt[N<<2],rt[N<<2];
struct w
{
	int to,nxt,z;
}b[N<<1];
struct w1
{
	ll ad,len,sum;
}c[N<<2];
inline void add(int x,int y,int z)
{
	b[++cnt].nxt = head[x];
	b[cnt].to = y,b[cnt].z = z;
	head[x] = cnt;
}
void dfs(int x,int y)
{
	siz[x] = 1,fa[x] = y,dep[x] = dep[y]+1;
	for(int i = head[x];i;i = b[i].nxt)
		if(b[i].to != y)
		{
			Dep[b[i].to] = Dep[x]+b[i].z,a[b[i].to] = b[i].z,dfs(b[i].to,x),siz[x] += siz[b[i].to];
			if(siz[b[i].to] > siz[son[x]]) son[x] = b[i].to;
		}
}
void dfs1(int x,int y,int z)
{
	dfn[x] = ++cnt1,id[cnt1] = x,col[x] = z,en[z] = cnt1;
	if(!son[x]) return;
	dfs1(son[x],x,z);
	for(int i = head[x];i;i = b[i].nxt)
		if(b[i].to != y && b[i].to != son[x])
			dfs1(b[i].to,x,b[i].to);
}
inline void push_up(int p)
{
	c[ls].ad += c[p].ad,c[rs].ad += c[p].ad;
	c[ls].sum += c[ls].len*c[p].ad,c[rs].sum += c[rs].len*c[p].ad;
	c[p].ad = 0;
}
void build(int &p,int L,int R)
{ 
	p = ++cnt2;
	if(L == R)
	{
		c[p].len = a[id[L]];
		return;
	}
	build(lt[p],L,mid),build(rt[p],mid+1,R);
	c[p].len = c[ls].len+c[rs].len;
}
void change(int p,int l,int r,int k,int L,int R)
{
	if(l <= L && R <= r)
	{
		c[p].ad += k,c[p].sum += c[p].len*k;
		return;
	}
	if(c[p].ad != 0) push_up(p);
	if(l <= mid) change(ls,l,r,k,L,mid);
	if(mid < r) change(rs,l,r,k,mid+1,R);
	c[p].sum = c[ls].sum+c[rs].sum;
}
ll query(int p,int l,int r,int L,int R)
{
	if(l <= L && R <= r) return c[p].sum;
	ll ans = 0;
	if(c[p].ad != 0) push_up(p);
	if(l <= mid) ans = query(ls,l,r,L,mid);
	if(mid < r) ans += query(rs,l,r,mid+1,R);
	return ans;
}
inline void Cg(int x,int y){ while(x) o1 = col[x],change(root[o1],dfn[o1],dfn[x],y,dfn[o1],en[o1]),x = fa[o1]; }
inline int Lca(int x,int y)
{
	while(col[x] != col[y])
	{
		if(dep[col[x]] < dep[col[y]]) swap(x,y);
		x = fa[col[x]];
	}
	if(dfn[x] < dfn[y]) return x;
	return y;
}
inline ll Q(int x)
{
	ll ans = 0;
	while(x) o1 = col[x],ans += query(root[o1],dfn[o1],dfn[x],dfn[o1],en[o1]),x = fa[o1];
	return ans;
}
signed main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	read(n),read(q),read(T);
	for(int i = 1;i < n;i++) read(x),read(y),read(z),add(x,y,z),add(y,x,z);
	for(int i = 1;i <= n;i++) read(v[i]);
	dfs(1,0),dfs1(1,0,1);
	for(int i = 1;i <= n;i++)
		if(col[i] == i) build(root[i],dfn[i],en[i]);
	for(int i = 1;i <= n;i++)
		if(v[i]) Cg(i,1),sum += Dep[i],S++;
	while(q--)
	{
		read(op);
		if(op == 1)
		{
			read(x);
			if(v[x] == 0) Cg(x,1),sum += Dep[x],S++;
			else Cg(x,-1),sum -= Dep[x],S--;
			v[x] = !v[x];
		}
		else
		{
			read(x),read(y),lca = Lca(x,y);
			print(sum-(Q(x)+Q(y))+Dep[lca]*S),pc('\n');
		}
	}
	flush();
	return 0;
}
```

---

## 作者：takanashi_mifuru (赞：1)

### 简要题意

给你一棵树，上面有白点和黑点，你需要支持两种操作：

1. 将一个点的颜色反转。
2. 查询树上所有黑点到一条链上的最短路径之和。

### 思路

先来考虑暴力做法。众所周知，在一棵树上，点 $x$ 到链 $\left(u,v\right)$ 的最短路径为 $\frac{dis\left(u,x\right)+dis\left(v,x\right)-dis\left(u,v\right)}{2}$。

暴力枚举就可以拿到 $40$ 分的好成绩。

众所周知，$dis\left(x,y\right)=dis_x+dis_y-2\times dis_{lca\left(x,y\right)}$，这里的 $dis_x$ 指的是 $x$ 到根的距离。考虑把这个式子化简，化简后的式子为 $dis_x-dis_{lca{\left(u,x\right)}}-dis_{lca\left(v,x\right)}+dis_{u,v}$，我们把这个式子拆成四个部分，第一部分是 $dis_x$，这个直接更新就做完了。

第四部分是 $dis_{u,v}$，这个统计黑点数量直接乘起来求和就做完了。

第二部分和第三部分的式子几乎相同，我们只要会求 $dis_{lca{\left(u,x\right)}}$，就能求出 $dis_{lca{\left(v,x\right)}}$。

容易发现，无论是什么点，与 $x$ 的 $lca$ 都一定是 $x$ 的祖先。

那么我们就从祖先下手，对于 $x$ 的祖先 $y$，与点 $x$ 的 $lca$ 是点 $y$ 的点一定是 $y$ 的后代并且一定不是 $x$ 的深度比 $y$ 大的祖先 $z$ 的后代的点。

非常拗口，画张图。

![](https://pic1.imgdb.cn/item/636c9e9816f2c2beb1e25040.png)

如图，设点 $5$ 为点 $x$，点 $1$ 为点 $y$，这个时候 $1$ 的后代有 $2,3,4,5,6$，其中 $4,5,6$ 是点 $x$ 的深度比 $y$ 大的祖先 $4$ 的后代。

说着很麻烦，你会发现 $x$ 的 $k$ 级祖先的可用黑点数量为第 $k$ 级祖先的子树中的黑点数量与第 $k-1$ 级祖先的子树中黑点数量的差，设 $a_i$ 表示点 $i$ 的子树中的黑点数量，那么$x$ 的 $k$ 级祖先的可用黑点数量为 $a_{fa_{x,k}}-a_{fa_{x,k-1}}$，这些点与 $x$ 的 $lca$ 都是 $x$ 的第 $k$ 级祖先。

我们要求的是 $dis$ 之和，即 $dis_{fa_{x,k}}\times\left(a_{fa_{x,k}}-a_{fa_{x,k-1}}\right)$，考虑对这个东西求和。

把相邻两个拿出来求和，即 $dis_{fa_{x,k}}\times\left(a_{fa_{x,k}}-a_{fa_{x,k-1}}\right)+dis_{fa_{x,k-1}}\times\left(a_{fa_{x,k-1}}-a_{fa_{x,k-2}}\right)$，拆开括号后合并同类项，发现对于每两个相邻的点的答案的和都可以将其中一个合并同类项，而又众所周知，$dis_1=0$，所以刚好凑出 $n$ 项，相邻两个点的 $dis$ 的差值相当于是这两个点之间的路径长度。

到这一步，式子变成了求 $x$ 的倒根链上的 $a_i\times w_i$ 的和，其中 $w_i$ 表示第 $i$ 个点与他的父亲之间的路径长度。

在树上，需要修改和查询一整条路径，用树链剖分套线段树就能维护。

时间复杂度 $O\left(n\log^2n\right)$。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct node{
    int v,w;
};
int n,q,type;
int father[200005];
int dis[200005];
int top[200005];
int rnk[200005];
int dfn[200005];
int heavy[200005];
int siz[200005];//这个siz是结点数量
int cnt;
vector<node> ljb[200005];
int val[200005];
int a[200005];
int tag[200005];
int pre[200005];
int dep[200005];
void dfs(int cur,int fa){
    dep[cur]=dep[fa]+1;
    father[cur]=fa;
    siz[cur]=1;
    for(int i=0;i<ljb[cur].size();i++){
        int v=ljb[cur][i].v;
        int w=ljb[cur][i].w;
        if(v==fa)continue;
        dis[v]=dis[cur]+w;
        dfs(v,cur);
        siz[cur]+=siz[v];
        if(siz[heavy[cur]]<siz[v]){
            heavy[cur]=v;
        }
    }
    return;
}
void getlink(int cur,int fa){
    cnt++;
    dfn[cur]=cnt;
    rnk[cnt]=cur;
    if(heavy[cur]){
        top[heavy[cur]]=top[cur];
        getlink(heavy[cur],cur);
    }
    for(int i=0;i<ljb[cur].size();i++){
        int v=ljb[cur][i].v;
        if(v==fa)continue;
        if(v==heavy[cur])continue;
        top[v]=v;
        getlink(v,cur);
    }
    return;
}
void geta(int cur,int fa){
    a[cur]=tag[cur];
    for(int i=0;i<ljb[cur].size();i++){
        int v=ljb[cur][i].v;
        if(v==fa)continue;
        geta(v,cur);
        a[cur]+=a[v];
    }
    return;
}
class SegTree{
    public:
    int tree[200005<<2];
    int tag[200005<<2];
    void pushup(int cur){
        tree[cur]=tree[cur*2]+tree[cur*2+1];
    }
    void addtag(int cur,int lt,int rt,int val){
        tree[cur]+=abs(pre[rt]-pre[lt-1])*val;
        tag[cur]+=val;
        return;
    }
    void pushdown(int cur,int lt,int rt){
        if(!tag[cur])return;
        int mid=lt+rt>>1;
        addtag(cur*2,lt,mid,tag[cur]);
        addtag(cur*2+1,mid+1,rt,tag[cur]);
        tag[cur]=0;
        return;
    }
    void build(int cur,int lt,int rt){
        if(lt==rt){
            tree[cur]=a[rnk[lt]]*val[lt];//lt是dfn，rnk[lt]是i
            return;
        }
        int mid=lt+rt>>1;
        build(cur*2,lt,mid);
        build(cur*2+1,mid+1,rt);
        pushup(cur);
        return;
    }
    void update(int cur,int lt,int rt,int qx,int qy,int val){
        if(rt<qx||lt>qy){
            return;
        }
        if(lt>=qx&&rt<=qy){
            addtag(cur,lt,rt,val);
            return;
        }
        pushdown(cur,lt,rt);
        int mid=lt+rt>>1;
        update(cur*2,lt,mid,qx,qy,val);
        update(cur*2+1,mid+1,rt,qx,qy,val);
        pushup(cur);
        return;
    }
    int query(int cur,int lt,int rt,int qx,int qy){
        if(lt>qy||rt<qx){
            return 0;
        }
        if(lt>=qx&&rt<=qy){
            return tree[cur];
        }
        pushdown(cur,lt,rt);
        int mid=lt+rt>>1;
        return query(cur*2,lt,mid,qx,qy)+query(cur*2+1,mid+1,rt,qx,qy);
    }
}P;
void updatelink(int x,int val){
    while(x){
        P.update(1,1,n,dfn[top[x]],dfn[x],val);
        x=father[top[x]];
    }
    return;
}
int getlink(int x){
    int sum=0;
    while(x){
        sum+=P.query(1,1,n,dfn[top[x]],dfn[x]);
        x=father[top[x]];
    }
    return sum;
}
int LCA(int x,int y){
    while(top[x]!=top[y]){
        if(dep[top[x]]<dep[top[y]]){
            swap(x,y);
        }
        x=father[top[x]];
    }
    if(dep[x]<dep[y])return x;
    return y;
}
/*
以上是树链剖分基本操作
*/
signed main(){
    scanf("%lld%lld%lld",&n,&q,&type);
    for(int i=1;i<n;i++){
        int u,v,w;
        scanf("%lld%lld%lld",&u,&v,&w);
        ljb[u].push_back(node{v,w});
        ljb[v].push_back(node{u,w});
    }
    dfs(1,0);
    getlink(1,0);
    int pos=0,sum=0;
    for(int i=1;i<=n;i++){
        scanf("%lld",&tag[i]);
        pos+=tag[i];
        sum+=tag[i]*dis[i];
    }
    geta(1,0);
    for(int i=1;i<=n;i++){
        val[i]=dis[rnk[i]]-dis[father[rnk[i]]];//注意这里的val以 $dfn[i]$ 为下标！
    }
    for(int i=1;i<=n;i++){
        pre[i]=pre[i-1]+val[i];
    }
    P.build(1,1,n);
    while(q--){
        int opt;
        scanf("%lld",&opt);
        if(opt==1){
            int x;
            scanf("%lld",&x);
            if(tag[x]){
                updatelink(x,-1);
                sum-=dis[x];
                pos--;
            }
            else{
                updatelink(x,1);
                sum+=dis[x];
                pos++;
            }
            tag[x]^=1;
        }
        else{
            int x,y;
            scanf("%lld%lld",&x,&y);
            printf("%lld\n",sum-getlink(x)-getlink(y)+pos*dis[LCA(x,y)]);
            /*
            sum表示所有黑点的dis和
            getlink(x)表示点x与所有黑点的lca的dis的和
            pos表示黑点数量。
            */
        }
    }
    return 0;
}
```

---


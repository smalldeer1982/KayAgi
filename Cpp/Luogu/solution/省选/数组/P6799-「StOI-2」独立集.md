# 「StOI-2」独立集

## 题目描述

一棵由 $n$ 个点组成的无根树，给定 $m$ 条树上的路径，请求出由这 $m$ 条路径组成的`独立集`方案总数。

由于这个答案可能很大，您只需求出它对 $998,244,353$ 取模的结果即可。

所谓`独立集`，就是一个路径集合，满足这个集合中**不存在**一对在树上有交点的路径。特殊的，空集和只包括一条路径的集合也是独立集。



## 说明/提示

**请注意常数因子对程序执行效率的影响**

## 样例解释


总共有 $2^3=8$ 个集合。

有两个集合 { {2,3} ，{2,4} } 与 { {1,5} ，{2,3} ，{2,4} } 不符合要求。

故样例答案为 $8-2=6$ 。

## 数据范围

对于 $10\%$ 的数据：$1 \leq n \leq 10$ ，$1 \leq m \leq 10$。   
对于 $20\%$ 的数据：$1 \leq n \leq 100$ ，$1 \leq m \leq 100$ 。   
对于另 $30\%$ 的数据：$1 \leq m \leq 15$ 。   
对于另 $10\%$ 的数据：$1 \leq n,m \leq 10^{5}$。    
对于另 $20\%$ 的数据：$u_{i}=i,v_{i}=i+1$。   
对于 $100\%$ 的数据：$1\leq n,m \leq 5 \times 10^{5}$ 。

## 样例 #1

### 输入

```
5 3
1 2
2 3
2 4
1 5
1 5
2 3
2 4```

### 输出

```
6```

# 题解

## 作者：littleKtian (赞：7)

upd on 2021.3.16：修改了原做法和代码中的错误，现在能通过 hack 数据了。

------------

显然这是道树形 dp，为了方便处理信息，我们考虑将这 $m$ 条链放到 lca 上维护。

设 $f_{i,0/1}$ 表示以 $i$ 为根的子树中没有选取/有选取以 $i$ 为 lca 的链时，选取链的方案数，$g_i$ 为两者之和。

易得转移方程 $f_{i,0}=\prod\limits_{j\text{是}i\text{的孩子}}g_j,f_{i,1}=\sum\limits_{\text{链}L\text{的lca是}i}\prod\limits_{j\text{不在}L\text{上，且}\atop j\text{的父亲在}L\text{上}}g_j$。

$f_{i,0}$ 很容易计算出，考虑如何计算 $f_{i,1}$。

发现连乘的形式和 $f_{i,0}$ 很像，于是考虑往这个方向变形。

得 $f_{i,1}=\sum\limits_{\text{链}L\text{的lca是}i}\dfrac{\prod\limits_{j\text{的父亲在}L\text{上}}g_j}{\prod\limits_{k\text{在}L\text{上且}k\neq i}g_k}=\sum f_{i,0}\prod\limits_{j\text{在}L\text{上且}j\neq i}\dfrac{f_{j,0}}{g_j}$。

显然这是一个树上的区间求乘积，最简单的方法是 树剖+线段树，但并不能通过此题。

我们可以对树剖的每条重链维护后缀积，因为整个 dp 的过程是从下往上的，而且我们只需要用到下面的信息点，所以对于每个点我们都可以做到 $O(1)$ 维护后缀积+每条链 $O(\log n\log p)$ 查询，预处理逆元后可以每个点 $O(\log p)$ 维护+每条链 $O(\log n)$ 查询，可以通过。

~~以上做法已被 hack~~

------------

上面做法的最大问题是 $f_{i,0}$ 和 $g_i$ 在对 $998244353$ 取模意义下可能为 $0$，导致逆元无法使用。但我们也可以从中获得一些启示。

我们把乘积式中的元素分为 $j$ 是 $i$ 的儿子以及不是 $i$ 的儿子两部分，发现对于 $j$ 是 $i$ 的儿子的部分，最多只会有两个元素缺失，所以我们可以给 $i$ 的每个儿子一个标号，用线段树处理出区间乘积，对于每条链最多只会有 $3$ 次询问，所以对于每条链复杂度是 $O(\log n)$。

对于不是 $i$ 的儿子的部分，可以发现对于所有链 $L$ 上的点 $j$，都最多只会缺失一个元素，并且缺失的元素就是链 $L$ 上的点。所以我们可以另设 $h_i$ 表示 $fa_i$ 的儿子中除了 $i$ 以外所有 $g$ 的乘积，那么我们相当于需要查询一条链上所有元素的乘积，我们可以转化为每次对以某个点为根的子树内所有元素乘上一个数，然后进行单点查询。因此复杂度还是 $O(\log n)$ 的。

总复杂度应该是 $O\left((n+m)\log n\right)$，细节相对较多。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define p 998244353
int lsw[500005],bi[1000005][2],bs;
int fa[500005],so[500005],si[500005],de[500005],to[500005],xh[500005],dfn;
int lw[500005],la[500005][3];
int n,m,ff[2][500005],f[500005];
int dr()
{
    int xx=0;char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9')xx=xx*10+ch-'0',ch=getchar();
    return xx;
}
int P(int x,int y=p-2)
{
    int z=1;
    for(;y;x=1ll*x*x%p,y>>=1)if(y&1)z=1ll*z*x%p;
    return z;
}
void tj(int u,int v){++bs,bi[bs][0]=lsw[u],bi[bs][1]=v,lsw[u]=bs;}
void dfs_1(int w,int f)
{
    fa[w]=f,si[w]=1,de[w]=de[f]+1;
    for(int o_o=lsw[w];o_o;o_o=bi[o_o][0])
    {
        int v=bi[o_o][1];
        if(v!=f)
        {
            dfs_1(v,w),si[w]+=si[v];
            if(si[v]>si[so[w]])so[w]=v;
        }
    }
}
void dfs_2(int w,int t)
{
    to[w]=t,xh[w]=++dfn;
    if(so[w])dfs_2(so[w],t);
    for(int o_o=lsw[w];o_o;o_o=bi[o_o][0])
    {
        int v=bi[o_o][1];
        if(v!=fa[w]&&v!=so[w])dfs_2(v,v);
    }
}
int fi(int x,int y)
{
    int fx=to[x],fy=to[y];
    while(fx!=fy)
    {
        if(de[fx]>=de[fy])x=fa[fx],fx=to[x];
        else y=fa[fy],fy=to[y];
    }
    return de[x]<de[y]? x:y;
}
int ju(int x,int y)
{
	int fx=to[x],fy=to[y];
	while(fx!=fy)
	{
		if(fa[fx]==y)return fx;
		x=fa[fx],fx=to[x];
	}
	return so[y];
}
int tree[2000005],ltree[2000005],a[500005],lxh[500005];
#define ls(w) (w<<1)
#define rs(w) (ls(w)^1)
void d(int w){if(tree[w]!=1)tree[ls(w)]=1ll*tree[ls(w)]*tree[w]%p,tree[rs(w)]=1ll*tree[rs(w)]*tree[w]%p,tree[w]=1;}
void csh1(int w,int l,int r)
{
	tree[w]=1;
	if(l==r)return;
	int mid=(l+r)>>1;
	csh1(ls(w),l,mid),csh1(rs(w),mid+1,r);
}
void xg1(int w,int l,int r,int L,int R,int x)
{
	if(L<=l&&r<=R){tree[w]=1ll*tree[w]*x%p;return;}
	d(w);
	int mid=(l+r)>>1;
	if(L<=mid)xg1(ls(w),l,mid,L,R,x);
	if(mid<R)xg1(rs(w),mid+1,r,L,R,x);
}
int cx1(int w,int l,int r,int xh)
{
	if(l==r)return tree[w];
	d(w);
	int mid=(l+r)>>1;
	if(xh<=mid)return cx1(ls(w),l,mid,xh);
	else return cx1(rs(w),mid+1,r,xh);
}
void u(int w){ltree[w]=1ll*ltree[ls(w)]*ltree[rs(w)]%p;}
void csh2(int w,int l,int r)
{
	if(l==r){ltree[w]=a[l];return;}
	int mid=(l+r)>>1;
	csh2(ls(w),l,mid),csh2(rs(w),mid+1,r);
	u(w);
}
int cx2(int w,int l,int r,int L,int R)
{
	if(L>R)return 1;
	if(L<=l&&r<=R)return ltree[w];
	int mid=(l+r)>>1,x=1;
	if(L<=mid)x=1ll*x*cx2(ls(w),l,mid,L,R)%p;
	if(mid<R)x=1ll*x*cx2(rs(w),mid+1,r,L,R)%p;
	return x;
}
void dp(int w)
{
    ff[0][w]=1;int tot=0;
    for(int o_o=lsw[w];o_o;o_o=bi[o_o][0])
    {
        int v=bi[o_o][1];
        if(v!=fa[w])dp(v),lxh[v]=++tot,ff[0][w]=1ll*ff[0][w]*f[v]%p;
    }
    for(int o_o=lsw[w];o_o;o_o=bi[o_o][0])
    {
    	int v=bi[o_o][1];
    	if(v!=fa[w])a[lxh[v]]=f[v];
	}
	if(tot)csh2(1,1,tot);
    for(int o_o=lw[w];o_o;o_o=la[o_o][0])
	{
		int u=la[o_o][1],v=la[o_o][2];
		if(u!=w&&v!=w)
		{
			int x=ju(u,w),y=ju(v,w);
			if(lxh[x]>lxh[y])swap(x,y);
			ff[1][w]=(ff[1][w]+(1ll*cx1(1,1,n,xh[u])*ff[0][u]%p)*(1ll*cx1(1,1,n,xh[v])*ff[0][v]%p)%p*(1ll*cx2(1,1,tot,1,lxh[x]-1)*cx2(1,1,tot,lxh[x]+1,lxh[y]-1)%p*cx2(1,1,tot,lxh[y]+1,tot)%p))%p;
		}
		else if(u==w&&v==w)
		{
			ff[1][w]=(ff[1][w]+ff[0][w])%p;
		}
		else
		{
			if(v==w)swap(u,v);
			int x=ju(v,w);
			ff[1][w]=(ff[1][w]+1ll*cx1(1,1,n,xh[v])*ff[0][v]%p*cx2(1,1,tot,1,lxh[x]-1)%p*cx2(1,1,tot,lxh[x]+1,tot))%p;
		}
	}
	for(int o_o=lsw[w];o_o;o_o=bi[o_o][0])
	{
		int v=bi[o_o][1];
    	if(v!=fa[w])
    	{
    		int x=1ll*cx2(1,1,tot,1,lxh[v]-1)*cx2(1,1,tot,lxh[v]+1,tot)%p;
    		xg1(1,1,n,xh[v],xh[v]+si[v]-1,x);
		}
	}
    f[w]=(ff[0][w]+ff[1][w])%p;
}
int main()
{
    n=dr(),m=dr();
    for(int i=1;i<n;i++)
    {
        int u=dr(),v=dr();
        tj(u,v),tj(v,u);
    }
    dfs_1(1,0),dfs_2(1,1);
    for(int i=1;i<=m;i++)
    {
        int u=dr(),v=dr(),g=fi(u,v);
        la[i][0]=lw[g],la[i][1]=u,la[i][2]=v,lw[g]=i;
    }
    csh1(1,1,n),dp(1);
    printf("%d",f[1]);
}

```


---

## 作者：Wei_Han (赞：1)

思维好题。

先考虑一个子树怎么做，假设当前子树根 $x$，有 $y,z$ 两儿子，我们令 $f_i$ 表示以 $i$ 为根的答案，那么首先 $y,z$ 的答案需要合并，其实就是直接乘，因为保证了左右两边的方案一定合法，但是这还没有算上新加入的点 $x$ 带来的贡献，暂且将儿子的乘积记作 $g_i$。

一条链，我们将其贡献整个放到 $lca$ 上来统计，对于当前一条 $lca$ 在 $x$ 的链，其左右端点 $u,v$ 分别在 $y,z$ 两子树内，记 $P(x,y)$ 表示 $x$ 到 $y$ 路径上的点构成的点集，则其新带来的贡献为 $\prod \limits_{i \in son_{P(y,x)} \wedge i \notin P(u,x)} f_i$，表示从 $u$ 到 $x$ 路径上所有点的子树答案乘积，且不包括链上的答案，因为需要链无交集，这只是一侧，另一侧同理，假设 $x$ 还有另外几个子树，而 $u,v$ 并不在那些子树内，则那些正常参与统计即可，也就是:

$$\prod \limits_{i \in son_{P(u,v)} \wedge i \notin P(u,v)} f_i = \prod \limits_{i \in P(u,v) \wedge i \notin x} \frac{g_i}{f_i}$$

这一步转化其实很简单，考虑我们只要链挂着的那些子树，而不要链上的点，第二个式子分子其实是包括了链和子树的乘积，所以我们需要再分母除掉我们多算的 $f_i$，这几步其实可以画画图可以更好理解。

推广到全树同理，之后就简单了，直接树剖维护 $g_i$ 链积和 $f_i$ 逆元链积就好了，注意判一下当 $u,v$ 和 $x$ 重合的情况，复杂度 $O((n+m)\log^2 n)$，可以通过。

判了 $1$ 就通过了 hack 数据，但感觉还是有点假，似乎也没有看懂 hack 的原理。

```cpp
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f3f3f3f3f
#define inf 0x3f3f3f3f
#define pr putchar('\n')
#define fi first
#define se second
#define pp putchar(' ')
#define pii pair<ll,ll>
#define pdi pair<ll,ll>
#define mem(aa,bb) memset(aa,bb,sizeof(aa))
#define fo(a,i,b) for(register ll i = a ; i <= b ; ++ i )
#define Fo(a,i,b) for(register ll i = a ; i >= b ; -- i )
#define pb push_back
//#pragma GCC optimize(2)
using namespace std;
//typedef int ll;
typedef long long ll;
//typedef __int128 ll;
typedef double db;
inline void read(ll &opp){ll x=0,t=1;char ch;ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-'){t=-1;}ch=getchar();}while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}opp=x*t;return; }
inline void wr(ll x){if(x<0){putchar('-');x=-x;}if(x>9){wr(x/10);}putchar(x%10+'0');}
const ll N=5e5+5,M=2e4+5,mod=998244353;
ll n,m,suf[N],fa[N],dep[N],siz[N],son[N],top[N],id[N],w[N],cnt,num[N],f[N],pw[N],g[N];
inline ll qpow(ll a,ll b){return (!b?1ll:qpow(a*a%mod,b>>1)*((b&1)?a:1))%mod;}
vector<ll> G[N];
vector<pii> P[N];
struct SGT{ll l,r,sum1,sum2;}tree[N<<2];
#define rt tree[root]
#define ls tree[root<<1]
#define rs tree[root<<1|1]
inline void pushup(ll root){rt.sum1=ls.sum1*rs.sum1%mod;rt.sum2=ls.sum2*rs.sum2%mod;}
inline void build(ll root,ll l,ll r){rt.l=l,rt.r=r;if(l==r) return rt.sum1=rt.sum2=1,void();ll mid=l+r>>1;build(root<<1,l,mid),build(root<<1|1,mid+1,r);pushup(root);}
inline void upd(ll root,ll x,ll k1,ll k2){ll l=rt.l,r=rt.r;if(l==r) return rt.sum1=k1,rt.sum2=k2,void();ll mid=l+r>>1;if(x<=mid) upd(root<<1,x,k1,k2);else upd(root<<1|1,x,k1,k2);pushup(root);}
inline void merge(pii &x,pii y){x.fi=x.fi*y.fi%mod,x.se=x.se*y.se%mod;}
inline pii ask(ll root,ll x,ll y){if(x>y) return {1,1};ll l=rt.l,r=rt.r;if(x<=l&&y>=r) return make_pair(rt.sum1,rt.sum2);ll mid=l+r>>1;pii ans={1,1};if(x<=mid) ans=ask(root<<1,x,y);if(y>mid) merge(ans,ask(root<<1|1,x,y));return ans;}
inline ll LCA(ll x,ll y){while(top[x]^top[y]) dep[top[x]]<dep[top[y]]?y=fa[top[y]]:x=fa[top[x]];return dep[x]<dep[y]?x:y;}
inline pii ask_chain(ll x,ll y)
{
	pii ans={1,1};
	while(top[x]^top[y])
	{
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		merge(ans,ask(1,id[top[x]],id[x]));x=fa[top[x]];
	}
	if(dep[x]<dep[y]) swap(x,y);merge(ans,ask(1,id[y]+1,id[x]));return ans;
}
inline void dfs1(ll x,ll fat,ll depth)
{
	fa[x]=fat,siz[x]=1,dep[x]=depth;
	for(ll y:G[x])
	{
		if(y==fat) continue;
		dfs1(y,x,depth+1);siz[x]+=siz[y];
		if(siz[y]>siz[son[x]]) son[x]=y;
	}
}
inline void dfs2(ll x,ll nowtop)
{
	top[x]=nowtop,id[x]=++cnt,w[cnt]=x;
	if(!son[x]) return;dfs2(son[x],nowtop);
	for(ll y:G[x]) if(y!=fa[x]&&y!=son[x]) dfs2(y,y);
}
inline void dfs3(ll x)
{
	suf[x]=num[x]=P[x].size();
	for(ll y:G[x])
	{
		if(y==fa[x]) continue;
		dfs3(y);
		suf[x]+=suf[y];
	}
}
inline void solve(ll x)
{
	g[x]=1;
	for(ll y:G[x])
	{
		if(y==fa[x]) continue;
		solve(y);g[x]=g[x]*f[y]%mod;
	}
	for(pii vv:P[x])
	{
		ll u=vv.fi,v=vv.se;
		ll num=g[x];
		if(u!=x)
		{
			pii opt=ask_chain(u,x);
			num=num*opt.fi%mod*opt.se%mod;
		}
		if(v!=x)
		{
			pii opt=ask_chain(v,x);
			num=num*opt.fi%mod*opt.se%mod;
		}
		f[x]=(f[x]+num)%mod;
	}
	f[x]=(g[x]+f[x])%mod;
	upd(1,id[x],g[x],qpow(f[x],mod-2));
}
signed main(){
	read(n),read(m);
	ll u,v;fo(1,i,n-1) read(u),read(v),G[u].pb(v),G[v].pb(u);
	dfs1(1,0,1),dfs2(1,1);
	fo(1,i,m)
	{
		ll x,y;read(x),read(y);
		ll lca=LCA(x,y);P[lca].pb({x,y});
	}
	dfs3(1),build(1,1,n),solve(1);
	wr(max(f[1],1ll)),pr;
	return 0;
}
``````

---

## 作者：lhc0707 (赞：0)

首先考虑能不能直接把链塞到状态里直接做，但是判重太困难了，显然不可做，所以考虑在子树里 dp。设 $f_{i,0/1}$ 表示点 $i$ 为根的子树内选不选以 $u$ 为 $\operatorname{lca}$ 的路径的情况数，并记 $g_i=f_{i,0}+f_{i,1}$。容易列出转移：

$$f_{i,0}=\prod\limits_{j\in \text{son}_i}g_j$$

记路径 $L$ 两端点的 $\operatorname{lca}$ 为 $\operatorname{lca}(L)$，点 $i$ 的父亲为 $\text{fa}_i$，有

$$f_{i,1}=\sum\limits_{\operatorname{lca}(L)=i}\prod\limits_{\text{fa}_j\in L}g_v$$

发现 $\text{fa}_j\in L$ 很难维护，于是考虑直接拿 $\text{fa}_j$ 算，这样就可以链上求和做了。注意到 $f_{i,0}=\prod_{j\in \text{son}_i}g_j$ 的形式，于是把连乘的东西变成这个东西，但是会多算链上的，于是把链上的点的 $g$ 除掉，有

$$f_{i,1}=\sum\limits_{\operatorname{lca}(L)=i}f_{i,0}\prod\limits_{j\in L,j\not =i}\frac{f_{j,0}}{g_j}$$

然后线段树维护 $\prod\frac{f_{j,0}}{g_j}$ 就可以了。注意如果存在 $g_j=0$，那么求出来的 $g_1$ 是 0，但是答案是 $1$，所以说答案不会小于一，所以最后的时候 $g_1$ 与 $1$ 取个 $\max$ 就可以了。

code：

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <vector>
#define int long long
using namespace std;
const int mod = 998244353;
int read()
{
    int x = 0, f = 1;
    char c = getchar();
    while (c < '0' || c > '9') f ^= (c == '-'), c = getchar();
    while (c >= '0' && c <= '9') x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();
    return f ? x : -x;
}
void write(int x)
{
    if (x < 0) putchar('-'), x = -x;
    if (x > 9) write(x / 10);
    putchar(x % 10 + '0');
}
int qpow(int a, int b)
{
    int res = 1;
    while (b)
    {
        if (b & 1) res = res * a % mod;
        a = a * a % mod, b >>= 1;
    }
    return res % mod;
}
const int N = 5e5 + 10;
int n, m, head[N], tot;
struct edge
{
    int v, nxt;
} e[N << 1];
void add(int u, int v) { e[++tot] = {v, head[u]}, head[u] = tot; }
struct path
{
    int l, r, lca;
} p[N];
int fa[N], dep[N], siz[N], hson[N], top[N], dfn[N], Time;
void dfs1(int u, int fath)
{
    fa[u] = fath, dep[u] = dep[fath] + 1, siz[u] = 1;
    for (int i = head[u]; i; i = e[i].nxt)
    {
        int v = e[i].v;
        if (v == fath) continue;
        dfs1(v, u), siz[u] += siz[v];
        if (siz[v] > siz[hson[u]]) hson[u] = v;
    }
}
void dfs2(int u, int now_tp)
{
    top[u] = now_tp, dfn[u] = ++Time;
    if (hson[u]) dfs2(hson[u], now_tp);
    for (int i = head[u]; i; i = e[i].nxt)
        if (e[i].v != fa[u] && e[i].v != hson[u]) dfs2(e[i].v, e[i].v);
}
int LCA(int u, int v)
{
    while (top[u] != top[v]) dep[top[u]] < dep[top[v]] ? v = fa[top[v]] : u = fa[top[u]];
    return dep[u] < dep[v] ? u : v;
}
vector<int> vec[N];
int f[N][2], g[N];
struct segment
{
#define ls (p << 1)
#define rs (p << 1 | 1)
#define mid ((pl + pr) >> 1)
    int tr[N << 2];
    void build(int p, int pl, int pr)
    {
        tr[p] = 1;
        if (pl == pr) return;
        build(ls, pl, mid), build(rs, mid + 1, pr);
    }
    void up(int p) { tr[p] = tr[ls] * tr[rs] % mod; }
    void update(int p, int pl, int pr, int pos, int v)
    {
        if (pl == pr) return tr[p] = v, void();
        if (pos <= mid) update(ls, pl, mid, pos, v);
        else update(rs, mid + 1, pr, pos, v);
        up(p);
    }
    int query(int p, int pl, int pr, int L, int R)
    {
        if (L > R) return 1ll;
        if (L <= pl && pr <= R) return tr[p];
        int res = 1;
        if (L <= mid) res = res * query(ls, pl, mid, L, R) % mod;
        if (R > mid) res = res * query(rs, mid + 1, pr, L, R) % mod;
        return res % mod;
    }
#undef ls
#undef rs
#undef mid
} seg;
int query_chain(int u, int v)
{
    int res = 1;
    while (top[u] != top[v])
    {
        if (dep[top[u]] < dep[top[v]]) swap(u, v);
        res = res * seg.query(1, 1, n, dfn[top[u]], dfn[u]) % mod;
        u = fa[top[u]];
    }
    if (dfn[u] > dfn[v]) swap(u, v);
    res = res * seg.query(1, 1, n, dfn[u], dfn[v]) % mod;
    return res;
}
void dp(int u)
{
    f[u][0] = 1;
    for (int i = head[u]; i; i = e[i].nxt)
    {
        if (e[i].v == fa[u]) continue;
        int v = e[i].v;
        dp(v), f[u][0] = f[u][0] * g[v] % mod;
    }
    for (int id : vec[u]) f[u][1] = (f[u][1] + query_chain(p[id].l, p[id].r)) % mod;
    f[u][1] = (f[u][1] * f[u][0]) % mod, g[u] = (f[u][0] + f[u][1]) % mod;
    seg.update(1, 1, n, dfn[u], f[u][0] * qpow(g[u], mod - 2) % mod);
}
signed main()
{
    n = read(), m = read();
    for (int i = 1; i < n; i++)
    {
        int u = read(), v = read();
        add(u, v), add(v, u);
    }
    dfs1(1, 0), dfs2(1, 1);
    seg.build(1, 1, n);
    for (int i = 1; i <= m; i++) p[i].l = read(), p[i].r = read(), p[i].lca = LCA(p[i].l, p[i].r);
    for (int i = 1; i <= m; i++) vec[p[i].lca].push_back(i);
    dp(1);
    write(max(g[1], 1ll));
    return 0;
}
```

---


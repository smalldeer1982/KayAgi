# [COCI 2016/2017 #3] Zoltan

## 题目描述

Marton 的朋友 Cero 有一个由 $N$ 个正整数组成的数组。

首先 Cero 会在黑板上写下这个数组中的第一个数字。接下来他会在之前写下的所有数的左边或者右边写下一个数字。重复以上操作得到一个序列。

请注意，根据上述方法构造出的两个序列相同**当且仅当每一个数字写下的顺序完全相同**。例如，$1,1$ 可能和 $1,1$ 不同，前者的第二个数在第一个数的左边，后者的第二个数在第一个数的右边。

求这些数组成的所有序列中，最长严格递增子序列长度的最大值 $M$，以及所有最长严格递增子序列长度等于 $M$ 的序列中，最长严格递增子序列个数的总和。考虑到答案可能很大，Marton 只想知道这个数对 $10^9+7$ 取模的值。

## 说明/提示

### 样例解释

#### 样例 1 解释

Cero 可以构造 $2$ 个不同的序列，$1,1$ 和 $1,1$。

显然最长的严格上升子序列长度为 $1$，有 $4$ 个子序列满足。

#### 样例 2 解释

最长的严格上升子序列长度为 $4$，只有 $1,2,3,4$ 满足。
 
### 数据规模与约定

对于 $30\%$ 的数据，满足 $N\le 20$。

对于 $50\%$ 的数据，满足 $N\le 10^3$。

对于 $100\%$ 的数据，满足 $N\le 2\times10^5$，数组中的每个元素 $\le10^9$。

### 说明

**题目译自 [COCI2016-2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST #3](https://hsin.hr/coci/archive/2016_2017/contest3_tasks.pdf) _T5 Zoltan_**。

样例 1,2 的解释非官方。

## 样例 #1

### 输入

```
2
1 1 ```

### 输出

```
1 4 ```

## 样例 #2

### 输入

```
4
2 1 3 4 ```

### 输出

```
4 1```

# 题解

## 作者：Demeanor_Roy (赞：18)

- [原题链接](https://www.luogu.com.cn/problem/P6885)

------------

### 前言

- 神仙 DP 题，建议评紫，考场上只能 $30$ 分暴力走人，本篇题解便分别讲解一下 $30$ 分和 $100$ 分的做法。（之所以不讲 $50$ 分，是因为它没有什么区分度，能想到这一步的人一般就能拿满了）


------------

### 30 分做法

- 考虑枚举每一个可能序列，由于每一个新增元素只有放最左或放最右两种选择，所以一共只会有 $2^n$ 种不同序列，对于每一个序列，我们用 $n^2$ 统计最长严格上升子序列及其数量，就可以总体以 $O(2^nn^2)$ 的复杂度解决问题，由于其实跑不满这么多，所以可以通过前 $30$ 分。

- 枚举时有一个小技巧：我们可以用2进制从前到后枚举 $2$ 到 $n$ 号元素怎么放，如果其对应位上为 $0$，就代表当前元素放到左边，我们就将其放入一个栈中，否则将其放入一个队列中，而最终序列就是：依次从栈中取出元素加上一号元素加上依次从队列中取出元素，读者可以思考一下为什么是这样。

- 由于暴力比较简单，就不放代码了。

### 100 分做法

- 首先我们需要将原问题进行转化，这也是本题最难的地方。

- 具体来说，我们不可能对每一个可能序列都进行操作，因为单是枚举的时间我们都无法接受，那让我们思考一下，对于任意一个可能序列，它与给定序列有什么关系？如果你有着惊人的直觉，或许可以看出：每一个可能序列，都是由给定序列选择一个子序列沿一号元素“翻折”至左侧得到的。

- 这么说可能有些抽象，换种说法，就是从原序列中抽出一些数，将这些数顺次组成一个新序列，再翻转这个序列，拼接至最左侧得到的。（这一部分请读者仔细理解）

- 而有了这个结论，我们再回去看题就容易了许多：对于可能序列的一个最长严格上升子序列，一定是由原序列的一个严格下降子序列和一个严格上升子序列拼接而成的，当然需要满足的条件是前者的最大值严格小于后者的最小值且二者无交，我们发现这样并不好求，所以我们可以将前者新增一个元素：严格上升子序列的最小值。

- 这样转化之后，如果我们用 $dp1(i)$ 和 $dp2(i)$ 分别表示以 $i$ 为开始的最长严格上升和下降子序列，那答案便是 $\max(dp1(i)+dp2(i)-1)$，其中 $i$ 从 $1$ 取到 $n$。

- 那接下来的问题就是如何求方案数，首先如果最长严格上升和下降子序列的个数分别为 $cnt1(i)$ 和 $cnt2(i)$ ，那对于确定的 $i$，子序列的个数显然是 $cnt1(i) \times cnt2(i)$，我们用 $len$ 表示最长严格上升子序列长度（拼接后），这时我们来考虑其他元素怎么放：

1. $A_1$ 属于最长严格上升子序列（拼接后），那这时不在序列中的所有元素显然有翻过去和不翻过去两种选择，所以它们的选择有 $2^{n-len}$ 种。

2. $A_1$ 不属于最长严格上升子序列（拼接后），这时不在序列中的元素除了$A_1$ 都有两种选择，可别忘了对于拼接前两个子序列的接口（就是同时属于两个序列的那个元素），由于它不是 $A_1$,所以它可以跟着任何一个序列走，翻不翻都可以，所以方案还要 $\times 2$，所以也是 $2^{n-len}$ 种。

- 综上所述，对于确定的 $i$，方案数为: 
$$cnt1(i) \times cnt2(i) \times2^{n-len}$$

- 最后便是如何快速求最长严格上升子序列，相信大家都会 $n^2$ 的做法，而树状数组优化也不难，这里就不细讲了。（注意不能用贪心加二分，因为那样不便于统计方案数）

- 放代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
#define lowbit(x) x&-x
const int N=2e5+10,mod=1e9+7;
int n,A[N];
LL ans1,ans2,dp1[N],dp2[N],cnt1[N],cnt2[N],fac[N];
vector<int> vec;
struct node
{
	int val;
	LL num;
	node()	{val=0,num=1;}
	inline void add(int x,LL y)
	{
		if(x>val)	val=x,num=y;
		else if(x==val)	num=(num+y)%mod;
	}
}C1[N],C2[N];
inline void insert(int x,int y,LL z,node C[])
{
	for(;x<=n+1;x+=lowbit(x))	C[x].add(y,z);
}
inline node query(int x,node C[])
{
	node res;
	for(;x;x-=lowbit(x))	res.add(C[x].val,C[x].num);
	res.num=res.val?res.num:1;
	return res;
}
int main()
{
	scanf("%d",&n);
	fac[0]=1;
	for(int i=1;i<=n;i++)	fac[i]=fac[i-1]*2%mod;
	for(int i=1;i<=n;i++)	scanf("%d",&A[i]),vec.push_back(A[i]);
	sort(vec.begin(),vec.end());
	vec.erase(unique(vec.begin(),vec.end()),vec.end());
	for(int i=1;i<=n;i++)	A[i]=lower_bound(vec.begin(),vec.end(),A[i])-vec.begin()+2;
	for(int i=n;i>=1;i--)
	{
		node up=query(n+1-A[i],C1),down=query(A[i]-1,C2);
		dp1[i]=up.val+1,cnt1[i]=up.num;;
		dp2[i]=down.val+1,cnt2[i]=down.num;
		insert(n+2-A[i],dp1[i],cnt1[i],C1);
		insert(A[i],dp2[i],cnt2[i],C2);
	}
	for(int i=1;i<=n;i++)	
	{
		int len=dp1[i]+dp2[i]-1;
		if(len>ans1)	ans1=len,ans2=cnt1[i]*cnt2[i]%mod*fac[n-len]%mod;
		else if(len==ans1)	ans2=(ans2+cnt1[i]*cnt2[i]%mod*fac[n-len]%mod)%mod;
	}
	printf("%lld %lld",ans1,ans2);
	return 0;	
} 
```
- 完结撒花~









---

## 作者：Reunite (赞：3)

## 一
---
挺好的一道题，被搬到联考里了然后~~被切了一车~~。

先给出一个结论：**操作的过程相当于取出一个子序列，翻转之后塞到首元素左边**。

证明是简单的，由于首元素固定，对于后面的每个元素，如果选择放到序列左边，那一定是在首元素左边。后放的更靠左，即相对顺序变为倒序。

考虑如何解决第一问，取出子序列这个操作并不好做，但是注意到严格上升以及翻转这两个突破点，我们设 $f_{1,i},f_{2,i}$ 为**从后往前**，到了 $i$ 这个位置，最长上升及最长下降子序列的长度，则第一问答案为：

$$\large \max_{i=1}^{n} \{f_{1,i}+f_{2,i}-1 \}$$

其实这个式子的意义很显然，就是把最长下降子序列翻折过去，和最长上升子序列拼起来，减去共有的 $a_i$ 这个贡献。因为严格上升和严格下降一定无交，所以这个式子的必要性是成立的。

那么有没有可能漏掉最优解呢？其实是不会的，考虑在枚举 $i$ 的时候，如果 $[1,i-1]$ 有值可以拼出更优的 $f_{1,i}+f_{2,i}-1$，那么上式虽然在 $i$ 处无法取到最优解，但是在 $[1,i-1]$ 中比能拼出更优的 $j$ 一定能取到最优。

至此，第一问得到解决。

## 二
---
有了上面的思路，统计方案其实是简单的。我们同时记录 $g_{1,i},g_{2,i}$ 表示后缀最长上升、下降子序列的方案数。

因为最长上升、下降子序列的方案互不干涉，所以这部分的贡献是 $g_{1,i} \cdot g_{2,i}$。剩下有 $n-f_{1,i}-f_{2,i}+1$ 的数放左方右对答案都没有影响，这部分的贡献就是 $2^{n-f_{1,i}-f_{2,i}+1}$。

记第一问的答案为 $mx$，则第二问的答案为：

$$\large \sum_{i=1}^{n}g_{1,i} \cdot g_{2,i}\cdot2^{n-f_{1,i}-f_{2,i}+1} [f_{1,i}+f_{2,i}-1=mx] $$


用树状数组简单维护即可，时间复杂度 $O(n\log_2n)$。

## 三
---
```cpp

inline void add(int x,int k,int mx){
	while(x<=n){
		if(t[x]<mx) t[x]=mx,g[x]=k;
		else if(t[x]==mx) g[x]=(g[x]+k)%mod;
		x+=x&-x;
	}
	return ;
}

inline pair <int,int> ask(int x){
	int mx=0,s=0;
	while(x){
		if(t[x]>mx) mx=t[x],s=g[x];
		else if(t[x]==mx) s=(s+g[x])%mod;
		x^=x&-x;
	}
	return make_pair(mx,s);
}

int main(){
	in(n);
	for(int i=1;i<=n;i++) in(a[i]),b[i]=a[i];
	sort(b+1,b+1+n);
	m=unique(b+1,b+1+n)-b-1;
	for(int i=1;i<=n;i++) a[i]=lower_bound(b+1,b+1+m,a[i])-b;
	for(int i=n;i>=1;i--){
		pair <int,int> tmp=ask(a[i]-1);
		f1[i]=tmp.first+1;
		g1[i]=tmp.second+(f1[i]==1?1:0);
		add(a[i],g1[i],f1[i]);
	}
	memset(t,0,sizeof(t));
	memset(g,0,sizeof(g));
	for(int i=n;i>=1;i--){
		pair <int,int> tmp=ask(n-a[i]);
		f2[i]=tmp.first+1;
		g2[i]=tmp.second+(f2[i]==1?1:0);
		add(n-a[i]+1,g2[i],f2[i]);
	}
	int mx=0;
	for(int i=1;i<=n;i++)
		mx=max(mx,f1[i]+f2[i]-1);
	printf("%d ",mx);
	ll ans=0,er=1;
	for(int i=1;i<=n-mx;i++) er=er*2%mod;
	for(int i=1;i<=n;i++)
		if(f1[i]+f2[i]-1==mx) ans=(ans+1ll*g1[i]*g2[i]%mod*er%mod)%mod;
	printf("%lld\n",ans);

	return 0;
}

```

---

## 作者：fush (赞：1)

我们先钦定 $x$ 在最长的那个子序列中，如果知道怎么统计两个答案，那么最后取 max 即可。

对于第一个答案。  
我们考虑把子序列拆成两部分，$x$ 的左边一部分，右边一部分。     
显然，右边递增，左边递减。我们需要维护以 $x$ 开始的最长上升子序列和最长下降子序列。

接下来是第二个答案。  
我们在维护第一个答案的时候，顺便维护方案数。  
如果转移的时候，长度相等，方案数相加即可。  
对于不在子序列的数，我们不在意它放在左或右，所以最终答案乘上 $2^{n - len}$。
```
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define FL(a,b,c) for(int a=(b),a##end=(c);a<=a##end;++a)
#define FR(a,b,c) for(int a=(b),a##end=(c);a>=a##end;--a)
#define lowbit(x) ((x)&-(x))
#define eb emplace_back
#define int long long
#define vt vector
#define ar(x) array<int,x>
#define PII pair<int, int>
#define max(a, b)({auto b5k5u7=(a);auto tmd67v8=(b);b5k5u7<tmd67v8?tmd67v8:b5k5u7;})
#define cmax(a, b)({auto tmd67v8=(b);(tmd67v8>a)&&(a=tmd67v8);})
#define min(a, b)({auto b5k5u7=(a);auto tmd67v8=(b);b5k5u7>tmd67v8?tmd67v8:b5k5u7;})
#define cmin(a, b)({auto tmd67v8=(b);(tmd67v8<a)&&(a=tmd67v8);})
constexpr int N = 2e5 + 10, mod = 1e9 + 7;
int n, a[N], b[N];
struct BIT{
	PII w[N];
	BIT(){FL(i, 1, N - 1)w[i] = {0, 1};}
	void g(PII&x, PII&y){
		if(y.first > x.first)x.first = y.first, x.second = 0;
		if(y.first == x.first)(x.second += y.second) %= mod;
	}
	void add(int x, PII&y){for(; x < N; x += lowbit(x))g(w[x], y);}
	void query(int x, PII&ans){
		for(; x; x -= lowbit(x))g(ans, w[x]);
		if(!ans.first)ans.second = 1;
	};
}c1, c2;
PII dp1[N], dp2[N];
int qpow(int a, int b = mod - 2, int ans = 1){
	for(;b;(a *= a) %= mod, b >>= 1)if(b & 1)(ans *= a) %= mod;
	return ans;
}
int32_t main(){
	cin.tie(0)->sync_with_stdio(0);
	cin >> n;
	FL(i, 1, n)cin >> a[i], b[i] = a[i];
	int m = (sort(b + 1, b + 1 + n), unique(b + 1, b + 1 + n) - b - 1);
	FL(i, 1, n)a[i] = lower_bound(b + 1, b + 1 + m, a[i]) - b;
	FR(i, n, 1){
		c1.query(m - a[i], dp1[i]), c2.query(a[i] - 1, dp2[i]);
		dp1[i].first++, dp2[i].first++;
		c1.add(m + 1 - a[i], dp1[i]), c2.add(a[i], dp2[i]);
	}
	int len = 0, ans = 0;
	FL(i, 1, n){
		int l = dp1[i].first + dp2[i].first - 1;
		if(l > len)len = l, ans = 0;
		if(len == l)(ans += dp1[i].second * dp2[i].second % mod) %= mod;
	}
	cout << len << " " << qpow(2, n - len, ans) << endl;
	return 0;
}
```

---

## 作者：CQ_Bob (赞：1)

题解摘自 [CSP2024 前做题情况](https://www.luogu.com.cn/article/9zpicw3e)。

## 分析

考虑 DP。

不难发现，原题的操作相当于将序列剖成两个子序列，将其中一个翻转后将第二个拼在它后面。考虑枚举第一个在 $1$ 右边，且在最终的 LIS 上面的点 $i$。不难发现，$i$ 往后相当于是 $i$ 开头的一个最长上升子序列，$i$ 往前相当于是 $i$ 开头的一个最长下降子序列。直观的感受到，这两个子序列的交只有 $i$ 这个点。所以最终的最长上升子序列仅存在于 $i$ 开头的最长上升子序列与最长下降子序列拼起来的子序列中。

那么久很容易了。令 $f_i$ 表示 $i$ 往后的最长上升子序列长度，$fcnt_i$ 表示 $i$ 往后最长上升子序列数量；$g_i$ 和 $gcnt_i$ 同理。那么就有：$M=\max\limits_{i=1}^{n} (f_i+g_i-1)$。

现在考虑如何求方案数。对于一个 $i$，它存在于最终的最长上升子序列中当且仅当 $f_i+g_i-1=M$。那么此时这 $M$ 个数选出来的方案数即为 $fcnt_i \times gcnt_i$。然后剩下的点放左边、右边随便选，$1$ 这个点可以看作放在了空点的左边或者右边，所以总的方案数为：$\sum\limits_{i=1}^{n}fcnt_i\times gcnt_i\times 2^{n-M}[f_i+g_i-1=M]$。时间复杂度为 $O(n\log n)$。

## 代码

```cpp
il void add1(int x,int y,int z){
	while(x>=1){
		if(tr1[x]<=y){
			if(tr1[x]==y) tr2[x]=(tr2[x]+z)%p;
			else tr1[x]=y,tr2[x]=z;
		}
		x-=x&(-x);
	}
	return ;
}
il void add2(int x,int y,int z){
	while(x<=len){
		if(tr3[x]<=y){
			if(tr3[x]==y) tr4[x]=(tr4[x]+z)%p;
			else tr3[x]=y,tr4[x]=z;
		}
		x+=x&(-x);
	}
	return ;
}
il pii query1(int x){
	pii ans={0,0};
	while(x<=len){
		if(ans.x<tr1[x]) ans.x=tr1[x],ans.y=tr2[x];
		else if(ans.x==tr1[x]) ans.y=(ans.y+tr2[x])%p;
		x+=x&(-x);
	}
	return ans;
}
il pii query2(int x){
	pii ans={0,0};
	while(x>=1){
		if(ans.x<tr3[x]) ans.x=tr3[x],ans.y=tr4[x];
		else if(ans.x==tr3[x]) ans.y=(ans.y+tr4[x])%p;
		x-=x&(-x);
	}
	return ans;
}

il void solve(){
	n=rd;int M=0,ans=0;
	for(re int i=1;i<=n;++i) a[i]=rd,b[++len]=a[i];
	sort(b+1,b+len+1),len=unique(b+1,b+len+1)-(b+1);
	for(re int i=1;i<=n;++i) a[i]=lower_bound(b+1,b+len+1,a[i])-b;
	for(re int i=n;i>=1;--i){
		pii x=query1(a[i]+1);
		f[i]=x.x+1;
		cnt_f[i]=x.y+(f[i]==1);
		pii y=query2(a[i]-1);
		g[i]=y.x+1;
		cnt_g[i]=y.y+(g[i]==1);
		add1(a[i],f[i],cnt_f[i]);
		add2(a[i],g[i],cnt_g[i]);	
		M=max(M,f[i]+g[i]-1);	
		cnt_f[i]%=p,cnt_g[i]%=p;
	}
	for(re int i=1;i<=n;++i)
	if(f[i]+g[i]-1==M){
		ans=(ans+cnt_f[i]*cnt_g[i]%p)%p;
	}
	printf("%lld %lld\n",M,ans*qmi(2,n-M,p)%p);
	return ;
}
```

---

## 作者：lyas145 (赞：0)

本题解摘自我的[这篇博客](https://www.cnblogs.com/lyas145/p/18701971)。

[原题链接](https://www.luogu.com.cn/problem/P6885)。

可以发现：在组成的新序列中，一个数 $x$ 左边的**所有的数在原序列所对应的顺序相反**、右边的**所有的数在原序列所对应的顺序相同**。

举个例子：

```
原序列：1 2 3 4 5 6
        ^ - + - + +
新序列：6 5 3 1 2 4
        + + + ^ - -
```

在新序列中，我们以 $1$ 为中心（下面标有 `^` 的数），她左边的数下标 `+`、右边的数下标 `-`。

再整理一下就是：

```cpp
在新序列中 1 的左边的数。
原序列：3 5 6
新序列：6 5 3

在新序列中 1 的右边的数。
原序列：2 4
新序列：2 4
```

这下懂了吧？

But，这有什么用呢？

这玩意用处老大了！

在新序列中，我们把 $x$ 作为中心，那么组成这个新序列的**最长严格上升子序列**就会被**分成两半**：$x$ 左边一半，$x$ 右边一半，可能 $x$ 也会在最长严格上升子序列中。左边那一半对应原序列是一个**严格下降子序列**，右边那一半对应原序列是一个**严格上升子序列**。

举个例子（在新序列中以 $5$ 为中心）。

```cpp
原序列：5 6 3 1 4 2 7
        ^ - + +     -
新序列：4 1 3 5 6 2 7
          + + ^ -   -

新序列的最长严格上升子序列：1 3 5 6 7
5 左边一半：
原序列：3 1
新序列：1 3
5 右边一半：
原序列：6 7
新序列：6 7
```

你可能会想：能不能在原序列求个严格下降子序列和严格上升子序列，然后把她们拼成一个新序列中的最长严格上升子序列？

不错，这和正解已经很近了。

但是你一定会发现：如果她们有重复的元素怎么办？并且合并似乎也不太好搞。

把刚才上面的新序列中最长严格上升子序列拿来研究研究。

```cpp
1 3 5 6 7
+ + ^ - -
```

唉？**$5$ 左边一半**的最长严格上升子序列**最大**的数**严格小于 $5$ 右边一半**的最长严格上升子序列**最小**的数。对应到原序列就是：我们得到的严格下降子序列**最大的数严格小于**我们得到的严格上升子序列**最小的数**。

但怎么用这个性质？

$5$（代表新序列最长严格上升子序列的中心）：你是不是忘了谁？~~《不为谁而作的歌》~~

那么对于一个新序列中最长严格上升子序列的中心 $x$，以她为起点向外扩展的最长严格下降子序列和最长严格上升子序列是**一定没有重复元素的**（除了 $x$，不过这个好处理）。

注意一下 dp 肯定是在原序列上跑的。

所以，对于原序列中的每个数 $x$，把她**强制**作为新序列中最长严格上升子序列的**中心**，令 $f_{i,0}$、$cnt_{i,0}$ 分别表示以 $i$ 为结尾的最长严格上升子序列长度以及方案数，再令 $f_{i,1}$、$cnt_{i,1}$ 分别表示以 $i$ 为结尾的最长严格下降子序列以及方案数，那么在所有可能的新序列中**最长严格上升子序列的长度 $M$ 就是 $f_{i,0}+f_{i,1}-1$**，减 $1$ 是因为 $x$ 是她们**唯一一个重复的数**。

于是最长一个上升子序列的长度我们就求出来了！

接下来是处理最长严格上升子序列长度是 $M$ 的 $B$ 序列的个数。先讨论有多少个新序列能够有同一个固定的最长严格上升子序列。由于组成最长严格上升子序列的数的放左或放右都已经定好了，所以她们对答案没什么影响，但是其他不组成这个最长严格上升子序列的数就不一样了，她们放左或放右都行，所以**有 $2^{N-M}$ 个新序列能够有同一个固定的最长严格上升子序列**。不过最长严格上升子序列可能**不止一个**，其**个数为 $\sum\limits_{i=1}^n cnt_{i,0} \times cnt_{i,1}[f_{i,0}+f_{i,1}-1=M]$**，答案就是她们俩的**积**，即

$$2^{N-M} \times \sum\limits_{i=1}^n cnt_{i,0}\times cnt_{i,1}[f_{i,0}+f_{i,1}-1=M]$$

注意代码中的一些处理细节。

码儿：  
```cpp
#include<bits/stdc++.h>
#define f first
#define s second
using namespace std;
typedef pair<int,int> PII;
const int N=2e5+5,P=1e9+7;
int n,m,len,ans;
int a[N],b[N],f[N][2],cnt[N][2];
struct TreeArray{            //这是树状数组，用来进行 dp。
	PII c[N];
	int lowbit(int x) {return x&-x;}
	void add(int x,int p,int s) {
		for (int i=x;i<=m;i+=lowbit(i)) {
			if (p>c[i].f) {c[i]={p,s};}
			else if (p==c[i].f) {(c[i].s+=s)%=P;}
		}
	}
	PII query(int x) {
		PII res={0,0};
		for (int i=x;i;i-=lowbit(i)) {
			if (res.f<c[i].f) {res=c[i];}
			else if (res.f==c[i].f) {(res.s+=c[i].s)%=P;}
		}
		res.s=max(res.s,1);  //注意个数最少是 1，不可能没有。
		return res;
	}
}c0,c1;
inline int read() {          //快读，没啥好看的。
	int x=0,f=1;
	char c=getchar();
	while (!isdigit(c)) {f=(c=='-'?-1:1);c=getchar();}
	while (isdigit(c)) {x=(x<<3)+(x<<1)+(c^48);c=getchar();}
	return x*f;
}
int main() {
	n=read();
	for (int i=n;i;i--) {a[i]=b[i]=read();}
	sort(b+1,b+1+n);
	m=unique(b+1,b+1+n)-b-1;
	for (int i=1;i<=n;i++) {           //离散化。
		a[i]=lower_bound(b+1,b+1+m,a[i])-b;
	}
/*----------------------一整个程序的精华----------------------*/
	for (int i=1;i<=n;i++) {           //dp 部分。
		PII t0=c0.query(a[i]-1);
		PII t1=c1.query(m-a[i]);
		f[i][0]=t0.f+1;cnt[i][0]=t0.s;
		f[i][1]=t1.f+1;cnt[i][1]=t1.s;
		c0.add(a[i],f[i][0],cnt[i][0]);
		c1.add(m-a[i]+1,f[i][1],cnt[i][1]);
	}
	for (int i=1;i<=n;i++) {           //求个数。
		int L=f[i][0]+f[i][1]-1;
		if (L>len) {len=L;ans=1ll*cnt[i][0]*cnt[i][1]%P;}
		else if (L==len) {ans=(ans+1ll*cnt[i][0]*cnt[i][1]%P)%P;}
	}
	for (int i=1;i<=n-len;i++) {ans=2ll*ans%P;}
/*--------------------------------------------------------*/
	printf("%d %d\n",len,ans);
	return 0;
}
```

Thanks for reading！

---

## 作者：CQ_JiJi (赞：0)

# 思路
模拟赛时场除 $2$ 没写逆元挂了，之后发现和题解都不一样，所以来提供一种简单的方法。

考虑到题目要求是**严格**上升子序列，所以如果前面取了一个数 $x$，后面的 $x$ 一定都不能取。转换下题意，每次操作同时将 $i$ 插入队列的左边与右边，这时候你会发现，当你取了 $[1,n]$ 的数（也就是插在前面的那部分）的一个时，后面与之对应的数必然取不到，反之亦然。所以此时直接跑最长上升子序列就能得到第一问的答案。

接着你会发现，如果在求最长上升子序列时让树状数组同时维护最大值的个数，那么最后的答案应该是 $ans2\times 2^{k-ans1}$ 次的，因为不属于最长上升子序列的 $k-ans1$ 个数随便放左边还是右边都合法。

但这样仍会出现一个问题，按题意来说，$1$ 号元素是不进行插入的，所以理应只有一个，但这样就会出现最长上升子序列包含，与不包含 $1$ 号元素两种情况。因为不包含 $1$ 时，$1$ 应该多除 $2$（$1$ 是固定的改不了）。所以考虑将 $1$ 也复制一遍（注意不是前后都插入），这样做的好处是不管包不包含 $1$ 你都应该多除一个 $2$。原因为：
1. 包含时，会在计算最长上升子序列时多算一倍。
2. 不包含时，会在计算可以随便左右放的时候多算一倍。

树状数组维护最长上升子序列没什么难度，就不再过多赘述。

```cpp
/*
	Luogu name: Symbolize
	Luogu uid: 672793
*/
#include<bits/stdc++.h>
#define int long long
#define pii pair<int,int>
#define x first
#define y second
#define rep1(i,l,r) for(register int i=l;i<=r;++i)
#define rep2(i,l,r) for(register int i=l;i>=r;--i)
#define rep3(i,x,y,z) for(register int i=x[y];~i;i=z[i])
#define rep4(i,x) for(auto i:x)
#define debug() puts("----------")
const int N=4e5+10;
const int inf=0x3f3f3f3f3f3f3f3f;
const int mod=1e9+7;
using namespace std;
int n,h[N],b[N],a[N];
pii tr[N],f[N],ans;
deque<int> q;
int read()
{
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return f*x;
}
int power(int a,int b,int p)
{
	int ans=1;
	while(b)
	{
		if(b&1) ans=ans*a%p;
		a=a*a%p;
		b>>=1;
	}
	return ans;
}
int lowbit(int x){return x&-x;}
void add(int x,pii k)
{
	while(x<=2*n)
	{
		if(tr[x].x<k.x) tr[x]=k;
		else if(tr[x].x==k.x) tr[x].y=(tr[x].y+k.y)%mod;
		x+=lowbit(x);
	}
	return;
}
pii query(int x)
{
	pii ans=make_pair(0,0);
	while(x)
	{
		if(ans.x<tr[x].x) ans=tr[x];
		else if(ans.x==tr[x].x) ans.y=(ans.y+tr[x].y)%mod;
		x-=lowbit(x);
	}
	return ans;
}
signed main()
{
//	freopen("queue.in","r",stdin);
//	freopen("queue.out","w",stdout);
	n=read();
	rep1(i,1,n) b[i]=h[i]=read();
	sort(b+1,b+n+1);
	int idx=unique(b+1,b+n+1)-b-1;
	rep1(i,1,n) h[i]=lower_bound(b+1,b+n+1,h[i])-b;
	rep1(i,1,n) a[n-i+1]=a[n+i]=h[i];
	rep1(i,1,2*n)
	{
		f[i]=query(a[i]-1);
		f[i].x=(f[i].x+1)%mod;
		if(f[i].x==1) f[i].y=1;
		add(a[i],f[i]);
//		cout<<a[i]<<' '<<f[i].x<<' '<<f[i].y<<endl;
	}
	rep1(i,1,2*n)
	{
		if(ans.x<f[i].x) ans=f[i];
		else if(ans.x==f[i].x) ans.y=(ans.y+f[i].y)%mod;
	}
	cout<<ans.x<<' '<<ans.y*power(2,mod-2,mod)%mod*power(2,n-ans.x,mod)%mod<<"\n";
	return 0;
}

```

---

## 作者：Dtw_ (赞：0)

# Solution
考虑最终的最长上升子序列在原序列的位置。

可以考虑枚举答案序列中的数在原序列出现的最早位置。

那这样答案序列就成了在原序列中以一个数开头的最长上升子序列，以及以这个数开头的最长下降子序列。但是要考虑方案数，我们发现如果长度一样那么将答案数相加，否则拿最大的长度的方案数去更新。我们可以倒着枚举，这样就可以处理出子序列长度，但这样还是 $O(n^2)$ 的，所以考虑优化。

怎么优化呢？发现 DP 的时候有区间取最大值，容易想到用权值线段树维护，但是值域很大，所以要离散化。

# Code
细节看代码。

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n' 

#define int long long

#define fi first
#define se second

#define pii pair<int, int>

#define fst ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);

const int INF = 0x3f3f3f3f3f3f3f3f;

const int P = 1e9 + 7;

const int N = 2e5 + 10;

int n, a[N], b[N], f[N], g[N], fcnt[N], gcnt[N];

struct Node
{
   int len, cnt;
};

void push_up(Node &x, Node &y, Node &z)
{
    if(z.len == y.len)
    {
        x.len = y.len;
        x.cnt = y.cnt + z.cnt;
        x.cnt %= P;
    }
    else if(y.len > z.len) x = y;
    else x = z;
}

// 板子

struct SEG_T
{
    Node tr[N<<2];
    
    #define lson (rt << 1)
    #define rson (rt << 1 | 1)
    #define mid (l + r) / 2

    void build(int rt, int l, int r)
    {
        if(l == r)
        {
            tr[rt] = {0, 0};
            return;
        }
        build(lson, l, mid), build(rson, mid + 1, r);
        push_up(tr[rt], tr[lson], tr[rson]);
    }

    void update(int rt, int l, int r, int p, int v, int w)
    {
        if(l == r)
        {
        	Node o = {v, w};
            push_up(tr[rt], tr[rt], o);
            return;
        }
        if(p <= mid) update(lson, l, mid, p, v, w);
        else update(rson, mid + 1, r, p, v, w);
        push_up(tr[rt], tr[lson], tr[rson]);
    }

    Node query(int rt, int l, int r, int sp, int ep)
    {
        if(sp <= l && r <= ep) return tr[rt];
        if(sp > mid) return query(rson, mid + 1, r, sp, ep);
        if(ep <= mid) return query(lson, l, mid, sp, ep);
        auto L = query(lson, l, mid, sp, ep), R = query(rson, mid + 1, r, sp, ep);
        Node res;
        push_up(res, L, R);
        return res;
    }
}T[2];

inline int fpm(int a, int n)
{
    int res = 1;
    while(n)
    {
        if(n & 1) res = res * a % P;
        a = a * a % P;
        n /= 2;
    }
    return res;
}

signed main()
{
    freopen("c.in", "r", stdin);
    freopen("c.out", "w", stdout);
    fst
    cin >> n;
    for(int i=1; i<=n; i++)
    {
        cin >> a[i];
        b[i] = a[i];
    }
    // 离散化
    sort(b+1, b+n+1);
    int len = unique(b+1, b+n+1) - b - 1;
    for(int i=1; i<=n; i++)
        a[i] = lower_bound(b+1, b+len+1, a[i]) - b;
    int maxn = 0;
    // 初始化
    // T[0] 维护上升
    // T[1] 维护下降
    T[0].build(1, 0, len+1);
    T[1].build(1, 0, len+1);
    // 初始化边界，因为一开始一个都不选方案数肯定为 1
    T[0].update(1, 0, len+1, len+1, 0, 1);
    T[1].update(1, 0, len+1, 0, 0, 1);
    Node ans = {0, 1};
    for(int i=n; i>=1; i--) // 倒序枚举
    {
        auto x = T[0].query(1, 0, len+1, a[i]+1, len+1); // 从比我大的里选
        f[i] = x.len + 1; // 大的长度 + 我这一位
        fcnt[i] = x.cnt;
        auto y = T[1].query(1, 0, len+1, 0, a[i]-1); // 从比我小的里选
        g[i] = y.len + 1;
        gcnt[i] = y.cnt;
        Node o = {f[i] + g[i] - 1, fcnt[i] * gcnt[i] % P};
        push_up(ans, ans, o); // 更新 ans
        // 修改
        T[0].update(1, 0, len+1, a[i], f[i], fcnt[i]);
    	T[1].update(1, 0, len+1, a[i], g[i], gcnt[i]);
	}
    cout << ans.len << " " << ans.cnt * fpm(2, n - ans.len) % P;
    return 0;
}
```

---

## 作者：dAniel_lele (赞：0)

考虑从后往前维护以每个数为开头的最长上升和下降子序列的长度与数量。

对于每个位置，设它为中间的，于是找到的最长上升子序列应当放在右边，最长下降子序列应当放在左边，这样就可以得到长度与方案数。

记录 $\max$ 和 $ans$ 动态更新即可。最后输出的时候子序列外的都是可以随意放左/右，故答案为 $ans\times2^{n-\max}$。总复杂度 $O(n\log n)$。

```cpp
#include <bits/stdc++.h>
#define int long long
#define double long double
#define mid ((l+r)>>1)
using namespace std;
const int mod=1e9+7;
int qp(int a,int b){
	int ans=1;
	while(b){
		if(b&1) (ans*=a)%=mod;
		(a*=a)%=mod;
		b>>=1;
	}
	return ans;
}
vector<int> vc1,vc2;
struct node{
	int maxv,num;
};
node merge(node x,node y){
	node ans; ans.maxv=max(x.maxv,y.maxv),ans.num=0;
	if(x.maxv==max(x.maxv,y.maxv)) (ans.num+=x.num)%=mod;
	if(y.maxv==max(x.maxv,y.maxv)) (ans.num+=y.num)%=mod;
	return ans;
}
struct sgt{
	node f[1000005];
	void build(int i,int l,int r){
		if(l==r){
			f[i].maxv=f[i].num=0;
			return ;
		}
		build(i*2,l,mid),build(i*2+1,mid+1,r);
		f[i]=merge(f[i*2],f[i*2+1]);
	}
	void change(int i,int l,int r,int pos,node v){
		if(l==r){
			f[i]=merge(f[i],v);
			return ;
		}
		if(pos<=mid) change(i*2,l,mid,pos,v);
		else change(i*2+1,mid+1,r,pos,v);
		f[i]=merge(f[i*2],f[i*2+1]);
	}
	node qry(int i,int l,int r,int ql,int qr){
		if(ql<=l&&r<=qr) return f[i];
		if(qr<=mid) return qry(i*2,l,mid,ql,qr);
		if(ql>mid) return qry(i*2+1,mid+1,r,ql,qr);
		return merge(qry(i*2,l,mid,ql,qr),qry(i*2+1,mid+1,r,ql,qr));
	}
}tree1,tree2;
signed main(){
	int n; cin>>n;
	int a[n+1],b[n+1]; for(int i=1;i<=n;i++) cin>>a[i],b[i]=a[i];
	sort(b+1,b+n+1); int m=unique(b+1,b+n+1)-b-1;
	for(int i=1;i<=n;i++) a[i]=lower_bound(b+1,b+m+1,a[i])-b;
	node bef,ans; bef.maxv=ans.maxv=ans.num=0,bef.num=1;
	tree1.build(1,0,m+1),tree2.build(1,0,m+1);
	tree1.change(1,0,m+1,m+1,bef);
	tree2.change(1,0,m+1,0,bef);
	for(int i=n;i>=1;i--){
		node p,p1=tree1.qry(1,0,m+1,a[i]+1,m+1),p2=tree2.qry(1,0,m+1,0,a[i]-1);
		p.maxv=p1.maxv+p2.maxv+1;
		p.num=p1.num*p2.num%mod;
		ans=merge(ans,p);
		p=tree1.qry(1,0,m+1,a[i]+1,m+1);
		p.maxv++;
		tree1.change(1,0,m+1,a[i],p);
		p=tree2.qry(1,0,m+1,0,a[i]-1);
		p.maxv++;
		tree2.change(1,0,m+1,a[i],p);
	}
	cout<<ans.maxv<<" "<<ans.num*qp(2,n-ans.maxv)%mod;
	return 0;
}

```

---

## 作者：lidundun (赞：0)

# 前情提要
本题解由[https://hsin.hr/coci/archive/2016_2017/](https://hsin.hr/coci/archive/2016_2017/)
以及[https://fanyi.baidu.com/](https://fanyi.baidu.com/)
赞助发布。
# Zoltan
为了确定这种最长严格递增子序列的长度，我们必须针对初始序列中的每个位置 $x$ ，确定从 $x$ 右侧位置开始到 $x$ 位置结束的最长严格递减子序列（序列从右向左读取）的长度，以及实现该最大值的方法的数量。同样的思想适用于最长的严格递减子序列。我们可以用一种相对简单的方式来实现这一点，使用时间复杂度为 $\mathcal O(n\log n)$ 的 Fenwick 树数据结构。

我们可以注意到，解是严格递增和严格递减子序列的并集，使得严格递增子序列的最大元素小于严格递减子顺序的最小元素。如果 $a$ 是在位置 $x$ （包括位置 $x$ ）结束的最长严格递增子序列的长度，并且 $b$ 对于严格递减子序列是相同的，并且如果 $num_a$ 、 $num_b$ 分别是获得它们的方法的数量，则 $x$ （包括位置 $x$ ）右侧的数字的最大长度是 $a+b-1$ ，并且获得该解的方法的数量是 $num_ a\times num_b$ 。

所需的最大长度是每个位置所述最大长度的最大值。我们用 $r$ 表示这个数。然后，我们可以实现这个长度的路径数是所有位置的路径数的乘积，其中最大长度等于 $r\times (2n-r)$ 。

因子 $2n-r$ 是必要的，因为如果解由 $r$ 个数组成，则剩余的 $n-r$ 个数中的每一个都可以独立地放置在所有数之前或之后。
# AC代码
```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;

#define TRACE(x) cout << #x << " = " << x << endl;

typedef long long int llint;

typedef pair<int, int> par;

#define X first
#define Y second

const int MAXN = 500010, MOD = 1000000007;

inline int add(int a, int b)
{
  int ret = a + b;
  if(ret >= MOD) ret -= MOD;
  return ret;
}

inline int mul(int a, int b)
{
  llint ret = (llint)a * b;
  if(ret >= MOD) ret %= MOD;
  return ret;
}

int n;
int niz[MAXN], dva[MAXN];

par A[MAXN], B[MAXN];
par FWT_gore[MAXN], FWT_dolje[MAXN];

par rj;

par spoji(par a, par b)
{
 if(b.X > a.X)
 {
   a.X = b.X;
   a.Y = b.Y;
 } 
 else if(b.X == a.X)
   a.Y = add(a.Y, b.Y);
 return a;
}

void ubaci_gore(int x, par v)
{
  x += 5;
  for(; x < MAXN; x += x & -x)
    FWT_gore[x] = spoji(FWT_gore[x], v);
}

par upit_gore(int x)
{
  x += 5;
  par ret(0, 0);
  for(; x > 0; x -= x & -x)
    ret = spoji(ret, FWT_gore[x]);
  return ret;
}

void ubaci_dolje(int x, par v)
{
  x += 5;
  for(; x > 0; x -= x & -x)
    FWT_dolje[x] = spoji(FWT_dolje[x], v);
}

par upit_dolje(int x)
{
  x += 5;
  par ret(0, 0);
  for(; x < MAXN; x += x & -x)
    ret = spoji(ret, FWT_dolje[x]);
  return ret;
}

void sazmi()
{
  vector<int> v;
  for(int i = 0; i < n; i++)
    v.push_back(niz[i]);
  sort(v.begin(), v.end());
  v.resize(unique(v.begin(), v.end()) - v.begin());
  for(int i = 0; i < n; i++)
    niz[i] = lower_bound(v.begin(), v.end(), niz[i]) - v.begin();
}

void sredi_gore()
{
  for(int i = n - 1; i >= 0; i--)
  {
    par p = upit_gore(niz[i] - 1);
    if(p.X == 0)
    {
      A[i] = par(0, 1);
      ubaci_gore(niz[i], par(1, 1));
    }
    else 
    {
      A[i] = p;
      p.X++;
      ubaci_gore(niz[i], p);
    }
  }
}

void sredi_dolje()
{
  for(int i = n - 1; i >= 0; i--)
  {
    par p = upit_dolje(niz[i] + 1);
    if(p.X == 0)
    {
      B[i] = par(0, 1);
      ubaci_dolje(niz[i], par(1, 1));
    }
    else
    {
      B[i] = p;
      p.X++;
      ubaci_dolje(niz[i], p);
    }
  }
}

void postavi()
{
  dva[0] = 1;
  for(int i = 1; i < MAXN; i++)
    dva[i] = mul(dva[i - 1], 2);
}

void glavno()
{
  for(int i = 0; i < n; i++)
    rj = spoji(rj, par(A[i].X + 1 + B[i].X, mul(A[i].Y, B[i].Y)));
  rj.Y = mul(rj.Y, dva[n - rj.X]);
}

int main()
{
  postavi();
  scanf("%d", &n);
  for(int i = 0; i < n; i++)
    scanf("%d", &niz[i]);
  sazmi();
  sredi_gore();
  sredi_dolje();
  glavno();
  printf("%d %d\n", rj.X, rj.Y);
  return 0;
}
```


---


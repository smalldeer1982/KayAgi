# [NOI1998] 免费的馅饼

## 题目描述

SERKOI 最新推出了一种叫做“免费馅饼”的游戏：游戏在一个舞台上进行。舞台的宽度为 $w$ 格（从左到右依次用 $1$ 到 $w$ 编号），游戏者占一格。开始时游戏者可以站在舞台的任意位置，手里拿着一个托盘。下图为天幕的高度为 $4$ 格时某一个时刻游戏者接馅饼的情景。

![](https://cdn.luogu.com.cn/upload/image_hosting/1gcg9awi.png)

游戏开始后，从舞台天幕顶端的格子中不断出现馅饼并垂直下落。游戏者左右移动去接馅饼。游戏者每秒可以向左或向右移动一格或两格，也可以站在原地不动。

当馅饼在某一时刻恰好到达游戏者所在的格子中，游戏者就收集到了这块馅饼。当馅饼落在一个游戏者不在的格子里时该馅饼就消失。

写一个程序，帮助我们的游戏者收集馅饼，使得所收集馅饼的分数之和最大。

## 说明/提示

对于 $100\%$ 的数据，$1 \leq w \leq 10^8$，$1 \leq n \leq 10^5$，$1\leq t_i \leq 10^8$，$1\leq p_i \leq w$，$1\leq v_i \leq 1000$。

## 样例 #1

### 输入

```
3 4
1 2 3
5 2 3
6 3 4
1 1 5
 ```

### 输出

```
12```

# 题解

## 作者：xiezheyuan (赞：21)

## 思路

免费的馅饼，~~免费的陷阱~~。

### 1.贪心做法

先对原数据排序（优先时间从小到大，然后是价值从大到小）。然后跑贪心。先选第一个，然后如果时间足够移动就移动。

时间复杂度是 $O(n\log n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;

struct Pie{
	int t,p,v;	
} a[100005],last;
int w,n,ans;

bool cmp(Pie x,Pie y){
	if(x.t==y.t){
		return x.v>y.v;
	}
	else{
		return x.t<y.t;
	}
}

int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>w>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i].t>>a[i].p>>a[i].v;
	}
	sort(a+1,a+n+1,cmp);
	last=a[1];
	ans=a[1].v;
	for(int i=2;i<=n;i++){
		if(2*(a[i].t-last.t)>=abs(a[i].p-last.p)){
			ans+=a[i].v;
			last=a[i];
		}
	}
	cout<<ans<<endl;
	return 0;
}
```

可以水 $50$ 分。

为什么不是满分，因为本题贪心没有最优解。

### 2.暴力DP

不难推出，如果设 $f[i]$ 为接住 第 $i$ 个节点，那么枚举 $j \in [1,i)$。

方程为:

$$f[i]=\max \{f[i],f[j]+v_i\}$$


当然，如果要接得到，需要满足 ：

$$2 \times (t[i]-t[j]) \ge |\ p[i]-p[j]\ |$$

最后的答案就是 ：

$$\max \nolimits_{i=1}^{n}\{f[i]\}$$


当然，边界条件为

$$\forall i,f[i]=v[i]$$

时间复杂度是 $O(n^2)$。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

int f[100005];
int w,n,ans;

struct pie{
	int t,p,v;
	bool operator<(const pie nth) const {
		return t<nth.t;
	}
} pies[100005];

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
	cin>>w>>n;
	for(int i=1;i<=n;i++){
		cin>>pies[i].t>>pies[i].p>>pies[i].v;
	}
	sort(pies+1,pies+n+1);
	f[1]=pies[1].v;
	for(int i=1;i<=n;i++){
	    f[i]=pies[i].v;
		for(int j=1;j<i;j++){
			if(2*(pies[i].t-pies[j].t)>=abs(pies[i].p-pies[j].p)){
				f[i]=max(f[i],f[j]+pies[i].v);
			}
		}
	}
	for(int i=1;i<=n;i++){
		ans=max(f[i],ans);
	}
	cout<<ans<<endl;
	return 0;
}
```

可以水 $85$ 分。

（开O2 就 $90$ 分了）。

### 3.树状数组优化DP（正解）

可以考虑对DP方程的条件进行整理，可以得出:

$p[i]+2 \times t[i] \le p[j]+2 \times t[j] \text{ when }(p[i]-p[j]) \ge 0$。


$p[i]-2 \times t[i] \le p[j]+2 \times t[j] \text{ when }(p[i]-p[j]) \lt 0$。

然后只需要对 $p[i]-2\times t[i]$ 排序，按 $p[i]+2\times t[i]$ 离散化 为 $x[i]$ 。然后建一个维护最大值的树状数组，每次 $f[i]$ 的更新只需要是 $f[i]=\max_{i=1}^{x[i]}+a[i].v$ ，更新 $x[i]$ 为 $f[i]$ ，然后就统计答案。

时间复杂度为 $O(n\log n)$。


~~老师的做法，我也是半知半懂~~


代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

struct pies {
	int t, p, v, x;
} a[100010];

int tmp[100010], f[100010], n,w;
int tree[100010];


bool cmp(pies a, pies b) {
	return a.p - 2 * a.t >= b.p - 2 * b.t;
}

int lowbit(int x) {
	return x & -x;
}

void update(int x, int a) {
	for (int i = x ; i <= n ; i += lowbit(i)) {
		tree[i] = max(tree[i], a);
	}
}

int query(int x) {
	int ans = 0;
	for (int i = x ; i ; i = i - lowbit(i)) {
		ans = max(ans, tree[i]);
	}
	return ans;
}

int ans = 0;

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>w>>n;
	for (int i = 1 ; i <= n ; i ++ ) {
		cin >> a[i].t >> a[i].p >> a[i].v;
		tmp[i] = a[i].p + 2 * a[i].t;
	}
	sort(tmp + 1, tmp + n + 1);
	for (int i = 1 ; i <= n ; i ++ ) {
		a[i].x = lower_bound(tmp + 1, tmp + n + 1, a[i].p + 2 * a[i].t) - tmp;
	}
	sort(a + 1, a + n + 1, cmp);
	for (int i = 1 ; i <= n ; i ++ ) {
		f[i] = query(a[i].x) + a[i].v;
		update(a[i].x, f[i]);
		ans = max(ans, f[i]);
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：SSL_TJH_蒟蒻 (赞：19)

# 免费馅饼
## 题目大意
有一个直线，在某一个时刻有一个馅饼会出现在一些位置，有它的价值。
一个人一开始可以站在直线的任意地方，然后他每个时刻可以不移动，或向任意一边移动一个单位或两个单位。

要你求这个人最多能拿多少价值的馅饼。

## 思路
我们看到这道题，弄出最普通的 dp。

$f_i$ 为对于前 $i$ 个馅饼，接住了第 $i$ 个的最大贡献。

那就是枚举前面的每个点，还有不枚举，然后首先看能不能从那个点赶到这个点，然后就在可以的里面找最大值，然后加上这个点的贡献，就是 $f_i$ 了。
那我们可以看出这是要馅饼按时间先后顺序排序。
而且看能否赶到，就要满足这个式子：（假设 $i$ 赶到 $j$，分别掉到格子的编号是 $p_i$ 和 $p_j$，掉的时间分别是 $t_i$ 和 $t_j$）
$abs(p_i-p_j)\leq 2\times(t_j-t_i)$

总的来说，就是这个：

$$f_j=\max_{\text{abs}(p_i-p_j)\leq 2\times(t_j-t_i)}\{f_i+v_j\}$$

但是这样会超时，那我们考虑优化看馅饼的先后顺序的地方，看能不能通过这个先后顺序，直接快速地找到满足的点。

那我们考虑把式子化开，因为有绝对值，所有会有两个式子：
$\left\{\begin{matrix}
2\times t_i+p_i\leq 2\times t_j+p_j&(p_i-p_j> 0)\\ 
2\times t_i-p_i\leq 2\times t_j-p_j&(p_i-p_j\leq 0)
\end{matrix}\right.$
那它要分开两种，就很麻烦，我们但其实我们会发现，如果要的那个式子满足了，另一个也会满足。
那我们不妨让这两个式子都要满足。

那我们看怎么快速地找呢？
首先，因为两个式子的左右两边其实分别是 $i,j$ 点的两个值，那我们可以一开始就算出来。
那我们考虑先按一个排好序，然后就只用判断另一个条件就可以了。

但是直接判断还是不行。
那我们考虑用一些数据结构来优化它。
那我们排好序之后，就要判断另一个值的大小关系。那只要大小关系，我们就可以把它离散化，不然值太大，数组装不下。

那离散化之后，怎么看大小呢？
我们想想，从小到大排序之后，意思就是可以从前面走到后面（当然这里是假设第二个条件都满足），那你现在就还要看第二个条件。
那就是当两个值，如果第一个值的位置比第二个值的位置靠前，而且第一个位置的第二个比较的值小于第二个值的第二个比较的值。那就是可以的。
你会发现它就是一个顺序对。

顺序对逆序对的这些玩意儿，自然就是树状数组。
当然，你用线段树也不是不可以，但是毕竟树状数组简单好打嘛。
（记得这个地方的地址是第二个匹配的值，因为树状数组地址其实就是一个匹配大小的东西，那就应该是最大贡献）

不过这个树状数组不是求逆序对个数或顺序对个数，而是在满足条件的地方取最大值。
那我们只要改一下，改成维护最大值即可。

那你就可以找到当你弄 $f_i$ 的时候，最优是从哪里转移过来。
那至于 $f_i$，就是最优还要加上拿到它这个馅饼能有的价值。

至于最后输出什么，就是所有最后结束的地方的最大值。那就是查询 $1\sim num$ 中树状数组的最大值。（$num$ 是离散化之后，有多少个不同的第二个匹配的值）
其实就是看找到最后选了哪里作为结尾使得价值最大。

那就是这样了。
## 代码

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>

using namespace std;

struct pie {
	int t, p, v, l, r, num;
}a[100001], b[100001];
int w, n, c[100001], now;
int tree[100001], re;

void add_num(int now, int addnum) {//树状数组（求最大值）
	for (int i = now; i <= c[0]; i += i & (-i))
		tree[i] = max(tree[i], addnum);
}

int quest(int now) {
	re = 0;
	for (int i = now; i; i -= i & (-i))
		re = max(re, tree[i]);
	return re;
}

bool cmp1(pie x, pie y) {
	return x.l < y.l;
}

bool cmp2(pie x, pie y) {
	return x.r < y.r;
}

int main() {
	scanf("%d %d", &w, &n);
	for (int i = 1; i <= n; i++) {
		scanf("%d %d %d", &a[i].t, &a[i].p, &a[i].v);
		a[i].l = 2 * a[i].t - a[i].p;//算出比较依据
		a[i].r = 2 * a[i].t + a[i].p;
		a[i].num = i;
		
		b[i] = a[i];
	}
	
	sort(b + 1, b + n + 1, cmp2);
	c[1] = ++c[0];
	a[b[1].num].r = c[1];//离散化（对于我们第二个要比较的值）
	for (int i = 2; i <= n; i++) {
		if (b[i].r != b[i - 1].r) ++c[0];
		c[i] = c[0];
		a[b[i].num].r = c[i];
	}
	
	sort(a + 1, a + n + 1, cmp1);//先按第一个要比较的值排序，使枚举过去的时候第一个直接符合
	for (int i = 1; i <= n; i++) {
		now = quest(a[i].r);//比较第二个，找到比第二个比较的值比它更小中能获得的价值最大的
		add_num(a[i].r, now + a[i].v);//捡这个
	}
	
	printf("%d", quest(c[0]));//扫一遍全部，看全部方案中价值最大的
	
	return 0;
}
```


---

## 作者：onglu (赞：12)

这道题是一道带权LIS呢。  

个人题库里有一道这道题的改编题，把每秒可以移动的步数$k$的范围换成了int以内，取消了馅饼的价值（其实加上价值也没事，只不过把LIS改成带权LIS罢了）。  

固定馅饼的纵坐标，转换成每秒人要向上走一格  

考虑假设我们在一个位置，接下来哪些位置可以走得到。  

发现这个区域被两条直线框住，直线的斜率为
$$\frac{1}{k},-\frac{1}{k}$$  

我们可以把坐标系旋转成以$y = \frac{x}{k}$为新的$x$轴，$y = -\frac{x}{k}$为新的$y$轴的坐标系。  

点$(x, y)$旋转后坐标为
$$(\frac{ycos\theta + xsin\theta}{sin2\theta}, \frac{ycos\theta - xsin\theta}{sin2\theta})$$

所以任意合法的吃馅饼的路线上的每个金币的$x,y$轴都是非降的，应用对二维偏序的处理方法，我们可以对$x$坐标进行排序，把$x$坐标转化为数组下标，对于$y$坐标就是一个LIS了，离散化后求$y$坐标的最长上升子序列。  
  
有点遗憾的是这种方法浮点误差会很大，在一些情况下会出现错误，于是就考虑如何防止小数产生。  
  
于是想到，在线性变换下，原坐标系下的点，在新的坐标系下$y$坐标相对大小不发生改变，对于点$(a,b)$我们可以采用$y - b = -\frac{x - a}{k}$在$y$轴上的截距作为他的$y$坐标， $y - b = \frac{x - a}{k}$在$y$轴上的截距作为他的$x$坐标，再把$x,y$同时放大k倍，就可以把坐标转化为整数了。  
  
时间复杂度为$O(nlogn)$。  
  
下面代码是将$k=10^9$的做法弱化后得到的，修改数据即可通过$k=10^9$的题。  


```cpp
#include <bits/stdc++.h>
#define int long long
#define Mid ((l + r) >> 1)
#define lson (rt << 1)
#define rson (rt << 1 | 1)
using namespace std;
int read(){
	char c; int num, f = 1;
	while(c = getchar(),!isdigit(c)) if(c == '-') f = -1; num = c - '0';
	while(c = getchar(), isdigit(c)) num = num * 10 + c - '0';;
	return f * num;
}
const int N = 3e5 + 1009;
struct node{
	int x, y;
}a[N];
int n, k, ans, cnt, sub[N], tree[N];
bool cmp(node a, node b){
	if(a.x == b.x) return a.y < b.y;
	else return a.x < b.x;
}
void modify(int x, int y){
	for( ; x <= n; x += x & -x)
		tree[x] = max(tree[x], y);
}
int query(int x){
	int ans = 0;
	for( ; x; x -= x & -x)
		ans = max(ans, tree[x]);
	return ans;
}
main()
{
	n = read(); k = read();
	for(int i = 1; i <= n; i++){
		int x = read(), y = read();
		a[i].y = y * k + x;
		a[i].x = y * k - x;
		sub[i] = a[i].y;
	}
	sort(a + 1, a + 1 + n, cmp);
	sort(sub + 1, sub + 1 + n);
	for(int i = 1; i <= n; i++)
		if(i == 1 || sub[i - 1] != sub[i])
			sub[++cnt] = sub[i];
	for(int i = 1; i <= n; i++){
		int p = lower_bound(sub + 1, sub + 1 + cnt, a[i].y) - sub;
		int t = query(p);
		ans = max(ans, t + 1);
		modify(p, t + 1);
	}
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：moosssi (赞：9)

 一道经典的数据结构优化dp。
 
 先考虑不加优化的转移，设 $f[i]$ 表示在前 $i$ 个馅饼里获得第 $i$ 个馅饼的最大得分，状态转移则为 $f[i]=max(f[i],f[j]+v_i)$ 且 $(0<j<i,abs(p_i - p_j)\le 2(t_i-t_j))$.

如果直接去枚举的话时间会是$O(n^2)$，这里考虑优化，把条件式子的绝对值拆开即为 $\begin{cases}p_i-2t_i\le p_j-2t_j(p_i\le p_j)\\p_i+2t_i\ge p_j+2t_j(p_i\ge p_j)\end{cases}$

第一个条件，直接在预处理的时候排序，即可满足。

第二个条件，利用我们的树状数组优化，时间复杂度即可降为$O(nlogn)$。

```cpp
#include<bits/stdc++.h>
#define lowbit(x) x&-x
using namespace std;
const int N=1e5+5;
int b[N],w,n,tr[N];
struct node{
	int t,p,v,l,r;
}a[N];
bool cmpl(node x,node y){return x.l>y.l;}//分别按两种关键字排序 
bool cmpr(node x,node y){return x.r<y.r;}
void add(int x,int val){
	for(int i=x;i<N;i+=lowbit(i)){
		tr[i]=max(tr[i],val);//更新树状数组 
	}
}
int query(int x){
	int res=0;
	for(int i=x;i;i-=lowbit(i)){
		res=max(res,tr[i]);//找最大值 
	}
	return res;
}
int main(){
	scanf("%d%d",&w,&n);
	for(int i=1;i<=n;i++){
		scanf("%d%d%d",&a[i].t,&a[i].p,&a[i].v);
		a[i].l=a[i].p-2*a[i].t;//预处理条件一的量 
		b[i]=a[i].r=a[i].p+2*a[i].t;//条件二的量 
	}                    
	sort(a+1,a+n+1,cmpr); 
	sort(b+1,b+n+1);
	unique(b+1,b+n+1)-b;
	for(int i=1;i<=n;i++){
		a[i].r=lower_bound(b+1,b+n+1,a[i].r)-b;//离散化 
	}
	sort(a+1,a+n+1,cmpl);
	for(int i=1;i<=n;i++){
		add(a[i].r,query(a[i].r)+a[i].v);//先取出当前最优，再把最优的存进树状数组 
	}
	printf("%d\n",query(N-1));//答案在整个树状数组里 
	return 0;
}

```


---

## 作者：鲨齿渊虹 (赞：7)

## write  in  front

前置知识，树状数组和二维偏序

## $思路$

显然定义 $dp_{i}$ = $max$($dp_{i}$ , $dp_{j}$ $+$ $v_{i}$)

$i$ 为接到第 $i$ 个馅饼

思考可以转移的条件

贪心的想一次最多跨 2 格

所以在这段时间内最多可走 $2$ $\times$ $(t_{i}-t_{j})$

所以说可行的条件是  $abs(p_{i}-p_{j})\le 2\times(t_{i}-t_{j})$     

然后暴力跑一遍拿到 85 分的佳绩

吐槽一句，更正解的区分度太低，求换  数据
 
运用拆的方法
    
$\left\{\begin{array}{ll}
2 t_{i}-p_{i} \geq 2 t_{j}-p_{j} & \left(p_{i} \leq p_{j}\right) \\
2 t_{i}+p_{i} \geq 2 t_{j}+p_{j} & \left(p_{i} \geq p_{j}\right)
\end{array}\right.$

发现它是 2 维偏序

所以对第一维排序，第二维也排序加树状数组，便到 $O(n \log n)$

但发现第 2个条件的值域太大，树状数组会炸

因为要的是大小关系

离散化就行
 

## AC  CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
const int SIZE=1<<13;
static char buf[SIZE],*be=buf,*en=buf,obuf[SIZE],*p3=obuf;
#define getchar() be==en&&(en=(be=buf)+fread(buf,1,SIZE,stdin),be==en)?EOF:*be++;
inline int read(){
     int x=0,f=1;char ch=getchar();
     while(!isdigit(ch))f=ch!='-',ch=getchar();
     while(isdigit(ch))x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
     return f?x:-x;
}
const int maxn=1e5+10;
struct node{
	int v,t,p,x,y;
}a[maxn];
int c[maxn],dp[maxn],b[maxn];
int w,n,k,ans=0;
inline bool cmp(node a,node b){
	return a.x<b.x;
}
inline int lowbit(int x){return x&(-x);}
inline int ask(int x){
	int res=0;
	for(int i=x;i;i-=lowbit(i)){
		res=max(res,c[i]);
    }
    return res;
}
inline void add(int x,int y){
	for(int i=x;i<=k;i+=lowbit(i)){
		c[i]=max(c[i],y);
	}
}
int main(){
	w=read();n=read();
	for(int i=1;i<=n;i++){
		a[i].t=read();a[i].p=read();a[i].v=read();
		a[i].x=2*a[i].t-a[i].p;
		a[i].y=2*a[i].t+a[i].p;	
		b[i]=a[i].y;
    }                       
    sort(a+1,a+n+1,cmp);
    sort(b+1,b+n+1);
    k=unique(b+1,b+n+1)-b;
    for(int i=1;i<=n;i++){
    	a[i].y=lower_bound(b,b+n+1,a[i].y)-b;
	}
	for(int i=1;i<=n;i++){
		dp[i]=ask(a[i].y)+a[i].v;
		add(a[i].y,dp[i]);
		ans=max(ans,dp[i]);
	}
	cout<<ans<<endl;
	return 0;
}
```
如果您看写的不错，麻烦点个赞

---

## 作者：Seauy (赞：6)

考虑dp，设 $dp_i$ 为得到馅饼 $i$ 后获得的最大分数，很容易得到递推式

$$ dp_i=\max_{2(t_i-t_j)\geq |p_i-p_j|,t_{i}\geq t_j} dp_j+v_i $$

看到讨厌的绝对值你产生了分类讨论的想法，那么 $j$ 成为 $i$ 的合法前继的条件为

$$\left\{\begin{array}{l}t_i\geq t_j \\p_i\geq p_j \\ 2t_i-p_i\geq 2t_j-p_j\end{array}\right.$$

或者

$$\left\{\begin{array}{l}t_i\geq t_j\\p_i\leq p_j-1\\2t_i+p_i\geq 2t_j+p_j\end{array}\right.$$

芜湖三个条件，~~做两次三维偏序~~

考虑把每个状态看作平面上的点 $(p_i,t_i)$，由于人最快的时候 2格/秒，所以一个点合法前继应该在如下图的范围内

![](https://cdn.luogu.com.cn/upload/image_hosting/nevm78rx.png)

点 $A(p_i,t_i)$，AD、AB 的斜率为 $\pm\frac{1}{2}$

反过来说，如果这个点被人家罩住了，两者的范围投影到 y轴 上它比人家低，投影到 x轴 上它比人家左

范围投影到 y轴 上为 $(0,t-\frac{p}{2})$，x轴 上为 $(2t+p,0)$

又变成二维偏序辽 qwq 愉快地切了这题吧！

```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAXN=1e5;

struct Point//转化坐标系后的点坐标 
{int x,y,v;}Cake[MAXN+5];

bool cmp(Point a,Point b) {return (a.y==b.y ? a.x<b.x : a.y<b.y);}

int w,n,ans;
int discre[MAXN+5],dnum;

int Search(int x)
{
	for(int L=1,R=dnum,mid;1;)
	{
		mid=(L+R)>>1;
		if(discre[mid]==x) return mid;
		if(discre[mid]<x) L=mid+1;
		else R=mid-1;
	}
	return 0;
}

int maxn[MAXN+5];
int lowbit(int x) {return x&-x;}
void Assis(int x,int v) {for(;x<=n;x+=lowbit(x)) maxn[x]=max(maxn[x],v);}
int GetMax(int x)
{
	int cnt=0;
	for(;x>0;x-=lowbit(x)) cnt=max(cnt,maxn[x]);
	return cnt;
}

int main()
{
	scanf("%d %d",&w,&n);
	for(int i=1,t,p;i<=n;i++)
	{
		scanf("%d %d %d",&t,&p,&Cake[i].v);
		discre[i]=Cake[i].x=p+2*t;
		Cake[i].y=-p+2*t;
	}
	sort(Cake+1,Cake+n+1,cmp);
	sort(discre+1,discre+n+1);
	dnum=unique(discre+1,discre+n+1)-discre-1;
	for(int i=1,dp;i<=n;i++)
	{
		Cake[i].x=Search(Cake[i].x);
		dp=GetMax(Cake[i].x)+Cake[i].v;
		ans=max(ans,dp);
		Assis(Cake[i].x,dp);
	}
	printf("%d\n",ans);
	return 0;
}
```

似乎并不用开 long long？

---

## 作者：Push_Y (赞：3)

这是一道经典的数据结构优化dp

### 思路

定义 $f_i$ 表示接住第 $i$ 个馅饼

对于 $f_i$ ，考虑从 $j∈[1,i)$ 的 $f_j$ 转移得到

$$f_i=max\{f_j+v_i\}$$

这里的 $j$ 满足 $abs(p_i-p_j)≤2(t_i-t_j)$，于是接下来的问题是如何维护每个 $i$ 对应的 $j$ 的集合了。于是将 $j$ 的条件式展开，得到

$$
\begin{cases}
p_i-2t_i≤p_j-2t_j\ \ \ \ \ (p_i≤p_j)\\
p_i+2t_i≥p_j+2t_j\ \ \ \ \ (p_i≥p_j)
\end{cases}$$

此时按第一个式子排序，再用树状数组维护另一个式子。这样做可以使两条式子同时都满足，于是 $pi$ 与 $p_j$ 的大小关系便无关紧要了。

### 树状数组维护过程

因为两条式子不等号方向不同，其他题解的做法

$$
\begin{cases}
2t_i-p_i≥2t_j-p_j\ \ \ \ \ (p_i≤p_j)\\
2t_i+p_i≥2t_j+p_j\ \ \ \ \ (p_i≥p_j)
\end{cases}$$

这样的话两次排序就都升序就解决了。

当然，也可以~~像我一样~~把第一条式子降序排序

### 具体实现细节

按第一个式子排序后用树状数组维护第二个式子，这里由于数值大，对第二个式子离散化。

### CODE

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

inline int gin(){
	char c=getchar();
	int s=0,f=1;
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		s=(s<<3)+(s<<1)+(c^48);
		c=getchar();
	}
	return s*f;
}

const int N=1e5+5;
int b[N],w,n,k,c[N];

struct node{
	int t,p,v,l,r;
}a[N];
bool cmpl(node x,node y){\\第一条式子降序排序
	return x.l>y.l;
}
bool cmpr(node x,node y){
	return x.r<y.r;
}

void update(int x,int val){
	while(x<=k){
		c[x]=max(c[x],val);
		x+=x&-x;
	}
}

int query(int x){
	int res=0;
	while(x){
		res=max(res,c[x]);
		x-=x&-x;
	}
	return res;
}

signed main(){
	w=gin(),n=gin();
	for(int i=1;i<=n;i++){
		a[i].t=gin(),a[i].p=gin(),a[i].v=gin();
		a[i].l=a[i].p-2*a[i].t;//存第一条式子
		a[i].r=b[i]=a[i].p+2*a[i].t;//存第二条式子
	}
                          
   \\离散化                        
	sort(a+1,a+n+1,cmpr);
	sort(b+1,b+n+1);
	k=unique(b+1,b+n+1)-b;
	for(int i=1;i<=n;i++)
		a[i].r=lower_bound(b+1,b+n+1,a[i].r)-b;
  
	sort(a+1,a+n+1,cmpl);
	for(int i=1;i<=n;i++){
		int tmp=query(a[i].r);
		update(a[i].r,tmp+a[i].v);//对于刚转移得到的dp值tmp，加入到树状数组里
	}
	printf("%lld\n",query(k));
	return 0;
}

```


---

## 作者：Sellaris (赞：3)

- 给出一种暴力 **树套树** 的解法。

- 一道简单的DP。但是我脑抽了，所以写了个吸氧的非常暴力的东西。俗话说的好，两只$\log$跑得快、跑得快。上来一看题解区，好！就我是脑瘫。


------------


- 首先很容易想到朴素的状态设计，令 $dp_i$ 表示前 $i$ 个，且必选第 $i$ 个物品的最大得分。有：

$$dp_i=\max_{abs(p[i]-p[j])\leqslant abs(t[i]-t[j])}^{0\leqslant j\leqslant i-1}\{dp_j+v[i]\}$$

- 容易想到按照时间排序，这样就可以把时间的绝对值去掉。即：

$$dp_i=\max_{abs(p[i]-p[j])\leqslant t[i]-t[j]}^{0\leqslant j\leqslant i-1}\{dp_j+v[i]\}$$

- 到这里之后考虑把位置的绝对值也去掉，于是拆开分类讨论。把同一个变量移到一边，原条件变为：

$\left\{
\begin{aligned}
-p[j]+t[j]\times2\leqslant -p[i]+t[i]\times2\quad p[i]\geqslant p[j]\\
p[j]+t[j]\leqslant p[i]+t[i]\times2\quad  p[i]\leqslant p[j]\\
\end{aligned}
\right.$

- 于是考虑直接暴力做，维护两个树套树，外层树状数组维护 $p_i$ 和 $p_j$ 的大小关系，两个树套树内层动态开点的值域线段树分别维护上述符合两个条件的最大 $dp_j(j\leq i-1)$ 的值进行转移即可。


- 时空复杂度都是 $O(n\log^2n)$ ，刚好可过。注意实现的时候离散化。代码可读性较差，勿喷。

```cpp
///*****Sellaris*****///
//I will win stars full sleeves in my dream.

#include <bits/stdc++.h>
//#include <bits/extc++.h>
using namespace std;

const int maxn=3e5+10;
const int mo=1e9+7;

inline int read(){
    int ret=0,f=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}
    while(isdigit(ch)){ret=ret*10+ch-'0';ch=getchar();}
    return ret*f; //x=(x<<1)+(x<<3)+(ch^48);
}

struct object{
	int t,p,v;
	friend bool operator <(const object &x,const object &y){
		if(x.t==y.t) return x.p<y.p;
		return x.t<y.t;
	}
}node[maxn];

int n,m;
//
//COOL PROBLEM
//

int tp=0;
int dp[maxn];
//well I want to write a bit in segmenttree
//gogogogo!!!!!
struct seg{
	int ls,rs,v;
}T[(int)maxn*((int)log2(maxn)+1)*((int)log2(maxn)+1)];
int tot=0;
int rt1[300003],rt2[300003];
unordered_map<int,int>mp;
inline void pushup(int p){
	if(T[p].ls) T[p].v=max(T[p].v,T[T[p].ls].v);
	if(T[p].rs) T[p].v=max(T[p].v,T[T[p].rs].v);
}
int update(int p,int l,int r,int x,int k){
	int root=p;
	if(root==0) root=++tot,T[tot].ls=0,T[tot].rs=0,T[tot].v=0;
	int mid=l+r>>1;
	p=root;
	if(l==r) {
		T[p].ls=0,T[p].rs=0;
		T[p].v=k;
		return root;
	}
	if(x<=mid) T[p].ls=update(T[p].ls,l,mid,x,k);
	else if(x>mid) T[p].rs=update(T[p].rs,mid+1,r,x,k);
	pushup(p);
	return root;
}
int query(int p,int l,int r,int ql,int qr){
//	cout<<p<<" "<<l<<" "<<r<<" "<<ql<<" "<<qr<<endl;
	if(p==0) return 0;
//	system("pause");
	if(ql<=l && r<=qr) return T[p].v;
	int mid=l+r>>1;
	int res=0;
	if(mid>=ql) res=max(res,query(T[p].ls,l,mid,ql,qr));
	if(mid+1<=qr) res=max(res,query(T[p].rs,mid+1,r,ql,qr));
	return res;
}
struct bit{
	inline int lowbit(int x) {return (x&(-x));}
	inline void add(int k,int pos,int x,int ty){
		//cout<<k<<" in b"<<ty<<" now: \n";
		int kk=k;
		while(kk<=m){
			//cout<<kk<<" "<<x<<"is insert\n";
			if(ty==1)rt1[kk]=update(rt1[kk],1,m,pos,x);
			else rt2[kk]=update(rt2[kk],1,m,pos,x);
			kk+=lowbit(kk);
			//if(kk+lowbit(kk)<=m){
				//if(!rt[kk+lowbit(kk)]){
			//		int now=++tot;
			//		rt[kk+lowbit(kk)]=tot;
			//		T[tot].ls=T[rt[kk]].ls;
			//		T[tot].rs=T[rt[kk]].rs;
			//		T[tot].v=T[rt[kk]].v;
				//}
			//}
		}
	}inline int ask(int k,int l,int r,int ty){
		int res=0;
		//cout<<k<<" "<<l<<" "<<r<<" is ask in b"<<ty<<"\n";
		while(k){
		//	cout<<k<<" ,";
		//	cout<<"k="<<k<<" res="<<res<<"\n";
			res=max(res,query(ty==1?rt1[k]:rt2[k],1,m,l,r));
		//	cout<<" res="<<res<<"\n";
			k-=lowbit(k);
		}return res;
	}//I think thats ok
}b1,b2;

inline void solve(){
//	clock_t st=clock();
	m=read();/*宽度*/n=read();//个数 
	for(int i=1;i<=n;i++){
		node[i].t=read();//reach_time 
		node[i].p=read();//reach_spot
		node[i].v=read();//value
	}
	sort(node+1,node+1+n);
	
	int reg[300010];
	for(int i=1;i<=n;i++){	
		reg[++tp]=node[i].p+node[i].t*2;
		reg[++tp]=-node[i].p+node[i].t*2;
		reg[++tp]=node[i].p;
	}sort(reg+1,reg+1+tp);
	
	int cnt=0;
	for(int i=1;i<=tp;i++){rt1[i]=rt2[i]=0;if(reg[i]==reg[i-1] && i>1) continue;else mp[reg[i]]=++cnt;}//lsh
	m=mp.size();
//	for (auto x:mp) cout<<x.first<<"->>"<<x.second<<"\n";
	for(int i=1;i<=n;i++){
	//	cout<<i<<"\n";
		
		//cout<<mp[-node[1].p+node[1].t*2]<<" "<<mp[node[1].p+node[1].t*2]<<"\n";
		
	//	cout<<mp[-node[i].p+node[i].t*2]<<" is fir "<<mp[node[i].p+node[i].t*2]<<" is sed\n";
		
		//cout<<1 <<" "<< mp[node[i].p]  << " " << mp[node[i].p]  <<" " << m <<"\n";
		
		//cout<<mp[-node[i].p+node[i].t*2]<<" is fir ";
		//cout<<b1.ask(mp[-node[i].p+node[i].t*2] , 1 , mp[node[i].p] )<<" " ;
		//cout<<" \n"<<mp[node[i].p+node[i].t*2]<<" is sed "<< b2.ask(mp[node[i].p+node[i].t*2] , mp[node[i].p] , m )<<"\n\n"; 
		
		dp[i]=max({node[i].v, b1.ask(mp[-node[i].p+node[i].t*2] , 1 , mp[node[i].p] ,1) + node[i].v, b2.ask(mp[node[i].p+node[i].t*2] , mp[node[i].p] , m ,2) + node[i].v });
		b1.add(mp[-node[i].p+node[i].t*2],mp[node[i].p],dp[i],1);
	//	cout<<"LOOK HERE that::" <<( node[i].p + node[i].t*2 )<< "->>" <<mp[node[i].p+node[i].t*2]<<"\n";
		b2.add(mp[node[i].p+node[i].t*2],mp[node[i].p],dp[i],2);
	//	cout<<dp[i]<<"\n";
	}

	int ans=0;
	for(int i=1;i<=n;i++) ans=max(ans,dp[i]);
	cout<<ans<<"\n";
}	
				//that's easy to do
				//yeah ... but why it goes wrang ???
				//ok,let me think ...
				//
//		if((clock()-st)/(double)CLOCKS_PER_SEC >0.95) break;
signed main(){
    //std::ios::sync_with_stdio(false);std::cin.tie(NULL);std::cout.tie(NULL);
    //freopen("P7302_6.in","r",stdin);
	//freopen("out.txt","w",stdout);
	int t=1;
	while(t--){
		solve();
	}
    return 0;
}

/*
8 6
1 1 5
1 2 3
3 4 8
5 3 9
5 7 3
6 3 4
*/

```







---

## 作者：Maverik (赞：2)


## 题目大意


有一个直线，在某一个时刻有一个馅饼会出现在一些位置，有它的价值。 一个人一开始可以站在直线的任意地方，然后他每个时刻可以不移动，或向任意一边移动一个单位或两个单位。

要你求这个人最多能拿多少价值的馅饼。

## 分析

$f_{i}$ 为对于前 $i$ 个馅饼，接住了第 $i$ 个的最大贡献，按时间先后顺序排序。转移： 

$$
f_{i}=\max_{\operatorname{abs}\left(p_{i}-p_{j}\right) \leq 2\left(t_{i}-t_{j}\right)\wedge t_j<t_i}\left\{f_{j}+v_{i}\right\}
$$

对于转移条件：
 $\text{abs}(p_{i}-p_{j}) \le 2(t_{i}-t_{j})\wedge t_j<t_i$
，拆一下绝对值：

$$
\left\{\begin{matrix}
2t_j-2t_i\le p_j-p_i && (p_j\le p_i\wedge t_j<t_i)
 \\
2t_j-2t_i\le p_i-p_j && (p_j>p_i\wedge t_j<t_i)
\end{matrix}\right.
$$

考虑当 $2t_j-2t_i\le p_j-p_i ~,~ p_j\le p_i~,~ t_j<t_i$ 都成立时，$2t_j-2t_i\le p_i-p_j $ 会使条件更严。也就是说前者能推出后者，同理，后者也能推出前者：

$$
\left\{\begin{matrix}
2t_j-2t_i\le p_j-p_i ~\wedge~ p_j\le p_i~\wedge~ t_j<t_i\Rightarrow2t_j-2t_i\le p_i-p_j
 \\
2t_j-2t_i\le p_i-p_j ~\wedge~ p_j>p_i~\wedge~ t_j<t_i\Rightarrow 2t_j-2t_i\le p_j-p_i
\end{matrix}\right.
$$

所以当 $2t_j-p_j\le 2t_i-p_i ~,~2t_j+p_j\le 2t_i-p_i$ 都成立的时候， $(p_j>p_i\wedge t_j<t_i)$ 和 $(p_j\le p_i\wedge t_j<t_i)$ 中一定有一个成立，满足转移条件，所以转移条件可以替换为

$$
\left\{\begin{matrix}
2t_j-p_j\le 2t_i-p_i 
\\
2t_j+p_j\le 2t_i+p_i 
\end{matrix}\right.
$$

二维偏序思想，先按照一维 $(2t_i-p_i)$ 排序，树状数组处理第二维 $(2t_i+p_i)$ 转移即可。

注意由于第二维要当作下标记放在树状数组里，需要离散化。

复杂度 $O(n\log n)$

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+5;
int W,n;
vector<int>lsh;
struct node{int t,p,v,l,r;}a[maxn];
struct BIT
{
    int c[maxn];
    inline int lowbit(int x){return x&(-x);}
    inline void add(int x,int y){for(;x<maxn;x+=lowbit(x)) c[x]=max(c[x],y);} 
    inline int query(int x){int res_=0;for(;x;x-=lowbit(x))res_=max(res_,c[x]);return res_;}
}B;
signed main()
{
  cin>>W>>n;
  for(int i=1;i<=n;i++)
  {
    cin>>a[i].t>>a[i].p>>a[i].v;
    a[i].l=a[i].p-2*a[i].t,a[i].r=a[i].p+2*a[i].t,lsh.push_back(a[i].r);
  }                    
  sort(lsh.begin(),lsh.end()),lsh.erase(unique(lsh.begin(),lsh.end()),lsh.end());
  for(int i=1;i<=n;i++) a[i].r=lower_bound(lsh.begin(),lsh.end(),a[i].r)-lsh.begin()+1;
  sort(a+1,a+n+1,[](node x,node y){return x.l>y.l;}); 
  for(int i=1;i<=n;i++) B.add(a[i].r,B.query(a[i].r-1)+a[i].v);
  cout<<B.query(maxn-1)<<endl;
  return 0;
}

```

---

## 作者：Jayun (赞：2)

# 链接：

[题目](https://www.luogu.com.cn/problem/P7302)

[博客园](https://www.cnblogs.com/GJY-JURUO/p/14336793.html)

# 题目大意：

有 $n$ 个馅饼，第 $i$ 个馅饼在 $t_i$ 时掉落在 $p_i$ 上，若掉落时玩家不没接住，馅饼就会消失。接住第 $i$ 个馅饼能获得 $v_i$ 的分数，问如何使得分数之和最大。

# 正文:

考虑用动态规划。设 $f_i$ 表示前 $i$ 个馅饼接住了第 $i$ 个的最大分数。我们可以列方程得：

$$f_i=\max_{\text{abs}(p_i-p_j)\leq 2(t_i-t_j)}\{f_j+v_i\}$$

直接 $\mathcal{O}(n^2)$ 是不可行的，考虑优化，展开上式的条件：

$$\left\{\begin{matrix}
p_i+2t_i\geq p_j+2t_j&(p_i\leq p_j)\\
p_i-2t_i\leq p_j-2t_j&(p_i> p_j)
\end{matrix}\right.$$

因为有两个关键字，按照关于第一个式子的关键字排序，用关于第二个式子的关键字树状数组维护就好了（或者用第二个式子排序，第一个式子树状数组，顺序没影响）。

# 代码：

```cpp
const int N = 1e5 + 10;

ll t[N], b[N];
int n, m, k;

void modify(int x, ll val){for (; x <= k; x += x & -x) t[x] = max(t[x], val);}
ll query (int x)
{
	ll ans = 0;
	for (; x; x -= x & -x) ans = max(ans, t[x]);
	return ans;
}

struct node
{
	ll l, r, p, t;
	int v;
}a[N];

bool cmp1 (node a, node b) {return a.r < b.r;}
bool cmp2 (node a, node b) {return a.l < b.l;}

int main ()
{
	scanf ("%d%d", &m, &n);
	for (int i = 1; i <= n; i++)
		scanf ("%d%d%d", &a[i].t, &a[i].p, &a[i].v), 
		a[i].l = 2 * a[i].t - a[i].p, 
		a[i].r = 2 * a[i].t + a[i].p,
		b[i] = a[i].r;
	sort (a + 1, a + 1 + n, cmp1);
	sort (b + 1, b + 1 + n);
	k = unique(b + 1, b + 1 + n) - b;
	for (int i = 1; i <= n; i++)
		a[i].r = lower_bound(b + 1, b + 1 + n, a[i].r) - b;
	sort (a + 1, a + 1 + n, cmp2);
	for (int i = 1; i <= n; i++)
	{
		ll tmp = query(a[i].r);
		modify(a[i].r, tmp + a[i].v);
	}
	printf ("%lld\n", query(k));
	
	return 0;
}
```


---

## 作者：dAniel_lele (赞：1)

## 思路

考虑两个馅饼在什么情况下才能同时接住。

当两馅饼的着落点之间的距离小于时间差的 $2$ 倍，两馅饼可先后被接住。

即为：$|p_i-p_j|\leq 2|t_i-t_j|$

考虑在图上，只需要在点 $(p_i,t_i)$ 上分别画两条向下的，斜率为 $-\dfrac{1}{2},\dfrac{1}{2}$ 的线，如果完全包含 $(p_j,t_j)$ 即可转移。

将 $(p_i,t_i)$ 映射为 $(x,y)$，其中 $x,y$ 为两条直线与线 $x=0,x=n$ 的交点的 $y$ 坐标。


然后我们就把问题转化成了二维的 $LIS$ 问题，排序后使用线段树解决即可。


## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
#define double long double
#define mid ((l+r)>>1)
using namespace std;
struct node{
	int x,y,w;
}a[1000005];
int lsx[1000005],lsy[1000005];
struct sgt{
	int f[1000005];
	void change(int i,int l,int r,int pos,int cg){
		if(l==r){
			f[i]=max(f[i],cg); return ;
		} 
		if(pos<=mid) change(i*2,l,mid,pos,cg);
		else change(i*2+1,mid+1,r,pos,cg);
		f[i]=max(f[i*2],f[i*2+1]); 
	}
	int qry(int i,int l,int r,int ql,int qr){
		if(ql<=l&&r<=qr) return f[i];
		if(ql>r||qr<l) return 0;
		return max(qry(i*2,l,mid,ql,qr),qry(i*2+1,mid+1,r,ql,qr));
	}
}tree;
bool cmp(node A,node B){
	if(A.x!=B.x) return A.x<B.x;
	return A.y<B.y;
}
signed main(){
	int w,n;
	cin>>w>>n;
	for(int i=1;i<=n;i++){
		int t,p;
		cin>>t>>p>>a[i].w;
		a[i].x=t*2-p;
		a[i].y=t*2-(w-p);
		lsx[i]=a[i].x;
		lsy[i]=a[i].y;
	}
	sort(lsx+1,lsx+n+1),sort(lsy+1,lsy+n+1);
	for(int i=1;i<=n;i++) a[i].x=lower_bound(lsx+1,lsx+n+1,a[i].x)-lsx,a[i].y=lower_bound(lsy+1,lsy+n+1,a[i].y)-lsy;
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++){
		tree.change(1,1,n,a[i].y,tree.qry(1,1,n,1,a[i].y)+a[i].w);
	}
	cout<<tree.qry(1,1,n,1,n);
	return 0;
}
```

---

## 作者：fanfansann (赞：1)


## 题目描述

SERKOI 最新推出了一种叫做 “免费馅饼” 的游戏：游戏在一个舞台上进行。舞台的宽度为 $w$​​ 格（从左到右依次用 $1\sim w$​ 编号），游戏者占一格。开始时游戏者可以站在舞台的任意位置，手里拿着一个托盘。下图为天幕的高度为 $4$ 格时某一个时刻游戏者接馅饼的情景。

![在这里插入图片描述](https://img-blog.csdnimg.cn/24c563fdf1134da4959b24cb638e3f44.png)

游戏开始后，从舞台天幕顶端的格子中不断出现馅饼并垂直下落。游戏者左右移动去接馅饼。游戏者每秒可以向左或者向右移动一格或两格，也可以以站在原地不动。

当馅饼在某一时刻恰好到达游戏者所在的格子中，游戏者就收集到了这块馅饼。当馅饼落在一个游戏者不在的格子里时该馅饼就消失。

写一个程序，帮助我们的游戏者收集馅饼，使得所收集馅饼的分数之和最大。

## 输入格式

第一行是用空格隔开的两个正整数，分别给出了舞台的宽度 $w$ 和馅饼的个数 $n$。　　

接下来 $n$ 行，每一行给出了一块馅饼的信息。由三个正整数组成，分别表示了每个馅饼落到舞台上的时刻 $t_i$，掉到舞台上的格子的编号 $p_i$，以及分值 $v_i$。

游戏开始时刻为 $0$ 。输入文件中同一行相邻两项之间用一个空格隔开。输入数据中可能存在两个馅饼的 $t_i$ 和 $p_i$ 都一样。

## 输出格式

一个数，表示游戏者获得的最大总得分。

## 输入样例

```
3 4
1 2 3
5 2 3
6 3 4
1 1 5
```

## 输出样例

```
12
```

## 数据规模与约定

对于 $100\%$ 的数据，$1\le  w\le 10^8$，$1\le n \le 10^5$，$1\le t_i\le 10^8$，$1\le p_i\le w$，$1\le v_i\le 1000$



**Solution** 

比较简单的一道题。

显然考虑 DP 。

设 $f[i]$ 表示接住第 $i$ 个馅饼以后能获得的最大的分数。

显然有转移方程：

$$
f[i] = \max\{f[j]\mid |p_i-p_j|\le 2\times (t_i-t_j)\} + v_i
$$

直接转移显然是 $O(n^2)$ 的，$n\le 10^5$，考虑优化。

显然我们可以从转移的条件 $j$ 入手。对于每一个可以转移到 $i$ 的 $j$ ，需要满足条件： $|p_i-p_j|\le 2\times (t_i-t_j)$，展开后有：

$$
|p_i-p_j|\le 2\times (t_i-t_j)
$$

$$
-2\times( t_i-t_j)\le p_i-p_j\le 2\times (t_i-t_j)
$$

$$
2\times t_i-p_i\ge 2\times t_j-p_j\  \mathrm{and}\ 2\times t_i+p_i\ge 2\times t_j+p_j
$$

设 $a_1=2\times t_i-p_i,a_2=2\times t_i+p_i$，显然我们只需要按照 $a_1$ 之后就不需要判断条件 $2\times t_i-p_i\ge 2\times t_j-p_j$了，但是我们必须同时满足两个条件，还有条件 $2\times t_i+p_i\ge 2\times t_j+p_j$，暴力判断条件二显然是 $O(n^2)$ 的，我们发现此时问题实际上是一个类 $LIS$ 问题也即二维偏序问题，使用树状数组 $O(\log n)$ 维护满足条件二的最优值进行DP转移即可。

时间复杂度 $\mathcal{O}(n\log n)$

注意给定的 $w$ 数据范围比较大，我们将 $a_2$ 离散化即可。


**Code**

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 7, INF = 0x3f3f3f3f;
#define lowbit(x) (x & (-x))
int n, m, s, t, w, ans;
int tr[maxn];
int f[maxn], b[maxn];

struct node {
    int x, y, t, p, v;
    bool operator < (const node &t) const {
        if (x == t.x)
            return y > t.y;

        return x < t.x;
    }
} a[maxn];

int query(int x) {
    int ans = 0;

    for (; x; x -= lowbit(x))
        ans = max(ans, tr[x]);

    return ans;
}

void update(int x, int k) {
    for (; x <= n + 1; x += lowbit(x))
        tr[x] = max(tr[x], k);
}

int main() {
    scanf("%d%d", &w, &n);
    a[0].x = a[0].y = a[0].t = -INF;

    for (int i = 1; i <= n; ++ i) {
        scanf("%d%d%d", &a[i].t, &a[i].p, &a[i].v);
        a[i].x = 2 * a[i].t + a[i].p;
        a[i].y = 2 * a[i].t - a[i].p;
    }

    sort(a, a + 1 + n);

    for (int i = 0; i <= n; ++ i)
        b[i] = a[i].y;

    sort(b, b + 1 + n);

    for (int i = 0; i <= n; ++ i)
        a[i].y = lower_bound(b, b + 1 + n, a[i].y) - b + 1;

    for (int i = 1; i <= n; ++ i) {
        f[i] = query(a[i].y) + a[i].v;
        update(a[i].y, f[i]);
    }

    for (int i = 1; i <= n; ++ i)
        ans = max(ans, f[i]);

    cout << ans << endl;
    return 0;
}
``` 

---

## 作者：Godのfather (赞：1)

## （一）思路

题意不再赘述。第一眼就觉得是动态规划。

设$f(i)$表示接到第$i$个馅饼能够得到的最大价值。由于一个人每次最多只能移动一格。设上一次接到的馅饼在$p_j$，当前要接的馅饼在$p_i$，那么，如果能同时接到馅饼$i,j$，必要条件是：$|p_i-p_j|\leq 2(t_i-t_j),t_i-t_j\ge0$

因此，状态转移方程可以表示为：

$f(i)=val(i)+\sum\limits_{|p_i-p_j|\leq 2(t_i-t_j)}f(j)$

$val(i)$是第$i$个馅饼的价值。

因为：

$$|p_i-p_j|\leq 2(t_i-t_j)\iff \begin{cases} 2t_j-p_j\leq 2t_i-p_i \\ 2t_j+p_j\leq 2t_i-p_i\end{cases}$$

所以：

$$\displaystyle f(i)=val(i)+\sum\limits_{2t_j-p_j\leq 2t_i-p_i \wedge2t_j+p_j\leq 2t_i+p_i}f(j)$$

## （二）实现

不难发现，上面的约束条件其实是一个二维偏序。因此，可以用树状数组/CDQ分治等算法和数据结构水过。由于我过于愚钝，开始没注意到二位偏序的关系，惨遭WA。

数据结构的具体做法是，先按照一维排序，然后再用数据结构维护第二维。

## （三）代码

@pythoner713 巨佬强烈要求发代码。

下面是动态开点线段树的代码（因为我懒得写离散化）。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 5;
inline int read(){
	int w = 0, f = 1; char ch = getchar();
	while(ch < '0' or ch > '9') {if(ch == '-') f = -f; ch = getchar();}
	while(ch >= '0' and ch <= '9') w = w*10 + ch - '0', ch = getchar();
	return w*f;
}
struct SegmentTree{
	int ls, rs, dat;
}t[maxn*30];
int tot;
void update(int p){
	t[p].dat = max(t[t[p].ls].dat, t[t[p].rs].dat);
}
void insert(int &p, int L, int R, int x, int val){
	if(!p) p = ++tot;
	if(L == R){
		t[p].dat = max(t[p].dat, val);
		return ;
	}
	int mid = (L+R)>>1;
	if(x <= mid) insert(t[p].ls, L, mid, x, val);
	else insert(t[p].rs, mid+1, R, x, val);
	update(p);
}
int ask(int p, int L, int R, int l, int r){
	if(!p) return 0;
	if(l <= L and r >= R){
		return t[p].dat;
	}
	int mid = (L+R)>>1, val = 0;
	if(l <= mid) val = max(val, ask(t[p].ls, L, mid, l, r));
	if(r > mid) val = max(val, ask(t[p].rs, mid+1, R, l, r));
	return val; 
}
struct PIE{
	int t, p, v;
	inline bool operator <(const PIE& x) const{
		return 2*t + p < 2*x.t + x.p;
	} 
}pie[maxn];
int N, W;
signed main(){
	tot = 1; int root = 1;
	W = read()<<1, N = read();
	for(int i=1, x, y, z; i <= N; i++){
		x = read(), y = read(), z = read(); 
		pie[i] = (PIE){x, y, z};
	}
	sort(pie+1, pie+N+1);
	for(int i=1; i<=N; i++){
		int val = ask(1, -W, W, -W, 2*pie[i].t - pie[i].p) + pie[i].v;
		insert(root, -W, W, 2*pie[i].t - pie[i].p, val);
	}
	cout<<t[1].dat<<endl;
	return 0;
}
```

---

## 作者：djh0314 (赞：0)

### [传送门](https://www.luogu.com.cn/problem/P7302)

### 题意

有 $n$ 个馅饼。第 $i$ 个馅饼，在 $t_i$ 时掉落至 $p_i$ 处，人接到这个馅饼可以获得 $v_i$ 的价值。    
人每单位时间可以移动 $0\sim 2$ 步。      
时间从 $0$ 开始，一开始人可站在任意处。

### 分析+暴力
一眼 dp ，于是我们可以分析一下 dp 数组。     
令 $\mathit{f}_ {i} $ 为第 $i$ 个馅饼，第 $i$ 个馅饼必选，人可以获得的最大价值。     
转移：倘若 $2\times \left (  t_i - t_j\right ) \ge \left| p_i-p_j \right|$，就可以从 $f_j$ 转移至 $f_i$。     
至于从 0 转移，我们可以在初始化是便将 $f_i$ 赋值为 $v_i$。       

暴力代码：
~~~cpp
sort(a+1,a+n+1);
for(int i=1; i<=n; ++i) {
    f[i]=a[i].val;
    for(int j=1; j<i; ++j) {
        if((a[i].t-a[j].t)*2>=abs(a[i].p-a[j].p)) 
            f[i]=max(f[i],f[j]+a[i].val);
    }
    ans=max(ans,f[i]);
}
~~~
时间复杂度 $O(n^2)$。       
如此我们便可以愉快的拿到 85 分的高分，以至于再吸口氧后可以拿到 90。

### 优化

显然是优化枚举 $j$ 的过程。       

观察我们的判断式子：       
$2\times \left (  t_i - t_j\right ) \ge \left| p_i-p_j \right|$，     
拆掉绝对值，     
$2\times t_i-2\times t_j \ge p_i-p_j$，   
$2\times t_i-2\times t_j \ge p_j-p_i$。    
将 $i$ 与 $j$ 归于两边，      
$2\times  t_i-p_i \ge 2\times t_j - p_j $，
$2\times  t_i+p_i \ge 2\times t_j + p_j $。

观察这个式子，我们便可以马上想到，这不是熟悉的[二维数点](https://oiwiki.org/geometry/scanning/#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%82%B9)吗？      

但是又有了一个问题，原来转移时，我们将 $t$ 进行排序，
但是我们在二维数点时并不能同时将 $t$ 排序，那我们又如何做呢？

我们再次分析原来的式子，很明显，当 $t_i\ge t_j$ 时，即使是我们分开的两个式子也无法转移。       
由此，我们就可以顺利地用二维数点解决掉这道紫题。     

至于二维数点，我们则可以用线段树或者树状数组来维护前缀最大值。   
时间复杂度 $O(n\log n)$。     
[Code](https://www.luogu.com.cn/paste/by7gh2ee)。


---

## 作者：lyt_awa (赞：0)

## dp
### 状态
$f_i$ 表示前 $i$ 个馅饼，必须收集到第 $i$ 块馅饼所收集馅饼的分最大数之和。
### 转移
$$f_i=\max_{\left|p_i-p_j\right|\le 2(t_i-t_j)}f_j+v_i$$
于是暴力转移。
```cpp
struct bing { int t, p, v; } b[N];
inline bool cmp(bing x, bing y) {
	return x.t < y.t;
}
//在main()中
sort(b + 1, b + n + 1, cmp);
for (int i = 1; i <= n; ++i)
	for (int j = 1; j < i; ++j)
		if (abs(b[i].p - b[j].p) <= 2 * (b[i].t - b[j].t))
			f[i] = max(f[i], f[j] + b[i].v);
```
明显超时。

考虑将转移的条件拆开。
$$\begin{array}{c}
\left|p_i-p_j\right|\le 2(t_i-t_j)\\
\Leftrightarrow p_i-p_j\le 2(t_i-t_j)\wedge p_j-p_i\le 2(t_i-t_j)\\
\Leftrightarrow 2t_j-p_j\le 2t_i-p_i\wedge 2t_j+p_j\le 2t_i+p_i
\end{array}$$
即 $f_j$ 转移到 $f_i$ 只要满足 $2t_j-p_j\le 2t_i-p_i\wedge 2t_j+p_j\le 2t_i+p_i$。

这类似于一个二维偏序问题，先按 $2t_i+p_i$ 排序，再用树状数组维护 $\le 2t_i-p_i$ 的最大值，进行转移就行了。用树状数组**记得离散化**。
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

int n, m;
ll c[210000], C[210000];
struct node {
	ll A, B, v;
	bool operator < (node u) const { return (B < u.B || (B == u.B && A < u.A)); }
} a[210000];

inline void add(int x, ll y) { for (int i = x; i <= m + 1; i += i & ~i + 1) c[i] = max(c[i], y); }
inline ll ask(int x) {
	ll res = 0;
	for (int i = x; i; i &= i - 1) res = max(res, c[i]);
	return res;
}

int main() {
	ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);
	cin >> n >> m;
	for (int i = 1, x, y; i <= m; ++i) {
		cin >> y >> x >> a[i].v;
		a[i].A = 2 * y - x, a[i].B = x + 2 * y, C[i - 1] = a[i].A;
	}
	sort(C, C + m), sort(a + 1, a + 1 + m);
	for (int i = 1; i <= m; ++i) {
		int x = lower_bound(C, C + m, a[i].A) - C + 1;
		add(x, ask(x) + a[i].v);
	}
	cout << ask(m + 1);
	return 0;
}
```
时间复杂度 $O(m\log m)$。

---

## 作者：free_fall (赞：0)

首先考虑暴力。

用 $f_i$ 表示吃到第 $i$ 个馅饼时得到的最多的分数。

那么当 $j$ 满足条件 $2\times(t_i-t_j)\geq|p_i-p_j|$ 时可以进行转移 $f_i=\max(f_i,f_j+v_i)$。

这样进行两层循环，时间复杂度为 $O(n^2)$。

继续寻找正解。

将式子拆开，我们得到了：

$\begin{cases}
2\times t_i-p_i\ge 2\times t_j-p_j
 \\
2\times t_i+p_i\ge 2\times t_j+p_j
\end{cases}$

那么问题就变得简单了，我们可以将 $2\times t_i-p_i$ 看做 $x$ 坐标，$2\times t_i+p_i$ 看做 $y$ 坐标来做一个二维偏序。

将所有的 $x$ 和 $y$ 进行一个离散化，把它们按照 $x$ 进行排序，再用树状数组来维护 $y$，时间复杂度就可以变为 $O(n\log n)$。
```
#include<bits/stdc++.h>
#define int long long
#define lowbit(x) x&-x
using namespace std;
const int N=1e5+5,inf=0x3f3f3f3f;
int w,n,f[N],ans,b[N<<1],uni,cnt;
struct kk{
	int x,y,v;
	bool operator<(const kk &other)const{
		if(x==other.x)return y<other.y;
		return x<other.x;
	}
}a[N];
struct bittree{
	int a[N<<1];
	void add(int x,int c){
		for(int i=x;i<=uni;i+=lowbit(i)){
			a[i]=max(a[i],c);
		}
		return;
	}
	int query(int x){
		int res=0;
		for(int i=x;i>=1;i-=lowbit(i)){
			res=max(res,a[i]);
		}
		return res;
	}
}bit;
signed main(){
	scanf("%lld%lld",&w,&n);
	for(int i=1;i<=n;i++){
		int t,p,v;
		scanf("%lld%lld%lld",&t,&p,&v);
		a[i]={2*t-p,2*t+p,v};
		b[++cnt]=2*t-p;
		b[++cnt]=2*t+p;
	}
	sort(b+1,b+cnt+1);
	uni=unique(b+1,b+cnt+1)-b-1;
	for(int i=1;i<=n;i++){
		a[i].x=lower_bound(b+1,b+uni+1,a[i].x)-b;
		a[i].y=lower_bound(b+1,b+uni+1,a[i].y)-b;
	}
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++){
		f[i]=a[i].v;
		f[i]=max(f[i],bit.query(a[i].y)+a[i].v);
		bit.add(a[i].y,f[i]);
		ans=max(ans,f[i]);
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：glorious_dream (赞：0)

## 算法分析：
首先，最基础的想法是暴力 DP 复杂度 $O(n^2)$。设 $f[i]$ 表示在前 $i$ 个馅饼中，获得第 $i$ 个馅饼的最大得分。转移方程 $f[i] = \max(f[i],f[j]+v[i])$，其中 $0<j<i$ 且 $abs(p[i],p[j]) \leq 2 \times (t[i]-t[j])$。这个转移复杂度是 $O(n^2)$。

考虑把绝对值打开，式子就变为

$\begin{cases}p[i] - 2 \times t[i] \leq p[j] - 2 \times t[j] (p[i] \leq p[j])\\p[i] + 2 \times t[i] \geq p[j] + 2 \times t[j] (p[i] \geq p[j])\end{cases}$

那么这个式子分成两种情况，维护比较麻烦。但我们发现，如果要的那个式子满足了，另一个也会满足。所以我们让两个式子都满足。为什么呢？举个例子，假如满足了第一个式子，那么移项可以得到 $p[i] - p[j] \leq 2 \times t[i] - 2 \times t[j]$，而满足这个式子的条件是 $p[i] \leq p[j] \Rightarrow p[i] - p[j] \leq 0 \Rightarrow t[i] \geq t[j]$。然后我们看第二个式子，$p[i] \geq p[j]$ 并且 $t[i] \geq t[j]$，显然是满足条件的。所以第一个式子满足，第二个式子也满足。

对于第一个式子，我们可以在读入的时候维护，并进行排序。这里问题就相当于变成了一个二维偏序。第二维由于数组开不下，我们需要进行离散化。

存两个关键值，$a[i].key1 = a[i].p - 2 \times a[i].t$ 和 $a[i].key2 = a[i].p + 2 \times a[i].t$。我们先按 $key2$ 从小到大排序，并进行离散化。

```cpp
inline bool cmp2(node a,node b) { return a.key2 < b.key2; }

sort(a+1,a+n+1,cmp2);
sort(lsh+1,lsh+n+1);
unique(lsh+1,lsh+n+1)-lsh;
rep(i,1,n) a[i].key2 = lower_bound(lsh+1,lsh+n+1,a[i].key2)-lsh;
```


然后我们按 $key1$ 从大到小进行排序，相当于先把第一个条件给固定。对于 $key2$ 进行操作。

先来看为什么对 $key1$ 和 $key2$ 要这么排序。对于 $key1$，从大到小排序，在 $j < i$ 的时候需要满足 $a[i].key1 < a[j].key1$。 $key2$ 是从小到大排序的，在 $j<i$ 的时候需要满足 $a[i].key2 > a[j].key2$。**所以我们发现，两个式子同时满足可以从线段树的前面转移到后面。**

我们在线段树中存区间的最大值。先在线段树中求出 $1$ 到 $a[i].key2$ 的最大值，加上 $a[i].v$，然后存入线段树中 $a[i].key2$ 的位置。最后的答案就是 $t[1]$。

一个单点修改，区间查询的线段树即可。

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cmath>
#define re register
#define drep(a,b,c) for(re int a(b) ; a>=(c) ; --a)
#define rep(a,b,c) 	for(re int a(b) ; a<=(c) ; ++a)
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch == '-') f=-1 ; ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x*f;
}
inline void print(int x){
	if(x < 0) putchar('-'),x = -x;
	if(x >= 10) print(x / 10);
	putchar(x % 10 + '0');
}
const int M = 1e5+10;
struct node{
	int t,p,v;
	int key1,key2;
}a[M];
inline bool cmp1(node a,node b) { return a.key1 < b.key1; }
inline bool cmp2(node a,node b) { return a.key2 < b.key2; }
int lsh[M],tot,n,w;
#define ls (k<<1)
#define rs (k<<1|1)
int t[M<<2];
inline void pushup(int k) { t[k] = max(t[ls],t[rs]); }
inline void modify(int k,int l,int r,int x,int v){
	if(l == x && r == x){
		t[k] = v;
		return;
	}
	int mid = (l+r)>>1;
	if(x <= mid) modify(ls,l,mid,x,v);
	else modify(rs,mid+1,r,x,v);
	pushup(k);
}
inline int query(int k,int l,int r,int x,int y){
	if(x <= l && r <= y) return t[k];
	int res = 0;
	int mid = (l+r)>>1;
	if(x <= mid) res = max(res,query(ls,l,mid,x,y));
	if(y > mid)  res = max(res,query(rs,mid+1,r,x,y));
	return res;
}
signed main(){
	w = read(),n = read();
	rep(i,1,n){
		scanf("%d%d%d",&a[i].t,&a[i].p,&a[i].v);
		a[i].key1 = a[i].p - 2*a[i].t;
		lsh[i] = a[i].key2 = a[i].p + 2*a[i].t;
	}
	sort(a+1,a+n+1,cmp2);
	sort(lsh+1,lsh+n+1);
	unique(lsh+1,lsh+n+1)-lsh;
	rep(i,1,n) a[i].key2 = lower_bound(lsh+1,lsh+n+1,a[i].key2)-lsh;
	sort(a+1,a+n+1,cmp1);
	rep(i,1,n){
		int res = query(1,1,n,a[i].key2,n) + a[i].v;
		modify(1,1,n,a[i].key2,res);
	}
	printf("%d\n",t[1]);
	return 0;
}
```


---

## 作者：ListenSnow (赞：0)

[原题链接](https://www.luogu.com.cn/problem/P7302)

## 题意

SERKOI 最新推出了一种叫做“免费馅饼”的游戏：游戏在一个舞台上进行。舞台的宽度为 $w$ 格（从左到右依次用 $1$ 到 $w$ 编号），游戏者占一格。开始时游戏者可以站在舞台的任意位置，手里拿着一个托盘。

游戏开始后，从舞台天幕顶端的格子中不断出现馅饼并垂直下落。游戏者左右移动去接馅饼。游戏者每秒可以向左或向右移动一格或两格，也可以站在原地不动。

当馅饼在某一时刻恰好到达游戏者所在的格子中，游戏者就收集到了这块馅饼。当馅饼落在一个游戏者不在的格子里时该馅饼就消失。

写一个程序，帮助我们的游戏者收集馅饼，使得所收集馅饼的分数之和最大。

#### 数据范围

$1≤w≤10^8$，$1 \leq n \leq 10^5$，$1\leq t_i \leq 10^8$，$1\leq p_i \leq w$，$1\leq v_i \leq 1000$。

## 思路

题目中给的舞台宽度很大，但是总的馅饼数很少。考虑按照馅饼进行 dp。

设 $f[i]$ 表示捡起第 $i$ 个馅饼时获得的最大分数。根据题意，易得状态转移方程：

$f[i]=\min(f[j]+v[i])$，其中 $i$ 和 $j$ 满足 $|p[i]-p[j]|\leq 2 \times(t[i]-t[j])$。

朴素的转移时间复杂度为 $O(n^2)$ 。由于不等式中带了绝对值，不方便进行优化， 不妨先去掉绝对值，得到：

$\begin{cases}
  & p[i]+2\times t[i] \leq p[j]+2\times t[j],(p[i]-p[j]) \geq 0\\
  & p[i]-2\times t[i] \leq p[j]-2\times t[j],(p[i]-p[j]) < 0
\end{cases}$

显然可以通过排序的方式使转移时其中一个不等式恒成立，我们不妨按照 $p[i]-2\times t[i]$ 从大到小排序。那么此时因为无法判断 $p[i]$ 和 $p[j]$ 大小关系，转移时仍需满足另一个不等式（因为满足最原始的不等式的决策点一定满足另一个不等式）。

注意到满足另一个不等式的是一个区间内的决策点，那么就可以先将 $p[i]+2\times t[i]$ **离散化**，用树状数组维护区间最大值。时间复杂度为 $O(n\log n)$。

## code：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=1e5+10;
int w,n,num[N],tot,c[N];
struct node{int t,p,l,r,v;bool operator <(const node &tmp)const{return l>tmp.l;}}a[N];
int lowbit(int x){return x&-x;}
void update(int x,int k){while(x<=tot){c[x]=max(c[x],k);x+=lowbit(x);}}
int query(int x){int res=0;while(x){res=max(res,c[x]);x-=lowbit(x);}return res;}
int main()
{
	scanf("%d%d",&w,&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d%d",&a[i].t,&a[i].p,&a[i].v);
		a[i].l=a[i].p-2*a[i].t;a[i].r=a[i].p+2*a[i].t;num[i]=a[i].r;
	}
	sort(a+1,a+n+1);sort(num+1,num+n+1);tot=unique(num+1,num+n+1)-num-1;
	for(int i=1;i<=n;i++) a[i].r=lower_bound(num+1,num+tot+1,a[i].r)-num;
	for(int i=1;i<=n;i++) update(a[i].r,query(a[i].r)+a[i].v);
	printf("%d\n",query(tot));
	return 0;
}
```


---


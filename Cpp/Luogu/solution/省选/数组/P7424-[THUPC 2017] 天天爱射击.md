# [THUPC 2017] 天天爱射击

## 题目描述

小 C 爱上了一款名字叫做《天天爱射击》的游戏。如图所示，这个游戏有一些平行于 $x$ 轴的木板。现在有一些子弹，按顺序沿着 $y$ 轴方向向这些木板射去。第 $i$ 块木板被 $S_i$ 个子弹贯穿以后，就会碎掉消失。一个子弹可以贯穿其弹道上的全部木板，特别的，如果一个子弹触碰到木板的边缘，也视为贯穿木板。

小 C 现在知道了游戏中 $n$ 块木板位置，以及知道了 $m$ 个子弹射击位置。现在问你每个子弹射出去以后，有多少木板会碎掉？

## 说明/提示

![](https://cdn.luogu.com.cn/upload/image_hosting/ocqlbnl3.png)
#### 版权信息
来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2017。

$\text{upd}2021.7.6$：感谢 @[jiangbowen](https://www.luogu.com.cn/user/366807) 提供的一组 hack 数据，不计分，但若不通过 hack 数据则不算通过此题。

## 样例 #1

### 输入

```
3 2
1 3 1
2 4 2
3 4 1
2
3```

### 输出

```
1
2```

# 题解

## 作者：Suzt_ilymtics (赞：17)

[题目传送](https://www.luogu.com.cn/problem/P7424)

[更好的阅读体验？](https://www.cnblogs.com/Silymtics/p/solution-P7424.html)

### Solution

经典整体二分，挺简单的一道题。

容易想到，我们知道了每个木板在什么时候被击碎就知道哪颗子弹击碎的它。

对于每个木板可以二分这个时刻，同时考虑所有木板就变成了整体二分。

每颗子弹可以看做树状数组的单点修改。

然后对于一个木板就可以看做查询一段区间被多少颗子弹打击。

能击碎的分一组，不能击碎的分一组。

然后这题套上整体二分的模板就做完了。

不断分治下去，到 $l=r$ 时直接统计答案即可。

注意一种特殊情况，有的木板有可能自始至终都没有被击碎。

这种情况很好处理，从 $[1,m+1]$ 开始分治即可，这样自始至终都没有被击碎的木板会被划分到 $m+1$ 的位置，这块贡献就不会被统计进去了。

调这种题要时刻注意细节，样例弱的一匹，不行就自己捏几个。

其他的看代码吧，有详细注释。

### Code

```cpp
/*
Work by: Suzt_ilymics
Problem: 不知名屑题
Knowledge: 垃圾算法
Time: O(能过)
*/
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<queue>
#define LL long long
#define orz cout<<"lkp AK IOI!"<<endl

using namespace std;
const int MAXN = 4e5+5;
const int INF = 1e9+7;
const int mod = 1e9+7;
const int Max = 2e5;

struct node {
    int l, r, k, type, id;
}q[MAXN], q1[MAXN], q2[MAXN];

int n, m, tot = 0;
int ans[MAXN];
int l[MAXN], r[MAXN], v[MAXN];

int read(){
    int s = 0, f = 0;
    char ch = getchar();
    while(!isdigit(ch))  f |= (ch == '-'), ch = getchar();
    while(isdigit(ch)) s = (s << 1) + (s << 3) + ch - '0' , ch = getchar();
    return f ? -s : s;
}

namespace BIT {
    int sum[MAXN];
    int lb(int x) { return x & -x; }
    void Modify(int x, int k) { for( ; x <= Max; x += lb(x)) sum[x] += k; }
    int Query(int x) { int res = 0; for( ; x; x -= lb(x)) res += sum[x]; return res; }
}

void Solve(int l, int r, int ql, int qr) { // 整体二分
    if(ql > qr) return ; // 这种空集直接返回即可。
    if(l == r) {
        for(int i = ql; i <= qr; ++i) if(q[i].type) ans[l]++;
        // 统计第 l 颗子弹击碎了几个木板。
        return ;
    }
    int mid = (l + r) >> 1, cnt1 = 0, cnt2 = 0;
    for(int i = ql; i <= qr; ++i) {
        if(q[i].type) {
            int sum = BIT::Query(q[i].r) - BIT::Query(q[i].l - 1);
            // 树状数组区间求和，表示 [l,mid] 区间的子弹打中了它几次。
            if(sum >= q[i].k) { // 打碎了分一组
                q1[++cnt1] = q[i];
            } else { // 没打碎另分一组。
                q[i].k -= sum; // 注意要把这次的贡献算上，以后就不用考虑了。
                q2[++cnt2] = q[i];
            }
        } else {
            if(q[i].id <= mid) { 
                BIT::Modify(q[i].l, 1);
                q1[++cnt1] = q[i];
            } else {
                q2[++cnt2] = q[i];
            }
        }
    }
    for(int i = 1; i <= cnt1; ++i) if(!q1[i].type) BIT::Modify(q1[i].l, -1); // 清空树状数组。
    for(int i = 1; i <= cnt1; ++i) q[ql + i - 1] = q1[i];
    for(int i = 1; i <= cnt2; ++i) q[ql + cnt1 + i - 1] = q2[i];
    Solve(l, mid, ql, ql + cnt1 - 1);
    Solve(mid + 1, r, ql + cnt1, ql + cnt1 + cnt2 - 1);
}

int main()
{
    n = read(), m = read();
    for(int i = 1; i <= n; ++i) l[i] = read(), r[i] = read(), v[i] = read();
    // 注意因为我们子弹和木板共用一个数组 q，要先操作子弹，所以把木板放子弹的后边。
    for(int i = 1, x; i <= m; ++i) {
        x = read();
        q[++tot] = (node){x, 0, 0, 0, i};
    }
    for(int i = 1; i <= n; ++i) q[++tot] = (node){l[i], r[i], v[i], 1, i};
    Solve(1, m + 1, 1, tot);
    for(int i = 1; i <= m; ++i) printf("%d\n", ans[i]);
    return 0;
}

```

---

## 作者：JeffZhao (赞：10)

与其费劲儿地考虑这个子弹会击中哪些木板，所有木板各自被击中的次数，我们不如直接考虑每一个木板会被哪一个子弹击碎。

考虑到一个木板被恰好贯穿 $s_i$ 次，那么 $ta$ 就会碎掉，那么我们不妨二分恰好击中这个木板第 $s_i$ 的木板的编号。如果 $[1 , mid]$ 个子弹中有 $c$ 个子弹能够贯穿这个木板并且 $c >= s_i$ 个子弹能够贯穿这个木板，那恰好击中这个木板第 $s_i$ 次的子弹一定在 $[1 , mid]$ 中，我们只需要再 $[1 , mid]$ 子弹中查找第 $s_i$ 次击中这个木板的子弹。反之，就在 $[mid + 1 , r]$ 中查找第 $s_i - c$ 次击中这个木板的子弹

对于单个木板如此，那么多个木板就可以套用整体二分，将所有答案在 $[L , mid]$ 和 $[mid + 1 , R]$ 的木板分开处理

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>

using namespace std;

const int N = 3e5 + 10;

struct node{
    int l , r , c;
}range[N] , q[N] , lq[N] , rq[N];

struct BIT{
    int c[N];
    BIT(){ memset(c , 0 , sizeof(c)); }
    void add(int x , int v) { for(; x < N ; x += x & -x) { c[x] += v; } return; }
    int query(int x){ int s = 0; for(; x >= 1 ; x -= x & -x) { s += c[x]; } return s; }
}tree;

int pos[N] , n , m , cnt[N];

void solve(int L , int R , int st , int ed){
    if(st > ed) return;
    if(L == R){
        for(int i = st ; i <= ed ; ++ i){ if(q[i].c == 1 && q[i].l <= pos[L] && pos[L] <= q[i].r) cnt[L] ++ ; }
        return;
    }
    int mid = (L + R) >> 1 , lt = 0 , rt = 0;
    for(int i = L ; i <= mid ; ++ i) { tree.add(pos[i] , 1); }
    for(int i = st ; i <= ed ; ++ i) {
        int c = tree.query(q[i].r) - tree.query(q[i].l - 1);
        if(c >= q[i].c) { lq[++ lt] = q[i]; }
        else rq[++ rt] = {q[i].l , q[i].r , q[i].c - c};
    }
    for(int i = L ; i <= mid ; ++ i) { tree.add(pos[i] , -1); }
    for(int i = 1 ; i <= lt ; ++ i) q[st + i - 1] = lq[i];
    for(int i = 1 ; i <= rt ; ++ i) q[st + lt + i - 1] = rq[i];
    solve(L , mid , st , st + lt - 1);
    solve(mid + 1 , R , st + lt , ed);
    return;
}

int main(void){

    scanf("%d%d" , &n , &m);

    for(int i = 1 ; i <= n ; ++ i){
        scanf("%d%d%d" , &range[i].l , &range[i].r , &range[i].c); q[i] = range[i];
    }
    
    for(int i = 1 ; i <= m ; ++ i){
        scanf("%d" , &pos[i]);
    }

    solve(1 , m , 1 , n);

    for(int i = 1 ; i <= m ; ++ i){
        printf("%d\n" , cnt[i]);
    }

    return 0;

}
```


---

## 作者：xfrvq (赞：8)

[P7424 [THUPC2017] 天天爱射击](/problem/P7424)

给一种将这道题转化为 [静态区间 $k$ 小模板](/problem/P3834) 的方法。

我们对子弹序列排序，然后分块，排序的方法为：射出位置不等按位置左右排序，位置相等按射出时间排序，最后定义每个子弹的权值为其射出时间。

这个时候，一块木板可以表示为排序后的子弹序列上的一段区间，那么要求的就是区间内第 $k$ 小的射出时间，就是区间 $k$ 小。

但是实现会发现有一些细节：可能有多个子弹在同一个地方射出，也有可能一个位置没有子弹，此时区间 $l,r$ 可能多于或少于 $r-l+1$ 个数。

所以我们考虑对于任意 $1\le i\le 2\times10^5$，维护 $l_i$ 为排序子弹序列中第一个位置大于等于 $i$ 的子弹的下标，$r_i$ 为排序子弹序列中最后一个位置小于等于 $i$ 的子弹的下标。

于是一个木板 $L_i,R_i$ 实际上在排序子弹序列上对应得区间就是 $l_{L_i}\sim r_{R_i}$，这里直接 $k$ 小即可，最后用一个桶统计答案。

这个菜鸡甚至不会主席树，那么垃圾分块区间 $k$ 小代码就没必要放出来了。

```cpp
#include<stdio.h>
#include<math.h>
#include<algorithm>

namespace IO{ // by OneZzz6174

using IO::read;
using IO::readc;
using IO::print;
using IO::flush;

const int maxn = 2e5 + 5; // n,m 的范围
const int M = 2e5 + 1; // 子弹位置的范围

#define rep(i,a,b) for(int i = (a);i <= (b);++i)

int n,m;
int b[maxn],c[maxn],a[maxn];
// b: 排序后的子弹分别的射出时间，用来求区间 k 小
// c: 排序后的子弹分别的射出位置，用来求 l,r 数组
// a: 统计答案的桶，a[i] 代表第 i 个射出的子弹的答案
int L[maxn],R[maxn],S[maxn];
// 木板的属性的数组（左右端点，s 值）
int l[maxn],r[maxn];
// 如题解中所述的 l,r 数组

struct qry{ // 用来存子弹
	int x,i; // x: 射出位置, i: 射出时间
	bool operator<(const qry& q) const {
		// 按位置为第一关键字，时间为第二关键字排序
		return x ^ q.x ? x < q.x : i < q.i;
	}
} Q[maxn];

namespace Blk{ } // 分块求区间 k 小

int main(){
	read(n,m);
	rep(i,1,n) read(L[i],R[i],S[i]); // 读入木板
	rep(i,1,m) Q[i].i = i,read(Q[i].x); // 读入子弹
	std::sort(Q + 1,Q + m + 1); // 排序
	rep(i,1,m) b[i] = Q[i].i,c[i] = Q[i].x; // 得到 b,c 数组
	Blk::init(); // 分块预处理，求 b 数组的区间 k 小
	rep(i,1,M){ // M 是子弹的位置的范围
		l[i] = std::lower_bound(c + 1,c + m + 1,i) - c;
		r[i] = std::upper_bound(c + 1,c + m + 1,i) - 1 - c;
		// lower_bound(bg,ed,x)->第一个大于等于 x 的位置 
        // upper_bound(bg,ed,x)->第一个大于 x 的位置
        // upper_bound-1 就是区间最后一个小于等于 x 的数的位置
	}
	rep(i,1,n){
		if(r[R[i]] - l[L[i]] + 1 < S[i]) continue;
		// 这句特判非常重要，否则会出现 l>r 的情况
		++a[Blk::kth(l[L[i]],r[R[i]],S[i])]; // 计算 kth，用桶统计
	}
	rep(i,1,m) print(a[i],'\n'); // 输出
	return flush(),0;
}
```

---

## 作者：MuYC (赞：7)

#### 前言

关于本题， $O(n \log^2 n)$ 的主席树做法它去世了，非常的卡，因为本屑人不喜欢写二分一般用倍增代替，然后直接爆零（倍增一定会跑满，而二分跑不满，所以说二分应该能过），于是这里来讲 $O(n\log n)$ 的主席树做法。

#### 关于本题：

首先我们可以转化，把每颗子弹射出后打碎的模板转化为有多少个木板是在当前子弹被打碎的。 然后我们就可以得到一个 $O(n \log_2 2 * 10^5 * \log_2 n)$ 的做法：

二分每一个木板在哪一块被会被打烂，然后就变成了询问区间 $(1,mid)$ 内有多少个子弹是在 $[l_i,r_i]$ 内的。倘若得到的结果大于等于 $S_i$ ，那么 $r = mid$ ，否则 $l = mid + 1$。

然后因为主席树必须跑满 $\log_2 (2*10^5)$ 次而且常数巨大，你就获得了 $0pts$ 的好成绩(正确性没有问题):

#### Code $0pts$

```cpp
#include <iostream>
#include <math.h>
using namespace std;
char buf[1 << 21], *p1= buf, *p2 = buf;
#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1 ++)
#define mid ((l + r) >> 1)
inline int read() {
    int x = 0, flag = 1;
    char ch = getchar();
    for( ; ch > '9' || ch < '0' ; ch = getchar()) if(ch == '-') flag = -1;
    for( ; ch >= '0' && ch <= '9' ; ch = getchar()) x = (x << 3) + (x << 1) + ch - '0';
    return x * flag;
}
const int MAXN = 2e5 + 50;
int n, m, root[MAXN], nowcnt = 1;
int Ans[MAXN];
struct Segment {
    int l, r, S;
} S[MAXN];

struct SegmentTree {
    int ls, rs, sum;
} T[MAXN << 6];

int insert(int x, int l, int r, int pos) {
    int cur = ++ nowcnt;
    T[cur] = T[x], T[cur].sum ++;
    if(l == r) return cur;
    if(pos <= mid) T[cur].ls = insert(T[cur].ls, l, mid, pos);
    else T[cur].rs = insert(T[cur].rs, mid + 1, r, pos);
    return cur;
}

int Get(int u, int v, int l, int r, int L, int R) {
    if(l >= L && r <= R) return T[v].sum - T[u].sum;
    int res = 0;
    if(L <= mid) res += Get(T[u].ls, T[v].ls, l, mid, L, R);
    if(R  > mid) res += Get(T[u].rs, T[v].rs, mid + 1, r, L, R);
    return res;
}

int main() {
    n = read(), m = read(); root[0] = 1;
    for(int i = 1 ; i <= n ; i ++)
        S[i].l = read(), S[i].r = read(), S[i].S = read();
    for(int i = 1 ; i <= m ; i ++) {
        int x = read();
        root[i] = insert(root[i - 1], 1, 2e5, x);
    }
    for(int i = 1 ; i <= n ; i ++) {
        int V = S[i].S, L = S[i].l, R = S[i].r, now = m;
        if(Get(root[0], root[m], 1, 2e5, L, R) < V) continue;
        for(int j = log2(now) ; j >= 0 ; j --) {
            int C = now - (1 << j);
            if(C > 0 && Get(root[0], root[C], 1, 2e5, L, R) >= V) now = C;
        }
        Ans[now] ++;
    }
    for(int i = 1 ; i <= m ; i ++) printf("%d\n", Ans[i]);
    return 0;
}
```

+ 如何进一步优化复杂度？

可以想到，第 $i$ 块木板一定是被第 $S_i$ 颗击中它的子弹打碎的。于是我们现在需要知道第 $S_i$ 个击中它的子弹是哪一颗，那么实际上我们要求的就是区间 $[L_i,R_i]$ 内第 $S_i$ 个出现的子弹是哪一颗。

可以想到把子弹的出现位置 $x_i$ 作为下标，出现的时间 $id_i$ 作为数值，实际上我们就是要求 $x_i$ 在区间 $[L_i,R_i]$ 的子弹中第 $S_i$ 大的 $id$ 值是哪一个。经典的 **静态查询第 $k$ 大问题** 对应的用主席树维护一下。

建树的过程即先把 $x_i$ 按照从小到大排序，用一个指针扫即可。写的时候注意有些木板可能并不会被击碎，特判一下。

时空复杂度均为: $O(n \log n)$

具体可以看代码。

#### Code $100pts$

```cpp
#include <iostream>
#include <math.h>
#include <algorithm>
using namespace std;
char buf[1 << 21], *p1= buf, *p2 = buf;
#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1 ++)
#define mid ((l + r) >> 1)
inline int read() {
    int x = 0, flag = 1;
    char ch = getchar();
    for( ; ch > '9' || ch < '0' ; ch = getchar()) if(ch == '-') flag = -1;
    for( ; ch >= '0' && ch <= '9' ; ch = getchar()) x = (x << 3) + (x << 1) + ch - '0';
    return x * flag;
}
const int MAXN = 2e5 + 50;
int n, m, root[MAXN], nowcnt = 1;
int Ans[MAXN];
struct Point {
    int pos, id; // pos 表示出现位置，id 表示出现时间 
} A[MAXN];
struct Segment {
    int l, r, S; // 同题意
} S[MAXN];

struct SegmentTree {
    int ls, rs, sum;
} T[MAXN << 6];//理论开到 MAXN * 20 即可，防挂开大点.....

int insert(int x, int l, int r, int pos) { // 主席树插入一个值
    int cur = ++ nowcnt;
    T[cur] = T[x], T[cur].sum ++;
    if(l == r) return cur;
    if(pos <= mid) T[cur].ls = insert(T[cur].ls, l, mid, pos);
    else T[cur].rs = insert(T[cur].rs, mid + 1, r, pos);
    return cur;
}

int Get(int u, int v, int l, int r, int k) { // 获取第 K 大 
    if(l == r) return l;
    int sum = T[T[v].ls].sum - T[T[u].ls].sum;
    if(k <= sum) return Get(T[u].ls, T[v].ls, l, mid, k);
    else return Get(T[u].rs, T[v].rs, mid + 1, r, k - sum);
}

bool cmp(Point a, Point b){return a.pos < b.pos;}

int main() {
    n = read(), m = read(); root[0] = 1;
    for(int i = 1 ; i <= n ; i ++)
        S[i].l = read(), S[i].r = read(), S[i].S = read();
    for(int i = 1 ; i <= m ; i ++) A[i].pos = read(), A[i].id = i;
    sort(A + 1 , A + 1 + m, cmp);
    int now = 1;
    for(int i = 1 ; i <= 2e5 ; i ++) {
        root[i] = root[i - 1]; // 直接继承，防止出现空节点
        while(A[now].pos == i) // 出现在当前枚举到的位置的子弹全都插入主席树
        root[i] = insert(root[i], 1, n, A[now].id), now ++;
    }
    for(int i = 1 ; i <= n ; i ++) {
        int K = S[i].S, L = S[i].l, R = S[i].r;
        if(K > T[root[R]].sum - T[root[L - 1]].sum) continue;//特判没有被击碎的木板
        Ans[Get(root[L - 1], root[R], 1, n, K)] ++; //对应答案 ++
    }
    for(int i = 1 ; i <= m ; i ++) printf("%d\n", Ans[i]);
    return 0;
}
```

---

## 作者：critnos (赞：7)

大概是为数不多的空间 $O(n)$ 做法。

可以把题目转化为每个木板被哪个子弹击中了。

把子弹作为序列，然后无脑分块，维护每个块排序的结果。

每次扫过所有的块，二分这个块中有多少个子弹是在 $[x,y]$ 内的，扫到了就暴力扫这一块内的元素。

块长 $b=\sqrt {n\log n}$，单次查询复杂度 $O(\dfrac n b \times \log b+b)=O(\sqrt {n\log n})$ 的。

就搞完了？超好写。要开 O2

不过应该是所有做法里面最慢的。

我还有口胡出的另一种分块是时空 $O(n\sqrt n)$ 的，不过没有意义。

```cpp
#include<bits/stdc++.h>
#define lowbit(x) (x&-x)
using namespace std;
const int n=2e5+5;
const int mxb=sqrt(n*log2(n))+5;
int lg;
int st[n];
int size[mxb];
int ans[n];
int x[n],y[n],s[n];
int a[n];
int l[mxb],r[mxb],bl[n];
int m,b,cnt;
void init(int n)
{
	int i,j;
	b=sqrt(n*log2(n));
	lg=log2(b);
	for(i=1;i<=n;i+=b)
		l[++cnt]=i,r[cnt]=min(i+b-1,n);
	for(i=1;i<=n;i++)
		st[i]=a[i];
	for(i=1;i<=cnt;i++)
	{
		for(j=l[i];j<=r[i];j++)
			bl[j]=i;
		sort(st+l[i],st+r[i]+1);
	}
}
int ask(int k,int p)
{
	int w=l[k]-1,i;
	for(i=1<<lg;i>=1;i>>=1)
		if(w+i<=r[k]&&st[w+i]<=p)
			w+=i;
	return w;
}
int t[n];
void add(int x)
{
	for(;x<=n-5;x+=lowbit(x))
		t[x]++;
}
int ask(int x)
{
	int s=0;
	for(;x;x-=lowbit(x))
		s+=t[x];
	return s;
}
void add(int x,int y,int s)
{
	if(ask(y)-ask(x-1)<s) return;
	int i,sum,j;
	for(i=1;i<=cnt;i++)
	{
		sum=ask(i,y)-ask(i,x-1);
		if(s-sum<=0)
		{
			for(j=l[i];j<=r[i];j++)
			{
				s-=a[j]>=x&&a[j]<=y;
				if(s<=0)
				{
					ans[j]++;
					return;
				}
			}
		}
		s-=sum;
	}
}
int read()
{
	int s=0;
	char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s;
}
int main()
{
	int n,i;
	n=read(),m=read();
	for(i=1;i<=n;i++)
		x[i]=read(),y[i]=read(),s[i]=read();
	for(i=1;i<=m;i++)
		a[i]=read(),add(a[i]);
	init(m);
	for(i=1;i<=n;i++)
		add(x[i],y[i],s[i]);
	for(i=1;i<=m;i++)
		printf("%d\n",ans[i]);
}
```


---

## 作者：wdgm4 (赞：6)

好像题解里很多就是整体二分耶。QWQ

~~整体二分是什么，能吃吗？~~

## 前言

由于本蒟蒻不会整体二分，所以这里是一篇主席树的题解。

## 正文

这里运用到了一个做题时的经典套路：**转化题意**。就是平时做线段树、主席树的题，都是先在线段树中放东西，然后查询时直接进入树里乱搞。其实我们可以把本来要查询的放到线段树中再将本来放在线段树中的东西进行查询，再将答案放入本来要查询的数组里。（大概就是这个意思）QWQ

那这道题，我们就可以将题意转化成一个木板被所有子弹打，打到第几个子弹时木板会碎。

恭喜你，这样这道题就已经做出一半了。

之后要想的是，如何将刚才转化后的题意用一种优秀的算法实现。

这里我要说的是，即使你是为了练习主席树而做的这道题，不要直接带入主席树，而是先将它具体化，去探索它的解法，当发现它需要求一个静态区间第 $k$ 小，再去想主席树如何实现。~~不要像我一样，想都不想直接往主席树那里乱搞，突然发现好像主席树没法做而去借鉴题解。QWQ~~

形象化，可以说是对于第 $i$ 个木板，答案要加在区间 $[l_i,r_i]$ 的中时间第 $s_i$ 个子弹上（时间就是第几个出现的时间就是几）。如果直接用主席树板子的话肯定不行（~~我就是直接用的板子~~），所以要有一个桶，存第 $i$ 个位置的子弹的时间，由于可能有多个子弹在同一位置发射，所以要用 `vector` 存。还有就是可能有的地方没有子弹发射，这个地方要存一个比所有时间更大的值（比如说 $m+1$）。

这样就可以用主席树维护了。

## 代码

```cpp
#include<bits/stdc++.h>
#define XD 114514
#define MAXN 200010
using namespace std;
int n,m;
vector<int> a[MAXN];
struct QWQ{
	int l,r,s;
} q[MAXN];
int ans[MAXN];
struct tree{
	int l,r,val;
} t[MAXN*80];
int top[MAXN],cnt;
int modify(int x,int l,int r,int k){//和主席树板子没有区别
	int nem=++cnt;t[nem]=t[x];t[nem].val++;
	if(l==r) return nem;
	int mid=l+r>>1;
	if(k<=mid) t[nem].l=modify(t[x].l,l,mid,k);
	else t[nem].r=modify(t[x].r,mid+1,r,k);
	return nem;
}
int query(int x,int y,int l,int r,int k){
	int nem=t[t[y].l].val-t[t[x].l].val;
	if(l==r) return l;
	int mid=l+r>>1;
	if(k<=nem) return query(t[x].l,t[y].l,l,mid,k);
	else return query(t[x].r,t[y].r,mid+1,r,k-nem); 
}
int main(){
	ios::sync_with_stdio(false);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>q[i].l>>q[i].r>>q[i].s;
	}
	for(int i=1;i<=m;i++){
		int x;cin>>x;
		a[x].push_back(i);
	}// 下面的 2e5 是位置最大值
	for(int i=1;i<=2e5;i++) if(!a[i].size()) a[i].push_back(m+1);
	for(int i=1;i<=2e5;i++){
		top[i]=top[i-1];
		for(int j=0;j<a[i].size();j++){
			top[i]=modify(top[i],1,m+1,a[i][j]);
		}
	}
	for(int i=1;i<=n;i++){
		int nem=query(top[q[i].l-1],top[q[i].r],1,m+1,q[i].s);
		if(nem==m+1) continue;//m+1 
		ans[nem]++;
	}
	for(int i=1;i<=m;i++) cout<<ans[i]<<"\n";
	return 0;
}

```


---

## 作者：Terac (赞：6)

[**原题**](https://www.luogu.com.cn/problem/P7424)  

本题有很多种做法，这里提供了一种应该是理论时间复杂度最优的 $O(n\log n)$ 的主席树做法，但因为常数巨大被整体二分吊打……  

题目描述挺好理解的，问题在于怎么转换题意。  

直接顺着题意在线做复杂度肯定是不行的，简单思考后发现把题意转化成求每个木板被哪颗子弹击中即可。  

对于第 $i$ 块木板所在的位置 $l_i$ 至 $r_i$，可视为区间 $\left[l_i,r_i\right]$，而击碎它的子弹就是第 $s_i$ 颗击中它的子弹。  

于是想到一个典型的问题：静态区间第 k 小。  

这里的关键字是每颗子弹发射的先后顺序，对于 $x$ 轴上的第 $j$ 个点记一个 $t_j$，表示在点 $j$ 上的子弹发射的顺序编号，若点 $j$ 上没有发射过子弹，$t_j\gets\inf$。对于区间 $\left[l_i,r_i\right]$，查询此区间内第 $S_i$ 大的 $t_j$ 并返回点 $j$ 上查询到的子弹。  

于是可以用主席树处理这样的问题，时间复杂度即为主席树的 $O(n\log n)$，空间 $O(n\log n)$。  

有个重要的内容，每个点上可能有多个子弹，所以每个点开一个 `vector`，然后把该点所存的所有子弹顺序编号都放进主席树的这棵分树中，不影响区间查询的正确性。因此主席树的空间也要开大一倍，来处理所有的子弹都在一个点的那种极限数据。  

这道题还是挺好想的，思维量不大也很好写。  

具体的某些实现可以看看代码。  

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 10, LOG = 20, inf = 1e9;
int n, m, t;
int l[N], r[N], s[N], ans[N];
int rt[N], val[N << 1];
int cnt;
vector <int> a[N]; 
struct President_Tree {
	int sum, l, r;
} tree[(N << 1) * LOG];
void build(int &node, int l, int r) {
	node = ++cnt;
	tree[node].sum = 0;
	if(l == r) 
		return;
	int mid = l + r >> 1;
	build(tree[node].l, l, mid);
	build(tree[node].r, mid + 1, r);
}
void update(int &node, int pre, int l, int r, int x) {
	node = ++cnt;
	tree[node] = tree[pre];
	tree[node].sum = tree[pre].sum + 1;
	if(l == r) 
		return;
	int mid = l + r >> 1;
	if(x <= mid)
		update(tree[node].l, tree[pre].l, l, mid, x);
	else 
		update(tree[node].r, tree[pre].r, mid + 1, r, x);
}
int query(int u, int v, int l, int r, int k) {
	int ans, mid = l + r >> 1, x = tree[tree[v].l].sum - tree[tree[u].l].sum;
	if(l == r) 
		return l;
	if(x >= k) 
		ans = query(tree[u].l, tree[v].l, l, mid, k);
	else 
		ans = query(tree[u].r, tree[v].r, mid + 1, r, k - x);
	return ans;
}
int main() {
	scanf("%d%d", &n, &t);
	for(int i = 1; i <= n; i++)
		scanf("%d%d%d", &l[i], &r[i], &s[i]);
	for(int i = 1; i <= 2e5; i++) {
		val[++m] = inf;
		a[i].push_back(inf);
	}
	for(int i = 1; i <= t; i++) {
		int x;
		scanf("%d", &x);
		if(a[x][0] == inf)
			val[x] = a[x][0] = i;
		else {
			val[++m] = i;
			a[x].push_back(i);
		}
	}
	sort(val + 1, val + 1 + m);
	m = unique(val + 1, val + 1 + m) - val - 1;
	build(rt[0], 1, m);
	for(int i = 1; i <= 2e5; i++) {
		a[i][0] = lower_bound(val + 1, val + 1 + m, a[i][0]) - val;
		update(rt[i], rt[i - 1], 1, m, a[i][0]);
		for(int j = 1; j < a[i].size(); j++)
			update(rt[i], rt[i], 1, m, a[i][j]);
	}
	for(int i = 1; i <= n; i++) {
		int res = query(rt[l[i] - 1], rt[r[i]], 1, m, s[i]);
		if(val[res] != inf)
			ans[val[res]]++;
	}
	for(int i = 1; i <= t; i++)
		printf("%d\n", ans[i]);
	return 0;
}
```

---

## 作者：Alex_Wei (赞：5)

[P7424 [THUPC2017] 天天爱射击](https://www.luogu.com.cn/problem/P7424)

既然主席树可以 $\mathcal{O}(n\log n)$，为什么整体二分不可以呢？

考虑整体二分，将问题转化为单点修改区间求和，但所有修改在查询之前，可以直接差分。问题在于向下递归时，我们不能直接下传原有坐标，否则每个区间处理的复杂度均为 $\mathcal{O}(n)$。

解决方法非常简单。在处理每个 $\mathrm {solve}$ 前，将所有相关下标离散化。这里离散化可以直接用桶维护而不需要排序，因为复杂度和它父区间离散化后的值域相关，加起来还是 $\mathcal{O}(n\log n)$ 的。

一个有趣的事实：本题和 P3527 几乎没有区别。

以相当大的优势（2.23s）获得了最优解（2022.11.18）。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define TIME 1e3 * clock() / CLOCKS_PER_SEC

constexpr int N = 2e5 + 5;
int n, m, x[N], d[N], res[N], ans[N];
struct board {
  int l, r, S;
} c[N], _c[N];
void solve(int l, int r, int cl, int cr, int range) {
  if(cl > cr) return;
  if(l == r) return ans[l] = cr - cl + 1, void();
  for(int i = 1; i <= range; i++) d[i] = 0;
  for(int i = l; i <= r; i++) d[x[i]] = 1;
  for(int i = 2; i <= range; i++) d[i] += d[i - 1];
  for(int i = l; i <= r; i++) x[i] = d[x[i]];
  for(int i = cl; i <= cr; i++) c[i].l = d[c[i].l - 1] + 1, c[i].r = d[c[i].r];
  range = d[range];
  int m = l + r >> 1, cm = cl - 1, cd;
  for(int i = 1; i <= range; i++) d[i] = 0;
  for(int i = l; i <= m; i++) d[x[i]]++;
  for(int i = 2; i <= range; i++) d[i] += d[i - 1];
  for(int i = cl; i <= cr; i++) {
    res[i] = d[c[i].r] - d[c[i].l - 1];
    if(c[i].S <= res[i]) _c[++cm] = c[i];
  }
  cd = cm;
  for(int i = cl; i <= cr; i++) if(c[i].S > res[i]) c[i].S -= res[i], _c[++cm] = c[i];
  for(int i = cl; i <= cr; i++) c[i] = _c[i];
  solve(l, m, cl, cd, range), solve(m + 1, r, cd + 1, cr, range);
}
int main() {
  #ifdef ALEX_WEI
    FILE* IN = freopen("1.in", "r", stdin);
    FILE* OUT = freopen("1.out", "w", stdout);
  #endif
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  cin >> n >> m;
  for(int i = 1; i <= n; i++) cin >> c[i].l >> c[i].r >> c[i].S;
  for(int i = 1; i <= m; i++) cin >> x[i];
  x[m + 1] = 1, solve(1, m + 1, 1, n, 200000);
  for(int i = 1; i <= m; i++) cout << ans[i] << "\n";
  return cerr << "Time: " << TIME << " ms\n", 0;
}
```

---

## 作者：Mini_PEKKA (赞：3)

## Preface

这是一篇整体二分的题解，如果你不完全熟悉整体二分的思想，可以将这篇题解作为参考。

## Solution

#### 算法思想：

计木板 $i$ 左端点的 $x$ 坐标为 $lx_i$，右端点的 $x$ 坐标为 $rx_i$，贯穿 $s_i$ 次会碎掉。

二分每一块木板会被那个子弹打碎，然后将那个子弹击碎的木板数加 $1$。

计当前二分的区间为 $l$ 到 $r$，表示二分到目前为止的所有木板都会被第 $l$ 到 $r$ 中的某个子弹击碎，$mid=\frac{l+r}{2}$。

假设所有木板都被第 $mid$ 个子弹打碎，然后检验每一块木板是否被第 $mid$ 及以前的子弹打碎，从而将所有木板分成两类。

#### 检验方法：

将第 $mid$ 个及以前的所有子弹以其 $x$ 坐标为位置插入到树状数组中，贡献为 $1$。对于每一块木板 $i$，查询树状数组中 $lx_i$ 到 $rx_i$ 的和，
得出第 $mid$ 个及以前的所有子弹中有多少个子弹打在了 $lx_i$ 到 $rx_i$ 内，计为 $cnt$。如果 $s_i \le cnt$，木板 $i$ 会被打碎，反之不会。

#### 分治区间：

分类后，对于会被打碎的一类，在 $l$ 到 $mid$ 区间中处理，另一类则在 $mid+1$ 到 $r$ 区间中处理。直到 $l$ 等于 $r$，一定会被第 $l$ 到 $l$ 个的子弹打碎，那么这块木板一定被第 $l$ 个子弹打碎，于是给第 $l$ 个子弹的击碎木板数加 $1$。

但如果每次都遍历所有子弹并将编号小于等于 $mid$ 的子弹插入到树状数组中，时间复杂度过高，所以考虑去除冗余部分。

#### 去除冗余：

计 $mid_1=\frac{l+r}{2}$，$mid_2=\frac{l+mid}{2}$，$mid_3=\frac{mid+1+r}{2}$，可以证明 $mid_2 \le mid_1 \le mid_3$。

因为在 $l$ 到 $mid_1$ 区间中只有在第 $mid_2$ 个及以前的子弹会对树状数组有贡献，所以可以排除第 $mid_1+1$ 到 $r$ 个子弹，只保留第 $l$ 到 $mid_1$ 个子弹。

计第 $mid_1$ 个及以前的子弹在 $lx_i$ 到 $rx_i$ 内的个数为 $cnt_1$，
第 $mid_1+1$ 个子弹到第 $mid_3$ 个子弹在 $lx_i$ 到 $rx_i$ 内的个数为 $cnt_2$，第 $mid_3$ 个及以前的子弹在 $lx_i$ 到 $rx_i$ 内的个数为 $cnt_3$，则 $cnt_3=cnt_1+cnt_2$。于是可以把 $s_i$ 与 $cnt_3$ 的比较，转化为 $s_i$ 与 $cnt_1+cnt_2$ 的比较，进一步转化为 $s_i-cnt_1$ 与 $cnt_2$ 的比较，所以可以在 $l$ 到 $r$ 区间内检验木板 $i$ 是否被击碎时直接将 $s_i$ 减去 $cnt_1$，只保留第 $mid_1$ 个以后的子弹。

#### 注意事项：

1. 要将树状数组的上界设为所有木板右端点 $x$ 坐标的最大值。
2. 一块木板有可能不会被任何子弹击碎，只需把二分的区间设为 $1$ 到 $m+1$ 就可以了。

## Code

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 2e5 + 5, M = 2e5 + 5, X = 2e5 + 5;
int bit_size, ans[M];
struct board {
	int x_l, x_r, s, id;
};
vector<board> bd;
struct bullet {
	int x, id;
};
vector<bullet> bt;
struct BIT {
	int c[X];
	int lowbit(int i) {
		return i & (-i);
	}
	void update(int x, int val) {
		for (; x <= bit_size; x += lowbit(x))
			c[x] += val;
	}
	int query(int x) {
		int sum = 0;
		for (; x; x -= lowbit(x))
			sum += c[x];
		return sum;
	}
} b;
void binsearch(int l, int r, vector<bullet> &bt, vector<board> &bd) {
	if (!bd.size())
		return;
	if (l == r) {
		ans[l] += bd.size();
		return;
	}
	vector<bullet> bt_l, bt_r;
	vector<board> bd_l, bd_r;
	int mid = (l + r) >> 1;
	for (auto i : bt) {
		if (i.id <= mid) {
			b.update(i.x, 1);
			bt_l.push_back(i);
		}
		else
			bt_r.push_back(i);
	}
	for (auto i : bd) {
		int cnt = b.query(i.x_r) - b.query(i.x_l - 1);
		if (i.s <= cnt)
			bd_l.push_back(i);
		else {
			i.s -= cnt;
			bd_r.push_back(i);
		}
	}
	for (auto i : bt_l)
		b.update(i.x, -1);
	binsearch(l, mid, bt_l, bd_l);
	binsearch(mid + 1, r, bt_r, bd_r);
}
signed main() {
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	int n, m, x_l, x_r, s, x;
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		cin >> x_l >> x_r >> s;
		bd.push_back({ x_l, x_r, s, i });
		bit_size = max(bit_size, x_r);
	}
	for (int i = 1; i <= m; i++) {
		cin >> x;
		bt.push_back({ x, i });
	}
	binsearch(1, m + 1, bt, bd);
	for (int i = 1; i <= m; i++)
		cout << ans[i] << '\n';
	cout << flush;
	return 0;
}
```

---

## 作者：苏联小渣 (赞：2)

一道比较简单的题，但是出题人把 $O(n \log^2 n)$ 的线段树完美地卡掉了。

我们思考询问是要求什么：对于一个询问的点 $x$，查询存在几个题目给出的线段，满足 $l_i \le x \le r_i$ 且 $x$ 是第 $s_i$ 个满足这个条件的点。

这个问题一脸写着不可在线，而且它和时间关系密切，所以很容易想到一种离线的思路：我们对每一个询问建立一棵以值域为下标的线段树，第 $i$ 次询问 $x_i$，基于第 $i-1$ 个版本，把 $x_i$ 单点加一。接着枚举每个线段，看这个线段在第几次被击碎。这个东西的充要条件就是找到 $p$ 使得第 $p$ 个询问的版本中，$[l_i,r_i]$ 的区间和恰好为 $s_i$，且第 $p-1$ 个版本区间和 $<s_i$。这个区间和显然单调不减，于是二分答案，判断第 $mid$ 个版本中区间 $[l_i,r_i]$ 的和与 $s_i$ 的关系即可。

交上去就会发现全部 TLE 得死死的。经过一系列卡常后自己造的数据卡到了 1s 以内，但是交上去依然 1.20s+。可见出题人用心良苦。

我们发现这个二分答案的 check 其实很废，它没有用到可持久化线段树的精髓，就是查询区间和值域有关的信息。我们再看看要求什么：找到第 $s_i$ 个满足这个条件的点，也就是说，我们要找到询问顺序第 $s_i$ 小的满足这个关系的点。到了这里就已经很清晰了，这个就是求区间第 $k$ 小的问题。具体来说，我们对于每个值域上的点（就是每一个坐标），建立一棵以询问顺序为下标的线段树。注意到这个建树方式和上面的恰好反了过来。把询问排序，记录它是第 $d$ 次询问（我们记录**原本**第 $d$ 次询问的点是 $q_d=x$），询问的点坐标是 $x$。按 $x$ 从小到大排序，到了每一个 $x$，在第 $x-1$ 个版本的基础上，把所有满足 $q_d=x$ 的 $d$ 加入第 $x$ 棵线段树中。然后对于每一条线段，查询区间 $[l_i,r_i]$ 的第 $s_i$ 小的值即可做到 $O(n \log n)$。

需要注意的细节是会有多个 $d$ 满足 $q_d=x$，这样可持久化的时候就要进行一些操作避免版本乱了。具体可以参考代码。

### Code：

```c++
#include <bits/stdc++.h>
using namespace std;
#define N 200000
int n, m, l, r, x, mx, now, cnt, lst, ans[200010], t[200010];
struct node{
	int l, r, val;
}a[200010];
struct ask{
	int x, y;
	bool operator < (const ask &A) const{
		return x < A.x;
	}
}q[200010];
struct segment{
	int l, r, s;
}d[5000010];
void modify(int &p, int lst, int l, int r, int x){
	if (!p || p == lst) d[p=++cnt]=d[lst];
	d[p].s ++;
	if (l == r) return ;
	int mid = l + r >> 1;
	if (x <= mid) modify(d[p].l, d[lst].l, l, mid, x);
	else modify(d[p].r, d[lst].r, mid+1, r, x);
}
int query(int p, int lst, int l, int r, int x){
	if (x > d[p].s - d[lst].s) return 0;
	if (l == r) return l;
	int mid = l + r >> 1, dif = d[d[p].l].s - d[d[lst].l].s;
	if (dif >= x) return query(d[p].l, d[lst].l, l, mid, x);
	else return query(d[p].r, d[lst].r, mid+1, r, x-dif);
}
int main(){
	scanf ("%d%d", &n, &m);
	for (int i=1; i<=n; i++){
		scanf ("%d%d%d", &a[i].l, &a[i].r, &a[i].val);
		mx = max(mx, a[i].r);
	}
	for (int i=1; i<=m; i++){
		scanf ("%d", &q[i].x);
		q[i].y = i;
	}
	sort (q+1, q+m+1);
	for (int i=1; i<=m; i++){
		for (int j=lst+1; j<q[i].x; j++){
			t[j] = t[j-1];
		}
		modify(t[q[i].x], t[q[i].x-1], 1, N, q[i].y);
		lst = q[i].x;
	}
	for (int i=lst+1; i<=mx; i++) t[i] = t[i-1];
	for (int i=1; i<=n; i++){
		now = query(t[a[i].r], t[a[i].l-1], 1, N, a[i].val);
		ans[now] ++;
	}
	for (int i=1; i<=m; i++){
		printf ("%d\n", ans[i]);
	}
	return 0;
}
```

---

## 作者：Utilokasteinn (赞：2)

## [Link](https://www.luogu.com.cn/problem/P7424)

题目大意：

$x$ 轴上有 $n$ 条线段，依次放入 $m$ 个点，若第 $i$ 条线段上有 $s_i$ 个点，这条线段便会消失。问放入第 $i$ 个点时会消失几条线段。

观察问题后可以发现，可以将问题转变为第 $i$ 块木板是否会被打碎，若打碎就将打碎它的子弹的答案数加 $1$。要求第 $i$ 木板是哪个子弹打碎的，就是求第 $s_i$ 个打在区间 $[l,r]$ 的子弹。

也就是求区间 $[l,r]$ 的第 $s_i$ 小值，这就转变为我们所熟悉的静态求区间第 $k$ 小值。

注意可能有多个子弹打在同一个位置上，这个时候需要按顺序加入主席树。还有就是要判断该区间的子弹数是否超过 $s_i$，否则根本就没有第 $s_i$ 小值。

时间复杂度： $O(n\log m)$。

空间复杂度： $O(n\log m)$。

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,tot,maxn;
int l[200005],r[200005],cnt[200005];
int root[200005],ans[200005];
vector<int>a[200005];
struct tree{
	int ls,rs,cnt;
}s[4000000];
inline int read()
{
	int s=0;char c=getchar();
	for(;!isdigit(c);c=getchar());
	for(;isdigit(c);c=getchar())
		s=s*10+c-'0';
	return s;
}
int update(int l,int r,int pre,int pos)//更新 
{
	int p=++tot;
	s[p]=s[pre];
	s[p].cnt++;
	if(l<r)
	{
		int mid=(l+r)/2;
		if(pos<=mid)
			s[p].ls=update(l,mid,s[pre].ls,pos);
		else s[p].rs=update(mid+1,r,s[pre].rs,pos);
	}
	return p;
}
int query(int l,int r,int k,int p1,int p2)//查询区间[l,r]的第k小值 
{
	if(l==r)return l;
	int mid=(l+r)/2,res=s[s[p2].ls].cnt-s[s[p1].ls].cnt;
	if(res>=k) 
		return query(l,mid,k,s[p1].ls,s[p2].ls);
	return query(mid+1,r,k-res,s[p1].rs,s[p2].rs);
}
int main()
{
	n=read(),m=read();
	for(int i=1;i<=n;i++)
		l[i]=read(),r[i]=read(),cnt[i]=read(),maxn=max(maxn,r[i]);
	for(int i=1;i<=m;i++)
	{
		int x=read();
		maxn=max(maxn,x);
		a[x].push_back(i);//a[x][i]表示第i个打在位置x的子弹的时间 
	}
	for(int i=1;i<=maxn;i++)//按顺序依次插入 
	{
		if(!a[i].size())
		{
			root[i]=root[i-1];
			continue;
		}
		root[i]=update(1,m,root[i-1],a[i][0]);
		for(int j=1;j<a[i].size();j++)
			root[i]=update(1,m,root[i],a[i][j]);
	}
	for(int i=1;i<=n;i++)
	{
		if(cnt[i]>s[root[r[i]]].cnt-s[root[l[i]-1]].cnt)continue;//若区间的数小于cnt[i]个 
		ans[query(1,m,cnt[i],root[l[i]-1],root[r[i]])]++;
	}
	for(int i=1;i<=m;i++)
		printf("%d\n",ans[i]);//依次输出每个子弹打碎的木板数 
	return 0;
}
```
谢谢观赏。

---

## 作者：Tan_Wei_Ye (赞：1)

记录一下自己学的新算法 & 用新算法独立过的第一道题

## 整体二分
**适用情况** ：
1. 能二分的(废话)，但普通二分过不了的。
2. 询问能离线的。

拿这题来举例子：

显然我们可以对于每块木板二分出它被击碎的时间，单块木板的时间为 $O(m \ \log_2m)$,所以总时间复杂度为 $O(n m\ \log_2m)$,不能通过这道题。

我们注意到，这些询问时可以离线下来的，那么考虑整体二分。

我们把所有询问放在一起进行二分。我们设计一个函数 $solve(l,r,x,y)$ ，来检查 $[x,y]$ 的木板是否能被 $[l,r]$ 区间的子弹击碎。

对于当前答案区间 $[l,r]$ ，我们把第 $[l,mid]$ 个子弹射出，用树状数组统计某个区间内共有几个子弹，把能被击碎的木板分为一组，不能的分为一组，然后对于 $2$ 组木板分别递归下去，直到 $l=r$ 时，我们统计答案。

**时间复杂度** ：

这部分可以参考线段树的分析：我们总的答案区间长度为 $m$。
我们每次把答案区间折半，直到左右端点相同为止，所以 $solve$ 函数的层数为 $\log_2m$ 层，而每次执行 $solve$ 函数时，因为用到了树状数组，所以一次 $solve$ 的时间是 $ O((n+m)\ \log_2m)$。

所以总时间复杂度为：$O((n+m)\ \log_2m\ \log_2m)$

（我比较菜，所以这部分可能会有点问题，如果发现错误的，可以私信我）

**代码** ：
```cpp
#include<bits/stdc++.h>
#define int long long 
#define lowbit (x&-x)
using namespace std;

inline int read()
{
    register int x=0,f=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
    while(isdigit(ch)){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
    return x*f;
}
const int N=2e5+10;
const int INF=N;
int n,m,p[N];
int a[N],ans[N];
struct line
{
	int l,r,h;
}w[N],t1[N],t2[N];
void add(int x,int val)
{
	for(;x<N;x+=lowbit)
		a[x]+=val; 
}
int query(int x)
{
	int res=0;
	for(;x;x-=lowbit)
		res+=a[x];
	return res;
}
void solve(int l,int r,int x,int y)
{
	if(l>r || x>y) return ;//查看答案区间是否合法
	if(l==r) return ans[l]=y-x+1,void();//统计答案
	int mid=l+r>>1;
	for(int i=l;i<=mid;i++)	add(p[i],i==m+1?INF:1);	
    //为了方便起见我们生成第 m+1 个子弹，威力为 INF
	int c1=0,c2=0;
	for(int i=x;i<=y;i++)	
	{
		
		int damage=query(w[i].r)-query(w[i].l-1);
		if(w[i].h-damage<=0) t1[++c1]=w[i]; //能被击碎
		else t2[++c2]=w[i],t2[c2].h-=damage; //不能被击碎
	}
	for(int i=l;i<=mid;i++)	add(p[i],i==m+1?-INF:-1);
	for(int i=x;i<=x+c1-1;i++) w[i]=t1[i-x+1];
	for(int i=x+c1;i<=y;i++) w[i]=t2[i-x-c1+1];
		
	solve(l,mid,x,x+c1-1);//递归到下一层
	solve(mid+1,r,x+c1,y);
}
signed main()
{
	n=read(),m=read();
	for(int i=1;i<=n;i++)
		w[i].l=read(),w[i].r=read(),w[i].h=read();
	for(int i=1;i<=m;i++) p[i]=read();
	solve(1,m+1,1,n);
	for(int i=1;i<=m;i++) cout<<ans[i]<<endl;
}
```




---

## 作者：Aisaka_Taiga (赞：1)

首先看到题面暴力肯定是不行的，所以我们需要考虑一些更优秀的做法。

因为我太弱了，所以看了[题解](https://www.luogu.com.cn/blog/WaterAche/solution-p7424)的思路，我试着写一篇更易懂的题解。

我们考虑如何用主席树做，首先对于每一块木板的话并不好处理，所以我们可以对于每一个坐标来进行修改，用主席树维护从 $1$ 到所有坐标（因为不确定所以我们直接从 $1$ 枚举到 $2\times 10^{5}$）中的子弹出现个数，这样我们就得到了一棵储存着前 $i$ 个坐标的子弹的数量的主席树，然后我们对于如何查询每一个子弹击碎了多少木板，我们可以直接枚举木板，然后用主席树查询区间内的第 $s_{i}$ 小的值，也就是击碎它的子弹的坐标，然后给这个点的子弹的答案加一即可。

因为一个坐标可能会有不同时刻的子弹，所以我们直接开 vector 存当前坐标出现的不同时刻的子弹。然后对于一些没有子弹的坐标，我们可以直接存一个 INF，后面如果在查询的时候击碎木板的子弹时刻是 INF 的话，说明此木板没有子弹击碎；需要注意的是，我们在这个先把每一个坐标都插一个 INF，后面当前时刻有子弹在替换，这样后面进行加的操作时一般会导致最后一个时刻的子弹，也就是 INF 时刻的子弹数目非常多（其实也不一定），这样会使每一块木板都会被击碎（因为题目里 $s\le2\times 10^{5}$，前面所有的子弹没有这个击碎木板的话也会被时刻为 INF 的子弹给击碎），这样保证了查询的正常进行。

具体其他细节看注释。

code:

```cpp
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f
#define N 1000100
#define endl '\n'
using namespace std;
int n,m,t,l[N],r[N],s[N],ans[N],rt[N],b[N];
int ls[N<<5],rs[N<<5],val[N<<5],cnt;
vector<int>a[N/5];
inline int read(){int x=0,f=1;char ch=getchar();while(!isdigit(ch)){f=ch!='-';ch=getchar();}while(isdigit(ch)){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}return f?x:-x;}
inline void build(int &x,int l,int r)//建树，普普通通 
{
	x=++cnt;if(l==r)return ;int mid=(l+r)>>1;
	build(ls[x],l,mid);build(rs[x],mid+1,r);
}
inline void add(int &x,int pre,int l,int r,int p)//区间加贡献 
{
	x=++cnt;ls[x]=ls[pre],rs[x]=rs[pre],val[x]=val[pre]+1;//当前点的子弹数加一 
	if(l==r)return ;int mid=(l+r)>>1;
	if(p<=mid)add(ls[x],ls[pre],l,mid,p);//如果在左子树就去左子树里加 
	else add(rs[x],rs[pre],mid+1,r,p);//反之右子树 
}
inline int ask(int u,int v,int l,int r,int k)//查询在那个时刻的子弹碎掉 
{
	int xx=val[ls[v]]-val[ls[u]];//计算这区间内的子弹数量 
	if(l==r)return l;int mid=(l+r)>>1;//如果到了叶子节点就返回当前点 
	if(k<=xx)return ask(ls[u],ls[v],l,mid,k);//如果要是查询的子弹多了，就去左子树继续找 
	else return ask(rs[u],rs[v],mid+1,r,k-xx);//多了就去右子树，要减去当前点左子树的子弹数量 
}
signed main()
{
	n=read();t=read();
	for(int i=1;i<=n;i++)l[i]=read(),r[i]=read(),s[i]=read();
	for(int i=1;i<=2e5;i++)b[++m]=INF,a[i].push_back(INF);//初始化，一开始每一个时刻都没有子弹	
	for(int i=1;i<=t;i++)
	{
		int x=read();
		if(a[x][0]==INF)b[x]=a[x][0]=i;//如果没有子弹就先替换掉并把b里的值换掉 
		else b[++m]=i,a[x].push_back(i);//后面的子弹直接插入到vector后面
	}
	sort(b+1,b+m+1);//对于所有的子弹的时刻排序 
	m=unique(b+1,b+m+1)-b-1;//去重 
	build(rt[0],1,m);//得到m种不同时刻的子弹，建树 
	for(int i=1;i<=2e5;i++) 
	{
		a[i][0]=lower_bound(b+1,b+m+1,a[i][0])-b;//找到在b中的位置并替换成离散化后的值 
		add(rt[i],rt[i-1],1,m,a[i][0]);//加入当前点的贡献 
		for(int j=1;j<a[i].size();j++)//把当前时刻的所有子弹都给加到树上 
		  add(rt[i],rt[i],1,m,a[i][j]);
	}
	for(int i=1;i<=n;i++)//枚举每一个木板 
	{
		int res=ask(rt[l[i]-1],rt[r[i]],1,m,s[i]);//前缀和思想 
		if(b[res]!=INF)ans[b[res]]++;//如果要是碎掉的时刻的子弹不是INF，说明能粉碎 
	}
	for(int i=1;i<=t;i++)cout<<ans[i]<<endl;//输出答案 
	return 0;
}
```


---

## 作者：Sham_Sleep (赞：1)

**整体二分**



------------


 **题面简述** 
 
有 $m$ 块木板，有 $n$ 颗子弹，每克子弹会穿过一个点，每块木板会覆盖一个区间，且有耐久值 $S$ ， 被穿过 $S$ 次就会破碎， 求颗子弹可以打碎多少木板。 		



------------

 **思路** 



------------
* step 1:

题意很简单，转化一下，不看子弹，而是看哪一块木板在哪个子弹打来的时候碎。

再转换一下，将每个子弹看成一个时间点，那么就是求木板破碎的时间。那么题目很简单了。

那就是求每颗子弹对每个木板的贡献。




------------

* step 2 :

问题转化成每块木板被击碎的时间，考虑离线做法。

将木板看成询问操作，子弹看成修改操作，又因为是求区间前 $S$ 个，是不是很熟悉？ ~~甲方爸爸又开口了，又是惯用伎俩~~。 所以考虑整体二分。 

又考虑到有些木板从头至尾都未被击碎，所以值域考虑[1, $m+1$ ] 在　$m+1$ 全部击碎。



------------



 **代码如下** 

```
#include <stdio.h>
#include <iostream>
const int N = 2e5 + 5;

struct node {
	int l, r, pos, val, id, ans, t, cur;
   //id = 1代表子弹
   //id = 2代表木板
} q[N << 1], temp[N << 1];

int n, m, top, Max;
int tree[N], tmp[N << 1], ans[N];
bool mark[N << 1];

int lowbit(int k) {return k & (-k);}

void add(int idx, int val) {
	while(idx <= Max) {
		tree[idx] += val;
		idx += lowbit(idx);
	}
	return ;
}

int sum(int idx) {
	int s = 0;
	while(idx) {
		s += tree[idx];
		idx -= lowbit(idx);
	}
	return s;
}

//统计子弹位置考虑用树状数组。
//x的值域在2e5之内，完全开得下

void Binsea(int l, int r, int L, int R) {
	if(L > R || l > r) return ;
	int mid = L + R >> 1, o = 0;
	if(L == R) {
		for(int i = l; i <= r; ++i)
			if(q[i].id == 2) q[i].ans = L;
		return ;
	}
	
	for(int i = l; i <= r; ++i) {
		if(q[i].t <= mid && q[i].id == 1) add(q[i].pos, 1);
		if(q[i].id == 2) tmp[i] = sum(q[i].r) - sum(q[i].l - 1);
	}
	
	for(int i = l; i <= r; ++i)
		if(q[i].t <= mid && q[i].id == 1) add(q[i].pos, -1);
	
	for(int i = l; i <= r; ++i) {
		if(q[i].id == 1) {
			if(q[i].t <= mid) mark[i] = true, ++o;
			else mark[i] = false;
		}
		else {
			if(tmp[i] + q[i].cur >= q[i].val) mark[i] = true, ++o;
			else mark[i] = false, q[i].cur += tmp[i]; 
		}
	}
	
	int i = l, j = l + o;
	
	for(int k = l; k <= r; ++k) {
		if(mark[k]) temp[i++] = q[k];
		else temp[j++] = q[k];
	}
	
	for(int k = l; k <= r; ++k) q[k] = temp[k];
	
	Binsea(l, i - 1, L, mid);
	Binsea(i, j - 1, mid + 1, R);
	
	return ;
}

int main() {
//	freopen("1.in", "r", stdin); 
//	freopen("1.out", "w", stdout);
	std :: ios :: sync_with_stdio(false);
	std :: cin >> n >> m;
	for(int i = 1; i <= n; ++i) {
		std :: cin >> q[i + m].l >> q[i + m].r >> q[i + m].val;
		Max = std :: max(Max, q[i + m].r);
		q[i + m].id = 2;
	}
   //注意修改操作一定要放在询问操作之前，否则无法计算贡献
	for(int i = 1; i <= m; ++i) {
		std :: cin >> q[i].pos;
		q[i].id = 1;
		q[i].t = i;
	}
	
	Binsea(1, n + m, 1, m + 1);
	
	for(int i = 1; i <= n + m; ++i)
		if(q[i].id == 2) ++ans[q[i].ans]; 
	
	for(int i = 1; i <= m; ++i)
		std :: cout << ans[i] << '\n';
		
	return 0;
}
```
望管理员大大通过QAQ，码题解不容易QAQ

---

## 作者：gyyyyx (赞：0)

[题面](https://www.luogu.com.cn/problem/P7424)

思考发现发射一枚子弹击碎的木板数量，发现其与之前发射过的子弹相关，这样很难维护。

考虑换一种思路，对于每一块木板，询问会被哪一枚子弹击碎。

设第 $i$ 块木板范围为 $[l_i,r_i]$，被贯穿 $s_i$ 次会被击碎；第 $j$ 枚子弹的坐标为 $x_j$。

那么要求的就是满足 $l_i\leq x_j\leq r_i$ 的子弹中第 $s_i$ 小的 $j$。

如果将其看做一个序列，第 $j$ 枚子弹代表 $x_j$ 位置上的数字为 $j$，那问题就转换为静态区间第 k 小了。

可以用整体二分，树套树等方式来解决。



我这里提供整体二分的代码：

```cpp
#include<bits/stdc++.h>
#define N 200005
using namespace std;
int n,m,a[N];
int c[N];
inline int lowbit(int i){return i&-i;}
inline void Add(int i,int v){
	while(i<N){//注意这里代表的是子弹坐标的值域，是N而不是n 
		c[i]+=v;
		i+=lowbit(i);
	}
}
inline int Sum(int i){
	int res(0);
	while(i){
		res+=c[i];
		i-=lowbit(i);
	}
	return res;
}
struct Query{
	int l,r,k,id,type;
	Query(int a=0,int b=0,int c=0,int d=0,int e=0)
	:l(a),r(b),k(c),id(d),type(e){}
};
struct Query Q[N<<1];
struct Query q1[N<<1],q2[N<<1];
int ans[N];
void Solve(int l,int r,int ql,int qr){
	if(ql>qr) return;
	if(l==r){
		for(int i(ql);i<=qr;++i) ans[l]+=Q[i].type;
		return;
	}
	int mid(l+r>>1),k1(0),k2(0);
	for(int i(ql);i<=qr;++i){
		if(!Q[i].type){
			if(Q[i].k<=mid){
				Add(Q[i].id,1);
				q1[++k1]=Q[i];
			}
			else q2[++k2]=Q[i];
		}
		else{
			int res(Sum(Q[i].r)-Sum(Q[i].l-1));
			if(Q[i].k<=res) q1[++k1]=Q[i];
			else{
				Q[i].k-=res;
				q2[++k2]=Q[i];
			}
		}
	}
	for(int i(1);i<=k1;++i) Q[ql+i-1]=q1[i];
	for(int i(1);i<=k2;++i) Q[ql+k1+i-1]=q2[i];
	for(int i(1);i<=k1;++i) if(!q1[i].type) Add(q1[i].id,-1);
	Solve(l,mid,ql,ql+k1-1);Solve(mid+1,r,ql+k1,qr);
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i(1);i<=n;++i){
		int l,r,s;scanf("%d%d%d",&l,&r,&s);
		Q[m+i]=Query(l,r,s,i,1);
	}
	for(int i(1);i<=m;++i){
		int x;scanf("%d",&x);
		Q[i]=Query(-1,-1,i,x,0);
	}
	Solve(1,m+1,1,n+m);
	for(int i(1);i<=m;++i) printf("%d\n",ans[i]);
	return 0;
}
```

---

## 作者：Galex (赞：0)

初学整体二分，写篇题解纪念一下。

要求每个子弹发射后会有几个木板碎掉，不如求每个木板会在第几个子弹发射后会 **恰好碎掉**，显然现在我们要求的东西是具有单调性的（如果前 $i$ 个子弹能击碎木板，则前 $i+1$ 个一定也能）。

那么先考虑对单个木板进行二分答案：称木板的血量为还需多少个子弹贯穿它后才会碎掉，则这个木板初始的血量就是它的 $S_i$。当二分的区间为 $[l,r]$ 时，假设第 $l$ 个发射到第 $mid$ 个（$mid=\frac{l+r}2$）发射的所有子弹中会贯穿该木板的子弹数量为 $t$。如果该木板的血量 $\le t$，则说明该木板会在发射 $[l,mid]$ 的所有子弹后碎掉（**不一定是恰好碎掉**），也就是它的答案会在 $[l,mid]$ 中。否则它在发射了 $[l,mid]$ 的所有子弹后仍然不会碎，也就是答案会在 $[mid+1,r]$ 中，但此时它的血量要减去 $t$。

但如果对每个木板都进行二分的话显然会 T 飞，所有我们可以使用 **整体二分**，统计第 $l$ 个发射到第 $mid$ 个（$mid=\frac{l+r}2$）发射的所有子弹中会贯穿当前整体二分的队列的子弹数量可以使用树状数组。

代码：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

int read() {
	int s = 0, f = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9')
		f = (ch == '-' ? -1 : 1), ch = getchar();
	while (ch >= '0' && ch <= '9')
		s = (s << 1) + (s << 3) + (ch ^ 48), ch = getchar();
	return s * f;
}

int n, m, k;
int a[200005];

struct Wood {
	int l, r, s;
} q[200005], q1[200005], q2[200005];

int ans[200005];

#define lb(x) (x & (-x))
int sum[200005] = {0};

void mdf(int x, int v) {
	while (x <= 200000)
		sum[x] += v, x += lb(x);
}

int qry(int x) {
	int res = 0;
	while (x)
		res += sum[x], x -= lb(x);
	return res;
}

void solve(int fr, int ba, int l, int r) {
	if (fr > ba)
		return ;
	if (l == r) {
		for (int i = fr; i <= ba; i++)
			if (q[i].s == 1 && q[i].l <= a[l] && a[l] <= q[i].r)
				ans[l]++;
		return ;
	}
	int mid = (l + r) >> 1;
	int cnt1 = 0, cnt2 = 0;
	for (int i = l; i <= mid; i++)
		mdf(a[i], 1);
	for (int i = fr; i <= ba; i++) {
		int t = qry(q[i].r) - qry(q[i].l - 1);
		if (q[i].s <= t)
			q1[++cnt1] = q[i];
		else
			q[i].s -= t, q2[++cnt2] = q[i];
	}
	for (int i = l; i <= mid; i++)
		mdf(a[i], -1);
	for (int i = 1; i <= cnt1; i++)
		q[fr + i - 1] = q1[i];
	for (int i = 1; i <= cnt2; i++)
		q[fr + cnt1 + i - 1] = q2[i];
	solve(fr, fr + cnt1 - 1, l, mid), solve(fr + cnt1, ba, mid + 1, r);
	return ;
}

signed main() {
	n = read(), m = read();
	for (int i = 1, l, r, s; i <= n; i++)
		l = read(), r = read(), s = read(), q[i] = (Wood){l, r, s};
	for (int i = 1; i <= m; i++)
		a[i] = read();
	solve(1, n, 1, m);
	for (int i = 1; i <= m; i++)
		printf("%lld\n", ans[i]);
	return 0;
}
```


---

## 作者：__stick (赞：0)

# 题意
$n$ 块木板，第 $i$ 块在区间 $[l_{i},r_{i}]$ ，被子弹击穿 $s_{i}$ 次后将会被摧毁，同时给出 $m$ 颗子弹，每颗将在 $x_{i}$ 处射出，并贯穿轨道上的所有木板，求在第 $i$ 颗子弹射出后将有多少木板被摧毁。

# 思路

整体二分好题，其实从 [P3527](https://www.luogu.com.cn/problem/P3527) 过来的一眼就能看出解法。

首先我们想一下如何解决单次询问，我们只要求出每块木板是在那颗子弹射出后被摧毁的，最后开个桶统计一下即可，这个问题就可以二分了，我们二分射出子弹的个数即可，然而复杂度是惊人的 $O(nm \log m)$ （不过似乎可以主席树优化到 $n \log^2 n$ ，但常数过大） 显然不可接受，我们考虑更换做法。

这时候整体二分就出场了，何为整体二分？ 就是将不同的询问放在一起二分，减少时空复杂度，听起来很玄乎？ 容我细细道来。 

首先以这个题为例子，还是二分子弹个数，假设当前区间是 $[\  l,r\ ]$ 中点是 $mid$ ，那我们统计一下 $[1,mid]$ 中子弹贯穿了哪些位置，然后对木板进行一一判断，如果左边区间内的子弹已经能贯穿这个木板那这个木板就应该去 $[l,mid]$ 这个区间继续二分，反之就应该去 $[mid+1,r]$ ，并减去被$[l,mid]$ 区间内子弹贯穿的次数（有点像权值线段树） ，这样最后就能得到一个精确值，我们将它记录下来即可。至于用树状数组维护击穿次数就不用多说了吧。

# 代码
```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cstdio>
#include<vector>
#include<set>
#include<map>
#include<queue>
#include<bits/stdc++.h>
using namespace std;
template<typename T>
inline void cmax(T& a,const T& b){a<b?a=b:0;}
template<typename T>
inline void cmin(T& a,const T& b){b<a?a=b:0;}
typedef long long ll;
typedef pair<int,int> pii;
typedef unsigned long long ull;
typedef unsigned int ui;
typedef vector<int> vi;
const int MAXN=2e5+10;
int n,m,k;
struct BIT
{
	int t[MAXN];
	inline void add(int x,int k)
	{
		for(;x<MAXN;x+=x&-x)t[x]+=k;
	}
	inline void add(int l,int r,int k)
	{
		if(l<=r)add(l,k),add(r+1,-k);
		else add(1,k),add(r+1,-k),add(l,k),add(m+1,-k);
	}
	inline int sum(int x)
	{
		int ans=0;
		for(;x;x-=x&-x)ans+=t[x];
		return ans;
	}
}t;
struct node
{
	int l,r, k;
}a[MAXN];
int q[MAXN];
int ans[MAXN];
void solve(int l,int r,vi& id)
{
	if(id.empty())return;
	if(l==r)
	{
		ans[l]+=id.size();
		return;
	}
	int mid=(l+r)>>1;
	for(int i=l;i<=mid;i++) t.add(q[i],1);
	vi ls,rs;
	for(int &p:id)
	{
		int sum=t.sum(a[p].r)-t.sum(a[p].l-1);
		if(a[p].k<=sum) ls.push_back(p);
		else a[p].k-=sum,rs.push_back(p);
	}
	for(int i=l;i<=mid;i++) t.add(q[i],-1);
	solve(l,mid,ls),solve(mid+1,r,rs);
}
int main()
{
	ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i].l>>a[i].r>>a[i].k;
	}
	for(int i=1;i<=m;i++)cin>>q[i];
	vi v(n);
	for(int i=1;i<=n;i++) v[i-1]=i;
	solve(1,m+1,v);
	for(int i=1;i<=m;i++)cout<<ans[i]<<'\n';
	return 0;
}
```
使用了 vector 保存当前区间内的木板，比较方便常数也不算大（目前在最优解第二页）。

# 复杂度
有同学（比如我）刚接触到整体二分的时候会怀疑复杂度的正确性，因为它对询问的划分是不均等的，难道复杂度不会退化吗？其实不会，因为我们将这个递归树画出来（线段树例题里复制的）：

![](https://i.loli.net/2019/09/21/8ZGMzeY14iLN2u3.png)

不难发现，在每一层递归中，询问的总数不会变，所以每一层递归会遍历一遍所有询问，而层数是 $\log$ 级别的，所以复杂度为 $n\log m \times $ 每次维护区间信息的复杂度，在这个题中就是： $O(n \log m \log 2\times 10^5)$。


---

## 作者：JiaY19 (赞：0)

这应该也是一道区间第 $k$ 小的裸题吧。

#### 思路

考虑整体二分，将所有的询问全部离线。

我们可以将每一个子弹赋值，值可以取他们射击的时间。

这样，被第 $k$ 颗子弹击碎，就相当于查询第 $k$ 小了。

这里与其它整体二分的不同的点是。

它的统计答案，要这样写。

```cpp
if(lc > rc || l == r)
{
    for(int i = lc;i <= rc;i++)
        if(e[i].type == 2) ans[l]++;
    return ;
}
```
因为我们二分的是时间，而时间又和子弹的编号相等。

所以查询到这些板子会被这颗子弹击碎。

相当与这颗子弹击碎的数量增加。

#### 一个细节

要注意，这里的板子并没有说一定会被击碎，所以初始化时，操作要多加一个。

这样，没有被击碎的板子二分到的就是，最后一颗子弹的下一颗子弹，而不是最后一颗子弹。

#### Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn = 300010;
int n , m , cnt , ans[maxn];

struct edge
{
    int x , y , k , id , type;
}e[maxn * 2] , a1[maxn * 2] , a2[maxn * 2];

inline int read()
{
    int asd = 0 , qwe = 1; char zxc;
    while(!isdigit(zxc = getchar())) if(zxc == '-') qwe = -1;
    while(isdigit(zxc)) asd = asd * 10 + zxc - '0' , zxc = getchar();
    return asd * qwe;
}

namespace TREE
{
    int l = 200010;
    int sum[maxn];

    inline int lowbit(int x) { return x & (-x); }
    inline void update(int x , int y) { while(x <= l) sum[x] += y , x += lowbit(x); }
    inline int ask(int x) { int res = 0; while(x) res += sum[x] , x -= lowbit(x); return res; }
}

using namespace TREE;
inline void solve(int l , int r , int lc , int rc);

signed main()
{
    n = read() , m = read();
    for(int i = 1;i <= n;i++)
        e[++cnt].x = read() , e[cnt].y = read() , e[cnt].k = read() , e[cnt].id = i , e[cnt].type = 2;
    for(int i = 1;i <= m;i++)
        e[++cnt].x = read() , e[cnt].y = i , e[cnt].type = 1;
    e[++cnt].x = 1 , e[cnt].y = ++m , e[cnt].type = 1;
    //多加一颗子弹。
    solve(1 , m , 1 , cnt);
    for(int i = 1;i < m;i++)
        cout << ans[i] << endl;
    return 0;
}

inline void solve(int l , int r , int lc , int rc)
{
    if(lc > rc || l == r)
    {
        for(int i = lc;i <= rc;i++)
            if(e[i].type == 2) ans[l]++;
        return ;
    }

    int mid = (l + r) >> 1 , cnt1 = 0 , cnt2 = 0;
    for(int i = lc;i <= rc;i++)
        if(e[i].type == 1)
        {
            if(e[i].y <= mid) update(e[i].x , 1) , a1[++cnt1] = e[i];
            else a2[++cnt2] = e[i];
        }
    for(int i = lc;i <= rc;i++)
        if(e[i].type == 2) 
        {
            int sum = ask(e[i].y) - ask(e[i].x - 1);
            if(sum >= e[i].k)  a1[++cnt1] = e[i];
            else a2[++cnt2] = e[i] , a2[cnt2].k -= sum;
        }
    
    for(int i = lc;i <= rc;i++)
        if(e[i].type == 1 && e[i].y <= mid)
            update(e[i].x , -1);
    for(int i = 1;i <= cnt1;i++) e[i + lc - 1] = a1[i];
    for(int i = 1;i <= cnt2;i++) e[i + lc + cnt1 - 1] = a2[i];

    solve(l , mid , lc , lc + cnt1 - 1);
    solve(mid + 1 , r , lc + cnt1 , rc);
}

```

---


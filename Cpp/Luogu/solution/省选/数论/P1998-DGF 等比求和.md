# DGF 等比求和

## 题目描述

给定数论函数 $f$，定义 $f^n$ 为：

$$f^n=\begin{cases}f&n=1\\f^{n-1}* f &n\ge 2\end{cases}.$$

其中 $* $ 是 Dirichlet 卷积。

对于正整数 $n,m$，记数论函数 $g=f+f^2+\cdots+f^m$，请求出 $g(1),g(2),\cdots,g(n)$，答案对 $10^9+7$ 取模。

为控制输出量，只需输出 $\bigoplus_{k=1}^n(g(k)\bmod (10^9+7))$ 的值即可。

## 说明/提示

对于所有数据，保证 $1\le n\le 10^6,1\le m\le 10^9$，且对于 $1\le i\le n$，恒有 $0\le f(i)\le 10^9$。

特别地，$f(1)=1,f(2)\neq 0$。

对于样例一，$g$ 的前 $10$ 项依次为 $10, 55, 220, 440, 55, 1540, 55, 2475,2695,825$。

时限为 std 的 4 倍，请使用较快的读入方式。

## 样例 #1

### 输入

```
10 10
1 1 4 5 1 4 1 9 1 9```

### 输出

```
1864```

# 题解

## 作者：飞雨烟雁 (赞：4)

前置知识是 [DGF ln / exp](https://loj.ac/p/6713)，推荐阅读 [DGF 的计算理论：牛顿迭代与特殊求逆运算](https://www.luogu.com.cn/article/fvuj6pau)。

下设数论函数 $f$ 对应的 DGF 为 $F$（$g,h$ 同理），并记 $F$ 的第 $n$ 项为 $F_n$。

> 给定 DGF $F$ 和正整数 $n,m$，我们应该如何快速计算 $F+F^2+\cdots+F^m$ 的前 $n$ 项呢？

熟悉等比数列求和的读者会说，$F+\cdots+F^m=(F^{m+1}-1)/(F-1)-1$，然后采用 [LOJ #6713](https://loj.ac/p/6713) 的方法就行了。不过我们会发现，如果 $F_1=1$ 的话，$F-1$ 就不可逆，最后会卡在求逆上。而且，因为 DGF 本质是多元多项式，我们不能像一元多项式一样分子分母除个 $x$ 再求逆。那么，我们有没有什么不用倍增的快速做法呢？

有的兄弟，有的。这就是广义求逆。

适当泛化问题，给定 DGF $F,G$，若已知存在 $H$ 使得 $F=GH$，且 $F_1=G_1=0,G_2\neq 0$，那要如何求出 $H$？

根据 Dirichlet 卷积的式子：

$$\begin{aligned}f(2n)&=\sum_{d|2n,d>1}g(d)h(2n/d)\\&=g(2)h(n)+\sum_{d|2n,d>2}g(d)h(2n/d)\end{aligned}$$

稍微整理一下就是：

$$h(n)=\frac 1{g(2)}\left(f(2n)-\sum_{d|2n,d>2}g(d)h(2n/d)\right)$$

依此式递推即可，时间复杂度为 $\Theta(n\log n)$。

这个做法需要得知 $F,G$ 的前 $2n$ 项，才能算出 $H$ 的前 $n$ 项。看似浪费了很多已知信息，实则我们已经利用了所有信息。因为想要唯一确定 $h(n)$，就必须知道 $f(2n)$ 是多少。即便是递推式中未出现的 $f$ 的奇数值也很重要，它可以告诉我们这样的 $H$ 是否存在。不过，如果我们已知 $H$ 是存在的，那奇数值确实没啥用（

代码如下：


```cpp
#include <ctime>
#include <cstdio>
#include <iostream>
#define ll long long
using namespace std;

int Read(){
	int res = 0; char c = getchar();
	while(c < '0' || c > '9') c = getchar();
	while(c >= '0' && c <= '9') res = res * 10 + (c ^ 48), c = getchar();
	return res;
}

const int Mx = 2e6 + 10, Mod = 1e9 + 7;

inline int FastPow(ll a, int b){
	int res = 1;
	while(b){
		if(b & 1) res = res * a % Mod;
		b >>= 1, a = a * a % Mod;
	}
	return res;
}
ll Inverse(ll x){ return FastPow(x % Mod, Mod - 2);}

void Print(const int *F, int n){
	int ans = 0;
	for(int i = 1; i <= n; ++i) ans ^= ((F[i] < 0) ? (F[i] + Mod) : F[i]);
	cout << ans;
}

bool Vis[Mx];
int Prime[Mx], tot;
int Lns[Mx], Inv[30];
void Sieve(){
	for(int i = 2; i < Mx; ++i){
		if(!Vis[i]) Prime[++tot] = i, Lns[i] = 1;
		for(int j = 1; j <= tot && Prime[j] * i < Mx; ++j){
			Vis[i * Prime[j]] = true;
			Lns[i * Prime[j]] = 1 + Lns[i];
			if(i % Prime[j] == 0) break;
		}
	}
	for(int i = 1; i < 30; ++i) Inv[i] = Inverse(i);
}

int Temp[Mx], Temp2[Mx], Temp3[Mx], Temp4[Mx];
void Mul(const int *F, const int *G, int *H, int n){
	for(int i = 1; i <= n; ++i) Temp[i] = 1ll * F[i] * G[1] % Mod;
	for(int i = 1; i <= n; ++i) for(int j = (i << 1); j <= n; j += i)
		Temp[j] = (Temp[j] + 1ll * F[i] * G[j / i]) % Mod;
	for(int i = 1; i <= n; ++i) H[i] = Temp[i];
}

void Div(const int *F, const int *G, int *H, int n){
	for(int i = 1; i <= n; ++i) Temp[i] = F[i];
	ll Invg = Inverse(G[1]);
	for(int i = 1; i <= n; ++i){
        Temp[i] = Temp[i] * Invg % Mod;
    	for(int j = (i << 1); j <= n; j += i) Temp[j] = (Temp[j] - 1ll * Temp[i] * G[j / i]) % Mod;
    }
	for(int i = 1; i <= n; ++i) H[i] = Temp[i];
}

void Derivate(const int *F, int *G, int n){ for(int i = 1; i <= n; ++i) G[i] = 1ll * F[i] * Lns[i] % Mod;}
void Integrate(const int *F, int *G, int n){ for(int i = 1; i <= n; ++i) G[i] = 1ll * F[i] * Inv[Lns[i]] % Mod;}

void Logarithm(const int *F, int *G, int n){ Derivate(F, Temp2, n), Div(Temp2, F, Temp3, n), Integrate(Temp3, G, n);}

void Exponent(const int *F, int *G, int n){
	Derivate(F, Temp2, n);
	for(int i = 2; i <= n; i++) Temp3[i] = 0;
	Temp3[1] = 1;
    for(int i = 1; i <= n; i++){
        if(i != 1) Temp3[i] = 1ll * Temp3[i] * Inv[Lns[i]] % Mod;
        for(int j = (i << 1); j <= n; j += i) Temp3[j] = (Temp3[j] + 1ll * Temp3[i] * Temp2[j / i]) % Mod;
    }
    for(int i = 1; i <= n; ++i) G[i] = Temp3[i];
}

void Pow(const int *F, int *G, int n, int k){
	Logarithm(F, Temp4, n);
	for(int i = 1; i <= n; ++i) Temp4[i] = 1ll * Temp4[i] * k % Mod;
	Exponent(Temp4, G, n);
}

int F[Mx], G[Mx], H[Mx];
int main(){
	
	Sieve();
	
	int n = Read(), m = Read();
	
	for(int i = 1; i <= n; ++i) F[i] = Read();
	
	Pow(F, G, 2 * n, m + 1);
	G[1] = F[1] = 0;
	
	for(int i = 1; i <= n; ++i) H[i] = G[2 * i];
	ll ivs = Inverse(F[2]);
	for(int t = 1; t <= n; ++t){
		H[t] = H[t] * ivs % Mod;
		for(int d = 3; d * t <= 2 * n; ++d) if(d * t % 2 == 0){
			H[d * t / 2] = (H[d * t / 2] - 1ll * F[d] * H[t]) % Mod;
		}
	}
	
	--H[1];
	Print(H, n);
	
	
	return 0;
}
```

---

## 作者：masterhuang (赞：1)

前置知识：[狄利克雷 k 次方](https://loj.ac/p/6713)

首先运用等比数列求和公式：$g=H=\dfrac{f^{m+1}-f}{f-1}$，其中乘法是狄利克雷卷积。

令 $F=f^{m+1}-f,G=f-1$，则 $H=\dfrac{F}{G}$，其中除法是狄利克雷求逆。

但是注意到 $G(1)=0$，于是无法直接求逆。

但是注意到 $G(2)\neq 0$，于是我们有一些手段：

$$H(n)=\dfrac{1}{G(2)}\left(F(2n)-\sum\limits_{{\color{red}{d>2}},d\mid 2n}  G(d)H(2n/d)\right)$$

我们只需把 $f^{m+1}$ 保留 $2n$ 项，然后枚举因数通过上述过程求得 $H$ 即可。

**std** 的实现是枚举倍数，减小了常数。

**code**：

```cpp
#include<bits/stdc++.h>
#define LL long long
#define fr(x) freopen(#x".in","r",stdin);freopen(#x".out","w",stdout);
using namespace std;
namespace IO
{
	const int _Pu=2e7+5,_d=32;
	char buf[_Pu],*p1=buf+_Pu,*p2=buf+_Pu;
	inline void fin()
	{
		memmove(buf,p1,p2-p1);
		int rlen=fread(buf+(p2-p1),1,p1-buf,stdin);
		if(p1-rlen>buf) buf[p2-p1+rlen]=EOF;p1=buf;
	}
	inline int rd()
	{
		if(p1+_d>p2) fin();int x=0;
		for(;!isdigit(*p1);++p1);x=(*p1++-'0');
	    for(;isdigit(*p1);++p1) x=x*10+(*p1-'0');
		return x;
	}
}using IO::rd;//快读
const int N=2e6+5,mod=1e9+7;
int n,m,pr[N],w[N],a[N],f[N],g[N],h[N],I[35],ans;bool v[N];
inline int md(int x){return x>=mod?x-mod:x;}
inline int ksm(int x,int p){int s=1;for(;p;(p&1)&&(s=1ll*s*x%mod),x=1ll*x*x%mod,p>>=1);return s;}
inline void init(int M)
{
	for(int i=2;i<=M;i++)
	{
		if(!v[i]) pr[++pr[0]]=i,w[i]=1;
		for(int j=1;j<=pr[0]&&i*pr[j]<=M;j++)
		{
			v[i*pr[j]]=1;w[i*pr[j]]=w[i]+1;
			if(i%pr[j]==0) break;
		}
	}I[1]=1;
	for(int i=2;i<=30;i++) I[i]=mod-1ll*I[mod%i]*(mod/i)%mod;
}//预处理素因数个数与逆元
inline void pw(int *f,int *g,int n,int k){
	static int F[N];
	for(int i=1;i<=n;i++) F[i]=1ll*f[i]*w[i]%mod*k%mod,g[i]=0;
	for(int i=1;i<=n;i++)
	{
		int d=g[i];
		g[i]=(1ll*g[i]*I[w[i]]+(i==1))%mod;
		for(int k=(i<<1),j=2;k<=n;k+=i,j++)
			g[k]=(g[k]+1ll*g[i]*F[j]+1ll*(mod-f[j])*d)%mod;
	}
}//狄利克雷幂
int main()
{
	n=rd(),m=rd();init(n<<1);
	for(int i=1;i<=n;i++) a[i]=g[i]=rd();
	g[1]=0;pw(a,f,n<<1,m+1);
	for(int i=1;i<=n;i++) f[i]=md(f[i]+mod-a[i]);
	int _I=ksm(g[2],mod-2);
	for(int i=1;i<=n;i++)
	{
		h[i]=1ll*_I*(f[i<<1]+mod-h[i])%mod;ans^=h[i];
		for(int j=3,k=i*3;k<=2*n;j++,k+=i) if(k&1^1) h[k>>1]=(h[k>>1]+1ll*h[i]*g[j])%mod;
	}//枚举倍数贡献
	return cout<<ans,0;
}
```

---


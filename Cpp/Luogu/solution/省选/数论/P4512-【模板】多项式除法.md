# 【模板】多项式除法

## 题目描述

给定一个 $n$ 次多项式 $F(x)$ 和一个 $m$ 次多项式  $G(x)$ ，请求出多项式 $Q(x)$, $R(x)$，满足以下条件：

 - $Q(x)$ 次数为 $n-m$，$R(x)$ 次数小于 $m$
 - $F(x) = Q(x) * G(x) + R(x)$

所有的运算在模 $998244353$ 意义下进行。

## 说明/提示

对于所有数据，$1 \le m < n \le 10^5$，给出的系数均属于 $[0, 998244353) \cap \mathbb{Z}$。

## 样例 #1

### 输入

```
5 1
1 9 2 6 0 8
1 7```

### 输出

```
237340659 335104102 649004347 448191342 855638018
760903695```

# 题解

## 作者：Great_Influence (赞：35)

要做这道题，先保证你会[多项式求逆](https://www.luogu.org/problemnew/show/P4238)。

再发一下我参考的博客: [Miskcoo's Space](http://blog.miskcoo.com/2015/05/polynomial-division)。

具体来说，设多项式 $A$ 为 $n$ 次多项式，考虑一种操作 $R$ ，使得

$$A_R(x) = x^n A(\frac{1}{x})$$

稍微想象一下，可以发现 $A_R[i] = A[n-i]$ ( $[i]$ 表示多项式的第 $i$ 次系数)。

这个操作可以 $O(n)$ 完成。

然后开始化式子。

$$F(x) = Q(x) * G(x) + R(x)$$

$$F(\frac{1}{x}) = Q(\frac{1}{x}) * G(\frac{1}{x}) + R(\frac{1}{x})$$

$$x^n F(\frac{1}{x}) = x^{n-m} Q(\frac{1}{x}) * x^m G(\frac{1}{x}) + x^{n-m+1} * x^{m-1} R(\frac{1}{x})$$

$$F_R(x) = Q_R(x) * G_R(x) + x^{n-m+1} * R_R(x)$$

$$F_R(x) \equiv Q_R(x) * G_R(x) + x^{n-m+1} * R_R(x)\pmod {x^{n-m+1}}$$

$$F_R(x) \equiv Q_R(x) * G_R(x)\pmod {x^{n-m+1}}$$

$$Q_R(x) \equiv F_R(x) * G_R^{-1}(x)\pmod {x^{n-m+1}}$$

求一遍 $G_R$ 的逆，然后就可以利用多项式乘法求出 $Q$ 。然后

$$R(x) = F(x) - G(x) * Q(x)$$

直接计算即可。时间复杂度$O(n\log n)$。

代码:

```cpp
#include<bits/stdc++.h>
#define For(i,a,b) for(i=(a);i<=(b);++i)
#define Forward(i,a,b) for(i=(a);i>=(b);--i)
#define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
#define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
using namespace std;
template<typename T>inline void read(T &x){
    T s=0,f=1;char k=getchar();
    while(!isdigit(k)&&k^'-')k=getchar();
    if(!isdigit(k)){f=-1;k=getchar();}
    while(isdigit(k)){s=s*10+(k^48);k=getchar();}
    x=s*f;
}
void file(void){
    #ifndef ONLINE_JUDGE
    freopen("NTT.in","r",stdin);
    freopen("NTT.out","w",stdout);
    #endif
}
const int MAXN=1<<20;

typedef long long ll;

namespace polynomial
{
	static int mod=998244353,gen=3,g[21],rev[MAXN],Len;

	inline int ad(int a,int b){return (a+=b)>=mod?a-mod:a;}

	inline int power(int a,int b)
	{
		static int sum;
		for(sum=1;b;b>>=1,a=(ll)a*a%mod)if(b&1)
			sum=(ll)sum*a%mod;
		return sum;
	}

	inline void predone()
	{
		static int i,j;
		for(i=1,j=2;i<=19;++i,j<<=1)g[i]=power(gen,(mod-1)/j);
	}

	inline void calrev(int Len)
	{
		static int Logl;Logl=(int)floor(log(Len)/log(2)+0.3)-1;
		Rep(i,1,Len-1)rev[i]=(rev[i>>1]>>1)|((i&1)<<Logl);
	}

	inline void NTT(int X[],int typ)
	{
		Rep(i,1,Len-1)if(i<rev[i])swap(X[i],X[rev[i]]);
		static int i,j,k,kk,w,t,wn,r;
		for(k=2,kk=1,r=1;k<=Len;k<<=1,kk<<=1,++r)
		{
			wn=g[r];
			for(i=0;i<Len;i+=k)for(j=0,w=1;j<kk;++j,w=(ll)w*wn%mod)
			{
				t=(ll)w*X[i+j+kk]%mod;
				X[i+j+kk]=ad(X[i+j],mod-t);
				X[i+j]=ad(X[i+j],t);
			}
		}
		if(typ==-1)
		{
			reverse(X+1,X+Len);
			static int invn;invn=power(Len,mod-2);
			Rep(i,0,Len-1)X[i]=(ll)X[i]*invn%mod;
		}
	}

	static int x[MAXN],y[MAXN];
	inline void mul(int a[],int b[])
	{
		memset(x,0,sizeof x);memset(y,0,sizeof y);
		Rep(i,0,(Len>>1)-1)x[i]=a[i],y[i]=b[i];
		NTT(x,1);NTT(y,1);
		Rep(i,0,Len-1)x[i]=(ll)x[i]*y[i]%mod;
		NTT(x,-1);
		Rep(i,0,Len-1)a[i]=x[i];
	}
	
	static int c[2][MAXN];
	
	inline void Inv(int a[],int n)
	{
		static int t;t=0;
		memset(c,0,sizeof c);
		c[0][0]=power(a[0],mod-2);
		Len=2;
		while(Len<=(n<<1))
		{
			Len<<=1;
			calrev(Len);t^=1;
			memset(c[t],0,sizeof c[t]);
			Rep(i,0,Len)c[t][i]=ad(c[t^1][i],c[t^1][i]);
			mul(c[t^1],c[t^1]);mul(c[t^1],a);
			Rep(i,0,Len)c[t][i]=ad(c[t][i],mod-c[t^1][i]);
		}
		Rep(i,0,Len-1)a[i]=c[t][i];
	}
}
using namespace polynomial;

int n,m,F[MAXN],G[MAXN],Q[MAXN],R[MAXN],Gr[MAXN];

int main(void){
    file();
	read(n);read(m);
	Rep(i,0,n)read(F[i]),Q[n-i]=F[i];
	Rep(i,0,m)read(G[i]),Gr[m-i]=G[i];
	Rep(i,n-m+2,m)Gr[i]=0;
	predone();
	Inv(Gr,n-m+1);
	mul(Q,Gr);
	reverse(Q,Q+n-m+1);
	Rep(i,n-m+1,n)Q[i]=0;
	Rep(i,0,n-m)printf("%d ",Q[i]);
	puts("");
	while(Len<=(n<<2))Len<<=1;
	calrev(Len);
	mul(Q,G);
	Rep(i,0,m-1)printf("%d ",ad(F[i],mod-Q[i]));
	puts("");
	return 0;
}
```

---

## 作者：zhoukangyang (赞：30)

upd : 修正了题解格式，更改了小 bug，更新了代码，~~加了 [cnblogs](https://www.cnblogs.com/zkyJuruo/p/14289013.html) 的链接~~

## -1.推荐

推荐一个非常好的blog：[$\color{black}{\text{F}}\color{red}{\text{roggy}}$的多项式大杂烩](https://www.luogu.com.cn/blog/1445353309froggy/duo-xiang-shi-tai-za-hui)

## 0.前言

必备内容：NTT，多项式求逆

建议到博客中查看

## 1.正文
定义 $F_R(x)$ 为把 $F(x)$ 系数翻转后的函数

若 $F_R(x)$ 次数为 $k$ ，那么 $F_R(x)=F(\frac{1}{x})*x^k$

若 $f(x)=g(x)*q(x)+r(x)$， $f$ 次数为 $n$ ，$g$ 次数为 $m$， $q$ 次数为 $n-m$ ， $r$ 次数为 $m-1$

我们可以把 $\frac{1}{x}$ 带入函数

得
$$f(\frac{1}{x})=g(\frac{1}{x})*q(\frac{1}{x})+r(\frac{1}{x})$$


$$f(\frac{1}{x})*x^n=g(\frac{1}{x})*x^mq(\frac{1}{x})*x^{n-m}+r(\frac{1}{x})*x^{m-1}*x^{n-m+1}$$

$$f_R(x)=g_R(x)*q_R(x)+r_R(x)*x^{n-m+1}$$

$$f_R(x) \equiv g_R(x)*q_R(x) \pmod {x^{n-m+1}}$$

$$q_R(x)\equiv \frac{f_R(x)}{g_R(x)} \pmod {x^{n-m+1}}$$

从而我们可以知道 $q(n) \bmod x^{n-m+1}$

我们知道 $q$ 次数为 $n-m$ ，而模数次数为 $n-m+1$

于是就可以算出 $q$ 啦！！！！！

然后我们可以用

$$r(x)=f(x)-g(x)*q(x)$$

然后 $r$ 也算出来啦！

## 2.代码

```cpp
#include<bits/stdc++.h>
#define L(i, j, k) for(int i = j, i##E = k; i <= i##E; i++)
#define R(i, j, k) for(int i = j, i##E = k; i >= i##E; i--)
#define ll long long
#define ull unsigned long long
#define db double
#define pii pair<int, int>
#define mkp make_pair
using namespace std;
const int N = 524288, mod = 998244353, G = 3, iG = (mod + 1) / G;
int qpow(int x, int y = mod - 2) {
	int res = 1;
	for(; y; x = (ll) x * x % mod, y >>= 1) if(y & 1) res = (ll) res * x % mod;
	return res;
}
int lim, pp[N];
void revlim() { L(i, 0, lim - 1) pp[i] = ((pp[i >> 1] >> 1) | ((i & 1) * (lim >> 1))); }
void up(int x) { lim = 1; for(; lim <= x; lim <<= 1); }
void cle(int *f) { L(i, 0, lim - 1) f[i] = 0; }
void NTT(int *f, int flag) {
	L(i, 0, lim - 1) if(pp[i] < i) swap(f[pp[i]], f[i]);
	for(int i = 2; i <= lim; i <<= 1) 
		for(int j = 0, l = (i >> 1), ch = qpow(flag == 1 ? G : iG, (mod - 1) / i); j < lim; j += i) 
			for(int k = j, now = 1; k < j + l; k ++) {
				int pa = f[k], pb = (ll) f[k + l] * now % mod;
				f[k] = (pa + pb) % mod, f[k + l] = (pa + mod - pb) % mod;
				now = (ll) now * ch % mod;
			}
	if(flag == -1) {
		int nylim = qpow(lim);
		L(i, 0, lim - 1) f[i] = (ll) f[i] * nylim % mod;
	}
}
int sav[N], sv[N];
void inv(int *f, int *g, int len) { 
	if(len == 1) return g[0] = qpow(f[0]), void();
	inv(f, g, (len + 1) >> 1), up(len << 1), cle(sav), copy(f, f + len, sav), revlim(), NTT(sav, 1), NTT(g, 1);
	L(i, 0, lim - 1) g[i] = (ll) g[i] * (2ll + mod - (ll) g[i] * sav[i] % mod) % mod;
	NTT(g, -1), fill(g + len, g + lim, 0);
}
int sava[N], savb[N];
void div(int *f, int *g, int *ansa, int *ansb, int n, int m) {
	up(n << 1), cle(sava), cle(savb), copy(g, g + m, sava), reverse(sava, sava + m);
	inv(sava, savb, n), up(n << 1), revlim(), copy(f, f + n, sava), reverse(sava, sava + n);
	NTT(sava, 1), NTT(savb, 1); 
	L(i, 0, lim - 1) ansa[i] = (ll) sava[i] * savb[i] % mod;
	NTT(ansa, -1), fill(ansa + n - m + 1, ansa + lim, 0), reverse(ansa, ansa + n - m + 1);
	cle(sav), cle(sava), copy(ansa, ansa + n - m + 1, sav), copy(g, g + m, sava), NTT(sav, 1), NTT(sava, 1);
	L(i, 0, lim - 1) sav[i] = (ll) sav[i] * sava[i] % mod;
	NTT(sav, -1);
	L(i, 0, m - 2) ansb[i] = (f[i] + mod - sav[i]) % mod;
}
int n, m, f[N], g[N], ansa[N], ansb[N];
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin >> n >> m, ++n, ++m;
	L(i, 0, n - 1) cin >> f[i];
	L(i, 0, m - 1) cin >> g[i];
	div(f, g, ansa, ansb, n, m);
	L(i, 0, n - m) cout << ansa[i] << " ";
	cout << endl;
	L(i, 0, m - 2) cout << ansb[i] << " ";
	cout << endl;
	return 0;
} 
```

**祝大家学习愉快！**

---

## 作者：飞雨烟雁 (赞：10)

在初学多项式除法之时，我曾惊叹于其中巧妙的系数翻转操作。两年过去了，初时的震撼已褪为另辟蹊径的渴望。回看此题，我又有了不同的想法——转置原理。它总会给问题带来全新的解法，并揭示更深层次的关联。

好，闲话结束，我们进入正题。

**约定**：对于任意的大写字母（比如 $A$），我们用对应的小写字母数列 $a_k$ 表示 $[x^k]A(x)$。并用下标 $r$ 表示系数翻转，例如 $F(x)=1+2x,F_r(x)=2+x$。

设 $R(x)=F(x)\bmod G(x),n=\deg F,m=\deg G$，则有：

$$r_k=\sum_{i=0}^n f_i [x^k](x^i\bmod G(x))$$

转置一下：

$$\begin{aligned}r^{\mathsf T}_ k&=\sum_{i=0}^n f_i [x^i](x^k\bmod G(x))\\
&=\sum_{i=0}^n [x^{n-i}]F_r(x) [x^i](x^k\bmod G(x))\\
&=[x^{n}]F_r(x) (x^k\bmod G(x))\\
\end{aligned}$$

但是这个要怎么解决呢？要注意「先取模后乘法」和「先乘法后取模」是不一样的，我们并不能将其化为 $(x^kF(x))\bmod G(x)$。但是，借助下面这个公式，我们可以实现完美的转化。

------------

对于任意的自然数 $k$，我们恒有：

$$[x^{n}]F_r(x)(x^k\bmod G(x))=[x^k]\dfrac{(F(x)G_r(x))\bmod  x^{m}}{G_r(x)}$$

嗯？！这个等式是怎么来的？

事实上，这个等式的左端描述的是用 Fiduccia 算法求解「常系数齐次线性递推」，右端描述的是用 LSB-First 算法求解「常系数齐次线性递推」。这样看来，这个式子是很直观的。

这么美妙的式子理应有种美妙的证法。可是我没能想到，暂且提供一个简单的归纳证明。

$k< m$ 时，命题显然成立。因为此时可以忽略取模，两边均为 $f_k$。$k\ge m$ 时，假设 $\forall k'< k$，等式对 $k'$ 成立，下证等式对 $k$ 也成立。

先凑出 $G(x)$ 的形式：

$$\sum_{i=0}^m g_{m-i}[x^n]F_r(x)(x^{k-i}\bmod G(x))=[x^n]F_r(x)(x^{k-m}G(x)\bmod G(x))=0$$

故有：

$$\begin{aligned}[x^n]F_r(x)(x^k\bmod G(x))&=-\frac 1{g_m}\left(\sum_{i=1}^m g_{m-i}[x^n]F_r(x)(x^{k-i}\bmod G(x))\right)\\
&=-\frac 1{g_m}\left(\sum_{i=1}^m g_{m-i}[x^{k-i}]\dfrac{(F(x)G_r(x))\bmod  x^{m}}{G_r(x)}\right)\\
&=-\frac 1{g_m}\left( [x^{k}]G_r(x)\dfrac{(F(x)G_r(x))\bmod  x^{m}}{G_r(x)}-g_{m}[x^{k}]\dfrac{(F(x)G_r(x))\bmod  x^{m}}{G_r(x)}\right)\\
&=[x^{k}]\dfrac{(F(x)G_r(x))\bmod  x^{m}}{G_r(x)}\\
\end{aligned}$$

综上，等式得证。

------------

利用该公式，我们有：


$$r^{\mathsf T}_ k=[x^{k}]\dfrac{(F(x)G_r(x))\bmod  x^{m}}{G_r(x)}$$

于是有多项式取模的转置算法：

1. 卷上 $G_r$，截取前 $m$ 项；
2. 卷上 $G_r^{-1}$。

把该过程转置即得多项式取模算法：

1. $F=F*^{\mathsf T}G_r^{-1}$；
2. 截取前 $m$ 项；
3. $F=F*^{\mathsf T}G_r$。

其中 $* ^{\mathsf T}$ 表示多项式乘法的转置。

我们可以这样来理解这几个步骤：第一步相当于把 $F$ 的高次项对取模结果的贡献，累加到低次项；第二步丢弃了高次项的信息；第三步是将低次项整理为取模结果。

至于 $F=G* Q+R$ 中的 $Q$，只需在求出 $R$ 后用 $Q=(F-R)/G$ 计算即可。也可以用原先的方法计算 $Q$，或者直接算出 $Q$ 的 FFT 点值，然后再逆回去。方法有很多，但实际应用中我们更关注的是取模，而非整除。

------------

Remark：

上面的推导过程也告诉我们，「多项式取模」和「常系数线性递推」之间存在转置关系。这个事实在 EI 的 [一种新的线性递推计算方法](https://blog.csdn.net/EI_Captain/article/details/109196620) 中亦有记载，但少有人提及。

---

## 作者：Illusory_dimes (赞：5)

### 题目描述
给定 $n$ 次多项式 $f(x)$ 和一个 $m$ 次多项式 $g(x)$ ，求多项式 $q(x)$ ， $r(x)$ 满足：

$q(x)$ 的次数为 $n-m$ ， $r(x)$ 次数小于 $m$ ；

$f(x)=q(x)\cdot g(x)+r(x)$

系数对 $998244353$ 取模。

数据范围 $1\leq m<n\leq 10^5$ 。

### 前置芝士：
多项式求逆。（不用牛顿迭代，甚至~~非常入门的~~求导，积分都不要，老少咸宜！）

不会出门左拐即可。。（应该已经没有人读到这里就走了吧）

### solution
来两个记号，

1.定义 $f^{R}(x)$ 为 $f(x)$ 系数反转的多项式。

2.定义 $deg(f(x))$ 为 $f(x)$ 的最高次幂数。

显然的一个小推论，

$f^{R}(x)=x^{deg(f(x))}\cdot f(\large\frac{1}{x}$ $)$

（随便举个例子就懂了）

$f(x)=q(x)\cdot g(x)+r(x)$

将上式中的 $x$ 令为 $\large\frac{1}{x}$ ，再乘上一个 $x^{deg(f(x))}$ ，就可以套上面的小推论。

（注： $q(x)\cdot g(x)$ 次数等于 $f(x)$ ，而 $r(x)$ 的次数必然小于 $f(x)$ （应该显然吧。。））

所以得到：

$f^{R}(x)=q^{R}(x)\cdot g^{R}(x)+x^{n-deg(r(x))}\cdot r^{R}(x)$

因为已知 $deg(r(x))<m$ 即 $deg(r(x))\leq m-1$ （因为这里只会出现整数次幂）

所以 $n-deg(r(x))\geq n-m+1$ 。

如果此时两边同时对 $x^{n-m+1}$ 取模，那么：

$f^{R}(x)\equiv q^{R}(x)\cdot g^{R}(x)$ $(mod$ $x^{n-m+1})$

最棒的是，这个式子没有答案的损失，因为 $q^{R}(x)$ 的次数是 $n-m$ 小于 $n-m+1$ ,非常完美。

所以 $q^{R}(x)$ 可以在不损失的情况下求出来，最后再回到原来的柿子，移一个项，再求 $r(x)$ 就行了。

时间复杂度 $O(n\log_{2}{n})$ 。

人傻常熟大 wtcl 。。

**（注：多项式是 $0$ 次到 $n$ 或 $m$ 次而非 $0$ 次到 $n-1$ 或 $m-1$ 次）**
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=4e5+10;
typedef ll arr[N];
const int mod=998244353;
const int inv3=332748118;
int n,m,inv,lim=1,fre,id[N];
arr f,g,fr,gr,gi,q,r,ans;
inline ll inc(ll x,ll y){return x+y>=mod?x+y-mod:x+y;}
inline ll dec(ll x,ll y){return x-y<0?x-y+mod:x-y;}
inline ll mul(ll x,ll y){return 1ll*x*y%mod;}
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*w;
}
inline int ksm(int a,int b)
{
	int tmp=1;
	while(b)
	{
		if(b&1)tmp=(1ll*tmp*a)%mod;
		b>>=1,a=(1ll*a*a)%mod;
	}
	return tmp;
}
inline void Never_Tell_TLE(ll* NTT,int sign)
{
	for(int i=0;i<=lim;++i)if(i<id[i])
	{
		ll NTt=NTT[i];
		NTT[i]=NTT[id[i]];
		NTT[id[i]]=NTt;
	}
	for(int mid=1;mid<lim;mid<<=1)
	{
		int Unit_root;
		if(sign==1)Unit_root=ksm(3,(mod-1)/(mid<<1));
		else Unit_root=ksm(inv3,(mod-1)/(mid<<1));
		for(int R=mid<<1,r=0;r<lim;r+=R)
		{
			int pw=1;
			for(int l=0;l<mid;++l,pw=(1ll*pw*Unit_root)%mod)
			{
				int butt=NTT[l+r],rfly=(1ll*pw*NTT[l+r+mid])%mod;
				NTT[l+r]=inc(butt,rfly);
				NTT[l+r+mid]=dec(butt,rfly);
			}
		}
	}
	if(sign==-1)
	{
		int inv_lim=ksm(lim,mod-2);
		for(int i=0;i<=lim;++i)NTT[i]=mul(NTT[i],inv_lim);
	}
}
/*
此Inv非彼Inv，一定要注意
因为多项式是0~n/m而非0~(n-1)/(m-1)
*/
inline void Inv(ll* F,ll* G,int nm)
{
	if(nm==0)
	{
		G[0]=ksm(F[0],mod-2);
		return;
	}
	Inv(F,G,nm>>1);
	lim=1,fre=0;
	for(;lim<=(nm<<1);lim<<=1)++fre;
	for(int i=0;i<=lim;++i)id[i]=(id[i>>1]>>1)|((i&1)<<(fre-1));
	for(int i=0;i<=nm;++i)ans[i]=F[i];
	for(int i=nm+1;i<=lim;++i)ans[i]=0;
	Never_Tell_TLE(ans,1),Never_Tell_TLE(G,1);
	for(int i=0;i<=lim;++i)G[i]=mul(inc(2ll,-mul(ans[i],G[i])+mod),G[i]);
	Never_Tell_TLE(G,-1);
	for(int i=nm+1;i<=lim;++i)G[i]=0;
}
inline void Mul(ll* F,ll* G,int nm)
{
	lim=1,fre=0;
	for(;lim<=nm;lim<<=1)++fre;
	for(int i=0;i<=lim;++i)id[i]=(id[i>>1]>>1)|((i&1)<<(fre-1));
	Never_Tell_TLE(F,1),Never_Tell_TLE(G,1);
	for(int i=0;i<=lim;++i)F[i]=mul(F[i],G[i]);
	Never_Tell_TLE(F,-1);
}
inline void solve(ll* F,ll* G,ll* FR,ll* GR,ll* GI,ll* Q,ll* R)
{
	Inv(GR,GI,n-m);
	Mul(FR,GI,n+n-m);
	for(int i=0;i<=n-m;++i)Q[i]=FR[n-m-i];
	for(int i=0;i<=n-m;++i)printf("%d ",Q[i]);
	printf("\n");
	Mul(G,Q,n);
	for(int i=0;i<m;++i)R[i]=inc(F[i],-G[i]+mod);
	for(int i=0;i<m;++i)printf("%d ",R[i]);
}
int main()
{
	n=read(),m=read();
	for(int i=0;i<=n;++i)f[i]=read(),fr[n-i]=f[i];
	for(int i=0;i<=m;++i)g[i]=read(),gr[m-i]=g[i];
	for(int i=n-m+1;i<=m;++i)gr[i]=0;
	solve(f,g,fr,gr,gi,q,r);
	return 0;
}
```
只求能帮助到几个人罢。。

---

## 作者：Convergent_Series (赞：2)

对于任意 $n$ 次多项式 $A(x)$，设 $A_r(x)=\displaystyle\sum_{i=0}^n[x^{n-i}]A(x)x^i$。

$\displaystyle A_r(x)=\sum_{i=0}^n[x^{n-i}]A(x)(\dfrac{1}{x})^{n-i}x^n=x^nA(\dfrac{1}{x})$

将 $\dfrac{1}{x}$ 代入题目中式子：

$$\begin{aligned}
F(\dfrac{1}{x})&=Q(\dfrac{1}{x})\times G(\dfrac{1}{x})+R(\dfrac{1}{x})\\
\\
x^n\times F(\dfrac{1}{x})&=x^n\times Q(\dfrac{1}{x})\times G(\dfrac{1}{x})+x^n\times R(\dfrac{1}{x})\\
\\
x^nF(\dfrac{1}{x})&=x^{n-m} Q(\dfrac{1}{x})\times x^mG(\dfrac{1}{x})+x^{n-m+1}\times x^{m-1}R(\dfrac{1}{x})\\
\\
F_r(x)&= Q_r(x)\times G_r(x)+x^{n-m+1}R_r(x)\\
\\
F_r(x)&\equiv Q_r(x)\times G_r(x)\pmod {x^{n-m+1}}\\
\\
Q_r(x)&\equiv F_r(x)\times G_r^{-1}(x)\pmod {x^{n-m+1}}\\
\\
\end{aligned}$$

直接套板子计算 $Q_r(x)$ ，翻转即为 $Q(x)$，$R(x)=F(x)-Q(x)\times G(x)$。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
#define ull unsigned long long
#define clr(f,n) memset(f,0,sizeof(int)*(n))
#define cpy(f,g,n) memcpy(f,g,sizeof(int)*(n))
using namespace std;
const int siz=1<<18;char buf[siz],*p1=buf,*p2=buf,obuf[siz],*p3=obuf;
#define getchar() p1==p2&&(p2=(p1=buf)+fread(buf,1,siz,stdin),p1==p2)?EOF:*p1++
#define putchar(x) (p3-obuf<siz)?(*p3++=x):(fwrite(obuf,p3-obuf,1,stdout),p3=obuf,*p3++=x)
int read(){
	int a=0,f=1;char ch=getchar();
	while(!((ch>='0'&&ch<='9')||ch=='-')) ch=getchar();
	if(ch=='-') f=-1,ch=getchar();
	while(ch>='0'&&ch<='9') a=(a<<3)+(a<<1)+(ch^'0'),ch=getchar();
	a*=f;return a;
} 
void write(int a){
	if(a<0){putchar('-'),a=-a;}
	if(a>9) write(a/10); 
	putchar(a%10+'0');
}
const int MAXN=1e6+10,P=998244353,G=3,Gi=332748118;
int l,r[MAXN],inv[MAXN],sav[MAXN<<1];
int qpow(int a,int b=P-2){
	if(a==1) return 1;
	if(a==-1) return b&1?-1:1; 
	int ans=1;a%=P;
	while(b){if(b&1) ans=ans*a%P;a=a*a%P;b>>=1;}
	return ans;
}
void tpre(int lim){for(int i=0;i<lim;i++) r[i]=(r[i>>1]>>1)|((i&1)?lim>>1:0);}
void px(int *A,int *B,int n){for(int i=0;i<n;i++) A[i]=A[i]*B[i]%P;} 
void NTT(int *A,int lim,int type){
	tpre(lim);
	static ull f[MAXN<<1],w[MAXN<<1];w[0]=1;
	for(int i=0;i<lim;i++) f[i]=((P<<5)+A[r[i]])%P;
	for(int mid=1;mid<lim;mid<<=1){
		ull Wn=qpow(type==1?G:Gi,(P-1)/(mid+mid));
		for(int i=1;i<mid;i++)w[i]=w[i-1]*Wn%P;
		for(int j=0;j<lim;j+=mid+mid){
			for(int k=0;k<mid;k++){
				int x=w[k]*f[j|mid|k]%P;
				f[j|mid|k]=f[j|k]+P-x;
				f[j|k]+=x;
			}   
		}if(mid==(1<<10)){for(int i=0;i<lim;i++) f[i]%=P;}
	}if(type==-1){
		ull inv=qpow(lim);
		for(int i=0;i<lim;i++) A[i]=f[i]%P*inv%P;
	}else for(int i=0;i<lim;i++) A[i]=f[i]%P;
}
void mul(int *A,int *B,int la,int lb){//乘法 
	int limit=1;while(limit<=la+la) limit<<=1;
	cpy(sav,B,lb);
    NTT(A,limit,1);NTT(sav,limit,1);
    px(A,sav,limit);NTT(A,limit,-1);
    clr(A+lb,limit-lb);clr(sav,limit);
} 
void invp(int *A,int lim){//逆元 
	int n=1;while(n<lim) n<<=1;
	static int w[MAXN<<1],r[MAXN<<1];
	w[0]=qpow(A[0]);
	for (int ln=2;ln<=n;ln<<=1){
		for(int i=0;i<(ln>>1);i++) r[i]=w[i];
		cpy(sav,A,ln);NTT(sav,ln,1);NTT(r,ln,1);px(r,sav,ln);
		NTT(r,ln,-1);clr(r,ln>>1);cpy(sav,w,ln);NTT(sav,ln,1);
	    NTT(r,ln,1);px(r,sav,ln);NTT(r,ln,-1);
	    for(int i=ln>>1;i<ln;i++) w[i]=(w[i]*2-r[i]+P)%P;
	}cpy(A,w,lim);clr(sav,n);clr(w,n);clr(r,n);
}
void rev(int *A,int lim){
    cpy(sav,A,lim);
    for (int i=0;i<lim;i++) A[i]=sav[lim-i-1];
    clr(sav,lim);
}
void mof(int *A,int *B,int n,int m){
	static int q[MAXN<<1],t[MAXN<<1]; 
	int l=n-m+1;
	rev(B,m);cpy(q,B,l);rev(B,m);
	rev(A,n);cpy(t,A,l);rev(A,n);
	invp(q,l);mul(q,t,l,l);rev(q,l);
	mul(B,q,n,n);
	for(int i=0;i<m-1;i++) B[i]=(A[i]-B[i]+P)%P;
	clr(B+m-1,l);cpy(A,q,l);clr(A+l,n-l); 
}//A<-A/B,B<-A%B.
int n,m,a[MAXN],b[MAXN];
signed main(){
    n=read()+1;m=read()+1; 
    for(int i=0;i<n;i++) a[i]=read();
    for(int i=0;i<m;i++) b[i]=read();
	mof(a,b,n,m);
    for(int i=0;i<n-m+1;i++){write(a[i]);putchar(' ');} 
    putchar('\n');
    for(int i=0;i<m-1;i++){write(b[i]);putchar(' ');} 
    fwrite(obuf,p3-obuf,1,stdout);
    return 0;
}
```

---

## 作者：Komodo (赞：2)

这是我发布的第一篇题解

前置知识：ntt,多项式逆元

根据题意，给定多项式F,G,求P,Q,其中
$$
F(x)= G(x)Q(x)+R(x)
$$
我们设$H^R(x)=x^{digitH}H(\frac 1 x)$

继续推式子……
$$
F(x)=G(x)Q(x)+R(x)
$$
$$
x^nF(\frac 1 x)= x^mG(\frac 1 x)x^{n-m}Q(\frac 1 x)+x^{n-m+1}x^{m-1}R(\frac 1 x)
$$
$$
F^R(x)=G^R(x)Q^R(x)+x^{n-m+1}R^R(x)
$$
$$
F^R(x)\equiv G^R(x)Q^R(x)\mod x^{n-m+1}
$$
$$
F^R(x){G^R}^{-1}(x)\equiv Q^R(x)\mod x^{n-m+1}
$$
算出来后把Q反带入求出R即可

O(nlogn)

code:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int ksm(int a,int b,int mod){
    if(b==1)return a%mod;
    if(b==0)return 1;
    int ans=ksm(a,b/2,mod);
    ans*=ans;
    ans%=mod;
    if(b%2)ans*=a,ans%=mod;
    return ans;
}
const int mod=998244353;
const int g=3;
int r[1000000];
void ntt(int a[],int len,int mode){
    for(int i=0;i<len;i++)if(r[i]<i)swap(a[r[i]],a[i]);
    for(int i=1;i<len;i<<=1){
        int wn=ksm(g,(mod-1)/(i*2),mod);
        if(mode==-1)wn=ksm(wn,(mod-2),mod);
        for(int j=0;j<len;j+=(i<<1)){
            int wnk=1;
            for(int k=0;k<i;k++){
                int x=a[j+k],y=(wnk*a[i+j+k])%mod;
                a[j+k]=(x+y)%mod;
                a[i+j+k]=(x-y+mod)%mod;
                wnk*=wn;
                wnk%=mod;
            }
        }
    }
    if(mode==-1){
        int invlen=ksm(len,mod-2,mod);
        for(int i=0;i<len;i++){
            a[i]*=invlen;
            a[i]%=mod;
        }
    }
}
int c[1000000];
void work(int a[],int b[],int n){
    if(n==1){
        b[0]=ksm(a[0],mod-2,mod);
        return;
    }
    work(a,b,(n+1)/2);
    memset(c,0,sizeof(c));
    for(int i=0;i<n;i++){
        c[i]=a[i];
    }
    int len=1,l=0;
    while(len<(n*2))len<<=1,l++;
    for(int i=0;i<len;i++){
        r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));
    }
    ntt(c,len,1);
    ntt(b,len,1);
    for(int i=0;i<len;i++){
        b[i]=((2+mod-c[i]*b[i]%mod)%mod*b[i])%mod;
    }
    ntt(b,len,-1);
    for(int i=n;i<len;i++)b[i]=0;
}
int n,m,f[1000000],G[1000000],fr[1000000],gr[1000000],gt[1000000];
signed main(){
    cin>>n>>m;
    for(int i=0;i<=n;i++){
        scanf("%d",f+i);
        fr[n-i]=f[i];
    }
    for(int i=0;i<=m;i++){
        scanf("%d",G+i);
        gr[m-i]=G[i];
        gt[i]=G[i];
    }
    for(int i=n-m+2;i<=m;i++)gr[i]=0;
    memset(G,0,sizeof(G));
    work(gr,G,n-m+1);
    int kkksc03=1,l=0;
    while(kkksc03<2*n+2){
        kkksc03<<=1;
        l++;
    }
    for(int i=0;i<kkksc03;i++){
        r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));
    }
    ntt(G,kkksc03,1);
    ntt(fr,kkksc03,1);
    for(int i=0;i<kkksc03;i++){
        fr[i]*=G[i];
        fr[i]%=mod;
    }
    ntt(fr,kkksc03,-1);
    /*for(int i=n-m;i>=0;i--)cout<<fr[i]<<" ";
    cout<<endl;*/
    reverse(fr,fr+n-m+1);
    for(int i=n-m+1;i<n;i++)fr[i]=0;
    for(int i=0;i<=n-m;i++)cout<<fr[i]<<" ";
    cout<<endl;
    for(int i=n-m+1;i<1000000;i++)fr[i]=0;
    kkksc03=1,l=0;
    while(kkksc03<n+2)kkksc03<<=1,l++;
    for(int i=0;i<kkksc03;i++){
        r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));
    }
    ntt(gt,kkksc03,1);
    ntt(fr,kkksc03,1);
    for(int i=0;i<kkksc03;i++){
        gt[i]*=fr[i];
        gt[i]%=mod;
    }
    ntt(gt,kkksc03,-1);
    //for(int i=0;i<kkksc03;i++)cout<<gt[i]<<endl;
    for(int i=0;i<m;i++){
        cout<<((f[i]-gt[i]+mod)%mod+mod)%mod<<" ";
    }
    cout<<endl;
    return 0;
}
```

Upd in 5/5:改正了一个微小错误

人生第一道黑题就此结束

---

## 作者：静谧幽蓝 (赞：1)

题目链接：[$\texttt{P4512}$](https://www.luogu.com.cn/problem/P4512)

本文收录于[多项式全家桶学习笔记](https://www.luogu.com.cn/blog/144853/Polynomial-notes-and-codes)。

---

前置知识：[多项式求逆](https://www.luogu.com.cn/problem/P4238) 和 [多项式乘法](https://www.luogu.com.cn/problem/P3803)。

这里题目要求的是两个多项式 $D(x)$ 和 $R(x)$ ，使得 $F(x)=D(x)\cdot G(x)+R(x)$。

设有一种操作 $r$，使得 $F_r(x)$ 为原数组 $F(x)$ 的系数反过来，即设 $F(x)=1+2x+3x^2$，则 $F_r(x)=3+2x+x^3$。用数学表达就是：

$$F_r(x)=\sum^n_{i=0}x^nF[i]$$

其中 $F[i]$ 表示多项式 $F$ 的 $i$ 次项。

这样，我们就可以开始化式子了。

$$F(x)=D(x)\cdot G(x)+R(x)$$
$$x^nF(x)=x^n\cdot D(x)\cdot G(x)+x^nR(x)$$
$$x^nF(x)=\left(x^m\cdot D(x)\right)\cdot\left(x^{n-m}\cdot G(x)\right)+x^{n-m+1}\cdot\left(x^{m-1}\cdot R(x)\right)$$
$$F_r(x)=D_r(x)\cdot G_r(x)+x^{n-m+1}\cdot R_r(x)$$
$$F_r(x)=D_r(x)\cdot G_r(x)\pmod{x^{n-m+1}}$$
$$D_r(x)=\frac{F_r(x)}{G_r(x)}\pmod{x^{n-m+1}}$$

然后我们就可以把两个多项式反转一下，除数求逆之后再乘起来，再反转就可以求出 $D(x)$ 啦。

而 $R(x)$ 求出的方法可以由上面的式子移项之后得到，即：

$$R(x)=F(x)-G(x)\cdot D(x)$$

**Code**
```cpp
void getDiv(int *f,int *g,int *q,int *r,int lenf,int leng)
{
    memset(div1,0,sizeof(div1));//invgR(x)
    memset(div2,0,sizeof(div2));//fR(x)
    memset(div3,0,sizeof(div3));//gR(x)
    memset(div4,0,sizeof(div4));//q
    memset(div5,0,sizeof(div5));//f
    memset(div6,0,sizeof(div6));//g
    for(int i=0,x=lenf-1; x>=0; i++,x--)
        div2[i]=f[x],div5[i]=f[i];
    for(int i=0,x=leng-1; x>=0; i++,x--)
        div3[i]=g[x],div6[i]=g[i];
    int len=lenf-leng+1;
    getInv(div3,div1,len);
    init(len);
    for(int i=len; i<lenf; i++)
        div2[i]=div3[i]=0;
    NTT(div2,lim,1);
    NTT(div1,lim,1);
    for(int i=0; i<lim; i++)
        div2[i]=1ll*div2[i]%p*div1[i]%p;
    NTT(div2,lim,-1);
    for(int i=0,j=len-1; j>=0; i++,j--)
        div4[i]=div2[j],q[i]=div4[i];
    for(int i=len; i<lenf; i++)
        div4[i]=q[i]=0;
    len=lenf;
    init(len);
    NTT(div6,lim,1);
    NTT(div4,lim,1);
    for(int i=0; i<lim; i++)
        div4[i]=1ll*div4[i]*div6[i]%p;
    NTT(div4,lim,-1);
    for(int i=0; i<leng-1; i++)
        r[i]=((f[i]-div4[i])%p+p)%p;
    return;
}
```

---

## 作者：Warriors_Cat (赞：1)

人生第一道黑题，祭之。


前置知识：[FFT&NTT](https://www.luogu.com.cn/problem/P3803)，[多项式乘法逆](https://www.luogu.com.cn/problem/P4238)，不会的先出门左转吧。

---
### $Solution:$

这道题如果没有这个 $R(x)$ 那就直接乘法逆做完了。于是我们的目的就是把这个 $R(x)$ 消掉。

由于这是个多项式，我们只能靠取模这一操作把 $R(x)$ 项消掉。

那么我们最后应该得到这样一个式子：

$$F^*(x)=Q^*(x)G^*(x)+x^kR^*(x)$$

其中 $F^*(x), Q^*(x), G^*(x), R^*(x)$ 是由原来的式子经过一系列变换得来的。这样子直接模一个 $x^k$ 就行了。

题面中说到 $R(x)$ 次数小于 $m$ ，也就是小于等于 $m-1$，而且 $F(x)$ 和 $Q(x)G(x)$ 的次数均为 $n$，所以我们可以想到让 $k=n-m+1$。

那怎么得到这种式子呢？

这里有一个很~~naive~~神仙的操作：定义 $k$ 次多项式 $F^*(x)=x^kF(x^{-1})$！

我们来用这个推一下式子：

$$F(x)=Q(x)G(x)+R(x)$$

$$x^nF(x^{-1})=x^nQ(x^{-1})G(x^{-1})+x^nR(x^{-1})$$

$$F^*(x)=Q^*(x)G^*(x)+x^{n-m+1}R^*(x)$$

这下我们需要的式子就推出来了/cy

而且，$Q^*(x)$ 是 $n-m$ 次的，模一下也没什么问题！

至于 $F^*(x)$，我们可以发现这个多项式的系数恰好是 $F(x)$ 系数翻转过后得来的，证明的话，直接展开就行。

对上面那个式子模一个 $x^{n-m+1}$：

$$F^*(x)\equiv Q^*(x)G^*(x)(\!\!\!\!\!\!\mod\ x^{n-m+1})$$

$$Q^*(x)\equiv\frac{F^*(x)}{G^*(x)}(\!\!\!\!\!\!\mod\ x^{n-m+1})$$

$Q^*(x)$ 就用一个多项式乘法逆就知道了。得到 $Q^*(x)$ 后 $Q(x)$ 也就知道了。

得到 $Q(x)$，$R(x)$ 就不难啦：

$$R(x)=F(x)-Q(x)G(x)$$

至此，整道题迎刃而解。时间复杂度为 $O(n\log n)$。

放一下核心代码：

### $Code:$

```cpp
inline ll fpow(ll n, ll p){
	ll ans = 1, base = n;
	while(p){
		if(p & 1) ans = ans * base % mod;
		base = base * base % mod;
		p >>= 1;
	}
	return ans;
}//快速幂
ll n, m, r[N], A[N], a[N], b[N], f[N], rev, c[N], d[N], e[N];
inline void clr(ll *A, ll x, ll y){
	for(int i = x; i < y; ++i) A[i] = 0;
}//清空
inline void cpy(ll *A, ll *B, ll x, ll y){
	for(int i = x; i < y; ++i) A[i] = B[i];
}//赋值
inline void NTT(ll typ, ll *a, ll lim){
	if(lim != rev){
		rev = lim;
		for(int i = 0; i < lim; ++i) r[i] = (r[i >> 1] >> 1) | ((i & 1) ? (lim >> 1) : 0); 
	}
	for(ll i = 0; i < lim; ++i) if(i < r[i]) swap(a[i], a[r[i]]);
	for(ll mid = 1; mid < lim; mid <<= 1){
		ll R = mid << 1, rt = fpow(typ == 1 ? g : invg, (mod - 1) / R);
		for(ll j = 0; j < lim; j += R){
			ll w = 1;
			for(ll k = 0; k < mid; k++, w = w * rt % mod){
				ll x = a[j | k], y = w * a[j | k | mid] % mod;
				a[j | k] = (x + y) % mod;
				a[j | k | mid] = (x - y + mod) % mod;
			}
		}
	}
	if(typ < 0) for(ll i = 0, k = fpow(lim, mod - 2); i < lim; ++i) a[i] = a[i] * k % mod; 
}//NTT 板子
inline void ptm(ll *A, ll *B, ll len){
	for(int i = 0; i < len; ++i) A[i] = A[i] * B[i] % mod; 
} //point multiple，点乘
inline void print(ll *A, ll len){
	for(ll i = 0; i < len; ++i) printf("%lld ", A[i]);
	printf("\n");
}//输出
inline void Polymul(ll *A, ll *B, ll len, ll m){
	ll lim = 1; while(lim < len) lim <<= 1;
	cpy(e, B, 0, lim); clr(e, len, lim);
	NTT(1, A, lim); NTT(1, e, lim); ptm(A, e, lim);
	NTT(-1, A, lim); clr(A, m, lim);
}//多项式乘法
inline void Polyinv(ll *A, ll len){
	ll lim = 1; while(lim < len) lim <<= 1;
	a[0] = fpow(A[0], mod - 2);
	for(ll m = 2; m <= lim; m <<= 1){
		for(ll i = 0; i < (m >> 1); ++i) b[i] = (a[i] << 1) % mod;
		cpy(f, A, 0, m);
		NTT(1, a, m << 1); ptm(a, a, m << 1);
		NTT(1, f, m << 1); ptm(a, f, m << 1);
		NTT(-1, a, m << 1); clr(a, m, m << 1);
		for(ll i = 0; i < m; ++i) a[i] = (b[i] - a[i] + mod) % mod;
	}
	cpy(A, a, 0, len);
	clr(f, 0, lim << 1); clr(a, 0, lim << 1); clr(b, 0, lim << 1);
}//多项式求逆
inline void Rev(ll *A, ll len){
	for(register int i = 0; i < len / 2; ++i) swap(A[i], A[len - i - 1]);
}//翻转系数
inline void Polydiv(ll *A, ll *B, ll n, ll m){
	int len = n - m + 1;
	Rev(B, m); cpy(c, B, 0, len); Rev(B, m);
	Rev(A, n); cpy(d, A, 0, len); Rev(A, n);
	Polyinv(c, len); Polymul(c, d, len << 1, len); Rev(c, len);
	Polymul(B, c, n << 1, n);
	for(register int i = 0; i < m - 1; ++i) B[i] = (A[i] - B[i] + mod) % mod;
	clr(B, m - 1, n); cpy(A, c, 0, len); clr(A, len, n);  
}//核心中的核心：多项式除法
```

剩余的 IO，简单头文件和 main 函数就不放了，看懂的同学应该可以写出来。

---


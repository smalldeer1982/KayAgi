# 【模板】多项式开根（加强版）

## 题目背景

模板题，无背景

## 题目描述

给定一个 $n-1$ 次多项式 $A(x)$ ，求一个在 $\bmod\ {x^n}$ 意义下的多项式 $B(x)$ ，使得 $B^2(x)\equiv A(x)\pmod {x^n}$。

多项式的系数在 $\bmod\ 998244353$ 的意义下进行运算。

## 说明/提示

对于$25\%$的数据，有$n \leq 1000$

对于$50\%$的数据，有$n \leq 10^4$

对于$75\%$的数据，有$n \leq 5\times 10^4$

对于$100\%$的数据，有$n \leq 10^5,a_i \in [0,998244352] \cap \mathbb{Z}$

## 样例 #1

### 输入

```
3
1 2 1
```

### 输出

```
1 1 0```

## 样例 #2

### 输入

```
7
1 8596489 489489 4894 1564 489 35789489  
```

### 输出

```
1 503420421 924499237 13354513 217017417 707895465 411020414
```

# 题解

## 作者：SSerxhs (赞：16)

以下内容p均指模数998244353

前置芝士：二次剩余（模奇素数意义下）

二次剩余：求y使得$y^2=x(mod\ p)$

今年WC的zzt大佬讲课课件中提到几种求二次剩余的算法，这题应该都能用

## 法一：暴力

求出模p意义下的一个原根(其中一个是3)，bsgs求出x的指标（即求出a使得$3^a=x(mod\ p)$），然后直接指标除以二即可，复杂度$O(\sqrt{p})$

## 法二：Cipolla算法

找到一个b，使得$(b^2-x)$为模意义下的**二次非剩余**，设$(b^2-x)$为w则$y=(b+\sqrt{w})^\frac{p+1}{2}$，这里的$\sqrt{w}$不能具体求出（实际上也没有），计算时它类似于复数里的i，整个数字需要划分实部虚部并重载乘法运算。

b的求法？直接rand几个b，由于恰好有一半数字是可以当成b的，另一半不能，所以期望次数2次，总复杂度$O(log_2p)$

upd:证明如下：根据二项式定理，$y^2=b^{p+1}+\sqrt{w^{p+1}}$(其余项都含有p，可以直接消去)，根据欧拉判定可知$\sqrt{w^{p+1}}=w^{\frac{p+	1}{2}}=-w$，根据欧拉定理可知$b^{p+1}=b^2$，所以$y^2=b^2-w=x$

为什么不讲WC的第三种做法Tonelli-Shanks 算法？~~我不会~~

以下是本题正片
## 解法一：暴力求$A^{\frac{1}{2}}$

前置芝士：[多项式幂函数（加强版）](https://www.luogu.org/problemnew/show/P5273)

把代码粘过来，注意处理当前几位为0时原来的做法会把全部值都赋值成0（因为次数太高了，原本的做法最后是把数组**右移**），这里考虑本身需要是开根号，如果后几位有k个0只要做完幂函数之后重新**左移**k/2位就可以了

另一个细节：对于数字x来说，$x^{p-1}=1(mod\ p)$，然而对于多项式f(x)来说$f^p(x)=1(mod\ p)(mod\ x^n)$，所以实际上做的是f(x)的$2^{p-2}$次方，但提取第一个非0时应该照常求其二次剩余，不能也提取${a_0}^{(2^{p-2})}$出来。

代码如下，建议吸氧使用此方法
```cpp
// luogu-judger-enable-o2
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <stdlib.h>
using namespace std;
typedef long long ll;
typedef pair<int,int> pa;
const int N=2.7e5,p=998244353,I=86583718,II=911660635;
int r[N],ig[N],yg[N],invf[N],sqrtf[N],sqrtg[N],cdqf[N],cdqg[N],lnf[N],expf[N],expg[N];
int ksmf[N],inv[N],f[N],g[N],sinf[N],sing[N],cosf[N],cosg[N],tanf[N],tang[N],cotf[N];
int cotg[N];
int n,m,i,j,l,limit,biglimit,c,w;
pa ys,yys;
inline int sj()
{
    return rand()<<15|rand();
}
pa operator *(pa x,pa y)
{
    ys.first=((ll)x.first*y.first+(ll)x.second*y.second%p*w)%p;
    ys.second=((ll)x.first*y.second+(ll)x.second*y.first)%p;
    return ys;
}
inline void dbug(int *a,int n)
{
    for (int i=0;i<n;i++) printf("%d ",a[i]);puts("");
}
inline void read(int &x)
{
    c=getchar();
    while ((c<48)||(c>57)) c=getchar();
    x=c^48;c=getchar();
    while ((c>=48)&&(c<=57))
    {
        x=x*10+(c^48);
        c=getchar();
    }
}
inline int ksm(int x,int y)
{
    int r=1;
    while (y)
    {
        if (y&1) r=(ll)r*x%p;
        x=(ll)x*x%p;
        y>>=1;
    }
    return r;
}
inline pa ksm(pa x,int y)
{
    yys.first=1;yys.second=0;
    while (y)
    {
        if (y&1) yys=yys*x;
        x=x*x;
        y>>=1;
    }
    return yys;
}
inline int mosqrt(int x)
{
    pa a;
    int y=rand()%p;
    while (ksm(w=((ll)y*y%p-x+p)%p,p-1>>1)<=1) y=rand()%p;
    if (w<0) w+=p;
    a.first=y;a.second=1;
    a=ksm(a,p+1>>1);
    return min(a.first,p-a.first);
}
inline void ycl(int l,int limit)
{
    for (int i=1;i<limit;i++) r[i]=r[i>>1]>>1|(i&1)<<l;
}
inline void gg(int limit)
{
    int i;
    ig[limit]=ksm(yg[limit]=ksm(3,(p-1)/limit),p-2);
    for (i=limit>>1;i;i>>=1)
    {
        yg[i]=(ll)yg[i<<1]*yg[i<<1]%p;
        ig[i]=(ll)ig[i<<1]*ig[i<<1]%p;
    }
    inv[1]=1;
    for (i=2;i<limit;i++) inv[i]=p-(ll)p/i*inv[p%i]%p;
}
inline void reverse(int limit,int *f)
{
    int lim=limit>>1;
    for (i=0;i<lim;i++) swap(f[i],f[limit-i-1]);
}
inline void dao(int *a,int n)
{
    for (i=1;i<n;i++) a[i-1]=(ll)a[i]*i%p;a[n-1]=0;
}
inline void ji(int *a,int n)
{
    for (i=n-1;~i;i--) a[i+1]=(ll)a[i]*inv[i+1]%p;
    a[0]=0;
}
void dft(int *a,int xs,int limit)
{
    register int i,j,k,l,w,wn,b,c;
    for (i=1;i<limit;i++) if (i<r[i]) swap(a[i],a[r[i]]);
    for (i=1;i<limit;i=l)
    {
        l=i<<1;
        if (xs) wn=ig[l]; else wn=yg[l];
        for (j=0;j<limit;j+=l)
        {
            w=1;
            for (k=0;k<i;k++,w=(ll)w*wn%p)
            {
                b=a[j|k];c=(ll)w*a[j|k|i]%p;
                a[j|k]=(b+c)%p;
                a[j|k|i]=(b-c+p)%p;
            }
        }
    }
    if (xs)
    {
        limit=ksm(limit,p-2);
        for (i=0;i<xs;i++) a[i]=(ll)a[i]*limit%p;
    }
}
void polymultiply(int *f,int *g,int limit)
{
    int i;
    dft(f,0,limit<<1);dft(g,0,limit<<1); 
    for (i=0;i<limit<<1;i++) f[i]=(ll)f[i]*g[i]%p;
    dft(f,limit,limit<<1);
}
void polyinv(int *f,int *g,int biglim)
{
    int i,j,l=1,limit;
    memset(g,0,biglim<<3);
    memset(invf,0,biglim<<3);
    g[0]=ksm(f[0],p-2);
    for (i=2;i<=biglim;i=limit,l++)
    {
        limit=i<<1;
        memcpy(invf,f,limit<<1);
        for (j=1;j<limit;j++) r[j]=r[j>>1]>>1|(j&1)<<l;
        dft(invf,0,limit);dft(g,0,limit);
        for (j=0;j<limit;j++) g[j]=(ll)g[j]*(p+2-(ll)g[j]*invf[j]%p)%p;
        dft(g,i,limit);
        memset(g+i,0,limit<<1);
    }
}
void polysqrt(int *f,int *g,int biglim)//不动f
{
    memset(sqrtf,0,biglim<<3);
    memset(sqrtg,0,biglim<<3);
    memset(g,0,biglim<<3);
    int i,j,l=1,limit;
    g[0]=mosqrt(f[0]);
    if ((ll)g[0]*g[0]%p!=f[0]) while (1);
    for (i=2;i<=biglim;i=limit,l++)
    {
        limit=i<<1;
        polyinv(g,sqrtg,i);
        memcpy(sqrtf,f,limit<<1);
        dft(sqrtf,0,limit);dft(sqrtg,0,limit);dft(g,0,limit);
        for (j=0;j<limit;j++)
        {
            g[j]=(ll)sqrtg[j]*((ll)g[j]*g[j]%p+sqrtf[j])%p;
            if (g[j]&1) g[j]=g[j]+p>>1; else g[j]>>=1;
        }
        dft(g,i,limit);
        memset(g+i,0,limit<<1);
    }
}
/*void polycdq(int l,int r,int *f,int *g)
{
    if (l==r) return;
    int mid=l+r>>1;
    polycdq(l,mid,f,g);
    int i,limit,li,siz=r-l;
    limit=1;li=-1;
    while (limit<=siz)
    {
        limit<<=1;++li;
    }
    for (i=l;i<=mid;i++) cdqf[i-l]=f[i];
    for (i=mid-l+1;i<lim;i++) cdqf[i]=0;
    for (i=1;i<=r-l;i++) cdqg[i]=g[i];G[0]=0;
    for (i=r-l+1;i<lim;i++) cdqg[i]=0;
    polymultiply(cdqf,cdqg,li,limit);
    for (i=mid+1;i<=r;i++)
    {
        f[i]+=cdqf[i-l];
        if (f[i]>=p) f[i]-=p;
    }
    polycdq(mid+1,r,f,g);
}*/
void polydivide(int *f,int *g,int *q,int *r,int limit)
{

}
void polyln(int *f,int *g,int biglim)
{
    int i,limit=biglim<<1;
    memcpy(lnf,f,biglim<<2);
    memset(lnf+biglim,0,biglim<<2);
    polyinv(f,g,biglim);
    dao(lnf,biglim);
    dft(lnf,0,limit);dft(g,0,limit);
    for (i=0;i<limit;i++) g[i]=(ll)g[i]*lnf[i]%p;
    dft(g,biglim,limit);
    memset(g+biglim,0,biglim<<2);
    ji(g,biglim);
}
void polyexp(int *f,int *g,int biglim)
{
    memset(g,0,biglim<<3);
    memset(expf,0,biglim<<3);
    memset(expg,0,biglim<<3);
    g[0]=1;
    int i,j,l=1,limit;
    for (i=2;i<=biglim;i=limit,l++)
    {
        limit=i<<1;
        memcpy(expf,f,limit<<1);
        polyln(g,expg,i);
        dft(expf,0,limit);dft(g,0,limit);dft(expg,0,limit);
        for (j=0;j<limit;j++) g[j]=(ll)g[j]*(1+expf[j]-expg[j]+p)%p;
        dft(g,i,limit);
        memset(g+i,0,limit<<1);
    }
}
void polyksm1(int *f,int *g,int biglim,int cs)
{
    if (cs==0)
    {
        g[0]=1;
        return;
    }
    int i,j,k=1,wy=0;
    if (f[0]==0)
    {
        for (i=1;i<biglim;i++) if (f[i]) break;
        for (j=0;j<biglim-i;j++) f[j]=f[j+i];
        memset(f+biglim-i,0,i<<2);
        wy=cs>>1;
    }
    if (f[0]>1)
    {
        k=ksm(f[0],p-2);
        for (i=1;i<biglim;i++) f[i]=(ll)f[i]*k%p;
        k=mosqrt(f[0]);f[0]=1;//printf("%d\n",k);
    }
    polyln(f,ksmf,biglim);
    for (i=0;i<biglim;i++) ksmf[i]=(ll)ksmf[i]*cs%p;
    polyexp(ksmf,g,biglim);
    if (k!=1)
    {
        for (i=0;i<biglim;i++) g[i]=(ll)g[i]*k%p;
    }
    if (wy)
    {
        for (i=wy;i<biglim;i++) g[i-wy]=g[i],g[i]=0;
    }
}
void polyksm2(int *f,int *g,int biglim,int cs)
{
    int limit=1,i,l=-1;
    while (limit<=biglim)
    {
        limit<<=1;++l;
    }
    for (i=1;i<limit;i++) r[i]=r[i>>1]>>1|(i&1)<<l;g[0]=1;
    while (cs)
    {
        if (cs&1)
        {
            memcpy(ksmf,f,biglim<<2);
            memset(ksmf+biglim,0,biglim<<2);
            polymultiply(g,ksmf,biglim);
            memset(g+biglim,0,biglim<<2);
        }
        dft(f,0,limit);
        for (i=0;i<limit;i++) f[i]=(ll)f[i]*f[i]%p;
        dft(f,biglim,limit);
        memset(f+biglim,0,biglim<<2);
        cs>>=1;
    }
}
void polyksm3(int *f,int *g,int biglim,int cs)
{
    int i;
    memset(ksmf,0,biglim<<3);
    memset(g,0,biglim<<3);
    polyln(f,ksmf,biglim);
    for (i=0;i<biglim;i++) ksmf[i]=(ll)ksmf[i]*cs%p;
    polyexp(ksmf,g,biglim);
}
void polysin(int *f,int *g,int biglim)
{
    int i;
    for (i=0;i<biglim;i++) g[i]=(ll)f[i]*I%p;
    polyexp(g,sinf,biglim);
    for (i=0;i<biglim;i++) if ((g[i]=p-(ll)f[i]*I%p)==p) g[i]-=p;
    polyexp(g,sing,biglim);
    for (i=0;i<biglim;i++) g[i]=(ll)(sinf[i]-sing[i]+p)*II%p;
    for (i=0;i<biglim;i++) if (g[i]&1) g[i]=g[i]+p>>1; else g[i]>>=1;
}
void polycos(int *f,int *g,int biglim)
{
    int i;
    for (i=0;i<biglim;i++) g[i]=(ll)f[i]*I%p;
    polyexp(g,cosf,biglim);
    for (i=0;i<biglim;i++) if ((g[i]=p-(ll)f[i]*I%p)==p) g[i]-=p;
    polyexp(g,cosg,biglim);
    for (i=0;i<biglim;i++) if ((g[i]=cosf[i]+cosg[i])>=p) g[i]-=p;
    for (i=0;i<biglim;i++) if (g[i]&1) g[i]=g[i]+p>>1; else g[i]>>=1;
}
void polytan(int *f,int *g,int biglim)
{
    polysin(f,tanf,biglim);
    polycos(f,tang,biglim);
    polyinv(tang,g,biglim);
    polymultiply(g,tanf,biglim);
}
void polycot(int *f,int *g,int biglim)
{
    polysin(f,cotf,biglim);
    polycos(f,cotg,biglim);
    polyinv(cotf,g,biglim);
    polymultiply(g,cotg,biglim);
}
int main()
{
    read(n);
    limit=1;
    while (limit<n) limit<<=1;
    for (i=0;i<n;i++) read(f[i]);gg(limit<<1);
    polyksm1(f,g,limit,ksm(2,p-2));
    for (i=0;i<n;i++) printf("%d ",g[i]);
}
```
## 解法二：推柿子
前置芝士：[多项式求逆](https://www.luogu.org/problemnew/show/P4238)、套路倍增（当然直接牛顿迭代也不是不行）

设$F^2(x)=A(x)(mod\ x^n),G^2(x)=A(x)(mod\ x^{2n})$(以下直接用A、F和G代表多项式)

则$(F-G)^2=0(mod\ x^{2n})$

拆开发现$F^2+G^2=2FG(mod\ x^{2n})$

$G^2=A(mod\ x^{2n})$所以$G=\frac{F^2+A}{2F}$

然后直接倍增即可，边界条件求一次二次剩余

代码如下

```cpp
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <stdlib.h>
using namespace std;
typedef long long ll;
typedef pair<int,int> pa;
const int N=2.7e5,p=998244353,I=86583718,II=911660635;
int r[N],ig[N],yg[N],invf[N],sqrtf[N],sqrtg[N],cdqf[N],cdqg[N],lnf[N],expf[N],expg[N];
int ksmf[N],inv[N],f[N],g[N],sinf[N],sing[N],cosf[N],cosg[N],tanf[N],tang[N],cotf[N];
int cotg[N];
int n,m,i,j,l,limit,biglimit,c,w;
pa ys,yys;
inline int sj()
{
    return rand()<<15|rand();
}
pa operator *(pa x,pa y)
{
    ys.first=((ll)x.first*y.first+(ll)x.second*y.second%p*w)%p;
    ys.second=((ll)x.first*y.second+(ll)x.second*y.first)%p;
    return ys;
}
inline void dbug(int *a,int n)
{
    for (int i=0;i<n;i++) printf("%d ",a[i]);puts("");
}
inline void read(int &x)
{
    c=getchar();
    while ((c<48)||(c>57)) c=getchar();
    x=c^48;c=getchar();
    while ((c>=48)&&(c<=57))
    {
        x=x*10+(c^48);
        c=getchar();
    }
}
inline int ksm(int x,int y)
{
    int r=1;
    while (y)
    {
        if (y&1) r=(ll)r*x%p;
        x=(ll)x*x%p;
        y>>=1;
    }
    return r;
}
inline pa ksm(pa x,int y)
{
    yys.first=1;yys.second=0;
    while (y)
    {
        if (y&1) yys=yys*x;
        x=x*x;
        y>>=1;
    }
    return yys;
}
inline int mosqrt(int x)
{
    pa a;
    int y=rand()%p;
    while (ksm(w=((ll)y*y%p-x+p)%p,p-1>>1)<=1) y=rand()%p;
    if (w<0) w+=p;
    a.first=y;a.second=1;
    a=ksm(a,p+1>>1);
    return min(a.first,p-a.first);
}
inline void ycl(int l,int limit)
{
    for (int i=1;i<limit;i++) r[i]=r[i>>1]>>1|(i&1)<<l;
}
inline void gg(int limit)
{
    int i;
    ig[limit]=ksm(yg[limit]=ksm(3,(p-1)/limit),p-2);
    for (i=limit>>1;i;i>>=1)
    {
        yg[i]=(ll)yg[i<<1]*yg[i<<1]%p;
        ig[i]=(ll)ig[i<<1]*ig[i<<1]%p;
    }
    inv[1]=1;
    for (i=2;i<limit;i++) inv[i]=p-(ll)p/i*inv[p%i]%p;
}
inline void reverse(int limit,int *f)
{
    int lim=limit>>1;
    for (i=0;i<lim;i++) swap(f[i],f[limit-i-1]);
}
inline void dao(int *a,int n)
{
    for (i=1;i<n;i++) a[i-1]=(ll)a[i]*i%p;a[n-1]=0;
}
inline void ji(int *a,int n)
{
    for (i=n-1;~i;i--) a[i+1]=(ll)a[i]*inv[i+1]%p;
    a[0]=0;
}
void dft(int *a,int xs,int limit)
{
    register int i,j,k,l,w,wn,b,c;
    for (i=1;i<limit;i++) if (i<r[i]) swap(a[i],a[r[i]]);
    for (i=1;i<limit;i=l)
    {
        l=i<<1;
        if (xs) wn=ig[l]; else wn=yg[l];
        for (j=0;j<limit;j+=l)
        {
            w=1;
            for (k=0;k<i;k++,w=(ll)w*wn%p)
            {
                b=a[j|k];c=(ll)w*a[j|k|i]%p;
                a[j|k]=(b+c)%p;
                a[j|k|i]=(b-c+p)%p;
            }
        }
    }
    if (xs)
    {
        limit=ksm(limit,p-2);
        for (i=0;i<xs;i++) a[i]=(ll)a[i]*limit%p;
    }
}
void polymultiply(int *f,int *g,int limit)
{
    int i;
    dft(f,0,limit<<1);dft(g,0,limit<<1); 
    for (i=0;i<limit<<1;i++) f[i]=(ll)f[i]*g[i]%p;
    dft(f,limit,limit<<1);
}
void polyinv(int *f,int *g,int biglim)
{
    int i,j,l=1,limit;
    memset(g,0,biglim<<3);
    memset(invf,0,biglim<<3);
    g[0]=ksm(f[0],p-2);
    for (i=2;i<=biglim;i=limit,l++)
    {
        limit=i<<1;
        memcpy(invf,f,limit<<1);
        for (j=1;j<limit;j++) r[j]=r[j>>1]>>1|(j&1)<<l;
        dft(invf,0,limit);dft(g,0,limit);
        for (j=0;j<limit;j++) g[j]=(ll)g[j]*(p+2-(ll)g[j]*invf[j]%p)%p;
        dft(g,i,limit);
        memset(g+i,0,limit<<1);
    }
}
void polysqrt(int *f,int *g,int biglim)//不动f
{
    memset(sqrtf,0,biglim<<3);
    memset(sqrtg,0,biglim<<3);
    memset(g,0,biglim<<3);
    int i,j,l=1,limit;
    g[0]=mosqrt(f[0]);
    if ((ll)g[0]*g[0]%p!=f[0]) while (1);
    for (i=2;i<=biglim;i=limit,l++)
    {
        limit=i<<1;
        polyinv(g,sqrtg,i);
        memcpy(sqrtf,f,limit<<1);
        dft(sqrtf,0,limit);dft(sqrtg,0,limit);dft(g,0,limit);
        for (j=0;j<limit;j++)
        {
            g[j]=(ll)sqrtg[j]*((ll)g[j]*g[j]%p+sqrtf[j])%p;
            if (g[j]&1) g[j]=g[j]+p>>1; else g[j]>>=1;
        }
        dft(g,i,limit);
        memset(g+i,0,limit<<1);
    }
}
/*void polycdq(int l,int r,int *f,int *g)
{
    if (l==r) return;
    int mid=l+r>>1;
    polycdq(l,mid,f,g);
    int i,limit,li,siz=r-l;
    limit=1;li=-1;
    while (limit<=siz)
    {
        limit<<=1;++li;
    }
    for (i=l;i<=mid;i++) cdqf[i-l]=f[i];
    for (i=mid-l+1;i<lim;i++) cdqf[i]=0;
    for (i=1;i<=r-l;i++) cdqg[i]=g[i];G[0]=0;
    for (i=r-l+1;i<lim;i++) cdqg[i]=0;
    polymultiply(cdqf,cdqg,li,limit);
    for (i=mid+1;i<=r;i++)
    {
        f[i]+=cdqf[i-l];
        if (f[i]>=p) f[i]-=p;
    }
    polycdq(mid+1,r,f,g);
}*/
void polydivide(int *f,int *g,int *q,int *r,int limit)
{

}
void polyln(int *f,int *g,int biglim)
{
    int i,limit=biglim<<1;
    memcpy(lnf,f,biglim<<2);
    memset(lnf+biglim,0,biglim<<2);
    polyinv(f,g,biglim);
    dao(lnf,biglim);
    dft(lnf,0,limit);dft(g,0,limit);
    for (i=0;i<limit;i++) g[i]=(ll)g[i]*lnf[i]%p;
    dft(g,biglim,limit);
    memset(g+biglim,0,biglim<<2);
    ji(g,biglim);
}
void polyexp(int *f,int *g,int biglim)
{
    memset(g,0,biglim<<3);
    memset(expf,0,biglim<<3);
    memset(expg,0,biglim<<3);
    g[0]=1;
    int i,j,l=1,limit;
    for (i=2;i<=biglim;i=limit,l++)
    {
        limit=i<<1;
        memcpy(expf,f,limit<<1);
        polyln(g,expg,i);
        dft(expf,0,limit);dft(g,0,limit);dft(expg,0,limit);
        for (j=0;j<limit;j++) g[j]=(ll)g[j]*(1+expf[j]-expg[j]+p)%p;
        dft(g,i,limit);
        memset(g+i,0,limit<<1);
    }
}
void polyksm1(int *f,int *g,int biglim,int cs)
{
    if (cs==0)
    {
        g[0]=1;
        return;
    }
    int i,j,k=1,wy=0;
    if (f[0]==0)
    {
        for (i=1;i<biglim;i++) if (f[i]) break;
        for (j=0;j<biglim-i;j++) f[j]=f[j+i];
        memset(f+biglim-i,0,i<<2);
        if ((ll)i*cs>=biglim) return;
        wy=i*cs;
    }
    if (f[0]>1)
    {
        k=ksm(f[0],p-2);
        for (i=1;i<biglim;i++) f[i]=(ll)f[i]*k%p;
        k=ksm(f[0],cs);f[0]=1;
    }
    polyln(f,ksmf,biglim);
    for (i=0;i<biglim;i++) ksmf[i]=(ll)ksmf[i]*cs%p;
    polyexp(ksmf,g,biglim);
    if (k!=1)
    {
        for (i=0;i<biglim;i++) g[i]=(ll)g[i]*k%p;
    }
    if (wy)
    {
        for (i=biglim-1;i>=wy;i--) g[i]=g[i-wy];
        memset(g,0,wy<<2);  
    }
}
void polyksm2(int *f,int *g,int biglim,int cs)
{
    int limit=1,i,l=-1;
    while (limit<=biglim)
    {
        limit<<=1;++l;
    }
    for (i=1;i<limit;i++) r[i]=r[i>>1]>>1|(i&1)<<l;g[0]=1;
    while (cs)
    {
        if (cs&1)
        {
            memcpy(ksmf,f,biglim<<2);
            memset(ksmf+biglim,0,biglim<<2);
            polymultiply(g,ksmf,biglim);
            memset(g+biglim,0,biglim<<2);
        }
        dft(f,0,limit);
        for (i=0;i<limit;i++) f[i]=(ll)f[i]*f[i]%p;
        dft(f,biglim,limit);
        memset(f+biglim,0,biglim<<2);
        cs>>=1;
    }
}
void polyksm3(int *f,int *g,int biglim,int cs)
{
    int i;
    memset(ksmf,0,biglim<<3);
    memset(g,0,biglim<<3);
    polyln(f,ksmf,biglim);
    for (i=0;i<biglim;i++) ksmf[i]=(ll)ksmf[i]*cs%p;
    polyexp(ksmf,g,biglim);
}
void polysin(int *f,int *g,int biglim)
{
    int i;
    for (i=0;i<biglim;i++) g[i]=(ll)f[i]*I%p;
    polyexp(g,sinf,biglim);
    for (i=0;i<biglim;i++) if ((g[i]=p-(ll)f[i]*I%p)==p) g[i]-=p;
    polyexp(g,sing,biglim);
    for (i=0;i<biglim;i++) g[i]=(ll)(sinf[i]-sing[i]+p)*II%p;
    for (i=0;i<biglim;i++) if (g[i]&1) g[i]=g[i]+p>>1; else g[i]>>=1;
}
void polycos(int *f,int *g,int biglim)
{
    int i;
    for (i=0;i<biglim;i++) g[i]=(ll)f[i]*I%p;
    polyexp(g,cosf,biglim);
    for (i=0;i<biglim;i++) if ((g[i]=p-(ll)f[i]*I%p)==p) g[i]-=p;
    polyexp(g,cosg,biglim);
    for (i=0;i<biglim;i++) if ((g[i]=cosf[i]+cosg[i])>=p) g[i]-=p;
    for (i=0;i<biglim;i++) if (g[i]&1) g[i]=g[i]+p>>1; else g[i]>>=1;
}
void polytan(int *f,int *g,int biglim)
{
    polysin(f,tanf,biglim);
    polycos(f,tang,biglim);
    polyinv(tang,g,biglim);
    polymultiply(g,tanf,biglim);
}
void polycot(int *f,int *g,int biglim)
{
    polysin(f,cotf,biglim);
    polycos(f,cotg,biglim);
    polyinv(cotf,g,biglim);
    polymultiply(g,cotg,biglim);
}
int main()
{
    read(n);
    limit=1;
    while (limit<n) limit<<=1;
    for (i=0;i<n;i++) read(f[i]);gg(limit<<1);
    polysqrt(f,g,limit);
    for (i=0;i<n;i++) printf("%d ",g[i]);
}
```


---

## 作者：Great_Influence (赞：6)

给一个方法，开多少次方都可以。当然对于这道题只要写一个开方就可以了。

根据初中数学只是可以知道:

$$\sqrt[k] a=a^{\frac{1}{k}}$$

那么，我们实际上需要求的是 $\frac{1}{k}$ 次方根。

而在膜意义下，这个数字等价于 $a^{k^{-1}}$ 。

那么，我们就只需要求一个 $k^{-1}$ 次方根就可以了。

如果用分治乘法的话， $k$ 可能不与 $mod-1$ 互质， $k^{-1}$ 可能不存在。但是一般情况下， $k$ 与 $mod$ 是互质的。因此我们只需要套用 $\ln$ 和 $\exp$ 实现的快速幂即可。

复杂度为 $O(n\log n)$ 。

这里给一个求 $k$ 次剩余的方法。

可以知道，我们平常用的膜数都是 $998244353$ 之类的膜数，因此原根一般是有完整定义的。

那么，设 $a_0=3^t$ ，我们需要的其实是 $3^{\frac{t}{k}}$ 。

如果 $\frac{t}{k}$ 在膜 $mod-1$ 意义下不存在，那么这个数字不存在 $k$ 次剩余。

否则我们直接用 $exgcd$ 算出结果就可以了。利用 $BSGS$ 实现求 $t$ ，复杂度为 $O(\sqrt{mod})$ 。

核心代码:

```cpp
int dir=0,fst;

map<int,int>G;

const int iv2=(mod+1)/2;

inline int gettwo(int x)//用BSGS求二次剩余
{
	const int blk=sqrt(mod);
	register int z=1,t=1;
	rep(i,0,blk)G[z]=i,z=z*3ll%mod;
	z=power(z,mod-2);
	for(register int i=0;;++i)
	{
		if(G[(ll)x*t%mod])
		{
			int mz=i*blk+G[(ll)x*t%mod];
			return power(3,mz/2);
        }//只要二次方根，不需要exgcd。
		t=(ll)t*z%mod;
	}
	return x;
}

int main()
{
	if(!F[0])
	{
		dir=-1;
		Rep(i,1,n)if(F[i]){dir=i;break;}
		if(dir==-1){Rep(i,1,n)write(0,' ');flush();exit(0);}
		Rep(i,dir,n)F[i-dir]=F[i],F[i]=0;
	}
	fst=F[0];
	register int iv=power(fst,mod-2);
	Rep(i,0,n)F[i]=(ll)F[i]*iv%mod;
	Ln(F,F,n);
	Rep(i,0,n)F[i]=(ll)F[i]*iv2%mod;//直接上 ln 和 exp
	Exp(F,F,n);
	fst=gettwo(fst);
	if(fst>(mod+1)/2)fst=mod-fst;
	Rep(i,1,dir/2)write(0,' ');
	Rep(i,0,n-dir/2)write((ll)fst*F[i]%mod,' ');
	return 0;
}

```

---

## 作者：周道_Althen (赞：6)

## ~~广告:[【多项式的操作大赏】](https://blog.csdn.net/weixin_43973966/article/details/87864851)~~


$\ \ \ \ \ \ \ $这道题的话，周道来提供一种不同的思路吧，理论上面可以解 **开任意次方** 的多项式问题。

$\ \ \ \ \ \ \ $对于求$B=\sqrt[k]A$，显然有：

$$B=exp\left(\frac{ln(A)}{k}\right)$$

$\ \ \ \ \ \ \ $在我这篇题解里面：[题解 P5273 【【模板】多项式幂函数 (加强版)】](https://www.luogu.org/blog/Althen-Way-Satan/solution-p5273)，有提到过，对于求常数项不是 $0$ 的多项式的 $exp$，我们可以单独求出 $exp$ 的常数项，问题便可以迎刃而解：

$\ \ \ \ \ \ \ $那么常数项显然是：

$$\sqrt[k]{A_0}\ \ \ (\%998244353)$$

$\ \ \ \ \ \ \ $现在$k=2$ 嘛，就是求$A_0$在$(\%998244353)$意义下的二次剩余啦。

$\ \ \ \ \ \ \ $可是周道太菜了，不会二次剩余……QAQ

$\ \ \ \ \ \ \ $没关系，我们可以$BSGS$乱搞：

$\ \ \ \ \ \ \ $已知$998244353$的原根是$3$，既所有的数在$(\%998244353)$意义下都可以被 $3^x$ 表达。

$\ \ \ \ \ \ \ $那么我们令：

$$3^x\equiv\sqrt[k]{A_0}\ \ \ (\%998244353)$$

$\ \ \ \ \ \ \ $既：

$$3^{xk}\equiv A_0\ \ \ (\%998244353)$$

$\ \ \ \ \ \ \ $通过$BSGS$，我们就可以很轻松算出 $xk$ 的取值啦，令$p=xk$，然后他是保证有解的，所以 $k$ 一定整除 $p$ ，就可以算出来：

$$\sqrt[k]{A_0}\equiv 3^{\frac{p}{k}}\ \ \ (\%998244353)$$

$\ \ \ \ \ \ \ $代码是这样子的，理论还可以开高次根的说 ~~（就没有试过了）~~ ：

```cpp
int BSGS(int a,int b){
  unordered_map<int,int>hash;hash.clear();b%=mod;
  int t=(int)sqrt(mod)+1;
  for(register int j=0;j<t;j++){
    int val=(int)(1ll*b*power(a,j)%mod);
    hash[val]=j;
  }
  a=power(a,t);
  if(a==0){
    if(b==0)return 1;
    else return -1;
  }
  for(register int i=0;i<=t;++i){
    int val=power(a,i);
    int j=hash.find(val)==hash.end()?-1:hash[val];
    if(j>=0&&i*t-j>=0)return i*t-j;
  }
  return -1;
}
int solve(int a,int K){
  int p=BSGS(mod_g,a);
  int ret=power(mod_g,p/K);
  return ret;
}
```

$\ \ \ \ \ \ \ $然后套板子然后一交，怎么连 $WA$ 带 $TLE$ ???

$\ \ \ \ \ \ \ $于是我问了一下：[多组解？](https://www.luogu.org/discuss/show/107417)

$\ \ \ \ \ \ \ $就变成了：

```cpp
int solve(int a,int K){
  int p=BSGS(mod_g,a);
  int ret=power(mod_g,p/K);
  return min(ret,mod-ret);
}
```

$\ \ \ \ \ \ \ $然后对是对了，就是卡了很久常数，其实也挺好的，优化了自己的模板，代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstdlib>
#include<cstring>
#include<string>
#include<queue>
#include<unordered_map>
#include<set>
#include<stack>
#include<cmath>
#include<cctype>
using namespace std;
const int inf=0x7fffffff;
const double eps=1e-10;
const double pi=acos(-1.0);
//char buf[1<<15],*S=buf,*T=buf;
//char getch(){return S==T&&(T=(S=buf)+fread(buf,1,1<<15,stdin),S==T)?0:*S++;}
inline int read(){
  int x=0,f=1;char ch;ch=getchar();
  while(ch<'0'||ch>'9'){if(ch=='-') f=0;ch=getchar();}
  while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch&15);ch=getchar();}
  if(f)return x;else return -x;
}
const int N=13e5+10;
const int mod=998244353,mod_g=3;
int K;
int R[N];
int power(int a,int b){
  int ans=1;
  for(;b;b>>=1,a=1ll*a*a%mod)if(b&1)ans=1ll*ans*a%mod;
  return ans;
}
#define Inv(x) power(x,mod-2)
int Polynomial_init(int n){
  int len;for(len=1;len<n;len<<=1);
  return len;
}
int g[22],inv[N];
void Get_Inv(int n){
  inv[1]=1;
  for(int i=2;i<=n;i++)inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
}
inline int add(int a,int b){return (a+=b)>=mod?a-mod:a;}
void NTT(int a[],int f,int Len){
  for(int i=1;i<Len;i++)if(i<R[i])swap(a[i],a[R[i]]);
  static int i,j,k,kk,w,t,wn,r;
  for(k=2,kk=1,r=1;k<=Len;k<<=1,kk<<=1,++r){
    wn=g[r];
    for(i=0;i<Len;i+=k)
    for(j=0,w=1;j<kk;++j,w=1ll*w*wn%mod){
      t=1ll*w*a[i+j+kk]%mod;
      a[i+j+kk]=add(a[i+j],mod-t);
      a[i+j]=add(a[i+j],t);
    }
  }
  if(f==-1){
    reverse(a+1,a+Len);
    for(int i=0;i<Len;++i)a[i]=1ll*a[i]*inv[Len]%mod;
  }
}
void Convolution(int *a,int *b,int la,int lb){
  int n=la,m=lb;
  int L=0;for(m+=n,n=1;n<=m;n<<=1)L++;
  for(register int i=0;i<n;++i)R[i]=(R[i>>1]>>1)|((i&1)<<(L-1));
  NTT(a,1,n);NTT(b,1,n);
  for(register int i=0;i<=n;++i)a[i]=1ll*a[i]*b[i]%mod;
  NTT(a,-1,n);
}
int I[N],J[N];
void Multiplication(int *a,int *b,int *c,int la,int lb){
  int n=la,m=lb;
  int L=0;for(m+=n,n=1;n<=m;n<<=1)L++;
  for(register int i=0;i<n;++i)R[i]=(R[i>>1]>>1)|((i&1)<<(L-1));
  for(register int i=0;i<=la;++i) I[i]=a[i];
  for(register int i=0;i<=lb;++i) J[i]=b[i];
  NTT(I,1,n);NTT(J,1,n);
  for(register int i=0;i<=n;++i)c[i]=1ll*I[i]*J[i]%mod,I[i]=J[i]=0;
  NTT(c,-1,n);
}
int C[N];
void Inverse(int *a,int *b,int len){
  if(len==1){b[0]=Inv(a[0]);return;}
  Inverse(a,b,(len+1)>>1);
  int L=0,n=1;
  for(;n<(len<<1);n<<=1)L++;
  for(register int i=1;i<n;++i)R[i]=(R[i>>1]>>1)|((i&1)<<(L-1));
  for(register int i=0;i<len;++i)C[i]=a[i];
  for(register int i=len;i<n;++i)C[i]=0;
  NTT(C,1,n);NTT(b,1,n);
  for(register int i=0;i<=n;++i)b[i]=1ll*add(2ll,mod-1ll*C[i]*b[i]%mod)*b[i]%mod;
  NTT(b,-1,n);
  for(register int i=len;i<n;++i)b[i]=0;
}
int H[N];
void Derivation(int *a,int *b,int n){
  for(register int i=1;i<n;++i)
  b[i-1]=1ll*i*a[i]%mod;
  b[n-1]=0;
}
void Integral(int *a,int *b,int n){
  for(register int i=1;i<n;++i)
  b[i]=1ll*inv[i]*a[i-1]%mod;
  b[0]=0;
}
int ln_a[N],ln_b[N];
void Logarithmic(int *a,int *b,int n){
  memset(ln_a,0,sizeof(ln_a));
  memset(ln_b,0,sizeof(ln_b));
  Derivation(a,ln_a,n);
  memset(C,0,sizeof(C));
  Inverse(a,ln_b,n);
  Convolution(ln_a,ln_b,n,n);
  Integral(ln_a,b,n);
}
int D[N];
void Exponential(int *a,int *b,int len){
  if(len==1){return;}
  Exponential(a,b,len>>1),Logarithmic(b,D,len);
  D[0]=add(a[0],mod+1ll-D[0]);
  for(register int i=1;i<len;++i) D[i]=add(a[i],mod-D[i]);
  Convolution(b,D,len,len);
  for(register int i=len;i<(len<<1);++i) b[i]=D[i]=0;
}
int gcd(int a,int b){return b?gcd(b,a%b):a;}
int BSGS(int a,int b){
  unordered_map<int,int>hash;hash.clear();b%=mod;
  int t=(int)sqrt(mod)+1;
  for(register int j=0;j<t;j++){
    int val=(int)(1ll*b*power(a,j)%mod);
    hash[val]=j;
  }
  a=power(a,t);
  if(a==0){
    if(b==0)return 1;
    else return -1;
  }
  for(register int i=0;i<=t;++i){
    int val=power(a,i);
    int j=hash.find(val)==hash.end()?-1:hash[val];
    if(j>=0&&i*t-j>=0)return i*t-j;
  }
  return -1;
}
int solve(int a,int K){
  int p=BSGS(mod_g,a);
  int ret=power(mod_g,p/K);
  return min(ret,mod-ret);
}
int s_a[N];
void Kth_root(int *a,int *b,int len,int K){
  Logarithmic(a,s_a,len);
  int Kr=Inv(K);
  for(register int i=1;i<=len;++i)s_a[i]=1ll*s_a[i]*Kr%mod;
  b[0]=solve(a[0],K);
  Exponential(s_a,b,len);
}
int n,F[N],G[N],low;
int main()
{
  Get_Inv(N-10);
  for(register int i=1,j=2;i<=19;++i,j<<=1)g[i]=power(mod_g,(mod-1)/j);
  n=read();K=2;
  for(register int i=0;i<n;++i)F[i]=read();
  Kth_root(F,G,Polynomial_init(n),K);
  for(register int i=0;i<n;++i)cout<<G[i]<<" ";
  return 0;
}

```

---

## 作者：Vocalise (赞：5)

因P5205题解已关，一并提交于P5277。事实上是两题的题解。

### P5205

考虑多项式exp的做法，牛顿迭代。

则易有

$$F(G(x))=G^2(x)-A(x)\equiv 0\pmod{x^n}$$

已知

$$F(G_0(x))\equiv 0\pmod{x^{\lceil \frac n2\rceil}}$$

有

$$\begin{aligned}
G(x)&\equiv G_0(x)-\frac{F(G(x))}{F'(G_0(x))} \\
&\equiv G_0(x)-\frac{G_0^2(x)-A(x)}{2G_0(x)} \\
&\equiv G_0(x)-\frac 12G_0(x)+\frac{A(x)}{2G_0(x)} \\
&\equiv \frac 12(G_0(x)+\frac{A(x)}{G_0(x)})\pmod{x^n}
\end{aligned}$$

递归中求一个逆就行了。

边界自然，对于 $a_0 = 1$，$b_0=\sqrt 1=1$。

这就是P5205的做法。

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>

typedef long long ll;
const int p = 998244353;
const int inv2 = 499122177;
const int MAXN = 4000001;

inline ll read() {
    ll x = 0,f = 1; char ch = getchar();
    while(ch > '9' || ch < '0') { if(ch == '-') f = -1; ch = getchar(); }
    do x = (x * 10 + ch - 48) % p, ch = getchar(); while(ch >= '0' && ch <= '9');
    return (x * f % p + p) % p;
}

int n,r[MAXN];
ll a[MAXN],b[MAXN],a1[MAXN],b1[MAXN];

ll fastpow(ll a,int b) {
    ll res = 1; a %= p;
    while(b) {
        if(b & 1) res = res * a % p;
        a = a * a % p;
        b >>= 1;
    }
    return res;
}

void NTT(ll *a,int N) {
    for(int i = 0;i < N;i++) if(i < r[i]) std::swap(a[i],a[r[i]]);
    for(int n = 2,m = 1;n <= N;m = n, n <<= 1) {
        ll g1 = fastpow(3,(p - 1) / n);
        for(int l = 0;l < N;l += n) {
            ll g = 1,t1,t2;
            for(int i = l;i < l + m;i++) {
                t1 = a[i], t2 = g * a[i + m] % p;
                a[i] = (t1 + t2) % p;
                a[i + m] = (t1 - t2 + p) % p;
                g = g * g1 % p;
            }
        }
    }
    return;
}

void INTT(ll *a,int N) {
    NTT(a,N);
    std::reverse(a + 1,a + N);
    int invN = fastpow(N,p - 2);
    for(int i = 0;i < N;i++) a[i] = a[i] * invN % p;
}

void Inv(ll *a,ll *b,int n) {
    if(n == 1) return void(b[0] = fastpow(a[0],p - 2));
    Inv(a,b,(n + 1) >> 1);
    int N = 1, l = -1; while(N <= n << 1) N <<= 1, l++;
    for(int i = 1;i < N;i++) r[i] = (r[i >> 1] >> 1) | ((i & 1) << l);
    for(int i = 0;i < n;i++) a1[i] = a[i];
    for(int i = n;i < N;i++) a1[i] = 0;
    NTT(a1,N); NTT(b,N);
    for(int i = 0;i < N;i++) b[i] = ((b[i] << 1) % p + p - a1[i] * b[i] % p * b[i] % p) % p;
    INTT(b,N);
    for(int i = n;i < N;i++) b[i] = 0;
    return;
}

void Sqrt(ll *a,ll *b,int n) {
    if(n == 1) return void(b[0] = 1);
    Sqrt(a,b,(n + 1) >> 1);
    memset(b1,0,sizeof(b1));
    Inv(b,b1,n);
    int N = 1, l = -1; while(N <= n << 1) N <<= 1, l++;
    for(int i = 1;i < N;i++) r[i] = (r[i >> 1] >> 1) | ((i & 1) << l);
    for(int i = 0;i < n;i++) a1[i] = a[i];
    for(int i = n;i < N;i++) a1[i] = 0;
    NTT(a1,N); NTT(b,N); NTT(b1,N);
    for(int i = 0;i < N;i++) b[i] = (b[i] + a1[i] * b1[i] % p) % p * inv2 % p;
    INTT(b,N);
    for(int i = n;i < N;i++) b[i] = 0;
    return;
}

int main() {
    n = read();
    for(int i = 0;i < n;i++) a[i] = read();
    Sqrt(a,b,n);
    for(int i = 0;i < n;i++) std::printf("%lld ",b[i]);
    return 0;
}
```

那对于P5277呢？此题不保证 $a_0=1$。

### P5277

这题实际上就是带上了给常数开根的P5205了。。

这里仅对Cipolla算法作一点最基本的说明。

模意义下开根，即对于 $a$ 及模数 $p$，求 $x$，

$$x^2\equiv a\pmod p$$

若方程有解，则 $a$ 为模 $p$ 下的二次剩余，否则称为二次非剩余。则本题保证有解。

下文讨论中 $p$ 为奇数素数，否则 $\frac{p-1}2$ 不会是整数。

#### 个数结论

首先，$[1,p)$ 中，模 $p$ 下的二次非剩余有 $\frac{p-1}2$ 个。

证明：考虑两个数 $x,y\in[1,p)$, $x^2\equiv y^2\pmod p$，其代表同一个二次剩余。

有 $p|(x^2-y^2)$,即 $p|(x-y)(x+y)$。

由于 $p\not|(x-y)$，则 $p|(x+y)$，$x\equiv p-y\pmod p$，即 $x=p-y$。

反之也容易展开得到 $x^2\equiv (p-x)^2\pmod p$。

则有当且仅当 $x=p-y$ 时其模 $p$ 下的平方相等；其中便有 $\frac{p-1}2$ 个二次剩余。

对于 $[1,p)$ 以外的 $x,y$，有 $x^2\equiv (x\mod p)^2$，不作考虑了。

#### 勒让德符号与欧拉判别

定义勒让德符号

$$\binom{\underline n}{p}$$

（latex写得不对不要在意）

有如下取值：

$1$,此时 $n$ 是模 $p$ 下的二次剩余；

$-1$,此时 $n$ 是模 $p$ 下的二次非剩余；

$0$，此时 $p|n$。

我们有欧拉判别式：

$$\binom{\underline n}p\equiv n^{\frac{p-1}2}\pmod p$$

证明可以简单地分类讨论一下。

取 $1$ 时，取方程 $x^2\equiv n\pmod p$ 的一个解 $x$，根据费马小定理，$x^{p-1}\equiv 1\pmod p$，换 $n$ 代入则有

$$x^{p-1}\equiv{(x^2)^{\frac{p-1}2}}\equiv n^{\frac{p-1}2}\equiv 1\pmod p$$

取 $-1$ 时，上述方程无解。考虑 $a\in[1,p)$ 及方程

$$ax\equiv n\pmod p$$

$$ax+py=n$$

方程有解，且对于一个解 $x_0$，有通解

$$x=x_0+k\frac p{\gcd(p,a)}=x_0+kp$$

则在 $[1,p)$ 范围内解唯一。

对于一个 $a\in[1,p)$ 有唯一的 $x\in[1,p)$ 使其相乘为 $n\pmod p$。于是 $(p-1)!\equiv n^{\frac{p-1}2}\equiv -1\pmod p$。

那为何 $n$ 不能为 $p$ 的二次剩余呢？因为此时对于 $x^2\equiv n\pmod p$ 的解其对应的因子是本身，取不到 $(p-1)!$ 了。

由 $n^{\frac{p-1}2}\equiv -1\pmod p$ 推出 $n$ 为二次非剩余的过程与上述过程类似，略。

取 $0$ 时显然。

#### 算法流程

首先，如果 $n$ 是二次非剩余，返回无解，当然这题不需要。

根据上述的个数结论，我们可以随机一个 $a$，使 $a^2-n$ 为非剩余，用欧拉式 $O(\log p)$ 快速幂判别。这个步骤期望只要两次。

得到一个 $a$ 后，求出 $w=\sqrt{a^2-n}$。这里其实是求不出来的，也不需要表示成整数；但是我们可以借复数进行运算，将其作为复数单位 $i$。

使其非剩余的意义在这：$w^p\equiv -w\pmod p$，证明：

$$w^p\equiv ww^{p-1}\equiv w(a^2-n)^{\frac{p-1}2}\equiv-w\pmod p$$

有结论 $x$ 即为 $(a+w)^{\frac{p+1}2}$。

证明：

$$\begin{aligned}
x^2&\equiv (a+w)^{p+1} \\
&\equiv (a+w)(a+w)^p
\end{aligned}$$

这里有一个小结论： $a^p+b^p\equiv(a+b)^p\pmod p$

右边展开得

$$\sum_{i=0}^p\binom pia^ib^{p-i}$$

组合数直接展开发现 $i\not=0$ 且 $i\not=p$ 时 $\binom pi\equiv0\pmod p$。

$$\begin{aligned}
x^2&\equiv (a+w)(a^p+w^p) \\
&\equiv(a+w)(aa^{p-1}+(-w)) \\
&\equiv(a+w)(a-w) \\
&\equiv a^2-w^2\equiv a^2-a^2+n\equiv n\pmod p
\end{aligned}$$

于是就这样了。

实现上仿造复数，只需定义复数的乘法，并作快速幂。根据结论，最后运算结果中只有 “实部”，返回其作为答案即可。

还有一点：根据 $y^2\equiv(p-y)^2\pmod p$，对答案 $y$ 也有答案 $p-y$。两者取 $\min$。~~这点本题好像没说清楚啊，但是样例中可以发现的。~~

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cstdlib>
#include <ctime>

typedef long long ll;
const int p = 998244353;
const int inv2 = 499122177;
const int MAXN = 4000001;

ll read() {
    ll x = 0,f = 1; char ch = getchar();
    while(ch > '9' || ch < '0') { if(ch == '-') f = -1; ch = getchar(); }
    do x = (x * 10 + ch - 48) % p, ch = getchar(); while(ch >= '0' && ch <= '9');
    return (x * f % p + p) % p;
}

int n,r[MAXN];
ll a[MAXN],b[MAXN],a1[MAXN],b1[MAXN];

ll fastpow(ll a,int b) {
    ll res = 1; a %= p;
    while(b) {
        if(b & 1) res = res * a % p;
        a = a * a % p;
        b >>= 1;
    }
    return res;
}

void NTT(ll *a,int N) {
    for(int i = 0;i < N;i++) if(i < r[i]) std::swap(a[i],a[r[i]]);
    for(int n = 2,m = 1;n <= N;m = n, n <<= 1) {
        ll g1 = fastpow(3,(p - 1) / n);
        for(int l = 0;l < N;l += n) {
            ll g = 1,t1,t2;
            for(int i = l;i < l + m;i++) {
                t1 = a[i], t2 = g * a[i + m] % p;
                a[i] = (t1 + t2) % p;
                a[i + m] = (t1 - t2 + p) % p;
                g = g * g1 % p;
            }
        }
    }
    return;
}

void INTT(ll *a,int N) {
    NTT(a,N);
    std::reverse(a + 1,a + N);
    int invN = fastpow(N,p - 2);
    for(int i = 0;i < N;i++) a[i] = a[i] * invN % p;
}

ll w;

struct Complex
{
    ll x, y;
    Complex(ll _x = 0, ll _y = 0) : x(_x), y(_y) {}
    friend Complex operator *(const Complex a,const Complex b) {
        return Complex((a.x * b.x % p + w * a.y % p * b.y % p) % p,(a.x * b.y % p + a.y * b.x % p) % p);
    }
};

ll fastpow(Complex a,ll b) {
    Complex ans(1,0);
    while(b) {
        if(b & 1) ans = ans * a;
        a = a * a;
        b >>= 1;
    }
    return ans.x;
}

ll Cipolla(ll x) {
    srand(time(0));
    if (fastpow(x,(p - 1) >> 1) == p - 1) return -1;
    while(true) {
        ll a = (1ll * rand() << 15 | rand()) % p;
        w = (a * a % p + p - x) % p;
        if(fastpow(w,(p - 1) >> 1) == p - 1) {
            ll res = fastpow(Complex(a,1),(p + 1) >> 1);
            return std::min(res,p - res);
        }
    }
}

void Inv(ll *a,ll *b,int n) {
    if(n == 1) return void(b[0] = fastpow(a[0],p - 2));
    Inv(a,b,(n + 1) >> 1);
    int N = 1, l = -1; while(N <= n << 1) N <<= 1, l++;
    for(int i = 1;i < N;i++) r[i] = (r[i >> 1] >> 1) | ((i & 1) << l);
    for(int i = 0;i < n;i++) a1[i] = a[i];
    for(int i = n;i < N;i++) a1[i] = 0;
    NTT(a1,N); NTT(b,N);
    for(int i = 0;i < N;i++) b[i] = ((b[i] << 1) % p + p - a1[i] * b[i] % p * b[i] % p) % p;
    INTT(b,N);
    for(int i = n;i < N;i++) b[i] = 0;
    return;
}

void Sqrt(ll *a,ll *b,int n) {
    if(n == 1) return void(b[0] = Cipolla(a[0]));
    Sqrt(a,b,(n + 1) >> 1);
    memset(b1,0,sizeof(b1));
    Inv(b,b1,n);
    int N = 1, l = -1; while(N <= n << 1) N <<= 1, l++;
    for(int i = 1;i < N;i++) r[i] = (r[i >> 1] >> 1) | ((i & 1) << l);
    for(int i = 0;i < n;i++) a1[i] = a[i];
    for(int i = n;i < N;i++) a1[i] = 0;
    NTT(a1,N); NTT(b,N); NTT(b1,N);
    for(int i = 0;i < N;i++) b[i] = (b[i] + a1[i] * b1[i] % p) % p * inv2 % p;
    INTT(b,N);
    for(int i = n;i < N;i++) b[i] = 0;
    return;
}

int main() {
    n = read();
    for(int i = 0;i < n;i++) a[i] = read();
    Sqrt(a,b,n);
    for(int i = 0;i < n;i++) std::printf("%lld ",b[i]);
    return 0;
}

```

最后。随机数如果 `rand()` 相乘~~且脸黑~~会T一两个点，因为一些原因它的随机性很差。

---

## 作者：ikka (赞：3)

**Update**

两处公式挂了换成了图片。

---
## 前置知识

- 多项式开根
- Cipolla算法

### 多项式开根

模板在[P5205 【模板】多项式开根](https://www.luogu.org/problemnew/show/P5277) 。

这里不多做讨论。

### Cipolla算法

求解$x^2\equiv n \pmod p$的算法，由于`ntt`的模是奇素数所以这里只讨论$p$为奇素数的情况。

当方程有解时称$n$在模$p$意义下是二次剩余，否则称$n$在模$p$意义下是非二次剩余。

我们定义**勒让德符号**：

![勒让德符号](https://i.loli.net/2019/03/30/5c9f2e12389c9.png)

有一个**欧拉判别准则**：

$$
(\frac{n}{p})\equiv n^{\frac{p-1}{2}}\pmod p
$$

~~口胡~~证明：

1. 当$p|n$时，显然有$0\equiv n^{\frac{p-1}{2}}\pmod p$
2. 假设$x^2\equiv n \pmod p$，若$x^{p-1}\equiv 1\pmod p$时，根据费马小定理，假设成立，$n$在模$p$意义下是二次剩余。
若$x^{p-1}\equiv -1\pmod p$时，根据费马小定理，假设不成立，$n$在模$p$意义下是二次非剩余。

接下来让我们证明三个结论。

**结论一：$n^2 \equiv (p-n)^2 \pmod p$**

证明展开式子中的$(p-n)^2$即可。

**结论二：有$\frac{p-1}{2}$个数是模$p$意义下的二次非剩余。**

根据结论一，可以得出$0$到$p-1$的平方中有$\frac{p+1}{2}$个不同的数，剩下的数即为模$p$意义下的二次非剩余。

**结论三：$(a+b)^p\equiv a^p+b^p \pmod p$**

二项式定理展开，由于$p$是素数，所以除了首尾两项其他项中的组合数中都有质因子$p$，故同余式成立。

#### Cipolla算法流程

第一步，判断原方程是否有解（利用欧拉判别准则）。

第二步，随机找到一个$a$使得$\omega\equiv(a^2-n)\pmod p$在模$p$意义下是二次非剩余。(根据结论二，期望随机次数为$2$)

第三步，找到一个解$x\equiv(a+\sqrt{\omega})^{\frac{p+1}{2}} \pmod p$。但是$\sqrt{\omega}$显然不存在，我们可以把$\sqrt{\omega}$当做虚数$i$来看，就把问题解决了。

证明：

![Cipolla证明](https://i.loli.net/2019/03/30/5c9f2e1259b12.png)

## Code

``` cpp
#include <cstdio>
#include <cstring>
#include <ctime>
#include <cstdlib>
#include <algorithm>
const int maxn = 400010;
const int mod = 998244353;
const int g = 3;
const int invg = 332748118;
const int inv2 = 499122177;

int inline pls(int a, int b) { int m = a + b; return m < mod ? m : m - mod; }
int inline dec(int a, int b) { int m = a - b; return m + ((m >> 31) & mod); }
int inline mul(int a, int b) { return 1ll * a * b % mod; }
int inline pow(int a, int b) {
  int ans = 1;
  while (b) {
    if (b & 1) ans = mul(ans, a);
    a = mul(a, a);
    b >>= 1;
  }
  return ans;
}

struct cp {
  int r, i;
  cp(int x = 0, int y = 0) : r(x), i(y) {}
};

cp inline mul(cp a, cp b, int w) {
  return cp(pls(mul(a.r, b.r), mul(w, mul(a.i, b.i))), pls(mul(a.r, b.i), mul(a.i, b.r)));
}

int inline pow(cp a, int b, int w) {
  cp ans(1, 0);
  while (b) {
    if (b & 1) ans = mul(ans, a, w);
    a = mul(a, a, w);
    b >>= 1;
  }
  return ans.r;
}

int inline cipolla(int x) {
  srand(time(0));
  if (pow(x, (mod - 1) >> 1) == mod - 1) return -1;
  while (true) {
    int a = mul(rand(), rand());
    int w = dec(mul(a, a), x);
    if (pow(w, (mod - 1) >> 1) == mod - 1) {
      return pow(cp(a, 1), (mod + 1) >> 1, w);
    }
  }
}

int a[maxn], b[maxn], r[maxn];

void inline ntt(int *a, int n, int f) {
  for (int i = 0; i < n; ++i) if (i < r[i]) std::swap(a[i], a[r[i]]);
  for (int i = 1; i < n; i <<= 1) {
    int wn = pow(f ? g : invg, (mod - 1) / (i << 1));
    for (int *j = a; j < a + n; j += i << 1) {
      int w = 1;
      for (int k = 0; k < i; ++k, w = mul(w, wn)) {
        int x = *(j + k), y = mul(w, *(i + j + k));
        *(j + k) = pls(x, y), *(i + j + k) = dec(x, y);
      }
    }
  }
  if (!f) {
    int rv = pow(n, mod - 2);
    for (int *i = a; i < a + n; ++i) *i = mul(*i, rv);
  }
}

void inline inv(int *a, int *b, int n) {
  b[0] = pow(a[0], mod - 2);
  static int A[maxn], B[maxn], len, lim;
  for (len = 1; len < n << 1; len <<= 1) {
    lim = len << 1;
    memcpy(A, a, len << 2); memcpy(B, b, len << 2);
    for (int i = 1; i < lim; ++i) r[i] = (r[i >> 1] >> 1) | ((i & 1) ? len : 0);
    ntt(A, lim, 1); ntt(B, lim, 1);
    for (int i = 0; i < lim; ++i) b[i] = dec((B[i] << 1) % mod, mul(A[i], mul(B[i], B[i])));
    ntt(b, lim, 0);
    memset(b + len, 0, len << 2);
  }
  memset(A, 0, len << 2); memset(B, 0, len << 2);
  memset(b + n, 0, (len - n) << 2);
}

void inline sqrt(int *a, int *b, int n) {
  int sr = cipolla(a[0]);
  b[0] = std::min(sr, mod - sr);
  static int A[maxn], B[maxn], len, lim;
  for (len = 1; len < n << 1; len <<= 1) {
    lim = len << 1;
    memcpy(A, a, len << 2);
    inv(b, B, len);
    for (int i = 1; i < lim; ++i) r[i] = (r[i >> 1] >> 1) | ((i & 1) ? len : 0);
    ntt(A, lim, 1); ntt(B, lim, 1);
    for (int i = 0; i < lim; ++i) A[i] = mul(A[i], B[i]);
    ntt(A, lim, 0);
    for (int i = 0; i < len; ++i) b[i] = mul(inv2, pls(A[i], b[i]));
    memset(b + len, 0, len << 2);
  }
  memset(A, 0, len << 2); memset(B, 0, len << 2);
  memset(b + n, 0, (len - n) << 2);
}

int main() {
  int n;
  scanf("%d", &n);
  for (int *i = a; i < a + n; ++i) scanf("%d", i);
  sqrt(a, b, n);
  for (int *i = b; i < b + n; ++i) printf("%d%c", *i, " \n"[i == b + n - 1]);
  return 0;
}
```

~~抄我的代码会TLE233~~

---

## 作者：cyffff (赞：2)

[_传送门_](https://www.luogu.com.cn/problem/P5277)

板子题。
## 题意
给定 $n-1$ 次多项式 $F(x)$，求 $G^2(x)\equiv F(x)(\bmod x^n)$。
## 思路
我们发现 $\sqrt{k}=k^{\frac 1 2}$，于是可以暴力求 $G(x)\equiv F^{\frac 1 2}(x)\equiv F^{499122177}(x)(\bmod x^n)$.

注意到 $f_0\ne1$，于是不能直接 $\ln$，还得把每项系数除掉 $f_0$，再取 $g_0\equiv \sqrt{f_0}(\bmod 998244353)$，模意义开根见[二次剩余](https://www.luogu.com.cn/problem/P5491)。

最后如果 $f_0\ne 1$，则还需将所有数乘上 $\sqrt{f_0}$。

给出 Code:
```cpp
#define ll long long
const int mod=998244353,N=6e5+10;
inline void print(int *a){
	for(int i=0;a[i]||a[i+1]||a[i+2]||a[i+3]||a[i+4]||a[i+5];i++){
		printf("%d ",a[i]);
	}
	puts("");
}
namespace rad{
	mt19937_64 R(time(0));
	inline int Rand(ll l,ll r){
		uniform_int_distribution<ll> distribution(l,r);
	    return distribution(R);
	}
}using namespace rad;
namespace quad_residue{
	ll i_;
	struct complex{
		ll x,y;
		complex(ll X=0,ll Y=0){x=X,y=Y;}
		inline friend complex operator *(const complex &a,const complex &b){
			return complex((a.x*b.x%mod+a.y*b.y%mod*i_%mod)%mod,(a.x*b.y%mod+a.y*b.x%mod)%mod);
		}
	};
	inline ll qpow(ll a,ll b){
		a%=mod;
		ll res=1;
		while(b){
			if(b&1) res=res*a%mod;
			a=a*a%mod;
			b>>=1;
		}
		return res;
	}
	inline ll qpow(complex a,ll b){
		complex res(1,0);
		while(b){
			if(b&1) res=res*a;
			a=a*a;
			b>>=1;
		}
		return res.x%mod;
	}
	inline ll solve(ll n){
		n%=mod;
		if(qpow(n,mod-1>>1)==mod-1) return -1;
		ll ans;
		while(true){
			ans=Rand(0,mod-1);
			i_=(ans*ans%mod+mod-n)%mod;
			if(qpow(i_,mod-1>>1)==mod-1) break;
		}
		int x=qpow(complex(ans,1),mod+1>>1);
		return min(x,mod-x);
	}
}
#define QR quad_residue
struct ntt{
	int n,a[N],b[N],c[N],qqqq[N],s[N],ss[N],d[N],e[N],rev[N],f[N],g[N],inv[N],lim;
	char m[N];
	inline void init(int n,int mode=1){
		if(mode){
			int l=0;
			for(lim=1;lim<=n;lim<<=1)l++;
			for(int i=1;i<lim;i++){
				rev[i]=(rev[i>>1]>>1)|((i&1)<<(l-1));
			}
		}else{
			for(lim=1;lim<=n;lim<<=1);
		}
	}
	inline int qpow(int x,int y){
		int res=1;
		while(y){
			if(y&1) res=1ll*res*x%mod;
			x=1ll*x*x%mod;
			y>>=1;
		}
		return res;
	}
	inline void Prefix(int n){
		inv[1]=1;
		for(int i=2;i<=n;i++){
			inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
		}
	}
	inline void NTT(int *a,bool t){
		for(int i=0;i<lim;i++){
			if(i<rev[i]){
				swap(a[i],a[rev[i]]);
			}
		}
		for(int i=1;i<lim;i<<=1){
			int gl=qpow(3,(mod-1)/(i<<1));
			for(int j=0;j<lim;j+=(i<<1)){
				int t1,t2,now=1;
				for(int k=0;k<i;k++,now=1ll*now*gl%mod){
					t1=a[j+k];
					t2=1ll*now*a[i+j+k]%mod;
					a[j+k]=(t1+t2)%mod;
					a[i+j+k]=(t1-t2+mod)%mod;
				}
			}
		}
		if(!t) return ;
		int Inv=qpow(lim,mod-2);
		reverse(a+1,a+lim);
		for(int i=0;i<lim;i++){
			a[i]=1ll*a[i]*Inv%mod;
		}
	}
	inline void Inv(int dg,int *a,int *b){
		if(dg==1){
			b[0]=qpow(a[0],mod-2);
			return ;
		}
		Inv(dg+1>>1,a,b);
		init((dg<<1)-1);
		for(int i=0;i<dg;i++){
			c[i]=a[i];
		}
		for(int i=dg;i<lim;i++){
			c[i]=0;
		}
		NTT(c,0);
		NTT(b,0);
		for(int i=0;i<lim;i++){
			b[i]=1ll*(2-1ll*c[i]*b[i]%mod+mod)%mod*b[i]%mod;
		}
		NTT(b,1);
		for(int i=dg;i<lim;i++){
			b[i]=0;
		}
	}
	inline void Mul(int *a,int *b,int n){
		init(n);
		memset(c,0,lim<<2);
		memcpy(c,b,n<<2);
		NTT(a,0);
		NTT(c,0);
		for(int i=0;i<lim;i++){
			a[i]=1ll*a[i]*c[i]%mod;
		}
		NTT(a,1);
	}
	inline void Der(int *a,int *b,int n){
		for(int i=1;i<n;i++){
			b[i-1]=1ll*i*a[i]%mod;
		}
		b[n-1]=0;
	}
	inline void Invder(int *a,int *b,int n){
		for(int i=1;i<n;i++){
			b[i]=1ll*a[i-1]*inv[i]%mod;
		}
		b[0]=0;
	}
	inline void polyln(int *a,int *b,int n){
		for(int i=0;i<(n<<2);i++){
			qqqq[i]=d[i]=b[i]=0;
		}
		Der(a,qqqq,n);
		Inv(n,a,d);
		Mul(qqqq,d,n);
		Invder(qqqq,b,n);
	}
	inline void Log(int n,int *f,int *g){
		init(n);
		polyln(f,g,lim);
		for(int i=n;i<lim;i++){
			g[i]=0;
		}
	}
	inline void polyexp(int n,int *a,int *b){
		if(n==1){
			b[0]=1;
			return ;
		}
		Exp(n+1>>1,a,b);
		init(n<<1);
		Log(n,b,s);
		for(int i=0;i<n;i++){
			s[i]=a[i]>=s[i]?a[i]-s[i]:a[i]+mod-s[i];
		}
		for(int i=n;i<lim;i++){
			b[i]=s[i]=0;
		}
		s[0]++;
		NTT(s,0);
		NTT(b,0);
		for(int i=0;i<lim;i++){
			b[i]=1ll*b[i]*s[i]%mod;
		}
		NTT(b,1);
		for(int i=n;i<lim;i++){
			b[i]=0;
		}
	}
	inline void Exp(int n,int *a,int *b){
		polyexp(n,a,b);
	}
	inline void polypow(int n,int m,int *a,int *b){
		int k1=1;
		if(a[0]!=1){
			k1=qpow(a[0],mod-2);
			for(int i=1;i<n;i++){
				a[i]=1ll*k1*a[i]%mod;
			}
			k1=QR::solve(a[0]);
			a[0]=1;
		}
		Log(n,a,ss);
		for(int i=0;i<n;i++){
			a[i]=1ll*ss[i]*m%mod;
		}
		Exp(n,a,b);
		for(int i=0;i<n;i++){
			b[i]=1ll*b[i]*k1%mod;
		}
	}
	inline void Pow(int n,int m,int *f,int *g){
		init(n<<1|1);
		polypow(n,m,f,g);
	}
	inline void MAIN(){
		n=read();
		for(int i=0;i<n;i++){
			f[i]=read();
		}
		init(n,0);
		Prefix(n);
		Pow(n,499122177,f,g);
		for(int i=0;i<n;i++){
			write(g[i]);
			out[len++]=' ';
		}
	}
}w;
```


---

## 作者：feicheng (赞：0)

## $\texttt{Description}$

给 $\deg = n-1$ 的多项式 $f$，求多项式 $g$ 满足
$$
        g \equiv \sqrt f \pmod {x^n}
$$

## $\texttt{Solution}$

考虑牛顿迭代：有 $h(g(x)) = g(x)^2 - f(x) \equiv 0 \pmod {x^n}$

$$
    g(x) \equiv \dfrac {g_0(x) - g_0^2(x) - f(x)} {2g_0(x)} \pmod {x^n}
$$ 

$$
    g(x) \equiv \dfrac {g_0^2(x)+f(x)} {2g_0(x)} \pmod {x^n}
$$

其中 $g_0(x)$ 是在模 $x^{ \lceil \frac {n} 2 \rceil}$ 时的答案。

在 $n=1$ 时用 cipolla 算一下就可以了。

## $\texttt{Code}$

```cpp
inline auto Sqrt(vector<int> a) {
    if (a.size() == 1) return vector<int> (1,quad::cipolla(a[0])) ;
    const int len = a.size() ;
    auto ta = a;
    ta.resize((len + 1) >> 1) ;
    auto tb = Sqrt(ta);
    tb.resize(len) ;
    auto tc = tb * tb;
    tc.resize(len) ;
    for (auto &it : tb) it = 2ll * it % mod ;
    for (int i = 0; i < len; ++i) tc[i] = (tc[i] + a[i]) % mod ;
    return tc = tc * Inv(tb),tc.resize(len),tc ;
}
```

---


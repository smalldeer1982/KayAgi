# 拉格朗日插值2

## 题目描述

给定一个不超过 $n$ 次的多项式的 $n+1$ 个点值 $f(0),f(1) \dots f(n)$，和一个正整数 $m$，求 $f(m),f(m+1) \dots f(m+n)$。

答案对 $998244353$ 取模。

## 说明/提示

【数据范围】     
对于 $100\%$ 的数据：  
$1 \le n \le 160000$，$n < m \le 10^8$，$0 \le f(i) < 998244353$。

## 样例 #1

### 输入

```
5 6
1 1 4 5 1 4```

### 输出

```
54 232 673 1579 3232 6007```

# 题解

## 作者：forgottencosecant (赞：21)


由插值公式可得

$$f(m+x)=\sum_{i=0}^{n}f(i)\prod_{j \neq i}\frac{m+x-j}{i-j}=\sum_{i=0}^{n}f(i) \frac{(m+x)!/(m+x-n-1)!}{(m+x-i)(-1)^{n-i}i!(n-i)!}$$

令

$$u_i=\frac{f(i)}{(-1)^{n-i}i!(n-i)!}$$

当$i>n$时$u_i=0$

$$v_i=\frac{1}{m-n+i}$$

可得

$$(u * v)_{x}=\sum_{i=0}^{x}\frac{f(i)}{(-1)^{n-i}i!(n-i)!(m-n+x-i)}$$

$$(u * v)_{n+x}=\sum_{i=0}^{n}\frac{f(i)}{(-1)^{n-i}i!(n-i)!(m+x-i)}$$

即
$$f(m+x)=(u*v)_{n+x}\prod_{i=m+x-n}^{m+x}i$$

于是可用一次NTT求出$f(m),f(m+1),...,f(m+n)$。

总复杂度$O(n \log n)$。


---

## 作者：mrsrz (赞：11)

[可能更好的体验](https://mrsrz.github.io/2019/11/21/lg5667/)

本题可以将点值转化为下降幂系数，然后做一次下降幂多项式平移，再转化为点值。

关于如何将点值与下降幂系数互相转化，详见[下降幂多项式乘法](https://www.luogu.org/problem/P5394)的模板。

这里主要讨论下降幂多项式的平移。

这里的平移指的是，已知多项式 $f(x)$ 的各项系数并给定常数 $c$，求 $f(x+c)$ 的各项系数。

这里需要用到下降幂的二项式定理。

![](https://cdn.luogu.com.cn/upload/image_hosting/8hx6emx6.png)

~~《具体数学》习题5.37~~

考虑我们当前得到 ![](https://cdn.luogu.com.cn/upload/image_hosting/0pkrwm56.png)，对 $f(x+c)$ 进行分析。

![](https://cdn.luogu.com.cn/upload/image_hosting/qin74w0p.png)

观察这个式子 ![](https://cdn.luogu.com.cn/upload/image_hosting/96r5gpua.png)，这是可以用一次多项式乘法得到的。

令

![](https://cdn.luogu.com.cn/upload/image_hosting/a3gmsnai.png)

那么 $f(x+c)$ 的第 $k$ 项下降幂系数就是 $p$ 与 $q$ 的卷积的第 $n-k$ 项，还要乘上 $k!$ 的逆。

得到 $f(x+c)$ 的下降幂系数后，再转化成点值即可。

总共需要三次多项式乘法。

时间复杂度 $O(n\log n)$。

## Code：
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
const int N=524288,md=998244353,g3=(md+1)/3;
typedef long long LL;
int a[N],n,rev[N],lim,m,fac[N],iv[N],F[N];
inline void upd(int&a){a+=a>>31&md;}
inline int pow(int a,int b){
    int ret=1;
    for(;b;b>>=1,a=(LL)a*a%md)if(b&1)ret=(LL)ret*a%md;
    return ret;
}
void init(int n){
    int l=-1;
    for(lim=1;lim<n;lim<<=1)++l;
    for(int i=1;i<lim;++i)
        rev[i]=(rev[i>>1]>>1)|((i&1)<<l);
}
void FFT(int*a,int f){
    for(int i=1;i<lim;++i)
        if(i<rev[i])swap(a[i],a[rev[i]]);
    for(int i=1;i<lim;i<<=1){
        const int gi=pow(f?3:g3,(md-1)/(i<<1));
        for(int j=0;j<lim;j+=i<<1)
            for(int k=0,g=1;k<i;++k,g=(LL)g*gi%md){
                const int x=a[j+k],y=a[j+k+i]*(LL)g%md;
                upd(a[j+k]+=y-md),upd(a[j+k+i]=x-y);
            }
    }
    if(!f){
        const int vv=pow(lim,md-2);
        for(int i=0;i<lim;++i)a[i]=(LL)a[i]*vv%md;
    }
}
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n>>m;++n;
    for(int i=0;i<n;++i)cin>>a[i];
    for(int i=*fac=1;i<=n;++i)fac[i]=(LL)fac[i-1]*i%md;
    iv[n]=pow(fac[n],md-2);
    for(int i=n-1;~i;--i)iv[i]=(i+1LL)*iv[i+1]%md;
    for(int i=0;i<n;++i)
        a[i]=(LL)a[i]*iv[i]%md,F[i]=(i&1)?md-iv[i]:iv[i];
    init(n<<1);
    FFT(a,1),FFT(F,1);
    for(int i=0;i<lim;++i)a[i]=(LL)a[i]*F[i]%md;
    FFT(a,0);
    for(int i=n;i<lim;++i)a[i]=F[i]=0;
    F[0]=1;
    for(int i=1;i<n;++i){
        F[i]=(LL)F[i-1]*(m-i+1)%md;
        a[i]=(LL)a[i]*fac[i]%md;
    }
    reverse(a,a+n);
    for(int i=1;i<n;++i)
        F[i]=(LL)F[i]*iv[i]%md;
    FFT(a,1),FFT(F,1);
    for(int i=0;i<lim;++i)a[i]=(LL)a[i]*F[i]%md;
    FFT(a,0);
    for(int i=n;i<lim;++i)a[i]=F[i]=0;
    reverse(a,a+n);
    for(int i=0;i<n;++i)F[i]=iv[i],a[i]=(LL)a[i]*iv[i]%md;
    FFT(a,1),FFT(F,1);
    for(int i=0;i<lim;++i)a[i]=(LL)a[i]*F[i]%md;
    FFT(a,0);
    for(int i=0;i<n;++i)
        cout<<(LL)a[i]*fac[i]%md<<' ';
    cout<<'\n';
    return 0;
}
```

---

## 作者：rickyxrc (赞：4)

本文章遵守知识共享协议 CC-BY-NC-SA，同步发表于洛谷题解区，转载时须在文章的任一位置附上原文链接和作者署名（rickyxrc）。推荐在[我的个人博客](https://blog.rickyxrc.cc)阅读。

这是我的第一篇 NTT 题解，思路和其它题解几乎一样，不过推式子的过程和讲解更加详细，希望可以成为新人学习 NTT 的有力基础，当然会有讲的不周到的地方，欢迎各位补充与指正。

阅读本篇题解，您需要掌握拉格朗日插值的基本知识并 AC [拉格朗日插值](https://www.luogu.com.cn/problem/P4781)。

## 题面大意

给定一个不超过 $n$ 次的多项式的 $n+1$ 个点值 $f(0),f(1) \dots f(n)$，和一个正整数 $m$，求 $f(m),f(m+1) \dots f(m+n)$。

## 解题思路

首先我们写出拉格朗日插值的式子：

$$l_i(x) = y_i \prod_{j\neq i}^{}\frac{x-x_j}{x_i-x_j}$$

$$f(x) = \sum_{i=0}^{n} l_i(x)$$

这个式子我不会证明，不过简单地来想想，将 $x_i$ 带入该式子，就会将除了 $l_i(x)$ 之外的值全部消掉（等于 0），得到 $y_i$，所以可以认为它是对的（当然这显然不是严谨的证明）。

把所有的 $l_i(x)$ 带入 $f(x)$，我们就得到了拉格朗日插值的另一种表达形式：

$$f(x) = \sum_{i=0}^{n}y_i\prod_{j\neq i}\frac{x-x_j}{x_i-x_j}$$

我们现在需要求出的是 $f(m),f(m+1),...,f(m+n)$，我们做如下推导：

$$f(m+x) = \sum_{i=0}^{n}y_i\prod_{j\neq i}\frac{(m+x)-x_j}{x_i-x_j}$$

因为给入的 $x$ 是连续的且是 $[0,n]$，所以式子可以简化如下：

$$f(m+x) = \sum_{i=0}^{n}f(i)\prod_{j\neq i}\frac{(m+x)-j}{i-j}$$

这一段连乘可以变成阶乘的形式，但是我没一步推出来所以我们写详细一点。

我们先下放连乘符号，于是式子可以写成这样：

$$f(m+x) = \sum_{i=0}^{n}f(i)\frac{\prod_{j\neq i}(m+x-j)}{\prod_{j\neq i}(i-j)}$$

然后我们先看分子：

$$\prod_{j\neq i}(m+x-j)$$

$$= \frac{(m+x-1) \times (m+x-2) \times(m+x-3) \times \cdots \times (m+x-n)}{m+x-i}$$

明显可以简化成阶乘的式子：

$$= \frac{(m-x-1)!}{(m+x-i)\times(m+x-n-1)!}$$

然后看分母：

$$\prod_{j\neq i}(i-j)$$

这个式子可以化成：

$$\prod_{j < i}(i-j) \prod_{j=i+1}^{n}(i-j)$$

$$=i!\times\prod_{j=i+1}^{n}-(j-i)$$

$$=i!\times(-1)^{n-i}\times\prod_{j=i+1}^{n}(j-i)$$

$$=i!\times(-1)^{n-i}\times(n-i)!$$

所以整段分式就可以化成：

$$\frac{\frac{(m-x-1)!}{(m+x-i)\times(m+x-n-1)!}}{i!\times(-1)^{n-i}\times(n-i)!}$$

$$=\frac{(m-x-1)!}{(m+x-i)\times(m+x-n-1)!\times i!\times(-1)^{n-i}\times(n-i)!}$$

原式就变成了：

$$f(m+x) = \sum_{i=0}^{n}\frac{f(i)\times(m-x-1)!}{(m+x-i)\times(m+x-n-1)!\times i!\times(-1)^{n-i}\times(n-i)!}$$

提出公因式：

$$= \frac{(m-x-1)!}{(m+x-n-1)!} \sum_{i=0}^{n}\frac{f(i)}{(m+x-i)\times i!\times(-1)^{n-i}\times(n-i)!}$$

因为我们需要 NTT 求解，所以我们选择将其凑成卷积的形式：

$$= \frac{(m-x-1)!}{(m+x-n-1)!} \sum_{i=0}^{n}\frac{1}{(m+x-i)}\times\frac{f(i)}{(n-i)!\times i!\times(-1)^{n-i}}$$

然后答案就比较显然了，为两个数列卷积之后再略微处理的形式。

形式化地说，设 $A_i=\frac{f(i)}{(n-i)!\times i!\times(-1)^{n-i}}$，$B_i = \frac{1}{m-n+i}$，则令 $F = A * B$，$\frac{F_i\times(m-x-1)!}{(m+x-n-1)!}$ 即为答案。

然后需要求逆元和阶乘逆元，最好能线性求。

因为阶乘可能很大，所以我们不能预处理阶乘逆元，而是预处理上升幂，参考代码中 jinv 和 mjcsinv 的部分。

代码如下：

```cpp
#include <stdio.h>

#define maxn 1000007

typedef long long i64;

i64 g = 3, gi;
const i64 mod = 998244353;

i64 t[maxn], a[maxn], b[maxn], n, m, len = 1, l, r[maxn], jcs[maxn], jinv[maxn], mjcs[maxn], mjcsinv[maxn], minv[maxn], ninv[maxn];

inline i64 pow(i64 x, i64 p);
inline i64 inv(i64 x);
void ntt(i64 *c, i64 op);

void getinv(i64 n, i64 m)
{
    jcs[0] = mjcs[0] = 1;
    for (i64 i = 1; i <= 2 * n + 1; i++)
        jcs[i] = jcs[i - 1] * i % mod,
        mjcs[i] = mjcs[i - 1] * (m - n + i - 1) % mod;
    jinv[2 * n + 1] = inv(jcs[2 * n + 1]);
    mjcsinv[2 * n + 1] = inv(mjcs[2 * n + 1]);
    for (int i = 2 * n + 1; i; i--)
        jinv[i - 1] = jinv[i] * i % mod,
                 mjcsinv[i - 1] = mjcsinv[i] * (m - n + i - 1) % mod,
                 ninv[i] = jinv[i] * jcs[i - 1] % mod,
                 minv[i] = mjcsinv[i] * mjcs[i - 1] % mod;
    minv[0] = 1;

    //	for(int i=1;i<=2*n+1;i++)
    //		printf("[%lld %lld %lld %lld] ",
    //			i*ninv[i]%mod,(m-n+i-1)*minv[i]%mod,jcs[i]*jinv[i]%mod,mjcs[i]*mjcsinv[i]%mod);
}

int main()
{
    gi = inv(g);

    scanf("%lld%lld", &n, &m);

    for (i64 i = 0; i <= n; i++)
        scanf("%lld", t + i);

    getinv(n, m);

    for (i64 i = 0; i <= n; i++)
    {
        a[i] = t[i] * jinv[i] % mod * jinv[n - i] % mod;
        if ((n - i) & 1)
            a[i] = mod - a[i];
    }
    for (i64 i = 0; i <= 2 * n; i++)
        b[i] = minv[i + 1];

    while (len <= 2 * n)
        len <<= 1, l++;

    for (i64 i = 0; i < len; i++)
        r[i] = (r[i >> 1] >> 1) | ((i & 1) << (l - 1));

    ntt(a, 1);
    ntt(b, 1);
    for (i64 i = 0; i < len; i++)
        a[i] = a[i] * b[i] % mod;
    ntt(a, -1);

    i64 linv = pow(len, mod - 2);
    for (i64 i = n; i <= 2 * n; i++)
        printf("%lld ", mjcs[i + 1] * a[i] % mod * mjcsinv[i - n] % mod * linv % mod);
    return 0;
}
```

---

## 作者：lbmzxhb (赞：3)

[题目传送门](/problem/P5667)

# 思路：

先推一波式子：

$$\begin{aligned}
f(m)&=\sum_{i=0}^nf(i)\prod_{j=0,j\neq i}^n\frac{m-j}{i-j}\\
&=\sum_{i=0}^nf(i)\prod_{j=0,j\neq i}^n\frac{1}{i-j}\prod_{j=0,j\neq i}^n(m-j)\\
&=\sum_{i=0}^nf(i)(-1)^{n-i}\frac{1}{i!(n-i)!}\prod_{j=0,j\neq i}^n(m-j)
\end{aligned}$$

令 $k_i=f(i)(-1)^{n-i}\frac{1}{i!(n-i)!}$，则

$$f(m)=\sum_{i=0}^nk_i\prod_{j=0,j\neq i}^n\left(m-j\right)$$

容易发现 $\prod\limits_{j=0,j\neq i}^n\left(m-j\right)=\frac{\prod\limits_{j=0}^n\left(m-j\right)}{m-i}$，所以

$$\begin{aligned}
f(m)&=\sum_{i=0}^n\frac{k_i}{m-i}\prod_{j=0}^n\left(m-j\right)\\
&=\prod_{j=0}^n\left(m-j\right)\sum_{i=0}^n\frac{k_i}{m-i}
\end{aligned}$$

令 $g(m)=\sum\limits_{i=0}^n\frac{k_i}{m-i}$，则

$$f(m)=g(m)\prod_{j=0}^n(m-j)$$

因为 $\prod\limits_{j=0}^n(m-j)$ 可以在输出时再计算，因此考虑如何计算 $g(m)$。

令 $m_i=\frac{1}{m-n+i}$，则

$$\begin{aligned}
g(m)&=\sum_{i=0}^nk_i\cdot m_{n-i}\\
&=\sum_{i+j=n}k_i\cdot m_j
\end{aligned}$$

此时 $g(m)$ 就被化成了卷积的形式。

不过本题还要求 $f(m+t)(1\le t\le n)$ 的值，将其转化为 $g(m+t)$ 后，则

$$\begin{aligned}
g(m+t)&=\sum_{i=0}^nk_i\cdot m_{n-i+t}\\
&=\sum_{i+j=n+t}k_i\cdot m_j
\end{aligned}$$

此时也可用卷积求解。

时间复杂度 $\mathcal{O}(n\log n)$。

# 代码：

```cpp
#include <iostream>
#define int long long
#define rep(x, y, z) for (int x = (y); x <= (z); ++x)
using namespace std;
const int P(998244353), G(3), GI((P + 1) / G), N((1 << 20) + 5);
int mi[N], ki[N], fac[N], rev[N];
int n, m, f[N];
inline int upd(int x) {return (x%P+P)%P;}
inline int qpow(int x, int p) {
	int res(1); x %= P;
	while (p) {
		if (p & 1) res = res * x % P;
		x = x * x % P;
		p >>= 1;
	}
	return res;
}
void NTT(int *a, int len, bool inv) {
	rep (i, 0, len - 1) if (rev[i] < i) swap(a[i], a[rev[i]]);
	for (int h = 1; h < len; h <<= 1) {
		int gn(qpow(inv ? GI : G, (P - 1) / (h << 1)));
		for (int i = 0; i < len; i += h << 1) {
			int g0(1);
			for (int j = i; j < i + h; j++, g0 = upd(g0 * gn)) {
				int x(a[j]), y(upd(g0 * a[j + h]));
				a[j] = upd(x + y), a[j + h] = upd(x - y);
			}
		}
	}
	if (inv) {
		int mul(qpow(len, P - 2));
		rep (i, 0, len - 1) a[i] = upd(a[i] * mul);
	}
}
signed main() {
	cin.tie(0), cout.tie(0)->sync_with_stdio(0);
	cin >> n >> m;
	rep (i, 0, n) cin >> f[i];
	rep (i, 0, n << 1) mi[i] = qpow(m - n + i, P - 2);//预处理mi
	fac[0] = 1; rep (i, 1, n) fac[i] = upd(fac[i - 1] * i);
	rep (i, 0, n) {
	    ki[i] = qpow(fac[i] * fac[n - i], P - 2);
	    if ((n - i) & 1) ki[i] = upd(-ki[i]);
	    ki[i] = upd(ki[i] * f[i]);
	    //预处理ki
	}
	int len(1), t(-1);
	while (len < 3 * n/*这里怕炸掉，可能不用3n*/) len <<= 1, t++;
	rep (i, 0, len) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << t);
	NTT(ki, len, 0); NTT(mi, len, 0);
	rep (i, 0, len - 1) ki[i] = upd(ki[i] * mi[i]);//做卷积
	NTT(ki, len, 1); NTT(mi, len, 1);//mi转换回来为了重复利用
	for (int i = 0, t = 1; i <= 2 * n; i++) {
		t = upd(t * (m - n + i));
		if (i >= n) cout << upd(ki[i] * t) << ' ', t = upd(t * mi[i - n]); 
	}
}
```

~~点个赞再走罢QWQ~~

---

## 作者：Chy12321 (赞：3)

[cnblogs](https://www.cnblogs.com/chy12321/p/18014619)

由拉格朗日插值公式得：
$$
f(x) = \sum_{i = 0}^nf(i)\prod_{j \ne i}\dfrac{x - j}{i - j} = \sum_{i = 0}^n\dfrac{f(i)x^{\underline{n+1}}}{(-1)^{n-i}i!(n - i)!(x - i)}
$$
我们要把函数平移 $m$ 个单位长度，所以要写 $f(x + m)$ 的式子，即
$$
f(x + m) = \sum_{i = 0}^n\dfrac{f(i)(x+m)^{\underline{n+1}}}{(-1)^{n-i}i!(n - i)!(x + m - i)}
$$
记 $A(x) = \begin{cases}\frac{f(x)}{(-1)^{n-x}x!(n - x)!} & x \le n \\ 0 & x > n\end{cases}, B(x) = \dfrac1{x + m}, F = A * B$。

当 $x \le n$ 时，有：
$$
F(x) = \sum_{i=0}^xA(i)B(x - i) = \sum_{i = 0}^x\dfrac{f(i)}{(-1)^{n-i}i!(n-i)!(x+m-i)}
$$
你会发现这样少算了 $[x + 1, n]$ 里的信息，所以 $B(x)$ 需要平移一下，变为 $B(x) = \dfrac1{x + m - n}$。

对于 $x \le n$，有：
$$
F(x+n) = \sum_{i=0}^nA(i)B(x+n-i) = \sum_{i=0}^n\dfrac{f(i)}{(-1)^{n-i}i!(n-i)!(x+m-i)}
$$
所以有
$$
f(x + m) = (x+m)^{\underline{n+1}}F(x+n)
$$
时间复杂度 $\mathcal O(n \log n)$。

代码

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

constexpr int N = 1 << 19, MOD = 998244353;

int n, m, f[N], A[N], B[N], F[N];
int bits, len, rev[N], Wn[2][19];
ll invfct[N], down[N];

ll qp(ll base, int e) {
    ll res = 1;
    while (e) {
        if (e & 1) res = res * base % MOD;
        base = base * base % MOD;
        e >>= 1;
    }
    return res;
}

inline void init(int n) {
    bits = -1, len = 1; while (len < n) len <<= 1, bits++;
    for (int i = 0; i < len; i++) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << bits);
}

void NTT(int *A, bool I = 0) {
    for (int i = 0; i < len; i++) if (i < rev[i]) swap(A[i], A[rev[i]]);
    for (int i = 1; i < len; i <<= 1) {
        ll wn = Wn[I][__builtin_ctz(i)];
        for (int j = 0; j < len; j += (i << 1)) {
            ll w = 1;
            for (int k = j; k < j + i; k++) {
                int t = w * A[k + i] % MOD;
                A[k + i] = (A[k] - t + MOD) % MOD, A[k] = (A[k] + t) % MOD;
                w = w * wn % MOD;
            }
        }
    }
    if (I) {
        ll invlen = qp(len, MOD - 2);
        for (int i = 0; i < len; i++) A[i] = A[i] * invlen % MOD;
    }
}

int main() {
    ios_base::sync_with_stdio(0); cin.tie(nullptr), cout.tie(nullptr);
    cin >> n >> m;
    for (int i = 0; i <= n; i++) cin >> f[i];

    for (int i = 0; i < 19; i++) Wn[0][i] = qp(3, (MOD - 1) / (1 << (i + 1))), Wn[1][i] = qp(Wn[0][i], MOD - 2);
    invfct[0] = 1; for (int i = 1; i <= n; i++) invfct[i] = invfct[i - 1] * i % MOD;
    for (int i = 2; i <= n; i++) invfct[i] = qp(invfct[i], MOD - 2);
    down[0] = 1; for (int i = m; i >= m - n; i--) down[0] = down[0] * i % MOD;
    for (int i = 1; i <= n; i++) down[i] = down[i - 1] * qp(m - n + i - 1, MOD - 2) % MOD * (m + i) % MOD;

    for (int i = 0; i <= n; i++) {
        A[i] = f[i] * invfct[i] % MOD * invfct[n - i] % MOD;
        if ((n ^ i) & 1) A[i] = MOD - A[i];
    }
    for (int i = 0; i <= (n << 1); i++) B[i] = qp(i + m - n, MOD - 2);

    init((n << 1) + 1); NTT(A), NTT(B);
    for (int i = 0; i < len; i++) F[i] = (ll)A[i] * B[i] % MOD;
    NTT(F, 1);
    for (int i = 0; i <= n; i++) cout << down[i] * F[i + n] % MOD << ' ';
    return 0;
}
```

---

## 作者：Emertyst (赞：3)

# P5667 拉格朗日插值2 题解

## 题目描述

~~仅仅是复制了一遍题目~~

给定一个不超过 $n$ 次的多项式的 $n+1$ 个点值 $f(0),f(1) \dots f(n)$，和一个正整数 $m$，求 $f(m),f(m+1) \dots f(m+n)$。

答案对 $998244353$ 取模。

## 前置知识

### 拉格朗日插值法

[模板](https://www.luogu.com.cn/problem/P4781)

已知一个 $n - 1$ 次多项式函数上的 $n$ 个点 $(x_1,f(x_1)),(x_2,f(x_2)), \cdots ,(x_n,f(x_n))$，求当横坐标为 $x$ 的时候的函数值。

$$
f(x) = \sum_{i = 1}^n f(x_i) \prod_{i \ne j} \frac{x - x_j}{x_i - x_j}
$$

### 卷积

数列卷积：

$$
f(x) = g(x) * h(x) = \sum_{i = 0}^x g(i) h(x - i)
$$

可以发现，如果将 $g(x),h(x)$ 看作两个多项式，那么 $f(x)$ 就是 $g(x)h(x)$ 的 $x$ 次项，于是我们可以用 FFT 计算卷积。 

[FFT 模板](https://www.luogu.com.cn/problem/P3803)

## 思路

先推式子。我们需要求 $f(m + k),k \in [0, n]$，用拉格朗日插值法表示如下（这里为了方便表示，将拉格朗日插值的公式中求和的下标改为从 $0$ 到 $n$）。

$$
f(x_{m + k}) = \sum_{i=0}^n f(x_i) \prod_{i \ne j} \frac{x_{m + k} - x_j}{x_i - x_j}
$$

注意到题目中给的点的横坐标为 $x_i = i$，所以将公式化简。

$$
\begin{aligned}
f(x_{m + k}) &= \sum_{i=0}^n f(x_i) \prod_{i \ne j} \frac{x_{m + k} - x_j}{x_i - x_j} \\
f(m + k) &= \sum_{i=0}^n f(i) \prod_{j = 0, j \ne i}^n \frac{m + k - j}{i - j} \\
f(m + k) &= \sum_{i=0}^n f(i) \frac{\prod_{j = 0, j \ne i}^n m + k - j}{\prod_{j = 0, j \ne i}^n i - j} \\
f(m + k) &= \sum_{i=0}^n \frac{(-1)^{n-i} f(i) \prod_{j = 0}^n m + k - j}{(m + k - i) i! (n-i)!} \\
f(m + k) &= \left(\prod_{j = 0}^n m + k - j \right) \sum_{i=0}^n \frac{(-1)^{n-i} f(i)}{(m + k - i) i! (n-i)!} \\
f(m + k) &= \left(\prod_{j = 0}^n m + k - j \right) \sum_{i=0}^n \frac{(-1)^{n-i} f(i)}{i! (n-i)!} \times \frac{1}{(m + k - i)} \\
\end{aligned}
$$

如果忽略前面的连乘部分，后面的求和有点像卷积的形式，不同点是卷积求和的范围是 $0$ 到 $k$，而这里是 $0$ 到 $n$。如果我们想使用 FFT 计算卷积，就必须变换一下形式。令：

$$
\begin{aligned}
a_i &= 
\begin{cases}
\dfrac{(-1)^{n-i} f(i)}{i! (n-i)!}, &i \in [0, n] \\
0, &i \in (n, 2n]
\end{cases} \\
b_i &= \frac{1}{m - n + i}, i \in [0, 2n] \\
c_i &= a_i * b_i \\
\end{aligned}
$$

这样：

$$
f(m + k) = c_{n + k} \prod_{j = 0}^n m + k - j
$$

为什么呢？

在上面拉格朗日插值法中推导出的式子中，求和上界为 $n$，而 $c_i$ 的求和上界为 $i$，可能小于 $n$，所以想到使用 $c_{n+k}$ 算 $f(m + k)$。这时，$c_{n + k} = \displaystyle\sum_{i = 0}^{n + k} a_i b_{n + k - i}$，我们需要令 $b_{n + k - i} = \dfrac{1}{m + k - i}$。设 $b_j = \dfrac{1}{u + j}$，将 $j = n + k - i$ 代入，则 $u + n + k - i = m + k - i$，解得 $u = m - n, b_j = \dfrac{1}{m - n + j}$。

这时：

$$
\begin{aligned}
c_{n + k} &= \sum_{i = 0}^{n + k} a_i b_{n + k - i} \\
&= \sum_{i = 0}^n a_i b_{n + k - i} + \sum_{i = n + 1}^{n + k} a_i b_{n + k - i} \\
&= \sum_{i = 0}^n \frac{(-1)^{n-i} f(i)}{i! (n-i)! (m + k - i)} + \sum_{i = n + 1}^{n + k} a_i b_{n + k - i} \\
\end{aligned}
$$

可以发现，前半部分是我们需要的，因此我们需要令后半部分（即 $\displaystyle\sum_{i = n + 1}^{n + k} a_i b_{n + k - i}$）等于 $0$。因为当 $k$ 取 $[0, n]$ 时，$n + 1 \leq i \leq 2n$，也就是说在这个取值范围内的 $a_i$ 对答案的贡献总是为 $0$。而 $0 \leq n + k - i \leq k - 1$，在这个取值范围内的 $b_i$ 对答案的贡献不总是 $0$（比如 $b_0$ 对 $c_n$ 的贡献不为 $0$，而对 $c_{n + 1}$ 的贡献为 $0$）。因此，只能将 $n + 1 \leq i \leq 2n$ 的 $a_i$ 赋值为 $0$，才能算出正确的 $c_i$。（这里对区间左右端点的书写并不是很严谨，只是为了便于说明原因）

将推导出来的式子转化为卷积问题之后，我们只需要预处理出阶乘逆元即可利用 FFT/NTT 解决问题（求和前面的连乘可以在求 $f(m + k)$ 时处理），时间复杂度 $O(n \log n)$。

## 代码

```cpp
#include <iostream>
using namespace std;
const int MAXN = 160005, MAXN2 = (1 << 19) + 5, MOD = 998244353, G_0 = 3, G_N = 332748118;
int n, m, fac, logLen, prod = 1, len = 1, a[MAXN2], b[MAXN2], rev[MAXN2], f[MAXN], invFac[MAXN];
int inc(int x, int y) { return x + y >= MOD ? x + y - MOD : x + y; }
int dec(int x, int y) { return x < y ? (x - y) % MOD + MOD : (x - y) % MOD; }
int mul(int x, int y) { return 1ll * x * y % MOD; }
int mul(int x, int y, int z) { return 1ll * x * y % MOD * z % MOD; }
int power(int x, int y, int mod) {
    int ans = 1;
    for (; y; y >>= 1, x = mul(x, x))
        if (y & 1)
            ans = mul(ans, x);
    return ans;
}
int op(int x) { return MOD - x; }
int inv(int x) { return power(x, MOD - 2, MOD); }
void NTT(int num[], int length, bool reverse) {
    for (int i = 0; i < length; ++i)
        if (i < rev[i])
            swap(num[i], num[rev[i]]);
    for (int i = 1; i < length; i <<= 1) {
        int g0 = power(reverse ? G_N : G_0, (MOD - 1) / (i << 1), MOD);
        for (int j = 0; j < length; j += (i << 1))
            for (int k = j, g = 1; k < i + j; ++k, g = mul(g, g0)) {
                int temp1 = num[k], temp2 = mul(g, num[i + k]);
                num[k] = inc(temp1, temp2), num[i + k] = dec(temp1, temp2);
            }
    }
    if (reverse)
        for (int i = 0, _ = inv(length); i < length; ++i)
            num[i] = mul(num[i], _);
}
int main() {
    ios::sync_with_stdio(false), cin.tie(0);
    cin >> n >> m;
    for (int i = 0; i <= n; ++i)
        cin >> f[i];
    fac = 1;
    for (int i = 1; i <= n; ++i)
        fac = mul(fac, i);
    invFac[n] = inv(fac);
    for (int i = n; i; --i)
        invFac[i - 1] = mul(invFac[i], i);
    for (int i = 0; i <= n; ++i) {
        a[i] = mul(f[i], invFac[i], invFac[n - i]);
        if ((n - i) & 1)
            a[i] = op(a[i]);
    }
    for (int i = 0; i <= (n << 1); ++i)
        b[i] = inv(m - n + i);
    for (int i = n + 1 + (n + 1 << 1); len < i;)
        len <<= 1, ++logLen;
    for (int i = 1; i <= len; ++i)
        rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << logLen - 1);
    NTT(a, len, false), NTT(b, len, false);
    for (int i = 0; i < len; ++i)
        a[i] = mul(a[i], b[i]);
    NTT(a, len, true);
    for (int i = m - n; i <= m; ++i)
        prod = mul(prod, i);
    for (int i = 0; i <= n; ++i)
        cout << mul(prod, a[n + i]) << " ", prod = mul(prod, inv(m - n + i), m + i + 1);
}
```

---

## 作者：Gorenstein (赞：2)

根据插值公式有

$$
f(m+a)=\sum_{i=0}^nf(i)\prod_{j\neq i}\frac{m+a-j}{i-j}
$$

$$
=\sum_{i=0}^nf(i)\frac{(m+a)!\big((m+a-n-1)!(m+a-i)\big)^{-1}}{i!(n-i)!(-1)^{n-i}}
$$

$$
=\frac{(m+a)!}{(m+a-n-1)!}\sum_{k=0}^n\frac{f(k)}{k!(n-k)!(-1)^{n-k}}\frac{1}{m+a-k}
$$

无妨令 $\color{royalblue}{}^{[1]}$

$$
a_i=\frac{f(i)}{i!(n-i)!(-1)^{n-i}}\;\;(i\leqslant n),\quad b_i=\frac{1}{m-n+i}
$$

并令在 $i>n$ 时令 $a_i$ 为零，那么

$$
f(m+
a)=\left[z^{n+a}\right]\frac{(m+a)!A(z)B(z)}{(m+a-n-1)!}
$$

卷起来就完事了。

------------
$\small{\color{royalblue}{[1]}}:m$ 很大，不能直接设为 $b_i=\frac{1}{i}$，否则会一直 RE。

---

## 作者：Nuisdete (赞：1)

直接将要求的东西带到拉格朗日插值公式里面可得：

$$f(m + k) = \sum_{i = 0}^n f(i) \prod_{j \neq i} \frac{m + k - j}{i - j}$$

考虑把连乘化简一下，分母就是：

$$\frac{1}{g(i)} = (-1)^{n - i}\frac{1}{i!~ (n - i)!}$$

分子是：

$$\frac{p(k)}{m + k - i} = \frac{\prod_{j = 0}^n m + k - j}{m + k - i}$$

$g(i)$ 可以直接线性预处理，$p(k)$ 可以线性预处理出 $p(0)$ 后再线性递推出 $p(k)$。

设 $F(i) = f(i)g(i)$，因此现在只需要算这个东西：

$$p(k)\sum_{i = 0}^n F(i)\frac{1}{m + k - i}$$

这个东西和卷积的形式很像，但是直接卷肯定是不对的，需要再转化一下（$p(k)$ 最后乘到系数上就行了，后文都省略）：

$$\sum_{i = 0}^k F(i)\frac{1}{m + k - i} + \sum_{i = k}^n F(i) \frac{1}{m + k - i} - \frac{F(k)}{m}$$

第一项设 $G(i) = \frac{1}{m + i}$ 后直接卷就行了。

第二项考虑将式子翻转一下，设 $F'(i) = F(n - i)$，$G'(i) = \frac{1}{-m + i}$，然后就可以卷再乘个 $-1$ 就行了，具体可以自己简单推推。

代码里数组名瞎起的，和上面不对应：

```cpp
# include <cstdio>
# include <algorithm>

# define int long long

constexpr int MAXN = 3.8e5 + 5, MOD = 998244353;

int n, m;

int fpow(int x, int k) {
  int res = 1;
  for (; k; k >>= 1) {
    if (k & 1) res = res * x % MOD;
    x = x * x % MOD;
  }
  return res;
}

int rev[MAXN << 1], len, bit;

void init(int n) {
  len = 1, bit = 0;
  for (; len < n; len <<= 1, ++bit);
  for (int i = 1; i < len; ++i) rev[i] = rev[i >> 1] >> 1 | (i & 1) << bit - 1;
}

void NTT(int* a, int len, bool sgn) {
  for (int i = 0; i < len; ++i) if (i < rev[i]) std::swap(a[i], a[ rev[i] ]);
  int inv3 = fpow(3, MOD - 2);
  for (int n = 1; n < len; n <<= 1) {
    int g = fpow(sgn ? 3 : inv3, (MOD - 1) / (n << 1));
    for (int i = 0; i < len; i += n << 1) {
      int val = 1;
      for (int k = 0; k < n; ++k, val = val * g % MOD) {
        int x = a[i + k], y = val * a[i + k + n] % MOD;
        a[i + k] = x + y, a[i + k + n] = x - y;
        a[i + k] -= a[i + k] >= MOD ? MOD : 0, a[i + k + n] += a[i + k + n] < 0 ? MOD : 0;
      }
    }
  }
  int inv = fpow(len, MOD - 2);
  if (!sgn) for (int i = 0; i < len; ++i) a[i] = a[i] * inv % MOD;
}

void mul(int* a, int* b, int n, int m) {
  init(n + m - 1);
  NTT(a, len, 1), NTT(b, len, 1);
  for (int i = 0; i < len; ++i) a[i] = a[i] * b[i] % MOD;
  NTT(a, len, false); for (int i = n + m - 1; i < len; ++i) a[i] = 0;
}

int fac[MAXN << 1], ifac[MAXN << 1];

int p[MAXN << 1], q[MAXN << 1], f[MAXN << 1], g[MAXN << 1], qq[MAXN << 1], tmp[MAXN << 1];

signed main() {

  scanf("%lld %lld", &n, &m);
  for (int i = 0; i <= n; ++i) scanf("%lld", &f[i]);

  fac[0] = 1;
  for (int i = 1; i <= n; ++i) fac[i] = fac[i - 1] * i % MOD;
  ifac[n] = fpow(fac[n], MOD - 2);
  for (int i = n - 1; i >= 0; --i) ifac[i] = ifac[i + 1] * (i + 1) % MOD;

  for (int i = 0; i <= n; ++i) 
    f[i] = ((n - i & 1 ? -1 : 1) * f[i] * ifac[i] % MOD * ifac[n - i] % MOD + MOD) % MOD;
  
  for (int i = 0; i <= n; ++i) g[i] = f[n - i];
  for (int i = 0; i <= n; ++i) qq[i] = fpow(MOD + i - m, MOD - 2);

  p[0] = 1;
  for (int i = m - n; i <= m; ++i) p[0] = p[0] * i % MOD;
  for (int i = 1; i <= n; ++i) 
    p[i] = p[i - 1] * fpow(m + i - n - 1, MOD - 2) % MOD * (m + i) % MOD;

  for (int i = 0; i <= n; ++i) q[i] = fpow(m + i, MOD - 2);

  for (int i = 0; i <= n; ++i) tmp[i] = f[i] * fpow(m, MOD - 2) % MOD;
  mul(f, q, n + 1, n + 1), mul(g, qq, n + 1, n + 1);
  for (int i = 0; i <= n; ++i) printf("%lld%c", (f[i] - g[n - i] - tmp[i] + MOD + MOD) % MOD * p[i] % MOD, " \n" [i == n]);

  return 0;
}
```

---

## 作者：Unnamed114514 (赞：0)

[猜你想看：Lagrange 插值](https://www.luogu.com.cn/article/mwqpv9v6)

***

给你 $[0,n]$ 的点值以及一个 $m$，让你求 $[m,m+n]$ 的点值。

先代入式子：

$$f(m+k)=\sum\limits_{i=0}^n y_i\prod\limits_{j\ne i}\dfrac{m+k-j}{i-j}=\sum\limits_{i=0}^n y_i\dfrac{\frac{(m+k)!}{(m+k-n-1)!}}{(m+k-i)(-1)^{n-i}i!(n-i)!}$$

右上角那坨显然是可以递推的，不管它，我们把它记作 $\Delta(k)$。

注意到模数 $998244353$，考虑构造成多项式乘法然后 NTT。

定义 $A(i)=\dfrac{y_i}{(-1)^{n-i}i!(n-i)!}(A(i)=0\ \text{if}\ i>n),B(i)=\dfrac{1}{m+i}$。

有：

$$F(k)=\sum\limits_{i=0}^kA(i)B(k-i)=\sum\limits_{i=0}^{k}\dfrac{y_i}{i!(-1)^{n-i}(n-i)!(m+k-i)}$$

但是我们最初的目的是求和求到 $n$，$A(i)$ 显然是不能动的。

于是我们平移 $B$，令新的 $B'(i)=B(i-n)=\dfrac{1}{m+i-n}$ 即可。

注意到 $m>n$ 所以 $B$ 是有定义的。

即：

$$F(n+k)=\sum\limits_{i=0}^{n+k}A(i)B(n+k-i)=\sum\limits_{i=0}^n\dfrac{y_i}{(m+k-i)(-1)^{n-i}i!(n-i)!}$$

因为 $A(i)=0(i>n)$ 所以你和式是可以求和到 $n+k$ 的。

上式是一个明显的卷积形式，NTT 即可。

最后的答案：

$$f(m+k)=\Delta(k)F(n+k)$$

```cpp
#include<bits/stdc++.h>
#define int long long
#define endl '\n'
using namespace std;
const int mod=998244353,g=3,invg=332748118,N=(1<<19);
int n,m,f[N],delta[N],rev[N],a[N],b[N],c[N],up,B,fac[N],inv[N];
int qpow(int a,int b){
    int s=1;
    while(b){
        if(b&1) s=s*a%mod;
        a=a*a%mod,b>>=1;
    }
    return s;
}
void NTT(const int n,int *a,const int op){
	for(int i=0;i<n;++i) if(i<rev[i]) swap(a[i],a[rev[i]]);
	for(int mid=1;mid<n;mid<<=1){
		const int Wn=qpow(op==1?g:invg,(mod-1)/(mid<<1));
		for(int i=0;i<n;i+=(mid<<1)) for(int j=0,w=1;j<mid;++j,w=w*Wn%mod){
			int y=w*a[i+j+mid]%mod;
			a[i+j+mid]=(a[i+j]-y+mod)%mod;
			a[i+j]=(a[i+j]+y)%mod;
		}
	}
}
void init(int L){ 
    up=1,B=0;
    while(up<=L) up<<=1,++B;
    for(int i=0;i<(1<<B);++i) rev[i]=(rev[i>>1]>>1)|((i&1)<<(B-1)); 
} 
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    cin>>n>>m;
    for(int i=0;i<=n;++i) cin>>a[i];
    delta[0]=1;
    for(int i=m-n;i<=m;++i) delta[0]=delta[0]*i%mod;
    for(int i=1;i<=n;++i) delta[i]=delta[i-1]*qpow(m+i-n-1,mod-2)%mod*(m+i)%mod;
    init(n<<1|1);
    fac[0]=1;
    for(int i=1;i<=n;++i) fac[i]=fac[i-1]*i%mod;
    inv[n]=qpow(fac[n],mod-2);
    for(int i=n-1;~i;--i) inv[i]=inv[i+1]*(i+1)%mod;
    for(int i=0;i<=n;++i){
        a[i]=a[i]*inv[i]%mod*inv[n-i]%mod;
        if(n-i&1) a[i]=(mod-a[i])%mod;
    }
    for(int i=0;i<=(n<<1);++i) b[i]=qpow(m+i-n,mod-2);
	NTT(up,a,1),NTT(up,b,1);
	for(int i=0;i<up;++i) a[i]=a[i]*b[i]%mod;
	NTT(up,a,-1);
	const int INV=qpow(up,mod-2);
	for(int i=0;i<up;++i) a[i]=a[i]*INV%mod;
    for(int i=0;i<=n;++i) cout<<a[n+i]*delta[i]%mod<<' ';
    cout<<endl;
    return 0;
}
```

---

## 作者：Corzica (赞：0)

根据插值公式，易得出每一个值的求值公式：
$$ f(m+i)=\sum_{k=0}^{n} f_k\prod_{j\neq k} \dfrac{m+i-j}{k-j}$$

发现对于每一个 $k$ 来讲，$\prod_{j\neq k} \dfrac{1}{k-j}$ 是和 $i$ 无关的，所以令 $g_k=f_k\prod_{j\neq k} \dfrac{1}{k-j}$。

化简为：
$$ f(m+i)=\sum_{k=0}^{n} g(k)\prod_{j\neq k} (m+i-j)$$

对于每一个 $i$ 来讲，$\prod_{j\neq k} (m+i-j)$ 的值又差不太多，不妨令 $sum(m+i)=\prod_{j=0}^{n} (m+i-j)$。

化简为：
$$ f(m+i)=sum(m+i)\sum_{k=0}^{n} \dfrac {g(k)}{m+i-k}$$

式子化简到这，做法就已经很明朗了。$sum$ 明显可以在输出答案的时候再乘上去，而后面那一部分又是一个卷积的形式，所以我们只需要一次ntt就能算出来这个东西了。

代码：
```cpp
#include <bits/stdc++.h>
#define clr(f,n) memset(f,0,sizeof(int)*(n))
#define cpy(f,g,n) memcpy(f,g,sizeof(int)*(n))
using namespace std;
const int mod = 998244353, g = 3, MAXN = 282144;
inline int ksm(int p, int q = mod - 2) {
	int base = 1;
	while (q) {
		if (q & 1) base = 1ll * base * p % mod;
		q >>= 1;
		p = 1ll * p * p % mod;
	}
	return base;
}
const int gg = ksm(g, mod - 2);
int n, f[MAXN << 1], r[MAXN << 1], tr[MAXN << 1], jie[MAXN << 1], m, inv[MAXN << 1], jjie[MAXN << 1];
inline void ntt(int*f, bool flg, int n) {
	tr[0] = 0;
	for (int i = 1; i < n; i++) {
		tr[i] = (tr[i >> 1] >> 1) | ((i & 1) ? n >> 1 : 0);
		if (i < tr[i]) swap(f[i], f[tr[i]]);
	}
	static int w[MAXN << 1];
	w[0] = 1;
	for (int p = 2; p <= n; p <<= 1) {
		int len = (p >> 1);
		int tG = ksm(flg ? g : gg, (mod - 1) / p);
		for (int i = 1; i <= len; i++) {
			w[i] = 1ll * w[i - 1] * tG % mod;
		}
		for (int k = 0; k < n; k += p) {
			for (int j = k; j < k + len; j++) {
				int tt = 1ll * w[j - k] * f[len + j] % mod;
				f[j + len] = f[j] - tt;
				if (f[len + j] < 0)f[len + j] += mod;
				f[j] = f[j] + tt;
				if (f[j] > mod)f[j] -= mod;
			}
		}
	}
}
inline void px(int *f, int *g, int n) {
	for (int i = 0; i < n; i++) {
		f[i] = 1ll * f[i] * g[i] % mod;
	}
}
inline void mul(int*f, int *g, int n, int m) {
	int nn = 1;
	while (nn < (n + m - 1)) nn <<= 1;
	static int ff[MAXN << 1], gg[MAXN << 1];
	for (int i = 0; i < n; i++) {
		ff[i] = f[i];
	}
	for (int i = 0; i < m; i++) {
		gg[i] = g[i];
	}
	for (int i = n; i < nn; i++) {
		ff[i] = 0;
	}
	for (int i = m; i < nn; i++) {
		gg[i] = 0;
	}
	ntt(ff, 1, nn);
	ntt(gg, 1, nn);
	px(ff, gg, nn);
	ntt(ff, 0, nn);
	int op = ksm(nn, mod - 2);
	for (int i = 0; i < nn; i++) {
		f[i] = (1ll * ff[i] * op) % mod;
	}
}
inline int gets(int l, int r) {
	return 1ll * jjie[r + 1 + n - m] * ksm(jjie[l + n - m]) % mod;
}
signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> m;
	for (int i = 0; i <= n; i++) {
		cin >> f[i];
	}
	jie[0] = 1;
	for (int i = 1; i <= n; i++) {
		jie[i] = 1ll * jie[i - 1] * i % mod;
	}
	inv[n] = ksm(jie[n ]);
	for (int i = n - 1; i >= 0; i--) {
		inv[i] = 1ll * (i + 1) * inv[i + 1] % mod;
	}
	for (int i = 0; i <= n; i++) {
		f[i] = 1ll * f[i] * inv[i] % mod * inv[n  - i] % mod;
		if ((n - i) & 1) {
			f[i] = mod - f[i];
		}
	}
	for (int i = 0; i <= 2 * n; i++) {
		r[i] = ksm( m - n + i);
	}
	jjie[0] = 1;
	for (int i = -n; i <= n; i++) {
		jjie[i + n + 1] = 1ll * jjie[i + n] * (m + i) % mod;
	}
	mul(f, r, n + 1, 2 * n + 1);
	for (int i = 0; i <= n; i++) {
		cout << 1ll * f[i + n]*gets(m + i - n, m + i) % mod << ' ' ;
	}
}
```

---


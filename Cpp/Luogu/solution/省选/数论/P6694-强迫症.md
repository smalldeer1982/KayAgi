# 强迫症

## 题目背景

小 L 是一个严重的强迫症患者。

由于他严重的强迫症，所以他画图时总是要把点画在一个圆上。

## 题目描述

一天，他问了小 H 和小 W 这样一个问题：

如果在一个圆上有 $n$ 个不同的点，依次标号为 $1$ 到 $n$，有多少种方案能把它们连成一棵树？

小 H & 小 W：这不是sb题吗？

小 L：那如果**连边不能相交**呢？

小 H & 小 W：这不是sb题吗？

小 L：那如果把「树」换成「图」呢呢？

小 H & 小 W：这不是sb题吗？

小 L：那如果给每个点一个权值 $a_i$，连接 $(i,j)$ 的边权值为 $a_i\times a_j$，求**满足上面**的图的**期望所有边权值之和**呢？

小 H & 小 W：这不是sb题吗？

小 L 见自己辛苦做了许久都没写出的题目被 dalao 轻松秒杀后十分郁闷。为了安慰他，你需要帮他做出这个问题。

**注意**：
1. 两条边在端点处**不视作相交**。
1. **没有边的图（即只有 $n$ 个点，之间没有边相连）也合法**
1. 点**按顺时针从 $1$ 到 $n$** 编号。
1. 图中**不能有自环和重边**

## 说明/提示

对于样例一，全部 $64$ 张图如下：
![](https://cdn.luogu.com.cn/upload/image_hosting/zfa8hs0v.png)

其中左侧 $48$ 张图合法，右侧 $16$ 张图不合法，所有边的权值均为 $1$。

期望边权和为 $\dfrac{8}{3}$，模 $998244353$ 意义下结果为 $665496238$。

### 数据范围

**本题采用捆绑测试。**

- Subtask 1( $10\%$ )：$n\leq 6$。
- Subtask 2( $30\%$ )：$n\leq 3000$。
- Subtask 3( $60\%$ )：无特殊限制。

对于 $100\%$ 的数据，$2\leq n\leq 10^5,0\leq a_i\leq10^6$。

Subtask 1 和 Subtask 2 时限 $1s$，Subtask 3 时限 $2s$。

------------
如果你不知道如何对一个有理数取模，请自行百度「乘法逆元」

## 样例 #1

### 输入

```
4
1 1 1 1```

### 输出

```
665496238```

## 样例 #2

### 输入

```
13
1 1 4 5 1 4 1 9 1 9 8 1 0```

### 输出

```
748867567```

# 题解

## 作者：Scarlet_Hypoc (赞：10)

~~可能是一篇比较硬核的题解~~

容易想到的思路是分别考虑每一条边的贡献，设 $h_i$ 表示 $i$ 个点的图的方案数，则答案为：
$$
\frac 1 {h_n}\sum_{i=1}^n\sum_{j=i+1}^na_ia_j\frac {h_{j-i+1}h_{n-(j-i-1)}} 4
$$

$\sum$ 里面的式子表示：连 $i,j$ 这条边，权值为 $a_i\times a_j$，图被分开成两部分，这两部分随便连边的方案数分别为 $h_{j-i+1},h_{n-(j-i-1)}$，但是两个部分内都有一条边强制要连上，不难发现这条边对别的边没有影响，所以直接除以 $2$ 就能得到连了这条边的方案，两个部分都除以 $2$ 就是除以 $4$ 了。

令 $f_i=h_{i+1}h_{n-i+1}$，代入得：
$$
\begin{aligned}
&=\frac 1 {4h_n}\sum_{i=1}^n\sum_{j=i+1}^n a_ia_jf_{j-i}\\
&=\frac 1 {4h_n}\sum_{j=1}^na_j\sum_{i=1}^{j-1}a_if_{j-i}
\end{aligned}
$$

不难发现后面是个卷积的形式，这样就求出答案了。

剩下的唯一一个问题是：如何求出 $h$？

考虑与 $1$ 号节点连边的编号最小的节点是谁，设为 $i$，则 $i$ 以后的节点与 $1,i$ 又构成了一个子问题，并强制连 $1,i$ 这条边，跟上面一样，方案数为 $h_{n-i+1}/2$，剩下 $1$ ~ $i-1$ 也是个子问题，方案数为 $h_i$。

还需要考虑没有点和 $1$ 连边的方案，可以看做点 $1$ 不存在，剩下的点构成一个子问题，方案数为 $h_{n-1}$。

于是有：
$$
\begin{aligned}
h_n&=h_{n-1}+\frac 1 2\sum_{i=2}^n h_ih_{n-i+1}\\
&=2h_{n-1}+\sum_{i=2}^{n-1}h_i h_{n-i+1}
\end{aligned}
$$

边界为 $h_1=1$。

令 $g_n=h_{n+1}$，代入得：
$$
\begin{aligned}
g_{n-1}&=2g_n+\sum_{i=2}^{n-1}g_{i-1}g_{n-i}\\
g_n&=2g_{n-1}+\sum_{i=1}^{n-1}g_ig_{n-i}
\end{aligned}
$$

看起来如果后面的卷积能把 $g_0$ 算上就会很棒，稍微改改：
$$
\begin{aligned}
g_n+2g_n&=2g_{n-1}+2g_n+\sum_{i=1}^{n-1} g_ig_{n-i}\\
g_n+2g_n&=2g_{n-1}+\sum_{i=0}^ng_ig_{n-i}\\
g_n&=\dfrac 2 3 g_{n-1}+\frac 1 3\sum_{i=0}^ng_ig_{n-i}\\
\end{aligned}
$$

设 $G(x)$ 为 $g$ 的生成函数，将递推式写成封闭形式：
$$
G=\frac 2 3Gx+\frac 1 3G^2+\frac 2 3
$$

求解得到：
$$
G=\frac {3-2x\pm\sqrt{4x^2-12x+1}} 2
$$

由于 $G(0)$ 应该等于 $1$，所以这里取 $-$ 号，即：
$$
G=\frac {3-2x-\sqrt{4x^2-12x+1}} 2
$$

考虑如何展开 $\sqrt{4x^2-12x+1}$，令 $f=4x^2-12x+1$，$F=f^{\frac 1 2}$，可以得到：
$$
F'f=(\frac 1 2f^{-\frac 1 2}f')f=\frac 1 2 f^{\frac 1 2}f'=\frac 1 2Ff'
$$

设 $F=\sum_{i=0}a_ix^i$，$F'=\sum_{i=0}a_{i+1}(i+1)x^i$，根据 $f=4x^2-12x+1$，可以得到 $f'=8x-12$，展开 $F'f$ 和 $\frac 1 2 Ff'$：

$$
F'f=\sum_{i=0} (4a_{i-1}(i-1)-12a_ii+a_{i+1}(i+1))x^i
$$

$$
\frac 1 2 Ff'=\sum_{i=0}(4a_{i-1}-6a_i)x^i
$$

由于两个多项式相等，即每一项系数都相等，于是可以得到等式：
$$
4a_{i-1}(i-1)-12a_ii+a_{i+1}(i+1)=4a_{i-1}-6a_i
$$

$$
a_{i+1}=\frac {(12i-6)a_i-4(i-2)a_{i-1}} {i+1}
$$

边界为 $a_0=1,a_1=\dfrac {(12\times 0-6)a_0} {0+1}=-6$。

不开 $O2$，$45ms$，目前洛谷rk1，代码如下：
```cpp
#include <cstdio>
#include <cmath>
#include <algorithm>
using namespace std;
#define maxn 300010
#define mod 998244353
#define bin(x) (1<<(x))

int n,a[maxn];
int ksm(int x,int y){int re=1;for(;(y&1?re=1ll*re*x%mod:0),y;y>>=1,x=1ll*x*x%mod);return re;}
int inv[maxn],w[maxn];void prep(int lg){int N=bin(lg);
	inv[1]=1;for(int i=2;i<=N;i++)inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
	for(int i=1,wn;i<N;i<<=1){
		w[i]=1;wn=ksm(3,(mod-1)/(i<<1));
		for(int j=1;j<i;j++)w[i+j]=1ll*w[i+j-1]*wn%mod;
	}
}
int limit,r[maxn];
void InitR(int lg){for(int i=1;i<bin(lg);i++)r[i]=(r[i>>1]>>1)|((i&1)<<(lg-1));}
int add(int x){return x>=mod?x-mod:x;}
int dec(int x){return x<0?x+mod:x;}
void ntt(int *f,int lg,int type=0){
	limit=bin(lg);if(type)reverse(f+1,f+limit);
	for(int i=1;i<limit;i++)if(i<r[i])swap(f[i],f[r[i]]);
	for(int mid=1,t;mid<limit;mid<<=1)for(int j=0;j<limit;j+=(mid<<1))for(int i=0;i<mid;i++)
	{t=1ll*f[j+i+mid]*w[mid+i]%mod;f[j+i+mid]=dec(f[j+i]-t);f[j+i]=add(f[j+i]+t);}
	if(type)for(int i=0;i<limit;i++)f[i]=1ll*f[i]*inv[limit]%mod;
}
int g[maxn],f[maxn];

int main()
{
	scanf("%d",&n);
	int lg=ceil(log2((n+1)<<1));prep(lg);InitR(lg);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	g[0]=1;g[1]=mod-6;
	for(int i=1;i<n;i++)g[i+1]=1ll*dec( 1ll*(12ll*i%mod-6+mod)*g[i]%mod - 4ll*(i-2)%mod*g[i-1]%mod )*inv[i+1]%mod;
	for(int i=0;i<=n;i++)g[i]=(mod-g[i]);
	g[0]=(g[0]+3)%mod;g[1]=(g[1]-2+mod)%mod;
	for(int i=0;i<=n;i++)g[i]=1ll*g[i]*inv[2]%mod;
	
	for(int i=1;i<=n;i++)f[i]=1ll*g[i]*g[n-i]%mod;
	ntt(a,lg);ntt(f,lg);for(int i=0;i<bin(lg);i++)f[i]=1ll*f[i]*a[i]%mod;
	ntt(a,lg,1);ntt(f,lg,1);int ans=0;
	for(int i=1;i<=n;i++)ans=add(ans+1ll*a[i]*f[i]%mod);
	ans=1ll*ans*ksm(4ll*g[n-1]%mod,mod-2)%mod;
	printf("%d",ans);
}
```

---

## 作者：littleKtian (赞：7)

### 放在前面

[第二个问题的答案](http://oeis.org/A001764)。

其实我最开始是想出第二个问题的，然后发现有通项公式~~其实是自己不会~~就换成了第三个问题，后来感觉太裸了就换成了第四个~~虽然还是很裸~~。

------------

### Subtask 1

暴力把所有图都搜一遍。

------------

### Subtask 2

设 $g_n$ 表示 $n$ 个点时没有边相交的图的个数，$g_1=1,g_2=2$，$h_n$ 表示 $1$ 和 $n$ 之间的边已经连接时的没有边相交的图的个数。易得 $h_n=\dfrac{g_n}{2}$（对于所有 $1$ 和 $n$ 之间的边相连/不相连的满足的图，一定能找到另一张图，除 $1$ 和 $n$ 以外其他边的连接情况都相同）。

考虑对于每条边 $(i,j)$ 对答案的贡献。

有：

$\begin{aligned}ans&=\dfrac{\sum\limits_{i=1}^{n-1}\sum\limits_{j=i+1}^{n}a_ia_jh_{j-i+1}h_{n+i-j+1}}{g_n}\\&=\dfrac{\sum\limits_{i=1}^{n-1}\sum\limits_{j=i+1}^{n}a_ia_jg_{j-i+1}g_{n+i-j+1}}{4g_n}\end{aligned}$

考虑如何递推 $g$。

我们分情况讨论：

+ 第 $n+1$ 个点与其他点没有连边

显然此时方案数就是 $g_n$。

+ 第 $n+1$ 个点与其他点有连边

假设所有与 $n+1$ 号点有连边的点中编号最小的点为 $i$。

此时整个圆被分成了两部分，这两部分之间**没有连边**（否则就会和中间这条边相交）。

对于 $1$ 到 $i$ 这部分，因为点 $n+1$ 不能和其他任意一个点之间有连边（不然 $i$ 就不是与 $n+1$ 有连边中编号最小的点），所以方案数就是 $g_i$（$1$ 到 $i$ 有 $i$ 个点）。

对于 $i$ 到 $n+1$ 这部分，发现这部分连边没有其他特别的影响（$i$ 与 $n+1$ 之间的这条边一定不与其他边相交）。所以方案数就是 $h_{n-i+2}$（$i$ 到 $n+1$ 有 $n-i+2$ 个点）。

于是就能得到下面的式子：

$g_{n+1}=g_n+\dfrac{1}{2}\sum\limits_{i=1}^ng_ig_{n-i+2}$

化一下就能得到 $g_{n+1}=2g_n+\sum\limits_{i=2}^{n}g_ig_{n-i+2}$（把上面式子右边的 $g_{n+1}$ 移到左侧后两边乘 $2$ 即可）。

然后就可以 $O(n^2)$ 求出 $g$ 和 $ans$ 了。

------------

### Subtask 3

记 $f_n=g_{n+1}$。根据上面的式子可得：

$f_n=2f_{n-1}+\sum\limits_{i=1}^{n-1}f_if_{n-i},ans=\dfrac{\sum\limits_{i=1}^{n-1}\sum\limits_{j=i+1}^{n}a_ia_jf_{j-i}f_{n+i-j}}{4f_{n-1}}$

~~其实只是为了好看一些。~~

法一：  
将递推式变形，可以得到 $f_n=\dfrac{2}{3}f_{n-1}+\dfrac{1}{3}\sum\limits_{i=0}^{n}f_if_{n-i}$。

定义 $F(x)$ 为 $f$ 的生成函数，可以得到：

$\dfrac{1}{3}F^2(x)+\dfrac{2}{3}xF(x)+\dfrac{2}{3}=F(x)$

解得 $F(x)=\dfrac{3-2x\pm\sqrt{4x^2-12x+1}}{2}$。

然后再试几个数，发现 $F(x)=\dfrac{3-2x-\sqrt{4x^2-12x+1}}{2}$。

直接多项式套板子就能求出 $f$。

法二：  
容易推出 $f$ 的前几项：$1,2,8,48,352,2880...$。

直接在OEIS上搜到[这个数列](http://oeis.org/A054726)然后直接把柿子代进去就能求出 $f$（或者将法一的柿子变形得到更简单的递推式）。

（出题人出题前考虑到OEIS了，但~~太懒了~~就没管）

对答案式子变形，得：

$ans=\dfrac{\dfrac{\sum\limits_{t=1}^{n-1}f_tf_{n-t}\sum\limits_{i=1}^{n}a_ia_{\left[(i+t-1)\bmod n\right]+1}}{2}}{4f_{n-1}}$

（上式由之前的式子改变枚举顺序所得，先枚举 $t=j-i$，再枚举 $i$ 因为有重复所以还要再除 $2$）

考虑求 $\sum\limits_{i=1}^{n}a_ia_{\left[(i+t-1)\bmod n\right]+1}$。

~~因为这条式子不好看所以~~接下来把 $a$ 从原来的从 $1$ 到 $n$ 的顺序变成从 $0$ 到 $n-1$

得到 $\sum\limits_{i=0}^{n-1}a_ia_{(i+t)\bmod n}$。

发现这玩意和 $\sum\limits_{i=0}^{n-1}a_ia_{i+t}$ 几乎一样，直接用这条式子做卷积的方法就行了。

于是就能 $O(n\log n)$ 完成这题了。

---

## 作者：yizhiming (赞：0)

难绷，怎么没有和我一样的分治 NTT。

[Link](https://www.luogu.com.cn/problem/P6694)

## 题目大意

给定一个包含 $n$ 个点的圆，每个点有点权 $a_i$，点之间可以连边形成图，不能有自环重边，求所有满足边除了在端点外不相交的图的期望权值和。

其中一个图的权值为所有 $(u,v)\in E$，$a_u\times a_v$ 的和。

对 $998244353$ 取模。

$2\leq n \leq 10^5$，$0\leq a_i \leq 10^6$。

## 题目分析

首先期望可以变成计数除以总方案数，假设大小为 $i$ 的时候方案数为 $f_i$，考虑知道了方案数能否能直接得到权值和，我们枚举点对来计算贡献。

式子即为 $\frac{1}{4f_n}\sum\limits_{i=1}^n \sum\limits_{j=i+1}^n a_i a_j f_{j-i+1}f_{n-(j-i)+1}$。

其中 $\frac{f_{j-i+1}f_{n-(j-i)+1}}{4}$ 其实就是点对的贡献，因为我们连了一条边之后由于不交，所以会把原问题划分成两部分，然后这两部分的是独立的，且可以视作大小为 $x$ 的圆，即便其只是圆上一部分。

然后由于我们钦定了这条边要选，所以要 $\times \frac{1}{2}$，原因是这条边在对应环上是相邻两点之间的边，选不选不影响其他点，所以强制选的方案数恰好就是一半。

注意这里是包含了两个端点的，我写的时候没有注意到，因为你端点即便强定连了一条边之后还是可以继续连的。

令 $g_i = f_{i+1}f_{n-i+1}$，那么上述就可以改写一下，顺带改变一下求和顺序的得到。

$\sum\limits_{j=1}^na_j \sum\limits_{i=1}^{j-1}a_ig_{j-i}$，常数被我省掉了，这个东西显然是可以对后面项卷积算的。

所以我们现在要做的只剩下算 $f$，考虑利用之前的性质，枚举当前 $1$ 号点的连边，情况，那么有。

$f_n = f_{n-1}+\frac{1}{2}\sum\limits_{i=2}^nf_if_{n-i+1}$，表示 $i$ 号点无连边，或者枚举连到了哪里，然后由于一边包含了分割点，另一边没包含所以系数是 $\frac{1}{2}$，把包含 $f_n$ 的拿出来移项得到 $f_n = 2f_{n-1}+\sum\limits_{i=2}^{n-1}f_if_{n-i+1}$。

别的题解到这里还在往下推，但是你看后面那一项很明显就是一个自卷积的形式，所以我们考虑分治 NTT。

具体的，我们先令 $g_i = f_{i+1}$，让后面的式子变的更阳间一点 $g_n = 2g_{n-1}+\sum\limits_{i=1}^n g_ig_{n-i}$，然后分治算，假设当前分治区间为 $[l,r]$，中心为 $mid$，先算 $[l,mid]$，然后用新增的 $g_{[l,mid]}$ 去更新 $g_{[mid+1,r]}$，然后注意不能算重，不能拿两边都是新增的情况去更新。

## Code


```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <queue>
#include <vector>
#define int long long
using namespace std;
int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
const int N = 4e5+5;
const int Mod = 998244353;
int G=3,invG = (Mod+1)/G;
int R[N];
int ksm(int x,int y){
	int res = 1;
	while(y){
		if(y&1){
			res = res*x%Mod;
		}
		y>>=1;
		x = x*x%Mod;
	}
	return res;
}
void NTT(int *a,int n,int op){
	for(int i=0;i<n;i++){
		if(R[i]<i){
			swap(a[R[i]],a[i]);
		}
	}
	for(int i=1;i<n;i<<=1){
		int x,y,w,wn,m;
		m = (i<<1);
		wn = ksm(op==1?G:invG,(Mod-1)/m);
		for(int j=0;j<n;j+=m){
			w = 1;
			for(int k=0;k<i;k++){
				x = a[j+k];y = a[j+k+i]*w%Mod;
				a[j+k] = (x+y)%Mod;a[j+k+i] = (x-y+Mod)%Mod;
				w = w*wn%Mod;
			}
		}
	}
	if(op==-1){
		int x = ksm(n,Mod-2);
		for(int i=0;i<n;i++){
			a[i] = a[i]*x%Mod;
		}
	}
}
void add(int &x,int y){
	x+=y;
	x-=(x>=Mod)*Mod;
}
int f[N];
int A[N],B[N],mx;
void init(int len){
	mx = 1;int l = 0;
	while(mx<len){
		mx<<=1;l++;
	}
	for(int i=0;i<mx;i++){
		R[i] = (R[i>>1]>>1)|((i&1)<<(l-1));
	}
}
void mul(int *a,int *b){
	NTT(a,mx,1);NTT(b,mx,1);
	for(int i=0;i<mx;i++){
		a[i] = a[i]*b[i]%Mod;
	}
	NTT(a,mx,-1);
}
void sol(int l,int r){
	if(l==r){
		add(f[l],f[l-1]);
		add(f[r],f[r-1]);
		return;
	}
	int mid = (l+r)/2;
	sol(l,mid);
	init(2*(r-l+1));
	memset(A,0,8*mx);memset(B,0,8*mx);
	for(int i=0;i<mid-l+1;i++){
		A[i] = f[i+l];
	}
	for(int i=1;i<(r-l+1);i++){
		B[i] = f[i];
	}
	mul(A,B);
	for(int i=mid+1;i<=r;i++){
		add(f[i],A[i-l]);
	}
	memset(A,0,8*mx);memset(B,0,8*mx);
	for(int i=0;i<mid-l+1;i++){
		A[i] = f[i+l];
	}
	for(int i=1;i<min(r-l+1,l);i++){
		B[i] = f[i];
	}
	mul(A,B);
	for(int i=mid+1;i<=r;i++){
		add(f[i],A[i-l]);
	}
	sol(mid+1,r);
}
int n,a[N],g[N];
signed main(){
	n = read();
	for(int i=1;i<=n;i++){
		a[i] = read();
	}
	f[0] = 1;
	sol(1,n-1);
	for(int i=n;i>=1;i--){
		f[i] = f[i-1];
	}
	for(int i=1;i<n;i++){
		g[i] = f[i+1]*f[n-i+1]%Mod;
	}
	memcpy(A,a,sizeof(A));
	init(2*n);
	mul(g,A);
	int res = 0;
	for(int i=1;i<=n;i++){
		add(res,a[i]*g[i]%Mod);
	}
	res = res*ksm(4*f[n]%Mod,Mod-2)%Mod;
	cout<<res<<"\n";
	return 0;
}
```

---


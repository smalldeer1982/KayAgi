# [THUPC 2017] 小 L 的计算题

## 题目描述

现有一个长度为 $n$ 的非负整数数组 $\{a_i\}$ 。小 L 定义了一种神奇变换：
$$f_k=\left(\sum_{i=1}^na_i^k\right)\bmod 998244353$$
小 L 计划用变换生成的序列 $f$ 做一些有趣的事情，但是他并不擅长算乘法，所以来找你帮忙，希望你能帮他尽快计算出 $f_{1\dots n}$。

## 说明/提示

对于 $100\%$ 的数据，$0\le a_i\le10^9$，$1\le n\le 2\times 10^5$，$\sum n\le 4\times 10^5$。

#### 版权信息
来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2017。

## 样例 #1

### 输入

```
2
3
2 3 3
5
1 2 3 4 5```

### 输出

```
32
4675```

# 题解

## 作者：jijidawang (赞：9)

这就是传说中的数列多幂次求和吗 .

咋题解全是先通分的 .

首先写出答案的 OGF：
$$F(z)=\sum_{k\ge 0}\sum_{i=1}^na_i^kz^k=\sum_{i=1}^n\dfrac1{1-a_iz}$$
然后考虑分治 NTT，每次从中点分治，动态维护答案的分子和分母，合并时暴力通分计算 .

对于 $\dfrac ab+\dfrac cd=\dfrac{ad+bc}{bd}$，可以发现分子分母的次数均被控制在可控范围内，于是可以根据类似一堆一次多项式乘法的分析得到复杂度为 $\Theta(n\log^2n)$ .

---

## 作者：peterwuyihong (赞：8)

题意：给定数组 $a$，对于 $1\le k\le n$，计算 $\sum_{i=1}^na_i^k$。

构造母函数 $F(x)$ 使得

$$F(x)=\sum_{k\ge1}x^k\sum_{i=1}^na_i^k$$

推柿子

$$F(x)=\sum_{k\ge1}\sum_{i=1}^n(xa_i)^k$$

$$=\sum_{i=1}^n\sum_{k\ge1}(xa_i)^k$$

$$=\sum_{i=1}^n\frac{xa_i}{1-xa_i}$$

$$=\frac{\sum_{i=1}^na_i\prod_{j\neq i}(1-xa_j)}{\prod_{i=1}^n(1-xa_i)}x$$

然后你思考下面的东西和上面的东西有什么牛逼的关系。

然后你发现：

$$(\prod_{i=1}^n(1-xa_i))^{'}=-\sum_{i=1}^na_i\prod_{j\neq i}(1-xa_j)$$

然后你直接~~yk链~~分治做掉分母，求一个导就是分子了，复杂度 $O(n\log^2n)$

现在是 $18:30$，我看我什么时候写完。

现在是 $18:34$，我写完了。

```cpp
int T;
int n,a[maxn];
poly solve(int l,int r){
	if(l==r)return (poly){1,p-a[l]};
	int mid=(l+r)>>1;
	return solve(l,mid)*solve(mid+1,r);
}
signed main(){
#ifndef ONLINE_JUDGE
	freopen("testdata.in","r",stdin);
#endif
	for(cin>>T;T;T--){
		cin>>n;
		for(int i=1;i<=n;i++)cin>>a[i];
		poly g=solve(1,n);
		poly f=Qd(g);
		f=-f*Inv(g);
		f.resize(n+1);
		int ans=0;
		for(int i=0;i<n;i++)ans^=f[i];cout<<ans<<endl;
	}
#ifndef ONLINE_JUDGE
	cerr<<endl<<(double)clock()/CLOCKS_PER_SEC;
#endif
}
```
上面是我的多项式板子，[安利一波](https://www.luogu.com.cn/blog/Peterprpr/mu-ban)。

---

## 作者：serverkiller (赞：4)

## 题意:

给定 $a_1$, $a_2$, $\cdots$, $a_n$ 对于 $k\in[1,n]\bigcap\mathbb N$ 求 $\sum_{i=1}^n a_i^k$

## solution:

首先设: $f_k=\sum_{i=1}^n a_i^k$

这个形式的式子看着就很像『牛顿恒等式』就是下面这个:

### Lemma

对于一个多项式 $f(x)=\sum_{i=0}^na_ix^i$ 它的根分别是 $x_1$, $x_2$, $\cdots$, $x_n$ 记 $f_k=\sum_{i=1}^n x_i^k$ 那么 $\forall k\in [1,n]$ 我们有:
$$
\sum_{i=1}^kf_ia_i+ka_{n-k}=0
$$
让我们来尝试证明一下这个

我们设 $\sigma_k(x_1,x_2,\cdots,x_n)$ 为 $k$ - 初等对称多项式

我们有:
$$
\begin{aligned}
\sigma_1&=f_1\\
2\sigma_2&=\sigma_1f_1-f_2\\
3\sigma_3&=\sigma_2 f_1-\sigma_1 f_2+f_3\\
&\dots\\
n\sigma_n&=\sum_{i=1}^{n} (-1)^{i} \sigma_{i} f_{n-i} + (-1)^{n-1} f_n
\end{aligned}
$$
反向表示:
$$
f_k=(-1)^{k-1} k \sigma_{k}+\sum_{i=1}^{k-1} (-1)^{k-i-1}\sigma_{k-i} f_i
$$
注意到韦达定理和 $\sigma$ 不可分割的关系 把韦达定理带入即可得到原式

### 返回原题

我们先把原来的方程还原出来: $\prod_{i=1}^{n}(x-a_i)$ 设 $x^i$ 的系数为 $a'_i$

考虑将它的系数翻转 得到:
$$
\mathcal G(x)=\sum_{i=0}^{n} a'_{n-i}x^i
$$
再设出来生成函数:
$$
\mathcal F(x)=\sum_{i} f_ix^i\\
\mathcal H(x)=\sum_{i=0}^nia'_{n-i}x^i
$$
根据 **Lemma** 有:
$$
\mathcal F(x)\mathcal G(x) + \mathcal H(x)=0\\
\mathcal F(x)=\frac{-\mathcal H(x)}{\mathcal G(x)}
$$
复杂度 $\mathcal O(n\log^2 n)$ 瓶颈在分治 fft 求原来的方程上 给出我的实现:

```cpp
read(n);
std::vector<int> a(n + 1);
for (int i = 1; i <= n; i++) read(a[i]);
function<poly(int,int)> divide = [&](int l,int r)
{
	if (l == r) return (poly) {mod - a[l],1};
	int mid = (l + r) >> 1;
	return divide(l,mid) * divide(mid + 1,r);
};
poly f = divide(1,n);
reverse(f.begin(),f.end());
poly g = f;
for (int i = 0; i < g.size(); i++) g[i] = (mod - g[i] * i % mod) % mod;
f = getinv(f) * g;
int ans = 0;
for (int i = 1; i <= n; i++) ans ^= f[i];
writeln(ans);
```



---

## 作者：Karry5307 (赞：4)

### 题意

$T$ 组数据，每组数据给定长度为 $n$ 的序列 $a$，对于 $1\leq k\leq n$ 求：

$$\sum\limits_{i=1}^{n}a_i^k$$

$\texttt{Data Range:}T\leq 10,\sum n\leq 4\times 10^5$。

### 题解

板题，蒯了以前写的一些东西就 AC 了。

感觉这种东西我自己理解就很简单写出来就写不清楚啊……

考虑将答案的 GF 写出来：

$$\sum\limits_{i=1}^{n}\frac{a_i}{1-a_ix}$$

直接通分：

$$\frac{\sum\limits_{i=1}^{n}a_i\prod\limits_{j\neq i}(1-a_jx)}{\prod\limits_{i=1}^{n}(1-a_ix)}$$

注意到对分母求导得到的是负的分子，所以分治 NTT 算出分母之后直接求答案然后取负即可。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef int ll;
typedef long long int li;
typedef unsigned long long int ull;
const ll MAXN=1048581,MOD=998244353;
ll test,n,res;
ll omgs[MAXN],x[MAXN],f[MAXN],g[MAXN];
vector<ll>tmpf[MAXN<<1];
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
        neg=-1;
        ch=getchar();
    }
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
}
inline ll qpow(ll base,ll exponent)
{
    ll res=1;
    while(exponent)
    {
        if(exponent&1)
        {
            res=(li)res*base%MOD;
        }
        base=(li)base*base%MOD,exponent>>=1;
    }
    return res;
}
inline void setupOmg(ll cnt)
{
    ll limit=__lg(cnt)-1;
    omgs[0]=1,omgs[1<<limit]=qpow(31,1<<(21-limit));
    for(register int i=limit;i;i--)
    {
        omgs[1<<(i-1)]=(li)omgs[1<<i]*omgs[1<<i]%MOD;
    }
    for(register int i=1;i<cnt;i++)
    {
        omgs[i]=(li)omgs[i&(i-1)]*omgs[i&-i]%MOD;
    }
}
inline ll& reduce(ll &x)
{
	return x+=x>>31&MOD;
}
inline void DIF(ll *cp,ll cnt)
{
	ll lim=__lg(cnt),len=cnt>>1,x;
	for(register int i=0;i<lim;i++,len>>=1)
	{
		for(register int *j=cp,*omg=omgs;j!=cp+cnt;j+=len<<1,omg++)
		{
			for(register int *k=j;k!=j+len;k++)
			{
				x=(li)*omg*k[len]%MOD,reduce(k[len]=*k-x),reduce(*k+=x-MOD);
			}
		}
	}
}
inline void DIT(ll *cp,ll cnt)
{
	ll lim=__lg(cnt),len=1,x,invl;
	for(register int i=0;i<lim;i++,len<<=1)
	{
		for(register int *j=cp,*omg=omgs;j!=cp+cnt;j+=len<<1,omg++)
		{
			for(register int *k=j;k!=j+len;k++)
			{
				reduce(x=*k+k[len]-MOD);
				k[len]=(li)(*k-k[len]+MOD)**omg%MOD,*k=x;
			}
		}
	}
	reverse(cp+1,cp+cnt),invl=MOD-(MOD-1)/cnt;
	for(register int i=0;i<cnt;i++)
	{
		cp[i]=(li)cp[i]*invl%MOD;
	}
}
inline void NTT(ll *cp,ll cnt,ll inv)
{
    inv==1?DIF(cp,cnt):DIT(cp,cnt);
}
inline void conv(ll fd,ll *f,ll *g,ll *res)
{
    static ll tmpf[MAXN],tmpg[MAXN];
    ll cnt=1,limit=-1;
    while(cnt<(fd<<1))
    {
        cnt<<=1,limit++;
    }
    for(register int i=0;i<cnt;i++)
    {
		tmpf[i]=i<fd?f[i]:0,tmpg[i]=i<fd?g[i]:0;
    }
    NTT(tmpf,cnt,1),NTT(tmpg,cnt,1);
    for(register int i=0;i<cnt;i++)
    {
		tmpf[i]=(li)tmpf[i]*tmpg[i]%MOD;
    }
    NTT(tmpf,cnt,-1),memcpy(res,tmpf,fd<<3);
}
inline void inv(ll fd,ll *f,ll *res)
{
	static ll tmp[MAXN],tmpr[MAXN];
	ll cnt=2,limit=0;
	tmpr[0]=res[0]=qpow(f[0],MOD-2);
	while(cnt<(fd<<1))
	{
		for(register int i=0;i<cnt;i++)
		{
			tmp[i]=f[i],tmpr[i]=i<(cnt>>1)?res[i]:0;
		}
		NTT(tmp,cnt,1),NTT(tmpr,cnt,1);
		for(register int i=0;i<cnt;i++)
		{
			tmp[i]=(li)tmp[i]*tmpr[i]%MOD;
		}
		NTT(tmp,cnt,-1),memset(tmp,0,cnt<<1),NTT(tmp,cnt,1);
		for(register int i=0;i<cnt;i++)
		{
			tmp[i]=(li)tmp[i]*tmpr[i]%MOD;
		}
		NTT(tmp,cnt,-1);
		for(register int i=(cnt>>1);i<cnt;i++)
		{
			res[i]=!tmp[i]?0:MOD-tmp[i];
		}
		cnt<<=1,limit++;
	}
	for(register int i=fd;i<cnt;i++)
	{
		res[i]=0;
	}
}
inline void deriv(ll fd,ll *f,ll *res)
{
    for(register int i=1;i<fd;i++)
    {
        res[i-1]=(li)f[i]*i%MOD;
    }
    res[fd-1]=0;
}
inline void lnDeriv(ll fd,ll *f,ll *res)
{
	static ll tmp[MAXN],tmp2[MAXN],tmp3[MAXN],tmp4[MAXN];
	ll cnt=1,r,invr;
	if(fd<=1)
	{
		return (void)(res[0]=(li)f[0]*qpow(f[0],MOD-2));
	}
	while(cnt<=fd)
	{
		cnt<<=1;
	}
	inv(cnt>>1,f,tmp4),deriv(fd,f,tmp),memcpy(tmp3,tmp,cnt<<1);
	for(register int i=0;i<cnt;i++)
	{
		tmp2[i]=i<(cnt>>1)?tmp4[i]:0,tmp3[i]=i<(cnt>>1)?tmp3[i]:0; 
	}
	NTT(tmp2,cnt,1),NTT(tmp3,cnt,1);
	for(register int i=0;i<cnt;i++)
	{
		res[i]=tmp3[i]=(li)tmp3[i]*tmp2[i]%MOD;
	}
	NTT(res,cnt,-1),r=MOD-(MOD-1)/cnt,invr=qpow(r,MOD-2);
	for(register int i=0;i<cnt;i++)
	{
		res[i]=tmp4[i]=i<(cnt>>1)?res[i]:0,tmp3[i]=f[i];
	}
	NTT(tmp3,cnt,1),NTT(tmp4,cnt,1);
	for(register int i=0;i<cnt;i++)
	{
		tmp3[i]=(li)tmp3[i]*tmp4[i]%MOD;
	}
	NTT(tmp3,cnt,-1),reverse(tmp3+1,tmp3+cnt);
	for(register int i=(cnt>>1);i<cnt;i++)
	{
		tmp3[i]=(tmp3[cnt-i]+MOD-tmp[i])%MOD;
	}
	for(register int i=0;i<(cnt>>1);i++)
	{
		tmp3[i]=(li)tmp3[i]*invr%MOD;
	}
	memset(tmp3,0,cnt<<1),NTT(tmp3,cnt,1);
	for(register int i=0;i<cnt;i++)
	{
		tmp3[i]=(li)tmp3[i]*tmp2[i]%MOD;
	}
	NTT(tmp3,cnt,-1);
	for(register int i=cnt>>1;i<cnt;i++)
	{
		res[i]=MOD-tmp3[i];
	}
}
#define ls node<<1
#define rs (node<<1)|1
inline void calc(ll l,ll r,ll node)
{
	static ll tmp[MAXN],tmp2[MAXN];
	tmpf[node].clear();
	if(l==r)
	{
		return tmpf[node].push_back(1),tmpf[node].push_back(MOD-x[l]);
	}
	ll mid=(l+r)>>1,sz,sz2;
	calc(l,mid,ls),calc(mid+1,r,rs),sz=tmpf[ls].size(),sz2=tmpf[rs].size();
	memset(tmp,0,max(sz,sz2)<<2),memset(tmp2,0,max(sz,sz2)<<2);
	copy(tmpf[ls].begin(),tmpf[ls].end(),tmp);
	copy(tmpf[rs].begin(),tmpf[rs].end(),tmp2);
	conv(max(sz,sz2),tmp,tmp2,tmp),tmpf[node].resize(sz+sz2-1);
	copy(tmp,tmp+sz+sz2-1,tmpf[node].begin());
}
inline void solve()
{
	n=read(),res=0;
	for(register int i=1;i<=n;i++)
	{
		x[i]=read()%MOD;
	}
	calc(1,n,1),copy(tmpf[1].begin(),tmpf[1].end(),f),lnDeriv(n+1,f,g);
	for(register int i=0;i<n;i++)
	{
		res^=((MOD-g[i])%MOD);
	}
	printf("%d\n",res);
}
int main()
{
    test=read(),setupOmg(1048576);
    for(register int i=0;i<test;i++)
    {
    	solve();
	}
}
```

---

## 作者：cyffff (赞：3)

[$\text{Link}$](https://www.luogu.com.cn/problem/P7431)

$\text{upd 2022.2.8}$：修改 $\LaTeX$ 和错误的式子。
## 题意
$$f_k=(\sum_{i=1}^na_i^k)\bmod 998244353$$
计算出 $f_1\sim f_n$。
## 思路
算出 $f$ 数列的 $\text{OGF}$ $F(x)$

$$\begin{aligned}F(x)&=\sum_{i\ge0}x^i\Big(\sum_{j=1}^n{a_j}^i\Big)\\&=\sum_{j=1}^n\sum_{i\ge0}{(a_jx)}^i\\&=\sum_{j=1}^n\dfrac{1}{1-a_jx}\\&=\sum_{j=1}^n\Big(1-\dfrac{-a_jx}{1-a_jx}\Big)\\&=n-x\sum_{j=1}^n\dfrac{-a_j}{1-a_jx}\end{aligned}$$
我们发现有 $\dfrac{-a_j}{1-a_jx}=(\ln(1-a_jx))'$，得：
$$F(x)=n-x\sum_{j=1}^n(\ln(1-a_jx))'$$
又有 $a'+b'=(a+b)'$，得：
$$\begin{aligned}F(x)&=n-x(\sum_{j=1}^n\ln(1-a_jx))'\\&=n-x(\ln\prod_{j=1}^n(1-a_jx))'\end{aligned}$$
这个可以分治 $\text{NTT}$ 求出。

再见 qwq~

---

## 作者：Union_of_Britain (赞：1)

> 部分内容参考自《代数学引论》第一卷。

## 前置知识

定义**幂和** ${\bf p}_k(X_{1:n})=S(X_1^k)=\sum_i X_i^k$。

定义初等对称多项式 

$$s_k=\sum _{a_1<a_2<\dots<a_k}\prod_i X_{a_i}$$

根据对称多项式基本定理，任何对称多项式都可以被拆分为初等对称多项式的线性组合（保证权为次数时唯一）。幂和可以通过下面的公式展开为初等对称多项式。

**牛顿公式**：

若 $1\le k\le n$：
$$
{\bf p}_k-{\bf p}_{k-1}s_1+\dots +(-1)^{k-1}{\bf p}_1s_{k-1}+(-1)^kks_k=0
$$
若 $k>n$：
$$
{\bf p}_k-{\bf p}_{k-1}s_1+\dots +(-1)^{n-1}{\bf p}_{k-n+1}s_{n-1}+(-1)^n{\bf p}_{k-n}s_n=0
$$

证明：首先不难证明，对于 $k\ge n$，有：

$$
X_i^k-s_1X_i^{k-1}+\dots +(-1)^ns_nX^{k-n}_i=0
$$
对其求和得到 $k\ge n$ 时的公式。考虑 $k<n$：

进而考察齐次对称多项式 $f_{k,n}$：
$$
f_{k,n}=\sum_{i\ge 1} {\bf p}_is_{k-i}(-1)^{k-i}+(-1)^kks_k
$$
对 $n-k$ 归纳。$n=k$ 时已经证明成立。

依靠归纳假设，不难证明 $f_{k,n}(X_1,X_2,\dots ,X_{n-1},0)=0$。

故所以 $X_n\mid f_{k,n}$。根据对称性所以 $s_n\mid f_{k,n}$。而 $\deg f_{k,n}<\deg s_n$，故 $f_{k,n}=0$。证毕。

而根据韦达定理：

设

$$a_i=[X^{n-i}]\prod_{i=1}^n (X-X_i)$$

则

$$a_i=(-1)^is_i(X_{1:n})$$

那么对于 $k\in [1,n]\cap \mathbb Z$，有：

$$
{\bf p}_k+{\bf p}_{k-1}a_1+\dots +{\bf p}_1a_{k-1}+ka_k=0$$

## Solution

在本题中，希望求出幂和 ${\bf p}_k(c_{1:n}),k=1,2,\dots n$，则先可使用分治 NTT 求出

$$a_i=[X^{n-i}]\prod (X-c_i)$$

然后根据公式

$$\left(\sum_{k=1}^n {\bf p_k}x^k\right)\left(\sum_{i=0}^n a_ix^i\right)\bmod x^{n+1}=-\sum_{i=0}^n ia_ix^i $$

通过多项式求逆得出答案。

```cpp
// Problem: P7431 [THUPC2017] 小 L 的计算题
// Platform: Luogu
// URL: https://www.luogu.com.cn/problem/P7431
// Memory Limit: 500 MB
// Time Limit: 3000 ms
// Author:British Union
// Long live UOB and koala
// 
// Powered by CP Editor (https://cpeditor.org)

#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=1e6+5,mod=998244353,g=3,ig=(mod+1)/3;
int lim,L,r[maxn];
void predo(int n){
	lim=1,L=0;
	while(lim<=n)lim<<=1,L++;
	for(int i=1;i<lim;i++)r[i]=(r[i>>1]>>1)|((i&1)<<L-1);
}
#define Poly vector<int> 
int qp(int a,int b){
	if(b==0)return 1;
	int T=qp(a,b>>1);T=T*T%mod;
	if(b&1)return T*a%mod;
	return T;
}
int Ttt[maxn];
void ntt(Poly &a,int tp){
	for(int i=0;i<lim;i++)if(r[i]>i)swap(a[i],a[r[i]]);
	for(int mid=1;mid<lim;mid<<=1){
		int wn=qp(tp==1?g:ig,(mod-1)/(mid<<1));
		Ttt[0]=1;
		for(int i=1;i<mid;i++)Ttt[i]=Ttt[i-1]*wn%mod;
		for(int j=0;j<lim;j+=(mid<<1)){
			int W=1;
			for(int k=0;k<mid;k++,W=Ttt[k]){
				int x=a[j+k],y=a[j+k+mid]*W%mod;
				a[j+k]=(x+y)%mod,a[j+k+mid]=(x-y+mod)%mod;
			}
		}
	}
	if(tp==-1){
		int I=qp(lim,mod-2);
		for(int i=0;i<lim;i++)a[i]=a[i]*I%mod;
	}
}
Poly operator +(Poly a,Poly b){
	Poly c(max(a.size(),b.size()));
	for(int i=0;i<c.size();i++){
		c[i]=0;
		if(a.size()>i)c[i]+=a[i];
		if(b.size()>i)c[i]+=b[i];
		c[i]%=mod;
	}
	return c;
}
Poly operator -(Poly a,Poly b){
	Poly c(max(a.size(),b.size()));
	for(int i=0;i<c.size();i++){
		c[i]=0;
		if(a.size()>i)c[i]+=a[i];
		if(b.size()>i)c[i]-=b[i]-mod;
		c[i]%=mod;
	}
	return c;
}
Poly operator *(Poly a,Poly b){
	Poly A=a,B=b,c;
	predo(a.size()+b.size());
	A.resize(lim),B.resize(lim);c.resize(lim);
	ntt(A,1);ntt(B,1);
	for(int i=0;i<lim;i++)c[i]=A[i]*B[i]%mod;
	ntt(c,-1);
	c.resize(a.size()+b.size()-1);
	return c;
}
Poly inv(Poly &a,int len){
	if(len==1){
		Poly b(1);
		b[0]=qp(a[0],mod-2);
		return b;
	}
	Poly b=inv(a,(len+1)>>1),c(len);
	for(int i=0;i<len;i++)c[i]=a[i];
	predo(len*2-1);
	b.resize(lim),c.resize(lim);
	ntt(c,1);ntt(b,1);
	for(int i=0;i<lim;i++)b[i]=(2-b[i]*c[i]%mod+mod)%mod*b[i]%mod;
	ntt(b,-1);b.resize(len);
	return b;
}
Poly f[200005];
Poly solve(int l,int r){
	if(l==r)return f[l];
	int mid=l+r>>1;
	return solve(l,mid)*solve(mid+1,r);
}
inline int read(){
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
int n,T;
int pow1(int x){
	return x%2?mod-1:1;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	T=read();
	while(T--){
		n=read();
		for(int i=1;i<=n;i++){
			int a;a=read();
			f[i]={mod-a,1};
		}
		Poly F=solve(1,n),F2=F,H(n+1);
		for(int i=0;i<=n;i++)F[i]=F2[n-i],H[i]=mod-i*F2[n-i]%mod;
		Poly G=inv(F,n+1);
		G=G*H;
		int ans=0;
		for(int i=1;i<=n;i++)ans^=G[i];
		cout<<ans<<endl;
	}
	return 0;
}
```

---

## 作者：Fzrcy (赞：1)

考虑生成函数，设 $[z^n]F=\sum_{i=1}^{n}a_{i}^{n}$，有：
$$
\begin{aligned}
F(z)&=\sum_{i=0}^{\infty}\sum_{j=1}^{n}a_{j}^iz^i\\
&=\sum_{j=1}^{n}\sum_{i=0}^{\infty}a_{j}^iz^i\\
&=\sum_{j=1}^{n}\sum_{i=0}^{\infty}(a_{j}z)^i\\
&=\sum_{i=1}^{n}\frac{1}{1-a_{i}z}\\
&=\frac{\sum_{i=1}^{n}\prod_{j\ne i}(1-a_{j}z)}{\prod_{i=1}^{n}(1-a_{i}z)}\\
\end{aligned}
$$
显然分子分母均可以用大力分治 NTT，在 $O(n\log^2n)$ 的复杂度求出，然后多项式求逆即可。

这里介绍一个不同解法，首先我们有 $(\ln(x))'=\frac{1}{x}$，所以：
$$
\begin{aligned}
&\sum_{i=1}^{n}\frac{1}{1-a_{i}z}\\
=&\sum_{i=1}^{n}(1-\frac{-a_{i}z}{1-a_{i}z})\\
=&\sum_{i=1}^{n}(1-z(\ln(1-a_{i}z))')\\
=&n-z\sum_{i=1}^{n}(\ln(1-a_{i}z))'\\
=&n-z(\sum_{i=1}^{n}\ln(1-a_{i}z))'\\
=&n-z(\ln(\prod_{i=1}^{n}1-a_{i}z))'\\
\end{aligned}
$$
我们可以在 $O(n\log^2n)$ 的复杂度求出 $\prod_{i=1}^{n}(1-a_{i}z)$，然后多项式 ln、求导即可，复杂度仍然是 $O(n\log^2n)$。

```cpp
// Fzrcy
#include <bits/stdc++.h>
#define cint const int&
using namespace std;
typedef long long LL;
constexpr int Mod=998244353,N=8e5+9;
inline int suf(int x,cint y){return (x+=y)>=Mod?x-Mod:x;}
inline int sub(int x,cint y){return (x-=y) <  0?x+Mod:x;}
inline int ksm(int x,int y=Mod-2){
    int ret=1;
    for(;y;y>>=1,x=(LL)x*x%Mod)
        if(y&1)ret=(LL)ret*x%Mod;
    return ret;
}
int REV[N],W[N];
inline void DFT(int*a,cint Len,bool fl){
    for(int i=1;i<Len;i++)if(REV[i]>i)swap(a[REV[i]],a[i]);
    for(int d=1;d<Len;d<<=1){
        int w=ksm(3,(Mod-1)/(d<<1));if(fl)w=ksm(w);W[0]=1;
        for(int i=1;i<d;i++)W[i]=(LL)W[i-1]*w%Mod;
        for(int i=0;i<Len;i+=d<<1){
            for(int j=0;j<d;j++){
                int a0=a[i+j],a1=(LL)a[i+j+d]*W[j]%Mod;
                a[i+j]=suf(a0,a1), a[i+j+d]=sub(a0,a1);
            }
        }
    }
    if(fl){
        int x=ksm(Len);
        for(int i=0;i<Len;i++)a[i]=(LL)a[i]*x%Mod;
    }
}
int NTT_F[N],NTT_G[N];
inline void Mul(int*a,int*b,int al,int bl,int*c,int cl){
    int len=1;while(len<=(al+bl+1))len<<=1;
    for(int i=1;i<len;i++)REV[i]=(REV[i>>1]>>1)+(i&1?len>>1:0);
    memset(NTT_F,0,len<<2),memcpy(NTT_F,a,al<<2);
    memset(NTT_G,0,len<<2),memcpy(NTT_G,b,bl<<2);
    DFT(NTT_F,len,0),DFT(NTT_G,len,0);
    for(int i=0;i<len;i++)NTT_F[i]=(LL)NTT_F[i]*NTT_G[i]%Mod;
    DFT(NTT_F,len,1),memcpy(c,NTT_F,cl<<2);
}
int Tmp1[N];
inline void PolyInv(int*a,int n,int*inv){
    if(n==1){inv[0]=ksm(a[0]);return;}
    int m=(n+1)>>1;  PolyInv(a,m,inv);
    Mul(a,inv,n,m,Tmp1,n),Tmp1[0]=sub(Tmp1[0],2);
    for(int i=0;i<n;i++)  Tmp1[i]=sub(0,Tmp1[i]);
    return Mul(inv,Tmp1,m,n,inv,n);
}
int Tmp2[N],ninv[N];
inline void dao(int*a,int n){for(int i=0;i<n-1;i++)a[i]=(LL)a[i+1]*(i+1)%Mod;a[n-1]=0;}
inline void jifen(int*a,int n){for(int i=n-1;i;i--)a[i]=(LL)a[i-1]*ninv[i]%Mod;a[0]=0;}
inline void Ln(int*a,int n,int*b){PolyInv(a,n,Tmp2),memcpy(b,a,n<<2),dao(b,n),Mul(b,Tmp2,n,n,b,n),jifen(b,n);}
int Tmp3[N];
inline void Exp(int*a,int n,int*b){
    if(n==1){b[0]=1;return;}
    int m=n+1>>1;Exp(a,m,b);
    for(int i=m;i<n;i++)b[i]=0;
    Ln(b,n,Tmp3);Tmp3[0]=sub(Tmp3[0],1);
    for(int i=0;i<n;i++)Tmp3[i]=sub(a[i],Tmp3[i]);
    return Mul(b,Tmp3,m,n,b,n);
}
typedef vector<int> V;
inline V Mul(const V&A,const V&B){
    int len=1,al=A.size(),bl=B.size();while(len<=(al+bl+1))len<<=1;
    for(int i=1;i<len;i++)REV[i]=(REV[i>>1]>>1)+(i&1?len>>1:0);
    memset(NTT_F,0,len<<2);for(int i=0;i<al;i++)NTT_F[i]=A[i];
    memset(NTT_G,0,len<<2);for(int i=0;i<bl;i++)NTT_G[i]=B[i];
    DFT(NTT_F,len,0),DFT(NTT_G,len,0);
    for(int i=0;i<len;i++)NTT_F[i]=(LL)NTT_F[i]*NTT_G[i]%Mod;
    DFT(NTT_F,len,1);V z(al+bl-1,0);
    for(int i=0;i<z.size();i++)z[i]=NTT_F[i];
    return z;
}
int T,n,a[N],A[N],Tmp[N];
inline V solve(int l,int r){
    if(l==r)return {1,(Mod-a[l])%Mod};int m=l+r>>1;
    return Mul(solve(l,m),solve(m+1,r));
}
int main(){
    ninv[0]=ninv[1]=1;
    for(int i=2;i<N;i++)ninv[i]=(LL)ninv[Mod%i]*(Mod-Mod/i)%Mod;
    for(scanf("%d",&T);T--;){
        scanf("%d",&n);for(int i=1;i<=n;i++)scanf("%d",&a[i]),a[i]%=Mod;
        V ret=solve(1,n);for(int i=0;i<=n;i++)A[i]=ret[i];
        Ln(A,n+1,Tmp);dao(Tmp,n+1);
        for(int i=0;i<n;i++)Tmp[i]=(Mod-Tmp[i])%Mod;
        for(int i=n;i>=1;i--)Tmp[i]=Tmp[i-1];Tmp[0]=n;
        int ans=0;for(int i=1;i<=n;i++)ans^=Tmp[i];
        cout<<ans<<endl;
    }
    return 0;
}
```



---

## 作者：lzyqwq (赞：0)

选自我的 [多项式与生成函数学习笔记](https://www.luogu.com.cn/article/ismqu7s9)。

> - 现有一个长度为 $n$ 的非负整数数组 $\{a_i\}$。定义：
> $$f_k=\left(\sum_{i=1}^na_i^k\right)\bmod 998244353$$
> - 计算出 $f_1,\dots,f_n$。
> - 多测，$n\le 2\times 10^5$，$\sum n\le 4\times 10^5$。



$k=0$ 是容易的，而且我们不需要算。所以考虑写出 $k\ge 1$ 时每个 $a_i$ 的若干次方的 OGF：

$$F_i(x)=\sum\limits_{k=1}^{+\infty}a_i^kx^k=\dfrac{a_ix}{1-a_ix}$$

那么 $k$ 次方和答案就是：

$$\left[x^k\right]\sum\limits_{i=1}^{n}F_i(x)=\left[x^k\right]x\sum\limits_{i=1}^n\dfrac{a_i}{1-a_ix}$$

接下来是让人惊掉下巴的操作，注意到：

$$\dfrac{a_i}{1-a_ix}=-\ln'(1-a_ix)$$

那么：

$$\begin{aligned}\sum\limits_{i=1}^n\dfrac{a_i}{1-a_ix}&=-\sum\limits_{i=1}^n\ln'(1-a_ix)\\&=-\left(\sum\limits_{i=1}^n\ln(1-a_ix)\right)'\\&=-\ln'\left(\prod\limits_{i=1}^n(1-a_ix)\right)\end{aligned}$$

$\prod\limits_{i=1}^n(1-a_ix)$ 可以用分治 + NTT 计算，设为 $G(x)$，那么：

$$\ln' G(x)=\dfrac{G'(x)}{G(x)}$$

那么答案的 OGF 就是 $H(x)=-\dfrac{xG'(x)}{G(x)}$。由于我们只需要知道不超过 $n$ 次项，所以求出 $G(x)$ 模 $x^{n+1}$ 意义下的逆后再 NTT 计算即可。

代码里面是求出 $\dfrac{G'(x)}{G(x)}$，然后利用 $\left[x^k\right]H(x)=-\left[x^{k-1}\right]\dfrac{G'(x)}{G(x)}$。

时间复杂度 $\mathcal{O}\left(\sum n\log^2 n\right)$，空间复杂度 $\mathcal{O}(n)$。


```cpp
#include <bits/stdc++.h>
using namespace std; const int N = 1 << 21;
namespace Poly {
	using ll = long long; using poly = vector<ll>;
	const ll G = 3, M = 998244353; int R[N]; poly get(int n) { return poly(n + 1); }
	int dg(poly &a) { return a.size() - 1; }
	ll qp(ll x, ll y = M - 2) {
		ll r = 1; for (; y; y >>= 1, x = x * x % M) if (y & 1) r = r * x % M;
		return r;
	}
	void I(int n) {
		for (int i = 0; i < n; ++i) {
			R[i] = R[i >> 1] >> 1; if (i & 1) R[i] |= n >> 1;
		}
	}
	void NTT(poly &a, int n, bool o = 0) {
		if (o) I(n); for (int i = 0; i < n; ++i) if (i < R[i]) swap(a[i], a[R[i]]);
		for (int i = 2; i <= n; i <<= 1) {
			ll g = qp(G, (M - 1) / i), w, u, v;
			for (int j = 0; j < n; j += i) {
				w = 1;
				for (int k = j; k < j + (i >> 1); ++k, w = w * g % M)
					u = a[k], v = w * a[k + (i >> 1)] % M,
					a[k] = (u + v) % M, a[k + (i >> 1)] = (u - v + M) % M;
			}
		}
	}
	poly operator-(poly a, poly b) {
		poly c;
		if (dg(a) < dg(b)) {
			c = get(dg(b));
			for (int i = 0; i <= dg(a); ++i) c[i] = (a[i] - b[i] + M) % M;
			for (int i = dg(a) + 1; i <= dg(b); ++i) c[i] = (M - b[i]) % M;
		} else {
			c = a; for (int i = 0; i <= dg(b); ++i) c[i] = (c[i] - b[i] + M) % M;
		}
		return c;
	}
	poly mod(poly a, int n) { a.resize(n); return a; }
	poly operator*(poly a, poly b) {
		int n = dg(a), m = dg(b), L = 1; while (L <= n + m) L <<= 1;
		a.resize(L); b.resize(L); NTT(a, L, 1); NTT(b, L);
		for (int i = 0; i < L; ++i) a[i] = a[i] * b[i] % M; NTT(a, L);
		poly c = get(n + m); ll iv = qp(L); c[0] = a[0] * iv % M;
		for (int i = 1; i <= n + m; ++i) c[i] = a[L - i] * iv % M; return c;
	}
	poly inv(poly a, int n) {
		poly r, c; r = c = get(0); r[0] = qp(a[0]); c[0] = 2;
		for (int i = 1; (1 << i - 1) <= n; ++i)
			r = mod(r * (c - mod(mod(a, 1 << i) * r, 1 << i)), 1 << i);
		return mod(r, n);
	}
	poly dao(poly a) {
		poly b = poly(dg(a));
		for (ll i = 0; i < dg(a); ++i) b[i] = (i + 1) * a[i + 1] % M; return b;
	}
}
using namespace Poly; ll T, n, a[N], ans; poly t;
poly F(int l, int r) {
	if (l == r) {
		poly c = get(1); c[0] = 1; c[1] = (M - a[l]) % M; return c;
	}
	int m = l + r >> 1; return F(l, m) * F(m + 1, r);
}
int main() {
	cin.tie(0); cout.tie(0); ios::sync_with_stdio(0);
	for (cin >> T; T--;) {
		cin >> n; for (int i = 1; i <= n; ++i) cin >> a[i];
		t = F(1, n); t = mod(dao(t) * inv(t, n), n); ans = 0;
		for (int i = 1; i <= n; ++i) ans ^= (M - t[i - 1]) % M; cout << ans << '\n';
	}
	return 0;
}
```

---


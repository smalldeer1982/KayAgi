# [传智杯 #3 决赛] 旅人1969

## 题目背景

在被称为未来的二十一世纪里，只残留着不安与少许的幻想。

永远与须臾的罪人啊，二十世纪的诺亚方舟，承载着期待与不安向着天空飞去呢！

而作为希望的你，在这并不永恒的旅途中，会怎样地前行呢？

## 题目描述

一条笔直的公路上有 $n$ 个旅店，第 $i$ 个旅店的坐标是 $i$，每一天早上从旅店出发走最多 $m$ 个距离，同时固定给你一个常数 $k$。

给定 $q$ 组询问，每次给定 $u,v$，求早上从旅店 $u$ 出发到旅店 $v$，途径不超过 $k$ 个旅店（不含起点 $u$）且行走方向不变的方案数。两种方案不同当且仅当存在一个不同的旅店选择，答案对 $998244353$ 取模。

对于所有数据，$n,q\leq 10^5$，$m,k\leq 10^4$，$mk\leq 10^5$，$u,v\leq n$。

## 样例 #1

### 输入

```
3 2 2 2
1 3
2 3```

### 输出

```
2
1```

## 样例 #2

### 输入

```
2077 30 200 3
1949 2021
1969 2077
1970 2004
```

### 输出

```
360658315
804081653
603979748```

# 题解

## 作者：LGyxj (赞：6)

最开始以为是反演，但很快发现并不是。

考虑进行 dp 。

$f_{k, n}$ 表示走了 $k$ 步，走到第 $n$ 个点。

不难想出，有以下转移：

$$f_{k, n} = \sum\limits_{x = 1}^m f_{k - 1, n - x}$$

于是写出它的生成函数

$$g = \sum\limits_{i = 1}^m x^i$$

$$f_k = g^k$$

那么我们要求的就是

$$h_k = \sum\limits_{i = 0}^k f_i$$

显然，这个东西是可以倍增的，即

$$h_{2k} = h_k + f_k * h_k$$

那么求出所有 $h_{2^i}$ 和 $f_{2^i}$，这部分是 $O(n \log k)$ 的。

再对 $k$ 进行二进制数位 dp 即可，不难发现，这部分也是 $O(n \log k)$ 的。

主要代码如下

```cpp
void solve() {
	for (int i = 0; i < Nn; ++ i) cur[i] = 1;
	for (int i = 1; i <= m; ++ i) g[i] = 1;
	fft(g); memcpy(f[0], g, sizeof g);
	memcpy(h[0], g, sizeof g);
	for (int i = 1; i < 14; ++ i) {
		for (int j = 0; j < Nn; ++ j) 
			f[i][j] = 1ll * f[i - 1][j] * f[i - 1][j] % mod;
		for (int j = 0; j < Nn; ++ j) 
			h[i][j] = (h[i - 1][j] + 1ll * h[i - 1][j] * f[i - 1][j]) % mod;
	}
	for (int i = 14; ~i; -- i) {
		if (k >> i & 1) {
			for (int j = 0; j < Nn; ++ j) 
				qx[j] = (qx[j] + 1ll * cur[j] * h[i][j]) % mod;
			for (int j = 0; j < Nn; ++ j) cur[j] = 1ll * cur[j] * f[i][j] % mod;
		}
	}
	fft(qx, 0); qx[0] = 1;
}
```

---

## 作者：514InParadox (赞：5)

一种朴素的多项式做法。

首先发现答案与出发结束点无关，直接设 $f_{i,j}$ 表示走过距离为 $i$，经过旅店为 $j$ 的方案数，有转移方程：

$$f_{i,j}=\sum_{d=1}^mf_{i-d,j-1}$$

设 $ans_d$ 表示距离为 $d$ 的答案，则
$$ans_d=\sum_{i=0}^kf_{d,j}$$

$f$ 的第二维可以考虑经典矩阵优化；但进一步发现转移方程的形式很像多项式乘法。

则设状态函数 $F_k(x)$，转移函数 $G(x)$，答案函数 $A(x)$，使 
$$
\begin{aligned}  
F_k(x)&=\sum_{i=0}^\infty f_{i,k}x^i \\ 
G(x)&=\sum_{i=1}^mx^i \\  
A(x)&=\sum_{i=0}^\infty\sum_{j=0}^kf_{i,j}x^i 
\end{aligned}
$$
又有 $F_0(x)=1$，可知
$$
\begin{aligned}
F_{k}(x)&=F_{k-1}(x)G(x) \\ 
&=G^k(x)
\end{aligned}
$$

考虑答案函数
$$
\begin{aligned}
A(x)&=\sum_{i=0}^kF_i(x) \\
&=\sum_{i=0}^kG^i(x) \\
&=\dfrac{1-G^{k+1}(x)}{1-G(x)}
\end{aligned}
$$

此时已可做到 $O(n\log n\log k)$ 预处理，$O(q)$ 询问。
```
#include<bits/stdc++.h>
#define INF 1000000007
#define MAXN 400000
using namespace std;
const int mod=998244353,og=3,invg=332748118;

template<typename T>
inline void read( T& r )
{
	r=0;
	bool w=true;
	char ch=getchar();
	while( ch<'0' || ch>'9' ) w=(!(ch^45))?false:w,ch=getchar();
	while( ch>='0' && ch<='9' ) r=(r*10)+(ch^48),ch=getchar();
	r=w?r:-r;
}
//================================
int n,m,k,q;

inline int quick_pow( int a , int p )
{
	int ret=1;
	for(;p;p>>=1)
	{
		if( p&1 ) ret=1ll*ret*a%mod;
		a=1ll*a*a%mod;
	}
	return ret;
}

int rev[MAXN+5];
inline void ntt( int *a , int tep , int typ )
{
	int len=1<<tep;
	for(int i=1;i<len;i++) rev[i]=rev[i>>1]>>1 | (i&1)<<tep-1;
	for(int i=1;i<len;i++) if( i>rev[i] ) swap(a[i],a[rev[i]]);
	
	for(int j=1,lim,gn;j<=tep;j++)
	{
		lim=1<<j-1;
		gn=quick_pow(typ?og:invg,mod-1>>j);
		for(int s=0,g0;s<len;s+=lim<<1)
		{
			g0=1;
			for(int i=0;i<lim;i++,g0=1ll*g0*gn%mod)
			{
				int x=a[s+i],y=1ll*g0*a[s+i+lim]%mod;
				a[s+i]=(x+y)%mod;
				a[s+i+lim]=(x-y+mod)%mod;
			}
		}
	}
	if( !typ )
	{
		int inv=quick_pow(len,mod-2);
		for(int i=0;i<len;i++) a[i]=1ll*a[i]*inv%mod;
	}
}
inline void mul( int *f , int *g , int n , int m )
{
	int tep=0;
	while( 1<<tep<=n+m ) ++tep;
	ntt(f,tep,1),ntt(g,tep,1);
	for(int i=0;i<1<<tep;i++) f[i]=1ll*f[i]*g[i]%mod;
	ntt(f,tep,0),ntt(g,tep,0);
}
int c[MAXN+5];
inline void inv( int *f , int *h , int deg )
{//求mod x^(deg+1)意义下h的逆f
	memset(f,0,sizeof(f));memset(c,0,sizeof(c));
	f[0]=quick_pow(h[0],mod-2);
	for(int tep=2;;tep++)
	{
		memcpy(c,h,sizeof(int)*1<<tep-1);
		ntt(c,tep,1),ntt(f,tep,1);
		for(int i=0;i<1<<tep;i++) f[i]=(2-1ll*f[i]*c[i]%mod+mod)%mod*f[i]%mod;
		ntt(f,tep,0);
		for(int i=1<<tep-1;i<1<<tep;i++) f[i]=0;
		if( 1<<tep-1>deg ) break;
	}
}
inline void qpow( int *f , int p , int deg )
{
	int tep=0;
	while( 1<<tep<deg*2+1 ) ++tep;
	
	memcpy(c,f,sizeof(int)*(deg+1));
	memset(f+1,0,sizeof(int)*deg);
	f[0]=1;
	for(;p;p>>=1)
	{
		if( p&1 ) mul(f,c,deg,deg);
		ntt(c,tep,1);
		for(int i=0;i<1<<tep;i++) c[i]=1ll*c[i]*c[i]%mod;
		ntt(c,tep,0);
	}
}
int F[MAXN+5],G[MAXN+5],g[MAXN+5];
int main()
{
	read(n),read(m),read(k),read(q);
	for(int i=1;i<=m;i++) g[i]=1;
	F[0]=(1-g[0]+mod)%mod; 
	for(int i=1;i<=n;i++) 
	{
		F[i]=(mod-g[i])%mod;
	}
	qpow(g,k+1,n);
	G[0]=(1-g[0]+mod)%mod; 
	for(int i=1;i<=n;i++) 
	{
		G[i]=(mod-g[i])%mod;
	}
	memset(g,0,sizeof(g));
	inv(g,F,n);
	mul(G,g,n,n);	
	for(int i=1,l,r;i<=q;i++)
	{
		read(l),read(r);
		r=abs(l-r);
		printf("%d\n",G[r]);
	}
	return 0;
}
```

---

## 作者：__stick (赞：1)



## 题意

一条笔直的公路上有 $n$ 个旅店，第 $i$ 个旅店的坐标是 $i$，每一天早上从旅店出发走最多 $m$ 个距离，同时固定给你一个常数 $k$。

给定 $q$ 组询问，每次给定 $u,v$，求早上从旅店 $u$ 出发到旅店 $v$，途径不超过 $k$ 个旅店（不含起点 $u$）且行走方向不变的方案数。两种方案不同当且仅当存在一个不同的旅店选择，答案对 $998244353$ 取模。

对于所有数据，$n,q\leq 10^5$，$m,k\leq 10^4$，$mk\leq 10^5$，$u,v\leq n$。

## 思路

发现重要的仅仅是 $v-u$ 的值。

然后就可以设计 $dp$ z状态了：

$F_{i,j}$ 表示走到 $i$ 走了 $j$ 步的方案数。

答案就是：
$$
\sum_{i=0}^{k}F_{v-u,i}
$$
然后考虑转移：
$$
F_{i,j}=\sum_{k=1}^m F_{i-k,j-1}
$$
发现时间复杂度是 $O(nmk)$ 的。

交换两维，滚动数组，就可以 dp 了。

复杂度看起来 $10^{10}$ 能过，好吧，看起啦也不行，但是还是会 T。

考虑优化这个鬼玩意。

交换两维，令：
$$
G_i(x)=\sum_{j\ge0}F_{i,j}x^j
$$
然后转移就变成了：
$$
G_i(x)=\sum_{j\ge 0}\sum_{k=1}^m[x^{j-k}]G_{i-1}(x)\cdot x^k
$$
还没有看出来？
$$
[x^n]G_i(x)=\sum_{k=1}^n[x^{n-k}]G_{i-1}(x)\cdot [x^k]h(x)
$$
其中 ：
$$
h(x)=\sum_{i=1}^mx^i
$$
明显后面就是卷积了（比原来多出来的项都是 $0$）。

然后：
$$
G_i(x)=G_{i-1}(x)\cdot h(x)
$$
可以直接算了，但是复杂度 $O(nk \log n)$ 最坏情况下反而增加了。

但是因为 $G_0(x)=1$ 。

于是 $G_i(x)=h(x)^i$ 。

然后答案的生成函数：
$$
ans(x)=\sum_{i=0}^kG_i(x)
$$
即：
$$
\sum_{i=0}^kh(x)^i
$$
根据等比数列求和公式：
$$
ans(x)=\frac{1-h(x)^{k+1}}{1-h(x)} 
$$
由于 $k$ 比较小，可以考虑直接倍增，应该比大常数 exp 要快。

这里 exp 由于不保证 $h(0)=1$，所以多项式快速幂相当麻烦，还得计算：

$(\frac{h(x)}{x})^{k+1}\cdot x^{k+1}$ 。然后果然慢了 500 多 ms。



## code

板子就不放了，这是倍增的。

```c++
int main()
{	
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	int n,m,k,T;
	cin>>n>>m>>k>>T;
	vi h(m+1);
	for(int i=1;i<=m;i++)h[i]=1;
	vi a(n+1);
	for(int i=1;i<=min(n,m);i++)a[i]=mod-h[i];
	a[0]++;
	getinv(a);
	vi ans={1};
	for(int p=k+1;p;p>>=1)
	{
		if(p&1)
		{
			ans=ans*h;
			if(ans.size()>n+1)ans.resize(n+1);
		}
		prework(n*2+2);h.resize(lim);
		ntt(h,1);
		for(int i=0;i<lim;i++)h[i]=mul(h[i],h[i]);
		ntt(h,0);h.resize(n+1);
	}
	for(int i=0;i<=n;i++)ans[i]=mod-ans[i];
	ans[0]++;
	ans=ans*a;
	while(T--)
	{
		int u,v;cin>>u>>v;
		cout<<ans[abs(u-v)]<<'\n';
	}
	return 0;
}
```

这是多项式快速幂的：

```c++
int main()
{	
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	int n,m,k,T;
	cin>>n>>m>>k>>T;
	vi g(m+1);
	for(int i=1;i<=m;i++)g[i]=1;
	vi a(n+1);
	for(int i=1;i<=min(n,m);i++)a[i]=mod-g[i];
	a[0]++;
	getinv(a);
	vi ans(max(n,m)+1);
	for(int i=0;i<m;i++)ans[i]=1;
	getln(ans);
	for(int i=0;i<=n;i++)ans[i]=mul(ans[i],k+1);
	getexp(ans);
	for(int i=n-k-1;i>=0;i--)ans[i+k+1]=ans[i];
	for(int i=0;i<=k;i++)ans[i]=0;
	for(int i=0;i<=n;i++)ans[i]=mod-ans[i];
	ans[0]++;
	ans=ans*a;
	while(T--)
	{
		int u,v;cin>>u>>v;
		cout<<ans[abs(u-v)]<<'\n';
	}
	return 0;
}
```



---


# [ZJOI2013] K大数查询

## 题目描述

你需要维护 $n$ 个可重整数集，集合的编号从 $1$ 到 $n$。  
这些集合初始都是空集，有 $m$ 个操作：  

- `1 l r c`：表示将 $c$ 加入到编号在 $[l,r]$ 内的集合中  
- `2 l r c`：表示查询编号在 $[l,r]$ 内的集合的并集中，第 $c$ 大的数是多少。  

注意可重集的并是不去除重复元素的，如 $\{1,1,4\}\cup\{5,1,4\}=\{1,1,4,5,1,4\}$。


## 说明/提示

【样例说明】   
第 $1$ 次操作在 $1,2$ 号集合中分别加入了一个  $1$。    
第 $2$ 次操作在 $1,2$ 号集合中分别加入了一个 $2$。   
第 $3$ 次操作查询 $1$ 号集合中第 $2$ 大的数，答案为 $1$。  
第 $4$ 次操作查询 $1$ 号集合中第 $1$ 大的数，答案为 $2$。    
第 $5$ 次操作查询 $1,2$ 号集合的并集 $\{1,2,1,2\}$ 中第 $3$ 大的数，答案为 $1$。

【数据范围】  
$1 \le n,m \le 5\times 10^4$   
$1\le l,r \le n$   
$1$ 操作中 $|c|\le n$   
$2$ 操作中 $1\le c < 2^{63}$，第 $c$ 大的数存在

---

$\text{upd 2023.8.23}$：新增加一组 Hack 数据。

## 样例 #1

### 输入

```
2 5
1 1 2 1
1 1 2 2
2 1 1 2
2 1 1 1
2 1 2 3```

### 输出

```
1
2
1```

# 题解

## 作者：I_AM_HelloWord (赞：84)

此题有三种做法：


1.平衡树套线段树


2.线段树套线段树


3.整体二分


这里介绍一下后两种做法。


我先写了个200+行的线段树套平衡树（~~注意顺序~~），然后效率是$O(nlog^3n)$，简直爆炸。


### 2.线段树套线段树

为什么线段树套平衡树是$O(nlog^3n)$的呢？因为我们需要查询的是权值，然而我外层是线段树，所以先二分答案，然后分解区间，到了各个平衡树时，又相当于二分了一次位置，实在是没必要。


因此，这里，我们的线段树套线段树，确切的说应该是权值线段树套区间线段树。


外层是权值线段树，实质上就是一个二分答案的过程，然后运用类似归并树和主席树的思想，我们设询问区间为$[ql,qr]$,答案区间为$[l,r]$,取其$mid$，然后计算在左儿子$[l,mid]$和询问区间$[ql,qr]$中的数的个数，那么我们就可以判断答案是大于$mid$还是小于$mid$的了。而在权值线段树的每一个节点上都建一个区间线段树，来维护该权值在$[1,n]$所有区间上的出现次数，然后维护一个区间和就好了。


还有就是防止MLE，在区间线段树上搞个动态开点就好了。


算法设计基本上就是这样了，具体细节就看代码了。


参考代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<vector>
#include<iostream>
#include<ctime>
#define rint register int
using namespace std;
typedef long long ll;
const int inf = 0x7fffffff;
const int N=5e4+5;
const int Tree=N*400;
int n,m,node=0,totn;
int ql[N],qr[N],op[N],b[N],k[N];
int rt[N<<2],tag[Tree];
ll sz[Tree];
struct Tnode{
    int L,R;
}T[Tree];
inline int read(){
    int x=0,f=1;char ch=getchar();
    while (ch<'0' || ch>'9'){if (ch=='-')f=-1;ch=getchar();}
    while ('0'<=ch && ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return x*f;
}
#define lc p<<1
#define rc p<<1|1
inline void pushdown(int p,int l,int r){
    int &v=tag[p],mid=(l+r)>>1;
    if (!T[p].L)T[p].L=++node;
    if (!T[p].R)T[p].R=++node;
    tag[T[p].L]+=v,tag[T[p].R]+=v;
    sz[T[p].L]+=v*(mid-l+1),sz[T[p].R]+=v*(r-mid);
    v=0;
}
inline void update(int &p,int ql,int qr,int l=1,int r=n){
    if (!p)p=++node;
    if (ql<=l && r<=qr){
        ++tag[p];sz[p]+=r-l+1;
        return;
    }
    if (tag[p])pushdown(p,l,r);
    rint mid=(l+r)>>1;
    if (ql<=mid) update(T[p].L,ql,qr,l,mid);
    if (mid<qr) update(T[p].R,ql,qr,mid+1,r);
    sz[p]=sz[T[p].L]+sz[T[p].R];
}
inline ll getsum(int &p,int ql,int qr,int l=1,int r=n){
    if (!p)return 0;
    if (ql<=l && r<=qr) return sz[p];
    if (tag[p])pushdown(p,l,r);
    rint mid=(l+r)>>1;
    ll tt=0;
    if (ql<=mid) tt+=getsum(T[p].L,ql,qr,l,mid);
    if (mid<qr) tt+=getsum(T[p].R,ql,qr,mid+1,r);
    return tt;
}
inline void add(int ql,int qr,int k,int p=1,int l=1,int r=totn){
    update(rt[p],ql,qr);
    if (l==r) return;
    rint mid=(l+r)>>1;
    if (k<=mid) add(ql,qr,k,lc,l,mid);
        else add(ql,qr,k,rc,mid+1,r);
}
inline int query(int ql,int qr,ll k,int p=1,int l=1,int r=totn){
    if (l==r) return b[l];
    rint mid=(l+r)>>1;
    ll tt=getsum(rt[rc],ql,qr);
    if (tt<k) return query(ql,qr,k-tt,lc,l,mid);
        else return query(ql,qr,k,rc,mid+1,r);
}
int main(){
    n=read(),m=read();
    for (rint i=1;i<=m;++i){
        op[i]=read(),ql[i]=read(),qr[i]=read(),k[i]=read();
        if (op[i]==1)b[++totn]=k[i];
    }
    sort(b+1,b+totn+1);
    totn=unique(b+1,b+totn+1)-b-1;
    for (rint i=1;i<=m;++i)
        if (op[i]==1)k[i]=lower_bound(b+1,b+totn+1,k[i])-b;
    for (rint i=1;i<=m;++i){
        if (op[i]==1){
            add(ql[i],qr[i],k[i]);
        }else{
            printf("%d\n",query(ql[i],qr[i],k[i]));
        }
    }
    return 0;
}
```

### 3.整体二分

这应该属于练整体二分的一道比较基础的题目了。


何谓整体二分？就是直接一起二分所有的询问操作的答案，然后暴力扫描当前操作区间，将其划分为答案的左子区间与右子区间两个部分。


那么以什么为划分依据呢？看看这个操作对于左子区间有没有贡献。如果没有，那么就划分到右子区间中，然后将这个操作的权值更改为这个贡献减去所需的贡献，反之，则划分到左子区间中，同时将这个操作的贡献加入某一个容器，为询问操作服务。


这么说可能有点晕。就这道题说的话，应该是这样：

我们设尚未解决的操作区间为$[ql,qr]$,答案区间为$[l,r]$,令当前答案为$mid$。


则若该操作是添加操作，如果其添加的$C<=mid$，这此次操作对于左子区间有贡献，加入左子区间中，并将区间线段树中的区间$[q[i].l,q[i].r]$整体加$1$.


反之，则将操作加入到右子区间中。


若该操作是询问操作，如果当前的$mid$在线段树中查询到的，比它大的数的个数$query()>=q[i].k$，则证明该询问操作应该在右子区间内可以找到答案。反之，则将$q[i].k-=query()$，减去此次查询的贡献，然后将询问操作添加到左子区间中。


参考代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#define rint register int
using namespace std;
typedef long long ll;
const int N=5e4+5;
struct Ask{
    int op,l,r,id;
    ll v;
}q[N],tl[N],tr[N];
int tag[N<<2],rec[N<<2],ans[N];
ll sum[N<<2];
int n,m,Q;
inline int read(){
    int x=0,f=1;char ch=getchar();
    while (ch<'0' || ch>'9'){if (ch=='-')f=-1;ch=getchar();}
    while ('0'<=ch && ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return x*f;
}
#define lc p<<1
#define rc p<<1|1
inline void pushdown(int p,int l,int r){
    if (rec[p]){
        rec[p]=0;
        tag[lc]=tag[rc]=sum[lc]=sum[rc]=0;
        rec[lc]=1,rec[rc]=1;
    }
    if (tag[p]){
        rint mid=(l+r)>>1;
        tag[lc]+=tag[p],tag[rc]+=tag[p];
        sum[lc]+=tag[p]*(mid-l+1);
        sum[rc]+=tag[p]*(r-mid);
        tag[p]=0;
    }
}    
inline void add(int ql,int qr,int w,int p=1,int l=1,int r=n){
    if (ql<=l && r<=qr){
        tag[p]+=w;sum[p]+=w*(r-l+1);
        return;
    }
    if (tag[p] || rec[p])pushdown(p,l,r);
    rint mid=(l+r)>>1;
    if (ql<=mid) add(ql,qr,w,lc,l,mid);
    if (mid<qr) add(ql,qr,w,rc,mid+1,r);
    sum[p]=sum[lc]+sum[rc];
}
inline ll query(int ql,int qr,int p=1,int l=1,int r=n){
    if (ql<=l && r<=qr)return sum[p];
    rint mid=(l+r)>>1;
    ll tt=0;
    if (tag[p] || rec[p])pushdown(p,l,r);
    if (ql<=mid) tt+=query(ql,qr,lc,l,mid);
    if (mid<qr) tt+=query(ql,qr,rc,mid+1,r);
    return tt;
}
inline void solve(int st,int en,int l,int r){
    if (l==r){
        for (rint i=st;i<=en;++i)
            if (q[i].op==2) ans[q[i].id]=l;
        return;
    }
    rint mid=(l+r)>>1;
    bool fl=0,fr=0;
    rint L=0,R=0;
    rec[1]=1;tag[1]=sum[1]=0;
    for (rint i=st;i<=en;++i)
        if (q[i].op==1){
            if (q[i].v>mid){
                add(q[i].l,q[i].r,1);
                tr[++R]=q[i];
            }else
                tl[++L]=q[i];
        }else{
            ll val=query(q[i].l,q[i].r);
            if (val<q[i].v){
                q[i].v-=val;
                fl=1;
                tl[++L]=q[i];
            }else{
                fr=1;
                tr[++R]=q[i];
            }
        }
    for (rint i=1;i<=L;++i) q[st+i-1]=tl[i];
    for (rint i=L+1;i<=L+R;++i) q[st+i-1]=tr[i-L];
    if (fl) solve(st,st+L-1,l,mid);
    if (fr) solve(st+L,en,mid+1,r);
}
int main(){
    n=read(),m=read();
    for (rint i=1;i<=m;++i){
        q[i].op=read(),q[i].l=read(),q[i].r=read(),q[i].v=read();
        if (q[i].op==2)q[i].id=++Q;
    }
    solve(1,m,-n,n);
    for (rint i=1;i<=Q;++i)
        printf("%d\n",ans[i]);
    return 0;
}
```

貌似一比，树套树还好写一点哈？


---

## 作者：hehelego (赞：36)

# 本文写给刚刚学习数据结构,对于偏序问题还不熟练的Oier.
### 如果您是写了这个做法被卡了直接看3.
### 想要了解整体二分(~~三分~~)的可以换一篇.


## (值域)线段树 套 (区间和)线段树 的也许唯一板子题.

### 本文内容
1. 如何得到这个做法+复杂度分析.
2. 实际代码编写.
3. 如何让这个代码卡过去(f read/write代替格式化IO, 线段树区间加的标记永久化)

### 1. val<X 和 pos<Y 是一样的!
首先窝必须说,窝并没能自己独立解决这个题目,这个解法是听dl lxl讲课时了解到的. 这是唯一一个窝听懂了,并且得到很大启发的题目.~~就是因为我太菜了其他都没有听懂好吧~~  


------------

首先看到题目,是不是 树套树单点修改区间kth 即视感?  
好的我们回顾一下 树套树单点修改区间kth的玩法.  
~~emm无 端 跑 题, 自 裁, 请~~  

回顾线段树套平衡树的最常规做法,首先外层的线段树是用来解决区间限制的,即只操作\[l,r]内的元素.内层的平衡树则是用来解决值域上的限制的. 我们看看之前那个log^3的区间kth是怎么玩的.  
1. 二分答案(你看外层是为了满足位置约束造的线段树而不是对于值域建立的平衡树/线段树.没法直接做,只能做一些统计比如pos in \[l,r], count( a\[pos] < x ).~~没错这就是查询排名嘛~~
2. 计算mid再\[l,r]内的排名,考虑的区间减半,最后找到答案.  

对于单点修改,在外层线段树上涉及logn个点,内层平衡树上操作复杂度是logn的,所以直接暴力做.  
 
我们用树套树其实只做了一个事情就是,就是统计 l<= p <= r && a\[p] < x,我们考虑把(p,a\[p])看作一个点,约束是两个不等式,不等式可以用来表示区域,这两个不等式表示的区域是个矩形....所以.这个操作其实就是再一个矩形区域里面数点! 

那么这个时候我们毒瘤一点把之前(2b平衡树)中的单点修改搞成在某位置插入一堆数,您是不是也会做了呢?(emm,总插入数字个5e4级别).   
 
~~我们回顾一下这一部分的标题~~ 等等窝要说什么? 对于值域的约束和对于区间的约束是一样的!,我们考虑之前那个题目的本质是二维数点,我们把坐标系转动pi/2就能看到(其实就是把两个不等式交换顺序嘛qwq),问题还是一个矩形数点的问题.  
我们有了这个想法之后很快可以写出一个外层是解决值域约束,内层是解决区间约束的(2b平衡树做法)对吧,直接点说,swap(p,a\[p])也是可以按照原来的做法来做.  



------------

### 好了回到本题
本题的修改操作是在区间上插入相同值.我们写个伪代码来说明问题.
```python
for i in range(l,r+1):
	arr[i].append(c)
```
~~上文说到,val和pos的约束没什么区别我们尝试也做这样一个旋转坐标系的操作,即arr\[i]保存,val=i的位置.  
```python
for i in range(l,r+1):
	arr[c].append(i)
```
更进一步的,我们考虑arr\[c]\[i]表示val=c,pos=i(这里顺序其实已经无关了).的元素个数.那么这个操作是在干什么呢?  
```python
for i in range(l,r+1):
	arr[c][i]+=1
```
### 哦没错是区间加法!
我们用线段树套线段树来维护arr.即可快速做修改操作,外层是单点修改,内层是区间加法,log^2可做!.  
**具体说,外层区间\[l,r]表示l<=val<=r,内层\[l,r]表示l<=pos<=r的元素有多少个,合起来看就是维护了值在l,r,位置在a,b内的元素个数**

## 等等查询操作呢,只能修改没用啊23333
好说啊,我们套用之前区间kth的解法.而且不是说了值域约束和位置约束一样吗,实在不会做就旋转坐标轴啊2333.  

得到log^3的做法,但是外层是维护值域的线段树可以在它上面二分,用线段树实现一个维护数集的平衡树,kth怎么做?想到了吧!省掉一个log(二分的log).

## 至此,得到了修改查询均为log^2n的做法.  

我们稍微分析一下空间复杂度再跑路好了233,emm是O(V\*N)的吧,V是值域和N同阶的?emm,说得对,但是我们之后讨论怎么解决.




------------

------------
~~分割\*2以示尊敬.~~  
### 2.实际代码编写和空间复杂度问题的解决.
1. 空间复杂度问题,相信您已经想到了是动态开点,这个操作在没有数据结构嵌套时看不出太大的优势.但是数据结构嵌套后,往往是必不可少的.  
**等等这哪一层动态开啊,内层可是区间加啊?**  
**我必须说明,我没办法讲清楚为何这么做,如果下面的讲解并不make sense,那么您可以选择私信我,或者看一些其他题解**  

外层能不能动态开点?我认为也是可以的只是没有意义.每次操作c不相等,外层动态开点失去意义.  我们使用线段树动态开点技巧时应该注意 实际使用是不是达到了 整个范围,如果是,那么没有办法节省空间.  

我们考虑优化内层线段树的空间复杂度.考虑在一个内层树上,区间加法涉及的节点个数(不是最终选中修改的节点,是经过的节点个数)是多少.选定logn,平均深度logn,是不是log^2n?  
并不是,如果您不知道为什么,请尝试自己分析,这说明您连线段树的时间复杂度都分析不对.   

提示,考虑每层经过多少节点,这是O(1)的,然后可以证明.



------------


### 那么内层动态开点之后,修改操作外层涉及logn节点,内层最多开logn节点,空间复杂度nlog^2n(这里n,m,v是同阶的我们不做区分)

## 至此空间复杂度问题得到解决,我们可以开始编写代码.
**我这里直接放出我的AC代码,包含了许多上文没有说到的优化,我们3中讲解**
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
typedef long long ll; //注意每次修改[1,n],元素个数2.5e9超过了int.
typedef unsigned int uint; // 没错我就是换了类型尝试卡时间的.
// IO 优化, 使用 fread,fwrite手动维护buffer. 效率极高,没有必要每个题目都使用
// 建议自己找资料学习.我这里的代码也是粘贴的,如果您认为这段代码侵犯了您的权利请联系本人删除.
namespace IO{
	const int IN_LEN=10000000;
	inline char nc() {
		static char buf[IN_LEN], *p1 = buf, *p2 = buf;
		return p1 == p2 && (p2 = (p1 = buf) + fread (buf, 1, IN_LEN, stdin), p1 == p2) ? EOF : *p1++;
	}
	template<typename T>
		inline T read() {
			char ch = nc();
			T tf = 0;
			T sum = 0;
			while((ch < '0' || ch > '9') && (ch != '-')) ch = nc();
			tf = ((ch == '-') && (ch = nc()));
			while(ch >= '0' && ch <= '9') sum = sum * 10+ (ch - 48), ch = nc();
			(tf) && (sum =- sum);
			return sum;
		}
	inline int gi(){ return read<int>(); }
	inline ll gll(){ return read<ll>(); }
	const int OUT_LEN=10000000;
	char obuf[OUT_LEN], *oh = obuf;
	inline void print(char c) {
		if (oh == obuf + OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), oh = obuf;
		*oh++ = c;
	}
	inline void print(int x) {
		static int buf[30], cnt;
		if (x == 0) {
			print('0');
		} else {
			if (x < 0) print('-'), x = -x;
			for (cnt = 0; x; x /= 10) buf[++cnt] = x % 10 + 48;
			while (cnt) print((char)buf[cnt--]);
		}
		print('\n');
	}
	inline void flush() { fwrite(obuf, 1, oh - obuf, stdout); }
}
const int N=50000+10;
const int M=N<<2;
// 空间复杂度计算的问题,linux发行版都有Python,随便算即可.记得算上常数(比如可能某题目每次修改是两次操作那么空间*2)
const int P=N*17*17;
struct Node{
// 动态开点后不是完全二叉树结构,必须保存左右儿子位置.
// 如果是64位系统pointer空间多一倍,小心MLE,我这里没用使用.
	uint lc,rc,add;
	ll sum;
	Node():lc(0),rc(0),add(0),sum(0LL){}
}t[P];uint cnt;
struct Q{ int opt,l,r;ll c; }q[N];
inline uint newnode(){ return ++cnt; }
uint n,m,maxn;
#define ls (o<<1)
#define rs ((o<<1)|1)
uint L[M],R[M],tree[M];
void build(uint o,uint l,uint r){
	L[o]=l;R[o]=r;tree[o]=newnode();
	if(l==r) return ;
	uint mid=(l+r)>>1;
	build(ls,l,mid);build(rs,mid+1,r);
}
inline uint len(uint l,uint r){ return r-l+1; }
inline uint intersect(uint a,uint b,uint c,uint d){
	int x=max(a,c),y=min(b,d);
	if(x>y) return 0;
	return y-x+1;
}
void add(uint o,uint L,uint R,uint l,uint r){
	if(L>r||R<l) return ;
	t[o].sum+=intersect(L,R,l,r);
	if(l<=L&&R<=r){ t[o].add++; return ; }
	uint mid=(L+R)>>1;
	if(t[o].lc==0) t[o].lc=newnode();
	if(t[o].rc==0) t[o].rc=newnode();
	add(t[o].lc,L,mid,l,r);
	add(t[o].rc,mid+1,R,l,r);
}
ll query(uint o,uint L,uint R,uint l,uint r,uint add=0){
	if(L>r||R<l) return 0;
// 这里涉及了 标记永久化. 如果看不懂我们之后讲解.
	if(l<=L&&R<=r) return t[o].sum+add*len(L,R);
	uint mid=(L+R)>>1;
	return query(t[o].lc,L,mid,l,r,add+t[o].add)+query(t[o].rc,mid+1,R,l,r,add+t[o].add);
}
// 外层修改,寻找单点,路径上的树进行区间加法.
void insert(uint o,uint l,uint r,uint c){
	add(tree[o],1,n,l,r);
	if(L[o]==R[o]) return ;
	uint mid=(L[o]+R[o])>>1;
	if(c<=mid) insert(ls,l,r,c);
	else 			 insert(rs,l,r,c);
}
// 线段树上二分,不做过多解释,不理解去看普通平衡树或者私信我.
// 思路和正常的平衡树上kth其实一样.
uint kth(uint o,uint l,uint r,ll k){
	if(L[o]==R[o]) return L[o];
	ll rcnt=query(tree[rs],1,n,l,r);
	if(rcnt>=k) return kth(rs,l,r,k);
	return kth(ls,l,r,k-rcnt);
}
struct B{
	int val,id;
	inline bool operator<(const B &x)const{ return val<x.val; }
}b[N];
// 我喜欢手动离散化.
void init(){
	sort(b+1,b+1+maxn);
	uint i=1,j=1;
	while(j<=maxn){
		b[i]=b[j];
		while(b[i].val==b[j].val&&j<=maxn) q[b[j++].id].c=i;
		++i;
	}maxn=i-1;
}
using namespace IO;
int main(){
// 使用了fread,不能使用键盘在console输入,必须使用文件输入.
// 打印时间太长我们重定向进文件(不然本地测试时间太长)
	//freopen("in.in","r",stdin);
	//freopen("tmp","w",stdout);
	n=gi();m=gi();
	for(register uint i=0;i<m;++i){
		q[i].opt=gi();
		q[i].l=gi();
		q[i].r=gi();
		q[i].c=gll();
		if(q[i].opt==1){ b[++maxn].val=q[i].c; b[maxn].id=i; }
	}
	init();
	build(1,1,maxn);
	for(register uint i=0;i<m;++i){
		if(q[i].opt==1) insert(1,q[i].l,q[i].r,q[i].c);
		else 						print(b[kth(1,q[i].l,q[i].r,q[i].c)].val);
	}
	flush();
	return 0;
}


```


------------

### 3.优化详解.
(这个部分可能会补充东西进来)
1. IO优化,不解释请自己找资料.没必要写这个,putchar getchar即可应对大多数情况.
2. 标记永久化.

这里是区间sum,区间add的标记永久化,标记永久化其实还能解决区间cover之类的东西,这个东西的作用是扔掉pushdown下传标记(线段树大常数一方面来自于经过节点个数是4logn的,另一方面就是两个push一个更新一个下传,后者往往影响超过前者.所以判断标记是不是空其实非常有必要)  

永久化的标记是不下穿的,而是进入子树时计算上它的贡献.
打标记只是对于选中的2logn个节点打标记,其他有修改的节点都是部分修改,直接加上贡献.  

正确性和复杂度分析略去,因为我不会. 如果需要请自行寻找.  

## 完结撒花,如果您有任何问题或者我的题解出现了任何问题(包括但不限于排版 概念错误)请及时私信联系我.





---

## 作者：shadowice1984 (赞：29)

这道题是一道非常好的入手整体二分的题

那么我们讲解一下整体二分的原理好了

## 整体二分

整体二分正如字面上讲的一样，是需要以二分为基础的

那么在使用二分法的时候需要先把原问题转化为一个**判定问题**

对于这道题，可以认为是询问

“在区间l-r中**是否**有**K**个比X大的数”

那么发现这是个我们熟悉的有**两个限制条件**的**统计问题**

思路很简单，摁死一个在解决另一个，这里是优先考虑比X大

枚举每一个修改，如果比x大就区间+1（表明这些位置都有一个比X大的数）

如果比X小就什么也不做

最后求出（l,r）的区间和即可对吧，线段树裸题


```cpp
    #include<cstdio>
    #include<algorithm>
    using namespace std;
    typedef long long ll;
    struct query//询问结构体
    {
        int id;int l;int r;ll k;int ans;int num;
        inline void prit(){printf("%d %d %d %lld\n",id,l,r,k);}
        friend bool operator <(query a,query b){return a.num<b.num;}
    }q[50010],tr[2][50010];//询问数组，辅助数组
    int cnt[2];int n;int m;
    struct linetree//线段树
    {
        ll val[200010];ll add[200010];
        inline void pushdown(int p,int l,int r)
        {
            if(r-l>1){add[2*p]+=add[p];add[2*p+1]+=add[p];}
            val[p]+=add[p]*(r-l);add[p]=0;return;
        }
        void setadd(int p,int l,int r,int dl,int dr,int plus)
        {
            if(dl==l&&dr==r){add[p]+=plus;pushdown(p,l,r);return;}
            if(add[p]!=0)pushdown(p,l,r);int mid=(l+r)/2;
            if(dl<mid)setadd(2*p,l,mid,dl,min(dr,mid),plus);
            else pushdown(2*p,l,mid);
            if(mid<dr)setadd(2*p+1,mid,r,max(dl,mid),dr,plus);
            else pushdown(2*p+1,mid,r);
            val[p]=val[2*p]+val[2*p+1];return;
        }
        ll sum(int p,int l,int r,int dl,int dr)
        {
            if(add[p]!=0)pushdown(p,l,r);
            if(dl==l&&dr==r){return val[p];}
            int mid=(l+r)/2;ll res=0;
            if(dl<mid)res+=sum(2*p,l,mid,dl,min(dr,mid));
            if(mid<dr)res+=sum(2*p+1,mid,r,max(dl,mid),dr);
            return res;
        }
        inline void cadd(int l,int r,int plus){setadd(1,0,n,l-1,r,plus);}
        inline ll csum(int l,int r){return sum(1,0,n,l-1,r);}
    }lt;
    void solve(int l,int r,int ql,int qr)//整体二分
    {
        if(r==l){for(int i=ql+1;i<=qr;i++){if(q[i].id==2)q[i].ans=r;}return;}
        int mid=(l+r+1)/2;//r=l更新答案
        for(int i=ql+1;i<=qr;i++)
        {
            if(q[i].id==1)
            {
                if(q[i].k<mid){tr[0][++cnt[0]]=q[i];}//放左边
                else {lt.cadd(q[i].l,q[i].r,1);tr[1][++cnt[1]]=q[i];}//放右边
            }else 
            {
                ll t=lt.csum(q[i].l,q[i].r);
                if(q[i].k<=t){tr[1][++cnt[1]]=q[i];}//放左边
                else {q[i].k-=t;tr[0][++cnt[0]]=q[i];}//放右边
            }
        }
        for(int i=1;i<=cnt[0];i++){q[ql+i]=tr[0][i];}//保证左右是一段连续的序列
        for(int i=1;i<=cnt[1];i++)
        {q[ql+cnt[0]+i]=tr[1][i];if(tr[1][i].id==1)lt.cadd(tr[1][i].l,tr[1][i].r,-1);}
        //撤回之前的线段树操作
        int div1=ql+cnt[0];int div2=ql+cnt[0]+cnt[1];cnt[0]=0;cnt[1]=0;
        if(ql!=div1)solve(l,mid-1,ql,div1);if(div1!=div2)solve(mid,r,div1,div2);
        //向左走，向右走
    }
    int main()
    {
        scanf("%d%d",&n,&m);
        for(int i=1;i<=m;i++){scanf("%d%d%d%lld",&q[i].id,&q[i].l,&q[i].r,&q[i].k);q[i].num=i;}
        solve(-n,n,0,m);sort(q+1,q+m+1);//由于整体二分会打乱顺序，最后还需排序后输出
        for(int i=1;i<=m;i++){if(q[i].id==2)printf("%d\n",q[i].ans);}return 0;
    }
```
当然这只能求一个询问，我们面对的是多组修改和查询
这里就是分治法的精髓了

发现修改-查询之间关系的本质就是

查询=合并**时间在该查询之前**的所有修改

也就是说我们可以不用考虑精确的时间，而是只要保证**有效**修改在查询之前就好

具体来讲，整体二分将所有询问分为**左侧有用**和**右侧有用**两个集合

**递归**的处理这两个集合，同时不断的缩小答案区间，得出答案

//讲了一堆玄学

对于这道题

考虑现在正在二分的答案是X

然后我们有一个询问是问K1大，另一个是K2大

发现K1小于查出来的区间和，k2大于查出来的区间和

那么是不是X大了以后，K2还是会超，X小了以后，K1肯定更小？

那么二分就需要同时向两个方向走，向左走（x减小）处理K2,向右走处理K1

我们现在又有一个修改插入V1,还有一个修改插入V2

v1大于x,而v2小于x

那么X大了以后，v2肯定还没用，x小了以后，V1一定被统计到

所以二分向左走的时候处理v2，向右走时候处理v1

同时，向左走的时候给对应的查询减去一个当前区间和，为了统计到一定会被统计的V1

现在考虑这样的操作序列

C1，c2,a1,a2（继续上面的样例）

那么二分向左走处理的是：C2,A2

向右走处理的是：C1，A1

发现C2被“抽走了”，但是抽走的是无效的操作

这就是整体二分啦

每次整体二分都会往两个方向走，一个X减小，X增大

之后根据一些规则，判断哪些操作流向左边，那些操作流向右边

同时每次保证流向左边和右边的操作都是相对有序的

我们抽去的东西，全部是无效操作，要么一定执行，要么一定不执行

当二分的答案只有一个取值时，更新答案就好了


我们发现，刚才的过程实际上在**时间维度**上形成了**一颗决策树**，树上的每一个**节点**对应一个**操作集合**，每个操作集合需要对**线段树**操作，其实是**另一种版本的树套树**

和dp的滚动数组优化类似，dp是用**时间维置换**了一个真实的**数组维**

而整体二分，则是用时间上生成的**“决策树”置换**了一颗真实的**外层树**


下面是一些实现的细节，我们每次将左边操作集合和右边操作集合存在两个数组里

之后把他们贴到原来的操作区间上，保证左边操作和右边操作是连续的一段区间

这样的话，左右区间的相对无序并不会影响答案，因为他们互不相关了

上代码~






---

## 作者：SSerxhs (赞：23)

~~树套树大法吼啊~~

类似于dynamic rankings，只是单点修改变成了区间修改，同样可以使用树状数组套主席树的方法解决，复杂度O(nlog^2 n)

单点最大500ms-，~~被整体二分50ms-吊起来锤~~

```cpp
// luogu-judger-enable-o2
#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N=5e4+2,M=3e7+2;
int c[M][2],rt[N],xrt[N],a[N],b[N];
int dr,n,m,i,j,x,y,fh,gs,ggs,pos,ds,dt,st1[N],st2[N],st3[N],st4[N];
ll s[M],z,ddr,op[N][4],tp1,tp2,tp3,tp4;
inline int lb(int x)
{
    return x&(-x);
}
inline ll read()
{
    dr=getchar();fh=1;
    while ((dr<48)||(dr>57))
    {
        if (dr=='-') fh=-1;
        dr=getchar();
    }
    ddr=dr^48;dr=getchar();
    while ((dr>=48)&&(dr<=57))
    {
        ddr=ddr*10+(dr^48);
        dr=getchar();
    }
    return ddr*fh;
}
void build(int &now,int pre,int l,int r)
{
    s[now=++ds]=s[pre]+dt;
    if (l==r) return;
    if (pos<=l+r>>1)
    {
        c[now][1]=c[pre][1];
        build(c[now][0],c[pre][0],l,l+r>>1);
    }
    else
    {
        c[now][0]=c[pre][0];
        build(c[now][1],c[pre][1],(l+r>>1)+1,r);
    }
}
void sol()
{
    int l=1,r=gs;
    ll sum;
    while (l<r)
    {
        sum=0;
        for (j=1;j<=tp1;j++) sum-=op[i][1]*s[c[st1[j]][1]];
        for (j=1;j<=tp2;j++) sum+=(op[i][2]+1)*s[c[st2[j]][1]];
        for (j=1;j<=tp3;j++) sum+=s[c[st3[j]][1]];
        for (j=1;j<=tp4;j++) sum-=s[c[st4[j]][1]];
        if (sum>=op[i][3])
        {
            for (j=1;j<=tp1;j++) st1[j]=c[st1[j]][1];
            for (j=1;j<=tp2;j++) st2[j]=c[st2[j]][1];
            for (j=1;j<=tp3;j++) st3[j]=c[st3[j]][1];
            for (j=1;j<=tp4;j++) st4[j]=c[st4[j]][1];
            l=(l+r>>1)+1;
        }
        else
        {
            for (j=1;j<=tp1;j++) st1[j]=c[st1[j]][0];
            for (j=1;j<=tp2;j++) st2[j]=c[st2[j]][0];
            for (j=1;j<=tp3;j++) st3[j]=c[st3[j]][0];
            for (j=1;j<=tp4;j++) st4[j]=c[st4[j]][0];
            op[i][3]-=sum;
            r=l+r>>1;
        }
    }
    printf("%d\n",b[l]);
}
int main()
{
    n=read();m=read();
    for (i=1;i<=m;i++)
    {
        op[i][0]=read();op[i][1]=read();op[i][2]=read();op[i][3]=read();
        if (op[i][0]==1) a[++ggs]=op[i][3];
    }
    sort(a+1,a+ggs+1);
    b[gs=1]=a[1];
    for (i=2;i<=ggs;i++) if (a[i]!=a[i-1]) b[++gs]=a[i];
    for (i=1;i<=m;i++)
    {
        if (op[i][0]==1)
        {
            pos=lower_bound(b+1,b+gs+1,op[i][3])-b;
            dt=1;
            for (j=op[i][1];j<=n;j+=lb(j)) build(rt[j],rt[j],1,gs);
            dt=op[i][1];
            for (j=op[i][1];j<=n;j+=lb(j)) build(xrt[j],xrt[j],1,gs);
            dt=-1;
            for (j=op[i][2]+1;j<=n;j+=lb(j)) build(rt[j],rt[j],1,gs);
            dt=-(op[i][2]+1);
            for (j=op[i][2]+1;j<=n;j+=lb(j)) build(xrt[j],xrt[j],1,gs);
        }
        else
        {
            tp1=tp2=tp3=tp4=0;
            for (j=op[i][1]-1;j;j-=lb(j)) st1[++tp1]=rt[j];
            for (j=op[i][2];j;j-=lb(j)) st2[++tp2]=rt[j];
            for (j=op[i][1]-1;j;j-=lb(j)) st3[++tp3]=xrt[j];
            for (j=op[i][2];j;j-=lb(j)) st4[++tp4]=xrt[j];
            sol();
        }
    }
}
```

---

## 作者：x义x (赞：19)

题目传送门：

### [P3332 [ZJOI2013]K大数查询](https://www.luogu.org/problemnew/show/P3332)

~~mmp刚看到这一题以为每个位置只有一个元素，操作是区间加，心想这怎么可能可做~~

本题解介绍暴力的树状数组套权值线段树做法。

首先我们来回顾一下这题：

### [P2617 Dynamic Rankings](https://www.luogu.org/problemnew/show/P2617)

区间第K大，单点修改为一个值。

这道题的树状数组套权值线段树做法的核心思想是，搞出一个权值线段树然后在上面二分：左子区间元素太少就到右边找，左子区间元素$\ge k$就进入左子区间找。

而树状数组和权值线段树的意义就是通过“前缀和”相减得出“区间和”的方式，得出这样一棵权值线段树。树状数组的每个元素都是一棵权值线段树，按照和不套东西的树状数组一模一样的方式把一些权值线段树加起来就能得到“前缀和”。

此题的区别在于需要区间加。~~因为树状数组好写得多了所以我选择使用树状数组而不是线段树来套权值线段树。~~众所周知，不套什么奇奇怪怪的树状数组处理这种问题的方式是使用差分：

记

$$b[i]=a[i]-a[i-1]\quad(a[0]=0)$$

则

$$a[1]+a[2]+...+a[n]=n*b[1]+(n-1)*b[2]+...+b[n]$$

等于

$$(n+1)*(b[1]+b[2]+...+b[n])-(1*b[1]+2*b[2]+...+n*b[n])$$

$b[1]+b[2]+...+b[n]$和$1*b[1]+2*b[2]+...+n*b[n]$都可以用树状数组维护，而套了权值线段树的树状数组和这个的处理方式真的是完全一致。只需要按照树状数组给出的对应的权值线段树上操作即可。

下面是代码。实际写起来是有一些需要注意的细节的。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

const int maxN=50005;

int N,M,n;
int Rot[2][maxN];
ll sum[maxN*400];int lc[maxN*400],rc[maxN*400],idx;
//空间尽量开大 
int Update(int x,int l,int r,int pos,int K){
	if(!x) x=++idx;
	sum[x]+=K;
	if(l!=r){
		int mid=(l+r)>>1;
		if(pos<=mid) lc[x]=Update(lc[x],l,mid,pos,K);
		else rc[x]=Update(rc[x],mid+1,r,pos,K);
	}
	return x;
}

int stk[4][25],len[4];
int Query(int l,int r,ll K){
	len[0]=len[1]=len[2]=len[3]=0;
	for(int x1=l-1;x1;x1-=x1&-x1) stk[0][++len[0]]=Rot[0][x1];
	for(int x1=l-1;x1;x1-=x1&-x1) stk[1][++len[1]]=Rot[1][x1];
	for(int x1=r;x1;x1-=x1&-x1) stk[2][++len[2]]=Rot[0][x1];
	for(int x1=r;x1;x1-=x1&-x1) stk[3][++len[3]]=Rot[1][x1]; 
	int L=1,R=n,mid;ll SUM;
	while(L<R){
		mid=(L+R)>>1;
		SUM=0;
		for(int i=1;i<=len[0];i++) SUM-=1LL*l*sum[rc[stk[0][i]]];
		for(int i=1;i<=len[1];i++) SUM+=sum[rc[stk[1][i]]];
		for(int i=1;i<=len[2];i++) SUM+=1LL*(r+1)*sum[rc[stk[2][i]]];
		for(int i=1;i<=len[3];i++) SUM-=sum[rc[stk[3][i]]];
		//注意上方加减号！细节*1 
		if(SUM>=K){
			for(int i=1;i<=len[0];i++) stk[0][i]=rc[stk[0][i]];
			for(int i=1;i<=len[1];i++) stk[1][i]=rc[stk[1][i]];
			for(int i=1;i<=len[2];i++) stk[2][i]=rc[stk[2][i]];
			for(int i=1;i<=len[3];i++) stk[3][i]=rc[stk[3][i]];
			L=mid+1;
		}
		else{
			for(int i=1;i<=len[0];i++) stk[0][i]=lc[stk[0][i]];
			for(int i=1;i<=len[1];i++) stk[1][i]=lc[stk[1][i]];
			for(int i=1;i<=len[2];i++) stk[2][i]=lc[stk[2][i]];
			for(int i=1;i<=len[3];i++) stk[3][i]=lc[stk[3][i]];
			R=mid;
			K-=SUM;
		}
		//注意上方跳儿子时的判断。K的含义是第K大而不是第K小！细节*2 
	}
	return L;
}

int main(){
	scanf("%d%d",&N,&M);n=2*N+1;
	//懒得离散化了 
	while(M--){
		int opt,l,r;scanf("%d%d%d",&opt,&l,&r);
		if(opt==1){
			int c;scanf("%d",&c);c+=N+1;
			for(int x1=l;x1<=N;x1+=x1&-x1)
				Rot[0][x1]=Update(Rot[0][x1],1,n,c,1);
			for(int x1=l;x1<=N;x1+=x1&-x1)
				Rot[1][x1]=Update(Rot[1][x1],1,n,c,l);
			for(int x1=r+1;x1<=N;x1+=x1&-x1)
				Rot[0][x1]=Update(Rot[0][x1],1,n,c,-1);
			for(int x1=r+1;x1<=N;x1+=x1&-x1)
				Rot[1][x1]=Update(Rot[1][x1],1,n,c,-r-1);
		}
		else{
			ll c;scanf("%lld",&c);
			printf("%d\n",Query(l,r,c)-N-1);
		}
	}
	
	return 0;
}

```


---

## 作者：complexly (赞：16)

### 大家好，我很喜欢暴力数据结构，所以我用分块做了这道题。

（ 严格 $O(n \sqrt n)$ ）。

这题有三种做法：

1.平衡树套线段树

2.线段树套线段树

3.整体二分

但是，我们使用第四种，**分块**

--------------

首先，序列分块，值域分块。

对于这种有二分性质的东西，分块一般有一个其他的做法：

- 先跳值域块，跳到头之后跳散块。

基于这个思路，我们需要 $O(1)$ （或者均摊 $\sqrt n$ ）知道一个值域块内的数的出现次数或一个数的出现次数，（下文中用 $B$ 表示序列块长， $V$ 表示值域块长）。

#### 数列整块对值域整/散块的贡献

维护什么？

1.  $col_{i,j}$ ，表示在第 $1$ 块到 $i$ 块数字 $j$ 的出现次数。
2.  $blockcol_{i,j}$ ，表示在第 $1$ 块到 $i$ 块有多少数字在第 $j$ 值域整块内。

如何维护？

1.  $col_{i,j}$ ，后缀加，$O(\frac n B)$。
2.  $blockcol_{i,j}$ ，后缀加，$O(\frac n B)$。

怎么计算？

1.  $col_{i,j}$ ，查数列整块对值域**散块**的贡献（查数列上第 $l$ 块到 $r$ 块中数字 $j$ 的出现次数），$O(1)$。
2.  $blockcol_{i,j}$ ，查数列整块（差分）对值域**整块**的贡献（查数列上第 $l$ 块到 $r$ 块中有多少数字在值域整块 $j$ 内），$O(1)$。

#### 数列散块对值域整块的贡献

维护什么？

1. $sum_{i,j,k}$ 表示在第 $i$ 个序列整块，前 $j$ 个位置的有多少数字在第 $k$ 个值域整块内。
2. $blocktag_{i,j}$ 表示第 $i$ 个序列整块**整体**加了多少次值在值域块 $j$ 内的数字 。
3. $tag_{i,j}$ 表示第 $i$ 个序列整块**整体**加了多少次数字 $j$ （这是数列散块对值域散块的贡献，顺带写在这里了，可以无视）。

如何维护？

1.  $sum_{i,j,k}$ ，只重构散块， $O(B)$。
2.  $blocktag_{i,j}$ ，对于区间内整块修改， $O(\frac n B)$。
3.  $tag_{i,j}$ ，对于区间内整块修改， $O(\frac n B)$。

怎么计算？

1.  $sum_{i,j,k}$ ，查数列散块对值域**整块**的贡献（不管整块修改也就是不管tag的贡献），$O(1)$。
2.  $blocktag_{i,j}$ ，查数列散块对值域**整块**的贡献（单独计算整块修改的贡献），$O(1)$。
3.  $tag_{i,j}$ ，查数列散块对值域**散块**的贡献（单独计算整块修改的贡献），$O(1)$。

#### 数列散块对值域散块的贡献

维护什么？

1. $tag_{i,j}$ ， 表示第 $i$ 个序列整块**整体**加了多少次数字 $j$ 。
2. $pre_{i,j,k}$ ， 表示第 $i$ 个序列整块，前 $k$ 个位置的有多少数字值为 $j$ 。（动态开点）

如何维护？

1. $tag_{i,j}$ ，对于区间内整块修改， $O(\frac n B)$。
2. $pre_{i,j,k}$ ，只重构散块， $O(B)$。

怎么计算？

1.  $pre_{i,j,k}$ ，查数列散块对值域**散块**的贡献（不管整块修改也就是不管tag的贡献），$O(1)$。
2.  $tag_{i,j}$ ，查数列散块对值域**散块**的贡献（单独计算整块修改的贡献），$O(1)$。

没了，太好了！！

注：代码中用了一个很愚蠢的方式实现上文的 $pre$ 数组，具体一点，就是在值域块用vector内存储操作，累积到 $V$ 个操作的时候的时候就重构整个块，至于排序，暴力插入，因为 $size \le V$ 所以不会爆炸。

~~~
#include<bits/stdc++.h>
// #define int long long
#define f(i , l , r) for(register int i = (l);i <= (r);++ i)
#define d(i , l , r) for(register int i = (r);i >= (l);-- i)
#define pii pair<int,int>
#define pb push_back
#define fi first
#define sc second
#define lowbit(x) ((x)&-(x))
#define fre(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout)
using namespace std;
const int N = 1e5 + 10 , B = 1000 , V = 1000;
int n , m , pre[N/V*2+4][B+4][V+4] , block_tag[N/B+4][N/V+4] , tag[N/B+4][N];
long long sum[N/V+4][N] , col[N/B+4][N] , block_col[N/B+4][N/V+4];
int bv[N] , bl[N] , L[N] , R[N] , Lv[N] , Rv[N];
int flg[N/B+4][N/V+4] , res;
vector<pii>vec[N/B+4][N/V+4];
inline void rebuild(int b,int v,int len){
    flg[b][v] = ++res;
    int id = flg[b][v];
    // cout << "rebuild : \n";
    for(pii u : vec[b][v]){
        int lm = abs(u.sc) , op = (u.sc < 0 ? -1 : 1);
        f(i , 0 , len)pre[id][i][u.fi] += op * min(i + 1 , lm);
        // cerr << u.fi << " " << abs(u.sc) << " " << u.sc / abs(u.sc) << "\n";
    }
    vec[b][v].clear();
    // f(c , 1 , V){
    //     f(i , 0 , len)cerr << pre[id][i][c] << " ";
    //     cerr << "\n";
    // }
}
inline void insert(int x,int y,int op){
    int b = bl[x] , v = bv[y];
    int up = x - L[b] , c = y - Lv[v] + 1 , len = R[b] - L[b];
    d(i , L[b] , R[b])sum[v][i] += (1 + min(i - L[b] , up)) * op;
    if(flg[b][v]){
        int id = flg[b][v];
        d(i , 0 , len)pre[id][i][c] += op * (1 + min(i , up));
    }
    else {
        pii u = (pii){c , op * (up + 1)};
        int p = lower_bound(vec[b][v].begin() , vec[b][v].end() , u) - vec[b][v].begin();
        vec[b][v].insert(vec[b][v].begin() + p , u);
        if(vec[b][v].size() > V)rebuild(b , v , len);
    }
}
inline void change_color(int l,int r,int x){
    int lb = bl[l] , rb = bl[r] , v = bv[x];
    // cout << l << 
    d(i , lb , bl[n]){
        col[i][x] += min(r , R[i]) - l + 1;
        block_col[i][v] += min(r , R[i]) - l + 1;
    }
}
inline void input(int l,int r,int x){
    int lb = bl[l] , rb = bl[r] , v = bv[x];
    change_color(l , r , x);
    f(i , lb , rb - 1)tag[i][x] ++ , block_tag[i][v] ++;
    if(l > L[lb])insert(l - 1 , x , -1);
    insert(r , x , 1);
}
inline int query(int l,int r,int k){
    int lst = 0;
    int lb = bl[l] , rb = bl[r];
    d(i , 1 , bv[n]){
        long long sum1 = block_col[rb-1][i] - block_col[lb-1][i];
        long long sum2 = 0;
                      sum2 += (block_tag[rb][i] * (r - L[rb] + 1) + sum[i][r]);
        if(l > L[lb]) sum2 -= (block_tag[lb][i] * (l - L[lb]) + sum[i][l-1]);
        lst = i;
        if(k <= sum1 + sum2)break;
        k -= sum1 + sum2;
    }
    // cerr << lst << " " << k << '\n';
    // if(vec[lb][lst].size > V)rebuild(lb , lst);
    // if(vec[rb][lst].size > V)rebuild(rb , lst);
    int id1 = flg[lb][lst] , id2 = flg[rb][lst] , p1 = vec[lb][lst].size() - 1 , p2 = vec[rb][lst].size() - 1;
    d(i , Lv[lst] , Rv[lst]){
        long long sum1 = col[rb-1][i] - col[lb-1][i];
        long long sum2 = tag[rb][i] * (r - L[rb] + 1) - tag[lb][i] * (l - L[lb]);
        if(id2)sum2 += pre[id2][r-L[rb]][i-Lv[lst]+1];
        else {
            while(p2 >= 0 && vec[rb][lst][p2].fi + Lv[lst] - 1 >= i){
                int op = (vec[rb][lst][p2].sc > 0 ? 1 : -1);
                sum2 += op * min(abs(vec[rb][lst][p2].sc) , r - L[rb] + 1) , p2 --;
                // cout << op << "\n";
            }
        }
        // cout << i << " " << sum2 << "\n";
        // if(l == 103 && r == 233)cout << i << " " << sum2 << " " << sum1 << "\n";
        if(id1 && l > L[lb])sum1 -= pre[id1][l-L[lb]-1][i-Lv[lst]+1];
        else if(l > L[lb]){
            while(p1 >= 0 && vec[lb][lst][p1].fi + Lv[lst] - 1 >= i){
                int op = (vec[lb][lst][p1].sc > 0 ? 1 : -1);
                sum2 -= op * min(abs(vec[lb][lst][p1].sc) , l - L[lb]) , p1 --;
            }
        }
        // if(l == 103 && r == 233)cout << i << " " << sum2 << " " << sum1 << "\n";
        if(k <= sum1 + sum2)return i;
        k -= sum1 + sum2;
    }
    return 0;
}
signed main(){
    ios_base::sync_with_stdio(0);
    cin.tie(0) , cout.tie(0);
    cin >> n >> m , n *= 2;
    f(i , 1 , n)bl[i] = (i - 1) / B + 1 , bv[i] = (i - 1) / V + 1;
    f(i , 1 , n)R[bl[i]] = i , Rv[bv[i]] = i;
    d(i , 1 , n)L[bl[i]] = i , Lv[bv[i]] = i;
    f(i , 1 , m){
        int op , l , r , c;
        cin >> op >> l >> r >> c;
        if(op == 1)input(l , r , c + n/2);
        if(op == 2)cout << query(l , r , c) - n/2 << "\n";
        // C();
    }
// int n , m , col[N/B+4][N] , block_col[N/B+4][N/V+4] , pre[N/V+4][B+4][V+4] , block_tag[N/B+4][N/V+4] , tag[N/B+4][N] , sum[N/V+4][N];
}
~~~

块长随便取，怎么都能过。

什么？你说这时间不如整体二分，空间还大？

那要是我强制在线，时限 300ms，阁下又该如何应对呢？

---

## 作者：hht2005 (赞：12)

第三次提交了，前面都有一些错误，如果前面合格了，这一次直接让过吧。

[my blog](https://www.cnblogs.com/hht2005/p/11421235.html)

# 题目大意

重新讲一下含糊不清的题意：

有n个可重集合，有m个操作，操作分为两种：
* 1 l r c 给第l到第r个可重集合都加入一个数c。
* 2 l r c 询问第l到第r个可重集合第c大的数是多少。

$n\le 50000,m\le 50000,1\le l\le r\le n$，1中的$|c|\le n$，2中的$c\le long\space long$
# sol
## 暴力
给每一个点开一个`vector`暴力插入，询问时将l到r的数暴力排一个序。时间复杂度：$\Theta(n^3\log n)$。

基于暴力，我们可以用树套树来做。
## 二分
对与每个询问，我们可以在-n到n之间二分，二分出一个mid后，我们暴力扫一遍所有在它之前的插入，统计出l到r中有多少个数大于mid，如果大于mid的数大于c，说明我们二分小了，反之说明我们二分大了。

时间复杂度：$\Theta(n^2\log n)$

## 整体二分
整体二分顾名思义就是所有的询问一起二分。其实在单次二分时，我们得出了很多有用信息，对之后的询问依然有用，所以我们可把所有询问一起二分。

二分思路就在上面。下面讲一些不一样的地方。

我们先新开出一个区间和两个数组，第一个数组存要向小二分的操作，第二个数组存要向大二分的操作。

在整体二分时，我们二分出了一个mid，依次扫过每一个操作：
1. 插入，讨论它的c值，如果大于mid，就在新区间的l到r加一，把它扔到第二个数组，否则扔到第一个数组。
2. 查询，令num等于新区间l到r的值之和，则num就等于l到r大于mid的数的个数。如果num小于c，则c-=num，把操作扔到第一个数组里，否则扔到第二个数组。

最后，递归处理两个数组。

证明一下这样做的正确性：

查询时，如果c大于num，那么对num产生贡献的插入都会和它到不同的数组中，以后不会再产生贡献。但由于我们往小二分，那些插入实际上是会对它产生贡献的，所以我们现在就要把贡献记下来，实际操作就是减去num。如果c小于num，那么对num产生贡献的插入都会和它到相同的数组中，没有问题。

插入操作其实是随着查询操作来的，查询没错它就没错。

对于新区间的区间修改，区间查询，树状数组或线段树即可。

时间复杂度：$\Theta(n\log^2 n)$

还有一些细节和优化都在代码注释里。

**code:**
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=50010;
int n,m;
ll ans[maxn];
struct BIT {//树状数组
	ll c[maxn];
	inline void add(int x,int y) {
		for(int i=x; i<=n; i+=i&-i)c[i]+=y;
	}
	inline ll sum(int x) {
		ll ans=0;
		for(int i=x; i; i-=i&-i)ans+=c[i];
		return ans;
	}
} a,b,c;
struct node {//操作的结构体
	int tp,l,r,id;
	ll c;
} q[maxn],tem1[maxn],tem2[maxn];//tem为两新数组
void solve(int x,int y,int l,int r) {//整体二分
	if(l==r) {//找到答案
		for(int i=x; i<=y; i++)
			ans[q[i].id]=l;
		return;
	}
	int mid=(l+r)>>1,cnt1=0,cnt2=0;
	for(int i=x; i<=y; i++)
		if(q[i].tp==2) {//查询
			ll num=q[i].r*a.sum(q[i].r)-b.sum(q[i].r)-(q[i].l-1)*a.sum(q[i].l-1)+b.sum(q[i].l-1);
			if(num<q[i].c) {
				q[i].c-=num;
				tem1[++cnt1]=q[i];
			} else tem2[++cnt2]=q[i];
		} else {//插入
			if(q[i].c>mid) {
				a.add(q[i].l,1),a.add(q[i].r+1,-1);
				b.add(q[i].l,q[i].l-1),b.add(q[i].r+1,-q[i].r);
				tem2[++cnt2]=q[i];
			} else tem1[++cnt1]=q[i];
		}
	for(int i=x; i<=y; i++)//清空树状数组，不能用memset，否则时间会爆炸
		if(q[i].tp==1&&q[i].c>mid) {
			a.add(q[i].l,-1),a.add(q[i].r+1,1);//照样减回去
			b.add(q[i].l,-q[i].l+1),b.add(q[i].r+1,q[i].r);
		}
	for(int i=1; i<=cnt1; i++)q[x+i-1]=tem1[i];//滚动一下优化空间
	for(int i=1; i<=cnt2; i++)q[x+cnt1+i-1]=tem2[i];
	if(cnt1)solve(x,x+cnt1-1,l,mid);//分别去二分
	if(cnt2)solve(x+cnt1,y,mid+1,r);
}
int main() {
	scanf("%d%d",&n,&m);
	int Q=0;
	for(int i=1; i<=m; i++) {
		scanf("%d%d%d%lld",&q[i].tp,&q[i].l,&q[i].r,&q[i].c);
		if(q[i].tp==2)q[i].id=++Q;
	}
	solve(1,m,-n,n);
	for(int i=1; i<=Q; i++)
		printf("%lld\n",ans[i]);
	return 0;
}
```
# 总结
整体二分不能在线，时间复杂度其实和树套树一样。但它代码短，常数小，还是挺有用的一个算法。

---

## 作者：Oxide (赞：8)

[toc]

# 题目

[传送门](https://www.luogu.com.cn/problem/P3332)

这里的加入是把每个元素看成一个集合！！！

# 解法

$\sf{FBI\ Warning}$：最好先跳到 "我 没 学 懂" 板块开始看，不然你可能会被我绕进去。

---

这道题主要是讲一下 **整体二分**。

整体二分顾名思义，就是有一坨数，规定一个 $\text{mid}$ 进行二分 ~~（好像一点也不清楚）~~。

思考一下普通的二分，我们其实是帮助 **一个数值** $ans$ 选择一个合适的值。整体二分就是帮助很多个数值选择一个合适的值。

接下来说一下算法流程吧。

对值域进行二分。我们定义两个序列 $L$ 与 $R$，分别向下递归至 $[l,\text{mid}],[\text{mid}+1,r]$。对于此题我们的 $\text{mid}$ 就是 **假定** 第 $C$ 大的数，那么对于这次遍历大于 $\text{mid}$ 的数就是能对结果产生影响的，设目前为止大于 $\text{mid}$ 的数的个数为 $num$。

首先我们的时间戳是有序的，这个就不用排序了。对于每个询问与插入，我们可以进行分类讨论。

- 操作为询问，$num$ 小于询问要求的 $C$。这说明我们把 $mid$ 的值调大了，我们将 $C$ 减去 $num$，再在 $[l,mid]$ 中选择新值（即插入 $L$）。（**注意这里的 $mid$ 是可以取到的，因为判断条件是 $num < C$**）
- 操作为询问，$num$ 大于等于要求的 $C$。我们先前判断用的是**严格大于**才加入树状数组，所以等于的情况不会触及 $mid$。从 $[mid+1,r]$ 中找就行了。
- 操作为插入，$C>mid$。这种权值插入 $R$，再在树状数组中更新就行了。
- 操作为插入，$C\le mid$。这种权值显然不能贡献 $[mid+1,r]$ 的 $mid'$，插入 $L$ 就行了。

------

$\text{Update on 2021.2.16}$：

我之前写了个啥，~~我怎么这么幼稚~~。

这题需要维护区间加和区间和。树状数组是单点加，为了保证时间复杂度容易想到差分的思想。

然后可以看看 [我的另一篇博客](https://www.cnblogs.com/AWhiteWall/p/12787417.html)，讲了树状数组怎么维护。

------

看到树状数组也许你看不懂 ~~（当然你可以写线段树，比树状数组好理解得多，我是因为我是 $250$ 才会去做的 $QwQ$）~~，接下来我会详细讲解树状数组，如果没有看懂可以私信或评论哟！ ~~（蒟蒻求赞）~~

先来一张图（这个可以结合代码观看，这个部分感觉网上有些代码可能有问题就比如我看的那份树状数组代码）：

![](https://img2020.cnblogs.com/blog/1889894/202005/1889894-20200506220334011-2021660189.png)

我们在 $2$ 这个节点加了 $1$ 这个数值，用另一个数组加了 $2-1=1$ 这个数值。

接下来假设我们 $ask(x=5)$。因为这相当于是一个前缀和：对于 $c1[]$，记录的就是在 $[1,x]$ 之间有多少个添加的 $1$（注意这里也可以改成 $-1$，这个部分我就不讲了，一通百通）。而对于 $c2[]$，记录的就是每个位置上被添加的次数 $*$ （位置 $ - 1$）（**注意这里的两个数组已经完成 $ask$ 中的累加**）。

那么 $\sum c1*x-\sum c2$ 对应在图上就是一条长的橙色的线段减去短的橙色的线段，正好就是黄色的线段：这个 $1$ 到 $x$ 之间的位置个数。

总结一下：这个 $ask$ 函数返回的值就是 $x$ 与之前每个位置的距离 $*$ 这个位置被添加 $1$ 的个数。



好的我们再放一张图，来解释最终的答案。

![](https://img2020.cnblogs.com/blog/1889894/202005/1889894-20200506223358361-1552121530.png)

$ask(L-1)=5-2+1=4$，$ask(R)=(8-2+1)+(8-7+1)=9$。

相减即为所求：在 $[L,R]$ 区间内大于 $mid$ 的数的个数。

我竟然写完了 $QwQ$（希望不要被布布扣转载小声哔哔）。

# 代码

```cpp
#include <cstdio>
#define int long long

const int N = 5e4 + 5;
int n, m, p[N], ans[N], op[N], l[N], r[N], c1[N], c2[N], c[N], lef[N], rig[N];

int read() {
    int x = 0, f = 1; char s;
    while((s = getchar()) < '0' || s > '9') if(s == '-') f = -1;
    while(s >= '0' && s <= '9') {x = (x << 1) + (x << 3) + (s ^ 48); s = getchar();}
    return x * f;
}

int lowbit(const int x) {return x & -x;}

void add(const int x, const int k) {
    for(int i = x; i <= n; i += lowbit(i))
        c1[i] += k, c2[i] += k * (x - 1);
}

int ask(const int x) {
    int r = 0;
    for(int i = x; i; i -= lowbit(i))
        r += c1[i] * x - c2[i];
    return r;
}

void cdq(const int L, const int R, const int down, const int up) {
    if(L > R || down > up) return;
    if(down == up) {for(int i = L; i <= R; ++ i) ans[p[i]] = up; return;}
    int mid = up + down >> 1; int lenl = 0, lenr = 0;
    for(int i = L; i <= R; ++ i) {
        int pos = p[i];
        if(op[pos] & 2) {
            int num = ask(r[pos]) - ask(l[pos] - 1);
            if(num < c[pos]) lef[++ lenl] = pos, c[pos] -= num;
            else rig[++ lenr] = pos;
        }
        else {
            if(c[pos] > mid) add(l[pos], 1), add(r[pos] + 1, -1), rig[++ lenr] = pos;
            else lef[++ lenl] = pos;
        }
    }
    for(int i = 1; i <= lenl; ++ i) p[L + i - 1] = lef[i];
    for(int i = 1; i <= lenr; ++ i) {
        p[L + i + lenl - 1] = rig[i];
        if(op[p[L + i + lenl - 1]] & 1) add(l[p[L + i + lenl - 1]], -1), add(r[p[L + i + lenl - 1]] + 1, 1);
    }
    cdq(L, L + lenl - 1, down, mid); cdq(L + lenl, R, mid + 1, up);
}

signed main() {
    n = read(), m = read();
    for(int i = 1; i <= m; ++ i)
        p[i] = i, op[i] = read(), l[i] = read(), r[i] = read(), c[i] = read();
    cdq(1, m, -n, n);
    for(int i = 1; i <= m; ++ i)
        if(op[i] & 2) printf("%lld\n", ans[i]);
    return 0;
}
```

# 我 没 学 懂

是这样的，在考场上又写挂了。

有一个更易理解的方法：二分 $\text{mid}$，将比它大的数加入线段树。查询时询问区间内大于 $\text{mid}$ 的数的个数，如果 $c\le \text{Query}$，那么这个值就应该在 $[\text{mid}+1,r]$ 之间。

关于复杂度，每一层都有 $m+q$ 个操作，一共有 $\log n$ 层，一次操作是 $\mathcal O(\log n)$ 的，所以总复杂度是 $\mathcal O((m+q)\cdot \log^2 n)$ 哒！

```cpp
#include <cstdio>
#define rep(i,_l,_r) for(signed i=(_l),_end=(_r);i<=_end;++i)

typedef long long ll;
const int maxn=5e4+5;

int n,m,tag[maxn<<2];
bool is[maxn];
ll t[maxn<<2],ans[maxn];
struct node {int l,r,op,id; ll c;} s[maxn],tl[maxn],tr[maxn];

void pushDown(int o,int l,int r) {
	if(!tag[o]) return;
	int mid=l+r>>1;
	tag[o<<1]+=tag[o],tag[o<<1|1]+=tag[o];
	t[o<<1]+=1ll*(mid-l+1)*tag[o],t[o<<1|1]+=1ll*(r-mid)*tag[o];
	tag[o]=0;
}

void pushUp(int o) {t[o]=t[o<<1]+t[o<<1|1];}

ll Query(int o,int l,int r,int L,int R) {
	if(l>R || r<L) return 0;
	if(l>=L && r<=R) return t[o];
	int mid=l+r>>1;
	pushDown(o,l,r);
	return Query(o<<1,l,mid,L,R)+Query(o<<1|1,mid+1,r,L,R);
}

void modify(int o,int l,int r,int L,int R,int k) {
	if(l>R || r<L) return;
	if(l>=L && r<=R) return (void)(tag[o]+=k,t[o]+=1ll*(r-l+1)*k);
	int mid=l+r>>1;
	pushDown(o,l,r);
	modify(o<<1,l,mid,L,R,k),modify(o<<1|1,mid+1,r,L,R,k);
	pushUp(o);
}

void dicon(int l,int r,int ql,int qr) {
	if(ql>qr || l>r) return;
	if(l==r) {
		rep(i,ql,qr) ans[s[i].id]=l;
		return;
	}
	int mid=l+r>>1,totl=0,totr=0; ll tmp;
	rep(i,ql,qr)
		if(s[i].op==1) {
			if(s[i].c>mid) modify(1,1,n,s[i].l,s[i].r,1),tr[++totr]=s[i];
			else tl[++totl]=s[i];
		}
		else {
			tmp=Query(1,1,n,s[i].l,s[i].r);
			if(s[i].c<=tmp) tr[++totr]=s[i];
			else s[i].c-=tmp,tl[++totl]=s[i];
		}
	rep(i,1,totl) s[ql+i-1]=tl[i];
	rep(i,1,totr) {
		s[ql+totl+i-1]=tr[i];
		if(tr[i].op==1) modify(1,1,n,tr[i].l,tr[i].r,-1);
	}
	dicon(l,mid,ql,ql+totl-1),dicon(mid+1,r,ql+totl,ql+totl+totr-1);
}

signed main() {
	scanf("%d %d",&n,&m);
	rep(i,1,m) scanf("%d %d %d %lld",&s[i].op,&s[i].l,&s[i].r,&s[i].c),s[i].id=i,is[i]=(s[i].op==2);
	dicon(-n,n,1,m);
	rep(i,1,m) if(is[i]) printf("%lld\n",ans[i]);
	return 0;
}
```

---

## 作者：DAMDAM (赞：7)

有一种经典的权值线段树套区间线段树的做法。

对于外层权值线段树，将一个数加入进线段树时对相对应的内层线段树区间加 $1$。

查询第 $k$ 大数可以外层权值线段树上对内层区间数值个数二分。

那么看到这个做法，我不禁想到可不可以把权值线段树换成权值树状数组。

答案是肯定的。

插入显然。但是我们似乎不知道如何查询第 $k$ 大。

对于权值树状数组，我们可以用如下代码实现查询区间第 $k$ 小数。

```cpp
int GetKthSmallest(const int &k) {
    int reply = 0, cnt = 0;
    for (int i = 17; i >= 0; --i) 
        reply += (1 << i), reply > *num || cnt + c[reply] >= k ? reply -= (1 << i) : cnt += c[reply];
    return ++reply;
}
```

这段代码在干嘛？

这就是**树状数组二分**。即存在某个数 $\delta$ 使得 $\forall x\le \delta$ 都满足该性质（排名小于等于 $k$），$\forall x> \delta$ 都不满足该性质。

那么怎么实现呢？考虑到权值树状数组是个前缀桶，我们可以用从高位到低位倍增实现，每次尝试把答案 $r$ 加上一个二进制位，若合法且排名小于 $k$ 可以加入该位。注意到加入该位后需要把前面个数计入。最后答案恰好在下一位。

那么我们把上面的代码稍微修改一下就可以树套树搞搞。

但是有个问题：这道题要求查询第 $k$ 大数，怎么办呢？

我们可以离散化（还剩 $n'$ 个数）后对每个数 $x$ 插入 $n'-x+1$，查询第 $k$ 小得到 $x$ 后返回 $n'-x+1$ 对应数即可。

```cpp
#include <algorithm>
#include <cstdio>
using namespace std;
typedef long long ll;
const int maxn = 5e4 + 5, Times = 168;
struct Operation {
    int tp, l, r;
    ll c;
} op[maxn];
int ls[maxn * Times], rs[maxn * Times], len, rt[maxn], n, num[maxn], m;
ll d[maxn * Times], vis[maxn * Times];
void InModify(const int &l, const int &r, const ll &c, int &p, const int &s = 1, const int &t = n) {
    p || (p = ++len), d[p] += (min(r, t) - max(l, s) + 1) * c;
    if (l <= s && t <= r) return void(vis[p] += c);
    int mid = s + ((t - s) >> 1);
    if (l <= mid) InModify(l, r, c, ls[p], s, mid);
    if (r > mid) InModify(l, r, c, rs[p], mid + 1, t);
}
ll InGet(const int &l, const int &r, const int &p, const int &s = 1, const int &t = n) {
    if (!p) return 0;
    if (l <= s && t <= r) return d[p];
    int mid = s + ((t - s) >> 1);
    ll reply = vis[p] * (min(r, t) - max(l, s) + 1);
    if (l <= mid) reply += InGet(l, r, ls[p], s, mid);
    if (r > mid) reply += InGet(l, r, rs[p], mid + 1, t);
    return reply;
}
inline int lowbit(const int &x) { return x & -x; }
void OutUpdate(int i, const int &l, const int &r) { for (; i <= *num; i += lowbit(i)) InModify(l, r, 1, rt[i]); }
ll OutGetKthSmallest(const ll &k, const int &l, const int &r) {
    ll reply = 0, cnt = 0, x;
    for (int i = 17; ~i; --i)
        reply += (1 << i), reply > *num || cnt + (x = InGet(l, r, rt[reply])) >= k ? reply -= (1 << i) : cnt += x;
    return ++reply;
}

int main() {    
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; ++i)
        scanf("%d%d%d%lld", &op[i].tp, &op[i].l, &op[i].r, &op[i].c), op[i].tp == 1 && (num[++*num] = op[i].c);
    sort(num + 1, num + *num + 1), *num = unique(num + 1, num + *num + 1) - num - 1;
    for (int i = 1; i <= m; ++i) {
        if (op[i].tp == 1) OutUpdate(*num - (lower_bound(num + 1, num + *num + 1, op[i].c) - num) + 1, op[i].l, op[i].r);
        else printf("%d", num[*num - OutGetKthSmallest(op[i].c, op[i].l, op[i].r) + 1]), putchar(10);
    }
    return 0;
}
```

---

## 作者：_ctz (赞：6)

好像整体二分跑得飞快，不过蒟蒻是来练树套树的。~~才不是我不会任何离线算法~~

操作涉及区间插入、区间查询k小值。先想到了权值线段树套平衡树，平衡树存储位置。

查询时（假设查询区间 $[l,r]$ 的第k名）从权值线段树根节点出发，查询右儿子平衡树的$r$的排名-（$l-1$）的排名，也就是右边区间中在区间 $[l,r]$的数的个数，比$k$小，就让$k$减去它，跳到左儿子上；反之跳到右儿子上。（比较像主席树区间$k$大值）

插入暴力将每个位置挨个插到平衡树中。

复杂度 $O(nlog^{2}n+len*log^{2}n)$ $\text{（len为总插入数字的个数）}$

$T$了$10$个点。$len$非常大。瓶颈就在于插入。一个个插入确实太慢了，有没有什么能快速把一段连续区间加进去？

线段树可以。权值线段树里套一个维护位置的线段树。插入直接区间加 $1$，查询区间求和，时间都是$logn$的。为了保证空间，还要动态开点。

时间复杂度：每次插入查询都要访问权值线段树的$logn$个节点，每个节点要访问内部的线段树的$logn$个节点。总复杂度$O(nlog^{2}n)$。

空间复杂度：每次插入都要访问权值线段树的$logn$个节点，每个节点内部的线段树最多会新开$logn$个节点，总复杂度$O(nlog^{2}n)$。

不过毕竟树套树常数大，容易 $T$ 。搞个标记永久化能优化不少。不过蒟蒻并不会卡常，程序自带大常数（比如AC自动机永远跑不进 $9000ms$），标记永久化还是 $T$ 了一个点。加了$fread$、快输才能不开$O2$过。

上代码：
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>

#define maxn 50005
#define inf 0x3f3f3f
#define pn putchar('\n')
#define px(x) putchar(x)
#define ps putchar(' ')
#define pd puts("======================")
#define pj puts("++++++++++++++++++++++")
#define getchar() (*head++)

using namespace std;

char buf[1<<23],*head=buf;//fread优化
inline int read(){
    int x=0,y=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return y?-x:x;
}
template<typename T>
inline T read(){
    T x=0;
    int y=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return y?-x:x;
}//快读
void put(int x){
	if(x<0)px('-')，x=-x;
	if(x>9)put(x/10);
	px(x%10+48);
}//快输
int n;
#define ls(x) ls[x]
#define rs(x) rs[x]
struct Position_Segment_Tree{
    long long dat[maxn*400];
    int tag[maxn*400],ls[maxn*400],rs[maxn*400],cnt;
    void add(int L,int R,int l,int r,int &node){
        if(!node)node=++cnt;//动态开点
        dat[node]+=(long long)(min(R,r)-max(L,l)+1);//标记永久化
        if(L<=l&&R>=r){
            ++tag[node];
            return;
        }
        int mid=l+r>>1;
        if(L<=mid)add(L,R,l,mid,ls(node));
        if(R>mid)add(L,R,mid+1,r,rs(node));
    }
    long long ask(int L,int R,int l,int r,int node,long long t=0){
        if(!node)return (long long)(min(R,r)-max(L,l)+1)*t;
        if(L<=l&&R>=r)return dat[node]+1ll*(min(R,r)-max(L,l)+1)*t;
        int mid=l+r>>1;
        long long ans=0;
        if(L<=mid)ans=ask(L,R,l,mid,ls(node),t+tag[node]);
        if(R>mid)ans+=ask(L,R,mid+1,r,rs(node),t+tag[node]);
        return ans;
    }
}pst;
#undef ls
#undef rs
#define ls(x) (x<<1)
#define rs(x) (x<<1|1)
struct Data_Segment_Tree{
    int root[maxn<<3];
    void insert(int poi,int L,int R){
		int l=-n,r=n,node=1;
		while(1){
			pst.add(L,R,1,n,root[node]);
			if(l==r)return;
			int mid=l+r>>1;
			if(poi<=mid)node=ls(node),r=mid;
			else node=rs(node),l=mid+1;
		}
    }//为了卡常把递归改成了非递归的。不过好像没什么效果。。。
    void ask(int L,int R,long long k){
        int l=-n,r=n,node=1;
        while(l<r){
            int mid=l+r>>1;
            long long sum=pst.ask(L,R,1,n,root[rs(node)]);
            if(sum>=k)node=rs(node),l=mid+1;
            else k-=sum,node=ls(node),r=mid;
        }
		put(l),pn;
    }
}dst;
int main(){
	fread(buf,1,1<<23,stdin);
    n=read();
    int m=read();
    while(m--){
        int s=read(),l=read(),r=read();
        if(s==1){
            int d=read();
            dst.insert(d,l,r);
        }
        else {
            long long k=read<long long>();
            dst.ask(l,r,k);
        }
    }
}

```

---

## 作者：巨型方块 (赞：5)

树套树是暴力好不好；

我来讲标算（伪）

my blog:-----

http://blog.csdn.net/largecub233/article/details/69383828

整体二分\cdq分治



第一次接触整体二分；

上课的时候小红说这用树套树做，但感觉好难啊，二维线段树都不会，怎么做树套树啊；

然后就去做整体二分了；

整体二分通过递归实现，和线段树一样，把一段东西变成两段，处理好这两段之间的关系后，这两段就相对独立了，我们直接分治这两段；

首先这题我们要离线做；

总共有两种操作

插入，查询；

查询的是第k大；

我们二分这个k;

二分区间就是k的取值范围，即-n~n;

二分出来的中间值mid;

对于插入；

设插入的值是v;

如果v<=x；那么现在来说这个v对答案没什么贡献；

因为我们要求比mid大的有几个；

那么就直接把这个操作放到左堆；

分治左堆的时候二分的区间会减小，右对会增大；

就是说当前的堆是l~r

做对l~mid;

右堆mid+1~r;

如果v>mid;

显然如果执行这个操作那么会对答案照成贡献；

那么我们用线段树记录一下这个贡献；

树状数组不会

记录好之后这个操作就无用了，放到右堆；


对于查询；

设查询区间xl,xr；

查询第k大；

我们看看xl~xr这个区间现在值是v;

v代表xl~xr区间里面比mid大的数的个数；

这个就是上面说到的贡献，用线段树取维护；

如果v < k,

那么我们直接把k-v之后把这个操作放到左堆；

因为mid+1~r的区间的值只有v个，k>v所以显然答案在l~mid里面；

要是v>=k直接放到右堆分治；


整个思想就是二分里面套分治，再加一颗线段树；


```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<cstring>
#define ui unsigned int
using namespace std;
struct in{
    int num,l,r,kind,v,ans,c;
}a[50005];
struct tree{
    ui v,tag;
    bool p;
}T[131072];
int n,m;
bool cmp2(in x,in y){return x.num<y.num;}
bool cmp1(in x,in y){return x.c<y.c;}
void pushdown(int num,int l,int r){
    if(l==r)return;
    if(T[num].p){//更新儿子； 
        T[num*2].v=T[num*2+1].v=0;
        T[num*2].tag=T[num*2+1].tag=0;
        T[num*2].p=T[num*2+1].p=1;
        T[num].p=0;
    }
    int mid=(l+r)/2;
    T[num*2].v+=(mid-l+1)*T[num].tag;
    T[num*2+1].v+=(r-(mid+1)+1)*T[num].tag;
    T[num*2].tag+=T[num].tag;
    T[num*2+1].tag+=T[num].tag;
    T[num].tag=0;
}
void init(int l,int r,int x,int y,int num){
    pushdown(num,l,r);
    if(x<=l&&r<=y){
        T[num].v+=(r-l+1)*1;
        T[num].tag+=1;
        return;
    }
    int mid=l+r>>1;
    if(mid  >=x)init(l,mid  ,x,y,num<<1  );
    if(mid+1<=y)init(mid+1,r,x,y,num<<1|1);
    T[num].v=T[num*2].v+T[num*2+1].v;
}
ui outit(int l,int r,int x,int y,int num){
    pushdown(num,l,r);
    if(x<=l&&r<=y)return T[num].v;
    int mid=l+r>>1;
    ui ans=0;
    if(mid  >=x)ans+=outit(l,mid  ,x,y,num<<1  );
    if(mid+1<=y)ans+=outit(mid+1,r,x,y,num<<1|1);
    return ans;
}
void er(int l,int r,int x,int y){
    if(l==r){
        for(int i=x;i<=y;i++)a[i].ans=l;//更新答案； 
        return;
    }
    int mid=l+r>>1;
    int L=0,R=y;//分开左右堆 
    T[1].v=T[1].tag=0; T[1].p=1;//更新线段树
    //p表示现在这个节点的左右儿子有没有被清空过，避免memset； 
    for(int i=x;i<=y;i++)
    if(a[i].kind==1){
        if(a[i].v<=mid)a[i].c=++L;else{
            a[i].c=++R;
            init(1,n,a[i].l,a[i].r,1);
        }
    }else{
        ui temp=outit(1,n,a[i].l,a[i].r,1);
        if(temp<(ui)a[i].v){
            a[i].v-=temp;
            a[i].c=++L;
        }else a[i].c=++R;
    }
    sort(a+x,a+y+1,cmp1);//排好序左右对就分离了 
    er(l,mid,x,x+L-1);
    er(mid+1,r,x+L,y);
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++){
        scanf("%d%d%d%d",&a[i].kind,&a[i].l,&a[i].r,&a[i].v);
        a[i].num=i;
    }
    er(-n,n,1,m);//开始分治 
    sort(a+1,a+m+1,cmp2);
    for(int i=1;i<=m;i++)
        if(a[i].kind==2)printf("%d\n",a[i].ans);
}

```

---

## 作者：Treaker (赞：4)

吸氧过了，实际上卡卡常应该还是可以的。比如fread~~本人不会~~。
那么这个题呢就是权值线段树套区间线段树。在权值线段树上进行二分，在不断向下走的过程中，再在区间线段树对应区间上进行相应操作。
本人使用了标记永久化，因为对标记不断down会很浪费时间，标记永久化也是很方便。
```cpp
// luogu-judger-enable-o2
#include <iostream>
#include <cstdio>
#define uint unsigned int
using namespace std;
const int N = 50000;
int n , m;
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while (ch<'0' || ch>'9'){if (ch=='-')f=-1;ch=getchar();}
    while ('0'<=ch && ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return x*f;
}
inline uint in()
{
    uint x=0,f=1;char ch=getchar();
    while (ch<'0' || ch>'9'){if (ch=='-')f=-1;ch=getchar();}
    while ('0'<=ch && ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return x*f;
}
struct Segment_tree
{
	struct node
	{
		node *ls , *rs , *tr;
		int l , r;
		uint sum , tag;
		node (int l = 0,int r = 0) : l(l) , r(r) {ls = rs = tr = NULL , tag = 0 , sum = 0;}
		inline int len() {return r - l + 1;}
		inline int mid() {return (l + r) >> 1;}
	} *root , pool[12000000] , *tail;
	Segment_tree () {root = NULL;tail = pool;}
	void chenge(node *&p,int x,int y,int l,int r)
	{
		if(p == NULL)	p = new (tail ++) node(l,r);
		p -> sum += min(r,y) - max(l,x) + 1;
		if(x <= p -> l && p -> r <= y)	return (void)(p -> tag ++);
		if(x <= p -> mid())	chenge(p -> ls,x,y,l,p -> mid());
		if(y > p -> mid())	chenge(p -> rs,x,y,p -> mid() + 1,r);
	}
	void build(node *&p,int l,int r)
	{
		p = new (tail ++) node(l,r);
		if(l == r)	return;
		build(p -> ls,l,p -> mid());
		build(p -> rs,p -> mid() + 1,r);
	}
	void insert(node *p,int x,int y,int c)
	{
		chenge(p -> tr,x,y,1,n);
		if(p -> l == p -> r)	return;
		if(c <= p -> mid())	insert(p -> ls,x,y,c);
		else insert(p -> rs,x,y,c);
	}
	uint query(node *p,int x,int y,int l,int r,int tag = 0)
	{
		if(p == NULL) return tag * (min(r,y) - max(l,x) + 1);
		if(x <= p -> l && p -> r <= y)	return tag * p -> len() + p -> sum;
		uint res = 0;
		if(x <= p -> mid())	res += query(p -> ls,x,y,l,p -> mid(),tag + p -> tag);
		if(y > p -> mid())		res += query(p -> rs,x,y,p -> mid() + 1,r,tag + p -> tag);
		return res;
	}
	int kth(node *p,int x,int y,uint c)
	{
		if(p -> l == p -> r)	return p -> l;
		uint tmp = query(p -> rs -> tr,x,y,1,n);
		if(c <= tmp)	return kth(p -> rs,x,y,c);
		else return kth(p -> ls,x,y,c - tmp);
	}
}cf;
int main()
{
	n = read(); m = read();
	uint c;
	cf.build(cf.root,-N,N);
	for(int i = 1 , opt , l , r;i <= m;i ++)
	{
		opt = read(); l = read(); r = read(); c = in();
		if(opt & 1)	cf.insert(cf.root,l,r,(int)c);
		else printf("%d\n",cf.kth(cf.root,l,r,c));
	}
	return 0;
}
```


---

## 作者：gyfer (赞：4)

# 浅显易懂的整体二分做法

首先：

确立可以二分：

第K大的数——标准二分

所以定义结构体

a,b,c——如题意

id——查询编号

cur——贡献值注意开long long



    
```cpp
    #include<iostream>
    #include<cstdio>
    using namespace std;
    #define LL long long
    #define f(i,a,b) for(int i=a;i<=b;i++)
    int n,m,mid,l,r,len,i,j,cnt;
    const int N=5e5 + 1;
    LL ans[N],bit0[N],bit1[N];
    struct data{
      int a,b,id,c;//cur:contribution value   q_id:Q_number
      LL cur;
    };
    data q[2*N],q1[2*N],q2[2*N];
```
###### ## Q:那么怎么解决区间插入呢（位置操作）
###### A:树状数组区间修改区间查询

##### 树状数组（模板）~~不是重点~~



```cpp
    void add(LL bit[],int x,int v){ 
      for(int i=x;i<=n;i+=(i&-i)) bit[i]+=v;
    }
    LL sum(LL bit[],int x){
      LL ret=0;for(int i=x;i>0;i-=(i&-i))ret+=bit[i];return ret;
    }
    void add_area(int x,int y,int v){
      add(bit0,x,-v*(x-1));
      add(bit1,x,v);
      add(bit0,y+1,v*y);
      add(bit1,y+1,-v);
    }
    LL sum_area(int x,int y){
      LL ret=0;
      ret+=sum(bit0,y)+sum(bit1,y)*y;
      ret-=(sum(bit0,x-1)+sum(bit1,x-1)*(x-1));
      return ret;
    }`
```
##### 整体二分部分~~也是模板~~



    
```cpp
    void solve(int ql,int qr,int l,int mid){
      f(i,ql,qr){
        if(q[i].id){//find
            q[i].cur=sum_area(q[i].a,q[i].b);
        }else if (q[i].c<=mid){//change
           add_area(q[i].a,q[i].b,q[i].cur);
        }
      }
      f(i,ql,qr){
        if(!q[i].id && q[i].c<=mid){
           add_area(q[i].a,q[i].b,-q[i].cur);
        }
      }
    }
    void divide(int ql,int qr,int l,int r){
      if(l==r){
        f(i,ql,qr){
          if(q[i].id){
            ans[q[i].id]=l;
            }
          }
        return;
      }
      int mid=(l+r)/2;
      solve(ql,qr,l,mid);//solve__cur
      int len1=0,len2=0;
      f(i,ql,qr){
        if(q[i].id){//find
            if(q[i].c<=q[i].cur){
              q1[++len1]=q[i];
            }
            else {
              q[i].c-=q[i].cur;
              q2[++len2]=q[i];
            }
        }
        else{//change
            if(q[i].c<=mid){
                q1[++len1]=q[i];
            }
            else {
                q2[++len2]=q[i];
            }
          }
        }
        f(i,1,len1) q[ql+i-1]=q1[i];
        f(i,1,len2) q[ql+len1+i-1]=q2[i];
        if(len1>0) divide(ql,ql+len1-1,l,mid);
        if(len2>0) divide(ql+len1,qr,mid+1,r);
    }
```
##### 映射重点来了，这道题是第C大数
那么为什么上面的代码（第C小）可以过呢？这用到了**映射**



```cpp
    int main(){
      cin>>n>>m;
     f(i,1,m){
         int type,c;
       scanf("%d%d%d%d",&type,&q[i].a,&q[i].b,&c);
       if(type==1){
       q[i].c=n-c+1;q[i].id=0;q[i].cur=1;//程序精华所在
       }
       else{
           q[i].c=c;q[i].id=++cnt;q[i].cur=0;
       }
     }
      divide(1,m,1,2*n+1);
      f(i,1,cnt){
          printf("%d\n",n-ans[i]+1);//重新映射回去
      }
    }

```

---

## 作者：GoldenPotato137 (赞：3)

[戳我获得更好的阅读体验qwq](https://www.goldenpotato.cn/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/luogu-p3332zjoi2013k%E5%A4%A7%E6%95%B0%E6%9F%A5%E8%AF%A2/)

---
# Solution

这是一道不辣么模板的整体二分题。

.

首先，我们先来假设一下只有一个询问应该怎么搞。

考虑这样做：我们先二分一个答案，修改中，如果所要修改的数大于mid，则在这段区
间中每个数加上1。否则什么都不做。这样一来，最后我们只需要看一下询问的区间的
区间和是否大于$K$即可。

.

接下来，我们考虑如何把所有询问一起来二分。

同样还是二分一个答案，把所有答案大于mid的询问丢到右边，其余丢到左边即可。
接下来，我们可以显然发现对于右边的区间，**所有修改$<=mid$的修改都是没有意义的。因此，我们考虑把所有$<=mid$的修改放在右边，其余的放在左边**。显然，**对于左边所有的询问，$>=mid$的修改一定会对左边造成影响，因此还要把所有在左边的询问减上对应的值**（在这个询问之前所有的操作对它产生的1的数量）。

对于询问和修改的顺序问题：我们分别保证询问与修改按照时间有序，用两个指针分开处理，每次询问之前把在它之前的修改全部做了即可。这样就可以保证时间合法。

.

时间复杂度$O(nlog^2n)$

就酱，我们又切掉一道题啦(ﾉ≧∀≦)ﾉ

---
# Code
**数据生成器**

[在这里](https://www.goldenpotato.cn/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/luogu-p3332zjoi2013k%E5%A4%A7%E6%95%B0%E6%9F%A5%E8%AF%A2/)

**正解**
```cpp
//Luogu P3332 [ZJOI2013]K大数查询 
//Mar,27th,2019
//整体二分+线段树
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<cmath>
using namespace std;
long long read()
{
	long long x=0,f=1; char c=getchar();
	while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
	while(isdigit(c)){x=x*10+c-'0';c=getchar();}
	return x*f;
}
const int N=50000+100;
struct SegmentTree
{
	#define lson (now<<1)
	#define rson (now<<1|1)
	#define mid ((now_l+now_r)>>1)
	long long sum[N<<2];
	int lazy[N<<2];
	inline void update(int now)
	{
		sum[now]=sum[lson]+sum[rson];
	}
	inline void pushdown(int now,int now_l,int now_r)
	{
		if(now_l!=now_r)
		{
			sum[lson]+=lazy[now]*(mid-now_l+1),sum[rson]+=lazy[now]*(now_r-mid);
			lazy[lson]+=lazy[now],lazy[rson]+=lazy[now];
		}
		lazy[now]=0;
	}
	void Change(int l,int r,int w,int now,int now_l,int now_r)
	{
		pushdown(now,now_l,now_r);
		if(now_l>=l and now_r<=r)
		{
			lazy[now]=w,sum[now]+=1ll*w*(now_r-now_l+1);
			return;
		}
		if(l<=mid) Change(l,r,w,lson,now_l,mid);
		if(r>mid) Change(l,r,w,rson,mid+1,now_r);
		update(now);
	}
	long long Query(int l,int r,int now,int now_l,int now_r)
	{
		pushdown(now,now_l,now_r);
		if(now_l>=l and now_r<=r)
			return sum[now];
		long long t_ans=0;
		if(l<=mid) t_ans+=Query(l,r,lson,now_l,mid);
		if(r>mid) t_ans+=Query(l,r,rson,mid+1,now_r);
		return t_ans;
	}
	#undef lson
	#undef rson
	#undef mid
}sgt;
struct OP
{
	int l,r,no;
	long long w;
}op1[N],op2[N];//op1:询问，op2:修改
struct DL
{
	int l,r;
	vector <OP> op,qur;
}mqueue[2*N];
int n,m,q,p,K=2*N-20;//q:询问，p:修改
int ans[N];
int main()
{
	freopen("3332.in","r",stdin);
	freopen("3332.out","w",stdout);
	
	n=read(),m=read();
	for(int i=1;i<=m;i++)
	{
		int op=read();
		if(op==1)
			op2[++p].l=read(),op2[p].r=read(),op2[p].w=read(),op2[p].no=i;
		else
			op1[++q].l=read(),op1[q].r=read(),op1[q].w=read(),op1[q].no=i;
	}
	
	int front=0,tail=0;
	mqueue[tail].l=-N,mqueue[tail].r=N;
	for(int i=1;i<=p;i++)
		mqueue[tail].op.push_back(op2[i]);
	for(int i=1;i<=q;i++)
		mqueue[tail].qur.push_back(op1[i]);
	tail++;
	memset(ans,0x3f,sizeof ans);
	
	while(front!=tail)
	{
		//cerr<<front<<" "<<tail<<" "<<mqueue[front].l<<" "<<mqueue[front].r<<endl;
		if(mqueue[front].l==mqueue[front].r)
		{
			for(int i=0;i<int(mqueue[front].qur.size());i++)
				ans[mqueue[front].qur[i].no]=mqueue[front].l;
		}
		else if(mqueue[front].qur.size()>0)
		{
			int mid=int(floor((mqueue[front].l+mqueue[front].r)/2.0)),T=0;
			DL L,R;
			for(int i=0;i<int(mqueue[front].qur.size());i++)
			{
				for(;T<int(mqueue[front].op.size()) and mqueue[front].qur[i].no>mqueue[front].op[T].no;T++)
				{
					sgt.Change(mqueue[front].op[T].l,mqueue[front].op[T].r,mqueue[front].op[T].w>mid,1,1,n);
					if(mqueue[front].op[T].w>mid)
						R.op.push_back(mqueue[front].op[T]);
					else
						L.op.push_back(mqueue[front].op[T]);
				}
				long long t=sgt.Query(mqueue[front].qur[i].l,mqueue[front].qur[i].r,1,1,n);
				if(t>=mqueue[front].qur[i].w)
					R.qur.push_back(mqueue[front].qur[i]);
				else
				{
					mqueue[front].qur[i].w-=t;
					L.qur.push_back(mqueue[front].qur[i]);
				}
			}
			for(int i=0;i<T;i++)
				sgt.Change(mqueue[front].op[i].l,mqueue[front].op[i].r,-(mqueue[front].op[i].w>mid),1,1,n);
			L.l=mqueue[front].l,L.r=mid;
			R.l=mid+1,R.r=mqueue[front].r;
			mqueue[tail]=L,tail=(tail+1)%K;
			mqueue[tail]=R,tail=(tail+1)%K;
		}
		front=(front+1)%K;
	}
	
	for(int i=1;i<=m;i++)
		if(ans[i]!=0x3f3f3f3f)
			printf("%d\n",ans[i]);
	return 0;
}

```






---

## 作者：微雨燕双飞 (赞：3)

穿梭在茫茫的树套树海洋中，蒟蒻深深地感觉到了自己的菜。各位大佬不是整体二分就是线段树、平衡树乱套，我只看得眼花缭乱。于是，就只好开始瞎搞，我采用的方法是：cdq分治+树状数组维护区间第c大的值，2368msAC，还是比较快的。
下面就来看一看一枝独秀的优（zha）秀（zha）代码：
```
#include<iostream>
#include<vector> //动态数组（分治用）
using namespace std;
struct op
{
 long long l,r;
 long long k;
 bool isquery;
 long long qid;
}; //分治用结构体
long long n,m,ty;
long long ans[50005],a[50005],a2[50005];
void add_bit(int k,int d)
{
 while(k<=n)
 {
  a[k]+=d;
  k+=k&-k;
 }
}
void add_bit2(int k,int d)
{
 while(k<=n)
 {
  a2[k]+=d;
  k+=k&-k;
 } 
}
void add(int l,int r,int d) //超级树状数组单点修改
{
 add_bit(l,d);
 add_bit(r+1,-d);
 add_bit2(l,d*l);
 add_bit2(r+1,-d*(r+1));
}
long long sum_bit(int i)
{
 int s=0;
 while(i>0)
 {
  s+=a[i];
  i-=i&-i;
 }
 return s;
}
long long sum_bit2(int i)
{
 int s=0;
 while(i>0)
 {
  s+=a2[i];
  i-=i&-i;
 }
 return s;
}
long long sum(int k) //超级树状数组区间和查询
{
 return(sum_bit(k))*(k+1)-sum_bit2(k);
}
void solve(int lb,int ub,vector<op> &q) //cdq分治 
{ //思路与quicksort类似，先分再治
 vector<op> left;
 vector<op> right;
 if(ub-lb==1)
 {
  for(int i=0; i<q.size(); i++)
    if(q[i].isquery) ans[q[i].qid]=lb;
  return;
 }
 int t=(ub+lb)/2;
 for(int i=0; i<q.size(); i++)
   if(q[i].isquery)
   {
    long long count=sum(q[i].r)-sum(q[i].l-1);
    if(q[i].k>count) 
    {
     q[i].k-=count;	
     left.push_back(q[i]);	
    }
    else right.push_back(q[i]);  
   }
   else if(q[i].k<t) left.push_back(q[i]);
          else 
          {
           right.push_back(q[i]);
           add(q[i].l,q[i].r,1);
          }
 for(int i=0; i<q.size(); i++)
   if(!q[i].isquery&&q[i].k>=t) add(q[i].l,q[i].r,-1);
 solve(lb,t,left); //区间左闭右开 
 solve(t,ub,right);  
}
int main()
{
 cin>>n>>m;
 vector<op> q(m);
 int qid=0;
 for(int i=0; i<m; i++)
 {
  cin>>ty>>q[i].l>>q[i].r>>q[i].k;
  q[i].isquery=(ty==2);
  if(ty==2)
  {
   qid++;
   q[i].qid=qid;
  }
 }
 solve(-50000,50001,q); //cdq分治求解
 for(int i=0; i<q.size(); i++) 
   if(q[i].isquery) cout<<ans[q[i].qid]<<endl; //输出
 return 0;
} //希望对大家有帮助
```

---

## 作者：Ηydra (赞：2)

#### [my blog](https://www.cnblogs.com/happyLittleRabbit/p/10392238.html)


[题目描述](https://www.luogu.org/problemnew/show/P3332)

#### 权值线段树套线段树板子题

首先观察题目，判断为二维偏序问题

操作1为区间修改，所以一定是外部线段树维护权值，内部线段树维护所在区间，否则时间复杂度爆炸qwq

为方便查找，哈希时我采用哈希每个数的相反数的方法将求第k大转换为求第k小

询问可以直接想到的做法就是二分答案，查询1~ans在区间内的个数，时间复杂度 O(nlog^3n)

尝试去掉一个log，思考发现可以直接在权值线段树上二分，每次查询左子树表示的数在区间内的个数p，若p大于等于当前查询的第k小则直接进入左子树，否则进入右子树并将k减p。时间复杂度O(nlog^2n)

内部线段树采用动态开点，空间复杂度O(nlog^2n) (n、m同阶)

但是我第一次写的树套树貌似常数过大，T了7个点，于是又加上了标记永久化，省去了标记下放的时间和不必要的空间浪费。区间修改时直接在经过的节点上修改权值并在原先打标记的节点上打上永久化标记，查询是将经过的点的标记都加起来乘区间长度再加上询问区间的权值即为答案。

具体实现见代码

```C++
#include <iostream>
#include <cstdio>
#include <algorithm>
#define gc getchar
#define re register
using namespace std;
template <typename T> void rd(T& s)
{
    s = 0;
    bool p = 0;
    char ch;
    while (ch = gc(), p |= ch == '-', ch < '0' || ch > '9');
    while (s = s * 10 + ch - '0', ch = gc(), ch >= '0' && ch <= '9');
    s *= (p ? -1 : 1);
}
template <typename T, typename... Args> void rd(T& s, Args&... args)
{
    rd(s);
    rd(args...);
}
int cnt, tot;
#define LL long long
#define new_node(ls, rs, val) (st[++cnt] = node(ls, rs, val), cnt)
const int MAXN = 50050;
const int MAX = 50000000;
struct node
{
    int ls, rs;
    LL val;
    int tag;
    node(int ls, int rs, LL val) : ls(ls), rs(rs), val(val), tag(0) {}
    node() {}
}st[MAX];
struct que
{
    int opt, a, b;
    LL c;
    que(int opt, int a, int b, LL c) : opt(opt), a(a), b(b), c(c) {}
    que() {}
}qu[MAXN];
int n;
LL hs[MAXN];
int tree[MAXN << 2];
void modify(int& o, re int l, re int r, re int ll, re int rr)
{
    if (!o)
        o = new_node(0, 0, 0);
    st[o].val += (r - l + 1);
    if (l == ll && r == rr)
    {
        st[o].tag += 1;
        return;
    }
    re int mid = (ll + rr) >> 1;
    if (r <= mid)
        modify(st[o].ls, l, r, ll, mid);
    else
        if (l > mid)
            modify(st[o].rs, l, r, mid + 1, rr);
        else
            modify(st[o].ls, l, mid, ll, mid),
            modify(st[o].rs, mid + 1, r, mid + 1, rr);
}
LL query(re int o, re int l, re int r, re int ll, re int rr, re int tag)
{
    if (!o)
        return tag * 1ll * (r - l + 1);
    if (l == ll && r == rr)
        return st[o].val + tag * 1ll * (r - l + 1);
    re int mid = (ll + rr) >> 1;
    if (r <= mid)
        return query(st[o].ls, l, r, ll, mid, tag + st[o].tag);
    else
        if (l > mid)
            return query(st[o].rs, l, r, mid + 1, rr, tag + st[o].tag);
        else
            return query(st[o].ls, l, mid, ll, mid, tag + st[o].tag) + query(st[o].rs, mid + 1, r, mid + 1, rr, tag + st[o].tag);
}
void add(re int o, re int k, re int l, re int r, re int ll, re int rr)
{
    modify(tree[o], l, r, 1, n);
    if (ll == rr)
        return;
    re int mid = (ll + rr) >> 1;
    if (k <= mid)
        add(o << 1, k, l, r, ll, mid);
    else
        add((o << 1) | 1, k, l, r, mid + 1, rr);
}
int midsearch(re int o, re int ll, re int rr, re int l, re int r, re int k)
{
    if (ll == rr)
        return ll;
    re LL p = query(tree[o << 1], l, r, 1, n, 0);
    if (p >= k)
        return midsearch(o << 1, ll, (ll + rr) >> 1, l, r, k);
    else
        return midsearch((o << 1) | 1, ((ll + rr) >> 1) + 1, rr, l, r, k - p);
}
int main()
{
    re int m = 0, opt, a, b;
    re LL c;
    rd(n, m);
    for (re int i = 1; i <= m; ++i)
    {
        rd(opt, a, b);
        rd(c);
        qu[i] = que(opt, a, b, c);
        if (opt == 1)
            hs[++tot] = -c;
    }
    sort(hs + 1, hs + 1 + tot);
    tot = unique(hs + 1, hs + 1 + tot) - hs - 1;
    for (re int i = 1; i <= m; ++i)
    {
        if (qu[i].opt == 1)
        {
            add(1, lower_bound(hs + 1, hs + 1 + tot, -qu[i].c) - hs, qu[i].a, qu[i].b, 1, tot);
        }
        else
        {
            printf("%lld\n", -hs[midsearch(1, 1, tot, qu[i].a, qu[i].b, qu[i].c)]);
        }
    }
    return 0;
}
```

---

## 作者：Angora (赞：0)

权值线段树套区间线段树,每次二分权值然后去对应的区间里查询或者修改就好了。具体一点讲,线段树里每个节点存的是权值在a-b 在区间l-r上的点的个数
可能我太菜了。。。裸的线段树套线段树我T三个点。。。加了个标记永久化。。。弱小.jpg
``` c++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define rep(i,x,y) for(register int i=x;i<=y;++i)
#define repd(i,x,y) for(register int i=x;i>=y;--i)
#define ll long long
using namespace std;
const int N=5e4+7;
const int M=N*400;
ll tr[M],lz[M],C[N],n,m,cnt,rk[N];
int ls[M],rs[M],root[N<<2],A[N],B[N],op[N],len,ct;
template <typename T>inline void read(T &x){
	x=0;char c;int sign=1;
	do{c=getchar(); if(c=='-')sign=-1;}while(c<'0'||c>'9');
	do{x=x*10+c-'0';c=getchar();}while(c>='0'&&c<='9');
	x*=sign;
}
inline void update(int &o,int l,int r,int L,int R){
    if(!o)o=++cnt;
    tr[o]+=min(r,R)-max(l,L)+1;
    if(L<=l&&R>=r){lz[o]++;return ;}
    int mid=l+r>>1;
    if(L<=mid)update(ls[o],l,mid,L,R);
    if(R>mid)update(rs[o],mid+1,r,L,R);
}
inline void UPDATE(int a,int b,int c){
    int l=1,r=len,k=1;
    while(l<r){
        int mid=l+r>>1;
        update(root[k],1,n,a,b);
        if(c<=mid)k<<=1,r=mid;
        else k=k<<1|1,l=mid+1;
    }
    update(root[k],1,n,a,b);
}
inline ll query(int o,int l,int r,int L,int R){
    if(!o)return 0;
    if(L<=l&&R>=r)return tr[o];
    int mid=l+r>>1;ll ans=lz[o]*(min(r,R)-max(L,l)+1);
    if(L<=mid)ans+=query(ls[o],l,mid,L,R);
    if(R>mid)ans+=query(rs[o],mid+1,r,L,R);
    return ans;
}
inline int QUERY(int a,int b,int c){
    int l=1,r=len,k=1;
    while(l<r){
        int mid=l+r>>1;ll t=query(root[k<<1],1,n,a,b);
        if(c<=t)r=mid,k<<=1;
        else l=mid+1,k=k<<1|1,c-=t;
    }
    return l;
}
int main(){
    read(n);read(m);
	rep(i,1,m){read(op[i]);read(A[i]);read(B[i]);read(C[i]);if(op[i]==1)rk[++ct]=C[i];}
    sort(rk+1,rk+ct+1);
    len=unique(rk+1,rk+ct+1)-rk-1;
    rep(i,1,m)if(op[i]==1)C[i]=lower_bound(rk+1,rk+len+1,C[i])-rk;
    rep(i,1,m){
        if(op[i]==1){UPDATE(A[i],B[i],len-C[i]+1);}
        else printf("%d\n",rk[len-QUERY(A[i],B[i],C[i])+1]);
    }
    return 0;
}
```

---


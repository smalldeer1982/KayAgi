# [国家集训队] 整数的lqp拆分

## 题目背景

来源：2011中国国家集训队命题答辩

## 题目描述

lqp在为出题而烦恼，他完全没有头绪，好烦啊…

他首先想到了整数拆分。整数拆分是个很有趣的问题。给你一个正整数 $N$ ，对于N的一个整数拆分就是满足任意 $m>0$，$a_1 ,a_2 ,a_3…a_m>0$，且 $a_1+a_2+a_3+…+a_m=n$ 的一个有序集合。通过长时间的研究我们发现了计算对于 $n$ 的整数拆分的总数有一个很简单的递推式，但是因为这个递推式实在太简单了，如果出这样的题目，大家会对比赛毫无兴趣的。  

然后 lqp 又想到了斐波那契数。定义 $F_0=0,F_1=1,F_n=F_{n-1}+F_{n-2} (n>1)$，$F_n$就是斐波那契数的第$n$项。但是求出第 $n$ 项斐波那契数似乎也不怎么困难…

lqp 为了增加选手们比赛的欲望，于是绞尽脑汁，想出了一个有趣的整数拆分，我们暂且叫它：整数的lqp拆分。

和一般的整数拆分一样，整数的 lqp 拆分是满足任意 $m>0$，$a_1 ,a_2 ,a_3…a_m>0$，且 $a_1+a_2+a_3+…+a_m=n$ 的一个有序集合。但是整数的lqp拆分要求的不是拆分总数，相对更加困难一些。

对于每个拆分，lqp 定义这个拆分的权值 $F_{a_1}F_{a_2}…F_{a_m}$，他想知道对于所有的拆分，他们的权值之和是多少？

简单来说，就是求  
$\sum\prod_{i=1}^m F_{a_i}$   
$m>0$    
$a_1,a_2...a_m>0$   
$a_1+a_2+...+a_m=n$     
由于答案可能非常大，所以要对 $10^9 + 7$ 取模。

## 说明/提示

【数据范围】  
对于 $60\%$ 的数据，$1\le n \le 10^9$；  
对于 $100\%$ 的数据，$1\le n \le 10^{10000}$。

【样例解释】  
$F_0=0,F_1=1,F_2=1,F_3=2$。

对于 $n=3$，有这样几种 lqp 拆分：

$3=1+1+1$，权值是 $F_1\times F_1\times F_1=1\times1\times1=1$

$3=1+2$，权值是 $F_1\times F_2=1\times1=1$

$3=2+1$，权值是 $F_2\times F_1=1\times1=1$

$3=3$，权值是 $F_3=2$

所以答案是 $1+1+1+2=5$

## 样例 #1

### 输入

```
3```

### 输出

```
5```

# 题解

## 作者：NaCly_Fish (赞：42)

《组合数学》原题改编石锤了（  
其实此题从各方面讲都不难。
****
fibonacci 数的生成函数是这个（基础知识）
$$F(x)=\frac{x}{1-x-x^2}$$  
我们知道拆分为恰好 $k$ 个数时，答案的生成函数为 $F(x)^k$  
那么答案的生成函数显然为
$$G(x)=\sum_{i=0}^\infty F(x)^i$$
$$=\frac{1}{1-F(x)}=\frac{1-x-x^2}{1-2x-x^2}$$
分母写成递推式就是

$$a_n=2a_{n-1}+a_{n-2}$$
乘上分子得到答案
$$\text{ans}=a_n-a_{n-1}-a_{n-2}=a_{n-1}$$

解递推式特征方程，得
$$x_1=-\sqrt 2+1,x_2=\sqrt 2+1$$
设通项公式为
$$a_n=c_1(-\sqrt 2+1)^n+c_2(\sqrt 2+1)^n$$
分别代入 $n=0,n=1$，解得 
$$\left\{\begin{aligned}c_1=\frac{\sqrt 2-1}{2\sqrt 2} \\ c_2=\frac{\sqrt 2+1}{2\sqrt 2} \end{aligned}\right.$$
注意到 $\sqrt 2$ 在模 $10^9+7$ 下存在（$59713600$），最终答案就出来了
$$a_n\equiv 485071604\times 940286408^n+514928404\times59713601^n\pmod{10^9+7}$$
直接计算即可。

---

## 作者：jun头吉吉 (赞：30)

## 题意
$$\large{\sum_{\small\sum_{i=1}^ma_i=n,a_i>0}}\small\prod_{i=1}^m F_{a_i}$$
## 题解
小清新生成函数。

记斐波那契数列的第$i$项为$fib_i$，那么有：$fib_0=0,fib_1=1,fib_n=fib_{n-1}+fib_{n-2}$

令$F(x)=\sum_{i=0}^{+\infty}fib_ix^i$，即斐波那契的生成函数，那么显然有：

$$
\begin{alignedat}{2}
F(x)&=fib_0+&fib_1\times x+&fib_2\times x^2+fib_3\times x^3+fib_4\times x^4+\ldots(1)\\
xF(x)&=&fib_0\times x+&fib_1\times x^2+fib_2\times x^3+fib_3\times x^4+\ldots(2)\\
x^2F(x)&=&&fib_0\times x^2+fib_1\times x^3+fib_2\times x^4+\ldots(3)\\
\end{alignedat}
$$

$(2)$式加$(3)$式，由于$fib_i+fib_{i+1}=fib_{i+2}$，可以得到：

$$(x+x^2)F(x)=fib_2\times x^2+fib_3\times x^3+fib_4\times x^4\ldots$$

与$(1)$式对比一下，有：

$$F(x)=(x+x^2)F(x)+x$$

$$F(x)=\frac{x}{1-x-x^2}$$

设$n$的答案为$g_n$，递推式应该比较容易。就是枚举最后的一个数字，在原来的基础上乘上这个数的斐波那契值，在累加答案，最后的式子应该就是：

$$g_n=\sum_{i=1}^ng_ifib_{n-i}$$

特别地，我们令$g_0=1$

$$g_n=[n=0]+\sum_{i=1}^ng_ifib_{n-i}$$

设$g$的生成函数为$G$,即$G(x)=\sum_{i=0}^{+\infty}g_ix^i$，那么对其进行展开：

$$G(x)=\sum_{n=0}^{+\infty}([n=0]+\sum_{i=1}^ng_ifib_{n-i})x^n$$

$$G(x)=1+\sum_{n=1}^{+\infty}(\sum_{i=1}^ng_ifib_{n-i})x^n$$

不难发现，$\sum_{n=1}^{+\infty}(\sum_{i=1}^ng_ifib_{n-i})x^n=F(x)\times G(x)$，因此：

$$G(x)=1+F(x)\times G(x)$$

$$G(x)=\frac{1}{1-F(x)}=\frac{1}{1-\frac{1}{1-x-x^2}}$$

$$=\frac{1-x-x^2}{1-2x-x^2}=1-\frac{x}{x^2+2x-1}$$

此时只需要展开$-\frac{x}{x^2+2x-1}$即可。

我们知道，$\frac{1}{1-cx^k}=\sum_{i=0}^{+\infty}(cx)^{ik}$，因此我们希望上式可以用这样的方式展开。

我们只需要解出$x^2+2x-1=0$的两根$x_1,x_2$，$x_{1,2}=-1±\sqrt{2}$,那么就有：

$$-\frac{x}{x^2+2x-1}=-\frac{x}{(x-x_1)(x-x_2)}$$

$$=\frac{x}{x_2-x_1}(\frac{1}{x-x_1}-\frac{1}{x-x_2})$$

把常数项化为$1$

$$=\frac{x}{x_2-x_1}(\frac{1}{x2}\times\frac{1}{1-x/x2}-\frac{1}{x1}\times\frac{1}{1-x/x1})$$

$$=\frac{x}{x_2-x_1}(\frac{1}{x2}\times\sum_{i=0}\frac{x^i}{x_2^i}-\frac{1}{x1}\times\sum_{i=0}\frac{x^i}{x_1^i})$$

$$=\frac{1}{x_2-x_1}(\sum_{i=0}\frac{x^{i+1}}{x_2^{i+1}}-\sum_{i=0}\frac{x^{i+1}}{x_1^{i+1}})$$

那么第$n$项的系数为$g(n)=\dfrac{1}{x2-x1}\times(\dfrac{1}{x_2^n}-\dfrac{1}{x_1^n})$

代入得到：$g(n)=\dfrac{\sqrt{2}}{4}[(1+\sqrt{2})^n-(1-\sqrt{2})^n]$

$\sqrt2$在模$1000000007$时等于$59713600$或$940286407$。

但是由于$n$的值很大，根据费马小定理，对$mod-1$取模即可。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
template<const int mod> 
struct modint{
    ll x;
    modint(ll o=0){x=o;}
    modint &operator = (ll o){return x=o,*this;}
    modint &operator +=(modint o){return x=x+o.x>=mod?x+o.x-mod:x+o.x,*this;}
    modint &operator -=(modint o){return x=x-o.x<0?x-o.x+mod:x-o.x,*this;}
    modint &operator *=(modint o){return x=1ll*x*o.x%mod,*this;}
    modint &operator ^=(ll b){
    	b%=(mod-1);
        modint a=*this,c=1;
        for(;b;b>>=1,a*=a)if(b&1)c*=a;
        return x=c.x,*this;
    }
    modint &operator /=(modint o){return *this *=o^=mod-2;}
    modint &operator +=(ll o){return x=x+o>=mod?x+o-mod:x+o,*this;}
    modint &operator -=(ll o){return x=x-o<0?x-o+mod:x-o,*this;}
    modint &operator *=(ll o){return x=1ll*x*o%mod,*this;}
    modint &operator /=(ll o){return *this *= ((modint(o))^=mod-2);}
    template<class I>friend modint operator +(modint a,I b){return a+=b;}
    template<class I>friend modint operator -(modint a,I b){return a-=b;}
    template<class I>friend modint operator *(modint a,I b){return a*=b;}
    template<class I>friend modint operator /(modint a,I b){return a/=b;}
    friend modint operator ^(modint a,ll b){return a^=b;}
    friend bool operator ==(modint a,ll b){return a.x==b;}
    friend bool operator !=(modint a,ll b){return a.x!=b;}
    bool operator ! () {return !x;}
    modint operator - () {return x?mod-x:0;}
    void read(){
    	string s;cin>>s;x=0;
    	for(int i=0;i<s.length();i++)
			*this*=10,*this+=s[i]-'0';
	}void write(){
		cout<<x;
	}
};
modint<1000000006>n;
modint<1000000007>ans,sqrt2=59713600;
signed main(){
	n.read();
	ans=sqrt2/4*(((sqrt2+1)^n.x)-((-sqrt2+1)^n.x));ans.write();
	return 0;
}
```


---

## 作者：Froggy (赞：18)

这里讲一个**不同根的有理展开定理**（解递归式，把函数展开成幂级数的常用方法）。

（学习自《具体数学》）

---

答案很显然可以写成如下递归式：

$$f_n=
\begin{cases}
\sum\limits_{i=0}^nfib_i\times f_{n-i} &n>0\\
1 &n=0
\end{cases}$$

搞出答案数列 $f$ 的生成函数 $F(x)$，设斐波那契数列的生成函数为 $G(x)$ 可以得到如下关系式：

$$F=F*G+1$$

众所周知斐波那契数列的生成函数的封闭形式是 $\dfrac{x}{1-x-x^2}$ (由于这道题目的数列整体右移了一位所以分子是 $x$ )

那么解得：

$$F=1+\frac{x}{1-2x-x^2}$$

现在的问题在于如何展开 $\dfrac{x}{1-2x-x^2}$。

---

## 不同根的有理展开定理

有一个多项式 $f(x)$：

$$f(x)=\sum\limits_{i=0}^{m}a_ix^i$$

$f(x)$ 的**反射多项式**：

$$f^R(x)=\sum\limits_{i=0}^{m}a_{m-i}x^i$$


设 $z_1,z_2,\cdots,z_m$ 为 $f^R(x)$ 的 $m$ 个根。

两者存在一个重要关系：


$$
\begin{aligned}
f^R(x)&=a_0\prod\limits_{i=1}^m (x-z_i) \\
&\Leftrightarrow \\
f(x)&=a_0\prod\limits_{i=1}^m (1-a_iz_i)
\end{aligned}
$$

若 $g(x)=\dfrac{p(x)}{f(x)}$ （ $p(x)$ 是一个小于 $m$ 次的多项式 ）

则有：

$$[x^i]g(x)=\sum\limits_{k=1}^m \frac{-z_kp\left(\frac{1}{z_k}\right)}{f'\left(\frac{1}{z_k}\right)}\cdot z_k^i$$

**注：** $[x^i]$ 是 $g(x)$ 的 $i$ 次项系数。

---

针对这道题目：

$g(x)=\dfrac{x}{1-2x-x^2}$

$f(x)=1-2x-x^2,f'(x)=-2x-2,p(x)=x$

则：

$$\frac{-z\ p\left(\frac{1}{z}\right)}{f'\left(\frac{1}{z}\right)}\cdot z^i=\frac{z}{2+2z}\cdot z^i$$

那么这道题目的答案就是：

$$\frac{z_1}{2+2z_1}\cdot z_1^n+\frac{z_2}{2+2z_2}\cdot z_2^n$$

其中，$f^R(x)$ 的两根分别为 $z_1=1+\sqrt{2},z_2=1-\sqrt{2}$。

$2$ 在模 $10^9+7$ 意义下的二次剩余是 $59713600$。

根据费马小定理，读入 $n$ 的时候模 $10^9+6$ ，然后直接快速幂即可求出答案。


---

炒鸡短的 ***code：***

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
typedef long long ll;
const ll mod=1e9+7;
const ll s2=59713600;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<3)+(x<<1)+c-'0';
        x%=(mod-1);
        c=getchar();
    }
    return x*f;
}
int n,X1,X2;
ll qpow(ll a,ll b){
	ll ans=1;
	while(b){
		if(b&1)ans=ans*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return ans;
}
int main(){
	n=read();
	X1=s2+1,X2=(1-s2+mod)%mod;
	printf("%lld\n",(X1*qpow((2+2*X1)%mod,mod-2)%mod*qpow(X1,n)%mod+X2*qpow((2+2*X2)%mod,mod-2)%mod*qpow(X2,n)%mod)%mod);
	return 0;
}

```

[*Froggy's blog*](https://www.luogu.org/blog/1445353309froggy/)

#### 呱!!



---

## 作者：JasonL (赞：12)

**前言**

[原题传送门](https://www.luogu.com.cn/problem/P4451)

我们发现数据范围似乎已经做了改动，由原来的$n≤10^6$ 变为$n≤10^{10000}$

时间复杂度掐的非常紧，原来简朴漂亮的递推方法就行不通了。由于个人在生成函数上非常的$naive$，所以使用了矩阵快速幂，然后对于看起来搞不定的$n$运用字符串高精运算。

------------

**正文**

首先是解题过程。

令$f(x)=\sum \prod\limits_{i=1}^xF_{a_i} $

则有 $f(x)=\sum\limits_{i=1}^{x}f(i)F_{x-i}$

$\because F_0=0$

$\therefore f(x)= \sum\limits_{i=1}^{x-1}f(i)F_{x-i}$

$\begin{aligned}f(x)-f(x-1) 
& = \sum\limits_{i=1}^{x-1}f(i)F_{x-i}-\sum\limits_{i=1}^{x-2}f(i)F_{x-1-i}
\\ & = \sum\limits_{i=1}^{x-2}f(i)F_{x-i}-\sum\limits_{i=1}^{x-2}f(i)F_{x-1-i}+f(x-1)F_{1}
\\ & = \sum\limits_{i=1}^{x-2}f(i)(F_{x-i}-F_{x-1-i})+f(x-1)
\\ & = \sum\limits_{i=1}^{x-2}f(i)F_{x-2-i}+f(x-1)
\\ & = f(x-2)+f(x-1)
\end{aligned}$ 

$\therefore f(x)=2f(x-1)+f(x-2)$

令$x=n$，构造矩阵，则有

$\begin{bmatrix}f(n)\\f(n-1)\end{bmatrix}=\begin{bmatrix}2f(n-1)+f(n-2)\\f(n-1)\end{bmatrix}=\begin{bmatrix}f(n-1)\\f(n-2)\end{bmatrix}\begin{bmatrix}2&1\\1&0\end{bmatrix}$ 

剩下的再加上字符串高精就好了。时间复杂度可以看成$O(\log n)$。

```cpp
#include<iostream>
#include<cstdio>
#define mod 1000000007
using namespace std;
long long fp2,fp1,fn,saver;
struct matrix{
	long long m[3][3];
	int l,w;
	void reset(int s,int v){
		l=s;w=v;
		for(register int i=0;i<l;++i)
			for(register int j=0;j<w;++j)
				m[i][j]=0;
	}
	matrix operator *(matrix s){
		matrix z;
		z.reset(l,s.w);
		for(register int i=0;i<z.l;++i)
			for(register int j=0;j<w;++j)
				for(register int k=0;k<z.w;++k)
					z.m[i][k]=(z.m[i][k]+m[i][j]*s.m[j][k])%mod;
		return z;
	}
};
int div(string &s){                                            		//对n>>=1
	int len=s.length(),res=0;
	string ans="";
	for(register int i=0;i<len;++i)
	{
		res=(res<<3)+(res<<1)+s[i]-'0';
		if(res>=2||i!=0){	
  			//如果不在首位需要补0
			ans=ans+char(res/2+'0');
			res=res%2;
		}
		else continue;
	}
	s=ans;
	return res;
}
void quickpow(string n){
	matrix res,x;
  //矩阵初始化
	res.reset(2,1);
	res.m[0][0]=1;res.m[1][0]=0;
	x.reset(2,2);
	x.m[0][0]=2;x.m[0][1]=1;
	x.m[1][0]=1;
  //矩阵快速幂+字符串高精
	while(n.length()>1||n[0]>'0'){
		if(div(n))res=x*res;
		x=x*x;
	}
  //答案输出
	printf("%lld",res.m[1][0]);
}
int main()
{
	string n;
	cin>>n;
	quickpow(n);
	return 0;
}
```



---

## 作者：p_b_p_b (赞：11)

[$$\large\color{purple}My\;Blog$$](https://www.cnblogs.com/p-b-p-b/p/10349253.html)

------

思路如此精妙，代码如此简洁，实是锻炼思维~~水经验~~之好题（大雾

---------

这种题当然是一眼DP啦。

设$dp_n$为把$n$拆分后的答案。为了方便我们设$dp_0=1$

由题意有
$$dp_n=[n=0]+\sum_{i=1}^n dp_{n-i}f_i$$
按照套路，我们考虑它的生成函数$A(x)$


$$A(x)=\sum_n ([n=0]+\sum_{i=1}^n f_i dp_{n-i})x^n$$
$$=1+\sum_{n=1}^{\infty} (\sum_{i=1}^n f_i dp_{n-i})x^n$$
$$=1+\sum_n (\sum_{i=0}^n f_i dp_{n-i})x^n$$
$$=1+A(x)F(x)$$

我们知道$F(x)=\frac{x}{1-x-x^2}$，所以有

$$A(x)=\frac{1}{1-F(x)}=1+\frac{x}{1-2x-x^2}=1+\frac{1}{2\sqrt{2}}(\frac{1}{1-(1+\sqrt{2})x}-\frac{1}{1-(1-\sqrt{2})x})=1+\sum_n \frac{1}{2\sqrt{2}}[(1+\sqrt{2})^n-(1-\sqrt{2})^n]$$

所以
$$Ans_n=\frac{(1+\sqrt{2})^n-(1-\sqrt{2})^n}{2\sqrt{2}}$$
发现题目要求$Ans_n\pmod{1e9+7}$，枚举可得$59713600^2  \equiv 2\pmod{1e9+7} $ ，所以$\sqrt{2}\equiv 59713600 \pmod{1e9+7}$

于是我们在$O(\log n)$的时间内求得了答案！

问题来了：为什么数据范围只有$10^6$呢？我$O(\log n)$快速幂还没有$O(n)$递推快……

代码：

```cpp
#include<bits/stdc++.h>
namespace my_std{
    using namespace std;
    #define pii pair<int,int>
    #define fir first
    #define sec second
    #define MP make_pair
    #define rep(i,x,y) for (int i=(x);i<=(y);i++)
    #define drep(i,x,y) for (int i=(x);i>=(y);i--)
    #define go(x) for (int i=head[x];i;i=edge[i].nxt)
    #define sz 101010
    #define mod (int)(1e9+7)
    typedef long long ll;
    template<typename T>
    inline void read(T& t)
    {
        t=0;char f=0,ch=getchar();
        double d=0.1;
        while(ch>'9'||ch<'0') f|=(ch=='-'),ch=getchar();
        while(ch<='9'&&ch>='0') t=t*10+ch-48,ch=getchar();
        if(ch=='.')
        {
            ch=getchar();
            while(ch<='9'&&ch>='0') t+=d*(ch^48),d*=0.1,ch=getchar();
        }
        t=(f?-t:t);
    }
    template<typename T,typename... Args>
    inline void read(T& t,Args&... args){read(t); read(args...);}
    void file()
    {
        #ifndef ONLINE_JUDGE
        freopen("a.txt","r",stdin);
        #endif
    }
//	inline ll mul(ll a,ll b){ll d=(ll)(a*(double)b/mod+0.5);ll ret=a*b-d*mod;if (ret<0) ret+=mod;return ret;}
}
using namespace my_std;

const ll sqrt2=59713600;
ll ksm(ll x,int y)
{
    ll ret=1;
    for (;y;y>>=1,x=x*x%mod) if (y&1) ret=ret*x%mod;
    return ret;
}
ll inv(ll x){return ksm(x,mod-2);}
int n;

int main()
{
    file();
    read(n);
    cout<<(ksm(1+sqrt2,n)-ksm(mod+1-sqrt2,n)+mod)%mod*inv(2*sqrt2)%mod;
}
```



---

## 作者：TianTian2008 (赞：10)

需要掌握用生成函数解递归式的技巧。

记斐波那契数列的第 $n$ 项为 $f_n$，生成函数为 $F(x)=\sum\limits_{i=0}^\infty f_ix^i$。

记 $n$ 所有拆分的权值之和为 $s_n$，生成函数为 $S(x)=\sum\limits_{i=0}^\infty s_ix^i$。

$\operatorname{DP}$ 可得 $s_n=\sum\limits_{i=0}^{n-1}s_if_{n-i}$，这是卷积的形式，于是考虑把两者的生成函数相乘，有

$\begin{aligned}
F(x)S(x)&=\sum\limits_{i=0}^\infty(\sum\limits_{j=0}^is_jf_{i-j})x^i\\
\because\sum\limits_{j=0}^is_jf_{i-j}&=s_if_0+\sum\limits_{j=0}^{i-1}s_jf_{i-j}=\sum\limits_{j=0}^{i-1}s_jf_{i-j}\\
\therefore F(x)S(x)&=\sum\limits_{i=0}^\infty(\sum\limits_{j=0}^{i-1}s_jf_{i-j})x^i=\sum\limits_{i=1}^\infty s_ix^i\\
\because S(x)&=s_0+\sum\limits_{i=1}^\infty s_ix^i=1+\sum\limits_{i=1}^\infty s_ix^i\\
\therefore F(x)S(x)&=S(x)-1\\
\therefore S(x)&=\frac 1{1-F(x)}=\frac 1{1-\frac x{1-x-x^2}}=\frac{1-x-x^2}{1-2x-x^2}
\end{aligned}$

设 $\begin{aligned}\frac{1-x-x^2}{1-2x-x^2}=\frac{1+Rx}{1-rx}+\frac{Sx}{1-sx}=\frac{1+(R+S-s)x-(rS+sR)x^2}{1-(r+s)x+rsx^2}\end{aligned}$

系数对应可得 $\begin{cases}R+S-s=-1\\rS+sR=1\\r+s=2\\rs=-1\end{cases}$，解得 $\begin{cases}R=-\frac{2+3\sqrt2}4\\S=\frac{2-\sqrt2}4\\r=1+\sqrt2\\s=1-\sqrt2\end{cases}$

$\begin{aligned}
S(x)&=\frac{1-\frac{2+3\sqrt2}4x}{1-(1+\sqrt2)x}+\frac{\frac{2-\sqrt2}4x}{1-(1-\sqrt2)x}\\
&=\frac1{1-(1+\sqrt2)x}-\frac{2+3\sqrt2}4\cdot\frac x{1-(1+\sqrt2)x}+\frac{2-\sqrt2}4\cdot\frac x{1-(1-\sqrt2)x}\\
&=\frac1{1-(1+\sqrt2)x}-\frac{4-\sqrt2}4\cdot\frac{(1+\sqrt2)x}{1-(1+\sqrt2)x}-\frac{\sqrt2}4\cdot\frac{(1-\sqrt2)x}{1-(1-\sqrt2)x}\\
&=\sum\limits_{i=0}^\infty(1+\sqrt2)^ix^i-\frac{4-\sqrt2}4\sum\limits_{i=1}^\infty(1+\sqrt2)^ix^i-\frac{\sqrt2}4\sum\limits_{i=1}^\infty(1-\sqrt2)^ix^i\\
&=1+\sum\limits_{i=1}^\infty\frac{\sqrt2}4((1+\sqrt2)^i-(1-\sqrt2)^i)x^i\\
\therefore s_n&=\frac{\sqrt2}4((1+\sqrt2)^n-(1-\sqrt2)^n)
\end{aligned}$

注意到有费马小定理 $a^{p-1}\equiv1\pmod{p}$，可得 $a^n\equiv a^{n\bmod (p-1)}\pmod{p}$。因此无需高精度快速幂，把 $n$ 模 $10^9+6$ 再使用普通快速幂即可。

到此，得出了此题的思路。

```
#include <iostream>
#include <cstdio>
#include <cstring>
#define mod 1000000007
#define rt2 59713600//模1000000007意义下的根号2 
using namespace std;
typedef long long ll;
int a[100001],b[100001],res[100001];
bool cmp(string s1,string s2)
{
    int n=s1.size(),m=s2.size();
    int i=0;
    while(i<n-1&&s1[i]=='0') ++i;
    s1=s1.substr(i);
    i=0;
    while(i<m-1&&s2[i]=='0') ++i;
    s2=s2.substr(i);
    if(s1.size()!=s2.size()) return s1.size()<s2.size();
    return s1<s2;
}
string sub(string s1,string s2)
{
    int n=s1.size(),m=s2.size(),len=max(n,m);
    for(int i=0;i<n;++i) a[i]=s1[n-1-i]-'0';
    for(int i=n;i<len;++i) a[i]=0;
    for(int i=0;i<m;++i) b[i]=s2[m-1-i]-'0';
    for(int i=m;i<len;++i) b[i]=0;
    for(int i=0;i<len;++i) res[i]=0;
    for(int i=0;i<len;++i)
	{
        res[i]+=a[i]-b[i];
        if(res[i]<0)
		{
            --res[i+1];
            res[i]+=10;
        }
    }
    int i=len-1;
    while(res[i]==0&&i>0) --i;
    string s="";
    for(;i>=0;--i) s+=res[i]+'0';
    return s;
}
string rem(string s1,string s2)
{
    string s="";
    int n=s1.size(),m=s2.size();
    for(int i=0;i<n;++i)
	{
        s+=s1[i];
        while(!cmp(s,s2)) s=sub(s,s2);
    }
    return s;
}
ll ksm(ll x,ll y)
{
	ll res=1;
	while(y)
	{
		if(y&1) res=res*x%mod;
		x=x*x%mod;
		y>>=1;
	}
	return res;
}
int main()
{
	string n;
	cin>>n;
	n=rem(n,"1000000006");//把指数对mod-1取模 
	int len=n.size();
	ll pw=0;
	for(int i=0;i<len;++i) pw=pw*10+n[i]-'0'; 
	printf("%lld",(rt2*ksm(4,mod-2)%mod*(ksm(1+rt2,pw)-ksm(1-rt2,pw))%mod+mod)%mod);
	return 0;
}
```

---

## 作者：asuldb (赞：8)

[题目](https://www.luogu.org/problemnew/show/P4451)

设我们要求的是$g_n$

我们强行定义$g_0=1$

于是就有

$$g_i=\sum_{j=0}^{i-1}fib_{j}g_{i-j}$$

就是新枚举一个$j$，通过一个分配率和在原来的答案上更进一步

于是这个数列的生成函数就是

$$\begin{aligned} G(x)=&\sum_{i=0}(\sum_{j=0}^{i-1}fib_jg_{i-j}+[i=0])x^i\\&=1+\sum_{i=0}(\sum_{j=0}^{i-1}fib_jg_{i-j})x^i\\&=1+\sum_{i=0}\sum_{j=0}^{i-1}fib_{j}x_j\times g_{i-j}x^{i-j}\end{aligned}$$


发现里面是$fib$的生成函数卷上$G(x)$

设

$$F(x)=\sum_{i=0}fib_ix^i=\frac{x}{1-x-x^2}$$

于是就有

$$G(x)=1+G(x)F(x)$$

解得

$$G(x)=\frac{1-x-x^2}{1-2x-x^2}=\frac{1-2x-x^2+x}{1-2x-x^2}=1+\frac{x}{1-2x-x^2}$$

发现多出来的那个常数项是我们强行使得$g_0=1$的结果，不管它就好了

强行处理后面的$\frac{x}{1-2x-x^2}$

我们发现分母上可以被因式分解一下

$$\frac{x}{1-2x-x^2}=\frac{x}{(1-(1-\sqrt{2})x)(1-(1+\sqrt{2})x)}$$

你说怎么搞这个因式分解，你把$1-\sqrt{2}$设成$\frac{a\pm\sqrt{b}}{c}$的形式

就会发现

$$\frac{a+\sqrt{b}}{c}\times \frac{a-\sqrt{b}}{c}=\frac{a^b-b}{c^2}=-1$$

$$-(\frac{a+\sqrt{b}}{c}+ \frac{a-\sqrt{b}}{c})=-2$$

根据下面那个式子我们可以发现$a=c$

于是上面那个式子就是$2a^2-b=0$，我们发现只需要使得$a=1,b=2$就可以了

于是我们就又需要来拆掉这个式子

至于这个如何去拆，我们可以继续列方程

设上面那个式子等于

$$\begin{aligned}&\frac{a}{1-(1-\sqrt{2})x}+\frac{b}{1-(1+\sqrt{2})x}\\&=\frac{a(1-(1+\sqrt{2})x)+b(1-(1-\sqrt{2})x)}{(1-(1-\sqrt{2})x)(1-(1+\sqrt{2})x)}\\&=\frac{a-ax-a\sqrt{2}x+b-bx+b\sqrt{2}x}{(1-(1-\sqrt{2})x)(1-(1+\sqrt{2})x)}\end{aligned}$$

我们知道上面那一大坨东西应该等于$x$

于是

$$a-ax-a\sqrt{2}x+b-bx+b\sqrt{2}x=x$$

由于没有常数项，于是$a=-b$

也就有

$$-a\sqrt{2}x+b\sqrt{2}x=x$$

解得$a=-\frac{1}{2\sqrt{2}},b=\frac{1}{2\sqrt{2}}$，我们$a,b$放到外面就好了

可以拆成

$$-\frac{\sqrt{2}}{4}\times\frac{1}{1-(1-\sqrt{2})x}+\frac{\sqrt{2}}{4}\times \frac{1}{1-(1+\sqrt{2})x}$$

发现有两个诸如$\frac{1}{1-cx}$的生成函数，这就是一个公比为$c$的等比数列

于是我们就可以推出通项

$$g_n=-\frac{\sqrt{2}}{4}\times (1-\sqrt{2})^n+\frac{\sqrt{2}}{4}\times(1+\sqrt{2})^n$$

由于我比较菜，不会二次剩余，可以写个暴力求一下$x^2 \equiv 2(mod\ 1e9+7)$，发现$x=59713600$

根据通项就可以求了，就是一个快速幂的事

```cpp
#include<cstdio>
#define LL long long
const LL mod=1e9+7;
const LL Sqr=59713600;
const LL Inv=250000002;
LL n;
inline LL ksm(LL a,LL b) {LL S=1;while(b) {if(b&1) S=S*a%mod;b>>=1;a=a*a%mod;}return S;}
int main() {
	scanf("%lld",&n);
	printf("%lld\n",((ksm(1+Sqr,n)*Sqr%mod*Inv%mod-ksm(1-Sqr+mod,n)*Sqr%mod*Inv)%mod+mod)%mod);
}
```


---

## 作者：C　C　A (赞：7)

## $[国家集训队]整数的lqp拆分$

$\quad$首先有 $Fibonacci$ 数列的生成函数 ：

$$F(x)=\sum_{i\geqslant1}fib_i\cdot x^i=\frac{x}{1-x-x^2}$$

$\quad$记 $g$ 为答案数列，有 ：

$$g_n=\sum_{m>0,\sum_{i=1}^ma_i=n}\prod_{i=1}^mfib_{a_i}$$

$\quad$若当前已经有 $\sum_{j=1}^{m-1}a_j=i$，那么可以给所有方案加入一个 $a_m=n-i$，使得 $sum_{j=1}^m=n$，且贡献为 $fib_{n-i}$.

$\quad$故得到 $g$ 的递推式 ：

$$g_n=\sum_{i=0}^{n-1}g_i\cdot fib_{n-i}$$

$\quad$特别的，定义 $g_0=1$，于是我们得到了答案的生成函数 ：

$$\begin{aligned}
    G(x)&=\sum_{i\geqslant 0}g_i\cdot x^i\\
    &=\sum_{i\geqslant 0}\left(\sum_{j=0}^{i-1}g_i\cdot fib_{n-i}+[i=0]\right)x^i\\
    &=1+\sum_{i\geqslant 1}\left(\sum_{j=0}^{i-1}g_i\cdot fib_{n-i}\right)x^i
\end{aligned}$$

$\quad$观察到由递推式得到的 $g$ 的生成函数是 $F$ 和 $G$ 的卷积形式，即 ：

$$\sum_{i\geqslant 1}\left(\sum_{j=0}^{i-1}g_i\cdot fib_{n-i}\right)x^i=F(x)\times G(x)$$

$$\therefore G(x)=1+G(x)\times F(x)$$

$$\therefore G(x)=\frac{1}{1-F(x)}=\frac{1-x-x^2}{1-2x-x^2}=1+\frac{x}{1-2x-x^2}$$

$\quad$发现式子中的 $1$ 是为了计算方便强行定义的，于是直接将其去掉，$g$ 的真正生成函数为 ：

$$G(x)=\sum_{i\geqslant 1}g_i\cdot x^i=\frac{x}{1-2x-x^2}$$

$\quad$根据部分分式定理，使用待定系数法将其展开 ：

$$\begin{aligned}
    \frac{x}{1-2x-x^2}&=\frac{A}{1-ax}+\frac{B}{1-bx}\\\\
    &=\frac{(A+B)+(aB-bA)x}{1-(a+b)x+abx^2}
\end{aligned}$$

$\quad$对比系数得到 ：

$$\frac{x}{1-2x-x^2}=\frac{\sqrt{2}}{4}\left(\frac{1}{1-(1+\sqrt{2})x}-\frac{1}{1-(1-\sqrt{2})x}\right)$$

$\quad$故可得 $G(x)$ 的形式幂级数形式 ：

$$\begin{aligned}
    G(x)&=\frac{x}{1-2x-x^2}\\
    &=\frac{\sqrt{2}}{4}\left(\frac{1}{1-(1+\sqrt{2})x}-\frac{1}{1-(1-\sqrt{2})x}\right)\\
    &=\frac{\sqrt{2}}{4}\left(\sum_{i\geqslant 0}(1+\sqrt{2})^i\cdot x^i-\sum_{i\geqslant 0}(1-\sqrt{2})^i\cdot x^i\right)\\
    &=\frac{\sqrt{2}}{4}\sum_{i\geqslant 0}\left[(1+\sqrt{2})^i-(1-\sqrt{2})^i\right]x^i
\end{aligned}$$

$$\therefore g_n=\frac{\sqrt{2}}{4}\left[(1+\sqrt{2})^n-(1-\sqrt{2})^n\right]$$

$\quad$现在考虑如何计算 $g_n$，观察到其中有无理数 $\sqrt{2}$，于是要先求出 $\sqrt{2}$ 在模 $10^9+7$ 意义下的值，即以下同余方程的解 ：

$$x^2\equiv 2\pmod{10^9+7}$$

$\quad$考虑一个更一般的问题 ：求 $\sqrt{n}$ 在模 $p$ 意义下的值。其等价于解下面的同余方程 ：

$$x^2\equiv n\pmod p$$

$\quad$定义 $n$ 是模 $p$ 意义下的二次剩余，当且仅当同余方程 $x^2\equiv n\pmod p$ 有解，也就是存在一个整数在模 $p$ 意义下等价于 $\sqrt{n}$.

$\quad$那么对于一个模 $p$ 意义下的二次剩余 $n$，方程 $x^2\equiv n\pmod p$ 有多少个解呢 $？$

$\quad$假设有多个解，取其中任意两个不同的 $x_1,x_2$，有 ：

$$x_1^2\equiv x_2^2\Longrightarrow (x_1+x_2)(x_1-x_2)\equiv 0\pmod p$$

$\quad$由于 $x_1\not= x_2$，所以 $x_1+x_2\equiv 0\pmod p$. 换而言之，对于任意一个二次剩余 $n$，存在两个解 $x_1,x_2$ 使得方程 $x^2\equiv n\pmod p$ 成立，且它们互为相反数。另外，因为 $p$ 是一个奇质数，所以 $x_1$ 和 $x_2$ 在模 $p$ 意义下不相等。

$\quad$由于任意一个二次剩余都对应一对互为相反数的解，且易知任意一对相反数也对应一个二次剩余，故二次剩余的个数恰为 $\frac{p-1}{2}$.

$\quad$那如何快速判断一个数 $n$ 是否为模 $p$ 意义下的二次剩余呢 $?$

$\quad$由费马小定理可知 ：

$$n^{p-1}\equiv 1\Longrightarrow \left(n^{\frac{p-1}{2}}\right)^2-1\equiv0\pmod p$$

$\quad$所以 $n^{\frac{p-1}{2}}$ 在模 $p$ 意义下可能有两个值，即 $1$ 或 $-1$.

$\quad$如果 $n$ 是二次剩余，那么有 ：

$$n^{\frac{p-1}{2}}\equiv (x^2)^{\frac{p-1}{2}}\equiv x^{p-1}\equiv 1\pmod p$$

$\quad$于是 $n$ 为模 $p$ 意义下的二次剩余当且仅当 $n^{\frac{p-1}{2}}\equiv 1\pmod p$.

$\quad$有了以上两个引理，寻找方程 $x^2\equiv n\pmod p$ 的解可以使用 $\rm Cipolla$ 算法。

$\quad$首先找到一个 $a$，满足 $a^2-n$ 是非二次剩余，我们可以随机找，由于非二次剩余的数量占总数的 $\frac{1}{2}$，所以期望随机两次可以找到。

$\quad$定义 $i^2\equiv a^2-n\pmod p$，但 $a^2-n$ 不是二次剩余，所以在整数域内找不到一个 $i$ 可以满足这个式子，于是考虑扩域，接下来所有数都在类复数域内讨论，每个数都可以被表示为 $a+bi$ 的形式，其中 $a$ 和 $b$ 是模 $p$ 意义下的值，类似于复数的实部和虚部。

$\quad$有 $(a+i)^{p+1}\equiv n\pmod p$，考虑证明。

$\quad$引理 $1$ ：$(a+b)^p\equiv a^p+b^p\pmod p$

> $Proof$.
$$(a+b)^p\equiv \sum_{i=0}^p \dbinom{p}{i}a^i\cdot b^{p-i}\equiv a^p+b^p+\sum_{i=1}^{p-1}\frac{p!}{i!(n-i)!}a^i\cdot b^{n-i}\equiv a^p+b^p\pmod p$$

$\quad$引理 $2$ ：$i^p\equiv -i\pmod p$

> $Proof$.
$$i^p\equiv i(i^2)^{\frac{p-1}{2}}\equiv i(a^2-n)^{\frac{p-1}{2}}\equiv -i\pmod p$$

$$\begin{aligned}
    (a+i)^{p+1}&=(a+i)^p(a+i)\\
    &\equiv (a^p+b^p)(a+i)\\
    &\equiv (a-i)(a+i)\\
    &\equiv a^2-i^2\\
    &\equiv n\pmod p
\end{aligned}$$

$\quad$所以 $x_0=(a+i)^{\frac{p+1}{2}}$ 是方程 $x^2\equiv n\pmod p$ 的一个解。

$\quad$言归正传，用这种方法可以求出 $\sqrt{2}$ 在模 $p$ 意义下的值为 $59713600$ 或 $940286407$.

$\quad$另一方面，由于 $n$ 的值很大，根据费马小定理，可以直接将其对 $p-1$ 取模。

$\quad$综上，我们可以在 $\Theta(\log p)$ 的时间复杂度下求出答案 ：

$$g_n=14928400\times \left(59713601^{n~mod~(p-1)}-940286408^{n~mod~(p-1)}\right)$$

---

## 作者：Prean (赞：4)

题意明确，不再阐述（

首先，众所周知的是 斐波那契数列 的生成函数是 $ F(x)=\frac x {1-x-x^2} $

那么答案就是 $\sum_{i=0} F^i(x) = \frac 1 {1-F(x)} = \frac {1-x-x^2} {1-2x-x^2} $ 的第 $ n $ 项。

首先我们把分子和分母分开考虑，因为如果知道了分母所代表的生成函数的第 $ n $ 项，答案就很明显了。。。

尝试把 $ \frac 1 {1-2x-x^2} $ 分解成 $ \frac A {1-ax} - \frac B {1-bx} $ 的形式。

解 $ -x^2 -2x +1 =0 $ 这个方程，得到 $ x_1 = -1 + \sqrt 2 $，$ x_2 = -1 - \sqrt 2 $

根据因式定理可得：
$$ 1 -2x -x^2 = (-1)(-1 + \sqrt 2 -x)(-1 - \sqrt2 -x) $$
$$ \frac 1 {1 -2x -x^2} = - \frac 1 {(-1 +\sqrt 2 -x)(-1 -\sqrt 2 -x)} $$
然后我们发现 $ \frac 1 {-1 -\sqrt 2 -x} - \frac 1 {-1 +\sqrt 2 -x} = \frac {2\sqrt 2} {(-1 +\sqrt 2 -x)(-1 -\sqrt 2 -x)} $
那么：
$$ \frac 1 {1 -2x -x^2} = (\frac 1 {-1 +\sqrt 2 -x} - \frac 1 {-1 -\sqrt 2 -x})\frac 1 {2\sqrt 2} $$
看一下括号里边的东西，我们知道 $ \frac 1 {a - x} = \frac {\frac 1 a} {1 - \frac 1 a x} $，然后括号里变成了这样：
$$ \frac {1 + \sqrt 2} {1 - (1 + \sqrt 2)x} - \frac {1 - \sqrt 2} {1 - (1 - \sqrt 2)x} $$
显然，第 $ n $ 项为 $ (1 +\sqrt 2)^{n+1} - (1 -\sqrt 2)^{n+1} $

乘上右边的 $ \frac 1 {2\sqrt 2} $ 和 $ 1 -x -x^2 $，答案就是：
$$ \frac 1 {2\sqrt 2}((1 +\sqrt 2)^{n+1} + (1 +\sqrt 2)^n + (1 +\sqrt 2)^{n-1} - ((1 -\sqrt 2)^{n+1} + (1 -\sqrt 2)^n + (1 -\sqrt 2)^{n-1})) $$
化简可得：
$$ ans = \frac {\sqrt 2} 4((1 +\sqrt2)^n - (1 -\sqrt 2)^n) $$
然后我们用[二次剩余](https://www.luogu.com.cn/paste/pzom8ca9)可知：
$$ 59713600 \equiv \sqrt 2 \pmod {10^9+7} $$
那么就可以 $ O(\log mod) $ 愉快地做掉了。

代码：
```cpp
#include<cctype>
#include<cstdio>
const int mod=1e9+7,MOD=mod-1,sqrt2=59713600ll;
inline int Add(const int&a,const int&b){
	return a+b>=mod?a+b-mod:a+b;
}
inline int Del(const int&a,const int&b){
	return a-b<0?a-b+mod:a-b;
}
inline int pow(int a,int b){
	int ans=1;
	for(;b;b>>=1,a=1ll*a*a%mod)if(b&1)ans=1ll*ans*a%mod;
	return ans;
}
signed main(){
	char s=getchar();int n=0;
	while(n=(n*10ll+(48^s))%MOD,s=getchar(),s>=48&&s<=58);
	printf("%d",1ll*sqrt2*pow(4,mod-2)%mod*Del(pow(Add(1,sqrt2),n),pow(Del(1,sqrt2),n))%mod);
}
```

---

## 作者：_Fontainebleau_ (赞：3)

### 题意

- 给定 $n$，求 
- $$\displaystyle\sum_{m>0,a_1,a_2,\ldots,a_m>0,\sum_{i=1}^ma_i=n}\prod_{i=1}^mF_{a_i}$$
- 其中 $F_0=0,F_1=1,F_n=F_{n-1}+F_{n-2}(n>1)$。答案对 $10^9+7$ 取模。
- $1\le{n}\le{10^{10000}}$。

### 做法

#### update 2022.7.4

感谢 $\color{balck}\text{y}\color{red}\text{spm}$ 神仙指出等比数列求和那里的错误。


------------


不妨设最后的答案是 $g_n$，令 $g_0=1$。那么有递推式：

$$g_n=\left[n=0\right]+\sum_{i=1}^{n}g_i\cdot{F_{n-i}}$$


所以就有生成函数：

$$\begin{aligned}G(x)&=\sum_{n=0}^{+\infty}\left(\left[n=0\right]+\sum_{i=1}^ng_i\cdot{F_{n-i}}\right)x^n\\&=1+\sum_{n=1}^{+\infty}\left(\sum_{i=1}^ng_i\cdot{F_{n-i}}\right)x^n\\&=1+\color{yellowgreen}\sum_{n=1}^{+\infty}\left(\sum_{i=1}^ng_i\cdot{x_i}\cdot{F_{n-i}\cdot{x^{n-i}}}\right)\end{aligned}$$

注意 $\color{yellowgreen}\text{yellowgreen}$ 的部分，如果设斐波那契数列的生成函数为 $F(x)=\dfrac{x}{1-x-x^2}$（这总算是基操了吧，就不赘述了），就等于 $G(x)\cdot{F(x)}$。

所以

$$\begin{aligned}G(x)&=1+G(x)\times{F(x)}\\&=\dfrac1{1-F(x)}\\&=\dfrac1{1-\dfrac{x}{1-x-x^2}}\\&=\dfrac{1-x-x^2}{1-2x-x^2}\\&=\dfrac{x^2+x-1}{x^2+2x-1}\\&=1-\dfrac{x}{x^2+2x-1}\end{aligned}$$

在 $\displaystyle\dfrac{1}{1-\left(ax\right)^k}=\sum_{i=0}^{+\infty}\left(ax\right)^{ik}$ 的指导下，我们试着将 $-\dfrac{x}{x^2+2x-1}$ 展开。将 $x^2+2x-1$ 因式分解成 $\left(x-x_1\right)\left(x-x_2\right)$，其中 $x_{1,2}=-1\pm\sqrt{2}$。

$$\begin{aligned}-\dfrac{x}{x^2+2x-1}&=\dfrac{x}{(x-x_1)(x-x_2)}\\&=\dfrac{x}{x_2-x_1}\left(\dfrac1{x-x_1}-\frac1{x-x_2}\right)\\&=\dfrac{x}{x_2-x_1}\left(\frac1{x_2}\frac1{1-\frac{x}{x_2}}-\frac1{x_1}\frac1{1-\frac{x}{x_1}}\right)\\&=\dfrac{x}{x_2-x_1}\left(\frac1{x_2}\sum_{i=0}^{+\infty}\left(\frac{x}{x_2}\right)^i-\frac1{x_1}\sum_{i=0}^{+\infty}\left(\frac{x}{x_1}\right)^i\right)\\&=\frac1{x_2-x_1}\left(\sum_{i=0}^{\infty}\left(\frac{x}{x_2}\right)^{i+1}-\sum_{i=0}^{\infty}\left(\frac{x}{x_1}\right)^{i+1}\right)\end{aligned}$$

那么 $g_n=\left[x^n\right]G(x)=\frac{\sqrt{2}}4\left(\left(1+\sqrt2\right)^n-\left(1-\sqrt2\right)^n\right)$。

由二次剩余可知，$\sqrt{2}$ 在 $\bmod{10^9+7}$ 时等于 $59713600$ 或 $940286407$。

由 FLT，$n$ 可按 $\bmod{10^9+6}$ 理解，于是时间复杂度是 $O(\log{mod})$ 的。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const long long tmz=1e9+7;
const long long z=59713600;
inline long long read()
{
	long long x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-f;c=getchar();}
	while(c>='0'&&c<='9'){x=x*10+c-'0';x%=(tmz-1);c=getchar();}
	return x*f;
}
int n,x1,x2;
long long f(long long x,long long y)
{
	long long res=1,p=x;
	while(y)
	{
		if(y&1)	res=res*p%tmz;
		p=p*p%tmz;y>>=1;
	}
	return res;
}
int main()
{
	n=read();x1=z+1,x2=(1-z+tmz)%tmz;
	printf("%lld\n",(x1*f((2+2*x1)%tmz,tmz-2)%tmz*f(x1,n)%tmz+x2*f((2+2*x2)%tmz,tmz-2)%tmz*f(x2,n)%tmz)%tmz);
	return 0;
}


```



---

## 作者：Aw顿顿 (赞：2)

曾经年少无知的时候把他扔进了任务列表，现在把他清掉吧

是比较清新的一道 Generating Function 的题目

## 分析

题意是显然的，我们只要掌握一些基础知识就行。

简单求一下斐波那契数列生成函数的封闭形式：

$$\begin{aligned}F(x)=0+1x+&1x^2+2x^3+3x^4+5x^5\cdots\\x\cdot F(x)=\quad\ \ \ 0x+&1x^2+1x^3+2x^4+3x^5\cdots\\x^2\cdot F(x)=\ \ \ \quad\quad\quad&0x^2+1x^3+1x^4+2x^5\cdots\end{aligned}$$

容易发现，实际上存在 $F(x)\times(1-x-x^2)=x$。

所以客观上存在 $F(x)=\dfrac{x}{1-x-x^2}$，~~虽然这是常识~~。

我们把答案的第 $n$ 项设为 $g_n$，不难发现根据题意有：

$$g_n=\sum\limits_{i=1}^{n}g_i\times f_{n-i}$$

纯粹以方便为嚆矢设 $g_0=1$，藉谓词函数之表达，容易写出：

$$g_n=[n=0]+\sum\limits_{i=1}^{n}g_i\times f_{n-i}$$

对其求生成函数便得以更进一步：

$$\begin{aligned}G(x)=&\sum\limits_{n=1}^{\infty}\bigg([n=0]+\sum\limits_{i=1}^{n}g_i\times f_{n-i}\bigg)x^n\\=&1+\sum\limits_{n=1}^{\infty}\sum\limits_{i=1}^{n}g_i\times f_{n-i}\\=&F(x)\times G(x)+1\end{aligned}$$

最后将斐波那契数列和答案两者生成函数联系起来的式子可谓是切中肯絮，经过简单的代数变换不难得到：

$$\dfrac{x}{1-x-x^2}\times G(x)+1=G(x)$$

$$1=G(x)\times\left(1-\dfrac{x}{1-x-x^2}\right)$$

所以 $G(x)$ 的封闭形式呼之欲出：

$$\dfrac{1}{1-F(x)}=1+\dfrac{x}{x^2+2x-1}$$

对于分母求其二根得 $x_{1,2}=-1\pm\sqrt{2}$，进一步将原式因式分解得：

$$1+\dfrac{x}{x^2+2x-1}=1+\dfrac{x}{(1-x+\sqrt{2}x)(1-x-\sqrt{x})}$$

然后你简单推一下特值基本上就能发现：

$$a_n=\dfrac{\sqrt 2-1}{2\sqrt 2}(-\sqrt 2+1)^n+\dfrac{\sqrt 2+1}{2\sqrt 2}(\sqrt 2+1)^n$$

对于 $\sqrt{2}$ 这一部分你可能需要用二次剩余的结论来处理，也就是说在模 $10^9+7$ 意义下，存在：

$$\sqrt{2}\equiv59713600\pmod{10^9+7}$$

最后代码里可以用费马小定理和快速幂解决这题。

~~写代码一开始不知道为啥被卡到 60 分了~~

然后你可以把逆元部分先处理好一下，要不然可能会 T，另外答案是 $a_{n-1}$ 而不是 $a_n$，并且你实际上读入的时候要对 $10^9+6$ 取模，否则会出事。

给出代码：

```cpp
#include<bits/stdc++.h>
#define int long long 
#define mod 1000000007
#define s2 59713600
#define Inv 14928400
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;x=x%(mod-1);ch=getchar();}
	return x*f%(mod-1);
}int n,c1,c2;
int ksm(int a,int b){
	int ans=1;
	while(b){
		if(b&1)ans=ans*a%mod;
		a=a*a%mod;
		b>>=1;
	}return ans;
}signed main(){
	n=read();
	c1=(s2-1)%mod;c2=(s2+1)%mod;
	cout<<((c1*ksm(1+mod-s2,n-1)%mod
		   +c2*ksm(s2+1,n-1)%mod)%mod)*Inv%mod;
	return 0;
}
```




---

## 作者：cirnovsky (赞：2)

## 题意简述

求

$$
\sum\prod_{i=1}^{m}F_{a_{i}},(m>0,a_{1},\cdots a_{m}>0,\sum a_{i}=n)
$$

## 题解

这是一篇不用 $\mathbf{OGF}$ 的题解。

设 $f_{i}$ 为 $i$ 的 $\operatorname{lqp}$ 拆分值。

然后有显然的过不了递推式：

$$
f_{n}=\begin{cases}
1,n=0 \\
\displaystyle
\sum_{i=0}^{n-1}F_{n-i}\times f_{i},n\neq0
\end{cases}
$$

然后传统艺能错位相减操作一下：

$$
\begin{aligned}
f_{n}&=\sum_{i=0}^{n-1}F_{n-i}\times f_{i} \\
f_{n-1}&=\sum_{i=0}^{n-2}F_{n-i-1}\times f_{i} \\
f_{n-2}&=\sum_{i=0}^{n-3}F_{n-i-2}\times f_{i}
\end{aligned}
\Longrightarrow
\begin{aligned}
f_{n}-f_{n-1}-f_{n-2}&=\sum_{i=0}^{n-1}F_{n-i}\times f_{i}-\sum_{i=0}^{n-2}F_{n-i-1}\times f_{i}-\sum_{i=0}^{n-3}F_{n-i-2}\times f_{i} \\
f_{n}-f_{n-1}-f_{n-2}&=(F_{2}-F_{1})\times f_{n-2}+F_{1}\times f_{n-1}
\end{aligned}
\\
\downarrow \\
f_{n}=2f_{n-1}+f_{n-2}
$$

递推公式有了，然后矩阵快速幂：

$$
\begin{bmatrix}
f_{n} \\
f_{n-1}
\end{bmatrix}
=\begin{bmatrix}
2f_{n-1}+f_{n-2} \\
f_{n-1}
\end{bmatrix}
=\begin{bmatrix}
f_{n-1} \\
f_{n-2}
\end{bmatrix}
\times\begin{bmatrix}
2 & 1 \\
1 & 0
\end{bmatrix}
$$

这样就可以做了（吗？）：

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <queue>
#define mod ( 1000000007 )

using namespace std;
typedef long long LL;

template<typename _T, typename _P>
_T qkpow( _T bas, _T one, _P fur ){
	_T res = one;
	while( fur != 0 ){
		if( fur % 2 == ( _P )1 )	res = bas * res;
		bas = bas * bas;
		fur /= 2;
	}
	return res;
}

template<typename _T>
_T add( _T x, _T y ){ if( y >= mod )	y %= mod; x += y; if( x >= mod )	x -= mod; return x; }

struct bigInt : vector<int>{
	bigInt &check( ){
		while( ! empty( ) && ! back( ) ) pop_back( );
		if( empty( ) )	return *this;
		for( unsigned i = 1; i < size( ); ++ i ){ ( *this )[i] += ( *this )[i - 1] / 10; ( *this )[i - 1] %= 10; }
		while( back( ) >= 10 ){ push_back( back( ) / 10 ); ( *this )[size( ) - 2] %= 10; }
		return *this;
	}
	bigInt( int tpN = 0 ){ push_back( tpN ); check( ); }
};
istream &operator >> ( istream &is, bigInt &tpN ){
	string s;
	is >> s; tpN.clear( );
	for( int i = s.size( ) - 1; i >= 0; --i ) tpN.push_back( s[i] - '0' );
	return is;
}
ostream &operator << ( ostream &os, const bigInt &tpN ){
	if( tpN.empty( ) )	os << 0;
	for( int i = tpN.size( ) - 1; i >= 0; --i )	os << tpN[i];
	return os;
}
bool operator != ( const bigInt &one, const bigInt &another ){
	if( one.size( ) != another.size( ) )	return 1;
	for( int i = one.size( ) - 1; i >= 0; --i ){
		if( one[i] != another[i] )	return 1;
	}
	return 0;
}
bool operator == ( const bigInt &one, const bigInt &another ){
	return ! ( one != another );
}
bool operator < ( const bigInt &one, const bigInt &another ){
	if( one.size( ) != another.size( ) )	return one.size( ) < another.size( );
	for( int i = one.size( ) - 1; i >= 0; --i ){
		if( one[i] != another[i] )	return one[i] < another[i];
	}
	return 0;
}
bool operator > ( const bigInt &one, const bigInt &another ){ return another < one; }
bool operator <= ( const bigInt &one, const bigInt &another ){ return ! (one > another ); }
bool operator >= ( const bigInt &one, const bigInt &another ){ return ! (one < another ); }
bigInt &operator += ( bigInt &one, const bigInt &another ){
	if( one.size( ) < another.size( ) )	one.resize(another.size( ) );
	for( unsigned i = 0; i != another.size( ); ++ i ) one[i] += another[i];
	return one.check( );
}
bigInt operator + ( bigInt one, const bigInt &another ){ return one += another; }
bigInt &operator -= ( bigInt &one, bigInt another ){
	if( one < another )	swap( one, another );
	for( unsigned i = 0; i != another.size( ); one[i] -= another[i], ++ i ){
		if( one[i] < another[i] ){
			unsigned j = i + 1;
			while( ! one[j] ) ++ j;
			while( j > i ){ -- one[j]; one[--j] += 10; }
		}
	}
	return one.check( );
}
bigInt operator - ( bigInt one, const bigInt &another ){ return one -= another; }
bigInt operator * ( const bigInt &one, const bigInt &another ){
	bigInt tpN;
	tpN.assign( one.size( ) + another.size( ) - 1, 0 );
	for( unsigned i = 0; i != one.size( ); ++ i ){
		for( unsigned j = 0; j != another.size( ); ++ j ) tpN[i + j] += one[i] * another[j];
	}
	return tpN.check( );
}
bigInt &operator *= ( bigInt &one, const bigInt &another ){ return one = one * another; }
bigInt divMod( bigInt &one, const bigInt &another ){
	bigInt ans;
	for( int t = one.size( ) - another.size( ); one >= another; -- t ){
		bigInt tpS;
		tpS.assign( t + 1, 0 );
		tpS.back( ) = 1;
		bigInt tpM = another * tpS;
		while( one >= tpM ){ one -= tpM; ans += tpS; }
	}
	return ans;
}
bigInt operator / ( bigInt one, const bigInt &another ){ return divMod(one, another ); }
bigInt &operator /= ( bigInt &one, const bigInt &another ){ return one = one / another; }
bigInt &operator %= ( bigInt &one, const bigInt &another ){ divMod( one, another ); return one; }
bigInt operator % ( bigInt one, const bigInt &another ){ return one %= another; }

struct matrixS{
	int mat[2][2];
	matrixS( int x = 0 ){ memset( mat, x, sizeof( mat ) ); }
	matrixS operator * ( const matrixS &another ) const{
		matrixS res;
		for( int i = 0; i < 2; ++ i ){
			for( int j = 0; j < 2; ++ j ){
				for( int k = 0; k < 2; ++ k )	res.mat[i][j] = add( ( LL )res.mat[i][j], ( LL )mat[i][k] * another.mat[k][j] );
			}
		}
		return res;
	}
} unit, erng;

bigInt N;

void progressBaseInformation( ){
	int unitS[2][2] = { { 1, 0 }, { 0, 1 } };
	memcpy( unit.mat, unitS, sizeof( unitS ) );
	int erngS[2][2] = { { 2, 1 }, { 1, 0 } };
	memcpy( erng.mat, erngS, sizeof( erngS ) );
}

signed main( ){
	ios::sync_with_stdio( 0 ); cin.tie( 0 ); cout.tie( 0 );
	progressBaseInformation( );
	cin >> N; cout << qkpow( erng, unit, N ).mat[1][0] << '\n';
	return 0;
}
```

不，凉心出题人友好地卡了高精的常数，于是你打开题解，发现 $f_{n}=f_{n\bmod (10^{9}+6)}$，于是你又行了。

```cpp
#include <cstdio>
#include <cstring>
#include <queue>
#define mod ( 1000000007 )

using namespace std;
typedef long long LL;

template<typename _T>
void read( _T &x ){
	x = 0; char c = getchar( ); _T f = 1;
	while( c < '0' || c > '9' ){ if( c == '-' )	f = -1; c = getchar( ); }
	while( c >= '0' && c <= '9' ){ x = ( ( x << 3 ) + ( x << 1 ) + ( c & 15 ) ) % ( mod - 1 ); c = getchar( ); }
	x *= f;
}

template<typename _T>
void write( _T x ){
	if( x < 0 ){ putchar( '-' ); x = -x; }
	if( x > 9 )	write( x / 10 );
	putchar( x % 10 + '0' );
}

template<typename _T, typename _P>
_T qkpow( _T bas, _T one, _P fur ){
	_T res = one;
	while( fur != 0 ){
		if( fur % 2 == ( _P )1 )	res = bas * res;
		bas = bas * bas;
		fur /= 2;
	}
	return res;
}

template<typename _T>
_T add( _T x, _T y ){ if( y >= mod )	y %= mod; x += y; if( x >= mod )	x -= mod; return x; }

struct matrixS{
	int mat[2][2];
	matrixS( int x = 0 ){ memset( mat, x, sizeof( mat ) ); }
	matrixS operator * ( const matrixS &another ) const{
		matrixS res;
		for( int i = 0; i < 2; ++ i ){
			for( int j = 0; j < 2; ++ j ){
				for( int k = 0; k < 2; ++ k )	res.mat[i][j] = add( ( LL )res.mat[i][j], ( LL )mat[i][k] * another.mat[k][j] );
			}
		}
		return res;
	}
} unit, erng;

LL N;

void progressBaseInformation( ){
	int unitS[2][2] = { { 1, 0 }, { 0, 1 } };
	memcpy( unit.mat, unitS, sizeof( unitS ) );
	int erngS[2][2] = { { 2, 1 }, { 1, 0 } };
	memcpy( erng.mat, erngS, sizeof( erngS ) );
}

signed main( ){
	progressBaseInformation( );
	read( N ); write( qkpow( erng, unit, N ).mat[1][0] ), putchar( '\n' );
	return 0;
}
```

---

## 作者：chihik (赞：2)

设整数 $n$ 的 $\text{lqp}$ 拆分权值为 $g(n)$ , 那么有：

$$\begin{cases}
g(n)=1 & (n=0) \\
\displaystyle g(n)=\sum_{i=0}^{n-1} fib(i) \times g(n-i) & (n \not=0)
\end{cases}$$

令 $F(x)$ 为斐波拉契数列的 $\text{OGF}$ , $G(x)$ 为 $g$ 的 $\text{OGF}$。

卷积就是生成函数的乘法，得到：

$$G=F*G+1$$

( 多出来的 $1$ 是让 $g(0)=1$ 的原因 )

又有斐波拉契数列的生成函数：

$$F(x)=\frac{1}{1-x-x^2}$$

那么：

$$G(x)=\frac{1-x-x^2}{1-2x-x^2}$$

$$G(x)=1+\frac{x}{1-2x-x^2}$$

想办法将后面的分数拆开，不妨令 $\frac{x}{1-2x-x^2}=A(\frac{1}{ax-1}-\frac{1}{bx-1})$

然后对比系数解出：

$$\begin{cases}
A=\frac{\sqrt 2}{4} \\
a=1+\sqrt{2} \\
b=1-\sqrt{2} \\
\end{cases}$$

$$G(x)=1+\frac{\sqrt 2}{4}(\frac{1}{1-(1+\sqrt{2})x} - \frac{1}{1-(1-\sqrt{2})x})$$

那么得到：

$$g(n)=\frac{\sqrt 2}{4} ((1+\sqrt {2})^n - (1-\sqrt {2})^n)$$

经过枚举你发现 $\sqrt{2}\equiv 59713600 ( \bmod 1e9+7 )$

那么用费马小定理处理指数就可以了。

```cpp
#include <cstdio>

const int Mod = 1e9 + 7 , Sqrt2 = 59713600;

int Quick_pow( int x , int po ) {
    x = ( x % Mod + Mod ) % Mod;
    int Ans = 1;
    for( ; po ; po >>= 1 , x = 1ll * x * x % Mod )
        if( po & 1 ) Ans = 1ll * Ans * x % Mod;
    return Ans;
}
int Inv( int x ) {
    return Quick_pow( x , Mod - 2 );
}

void Read( int &x ) {
    x = 0; char s = getchar();
    for( ; '0' <= s && s <= '9' ; s = getchar() ) x = ( 10ll * x + s - '0' ) % ( Mod - 1 );
}

int n;
int main( ) {
    Read( n );
    printf("%d\n", ( 1ll * Sqrt2 * Inv( 4 ) % Mod * ( Quick_pow( 1 + Sqrt2 , n ) - Quick_pow( 1 - Sqrt2 , n ) + Mod ) % Mod + Mod ) % Mod );
    return 0;
}
```

---

## 作者：Taduro (赞：2)

生成函数一血祭。

首先设答案为$g(n)$，有一个显然的递推式：$g(n)=\sum_{i=1}^nfib_{i}\times g_{n-i}$，另外$g_0=1$

那么他的生成函数：
$$
G(x)=\sum_{n=0}g_nx^n
$$

$$
=\sum_{n=0}(\sum_{i=0}^{n-1}fib_ig_{n-i}+[n=0])x^n
$$

$$
=1+\sum_{n=0}x^n\sum_{i=0}^{n-1}fib_ig_{n-i}
$$

$$
=1+\sum_{n=0}\sum_{i=0}^{n-1}fib_ix^i\times g_{n-i}x^{n-i}
$$

就可以看成：
$$
G(x)=1+F(x)\times G(x)
$$
$F(x)$是斐波那契数列的生成函数，众所周知：
$$
F(x)=\frac{x}{1-x-x^2}
$$
那么：
$$
G(x)=\frac{1-x-x^2}{1-2x-x^2}=1+\frac{x}{1-2x-x^2}
$$
$1-2x-x^2$可以因式分解成$(1-(1+\sqrt2)x)(1-(1-\sqrt2)x)$

两项的差是$2\sqrt2x$，那么我们来把他裂项：
$$
G(x)=1+\frac{x}{2\sqrt2x}(\frac{1}{1-(1+\sqrt2)x}-\frac{1}{1-(1-\sqrt2)x})
$$
不管那个一，我们已经得到了想要的式子，这是一个第$n$系数为$\frac{((1+\sqrt2)x)^n-((1-\sqrt2)x)^n}{2\sqrt2}$的多项式，同时这个系数也是我们要求的答案。

所以我们求出了$G(x)$的通项

PS： $\sqrt2≡59713600(mod\ 1e9+7)$

```c++
#include<cstdio>
#include<iostream>
#define re register
#define mod 1000000007
const int s2=59713600;
using namespace std;
inline int add(re int x,re int y){return x+y>=mod?x+y-mod:x+y;}
inline int dec(re int x,re int y){return x-y<0?x-y+mod:x-y;}
inline int mul(re int x,re int y){return 1ll*x*y-1ll*x*y/mod*mod;}
inline int ksm(int a,int b){
	int res=1;
	while (b){
		if (b&1) res=mul(res,a);
		a=mul(a,a); b>>=1;
	}
	return res;
}
int main(){
	int n; scanf("%d",&n);
	printf("%d\n",mul(dec(ksm(add(1,s2),n),ksm(dec(1,s2),n)),
	ksm(mul(2,s2),mod-2)));
	return 0;
}
```



---

## 作者：localhost (赞：1)

[更好的阅读体验,~~如果下面LaTeX炸了可以看这个~~](https://blog.zcmimi.top/posts/LG%204451%20[%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F]%E6%95%B4%E6%95%B0%E7%9A%84lqp%E6%8B%86%E5%88%86)


拆分为$m$项时,生成函数为$F^m (x)$

那么答案的生成函数为$\displaystyle G(x)=\sum_{i=0}^{\infty} F^i(x)$

$F$为斐波那契数列生成函数,$\displaystyle F(x)=\frac x{1-x-x^2}$

$
\begin{aligned}
G(x)
&=\sum_{i=0}^{\infty} F^i(x)\\
&=\frac 1{1-F(x)}\\
&=\frac {1-x-x^2}{1-2x-x^2}\\
&=1+\frac x{1-2x-x^2}\\
&=1+\frac x{[1-(1+\sqrt 2)x][1-(1-\sqrt2)x]}\\
&=1+\frac 1{2\sqrt 2}\left( \frac 1{1-(1+\sqrt 2)x} - \frac 1{1-(1-\sqrt 2)x} \right)\\
&=1+\sum_{i=1}^{\infty} \frac{(1+\sqrt 2)^i-(1-\sqrt 2)^i}{2\sqrt 2} x^i
\end{aligned}
$

那么:

$\displaystyle
ans_n=\frac{(1+\sqrt 2)^n-(1-\sqrt 2)^n}{2\sqrt 2}
$

其中$\sqrt 2 \equiv 59713600 \pmod{10^9+7}$(二次剩余)

这样的话:

$\displaystyle
\begin{aligned}
ans_n
&=\frac {\sqrt 2}4\left[(1+\sqrt 2)^n-(1-\sqrt 2)^n\right]\\
&\equiv 59713600\times 250000002\times [(1+59713600)^n-(1-59713600)^n] \pmod{10^9+7}
\end{aligned}
$

使用快速幂复杂度$O(\log n)$

考虑费马小定理: $ans_n \equiv ans_{n \mod 10^9+6}$

这样就可以把$n$压到$10^9+6$以内了,再快速幂即可

```cpp
#include<cstdio>
const int P=1000000007;
int n;
void readn(){
    char c;int p=P-1;
    for(c=getchar();c<'0'||'9'<c;c=getchar());
    for(n=c-48,c=getchar();'0'<=c&&c<='9';n=(10ll*n+c-48)%p,c=getchar());
}
int pw(int x,int b){
    int res=1;
    while(b){
        if(b&1)res=1ll*res*x%P;
        b>>=1,x=1ll*x*x%P;
    }
    return res;
}
int main(){
    readn();
    int t=1ll*59713600*250000002%P,
        a=(pw(59713601,n)-pw(940286408,n)+P)%P;
    printf("%d\n",1ll*t*a%P);
}
```

~~luogu最近LaTeX有点锅(已经保证编辑页面和博客页面没炸了,如果炸了希望管理能够帮忙修一下)~~

---

## 作者：Cyhlnj (赞：1)

构造 $fib$ 数列的母函数 $F(x)$

那么答案就是
$$[x^n]\sum_{i=1}^{\infty}F^i(x)=[x^n]\frac{F(x)}{1-F(x)}$$

而

$$F(x)=xF(x)+x^2F(x)+x,F(x)=\frac{x}{1-x-x^2}$$

所以答案就是

$$[x^n]\frac{x}{1-2x-x^2}$$

递推式出来了直接 $\Theta(n)$ 递推

或者求出通项

$$\frac{(\sqrt{2}+1)^n-(1-\sqrt{2})^n}{2\sqrt{2}}$$
然后 $\Theta(logn)$ 出解

所以这个题目的 $n$ 大概可以出的更大一些吧

```cpp
# include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int mod(1e9 + 7);

inline int Inc(int x, int y) {
	return x + y >= mod ? x + y - mod : x + y;
}

inline int Dec(int x, int y) {
	return x - y < 0 ? x - y + mod : x - y;
}

inline int Pow(ll x, int y) {
	register ll ret = 1;
	for (x = (x % mod + mod) % mod; y; y >>= 1, x = x * x % mod)
		if (y & 1) ret = ret * x % mod;
	return ret;
}

struct Pair {
	int a, b;

	inline Pair() {
		a = b = 0;
	}

	inline Pair(int _a, int _b) {
		a = _a, b = _b;
	}

	inline Pair operator +(Pair x) const {
		return Pair(Inc(a, x.a), Inc(b, x.a));
	}

	inline Pair operator -(Pair x) const {
		return Pair(Dec(a, x.a), Dec(b, x.b));
	}

	inline Pair operator *(Pair x) const {
		return Pair(((ll)a * x.a + (ll)2 * b * x.b) % mod, ((ll)a * x.b + (ll)x.a * b) % mod);
	}

	inline Pair operator /(Pair x) const {
		register Pair t1(a, b), t2(x.a, mod - x.b), t3(Pow((ll)x.a * x.a - (ll)2 * x.b * x.b, mod - 2), 0);
		return t1 * t2 * t3;
	}
} v1, v2, v3;

int n, x;

int main() {
    scanf("%d", &n), v1 = Pair(1, 1), v2 = Pair(1, mod - 1);
	for (v3 = Pair(1, 0), x = n; x; x >>= 1, v1 = v1 * v1) if (x & 1) v3 = v3 * v1;
	for (v1 = Pair(1, 0), x = n; x; x >>= 1, v2 = v2 * v2) if (x & 1) v1 = v1 * v2;
	v1 = (v3 - v1) / Pair(0, 2), printf("%d\n", v1.a);
    return 0;
}
```

---

## 作者：1lgorithm (赞：1)

最近自学了离散数学，所以找几道生成函数的题做一做。

首先，我先来科普一下生成函数是什么吧。

对于一个数列 $ \{a_{n}\} $,有一个函数 $G$ ,使得

$ G(x)=\sum_{i=1}^{+\infty} a_{i}x^{i}$

那么称 $G(x)$ 是 $\{a_{n}\}$ 的生成函数。

如对于 $a_{n} = 1 $ 这个数列，他的生成函数是

$ G(X) = \sum_{i=1}^{+\infty} x^{i} = \frac{1}{1-x}$.

对于斐波那契数列，有

$ F(X) $

$=\sum_{i=1}^{+\infty} f_{i}x^{i} $

$=\sum_{i=1}^{+\infty}(\frac {(\frac{1+\sqrt{5}}{2})^i-(\frac{1-\sqrt{5}}{2})^i}{\sqrt{5}})x^i $

$=\frac{1}{\sqrt{5}}(\sum_{i=1}^{+\infty}(\frac{1+\sqrt{5}}{2})^{i}x^i-\sum_{i=1}^{+\infty}(\frac{1-\sqrt{5}}{2})^{i}x^i) $

$ =\frac{1}{\sqrt{5}}(\frac{1}{1-\frac{1+\sqrt{5}}{2}x}-\frac{1}{1-\frac{1-\sqrt{5}}{2}x})$

$=\frac{1}{\sqrt{5}}(\frac{2}{2-x-\sqrt{5}x}-\frac{2}{2-x+\sqrt{5}x})$

$=\frac{x}{1-x-x^2}$

对于这个题，我们设 $ a_{i} $ 表示 $ i $ 个数的结果。

我们设$ a_0=1$

那么，我们先求出这个题数列的递推公式$ (n>0)$：

$a_{n}=\sum_{i=0}^{n-1}a_{i}f_{n-i}$

其生成函数为

$G(x)$

$=\sum_{i=0}^{+\infty}(\sum_{j=0}^{i-1}a_{j}f_{n-j})x^i$

$=1+\sum_{i=1}^{+\infty}(\sum_{j=0}^{i}a_{j}f_{n-j})x^i$

$=1+G(x)F(x)$

所以$ G(x)(1-F(x))=1$

那么 $G(x)=\frac{1}{1-\frac{x}{1-x-x^2}}=\frac{1-x-x^2}{1-2x-x^2}$

$ G(x)=1+\frac{x}{1-2x-x^2} $

所以$a_{n}=\frac{(1+\sqrt{2})^{n}-(1-\sqrt2)^{n}}{2\sqrt{2}}=\sqrt{2}\frac{(1+\sqrt{2})^{n}-(1-\sqrt2)^{n}}{4}$

而$ \sqrt{2} $在模$1e9+7$的情况下的值是59713600，所以我们用快速幂 + 费马小定理计算即可。

代码：

```cpp
#include<iostream>
using namespace std;
long long input(long long mod){
	string a;
	cin>>a;
	long long sum=0;
	for(int i=0;i<a.size();i++){
		sum=sum*10+a[i]-'0';
		sum%=mod;
	}
	return sum;
}
long long qpmod(long long a,long long b,long long p){
	long long ans=1;
	while(b){
		if(b&1ll) ans=ans*a%p;
		a=a*a%p;
		b>>=1;
	}
	return ans;
}
int main(){
	long long sqrt2=59713600;
	long long plussqrt2=1+sqrt2;
	long long minussqrt2=(long long)(1e9+8-sqrt2)%1000000007;
	long long inv2sqrt2=1000000008/4*sqrt2%1000000007;
	//(plus^n-minus^n)*inv2%(1e9+7)
	long long n=input(1000000006);
	cout<<(qpmod(plussqrt2,n,1000000007)-qpmod(minussqrt2,n,1000000007)+1000000007)%1000000007*inv2sqrt2%1000000007;
}
```


---

## 作者：Alear (赞：1)

[题面传送门](https://www.luogu.com.cn/problem/P4451)

主要是想讲一个个人觉得比较容易想的推出线性递推式的方法。

显然的有非线性的递推式子: $f_n = \sum\limits_{i=0}^{n-1}fib_{n-i}\ f_i$， $f_0=1$。

相当于枚举第一位之后的和。

这样子写有一个好处就是 $f_i$ 是对齐，$fib_{n-i}$ 在变化，而斐波那契数列的有简单的递推式可以用来加减消去式子。

考虑构造连续三项：
$$
\begin{aligned}
f_n &= \sum\limits_{i=0}^{n-1}fib_{n-i}\ f_i\\
f_{n-1} &= \sum\limits_{i=0}^{n-2}fib_{n-i-1}\ f_i\\
f_{n-2} &= \sum\limits_{i=0}^{n-3}fib_{n-i-2}\ f_i
\end{aligned}
$$
这样子我们就有了相邻三项的斐波那契数列了，拿式子加减一下，比较末尾的两项：
$$
\begin{aligned}
f_n - f_{n-1} - f_{n-2} &= (fib_2-fib_1)f_{n-2}+fib_1f_{n-1}\\
f_n&=2f_{n-1}+f_{n-2}
\end{aligned}
$$

这样，朝思暮想的递推方程就有了。

不过单是递推还切不动这道题，十进制矩阵快速幂略显麻烦，这里推一下通项。

列出特征方程：$x^2=2x+1$

解得：$x=1\pm\sqrt 2$

通项的形式有了：$f_n=A(1+\sqrt 2)^n+B(1-\sqrt 2)^n$

用待定系数法解一下就可以了。

这里还有一个坑爹的地方，由于原始递推式要求 $n\geqslant 1$ ，而我们推式子的过程用到了 $n-2$， 也就是说这个求出来的递推式只有在 $n\geqslant 3$ 的时候才成立，通项从 $1$ 开始成立，而不保证 $0$ 处的正确性，因此不能使用 $n=0$ 的方程来解系数。  
我一开始习惯性地用了 $0$ 处的式子，没多想，结果因为求出来的式子明明前两项对了后面却错了，迷惑了半天。

最终式子长这样：$f_n=\cfrac{(1+\sqrt 2)^n-(1-\sqrt 2)^n}{2\sqrt 2}$， 是一个带根号的式子，考虑到 $2$ 是 $1e9+7$ 的二次剩余，我们可以使用 $59713600$ 来代替 $\sqrt 2$，这道题就做完了。

哦对了，由于这道题数据范围很大，而 $n$ 在指数上，所以可以使用欧拉定理可以简化计算，普通快速幂就可以搞定。

```cpp
#include<bits/stdc++.h>
#define next nxt
#define int long long
using namespace std;
typedef long long ll;
const int N =1e6, mod=1e9+7, sqrt2=59713600, phi=mod-1;
const int alpha=sqrt2+1, beta=mod+1-sqrt2;
int read(){
	int c=0,nx,sign=1;
	while(!isdigit(nx = getchar()))
		if(nx=='-')
			sign=-1;
	while(isdigit(nx))
		c=(c*10+nx-'0')%phi,nx=getchar();//在这里对读入取模了
	return sign*c;
}
inline int fast(int a, int b, int ans=1){
	for(;b;b>>=1,a=a*a%mod)
		if(b&1)
			ans=ans*a%mod;
	return ans; 
}
int inv[N];
int a = fast(2 * sqrt2 % mod, mod - 2), b = mod - a;

signed main(){
	int n = read() + phi;
	printf("%lld\n", (fast(alpha, n, a) + fast(beta, n, b)) % mod);
}
```



---

## 作者：_LHF_ (赞：1)

# 题解
首先，我们可以整理出一个式子：$dp[i]=\sum_{j=1}^{i-1}dp[j]F[i-j]$

其中：F[i]表示斐波那契数列的第$i$项,其中，$F[0]=0,F[1]=1$。

然后得到
$$dp[n+1]-dp[i]=\sum_{j=1}^ndp[j]F[i-j+1]-\sum_{j=1}^{n-1}dp[j]F[i-j]$$
然后合并一下，得：
$$dp[n+1]-dp[n]=\sum_{i=1}^{n-1}dp[j](F[i-j+1]-F[i-j])+dp[n]$$
之后利用斐波那契数列的性质，得：
$$dp[n+1]-dp[n]=\sum_{i=1}^{n-1}dp[j]F[i-j-1]+dp[n]$$
因为$F[0]=0$，得：
$$dp[n+1]-dp[n]=\sum_{i=1}^{n-2}dp[j]F[i-j-1]+dp[n]$$
$$dp[n+1]-dp[n]=dp[n-1]+dp[n]$$
$$dp[n+1]=2\times dp[n]+dp[n-1]$$
好了，式子推出来了，接下来怎么办？暴力，直接递推？期望得分：$0pts$。

看一看，对于60%的数据$n \leq 10^9$，怎么办呢？

应该用矩阵快速幂来解决。

建议大家先看一看这篇题解：[矩阵加速](https://www.luogu.com.cn/blog/LHF/solution-p1939)，尤其是没有学过这一方面问题的人。

接着直接按照矩阵加速的老套路，得到：
$$\begin{bmatrix}2&1\\1&0\end{bmatrix}$$
然后套矩阵快速幂即可。

于是，我们得到了60分的代码：
```cpp
#include<cstdio>
#define N 110
#define mod 1000000007
using namespace std;
struct matrix
{
	long long a[N][N];
} s,ans;
int n=2;
matrix operator *(matrix &a,matrix &b)
{
	matrix x;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			x.a[i][j]=0;
			for(int k=1;k<=n;k++)
			{
				x.a[i][j]=(x.a[i][j]+a.a[i][k]*b.a[k][j])%mod;
			}
		}
	}
	return x;
}
int getans(int k)
{
	matrix ans;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++) s.a[i][j]=0,ans.a[i][j]=0;
	s.a[1][1]=2;
	s.a[1][2]=1;
	s.a[2][1]=1;
	ans.a[1][1]=ans.a[2][2]=1;
	while(k)
	{
		if(k&1) ans=ans*s;
		k=k>>1;
		s=s*s;
	}
	return ans.a[2][1];
}
int T=1,a;
int main()
{
	while(T--)
	{
		scanf("%d",&a);
		printf("%d\n",getans(a));
	}
}
```
再看一看：对于100%的数据，$n\leq10^{10000}$，怎么办？

凉拌啦！

直接用高精度除法就行了。

那，用不用高精度取模呢？根本不用，毕竟判断一个是是否是偶数只用看它的各位是不是偶数罢了。
```cpp
#include<cstdio>
#include<cstring>
#define N 110
#define M 10100
#define mod 1000000007
using namespace std;
struct matrix
{
	long long a[N][N];
} s,ans;
int n=2,a[M],len;
matrix operator *(matrix &a,matrix &b)
{
	matrix x;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			x.a[i][j]=0;
			for(int k=1;k<=n;k++)
			{
				x.a[i][j]=(x.a[i][j]+a.a[i][k]*b.a[k][j])%mod;
			}
		}
	}
	return x;
}
bool div()
{
	if(a[len]==1) len--,a[len]+=10;
	for(int i=len;i;i--)
	{
		if(a[i]&1) a[i-1]+=10;
		a[i]=a[i]/2;
	}
	return len;
}
int getans()
{
	matrix ans;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++) s.a[i][j]=0,ans.a[i][j]=0;
	s.a[1][1]=2;
	s.a[1][2]=1;
	s.a[2][1]=1;
	ans.a[1][1]=ans.a[2][2]=1;
	while(true)
	{
		if(a[1]&1) ans=ans*s;
		if(!div()) break;
		s=s*s;
	}
	return ans.a[2][1];
}
char str[M];
int main()
{
	scanf("%s",str);
	len=strlen(str);
	for(int i=0;i<len;i++)
	{
		a[len-i]=str[i]-'0';
	}
	printf("%d",getans());
}
```


---

## 作者：HohleFeuerwerke (赞：1)

#### 前言

发这篇题解的原因是因为神鱼自己切完了这道题然后把数据改了额（，然后现在这里几乎所有的题解都不能过。

[戳我返回题目](https://www.luogu.com.cn/problem/P4451)
。

#### 正文

思路上借鉴了[这篇题解](https://www.luogu.com.cn/blog/asuldb/solution-p4451)，也是窝唯一一个比较能赞同的题解。

我们首先明确一个事实：为什么现在题解过不去？

你可能会说：复杂度有问题啊，你看递推交了十几遍都过不去。

恭喜你，说对了一半。

原来这题的数据范围是：$n\leq 10^6$，然后毒瘤鱼就这么把它改成了：$n\leq 10^9$拿$60\%$，原来按照$n\leq 10^6$写的全部挂掉。$n\leq 10^{10000}$拿$100\%$。

所以原先复杂度没有做到$log_n$或者$\sqrt{n}$反正一切小于$n$的都挂掉了。  
~~事实上我也没有见过根号算法基本上原来全都是log级的。~~

我们通过上一篇题解最后推出来的式子：

$$\text{ans}_n≡(1+59713600)^n*59713600*250000002-(1-59713600)^n*597136000*250000002\ \ (\text{mod} 10^9+7)$$

这个东西可以用快速幂解决，复杂度$O(log_n)$，我们能拿到$60\%$。

然后我们考虑满分。目前没有学过能把$10^{10000}$次方压下来通过的算法，如果有那就很神仙了。

我们考虑费马小定理。由费马小定理，或者珂以实践出真知，我们发现：

$$\text{ans}_n≡\text{ans}_{n±k(10^9+6)}$$

直接珂以把数据范围压到$n\leq 10^9$，刚刚讲的做法。

给出代码

```cpp
#include<bits/stdc++.h>
const long long MOD=1e9+7;
using namespace std;
typedef long long ll;
ll n;
ll a;
ll read(){
	ll ret=0; char ch=0;
	while(!isdigit(ch)) ch=getchar();
	while(isdigit(ch)){
		ret=((ret<<1)+(ret<<3)+ch-'0')%(MOD-1);
		ch=getchar();
	}
	return ret;
}

//边读边模，感谢@若如初见 教会我这个小技巧。

ll ksm(ll a,ll b,ll m){
	if(b==0)
		return 1;
	else if(b%2==1)
		return a*ksm(a,b-1,m)%m;
	else{
		ll num=ksm(a,b/2,m)%m; 
		return num*num%m;
	}
}

//快速幂

int main(){
	n=read();
	cout<<(ksm(1+59713600,n,MOD)*59713600%MOD*250000002%MOD-ksm(1-59713600+MOD,n,MOD)%MOD*59713600%MOD*250000002%MOD+MOD)%MOD<<endl;//直接输出。
}
```

---

## 作者：FutaRimeWoawaSete (赞：0)

**P4451**题解。

考虑生成函数。我们知道整数有序拆分可以考虑每个位置的数是什么，即 $(1 + x ^ 1 + x ^ 2 + ...... + x ^ n)$，最多 $n$ 个位置也就是 $(1 + x^1 +  x ^ 2 + x ^ 3  + ...... + x ^ n) ^ n$。

由于有斐波那契的乘积影响，所以写进系数里面，拆分成 $n$ 个数即 $(F_0 + F_1x^1 + F_2x^2 +......+F_nx^n)^n$，答案就应该是拆分成 $1 \sim n$ 个数的所有方案之和。

根据~~常识~~我们知道斐波那契数列的生成函数写成 $G(x) = \frac{x}{1 - x - x ^ 2}$，这个可以通过构造等式证明：

- $F_x = F_{x - 1} + F_{x - 2},x > 2$

- $G(x) = xG(x) + x ^ 2G(x)-xa_0+a_1x+a_0$

代入解得 $G(x) = \frac{x}{1 - x - x ^ 2}$。

考虑通过构建递推式得到答案，构造答案的生成函数：

- $H(x) = \sum_{i = 0} ^ {+\infty} G(x)^i$

- $H(x) = \frac{1}{1 - G(x)} = \frac{1 - x - x ^ 2}{1 - 2x - x ^ 2}$

考虑将分母拆开，变成 $(1 - x - x ^ 2) \times \frac{1}{1 - 2x - x ^ 2}$，然后展开后面的分母项，设展开形式为 $S$。

- $S = \frac{1}{1 - 2x - x ^ 2}$

- $S(1 - 2x - x ^ 2)=1$

- $S = 1 + 2xS + Sx^2$

设 $S$ 对应的系数项 $a$ 即为我们的答案，常数项 $1$ 是无关的：

- $a_n = 2a_{n - 1} + a_{n - 2}$；

设 $H(x)$ 对应的系数项为 $b$，由于还要乘上 $(1 - x - x ^ 2)$，所以可得：

- $b_n = a_n - a_{n - 1} - a_{n - 2} = a_{n - 1}$

考虑计算 $a_n$ 的通项式， 显然 $S$ 分母的最高次项为 $2$ 次，所以设两个分式提出来：

- $\frac{1}{1 - 2x - x ^ 2} = \frac{1}{(1 - ax)(1 - bx)}$

显然这可以通过初中生就会的待定系数法解决：

- $a = -\sqrt2+1,b=\sqrt2+1$

观察到如果我们能将分母的乘积拆开，则一定可以写成两个生成函数的和的形式，这样我们只需要将它们对应的系数项相加即可！

$S = \frac{c}{1 - (-\sqrt 2 + 1)x} + \frac{d}{1 - (\sqrt 2 + 1)x}$

则 $c \times (1 - (\sqrt 2 + 1)x) + d(1 - (-\sqrt 2 + 1)x) = 1$；

解得 $c = \frac{1}{2} - \frac{\sqrt 2}{4},d = \frac{1}{2}+\frac{\sqrt 2}{4}$；

将两个生成函数展开，其中 $(-\sqrt 2 + 1)$ 与 $(\sqrt 2 + 1)$ 为它们的公平，分别乘上对应的 $c,d$ 可以得到最后的通项公式：

- $\frac{(1 + \sqrt 2) ^ n - (1 - \sqrt 2) ^ n}{2 \sqrt 2}$

由于 $\sqrt 2 \equiv 59713600 \pmod {1000000007}$，剩下的直接套公式算即可。

```cpp
#include "bits/stdc++.h"
using namespace std;
#define ll long long
const int Len = 2e5 + 5;
const ll sqrt2 = 59713600 , mod = 1e9 + 7;
int n,m;
ll qpow(ll a,ll b)
{
	a = (a + mod) % mod;
	ll res = 1;
	while(b)
	{
		if(b & 1) res = res * a % mod;
		a = a * a % mod;
		b = b >> 1;
	}
	return res;
}
inline ll read() 
{
    char ch = getchar();
    ll x = 0 , f = 1;
    while (ch < '0' || ch > '9') 
	{
        if (ch == '-') f = -1;
        ch = getchar();
    }
    while ('0' <= ch && ch <= '9') 
	{
        x = 1ll * x * 10 % (mod - 1) + (ch - '0');
        x %= (mod - 1);
        ch = getchar();
    }
    return x * f;
}
int main()
{
	n = read();ll A1 = qpow(1ll + sqrt2 , n) , A2 = qpow(1ll - sqrt2 , n);
	printf("%lld\n",(A1 - A2 + mod) % mod * qpow(2 * sqrt2 % mod , mod - 2) % mod);
	return 0;
}
```

---

## 作者：wind_whisper (赞：0)

## $\text{foreword}$
第一道完全自己做出来的生成函数，特来发一篇题解。
## $\text{Solution}$
设答案数列为 $g$，斐波拉契数列为 $f$，可以得到递推式：
$$g_n=\sum_{i=0}^{n-1}g_if_{n-i}$$
由于 $f_0=0$ ，不妨改为：
$$g_n=\sum_{i=0}^{n}g_if_{n-i}$$
设 $f,g$ 的生成函数为 $F,G$，就有：
$$G=F*G+1$$
解得：
$$G=\frac{1}{1-F}$$
~~总所周知~~斐波拉契 $F$ 的封闭形式为：
$$F=\frac{x}{1-x-x^2}$$
然后带入化简分离常数可得：
$$G=1+\frac{x}{1-2x-x^2}$$
后面的过程就和斐波拉契证明一模一样了。  

待定系数，设：
$$\frac{x}{1-2x-x^2}=\frac{A}{1-ax}+\frac{B}{1-bx}$$
解得：
$$\frac{x}{1-2x-x^2}=\frac{\dfrac{\sqrt2}{4}}{1-(1+\sqrt2)x}-\frac{\dfrac{\sqrt2}{4}}{1-(1-\sqrt2)x}$$
所以通项公式就是：
$$g_n=\frac{\sqrt2}{4}[(1+\sqrt2)^n-(1-\sqrt2)^n]$$
可以找到 $\sqrt2$ 的模 $10^9+7$ 的结果，也可以直接用复数类的形式计算。
## $\text{Code}$
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned long long
#define debug(...) fprintf(stderr,__VA_ARGS__)
inline ll read(int mod=0) {
	ll x(0),f(1);char c=getchar();
	while(!isdigit(c)) {if(c=='-')f=-1;c=getchar();}
	while(isdigit(c)) {x=(x<<1)+(x<<3)+c-'0';if(mod) x%=mod;c=getchar();}
	return x*f;
}
const int mod=1e9+7;
const int N=4e5+100;
int n,m,k;
inline ll ksm(ll x,ll k){
	ll res=1;
	while(k){
		if(k&1) res=res*x%mod;
		x=x*x%mod;k>>=1;
	}
	return res;
}

struct node{
	ll x,y;//a+b*sqrt(2)
	node(ll a,ll b):x(a),y(b){}
};
node t(int a,int b){
	return (node){a,b};
}
node operator + (node a,node b){
	return (node){(a.x+b.x)%mod,(a.y+b.y)%mod};
}
node operator - (node a,node b){
	return (node){(a.x+mod-b.x)%mod,(a.y+mod-b.y)%mod};
}
node operator * (node a,node b){
	return (node){(a.x*b.x+2*a.y*b.y)%mod,(a.x*b.y+a.y*b.x)%mod};
}
node ksm(node x,int k){
	node res=t(1,0);
	while(k){
		if(k&1) res=res*x;
		x=x*x;
		k>>=1;
	}
	return res;
}
signed main() {
#ifndef ONLINE_JUDGE
	//freopen("a.in","r",stdin);
	//freopen("a.out","w",stdout);
#endif
	n=read(mod-1);
	node res=t(0,ksm(4,mod-2))*(ksm(t(1,1),n)-ksm(t(1,-1),n));
	printf("%lld",res.x);
	return 0;
}
/*
3 1
2 3 3 1
1 1
*/

```


---

## 作者：Illusory_dimes (赞：0)

### 题目描述
给定 $n$ ，要求，

$$m>0\ ,a_i>0\ ,\sum_{i=1}^{m}a_i=n$$

求，

$$\sum_{all}{\prod_{i=1}^{m}fib_{a_i}}$$

$1\leq n\leq 10^{10^4}$

### solution
于是我们设答案为 $g(x)$ ，它的生成函数为 $G(x)$ 。

如果暂定 $g_0=1$ ，其实就能非常顺手地写出一个递推式

$$g(x)=\sum_{i=1}^{x}fib_i\cdot g_{n-i}+[n=0]$$

然后 $G(x)$ 也就写出来了，

$$G(x)=\sum_{n=1}^{\infty}{(\sum_{i=1}^{n}fib_i\cdot g_{n-i})x^n}+1$$

其实再写递推式的时候，就是在做类似卷积的“填”动作，所以生成函数就很愉快的化成了

$$G(x)=Fib(x)\cdot G(x)+1$$

化简一下，

$$G(x)=\frac{1}{1-Fib(x)}$$

应该都知道公式，

$$Fib(x)=\frac{x}{1-x-x^2}$$

带入，并化简一下，

$$G(x)=\frac{1}{1-\Large \frac{x}{1-x-x^2}}$$

$$\Rightarrow\frac{1-x-x^2}{1-2\cdot x-x^2}$$

$$\Rightarrow1-\frac{x}{x^2+2\cdot x-1}$$

后面这一坨并非我们想要的，关注到有二次方程，尽量化成乘积模式，那就设方程两根 $x_1=-1-\sqrt{2}$ ， $x_2=-1+\sqrt{2}$ 并设 $\varphi(x)=-\Large\frac{x}{x^2+2\cdot x-1}$ 。

$$\varphi(x)=-\frac{x}{(x-x_1)(x-x_2)}$$

$$\Rightarrow\frac{1}{x_2-x_1}\cdot (\frac{x}{x_2-x}-\frac{x}{x_1-x})$$

似乎这一切又卡住了，但是如果尽可能的提系数的话

$$\Rightarrow\frac{1}{x_2-x_1}\cdot (\frac{x}{x_2}\cdot \frac{1}{1-\Large\frac{x}{x_2}}-\frac{x}{x_1}\cdot \frac{1}{1-\Large\frac{x}{x_1}})$$

会发现这好像唤起了你~~某深处沉睡~~的记忆，刚开始学生成函数的时候，我们就学了,

$$\sum_{i=0}^{\infty}(c\cdot x)^{k\cdot i}=\frac{1}{1-c\cdot x^k}$$

来一手逆用，

$$\Rightarrow\frac{1}{x_2-x_1}\cdot \Big(\frac{x}{x_2}\cdot \sum_{i=0}^{\infty}(\frac{x}{x_2})^i-\frac{x}{x_1}\cdot \sum_{i=0}^{\infty}(\frac{x}{x_1})^i\Big)$$

$$\Rightarrow\frac{1}{x_2-x_1}\cdot \Big(\sum_{i=1}^{\infty}(\frac{x}{x_2})^i-\sum_{i=1}^{\infty}(\frac{x}{x_1})^i\Big)$$

$$\Rightarrow\frac{1}{x_2-x_1}\cdot \Big(\sum_{i=1}^{\infty}\big((\frac{1}{x_2})^i-(\frac{1}{x_1})^i\big)\Big)\sum_{i=1}^{\infty}x^i$$

~~是不是已经快忘了我们从哪里开始的吗（我自己都快了~~

悄悄往上一看，噢。。所以，

$$G(x)=1+\varphi(x)$$

$$\Rightarrow\frac{1}{x_2-x_1}\cdot \Big(\sum_{i=1}^{\infty}\big((\frac{1}{x_2})^i-(\frac{1}{x_1})^i\big)\Big)\sum_{i=1}^{\infty}x^i+1$$

于是 $i=n$ 的系数就是，

$$\frac{1}{x_2-x_1}\cdot \Big((\frac{1}{x_2})^n-(\frac{1}{x_1})^n\Big)$$

带入 $x_1=-1-\sqrt{2}$ ， $x_2=-1+\sqrt{2}$ ，

$$\frac{1}{2\cdot \sqrt{2}}\cdot \Big((1+\sqrt{2})^n-(1-\sqrt{2})^n\Big)$$
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int sqrt2=59713600,mod=1e9+7;
int n,lqp1,lqp2,ans1,ans2;
inline int inc(int x,int y){return x+y>=mod?x+y-mod:x+y;}
inline int mul(int x,int y){return 1ll*x*y%mod;}
inline ll read()
{
	ll s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')s=((s<<3)+(s<<1)+ch-'0')%(mod-1),ch=getchar();
	return s*w;
}
inline int ksm(int a,int b)
{
	int tmp=1;
	while(b)
	{
		if(b&1)tmp=mul(tmp,a);
		a=mul(a,a),b>>=1;
	}
	return tmp;
}
int main()
{
	n=read(),lqp1=1+sqrt2,lqp2=1-sqrt2+mod;
	ans1=mul(lqp1,mul(ksm(inc(2+lqp1,lqp1),mod-2),ksm(lqp1,n)));
	ans2=mul(lqp2,mul(ksm(inc(2+lqp2,lqp2),mod-2),ksm(lqp2,n)));
	printf("%d",inc(ans1,ans2));
	//这是Froggy的公式（主要好看。。）
	return 0;
}
```
只求能帮助到几个人罢。。

---

## 作者：ricky0916 (赞：0)


首先定义$ \{F_i\} $的生成函数
$$ 
G(x)=F_0+F_1 x+......=\sum_{i=0}^\infty F_ix^i
$$
则有

$$
\begin{aligned}
G(x)\times x=\sum_{i=0}^\infty F_ix^{i+1}\\
G(x)\times x^2=\sum_{i=0}^\infty F_ix^{i+2}
\end{aligned}
$$

由于$ F_{n}=F_{n-1}+F_{n-2}(n\ge2),F_0=0,F_1=1 $

则有

$$
\begin{aligned}
&G(x)\times (1-x-x^2)\\
=&\sum_{i=0}^\infty F_ix^i -\sum_{i=0}^\infty F_ix^{i+1}-\sum_{i=0}^\infty F_ix^{i+2}\\
=&x+\sum_{i=0}^\infty (F_{i+2}-F_{i+1}-F_n)x^i\\
=&x
\end{aligned}
$$

所以我们有了$ G(x)=\dfrac{x}{1-x-x^2} $

此时设$ b_i $为$n=i$时的答案，构造$ B(x)=\sum_{i=0}^\infty b_ix^i $

我们知道，取$ m $个数能使得$ \sum_{i=1}^m F_{a_i}=n $的权值之和为$ G(x)^m $

于是有了$ B(x)=\sum_{i=0}^\infty G(x)^i=\dfrac{1}{1-G(x)}=\dfrac{1-x-x^2}{1-2x-x^2} $

这里运用~~初中的部分分式~~，我们有
$$
B(x)=1+\dfrac{1}{2\sqrt2} (\dfrac{1}{1-(1+\sqrt2)x}-\frac{1}{1-(1-\sqrt2)x})=1+\dfrac{1}{2\sqrt2}\sum_{i=0}^\infty [(1+\sqrt2)^i-(1-\sqrt2)^i] x^i
$$
所以$ b_i=\dfrac{(1+\sqrt2)^i-(1-\sqrt2)^i}{2\sqrt2} $

（特别的，$b_0=1$）

这里$\sqrt2\equiv 59713600\pmod {1000000007}$，一个快速幂就完事了。

---

## 作者：传奇666666 (赞：0)

首先，把这个$F$的生成函数列出来，原本$F$的生成函数是$\frac{1}{1-x-x^2}$，这道题的$F$是向右移了一位的，所以是$F(x)=\frac{x}{1-x-x^2}$。

易知当拆分成$k$个数时，生成函数为$F^k(x)$。应该不难理解，这样实际上是在讨论每一个数选了什么，然后把方案数最终算在对应项系数上。

所以答案的生成函数就是$G(x)=\sum_{i=0}^{\infty}{F^i(x)}$

化简一下就是$G(x)=\frac{1}{1-F(x)}=1+\frac{x}{1-2x-x^2}$

考虑变化一下$G(x)$：

$\begin{aligned}
G(x) &= \frac{1}{1-F(x)}\\
&= 1+\frac{x}{1-2x-x^2}\\
&= 1+\frac{1}{2\sqrt2}*(\frac{1}{1-(1+\sqrt2)x}-\frac{1}{1-(1-\sqrt2)x})\\
&=1+\sum_{i>0}{\frac{(1+\sqrt2)^i-(1-\sqrt2)^i}{2\sqrt2}*x^i}
\end{aligned}$

所以答案就是$ans_n=\frac{(1+\sqrt2)^n-(1-\sqrt2)^n}{2\sqrt2}$

注意到$2$在$1e9+7$意义下有二次剩余为$59713600$所以直接快速幂就好了。

---

## 作者：xuyixuan (赞：0)

## 题意简述
设$F_{x}$为斐波那契数列第$x$项

将一个数$n$拆分为$a{1}, a{2}, ..., a{m}$, 即$a{1} + a{2} +...+ a{m} = n$

求$\sum\prod\limits_{i =1}^m F_{a_i}$

## 题解
我太弱了所以不会生成函数乱搞，只能递推

还有我觉得其他递推好像有点小错误，它们没有计算当n只分解为n时的情况，~~虽然递推式一样~~

$F_{x}$为斐波那契数列第$x$项

设$g(i)$为当n = i时的答案

所以

$g(i) = \sum\limits_{j = 1} ^ {i - 1} g(j) * F_{i - j} + F_i$

加上一个$F_i$是计算当i拆分成i时的贡献

$g(i + 1) = \sum\limits_{j = 1} ^ {i} g(j) * F_{i + 1 - j} + F_{i + 1}$

$g(i + 1) - g(i)$

$ = \sum\limits_{j = 1} ^ {i - 1} g(j) * (F_{i + 1 - j} - F_{i - j}) + g(i) * F_1 + F_{i + 1} - F_i$

$ = \sum\limits_{j = 1} ^ {i - 1} g(j) * F_{i - j - 1} + g(i) + F_{i - 1}$

$ = \sum\limits_{j = 1} ^ {i - 2} g(j) * F_{i - j - 1} + F_{i - 1} + g(i)$

$ = g(i - 1) + g(i)$

所以 $g(i + 1) = 2 * g(i) + g(i - 1)$ 且 $g(0) = 0, g(1) = 1$

再直接递推或矩阵快速幂求第$n$项即可
我用的是矩阵快速幂

## 代码
```cpp
#include <cstdio>
typedef long long ll;
const int mod = 1000000007;
int T, N;
int n;
struct Matrix
{
    int a[4][4];
    Matrix& operator =(const Matrix& x)
    {
        for (register int i = 1; i <= N; ++i)
            for (register int j = 1; j <= N; ++j)
                a[i][j] = x.a[i][j];
        return *this;
    }
};
Matrix a, b, c;
Matrix Mul(const Matrix& x, const Matrix& y)
{
    Matrix s;
    for (register int i = 1; i <= N; ++i)
        for (register int j = 1; j <= N; ++j)
            s.a[i][j] = 0;
    for (register int k = 1; k <= N; ++k)
    	for (register int i = 1; i <= N; ++i)
        	for (register int j = 1; j <= N; ++j)
                s.a[i][j] = (s.a[i][j] + (ll)x.a[i][k] * y.a[k][j] % mod) % mod;
    return s;
}
Matrix _pow(Matrix x, int y)
{
    Matrix s;
    for (register int i = 1; i <= N; ++i)
        for (register int j = 1; j <= N; ++j)
            s.a[i][j] = (i == j);
    for (; y; y >>= 1, x = Mul(x, x)) if (y & 1) s = Mul(s, x);
    return s;
}
int main()
{
    N = 2;
    scanf("%d", &n);
    c.a[1][1] = 0; c.a[1][2] = 1;
    a.a[2][1] = a.a[1][2] = 1; a.a[2][2] = 2;
    if (n <= 1) {printf("%d\n", c.a[1][n + 1]); return 0; }
    b = Mul(c, _pow(a, n - 1));
    printf("%d\n", b.a[1][2]);
}
```

---


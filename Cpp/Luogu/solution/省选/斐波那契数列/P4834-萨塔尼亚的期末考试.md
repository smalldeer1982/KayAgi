# 萨塔尼亚的期末考试

## 题目背景

“呐，珈百璃，我说，暑假我们去哪里玩呢？”薇奈特拍拍珈百璃的肩膀

“哈？暑假当然是在家里打游戏啦”珈百璃无精打采地回答道

“怎么能这样呢？你好歹也是天使啊，给我拿出天使的样子来啊”

“真麻烦”

“所以，暑假我们去海边玩吧？”

“赞成赞成！去海边玩的话，就可以好好调戏珈百璃了”菈菲尔不知道什么时候凑进来

“麻烦死了。”

这边一群人正讨论着暑假去哪玩，然而萨塔尼亚在旁边听得很纠结，因为没有人邀请她。。

“哼哼哼哼，吾乃神魔萨塔尼亚，怎么可能主动去加入呢，我必须等她们邀请我”萨塔尼亚心理打着小算盘

“呐，我说，萨塔尼亚貌似有点小不开心呀”

“已经不是貌似了吧，她这表情完全没有掩盖的意思啊。。”

“呐，我说，要不要邀请她去啊？”

拉菲尓说着，走向了萨塔尼亚。“萨塔尼亚桑，暑假我们要去海边玩哟~”

“哼哼哼，终于来邀请我了吗”萨塔尼亚心里有点小开心，小声嘀咕到

“萨塔尼亚桑就好好待在这里哟~”

“额。。。”萨塔尼亚受到了成吨的暴击，“喂，我说，哪有你这样的啊”

“恩？因为，萨塔尼亚桑，暑假如果要出去玩的话，就要通过期末考试哟，不然会被留下来补课的”

“补。。。补课。。。。”萨塔尼亚貌似意会到了什么，脸色大变，“补课。。。呐，拉菲尓。。你。。你能帮我。。补习吗？”

“恩？可以呀~但是期末考试如何就得看你自己了”

“谢谢，那帮我看看这些哪里错了吧？我完全不懂诶”

“我看看。。。” 拉菲尓丢下珈百璃和薇奈特独自给萨塔尼亚开始了补习。

终于，期末考来了，萨塔尼亚努力的这么久，就看这次考试了！经过长期的努力，期末考一切顺利，除了还没考的数学其他学科都及格啦！

终于到了最后一场考试——物理考试。很不错的是，萨塔尼亚已经答完了59分而且全对，但是她遇到了一道绝世难题，而且她很惊奇的发现，总分100分，这题41分，如果不写出来，就会挂科。“期末考如果有某人有挂科，那么那个人的暑假要参加补课以及补考！”班主任的话萦绕在她的耳旁，这可怎么办啊。。。


## 题目描述

这道题是这样的：

有一个由 $n$ 个点电荷形成的电场。假定每个点电荷放出的电场都是匀强电场而不是点电荷电场，第 $i$ 个点电荷的电场强度 $E_i=i$。

现放一个带负电的试探电荷到这个电场中，这个试探电荷只要触碰到任何一个点电荷就会和这个点电荷发生聚变放出巨大能量。

因为点电荷放出的电场强度不同，所以试探电荷被吸引到每个点电荷的概率也不同，点电荷给试探电荷的吸引力越大被吸到这个点电荷的概率就越大，且成正比。

我们假设最小的点电荷给试探电荷的吸引力为 $F$，那么对于其他点电荷给试探电荷和吸引力就是 $iF$，那么假设触碰最小的点电荷的概率为 $P$，则每个点的概率就是 $iP$，触碰到点电荷后发出的能量为 $\mathrm{Fib}(E_i)$。

求期望放出的能量。

好消息是，只要这道题拿到分，萨塔尼亚就能及格啦！


## 说明/提示

### 样例解释

$\dfrac{1}{3}\times \mathrm{Fib}(1)+\dfrac{2}{3}\times \mathrm{Fib}(2)=1$。

请结合样例仔细再仔细的读题！

### 数据范围

- 对于 $10\%$ 的数据 $T=1$，$n=2$；
- 对于 $30\%$ 的数据 $T≤10$，$1\le n\le 10^6$；
- 对于 $60\%$ 的数据 $T≤10^6$，$1\le n\le 10^6$；
- 对于 $100\%$ 的数据 $T≤10^6$，$1\le n\le 10^9$，保证 $n \ne 998244352$ 且 $n \ne 998244353$。

$\mathrm{Fib}(i)$ 为斐波那契数列。

$$\mathrm{Fib}(i)=\begin{cases}
1 & i\le 2 \cr
\mathrm{Fib}(i-1)+\mathrm{Fib}(i-2) & i > 2
\end{cases}$$


## 样例 #1

### 输入

```
1
2
```

### 输出

```
1```

# 题解

## 作者：风浔凌 (赞：6)

发现比赛的题解链接需要密码才能打开？

啊没办法看不了题解了怎么办。。。。自己写一篇好了qwq

就是这个题我们需要推一个式子：

$$\frac{\sum_{i=1}^n i\times F_i}{n\times(n-1)/2}$$
因为下面的分母很好求，所以。。。我们只需要知道怎么快速的求分子就行了。。。我们要降低复杂度qwq

 $\sum_{i=1}^n i\times F_i=n\times F_{n+2}-F_{n+3}+2$  
证明：  
$\sum_{i=1}^n i\times F_i$

$=n\times \sum_{i=1}^nF_i-(n-1)\times F_1-(n-2)\times F_2-...-1\times F_{n-1}$

$=n\times \sum_{i=1}^nF_i-(\sum_{i=1}^{n-1}F_i+\sum_{i=1}^{n-2}F_i+...+\sum_{i=1}^2F_i+F_1)$

$=n\times \sum_{i=1}^nF_i-(F_{n+1}-1+F_{n}-1+...+F_4-1+F_1)$

$=n\times \sum_{i=1}^nF_i-(F_{n+1}+F_{n}+...+F_4+F_3+F_2+F_1-3-(n-2))$

$=n\times \sum_{i=1}^nF_i-F_{n+3}+1+n+1$

$=n\times F_{n+2}-F_{n+3}+2$

这样一来就很简单了，因为数据很大，所以采用矩阵快速幂来加速斐波那契数列的运算，然后记得分子要求逆元qwq

下面贴上代码：（大家要注意及时取模啊，本蒻就是因为有一个取模忘写了结果炸成负数debug了好久来着。。。。）
```
#include<iostream>
#include<cstring>
#include<algorithm>
#define mod 998244353
using namespace std;
struct Node{long long t[3][3];};
Node res,poww;
long long ans[3],kkk[3];
int t;
long long mul(long long x,long long y)
{
    long long ans=1;
    while(y)
    {
        if(y&1) ans=x*ans%mod;
        x=x*x%mod;
        y>>=1;
    }
    return ans;
}
Node Mul(Node x,Node y)
{
    Node cur;
    for(int i=1;i<=2;i++)
        for(int j=1;j<=2;j++)
            cur.t[i][j]=0;
    for(int i=1;i<=2;i++)
        for(int j=1;j<=2;j++)
            for(int k=1;k<=2;k++)
                cur.t[i][j]=(cur.t[i][j]+(x.t[i][k]*y.t[k][j])%mod)%mod;
    return cur;
}
void solve()
{
    for(int i=1;i<=2;i++)
        for(int j=1;j<=2;j++)
            ans[i]=(ans[i]+(kkk[j]*(res.t[i][j])%mod)%mod)%mod;
}
int main()
{
    
    scanf("%d",&t);
    for(int c=1;c<=t;c++)
    {
        long long n;
        memset(ans,0,sizeof(ans));
        memset(kkk,0,sizeof(kkk));
        for(int i=0;i<=2;i++)
            for(int j=0;j<=2;j++)
                poww.t[i][j]=0,res.t[i][j]=0;
        kkk[1]=kkk[2]=1;//[1]=a_n+3,[2]=a_n+2 
        res.t[1][1]=res.t[2][2]=1;//单位矩阵 
        poww.t[1][1]=poww.t[1][2]=poww.t[2][1]=1;//快速幂矩阵 
        scanf("%lld",&n);
        long long he=(n*(n+1)/2)%mod;
        long long k=mul(he,mod-2);//求逆元 
        long long cnt=n+1;
        while(cnt)
        {
            if(cnt&1) res=Mul(res,poww);
            poww=Mul(poww,poww);
            cnt>>=1;
        }
        solve();
        k=k*((n*ans[2]%mod+mod-(ans[1]%mod)+2)%mod);
        printf("%lld\n",k%mod);
    }
    return 0;
}
```

---

## 作者：dspt (赞：2)

题面里没有 $\LaTeX$，比较可惜。这是道挺好的题，可能很多人看到题面的狼藉就望而止步了。

大致题意就是求解：$\sum\limits_{i=1}^n\dfrac{2iF(i)}{n(n+1)}$。其中 $F(i)$ 指斐波那契数列（$1,1,2,3,\cdots$），$1\leqslant n\leqslant 10^9$，并且有 $10^6$ 组数据。

直接做？不太可能。如果我们直接求解，时间复杂度显然会到达 $O(10^9)$，那么化简式子是我们简单思考后的唯一选择。

先将 $\dfrac{2}{n(n+1)}$ 提出来，剩下 $\sum\limits_{i=1}^n iF(i)$，然后利用斐波那契前缀和的知识 $\sum\limits_{i=1}^nF(i)=F(n+2)-1$ 来进行化简：

$$
\begin{aligned}
\sum\limits_{i=1}^n iF(i)&=\sum\limits_{i=1}^n\sum\limits_{j=i}^nF(j)\\
&=\sum\limits_{i=1}^n(\sum_{j=1}^nF(j)-\sum_{j=1}^{i-1}F(j
))\\
&=\sum\limits_{i=1}^n(F(n+2)-1-F(i+1)+1)\\
&=nF(n+2)-\sum\limits_{i=1}^{n+1}F(i)+1\\
&=nF(n+2)-F(n+3)+2\\
\end{aligned}
$$

化简过程比较简单，最后得到 $\dfrac{2(nF(n+2)-F(n+3)+2)}{n(n+1)}$。

我们知道斐波那契中的一项（$F(n)$）其实可以用矩阵快速幂在 $O(\log n)$ 的时间内求出来，于是我们对于每组询问只需要进行一次矩阵快速幂即可，然后乘上分母的逆元即可。

现在的时间复杂度 $O(T\log n)$，可以通过。

代码如下：

```cpp
#include <stdio.h>
const int p(998244353);
struct matrix
{
    long long t[3][3];
    matrix operator*=(const matrix x) {
        matrix y;
        y.t[1][1] = (t[1][1] * x.t[1][1] + t[1][2] * x.t[2][1]) % p;
        y.t[1][2] = (t[1][1] * x.t[1][2] + t[1][2] * x.t[2][2]) % p;
        y.t[2][1] = (t[2][1] * x.t[1][1] + t[2][2] * x.t[2][1]) % p;
        y.t[2][2] = (t[2][1] * x.t[1][2] + t[2][2] * x.t[2][2]) % p;
        return *this = y;
}   } a, b;
int T, n, x, y;
inline int power()
{
    int a(1ll * n * (n + 1) % p), b(1), c(p - 2);
    while (c) {
        if (c & 1) b = 1ll * a * b % p;
        a = 1ll * a * a % p; c >>= 1;
    } return b;
}
int main()
{
    scanf("%d", &T);
    while (T--) {
        scanf("%d", &n); int k(n + 2);
        a.t[1][1] = b.t[1][1] = 1;
        a.t[1][2] = a.t[2][1] = b.t[2][2] = 1;
        b.t[1][2] = b.t[2][1] = a.t[2][2] = 0;
        while (k) { if (k & 1) b *= a; a *= a; k >>= 1; }
        const long long w((1ll * n * b.t[1][2] % p - b.t[1][1] + 2 + p) % p);
        printf("%d\n", 2 * w * power() % p);
    } return 0;
}
```

补充说明：在矩阵乘法中，其实一次矩阵快速幂可以求出相邻的两项，所以求出 $F(n+2)$ 和 $F(n+3)$ 只需要一次即可。

根据这个性质，我在不用 O2 的情况下轻松拿到了最优解。

---

## 作者：离散小波变换° (赞：1)

## 题意

计算：

$$\dfrac{1}{\sum_{i=1}^n i}\sum_{i=1}^n i\times \mathrm{Fib}_i \pmod {998{,}244{,}353}$$

数据范围：$T$ 组数据，$1\le T\le 10^6$，$1\le n\le 10^9$。

## 题解

斐波那契数列乘上一个数字再求和，很难不想到一个经典结论：

$$S_n=\sum_{i=1}^n \mathrm {Fib}_i=\mathrm {Fib}_{i+2}-1$$

证明可用归纳法，这里不再赘述。

回到本题来，$i$ 的存在似乎不太好用这个结论。但如果稍微写过树状数组区间加区间求和，应该会比较熟悉某个变换（因为笔者太菜不太会语言叙述，可以到线段树模板题题解区看下）。应用到这题里来，

$$\begin{aligned}
\sum_{i=1}^n i\times \mathrm{Fib}_i &=(n+1)S_n-\sum_{i=1}^n (n-i+1)\times \mathrm{Fib}_i\cr
&=(n+1)S_n-\sum_{i=1}^n S_i\cr
&=(n+1)S_n-\sum_{i=1}^n \left(\mathrm {Fib}_{i+2}-1\right) \cr
&=(n+1)S_n+n-S_{n+2}+S_2 \cr
&=(n+1)(\mathrm{Fib}_{n+2}-1)+n-\mathrm{Fib}_{n+4}+1+2\cr
&=(n+1)\mathrm{Fib}_{n+2}-\mathrm{Fib}_{n+4}+2
\end{aligned}$$

然后套一个矩阵乘法板子就完事了。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l, r, i) for(int i = l, END##i = r;i <= END##i;++ i)
#define dn(r, l, i) for(int i = r, END##i = l;i >= END##i;-- i)
using namespace std;
typedef long long i64;
const int INF = 2147483647;
int qread(){
    int w = 1, c, ret;
    while((c = getchar()) >  '9' || c <  '0') w = (c == '-' ? -1 : 1); ret = c - '0';
    while((c = getchar()) >= '0' && c <= '9') ret = ret * 10 + c - '0';
    return ret * w;
}
const int MOD = 998244353;
struct Mat{ int a11, a12, a21, a22; };
struct Vec{ int a11, a12; };
Mat operator *(Mat a, Mat b){
    Mat c;
    c.a11 = (1ll * a.a11 * b.a11 + 1ll * a.a12 * b.a21) % MOD;
    c.a12 = (1ll * a.a11 * b.a12 + 1ll * a.a12 * b.a22) % MOD;
    c.a21 = (1ll * a.a21 * b.a11 + 1ll * a.a22 * b.a21) % MOD;
    c.a22 = (1ll * a.a21 * b.a12 + 1ll * a.a22 * b.a22) % MOD;
    return c;
}
Vec operator *(Vec a, Mat x){
    Vec c;
    c.a11 = (1ll * a.a11 * x.a11 + 1ll * a.a12 * x.a21) % MOD;
    c.a12 = (1ll * a.a11 * x.a12 + 1ll * a.a12 * x.a22) % MOD;
    return c;
}
const int MAXM = 30 + 3;
struct Mat M[MAXM];
int power(int a, int b){
    int r = 1;
    while(b){
        if(b & 1) r = 1ll * r * a % MOD;
        b >>= 1,  a = 1ll * a * a % MOD;
    }
    return r;
}
int main(){
    M[0].a11 = 0, M[0].a12 = 1;
    M[0].a21 = 1, M[0].a22 = 1;
    up(1, 30, i) M[i] = M[i - 1] * M[i - 1];
    up(1, qread(), _){
        int n = qread(), t = 0;
        int p = 2ll * power(n, MOD - 2) * power(n + 1, MOD - 2) % MOD;
        Vec T; T.a11 = 1, T.a12 = 1;
        dn(30, 0, i){
            if((t | 1 << i) <= n + 1)
                t |= 1 << i, T = T * M[i];
        }
        int a = T.a11;
        T = T * M[0];
        T = T * M[0];
        int b = T.a11;
        printf("%d\n", ((1ll * (n + 1) * a - b + 2) % MOD + MOD) * p % MOD);
    }
    return 0;
}
```

---

## 作者：UperFicial (赞：1)

为啥题解区全是推式子……甚至还有直接放结论然后归纳的（

既然我不会推式子，难道矩阵加速就没有地位了是吗？

不过我卡场卡得有点小恐怖，交了 1 页（

**注：本题解不是正解。**

[题目传送门](https://www.luogu.com.cn/problem/P4834)。

同步发表于我的 [$\text{cnblogs}$](https://www.cnblogs.com/UperFicial/p/16698913.html)。

题意是要求 $\frac{\sum_{i=1}^ni\times f_i}{n(n+1)\times \frac{1}{2}}$，$f_i$ 表示 $\texttt{Fibonacci}$ 数列第 $i$ 项。

分母直接 $\Theta(\log n)$ 求逆元，考虑分子。

寄 $S(n)\leftarrow\sum_{i=1}^ni\times f_i$，显然这个 $S(n)$ 是可递推的，直接上矩阵加速。

把 $S(n)$ 展开，把与 $n$ 有关的项，都换成 $(n-1)$ 或 $(n-2)$，因为斐波那契数列与 $n$ 有关的就是这两项。

$$
\begin{aligned}
S(n)&=S(n-1)+nf_n\\
&=S(n-1)+n\left(f_{n-1}+f_{n-2}\right)\\
&=S(n-1)+(n-1)f_{n-1}+(n-1)f_{n-2}+f_{n-1}+f_{n-2}
\end{aligned}
$$

假若我们把 $\begin{bmatrix}
S(n) \\
f_n\\
f_{n-1}
\end{bmatrix}$ 看作目标矩阵，发现 $(n-1)f_{n-1}$ 和 $(n-1)f_{n-2}$ 是不支持转移的，所以我们把 $nf_n$ 和 $nf_{n-1}$ 都放进矩阵中：

$$\begin{bmatrix}
S(n) \\
f_n \\
f_{n-1} \\
nf_n \\
nf_{n-1}
\end{bmatrix}$$

原矩阵为：

$$\begin{bmatrix}
S(n-1) \\
f_{n-1} \\
f_{n-2} \\
(n-1)f_{n-1} \\
(n-1)f_{n-2}
\end{bmatrix}$$

考虑目标矩阵每一个元素的转移：

- $S(n)$ 由 $S(n-1)+f_{n-1}+f_{n-2}+(n-1)f_{n-1}+(n-1)f_{n-2}$ 转移而来，选取所有元素，转移矩阵第一行为即为 $\begin{bmatrix}
 1 & 1 & 1 & 1 & 1
\end{bmatrix}$。

- $f_n$ 由 $f_{n-1}+f_{n-2}$ 转移而来。选取了第二个和第三个元素，则第二行为 $\begin{bmatrix}
 0 & 1 & 1 & 0 & 0
\end{bmatrix}$。

- $f_{n-1}$ 已经在原矩阵出现过了，直接将第二个系数标成 $1$ 即可。$\begin{bmatrix}
 0 & 1 & 0 & 0 & 0
\end{bmatrix}$

- $nf_n$ 直接展开就好了，小技巧是把 $n$ 看成 $(n-1)$，得到 $(n-1)f_{n-1}+(n-1)f_{n-2}+f_{n-1}+f_{n-2}$，除了第一个元素都选取了，所以第四行为 $\begin{bmatrix}
 0 & 1 & 1 & 1 & 1
\end{bmatrix}$。

- $nf_{n-1}$ 也好办，同样把 $n$ 看成 $(n-1)+1$，然后得到 $(n-1)f_{n-1}+f_{n-1}$，选取了第二个和第四个元素，所以转移矩阵最后一行应为 $\begin{bmatrix}
 0 & 1 & 0 & 1 & 0
\end{bmatrix}$。

这样就得到了我们的转移矩阵：

$$
\begin{bmatrix}
 1 & 1 & 1 & 1 & 1\\
 0 & 1 & 1 & 0 & 0\\
 0 & 1 & 0 & 0 & 0\\
 0 & 1 & 1 & 1 & 1\\
 0 & 1 & 0 & 1 & 0
\end{bmatrix}
$$

将这个做一下 $(n-2)$ 次幂，然后与 $f_1,f_2$ 构成的矩阵相乘即可。

但你会发现 T 飞了，因为你这个矩乘是 $\Theta(5^3)$ 的，单次询问 $\Theta(5^3\log n)$，总时间复杂度 $\Theta(125\times T\log n)$，约为 $3\times 10^9$。

考虑我们比正解逊在哪里，就是矩阵过大，但我们完全可以上一手循环展开啊！

~~当然你肯定不会傻到手打 $\sout{125}$ 行的矩乘吧（~~

~~我有一个绝妙的方法可惜我太懒不想写。~~

加一手快读然后一个氧气起飞啦。

[记录](https://www.luogu.com.cn/record/86716556)。

代码不给了，想要私信。

---

## 作者：BotDand (赞：1)

# $\text{Problems}$

给出 $n$ ，求 $\frac{\sum_{i=1}^{n} i \times F_{i}}{n\times(n+1)/2}$ 。

# $\text{Answer}$

$\sum_{i=1}^{n} i \times F_{i}=n \times F_{n+2}-F_{n+3}+2$

证明：

当 $n=1$ 时，原命题显然成立。

设 $n=k$ 时原命题成立

令 $f_{n}=\sum_{i=1}^{n} i \times F_{i}$

则

$$
f_{k+1}=f_{k}+F_{k+1} \times (k+1)\\
=k \times F_{k+2}-F_{k+3}+2+F_{k+1} \times (k+1)\\
=k \times F_{k+3}-F_{k+3}+2+F_{k+1}\\
=k \times F_{k+3}-F_{k+2}+2
$$

所以原命题成立。

这玩意用矩阵乘法算一下即可。

然后 $n\times(n+1)/2$ 求一下逆元即可。

注意取模。

开了 O2 居然跑了最优解/yun

# $\text{Code}$

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mo=998244353;
int t,n;
int A,B;
int m;
inline int read()
{
    int s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9') {if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
    return s*w;
}
inline void write(int x)
{
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
inline void print(int x)
{
    write(x);
    putchar('\n');
}
int ksm(int a,int b,int mo)
{
    int ans=1,x=a;
    while(b)
    {
        if(b&1) ans=ans%mo*x%mo;
        x=x%mo*x%mo;b>>=1;
    }
    return ans;
}
struct arr
{
    int a[3][3];
    arr() {memset(a,0,sizeof(a));}
    arr operator *(const arr &b) const
    {
        arr c;
        for(int i=1;i<=2;++i)
            for(int j=1;j<=2;++j)
                for(int k=1;k<=2;++k)
                    c.a[i][j]=(c.a[i][j]+a[i][k]*b.a[k][j]%mo)%mo;
        return c;
    }
}a,ans;
inline void work()
{
    n=read();
    B=ksm((((n+1)*n/2)%mo),mo-2,mo);
    a.a[1][1]=1;a.a[1][2]=1;
    a.a[2][1]=1;a.a[2][2]=0;
    ans.a[1][1]=1;ans.a[1][2]=0;
    ans.a[2][1]=0;ans.a[2][2]=1;
    m=n+1;
    while(m)
    {
        if(m&1) ans=ans*a;
        a=a*a;m>>=1;
    }
    A=(n*ans.a[1][1]%mo+mo-(ans.a[1][1]+ans.a[1][2])%mo+2+mo)%mo;
    print(A*B%mo);
}
signed main()
{
    t=read();
    while(t--) work();
}
```


---

## 作者：圣光天子 (赞：1)

这道题我看到题面的时候懵逼了好一会儿...

大概就是第一个电子触碰的概率是$P_1$的话，$P_i$值就为$i\cdot P_1$

设$F[i]$为斐波那契数列的第$i$项

那么就相当于要求$ans=\sum_{i=1}^{n}P_i\cdot F[i]$

$\because$ $\sum_{i=1}^nP_i=1$

$\therefore P_1=\frac{1}{n\cdot(n+1)/2}$

将上式展开，则可得$ans=\frac{\sum_{i=1}^ni\cdot F[i]}{n\cdot (n+1)/2}$

那么现在的问题就是求$\sum_{i=1}^ni\cdot F[i]$了

前置：斐波那契数列的求和公式$(\sum_{i=1}^{n}F[i]=F[n+2]-1)$

观察上式，可以发现对于第$i$项，需要进行$i$次累加

然后我们就可以将其转化为$ans=\sum_{i=1}^n\sum_{j=i}^{n}F[j]$

而$\sum_{j=i}^{n}F[j]$可变成$\sum_{j=1}^nF[j]-\sum_{j=1}^{i-1}F[j]$

即$F[n+2]-F[i+1]$

$\therefore ans=n\cdot F[n+2]-\sum_{i=1}^{n}F[i+1]$

$ans=n\cdot F[n+2]-F[n+3]+2$

将$n$代入该式即可求出答案

但是$n<=1e9$....

所以再用矩阵快速幂优化一下就可以过啦

(不会的右转[P1962](https://www.luogu.org/problem/P1962))

代码略丑....
```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<string>
#include<set>
#include<queue>

//using namespace std;

#define N 10
#define MOD 998244353

struct rect{
	long long t[N][N];
};

int t;
long long n,m,i,j,k,tk,ans1,ans2,ans,now;
rect a,w,r;

long long ksm(long long x,long long  k)
{
	long long ans=1; 
	while (k)
	{
		if (k%2!=0) ans=(ans*x)%MOD;
		k=k/2;
		x=((x*x)%MOD+MOD)%MOD;
	}
	return ans%MOD;
}

void reksm(rect x,long long c,rect &ans)
{
	static rect p;
	for (i=1; i<=2; i++) 
		for (j=1; j<=2; j++)
			if (i==j) ans.t[i][j]=1; else ans.t[i][j]=0;
	while (c)
	{
		if (c%2!=0)
		{
			for (i=1; i<=2; i++)
				for (j=1; j<=2; j++) p.t[i][j]=0;
			for (i=1; i<=2; i++)
				for (j=1; j<=2; j++) 
					for (k=1; k<=2; k++)
						p.t[i][j]=(p.t[i][j]+ans.t[i][k]*x.t[k][j]%MOD)%MOD;
			ans=p;
		}
		c=c/2;
		for (i=1; i<=2; i++)
			for (j=1; j<=2; j++) p.t[i][j]=0;
		for (i=1; i<=2; i++)
			for (j=1; j<=2; j++) 
				for (k=1; k<=2; k++)
					p.t[i][j]=(p.t[i][j]+x.t[i][k]*x.t[k][j]%MOD)%MOD;
		x=p;
	}
	return;
}

int main(){
	scanf("%lld",&t);
	for (tk=1; tk<=t; tk++)
	{
		scanf("%lld",&n); 
		a.t[1][1]=0; a.t[1][2]=1;
		a.t[2][1]=1; a.t[2][2]=1;
		reksm(a,n+1,w);
		for (i=1; i<=2; i++)
			for (j=1; j<=2; j++) r.t[i][j]=0;
		a.t[1][1]=1; a.t[1][2]=1; a.t[2][1]=0; a.t[2][2]=0;
		for (j=1; j<=2; j++)
			for (k=1; k<=2; k++)
				r.t[1][j]+=a.t[1][k]*w.t[k][j]%MOD;
		ans1=r.t[1][1];
		ans2=r.t[1][2]%MOD;
		ans1=((ans1*n)%MOD+MOD)%MOD;
		ans1=(ans1-ans2+MOD)%MOD;
		ans1+=2;
		now=(n*(n+1)/2)%MOD;
		now=ksm(now,MOD-2);
		ans1=(ans1*now)%MOD;
		printf("%lld\n",ans1);
	}
	return 0;
}
```


---

## 作者：Li2021 (赞：0)

题意即求

$$
\frac{2}{n(n+1)}\sum_{i=1}^{n}i\times F_i
$$

熟知

$$
\sum_{i=1}^{n}F_i=F_{n+2}-1
$$

则

$$
\begin{aligned}
\sum_{i=1}^{n}i\times F_i
&= n\times\sum_{i=1}^{n}F_i-\sum_{i=1}^{n}(n-i)F_i \\
&= n(F_{n+2}-1)-\sum_{i=1}^{n-1}\sum_{j=1}^{i}F_i \\
&= n(F_{n+2}-1)-\sum_{i=1}^{n-1}(F_{i+2}-1) \\
&= n\times F_{n+2}-n+n-1+F_{n+3}+1+2 \\
&= n\times F_{n+2}+F_{n+3}+2
\end{aligned}
$$

矩阵快速幂计算即可。

关键代码：
```cpp
matrix F1=qpow(n+2),F2=qpow(n+3);
ll res=((n*F1.a[1][2]%MOD-F2.a[1][2]+2)%MOD+MOD)%MOD;
res=(res*qpow(n*(n+1)%MOD,MOD-2)*2)%MOD;
cout<<res<<"\n";
```

---

## 作者：x383494 (赞：0)

本文是[《矩阵快速幂的常数优化——对角化与 Jordan 分解》](https://www.luogu.com.cn/article/grp38dqc)（[cnblogs 链接](https://www.cnblogs.com/x383494/p/18836969)）的省流版，由于洛谷没法一文投两种分类就只能拆成两篇文章了。

由于是省流版，因此只会提到大致思路。关于此优化更详细（也没多详细？）的介绍见原文。

## 题意

求 

$$
\dfrac{2}{n(n+1)} \sum \limits_{i=1}^{n}i \mathrm{Fib}(i)
$$

对 $998244353$ 取模后的值。

## 解法

可以无脑设状态为

$$
\mathbf{v} = \begin{bmatrix}
\mathrm{Fib}(n), \mathrm{Fib}(n-1), n\mathrm{Fib}(n), (n-1) \mathrm{Fib}(n-1), \sum \limits_{i=1}^{n-1}i\mathrm{Fib}(i)
\end{bmatrix}^T
$$

并写出转移矩阵

$$
A=\begin{bmatrix}
1 & 1 & 0 & 0 & 0 \\
1 & 0 & 0 & 0 & 0 \\
1 & 2 & 1 & 1 & 0 \\
0 & 0 & 1 & 0 & 0 \\
0 & 0 & 1 & 0 & 1
\end{bmatrix}
$$

但是矩阵太大，直接做会 TLE。

考虑用 Jordan 分解优化常数，即将 $A$ 分解为 $A = PJP^{-1}$，发现

$$
J = \begin{bmatrix}
1&               0&               0&               0&               0 \\
0&\dfrac{1-\sqrt5}{2}&               1&               0&               0 \\
0&               0&\dfrac{1-\sqrt5}{2}&               0&               0 \\
0&               0&               0& \dfrac{1+\sqrt5}{2}&               1 \\
0&               0&               0&               0& \dfrac{1+\sqrt5}{2}
\end{bmatrix}
$$

其对应的幂零矩阵

$$
\begin{bmatrix}
0 & 0 & 0 & 0 & 0 \\
0 & 0 & 1 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 1 \\
0 & 0 & 0 & 0 & 0
\end{bmatrix}
$$

的幂零指数为 $2$，因此

$$
J^k = \begin{bmatrix}
1 & 0 & 0 & 0 & 0 \\
0 & \lambda_1^k & k \lambda_1^{k-1} & 0 & 0 \\
0 & 0 & \lambda_1^k & 0 & 0 \\
0 & 0 & 0 & \lambda_2^k & k \lambda_2^{k-1} \\
0 & 0 & 0 & 0 & \lambda_2^k
\end{bmatrix}
$$

其中 $\lambda_1 = \dfrac{1-\sqrt5}{2}, \lambda_2 = \dfrac{1+\sqrt5}{2}$。

本来矩阵乘法有 $125$ 的常数，现在优化后只要做 $2$ 次快速幂即可。

## 实现细节

- 结果里出现了 $\sqrt5$，在 $\bmod \ 998244353$ 意义下需要扩域。
- 注意特判 $n \le 2$ 的情况。

于是我们在不推结论的情况下，用 $5 \times 5$ 的矩阵乘法通过了此题。[评测记录](https://www.luogu.com.cn/record/214478944)

## 代码

```cpp
#include <bits/stdc++.h>
#define UP(i,s,e) for(auto i=s; i<e; i++)
#define DOWN(i,e,s) for(auto i=e; i-->s;)
using std::cin; using std::cout;
using ll = long long;
constexpr int MOD = 998244353;
struct CC{ // Z_998244353[sqrt(5)]
    int re, im; // i = sqrt(5)
    CC(){}
    constexpr CC(int x, int y=0): re(x), im(y){}
    CC &operator+=(CC b){ re += b.re; im += b.im; re %= MOD; im %= MOD; return *this; }
    CC operator+(CC b) const { return b += *this; }
    CC operator-() const { return CC(MOD-re, MOD-im); }
    CC &operator-=(CC b){ return *this += -b; }
    CC operator-(CC b) const { return -b += *this; }
    CC operator*(CC b) const {
        ll ree = 1ll * re * b.re + 5ll * im * b.im;
        ll imm = 1ll * re * b.im + 1ll * im * b.re;
        return CC(ree % MOD, imm % MOD);
    }
    CC &operator*=(CC b) { return *this = *this * b; }
};
CC qpow(CC x, int t){
    CC ret = 1;
    while(t){
        if(t&1) ret *= x;
        x *= x;
        t >>= 1;
    }
    return ret;
}
namespace linear_algebra{ // }{{{
struct Matrix55{
    CC elem[5][5];
    Matrix55(){}
    Matrix55(CC val[]){
        UP(i, 0, 5) UP(j, 0, 5) elem[i][j] = val[i*5+j];
    }
    Matrix55 operator*(Matrix55 const& b){
        Matrix55 tmp;
        UP(i, 0, 5) UP(j, 0, 5) tmp.elem[i][j] = 0;
        UP(i, 0, 5) UP(j, 0, 5) UP(k, 0, 5){
            tmp.elem[i][k] += elem[i][j] * b.elem[j][k];
        }
        return tmp;
    }
};

constexpr CC inv2 = 499122177, inv5 = 598946612, inv10 = 299473306, sqrt5 = CC(0, 1);

Matrix55 Mat_P = [](){
    // Matrix([
    // [0,               0,                1,               0,                1],
    // [0,               0, -sqrt(5)/2 - 1/2,               0, -1/2 + sqrt(5)/2],
    // [0, 1/2 - sqrt(5)/2,  3/2 - sqrt(5)/2, 1/2 + sqrt(5)/2,  sqrt(5)/2 + 3/2],
    // [0,               1,                1,               1,                1],
    // [1, 3/2 - sqrt(5)/2,                0, sqrt(5)/2 + 3/2,                0]])
    CC val[] = {
        0, 0, 1, 0, 1,
        0, 0, -inv2 - sqrt5 * inv2, 0, -inv2 + sqrt5 * inv2,
        0, inv2 - sqrt5 * inv2, inv2 * 3 - sqrt5 * inv2, inv2 + sqrt5 * inv2, inv2 * 3 + sqrt5 * inv2,
        0, 1, 1, 1, 1,
        1, inv2 * 3 - sqrt5 * inv2, 0, sqrt5 * inv2 + inv2 * 3, 0
    };
    return Matrix55(val);
}();

Matrix55 Mat_P_inv = [](){
    // Matrix([
    // [                  3,          1,         -1,               -1, 1],
    // [-1/2 + 3*sqrt(5)/10,  sqrt(5)/5, -sqrt(5)/5, sqrt(5)/10 + 1/2, 0],
    // [   1/2 - sqrt(5)/10, -sqrt(5)/5,          0,                0, 0],
    // [-3*sqrt(5)/10 - 1/2, -sqrt(5)/5,  sqrt(5)/5, 1/2 - sqrt(5)/10, 0],
    // [   sqrt(5)/10 + 1/2,  sqrt(5)/5,          0,                0, 0]])
    CC val[] = {
        3, 1, MOD-1, MOD-1, 1,
        -inv2 + sqrt5*inv10*3, sqrt5*inv5, -sqrt5*inv5, sqrt5*inv10 + inv2, 0,
        inv2 - sqrt5*inv10, -sqrt5*inv5, 0, 0, 0,
        -sqrt5*inv10*3 - inv2, -sqrt5*inv5,  sqrt5*inv5, inv2 - sqrt5*inv10, 0,
        sqrt5*inv10 + inv2,  sqrt5*inv5, 0, 0, 0
    };
    return Matrix55(val);
}();

std::function<Matrix55(int)> calc_J_n = [](int n){
    CC lam1 = inv2 - sqrt5 * inv2, lam2 = inv2 + sqrt5 * inv2;
    CC lam1_n = qpow(lam1, n-1), lam2_n = qpow(lam2, n-1);
    CC val[] = {
        1, 0, 0, 0, 0,
        0, lam1_n * lam1, lam1_n * n, 0, 0,
        0, 0, lam1_n * lam1, 0, 0,
        0, 0, 0, lam2_n * lam2, lam2_n * n,
        0, 0, 0, 0, lam2_n * lam2
    };
    return Matrix55(val);
};

} // {}}}
namespace solver{ // }{{{
using namespace linear_algebra;
int in;
void work(){
    cin >> in;
    if(in <= 2){ cout << 1 << '\n'; return; }
    CC x = qpow(CC(in+1) * in, MOD-2) * 2;
    auto p = Mat_P * calc_J_n(in-1) * Mat_P_inv;
    CC s = p.elem[4][0] + p.elem[4][1] + p.elem[4][2]*2 + p.elem[4][3] + p.elem[4][4];
    s *= x;
    cout << s.re << '\n';
}
} // {}}}
int main(){
    int it; cin >> it;
    while(it--) solver::work(); 
    return 0;
}
```

---


# 『STA - R3』高维立方体

## 题目描述

如下定义斐波那契数列：
$$\operatorname{fib}(n)=\begin{cases}1&n\le 2\\\operatorname{fib}(n-1)+\operatorname{fib}(n-2)&n>2\end{cases}$$

现在我们定义一个函数（注意在 $n<1$ 时这个函数的值是 $0$）：

$$f(n)=\sum_{i=1}^n\operatorname{fib}^2(i)$$

由于求斐波那契数列的前缀和太简单了，你需要求出：
$$\sum_{i=1}^n\operatorname{fib}(i)\cdot(f(i-2)+\operatorname{fib}^2(i)+\operatorname{fib}(i))$$
的值，答案对输入的 $p$ 取模。

注：$\operatorname{fib}^2(x)$ 表示 $\operatorname{fib}(x)$ 的平方。

## 说明/提示

样例解释：

对于第一组数据，$1\times(0+1^2+1)+1\times(0+1^2+1)=4$。

对于第二组数据，$1\times(0+1^2+1)+1\times(0+1^2+1)+2\times(1+2^2+2)=18$。  
### 数据范围

**本题采用捆绑测试。**

- Subtask 1（5 points）：$n \le 10^7$，$p=10^9+7$。
- Subtask 2（20 points）：$T\le 10^4$，$n \le 10^8$，$p=10^9+7$。
- Subtask 3（5 points）：$p=2$。
- Subtask 4（15 points）：$p\le 5$。
- Subtask 5（30 points）：$T\le 10^4$，$n \le 10^8$。
- Subtask 6（25 points）：无特殊限制。

对于所有数据，$1\le T\le 2\times 10^5$，$1\le n\le 10^{18}$，$2\le p\le 10^9+7$。


## 样例 #1

### 输入

```
3
2 100
3 100
4 100```

### 输出

```
4
18
60```

# 题解

## 作者：zifanwang (赞：30)

这题的部分分比较好拿，就不细讲了。

Subtask 3 经过简单的推导可以发现这个式子的值一定是偶数，直接输出 $0$ 即可。

Subtask 4 求出这个式子的循环节。

Subtask 5 可以用一个大矩阵快速幂做，比较麻烦。

先考虑怎么求 $\sum_{i=1}^{n}\operatorname{fib}^2(i)$。如图，我们可以用若干个正方形的面积和来表示：

![](https://cdn.luogu.com.cn/upload/image_hosting/aiuqf1ru.png)

可以发现这个长方形的长是 $\operatorname{fib}(n+1)$，宽是 $\operatorname{fib}(n)$，得到：

$$\sum_{i=1}^{n}\operatorname{fib}^2(i)=\operatorname{fib}(n)\operatorname{fib}(n+1)$$

看到三个数的乘积我们可以想到立方体，上图（可能画得比较丑）：

![](https://cdn.luogu.com.cn/upload/image_hosting/nnhwn18t.png)

如果最大的立方体边长是 $\operatorname{fib}(n)$，那么红色部份的体积就是 $\operatorname{fib}(n)\operatorname{fib}(n-1)\operatorname{fib}(n-2)$，于是：

$$
\begin{aligned}
\sum_{i=1}^n\operatorname{fib}(i)\cdot(f(i-2)+\operatorname{fib}^2(i)+\operatorname{fib}(i))&=
\left(\sum_{i=1}^n\operatorname{fib}(i)f(i-2)+\operatorname{fib}^3(i)\right)+\sum_{i=1}^n\operatorname{fib}^2(i)\\&=
\operatorname{fib}^2(n)\operatorname{fib}(n+1)+\operatorname{fib}(n)\operatorname{fib}(n+1)
\end{aligned}
$$

矩阵快速幂即可，代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
#define rep(i,a,b) for(int i=a;i<=b;++i)
#define rept(i,a,b) for(int i=a;i<b;++i)
using namespace std;
inline ll read(){
	ll x=0;char ch=getchar();
	while(!isdigit(ch))ch=getchar();
	while(isdigit(ch))x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return x;
}
int t,md;
ll n,a,b,ans[3][3],l[3][3],d[3][3];
inline void mul(ll x[3][3],const ll y[3][3]){
    ll a=x[0][0],b=x[0][1],c=x[1][0],d=x[1][1];
    x[0][0]=(a*y[0][0]+b*y[1][0])%md;
    x[0][1]=(a*y[0][1]+b*y[1][1])%md;
    x[1][0]=(c*y[0][0]+d*y[1][0])%md;
    x[1][1]=(c*y[0][1]+d*y[1][1])%md;
}
inline void initd(){
	d[0][0]=0,d[0][1]=d[1][0]=d[1][1]=1;
}
void power(ll x){
    ans[0][0]=ans[1][1]=1;
    ans[0][1]=ans[1][0]=0;
    initd(); 
    for(;x;x>>=1){
        l[0][0]=d[0][0],l[0][1]=d[0][1];
        l[1][0]=d[1][0],l[1][1]=d[1][1];
        if(x&1)mul(ans,l);
        mul(d,l);
    }
}
signed main(){
	scanf("%d",&t);
	while(t--){
		n=read(),md=read();
		power(n-1);
		a=(ans[0][0]+ans[1][0])%md;
		b=(ans[0][1]+ans[1][1])%md;
		printf("%lld\n",(a*a+a)%md*b%md);
	}
	return 0;
}
```

---

## 作者：littlez_meow (赞：12)

虽然说数形结合是很好了，但我还是更喜欢纯代数推导些。

【引理】求证：$f(n)=\operatorname{fib}(n)\operatorname{fib}(n+1)$

证明：当 $n=1$ 时，$f(n)=f(1)=1=\operatorname{fib}(1)\operatorname{fib}(2)$，显然成立。

假设当 $n=t$ 时该式成立，下证当 $n=t+1$ 时该式也成立。

$$f(t+1)=f(t)+\operatorname{fib}^2(t+1)$$

$$=\operatorname{fib}(t)\operatorname{fib}(t+1)+\operatorname{fib}^2(t+1)$$

$$=\operatorname{fib}(t+1)(\operatorname{fib}(t+1)+\operatorname{fib}(t))$$

$$=\operatorname{fib}(t+1)\operatorname{fib}(t+2)$$

故对于 $n\ge 1$，均有 $f(n)=\operatorname{fib}(n)\operatorname{fib}(n+1)$。

$\Box$

下面开始推式子，原式为：

$$\sum\limits_{i=1}^n\operatorname{fib}(i)\cdot(f(i-2)+\operatorname{fib}^2(i)+\operatorname{fib}(i))$$

展开 $f(i-2)$，得：

$$\sum\limits_{i=1}^n\operatorname{fib}(i)\cdot(\operatorname{fib}(i-2)\operatorname{fib}(i-1)+\operatorname{fib}^2(i)+\operatorname{fib}(i))$$

去括号并拆开求和号，得：

$$\sum\limits_{i=1}^n(\operatorname{fib}(i-2)\operatorname{fib}(i-1)\operatorname{fib}(i)+\operatorname{fib}^3(i))+\sum\limits_{i=1}^n\operatorname{fib}^2(i)$$

将左边求和号中的 $\operatorname{fib}(i-2)$ 替换为 $\operatorname{fib}(i)-\operatorname{fib}(i-1)$，右边求和号用 $f(n)$ 替换，得：

$$\sum\limits_{i=1}^n((\operatorname{fib}(i)-\operatorname{fib}(i-1))\operatorname{fib}(i-1)\operatorname{fib}(i)+\operatorname{fib}^3(i))+f(n)$$

去括号，整理：

$$\sum\limits_{i=1}^n(\operatorname{fib}^2(i)\operatorname{fib}(i-1)+\operatorname{fib}^3(i)-\operatorname{fib}^2(i-1)\operatorname{fib}(i))+\operatorname{fib}(n)\operatorname{fib}(n+1)$$

提出 $\operatorname{fib}^2(i)$：

$$\sum\limits_{i=1}^n(\operatorname{fib}^2(i)(\operatorname{fib}(i-1)+\operatorname{fib}(i))-\operatorname{fib}^2(i-1)\operatorname{fib}(i))+\operatorname{fib}(n)\operatorname{fib}(n+1)$$

$\operatorname{fib}(i-1)+\operatorname{fib}(i)$ 正好可以加成 $\operatorname{fib}(i+1)$：

$$\sum\limits_{i=1}^n(\operatorname{fib}^2(i)\operatorname{fib}(i+1)-\operatorname{fib}^2(i-1)\operatorname{fib}(i))+\operatorname{fib}(n)\operatorname{fib}(n+1)$$

求和号里面就可以裂项相消了：

$$\operatorname{fib}^2(n)\operatorname{fib}(n+1)-\operatorname{fib}^2(0)\operatorname{fib}(1)+\operatorname{fib}(n)\operatorname{fib}(n+1)$$

递推式可以倒推出 $\operatorname{fib}(0)=0$，因此答案就是：

$$\operatorname{fib}^2(n)\operatorname{fib}(n+1)+\operatorname{fib}(n)\operatorname{fib}(n+1)$$

矩阵加速递推就可以了，时间复杂度 $O(T\log n)$

注意到矩阵每次可以同时求出 $\operatorname{fib}(n),\operatorname{fib}(n+1)$，只需递推一次。

矩阵乘法不要一步一取模，否则你的常数会让你 [TLE 三个点](luogu.com.cn/record/119865361)。

自此，本题完成。

## 附上代码

```cpp
#include<bits/stdc++.h>
#define ll long long
#define f(i,a,b) for(register int i(a);i<=b;++i)
#define r(i,a,b) for(register int i(a);i>=b;--i)
using namespace std;
ll n;
int p,t;
struct vec{
	ll range[3];
	void init(){
		f(i,1,2) range[i]=0;
		return;
	}
};
struct matrix{
	ll range[3][3];
	void init(){
		f(i,1,2) f(j,1,2) range[i][j]=0;
		return;
	}
	matrix operator*(const matrix a)const{
		matrix res;
		res.init();
		f(i,1,2) f(j,1,2){
			f(k,1,2) res.range[i][j]+=range[i][k]*a.range[k][j];
			res.range[i][j]%=p;
		}
		return res;
	}
	vec operator*(const vec a)const{
		vec res;
		res.init();
		f(i,1,2) f(j,1,2) res.range[i]=(res.range[i]+range[i][j]*a.range[j])%p;
		return res;
	}
};
const matrix E={{{0,0,0},{0,1,0},{0,0,1}}};
inline matrix qpow(matrix base,ll expo){
	matrix res=E;
	while(expo){
		if(expo&1) res=res*base;
		base=base*base;
		expo>>=1;
	}
	return res;
}
const matrix f={{{0,0,0},{0,1,1},{0,1,0}}};
const vec a={{0,1,1}};
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	for(cin>>t;t;--t){
		cin>>n>>p;
		vec ans=qpow(f,n-1)*a;
		cout<<ans.range[1]*ans.range[2]%p*(ans.range[2]+1)%p<<"\n";
	}
	return 0;
}
```
不喜勿喷 qwq~


---

## 作者：mlvx (赞：8)

### 引理

$\sum\limits^n_{i=1}\operatorname{fib}^2(i)=\operatorname{fib}(n)\operatorname{fib}(n+1)$，数学归纳法经典。

假设该式成立，则该式在 $n-1$ 时均成立，故 $\sum\limits^n_{i=1}\operatorname{fib}^2(i)=\left(\sum\limits^{n-1}_{i=1}\operatorname{fib}^2(i)\right)+\operatorname{fib}^2(n)=\operatorname{fib}(n-1)\operatorname{fib}(n)+\operatorname{fib}^2(n)=\operatorname{fib}(n)\cdot(\operatorname{fib}(n)+\operatorname{fib}(n-1))=\operatorname{fib}(n)\operatorname{fib}(n+1)$。

可推导出假设该式在 $n-1$ 时成立，在 $n$ 时也成立。

当 $n=2$ 时显然成立。

### 分析

把求的式子整理一下，得 $\sum\limits_{i=1}^n\operatorname{fib}(i)\cdot(f(i-2)+\operatorname{fib}^2(i)+\operatorname{fib}(i))=\sum\limits_{i=1}^n\operatorname{fib}(i)\cdot(\operatorname{fib}(i-2)\operatorname{fib}(i-1)+\operatorname{fib}^2(i)+\operatorname{fib}(i))=\sum\limits_{i=1}^n\operatorname{fib}(i)\operatorname{fib}(i-1)\operatorname{fib}(i-2)+\operatorname{fib}^3(i)+\operatorname{fib}^2(i)$。

把 $\operatorname{fib}(i-2)$ 用 $\operatorname{fib}(i)-\operatorname{fib}(i-1)$ 表示出来，得 $\sum\limits_{i=1}^n\operatorname{fib}(i)\operatorname{fib}(i-1)(\operatorname{fib}(i)-\operatorname{fib}(i-1))+\operatorname{fib}^3(i)+\operatorname{fib}^2(i)$。

把里面的展开，得 $\sum\limits_{i=1}^n\operatorname{fib}^2(i)\operatorname{fib}(i-1)-\operatorname{fib}(i)\operatorname{fib}^2(i-1)+\operatorname{fib}^3(i)+\operatorname{fib}^2(i)$。

提 $\operatorname{fib}^2(i)$，得 $\sum\limits_{i=1}^n\operatorname{fib}^2(i)\cdot(\operatorname{fib}(i-1)+\operatorname{fib}(i))-\operatorname{fib}(i)\operatorname{fib}^2(i-1)+\operatorname{fib}^2(i)$。

由斐波那契的定义，可得 $\sum\limits_{i=1}^n\operatorname{fib}^2(i)\operatorname{fib}(i+1)-\operatorname{fib}(i)\operatorname{fib}^2(i-1)+\operatorname{fib}^2(i)$。

把求和符号展开发现可以消除，得 $\operatorname{fib}^2(1)\operatorname{fib}(2)-\operatorname{fib}(1)\operatorname{fib}^2(0)+\operatorname{fib}^2(2)\operatorname{fib}(3)-\operatorname{fib}(2)\operatorname{fib}^2(1)+\dots+\operatorname{fib}^2(n)\operatorname{fib}(n+1)-\operatorname{fib}(n)\operatorname{fib}^2(n-1)+\sum\limits^n_{i=1}\operatorname{fib}^2(i)$。

中间相消，并把前面的 $\sum\limits^n_{i=1}\operatorname{fib}^2(i)=\operatorname{fib}(n)\operatorname{fib}(n+1)$ 代入，得 $\operatorname{fib}(1)\operatorname{fib}^2(0)+\operatorname{fib}^2(n)\operatorname{fib}(n+1)+\operatorname{fib}(n)\operatorname{fib}(n+1)$。

而题目中规定了当 $n<1$ 时，$\operatorname{fib}(n)=0$，故所求即为 $\operatorname{fib}^2(n)\operatorname{fib}(n+1)+\operatorname{fib}(n)\operatorname{fib}(n+1)=\operatorname{fib}(n)\operatorname{fib}(n+1)(\operatorname{fib}(n)+1)$。

这个式子用矩阵快速幂求斐波那契第 $n+1$ 项即可。

记得要循环展开，会快很多。

### 代码

```cpp
#include<bits/stdc++.h>
namespace fastIO{
    inline bool digit(register char c){return c>=48&&c<=57;}
    static char BUF[1000000],*P1=BUF,*P2=BUF,OBUF[1000000],*P3=OBUF;
    inline char gc(){return P1==P2&&(P2=(P1=BUF)+fread(BUF,1,1000000,stdin),P1==P2)?EOF:*P1++;}
    inline void pc(register char x){(P3-OBUF<1000000)?(*P3++=x):(fwrite(OBUF,P3-OBUF,1,stdout),P3=OBUF,*P3++=x);}
    template<typename item>inline void uread(register item&x){
        register char c;
        for(;!digit(c=gc()););
        for(x=c^48;digit(c=gc());)x=(x<<3)+(x<<1)+(c^48);
    }template<typename item>inline void read(register item&x){
        register char c;register bool f=0;
        for(;!digit(c=gc());)if(c==45)f=1;
        for(x=c^48;digit(c=gc());)x=(x<<3)+(x<<1)+(c^48);
        f&&(x=-x);
    }static char STACK[20];
    template<typename item>inline void uwrite(register item x){
        if(!x)return pc(48);
        register unsigned short len=0;
        for(;x;x/=10)STACK[len++]=x%10|48;
        for(;len--;)pc(STACK[len]);
    }template<typename item>inline void write(register item x){
        if(!x)return pc(48);
        if(x<0)pc(45),x=-x;
        register unsigned short len=0;
        for(;x;x/=10)STACK[len++]=x%10|48;
        for(;len--;)pc(STACK[len]);
    }inline void endl(){pc(10);}
    inline void space(){pc(32);}
    inline void close(){fwrite(OBUF,P3-OBUF,1,stdout);}
}using namespace fastIO;
using namespace std;
#define ll long long
int T,mod;ll n;
inline int MOD(int x){return x>=mod?x-mod:x;}
struct Matrix{int a[10][10];}qwq,base;
inline Matrix operator*(const Matrix&a,const Matrix&b){
    Matrix ret;memset(ret.a,0,sizeof ret.a);
    ret.a[0][0]=MOD(1ll*a.a[0][0]*b.a[0][0]%mod+1ll*a.a[0][1]*b.a[1][0]%mod);
    ret.a[0][1]=MOD(1ll*a.a[0][0]*b.a[0][1]%mod+1ll*a.a[0][1]*b.a[1][1]%mod);
    ret.a[1][0]=MOD(1ll*a.a[1][0]*b.a[0][0]%mod+1ll*a.a[1][1]*b.a[1][0]%mod);
    ret.a[1][1]=MOD(1ll*a.a[1][0]*b.a[0][1]%mod+1ll*a.a[1][1]*b.a[1][1]%mod);
    return ret;
}inline Matrix qpow(Matrix ret,Matrix a,ll b){
    for(;b;b>>=1,a=a*a)if(b&1)ret=ret*a;
    return ret;
}int main(){
    qwq.a[0][0]=qwq.a[0][1]=1,base.a[0][0]=base.a[0][1]=base.a[1][0]=1;
	read(T);
    while(T--){
        read(n),read(mod);
        Matrix ans=qpow(qwq,base,n-1);
        write(1ll*ans.a[0][0]*ans.a[0][1]%mod*(ans.a[0][1]+1)%mod),endl();
    }return close(),0;
}
```

---

## 作者：sidekick257 (赞：5)

### update on 2023.12.19
修改了两处笔误


为方便表示，设 $a=\frac{1+\sqrt{5}}{2},b=\frac{1-\sqrt{5}}{2}$

$$5fib^2(i)=(a^i-b^i)(a^i-b^i)=a^{2i}+b^{2i}-2(ab)^i=a^{2i}+b^{2i}-2(-1)^i$$

$$5f(n)=\sum_{i=1}^n a^{2i}+b^{2i}-2(-1)^i=a^{2n+1}+b^{2n+1}-(-1)^n$$

原式化为：
$$
f(n)+\frac{1}{5\sqrt{5}}(\sum_{i=1}^n \sqrt{5} fib(i)(5fib^2(i)+5f(i-2)))
$$
先看括号里的：
$$
5fib(i)^2+5f(i-2)=a^{2i}+b^{2i}-2(-1)^i+a^{2i-3}+b^{2i-3}-(-1)^i=2a^{2i-1}+2b^{2i-1}-3(-1)^i
$$
这个乘 $\sqrt{5}fib(i)$ 就是：
$$
(2a^{2i-1}+2b^{2i-1}-3(-1)^i)(a^i-b^i)=2a^{3i-1}-2b^{3i-1}-2(-1)^i(a^{i-1}-b^{i-1})-3(-1)^i(a^i-b^i)
$$
显然可以拆成 $2\times3$ 个等比数列（在此只写关于 $a$ 的，$b$ 同理）：
$$
\sum2a^{3i-1}=2a^2\frac{a^{3n}-1}{a^3-1}=a^{3n+1}-a
$$

$$
\sum2(-a)^{i-1}=2\frac{(-a)^n-1}{-a-1}=2(-1)^na^{n-2}-2b^2
$$

$$
\sum-3(-a)^i=3a\frac{(-a)^n-1}{-a-1}=3(-1)^na^{n-1}-3b
$$

把这六个式子加起来：
$$
a^{3n+1}-b^{3n+1}-a+b+2(-1)^n(a^{n-2}-b^{n-2})-2b^2+2a^2+3(-1)^n(a^{n-1}-b^{n-1})-3b+3a
$$


如果 $5$ 有逆元或者 $2$ 有逆元这道题就做完了，但是出题人不是很友善，模数居然可以不是质数，必须把 $5\sqrt{5}$ 再搞进去。

你考虑用三个斐波数相乘来凑出来这个。
$$
F_iF_jF_k=a^{3n+1}-b^{3n+1}+2(-1)^n(a^{n-2}-b^{n-2})+3(-1)^n(a^{n-1}-b^{n-1})
$$

$$
a^{i+j+k}-b^{i+j+k}+a^kb^{i+j}-a^{i+j}b^k-(-1)^j(a^{i-j+k}+b^{i-j+k}-(-1)^k(a^{i-j-k}-b^{i-j-k}))
$$

$$
a^{i+j+k}-b^{i+j+k}-(-1)^{i+j-k}(a^{i+j-k}-b^{i+j-k})-(-1)^j(a^{i-j+k}+b^{i-j+k})+(-1)^{j+k}(a^{i-j-k}-b^{i-j-k})
$$

你发现有一个很抽象的卢卡斯数混进去了，先把卢卡斯换成斐波那契。
$$
a^{i+j+k}-b^{i+j+k}-(-1)^{i+j-k}(a^{i+j-k}-b^{i+j-k})-(-1)^j(a^{i-j+k-1}-b^{i-j+k-1})-(-1)^j(a^{i-j+k+1}-b^{i-j+k+1})+(-1)^{j+k}(a^{i-j-k}-b^{i-j-k})
$$
这个式子里没有可以相互消掉的项，所以这些项中的每一个都是接近 $n$ 的。

经过尝试，你会发现如果 $i>j+k$ 最后不可能所有项都接近 $n$。

于是把最后一项换成 $-(-1)^{j+k}(a^{j+k-i}-b^{j+k-i})$。

然后你发现现在的每一项都是两个减一个的形式，容易想到 $i,j,k$ 都十分接近 $n$。

提出一个 $(-1)^n$，然后用二元组 $(x,y)$ 表示 $(-1)^x(a^y-b^y)$。

四项分别是：
$$
(i+j-k,i+j-k)(j+1,i-j+k-1)(j+1,i-j+k+1)(j+k+1,j+k-i)
$$

$$
(n+1,i+j-k)(j+1,i-j+k-1)(j+1,i-j+k+1)(i,j+k-i)
$$



观察到 $j+1$ 一定得是正数，不然就太小了。

换成齐肯多夫表示，你发现你现在是 $101$，你要变成 $32$，用齐肯多夫表达式比较多的同学肯定看出来了，$1010=0032-0001$，而 $0001=0100-0010$。

解出来之后发现答案是 $i=n,j=n+1,k=n$。

然后式子里还有一个 $f(n)$ 没解决，对斐波数展开或因式分解比较熟练的同学会发现这个是 $F_nF_{n+1}$。

最后的做法和其他题解都一样，代码就不放了。
         



---

## 作者：Allan_Xu (赞：3)

### [题目传送门](https://www.luogu.com.cn/problem/P9510)

我看见许多大佬都写的是**数形结合**的（这确实非常易懂），我来写一篇纯数字的吧。

### 1、处理 $f(i)$

对于单个的 $fib^2(i)$：

$$fib^2(i)=((fib(i)+fib(i-1))\times fib(i))-fib(i)\times fib(i-1)=fib(i+1)\times fib(i)-fib(i)\times fib(i-1)$$

由于 $f(i)=\sum_{i=1}^{n}fib^2{i}$。

所以将 $\sum$ 展开，你就会发现两两相消了（类似小学奥数中的**裂项拆项**的思维）。

所以最后可以得出：$f(n)=fib(n+1)\times fib(n)$。

### 2、处理答案数列

$\sum_{i=1}^{n}fib(i)\times (f(i-2)+fib^2(i)+fib(i))$

将 $f(i-2)$ 替换成刚才推出来的式子。

$=\sum_{i=1}^{n}fib(i)\times (fib(i-1)\times fib(i-2)+fib^2(i)+fib(i))$

将 $fib(i)$ 乘进去。

$=\sum_{i=1}^{n}fib(i)\times fib(i-1)\times fib(i-2)+fib^2(i)+fib^3(i)$

将 $\sum_{i=1}^{n}fib^2(i)$ 单独拉出来，可见即为定义的 $f(i)$。

$=(\sum_{i=1}^{n}fib(i)\times fib(i-1)\times fib(i-2)+fib^3(i))+f(i)$

将式中的 $fib(i-2)$ 拆成 $fib(i)-fib(i-1)$，并将括号打开。

$=(\sum_{i=1}^{n}fib^2(i)\times fib(i-1)-fib(i)\times fib^2(i-1)+fib^3(i))+f(i)$

将 $fib^2(i)\times fib(i-1)$ 和 $fib^3(i)$ 提出一个 $fib^2(i)$，得到 $fib^2(i)\times (fib(i-1)+fib(i))=fib^2(i)\times fib(i+1)$。

$=(\sum_{i=1}^{n}fib^2(i)\times fib(i+1)-fib^2(i-1)\times fib(i))+f(i)$

可以发现 $\sum_{i=1}^{n}fib^2(i)\times fib(i+1)-fib^2(i-1)\times fib(i)$ 又可以像**步骤 1** 中一样处理。

所以最后：

$=fib^2(n)\times fib(n+1)+fib(n)\times fib(n+1)$

### 3、矩阵快速幂

这一步可以用矩阵快速幂处理出 $fib(n+1),fib(n)$。

（不会请见 [P1962 斐波那契数列](https://www.luogu.com.cn/problem/P1962)）

另外，不要乘一个模一个，不然有概率会 TLE，（根据写法不同而异）。

*code*

```cpp
#include <bits/stdc++.h>
#define int long long 
using namespace std;
inline long long read(){//快读
	long long x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int n,m;
struct matrix{
	int a[3][3];
	matrix(){
		memset(a,0,sizeof(a));
	}
	inline void build(){
		a[1][1]=a[1][2]=1;
	}
	inline void init(){
		a[1][2]=a[2][1]=a[2][2]=1;
	}
	matrix operator *(const matrix &b)const{
		matrix c;
		for(int i=1;i<=2;i++)	
			for(int j=1;j<=2;j++)
				for(int k=1;k<=2;k++)
					c.a[i][j]+=a[i][k]*b.a[k][j],c.a[i][j]%=m;
		return c;
	}
}fib,ans;
matrix quick_pow(matrix a,long long x){
	matrix res;
	res.build();
	for(;x;x>>=1,a=a*a)
		if(x&1)res=res*a;
	return res;
}
signed main(){
	fib.init();
int t;t=read();
while(t--){ 
	n=read(),m=read();
	ans=quick_pow(fib,n-1);
	cout << (ans.a[1][1]*ans.a[1][1]%m*ans.a[1][2]%m+ans.a[1][1]%m*ans.a[1][2]%m)%m<<"\n";
}
		return 0;
} 
```

---

## 作者：Sky_city (赞：3)

# Part 1-数学部分：
## 第一部分：证明 $f(n)=\operatorname{fib}(n)\operatorname{fib}(n+1)$

数学归纳法证明：
$$\text{当}\ n=1\ \text{时，显然成立}$$
$$\text{令}\ n=k\ \text{原式成立}$$
$$\text{只需证明}\ n=k+1\ \text{即可}$$
$$f(k+1)=f(k)+\operatorname{fib^2}(k+1)$$
$$=\operatorname{fib}(k)\operatorname{fib}(k+1)+\operatorname{fib^2}(k+1)$$
$$=\operatorname{fib}(k+1)[\operatorname{fib}(k+1)+\operatorname{fib}(k)]$$
$$=\operatorname{fib}(k+1)\operatorname{fib}(k+2)$$
证毕。

## 第二部分：将求和公式展开：

将 $f(x)$ 关于 $\operatorname{fib}(x)$ 的表达式带入和式：

$$\sum\limits_{i=1}\limits^n\operatorname{fib}(i)\cdot(\operatorname{fib}(i-2)\operatorname{fib}(i-1)+\operatorname{fib^2}(i)+\operatorname{fib}(i))$$
展开：
$$\sum\limits_{i=1}\limits^n(\operatorname{fib}(i-2)\operatorname{fib}(i-1)\operatorname{fib}(i)+\operatorname{fib^3}(i))+\sum\limits_{i=1}\limits^n\operatorname{fib^2}(i)$$
注意到右边和式即为 $f(n)$，也是 $\operatorname{fib}(n)\operatorname{fib}(n+1)$，并把 $\operatorname{fib}(i-2)$ 替换为 $\operatorname{fib}(i)-\operatorname{fib}(i-1)$，带入并展开整理得：
$$\sum\limits_{i=1}\limits^{n}(\operatorname{fib}^2(i)\operatorname{fib}(i-1)+\operatorname{fib}^3(i)-\operatorname{fib}^2(i-1)\operatorname{fib}(i))+\operatorname{fib}(n)\operatorname{fib}(n+1)$$
提出 $\operatorname{fib}^2(i)$:
$$\sum\limits_{i=1}\limits^n(\operatorname{fib}^2(i)(\operatorname{fib}(i-1)+\operatorname{fib}(i))-\operatorname{fib}^2(i-1)\operatorname{fib}(i))+\operatorname{fib}(n)\operatorname{fib}(n+1)$$
将 $\operatorname{fib}(i-1)+\operatorname{fib}(i)$ 替换成 $\operatorname{fib}(i+1)$:
$$\sum\limits_{i=1}\limits^n(\operatorname{fib}^2(i)\operatorname{fib}(i+1)-\operatorname{fib}^2(i-1)\operatorname{fib}(i))+\operatorname{fib}(n)\operatorname{fib}(n+1)$$
展开相消，并注意到 $\operatorname{fib}(0)=0$，因此解得答案为：
$$\operatorname{fib}^2(n)\operatorname{fib}(n+1)+\operatorname{fib}(n)\operatorname{fib}(n+1)$$
## 第三部分：矩阵快速幂求斐波那契数列
得到答案后，若采取 $F_n=F_{n-1}+F_{n-2}(n\ge2)$ 的递推通项公式算时间复杂度为 $O(n)$，必会超时，需采取矩阵快速幂求解，下面讲解原理：

设 $F_n=[f_n,f_{n+1}]$，定义矩阵 $A=\left[\begin{array}{c}
a & b \\
c & d
\end{array}\right]
$，令 $F_{n+1}=F_n\times A$，解得 $A=\left[\begin{array}{c}0&1\\1&1\end{array}\right]$，已知 $F_1=[1,1]$，因此 $F_n=F_1\times A^{n-1}$，利用矩阵快速幂求解，时间复杂度 $O(\log n)$。
# Part 2-代码部分
先介绍一下矩阵乘法，设 $n\times m$ 阶的矩阵 $A$ 乘 $m\times k$ 阶的矩阵 $B$ 的结果 $n\times k$ 阶的矩阵 $C$，则 $C[i][j]=A[i][0]\times B[0][j]+A[i][1]\times B[j][1]+\cdots+A[i][m-1]\times B[m-1][j]$，代码如下：
```cpp
for(int i=1;i<=n;i++)
	for(int j=1;j<=k;j++)
		for(int p=1;p<=m;p++)
			c[i][j]+=a[i][p]*b[p][j];
```
然后对矩阵乘法进行重载，从而实现快速幂，快速幂部分代码如下：
```cpp
matrix qpow(matrix A,int b){
    matrix res;
    res.build();
    while(b)
    {
        if(b&1)
            res=res*A;
        b/=2;
        A=A*A;
    }
    return res;
}
```
* 注意事项：不开 `long long` 见祖宗！

My AC code:
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int T,n,p,sum;
struct matrix{
	int a[3][3];
	matrix(){
		memset(a,0,sizeof(a));
	}
	inline void build(){
		a[0][0]=a[0][1]=a[1][0]=a[2][1]=a[2][2]=0;
		a[1][1]=a[1][2]=1;
	}//F_1
	inline void init(){
		a[0][0]=a[0][1]=a[1][0]=a[1][1]=0;
		a[1][2]=a[2][1]=a[2][2]=1;
	}//A
	matrix operator *(const matrix &b)const{
		matrix c;
		for(int i=1;i<=2;i++)	
			for(int j=1;j<=2;j++)
				for(int k=1;k<=2;k++)
					c.a[i][j]+=a[i][k]*b.a[k][j],c.a[i][j]%=p;
		return c;
	}
}fib,ans;
matrix qpow(matrix A,int b){
    matrix res;
    res.build();
    while(b)
    {
        if(b&1)
            res=res*A;
        b/=2;
        A=A*A;
    }
    return res;
}
signed main(){
	fib.init();
	scanf("%lld",&T);
	while(T--)
	{
		scanf("%lld%lld",&n,&p);
		ans=qpow(fib,n-1);
		sum=((ans.a[1][1]*ans.a[1][1]%p*ans.a[1][2]%p)+ans.a[1][1]*ans.a[1][2]%p)%p;
		printf("%lld\n",sum);
	}
	return 0;
}
```

---

## 作者：RootMirzayanov (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P9510)

## 题意

给定正整数 $n,p$，求 

$$\left(\sum\limits_{i=1}^n\operatorname{fib}(i)\left(f(i-2)+\operatorname{fib}^2(i)+\operatorname{fib}(x)\right)\right)\bmod p$$

的值，其中 $\operatorname{fib}(x)$ 表示斐波那契数列中第 $x$ 个数，$f(x)=\sum\limits_{i=1}^x\operatorname{fib}^2(i)$。

（下文中全部记号均遵循于此）

## 解析

纯推式子题，不过比较恶心，涉及的算法数论知识并不多。

我们首先证明一个引理：

$\mathbf{Lemma\ 1}:\qquad\sum\limits_{i=1}^n\operatorname{fib}^2(i)=\operatorname{fib}(n+1)\operatorname{fib}(n)$

$\mathbf{Prove}:\qquad$ 观察到 $\operatorname{fib}(x)=\operatorname{fib}(x+1)-\operatorname{fib}(x-1)$，我们可以对所有的 $\operatorname{fib}^2(i)=\operatorname{fib}(i+1)\operatorname{fib}(i)-\operatorname{fib}(i)\operatorname{fib}(i-1)$ 进行如此的变形，我们可以发现在求和号内可以进行裂项相消，则有

$$\begin{aligned}\sum\limits_{i=1}^n\operatorname{fib}^2(i)&=\sum\limits_{i=1}^n\operatorname{fib}(i+1)\operatorname{fib}(i)-\operatorname{fib}(i)\operatorname{fib}(i-1)\\&=\operatorname{fib}(n+1)\operatorname{fib}(n)-\operatorname{fib}(0)\operatorname{fib}(1)\\&=\operatorname{fib}(n+1)\operatorname{fib}(n)&\square\end{aligned}$$

注意关于 $\operatorname{fib}(x)$ 的变形（$\operatorname{fib}(x+1)-\operatorname{fib}(x-1)$，$\operatorname{fib}(x-1)+\operatorname{fib}(x-2)$，$\operatorname{fib}(x+2)-\operatorname{fib}(x+1)$）以及**裂项相消**的思想在接下来的证明尤其重要且常用，读者不妨在接下来的证明以及其他相关斐波那契数列中的推导多多注意且运用。

根据我们刚刚证出的引理 $1$，我们便得出了 $f(x)=\operatorname{fib}(x+1)\operatorname{fib}(x)$ 的结论。接下来我们来推导非模意义下的原式：

$$\begin{aligned}&\quad\sum\limits_{i=1}^n\operatorname{fib}(i)\left(f(i-2)+\operatorname{fib}^2(i)+\operatorname{fib}(x)\right)\\&=\sum\limits_{i=1}^n\operatorname{fib}^2(i)+\operatorname{fib}^3(i)+\operatorname{fib}(i)\operatorname{fib}(i-1)\operatorname{fib}(i-2)\\&=\operatorname{fib}(n)\operatorname{fib}(n+1)+\sum\limits_{i=1}^n\operatorname{fib}^3(i)+\operatorname{fib}(i)\operatorname{fib}(i-1)\operatorname{fib}(i-2)\end{aligned}$$

接下来我们将 $\operatorname{fib}(n)\operatorname{fib}(n+1)$ 部分减去，对剩余部分进行化简处理。由于 $\operatorname{fib}^3(i)$ 较难处理，并且对和式求和也较难化简，所以我们可以先对 $\operatorname{fib}(i-2)=\operatorname{fib}(i)-\operatorname{fib}(i-1)$ 进行这样的处理，如此我们不仅可以将剩余的式子化为只有 $\operatorname{fib}(i)$ 和 $\operatorname{fib}(i-1)$ 的形式，而且我们可以构造出一个差式便于接下来**裂项相消**从而去掉求和号。我们继续推导：

$$\begin{aligned}&\quad\sum\limits_{i=1}^n\operatorname{fib}^3(i)+\operatorname{fib}(i)\operatorname{fib}(i-1)\operatorname{fib}(i-2)\\&=\sum\limits_{i=1}^n\operatorname{fib}^3(i)+\operatorname{fib}^2(i)\operatorname{fib}(i-1)-\operatorname{fib}^2(i-1)\operatorname{fib}(i)\\&=\sum\limits_{i=1}^n\operatorname{fib}^2(i)(\operatorname{fib}(i)+\operatorname{fib}(i-1))-\operatorname{fib}^2(i-1)\operatorname{fib}(i)\\&=\sum\limits_{i=1}^n\operatorname{fib}^2(i)\operatorname{fib}(i+1)-\operatorname{fib}^2(i-1)\operatorname{fib}(i)\\&=\operatorname{fib}^2(n)\operatorname{fib}(n+1)-\operatorname{fib}^2(0)\operatorname{fib}(1)\\&=\operatorname{fib}^2(n)\operatorname{fib}(n+1)\end{aligned}$$

综上我们可以得到原式等于 $\operatorname{fib}(n)\operatorname{fib}(n+1)+\operatorname{fib}^2(n)\operatorname{fib}(n+1)$，用矩阵快速幂求 $\operatorname{fib}(n)$ 与 $\operatorname{fib}(n+1)$ 即可。

而答案式同样可以化为 $\operatorname{fib}(n+1)\operatorname{fib}(n)(\operatorname{fib}(n)+1)$ 三个整式相乘的形式，即为三维空间内立方体求体积公式，或许有数形结合的做法，但是我不会，也没想出来。

代码实现时请注意必要的常数优化。

---

Update：看到了出题人大佬的题解和另一位也是纯推式子的佬的题解，感觉数形结合还是比较困难但是很妙，具体做题时还是看个人理解和思想。

---

## 作者：Exp10re (赞：1)

有趣数学推导题。

## 解题思路

先把要算的结果拆开：

$$Ans=\sum_{i=1}^n\operatorname{fib}(i)\cdot(f(i-2)+\operatorname{fib}^2(i)+\operatorname{fib}(i))$$

$$Ans=\sum_{i=1}^n\operatorname{fib}(i)f(i-2)+\operatorname{fib}^3(i)+\operatorname{fib}^2(i)$$

$$Ans=\sum_{i=1}^n\operatorname{fib}(i)f(i-2)+\sum_{i=1}^n\operatorname{fib}^3(i)+\sum_{i=1}^n\operatorname{fib}^2(i)$$

$$Ans=\sum_{i=1}^n\operatorname{fib}(i)f(i-2)+\sum_{i=1}^n\operatorname{fib}^3(i)+f(n)$$

显然我们需要先算出 $f(n)$ 的通项公式。

引理：$\displaystyle f(n)=\sum_{i=1}^n\operatorname{fib}^2(i)=\operatorname{fib}(n)\operatorname{fib}(n+1)$

证明：

$$\sum_{i=1}^n\operatorname{fib}^2(i)=\sum_{i=1}^n\operatorname{fib}(i)\cdot(\operatorname{fib}(i+1)-\operatorname{fib}(i-1))$$

$$\sum_{i=1}^n\operatorname{fib}^2(i)=\sum_{i=1}^n(\operatorname{fib}(i)\operatorname{fib}(i+1)-\operatorname{fib}(i)\operatorname{fib}(i-1))$$

显然裂项可得：

$$\sum_{i=1}^n\operatorname{fib}^2(i)=\operatorname{fib}(n)\operatorname{fib}(n+1)-\operatorname{fib}(1)\operatorname{fib}(0)$$

则：

$$\sum_{i=1}^n\operatorname{fib}^2(i)=\operatorname{fib}(n)\operatorname{fib}(n+1)$$

代入 $Ans$ 可得：

$$Ans=\sum_{i=1}^n\operatorname{fib}(i)\operatorname{fib}(i-1)\operatorname{fib}(i-2)+\sum_{i=1}^n\operatorname{fib}^3(i)+\operatorname{fib}(n)\operatorname{fib}(n+1)$$

考虑 $\displaystyle\sum_{i=1}^n\operatorname{fib}(i)\operatorname{fib}(i-1)\operatorname{fib}(i-2)+\sum_{i=1}^n\operatorname{fib}^3(i)$ 怎么拆：

引理：$\displaystyle\operatorname{fib}^2(n)\operatorname{fib}(n-1)=\displaystyle\sum_{i=1}^n\operatorname{fib}(i)\operatorname{fib}(i-1)\operatorname{fib}(i-2)+\sum_{i=1}^{n-1}\operatorname{fib}^3(i)$

证明：

$$\operatorname{fib}^2(n)\operatorname{fib}(n-1)=\operatorname{fib}^2(n-1)\operatorname{fib}(n)+\operatorname{fib}(n)\operatorname{fib}(n-1)\operatorname{fib}(n-2)$$

$$\operatorname{fib}^2(n)\operatorname{fib}(n-1)=\operatorname{fib}^2(n-1)\operatorname{fib}(n-2)+\operatorname{fib}^3(n)+\operatorname{fib}(n-1)\operatorname{fib}(n-1)\operatorname{fib}(n-2)$$

显然可以递归得到：

$$\operatorname{fib}^2(n)\operatorname{fib}(n-1)=\displaystyle\sum_{i=1}^n\operatorname{fib}(i)\operatorname{fib}(i-1)\operatorname{fib}(i-2)+\sum_{i=1}^{n}\operatorname{fib}^3(i-1)$$

$$\operatorname{fib}^2(n)\operatorname{fib}(n-1)=\displaystyle\sum_{i=1}^n\operatorname{fib}(i)\operatorname{fib}(i-1)\operatorname{fib}(i-2)+\sum_{i=1}^{n-1}\operatorname{fib}^3(i)$$

代入 $Ans$ 可得：

$$Ans=\operatorname{fib}^2(n)\operatorname{fib}(n-1)+\operatorname{fib}^3(n)+\operatorname{fib}(n)\operatorname{fib}(n+1)$$

$$Ans=\operatorname{fib}^2(n)\operatorname{fib}(n+1)+\operatorname{fib}(n)\operatorname{fib}(n+1)$$

矩阵乘法即可。

代码太丑，不放了。

---

## 作者：Butterfly_qwq (赞：1)

这道题感觉思路很妙。

卡西尼恒等式是什么？我不知道。

但这道题可以数形结合乱搞。

![](https://cdn.luogu.com.cn/upload/image_hosting/i58mizcd.png?x-oss-process=image/resize,m_lfit,h_6800,w_9000)

所以 $f(i)=\operatorname{fib}(i)*\operatorname{fib}(i+1)$。

代入可得 $\text{原式}=(\sum\limits^n_{i=1}\operatorname{fib}(i)*\operatorname{fib}(i-1)*\operatorname{fib}(i-2)+\operatorname{fib}^3(i))+f(n)=(\sum\limits^n_{i=1}\operatorname{fib}(i)*\operatorname{fib}(i-1)*\operatorname{fib}(i-2)+\operatorname{fib}^3(i))+\operatorname{fib}(n)*\operatorname{fib}(n+1)$。

![](https://cdn.luogu.com.cn/upload/image_hosting/zyqj9ajt.png?x-oss-process=image/resize,m_lfit,h_6800,w_9000)

设最大的正方体边长为 $\operatorname{fib}(i)$，你发现 $\operatorname{fib}(i)*\operatorname{fib}(i-1)*\operatorname{fib}(i-2)$ 就是大正方体右面的，第二大的正方体上面的，有一条边和大正方体上表面右棱长度一样且完全重合的长方体体积。

然后你会发现 $\sum\limits^n_{i=1}\operatorname{fib}(i)*\operatorname{fib}(i-1)*\operatorname{fib}(i-2)+\operatorname{fib}^3(i))$ 就是 $\operatorname{fib}^2(n)*\operatorname{fib}(n+1)$。

于是 $\text{原式}=\operatorname{fib}(n)*\operatorname{fib}(n+1)*(\operatorname{fib}(n)+1)$。

然后就是基础的矩阵快速幂优化DP了。

Talking is cheap,show me the code：
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int mod;
struct matrix
{
	int c[2][2];
	matrix operator*(const matrix &p)const
	{
		matrix q;
		for(int i=0;i<2;i++)for(int j=0;j<2;j++)q.c[i][j]=0;
		for(int i=0;i<2;i++)for(int j=0;j<2;j++)for(int k=0;k<2;k++)(q.c[i][j]+=c[i][k]*p.c[k][j])%=mod;
		return q;
	}
	matrix operator^(int x)const
	{
		matrix q;
		for(int i=0;i<2;i++)for(int j=0;j<2;j++)q.c[i][j]=(i==j);
		matrix p=*this;
		for(int i=x;i;i>>=1)
		{
			if(i&1)q=q*p;
			p=p*p;
		}
		return q;
	}
}sta,res;
signed main()
{
	int t;
	cin>>t;
	sta.c[0][1]=res.c[0][1]=res.c[1][0]=res.c[1][1]=1;
	while(t--)
	{
		int n;
		scanf("%lld%lld",&n,&mod);
		matrix t=sta*(res^n);
		printf("%lld\n",t.c[0][0]*t.c[0][1]%mod*(t.c[0][0]+1)%mod);
	}
}
```

---

## 作者：黑影洞人 (赞：1)

矩阵加速求 $fib$

首先这道题让我们求 $g(x)$：

$$f(x)=\sum_{i=1}^{x}fib_i^2$$

$$g(x)=\sum_{i=1}^{x}fib_i\times(fib_i^2+fib_i+f(i-2))$$

显然，这样直接套着 $\sum$ 去求很复杂，算法效率也很低。

因此我们考虑推柿子。

$$f(x)=\sum_{i=1}^{x}fib_i^2$$

$$=fib_1^2+fib_2^2+……+fib_x^2$$

$$=fib_1\times fib_2+fib_2^2+fib_3^2+……+fib_x^2$$

$$=fib_2(fib_1+fib_2)+fib_3^2+……+fib_x^2$$

$$=fib_2\times fib_3+fib_3^2+……+fib_x^2$$

$$=fib_3(fib_2+fib_3)+fib_4^2+……+fib_x^2$$

$$=fib_4(fib_3+fib_4)+fib_5^2+……+fib_x^2$$

$$…………$$

$$=fib_x\times fib_{x+1}$$

第一步我们完美地完成了。

$$g(x)=\sum_{i=1}^{x}fib_i\times(fib_i^2+fib_i+f(i-2))$$

$$=\sum_{i=1}^{x}fib_i\times(fib_i^2+fib_i+fib_{i-2}\times fib_{i-1})$$

$$=\sum_{i=1}^xfib_i^2+\sum_{i=1}^{x}fib_i\times(fib_i^2+fib_{i-2}\times fib_{i-1})$$

$$=f(x)+\sum_{i=1}^{x}fib_i^3+\sum_{i=1}^{x}fib_ifib_{i-1}fib_{i-2}$$

$$=f(x)+\sum_{i=1}^{x}fib_i^3+\sum_{i=1}^{x}fib_ifib_{i-1}fib_{i-2}$$

我们先观察 $\sum_{i=1}^{x}fib_i^3$ 部分：

$$\sum_{i=1}^{x}fib_i^3$$

$$=fib_x^3+\sum_{i=1}^{x-1}fib_i^3$$

$$=fib_x^2fib_{x+1}-fib_x^2fib_{x-1}+\sum_{i=1}^{x-1}fib_i^3$$

$$=fib_x^2fib_{x+1}-fib_x^2fib_{x-1}+fib_xfib_{x-1}^2-fib_{x-1}^2fib_{x-2}+……$$

$$=fib_x^2fib_{x+1}-\sum_{i=1}^xfib_i^2fib_{i-1}-fib_ifib_{i-1}^2$$

再观察 $\sum_{i=1}^xfib_i^2fib_{i-1}-fib_ifib_{i-1}^2$：


$$\sum_{i=1}^xfib_i^2fib_{i-1}-fib_ifib_{i-1}^2$$

$$=\sum_{i=1}^xfib_ifib_{i-1}(fib_i-fib_{i-1})$$

$$=\sum_{i=1}^xfib_ifib_{i-1}fib_{i-2}$$

带回得到：

$$\sum_{i=1}^{x}fib_i^3$$

$$=fib_x^2fib_{x+1}-\sum_{i=1}^xfib_ifib_{i-1}fib_{i-2}$$

再带回得：

$$g(x)=f(x)+\sum_{i=1}^{x}fib_i^3+\sum_{i=1}^{x}fib_ifib_{i-1}fib_{i-2}$$

$$=f(x)+fib_x^2fib_{x+1}$$

$$=fib_x^2fib_{x+1}+fib_xfib_{x+1}$$

跑一遍矩阵加速求出$fib_x,fib_{x+1}$ 即可。

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#define int long long
using namespace std;
int T,n,p;
struct matrix{
	int m[2][2];
	matrix(){memset(m,0,sizeof(m));}
	void set(){
		memset(m,0,sizeof(m));
		m[0][0]=m[1][0]=m[0][1]=1;
	}
	void csh(){m[0][0]=m[1][1]=1;}
	matrix operator*(const matrix &a)const{
		matrix res;
		for(int i=0;i<2;i++){
			for(int j=0;j<2;j++){
				for(int k=0;k<2;k++){
					res.m[i][j]+=m[i][k]*a.m[k][j];
				}res.m[i][j]%=p;
			}
		}
		return res;
	}
	matrix operator^(int b){
		matrix res,a=*this;
		res.csh();
		while(b){
			if(b&1)res=res*a;
			a=a*a;
			b>>=1;
		}
		return res;
	}
}a,b;
signed main(){
	scanf("%lld",&T);
	while(T--){
		scanf("%lld%lld",&n,&p);
		a.set();
		a=a^n;
		int y=a.m[0][0],x=a.m[0][1];
		printf("%lld\n",((x*x%p)*y%p+x*y%p)%p); 
	}
	return 0;
}
```



---

## 作者：coderJerry (赞：0)

先看看 $f(n)$。注意到原式里有个平方，考虑一堆边长为斐波那契数的正方形拼起来。不难发现原式等于下图大长方形的面积的数值，即为 $\operatorname{fib}(n)\operatorname{fib}(n+1)$。（~~图有点丑凑合着看吧~~）

![](https://cdn.luogu.com.cn/upload/image_hosting/xx2smnsn.png)

再看看题目要我们算的东西，先拆括号暴力计算一下：

原式 $=\sum_{i=1}^n \operatorname{fib}(i)f(i-2)+\operatorname{fib}^3(i)+\sum_{i=1}^n\operatorname{fib}^2(i)$

$=(\sum_{i=1}^n \operatorname{fib}(i)\operatorname{fib}(i-1)\operatorname{fib}(i-2)+\operatorname{fib}^3(i))+\operatorname{fib}(n)\operatorname{fib}(n+1)$

$=(\sum_{i=1}^n \operatorname{fib}(i)\operatorname{fib}(i-1)(\operatorname{fib}(i)-\operatorname{fib}(i-1))+\operatorname{fib}^3(i))+\operatorname{fib}(n)\operatorname{fib}(n+1)$

$=(\sum_{i=1}^n \operatorname{fib}^2(i)\operatorname{fib}(i-1)+\operatorname{fib}^3(i)-\operatorname{fib}^2(i-1)\operatorname{fib}(i))+\operatorname{fib}(n)\operatorname{fib}(n+1)$

$=(\sum_{i=1}^n \operatorname{fib}^2(i)\operatorname{fib}(i+1)-\operatorname{fib}^2(i-1)\operatorname{fib}(i))+\operatorname{fib}(n)\operatorname{fib}(n+1)$。

然后，sigma 后面一大坨东西裂项一下，最后得到原式的结果是 $\operatorname{fib}^2(n)\operatorname{fib}(n+1)+\operatorname{fib}(n)\operatorname{fib}(n+1)$。矩阵快速幂求解即可。

---

## 作者：hh弟中弟 (赞：0)

### [P9510 『STA - R3』高维立方体](https://www.luogu.com.cn/problem/P9510)
[更多关于斐波那契数列的知识](https://www.cnblogs.com/Ishar-zdl/p/18259983)\
设 $f_i$ 表示斐波那契数列的第 $i$ 项。

引理一：$\sum_{i=1}^{n}f^2_i=f_nf_{n+1}$\
证明：显然 $\sum_{i=1}^{n}f^2_i=f_nf_{n+1}$ 对于 $n=3$ 成立，假设该引理对于 $n=k$ 成立，对于 $n=k+1$，有 
$$
\begin{aligned}
\sum_{i=1}^{k+1}f^2_i&=\sum_{i=1}^{k}f^2_i+f^2_{k+1}\\
&=f_{k}f_{k+1}+f^2_{k+1}\\
&=f_{k+1}f_{k+2}
\end{aligned}
$$
即 $\sum_{i=1}^{n}f^2_i=f_nf_{n+1}$，证毕。

简单整理下所求式子，得 $\sum_{i=1}^n(f_if_{i-1}f_{i-2}+f^3_i)+f_nf_{n+1}$\
对于 $\sum_{i=1}^n f_if_{i-1}f_{i-2}$，有
$$
\begin{aligned}
\sum_{i=1}^n f_if_{i-1}f_{i-2}&=\sum_{i=1}^n f_if_{i-1}(f_i-f_{i-1})\\
&=\sum_{i=1}^{n}f^2_if_{i-1}-f_if^2_{i-1}\\
&=f^2_nf_{n-1}-f_nf^2_{n-1}+f^2_{n-1}f_{n-2}-f_{n-1}f^2_{n-2}+\cdots+f^2_1f_0-f_1f^2_0\\
&=f^2_nf_{n-1}-(f_{n-1}+f_{n-2})f^2_{n-1}+f^2_{n-1}f_{n-2}-(f_{n-2}+f_{n-3})f^2_{n-2}+\cdots +0-0\\
&=f^2_nf_{n-1}-f^3_{n-1}-f^3_{n-2}-\cdots -0\\
&=f^2_nf_{n-1}-\sum_{i=1}^{n-1}f^3_i
\end{aligned}
$$
故答案可以整理为
$$
\begin{aligned}
\sum_{i=1}^n(f_if_{i-1}f_{i-2}+f^3_i)+f_nf_{n+1}&=f^2_nf_{n-1}-\sum_{i=1}^{n-1}f^3_i+\sum_{i=1}^{n}f^3_i+f_nf_{n+1}\\
&=f^2_nf_{n-1}+f^3_n+f_nf_{n+1}\\
&=f^2_nf_{n+1}+f_nf_{n+1}
\end{aligned}
$$
直接矩阵快速幂即可。\
另外，这题也可以数形结合，用立方体的体积表示乘积，发现所有的 $f_if_{i-1}f_{i-2}$ 和 $f^3_i$ 可以互补成一个长宽高为 $f_{n+1},f_n,f_n$ 的立方体，同样可以得出答案。
```cpp
#include<bits/stdc++.h>
#define int long long
#define ll long long
#define int long long
int mod;
using namespace std;
inline int read(){
    int x=0,f=1;char ch=getchar();
    for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;
    for(;ch>='0'&&ch<='9';ch=getchar())x=(x<<1)+(x<<3)+(ch^48);
    return x*f;
}
inline int mo(int x){return x>=1e9?x%mod:x;}
struct mt{
    ll a[2][2];
    mt(){memset(a,0,sizeof a);}
    mt operator*(const mt&b)const{
        mt res;
        for(int i=0;i<=1;++i)
        	for(int k=0;k<=1;++k){
        		int zc=a[i][k];
            	for(int j=0;j<=1;++j)
                	res.a[i][j]=mo(res.a[i][j]+zc*b.a[k][j]);
        	}
        return res;
    }
}ans,base;
inline int qpow(int b){
	b--;
    ans.a[0][0]=0,ans.a[0][1]=1;
    base.a[0][1]=base.a[1][0]=base.a[1][1]=1;
    base.a[0][0]=0;
    while(b){
        if(b&1)ans=ans*base;
        base=base*base;b>>=1;
    }
    return ans.a[0][1];
}
signed main(){
	// freopen("in.in","r",stdin);freopen("out.out","w",stdout);
	int T=read();
	while(T--){
		int n=read();mod=read();
		int a=qpow(n),b=ans.a[0][0]+a;
		std::cout<<(a*a%mod*b%mod+b*a%mod)%mod<<'\n';
	}
}
```

---

## 作者：XYQ_102 (赞：0)

![Image](https://cdn.luogu.com.cn/upload/image_hosting/3ylr2pq4.png)

从这张图我们可以得到

$$f(n)=\sum_{i=1}^n \left(\operatorname{fib}(i)\right)^2=\operatorname{fib}(n)\operatorname{fib}(n+1)$$

然后就是化式子

$\sum_{i=1}^{n}\operatorname{fib}(i)(f(i-2)+\operatorname{fib}^2(i)+\operatorname{fib}(i))$ 

展开 $f(x)$

$=\sum_{i=1}^{n}\operatorname{fib}(i)(\operatorname{fib}(i-2)\operatorname{fib}(i-1)+\operatorname{fib}^2(i)+\operatorname{fib}(i))$

乘开，提出 $\sum \operatorname{fib}^2(i)$ 

$=\sum_{i=1}^{n}(\operatorname{fib}(i)\operatorname{fib}(i-1)\operatorname{fib}(i-2)+\operatorname{fib}^3(i))+ \sum_{i=1}^n\operatorname{fib}^2(i))$

左边带入 $\operatorname{fib}(i-2)=\operatorname{fib}(i)-\operatorname{fib}(i-1)$，右边带入上述公式

$=\sum_{i=1}^{n}(\operatorname{fib}(i)\operatorname{fib}(i-1)(\operatorname{fib}(i)-\operatorname{fib}(i-1))+\operatorname{fib}^3(i))+ \operatorname{fib}(n)\operatorname{fib}(n+1)$

乘开

$=\sum_{i=1}^{n}(\operatorname{fib}^2(i)\operatorname{fib}(i-1)-\operatorname{fib}(i)\operatorname{fib}^2(i-1)+\operatorname{fib}^3(i))+ \operatorname{fib}(n)\operatorname{fib}(n+1)$

提取公因式 $\operatorname{fib}^2(i)$ 

$=\sum_{i=1}^{n}(\operatorname{fib}^2(i)(\operatorname{fib}(i-1)+\operatorname{fib}(i))-\operatorname{fib}(i)\operatorname{fib}^2(i-1))+ \operatorname{fib}(n)\operatorname{fib}(n+1)$

合并 $\operatorname{fib}(i-1)+\operatorname{fib}(i)=\operatorname{fib}(i+1)$ 

$=\sum_{i=1}^{n}(\operatorname{fib}^2(i)\operatorname{fib}(i+1)-\operatorname{fib}^2(i-1)\operatorname{fib}(i))+ \operatorname{fib}(n)\operatorname{fib}(n+1)$

裂项相消

$=\operatorname{fib}^2(n)\operatorname{fib}(n+1)-\operatorname{fib}^2(0)\operatorname{fib}(1)+ \operatorname{fib}(n)\operatorname{fib}(n+1)$ 

通过 $\operatorname{fib}(n)=\operatorname{fib}(n-1)+\operatorname{fib}(n-2)$ 逆推得到 $\operatorname{fib}(0)=0$ 并带入

$=\operatorname{fib}^2(n)\operatorname{fib}(n+1)+ \operatorname{fib}(n)\operatorname{fib}(n+1)$

矩阵乘法一次就可以同时算出 $\operatorname{fib}(n)$ 和  $\operatorname{fib}(n+1)$。

时间复杂度 $O(T\times \log n)$。
## 核心代码
```cpp
ll n,p;
struct Mat{
	ll a11,a12,a21,a22;
	Mat operator * (const Mat y) const {
		return (Mat){(this->a11*y.a11+this->a12*y.a21)%p,
			(this->a11*y.a12+this->a12*y.a22)%p,
			(this->a21*y.a11+this->a22*y.a21)%p,
			(this->a21*y.a12+this->a22*y.a22)%p};
	}
}st,base;
Mat pow(Mat x,ll y){
	Mat res,tmp=x; res.a11=res.a22=1; res.a12=res.a21=0;
	while(y){ if(y&1) res=res*tmp; tmp=tmp*tmp; y>>=1; } return res;
}
void work(){
	fin>>n>>p; if(n==1){ fin<<2%p<<'\n'; return; }
	st.a11=1; st.a12=1; base.a12=1; base.a21=1; base.a22=1;
	st=(st*pow(base,n-1));
	fin<<(st.a11+1)*st.a11%p*st.a12%p<<'\n';
}
int main(){
	int T; fin>>T; while(T--) work(); return 0;
}
```

---


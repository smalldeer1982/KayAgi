# [UESTCPC 2024] 打字

## 题目描述

给定一颗 $n$ 个节点的 trie 树，以 $1$ 号节点为根，其余每个节点到父亲的边上都有一个字符，且父亲相同的节点到父亲的边上的字符互不相同。从根到每个节点的路径都代表一个单词，这个单词由路径上的字符顺序拼接而成。在每个节点 $i$ 处有一个权值 $c_i$，表示该节点所代表的单词需要写出的次数。

你有一个 cache，可以选择任意个单词放在 cache 里面。写单词时，每写一个字符需要花费 $a$ 的代价。当写出一个完整的单词时，就可以选择结束当前单词，转而拼写下一个单词。而 cache 会根据当前已经写出的字符，把 cache 中以这一部分字符为前缀且字典序最小的单词提示出来。此时你可以花费 $b$ 的代价直接写出这个单词，**并结束当前单词的拼写**，转而拼写下一个单词。注意一个字符串本身也看作它自己的前缀。

求完成 trie 树上所有单词的拼写所需的最小代价。

## 说明/提示

**【样例解释】**

假设每个节点的子节点按字典序从小到大按 $a,b,\ldots$ 编码。最优方案为将 $aa$ 放在 cache 中，于是 $aa$ 可以花费 $3\times 4$
的代价利用提示打出来，$a$ 和 $b$
都直接打出来。总代价为 $3\times 4+2\times 1\times 2+2\times 1\times 3=22$。

## 样例 #1

### 输入

```
4 2 3
0 2 3 2
3 0
2 1 4
4 0```

### 输出

```
22```

# 题解

## 作者：zhongpeilin (赞：6)

首先我们类似题意建字典树，设 $dis_{u}$ 表示 u 节点的深度。  

那么我们发现正着搞不好搞，那么先将答案设为 $\sum_{i = 1}^{n} dis_{i} \times A \times c_{i}$，你会发现假设 $id_{1}, id_{2} \dots id_{len}$ 是 cache 中的字符串编号按字典树顺序排序，那么答案会少 $\sum_{i = 1}^{len} ((dis_{id_{i}} - dis_{LCA(id_{i - 1}, id_{i})} - 1) \times A - B) \times c_{id_{i}}$，其中我们设 $dis_{id_{1}} - LCA_{id_{0}, id_{1}} - 1 = 0$，因为第一个单词只需打一个 $B \times c_{id_{1}}$。  

所以设 $dp_{x}$ 表示 dfn 序列中在 $x$ 及之前的能减去的最大答案，这里强制 $x$ 放入 cache。  

那么枚举上一个放入 cache 的单词，假设标号为 $y$，则：
$$dp_{x} = \max_{dfn 中 y 在 x 前面} (dp_{y} + ((dis_{x} - dis_{LCA_{x, y}} - 1) \times A - B) \times c_{x})$$
你会发现 $dis_{LCA_{x, y}}$ 很难受，那么设 $f_{x}$ 表示当前 $x$ 子树中 dp 最大的值，那么转移变成了枚举 LCA，有：
$$dp_{x} = \max_{y 是 x 祖宗} (f_{y} + ((dis_{x} - dis_{y} - 1) \times A - B) \times c_{x})$$
那么拆一下：
$$dp_{x} = \max_{y 是 x 祖宗} (f_{y} + (dis_{x} \times A - {dis_{y} + 1} \times A - B) \times c_{x})$$
所以：
$$dp_{x} = \max_{y 是 x 祖宗} (f_{y} + dis_{x} \times A \times c_{x} - (dis_{y} + 1) \times A \times c_{x}- B \times c_{x})$$
$$dp_{x} = \max_{y 是 x 祖宗} (f_{y} - (dis_{y} + 1) \times A  \times c_{x}) - B \times c_{x}  + dis_{x} \times A \times c_{x}$$
将一次函数中 $k$ 看成 $-(dis_{y} + 1) \times A  \times c_{x}$, $b$ 看成 $f_{y}$，建李超树。  

## CODE：
```cpp#include <bits/stdc++.h>
using namespace std;
#define int long long
struct Segment{
	int k, b;
}a[800005];
int tree[800005], tot, ans;
int n, A, B, c[200005], dp[200005], dis[200005];
vector<int> g[200005];

void dfs(int x){
	ans += c[x] * A * dis[x];
	for(auto it : g[x]){
		dis[it] = dis[x] + 1;
		dfs(it);
	}
}
int GET(int id, int x){
	return a[id].k * x + a[id].b;
}

int query(int u, int l, int r, int pos){
	if(l == r) return GET(tree[u], l);
	int mid = (l + r) / 2;
	if(pos <= mid) return max(GET(tree[u], pos), query(u << 1, l, mid, pos));
	else return max(GET(tree[u], pos), query(u << 1 | 1, mid + 1, r, pos));
}

void add(int u, int l, int r, int id){
	if(!id) return ;
	int mid = (l + r) / 2;
	if(GET(id, mid) > GET(tree[u], mid) || !tree[u]) swap(id, tree[u]);
	if(l == r) return ;
	if(GET(id, l) > GET(tree[u], l)) add(u << 1, l, mid, id);
	if(GET(id, r) > GET(tree[u], r)) add(u << 1 | 1, mid + 1, r, id);
}

void addedge(int x){
	a[++tot] = {-1 * (dis[x] + 1) * A, dp[x]};
	add(1, 0, 10000, tot);
}
void DP(int x){
	dp[x] = query(1, 0, 10000, c[x]) - B * c[x] + dis[x] * A * c[x];
	addedge(x);
	cout << dp[x] << endl;
	for(auto it : g[x]){
		DP(it);
		if(dp[it] > dp[x]){
			dp[x] = dp[it];
			addedge(x);
		}
	}
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin >> n >> A >> B;
	for(int i = 1; i <= n; i++){
		int k;
		cin >> c[i] >> k;
		for(int j = 1; j <= k; j++){
			int son;
			cin >> son;
			g[i].push_back(son);
		}
	}
	dfs(1);
	DP(1);
	cout << ans - dp[1] << endl;
	return 0;
}

---

## 作者：C1942huangjiaxu (赞：6)

记 $dp_x$ 为 $x$ 节点的深度。

假如不用 cache，答案为 $\sum dp_x\times a\times c_x$。

假设我们将单词 $w_1,w_2,\dots,w_k$ 加入了cache，将 $w$ 按照字典序（也就是 dfs 序）排序，那么答案会**减少** $\sum ((dp_{w_i}-dp_{\operatorname{LCA}(w_{i-1},w_i)}-1)\times a-b)\times c_{w_i}$，因为 $dp_{\operatorname{LCA}(w_{i-1},w_i)}$ 就是 $w_i$ 和 $w_{i-1}$ 的最长公共前缀，要再打一个字符 cache 才能确定 $w_i$。

考虑按照 dfs 序 dp，$f_x$ 表示当前加入 cache 的字典序最大的单词为 $x$ 时的最大值，转移为 $f_y=\max(f_x+((dp_y-dp_{\operatorname{LCA}(x,y)}-1)\times a-b)\times c_y$

为了方便转移，**我们可以在考虑完 $x$ 子树后将 $x$ 子树内的最大值更新给 $x$ 的父亲，求值时从祖先转移过来**，也就是从 $x$ 先转移到 $\operatorname{LCA}(x,y)$ 再转移到 $y$。

容易用李超树优化转移，因为每个点只会在到达和离开时改变某个 $f_x$ 的值，所以总共加入的直线是 $O(n)$ 个的，时间复杂度 $O(n\log V)$。

参考代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5,V=1e4;
typedef long long ll;
int n,a,b,c[N],dp[N],cv,tr[N];
vector<int>e[N];
ll f[N],ans;
struct line{
	ll a,b;
}va[N<<1];
inline ll W(int u,int x){
	return 1ll*va[u].a*x+va[u].b;
}
void ins(int k,int l,int r,int x){
	if(!tr[k]||W(tr[k],l)<=W(x,l)&&W(tr[k],r)<=W(x,r))return tr[k]=x,void();
	if(W(tr[k],l)>=W(x,l)&&W(tr[k],r)>=W(x,r))return;
	int mid=l+r>>1;
	if(W(tr[k],mid)<W(x,mid))swap(tr[k],x);
	if(W(tr[k],l)<W(x,l))ins(k<<1,l,mid,x);
	else ins(k<<1|1,mid+1,r,x);
}
ll query(int k,int l,int r,int x){
	if(!tr[k])return 0;
	int mid=l+r>>1;
	if(x<=mid)return max(W(tr[k],x),query(k<<1,l,mid,x));
	else return max(W(tr[k],x),query(k<<1|1,mid+1,r,x));
}
void add(int x){
	va[++cv]={-1ll*(dp[x]+1)*a,f[x]};
	ins(1,0,V,cv);
}
void dfs(int x){
	ans+=1ll*dp[x]*a*c[x];
	f[x]=max(f[x],query(1,0,V,c[x])+(1ll*dp[x]*a-b)*c[x]);
	add(x);
	for(auto v:e[x]){
		dp[v]=dp[x]+1;
		dfs(v);
		if(f[v]>f[x])f[x]=f[v],add(x);
	}
}
int main(){
	scanf("%d%d%d",&n,&a,&b);
	for(int i=1,x,y;i<=n;++i){
		scanf("%d%d",&c[i],&x);
		while(x--){
			scanf("%d",&y);
			e[i].push_back(y);
		}
	}
	dfs(1);
	printf("%lld\n",ans-f[1]);
	return 0;
}
```

---

## 作者：honglan0301 (赞：6)

## 分析

首先注意到，对于不在 cache 里的单词 $i$，我们显然只能用 $c_i\times dep_i\times a$ 的代价拼写它；而对于在 cache 中的单词，我们可以钦定必须用 $c_i\times(k_i\times a+b)$ 的代价拼写它，这样不影响答案（如果不使用 $b$ 更优，那么把它移除出 cache 显然不劣）。

于是考虑树上 dp，我们记初始花费 $ans_0=\sum c_i\times dep_i\times a$，考虑对使用 cache 能够节约的花费进行 dp，记 $f_{i,j}$ 表示在 $i$ 的子树中，要求从 $dep=j$ 处就能够提示出子树中字典序最小的串时，子树中最多能够节约的花费。

那么枚举是否把 $i$ 放入 cache 集合，有转移：

$$f_{i,j}\gets\max\{f_{son_{i,k},j}+\sum_{p>k} f_{son_{i,p},dep_{i}+1}\}$$

$$f_{i,j}\gets c_i\times ((dep_i-j)\times a-b)+\sum_p f_{son_{i,p},dep_i+1}$$

（其中注意每个 $f$ 都要与 $0$ 取 $\max$，因为子树内可以没有 cache 集合中的元素。）

考虑优化，我们把 $f_{i,j}$ 看成一个关于 $j$ 的函数 $F_i(j)$，那么第一种转移是令 $F_i(j)$ 对每个 $F_{son_i}(j)+c$ 取 $\max$，其中 $c$ 是常数；第二种转移是令 $F_{i}(j)$ 对一个一次函数取 $\max$。

想到李超线段树，只需支持插入一条直线（第二种转移），给一棵树全局加、合并若干棵树（第二种转移），以及查询某个横坐标处纵坐标 $\max$ （查询），使用支持合并/打全局加 tag 的动态开点李超线段树简单维护即可，时空复杂度都是优秀的 $O(n\log n)$。

## 代码

```cpp
/*
  author: honglan0301
  Sexy_goodier _ xiaoqing
 */
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cstdio>
#include <cctype>
#include <queue>
#include <map>
#include <unordered_map>
#include <cstdlib>
#include <ctime>
#include <vector>
#include <cmath>
#include <random>
#include <set>
#include <bitset>
#include <assert.h>
using namespace std;

// 快读板子

#define mp make_pair
#define pb push_back
#define fi first
#define se second
#define int long long
#define ull unsigned long long
#define mod 998244353
mt19937 rnd(time(0));
mt19937_64 rndl(time(0));

int n,a,b,c[200005],k[200005],u,dep[200005];
vector <int> e[200005];

struct tree1
{
	int ls,rs,num,tagadd;
}tree1[10000005];
int rt[200005],cntd1,k1[20000005],b1[20000005],cntx;

#define ls1(x) tree1[x].ls
#define rs1(x) tree1[x].rs
#define n1(x) tree1[x].num
#define tg(x) tree1[x].tagadd
#define md(x,y) ((x+y)>>1)
#define gety1(u,x) (k1[(u)]*(x)+b1[(u)])

void czad(int k,int p) {tg(p)+=k; cntx++; k1[cntx]=k1[n1(p)]; b1[cntx]=b1[n1(p)]+k; n1(p)=cntx;}
void push_down(int p)
{
	if(tg(p))
	{
		if(ls1(p)) czad(tg(p),ls1(p));
		if(rs1(p)) czad(tg(p),rs1(p)); tg(p)=0;
	}
}
void cz1(int l,int r,int u,int &p)
{
	//cout<<l<<" "<<r<<" "<<p<<" "<<u<<" "<<k1[u]<<" "<<k2endl;
	if(!p) {p=++cntd1; n1(p)=u; return;}
	int mid=md(l,r); if(gety1(u,mid)>gety1(n1(p),mid)) swap(u,n1(p)); push_down(p);
	if(gety1(u,l)>gety1(n1(p),l)) cz1(l,mid,u,ls1(p));
	if(gety1(u,r)>gety1(n1(p),r)) cz1(mid+1,r,u,rs1(p));
}
void merge(int l,int r,int q,int &p)
{
	if(!p||!q) {p+=q; return;}
	int mid=md(l,r); push_down(p); push_down(q);
	merge(l,mid,ls1(q),ls1(p)); merge(mid+1,r,rs1(q),rs1(p));
	cz1(l,r,n1(q),p);
}
int ask1(int l,int r,int x,int p)
{
	if(!p) return -1000000000000000000; if(l==r) return gety1(n1(p),x);
	int mid=md(l,r),nans=gety1(n1(p),x); push_down(p);
	if(mid>=x) nans=max(nans,ask1(l,mid,x,ls1(p))); else nans=max(nans,ask1(mid+1,r,x,rs1(p))); return nans;
}

void dfs(int x,int fat)
{
	vector <int> mx;
	for(auto i:e[x]) dfs(i,x),mx.pb(max(0ll,ask1(0,n,dep[x]+1,rt[i]))); int na=0;
	for(int i=(int)e[x].size()-1;i>=0;i--) 
	{
		czad(na,rt[e[x][i]]),merge(0,n,rt[e[x][i]],rt[x]),na+=mx[i];
	}
	cntx++; k1[cntx]=-a*c[x]; b1[cntx]=a*dep[x]*c[x]-c[x]*b+na; cz1(0,n,cntx,rt[x]);
	//cout<<x<<" "<<na<<" "<<ask1(0,10000000,dep[x],rt[x])<<" "<<k1[cntx]<<" "<<b1[cntx]<<endl;
}//

signed main()
{
	cin>>n>>a>>b;
	for(int i=1;i<=n;i++) {cin>>c[i]>>k[i]; for(int j=1;j<=k[i];j++) cin>>u,dep[u]=dep[i]+1,e[i].pb(u);}
	int ans=0; for(int i=1;i<=n;i++) ans+=dep[i]*c[i]*a; dfs(1,1); 
	ans-=max(0ll,ask1(0,n,0,rt[1]));
	cout<<ans<<endl;
	//cout<<ans<<" "<<ask1(0,10000000,0,rt[1])<<endl;
}//
```

---

## 作者：tobie (赞：0)

提供一个李超树合并的做法。

先把字典树建出来。

假如我们知道了哪些字符串被放到 Cache 中，那么能输出这个字符串的位置一定是从对应节点出发一直往根上走的一段路径。

这段路径可能会走着走着被别的 dfs 序更小的点覆盖。显然我们会在被覆盖的前一个点使用 Cache 输出答案。

假设输出的位置为 $u$，这个字符串的实际位置为 $x$，那么如果把 $x$ 放入 Cache，答案将会减少 $C_x\times (A\times(\mathrm{dep}_x-\mathrm{dep}_v)-B)$

于是我们可以得到一个简单的 dp：$dp_{u,x}$ 表示当前在 $u$ 节点，它子树内最小的 Cache 串是 $x$ 时，答案最多会在没有任何 Cache 串的基础上减少多少。注意这里我们暂时不计算 $x$ 的贡献，因为它可能在更上面的祖先节点处才产生贡献。

转移考虑枚举 $x$ 从哪里来：如果 $x$ 在第 $i$ 个子树内，则 $[1,i)$ 内的子树内不能有贡献，$(i,\mathrm{deg}_u]$ 内没有计算的贡献要加上去，至于 $i$ 子树直接继承就好。

所以考虑从大到小“插入”一个子树 $v$，那么 $dp_{v,x}$ 有两种情况：一种是直接贡献到 $dp_{u,x}$，另一种是在 $v$ 处计算 $x$ 的贡献，给 dfs 序更小的 $x'$ 让路。

发现这有点像线段树合并的过程。第一中转移就是线段树合并，而第二种转移类似于一个全局加法，但是我们不知道我们具体需要加什么东西。

回到 $x$ 对 $v$ 的贡献，发现这是一个关于 $dep_v$ 的一次函数，所以可以用李超线段树维护。

事实上李超树上只存了 $O(n)$ 条线段，所以节点个数是 $O(n)$ 的，如果加上空间回收，合并等各种操作的复杂度可以做到 $O(n\log n)$。但是这题的数据范围不大，所以以下代码可能会被卡到 $O(n\log^2 n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+9;
namespace io
{

template<typename T>
void read(T &x){
	// read a __int128 variable
	char c; bool f = 0;
	while(((c = getchar()) < '0' || c > '9') && c != '-');
	if(c == '-'){f = 1; c = getchar();}
	x = c - '0';
	while((c = getchar()) >= '0' && c <= '9')x = x * 10 + c - '0';
	if(f) x = -x;
}
template<typename T>
void write(T x){
	// print a __int128 variable
	if(x < 0){putchar('-'); x = -x;}
	if(x > 9)write(x / 10);
	putchar(x % 10 + '0');
}
void getch(char &x)
{
	char c;
	while(((c = getchar()) < 'a' || c > 'z'));
	x=c;
}

}

using io::read;using io::write;using io::getch;

#define int long long
bool st_;
vector<int> trie[N];
int dep[N];
int n,A,B,c[N];
__int128 ans0=0;

#define lson son[u][0]
#define rson son[u][1]
#define mid ((l+r)>>1)
struct Line{
	int k,b;
	Line(){}
	Line(int k_,int b_){k=k_,b=b_;}
	__int128 f(int x){return (__int128) k*x+b;}
};
Line val[N*20];
int son[N*20][2],tcnt=0;
int tag[N*20];
int rt[N];
void Add(int u,int x)
{
	if(!u) return;
	val[u].b+=x;tag[u]+=x;
}
void pushdown(int u)
{
	if(!tag[u]) return;
	Add(lson,tag[u]);Add(rson,tag[u]);
	tag[u]=0;
}
void Ins(int &u,int l,int r,Line t)
{
	if(!u) return u=++tcnt,val[u]=t,void();
	__int128 al=t.f(l),ar=t.f(r),bl=val[u].f(l),br=val[u].f(r);
	if(al<=bl&&ar<=br) return;
	if(al>=bl&&ar>=br) return val[u]=t,void();
	if(t.f(mid)>val[u].f(mid)) swap(t,val[u]),swap(al,bl),swap(ar,br);
	pushdown(u);
	al>=bl?Ins(lson,l,mid,t):Ins(rson,mid+1,r,t);
}
__int128 Ask(int u,int l,int r,int x)
{
	if(!u) return 0;
	__int128 res=val[u].f(x);
	if(l==r) return max(res,__int128(0));
	pushdown(u);
	if(x<=mid) res=max(res,Ask(lson,l,mid,x));
	else res=max(res,Ask(rson,mid+1,r,x));
	return max(res,__int128(0));
}
int Merge(int u,int v,int l,int r)
{
	if(!u||!v) return u+v;
	if(val[u].f(mid)<val[v].f(mid)) swap(u,v);
	if(l==r) return u;
	pushdown(u);pushdown(v);
	son[u][0]=Merge(son[u][0],son[v][0],l,mid);
	son[u][1]=Merge(son[u][1],son[v][1],mid+1,r);
	Ins(u,l,r,val[v]);
	return u;
}

void dfs(int u)
{
	Ins(rt[u],0,n,Line(-(__int128)A*c[u],(__int128)A*dep[u]*c[u]-B*c[u]));
	for(int i=0,v;i<trie[u].size();i++)
	if(v=trie[u][i])
	{
		dfs(v);
		Add(rt[u],Ask(rt[v],0,n,dep[v]));
		rt[u]=Merge(rt[u],rt[v],0,n);
	}
}
bool ed_;
signed main()
{
	cerr<<(&ed_-&st_)/1048576.0<<"Mib\n";
	read(n);read(A);read(B);
	for(int i=1,x;i<=n;i++)
	{
		scanf("%lld%lld",&c[i],&x);
		for(int j=1,y;j<=x;j++) scanf("%lld",&y),trie[i].push_back(y),dep[y]=dep[i]+1;
	}
	for(int i=1;i<=n;i++) ans0+=(__int128)A*c[i]*dep[i];
	dfs(1);
	write(ans0-Ask(rt[1],0,n,dep[1]));
}
```

---


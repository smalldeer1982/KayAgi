# [ZJOI2007] 仓库建设

## 题目描述

L 公司有 $n$ 个工厂，由高到低分布在一座山上，工厂 $1$ 在山顶，工厂 $n$ 在山脚。

由于这座山处于高原内陆地区（干燥少雨），L公司一般把产品直接堆放在露天，以节省费用。突然有一天，L 公司的总裁 L 先生接到气象部门的电话，被告知三天之后将有一场暴雨，于是 L 先生决定紧急在某些工厂建立一些仓库以免产品被淋坏。

由于地形的不同，在不同工厂建立仓库的费用可能是不同的。第 $i$ 个工厂目前已有成品 $p_i$ 件，在第 $i$ 个工厂位置建立仓库的费用是 $c_i$。

对于没有建立仓库的工厂，其产品应被运往其他的仓库进行储藏，而由于 L 公司产品的对外销售处设置在山脚的工厂 $n$，故产品只能往山下运（即**只能运往编号更大的工厂的仓库**），当然运送产品也是需要费用的，一件产品运送一个单位距离的费用是 $1$。

假设建立的仓库容量都都是足够大的，可以容下所有的产品。你将得到以下数据：

- 工厂 $i$ 距离工厂 $1$ 的距离 $x_i$（其中 $x_1=0$）。
- 工厂 $i$ 目前已有成品数量 $p_i$。
- 在工厂 $i$ 建立仓库的费用 $c_i$。

请你帮助 L 公司寻找一个仓库建设的方案，使得总的费用（建造费用 + 运输费用）最小。

## 说明/提示

#### 样例输入输出 $1$ 解释

在工厂 $1$ 和工厂 $3$ 建立仓库，建立费用为 $10+10=20$ ，运输费用为 $(9-5) \times 3 = 12$，总费用 $32$。

#### 数据范围与约定

对于 $20\%$ 的数据，保证 $n \leq 500$。

对于 $40\%$ 的数据，保证 $n \leq 10^4$。

对于 $100\%$ 的数据，保证 $1 \leq n \leq 10^6$，$0 \leq x_i,p_i,c_i < 2^{31}$。

对于任意的 $1 \leq i < n$，保证 $x_i < x_{i + 1}$。

设答案为 $ans$，保证 $ans + \sum\limits_{i = 1}^{n} p_ix_i < 2^{63}$。

## 样例 #1

### 输入

```
3
0 5 10
5 3 100
9 6 10```

### 输出

```
32
```

# 题解

## 作者：rickyxrc (赞：13)

本文章遵守知识共享协议 CC-BY-NC-SA，同步发表于洛谷题解区，转载时须在文章的任一位置附上原文链接和作者署名（rickyxrc）。推荐在[我的个人博客](https://blog.rickyxrc.cc)阅读。

## 题面大意

有 $n$ 个点，每个点有一定量（$p_i$）的物资，现在要选择一些点，将所有物资通过**向右移动**的方式汇集到这些点中，选择点和向右移动单位物资均有代价，求最小代价。

## 解题思路

我们首先想一个 $O(n^2)$ 的 dp 式子。

注意到如下基本事实：若一个点建立了仓库，则前面的没有运输进仓库的点都会运输到这里，所以每个仓库的覆盖范围是一定的。

我们定义 $f_i$ 为前 $i$ 个地点的物品都能被安置，且 $i$ 号点是最后一个仓库时的最小花费。

则我们可以得到（下文中的 $d$ 指的是题目中的 $x$，即距离）：

$$\begin{aligned}f_i &= \min_{j\in[0,i)}\{f_j+c_i+\sum_{k\in[j+1,i)}p_k(d_i-d_k)\} \\ &= \min_{j\in[0,i)}\{f_j+c_i+d_i\sum_{k\in[j+1,i)}p_k-\sum_{k\in[j+1,i)}p_k\cdot d_k\}\end{aligned}$$
我们定义 $q_i = \sum_{j \in [1,i]}p_j,r_i = \sum_{j \in [1,i]}d_j\cdot p_j$，则上面的式子就变成了这样：

$$\begin{aligned}f_i &= \min_{j\in[0,i)}\{f_j+c_i+d_i(q_i-q_j)-r_i+r_j\}\end{aligned}$$
这个基本就是斜率优化的板子了，我们假定存在 $u,v\in [0,i)$ 且 $u<v$，同时 $v$ 优于 $u$（即选 $v$ 转移 $f$ 比选 $u$ 更大），那么我们就能列出不等式：

$$\begin{aligned}f_u+c_i+d_i(q_i-q_u)-r_i+r_u &\le f_v+c_i+d_i(q_i-q_v)-r_i+r_v \\ f_u+c_i+d_iq_i-d_iq_u-r_i+r_u &\le f_v+c_i+d_iq_i-d_iq_v-r_i+r_v \\ f_u+d_iq_i-d_iq_u+r_u &\le f_v+d_iq_i-d_iq_v+r_v \\ (f_u-r_u) - (f_v-r_v) &\le (q_u-q_v)d_i \\ \dfrac{(f_u-r_u) - (f_v-r_v)}{q_u-q_v} &\le d_i \\ \dfrac{(f_v-r_v) - (f_u-r_u)}{q_v-q_u} &\le d_i\end{aligned}$$
于是我们将问题抽象如下：平面上有 $n$ 个点，坐标为 $(q_i,f_i+r_i)$，若对于 $u<v$ 的两点，满足两点的斜率小于 $d_i$，则选择右侧的点是更优的。

这里可以用凸壳维护，因为不在凸壳上的点一定劣于凸壳上的点，下面是具体原因：

我们假设有 $u,v,w$ 三点，满足 $u < v < w$，且 $u,w$ 在凸壳上，$v$ 在凸壳以内。

假如此时 $u$ 优于 $w$，则有 $k_{uw} < k_{u,v},k_{uw} \le di$，结合几何相关知识得 $k_{vw} \le k_{uv}$ 此时 $w$ 优于 $v$，所以 $v$ 对答案没有贡献。

配上一张很丑的图示：

![](https://cdn.luogu.com.cn/upload/image_hosting/exhik42m.png)

假如此时 $u$ 劣于 $w$，则同样有 $k_{uw} < k_{u,v},k_{uw} \le di,k_{uv} \ge k_{uw}$ 此时 $w$ 劣于 $u$，同时 $v$ 劣于 $u$，$v$ 对答案同样没有贡献。

![](https://cdn.luogu.com.cn/upload/image_hosting/7l937y42.png)

综上，$v$ 对答案是没有贡献的，所以我们可以维护一个下凸壳，因为凸壳上的斜率单调递增，所以可以在上面二分最优决策点。

但这题有更好的性质：$d_i$ 单调递增，所以我们可以直接维护一个单调队列代表凸壳上边的斜率，在查找时直接弹出队尾斜率不合法的点即可，因为队尾若不合法，接下来也不可能合法。

还有一个要注意的点（hack 数据），就是 $p_i$ 等于 $0$ 的情况，若末尾有连续的 $p_i=0$，取其 $f$ 值的最小值即可。

代码不长，重在理解。

```cpp nums
#include<stdio.h>

typedef long long i64;
const int maxn = 1.2e6;

int n;

i64 d[maxn],p[maxn],c[maxn],f[maxn],q[maxn],r[maxn];

i64 min(i64 a,i64 b){ return a<b?a:b;}

i64 decx (int index)   { return q[index];}
i64 decy (int index)   { return f[index]+r[index];}
i64 maked(int i,int u) { return f[u] + d[i] * (q[i] - q[u]) - r[i] + r[u] + c[i];}

// back -> . . . . . . . . . <- front 
int que[maxn],vfront,vback;
int  size     ()      { return vfront-vback;}
int  front    ()      { return que[vfront-1];}
int  front2   ()      { return que[vfront-2];}
int  back     ()      { return que[vback];}
int  back2    ()      { return que[vback+1];}
void push     (int v) { que[vfront++]=v;}
void pop_front()      { vfront--;}
void pop_back ()      { vback++;}

int main(){
	scanf("%d",&n);

	for(int i=1;i<=n;i++)
		scanf("%lld%lld%lld",d+i,p+i,c+i);

	for(int i=1;i<=n;i++) q[i] = p[i] + q[i-1];
	for(int i=1;i<=n;i++) r[i] = d[i] * p[i] + r[i-1];

	push(0);

	for(int i=1;i<=n;i++){
		while(
			size()>=2 and
			(decy(back2())-decy(back()))
				<= d[i] * (decx(back2())-decx(back()))
		)
			pop_back();
		f[i] = maked(i,back());
		while(
			size()>=2 and
			(decy(front())-decy(front2())) * (decx(i)-decx(front()))
				>= (decy(i)-decy(front())) * (decx(front()) - decx(front2()))
		)
			pop_front();
		push(i);
	}
	
	i64 ans = f[n];

	int x=n;
	while(p[x]==0)
		x--,ans=min(ans,f[x]);

	printf("%lld",ans);

	return 0;
}
```

---

## 作者：Aisaka_Taiga (赞：8)

咱可以设 $f_{i}$ 表示第 $i$ 个工厂建工厂，只考虑前 $i$ 个工厂不被冲的最小花费。

那么咱就能写出来一个 $O(n^2)$ 的 DP 式子：

$$
f_{i} = \min_{j=1}^{i -1}(f_j + \sum_{k = j + 1}^{i} (x_i - x_k) \times p_k + c_i)
$$

复杂度肯定受不了，我们先拆一下式子：

$$
f_i=\min_{j=1}^{i-1}(f_{j}+\sum_{k = j + 1}^{i}x_i\times p_k - \sum_{k = j + 1}^{i}x_{k}\times p_k + c_i)
$$

咱设 $s_i = \sum_{k=1}^{i}p_k\times x_k$，然后对 $p$ 数组做一次前缀和。

那么咱就可以简化成这样：

$$
f_i = \min_{j=1}^{i-1}(f_j + x_i \times (p_i - p_j) - s_i + s_j + c_i)
$$

假设前面有两个位置 $a, b$，且 $a<b$ 那么如果 $a$ 转移过来优于 $b$，需要满足：

$$
f_a+x_i\times(p_i-p_a) - s_i +s_a + c_i > f_b+x_i\times(p_i-p_b) - s_i +s_b + c_i
$$

$$
f_a-f_b+x_i\times(p_i-p_a-p_i+p_b)<-s_i+s_b+c_i+s_i-s_a-c_i
$$

$$
f_a-f_b+x_i\times(p_b-p_a)< s_b - s_a
$$

$$
x_i\times(p_b-p_a) < s_b-s_a-f_a+f_b
$$

$$
x_{i}<\frac{s_b-s_a-f_a+f_b}{p_b-p_a}
$$

$$
x_{i}<\frac{(f_b+s_b)-(f_a+s_a)}{p_b-p_a}
$$

右边的这个东西可以看作是由 $(p_i,f_i+s_i)$ 这类点的两个点构成的直线的斜率，既然 $p_i, x_i$ 单调递增，也就是说斜率需要越来越大，咱就可以维护一个下凸壳。

开一个队列，设 $q_t$ 为队尾元素，那么根据上面的式子，若通过 $q_t,i$ 两个点的直线斜率小于等于通过 $q_{t-1},q_t$ 两点的直线，那么就应该弹出 $q_t$。

最后有的工厂可能没有商品，所以此时会出现相邻两个点构成的直线中 $p_i-p_j=0$，此时咱想到横坐标相同的两个点，显然应该是要纵坐标更小的。

所以若 $y>0$ 就当作是正无穷，反之则为负无穷，若 $y=0$ 则无所谓。

```cpp

/*
 * @Author: Aisaka_Taiga
 * @Date: 2023-11-14 16:17:16
 * @LastEditTime: 2023-11-14 19:42:44
 * @LastEditors: Aisaka_Taiga
 * @FilePath: \Desktop\P2120.cpp
 * The heart is higher than the sky, and life is thinner than paper.
 */
#include <bits/stdc++.h>

#define int long long
#define DB double
#define N 1000010

using namespace std;

inline int read()
{
    int x = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9'){if(c == '-') f = -1; c = getchar();}
    while(c <= '9' && c >= '0') x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();
    return x * f;
}

int n, c[N], p[N], x[N], s[N], q[N], f[N], ans = 1e18;

/*
f[i] = min(f[j] + \sum_{k = j + 1}^{i} (x[i] - x[k]) * p[k] + c[i]);
f[i] = min(f[j] + \sum_{k = j + 1}^{i} (x[i] * p[k]) - \sum_{k = j + 1}^{i} x[k] * p[k] + c[i]);
s[i] = \sum_{k = 1}^{i} p[k] * x[k], p[i] = \sum_{k = 1}^{i} p[k];
f[i] = min(f[j] + x[i] * (p[i] - p[j]) - s[i] + s[j] + c[i]);
f[i] = min(f[j] + x[i] * p[i] - x[i] * p[j] - s[i] + s[j] + c[i]);
f[j] = x[i] * p[j] + f[i] - x[i] * p[i] + s[i] - s[j] - c[i];???
*/

inline DB xl(int i, int j)
{
    DB y = f[j] - f[i] + s[j] - s[i];
    if(p[j] == p[i])
    {
        if(y == 0) return 0;
        else
        {
            if(y > 0) return 1e19;
            else return -1e19;
        }
    }
    else return y / (p[j] - p[i]);
    return (f[j] - f[i]) * 1.0 / (p[j] - p[i]);
    // return(p[j] == p[i] ? (!y ? 0 : (y > 0 ? 1e19 : -1e19)) : y / DB(p[j] - p[i]));
}

signed main()
{
    n = read();
    for(int i = 1; i <= n; i ++)
    {
        x[i] = read(), p[i] = read(), c[i] = read();
        s[i] = s[i - 1] + p[i] * x[i];
        p[i] += p[i - 1];
    }
    int h = 1, t = 1;
    for(int i = 1; i <= n; i ++)
    {
        while(h < t && xl(q[h], q[h + 1]) <= x[i]) h ++;
        f[i] = f[q[h]] + x[i] * (p[i] - p[q[h]]) - s[i] + s[q[h]] + c[i];
        // cout << "CAO : " << q[h] << endl;
        while(h < t && xl(q[t - 1], i) <= xl(q[t - 1], q[t])) t --;
        q[++ t] = i;
    }
    h = n; ans = f[n];
    while(h && p[h] - p[h - 1] == 0) h --, ans = min(ans, f[h]);
    cout << ans << endl;
    return 0;
}
```

---

## 作者：DaydreamWarrior (赞：8)

有兴趣的可以看看 [我的博客](https://rainlycoris.github.io/#/post/46)

### 分析

首先写个 $n^2$ dp 转移：

$$
\begin{aligned}
f_i&=\min_{j=1}^{i-1}(f_j+\sum_{k=j+1}^i(x_i-x_k)p_k)+c_i\\
  &=\min_{j=1}^{i-1}(f_j+x_i\sum_{k=j+1}^ip_k-\sum_{k=j+1}^ix_kp_k)+c_i\\
  &=\min_{j=1}^{i-1}(-x_i\sum_{k=1}^jp_k+f_j+\sum_{k=1}^jx_kp_k)+x_i\sum_{k=1}^ip_k-\sum_{k=1}^ix_kp_k+c_i
\end{aligned}
$$

然后 $\min$ 里面的像一次函数，直接上李超树。

### 一些细节

要特判末尾连续的 $p_i=0$，以及第 $8$ 个点卡李超树，别的 hack 倒是不用管。

### 代码

```cpp
const int N = 1000005,INF = (1ull<<63)-1;
int x[N],p[N],c[N],f[N];
int n;

class lctree{
    private:
        struct{int l,r;pair<int,int> f;} tr[N];
        int val(pair<int,int> f,int x){return f.first*x+f.second;};
        int idx;
    public:
        int root;
        void insert(int &u,int l,int r,pair<int,int> f){
            if(!u)
                tr[u=++idx].f =  f;
            else{
                int mid = (l+r)>>1;
                if(val(f,mid)<val(tr[u].f,mid))
                    swap(f,tr[u].f);
                if(f.first>tr[u].f.first)
                    insert(tr[u].l,l,mid,f);
                else
                    insert(tr[u].r,mid+1,r,f);
            }
        }

        int query(int u,int l,int r,int p){
            if(!u)
                return INF;
            int mid = (l+r)>>1;
            return min(val(tr[u].f,p),p<=mid?query(tr[u].l,l,mid,p):query(tr[u].r,mid+1,r,p));
        }
}tr;

signed main(){
    n = in;
    int V = 0;
    for(int k=1;k<=n;k++){
        x[k] = in,p[k] = in,c[k] = in;
        V = max(V,x[k]);
    }
    tr.insert(tr.root,0,V,{0,0});
    int sp = 0,sxp = 0;
    for(int k=1;k<=n;k++){
        sp += p[k];
        sxp += x[k]*p[k];
        f[k] = tr.query(tr.root,0,V,x[k])+x[k]*sp-sxp+c[k];
        tr.insert(tr.root,0,V,{-sp,f[k]+sxp});
    }
    int ans = f[n];
    for(int k=n;k&&!p[k];k--)
        ans = min(ans,f[k-1]);
    out(ans);
    return 0;
}
```

---

## 作者：Biadocy (赞：7)

[本文同步发表于我的博客园](https://www.cnblogs.com/landsol/p/17766695.html)

令 $f_i$ 表示在 $i$ 工厂建立仓库，$i+1\sim n-1$ 工厂不建立仓库的最小费用。对成品数量 $p$ 做一遍前缀和。

转移直接枚举上一个建立的仓库位置：

$$f_i=\min\{f_j-(p_i-p_j)\times(x_n-x_i)+c_i|j<i\}$$

考虑两个转移点 $j<k$，若 $j$ 对于当前位置 $i$ 更优：

$$f_j-(p_i-p_j)\times(x_n-x_i)+c_i<f_k-(p_i-p_k)\times(x_n-x_i)+c_i$$

$$f_j-f_k<(x_n-x_i)\times(p_i-p_j-p_i+p_k)$$

$$\frac{f_k-f_j}{p_k-p_j}>x_i-x_n$$

$x_i-x_n$ 随着 $i$ 增大单调递增，维护 $(p,f)$ 的下凸包。

---

可惜这个做法被 hack 了，因为 $p_n$ 可能为 $0$，最后一个工厂不一定要建仓库，所以不能在前面就把后面的贡献计算好。

令 $f_i$ 表示只考虑前 $i$ 个工厂并在 $i$ 工厂建立仓库的最小费用。

转移直接枚举上一个建立的仓库位置：

$$f_i=\min\left\{\left.f_j+\left(\sum_{l=j+1}^i(x_i-x_l)\times p_l\right)+c_i\right|j<i\right\}$$

$$f_i=\min\left\{\left.f_j+\left(\sum_{l=j+1}^i x_i\times p_l\right)-\left(\sum_{l=j+1}^i x_l\times p_l\right)+c_i\right|j<i\right\}$$

令 $s_i$ 表示 $x_i\times p_i$ 的前缀和数组，然后对 $p$ 做一遍前缀和：

$$f_i=\min\{f_j+x_i\times(p_i-p_j)-(s_i-s_j)+c_i|j<i\}$$

考虑两个转移点 $j<k$，若 $j$ 对于当前位置 $i$ 更优：

$$f_j+x_i\times(p_i-p_j)-(s_i-s_j)+c_i<f_k+x_i\times(p_i-p_k)-(s_i-s_k)+c_i$$

$$f_j-x_i\times p_j+s_j<f_k-x_i\times p_k+s_k$$

$$f_j-f_k+s_j-s_k<x_i\times p_j-x_i\times p_k$$

$$\frac{f_k-f_j+s_k-s_j}{p_k-p_j}>x_i$$

$x_i$ 随着 $i$ 增大单调递增，维护 $(p,f+s)$ 的下凸包。

**如果中途出现了分母为 $\bm 0$ 的情况，斜率应视为无穷大乘上纵坐标差的符号。**因为下凸包横坐标相同时应保留纵坐标较小的点，加入一个纵坐标更小的点时队首会被弹掉，加入一个纵坐标更大的点时队尾会被弹掉，**所以始终只保留了纵坐标最小的一个点。**

**最后答案就在最后一个 $\bm{p>0}$ 的位置到 $\bm n$ 中。**

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define N 1000005
#define Db double
#define Min(x,y)((x)<(y)?x:y)
#define For(i,x,y)for(i=x;i<=(y);i++)
ll p[N],f[N],s[N];
int x[N],c[N],que[N];
int read()
{
	int A;
	bool K;
	char C;
	C=A=K=0;
	while(C<'0'||C>'9')K|=C=='-',C=getchar();
	while(C>'/'&&C<':')A=(A<<3)+(A<<1)+(C^48),C=getchar();
	return(K?-A:A);
}
Db slope(int j,int k)
{
	Db y=f[k]-f[j]+s[k]-s[j];
	return(p[k]==p[j]?(!y?0:(y>0?1e19:-1e19)):y/Db(p[k]-p[j]));
}
int main()
{
	int n,i,head,tail;
	n=read();
	head=tail=1;
	For(i,1,n)
	{
		x[i]=read(),p[i]=read(),c[i]=read();
		s[i]=s[i-1]+x[i]*p[i];
		p[i]+=p[i-1];
	}
	For(i,1,n)
	{
		while(head<tail&&slope(que[head],que[head+1])<=x[i])head++;
//		cerr<<que[head]<<' '<<i<<endl;
		f[i]=f[que[head]]+x[i]*(p[i]-p[que[head]])-(s[i]-s[que[head]])+c[i];
		while(head<tail&&slope(que[tail-1],que[tail])>=slope(que[tail-1],i))tail--;
		que[++tail]=i;
	}
	i=n;
	while(i&&!(p[i]-p[i-1]))i--;
//	cerr<<i<<endl;
	For(i,i,n-1)f[n]=Min(f[n],f[i]);
	cout<<f[n];
	return 0;
}
//#include<bits/stdc++.h>
//using namespace std;
//typedef long long ll;
//#define N 1000005
//#define Db double
//#define Min(x,y)((x)<(y)?x:y)
//#define For(i,x,y)for(i=x;i<=(y);i++)
//ll p[N],f[N];
//int x[N],c[N],que[N];
//int read()
//{
//	int A;
//	bool K;
//	char C;
//	C=A=K=0;
//	while(C<'0'||C>'9')K|=C=='-',C=getchar();
//	while(C>'/'&&C<':')A=(A<<3)+(A<<1)+(C^48),C=getchar();
//	return(K?-A:A);
//}
//Db slope(int j,int k)
//{
//	return Db(f[k]-f[j])/Db(p[k]-p[j]);
//}
//int main()
//{
//	int n,i,head,tail;
//	n=read();
//	head=tail=1;
//	For(i,1,n)
//	{
//		x[i]=read(),p[i]=read(),c[i]=read();
//		f[0]-=p[i]*x[i];
//		p[i]+=p[i-1];
//	}
//	f[0]+=p[n]*x[n];
//	For(i,1,n-1)
//	{
//		while(head<tail&&slope(que[head],que[head+1])<=x[i]-x[n])head++;
//		f[i]=f[que[head]]-(p[i]-p[que[head]])*(x[n]-x[i])+c[i];
//		while(head<tail&&slope(que[tail-1],que[tail])>=slope(que[tail-1],i))tail--;
//		que[++tail]=i;
//	}
//	For(i,1,n-1)f[0]=Min(f[0],f[i]);
//	cout<<f[0]+c[n];
//	return 0;
//}
```

---

## 作者：TJB_LHY (赞：4)

### 形象化题意

有一个数轴，数轴上有 $n$ 个点，到第一个点的距离为 $x_i$，（$x_1=0$），有两个点权分别为 $w_i$ 和 $c_i$（数据保证 $x_i$ 递增）。每个点 $i$ 有两个选择：一、留在原地，花费 $c_i$ 的代价；二、向数轴正方向移动至一个留在原地的点 $j$，花费 $w_i \times (x_j-x_i)$ 的代价。要求所以选择中代价的最小值。

## 算法一：纯暴力 dp

我们设 $dp_i$ 表示前 $i$ 个点所以选择中代价的最小值，通过枚举前一个选择留在原地的点 $j$，容易得出状态转移方程为：$dp_i=\min_{j<i}(dp_j+\sum_{j<k<i}(x_i-x_k)\times w_k+c_i)$。时间复杂度为 $O(n^3)$，不足以通过此题 ~~（分数太低，本蒟蒻不想写）~~。

## 算法二：前缀和优化 dp

化简状态转移方程得：

$$\begin{aligned} dp_{i}&=\min_{j<i}(dp_j+\sum_{j<k<i}(x_i-x_k)\times w_k+c_i)\\&= \min_{j<i}(dp_j+x_i\sum_{j<k<i}w_k-\sum_{j<k<i}x_k\times w_k+c_i) \end{aligned}$$

。发现累加的数只与 $k$ 有关，所以我们设 $sumw_i=\sum_{i=1}^n w_i$，$sumv_i=\sum_{i=1}^n w_i\times x_i$，易得 $sumw_i=sumw_{i-1}+w_i$，$sumv_i=sumv_{i-1} + w_i\times x_i$。
变形状态转移方程为：

$$dp_i=\min_{j<i}(dp_j+x_i\times sumw_{i-1}-x_i\times sumw_{j}-sumv_{i-1}+sumv_j+c_i)$$

。时间复杂度变为 $O(n^2)$，仍不足以通过此题。

## 算法三：前缀和优化 + 斜率优化 dp

我们设 $j_0$ 为使 $dp_i$ 最小的 $j$，变形整理状态转移方程得：$dp_i=dp_{j_0}+x_i\times sumw_{i-1}-x_i\times sumw_{j_0}-sumv_{i-1}+sumv_{j_0}+c_i$。将 $j_0$ 看作未知数，$i$ 看作常数（因为 $i$ 是在外层循环的变量），将仅含未知数项移至等号左侧，其余项移至等号右侧，得：

$$dp_{j_0}+sumv_{j_0}=x_i\times sumw_{j_0}+(dp_i-x_i\times sumw_{i-1}+sumv_{i-1}+c_i)$$ 

对比一次函数：$y=k\times x+b$。令 $y=dp_{j_0}+sumv_{j_0}$、$k=x_i$、$x=sumw_{j_0}$、$b=dp_i-x_i\times sumw_{i-1}+sumv_{i-1}+c_i$。因为原题保证 $x_i$ 单调递增，所以当 $i$ 增大时，斜率 $k$ 也随着增大，则若截距 $b$ 最小时，$dp_i$ 最小。剩下的套上模板即可，可以参考一下[我的模板](https://www.luogu.com.cn/article/g7xwn5sq)。由于优化后可以做到 $O(1)$ 转移，所以枚举 $i$ 不断转移，入队新的一次函数即可。时间复杂度 $O(n)$，足以通过本题。（我的代码中有 tips，你们被 hack 了有很大的原因就是因为这些 tips 没处理好 ~~，本蒟蒻也调了 1h~~）

```cpp
#include <bits/stdc++.h>
#define ll __int128
#define U unsigned
#define ss size()
using namespace std;
void read(ll &x) {
	x=0;
	char y=getchar();
	bool flag=0;
	while(y<'0' || y>'9') {
		if(y=='-')flag=1;
		y=getchar();
	}
	while((y>='0' && y<='9')) {
		x=(x<<1)+(x<<3)+(y-'0');
		y=getchar();
	}
	if(flag)x=-x;
}
void write(ll x) {
	if(x<0) {
		putchar('-');
		x=-x;
	}
	if(x<10)putchar(x+'0');
	else {
		write(x/10);
		putchar(x%10+'0');
	}
}//快读快写
struct node{
    ll x,y,i;
}ttt;
deque<node>q;
ll j,n,id[1000005],w,sumw[1000005],sumv[1000005],c[1000005],dp[1000005],X,Y;
int main() {
    read(n);
    for(ll i=1;i<=n;i++){
        read(id[i]);
        read(sumw[i]);
        read(c[i]);
        dp[i]=10000000000;//赋初始值
        sumv[i]=sumw[i]*id[i]+sumv[i-1];
        sumw[i]+=sumw[i-1];//计算前缀和
    }
    for(ll i=1;i<=n;i++){
        j=i-1;
        X=sumw[j];
        Y=dp[j]+sumv[j];
        ttt={X,Y,j};
        while(q.ss>=2 && (ttt.y-q[q.ss-1].y)*(q[q.ss-1].x-q[q.ss-2].x)<=(q[q.ss-1].y-q[q.ss-2].y)*(ttt.x-q[q.ss-1].x))q.pop_back();
		q.push_back(ttt);//添加节点
        while(q.ss>=2 && q[1].y-q[0].y<=id[i]*(q[1].x-q[0].x))q.pop_front();
        // tips1:以上若使用传统求斜率的函数会导致
		// 		 精度爆炸，提高移项即可。此题不需
		// 		 要变号，大家做题时要留个心眼！！
        j=q[0].i;
        if(sumw[i]==sumw[j])if(dp[j]+id[i]*(sumw[i-1]-sumw[j])-(sumv[i-1]-sumv[j])+c[i]>dp[j]){
            dp[i]=dp[j];
            continue;
        }
		// tips2:以上特判用于计算一段点权w全零时
		// 	     的代价，此时不需要建仓库。若你的
		// 		 代码被hack了，可以看看我代码下
		// 		 面的hack数据链接
        dp[i]=dp[j]+id[i]*(sumw[i-1]-sumw[j])-(sumv[i-1]-sumv[j])+c[i];//O(1)转移
    }
    write(dp[n]);
	return 0;
}
```

#### 附件

[hack 数据](https://www.luogu.com.cn/discuss/947213)、[我的斜率优化模板](https://www.luogu.com.cn/article/g7xwn5sq)

完结撒花！~~敲了 3300+ 字符，花了 2h+，真累死我了。~~

---

## 作者：人间温柔 (赞：2)

这是一道斜率优化的一道很好的练手题，和 [P3195 [HNOI2008] 玩具装箱](https://www.luogu.com.cn/problem/P3195)十分相似，可以放在一起对比，加深对斜率优化的理解。

个人感觉讲的挺清楚的，可以供斜率优化初学者参考。

第一部分 朴素 dp
---

![](https://cdn.luogu.com.cn/upload/image_hosting/j5z20hce.png)

首先一眼看出这是一个分组 dp 的过程，各个仓库之间所夹的工厂为一组。按照分组 dp 的基本方法，假设 $f[i]$ 表示在 $i$ 处建立一个仓库所需要花费的最小代价。转移的时候枚举当前组的末尾编号 $i$ 和前一组的末尾编号 $j$，表示在 $i$ 处建立一个仓库，$i$ 之前最早的一个仓库是 $j$，那么 $f[j]$ 加上 $[j+1,i]$ 之间的总代价 $c[i]+\sum_{k=j+1}^{i}(x[j+1]-x[k])p[k]$ 就等于 $f[i]$，其中 $c[i]$ 表示建立 $i$ 仓库本身所需花费，$\sum_{k=j+1}^{i}(x[j+1]-x[k])p[k]$ 表示把货物运送到仓库 $i$ 中所需的花费。

列出状态转移方程如下：
$$
f[i]=\min_{0\leq j\leq i-1}\{\ f[j]+c[i]+\sum_{k=j+1}^{i}(x[i]-x[k])p[k]\ \}
$$
这个式子的时间复杂度为 $O(n^3)$，需要优化。

第二部分 前缀和优化
---
但凡学过动态规划的同学都可以一眼看出来式子中大 sigma 可以用前缀和优化掉。

先把方程简化一下，以构造出同构式：
$$
f_[i]=\min_{0\leq j\leq i-1}\{\ f[j]+c[i]+\sum_{k=j+1}^{i}x[i]p[k]-\sum_{k=j+1}^{i}x[k]p[k]\ \}
$$
$$
f[i]=\min_{0\leq j\leq i-1}\{\ f[j]+c[i]+x[i]\sum_{k=j+1}^{i}p[k]-\sum_{k=j+1}^{i}x[k]p[k]\ \}
$$
现在令 $sump[i]=\sum_{k=1}^{i}p[k]$，$sumxp[i]=\sum_{k=1}^{i}x[k]p[k]$。那么用前缀和可以把方程转化为：
$$
f[i]=\min_{0\leq j\leq i-1}\{\ f[j]+c[i]+x[i](sump[i]-sump[j])-(sumxp[i]-sumxp[j])\ \}
$$
**记住这个状态转移方程，后面还要用到！！！**

核心代码：
```cpp
for(int i=1;i<=n;i++){
    for(int j=0;j<=i-1;j++){
        f[i]=min(f[i],f[j]+c[i]+x[i]*(sump[i]-sump[j])-(sumxp[i]-sumxp[j]));
    }
}
```


优化后的时间复杂度是 $O(n^2)$，还是不够。

第三部分 斜率优化
---
接下来的斜率优化是重头戏，就是有亿点点抽象。

~~注意到~~，$f[i]$ 的值由多个 $j$ 确定（~~这不废话吗~~），这么多的 $j$ 中，每一个 $j$ 都可以叫做一个**决策**，我们取出两个决策：$j_1$ 和 $j_2$，并令 $0\leq j_1<j_2\leq i-1$。然后我们看看在什么样的情况下 $j_2$ 一定会优于 $j_1$。

所谓 $j_2$ 优于 $j_1$，就是指由 $j_2$ 计算而得的 $f[i]_2$ 比由 $j_1$ 计算而得的 $f[i]_1$ 更小，这样的话 $f[i]$ 的最终值一定不可能是 $f[i]_1$（因为方程里面是取 $\min$ 的）。所以，
$$
f[j_2]+x[i](sump[i]-sump[j_2])-(sumxp[i]-sumxp[j_2])\leq f[j_1]+x[i](sump[i]-sump[j_1])-(sumxp[i]-sumxp[j_1])
$$
把括号展开，消去相同的项：
$$
f[j_2]-x[i]sump[j_2]+sumxp[j_2]\leq f[j_1]-x[i]sump[j_1]+sumxp[j_1]
$$
$$
(sump[j_1]-sump[j_2])x[i]\leq (f[j_1]+sumxp[j_1])-(f[j_2]+sumxp[j_2])
$$
因为 $sump[i]$ 是前缀和函数，且每一个 $p[i]>0$，所以 $sump[i]$ 是单调增的。又有 $j_1<j_2$，所以 $sump[j_1]-sump[j_2]<0$，把 $sump[j_1]-sump[j_2]$ 除到等号右边，要变号：
$$
x[i]\geq \dfrac{(f[j_1]+sumxp[j_1])-(f[j_2]+sumxp[j_2])}{sump[j_1]-sump[j_2]}=\dfrac{(f[j_2]+sumxp[j_2])-(f[j_1]+sumxp[j_1])}{sump[j_2]-sump[j_1]}.........①
$$
**记住这个式子，后面要用很多次！！！**

以上过程均可逆推，因此只要有满足这一不等关系的 $j_1,j_2$，那么  $j_2$ 就一定优于 $j_1$，在状态转移的过程中，$j_1$ 就可以直接舍弃，忽略不计（就好像在单调队列优化的 dp 中，经常舍弃那些不可能被转移的数据一样）。

那么剩下的那些没有被舍弃的 $j$ 具有什么样的性质？

这就要和“斜率优化”中的“斜率”一词搭上关系了。

~~注意到~~，$\dfrac{(f[j_2]+sumxp[j_2])-(f[j_1]+sumxp[j_1])}{sump[j_2]-sump[j_1]}$ 在形式上和解析几何中的斜率公式 $k=\dfrac{y_1-y_2}{x_1-x_2}$ 很像，因此~~很容易想到~~，如果把 $sump$ 作为横坐标，$f+sumxp$ 作为纵坐标，那么 $\dfrac{(f[j_2]+sumxp[j_2])-(f[j_1]+sumxp[j_1])}{sump[j_2]-sump[j_1]}$ 就代表了决策 $j_1,j_2$ 之间的“斜率”。

在斜率优化中，所有没被舍弃的 $j$ 在平面直角坐标系中基本只构成两种形状：上凸包或下凸包。

先给出结论，本道题是下凸包。下证：如果存在如下图的三种决策 $j_1,j_2,j_3$，它们构成了上凸包，那么 $j_2$ 一定不是这三者中的最优点。 

证明：记 $j_1$ 与 $j_2$、$j_2$ 与 $j_3$ 之间的斜率为 $k_{1,2},k_{2,3}$。因为横坐标 $sump$ 单调增，又由图可知 $sump[j_1]<sump[j_2]<sump[j_3]$，所以 $j_1<j_2<j_3$。反设：假设 $j_2$ 是 $j_1,j_2,j_3$ 中的最优点，那么 $j_2$ 优于 $j_1$，根据上文 ① 式可知，$k_{1,2}\leq x[i]$。同理，$k_{2,3}<k_{1,2}<x[i]$，又因为 $j_2<j_3$，所以 $j_3$ 优于 $j_2$，所以 $j_2$ 应当舍弃，与假设矛盾。证毕！
![](https://cdn.luogu.com.cn/upload/image_hosting/9sczni38.png)
因此一定是一个下凸包，决策之间的斜率是递增的。维护这一凸包可以使用**单调队列**来存储斜率。

参考 ① 式，对于给定的 $i$，找到一个 $j'$ 使得凸包上 $j'$ 左侧的斜率均小于 $x[i]$，右侧的斜率均大于 $x[i]$，那么这个 $j'$ 就一定能够让状态转移方程中的 $f[j]+c[i]+x[i](sump[i]-sump[j])-(sumxp[i]-sumxp[j])$ 取到最小值，那么 $f[i]$ 就自然等于 $f[j']+c[i]+x[i](sump[i]-sump[j'])-(sumxp[i]-sumxp[j'])$ 了。

可以借助下图形象理解。先画出所有下凸包，在画一条红色的直线，其斜率为 $x[i]$。将这条红色的直线从 $y=-\infty$ 向 $y=+\infty$ 移动，他和下凸包的第一个交点就是 $j'$。
![](https://oi-wiki.org/dp/images/optimization.svg)

本道题中，寻找这样的 $j'$，可以通过不断删除单调队列中队头的元素寻找。但并不是所有的斜率优化的题都可以这么来找 $j'$，只是因为这道题恰好 $x[i]$ 代表工厂 $i$ 到工厂 $1$ 的距离，因此是单调增的，之前删除的对头元素不可能作为之后某次转移的最优元素。还是通过上面这张图理解，状态转移时，随着 $i$ 增大，红色直线的斜率 $x[i]$ 也在增大，那么红色直线和凸包的交点只会越来越往右，不会往左。

如果以后碰到的题目，$x[i]$ 不再具有单调性，那么就不能通过删除队头元素来寻找 $j'$ 了，而应当使用二分查找。

而在代码实现时，要考虑的问题是：斜率运算涉及除法，可能会造成误差。所以我是把 ① 式子的除法式子转换成乘积式：
$$
(sump[j_1]-sump[j_2])x[i]\leq (f[j_1]+sumxp[j_1])-(f[j_2]+sumxp[j_2])
$$

寻找 $j'$ 的核心代码：

```cpp
while(head+1<=tail){
	int j1=q[head],j2=q[head+1];
	if( ( sump[j2] - sump[j1]) * x[i] >= ( f[j2] + sumxp[j2] ) - ( f[j1] + sumxp[j1] ) ) head++;
	else break;
}
```
状态转移的核心代码：
```cpp
f[i] = f[q[head]] + c[i] + x[i] * ( sump[i] - sump[q[head]] ) - ( sumxp[i] - sumxp[q[head]] );
```
状态转移完之后，还要把当前的状态 $i$ 加入下凸包（单调队列的基本原理）。要确保加入后还是一个下凸包，因此要去除队尾的一些不优于 $i$ 的元素。核心代码如下，代码中 $j_1,j_2$ 是 $i$ 之前的两个下凸包顶点。~~由于本人的强迫症~~，代码中令 $j_3=i$。如果 $j_3$ 优于 $j_2$，那么 $j_1,j_2$ 的斜率大于等于 $j_2,j_3$ 的斜率，即：
$$
\dfrac{(f[j_2]+sumxp[j_2])-(f[j_1]-sumxp[j_1])}{sump[j_2]-sump[j_1]}\geq \dfrac{(f[j_3]+sumxp[j_3])-(f[j_2]-sumxp[j_2])}{sump[j_3]-sump[j_2]}
$$
这里还是涉及除法，还是把除法式转换成乘积式：
$$
((f[j_2]+sumxp[j_2])-(f[j_1]-sumxp[j_1]))\times (sump[j_3]-sump[j_2])\geq ((f[j_3]+sumxp[j_3])-(f[j_2]-sumxp[j_2]))\times (sump[j_2]-sump[j_1])
$$
核心代码：
```cpp
while(head+1<=tail){
	int j1=q[tail-1],j2=q[tail],j3=i;
	if( ( (f[j2] + sumxp[j2]) - (f[j1] + sumxp[j1]) ) * (sump[j3] - sump[j2]) >= ( (f[j3] + sumxp[j3]) - (f[j2] + sumxp[j2]) ) * (sump[j2]-sump[j1]) ) tail--;
	else break;
}
q[++tail]=i;
```
最后输出 `f[n]` 即可。

然而，这样是无法通过 hack 数据的。

题目里的数据范围写着：$p_i\geq 0$。可能从某一位的 $p[i]$ 开始，一直到  $p[n]$ 都等于 $0$，那么这个时候，最后一个仓库建在 $n$ 未必是最优的。因此我们只需要从 $n$ 往 $1$ 倒着扫一遍，找出最后一段 $p[i]=0$ 的这些位置中 $f[i]$ 的最小值就可以了。

所以输出的代码如下：
```cpp
int last=n;
ans=f[n];
while(p[last]==0){
	last--;
	ans=min(ans,f[last]);
}
cout<<ans<<endl;
```
完整代码见[云剪贴板](https://www.luogu.com.cn/paste/44g39w6m)。

斜率优化后的时间复杂度降到了 $O(n)$。

总结
---
斜率优化适用于状态转移方程形如 $f[i]=\min/\max\{\ f[j]+A(i)\times B(j)\ \}+K(i)$ 的题目，其中 $A(i),B(j),K(i)$ 为三个函数。

通过研究决策 $j_2$ 何时优于 $j_1$ 构造出平面直角坐标系上的上凸包或下凸包，并用单调队列维护。

文中两张图片取自 OI-Wiki 的[斜率优化](https://oi-wiki.org/dp/opt/slope/)一章。

---

## 作者：114514xxx (赞：2)

## 题意
[题目传送门](https://www.luogu.com.cn/problem/P2120) 

## 思路

朴素的 $O(n^2)$ 的 dp 式子是简单的。
$$f_i=\min_{j<i}\{f_j+\sum^{i-1}_{k=j+1}(x_i-x_k)p_k+c_i\}$$

稍微简单变形一下

$$f_i=\min_{j<i}\{f_j+x_i \sum^{i-1}_{k=j+1}p_k+\sum^{i-1}_{k=j+1}x_kp_k\}+c_i$$

令 $s_j=\sum^{j}_{i=1}p_i,t_j=\sum^{j}_{i=1}p_ix_i$，那么我们的式子就可以变为

$$f_i=\min_{j<i}\{f_j+x_i(s_{i-1}-s_{j})+(t_{i-1}-t_{j})\}+c_i$$

显然这是可以斜率优化的，设存在两个决策点 $u$ 和 $v$，满足 $u<v$ 且 $u$ 比 $v$ 更优。那么我们有

$$f_u+x_i(s_{i-1}-s_{u})+(t_{i-1}-t_{u})<f_v+x_i(s_{i-1}-s_{v})+(t_{i-1}-t_{v})$$

化简一下式子得到
$$\frac{f_u-f_v+t_v-t_u}{s_v-s_u}<x_i$$

这题的 $x_i$ 是单调的，维护一个 $(s,f+t)$ 的下凸包即可。可以使用单调队列进行维护。

注意若末尾有连续的 $p_i=0$ 时，取其最小的 $f$ 值即可。

## 代码


```cpp
#include<bits/stdc++.h>
#define int long long
#define lf long double
using namespace std;
const int N=1e6+25;
const lf eps=0.00001;
int f[N],x[N],p[N],c[N],n;
int s[N],t[N],head,tail,q[N];
inline lf slope(int i,int j){
    lf y=f[j]-f[i]+t[j]-t[i];
    return y/(1.0*(s[j]-s[i]));
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    cin>>n;
    //memset(f,0x3f,sizeof(f));
    for(int i=1;i<=n;i++)cin>>x[i]>>p[i]>>c[i];
    for(int i=1;i<=n;i++){
        s[i]=p[i]+s[i-1];
        t[i]=p[i]*x[i]+t[i-1];
    }
    //f[1]=0;
    int head=1,tail=1;
    for(int i=1;i<=n;i++){
        while(head<tail&&slope(q[head],q[head+1])<=x[i])++head;
        f[i]=f[q[head]]+x[i]*(s[i-1]-s[q[head]])-t[i-1]+t[q[head]]+c[i];
        while(head<tail&&slope(q[tail-1],i)<=slope(q[tail-1],q[tail]))--tail;
        q[++tail]=i;
    }
    head=n;int ans=f[n];
    while(head&&s[head]==s[head-1])head--,ans=min(ans,f[head]);
    cout<<ans ;
}

```

---

## 作者：可爱的小棉羊 (赞：1)

水题。

有个很显然的事情：一个仓库建在 $i$，$j$ 若是他前一个仓库那么 $(j,i]$ 的所有产品都会到 $i$。

这样，设 $dp_i$ 为在 $i$ 处建仓库使得 $[1,i]$ 都合法的代价，就可以写出转移：

$$dp_i=\min_{j=0}^{i-1}(dp_j+\sum_{k=j+1}^i(x_i-x_k)p_k+c_i)$$

那么考虑拆开：

$$dp_i=\min_{j=0}^{i-1}(dp_j+x_i\sum_{k=j+1}^ip_k-\sum_{k=j+1}^ix_kp_k)+c_i$$

令 $S_n=\sum_{i=1}^np_i$，$T_n=\sum_{i=1}^nx_ip_i$。

$$dp_i=\min_{j=0}^{i-1}(dp_j+x_i(S_i-S_j)-(T_i-T_j))+c_i$$

整理：

$$dp_i=\min_{j=0}^{i-1}(dp_j+T_j-x_iS_j)+S_ix_i+c_i-T_i$$

经典形式，斜率优化，维护下凸壳即可。

---


# [HNOI2008] 玩具装箱

## 题目描述

P 教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。

P 教授有编号为 $1 \cdots n$ 的 $n$ 件玩具，第 $i$ 件玩具经过压缩后的一维长度为 $C_i$。

为了方便整理，P 教授要求：

- 在一个一维容器中的玩具编号是连续的。

- 同时如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物。形式地说，如果将第 $i$ 件玩具到第 $j$ 个玩具放到一个容器中，那么容器的长度将为 $x=j-i+\sum\limits_{k=i}^{j}C_k$。

制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为 $x$，其制作费用为 $(x-L)^2$。其中 $L$ 是一个常量。P 教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过 $L$。但他希望所有容器的总费用最小。

## 说明/提示

对于全部的测试点，$1 \leq n \leq 5 \times 10^4$，$1 \leq L \leq 10^7$，$1 \leq C_i \leq 10^7$。

## 样例 #1

### 输入

```
5 4
3
4
2
1
4```

### 输出

```
1```

# 题解

## 作者：辰星凌 (赞：725)

# **【学习笔记】动态规划—斜率优化DP（超详细）**

$update\ 2020.6.19:$ 临近退役，终于来修锅啦QAQ（更正基础概念上的错误；$\text{Latex}$ 规范化；重新排版；增加标题号；添加【关于单调性的研究】；添加 $\text{CDQ}$ 维护斜率优化的例子）

[$\mathcal{My}\ \mathcal{Blog}$](https://www.cnblogs.com/Xing-Ling/p/11210179.html)

**[【学习笔记】动态规划—各种 $\text{DP}$ 优化](https://www.luogu.com.cn/blog/ChenXingLing/post-xue-xi-bi-ji-dong-tai-gui-hua-ge-zhong-dp-you-hua)**

## **【前言】**

第一次写这么长的文章。

写完后对斜优的理解又加深了不少（$update\ 2020.6.19:$ 回过头来看这句话满是讽刺啊，明明这时候连基本的概念都没有理清....）。

本文讲解较详，只要耐心读下去，相信大部分 $\text{OIer}$ 都能看懂。

斜率优化 $\text{dp}$，顾名思义就是利用斜率相关性质对 $\text{dp}$ 进行优化。

斜率优化通常可以由两种方式来理解，需要灵活地运用数学上的**数形结合,线性规划**思想。

对于这样形式的 $\text{dp}$ 方程：$dp[i]=\min/ \max(a[i]\times b[j]+c[j]+d[i])$，其中 $b$ 严格单调递增。

该方程的关键点在于 $a[i]\times b[j]$ 这一项，它既有 $i$ 又有 $j$，于是单调队列优化不再适用，可以尝试使用斜率优化。

---------

## **一.【理解方式】**

以 [**【模板】** 玩具装箱 $\text{toy [P3195]}$](https://www.luogu.org/problemnew/show/P3195) 为例，两种斜优的理解方式。

设 $S[n]=\sum_{i=1}^n(C[i]+1)$，用 $dp[i]$ 表示装好前 $i$ 个的最小花费，则转移方程为：$dp[i]=\min(dp[j]+(S[i]-S[j]-1-L)^2)$。

为方便描述，将 $\text{L}$ 提前加 $1$，再把 $\min$ 去掉，得到状态转移方程：$dp[i]=dp[j]+(S[i]-S[j]-L)^2$。

化简得：$dp[i]=S[i]^2-2S[i]L+dp[j]+(S[j]+L)^2-2S[i]S[j]$

### **1.【代数法（数形结合）】**

只含 $\text{L}$ 的项对于每一个 $i$ 的**择优筛选**过程都是完全一样的值，只含 $Function(i)$ 的项在一次 $i$ 的**择优筛选**过程中不变，含 $Function(j)$ 的项可能会不断变化（在本题中表现为为**严格单增**）。  
我们以此为划分依据，把同类型的项用括号括起来，即：$dp[i]=(-2S[i]S[j])+(dp[j]+(S[j]+L)^2)+(S[i]^2-2S[i]L)$

#### **(1).【维护一个凸包】**

设 $j_1,j_2$ $(0 \leqslant j_1<j_2<i)$ 为 $i$ 的两个决策点，且满足**决策点 $j_2$ 优于 $j_1$**，
有：$(-2S[i]S[j_2])+(dp[j_2]+(S[j_2]+L)^2)+(S[i]^2-2S[i]L) \leqslant (-2S[i]S[j_1])+(dp[j_1]+(S[j_1]+L)^2)+(S[i]^2-2S[i]L)$

即：$(-2S[i]S[j_2])+(dp[j_2]+(S[j_2]+L)^2) \leqslant (-2S[i]S[j_1])+(dp[j_1]+(S[j_1]+L)^2)$

**划重点：此处移项需要遵循的原则是：参变分离。将 $Function(i)$ 视作未知量，用  $Function(j)$ 来表示出 $Function(i)$ 。**

> 移项得：$-2S[i](S[j_2]-S[j_1]) \leqslant (dp[j_1]+(S[j_1]+L)^2)-(dp[j_2]+(S[j_2]+L)^2)$  
$\because C[j] \geqslant 1$  
$\therefore S[j+1] > S[j]$  
$\text{又} \because j_2 > j_1$  
$\therefore S[j_2]-S[j_1]>0$  
$\therefore 2S[i] \geqslant \frac {(dp[j_2]+(S[j_2]+L)^2)-(dp[j_1]+(S[j_1]+L)^2)} {S[j_2]-S[j_1]}$  
设 $Y(j)=dp[j]+(S[j]+L)^2,X(j)=S[j]$，
即 $2S[i] \geqslant \frac {Y(j_2)-Y(j_1)} {X(j_2)-X(j_1)}$

显然等式右边是一个关于点 $P(j_2)$ 和 $P(j_1)$ 的斜率式，其中 $P(j)=(X(j),Y(j))=(S[j],dp[j]+(S[j]+L)^2)$。

也就是说，如果存在两个决策点 $j_1,j_2$ 满足 $(0 \leqslant j_1<j_2<i)$，使得不等式 $\frac {Y(j_2)-Y(j_1)} {X(j_2)-X(j_1)} \leqslant 2S[i]$ 成立，或者说 使得 $P(j_2),P(j_1)$ 两点所形成直线的斜率小于等于 $2S[i]$，那么**决策点 $j_2$ 优于 $j_1$**。

> **划重点：斜优灵活多变，细节麻烦也多，所以尽量将问题模式化。**  
比如这里的最终公式，尽量化为 $\frac {(j)-(j')} {(j)-(j')}$ 的形式，而不是 $\frac {(j)-(j')} {(j')-(j)}$ ，虽然直接做一般也不会出什么问题，但这样子可以方便理解，方便判断凸包方向等等。

假设有酱紫的三个点 $P(j_1),P(j_2),P(j_3)$，$k_1,k_2$ 为斜率，如下图所示情况（三点分别为 $A,B,C$）：

![](http://images.cnblogs.com/cnblogs_com/Xing-Ling/1457207/o_464656465.PNG)

显然有 $k_2 < k_1$。设 $k_0=2S[i]$，由上述结论可知：  
> $(a).$ 若 $k_1 \leqslant k_0$，则 $j_2$ 优于 $j_1$ 。反之，若 $k_1 > k_0$，则 $j_1$ 优于 $j_2$ 。  
$(b).$ 若 $k_2 \leqslant k_0$，则 $j_3$ 优于 $j_2$ 。反之，若 $k_2 > k_0$，则 $j_2$ 优于 $j_3$ 。

于是这里可以分三种情况来讨论：  
> $(1).$ $k_0 < k_2 < k_1$。由 $(a),(b)$ 可知：$j_1$ 优于 $j_2$ 优于 $j_3$ 。  
$(2).$ $k_2 \leqslant k_0 < k_1$。由 $(a),(b)$ 可知：$j_1$ 和 $j_3$ 均优于 $j_2$。  
$(3).$ $k_2 < k_1 \leqslant k_0$。由 $(a),(b)$ 可知：$j_3$ 优于 $j_2$ 优于 $j_1$ 。

可以发现，对于这三种情况，$j_2$ **始终不是最优解**，于是我们可以**将 $j_2$ 从候选决策点中踢出去（删除）**，只留下 $j_1$ 和 $j_3$，删后的情况如下图所示：

![](http://images.cnblogs.com/cnblogs_com/Xing-Ling/1457207/o_456.PNG)

我们要对某一个问题的解决方案进行优化改进，无非就是关注两个要点：**正确性**和**高效性**（很多时候**高效性**都体现为**单调性**）。

酱紫做的**正确性**是毋庸置疑的，因为在 $j_1$ 和 $j_3$ 其中必定有一个比 $j_2$ 更优，所以删除 $j_2$ 对答案没有任何影响。

那么**高效性**呢？自己在脑子里面 $yy$ 一下，在一个坐标系的第一象限中（本题中 $X(j)$ 和 $Y(j)$均大于等于 $0$，至于为什么这里要说等于，下面会提到），有若干个离散的点，任取三点，如果左边斜率大于右边斜率，则形成了上述情况，必定会删点，因而消除这种情况。所以**将最后留下来的点首位相连，其形成的各个线段斜率从左到右必定是单调递增的**（有可能非严格递增，这个问题之后再讨论）。

如果学习过计算几何相关知识，会意识到这个过程其实与求凸包算法是类似的。（顺手丢一个广告：[【学习笔记】计算几何全家桶](https://www.luogu.com.cn/blog/ChenXingLing/post-xue-xi-bi-ji-ji-suan-ji-he-quan-jia-tong)）

实际上在图中选取最靠左下面、下面、右下面的点首位相连，就是最后留下来的点了，它们形成了一个**下凸包**，即**凸包**（又名**凸壳**）的**下半部分**（不严谨的讲，给定二维平面上的点集，凸包就是将最外层的点连接起来构成的**凸多边形**，它能包含点集中所有的点——摘自[百度百科](https://baike.baidu.com/item/%E5%87%B8%E5%8C%85/179150?fr=aladdin)）。

维护出的图形如下图所示：

![](http://images.cnblogs.com/cnblogs_com/Xing-Ling/1457207/o_789.PNG)

可以尝试在凸包围起来的区域内任意取一点，其必定能在包围圈上找到两个点使得该点可被删除。如上 $\text{L}$ 点，它与 $D,E$ 两点形成了一个可删点图形。

> 注意：图中 $C,D,E$ 故意画成了三点一线，而实际上点 $D$ 是可以删去的，且严格凸包不允许存在这种情况。关于去重的细节问题后面会提到。

**同理**，如果把不等式 $\frac {Y(j_2)-Y(j_1)} {X(j_2)-X(j_1)} \leqslant k_0[i]$ 改为 $\frac {Y(j_2)-Y(j_1)} {X(j_2)-X(j_1)} \geqslant k_0[i]$，那么维护出来的就是一个**上凸包**。

#### **(2).【寻找最优决策点】**

在一次决策点的寻找中，易知下凸包点集里总会存在一点，使得它与左邻点形成的斜率小于等于 $k_0$ ，与右邻点形成的斜率大于 $k_0$ 。

例如上图中的 $E$ 点，设 $k_4 \leqslant k_0 < k_5$ 由于凸包上面的斜率呈单增态，那么有：$k_1 < k_2 < k_3 < k_4 \leqslant k_0 < k_5 < k_6 < k_7$，所以决策点 $E$ 优于其他所有点，即 $E$ 就是 $dp[i]$ 的**最优决策点**。

如果暴力查找的话，就是从第一个点开始向后扫描，找到**第一个斜率大于 $k_0$ 的线段**，其左端点即为**最优决策点**。由于凸包上的斜率依次递增，可以**二分**快速得到这个点。

### **2.【线性规划】**

先回顾一下模板题的 $\text{dp}$ 方程：$dp[i]=S[i]^2-2S[i]L+dp[j]+(S[j]+L)^2-2S[i]S[j]$。

对其进行移项变化，变成形如 $y=kx+b$ 的点斜式。  
**划重点：移项要遵循的原则是：把含有 $function(i)*function(j)$ 的表达式看作斜率 $k_0$ 乘以未知数 $x$，含有 $dp[i]$ 的项必须要在 $b$ 的表达式中，含有 $function(j)$ 的项必须在 $y$ 的表达式中。如果未知数 $x$ 的表达式单调递减，最好让等式两边同乘个 $-1$，使其变为单增**。

至于为什么说要让 $x$ 的表达式单增，emm...其实是为了让一些较简单的问题模式化，不易出错，如果你非要单减，可以尝试倒序枚举，至于是否正确，具体实现需要注意的玄学问题等等，因为觉得太麻烦没有细想，我也不清楚会遇到什么问题。

例如此题，原 $\text{dp}$ 方程可化为：
$(2S[i])S[j]+(dp[i]-S[i]^2+2S[i]L)=(dp[j]+(S[j]+L)^2)$

其中 $k_i=2S[i],$ $x_i=S[j],$ $b_i=dp[i]-S[i]^2+2S[i]L,$ $y_i=dp[j]+(S[j]+L)^2$。

其实也可以化为：
$(2S[i])(S[j]+L)+(dp[i]-S[i]^2)=(dp[j]+(S[j]+L)^2)$
其中 $k_i=2S[i],$ $x_i=S[j]+L,$ $b_i=dp[i]-S[i]^2,$ $y_i=dp[j]+(S[j]+L)^2$。

还可以化为 $...$

$...$

只要满足上述移项原则，对答案是没有任何影响的。

这里以第一种形式为例，先画出草图：

![](http://images.cnblogs.com/cnblogs_com/Xing-Ling/1457207/o_14564864.PNG)

#### **(1).【高中数学知识】**

我们的目的是求出一个**最优决策点** $j$ 使得 $dp[i]$ 最小，又因为 $b[i]=dp[i]-S[i]^2$ ，所以就是要找到某个点使这条直线经过它时算出来的 $b$ 最小，即是高中数学课本上的**线性规划**问题。

#### **(2).【寻找最优决策点】**

![](http://images.cnblogs.com/cnblogs_com/Xing-Ling/1457207/o_4684.PNG)

如图所示，点 $E$ 即为**最优决策点**。显然，这个使得 $b$ 最小的**最优决策点**位于**下凸包**点集中，且与上述**代数法**求得的点一致。

### **3.【两种思考方式的结合】**

强烈推荐用**线性规划**思想主导思考过程，因为图形的变幻较直观，更重要的是：在某某变量不满足单调性时，通过图形可以迅速做出判断并改变策略（在后面【关于单调性的研究】中会详细解释）。

而**代数法**通常在不便于识别方程特征时起一个转换思维方向的作用，因为有些题可能会直接出现 $\frac{Y(j)-Y(j')}{X(j)-X(j')}$ 的形式，需要通过一系列代数推导后再绘草图模拟决策。

------

## **二.【维护凸包】**

实际上只要让维护的凸包方向相同，两种思考方式的代码是一模一样的。

用单调队列维护凸包点集，操作分三步走：  
$(1).$ 进行**择优筛选**时，在凸包上找到**最优决策点** $j$ 。  
$(2).$ 用**最优决策点** $j$ 更新 $dp[i]$ 。  
$(3).$ 将 $i$ 作为一个**决策点**加入图形并更新凸包（如果点 $i$ 也是 $dp[i]$ 的**决策点之一**，则需要将 $(3)$ 换到最前面）。

在本题中步骤 $(3)$ 的具体操作为：判断当队尾的点与点 $i$ 形成可删点图形时，出队直至无法再删点，然后将 $i$ 加入队列。  



在判断可删图形时有两种方法（以 下凸包 为例），一种是 `slope(Q[t-1],Q[t])<=slope(Q[t],i)`，另一种是 `slope(Q[t-1],Q[t])<=slope(Q[t-1],i)`，都表示出现了可以删去点 $Q[t]$ 的情况（只要对边界、去重的处理足够严谨，两种写法是没有区别的）。其中 $Q$ 是维护凸包点集的队列。

该做法时间复杂度为 $O(n\log n)$，瓶颈在于二分寻找**最优决策点**。

------

## **三.【再优化】**

运用**决策单调性**进行优化。**决策单调性**相关基础知识见 **[【学习笔记】动态规划—各种 $\text{DP}$ 优化](https://www.cnblogs.com/Xing-Ling/p/11317315.html)**，这里只放一下定义：  
设 $j_0[i]$ 表示 $dp[i]$ 转移的**最优决策点**，那么**决策单调性**可描述为 $\forall i\leqslant i',j_0[i]\leqslant j_0[i']$。也就是说随着 $i$ 的增大，所找到的**最优决策点**是递增态（非严格递增）。

### **(1).【决策单调性证明】**

还是以 [玩具装箱](https://www.luogu.org/problemnew/show/P3195) 为例，来简单证一波决策单调性，方法采用**四边形不等式**。

显然，本题的转移方程呈现出了 $dp[i]=\min(dp[j]+w(i,j))$ 的形式，即 $1D/1D$ 动态规划方程，其中 $w(i,j)=(S[i]-S[j]-1-L)^2$。

$证明：设$ $Q=S[i]-S[j]-1-L$

$\therefore w(i,j)=(S[i]-S[j]-1-L)^2=Q^2$

$\begin{aligned}
\therefore w(i+1,j+1)=&(S[i+1]-S[j+1]-1-L)^2\\
                   =&((S[i]+C[i+1]+1)-(S[j]+C[j+1]+1)-1-L)^2\\
                   =&(Q+C[i+1]-C[j+1])^2
\end{aligned}$

$\begin{aligned}
w(i,j+1)=&(S[i]-S[j+1]-1-L)^2\\
                   =&(S[i]-(S[j]+C[j+1]+1)-1-L)^2\\
                   =&(Q-C[j+1]-1)^2
\end{aligned}$

$\begin{aligned}
w(i+1,j)=&(S[i+1]-S[j]-1-L)^2\\
                   =&((S[i]+C[i+1]+1)-S[j]-1-L)^2\\
                   =&(Q+C[i+1]+1)^2
\end{aligned}$

$\therefore w(i,j)+w(i+1,j+1)=2Q^2+2C[i+1]Q-2C[j+1]Q+C[i+1]^2-2C[i+1]C[j+1]+C[j+1]^2$

$\therefore w(i+1,j)+w(i,j+1)=2Q^2+2C[i+1]Q-2C[j+1]Q+C[i+1]^2+2C[i+1]+2C[j+1]+C[j+1]^2+2$

$\therefore w(i,j)+w(i+1,j+1)-w(i+1,j)+w(i,j+1)=-2(C[i+1]+1)(C[j+1]+1)$

$\text{又} \because C[i],C[j] \geqslant 1$

$\therefore -2(C[i+1]+1)(C[j+1]+1) \leqslant -8$

$\therefore w(i,j)+w(i+1,j+1) \leqslant w(i+1,j)+w(i,j+1)$

四边形不等式成立，所以此方程具有决策单调性。  
证毕。

### **(2).【单调队列】**

由于**最优决策点**递增，可以用单调队列对其进行维护。操作 $(2),(3)$ 不需要改动，操作 $(1)$ 改为：判断当队首的第一根线段斜率小于等于 $k_0[i]$ 时就出队，直至斜率大于 $k_0[i]$，此时的队首即为**最优决策点**。

正确性显然。因为随着 $i$ 的变大，最优决策点 $j_0[i]$ 也会跟着变大，如果已知某个点在当前情况下不够侑秀，那么在这之后也一定不会作为最优决策点，所以可以直接出队。

时间复杂度为 $O(n)$ 。

### **(3).【再证决策单调性】**

一样的，两种思路。

先观察 $k_0[i]$ 的表达式：$k_0[i]=2S[i]$ ，明显在本题中 $k_0$ 呈单增态。

#### **【代数法】**

$k_0[i]$ 递增就说明我们找到的**第一个斜率大于 $k_0[i]$ 的线段**在不断地向后移，也就是说，如果我们找到了某一个**最优决策点 $j$**，那么在下一次决策中，**最优决策点 $j'$** 必定在 $j$ 的后面。

**决策单调性**得证。

#### **【线性规划】**

画出草图：

![](http://images.cnblogs.com/cnblogs_com/Xing-Ling/1457207/o_5757575.PNG)

直线 $Line_i$ 的斜率 $k_0[i]$ 递增，

由图可知**最优决策点**在递增。

**决策单调性**得证。

#### **【其他】**

从这个角度来看的话，貌似决策单调性和 $X(j),k_0[i]$ 的单调性是相通的？

于是一个结论就出现了：如果 $X(j),k_0[i]$ 均单调不减，则该方程必定有**决策单调性**（自己瞎 $yy$ 的，不敢肯定一定正确）。

-------

## **四.【Code】**

[**【模板】** 玩具装箱 $toy$ $[P3195]$](https://www.luogu.org/problemnew/show/P3195) 

这道题 $...$ 数据太水了 $...$ 我一开始 $\text{L}$ 忘了加 $1$ 居然还过了 $...$

```cpp
#include<cstring>
#include<cstdio>
#define LL long long
#define Re register LL
const int N=5e4+5;
LL i,j,n,L,h=1,t=0,Q[N],S[N],dp[N];
//S[n]=∑C[i]+1, dp[i]=min(dp[j]+(S[i]-(S[j]+L+1))^2)，++L 
//dp[i]=S[i]^2-2*S[i]*L+dp[j]+(S[j]+L)^2-2S[i]*S[j]
//(2*S[i]) * S[j] + (dp[i]-S[i]^2+2S[i]L)=(dp[j]+(S[j]+L)^2)
//   k     *  x   +           b          =        y
inline LL min(Re a,Re b){return a<b?a:b;}
inline LL X(Re j){return S[j];}
inline LL Y(Re j){return dp[j]+(S[j]+L)*(S[j]+L);}
inline long double slope(Re i,Re j){return (long double)(Y(j)-Y(i))/(X(j)-X(i));}//记得开long double 
int main(){
    scanf("%lld%lld",&n,&L);++L; 
    for(i=1;i<=n;S[i]+=S[i-1]+1,++i)scanf("%lld",&S[i]);
    Q[++t]=0;//重中之重 
    for(i=1;i<=n;++i){
        while(h<t&&slope(Q[h],Q[h+1])<=2*S[i])++h;//至少要有两个元素 h<t。出队判断时尽量加上等号 
        dp[i]=dp[j=Q[h]]+(S[i]-S[j]-L)*(S[i]-S[j]-L);
        while(h<t&&slope(Q[t-1],Q[t])>=slope(Q[t-1],i))--t;//至少要有两个元素 h<t。入队判断时尽量加上等号 
        Q[++t]=i;
    }
    printf("%lld",dp[n]);
}
```

-------

## **五.【各种玄学问题】**

 (ノ°ο°)ノ前方高能预警 (＊°ω°＊)ノ"非战斗人员请撤离!! ＊・_・)ノ

$(1).$ 写出 $\text{dp}$ 方程后，要先判断能不能使用斜优，即是否存在 $function(i)*function(j)$ 的项或者 $\frac{Y(j)-Y(j')}{X(j)-X(j')}$ 的形式。

$(2).$ 通过大小于符号或者 $b$ 中 $dp[i]$ 的符号结合题目要求 $(\min/ \max)$ 判断是上凸包还是下凸包，不要见一个方程就直接盲猜一个下凸。

$(3).$ 当 $X(j)$ 非严格递增时，在求斜率时可能会出现 $X(j_1)=X(j_2)$ 的情况，此时最好是写成这样的形式：`return Y(j)>=Y(i)?inf:-inf`，而不要直接返回 $inf$ 或者 $-inf$，在某些题中情况较复杂，如果不小心画错了图，返回了一个错误的极值就完了，而且这种错误只用简单数据还很难查出来。

$(4).$ 注意比较 $k_0[i]$ 和 $slope(j_1,j_2)$ 要写规范，要用右边的点减去左边的点进行计算（结合 $(3)$ 来看，可防止返回错误的极值），如果用的代数法理解，写出了 `(X(j2)-X(j1))*k0<=Y(j2)-Y(j1)` 或 `(X(j2)-X(j1))*k0<=Y(j2)-Y(j1)`，而恰巧 $j_1,j_2$ 又写反了，便会出现等式两边同除了负数却没变号的情况。当然用 $k_0$ 和 $\frac {Y(j_2)-Y(j_1)}{X(j_2)-X(j_1)}$ 进行比较是没有这种问题的。

$(5).$ 队列初始化大多都要塞入一个点 $P(0)$，比如 [玩具装箱 $\text{toy}$](https://www.luogu.org/problemnew/show/P3195)，需要塞入 $P(S[0],dp[0]+(S[0]+L)^2)$ 即 $P(0,0)$，其代表的决策点为 $j=0$。

$(6).$ 手写队列的初始化是 `h=1,t=0`，由于塞了初始点导致 $t$ 加 $1$，所以在一些题解中可以看到 `h=t=1` 甚至是 `h=t=0`，`h=t=2` 之类的写法，其实是因为省去了塞初始点的代码。它们都是等价的。

$(7).$ 手写队列判断不为空的条件是 `h<=t`，而出入队判断都需要有至少 $2$ 两个元素才能进行操作。所以应是 `h<t` 。

$(8).$ 计算斜率可能会因为向下取整而出现误差，所以 $slope$ 函数最好设为 $long$ $double$ 类型。

$(9).$ 可能会有一部分的 $\text{dp}$ 初始值无法转移过来，需要手动提前弄一下，例如 [摆渡车 $\text{[P5017]}$](https://www.luogu.org/problemnew/show/P5017)。

$(10).$ 在比较两个斜率时，尽量写上等于，即 `<=` 和 `>=` 而不是 `<` 和 `>`。这样写对于去重有奇效（有重点时会导致斜率分母出锅），但不要以为这样就可以完全去重，因为要考虑的情况可能会非常复杂，所以还是推荐加上 $(3)$ 中提到的特判，确保万无一失。

-------

## **六.【关于单调性的研究】**

**划重点：注意是否具有单调性，不要盲目地使用单调队列进行维护。**

### **(1).【X(j) 单增与单减】**

将方程变为 $\frac {Y(j_2)-Y(j_1)} {X(j_2)-X(j_1)} \leqslant k_0[i]$ 或者 $\frac {Y(j_2)-Y(j_1)} {X(j_2)-X(j_1)} \geqslant k_0[i]$ 或者 $kx+b=y$ 的形式，变化要遵循之前提到的原则，尤其是 $X(j)$ 的单调性，结合图形会更好理解（目的是将单减的形式变为单增，方便维护）。

### **(2).【决策点横坐标 X(j) 不单调】**

> 注意：$X(j)$ 的单调性会影响**凸包维护**方式的选择。

**如果决策点横坐标 $X(j)$ 不存在单调性该怎么办（既不单增也不单减）？**  
（假设此时 $k_0[i]$ 仍然单调）

此时维护凸包就不能用单调队列了，因为插入点时可能会插到凸包点集中间的某个位置，而队列是不支持这种操作的，需要用到平衡树维护或者用 $\text{CDQ}$ 分治提供单调性（后面会讲到）。  
这里有计算几何基础的话会更易理解，因为上面维护图形时的删点操作与水平序 $\text{Graham}$ 扫描法求凸包是类似的，而扫描法的前提为：点集呈水平序，即点从左至右依次排列（体现为 $X(j)$ 单调不减）。

### **(3).【待决策点斜率 K0[i] 不单调】**

> 注意：$k_0[i]$ 的单调性会影响**寻找最优决策点**方式的选择。

**如果斜率 $k_0[i]$ 不存在单调性该怎么办？**  
（假设此时 $X(j)$ 仍然单调）

我们仍可以用队列维护凸包点集，但不知道每一次会在什么地方取得**最优决策点**，所以必须要保留整个凸包以确保决策有完整的选择空间，也就是说不能弹走队首，同时查找答案也不能直接取队首，只能使用二分。  
- [**【模板】** 任务安排 $3$](https://www.luogu.com.cn/problem/P5785)（可以证明该题不具有决策单调性）

### **(4).【X(j) 与 K0[i]  均不单调】**

现在来看 $k_0[i]$ 与 $X(j)$ 均不单调的情况：  

此时无法再用队列维护凸包了，但平衡树本就支持查询前驱、后继，直接把 $k_0[i]$ 丢进去询问即可。

而 $\text{CDQ}$ 就更有意思了：在 $(2)$ 中做法的基础上恰好还能再加一维偏序！  
我们直接人为地排出单调性，像普通单调队列那样维护就可以了（代码放后面）。
- [**【模板】** $\text{Building Bridges}$](https://www.luogu.com.cn/problem/P4655) 

-------

## **七.【例题】**

### **1.【预处理DP 初始值】**

- [摆渡车 $\text{[NOIP2018] [P5017]}$](https://www.luogu.org/problemnew/show/P5017)

去年 $\text{noip}$ 普及组的题（雾）。

#### **【Code】**

```cpp
#include<cstdio>
#define Re register int
const int N=4e6+105;
int i,j,n,m,h=1,t=0,T,ti,ans=2e9,G[N],S[N],Q[N],dp[N];
inline int min(Re a,Re b){return a<b?a:b;}
//                 i
//dp[i]=min(dp[j]+ ∑(i-T[k]))
//                 k=j+1
//dp[i]=dp[j]+(G[i]-G[j])*i-(S[i]-S[j])
//(i) * G[j] + (dp[i]+S[j]-i*G[i]) = (dp[j]+S[j])
// k  *  x   +          b          =      y
inline int X(Re j){return G[j];}
inline int Y(Re j){return dp[j]+S[j];}
inline long double slope(Re i,Re j){return X(i)==X(j)?(Y(j)>Y(i)?2e9:-2e9):(long double)(Y(j)-Y(i))/(long double)(X(j)-X(i));}
int main(){
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;T=-min(-T,-ti),++G[ti],S[ti]+=ti,++i)scanf("%d",&ti);
    for(i=1;i<T+m;++i)G[i]+=G[i-1],S[i]+=S[i-1];
    for(i=0;i<m;++i)dp[i]=G[i]*i-S[i];//提前处理dp初始值 
    Q[++t]=0;
    for(i=m;i<T+m;++i){
        while(h<t&&slope(Q[h],Q[h+1])<=i)++h;
        dp[i]=dp[j=Q[h]]+(G[i]-G[j])*i-S[i]+S[j];
           while(h<t&&slope(Q[t-1],Q[t])>=slope(Q[t-1],i-m+1))--t;
        Q[++t]=i-m+1;//(j+1)+m<=i
    }
    for(i=T;i<T+m;++i)ans=min(ans,dp[i]);
    printf("%d",ans);
}
```

### **2.【单调队列+二分】**

- [任务安排 $1$ $\text{[Loj10184]}$](https://loj.ac/problem/10184) [$\text{[P2365]}$](https://www.luogu.org/problemnew/show/P2365)

- [任务安排 $2$ $\text{[Loj10185]}$](https://loj.ac/problem/10185) [$\text{[Poj1180]}$](http://poj.org/problem?id=1180)

- [任务安排 $3$ $\text{[SDOI2012] [P5785]}$](https://www.luogu.com.cn/problem/P5785) [$\text{[Loj10186]}$](https://loj.ac/problem/10186) [$\text{[Bzoj2726]}$](https://www.lydsy.com/JudgeOnline/problem.php?id=2726)

**【题目描述】**

有 $N$ 个任务等待完成（顺序不得改变），这 $N$ 个任务被分成若干批，每批包含相邻的若干任务。从时刻 $0$ 开始，这些任务被分批加工，第 $i$ 个任务单独完成所需的时间是 $T_i$ 。只有一台机器，在每批任务开始前，机器需要启动时间 $S$，完成这批任务所需的时间是各个任务需要时间的总和（同一批任务将在同一时刻完成）。每个任务的费用是它的完成时刻乘以它的费用系数 $F_i$。请确定一个分组方案，使得总费用最小。

**【数据范围】**

$T1:$ $1 \leqslant N \leqslant 5000, 0 \leqslant S \leqslant 50,1 \leqslant T_i, F_i \leqslant 100$

$T2:$ $1 \leqslant N \leqslant 10000, 0 \leqslant S \leqslant 50,1 \leqslant T_i, F_i \leqslant 100$

$T3:$ $1 \leqslant N \leqslant 300000, 1 \leqslant S\leqslant 512,0 \leqslant F_i \leqslant 512,|T_i| \leqslant 512$

#### **(1).【T1】**

设 $ST[i]=\sum_{j=1}^i T[j],SF[i]=\sum_{j=1}^i F[j]$

$\text{dp}$ 方程很简单：$dp[p][i]=\min(dp[p-1][j]+(ST[i]+p\times S)(SF[i]-SF[j]))$，但是 $O(n^3)$ 的时间复杂度连 $T1$ 都过不了。

由于不知道每一次分段之前已经分了多少，所以需要用一维空间和一层循环来表示这个信息，从而知道 $S$ 需要乘以多少。

那么可以反过来，用一种名为**费用提前计算**的经典思想来进行优化（据说这个叫未来 $\text{dp}$），每分出一批任务，那么对于这之后的每一个任务都需要多出一个 $S$ 的时间，所以可以直接计算 $S$ 对后面的影响。
即：$dp[i]=\min(dp[j]+ST[i](SF[i]-SF[j])+S(SF[n]-SF[j]))$
压成了 $O(n^2)$ 后，$T1$ 就可以 $\text{AC}$ 了，但它还能继续优化。

#### **(2).【T2】**

先转化为斜率式看看？
$(S+ST[i]) * SF[j] + (dp[i]-ST[i]*SF[i]-S\times SF[i]) = (dp[j])$
其中 $k=S+ST[i],$ $x=SF[j],$ $b=dp[i]-ST[i]\times SF[i]-S\times SF[i],$ $y=dp[j]$ 。

决策点要使得 $dp[i]$ 尽量小，且 $S+ST[i]$ 和 $SF[j]$ 都严格单增，所以直接用单调队列维护一个下凸包即可。

时间复杂度为 $O(n)$ 。

**【Code】**

```cpp
#include<cstring>
#include<cstdio>
#define LL long long
#define Re register LL
const int N=1e4+5;
LL i,j,n,h=1,t=0,S,Q[N],ST[N],SF[N],dp[N];
//dp[p][i]=min(dp[p-1][j]+(ST[i]+S*p)*(SF[i]-SF[j]));
//dp[i]=dp[j]+ST[i]*(SF[i]-SF[j])+S*(SF[n]-SF[j]);
//(S+ST[i]) * SF[j] + (dp[i]-ST[i]*SF[i]-S*SF[i]) = (dp[j])
//    k     *   x   +              b              = y
inline LL min(Re a,Re b){return a<b?a:b;}
inline LL X(Re j){return SF[j];}
inline LL Y(Re j){return dp[j];}
inline long double slope(Re i,Re j){return (long double)(Y(j)-Y(i))/(X(j)-X(i));}
int main(){
    scanf("%lld%lld",&n,&S);
    for(i=1;i<=n;ST[i]+=ST[i-1],SF[i]+=SF[i-1],++i)scanf("%lld%lld",&ST[i],&SF[i]);
    Q[++t]=0;
    for(i=1;i<=n;++i){
        while(h<t&&slope(Q[h],Q[h+1])<(S+ST[i]))++h;
        dp[i]=dp[j=Q[h]]+ST[i]*(SF[i]-SF[j])+S*(SF[n]-SF[j]);
        while(h<t&&slope(Q[t-1],Q[t])>slope(Q[t-1],i))--t;
        Q[++t]=i;
    }
    printf("%lld",dp[n]);
}
```

#### **(3).【T3】**

因 $F_i$ 可等于 $0$，$X(j)$ $($ 即 $SF[i])$ 非严格递增，所以需要特判 $X(j_1)=X(j_2)$ 的情况（但仍具有单调性，可以使用队列维护凸包）。

因 $T_i$ 可小于 $0$，$k_0[i]($ 即 $S+ST[i])$ 无单调性，所以不具有决策单调性，可以用四边形不等式进行证明：

该 $\text{dp}$ 方程显然为 $dp[i]=dp[j]+w(i,j)$ 的形式，其中 $w(i,j)=ST[i](SF[i]-SF[j])+S(SF[n]-SF[j])$ 。  

$\text{证明：}$ $\text{设}$ $Q=S(SF[n]-SF[j])$  

$\therefore w(i,j)=ST[i](SF[i]-SF[j])+Q$  

$\begin{aligned}
\therefore w(i+1,j+1)=&ST[i+1]SF[i+1]-ST[i+1]SF[j+1]+S(SF[n]-SF[j+1])\\
                              =&ST[i+1]SF[i+1]-SF[j+1]*(ST[i]+T[i+1])+Q-S\times F[j+1]\\
\end{aligned}$  

$\begin{aligned}
w(i,j+1)=&ST[i](SF[i]-SF[j+1])+Q-S\times F[j+1]\\
           =&ST[i]SF[i]-ST[i]SF[j+1]+Q-S\times F[j+1]\\
\end{aligned}$  

$\begin{aligned}
w(i+1,j)=&ST[i+1](SF[i+1]-SF[j])+Q\\
           =&ST[i+1]SF[i+1]-ST[i+1]SF[j]+Q\\
           =&ST[i+1]SF[i+1]-ST[i]SF[j]-T[i+1]SF[j]+Q
\end{aligned}$  

$\therefore w(i,j)+w(i+1,j+1)=ST[i](SF[i]-SF[j])+ST[i+1]SF[i+1]-SF[j+1](ST[i]+T[i+1])+2Q-S\times F[j+1]$  

$\therefore w(i+1,j)+w(i,j+1)=ST[i]SF[i]-ST[i]SF[j+1]+ST[i+1]SF[i+1]-ST[i]SF[j]-T[i+1]SF[j]+2Q-S\times F[j+1]$  

$\therefore w(i,j)+w(i+1,j+1)-w(i+1,j)+w(i,j+1)=-F[j+1]*T[i+1]$  
$\text{又} \because 0 \leqslant F_i \leqslant 512,-512 \leqslant T_i \leqslant 512$  

$\therefore \text{当} T_i \leqslant 0 \text{时},w(i,j)+w(i+1,j+1) \geqslant w(i+1,j)+w(i,j+1)$  

$\text{当} T_i \geqslant 0 \text{时},w(i,j)+w(i+1,j+1) \leqslant w(i+1,j)+w(i,j+1)$

四边形不等式不一定成立，所以此题不具有决策单调性。  
证毕。

此时需要在队列中二分查找最优决策点。

时间复杂度为 $O(n\log n)$ 。

**【Code】**

```cpp
#include<cstring>
#include<cstdio>
#define LL long long
#define Re register LL
const int N=3e5+5;
LL i,j,n,h=1,t=0,S,Q[N],ST[N],SF[N],dp[N];
//dp[p][i]=min(dp[p-1][j]+(ST[i]+S*p)*(SF[i]-SF[j]));
//dp[i]=dp[j]+ST[i]*(SF[i]-SF[j])+S*(SF[n]-SF[j]);
//(S+ST[i]) * SF[j] + (dp[i]-ST[i]*SF[i]-S*SF[i]) = (dp[j])
//    k     *   x   +              b              = y
//ti可小于0，所以ST[i]非递增，只可二分
//fi可等于0，所以SF[i](X)非严格递增，因此需要特判X(i)==X(j)的情况
inline LL min(Re a,Re b){return a<b?a:b;}
inline LL X(Re j){return SF[j];}
inline LL Y(Re j){return dp[j];}
inline long double slope(Re i,Re j){return X(j)==X(i)?(Y(j)>=Y(i)?1e18:-1e18):(long double)(Y(j)-Y(i))/(X(j)-X(i));
}//由于需要二分查找，多了一些限制：队列里不能有在同一位置的点,返回inf还是-inf都影响着是否删除重点，平时不可不管，二分必须注意返回值
inline LL sakura(Re k){
    if(h==t)return Q[h];
    Re l=h,r=t;
    while(l<r){
        Re mid=l+r>>1,i=Q[mid],j=Q[mid+1];
        if(slope(i,j)<k)l=mid+1;
//      if( (Y(j) - Y(i)) < k * (X(j) - X(i)) )l=mid+1;//注意是(j)-(i)因为Q[mid+1]>Q[mid]s即j>i即SF[j]>SF[i]即X(j)>X(i)，如果是(i)-(j)的话乘过去要变号
        else r=mid;
    }
    return Q[l];
}
int main(){
    scanf("%lld%lld",&n,&S);
    for(i=1;i<=n;ST[i]+=ST[i-1],SF[i]+=SF[i-1],++i)scanf("%lld%lld",&ST[i],&SF[i]);
    Q[++t]=0;
    for(i=1;i<=n;++i){
        j=sakura(S+ST[i]);
        dp[i]=dp[j]+ST[i]*(SF[i]-SF[j])+S*(SF[n]-SF[j]);
        while(h<t&&slope(Q[t-1],Q[t])>=slope(Q[t-1],i))--t;//此处取等号作用出现，如果不取等，会WA第12个点
        Q[++t]=i;
    }
    printf("%lld",dp[n]);
}
```

### **3.【CDQ/平衡树】**

因为暂时没找到 $X(j)$ 不单调、$k_0[i]$ 单调的例题，这里直接讲两者均不单调的情况。

- [$\text{Building Bridges [CEOI2017] [P4655]}$](https://www.luogu.com.cn/problem/P4655)

如果学习了动态凸包算法，会发现这其实就是套了个板子上去（平衡树代码较毒瘤就不放了）。

$\text{CDQ}$ 做法也比较显然，但因为递归过程不好描述，直接看代码注释吧。

时间复杂度为 $O(n\log n)$。

#### **【Code】**

```cpp
#include<algorithm>
#include<cstring>
#include<cstdio>
#define LD long double
#define LL long long
#define Re register int
#define S2(a) (1ll*(a)*(a))
using namespace std;
const LL N=1e5+3,inf=1e18;
int n,H[N],W[N],Q[N];LL S[N],dp[N];
inline void in(Re &x){
    int f=0;x=0;char c=getchar();
    while(c<'0'||c>'9')f|=c=='-',c=getchar();
    while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=getchar();
    x=f?-x:x;
}
//dp[i]=min(dp[i],dp[j]+(H[i]-H[j])*(H[i]-H[j])+S[i-1]-S[j]);
//dp[i]=dp[j]-2*H[i]*H[j]+H[j]*H[j]+H[i]*H[i]+S[i-1]-S[j]
//(2*H[i]) * H[j] + (dp[i]-S[i-1]-H[i]*H[i]) = (dp[j]+H[j]*H[j]-S[j])
//   k     *  x   +            b             =          y
#define X(j) (a[j].x)
#define Y(j) (a[j].y)
struct QAQ{
    int k,x,id;LL y;
    inline bool operator<(const QAQ &O)const{return x!=O.x?x<O.x:y<O.y;}
}a[N],b[N];
inline bool cmp(QAQ A,QAQ B){return A.k<B.k;}
inline LD slope(Re i,Re j){return X(i)==X(j)?(Y(j)>Y(i)?inf:-inf):(LD)(Y(j)-Y(i))/(X(j)-X(i));}
inline void CDQ(Re L,Re R){
    if(L==R){Re j=a[L].id;a[L].y=dp[j]+(LL)H[j]*H[j]-S[j];return;}//此时dp[j]必定已经求出来了，直接算计Y(j)即可
    Re mid=L+R>>1,p1=L,p2=mid+1,h=1,t=0;
    for(Re i=L;i<=R;++i)a[i].id<=mid?b[p1++]=a[i]:b[p2++]=a[i];//按照i的大小分到左右两边（两边的k0[i]分别递增）
    for(Re i=L;i<=R;++i)a[i]=b[i];
    CDQ(L,mid);//处理完左边后，左边的X(j)是递增的，此时右边还没处理，所以右边k0[i]是递增的
    for(Re i=L;i<=mid;++i){//把左边的点拿出来维护凸包（使用单调队列）
        while(h<t&&slope(Q[t-1],Q[t])>=slope(Q[t-1],i))--t;
        Q[++t]=i;
    }
    for(Re i=mid+1,j,id;i<=R;++i){//把右边的点拿来决策（依旧是单调队列）
        while(h<t&&slope(Q[h],Q[h+1])<=a[i].k)++h;
        if(h<=t)id=a[i].id,j=Q[h],dp[id]=min(dp[id],a[j].y-(LL)a[i].k*a[j].x+S[id-1]+(LL)H[id]*H[id]);
    }
    CDQ(mid+1,R);//处理完右边后，两边都按照X(j)排好了序
    Re w=L-1;p1=L,p2=mid+1;//把两边按照X(j)从小到大归并起来
    while(p1<=mid&&p2<=R)b[++w]=a[p1]<a[p2]?a[p1++]:a[p2++];
    while(p1<=mid)b[++w]=a[p1++];while(p2<=R)b[++w]=a[p2++];
    for(Re i=L;i<=R;++i)a[i]=b[i];
}
int main(){
//    freopen("123.txt","r",stdin);
    in(n);
    for(Re i=1;i<=n;++i)in(H[i]);
    for(Re i=1;i<=n;++i)in(W[i]);
    for(Re i=1;i<=n;++i)S[i]=S[i-1]+W[i],dp[i]=inf;
    for(Re i=1;i<=n;++i)a[i].k=(H[i]<<1),a[i].x=H[i],a[i].id=i;
    sort(a+1,a+n+1,cmp);//先按k0[i]排序
    dp[1]=0,CDQ(1,n);//注意左边界上的点要单独求
    printf("%lld\n",dp[n]);
}
```

### **4.【题目链接】**

- [玩具装箱 $\text{toy [HNOI2008] [P3195]}$](https://www.luogu.org/problemnew/show/P3195)

- [土地征用 $\text{Land Acquisition G [P2900]}$](https://www.luogu.org/problemnew/show/P2900)

- [征途 $\text{[SDOI2016] [P4072]}$](https://www.luogu.org/problemnew/show/P4072)

- [$\text{Cats Transport}$](https://www.luogu.com.cn/problem/CF311B) [$\text{[CF311B]}$](http://codeforces.com/problemset/problem/311/B)

- [摆渡车 $\text{[NOIP2018] [P5017]}$](https://www.luogu.org/problemnew/show/P5017)

- [仓库建设 $\text{[ZJOI2007] [P2120]}$](https://www.luogu.com.cn/problem/P2120)

- [序列分割 $\text{[APIO2014] [P3648]}$](https://www.luogu.com.cn/problem/P3648)

- [任务安排 $2$ $\text{[Loj10185]}$](https://loj.ac/problem/10185) [$\text{[Poj1180]}$](http://poj.org/problem?id=1180)

- [锯木厂选址 $\text{[CEOI2004] [P4360]}$](https://www.luogu.com.cn/problem/P4360)

- [特别行动队 $\text{[APIO2010] [P3628]}$](https://www.luogu.com.cn/problem/P3628)

- [国王饮水记 $\text{[NOI2016] [P1721]}$](https://www.luogu.org/problemnew/show/P1721)

（以此处为分界线，上面都是 $X(j)$ 与 $k_0[i]$ 均单调的例子）

- [任务安排 $3$ $\text{[SDOI2012] [P5785]}$](https://www.luogu.com.cn/problem/P5785) [$\text{[Loj10186]}$](https://loj.ac/problem/10186) [$\text{[Bzoj2726]}$](https://www.lydsy.com/JudgeOnline/problem.php?id=2726)（$X(j)$ 单调 $k_0[i]$ 不单调）

- [高速公路 $\text{[P3994]}$](https://www.luogu.com.cn/problem/P3994)（$X(j)$ 单调 $k_0[i]$ 不单调。树上转移）

- [购票 $\text{[NOI2014] [P2305]}$](https://www.luogu.org/problemnew/show/P2305)（$X(j)$ 单调 $k_0[i]$ 不单调。树上转移）

- [$\text{Building Bridges [CEOI2017] [P4655]}$](https://www.luogu.com.cn/problem/P4655)（$X(j)$ 与 $k_0[i]$ 均不单调）

- [货币兑换 $\text{[NOI2007] [P4027]}$](https://www.luogu.com.cn/problem/P4027)（$X(j)$ 与 $k_0[i]$ 均不单调）

--------

## **【参考资料】**

（本文部分内容摘自以下文章）

- [凸包—百度百科](https://baike.baidu.com/item/%E5%87%B8%E5%8C%85/179150?fr=aladdin)

- [$\text{DP}$ 的各种优化](https://www.cnblogs.com/flashhu/p/9480669.html)

- [斜率优化学习笔记](https://www.cnblogs.com/MashiroSky/p/6009685.html)

- [斜率优化及其变形](https://www.cnblogs.com/Parsnip/p/10832015.html)

- [斜率优化 $\text{DP}$ 及总结](https://blog.csdn.net/weixin_34402408/article/details/94027981)

- [题解 $P3195$—$xyz32768$](https://www.luogu.org/blog/user29936/solution-p3195)

- [『任务安排 斜率优化及其变形』](https://www.cnblogs.com/Parsnip/p/10832015.html)

---

## 作者：hhz6830975 (赞：415)

这是一道经典的斜率优化入门题，就用这题来作个总结好了

前言：斜率优化的思想其实和高中数学的线性规划有相似之处，因此建议没学过的同学先了解一下线性规划


首先提一下单调队列优化：

当dp方程为$dp[i]=a[i]+b[j]$时，这个方程是$O(n^2)$的

这时用单调队列可以将其优化为$O(n)$，具体方法这里不再赘述

而dp方程为$dp[i]=a[i] \cdot b[j]+c[i]+d[j]$时，由于存在$a[i] \cdot b[j]$这个既有$i$又有$j$的项，以上方法就不适用了，这时就需要使用斜率优化

回到本题，设前缀和为$sum[i]$，由题意易得dp方程：

$$dp[i]=min(dp[j]+(sum[i]+i-sum[j]-j-L-1)^2)  (j<i)$$

但这个方程是$O(n^2)$的，显然不满足要求，因此需要进行优化

（以下称两点斜率为$slope(A,B)$）

令$a[i]=sum[i]+i$，$b[i]=sum[i]+i+L+1$（这一步是为了简化计算）

则
$$dp[i]=dp[j]+(a[i]-b[j])^2$$

展开得

$$dp[i]=dp[j]+a[i]^2-2 \cdot a[i] \cdot b[j]+b[j]^2$$

移项得

$$2 \cdot a[i] \cdot b[j]+dp[i]-a[i]^2=dp[j]+b[j]^2$$

将$b[j]$看作$x$，$dp[j]+b[j]^2$看作$y$，这个式子就可以看作一条斜率为$2 \cdot a[i]$的直线

而对于每个$i$来说，$a[i]$都是确定的

接下来的步骤和线性规划很相似

$dp[i]$的含义转化为：当上述直线过点$P(b[j],dp[j]+b[j]^2)$时，直线在$y$轴的截距加上$a[i]^2$（一个定值）

而题目即为找这个截距的最小值

因此，类似线性规划，我们将这条直线从下往上平移，直到过一个符合要求的点时停下，此时截距即为最小

画出图像如下（红色为目标直线）

 ![](https://cdn.luogu.com.cn/upload/pic/13267.png) 

结合图像分析可知，本题中可能为最优的$P$点（图中用直线连接）组成了一个下凸包（其他题目可能不同，结合图像具体分析）

显然，凸包中相邻两点斜率是单调递增的

而目标直线的斜率$2 \cdot a[i]$也是单调递增的

由图像又易知，满足条件的最优$P_j$为第一个$slope(P_j,P_{j+1}) > 2 \cdot a[i]$的点

因此，我们用单调队列维护这个凸包：

设队首为$head$，队尾为$tail$

1. 对队首：

$$while(slope(P_{head},P_{head+1})<2 \cdot a[i])\quad  head++$$

2. 此时队首的点即为最优，根据它计算出$dp[i]$

3. 对队尾：

$$while(slope(P_{tail-1},P_{tail})>slope(P_{tail-1},P_i)\quad tail--$$

4. 在队尾插入$P_i$

解释：

若$slope(P_j,P_{j+1})<2 \cdot a[i]$，显然$P_j$不是最优通过步骤1删去

因为目标直线斜率单调递增，所以当前删去的$P_j$一定对之后的$dp[i]$也不是最优，不会造成影响

而操作3的理由如下：

 ![](https://cdn.luogu.com.cn/upload/pic/13443.png) 

图中红色的点为$P_i$

显然，满足操作3的要求时，$P_{tail}$在凸包内部，一定不是最优，因此可以删去

以上即为本题算法

要注意，初始化时要加入单调队列的点为$P_0$而不是$P_1$（否则就变成了第一个物品必须单独装）


代码：



```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
typedef double db;
typedef long long LL;
const int maxn=50010;
int n,L;
db sum[maxn],dp[maxn];
int head,tail,Q[maxn];
inline db a(int i){return sum[i]+i;}
inline db b(int i){return a(i)+L+1;}
inline db X(int i){return b(i);}
inline db Y(int i){return dp[i]+b(i)*b(i);}
inline db slope(int i,int j){return (Y(i)-Y(j))/(X(i)-X(j));}
int main(){
    scanf("%d%d",&n,&L);
    for(int i=1;i<=n;i++){
        scanf("%lf",&sum[i]);
        sum[i]+=sum[i-1];
    }
    head=tail=1;
    for(int i=1;i<=n;i++){
        while(head<tail&&slope(Q[head],Q[head+1])<2*a(i)) ++head;
        dp[i]=dp[Q[head]]+(a(i)-b(Q[head]))*(a(i)-b(Q[head]));
        while(head<tail&&slope(i,Q[tail-1])<slope(Q[tail-1],Q[tail])) --tail;
        Q[++tail]=i;
    }
    printf("%lld\n",(LL)dp[n]);
    return 0;
}

```

---

## 作者：lcjqwq (赞：133)

**斜率优化动态规划**可以用来解决这道题。同时这也是一道经典的斜率优化基础题。

**分析**：明显是动态规划。令$dp[i]$为前$i$个装箱的最小花费。
转移方程如下：
$$dp[i]=\min\limits_{0 \leq j < i} \{ dp[j]+( \sum \limits_{k = j + 1}^{i}{C_k} + i - j - 1 - L) ^ 2\}$$

用$sum[i]$表示前$i$个容器的长度之和（即$C$的前缀和），方程简化为：
$$dp[i]=\min\limits_{0 \leq j < i} \{ dp[j]+( sum[i]-sum[j] + i - j - 1 - L) ^ 2\}$$

又令$f[i]$为$sum[i]+i$，继续简化方程为：
$$dp[i]=\min\limits_{0 \leq j < i} \{ dp[j]+( f[i]-f[j] - 1 - L) ^ 2\}$$

暴力dp是$O(n^2)$，考虑优化。如何优化，就是用前面所提到的**斜率优化**。这玩意到底是什么？我们先来继续对状态转移方程进行进一步的推导。

对于每个$dp[i]$可以知道都是由一个$j0$推过来的。这个$j0$对于当前的$i$是最优的决策。假设现在有两个决策$j_1,j_2 (1 \leq j_1 < j_2 < i)$，且决策$j_2$优于$j_1$，则有：
$$dp[j_1]+( f[i]-f[j_1] - 1 - L) ^ 2 \geq dp[j_2]+( f[i]-f[j_2] - 1 - L) ^ 2$$

拆开可得：
$$dp[j_1]+f[i]^2-2f[i](f[j_1]+1+L)+(f[j_1]+L+1)^2 \geq dp[j_2]+f[i]^2-2f[i](f[j_2]+1+L)+(f[j_2]+L+1)^2$$

化简可得：
$$2f[i](f[j_2] + 1 + L)-2f[i](f[j_1] + 1 + L) \geq dp[j_2]+(f[j_2]+1+L)^2 - (dp[j_1]+(f[j_1]+1+L)^2)$$

即：
$$2f[i] \geq \frac{dp[j_2]+(f[j_2]+1+L)^2 - (dp[j_1]+(f[j_1]+1+L)^2)}{f[j_2]-f[j_1]}$$
令$g[i] = (f[i]+L+1)^2$，可得：
$$2f[i] \geq \frac{dp[j_2]+g[j_2] - (dp[j_1]+g[j_1])}{f[j_2]-f[j_1]}$$

也就是说，若$j1,j2$满足上面这个式子，那么$j2$一定比$j1$优。

为什么叫斜率优化？因为上面这个式子可以把看作$dp[i]+g[i]$看做纵坐标，$f[i]$看做横坐标，上面的等式右侧就相当于$\frac{\Delta y}{\Delta x}=k$也就是一个一次函数的斜率。当这个斜率$k \leq 2f[i]$则$j_2$优于$j_1$。

假如我们有三个决策$j_1,j_2,j_3$（如下图）
![](https://cdn.luogu.com.cn/upload/pic/20775.png)

容易证明：$j_2$不可能是最优的。
这样一来，每两个决策间的斜率便是**单调上升的**。

所以有两种做法：
- 对于$dp[i]$，有了斜率单调上升这个条件，就可以去二分最优的决策点（也就是斜率小于$2f[i]$的）。复杂度$O(n \log n)$。
- 又因为$f[i]$是单调递增的，可以用单调队列来维护。具体实现就是，把决策放进一个单调队列里，如果队首和当前的$i$间的斜率 $<f[i]$，就把队首删掉（即h++）。对于队尾，就每次把加入$i$后不满足斜率单调上升的队尾全部删掉（即t--），最后把$i$放进单调队列就好了。

注意事项：
**long long**.
**还有 $g[0]=(L + 1) ^ 2 $而不是$0$!!!!**~~（因为这个我调了很久）~~

给一下单调队列做法的代码：
```cpp
#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <algorithm>

using namespace std;

#define int long long
const int MAXN = 50050;
int N, L, dp[MAXN], sum[MAXN], f[MAXN], g[MAXN], h, t, Q[MAXN];

inline double xie(int j1, int j2)
{
	return (double) (dp[j2] + g[j2] - dp[j1] - g[j1]) / (f[j2] - f[j1]);
}
#undef int
int main()
{
    scanf("%d%d", &N, &L);
    for(int i = 1; i <= N; i++)
    {
    	scanf("%d", &sum[i]);
    	sum[i] += sum[i - 1];
    	f[i] = sum[i] + i;
    	g[i] = (f[i] + L + 1) * (f[i] + L + 1);
	}
	g[0] = (L + 1) * (L + 1); //important!!!
	for(int i = 1; i <= N; i++)
	{
		while(h < t && xie(Q[h], Q[h + 1]) <= 2 * f[i]) h++;
		dp[i] = dp[Q[h]] + (f[i] - f[Q[h]] - L - 1) * (f[i] - f[Q[h]] - L - 1); //更新dp值
		while(h < t && xie(Q[t], i) < xie(Q[t - 1], Q[t])) t--;
		Q[++t] = i;
		
	}
	printf("%lld\n", dp[N]);
 	return 1；//防抄
}

```


---

## 作者：xyz32768 (赞：62)

容易推出，如果玩具长度的前缀和为$sum[]$，那么$DP$方程为：

$f[i]=min{0<=j<i,f[j]+(i-j-1-L+sum[i]-sum[j])^2}$。

解法一：决策单调性。

可以看出原方程是一个$f[i]=min{0<=j<i,f[j]+w(i,j)}$的模型，其中$w(i,j)=(i-j-1-L+sum[i]-sum[j])^2$。

设$X=i-j-1-L+sum[i]-sum[j]$，则：

$w(i+1,j+1)=(X+c[i+1]-c[j+1])^2$

$w(i+1,j)=(X+c[i+1]+1)^2$

$w(i,j+1)=(X-c[j+1]-1)^2$

此时$w(i,j)+w(i+1,j+1)=2X^2+2c[i+1]X-2c[j+1]X+c[i+1]^2-2c[i+1]c[j+1]+c[j+1]^2$

$w(i+1,j)+w(i,j+1)=2X^2+2c[i+1]X-2c[j+1]X+c[i+1]^2+2c[i+1]+2c[j+1]+c[j+1]^2+2$

可得$w(i,j)+w(i+1,j+1)<=w(i+1,j)+w(i,j+1)$，即满足决策单调性。

决策单调性实现即，用一个栈维护每个决策的起始和结束位置。对于每个已经计算出来的$f[i]$，去寻找它能更新的状态有哪些。

具体为：

（1）在栈顶的决策起始位置判断起始位置是否决策$i$更优。如果是，则退栈，继续执行（1）。否则转（2）。

（2）二分查找在栈顶的决策区间里，决策$i$最优的最左位置$pos$，把栈顶的决策结束位置设为$pos-1$，并把决策$i$压入栈，决策起始位置为$pos$，结束位置为$n$（但是如果$pos>n$就不要入栈，我就在这里调了好久）。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
typedef long long ll;
const int N = 5e4 + 5;
int n, L, c[N], top; ll sm[N], f[N];
struct cyx {
    int l, r, x;
    cyx() {}
    cyx(int _l, int _r, int _x) :
        l(_l), r(_r), x(_x) {}
} stk[N];
ll w(int i, int j) {
    ll res = sm[j] - sm[i] - L;
    res += j - i - 1; return res * res;
}
int findx(int i) {
    int l = stk[top].l, r = stk[top].r, mid;
    while (l <= r) { // 二分查找新决策的起始位置
        mid = l + r >> 1;
        if (f[i] + w(i, mid) < f[stk[top].x] + w(stk[top].x, mid))
            r = mid - 1;
        else l = mid + 1;
    }
    return l;
}
int main() {
    int i, now = 1; n = read(); L = read();
    for (i = 1; i <= n; i++) c[i] = read(),
        sm[i] = sm[i - 1] + c[i];
    stk[top = 1] = cyx(1, n, 0);
    for (i = 1; i <= n; i++) {
        f[i] = f[stk[now].x] + w(stk[now].x, i);
        while (i < stk[top].l && f[i] + w(i, stk[top].l) < f[stk[top].x] +
            w(stk[top].x, stk[top].l)) top--;
        int u = findx(i); stk[top].r = u - 1;
        if (u <= n) stk[++top] = cyx(u, n, i);
        if (i == stk[now].r) now++;
    }
    cout << f[n] << endl;
    return 0;
}
```
时间复杂度$O(nlogn)$。


解法二：斜率优化。

可以发现原方程为

$f[i]=min{0<=j<i,f[j]+((i+sum[i]-L-1)-(sum[j]+j))^2}$

设$a[i]=i+sum[i]-L-1$，$b[j]=sum[j]+j$，

则$f[i]=min{0<=j<i,f[j]+(a[i]-b[j])^2}$

即$f[i]=min{0<=j<i,f[j]+b[j]^2-2a[i]b[j]}+a[i]^2$

再设$X[j]=b[j]$，$Y[j]=f[j]+b[j]^2$，

则可以发现$a[]$和$X[]$都单调递增，所以斜率是单调递减的。用单调队列维护凸壳，每次从队首不断出队以找出最优决策。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
typedef long long ll;
const int N = 5e4 + 5;
int n, H, T, L, que[N];
ll f[N], a[N], b[N], X[N], Y[N];
bool check(int p1, int p2, int p3) {
    return (X[p2] - X[p3]) * (Y[p1] - Y[p3]) - (X[p1] - X[p3])
        * (Y[p2] - Y[p3]) >= 0; // 根据叉积判断p1p2的斜率是否大于p2p3的斜率
}
ll calc(int x, int y) {
    return f[x] + b[x] * b[x] - 2ll * a[y] * b[x];
}
int main() {
    int i; n = read(); L = read(); H = T = 1;
    for (i = 1; i <= n; i++) {
        b[i] = b[i - 1] + read() + 1;
        a[i] = b[i] - L - 1;
    }
    for (i = 1; i <= n; i++) {
        while (H < T && calc(que[H], i) >= calc(que[H + 1], i)) H++;
        f[i] = calc(que[H], i) + a[i] * a[i];
        X[i] = b[i]; Y[i] = f[i] + b[i] * b[i];
        while (H < T && check(que[T - 1], que[T], i)) T--;
        que[++T] = i;
    }
    cout << f[n] << endl;
    return 0;
}
```
时间复杂度$O(n)$。


---

## 作者：Siyuan (赞：24)

[$$\Large\texttt{My Blog}$$](https://hydingsy.github.io/)

---

## Description

> 题目链接：[Luogu 3195](https://www.luogu.org/problemnew/show/P3195)

P 教授要去看奥运，但是他舍不得他的玩具，于是他决定把所有的玩具运到北京。

他使用自己的压缩器进行压缩。这个压缩器可以将任意物品变成一维，再放到一种特殊的一维容器中。P 教授有编号为 $1\dots n$ 的 $n$ 件玩具，玩具经过压缩后会变成一维，第 $i$ 件件玩具压缩后长度为 $C_i$。

为了方便整理，P 教授要求：

- 在一个一维容器中，玩具的编号是连续的；
- 如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物。形式地说，如果要将 $i$ 号玩具到 $j$ 号玩具放到同一个容器中，则容器长度不小于 $x=j-i+\sum_{k=i}^{j}C_k$。

制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为 $x$，其制作费用为 $(x-L)^2$，其中 $L$ 是一个常量。

P 教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过 $L$。试求最小费用。

数据范围：$1\le n\le 5\times 10^4$，$1\le L,C_i\le 10^7$

------

## Solution

这题可以说是**斜率优化**的入门题了吧（关于斜率优化的分析实现，请参见我的另一篇博客[「算法笔记」斜率优化](https://hydingsy.github.io/articles/algorithm-Slope-Optimization/)）。我们首先考虑朴素的动态规划，定义 $f_i$ 表示考虑到第 $i$ 个玩具的最小费用，记 $sum_i=\sum_{k=1}^i C_k$。转移方程为：

$$f_i=\min\{f_j+(i-j-1+sum_i-sum_j-L)^2\}\quad (0\le j<i)$$

我们发现这里有一个平方项，所以可以考虑斜率优化。

为了表述方便，我们记 $x_i=sum_i+i$，$y_i=sum_i+i+1+L$，那么转移方程可以变形为：

$$f_i=\min\{f_j+(x_i-y_j)^2\}\quad (0\le j<i)$$

我们任取 $j,k$ 满足 $0\le k<j<i$，当 $j$ 比 $k$ 要**更好**时，满足：

$$\begin{aligned}f_j+(x_i-y_j)^2&\le f_k+(x_i-y_k)^2 \\f_j-2\cdot x_i\cdot y_j+y_j^2&\le f_k-2\cdot x_i\cdot y_k+y_k^2 \\(f_j+y_j^2)-(f_k+y_k^2)&\le 2\cdot x_i(y_j-y_k)\end{aligned}$$

由于 $C_i>0$ 因此 $y_i$ 的值是递增的，可以直接除以 $y_j-y_k$ 得到：

$$2\cdot x_i\ge \frac{(f_j+y_j^2)-(f_k+y_k^2)}{y_j-y_k}$$
很显然这已经是一个可以斜率优化的东西了，直接套斜率优化板子即可！

**注意**：此处 $x_0=0$，$y_0=1+L$，这两个值必须要初始化！

**时间复杂度**：$O(n)$

------

## Code

```cpp
#include <cstdio>
#include <algorithm>

const int N=5e4+5;
int n,L,c[N],q[N];
long long sum[N],x[N],y[N],f[N];

long long sqr(long long x) {
    return x*x;
}
double slope(int i,int j) {
    return 1.0*((f[i]+sqr(y[i]))-(f[j]+sqr(y[j])))/(y[i]-y[j]);
}
int main() {
    scanf("%d%d",&n,&L);
    x[0]=0,y[0]=1+L;
    for(int i=1;i<=n;++i) {
        scanf("%d",&c[i]);
        sum[i]=sum[i-1]+c[i],x[i]=sum[i]+i,y[i]=sum[i]+i+1+L;
    }
    int l=1,r=0;
    f[0]=q[++r]=0;
    for(int i=1;i<=n;++i) {
        while(l<r&&slope(q[l],q[l+1])<=2*x[i]) ++l;
        f[i]=f[q[l]]+sqr(x[i]-y[q[l]]);
        while(l<r&&slope(q[r-1],q[r])>=slope(q[r],i)) --r;
        q[++r]=i;
    }
    printf("%lld\n",f[n]);
    return 0;
}
```



---

## 作者：League丶翎 (赞：20)

顺手安利一波博客->[Chlience](http://blog.csdn.net/Force_CHL)

欢迎dalao交换友链


### 分析：

状态转移方程：（显然）

$dp[i]=min(dp[j]+(sum[i]-sum[j]+i-j-1-L)^2)$

$sum$为前缀和

然后我们令$f[i]=sum[i]+i,c=1+L$

原式可以化简为：

$dp[i]=min(dp[j]+(f[i]-f[j]-c)^2)$

注意，这里的$f,c$都是可以预处理出来的

#### 1.证明决策单调性

假设在当前由$j$状态转移优于$k$状态（显然$k$是之前枚举的决策），即：

$dp[j]+(f[i]-f[j]-c)^2\le dp[k]+(f[i]-f[j]-c)^2$

那么对于$i$后面的一个状态$t$，要保证$k$对其无贡献（已经被$j$覆盖）

则需要证明：

$dp[j]+(f[t]-f[j]-c)^2\le dp[k]+(f[t]-f[k]-c)^2$

由于$f[i]=sum[i]+i$，所以一定为单调递增的（$sum$和$i$均为单调递增）

所以令$v=f[t]-f[i]$

原式可化为：

$dp[j]+(f[i]+v-f[j]-c)^2\le dp[k]+(f[i]+v-f[k]-c)^2$

变形↓尽量拆出已有的式子

$dp[j]+(f[i]-f[j]-c)^2+2v*(f[i]-f[j]-c)+4v^2\le dp[k]+(f[i]-f[k]-c)^2+2v*(f[i]-f[k]-c)+4v^2$

移项，消除相同项

$f[i]-f[j]-c\le f[i]-f[k]-c$

$f[j]\ge f[k]$

由单调递增性，只需要枚举状态时以$1$~$i-1$的顺序即可保证$f[j]\ge f[k]$，得证

#### 2.求斜率方程

当前决策$i$，若由$j$状态转移优于$k$状态，则有：

$dp[j]+(f[i]-f[j]-c)^2\le dp[k]+(f[i]-f[j]-c)^2$

展开，变形，得：

$dp[j]+f[i]^2-2f[i]* (f[j]+c)+(f[j]+c)^2\le dp[k]+f[i]^2-2f[i]* (f[k]+c)+(f[k]+c)^2$

移项，消除相同项，尽量将变量按$j,k$凑在一起，得：

$\frac {(dp[j]+(f[j]+c)^2)-(dp[k]+(f[k]+c)^2)}{2*(f[j]-f[k])}\le f[i]$

左边部分就像斜率一样，可以看做：

$\frac {Y_j-Y_k} {X_j-X_k}$

我们以$Slope(x,y)$来表示上面那个类似于斜率的东西（其实就是斜率好么）

若满足这个$Slope(k,j)\le f[i]$，则说明$j$比$k$优

#### 3.组织算法

那么对于当前较优的状态我们建立一个队列$q$

维护这个队列我们有以下操作：

> 1.若$Slope(q[l],q[l+1])\le f[i] $，则$q[l]$没有$q[l+1]$优，则删除$q[l]$
> 2.若$Slope(q[r-1],q[r])\ge Slope(q[r],i)$,则删除$q[r]$




**分析：**


方程成立时是$j$比$k$优的充分必要条件，那么假设我们现在有一个序列，那么队头就是当前最优的，若到了某个$i$值使得对于队首$p[l]$和队次首$p[l+1]$来说$Slope(q[l],q[l+1])\le f[i]$成立，则$q[l+1]$比$q[l]$优，所以弹出队首，直到不成立为止


第一条操作是显然的，那么第二条呢？

一个状态要不要放在序列里，是由它能不能做出贡献决定的，也就是说，它能不能成为队首决定的

假设我们现在有$Slope(q[a],q[a+1])\ge Slope(q[a+1],q[a+2])$，那么，$q[a+1]$点想要成为队首就只能当前面的点都弹出了，并且$Slope(q[a],q[a+1])\le f[i]$，$q[a+1]$比$q[a]$优所以也将$q[a]$弹出时，才能成为队首。但是在这时，由于$f[i]\ge Slope(q[a],q[a+1])\ge Slope(q[a+1],q[a+2])$，那么$q[a+2]$也应该比$q[a+1]$优，所以将$q[a+1]$弹出，意思就是，无论怎样，$q[a+1]$都不可能做出贡献

类比一下，我们只操作队尾时，若其斜率$Slope(q[r-1],q[r])\ge Slope(q[r],i)$，直接弹出$q[r]$即可

那么，在我们的这个操作以后，能够保证斜率单调递增，也就是维护一个上凸包，这就是斜率优化啦！


自认为非常的详细啦，有问题可以在下面留言喽！


**Code：**

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
ll n,L;
ll f[50005];
ll dp[50005];
ll q[50005];
ll head,tail; 
ll read() {
    ll ans=0,flag=1;
    char ch=getchar();
    while((ch<'0'||ch>'9') && ch!='-') ch=getchar();
    if(ch=='-') flag=-1,ch=getchar();
    while(ch>='0' && ch<='9') ans=ans*10+ch-'0',ch=getchar();
    return ans*flag;
}
double slope(ll k,ll j) {return (double) (dp[j]-dp[k]+(f[j]+L)*(f[j]+L)-(f[k]+L)*(f[k]+L))/(2.0*(f[j]-f[k]));}
int main() {
    n=read(),L=read();
    L++;
    for(int i=1;i<=n;i++) {
        ll a=read();
        f[i]=f[i-1]+a+1;
    }
    for(int i=1;i<=n;i++) {
        while(head<tail && slope(q[head],q[head+1])<=f[i]) head++;
        int t=q[head];
        dp[i]=dp[t]+(f[i]-f[t]-L)*(f[i]-f[t]-L);
        while(head<tail && slope(q[tail],i)<slope(q[tail-1],q[tail])) tail--;
        q[++tail]=i;
    } 
    printf("%lld",dp[n]);
}
```

---

## 作者：rhdeng (赞：14)

[传送~](https://www.luogu.org/problemnew/show/P3195)

## Description

共有$n$个玩具,每个玩具长度$c_i$, 将$i$至$j$**连续**的玩具放入一个容器$i<j$,其长度$x=j-i+\sum_{k=i}^j{c_k}$.制作一个容器的费用为$(x-L)^2$,其中L为常数.求将所有玩具都放入容器中的费用最小值.

$n\leq 5*10^4, 1\leq L,c_i\leq 10^7$

## Solution

### $O(n^2)$

考虑dp.

设$f_i$为1至$i$的所有玩具都放入容器中的最小费用.~~显然~~可以得到如下转移方程

$$f_i=\min_{1\leq j<i}\left\{f_j+\left[i-(j+1)+\sum_{k=j+1}^i{c_k}-L\right]^2\right\}$$

设$sum_i$为$\sum_{j=1}^i{c_j}$,则原方程可化为

$$f_i=\min_{1\leq j<i}\{f_j+[i-(j+1)+(sum_i-sum_{j+1})-L]^2\}$$

这样我们可以做到$O(n^2)$.但对于$5*10^4$,这是远远不够的.

### $O(n)$

这个式子实在是太丑了...于是,根据式子中各成分与$i,j$的关系,我们可以设$a_i=sum_i+i,b_i=sum_i+i+L$,则原方程又~~双叒叕~~可以表示为

$$f_i=\min_{1\leq j<i}\{f_j+(a_i-b_{j+1})^2\}$$

式子瞬间简洁多了.

这时我们可以考虑斜率优化\.由斜率优化套路,即比较两种转移策略,我们设$j>k$且从从$j$转移优于$k$,则必须满足

$$\begin{aligned}f_j+(a_i-b_{j+1})^2&<f_k+(a_i-b_{k+1})^2\\\Rightarrow f_j+a_i^2-2*a_i*b_{j+1}+b_{j+1}^2&<f_k+a_i^2-2*a_k*b_{k+1}+b_{k+1}^2\\\Rightarrow (f_j+b_{j+1}^2)-(f_k+b_{k+1}^2)&<2*a_i*(b_{j+1}-b_{k+1})\\\Rightarrow \frac{(f_j+b_{j+1}^2)-(f_k+b_{k+1}^2)}{(b_{j+1}-b_{k+1})}&<2*a_i\end{aligned}$$

这时我们发现左边**与当前$i$无关**(这是可以用斜率优化的必要条件)且很像一次函数的点斜式.我们设$slope(j,k)$为上面的左式,即斜率.则当$j>k$且$slope(j,k)<2*a_i$时,$j$比$k$优.由于$a_i$单调递增,我们可以用单调队列维护斜率,使$slope(i+1, i)$单调递增,且队首最优.

## Code
```cpp
#include <bits/stdc++.h>
#define A(i) ((i)+sum[i])
#define B(i) ((i)+L+1+sum[i])
#define S(i) 1ll*(i)*(i)
using namespace std;
template<typename T> inline void read(T& x) {
	char ch = getchar(); T a = 0, b = 1;
	while (ch != '-' && (ch < '0' || ch > '9')) ch = getchar();
	if (ch == '-') b = -1, ch = getchar();
	while (ch >= '0' && ch <= '9') a = (a<<1)+(a<<3)+(ch^48), ch = getchar();
	x = a*b;
}
typedef long long ll;
const int maxn = 5e4;
int n, sum[maxn+10], L, q[maxn+10];
ll f[maxn+10];
inline double slope(int j, int k) {
	return 1.0*(f[j]+S(B(j))-f[k]-S(B(k)))/(B(j)-B(k));
}
int main() {
	read(n); read(L);
	for (int i = 1; i <= n; ++i) {
		read(sum[i]); sum[i] += sum[i-1];
	}
	int l = 0, r = 0;
	for (int i = 1; i <= n; ++i) {
		while (l < r && slope(q[l+1], q[l]) <= 2*A(i)) ++l; //此时q[l]比q[l+1]更劣,由于a[i]递增,故之后一直更劣,弹出
		f[i] = f[q[l]]+S(A(i)-B(q[l]));
		while (l < r && slope(q[r], q[r-1]) > slope(i, q[r])) --r; //保持队列中斜率单调递增
		q[++r] = i;
	}
	printf("%lld", f[n]); //一定记得开longlong
	return 0;
}
```
> *THANK YOU FOR READING THIS!*

---

## 作者：Brioche (赞：14)

### [BLOG](https://www.luogu.org/problemnew/show/P3195)

感谢楼上大佬让我彻底弄懂斜率优化QAQ

"这是一道经典的斜率优化入门题,就用这题来作个总结好了."

这道题用到的是单调队列(我只会这玩意儿)的斜率优化.

我们整理一下题意会发现它的状态转移方程就是下面这东西:

$$dp[i]=min(dp[j]+(sum[i]+i-sum[j]-j-L-1)^2),i>j$$

![](https://www.cnblogs.com/images/cnblogs_com/terribleterrible/1303410/o_1537252318274.jpg)

上面这张图讲得已经很清楚了.

我们如果把含$j$的相关变量都看成点的坐标的话,此时我们要做的就是尽量让截距更小.

怎么让截距最小呢?难道一个一个比较吗?

我们再来看下面这张图:

![](https://www.cnblogs.com/images/cnblogs_com/terribleterrible/1303410/o_2.png)

上面三个点是我们可供选择的三个点,这条直线就是我们就是要使这条一直斜率的截距最小.

高中数学学线性规划的时候我们都知道,显然是选途中的$B$点.

那么对于这一条直线,我们根据斜率和坐标可以计算截距,从而得到dp值.
那剩下两个点呢?

对于$A$点,我们是不是可以丢掉它了?是的,由于我们的斜率是不断增大的,$A$点是不可能用来转移后面的状态了,所以把它剔除.

还有$C$点,当斜率到达一定大小,例如下图:

![](https://www.cnblogs.com/images/cnblogs_com/terribleterrible/1303410/o_1.png)

此时我们就要用到$C$,而$B$又可以剔除.

于是我们只要维护一个凸包,而且这个凸包相邻两个点连的斜率要大于当前这条线的斜率.就像刚刚这个例子一样.一旦最左端的一个点和次左端的点的连线要小于当前的斜率了,就把最左端的点剔除.

这样每次遇到新的直线,直接拿最左端的点(队头)来转移,加入一个新点就加到最右边(队尾),因为横坐标也是递增的.再加入这个点之前,我们一定要保证下凸的性质,例如下面这个例子:

![](https://www.cnblogs.com/images/cnblogs_com/terribleterrible/1303410/o_W@2AJJXH%7B_%7D0A5C_V5%7BS5L2.png)

$B$显然要被剔除.

为什么一定维护凸包呢?为什么一定是弹掉$B$.$C$为什么更优呢?自己想象一下,一条直线斜率大于$CG$的直线从下面平移上来,走啊走,最后一定会在$C$这里停下.如果是一条斜率小于$GC$大于$GF$的,显然会在$G$停下,这样$B$就没有人和用武之地了.

在这里我们总结一下,单调队列斜率优化的步骤:

1.弹队头,就是最左边的点.

2.放直线,算答案,得到当前状态的答案,得到新的待加入的点.

3.弹队尾,把插入新点之后不合法的点弹掉.最后加入新点就好了.

代码:
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#define maxn 50005
#define ll long long
using namespace std;
int q[maxn];
double A[maxn],B[maxn],dp[maxn],sum[maxn];
double X(int x){return B[x];}
double Y(int x){return dp[x]+B[x]*B[x];}
double slope(int a,int b){return (Y(a)-Y(b))/(X(a)-X(b));}
int main()
{
	int n,l;cin>>n>>l;
	for(int i=1;i<=n;i++)scanf("%lf",&sum[i]);
	for(int i=1;i<=n;i++)
	{
		sum[i]+=sum[i-1];
		A[i]=sum[i]+i;B[i]=sum[i]+i+l+1;
	}
	B[0]=l+1;//B[0]=sum[0]+0+l+1=l+1
	int tail=1,head=1;
	for(int i=1;i<=n;i++)
	{
		while(head<tail&&slope(q[head],q[head+1])<2*A[i])head++;
		int j=q[head];dp[i]=dp[j]+(A[i]-B[j])*(A[i]-B[j]);
		while(head<tail&&slope(i,q[tail-1])<slope(q[tail-1],q[tail]))tail--;
		q[++tail]=i;
	}
	printf("%lld",(ll)dp[n]);
	return 0;
}

```


---

## 作者：Polaris_Dane (赞：11)

不得不说，斜率优化这个东西代码一点都不多

就是理解上面的问题了

------------

本人太弱了。。。刚刚学斜率优化，做几道题练练手，偶尔看到了这道题

一看就知道是要DP，状态转移方程一写

dp[i]=min(dp[j]+(sum[i]+i−sum[j]−j−L−1)^2)(j<i)

那么如果我们要去掉min

就变成了这样

dp[i]=dp[j]+(sum[i]+i−sum[j]−j−L−1)^2(j<i)

设sum[i]+i=a[i],sum[i]+i+L+1=b[i]

那么dp[i]=dp[j]+a[i]^2+b[j]^2-2*a[i]*b[j]

如果式子长这样：

dp[i]=max（dp[j]+a[j]）(只是类似)

那么我们可以使用单调队列优化

但是我们的这个式子中有一项为i，j相乘！！！

怎么办？凉了吗？

这时斜率优化横空而出

移一下项，有：

dp[j]+b[j]^2=2*a[i]*b[j]+dp[i]-a[i]^2

等一下，这里i为定值，同时为需要转移状态，所以除了dp[i]之外所有与i相关的项为定值

我们需要dp[i]最小，那么

dp[j]+b[j]^2（y）=2*a[i]（k）*b[j]（x）+dp[i]-a[i]^2（b）

形如y=kx+b（~~废话~~）

考虑平面内一系列的点（即每个决策点）

![](https://cdn.luogu.com.cn/upload/pic/13267.png)

当前仅当形如上图的下凸包的点才可能成为最优决策

那么我们用单调队列维护一下

就是要保证一个点，其左边斜率小于右边斜率即可

队首出队条件当队首斜率小于当前直线斜率（2*a[i]）

主要原因是因为2*a[i]单调，但有些题目中不一定

那我们就必须要二分在其中查找最优决策

此处暂且不会用，作者太弱了也不大会

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<cctype>
#define M 4010000
#define inf 1e9+1e4
#define LL long long
using namespace std;
LL n,ll,q[M];
double dp[M],sum[M];
LL l=0,r=0,maxt,ans=inf,c[M],a[M],b[M];
inline void read(LL &x)
{
	LL f=1;x=0;char s=getchar();
	while (!isdigit(s)){
		if(s=='-')f=-1;
		s=getchar();
	}
	while (isdigit(s))
	{
		x=(x<<1)+(x<<3)+(s^48);
		s=getchar();
	}
	x*=f;
}
double get_slope(int x,int y)
{
	return (dp[x]-dp[y]+b[x]*b[x]-b[y]*b[y])/(b[x]-b[y]);
}
int main()
{
	read(n);read(ll);
	b[0]=ll+1;
	for (int i=1;i<=n;i++)
	{
		read(c[i]);
		sum[i]=sum[i-1]+c[i];
		a[i]=sum[i]+i;
		b[i]=sum[i]+i+ll+1;
	}
	for (int i=1;i<=n;i++)
	{
		while (l<r&&get_slope(q[l+1],q[l])<2*a[i])
		{
			l++;
		}
		dp[i]=dp[q[l]]+(a[i]-b[q[l]])*(a[i]-b[q[l]]);
		while (l<r&&get_slope(i,q[r])<get_slope(q[r],q[r-1]))
		{
			r--;
		}
		q[++r]=i;
	}
	printf("%lld",(LL)dp[n]);
    return 0;
}

```


---

## 作者：hongzy (赞：8)

## 「HNOI 2008」玩具装箱TOY

首先$O(n^2)$的$DP$做法是显然的，使用前缀和然后暴力枚举转移

```cpp
dp[0] = 0;
for(int i = 1; i <= n; i ++) {
	dp[i] = 1LL << 62;
	for(int j = 0; j < i; j ++) {
		LL x = i - (j + 1) + s[i] - s[j];
		dp[i] = min(dp[i], dp[j] + (x - L) * (x - L));
	}
}
```
上面的$dp$转移方程为：（$s[k]=\sum_{i=1}^kc[i]$ 为前缀和）

$dp[i]=min(dp[j]+(i - j - L - 1 + s[i] - s[j]) ^ 2) \; (0\leq j < i)$

令$a_i=s[i]+i-L-1,b_j=s[j]+j$，则：

$dp[i]=min(dp[j]+(a_i - b_j) ^ 2) \; (0\leq j < i)$

假设选$j$转移：$dp[i]=dp[j]+(a_i - b_j) ^ 2$

$dp[i]=dp[j]+a_i^2 + b_j^2 -2a_ib_j$

移项得：

$2a_ib_j+dp[i]-a_i^2 =dp[j]+ b_j^2$

把这看成是$kx+b=y$的直线形式，则其斜率为$2a_i$，$x=b_j$，$y=dp[j]+ b_j^2$，截距$dp[i]-a_i^2$

也就是说假设我们用$j$转移，$y=2a_ix+b$这条直线经过点$P_j(b_j,dp[j]+ b_j^2)$时，它的截距$+a_i^2$就是$dp[i]$。

这样我们每次选择一个最优的$j$转移就行了

显然是找一个斜率为$2a_i$、经过$P_j$，截距最小的$j$。

根据图像，这些最优的$j$点是会构成一个下凸包的

然后每次找到第一个满足的位置就是最优答案（截距最小），如图

![](https://cdn.luogu.com.cn/upload/pic/39942.png)

记$slope(P_1,P_2)$表示经过$P1,P2$的直线斜率

可以发现最优解处就是找到凸包上的第一个满足$slope(P_j,P_{j+1})>2a_i$的点$j$

注意每次需要查找的$a_i=s[i]+i-L-1$是递增的，因为$s[i]+i$递增，$-L-1$是常量

因此可以使用单调队列维护凸包

考虑队首：根据单调性，若$slope(P_j,P_{j+1})<2a_i$，$P_j$就可以以后都不再考虑，把它出队$( \text{pop\_front})$

这样就可以更新$dp[i]$了。

再考虑队末：把$P_i(b_i,dp[i]+ b_i^2)$加入凸包。如图所示，红线优于绿线，因此$P_{back-1}$将改为连$P_i$

![](https://cdn.luogu.com.cn/upload/pic/39944.png)

因此单调队列具体做法是：记末端$2$个点分别为$P_{back-1},P_{back}$

若$slope(P_{back-1},P_{back})>slope(P_{back-1},P_i)$，从队尾弹出$(\text{pop\_back})$

直到只剩一个点或者不满足大于条件时插入。

大概就是这样.

```cpp
#include <cstdio>

typedef long long LL;

const int N = 5e4 + 10; 

int n, L, c[N];
LL dp[N], s[N], a[N], b[N];

inline LL x(int i) { return b[i]; }
inline LL y(int i) { return dp[i] + b[i] * b[i]; }
inline double slope(int i, int j) { return (y(j) - y(i)) / (double) (x(j) - x(i)); }

int main() {
	scanf("%d%d", &n, &L);
	for(int i = 1; i <= n; i ++) {
		scanf("%d", &c[i]);
		s[i] = s[i - 1] + c[i];
		a[i] = (b[i] = s[i] + i) - L - 1;
	}
	static int q[N], hd = 0, bk = 0;
	q[bk ++] = 0; //注意队列初始时应 push(j = 0)
	for(int i = 1; i <= n; i ++) {
		for(; hd + 1 < bk && slope(q[hd], q[hd + 1]) < 2.0 * a[i]; ++ hd) ;
		dp[i] = dp[q[hd]] + (a[i] - b[q[hd]]) * (a[i] - b[q[hd]]);
		for(; hd < bk - 1 && slope(q[bk - 2], q[bk - 1]) > slope(i, q[bk - 1]); -- bk) ;
		q[bk ++] = i;
	}
	printf("%lld\n", dp[n]);
	return 0;
}
```
（感谢之前的$dalao$们的细致讲解$qwq$

---

## 作者：y2823774827y (赞：8)

[更好的阅读体验](https://www.cnblogs.com/y2823774827y/p/10176159.html)

纪念不看题解$A$掉的第一个斜率优化dp

定义数组$sum_i$为长度前缀和，数组$dp_i$为前$i$个玩具的最小花费

当前块末$i$与前一块末$j$状态转移为$dp_i=dp_{j-1}+i-(j+1)+sum_i-sum_j-L$

假设$j<k$，从$k$转移比$j$转移更优：

$dp_j+[i-(j+1)+sum_i-sum_j-L]^2>$

$dp_k+[i-(k+1)+sum_i-sum_k-L]^2$

$\Longrightarrow$

$dp_j+[(i+sum_i-L)+(-j-1-sum_j)]^2>$

$dp_k+[(i+sum_i-L)+(-k-1-sum_k)]^2$

$\Longrightarrow$

$dp_j+(i+sum_i-L)^2+2(i+sum_i-L)(-j-1-sum_j)+(-j-1-sum_j)^2>$

$dp_k+(i+sum_i-L)^2+2(i+sum_i-L)(-k-1-sum_k)+(-k-1-sum_k)^2$

$\Longrightarrow$

$dp_j+2(i+sum_i-L)(-j-1-sum_j)+(-j-1-sum_j)^2>$

$dp_k+2(i+sum_i-L)(-k-1-sum_k)+(-k-1-sum_k)^2$

$\Longrightarrow$

$dp_j-dp_k+(-j-1-sum_j)^2-(-k-1-sum_k)^2>$

$(i+sum_i-L) \{2[(-k-1-sum_k)-(-j-1-sum_j)]\}$ 

$\Longrightarrow$

$\dfrac{dp_j-dp_k+(-j-1-sum_j)^2-(-k-1-sum_k)^2}{2[(-k-1-sum_k)-(-j-1-sum_j)]}>i+sum_i-L$

：然后你就会样例都过不了，为什么？根据单调性$2[(-k-1-sum_k)-(-j-1-sum_j)]$为负，符号要变，所以最后的式子为

$\dfrac{dp_j-dp_k+(-j-1-sum_j)^2-(-k-1-sum_k)^2}{2[(-k-1-sum_k)-(-j-1-sum_j)]}<i+sum_i-L$

$i+sum_i-L$单调递增，所以我们用单调队列维护上凸包

### **My complete code**

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL maxn=200000;
inline LL Read(){
	LL x=0,f=1; char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f=-1; c=getchar();
	}
	while(c>='0'&&c<='9')
	    x=(x<<3)+(x<<1)+c-'0',c=getchar();
	return x*f;
}
LL n,L,head,tail;
LL sum[maxn],dp[maxn],q[maxn];
inline double Get(LL i){
	return (double)i+sum[i]-L;
}
inline LL P_(LL x){
	return x*x;
}
inline double Xl(LL j,LL k){
	return (double)
	(dp[j]-dp[k]+P_(-j-1-sum[j])-P_(-k-1-sum[k]))/(2*(-k-1-sum[k]+j+1+sum[j]));
}
int main(){
	n=Read(),L=Read();
	for(LL i=1;i<=n;++i)
		sum[i]=sum[i-1]+Read();
	dp[1]=P_(sum[1]-L),
	q[head=tail=1]=1;
	for(LL i=2;i<=n;++i){
		while(head<tail&&Xl(q[head],q[head+1])<Get(i))
		    ++head;
		LL j=q[head];
		LL val=i-(j+1)+sum[i]-sum[j]-L;
		dp[i]=min(dp[j]+P_(val),P_(i-1+sum[i]-L));
		while(head<tail&&Xl(q[tail-1],q[tail])>Xl(q[tail],i))
		    --tail;
		q[++tail]=i;
	}
	printf("%lld",dp[n]);
    return 0;
}
```

---

## 作者：_LHF_ (赞：6)

# 斜率优化
前置知识：动态规划，单调队列。

好了，就当大家学会了，那么我们一起开始吧。

就拿这一题作为例题吧。方程：
$$dp[i]=min(dp[j]+(\sum_{k=j+1}^ic[k]+i-j-1-l)^2)$$
时间复杂度：$O(n^3)$

显然是不行的，我们可以优化一下，用s储存c的前缀和，这样化简之后，方程如下：
$$dp[i]=min(dp[j]+(s[i]-s[j]+i-j-1-l)^2)$$
我们令$f[i]=s[i]+i$，则方程为：
$$dp[i]=min(dp[j]+(f[i]-f[j]-1-l)^2)$$
时间复杂度：$O(n^2)$

还是会超时
## 斜率优化该上了
假如现在有两个决策，分别为
$$dp[j]+(f[i]-f[j]-1-l)^2\geq dp[k]+(f[i]-f[k]-1-l)^2$$
其中：$j<k$，那么，我们肯定会选择$k$，对吧。

我们可以先把上面讲述的不等式化简一下，令$g[i]=(f[i]+1+l)^2,g[0]=(1+l)^2$，那么原式为：
$$dp[j]+(f[i]-(f[j]+1+l))^2\geq dp[k]+(f[i]-(f[k]+1+l))^2$$
$$dp[j]+f[i]^2-2×f[i]×(f[j]+1+l)+g[j]\geq dp[k]+f[i]^2-2×f[i]×(f[k]+1+l)+g[k]$$
移项得：
$$2×f[i]×(f[k]+1+l)-2×f[i]×(f[j]+1+l)\geq dp[k]+f[i]^2+g[k]-dp[j]-f[i]^2-g[j]$$
$$2×f[i]×(f[k]-f[j])\geq dp[k]+g[k]-dp[j]-g[j]$$
因为$f[k]-f[j]>0$，所以得到：
$$2×f[i]\geq \frac{dp[k]+g[k]-dp[j]-g[j]}{f[k]-f[j]}$$
这个时候我们惊奇地发现，如果两个决策：$j,k(j<k)$满足$2×f[i]\geq \frac{dp[k]+g[k]-dp[j]-g[j]}{f[k]-f[j]}$，则$k$比$j$更优。

好了，既然我们推出的这一个式子，那么我们继续。

我们可以维护一个队列，为了保证队列中的元素单调递增，我们必须开一个单调队列。保证每一次取队首的元素一定是最优的，所以我们也要维护这一个队列。

首先，给出这一个东西：
```cpp
double slope(int j1,int j2)
{
	return (double)(dp[j2]+g[j2]-dp[j1]-g[j1])/(f[j2]-f[j1]);
}
long long pw(int a)
{
	return (long long)a*a;
}
```
应该懂得这东西是干什么的吧，然后我们再来看：

首先：
```cpp
while(head<tail&&slope(d[head],d[head+1])<2*f[i]) head++;
dp[i]=dp[d[head]]+pw(f[i]-f[d[head]]-1-l);
```
这一个就是取最优的决策，应该没问题吧。

然后，因为斜率倒掉上升，所以我们也要$\frac{dp[k]+g[k]-dp[j]-g[j]}{f[k]-f[j]}$其实也要保证单调上升，这样才能达到最优解，所以：
```cpp
while(head<tail&&slope(d[tail],i)<slope(d[tail-1],d[tail])) tail--;
tail++;
d[tail]=i;
```
好了，大功告成，最后给一份完整的代码（码风不怎么样，请谅解）：
```cpp
#include<cstdio>
#define N 100010
using namespace std;
long long dp[N],g[N];
int f[N],d[N];
int t,n,l,head,tail,s;
long long pw(int a)
{
	return (long long)a*a;
}
double slope(int j1,int j2)
{
	return (double)(dp[j2]+g[j2]-dp[j1]-g[j1])/(f[j2]-f[j1]);
}
int main()
{
	scanf("%d%d",&n,&l);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&t);
		s+=t;
		f[i]=s+i;
		g[i]=pw(l+1+f[i]);
	}
	g[0]=pw(l+1);
	for(int i=1;i<=n;i++)
	{
		while(head<tail&&slope(d[head],d[head+1])
			<2*f[i]) head++;
		dp[i]=dp[d[head]]+pw(f[i]-f[d[head]]-1-l);
		while(head<tail&&slope(d[tail],i)<
			slope(d[tail-1],d[tail])) tail--;
		tail++;
		d[tail]=i;
	}
	printf("%lld",dp[n]);
}
```
完美撒花❀
## 更新日志
updata 2020.1.16 修改了一个小小的错误

updata 2020.6.27 删掉了没用的东西

---

## 作者：bztMinamoto (赞：6)

打广告->[这里](https://www.cnblogs.com/bztMinamoto/p/9544619.html)

来好好的讲一讲斜率优化（虽然本人才做了一两道题）

首先我们要知道，对于形如$dp[i]=a[j]+b[j]$的式子，可以用单调队列优化到$O(n)$

但如果式子变成了形如$dp[i]=a[i]*b[j]+c[i]+d[j]$的时候，因为$a[i]*b[j]$这一项既与$i$有关又与$j$有关，所以直接单调队列行不通了

我们先来考虑这一道题目，设前缀和为$sum[i]$转移方程应该是$$dp[i]=min(dp[j]+(sum[i]+i-sum[j]-j-L-1)^2) (j<i)$$

那么我们要考虑一下进行优化，我们假设选取$j$会比$k$更优，且$k<j$

那么$$dp[j]+(sum[i]+i-sum[j]-j-L-1)^2<dp[k]+(sum[i]+i-sum[k]-k-L-1)^2$$

然后为了方便一点，令$a[i]=sum[i]+i,b[i]=sum[i]+i+L+1$

那么上式可以化为$$dp[j]+(a[i]-b[j])^2<dp[k]+(a[i]-b[k])^2$$

然后展开一下$$dp[j]+a[i]^2-2*a[i]*b[j]+b[j]^2<dp[k]+a[i]^2-2*a[i]*b[k]+b[k]^2$$

移项$$dp[j]+b[j]^2-dp[k]-b[k]^2<2*a[i]*b[j]-2*a[i]*b[k]$$

$$\frac {dp[j]+b[j]^2-dp[k]-b[k]^2}{b[j]-b[k]}<2*a[i]$$

然后令$Y[i]=dp[i]+b[i]^2,x[i]=b[i]$

那么原式可化为$$\frac {Y[j]-Y[k]}{X[j]-X[k]}<2*a[i]$$

所以如果$j>k$且$\frac {Y[j]-Y[k]}{X[j]-X[k]}<2*a[i]$ 那么$j$比$k$更优，否则$k$比$j$优

所以证了半天这有啥用么？没有

我们考虑一下，若在平面直角坐标系上存在点$k:(X[k],Y[k])$与$j:(X[j],Y[j])$，那么$\frac {Y[j]-Y[k]}{X[j]-X[k]}$就是两点的斜率

然后一下我们用$slope(i,j)$表示$i,j$两点的斜率，即$\frac {Y[i]-Y[j]}{X[i]-X[j]}$

因为$X[j],X[k],Y[i],Y[k]$都是定值，所以上面两个点都是定点

然后我们假设有三个值$i,j,k$（这里的$i$与上面的无关），其中$k<j<i$

我们假设$slope(j,k)>slope(i,j)$，也就是说是下面这个样子


![](https://i.loli.net/2018/08/27/5b83fc008a9aa.png)
 

那么$slope(j,k),slope(i,j),2*a[i]$会有三种大小关系

当$slope(j,k)>slope(i,j)>2*a[i]$时，$j$比$i$优，$k$比$j$优，$j$不是最优

当$slope(j,k)>2*a[i]>slope(i,j)$时，$k$比$j$优，$i$比$j$优，$j$不是最优

当$2*a[i]>slope(j,k)>slope(i,j)$时，$j$比$k$优，$i$比$j$优，$j$不是最优

也就是说，如果存在$slope(j,k)>slope(i,j)$，那么从$j$转移无论如何都不可能是最优的方案，已经可以把它给排除了

所以，我们必须保证维护的是一个下凸包，即$slope(j,k)>slope(i,j)$，如下图

![](https://i.loli.net/2018/08/27/5b83fbf130e32.png)

不难看出下凸包的斜率是永远单调递增的，那么可以用一个单调队列来维护，即每一次看一看最末尾的元素$slope(q[t],q[t-1])<slope(q[t],i)$是否成立，若不成立则把$q[t]$弹出（即$--t$）

或者写成$slope(q[t],q[t-1])<slope(q[t-1],i)$也是可以的（仔细观察上图，不难发现这两个判断是等价的）

那么，在这个单调队列里哪一个答案才是最优的呢？

因为只有$slope(j,k)<2*a[i]$时$j$才会比$k$更优，而因为$a[i]=sum[i]+i$（忘了的可以回去看看，上面的假设），所以$s[i]$肯定是递增的

那么如果$slope(j,k)>2*a[i]$，那么$j$就不可能比$k$更优了，否则$j$一定比$k$优，所以我们可以把$k$从单调队列里删掉了，即每一次看看最开头的元素$slope(q[h],q[h+1])<2*a[i]$是否成立，若成立，则把$q[h]$弹出（即$++h$）

那么每一次单调队列的开头都满足$slope(q[h],q[h+1])>2*a[i]$，即$q[h]$后面的答案永远不可能比它更优。所以我们可以直接用$q[h]$来进行转移就行了，时间复杂度为$O(n)$

顺便注意一个细节，因为我们要求的$j$必须小于$i$所以我们应该先处理完单调队列开头并更新完答案，再去处理末尾

然后上本题代码
```
//minamoto
#include<iostream>
#include<cstdio>
#include<cstring>
#define db double
#define ll long long
using namespace std;
#define getc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
inline int read(){
    #define num ch-'0'
    char ch;bool flag=0;int res;
    while(!isdigit(ch=getc()))
    (ch=='-')&&(flag=true);
    for(res=num;isdigit(ch=getc());res=res*10+num);
    (flag)&&(res=-res);
    #undef num
    return res;
}
const int N=50005;
int n,L;
db sum[N],dp[N];int h,t,q[N];
inline db a(int i){return sum[i]+i;}
inline db b(int i){return sum[i]+i+L+1;}
inline db X(int i){return b(i);}
inline db Y(int i){return dp[i]+b(i)*b(i);}
inline db slope(int i,int j){return (Y(i)-Y(j))/(X(i)-X(j));}
//这些都如上面定义，忘了的再去看看 
int main(){
    n=read(),L=read();
    for(int i=1;i<=n;++i) sum[i]=read()+sum[i-1];
    h=t=1;
    //一开始要先放一个0，而不能把它设为空 
    for(int i=1;i<=n;++i){
        while(h<t&&slope(q[h],q[h+1])<2*a(i)) ++h;
        double p=a(i)-b(q[h]);
        dp[i]=dp[q[h]]+p*p;
        //更新答案 
        while(h<t&&slope(q[t-1],q[t])>slope(q[t-1],i)) --t;
        q[++t]=i;
    }
    printf("%lld\n",(ll)dp[n]);
    return 0;
}
```

---

## 作者：_bestknife (赞：5)

我们从暴力决策打表得知, 决策总是满足单调性的, 一个决策j<k在之前k起作用而j没有, 在k之后j就再也没有了,这就是四边形不等式原理[详见刘汝佳黑书等资料], 所以我们可以动态维护决策区间达到目的, 然而这里使用了单调栈去二分, 详见<http://blog.csdn.net/qq\_34025203/article/details/50976612>,有比较详细的讲解,这里给出了程序

```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#define LL long long 
const int N = 1e5 + 10;
using namespace std; 
int n,h,t;
LL m,a[N],l,sum[N],f[N];
struct Nodes {int l,r,p;} q[N];
```
namespace SAKman
```cpp
{
  LL spr(LL x) {return x*x;} 
  LL cal(int x,int y) {return f[x]+spr(sum[y]-sum[x]+y-x-1-l);}
  int find(Nodes qi,int o)
  {
    int l=qi.l, r=qi.r;
    while(l<=r)
    {
      int m=(l+r) >> 1;
      if(cal(o,m) < cal(qi.p,m)) r=m-1; else l=m+1;
    }
    return l;
  }
  void run() 
  {
    scanf("%d%lld",&n,&l);
    for(int i=1; i<=n; ++i){scanf("%lld",&a[i]);sum[i]=sum[i-1]+a[i];}
    h=1;t=0;q[++t]=(Nodes){0,n,0};
    for(int i=1; i<=n; ++i) 
    {
      if(i>q[h].r) ++h;
      f[i]=cal(q[h].p,i);
      while(h>t||cal(i,n)<cal(q[t].p,n))
      {    
        while(h<=t && cal(i,q[t].l)<cal(q[t].p,q[t].l)) --t;
        if(h<=t)
        {
          int z=find(q[t],i);
          q[t].r=z-1;
          q[++t]=(Nodes){z,n,i}; 
        } 
        else q[++t]=(Nodes){i,n,i};
      }    
    }
    printf("%lld\n",f[n]);
  }
}
using namespace SAKman; int main() {    run();}

```

---

## 作者：i207M (赞：5)

## 题目总结

![](https://cdn.luogu.com.cn/upload/pic/20603.png )

## 数据范围

$1<=N<=50000$，不优化凉凉；

## 解题思路

![](https://cdn.luogu.com.cn/upload/pic/20604.png )

![](https://cdn.luogu.com.cn/upload/pic/20606.png )

![](https://cdn.luogu.com.cn/upload/pic/20607.png )

那么我们就不用维护所有点了，只用维护一个凸壳。
注意到，我们的斜率（
$2 × G(i)$
）是正的，且求截距最小值。
所以我们应该维护下凸壳（右下）。
那怎么维护呢？
维护动态凸包这个东西需要用平衡树或set。
那这题只能用那两种方法做吗？

显然不是；
我们继续观察，不难发现，**我们的斜率（
$2 × G(i)$
）是单调递增的。
所以呢？之前（因为斜率）被删掉的点肯定不会再被加进来。
并且每次插入点的
X
坐标是单调不降的，所以就可以单调队列维护。**

![](https://cdn.luogu.com.cn/upload/pic/20608.png )

手动模拟一下发现这是对的；

## 易错误区

一个题能使用单调队列维护凸包，应该有以下几个条件：

1.
查询斜率单调。

2.
插入点的横坐标单调。

## 代码展示

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<string>
#include<algorithm>
#include<vector>
#include<map>
#include<set>
#include<list>
#include<queue>
#include<stack>
#include<bitset>
#include<deque>
using namespace std;
#define ll long long
#define ull unsigned long long
#define inf 0x3f3f3f3f
#define ri register int
#define il inline
#define fi first
#define se second
#define mp make_pair
#define pi pair<int,int>
#define mem0(x) memset((x),0,sizeof (x))
#define mem1(x) memset((x),0x3f,sizeof (x))
#define int ll
il char gc() {
    static const int BS = 1 << 22;
    static unsigned char buf[BS], *st, *ed;
    if (st == ed) ed = buf + fread(st = buf, 1, BS, stdin);
    return st == ed ? EOF : *st++;
}
#define gc getchar
template<class T>void in(T &x)
{
    x = 0; bool f = 0; char c = gc();
    while (c < '0' || c > '9') {if (c == '-') f = 1; c = gc();}
    while (isdigit(c)) {x = (x << 3) + (x << 1) + (c ^ 48); c = gc();}
    if (f) x = -x;
}
#undef gc
void out(int x) {
    if (x < 0) putchar('-'), x = -x;
    if (x > 9) out(x / 10);
    putchar(x % 10 + '0');
}
#define N 50010
#define int ll
#define A(i) (sum[i]+i)
#define B(i) (A(i)+(L+1))
#define X(i) B(i)
#define Y(i) (B(i)*B(i)+dp[i])
#define G(i) 2.0*A(i)
#define slope(i,j) ((double)(Y(j)-Y(i))/(double)(X(j)-X(i)))
int n,L, c[N], sum[N], dp[N];
deque<int>q;
signed main() {
    in(n),in(L);
    for (ri i = 1; i <= n; ++i) {
        in(c[i]);
        sum[i] = sum[i - 1] + c[i];
    }
    q.push_back(0);// f[0]=0;
    for (ri i = 1; i <= n; ++i) {
        while (q.size() > 1 && slope(*(q.begin()), *(q.begin() + 1)) < G(i))
            q.pop_front();
        dp[i] = dp[q.front()] + (A(i) - B(q.front())) * (A(i) - B(q.front()));
        while (q.size() > 1 && slope(*(q.end() - 1), *(q.end() - 2)) > slope(*(q.end() - 2), i))
            q.pop_back();
        q.push_back(i);
    }
    printf("%lld", dp[n]);
    return 0;
}
```

---

## 作者：ccsc (赞：4)

[P3195 [HNOI2008]玩具装箱TOY](https://www.luogu.org/problemnew/show/P3195)
**过程十分艰难，刺蝥**

------------
## 不过，啥都不说了，题解招待*——*
# "斜率优化"  才是本题正解

斜率优化

------------

目标是要化成f[i]=a[i]*b[j]+c[j]+（一个只与i有关的常数）这个形式！
[a[i]表示一个与i有关的数，b[j]、c[j]亦如此]

移项：-a[i]*b[j]+f[i]=c[j] 有没有很像y=kx+b

把-a[i]看为斜率，b[j]为x，c[j]为y，画一条直线 

那么答案f[i]就是直线与y轴的交点，即截距

------------

先把dp方程写出来吧：f[i]=min( f[j] +[sum[i]-sum[j]+i-(j+1)-L]^2 ),j<=i (sum[i]为前缀和 

f[i]表示i为其中一个断点，搞完前i个数的最小总和

为了简化方程，我们设s[i]=sum[i]+i;L=L+1;

那么原方程则为 f[i]=min(f[j]+(s[i]-s[j]-L)^2)，j<=i

平方拆开、移项能得到：2*(s[i]-L)*s[j]+f[i]=f[j]+s[j]^2

k=2*(s[i]-L)；x=s[j]；y=f[j]+s[j]*2
## 然后吗，代码伺候￥-￥
```cpp
#include<bits/stdc++.h>
#define maxn 50100
using namespace std;
typedef long long LL;
LL s[maxn],q[maxn],f[maxn];
double Y(LL j) {return f[j]+s[j]*s[j];}
double X(LL j) {return s[j];}
double xielu(LL j,LL k)
{
	return (Y(k)-Y(j))/(X(k)-X(j));
}
int main()
{
	LL n,L,i,x,tou,wei;
	scanf("%lld%lld",&n,&L);L++;s[0]=0;
    for (i=1;i<=n;i++) {scanf("%lld",&s[i]);s[i]+=s[i-1];}
	for (i=1;i<=n;i++) s[i]+=i;
	tou=1;
	wei=1;
	q[1]=0;
	for (i=1;i<=n;i++)
	{
		while (tou<wei &&xielu(q[tou],q[tou+1])<=2*(s[i]-L))tou++;
		int j=q[tou];
		f[i]=f[j]+(s[i]-s[j]-L)*(s[i]-s[j]-L);
		while (tou<wei &&xielu(q[wei-1],q[wei])>xielu(q[wei],i)) wei--;
		q[++wei]=i;
	}
	printf("%lld\n",f[n]);
	return 0;
}
```


---

## 作者：AlanSP (赞：3)

## 在这里写一写学习心得

这次没有找到大佬的博客，于是我就自己写写，画画图吧

众所周知，DP的复杂度一般是$ O(n^a) $ 的（其中a为常数）

而对于1e5及以上的数据，普通的dp就不好使了

于是就产生了DP的优化。

优化有很多种：斜率优化，单调队列，决策单调（不等式），数据结构………………

其中斜率优化很常考，不过也有模板

一般的转移方程 $ dp_i  = max/min $ ( $ dp_j $   + 平方项) $ (0<=j<i) $

这时把平方项拆开看，可以写成$ ai*bj $ 的形式。

看成kx就行，其它的看成常数项b。

保证
$ dp_i $这一项在b中，y可以表示为和 $ dp_j $有关的项

然后我们可以画出这样的图

![画的好丑555](https://cdn.luogu.com.cn/upload/image_hosting/k2arc8ic.png)

我们所要做的，就是要让图中直线的截距最小（大）化。

### 实现

运用建模的思想，我们可以把每个决策点变为一个点

那么可以得出决策点与现决策点之间的关系——连成了一个凸包

如果求最大值，维护上凸包，最小值反是。

而当前的决策状态，就是以某一斜率去切这个凸包

而每切一次，直线的斜率都会变，而我们要找的便是最优截距。

我们可以找一个数据结构，维护这个凸包，保证每次决策的点是最优的（如单调队列，单调栈……）

至于维护凸包的方式，我们在题里细说。

（口胡完了，拍张图）

![](https://cdn.luogu.com.cn/upload/image_hosting/fq81cd15.png)


### 题解

[P3195](https://www.luogu.com.cn/problem/P3195)

[P3628](https://www.luogu.com.cn/problem/P3628)

这两道模板题，先做做。

我写一篇P3628的题解（这是一位学长去年讲得，我今年才做出来，惭愧啊！）

我们很容易得出 $ O(n^2) $的dp方程：$ dp_i=\max_{0<=j<i}\{{dp_j+a(sum_i-sum_j)^2+b(sum_i-sum_j)+c}\} $ 

通过上文的拆项方式，我们得到

$ dp_i=\max_{0<=j<i}\{{dp_j-2a(sum_i-sum_j)+asum_j^2-bsum_j}\}+asum_i^2+bsum_i+c $ 

之后画出直线，用单调队列维护上凸包，使截距最大。

优秀的push，不优的pop

注意维护单调队列的单调性

直接转移即可，上代码

```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long

const int INF=0x3f3f3f3f3f3f;

double x,y,k;
int n,L,ans=INF;
double c[50009],dp[50009],sum[50009];
int Q[50009],h,t;
inline int X(int p) {return (sum[p]+p+L+1);}
inline int Y(int p) {return dp[p]+X(p)*X(p);}
inline int A(int p) {return sum[p]+p;}

inline double cal(double x,double y)
{
	return (Y(x)-Y(y))/(X(x)-X(y));
}

signed main()
{
//	freopen("P3195_1.in","r",stdin);
//	freopen("P3195_1.out","w",stdout);
	scanf("%d%d",&n,&L);
	for(int i=1;i<=n;i++)
	{
		scanf("%lf",&c[i]);
		sum[i]=sum[i-1]+c[i];
	}
	h=t=1;
	for(int i=1;i<=n;i++)
	{
		while(h<t&&cal(Q[h],Q[h+1])<2*A(i)) h++;
		dp[i]=dp[Q[h]]+(A(i)-X(Q[h]))*(A(i)-X(Q[h]));
		while(h<t&&cal(Q[t-1],i)<cal(Q[t-1],Q[t])) t--;
		Q[++t]=i;
	}
	printf("%lld",(long long)dp[n]);
	return 0;
}    
```

#### PS 

注意在进行斜率的比较时，因为“/”是向下取整，容易出锅

所以一般化除为乘，或转一下double

最后%学长[whyl](https://www.luogu.com.cn/user/118918)

我太菜了

---

## 作者：a999999 (赞：3)

明显的斜率优化题~

所以我们按照一般的程序来看

不懂的可以看[我的blog](https://www.luogu.org/blog/a999999/xie-shuai-you-hua-di-ji-ben-bu-zhou)

首先列出dp方程：
$$f_i=min_{0<j<i}\{f_j+(i-j-1-L+\sum_{k=j+1}^iC_k)^2\}$$
然后按基本步骤来：
设$sum_i=\sum_{j=1}^{i}C_j$

于是就有
$$f_i=f_j+(i-j+sum_i-sum_j-L-1)^2$$
设$j>k$且$j$比$k$优
$$f_j+[(sum_i+i-L-1)-(sum_j+j)]^2<f_k+[(sum_i+i-L-1)-(sum_k+k)]^2$$
$$f_j-2(sum_i+i-L-1)(sum_j+j)+(sum_j+j)^2<f_k-2(sum_i+i-L-1)(sum_k+k)+(sum_k+k)^2$$
$$f_j-f_k+(sum_j+j)^2-(sum_k+k)^2<2(sum_i+i-L-1)(sum_j+j-sum_k-k)$$
$$\frac{f_j-f_k+(sum_j+j)^2-(sum_k+k)^2}{sum_j+j-sum_k-k}<2(sum_i+i-L-1)$$

再偷偷告诉你一个小技巧

队尾排除时不知道大于还是小于的时候

~~用样例把两种情况都试一下就好啦~~

$Code:$

```cpp
#include<algorithm>
#include<cstdio>
#define N 50010 
#define S(x) ((x)*(x))
long long f[N],sum[N],m;
int n,q[N];
long long Y(int x,int y)
{
	return f[x]-f[y]+S(sum[x]+x)-S(sum[y]+y);
}
long long X(int x,int y)
{
	return sum[x]+x-sum[y]-y;
}
signed main(int argc,char **argv)
{
	scanf("%d%lld",&n,&m);
	for(int i=1;i<=n;++i)
		scanf("%lld",sum+i),
		sum[i]+=sum[i-1];
	for(int l=0,r=0,i=1;i<=n;++i)
	{
		while(Y(q[l+1],q[l])<2*(sum[i]+i-m-1)*X(q[l+1],q[l])&&l<=r)++l;//记得-1
		f[i]=f[q[l]]+S(i-q[l]+sum[i]-sum[q[l]]-m-1);//记得-1
		while(Y(q[r],q[r-1])*X(i,q[r])>Y(i,q[r])*X(q[r],q[r-1])&&l<=r)--r;
		q[++r]=i;
	}
	printf("%lld",f[n]);
	return 0;
}
```

---

## 作者：mgzc (赞：3)

# [题面](https://www.luogu.org/problemnew/show/P3195)
[惊喜](https://www.cnblogs.com/ztlztl/p/10616538.html)

​	最近在搞dp, 发现自己的dp还是太弱了, 做的题比较少, 也有一些东西没学, 这道题算是我独立做的第一道斜率优化dp, 写篇题解纪念一下吧.

​	dp式比较简单, 就是一个线性的dp, 设$f[i]$为将1 ~ i分为若干个集合所花费的最小值, $c[i]$为1 ~ i的$c$值的前缀和, 对于满足$j$小于$i$的$j$, 则有:
$$
f[i] = min(f[j] + (c[i] - c[j] + i - j - 1 - l)^2)\tag{1}
$$
设$a[i] = c[i] + i$, $b[i] = c[i] + i + 1 + l$, 则可将上式化简为下式:
$$
\begin{aligned}
f[i] = & min(f[j] + (a[i] - b[j])^2)\\
=&min(f[j] + a[i] ^ 2 + b[j] ^ 2 - 2 * a[i] * b[j])
\end{aligned}
$$
假设对于某个$k$($k$ >$j$), 选$k$比选$j$更优, 则有下式:
$$
\begin{aligned}
f[k] + a[i] ^ 2 + b[k] ^ 2 - 2 * a[i] * b[k] &< f[j] + a[i] ^ 2 + b[j] ^ 2 - 2 * a[i] * b[j]\\
(f[k] + b[k] ^ 2) - (f[j] + b[j] ^ 2) &< 2 * a[i] * (b[k] - b[j])\\
\frac{(f[k] + b[k] ^ 2) - (f[j] + b[j] ^ 2)}{2 * (b[k] - b[j])} &< a[i]
\end{aligned}
$$
对于上述几个不等式, 由于$c[i]$与$i$单调递增, 所以$a[i]$也是单调递增的, 那么对于平面上的任意三个决策点$j_1$, $j_2$, $j_3$, 若$j_2$对$i$最优, 则$(b[j_1], f[j_1] + b[j _ 1] ^ 2)$, $(b[j_2], f[j_2] + b[j _ 2]^2)$, $(b[j_3], f[j _ 3] + b[j _ 3] ^ 2)$三点应该满足下列两个等式: 
$$
\begin{aligned}
\frac{(f[j_2] + b[j_2] ^ 2) - (f[j _ 1] + b[j _ 1] ^ 2)}{2 * (b[j_2] - b[j _ 1])} &< a[i]\\
\frac{(f[j_3] + b[j_3] ^ 2) - (f[j _ 2] + b[j _ 2] ^ 2)}{2 * (b[j_3] - b[j _ 2])} &\geq a[i]\\
\end{aligned}
$$
所以有:
$$
\frac{(f[j_3] + b[j_3] ^ 2) - (f[j _ 2] + b[j _ 2] ^ 2)}{2 * (b[j_3] - b[j _ 2])} >\frac{(f[j_2] + b[j_2] ^ 2) - (f[j _ 1] + b[j _ 1] ^ 2)}{2 * (b[j_2] - b[j _ 1])}
$$
故维护一个下凸包即可, 注意单调队列初始化时要先加入一个0. 

**代码**

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#define N 50005
#define int long long
using namespace std;

int n, L, sum[N], a[N], b[N], f[N], q[N], l = 1, r; 

inline int read()
{
	int x = 0, w = 1;
	char c = getchar();
	while(c < '0' || c > '9') { if (c == '-') w = -1; c = getchar(); }
	while(c >= '0' && c <= '9') { x = x * 10 + c - '0'; c = getchar(); }
	return x * w;
}

bool F_check(int x, int y, int z) { return f[y] - f[x] + b[y] * b[y] - b[x] * b[x] < 2 * z * (b[y] - b[x]); }

bool S_check(int x, int y, int z)
{
	return (f[y] - f[x] + b[y] * b[y] - b[x] * b[x]) * (b[z] - b[y]) > (f[z] - f[y] + b[z] * b[z] - b[y] * b[y]) * (b[y] - b[x]); 
}

signed main()
{
	n = read(); L = read(); 
	for(int i = 1; i <= n; i++)
	{
		sum[i] = read(); sum[i] += sum[i - 1];
		a[i] = sum[i] + i; b[i] = sum[i] + i + L + 1; 
	}
	memset(f, 0x3f, sizeof(f));
	b[0] = L + 1; f[0] = 0;
	q[++r] = 0; 
	for(int i = 1; i <= n; i++)
	{
		while(l < r && F_check(q[l], q[l + 1], a[i])) l++;
		f[i] = f[q[l]] + a[i] * a[i] + b[q[l]] * b[q[l]] - 2 * a[i] * b[q[l]];
		while(l < r && S_check(q[r - 1], q[r], i)) --r;
		q[++r] = i; 
	}
	printf("%lld\n", f[n]); 
	return 0;
}
\\有一些数组的名字改动了一点点, 世上不是缺少不一样的东西, 而是缺少发现不一样的东西的眼睛
```

~~你觉得我会告诉你我在写题目之前就把题解写完了吗???~~

---

## 作者：aiyougege (赞：3)

### 做法: 
　　用$f(i)$表示前$i$个物品的长度加物品个数$s_n=\sum\limits_{i=1}^nc_i+j$, 那么第$i$到$j$个物品的长度加物品个数就为$s_j-s_{i-1}$.这就是题目要求的$(x-l)^2$中的x.
　　首先可以想出一个朴素的dp.$f(i)$表示前$i$个数放到若干个盒子里(放满)的最小花费.则$f(i)$为$j$个物品最小代价加上这个盒子的代价, 转移方程为:
$$f(i)=\max\{f(j)+(s_i-s_j-l-1)^2\},j<i$$

　　表示新加一个盒子装第$j+1$到$i$个物品.
　　优化这个$n^2$转移的方法主要有两种.
- 斜率优化
- 决策单调性

　　斜率优化的复杂度较低, 为$O(n)$, 这是考虑到其单调队列复杂度为均摊$O(7n)$.而一次转移只需要取出单调队列中的一个最小值.
	.
　　在$N^2$转移中, 求$f(i)$需要枚举从$j,j< i$转移的代价.可以通过维护一个单调队列来将这一过程优化到$O(1)$, 考虑从$k$转移到$i$比从$j$转移到$i$代价更低, 其满足这么一个不等式.

$$f(j)+(s_j-s_i-l-1)^2>f(k)+(s_k-s_i-l-1)^2$$
将这个式子展开可以得到如此的限制关系.

$$s_i>\frac{f_k-f_i+(s_k+1+1)^2-(s_j+1+1)^2}{s\cdot(s_k-s_j)}$$
将右边的式子记为$p(k,j)$, 可以发现求得最大的$p(k,j)$满足$s_i>p(k,j)$, 则$f(i)$为$f(k)+(s_k-s_i-l)^2$.
　　通过维护一个单调递增队列,用$q_i$表示队列中的元素, $q_h, q_t$表示队头和队尾.单调队列中的元素是可以转移至答案的点, 答案从队首寻找.单调队列中元素的单调性是指满足$p(q_{i+1},q_{i})<p(q_{i+2},q_{i+1})$,对于$f(1)$到$f(n)$的求值, 因为$s_i$为单调递增, 所以可以保证删除队列手元素不会影响答案.

- 求$f(i)$时, 如果$p(q_{h+1},q_{h})\leq s_i$,就弹出队首.直到无法弹出时即从$q_h$其转移至当前点最优.
- 每次将一个点$i$加入队列时, 为了保证队列的单调性, 依次弹出队尾直到满足单调递增.

### Code
```c++
#include<iostream>
#include<cstdio>
#include<cmath>
#define N 100005

long long sum[N];
long long f[N];
int q[N];
int h,t;
int n,l;

long long pow(long long s){
return (long long)s*s;
}
double cmp(int i,int j){
	return (double)(f[j]-f[i]+pow(sum[j]+l)-pow(sum[i]+l))/(2*(sum[j]-sum[i]));
}

int main(){
	long long temp;
	scanf("%d%d",&n,&l);l+=1;
	for(int i=1;i<=n;++i){
		scanf("%lld",&temp);
		sum[i]=(long long)sum[i-1]+1+temp;
	}
	for(int i=1;i<=n;++i){
		while(h<t&&cmp(q[h],q[h+1])<=(double)sum[i])++h;
		f[i]=(long long)f[q[h]]+pow(sum[i]-sum[q[h]]-l);
		while(h<t&&cmp(q[t-1],q[t])>cmp(q[t],i))--t;
		q[++t]=i;
	}
	printf("%lld",f[n]);
	return 0;
}
```


---

## 作者：shadowice1984 (赞：3)

# 一定要开longlong！

非常适合入手斜率优化的模板题

n^2暴力方程//这里c[i]是前缀和

**dp\[i]=dp\[j]+(i-j+1+c[i]-c[j]+l)^2**

令f\[i]=c\[i]+i-1-l,g\[i]=c\[i]+i

**dp\[i]=dp\[j]+(f\[i]-g\[j])^2**

**dp\[i]=dp\[j]+f\[i]^2+g\[j]^2-2\*f\[i]\*g\[j]**

令h\[i]=g\[i]^2+dp\[i]

**h[j]=2\*f\[i]\*g\[j]+dp\[i]**

发现对于每一个i来讲，转移的过程实际上是

寻找一个点(g\[j],h\[j])使得过这个点做斜率为2\*f\[i]的直线截距最小

这里有一个神奇的性质，这个点一定在已知点集的凸包上

**//这也是为什么这种优化方法被称为斜率优化**

然后又发现g[i],h[i]都是单调的

选择单调队列维护凸包，每次检查队尾的形状是否凹进去

斜率最小的点一定在队头，每次取最小值的时候pop至斜率第一次大于队头即可

上代码~




```cpp
    #include<cstdio>
    #include<algorithm>
    using namespace std;//一定要开longlong！
    typedef double db;long long c[500010];
    int n;int l;long long dp[500010];long long f[500010];
    long long g[500010];long long h[500010];
    int dq[500010];int head;int tail;//手写双端队列
    inline bool empty(){return head>=tail;}
    inline void push(int x){dq[++tail]=x;}
    inline void pop(){head++;}
    inline void pot(){tail--;}
    inline db calck(int p1,int p2)//计算斜率
    {return ((db)h[p1]-(db)h[p2])/((db)g[p1]-(db)g[p2]);}
    int main()
    {
        scanf("%d%d",&n,&l);
        for(int i=1;i<=n;i++)
        {scanf("%d",&c[i]);c[i]+=c[i-1];}//前缀和
        for(int i=1;i<=n;i++)
        {
            f[i]=c[i]+i-1-l;g[i]=c[i]+i;//计算f,g
            while(!empty()&&(db)2*f[i]>=calck(dq[head],dq[head+1]))pop();
            dp[i]=dp[dq[head]]+(f[i]-g[dq[head]])*(f[i]-g[dq[head]]);//转移
            h[i]=g[i]*g[i]+dp[i];//计算h
            while(!empty()&&calck(dq[tail-1],dq[tail])>=calck(dq[tail],i))pot();
            push(i);//插入点
        }
        printf("%lld",dp[n]);return 0;
    }

```

---

## 作者：yybyyb (赞：3)

**如果公式看不清到CSDN上看把。。。**

[CSDN的链接](http://blog.csdn.net/qq\_30974369/article/details/78306943)

首先我们很容易想到DP

设f[i]表示当前选择到了第i个玩具，且第i个作为一个容器结束的位置的最小代价

然后很容易的想到了O(n^2)的DP

```cpp
    for(int i=1;i<=n;++i)
        for(int j=0;j<i;++j)
            f[i]=min(f[i],f[j]+sqr(c[i]-c[j]+i-j-1-L));

```
其中，c为前缀和,sqr为平方


但是，这样做的复杂度太高，显然不能够AC

那么，我们不妨设f[i]从j转移过来，并且还有一个状态k

那么就有：

$$f[j]+(c[i]-c[j]+i-j-1-L)^{2}<f[k]+(c[i]-c[k]+i-k-1-L)^{2}$$

$$不妨令M=c[i]-i-1-L,T[j]=c[j]+j$$

$$原式可以简写为f[j]+(M-T[j])^{2}<f[k]+(M-T[k])^{2}$$

$$左边=f[j]+M^{2}+T[j]^{2}-2MT[j]$$

$$右侧同理=f[k]+M^{2}+T[k]^{2}-2MT[k]$$

$$化简不等式得：\frac{(f[j]+T[j]^2)-(f[k]+T[k]^2)}{2(T[j]-T[k])}<M$$

f[i],T[j]和M很显然是单调的

所以很显然的可以用到了[斜率优化](http://blog.csdn.net/qq\_30974369/article/details/78306743)啦

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<set>
#include<map>
#include<vector>
using namespace std;
#define MAX 50100
inline int read()
{
    int x=0,t=1;char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
    if(ch=='-')t=-1,ch=getchar();
    while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
    return x*t;
}
int n,L,c[MAX];
int s[MAX],h,t;
long long f[MAX],q[MAX],T[MAX];
long long sqr(long long x){return x*x;}
long long count(int x,int y)
{
    return ((f[x]+sqr(q[x]))-(f[y]+sqr(q[y])))/(2*(q[x]-q[y]));
}
int main()
{
    n=read();L=read();
    for(int i=1;i<=n;++i)c[i]=read()+c[i-1];
    for(int i=1;i<=n;++i)f[i]=1e18;
    /*
    for(int i=1;i<=n;++i)
        for(int j=0;j<i;++j)
            f[i]=min(f[i],f[j]+sqr(c[i]-c[j]+i-j-1-L));
    */
    //以上内容为O(n^2)的暴力转移
    for(int i=1;i<=n;++i)q[i]=c[i]+i;
    for(int i=1;i<=n;++i)T[i]=c[i]+i-L-1;
    for(int i=1;i<=n;++i)
    {
        while(h<t&&count(s[h],s[h+1])<=T[i])h++;
        int get=s[h];
        f[i]=f[get]+sqr(T[i]-q[get]);
        while(h<t&&count(s[t-1],s[t])>=count(s[t],i))t--;
        s[++t]=i;
    }
    printf("%lld\n",f[n]);
    return 0;
}

```

---

## 作者：MZW_BG (赞：2)



[题面](https://www.Luogu.org/probLemnew/show/P3195)
大意：~~自己看太复杂我不想解释了~~

---
终于，我要开始复习我目前接触到的最毒瘤、思考难度最大的算法了。

**斜率优化。**

简单介绍一下： ~~斜率优化在我看来就是利用一个玄学的方法确定一个值，然后用这个值去确定以前的一些状态是否没有用，再结合单调队列或其他数据结构减少DP过程中的继承次数，从而达到加速的目的。~~ 不得不说斜率优化**必！须！得！数！形！结！合！**

斜率优化是将每一个状态转换成决策点，再用求最小截距等方法加速的

废话少说我们来做题

首先我们可以飞快地想出$O(n^2)$的算法：

$f[i]$表示前$i$个玩具被装好的最小花费

然后

$$f[i]=\min\limits^{i-1}_{j=0}(f[j]+(i-j-1+\sum\limits^{i}_{k=j+1}a[i]-L)^2)$$
即将第$j+1$到第$i$个放到一个盒子中

（请原谅我用了一种玄学的方式表示求最小值）

其中$\sum\limits^{i}_{k=j+1}a[i]$一部分可以用前缀和求

```cpp
#incLude<cstdio>
#incLude<cstring>
using namespace std;
Long Long min(register Long Long a,register Long Long b)
{return a<b?a:b;}
Long Long sqr(register Long Long x)
{return x*x;}
int a[51000],sum[51000];
Long Long f[51000];
int main()
{
	int n,l;
	scanf("%d%d",&n,&l);
	for(int i=1;i<=n;i++)
		scanf("%d",a+i),sum[i]=sum[i-1]+a[i];
	memset(f,1,sizeof(f));
	f[0]=0;
	for(int i=1;i<=n;i++)
		for(int j=0;j<n;j++)
			f[i]=min(f[i],f[j]+sqr(i-j-1+(sum[i]-sum[j])-l));
	printf("%LLd",f[n]);
	return 0;
}
```
可以成功地获得20分

---
接下来优化的时间就到了

首先，我们从状态转移方程入手：
```cpp
f[i]=min(f[i],f[j]+sqr(i-j-1+(sum[i]-sum[j])-l));
```
可以发现，记$s[i]=sum[i]+i$，$L=L+1$可以简化方程

则有：
```cpp
f[i]=min(f[i],f[j]+sqr(s[i]-s[j]-l));
```
然后我们开始数形结合

（PS.:本来这后面有一段两千多字打了我整整一天的推导，最后发现根本\*\*不通——请原谅我因为实在是太生气了）（**数形结合万岁！**）

简单地讲，现在优化的目的就是尽快地找到这个使$f_i$最小化的$j$

所以，我们设$j$就是令$f_i$最小化的继承状态

$f_i=f_j+(s_i-s_j-L)^2$

将这个方程展开，并将其转化为$y=kx+b$的形式

其中，$y$与$x$要包含所有与$j$有关的项，且$x$要保证随$j$单调递增（方便构建模型），$k,b$是与$j$无关的值，$b$要包含$f_i$

原式$=f_i=f_j+{s_i}^2-2s_i(s_j+L)+(s_j+L)^2$

$f_i-{s_i}^2=f_j-2s_i(s_j+L)+(s_j+L)^2$

$f_i-{s_i}^2+2s_i(s_j+L)=f_j+(s_j+L)^2$

$即f_j+(s_j+L)^2=2s_i(s_j+L)+f_i-{s_i}^2$

其中：

$y=f_j+(s_j+L)^2$

$k=2s_i$

$x=s_j+L$

（由$2s_i(s_j+L)$拆成）

$b=f_i-{s_i}^2$

这样，我们就得到了对于$j$的坐标描述：

$(s_j+L,f_j+(s_j+L)^2)$

不逼逼上图
![](https://img-blog.csdnimg.cn/20190701195330136.png)
就是这样，我们要找到一个点把那条线挂上去

线的斜率不变，又需要挂在最低的地方

点从左到右依次加入

观察一下，除了图中的那几个折线上的点，其它点想都不用想就可以淘汰：

![](https://img-blog.csdnimg.cn/20190701195640154.png)
因为它们被挡住了。

而再观察这条折线，上面任意的三个点$A,B,C$若满足$x_A<x_B<x_C$，就有$AB$的斜率小于$BC$的斜率。（记任意两点$B,C$的斜率为$\operatorname{slop}(B,C)$）

结合点的加入方式和最优化的需求，考虑$O(1)$查询最值+末端插入的单调队列

（记单调队列为$q$，队尾下标为$tail$，队头下标为$head$，新加入的点为$i$）

推出淘汰队列末尾的标准：

**当$\operatorname{slop}(q_{tail-1},q_{tail})\ge\operatorname{slop}(q_{tail},i)$时，剔除$q_{tail}$**

而又从单调队列引出一个问题：如何删队头？

这简单：~~由图可知~~**斜率小于$k$的就删掉**~~证明很简单但我很懒~~

如果以后的直线斜率比现在小了怎么办？

$k=2s_i$——$s_i$是和$i$一起递增的。

由此，单调队列所有操作全部推出。

代码：

```cpp
#include<cstdio>
#define ll long long
using namespace std;
int l;
struct deque
{
	int list[51000];
	int head,tail;//head~tail
	
	deque():head(1),tail(0){}
	int size(){return tail-head+1;}
	
	int front(){return list[head];}
	void push_front(int x){list[--head]=x;}
	void pop_front(){++head;}
	int front_2nd(){return list[head+1];}
	
	int back(){return list[tail];}
	void push_back(int x){list[++tail]=x;}
	void pop_back(){--tail;}
	int back_2nd(){return list[tail-1];}
};//手打deque
ll sqr(ll x)
{return x*x;}
int a[51000];
ll s[51000];
ll f[51000];
double slop(ll a,ll b)
{return (f[b]+sqr(s[b]+l)-f[a]-sqr(s[a]+l))/(double)(s[b]-s[a]);}
int main()
{
	int n;
	scanf("%d%d",&n,&l);l++;
	for(int i=1;i<=n;i++)
		scanf("%d",a+i),s[i]=s[i-1]+a[i]+1;
	deque q;
	q.push(0);//很重要！！！要初始化！！！
	f[0]=0;
	for(int i=1;i<=n;i++)
	{
		while(q.size()>1&&slop(q.front(),q.front_2nd())<=2*s[i])q.pop_front();
		f[i]=f[q.front()]+sqr(s[i]-s[q.front()]-l);
		while(q.size()>1&&slop(q.back_2nd(),q.back())>=slop(q.back(),i))q.pop_back();
		q.push_back(i);
	}
	printf("%lld",f[n]);
	return 0;
}
```

参考资料：[LB不顶用](http://www.360doc.com/content/19/0120/11/5315_810145904.shtml)

---

## 作者：_Sein (赞：2)

## 思路
理解题意之后，发现

## 斜率优化真是一个大坑
$F_i$为最近一个箱子装到第$i$件物品的花费

首先我们来看看状态转移方程
($sum$为前缀和)

$$F_i=\min(F_i,F_j+(sum_i-sum_j+(i-(j+1))-L)^2)$$

$$=\min(F_i,F_j+((sum_i+i)-(sum_j+j)-(L+1))^2)$$

设$s_i=sum_i+i,s_j=sum_j+j,L=L+1$，

则
$$F_i=\operatorname{min}(F_i,F_j+(s_i-s_j-L)^2)$$

设有
$F_j+(s_i-s_j-L)^2\ge F_k+(s_i-s_k-L)^2(j<k<i)$

说明在$i$时，$k$优于$j$。

那么对于后面状态$t$呢，是否有$F_j+(s_t-s_j-L)^2\ge F_k+(s_t-s_k-L)^2$

证明:

显而易见的，$s_t=s_i+val(val>0)$，则

$$F_j+(s_t-s_j-L)^2=F_j+(s_i-s_j-L+val)^2$$
②

$$ F_k+(s_t-s_k-L)^2=F_k+(s_i-s_j-	L+val)^2 $$
③

由$②$得:

$$F_j+(s_i-s_j-L)^2+2*val*(s_i-s_j-L)+val^2$$

由$③$得

$$F_k+(s_i-s_j-L)^2+2*val*(s_i-s_k-L)+val^2$$

比较上述二式，并结合$①$,可知

只要证明$s_i-s_j-L>s_i-s_k-L$即可

$-s_j>-s_k$

由于$s_j<s_k$，则不等式成立。

所以在$i$时，$k$优于$j$，那么在后面状态时，$k$永远优于$j$。

## 如何淘汰$j$(队头)

$$F_j+(s_i-s_j-L)^2\ge F_k+(s_i-s_k-L)^2 $$
$$F_j+(s_i-L)^2-2*s_j*(s_i-L)+s_{j}^{2}\ge F_k+(s_i-L)^2-2*s_k*(s_i-L)+s_{k}^{2}$$
$$ F_j-F_k+s_j^2-s_k^2\ge 2*(s_j-s_k)*(s_i-L)$$

由$s_k>s_j$可知，

$$\frac{F_j-F_k+s_j^2-s_k^2}{s_j-s_k}\le 2*(s_i-L)$$

设$x_1=F_j+s_j^2,x_2=F_k+s^2_k,y_1=s_j,y_2=s_k$

则
$$calc(j,k)=\frac{x_1-x_2}{y_1-y_2}\le2*(s_i-L)$$

这句话的意思就是$k$比$j$更优，所以$j$(先进队列)就没有存在的必要，要踢去。

## 踢队尾

我们首先一定要确定$i$这个状态，要优于$q_{tail}$

要维护的队列由于$q_{tail-1}$一定优于$q_{tail}$

现有一个标准值$2*(s_t-L)(tail<t)$

$calc(q_{tail-1},q_{tail)}\ge 2*(s_t-L)$

如果$q_{tail}$要优于$i$，

则$calc(q_{tail},i)\ge calc(q_{tail-1},q_{tail})$

才能确保$q_{tail}$优于$i$

反之，当$calc(q_{tail},i)\le calc(q_{tail-1},q_{tail})$时，需要删去队尾。

貌似就没了哦。


## 最后几句话
本题维护的是一个下凸壳(我的做法是这样的)，所以斜率优化真是一个神奇的东西。

## AC code
```cpp
#pragma GCC optimize("Ofast")
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<iostream>
#define gc getchar()
#define ll long long
using namespace std;
const int N=5e4+10;
inline void qr(ll &x)
{
	x=0;int f=1;char c=gc;
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=gc;}
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=gc;}
	x*=f;
}
void qw(ll x)
{
	if(x<0)x=-x,putchar('-');
	if(x/10)qw(x/10);
	putchar(x%10+48);
}
ll s[N],f[N];
int q[N],l,r;
double calc(int j,int k)
{
	return (f[j]-f[k]+s[j]*s[j]-s[k]*s[k])/(double)(s[j]-s[k]);
}
int n,L;
int main()
{
	scanf("%d%d",&n,&L);++L;
	for(int i=1;i<=n;i++)qr(s[i]),s[i]+=s[i-1]+1;
	l=1;r=1;q[1]=0;
	for(int i=1;i<=n;i++)
	{
		while(l<r&&calc(q[l],q[l+1])<=2.0*(s[i]-L))++l;
		f[i]=f[q[l]]+(s[i]-s[q[l]]-L)*(s[i]-s[q[l]]-L);
		while(l<r&&calc(q[r],i)<=calc(q[r-1],q[r]))--r;
		q[++r]=i;
	}
	qw(f[n]);puts("");
	return 0;
}
```

---

## 作者：lahlah (赞：2)

# [problem](https://www.luogu.org/problemnew/show/P3195)
___
___
## Solution
### 20'DP:

$dp[i] = min(dp[j] + (sum[i] - sum[j - 1] + i - j - L)^2)$

code:

```cpp
#include<bits/stdc++.h>
#define N 500005
#define int long long
using namespace std;
int sqr(int x){
	return x * x;
}
int n, L, a[N], sum[N], f[N];
signed main(){
	scanf("%lld%lld", &n, &L);
	for(int i = 1; i <= n; i ++) scanf("%lld", &a[i]), sum[i] = a[i] + sum[i - 1];
	memset(f, 0x3f, sizeof f);
	f[0] = 0;
	for(int i = 1; i <= n; i ++){
		for(int j = 1; j <= i; j ++){
			f[i] = min(f[i], f[j - 1] + sqr(sum[i] - sum[j - 1] + i - j - L));
		}
	}
	printf("%lld", f[n]);
	return 0;
}

```


## 斜率优化
可以变成
$dp[i] = min(dp[j] + (sum[i] - sum[j] + i - j - L - 1)^2)$

令 $a[i] = sum[i] + i, b[i]=sum[i]+i+L+1$

$dp[i] = min(dp[j] + (a[i]-b[j])^2)$

$dp[i] = dp[j] + a[i]^2+b[j]^2-2·a[i]·b[j]$

$2·a[i]·b[j] + dp[i] -a[i]^2= dp[j]+b[j]^2$

把$b[j]$看做$x$，$dp[j]+b[j]^2$看做$y$

$y=2·a[i]x+dp[i]-a[i]^2$

这就是一条直线的解析式，$y=kx+b, k=2·a[i],b=dp[i]-a[i]^2$

要找一个点$P(b[j],dp[j]+b[j]^2)$使得上面的斜率为2*a[i]的直线过这个点且与$y$轴截距$(b=dp[i]-a[i]^2)$最小

因为斜率$k=2·a[i]$是固定的，所以要求的就是最小的$b$,把它加上$a[i]^2$就是$dp[i]$的值
___
### 大概就是这样

![233](https://i.loli.net/2019/06/06/5cf8a82eed5f943608.png)

就变成了用一条斜率为$k=2·a[i]$的直线从下到上（或从右到左）扫过去，碰到的第一个点后把直线和$y$轴的截距求出来加上$a[i]$就是答案

很明显就是维护一个下凸壳(1/4)

___



然后就单调队列维护嘛。。

设$Slope(i,j)$为    $P_i, P_j$ 的斜率

如果$Slope(Q_{head}, Q_{head + 1}) <=2·a[i]$就 $head ++$


$Slope(Q_{tail}, Q_{tail - 1}) >= Slope(Q_{tail - 1}, i)$就 $tail --$



code:
```cpp
#include<bits/stdc++.h>
#define N 1000005
#define int long long//hei hei
#define double long double //开long double 防止精度丢失
using namespace std;
int q[N], n, L, sum[N], dp[N];
double a(int i) {return sum[i] + i;}
double b(int i) {return sum[i] + i + L + 1;}
double x(int i) {return b(i);}
double y(int i) {return dp[i] + b(i) * b(i);}
double Slope(int i, int j) {return (y(i) - y(j)) / (x(i) - x(j));}
signed main(){
	scanf("%lld%lld", &n, &L);
	for(int i = 1; i <= n; i ++) scanf("%lld", &sum[i]), sum[i] += sum[i - 1];
	int l = 1, r = 1;
	for(int i = 1; i <= n; i ++){
		while(l < r && Slope(q[l], q[l + 1]) < 2 * a(i)) l ++;
		int j = q[l]; 
		dp[i] = dp[j] + (a(i) - b(j)) * (a(i) - b(j));//截距就是把x=2*b[j]代入斜率为2*a[i]的直线，解除b，加上a[i]就是dp[i],化简完就是这样
		while(l < r && Slope(q[r - 1], q[r]) > Slope(i, q[r - 1])) r --;
		q[++ r] = i;
	}
	printf("%lld", dp[n]);
	return 0;
}

```



















---

## 作者：ysy20021208 (赞：2)

###### 1.列方程

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们先想这道题的dp式子，先不管时间复杂度的问题。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个式子应该很好想：$ f[i]=min \{ f[j]+( \sum_{k=j+1}^{i} lenth[k] +i−j−l)^{2} \}$，我们来分析一下时间复杂度：$ O(n^3) $。   

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;想一下优化，我们是不是可以将求和部分写成前缀和的形式？将$ \sum $的部分化成$ sum[i] $。这样我们就可以将式子转化成$ f[i]=min \{ f[j]+( sum[i] -sum[j] +i−j−l)^{2} \} $，这样的话时间复杂度就降低成为$ O(n^2) $。时间是更低了，但是还是过不了啊，这是我们就要等价地变换式子，使其成为y=kx+b的形式，这个形式就是斜率优化的核心。

###### 2.转化式子

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$ f[i]=min \{ f[j]+( sum[i] -sum[j] +i−j−l)^{2} \} \downarrow$

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$ f[i]= f[j] + [ ( sum[i] + i ) - ( sum[j] + j ) - l ]^2 \downarrow $

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;令$ s[i]=sum[i]+i \downarrow$

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$ f[i]=f[j]+( s[i] -s[j] - l)^2 $

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$ f[i] = f[j] + s[i]^2 + ( s[j] + l ) ^2 - 2\times s[i] \times ( s[j] + l) \downarrow$

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$ f[j] + s[i]^2 + ( s[j] + l )^2 = 2 \times s[i] \times ( s[j] +l ) + f[i] $

###### 3.分析式子

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$ f[j] + s[i]^2 + ( s[j] + l )^2 = 2 \times s[i] \times ( s[j] +l ) + f[i] $

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;观察上面的式子，我们发现这个式子十分像一种函数，y=kx+b，可能大家会有疑问，这个式子和直线的表达是有什么形似之处呢？

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们将$ f[j] + s[i]^2 + (s[j] + l)^2 $这个部分看做一个整体记为$ y $，这个部分可以看成一个整体的条件是：这个整体中的所有部分都是已求出的，并且当知道$ i $和$ j $之后可以$ O(1) $求出。显然这个整体满足。同理我们将$ 2 \times s[i] $和$ (s[i] + l) $这两个部分也分别看做整体，并分别记为$ k $、$ x $。这样式子就化为$ y=kx+f[i] $。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下一步，我们建立以个平面直角坐标系，这个平面直角坐标系中的每一个点的坐标$ （x，y） ​$都对应的是上面式子中的$ x ​$和$ y ​$，这样我们就能够将每一个与$ i ​$有关的东西处理完事之后标到平面直角坐标系之中。每一个点的坐标表成$ ( s[i]，f[i] + （s[i] + l）^2 ) ​$，可能有人会问为什么纵坐标没有了$ s[i]^2 ​$，并且横坐标没有了$ l ​$，这个问题下面会解答，请稍作等待。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们想用$ j $来转移$ i $的话，就要让斜率为$ 2 \times s[i] $的直线过点$ (s[j]，f[j] + （s[j] + l）^2) $，并且此时直线的截距就是新的$ f[i] $，因为$ f[i] $为这条直线的$ b $。再看下面的图解，我们将求过的点都标到平面直角坐标系中，我们可以发现，我们想过的这个点一定在我们维护的大圆包上，像点2这样的点就不能被用来更新，因为过点3所得截距，一定比过点2所得截距小，那么我们能发现当点3求出之后，只要比较一下，点2和点3形成的直线的斜率和点1和点2形成的直线的斜率，如果2、3形成的比1、2形成的要小，那么3号点一定比2号点更优。我们再看，假设下图之中已经维护好1到5的所有点，那么就会出现这样的大圆包。我们用求出6的点的直线去和这些点相交，我们发现只有点4在当前直线上时能使截距最小（画一画图就能发现是过点4时，直线的截距最小），根据是由点4转移，我们可以发现，当两个点1、3的斜率小于$ 2 \times s[i] $的时候，横坐标小的点一定不能用来转移，同理斜率大于$ 2 \times s[i] $的两个点，横坐标大的也不能够用来转移，这个性质是不是很好？

![](https://images2018.cnblogs.com/blog/1257114/201809/1257114-20180911205634537-676700193.png)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据上面我们发现的式子，我们可以维护一个类似于单调队列的队列来维护我们的大圆包。但是这个大圆包具体怎么维护呢？我们先看如何求斜率。如果给你直线上的两个点，我想大家一定会求斜率。就是两点的纵坐标相减的差除上两点的横坐标相减的差。这里也就解释了，为什么上文中的纵坐标没有了$ s[i]^2 $，因为两式相减时$ s[i] $是相同的，从而$ s[i]^2 $也就是相同的，所以相减时就将其减掉了，因此$ s[i]^2 $不用出现在纵坐标之中。同理在相减时我们的横坐标也不需要$ l $。

```c++
double re_x(int i){return s[i];}
double re_y(int i){return f[i]+(s[i]+l)*(s[i]+l);}
double re_k(int i,int j){return (re_y(j)-re_y(i))/(re_x(j)-re_x(i));}
```

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;会求斜率了，我们再来看怎么维护大圆包，我们发现当队列中最后一个的点和队列中倒数第二个点的产生斜率大于最后一个点和新产生的点产生的斜率，那么结尾就要弹出队列，这个用一个$ whlie $循环就能够解决，最后再将新产生的点放在结尾。这个实现十分像单调队列的实现。

```C++
int main()
{
    while(head<tail&&re_k(q[tail],i)<re_k(q[tail],q[tail-1])) tail--;
    q[++tail]=i;
}
```

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们再看，怎么满足第二个性质，让更新变成$ O(1) $的？我们发现当队列中第一个点和第二个点产生的斜率如果小于当前的直线，那么第二个点更新一定比第一个点更新更优，我们就要进行队首弹出。这个过程也十分像单调队列的维护。最后直接用队首进行更新。

```c++
int main()
{
    while(head<tail&&re_k(q[head],q[head+1])<2*s[i]) head++;
    f[i]=f[q[head]]+(s[i]-s[q[head]]-l-1)*(s[i]-s[q[head]]-l-1);
}
```

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样我们就解决了维护的问题，最后就是将这些组装在一起，形成下方的代码。

```C++
#include <stdio.h>
#define N 50001
int n,l,head,tail;
long long f[N],s[N],q[N];
double re_x(int i){return s[i];}
double re_y(int i){return f[i]+(s[i]+l)*(s[i]+l);}
double re_k(int i,int j){return (re_y(j)-re_y(i))/(re_x(j)-re_x(i));}
int main()
{
    scanf("%d%d",&n,&l);
    for(int i=1;i<=n;i++)
		scanf("%lld",&s[i]),s[i]+=s[i-1];
    for(int i=1;i<=n;i++) s[i]+=i;
    q[tail]=0;
    for(int i=1;i<=n;i++)
    {
		while(head<tail&&re_k(q[head],q[head+1])<2*s[i]) head++;
		f[i]=f[q[head]]+(s[i]-s[q[head]]-l-1)*(s[i]-s[q[head]]-l-1);
		while(head<tail&&re_k(q[tail],i)<re_k(q[tail],q[tail-1])) tail--;
		q[++tail]=i;
    }
    printf("%lld\n",f[n]);
}
```

---

## 作者：封禁用户 (赞：2)

### 题目大意：

有编号 _1~n_ 的 _n_ 样物品。

第i样压缩成一维以后长度为 _c[i]_ 

把第 _i~j_ 号物品放入容器长度为 _j-i+cigema(i<=k<=j) c[k]_ 

呢么若长度为x，费用为： _(x-l)^2   L为常量_ 

### 解题思路：

####  _f[i]=min(0<=j<i){f[j]+(cigema(j+1<=k<=i) c[k]+i-j-1-L)^2}_

令_sum[i]_ 为_c_的前缀和;

则，上式=> _f[i]=min(0<=j<i{f[j]+(sum[i]-sum[j]+i-j-1-L)^2})_

令_a[i]=sum[i]+i_

_f[i]=min(0<=j<i){f[j]+(a[i]-a[j]-1-L)^2}_

暴力n^2;使用斜率优化。

代码如下：

```cpp
#include<cstdio>
#define N 50005
using namespace std;
long long n,L,f[N],sum[N],a[N],sqr[N],que[N];
double calc(long long x,long long y){
    return (double)(f[y]+sqr[y]-f[x]-sqr[x])/(a[y]-a[x]);
}
int main(){
    scanf("%lld%lld",&n,&L);
    sqr[0]=(L+1)*(L+1);
    for (long long i=1;i<=n;i++){
        scanf("%lld",&sum[i]);
        sum[i]+=sum[i-1];
        a[i]=sum[i]+i;
        sqr[i]=(a[i]+L+1)*(a[i]+L+1);
    }
    long long l=0,r=0;
    for (long long i=1;i<=n;i++){
        while (l<r&&calc(que[l],que[l+1])<=(a[i]<<1)) l++;
        f[i]=f[que[l]]+(a[i]-a[que[l]]-L-1)*(a[i]-a[que[l]]-L-1);
        while (l<r&&calc(que[r],i)<calc(que[r-1],que[r])) r--;
        que[++r]=i;
    }
    printf("%lld\n",f[n]);
    return 0;
}
```

---

## 作者：chihik (赞：1)

这道题像我这样的 $dp$ 蒟蒻都能一眼看出 $dp$ 式：

设 $sum$ 为 $c$ 的前缀和，则有

$$
dp[i]=min\{ dp[j]+((i-j-1)+(sum[i]-sum[j])-L)^2 \} ~~ (0 \le j < i)
$$

就可以$\Theta(n^2)$解决了 ，~~开O2骗了70分~~。

考虑优化，令$s_i=sum[i]+i$,则有：

$$
dp[i]=min\{ dp[j] + (s_i-s_j-1-L)^2 \} ~~~~ (0 \le j < i)
$$

将 $s_i-1-L$ 看作一个整体拆开平方（它们与决策点 $j$ 无关），得到:

$$
dp[i]=min\{ dp[j] + {s_j}^2 - 2 \times s_j \times (s_i-L-1) \}+(s_i-L-1)^2 ~~~~ (0 \le j < 0)
$$

$$
dp[i]=min\{ dp[j] + {s_j}^2 - 2s_is_j + 2Ls_j + 2s_j  \}+(s_i-L-1)^2 ~~~~ (0 \le j < 0)
$$

然后是斜优的套路，设两个决策点 $j,k (j<k)$ 且 $j$ 优于 $k$。即:

$$dp[j] + {s_j}^2 - 2s_is_j + 2Ls_j + 2s_j<dp[k] + {s_k}^2 - 2s_is_k + 2Ls_k + 2s_k$$

$$(dp[j]+{s_j}^2)-(dp[k]+{s_k}^2)+2L(s_j-s_k)+2(s_j-s_k)<2s_i(s_j-s_k)$$

注意$s_j<s_k$ ， 移项变号：

$$
\frac{(dp[j]+{s_j}^2)-(dp[k]+{s_k}^2)+2(L+1)(s_j-s_k)}{s_j-s_k}>2s_i
$$

$$
\frac{(dp[j]+{s_j}^2+2s_j(L+1))-(dp[k]+{s_k}^2+2s_k(L+1))}{s_j-s_k}>2s_i
$$

现在就可以维护一个下凸包解决，时间复杂度$\Theta(n)$。

```cpp
#include <cstdio>
#include <iostream>
using namespace std;
#define LL long long

const int MAXN = 50000;
int n , l , c[ MAXN + 5 ] , Head = 1 , Tail = 0 , Que[ MAXN + 5 ];
LL sum[ MAXN + 5 ] , dp[ MAXN + 5 ];

LL Calc( int i ) {
    return sum[ i ] + i;
}
double Slope( int u , int v ) {
    return ( ( dp[ u ] + Calc( u ) * Calc( u ) + 2 * Calc( u ) * ( l + 1 ) ) - ( dp[ v ] + Calc( v ) * Calc( v )+ 2 * Calc( v ) * ( l + 1 ) ) ) / ( Calc( u ) - Calc( v ) );
}

int main( ) {
    scanf("%d %d",&n,&l);
    for( int i = 1 ; i <= n ; i ++ )
        scanf("%d",&c[ i ]) , sum[ i ] = sum[ i - 1 ] + c[ i ];
    
    Que[ ++ Tail ] = 0;
    for( int i = 1 ; i <= n ; i ++ ) {
        while( Head < Tail && Slope( Que[ Head ] , Que[ Head + 1 ] ) < 2 * Calc( i ) ) Head ++;

        dp[ i ] = dp[ Que[ Head ] ] + ( Calc( i ) - Calc( Que[ Head ] ) - 1 - l ) * ( Calc( i ) - Calc( Que[ Head ] ) - 1 - l );
        while( Head < Tail && Slope( Que[ Tail - 1 ] , Que[ Tail ] ) > Slope( Que[ Tail - 1 ] , i ) ) Tail --;
        Que[ ++ Tail ] = i;
    }

    printf("%lld",dp[ n ]);
    return 0;
}
```



---

## 作者：crashed (赞：1)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.com.cn/problem/P3195)看题目。  
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不难看出是一个$dp$题：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$f(i)$：前$i$个物品装进箱子里面的最小花费。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;转移很简单：  
$$f(i)=\min_{0\le j<i}\{f(j)+(i-j-1+\sum_{k=j+1}^iC_k-L)^2\}$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设$s_i=(\sum_{j=1}^i C_j)+i$，代入得到：  
$$f(i)=\min_{0\le j<i}\{f(j)+(s_i-s_j-L-1)^2\}$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时间是$O(n^2)$。考虑优化。二次项这种东西告诉我们，这个应该和斜优有关。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设$0\le j<k<i\Rightarrow s_j<s_k$，若在$j$转移比$k$优：  
$$f(j)+(s_i-s_j-L-1)^2<f(k)+(s_i-s_k-L-1)^2$$  
$$\Rightarrow f(j)-2s_is_j+s_j^2+2s_j(L+1)<f(k)-2s_is_k+s_k^2+2s_k(L+1)$$  
$$\Rightarrow [f(j)+s_j^2+2s_j(L+1)]-[f(k)+s_k^2+2s_k(L+1)]<2s_i(s_j-s_k)$$  
$$\Rightarrow \frac {[f(j)+s_j^2+2s_j(L+1)]-[f(k)+s_k^2+2s_k(L+1)]}{s_j-s_k}>2s_i$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;感性理解就是，如果两点的斜率$>2s_i$，那么前一个点更优，否则就是后一个点更优。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后不难发现我们需要维护一个下凸包。然后用单调队列做一做就可以了。时间$O(n)$。  
# 代码
```cpp
#include <cstdio>

typedef long long LL;

const LL INF = 0x3f3f3f3f3f3f3f3f;
const int MAXN = 50005;

template<typename _T>
void read( _T &x )
{
	x = 0; char s = getchar();int f = 1;
	while( s < '0' || '9' < s ) { f = 1; if( s == '-' ) f = -1; s = getchar(); }
	while( '0' <= s && s <= '9' ) { x = ( x << 3 ) + ( x << 1 ) + s - '0', s = getchar(); }
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ) { putchar( '-' ), x = -x; }
	if( 9 < x ) { write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
_T MIN( const _T a, const _T b )
{
	return a < b ? a : b;
}

struct vector
{
	LL x, y;
	vector(){}
	vector( const LL X, const LL Y ) { x = X, y = Y; } 
	LL mul( const vector & other ) const { return x * other.y - other.x * y; }
	bool operator >= ( const vector & other ) const { return mul( other ) <= 0; }
};

LL f[MAXN], s[MAXN], p[MAXN];
LL L;
int deq[MAXN], h, t;
int N;

LL sqr( const LL a ) { return a * a; }

LL Y( const LL i ) { return f[i] + sqr( p[i] ) + 2 * p[i] * ( L + 1 ); }
LL X( const LL i ) { return p[i]; }
LL getDP( const LL i, const LL j ) { return f[j] + sqr( p[i] - p[j] - L - 1 ); }

int main()
{
	read( N ), read( L );
	for( int i = 1, tmp ; i <= N ; i ++ ) read( tmp ), s[i] = s[i - 1] + tmp, p[i] = s[i] + i;
	f[0] = 0, h = 1, t = 0, deq[++ t] = 0;
	for( int i = 1 ; i <= N ; i ++ )
	{
		while( h < t && Y( deq[h] ) - Y( deq[h + 1] ) >= 2 * p[i] * ( X( deq[h] ) - X( deq[h + 1] ) ) ) h ++;
		f[i] = getDP( i, deq[h] );
		while( h < t && vector( X( deq[t] ) - X( deq[t - 1] ), Y( deq[t] ) - Y( deq[t - 1] ) ) >=
						vector( X( i ) - X( deq[t] ), Y( i ) - Y( deq[t] ) ) ) t --;
		deq[++ t] = i;
	}
	write( f[N] ), putchar( '\n' );
	return 0;
}```

---

## 作者：cold_cold (赞：1)

 [安利一波博客](https://www.cnblogs.com/cold-cold/p/10103100.html)


显然dp方程可以得出为dp[i]=min{dp[j]+(sum[i]+i−sum[j]−j−L−1)2}

但是这种dp方式是O(n2)的，我们可以使用斜率优化的方法将其优化成O(n)

我们考虑将原DP方程变形

1.  dp[i]=dp[j]+(sum[i]+i−sum[j]−j−L−1)^2    　　　　将L++

2.  dp[i]=dp[j]+(sum[i]+i−sum[j]−j−L)^2 　　　　　    令sum[i]+=i

3.  dp[i]=dp[j]+(sum[i]−sum[j]−L)^2

将原式子展开

dp[j]+sum[i]^2+(sum[j]+L)^2=2\*sum[i]\*(sum[j]+L)+dp[i]

          y 			  = 	k *   x    +  b

y=dp[j]+sum[i]^2+(sum[j]+L)^2

k=2*sum[i]

x=sum[j]+L

b=dp[i]

所以我们将每一个点(x,y)画在图像上，并维护一个凹包

![](https://img2018.cnblogs.com/blog/1539484/201812/1539484-20181211162629847-430955230.png)

那么我们在求f[i]的值的时候，用一条斜率为2*sum[i]的线切上它能切到的最低点

此时其与y轴的交点的截距为f[i]的最小值

又因为sum[i]单调递增，所以k值只会越来越大

所以选中点前的点全部废弃
![](https://img2018.cnblogs.com/blog/1539484/201812/1539484-20181211163154391-1027468699.png)

因为每个点只会被删一次，所以算法为O(n)

实现采用单调队列：

```cpp
#include <algorithm>
#include <iostream>
#include <cmath>
#include <cstring>
#include <map>
#include <string>
#include <vector>
#include <queue>
#include <stack>
#include <cstdio>
#include <cstdlib>
using namespace std;
typedef long long ll;
inline ll read()
{
    register ll p(1),a(0);register char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
    if(ch=='-') p=-1,ch=getchar();
    while(ch>='0'&&ch<='9') a=a*10+ch-48,ch=getchar();
    return a*p;
}
const int N=50010;
ll n,L,f[N],s[N],Q[N],head=1,tail=1;
//f[i]+2*s[i]*(s[j]+L)=f[j]+s[i]^2+(s[j]+L)^2
double getx(int x) {return s[x];}
double gety(int x) {return f[x]+(s[x]+L)*(s[x]+L);}
double che(int x,int y){return (gety(y)-gety(x))/(getx(y)-getx(x));}
int main()
{
//    freopen("input","r",stdin);
//    freopen("output","w",stdout);
    n=read(),L=read()+1;
    for(int i=1;i<=n;i++) s[i]=s[i-1]+read();
    for(int i=1;i<=n;i++) s[i]+=i;
    for(int i=1,j;i<=n;i++)
    {
        while(head<tail&&che(Q[head],Q[head+1])<2*s[i]) ++head;
        j=Q[head];f[i]=f[j]+(s[i]-s[j]-L)*(s[i]-s[j]-L);
        while(head<tail&&che(Q[tail-1],Q[tail])>che(Q[tail],i)) --tail;
        Q[++tail]=i;
    }
    printf("%lld",f[n]);
    return 0;
}
/*
 
*/
```


---

## 作者：Algha_Porthos (赞：1)

啊，这个是我很早很早之前就想搞懂的知识点了emmm可是一直没有解决。今天总算有机会了！

我今天打算做[P3195](https://www.luogu.com.cn/problem/P3195)，把这道板子肝出来。

## 题意：

你有一个序列，你可以任意地将其中的i-j项合并成一组。并且对于每一组，代价为$(x-L)^2$。其中，$x=j-i+\sum_{k=i}^j C_k$，L为常亮。求最小代价。

## $N^2$ 解法

我们让$s[i]=\sum_{j=1}^i+i$(即前缀和+i)，可以发现状态转移方程可以变成：

$$f[i]=min_{j=0}^{i-1}(f[j]+(s[i]-s[j]-1-l)^2);$$

于是愉快$N^2$暴力，吸氧后70分。

## 午餐

午餐和Atalod一起吃，吃了金拱门。虽然等了很久，但是我们聊了一会儿斜率优化。

## 斜优数论证明

对于上面的这个方程，我们假设对于一个我们将要求的i。有两个j,分别是$j_1,j_2$,我们假设$j_1$的解更小(更优秀)。


$$f[j_1]+(s_i-s_{j_1}-1-l)^2\leq f[j_2]+(s_i-s_{j_2}-1-l)^2$$

拆开：

$$f[j_1]+s_i^2-2*s_i*(s_{j_1}-1-l)+(s_{j_1}-1-l)^2\leq f[j_2]+s_i^2-2*s_i*(s_{j_2}-1-l)+(s_{j_2}-1-l)^2$$

化简：

$$-2*s_i*(s_{j_1}-1-l)+2*s_i*(s_{j_2}-1-l)\leq -f[j_1]+f[j_2]+(s_{j_2}-1-l)^2-(s_{j_1}-1-l)^2$$

再化简：

$$2*s_i*(s_{j_2}-s_{j_1})\leq -f[j_1]+f[j_2]+(s_{j_2}-1-l)^2-(s_{j_1}-1-l)^2$$

再再化简：


$$2*s_i\leq \frac{-f[j_1]+f[j_2]+(s_{j_2}-1-l)^2-(s_{j_1}-1-l)^2}{(s_{j_2}-s_{j_1})}$$

经过我们的推导，我们发现，只要任意的$j_1,j_2$满足上式子，$j_1$就更优秀，也就是$j_1$更小。
接下来，我们发现，我们可以根据下标与下标所对应的值建立一个个散点。

![](https://cdn.luogu.com.cn/upload/image_hosting/swcmvou8.png)

根据我们的推论，$2*s_i$作为斜率，我们应当找到某个j作为**转移决策点**，而且这个转移决策点需要保证让$f[i]$最小。

借用上面的一个公式：
$$f[i]=f[j]+(s[i]-s[j]-1-l)^2;$$

$f[j]$就是高度,$(s[i]-s[j]-1-l)^2$是斜率

然后发现我们要做的只是拿一条斜率为$2*s[i]$的直线去逼近它，找到第一个决策点。
![](http://47.103.204.220/picture_bed/uploads/2020/02/1.jpg)

我们可以发现，只有这些散点中能够成下凸壳的那些点才有可能成为决策点。

![](http://47.103.204.220/picture_bed/uploads/2020/02/2.jpg.png)

然后队列或者栈维护凸壳。

而这个方程，前缀和单增，y=x单增，所以$s_i$单增，所以斜率单增，满足斜率单调性。

对于有决策单调性的方程，决策点一定会会后移或不动，不可能前移。每个点是最多进队一次，出队一次。复杂度$O(n)$

对于没有决策单调性的点，决策点可能乱跳。每个点进栈出栈最多一次。对于每一个i，在凸壳上二分即可找到决策点。复杂度$O(n log n)$

此题吸氧70分的$O(n^2)$做法

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=52505;
int f[N],a[N],s[N];
int q[N],be,ed;
int n,l;
int X(int j){
	return s[j];
}
int Y(int j){
	return f[j]+(s[j]+l)*(s[j]+l);
}
long double slope(int i,int j){
	return (long double)(Y(j)-Y(i))/(X(j)-X(i));
}
signed main(){
	cin>>n>>l;
	for(int i=1;i<=n;++i){
		scanf("%lld",&a[i]);
		s[i]=s[i-1]+a[i]+1;
	}
	q[++ed]=1;
	for(int i=1;i<=n;++i){
		f[i]=0x3f3f3f3f3f3f3f3f;
		for(int j=0;j<i;++j)
			f[i]=min(f[i],f[j]+(s[i]-s[j]-1-l)*(s[i]-s[j]-1-l));
	}
	cout<<f[n];
}
```
斜优$O(n)$做法
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=52505;
int f[N],a[N],s[N];
int q[N],be,ed;
int n,l;
int X(int j){
	return s[j];
}
int Y(int j){
	return f[j]+(s[j]+l)*(s[j]+l);
}
long double slope(int i,int j){
	return (long double)(Y(j)-Y(i))/(X(j)-X(i));
}
signed main(){
	cin>>n>>l;
	for(int i=1;i<=n;++i){
		scanf("%lld",&a[i]);
		s[i]=s[i-1]+a[i]+1;
	}
	q[++ed]=1;
	for(int i=1;i<=n;++i){
//		f[i]=0x3f3f3f3f3f3f3f3f;
//		for(int j=0;j<i;++j)
//			f[i]=min(f[i],f[j]+(s[i]-s[j]-1-l)*(s[i]-s[j]-1-l));
		while(be<=ed&&slope(q[be],q[be+1])<=2*s[i])
			be++;
		f[i]=f[q[be]]+(s[i]-s[q[be]]-1-l)*(s[i]-s[q[be]]-1-l);
		while(be<=ed&&slope(q[ed-1],q[ed])>=slope(q[ed-1],i))
			ed--;
		q[++ed]=i;
	}
	cout<<f[n];
}
```


---

## 作者：枫林晚 (赞：1)

#### 题目大意：

有n个数，要将他们分成若干段，每一段的cost定义为：
cost=r-l+ΣCk (k∈[r,l])
该段的最终花费是：(cost-L)^2;
给出L,n,C(1~n)，总共的最小花费。

#### 分析：

dp方程极容易想出来：
f[i]=max(f[j]+(sum[i]-sum[j]+i-j-1-L)^2)
其中sum[i]表示c(1~i)的和。因为取的这一段数从j+1开始，所以i-j-1（题目中i-j并不是区间长度！没有再加1）

O(n^2)直接挂掉。

因为状态O(n)已经非常不错，无法再优化了。所以考虑能不能优化转移的O(n)。

将表达式展开：

f[i]=f[j]+(sum[i]-sum[j]+i-j-1-L)^2

令a[k]=sum[k]+k;x[k]=a[k]+1+
f[i]=f[j]+(a[i]-x[j])^2

f[i]=f[j]+x[j]^2-2a[i]x[j]+a[i]^2

对于给定的i，a[i]^2是一个定值，所以当做常数先不用管，**但是记得最后加上！**

令y[k]=f[k]+x[k]^2;
f[i]=y[j]-2a[i]x[j]

移项：
**y[j]**=2a[i]**x[j]**+f[i]

对于给定的i,我们需要循环所有的j。
对于一个j,我们已经知道了x[j],y[j]。
将它看作一个点，所有的j构成一个点集，横坐标x[j],纵坐标y[j]

而对于给定的i，2a[i]是一个定值，看做斜率，而目标f[i]则是截距，所以要在j的点集之中找到一个点使得这条直线截距最小，本质是将y=2a[i]x的直线平移。

可以发现这些最优解的点必定在边界上。并且发现，斜率是单增的，而x一定也是单增的。所以可以维护一个左上下凸壳。

因为斜率单增，所以若一个点此时不是最优解，那么以后一定也不是最优解，可以直接从头pass掉；每次新增一个点，都要保证这是一个凸包，通过斜率要来从尾pass掉。

所以可以用单调队列维护！单调，在这里是指队列中的元素，每相邻两个元素所代表的点连成的线，其斜率是单调递增的。因为斜率都是正数，所以也就是画出来是一个左上凸包。

注意，**队列中至少要有一个0号元素不能出队**！这里第一个空位置是有意义的。否则就不存在线和斜率了。所以手写队列时，开始hd=tl=0,while判断中hd<tl 保证一定至少有一个元素，并且这个元素不会被其他元素替代。详见代码。

##### 具体步骤：

1.前缀和预处理

2.循环i，先删除队首，再更新答案，再更新队列。

3.输出f[n] GAME OVER

代码：
```cpp
#include<bits/stdc++.h>
#define ll long long 
using namespace std;
const int N=50000+10;
int n,L;
long long f[N];
long long sum[N];
int q[N],hd,tl;
long long a(int i)
{
	return sum[i]+i;
}
long long x(int i)
{
	return sum[i]+i+L+1;
}
long long y(int i)
{
	return x(i)*x(i)+f[i];
}
double slope(int a,int b)
{
	return	((double)y(b)-y(a))/((double)x(b)-x(a));
}//一堆函数
int t;
int main()
{
	scanf("%d%d",&n,&L);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&t);
	    sum[i]=sum[i-1]+t;
	}
	hd=0,tl=0;
	for(int i=1;i<=n;i++)
	{
		while(hd<tl&&slope(q[hd],q[hd+1])<2*a(i)) hd++;//删除
		f[i]=y(q[hd])-2*a(i)*x(q[hd])+a(i)*a(i);
		while(hd<tl&&slope(q[tl-1],q[tl])>slope(q[tl-1],i)) tl--;
		q[++tl]=i;//更新
	}
	printf("%lld",f[n]);
	return 0;
}
```

#### 总结：

1.一个题能用斜率优化，必然能出现y=kx+b 线性形式，其中k是定值，x，y构成点集，b是目标值。

2.一个凸包能用单调队列优化的条件应该满足：
 
 （1）查询的斜率单调
 （2）插入的点横坐标有单调性
  （否则要用平衡树、set）

---

## 作者：zyh2015 (赞：1)

来自我的博客：http://blog.csdn.net/YihAN\_Z/article/details/65449992

这里用一个与楼下不同的斜率优化方法

设状态f(i)表示将前i个玩具装箱后的最小费用，sum(i)表示前i个玩具的长度(c值)和

易得状态转移方程

![这里写图片描述](http://img.blog.csdn.net/20170324085548517?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWWloQU5fWg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

其中  0 < j < i

为了简化式子，记![这里写图片描述](http://img.blog.csdn.net/20170324085707392?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWWloQU5fWg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

将上式代入，开方[^1]

则对于所有可能的![这里写图片描述](http://img.blog.csdn.net/20170324090319479?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWWloQU5fWg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

![这里写图片描述](http://img.blog.csdn.net/20170324090514521?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWWloQU5fWg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

记![这里写图片描述](http://img.blog.csdn.net/20170324090809304?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWWloQU5fWg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)[^2]

将上式移项后代入，得到![这里写图片描述](http://img.blog.csdn.net/20170324091241757?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWWloQU5fWg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

现在要使b最小，k不变，若固定x，则y越小，b越小，所以维护一个下凸壳。

可以看出x与查询斜率k均单调递增，维护一个有关斜率的单调队列即可。

```cpp
#include <cstdio>
#define N 50005
using namespace std;
typedef long long LL;
const double INF=1e10;
inline LL sq(LL x) { return x*x; }
struct Point {
    LL x,y;
    Point() {}
    Point(LL _x,LL _y):x(_x),y(_y) {}
    double operator ^ (const Point& rhs) const {///get_slope
        if(x==rhs.x) return y>rhs.y ? -INF : INF;
        return (double)(rhs.y-y)/(rhs.x-x);
    }
}q[N];
int n,l=1,r;
LL L,f[N],sum[N];
LL get_ans(LL k) {
    while(l<r && (q[l]^q[l+1])<k) l++;
    return q[l].y-k*q[l].x;
}
void Insert(Point o) {
    while(l<r && (q[r-1]^q[r])>(q[r-1]^o)) r--;
    q[++r]=o;
    return ;
}
int main() {
    scanf("%d%lld",&n,&L); L++;
    for(int i=1;i<=n;i++) scanf("%lld",sum+i), sum[i]+=sum[i-1]+1;
    //DP
    q[++r]=Point(0,0);
    for(int i=1;i<=n;i++) {
        f[i]=get_ans(2*(sum[i]-L))+sq(sum[i]-L);
        Insert(Point(sum[i],sum[i]*sum[i]+f[i]));
    }

    printf("%lld\n",f[n]);
    return 0;
}

```

[^1]: 因为要计算f(i)，固定i，有关于i的量均为已知量。将已知量与常量放在一起开方。


[^2]:因为要斜率优化，所以将f(i)和常量(已知量)放到b中；有关j与有关i的乘积的项中，将有关i的变量和常量看做斜率k，有关j的变量看做x；其余只含有有关j的量的项看做y


---

## 作者：MrMorning (赞：1)

首先就写了一个大暴力：

定义f[i]为已经分配了i个玩具时的最小费用。

方程容易写出:

f[i] = f[j] + w[j][i];

其中$w[j][i] = (sum_i - sum_j + i - (j+1) - l ) ^ 2$

明显地，这是一个O(n2)的算法，只能得到题目30的分数。

所以我们上斜率优化。

首先我们分析复杂度:状态为O(n)，转移为O(n)

状态已经可以认为无法继续优化了（除非使用其他算法），所以我们考虑优化转移。

曾经我们做过很多题目，可以使用单调队列来获得均摊O(1)的转移复杂度，这里也是类似思路。

经过一些推导（这里略去，http://medalplus.com/?p=1751#Solution写的很不错），我们可以知道决策i比决策j优当且仅当(i>j)

$$\frac{f[j]-f[k]+(G[j]+M)^2-(G[k]+M)^2}{2(G[j]-G[k])} < G(x)$$

其中，G[i] = S[i] + i, 常数M = 1 + l, S[i] = S[i-1]+C[i]，x是当前需要进行决策的点.

根据G[x]的定义，可以知道G[x]是单调递增的。

所以我们证明这样两个性质：

性质一：

如果我们把每一个状态抽象成一个点，那么原式可以看作i到j连线的斜率。

我们说：对于一个决策x，其最优决策一定在x决策前面的决策的点连成的一个下凸包上。

对于这个结论：

考虑有一个要加入的点k>j, 且k[j-1][j] > k[j][k]

因为j点已经在这个下凸包上，所以j一定比j-1更优，所以k[j-1][j] < G[x]

又因为k[j][k] < k[j-1][j]，

所以k[j][k] < G[x]

所以k比j更优

所以我们把j点舍弃，在操作中就是从尾端弹出双端队列。

直接把j-1点连上k即可。

这样我们就证明了性质一。

性质二：

因为G[x]单调递增，所以我们可以从前向后弹出最前端元素来保证k[head][head+1] > G[i]

这时k[head]一定是最优的。

根据定义不难得出这个结论。

在两个性质的推导中，我们也得到了维护下凸包的方法，具体详见代码。

下面是代码。


```cpp
#include <bits/stdc++.h>
#define ll long long 
using namespace std;
const int maxn = 50005;
ll n, l;
ll f[maxn];
ll c[maxn], s[maxn], g[maxn];
ll pow(ll n) {return n*n;}
ll que[maxn];
int alpha;
int head, tail, size;
double calck(int a, int b) {
    return (double)(f[b]-f[a]+pow(g[b]+alpha)-pow(g[a]+alpha))/(double)(2*(g[b]-g[a]));
}
int main() {
    scanf("%d %d", &n, &l);
    alpha = l+1;
    s[0] = 0;
    for(int i = 1; i <= n; i++) {
       scanf("%d", &c[i]); 
       s[i] = s[i-1] + c[i];
       g[i] = s[i] + i; 
    }
    f[0] = 0;
    head = 1;
    tail = 1;
    size = 1;
    que[head] = 0;
    for(int i = 1; i <= n; i++) {
        while(size >= 2) {
            int a = que[head];
            int b = que[head+1];
            if(calck(a, b) < g[i]) {
                head++;
                size--;
            }
            else break;
        }   
        int n = que[head];
        f[i] = f[n]+pow(s[i]-s[n]+i-n-1-l);
        if(size>=2){int x = que[tail];
        int y = que[tail-1];
        while(calck(x, i) < calck(y, x)) {
            tail--;
            size--;
            if(size < 2) break;
            x = que[tail];
            y = que[tail-1];
        }}
        tail++;
        que[tail] = i;
        size++;
    } 
    //for(int i = 1; i <= n; i++) cout << f[i] << ' ';
    //cout << endl;
    printf("%lld\n", f[n]);
}
```
欢迎访问[我的博客](http://www.cnblogs.com/gengchen/p/6340921.html)


---


# 高速公路

## 题目描述

C 国拥有一张四通八达的高速公路树。

C 国有 $n$ 个城市，城市之间由一共 $n-1$ 条高速公路连接。除了首都 $1$ 号城市，每个城市都有一家本地的客运公司，可以发车前往全国各地。你可以把它认作以 $1$ 为根的树。两城市的距离定义为它们之间简单路径的长度。

假设有一个人要从 $i$ 号城市坐车出发前往与其距离为 $D$ 的 $j$ 号城市，那么他要花费 $P_i \times D+Q_i$ 元，**且要求满足 $j$ 是 $i$ 的祖先**。由于距离首都越远，国家的监管就越松，所以距离首都越远，客运公司的 $P_i$ 越大，如果 $i$ 号城市是 $j$ 号城市的某个祖先，那么一定存在 $P_i \leq P_j$。

小 T 成为了国家统计局的调查人员，他需要对现在的高速路网进行一次调查，了解从其他每一个城市到达首都 $1$ 号城市所花费的金钱。

因为可能出现多转车（或不转车）的抵达首都的方法，所以人工计算这个结果是十分复杂的。大宁非常的懒，所以请你编写一个程序解决它。

## 说明/提示

#### 数据规模与约定

- 对于前 $40\%$ 的数据 $n \leq 1000$。
- 对于另外 $20\%$ 的数据，$F_i=i-1$
- 对于所有的数据，$1 \leq n \leq 10^6$，$0 \leq Pi,Qi \lt 2^{31}$，保证结果不会大于 $2^{63}-1$。

## 样例 #1

### 输入

```
6
1 9 3 0
1 17 1 9
1 1 1 6
4 13 2 15
4 9 2 4
```

### 输出

```
27
26
7
43
24
```

# 题解

## 作者：pkh68 (赞：13)

### 题面描述

给定一颗树，在树上做dp。

### 解析

这道题转移还是比较好想的，朴素的方程如下：

$$f(i)=min(f(j)+(deep(i)-deep(j))*Pi+Qi)(j∈Prei)$$

但这样的复杂度是$O(n^2)$的，过不掉1000000的数据。

所以我们考虑斜率优化：设决策$j$比决策$k$优秀（$j<k$）。

那么就有：

$$f(j)+(deep(i)-deep(j))*Pi+Qi<f(k)+(deep(i)-deep(k))*Pi+Qi$$

即：

$$f(j)-deep(j)*Pi<f(k)-deep(k)*Pi$$

$$Pi<\frac{f(k)-f(j)}{deep(k)-deep(j)}$$

考虑下图：

![](https://cdn.luogu.com.cn/upload/pic/36216.png)

$j2$肯定不是最优转移，所以最优转移为下凸包。

又因为$Pi$单调递增，所以用单调队列维护即可。

但是，此题是在树的链上转移，所以$dfs$时一颗子树的决策会影响另一颗子树的凸包，而这不符合题意。


我们仔细观察单调队列的性质：发现每次修改只是$++h$,而队列元素本身没有变化，至于队尾，每次是$--t$,并且只修改一个元素。

我们便有了一个自然的思路：记下每一个节点对应的$h$，$t$和对应的被修改的元素，每一次回溯时还原。

但这样一个节点会入队出队多次，复杂度上界仍为$O(n^2)$。

我们考虑二分查找每一次更新的$h$，$t$，这样对于每一个节点有两次二分查找，
回溯还原、状态转移复杂度皆为$Q(1)$，所以总复杂度为$O(nlogn)$。

### 代码如下

```cpp

#include<iostream>
#include<cstdio>
#include<cstdlib>
#define re register
#define N 1000005
#define LL long long
using namespace std;
int n,h,t,Etot=0,head[N],p[N],q[N];
LL deep[N],f[N];
struct Edge{ int to,next,dis; }edge[N];
inline void add(int u,int v,int dis){ edge[++Etot]=(Edge){v,head[u],dis};head[u]=Etot; }
inline double slope(int j,int k){ return 1.0*(f[k]-f[j])/(deep[k]-deep[j]); }
void dfs(int u,int depth){
    deep[u]=depth;
    for(re int i=head[u];i;i=edge[i].next) dfs(edge[i].to,depth+edge[i].dis);
}
void dp(int u){
    int now_h=h,now_t=t,l,r,mid,tmp;
    l=h;r=t-1;tmp=-1;
    while(l<=r){
        mid=(l+r)>>1;
        if(1.0*p[u]<=slope(q[mid],q[mid+1])) tmp=mid,r=mid-1;
        else l=mid+1;
    }
    if(tmp!=-1) h=tmp;else h=t;
    f[u]=f[q[h]]+(deep[u]-deep[q[h]])*p[u]+q[u];
    l=h;r=t-1;tmp=-1;
    while(l<=r){
        mid=(l+r)>>1;
        if(slope(q[mid],q[mid+1])<slope(q[mid+1],u)) tmp=mid,l=mid+1;
        else r=mid-1;
    }
    if(tmp!=-1) t=tmp+1;else t=h;
    int now_q=q[++t];q[t]=u;
    for(re int i=head[u];i;i=edge[i].next) dp(edge[i].to);
    h=now_h;q[t]=now_q;t=now_t;
}
int main(){
    scanf("%d",&n);
    for(re int i=2,u,w;i<=n;++i){
        scanf("%d%d%d%d",&u,&w,&p[i],&q[i]);
        add(u,i,w);
    }
    dfs(1,0);
    for(re int i=head[1];i;i=edge[i].next) h=t=1,q[h]=1,dp(edge[i].to);
    for(re int i=2;i<=n;++i) printf("%lld\n",f[i]);
    return 0;
}
```

### 后记

这道题思路非常巧妙，在$dfs$时没有按套路更改$h$，$t$，而是用二分查找降低了复杂度（因为每一次只修改了一个元素），要仔细体会。

---

## 作者：xuxinyu (赞：8)

设dp[i] 表示第i个城市到根节点的最小花费

dp[i]=min{ (dis[i]-dis[j])*P[i]+Q[i]+dp[j] } 

这是O（n^2）的

这个式子可以斜率优化

dp[i]+dis[j]*P[i]=dis[i]*P[i]+Q[i]+dp[j]

就是一条斜率为P[i]的直线，截（dis[j],dp[j]）的最小截距

在根往下走的过程中，斜率单调递增

这就体现了 为什么题目中说“i号城市是j号城市的某个祖先，那么一定存在Pi<=Pj”

我们按dfs序dp

现在唯一的问题就是如何得到 一个点到根节点路径上的单调队列

只需要考虑如何去除兄弟节点的子树对单调队列的影响

即在一个节点退出dfs时，将单调队列恢复为这个节点开始dfs的情况

头指针只是不断的+1，没有涉及到单调队列中元素的修改，所以记录下头指针在哪个位置即可

尾指针涉及到元素的替换，但是它只会替换一个元素，所以记录下尾指针的位置，以及被当前点替换的元素是谁

当节点退出dfs时，恢复记录的这三个值即可

这样的话，一个节点多次出队入队，时间复杂度就不是O（n）了

所以二分出队位置，时间复杂度为O（nlogn）

代码链接：
[http://www.cnblogs.com/TheRoadToTheGold/p/8468557.html](http://www.cnblogs.com/TheRoadToTheGold/p/8468557.html)
n^2 暴力dp代码、斜率优化+暴力出队代码、斜率优化+二分出队代码

---

## 作者：Soulist (赞：7)

为什么题解都是请一色的二分还原啊...

~~总感觉有题解彼此潮汐的嫌疑~~

~~实际上并不需要什么二分~~

把朴素的$dp$转移写出来

发现是这样的：

$dp_x=\min(dp_{u}+(dis_x-dis_u)*p_x+c_x)$

设$u,v$均可以转移给$k$，且$u<v$

$$dp_u+(dis_k-dis_u)*p_k+c_k>dp_v+(dis_k-dis_v)*p_k+c_k$$

$$dp_u-dis_u*p_k>dp_v-dis_v*p_k$$

$$(dis_v-dis_u)*p_k>dp_v-dp_u$$

$$p_k>\dfrac{dp_v-dp_u}{dis_v-dis_u}$$

不难发现我们要维护一个下凸壳

因为有$p_{fa}\le p_u$

所以沿途走下来我们可以$O(n)$的$dp$下来

但是跨越子树就做不到了...

仔细思考，我们发现我们对于这个单调队列只做了如下三种操作：

$++head$

$--tail$

$q[tail]=x$

所以，我们发现我们只是修改了$head,tail$和$q[tail]$而已$...$

所以就分别记录一下本次修改前的状态，然后还原回去即可$...$

如果按照出边对应点的点权排序，复杂度应该可以做到$O(n\log n)$

但我比较懒，所以没排，但还是过了...

```cpp
#include<bits/stdc++.h>
using namespace std ;
#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next ) 
#define drep( i, t, s ) for( register int i = t; i >= s; -- i )
#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )
#define LL long long
int read() {
	char cc = getchar(); int cn = 0, flus = 1;
	while(cc < '0' || cc > '9') {  if( cc == '-' ) flus = -flus;  cc = getchar();  }
	while(cc >= '0' && cc <= '9')  cn = cn * 10 + cc - '0', cc = getchar();
	return cn * flus;
}
const int N = 1e6 + 5;
int n, num, L[N], q[N], fr, ed; 
int cnt, head[N], p[N], c[N] ;
LL dp[N], dis[N] ; 
struct E {
    int to, next, w ;
} e[N * 2];
void add( int x, int y, int z ) {
	e[++ cnt] = (E){ y, head[x], z }, head[x] = cnt ; 
}
double K( int x, int y ) {
	double yy = dp[x] - dp[y], xx = dis[x] - dis[y] ;
	return yy / xx ; 
}
inline void dfs( int x ) {
	int Hev = fr, Eev = ed ; 
	while( fr < ed && K( q[fr], q[fr + 1] ) < 1.0 * p[x] ) ++ fr ; 
	dp[x] = dp[q[fr]] + 1ll * p[x] * ( dis[x] - dis[q[fr]] ) + c[x] ; 
	while( fr < ed && K( q[ed], q[ed - 1] ) > K( q[ed], x ) ) -- ed ; 
	int ru = ++ ed, rm = q[ed] ; q[ed] = x ; 
	Next( i, x ) {
		dis[e[i].to] = dis[x] + e[i].w, dfs(e[i].to) ;
	}
	q[ru] = rm, fr = Hev, ed = Eev ; 
}
signed main()
{
    n = read() ; fr = 1 ; int x, y ; 
	rep( i, 2, n ) {
		x = read(), y = read(), add( x, i, y ), p[i] = read(), c[i] = read() ; 
	}
	dfs( 1 ) ;
    rep( i, 2, n ) printf("%lld\n", dp[i] ); 
    return 0;
}
```

---

## 作者：洛水·锦依卫 (赞：3)

[My Blog](https://www.cnblogs.com/luoshuitianyi/p/10896213.html)
# Algorithm

$DP$，斜率优化

# Mentality

看看这个题目，其实一下子就能想到我们可以在每一条从根节点到叶子节点的路径上线性 $DP$ 。

那么方程也异常简单：设 $f[i]$ 为从 $i$ 点到达根节点所需最小费用，$pre_i$ 为 $i$ 到根节点路径上所有点的集合，$lj[i]$ 为 $i$ 到根节点的距离，那么自然有：
$$
f[i]=Min_{j\in pre_i}(f[j]+(lj[i]-lj[j])*P[i]+Q[i])
$$
当然，这个 $DP$ 方程的复杂度是不过关的。按照一贯的套路，这种很容易想式子的 $DP$ 题总满足决策单调性。所以我们尝试一下列出它的决策之间有什么关系。

设 $i$ 的两个决策点为 $j,k$ ，其中 $j\in pre_k$ ，$j,k\in pre_i$ 。

如果从点 $k$ 转移比从点 $j$ 转移更优，那么自然有：

$$
f[k]+(lj[i]-lj[k]) × P[i]+Q[i]<f[j]+(lj[i]-lj[j]) × P[i]+Q[i]
$$

$$
f[k]-lj[k] × P[i]<f[j]-lj[j] × P[i]
$$

$$
f[k]-f[j]<(lj[k]-lj[j])×P[i]
$$

$$
\frac{f[k]-f[j]}{lj[k]-lj[j]}<P[i]
$$

我们发现，由于题目有 $P_i>P_{pre_i}$ 的条件，那么当我们在一条链上 $DP$ 时，一旦从某一点开始满足上式，则这个点的子树内所有点一直都会满足上式。换句话说，对于这个点的子树内所有点而言，**从 $k$ 转移总会比从 $j$ 转移更优** 。

换而言之，此题满足决策单调性中的斜率优化的条件。

那么由于 $P[i]$ 递增，我们只需要维护一个斜率单调递增的决策点队列即可。

但是这是一棵树，怎么办？

很简单，每个点在更改决策点的单调队列时只有三个操作：

- 不断 $++head$ ，直到队首斜率不满足上式
- 不断 $--tail$ ，直到对尾斜率符合单调性
- $++tail$ ，在队列尾部插入当前决策点

那么我们发现，每到一个新的点，其实我们只是修改了一下 $head$ 和 $tail$ 的值，并修改了队列中的一个元素。则我们只需要记住修改之前的那个元素的值，修改之前的队首对尾的位置即可，当我们退出当前点的时候，只需要照着之前记录的值改回去就好了！

但是对于这题还不够。

一般而言，我们的斜率优化总会是 $O(n)$ 的，因为每个点最多只会被入队出队一次，所以总体复杂度只会取决于决策点个数而不是枚举决策点。

但是在这题里，**一个决策点可能在这个点里入队，在下一个点里出队，而回溯回来的时候又再次入队，因而不符合每个点最多只会入队出队一次的规则！**，换句话说，这样做的话，复杂度是错误的。

那接下来又怎么做呢？

由于我们的决策点队列里，相邻两点之间的斜率是单调的，所以我们完全可以通过二分来找到应该 $++head,--tail$ 所达到的位置！

只需要找到最左边的，不满足斜率不等式的位置，以及最右边的，不满足斜率单调递增的位置即可。

当然，二分可能有点小细节，可以看看我的代码。（良心注释）

# Code

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n;
int cntr,head[1000001],to[1000001],nx[1000001],w[1000001];
int Q[1000001];
int que[1000001],h,t;
long long P[1000001],lj[1000001],f[1000001];
void addr(int u,int v,int W)
{
	cntr++;
	to[cntr]=v,nx[cntr]=head[u],w[cntr]=W;
	head[u]=cntr;
}
double slope(int a,int b){return (double)(f[b]-f[a])/(lj[b]-lj[a]);}//斜率不等式
void DP(int x)
{
	int p,tph=h,tpt=t,tpw,l=h+1,r=t,ans=h;//l 的初值为 h+1，因为我们用来比较的是 mid-1 与 mid 两个位置的斜率。之所以不用 l=h,r=t-1 作为初值并比较 mid 与 mid+1 ，是因为根据我们做斜率题的时候 h 总会在最右边的符合不等式的位置的右一个。这样二分出來的位置刚刚好;ans 的初值为 h，因为如果找不到相应的位置，那就不需要修改 h。
	while(l<=r)
	{
		int mid=(l+r)>>1;
		if(slope(que[mid-1],que[mid])<=P[x])l=mid+1,ans=mid;
		else r=mid-1;
	}
	h=ans,p=que[h];
	f[x]=f[p]+(lj[x]-lj[p])*P[x]+Q[x];
	l=h,r=t-1,ans=t;//这里的理由与队首差不多，都是为了结果正确性
	while(l<=r)
	{
		int mid=(l+r)>>1;
		if(slope(que[mid],que[mid+1])>=slope(que[mid+1],x))r=mid-1,ans=mid;
		else l=mid+1;
	}
	t=ans;
	tpw=que[++t],que[t]=x;//记录即将被更改的位置的元素并更新
	for(int i=head[x];i;i=nx[i])
	{
		lj[to[i]]=lj[x]+w[i];//更新路径长度
		DP(to[i]);
	}
	que[t]=tpw;
	h=tph,t=tpt;//修改回进入这个点之前的状态
}
int main()
{
	cin>>n;
	int F,W;
	for(int i=2;i<=n;i++)
	{
		scanf("%d%d%lld%d",&F,&W,&P[i],&Q[i]);
		addr(F,i,W);
	}
	t=-1;//最开始队列是空的，所以 tail=head-1
	DP(1);
	for(int i=2;i<=n;i++)
		printf("%lld\n",f[i]);
}

```



---

## 作者：_WA自动机 (赞：1)

**更好的阅读体验点[这里](https://wa-automaton.github.io/2019/04/28/luogu-P3994-%E9%AB%98%E9%80%9F%E5%85%AC%E8%B7%AF/)~**

~~这是一份将决策理解成直线的题解~~  
~~为啥泥萌都认为决策是点啊~~  

以下进入正题：  
这道题的dp方程比较显然：
$$f[u]=min_{lca(u,v)=v}\{f[v]+P[u]*(depth[u]-depth[v])+Q[u]\}$$
直接dp是$O(n^2)$的。有关于uv的乘积项，depth单调，考虑斜率优化。  
整理得：
$$f[u]=min_{lca(u,v)=v}(-depth[v]*P[u]+f[v])+Q[u]+depth[u]*P[u])$$
则以$-depth[v]$为斜率，$P[u]$为横坐标，$f[v]$为截距，化为一个标准的斜率优化柿子。

我们发现x坐标是不单调的，这意味着我们需要维护整个凸包（单调栈），然后二分找最优的决策点。这也是老套路了。

但是重点并不在于此：这是树上的dp，我们不能像维护序列一样直接令决策点入队出队，因为这样的话每个点不一定只被入队一次，最坏情况仍然是$O(n^2)$。那我们怎么办呢？

~~用主席树实现可持久化栈~~

~~点分治优化dp~~

上面的做法不太好写而且常数巨大...我们有更为优雅的方法：

考虑到斜率单调，那么新来的直线排除掉的旧决策一定是栈顶连续的一段区间。由于决策的单调性，我们可以通过二分找到应该插入新决策的位置(这里找决策点的方法其实和单调队列相同，只是把暴力出队改成二分找合法位置罢了），并让决策入栈。我们发现这样的话其实只是改变了栈顶的位置并修改了一个元素，所以我们在回溯的时候把栈顶和修改的元素改回去，就实现了$O(n\lg n)$的优秀做法...  
~~不过因为数据太水被暴力踩爆了~~

下面是喜闻乐见的代码~（求评价码风qwq）
```cpp
// luogu-judger-enable-o2
#include <cstdio>
#include <algorithm>

const int maxn=1e6+100;

struct Edge
{
    int to,next,w;
}edge[maxn<<1];

int head[maxn],cnt;
int stack[maxn],P[maxn],Q[maxn],fa[maxn];
int64_t f[maxn],depth[maxn];

inline void add(int u,int v,int w)
{
    edge[++cnt].next=head[u];
    edge[cnt].to=v;
    edge[cnt].w=w;
    head[u]=cnt;
}

template<class T>inline T max(T a,T b){return a<b?b:a;}
template<class T>inline T min(T a,T b){return a<b?a:b;}

inline int64_t K(int x){return -depth[x];}
inline int64_t B(int x){return f[x];}
inline int64_t C(int x){return Q[x]+(int64_t)depth[x]*P[x];}
inline double intersection(int x,int y){return ((double)B(x)-B(y))/(K(y)-K(x));}

//f[u]=min_{lca(u,v)=v}(-depth[v]*P[u]+f[v])+Q[u]+depth[u]*P[u])

inline int findbest(int x,int top)
{
    int l=1,r=top;
    while (l<=r)
    {
        int mid=(l+r)>>1;
        if (intersection(stack[mid-1],stack[mid])<=P[x]) l=mid+1;
        else r=mid-1;
    }
    return stack[r];//蒟蒻这里写成了return r WA到怀疑人生..
}

inline int findpos(int x,int top)
{
    int l=1,r=top;
    while (l<=r)
    {
        int mid=(l+r)>>1;
        if (intersection(stack[mid-1],x)>intersection(stack[mid],stack[mid-1])) l=mid+1;
        else r=mid-1;
    }
    return r;
}

inline int64_t calc(int x,int top)
{
    int dec=findbest(x,top);
    return K(dec)*P[x]+B(dec)+C(x);
}

inline void dfs(int u,int top,int ff)
{
    f[u]=calc(u,top);
    top=findpos(u,top)+1;
    int pre=stack[top];
    stack[top]=u;
    for (int i=head[u];i;i=edge[i].next)
    {
        int v=edge[i].to;
        depth[v]=depth[u]+edge[i].w;
        if (v==ff) continue;
        dfs(v,top,u);
    }
    stack[top]=pre;
}

int main()
{
    int n;
    scanf("%d",&n);
    for (int i=2,w;i<=n;++i)
        scanf("%d%d%d%d",fa+i,&w,P+i,Q+i),add(fa[i],i,w);
    for (int i=head[1];i;i=edge[i].next)
    {
        int v=edge[i].to;
        depth[v]=edge[i].w;
        dfs(v,0,1);
    }
    for (int i=2;i<=n;++i)
        printf("%lld\n",f[i]);
}
```

---


# [JSOI2009] 火星藏宝图

## 题目背景

JSOI2009第三轮二试


## 题目描述

在火星游玩多日,jyy 偶然地发现了一张藏宝图。根据藏宝图上说法，宝藏被埋藏在一个巨大的湖里的 $N$ 个岛上 $(2\le N \le 2 \times 10^{5})$。为了方便描述，地图把整个湖划分成 $M$ 行 $M$ 列 $(1\le M\le 1000)$,共 $M \times M$ 个小块，并把所有岛按照 $1...N$ 编了号。第 $i$ 个岛位于第 $X_i$ 行 $Y_i$ 列 (设其坐标为 $(X_i,Y_i)$的格子 （ $X_i,Y_i$ 均为整数，并且满足 $1<=X_i,Y_i<=M$ ）,岛上藏有价值财富 $V_i(1\le V_i\le 10,000)$。湖的左上角 $(1,1)$ 和右下角 $(M,M)$ 都有岛，有桥将它们与陆地相连。

jyy 没费多大劲，就找到了那个湖，同时哭笑不得地发现，所谓的财富，是各个岛上出产的珍稀水果。jyy 在左上角的岛的岸边找到了一条小木船，他可以划船到其他岛上去。划船是要消耗体力的，具体地说，等于两岛 Euclidean 距离的平方(即，从 $(X_1,Y_1)$ 划船到 $(X_2,Y_2)$ 所耗费的体力为 $(X_1-X_2)^2+(Y_1-Y_2)^2$ 个单位)。jyy 可以吃水果来恢复体力，吃掉 $1$ 单位价值的水果能恢复 $1$ 单位体力。

现在 jyy 打算从 $(1,1)$ 旅行到 $(M,M)$，沿途收集珍稀水果。按藏宝图上的提示，jyy 离开一个岛后，就只能去该岛右下方的区域（正下和正右方向也是允许的），否则会遭遇水怪。jyy 可以在旅行途中饿一段时间，即体力为负。但抵达终点后，只要身边有足够多的水果，他就会通过吃水果将体力恢复到旅行前的水平。

jyy想知道，经过一次旅行，他最多能得到多少收益，即 `jyy 收集到的水果总价值- jyy 在旅途中花的总体力` 。(如果吃完所有水果他还饿着，收益就是负数，具体的例子见样例)

## 说明/提示

### 样例解释

$20+60+10-\left ( \left(3-1 \right )^2+\left (5-1 \right )^2 \right )-\left ( \left (10-3 \right )^2+\left (10-5 \right )^2 \right )=-4$

### 数据范围

对 $20\%$ 的数据 $M\le 200$，且 $N\le 2\times 10^3$。

对 $50\%$ 的数据 $M\le 200$，且 $N\le 2\times 10^4$。

对 $100\%$ 的数据 $M\le 1000$，且 $N\le 2\times 10^5$。

## 样例 #1

### 输入

```
4  10 
1  1  20 
10 10 10 
3  5  60 
5  3  30```

### 输出

```
-4```

# 题解

## 作者：Sakits (赞：12)

## https://sakits.com/bzoj1560/
# 题解

　　这题网上题解大都是$O(nm)$的做法，实际上用斜率优化可以做到$O(m^2)$，可貌似只有[lichangdongtw大爷](http://blog.csdn.net/l_0_forever_lf/article/details/65935997)提到了斜率优化，但是没细讲，那我就详细说一下吧...虽然会$O(nm)$肯定就会斜率优化了吧qaq

　　首先先说一下$O(nm)$的做法。设$f(i)$为走到第$i$个点时的最大收益，显然有：
$$f(i)=f(j)-(x_i-x_j)^2-(y_i-y_j)^2+w_i$$


　　朴素的转移当然是$O(n^2)$的，但是我们可以发现每一列上能转移的点行数大的一定比行数小的更优，因为：
$$(a+b)^2>a^2+b^2$$

　　所以对于每一列我们只需要保存可转移点中行数最大的点，从这些点转移就好了，那么转移复杂度是$O(m)$的，总复杂度$O(nm)$，可以卡过去。

　　观察一下方程，平方展开后有一些$i$和$j$的乘积，可以联想到斜率优化。这题如果使用斜率优化的话，可以桶排后做到$O(m^2)$，但是我们也可以改变一下状态表示，不需要桶排。
  
　　设$f(i)(j)$为走到$(i,j)$上的点的最大收益，枚举每一列最底下的点来转移，因为我们确定了转移点的列就能确定行，为了写方程更简单一些，我省略第一维来写方程，设$pos_i$为第$i$列上当前能转移的点的最大行数，$x$为当前点的行数：

$$dis_j=(x-pos_j)^2$$
$$f(i)=f(j)-dis_j-(i-j)^2+w_{x,i}$$

　　设$j<k$，且从$k$转移比从$j$转移优，则有：

$$f(j)-dis_j+2ij-j^2<f(k)-dis_k+2ik-k^2$$
$$f(j)-f(k)-dis_j+dis_k-j^2+k^2<2i(k-j)$$
$$\frac{f(j)-f(k)-dis_j+dis_k-j^2+k^2}{2(k-j)}<i$$
　　然后就可以斜率优化了...**注意横坐标相同时斜率要设为-inf**
# 代码

    #include<iostream>
    #include<cstring>
    #include<cstdlib>
    #include<cstdio>
    #include<algorithm>
    using namespace std;
    const int maxn=1010, inf=1e9;
    const double eps=1e-6;
    int n, m, x, y, z;
    int f[maxn][maxn], w[maxn][maxn], pos[maxn], dis[maxn], q[maxn];
    inline void read(int &k)
    {
    	int f=1; k=0; char c=getchar();
    	while(c<'0' || c>'9') c=='-' && (f=-1), c=getchar();
    	while(c<='9' && c>='0') k=k*10+c-'0', c=getchar();
    	k*=f;
    }
    inline double xl(int x, int y){return (x==y)?-inf:1.0*(f[pos[x]][x]-f[pos[y]][y]-dis[x]+dis[y]-x*x+y*y)/2/(y-x);}
    int main()
    {
    	read(n); read(m);
    	for(int i=1;i<=n;i++) read(x), read(y), read(w[x][y]);
    	memset(f, 200, sizeof(f));
    	f[1][1]=w[1][1]; pos[1]=1; w[1][1]=0; 
    	for(int i=1;i<=m;i++)
    	{
    		for(int j=1;j<=m;j++) dis[j]=(pos[j]!=0)*(pos[j]-i)*(pos[j]-i);
    		int l=1, r=0;
    		for(int j=1;j<=m;j++)
    		{
    			if(pos[j]) 
    			{
    				while(l<r && xl(q[r-1], q[r])>xl(q[r], j)-eps) r--;
    				q[++r]=j; 
    			}
    			if(w[i][j])
    			{
    				while(l<r && xl(q[l], q[l+1])-eps<j) l++;
    				f[i][j]=f[pos[q[l]]][q[l]]-dis[q[l]]-(q[l]-j)*(q[l]-j)+w[i][j];
    				pos[j]=i; dis[j]=0;
    				while(l<r && xl(q[r-1], q[r])>xl(q[r], j)-eps) r--;
    				q[++r]=j; 
    			}
    		}
    	}
    	printf("%d\n", f[m][m]);
    }


---

## 作者：Thanks_bydays (赞：8)

首先可以看出此题是动态规划，于是设置状态：

$f_{i,j}$ 表示划上坐标为 $(i,j)$ 的岛的最大收益。
 
于是有状态转移方程：
 
$f_{i,j}=\max\limits_{1\le p\le i,1\le k\le j}(f_{p,k}-(p-i)^2-(k-j)^2+a[i][j])$

显然朴素 dp 时间复杂度 $O(m^4)$，无法通过本题。

考虑优化，观察下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/6tppnws4.png)

$a_1(x_1,y),a_2(x_2,y),a3(x_3,y_3)$
$(x_1>x_2>x_3,y_3>y)$


有以下 $2$ 种路径：

1. $a_1\rightarrow a_3$

2. $a_1\rightarrow a_2\rightarrow a_3$

可以得出第一种路线体力消耗为 $(x_3-x_1)^2+(y_3-y)^2$。

同理第二种为 $(x_2-x_1)^2+(y_3-y)^2+(x_3-x_2)^2$。

展开后易证第二种消耗更少，且由于水果价值为正，第二种路径取得价值更多，故更优。

结论：当前岛的价值应由其前列中行数 $(x)$ 最大者转移。

于是可以定义 $g_i$ 记录第i列可以转移的行数最大的岛的编号，将时间复杂度降为 $O(m^3)$。

新的 dp 转移式：

$f_{i,j}=\max\limits_{1\le k\le j}(f_{g_k,k}-(g_k-i)^2-(k-j)^2+a_{i,j})$

可以发现复杂度仍无法通过此题，再次观察dp转移式，发现展开后出现 $k,j$ 交错项。考虑斜率优化：

1. 将转移式的 max 除去，得到方程：

   $f_{i,j}=f_{g_k,k}-(g_k-i)^2-(k-j)^2+a_{i,j}$

2. 设 $k_1<k_2$，因为所求的是最大值，故若选择 $k_2$ 优于 $k_1$，当且仅当：

   $f_{g_{k_2},k_2}-g_{k_2}^2-i^2+2ig_{k_2}-k_2^2-j^2+2k_2j+a_{i,j}\ge f_{g_{k_1},k_1}-g_{k_1}^2-i^2+2ig_{k_1}-k_1^2-j^2+2k_1j+a_{i,j}$

3. 化简可得：

   $\frac{(g_{k_2}^2+k_2^2-f_{g_{k_2},k_2}-2ig_{k_2})-(g_{k_1}^2+k_1^2-f_{g_{k_1},k_1}-2ig_{k_1})}{k_2-k_1}\le 2j$

4. 对其斜率优化即可，注意 $k_2=k_1$ 时返回 -inf。时间复杂度 $O(m^2)$。

End.

---

## 作者：洛苡hh (赞：8)

完全不会斜率优化的戳[这里](https://www.cnblogs.com/luoyi-hh/p/18940250)。

第一思路是设 $f_i$ 表示走到第 $i$ 个岛上的最大收益，有转移方程：

$$
f_i = \max_{j,x_j \le x_i,y_j \le y_i} f_j - ((x_i-x_j)^2+ (y_i-y_j)^2) + v_i
$$

注意到方程中有两个 $i,j$ 交乘项，无法直接进行斜率优化，但是不难发现坐标的数据范围很小，我们可以考虑枚举一维坐标将其变为常量，然后再用斜率优化去做另一维，这样复杂度是 $O(nm)$ 的。

但其实我们有复杂度更加优秀的做法，需要观察一些性质。

设 $f_{i,j}$ 表示走到坐标为 $(i,j)$ 的最大收益。

朴素转移方程是 $O(m^4)$ 的，枚举当前坐标，枚举决策点坐标，然后进行转移。

考虑对于同一列上的两个转移点 $j,k$。

![](https://cdn.luogu.com.cn/upload/image_hosting/msth9g13.png)

1号路线的代价为 $(x_i-x_k)^2+(y_i-y_k)^2$。

2号路线的代价为 $(x_j-x_k)^2 + (x_i-x_j)^2+(y_i-y_j)^2$。

由于 $(x_j-x_k)+(x_i-x_j) = x_i-x_k$ 不难发现有2号路线优于1号路线。

即每一列上最优的转移点是行坐标最大的点，于是确定了决策点的列也就确定了行，复杂度优化为 $O(m^3)$。

我们记第 $i$ 列的最优转移点为 $pos_i,i$。

则有转移方程：

$$
f_{i,j} = \max_{k=1}^{j-1} f_{pos_k,k} - ((i-pos_k)^2+(j-k)^2) + v_{i,j}
$$

由于行是固定的，为了方便下文记在第 $i$ 行 $dis_j=(i-pos_j)^2$。

$$
f_{i,j} = \max_{k=1}^{j-1} f_{pos_k,k} - (dis_k^2+(j-k)^2) + v_{i,j} \\
f_{i,j} = v_{i,j} -j^2 + \max_{k=1}^{j-1} 2jk + f_{pos_k,k} - dis_k -k^2
$$

以 $(k,f_{pos_k,k} - dis_k -k^2)$ 为坐标维护上凸壳，用斜率为 $-2j$ 的直线去切，注意到坐标和斜率均单调。

复杂度优化为 $O(m^2)$。

代码：

```cpp
#include<bits/stdc++.h>
#define MAXN 200005
#define MAXM 1005
#define int long long
#define look_memory cerr<<abs(&M2-&M1)/1024.0/1024<<'\n'
#define look_time cerr<<(clock()-Time)*1.0/CLOCKS_PER_SEC<<'\n'
using namespace std;

inline int read(){
    int x=0;
    int f=1;
    char c=getchar();
    while(c<'0' || c>'9'){
        if(c=='-') f=-1;
        c=getchar();
    }
    while(c>='0' && c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return x*f;
}

bool M1;
int n,m;
struct node{
	int x,y;
};
int w[MAXM][MAXM];
deque<node> q;
int pos[MAXM],dis[MAXM],f[MAXM][MAXM];
const int inf=1e9;
const double eps=1e-6;

double get_k(node aa,node bb){
	return 1.0*(bb.y-aa.y)/((aa.x==bb.x)?eps:(bb.x-aa.x));
}

bool M2;

signed main(){
//  freopen("","r",stdin);
//  freopen("","w",stdout);
    int Time=clock();
	n=read();m=read();
	for(int i=1;i<=n;i++){
		int x,y;
		x=read();y=read();
		w[x][y]=read();
	}
	f[1][1]=w[1][1];
	pos[1]=1;
	for(int i=1;i<=m;i++){
		q.clear();
		for(int j=1;j<=m;j++){
			if(pos[j]) dis[j]=(i-pos[j])*(i-pos[j]);
			else dis[j]=0;
		}
		for(int j=1;j<=m;j++){
			if(pos[j]){
				node tmp={j,f[pos[j]][j]-dis[j]-j*j};
				while(q.size()>=2 && get_k(q[q.size()-2],tmp)>=get_k(q[q.size()-2],q.back())) q.pop_back();
				q.push_back(tmp);
			}
			if(w[i][j] && (i>1||j>1)){
				while(q.size()>=2 && -2*j<=get_k(q[0],q[1])) q.pop_front();
				int x=q.front().x,y=q.front().y;
				f[i][j]=w[i][j]-j*j+2*j*x+y;
				pos[j]=i;
				dis[j]=0;
				node tmp={j,f[pos[j]][j]-dis[j]-j*j};
				while(q.size()>=2 && get_k(q[q.size()-2],tmp)>=get_k(q[q.size()-2],q.back())) q.pop_back();
				q.push_back(tmp);
			}
		}
	}
	int ans=f[m][m];
	printf("%lld\n",ans);
    look_memory;
    look_time;
    return 0;
}
```

---

## 作者：BzhH (赞：5)

这道题很容易想到$O(n^2)$的暴力做法,但仔细思考一下,可以发现对于每一列的可转移的岛,行数大的一定比行数小的更优.

不妨假设这两个岛的坐标为$(x_1,y),(x_2,y)(x_1 < x_2 \le x)$,当前的岛的坐标为$(x,y)$

$\because (x_1-x_2)^2+(x_2-x)^2 - (x_1-x)^2$

$=2x_2^2-2x_1x_2-2xx_2+2xx_1=2(x_2-x_1)(x_2-x)<0$

$\therefore (x_1-x_2)^2+(x_2-x)^2 < (x_1-x)^2$

即选择经过第二个岛的花费一定小于不选择经过第二个岛

那么我们就可以再开一个数组把每一列可以转移的岛的最大行数用数组$st[k]$存下来

对于状态转移方程,我们不妨假设当前岛的坐标为(i,j),定义状态$f_{i,j}$为走到$(i,j)$的最小花费,那么只需要用$O(m^3)$枚举横坐标k即可求出答案,显然是不行的

观察转移方程$f_{i,j}=f_{st[k],k}+(i-st[k])^2+(j-k)^2+w_{i,j}$

为了式子更简便不妨设$dis_k=(i-st[k])^2$

那么稍微变一下形可得$dis_k-k^2-f_{st[k],k}=2jk-j^2+w_{i,j}-f_{i,j}$

令$y=dis_k-k^2-f_{st[k],k},x=k$

得$y=2jx-j^2+w_{i,j}-f_{i,j}$

到这很明显就是用斜率优化了,维护一个下凸壳求最小值,那么就可以用$O(m^2)$求出了

代码
```
#include<iostream>
#include<cstdio>
#include<cstring>
#define cost(i, j, k) ((i - st[k]) * (i - st[k]) + (j - k) * (j - k))
#define gety(k) (dis[k] + k * k - f[st[k]][k])
using namespace std;
const int N = 2e5 + 5;

int ld[1005][1005], st[1005], f[1005][1005], dis[1005], q[N];

int main()
{
    int n, m;
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
    {
        int x, y, v;
        scanf("%d%d%d", &x, &y, &v);
        ld[x][y] = v;
    }
    memset(f, -0x3f, sizeof(f));
    f[1][1] = ld[1][1], st[1] = 1, ld[1][1] = 0;//初始化,将ld[1][1]=0避免重复转移
    for (int i = 1; i <= m; i++)
    {
        int front = 0, tail = 0;
        q[0] = 0;
        for (int j = 1; j <= m; j++)
            dis[j] = (st[j] != 0) * (i - st[j]) * (i - st[j]);
        for (int j = 1; j <= m; j++)
        {
            if (st[j])
            {
                while (front < tail && (gety(q[tail]) - gety(q[tail - 1])) * (j - q[tail]) 
                    >= (gety(j) - gety(q[tail])) * (q[tail] - q[tail - 1]))
                    tail--;
                q[++tail] = j;//因为每次队列都会清空,所以要将之前的重新放回队列
            }
            if (!ld[i][j])
                continue;
            while (front < tail && gety(q[front + 1]) - gety(q[front]) <= 2 * j * (q[front + 1] - q[front]))
                front++;
            int k = q[front];
            f[i][j] = f[st[k]][k] - cost(i, j, k) + ld[i][j];
            st[j] = i, dis[j] = 0;
            while (front < tail && (gety(q[tail]) - gety(q[tail - 1])) * (j - q[tail]) 
                >= (gety(j) - gety(q[tail])) * (q[tail] - q[tail - 1]))
                tail--;
            q[++tail] = j;//斜率优化
        }
    }
    printf("%d", f[m][m]);
    return 0;
}
```

---

## 作者：asuldb (赞：4)

这里是$sb$的$O(nm)$做法

上一篇题解里写的$O(nm)$做法并没有看懂，我真是好菜啊

这是一个用了斜率优化，但是复杂度仍然是$O(nm)$的做法

我们还是先写出简单的$dp$方程

$dp[i]$表示到达第$i$个点的时候的最大收益

于是就有

$$dp[i]=max(dp[j]+w[i]-(a[i].x-a[j].x)^2-(a[i].y-a[j].y)^2)$$

显然暴力转移是$O(n^2)$的

我们发现$m$非常的小，于是我们可以考虑一下把$n$优化成$m$

我们先将整个矩阵破坏成一条链，之后给每一个点一个新编号，对于原来的点$(x,y)$，新编号就是$(x-1)*m+y$，我们按照新编号给点从小到大排序

于是我们按照这个样子来进行$dp$的话就可以方便的找到某个点右上的所有点了

我们可以开上$m$个队列，第$i$个队列$q[i]$存储的是$i$这一列上面所有的点

于是我们更新一个点的时候只需要去枚举它之前的所有列对应的队列就好了

之后我们就可以来斜率优化了

由于我们枚举的是列数，那么$(a[i].y-a[j].y)^2$就固定了，为了方便化柿子，我们设$c=(a[i].y-a[j].y)^2$

于是就有

$$dp[i]=dp[j]+w[i]-c-(a[i].x-a[j].x)^2$$

$$dp[i]=dp[j]+w[i]-c-a[i].x^2-a[j].x^2+2*a[i].x*a[j].x$$

$$-2*a[i].x*a[j].x+dp[i]+c-w[i]=dp[j]-a[j].x^2$$

这个柿子显然可以列率优化，截距为$dp[i]+c-w[i]$，斜率为$-2*a[i].x$由于斜率单减，我们要求最大化截距，所以维护一个上凸壳就好了

代码
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#define re register
#define maxn 1005
#define max(a,b) ((a)>(b)?(a):(b))
inline int read()
{
	char c=getchar();
	int x=0,r=1;
	while(c<'0'||c>'9') 
	{
		if(c=='-') r=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')
		x=(x<<3)+(x<<1)+c-48,c=getchar();
	return x;
}
struct Point
{
	int x,y,rk;
	int w;
}a[200005];
int dp[200005];
int q[maxn][maxn],head[maxn],tail[maxn];
inline int cmp(Point K,Point M)
{
	return K.rk<M.rk;
}
#define X(i) (a[i].x)
#define Y(i) (dp[i]-a[i].x*a[i].x)
inline double K(int i,int j)
{
	return double(Y(i)-Y(j))/double(X(i)-X(j));
}
int n,m;
int main()
{
	n=read(),m=read();
	for(re int i=1;i<=n;i++)
	{
		a[i].x=read(),a[i].y=read(),a[i].w=read();
		a[i].rk=(a[i].x-1)*m+a[i].y;
	}
	std::sort(a+1,a+n+1,cmp);
	memset(dp,-20,sizeof(dp));
	dp[1]=a[1].w;
	q[1][++tail[1]]=1;
	for(re int i=2;i<=n;i++)
	{
		int T=a[i].y;
		for(re int j=1;j<=T;j++)
		{
			int c=(T-j)*(T-j);
			while(head[j]<tail[j]&&-2*a[i].x<K(q[j][head[j]],q[j][head[j]+1])) head[j]++;
			dp[i]=max(dp[i],dp[q[j][head[j]]]+a[i].w-c-(a[q[j][head[j]]].x-a[i].x)*(a[q[j][head[j]]].x-a[i].x));
		}
		while(head[T]<tail[T]&&K(i,q[T][tail[T]-1])>K(q[T][tail[T]],q[T][tail[T]-1])) tail[T]--;
		q[T][++tail[T]]=i;
	}
	std::cout<<dp[n];
	return 0;
}
```

---

## 作者：蒟蒻丁 (赞：2)

首先，$n^2$的做法不难想  
暴力枚举现在的点，然后枚举决策点 $f_i=min(f_j-dis_{ij}+w_{ij})$  
然后考虑优化 
这里有个有意思的贪心：

![art if abcd](https://cdn.luogu.com.cn/upload/image_hosting/ism5vw1p.png)

考虑题意，$A C$点间距离为$c^2=(a+b)^2+d^2$稍作计算就会发现直接走$A C$不如顺便去一下$B$  
所以对于每一列，最下面的点必定是最优的（不要忘了$w$大于零）  
用一个$st$数组记录下每一列的最优点在第几排，设$f_{ij}$表示走到第$(i,j)$点的最大收获
$$f[i][j]=min(f[st[k]][k]-dis(i,j,st[k],k)+w[i][j])$$
时间复杂度变成了$m^3$  
意识到可以用下单调队列优化一下  
先无视掉第一维，设$i$为当前列  
设：
$$dis_{j}=(i-st[j])$$
$$f[i]=min(f[j]-dis[j]-(i-j)^2)+w[i]$$
若第$j$列优于第$k$列
$$f[j->i]>f[k->i]$$
$$f[j]-dis[j]-i^2+2*ij-j^2>f[k]-dis[k]-i^2+2*ik-k^2$$
$$f[j]-f[k]-dis[j]+dis[k]-j^2+k^2>2i*(k-j)$$
$$\frac{f[j]-f[k]-dis[j]+dis[k]-j^2+k^2}{2*(k-j)}>i$$
显然是斜率$DP$格式，后面就直接套"模板"
```
#include<iostream> 
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll long long
#define ld long double 
using namespace std;
const ld eps=1e-6;
const ll M=2100;
ll n,m,f[M][M],st[M],w[M][M],q[M],l,r,dis[M];

ll disc(ll x,ll y){
	return (x-y)*(x-y);
}

ld K(ll x,ll y){
	if(x!=y)return (f[st[x]][x]-dis[x]-x*x-f[st[y]][y]+dis[y]+y*y)/(y-x)/2.0;
	return -1e9;//这点不要忘记
}

int main(){
	memset(f,-0x3f,sizeof(f));
	scanf("%lld%lld",&n,&m);
	for(ll i=1,a1,a2,a3;i<=n;i++){
		scanf("%lld%lld%lld",&a1,&a2,&a3);
		w[a1][a2]=a3;
	}
	f[1][1]=w[1][1],st[1]=1;
	w[1][1]=0;
	for(ll i=1;i<=m;i++){
		l=1,r=0;
		for(ll j=1;j<=m;j++){
			dis[j]=(st[j]!=0)*disc(st[j],i);
		}
		for(ll j=1;j<=m;j++){
			if(st[j]){
				while(l<r&&K(q[r-1],q[r])>K(q[r],j))r--;
				q[++r]=j;
			}
			if(w[i][j]){
				while(l<r&&K(q[l],q[l+1])<j)l++;
				f[i][j]=f[st[q[l]]][q[l]]-dis[q[l]]-disc(j,q[l])+w[i][j];
				st[j]=i,dis[j]=0;//不要忘记dis赋为零
				while(l<r&&K(q[r-1],q[r])>K(q[r],j))r--;
				q[++r]=j;
			}
		}
	}
	cout<<f[m][m];
}
```

---

## 作者：xuantianhao (赞：0)

## [ [JSOI2009] 火星藏宝图](https://www.luogu.com.cn/problem/P4056)

一个非常显然的结论：在最优方案中，路径上的任意两个点所构成的矩形内部一定不存在其它点。不然的化，在这个其它的点多停留一下一定不会更差。

因为 $a^2+b^2<(a+b)^2$。

~~但是，就算想到这个，我也得不出什么好的转移方式~~

考虑将所有岛屿按照行优先，如果行相同就按列优先进行排序。这样，对于任何一个岛 $i$，所有编号小于 $i$ 的且列比它小的岛都是可转移的。

而在所有列相同的岛中，行最大的那个一定是最优的。

因此我们可以针对每行维护一个列数最大的点（类似于桶），每次只需要遍历这些桶进行转移即可。

复杂度 $O(nm)$，卡卡就卡过去了。

代码：

```cpp
#pragma GCC optimize(3)
#include<bits/stdc++.h>
using namespace std;
int n,m,tri[1010],f[200100];
struct node{
    int x,y,v;
    friend bool operator <(const node &x,const node &y){
        if(x.x!=y.x)return x.x<y.x;
        return x.y<y.y;
    }
}is[200100];
inline void read(int &x){
    x=0;
    char c=getchar();
    while(c>'9'||c<'0')c=getchar();
    while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+(c^48),c=getchar();
}
inline void print(int x){
    if(x<0)putchar('-'),x=-x;
    if(x<=9)putchar('0'+x);
    else print(x/10),putchar('0'+x%10);
}
int main(){
    read(n),read(m);
    for(register int i=1;i<=n;i++)read(is[i].x),read(is[i].y),read(is[i].v);
    sort(is+1,is+n+1);
    tri[1]=1;
    f[1]=is[1].v;
    for(register int i=2;i<=n;i++){
        f[i]=f[1]-(is[i].x-1)*(is[i].x-1)-(is[i].y-1)*(is[i].y-1);
        for(register int j=1;j<=is[i].y;j++)if(tri[j])f[i]=max(f[i],f[tri[j]]-(is[i].x-is[tri[j]].x)*(is[i].x-is[tri[j]].x)-(is[i].y-is[tri[j]].y)*(is[i].y-is[tri[j]].y));
        f[i]+=is[i].v;
        tri[is[i].y]=i;
    }
    print(f[n]);
    return 0;
}
```


---


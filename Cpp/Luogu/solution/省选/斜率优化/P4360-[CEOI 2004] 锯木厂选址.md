# [CEOI 2004] 锯木厂选址

## 题目描述

从山顶上到山底下沿着一条直线种植了 $n$ 棵老树。当地的政府决定把他们砍下来。为了不浪费任何一棵木材，树被砍倒后要运送到锯木厂。 

木材只能朝山下运。山脚下有一个锯木厂。另外两个锯木厂将新修建在山路上。你必须决定在哪里修建这两个锯木厂，使得运输的费用总和最小。假定运输每公斤木材每米需要一分钱。 

你的任务是编写一个程序，从输入文件中读入树的个数和他们的重量与位置，计算最小运输费用。

## 说明/提示

样例图示，黑点为锯木厂

![](https://cdn.luogu.com.cn/upload/pic/16339.png)

本题共有 $13$ 个测试点，每个测试点的数据范围如下

测试点 $1\sim 5$：$n\leq 200$；

测试点 $6\sim7$：$n\leq 1000$；

测试点 $7\sim13$：$2\leq n\leq 20000$；

## 样例 #1

### 输入

```
9 
1 2 
2 1 
3 3 
1 1 
3 2 
1 6 
2 1 
1 2 
1 1
```

### 输出

```
26```

# 题解

## 作者：TimeTraveller (赞：73)

~~这个题就是个简单的斜率优化DP的入门题~~  

我们先写出朴素的DP方程式：

$dp[i]=totsum-dis[j]*sum[j]-dis[i]*(sum[i]-sum[j])(j<i)$

其中$dp[i]$表示当前第二个工厂修到第$i$棵树的位置时的最小花费，$totsum$表示所有树一开始全部运送的山脚下的花费，$dis[i]$表示距离的后缀和(因为我们是从上运到下面)，$sum[i]$表示树的重量的前缀和。那么在$i,j$处修了工厂后花费就变成了总花费$totsum$减去从$j$厂运到山脚的额外花费$dis[j]*sum[j]$，再减去从$i$厂运到山脚下的额外花费$dis[i]*(sum[i]-sum[j])$。

形象的说，就是你先把$j$前面的木材运到$j$厂，然后减去这些木材运到山脚的花费，再把$i,j$之间的木材运到$i$厂，再减去它们到山脚的花费。

然后我们将DP方程式变形,令$j,k(j<k)$这两种决策转移到$i$的时候，$k$决策更优秀，那么就可以得到$totsum-dis[j]*sum[j]-dis[i]*(sum[i]-sum[j])>totsum-dis[k]*sum[k]-dis[i]*(sum[i]-sum[k])$

整理后可以得出：$\frac{dis[j]*sum[j]-dis[k]*sum[k]}{sum[j]-sum[k]}>dis[i]$

然后因为斜率$dis[i]$是随着$i$的增加而变小的，所以我们根据斜率维护一个上凸壳，因为是单调的，所以用一个队列就可以了。

丑陋代码新鲜出炉~~~

代码中的sum就是totsum，s[i]就是sum[i],d[i]就是dis[i].

```cpp

#include<cstdio>
#include<cstring>
#include<algorithm>
#define db double
using namespace std;
const int M=3e4+1;
int n;
int q[M],fi,la,ans=2e9+1;
int sum,s[M],d[M],w[M];
db calc(int j,int k){return 1.0*(d[j]*s[j]-d[k]*s[k])/(s[j]-s[k]);}
int count(int i,int j){return sum-d[j]*s[j]-d[i]*(s[i]-s[j]);}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++){scanf("%d%d",&w[i],&d[i]);}
    for(int i=n;i>=1;i--) d[i]+=d[i+1];
    for(int i=1;i<=n;i++) s[i]=s[i-1]+w[i],sum+=d[i]*w[i];
    for(int i=1;i<=n;i++){
        while(fi<la&&calc(q[fi],q[fi+1])>d[i]) ++fi;
        ans=min(ans,count(i,q[fi]));
        while(fi<la&&calc(q[la-1],q[la])<calc(q[la],i)) --la;
        q[++la]=i;
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：zhoufangyuanPT (赞：36)

**这题的正解是DP+斜率优化，所有想学习斜率优化的人请用斜率优化解决**
## 然而我却觉得这是一道模拟退火好题（楼下锯木厂着火了）
因为刚学模拟退火没有什么题好刷，就试着用模拟退火把这一题水过了。

下面是题解正文

# 1.模拟退火
没学过模拟退火的请可以看[FlashHu大佬的博客](http://www.cnblogs.com/flashhu/p/8884132.html)

并且先去做[P1337 【JSOI2004】平衡点 / 吊打XXX](https://www.luogu.org/problemnew/show/P1337)这一题

# 2.f函数的O(1)实现
**这部分可以参考上面斜率优化的题解**

定义$x$是一个结构体，里面存两个值$a,b$，表示把锯木厂分别建在$a,b$这两个地方

先设$D_i=\sum_{j=1}^{i-1}d_j$

可以知道

$f\left(x\right)=\sum_{i=1}^aw_i\cdot\left(D_a-D_i\right)+\sum_{i=a+1}^bw_i\cdot\left(D_b-D_i\right)+\sum_{i=b+1}^nw_i\cdot\left(D_{n+1}-D_i\right)$

$f\left(x\right)=D_a\sum_{i=1}^aw_i-\sum_{i=1}^aw_i\cdot D_i+D_b\sum_{i=a+1}^bw_i-\sum_{i=a+1}^bw_i\cdot D_i+D_{n+1}\sum_{i=b+1}^nw_i-\sum_{i=b+1}^nw_i\cdot D_i$

$f\left(x\right)=D_a\sum_{i=1}^aw_i+D_b\sum_{i=a+1}^bw_i+D_{n+1}\sum_{i=b+1}^nw_i-\sum_{i=1}^nw_i\cdot D_i$

然后我们用前缀后优化一下

设$W_i=\sum_{j=1}^iw_j$，$s=\sum_{i=1}^nw_i\cdot D_i$

$f\left(x\right)=D_a\cdot W_a+D_b\cdot\left(W_b-W_a\right)+D_{n+1}\cdot\left(W_n-W_b\right)-s$

这是我们发现$d_i$和$w_i$已经不存在了，~~就可以扔了~~

# 3.模拟退火的具体实现
每一次位移就是将a和b向左或右移动一定距离，如果小于0就加上$n$，大于$n$就减去$n$。

一开始$T=1.0n$，因为$T>n$时移动一次就相当于绕了整个山一圈，没有必要。然后设$eps=0.5$，因为这样四舍五入刚好能影响结果。

由于有可能$a>b$，所以$f(x)$中要判断一下。

四舍五入可以用cmath的$round()$函数

还记得要开long long

以下是代码
```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<cstdlib>
using namespace std;
long long w[210000],d[210000],s,n;
struct node
{
    int a,b;
    inline double f()
    {
        if(a>b)a^=b^=a^=b;
        return w[a]*d[a]+(w[b]-w[a])*d[b]+(w[n]-w[b])*d[n+1]-s;
    }
};
const double delta=0.99,eps=5e-1;
double T;node x;
int main()
{
    scanf("%lld",&n);
    w[0]=0;d[0]=0;s=0;
    for(int i=1;i<=n;i++)
    {
        int a,b;scanf("%d%d",&a,&b);
        w[i]=w[i-1]+a;d[i+1]=d[i]+b;
        s=s+a*d[i];
    }
    T=1.0*n;
    x.a=1;x.b=2;
    while(T>=eps)
    {
        int aa=round((2.0*rand()/RAND_MAX-1)*T);
        int bb=round((2.0*rand()/RAND_MAX-1)*T);
        node x1;
        x1.a=((x.a+aa)%n+n)%n;
        x1.b=((x.b+bb)%n+n)%n;
        if(x1.f()<x.f())x=x1;
        else
        {
            double gl=1.0*rand()/RAND_MAX;
            if(gl<=exp((x.f()-x1.f())/T))x=x1;
        }
        T=T*delta;
    }
    printf("%lld\n",(long long)(x.f()));
    return 0;
}
```

# 4.优化
**细心的同学会发现上面的代码交上去后会WA成51分**

首先加一个best记录全局搜过的最优解

然后选一个~~好的随机数种子~~

最后就用我们神奇的多次模拟退火来骗分

AC代码：
```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<cstdlib>
using namespace std;
long long w[210000],d[210000],s,n;
struct node
{
	int a,b;
	inline double f()
	{
		if(a>b)a^=b^=a^=b;
		return w[a]*d[a]+(w[b]-w[a])*d[b]+(w[n]-w[b])*d[n+1]-s;
	}
};
const double delta=0.99,eps=5e-1;
double T;node x,best;
int main()
{
	srand(99);
	scanf("%lld",&n);
	w[0]=0;d[0]=0;s=0;
	for(int i=1;i<=n;i++)
	{
		int a,b;scanf("%d%d",&a,&b);
		w[i]=w[i-1]+a;d[i+1]=d[i]+b;
		s=s+a*d[i];
	}
	best.a=1;best.b=2;
	int times=100;
	while(times--)
	{
		T=1.0*n;
		x.a=rand()%n+1;
		x.b=rand()%n+1;
		while(T>=eps)
		{
			int aa=round((2.0*rand()/RAND_MAX-1)*T);
			int bb=round((2.0*rand()/RAND_MAX-1)*T);
			node x1;
			x1.a=((x.a+aa)%n+n)%n;
			x1.b=((x.b+bb)%n+n)%n;
			if(x1.f()<x.f())x=x1;
			else
			{
				double gl=1.0*rand()/RAND_MAX;
				if(gl<=exp((x.f()-x1.f())/T))x=x1;
			}
			if(x.f()<best.f())best=x;
			T=T*delta;
		}
	}
	printf("%lld\n",(long long)(best.f()));
	return 0;
}
```

---

## 作者：MuYC (赞：21)

#### 前言

这里带来一个随机化解法。这个做法并非是我原创的，它出自 刘家烨 2008 年的国家队论文 ----- 《浅谈随机化在信息学竞赛中的应用》，有兴趣的话可以去看看原文（百度即可）。但是原文并没有提供代码实现，而这个做法又比较的妙，算得上一个比较精巧的随机化的实现，并且网上大多数题解都是斜率优化的，于是我写下了这篇题解想要分享一下这个做法，这个做法在原题的数据范围下对拍了 $500$ 组没有出现错误。

#### 具体做法

##### 前置部分

首先我们可以很容易通过预处理的方式来实现 $O(1)$ 回答在某两个点  $x,y$ 修建锯木厂的总费用是多少。

+ 令 $sw[i]$ 为第 $1$ 到 第 $i$ 棵的树的重量和，$sd[i]$ 为从山顶的点（第一个点）到第 $i$ 个点的距离, $S[i]$ 表示的是在第 $i$ 个点修建锯木厂，而且前面 $i - 1$ 个点没有修建锯木厂的花费。预处理这三个数组, 其中特殊一点的是 $S[i] = S[i - 1] + dis(i - 1, i) * sum[i - 1]$。

假设我们现在在 $x,y(x < y)$ 修建了两个锯木厂，那么费用分三段看，第一段 $1$ 到 $x$ 的费用直接得出是 $S[x]$，第二段的费用是从第 $x + 1$ 棵树到第 $y$ 棵树运到第 $y$ 个点的费用，就叫做 $cost_2$ ，$cost_3$ 类似，讲一下 $cost_2$ 的计算方法，$cost_3$ 的就同理。

$cost_2 = S[y] - S[x] - sw[x] * dis(x,y)$ 

$dis(x,y)$ 表示 $x$ 到 $y$ 的距离, 用上面提到的数组表示就是 $sd[y] - sd[x]$，然后 $cost_3$ 依葫芦画瓢即可。答案就是 $S[x] + cost_2 + cost_3$

然后我们就可以通过 $O(n)$ 预处理然后 $O(1)$ 回答在 $x,y$ 修建锯木厂的花费是多少了。

##### 正文部分

不妨将 $(x,y)$ 看作是一个矩形上的点，这个点的含义就是在 $x$ 和 $y$ 点修建锯木厂的花费。构造一个 $n * n$ 的矩形就可以涵盖所有的决策点。

那么完全的将这个矩阵遍历一遍获得其最优解是不现实的，因为总的点数会达到 $20000 * 20000 = 4 * 10^8$ 个。考虑随机的取一部分点。那么我们虽然可以用 $O(1)$ 的时间复杂度随机 $10^7$ 次或者更多，但是这对于 $4*10^8$ 的总点数来说还是太小了的。

考虑随机在一个子矩阵中获得解，不妨令 $(nowx,nowy)$ 为这个子矩阵的**中心点**，然后 $len$ 就表示矩阵的**边长**（但是我的代码中为了方便设置的实际上是矩阵的边长的一半）。一开始将 $(nowx,nowy)$ 就设置为 $n*n$ 矩阵的中心点，也就是 $nowx = n / 2, nowy = n / 2$，$len$ 也直接设置为 $n$，也就是说我们一开始的子矩阵就是整个矩阵。接下来我们在目前的获取答案的矩阵中随机取几个点（如图中黑点所示）：

![](https://cdn.luogu.com.cn/upload/image_hosting/rhfi14s7.png)

对于这些点进行判断，取其中最优的一个，然后作为新的矩阵的**中心**。在下一次进行操作的时候，我们缩减这个 $len$，当然了，随着 $len$ 的变小，自然我们每次随机的点的数量也应该减少（初始值设置为于 $n$ 同级，约为 $n$ 的 $3$ ~ $5$ 倍即可），然后每次 $len$ 缩小的量我设置为了 $\frac{7}{8}$，每次缩小的判断的点的数量也是 $\frac{7}{8}$。

同时最后的优化是，当这个点阵的边长已经足够小了（我这里设置的阈值是 $3000$）就直接暴力的判断矩阵中的所有点，对于答案取 $min$ 即可终止循环了，答案的正确率趋近于 $100$%(前面提到过的，在 $2*10^4$ 的数据范围下跟斜率优化算法对拍了 $500$ 组随机数据是没有问题的，也许这个数据还会更加好，但是迫于时间关系我只拍了 500 组，今晚放在这里跑看能跑多少组)。

#### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int MAXN = 2e5 + 50;
int n;
int dis[MAXN], val[MAXN], sw[MAXN], S[MAXN], sd[MAXN];
// 数组含义如题解中一样,sw 表示树重前缀和，sd 表示距离前缀和，S 表示费用前缀和
int Ans = 1e18, nowx, nowy, len;

int GetSum(int l, int r) {
    int Dis = sd[r] - sd[l], weight = sw[l];
    return (S[r] - S[l] - Dis * weight);
}

int calc(int x, int y) { // 表示在 x 和 y 修建的花费
    if(x > n || y > n || x <= 0 || y <= 0) return 1e18;
    if(x > y) swap(x, y);
    int now = S[x] + GetSum(x, y) + GetSum(y, n);
    return now;
}

signed main() {
    srand(time(NULL));
    cin >> n;
    for(int i = 1 ; i <= n ; i ++)
    cin >> val[i] >> dis[i]; n ++;
    for(int i = 1 ; i <= n;  i ++) { 
        sw[i] = sw[i - 1] + val[i];
        sd[i] = sd[i - 1] + dis[i - 1]; //前缀和处理
        S[i] = S[i - 1] + sw[i - 1] * dis[i - 1]; //前缀和处理
    }
    nowx = n / 2, nowy = n / 2 + 1, len = n / 2; //这里为了方便我的len定义为正方形边长的一半
    int Times = n * 3, ansx = nowx, ansy = nowy; //ansx,ansy 用于记录当前最优解，用于更新矩阵的中心点
    while((double)clock() / CLOCKS_PER_SEC < 0.8) {
        int x, y, newx, newy;
        if(len <= 3000) { //如果矩形的边长足够小就可以停止了
            for(int i = max(1ll, nowx - 3000) ; i <= min(n, nowx + 3000); i ++) {
                for(int j = max(1ll, nowy - 3000) ; j <= min(n, nowy + 3000); j ++) 
                Ans = min(calc(i, j), Ans);
            }
            break;
        }
        for(int i = 1 ; i <= Times ; i ++) {
            if(rand() % 2 == 1)newx = nowx + rand() % len;
            else newx = nowx - rand() % len;
            if(rand() % 2 == 1)newy = nowy + rand() % len;
            else newy = nowy - rand() % len;
            int cost = calc(newx, newy);
            if(cost < Ans) Ans = cost, ansx = newx, ansy = newy;
        }
        len = (int)(len / 8) * 7; Times = (int)(Times / 8) * 7; // 边长以及次数进行缩减
        nowx = ansx, nowy = ansy;
    }
    cout << Ans;
    return 0;
}
```

#### 总结

这个做法我认为是模拟退火的温控同时结合爬山进行的优化，非常精妙的随机化，非常值得学习。

---

## 作者：_Sein (赞：16)

## 题面描述
[传送门](https://www.luogu.org/problemnew/show/P4360)

## 思路
状态转移方程

$tot$为所有树都运到山下锯木厂的费用，$dis$为到山下锯木厂的距离，$s$为树的重量前缀和。

$$F_i=\min(tot-dis_j*s_j-dis_i*(s_i-s_j))(j<i)$$

不难理解,$[1,j]$的木头运到$j$处锯木厂，$[j+1,i]$运到$i$处锯木厂，剩余的运往山下锯木厂。


## 决策单调性

设

$$tot-dis_j*s_j-dis_i*(s_i-s_j)>tot-dis_k*s_k-dis_i*(s_i-s_k)(j<k<i)$$

化简

$$-dis_j*s_j+dis_i*s_j>-dis_k*s_k+dis_i*s_k$$

在未来状态$t$，证明:

$$-dis_j*s_j+dis_t*s_j>-dis_k*s_k+dis_t*s_k$$

由$dis_t=dis_i+val(val<0)$，

$$-dis_j*s_j+(dis_i+val)*s_j>-dis_k*s_k+(dis_i+val)*s_k$$

仅需证明:

$$val*s_j>val*s_k$$

$$s_j<s_k$$

证毕。

## 踢队头
$$-dis_j*s_j+dis_i*s_j>-dis_k*s_k+dis_i*s_k$$

$$dis_j*s_j-dis_k*s_k<dis_i*s_j-dis_i*s_k$$

$$calc(j,k)=\frac{dis_j*s_j-dis_k*s_k}{s_j-s_k}>dis_i$$

$k$优于$j$

即

$$calc(q_{head},q_{head+1})>dis_i$$

$q_{head+1}$优于$q_{head}$，踢去$head$

维护一个$calc(q_{head},q_{head+1})<dis_i$队列

同时我们可以发现，$dis_i$随$i$增大而减小，那么$calc(q_{head},q_{head+1})$随$dis_i$的减小，$head$不断增大，而不断减小。

因此，队列维护的应该是一个上凸壳。

## 踢队尾
由于维护一个上凸壳，

所以

$$calc(q_{tail-1},q_{tail})>calc(q_{tail},i)$$

反之，

当

$$calc(q_{tail-1},q_{tail})\le calc(q_{tail},i)$$

踢去队尾。

## AC code
```cpp
#include<cstdio>
#include<algorithm>
#include<cstdlib>
#include<cstring>
#include<cmath>
#define ll long long 
#define gc getchar()
using namespace std;
const int N=2e4+10;
inline void qr(ll &x)
{
	x=0;int f=1;char c=gc;
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=gc;}
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=gc;}
	x*=f;
}
inline void qw(ll x)
{
	if(x<0)x=-x,putchar('-');
	if(x/10)qw(x/10);
	putchar(x%10+48);
}
ll dis[N],s[N],tot,f[N];
int q[N],l,r;
inline double calc(int j,int k)
{
	return (double)(dis[j]*s[j]-dis[k]*s[k])/(s[j]-s[k]);
}
int main()
{
	int n;scanf("%d",&n);ll tot=0;
	for(int i=1;i<=n;i++)qr(s[i]),qr(dis[i]),s[i]+=s[i-1],tot+=s[i]*dis[i];
	for(int i=n;i>=1;i--)dis[i]+=dis[i+1];
	l=1;r=1;q[1]=0;ll ans=1e10;
	for(int i=1;i<=n;i++)
	{
		while(l<r&&calc(q[l],q[l+1])>=dis[i])++l;
		ans=min(ans,tot-dis[q[l]]*s[q[l]]-dis[i]*(s[i]-s[q[l]]));
		while(l<r&&calc(q[r],i)>=calc(q[r-1],q[r]))--r;
		q[++r]=i;
	}
	qw(ans);puts("");
	return 0;
}
```









---

## 作者：User_Unauthorized (赞：11)

设 $f_{k, i}$ 表示在点 $i$ 设置第 $k$ 个锯木厂的最小代价，那么有：

$$f_{k, i} = \min\limits_{j < i}\left(f_{k - 1, j} + w\left(j + 1, i\right)\right)$$

其中 $w\left(i, j\right)$ 表示区间 $\left[i, j\right]$ 的木材运送至点 $j$ 的代价。下面证明其满足四边形不等式。

首先，$w\left(l, r\right)$ 满足四边形不等式，当且仅当：

$$w\left(l, r\right) + w\left(l + 1, r - 1\right) \ge w\left(l + 1, r\right) + w\left(l, r - 1\right)$$

移项可得：

$$w\left(l, r\right) - w\left(l + 1, r\right) \ge w\left(l, r - 1\right) - w\left(l + 1, r - 1\right)$$

即 $f_l\left(r\right) = w\left(l, r\right) - w\left(l + 1, r\right)$ 随 $r$ 的增长单调不减，不难发现 $f_l\left(r\right)$ 可以表示为将点 $l$ 的木材运送至点 $r$ 的代价，由于距离和代价均为非负整数，因此 $f_l\left(r\right)$ 单调不减，即 $w\left(l, r\right)$ 满足四边形不等式。

进而可以推知 $f_{k, i}$ 满足决策单调性，因此使用分治优化转移即可。

复杂度为 $O\left(nk\log n\right)$，其中 $k = 3$。

---

## 作者：hicc0305 (赞：11)

一道斜率优化的DP题

先说一下几个数组的含义：

s[i]表示前i棵树的重量之和

d[i]表示第i棵树到第一棵树的距离

c[i]前i棵树运到i的费用

也就是第一个锯木厂的费用就是c[i],假设第二个锯木厂设在j(j>i)，那么i~j的树木运到j的费用就是c[j]-c[i]-s[i]·(d[j]-d[i])

那么也就是说第一个建在i，第二个建在j的总费用为第一棵树到i棵数的总费用c[i],第i+1到第j棵数的总费用c[j]-c[i]-s[i]·(d[j]-d[i])，以及第j+1棵到山脚的总费用c[n+1]-c[j]-s[j]·(d[n+1]-d[j])

加起来就是：c[n+1]-s[i]·(d[j]-d[i])-s[j]·(d[n+1]-d[j])

我们用f[j]表示第一个锯木厂建在j的最小费用，那么f[j]=min(c[n+1]-s[i]·(d[j]-d[i])-s[i]·(d[n+1]-d[j]))(0<i<j)

当我们枚举i时，如果k比i(k>i)更优则有：c[n+1]-s[i]·(d[j]-d[i])-s[i]·(d[n+1]-d[j])>c[n+1]-s[k]·(d[j]-d[k])-s[j]·(d[n+1]-d[j])  ->  s[i]·d[i]−s[k]·d[k]>d[j]∗(s[i]−s[k])   因为k>i所以s[k]>s[i]  ->   (s[i]·d[i]−s[k]·d[k])/(s[i]−s[k])就可以了

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
int n;
int c[20100],s[20100],d[20100];
int q[101000],dp[20100];
double clac(int j,int k)
{
	return (s[j]*d[j]-s[k]*d[k])/(s[j]-s[k]);
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		s[i]=s[i-1]+x;
		c[i+1]=c[i]+s[i]*y;
		d[i+1]=d[i]+y;
	}
	int l=1,r=1;
	q[1]=0,s[n+1]=s[n];
	for(int i=1;i<=n;i++)
	{
		while(l<r && clac(q[l],q[l+1])<d[i]) l++;
		int j=q[l];
		dp[i]=c[n+1]-s[j]*(d[i]-d[j])-s[i]*(d[n+1]-d[i]);
		while(l<r && clac(q[r-1],q[r])>clac(q[r],i)) r--;
		q[++r]=i;
	}
	int ans=0x7fffffff;
	for(int i=1;i<=n;i++)
		ans=min(ans,dp[i]);
	cout<<ans;
	return 0;
}
```
<d[j]

这样我们可以用单调队列来维护，在枚举i的时候，的d[j]是不变的，用单调队列来维护两点的斜率(s[i]·d[i]−s[k]·d[k])/(s[i]−s[k])就可以了

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
int n;
int c[20100],s[20100],d[20100];
int q[101000],dp[20100];
double clac(int j,int k)
{
	return (s[j]*d[j]-s[k]*d[k])/(s[j]-s[k]);
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		s[i]=s[i-1]+x;
		c[i+1]=c[i]+s[i]*y;
		d[i+1]=d[i]+y;//求出各个数组
	}
	int l=1,r=1;
	q[1]=0,s[n+1]=s[n];
	for(int i=1;i<=n;i++)
	{
		while(l<r && clac(q[l],q[l+1])<d[i]) l++;
		int j=q[l];
		dp[i]=c[n+1]-s[j]*(d[i]-d[j])-s[i]*(d[n+1]-d[i]);
		while(l<r && clac(q[r-1],q[r])>clac(q[r],i)) r--;//单调队列维护，把斜率不优的踢出去
		q[++r]=i;
	}
	int ans=0x7fffffff;
	for(int i=1;i<=n;i++)
		ans=min(ans,dp[i]);
	cout<<ans;
	return 0;
}
```


---

## 作者：ModestCoder_ (赞：6)

本题跟[这道题](https://blog.csdn.net/ModestCoder_/article/details/98648951)有点像

但是做法是不一样的，只是斜率优化

令$s_i=\sum_{j=1}^{i}w_j,dis_i=\sum_{j=i}^{n}d_j,tot=\sum_{i=1}^{n}w_i*dis_i$

枚举第二个锯木厂所在地$i$，答案是$ans_i=min(tot-s_j*dis_j-(s_i-s_j)*dis_i)$

此处斜率优化，若两个决策$x,y(x>y)$，x比y优必然满足

$tot-s_x*dis_x-(s_i-s_x)*dis_i<tot-s_y*dis_y-(s_i-s_y)*dis_i$

整理得$\frac{s_x*dis_x-s_y*dis_y}{s_x-s_y}>dis_i$

这个时候其实可以维护一个递减的上凸包

或者你可以两边乘上-1

变成$-\frac{s_x*dis_x-s_y*dis_y}{s_x-s_y}<-dis_i$

维护下凸包即可

Code：

```cpp
#include <bits/stdc++.h>
#define maxn 20010
using namespace std;
int n, s[maxn], d[maxn], tot, q[maxn];

inline int read(){
	int s = 0, w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
	return s * w;
}

double slope(int x, int y){ return -1.0 * (s[x] * d[x] - s[y] * d[y]) / (s[x] - s[y]); }

int main(){
	n = read();
	for (int i = 1; i <= n; ++i) s[i] = read() + s[i - 1], d[i] = read();
	for (int i = n; i; --i) tot += (d[i] += d[i + 1]) * (s[i] - s[i - 1]);
	int ans = 2147483647, h = 0, t = 0;
	for (int i = 1; i <= n; ++i){
		while (h < t && slope(q[h + 1], q[h]) < -d[i]) ++h;
		ans = min(ans, tot - s[q[h]] * d[q[h]] - (s[i] - s[q[h]]) * d[i]);
		while (h < t && slope(q[t], q[t - 1]) > slope(i, q[t])) --t;
		q[++t] = i;
	}
	printf("%d\n", ans);
	return 0;
}
```


---

## 作者：Uniecho1 (赞：5)

写在前面：这是04年的老题，数据对于现在而言已经很水了。但是，如果想要学斜率优化，就请不要用一些暴力方法飘过去。

好了现在正文。

因为**只会新建两个锯木厂**，我们可以暴力算出从山顶到第一个锯木厂的费用（评：废话），然后**对于每个位置枚举如果第二个锯木厂修在这里，最少需要话费多少钱**。

那么这个题就很明了了，我们要做的就只是耐心的打开括号并化简，得出递推式，然后找到优化方式。

**ans=f[j]+w[i]*(pos[i]-pos[N+1])-w[j]*pos[i]+sum[j]-sum[N]+w[N]*pos[N+1]**（其中f[j]为第一个锯木厂建在j时1-j会产生的费用，w[i]是前i棵树重量的前缀和，pos是指第i棵树到第1棵树的距离，sum[i]是for j 1 to i:w[j]*pos[j]）自己用原始式子化简一下就是这玩意

移项就可以得到f[j]+sum[j]=pos[i]*w[j]-w[i]*(pos[i]-pos[N+1])+sum[N]-w[N]*pos[N+1]+ans;

显然pos[i]已知且单调递增，用线性规划的思想，要使ans（与截距正相关）尽量的小，我们就需要使斜线y=pos[i]*x尽可能的小。
那么我们就需要维护一个下凸壳，来使我们总能截到一个最低的点：队首；

那么对于队尾维护其单调性即可，而队首则需要在前两个节点间的斜率小于pos[i]时弹出（因为pos[i]单调递增，现在截不到，以后就更别想了......不能理解请在本上画画图）

于是懒惰之人的代码就出炉了（我连scanf都懒得打了，没救了）
```cpp
#include<bits/stdc++.h>
using namespace std;
const long long maxn=200005;
long long N,pos[maxn],w[maxn],sum[maxn];
long long que[maxn],l=1,r=0,f[maxn],ans=LONG_LONG_MAX;
double calc(long long x,long long y){
	return (f[y]+sum[y]-f[x]-sum[x])/(w[y]-w[x]);
}
int main(){
	//freopen("in.txt","r",stdin);
	ios::sync_with_stdio(false);
	cin>>N;
	for(long long i=1;i<=N;i++){
		cin>>w[i]>>pos[i+1];
		pos[i+1]+=pos[i];
		sum[i]+=pos[i]*w[i]+sum[i-1];
		w[i]+=w[i-1];
		f[i]=w[i]*pos[i]-sum[i];//f[i]:将第一个厂建在i的费用 
	}
	for(long long i=1;i<=N;i++){
		while(l<r&&calc(que[l],que[l+1])<pos[i])l++;
		long long j=que[l];
		ans=min(ans,f[j]+w[i]*(pos[i]-pos[N+1])-w[j]*pos[i]+sum[j]-sum[N]+w[N]*pos[N+1]);
		while(l<r&&calc(que[r],que[r-1])>calc(i,que[r]))r--;
		que[++r]=i;
	}
	cout<<ans;
	return 0;
}
```
em，如果出锅了还请指出，我会修改的谢谢。

---

## 作者：ww3113306 (赞：3)

广告：[my blog](https://i.cnblogs.com/PostDone.aspx?postid=8906890&actiontip=%e4%bf%9d%e5%ad%98%e4%bf%ae%e6%94%b9%e6%88%90%e5%8a%9f)

blog里面的公式更加清晰一点

斜率优化DP

先考虑朴素DP方程，

f[i][k]代表第k个厂建在i棵树那里的最小代价，最后答案为f[n+1][3];

f[i][k]=min(f[j][k-1] + 把j+1~i的树都运到i的代价）

首先注意到“把j+1~i的树都运到i的代价”不太方便表达，每次都暴力计算显然是无法承受的，

于是考虑前缀和优化，观察到先运到下一棵树那里，等一会再运下去，和直接运下去是等效的。

设sum[i]代表1 ~ i的树都运到i的代价，

于是根据前缀和思想，猜想我们可以用1 ~ r 的代价与 1 ~ l-1的代价获取l ~ r的代价,

所以要做的就是吧1 ~ l-1 对 1 ~ r产生的贡献给算出来，然后减掉，

考虑先把1 ~ l-1的树都运到l-1,所以这部分的代价是sum[l-1],

然后再把树一次性运到r，那么代价是sum_weight[l-1] * (sum_len[r] - sum_len[l-1]);

									总的重量 * 现在要再次运的路程

于是用sum[r] 减去这两部分代价就可以得到l ~ r 的代价(把l ~ r的树都运到r)

代价(l ~ r) =  sum[r] - sum[l-1] - sum_weight[l-1] * (sum_len[r] - sum_len[l-1]);

那么如何计算sum ? 

也是一样的思想，用前面的推后面的，先得到前面的代价，再加上新增的代价即可

sum[i]=sum[i-1] + sum_weight[i-1] * len[i-1];//len[i-1]代表i-1到i的距离

于是我们就得到了DP方程：

当k==1时,f[i][k]=sum[i];

else

		f[i][k]=min(f[j][k-1] + sum[i] - sum[j] - sum_weight[j] * (sum_len[i] - sum_len[j]));

但是可以发现，由于k最大就是3，而且3必须是n+1才可以取，

而且当k==1时，f[i][k]就等于sum[i]，

所以考虑优化维数：

当k==1时，不用求，因为有sum了

当k==2时，调用的f[j][k-1]替换为sum[j],并且还可以发现由于后面有一个-sum[j],所以可以直接消掉

当k==3时，由于只有n+1可以取，所以直接在外面多写一个循环，相当于最后统计答案即可

转移方式同朴素方程

但是这样是n^2的DP，而n有20000，那怎么办呢？

考虑斜率优化。

首先我们用暴力打表可以发现，决策是单调的，

打表代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define R register int
#define AC 20100
int n,ans;
int sum[AC],sum_weight[AC],sum_len[AC],f[AC];
int weight[AC],len[AC];
inline int read()
{
	int x=0;char c=getchar();
	while(c < '0' || c > '9') c=getchar();
	while(c >= '0' && c <= '9') x=x*10+c-'0',c=getchar();
	return x; 
}

void pre()
{
	n=read();
	for(R i=1;i<=n;i++)
		weight[i]=read(),len[i]=read();
}

void getsum()
{
	for(R i=1;i<=n+1;i++)//山脚的也要求
	{
		sum_len[i]=sum_len[i-1] + len[i-1];
		sum_weight[i]=sum_weight[i-1] + weight[i];
		sum[i]=sum[i-1] + sum_weight[i-1] * len[i-1];
	//	printf("%d : %d\n",i,sum[i]);
	}
}

void work()
{
	for(R i=1;i<=n;i++)
	{
		int tmp=0;
		f[i]=INT_MAX;
		for(R j=1;j<i;j++)
		{
			if(sum[i] - sum_weight[j] * (sum_len[i] - sum_len[j]) < f[i])
			{
				f[i]=sum[i] - sum_weight[j] * (sum_len[i] - sum_len[j]);
				tmp=j;
			} 
		}
		printf("%d --- > %d\n",tmp,i);//打表验证决策单调性
	}
	ans=INT_MAX;
	for(R i=2;i<=n;i++)//注意应该是n+1,因为山脚是在下面
		ans=min(ans,f[i] + sum[n+1] - sum[i] - sum_weight[i] * (sum_len[n+1] - sum_len[i]));
	for(R i=2;i<=n;i++) printf("%d : %d\n",i,f[i]);
	printf("%d\n",ans);
}

int main()
{
	freopen("in.in","r",stdin);
	freopen("out.out","w",stdout);
	pre();
	getsum();
	work();
	fclose(stdin);
	fclose(stdout);
	return 0;
}

```

于是我们推斜率优化方程:

设有 k < j < i,且j优于k（相当于j是后面来的）,则有：

sum[i] - sum_weight[j] * (sum_len[i] - sum_len[j]) < sum[i] - sum_weight[k] * (sum_len[i] - sum_len[k])

sum_weight[j] * (sum_len[i] - sum_len[j]) > sum_weight[k] * (sum_len[i] - sum_len[k])

这里为了表示方便，用sw代表sum_weight,用sl代表sum_len;

sw[j] * sl[i] - sw[j] * sl[j] >  sw[k] * sl[i] - sw[k] * sl[k]

sw[k] * sl[k] - sw[j] * sl[j] > sw[k] * sl[i] - sw[j] * sl[i]

sw[k] * sl[k] - sw[j] * sl[j] > sl[i] * (sw[k] - sw[j])

(sw[k] * sl[k] - sw[j] * sl[j]) / (sw[k] - sw[j]) < sl[i] //注意sw[k] - sw[j]小于0，要变号

所以令k=(sw[k] * sl[k] - sw[j] * sl[j]) / (sw[k] - sw[j]);

则	while(head < tail && k(q[head],q[head+1]) < sum_len[i])  ++head;

while(head < tail && k(q[tail-1],q[tail]) > k(q[tail],i)) --tail;

最后上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define R register int
#define AC 20100
int n,ans;
int sum[AC],sum_weight[AC],sum_len[AC],f[AC];
int weight[AC],len[AC];
int q[AC],head,tail;
inline int read()
{
    int x=0;char c=getchar();
    while(c < '0' || c > '9') c=getchar();
    while(c >= '0' && c <= '9') x=x*10+c-'0',c=getchar();
    return x; 
}

inline double k(int x,int y)
{
    double a=sum_weight[x] * sum_len[x] - sum_weight[y] * sum_len[y];
    double b=sum_weight[x] - sum_weight[y];
    return a/b;
}

void pre()
{
    n=read();
    for(R i=1;i<=n;i++)
        weight[i]=read(),len[i]=read();
}

void getsum()
{
    for(R i=1;i<=n+1;i++)//山脚的也要求
    {
        sum_len[i]=sum_len[i-1] + len[i-1];
        sum_weight[i]=sum_weight[i-1] + weight[i];
        sum[i]=sum[i-1] + sum_weight[i-1] * len[i-1];
    //	printf("%d : %d\n",i,sum[i]);
    }
}

void work()
{
    head=1;
    for(R i=1;i<=n;i++)
    {
        f[i]=INT_MAX;
        
        /*int tmp=0;
        f[i]=INT_MAX;
        for(R j=1;j<i;j++)
        {
            if(sum[i] - sum_weight[j] * (sum_len[i] - sum_len[j]) < f[i])
            {
                f[i]=sum[i] - sum_weight[j] * (sum_len[i] - sum_len[j]);
                tmp=j;
            } 
        }
        printf("%d --- > %d\n",tmp,i);//打表验证决策单调性*/
        
        while(head < tail && k(q[head],q[head+1]) < sum_len[i]) ++head;
        int now=q[head];
    //	printf("%d --- > %d\n",now,i);
        f[i]=sum[i] - sum_weight[now] * (sum_len[i] - sum_len[now]);
        while(head < tail && k(q[tail-1],q[tail]) > k(q[tail],i)) --tail;
        q[++tail]=i;
    }
    ans=INT_MAX;
    for(R i=2;i<=n;i++)//注意应该是n+1,因为山脚是在下面,注意要从2开始，因为这是在枚举第2个厂在哪
        ans=min(ans,f[i] + sum[n+1] - sum[i] - sum_weight[i] * (sum_len[n+1] - sum_len[i]));
    printf("%d\n",ans);
}

int main()
{
//	freopen("in.in","r",stdin);
    pre();
    getsum();
    work();
//	fclose(stdin);
    return 0;
}

```

---

## 作者：i207M (赞：2)

## 题目总结

从山顶上到山底下沿着一条直线种植了 n 棵老树。当地的政府决定把他们砍下来。为了不浪费任何一棵木材，树被砍倒后要运送到锯木厂。

木材只能朝山下运。山脚下有一个锯木厂。另外两个锯木厂将新修建在山路上。你必须决定在哪里修建这两个锯木厂，使得运输的费用总和最小。假定运输每公斤木材每米需要一分钱。

你的任务是编写一个程序，从输入文件中读入树的个数和他们的重量与位置，计算最小运输费用。

## 数据范围

$N<=20000$

## 解题思路

一道DP；进一步思考发现是斜率优化；

考虑在每个点选址的代价，我们设$f[i]$表示在i处建一个场，另一个建在 $i$ 的上方的最小代价；

设tot为把所有木材送到山脚的代价；

我们可以通过减法求出在i，j处修建的代价：

$tot - sum[j = q.front()] * dis[j] - (sum[i] - sum[j]) * dis[i]$

sum[i]为第i棵树的权值前缀和，dis[i]为i到山脚距离（即后缀和）

考虑斜率优化

如此定义Y、X、K；

```cpp
#define X(i) (sum[i])
#define Y(i) (dis[i]*sum[i])
#define K(i) (dis[i])
#define slope(i,j) ((double)(Y(i)-Y(j))/(double)(X(i)-X(j)))
```

我们每次查询的斜率是单调递减的，我们要求截距最小，所以我们维护一个右上凸包；单调队列即可；

## 易错误区

没啥，想出来就好；

## 代码展示

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<string>
#include<algorithm>
#include<vector>
#include<map>
#include<set>
#include<list>
#include<queue>
#include<stack>
#include<bitset>
#include<deque>
using namespace std;
#define ll long long
#define ull unsigned long long
#define inf 0x3f3f3f3f
#define ri register int
#define il inline
#define fi first
#define se second
#define mp make_pair
#define pi pair<int,int>
#define mem0(x) memset((x),0,sizeof (x))
#define mem1(x) memset((x),0x3f,sizeof (x))
#define int ll
il char gc() {
    static const int BS = 1 << 22;
    static unsigned char buf[BS], *st, *ed;
    if (st == ed) ed = buf + fread(st = buf, 1, BS, stdin);
    return st == ed ? EOF : *st++;
}
#define gc getchar
template<class T>void in(T &x)
{
    x = 0; bool f = 0; char c = gc();
    while (c < '0' || c > '9') {if (c == '-') f = 1; c = gc();}
    while (isdigit(c)) {x = (x << 3) + (x << 1) + (c ^ 48); c = gc();}
    if (f) x = -x;
}
#undef gc
void out(int x) {
    if (x < 0) putchar('-'), x = -x;
    if (x > 9) out(x / 10);
    putchar(x % 10 + '0');
}
#define N 20010
#define int ll
int n;
int dis[N], sum[N], w[N], l[N];
deque<int>q;
#define X(i) (sum[i])
#define Y(i) (dis[i]*sum[i])
#define K(i) (dis[i])
#define slope(i,j) ((double)(Y(i)-Y(j))/(double)(X(i)-X(j)))
int ans=inf, tot;
signed main() {
    in(n);
    for (ri i = 1; i <= n; ++i) {
        in(w[i]), in(l[i]);
        sum[i] = sum[i - 1] + w[i];
    }
    for (ri i = n; i >= 1; --i) {
        dis[i] = dis[i + 1] + l[i];
        tot += w[i] * dis[i];
    }
    q.push_front(0);
    for (ri i = 1, j; i <= n; ++i) {
        while (q.size() > 1 && slope(*(q.begin()), *(q.begin() + 1)) > K(i))
            q.pop_front();
        ans = min(ans, tot - sum[j = q.front()] * dis[j] - (sum[i] - sum[j]) * dis[i]);
        while (q.size() > 1 && slope(*(q.end() - 1), *(q.end() - 2)) < slope(*(q.end() - 2), i))
            q.pop_back();
        q.push_back(i);
    }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：greenheadstrange (赞：1)

## 分析：
用sumw[i]记录∑ij=1w[j]∑j=1iw[j]维护前缀和 

用sumd[i]记录∑i−1j=1d[j]∑j=1i−1d[j]维护前缀和 

Cost[i]表示将第一个锯木厂建在i的位置时，1~i第一段的木材运到i的费用：

Cost[i]=Cost[i-1]+sumw[i-1]*d[i-1] 

接着就可以用列出状态转移方程，设f[i]表示第二个锯木厂建在i时的费用 

f[i]=min{ Cost[j]- sumw[j] (sumd[i]-sumd[j])- sumw[i] (sumd[n+1]-sumd[i]) } 

令 y=sumw[j]*sumd[j] ，x=sumw[j] ，k=sumd[i] 

维护下凸包，斜率优化乱搞即可。

## 下面是本蒟蒻的代码：

```cpp
#include<bits/stdc++.h>
#define INF 0x7ffffffffff
using namespace std;
long long n,sumw[50005],sumd[50005],w[50005],d[50005],c[50005],q[50005],f[50005],ans=INF;
long double find(long long j,long long k){//计算斜率
    return (double)(sumw[k]*sumd[k]-sumw[j]*sumd[j])/(sumw[k]-sumw[j]);
}
int main() {
    scanf("%lld",&n);
    for(long long i=1;i<=n;i++)scanf("%lld%lld",&w[i],&d[i]);
    for(long long i=1;i<=n+1;i++) {
        sumw[i]=sumw[i-1]+w[i];//求出w的前缀和
        sumd[i]=sumd[i-1]+d[i-1];//求出d的前缀和
        c[i]=c[i-1]+sumw[i-1]*d[i-1];//c[i]表示把第一个锯木厂设在i，第一段木材运到i的总费用
    }
    long long l=1,r=1;
    q[1]=1;f[1]=0;
    for(long long i=2;i<=n;i++) {
        while(l<r&&find(q[l],q[l+1])<=sumd[i])l++;//维护队首（删除非最优决策）
        f[i]=sumw[q[l]]*sumd[q[l]]-sumd[i]*sumw[q[l]]+c[n+1]-sumw[i]*(sumd[n+1]-sumd[i]);
        while(l<r&&find(q[r-1],q[r])>=find(q[r],i))r--;//维护队尾（维护下凸包性质）
        q[++r]=i;//入队
        ans=min(ans,f[i]);
    }
    printf("%lld",ans);
    return 0;
}
```
小提示：不开long long 见祖宗

---

## 作者：__Ressed__ (赞：0)

设：

　　sw[i]为1..i的w之和
  
　　sd[i]为1到i的距离
  
　　cost[i]为把第一个锯木厂建在i带来的花费

　　all[i,j]为把i..j所有木头运到j所需要的花费

所以$all[i,j]=cost[j]-cost[i-1]-sw[i-1]*(sd[j]-sd[i-1])$

我们设第2个锯木厂建在i所带来的最小花费为f[i]，则$f[i]=min\{cost[j]+all[j+1,i]+all[j+1,n+1]\}$

把all化掉，最终变成$f[i]=min\{cost[n+1]-sw[j]*(sd[i]-sd[j])-sw[i]*(sd[n+1]-sd[i])\}$

这样的话，如果直接做，复杂度是$O(n^2)$的

考虑优化，我们尝试比较在i固定时，f[j1]和f[j2]的值（j1<j2）,$f[j1]-f[j2]=sw[j2]*(sd[i]-sd[j2])-sw[j1]*(sd[i]-sd[j1])$

先假设$f[j1]-f[j2]<0$，也就是j1是较优解

那么可以得到$\frac{sw[j1]*sd[j1]-sw[j2]*sd[j2]}{sw[j1]-sw[j2]}>sd[i]$

发现右端随i单增，而且左端呈现斜率的形式

那么也就是说，如果在某次i++以后，某两个j1,j2的斜率<sd[i]，就可以确定j1永远不会是最优解了

那么可以维护一个队列，保证j1<j2<j3<... ，而且j1j2 ,j2j3 ,j3j4两两间的斜率递增

这样在每次i++的时候，先从队头向后把斜率<sd[i]的踢掉，之后的队头就是这次i的最优值

然后在统计完i的答案以后，i也可以作为第一个伐木厂了，就把它按照性质从队尾插进去

　　也就是说，对于队尾的两个元素t-1和t，若t.i间斜率>t-1.t间斜率，直接把i插到队尾；

　　　　若不是，则踢掉t然后继续做（此时的t绝对不会是最优解了，因为t-1与i间斜率<t-1与t间斜率，则要么t-1比t和i都优，要么sd[i]先超过t-1与i间的斜率，然后i会优于t-1和t）

队列里只剩一个点的话就谈不来斜率了..就不做了...

然后做的时候可以把比较斜率的除法改成乘法，防止出锅

每个点最多进队一次，出队一次，所以复杂度是O(n)的

代码很丑...

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
#include<queue>
#include<cmath>
#include<ctime>
#define LL long long int
using namespace std;
const int maxn=20005;

LL rd(){
   LL x=0;char c=getchar();int neg=1;
   while(c<'0'||c>'9'){if(c=='-') neg=-1;c=getchar();}
   while(c>='0'&&c<='9') x=x*10+c-'0',c=getchar();
   return x*neg;
}

int N,w[maxn],d[maxn];
LL sw[maxn],sd[maxn],cost;
int q[maxn],head,tail;

inline bool judge1(int j1,int j2,int i){return sw[j1]*sd[j1]-sw[j2]*sd[j2]<sd[i]*(sw[j1]-sw[j2]);}
inline bool judge2(int j1,int j2,int j3){return (sw[j1]*sd[j1]-sw[j2]*sd[j2])*(sw[j2]-sw[j3])<(sw[j2]*sd[j2]-sw[j3]*sd[j3])*(sw[j1]-sw[j2]);}
inline int get(int i,int j){return cost-sw[j]*(sd[i]-sd[j])-sw[i]*(sd[N+1]-sd[i]);}

int main(){
	int i,j,k;
	N=rd();
	for(i=1;i<=N;i++){
		w[i]=rd(),d[i]=rd();
		sw[i]=sw[i-1]+w[i];sd[i]=sd[i-1]+d[i-1];
		cost+=sw[i-1]*d[i-1];
	}cost+=sw[N]*d[N];sd[N+1]=sd[N]+d[N];
	head=tail=1;q[1]=1;
	int ans=2e9+10;
	for(i=2;i<=N;i++){
		while(head<tail&&(!judge1(q[head],q[head+1],i))) head++;
		ans=min(ans,get(i,q[head]));
		while(tail>head&&(!judge2(q[tail-1],q[tail],i))) tail--;
		q[++tail]=i; 
	}printf("%d\n",ans);
	
	return 0;
}


```

---


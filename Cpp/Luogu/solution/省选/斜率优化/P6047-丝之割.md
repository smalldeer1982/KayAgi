# 丝之割

## 题目背景

Pharloom 是一个神秘的王国，[丝线与歌](https://www.bilibili.com/video/av43623335)是那里最强大的力量。多弦琴是 Pharloom 的一种强大武器，正如多项式是 OI 中的强大武器。

因为你很讨厌多项式，你决定摧毁多弦琴。

## 题目描述

下面这部分题面只是为了帮助你理解题意，并没有详细的解释。更为严谨清晰的叙述见形式化题意。

多弦琴由两根支柱和连接两根支柱的 $m$ 条弦组成。每根支柱上都均匀安放着 $n$ 个固定点，第 $i$ 条弦连接上方支柱的第 $u_i$ 个固定点和下方支柱的第 $v_i$ 个固定点。

![](https://cdn.luogu.com.cn/upload/image_hosting/14igq7bn.png)

> 上图是一把多弦琴

为了摧毁多弦琴，你可以进行若干次切割操作。在一次切割操作中，你可以选择上方支柱的某一个固定点 $u$ 和下方支柱的一个固定点 $v$，所有被 $u$ 到 $v$ 的连线**从左到右**穿过的弦都将被破坏。但同时，你需要付出 $a_u \times b_v$ 的代价。

形式化题意：有 $m$ 条弦，一条弦可以抽象为一个二元组 $(u,v)$，你可以进行任意次切割操作，一次切割操作你将选择两个下标 $i$ 和 $j$ 满足 $i,j \in [1,n]$，然后所有满足 $u>i,v<j$ 的弦 $(u,v)$ 都将被破坏，同时你将付出 $a_i \times b_j​$ 的代价。求破坏所有弦的最小代价和。

## 说明/提示

#### 样例解释

对于第一组样例，使用两次切割，分别为 $(1,3)$，$(3,5)$，花费代价 $3 \times 1 + 1 \times 3 = 6$。

对于第二组样例，注意切割 $(5,1)$ 不能使弦 $(3,3)$ 消失。

---

#### 数据范围

**「本题采用捆绑测试」**

对于所有测试点，保证 $1 \leq n, m \leq 3\times 10^5$，$2 \leq u \leq n$，$1 \leq v \leq n-1$，$1 \leq a_i,b_i \leq 10^6$。

$\text{Subtask 1 (21 pts)}$ $n,m \leq 6$。

$\text{Subtask 2 (3 pts)}$ $m=1$。

$\text{Subtask 3 (1 pts)}$ $a_1=b_n = 1$。

$\text{Subtask 4 (25 pts)}$ $n,m \leq 100$。

$\text{Subtask 5 (29 pts)}$ $n,m \leq 10^3$。

$\text{Subtask 6 (21 pts)}$ 无特殊限制。

---
#### 提示

如果你认真观察了数据范围，你会发现这把多弦琴一定能够被破坏。

## 样例 #1

### 输入

```
5 2
3 9 1 9 9
9 9 1 9 3
2 1
5 4```

### 输出

```
6```

## 样例 #2

### 输入

```
5 1
9 9 9 9 1
1 9 9 9 9
3 3```

### 输出

```
81```

# 题解

## 作者：Schwarzkopf_Henkal (赞：23)

真的是非常 amazing 的一道斜率优化DP题啊。

前两天学了斜率优化，然后就想着找几道题做一做，苦于斜率优化它就没有几道蓝以下的题，所以第一道就被卡住了，当然事后发现是一个SB错误。对斜率优化还没有什么了解的可以看我的[**博客**](http://175.24.116.241/index.php/2020/08/03/%e6%96%9c%e7%8e%87%e4%bc%98%e5%8c%96/)，如果还有闲心，可以看看我原来写的[**乱搞**](http://175.24.116.241/index.php/2020/08/05/p6047%e4%b8%9d%e4%b9%8b%e5%89%b2/)，大概展现了我做这道题整个的心理变化？然后最后稍微总结一下斜率优化 DP 里面的一些细节，还有不能太确定的。

观察题面，它要求我们破坏几个二元组，其中非常特殊的一点是，必须从左到右穿过，才能破坏这个二元组，也就是：对于一次切割 $(i,j)$，你会切掉的弦包括 $(u,v)u>i,j<v$。那么于是我们能够得到，对于一两个二元组 $(i,j),(u,v)$，如果 $i>u,j<v$ 那么二元组 $(i,j)$ 是无用的，因为切掉第二个二元组的切割一定能切掉第一个二元组。然后我们再发现，这个东西事实上等于是不允许**有用**的二元组之间存在交叉。看一下图片：

![](https://cdn.luogu.com.cn/upload/image_hosting/14igq7bn.png)

在这个情况中，按上端点排序从左到右第二根弦是无用的。那么，最后去掉所有无用的二元组之后，我们得到了类似于这种情况的结果：

![](https://s1.ax1x.com/2020/08/06/ace9Tf.png)

既然不允许交叉，那么我们有随着 $u$ 的递增，所有的弦的 $v$ 也是递增的这一性质。那么这样的话事情就非常的明朗了，我们定义状态 $dp_i$ 是把前 $i$ 根弦全部切掉的最小代价。定义 $mina_{i,j}$ 是 $i$ 与 $j$ （按连接点编号）之间的 $a$ 的最小值，$minb_{i,j}$ 的定义类似，那么我们有状态转移方程：

$$dp_{i}=\min_{j<i}\{ dp_j+mina_{1,u_{j+1}-1}\times minb_{v_i+1,n}\}$$

然后我们就能把斜率优化的板子套上去了，点的坐标是 $(-mina_{1,u_{j+1}-1},dp_j)$ ，斜率是 $minb_{v_i+1,n}$，具有单调性质，可以使用单调队列维护一个下凸壳。某个【数据删除】跟我说了包括“这道题没有单调性质，必须要单调栈内二分”，“从队头入点从队尾出点才行”，“这道题的状态转移方程是 $dp_{i}=\min\limits_{j<i}\{ dp_j+mina_{u_j,u_{j+1}-1}\times minb_{v_i+1,n}\}$”，“斜率有可能是负的，点有可能在第二象限，所以维护一个下凸壳炸掉了”等等的一系列睿智言论，某种程度上他就是导致我卡这么久的罪魁祸首。那么既然有了点的坐标有了斜率就可以直接套斜率优化的板子上去了，接下来是代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,a[300005],b[300005],u[300005],v[300005];
long long gt[300005],st[300005],deq[300005],s=1,t=1;
long long dp[300005];
struct node{
    long long u,v;
    friend bool operator<(node a,node b){
        if(a.u==b.u)
            return a.v>b.v;
        return a.u<b.u;
    }
}cts[300005];
double slope(int x,int y){
    if(st[u[x+1]-1]==st[u[y+1]-1])
        return 1e18;
    return 1.0*(dp[x]-dp[y])/(st[u[y+1]-1]-st[u[x+1]-1]);
}
int main(){
    // freopen("P6047_6.in","r",stdin);
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    for(int i=1;i<=n;i++)
        cin>>b[i];
    for(int i=1;i<=m;i++)
        cin>>cts[i].u>>cts[i].v;
    sort(cts+1,cts+m+1);
    int TOT=m;
    m=0;
    for(int i=1,mx=0;i<=TOT;i++){
        if(cts[i].v>mx){
            u[++m]=cts[i].u;
            v[m]=cts[i].v;
        }
        mx=max(1ll*mx,v[m]);
    }
    gt[n+1]=1e18;
    st[0]=1e18;
    u[0]=1;
    for(int i=n;i>=0;i--)
        gt[i]=min(gt[i+1],b[i]);
    for(int i=1;i<=n;i++)
        st[i]=min(st[i-1],a[i]);
    for(int i=1;i<=m;i++){
        while(s<t&&slope(deq[s],deq[s+1])<gt[v[i]+1]){
            s++;
        }
        dp[i]=dp[deq[s]]+st[u[deq[s]+1]-1]*gt[v[i]+1];
        while(s<t&&slope(deq[t-1],deq[t])>slope(deq[t],i)){
            t--;
        }
        deq[++t]=i;
    }
    cout<<dp[m];
}
```
然后是比较简短的总结，包括一些常见的误区。首先，因为斜率优化它的模板柿子是 $b=y-kx$，所以记得 $k$ 和 $x$ 里面其中一个要搞成负的。第二个，使用单调队列的条件是斜率满足单调性质而不是点满足单调性质，如果不满足单调性质可以换用单调栈内二分，复杂度多一个 log。第三个，由于两个点的 x 坐标有可能相同所以需要特判成 inf，如果不特判会变成 -inf。

没了，就这样。

---

## 作者：天命之路 (赞：6)

这是一篇比较详细（冗长）的题解，慎读。
  
主要讲预处理和斜率优化 dp 的正确性证明。

### 预处理

对于每条弦，我们发现它们的关系具有传递性：如果 $i_1 \lt i_2,j_1 \gt j_2$，则当 $(i_1,i_2)$ 被摧毁时，$(j_1,j_2)$ 一定会被摧毁。

证明很简单，若 $(i_3,j_3)$ 摧毁了 $(i_1,j_1)$ ($(i_3,j_3)$ 不一定是一条弦） 则 $i_3 \lt i_1,j_3 \gt j_1$ 再由不等式的传递性，$i_3 \lt i_2,j_3 \gt j_2$,所以 $(i_3,j_3)$ 可摧毁 $(i_2,j_2)$

所以，如果一条弦可以被其他的弦传递到，那它对答案是可以没有贡献的，又因为答案要最小，所以，我们不用管他。

这是**前半部分**预处理的代码(还没讲完呢）：

```cpp
struct xian{
	ll u,v;
	xian(){u=v=0;}
	xian(ll _u,ll _v):u(_u),v(_v){}
	bool operator <(const xian p)   //等会要排序
	{
		if(v!=p.v)
		return v<p.v;
		return u<p.u;    //为了防止 v 相等的弦被和谐掉（必不可少！）
	}
}xi[M],xu[M];    // xu 是处理完的序列
inline void Read()
{
	
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
	for(int i=1;i<=n;i++) scanf("%lld",&b[i]);
	for(int i=1;i<=m;i++)
	{
		scanf("%lld%lld",&xi[i].u,&xi[i].v);
	}
	
}
inline void xiclear()
{
	sort(xi+1,xi+m+1);    //其实你会发现这跟二维偏序有点像
	for(int i=1;i<=m;i++)
	{
		while(top&&xu[top].u>xi[i].u) top--;    //如果栈顶的弦会被当前弦关联
		xu[++top]=xi[i];
	}
	xu[0]=xian(1,1);
	xu[top+1]=xian(n,n);      //等会有用
}
// xu 其实像一个单调栈
```
完事之后，你会发现，u 序列和 v 序列都是不下降的（可能取等），这样，我们就可以考虑 dp 了。

我们可以把弦分成几组，考虑切掉前 i 条弦的最小代价 $f_i$，枚举断点转移，可得：
$f_i=\min\{f_j+\min\{a_k|1 \le k \lt xu[j+1].u\} \times \min\{b_k|xu[i].v \lt k \le n\}\}$

它表示前 $j$ 条弦的最小代价加上消去第 $j+1 \dots i$ 条弦的最小代价和（你可以看到，多次切割可能会有交叉，但是没有关系，我们并不需要分得那么严）

为了简化状态转移方程，我们可以令 $up_i=\min\{a_j|1 \le j \lt xu[i].u\},down_i=\min\{b_j|xu[i].v \lt j \le n\}$

所以，最后就化为：$f_i=\min\{f_j+up_{j+1} \times down_i\}$

而 $up_i$和 $down_i$ 可以用 $up_{i-1}$ 和 $down_{i+1}$ 推得：
```cpp
inline void dpclear()
{
	memset(up,63,sizeof up);
	memset(down,63,sizeof down);
	for(int i=1;i<=top;i++)
	{
		up[i]=up[i-1];
		for(int j=xu[i-1].u;j<xu[i].u;j++)
		up[i]=min(up[i],a[j]);
	}
	for(int i=top;i>=1;i--)
	{
		down[i]=down[i+1];
		for(int j=xu[i].v+1;j<=xu[i+1].v;j++)
		down[i]=min(down[i],b[j]);
	}   //前面的预处理最后两行保证了预处理边界的正确性
}
//你们可以发现，up 不上升，down 不下降
```

然后进入 dp 部分：

### dp

如果对于每个 $f_i$ 暴力枚举断点，时间 $\Theta(n^2)$ ，可得79分，还是挺多的：
```cpp
void dp()
{
	memset(f,63,sizeof f);
    f[0]=0;
    for(int i=1;i<=top;i++)
    for(int j=0;j<i;j++) f[i]=min(f[i],up[j+1]*down[i]);
    cout<<f[top];
}

```

但是，这是过不了本题的，我们要进行优雅（毒瘤）的数学优化。

对方程稍做变形，可得：
$f_j=-up_{j+1} \times down_i + f_i$

这样，我们如果把每个决策点作为点$(-up_{j+1},f_j)$ 放入一个平面直角坐标系中去，那么这个方程就是一条以 $down_i$ 为斜率，$f_i$ 为截距的直线。 
我们所做的就是让就在直线接触某个决策点时，截距取最小。
比如说：
![](https://cdn.luogu.com.cn/upload/image_hosting/gf5gb9jq.png?x-oss-process=image/resize,m_lfit,h_510,w_675)

所以，我们只要取第一个接触到的决策点。

注：其中，A,B,C,D 是决策点，E,F不用管。

P.S. 在接下来，为了方便叙述，设 $slope(A,B)$ 表示决策点 $A$ 和 $B$ 间线段的斜率。

然而，我们发现，若三个决策点 $A,B,C$ 不满足 $slope(A,B) \lt slope(B,C)$,则决策点 B 永远不可能**最先**被从下方而来的直线接触到。

证明在[这里](https://www.luogu.com.cn/paste/3g0xtfem)。

所以，我们可以建立一个单调队列保存所有决策点。当有个决策点要入队时，若$slope(queue[tail-1],queue[tail]) \ge slope(queue[tail],i)$ (i 表示要入队的决策点),就把队尾出队。

为什么能这样维护？因为你会发现，横坐标是不下降的。（所以新入队的决策点肯定在最右边）

那我们怎么从队列中寻找最优解呢？

设当前状态转移方程所表示的直线的斜率为 $d$

其实，最优决策点就是一个点 $j$ ，满足 $slope(queue[j-1],queue[j]) \lt d \lt slope(queue[j],queue[j+1])$(取不取等号不影响结果）。

$\because$ 就像刚刚那个证明，由倒数第二步有 $slope(A,B) \lt slope(l) \lt slope(B,C)$ (其中 $l$ 是当前状态转移方程表示的直线）,所以点 B 是最优决策。

因为队列里斜率单调，所以我们可以码一个二分。

（注：因为 $x$ 坐标可能相等，所以最好用交叉相乘做斜率，不用特判）

```cpp
//我码的是左开右闭的单调队列
#define X(i) up[i+1]
#define Y(i) f[i]
#define lower_x(i,j) (X(j)-X(i))
#define lower_y(i,j) (Y(i)-Y(j))   //利用宏定义简化代码
inline int erfen(ll);
inline void dp()
{
//	memset(f,63,sizeof f);
	ll inf=f[M-1];
	f[0]=0;
	head=tail=1;
	for(int i=1;i<=top;i++)
	{
		while(head+1<tail&&lower_y(que[tail-2],que[tail-1])*lower_x(que[tail-1],i-1)>=
		lower_y(que[tail-1],i-1)*lower_x(que[tail-2],que[tail-1])) tail--;
		que[tail++]=i-1;    //维护斜率单调性
		int p=erfen(down[i]);
		f[i]=f[p]+up[p+1]*down[i];
	}
	
	cout<<f[top];
}
inline int erfen(ll slo)  找到最前面的斜率大于 slo 的线段
{
	if(head+1>=tail) return que[head];
	int lef=head,righ=tail-1,mid;
	while(lef<righ)
	{
		mid=lef+righ>>1;
		if(lower_y(que[mid+1],que[mid])<=slo*lower_x(que[mid+1],que[mid])) lef=mid+1;  //mid 本身可以被剔除
		else righ=mid;  //mid 本身还不能被剔除
	}
	return que[lef];
}
```


这道题至此就做完了。

你们可以看到，在题解区里还有 $\Theta(n)$ 的做法，但我不想码~~没码对~~，所以就贴出了个 $\Theta(n \times \log_2n)$ 的做法。

还能理解吧？

---

## 作者：devout (赞：5)

我们发现，第一排的每一个点$u$最多被割一次，而且如果我们选择割掉一个点，第二排的那个点一定会在$u$连出去的弦中最大的$v$的右边

所以我们对于每个点$i$只需要储存最远的那个$v$，记做$lmax_i$

考虑用$rmin$维护$b$的后缀最小值

设$f_i$表示在$i$这里割了一刀的最小花费

那么可以得到转移

$$f_i=\min\limits_{i+1\leq j\leq n}\{f_j+a_i\times rmin[\max\limits_{i+1\leq k\leq j}lmax_k+1]\}$$

那么这个东西的朴素转移是$O(n^3)$的

考虑快速的求区间$lmax$的最大值

我们发现，如果存在两条弦$(i,j),(u,v)$，其中$i<u,j>v$，那么$(u,v)$这条弦是没有用的，因为如果割掉了$(i,j)$，那么一定割掉了$(u,v)$

那么我们可以考虑对于$lmax$求前缀最大值，这个时候，我们可以通过直接调用$lmax_j$来确定区间的$lmax$的最大值

考虑这样做的正确性，因为如果$lmax_j$不在$(i,j]$里面的时候，这一段的东西是完全没有用的，最后转移到最优解的时候一定不是这一段，因为从让取到$lmax_j$的点转移一定更优

当然也可以把那些没有用的点删掉

那么对于$lmax$求前缀最大值之后，我们可以变成

$$f_i=\min\limits_{i+1\leq j\leq n}\{f_j+a_i\times rmin[lmax_j+1]\}$$

将式子转化成

$$f_j=-a_i\times rmin[lmax_j+1]+f_i$$

相当于转化成$n$个点$(rmin[lmax_j+1],f_j)$，可以进行斜率优化

因为每次的斜率$-a_i$不具有单调性，所以我们需要每次在凸壳上二分，这样可以在$O(n\log n)$的时间里解决这个问题

注意斜率是负数的时候做乘法判断时要注意不等号的方向，因为两边同时乘上一个负数后不等号的方向会改变

```cpp
#include <bits/stdc++.h>
using namespace std;

# define Rep(i,a,b) for(int i=a;i<=b;i++)
# define _Rep(i,a,b) for(int i=a;i>=b;i--)
# define RepG(i,u) for(int i=head[u];~i;i=e[i].next)

typedef long long ll;

const int N=3e5+5;
const int mod=1e9;

template<typename T> void read(T &x){
   x=0;int f=1;
   char c=getchar();
   for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
   for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+c-'0';
    x*=f;
}

int n,m;
int a[N],b[N],low=INT_MAX;
int lmax[N],rmin[N];
int q[N],top;
ll f[N];
ll ans=1e18;

ll fz(int x,int y){
	return f[x]-f[y];	
}

ll fm(int x,int y){
	return rmin[lmax[x]+1]-rmin[lmax[y]+1];	
}

int main()
{
	read(n),read(m);
	Rep(i,1,n)read(a[i]);
	Rep(i,1,n)read(b[i]);
	rmin[n]=b[n];
	_Rep(i,n-1,1)rmin[i]=min(rmin[i+1],b[i]);
	Rep(i,1,m){
		int x,y;
		read(x),read(y);
		lmax[x]=max(lmax[x],y);
		low=min(low,x-1);
	}
	Rep(i,1,n)lmax[i]=max(lmax[i-1],lmax[i]);
	f[n]=0;
	q[++top]=n;
	_Rep(i,n-1,1){
		int l=2,r=top,pos=1;
		while(l<=r){
			int mid=l+r>>1;
			if(fz(q[mid-1],q[mid])>=1ll*-a[i]*fm(q[mid-1],q[mid]))pos=mid,l=mid+1;
			else r=mid-1;
		}
		f[i]=f[q[pos]]+1ll*a[i]*rmin[lmax[q[pos]]+1];
		while(top>1&&fz(q[top],q[top-1])*fm(i,q[top])<=fz(i,q[top])*fm(q[top],q[top-1]))top--;
		q[++top]=i;
	}
	Rep(i,1,low)ans=min(ans,f[i]);
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：Super_Cube (赞：4)

# Solution

所以 Team Cherry 的 Silksong 在我退役前能发售吗？

先删去 $u_i\le u_j,v_i\ge v_j$ 的 $j$，因为一定会在切断 $i$ 时顺便把 $j$ 切断掉。

对 $a$ 做前缀 $\min$，$b$ 做后缀 $\min$。

设 $dp_i$ 表示切断前 $i$ 根弦的最小代价。转移：$dp_i=\displaystyle\min_{j=1}^idp_{j-1}+a_{u_j-1}\cdot b_{v_i+1}$，即把 $j\sim i$ 这一段一起切割。

直接做复杂度过不去，考虑斜率优化，先将 $\min$ 去掉，改写此式为：$dp_{j-1}=b_{v_i+1}\cdot(-a_{u_j-1})+dp_i$。

然后我们对于上式进行换元：

$$
\begin{cases}
y=dp_{j-1}\\
k=b_{v_i+1}\\
x=-a_{u_j-1}\\
b=dp_i\\
\end{cases}
$$

这样就可以很清晰的看出上式是类似于一次函数的。

我们为了让 $dp_i$ 能够取得最小值，那么就要最小化截距 $b$，只要截距最小，$dp_i$ 肯定也是最小的。

所以我们要对于所有的决策点维护一个下凸包，这样我们拿斜率为 $k$ 的直线去切的时候截距 $b$ 才能最小化。

因为前面有对 $a$ 做前缀 $\min$，$b$ 做后缀 $\min$ 的操作，保证了 $a$ 不升与 $b$ 不减，那么说明我们刚刚的斜率 $k$ 与 $x$ 都是不减的，就可以直接用单调队列维护凸包斜率。

---

## 作者：chen_qian (赞：4)

对于这类二维偏序问题。比较直观的转化方法就是在二维平面上进行分析。如下图

![](https://cdn.luogu.com.cn/upload/image_hosting/aotu2ue9.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

显然，假如说我们选定的点 $(i,j)$ 是图中的红色点。那么显然对于满足条件 $u>i$ 且 $v<j$ 的点就是处在红色点右下方的这些点。通过这个图片，我们还可以知道，假如说一个点 $(u_1,v_1)$，在 $(u_2,v_2)$ 点的左上方，那么我们在删除点 $(u_1,v_1)$ 时，必然会把 $(u_2,v_2)$ 也给删除，所以我们就没有必要去删 $(u_2,v_2)$，反正我们也会删掉 $(u_1,v_1)$。所以我们把类似 $(u_2,v_2)$ 的点（绿色点）定义为无效点，并把他们从图中删掉，剩下的就是有效点了。具体实现方式就是先按 $x$ 坐标排序之后，从前往后扫，并记录当前的 $y$ 的最大值。

定义 $f_i$ 表示删掉前 $i$ 个点的最小花费。显然我们枚举一个 $j$，让 $j+1 \dots i$ 一起删掉。就有方程：

$$f_i=\min_{j=0}^{i-1}(f_j+pre_{u_j-1}\times suf_{v_i+1})$$

其中
 $$pre_i=\min_{j=1}^i(a_i)$$
 
 $$suf_i=\min_{j=n}^i(b_j)$$
 
 一个从前往后一个从后往前计算即可。
 
 那么接下来我们如何找到备选答案的最小值呢？
 
直接将后式看做一个一次函数，将 $suf_{v_i+1}$ 看作自变量即可，实际上就是在备选集合中找定点一次函数最小值。

直接上李超线段树维护即可。

```
#include<bits/stdc++.h>
#define N 300005
#define M 100005
#define int long long 
using namespace std;
struct line{
	int k,b;
}p[N<<1];
int s[M*4];
int f[N],cnt;
int calc(int id,int x){
	return p[id].b+p[id].k*x;	
}
void modify(int u,int l,int r,int x){
	int mid=(l+r)>>1;
	int y=s[u];
	int ansx=calc(x,mid),ansy=calc(y,mid);
	if(l==r){
		if(ansx<ansy) s[u]=x;
		return ;
	}
	if(p[x].k>p[y].k){
		if(ansx<ansy){
			s[u]=x;
			modify(u<<1|1,mid+1,r,y);
		}
		else modify(u<<1,l,mid,x);
	}
	else if(p[y].k>p[x].k){
		if(ansx<ansy){
			s[u]=x;
			modify(u<<1,l,mid,y);
		}
		else modify(u<<1|1,mid+1,r,x);
	}
	else if(p[x].b<p[y].b) s[u]=x;
	return;
}
int query(int u, int l,int r,int x){
	int mid=(l+r)>>1;
	int res=calc(s[u],x);
	if(l==r) return res; 
	if(x<=mid) return min(res,query(u<<1,l,mid,x));
	else return min(res,query(u<<1|1,mid+1,r,x));
	
}
pair<int,int> q[N],t[N];
int n,m,num=0;
int a[N],b[N];
int pre[N],suf[N];
signed main(){
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
	for(int i=1;i<=n;i++) scanf("%lld",&b[i]);
	for(int i=1;i<=m;i++){
		scanf("%lld%lld",&q[i].first,&q[i].second);
	}
	sort(q+1,q+m+1);
	 for(int i=1,mx=0;i<=m;i++){
        if(q[i].second>mx){
        	t[++num]=q[i];
        }
        mx=max(1ll*mx,q[i].second);
    }
	int l=1;
	memset(pre,0x3f,sizeof(pre));
	memset(suf,0x3f,sizeof(suf));
	for(int i=1;i<=n;i++){
		pre[i]=min(pre[i-1],a[i]);
	}
	for(int j=n;j>=0;j--){
		suf[j]=min(suf[j+1],b[j]);
	}
	p[0].k=pre[t[1].first-1],p[0].b=0;
	for(int i=1;i<=num;i++){
		f[i]=query(1,1,M,suf[t[i].second+1]);
		p[++cnt].k=pre[t[i+1].first-1],p[cnt].b=f[i];
		modify(1,1,M,cnt);
	}
	cout<<f[num]<<endl;
}

```

虽然比斜率优化慢，但是更好理解（学了李超线段树后）。

 
 
 

---

## 作者：cff_0102 (赞：3)

斜率优化 dp。设 $dp_i$ 表示破坏掉前 $i$ 根弦需要的最小代价，那么正常的转移方程就应该是 $dp_i=\min\limits_{j=0}^{i-1}(dp_j+minu_{u_{j+1}}\times minv_{v_i})$，其中 $minu_x,minv_x$ 分别是在第 $x$ 个点之前的最小的 $a_i$ 和在第 $x$ 个点之后的最小的 $b_i$。

不过在这之前，当然要先给每根弦按 $u$ 排个序，还需要把没用的弦去掉。怎么算没用的弦呢？假设弦已经按 $u$ 为第一关键字，$v$ 为第二关键字排序，那么满足 $v_{i-1}\ge v_i$ 的弦 $i$ 就是没用的，因为在切割 $v_{i-1}$ 的时候就会切到 $v_i$，而且如果把 $v_i$ 保留，那么在 dp 时答案可能会出错，因为此时选择的切割路径下面的那个点可能会小于 $v_{i-1}$，而导致实际上切不到第 $i-1$ 根弦。

排完序，去掉无用弦之后就可以按正常的斜率优化 dp 来做了，具体的推导式可以在代码中看到。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=3e5+5;
/*
dp[i]:破坏掉前 i 根弦需要的最小代价
dp[i]=min[j=0,i-1](dp[j]+minu[u[j+1]]*minv[v[i]])
其中 minu[x] = min a_i,1<=i<x; minv[x] = min b_i,x<i<=n，可以 O(n) 预处理
dp[j]+minu[u[j+1]]*minv[v[i]]-dp[i]=0
dp[j]=minv[v[i]]*(-minu[u[j+1]])+dp[i]
y    =k          x              +b
最小值维护下凸壳 
*/
struct str{
	int u,v;
}uv[N];
bool cmp(str x,str y){
	if(x.u==y.u)return x.v<y.v;
	else return x.u<y.u;
}
int dp[N],u[N],v[N],minu[N],minv[N],a[N],b[N];
double k(int p1,int p2){
	double p1x=-minu[u[p1+1]];
	double p1y=dp[p1];
	double p2x=-minu[u[p2+1]];
	double p2y=dp[p2];
	return (p2y-p1y)/((p2x==p1x)?1e-9:p2x-p1x);
}
int n,m;
int q[N];
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=n;i++)cin>>b[i];
	for(int i=1;i<=m;i++)cin>>uv[i].u>>uv[i].v;
	sort(uv+1,uv+1+m,cmp);
	int del=0;
	for(int i=1;i<=m;i++){
		if(uv[i].v<=v[i-del-1]){
			del++;
			continue;
		}
		u[i-del]=uv[i].u,v[i-del]=uv[i].v;
	}
	m-=del;
	minu[1]=minv[n]=(1ll<<62);
	for(int i=2;i<=n;i++)minu[i]=min(minu[i-1],a[i-1]);
	for(int i=n-1;i>=1;i--)minv[i]=min(minv[i+1],b[i+1]);
	int h=1,t=0;
	for(int i=1;i<=m;i++){
		while(h<t&&k(q[t-1],q[t])>=k(q[t],i-1))t--;
		q[++t]=i-1;
		while(h<t&&k(q[h],q[h+1])<=minv[v[i]])h++;
		int j=q[h];
		dp[i]=dp[j]+minu[u[j+1]]*minv[v[i]];
	}
	cout<<dp[m];
	return 0;
}
```

---

## 作者：hhhqx (赞：2)

这题怎么还能交题解？无耻求赞 QwQ


---



对于 $u_1 \ge u_2$ 且 $v_2 \ge v_1$ 则把 $1$ 删除。

剩余的所有弦，满足 $u$ 越大 $v$ 越大。

把弦按照 $u$ 从小到大。$f_i$ 表示把前 $i$ 个剪短的最小代价。有 $f_i = \min(f_j + (\min\limits_{x=v_i+1}^{n}{b_x}) \times (\min\limits_{x=1}^{u_{j+1} - 1}{a_x}))$。

考虑斜率优化，对标 $b = y - k \times x$。这里把 $(-\min\limits_{x=1}^{u_{j+1} - 1}{a_x},f_j)$ 看作 $(x,y)$，那么 $k=\min\limits_{x=v_i+1}^{n}{b_x},b=f_i$。

显然 $k$ 递增，$y$ 递增，$x$ 递增。直接做就行了。

注意：求两点斜率时，需要特判 $x_1=x_2$。

```cpp
#include <bits/stdc++.h>

using namespace std;
using LL = long long;
using PLL = pair<LL, LL>;

const int MAXN = 3e5 + 3;
const int inf = 1e9;

int n, m, v[MAXN];
int a[MAXN], b[MAXN];
int dq[MAXN], h = 1, t = 0;
PLL vis[MAXN];

double Slope(int i, int j){
  if(vis[j].first == vis[i].first) return 1e18; 
	return double(vis[j].second - vis[i].second) / double(vis[j].first - vis[i].first);
}

int main(){
	ios::sync_with_stdio(0), cin.tie(0);
	//freopen("P6047_10.in", "r", stdin);
	cin >> n >> m;
	for(int i = 1; i <= n; i++) cin >> a[i];
	for(int i = 1; i <= n; i++) cin >> b[i];
	a[0] = inf;
	for(int i = 1; i <= n; i++) a[i] = min(a[i - 1], a[i]);
	b[n + 1] = inf;
	for(int i = n; i >= 1; i--) b[i] = min(b[i + 1], b[i]);
	
	for(int i = 1; i <= n; i++) v[i] = 0;
	for(int i = 1, U, V; i <= m; i++){
		cin >> U >> V, v[U] = max(v[U], V);
	}
	for(int i = 1, mx = 0; i <= n; i++){
		if(mx >= v[i]) v[i] = 0;
		mx = max(mx, v[i]);
	}
	for(int i = n, la = 0; i >= 0; i--){
		if(v[i] == 0 && i > 0) continue;
		vis[i].first = - la, la = a[i - 1];
	}
	
	LL ans = 0;
	vis[0].second = 0;
	dq[++t] = 0;
  for(int i = 1; i <= n; i++){
		if(v[i] == 0) continue;
		LL k = b[v[i] + 1], f = 0;
		while(h < t && Slope(dq[h], dq[h + 1]) <= k) h++;
		ans = f = vis[dq[h]].second - k * vis[dq[h]].first;
		vis[i].second = f;
		while(h < t && Slope(dq[t], i) <= Slope(dq[t - 1], dq[t])) t--;
		dq[++t] = i;
	}
	cout << ans;
	return 0;
}
/*
6 6
9 1 3 9 3 9 
9 9 8 1 5 3 
6 5
5 3
4 2
2 3
3 3
4 5


12
*/
```

---

## 作者：Fading (赞：2)

没有题解？我来水一篇

把弦转化成二维平面的点，横坐标为上方编号，纵坐标为下方编号，答案等价于消去所有弦点对的最小代价。

发现我们一次可以消去一个点右下方的所有弦点。

首先有很多弦点是没用的，如果有弦$a$在弦$b$的左上方，那么弦$b$没有用，用单调栈筛去这些点。

发现平面的点单调了，设计$dp$

先给所有弦点按照横坐标大小从小到大排序

设$f_i$表示前$i$个点都消去的代价，然后$x_i,y_i$分别表示前$i$个点的横纵坐标，有

$$f_i=\max({f_j+(\min_{k=1}^{x_{j+1}-1}a_k})\times(\min_{k=y_i+1}^{n}b_k))$$

注意到这个式子可以斜率优化，可以$O(n)$。

~~我不会告诉你我当时单调性搞反了，以为不能单调队列，写了李超线段树~~

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline ll read(){
	ll x=0,f=1;char ch=getchar();
	while (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}
	while (isdigit(ch)){x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
	return x*f;
}
struct line{
	ll k,b;
}_a[1010101];
ll seg[4010101],tot;
inline bool better(ll id1,ll id2,ll pos){
	return pos*_a[id1].k+_a[id1].b<pos*_a[id2].k+_a[id2].b;
}
#define mid ((lb+rb)>>1)
void update(ll rt,ll lb,ll rb,ll x){
    if (!x) return;
    if (!seg[rt]) return (void)(seg[rt]=x);
	if (lb==rb) return (void)(better(x,seg[rt],lb)?seg[rt]=x:0);
	if (_a[seg[rt]].k>_a[x].k){
		if (better(x,seg[rt],mid)) update(rt<<1,lb,mid,seg[rt]),seg[rt]=x;
		else update(rt<<1|1,mid+1,rb,x);
	}else{
		if (better(x,seg[rt],mid)) update(rt<<1|1,mid+1,rb,seg[rt]),seg[rt]=x;
		else update(rt<<1,lb,mid,x);
	}
}
ll query(ll rt,ll lb,ll rb,ll x){
    if (!seg[rt]) return _a[0].k*x+_a[0].b;
	ll ans=_a[seg[rt]].k*x+_a[seg[rt]].b;
	if (lb==rb) return ans;
	ans=min(ans,(mid>=x?query(rt<<1,lb,mid,x):query(rt<<1|1,mid+1,rb,x)));
	return ans;
}
ll n,m,a[1010101],b[1010101],h,t,dl[1010101];
ll sta[1010101],A[1010101],B[1010101],cac[1010101];
ll AA[1010101],BB[1010101],dp[1010101];
int main(){
	n=read(),m=read();
	for (int i=1;i<=n;i++) a[i]=read();
	for (int i=1;i<=n;i++) b[i]=read();
	A[0]=B[n+1]=0x3f3f3f3f;
	for (int i=1;i<=n;i++) A[i]=min(A[i-1],a[i]);
	for (int i=n;i;i--) B[i]=min(B[i+1],b[i]);
	for (int i=1;i<=m;i++){
		ll x=read(),yy=read();
		cac[x]=max(cac[x],yy);
	}
	int N=0;
	for (int i=n;i;i--){
		if (!cac[i]) continue;
		while (N&&cac[sta[N]]<=cac[i]) N--;
		sta[++N]=i;
	}
	reverse(sta+1,sta+1+N);
	for (int i=0;i<=N;i++){
		BB[i]=B[cac[sta[i]]+1],AA[i]=A[sta[i+1]-1];
	}
	_a[0].k=999999999,_a[0].b=999999999;
	_a[++tot].k=AA[0],_a[tot].b=0;
	update(1,0,n,tot);
	for (int i=1;i<=N;i++){
		dp[i]=query(1,0,1e6,BB[i]);
		_a[++tot].k=AA[i];_a[tot].b=dp[i];
		update(1,0,1e6,tot);
	}
    printf("%lld",dp[N]);
	return 0;
}
```


---

## 作者：JK_LOVER (赞：2)

主要是提供一种更加易懂的李超线段树写法。[更好的阅读体验。](https://www.luogu.com.cn/blog/xzc/solution-p6047)
# 分析
真的是好题。我们考虑并不是所有线段都是有用的，如果有两条线段相交，那么其实我们只需要切断第一个 $(u_1\le u_2)$ 就行了。所以我们可以形式化的表达当 $u_i \le u_j$ 则 $v_i \le v_j$ 时，这才是个合法图。而我们就是要求这个图转换为合法图之后的最小答案。我们考虑线性 $dp$ 。令 $f_i$ 以 $i$ 结尾的最小代价。那么我们的转移为 $f_i=\min_{j<i}\{f_j + \min_{1\le k< u_{{j+1}}}\{a_k\}\times \min_{v_i<k\le n}\{b_k\}\}$ 。我们发现其实后面的是一堆常数。那么这又是一个满足 $y=kx+b$ 的形式了。所以我们考虑李超线段树来维护这个凸壳。
# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
LL read() {
	LL x = 0,f = 0;char ch = getchar();
	while(!isdigit(ch)) {if(ch == '-')f=1;ch=getchar();}
	while(isdigit(ch)) {x = x * 10 + ch - '0';ch=getchar();}
	return f?-x:x;
}
const LL N = 5e5 + 100,inf = 0x3f3f3f3f3f3f3f3f,M = 1e6+10;
struct Node{LL u,v;}e[N],p[N];
bool cmp(Node a,Node b) {return a.u < b.u;}
LL n,m,A[N],B[N],U[N],D[N],f[N],K[N];
LL clac(LL id,LL pos) {return K[id] * pos + f[id];}
LL top2;
LL lc[N],rc[N],size,t[N],rt;
void insert(LL &u,LL l,LL r,LL id) {
	if(!u) u = ++size;
	if(!t[u]) {t[u] = id;return;}
	LL mid = l + r >> 1;
	LL val_L = clac(id,l),val_R = clac(id,r),val_l = clac(t[u],l),val_r = clac(t[u],r);
	if(val_L <= val_l && val_R <= val_r) {t[u] = id;return;}
	if(val_l <= val_L && val_r <= val_R) {return;}
	insert(lc[u],l,mid,id);insert(rc[u],mid+1,r,id);
}
LL query(LL u,LL l,LL r,LL pos) {
	if(!u || !t[u]) return inf;
	LL ans = clac(t[u],pos);
	LL mid = l + r >> 1;
	if(pos <= mid) return min(ans,query(lc[u],l,mid,pos));
	else return min(ans,query(rc[u],mid+1,r,pos));
}
int main() {
	n = read();m = read();
	for(LL i = 1;i <= n;i++) U[i] = read();
	for(LL i = 1;i <= n;i++) D[i] = read();
	memset(A,0x3f,sizeof(A));memset(B,0x3f,sizeof(B));
	A[1]=U[1];for(LL i = 1;i <= n;i++) A[i] = min(A[i-1],U[i]);
	B[n]=D[n];for(LL i = n;i >= 1;i--) B[i] = min(B[i+1],D[i]);
	for(LL i = 1;i <= m;i++) {e[i].u = read();e[i].v = read();}
	sort(e+1,e+1+m,cmp);
	LL mx = 0;
	for(LL i = 1;i <= m;i++) {
		if(e[i].v > mx) {
			p[++top2] = e[i];
			mx = e[i].v;
		}
	}
	K[top2 + 1] = A[p[1].u-1];f[top2 + 1] = 0;
	insert(rt,1,M,top2+1);
	for(LL i = 1;i <= top2;i++) {
		f[i] = query(rt,1,M,B[p[i].v+1]);
		K[i] = A[p[i + 1].u - 1];
		insert(rt,1,M,i);
	}
	cout << f[top2] << endl;
} 
```



---

## 作者：_ChongYun_ (赞：1)

一道简单的斜率优化 dp。

### Solution

当选择二元组 $(p,q)$ 时，对于满足 $i>p,j<q$ 的弦 $(i,j)$：若存在弦 $(i',j')$ 满足 $i'>i,j'<j$，在破坏弦 $(i,j)$ 时一定会破坏弦 $(i',j')$，故先删去所有的弦 $(i',j')$。

在排序后，由于弦的上坐标和下坐标分别都单调递增，考虑 dp 分划阶段。

令 $c_i=\min\limits_{k=1}^{i} a_i,d_i=\min\limits_{k=i}^{n} b_i$，容易得到状态转移方程：
$$dp_i=\min_{j<i} \{dp_j+c_{u_{j+1}-1}d_{v_{i-1}}\}$$

考虑斜率优化。将式子转化为 $y=kx+b$ 的形式，有：
$$\begin{cases}
x=-c_{u_{j+1}-1} \\
y=dp_j \\
k=d_{v_{i-1}} \\
b=dp_i
\end{cases}$$

按照常规斜率优化 dp 套路，单调队列维护凸包斜率即可。

### Code


```cpp
/* ChongYun */
#include<bits/stdc++.h>
#define START_LL 1
using namespace std;
#define fir first
#define sec second
#define pii pair<int,int>
#define start(x) using namespace x
#if START_LL 
#define int long long
#endif
#define ldb long double
namespace IO{
    #define flush() fwrite(obuf,1,O-obuf,stdout)
    #define putchar(x) ((O==obuf+(1<<21))&&(flush(),O=obuf)),*O++=x
    char buf[1<<23],*p1=buf,*p2=buf,obuf[1<<23],*O=obuf;
    #define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
    inline int read(){
        register int x=0,f=1;
        register char ch=getchar();
        while(ch<'0'||ch>'9'){
            if(ch=='-') f=-1;
            ch=getchar();
        }
        while(ch>='0'&&ch<='9'){
            x=(x<<1)+(x<<3)+(ch^48);
            ch=getchar();
        }
        return x*f;
    }
    inline void write(int x){
        if(x>9) write(x/10);
        putchar((x%10)^48);
        return ;
    }
    struct Flush{ ~Flush(){flush();} }_;
}start(IO);
const int N=3e5+5,inf=1e18;
int n,k,a[N],b[N],c[N],d[N];
int q[N],hd=1,tl=0,dp[N];
pii Rhy[N],Mil[N];
bool cmp(pii pt,pii qt){
    if(pt.fir==qt.fir) return pt.sec<qt.sec;
    return pt.fir<qt.fir;
}
ldb getx(int qwq){ return a[Mil[qwq+1].fir-1]; }
ldb gety(int qwq){ return dp[qwq]; }
ldb Slope(int qwq,int qaq){ 
    if(getx(qwq)==getx(qaq)) return inf;
    return -(gety(qwq)-gety(qaq))/(getx(qwq)-getx(qaq)); 
}
signed main(){
	n=read(); k=read();
    for(int i=1;i<=n;i++) a[i]=read();
    for(int i=1;i<=n;i++) b[i]=read();
	for(int i=1;i<=k;i++){
        Rhy[i].fir=read();
        Rhy[i].sec=read();
    }
    sort(Rhy+1,Rhy+k+1,cmp);
    int now=n; n=1;
    int l=Rhy[1].fir,r=Rhy[1].sec;
    Mil[1]=Rhy[1];
    for(int i=2;i<=k;i++){
        if(l<=Rhy[i].fir&&Rhy[i].sec<=r) continue;
        l=Rhy[i].fir,r=Rhy[i].sec;
        Mil[++n]=Rhy[i];
    }
    k=now; 
    a[0]=b[k+1]=inf;
    for(int i=1;i<=k;i++) a[i]=min(a[i],a[i-1]);
    for(int i=k;i>=0;i--) b[i]=min(b[i],b[i+1]);
	q[++tl]=0;
    for(int i=1;i<=n;i++){
        while(hd<tl&&Slope(q[hd],q[hd+1])<=b[Mil[i].sec+1]) ++hd;
	    dp[i]=dp[q[hd]]+a[Mil[q[hd]+1].fir-1]*b[Mil[i].sec+1];
	    while(hd<tl&&Slope(q[tl],q[tl-1])>=Slope(i,q[tl])) --tl;
	    q[++tl]=i;
    }
    printf("%lld\n",dp[n]);
	return 0;
}
```

---

## 作者：Kelvin2009 (赞：1)

这是一道斜率优化 DP。

首先简化弦图。只有从该弦的上端点左边到下端点右边穿过，该弦才会消失。考虑到每条弦都必须删掉，对于两条弦的位置，分为 $3$ 种特殊情况：

1. 共上端点。显然，下端点最靠右的弦被消掉时，靠左的弦也一定会被消掉。因此不用再考虑靠左的弦。

2. 共下端点。上端点靠左的弦被消掉时，靠右的边也一定会被消掉。因此不用再考虑靠右的弦。

3. 中间部分相交。可以发现：一定有一条弦上端点在另一条弦上端点的左端，且这条弦下端点在另一条弦下端点的右端。只要这条弦被消掉，另一条弦也一定会被消掉，不用考虑。

将不用考虑的弦全都删去，剩下的弦完全互不相交。消去剩下的弦并对其排序，于是考虑 DP。设 $dp_{i}$ 表示消去前 $i$ 条弦所需的代价。设上端点的前缀最小值为 $pre_{i}$，下端点的后缀最小值为 $bre_{i}$，易得：
$$dp_{i}=\min_{0\leqslant j<i}{(dp_{j}+pre_{(u_{(i+1)}-1)}\cdot bre_{(v_{i}+1)})}$$ 

其中，下标 $0$ 是一个初始化。

推导：

设 $mina_{i}$、$minb_{i}$ 分别为 $pre_{(i-1)}$ 与 $bre_{(i+1)}$。令 $j_{1}<j_{2}$ 且 $j_{1}$ 更优。
$$dp_{j_{1}}+mina_{u_{(j_{1}+1)}}\cdot minb_{v_{i}}<dp_{j_{2}}+mina_{u_{(j_{2}+1)}}\cdot minb_{v_{i}}$$ 

$mina$ 单调不增，需变号：
$$\frac{dp_{j_{1}}-dp_{j_{2}}}{mina_{u_{(j_{2}+1)}}-mina_{u_{(j_{1}+1)}}}>minb_{v_{i}}$$ 

然后正常维护凸包。


---

代码：


---


```cpp
#include<bits/stdc++.h>
using namespace std;
const int range=1e6+5;
const double lim=1e18;
int n,m;
long long a[range],b[range];
struct line
{
	int u,v;
	bool operator <(const line &o) const
	{
		if(u==o.u) return v>o.v;
		return u<o.u;
	}
}line[range];
int len,u[range],v[range];
long long mina[range],minb[range];
int que[range];
long long dp[range];
inline double slope(int j1,int j2)
{
	if(mina[u[j1+1]]==mina[u[j2+1]]) return lim;
	return 1.0*(dp[j1]-dp[j2])/(mina[u[j2+1]]-mina[u[j1+1]]);
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
	for(int i=1;i<=n;i++) scanf("%lld",&b[i]);
	for(int i=1;i<=m;i++) scanf("%d%d",&line[i].u,&line[i].v);
	sort(line+1,line+1+m);
	int rec=0;
	for(int i=1;i<=m;i++)
	{
		if(line[i].u==line[i-1].u) continue;
		if(line[i].v>rec)
		{
			u[++len]=line[i].u;
			v[len]=line[i].v;
			rec=line[i].v;
		}
	}
	//cout << "ok" << endl;
	mina[1]=a[1],minb[n]=b[n];
	for(int i=2;i<=n;i++) mina[i]=min(mina[i-1],a[i]);
	for(int i=n;i>=2;i--) mina[i]=mina[i-1];
	for(int i=n-1;i;i--) minb[i]=min(minb[i+1],b[i]);
	for(int i=1;i<n;i++) minb[i]=minb[i+1];
	int l,r;
	l=r=1;
	for(int i=1;i<=len;i++)
	{
		while(l<r && slope(que[l],que[l+1])<=minb[v[i]]) l++;
		dp[i]=dp[que[l]]+mina[u[que[l]+1]]*minb[v[i]];
		while(l<r && slope(que[r-1],que[r])>=slope(que[r],i)) r--;
		que[++r]=i;
	}
	printf("%lld",dp[len]);
	return 0;
}
```

---

## 作者：wYYSZLwSSY (赞：1)

## 题意
有 $m$ 条弦，一条弦可以抽象为一个二元组 $(u,v)$，你可以进行任意次切割操作，一次切割操作你将选择两个下标 $i$ 和 $j$ 满足 $i,j \in [1,n]$，然后所有满足 $u>i,v<j$ 的弦 $(u,v)$ 都将被破坏，同时你将付出 $a_i \times b_j$ 的代价。求破坏所有弦的最小代价和。

数据范围：$1 \leq n,m \leq 3\times 10^5$，$2 \leq u \leq n$，$1 \leq v \leq n-1$，$1 \leq a_i,b_i \leq 10^6$。

## 题解

斜率优化好题，斜率优化的一些细节都有所体现。

### 基本思想：

注意到如果有两个弦左右端点是“交错”的，那么一定有删掉其中某个另一个也会删掉。准确地讲，两个弦如果 $u < u'$ 但 $v' \leq v$，或者 $u=u'$ 但 $v'\leq v$，则删掉第一个（$(u,v)$）的同时可以删掉第二个，那么第二个就没有保留的必要。最后需要保留下来的弦是 $u,v$ 都单调递增的。

### $n,m \leq 10^3$ 做法

我们先预处理出有必要考虑的弦，可以按 $u$ 排序，保留每个 $u$ 有最大 $v$ 的那个弦，然后删去其他的弦，进而删去 $v$ 不增的。

之后考虑 dp。

设 $f_i$ 表示删除前 $i$ 根弦（删去后且保持排序）所需要的最小代价，转移显然：

$$f_i=\min^{i-1}_{j=0} f_j+\min_{k=1}^{u_{j+1}-1} a_j\times \min_{k=v_i+1}^{n} b_k$$

预处理 $a,b$ 的前后缀和可以做到 $O(m^2)$，可以通过 Sub1-6。

### 正解

稍微变化一下式子（用 $m1$ 表示 $a$ 的前缀和，用 $m2$ 表示 $b$ 的后缀和）：

$$f_j=f_i-m1_{u_{j+1}-1} \times m2_{v_i+1}$$

发现这是斜率优化的经典形式。

取 $f_j$ 为纵坐标，$-m1_{u_{j+1}-1}$ 为横坐标，$m2_{v_i+1}$ 单增符合上凸性可以直接单调队列无需二分。

注意进出队列时特判一下斜率不存在的情况，就算化为乘法判断也需要。

时间复杂度 $O(m\log m)$。

## 代码
```cpp
#include<bits/stdc++.h>
#define int long long 
#define ft first
#define sd second
using namespace std;
int n,m;
int min1[300005];
int min2[300005];
pair<int,int>pr[300005];
vector<int>xl,xl1;
int f[300005];
int dl[300005];
int a[300005];
int b[300005];
pair<int,int>np[300005];
signed main(){
	cin.tie(0)->sync_with_stdio(0);
	cin>>n>>m;
	min1[0]=1e9;
	for(int i=1;i<=n;++i)cin>>a[i],min1[i]=min(min1[i-1],a[i]);
	for(int i=1;i<=n;++i)cin>>b[i];
	min2[n+1]=1e9;
	for(int i=n;i;--i)min2[i]=min(min2[i+1],b[i]);
	for(int i=1;i<=m;++i)cin>>pr[i].ft>>pr[i].sd;
	sort(pr+1,pr+m+1);
	int last=0;
	for(int i=1;i<=m;++i){
		if(pr[i+1].ft!=pr[i].ft){
			last=pr[i].ft;
			xl.push_back(i);
		}
	}
	xl1.push_back(0);
	for(int i=0;i<xl.size();++i){
		if(i and pr[xl[i]].sd<=pr[xl1[xl1.size()-1]].sd)continue;
		xl1.push_back(xl[i]);
	}
	sort(xl1.begin(),xl1.end());
	int l=1,r=0;
	dl[++r]=0;
	for(int i=1;i<xl1.size();++i)
		np[i]=pr[xl1[i]];
	for(int i=1;i<xl1.size();++i){
		while(l<r and (f[dl[l+1]]-f[dl[l]])<\
			min2[np[i].sd+1]*(-min1[np[dl[l+1]+1].ft-1]+min1[np[dl[l]+1].ft-1]))++l;
		f[i]=f[dl[l]]+min1[np[dl[l]+1].ft-1]*min2[np[i].sd+1];
		while(l<r and (-min1[np[dl[r]+1].ft-1]+min1[np[dl[r-1]+1].ft-1])==0)--r;//特判
		while(l<r and (f[i]-f[dl[r]])*(-min1[np[dl[r]+1].ft-1]+min1[np[dl[r-1]+1].ft-1])<\
				(f[dl[r]]-f[dl[r-1]])*(-min1[np[i+1].ft-1]+min1[np[dl[r]+1].ft-1]))--r;
		dl[++r]=i;
	}
	cout<<f[xl1.size()-1]<<'\n';
	return 0;
}

```

---

## 作者：tommy0221 (赞：1)

[P6047 丝之割](https://www.luogu.com.cn/problem/P6047)

[更好的阅读体验](https://www.cnblogs.com/zzctommy/p/13905543.html)

挺有意思的一道题呢！

首先我们发现，如果我们要割掉弦 $i$ ，那么所花的代价最小是 $suf_{u_i+1}\times pre_{v_i-1}$

其中 $suf_i$ 表示 **数组a** 的后缀最小值，$pre_i$ 表示 **数组b** 的前缀最小值。

这个很显然，第一行从后找一个最小的，第二行从前找一个最小的，连起来这根弦就割掉了。

尝试搞个dp出来，如果按照 $u$ 排序割掉一段弦 $i,\cdots,j$ 呢？最靠左 $v$ 不知道，如果拿DS维护 $v$ 的区间最值那就很难继续优化了，这个dp写不下去。

换个方向。

思考一会可以隐约感觉到有些弦是没用的，就是割掉另一根弦一定会割掉它，那么这根弦就是没用的了。

考虑有两根弦 $i,j$ ，割掉 $i$ 必然割掉 $j$ 所需满足的条件，显然是 $u_i<u_j$ 且 $v_i>v_j$ 。

**这东西不就是两根弦 $i,j$ 有交的充要条件吗！**

那么我们可以通过排序来得出所有“有用”的弦，**这些有用的弦一定是没有交点的**。

形象一点[放个图](https://img2020.cnblogs.com/blog/1943963/202010/1943963-20201031105731530-1411997367.png) ~~谁能教我在ubuntu上怎么画直线啊~~

根据这个性质就可以dp了

设 $dp_i$ 表示割断前 $i$ 根弦的最小代价，记有用的弦为 $q$

那么根据之前的分析有

$$
dp[0]=0
$$
$$
dp[i]=\min\{dp[j]+pre[u[q[j+1]]-1]\times suf[v[q[i]]+1] \}
$$

即枚举上一次割断前 $j$ 根弦，这次割断第 $j+1$ 到 $i$根弦

这个东西可以看作是：有 $i$ 根直线，每一根的斜率是 $pre[u[q[j+1]]-1]$ ，$y$ 轴截距是 $dp[j]$ ，$dp[i]$ 是 $x=suf[v[q[i]]+1]$ 时所有直线的最小值

直接上李超树即可

唯一的细节大概就是排序了，按照 $u$ 为第一关键字从小到大，$v$ 为第二关键字从大到小排，从前往后扫到与之前直线不相交就加入 $q$ 。

~~为啥题解里有 $O(n)$ 的但是我这个 $O(n\log n)$ 的反而是最优解啊~~

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef double db;
#define mkp(x,y) make_pair(x,y)
#define fi first
#define se second
#define pb(x) push_back(x)
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=0;ch=getchar();}
	while(isdigit(ch))x=x*10+ch-'0',ch=getchar();
	return f?x:-x;
}
#define N 300005
#define M 1000005
#define inf 1000000000000000000ll
#define T (M<<2)
int n,m,suf[N],pre[N],a[N],b[N],cnt,MX;
LL dp[N];
struct node{
	int u,v;
	inline bool operator < (const node&t)const{return u!=t.u?u<t.u:v>t.v;}
}p[N],q[N];
pair<int,LL>li[N];
int v[T];
#define lc (p<<1)
#define rc (p<<1|1)
#define val(x,y) (1ll*li[x].fi*y+li[x].se)
void update(int id,int l=1,int r=MX,int p=1){
	if(!v[p])return v[p]=id,void();
	LL al=val(id,l),ar=val(id,r),bl=val(v[p],l),br=val(v[p],r);
	if(al>=bl&&ar>=br)return;
	if(al<=bl&&ar<=br)return v[p]=id,void();
	int mid=(l+r)>>1;
	db inter=1.*(li[id].se-li[v[p]].se)/(li[v[p]].fi-li[id].fi);
	if(al<=bl){
		if(inter<=mid)update(id,l,mid,lc);
		else update(v[p],mid+1,r,rc),v[p]=id;
	}else{
		if(inter>mid)update(id,mid+1,r,rc);
		else update(v[p],l,mid,lc),v[p]=id;
	}
}
LL query(int X,int l=1,int r=MX,int p=1){
	LL res=inf;
	if(v[p])res=val(v[p],X);
	if(l==r)return res;
	int mid=(l+r)>>1;
	if(X<=mid)res=min(res,query(X,l,mid,lc));
	else res=min(res,query(X,mid+1,r,rc));
	return res;
}
signed main(){
	n=read(),m=read();
	for(int i=1;i<=n;++i)MX=max(MX,a[i]=read());
	for(int i=1;i<=n;++i)MX=max(MX,b[i]=read());
	for(int i=1;i<=m;++i)p[i].u=read(),p[i].v=read();
	pre[1]=a[1];for(int i=2;i<=n;++i)pre[i]=min(pre[i-1],a[i]);
	suf[n]=b[n];for(int i=n-1;i>=1;--i)suf[i]=min(suf[i+1],b[i]);
	sort(p+1,p+m+1);
	int mm=0;
	for(int i=1;i<=m;++i)if(p[i].u>q[mm].u&&p[i].v>q[mm].v)q[++mm]=p[i];
	m=mm;
	for(int i=0;i<=m;++i){
		if(!i)dp[i]=0;
		else dp[i]=query(suf[q[i].v+1]);
		li[++cnt]=mkp(pre[q[i+1].u-1],dp[i]);
		update(cnt);
		// for(int j=0;j<i;++j)dp[i]=min(dp[i],dp[j]+1ll*pre[q[j+1].u-1]*suf[q[i].v+1]);
	}
	printf("%lld\n",dp[m]);
}
```

---

## 作者：2021hych (赞：1)

首道斜率优化题，感觉很套路。关注到题目本身，如果存在 $u_1$，$v_1$，$u_2$，$v_2$ 使得 $u_1 < u_2$ 且 $v_1 > v_2$，则我们只需要留 $u_1$，$v_1$ 就好了，因为一定可以被顺带破坏掉。

我们可以预处理出来，或者叫筛出来一个等价的二元组集合，然后就一定可以通过排序得到一个两个维度都单调递增的东东。这时，就可以一维线性 dp 了。

状态设计 $dp_i$ 表示将前 $i$ 个二元组（排序后的）都破坏掉的最小代价和，那么状态转移方程如下：
$$dp_i=\min_{j<i}{(dp_j+A_{u_{j+1}-1} \times B_{v_i+1})}$$
其中 $A$ 和 $B$ 表示 $a$ 数组的前缀最小值和 $b$ 数组的后缀最小值。  

接下来是重头戏：斜率优化。  
## 第一步：证明决策单调性
如果对于 $dp_i$ 来说，决策点 $j$ 优于决策点 $k$ 且 $k<j$， 则对于 $dp_{i+1}$ 来说 $j$ 也一定优于 $k$。如果能证明这个，那么该问题是具有决策单调性的。这个的用处在于，可以用单调队列动态维护最优决策点。

具体的，在本题中，如果
$$dp_j+A_{u_{j+1}-1} \times B_{v_i+1} \le dp_k+A_{u_{k+1}-1} \times B_{v_i+1}$$
那么
$$dp_j+A_{u_{j+1}-1} \times B_{v_{i+1}+1} \le dp_k+A_{u_{k+1}-1} \times B_{v_{i+1}+1}$$
发现从第一个式子到第二个式子的左边的增量为：  
$$A_{u_{j+1}-1} \times (B_{v_{i+1}+1}- B_{v_i+1})$$
右边的增量为：
$$A_{u_{k+1}-1} \times (B_{v_{i+1}+1}- B_{v_i+1})$$
注意到由于是针对排序后的，而且对于小区间最小值一定大于等于大区间最小值，故有 $B_{v_{i+1}+1}- B_{v_i+1} \ge 0$，$A_{u_{j+1}-1} \le A_{u_{k+1}-1}$。
那么就有：
$$A_{u_{j+1}-1} \times (B_{v_{i+1}+1}- B_{v_i+1}) \le A_{u_{k+1}-1} \times (B_{v_{i+1}+1}- B_{v_i+1})$$
把这个加上最原始的那个不等式就得到了决策单调性的决定式。
## 第二步：推导斜率式
为啥叫斜率式？我也不知道，有些大佬用的凸包维护的思考方式，这里朴素思考一点。斜率式简单来说就是决策点 $j$ 优于决策点 $k$ 的条件。那么我们只要把原始式子的 $j$ 和 $k$ 移到左边就好了，直接上式子！
$$\dfrac{dp_j-dp_k}{A_{u_{j+1}-1}-A_{u_{k+1}-1}} \ge -B_{v_i+1}$$
那么我们记 $slope(k,j)$ 为左边那个很巨的式子。到此斜率式告一段落。

有人可能要问这有什么用，还是那句话，单调队列呀！你看，根据决策单调性，这个 $k$ 已经莫得用处了呀。
## 第三步：利用单调队列维护决策点
注意到，暴力的瓶颈在于无法将最优决策点高效的找出来，所以我们用单调队列动态维护决策点，使得队首为最优决策点。具体的：

对于队首决策点：如果 $slope(que_{head},que_{head+1}) \ge -B_{v_i+1}$，那么根据决策单调性，此时的队首不可能再成为最优决策点，直接出队。

对于队尾决策点：如果 $slope(que_{tail-1},que_{tail}) \le slope(que_{tail},que_i)$，那么显然如果 $slope(que_{tail-1},que_{tail}) \ge -B_{v_i+1}$ 那么必然有 $slope(que_{tail},que_i) \ge -B_{v_i+1}$。也就是说，此时如果队尾的上一个元素非最优决策点，那么队尾也不是最优决策点。也就是此时的队尾没必要存在了，直接出队。

这样，每个决策点只会进出队列一次，时间复杂度线性，总体时间复杂度就落到排序上了，非常优秀！

来康康代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=3e5+10;
const double inf=0x7f7f7f7f;
int n,m,cnt;
int a[N],b[N],A[N],B[N],dp[N];
int que[N];
int head=1,tail=1;
struct Line {
	int u,v;
}c[N];
bool cmp(Line x,Line y) {
	return x.u<y.u||(x.u==y.u&&x.v>y.v);
}
double slope(int k,int j) {
	if(A[c[j+1].u-1]-A[c[k+1].u-1]==0) return -inf;//注意判断合法呀！
	return (dp[j]-dp[k])*1.0/(A[c[j+1].u-1]-A[c[k+1].u-1]);
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++) cin>>b[i];
	for(int i=1;i<=m;i++) cin>>c[i].u>>c[i].v;
	sort(c+1,c+m+1,cmp);
	int pre=0;
	for(int i=1;i<=m;i++) 
		if(c[i].v>pre) {
			c[++cnt]=c[i];
			pre=c[i].v;
		}
	A[1]=a[1];
	for(int i=2;i<=n;i++) A[i]=min(a[i],A[i-1]);
	B[n]=b[n];
	for(int i=n-1;i>=1;i--) B[i]=min(b[i],B[i+1]);
	for(int i=1;i<=cnt;i++) {
		while(head<tail&&slope(que[head],que[head+1])>=-B[c[i].v+1]) head++;
		dp[i]=dp[que[head]]+A[c[que[head]+1].u-1]*B[c[i].v+1];
		while(head<tail&&slope(que[tail-1],que[tail])<=slope(que[tail],i)) tail--;
		que[++tail]=i;
	}
	cout<<dp[cnt];
	return 0;
}

```


---

## 作者：蓝莲花__ (赞：1)

## 经典的二维化作一维得斜率优化DP。

### 套路性思路：将所有（x，y）排序，用单调栈去掉无用得（x，y），接下来就是套路得斜率优化。

说说这道题得具体细节吧

首先，排序得时候不能像以前一样，先按x从小到大，再按y从小到大，本题得排序方法时按照x从大到小，再按照y从小到大。为什么？我们把题目中所给得（U，V）转化为二维平面，就可以发现，每次选取一条丝去割，就相当于用一个点去覆盖所有他的右下角得区域（不包含端点）。

然后，对于A，B，就是题目中得价值数组分别从前到后和从后到前取min，这是为了满足单调性和最优性，附上理解性代码
```cpp
void pre_work(){
	for(int i=n;i>=1;--i)B[i-1]=min(B[i-1],B[i]);
	for(int i=1;i<=n;++i)A[i+1]=min(A[i+1],A[i]);
}
```
接下来得事情就是推公式，按照斜率优化得套路来了
我给出斜率式子
(p存的是每一个（x，y）)
```cpp
long double slope(int j,int i){
	if(A[p[j+1].x-1]==A[p[i+1].x-1])return oo;
	return 1.0*(f[i]-f[j])/(1.0*(A[p[j+1].x-1]-A[p[i+1].x-1]));
}
```
最后贴上代码（好像时第一个用斜率优化得题解）
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ld long double
#define oo 9e18
const int N=3e5+11;
int n,m,tot,l,r,q[N];
struct node{int x,y;}p[N];
ll f[N],A[N],B[N];
bool cmp(const node a,const node b){return a.x==b.x?a.y<b.y:a.x>b.x;}
bool cmp_f(const node a,const node b){return a.x==b.x?a.y<b.y:a.x<b.x;}
ld slope(int j,int i){
	if(A[p[j+1].x-1]==A[p[i+1].x-1])return oo;
	return 1.0*(f[i]-f[j])/(1.0*(A[p[j+1].x-1]-A[p[i+1].x-1]));
}
void init(){
	cin>>n>>m;
	for(int i=1;i<=n;++i)cin>>A[i];
	for(int i=1;i<=n;++i)cin>>B[i];
	for(int i=1;i<=m;++i)cin>>p[i].x>>p[i].y;
}
void pre_work(){
	for(int i=n;i>=1;--i)B[i-1]=min(B[i-1],B[i]);
	for(int i=1;i<=n;++i)A[i+1]=min(A[i+1],A[i]);
}
void work(){
	sort(p+1,p+m+1,cmp);
	for(int i=1;i<=m;++i){
		while(tot&&(p[tot].y<=p[i].y))--tot;
		p[++tot]=p[i];
	}
	sort(p+1,p+tot+1,cmp_f);
	q[l=r=1]=0;
	for(int i=1;i<=tot;++i){
		while(l<r&&slope(q[l],q[l+1])<=1.0*B[p[i].y+1])l++;
		f[i]=f[q[l]]+A[p[q[l]+1].x-1]*B[p[i].y+1];
		while(l<r&&slope(q[r-1],q[r])>slope(q[r],i))r--;
		q[++r]=i;
	}
	cout<<f[tot];
}
int main(){
	ios::sync_with_stdio(0);
	init();
	pre_work();
	work();
	return 0;
} 
```


---

## 作者：Jadonyzx (赞：0)

斜率优化 dp 好题。

首先观察题目，切割丝线最优化问题。

联系生活实际，发现两根交叉的线可以一次割掉，然后读题发现满足以下情况的线可以视为一根线，蓝色的为切割。

![丝之割1](https://cdn.luogu.com.cn/upload/image_hosting/kaa4ls96.png)

显然有黄色的线割掉时一定割掉边上交叉的线，如图。

![丝之割2](https://cdn.luogu.com.cn/upload/image_hosting/jem89chp.png)

那么我们把这些一定会被别的顺带割掉的线先去掉，具体实现将在后面介绍。

然后一定得到一个这样的互不相交的局面了，如图。

![丝之割3](https://cdn.luogu.com.cn/upload/image_hosting/ub3tt1r1.png)

不妨设 $dp_i$ 表示前 $i$ 个线被割掉的最小开销，有 $dp_i=min_{j=0}^{i-1}{(dp_j+res)}$。其中 $res$ 表示割掉 $j+1$ 到 $i$ 的最小开销。

如何求最小开销？

对于上面，求前缀最小值即可。

对于下面，求后缀最小值即可。

转移可以通过斜率优化实现线性复杂度。

最终问题：如可去掉交叉边？

把丝线按照以下规则排序：

优先按照上面的位置升序排，若上面位置相同，按照下面的降序排，然后从左到右扫一遍，更新最右边的下面的点，若一个点下面的坐标大于等于前者最大下面坐标，则它一定可以舍去，正确性显然。

最后就是实现了。代码如下。


```cpp
#include<bits/stdc++.h>
#define int long long 
#define maxn 300005
using namespace std;
const int inf=1e18;
int n,m,a[maxn],b[maxn],maxczr,top,ak[maxn],bk[maxn],dp[maxn];
struct line{int u,v;}l[maxn],stk[maxn];
int head,tail,q[maxn];
inline int Y(int i){return dp[i];}
inline int X(int i){return -ak[i+1];}
inline long double k(int i,int j){
	int up=Y(i)-Y(j);
	if(X(i)==X(j)){
		return inf;
	}
	return up*1.00/(X(i)-X(j));
}
bool cmp(line a,line b){
	if(a.u!=b.u)return a.u<b.u;
	return a.v>b.v;
}
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;++i)cin>>a[i];
	for(int i=1;i<=n;++i)cin>>b[i];
	for(int i=1;i<=m;++i)cin>>l[i].u>>l[i].v;
	sort(l+1,l+1+m,cmp);
	for(int i=1;i<=m;++i){
		if(maxczr>=l[i].v)continue;
		stk[++top]=l[i];
		maxczr=max(maxczr,l[i].v);
	}
	int minczr=inf,now=1;
	for(int i=1;i<=n&&now<=top;++i){
		if(i==stk[now].u){
			while(i==stk[now].u&&now<=top){
				ak[now]=minczr;
				now++;
			}
		}
		minczr=min(minczr,a[i]);
	}
	minczr=inf;now=top;
	for(int i=n;i>=1&&now>=1;--i){
		if(i==stk[now].v){
			while(i==stk[now].v&&now>0){
				bk[now]=minczr;
				now--;
			}
		}
		minczr=min(minczr,b[i]);
	}
	for(int i=1;i<=n;++i)dp[i]=inf;
	for(int i=1;i<=top;++i){
		while(head<tail&&k(q[head],q[head+1])<=1.00*bk[i])head++;
		int j=q[head];dp[i]=dp[j]+bk[i]*ak[j+1];
		while(head<tail&&k(q[tail],q[tail-1])>=k(i,q[tail]))tail--;
		q[++tail]=i;
	}
	cout<<dp[top];
	return 0;
}
```

---

## 作者：OIer_ACMer (赞：0)

# 题目解析：

题目看起来很抽象，毕竟是要在一个平面内进行删线操作，所以，我们就要化二维为一维，如果我们将下面那条线翻转过来，我们就可以得到条件 $u > i$ 和 $v > j$，若我们将弦看成坐标的话，我们可以发现其实就是**每次选择一个点然后将右下角的点都去掉**，这样就是删除线段了。

所以，根据以上的分析，我们就可以得到两个优化方式，一个是若一条弦代表的点在其它的弦代表的点的右下角，则无法因这些点更新，直接无视不管。如果一个点的代价比他右上角的其中一个点的代价高，那么如果我们选那个点，就能得到更优的答案，因此，我们对 $a$ 数组和 $b$ 数组都取一个前缀最小值。

那么我们设 $dp_i$ 为删除 $i$ 条弦的最小代价，算的方式就是从 $i$ 到 $j$ 一一枚举 $dp_j$ 找出 $dp_j$ 和每个 $a_{x_j + 1} \times b_{y_i}$ 哪个最小，为了方便斜率优化，我们删掉求最小的函数，并将 $a_{x_j + 1} \times b_{y_i}$ 提出来与 $dp_j$ 相加，为了得到一次函数，我们将 $dp_j$ 移动到左边，并将 $dp_i$ 移动到右边那么，我们很容易就知道了 $a_{x_j + 1}$ 为导数 $k$ 至于 $dp_j$ 就是截距 $b$，然后都是单调的，可以用单调队列维护。

# 代码如下：

```

#include <bits/stdc++.h>
using namespace std;
#define int long long
struct node
{
    int x, y;
} dian[10000009];
int n, m, q[10000009];
double a[10000009], b[10000009], dp[10000009];
bool cmp(node x, node y)
{
    return (x.x == y.x) ? (x.y < y.y) : (x.x < y.x);
}
double work(int i, int j)
{
    if (dian[i + 1].x != dian[j + 1].x)
    {
        return (dp[i] - dp[j]) / (dian[j + 1].x - dian[i + 1].x);
    }
    return 0x3f3f3f3f3f3f3f;
}
signed main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
    }
    for (int i = n; i >= 1; i--)
    {
        cin >> b[i];
    }
    a[0] = b[0] = 0x3f3f3f3f3f3f3f;
    for (int i = 1; i <= n; i++)
    {
        a[i] = min(a[i], a[i - 1]);
        b[i] = min(b[i], b[i - 1]);
    }
    for (int i = 1; i <= m; i++)
    {
        cin >> dian[i].x >> dian[i].y;
    }
    for (int i = 1; i <= m; i++)
    {   
        dian[i].y = n + 1 - dian[i].y;
    }
    sort(dian + 1, dian + 1 + m, cmp);
    int p = 0;
    dian[0].y = 2147483647 / 3;
    for (int i = 1; i <= m; i++)
    {
        if (dian[i].y < dian[p].y)
        {
            dian[++p] = dian[i];
        }
    }
    m = p;
    int l = 1, r = 1;
    for (int i = 1; i <= m; i++)
    {
        dian[i].x = a[dian[i].x - 1], dian[i].y = b[dian[i].y - 1];
    }
    for (int i = 1; i <= m; i++)
    {
        while (l < r && work(q[l], q[l + 1]) <= dian[i].y)
        {
            l++;
        }
        int pos = q[l];
        dp[i] = dp[pos] + dian[pos + 1].x * dian[i].y;
        while (l < r && work(q[r - 1], q[r]) > work(q[r], i))
        {
            r--;
        }
        q[++r] = i;
    }
    cout << fixed << setprecision(0) << dp[m];
    return 0;
}

```

---

## 作者：Purslane (赞：0)

# Solution

分享一个不太一样的做法。斜率优化 DP，差不多是 $\rm NOIp$ 第二题难度？

不妨把所有的线都放在一个二维平面上，那么每次你相当于花 $a_{x-1}b_{y+1}$ 的代价在平面中放置区域 $\{(a,b) \mid a \ge x \text{ and } b \le y\}$（这实际上是一个矩形）。

根据最基本的贪心，我们知道最后的覆盖一定是这种形状的：

![](https://s21.ax1x.com/2024/04/12/pFjM7y8.md.png)

所以发现本质上可以化归为子问题：$dp_t$ 表示清除了所有 $x \ge t$ 的点所用的最小代价。

先对 $\{a\}$ 求前缀 $\min$，对 $\{b\}$ 求后缀 $\min$。这时候发现，如果要从 $dp_j$ 转移到 $dp_i$（$i < j$），应当为：

- 设 $k$ 为横坐标在 $\{x \mid i \le x <j , x \in \mathbb Z\}$ 的点中最大的纵坐标。
- 代价为 $a_{i-1} \times b_{k+1}$，即 $dp_i \leftarrow \min\{dp_i,dp_j+a_{i-1} \times b_{k+1}\}$。

考虑优化该转移。根据组合意义，$dp_{*}$ 关于 $*$ 应当是单调不增的。那么当 $k$ 相同的时候，我们应当选取最大的 $j$。所以实际上只有严格单调栈里面的元素可能成为元素。

但是你发现这样完全不能维护。为什么？因为随着单调栈的转移，$j$ 对应的 $k$ 会改变——这样会导致凸包的形态发生各种变化。那么我们换一种方式：还是认定单调栈中的元素，但是把右端点放到第一个比他大的元素上，建立“可持久化凸包”（准确来说是一个树形结构）。

复杂度 $O(n \log n)$。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=3e5+10;
int n,m,a[MAXN],b[MAXN],h[MAXN],dp[MAXN],rt[MAXN],nxt[MAXN][20];
struct Node {int x,y;}t[MAXN];
void insert(int id,int fm,int x,int y) {
	t[id]={x,y},rt[id]=id;
	if(t[id].x==t[fm].x) return rt[id]=fm,void();
	int nid=fm;
	if(fm==n+1||((double)(t[id].y-t[nid].y)/(t[id].x-t[nid].x)<(double)(t[nid].y-t[nxt[nid][0]].y)/(t[nid].x-t[nxt[nid][0]].x))) nxt[id][0]=fm;
	else {
		roff(i,19,0) {
			int nid=nxt[fm][i];
			if(nid!=0&&nid!=n+1&&(double)(t[id].y-t[nid].y)/(t[id].x-t[nid].x)>(double)(t[nid].y-t[nxt[nid][0]].y)/(t[nid].x-t[nxt[nid][0]].x)) fm=nid;
		}
		nxt[id][0]=nxt[fm][0];
	}
	ffor(i,1,19) nxt[id][i]=nxt[nxt[id][i-1]][i-1];
	return ;
}
int calc_min(int id,int k) {
	if((double)(t[id].y-t[nxt[id][0]].y)/(t[id].x-t[nxt[id][0]].x)<-k) {
		roff(i,19,0) {
			int nid=nxt[id][i];
			if(nid!=0&&nid!=n+1&&(double)(t[nid].y-t[nxt[nid][0]].y)/(t[nid].x-t[nxt[nid][0]].x)<-k) id=nid;
		}
		id=nxt[id][0];
	}
	return t[id].y+k*t[id].x;
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m; ffor(i,1,n) cin>>a[i]; ffor(i,1,n) cin>>b[i];
	ffor(i,2,n) a[i]=min(a[i],a[i-1]); roff(i,n-1,1) b[i]=min(b[i],b[i+1]);
	ffor(i,1,m) {int x,y; cin>>x>>y,h[x]=max(h[x],y);}
	b[n+1]=0x3f3f3f3f,h[n+1]=348649614; stack<int> st; st.push(n+1),rt[n+1]=n+1,t[n+1]={b[n+1],0};
	roff(i,n,2) {
		while(h[st.top()]<=h[i]) st.pop();
		insert(i,rt[st.top()],b[h[i]+1],dp[st.top()]);
		st.push(i);
		dp[i]=calc_min(rt[i],a[i-1]);
		if(h[i]==0) dp[i]=dp[i+1];
	}
	cout<<dp[2];
	return 0;
}
```

---

## 作者：Cl41Mi5deeD (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P6047)

这是一道斜优 dp，令 $dp[i]$ 表示切到第 $i$ 根弦时的最小代价。

给出的弦是没有什么顺序的，挖掘性质并做预处理。
- 所有的弦都要被切掉，不妨对弦按左端点排序。
- 如果在 $(l,r)$ 上的一次切割切断了弦 $(u_0,v_0)$，那么所有满足 $u_0<u<v<v_0$ 的弦 $(u,v)$ 都会被顺带切断。我们只需 dp 不会被顺带切断的弦。
- $a_i$ 可以作为所有 $a_j>a_i,j>i$ 的更优选择，同理，$b_i$ 可以作为所有 $b_j>b_i,j<i$ 的更优选择。

```cpp
bool cmp(node a,node b){
	if(a.u==b.u)return a.v<b.v;
	return a.u<b.u;
}
...
signed main(){
	scanf("%lld%lld",&n,&m);
	a[0]=b[n+1]=inf;
	for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
	for(int i=1;i<=n;i++)scanf("%lld",&b[i]);
	for(int i=1;i<=n;i++)a[i]=min(a[i],a[i-1]);
	for(int i=n;i>=0;i--)b[i]=min(b[i],b[i+1]);//更新切割(u,v)时的最优代价a[u],b[v]
	for(int i=1;i<=m;i++)scanf("%lld%lld",&s[i].u,&s[i].v);
	sort(s+1,s+1+m,cmp);
	int tmp=0;
	for(int i=1;i<=m;i++){
		int loc=i+1;
		while(s[i].v>=s[loc].v)++loc;
		p[++tmp]=s[i];
		i=loc-1;
	}//排好序后左端点递增，右端点不递增的都算作被顺带切掉的弦。
	m=tmp;
```

令本次转移切割到第 $i$ 条弦，上次切割到第 $j$ 条弦，故本次切割 $j+1\sim i$ 的弦，写出转移方程：

$$
dp[i]=min_{j=0}^{i-1}(dp[j]+a[p[j+1].u-1]*b[p[i].v+1])
$$

考虑斜率优化。转化为 $Y=K*X+B$ 形式。

$$
dp[j]=-b[p[i].v+1]*a[p[j+1].u-1]+dp[i]
$$
$$
Y=dp[j]
$$
$$
K=b[p[i].v+1]
$$
$$
X=-a[p[j+1].u-1]
$$
$$
B=dp[i]
$$

直接套板子即可。

负号的安排是有讲究的。出于对 $a_i,b_i$ 的预处理，序列 $a$ 递减，序列 $b$ 递增，$X=-a[p[j+1].u-1]$ 可以同时让 $K,X$ 递增，无需二分，复杂度 $O(n)$。

```cpp
#include<bits/stdc++.h>
#define int long long
#define MAXN 300005
using namespace std;
const int inf=1e18;
int n,m;
int a[MAXN],b[MAXN];
struct node{
	int u,v;
}s[MAXN],p[MAXN];
bool cmp(node a,node b){
	if(a.u==b.u)return a.v<b.v;
	return a.u<b.u;
}
int dp[MAXN];
int q[MAXN],h,t;
int Y(int x){
	return dp[x];
}
int X(int x){
	return -a[p[x+1].u-1];
}
int K(int x){
	return b[p[x].v+1];
}
double slope(int x_1,int x_2){
	return 1.0*(Y(x_1)-Y(x_2))/(X(x_1)-X(x_2));
}
signed main(){
	scanf("%lld%lld",&n,&m);
	a[0]=b[n+1]=inf;
	for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
	for(int i=1;i<=n;i++)scanf("%lld",&b[i]);
	for(int i=1;i<=n;i++)a[i]=min(a[i],a[i-1]);
	for(int i=n;i>=0;i--)b[i]=min(b[i],b[i+1]);
	for(int i=1;i<=m;i++)scanf("%lld%lld",&s[i].u,&s[i].v);
	sort(s+1,s+1+m,cmp);
	int tmp=0;
	for(int i=1;i<=m;i++){
		int loc=i+1;
		while(s[i].v>=s[loc].v)++loc;
		p[++tmp]=s[i];
		i=loc-1;
	}
	m=tmp;
	for(int i=1;i<=m;i++){
		//dp[i]=min(dp[i],dp[j]+a[p[j+1].u-1]*b[p[i].v+1]);
		// Y   =    K            X          + B
		//dp[j]=b[p[i].v+1]*(-a[p[j+1].u-1])+dp[i]
		while(t>h&&K(i)>=slope(q[h+1],q[h]))++h;
		dp[i]=dp[q[h]]+a[p[q[h]+1].u-1]*b[p[i].v+1];
		while(t>h&&slope(i,q[t-1])<=slope(q[t],q[t-1]))--t;
		q[++t]=i;
	}
	printf("%lld",dp[m]);
	return 0;
}
```


---

## 作者：User_Unauthorized (赞：0)

可以发现，若数对 $\left(u_0, v_0\right)$ 被除去，那么所有满足 $u \ge u_0$ 且 $v \le v_0$ 的数对均会被除去。

因此若将所有数对按 $u$ 升序排列，那么剩余的有用的数对一定满足 $v$ 严格递增。

这样之后每次消除数对一定是消除一个区间的数对，可以使用动态规划。

设 $f_i$ 表示前 $i$ 个数对的最小花费，那么有转移：

$$f_i = \min\limits_{j < i}\left\{f_j + \min\limits_{k < u_{j + 1}} a_k \times \min\limits_{k > v_{i}} b_k\right\}$$

其中 $u_i, v_i$ 表示第 $i$ 个数对的两个数，维护出 $a$ 的前缀最小值和 $b$ 的后缀最小值即可。

这样转移式就可以化为斜率优化的形式，使用斜率优化即可。

---

## 作者：Nephren_Sakura (赞：0)

题目传送门：[link](https://www.luogu.com.cn/problem/P6047)。

一道有点难度的斜率优化 dp。

首先，我们可以发现，如果两条弦 $i,j$ 满足 $u_i \le u_j$ 且 $v_i \ge v_j$，则 $j$ 是不需要考虑的，为什么呢？

假设我们切了一次 $k,l$ 切断了 $i$ 弦，由题意：$k \le u_i$，$l \ge v_i$。

又因为 $u_i \le u_j$，$v_i \ge v_j$。

所以 $k \le u_j$，$l \ge v_j$，则可以同时切断 $j$ 弦。

那么我们就可以先把所有不需要的弦先删掉。

将所有弦先按 $u$ 排序，再按 $v$ 从大到小排序，然后判断当前点的 $v$ 值是不是目前最大的，如果不是则删除当前点。

设 $dp_i$ 表示切掉前 $i$ 根弦的最小价值。

枚举转移点 $j$，则方程为 $dp_i=\min_{j=0}^{i-1}(dp_j+\min_{k=1}^{u_{j+1}-1}a_k \times \min_{k=v_i+1}^{n}b_k)$。

将 $a_k$ 的前缀最小值和 $b_k$ 的后缀最小值预处理出来，即可将时间复杂度降为 $O(n^2)$。

但这样做只有 79 分，仍然不足以通过本题，考虑继续优化。

我们发现这个式子很像斜率优化的形式，然后推一下式子即可。

具体的方法可以看我的 [DP 优化](https://www.luogu.com.cn/blog/Nephren-Ruq-Insania/dp-you-hua)。

然后这题就做完了。

代码（本人码风奇特，不建议学习）：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m,a[1000005],b[1000005],cnt,qzmin[1000005],edmin[1000005],dp[1000005];
deque<int> dq;
struct node{
	int u,v;
}c[1000005],d[1000005];
bool cmp(node x,node y){
	if(x.u!=y.u)
		return x.u<y.u;
	return x.v>y.v;
}
int top(int i,int j){
	return dp[i]-dp[j];
}
int down(int i,int j){
	return qzmin[d[j+1].u-1]-qzmin[d[i+1].u-1];
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	memset(qzmin,0x3f,sizeof qzmin);
	memset(edmin,0x3f,sizeof edmin);
	cin>>n>>m;
	for(int i=1; i<=n; i++)
		cin>>a[i],qzmin[i]=min(qzmin[i-1],a[i]);
	for(int i=1; i<=n; i++)
		cin>>b[i];
	for(int i=n; i>=1; i--)
		edmin[i]=min(edmin[i+1],b[i]);
	for(int i=1; i<=m; i++)
		cin>>c[i].u>>c[i].v;
	int minv=-1e18;
	sort(c+1,c+m+1,cmp);
	for(int i=1; i<=m; i++)
		if(c[i].v>minv)
			minv=c[i].v,d[++cnt]=c[i];
	memset(dp,0x3f,sizeof dp);
	dp[0]=0;
	dq.push_back(0);
	for(int i=1; i<=cnt; i++){
		while(dq.size()>=2){
			int x=dq.front();
			dq.pop_front();
			int y=dq.front();
			if(top(y,x)>edmin[d[i].v+1]*down(y,x)){
				dq.push_front(x);
				break;
			}
		}
		int j=dq.front();
		dp[i]=min(dp[i],dp[j]+qzmin[d[j+1].u-1]*edmin[d[i].v+1]);
		while(dq.size()>=2){
			int x=dq.back();
			dq.pop_back();
			int y=dq.back();
			if(top(i,x)*down(x,y)>top(x,y)*down(i,x)){
				dq.push_back(x);
				break;
			}
		}
		dq.push_back(i);
	}
	cout<<dp[cnt];
	return 0;
}
```

upd：被 Bot 打回了，说我少了空格，但我找了半天也没找到哪里少了空格。

---


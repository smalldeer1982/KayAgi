# [蓝桥杯 2015 国 B] 居民集会

## 题目描述

蓝桥村的居民都生活在一条公路的边上，公路的长度为 $L$，每户家庭的位置都用这户家庭到公路的起点的距离来计算，第 $i$ 户家庭距起点的距离为 $d_i$。

每年，蓝桥村都要举行一次集会。今年，由于村里的人口太多，村委会决定要在 $4$ 个地方举行集会，其中 $3$ 个位于公路中间，$1$ 个位最公路的终点。

已知每户家庭都会向着远离公路起点的方向去参加集会，参加集会的路程开销为家庭内的人数 $t_i$ 与距离的乘积。

给定每户家庭的位置 $d_i$ 和人数 $t_i$，请为村委会寻找最好的集会举办地：$p_1,p_2,p_3,p_4(p_1 \le p_2 \le p_3 \le p_4=L),$ 使得村内所有人的路程开销和最小。

## 说明/提示

【样例说明】

在距起点 $2,5,8,10$ 这 $4$ 个地方集会，$6$ 个家庭需要的走的距离分别为 $1,0,1,0,2,0$，总的路程开销为 $1 \times 3+0 \times 2+1 \times 5+0 \times 20+2 \times 5+0 \times 7=18$。

【数据规模与约定】

对于 $10\%$ 的评测数据，$1 \le n \le 300$。

对于 $30\%$ 的评测数据，$1 \le n \le 2000$，$1 \le L \le 10000$，$0 \le d_i \le L$，$d_i \le d_i+1$，$0 \le t_i \le 20$。

对于 $100\%$ 的评测数据，$1 \le n \le 10^5$，$1 \le L \le 10^6$，$0 \le d_i \le L$，$d_i \le d_i+1$，$0 \le t_i \le 10^6$。

## 样例 #1

### 输入

```
6 10
1 3
2 2
4 5
5 20
6 5
8 7```

### 输出

```
18```

# 题解

## 作者：kbzcz (赞：5)

### 思路

这题和仓库选址差不多，只是多了一个修建仓库数量的限制，所以我们要多设一维。设 $f_{i,j}$ 表示在 $i$ 处建一个集会，一共建了 $j$ 个集会的最小开销。则转移方程为：

$$f_{i,j}=\min\limits_{k<i}{f_{k,j-1}+d_i \times \displaystyle\sum_{p=k+1}^i{t_p}-\displaystyle\sum_{p=k+1}^i}{d_p\times t_p}$$

其中两个求和可以通过前缀和算出来。

接下来化简。设 $T_i=\displaystyle\sum_{j=1}^i{t_j},D_i=\displaystyle\sum_{j=1}^i{t_j\times d_j}$，则式子变成：

$$ f_{i,j}=\min\limits_{k<i}{f_{k,j-1}+d_i \times (T_i-T_k)-(D_i-D_k)}$$

把 $\min$ 去掉，并化简成斜率优化的样子。     

$$ \begin{aligned}f_{i,j}=f_{k,j-1}+d_i\times T_i-d_i\times T_k-D_i+D_k \\  f_{i,j}-d_i\times T_i+D_i+d_i\times T_k=f_{k,j-1}+D_k\end{aligned}$$

则

$$ \begin{aligned}y&=f_{k,j-1}+D_k\\k&=d_i\\x&=T_k\\b&=f_{i,j}-d_i\times T_i+D_i\end{aligned}$$

因为在 $L$ 位置必须建一个集会，所以我们新建一个点，把 $L$ 当成一个人数为 $0$ 的点，$f_{n+1,4}$ 即为所求。

题目要求最小值，所以截距要最小，维护下凸即可。

---
### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef double DB;
const int N=1e5+5;
int n,L;
LL d[N],t[N];
LL sd[N],st[N],f[N][5];
int q[N],l,r;
DB X(int j) {return 1.0*st[j];}
DB Y(int j,int k) {return 1.0*(f[j][k]+sd[j]);}
DB slop(int i,int j,int k) {
	if(X(i)==X(j)) return 1e18;
	return (Y(j,k)-Y(i,k))/(X(j)-X(i));
}
int main() {
	scanf("%d%d",&n,&L);
	for(int i=1;i<=n;i++) {
		scanf("%lld%lld",&d[i],&t[i]);
		st[i]=st[i-1]+t[i];
		sd[i]=sd[i-1]+t[i]*d[i];
	} 
	d[n+1]=L;t[n+1]=0;
	st[n+1]=st[n]+t[n+1];sd[n+1]=sd[n]+t[n+1]*d[n+1];
	memset(f,0x3f,sizeof(f));
	f[0][0]=0;
	for(int j=1;j<=4;j++) {
		l=r=1;q[l]=0;
		for(int i=1;i<=n+1;i++) {
			while(l<r&&slop(q[l],q[l+1],j-1)<=d[i]) l++;
			int k=q[l];
			f[i][j]=f[k][j-1]+d[i]*(st[i]-st[k])-(sd[i]-sd[k]);
			while(l<r&&slop(q[r-1],q[r],j-1)>=slop(q[r],i,j-1)) r--;
			q[++r]=i;
		}
	}
	printf("%lld",f[n+1][4]);
	return 0;
}
```


---

## 作者：cff_0102 (赞：4)

首先把道路的终点也看做一个家庭，这个家庭的人数是 $0$，到达公路起点的距离就是 $L$。

设 $dp_{i,j}$ 为在第 $i$ 户家庭修建第 $j$ 个集会地点，前 $i$ 户的开销之和的最小值，最终答案就是 $dp_{n+1,4}$。可以在开始的时候直接选择将 $n$ 加上 $1$，最后输出 $dp_{n,4}$。

状态转移方程：$dp_{i,j}=\min\limits_{k=0}^{i-1}(dp_{k,j-1}+\sum\limits_{p=k+1}^{i}(t_p\times(d_i-d_p)))$，在这之前要先将 $dp$ 初始化为无穷大。

显然如果直接这样做会直接 T 飞，所以考虑优化。

一个显而易见的优化是使用前缀和，设 $st_i=\sum\limits_{p=1}^{i}t_p$，$std_i=\sum\limits_{p=1}^{i}(t_p\times d_p)$，那么原状态转移方程就能写为：$dp_{i,j}=\min\limits_{k=0}^{i-1}(dp_{k,j-1}+d_i\times(st_i-st_k)-(std_i-std_k))$，拆括号并整理得到 $dp_{i,j}=\min\limits_{k=0}^{i-1}(dp_{k,j-1}+std_k-d_i\times st_k+d_i\times st_i-std_i)$。

为什么要这么整理呢？因为不难发现在本题的情况下，决策单调性是显然的，将转移式改成 $y=kx+b$ 的形式，就可以用斜率优化 dp。

去除 $\min$ 并将转移式改写成 $dp_{k,j-1} + std_k = d_i\times st_k + std_i - d_i\times st_i + dp_{i,j}$，并令：
$$y=dp_{k,j-1} + std_k$$
$$k=d_i$$
$$x=st_k$$
$$b=std_i - d_i\times st_i + dp_{i,j}$$

要让 $dp_{i,j}$ 最小，则要 $b$ 最小，单调队列维护下凸壳即可。

具体在 dp 的时候要先推一遍 $j=1$ 的情况。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+5;
/*
dp[i][j] 在第 i 户家庭修建第 j 个集会地点，前 i 户的开销最小值
dp[i][j] = min[k=0,i-1](dp[k][j-1]+sum[p=k+1,i](t[p]*(d[i]-d[p])))
dp[i][j] = min[k=0,i-1](dp[k][j-1]+sum[p=k+1,i](t[p]*d[i])-sum[p=k+1,i](t[p]*d[p]))
dp[i][j] = min[k=0,i-1](dp[k][j-1] + sum[p=k+1,i]t[p]*d[i] - sum[p=k+1,i](t[p]*d[p]))
设 st[i] = sum[p=1,i](t[p]), std[i] = sum[p=1,i]t[p]*d[p]
dp[i][j] = min[k=0,i-1](dp[k][j-1] + (st[i]-st[k])*d[i] - (std[i]-std[k]))
dp[i][j] = min[k=0,i-1](dp[k][j-1] + st[i]*d[i] - st[k]*d[i] - std[i] + std[k]) 注：st[i]*d[i] 不等于 std[i]
dp[k][j-1] + st[i]*d[i] - st[k]*d[i] - std[i] + std[k] - dp[i][j] = 0
dp[k][j-1] = - st[i]*d[i] + st[k]*d[i] + std[i] - std[k] + dp[i][j]
dp[k][j-1] + std[k] = d[i]*st[k] + std[i] - st[i]*d[i] + dp[i][j]
y                   = k    x     + b
求最小维护下凸壳 
*/
int n,L,d[N],t[N],dp[N][5],st[N],st_d[N],q[N];
double K(int p1,int p2,int j){
	double xp1=st[p1];
	double xp2=st[p2];
	double yp1=dp[p1][j-1]+st_d[p1];
	double yp2=dp[p2][j-1]+st_d[p2];
	return (yp2-yp1)/((xp2-xp1==0)?1e-9:xp2-xp1);
}
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);
	cin>>n>>L;
	for(int i=1;i<=n;i++)cin>>d[i]>>t[i];
	d[++n]=L;t[n]=0;
	for(int i=1;i<=n;i++)st[i]=st[i-1]+t[i],st_d[i]=st_d[i-1]+t[i]*d[i];
	//初始化 j=1 的情况
	for(int j=1;j<=1;j++){
		for(int i=1;i<=n;i++){
			dp[i][j]=dp[i-1][j]+(d[i]-d[i-1])*st[i-1];//将前面所有 st[i-1] 个人全部迁移 (d[i]-d[i-1]) 的长度 
		}
	} 
	for(int j=2;j<=4;j++){
		for(int i=0;i<=n;i++)q[i]=0;
		for(int i=0;i<=n;i++)dp[i][j]=(1ll<<60);
		int h=1,aqua=0;
		for(int i=1;i<=n;i++){
			while(h<aqua&&K(q[aqua-1],q[aqua],j)>=K(q[aqua-1],i-1,j))aqua--;
			q[++aqua]=i-1;
			while(h<aqua&&K(q[h],q[h+1],j)<=d[i])h++;
			int k=q[h];
			dp[i][j]=dp[k][j-1]+st[i]*d[i]-st[k]*d[i]-st_d[i]+st_d[k];
		}
	}
	cout<<dp[n][4];
	return 0;
}
```

---

## 作者：toolong114514 (赞：3)

# P8632 [蓝桥杯 2015 国 B] 居民集会 题解
## 题面大意
[传送门。](https://www.luogu.com.cn/problem/P8632)
## 解题思路
非常典的斜率优化。

居民们肯定是去离他们最近，且可以到达的集会点，否则一定不优。

根据题面的 $d_i$ 和 $t_i$ 推导出到起点距离为 $i$ 处的人数 $s_i$。

记 $f_{i,t}(0\le i\le l,0\le t\le 4)$ 为在离起点距离为 $i$ 处建第 $t$ 个集合点的最小花费。特别地，我们认为 $f_{0,0},f_{1,0},\cdots,f_{n,0}=0$。

可得以下的状态转移方程：

$$f_{i,t}=\min\{f_{j,t-1}+(i-j-1)\cdot s_{j+1}+(i-j-2)\cdot s_{j+2}+\cdots+(i-i)\cdot s_i\}(j\le i)$$
按上述状态转移方程搞一个暴力转移，时间复杂度为 $O(l^3)$（完全暴力处理）或 $O(l^2)$（继承答案优化），可以分别获得 10pts 或 30pts。

考虑对上式进行斜率优化。

变换式子，得：

$$f_{i,t}=\min\{f_{i,t-1}+i\cdot(s_{j+1}+s_{j+2}+\cdots)-((j+1)\cdot s_{j+1}+(j+2)\cdot s_{j+2}+\cdots+i\cdot s_i)\}$$

记 $sum1_i=s_0+s_1+\cdots+s_i,sum2_i=0\cdot s_0+1\cdot s_1+\cdots+i\cdot s_i$，可将继续变换为前缀和的形式：

$$f_{i,t}=\min\{f_{j,t-1}+i\cdot(sum1_i-sum1_j)-(sum2_i-sum2_j)\}$$

去掉括号，写成斜优的标准形式如下：

$$f_{i,t}=\min\{-sum1_j\cdot i+sum2_j+f_{j,t-1}\}+i\cdot sum1_i-sum2_i$$

令 $k=-sum1_j$，$x=i$，$b=sum2_j+f_{j,t-1}$，原问题就变为：求若干条形如 $y=kx+b$ 的直线，求横坐标为 $x$ 时纵坐标最小的那条。

使用李超线段树（~~LCT~~）维护即可。

最后的答案即为 $f_{l,4}$。

编写代码时，可以让 $f_{i,t}$ 从任意的 $f_{j,t-1}$ 转移，无需满足 $j\le i$ 的条件，因为变换集会点的顺序不会影响最终答案。

## 参考代码
```cpp
#include<algorithm>
#include<iostream>
using namespace std;
#define s sum1
#define int long long
const int N=1e6+10;
const int INF=0x7fffffff;
struct node{
	int l,r,bst;
}tree[4*N];
struct ccf{
	int k,b;
}ln[N];
void build(int pos,int lft,int rgt){
	tree[pos].l=lft;
	tree[pos].r=rgt;
	if(lft==rgt) return;
	int mid=(lft+rgt)/2;
	build(pos*2,lft,mid);
	build(pos*2+1,mid+1,rgt);
}
void upd(int pos,int num){
	int mid=(tree[pos].l+tree[pos].r)/2;
	if((ln[tree[pos].bst].k==ln[num].k)&&(ln[tree[pos].bst].b==ln[num].b)) return;
	if(ln[tree[pos].bst].k*mid+ln[tree[pos].bst].b>ln[num].k*mid+ln[num].b) swap(tree[pos].bst,num);
	if(tree[pos].l==tree[pos].r) return;
	if(ln[num].k*tree[pos].l+ln[num].b<ln[tree[pos].bst].k*tree[pos].l+ln[tree[pos].bst].b) upd(pos*2,num);
	if(ln[num].k*tree[pos].r+ln[num].b<ln[tree[pos].bst].k*tree[pos].r+ln[tree[pos].bst].b) upd(pos*2+1,num);
}
int ask(int pos,int kk){
	if(kk<tree[pos].l||tree[pos].r<kk) return INF;
	if(tree[pos].l==tree[pos].r) return ln[tree[pos].bst].k*kk+ln[tree[pos].bst].b;
	return min(min(ask(pos*2,kk),ask(pos*2+1,kk)),ln[tree[pos].bst].k*kk+ln[tree[pos].bst].b);
}
int n,l,cnt;
int sum1[N],sum2[N],f[N];
signed main(){
	ios::sync_with_stdio(false);
	cin>>n>>l;
	while(n--){
		int dd,tt;
		cin>>dd>>tt;
		s[dd]+=tt; 
	}
	for(int i=1;i<=l;i++){
		sum2[i]=sum2[i-1]+s[i]*i;
		s[i]+=s[i-1];
	}
	ln[0].b=INF;
	build(1,0,l);
	ln[++cnt]={0,0};
	upd(1,cnt);
	for(int i=1;i<=3;i++){
		for(int j=0;j<=l;j++){
			f[j]=ask(1,j)+sum1[j]*j-sum2[j];
		}
		build(1,0,l);
		cnt=0;
		for(int j=0;j<=l;j++){
			ln[++cnt]={-sum1[j],sum2[j]+f[j]};
			upd(1,cnt);
		}
	}
	cout<<ask(1,l)+sum1[l]*l-sum2[l];
	return 0;
}
```
[此代码可以通过洛谷评测。](https://www.luogu.com.cn/record/161929176)

Written by [toolong114514](https://www.luogu.com.cn/user/477821) on 2024/6/12.

---

## 作者：wjl1100 (赞：3)

## [原题传送门](https://www.luogu.com.cn/problem/P8632)

## 思路

我们首先用 $dp_{i,j}$ 表示在第 $i$ 个位置一共建立了 $j$ 个集会点的最小代价，推出暴力公式为 $dp_{i,j}=\min\limits_{k=1}^{i-1}(dp_{k,j-1}+\sum\limits_{p=k+1}^{i}(t_p\times(d_i-d_p)))$，化简为 $dp_{i,j}=\min\limits_{k=1}^{i-1}(dp_{k,j-1}+d_i\times\sum\limits_{p=k+1}^{i}t_p-\sum\limits_{p=k+1}^{i}(t_p\times d_p))$，这时我们利用前缀和分别维护 $\sum\limits_{p=k+1}^{i}t_p$ 和 $\sum\limits_{p=k+1}^{i}(t_p\times d_p)$ 的值，利用前缀和进行优化，这样我们就可以写出暴力代码。

```cpp
#include<bits/stdc++.h>
#define int long long
#define inf 0x7f7f7f7f
#define mod 1000000007
using namespace std;
const int maxn = 1e6 + 100;
inline int read() {
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
int dp[maxn][5] , n , l , ll = 1 , rr = 0 , q[maxn] , sumt[maxn] , d[maxn] , t , sumdt[maxn] , f[maxn];
signed main(){
	n = read();
	l = read();
	for(int i = 1; i <= n; i++) {
		d[i] = read();
		t = read();
		sumt[i] = sumt[i - 1] + t;
		sumdt[i] = sumdt[i - 1] + d[i] * t;
	}
	n++;
	d[n] = l;
	sumt[n] = sumt[n - 1];
	sumdt[n] = sumdt[n - 1];
	memset(dp , 0x3f , sizeof(dp));
	dp[1][1] = 0;
	dp[0][0] = 0;
	for(int i = 1; i <= 4; i++) {
		for(int j = 1; j <= n; j++) {
			for(int k = 0; k < j; k++) {
				dp[j][i] = min(dp[j][i] , dp[k][i - 1] + d[j] * (sumt[j] - sumt[k]) - (sumdt[j] - sumdt[k]));
			}
		}
	}
	cout << dp[n][4] << endl;
	return !("wjl1100 qwq");
} 
```

这样我们就可以得到 50 分。

（以下的 $dp$ 省掉了第二维）然后我们可以发现这个转移方程可以用斜率优化，我们假设从 $k$ 转移比从 $p$ 转移更优且 $j > p$，那么我们令 $g_i=dp_i+sumdt_i$，则 $\dfrac{g_j-g_p}{sumt_j-sumt_p}<d_i$ 时可以转移，这时我们发现这个形式非常像斜率公式，所以我们用 $g_i$ 为纵坐标，$sumt_i$ 作横坐标做斜率优化，枚举转移点，找到满足要求且编号最大的点进行转移，又因这里为小于，所以用单调队列维护下凸壳即可。

```cpp
#include<bits/stdc++.h>
#define int long long
#define inf 0x7f7f7f7f
#define mod 1000000007
using namespace std;
const int maxn = 1e6 + 100;
inline int read() {
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
int dp[maxn][5] , n , l , ll = 1 , rr = 0 , q[maxn] , sumt[maxn] , d[maxn] , t , sumdt[maxn];
inline int getg(int i , int k) {
	return dp[i][k] + sumdt[i];
}
inline long double getxl(int i , int j , int k) {
	if(sumt[i] == sumt[j]) return inf;
	return (long double) (getg(j , k) - getg(i , k)) / (sumt[j] - sumt[i]);
}
signed main(){
	n = read();
	l = read();
	for(int i = 1; i <= n; i++) {
		d[i] = read();
		t = read();
		sumt[i] = sumt[i - 1] + t;
		sumdt[i] = sumdt[i - 1] + d[i] * t;
	}
	n++;
	d[n] = l;
	sumt[n] = sumt[n - 1];
	sumdt[n] = sumdt[n - 1];
	memset(dp , 0x7f , sizeof(dp));
	dp[0][0] = 0;
	for(int time = 1; time <= 4; time++) {
		ll = 1;
		rr = 0;
		q[++rr] = 0;
		for(int i = 1; i <= n; i++) {
			while(rr > ll && getxl(q[ll] , q[ll + 1] , time - 1) <= d[i]) ll++;
			int u = q[ll];
			dp[i][time] = dp[u][time - 1] + d[i] * (sumt[i] - sumt[u]) - (sumdt[i] - sumdt[u]);
			while(rr > ll && getxl(q[rr - 1] , q[rr] , time - 1) >= getxl(q[rr] , i , time - 1)) rr--;
			q[++rr] = i;
		}
	}
	cout << dp[n][4] << endl;
	return !("wjl1100 qwq");
} 
```

三倍经验：

[居民集会](https://www.luogu.com.cn/problem/P8632)

[仓库建设](https://www.luogu.com.cn/problem/P2120)

[锯木厂选址](https://www.luogu.com.cn/problem/P4360)

---

## 作者：FitHar406 (赞：2)

## 思路
因为公路上的家庭只会向远离公路的方向前进，所以定义状态 $f_{i,0/1/2/3}$ 表示在第 $i$ 户家庭设置集合点，且第 $1$ 至 $i$ 户家庭一共设立了 $0/1/2/3$ 个集合点所需的最小费用。

先考虑暴力转移。令 $d_i$ 表示第 $i$ 户家庭到第一户家庭的距离，$t_i$ 表示该户家庭的人数，则有状态转移方程如下：

$$
f_{i,k}=\min_{0\leq{j}<{i}}{\lbrace{f_{j,k-1}+\sum^{i-1}_{l=j+1}{(d_i-d_l)\times{t_l}}}\rbrace}
$$

运用乘法分配律，把求和展开得到：

$$
\sum^{i-1}_{l=j+1}{d_i\times{t_l}-d_l\times{t_l}}
$$

把 $d_i$ 提出来：

$$
d_i\times{\sum^{i-1}_{l=j+1}{t_l}}-{\sum^{i-1}_{l=j+1}{d_l\times{t_l}}}
$$

可以用前缀和来表示这个式子。

令 $st_i=\sum^{i}_{j=1}{t_j}$，$sd_i=\sum^{i}_{j=1}{d_j\times{t_j}}$，则原方程式可表示为：

$$
f_{i,k}=\min_{0\leq{j}<{i}}{\lbrace{f_{j,k-1}+(st_{i-1}-st_j)\times{d_i}-(sd_{i-1}-sd_j)}\rbrace}
$$

展开再提炼，就有：

$$
f_{i,k}=\min_{0\leq{j}<{i}}{\lbrace{f_{j,k-1}-st_j\times{d_i}+sd_j}\rbrace}+st_{i-1}\times{d_i}-sd_{i-1}
$$

可以使用滚动数组把 $k$ 这一维省掉：

$$
f_{i}=\min_{0\leq{j}<{i}}{\lbrace{f_{j}-st_j\times{d_i}+sd_j}\rbrace}+st_{i-1}\times{d_i}-sd_{i-1}
$$

这就已经是一个很标准的斜率优化式子了，令：

$$
y=f_i+st_{i-1}\times{d_i}-sd_{i-1}
$$

$$
k=-st_j
$$

$$
x=d_i
$$

$$
b=f_j+sd_j
$$

再令最终的答案为 $ans$，终点到第一户家庭的距离为 $L$，则：

$$
ans=\min_{1\leq{i}\leq{n}}{\lbrace{f_i+(st_n-st_i)\times{L}-(sd_n-sd_i)}\rbrace}
$$

用李超线段树维护即可，时间复杂度 $O(n\log{n})$。

## 代码
~~~cpp
#include<iostream>
#include<cstring>
#define int long long
using namespace std;
const int N=2e5+10;
int dis[N],st[N],f[N],sd[N],dp[N];
//f[i][k]=min(f[i][k],f[j][k-1]+(st[i-1]-st[j])*dis[i]-(sd[i-1]-sd[j]));
//f[i]=f[j]+st[i-1]*dis[i]-st[j]*dis[i]-sd[i-1]+sd[j]
//f[i]-st[i-1]*dis[i]+sd[i-1]=-st[j]*dis[i]+f[j]+sd[j];
inline int read(){
	int sig=0,x=0,ch=getchar();
	while(!isdigit(ch))sig|=ch=='-',ch=getchar();
	while(isdigit(ch))x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return sig?-x:x;
}
void write(int x){
	if(x<0)x=-x,putchar('-');
	if(x>9)write(x/10);
	putchar(x%10+48);
}
inline int X(int i){return dis[i];}
inline int K(int j){return -st[j];}
inline int B(int j){return f[j]+sd[j];}
struct SEG{
	int k,b;
	int ls,rs;
	SEG(){ls=rs=0;k=1e16,b=0;}
	SEG(int K,int B){
		k=K,b=B;
	}
}t[N<<1];int tot;
inline int New(){
	t[++tot].k=0;
	t[tot].b=1e16;
	t[tot].ls=t[tot].rs=0;
	return tot;
}
inline int calc(SEG a,int x){
	return a.k*x+a.b;
}
inline bool cover(SEG b,SEG a,int x){
	return calc(a,x)>=calc(b,x);
}
void Insert(int p,int l,int r,SEG num){
	num.ls=t[p].ls,num.rs=t[p].rs;
	if(cover(num,t[p],l)&&cover(num,t[p],r)){t[p]=num;return ;}
	int mid=(l+r)>>1;
	if(cover(num,t[p],mid))swap(num,t[p]);
	if(cover(num,t[p],l)){
		if(!t[p].ls)t[p].ls=New();
		Insert(t[p].ls,l,mid,num);	
	}
	if(cover(num,t[p],r)){
		if(!t[p].rs)t[p].rs=New();
		Insert(t[p].rs,mid+1,r,num);
	}
}
inline int query(int p,int l,int r,int x){
	int ans=1e16;
	int mid=(l+r)>>1;
	if(x<mid&&t[p].ls)ans=query(t[p].ls,l,mid,x);
	if(x>mid&&t[p].rs)ans=query(t[p].rs,mid+1,r,x);
	ans=min(ans,calc(t[p],x));
	return ans;
}
signed main(){
	memset(dp,0x3f,sizeof(dp));
	int n,l;n=read(),l=read();
    int start=0,ans=1e16;
	for(int i=1;i<=n;i++){
		dis[i]=read(),st[i]=read();
        if(i==1)start=dis[i];
        dis[i]-=start;
		sd[i]=sd[i-1]+dis[i]*st[i];
		st[i]+=st[i-1];
	}
    dis[n+1]=l-start;
	New();
	Insert(1,0,l,SEG(K(0),B(0)));
	for(int k=1;k<=3;k++){
		for(int i=1;i<=n;i++)f[i]=dp[i];
		for(int i=1;i<=n;i++){
			dp[i]=query(1,0,l,X(i))+st[i-1]*dis[i]-sd[i-1];
			Insert(1,0,l,SEG(K(i),B(i)));
		}
	}
	for(int i=1;i<=n;i++){
		ans=min(ans,dp[i]+(st[n]-st[i])*dis[n+1]-(sd[n]-sd[i]));
	}
	write(ans);
} 
~~~

---

## 作者：2018ljw (赞：2)

长得就很斜率优化的说。

首先显然有集结部队在某个村子处一定优于设在道路中间。设 $dp_{i,j}$ 表示在村庄 $i$ 处设立第 $j$ 个集结点，前 $i$ 个村子最小总代价。

但这样设会有一点问题，因为最后一个集结点要求在道路尽头，所以我们额外加入一个 $d=L$ 的村庄即可。

易得转移式 $dp_{i,j}=\min\limits_{k<i}\{dp_{k,j-1}+calc(k+1,i)\}$，而 $calc(k+1,i)=\sum\limits_{j=k+1}^it_j\times(d_i-d_j)$。

分别作出 $t$ 的前缀和 $st$ 和 $t\times d$ 的前缀和 $sd$，可得 $calc(k+1,i)=d_i\times(st_i-st_k)-(sd_i-sd_k)$。

即 $dp_{i,j}=\min\limits_{k<i}\{dp_{k,j-1}+sd_k-d_i\times st_k\}+d_i\times st_i-sd_i$。

非常标准的斜率优化形式，横坐标与斜率都是单调的，可以直接 $O(n)$ 解决。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
const long long inf=1e18;
using namespace std;
int n,m;
long long d[100002],t[100002];
long long sd[100002],st[100002];
long long dp[100002],tmp[100002];
int q[100002],head,tail;
long long px(int x){return st[x];}
long long py(int x){return tmp[x]+sd[x];}
double slope(int x,int y){
	if(px(x)==px(y))return inf;
	return (py(x)-py(y))/(double)(px(x)-px(y));
}
int main(){
	int i,j;
	scanf("%d%d",&n,&m);
	d[0]=-1;
	for(i=1;i<=n;i++){
		int x,y;
		scanf("%d%d",&x,&y);
		if(x==d[i-1]){
			n--;i--;
			t[i]+=y;
			continue;
		}
		if(!y){
			n--;i--;
			continue;
		}
		d[i]=x;t[i]=y;
	}
	if(d[n]!=m)d[++n]=m,t[n]=1;
	d[0]=0;
	if(n<=4)return printf("0"),0;
	for(i=1;i<=n;i++){
		st[i]=st[i-1]+t[i];
		sd[i]=sd[i-1]+t[i]*d[i];
	}
	for(i=1;i<=n;i++)dp[i]=inf;
	for(j=1;j<=4;j++){
		memcpy(tmp,dp,sizeof(dp));
		memset(dp,0x3f,sizeof(dp));
		head=tail=0;q[1]=0;
		for(i=1;i<=n;i++){
			while(head<tail&&slope(q[head],q[head+1])<=d[i])head++;
			int p=q[head];
			dp[i]=tmp[p]+sd[p]-d[i]*st[p]+d[i]*st[i]-sd[i];
			while(head<tail&&slope(q[tail-1],q[tail])>=slope(q[tail],i))tail--;
			q[++tail]=i;
		}
	}
	printf("%lld",dp[n]);
}
```

---

## 作者：CQ_Bab (赞：1)

# 前言
给出一种不用动脑子的解法。
# 思路
首先我们可以发现这是一个 dp 题，那么考虑定义 $f_{i,j}$ 表示现在到 $i$ 选了 $j$ 举办地且 $i$ 为第 $j$ 个的 $1\sim i$ 的最小值，考虑转移 $f_{i,j}=\min(f_{k-1,j-1}+\sum_{x=k}^{i} (d_i-d_x)\times t_x)$ 这里的中间的求和明显可以用前缀和优化，我们定义 $ts_i=\sum_{x=1}^{i} t_x,s_i=\sum_{x=1}^{i} t_x\times d_x$，然后柿子又变成了 $f_{k-1,j-1}+(ts_i-ts_{k-1})\times d_i-s_i+s_{k-1}$ 然后就会 $n^2$ 做法了。

考虑优化，我们再把柿子变一下 $f_{k-1,j-1}+ts_{k-1}\times d_i+s_{k-1}-s_i+ts_i\times d_i$ 由于 $-s_i+ts_i\times d_i$ 为定值所以无需处理，考虑如何求 $f_{k-1,j-1}+ts_{k-1}\times d_i+s_{k-1}$ 的最值，直接李超线段树即可，[不会的话学一下吧](https://www.luogu.com.cn/problem/P4097)，然后就没了。
# 代码
由于一些未知原因这个题爆 `long long` 了，所以要开 `__int128`。
```cpp
#include <bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
#include <ext/rope>
using namespace __gnu_pbds;
using namespace std;
#define pb push_back
#define rep(i,x,y) for(register int i=x;i<=y;i++)
#define rep1(i,x,y) for(register int i=x;i>=y;--i)
#define int __int128
#define fire signed
#define il inline
template<class T> il void print(T x) {
	if(x<0) printf("-"),x=-x;
	if (x > 9) print(x / 10);
	putchar(x % 10 + '0');
}
template<class T> il void in(T &x) {
    x = 0; char ch = getchar();
    int f = 1;
    while (ch < '0' || ch > '9') {if(ch=='-') f = -1; ch = getchar(); }
    while (ch >= '0' && ch <= '9') { x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar(); }
    x *= f;
}
int T=1;
int n,L;
const int N=1e5+10;
const int M=1e6;
int d[N],t[N],s[N],ts[N],f[N][5];
struct line{
	int k,b;
	int id;
};
struct node{
	int l,r;
	line mx;
}tr[N<<2];
int idx;
int calc(line a,int x) {
	return a.k*x+a.b;
}
void modify(int &u,int l,int r,line now) {
	if(!u) u=++idx;
	if(!tr[u].mx.id) {
		tr[u].mx=now;
		return;
	}
	int l1=calc(tr[u].mx,l),r1=calc(tr[u].mx,r);
	int l2=calc(now,l),r2=calc(now,r);
	if(l1<=l2&&r1<=r2) return;
	else {
		if(l1>=l2&&r1>=r2) {
			tr[u].mx=now;
		}else {
			int mid=l+r>>1;
			if(calc(tr[u].mx,mid)>calc(now,mid)) swap(tr[u].mx,now);
			l1=calc(tr[u].mx,l),r1=calc(tr[u].mx,r);
			l2=calc(now,l),r2=calc(now,r);
			if(l1>l2) modify(tr[u].l,l,mid,now);
			if(r1>r2) modify(tr[u].r,mid+1,r,now);
		}
	}
}
int Ans(int u,int l,int r,int k) {
	if(!tr[u].mx.id) return 1e18;
	int res=calc(tr[u].mx,k);
	if(l==r) return res;
	int mid=l+r>>1;
	if(mid>=k) res=min(res,Ans(tr[u].l,l,mid,k));
	else res=min(res,Ans(tr[u].r,mid+1,r,k));
	return res;
}
void solve() {
	in(n),in(L);
	rep(i,1,n) in(d[i]),in(t[i]),s[i]=s[i-1]+t[i]*d[i],ts[i]=ts[i-1]+t[i];
	memset(f,0x3f,sizeof f);
	f[0][0]=0;
	int rt=0;
	rep(j,1,3) {
		rep(i,1,idx) tr[i]={0,0,{0,0,0}};
		idx=false;
		rt=0;
		line c1={0,0,1};
		modify(rt,0,M,c1);
		rep(i,1,n) {
			f[i][j]=Ans(rt,0,M,d[i])-s[i]+ts[i]*d[i];
			line c={-ts[i],f[i][j-1]+s[i],1};
			modify(rt,0,M,c);
		}
	}
	int res=1e18;
	rep(i,1,n) {
		res=min(res,f[i][min(i,(int)3)]-s[n]+s[i]+L*(ts[n]-ts[i]));
	}
	print(res);
}
fire main() {
	while(T--) {
		solve();
	}
	return false;
}
```

---

## 作者：Rindong (赞：1)

# 题意

给定 $n$ 个家庭，其中每个家庭距离起点有 $d_i$ 的距离，每个家庭有 $t_i$ 个人。

题目需要我们在长度为 $L$ 的数轴上放置四个点 $p_1,p_2,p_3,p_4(p_1 \le p_2 \le p_3 \le p_4)$ 并且最后一个点必须落在 $L$ 上，然后这 $n$ 个家庭会往右一直走直到碰到任意一个点，设第 $i$ 个家庭到达一个点的距离是 $len_i$ 那么这个家庭的开销是 $len_i \times t_i$。

问如何安排这些点使得所有家庭的开销总和最小？

# 思路

首先贪心地想，这些点肯定是落在某个家庭的位置代价最小。

然后来考虑动态规划，设 $dp[i][j]$ 为以第 $i$ 个家庭结尾，并且放置了 $j$ 个点的最小开销，那么转移方程就是从前面的数中找到一个 $k$ 作为 $j - 1$ 的结尾，设 $Cost_{[l, r]}$ 为以 $l$ 为起点，以 $r$ 为终点的花费，有状态转移方程 $dp[i][j] = dp[k][j - 1] + Cost_{[k + 1, r]}$ 我们的目标就是使这个值最小。

那么问题来了，如何计算一个区间的开销呢？

设 $pres_i$ 为只放置一个点在 $i$ 并且以 $i$ 结尾时所有家庭的开销。假设我已经知道 $pres_{i - 1}$ 了，那么我如何计算出 $pres_i$ 呢？经过观察，对于 $pres_{i - 1}$ 来说，每多走一个单位距离，就会使得前面所有的家庭又多走了一个单位距离也就是增加了一倍的家庭人数前缀和。所以设 $T_i=\sum_{j=1}^{i}t_j$ ，得：
$$
pres_i = pres_{i - 1} + T_{i - 1} \times (d_i - d_{i - 1})
$$

得到所有的 $pres_i$ 后，获取一个区间的开销就变轻松了： 

$$Cost_{[l, r]} = pres_{[l, r]} = pres_r - pres_{l - 1} - (d_r - d_{l - 1}) \times T_{l - 1}$$

也就是把 $l$ 之前的贡献减掉就好了。

回到我们的状态转移方程，有：

$$dp[i][j] = \min_{k = 0}^{i - 1}(dp[k][j - 1] + pres_i - pres_k - (d_i - d_k) \times T_k)$$

这样的复杂度是 $n^2$ 显然是会T的，不要着急，我们思考一下~~点开标签~~，考虑动态规划优化。整理转移方程的式子得（过程读者可自行推导）：

$$dp[k][j - 1] - pres_k + T_k \times d_k = T_k \times d_i - pres_i + dp[i][j]$$

是不是有点眼熟？有点像形如 $y = kx + b$ 的式子？我们令：

$$y = dp[k][j - 1] - pres_k + T_k \times d_k$$

$$x = T_k$$

$$k = d_i$$

$$b = dp[i][j] - pres_i$$

那么对于这个式子来说，只要使得 $b$ 最小，那么 $dp[i][j]$ 就最小，画一个二维坐标系发现横坐标单调递增，所以可以使用优先队列维护我们的答案。

# 注意的点

运算过程中会爆 LL 所以使用 int128 防溢出。

# 代码

```cpp
#include <iostream>
using namespace std;
#define MAX_N 100005
#define ll long long
#define ull unsigned ll
ll dp[5][MAX_N] = { 0 };
ll dis[MAX_N] = { 0 };
__int128 T[MAX_N] = { 0 };
__int128 pres[MAX_N] = { 0 };
int head = 1, tail = 1;
int q[MAX_N + 10] = { 0 };
__int128 get_y(int i, int j) { // j - 1
	return dp[j - 1][i] - pres[i] + T[i] * dis[i];
}
long double slope(int a, int b, int j) {
	ll x1 = T[a], x2 = T[b];
	ll y1 = get_y(a, j), y2 = get_y(b, j);
	if (x1 == x2) return 999999999999999;
	return (y2 - y1) * 1.0f / (x2 - x1);
}
int main() {
	int n, L;
	scanf("%d%d", &n, &L);
	for (int x = 1; x <= n; x++) {
		ll ti;
		scanf("%lld%lld", dis + x, &ti);
		T[x] = ti + T[x - 1];
		pres[x] = pres[x - 1] + T[x - 1] * (dis[x] - dis[x - 1]);
		//cout << pres[x] << endl;
	}
	n++;
	dis[n] = L;
	T[n] = T[n - 1];
	pres[n] = pres[n - 1] + T[n - 1] * (dis[n] - dis[n - 1]);
	for (int i = 1; i <= n; i++) dp[1][i] = pres[i];
	for (int j = 2; j <= 4; j++) {
		head = tail = 1;
		q[tail++] = 0;
		for (int i = 1; i <= n; i++) {
			ll xielv = dis[i];
			while (tail - head >= 2 && slope(q[head], q[head + 1], j) < 
			xielv)
				head++;
			//printf("[%d, %d] head = %d\n", i, j, q[head]);
			int k = q[head];
			dp[j][i] = dp[j - 1][k] + pres[i] - pres[k] - (dis[i] - dis[k]) * T[k];
			//printf("%llu   %llu   %llu\n", dis[i], dis[k], T[k]);
			while (tail - head >= 2 && slope(q[tail - 1], q[tail - 2], j) >=
				slope(q[tail - 1], i, j))
				tail--;
			q[tail++] = i;
			//printf("[%d, %d] = %lld\n", i, j, dp[j][i]);
		}
	}
	ll ans = 0x7f7f7f7f7f7f7f7f;
	for (int x = 1; x <= 4; x++) ans = min(ans, dp[x][n]);
	printf("%lld", ans);
	return 0;
}
```

---

## 作者：未来姚班zyl (赞：1)

## 题目大意

在一条长为 $L$ 的公路上有 $n$ 个家庭，现在要标记其中的三个家庭与终点。对于每个家庭，其花费为人数乘终点方向第一个被标记的点与其的距离。最小化总花费。

## 题目分析

设 $f_{i,j}$ 表示前 $i$ 个家庭，标记了 $j$ 个家庭且 $i$ 被标记的最小花费，则答案为 $f_{n+1,4}$。容易列出转移式：

$f_{i,j}=\min\limits_{0\le k\le i-1}(f_{k,j-1}+\sum\limits_{k+1\le j\le i-1}t_k(d_i-d_k))$

记 $t$ 的前缀和数组为 $w$，即 $w_i=\sum\limits_{1\le j\le i}t_j$，$t_i\times d_i$ 的前缀和数组为 $wd$，即 $wd_i=\sum\limits_{1\le j\le i}t_jd_j$。

则转移式可以化为：

$f_{i,j}=\min\limits_{0\le k\le i-1}(-d_iw_k+f_{k,j-1}+wd_k+d_iw_{i-1}-wd_{i-1})$

显然，与 $k$ 有关的值是一个一次函数，李超线段树维护即可，复杂度 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define int ll
#define L x<<1
#define R x<<1|1
#define mid (l+r>>1LL)
#define lc L,l,mid
#define rc R,mid+1,r
#define Root 1,1,n
#define OK l>=Ll&&r<=Rr
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define per(x,y,z) for(int x=(y);x>=(z);x--)
#define pb push_back
#define ull unsigned ll
#define e(x) for(int i=h[x],y=to[i];i;i=nxt[i],y=to[i])
#define E(x) for(auto y:p[x])
#define Pi pair<ll,int>
#define ui unsigned ll
inline int read(){int s=0,w=1;char c=getchar();while(c<48||c>57) {if(c=='-') w=-1;c=getchar();}while(c>=48&&c<=57) s=(s<<1)+(s<<3)+c-48,c=getchar();return s*w;}
inline void pf(ll x){if(x<0) putchar('-'),x=-x;if(x>9)pf(x/10);putchar(x%10+48);}
const int N =1e5+5,M=1e6+5,inf=(1LL<<31)-1;
const ll llf=inf,mod=998244353,bas=131;
const ui base=13331;
using namespace std;
int n=read()+1,d[N],w[N],wd[N],tot;
struct segment{
	ll k,b;
}s[N<<2];
inline ll get(int x,int id){
	if(!id)return llf;
	return s[id].k*x+s[id].b;
}
int xd[N<<2][5];
inline void pushdown(int x,int l,int r,int id,int k){
	if(!xd[x][k])xd[x][k]=id;
	if(get(d[mid],id)<get(d[mid],xd[x][k]))swap(xd[x][k],id);
	if(get(d[l],id)<get(d[l],xd[x][k]))pushdown(lc,id,k);
	if(get(d[r],id)<get(d[r],xd[x][k]))pushdown(rc,id,k);
}
inline int query(int x,int l,int r,int p,int k){
	int nk=get(d[p],xd[x][k]);
	if(l==r||!xd[x][k])return nk;
	if(p<=mid)return min(nk,query(lc,p,k));
	return min(nk,query(rc,p,k));
}
signed main(){
	d[n]=read();
    rep(i,1,n-1)d[i]=read(),w[i]=read()+w[i-1],wd[i]=wd[i-1]+d[i]*(w[i]-w[i-1]);
	s[++tot]={0,0};pushdown(Root,tot,0);
	rep(i,1,n)per(j,4,1){
		int nw=query(Root,i,j-1)+d[i]*w[i-1]-wd[i-1];
		if(i==n){
			pf(nw);return 0;
		}
		s[++tot]={-w[i],nw+wd[i]};
		pushdown(Root,tot,j);
	}
	return 0;
}
```

---

## 作者：hlsnqdmz (赞：1)

## 前言
这道题其实跟**锯木厂选址**很像（题目链接[锯木厂选址](https://www.luogu.com.cn/problem/P4360)）没做可以先去做一下。

## 通用想法：
和其他斜率 dp 的经典例题一样，这道题也有较为固定的思路：
1. 首先还是设定 dp 状态，由于有三个选址（第四个已经固定）所以可以给 dp 状态增加一维：设 $dp[i][j]$ 为选第 $i$ 户家庭为第 $j$ 个集会举办地时前 $j$ 个家庭的总开销和。
2. 接下来思考如何转移状态，可以发现 $dp[i][j]$ 的状态可以从 $dp[1][j-1]$ 到  $dp[i][j-1]$ 的状态进行转移，（**注意这里四个举办地可以在同一个地方！**）所以可以写出转移方程：

$$
dp[i][j]=\min_{1 \le k \le i} dp[k][j-1]+\sum_{f=j+1}^i(d[i]-d[f])*p[f]
$$ 

3. 然后我们可以用前缀和优化为：

$$
dp[i][j]=\min_{1 \le k \le i} dp[k][j-1]+d[i]*\sum_{f=j+1}^i p[f]-\sum_{f=j+1}^i d[f]*p[f]
$$ 

4. 注意这里我们可以看到我们把 $d[i]$ 放在了其自身所在的式子的前面，因为它并不会变化，是个常量，我们可以在输入数据时就把它求出来。

5. 接下来可以通过前缀和将两个求和公式转化，（~~至少我看着并不舒服~~）我们设：

$$ 
P[i]=\sum_{j=1}^i p[j]
$$ 
$$ 
C[i]=\sum_{j=1}^i d[j]*p[j]
$$ 

6. 把 $\min$ 去掉后将式子转化为一个让人舒适的样子：

$$ 
dp[i][j]=dp[k][j-1]+d[i]*(P[i]-P[k])-C[i]+C[k]=S[k][j-1]
$$ 

7. 最后我们使出代数法，设 $k_2>k_1$ 且  $S[k_2][j-1] \le S[k_1][j-1]$，那么：

$$ 
dp[k_2][j-1]+d[i]*(P[i]-P[k_2])-C[i]+C[k_2] \le dp[k_1][j-1]+d[i]*(P[i]-P[k_1])-C[i]+C[k_1]
$$ 

8. 去掉公共项后，我们再将还有与 $i$ 有关的式子移到符号一边，剩下的移到另一边：

$$
dp[k_2][j-1]+C[k_2]-dp[k_1][j-1]-C[k_1] \le d[i](P[k_2]-P[k_1])
$$ 

9. 再将 $(P[k_2]-P[k_1])$ 除到左边，我们就可以发现我们 $k_1 k_2$ 的斜率式：

$$
\frac{dp[k_2][j-1]+C[k_2]-dp[k_1][j-1]-C[k_1]}{P[k_2]-P[k_1]}\le d[i]
$$ 

10. 所以当 $k_2$ 与 $k_1$ 的该式的值小于等于 $d[i]$ 时，我们可以说 $k_2$ 比 $k_1$ 更优。（前提是 $k_2>k_1$）

## 题干分析
好像很久才是分析题干，但在草稿纸上上述步骤很快就可以求出。接下来我们可以意识到：
- 我们发现需要求三个集会地，且斜率式与 x 满足单调性，可以用单调队列维护。

- 由于三个集会地位置也单调不减，我们可以先求出来每个家庭作为第一个集会地的开销和。

- 我们发现这是维护下凸包，所以队列是单调递增的

我的思路可能有些独特，（~~奇葩~~）只求到第三个集会点的开销和，这时统计从该点到公路终点这段以公路终点为集会地的开销和。（但这样就会发现第二遍和第三遍步骤有区别，再加上本来写循环就只求这两遍，所以直接分开来写了）

直接看代码吧（码风丑，骂轻点）

```
//Just Sayori
#include <bits/stdc++.h>
using namespace std;
#define ll long long
inline ll read()//快读。
{
    ll x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9') {
        if (ch == '-') f = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = (x << 3) + (x << 1) + ch - 48;
        ch = getchar();
    }
    return x * f;
}
ll n, L, t;
ll dp[100005][4], d[100005], p[100005], c[100005];//十年OI一场空，___________。
int q[50005];//手写单调队列。
inline ll y(int n)
{
    return dp[n][t - 1] + c[n];//记住是 t-1。
}
inline ll x(int n)
{
    return p[n];
}
inline long double get_num(int a, int b)//保障精度用 double。
{
    return (long double)(y(b) - y(a)) / (x(b) - x(a));
}
int main()
{
    n = read(), L = read();
    ll ans = 0x3f3f3f3f3f3f3f3f;//记得初始化
    for (int i = 1; i <= n; i++)
    {
        d[i] = read(), p[i] = read();
        dp[i][1] = dp[i - 1][1] + p[i - 1] * (d[i] - d[i - 1]);//求前缀和。
        c[i] = c[i - 1] + d[i] * p[i];
        p[i] += p[i - 1];//这个时候再加，不然上几行会出事。
    }
    int l = 1, r = 1;//清空队列。
    q[1] = 0;//重点。
    t = 2;
    for (int i = 1; i <= n; i++)
    {
        while (l < r && get_num(q[r - 1], q[r]) >= get_num(q[r - 1], i)) r--;//重点：由于可以都选同一个点所以先加入队列再求值。
        q[++r] = i;
        while (l < r && get_num(q[l], q[l + 1]) <= d[i]) l++;//先去尾后删头，不然会 WA 三个点。
        int j = q[l];
        dp[i][t] = dp[j][t - 1] + d[i] * (p[i] - p[j]) - c[i] + c[j];
    }
    l = 1, r = 1;
    q[1] = 0;
    t = 3;
    for (int i = 1; i <= n; i++)
    {
        while (l < r && get_num(q[r - 1], q[r]) >= get_num(q[r - 1], i)) r--;
        q[++r] = i;
        while (l < r && get_num(q[l], q[l + 1]) <= d[i]) l++;
        int j = q[l];
        dp[i][t] = dp[j][t - 1] + d[i] * (p[i] - p[j]) + c[j] + L * (p[n] - p[i]) - c[n];//这里要包括公路末尾的值。
        ans = min(ans, dp[i][t]);//求最小值。
    }
    cout << ans;//朴实无华的输出。
    return 0;
}

```
**感谢您的观看！**

---

## 作者：5k_sync_closer (赞：1)

其实我也没写什么正经做法……不过能过题

对集会位置退火，考虑对任意集会位置 $a,b,c$ 怎么 $O(1)$ 计算答案。

以 $[1,a]$ 的家庭为例，其贡献为 $\sum\limits_{i=1}^at_i(d_a-d_i)=d_a\sum\limits_{i=1}^a t_i-\sum\limits_{i=1}^ad_it_i$。

分别预处理 $\sum\limits_{i=1}^a t_i$ 和 $\sum\limits_{i=1}^ad_it_i$ 即可。$(a,b],(b,c],(c,n+1]$ 的家庭同理。注意 $d_{n+1}=L$。

初始解贪心地选择人数最多的三个位置。

设当前温度为 $T$，则对每个集会位置 $x\gets (x+pT+n)\bmod n+1$ 生成新解，其中 $p$ 为 $[-1,1]$ 的随机实数。

调一个合适的参数，然后微调初温，发现初温为 $n+1$ 和 $n+2$ 时可以得到两个不同的 90 分。

所以分别跑 600 遍取 $\min$ 即可。

```cpp
#include <cmath>
#include <ctime>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
int n, L, x, y, z, X, Y, Z, d[100050], t[100050];
long long q, Q, s[100050], p[100050];
bool u;
inline long long F(int a, int b, int c)
{
    int x = a, y = b, z = c;
    if (x > y)
        swap(x, y);
    if (x > z)
        swap(x, z);
    if (y > z)
        swap(y, z);
    return d[x] * s[x] - p[x] + d[y] * (s[y] - s[x]) - p[y] + p[x] + d[z] * (s[z] - s[y]) - p[z] + p[y] + L * (s[n] - s[z]) - p[n] + p[z];
}
inline void SA()
{
    double T = n + u + 1;
    while (T > 1e-7)
    {
        int a = int(x + (rand() * 2.0 / RAND_MAX - 1) * T + n) % n + 1,
            b = int(y + (rand() * 2.0 / RAND_MAX - 1) * T + n) % n + 1,
            c = int(z + (rand() * 2.0 / RAND_MAX - 1) * T + n) % n + 1;
        long long f = F(a, b, c);
        double d = f - q;
        if (d < 0 || exp(-d / T) * RAND_MAX > rand())
            q = f, x = a, y = b, z = c;
        Q = min(Q, q);
        T *= 0.9965;
    }
}
int main()
{
    srand(388651);
    scanf("%d%d", &n, &L);
    for (int i = 1; i <= n; ++i)
    {
        scanf("%d%d", d + i, t + i);
        s[i] = s[i - 1] + t[i];
        p[i] = p[i - 1] + 1ll * d[i] * t[i];
        if (t[i] > t[x])
            z = y, y = x, x = i;
        else if (t[i] > t[y])
            z = y, y = i;
        else if (t[i] > t[z])
            z = i;
    }
    q = Q = F(X = x, Y = y, Z = z);
    for (int i = 0; i < 600; ++i)
        SA();
    u = 1;
    q = F(x = X, y = Y, z = Z);
    srand(388651);
    for (int i = 0; i < 600; ++i)
        SA();
    printf("%lld", Q);
    return 0;
}
```


---

## 作者：YZren (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P8632)

# 思路

- 可以发现此题与[仓库建设](https://www.luogu.com.cn/problem/P2120)很像，没做过的可以去做一下。

- 回到这道，令 $sumnum_i=\sum\limits_{k=0}^i d_k$ 和 $sum_i=sum_{i-1}+sumnum_{i-1}$ 其中 $sumnum_i$ 表示到 $i$ 这个位置共有多少人，然后 $sum_i$ 表示 $i$ 以前的人到 $i$ 的总距离。可以得出一个 Dp 方程 $dp_{i,t}=\min\limits_{k=0}^i(dp_{k,t-1}+sum_i-sum_k-sumnum_k\times (i-k))$。可以发现直接枚举肯定要超时，但是整理一下方程可得 $dp_{i,t}=sum_i+\min\limits_{k=0}^i(-sumnum_k\times i+sumnum_k\times k-sum_k+dp_{k,t-1})$ 可以发现很像一个一次函数，所以使用斜率优化。

- 使用李超线段树维护最小值即可。

# Code


```cpp
#include<bits/stdc++.h>
#define int long long
#define endl "\n"
#define f(i,j,k) for(int i=j;i<=k;i++)
#define F(i,j,k) for(int i=j;i>=k;i--)
using namespace std;
const int maxn=1e6+10,inf=LLONG_MAX;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
inline void write(int x){
	if(x<0) {x=~(x-1); putchar('-');}
	if(x>9) write(x/10);
	putchar(x%10+'0');
}
int n=read(),L=read(),root=1,dp[maxn][5],sum[maxn],sum_num[maxn],dis[maxn/10],tree[maxn<<2];
struct line{int k,b;} a[maxn];
inline int getY(int id,int X){return a[id].k*X+a[id].b;}
inline void update(int rt,int l,int r,int id){
	if(l==r){
		if(getY(id,l)<getY(tree[rt],l)) tree[rt]=id;
		return ;
	}
	int mid=(l+r)>>1;
	if(getY(id,mid)<getY(tree[rt],mid)) swap(tree[rt],id);
	if(getY(id,l)<getY(tree[rt],l)) update(rt<<1,l,mid,id);
	else if(getY(id,r)<getY(tree[rt],r)) update(rt<<1|1,mid+1,r,id);
}
inline int query(int rt,int l,int r,int X){
	if(!rt) return inf;
	if(l==r) return getY(tree[rt],X);
	int mid=(l+r)>>1;
	if(X<=mid) return min(getY(tree[rt],X),query(rt<<1,l,mid,X));
	else return min(getY(tree[rt],X),query(rt<<1|1,mid+1,r,X));
}
inline void work(){
	update(root,0,L,L+1); f(i,1,n) dis[i]=read(),sum_num[dis[i]]+=read();
	f(i,1,L) sum_num[i]+=sum_num[i-1],sum[i]=sum[i-1]+sum_num[i-1];
	f(j,1,4){
		f(i,1,L) dp[i][j]=query(root,0,L,i)+sum[i];
		memset(tree,0,sizeof(tree)); root=1; update(root,0,L,L+1); 
		f(i,1,L) a[i]=(line){-sum_num[i],sum_num[i]*i-sum[i]+dp[i][j]},	update(root,0,L,i);
	} write(dp[L][4]);
}
signed main(){work();return !!!!!("YZren");}
```

---

## 作者：Jadonyzx (赞：0)

设 $dp_{i,j}$ 表示设了 $j$ 个集会点，考虑到第 $i$ 个位置的最小总移动。

设 $pre_i$ 表示前 $i$ 个格子居民移动距离前缀和。

设 $cnt_i$ 表示前 $i$ 个格子居民数量的前缀和。

有转移方程：

$dp_{i,j}=\min_{x\lt i}dp_{x,k-1}+pre_i-pre_x-cnt_x\times (d_i-d_x)$。

斜率优化即可。

code：


```cpp
#include <bits/stdc++.h>
#define int long long
#define double long double
#define maxn 1000005
using namespace std;
int n,L,d[maxn],t[maxn],pre[maxn],cnt[maxn];
int head,tail,q[maxn],dp[maxn][5];
inline double Y(int i,int k){return dp[i][k]-pre[i]+d[i]*cnt[i];}
inline double X(int i){return cnt[i];}
inline double K(int i,int j,int k){return (Y(i,k)-Y(j,k))/(X(i)-X(j)==0?1e-9:X(i)-X(j));}
signed main(){
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    cin>>n>>L;
    for(int i=1;i<=n;++i)
        cin>>d[i]>>t[i];
    d[++n]=L;t[n]=0;
    cnt[0]=t[0];pre[0]=0;
    for(int i=1;i<=n;++i){
        cnt[i]=cnt[i-1]+t[i];
        pre[i]=pre[i-1]+cnt[i-1]*(d[i]-d[i-1]);
    }
    for(int i=1;i<=n;++i)
        dp[i][1]=dp[i-1][1]+cnt[i-1]*(d[i]-d[i-1]);
    for(int k=2;k<=4;++k){
        head=1;tail=0;
        for(int i=0;i<=n;++i)q[i]=0;
        for(int i=0;i<=n;++i)dp[i][k]=1e18;
        for(int i=1;i<=n;++i){
            while(head<tail&&K(q[tail-1],q[tail],k-1)>=K(q[tail],i-1,k-1))tail--;
            q[++tail]=i-1;
            while(head<tail&&K(q[head],q[head+1],k-1)<=d[i])head++;
            int j=q[head];dp[i][k]=dp[j][k-1]+pre[i]-pre[j]-cnt[j]*(d[i]-d[j]);
        }
    }
    cout<<dp[n][4];
    return 0;
}
```

---

## 作者：Purslane (赞：0)

# Solution

梦熊作业题里咋混进来一个普及组题 /xia

设 $dp_{u,i}$ 表示将前 $u$ 个家庭分作 $i$ 段，最小代价。

转移为：

$$dp_{u,i} = \min_{j <i } dp_{v,i-1} + p_i \times f_{j+1,i} - g_{j+1,i}$$

其中 $f_{l,r} = \sum_{i=l}^r t_i$，$g_{l,r} = \sum_{i=l}^r p_i t_i$，都可以写成前缀和的形式。

显然可以用斜率优化处理，复杂度 $O(nk)$。本题中 $k=4$。

不放代码。

---

## 作者：jamesharden666 (赞：0)

写发题解安慰我受伤的心灵。

这道题一眼瞅就跟仓库建设差不多，集会举办地一定在家庭处，在距离 $L$ 处建一个虚点。

设 $f_{i,j}$ 为考虑了前 $i$ 个家庭，第 $j$ 个举办地在第 $i$ 个家庭的路程开销总和最小值，答案为 $f_{n,4}$。

 $dp$ 式显然如下，其中 $sum_1$， $sum_2$ 是用来计算贡献的，自己手推一下就出来了。

$sum1_i=sum1_{i-1}+a_i$，$sum2_i=sum2_{i-1}+d_i \times a_i$

$f_{i,k}=\min(f_{i,k},f_{j,k-1}+d_i\times(sum1_i-sum1_j)-(sum2_i-sum2_j))$

你在一眼瞅就可以发现，这个式子可以斜率优化，化成如下形式

$d_i \times sum1_j+(f_{i,k}-d_i \times sum1_i+sum2_i)=f_{j,k-1}+sum2_j$

然后直接做就完了。

坑点：横坐标可能相同。

作者因为在 $1$ 处打成了 $k-1$，$2$ 处打成了 $\leq$ 遂调了 $40$ 分钟。

代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
int n,m,q[N];
long long d[N],a[N],sum1[N],sum2[N],f[N][5];
int read()
{
    int s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-')
            w=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
        s=s*10+(ch-'0'),ch=getchar();
    return s*w;
}
long double X(int i)
{
    return sum1[i];
}
long double Y(int i,int k)
{
    return f[i][k]+sum2[i];//1
}
long double Slope(int i,int j,int k)
{
    if(X(i)==X(j))
        return 1e18;
    else
        return (Y(j,k)-Y(i,k))/(X(j)-X(i));
}
int main()
{
    n=read(),m=read();
    for(int i=1;i<=n;++i)
        d[i]=read(),a[i]=read();
    n++;
    d[n]=m,a[n]=0;
    for(int i=1;i<=n;++i)
        sum1[i]=sum1[i-1]+a[i],sum2[i]=sum2[i-1]+d[i]*a[i];
    memset(f,0x3f,sizeof(f));
    f[0][0]=0;
    for(int k=1;k<=4;++k)
    {
        int l=1,r=0;
        q[++r]=0;
        for(int i=1;i<=n;++i)
        {
            while(l<r&&Slope(q[r-1],q[r],k-1)>=Slope(q[r],i,k-1))//2
                r--;
            q[++r]=i;
            while(l<r&&Slope(q[l],q[l+1],k-1)<=d[i])
                l++;
            int j=q[l];
            f[i][k]=f[j][k-1]+d[i]*(sum1[i]-sum1[j])-(sum2[i]-sum2[j]);
        }
    }
    printf("%lld",f[n][4]);
    return 0;
}
```

---

## 作者：OneLeft (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P8632)

## 思路
不难看出是 DP。

设 $dp_{i\ j}$ 表示前 $i$ 户人家，从中选择 $j$ 个集合点最小路径花费总和。

易得 

$$
dp_{i\ 1}=\sum_{j=1}^{i-1}t_j(d_i-d_j)
$$

$$
dp_{i\ 2}=\min_{j=1}^{i-1} \left\{dp_{j\ 1}+\sum_{k=j+1}^{i-1}t_k(d_i-d_k)\right\}
$$

化简上式得

$$
dp_{i\ 1}=d_i\sum_{j=1}^{i-1}t_j-\sum_{j=1}^{i-1}t_jd_j
$$

$$
dp_{i\ 2}=\min_{j=1}^{i-1} \left\{dp_{j\ 1}+d_i\sum_{k=j+1}^{i-1}t_k-\sum_{k=j+1}^{i-1}t_kd_k\right\}
$$

设

$$
\left\{\begin{matrix} 
sum_i=\sum_{j=1}^it_j\\  
ssum_i=\sum_{j=1}^it_jd_j
\end{matrix}\right.
$$

带入得

$$
dp_{i\ 1}=d_isum_{i-1}-ssum_{i-1}
$$

$$
dp_{i\ 2}=\min_{j=1}^{i-1}\left\{dp_{j\ 1}+d_i(sum_{i-1}-sum_j)-(ssum_{i-1}-ssum_j)\right\}
$$

化简得

$$
dp_{i\ 2}=\min_{j=1}^{i-1}\left\{dp_{j\ 1}+d_isum_{i-1}-d_isum_j-ssum_{i-1}+ssum_j\right\}
$$

去掉 $\min$ 得

$$
dp_{i\ 2}=dp_{j\ 1}+d_isum_{i-1}-d_isum_j-ssum_{i-1}+ssum_j
$$

移项得

$$
-dp_{j\ 1}-ssum_j=-d_isum_j-dp_{i\ 2}+d_isum_{i-1}-ssum_{i-1}
$$

等式两边同时取反得

$$
dp_{j\ 1}+ssum_j=d_isum_j+dp_{i\ 2}-d_isum_{i-1}+ssum_{i-1}
$$

不难发现是斜率优化，设

$$
\left\{\begin{matrix}
y=dp_{j\ 1}+ssum_j\\
x=sum_j\\
k=d_i\\
b=dp_{i\ 2}-d_isum_{i-1}+ssum_{i-1}
\end{matrix}\right.
$$

带入得 $y=kx+b$，标准的斜率优化。

## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+5,INF=(int)1e18+5;
int n,m,d[N],t[N],sum[N],ssum[N],dp[N][2];
deque<int>que;
double X(int id)
{
    return sum[id];
}
double Y(int id)
{
    return dp[id][0]+ssum[id];
}
double calc(int a,int b)
{
    if(X(a)==X(b))
        return INF;
    return (Y(a)-Y(b))/(X(a)-X(b));
}
bool check_front(int k)
{
    int a=que.front();
    que.pop_front();
    int b=que.front();
    que.push_front(a);
    return calc(a,b)<=k;
}
bool check_back(int node)
{
    int a=que.back();
    que.pop_back();
    int b=que.back();
    que.push_back(a);
    return calc(b,a)>=calc(a,node);
}
signed main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        cin>>d[i]>>t[i];
        sum[i]=sum[i-1]+t[i];
        ssum[i]=ssum[i-1]+t[i]*d[i];
    }
    d[++n]=m;
    sum[n]=sum[n-1],ssum[n]=ssum[n-1];
    for(int i=1;i<=n;i++)
        dp[i][0]=d[i]*sum[i-1]-ssum[i-1];
    que.push_back(0);
    for(int i=1;i<=n;i++)
    {
        while(que.size()>=2&&check_front(d[i]))
            que.pop_front();
        int j=que.front();
        dp[i][1]=dp[j][0]+d[i]*sum[i-1]-d[i]*sum[j]-ssum[i-1]+ssum[j];
        while(que.size()>=2&&check_back(i))
            que.pop_back();
        que.push_back(i);
    }
    for(int i=1;i<=n;i++)
        dp[i][0]=dp[i][1];
    que.clear();
    que.push_back(0);
    for(int i=1;i<=n;i++)
    {
        while(que.size()>=2&&check_front(d[i]))
            que.pop_front();
        int j=que.front();
        dp[i][1]=dp[j][0]+d[i]*sum[i-1]-d[i]*sum[j]-ssum[i-1]+ssum[j];
        while(que.size()>=2&&check_back(i))
            que.pop_back();
        que.push_back(i);
    }
    for(int i=1;i<=n;i++)
        dp[i][0]=dp[i][1];
    que.clear();
    que.push_back(0);
    for(int i=1;i<=n;i++)
    {
        while(que.size()>=2&&check_front(d[i]))
            que.pop_front();
        int j=que.front();
        dp[i][1]=dp[j][0]+d[i]*sum[i-1]-d[i]*sum[j]-ssum[i-1]+ssum[j];
        while(que.size()>=2&&check_back(i))
            que.pop_back();
        que.push_back(i);
    }
    cout<<dp[n][1];
    return 0;
}
```

---

## 作者：cppcppcpp3 (赞：0)

[传送门](https://www.luogu.com.cn/problem/P8632)。

下文中所有出现的 $n$ 都对应题目中的 $L$。

设 $a_i$ 为距离公路起点 $i$ 处的总人数，$f_{i,1/2/3}$ 表示前 $i$ 个点中，选了 $1/2/3$ 个点，且选择了点 $i$，前 $i$ 个点的最小代价。

暴力 dp 转移如下：

- $f_{i,1}=\sum\limits_{j=1}^i a_j(i-j)$

- $f_{i,2}=\min\limits_{1\le k<i}f_{k,1}+\sum\limits_{j=k+1}^i a_j(i-j)$

- $f_{i,3}=\min\limits_{1\le k<i}f_{k,2}+\sum\limits_{j=k+1}^i a_j(i-j)$

答案 $ans=\min\limits_{i=1}^{n-1} f_{i,3}+\sum\limits_{j=i+1}^n a_j(n-j)$。

直接做是 $O(n^2)$ 的，有 $40$ 分的部分分。

可以把 $\sum a_j(i-j)$ 拆开，令 $A_i$ 为 $a_i$ 的前缀和，$B_i$ 为 $i\times a_i$ 的前缀和：

- $f_{i,1}=i\times A_i-B_i$

- $f_{i,2}=\min\limits_{1\le k<i}f_{k,1}+i\times (A_i-A_k) - (B_i-B_k)$

- $f_{i,3}=\min\limits_{1\le k<i}f_{k,2}+i\times (A_i-A_k) - (B_i-B_k)$

把只与 $i$ 有关的项移到左边（以下两式省去了 $\min$）：

- $f_{i,2}-i\times A_i+B_i=-A_k \times i+(f_{k,1}+B_k)$

- $f_{i,3}-i\times A_i+B_i=-A_k \times i+(f_{k,2}+B_k)$

将 $-A_k$ 看作斜率，$f_{k,1/2}+B_k$ 看作纵截距，右式就变成了一次函数的形式。现在就是需要支持每次插入一条直线，并查询所有直线在 $x=i$ 时的 $y_{\min}$。用李超线段树维护，时间复杂度 $O(n\log n)$。

注意 $0 \le d_i \le n$。

```cpp
#include<bits/stdc++.h>
#define il inline
#define int long long
using namespace std;
const int N=1e6+5;
const int inf=1e18;

il int wrd(){
	int x=0,f=1; char c=getchar();
	while(!isdigit(c)){if(c=='-')f=-1; c=getchar();}
	while(isdigit(c)){x=x*10+c-48,c=getchar();}
	return x*f;
}

int n,m,a[N],A[N],B[N],ans=inf,dp[N][4];

struct seg{
	int k,b;
}sg1[N],sg2[N];

int val(int o,int x,bool op){
	if(o==-1) return inf;
	return op ? sg2[o].k*x+sg2[o].b : sg1[o].k*x+sg1[o].b;
}

int s[N<<2][2];

#define ls (t<<1)
#define rs (t<<1|1)
#define md ((l+r)>>1)
	
void modify(int l,int r,int t,int u,int op){
	int &v=s[t][op];
	if(val(v,md,op)>val(u,md,op)) swap(u,v);
	if(val(v,l,op)>val(u,l,op)) modify(l,md,ls,u,op);
	if(val(v,r,op)>val(u,r,op)) modify(md+1,r,rs,u,op);
}

int qry(int l,int r,int t,int x,int op){
	int ans=val(s[t][op],x,op);
	if(l==r) return ans;
	return min(ans,x<=md ? qry(l,md,ls,x,op) : qry(md+1,r,rs,x,op));
}

signed main(){
	m=wrd(),n=wrd();
	while(m--){
		int x=wrd(),y=wrd();
		a[x]+=y;
	}
	A[0]=a[0];
	for(int i=1;i<=n;++i) A[i]=A[i-1]+a[i],B[i]=B[i-1]+i*a[i];
	
	sg1[0].b=sg2[0].b=inf;
	
	for(int i=0;i<n;++i){
		dp[i][1]=i*A[i]-B[i];
		dp[i][2]=qry(0,n,1,i,0)+i*A[i]-B[i];
		dp[i][3]=qry(0,n,1,i,1)+i*A[i]-B[i];
		
		sg1[i]={-A[i],dp[i][1]+B[i]};
		sg2[i]={-A[i],dp[i][2]+B[i]};
		modify(0,n,1,i,0),modify(0,n,1,i,1);
		
		ans=min(ans,dp[i][3]+n*(A[n]-A[i])-B[n]+B[i]);
	}
	return printf("%lld",ans),0;
}
```

---

## 作者：gyyyyx (赞：0)

[题面](https://www.luogu.com.cn/problem/P8632)

~~好耶，又可以水题解了！~~

前置知识：[斜率优化](https://www.luogu.com.cn/blog/s19418/dp-di-you-hua-fang-shi#斜率优化)。

首先明显是 $\text{dp}$。

我们发现集会举办地一定是某人的家。

简单证明一下。

假设 $i\in [l,r]$ 的家庭都去到 $x$ 位置集会，那么开销为：

$$\sum\limits_{i=l}^r(x-d_i)t_i=\sum\limits_{i=l}^r(d_r-d_i)t_i+(x-d_r)\sum\limits_{i=l}^rt_i$$

因为前面一串是定值，因此 $x-d_r$ 越小，开销越小。

由题可知 $x\geq d_r$，所以 $x-d_r\geq 0$ 因此最优情况就是聚会地点为 $d_r$。

证毕。

那我们就可以设 $dp_{p,i}$ 表示前 $i$ 个家庭，选择 $p$ 个集会地点的最小开销。

写出转移方程：

$$
\begin{array}{l}
dp_{p,i}=\min\limits_{0\leq j<i}\{dp_{p-1,j}+\sum\limits_{k=j+1}^i(d_i-d_k)t_k\}\\
\qquad\,=\min\limits_{0\leq j<i}\{dp_{p-1,j}+d_i\sum\limits_{k=j+1}^it_k-\sum\limits_{k=j+1}^id_kt_k\}
\end{array}
$$

设 $s_i=\sum\limits_{j=1}^it_j,sp_i=\sum\limits_{j=1}^id_jt_j$，则：

$$
\begin{array}{l}
dp_{p,i}=\min\limits_{0\leq j<i}\{dp_{p-1,j}+d_i(s_i-s_j)-(sp_i-sp_j)\}\\
\qquad\,=\min\limits_{0\leq j<i}\{dp_{p-1,j}+d_is_i-d_is_j-sp_i+sp_j\}\\
\qquad\,=\min\limits_{0\leq j<i}\{dp_{p-1,j}-d_is_j+sp_j\}+d_is_i-sp_i
\end{array}
$$

发现式子中有既关于 $i$ 也关于 $j$ 的项，考虑斜优。

首先用滚动数组将二维压成一维。

设 $x_i=s_i,y_i=dp_i-sp_i,k_i=d_i,b_i=dp_i-(d_is_i-sp_i)$，有：

$$b_i=\min\limits_{0\leq j<i}\{y_j-k_ix_j\}$$

由于 $x_i$ 单调不降，$k_i$ 单调递增，可以用单调队列维护下凸壳。

代码：

```cpp
#include<bits/stdc++.h>
#define LL long long
#define N 100005
#define exp 1e-10
using namespace std;
int n;LL L,d[N],s[N],sp[N],dp[N],tmp[N];
int q[N],l,r;
inline LL X(int i){return s[i];}
inline LL Y(int i){return dp[i]+sp[i];}
inline long double slope(int i,int j){
	return 1.0*(Y(j)-Y(i))/(X(j)-X(i));
}
inline LL k(int i){return d[i];}
LL ans(LONG_LONG_MAX);
int main(){
	scanf("%d%lld",&n,&L);
	for(int i(1);i<=n;++i){
		int t;scanf("%lld%d",&d[i],&t);
		s[i]=s[i-1]+t;sp[i]=sp[i-1]+d[i]*t;
	}
	l=r=1;
	for(int i(1);i<=n;++i) dp[i]=d[i]*s[i]-sp[i];
	for(int j(2);j<=3;++j){
		for(int i(1);i<=n;++i){
			while(l<r&&slope(q[l],q[l+1])-k(i)<exp) ++l;
			tmp[i]=Y(q[l])-k(i)*X(q[l])+d[i]*s[i]-sp[i];
			while(l<r&&slope(q[r-1],q[r])-slope(q[r-1],i)>=exp) --r;
			q[++r]=i;
		}
		for(int i(1);i<=n;++i) dp[i]=tmp[i];
	}
	for(int i(3);i<=n;++i)
		ans=min(ans,dp[i]+L*(s[n]-s[i])-(sp[n]-sp[i]));
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：splendore (赞：0)

### 思路
为方便计算，新增一个村庄，令其 $d_{n+1}=L$。

令 $f_{i,k}$ 表示在 $i$ 处建第 $k$ 个集会的最小开销，容易得到方程：

$$f_{i,k}=\min_{0\le j<i}\{ f_{j,k-1}+d_i\sum_{p=j+1}^{i}t_p-\sum_{p=j+1}^{i}d_p t_p\}$$

发现 $f$ 可以滚动，令其减少一维。

设 $st_i=\sum_{j=1}^i t_j$，$sd_i=\sum_{j=1}^i d_j t_j$，化简得：

$$f_i=\min_{0\le j<i}\{f_j+d_i(st_i-st_j)-(sd_i-sd_j)\}$$

去掉 $\min$，利用斜率优化套路化简得：

$$f_j+sd_j=d_ist_j+f_i-d_ist_i+sd_i$$

接着直接上单调队列维护即可。

代码如下：
```
#include<cstdio>
using namespace std;
typedef long long LL;
constexpr int N=100005;
LL d[N],t[N],sd[N],st[N],f[N],tmp[N];
int q[N];
inline double X(int j){return st[j];}
inline double Y(int j){return tmp[j]+sd[j];}
inline double K(int j1,int j2){return X(j1)==X(j2)?1e18:(Y(j2)-Y(j1))/(X(j2)-X(j1));}
int main(){
	int n,m;scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)
		scanf("%lld%lld",&d[i],&t[i]);
	d[++n]=m;
	for(int i=1;i<=n;++i){
		sd[i]=sd[i-1]+d[i]*t[i];
		st[i]=st[i-1]+t[i];
		f[i]=1ll<<60;
	}
	for(int k=1;k<=4;++k){
		for(int i=1;i<=n;++i)tmp[i]=f[i],f[i]=1ll<<60;
		int l=0,r=0;
		for(int i=1;i<=n;++i){
			while(l<r&&K(q[l],q[l+1])<=d[i])++l;
			int j=q[l];
			f[i]=tmp[j]+d[i]*(st[i]-st[j])-sd[i]+sd[j];
			while(l<r&&K(q[r-1],q[r])>=K(q[r],i))--r;
			q[++r]=i;
		}
	}
	printf("%lld\n",f[n]);
	return 0;
}
```

---


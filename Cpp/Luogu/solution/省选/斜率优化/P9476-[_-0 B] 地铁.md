# [_-0 B] 地铁

## 题目背景

小 $\mathfrak{f}$ 的家乡 A 市最近开通了地铁。

## 题目描述

A 市共有 $n (2\le n \le 10^5)$ 个居民点，第 $i$ 个居民点的人口为 $s_i (1 \le s_i \le 10^7)$，同时有 $n-1$ 条双向道路，构成一棵树，第 $i $ 条双向道路连接居民点 $u_i$ 和 $v_i$，人步行走过这条道路需要 $w_i (1 \le w_i\le 10^7)$ 的时间。

现 A 市政府决定开通一条地铁线路。地铁线路是树上的一条简单路径，若路径经过第 $i$ 条道路，那么地铁从这条道路下方经过只需要 $w_i^{\prime} (1 \le w_i^{\prime} \le 10^7)$ 的时间，同时，地铁的进出站**共**需要花费 $t (0 \le t \le 10^7)$ 的时间。

已知，若一个人从一个居民点前往另一个居民点，如果这条路径与地铁经过的路径有至少一条公共**边**，那么就**一定**会选择**尽可能多地**乘坐地铁。如果没有公共边，那么就会选择完全步行。**题目保证对于第 $i$ 条道路有 $w_i^{\prime} \le w_i - t$。** 我们认为，如果两个居民点的人口的乘积越大，那么有人想要在它们之间流动的可能性也越大。

现在，小 $\mathfrak{f}$ 想知道在所有 $\frac{n(n-1)}{2}$ 种建造地铁线路的方案中，$\sum_{a=1}^{n-1}\sum_{b=a+1}^{n}(s_a \cdot s_b \cdot d_{a,b})$ 的最小值，其中 $d_{a,b}$ 表示从居民点 $a$ 前往 $b$（或者从 $b$ 前往 $a$，两者是相等的）所需要的时间。

但是他不会，所以他来求助万能的你。

## 说明/提示

**样例 $1$ 解释：**

修建地铁前如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/3oh0y5mn.png)

一种最优的修建地铁的方案为从 $2$ 到 $3$ 修建地铁。如下图所示（实线表示修建了地铁）：

![](https://cdn.luogu.com.cn/upload/image_hosting/ian9c6po.png)

从 $1$ 到 $2$ 经过地铁，所需时间为：$6+0=6$，对答案的贡献为：$9\times9\times6=486$。

从 $1$ 到 $3$ 经过地铁，所需时间为：$5+0=5$，对答案的贡献为：$9\times3\times5=135$。

从 $1$ 到 $4$ 不经过地铁，所需时间为：$6$，对答案的贡献为：$9\times2\times6=108$。

从 $1$ 到 $5$ 经过地铁，所需时间为：$6+9+0=15$，对答案的贡献为：$9\times3\times15=405$。

从 $2$ 到 $3$ 经过地铁，所需时间为：$6+5+0=11$，对答案的贡献为：$9\times3\times11=297$。

从 $2$ 到 $4$ 经过地铁，所需时间为：$6+6+0=12$，对答案的贡献为：$9\times2\times12=216$。

从 $2$ 到 $5$ 不经过地铁，所需时间为：$9$，对答案的贡献为：$9\times3\times9=243$。

从 $3$ 到 $4$ 经过地铁，所需时间为：$5+6+0=11$，对答案的贡献为：$3\times2\times11=66$。

从 $3$ 到 $5$ 经过地铁，所需时间为：$5+6+9+0=20$，对答案的贡献为：$3\times3\times20=180$。

从 $4$ 到 $5$ 经过地铁，所需时间为：$6+6+9+0=21$，对答案的贡献为：$2\times3\times21=126$。

综上，答案为：$486+135+108+405+297+216+243+66+180+126=2262$。

可以证明不存在更优的修建地铁的方案。

**本题采用捆绑测试且使用子任务依赖。**

| 编号 | 分值 | $n \le$ | 性质 | 依赖 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $0$ | $0$ | N/A | 样例 | 无 |
| $1$ | $5$ | $10$ | 无 | 无 |
| $2$ | $5$ | $500$ | 无 | $1$ |
| $3$ | $10$ | $5000$ | 无 | $1,2$ |
| $4$ | $30$ | $10^5$ | A | 无 |
| $5$ | $5$ | $10^5$ | B | 无 |
| $6$ | $20$ | $10^5$ | C | 无 |
| $7$ | $15$ | $10^5$ | D | 无 |
| $8$ | $10$ | $10^5$ | 无 | $0,1,2,3,4,5,6,7$ |

特殊性质 A：$t=0$

特殊性质 B：$u_i=i,v_i=i+1$

特殊性质 C：每一个点的度数都不超过 $100$

特殊性质 D：$u_i=1,v_i=i+1$

## 样例 #1

### 输入

```
0 5 0
9
9
3
2
3
1 2 7 6
1 3 8 5
1 4 6 5
2 5 9 9```

### 输出

```
2262```

## 样例 #2

### 输入

```
0 10 86
50
6
84
50
83
67
93
55
93
70
1 2 94 7
1 3 97 4
1 10 98 12
2 4 89 1
2 7 98 1
4 5 99 13
4 6 96 5
5 8 95 5
5 9 97 7```

### 输出

```
33600416```

# 题解

## 作者：0x3F (赞：9)

假如没有地铁，那么每条边对答案的贡献为 $w\times S_1\times S_2$，其中 $S_1,S_2$ 为这条边把树分成的两部分分别的点权和，如图。

![](https://cdn.luogu.com.cn/upload/image_hosting/36hli1r9.png)

现在有了地铁，使得答案减少了 $D$。

假设一个人从 $A$ 到 $B$，其中 $a,p_1,p_2,\cdots,p_k,b$ 共 $k+2$ 个点，$k+1$ 条边与地铁重合（$k$ 可以为 $0$），那么对 $D$ 的贡献为：

$$(w_{a\to p_1}-w'_{a\to p_1})+(w_{p_1\to p_2}-w'_{p_1\to p_2})+\cdots+(w_{p_k\to b}-w'_{p_k\to b})-t$$

其中 $w_{u\to v}$ 表示从 $u$ 到 $v$ 的边的 $w$ 的值。

上式也可以改写为：

$$(w_{a\to p_1}-w'_{a\to p_1}-t)+t+(w_{p_1\to p_2}-w'_{p_1\to p_2}-t)+t+\cdots+t+(w_{p_k\to b}-w'_{p_k\to b}-t)$$

也就是说，在这个人移动的过程中，经过的地铁的每条边对 $D$ 产生的贡献为 $w-w'-t$，每个“内点”（不是 $a,b$ 的点）对 $D$ 产生的贡献为 $t$，如图。

![](https://cdn.luogu.com.cn/upload/image_hosting/zn2ci1st.png)

考虑每条边和每个点产生贡献的次数。

每条边产生贡献，当且仅当它被经过。因此次数等于 $S_1S_2$，其中 $S_1,S_2$ 为这条边把树分成的两部分分别的点权和。

每个点产生贡献，当且仅当它作为“内点”被经过。由于地铁是一条链，在链上，与之相邻的两条边均被经过。因此次数等与 $S_1S_3$，其中 $S_1,S_3$ 为这两条边把树分成的三部分中，不包含该点的两部分分别的点权和。端点的贡献为 $0$。

因此对 $D$ 的贡献分别为 $S_1S_2(w-w'-t)$ 和 $S_1S_3t$，如图。

![](https://cdn.luogu.com.cn/upload/image_hosting/hyp95dng.png)

可以使用树形 DP 求出 $D$ 的最大值。

如果树根为 $1$，记 $dp_{i}(i\ne1)$ 表示如果链的一端为 $i$ 的父亲，另一端在 $i$ 的子树内，那么这条链产生的贡献，最大是多少。

转移有两种可能性：

一、另一端就是 $i$。此时只有 $i$ 连向父亲的边产生贡献。

即 $dp_{i}\gets(w_{i\to f_{i}}-w'_{i\to f_{i}}-t)siz_{i}(N-siz_{i})$。

其中 $f_{u}$ 表示 $u$ 的父亲，$siz_{u}$ 表示 $u$ 的子树内点权之和，$N$ 表示所有点权之和。


二、另一端不是 $i$。假设另一端在 $j$ 的子树内，则不仅 $i$ 连向父亲的边产生贡献，而且 $i$ 从端点变为内点，产生贡献。

即 $dp_{i}\gets(w_{i\to f_{i}}-w'_{i\to f_{i}}-t)siz_{i}(N-siz_{i})+tsiz_{j}(N-siz_i)+dp_j$。

如图。

![](https://cdn.luogu.com.cn/upload/image_hosting/02fx9l1i.png)

假设 $r$ 是地铁中深度最浅的点。

如果 $r$ 是端点，与 $r$ 相邻的是 $s$（是 $r$ 的儿子），那么 $D\gets dp_s$。

如果 $r$ 不是端点，与 $r$ 相邻的是 $s,t$（都是 $r$ 的儿子），由于点 $r$ 是内点，产生贡献，那么 $D\gets dp_s+dp_t+tsiz_ssiz_t$。

如图。

![](https://cdn.luogu.com.cn/upload/image_hosting/dub40dr3.png)

如果暴力枚举 $s,t$，会超时，应当使用斜率优化。

如果有 $siz$ 相同的，那么选取 $dp$ 最大和次大的作为 $s,t$，计入答案。

然后将 $siz$ 去重，只保留 $dp$ 最大的，将 $siz$ 从小到大排序。

由 $D=dp_s+dp_t+tsiz_ssiz_t$，移项得：

$$\underset{y}{\underline{dp_s}}=\underset{k}{\underline{-tsiz_t}}\times\underset{x}{\underline{siz_s}}+\underset{b}{\underline{D-dp_t}}$$

由于 $k,x$ 均单调，可以使用单调队列维护凸包。

时间复杂度为 $O(n\log n)$。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int _ = 1e5 + 10;
const int __ = 2e5 + 10;
int id, n, t, e, hd[_], nx[__], to[__], ln1[__], ln2[__];
long long siz[_], N;
__int128 dp[_];
inline void add(int u, int v, int w1, int w2) {
	e++;
	nx[e] = hd[u];
	to[e] = v;
	ln1[e] = w1;
	ln2[e] = w2;
	hd[u] = e;
}
__int128 sum, dif;
void dfs1(int x, int f) {
	for (int i = hd[x]; i; i = nx[i]) {
		int y = to[i];
		if (y != f) {
			dfs1(y, x);
			siz[x] += siz[y];
			sum += __int128(siz[y]) * (N - siz[y]) * (ln1[i]);
		}
	}
}
int m;
struct node {
	__int128 x;
	__int128 y;
} arr[_];
int l, r, q[_];
inline bool cmp(node a, node b) {
	if (a.x == b.x) return (a.y > b.y);
	return (a.x < b.x);
}
inline bool eqn(node a, node b) {
	return (a.x == b.x);
}
inline __float128 slope(node a, node b) {
	return ((__float128)(b.y - a.y) / (__float128)(b.x - a.x));
}
void dfs2(int x, int f, __int128 z) {
	dp[x] = z;
	for (int i = hd[x]; i; i = nx[i]) {
		int y = to[i];
		if (y != f) {
			dfs2(y, x, __int128(siz[y]) * (N - siz[y]) * (ln1[i] - ln2[i] - t));
			if (f) dp[x] = max(dp[x], dp[y] + z + __int128(siz[y]) * (N - siz[x]) * (t));
			dif = max(dif, dp[y]);
		}
	}
	m = 0;
	for (int i = hd[x]; i; i = nx[i]) {
		int y = to[i];
		if (y != f) {
			m++;
			arr[m].x = siz[y];
			arr[m].y = dp[y];
		}
	}
	sort(arr+1, arr+m+1, cmp);
	for (int i = 1; i < m; i++) {
		if (arr[i].x == arr[i+1].x) {
			dif = max(dif, arr[i].y + arr[i+1].y + t * arr[i].x * arr[i+1].x);
		}
	}
	m = unique(arr+1, arr+m+1, eqn) - arr - 1;
	l = r = 1;
	q[1] = 1;
	for (int i = 2; i <= m; i++) {
		while (r > l && slope(arr[q[l]], arr[q[l+1]]) > (-t * arr[i].x)) l++;
		dif = max(dif, arr[i].y + arr[q[l]].y + t * arr[i].x * arr[q[l]].x);
		while (r > l && slope(arr[q[r]], arr[i]) > slope(arr[q[r-1]], arr[i])) r--;
		q[++r] = i;
	}
}
int main() {
	cin >> id >> n >> t;
	for (int i = 1; i <= n; i++) {
		cin >> siz[i];
		N += siz[i];
	}
	for (int i = 1; i < n; i++) {
		int u, v, w1, w2;
		cin >> u >> v >> w1 >> w2;
		add(u, v, w1, w2);
		add(v, u, w1, w2);
	}
	dfs1(1, 0);
	dfs2(1, 0, __int128(0));
	__int128 ans = sum - dif;
	string str;
	while (ans) {
		str = (char)((ans % 10) + 48) + str;
		ans /= 10;
	}
	cout << str << endl;
	return 0;
}
```

---


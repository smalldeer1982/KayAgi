# [NOI2008] 假面舞会

## 题目描述

一年一度的假面舞会又开始了，栋栋也兴致勃勃的参加了今年的舞会。

今年的面具都是主办方特别定制的。每个参加舞会的人都可以在入场时选择一个自己喜欢的面具。每个面具都有一个编号，主办方会把此编号告诉拿该面具的人。

为了使舞会更有神秘感，主办方把面具分为 $k$（$k\geq 3$）类，并使用特殊的技术将每个面具的编号标在了面具上，只有戴第 $i$ 类面具的人才能看到戴第 $i+1$  类面具的人的编号，戴第 $k$ 类面具的人能看到戴第 $1$ 类面具的人的编号。

参加舞会的人并不知道有多少类面具，但是栋栋对此却特别好奇，他想自己算出有多少类面具，于是他开始在人群中收集信息。

栋栋收集的信息都是戴第几号面具的人看到了第几号面具的编号。如戴第 $2$ 号面具的人看到了第 $5$ 号面具的编号。栋栋自己也会看到一些编号，他也会根据自己的面具编号把信息补充进去。

由于并不是每个人都能记住自己所看到的全部编号，因此，栋栋收集的信息不能保证其完整性。现在请你计算，按照栋栋目前得到的信息，至多和至少有多少类面具。由于主办方已经声明了 $k\geq 3$，所以你必须将这条信息也考虑进去。


## 说明/提示

- 对于 $50\%$ 的数据，满足 $n \leq 300$，$m \leq 10^3$；
- 对于 $100\%$ 的数据，满足 $n \leq 10^5$，$m \leq 10^6$。


## 样例 #1

### 输入

```
6 5
1 2
2 3
3 4
4 1
3 5```

### 输出

```
4 4
```

## 样例 #2

### 输入

```
3 3
1 2
2 1
2 3```

### 输出

```
-1 -1
```

# 题解

## 作者：StudyingFather (赞：31)

（UPD 2021/08/21：感谢 @[wxy_](https://www.luogu.com.cn/user/317459) 同学指出原来题解中的一些错误之处，已经对相关部分进行了修正。）

如果整个图没有环，且不存在两条共用起点和终点的相交链，显然最多能分的种类数是每个连通分量内最长链的长度之和。

如果整个图是由若干个不相交的环构成的话，最多能分的种类数是所有环长度的最大公约数（找环的时候，可以从连通块内的任意一点开始编号，第二次经过一个点的时候，它第二次的编号减去第一次的编号就是环的大小）。

除了这两种特殊情况之外，还有两种情况：

1. 两个环之间有公共部分（指至少共用两个点）。
2. 存在两个链共用起点和终点。

对于情况 1，合法的面具数一定是这两个环长度的公约数。

对于情况 2，合法的面具数一定是两个链长度差的约数。

我们将每个部分的结果合并，最后就可以得到整个图的结果。

先处理情况 1。我们考虑倒推：建图的时候不仅连一条 $u \to v$，边权为 $1$ 的边之外，同时连一条 $v \to u$，边权为 $-1$ 的边（这种连边方式可以确保我们从任意一个点开始，都可以遍历整个连通块）。

对于每个连通块，我们还是任意选一个点开始编号，经过一条边的时候将编号加上边权，和上面一样，第二次经过同一个点的时候，它第二次的编号减去第一次的编号就是环的大小。

接下来处理情况 2。我们发现，上面的建图方式已经很好地处理了这种情况（走反边的时候权值 `-1`，刚好可以得到两条链长度的差值），因此不需要再另外进行处理。

（最后别忘了题目要求面具最少要有三种）

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <vector>
#define INF 1e9
using namespace std;
struct edge {
  int v, w;
  bool operator<(const edge& a) const {
    return v < a.v || (v == a.v && w < a.w);
  }
};
vector<edge> e[100005];
int dis[100005], vis[100005], ans, res, cnt, maxv, minv;
int gcd(int x, int y) { return y == 0 ? x : gcd(y, x % y); }
void dfs(int u, int d) {
  if (dis[u]) {
    ans = gcd(ans, abs(d - dis[u]));
    return;
  }
  dis[u] = d, vis[u] = 1;
  maxv = max(maxv, dis[u]);
  minv = min(minv, dis[u]);
  for (auto i : e[u]) dfs(i.v, d + i.w);
}
int main() {
  int n, m;
  scanf("%d%d", &n, &m);
  for (int i = 1; i <= m; i++) {
    int u, v;
    scanf("%d%d", &u, &v);
    e[u].push_back({v, 1});
    e[v].push_back({u, -1});
  }
  for (int i = 1; i <= n; i++)
    if (!vis[i]) {
      maxv = -INF, minv = INF;
      dfs(i, 1);
      res += maxv - minv + 1;
    }
  if (ans) {
    if (ans < 3)
      puts("-1 -1");
    else
      for (int i = 3; i <= ans; i++)
        if (ans % i == 0) {
          printf("%d %d\n", ans, i);
          break;
        }
  } else {
    if (res < 3)
      puts("-1 -1");
    else
      printf("%d 3\n", res);
  }
  return 0;
}

```

---

## 作者：water_tomato (赞：9)

本文同步发表于个人博客：[Link](https://www.watertomato.com/p1477noi2008%e5%81%87%e9%9d%a2%e8%88%9e%e4%bc%9a%e9%a2%98%e8%a7%a3/)。

[题目链接](https://www.luogu.com.cn/problem/P1477)。

发现题解区说大多都是直接说再连一条边权为 $-1$ 的边，在这里略微证明一下正确性。​

## 解析

首先发现若图中没有环，最大答案为所有联通块的最长链长度之和，最小答案为 $3$。

若存在环，则最大答案为所有环的 $\gcd$​​。为了在可接受的时间内找到所有环，我们对于每一条边的 $u\rightarrow v$​​，从 $u$​​ 向 $v$​​ 连一条边权为 $1$​​ 的边，从 $v$​​ 向 $u$​​ 连一条边权为 $-1$​​ 的边。然后每一次都从任意一个未被搜索过的点开始搜，并记录每一个点的距离 $dis$​​，若走到一个已走过的点 $i$​​，就取 $d-dis_i$​​ 作为一个新找到的环的长度，这部分代码如下：

```cpp
inline void dfs(int u,int d){
	if(dis[u]){
		ans=gcd(ans,abs(d-dis[u]));
		return;
	}
	dis[u]=d;vis[u]=1;
	mx=max(mx,dis[u]);mn=min(mn,dis[u]);
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;dfs(v,d+e[i].w);
	}
}
```

接着我们观察下面这张图。

![](https://cdn.luogu.com.cn/upload/image_hosting/jwki6g60.png)

我们发现，当图中出现上图这个情况时，记 $a$​​ 为红色环的长度，$b$​​ 为蓝色部分的长度，$c$​​​ 为中间部分的长度。这时的两个环的长度分别为 $a$​​ 和 $a+b-c$​​，但是我们搜索时搜出来的长度可能是 $a$​​ 和 $c-b$​​​ 或 $a+b-c$ 和 $c-b$，即先搜完 $a$ 这个环，再从 $T$ 点以 $-1$ 的道路通过 $b$ 回到 $S$​​ 点。

也就是说，这个做法想要正确，需要有 $\gcd(a,a+b-c)=\gcd(a,|c-b|)$ 且 $\gcd(a,a+b-c)=\gcd(a+b-c,|c-b|)$​​。

先证明前者：

- 若 $b \ge c$​，有 $\gcd(a,|c-b|)=\gcd(a,b-c)=\gcd(a,a+b-c)$​，显然正确
- 若 $b<c$​ ，有 $\gcd(a,|c-b|)=\gcd(a,c-b)=\gcd(a,a+c-b)$​，换言之，我们需要证明 $\gcd(a,a+b)=\gcd(a,a-b),a>b$​。

**证明：**

记 $x=\gcd(a,a-b)$，则 $x|a$ 且 $x|b$。

设 $a=mx$，$b=nx$，有 $m$ 与 $m-n$ 互质且 $m>n$，故 $\gcd(a,a+b)=\gcd(mx,(m+n)x)$。

若 $m+n$ 与 $m$ 不互质，有 $\gcd(m+n,m)=\gcd(n,m)\ne 1$。

可设 $t=\gcd(m,n)$，有 $m=k_1t,n=k_2t,m-n=(k_1-k_2)t$​​，与 $m$ 与 $m-n$ 互质矛盾。

故 $m+n$​ 与 $m$​ 互质，即 $\gcd(a,a+b)=x=\gcd(a,a-b)$​​。

再证明后者：

- 若 $c \ge b$，有 $\gcd(a+b-c,|c-b|)=\gcd(a+b-c,c-b)=\gcd(a+b-c,a)$。
- 若 $c<b$，有 $\gcd(a+b-c,|c-b|)=\gcd(a+b-c,b-c)=\gcd(a+b-c,a+2b-2c)$，将 $a+b-c$ 和 $b-c$ 分别看作 $\gcd(a,a+b)=\gcd(a,a-b)$ 中的 $a$ 和 $b$​，由上得证。

同时我们又发现，除了上图的情况，其他的情况搜到的环的长度都是真是的或是可以化成上图情况的。

因此，建反向的边权为 $-1$ 的边的做法是正确的。求出最大答案后，最小答案显然为最大答案的最小的 $\ge3$ 的因子，求出答案后再判断一下和 $3$​​ 的关系即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
const int M=1e6+5;
int n,m;
struct node{
	int to,nxt,w;
}e[M];
int cnt,head[N];
inline void add(int u,int v,int w){
	e[++cnt].to=v;
	e[cnt].nxt=head[u];
	e[cnt].w=w;
	head[u]=cnt;
}
int dis[N],ans,ans2,mx,mn;
bool vis[N];
inline int gcd(int a,int b){
	return b==0?a:gcd(b,a%b);
}
inline void dfs(int u,int d){
	if(dis[u]){
		ans=gcd(ans,abs(d-dis[u]));
		return;
	}
	dis[u]=d;vis[u]=1;
	mx=max(mx,dis[u]);mn=min(mn,dis[u]);
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;dfs(v,d+e[i].w);
	}
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1,u,v;i<=m;i++){
		scanf("%d%d",&u,&v);
		add(u,v,1);add(v,u,-1);
	}
	for(int i=1;i<=n;i++){
		if(!vis[i]){
			mx=-1e9;mn=1e9;
			dfs(i,1);
			ans2+=mx-mn+1;//找最长链
		}
	}
	if(ans){//有环
		if(ans<3) printf("-1 -1\n");
		else for(int i=3;i<=ans;i++){
			if(!(ans%i)){
				printf("%d %d\n",ans,i);
				return 0;
			}
		}
	}
	else{//没环
		if(ans2<3) printf("-1 -1\n");
		else printf("%d 3\n",ans2);
	}
	return 0;
}
```



---

## 作者：sodak (赞：9)

对于给出的图，存双向边，正向长度为1，反向长度为-1，我们可以将它处理为环和链
* 对于单个的环来说，其中k最大可能为环中的节点个数，其因数都为该环k的个数的可能情况—>可以推得多个环的最大可能为多个环的最大公因数（因为所有环都要满足），最小可能为最大公因数的最小因数（所有因数都有可能，这里取最小的）;
* 对于无环的链来说，最大可能为图中所有链的长度总和，最小可能为k的最低限制3;

所以综上

在k>=3时

最大值：有环情况下，为所有环的节点个数的最大公因数，无环为所有链长之和

最小值：有换情况下，为所有环的节点个数的最大公因数的最小的因数(>=3)，无环情况下为为k最小取值3

在k<3时

最大值：-1
最小值：-1

代码如下
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+10,maxm=2e6+10;
int head[maxn],ver[maxm],edge[maxm],Next[maxm],tot=1;
bool vis[maxn];//记录点的访问情况
bool flag[maxm];//记录边的访问情况
int mx,mn,ans,m,n;
int d[maxn];//记录dfs初始点到该节点的距离
int gcd(int a,int b){//求最大公因数
	return b==0?a:gcd(b,a%b);
}
void add(int x,int y,int z){
	ver[++tot]=y,edge[tot]=z,Next[tot]=head[x],head[x]=tot;
}
void DFS(int now){
	vis[now]=1;
	for(int i=head[now];i;i=Next[i]){
		int to=ver[i];
		if(!vis[to]){
			d[to]=d[now]+edge[i];
			DFS(to);
		}
		else ans=gcd(ans,abs(d[now]+edge[i]-d[to]));
	}
}
void dfs(int now){
	vis[now]=1;
	mx=max(mx,d[now]);//更新最大距离
	mn=min(mn,d[now]);//更新最小距离
	for(int i=head[now];i;i=Next[i]){
		if(!flag[i]){
			flag[i]=flag[i^1]=1;//标记反向边，使其只能向一边走
			int to=ver[i];
			d[to]=d[now]+edge[i];
			dfs(to);
		}
	}
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1,x,y;i<=m;i++){//正向加正边，反向加反边
		scanf("%d%d",&x,&y);
		add(x,y,1);
		add(y,x,-1);
	}
	for(int i=1;i<=n;i++){//判环
		if(!vis[i])DFS(i);
	}
	if(ans){
		if(ans<3){//不符合k>=3
			printf("-1 -1\n");
			return 0;
		}
		else{
			int x;
			for(x=3;x<=ans;x++)if(ans%x==0)break;//求最小因数为最小可能
			printf("%d %d\n",ans,x);
			return 0;		
		}
	}
	//寻找环失败，开始寻找链
	memset(vis,0,sizeof(vis));
	for(int i=1;i<=n;i++){
		if(!vis[i]){
			mx=mn=d[i]=0;
			//初始化最大值最小值，因为正向为1,反向为-1，并且初始点不一定是两端
			dfs(i);
			ans+=mx-mn+1;//最大距离（正）减去最小距离（负）为链长
		}
	}
	if(ans>=3)printf("%d 3\n",ans);
	else printf("-1 -1\n");//不符合k>=3
	return 0;
}


```

---

## 作者：SS80194 (赞：6)

本文是对其他题解中所谓“找环”所采用的建图方式的详细说明。

这些题解声称：用以下的方式建图，搜索可以得出原图中所有环长，结果跑出来确实是对的，但看着好像不是很靠谱。

注：本题解只讨论连通块有环的情况，其它细节请参见其它题解。

### 具体做法：

原图所有边边权为 $1$，再建出所有边的反边，边权都为 $-1$。

dfs的时候，如果搜到搜过的点 $v$，则产生一个大小为 $dep[u]+e[i].W-dep[v]$ 的环，否则就搜 $v$ 点，并记录所有点的深度。

最后所有的环的大小取公约数即可。

------------
### 正确性证明

我们需要用到一个叫 **DFS 生成树**（[从OIwiki了解](https://oi-wiki.org/graph/scc/)）的科技。

下面证明这棵 DFS 生成树**不可能含有横叉边**。假设有 $u$ 点和 $v$ 点，$u$ 点在 $v$ 点后面被访问到，这条横叉边的方向显然必须是 $ u \to v$。模拟 DFS 的过程可以轻松知道， $v$ 点一定会通过 $v \to u$ 这条反向边先访问 $u$，之后才会是 $lca(u,v) \to v$ 推出矛盾。

![](https://cdn.luogu.com.cn/upload/image_hosting/98y98qyb.png)

换句话说，$v$ 点会先通过横叉边的反向边到达 $u$ 点，也就不会产生如图的生成树。而这条横叉边会在实际的生成树中作为返祖边出现，它的反边会成为树边。

所以，这棵 DFS 生成树，不计树边，只剩下**返祖边**或**前向边**。

如果是通过**原图就有的返祖边**到达之前访问过的节点的话，环的大小显然就是 $dep[u]+e[i].W-dep[v]$，没有任何问题。

考虑**原图没有的返祖边**，其实他一定是**原图中存在的一条前向边的反边**。根据类似前面对横叉边的分析，可以得到结论：这条前向边在实际操作时会被当成返祖边和横叉边各食用一次。

计算正的前向边时所得到的答案是 $dep[u]+1-dep[v]$，而在计算反的返祖边时，所得到的答案是 $dep[v]-1-dep[u]$，显然两者互成相反数。

这时候就会发现不对：**哪来的负环**？

实际上我们再观察一下图就能发现问题所在。

![](https://cdn.luogu.com.cn/upload/image_hosting/djujbzxz.png)

**我们真的要求原图中一定要有环吗？不。**

如果有两条起点终点相同的路径，他们的长度之差必须是面具种类的整数倍。以图一为例，那他们的**只要**橙色和绿色的路径长度除面具个数**同余即可**！即 $dis[u]+e[i].W \equiv dis[v] \; \pmod A $ 就行了。并不一定在原图中要有环。

---

## 作者：1000001001wj (赞：6)

#**经过我一周中四次重构终于A了**

\_本题解仅用于抛蒟蒻引大佬\_

**AC链接**

<https://www.luogu.org/record/show?rid=2365855>

好，开始正文。。。

首先我们分析一下这道题

>都看题解了应该看过题了吧。。。
**注意**

- 图不一定联通（废话）

- 类数大于等于3（废话×2）

- 不要乱剪枝。。。（废话×3）

##总共就3种情况

1. 环
2. 奇奇怪怪的环。。类似于1→2→3→4→5，1→6→5这样

3. 链，显然有这种奇奇怪怪而且没什么卵用的情况

首先，如果有1或2那么3就真的没什么卵用（废话）

那么先讨论有1或2的情况

1的话显然是求所有环长的gcd

2的话我们看上面的例子，显然2和6是同一类，进而3和5也是同一类，那么3能看到的5也能，所以5能看到4，然后，我们又找到一个奇奇怪怪的环。。。。

接下来说说只有3的情况，比较麻烦，那我们一会再说吧（打死这个zz）

##环长和链长的求法

首先这题dfs没得说那么直接编号就好，在输入时注意去除重边，建边时正反建，正边权为1，反边权为-1（其实没必要存权，搜的时候分开就好），搜的时候记录哪个点被搜过，这样搜的时候搜到搜过的点就会有一个环，环长显然（显然求证法？）是当前编号与这个点的编号的差（勿忘abs），直接和ans求gcd就好，至于链的问题（没错，我没忘）只要在搜的时候记录最小编号和最大编号，最后两个一减再加一就是该链长，如果没有1或2的话，答案就是sum(链长)和3(显然)

##一点没什么卵用的小问题

关于最少类数，显然（又来！？）是pj的问题。。。

但我还是说说吧。。

简单来说就是从**3**一直搜到**ans/2**就好，只要ans%当前值==0就输出答案然后return

当然这样你也是WA，搜不到记得输出两个ans

```cpp
#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>
#include <utility>
#define f first
#define s second
/*#include <fstream>
#define fin cin
#define fout cout*/
/*#define un unsigned
#define l long
#define ll long long
#define ull un ll*/
//被封印的四行
using std::cin;
using std::cout;
using std::endl;
//std::ifstream fin(".in");
//std::ofstream fout(".out");
struct wtfd{
    int bh;//点编号
    std::vector<int>zb,fb;//连边 正反存 
}d[100001];
int n,m;
int ans;
int lc[3];//0为 仅有链时最多种
//1为当前最小 2为当前最大
bool alr[100001];//已搜过
std::pair<int,int>b[1000000];//边
int gcd(int,int);
void dfs(int,int);
int main(){
    std::ios::sync_with_stdio(false);//cin大法好
    cin>>n>>m;
    for (int i=0;i<m;++i)
        cin>>b[i].f>>b[i].s;
    std::sort(b,b+m);
    d[b[0].f].zb.push_back(b[0].s);
    d[b[0].s].fb.push_back(b[0].f);
    for (int i=1;i<m;++i){
        if (b[i].s!=b[i-1].s||b[i].f!=b[i-1].f){
            d[b[i].f].zb.push_back(b[i].s);
            d[b[i].s].fb.push_back(b[i].f);
        }
    }//剔除重边
    for (int i=1;i<=n;++i)
        if (!alr[i]){
            dfs(i,0);
            lc[0]+=lc[2]-lc[1]+1;
            lc[1]=lc[2]=0;
        }
    if (ans>=3){
        for (int i=3;i<=ans/2;++i)
            if (ans%i==0){
                cout<<ans<<' '<<i<<endl;
                return 0;
            }
        cout<<ans<<' '<<ans<<endl;
        return 0;
    }
    if (ans==0&&lc[0]>=3){
        cout<<lc[0]<<' '<<3<<endl;
        return 0;
    }
    cout<<-1<<' '<<-1<<endl;
    //fin.close();
    //fout.close();
}
int gcd(int a,int b){
    if (b==0) return a;
    else return gcd(b,a%b);
}
void dfs(int dq,int bh){
    if (!alr[dq]){
        alr[dq]=true;
        d[dq].bh=bh;
        lc[1]=std::min(lc[1],bh);
        lc[2]=std::max(lc[2],bh);
        for (int i=0;i<d[dq].zb.size();++i)
            dfs(d[dq].zb[i],bh+1);
        for (int i=0;i<d[dq].fb.size();++i)
            dfs(d[dq].fb[i],bh-1);
    }
    else ans=gcd(ans,abs(bh-d[dq].bh));
}
```
最后的最后提醒大家，上来就namespace不好，真的不好。。。


---

## 作者：Xing_ke (赞：3)

## **本题解与多菜联盟联合出品>WQ**

### 题面：
一年一度的假面舞会又开始了，栋栋也兴致勃勃的参加了今年的舞会
今年的面具都是主办方特别定制的。每个参加舞会的人都可以在入场时选择一 个自己喜欢的面具

每个面具都有一个编号，主办方会把此编号告诉拿该面具的人
为了使舞会更有神秘感，主办方把面具分为**k (k≥3)类**，并使用特殊的技术将每个面具的编号标在了面具上
只有戴**第i 类面具的人才能看到戴第i+1 类面具的人的编号**，**戴第k 类面具的人能看到戴第1 类面具的人的编号**

参加舞会的人并不知道有多少类面具，但是栋栋对此却特别好奇
他想自己算出有多少类面具，于是他开始在人群中收集信息

栋栋收集的信息都是戴第几号面具的人看到了第几号面具的编号
如戴第2号面具的人看到了第5 号面具的编号
栋栋自己也会看到一些编号，他也会根据自己的面具编号把信息补充进去

由于并不是每个人都能记住自己所看到的全部编号
因此，栋栋收集的信 息不能保证其完整性
现在请你计算，按照栋栋目前得到的信息，至多和至少有多少类面具
由于主办方已经声明了**k≥3**，所以你必须将这条信息也考虑进去


------------

### 观察：
- $kind_{i}->kind_{i+1}$
	
  若存在链，则链只能为$kind:1->2->3->4->5->……$  
  
- $k->1$

  若存在环，则环为$kind:1->2->3->4->1$或$kind:1->2->3->4->1->2->3->4->1……
  $

- $k≥3$

	若$k<3$，则$ans=-1$
    
### 分析：

- **若无环**，根据链的性质，$ans=$每个连通分量内最长链的长度之和


`

- **若有环且环互不相交**，根据环的性质，$ans=$所有环长度的最大公约数

`



- **若环之间存在相交部分**，直接遍历可能会漏环。考虑建权值为$1$的正向边，和权值为$-1$反向边，（这种连边方式可以确保我们从任意一个点开始，都可以遍历整个连通块）。对于每个连通块，我们还是任意选一个点开始编号，经过一条边的时候将编号加上边权，和上面一样，第二次经过同一个点的时候，它第二次的编号减去第一次的编号就是环的大小。这样就万无一失了

$ps:$不必判断环是否有相交，直接建双向边遍历$DFS$即可

### 处理：

- **最大值**：有环情况下，为所有环的节点个数的最大公因数($gcd$)，无环为所有链长之和

`
- **最小值**：有换情况下，为所有环的节点个数的最大公因数的最小的因数(>=3)，无环情况下为为k最小取值3

`
- **$k<3$**，则 $mx=-1,mi= -1$


------------


## 看到这里理解的同志，请自动跳过以下的胡扯



### 蒟蒻的疑惑与自我解答（~~可能假~~）：



- **环和链的$ans$是否会冲突？**

**“如果无法将所有的面具分为至少 3 类，使得这些信息都满足，则认为栋栋收集的信息有错误”**


所以不必考虑$k$的存在性,只用考虑$k$是否满足$k≥3$，即从环求出的$ans$一定满足链的要求


**胡扯完毕qwq**

------------
## 上代码
### 观前提示：建议理解的同志，劳烦亲自动手。
蒟蒻马峰若带来不适，还望各位保留意见

```cpp
#include<bits/stdc++.h>
#define M 2000010
#define N 100010

using namespace std;
inline int read(){
	int x=0;int f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while( isdigit(ch)){ x=x*10+ch-'0'; ch=getchar();}
	return x*f;
}

bool vis[N],flag[M];
int n,m,mi,mx,ans,dis[N];
inline int gcd(int a,int b){
	return b==0?a:gcd(b,a%b);
}

struct Bian_{
	int to,nxt,val;
}e[M];
int cnt=-1,head[N];
inline void Lian(int fr,int to,int val){
	cnt++;
	e[cnt].to=to;
	e[cnt].val=val;
	e[cnt].nxt=head[fr];
	head[fr]=cnt;
}

inline void DFS_ring(int x){
	vis[x]=1;
	for(int i=head[x];~i;i=e[i].nxt){//不用i而用~i
		int y=e[i].to,v=e[i].val;
		if(!vis[y]){
			dis[y]=dis[x]+v;
			DFS_ring(y);
		}
		else ans=gcd(ans,abs(dis[x]+v-dis[y]));
	}
}

inline void DFS_chain(int x){
	vis[x]=1;cerr<<x<<endl;
	mx=max(mx,dis[x]);
	mi=min(mi,dis[x]);
	for(int i=head[x];~i;i=e[i].nxt){
		if(!flag[i]){
			flag[i]=flag[i^1]=true;//(0,1),(2,3),(4,5)…… 
			int y=e[i].to,v=e[i].val;
			dis[y]=dis[x]+v;
			DFS_chain(y);
		}
	}
}

int main(){
	n=read();m=read();
	memset(head,-1,sizeof(head));
	for(int i=1;i<=m;++i){
		int a=read(),b=read();
		Lian(a,b,1);Lian(b,a,-1);//(0,1),(2,3),(4,5)…… 
	}
	
	for(int i=1;i<=n;++i)
		if(!vis[i]) DFS_ring(i);
	if(ans){
		if(ans<3){
			printf("-1 -1\n");cerr<<"!"<<endl;return 0;
		}else{
			int x；
			for(x=3;x<=ans;++x)if(ans%x==0)break;
			printf("%d %d\n",ans,x);return 0;
		}
	}
	
	memset(vis,0,sizeof(vis));
	for(int i=1;i<=n;++i){
		if(!vis[i]){
			mx=mi=dis[i]=0;cerr<<mx<<mi;
			DFS_chain(i);
			//dfs(i);
			ans+=mx-mi+1;//可能走了负边，要加回来
		}
	}		
	if(ans>=3)printf("%d 3\n",ans);
	else printf("-1 -1\n");//不符合k>=3
	return 0;
	
}
```

### 代码细节：
	为了实现flag标记(1^1=0),cnt赋初值为-1，同时head也要赋初值为-1
    
    （就这调了一晚上，没处理过第一条边为0的情况qwq）
         
$ps:$这是本蒟蒻的第一篇题解，感谢各位$dalao$题解的点醒，感谢各位的观看，还望管理大大高抬贵手啊

（完结撒花QWQ）


---

## 作者：HH_Halo (赞：2)

## 思路分析
* 首先不难发现，这道题的关键在于是否能形成环，很容易联想到并查集和tarjan等对环形进行处理的操作，然而这道题和这些算法并没有什么关系......
* 直接模拟过程，判断是否存在环的操作很简单，关键在于求出环长
* 在环的个数和环的长度都求出来以后，我们就可以进行判断
1.  有环的情况：
	* 最大值：所有环长的最大公约数（有可能有多个环，要保证每个环都成立）。因为只有当环长是种类数的倍数时，才可以保证环内顺序一定而不冲突
    * 最小值：最大值的不小于3的最小约数。
2. 无环有链的情况：
	* 最大值：所有链的长度之和
    * 最小值：3
    
`细节较多，详见代码`
## $Code$
```c++
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn = 1e5+10,maxm = 1e6+10;
int vis[maxn],flag[maxn],d[maxn],head[maxn]; /d为到起点的距离
int n,m,ans,mx,mn;
int gcd(int a,int b){
	return (b == 0 ? a : gcd(b,a%b));
}
struct edge{
	int next,to,w;
}e[maxm<<1];
int cnt = 1; //注意因为正向边和反向边相关联，所以初始值为1，从2,3开始存边
void addedge(int u,int v,int val){
	e[++cnt].to = v;
	e[cnt].w = val;
	e[cnt].next = head[u];
	head[u] = cnt;
}
void DFS(int u){ //该DFS用于求环
	vis[u] = 1;
	for(int i = head[u];~i;i = e[i].next){
		int v = e[i].to;
		if(!vis[v]){ //若该点为到达过
			d[v] = d[u]+e[i].w; //更新v到起点的距离
			DFS(v);
		}
		else{ //若该点到达过，说明存在环
			ans = gcd(ans,abs(d[u]+e[i].w-d[v])); //最大公约数求最大种类数。（因为反向边权值为-1，所以不需要特判回到父亲节点的情况）
		}
	}
}
void dfs(int u){//无环时用该dfs跑链
	//更新链中最大最小值
	mx = max(mx,d[u]);
	mn = min(mn,d[u]);
	vis[u] = 1;
	for(int i = head[u];~i;i = e[i].next){
		if(!flag[i]){ //该边为走过
			flag[i] = flag[i^1] = 1; //正向反向都标记，保证不会回返
			int v = e[i].to;
			d[v] = d[u]+e[i].w;
			dfs(v);
		}
	}
}
int main(){
	scanf("%d%d",&n,&m);
	memset(head,-1,sizeof(head));
	for(int i = 1;i <= m;i++){
		int x,y;scanf("%d%d",&x,&y);
		addedge(x,y,1);addedge(y,x,-1); //正向边权值为1,反向边为-1
	}
	for(int i = 1;i <= n;i++){//先求环
		if(!vis[i])DFS(i);
	}
	if(ans){ //说明有环
		if(ans<3)printf("-1 -1");
		else{
			int i;
			for(i = 3;i <= ans;i++){ //ans的最小约数即为最少种类数
				if(ans%i==0)break;
			}
			printf("%d %d",ans,i);
		}
		return 0;
	}
	memset(vis,0,sizeof(vis)); //说明无环
	for(int i = 1;i <= n;i++){
		if(!vis[i]){
			mx = mn = d[i] = 0;
			dfs(i);
			ans+=mx-mn+1; //最大值为链长
		}
	}
	if(ans>=3)printf("%d %d",ans,3);
	else printf("-1 -1");
	return 0;
}
```

---

## 作者：无意识躺枪人 (赞：2)

```
一年一度的假面舞会又开始了，栋栋也兴致勃勃的参加了今年的舞会
今年的面具都是主办方特别定制的。每个参加舞会的人都可以在入场时选择一 个自己喜欢的面具

每个面具都有一个编号，主办方会把此编号告诉拿该面具的人
为了使舞会更有神秘感，主办方把面具分为k (k≥3)类，并使用特殊的技术将每个面具的编号标在了面具上
只有戴第i 类面具的人才能看到戴第i+1 类面具的人的编号，戴第k 类面具的人能看到戴第1 类面具的人的编号

参加舞会的人并不知道有多少类面具，但是栋栋对此却特别好奇
他想自己算出有多少类面具，于是他开始在人群中收集信息

栋栋收集的信息都是戴第几号面具的人看到了第几号面具的编号
如戴第2号面具的人看到了第5 号面具的编号
栋栋自己也会看到一些编号，他也会根据自己的面具编号把信息补充进去

由于并不是每个人都能记住自己所看到的全部编号
因此，栋栋收集的信 息不能保证其完整性
现在请你计算，按照栋栋目前得到的信息，至多和至少有多少类面具
由于主办方已经声明了k≥3，所以你必须将这条信息也考虑进去
```

看到题，显然就是找是否有看到的关系构成了一个环的结构

如果有环，那么答案就是所有环的$gcd$

所以现在的问题就是找到所有的环

dfs搜索的时候，如果一个点已经被搜过，就可以更新答案

最小的可能就是ans的最小的因子（>3）

当然，有可能没有环

这种情况就直接统计每个连通块内最长链的长度

最小答案一定是3

代码：
```cpp
#include<bits/stdc++.h>
#define N 1000005
using namespace std;

int n,m,u,v,ans;

struct Edge
{
	int next,to,dis;
}edge[N<<1];
int cnt=0,head[N];

int gcd(int a,int b) {return b?gcd(b,a%b):a;}

inline void add_edge(int from,int to,int dis)
{
	edge[++cnt].next=head[from];
	edge[cnt].to=to;
	edge[cnt].dis=dis;
	head[from]=cnt;
}

template<class T>inline void read(T &res)
{
	char c;T flag=1;
	while((c=getchar())<'0'||c>'9')if(c=='-')flag=-1;res=c-'0';
	while((c=getchar())>='0'&&c<='9')res=res*10+c-'0';res*=flag;
}

bool vis[N];
int dis[N];
void dfs1(int u)
{
	vis[u]=1;
	for(register int i=head[u];i;i=edge[i].next)
	{
		int v=edge[i].to;
		if(vis[v]) ans=gcd(ans,abs(dis[u]-dis[v]+edge[i].dis));
		else
		{
			dis[v]=dis[u]+edge[i].dis;
			dfs1(v);
		}
	}
}

int minans=1234567890,maxans=0;
void dfs2(int u)
{
	vis[u]=1;
	minans=min(minans,dis[u]);
	maxans=max(maxans,dis[u]);
	for(register int i=head[u];i;i=edge[i].next)
	{
		int v=edge[i].to;
		if(vis[v]) continue;
		dis[v]=dis[u]+edge[i].dis;
		dfs2(v);
	}
}

int main()
{
	read(n);read(m);
	for(register int i=1;i<=m;++i)
	{
		read(u);read(v);
		add_edge(u,v,1);
		add_edge(v,u,-1);
	}
	for(register int i=1;i<=n;++i) if(!vis[i]) dfs1(i);
	if(ans)
	{
		if(ans<3){puts("-1 -1");return 0;}
		minans=0;
		for(register int i=1;i<=ans;++i)
		{
			if(!(ans%i)&&i>2)
			{
				minans=i;
				break;
			}
		}
		printf("%d %d",ans,minans);
		return 0;
	}
	memset(vis,0,sizeof(vis));
	memset(dis,0,sizeof(dis));
	for(register int i=1;i<=n;++i)
	{
		if(!vis[i])
		{
			maxans=minans=0;
			dfs2(i);
			ans+=maxans-minans+1;
		}
	}
	minans=3;
	if(ans<3) ans=minans=-1;
	printf("%d %d",ans,minans);
	return 0;
}
```

---

## 作者：龙神哈迪斯 (赞：2)

```cpp
//详解请看注释，这是一道思维难度之题，看不出来否则就会很难写暴力
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<cmath>
using namespace std;
#define rg register
const int M=1000005;
int n,m,x,y,ans,anss;
//关于gcd的一个我从未发现的事情，任意一个数于0的gcd还是为它本身
inline int gcd(int a,int b){return b?gcd(b,a%b):a;}
struct hand{int to,next,w;}a[M<<1];
int cnt,head[M];
void link(int u,int v,int w){a[++cnt]=(hand){v,head[u],w};head[u]=cnt;}
int dui[M],vis[M],sum;//vis是点的序号
vector<int>fan;
void bfs(int s)
{
    int minn=1e9,maxx=1e9;
    int H=0,T=1;
    bool flag=0;
    dui[1]=s;
    vis[s]=1e9;//怕炸裂
    while(H<T)
    {
        int u=dui[++H];
        for(int e=head[u];e;e=a[e].next)
        {
            int v=a[e].to;
            if(!vis[v])
            {
                dui[++T]=v;
                vis[v]=vis[u]+a[e].w;
                maxx=max(maxx,vis[v]);
                minn=min(minn,vis[v]);
            }
            else if(vis[v]==vis[u]+a[e].w)continue;
            else
            {
                flag=1;
                fan.push_back(abs(vis[v]-(vis[u]+a[e].w)));
            }
        }
    }
    if(!flag)
    {
        sum+=(maxx-minn+1);
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    while(m--)
    {
        scanf("%d%d",&x,&y);
        link(x,y,1);
        link(y,x,-1);//方便我bfs
    }
    for(int i=1;i<=n;i++)
    {
        if(!vis[i])bfs(i);
    }
    if(fan.size())
    {
        ans=fan[0];
        for(int i=1;i<fan.size();i++)
        {
            ans=gcd(ans,fan[i]);
        }
        if(ans<=2){printf("-1 -1\n");return 0;}
        else
        {
            int cao=sqrt(ans);//枚举质因子啊,haha ->_->
            anss=ans;
            for(int i=2;i<=cao;i++)
            {
                if(!(ans%i))
                {
                    if(i>=3)
                    {
                        anss=min(anss,i);
                    }
                    if(ans/i>=3)
                    {
                        anss=min(anss,ans/i);
                    }
                }
            }
            printf("%d %d\n",ans,anss);
            return 0;
        }
    }
    else
    {
        if(sum<3) printf("-1 -1\n");
        else printf("%d %d\n",sum,3);
        return 0;
    }
    return 0;
}
/*
  对于这种连题意都看不懂的恶心题目的理解
  非常套路啊
  gcd()你要求一些很奇妙的东西
  就像一个环上点的标号可以是1-2-1-2```同样满足条件
于是我们知道了要输出的答案一定是所有环长的质因子，就好了

然后由于星图是残损的，所有存在伪环，你可以自己yy一条边把图中的最长链给拼在一起

对，还有细节，注意k是有大于三就取三中最小的那个，否则输出-1（这是求最小可能的），否则就是最大公约数，注意特判

然后，实现是重点，上面只是一些很莫名其妙的思想（看不懂没关系）

注意反边建立，这样当矛盾点产生时记录两个标号之差的绝对值就好了

  <-\_<- 简单吧

\*/
```cpp

---


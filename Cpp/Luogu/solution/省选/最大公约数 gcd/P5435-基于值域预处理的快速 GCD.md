# 基于值域预处理的快速 GCD

## 题目背景

模板题，无背景。

## 题目描述

给定 $n$ 个正整数 $a_1,a_2,\dots,a_n$，再给定 $n$ 个正整数 $b_1,b_2,\dots,b_n$，你需要对每对 $(i,j)$ 求出 $a_i$ 与 $b_j$ 的最大公因数。

不难发现你的输出应有 $n^2$ 个正整数。为了减少输出对程序的运行效率的影响，你只需要输出 $n$ 行，每行一个整数 $A_i$。

其中对于 $i\in[1,n]$，$A_i=\sum_{j=1}^{n}i^j\gcd(a_i,b_j)$。由于答案可能过大，你只需要输出模 $998,244,353$ 后的结果即可。

## 说明/提示

对于 $20\%$ 的数据，$1\leqslant n\leqslant 500$。

对于 $100\%$ 的数据，$1\leqslant n\leqslant 5000;1\leqslant a_i,b_i\leqslant 10^6$。

**请注意常数因子对程序运行效率的影响**

## 样例 #1

### 输入

```
5
200 300 300 300 23333
666 666 666 666 123456
```

### 输出

```
16
564
3636
14328
3905
```

# 题解

## 作者：moongazer (赞：51)

# 一种$O($值域$)$时间预处理$O(1)$时间求最大公约数($\gcd$)的算法

[$\mathfrak{View\space it\space on\space my\space Blog}$](https://blog.seniorious.cc/2020/quick-gcd/)

Update in 2020.08.07：修正了一处错误，感谢@Kinesis的指正

## 一些约定
1. $N$为询问的值域
2. $Prime$为全体素数集合
3. 集合$\{a_1,a_2,\cdots,a_m\}$是$n$的分解，当且仅当$a_1\times a_2\times\cdots\times a_m=n$

## 原理
### 定理一
#### 内容
可以将值域中的每个$x$分解成$\{a,b,c\}$，满足$a,b,c\leq\sqrt{x}$或$\in Prime$（定义这种分解为合法分解）
#### 证明
不妨设$a\leq b\leq c$若$c\notin Prime$且$c>\sqrt{x}$，则$c$可分解为$\{d,e\}$且$d\leq e$有$d\leq\sqrt{x}$,而$a\times b=\frac{x}{c}<\sqrt{x}$则有$n$的分解$\{d,a\times b,e\}$，若$e>\sqrt{x}$则可按该规律一直分解直到$e\in Prime$或$\leq\sqrt{x}$
### 定理二
#### 内容
对于询问$\gcd(x,y)$，分别考虑$a,b,c$对答案的贡献，$a$对答案的贡献为$\gcd(a,y)$，再将$y$除以$\gcd(a,y)$（这个因子已经被算过，不能重复计算），再对$b,c$干同样的事，三个贡献相乘即为$\gcd(x,y)$
#### 证明
> 易得引理若$r\mid p, r\mid q$则$\gcd(p,q)=r\times\gcd(\frac{p}{r},\frac{q}{r})$

分别代入$\left\{
\begin{aligned}
&p_1=a\times b\times c,q_1=y,r_1=\gcd(a,q_1) \\
&p_2=b\times c,q_2=\frac{q_1}{r_1},r_2=\gcd(b,q_2) \\
&p_3=c,q_3=\frac{q_2}{r_2},r_3=\gcd(c,q_3)
\end{aligned}
\right.
$即可


## 实现
我们发现实现的难点在于如何在$O(N)$时间内进行分解，询问部分较为容易

### 分解
对于$x\geq2$，找到$x$的最小质因子$p$以及$\frac{x}{p}$的合法分解$\{a_0,b_0,c_0\}$且$a_0\leq b_0\leq c_0$,$x$的一种合法分解即为$\{a_0\times p,b_0,c_0\}$的升序排序

考虑证明：

1. $x\in Prime$时显然成立,分解为$\{1,1,x\}$
2. 当$p\le\sqrt[4]{x}$时将$a_0\leq\sqrt[3]{\frac{x}{p}}$带入有$a_0\times p\le\sqrt{x}$
3. 考虑$p>\sqrt[4]{x}$的情况，$\left(1.\right)$ $a_0=1$，显然有$a_0\times p=p\le\sqrt{x}$；$\left(2.\right)$ $a\neq1$，由于$x$不是素数，$\frac{x}{p}$的最小质因子$q$即为$x$的第二小质因子，一定$\geq p$，而$a_0,b_0,c_0$都为$\frac{x}{p}$的非$1$因子，有$p\leq q\leq a_0\leq b_0\leq c_0$,$p\times a_0\times b_0\times c_0>(\sqrt[4]{x})^4=x$与$p\times a_0\times b_0\times c_0=x$相矛盾，故不存在此情况

所以只用跑一次线性筛，用最小质因子更新即可，然后预处理出$\sqrt{n}\times\sqrt{n}$的$\gcd$数组

代码如下
```cpp
// fac为合法分解，isp表示是否非质数，pri为质数数组，tot为pri的大小，pre为预处理的gcd数组，M为值域，T为sqrt(M)
void work() {
  fac[1][0] = fac[1][1] = fac[1][2] = 1;
  for (int i = 2; i <= M; ++i) {
    if (!isp[i]) {
      fac[i][0] = fac[i][1] = 1;
      fac[i][2] = i;
      pri[++tot] = i;
    }
    for (int j = 1; pri[j] * i <= M; ++j) {
      int tmp = pri[j] * i;
      isp[tmp] = true;
      fac[tmp][0] = fac[i][0] * pri[j];
      fac[tmp][1] = fac[i][1];
      fac[tmp][2] = fac[i][2];
      if (fac[tmp][0] > fac[tmp][1]) {
        fac[tmp][0] ^= fac[tmp][1] ^= fac[tmp][0] ^= fac[tmp][1];
      }
      if (fac[tmp][1] > fac[tmp][2]) {
        fac[tmp][1] ^= fac[tmp][2] ^= fac[tmp][1] ^= fac[tmp][2];
      }
// 对于整数运算a ^= b ^= a ^= b等价于swap(a, b)这里就是手动进行length = 3的排序
      if (i % pri[j] == 0) {
        break;
      }
    }
  }
  for (int i = 0; i <= T; ++i) {
    pre[0][i] = pre[i][0] = i;
  }
  for (int i = 1; i <= T; ++i) {
    for (int j = 1; j <= i; ++j) {
      pre[i][j] = pre[j][i] = pre[j][i % j];
    }
  }
}
```

### 查询
若当前枚举的为$a$，只需注意$a>\sqrt{N}$时分$a\mid y$和$a\nmid y$两种情况即可

以下为代码
```cpp
int gcd(int a, int b) {
// 不想写if-else所以用三目运算符代替并缩进了一下
  int ans = 1;
  for (int i = 0; i < 3; ++i) {
    int tmp = (fac[a][i] > T) ?
                (b % fac[a][i] ?
                   1
                 : fac[a][i]
                )
              : pre[fac[a][i]][b % fac[a][i]];
    b /= tmp;
    ans *= tmp;
  }
  return ans;
}
```

## 本题做法
基本上已经没了，就是求$\gcd$然后按题目给的算，放个代码吧
```cpp
const int N = 5000;
const int M = 1000000;
const int T = 1000;
const int Mod = 998244353;

void work();
int gcd(int, int);

int pre[T + 2][T + 2];
int a[N + 2], b[N + 2];
int fac[M + 2][3];
bool isp[M + 2];
int pri[M / 10], tot;
int n;

int main () {
  work();
  read(n);
  for (int i = 1; i <= n; ++i) {
    read(a[i]);
  }
  for (int i = 1; i <= n; ++i) {
    read(b[i]);
  }
  for (int i = 1; i <= n; ++i) {
    int ans = 0;
    for (int j = 1, now = i; j <= n; ++j, now = now * 1ll * i % Mod) {
      ans = (ans + int(now * 1ll * gcd(a[i], b[j]) % Mod)) % Mod;
    }
    write(ans), EL;
  }
  return 0;
}

void work() {
  fac[1][0] = fac[1][1] = fac[1][2] = 1;
  for (int i = 2; i <= M; ++i) {
    if (!isp[i]) {
      fac[i][0] = fac[i][1] = 1;
      fac[i][2] = i;
      pri[++tot] = i;
    }
    for (int j = 1; pri[j] * i <= M; ++j) {
      int tmp = pri[j] * i;
      isp[tmp] = true;
      fac[tmp][0] = fac[i][0] * pri[j];
      fac[tmp][1] = fac[i][1];
      fac[tmp][2] = fac[i][2];
      if (fac[tmp][0] > fac[tmp][1]) {
        fac[tmp][0] ^= fac[tmp][1] ^= fac[tmp][0] ^= fac[tmp][1];
      }
      if (fac[tmp][1] > fac[tmp][2]) {
        fac[tmp][1] ^= fac[tmp][2] ^= fac[tmp][1] ^= fac[tmp][2];
      }
      if (i % pri[j] == 0) {
        break;
      }
    }
  }
  for (int i = 0; i <= T; ++i) {
    pre[0][i] = pre[i][0] = i;
  }
  for (int i = 1; i <= T; ++i) {
    for (int j = 1; j <= i; ++j) {
      pre[i][j] = pre[j][i] = pre[j][i % j];
    }
  }
}
int gcd(int a, int b) {
  int ans = 1;
  for (int i = 0; i < 3; ++i) {
    int tmp = (fac[a][i] > T) ?
                (b % fac[a][i] ?
                   1
                 : fac[a][i]
                )
              : pre[fac[a][i]][b % fac[a][i]];
    b /= tmp;
    ans *= tmp;
  }
  return ans;
}
```

---

## 作者：hehezhou (赞：40)

#### 感谢@Duan2baka 指出一处错误
这道题很多人可能会以为要求的东西是有性质  
然而确实有预处理$O($值域$)$预处理 $O(1)$查询的方法

首先用线性筛预处理，可以把大多数的数分解成三个不大于$O(\sqrt n)$的数的乘积  
如果分解出来大于$O(\sqrt n)$的话，一定是一个质数  
具体方法:  
1.找出一个数$x$的最小质因子$p$,并得到$\frac xp$的分解  
2.把$p$乘到最小的数上即可

证明一下为什么是对的  
考虑归纳法  
只需证明把$p$乘上最小的数后得到的结果一定不大于$\sqrt n$  
$\frac np$分解中最小的一个数$a$一定不大于$\sqrt[3]\frac np$  
$a\times p\leq\sqrt[3] \frac np \times p$  
当$p > \sqrt[4] n$时，显然分解出的三个数为它的三个质因子,成立  
否则$a\times p\leq\sqrt[3]\frac n{\sqrt[4] n}\times\sqrt[4]n=\sqrt n$  
证毕  

于是乎，对于每次询问就可以把一个数分解  
然后第一次暴力取一下膜  
值域就变为了$O(\sqrt v)$  
于是就可以打一个$O(\sqrt v)\times O(\sqrt v)$的表  
$O(v)-O(1)$

```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod = 998244353;
const int maxn = 5000, v = 1000000, radio = 1000;
int a[maxn + 10], b[maxn + 10], n, ans;
int np[v + 10], prime[v + 10], cnt;
int k[v + 10][3];
int _gcd[radio + 10][radio + 10];
inline int gcd(int a, int b) {
    int g = 1;
    for(int tmp, i = 0; i < 3; i++) {
        if(k[a][i] > radio) {
            if(b % k[a][i] == 0) tmp = k[a][i];
            else tmp = 1;
        }
        else tmp = _gcd[k[a][i]][b % k[a][i]];
        b /= tmp;
        g *= tmp;
    }
    return g;
}
int main() {
    k[1][0] = k[1][1] = k[1][2] = 1;
    np[1] = 1;
    for(int i = 2; i <= v; i++) {
        if(!np[i]) prime[++cnt] = i, k[i][2] = i, k[i][1] = k[i][0] = 1;
        for(int j = 1; prime[j] * i <= v; j++) {
            np[i * prime[j]] = 1;
            int *tmp = k[i * prime[j]];
            tmp[0] = k[i][0] * prime[j];
            tmp[1] = k[i][1];
            tmp[2] = k[i][2];
            if(tmp[1] < tmp[0]) swap(tmp[1], tmp[0]);
            if(tmp[2] < tmp[1]) swap(tmp[2], tmp[1]);
            if(i % prime[j] == 0) break;
        }
    }
    for(int i = 1; i <= radio; i++) _gcd[i][0] = _gcd[0][i] = i;
    for(int _max = 1; _max <= radio; _max++)
        for(int i = 1; i <= _max; i++)
            _gcd[i][_max] = _gcd[_max][i] = _gcd[_max % i][i];
    // for(int i = 1; i <= 10; i++)
        // for(int j = 1; j <= 10; j++) printf("gcd(%d, %d) = %d\n", i, j, _gcd[i][j]);
    scanf("%d", &n);
    for(int i = 1; i <= n; i++) scanf("%d", a + i);
    for(int i = 1; i <= n; i++) scanf("%d", b + i);
    for(int i = 1; i <= n; i++) {
        int now = 1, ans = 0;
        for(int j = 1; j <= n; j++) {
            now = 1ll * now * i % mod;
            ans = (ans + 1ll * gcd(a[i], b[j]) * now) % mod;
        }
        printf("%d\n", ans);
    }
    return 0;
}
```

---

## 作者：Maysoul (赞：36)

这题不就是求 $ \gcd $ 嘛！辗转相除法求 $ \gcd $ 真是太简单啦！

普通的 $ \gcd $ 它长这个样子：

```cpp
int gcd(int a,int b)
{
	if(b==0) return a;
	return gcd(b,a%b);
}
```
然后我们就T飞了。

![](https://cdn.luogu.com.cn/upload/image_hosting/50p4a3bj.png)

所以我们有必要引入一种特殊的，好用的，超级快的算法—— Binary GCD 。

Binary GCD （二进制算法求GCD）的思想就是不断的去除因子2以达到降低常数的目的。以下我将详细讲解这种算法：


对于 $ \gcd(x,y) $，满足 $ x,y>0 $：

可分以下几种情况：

1.$ x=y $，显然，$ \gcd(x,y)=x=y $。

2.$ x=0 $ 或 $ y=0 $：

$ x=0$ 时，$ \gcd(x,y)=\gcd(0,y)=y $。

$ y=0$ 时，$ \gcd(x,y)=\gcd(x,0)=x $。

3.$ x,y $ 均为偶数，显然 $ x,y $ 均有因子2，故可以去掉因子2变成：$ \gcd( \frac{x}{2} , \frac{y}{2}) $ 。

4.$ x $ 为奇数，$ y $ 为偶数，则 $ y $ 有因子2，可去掉变成 $ \gcd( x, \frac{y}{2}) $ 。

5.同理，当$ x $ 为偶数，$ y $ 为奇数的时候变成 $ \gcd( \frac{x}{2}, y) $。

6.当$ x,y $ 均为奇数,可得$ \gcd(x,y)= \gcd(x-y,y) $ （$ a \ge b $）。

这玩意叫做**更减相损术**，具体证明过程如下：

当 $ x=y $ 时，$ \gcd(x,y)=x=y $，等同于情况1。

当 $ x>y $ 时，设 $ \gcd(x,y)=a $:

$$\because   a \mid x , a \mid y $$

$$\therefore   a \mid x-y$$

$$\therefore \gcd(x,y)=\gcd(x-y,y) $$

因为 $ x,y $ 均为奇数，那么 $ x-y $ 是偶数，等同于情况3，可以写为 $ \gcd( \frac{x-y}{2}, y) $。

以上就是二进制算法的全部内容，我们将上面的模拟出来的样式，叫做 **Stein 算法**。

当然模拟的时候使用二进制位运算来大幅提升效率的方式，就是我们所讲的二进制算法了：
```cpp
int gcd(int a,int b)
{
	int i,j;
	if(a==0) return b;
	if(b==0) return a;
	for (i=0;0==(a&1);++i) a>>=1;//去掉所有的2
	for (j=0;0==(b&1);++j) b>>=1;//去掉所有的2
	if(j<i) i=j;
	while(1)
	{
		if(a<b) swap(a,b);//交换a,b
		if(0==(a-=b)) return b<<i;//辗转减
		while(0==(a&1)) a>>=1;//去掉所有的2
	}
	return a;
}
```
提交就会发现又T飞了，这是因为我们这个算法一直在循环向下找二进制的末尾0，速度还是太慢。

我们只好再引入一种神器`__builtin `。

以这个开头的函数都是极快的位运算函数，比如我们将要使用的`__builtin_ctz( ) `。

这个函数可以获取到括号内元素中二进制表示的末尾元素0的个数。

利用这个，就可以省去循环跑的时间。

用`__builtin `优化完之后的函数长这样：


```cpp
int gcd(int a,int b)
{
	int az=__builtin_ctz(a),bz=__builtin_ctz(b);
	int z=min(az,bz);
	int dif;
	b>>=bz;
	while(a)
	{
		a>>=az;
		dif=b-a;
		az=__builtin_ctz(dif);
		if(a<b) b=a;
		if(dif<0) a=-dif;
		else a=dif;
	}
	return b<<z;
}
```
![](https://cdn.luogu.com.cn/upload/image_hosting/8ez5bvrs.png)

就没有然后了，这题其实根本不用卡常，我什么优化都没加，裸着跑也能跑过。

完整代码放在下方：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e6+10;
const int mod=998244353;
long long ans,n;
int x[10000];
int y[10000];
int gcd(int a,int b)
{
	int az=__builtin_ctz(a),bz=__builtin_ctz(b);
	int z=min(az,bz);
	int dif;
	b>>=bz;
	while(a)
	{
		a>>=az;
		dif=b-a;
		az=__builtin_ctz(dif);
		if(a<b) b=a;
		if(dif<0) a=-dif;
		else a=dif;
	}
	return b<<z;
}

int main()
{
	cin>>n;
	for (int i=1;i<=n;i++)
	{
		cin>>x[i];
	} 
	for (int i=1;i<=n;i++)
	{
		cin>>y[i];
	}
	for (int i=1;i<=n;i++)
	{
		ans=0;
		long long num=i;//num和ans必须要开long long
		for (int j=1;j<=n;j++)
		{
			ans+=num*gcd(x[i],y[j]);
			ans%=mod;//每次计算完之后取一次余避免误差
			num=num*i%mod;
		}
		cout<<ans%mod<<endl;
	}
	return 0;
}

```



---

## 作者：hhoppitree (赞：15)

### 功能简述

可在 $\mathcal{O}(v)-\mathcal{O}(1)$ 的时间内多次询问 $\gcd(n,m)(1\le n,m\le v)$。

### 算法过程

$\rm Lemma\;\#01$：对于任意正整数 $n$，存在三个正整数 $a,b,c$ 满足 $abc=n$ 且 $a,b\le\sqrt{n}$，$c\le\sqrt{n}$ 与 $c\in\mathbb{P}$ 中有至少一个成立。

证明：

采用数学归纳法，易得 $n=1$ 时成立。

对于正整数 $n$，设 $p$ 为其最小质因数，$a',b',c'$ 为 $\dfrac{n}{p}$ 的一合法分解（$a'\le b'\le c'$），则：

- 若 $p\le\sqrt[4]{n}$，则因为 $a'\le\sqrt[3]{\dfrac{n}{p}}$，所以 $pa'\le p\sqrt[3]{\dfrac{n}{p}}=\sqrt[3]{np^2}\le\sqrt{n}$，所以 $pa',b',c'$ 为一符合条件的解；
- 若 $p>\sqrt[4]{n}$，则若 $a'>p$，则 $n=pa'b'c'>p^4>n$，矛盾！故 $a'<p$，而又有 $p$ 为 $n$ 的最小质因数，所以 $a'=1$，故 $p,b,c$ 为一符合条件的解。

综上所述，原命题成立。

这也揭示了将 $n$ 分解为满足上述条件的 $a,b,c$ 的方法：线性筛后将 $n$ 最小素因子 $p$ 乘给 $\dfrac{n}{p}$ 分解成的三个数中最小的数即可。

所以当询问 $\gcd(n,m)$ 时，可以将 $n$ 分解为这样的 $abc$，每次求 $t=\gcd(a/b/c,m)$ 后，将最终结果乘上 $t$ 并将 $m$ 除以 $t$，即可得解。

具体地，若此时考虑到的数 $x$ 为素数，则求 $\gcd(x,m)$ 是简单的；否则必有 $x\le\sqrt{n}$，而 $\gcd(x,m)=\gcd(x,m\bmod x)$，所以只需预处理出 $\sqrt{v}$ 内任意两个数的 $\gcd$ 后 $\mathcal{O}(1)$ 查询即可。

时间复杂度：$\mathcal{O}(\sqrt{v}^2)=\mathcal{O}(v)$ 预处理，$\mathcal{O}(1)$ 查询。

### 例题 $1$：

- 给定数列 $a,b$，对每一个 $i$，求 $\sum\limits_{j=1}^{n}i^j\gcd(a_i,b_j)$。
- $n\le5000$，$a_i,b_i\le v=10^6$。

乍看一个推式子题，用如上高科技秒切。

时间复杂度：$\mathcal{O}(n^2+v)$

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 5005, M = 1e6 + 5, S = 1000, P = 998244353;

int _a[M], _b[M], _c[M];
int v[M], p[M], r;
int f[S + 1][S + 1];
int a[N], b[N];

void Init()
{
	_a[1] = _b[1] = _c[1] = 1;
	for (int i = 2; i <= M - 5; ++i) {
		if (!v[i]) {
			p[++r] = i;
			_a[i] = _b[i] = 1, _c[i] = i; 
		}
		int tp;
		for (int j = 1; j <= r && (tp = i * p[j]) <= M - 5; ++j) {
			v[tp] = 1;
			_a[tp] = _a[i] * p[j];
			_b[tp] = _b[i];
			_c[tp] = _c[i];
			if (_a[tp] > _b[tp]) {
				swap(_a[tp], _b[tp]);
				if (_b[tp] > _c[tp]) {
					swap(_b[tp], _c[tp]);
				}
			}
			if (!(i % p[j])) {
				break;
			}
		}
	}
	
	for (int i = 1; i <= S; ++i) {
		f[0][i] = f[i][0] = i;
		for (int j = 1; j <= S; ++j) {
			f[i][j] = f[j % i][i];
		}
	}
	return;
}

int gcd(int x, int y)
{
	int A = 1, tp = f[_a[x]][y % _a[x]];
	A *= tp;
	y /= tp;
	tp = f[_b[x]][y % _b[x]];
	A *= tp;
	y /= tp;
	tp = (v[_c[x]] ? f[_c[x]][y % _c[x]] : (y % _c[x] ? 1 : _c[x]));
	A *= tp;
	y /= tp;
	return A;
}

signed main()
{
	Init();
	int n;
	scanf("%d", &n);
	for (int i = 1; i <= n; ++i) {
		scanf("%d", &a[i]);
	}
	for (int i = 1; i <= n; ++i) {
		scanf("%d", &b[i]);
	}
	for (int i = 1; i <= n; ++i) {
		int tp = 1, A = 0;
		for (int j = 1; j <= n; ++j) {
			tp = 1ll * tp * i % P;
			A = (A + 1ll * tp * gcd(a[i], b[j])) % P;
		}
		printf("%d\n", A);
	}
	return 0;
}
```

---

## 作者：Leasier (赞：9)

### 简介
一种基于值域预处理的快速求 gcd 的算法。
### 算法
前置芝士：[线性筛](https://oi-wiki.org/math/sieve/#_7)

设 $\operatorname{Prime}$ 表示质数集合，并定义正整数 $n$ 的**合法分解**：若对于正整数 $a, b, c$ 有 $abc = n, a \leq b \leq c, c \leq \sqrt{n} \operatorname{or} c \in \operatorname{Prime}$，则称 $(a, b, c)$ 为 $n$ 的一组合法分解。

存在性证明：假设 $c > \sqrt{n}, c \notin \operatorname{Prime}$，那么显然 $c$ 有至少一个质因数 $\leq \sqrt{n}$，则可以继续分解直到该分解合法。
#### 预处理
考虑对于任意满足 $1 \leq x \leq n$ 的正整数 $x$ 构造合法分解。

1. $x = 1$

显然可以构造 $(1, 1, 1)$。

2. $x \in \operatorname{Prime}$

显然可以构造 $(1, 1, x)$。

3. $x$ 为合数

考虑筛出 $y = \operatorname{lpf}(x)$，找到 $z = \frac{x}{y}$ 的一组合法分解 $(p, q, r)$，则 $x$ 的合法分解即为 $(py, q, r)$ 的升序排列。

证明：显然有 $p \leq \sqrt[3]{z}$。

1. 当 $y \leq \sqrt[4]{x}$

显然有 $py \leq \sqrt{x}$。

2. 当 $y > \sqrt[4]{x}$

- $p = 1$：显然成立。

- $p > 1$：此时 $x \notin \operatorname{Prime}$，则 $pqry > (\sqrt[4]{x})^4 = x$，与 $pqry = x$ 矛盾，故不存在此情况。
#### 计算
对于 $\gcd(a, b)$，分别将 $a$ 的合法分解中的 $x_1, x_2, x_3$ 带入，求出 $\gcd(b, x_1), \gcd(\frac{b}{\gcd(b, x_1)}, x_2), \gcd(\frac{b}{\gcd(b, x_1) \gcd(\frac{b}{\gcd(b, x_1)}, x_2)}, x_3)$ 并相乘即可。

这里讲一下这 $3$ 个 $\gcd$ 的求法。

1. 当 $x_i \leq \sqrt{n}$

考虑手动递归一层欧几里得算法，得 $\gcd(x_i, b \bmod x_i)$。由于 $x_i \leq \sqrt{n}$，前后两个参数都 $\leq \sqrt{n}$，所以可以考虑预处理出一张 $\sqrt{n} \times \sqrt{n}$ 的 $\gcd$ 的表。

2. 当 $x_i > \sqrt{n} \operatorname{and} b \bmod x_i = 0$

显然答案为 $x_i$。

3. 当 $x_i > \sqrt{n} \operatorname{and} b \bmod x_i \neq 0$

显然答案为 $1$。

在这些操作结束后将 $b$ 除以求出的 $\gcd$。
#### 时间复杂度
显然，时间复杂度为 $O(n) - O(1)$。
### 例题
1. [P5435 基于值域预处理的快速 GCD](https://www.luogu.com.cn/problem/P5435)

套一个板子再照着题目说的式子算就可以了。

注意计算 $i^j$ 的部分时不要直接快速幂，而是要在循环里递增处理幂次。

时间复杂度为 $O(n^2 + N)$。

代码：
```cpp
#include <stdio.h>

typedef long long ll;

const int N = 1e6 + 7, M = 3, K = 1e3 + 7, P = 5e3 + 7, mod = 998244353;
int cnt = 0;
int prime[N], decompound[N][M + 1], pre_gcd[K][K], a[P], b[P];
bool p[N];

inline void init(){
    int cnt = 0;
    p[0] = p[1] = true;
    decompound[1][1] = decompound[1][2] = decompound[1][3] = 1;
    for (register int i = 2; i < N; i++){
        if (!p[i]){
            prime[++cnt] = i;
            decompound[i][1] = decompound[i][2] = 1;
            decompound[i][3] = i;
        }
        for (register int j = 1; j <= cnt && i * prime[j] < N; j++){
            int t1 = i * prime[j], t2 = decompound[i][1] * prime[j];
            p[t1] = true;
            if (t2 < decompound[i][2]){
                decompound[t1][1] = t2;
                decompound[t1][2] = decompound[i][2];
                decompound[t1][3] = decompound[i][3];
            } else if (t2 < decompound[i][3]){
                decompound[t1][1] = decompound[i][2];
                decompound[t1][2] = t2;
                decompound[t1][3] = decompound[i][3];
            } else {
                decompound[t1][1] = decompound[i][2];
                decompound[t1][2] = decompound[i][3];
                decompound[t1][3] = t2;
            }
            if (i % prime[j] == 0) break;
        }
    }
    for (register int i = 1; i < K; i++){
        pre_gcd[0][i] = pre_gcd[i][0] = i;
        for (register int j = 1; j <= i; j++){
            pre_gcd[i][j] = pre_gcd[j][i] = pre_gcd[j][i % j];
        }
    }
}

inline int quick_gcd(int a, int b){
    if (a < K && b < K) return pre_gcd[a][b];
    int ans = 1;
    for (register int i = 1; i <= M; i++){
        int d;
        if (decompound[a][i] < K){
            d = pre_gcd[decompound[a][i]][b % decompound[a][i]];
        } else if (b % decompound[a][i] == 0){
            d = decompound[a][i];
        } else {
            d = 1;
        }
        b /= d;
        ans *= d;
    }
    return ans;
}

int main(){
    int n;
    scanf("%d", &n);
    init();
    for (register int i = 1; i <= n; i++){
        scanf("%d", &a[i]);
    }
    for (register int i = 1; i <= n; i++){
        scanf("%d", &b[i]);
    }
    for (register int i = 1; i <= n; i++){
        ll j = i, ans = 0;
        for (register int k = 1; k <= n; j = j * i % mod, k++){
            ans = (ans + j * quick_gcd(a[i], b[k]) % mod) % mod;
        }
        printf("%lld\n", ans);
    }
    return 0;
}
```

---

## 作者：Kinesis (赞：6)

本来是想在**クトリ**大佬题解评论下指正错误的，，但字太多了，分段很难看（

本文作为**クトリ**的题解补充、、

整体思路基本按照大佬的博文学习，能想到三个因子代表一个数的思路真的%%%

但**分解**那一块证明的不严谨，比如$49 = 1 * 7 * 7$,由最小质因子$p_0 = 7$和非互异性集合$\{1,1,7\}$递推而来，而$p_0$显然大于$n^{\frac{1}{4}}$。

下面对分解所证明的$ap_0$重新定义：

任何数$n$可以由最小质因子$p_0$与$\frac{n}{p_0}$的三个升序因子$\{a,b,c\}$的组合$\{ap_0,b,c\}$所构成，且$ap_0\leq \sqrt{n}\ or\ ap$是素数。

证明：当$n$是质数时显然成立：$[n=p_0]+[\{1,1,1\}] = \{1,1,p_0\}$,对应的$ap_0$为素数、、

当$n$为合数，最小素因子必满足$p_0 \leq \sqrt{n}$。给$n$的最小素因子限定上界$p_0\leq n^{\frac{1}{4}}$,带入$a\leq{\frac{n}{p_0}}^{\frac{1}{3}}$，解得$ap_0\leq n^{\frac{1}{2}}$、、若$p_0 > n^{\frac{1}{4}}$，对$\frac{n}{p_0}$进行讨论：

当$\frac{n}{p_0}$是质数时，三个因子必是$\{1,1,\frac{n}{p}\},$此时$a = 1,ap \leq \sqrt{n}$；

当$\frac{n}{p_0}$的形式为$p_1^2\ or\ p_1*p_2,p_0\leq p_1,p_0\leq p_2,$三个因子为$\{1,p_1,p_1\}\ or\ \{1,p_1,p_2\},a = 1,ap_0\leq \sqrt{n}$；

否则，$\frac{n}{p_0}$三个因子$\{a,b,c\}$必均$\geq p_0$，由于$n = p_0 * a * b * c > n$，此时便不存在$p_0>n^{\frac{1}{4}}$，即不存在当$p_0>n^{\frac{1}{4}}$时，存在$\frac{n}{p_0} = a*b*c$使$n = p_0 * a * b *c$成立的等式。

综上，$p_0\leq n^{\frac{1}{4}}\ or\ p_0>n^{\frac{1}{4}}$都是存在的，但$ap\leq \sqrt{n}\ or\ ap $是素数均成立。另外在这也说一下自己学这位大佬的一些想法当做补充，证明**分解**的必要性在于$ap$不是素数则必然是合数，若$ap>\sqrt{n}$，则由**分解**递推得来的三个因子不符合定理1，即我们希望由递推得到的就是正好满足引理1而不需额外操作。具体见**クトリ**的题解代码、、

---

## 作者：altgo (赞：5)

## 前言

见 [这里](https://www.luogu.com.cn/blog/48311/solution-p5435)。

## 内容

做了一点微末的拓展。

从上文得知，我们有定理：

存在分解 $n$ 的方法使得 $n=abc,a\le\sqrt n,b\le\sqrt n$ 且 $c\in \text{Prime}\ \text{or}\ c\le\sqrt n$。

证明不再赘述。

接下来将给出更加一般化的形式：存在分解 $n$ 的方法 $b_1b_2...b_k$ 使得 $\forall 1\le i\le k,b_i\le n^{1/m}\ \text{or}\ b_i\in\text{Prime}$。

将指出 $m$ 与 $k$ 较为宽松的关系。（其实就是把 2 换成了未知数，做了一点计算而已）

令 $b_1\le b_2\le...\le b_k$。

我们采用类似的构造方法，考虑拿出 $p=\text{minp}(n)$，那么如果其可以直接乘在 $n/p$ 表示中的 $b_1$ 中，则应当满足如下不等式：

$$
(\frac{n}{p})^{1/k}p\le n^{1/m}

$$

即
$$
p\le n^{\frac{k-m}{m(k-1)}}
$$

令右式值$=C$。

那么，我们希望当 $p>C$ 的时候，可以得出 $b_1=1$ 的结论；也即 $C^{k+1}>n$。

继续列出不等式：

$$
n^{\frac{(k-m)(k+1)}{m(k-1)}}\ge n
$$

得到

$$
(k-m)(k+1)\ge m(k-1)
$$

最终可以得到 $k\ge 2m-1$，多么简洁美妙的不等式！

比如说，我们希望得到一个 $V^{1/3}$ 的预处理，那么我们就要至少把每个数字分解成 $3* 2-1=5$ 个数字的乘积。

不过一般来说值域都不会很大，所以可能如果是要预处理 $10^{18}$ 的话，就需要达到 $V^{1/5}$，也就是 $9$ 个数字，这个速度或许会比 $\text{bin gcd}$ [还要慢](https://www.luogu.com.cn/discuss/442855)。。。

不过也是有一定的价值的，至少我估计在 $m=3$ 的时候还是很优秀的。

那么每次计算两个数的 $\gcd$ 都是 $O(m)$ 的。

如果要计算复杂度的话，大概是 $O(V^{2/m}+mn^2)$，$m$ 是自取的一个数。

---

## 作者：Untitled_unrevised (赞：4)

概述：本文将以 [P5435 基于值域预处理的快速 GCD](https://www.luogu.com.cn/problem/P5435) 为例，介绍使用线性筛预处理所有数的素因子，然后计算最大公因数的算法。

## 题意简述

给定 $n$ 个正整数 $\langle a_n \rangle$ 和 $n$ 个正整数 $\langle b_n \rangle$，对所有的 $i, j$ 计算 $\gcd(a_i, b_j)$。

其中 $1 \le a_i, b_j \le W = 10^6$，$n \le 5,000$，使用 $O(n^2 \log W)$ 的做法不好通过此题。

## 分解素因数计算 gcd

使用分解素因数计算 $\gcd(a, b)$ 的方法大致为如下几步：

1. 预处理所有数的素因子分解；
2. 从小到大枚举素因子，将两数共有的素因子并入结果。

接下来逐一解释每一步的实现方法。

### 存储素因子分解

根据算术基本定理，任何正整数 $n$ 都有如下的唯一分解形式：

$$
n = p_1^{b_1}p_2^{b_2}\dots p_k^{b_k}
$$

其中 $p_1 \lt p_2 \lt \dots \lt p_k$ 皆为素数，$b_i \in \N^+$ 为相应的指数。

朴素存储方法为记录所有二元组 $(p_i, b_i)$，但是且不说时间上过不过得去，空间上就已经爆了（本题空间限制 32 MB）。

更好的存储方法为只记录 $n$ 的最小素因子 $\operatorname{lpf}(n) = p_1$ 和下一个数 $\operatorname{pa}(n) = \frac{n}{p_1^{b_1}}$，此时就可以类似链表那样存储所有数的素因子分解并节省空间。

此时所有的 $n$ 与有向边 $n \to \operatorname{pa}(n)$ 形成如下的树形结构：

![](https://cdn.luogu.com.cn/upload/image_hosting/pbfoac24.png)

并且根据 $\operatorname{lpf}$ 的定义可知，所有树上路径 $u \to \dots \to v$ 的 $\operatorname{lpf}$ 单调递增。

现在考虑如何使用线性筛计算所有的 $\operatorname{lpf}(n)$ 和 $\operatorname{pa}(n)$。在以 $n$ 为当前节点，从小到大枚举素数 $p$ 的过程中：

- 若 $p \nmid n$，由于 $p$ 是从小到大枚举的，因此 $\operatorname{lpf}(n) \gt p$（否则更小的素数会被提前枚举到并进入下一情况），所以 $\operatorname{lpf}(np) = p$，$\operatorname{pa}(np) = n$；
- 否则 $p \mid n$，此时有 $\operatorname{lpf}(n) \ge p$，因此 $\operatorname{lpf}(np) = \operatorname{lpf}(n)$，$\operatorname{pa}(np) = \operatorname{pa}(n)$；由于到这一步线性筛就会终止继续对 $n$ 伸展节点，此时必有 $\operatorname{lpf}(n) = p$，因此也可以直接令 $\operatorname{lpf}(np) = p$。

最后特别的，$\operatorname{lpf}(p) = p$，$\operatorname{pa}(p) = 1$。

综上，可以在 $O(W)$ 的时间计算每个数 $n$ 的 $\operatorname{lpf}(n)$ 和 $\operatorname{pa}(n)$。

```
#include <algorithm>
#include <vector>

using u32 = unsigned int;
using std::vector;

constexpr u32 W = 1'000'000;

u32 lpf[W + 1] = {}, pa[W + 1] = {};
vector<u32> primes;
bool vis[W + 1] = {};

void sieve() {

	for(u32 n = 2; n <= W; ++n) {
		// n 是素数
		if(!vis[n]) {
			primes.emplace_back(n);
			lpf[n] = n;
			pa[n] = 1;
		}
		// 枚举已知的素数 p
		for(u32 p : primes) {
			
			// 超出值域范围
			if(n * p > W) break;

			// 筛掉 n * p
			vis[n * p] = true;

			// 若 p | n
			if(n % p == 0) {
				lpf[n * p] = lpf[n];
				pa[n * p] = pa[n];
				break;
			}
			else {
				lpf[n * p] = p;
				pa[n * p] = n;
			}
		}
	}
}
```

### 并入共有的素因子

从小到大枚举 $a,b$ 的素因子 $\operatorname{lpf}(a)$ 和 $\operatorname{lpf}(b)$，如果存在共有的素因子，则将对应的素因子的幂次 $\min\Big(\frac{a}{\operatorname{pa}(a)}, \frac{b}{\operatorname{pa}(b)}\Big)$ 并入答案。

枚举的同时将 $a, b$ 除去当前最小的素因子，方式为：

- 若 $\operatorname{lpf}(a) \lt \operatorname{lpf}(b)$，则令 $a \to \operatorname{pa}(a)$；
- 若 $\operatorname{lpf}(a) \gt \operatorname{lpf}(b)$，则令 $b \to \operatorname{pa}(b)$；
- 若 $\operatorname{lpf}(a) = \operatorname{lpf}(b)$，则同时令 $a \to \operatorname{pa}(a)$ 和 $b \to \operatorname{pa}(b)$。

```cpp
u32 gcd(u32 a, u32 b) {
	u32 res = 1;
	while(a != 1 && b != 1) {
		if(lpf[a] == lpf[b]) {
			res *= std::min(a / pa[a], b / pa[b]);
			a = pa[a];
			b = pa[b];
		}
		else
			(lpf[a] < lpf[b]) ? (a = pa[a]) : (b = pa[b]);
	}
	return res;
}
```

这一步的时间复杂度取决于本质不同的素因子个数 $\omega(a) + \omega(b)$，期望为 $O(\log\log W)$ 最恶劣为 $O\Big(\frac{\log W}{\log\log W}\Big)$。关于如何卡这一算法有许多特别的想法，接下来分析其中一些：

1. 将素数交错乘进 $a, b$ 中，比如令

$$
\begin{aligned}
a &= 2 \times 3 \times 5 \times 7  \times 11 \times 13 \times 29 = 870,870 \\
b &= 17 \times 19 \times 23 \times 31 = 230,299
\end{aligned}
$$

此时循环的迭代次数达到了极限 $10$ 次，我本机测出来在 `1.8s` 左右。如果所有数据都是如上这样比较极端的，没做其它常数优化的代码可能受制于评测机性能。

2. 素数的积与一个大素数，比如令

$$
\begin{aligned}
a &= 2 \times 3 \times 5 \times 7 \times 11 \times 13 \times 17 = 510,510 \\
b &= 999,983
\end{aligned}
$$

此时循环迭代的次数最大为 $7$（就是 $a$ 的不同素因子个数），我本机测出来在 `1.3s` 左右。如果所有数据都是如上这样比较极端的，没做其它常数优化的代码可能受制于评测机性能。

3. 素数的积复制一份，比如令

$$
\begin{aligned}
a &= 2 \times 3 \times 5 \times 7 \times 11 \times 13 \times 17 = 510,510 \\
b &= 2 \times 3 \times 5 \times 7 \times 11 \times 13 \times 17 = 510,510
\end{aligned}
$$

这里主要是盯着整除运算所需的大常数卡的，我本机测出来在 `1.6s` 左右。如果所有数据都是如上这样比较极端的，没做其它常数优化的代码可能受制于评测机性能。

---

综上得到了期望 $O(W + n^2\log\log W)$ 最恶劣 $O\Big(W + \frac{n^2\log W}{\log\log W}\Big)$ 的算法，诚然还不是渐进最优的算法。但因其做法极其简单且常数较小，因此甚至拿下了最优解第一页，记录见[此处](https://www.luogu.com.cn/record/173166499)。

---

## 作者：KobeBeanBryantCox (赞：3)

# P5435 基于值域预处理的快速 GCD 题解

[题目传送门](https://www.luogu.com.cn/problem/P5435)。

现有题解在讲什么啊？大部分没有把底层逻辑讲清楚，更有甚者还是卡常 AC。~~（当然，并不是指全部题解。）~~

本题解讲述所有常用的求 gcd 的方法（不常用的不讲），且有效率对比。

--------------

## 题意

求多次 gcd。

-------------

## 1. 朴素 gcd

前置知识：辗转相除法。

```cpp
int gcd(int a,int b){return !b?a:gcd(b,a%b);}
```

复杂度 $O(\log\min\{a,b\})$，能拿 $50$ 分，[记录](https://www.luogu.com.cn/record/206023033)。

事实上，algorithm 库中的 `__gcd()` 也是采用的辗转相除法，其在 VSCode 中的 stl_algo.h 文件下的源码如下：

```cpp
template<typename _EuclideanRingElement>
  _GLIBCXX20_CONSTEXPR
  _EuclideanRingElement
  __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
  {
    while (__n != 0)
{
  _EuclideanRingElement __t = __m % __n;
  __m = __n;
  __n = __t;
}
    return __m;
  }
```

区别是其采用循环处理。也能拿 $50$ 分，[记录](https://www.luogu.com.cn/record/206023147)。

---------------

## 2. Binary GCD / Stein 算法

这两个名字是指同一个东西。

前置知识：基本位运算，辗转相减法。

定理：

$$\gcd(a,b)=\left\{\begin{matrix}
\gcd(\dfrac a 2,b)  & [a\bmod 2=0][b\bmod2=1]\\
\gcd(a,\dfrac b 2)  & [a\bmod 2=1][b\bmod2=0]\\
2\times\gcd(\dfrac a 2,\dfrac b 2)  & [a\bmod 2=0][b\bmod2=0]\\
\gcd(|a-b|,\min(a,b))  & [a\bmod 2=1][b\bmod2=1]
\end{matrix}\right.$$

考虑证明：

- 先证明第三个。**事实上 $\gcd(ka,kb)=k\times\gcd(a,b)$ 也是对的**，考虑证明。

  - 令 $d=\gcd(a,b)$，则 $a=x_1d$，$b=x_2d$，则有 $\gcd(x_1,x_2)=1$（否则 $d$ 就不是**最大的**公因数了）。

  - 则 $\gcd(ka,kb)=\gcd(kdx_1,kdx_2)=kd=k\times \gcd(a,b)$。第三个证毕。

- 证明前两个，这里讨论第一个，第二个同理。

  - 令 $d=\gcd(a,b)$ ，则 $a=2k_1d$，$b=k_2d$，所以 $\gcd(2k_1,k_2)=1$，则有 $\gcd(k_1,k_2)=1$。

  - 所以 $\gcd(dk_1,dk_2)=d$，即 $\gcd(\dfrac a 2,b)=d=\gcd(a,b)$。

- 证明最后一个。事实上 $a,b$ 都是奇数的限制是不需要的。

  - 根据辗转相减法，若 $a>b$ 有 $\gcd(a,b)=\gcd(a-b,b)$，否则 $\gcd(a,b)=\gcd(b,a)=\gcd(b-a,a)$。所以证毕。

然后注意到第三个肯定只能在刚开始的时候操作，证明显然：根据表达式的奇偶性，易得，但凡出现了“$a,b$ 都是偶数”不成立，那么之后永远不可能成立。

所以我们在刚开始的时候除以足够多的 $2$，后面就不需要管第三个了。

于是我们得到了这样的代码：

```cpp
int gcd(int a,int b)
{
	int x=__builtin_ctz(a),y=__builtin_ctz(b);
	b>>=y;int z=min(x,y);
	while(a)
	{
		a>>=x;int tmp=b-a;
		b=min(a,b),a=abs(tmp),x=__builtin_ctz(tmp);
	}
	return b<<z;
}
```

其中 `__builtin_ctz` 功能是找出数字二进制位末尾 $0$ 的个数，理论时间复杂度是 $O(\log n)$，总的时间复杂度是 $O(\log\min\{a,b\})$。

值得关注的是，`__builtin_ctz` 的底层逻辑主要依赖于处理器的硬件指令，而不是用代码实现，相当于处理器在配置的时候已经内置了此功能，因此找不到其源码，但使用它可以充分地利用硬件特性提高计算效率。

这样子是能卡过的，由于数据太水，甚至跑得比正解还快，**但是是可以卡的，具体看文章末尾。**[记录](https://www.luogu.com.cn/record/206023188)。

事实上，c++17 中新增的 `gcd()` 函数也是用 Binary GCD 实现的，以下是 VSCode 中 numeric 库中的 `gcd()` 源码：

```cpp
template<typename _Mn, typename _Nn>
  constexpr common_type_t<_Mn, _Nn>
  gcd(_Mn __m, _Nn __n) noexcept
  {
    static_assert(is_integral_v<_Mn> && is_integral_v<_Nn>,
      "std::gcd arguments must be integers");
    static_assert(_Mn(2) == 2 && _Nn(2) == 2,
      "std::gcd arguments must not be bool");
    using _Ct = common_type_t<_Mn, _Nn>;
    const _Ct __m2 = __detail::__abs_r<_Ct>(__m);
    const _Ct __n2 = __detail::__abs_r<_Ct>(__n);
    return __detail::__gcd<make_unsigned_t<_Ct>>(__m2, __n2);
  }
```

可以发现它取绝对值后调用了 numeric 中的 `__gcd()`，再找到其源码：

```cpp
template<typename _Tp>
  constexpr _Tp
  __gcd(_Tp __m, _Tp __n)
  {
    static_assert(is_unsigned<_Tp>::value, "type must be unsigned");

    if (__m == 0)
return __n;
    if (__n == 0)
return __m;

    const int __i = std::__countr_zero(__m);
    __m >>= __i;
    const int __j = std::__countr_zero(__n);
    __n >>= __j;
    const int __k = __i < __j ? __i : __j; // min(i, j)

    while (true)
{
  if (__m > __n)
    {
      _Tp __tmp = __m;
      __m = __n;
      __n = __tmp;
    }

  __n -= __m;

  if (__n == 0)
    return __m << __k;

  __n >>= std::__countr_zero(__n);
}
  }
```

可以发现它用的就是 Binary GCD。注意到有一个 `std::__countr_zero()` 函数，我们翻到源码，在文件 bit 下：

```cpp
template<typename _Tp>
  constexpr int
  __countr_zero(_Tp __x) noexcept
  {
    using __gnu_cxx::__int_traits;
    constexpr auto _Nd = __int_traits<_Tp>::__digits;

    if (__x == 0)
      return _Nd;

    constexpr auto _Nd_ull = __int_traits<unsigned long long>::__digits;
    constexpr auto _Nd_ul = __int_traits<unsigned long>::__digits;
    constexpr auto _Nd_u = __int_traits<unsigned>::__digits;

    if _GLIBCXX17_CONSTEXPR (_Nd <= _Nd_u)
return __builtin_ctz(__x);
    else if _GLIBCXX17_CONSTEXPR (_Nd <= _Nd_ul)
return __builtin_ctzl(__x);
    else if _GLIBCXX17_CONSTEXPR (_Nd <= _Nd_ull)
return __builtin_ctzll(__x);
    else // (_Nd > _Nd_ull)
{
  static_assert(_Nd <= (2 * _Nd_ull),
    "Maximum supported integer size is 128-bit");

  constexpr auto __max_ull = __int_traits<unsigned long long>::__max;
  unsigned long long __low = __x & __max_ull;
  if (__low != 0)
    return __builtin_ctzll(__low);
  unsigned long long __high = __x >> _Nd_ull;
  return __builtin_ctzll(__high) + _Nd_ull;
}
  }
```

注意到它调用的竟然也是 `__builtin_ctz` 和其 long long 形式。

用这个只能拿 $70$ 分，估计是因为多做了一些判断导致的。[记录](https://www.luogu.com.cn/record/206023081)。

---------------

## 3. 基于值域 $O(V)$ 预处理的快速 $O(1)$ GCD

这才是正解！！！

前置知识：集合，指数函数，线性筛。

参考了[这一篇](https://www.luogu.com.cn/article/v7ewb6u9)题解，并对其补充说明，若表述相同请见谅，如有侵权请联系删除相关表述。

### 一些定义

1. 定义所有质数集合为 $\mathbb P$。
2. 定义集合 $\{a,b,c\}$ 是 $n$ 的分解，当且仅当 $a\times b\times c=n$（注意，这个集合只有三个元素，下同）。
3. 定义集合 $\{a,b,c\}$ 是 $n$ 的合法分解，当且仅当集合是其分解且满足 $a,b,c\le\sqrt n$ 或 $a,b,c\in\mathbb P$ 二者之一（这里我们强行定义 $1\in\mathbb P$）。

------------

### 原理

#### 定理 1：

> 值域中的所有 $x$ 均有其合法分解。

- 考虑证明：不妨设 $a\le b\le c\le x$。若 $c\not\in\mathbb P$ 且 $\sqrt x<c\le x$，则 $c$ 可以分解为 $\{d,e\}$（$d\le e$），此时显然有 $d\le\sqrt x$。而 $a\times b=\dfrac x c\le\sqrt x$，此时存在 $x$ 的分解 $\{d,a\times b,e\}$，此时继续上述分解 $e$ 直到 $e\not\in\mathbb P$ 且 $\sqrt x<e\le x$ 不成立，可以发现一定存在不成立的时刻。

#### 定理 2：

> 将 $x$ 分解为 $\{a,b,c\}$，令 $a_0=\gcd(a,y),a_1=\gcd(b,\dfrac y{a_0}),a_2=\gcd(c,\dfrac y{a_0a_1})$，则有 $\gcd(x,y)=a_0\times a_1\times a_2$。

- 考虑证明：前面证明过了 $\gcd(ka,kb)=k\times\gcd(a,b)$，即 $\gcd(p,q)=r\times gcd(\dfrac p r,\dfrac q r)[r|p][r|q]$，分别代入 $\left\{\begin{matrix}
p_1=a\times b\times c,q_1=y,r_1=\gcd(a,q1)\\
p_2=b\times c,q_2=\dfrac{q_1}{r_1},r_2=\gcd(b,q_2)\\
p_3=c,q_3=\dfrac{q_2}{r_2},r_3=\gcd(c,q_3)
\end{matrix}\right.$ 即可证明。

---------------

### 实现

#### 1. 分解

上结论：对于 $x\ge 2$，找到 $x$ 的最小质因子 $p$ 以及 $\dfrac x p$ 的合法分解 $\{a,b,c\}$，不妨设 $a\le b\le c$，则 $x$ 的合法分解为 $\{a\times p,b,c\}$。

考虑证明 $a\times p\le \sqrt x$ 或 $a\times p\in\mathbb P$：

1. $x\in\mathbb P$，成立，分解为 $\{1,1,x\}$。
2. 当 $p\le x^{\frac 1 4}$，由于 $a\le b\le c$，则有 $a\le(\frac x p)^{\frac 1 3}$，现在要求出 $a\times p$ 的最大值。

   - $p\times a\le p\times (\frac x p)^{\frac 1 3}=p^{\frac 2 3}x^{\frac 1 3}$。
   - 等价于求函数 $f(p)=p^{\frac 2 3}x^{\frac 1 3}$ 最大值。
   - $x>0\Rightarrow x^{\frac 1 3}>0$，此时关于 $p$ 的指数函数的指数为 $\dfrac 2 3>0$，故 $f(p)$ 在定义域 $(0,x^{\frac 1 4}]$ 上单调递增。
   - 所以取 $p=x^{\frac 1 4}$ 能取到最大，最大为 $\sqrt x$。
3. 考虑 $x^{\frac 1 4}<p\le \sqrt x$ 的情况：

   1. $a=1$，显然有 $a\times p=p\le\sqrt x$。
   2. $a\not=1$，由于 $x$ 不是质数，$\dfrac x p$ 的最小质因子 $q$ 为 $x$ 的非严格第二小质因子（不是最小是因为已经被 $p$ 取过了），因为 $a\le b\le c$ 且 $a\not=1$，故 $a,b,c$ 为 $\dfrac x p$ 的非 $1$ 的因子，此时满足 $p\le q\le a\le b\le c$（因为 $q$ 是 $\dfrac x p$ 的最小质因子而 $a$ 是 $\dfrac x p$ 的因子且 $a\not=1$），所以有 $p\times a\times b\times c\ge p^4>(x^{\frac 1 4})^4=x$，不满足其是分解，矛盾，所以没有这种情况。

所以可以用线性筛递推出来。

代码：

```cpp
// fac 表示一个分解，isnp 表示是不是合数，p 是质数集，pre 是预处理的 gcd，V 和 v 都是值域
void init(const int v=V)
{
  fac[1]={1,1,1};
  for(int i=2;i<=v;i++)
  {
    if(!isnp[i])fac[i]={i,1,1},p[tot++]=i;
    for(int j=0;j<tot&&i*p[j]<=v;j++)
    {
      int t=i*p[j];isnp[t]=true;
      fac[t]=fac[i],*min_element(fac[t].begin(),fac[t].end())*=p[j];
      if(i%p[j]==0)break;
    }
  }
  TT=sqrt(v);
  for(int i=1;i<=TT;i++)pre[0][i]=pre[i][0]=i;
  for(int i=1;i<=TT;i++)
    for(int j=1;j<=i;j++)pre[i][j]=pre[j][i]=pre[j][i%j];
}
```

#### 2. 查询

不讲，直接看代码：

```cpp
int g(int x,int y){int t=x%y;if(t==0)return y;return y>TT?1:pre[y][t];}
int gcd(int a,int b)
{
  if(a==1||b==1)return 1;
  int a0=g(a,fac[b][0]),a1=g(a/=a0,fac[b][1]),a2=g(a/=a1,fac[b][2]);
  return a0*a1*a2;
}
```

所以就做完了，总代码：

```cpp
namespace GCD
{
	const int V=1e6,T=1e3;
	int pre[T+5][T+5];array<int,3>fac[V+5];
	bool isnp[V+5];int p[V+5],tot=0;
	int TT;
	void init(const int v=V)
	{
		fac[1]={1,1,1};
		for(int i=2;i<=v;i++)
		{
			if(!isnp[i])fac[i]={i,1,1},p[tot++]=i;
			for(int j=0;j<tot&&i*p[j]<=v;j++)
			{
				int t=i*p[j];isnp[t]=true;
				fac[t]=fac[i],*min_element(fac[t].begin(),fac[t].end())*=p[j];
				if(i%p[j]==0)break;
			}
		}
		TT=sqrt(v);
		for(int i=1;i<=TT;i++)pre[0][i]=pre[i][0]=i;
		for(int i=1;i<=TT;i++)
			for(int j=1;j<=i;j++)pre[i][j]=pre[j][i]=pre[j][i%j];
	}
	int g(int x,int y){int t=x%y;if(t==0)return y;return y>TT?1:pre[y][t];}
	int gcd(int a,int b)
	{
		if(a==1||b==1)return 1;
		int a0=g(a,fac[b][0]),a1=g(a/=a0,fac[b][1]),a2=g(a/=a1,fac[b][2]);
		return a0*a1*a2;
	}
}
```

注意不要全开 long long，本题中会 MLE。[记录](https://www.luogu.com.cn/record/206029786)。

---------------

以下的代码均在 c++17 加入快读快输，且除了 gcd 的求法之外的其余部分相同的情况下测试。



|方法|理论时间复杂度|实际效率|
|:-:|:-:|:-:|
|基于值域预处理的快速 GCD|$O(V+n^2)$|5.05s|
|手写 binary gcd（也叫 Stein 算法）|$O(n^2\log V)$|4.26s|
|c++17 中 numeric 的 `gcd()`|$O(n^2\log V)$|6.75s TLE $70$pts|
|algorithm 中的 `__gcd()`|$O(n^2\log V)$|9.07s TLE $50$pts|
|手写 gcd|$O(n^2\log V)$|9.14s TLE $50$pts|

关于 Binary GCD 比正解快，纯粹是因为数据太水了。

我来给个数据，实测能把 Binary GCD 卡到 1.4s+，而正解还是稳定的 600ms。

生成器：

```cpp
#include<bits/stdc++.h>
#define Code using
#define by namespace
#define wjb std
Code by wjb;
int main()
{
	freopen("in.txt","w",stdout);
	srand(time(0));
	int n=5000;
	cout<<n<<"\n";
	for(int i=1;i<=n;i++)cout<<(1<<(rand()%10+10))+rand()%2-1<<" ";
	cout<<"\n";
	for(int i=1;i<=n;i++)cout<<(1<<(rand()%10+10))+rand()%2-1<<" ";
	cout<<"\n";
	return 0;
}
```

------------------

## 后记

~~可恶的 $\sout{\LaTeX}$ 好难打啊啊啊！~~

若讲述有误，请私信或评论指出。

---

## 作者：Milthm (赞：3)

## P5435 题解

### 前置知识

- 最小公倍数

- 二进制

- 卡常

### 题目解法

一看题目名，什么基于值域，什么预处理，蒟蒻都不会。~~蒟蒻只会暴力。~~

那暴力能不能过呢？

事实证明，是可以的，但是需要一些技巧。那么接下来我们来看看怎么暴力优化卡常做掉这道题吧！

#### 一、Binary GCD

普通的 $\gcd$ 肯定会超时，考虑一种新的 $\gcd$，即二进制 $\gcd$（定义和原理在[这](https://www.cnblogs.com/cmy-blog/p/binary-gcd.html)）。那么我们再利用位运算等方式优化一下，就有了：

```cpp
inline int gcd(int a,int b){
    az=__builtin_ctz(a),bz=__builtin_ctz(b),z=az>bz?bz:az;
    b>>=bz;
    while(a){
    	a>>=az;
    	d=b-a;
    	az=__builtin_ctz(d);
    	a<b?b=a:0;
    	a=d<0?-d:d;
	}
	return b<<z;
}
```

这个东西复杂度与普通的 $\gcd$ 相同，但是因为是位运算，所以跑得极快。

#### 二、卡常技巧

读写用 `scanf` 和 `printf` 就够了。

不用开 `long long` 的不要乱开。

开 $O2$ 优化。

然后按照题意模拟就可以啦！

### AC 代码

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n,a[5005],b[5005],mod=998244353;
int az,bz,z,d;
long long ans;//不开 long long 见祖宗
inline int gcd(int a,int b){//二进制 gcd，注意前面加上 inline
    az=__builtin_ctz(a),bz=__builtin_ctz(b),z=az>bz?bz:az;
    b>>=bz;
    while(a){
    	a>>=az;
    	d=b-a;
    	az=__builtin_ctz(d);
    	a<b?b=a:0;
    	a=d<0?-d:d;
	}
	return b<<z;
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;++i)scanf("%d",&a[i]);
	for(int i=1;i<=n;++i)scanf("%d",&b[i]);
	for(int i=1;i<=n;++i){
		ans=0;//多测不清空，直接见祖宗
		long long nn=i;
		for(int j=1;j<=n;++j){
			ans=(ans+nn*gcd(a[i],b[j]))%mod;//边算边取模
			ans%=mod;
			nn=nn*i%mod;
		}
		printf("%lld\n",ans);//输出结果
	}
	
	
	return 0;
}
```








---

## 作者：EmptyAlien (赞：3)

# 思路
我们看到：
$$
1 \le n \le 5000
$$
哇塞，这道题是不是可以 $O(n^2\log n)$ 暴力过呢？

然后我们就只需要亿点点常数优化就行了。

我们就用 $\text {binary gcd}$ 吧。

就是:

$$ \gcd(a,b)=\begin{cases} \gcd(|a-b|,\min(a,b))&(a,b\text{ is odd})\\ \gcd(a/2,b/2)&(a,b\text{ is even})\\ \gcd(a,b/2)&(a\text{ is odd},b\text{ is even})\\ \gcd(a/2,b)&(a\text{ is even},b\text{ is odd}) \end{cases} $$

> 声明：本题解借鉴了一下讨论区大叔的思想。

# 注意事项

不要用辗转相除法，因为模运算常数好大。

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 5005;
const int MOD = 998244353;

char buf[1<<20], *p1 = buf, *p2 = buf;
#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 20, stdin), p1 == p2) ? EOF : *p1++)
template<typename type>
inline void read(type &x) {
    x = 0;
    bool flag(0);
    char ch = getchar();
    while(!isdigit(ch)) {
        flag=ch=='-';
        ch=getchar();
    }
    while(isdigit(ch)) {
        x = (x << 1) + (x << 3) + (ch ^ 48);
        ch=getchar();
    }
    flag ? x = -x : 0;
}
void print(int x) {
    if (x < 0) {
        putchar('-');
        x = -x;
    }
    if (x >= 10) print(x / 10);
    putchar(x % 10 + '0');
}

int gcd(int a, int b) {
    int x = __builtin_ctz(a);
    int y = __builtin_ctz(b);
    b >>= y;
    int z = min(x, y);
    while(a) {
        a >>= x;
        int tmp = b - a;
        b = min(a, b);
        a = abs(tmp);
        x = __builtin_ctz(tmp);
    }
    return b << z;
}
long long a[MAXN], b[MAXN];
int n;
int main() {
    read(n);
    for (int i = 1; i <= n; i++) read(a[i]);
    for (int i = 1; i <= n; i++) read(b[i]);
    for (int i = 1; i <= n; i++) {
        long long ans = 0;
        long long k = 1;
        for (int j = 1; j <= n; j++) {
            k *= i;
            k %= MOD;
            ans += k * gcd(a[i], b[j]);
            ans %= MOD;
        }
        print(ans);
        puts("");
    }
    return 0;
}
```

---

## 作者：Purslane (赞：2)

# Solution

感觉我的科技树还是不够茂盛，最近多学点数学的科技。

如果我们求最大公约数的两数都在值域 $[1,V]$ 内，我们需要在 $O(V)$ 的时间内预处理出 $\forall x_1 , x_2 \le \sqrt V$ 的 $\gcd(x_1,x_2)$ 和另外一个东西，然后查询只需要 $O(1)$ 的时间。

## Lemma

任意一个数 $n$，都可以写成 $a \times b \times c$ 的形式，其中 $a \le b \le c$ 且 $c \le \sqrt n$ 或 $c$ 是个质数。

证明：归纳的，我们尝试用 $n$ 的因子的合法解构造 $n$ 的合法解。当 $n$ 是个质数（或者 $1$）的时候，解 $(1,1,n)$ 一定是合法的。

不然假设 $n$ 的最小质因子为 $p$，假设 $\frac{n}{p}$ 的解为 $\{a,b,c\}(a \le b \le c)$。

我们证明：将 $ap$，$b$，$c$ 从小到大排序后任然是合法的解。其实也就只需要证明 $ap \le \sqrt  n$。

如果 $c \ge \sqrt{\frac{n}{p}}$，它是个质数，那么一定有 $a < \sqrt[4]{\frac{n}{p}}$。再乘上 $p$，要它不大于 $\sqrt n$ 的等价条件是 $p^3 \le n$。

不然就有  $a \le \sqrt[3]{\frac{n}{p}}$，要乘上 $p$ 之后不大于 $\sqrt n$ 的等价条件是 $p^4 \le n$。

我们可以感性理解，若 $n$ 有不少于 $4$ 个质因子（相同的算一个），这两个条件肯定都成立。

假设 $n$ 有 $3$ 个质因子，也就是说 $\frac{n}{p}$ 只有两个，我们记为 $p_1$ 和 $p_2$。那么实际上 $\frac{n}{p}$ 只有唯一的解：$\{1,p_1,p_2\}$。那么 $\{p,p_1,p_2\}$ 无论如何都是 $n$ 正确的解。

如果 $n$ 有两个质因子，也就是 $\frac{n}{p}$ 是个质数。那么 $\{1,p,\frac{n}{p} \}$ 也是合法的解。

这样我们不仅证明了这样的拆分是存在的，还给出了一种用线性筛可以在 $O(V)$ 复杂度内构造解的方法。

好的，如果我们要求 $x$ 和 $y$ 的最大公约数，我们用上面的方法把 $x$ 拆成了 $a \times b \times c$。我们求出 $\gcd(a,y)$，然后让 $y$ 除以这个数（防重复），然后处理 $b$ 和 $c$。

这里的 $\gcd$ 求起来就相当高效。当 $a$ 是质数，直接返回 $y$ 是不是 $a$ 的倍数。否则先辗转相除一次变成 $\gcd(a,y \bmod a)$，然后转化为两个在 $\sqrt n$ 之内数的最大公约数，这是我们已经预处理过了的。

---

## 作者：huangzirui (赞：1)

大致题意：

对于所有的 $0\leq i,j\leq n$ 求 $\text{gcd}(a_i,b_j)$

$n \leq 5000\ \ 1\leq a_i,b_i \leq 10^6$

---

考虑暴力求解。

如果直接使用最朴素的算法的话，时间复杂度在最劣情况是 $O(n^2\ log\ S)$  (其中 $S$ 是值域)， 效率较差，不能通过此题。

于是考虑优化。

由于枚举 $a$ 和 $b$ 种的每个数至少需要 $O(n^2)$ 的复杂度，于是我们考虑优化求 $\text{gcd}$ 部分。

于是考虑如何快速计算 $\text{gcd}(a,b)$ 。

假如提前对 $a,b$ 进行质因数分解，那么我们可以认为复杂度非常小（因为值域小）。

证明：

由算术基本定理，设 

$a = {p_1}^{\alpha1} \cdot {p_2}^{\alpha2} \cdots\ {p_s}^{\alpha s}$

$b = {p_1'}^{\alpha1'} \cdot {p_2'}^{\alpha2'} \cdots\ {p_s'}^{\alpha s'}$

又因为 $2*3*5*7*11*13*17*19=9699690 > 10^6$  

故在值域范围内一个数最多由 $7$ 个数组成。

对每个数预处理，然后可以 $O(49)$ 算出来 $\text{gcd}$

理论复杂度 $O(49\ n^2)$

但是 duliu 出题人造的数据 $n\leq 5000$，会被卡常。

于是再次尝试优化。

发现复杂度过高是因为分解出因数种类过多了，而且没有利用好值域小的性质。于是我们尝试把因数个数控制在一个合适的范围内，比如 $3$ 。

于是我们在思考一番后，可以得到一个优美的算法：

对于求 $\text{gcd}(a,b)$，我们先将 $b$ 分解成 $b_1\cdot b_2\cdot b_3$ 的形式，不妨设 $b_1\leq b_2\leq b_3$ ，然后令 $b_3$ 最小。

这样我们有一个优秀的性质： 如果 $b_3 > \sqrt{b}$，那么 $b_3$ 是个质数。

这个性质很好发现（但是很不好证），如果想学习证明过程可以移步 [クトリ的题解](https://www.luogu.com.cn/blog/chtholly-willem/solution-p5435) ，这里略过。

于是求 $\text{gcd}{(a,b)}$，就相当于求 $\text{gcd}{(a,b_1)}$，然后将 $a$ 除以这个 $\text{gcd}$，然后对 $b_2$ 和 $b_3$ 都这样搞一遍。

然后此处求 $\text{gcd}$ 也有技巧。对于 $b_i \leq \sqrt b$ 可以直接预处理（ $\sqrt b\leq 1000$ 值域相当小），对于 $b_i > \sqrt b$ ， $b_i$ 一定是个质数，可以直接判断。

总复杂度 $O(n^2)$，可以通过此题。

本题略卡常，另外需要许多小技巧。

---
鸣谢：
> 感谢 $\texttt{クトリ}$ 大佬的[题解](https://www.luogu.com.cn/blog/chtholly-willem/solution-p5435)，帮助我学会了 快速 GCD。


```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline int read(){
	char c=getchar();int x=0,f=1;
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return x*f;
}
int i,j,k,n,m;
const int maxn=5010,N=1000000;
int a[maxn],b[maxn],s[maxn][3];
int prime[N+10],is_prime[N+10],num;
void init(){
	for(int i=2;i<=N;i++)is_prime[i]=1;
	for(int i=2;i<=N;i++){
//		cout<<"i="<<i<<' '<<is_prime[i]<<endl;
		if(is_prime[i])prime[++num]=i;
		for(int j=1;j<=num && i*prime[j]<=N;j++){
			is_prime[prime[j]*i]=0;
			if(i%prime[j]==0)break;
		}
	}
}
void make(int now,int num){
	s[now][0]=s[now][1]=s[now][2]=1;
	int T=0,nn=sqrt(b[now]);
	for(int i=1;i<=num;i++){
		if(num<prime[i]*prime[i])break;
		while(num%prime[i]==0){
			if(s[now][T]*prime[i]>nn)++T;
			s[now][T]*=prime[i];
			num/=prime[i];
		}
	}
	if(s[now][T]*num>nn)++T;
	s[now][T]*=num;
	num/=num;
	sort(s[now],s[now]+3);
}
int Gcd,X;
int gcd(int x,int y){
	return y==0?x:gcd(y,x%y);
}
int GCD[1010][1010],B_[maxn];
void Dogcd(int now){
	int B=B_[now];
	for(int i=0;i<=2;i++){
		if(s[now][i]>B){
			if(X%s[now][i]==0)
				X/=s[now][i],Gcd*=s[now][i];
		}else{
//			cout<<s[now][i]<<' '<<X<<endl;
			int tmp=GCD[s[now][i]][X%s[now][i]];
			X/=tmp;Gcd*=tmp;
		}
	} 
}
const ll mod=998244353;
int main(){
	init();
	for(i=0;i<=1000;i++)
		for(j=i;j<=1000;j++)
			GCD[i][j]=GCD[j][i]=gcd(i,j);
	cin>>n;
	for(i=1;i<=n;i++)a[i]=read();
	for(i=1;i<=n;i++)b[i]=read();
	for(i=1;i<=n;i++)make(i,b[i]);
	ll ans=0;
	for(i=1;i<=n;i++)B_[i]=sqrt(b[i]);
	for(i=1;i<=n;i++){
		ans=0;
		ll S=1;
		for(j=1;j<=n;j++){
			S=S*i%mod;
//			cout<<i<<' '<<j<<' '<<a[i]<<' '<<b[j]<<"="<<s[j][0]<<"*"<<s[j][1]<<"*"<<s[j][2]<<endl;
			Gcd=1;X=a[i];
			Dogcd(j);
			ans+=S*Gcd%mod;
		}
		printf("%lld\n",ans%mod);
	}
	return 0;
}
```

---

## 作者：Claire0918 (赞：1)

这题其实可以不用预处理，只需要加快计算最大公因数的速度即可。

首先，我们知道：
$$
\gcd(a, b) = 
\begin{cases}
\gcd(b, a - b) & a \bmod 2 = 1, b \bmod 2 = 1\\
\gcd(\frac{a}{2}, b) & a \bmod 2 = 0, b \bmod 2 = 1\\
\gcd(a, \frac{b}{2}) & a \bmod 2 = 1, b \bmod 2 = 0\\
\gcd(\frac{a}{2}, \frac{b}{2}) \times 2 & a \bmod 2 = 0, b \bmod 2 = 0\\
\end{cases}
$$

于是，我们可以用类似二进制的方法求得最大公因数。

这里介绍一个函数：`__builtin_ctz(a)`，它可以返回 **$a$ 在二进制表示下末尾 $0$ 的数量**。

于是就有以下求最大公因数的代码。

```cpp
typedef unsigned long long ull;

inline ull gcd(ull a, ull b){
    ull az = __builtin_ctz(a), bz = __builtin_ctz(b);
    ull z = min(az, bz);
    b >>= bz;
    while (a){
        a >>= az;
        int diff = a - b;
        az = __builtin_ctz(diff);
        b = min(a, b), a = abs(diff);
    }
    return b << z;
}
```

时间复杂度不会超过 $\mathcal{O}(\log (\max\{a, b\}))$，并且有优化。

其他部分使用普通方法即可，总体复杂度大致为 $\mathcal{O}(n^2 \log a)$。

Code：

```cpp
#include<bits/stdc++.h>
#define mem(a, v) memset(a, v, sizeof(a));

using namespace std;

typedef unsigned long long ull;

const int maxn = 5000 + 10, mod = 998244353;

int n;
int a[maxn], b[maxn];

inline ull gcd(ull a, ull b){
    ull az = __builtin_ctz(a), bz = __builtin_ctz(b);
    ull z = min(az, bz);
    b >>= bz;
    while (a){
        a >>= az;
        int diff = a - b;
        az = __builtin_ctz(diff);
        b = min(a, b), a = abs(diff);
    }
    return b << z;
}

int main(){
    scanf("%d", &n);
    for (int i = 1; i <= n; i++){
        scanf("%d", &a[i]);
    }
    for (int i = 1; i <= n; i++){
        scanf("%d", &b[i]);
    }
    for (int i = 1; i <= n; i++){
        ull res = 0, now = i;
        for (int j = 1; j <= n; j++){
            res = (res + (now * gcd(a[i], b[j]) % mod)) % mod;
            now = now * i % mod;
        }
        printf("%llu\n", res);
    }

return 0;
}
```

---

## 作者：snail2956 (赞：0)

[题目链接](https://www.luogu.com.cn/problem/P5435)

## updated

**2022.10.16** ： 修正了几处笔误并取消了博客隐藏  
**2022.10.21** ： 统一了 $\operatorname{Prime}$ 的写法

## 思路

-  基于值域预处理的快速 $\gcd$

**思想**：  
将每个 $x$ 分解成 $a\times b\times c$ 的形式，满足 $a,b,c\leq\sqrt{x}$ 或 $\in \operatorname{Prime}$，且 $a\leq b\leq c$。  
对于每次询问 $\gcd(x,y)$，分别考虑 $a$，$b$，$c$ 对答案的贡献。$a$ 对答案的贡献为 $\gcd(a,y)$，再将 $y$ 除以 $\gcd(a,y)$（不能重复计算），再分别对 $b$，$c$ 干同样的事，三个贡献相乘即为 $\gcd(x,y)$。 

**对于分解的证明**：假设 $c > \sqrt{x}$，$c \notin \operatorname{Prime}$，那么显然 $c$ 有至少一个质因数 $\leq \sqrt{x}$，则可以继续分解直到该分解合法。

**分解过程的实现**：  
拢共分三种情况  
1. 当 $x=1$ 时，可以构造 $(1,1,1)$。
1. 当 $x \in \operatorname{Prime}$ 时，可以构造 $(1,1,x)$。
1. 当 $x \notin \operatorname{Prime}$ 且 $x\not=1$ 时，考虑筛出 $y = \operatorname{lpf}(x)$，找到 $z=\frac{x}{y}$ 的一组合法分解 $(p,q,r)$，则 $x$ 的合法分解即为 $(p\times y,q,r)$ 的升序排列。

---

## Code

```cpp
const int mod=998244353,N=5e3+10,M=1e6+10,A=1e3+10;

int n,a[N],b[N],y[M][3],_p[M],cnt,p[M],pre[A][A];

void work(){
	y[1][1]=1,y[1][2]=1,y[1][3]=1;
	_p[1]=1;
	for(int i=2;i<=M-10;i++){
		if(!_p[i]){
			cnt++;
			p[cnt]=i;
			y[i][1]=1,y[i][2]=1,y[i][3]=i;
		}
		for(int j=1;p[j]*i<=M-10;j++){
            _p[i*p[j]]=1;
            int *tmp=y[i*p[j]];
            tmp[1]=y[i][1]*p[j];
            tmp[2]=y[i][2];
            tmp[3]=y[i][3];
            if(tmp[2]<tmp[1]){
            	int m=tmp[2];
				tmp[2]=tmp[1];
				tmp[1]=m;
			}
            if(tmp[3]<tmp[2]){
            	int m=tmp[3];
				tmp[3]=tmp[2];
				tmp[2]=m;
			}
            if(!(i%p[j])) break;
        }
	}
	for(int i=1;i<=A-10;i++){
		pre[0][i]=i;
		pre[i][0]=i;
	}
	for(int i=1;i<=A-10;i++){
		for(int j=1;j<=i;j++){
			pre[j][i]=pre[i%j][j];
			pre[i][j]=pre[i%j][j];
		}
	}
}
```

**另**：不用开 `long long` 的地方千万别开，容易 MLE。

---

- 二分 $\gcd$

出于某些神奇的原因，二分 $\gcd$ 是可以通过的，甚至跑得比正解还快。

由于二分 $\gcd$ 的做法不是正解，就不贴代码了。

---


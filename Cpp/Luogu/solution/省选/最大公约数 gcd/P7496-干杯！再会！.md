# 干杯！再会！

## 题目背景

>酒酣之时，等待你的会是……

黛米和哥哥在一个小城镇里经营着一家小酒吧。靠着哥哥调制的多夫林酒，这间小酒吧的生意也逐渐兴隆起来。

## 题目描述

这家小店有 $n$ 位常驻顾客。第 $i$ 位顾客来到这家小店时都会带上一瓶美味度为 $a_i$ 的底酒和一份美味度为 $b_i$ 的调料。这些顾客会让黛米帮忙调酒。对于一瓶美味度为 $x$ 的底酒和一份美味度为 $y$ 的调料，如果黛米将它们调制在一起，就能得到一瓶美味度为 $\gcd(x,y)$ 的美酒（我们认为美味度数值越低代表酒越好喝）。

这一天，这些顾客同时来到了这家小店想要黛米帮忙调酒。然而黛米在前一天喝了太多的酒导致意识错乱了，这导致她将调料加入到了错误的底酒里。不过好在这些顾客并不在意，他们只想知道对于**所有**黛米加入调料的情况下，他们将会拿到的酒的美味度的**方差**的**和**在对 $10^9+7$ 取模意义下是多少。如果你能回答出他们的问题，那么他们会很愿意帮你支付酒钱。

------------
#### 简要题意：
给定 $n$ 以及两个长度为 $n$ 的序列 $a,b$。对于一个 $1$ 到 $n$ 的排列 $p$，记 $c_i=\gcd(a_i,b_{p_i})$，$\sigma(c)$ 表示序列 $c$ 中所有元素的**方差**（方差公式详见提示），求：

$$\sum\limits_{p}\sigma(c)$$

对 $10^9+7$ 取模。

## 说明/提示

#### 样例一解释
+ $p=\{1,2,3\},c=\{1,2,3\},\sigma(c)=\dfrac{2}{3}$。
+ $p=\{1,3,2\},c=\{1,1,1\},\sigma(c)=0$。
+ $p=\{2,1,3\},c=\{1,1,3\},\sigma(c)=\dfrac{8}{9}$。
+ $p=\{2,3,1\},c=\{1,1,1\},\sigma(c)=0$。
+ $p=\{3,1,2\},c=\{1,1,1\},\sigma(c)=0$。
+ $p=\{3,2,1\},c=\{1,2,1\},\sigma(c)=\dfrac{2}{9}$。

总和为 $\dfrac{16}{9}$，对 $10^9+7$ 取模意义下为 $777777785$。

------------
#### 数据范围

**本题采用捆绑测试**。

+ Subtask 1 ( $5\%$ )：$n\leq8$。
+ Subtask 2 ( $15\%$ )：$n,a_i,b_i\leq100$。
+ Subtask 3 ( $25\%$ )：$a_i,b_i\leq10^3$。
+ Subtask 4 ( $25\%$ )：$n,a_i,b_i\leq 10^5$。
+ Subtask 5 ( $30\%$ )：无特殊限制。

对于所有数据，$2\leq n\leq 10^6,1\leq a_i,b_i\leq 10^6$。

------------
对于一个长度为 $n$ 的序列 $x$，方差 $\sigma(x)=\sum\limits_{i=1}^n\dfrac{1}{n}(x_i-\bar{x})^2$，其中 $\bar{x}$ 表示所有元素的平均数（$\bar{x}=\dfrac{1}{n}\sum\limits_{i=1}^nx_i$）。

## 样例 #1

### 输入

```
3
1 2 3
1 2 3
```

### 输出

```
777777785```

## 样例 #2

### 输入

```
12
1 3 4 2 3 5 7 3 5 6 8 9
4 3 10 2 5 6 4 8 2 9 12 5
```

### 输出

```
931089600```

# 题解

## 作者：wolfind (赞：12)

# $n\le 8$

直接枚举 $p$ 然后计算方差即可。

~~写起来意外的麻烦~~

复杂度 $O(n!)$。

```cpp
#include<bits/stdc++.h>
#define N 10
#define MOD 1000000007
using namespace std;
void read(int &x)
{
	x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')
	{
		x=x*10+ch-'0';
		ch=getchar();
	}
}
int n,invn,ans;
int a[N],b[N];
int p[N],v[N];
int ksm(int x,int k)
{
	int res=1;
	while(k)
	{
		if(k&1)res=1ll*res*x%MOD;
		x=1ll*x*x%MOD;
		k>>=1; 
	}
	return res;
}
int gcd(int x,int y)
{
	if(x==0)return y;
	return gcd(y%x,x);
}
void dfs(int x)
{
	if(x>n)
	{
		int pj=0;
		for(int i=1;i<=n;i++)
		{
			int res=gcd(a[i],b[p[i]]);
			pj=(pj+res)%MOD;
		}
		pj=1ll*pj*invn%MOD;
		for(int i=1;i<=n;i++)
		{
			int res=gcd(a[i],b[p[i]]);
			ans=(ans+1ll*(res-pj)*(res-pj)%MOD)%MOD;
		}
		return;
	}
	for(int i=1;i<=n;i++)
		if(!v[i])
		{
			p[x]=i;
			v[i]=1;
			dfs(x+1);
			p[x]=0;
			v[i]=0;
		}
}
int main()
{
	scanf("%d",&n);
	invn=ksm(n,MOD-2);
	for(int i=1;i<=n;i++)
		read(a[i]);
	for(int i=1;i<=n;i++)
		read(b[i]);
	dfs(1);
	ans=1ll*ans*invn%MOD;
	printf("%d",ans);
}
```


------------

# $n\le 100$

如果你想要直接递推，比如说 $dp_i$ 表示只考虑前 $i$ 位的时候的答案，那么由于原题是个随机的排列，你就得知道前 $i$ 位到底用了什么位置，必须要 $2^n$ 来记录，肯定是做不了的。

所以我们把方差拆掉：$\begin{aligned}\dfrac{1}{n}\sum\limits_{i=1}^{n}(x_i-\dfrac{S}{n})^2=\dfrac{1}{n}(\sum\limits_{i=1}^{n}x_i^2-\dfrac{S^2}{n})\end{aligned}$

那么这题就变成了求两个东西：

1.数列中的数的**平方的和** $\begin{aligned}sum1=\sum\limits_{i=1}^{n}x_i^2\end{aligned}$。

2.数列中的数的**和的平方** $sum2=S^2$。

$sum1$ 是好弄的，只要数列中的每个数独立考虑即可。

问题就是 $sum2$，没法独立考虑，因为这题的性质不允许我们 $dp$，所以就**直接把它拆掉**！

具体地， $\begin{aligned}S^2=\sum\limits_{i=1}^{n}x_i^2+\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{n}[i\ne j]x_ix_j\end{aligned}$

那么我们记录两个值：

$\begin{aligned}res1=\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{n}\gcd(a_i,b_j)^2\end{aligned}$

$\begin{aligned}res2=\sum\limits_{i1=1}^{n}\sum\limits_{i2=1}^{n}\sum\limits_{j1=1}^{n}\sum\limits_{j2=1}^{n}[i1 \ne i2][j1 \ne j2]\gcd(a_{i1},b_{j1})\times \gcd(a_{i2},b_{j2})\end{aligned}$

就会有 $sum1=res1\times (n-1)!$，$sum2=res1\times (n-1)!+res2\times (n-2)!$

最后答案就是 $ans=\dfrac{1}{n}(sum1-\dfrac{sum2}{n})$。

这样直接做就是 $O(n^4)$ 的，可以拿 $25$ 分。

下面这个代码真的是直接明了，就不写注释了。

```cpp
#include<bits/stdc++.h>
#define N 110
#define MOD 1000000007
using namespace std;
void read(int &x)
{
	x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')
	{
		x=x*10+ch-'0';
		ch=getchar();
	}
}
int n,invn,sum1,sum2,ans;
int a[N],b[N],mul[N];
int c[N][N];
int ksm(int x,int k)
{
	int res=1;
	while(k)
	{
		if(k&1)res=1ll*res*x%MOD;
		x=1ll*x*x%MOD;
		k>>=1;
	}
	return res;
}
int gcd(int x,int y)
{
	if(x==0)return y;
	return gcd(y%x,x);
}
int main()
{
	scanf("%d",&n);
	invn=ksm(n,MOD-2);
	for(int i=1;i<=n;i++)
		read(a[i]);
	for(int i=1;i<=n;i++)
		read(b[i]);
	mul[0]=1;
	for(int i=1;i<=n;i++)
		mul[i]=1ll*mul[i-1]*i%MOD;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			c[i][j]=gcd(a[i],b[j]);
			sum1=(sum1+1ll*c[i][j]*c[i][j])%MOD;
		}
	}
	sum1=1ll*sum1*mul[n-1]%MOD;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			for(int ii=1;ii<=n;ii++)
			{
				if(ii==i)continue;
				for(int jj=1;jj<=n;jj++)
				{
					if(jj==j)continue;
					int res1=c[i][j],res2=c[ii][jj];
					sum2=(sum2+1ll*res1*res2)%MOD;
				}
			}
		}
	}
	sum2=1ll*sum2*mul[n-2]%MOD;
	sum2=(sum1+sum2)%MOD;
	ans=(sum1-1ll*invn*sum2%MOD+MOD)%MOD;
	ans=1ll*ans*invn%MOD;
	printf("%d",ans);
}
```


------------

# $n\le 10^6$

（~~O(n^2)都是些奇怪的东西，就跳过了。~~）

然后就是想办法加快求 $res1,res2$ 的速度了。

首先是 $res1$，非常经典的 $\gcd$ 容斥：（知道的可以跳过了）

我们记录 $f_x$ 表示 $\gcd(a,b)=x$ 的 $(a,b)$ 有多少组。

也就是：$\begin{aligned}f_x=\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{n}[\gcd(a_i,b_j)=x]\end{aligned}$。

不过想要 $\gcd(a,b)=x$ 的话，至少得有 $x|a,x|b$ 吧。

也就是： $\begin{aligned}f_x=\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{n}[x|a_i][x|b_j]\end{aligned}$

但是这样的话如果 $\gcd(a,b)=kx$ 也会被算进去，所以要减去 $f_{2x},f_{3x},f_{4x}...$ 就把错的去掉了。

最终会有：$\begin{aligned}f_x=\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{n}[x|a_i][x|b_j]-\sum\limits_{i=2}^{\left\lfloor\frac{n}{x}\right\rfloor}f_{ix}\end{aligned}$

直接预处理 $\begin{aligned}ca_x=\sum\limits_{i=1}^{n}[x|a_i]\end{aligned}$，$\begin{aligned}cb_x=\sum\limits_{i=1}^{n}[x|b_i]\end{aligned}$，就可以从大往小求出 $f_i$ 了。

最后 $\begin{aligned}res1=\sum\limits_{i=1}^{n}f_i\times i^2\end{aligned}$

复杂度为 $O(\left\lfloor\dfrac{n}{1}\right\rfloor+\left\lfloor\dfrac{n}{2}\right\rfloor+...\left\lfloor\dfrac{n}{n}\right\rfloor)=O(n\log n)$。


------------

**然后就是本题的难点所在，$res2$ 该怎么求？**

仔细观察原式：

$\begin{aligned}res2=\sum\limits_{i1=1}^{n}\sum\limits_{i2=1}^{n}\sum\limits_{j1=1}^{n}\sum\limits_{j2=1}^{n}[i1 \ne i2][j1 \ne j2]\gcd(a_{i1},b_{j1})\times \gcd(a_{i2},b_{j2})\end{aligned}$

其中要满足两个条件 $[i1 \ne i2][j1 \ne j2]$。

但是在计数的时候保证选的两个不同的数是难的，而**选两个相同的数**或者是**任选两个数**都是好做的。

所以这就启发我们去**容斥**！

具体来说我们先求出**无限制下**的答案，然后减去**满足** $[i1=i2]$（注意这里是**相等**）而 $(j1,j2)$ 无限制的答案，再减去 $(i1,i2)$ 无限制而**满足** $[j1=j2]$ 的答案，最后还要加回来**满足** $[i1=i2]$ **且** $[j1=j2]$ 的答案。

有点繁琐，不过意会一下应该能明白。

我们把上面四个情况顺次记作 $tot1,tot2,tot3,tot4$，下面我们一个个求。


------------

# $tot1$

先把式子写出来：

$\begin{aligned}tot1=\sum\limits_{i1=1}^{n}\sum\limits_{i2=1}^{n}\sum\limits_{j1=1}^{n}\sum\limits_{j2=1}^{n}\gcd(a_{i1},b_{j1})\times \gcd(a_{i2},b_{j2})\end{aligned}$

观察一下发现：

$\begin{aligned}tot1=(\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{n}\gcd(a_{i},b_{j}))^2\end{aligned}$

想到之前求 $res1$ 时用的 $f_i$ 了吗？借用一下即可。

$\begin{aligned}tot1=(\sum\limits_{i=1}^{n}f_i\times i)^2\end{aligned}$

------------

# $tot2,tot3$

因为它俩一模一样，所以就讲讲 $tot2$ 咋求。

$\begin{aligned}tot2=\sum\limits_{i=1}^{n}\sum\limits_{j1=1}^{n}\sum\limits_{j2=1}^{n}\gcd(a_{i},b_{j1})\times \gcd(a_{i},b_{j2})\end{aligned}$

（因为 $i1=i2$，所以就直接改成 $i$ 了）

再观察一下可以发现 $j1,j2$ 能用一个平方弄掉：

$\begin{aligned}tot2=\sum\limits_{i=1}^{n}(\sum\limits_{j=1}^{n}\gcd(a_{i},b_{j}))^2\end{aligned}$

然后就用到我们的欧拉反演了！

当然，反演的式子很简单：$\begin{aligned}n=\sum\limits_{d|n}\varphi(d)\end{aligned}$。

咋用呢，其实就是把gcd换掉！

$\begin{aligned}\gcd(a_i,b_j)=\sum\limits_{d|\gcd(a_i,b_j)}\varphi(d)\end{aligned}$

代入即有：

$\begin{aligned}
tot2&=
\sum\limits_{i=1}^{n}(\sum\limits_{j=1}^{n}\sum\limits_{d|\gcd(a_i,b_j)}\varphi(d))^2\\
&=\sum\limits_{i=1}^{n}(\sum\limits_{j=1}^{n}\sum\limits_{d|a_i,d|b_j}\varphi(d))^2\\
&=\sum\limits_{i=1}^{n}(\sum\limits_{d|a_i}\sum\limits_{j=1}^{n}[d|b_j]\varphi(d))^2\\
\end{aligned}$

我们记录一个辅助数组 $\begin{aligned}gb_x=\sum\limits_{i=1}^{n}[x|b_i]\varphi(x)\end{aligned}$。

那么上式就是：$\begin{aligned}tot2=
\sum\limits_{i=1}^{n}(\sum\limits_{d|a_i}gb_d)^2\end{aligned}$

这样就可以 $O(n\log n)$ 啦。

如果你不用欧拉反演而是继续用之前的容斥的话，复杂度就是 $O(nlog^2n)$ 的，不过仔细想想把这个容斥的过程预处理出来，其实就是欧拉函数！

~~还是挺简单的。~~

------------
# $tot4$

$\begin{aligned}tot4=\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{n}\gcd(a_{i},b_{j})^2=res1\end{aligned}$

~~没了。~~

------------

然后根据 $res2=tot1-tot2-tot3+tot4$，这题就做完了。

复杂度 $O(n\log n)$。

写代码的时候还要注意一个细节，就是所有的 $a$ 我们是要存进桶中的，这样不同的数才会去计算一遍，否则同一个数计算多次的话复杂度是错的。

~~代码长度也就暴力的两倍~~

```cpp
#include<bits/stdc++.h>
#define N 1000010
#define MOD 1000000007
using namespace std;
void read(int &x)
{
	x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')
	{
		x=x*10+ch-'0';
		ch=getchar();
	}
}
int n,m,invn,sum1,sum2,ans;
int a[N],b[N],mul[N];
int ca[N],cb[N],f[N],phi[N],ga[N],gb[N];
int ksm(int x,int k)
{
	int res=1;
	while(k)
	{
		if(k&1)res=1ll*res*x%MOD;
		x=1ll*x*x%MOD;
		k>>=1; 
	}
	return res;
}
int gcd(int x,int y)
{
	if(x==0)return y;
	return gcd(y%x,x);
}
int main()
{
	scanf("%d",&n);
	invn=ksm(n,MOD-2);
	for(int i=1;i<=n;i++)
	{
		int x;
		read(x);
		++a[x];//要存进桶里 
		m=max(m,x);
	}
	for(int i=1;i<=n;i++)
	{
		int x;
		read(x);
		++b[x];
		m=max(m,x);
	}
	mul[0]=1;
	for(int i=1;i<=n;i++)
		mul[i]=1ll*mul[i-1]*i%MOD;//前缀积 
	for(int i=m;i>=1;i--)
		for(int j=1;j*i<=m;j++)
			ca[i]+=a[j*i];//把多少个a是i的倍数算进ca[i]中 
	for(int i=m;i>=1;i--)
		for(int j=1;j*i<=m;j++)
			cb[i]+=b[j*i];
	for(int i=m;i>=1;i--)
	{
		f[i]=1ll*ca[i]*cb[i]%MOD;
		for(int j=2;j*i<=m;j++)
			(f[i]+=MOD-f[j*i])%=MOD;//容斥,求出有多少gcd(a,b)=i,存进f[i] 
		sum1=(sum1+1ll*f[i]*i%MOD*i)%MOD;//其实是res1
		sum2=(sum2+1ll*f[i]*i)%MOD;//tot1
	}
	sum2=1ll*sum2*sum2%MOD;
	
	for(int i=1;i<=m;i++)
	{
		phi[i]=(phi[i]+i)%MOD;
		//这也是phi的一种求法，这样写主要是为了体现出其容斥的内涵 
		int tmpa=1ll*phi[i]*ca[i]%MOD,tmpb=1ll*phi[i]*cb[i]%MOD;
		(gb[i]+=tmpb)%=MOD;
		(ga[i]+=tmpa)%=MOD;
		sum2=(sum2-1ll*gb[i]*gb[i]%MOD*a[i]%MOD+MOD)%MOD;//tot2
		sum2=(sum2-1ll*ga[i]*ga[i]%MOD*b[i]%MOD+MOD)%MOD;//tot3
		for(int j=2;j*i<=m;j++)
			(phi[j*i]+=MOD-phi[i])%=MOD,(gb[j*i]+=tmpb)%=MOD,(ga[j*i]+=tmpa)%=MOD;
	}
	
	sum2=(sum2+sum1)%MOD;//tot4
	
	sum1=1ll*sum1*mul[n-1]%MOD;
	sum2=1ll*sum2*mul[n-2]%MOD;
	sum2=(sum1+sum2)%MOD;
	ans=(sum1-1ll*invn*sum2%MOD+MOD)%MOD;
	ans=1ll*ans*invn%MOD;
	printf("%d",ans);
}
```

------------

# $n\le 5\times 10^6$

~~没有被放进去的数据范围。~~

这咋整啊！~~卡常？~~

其实是高维前缀和优化。

复杂度上看，高维前缀和的复杂度是 $\sum\limits_{p}\left\lfloor\dfrac{n}{p}\right\rfloor$ （$p$ 是质数）$=O(n\log \log n)$，~~卡5000000还是很轻松的。~~

那么高维前缀和优化到底是啥呢？

其实就是我们想要求一个东西 $\begin{aligned}f_i=\sum\limits_{j=1}^{ij\le n}g_{ij}\end{aligned}$，其中 $g$ 是已知的。

那么我们可以先把 $j=2$ 的求出来，再加上 $j=3$ 的，再加上 $j=5$ 的......

而在加的过程中我们可以把之前算过的 $f$ 拿来用，跟前缀和一样。而且为了不算重，枚举的 $j$ 都是质数。

而这可以看作是一个多维的空间，其中每一维都是由一个质数 $p$ 的倍数构成的，因此原理其实就是高维前缀和。

代码也很短，如下：
```cpp
for(int i=1;i<=n;i++)f[i]=g[i];
	
for(int i=1;i<=p[0];i++)
	for(int j=n/p[i];j>=1;j--)
			f[j]+=f[j*p[i]];
```

那么我们原来的求 $ca[i]$ 的代码就可以改掉了，但是有些是无法改的！

我们举例一下原来所有要 $O(n\log n)$ 求的东西现在可以做到的复杂度：

1.$phi[i]$： 直接线性筛。$O(n)$

2.$ca[i],cb[i]$：高维前缀和。$O(n\log\log n)$ 

3.$ga[i],gb[i]$：高维前缀和。$O(n\log\log n)$ 

4.$f[i]$：因为要由自己容斥出自己，所以无法高维前缀和优化。$O(n\log n)$

好家伙，经典 $\gcd$ 容斥部分的求解成为了复杂度上限。

不过我们仍然有办法！

我们想，反正都是容斥，这里也用欧拉反演不好吗？

比如说：

$\begin{aligned}
tot1&=(\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{n}\gcd(a_{i},b_{j}))^2\\
&=(\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{n}\sum\limits_{d|a_i,d|b_j}\varphi(d))^2\\
&=(\sum\limits_{d=1}^{n}ca_dcb_d\varphi(d))^2
\end{aligned}$

要用 $f$ 求的还有一个 $res1$：

$\begin{aligned}res1=\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{n}\gcd(a_i,b_j)^2\end{aligned}$

啊这怎么欧拉反演。。。

我们参考欧拉反演的式子 $n=\sum\limits_{d|n}\varphi(d)$，也设计一个反演！

具体的，我们找到一个函数 $\phi(x)$，使得 $n^2=\sum\limits_{d|n}\phi(d)$ 就能像上面那样反演了。

这里根据狄利克雷卷积有 $id_2=\phi\ \ast\ I $ ，$\phi=id_2\ \ast\ \mu$ 所以 $\phi$ 是个积性函数，我们只要知道 $\phi(p^k)$ 是多少即可。

我们可以轻易发现 $\phi(p^k)=(p^k)^2-\phi(1)-\phi(p)-...-\phi(p^{k-1})=(p^k)^2-(p^{k-1})^2$

然后就没了。

复杂度 $O(n\log\log n)$。

~~全村最快的代码~~

在洛谷上跑 $n=5000000$ 只用 $500ms$ （不计读入）。

```cpp
#include<bits/stdc++.h>
#define N 5000010
#define MOD 1000000007
using namespace std;
void read(int &x)
{
	x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')
	{
		x=x*10+ch-'0';
		ch=getchar();
	}
}
int f[N],phi[N],v[N],p[N];
int n,m,invn,sum1,sum2,ans;
int a[N],b[N],mul[N];
int ca[N],cb[N],ga[N],gb[N];
int ksm(int x,int k)
{
	int res=1;
	while(k)
	{
		if(k&1)res=1ll*res*x%MOD;
		x=1ll*x*x%MOD;
		k>>=1; 
	}
	return res;
}
int gcd(int x,int y)
{
	if(x==0)return y;
	return gcd(y%x,x);
}
int main()
{
	read(n);
	invn=ksm(n,MOD-2);
	for(int i=1;i<=n;i++)
	{
		int x;
		read(x);
		++a[x];
		++ca[x];//这边要多一步，等价于ca[x]=a[x] 
		m=max(m,x);
	}
	for(int i=1;i<=n;i++)
	{
		int x;
		read(x);
		++b[x];
		++cb[x];
		m=max(m,x);
	}
	mul[0]=1;
	for(int i=1;i<=n;i++)
		mul[i]=1ll*mul[i-1]*i%MOD;
	
	phi[1]=1;f[1]=1;
	for(int i=2;i<=m;i++)
	{
		if(!v[i])p[++p[0]]=i,phi[i]=i-1,f[i]=1ll*i*i%MOD-1;//f[i]就是我们自己求的积性函数！ 
		for(int j=1;j<=p[0]&&p[j]*i<=m;j++)
		{
			v[i*p[j]]=1;
			if(i%p[j]==0)
			{
				phi[i*p[j]]=phi[i]*p[j];
				f[i*p[j]]=1ll*f[i]*p[j]%MOD*p[j]%MOD;
				break;
			}
			else phi[i*p[j]]=phi[i]*phi[p[j]],f[i*p[j]]=1ll*f[i]*f[p[j]]%MOD;
		}
	}
	
	for(int i=1;i<=p[0];i++)
		for(int j=m/p[i];j>=1;j--)
			ca[j]+=ca[j*p[i]],cb[j]+=cb[j*p[i]];//高维前缀和！ 
	
	for(int i=m;i>=1;i--)
	{
		int tmp=1ll*ca[i]*cb[i]%MOD;
		sum1=(sum1+1ll*tmp*f[i])%MOD;
		sum2=(sum2+1ll*tmp*phi[i])%MOD;
	}
	sum2=1ll*sum2*sum2%MOD;
	
	for(int i=1;i<=m;i++)//初始化 
	{
		gb[i]=1ll*phi[i]*cb[i]%MOD;
		ga[i]=1ll*phi[i]*ca[i]%MOD;
	}
	
	for(int i=1;i<=p[0];i++)
		for(int j=1;j<=m/p[i];j++)
			(ga[j*p[i]]+=ga[j])%=MOD,(gb[j*p[i]]+=gb[j])%=MOD;//高维前缀和！ 
	
	for(int i=1;i<=m;i++)
	{
		sum2=(sum2-1ll*gb[i]*gb[i]%MOD*a[i]%MOD+MOD)%MOD;
		sum2=(sum2-1ll*ga[i]*ga[i]%MOD*b[i]%MOD+MOD)%MOD;
	}
	
	sum2=(sum2+sum1)%MOD;
	
	sum1=1ll*sum1*mul[n-1]%MOD;
	sum2=1ll*sum2*mul[n-2]%MOD;
	sum2=(sum1+sum2)%MOD;
	ans=(sum1-1ll*invn*sum2%MOD+MOD)%MOD;
	ans=1ll*ans*invn%MOD;
	printf("%d",ans);
}
```


---

## 作者：littleKtian (赞：8)

以下复杂度分析中的 $m$ 表示 $a,b$ 的值域。

------------

#### Part 0

众所周知，方差有个相对好看的式子：

$$\begin{aligned}\sigma(x)&=\sum\limits_{i=1}^n\dfrac{1}{n}(x_i-\bar{x})^2\\&=\dfrac{1}{n}\sum\limits_{i=1}^nx_i^2-\bar{x}^2\\&=\dfrac{1}{n}\sum\limits_{i=1}^nx_i^2-\dfrac{1}{n^2}\left(\sum\limits_{i=1}^nx_i\right)^2\end{aligned}$$

所以我们将方差拆成两部分计算。

#### Part 1

考虑如何计算 $\sum x_i^2$。

显然我们可以将所有 $a$ 和 $b$ 中的元素两两之间的 $\gcd$ 求出来，每对显然正好会在 $(n-1)!$ 种情况中出现。

直接用莫反计算出对于所有的 $k$，$\gcd(a_i,b_j)=k$ 的 $(i,j)$ 的对数，就可以求出这部分的答案了。复杂度 $O(m\log m)$。

#### Part 2

考虑如何计算 $\left(\sum x_i\right)^2$。

直接做肯定不好处理，我们考虑拆掉一层括号，即对于所有 $c_i$ 可能出现的值，我们统计出所有包含这个数的所有方案中所有元素的和（如果在一种方案中出现了多次也要统计多次）。

然后我们再讲所有元素的和拆成这个值本身以及其他所有元素的和。也就是说对于每对 $\gcd(a_i,b_j)=k$，我们要统计出 $a,b$ 中**其他元素两两组合**所得的所有值（还要记得乘上 $(n-2)!$，因为每组会出现 $(n-2)!$ 次）。

这个如果直接暴力做是 $O(n^3\log m)$ 的，显然不能接受。我们考虑再利用容斥，将其他元素两两组合所得的所有值拆成 $($ **所有元素两两组合**所得的所有值 $)-($ **$a_i$ 与 $b$ 中所有元素组合**的所有值 $)-($ **$b_j$ 与 $a$ 中所有元素组合**的所有值 $)+($ $a_i$ 与 $b_j$ 组合的值 $)$。

所有元素两两组合所得的所有值显然我们利用上面的莫反可以直接做出，$a_i$ 和 $b_j$ 的组合值也很显然（就是我们枚举的）。所以问题变成了如何求 $a_i$ 与 $b$ 中所有元素组合的所有值 以及 $b_j$ 与 $a$ 中所有元素组合的所有值。这两个问题基本相同，所以我们下面只讨论其中一个。

如果我们暴力对每个元素都进行一次莫反，复杂度就是 $O(n^2\log m)$ 的，这显然还不是我们需要的。

因为两个数的 $\gcd$ 显然是整除这两个数的，所以我们考虑缩小莫反的范围，即对于每次枚举的 $a_i$，我们**只在其约数范围内进行莫反。**

注意到如果 $a$ 中很多元素重复时我们没有必要对这些重复的元素都进行一遍莫反，所以我们改为在值域范围内枚举，另外我们可以预处理约数来减小枚举时的复杂度。可以证明复杂度是 $O(m\log^2 m)$。

处理完这两部分后我们再用一遍莫反就能得出我们所要求的结果。

总复杂度为 $O(m\log^2 m)$。

~~然后 std 就被吊打了。~~

#### Part 3 一个小优化

其实只需要用欧拉反演（$n=\sum\limits_{d|n}\varphi(d)$）就能将 $O(m\log^2 m)$ 优化到 $O(m\log m)$ 了。

当然还可以用一些其他的优化做到更优，此题不作要求，具体可以去看验题人的题解。

```cpp
#include<bits/stdc++.h>
#define N 1000000
#define p 1000000007
using namespace std;
int n,nn,jc,cjc,a[N+5],b[N+5],ta[N+5],tb[N+5];
int ans1,ans2,tf,f[N+5],fa[N+5],fb[N+5],lf[N+5];
int vi[N+5],pi[N+5],phi[N+5],tp;
int dr()
{
    int xx=0;char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9')xx=(xx<<1)+(xx<<3)+ch-'0',ch=getchar();
    return xx;
}
int P(int x,int y=p-2)
{
    int z=1;
    for(;y;x=1ll*x*x%p,y>>=1)if(y&1)z=1ll*z*x%p;
    return z;
}
int main()
{
	phi[1]=1;
    for(int i=2;i<=N;i++)
	{
		if(vi[i]==0){vi[i]=pi[++tp]=i;}
		phi[i]=phi[i/vi[i]]*(vi[i]==vi[i/vi[i]]?vi[i]:vi[i]-1);
		for(int j=1;j<=tp&&pi[j]<=vi[i]&&pi[j]<=N/i;j++)vi[pi[j]*i]=pi[j];
	}
    n=dr(),nn=P(n),cjc=1;
    for(int i=1;i<n-1;i++)cjc=1ll*i*cjc%p;
    jc=1ll*(n-1)*cjc%p;
    for(int i=1;i<=n;i++)++a[dr()];
    for(int i=1;i<=n;i++)++b[dr()];
    for(int i=1;i<=N;i++)for(int j=i;j<=N;j+=i)ta[i]+=a[j],tb[i]+=b[j];
    for(int i=1;i<=N;i++)
	{
		int xa=1ll*phi[i]*ta[i]%p,xb=1ll*phi[i]*tb[i]%p;
		for(int j=i;j<=N;j+=i)fa[j]+=xb,fb[j]+=xa,fa[j]-=fa[j]>=p?p:0,fb[j]-=fb[j]>=p?p:0;
	}
    for(int i=1;i<=N;i++)
    {
        f[i]=1ll*ta[i]*tb[i]%p;int tfa=0,tfb=0;
        for(int j=i;j<=N;j+=i)tfa=(tfa+1ll*a[j]*fa[j])%p,tfb=(tfb+1ll*b[j]*fb[j])%p;
        lf[i]=(1ll*tb[i]*tfa+1ll*ta[i]*tfb)%p;
    }
    for(int i=N;i;i--)for(int j=i<<1;j<=N;j+=i)f[i]-=f[j],f[i]+=f[i]<0?p:0,lf[i]-=lf[j],lf[i]+=lf[i]<0?p:0;
    for(int i=1;i<=N;i++)
	{
		int x=1ll*i*f[i]%p;
		tf+=x,tf-=tf>=p?p:0,ans1=(ans1+1ll*i*x)%p;
	}
    for(int i=1;i<=N;i++)ans2=(ans2+((1ll*i*(jc+cjc)+1ll*tf*cjc)%p*f[i]-1ll*lf[i]*cjc)%p*i)%p,ans2+=ans2<0?p:0;
	ans1=1ll*ans1*jc%p*nn%p,ans2=1ll*ans2*nn%p*nn%p;
    ans1-=ans2,ans1+=ans1<0?p:0,printf("%d",ans1);
}
```


---

## 作者：Reunite (赞：6)

好题。

更新了更优复杂度做法，置于文末。

## 一
---

方差和排列的组合，我还没见过。但是方差的定义式太丑了，考虑转换一下形式。由初中知识，方差的另一种表达形式为：

$$\frac{1}{n}\sum_{i=1}^nx_i^2-\frac{1}{n^2}(\sum_{i=1}^nx_i)^2$$

先丢掉系数，分别考虑左右两个部分，记为 $s1,s2$。先考虑较简单的 $s1$。记 $c_i,h_i$ 分别为 $a_n,b_n$ 中值为 $i$ 的个数，$m$ 为值域。我们来考虑对 $n!$ 种排列的贡献。下文的 $x_i$ 即为原题的 $c_i$。

$$
\begin{aligned}
s1=&\sum_{p}\sum_{i=1}^nx_i^2 \\
=&(n-1)!\sum_{i=1}^n\sum_{j=1}^n(a_i,b_j)^2\\
=&(n-1)!\sum_{d=1}^md^2\sum_{i=1}^{\frac{m}{d}}\sum_{j=1}^{\frac{m}{d}} c_ih_j[(i,j)==1]\\
=&(n-1)!\sum_{d=1}^md^2\sum_{t=1}^{\frac{m}{d}}\mu(t)\sum_{i=1}^{\frac{m}{dt}}c_{idt}\sum_{j=1}^{\frac{m}{dt}} h_{jdt}\\
\end{aligned}
$$

发现后面那两个 $c_{idt},h_{jdt}$ 的意义为 $a_n,b_n$ 中 $dt$ 的倍数的个数，我们把它预处理出来，记为 $f_i,g_i$。则：

$$
\begin{aligned}
s1=&(n-1)!\sum_{d=1}^md^2\sum_{t=1}^{\frac{m}{d}}\mu(t)\sum_{i=1}^{\frac{m}{dt}}c_{idt}\sum_{j=1}^{\frac{m}{dt}} h_{jdt}\\
=&(n-1)!\sum_{d=1}^md^2\sum_{t=1}^{\frac{m}{d}}\mu(t)f_{dt}g_{dt}

\end{aligned}
$$

枚举 $d,t$ 的复杂度是调和级数，$f,g$ 也可以调和计数或者狄利克雷前缀和算出，这部分复杂度是可以接受的。

接下来考虑 $s2$，方法还是考虑对于整个 $n!$ 种排列的贡献。

因为:

$$(\sum_{i=1}^nx_i)^2=\sum_{i=1}^n\sum_{j=1}^n[i\ne j]x_iy_j+\sum_{i=1}^nx_i^2$$

所以：

$$
\begin{aligned}
s2=&\sum_p(\sum_{i=1}^nx_i)^2\\
=&\sum_p(\sum_{i=1}^n\sum_{j=1}^nx_ix_j)\\
=&(n-2)!\sum_{i=1}^n\sum_{j=1}^n\sum_{x=1}^n\sum_{y=1}^n[x\ne i][y \ne j](a_i,b_j)(a_x,b_y)+\sum_p\sum_{i=1}^nx_i^2\\
=&(n-2)!\sum_{i=1}^n\sum_{j=1}^n\sum_{x=1}^n\sum_{y=1}^n[x\ne i][y \ne j](a_i,b_j)(a_x,b_y)+s1

\end{aligned}
$$

我们发现这两个不等于的限制无法简单做到，于是考虑容斥，即上式左边等于无限制的值减去一定满足两个限制之一的值，然后再加上两个限制都满足的值，我们把上面所说的四个部分记为 $A,B,C,D$，则 $s2=A-B-C+D+s1$。

继续我们的推导。

$$
\begin{aligned}
A=&(n-2)!\sum_{i=1}^n\sum_{j=1}^n\sum_{x=1}^n\sum_{y=1}^n(a_i,b_j)(a_x,b_y)\\
=&(n-2)!(\sum_{i=1}^n\sum_{j=1}^n(a_i,b_j))^2\\
=&(n-2)!(\sum_{d=1}^md\sum_{i=1}^{\frac{m}{d}}\sum_{j=1}^{\frac{m}{d}}[(i,j)==1]c_ih_j)^2\\
=&(n-2)!(\sum_{d=1}^md\sum_{t=1}^{\frac{m}{d}}\mu(t)f_{dt}g_{dt})^2

\end{aligned}
$$

$A$ 与 $s1$ 是很类似的，不再赘述。

$$
\begin{aligned}
B=&(n-2)!\sum_{i=1}^n\sum_{x=1}^n\sum_{y=1}^n(a_i,b_x)(a_i,b_y)\\
=&(n-2)!\sum_{i=1}^n(\sum_{j=1}^n(a_i,b_j))^2\\
=&(n-2)!\sum_{i=1}^mc_i(\sum_{d|i}d\sum_{j=1}^{\frac{m}{d}}[(\frac{i}{d},j)==1]h_{jd})^2\\
=&(n-2)!\sum_{i=1}^mc_i(
\sum_{d|i}d\sum_{t|\frac{i}{d}}\mu(t)g_{dt})^2\\
=&(n-2)!\sum_{i=1}^mc_i(\sum_{t|i}g_t\sum_{d|t}d\mu(\frac{t}{d}))^2\\

\end{aligned}

$$

我们发现平方项里面是只与 $t$ 有关的，与 $i$ 无关，所以我们可以先预处理出来，具体地：

$$G(n)=\sum_{t|n}g_t\sum_{d|t}d\mu(\frac{t}{d})$$

后面的 $\sum\limits_{d|t}d\mu(\frac{t}{d})$ 是一个标准的狄利克雷卷积的形式。我们知道：


$$Id*\mu=\varphi$$

所以有：

$$G(n)=\sum_{d|n}g_d\varphi(d)$$

$$B=(n-2)!\sum_{i=1}^mc_iG(i)^2$$

可以在调和级数复杂度内处理处所有的 $G$。

$C$ 的处理是类似的。

$$F(n)=\sum_{d|n}f_d\varphi(d)$$

$$C=(n-2)!\sum_{i=1}^mh_iF(i)^2$$

然后发现 $D$ 就等于 $\frac{s1}{n-1}$。有这样一个分母是因为前面阶乘的系数不同。

所以这道题就做完了。我们算出 $s1,s2$，那么答案为：

$$\frac{1}{n}s1-\frac{1}{n^2}s2$$


## 二
---

具体实现方面，$f,g,F,G$ 都可以通过暴力的枚举倍数或者是狄利克雷前缀和后缀和求出，复杂度分别为 $O(m\log m)$ 和 $O(m\log\log m)$。

但是我的实现可能比较劣，因为至少有一步我是需要枚举到调和级数的，也就是算 $A,D$ 的时候，这也成为我做法的复杂度瓶颈，但我懒的想了。


```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#define ll long long
#define mod 1000000007
using namespace std;

int n,m=1000000,cnt;
int a[1000005];
int b[1000005];
int c[1000005];
int h[1000005];
ll fac[1000005];
int f[1000005];
int g[1000005];
ll F[1000005];
int mu[1000005];
int oular[1000005];
int prime[150005];
bool mp[1000005];

inline void in(int &n){
	n=0;
	char c=getchar();
	while(c<'0' || c>'9') c=getchar();
	while(c>='0'&&c<='9') n=n*10+c-'0',c=getchar();
	return ;
}

inline ll calc(ll x,ll k){
	ll tmp=1;
	while(k){
		if(k&1) tmp=tmp*x%mod;
		x=x*x%mod;
		k>>=1;
	}
	return tmp;
}

int main(){
	// freopen("qwq.in","r",stdin);
	in(n);
	for(int i=1;i<=n;i++) in(a[i]),c[a[i]]++;
	for(int i=1;i<=n;i++) in(b[i]),h[b[i]]++;
	fac[0]=1;
	for(int i=1;i<=n;i++) fac[i]=1ll*fac[i-1]*i%mod;
	for(int i=1;i<=m;i++)
		for(int j=i;j<=m;j+=i) f[i]+=c[j],g[i]+=h[j];
	for(int i=1;i<=m;i++) F[i]=1ll*f[i]*g[i]%mod;
	mu[1]=oular[1]=1;
	for(int i=2;i<=m;i++){
		if(!mp[i]) mu[i]=-1,prime[++cnt]=i,oular[i]=i-1;
		for(int j=1;j<=cnt&&i*prime[j]<=m;j++){
			mp[i*prime[j]]=1;
			if(i%prime[j]==0){
				oular[i*prime[j]]=oular[i]*prime[j];
				break;
			}
			mu[i*prime[j]]=-mu[i];
			oular[i*prime[j]]=oular[i]*(prime[j]-1);
		}
	}

	ll A=0,B=0,C=0,D=0;
	for(int d=1;d<=m;d++){
		ll ss=0;
		for(int t=1;t<=m/d;t++) (ss+=mod+mu[t]*F[d*t])%=mod;
		D=(D+ss*d%mod*d%mod+mod)%mod;
		A=(A+ss*d%mod+mod)%mod;
	}
	(A*=A%mod)%=mod;

	memset(F,0,sizeof(F));

	for(int i=1;i<=m;i++)
		for(int j=i;j<=m;j+=i) (F[j]+=g[i]*oular[i]%mod)%=mod;
	for(int i=1;i<=m;i++) B=(B+c[i]*F[i]%mod*F[i]%mod)%mod;

	memset(F,0,sizeof(F));

	for(int i=1;i<=m;i++)
		for(int j=i;j<=m;j+=i) (F[j]+=f[i]*oular[i]%mod)%=mod;
	for(int i=1;i<=m;i++) C=(C+h[i]*F[i]%mod*F[i]%mod)%mod;

	ll inv=calc(n,mod-2);
	ll s1=D*fac[n-1]%mod;
	ll s2=(fac[n-2]*(A-B-C+D+mod+mod)%mod+s1)%mod;
	printf("%lld\n",(s1-s2*inv%mod+mod)%mod*inv%mod);

	return 0;
}
```

## 三
---

更优秀的实现？

上文说到我在算 $A,D$ 时无法避免地要达到调和级数复杂度，但我想了半个小时后发现并不是这样的。总时间复杂度已被我优化至 $O(m\log\log m)$。

$f,g$ 用狄利克雷后缀和是平凡的，下面主要说如何降低处理 $A,D$ 的复杂度。

令 $T(n)=f_{n}g_{n}$。

由上：

$$
\begin{aligned}

A=&(n-2)!(\sum_{d=1}^md\sum_{t=1}^{\frac{m}{d}}\mu(t)f_{dt}g_{dt})^2\\
=&(n-2)!(\sum_{d=1}^md\sum_{t=1}^{\frac{m}{d}}\mu(t)T(dt))^2\\
=&(n-2)!(\sum_{t=1}^mT(t)\sum_{d|t}d\mu(\frac{t}{d}))^2\\

=&(n-2)!(\sum_{t=1}^mT(t) \varphi(t))^2

\end{aligned}
$$

这样的话只算 $A$ 的复杂度被降低至线性。接下来考虑 $D$。

$$
\begin{aligned}

D=&(n-2)!\sum_{d=1}^md^2\sum_{t=1}^{\frac{m}{d}}\mu(t)f_{dt}g_{dt}\\
=&(n-2)!\sum_{d=1}^md^2\sum_{t=1}^{\frac{m}{d}}\mu(t)T(dt)\\
=&(n-2)!\sum_{t=1}^mT(t)\sum_{d|t}d^2\mu(\frac{t}{d})

\end{aligned}
$$

到这里好像推不了了？其实还是可以的。我们知道 $Id_{k},\mu$ 均为积性函数，那么它们的狄利克雷卷积一定也是积性函数。也就是说，如果我们令 $H(n)=\sum\limits_{d|n}d^2\mu(\frac{n}{d})$，那么 $H(n)$ 是可以用线性筛直接筛出来的。

我的解决办法也的确是这样，注意到这里只需要用到 $d^2$，所以线性筛出这个积性函数非常简单。至此，我们可以在线性复杂度内完成对 $A,D$ 的计算。比较有意思的是，曾经我们认为是复杂度瓶颈的部分已经做到了更优的复杂度，当然，预处理 $f,g$ 还是少不了狄利克雷后缀和的。

然后还有一个比较有意思的是，我们的 $\mu$ 曾几乎出现在每一个式子里，但是经过我们利用狄利克雷卷积和线性筛，$\mu$ 已经是完全不需要的了！甚至都不用顺便筛出来，有些大道至简的感觉。

放一下 $O(m\log\log m)$ 的实现，目前是次优解。

---
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#define ll long long
#define mod 1000000007
using namespace std;

int n,m,cnt;
int a[1000005];
int b[1000005];
int c[1000005];
int h[1000005];
ll fac[1000005];
int f[1000005];
int g[1000005];
ll F[1000005];
ll H[1000005];
int low[1000005];
int oular[1000005];
int prime[150005];
bool mp[1000005];

inline void in(int &n){
	n=0;
	char c=getchar();
	while(c<'0' || c>'9') c=getchar();
	while(c>='0'&&c<='9') n=n*10+c-'0',c=getchar();
	return ;
}

inline ll calc(ll x,ll k){
	ll tmp=1;
	while(k){
		if(k&1) tmp=tmp*x%mod;
		x=x*x%mod;
		k>>=1;
	}
	return tmp;
}

inline void Dirichlet1(){
	for(int i=1;i<=cnt;i++)
		for(int j=m/prime[i];j>=1;j--)
			F[j]=(F[j]+F[j*prime[i]])%mod;
	return ;
}

inline void Dirichlet2(){
	for(int i=1;i<=cnt;i++)
		for(int j=1;j<=m/prime[i];j++)
			F[j*prime[i]]=(F[j*prime[i]]+F[j])%mod;
	return ;
}

inline void init(){
    H[1]=low[1]=oular[1]=1;
    for(int i=2;i<=m;i++){
        if(!mp[i]) low[i]=prime[++cnt]=i,H[i]=(1ll*i*i-1)%mod,oular[i]=i-1;
        for (ll j=1;j<=cnt&&i*prime[j]<=m;j++){
            mp[i*prime[j]]=1;
            if (i%prime[j]==0){
                low[i*prime[j]]=low[i]*prime[j];
                if (low[i]==i)
                    H[i*prime[j]]=H[i]*prime[j]%mod*prime[j]%mod;
                else
                    H[i*prime[j]]=H[i/low[i]]*H[low[i]*prime[j]]%mod;
               	oular[i*prime[j]]=oular[i]*prime[j];
                break;
            }
            low[i*prime[j]]=prime[j];
            H[i*prime[j]]=H[i]*H[prime[j]]%mod;
            oular[i*prime[j]]=oular[i]*(prime[j]-1);
        }
    }
    return ;
}

int main(){
	in(n);
	for(int i=1;i<=n;i++) in(a[i]),c[a[i]]++,m=max(m,a[i]);
	for(int i=1;i<=n;i++) in(b[i]),h[b[i]]++,m=max(m,b[i]);
	fac[0]=1;
	for(int i=1;i<=n;i++) fac[i]=1ll*fac[i-1]*i%mod;
	init();
	for(int i=1;i<=m;i++) F[i]=c[i];
	Dirichlet1();
	for(int i=1;i<=m;i++) f[i]=F[i],F[i]=h[i];
	Dirichlet1();
	for(int i=1;i<=m;i++) g[i]=F[i];
	for(int i=1;i<=m;i++) F[i]=1ll*f[i]*g[i]%mod;
	ll A=0,B=0,C=0,D=0;
	for(int d=1;d<=m;d++){
		D=(D+H[d]*F[d]%mod)%mod;
		A=(A+F[d]*oular[d]%mod)%mod;
	}
	(A*=A%mod)%=mod;
	for(int i=1;i<=m;i++) F[i]=g[i]*oular[i]%mod;
	Dirichlet2();
	for(int i=1;i<=m;i++) B=(B+c[i]*F[i]%mod*F[i]%mod)%mod;
	for(int i=1;i<=m;i++) F[i]=f[i]*oular[i]%mod;
	Dirichlet2();
	for(int i=1;i<=m;i++) C=(C+h[i]*F[i]%mod*F[i]%mod)%mod;
	ll inv=calc(n,mod-2);
	ll s1=D*fac[n-1]%mod;
	ll s2=(fac[n-2]*(A-B-C+D+mod+mod)%mod+s1)%mod;
	printf("%lld\n",(s1-s2*inv%mod+mod)%mod*inv%mod);

	return 0;
}
```

---

## 作者：CloudDreamLake (赞：1)

这篇题解使用了  
+ `gcd` 容斥
+ 欧拉反演
+ 倍数卷积优化

将各个部分分都讲完，并且造了一道加强版的题目 [U523479 P7496 干杯！再会！（加强版）](https://www.luogu.com.cn/problem/U523479)。

借鉴了第一篇 [wolfind](https://www.luogu.com.cn/article/5y7vfo0o) 的题解。
## $n\le 8$
时间复杂度： $\Theta(n!n)$

直接枚举排列 $p$。
```cpp
int n;
int a[N], b[N], p[N];
ModInt ans;

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    
    cin >> n;
    fup(i, 1, n) cin >> a[i];
    fup(i, 1, n) cin >> b[i];

    iota(p, p+N, 0);
    do {
        ModInt F, G;
        fup(i, 1, n) {
            ModInt x = __gcd(a[i], b[p[i]]);
            F += x * x;
            G += x;
        }
        ans += F / n - (G / n) * (G / n);
    } while(next_permutation(p+1, p+n+1));

    cout << ans << endl;
}
```

## $n\le 100$
时间复杂度： $\Theta(n^4)$

方差 $c(a) = \bar {a^2}-{\bar a}^2$。

对答案推导：
$$
\begin{aligned}
\sum_p\sigma(c) &= \sum_p\left\{ \frac{\sum_i a_i^2}{n} - \left(\frac{\sum_ia_i}{n}\right)^2 \right\}\\
&= \frac{\sum_p\sum_i a_i^2}{n} - \sum_p\left(\frac{\sum_ia_i}{n}\right)^2\\
&= \frac{\sum_i\sum_p (n-1)!\gcd^2(a_i,b_{p_i})}{n} - \frac{\sum_p(\sum_ia_i)^2}{n^2}\\
S^2&=\sum_ia_i^2+\sum_i\sum_j[i\neq j]a_ia_j
\end{aligned}
$$
$S^2$ 可以直接枚举求出来。

```cpp
int n;
int a[N], b[N], p[N];
ModInt g[N][N];
ModInt F, G;

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    
    cin >> n;
    fup(i, 1, n) cin >> a[i];
    fup(i, 1, n) cin >> b[i];
    fup(i, 1, n) fup(j, 1, n) g[i][j] = __gcd(a[i], b[j]);

    fup(i, 1, n) fup(j, 1, n) F += g[i][j] * g[i][j]; 
    fup(i, 1, n-1) F *= i;

    fup(i1, 1, n) fup(i2, 1, n) fup(j1, 1, n) fup(j2, 1, n) 
	    if(i1 != i2) if(j1 != j2) {
	        G += g[i1][j1] * g[i2][j2];
	    }
    fup(i, 1, n-2) G *= i;  

    cout << (F - (F + G) / n) / n << endl;
}
```
## $W\le 10^3$
时间复杂度： $\Theta(W^2\log W)$ 

把 
```cpp
fup(i1, 1, n) fup(i2, 1, n) fup(j1, 1, n) fup(j2, 1, n) 
	if(i1 != i2) if(j1 != j2) {
		G += g[i1][j1] * g[i2][j2];
	}
```
展开
```cpp
ModInt S = 0;
fup(i, 1, 1000) fup(j, 1, 1000) S += g[i][j] * c[i][j];
G += S * S;

fup(i, 1, 1000) {
	S = 0;
	fup(j, 1, 1000) S += g[i][j] * c[i][j];
	G -= S * S / cnt[0][i]; 
}
fup(j, 1, 1000) {
	S = 0;
	fup(i, 1, 1000) S += g[i][j] * c[i][j];
	G -= S * S / cnt[1][j];
}
fup(i, 1, 1000) fup(j, 1, 1000) {
	G += g[i][j] * g[i][j] * c[i][j];
}
```
枚举 $n$ 变成枚举值域。
```cpp
int n;
int a[N], b[N];
ModInt g[W][W];
int c[W][W];
int cnt[2][N];
ModInt F, G, S;

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    
    cin >> n;
    fup(i, 1, n) cin >> a[i], cnt[0][a[i]]++;
    fup(i, 1, n) cin >> b[i], cnt[1][b[i]]++;
    fup(i, 1, 1000) fup(j, 1, 1000) g[i][j] = __gcd(i, j);
    fup(i, 1, 1000) fup(j, 1, 1000) c[i][j] = cnt[0][i] * cnt[1][j];

    fup(i, 1, 1000) fup(j, 1, 1000) F += g[i][j] * g[i][j] * c[i][j]; 
    fup(i, 1, n-1) F *= i;

    fup(i, 1, 1000) fup(j, 1, 1000) S += g[i][j] * c[i][j];
    G += S * S;
    fup(i, 1, 1000) {
        S = 0;
        fup(j, 1, 1000) S += g[i][j] * c[i][j];
        G -= S * S / cnt[0][i]; 
    }
    fup(j, 1, 1000) {
        S = 0;
        fup(i, 1, 1000) S += g[i][j] * c[i][j];
        G -= S * S / cnt[1][j];
    }
    fup(i, 1, 1000) fup(j, 1, 1000) {
        G += g[i][j] * g[i][j] * c[i][j];
    }
    fup(i, 1, n-2) G *= i;  

    cout << (F - (F + G) / n) / n << endl;
}
```
## $n\le 10^6$
时间复杂度： $\Theta(n\log n)$
### $F$
$$
\begin{aligned}
F &= \sum_{i=1}^n\sum_{j=1}^n {\gcd}^2(a_i,b_j) \\
F_x&=\sum_{i=1}^n\sum_{j=1}^n[\gcd(a_i,b_j)=x] \\
f_x&=\sum_{i=1}^n\sum_{j=1}^n[x|\gcd(a_i,b_j)] \\
&= \sum_{i=1}^n\sum_{j=1}^n[x|a_i][x|b_j]\\
&= \sum_{i=1}^n[x|a_i]\sum_{i=1}^n[x|b_i]\\
f_x &= \sum_{i=1}^{\left\lfloor \frac nx \right\rfloor} F_{ix} \\
F_x &= f_x-\sum_{i=2}^{\left\lfloor \frac nx \right\rfloor} F_{ix} \\
F &= \sum_{x=1}^n F_x\times x^2
\end{aligned}
$$
复杂度为： $\Theta\left( \sum\limits_{i=1}^n \left\lfloor \dfrac ni \right\rfloor \right) = \Theta(n\log n)$ 
### $G$
考虑之前 $\Theta(W^2\log W)$ 的优化。

设 
$$
G=tot_1-tot_2-tot_3+tot_4
$$
#### $tot_1$
$$
\begin{aligned}
tot_1 &= \left(\sum_{i=1}^n\sum_{j=1}^n\gcd(a_i,b_j)\right)^2 \\
&= \left(\sum_{x=1}^n F_x\times x\right)^2
\end{aligned}
$$
#### $tot_{2/3}$
$$
\begin{aligned}
tot_2 &= \sum_{i=1}^n\sum_{j_1=1}^n\sum_{j_2=1}^n \gcd(a_i,b_{j_1})\times\gcd(a_i,b_{j_2}) \\
&= \sum_{i=1}^n \left( \sum_{j=1}^n\gcd(a_i, b_j) \right)^2 \\
&= \sum_{i=1}^n \left( \sum_{j=1}^n \sum_{d|\gcd(a_i,b_j)} \varphi(d)  \right)^2 \\
&= \sum_{i=1}^n \left( \sum_{j=1}^n \sum_{d|a_i\land d|b_j} \varphi(d)  \right)^2 \\
&= \sum_{i=1}^n \left( \sum_{j=1}^n \sum_d [d|a_i][d|b_j] \varphi(d)  \right)^2 \\
&= \sum_{i=1}^n \left( \sum_d [d|a_i]\sum_{j=1}^n[d|b_j] \varphi(d)  \right)^2 \\
G_x &=\sum_{j=1}^n[x|b_j]\varphi(x) \\
tot_2 &=  \sum_{i=1}^n \left( \sum_{d|a_i} G_d  \right)^2 \\
\end{aligned}
$$
#### $tot_4$
$$tot4=F$$
```cpp

int n;
int a[N], b[N];
int ca[N], cb[N];
ModInt F[N], f[N], sa[N], sb[N];
ModInt S[N], G[N];
ModInt res[3], tot[5];
int phi[N];

namespace Sieve {
    vector<int> pri;
    bool npr[N];

    void sieve() {
        phi[1] = 1;
        for (int i = 2; i < N; i++) {
            if (!npr[i]) {
                pri.push_back(i);
                phi[i] = i - 1;
            }
            for (int j : pri) {
                if (i * j >= N) break;
                npr[i * j] = true;
                if (i % j == 0) {
                    phi[i * j] = phi[i] * j;
                    break;
                }
                phi[i * j] = phi[i] * phi[j];
            }
        }
    }
}

signed main() {
    Sieve::sieve();
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    
    cin >> n;
    fup(i, 1, n) cin >> a[i], ca[a[i]]++;
    fup(i, 1, n) cin >> b[i], cb[b[i]]++;

    /* F_x / f_x */
    fup(i, 1, W) for(int j = i; j <= W; j += i) {
        sa[i] += ca[j];
        sb[i] += cb[j];
    }
    fup(i, 1, W) f[i] = sa[i] * sb[i];
    fdn(i, W, 1) {
        F[i] = f[i];
        for(int j = i + i; j <= W; j += i) F[i] -= F[j];
    }
    
    /* res 1 */
    fup(i, 1, W) res[1] += F[i] * i * i;


    /* res 2 */
    /*   tot 1   */
    fup(i, 1, W) tot[1] += F[i] * i; tot[1] = tot[1] * tot[1];
    /*   tot 2   */
    mms(G, 0); mms(S, 0);
    fup(i, 1, W) for(int j = i; j <= W; j += i) G[i] += cb[j] * phi[i];
    fup(i, 1, W) for(int j = i; j <= W; j += i) S[j] += G[i];
    fup(i, 1, n) tot[2] += S[a[i]] * S[a[i]];
    /*   tot 3   */
    mms(G, 0); mms(S, 0);
    fup(i, 1, W) for(int j = i; j <= W; j += i) G[i] += ca[j] * phi[i];
    fup(i, 1, W) for(int j = i; j <= W; j += i) S[j] += G[i];
    fup(i, 1, n) tot[3] += S[b[i]] * S[b[i]];
    /*   tot 4   */
    tot[4] = res[1];
    res[2] = tot[1] - tot[2] - tot[3] + tot[4];

    fup(i, 1, n-1) res[1] *= i;
    fup(i, 1, n-2) res[2] *= i;

    cout << (res[1] - (res[1] + res[2]) / n) / n << endl;
}
```
## $n\le 5\times 10^6$
### 倍数卷积
对于这一类的式子
#### 一
$$
\begin{aligned}
f_i&=\sum_{i|d} g_d
\end{aligned}
$$
```cpp
for(int i=1;i<=n;i++)f[i]=g[i];

for(int i=1;i<=(*p);i++)
	for(int j=n/p[i];j>=1;j--)
			f[j]+=f[j*p[i]];
```
#### 二
$$f_i=\sum_{d|i}g_d$$
```cpp
for(int i=1;i<=n;i++)f[i]=g[i];

for(int i=1;i<=(*p);i++)
	for(int j=1;j<=n/p[i];j++)
			f[j*p[i]]+=f[j];
```
时间复杂度： $\Theta(n\log\log n)$ 

所以 
+ $sa,sb,S_2,S_3$ 都可以优化至 $\Theta(n\log\log n)$。
+ $\varphi$ 是 $\Theta(n)$
+ $F$ 是自卷积，复杂度 $\Theta (n\log n)$

**$F$ 是经典 $\gcd$ 容斥，改为欧拉反演**
$$
\begin{aligned}
tot_1&=\left(\sum_{i=1}^n\sum_{j=1}^n \gcd(a_i,b_j)\right)^2\\
&=\left(\sum_{i=1}^n\sum_{d|\gcd(a_i,b_j)}\varphi(d)\right)^2\\
&=\left(\sum_{d=1}^n sa_dsb_d\varphi(d)\right)^2 \\
\end{aligned}
$$
$$
\begin{aligned}
res_1=\sum_{i=1}^n\sum_{j=1}^n{\gcd}^2(a_i,b_j)
\end{aligned}
$$
考虑设 $n^2=\sum\limits_{d|n}\tau(d)$。
狄利克雷卷积形式：
$$
id_2=\tau*\mathbb 1 \Longrightarrow id_2*\mathbb 1^{-1}=\tau
$$
所以 $\tau$ 是积性函数，直接上线性筛。
$$
\begin{aligned}
\tau(p^k)&=\sum_{i=0}^k id_2(p^i)\mu(p^{k-i})\\
&=id_2(p^k)-id_2(p^{k-1})
\end{aligned}
$$
结束了。{ }
# 代码
```cpp
// clang-format off
/*
Time: 
lable []
Wrong Answer:
    1. 
*/
#include<bits/stdc++.h>
#include<bits/extc++.h>
#define fup(i, bg, ed) for(int i = (bg); i <= (ed); ++i)
#define fdn(i, bg, ed) for(int i = (bg); i >= (ed); --i)
#define mms(f, x) memset(f, x, sizeof f)
#ifdef cDebug
FILE* dbg_stream = fopen("dbg.log", "w");
#define pdbg(...) fprintf(dbg_stream, __VA_ARGS__), fflush(dbg_stream)
#else 
#define pdbg(...) 1
#endif

typedef long long lld;
const int N = 1e6+10;
const int W = 1e6;
using namespace std;

const int P = 1e9 + 7;

lld qpow(lld x, lld p=P-2){
    lld res=1;
    for(;p;p>>=1,x=x*x%P)if(p&1)res=res*x%P;
    return res;
}
struct ModInt {
    int x;
    ModInt(lld _x) : x(_x) {}
    ModInt() : x(0) {}
    friend ModInt operator * (const ModInt& l,const ModInt& r){
        return {1ll * l.x * r.x % P };
    }
    friend ModInt operator ^ (const ModInt& l,const int& r){
        return {qpow(l.x,r)};
    }
    friend ModInt operator ^ (const ModInt& l,const ModInt& r){
        return {qpow(l.x,r.x)};
    }
    friend ModInt operator / (const ModInt& l,const ModInt& r){
        return {1ll * l.x * qpow(r.x) % P};
    }
    friend ModInt operator + (const ModInt& l,const ModInt& r){
        return {(l.x + r.x) % P};
    }
    friend ModInt operator - (const ModInt& l,const ModInt& r){
        return {(l.x - r.x + P) % P};
    }
    friend ModInt& operator += (ModInt& l,const ModInt& r){
        return l=l+r;
    }
    friend ModInt& operator *= (ModInt& l,const ModInt& r){
        return l=l*r;
    }
    friend ModInt& operator -= (ModInt& l,const ModInt& r){
        return l=l-r;
    }
    friend ModInt& operator /= (ModInt& l,const ModInt& r){
        return l=l/r;
    }
    ModInt& operator= (const int& r){
        return *this=ModInt(r);
    }
};

ostream& operator<<(ostream& os, ModInt&& r) {
    os << r.x;
    return os;
}
ostream& operator<<(ostream& os, ModInt& r) {
    os << r.x;
    return os;
}

int n;
int a[N], b[N];
int ca[N], cb[N];
ModInt F[N], f[N];
ModInt sa[N], sb[N];
ModInt S[N], G[N];
ModInt res[3], tot[5];
ModInt phi[N], tau[N];
vector<int> prs;

namespace Sieve {
    bool npr[N];

    void sieve() {
        phi[1] = 1; tau[1] = 1;
        for (int i = 2; i < N; i++) {
            if (!npr[i]) {
                prs.push_back(i);
                phi[i] = i - 1;
                tau[i] = ModInt(i) * i - 1;
            }
            for (int j : prs) {
                if (i * j >= N) break;
                npr[i * j] = true;
                if (i % j == 0) {
                    phi[i * j] = phi[i] * j;
                    tau[i * j] = tau[i] * j * j;
                    break;
                }
                phi[i * j] = phi[i] * phi[j];
                tau[i * j] = tau[i] * tau[j];
            }
        }
    }
}

signed main() {
    Sieve::sieve();
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    
    cin >> n;
    fup(i, 1, n) cin >> a[i], ca[a[i]]++;
    fup(i, 1, n) cin >> b[i], cb[b[i]]++;

    /* F_x / f_x */
    // fup(i, 1, W) for(int j = i; j <= W; j += i) {
    //     sa[i] += ca[j];
    //     sb[i] += cb[j];
    // }
    fup(i, 1, W) sa[i] = ca[i];
    fup(i, 1, W) sb[i] = cb[i];
    for(int pr: prs) for(int j = W / pr; j >= 1; j--) sa[j] += sa[j * pr], sb[j] += sb[j * pr];

    // fup(i, 1, W) f[i] = sa[i] * sb[i];
    // fdn(i, W, 1) {
    //     F[i] = f[i];
    //     for(int j = i + i; j <= W; j += i) F[i] -= F[j];
    // }
    
    /* res 1 */
    // fup(i, 1, W) res[1] += F[i] * i * i;
    fup(i, 1, W) res[1] += sa[i] * sb[i] * tau[i];



    /* res 2 */
    /*   tot 1   */
    // fup(i, 1, W) tot[1] += F[i] * i; tot[1] = tot[1] * tot[1];
    fup(i, 1, W) tot[1] += sa[i] * sb[i] * phi[i]; tot[1] = tot[1] * tot[1];
    /*   tot 2   */
    mms(G, 0); mms(S, 0);
    fup(i, 1, W) G[i] = sb[i] * phi[i];
    // fup(i, 1, W) for(int j = i; j <= W; j += i) S[j] += G[i];
    fup(i, 1, W) S[i] = G[i]; 
    for(int pr: prs) for(int j = 1; j <= W / pr; j++) S[j * pr] += S[j];
    fup(i, 1, n) tot[2] += S[a[i]] * S[a[i]];
    /*   tot 3   */
    mms(G, 0); mms(S, 0);
    fup(i, 1, W) G[i] = sa[i] * phi[i];
    // fup(i, 1, W) for(int j = i; j <= W; j += i) S[j] += G[i];
    fup(i, 1, W) S[i] = G[i]; 
    for(int pr: prs) for(int j = 1; j <= W / pr; j++) S[j * pr] += S[j];
    fup(i, 1, n) tot[3] += S[b[i]] * S[b[i]];
    /*   tot 4   */
    tot[4] = res[1];
    res[2] = tot[1] - tot[2] - tot[3] + tot[4];

    fup(i, 1, n-1) res[1] *= i;
    fup(i, 1, n-2) res[2] *= i;

    cout << (res[1] - (res[1] + res[2]) / n) / n << endl;
}
```

---

## 作者：封禁用户 (赞：1)

首先，我们注意到方差 $\sigma(x)$ 的定义中包含了平方项和平均数的计算，这在模运算下会变得复杂。为了简化问题，我们可以先考虑方差的另一种形式，即

$$\sigma(x) = \frac{1}{n}\sum_{i=1}^{n}x_i^2 - \left(\frac{1}{n}\sum_{i=1}^{n}x_i\right)^2$$

这是因为

$$\sum_{i=1}^{n}(x_i - \bar{x})^2 = \sum_{i=1}^{n}x_i^2 - 2\bar{x}\sum_{i=1}^{n}x_i + n\bar{x}^2 = \sum_{i=1}^{n}x_i^2 - n\bar{x}^2$$

现在，我们定义 $A = \sum_{i=1}^{n}a_i^2$，$B = \sum_{i=1}^{n}b_i^2$，$C = \sum_{i=1}^{n}a_i$，$D = \sum_{i=1}^{n}b_i$，以及 $G(d)$ 为所有满足 $\gcd(a_i, b_j) = d$ 的 $(i, j)$ 对的数量。

对于每一个 $d$，我们考虑所有可能的 $c_i = \gcd(a_i, b_{p_i}) = d$ 的情况。这样的 $c_i$ 会出现 $G(d)$ 次，因此它们对方差的贡献是

$$\frac{G(d) \cdot d^2}{n} - \left(\frac{G(d) \cdot d}{n}\right)^2$$

由于我们需要对所有可能的 $p$ 求和，因此总的方差和为

$$\sum_{d=1}^{\max(a_i, b_i)} \left( \frac{G(d) \cdot d^2}{n} - \left(\frac{G(d) \cdot d}{n}\right)^2 \right)$$

注意到 $G(d)$ 可以通过预处理 $a_i$ 和 $b_i$ 的因子来快速计算。

现在，我们定义 $M = 10^9 + 7$，并注意到在模 $M$ 下，我们可以将上述公式重写为

$$\sum_{d=1}^{\max(a_i, b_i)} \left( \frac{G(d) \cdot d^2 \cdot (n - G(d))}{n^2} \right) \mod M$$

这是因为 $\left(\frac{G(d) \cdot d}{n}\right)^2 = \frac{G(d)^2 \cdot d^2}{n^2}$，而 $G(d) \cdot (n - G(d))$ 是 $G(d)$ 和 $n - G(d)$ 的配对数，这对应于 $c_i = d$ 和 $c_i \neq d$ 的情况。

最后，我们注意到 $n$ 在分母中，但我们可以预先计算 $n^{-1}$（即 $n$ 在模 $M$ 下的乘法逆元）来避免在模运算中除以 $n$。

---


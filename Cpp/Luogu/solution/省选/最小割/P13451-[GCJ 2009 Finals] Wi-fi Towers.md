# [GCJ 2009 Finals] Wi-fi Towers

## 题目描述

你将得到一个由无线信号塔组成的网络。每个信号塔都有一定的覆盖半径，并且只要相邻信号塔之间的距离不超过发送塔的覆盖半径，就可以向其发送数据。

这些信号塔目前使用的是旧的通信协议 $A$，但现在有一种更新、更好的协议 $B$ 可供升级。我们正在考虑将部分信号塔升级为协议 $B$，以获得更好的带宽。

但有一个重要的限制：如果某个信号塔 $T$ 升级为新协议 $B$，那么在 $T$ 覆盖范围内的所有信号塔也必须升级为协议 $B$，以便它们能够理解 $T$ 发送的数据。反过来则不要求——使用新协议 $B$ 的信号塔可以接收来自旧协议 $A$ 的信号。

你的任务是选择一组信号塔进行升级，使得升级后信号塔的总得分最大。每个信号塔升级的价值（即得分）可能为正也可能为负。你需要选择升级哪些信号塔，使得升级塔的总得分最大。

## 说明/提示

**限制条件**

- $1 \leq T \leq 55$
- $-10000 \leq x, y \leq 10000$
- $1 \leq r \leq 20000$
- $-1000 \leq s \leq 1000$
- 不会有两个信号塔的坐标完全相同。

**小数据集（3 分）**

- $1 \leq n \leq 15$

**大数据集（25 分）**

- $1 \leq n \leq 500$

翻译由 ChatGPT-4.1 完成。

## 样例 #1

### 输入

```
1
5
0 1 7 10
0 -1 7 10
5 0 1 -15
10 0 6 10
15 1 2 -20```

### 输出

```
Case #1: 5```

# 题解

## 作者：chen_zhe (赞：0)

本题解来自于[《挑战程序设计竞赛》](https://www.luogu.com.cn/training/813583)。

---

这个问题可以归约到 $s$-$t$ 最小割问题上。我们加入 $s$， $t$ 顶点，然后考虑把这两个顶点分开的割中的最小割。

首先，很自然地想到对于一个割割成的两个顶点集合，让其中一个全部使用“协议 B”，另一个全部使用“协议 A”。这里不妨假设包含 $s$ 的集合使用“协议 B”，包含 $t$ 的集合使用 “协议A”。

由于是“最小”割，就需要搞清楚最小化的是什么。看起来最小化“损失” 是一个比较合理的解释。我们先不考虑无线电塔之间的互相关系，而是先考虑怎么归约到最小割上。在这里，每一个无线电塔对应图中的一个顶点。

分数为负的的无线电塔如果和 $s$ 相连，也就是升级到了协议 B，就产生了损失，因此和 $s$ 之间连一条容量为分数的绝对值的边。由于如果和 $t$ 相连，也就是维持协议 A 不变，就没有收益也没有损失，因此不需要连边（也可以看成是连了一条容量为 $0$ 的边）。

分数为正的的无线电塔如果从 $s$ 可达，也就是升级到了协议 B，就可以看成是产生了负的损失，但是之后根据最大流最小割定理用最大流求解的话，是不能有容量为负的边的。因此，我们认为分数为正的的无线电塔最开始就是以协议 B 通讯的，这样使用协议 B 的损失是 $0$，而如果使用协议 A 则损失了对应的分数。这样，就可以使得所有边的容量都是正的（注意在求完最小割之后，还需要加上这些分数）。

接下来只需要搞清楚电波之间的关系并加入图中，就可以归约到最小割了。我们要将升级无线电塔 $i$ 时，其他的无线电塔 $j$ 也必须升级这一关系加入图中。

需要防止的情况是 $i$ 和 $s$ 相连，同时 $j$ 和 $t$ 相连。在这种情况下，从 $i$ 到 $j$ 的边（如果存在的话）一定属于割集。因此，我们可以从 $i$ 向 $j$ 连一条容量是 $\infty$ 的边，这样最小割就不会包含这条边，因为若 $i$ 和 $s$ 相连，则 $j$ 也一定和 $s$ 相连，从而满足了限制条件。①

① 请注意在这个构图中的相反的情况，也就是 $j$ 和 $s$ 相连，同时 $i$ 和 $t$ 相连是允许的。另外，有向图的割等于从和 $s$ 相连的顶点集合出发，到和 $t$ 相连顶点集合的边的容量之和。

综上所述，原问题归约到了最小割上。根据最大流最小割定理，接下来只需要使用合适的最大流算法就可以了。这一类问题也被叫做最大权闭合图问题。

```cpp
// 输入
int n, x[MAX_N], y[MAX_N], r[MAX_N], s[MAX_N];

int sqr(int x) {
    return x * x;
}

void solve() {
    // 把n作为源点、n+1作为汇点共n+2个顶点的网络
    rep(v, n + 2) G[v].clear();

    int ans = 0;
    for (int i = 0; i < n; i++) {
        if (s[i] < 0) {
            add_edge(n, i, -s[i]);
        } else {
            ans += s[i];
            add_edge(i, n + 1, s[i]);
        }
    }

    for (int j = 0; j < n; j++) {
        if (i == j) continue;
        if (sqr(x[i] - x[j]) + sqr(y[i] - y[j]) <= sqr(r[i])) {
            add_edge(j, i, INF);
        }
    }

    ans -= max_flow(n, n + 1);
    printf("%d\n", ans);
}
```

---


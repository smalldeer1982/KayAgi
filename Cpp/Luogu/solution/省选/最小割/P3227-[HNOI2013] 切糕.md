# [HNOI2013] 切糕

## 题目描述

经过千辛万苦小 A 得到了一块切糕，切糕的形状是长方体，小 A 打算拦腰将切糕切成两半分给小 B。出于美观考虑，小 A 希望切面能尽量光滑且和谐。于是她找到你，希望你能帮她找出最好的切割方案。

出于简便考虑，我们将切糕视作一个长 $P$、宽 $Q$、高 $R$ 的长方体点阵。我们将位于第 $z$ 层中第 $x$ 行、第 $y$ 列上的点称 $(x,y,z)$，它有一个非负的不和谐值 $v(x,y,z)$。一个合法的切面满足以下两个条件：

 - 与每个纵轴（一共有 $P\times Q$ 个纵轴）有且仅有一个交点。即切面是一个函数 $f(x,y)$，对于所有 $(x,y)(x\in [1,P],y\in[1,Q])$，我们需指定一个切割点 $f(x,y)$，且 $1\le f(x,y)\le R$。

 - 切面需要满足一定的光滑性要求，即相邻纵轴上的切割点不能相距太远。对于所有的 $1\le x,x'\le P$ 和 $1\le y,y'\le Q$，若 $|x-x'|+|y-y'|=1$，则 $|f(x,y)-f(x',y')| \le D$，其中 $D$ 是给定的一个非负整数。

可能有许多切面 $f$ 满足上面的条件，小 A 希望找出总的切割点上的不和谐值最小的那个。

## 说明/提示

#### 输入输出样例 1 解释

最佳切面的 $f$ 为 $f(1,1)=f(2,1)=2,f(1,2)=f(2,2)=1$。

---
#### 数据规模与约定

对于 $100\%$ 的数据，$1 \leq P,Q,R\leq 40,0\le D\le R$，且给出的所有的不和谐值不超过 $1000$。

## 样例 #1

### 输入

```
2 2 2
1
6 1
6 1
2 6
2 6```

### 输出

```
6```

# 题解

## 作者：dengyaotriangle (赞：101)

## 注意：本文不是题解，而是正确性证明。
之前想过这个问题，看到确实有很多人像我一样的对正确性有疑问，就写一个详细的证明吧。

大多数本题解法给出了这样一个建图方式：建一条条链，具体，令 $(a,b)$ 为第 $a$ 条链第 $b$ 个点，建有向边：

1. $((a,b),(a,b+1),cost_{a,b})$
2. $ (S,(a,1),\infty)$
3. $((a,m),T,\infty)$
4. $\forall x,y,z$ ，$x,y$ 相邻，$((x,z),(y,z-D),\infty)$

跑最小割，令第 $a$ 个点选了第 $b$ 个位置表现为割了边 $((a,b),(a,b+1))$，那么由于第 4 类边，一组合法的割必然满足 $|a_i-a_j|\leq D$，所以最小割就是答案。

注意到了啥？**不加证明的声称了一条链最多割一条边。** 为啥是对的？

## 1. 我们改个建图吧！
加第五类边： $((a,b),(a,b-1),\infty)$ 即可。显然，在一条链只割一条边的情况下，加了这条边后原来的割依然是割。

注意到这也是题目 [P6054](https://www.luogu.com.cn/problem/P6054) 的处理方式。

那道题的限制的种类更加丰富：给 $n$ 个变量 $a_i$，第 $i$ 个选 $j$ 代价 $c_{i,j}$ 且有若干个 $a_{v_i}\geq a_{u_i}+k_i$ 的限制。

其实，那这道题中，若不存在我们新加的第五类边，则真的有可能最优方案割了两条边。

为啥是对的，首先考虑一个引理：

**引理**：在割去最小割后，最小割的割边 $(u,v)$ 必须满足 $S\to u,v\to T$，其中 $\to$ 表示可以到达。

**证**：若 $S\to u$ ，$v\to T$ 任意一个不成立，不割这条边一定还是个割，且更优。

接下来就简单了，假设最小割有一条链，上面被割了$\geq2$ 条边，那么考虑相邻的两个割边，由于引理，第一个割边右边可以到 $T$ 、第二个左边可以到 $S$ ，那么由于有第五类边，那么无论怎样，$S\to T$，与是个割矛盾。

![](https://cdn.luogu.com.cn/upload/image_hosting/6sces8dw.png)

## 2. 本题的特殊性

但本题相比于 [P6054](https://www.luogu.com.cn/problem/P6054) 有个特殊的点：$D\geq 0$


若存在一条链被割两次以上。现基于割掉最小割后的图建一个新图：

对于每条链，若割了若干条边：$((a,k_1),(a,k_1+1)),((a,k_2),(a,k_2+1)),\cdots((a,k_t),(a,k_t+1)),$

那么，建 $t+1$ 个新点 $[a,1],[a,2],\cdots [a,t+1]$，代表被割开的一段一段的链。

![](https://cdn.luogu.com.cn/upload/image_hosting/1z5q0qh9.png)

其中，根据前面所说的引理， $[a,2]\cdots,[a,t]$ 里面都存在点可以从 $S$ 到达，也存在点可以到达 $T$。

所以对于  $[a,2]\cdots,[a,t]$  这些新点，对于每个新点 $[a,k]$，考虑它代表的点的区间所有点 $(a,c)$，若存在边 $((b,c+D),(a,c),\infty)$，且 $S\to (b,c+D)$。 且 $(b,c+D)$ 在 $[b,k']$ 里面，那么从 $[b,k']$ 向 $[a,k]$ 连一条边。

![](https://cdn.luogu.com.cn/upload/image_hosting/45xas4t2.png)
（例如本图中，假设 $S\to$ $[b,2]$ 的最后一个点，那么$[b,2]$ 向 $[a,2]$ 连一条边）

由于 $S$ 可以到达 $[a,i]$ （$2\leq i\leq t_a$），那么对于新图，必然存在边 $([a,1],[b,i])$ （$2\leq i\leq t_b$）。因为若不存在这样的边，必然所有点都无法从 $S$ 到达。

那么，考虑  $([a,1],[b,i])$ 这条边存在导致的问题吧。

由于 $D\geq 0$，所以边都是向源点方向连的，所以 $[b,i]$ 里第一个可以被 $[a,1]$ 到达的点必然为最左端点。而可以到达最左端点则意味着可以到达所有点，而回顾之前我们说的一定存在一个点可以到达 $T$，这意味着 $S\to T$，矛盾。

![](https://cdn.luogu.com.cn/upload/image_hosting/w9zbopy2.png)

综上，一定不存在点 $[a,i]$ （$2\leq i\leq t_a$），也就是每条链必然割一条边。得证。

至于问我为啥 $D<0$ 这个证明就不行了，考虑：

![](https://cdn.luogu.com.cn/upload/image_hosting/0usfl1n2.png)

左边的那条虚线边不存在。所以证明无法进行下去。就真的有可能出现两个割边之间，前面一段可以到 $T$ 后面一段可以从 $S$ 到达的合法的两个割边的情况了。

其实根据这个证明不难想到另一种解决 [P6054](https://www.luogu.com.cn/problem/P6054) 的方式：手动把缺的那些边补上就好。对于 $a_{v_i}\geq a_{u_i}+k_i$ 的限制，若 $k_i>0$ 那么从 $S$ 开始向 $(v_i,1),\cdots (v_i,k_i)$ 连 $\infty$ 边，把那些缺少的边补上就好。

---

## 作者：Mihari (赞：86)

# 「题解」「HNOI2013」切糕

## 题目描述

[点这里](https://www.luogu.com.cn/problem/P3227)

## 思路分析及代码

### 题目分析

这道题的题目可以说得上是史上最难看懂的题目之一了...

首先把题目重新叙述一遍。

题目大致在说，你有一个 $P\times Q\times R$ 的蛋糕，每个点有一个不客观度 $v[i][j][k]$ ，现在你要把这个蛋糕切开。

切蛋糕的规则是什么呢？

首先我们解释一下：

对于每一竖列，这个竖列的坐标用 $(x,y)$ 表示。

也就是说，这个竖列上的点的坐标可以表示为 $(x,y,i)|i\in [1,R]$ 。

那么，规则很好描述：

我们要在所有的 $P\times Q$ 个竖列中，每个竖列选**一个**点。

对于一个竖列 $(x,y)$ 中，把我们选的点的高表示为 $f(x,y)$ 。

那么很好有 $1\le f(x,y)\le R$ 。

而我们选的点的坐标就是 $(x,y,f(x,y))$ 。

>竖列相邻：对于一个坐标为 $(x,y)$ 的竖列，相邻即指坐标为 $(i+1,j)、(i-1,j)、(i,j+1)、(i,j-1)$ 的竖列。

但是有一个限制，对于**相邻**的竖列，在他们上所选择的点的高度差不超过 $D$ ，即：

$$|f(x,y)-f(x,y\pm1)|\le D\space, \space |f(x,y)-f(x\pm 1,y)|\le D$$

而现在我们的目的是，对于我们所有选出的点，使得 $\sum v[i][j][f(i,j)]$ 最小。

### 题解及代码

这道题怎么思考？

首先，我们考虑：如果没有这个 $D$ ，我们应该怎么做？

这个题就转化为：求每一竖列的最短边之和。

这样的问题，似乎几个循环就可以解决。

但是，这样的题是否有些像**最小割问题**？

那么，此题的方法呼之欲出：网络流最大流最小割问题。

如果解决 `每一竖列的最短边之和` 这样的问题用网络流，建图方法很简单：

建立第 $0$ 层与第 $R+1$ 层，然后有这样的连边关系：

>$S->(i,j,1),flow=INF$
>
>$(i,j,k)->(i,j,k+1),flow=v[i][j][k]|k\in [1,R)$
>
>$(i,j,r)->T,flow=v[i][j][r]$

但是对于此题，我们还有 $D$ 的限制。

现在考虑怎么把这样的限制考虑进我们的网络流。

假设我们有这样一个图：

![graph.png](https://i.postimg.cc/FFkMrF2j/graph-3.png)

其中， $A=\{p1,p2,p3,p4\}$ 代表第 $a$ 列， $B=\{p5,p6,p7,p8\}$ 代表第 $b$ 列。

断言，现在的 $D$ 的值为 $1$ 。

那么，从题目的表示来说，假设我们在 $A$ 中选择了 $p3$ ，那么我们就只能在 $B$ 中选择 $p6,p7,p8$ 。

现在，我们做一个尝试，连接一条边 $edge\{p3,p6\}$ 。

![](https://i.postimg.cc/44c0CL9P/graph-2.png)

那么，如果我们再跑最大流时，如果我们将 $edge\{p5,p6\}$ 删掉，对 $path\{S,p1,p2,p3,p6,p7,p8\}$ 似乎没有影响。

但是又有一个问题：如果我们选的点比 $p3$ 高**出**了 $D$ 呢？

其实这个问题是一样的：我们连接 $edge\{p8,p3\}$ ，那么就有这个图：

![](https://i.postimg.cc/7YYQCxRs/graph-4.png)

那么问题就解决了。

所以，我们解决 $D$ 对于我们的限制，就是再添加几条边条边：

> $(i,j,k)->(i\pm 1,j,k-d)$
>
> $(i,j,k)->(i,j\pm 1,k-d)$
>
> 对于 $k$ ，满足 $k>d$

那么，这个题就算是解决了。

接下来是代码。

```cpp
#include<cstdio>
#include<queue>
using namespace std;

#define rep(i,__l,__r) for(int i=__l,i##_end_=__r;i<=i##_end_;++i)
#define fep(i,__l,__r) for(int i=__l,i##_end_=__r;i>=i##_end_;--i)
#define writc(a,b) fwrit(a),putchar(b)
#define mp(a,b) make_pair(a,b)
#define ft first
#define sd second
#define LL long long
#define ull unsigned long long
#define pii pair<int,int>
#define Endl putchar('\n')
// #define FILEOI
// #define int long long

#ifdef FILEOI
    #define MAXBUFFERSIZE 500000
    inline char fgetc(){
        static char buf[MAXBUFFERSIZE+5],*p1=buf,*p2=buf;
        return p1==p2&&(p2=(p1=buf)+fread(buf,1,MAXBUFFERSIZE,stdin),p1==p2)?EOF:*p1++;
    }
    #undef MAXBUFFERSIZE
    #define cg (c=fgetc())
#else
    #define cg (c=getchar())
#endif
template<class T>inline void qread(T& x){
    char c;bool f=0;
    while(cg<'0'||'9'<c)f|=(c=='-');
    for(x=(c^48);'0'<=cg&&c<='9';x=(x<<1)+(x<<3)+(c^48));
    if(f)x=-x;
}
inline int qread(){
    int x=0;char c;bool f=0;
    while(cg<'0'||'9'<c)f|=(c=='-');
    for(x=(c^48);'0'<=cg&&c<='9';x=(x<<1)+(x<<3)+(c^48));
    return f?-x:x;
}
template<class T,class... Args>inline void qread(T& x,Args&... args){qread(x),qread(args...);}
template<class T>inline T Max(const T x,const T y){return x>y?x:y;}
template<class T>inline T Min(const T x,const T y){return x<y?x:y;}
template<class T>inline T fab(const T x){return x>0?x:-x;}
inline int gcd(const int a,const int b){return b?gcd(b,a%b):a;}
inline void getInv(int inv[],const int lim,const int MOD){
    inv[0]=inv[1]=1;for(int i=2;i<=lim;++i)inv[i]=1ll*inv[MOD%i]*(MOD-MOD/i)%MOD;
}
template<class T>void fwrit(const T x){
    if(x<0)return (void)(putchar('-'),fwrit(-x));
    if(x>9)fwrit(x/10);putchar(x%10^48);
}
inline LL mulMod(const LL a,const LL b,const LL mod){//long long multiplie_mod
    return ((a*b-(LL)((long double)a/mod*b+1e-8)*mod)%mod+mod)%mod;
}

const int MAXP=40;
const int INF=(1<<30)-1;

int p,q,r,d,S,T;
int v[MAXP+5][MAXP+5][MAXP+5];

struct edge{
    int to,nxt,w;
    edge(){}
    edge(const int T,const int N,const int W):to(T),nxt(N),w(W){}
}e[(MAXP*MAXP*MAXP*10)+5];
int tail[MAXP*MAXP*MAXP*MAXP+5],ecnt;
int cur[MAXP*MAXP*MAXP*MAXP+5];
inline void add_edge(const int u,const int v,const int w){
    // printf("add_edge:>u == %d, v == %d, w == %d\n",u,v,w);
    e[++ecnt]=edge(v,tail[u],w);tail[u]=ecnt;
}

inline int id(const int x,const int y,const int z){return x*40*40+y*40+z;}

inline bool inside(const int x,const int y,const int z){
    return 0<x && x<=p && 0<y && y<=q && 0<z && z<=r;
}

int dis[MAXP*MAXP*MAXP*MAXP+5];
inline bool bfs(){
    rep(i,0,id(p,q,r)+1)dis[i]=-1;
    dis[S]=0;
    queue<int>Q;Q.push(S);
    while(!Q.empty()){
        int u=Q.front();Q.pop();
        for(int i=tail[u],v;i;i=e[i].nxt){
            v=e[i].to;
            if(dis[v]!=-1 || e[i].w<=0)continue;
            dis[v]=dis[u]+1;
            Q.push(v);
        }
    }
    return dis[T]!=-1;
}

int dfs(const int u,int inflow){
    if(u==T)return inflow;
    int sum=0,tmp,v;
    for(int& i=cur[u];i;i=e[i].nxt){
        v=e[i].to;
        if(dis[v]!=dis[u]+1 || e[i].w<=0)continue;
        tmp=dfs(v,Min(inflow-sum,e[i].w));
        e[i].w-=tmp,e[i^1].w+=tmp;
        if((sum+=tmp)>=inflow)break;
    }
    return sum;
}

inline int dinic(){
    int max_flow=0;
    while(bfs()){
        rep(i,0,id(p,q,r)+1)cur[i]=tail[i];
        max_flow+=dfs(S,INF);
    }
    return max_flow;
}

signed main(){
#ifdef FILEOI
    freopen("file.in","r",stdin);
    freopen("file.out","w",stdout);
#endif
    ecnt=1;
    qread(p,q,r,d);
    S=0,T=id(p,q,r)+1;
    // printf("S == %d, T == %d\n",S,T);
    rep(k,1,r)rep(i,1,p)rep(j,1,q)qread(v[i][j][k]);
    rep(i,1,p)rep(j,1,q){
        add_edge(S,id(i,j,1),INF);
        add_edge(id(i,j,1),S,0);
    }
    rep(k,1,r-1)rep(i,1,p)rep(j,1,q){
        add_edge(id(i,j,k),id(i,j,k+1),v[i][j][k]);
        add_edge(id(i,j,k+1),id(i,j,k),0);
        if(k<=d)continue;
        // puts("the special edge:");
        if(inside(i+1,j,k-d)){
            add_edge(id(i,j,k),id(i+1,j,k-d),INF);
            add_edge(id(i+1,j,k-d),id(i,j,k),0);
        }
        if(inside(i-1,j,k-d)){
            add_edge(id(i,j,k),id(i-1,j,k-d),INF);
            add_edge(id(i-1,j,k-d),id(i,j,k),0);
        }
        if(inside(i,j+1,k-d)){
            add_edge(id(i,j,k),id(i,j+1,k-d),INF);
            add_edge(id(i,j+1,k-d),id(i,j,k),0);
        }
        if(inside(i,j-1,k-d)){
            add_edge(id(i,j,k),id(i,j-1,k-d),INF);
            add_edge(id(i,j-1,k-d),id(i,j,k),0);
        }
        // puts("-------------end-------------");
    }
    rep(i,1,p)rep(j,1,q){
        add_edge(id(i,j,r),T,v[i][j][r]);
        add_edge(T,id(i,j,r),0);
        if(r<=d)continue;
        // puts("the special edge:");
        if(inside(i+1,j,r-d)){
            add_edge(id(i,j,r),id(i+1,j,r-d),INF);
            add_edge(id(i+1,j,r-d),id(i,j,r),0);
        }
        if(inside(i-1,j,r-d)){
            add_edge(id(i,j,r),id(i-1,j,r-d),INF);
            add_edge(id(i-1,j,r-d),id(i,j,r),0);
        }
        if(inside(i,j+1,r-d)){
            add_edge(id(i,j,r),id(i,j+1,r-d),INF);
            add_edge(id(i,j+1,r-d),id(i,j,r),0);
        }
        if(inside(i,j-1,r-d)){
            add_edge(id(i,j,r),id(i,j-1,r-d),INF);
            add_edge(id(i,j-1,r-d),id(i,j,r),0);
        }
        // puts("-------------end-------------");
    }
    int ret=dinic();
    writc(ret,'\n');
    return 0;
}
```

**一道十分好的题**。

---

## 作者：xyz32768 (赞：31)

把切点看作割边。新建一个虚拟的层$R+1$，建立源点$S,T$。

先不考虑光滑限制。先由源点$S$向第$1$层的每一个点连一条边，再由第$R+1$层的每一个点向汇点$T$连一条边，这些边是割不掉的，所以容量都为$INF$。

然后对于任何一个$1\leq i\leq P,1\leq j\leq Q,1\leq k\leq R$，由$(i,j,k)$向$(i,j,k+1)$连一条容量为$(i,j,k)$的不和谐值的边。

显然，对于任何一个$1\leq i\leq P,1\leq j\leq Q$，从$(i,j,1)$到$(i,j,R+1)$的路径上需要且只需要割掉一条边。

再考虑光滑限制。可以发现对于任意一个在同一平面上距离为$1$的两个点对$(i,j),(x,y)$，其实只要限制$f(i,j)-f(x,y)\leq D$就可以了（因为如果有存在$f(i,j)-f(x,y)<-D$，那么一定有$f(x,y)-f(i,j)>D$，自然不符合条件）。

怎样限制这个条件呢？可以发现，我们的目标其实就是让$f(i,j)-f(x,y)>D$时，$S$仍然可以到达$T$。也就是对于任意一个在同一平面上距离为$1$的两个点对$(i,j),(x,y)$，对于任何一个$D+1\leq k\leq R+1$，由$(i,j,k)$向$(x,y,k-D)$连一条容量为$INF$（割不掉）的边。

最后求最小割（最大流）即为答案。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
const int W = 45, N = 3e5 + 5, INF = 0x3f3f3f3f;
int P, Q, R, D, S, T, val[W][W][W], ecnt = 1, nxt[N], adj[N], go[N], cap[N],
lev[N], len, que[N], dx[] = {-1, 1, 0, 0}, dy[] = {0, 0, -1, 1};
void add_edge(int u, int v, int w) {
    nxt[++ecnt] = adj[u]; adj[u] = ecnt; go[ecnt] = v; cap[ecnt] = w;
    nxt[++ecnt] = adj[v]; adj[v] = ecnt; go[ecnt] = u; cap[ecnt] = 0;
}
bool bfs() {
    int i; memset(lev, -1, sizeof(lev));
    lev[que[len = 1] = S] = 0;
    for (i = 1; i <= len; i++) {
        int u = que[i];
        for (int e = adj[u], v; e; e = nxt[e])
            if (cap[e] > 0 && lev[v = go[e]] == -1) {
                lev[que[++len] = v] = lev[u] + 1;
                if (v == T) return 1;
            }
    }
    return 0;
}
int dinic(int u, int flow) {
    if (u == T) return flow;
    int res = 0, delta;
    for (int e = adj[u], v; e; e = nxt[e])
        if (cap[e] > 0 && lev[u] < lev[v = go[e]]) {
            delta = dinic(v, min(cap[e], flow - res));
            if (delta) {
                cap[e] -= delta; cap[e ^ 1] += delta;
                res += delta; if (res == flow) break;
            }
        }
    if (res != flow) lev[u] = -1;
    return res;
}
int solve() {
    int ans = 0;
    while (bfs()) ans += dinic(S, INF);
    return ans;
}
int main() {
    int i, j, k, h; P = read(); Q = read();
    R = read(); D = read(); S = 1; T = P * Q * (R + 1) + 2;
    for (k = 1; k <= R; k++) for (i = 1; i <= P; i++)
    for (j = 1; j <= Q; j++) val[i][j][k] = read();
    for (i = 1; i <= P; i++) for (j = 1; j <= Q; j++) {
        int x = (i - 1) * Q + j + 1;
        add_edge(S, x, INF); for (k = 1; k <= R; k++)
        add_edge(P * Q * (k - 1) + x, P * Q * k + x, val[i][j][k]);
        add_edge(P * Q * R + x, T, INF);
    }
    for (i = 1; i <= P; i++) for (j = 1; j <= Q; j++)
    for (h = 0; h < 4; h++) {
        int x = i + dx[h], y = j + dy[h];
        if (x < 1 || x > P || y < 1 || y > Q) continue;
        for (k = D + 1; k <= R + 1; k++)
            add_edge(P * Q * (k - 1) + (i - 1) * Q + j + 1,
            P * Q * (k - D - 1) + (x - 1) * Q + y + 1, INF);
    }
    printf("%d\n", solve());
    return 0;
}
```

---

## 作者：木xx木大 (赞：19)

[P3227 [HNOI2013]切糕](https://www.luogu.com.cn/problem/P3227)

第一个限制比较好处理，相当于每个纵轴上选一个点，我们把点权压到边上，就相当于最小割。连边 $S\to(x,y,1)$，流量为 INF；连边 $(x,y,z)\to(x,y,z+1),z\in[1,r]$，流量为点权；连边 $(x,y,z+1)\to T$，流量为 INF。

第二个限制的处理就比较巧妙了。原式相当于若相邻纵轴上的切割点 $f(x,y)-f(x',y')>D$，则不能同时选 $f(x,y)$ 和 $f(x',y')$。**处理方法是，使得当 $f(i,j)-f(x,y)>D$ 时，即使同时割掉这两个点，$S$ 仍然可以到达 $T$**。具体地，建边 $(x,y,z)\to(x',y',z-D)$，边权为 INF。如下图，处理完第一个限制的模型大概长上面那样。若 $D=2$ ，连边 $4'\to 2$ 后，即使同时割掉 $1,4'$ 的边，$S$ 仍然可以到达 $T$。而割掉边权为 INF 的边显然是不优的，最小割不会这样做。所以这样建模就可以处理掉第二个限制了。



![](https://cdn.luogu.com.cn/upload/image_hosting/24rby9fk.png)

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
namespace FGF
{
	int n,m,r,K;
	const int INF=0x3f3f3f3f,N=1e5+5,M=5e5+5;;
	struct edg{
		int to,nxt,w;
	}e[M<<1];
	int cnt=1,head[N],ans,dep[N],S,T,num,cur[N];
	const int dx[4]={0,1,0,-1};
	const int dy[4]={1,0,-1,0};
	void add(int u,int v,int w)
	{
		cnt++;
		e[cnt].to=v;
		e[cnt].nxt=head[u];
		head[u]=cnt;
		e[cnt].w=w;
	}
	void Add(int u,int v,int w){add(u,v,w),add(v,u,0);}
	queue<int> q;
	bool bfs()
	{
		memset(dep,-1,sizeof(dep));
		dep[S]=0;q.push(S);
		while(q.size())
		{
			int u=q.front();q.pop();
			for(int i=head[u];i;i=e[i].nxt)
				if(e[i].w&&dep[e[i].to]==-1)dep[e[i].to]=dep[u]+1,q.push(e[i].to);
		}
		return dep[T]!=-1;
	}
	int dfs(int u,int f)
	{
		if(u==T)return f;
		int w=0,usd=0;
		for(int& i=cur[u];i;i=e[i].nxt)
			if(e[i].w&&dep[e[i].to]==dep[u]+1)
			{
				w=dfs(e[i].to,min(e[i].w,f-usd));
				usd+=w,e[i].w-=w,e[i^1].w+=w;
				if(usd==f)return usd;
			}
		if(!usd)dep[u]=-1;
		return usd;
	}
	int id(int x,int y,int z)
	{
		return (x-1)*n*m+(y-1)*m+z;
	}
	void work()
	{
		scanf("%d%d%d%d",&n,&m,&r,&K);
		T=n*m*(r+1)+1;
		for(int i=1;i<=r;i++)
			for(int j=1;j<=n;j++)
				for(int k=1,x;k<=m;k++)
					scanf("%d",&x),Add(id(i,j,k),id(i+1,j,k),x);
		for(int j=1;j<=n;j++)
			for(int k=1;k<=m;k++)
				Add(S,id(1,j,k),INF),Add(id(r+1,j,k),T,INF);
		for(int i=K+1;i<=r+1;i++)
			for(int j=1;j<=n;j++)
				for(int k=1;k<=m;k++)
					for(int o=0;o<4;o++)
						if(j+dx[o]<=n&&j+dx[o]>=1&&k+dy[o]<=m&&k+dy[o]>=1)Add(id(i,j,k),id(i-K,j+dx[o],k+dy[o]),INF);
		while(bfs())memcpy(cur,head,sizeof(int[T+1])),ans+=dfs(S,INF);
		printf("%d\n",ans);
	}	
}
int main()
{
	FGF::work();
	return 0;
}
```

---

## 作者：jijidawang (赞：14)

## 广义切糕模型之最小割离散变量模型
### Preface
2016 年的候选队论文《网络流的一些建模方法》（姜志豪）给出了一种最小割建模方法——最小割离散变量模型 .

以下 $\infty$ 均为**正**无穷 .

### Solution

> **最小割离散变量模型**
>
> $n$ 个变量 $\{x_n\}$，每个变量的取值范围为 $x_i\in[1,m_i]\cap\mathbb Z$，每两个变量之间会对答案产生贡献（一般和两变量差有关），我们要最大化 / 最小化这个贡献 .
>
> 建图方式一般就是对每个变量 $x_i$ 拆成 $m_i+1$ 个点串成一个源点 $s$ 到汇点 $t$ 的链，割哪条边就代表取那个值，贡献用两条链直接的连边表达，于是就变成最小割形式了 .

对于这个题，对于每个点 $(i,j)$，其中 $1\le i\le P,1\le j\le Q$，就相当于有一个变量 $x_{i,j}$，取值为对于 $1\le k\le R$ 的不和谐值 $v(i,j,k)$ .

注意到有一个光滑度限制，注意到最小割中 $\infty$ 边不可能被选，那么我们可以借助一条 $\infty$ 边 $u\overset{\infty}{\to} v$，来限制 $s,u$ 和 $v,t$ 不同时连通 .

于是我们对每个点向周围能连的最远点连一条 $\infty$ 边就可以解决问题了，可以画一下这个图的样子，一个可行的最小割必然对应一组可行最优解 .

建图建好了直接跑最小割即可，时间复杂度就是最小割复杂度 .

[「开门大吉」](https://www.luogu.com.cn/problem/P6054)一题给出了一个更一般的问题，可以尝试做一下 .

### Code
```cpp
dinic F;
int p, q, r, d, v[L][L][L];
inline int node(int i, int j, int k){return i * 1600 + j * 40 + k;}
int main()
{
	scanf("%d%d%d%d", &p, &q, &r, &d); int s = 1, t = 2;
	for (int k=1; k<=r; k++)
		for (int i=1; i<=p; i++)
			for (int j=1; j<=q; j++) scanf("%d", v[i][j] + k);
	for (int i=1; i<=p; i++)
		for (int j=1; j<=q; j++)
		{
			F.addedge(s, node(i, j, 1), v[i][j][1]); F.addedge(node(i, j, r), t, INF);
			for (int k=2; k<=r; k++) F.addedge(node(i, j, k-1), node(i, j, k), v[i][j][k]);
		}
	for (int i=1; i<=p; i++)
		for (int j=1; j<=q; j++)
			for (int k=1; k<=r-d; k++)
			{
				if (inrange(i+1, 1, p)) F.addedge(node(i+1, j, k+d), node(i, j, k), INF);
				if (inrange(i-1, 1, p)) F.addedge(node(i-1, j, k+d), node(i, j, k), INF);
				if (inrange(j+1, 1, q)) F.addedge(node(i, j+1, k+d), node(i, j, k), INF);
				if (inrange(j-1, 1, q)) F.addedge(node(i, j-1, k+d), node(i, j, k), INF);
			}
	printf("%lld\n", F.maxflow(s, t));
	return 0;
}
```

---

## 作者：louhao088 (赞：5)

最小割经典问题。


------------
首先遇到这个问题，发现并不怎么显然，我们可以将其转换

我们把每个纵柱的高度分别依次连边，边权即为其不和谐值，即 $(x,y,k)  \xrightarrow{val(x,y,k+1)}(x,y,k+1)$，再把两端分别向起点，终点连边，这样我们就可以把每个纵列选一个高度转换为求最小割。

那么如何把相邻高度差这个条件转换呢，我们可以将每个点的第 $k$ 个高度，向其周围的点的第 $k-D$ 个高度连 $\infty  $ 的边，即  $(x,y,k)  \xrightarrow{\infty}(x\pm1,y\pm1,k-D)$。这样就可以使选定相邻高度差小于 D。因为如果选了不合法的方案，那么必然他还能通过这条  $\infty  $ 的边，这必然不是最小割。

我们建边后就可以通过网络流求解了，因为最小割等于最大流，只要求出最大流了。



------------
代码如下

```cpp
// Problem: P3227 [HNOI2013]切糕
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P3227
// Memory Limit: 125 MB
// Time Limit: 1000 ms
// 2022-02-13 09:11:43
// Author : louhao088
// 

#include<bits/stdc++.h>
using namespace std;
//static char buf[1000000],*p1=buf,*p2=buf;
//#define getchar() p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++
#define pi pair<int,int>
#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define ls (rt<<1)
#define rs (rt<<1|1)
#define mid (l+r>>1)
#define lowbit (x&-x)
const int maxn=1e5+5,M=34005,inf=1e9;
inline int read()
{
	char ch=getchar();bool f=0;int x=0;
	for(;!isdigit(ch);ch=getchar())if(ch=='-')f=1;
	for(;isdigit(ch);ch=getchar())x=(x<<1)+(x<<3)+(ch^48);
	if(f==1)x=-x;return x;
}
inline void print(int x)
{
    static int a[55];int top=0;
    if(x<0) putchar('-'),x=-x;
    do{a[top++]=x%10,x/=10;}while(x);
    while(top) putchar(a[--top]+48);
}
int n,m,h,d,x,y,id[45][45][45],tot=0,v[45][45][45],dx[4]={0,0,1,-1},dy[4]={1,-1,0,0};
struct node
{
	int head[maxn],to[maxn*4],nex[maxn*4],w[maxn*4],cnt,s,t,maxflow,dis[maxn],cur[maxn];
	void add(int x,int y,int z){to[++cnt]=y,w[cnt]=z,nex[cnt]=head[x],head[x]=cnt;
	to[++cnt]=x,w[cnt]=0,nex[cnt]=head[y],head[y]=cnt;}
	void clear(){memset(head,0,sizeof head),memset(cur,0,sizeof cur),cnt=1,maxflow=0;}
	bool bfs()
	{
		memset(dis,-1,sizeof dis);queue<int>q;
		q.push(s);cur[s]=head[s];dis[s]=0;		
		while(!q.empty())
		{
			int x=q.front();q.pop();
			for(int i=head[x];i;i=nex[i])
				if(dis[to[i]]==-1&&w[i])
					dis[to[i]]=dis[x]+1,q.push(to[i]),cur[to[i]]=head[to[i]];
		}
		return dis[t]!=-1;
	}
	int dfs(int x,int flow)
	{
		if(x==t)return flow;
		int sum=0;
		for(int i=cur[x];i&&flow;i=nex[i])
		{
			cur[x]=i;
			if(w[i]&&dis[to[i]]==dis[x]+1)
			{
				int k=dfs(to[i],min(flow,w[i]));
				flow-=k,sum+=k;w[i]-=k,w[i^1]+=k;
			}
		}return sum;
	}
	void work()
	{
		while(bfs())maxflow+=dfs(s,inf);
	}
}G;
signed main()
{
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	n=read(),m=read(),h=read(),d=read();G.clear();
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			for(int k=0;k<=h;k++)id[i][j][k]=++tot;
	for(int k=1;k<=h;k++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=m;j++)
			{
				v[i][j][k]=read(),G.add(id[i][j][k-1],id[i][j][k],v[i][j][k]);
				if(k>=d)
				{
					for(int l=0;l<4;l++)
					{
						int tx=i+dx[l],ty=j+dy[l];
						if(tx<=n&&tx>=1&&ty<=m&&ty>=1)G.add(id[i][j][k],id[tx][ty][k-d],inf);
					}
				}
			}
	int s=++tot,t=++tot;
	G.s=s,G.t=t;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			G.add(s,id[i][j][0],inf),G.add(id[i][j][h],t,inf);
	G.work();cout<<G.maxflow<<endl;
 	return 0;
}


```


---

## 作者：yllcm (赞：4)

提供一种（可能）更加自然的理解。

题目要求我们选一些点，可以写出如下限制：

* 对于每个 $(x,y)$，只能选一个点。
* $|f(x,y)-f(x',y')|\leq D$。

对第二个条件进行简化：$-D\leq f(x,y)-f(x',y')\leq D$。容易发现我们只需要考虑 $\leq D$ 的限制，因为不等式乘上 $-1$ 之后可以得到另一个对称的限制。

考虑最小割，对于第一个限制，显然可以按照套路建一条 $1\sim R$ 的链，然后 $(x,y,i)$ 向 $(x,y,i+1)$ 连边。为了保证我们建模有着自然的实际意义，定义 $V_S$ 为残量网络上与 $S$ 联通的点集，于是我们可以钦定：$(x,y)$ 选的点为 $V_S$ **在这条链上最靠后的点**。事实上它的后继边的集合就是割边集。

upd：事实上这里是不太严谨的，因为一条链有最多割一条的限制，所以必须要保证连通的一定是一个前缀。换句话说，选择的条件实际上是一个“若 $i$ 连通且 $j$ 不连通，则花费为 $c$”的限制。所以需要 $(x,y,i+1)$ 向 $(x,y,i)$ 连一条 $\inf$ 边。不过根据 dengyaotriangle 的证明也是对的，所以不管了（

那么对于相邻的限制，在模型上有如下理解：若 $S$ 与 $(x',y',t')$ 联通，则存在 $t\geq t'-d$，使得 $(x,y,t)$ 与 $S$ 联通，那么对于 $(x',y',t')$ 向 $(x,y,t'-d)$ 连 $\inf$ 边的思路就相当自然了。



```cpp
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define db double
#define ldb long double
#define pb push_back
#define mp make_pair
#define pii pair<int, int>
using namespace std;
inline int read() {
    int x = 0; bool op = 0;
    char c = getchar();
    while(!isdigit(c))op |= (c == '-'), c = getchar();
    while(isdigit(c))x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();
    return op ? -x : x;
}
const int N = 50;
const int MAXN = 1e6 + 10;
const int INF = 1e9;
template<int N> struct MFL {
    int n, etot, S, T, head[N], to[N], nxt[N], flow[N];
    void addedge(int u, int v, int w) { 
        to[++etot] = v; flow[etot] = w; nxt[etot] = head[u]; head[u] = etot;
    }
    void add(int u, int v, int w) {
        addedge(u, v, w); addedge(v, u, 0);
        return ;
    }
    void init(int nn, int ns, int nt) {
        n = nn; S = ns; T = nt; etot = 1;
        memset(head, 0, sizeof(head));
        return ;
    }
    int lev[N], cur[N];
    bool bfs() {
        for(int i = 0; i <= n; i++)cur[i] = head[i], lev[i] = 0;
        queue<int> q;
        q.push(S); lev[S] = 1;
        while(q.empty() == false) {
            int u = q.front(); q.pop();
            for(int i = head[u]; i; i = nxt[i]) {
                if(lev[to[i]] || flow[i] == 0)continue;
                lev[to[i]] = lev[u] + 1;
                if(to[i] == T)return true;
                q.push(to[i]);
            }
        }
        return false;
    }
    int dinic(int u, int fl) {
        if(u == T)return fl;
        int rest = fl;
        for(int i = cur[u]; i && rest; i = nxt[i]) {
            cur[u] = i;
            if(lev[to[i]] ^ (lev[u] + 1) || flow[i] == 0)continue;
            int inc = dinic(to[i], min(flow[i], rest));
            if(inc == 0)lev[to[i]] = 0;
            flow[i] -= inc; flow[i ^ 1] += inc; rest -= inc;
        }
        return fl - rest;
    }
    int query() {
        int mxfl = 0, fl = 0;
        while(bfs()) {
            while(fl = dinic(S, INF))mxfl += fl;
        }
        return mxfl;
    }
};
MFL<MAXN> mf;
const int dx[4] = {0, 0, 1, -1};
const int dy[4] = {1, -1, 0, 0};
int p, q, r, d, tot;
int a[N][N][N], id[N][N][N];
int main() {
    p = read(); q = read(); r = read(); d = read();
    for(int i = 1; i <= r; i++) {
        for(int j = 1; j <= p; j++) {
            for(int k = 1; k <= q; k++) {
                a[j][k][i] = read();
                id[j][k][i] = ++tot;
            }
        }
    }
    mf.init(tot + 1, 0, tot + 1);
    for(int i = 1; i <= p; i++) {
        for(int j = 1; j <= q; j++) {
            mf.add(mf.S, id[i][j][1], INF); mf.add(id[i][j][1], mf.S, INF);
            for(int k = 1; k < r; k++) {
                mf.add(id[i][j][k], id[i][j][k + 1], a[i][j][k]);
                mf.add(id[i][j][k + 1], id[i][j][k], INF);
            }
            mf.add(id[i][j][r], mf.T, a[i][j][r]); mf.add(mf.T, id[i][j][r], INF);
        }
    }
    for(int i = 1; i <= p; i++) {
        for(int j = 1; j <= q; j++) {
            for(int o = 0; o < 4; o++) {
                int nx = i + dx[o], ny = j + dy[o];
                if(nx < 1 || nx > p || ny < 1 || ny > q)continue;
                for(int k = 1; k + d <= r; k++) {
                    mf.add(id[nx][ny][k + d], id[i][j][k], INF);
                }
            }
        }
    }
    printf("%d\n", mf.query());
    return 0;
}
```


---

## 作者：ysy20021208 (赞：4)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**分析与题解：**对于此题，我们观察对于点的分割不太好操作，我们考虑转化模型。由于我们是要拦腰切成两半，所以我们在高上入手，我们将高的$r$层多加一层，将点转化为边，第一层的点就相当于连接转化后的第一层和第二层的边，第二层的点就相当于连接转化后的第二层和第三层的边……第$r$层的点就相当于连接转化后的第$r$层和第$r+1$层的边。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果不考虑$D$这道题现在就解决了。对于$D$的限制，我们发现不成立只需要考虑$f(x，y)-f(x'，y')\gt D$的情况，因为$f(x，y)-f(x'，y')\lt -D$的情况在考虑点$(x'，y'，f(x'，y'))$的时候就转化为上述形式。我们现在要将$(x，y，z)$向$(x'，y'，z’-k)，k\in[D+1,R+1]$连边，边权为$inf$，这样在不合法的时候，我们依旧能使$S$和$T$联通。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;建图建完，直接用$Dinic$跑最小割就可以了。

```c++
// luogu-judger-enable-o2
#include <queue>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
#define N 200000
#define inf 1000000000
int p,q,r,D,s,t,dis[N],ans,num[60][60][60];
int cur[N],head[N],to[N<<3],nxt[N<<3],val[N<<3],idx=1;
void add(int a,int b,int c)
    {nxt[++idx]=head[a],to[idx]=b,val[idx]=c,head[a]=idx;}
bool bfs() 
{
    memset(dis,-1,sizeof dis);
    queue <int> q;q.push(s),dis[s]=0;
    while(!q.empty())
    {
        int p=q.front();q.pop();
        if(p==t) return true;
        for(int i=head[p];i;i=nxt[i])
            if(val[i]>0&&dis[to[i]]==-1)
                dis[to[i]]=dis[p]+1,q.push(to[i]);
    } return false;
}
int dfs(int p,int flow)
{
    int now,temp=flow;
    if(p==t) return flow;
    for(int i=cur[p];i;i=nxt[i])
        if(val[i]>0&&dis[to[i]]==dis[p]+1)
        {
            now=dfs(to[i],min(val[i],temp));
            if(!now) dis[to[i]]=-1;
            temp-=now,val[i]-=now,val[i^1]+=now;
            if(val[i]) cur[p]=i;
            if(!temp) break;
        } return flow-temp;
}
void dinic() {while(bfs()) memcpy(cur,head,sizeof head),ans+=dfs(s,inf);}
int pla(int x,int y,int z) {return (z-1)*p*q+(x-1)*q+y;}
int main()
{
    scanf("%d%d%d%d",&p,&q,&r,&D),s=p*q*(r+1)+1,t=p*q*(r+1)+2;
    for(int i=1;i<=r;i++) for(int j=1;j<=p;j++) for(int k=1;k<=q;k++)
        scanf("%d",&num[j][k][i]);r++;
    for(int i=1;i<=p;i++) for(int j=1;j<=q;j++)
        add(s,pla(i,j,1),inf),add(pla(i,j,1),s,0);
    for(int i=1;i<=p;i++) for(int j=1;j<=q;j++)
        add(pla(i,j,r),t,inf),add(t,pla(i,j,r),0);
    for(int i=1;i<=p;i++) for(int j=1;j<=q;j++) for(int k=1;k<r;k++)
        add(pla(i,j,k),pla(i,j,k+1),num[i][j][k]),add(pla(i,j,k+1),pla(i,j,k),0);
    for(int i=1;i<p;i++) for(int j=1;j<=q;j++) for(int t=D+1;t<=r;t++)
            add(pla(i,j,t),pla(i+1,j,t-D),inf),add(pla(i+1,j,t-D),pla(i,j,t),0);
    for(int i=1;i<=p;i++) for(int j=1;j<q;j++) for(int t=D+1;t<=r;t++)
            add(pla(i,j,t),pla(i,j+1,t-D),inf),add(pla(i,j+1,t-D),pla(i,j,t),0);
    for(int i=2;i<=p;i++) for(int j=1;j<=q;j++) for(int t=D+1;t<=r;t++)
            add(pla(i,j,t),pla(i-1,j,t-D),inf),add(pla(i-1,j,t-D),pla(i,j,t),0);
    for(int i=1;i<=p;i++) for(int j=2;j<=q;j++) for(int t=D+1;t<=r;t++)
            add(pla(i,j,t),pla(i,j-1,t-D),inf),add(pla(i,j-1,t-D),pla(i,j,t),0);
    dinic(),printf("%d\n",ans);
}
```

---

## 作者：撤云 (赞：3)

### 题目链接
[戳我](https://www.luogu.org/problemnew/show/P3227)
### $Solution$

对于这道题，我们首先来看看没有$D$这个约束的该如何做。

我们考虑构造最小割模型。  
~~其实直接贪心就好了,选出每条路径上的最小值就好了(路径就是将每层的同一个点连起来)~~  
但是因为这题不仅仅是这样,还有一些约束条件需要满足。所以还是看看如何建模吧。

其实和贪心很像啊。  
首先如上面所说连成一条条路径，在将第一层和$S$相连,最后一层和$T$连接。跑一遍最小割就好了。至于流量，这个自己应该知道吧,如果不知道来看看图，更加深刻的理解。(这里只选了局部图,~~有点丑~~)
首先我们将第$k$层第$i$行,第$j$列的数的值设为$V[k][i][j]$

![](https://s2.ax1x.com/2019/01/18/k9ryzn.png)

现在考虑一下$D$的约束条件  
我们可以对于一个点，令他为$(k,x,y)$，我们可以将点x连向$k-D$层中与$(x,y)$相邻的点,流量为$inf$,这样就可以满足条件了，至于问什么来借助图来看一下吧。  
假设现在$D=1$,如图:
![](https://s2.ax1x.com/2019/01/19/k9IU9P.png)

我们将$i$点到$j$点的边表示为$f[i][j]$  
我们首先的思考一下，每一条链只能割一条边，因为如果割多条明显不会最优。假设我们现在割的是$f[6][8]$这一条边,那么我们就不能割$f[S][1]$,我们将$(6,1)$连一条为$inf$的边我这样当我们割掉是$f[6][8]$，则这一条道路走不通我们就会走$f[6][1]$因为要满足最优，所以我们一定不会割$f[S][1]$,其他的同理。

### $Code$

见[博客](https://www.cnblogs.com/hbxblog/p/10290453.html)

---

## 作者：破壁人 (赞：2)

分析：

先考虑没有D的限制，当然是每根纵轴都取最小值。

建立网络流模型，就是(i,j,k)向(i,j,k+1)连一条容量为1的边。

建立S和T，S向(i,j,1)连一条容量为1的边，(i,j,R)向T连容量为1的边。

答案就是最小割。

那么现在加上	D的限制怎么办呢？

想办法在原基础上使割掉不合法的边后S和T连通就可以了。

我们发现(i,j,k)向(i,j,k-D)连一条容量为inf的边就可以达成要求了。


代码：
```cpp

#include<iostream>
#include<cstring>
#include<cstdio>

using namespace std;

const int inf=1e9;

int to[1000001],w[1000001],next[1000001],first[1000001],cur[1000001],now,ans=0;
int P,Q,R,D,S,T,v[50][50][50],d[1000001],e[1000001],f[1000001],mi=inf,e1;

int idx(int x,int y,int z){return (x-1)*P*Q+(y-1)*Q+z;}

void insert(int o,int p,int q)
{
    to[e1]=p;w[e1]=q;next[e1]=first[o];first[o]=e1++;
    to[e1]=o;w[e1]=0;next[e1]=first[p];first[p]=e1++;
}

int main()
{
    memset(first,-1,sizeof(first));
    scanf("%d%d%d%d",&P,&Q,&R,&D);
    S=P*Q*R+1;T=S+1;
    for(int i=1;i<=R;i++)
        for(int j=1;j<=P;j++)
            for(int k=1;k<=Q;k++)
            {
                scanf("%d",&v[i][j][k]);
                if(i==1) insert(S,idx(i,j,k),inf);
                if(i!=R) insert(idx(i,j,k),idx(i+1,j,k),v[i][j][k]);else
                insert(idx(i,j,k),T,v[i][j][k]);
                if(i>D)
                {
                    if(j>1) insert(idx(i,j,k),idx(i-D,j-1,k),inf);
                    if(j<P) insert(idx(i,j,k),idx(i-D,j+1,k),inf);
                    if(k>1) insert(idx(i,j,k),idx(i-D,j,k-1),inf);
                    if(k<Q) insert(idx(i,j,k),idx(i-D,j,k+1),inf);
                }
            }
    memset(e,-1,sizeof(e));
    memset(d,0,sizeof(d));
    memset(f,0,sizeof(f));
    for(int i=0;i<=T;i++) cur[i]=first[i];
    now=e[S]=S;f[0]=T;
    while(d[S]<T)
    {
        bool bo=false;
        if(now==-1) break;
        for(int i=cur[now];i!=-1;i=next[i])
            if((w[i]>0)&&(d[now]==(d[to[i]]+1)))
            {
                cur[now]=i;
                mi=min(mi,w[i]);
                e[to[i]]=now;
                now=to[i];
                bo=true;
                if(now==T)
                {
                    ans+=mi;
                    while(now!=S)
                    {
                        w[cur[e[now]]]-=mi;
                        w[cur[e[now]]^1]+=mi;
                        now=e[now];
                    }
                    mi=inf;
                }
                break;
            }
        if(bo) continue;int mmi=T;
        for(int i=first[now];i!=-1;i=next[i])
            if((w[i]>0)&&(mmi>d[to[i]])){mmi=d[to[i]];cur[now]=i;}
        if(!(--f[d[now]])) break;
        f[d[now]=(mmi+1)]++;
        now=e[now];
    }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：EkiXu (赞：2)

来源：[http://ozem.pw/archives/1201][1]

![如图](http://i1.piimg.com/567571/9e191d3050ae3c10.png)

我们将点转化成边，那么选点就等于割边，第一个条件满足

对于第二个条件我们可以用一些inf的边来"屏蔽"那些不能割的边，从z向"相邻的"路径的z-d号点连inf的边（如上图）这样做之后，如果删了这条边，我们还可以通过这些桥梁，从相邻的路径的一段[z-d,z+d]绕过，所以割那些边就没有意义了

从而实现必须割[z-d,z+d]的目的

```cpp
#include<cstdio>
#include<cstring>
#include<queue>
#define MAXN 200000
#define inf 0x3f3f3f3f
struct Edge {
    int u;
    int v;
    int cap;
    int nxt;
    Edge() {}
    Edge(int _u,int _v,int _cap,int _nxt):u(_u),v(_v),cap(_cap),nxt(_nxt) {}
} edge[MAXN*10+1];
int head[MAXN+1];
inline int min(int a,int b) {
    if(a<b) return a;
    return b;
}

struct Dicnic {
    int tot,dis[MAXN+1],cur[MAXN+1];
    void init() {
        tot=0;memset(head,-1,sizeof(head));memset(cur,-1,sizeof(cur));
    }
    void AddEdge(int u,int v,int c) {
        edge[tot]=Edge(u,v,c,head[u]);
        head[u]=tot++;
        edge[tot]=Edge(v,u,0,head[v]);
        head[v]=tot++;
    }
    void BFS(int s) {
        memset(dis,-1,sizeof(dis));
        std::queue<int> q;
        dis[s]=0;
        q.push(s);
        while(!q.empty()) {
            int v=q.front();q.pop();
            for(int i=head[v]; i!=-1; i=edge[i].nxt) {
                Edge e=edge[i];
                if(e.cap>0&&dis[e.v]==-1) {
                    dis[e.v]=dis[v]+1;
                    q.push(e.v);
                }
            }
        }
    }
    int DFS(int v,int t,int low) {
        if(v==t) return low;
        for(int &i=cur[v]; i!=-1; i=edge[i].nxt) {
            Edge &e=edge[i],&reve=edge[i^1];
            if(e.cap>0&&dis[e.v]>dis[v]) {
                int d=DFS(e.v,t,min(low,e.cap));
                if(d>0){
                    e.cap-=d;
                    reve.cap+=d;
                    return d;
                }
            }
        }
        return 0;
    }
    int Max_Flow(int s,int t) {
        int flow=0,f=0;
        while(1) {
            BFS(s);
            if(dis[t]==-1) return flow;
            memcpy(cur,head,sizeof(cur));
            while((f=DFS(s,t,inf))>0) flow+=f;
        }
    }
} net;
int g[50][50][50];
const int dir[4][2]={{1,0},{-1,0},{0,1},{0,-1}};
int main() {
    int P,Q,R,D,cnt=0;
    net.init();
    scanf("%d%d%d%d",&P,&Q,&R,&D);
    for(int i=1; i<=R+1; i++) {
        for(int j=1; j<=P; j++) {
            for(int k=1; k<=Q; k++) {
                g[i][j][k]=++cnt;
            }
        }
    }
    const int s=0,t=cnt+1;
    int v;
    for(int i=1;i<=P;i++)
        for(int j=1;j<=Q;j++){
            net.AddEdge(s,g[1][i][j],inf);
            net.AddEdge(g[R+1][i][j],t,inf);
    }
    for(int i=1; i<=R; i++) 
        for(int j=1; j<=P; j++) 
            for(int k=1; k<=Q; k++) {
                scanf("%d",&v);
                net.AddEdge(g[i][j][k],g[i+1][j][k],v);//向上连边 
            }
    for(int i=D+1;i<=R;i++)
        for(int j=1;j<=P;j++)
            for(int k=1;k<=Q;k++){
                for(int m=0;m<4;m++){
                    if(g[i-D][j+dir[m][0]][k+dir[m][2]]>0){
                        net.AddEdge(g[i][j][k],g[i-D][j+dir[m][0]][k+dir[m][3]],inf);
                    }
                }
            }
    printf("%d\n",net.Max_Flow(s,t));
    return 0;
}
```


[1]: http://ozem.pw/archives/1201


---

## 作者：zzw4257 (赞：1)

#### 简述
>给一个$n*m*h$的立体图,对$\forall(x,y)(1\le x\le n\vee1\le y\le m)$要求选出$1\le f_{x,y}\le h$使得$|f_{x,y}-f_{x',y'}|\le D(|x-x'+y-y'|=1)$,最小化$\sum v_{x,y,f_{x,y}}$

#### Solution
首先对每个离散变量$f_{x,y}$,我们拆出$h$个点$\{1,2,\cdots,h\}$

然后连边

$(S,(x,y,1),v_{x,y,1})$表示$f_{x,y}=1$

$((x,y,i),(x,y,i+1),v_{x,y,i+1})(i\in[1,h))$表示$f_{x,y}=i+1$

$((x,y,h),T,INF)$表示不能**不选**

然后考虑变量间限制
$f_{x,y}-f_{x',y'}\le D\vee f_{x,y}-f_{x',y'}\le -D(|x-x'+y-y'|=1)$

这里我们需要注意到割的性质:是让$S,T$分离的边

我们不能明确用割的容量去表示合法情况，那么就可以反其道而行用$INF$这个特殊的容量去禁止选一些情况

我们让$(x,y,f_{x,y})$$\in S$则$k\le f_{x,y}$,反之$k>f_{x,y}$

先给出结论

$((x,y,k),(x',y',k-D),INF)(|x-x'+y-y'|=1)$

什么意思,首先我们知道我们不能割这个边

如果你到达了$(x,y,k)$,你要跨越$(x,y)$到$(x',y')$并且选了$f_{x',y'}<k-D$

那么由于边$((x,y,k),(x',y',k-D),INF)$

妳割了$((x',y',f_{x',y'}),(x',y',f_{x',y'}-1))$但$(S,T)$就联通，又因为你不可以割这条边，所以这个非法情况不是割

我们实际上满足了$f_{x,y}-f_{x',y'}\le D$

但~~很好~~理解$(x,y),(x',y')$的关系有翻转的一天，也会满足满足了$f_{x,y}-f_{x',y'}\le -D$

#### Code

```cpp
inline void Read(void){
	re int i,j,k,last,dir,tx,ty;
	n=read(),m=read(),H=read(),lim=read(),S=0,T=n*m*H+1,P=T+1;
	for(k=1;k<=H;++k)
		for(i=1;i<=n;++i)
			for(j=1;j<=m;++j)a[i][j][k]=read();
	for(i=1;i<=n;++i)
		for(j=1;j<=m;++j){
			last=S;
			for(k=1;k<=H;++k)AddEdge(last,pos(i,j,k),a[i][j][k]),last=pos(i,j,k);
			AddEdge(last,T,INF);
		}
	//同一个位置不同层可以从下往上传
	for(i=1;i<=n;++i)
		for(j=1;j<=m;++j)
			for(k=1;k<=H-lim;++k){
				for(dir=0;dir<4;++dir){
					tx=i+dx[dir],ty=j+dy[dir];
					if(tx>n||!tx||!ty||ty>m)continue;
					AddEdge(pos(tx,ty,k+lim),pos(i,j,k),INF);//从上到下，只要高于这个就必须割INF
					//事实上(i,j)也会被连一个来限制下界 
				}
			}
}
```

---

## 作者：magolor (赞：1)

就是暴力把所有点都建出来：

P\*Q\*R个点，从P\*Q个R-1层到R层的点连边代表选择这一层的权值；

加一个0层，S到0层连INF，R层到T连INF，相邻相差超过D的层连INF

这样最小割（=最大流）就代表每个方格必须选一个层，相邻方格差不超过D的最小代价。







```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
#define MAXN 100000
#define MAXM 500000
#define INF 0x3f3f3f3f
#define v(x,y,z) (~-(x)*2000+~-(y)*50+(z))
#define gc() getchar()
inline int read(int ans = 0, int sgn = ' ', int ch = gc())
{
    for(;ch < '0' || ch > '9'; sgn=ch,ch=gc());
    for(;ch >='0' && ch <='9'; (ans*=10)+=ch-'0',ch=gc());
    return sgn-'-' ? ans : -ans;
}
struct Edge
{
    int to,nex;
    int c;
    Edge(int _to=0, int _nex=0, int _c=0):to(_to),nex(_nex),c(_c){}
}e[MAXM+5];
int first[MAXN+5], q[MAXN+5], level[MAXN+5], cur[MAXN+5], c[MAXN+5], tot, P, Q, R, D, N, S, T;
int mx[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};
inline void Add(int a, int b, int c)
{
    e[tot] = Edge(b,first[a],c), first[a] = tot++;
    e[tot] = Edge(a,first[b],0), first[b] = tot++;
    return;
}
inline bool BFS()
{
    memset(level,0,sizeof(level)), q[0] = S, level[S] = 1;
    for(register int head = 0, tail = 1, t, u, v; head-tail; )
        for(t = q[head++], head %= MAXN, u = first[t]; u+1; u = e[u].nex)
            if(e[u].c > 0 && !level[v=e[u].to])
            {
                level[v] = level[t]+1, q[tail++] = v, tail %= MAXN;
                if(v == T)
                    return true;
            }
    return false;
}
int DFS(int p, int f, int tag = 0, int del = 0)
{
    if(p == T)
        return f;
    for(register int &u = cur[p], v; u+1; u = e[u].nex)
        if(e[u].c > 0 && level[v=e[u].to] == level[p]+1)
        {
            del = DFS(v,min(e[u].c,f-tag)), e[u].c -= del, e[u^1].c += del, tag += del;
            if(f == tag)
                return tag;
        }
    return tag;
}
inline int Dinic(int ans = 0)
{
    for(register int i; BFS(); ans += DFS(S,INF))
        for(i = 0; i <= N; cur[i] = first[i], i++);
    return ans;
}
int main()
{
    P = read(), Q = read(), R = read(), D = read(), memset(first,-1,sizeof(first)), S = 0, N = T = v(P,Q,R+1);
    for(register int z = 1, x, y; z <= R; z++)
        for(x = 1; x <= P; x++)
            for(y = 1; y <= Q; y++)
                Add(v(x,y,z-1),v(x,y,z),read());
    for(register int x = 1, y, k, nx, ny, z; x <= P; x++)
        for(y = 1; y <= Q; y++)
            for(Add(S,v(x,y,0),INF), Add(v(x,y,R),T,INF), k = 0; k < 4; k++)
            {
                nx = x+mx[k][0], ny = y+mx[k][1];
                if(nx < 1 || nx > P || ny < 1 || ny > Q)
                    continue;
                for(z = D+1; z <= R; Add(v(x,y,z),v(nx,ny,z-D),INF), z++);
            }
    printf("%d\n",Dinic());
    return 0;
}
```

---

## 作者：Cry_For_theMoon (赞：0)

[传送门](https://www.luogu.com.cn/problem/P3227)

为啥一定要建虚拟层，割边转割点也是可做的。

同样考虑没有 $D$ 的限制。每个点和它上方的点连边容量 INF，$S$ 和第一层的点连边同样容量 $INF$，最上面一层和 $T$ 连边依旧容量 INF。然后拆点成 $X_i$ 和 $Y_i$，在 $X_i->Y_i$ 之间连容量为 $v$ 的边。此时最小割就是答案。

然后考虑加入 $D$ 的限制。从题目出发有两种可能做法：

- 割一个点后某些点不能再割

- 割一个点后必须在某些点里面割一个

其实因为拆了点完全可以把点当成边来考虑，两者没有太大差别。如果 $(x,y)$ 和 $(x',y')$ 的曼哈顿距离为1（其实就是上下左右），那么选 $(x,y,k)$ 意味着要在 $(x',y',k-d) ...(x',y',k+d)$ 之间选点。然后就有一个神奇的做法：连边 $X_{(x,y,k)}->X_{(x',y',k-d)},Y_{(x',y',k+d)}->Y_{(x,y,k)}$，容量皆为INF（代表不能割），就满足了限制。如果割的边不是 $X_i->Y_i$ 这一条那么不会割任何其它的边；如果割的就是 $X_i->Y_i$ 这一条那么在 $X_{(x',y',k-d)}...Y_{(x',y',k+d)}$ 之间必须割掉某条边，否则 $S->X_i->T$ 仍可行不是最小割。

如果没看懂的话看看代码怎么建图就可以了。

```cpp
//HNOI,2013
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#define op(x) x+((x&1)?1:-1)
#define out(x) x+p*q*r
#define next Cry_For_theMoon
using namespace std;
typedef long long ll;
const int MAXN=2e5+10,MAXM=5e6+10,INF=2e9,pv[4][2]={{1,0},{0,1},{-1,0},{0,-1}};
struct Edge{
	int u,v,cap,flow;
}edge[MAXM];
int first[MAXN],next[MAXM],tot;
int p,q,r,d,s,t;
int dis[MAXN],vis[MAXN],cur[MAXN];
void addedge(int u,int v,int cap){
	edge[++tot].u=u;edge[tot].v=v;edge[tot].cap=cap;
	next[tot]=first[u];first[u]=tot;
}
inline int Hash(int x,int y,int z){
	return (z-1)*(p*q) + (x-1)*q + y;
}
int bfs(){
	memset(dis,0,sizeof dis);memset(vis,0,sizeof vis);
	queue<int>q;q.push(s);vis[s]=1;
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int j=first[u];j;j=next[j]){
			int v=edge[j].v;
			if(vis[v] || edge[j].cap==edge[j].flow)continue;
			vis[v]=dis[v]=dis[u]+1;
			q.push(v);
		}
	}
	return vis[t];
}
int dfs(int u,int a){
	if(u==t||!a)return a;
	int flow=0,val;
	for(int& j=cur[u];j;j=next[j]){
		int v=edge[j].v;
		if(dis[v]!=dis[u]+1)continue;
		val=dfs(v,min(a,edge[j].cap-edge[j].flow));
		if(val){
			flow+=val;a-=val;
			edge[j].flow+=val;edge[op(j)].flow-=val;
		}
		if(!a)break;
	}
	return flow;
}
int dinic(){
	int flow=0;
	while(bfs()){
		for(int i=1;i<=t;i++){cur[i]=first[i];}
		flow+=dfs(s,INF);
	}
	return flow;
}
int main(){
	scanf("%d%d%d%d",&p,&q,&r,&d);
	s=2*p*q*r+1,t=s+1; 
	for(int i=1;i<=r;i++){
		for(int j=1;j<=p;j++){
			for(int k=1,v;k<=q;k++){
				scanf("%d",&v);
				addedge(Hash(j,k,i),out(Hash(j,k,i)),v);addedge(out(Hash(j,k,i)),Hash(j,k,i),0);
			}
		} 
	}
	for(int i=1;i<=r;i++){
		for(int j=1;j<=p;j++){
			for(int k=1;k<=q;k++){ 
				if(i==1){
					addedge(s,Hash(j,k,i),INF);addedge(Hash(j,k,i),s,0);
				}
				if(i==r){
					addedge(out(Hash(j,k,i)),t,INF);addedge(t,out(Hash(j,k,i)),0);
				}else{ 
					addedge(out(Hash(j,k,i)),Hash(j,k,i+1),INF);addedge(Hash(j,k,i+1),out(Hash(j,k,i)),0); 
				}
				int lr=max(1,i-d),rr=min(r,i+d);
				for(int idx=0;idx<4;idx++){
					int x=j+pv[idx][0],y=k+pv[idx][1];
					if(x<1 || x>p || y<1 || y>q)continue;
					addedge(Hash(j,k,i),Hash(x,y,lr),INF);addedge(Hash(x,y,lr),Hash(j,k,i),0);
					addedge(out(Hash(x,y,rr)),out(Hash(j,k,i)),INF);addedge(out(Hash(j,k,i)),out(Hash(x,y,rr)),0);
				}
			}
		}
	}
	printf("%d",dinic());
	return 0;
}
```


---

## 作者：45dino (赞：0)

还是很巧妙的，如果在场上我 $100\%$ 想不到用网络流。

题目一堆文字都是在解释**拦腰切**，如果明白这一点对做题比较有帮助。

现在问题转换为：有一个 $p\times q$ 的矩阵，每个元素又是一个长度为 $r$ 的数列。定义矩阵中任意两个元素相邻当且仅当两个元素的行或列差1，同时另一个相等，现在希望在 $p\times q$ 个数列中各取一个数，满足相邻的数列中取出的数在原数列的位置的差不大于 $d$。求这 $p\times $ q个数和的最小值。

如果知道了用网络流解决，可以自然而然(?)地想到最小割。

对于 $(i,j,k)$ ，连上 $(i,j,k+1),(i,j+1,k-d),(i,j-1,k-d),(i+1,j,k-d),(i-1,j,k-d)$，再用Dinic进行最小割即可。

注意处理边界条件。

## 小结：
不知为何，有点想到分层图。

毕竟是省选题，也应该往网络流之类高大上算法去靠。

网络流这种属于变化比较多，代码比较简单的，如果想到了就呼之欲出。

感觉只要出现比较复杂的转移以及最值就可以考虑一下网络流。

最后是喜闻乐见的代码（EK网络流）
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read()
{
	int x=0,flag=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')
			flag=0;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<3)+(x<<1)+ch-'0';
		ch=getchar();
	}
	if(flag)
		return x;
	else
		return ~(x-1);
}
struct node{
	int to,val,next;
} edge[128002];
struct Pre{
	int from,pre;
} P[128002];
int fx[4]={0,1,0,-1};
int fy[4]={1,0,-1,0};
int cnt=1,p,q,r,d,s,t,inque[64001],head[6401],v[110][110][100];
inline int id(int x,int y,int z)
{
	return p*q*(z-1)+y+(x-1)*q;
}
inline bool in(int x,int y)
{
	return x>=1&&x<=p&&y>=1&&y<=q;
}
inline void add(int x,int y,int z)
{
	edge[++cnt].to=y;
	edge[cnt].val=z;
	edge[cnt].next=head[x];
	head[x]=cnt;
}
inline bool bfs()
{
	queue<int> q;
	memset(inque,0,sizeof(inque));
	inque[s]=1;
	q.push(s);
	while(!q.empty())
	{
		int f=q.front();
		q.pop();
		for(int i=head[f];i;i=edge[i].next)
			if(edge[i].val&&inque[edge[i].to]==0)
			{
				P[edge[i].to].from=f;
				P[edge[i].to].pre=i;
				if(edge[i].to==t)
					return 1;
				inque[edge[i].to]=1;
				q.push(edge[i].to);
			}
	}
	return 0;
}
inline int EK()
{
	int ans=0;
	while(bfs())
	{
		int minn=114514114514114514;
		for(int i=t;i!=s;i=P[i].from)
			minn=min(minn,edge[P[i].pre].val);
		for(int i=t;i!=s;i=P[i].from)
		{
			edge[P[i].pre].val-=minn;
			edge[P[i].pre^1].val+=minn;
		}
		ans+=minn;
	}
	return ans;
}
signed main()
{
	p=read();
	q=read();
	r=read();
	d=read();
	s=p*q*(r+1)+1;
	t=p*q*(r+1)+2;
	for(int k=1;k<=r;k++)
		for(int i=1;i<=p;i++)
			for(int l=1;l<=q;l++)
				v[i][l][k]=read();
	for(int i=1;i<=p;i++)
		for(int l=1;l<=q;l++)
		{
			add(s,id(i,l,1),114514114514114514);
			add(id(i,l,1),s,0);
			for(int k=1;k<=r;k++)
			{
				add(id(i,l,k),id(i,l,k+1),v[i][l][k]);
				add(id(i,l,k+1),id(i,l,k),0);
			}
			add(id(i,l,r+1),t,114514114514114514);
			add(t,id(i,l,r+1),0);
		}
	for(int i=1;i<=p;++i)
		for(int j=1;j<=q;++j)
			for(int k=0;k<4;++k)
			{
				int x=i+fx[k],y=j+fy[k];
				if(!in(x,y)) 
					continue;
				for(int l=d+1;l<=r+1;++l) 
				{
					add(id(i,j,l),id(x,y,l-d),114514114514114514);
					add(id(x,y,l-d),id(i,j,l),0);
				}
			}
	cout<<EK();
	return 0;	
} 
```


---


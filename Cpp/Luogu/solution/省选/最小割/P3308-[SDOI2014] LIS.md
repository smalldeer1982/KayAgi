# [SDOI2014] LIS

## 题目描述

给定序列 $A$，序列中的每一项 $A_i$ 有删除代价 $B_i$ 和附加属性 $C_i$。请删除若干项，使得 $A$ 的最长上升子序列长度减少至少 $1$，且付出的代价之和最小，并输出方案。

如果有多种方案，请输出将删去项的附加属性排序之后，字典序最小的一种。


## 说明/提示

【样例说明】

删去 $(A_2,A_3,A_6),(A_1,A_6),(A_2,A_3,A_4,A_5)$ 等都是合法的方案，但$(A_2,A_3,A_6)$ 对应的 $C$ 值的字典序最小。

对于 $100\%$ 的数据，$1\le N\le 700$，$1\le T\le 5$。


## 样例 #1

### 输入

```
1
6
3 4 4 2 2 3
2 1 1 1 1 2
6 5 4 3 2 1```

### 输出

```
4 3
2 3 6
```

# 题解

## 作者：linfourxu (赞：15)

#### 一道网络流建模+贪心求割边边集好题。

从~~数据范围~~以及求最长上升子序列相关，不难想到[这道题](https://www.luogu.com.cn/problem/P2766)。

具体的，考虑用一个流量来表示一个最长上升子序列。

一个较为显然的结论是，求出 $\text{dp}[i]$ 表示以 $i$ 为结尾的最长上升子序列的长度后，$i$ 这个位置在最长上升序列中只能位于第 $\text{dp}[i]$ 个位置~~显然很显然~~，即我们的最长上升子序列的下标序列 $\text{pos}$ 一定满足 $\text{dp}[\text{pos}[i]]=i $。

那么如果我们将所有的点满足 $i<j$ 且 $\text{dp}[i]=\text{dp}[j]-1$ 的位置 $(i,j)$ 建立一条由 $i$ 指向 $j$ 的边，令最长上升子序列的长度为了 $\text{len}$，那么任意一条最长上升子序列就可以表示为一条从 $\text{dp}[s]=1$ 的点到 $\text{dp}[t]=\text{len}$ 的点的一条路径，而回到这题的要求便是破坏所有的这种路径。

容易发现这题允许破坏的是”点“，那么最终的建图也基本明朗了起来。

1.将这 $n$ 个点拆为两个点即入点和出点，并将每个入点向对应出点连一条流量为 $B[i]$ 的边，表示破坏掉这个点的代价是 $B[i]$，也就是这题中，我们用”最小割“来表示“最小的破坏代价”。

2.将所有满足 $\text{dp}[i]=1$ 的点，建立一条由源点 $\text{S}$ 到 $i$ 入点的，流量为 $\text{inf}$ 的边；将所有满足 $\text{dp}[j]=\text{len}$ 的点，建立一条由 $j$ 出点到 汇点 $\text{T}$ 的，流量为 $\text{inf}$ 的边。

3.将所有的点满足 $i<j$ 且 $\text{dp}[i]=\text{dp}[j]-1$ 的位置 $(i,j)$ 建立一条由 $i$ 出点指向 $j$ 入点的，流量为 $\text{inf}$ 的边。这样一条条形如 $\text{S}$ -> $\text{pos}[1]$入点 -> $\text{pos}[1]$出点 -> $\text{pos}[2]$入点 -> $\text{pos}[2]$出点 -> $\dots$ -> $\text{pos}[\text{len}]$入点 -> $\text{pos}[\text{len}]$出点 -> $\text{T}$ 的增广路即为一条条最长上升子序列。而流量为 $\text{inf}$ 则表示不可破坏，实际上也就是我们只允许破坏每条"入点连向对应出点的边“。

最后跑一遍 $\text{S}$ 到 $\text{T}$ 的最小割即可求出第一问的最小代价。

再考虑如何确定出附加属性字典序最小的最小割割边边集。

首先容易发现的是，成为割边的一定是”入点连向对应出点的边“，~~这显然是我们一手策划的~~，将题目中的 $C$ 数组 $\text{sort}$ 之后，按顺序考虑每条边是否可能成为割边，如果可能的话就强制钦定它为割边。

具体实现的时候也不需要其他题解那么麻烦，判断一条边是否为割边，显然就是从该边的入点无法到达出点（当然不走流量为 $0$ 的边），代码实现上只需要调用一遍 $\text{dinic}$ 中的 $\text{bfs}$ 函数即可。而强制钦定他为割边只需要将所有边复原后，删除这条边（将它和它的反向边流量都置为 $0$ 即可），再重新跑一遍 $S$ 到 $T$ 的最小割用以得到新图的最小割即可。

最后将得到的”需破坏点“下标 $\text{sort}$ 一遍即可。

复杂度就是 $n$ 遍 $\text{dinic}$ 的复杂度，如果将边的数量看作 $n^2$ 的话，复杂度就是 $\Theta(n^5)$ ~~实际上哪里都不满~~

最后放一下代码

```cpp
inline void add(rint x,rint y,rint flow)
{
	e[++cnt]=(Edge){y,head[x],flow},head[x]=cnt;
}

int bfs(rint s,rint t)
{
	memset(dis,0,sizeof(dis)),memcpy(tmphead,head,sizeof(head));
	queue<int> q;q.push(s),dis[s]=1;
	while(!q.empty())
	{
		rint u=q.front();q.pop();
		for(rint i=head[u];i;i=e[i].next)
		{
			rint v=e[i].to;
			if(!e[i].flow||dis[v]) continue;
			dis[v]=dis[u]+1,q.push(v);
			if(v==t) return 1;
		}
	}
	return 0;
}

int dfs(rint x,rint t,rint flow)
{
	if(x==t) return flow;
	rint rest=flow;
	for(rint i=tmphead[x];i;i=e[i].next)
	{
		tmphead[x]=i;rint v=e[i].to;
		if(!e[i].flow||dis[v]!=dis[x]+1) continue;
		rint tmp=dfs(v,t,min(rest,e[i].flow));
		tmp?e[i].flow-=tmp,e[i^1].flow+=tmp,rest-=tmp:dis[v]=0;
		if(!rest) return flow;
	}
	return flow-rest;
}

inline void add_edge(rint x,rint y,rint flow)
{
	add(x,y,flow),add(y,x,0);
}

int main()
{
	for(rint tt=read<int>();tt;tt--)
	{
		rint n=read<int>(),mx=0,s=0,t=n*2+1;memset(head,0,t+1<<2),cnt=1;
		for(rint i=1;i<=n;i++) a[i]=read<int>();
		for(rint i=1;i<=n;i++)
		{
			dp[i]=1;
			for(rint j=1;j<i;j++)
				if(a[i]>a[j])
					dp[i]=max(dp[i],dp[j]+1);
			mx=max(mx,dp[i]);
		}
		for(rint i=1;i<=n;i++) add_edge(i,i+n,read<int>());
		for(rint i=1;i<=n;i++)
		{
			if(dp[i]==1) add_edge(s,i,inf);
			if(dp[i]==mx) add_edge(i+n,t,inf);
			for(rint j=i+1;j<=n;j++)
				if(a[i]<a[j]&&dp[j]==dp[i]+1)
					add_edge(i+n,j,inf);
		}
		for(rint i=1;i<=n;i++) c[i]=(Node){read<int>(),i};
		sort(c+1,c+n+1,[](const Node &x,const Node &y){return x.val<y.val;});
		rll ans=0;rint N=0;
		while(bfs(s,t)) ans+=dfs(s,t,inf);
		for(rint i=1;i<=n;i++)
		{
			rint u=c[i].id,v=u+n;
			if(!bfs(u,v))
			{
				b[++N]=u,e[u*2].flow=e[u*2+1].flow=0;
				for(rint i=2;i<=cnt;i+=2) e[i].flow+=e[i^1].flow,e[i^1].flow=0;
				while(bfs(s,t)) dfs(s,t,inf);
			}
		}
		sort(b+1,b+N+1),printf("%lld %d\n",ans,N);
		for(rint i=1;i<=N;i++) printf("%d ",b[i]);puts("");
	}
	return 0;
}
```

---

## 作者：inc1ude_c (赞：11)

怎么都用跑 $n$ 遍网络流来解决字典序最小的最小割呢？

所以本题解就来介绍（且只介绍）跑完一次网络流后用 $O(n+m)$ 来求出字典序最小的最小割的方法，对于原题的建模转换，可以去看看其他题解。

先跑一次网络流，随后我们在残余网络（即只把有流量的边拿出来建的新图）上跑一遍 Tarjan，会得到一张 DAG，并且这张 DAG 上只有满流边（否则其与其反边都有流量，就会被缩掉）。

考虑最小割在这张 DAG 表现出来什么特征，容易发现一个割集 $\{S,T\}$ 是最小割，当且仅当不存在 $T\to S$ 的满流边，割这种边一定不优。

于是考虑按编号从小到大枚举每条边 $(u,v)$ 来贪心构造 $\{S,T\}$，具体的，查看这条边是不是确定了 $u\in T$ 或 $v\in S$，如果是，那么它肯定不能存在于最小割中；否则就将其加入最小割，并把 $u$ 的前驱标记为属于 $S$，$v$ 的后继标记为属于 $T$。

![](https://cdn.luogu.com.cn/upload/image_hosting/3jxqy9sd.png)

（拙劣的示意图）

因为每个点只会被遍历一次所以这个地方复杂度 $O(n+m)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
const int N=705*2;
int n,a[N],b[N];struct Item{int c,id;bool operator<(const Item&_)const{return c<_.c;}}c[N];
int f[N],S,T,id[N];
struct Edge{int v;ll c;int ne;}e[N*N];int h[N],cur[N],ecnt;
void add(int u,int v,ll c){
    e[++ecnt]={v,c,h[u]};h[u]=cur[u]=ecnt;
    e[++ecnt]={u,0,h[v]};h[v]=cur[v]=ecnt;
}
int gap[N],dis[N];
ll dfs(int u,ll lim){
    if(u==T)return lim;
    int sum=0;
    for(int &i=cur[u];i;i=e[i].ne){
        if(e[i].c&&dis[u]==dis[e[i].v]+1){
            ll res=dfs(e[i].v,min(lim,e[i].c));
            e[i].c-=res;e[i^1].c+=res;sum+=res;lim-=res;
            if(!lim)return sum;
        }
    }
    if(!--gap[dis[u]])dis[S]=T+2;
    gap[++dis[u]]++;
    cur[u]=h[u];
    return sum;
}
ll Dinic(){
    ll ans=0;rep(i,0,T+2)gap[i]=dis[i]=0;
    gap[0]=T+1;
    while(dis[S]<T+2)ans+=dfs(S,1e14);
    return ans;
}
int tim,dfn[N],low[N],sta[N],tp;bool in[N];
int cnt,bel[N];
void dfs2(int x){
    dfn[x]=low[x]=++tim;
    sta[++tp]=x;in[x]=1;
    for(int i=h[x];i;i=e[i].ne){
        if(!e[i].c)continue;
        if(!dfn[e[i].v]){
            dfs2(e[i].v);
            low[x]=min(low[x],low[e[i].v]);
        }else if(in[e[i].v])low[x]=min(low[x],dfn[e[i].v]);
    }
    if(dfn[x]==low[x]){
        cnt++;
        while(in[x]){
            in[sta[tp]]=0;
            bel[sta[tp]]=cnt;tp--;
        }
    }
}
int col[N];
void dfs3(int x,int co){
    if(col[x])return ;
    col[x]=(co?1:-1);
    for(int i=h[x];i;i=e[i].ne){
        if((co?e[i^1].c:e[i].c)||bel[x]==bel[e[i].v])dfs3(e[i].v,co);
    }
}
void solve(){
    scanf("%d",&n);
    rep(i,1,n)scanf("%d",&a[i]);
    rep(i,1,n)scanf("%d",&b[i]);
    rep(i,1,n)scanf("%d",&c[i].c),c[i].id=i;
    f[0]=0;int mx=0;
    rep(i,1,n){
        f[i]=0;
        rep(j,0,i-1)if(a[j]<a[i])f[i]=max(f[i],f[j]+1);
        mx=max(mx,f[i]);
    }
    ecnt=1;S=0;T=2*n+1;
    rep(i,1,n){
        if(f[i]==1)add(S,i*2-1,1e14);
        if(f[i]==mx)add(i*2,T,1e14);
        rep(j,1,i-1)if(f[j]==f[i]-1&&a[j]<a[i])add(j*2,i*2-1,1e14);
        add(i*2-1,i*2,b[i]);id[i]=ecnt-1;
    }
    ll ans=Dinic(),sum=0;
    printf("%lld ",ans);vector<int>tans;
    sort(c+1,c+n+1);
    rep(i,S,T)if(!dfn[i])dfs2(i);
    dfs3(S,0);dfs3(T,1);
    rep(i,1,n){
        if(e[id[c[i].id]].c)continue;
        int u=c[i].id*2-1,v=c[i].id*2;
        if(bel[u]==bel[v])continue;
        //col=1表示归属于T，col=-1表示归属于S
        if(col[u]!=1&&col[v]!=-1)tans.push_back(c[i].id),dfs3(u,0),dfs3(v,1);
    }
    sort(tans.begin(),tans.end());
    printf("%d ",tans.size());puts("");
    for(auto j:tans)printf("%d ",j);puts("");
    rep(i,S,T)h[i]=dfn[i]=low[i]=in[i]=sta[i]=bel[i]=col[i]=0;tp=cnt=tim=0;
}
int main(){
    int T;scanf("%d",&T);
    while(T--)solve();
    return 0;
}
```

跑得比较快，目前最优解。

---

## 作者：asuldb (赞：7)

这道题还是非常好的

首先第一问可以让我们联想到某网络流二十四题里的一道题，发现建图方式应该和这道题差不多啊

所以首先跑一遍$dp$，求出$dp[i]$表示$i$位置结束的$LIS$长度，设最长的$LIS$长度为$M$

我们考虑一下如果想要使得这个$M$减小要割掉一些点，显然我们割掉的是点，所以将每一个点$i$拆成$i$和$i'$两个点，之后在$i$和$i'$之间连一条容量为$b_i$的边，表示割掉这个点的代价是$b_i$

之后我们将那些$dp[i]=M$点的$i'$向$T$连边，$S$向$dp[i]=1$的$i$连边，容量都是$inf$，表示这些边割不掉

之后跑一遍最小割就是第一问的答案了

考虑第二问，我们要构造一组字典序最小的最小割

首先有一个前置知识，就是最小割的可行边与必须边

一条边是最小割的可行边，就表明这条边存在于某一种最小割中

一条边$(u,v)$是最小割的可行边需要满足两个条件

1. $(u,v)$满流

1. 不存在从$u$到$v$的增广路径

我们只需要看看从$u$到$v$能不能$bfs$就好了

所以我们的答案就一定是最小割的可行边，我们开始构造这个最小割集

我们按照边的权值排序，如果一条边是可行边，我们就需要把这条边加入答案

同时选择了这条边的话我们就得排除和这条边等价的那些边的影响

这条边等价的那些边显然会存在于$S$到$u$和$v$到$T$的路径上，我们只需要从$u$向$S$，$T$向$v$退流,把那些满流的边的流量清掉

退流的话跑一遍$dinic$就好了

同时注意优化一下$dinic$的常数，有一点卡常

代码

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
#define re register
#define maxn 1505
#define LL long long
#define inf 999999999
inline int max(int a,int b){return a>b?a:b;}
inline int min(int a,int b){return a<b?a:b;}
inline int read()
{
    char c=getchar();int x=0;while(c<'0'||c>'9') c=getchar();
    while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+c-48,c=getchar();return x;
}
struct node{int a,b,c,rk;}g[maxn];
inline int cmp(node A,node B) {return A.c<B.c;}
struct E{int v,nxt,w,f;}e[maxn*maxn];
int n,num=1,S,T,Test;
int ans[maxn],cnt,id[maxn],vis[maxn];
int d[maxn],dp[maxn],head[maxn],cur[maxn],in[maxn],out[maxn];
inline void add(int x,int y,int z) {e[++num].v=y;e[num].nxt=head[x];head[x]=num;e[num].w=z;}
inline void C(int x,int y,int z) {add(x,y,z),add(y,x,0);}
inline int check(int s,int t)
{
    std::queue<int> q;
    memset(vis,0,sizeof(vis));
    q.push(s);vis[s]=1;
    while(!q.empty())
    {
        int k=q.front();q.pop();
        if(k==t) return 1;
        for(re int i=head[k];i;i=e[i].nxt)
        if(!vis[e[i].v]&&e[i].w>e[i].f) q.push(e[i].v),vis[e[i].v]=1;
    }
    return 0;
}
inline int BFS(int s,int t)
{
    std::queue<int> q;
    memcpy(cur,head,sizeof(head));
    memset(d,0,sizeof(d));
    d[s]=1,q.push(s);
    while(!q.empty())
    {
        int k=q.front();q.pop();
        for(re int i=head[k];i;i=e[i].nxt)
        if(!d[e[i].v]&&e[i].w>e[i].f) 
        {
            d[e[i].v]=d[k]+1;
            if(e[i].v==t) return 1;
            q.push(e[i].v);
        }
    }
    return d[t];
}
int dfs(int x,int now,int t)
{
    if(x==t||!now) return now;
    int flow=0,ff;
    for(re int& i=cur[x];i;i=e[i].nxt)
    if(d[e[i].v]==d[x]+1)
    {
        ff=dfs(e[i].v,min(now,e[i].w-e[i].f),t);
        if(ff<=0) continue;
        now-=ff,flow+=ff;
        e[i].f+=ff,e[i^1].f-=ff;
        if(!now) break;
    }
    return flow;
}
int main()
{
    Test=read();
    while(Test--)
    {
        n=read();cnt=0;num=1;memset(head,0,sizeof(head));
        for(re int i=1;i<=n;i++) g[i].a=read(),dp[i]=1;
        for(re int i=1;i<=n;i++) g[i].b=read(),g[i].rk=i;
        for(re int i=1;i<=n;i++)
            for(re int j=1;j<i;j++) if(g[j].a<g[i].a) dp[i]=max(dp[j]+1,dp[i]);
        int tot=0;
        for(re int i=1;i<=n;i++) tot=max(tot,dp[i]);
        T=0;
        for(re int i=1;i<=n;i++) in[i]=++T;
        for(re int i=1;i<=n;i++) out[i]=++T;++T;
        for(re int i=1;i<=n;i++) C(in[i],out[i],g[i].b),id[i]=num;
        for(re int i=1;i<=n;i++) if(dp[i]==1) C(S,in[i],inf);
        for(re int i=1;i<=n;i++) if(dp[i]==tot) C(out[i],T,inf);
        for(re int i=1;i<=n;i++)
            for(re int j=1;j<i;j++) if(g[j].a<g[i].a&&dp[j]+1==dp[i]) C(out[j],in[i],inf);
        tot=0;
        while(BFS(S,T)) 
            tot+=dfs(S,inf,T);
        for(re int i=1;i<=n;i++) g[i].c=read();
        printf("%d ",tot);
        std::sort(g+1,g+n+1,cmp);
        for(re int i=1;i<=n;i++)
        {
            int k=g[i].rk;
            if(check(in[k],out[k])) continue;
            ans[++cnt]=k;
            while(BFS(T,out[k])) dfs(T,inf,out[k]);
            while(BFS(in[k],S)) dfs(in[k],inf,S);
            e[id[k]].w=e[id[k]^1].w=0;
            e[id[k]].f=e[id[k]^1].f=0;
        }
        printf("%d\n",cnt);
        std::sort(ans+1,ans+cnt+1);
        for(re int i=1;i<=cnt;i++) printf("%d ",ans[i]);putchar(10);
    }
    return 0;
}
```

---

## 作者：magolor (赞：5)

LIS最小割：

拆点，

所有Xj向Yj连权值边；

对于A[k]<A[j]，且f[j]==f[k]+1的点Yk和Xj之间连INF边；

对于f[j]==1的点连S和X的INF边，对于f[j]==maxi的点Y和T的连INF边。


但输出方案要求字典序最小，贪心选择最小的可能存在在最小割中的边

（这里的边是连接同一点X和Y的边，在最小割上当且仅当 满流&&不能增广 两个条件）。

选择一条边后要删除它对其他边选择的影响，所以退流：边的靠S端点向S退边权流，T端点向靠T端点退边权流。

退流就是倒着跑一次Dinic（更改源点和汇点）


不明白的，见代码，理解一下：










```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
#define MAXN 2000
#define MAXM 1000000
#define INF 0x3f3f3f3f
#define ll long long
#define X(x) (x)
#define Y(x) (x+n)
#define gc() getchar()
inline int read(int ans = 0, int sgn = ' ', int ch = gc())
{
    for(;ch < '0' || ch > '9'; sgn=ch,ch=gc());
    for(;ch >='0' && ch <='9'; (ans*=10)+=ch-'0',ch=gc());
    return sgn-'-' ? ans : -ans;
}
struct Edge{int to,nex;ll c;Edge(int _to=0, int _nex=0, ll _c=0):to(_to),nex(_nex),c(_c){}}e[MAXM+5];
int first[MAXN+5], q[MAXN+5], level[MAXN+5], cur[MAXN+5], A[MAXN+5], B[MAXN+5], C[MAXN+5], f[MAXN+5], K[MAXN+5], s[MAXN+5], E[MAXN+5], tot, testcase, maxi, num, n, m, SS, TT;
inline void Add(int a, int b, ll c)
{
    e[tot] = Edge(b,first[a],c), first[a] = tot++;
    e[tot] = Edge(a,first[b],0), first[b] = tot++;
    return;
}
inline bool BFS(int S, int T)
{
    memset(level,0,sizeof(level)), q[0] = S, level[S] = 1;
    for(register int head = 0, tail = 1, t, u, v; head-tail; )
        for(t = q[head++], head %= MAXN, u = first[t]; u+1; u = e[u].nex)
            if(e[u].c > 0 && !level[v=e[u].to])
            {
                level[v] = level[t]+1, q[tail++] = v, tail %= MAXN;
                if(v == T)
                    return true;
            }
    return false;
}
ll DFS(int p, ll f, int S, int T, ll tag = 0, ll del = 0)
{
    if(p == T)
        return f;
    for(register int &u = cur[p], v; u+1; u = e[u].nex)
        if(e[u].c > 0 && level[v=e[u].to] == level[p]+1)
        {
            del = DFS(v,min(e[u].c,f-tag),S,T), e[u].c -= del, e[u^1].c += del, tag += del;
            if(f == tag)
                return tag;
        }
    return tag;
}
inline ll Dinic(int S, int T, ll ans = 0)
{
    for(register int i; BFS(S,T); ans += DFS(S,INF,S,T))
        for(i = 0; i <= 2*n+1; cur[i] = first[i], i++);
    return ans;
}
inline void Build()
{
    n = read(), memset(first,-1,sizeof(first)), tot = 0, SS = 0, TT = 2*n+1, maxi = 0;
    for(register int i = 1; i <= n; A[i] = read(), i++);
    for(register int i = 1; i <= n; B[i] = read(), i++);
    for(register int i = 1; i <= n; C[i] = read(), i++);
    for(register int i = 1, j; i <= n; maxi = max(maxi,f[i]), i++)
        for(f[i] = 1, j = 1; j < i; j++)
            if(A[j] < A[i])
                f[i] = max(f[i],f[j]+1); 
    for(register int i = 1, j; i <= n; E[i] = tot, Add(X(i),Y(i),B[i]), i++)
    {
        if(f[i] == 1)
        {
            Add(SS,X(i),INF);
            continue;
        }
        if(f[i]==maxi)
            Add(Y(i),TT,INF);
        for(j = 1; j < i; j++)
            if(A[j] < A[i] && f[i] == f[j]+1)
                Add(Y(j),X(i),INF);
    }
    return;
}
inline bool cmp(int x, int y)
{
    return (C[x]-C[y] ? C[x]<C[y] : x<y);
}
inline bool Check(int p)
{
    return !(e[E[p]].c || BFS(X(p),Y(p)));
}
inline void Calc()
{
    for(register int i = 1; i <= n; K[i] = i, i++);
    sort(K+1,K+n+1,cmp);
    for(register int i = num = 1; i <= n; i++)
        if(Check(K[i]))
            s[num++] = K[i], Dinic(TT,Y(K[i]),B[K[i]]), Dinic(X(K[i]),SS,B[K[i]]), e[E[K[i]]].c = e[E[K[i]]^1].c = 0;
 return;
}
int main()
{
    for(testcase = read(); testcase--; printf("%d\n",s[num]))
    {
        Build(), printf("%d ",Dinic(SS,TT)), Calc(), num--, printf("%d\n",num), sort(s+1,s+num+1);
        for(register int i = 1; i < num; printf("%d ",s[i]), i++);
    }
     return 0;
}

```

---

## 作者：FutaRimeWoawaSete (赞：3)

我们可以考虑首先用 dp 求解以每个点结尾的最长上升子序列长度。

若一个点能被它前面的一个点转移，那么它前面的点向它连边。

假设有源点和汇点，源点向所有 $dp_i = 1$ 的位置连边，汇点向所有 $dp_i = ans$ 的位置连边。

上述的边都是不可割的，但是点可以割，问题转化成了通过删点将原图划分为两个点集的最小权值。

这个是套路，直接将点权拆成边权，一个点拆成入点和出点后入点向出点连边权为原点权的边后跑最小割即可。

考虑字典序的限制，可以转化为从小到大枚举每条表示割点的边是否可强制割去，共跑 $n$ 次网络流即可。

删就直接看在上一次的残余网络上两点是否已经完全不联通了，是的话就说明这条边可以强制选择后割去。

```cpp
#include "bits/stdc++.h"
using namespace std;
const int Len = 700 * 2 + 5;
const long long Inf = 1e18;
int n,m,head[Len],cnt = 1,dp[Len],a[Len],b[Len],S,T,ks[Len],dep[Len],cur[Len];
struct node
{
	int next,to;long long w;
}edge[Len * Len * 2];
inline void add(int from,int to,long long w)
{
	edge[++ cnt].to = to;
	edge[cnt].next = head[from];
	edge[cnt].w = w;
	head[from] = cnt;
}
inline void Ad(int x,int y,long long w){add(x , y , w);add(y , x , 0);}
inline int BFS(int s,int t)
{
	queue<int> q;
	for(int i = 1 ; i <= T ; i ++) dep[i] = cur[i] = 0;
	dep[s] = 1;q.push(s);cur[s] = head[s];
	while(!q.empty())
	{
		int p = q.front();q.pop();
		for(int e = head[p] ; e ; e = edge[e].next)
		{
			int to = edge[e].to;
			if(!dep[to] && edge[e].w)
			{
				dep[to] = dep[p] + 1;
				cur[to] = head[to];
				q.push(to);
				if(to == t) return 1;
			}
		}
	}
	return dep[t];
}
long long dfs(int u,long long In)
{
	if(u == T) return In;
	long long Out = 0;
	for(int e = cur[u] ; e && In > 0 ; e = edge[e].next)
	{
		cur[u] = e;
		int to = edge[e].to;
		if(edge[e].w && dep[to] == dep[u] + 1)
		{
			long long res = dfs(to , min(In , 1ll * edge[e].w));
			In -= res;
			Out += res;
			edge[e].w -= res;
			edge[e ^ 1].w += res;
		}
	}
	if(!Out) return dep[u] = 0;
	return Out;
}
struct niyoubingba
{
	int c,id;
}bs[Len];
vector<int> Print;
inline bool cmp(niyoubingba x,niyoubingba y){return x.c < y.c;}
int main()
{
	int TT;scanf("%d",&TT);
	while(TT --)
	{
		memset(head , 0 , sizeof head);cnt = 1;
		scanf("%d",&n);
		for(int i = 1 ; i <= n ; i ++) scanf("%d",&a[i]);
		for(int i = 1 ; i <= n ; i ++) scanf("%d",&b[i]);
		for(int i = 1 ; i <= n ; i ++){scanf("%d",&bs[i].c);bs[i].id = i;}
		int mxlen = 0;
		for(int i = 1 ; i <= n ; i ++) 
		{
			dp[i] = 1;
			for(int j = 1 ; j < i ; j ++) if(a[j] < a[i]) dp[i] = max(dp[i] , dp[j] + 1);
			mxlen = max(mxlen , dp[i]);
		}
		S = (n << 1) + 1 , T = S + 1;
		for(int i = 1 ; i <= n ; i ++) 
		{
			ks[i] = cnt + 1;
			Ad(i , i + n , b[i]);
		}
		for(int i = 1 ; i <= n ; i ++) 
		{
			if(dp[i] == 1) Ad(S , i , Inf);
			if(dp[i] == mxlen) Ad(i + n , T , Inf);
		}
		for(int i = 1 ; i <= n ; i ++) 
			for(int j = i + 1 ; j <= n ; j ++) if(a[i] < a[j] && dp[j] == dp[i] + 1) Ad(i + n , j , Inf);
		long long ans = 0;
		while(BFS(S , T)) 
		{
			long long kkk = dfs(S , Inf);
			ans += kkk;
			//printf("%lld\n",kkk);
		}
		sort(bs + 1 , bs + 1 + n , cmp);
		for(int i = 1 ; i <= n ; i ++)
		{
			int x = bs[i].id , y = x + n;
			if(!BFS(x , y)) 
			{
				Print.push_back(x);edge[ks[x]].w = edge[ks[x] ^ 1].w = 0;
				for(int e = 2 ; e <= cnt ; e += 2) edge[e].w += edge[e ^ 1].w , edge[e ^ 1].w = 0;
				long long nus = 0;
				while(BFS(S , T)) nus += dfs(S , Inf);
			}
		}
		int sz = Print.size();printf("%lld %d\n",ans,sz);
		sort(Print.begin() , Print.end());
		for(int i = 0 ; i < sz ; i ++) printf("%d ",Print[i]);
		Print.clear();
		puts("");
	}
	return 0;
}
```

---

## 作者：sangshang (赞：2)

# Description

给出一个长度为 $n$ 的序列，每一项都有三个属性 $A,B,C$。将一个点炸掉，花费 $B_i$ 的钱，要求将一些点炸掉，并使以 $A$ 为值的最长上升子序列产度减少至少一。


要求输出方案，方案要求炸掉的点的 $C$ 值排序后字典序最小。

# Solution

## 最小费用

- 看到“炸点”可以想到最小割。

最小割那得有路径啊？

- 最长上升子序列至少减一，可以看作，任意一条最长上升子序列都至少包含所炸点中的一个。最长上升子序列的每一个项可以看作路径上一点，对于每个可能的，组成最长上升子序列的两点之间连一条路径（容量为 $+\infty$，不可割掉，表示一种最长上升子序列所经过的路径）。对每个项进行拆点，入点和出点连一条容量为 $B_i$ 的边，割掉表示将此点炸掉，同时，与此点相连的路径不再联通。

- 考虑 $O(n^2)$ 的 DP 算法求解可能的最长上升子序列所经过的点，因为 DP 求解可以很方便的求出最长上升子序列是如何组成的。DP 普及组内容就不介绍了。用 $f[i]$ 表示从一到 $i$ 中选取，且必须选 $i$ 的最长上升子序列。如果对于一个 $j,j\in [1,i-1]$，如果 $A_j<A_i$ 并且 $f[j]+1=f[i]$，那说明从 $j$ 到 $i$ 可能是组成最长上升子序列的一部分。$f[i]$ 等于 $1$ 时，说明是可能的起点，$f[i]=\operatorname{LIS}$ 时，说明是可能的终点。

接下来，求出路径后，对于每个点 $i$ 拆成入点和出点。连容量为 $B_i$ 边。对于一条可能的路径 $i\to j$，连边 $i$ 的出点，到 $j$ 的入点，容量为 $+\infty$ 的边，表示一种不可被割的路径。跑完最小割就是最小费用。

## 最小割边集

一条边被割，它一定是满流的，因为最大流没把它流满说明还有费用更小的边被割。但满流的边不一定都被割，因为若路径上多边流量相同，且都满流，那肯定只用割其中一边。

>事实上，一条边 $(u,v)$ 被割，当且仅当不存在从 $u$ 到 $v$ 的还有残余流量的路径。

>首先，原图一定被割成了两部分（下文假定图联通），一部分与源点连通，另一部分与汇点连通。因为，若有连通块既不与源点连通，又不与汇点连通。那去掉一些无需割的边，将其加入到源点或汇点的连通块中一个一定更优。此时，如果边 $(u,v)$ 被割，$u,v$ 一定在不同连通块；相反，若没被割，$u,v$ 一定在相同连通块。

根据如上分析，基于一个贪心思想，因为字典序优先比较最前面的元素，所以我们只要优先判断 $C$ 值小的点所对应的边，如果对应的边是可以属于任意一个最小割边集，就将其从原图中去掉，还原边权，重新跑最小割，求出边集。因为其，属于任意一个最小割边集，所以，将其从图中剃掉再继续求剩余最小割边集也是正确的，同时可保证字典序最小。

## Code

[Code](https://www.luogu.com.cn/paste/844okctg)

注意，Dinic 当前弧优化万不可写成如下形式：


```cpp
for (int &i = cur[u]; i < sz && flow; ++i) {
```

模拟一下算法计算过程：

1. 点 $u$ 对第 $i$ 条边进行寻找增广路。

2. 找到增广路，进行增广，发现从源点到点 $u$ 的流量 $flow$ 流完了，但边 $i$ 还有剩余流量。

3. 一轮循环结束，$cur[u]$ 被设成 $i+1$。

4. 下一轮循环开始，但因为 $flow=0$ 结束循环。

此时第 $i$ 条边还有残余容量，但当前弧直接跳过了它，导致算法效率大跌。

请务必写成如下形式：

```cpp
for (int i = cur[u]; i < sz && flow; ++i) {
	cur[u] = i;
```

---

## 作者：Purslane (赞：2)

# Solution

对于第一问，这是很典的网络流模型。

考虑先求出每个点的 $dp_i$ 表示以 $i$ 结尾的最长上升子序列的长度。$j$ 是 $i$ 的**前驱**当且仅当 $j<i$ 且 $a_j < a_i$ 且 $dp_j+1=dp_i$。

然后对于所有 $dp_k=\max_{i=1}^n dp_i$，$k$ 的所有沿前驱走到 $0$ 的这一串数中间必须有一个数被删掉。于是就是拆点最小割问题。

上面的内容是普及组内容，非常简单。

但是我本人才疏学浅，根本不知道怎么求字典序最小的最小割。

但是考虑我从小到大枚举最小割的每一位。如果当前图 $s$ 和 $t$ 已经分开，那么直接结束过程。

否则，假设当前我们要删去数 $t$。考虑把 $t$ 拆点后那条边给**删掉**（相当于直接钦定它是最小割中的一个点），求出新的最小割，看看他们之间差的是不是恰好为删掉的那条边的价值。如果差的很少，那么说明这条边不可能存在于最小割之中。（由于“字典序”严重依赖最前面的位置，所以我们这么贪心的做是对的。）

非常简单粗暴。但是好像和题解中的东西不大一样。

题解如何判断当前状态下一条边是否可以在最小割中出现呢？

我们看一个不等式放缩。对于任何一个割（假设两个集合是 $S$ 和 $T$），都有：

$$\sum_{u\in S,v\in T,(u,v)\in E} c(u,v) \ge \sum_{u \in S,v\in T,(u,v) \in E} f(u,v) = w$$

其中 $w$ 是最大流。（至于右边那个等式为啥对，考虑你是一个流量，你每次从 $S$ 到 $T$ 会给 $\sum f$ 带来 $1$ 的贡献，穿回去会带来 $-1$ 的贡献。而最终你在 $t$，因此总的贡献就是 $1$。）

> 个人认为这个不等式是处理“最小割问题”的一个很重要的手段。

因此，如果我们这个割是最小割，那么必须有 $f(u,v)=c(u,v)$，也就是这条边**满流**。

不过呢，事情并非总是这样。因为我这条边满流，不代表我能找到一个穿过这条边的割，使得其他割上的边都满流啊！

因此还有一个限制条件：不存在 $u$ 到 $v$ 的**增广路**。因为如果存在，那么每次我们都必须断掉这条增广路上的一条边。你发现第二个限制包含了第一个，因此我们只需要看一看 $u$ 能不能到 $v$，通过有容量的边。

> 注：这个条件实际上是充要的。必要性显然，因为如果存在一个把 $u$ 和 $v$ 隔开的割，那么所有 $u$ 到 $v$ 的路径必然都至少有一条边是满流的。相反，如果 $u$ 到 $v$ 的路径每一条都至少有一条边是满流的，那么至少只关注这些满流边，他们足以把 $s$ 到 $t$ 给堵起来。然后你删掉其中赘余的，总能形成一个割，把 $u$ 和 $v$ 隔开。

PS：上面的东西都是我根据网上的资料自己胡言乱语几句，并没有系统学习过。如果有错，轻喷。

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1400+10;
int T,n,tot,a[MAXN],b[MAXN],c[MAXN],hd[MAXN],id[MAXN],dp[MAXN],s,t; 
struct Edge {int to,nxt,w;}edge[MAXN*MAXN*2];
int add_edge(int u,int v,int f) {
	edge[++tot]={v,hd[u],f},hd[u]=tot;
	edge[++tot]={u,hd[v],0},hd[v]=tot;	
	return tot-1;
}
int cur[MAXN],dis[MAXN];
int bfs(int s,int t) {
	memset(dis,-1,sizeof(dis)),dis[s]=0;
	queue<int> q; q.push(s);
	while(!q.empty()) {
		int u=q.front(); q.pop();
		cur[u]=hd[u];
		for(int i=hd[u];i;i=edge[i].nxt) {
			int to=edge[i].to,w=edge[i].w;
			if(dis[to]!=-1||!w) continue ;
			dis[to]=dis[u]+1,q.push(to);
		}
	}
	return dis[t]!=dis[n+n+2];
}
int dinic(int u,int res) {
	int ans=0;
	if(u==n+n+1) return res;
	for(int i=cur[u];i;i=edge[i].nxt) {
		cur[u]=i;
		int to=edge[i].to,w=edge[i].w;
		if(!w||dis[to]!=dis[u]+1) continue ;
		int tmp=dinic(to,min(res,w));
		if(tmp) {
			edge[i].w-=tmp,edge[i^1].w+=tmp,ans+=tmp,res-=tmp;
			if(res==0) break;	
		} else dis[to]=-1;
	}
	return ans;
}
void solve(void) {
	cin>>n,tot=1,memset(hd,0,sizeof(hd));
	ffor(i,1,n) cin>>a[i];
	ffor(i,1,n) cin>>b[i];
	ffor(i,1,n) cin>>c[i];	
	ffor(i,1,n) id[i]=add_edge(i,i+n,b[i]);
	ffor(i,1,n) {
		dp[i]=0;
		ffor(j,0,i-1) if(a[i]>a[j]) dp[i]=max(dp[i],dp[j]+1);
		ffor(j,0,i-1) if(a[i]>a[j]&&dp[i]==dp[j]+1) if(j) add_edge(j+n,i,998244353); else add_edge(0,i,998244353);
	}
	int k=*max_element(dp+1,dp+n+1);
	ffor(i,1,n) if(dp[i]==k) add_edge(i+n,n+n+1,998244353);
	vector<int> ans;
	int flow=0,tmp=0;
	while(bfs(0,n+n+1)) while(tmp=dinic(0,998244353)) flow+=tmp;
	cout<<flow<<' ';
	vector<pair<int,int>> vc;
	ffor(i,1,n) vc.push_back({c[i],i});
	sort(vc.begin(),vc.end());
	ffor(i,0,n-1) {
		int idx=vc[i].second;
		if(bfs(idx,idx+n)==0) {
			ans.push_back(idx);	
			edge[id[idx]].w=edge[id[idx]^1].w=0;
			for(int j=2;j<=tot;j+=2) edge[j].w+=edge[j^1].w,edge[j^1].w=0;
			flow=0;
			while(bfs(0,n+n+1)) while(tmp=dinic(0,998244353)) flow+=tmp;
			if(flow==0) break;
		}
	}
	cout<<ans.size()<<'\n';
	sort(ans.begin(),ans.end());
	for(auto id:ans) cout<<id<<' ';
	cout<<'\n';
	return ;
}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>T;
	while(T--) solve();
	return 0;
}
```

---

## 作者：lingfunny (赞：1)

## Solution

[原题](https://www.luogu.com.cn/problem/P3308)

### Point 1 建图
首先是如何建模 $A$ 的最长上升子序列，可以参考[这道题](https://www.luogu.com.cn/problem/P2766)。

简单描述一下，就是对于每一个位置 $i$，求出以 $A_i$ 结尾的最长上升子序列长度 $dp_i$，此时最长上升子序列长度 $len$ 就是 $\max\{dp_i\}$。

然后将满足 $dp_j=dp_i+1$，$A_j>A_i$，$j>i$ 的 $j$ 与 $i$ 相连，对于本题的样例应该最终的图张这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/79lwd8iz.png)

最后将源点 $s$ 与 $dp_i=1$ 的 $i$ 相连，将 $dp_i=len$ 的 $i$ 与汇点 $t$ 相连，就能保证每条路跑出来都一定是 **最长** 的了。

不难想到，如果要使最长上升子序列长度 $-1$，必然要让 $s,t$ 不连通。反证法易得，$s,t$ 连通时必然有一条路径能经过 $len$ 个点。

既然要使 $s,t$ 不连通，其实就是求最小割点。可以考虑拆点，将每个点拆分为 $u_1,u_2$ 两部分，连接一条 $(u_1,u_2,w_u)$ 的边，对于原图中 $(u,v)$ 改为 $(u_2,v_1,\inf)$，这样就能将最小割点转化为最小割边（即最小割）了。

### Point 2 方案输出

直接将图看成一张网络，现在需要求的就是字典序最小的割边方案。

想想最小割的定义，将点分为两个集合 $S,T$，割掉总权值最小的一些边使得 $S,T$ 不连通。那么对于一条边 $(u,v)$，它能成为最小割边当前仅当满足下面两个条件：

1. $(u,v)$ 满流。
2. **残量网络** 上不存在 $u\to v$ 的路径。因为在满足第一点的前提下，必然存在 $v\to u$ 的路径，这句话其实就是说 $u,v$ 不在同一个强连通分量里。

运用 **最大流最小割定理**，可以很容易推出第一点。

对于第二点，如果 $u,v$ 在同一个 SCC 里，那一定可以通过流量调整（匀一点流量）使得 $(u,v)$ 不满流，此时就不满足条件了。

最后因为要字典序最小，所以每次选择字典序最小的可行边即可。但是每次选择完这条边后，必须要把这条边带来的影响也删去，即退流。可以直接在残量网络上从 $u\to s$，$t\to v$ 跑两边最大流。也不用担心跑的最大流会不会比 $c(u,v)$ 大，即退流退多了，因为网络流有 **反对称性** 和 **流量平衡** 的特点，$s\to u$ 最大流了多少，$u\to s$ 最大也只能流多少。

具体如何找到这条满流边：因为满流边必定是拆点后的中间边，即 $(u_1,u_2,w)$，我们可以记录下每个点的 $u_1$，然后按照每个点的 $C_i$ 排序，从小到大找每个点，然后判断这个点对应的边是否在最小割上。

## Code

需要 **吸氧**。

```cpp
#include <cstdio> 
#include <iostream>
#include <cstring>
#include <algorithm>
#include <queue>
#include <vector>
#define LL long long
#define F(i, s, e) for(int i=s;i<=e;++i)
#define inf (LL)(1e18)
#define INF (int)(2e9)
#define N 2005
using namespace std;

struct edge { int v; LL f; };
struct node { LL w; int p, id; } nd[N];
vector <edge> E, E_;
vector <int> G[N];
int n, m, s, t, T, cur[N], dep[N], A[N], B[N], C[N], dp[N], len, stk[N], tp;

int add(int u, int v, LL w) {
	E.push_back((edge){v, w});
	E.push_back((edge){u, 0});
	G[u].push_back(E.size()-2);
	G[v].push_back(E.size()-1);
	return E.size()-2;
}
void init() {
	scanf("%d", &n);
	E.clear(); F(i, 0, N-1) G[i].clear();
	F(i, 1, n) stk[i] = dp[i] = 0;
	tp = len = 0;
	F(K, 1, 3) F(i, 1, n) switch(K) {
		case 1: scanf("%d", &A[i]); break;
		case 2: scanf("%d", &B[i]); break;
		case 3: scanf("%d", &C[i]); break;
	}
	s = n*2+1; t = s+1;
	F(i, 1, n) {
		dp[i] = 1;
		F(j, 1, i) if(A[j] < A[i])
			dp[i] = max(dp[i], dp[j]+1);
		len = max(len, dp[i]);
	}
	F(i, 1, n) {
		nd[i].w = C[i]; nd[i].p = add(i, n+i, B[i]); nd[i].id = i;
		if(dp[i] == 1) add(s, i, inf);
		if(dp[i] == len) add(i+n, t, inf);
		F(j, i+1, n) if(dp[j] == dp[i]+1 && A[j] > A[i]) add(i+n, j, inf);
	}
}
bool bfs(int S, int T) {
	F(i, 1, 2*(n+1)) dep[i] = 0; dep[S] = 1;
	queue <int> q; q.push(S);
	while(q.size()) {
		int u = q.front(); q.pop();
		for(int i=0;i<G[u].size();++i) {
			edge& e=E[G[u][i]];
			if(e.f && !dep[e.v]) {
				dep[e.v] = dep[u] + 1;
				q.push(e.v);
			}
		}
	}
	return dep[T];
}
LL dfs(int u, LL in, int T) {
	if(u == T) return in;
	LL flow = 0;
	for(int& i=cur[u];i<G[u].size();++i) {
		edge& e=E[G[u][i]];
		if(e.f && in && dep[e.v] == dep[u]+1) {
			LL d = dfs(e.v, min(in, e.f), T);
			flow += d; E[G[u][i]^1].f += d;
			in -= d; e.f -= d;
		}
	}
	return flow;
}
inline bool cmp(node x, node y) { return x.w < y.w; }
void back(int u, int v) {
	while(bfs(u, s)) {
		F(i, 1, t) cur[i] = 0;
		dfs(u, inf, s);
	}
	while(bfs(t, v)) {
		F(i, 1, t) cur[i] = 0;
		dfs(t, inf, v);
	}
}
void solve() {
	LL mxf = 0;
	while(bfs(s, t)) {
		F(i, 1, t) cur[i] = 0;
		mxf += dfs(s, inf, t);
	}
	sort(nd+1, nd+n+1, cmp);
	F(i, 1, n) {
		int p = nd[i].p; int u = nd[i].id;
		if(E[p].f == 0 && !bfs(u, u+n)) {
			back(u, u+n);
			E[p].f = E[p^1].f = 0;
			stk[++tp] = u;
		}
	}
	sort(stk+1, stk+tp+1);
	printf("%lld %d\n", mxf, tp);
	F(i, 1, tp) printf("%d ", stk[i]);
	puts("");
}
int main() {
	scanf("%d", &T);
	while(T--) {
		init();
		solve();
	}
	return 0;
}
```

[评测记录](https://www.luogu.com.cn/record/56631555)

---

## 作者：小木虫 (赞：1)

这题属于最小割类题目里比较典型且高质量的了  
因为只要减少1的长度，所以完美契合最小割的性质，只要破坏了所有路径就行 了。所有路径应该都是代表一种最长序列  
我们要算出每个点对于最长序列之间的关系（在哪些最长序列里）  
所以先来一次小dp，算出最长子序列和转移路径啥的，拆点后in和out之间连长度为ai的边。长度为1的从S向其连inf边，长度最高的向T连inf边，一个点拆点，入点出点之间连权值边，一个模型就建好了。现在的关键在于题目要求按一定顺序构建最小割集。  


------------

关于网络流退流的结论  
下文称入度为in，出度为out。  
在构建特定最小割集的时候，我们需要使已经割离的边消除掉它原本的影响，这个操作我们称作退流，那么如何退流呢？将边的入度和出度分别做一次反向DINIC就可以了（T到out、in到S），接下来解释这样为什么是对的；
首先，一旦割掉一条边，所面临的第一个改动就是任何一个任一节点在所有in的前置节点的集合内的边不能再被割掉，因为我们需要满足最小割性质，如果割掉这条可行边，那么那些边就没有割掉的必要了：  
![](https://cdn.luogu.com.cn/upload/image_hosting/2vbf8r3p.png)  
如上图，要么继续切断所有前面的边，要么切断剩下的后面的边，因为再切前面的边会导致阻断路径的重合（拿上图的路径举例子，所有节点在最上面的那个我们称作1号路径，很显然目前割掉的边已经不允许通过1号路径了，但这时再割掉第2列第一个点连接的边又会重复阻断，浪费点数）  
所以我们需要把前置节点全部退流  
out的后置节点同理  
这样顺序构建的割就是满足特殊条件的最小割集，因为每步会给后面增加限制保证最优  
前置知识：可行边  
一条满流且没有其它从其in到其out的增广路，一定是一个最小割集里的一个元素  
然后知道上述知识后直接将所有可行边按c排序，一个一个退流检查，答案就出来了    
代码：  
```cpp
#include<cstdio>  
#include<cstring>  
#include<algorithm>  
#include<queue>  
using namespace std;  
const int N=1410;  
const long long inf=1e9+10;  
long long n,x,y,z,maxflow,deep[N];//deep深度   
struct Edge{  
	int next,to;  
	long long dis;
}edge[N*N];
int num_edge=-1,head[N],cur[N];//cur用于复制head 
queue <int> q;
bool vis[N]; 
void add(int from,int to,long long dis){
	edge[++num_edge].next=head[from];
	edge[num_edge].to=to;
	edge[num_edge].dis=dis;
	head[from]=num_edge;
}
queue <int> qwq;
//bfs用来分层 
bool check(int s,int t){
	for(int i=0;i<=2*n+1;i++)vis[i]=false;
	while(!qwq.empty())qwq.pop();
	qwq.push(s);vis[s]=true;
	while(!qwq.empty()){
		int u=qwq.front();qwq.pop();
		if(u==t)return true;
		for(int i=head[u];i!=-1;i=edge[i].next){
			int v=edge[i].to;
			if(edge[i].dis>0&&!vis[v]){
				vis[v]=true;
				qwq.push(v);
			}
		}
	}
	return false;
}
bool bfs(int s,int t){
	memset(deep,-1,sizeof(deep));
	while (!q.empty()) q.pop();
	for(int i=0;i<=2*n+1;i++)cur[i]=head[i];
	deep[s]=0;
	q.push(s);
 	while (!q.empty()){
		int now=q.front(); q.pop();
		if(now==t){
			return true;
		}
 		for (int i=head[now]; i!=-1; i=edge[i].next){
			if (deep[edge[i].to]==-1 && edge[i].dis){
				deep[edge[i].to]=deep[now]+1;
				q.push(edge[i].to);
			}
		}
	}
	if (deep[t]!=-1) return true;
	else return false;
}
long long dfs(int now,int t,long long limit){
	if (!limit || now==t) return limit;
	long long flow=0,f;
	for (int &i=cur[now]; i!=-1; i=edge[i].next){
		if (deep[edge[i].to]==deep[now]+1 && (f=dfs(edge[i].to,t,min(limit,edge[i].dis))/*f赋值为从源点到汇点的最小值（沿某一增广路）*/))
		{
			flow+=f;
			limit-=f;
			edge[i].dis-=f;
			edge[i^1].dis+=f;
			if (!limit) break;
		}
	}
	return flow;
}

void Dinic(int s,int t){
	while (bfs(s,t)){
		maxflow+=dfs(s,t,inf);
	}
}
int s,t;int T;
struct node{
	long long rk,a,b,c;
}w[N];
int dp[N];int m;int cnt;int ans[N];
bool cmp(node a,node b){
	return a.c<b.c;
}
int in[N];int out[N];int id[N];
int main(){
	scanf("%d",&T);
	while(T--){
		num_edge=-1;
		maxflow=0;m=0;s=0;cnt=0;
		memset(head,-1,sizeof(head));
		scanf("%lld",&n);t=2*n+1;
		for(int i=1;i<=n;i++)
			dp[i]=1;
		for(int i=1;i<=n;i++){
			scanf("%lld",&w[i].a);
			w[i].rk=i;
			in[i]=i;out[i]=i+n;
		}
		for(int i=1;i<=n;i++){
			for(int j=1;j<i;j++){
				if(w[i].a<=w[j].a)continue;
				dp[i]=max(dp[i],dp[j]+1);
			}
			m=max(m,dp[i]);
		}
		for(int i=1;i<=n;i++){
			if(dp[i]==m){
				add(out[i],t,inf);
				add(t,out[i],0);
			}
			if(dp[i]==1){
				add(s,in[i],inf);
				add(in[i],s,0);
			}
			for(int j=1;j<i;j++){
				if(w[i].a<=w[j].a)continue;
				if(dp[i]!=dp[j]+1)continue;
				add(out[j],in[i],inf);
				add(in[i],out[j],0);
			}
		}
		for(int i=1;i<=n;i++){
			scanf("%lld",&w[i].b);
			add(in[i],out[i],w[i].b);
			id[i]=num_edge;
			add(out[i],in[i],0);
		}
		Dinic(s,t);
		for(int i=1;i<=n;i++){
			scanf("%lld",&w[i].c);
		}
		printf("%lld ",maxflow);
		sort(w+1,w+n+1,cmp);
		for(int i=1;i<=n;i++){
			int k=w[i].rk;
			if(!check(in[k],out[k])){
				ans[++cnt]=k;
				while(bfs(in[k],s))dfs(in[k],s,inf);
				while(bfs(t,out[k]))dfs(t,out[k],inf);
				edge[id[k]].dis=edge[id[k]^1].dis=0;
			}
		}
 		printf("%lld\n",cnt);
 		sort(ans+1,ans+cnt+1);
 		for(int i=1;i<=cnt;i++){
 			printf("%d ",ans[i]);
		}
		printf("\n");
	}
	return 0;
}
```


---

## 作者：zzw4257 (赞：1)

>对第$i$个位置有三个属性$(a_i,b_i,c_i)$
分别表示值/删除代价/附加价值
求删除若干项，使得最长上升子序列长度减少至少$1$，且删除代价和最小，将删去项的附加价值排序后字典序最小的一种

首先考虑每一种合法的删除方法对应一个断层,也就对应一个特殊的割

具体而言同[$\mathtt{BSOJ2547}$](https://oj.bashu.com.cn/code/problempage.php?problem_id=2547)建图方法:

先拆点$i,i'$表示入/出点，$(i,i',b_i)$表示这个点(割)删除的代价
$f(i)=1$,连边$(S,i,INF)$
对$1<f(j),f(i)<maxl,a_i>a_j$的连边$(j',i,INF)$
$f(i)=maxl$连边$(i',T,INF)$

那么一个割就对应一种删除方案使得不存在$maxl$层转移

考虑字典序最小就在最小割集里退流尝试即可

---

## 作者：OIer_ACMer (赞：0)

# Sol:


本题要考虑最长上升子序列，我们设 $f_i$ 为以 $i$ 下标结尾的最长上升子序列长度，可以考虑这样一种建边方式，当 $i < j$，且保证 $f_i = f_j + 1$ 时，将 $i$ 和 $j$ 连边，**因为这是问题的转移点，将这些边加进图中以方便我们进行最小割**，因为我们要保证代价最小。有两个特殊情况，如果 $f_i = 1$，则将起始点和 $i$ 连边，如果 $f_i$ 是全局最大值则将其与汇点连边。

之于我们要保证答案的字典序最小，所以，我们要对 $c$ 数组进行排序，并找出当前这个点在是否可以在最小割里面，每次跑一遍从 $u$ 到 $u + n$ 的最大流就行了。

最后提一嘴，这道题似乎用 ISAP 不行，必须用 Dinic，笔者也不知道是怎么回事。

# Code:

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
inline int read()
{
    register int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
            f = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        x = x * 10 + ch - 48;
        ch = getchar();
    }
    return x * f;
}
inline int write(int x)
{
    if (x < 0)
        putchar('-'), x = -x;
    if (x > 9)
        write(x / 10);
    putchar(x % 10 + 48);
}
struct node
{
    int to, next, val;
} edge[1000009];
int cnt = 1, head[10009];
inline void add(int u, int v, int w)
{
    edge[++cnt].to = v;
    edge[cnt].next = head[u];
    edge[cnt].val = w;
    head[u] = cnt;
    edge[++cnt].to = u;
    edge[cnt].next = head[v];
    edge[cnt].val = 0;
    head[v] = cnt;
}
int dep[10009];
int s, t;
int gap[10009];
// queue<int> q;
int n, m;
int q[1000009];
int he, ta;
int cur[1000009];
int mx;
int f[10009];
int st[10009];
int top;
inline bool check(int s, int t)
{
    for (register int i = 0; i <= (n << 2 | 1); i++)
    {
        dep[i] = 0;
    }
    q[he = ta = 1] = s;
    dep[s] = 1;
    while (he <= ta)
    {
        int x = q[he++];
        // cout << "x=" << x << endl;
        for (register int i = head[x]; i; i = edge[i].next)
        {
            int y = edge[i].to;
            if (dep[y] == 0 && edge[i].val)
            {
                dep[y] = dep[x] + 1;
                q[++ta] = y;
                if (y == t)
                {
                    return true;
                }
            }
        }
    }
    return false;
}
inline void bfs(int s, int t)
{
    for (register int i = 0; i <= (n << 2 | 1); i++)
    {
        dep[i] = -1;
        gap[i] = 0;
    }
    q[he = ta = 1] = t;
    dep[t] = 0;
    gap[0] = 1;
    while (he <= ta)
    {
        int u = q[he++];
        for (register int i = head[u]; i; i = edge[i].next)
        {
            int y = edge[i].to;
            if (dep[y] < 0)
            {
                dep[y] = dep[u] + 1;
                gap[dep[y]]++;
                q[++ta] = y;
            }
        }
    }
}
inline int dfss(int x, int t,int flow)
{
    if (x == t)
    {
        return flow;
    }
    int used = 0;
    for (register int i = cur[x]; i; i = edge[i].next)
    {
        cur[x] = i;
        int y = edge[i].to;
        int w = edge[i].val;
        // cout << "x=" << x << ' ' << "y=" << y << ' ' << "w=" << w << endl;
        if (dep[y] == dep[x] + 1 && w)
        {
            int minn = dfss(y, t, min(flow - used, edge[i].val));
            if (minn)
            {
                used += minn;
                edge[i].val -= minn;
                edge[i ^ 1].val += minn;
                if (used == flow)
                {
                    return flow;
                }
            }
        }
    }
    if (used == 0)
    {
        dep[x] = 0;
    }
    return used;
}
int dinic(int s, int t)
{
    int res = 0;
    while (check(s, t))
    {
        memcpy(cur, head, sizeof(head));
        res += dfss(s, t, 1e16);
        // cout << "res=" << res << endl;
    }
    return res;
}
// int cur[10009];
inline int dfs(int x, int t, int flow)
{
    if (x == t || !flow)
    {
        return flow;
    }
    int used = 0;
    for (register int i = cur[x]; i; i = edge[i].next)
    {
        cur[x] = i;
        int y = edge[i].to;
        int w = edge[i].val;
        // cout << "x=" << x << " y=" << y << " w=" << w << endl;
        if (dep[x] == dep[y] + 1 && w)
        {
            int minn = dfs(y, t, min(flow - used, w));
            if (minn)
            {
                used += minn;
                edge[i].val -= minn;
                edge[i ^ 1].val += minn;
                if (used == flow)
                {
                    return flow;
                }
            }
        }
    }
    if (--(gap[dep[x]]) == 0)
    {
        // cout << "gap[" << dep[x] << "]=0\n";
        dep[s] = n + 1;
    }
    dep[x]++;
    gap[dep[x]]++;
    return used;
}
inline int isap(int s, int t)
{
    bfs(s, t);
    // cout << "ggg\n";
    int max_flow = 0;
    while (dep[s] < n)
    {
        for (int i = 0; i <= (n << 2 | 1); i++)
        {
            cur[i] = head[i];
        }
        // cout << "dep[" << s << "]=" << dep[s] << endl;
        max_flow += dfs(s, t, 1e16);
    }
    return max_flow;
}
int a[10009], b[10009];
struct no1de
{
    int c, id;
    inline bool operator<(const no1de &b) const { return c < b.c; }
} c[10009];

inline void cl()
{
    memset(head, 0, sizeof(head)), mx = 0, cnt = 1;
}
signed main()
{
    int T = read();
    while (T--)
    {
        cl();
        n = read();
        for (register int i = 1; i <= n; i++)
        {
            a[i] = read();
        }
        for (register int i = 1; i <= n; i++)
        {
            b[i] = read();
        }
        for (register int i = 1; i <= n; i++)
        {
            c[i].c = read(), c[i].id = i;
        }
        for (register int i = 1; i <= n; i++)
        {
            f[i] = 1;
            for (int j = 1; j <= i - 1; j++)
            {
                if (a[j] < a[i])
                {
                    f[i] = max(f[i], f[j] + 1);
                }
            }
            mx = max(mx, f[i]);
        }
        s = 0, t = n << 1 | 1, top = 0;
        for (register int i = 1; i <= n; i++)
        {
            add(i, i + n, b[i]);
        }
        for (register int i = 1; i <= n; i++)
        {
            if (f[i] == 1)
            {
                add(s, i, 1e16);
            }
        }
        for (register int i = 1; i <= n; i++)
        {
            if (f[i] == mx)
            {
                add(i + n, t, 1e16);
            }
        }
        for (register int i = 1; i <= n; i++)
        {
            for (int j = 1; j <= i - 1; j++)
            {
                if (a[j] < a[i] && f[i] == f[j] + 1)
                {
                    add(j + n, i, 1e16);
                }
            }
        }
        int flow = dinic(s, t);
        // cout <<"flow=" << flow << endl;
        sort(c + 1, c + n + 1);
        for (register int i = 1; i <= n; i++)
        {
            int u = c[i].id;
            if (check(u, u + n))
            {
                continue;
            }
            // cout << "i=" << i << " u=" << u << endl;
            int ooo = dinic(t, u + n), oo = dinic(u, s);
            // cout << "ooo=" << ooo << " oo=" << oo << endl;
            st[++top] = u;
        }
        sort(st + 1, st + 1 + top);
        printf("%lld %lld\n", flow, top);
        for (register int i = 1; i <= top; i++)
        {
            printf("%lld ", st[i]);
        }
        cout << endl;
    }
    return 0;
}
```

---

## 作者：Petit_Souris (赞：0)

这题的网络流建模是很显然的：是一个割点集的形式，显然可以拆点，在 dp 产生贡献的点之间连边跑最小割。特别的地方在于需要输出方案，然而我发现很多题解都跑了 $\mathcal O(n)$ 次网络流来找答案，这并非最优解决方法。下面给出一个只跑一次网络流，额外用 $\mathcal O(n+m)$ 的时间求出字典序最小割的方案。

先跑一遍最大流，在残量网络上构造。我们保留所有残留容量的边并缩点，剩下的所有 SCC 之间的边一定是满流的（否则正反都可以走了）。

这时候一个割集 $S,T$ 满足条件当且仅当没有 $T$ 指向 $S$ 的满流边。

我们可以贪心，从小到大考虑每条边。如果这条边没有满流，或者两个点在同一个 SCC 内，那么一定不在最小割中，直接跳过。否则我们考虑能否使 $u\to v$ 是 $S\to T$ 的，直接进行一次染色就行了，即 $u$ 的前驱都是属于 $S$ 的，$v$ 的后继都是属于 $T$ 的。均摊显然每条边、每个点只会经过一次，因此复杂度为 $\mathcal O(n+m)$。

---

## 作者：Kun_9 (赞：0)

最小割好题。

我尝试从另一个角度解释一下建图的过程，考虑求 LIS 的过程实际上是在求一个偏序集上的最长链，抽象成图就是一张 DAG 上从零入度点到零出度点的一条最长链，那么我们只需要让所有的零入度点和零出度点之间都不可达就不可能有长度大于等于原来长度的链。

考虑实现这个过程，朴素的想法是拓扑排序，但这样会有大量无用的状态，怎么减少状态？DP！考虑到 DP 的本质就是更改遍历状态空间的顺序来减少冗余状态的，所以在求 LIS 时每一个转移就是我们要连的下一个点。

然后是建图，因为一个点只能删一次所以要拆点，正常按拓扑序连边（出->入），源点向所有零入度点连边，所有零出度点向汇点连边。

最后是输出方案，这是一个经典的技巧，必定在割集中的边一定是使原图不连通的边，所以我们按照权值排序，取边删边退流即可。

最后是代码（常数太大不吸氧会 T）。

```
#include <bits/stdc++.h>

#define AC true
// #define int long long
#define dub double
#define ull unsigned long long
#define mar(x) for(int i = head[x]; i; i = e[i].nxt)
#define car(a) memset(a, 0, sizeof(a))
constexpr int inf = 1e9 + 7;
constexpr int MAXN = 710;
constexpr dub eps = 1e-5;
constexpr int mod = 998244353;
#define db if(0)
// #define local
bool ___f1___;
using namespace std;

void cmi(int &x, int y){x > y && (x = y);}
void cmx(int &x, int y){x < y && (x = y);}
#define getcha() (S==_&&(_=(S=fsr)+fread(fsr,1,1<<10,stdin),S==_)?EOF:*S++)
char fsr[1<<10],*S=fsr,*_=fsr;
inline int read( ){
    int x = 0 ; short w = 0 ; char ch = 0;
    while( !isdigit(ch) ) { w|=ch=='-';ch=getcha();}
    while( isdigit(ch) ) {x=(x<<3)+(x<<1)+(ch^48);ch=getcha();}
    return w ? -x : x;
}

namespace mxf{
    const int N = 5e5 + 10;
    struct edge{
        int u, v, f, nxt;
    } e[N << 1];
    int head[N], cur[N], cnt = 1;
    int dis[N];
    int s, t, flow, lim;
    queue<int> q;
    
    void add(int u, int v, int f){
        e[++cnt] = {u, v, f, head[u]};
        head[u] = cnt;
        e[++cnt] = {v, u, 0, head[v]};
        head[v] = cnt;
    }
    
    bool bfs( ){
        memcpy(cur, head, sizeof(int)*(lim + 1));
        memset(dis, 0, sizeof(int)*(lim + 1));
        q.push(s); dis[s] = 1;
        while(!q.empty( )){
            int x = q.front( ); q.pop( );
            mar(x){
                int y = e[i].v;
                if(dis[y] or !e[i].f) continue;
                dis[y] = dis[x] + 1;
                q.push(y);
            }
        }
        return dis[t];
    }
    
    int dfs(int x, int low){
        if(x == t){flow += low; return low;}
        int rlow = 0, used = 0;
        for(int &i = cur[x]; i; i = e[i].nxt){
            int y = e[i].v;
            if(!e[i].f or dis[y] != dis[x] + 1) continue;
            if(rlow = dfs(y, min(e[i].f, low - used))){
                e[i].f -= rlow;
                e[i^1].f += rlow;
                used += rlow;
                if(low == used) break;
            }
        } 
        return used;
    }
    
    int dinic( ){
        flow = 0;
        while(bfs( )) dfs(s, inf);
        return flow;
    }
    void pushback( ){
        for(int i = 2; i <= cnt; i += 2)
            if(e[i^1].f) e[i].f += e[i^1].f, e[i^1].f = 0;
    }
};
using namespace mxf;

struct vex{
    int x, y, z;
} val[MAXN];
struct node{int id, w;} a[MAXN];
int n;
int dp[MAXN], ed[MAXN];
void work( ){
    cnt = 1;
    n = read( );
    memset(head, 0, sizeof(int)*(n * 2 + 3));
    s = n * 2 + 1; t = n * 2 + 2;
    lim = n * 2 + 2;
    for(int i = 1; i <= n; i++) val[i].x = read( );
    for(int i = 1; i <= n; i++){
        val[i].y = read( );
        add(i, i + n, val[i].y);
        ed[i] = cnt - 1;
    }
    for(int i = 1; i <= n; i++) val[i].z = read( );
    int mxx = 0;
    for(int i = 1; i <= n; i++){
        int mx = 0;
        for(int j = 1; j < i; j++)
            if(val[j].x < val[i].x) cmx(mx, dp[j]);
        for(int j = 1; j < i; j++)
            if(val[j].x < val[i].x and dp[j] == mx)
                add(j + n, i, inf);
        dp[i] = mx + 1;
        cmx(mxx, dp[i]);
    }
    for(int i = 1; i <= n; i++){
        if(dp[i] == 1) add(s, i, inf);
        if(dp[i] == mxx) add(i + n, t, inf);
    }
    printf("%d ",dinic( ));
    for(int i = 1; i <= n; i++) a[i].id = i, a[i].w = val[i].z;
    sort(a + 1, a + n + 1, [](node x, node y){return x.w < y.w;});
    int ss = s, tt = t;
    vector<int> ans;
    for(int i = 1; i <= n; i++){
        s = a[i].id; t = a[i].id + n;
        if(!bfs( )){
            ans.push_back(a[i].id);
            e[ed[a[i].id]].f = e[ed[a[i].id] ^ 1].f = 0;
            pushback( );
            s = ss; t = tt;
            dinic( );
        }
    }
    printf("%d\n",(int)ans.size( ));
    sort(ans.begin( ), ans.end( ));
    for(int i: ans) printf("%d ",i);
    putchar('\n');
}

bool ___f2___;
signed main( ){
#ifdef local
    freopen("tes.in", "r", stdin);
    freopen("tes.out", "w", stdout);
#endif
    int T = read( ); while(T--) work( );
#ifdef local
    putchar('\n');
    printf("MLE:%lld\n",((&___f2___)-(&___f1___))/1024/1024);
    printf("TLE:%lld\n",(int)clock( ));
#endif
    return (0-0);
}
```

---


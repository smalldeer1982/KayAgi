# [ZJOI2011] 最小割

## 题目描述

小白在图论课上学到了一个新的概念——最小割，下课后小白在笔记本上写下了如下这段话： 

对于一个图，某个对图中结点的划分将图中所有结点分成两个部分，如果结点 $s$ 和 $t$ 不在同一个部分中，则称这个划分是关于 $s,t$ 的割。对于带权图来说，将所有顶点处在不同部分的边的权值相加所得到的值定义为这个割的容量，而 $s,t$ 的最小割指的是在关于 $s,t$ 的割中容量最小的割。

现给定一张无向图，小白有若干个形如“图中有多少个无序点对的最小割的容量不超过 $x$ ”的疑问，小蓝虽然很想回答这些问题，但小蓝最近忙着挖木块，于是作为小蓝的好友，你又有任务了。

## 说明/提示

对于 $100 \%$ 的数据，$1 \leq T \leq 10$，$1 \leq n \leq 150$，$0 \leq m \leq 3000$，$0 \leq x \leq 2^{31}-1$，$0 \leq q \leq 30$。

## 样例 #1

### 输入

```
1
5 0
1
0```

### 输出

```
10```

# 题解

## 作者：Orion545 (赞：8)

# 广告

[蒟蒻的blog](http://www.cnblogs.com/dedicatus545/p/8781237.html)

# 正文

首先我们明确一点：这道题不是让你把$n^2$个最小割跑一遍【废话】

但是最小割过程是必要的，因为最小割并没有别的效率更高的算法(Stoer-Wagner之类的？)

那我们就要尽量找办法减少做最大流（求最小割）的次数

# 最小割树

就像最小生成树一样，最小割也有自己的生成树

我们新建立一个有n个点，没有边的无向图

我们在原无向图中任选两个点S,T，求出S-T最小割，那么可以在S-T中间加一条权值等于最小割值得无向边

然后，分别对S属于的点集合和T属于的点集合递归做上面的过程，直到当前处理的集合只剩下一个点了

现在，对于这棵新树（显然是一棵树，可以自己退一下为什么），有一个结论：

树上任意两个点在原图中的对应点之间的最小割值等于这两个点的树上路径中边权的最小值

证明？我也不知道啊！

但是这个算法的正确性是可以保证的（你也可以感性理解一下qwq）

# 做法

有了这个“大杀器”以后，这道题也就迎刃而解了~

这道题目的点数很小，因此我们只要把所有搞出来的最小割值依此更新点对

处理询问的时候就把所有的点对扫一遍输出就好了

# Code

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cassert>
#define inf 1e9
using namespace std;
inline int read(){
	int re=0,flag=1;
	scanf("%d",&re);return re;
	char ch=getchar();
	while(ch>'9'||ch<'0'){
		if(ch=='-') flag=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();
	return re*flag;
}
int n,m,cnt,first[210],dep[210],cur[210],ans[160][160];
struct edge{
	int to,next,w,W;
}a[10010];
inline void add(int u,int v,int w){
	a[++cnt]=(edge){v,first[u],w,w};first[u]=cnt;
	a[++cnt]=(edge){u,first[v],w,w};first[v]=cnt;
}
bool bfs(int s,int t){
	int q[210],head=0,tail=1,i,u,v;
	for(i=1;i<=n;i++) dep[i]=-1,cur[i]=first[i];
	q[0]=s;dep[s]=0;
	while(head<tail){
		u=q[head++];
		for(i=first[u];~i;i=a[i].next){
			v=a[i].to;
			if(~dep[v]||!a[i].w) continue;
			dep[v]=dep[u]+1;q[tail++]=v;
		}
	}
	return ~dep[t];
}
int dfs(int u,int t,int limit){
	if(u==t||!limit) return limit;
	int i,v,f,flow=0;
	for(i=first[u];~i;i=a[i].next){
		v=a[i].to;
		if(dep[v]==dep[u]+1&&(f=dfs(v,t,min(limit,a[i].w)))){
			a[i].w-=f;a[i^1].w+=f;
			flow+=f;limit-=f;
			if(!limit) return flow;
		}
	}
	return flow;
}
int dinic(int s,int t){
	int re=0;
	while(bfs(s,t)) re+=dfs(s,t,inf);
	return re;
}
void clear(){
	for(int i=0;i<=cnt;i++) a[i].w=a[i].W;
}
void init(){
	memset(first,-1,sizeof(first));memset(a,0,sizeof(a));cnt=-1;
	memset(ans,127,sizeof(ans));
}
int node[210],vis[210];
void cut(int u){
	int i,v;vis[u]=1;
	for(i=first[u];~i;i=a[i].next){
		v=a[i].to;
		if(a[i].w&&!vis[v]) cut(v);
	}
}
void solve(int l,int r){
	if(l==r) return;
	clear();int i,j,tmp,t[2][210]={0};
	memset(vis,0,sizeof(vis));
	tmp=dinic(node[l],node[r]);
	cut(node[l]);
	for(i=1;i<=n;i++)
		if(vis[i])
			for(j=1;j<=n;j++)
				if(!vis[j])
					ans[i][j]=ans[j][i]=min(ans[i][j],tmp);
	for(i=l;i<=r;i++) t[vis[node[i]]][++t[vis[node[i]]][0]]=node[i];
	for(i=l,j=1;j<=t[0][0];j++,i++) node[i]=t[0][j];
	for(i=l+t[0][0],j=1;j<=t[1][0];j++,i++) node[i]=t[1][j];
	solve(l,l+t[0][0]-1);solve(l+t[0][0],r);
}
int main(){
	int i,j,k,T=read(),t1,t2,t3,q;
	while(T--){
		init();
		n=read();m=read();
		for(i=1;i<=m;i++) t1=read(),t2=read(),t3=read(),add(t1,t2,t3);
		for(i=1;i<=n;i++) node[i]=i;
		solve(1,n);
		q=read();
		for(k=1;k<=q;k++){
			t1=read();int tmp=0;
			for(i=1;i<=n;i++){
				for(j=i+1;j<=n;j++) if(ans[i][j]<=t1) tmp++;
			}
			printf("%d\n",tmp);
		}
		puts("");
	}
}
```

---

## 作者：mydcwfy (赞：5)

## 1. 前置知识

[最小割树（Gomory-Hu Tree）](https://www.luogu.com.cn/problem/P4897)

如果你不知道，可以看 [网络流](https://www.luogu.com.cn/blog/mydcwfy-342891/network-flow) 或 [最小割树](https://www.luogu.com.cn/blog/mydcwfy-342891/solution-p4897) （ ~~都是我的博客~~ ）

当然，你也可以看一下下面的解释。

## 2. 最小割树（Gomory-Hu Tree）

（ ~~这也是来自我的博客~~ ）

很明显，不可能每次求最小割（复杂度为 $O(n^4m)$）。

我们将一个网络流的图转化为一棵树，其中原图 $u$ 到 $v$ 的最小割即为转化到树上。

树的一个性质是：删除一条边，树变得不连通。

那么，我们可以任意选 2 个点 $s$ 与 $t$，跑最小割（即最大流），然后再连一条从 $s$ 到 $t$ 的边。

又 Dinic 算法最后一次 bfs 相当于求一个最小割，原图就被分为了两部分。

最后分治就可以了，复杂度为 $O(n^3m)$（Dinic 跑不满的，所以不会超时）。

按这样建出的树，就是一棵无根树。

我们可以发现一个有趣的性质：$u$ 到 $v$ 的最小割就是树上从 $u$ 到 $v$ 的所有路径长的最小值。

可以感性地理解一下（ ~~主要是太菜不会证~~ ）：最小割即为最小的路径长，把 $u$ 到 $v$ 的任意一条路径切断，都是割。

## 3. 回归本题

还是比较简单。

直接预处理，将所有的点对之间的最小割求出来。

有一下两种做法。

### 1） 直接扫描

由于出题人比较良心，这个题的 $Q$ 比较少，可以通过 $O(Qn^2)$，还是可以过的。

### 2） 使用有序排列

我们也可以先将所有的最小割排序好，每次询问，直接查询在有序数列中的位置，减下标即可。

~~我太懒了~~，使用了第一种。

## 4. Code

注意要建双向边，否则就不是两边都可以被割掉了。

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#define ll long long
using namespace std;

const int N=1005,M=1e5+10;
const ll INF=1e15;

int h[N],e[M],ne[M],idx;
ll w[M],ans[N][N];
int cur[N],d[N],q[N],S,T,n,m;
int node[N],tmp1[N],tmp2[N];

void add(int a,int b,int c)
{
	e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
	e[idx]=a,ne[idx]=h[b],w[idx]=0,h[b]=idx++;
}

bool bfs()
{
	memset(d,0,sizeof d);
	int hh=1,tt=1;
	q[1]=S;cur[S]=h[S];d[S]=1;
	while (hh<=tt)
	{
		int x=q[hh++];
		for (int i=h[x];~i;i=ne[i])
			if (!d[e[i]]&&w[i])
			{
				d[e[i]]=d[x]+1;
				cur[e[i]]=h[e[i]];
				if (e[i]==T) return true;
				q[++tt]=e[i];
			}
	}
	return false;
}

int findflow(int x,ll limit)
{
	if (x==T) return limit;
	ll flow=0;
	for (int i=cur[x];~i&&flow<limit;i=ne[i])
	{
		cur[x]=i;
		if (d[e[i]]==d[x]+1&&w[i])
		{
			int t=findflow(e[i],min(w[i],limit-flow));
			if (!t) d[e[i]]=-1;
			w[i]-=t,w[i^1]+=t,flow+=t;
		}
	}
	return flow;
}

void init()
{
	for (int i=0;i<idx;i+=2)
		w[i]=(w[i]+w[i^1]),w[i^1]=0;
	return;
}

ll dinic()
{
	init();
	ll r=0,flow;
	while (bfs()) while (flow=findflow(S,INF)) r+=flow;
	return r;
}

void work(int l,int r)
{
	if (l==r) return ;
	S=node[l],T=node[l+1];
	ll t=dinic();
    int s=node[l],tt=node[l+1];
	ans[T][S]=ans[S][T]=t;
//	printf("%d %d:%d\n",S,T,ans[S][T]);
	int cnt1=0,cnt2=0;
	for (int i=l;i<=r;++i)
		if (d[node[i]]) tmp1[++cnt1]=node[i];
		else tmp2[++cnt2]=node[i];
	for (int i=1;i<=cnt1;++i) node[i+l-1]=tmp1[i];
	for (int i=1;i<=cnt2;++i) node[cnt1+l+i-1]=tmp2[i];
	work(l,l+cnt1-1);
	work(l+cnt1,r);
	for (int i=1;i<=cnt1;++i)
		for (int j=1;j<=cnt2;++j)
		{
			int ii=node[i+l-1],jj=node[j+cnt1+l-1];
			ans[jj][ii]=ans[ii][jj]=min(min(ans[ii][s],ans[s][tt]),ans[tt][jj]);
		}
	return;
}

int main()
{
    int Case=0;cin>>Case;
    while (Case--)
    {
        memset(h,-1,sizeof h);
        idx=0;
        cin>>n>>m;
        for (int i=1;i<=n;++i)
            for (int j=1;j<=n;++j) ans[i][j]=INF;
        int x,y;
        ll z;
        while (m--)
        {
            scanf("%d %d %lld",&x,&y,&z);
            add(x,y,z);add(y,x,z);
        }
        for (int i=0;i<=n;++i) node[i]=i;
        work(1,n);
        int que;cin>>que;
        while (que--)
        {
            scanf("%lld",&z);
            int tot=0;
            for (int i=1;i<=n;++i)
                for (int j=1;j<=n;++j)
                    if (ans[i][j]<=z) tot++;
            printf("%d\n",tot/2);
        }
        puts("");
    }
	return 0;
}
```



---

## 作者：watermonster (赞：2)

前置知识:[最小割树](https://www.luogu.com.cn/problem/P4897)

如果你会最小割树，那么这题差不多就是一道板子题了。哪怕$n$很小，我们也不能枚举所有点对，然后跑$n^2$次最小割。我们要知道每对点之间的最小割，显然可以用最小割树，这样就可以只跑$n$次最小割。

对于每一组测试数据，我们可以先建出最小割树，然后枚举点对，在最小割树上查询答案，然后将答案存入数组。预处理出所有点对的最小割之后排序，对于每次询问直接二分答案即可（反正跑最小割树就有$n^3m$的复杂度，所以其实暴力$qn^2$枚举也行）。

### **CODE**
```cpp
#include <cmath>
#include <queue>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
#define re register
#define il inline
#define isdigit(ch) (ch>=48&&ch<=57)
const int N=220;
const int M=3030;
const int inf=0x3f3f3f3f;
il void read(int &x)
{
	x=0;char ch=getchar();
	while(!isdigit(ch)) ch=getchar();
	while(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
}
void write(int x){if(x/10)write(x/10);putchar(x%10+48);}
il void swap(int &a,int &b){re int tmp=a;a=b;b=tmp;}
il int min(int a,int b){return a<b?a:b;}
int T,n,m,q,k;
namespace dinic
{
	int cnt=1,h[N],cur[N];
	struct edge{int v,res,nxt;}e[M<<2];
	il void add(int u,int v,int w){e[++cnt]=(edge){v,w,h[u]};h[u]=cnt;}
	il void init()
	{
		for(re int i=2;i<=cnt;i+=2)
			e[i].res+=e[i^1].res,e[i^1].res=0;
            	//退流
	}
	int dep[N];
	il bool bfs(int s,int t)
	{
		for(re int i=1;i<=n;++i) cur[i]=h[i],dep[i]=0;
		queue<int>q;q.push(s);dep[s]=1;
		while(!q.empty())
		{
			re int u=q.front();q.pop();
			for(re int i=h[u],v;i;i=e[i].nxt)
				if(!dep[v=e[i].v]&&e[i].res)
					dep[v]=dep[u]+1,q.push(v);
		}
		return dep[t]>0;
	}
	int dfs(int u,int flow,int t)
	{
		if(!flow||u==t)  return flow;
		int tmp=0,v,f;
		for(re int i=cur[u];i;i=e[i].nxt)
		{
			cur[u]=i;
			if(dep[v=e[i].v]>dep[u]&&(f=dfs(v,min(flow-tmp,e[i].res),t)))
			{
				e[i].res-=f;e[i^1].res+=f;
				tmp+=f;
				if(!(flow-tmp)) break;
			}
		}
		return tmp;
	}
	il int ans(int s,int t)
	{
		int res=0;init();
		while(bfs(s,t)) res+=dfs(s,inf,t);
		return res;
	}
	il void clr()
	{
		cnt=1;
		memset(h,0,sizeof(h));
	}
}//dinic的板子
namespace GHT
{
	int cnt=0,h[N];
	struct edge{int v,w,nxt;}e[N<<1];
	il void add(int u,int v,int w){e[++cnt]=(edge){v,w,h[u]};h[u]=cnt;}
	int node[N],tmp1[N],tmp2[N];
	void build(int l,int r)
	{
		if(l==r) return;
		re int u=node[l],v=node[l+1];
		re int w=dinic::ans(u,v);
		add(u,v,w);
		add(v,u,w);
		re int cnt1=0,cnt2=0;
		for(re int i=l;i<=r;++i)
		{
			if(dinic::dep[node[i]]>0) tmp1[++cnt1]=node[i];
            else tmp2[++cnt2]=node[i];
		}
		for(re int i=l;i<=l+cnt1-1;++i) node[i]=tmp1[i-l+1];
        for(re int i=l+cnt1;i<=r;++i) node[i]=tmp2[i-cnt1-l+1];
		build(l,l+cnt1-1);build(l+cnt1,r);
	}//建树，板子不会的建议先去写模板题
	int lg;
	int fa[10][N],dep[N];
	int st[10][N];
	void dfs(int x,int f)
	{
		dep[x]=dep[f]+1;
		fa[0][x]=f;
		for(re int i=1;i<=lg;++i)
		{
			fa[i][x]=fa[i-1][fa[i-1][x]];
			st[i][x]=min(st[i-1][fa[i-1][x]],st[i-1][x]);
		}
		for(re int i=h[x],v;i;i=e[i].nxt)
			if(e[i].v^f)
			{
				st[0][e[i].v]=e[i].w;
				dfs(e[i].v,x);
			}
	}
	il int query(int u,int v)
	{
		re int res=inf;
		if(dep[u]<dep[v]) swap(u,v);
		for(re int i=lg;i>=0;--i)
			if(dep[fa[i][u]]>=dep[v])
			{
				res=min(res,st[i][u]);
				u=fa[i][u];
			}
		if(u==v) return res;
		for(re int i=lg;i>=0;--i)
			if(fa[i][u]^fa[i][v])
			{
				res=min(res,st[i][u]);
				u=fa[i][u];
				res=min(res,st[i][v]);
				v=fa[i][v];
			}
		res=min(res,st[0][u]);
		res=min(res,st[0][v]);
		return res;
        	//树上倍增查询最小割
	}
	il void clr()
	{
		cnt=0;
		memset(h,0,sizeof(h));
		memset(fa,0,sizeof(fa));
		memset(dep,0,sizeof(dep));
		memset(st,0x3f,sizeof(st));
		for(re int i=1;i<=n;++i) node[i]=i;
        	//初始化最小割树
	}
}
int st[N*N],top;
int main()
{
	read(T);
	while(T--)
	{
		read(n),read(m);
		GHT::lg=log2(n)+1;
		GHT::clr();dinic::clr();
		for(re int i=1,u,v,w;i<=m;++i)
		{
			read(u),read(v),read(w);
			dinic::add(u,v,w);
			dinic::add(v,u,0);
			dinic::add(v,u,w);
			dinic::add(u,v,0);//注意无向图
		}
		GHT::build(1,n);
		GHT::dfs(1,0);//构建最小割树
		top=0;
		for(re int i=1;i<n;++i)
			for(re int j=i+1;j<=n;++j)
				st[++top]=GHT::query(i,j);//将最小割存入数组中
		sort(st+1,st+top+1);
		read(q);
		while(q--)
		{
			read(k);
			re int l=0,r=top,ans=0,mid;
			while(l<=r)
			{
				mid=(l+r)>>1;
				if(st[mid]<=k) ans=mid,l=mid+1;
				else r=mid-1;
			}
        		//二分答案
			write(ans);puts("");
		}
		puts("");
	}
	return 0;
}
```

---

## 作者：Charlie_ljk (赞：1)

- [推一下自己的最小割树学习笔记](https://www.cnblogs.com/Charlieljk/p/18729786)。

# 最小割树

最小割树就是通过分治建出一棵树，树上两点的最小割就等于原图上的最小割，树上两点路径唯一，其最小割就等于路径上边权的最小值。

建树时，任意选择两点最为 $s,t$ 跑最小割，求得 $ans_{s,t}$，并将其分为两个集合 $S,T$，对于 $x\in S,y\in T$，有 $ans_{x,y}=ans_{y,x}=\min(ans_{s,t},ans_{x,s},ans_{t,y})$。

之后对于这两部分再分别跑最小割，重复上述步骤，就能在理论（网络流的复杂度跑不满） $O(n^3m)$ 的复杂度内建出一棵最小割树。

# 答案处理

求出任意两点间的最小割，排序后二分即可，所以要求一个 $Q=n^2$ 的查询。

## 建树

建树就是对于每一层分治将 $s,t$ 连上边权为 $ans_{s,t}$ 的边即可，$ans_{s,t}$ 为本次最小割跑出的答案。

因为原图两点的最小割就等于树上两点路径上边权的最小值，根据这点就可以有很多种处理方式了，具体有树上倍、lca 等多种求法，但是本题 $Q=n^2$，就不如以每个点为根遍历一遍树，复杂度 $O(n^2)$。

## 不建树

根据上面的式子，对于 $x\in S,y\in T$，有 $ans_{x,y}=ans_{y,x}=\min(ans_{s,t},ans_{x,s},ans_{t,y})$。

所以可以在分治的同时处理出答案，不需要把树建出来。

# 一些细节

- 每一次跑最小割前要将所有边恢复初始状态。
- 本题为无向图，要所以可以不用对于每一个边再建一条流量为 $0$ 的反边了，建双向边即可。
- 注意分治时每层的 $s,t$ 不同，根据需要保存本层的 $s,t$。

# 代码如下

使用的是不把树建出来的方法。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define mkp make_pair
using namespace std;
const int N=155,M=6010,inf=0x3f3f3f3f;
#ifdef __linux__
#define gc getchar_unlocked
#define pc putchar_unlocked
#else
#define gc _getchar_nolock
#define pc _putchar_nolock
#endif
inline bool blank(const char x) {return !(x^32)||!(x^10)||!(x^13)||!(x^9);}
template<typename Tp> inline void read(Tp &x) {x=0; register bool z=true; register char a=gc(); for(;!isdigit(a);a=gc()) if(a=='-') z=false; for(;isdigit(a);a=gc()) x=(x<<1)+(x<<3)+(a^48); x=(z?x:~x+1);}
inline void read(double &x) {x=0.0; register bool z=true; register double y=0.1; register char a=gc(); for(;!isdigit(a);a=gc()) if(a=='-') z=false; for(;isdigit(a);a=gc()) x=x*10+(a^48); if(a!='.') return x=z?x:-x,void(); for(a=gc();isdigit(a);a=gc(),y/=10) x+=y*(a^48); x=(z?x:-x);}
inline void read(char &x) {for(x=gc();blank(x)&&(x^-1);x=gc());}
inline void read(char *x) {register char a=gc(); for(;blank(a)&&(a^-1);a=gc()); for(;!blank(a)&&(a^-1);a=gc()) *x++=a; *x=0;}
inline void read(string &x) {x=""; register char a=gc(); for(;blank(a)&&(a^-1);a=gc()); for(;!blank(a)&&(a^-1);a=gc()) x+=a;}
template<typename T,typename ...Tp> inline void read(T &x,Tp &...y) {read(x),read(y...);}
template<typename Tp> inline void write(Tp x) {if(!x) return pc(48),void(); if(x<0) pc('-'),x=~x+1; register int len=0; register char tmp[64]; for(;x;x/=10) tmp[++len]=x%10+48; while(len) pc(tmp[len--]);}
inline void write(const double x) {register int a=6; register double b=x,c=b; if(b<0) pc('-'),b=-b,c=-c; register double y=5*powl(10,-a-1); b+=y,c+=y; register int len=0; register char tmp[64]; if(b<1) pc(48); else for(;b>=1;b/=10) tmp[++len]=floor(b)-floor(b/10)*10+48; while(len) pc(tmp[len--]); pc('.'); for(c*=10;a;a--,c*=10) pc(floor(c)-floor(c/10)*10+48);}
inline void write(const pair<int,double>x) {register int a=x.first; if(a<7) {register double b=x.second,c=b; if(b<0) pc('-'),b=-b,c=-c; register double y=5*powl(10,-a-1); b+=y,c+=y; register int len=0; register char tmp[64]; if(b<1) pc(48); else for(;b>=1;b/=10) tmp[++len]=floor(b)-floor(b/10)*10+48; while(len) pc(tmp[len--]); a&&(pc('.')); for(c*=10;a;a--,c*=10) pc(floor(c)-floor(c/10)*10+48);} else cout<<fixed<<setprecision(a)<<x.second;}
inline void write(const char x) {pc(x);}
inline void write(const bool x) {pc(x?49:48);}
inline void write(char *x) {fputs(x,stdout);}
inline void write(const char *x) {fputs(x,stdout);}
inline void write(const string &x) {fputs(x.c_str(),stdout);}
template<typename T,typename ...Tp> inline void write(T x,Tp ...y) {write(x),write(y...);}
int T,n,m,s,t,cs[N],ct[N],dep[N],node[N],f[N][N],g[N*N>>1];
int tot=1,now[N],head[N],nxt[M],to[M],w[M];
inline void add(int x,int y,int z)
{
	nxt[++tot]=head[x],to[head[x]=tot]=y,w[tot]=z;
	nxt[++tot]=head[y],to[head[y]=tot]=x,w[tot]=z;
}
inline bool bfs()
{
	queue<int>q; memset(dep,0,sizeof(dep));
	for(memcpy(now,head,sizeof(now)),q.push(s),dep[s]=1;!q.empty();)
	{
		int x=q.front(); q.pop();
		for(int i=head[x],y;y=to[i];i=nxt[i]) if(w[i]&&!dep[y])
		{dep[y]=dep[x]+1,q.push(y); if(y==t) return true;}
	} return false;
}
inline int dfs(int x,int sum)
{
	if(x==t||!sum) return sum; int sur,res=0;
	for(int &i=now[x],y;y=to[i];i=nxt[i]) if(w[i]&&dep[y]==dep[x]+1)
	{
		if(!(sur=dfs(y,min(sum,w[i])))) {dep[y]=-1; continue;}
		w[i]-=sur,w[i^1]+=sur,res+=sur; if(!(sum-=sur)) break;
	} return res;
}
inline void build(int l,int r)
{
	if(l>=r) return ; s=node[l],t=node[r]; int res=0,ns=0,nt=0;
	for(int i=2;i<tot;i+=2) w[i]=w[i^1]=w[i]+w[i^1]>>1;
	while(bfs()) res+=dfs(s,inf); f[s][t]=f[t][s]=res;
	for(int i=l,x;i<=r;i++) dep[x=node[i]]?cs[++ns]=x:ct[++nt]=x;
	for(int i=1;i<=ns;i++) node[l+i-1]=cs[i];
	for(int i=1;i<=nt;i++) node[l+ns+i-1]=ct[i];
	int os=s,ot=t; build(l,l+ns-1),build(l+ns,r); 
	for(int i=1,j,x,y;i<=ns;i++) for(x=node[l+i-1],j=1;j<=nt;j++)
		y=node[l+ns+j-1],f[x][y]=f[y][x]=min({f[x][os],f[ot][y],res});
}
signed main()
{
	for(read(T);T--;puts(""),tot=1,memset(head,0,sizeof(head)))
	{
		read(n,m),memset(f,0x3f,sizeof(f));
		for(int x,y,z;m;m--) read(x,y,z),add(x,y,z);
		for(int i=1;i<=n;i++) node[i]=i; build(1,n);
		for(int i=1,j;i<=n;i++) for(j=i+1;j<=n;j++) g[++m]=f[i][j];
		sort(g+1,g+1+m),g[++m]=inf,read(n);
		for(int x;n--;) read(x),write(upper_bound(g+1,g+1+m,x)-g-1,'\n');
	}
}
```

---

## 作者：yanwh1 (赞：1)

做完这道题后，我发誓从今往后一定认真看题面。
# 题面转换
给你一张图，要求回答 $q$ 个询问：图中有多少个点对的最小割小于等于 $x$。

# 思路解析
如果你学过最小割树的话，这道题应该十分简单。

看到数据范围，可以发现，建完最小割树后可以直接查整张图的所有点对的最小割，判断一下就做完了。

温馨提示：在两组测试数据之间需要输出一行空行。~~我就是因为这个浪费了几个小时~~。
# 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rint register int
#define int long long
inline int read(){
    int f=0,t=0;
    char c=getchar();
    while(!isdigit(c)) t|=(c=='-'),c=getchar();
    while(isdigit(c)) f=(f<<3)+(f<<1)+c-48,c=getchar();
    return t?-f:f;
}inline void write(int x) {
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar('0'+x%10);
}const int N=155,M=3005,inf=LONG_LONG_MAX;
int head[M],to[M<<1],nxt[M<<1],w[M<<1],cnt=1,n,m,s,t;
inline void add(int u,int v,int vl){nxt[++cnt]=head[u],to[cnt]=v,w[cnt]=vl,head[u]=cnt;}
int dis[N],now[N],rs[N],rs1[N],rs2[N];
queue<pair<int,int>>qe;
struct edge{int v,w;};
vector<edge>qwe[N];
inline int bfs(){
	for(rint i=1;i<=n;i++)dis[i]=inf;
	queue<int>q;q.push(s),dis[s]=0,now[s]=head[s];
	while(!q.empty()){
		int u=q.front();q.pop();
		for(rint i=head[u];i;i=nxt[i]){
			int v=to[i],vl=w[i];
			if(vl&&dis[v]==inf){
				q.push(v);
				dis[v]=dis[u]+1;
				now[v]=head[v];
				if(v==t)return 1;
			}
		}
	}return 0;
}inline int dfs(int u=s,int mn=inf){
	if(u==t||!mn)return mn;
	int k,res=0;
	for(rint i=now[u];i;i=nxt[i]){
		now[u]=i;int v=to[i],vl=w[i];
		if(vl&&dis[v]==dis[u]+1){
			k=dfs(v,min(vl,mn));
			if(!k)dis[v]=inf;
			w[i]-=k,w[i^1]+=k;
			qe.push(make_pair(i,k));
			res+=k,mn-=k;
			if(!mn)break;
		}
	}return res;
}inline int dinic(int u,int v){
	s=u,t=v;int ans=0;
	while(bfs())ans+=dfs();
	while(!qe.empty()){
		pair<int,int> res=qe.front();qe.pop();
		w[res.first]+=res.second;
		w[res.first^1]-=res.second;
	}return ans;
}inline void build(int l,int r){
	int m1=0,m2=0;
	if(l==r)return;
	int ans=dinic(rs[l],rs[l+1]);
	qwe[rs[l]].push_back({rs[l+1],ans});
	qwe[rs[l+1]].push_back({rs[l],ans});
	for(rint i=l;i<=r;i++){
		if(dis[rs[i]]!=inf)rs1[++m1]=rs[i];
		else rs2[++m2]=rs[i];
	}for(rint i=1;i<=m1;i++)rs[i+l-1]=rs1[i];
	for(rint i=1;i<=m2;i++)rs[i+l+m1-1]=rs2[i];
	build(l,l+m1-1),build(l+m1,r);
}int ans; 
inline void query(int u,int f,int mx,int mn,int qr){
	for(rint i=0;i<qwe[u].size();i++){
		int v=qwe[u][i].v,w=qwe[u][i].w;
		if(f==v)continue;
		if(v<mx&&min(mn,w)<=qr)ans++;
		query(v,u,mx,min(mn,w),qr);
	}
}
signed main(){
	int T=read();
	while(T--){
		n=read(),m=read();
		for(rint i=1;i<=n;i++)rs[i]=i;
		for(rint i=1;i<=m;i++){
			int u=read(),v=read(),e=read();
			add(u,v,e),add(v,u,e);
		}build(1,n);
		int q=read();
		while(q--){
			ans=0;int qr=read();
			for(rint i=2;i<=n;i++)
				query(i,0,i,inf,qr);
			write(ans),puts("");
		}for(rint i=1;i<=n;i++)head[i]=0;
		cnt=1;for(rint i=1;i<=n;i++)qwe[i].clear();
		puts("");
	}
	return 0;
}
```

---

## 作者：Rubidium_Chloride (赞：1)

多次查询最小割，不会快速计算，只会 $n^2$ 计算最小割，但是单组数据复杂度是 $\mathcal{O}(n^4m+qn^2)$ 的怎么办？

合理想到最小割树。

大概有个定理：任选两个点 $s,t$ 跑最小割为 $c$，然后在一张新图上连一条边 $(s,t)$，权值为 $c$，并且对分别在 $s$ 和 $t$ 连通块里的点分治计算并建图，则得到的是一棵树，而且两点的最小割等于树上路径中的最小值。

这棵树称为这个网络的最小割树。

利用树上倍增和类似跑 `lca` 的方法可以在单次 $\mathcal{O}(\log n)$ 的时间内跑出两点间的最小割。

预处理的复杂度是 $\mathcal{O}(n^3m)$ 的，因为一共要跑 $n$ 次最小割。

但是显然跑不满，所以可过。

预处理出来然后每次 $\mathcal{O}(n^2)$ 查询即可。

总复杂度 $\mathcal{O}(T(n^3m+n^2\log n+qn^2))$。

```
#include<bits/stdc++.h>
#define N 159
#define M 12009
#define L 10
#define INF 0x3f3f3f3f3f3f3f3f
using namespace std;
typedef long long ll;
inline ll read() {
    ll x=0,f=1;int c=getchar();
    while(!isdigit(c)) {if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)) {x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    return x*f;
}
ll t,n,m,q,f[N][N];
namespace Flow{
    ll s,t,hd[N],tot=1,dst[N],nw[N],ans;
    struct edge{ll t,w,nxt;} es[M];
    void add(ll u,ll v,ll w){
        es[++tot]=(edge){v,w,hd[u]},hd[u]=tot;
        es[++tot]=(edge){u,0,hd[v]},hd[v]=tot;
    }
    void init(ll ss,ll tt){for(int i=2;i<=tot;i+=2) es[i].w=es[i].w+es[i^1].w,es[i^1].w=0;s=ss,t=tt;}
    bool bfs(){
        memset(dst,0x3f,sizeof(dst));
        queue<ll> q;
        q.push(s);
        dst[s]=0;
        nw[s]=hd[s];
        while(!q.empty()){
            ll x=q.front();q.pop();
            for(int i=hd[x];i;i=es[i].nxt){
                if(es[i].w>0&&dst[es[i].t]==INF){
                    nw[es[i].t]=hd[es[i].t]; 
                    dst[es[i].t]=dst[x]+1;
                    q.push(es[i].t);
                    if(es[i].t==t) return 1;
                }
            }
        }
        return 0;
    }
    ll dfs(ll x,ll tot){
        if(x==t) return tot;
        ll sum=0,k;
        for(int i=nw[x],v;i&&tot;i=es[i].nxt){
            nw[x]=i;
            v=es[i].t;
            if(es[i].w>0&&dst[v]==dst[x]+1){
                k=dfs(v,min(tot,es[i].w));
                if(k==0) dst[v]=INF;
                es[i].w-=k,es[i^1].w+=k;
                tot-=k,sum+=k; 
            }
        }
        return sum;
    }
    ll dinic(){ll ans=0;while(bfs()) ans+=dfs(s,INF);return ans;}
}
namespace tree{
    ll hd[N],tot,id[N],t1[N],t2[N],d[N],fa[N][L],mn[N][L];
    struct edge{ll t,w,nxt;} es[M];
    void add(ll u,ll v,ll w){
        es[++tot]=(edge){v,w,hd[u]},hd[u]=tot;
        es[++tot]=(edge){u,w,hd[v]},hd[v]=tot;
    }
    void init(){for(int i=1;i<=n;i++) id[i]=i;memset(mn,0x3f,sizeof(mn));}
    void build(ll l,ll r){
        if(l==r) return;
        Flow::init(id[l],id[l+1]);ll c=Flow::dinic();
        add(id[l],id[l+1],c);
        ll tt1=0,tt2=0;
        for(int i=l;i<=r;i++){
            if(Flow::dst[id[i]]<0x3f3f3f3f) t1[++tt1]=id[i];
            else t2[++tt2]=id[i];
        }
        for(int i=l;i<l+tt1;i++) id[i]=t1[i-l+1];
        for(int i=l+tt1;i<=r;i++) id[i]=t2[i-l-tt1+1];
        build(l,l+tt1-1),build(l+tt1,r);
    }
    void dfs(ll x,ll f){
        d[x]=d[f]+1,fa[x][0]=f;
        for(int i=1;i<L;i++) fa[x][i]=fa[fa[x][i-1]][i-1],mn[x][i]=min(mn[x][i-1],mn[fa[x][i-1]][i-1]);
        for(int i=hd[x],v;i;i=es[i].nxt){v=es[i].t;if(v!=f) mn[v][0]=es[i].w,dfs(v,x);}
    }
    void prep(){init(),build(1,n),dfs(1,0);}
    ll query(ll u,ll v){
        ll ans=INF;
        if(d[u]<d[v]) swap(u,v);
        for(int i=L-1;i>=0;i--) if(d[fa[u][i]]>=d[v]) ans=min(ans,mn[u][i]),u=fa[u][i];
        if(u==v) return ans;
        for(int i=L-1;i>=0;i--) if(fa[u][i]!=fa[v][i]) ans=min(ans,min(mn[u][i],mn[v][i])),u=fa[u][i],v=fa[v][i];
        ans=min(ans,min(mn[u][0],mn[v][0]));return ans;
    }
}
int main(){
    //freopen("qaq.in","r",stdin);
    //freopen("qaq.out","w",stdout);
    t=read();
    while(t--){
        n=read(),m=read(),memset(Flow::hd,0,sizeof(Flow::hd)),Flow::tot=1;
        memset(tree::hd,0,sizeof(tree::hd)),memset(tree::fa,0,sizeof(tree::fa)),tree::tot=0;
        for(int i=1,u,v,w;i<=m;i++) u=read(),v=read(),w=read(),Flow::add(u,v,w),Flow::add(v,u,w);
        tree::prep(),q=read();
        for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) f[i][j]=tree::query(i,j);
        for(int i=1;i<=q;i++){
            ll ans=0,w=read();
            for(int i=1;i<=n;i++) for(int j=i+1;j<=n;j++) ans+=(f[i][j]<=w);
            printf("%lld\n",ans);
        }
        printf("\n");
    }
    return 0;
}
```

---

## 作者：EnofTaiPeople (赞：1)

首先明确最小割树的定义：对于任意树上的边 $(u,v)$，删除图上的点 $u,v$，树上的边 $(u,v)$，之后，图会分成两部分，一部分在树上与 $u$ 连通，另一部分在树上与 $v$ 连通，树上边 $(u,v)$ 的边权为图上 $u,v$ 之间的最小割。

同时，图上任意两点的最小割是它们的树上路径边权最小值。

于是，只要将树建出来，就可以实现 $O(1)$ 查询最小割啦！

问题来了：怎么建树？

事实上，最小割树的性质告诉我们，其实只要不断加边就可以了，具体做法是：

1. 定义 $solve(l,r)$ 为将区间 $[l,r]$的节点建树；
2. 求出 $MinCut(a_l,a_r)$；
3. 判断 $[l,r]$ 中那些点与 $a_l$ 连通，那些点与 $a_r$ 连通，并将其划分为 $[l,lc],[rc,r]$，可以用最后一次广搜节点是否被搜到为标准判断；
4. 递归：$solve(l,lc),solve(rc,r)$；
5. $n$ 遍深搜求出树上任意两点路径上的最小边权。

然后查询就可以啦！

##  code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=205,M=6005;
char buf[M+5],*p1,*p2,c;
#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,M,stdin),p1==p2)?EOF:*p1++)
inline int read(){
	int an=0,f=1;while(!isdigit(c=gc))if(c=='-')f=-f;
	do an=an*10+(48^c);while(isdigit(c=gc));return an*f;
}
int a[N],b[N],d[N],n,m,s,t,Q,q[N],l,r;
vector<int>lk[N];
int w[M],ed[M],cnt,now[N];
struct Eg{int u,v,w;}g[N];
int ans[N][N],*add;
inline bool bfs(){
	int i,x,y;
	for(i=1;i<=n;++i)now[i]=d[i]=0;
	q[l=r=d[s]=1]=s;
	while(l<=r){
		x=q[l++];
		for(int i:lk[x])
			if(w[i]&&!d[y=ed[i]]){
				d[q[++r]=y]=d[x]+1;
				if(y==t)return 1;
			}
	}return 0;
}
int Dinic(int x,int flow){
	if(x==t)return flow;int i,y,k,rest=flow;
	for(int &g=now[x],sz=lk[x].size();g<sz;++g)
		if(w[i=lk[x][g]]&&d[y=ed[i]]==d[x]+1)
			if(k=Dinic(y,min(w[i],rest))){
				w[i]-=k,w[i^1]+=k;
				if(!(rest-=k))return flow;
			}
	d[x]=0;
	return flow-rest;
}
inline void solve(int l,int r){
	if(l>=r)return;int i,lc=l-1,rc=r+1;
	s=a[l],t=a[r],g[++cnt]={a[l],a[r]};
	while(bfs())g[cnt].w+=Dinic(s,INT_MAX);
	for(i=l;i<=r;++i)
		if(d[a[i]])b[++lc]=a[i];
		else b[--rc]=a[i];
	for(i=l;i<=r;++i)a[i]=b[i];
	for(i=1;i<=m;++i){
		w[i+i]+=(w[i+i+1]-w[i+i])>>1;
		w[i+i+1]=w[i+i];
	}solve(l,lc),solve(rc,r);
}
void dfs(int x,int ad,int pr){
	add[x]=ad;int y;
	for(int i:lk[x])
		if((y=ed[i])!=pr)
			dfs(y,min(ad,w[i]),x);
}
int main(){
	int ttt=read();
	while(ttt--){
		n=read(),m=read(),cnt=0;
		int i,x,y;
		for(i=1;i<=m;++i){
			x=read(),y=read();
			w[i+i]=w[i+i+1]=read();
			ed[i+i]=x,lk[y].push_back(i+i);
			ed[i+i+1]=y,lk[x].push_back(i+i+1);
		}
		for(i=1;i<=n;++i)a[i]=i;
		solve(1,n);
		for(i=1;i<=n;++i)lk[i].clear();
		for(i=1;i<=cnt;++i){
			w[i+i]=w[i+i+1]=g[i].w;
			ed[i+i]=g[i].v,lk[g[i].u].push_back(i+i);
			ed[i+i+1]=g[i].u,lk[g[i].v].push_back(i+i+1);
		}
		for(x=1;x<=n;++x)
			add=ans[x],dfs(x,INT_MAX,-1);
		Q=read();
		for(i=1;i<=n;++i)lk[i].clear();
		while(Q--){
			x=read(),cnt=0;
			for(i=1;i<n;++i)
				for(y=i+1;y<=n;++y)
					cnt+=ans[i][y]<=x;
			printf("%d\n",cnt);
		}
		if(ttt)putchar('\n');
	}
	return 0;
}
```

---

## 作者：warzone (赞：1)

首先图是静态的，因此询问是离线的。

静态图的最小割询问，很容易想到[最小割树](https://www.luogu.com.cn/problem/P4897)。

最小割树满足如下性质：  
两点间最小割为最小割树上两点间路径边权的最小值。

我们要求的是：  
有多少个点对 $(s,t)$，其最小割不超过 $x$  

那么建好最小割树后，显然有两种做法建表：
- 树链剖分 + 暴力枚举点对 建表，复杂度 $\Theta(n^2\log n)$  
	优点：简单粗暴，便于想到。
- 使用 kruskal 重构树（[P4768 [NOI2018] 归程](https://www.luogu.com.cn/problem/P4768)）  
	具体地，将最小割树上边按边权扔进大根堆，然后依次取出，  
    在并查集上合并每条边两端点所在集合。  
    设合并两点 $(x,y)$ 所在集合大小分别为 $size_x,size_y$，  
    那么肯定有 $size_x\times size_y$ 个点对最小割为该边边权。  
    前缀和计算贡献即可，复杂度 $\Theta(n\log n)\sim\Theta(n\alpha(n))$  
    优点：都是数据结构，直接蒯代码就是了。
    
表建好后，询问时在表上二分即可。

第一种做法已经有人给出，这里给出第二种做法的代码。
```cpp
/*
This code is made by warzone
2021.2.16 10:46
*/
#include<stdio.h>
#include<string.h>
#include<algorithm>
typedef long long ll;
typedef unsigned long long ull; 
typedef unsigned int word;
typedef unsigned short hword;
typedef unsigned char byte;
word n,m,begin,end;
template<typename type>
struct HEAP{//手写堆
    type list[160];
    word size;
    inline HEAP(){size=0;}
#define swap(a,b)(                              \
    list[0]=list[a],                            \
    list[a]=list[b],                            \
    list[b]=list[0])
    inline void push(type in){
        list[++size]=in;
        for(register word i=size;i>1&&list[i]<list[i>>1];i>>=1)
            swap(i,i>>1);
    }
    inline void pop(){
        list[1]=list[size--];
        for(register word i=1;i<<1<=size;swap(i,i>>1))
            if(list[i<<1]<list[i])
                if(i<<1<size&&list[i<<1|1]<list[i<<1]) i=i<<1|1;
                else i<<=1;
            else if(i<<1<size&&list[i<<1|1]<list[i]) i=i<<1|1;
            else return;
    }
    inline type& top(){return list[1];}
};
struct edge{//最小割树上的边
	hword x,y;
	word value;
	inline bool operator <(const edge &p){
		return value>p.value;}
}ed;
HEAP<edge> heap;
struct READ{//快读快写
	char c;
	inline READ(){c=getchar();}
	template<typename type>
	inline READ& operator >>(register type& num){
		while('0'>c||c>'9') c=getchar();
		for(num=0;'0'<=c&&c<='9';c=getchar())
			num=num*10+(c-'0');
		return *this;
	}
}cin;
struct queue{//队列
	hword list[160],head,tail;
	inline void push(register hword in){
		list[tail]=in;
		if(++tail==160) tail=0;
	}
	inline void pop(){
		if(++head==160) head=0;}
	inline hword top(){return list[head];}
	inline bool empty(){return head==tail;}
}q;
struct flow_net{//网络流原图
	hword head[160],to[6010],next[6010];
	hword floor[160],gap[160];
	word value[6010];
	inline flow_net(){//原图输入
		cin>>n>>m;
		for(register hword i=1;i<=m;++i){
			cin>>to[i<<1]>>to[i<<1|1]>>value[i<<1];
			value[i<<1|1]=value[i<<1];
			next[i<<1|1]=head[to[i<<1]];
			next[i<<1]=head[to[i<<1|1]];
			head[to[i<<1]]=i<<1|1;
			head[to[i<<1|1]]=i<<1;
		}
	}
	inline bool bfs(){//广搜分层
		memset(floor,0x7f,sizeof(floor));
		floor[begin]=0,q.push(begin);
		for(register word id;!q.empty();){
			id=q.top(),q.pop(),gap[id]=head[id];//gap优化
			for(register word i=head[id];i;i=next[i])
				if(value[i]&&floor[to[i]]>floor[id]+1)
					floor[to[i]]=floor[id]+1,q.push(to[i]);
		}
		return floor[end]!=0x7f7f;
	}
	inline word dfs(hword id,word min){//深搜增广
		if(id==end) return min;
		word ans=0,out;
		#define i gap[id]
		for(;i&&min;i=next[i])
			if(value[i]&&floor[to[i]]==floor[id]+1){
				out=dfs(to[i],min<value[i]? min:value[i]);
				value[i]-=out,value[i^1]+=out;
				min-=out,ans+=out;
			}
		#undef i
		return ans;
	}
};
struct gomory_hu_tree{
	flow_net flow;
	struct union_{//kruskal 重构树所用并查集
		hword fa[160],size[160];
		inline union_(){
			for(register hword i=1;i<=n;++i)
				fa[i]=i,size[i]=1;
		}
		inline hword find(hword id){
			if(fa[id]==id) return id;
			return fa[id]=find(fa[id]);
		}//路径压缩
		inline word merge(hword x,hword y){
			x=find(x),y=find(y);
			register word ans=(word)(size[x])*size[y];//计算贡献
			if(size[x]>size[y]) fa[y]=x,size[x]+=size[y];
			else fa[x]=y,size[y]+=size[x];//按秩合并
			return ans;
		}
	}_union;
	word ans[160],value[160];
	inline void build(word *num,hword size){//最小割树建树
		if(size==1) return;
		ed.x=begin=num[0];
		ed.y=end=num[size-1];
		ed.value=0;
		while(flow.bfs()) ed.value+=flow.dfs(begin,0x7fffffff);
		heap.push(ed);
		//找最小割然后在树上连边（边扔进大根堆中）
		for(register word i=1;i<=m;++i)
			flow.value[i<<1]=flow.value[i<<1|1]=
			(flow.value[i<<1]+flow.value[i<<1|1])>>1;//恢复原图
		register hword l=0,r=size-1;
		while(l<r){
			while(l<r&&flow.floor[num[l]]!=0x7f7f) ++l;
			while(l<r&&flow.floor[num[r]]==0x7f7f) --r;
			register hword swap=num[l];
			num[l]=num[r],num[r]=swap;
		}//分割点集
		l=flow.floor[num[l]]==0x7f7f? l:r;
		build(num,l),build(num+l,size-l);
	}
	inline void* operator new(size_t size,void *p){
		return p;}
	inline gomory_hu_tree():flow(),_union(){
		for(register hword i=1;i<=n;++i) ans[i]=i;
		build(ans+1,n);
		while(heap.size){//kruskal 重构树建表
			ed=heap.top(),value[heap.size]=ed.value;
			ans[heap.size]=_union.merge(ed.x,ed.y);
			heap.pop();
		}
		for(register word i=1;i<=n;++i)
			ans[i]+=ans[i-1];//前缀和计算总贡献
		value[n]=0x80000000;
	}
	inline word operator()(word x){
		x=std::upper_bound(value,value+n+1,x)-value;//询问时二分
		return ans[x-1];
	}
}*tree;
byte pool[1<<16];
int main(){
	byte t;
	for(cin>>t;t;--t){
		tree=new(pool) gomory_hu_tree;
		register word q,x;
		for(cin>>q;q;--q)
			cin>>x,printf("%u\n",(*tree)(x));
		putchar('\n');
		memset(pool,0,sizeof(pool));
	}
	return 0;
}

```

---

## 作者：gyyyyx (赞：0)

笑死我了，没看到两组数据之间要有空行，挂了无数次。

其实就是一个最小割树的板子题。

最小割树就是一棵满足图上任意两点的最小割都等价于树上对应两点的最小割。

而树上的最小割是平凡的。

这里讲一下建树过程，至于最小割树的证明大家可以看[这篇博客](https://www.luogu.com.cn/article/5w729thn)。

我们首先对于图上随机两点 $u,v$ 求最小割，设其容量为 $w$，则在树上连一条 $u,v$ 之间边权为 $w$ 的无向边。

接着我们分别对最小割把图所分成了两部分分别分治下去，直到只剩一个点为止。

注意每次求最小割要在原图上求。

这样我们会求 $n-1$ 次最小割，也就对应了树上的 $n-1$ 条边。

求完最小割之后问题就好办了，由于图上两点的最小割容量等于树上两点间最短路径上的边权最小值，我们可以对每个询问都 $O(n^2)$ 暴力找点对，询问复杂度是 $O(qn^2)$。

代码：

```cpp
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f
#define LL long long
#define N 500
#define M 10000
using namespace std;
mt19937 engine(time(0));
int _,n,m,__,id[N],S,T;
vector <pair <int,LL> > tree[N];
struct Edge{
	int nxt,to,flw,tmp;
	Edge(int a=0,int b=0,int c=0)
	:nxt(a),to(b),flw(c),tmp(c){}
} e[M];
int head[N],cnt;
inline void AddEdge(int x,int y,int f){
	e[++cnt]=Edge(head[x],y,f);head[x]=cnt;
}
int dis[N],cur[N];
queue <int> q;
inline bool BFS(){
	memset(dis,0,sizeof(dis));
	q.push(S);dis[S]=1;
	while(!q.empty()){
		int u(q.front());q.pop();cur[u]=head[u];
		for(int i(head[u]);i;i=e[i].nxt){
			int v(e[i].to);
			if(e[i].flw&&!dis[v]){
				dis[v]=dis[u]+1;
				q.push(v);
			}
		}
	}
	return dis[T];
}
int DFS(int u,int limit){
	if(u==T||!limit) return limit;
	int f(0);
	for(int i(cur[u]);i&&limit;i=e[i].nxt){
		cur[u]=i;int v(e[i].to);
			if(e[i].flw&&dis[v]==dis[u]+1){
			int t(DFS(v,min(limit,e[i].flw)));
			e[i].flw-=t;e[i^1].flw+=t;limit-=t;f+=t;
		}
	}
	if(!f) dis[u]=0;
	return f;
}
inline LL Dinic(){
	LL flw(0),tmp;
	while(BFS())
		while(tmp=DFS(S,INF))
			flw+=tmp;
	return flw;
}
void Build(int l,int r){
	if(r-l<=1) return;
	int mid(l+r>>1);
	S=id[engine()%(mid-l)+l];
	T=id[engine()%(r-mid)+mid];//随便选两点
	for(int i(2);i<=cnt;++i) e[i].flw=e[i].tmp;//恢复成原图
	LL w(Dinic());//求最小割
	tree[S].push_back(make_pair(T,w));
	tree[T].push_back(make_pair(S,w));//连边
	for(int i(mid=l);i<r;++i)
		if(dis[id[i]]) swap(id[mid++],id[i]);//分成两个集合[l,mid)[mid,r)
	Build(l,mid);Build(mid,r);
}
int Get(int u,int f,int x,bool flg){
	int ret(flg);
	for(auto t:tree[u]){
		int v(t.first),w(t.second);
		if(v^f) ret+=Get(v,u,x,flg|(w<=x));
	}
	return ret;
}
inline int Query(int x){
	int ret(0);
	for(int i(1);i<=n;++i) ret+=Get(i,0,x,0);
	return ret>>1;
}
int main(){
	scanf("%d",&_);
	while(_--){
		scanf("%d%d",&n,&m);
		fill(head+1,head+1+n,0);cnt=1;
		for(int i(1);i<=m;++i){
			int u,v,w;scanf("%d%d%d",&u,&v,&w);
			AddEdge(u,v,w);AddEdge(v,u,w);
		}
		for(int i(1);i<=n;++i) id[i]=i,tree[i].clear();
		Build(1,n+1);//建[1,n)上的树
		scanf("%d",&__);
		while(__--){
			int x;scanf("%d",&x);
			printf("%d\n",Query(x));
		}
		puts("");
	}
	return 0;
}
```

---

## 作者：Eznibuil (赞：0)

如何吊打 Gusfield？快使用 Gomory-Hu！

具体细节参见[我的另一篇博客](/blog/_post/537433)。

数据范围很小，求出最小割树后暴力扫一遍即可。

具体到这个题而言，可以考虑从每个点开始搜索整棵树，预处理出每个点对答案。查询的时候直接遍历 $O(n^2)$ 个点对即可。单组数据时间复杂度 $O(n\tau+qn^2)$（$\tau$ 为求最小割时间复杂度），但是常数挺小的。

事实上，Gomory-Hu 轻松拿到最优解。
```cpp
#include<assert.h>
#include<stdio.h>
#include<stdlib.h>
#include<vector>
const int N=2001,M=100001;
bool vis[N],C[N][N];
int f,s,t,len,las[N],nex[M],en[M],vol[M],he,ta,q[N],dis[N],cnt[N],maxfl,sh[N],fa[N],ans[N][N];
#define addedg(e,d,g) (nex[len]=las[e],las[e]=len,en[len]=d,vol[len++]=g)
#define addfl(e,d,g) (addedg(e,d,g),addedg(d,e,g))
std::vector<int>rs[N];
std::vector<std::pair<std::pair<int,int>,int>>T;
bool bfs()
{
	int x;
	for(int i=he=ta=0;i<f;i++)
		vis[sh[i]]=0,cnt[sh[i]]=dis[sh[i]]=0;
	vis[q[ta++]=sh[t]]=1,dis[sh[t]]=0;
	while(he<ta)
	{
		cnt[dis[x=q[he++]]]++;
		for(int _:rs[x])
			for(int i=las[_];~i;i=nex[i])
				if(!vis[sh[en[i]]])
					vis[sh[en[i]]]=1,dis[sh[en[i]]]=dis[x]+1,q[ta++]=sh[en[i]];
	}
	assert(sh[s]!=sh[t]);
	return vis[sh[s]];
}
int dfs(int x,int fl)
{
	if(x==sh[t])
		return maxfl+=fl,fl;
	int d=0;
	for(int _:rs[x])
		for(int i=las[_],j;~i;i=nex[i])
			if(vol[i]&&dis[sh[en[i]]]==dis[x]-1)
			{
				d+=j=dfs(sh[en[i]],vol[i]<fl-d?vol[i]:fl-d),vol[i]-=j,vol[i^1]+=j;
				if(d==fl)
					return d;
			}
	cnt[dis[x]]--;
	if(!cnt[dis[x]])
		dis[sh[s]]=f;
	return cnt[++dis[x]]++,d;
}
void tag(int x)
{
	vis[x]=1;
	for(int _:rs[x])
		for(int i=las[_];~i;i=nex[i])
			if(vol[i^1]&&!vis[sh[en[i]]])
				tag(sh[en[i]]);
	return;
}
int mf(int S,int T)
{
	s=S,t=T;
	for(int i=maxfl=0;i<len;i+=2)
		vol[i]=vol[i^1]=vol[i]+vol[i^1]>>1;
	if(bfs())
		while(dis[sh[s]]<f)
			dfs(sh[s],1000000000);
	for(int i=0;i<f;i++)
		vis[sh[i]]=0;
	return tag(sh[t]),maxfl;
}
void GomoryHu(const std::vector<int>&R)
{
	if(R.size()==1)
	{
		for(int i=0;i<f;i++)
			C[R[0]][sh[i]]=1;
		return;
	}
	std::vector<int>R1,R2;
	bool v[N];
	int r1=R[0],r2=R[1],d=mf(r1,r2),tmp[N],rp,rpp;
	for(int i=0;i<f;i++)
		tmp[i]=-1,v[i]=vis[i];
	for(int i:R)
		if(vis[sh[i]])
			R2.emplace_back(i);
		else
			R1.emplace_back(i);
	for(int i=0,k;i<f;i++)
		if(v[k=sh[i]]&&k!=r2)
			for(int j=rs[k].size()-1;~j;j--)
				tmp[rs[k][j]]=sh[rs[k][j]],sh[rs[k][j]]=r2;
	for(int i=0;i<f;i++)
		rs[i].clear();
	for(int i=0;i<f;i++)
		rs[sh[i]].emplace_back(i);
	GomoryHu(R1);
	for(int i=0;i<f;i++)
		if(~tmp[i])
			sh[i]=tmp[i],tmp[i]=-1;
	for(int i=0;i<f;i++)
		rs[i].clear();
	for(int i=0;i<f;i++)
		rs[sh[i]].emplace_back(i);
	for(int i=0,k;i<f;i++)
		if(!v[k=sh[i]]&&k!=r1)
			for(int j=rs[k].size()-1;~j;j--)
				tmp[rs[k][j]]=sh[rs[k][j]],sh[rs[k][j]]=r1;
	for(int i=0;i<f;i++)
		rs[i].clear();
	for(int i=0;i<f;i++)
		rs[sh[i]].emplace_back(i);
	GomoryHu(R2);
	for(int i=0;i<f;i++)
		if(~tmp[i])
			sh[i]=tmp[i];
	for(int i=0;i<f;i++)
		rs[i].clear();
	for(int i=0;i<f;i++)
		rs[sh[i]].emplace_back(i);
	for(int i:R1)
		if(C[i][r2])
		{
			rp=i,C[i][r2]=0;
			break;
		}
	for(int i:R2)
		if(C[i][r1])
		{
			rpp=i,C[i][r1]=0;
			break;
		}
	return T.emplace_back(std::make_pair(rp,rpp),d);
}
void getans(int x,int y)
{
	for(int i=las[y];~i;i=nex[i])
		if(en[i]!=fa[y])
			fa[en[i]]=y,ans[x][en[i]]=(ans[x][y]<vol[i]?ans[x][y]:vol[i]),getans(x,en[i]);
	return;
}
int main()
{
	int t,n,m,q,u,v,w;
	std::vector<int>R;
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d%d",&n,&m),f=n,R.clear(),T.clear();
		for(int i=0;i<f;i++)
			las[i]=-1,R.emplace_back(i),sh[i]=i,rs[i].clear(),rs[i].emplace_back(i);
		for(int i=0;i<f;i++)
			for(int j=0;j<f;j++)
				C[i][j]=0;
		while(m--)
			scanf("%d%d%d",&u,&v,&w),addfl(u-1,v-1,w);
		GomoryHu(R);
		for(int i=len=0;i<f;i++)
			las[i]=-1;
		for(auto j:T)
			addfl(j.first.first,j.first.second,j.second);
		for(int i=0;i<f;i++)
			fa[i]=-1,ans[i][i]=1e9,getans(i,i);
		scanf("%d",&q);
		while(q--)
		{
			scanf("%d",&w),m=0;
			for(int i=1;i<n;i++)
				for(int j=0;j<i;j++)
					if(ans[i][j]<=w)
						m++;
			printf("%d\n",m);
		}
		if(t)
			puts("");
	}
	return 0;
}
```

---


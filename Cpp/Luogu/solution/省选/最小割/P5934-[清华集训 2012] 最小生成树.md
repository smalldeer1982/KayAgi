# [清华集训 2012] 最小生成树

## 题目描述

给定一个边带正权的连通无向图 $G=(V,E)$，其中 $N=|V|,M=|E|$，$N$ 个点从 $1$ 到 $N$ 依次编号，给定三个正整数 $u,v$ 和 $L(u\ne v)$，假设现在加入一条边权为 $L$ 的边 $(u,v)$，那么需要删掉最少多少条边，才能够使得这条边既可能出现在最小生成树上，也可能出现在最大生成树上？

## 说明/提示

#### 样例解释
我们只需把边 $(1,2)$ 删除即可，删除并加入新边之后，图中的生成树唯一。

#### 数据规模与约定
对于 $20\%$ 的数据满足 $N\leqslant10,M\leqslant20,L\leqslant20$；

对于 $50\%$ 的数据满足 $N\leqslant300,M\leqslant3000,L\leqslant200$；

对于 $100\%$ 的数据满足 $N\leqslant20000,M\leqslant200000,L\leqslant20000$。

## 样例 #1

### 输入

```
3 2
3 2 1
1 2 3
1 2 2
```

### 输出

```
1```

# 题解

## 作者：xiezheyuan (赞：13)

## 简要题意

给你一个 $N$ 个点，$M$ 条边的 **无向连通** 带权图。给定一条边 $(u,v,L)$，请问需要在原图中删除多少条边，使得将 $(u,v,L)$ 插入图后，它既可能在最小生成树上，又可能在最大生成树上。

对于 $100\%$ 的数据，满足 $N\leq 20000,M\leq 200000,L\leq 20000$。

## 思路

update on 2024.1.7 修订一个小错误，感谢 [@yyz1005](https://www.luogu.com.cn/user/220824)。

如果一条插入边 $(u,v,L)$ 后该边可能在最小生成树上，那么如果将边权小于 $L$ 的边组成一个新图，则新图不连通。

证明：

- 如果新图连通，则对新图求最小生成树，则最小生成树一定是原图的最小生成树（显然），然后 $(u,v,L)$ 就一定不在任意一个最小生成树中。与前句矛盾，所以必须不连通。
- 如果新图不连通，则不存在最小生成树，使得任意一条树边边权小于 $L$。又因为原图连通，所以插入 $(u,v,L)$ 后，原图依旧连通。如果原图的最小生成树边集为 $S$，则满足 $\exists (x,y,z) \in S,z \geq L$，但可以知道环上一定有比 $L$ 大的边。 $(u,v,L)$ 插入 $S$，则最小生成树变为基环树。将环上最大边权的边删除，则该边一定不是 $(u,v,L)$（除非环上边权都相等），所以 $(u,v,L)$ 可能在插入后的最小生成树上。

（可能有一些不严谨，敬请指正）

同理可得：如果一条插入边 $(u,v,L)$ 后该边可能在最大生成树上，那么如果将边权大于 $L$ 的边组成一个新图，则新图不连通。

所以如果我们建出了这两个新图，则相当于就是在求删除多少条边后全图（其实就是 $u\to v$）不连通。最小割解决。

最后答案就是两图最小割答案和，由于两个图的割集的交集一定为空集（因为它们没有相同的点），所以可以加法原理。

最后说一句，为什么是题面可能是最小（最大）生成树呢，因为可能有边权相等的边。

时间复杂度 $O(\operatorname{maxflow}(n,m))$，可以通过本题。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

int n,m;
const int N = 200000+5,M = 200000+5;
int s,t,U,V,L,ret;

namespace MaxFlow{
	// 自己打一遍 Dinic 最大流，以防忘记
	struct edge{
		int nxt,to,w;
	} g[M<<2];
	int head[N],ec,dis[N],now[N];
	bool vis[N];
	void add(int u,int v,int w){
		g[++ec].nxt=head[u];
		g[ec].to=v;
		g[ec].w=w;
		head[u]=ec;
	}
	int bfs(){
		memset(dis,0x3f,sizeof(dis));
		memset(vis,0,sizeof(vis));
		queue<int> q;
		q.push(s);
		dis[s]=0;
		now[s]=head[s];
		vis[s]=1;
		while(!q.empty()){
			int u=q.front();
			q.pop();
			for(int i=head[u];i;i=g[i].nxt){
				int v=g[i].to;
				if(g[i].w>0 && !vis[v]){
					q.push(v);
					vis[v]=1;
					now[v]=head[v];
					dis[v]=dis[u]+1;
					if(v==t){
						return 1;
					}
				}
			}
		}
		return 0;
	}
	int dfs(int x,int sum){
		if(x==t){
			return sum;
		}
		int k,res=sum;
		for(int i=now[x];i&&sum;i=g[i].nxt){
			now[x]=i;
			int v=g[i].to;
			if(g[i].w>0&&(dis[v]==dis[x]+1)){
				k=dfs(v,min(res,g[i].w));
				g[i].w-=k;
				g[i^1].w+=k;
				res-=k;
			}
		}
		return sum-res;
	}
	int dinic(){
		int ans=0;
		while(bfs()){
			ans+=dfs(s,LLONG_MAX);
		}
		return ans;
	}
	void addedge(int u,int v,int cap){
		add(u,v,cap);
		add(v,u,-cap);
	}
	
	void clean(void){
		ec=0;
		memset(head,0,sizeof(head));
		memset(dis,0,sizeof(dis));
		memset(vis,0,sizeof(vis));
		memset(g,0,sizeof(g));
	}
}
using namespace MaxFlow;

struct Edge{int from,to,weight;};
vector<Edge> graph;

signed main(){
	cin>>n>>m;
	for(int i=1,u,v,w;i<=m;i++){
		cin>>u>>v>>w;
		graph.push_back({u,v,w});
	}
	cin>>U>>V>>L;
	s=U,t=V;
	clean();
	for(Edge i:graph){
		if(i.weight < L){
			addedge(i.from,i.to,1);addedge(i.to,i.from,1);
		}
	}
	ret=dinic();
	clean();
	for(Edge i:graph){
		if(i.weight > L){
			addedge(i.from,i.to,1);addedge(i.to,i.from,1);
		}
	}
	cout<<ret+dinic()<<'\n';
	return 0;
}

```

---

## 作者：Rainbow_qwq (赞：10)

[P5934 [清华集训2012]最小生成树](https://www.luogu.com.cn/problem/P5934)

---

# 思路

边权为 $L$ 的边 $(u,v)$，要出现在最小生成树上，需要什么条件呢？

就是，把边权 $<L$ 的所有边连上，$u,v$也不能联通，那边权为 $L$ 的边 $(u,v)$就必须选了。

也就是说在原图上割掉一些边，使$u,v$不能联通。

所以转化为最小割问题。

把原图中边权 $<L$ 的所有边 $a\to b$，都连 $a\to b$容量为$1$， $b\to a$ 容量为$1$，然后求 $u,v$ 之间的最小割。

那么最大生成树呢？把原图中边权 $>L$ 的所有边 $a\to b$，都连 $a\to b$容量为$1$， $b\to a$ 容量为$1$，然后求 $u,v$ 之间的最小割。

然后两个答案加起来就是答案了。

代码，用$\text{Dinic}$求最小割：
```cpp
#include<bits/stdc++.h>
#define For(i,a,b) for(register int i=(a);i<=(b);++i)
#define Rep(i,a,b) for(register int i=(a);i>=(b);--i)
using namespace std;
inline int read()
{
    char c=getchar();int x=0;bool f=0;
    for(;!isdigit(c);c=getchar())f^=!(c^45);
    for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+(c^48);
    if(f)x=-x;return x;
}
const int maxn=20007,maxm=200007,inf=0x3f3f3f3f;
int n,m,s,t,maxflow;
int dep[maxn],cur[maxn];
int tot=1,head[maxn];
struct edge{
	int to,nxt,w;
}e[maxm<<2];
inline void adde(int u,int v,int w){
	e[++tot]=(edge){v,head[u],w};
	head[u]=tot;
}
inline void add(int u,int v,int w){
	adde(u,v,w);
	adde(v,u,0);
}
bool bfs(int s,int t)
{
	queue<int>q;
	memcpy(cur,head,sizeof cur);
	memset(dep,63,sizeof dep);
	dep[s]=0;q.push(s);
	while(!q.empty())
	{
		int u=q.front();q.pop();
		for(int i=head[u];i;i=e[i].nxt){
			int v=e[i].to;
			if(dep[v]==inf&&e[i].w){
				dep[v]=dep[u]+1;
				q.push(v);
			}
		}
	}return dep[t]<inf;
}
int dfs(int u,int t,int minn)
{
	if(!minn||u==t)return minn;
	int res=0;
	for(int i=cur[u];i;i=e[i].nxt)
	{
		int v=e[i].to;
		cur[u]=i;
		if(dep[v]!=dep[u]+1)continue;
		int flow=dfs(v,t,min(minn,e[i].w));
		if(!flow)continue;
		res+=flow,minn-=flow;
		e[i].w-=flow,e[i^1].w+=flow;
		if(!minn)break;
	}return res;
}
inline int dinic(int s,int t)
{
	int maxflow=0;
	while(bfs(s,t))maxflow+=dfs(s,t,inf);
	return maxflow;
}
int uu[maxm],vv[maxm],ww[maxm];
int main()
{
	n=read(),m=read();
	For(i,1,m)uu[i]=read(),vv[i]=read(),ww[i]=read();
	s=read(),t=read();
	int L=read();
	For(i,1,m)if(ww[i]<L)add(uu[i],vv[i],1),add(vv[i],uu[i],1);
	int ans=dinic(s,t);
	memset(head,0,sizeof head);tot=1;//记得清空图。
	For(i,1,m)if(ww[i]>L)add(uu[i],vv[i],1),add(vv[i],uu[i],1);
	ans+=dinic(s,t);
	cout<<ans;
    return 0;
}
```

---

## 作者：YZren (赞：4)

# [最小生成树](https://www.luogu.com.cn/problem/P5934)

## 思路

- 先看最小生成树，如果要使最后的边可能在生成树上，那么边权大于这条边权值的可以不管，想把这条边放到生成树必须使 $u,v$ 不联通。所以把权值小于 $L$ 的边用 vector 建边（注意是双向建边），最后跑一个最小割即可（源点定为 $u$ 汇点定为 $v$ 就可以了）。

- 最大生成树同理，最后把两次最小割的结果加起来就是答案。

## Code


```cpp
#include<bits/stdc++.h>
#define int long long
#define f(i,j,k) for(int i=j;i<=k;i++)
#define F(i,j,k) for(int i=j;i>=k;i--)
const int maxn=2e5+10;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
inline void write(int x){
	if(x<0) {x=~(x-1); putchar('-');}
	if(x>9) write(x/10);
	putchar(x%10+'0');
}
int n=read(),m=read(),Uto,Vto,S,T,limit,dis[maxn],cur[maxn],ans;
struct node{
	int u,v,w;
} line[maxn];
struct edge{int to,val,id;}; std::vector<edge> vec[maxn];
inline void add(int u,int v,int w){Uto=vec[u].size();Vto=vec[v].size();vec[u].push_back({v,w,Vto});vec[v].push_back({u,0,Uto});}
inline bool bfs(){
	memset(dis,-1,sizeof(dis));
	std::queue<int> q; dis[S]=0; q.push(S);
	while(!q.empty()){
		int p=q.front(); q.pop();
		for(auto y:vec[p]) if(dis[y.to]==-1&&y.val) dis[y.to]=dis[p]+1,q.push(y.to);
	}
	memset(cur,0,sizeof(cur));
	return (dis[T]!=-1);
}
inline int dfs(int x,int inc){
	if(x==T) return inc;
	int delta=inc;
	for(int i=cur[x];i<(int)vec[x].size();i++){
		cur[x]=i; 
		if(dis[vec[x][i].to]==dis[x]+1&&vec[x][i].val){
			int d=dfs(vec[x][i].to,std::min(delta,vec[x][i].val));
			vec[x][i].val-=d; vec[vec[x][i].to][vec[x][i].id].val+=d;
			delta-=d; if(!d) dis[vec[x][i].to]=-1; 
		}
	}
	return inc-delta;
}
inline void dinic(){while(bfs()) ans+=dfs(S,LLONG_MAX);}
inline void work(){
	f(i,1,m) line[i]=(node){read(),read(),read()};
	S=read(),T=read(),limit=read();
	f(i,1,m) if(line[i].w<limit) add(line[i].u,line[i].v,1),add(line[i].v,line[i].u,1);
	dinic();
	f(i,1,n) vec[i].clear();
	f(i,1,m) if(line[i].w>limit) add(line[i].u,line[i].v,1),add(line[i].v,line[i].u,1);
	dinic();
	write(ans);
}
signed main(){work();return !!!!!("YZren");}
```

---

## 作者：FreeTimeLove (赞：3)

## 一、题意

给定连通无向图 $G$ 和一条额外给定的边 $e$，求至少删掉多少条边使得既**存在**最小生成树又**存在**最大生成树包含 $e$。

## 二、思路

我们考虑将 $e$ 加入 $G$，设 $e$ 的端点 $u,v$ 分别为 $s,t$。如果此时从 $s$ 到 $t$ 只有一条路径，那么 $e$ 存在于 $G$ 的**任意**一个生成树中；如果 $s,t$ 在一个环中，说明如果没有 $e$，仍然存在从 $s$ 到 $t$ 的路径，这个时候我们就去观察这个环。

在求最小生成树时，一定是**断掉**这个环的**最大**的一条边，那么只要环上存在**不小于** $e$ 的边，就存在最小生成树包含 $e$；在求最小生成树时，一定是**断掉**这个环的**最小**的一条边，那么只要环上存在**不大于** $e$ 的边，就存在最大生成树包含 $e$。也就是说，我们要“破坏”掉所有边都小于 $e$ 的环**和**所有边都大于 $e$ 的环。

那么我们只要令源点为 $s$，汇点为 $t$，分别建图 $G_1=\{\forall e'\in G|e'<e\}$，$G_2=\{\forall e'\in G|e'>e\}$，因为一个环只需割一条边，所以容量设为 $1$。求两图最小割之**和**即可。

注意要建双向边。

## 三、$\text{further}$

1. 如果要求**存在**最小生成树或**存在**最大生成树包含 $e$，求两图最小割的最小值。

2. 如果要求**任意**最小生成树包含 $e$，建图 $G_1=\{\forall e'\in G|e'\le e\}$。最大生成树同理。关键在于对于最小（大）生成树原理的认识。

### AC code

```cpp
//written_by_FTL
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#include<vector>
#define ll long long
#define db double
using namespace std;
const int N=2e4+5;
int rd(){
	int ans=0,f=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')f^=(ch=='-'),ch=getchar();
	while(ch>='0'&&ch<='9')ans=(ans<<3)+(ans<<1)+(ch^48),ch=getchar();
	if(f)ans=-ans;
	return ans;
}
int n,m,u,v,s,t,c,ans;
int nd[N],nds[N],tt=1;
int dep[N],INF=0x3f3f3f3f;
struct xxs{
	int u,v,w;
}ed[200005];
struct edge{
	int v,w,nxt;
}e[1000005];
void add(int u,int v,int w){
	e[++tt]={v,w,nd[u]};
	nd[u]=tt;
}
bool bfs(){
	queue<int>que;
	memset(dep,0,sizeof dep);
	dep[s]=1;
	que.push(s);
	while(!que.empty()){
		u=que.front();
		que.pop();
		for(int i=nd[u];i;i=e[i].nxt){
			v=e[i].v;
			if(dep[v]==0&&e[i].w){
				dep[v]=dep[u]+1;
				que.push(v);
			}
		}
	}
	return dep[t];
}
int dfs(int u,int flw){
	if(u==t)return flw;
	int ret=0,x;
	for(int i=nds[u];i;i=nds[u]){
		nds[u]=e[i].nxt;
		int v=e[i].v;
		if(dep[v]!=dep[u]+1||e[i].w==0)continue;
		x=dfs(v,min(flw,e[i].w));
		if(x){
			flw-=x,ret+=x;
			e[i].w-=x,e[i^1].w+=x;
			if(flw==0)break;
		}
	}
	return ret;
}
int dinic(){
	int flw=0;
	while(bfs())memcpy(nds,nd,sizeof nd),flw+=dfs(s,INF);
	return flw;
}
int main(){
	n=rd(),m=rd();
	for(int i=1;i<=m;i++)ed[i].u=rd(),ed[i].v=rd(),ed[i].w=rd();
	s=rd(),t=rd(),c=rd();
	for(int i=1;i<=m;i++)//双向建边
		if(ed[i].w<c)add(ed[i].u,ed[i].v,1),add(ed[i].v,ed[i].u,0),add(ed[i].v,ed[i].u,1),add(ed[i].u,ed[i].v,0); 
	ans+=dinic();
	memset(nd,0,sizeof nd),tt=1;
	for(int i=1;i<=m;i++)//双向建边
		if(ed[i].w>c)add(ed[i].u,ed[i].v,1),add(ed[i].v,ed[i].u,0),add(ed[i].v,ed[i].u,1),add(ed[i].u,ed[i].v,0); 
	ans+=dinic();
	printf("%d\n",ans);
	return 0;
}
```

### $\text{The End.}$

---

## 作者：wmy_goes_to_thu (赞：3)

不会 Dinic。。。只能用 EK 了。

如果是在最小生成树上，怎么办呢？？根据 Kruskal，先选 $\lt L$ 的边，然后选 $=L$ 的边。所以如果选完所有 $\lt L$ 的边，$u$ 和 $v$ 还不连通，那么只能选 $=L$ 的啦！所以，我们把所有 $\lt L$ 的边都连上，因为是无向图，所以两个方向的容量都是 $1$，求一个最小割就行了。根据最大流最小割定理，可以用 Dinic 来求最大流，当然我不会，用的是 EK。

同理，最大生成树只要把小于改成大于即可，然后两个答案相加就行了。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct apple
{
	int p1,p2,l,z;
	apple(int p1=0,int p2=0,int l=0,int z=0):p1(p1),p2(p2),l(l),z(z){}
	bool operator<(const apple &other)const
	{
		if(l!=other.l)return l<other.l;
		return z>other.z;
	}
};
int vist[20005],q[20005],u[200005],v[200005],w[200005],n,m,s,t,ans=0;
apple rt[20005];
vector<pair<int,int> >g[20005];
vector<int>gg[20005];
void minu(int x,int z)
{
	int ls=rt[x].p1,l2=rt[x].p2;
	if(!ls)return;
	int lt=gg[ls][l2];
	g[ls][l2].second-=z;
	g[x][lt].second+=z;
	minu(ls,z);
}
int EK()
{
	int head=0,tail=0;
	memset(vist,0,sizeof(vist));
	memset(rt,0,sizeof(rt));
	rt[s]=apple(0,0,0,2147483647);
	q[++tail]=s;
	while(head<tail)
	{
		int x=q[++head],y=rt[x].l,f=rt[x].z;
		vist[x]=1;
		for(int i=0;i<g[x].size();i++)
		{
			int cu=g[x][i].first;
			if(!g[x][i].second||vist[cu])continue;
			q[++tail]=cu;
			vist[cu]=1;
			rt[cu]=apple(x,i,y+1,min(f,g[x][i].second));
		}
	}
	if(rt[t].z)
	{
		minu(t,rt[t].z);
		ans+=rt[t].z;
		return rt[t].z;
	}
	return 0;
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&u[i],&v[i],&w[i]);
	}
	int uu,vv,ww;
	cin>>uu>>vv>>ww;
	for(int i=1;i<=m;i++)if(w[i]<ww)
	{
		gg[u[i]].push_back(g[v[i]].size());
		gg[v[i]].push_back(g[u[i]].size());
		g[u[i]].push_back(make_pair(v[i],1));
		g[v[i]].push_back(make_pair(u[i],1));
	}
	s=uu,t=vv;
	while(EK());
	int ans1=ans;
	for(int i=1;i<=n;i++)g[i].clear(),gg[i].clear();
	for(int i=1;i<=m;i++)if(w[i]>ww)
	{
		gg[u[i]].push_back(g[v[i]].size());
		gg[v[i]].push_back(g[u[i]].size());
		g[u[i]].push_back(make_pair(v[i],1));
		g[v[i]].push_back(make_pair(u[i],1));
	}
	s=uu,t=vv,ans=0;
	while(EK());
	cout<<ans+ans1<<endl;
	return 0;
}
```

---

## 作者：gghack_Nythix (赞：2)

## 前言：

感觉题解建图有些地方没有讲的很清楚（也可能是我没看到），接下来我来讲讲我的思考过程。

## 分析：

发现这个东西直接想非常的困难，先考虑它的一个子问题，就是如何判定一个图 $G$ 中 $(u,v,L)$ 可能位于最小生成树上。首先我们先把边权小于 $L$ 的边拿出来，然后再把他们组成一张新图 $G'$，如果 $G'$ 不连通，那就说明 $(u,v,L)$ 可能位于 $G$ 的最小生成树上。

是不是觉得挺扯的，接下来我们考虑怎么证明：

如果 $G'$ 本来就连通了，那么原图 $G$ 的最小生成树边集 $S$ 中，$\forall (u,v,w)\in S,w\leq L$，这是非常显然的，因为我直接从 $G'$ 中取个最小生成树就是 $G$ 的最小生成树了。

如果 $G'$ 是个不连通的，那么 $\exists(u,v,w)\in S,w\ge L$，不然 $G'$ 就可以直接取出一个最小生成树了。

如果 $\nexists(u,v,w)=L$ 的，则必然有一条边 $(u',v',w')$，有 $w>L$，如果它和题目给定的边 $(u,v,L)$ 重复，直接换掉就可以了（画个图可以帮助理解）。如果不重复，那么 $S$ 成为一颗基环树，也是直接去掉即可。

所以说上述结论是对的。

同理，我们可以推出 $(u,v,L)$ 可能位于最大生成树的条件，随后我们就可以推出满足题设的条件了，这个相信大家都能明白。

然后你建两个图，一个 $G'$，一个只有边权大于 $L$ 的边的图 $G''$，以 $u$ 为源点，$v$ 为汇点跑最小割，意义就是把 $(u,v,L)$ 分开，再加入 $(u,v,L)$ 这条边就可以正好使图连通，对 $G'$ 和 $G''$ 都跑一遍，求得的最小割答案相加即可，因为 $\nexists(u,v,w)\in G'$ 且 $\nexists(u,v,w)\in G''$，所以直接加就完了。

```cpp
# include <bits/stdc++.h>
# define int long long
using namespace std;
const int N = 1e6 + 5 , INF = 1e18;
int n , m , U , V , L;
struct edgedge {
	int u , v , w;
}E[N];
namespace netflow {
	int head[N] , nxt[N] , to[N] , tot , edge[N] , s , t , ans = 0 , ceng[N];
	void ade (int u , int v , int w) { nxt[++tot] = head[u] , head[u] = tot , to[tot] = v , edge[tot] = w; }
	void add (int u , int v , int w) { ade (u , v , w) , ade (v , u , 0); }
	bool bfs () {
		memset (ceng , 0 , sizeof ceng) , ceng[s] = 1;
		queue <int> q;
		q.push (s);
		while (!q.empty()) {
			int now = q.front();
			q.pop();
			for (int i = head[now] ; i ; i = nxt[i]) {
				int y = to[i];
				if (!edge[i]) continue;
				if (ceng[y]) continue;
				ceng[y] = ceng[now] + 1;
				q.push (y);
				if (y == t) return 1;
			}
		}
		return 0;
	}
	int dinic (int now , int flow) {
		if (now == t) return flow;
		int rest = flow;
		for (int i = head[now] ; i && rest ; i = nxt[i]) {
			int y = to[i];
			if (!edge[i]) continue;
			if (ceng[y] != ceng[now] + 1) continue;
			int inc = dinic (y , min (rest , edge[i]) );
			if (!inc) ceng[y] = -1;
			edge[i] -= inc , edge[i ^ 1] += inc , rest -= inc;
		}
		return flow - rest;
	}
}
void solve () {
	netflow::tot = 1 , memset (netflow::head , 0 , sizeof netflow::head) , netflow::s = 0 , netflow::t = N - 2 , netflow::ans = 0;
	cin >> n >> m;
	for (int i = 1;i <= m;++i) cin >> E[i].u >> E[i].v >> E[i].w;
	cin >> U >> V >> L;
	netflow::s = U , netflow::t = V;
	for (int i = 1;i <= m;++i) if (E[i].w < L) netflow::add (E[i].u , E[i].v , 1) , netflow::add (E[i].v , E[i].u , 1);
	int res1 = 0 , res2 = 0;
	while ( netflow::bfs() ) netflow::ans += netflow::dinic (netflow::s , INF);
	res1 = netflow::ans , netflow::ans = 0;
	netflow::tot = 1 , memset (netflow::head , 0 , sizeof netflow::head) , netflow::s = U , netflow::t = V , netflow::ans = 0;
	for (int i = 1;i <= m;++i) if (E[i].w > L) netflow::add (E[i].u , E[i].v , 1) , netflow::add (E[i].v , E[i].u , 1);
	while ( netflow::bfs() ) netflow::ans += netflow::dinic (netflow::s , INF);
	res2 = netflow::ans;
	return cout << res1 + res2 << "\n" , void();
}
signed main () {
	ios::sync_with_stdio(false) , cin.tie(0) , cout.tie(0);
	int T = 1;
	while (T--) solve ();
	return 0;
}
```

---

## 作者：Stinger (赞：2)

# $\texttt{Description}$

> 给你一个 $n$ 个点，$m$ 条边的图，请问至少删除原图上的多少条边，才能使得加入一条从 $u$ 到 $v$ 边权为 $L$ 的边后，该边同时在任意一颗最小生成树和最大生成树上。
>
> $ \texttt{Data Range:}1\le n\le 2\times 10^4,1\le m\le 2\times 10^5$

# $\texttt{Solution}$

根据 kruskal 算法的原理，一条边权为 $L$ 的边在最小生成树上，必须有将所有边权 $<L$ 的边加入后，$u$ 和 $v$ 仍然不连通。

那么问题转化为，只考虑边权 $<L$ 的情况下，需要删除多少条的边，使得 $u,v$ 不连通。就是个最小割问题了。最大生成树同理。

解释一下为什么没有取到等号，因为题目只要求出现在任意一颗 MST 上，而对于 kruskal 而言，排序的时候边权相同的边之间的顺序可以随意（而且如果不能随意，就不能使用 sort 这种不稳定的排序了）。所以为了满足题目的要求，在边权为 $L$ 的，两个端点仍未连通的边中，我们选择题目让我们新加的那条边。

虽然流量为 $1$ 的图上 Dinic 有优势，~~但是不管常数多小的 Dinic 仍然被 ISAP 吊起来打~~

~~不过大多数时候 EK 和 ISAP 差不多~~

# $\texttt{Code}$

```cpp
#include <cstdio>
#include <queue>
#include <cstring>

const int INF = 1e9;
inline int min(const int x, const int y) {return x < y ? x : y;}
struct Edge {
	int to, nxt, cap;
} e[800005];
int head[20005], cur[20005], num[20005], dep[20005], from[200005], to[200005], val[200005];
int tot = 1, s, t, n, m;
std::queue<int> Q;
inline void AddEdge(const int u, const int v, const int cap) {
	e[++ tot].to = v, e[tot].cap = cap, e[tot].nxt = head[u], head[u] = tot;
}

void bfs() {
	memset(num, 0, sizeof num);
	memset(dep, 0, sizeof dep);
	memcpy(cur, head, sizeof cur);
	Q.push(t);
	num[dep[t] = 1] = 1;
	while (Q.size()) {
		int u(Q.front());
		Q.pop();
		for (int i(head[u]); i; i = e[i].nxt)
			if (!dep[e[i].to]) ++ num[dep[e[i].to] = dep[u] + 1], Q.push(e[i].to);
	}
}

int dfs(const int u, const int flow) {
	if (u == t) return flow;
	int used(0), tmp(0);
	for (int i(head[u]); i; i = e[i].nxt) {
		cur[u] = i;
		if (dep[u] - 1 == dep[e[i].to] && e[i].cap) {
			if (tmp = dfs(e[i].to, min(e[i].cap, flow - used)))
				e[i].cap -= tmp, e[i ^ 1].cap += tmp, used += tmp;
			if (used == flow) return used;
		}
	}
	if (!(-- num[dep[u]])) dep[s] = n + 1;
	++ num[++ dep[u]];
	return used;
}

int ISAP() {
	int Maxflow(0);
	bfs();
	while (dep[s] && dep[s] <= n) Maxflow += dfs(s, INF);
	return Maxflow;
}

int main() {
	int ans(0), L;
	scanf("%d%d", &n, &m);
	for (int i(1); i <= m; ++ i) scanf("%d%d%d", from + i, to + i, val + i);
	scanf("%d%d%d", &s, &t, &L);
	for (int i(1); i <= m; ++ i)
		if (val[i] < L) AddEdge(from[i], to[i], 1), AddEdge(to[i], from[i], 1);
	ans = ISAP();
	memset(head, 0, sizeof head);
	tot = 1;
	for (int i(1); i <= m; ++ i)
		if (val[i] > L) AddEdge(from[i], to[i], 1), AddEdge(to[i], from[i], 1);
	printf("%d\n", ans + ISAP());
	return 0;
}
```

---

## 作者：BFqwq (赞：2)

## P5934 【[清华集训2012]最小生成树】
一道网络流水题吧。

我们先来考虑最小生成树的情况。如果一条边边权大于选中的边，那么这条边是否删去没有任何影响。

如果一条边边权等于它，由于我们要求的是**可能**，因此对答案也没有影响。

所以我们只需要保证边权比它小的边全部练完之后 $u,v$ 不连通即可，这样这条边就可以加入了。

把所有边权比选定的边的边权小的边拿出来连上，流量均为 $1$，然后求最小割即可。

由于熟知最小割等于最大流，直接一遍最大流结束。

然后清空数组，用一样的方法解决最大树的问题，也就是把边权大于选定边的边拿出来连上。

然后再跑一边最大流，两次答案相加。

```cpp
#include<bits/stdc++.h> 
#define int long long
using namespace std;
inline int read(){
	register int x=0;
	register bool f=0;
	register char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f=1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<3)+(x<<1)+c-48;
		c=getchar();
	}
	return f?-x:x;
}
char cr[200];int tt;
inline void print(int x,char k='\n') {
    if(!x) putchar('0');
    if(x < 0) putchar('-'),x=-x;
    while(x) cr[++tt]=x%10+'0',x/=10;
    while(tt) putchar(cr[tt--]);
    putchar(k);
}
const int maxn=25000;
const int inf=1e9+7; 
struct Edge{
    int nxt,to,val;
}e[3000005];
int num=1,h[maxn],s,t;
queue <int> q;
void add(int from,int to,int dis){
    e[++num].nxt=h[from];
    e[num].to=to;
    e[num].val=dis;
    h[from]=num;
    e[++num].nxt=h[to];
    e[num].to=from;
    e[num].val=1;
    h[to]=num;
}
int n,m,maxflow,dep[maxn];
char mp[105][105];
bool bfs(int s,int t){
	memset(dep,0x3f,sizeof(dep));
	while(!q.empty()) q.pop();
    dep[s]=0;
    q.push(s);
    while(!q.empty()){
        int u=q.front();q.pop();
        for (int i=h[u];i;i=e[i].nxt){
        	int v=e[i].to;
            if(dep[v]>inf&&e[i].val){
                dep[v]=dep[u]+1;
                q.push(e[i].to);
            }
        }
    }
    if(dep[t]<inf) return true;
    return 0;
}
int dfs(int u,int t,int lim){
    if (!lim||u==t)return lim;
    int flow=0,f;
    for (int i=h[u];i;i=e[i].nxt){
        int v=e[i].to;
        int &w=e[i].val;
        if(dep[v]==dep[u]+1&&(f=dfs(v,t,min(lim,w)))){
            flow+=f;
            lim-=f;
            w-=f;
            e[i^1].val+=f;
            if(!lim) break;
        }
    }
    return flow;
}
void dinic(int s,int t){
    while(bfs(s,t)){
		maxflow+=dfs(s,t,inf);
	}
}
int u[maxn*10],v[maxn*10],w[maxn*10],l,ans;
signed main(){
	n=read();m=read();
	for(int i=1;i<=m;i++){
		u[i]=read();
		v[i]=read();
		w[i]=read();
	} 
	s=read();t=read();l=read();
	for(int i=1;i<=m;i++){
		if(w[i]<l) add(v[i],u[i],1);
	}
	dinic(s,t);
	memset(h,0,sizeof(h));
	num=1;
	for(int i=1;i<=m;i++){
		if(w[i]>l) add(v[i],u[i],1);
	}
	dinic(s,t);
	print(maxflow);
	return 0;
}
```


---

## 作者：Cx114514 (赞：1)

### 题目链接：[[清华集训2012] 最小生成树](https://www.luogu.com.cn/problem/P5934)

考虑 Kruskal 算法的实现过程：将边权从小到大排序，依次加边，若 $u$ 和 $v$ 不连通，则可以加当前边。若一个指定边在最小生成树中，则在所有边权小于该边的边组成的图中，该边的两个端点不相连。

先把所有边权小于指定边的所有边建出一个图，目标就是要求出 $u$ 和 $v$ 不连通的最小删边数，这是一个经典的最小割问题。根据最大流最小割定理，只需将 $u$ 看作源点，$v$ 看作汇点，跑出的最大流即为答案。

因为图中均为单位流量，故时间复杂度为 $O\left(\min\left(n^\frac{2}{3},m^\frac{1}{2}\right)m\right)$。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

int read()
{
	int f = 1;
	char c = getchar();
	while (!isdigit(c))
	{
	    if (c == '-') f = -1;
	    c = getchar();
    }
	int x = 0;
	while (isdigit(c))
	{
		x = x * 10 + c - '0';
		c = getchar();
	}
	return x * f;
}

int buf[15];

void write(int x)
{
	int p = 0;
	if (x < 0)
	{
	    putchar('-');
	    x = -x;
	}
	if (x == 0) putchar('0');
	else
	{
		while (x)
		{
			buf[++p] = x % 10;
			x /= 10;
		}
		for (int i = p; i >= 1; i--)
			putchar('0' + buf[i]);
	}
}

int n, m, S, T, L, tot = 1, ans, U[200005], V[200005], W[200005], vis[20005], dep[20005], cur[20005];

queue < int > q;

struct node
{
	int u, v, w;
} edge[1000005];

struct node2
{
	int to, num;
};

vector < node2 > G[20005]; 

bool bfs()
{
	while (!q.empty()) q.pop();
	for (int i = 1; i <= n; i++)
		vis[i] = 0;
	for (int i = 1; i <= n; i++)
		dep[i] = 1145141919;
	for (int i = 1; i <= n; i++)
		cur[i] = 0;
	dep[S] = 0;
	vis[S] = 1;
	q.push(S);
	while (!q.empty())
	{
		int t = q.front();
		q.pop();
		for (int i = 0; i < G[t].size(); i++)
		{
			int v = G[t][i].to, num = G[t][i].num;
			if (!vis[v] && edge[num].w)
			{
				dep[v] = dep[t] + 1;
				q.push(v);
				vis[v] = 1;
			}
		}
	}
	if (dep[T] == 1145141919) return 0;
	return 1;
}

int dfs(int u, int flow)
{
	int x;
	if (u == T) return flow;
	for (int i = cur[u]; i < G[u].size(); i++)
	{
		cur[u] = i;
		int v = G[u][i].to, num = G[u][i].num;
		if (edge[num].w && dep[v] == dep[u] + 1)
			if (x = dfs(v, min(flow, edge[num].w)))
			{
				edge[num].w -= x;
				edge[num ^ 1].w += x;
				return x;
			}
	}
	return 0;
}

int main()
{
	n = read(), m = read();
	for (int i = 1; i <= m; i++)
		U[i] = read(), V[i] = read(), W[i] = read();
	S = read(), T = read(), L = read();
	for (int i = 1; i <= m; i++)
		if (W[i] < L)
		{
			edge[++tot] = {U[i], V[i], 1};
			G[U[i]].push_back({V[i], tot});
			edge[++tot] = {V[i], U[i], 0};
			G[V[i]].push_back({U[i], tot});
			edge[++tot] = {V[i], U[i], 1};
			G[V[i]].push_back({U[i], tot});
			edge[++tot] = {U[i], V[i], 0};
		}
	while (bfs())
	{
		int x;
		while (x = dfs(S, 1145141919)) ans += x;
	}
	for (int i = 1; i <= n; i++)
		G[i].clear();
	tot = 1;
	for (int i = 1; i <= m; i++)
		if (W[i] > L)
		{
			edge[++tot] = {U[i], V[i], 1};
			G[U[i]].push_back({V[i], tot});
			edge[++tot] = {V[i], U[i], 0};
			G[V[i]].push_back({U[i], tot});
			edge[++tot] = {V[i], U[i], 1};
			G[V[i]].push_back({U[i], tot});
			edge[++tot] = {U[i], V[i], 0};
		}
	while (bfs())
	{
		int x;
		while (x = dfs(S, 1145141919)) ans += x;
	}
	write(ans);
	putchar('\n');
	return 0;
}

```

---

## 作者：spider_oyster (赞：1)

最小割板题。

以最小生成树为例。

考虑一个 kruskal 的过程，先按边权排序，对于当前边 $(u,v,L)$，会用到这条边当且仅当 $u,v$ 不在一个连通块。

那么加入所有 $w<L$ 的边，以 $u$ 为源点，$v$ 为汇点，求最小割即可。

对于最大生成树同理。

两次求最小割加入的边集显然不重，把两次求的答案相加即可。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=20005;
int n,m,ans,L,S,T,tot=1,pre[N],lv[N],cur[N];
struct node{int u,v,w;} a[N*10];
struct edge{int to,nxt,w;} e[N*20];

void add(int u,int v)
{
    e[++tot]={v,pre[u],1},pre[u]=tot;
    e[++tot]={u,pre[v],1},pre[v]=tot;
}

int bfs()
{
    memset(lv,0,sizeof(lv));
    memcpy(cur,pre,sizeof(cur));
    queue<int> q;lv[S]=1;q.push(S);
    while(!q.empty())
    {
        int u=q.front();q.pop();
        for(int i=pre[u];i;i=e[i].nxt)
        {
            int v=e[i].to,w=e[i].w;
            if(!lv[v]&&w) lv[v]=lv[u]+1,q.push(v);
        }
    }
    return lv[T];
}

int dfs(int u=S,int flow=1e9)
{
    if(u==T) return flow;
    int lev=flow;
    for(int i=cur[u];i&&lev;i=e[i].nxt)
    {
        cur[u]=i;
        int v=e[i].to,w=e[i].w;
        if(lv[v]==lv[u]+1&&w)
        {
            int out=dfs(v,min(lev,w));
            e[i].w-=out,lev-=out,e[i^1].w+=out;
        }
    }
    return flow-lev;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=m;i++) cin>>a[i].u>>a[i].v>>a[i].w;
    cin>>S>>T>>L;
    for(int i=1;i<=m;i++) if(a[i].w<L) add(a[i].u,a[i].v);
    while(bfs()) ans+=dfs();
    tot=1;
    memset(pre,0,sizeof(pre));
    for(int i=1;i<=m;i++) if(a[i].w>L) add(a[i].u,a[i].v);
    while(bfs()) ans+=dfs();
    cout<<ans<<'\n';
}
```

---

## 作者：wangyibo201026 (赞：1)

## 题意

给你一张**无向图**，并且给你一条边，每条边都有其对应的边权，问最少删除多少条边，才能使原图中的最小生成树和最大生成树都都包含给定的边（不删除给定的边）。

## 思路

我们考虑什么时候会满足题目条件。考虑最小生成树一定是在连通的图里才有的，所以我们可以得出这样一个结论：如果给出的边在最小生成树上，那么由边权小于这条边的所有边构成的新图一定是不连通的。我们考虑用证明：

假如新图是连通的，那么对新图求最小生成树，这棵最小生成树一定是原图的最小生成树（因为新图中都是原边集中边权较小的边，答案一定更优），而其中的所有边权都比给定边边权小，所以没必要加进给定的边。

最大生成树也是同样的，将大于给定边边权的边建新图。

我们发现，要使得新图不连通，最少删除的边的数量，就是最小割问题，使用最小割求解。

由于两张新图的边集的交集为空集，所以将两张新图的最小割加起来即可。

## 代码

Code：

```cpp
#include<bits/stdc++.h>

#define int long long
#define endl '\n'

using namespace std;

const int N = 2e5 + 5;
const int INF = 1 << 30;

int n, m, s, t, ans;
int u[N], v[N], w[N];

// 以下是祖传 dinic

int dep[N], st[N];
bool vis[N];

int head[N], tot = 1;

struct Node{
	int to, w, next;
}edges[N * 2];

void add(int u, int v, int w){
	tot++;
	edges[tot].to = v;
	edges[tot].w = w;
	edges[tot].next = head[u];
	head[u] = tot;
}

bool bfs(){
	memset(dep, 0, sizeof(dep));
	dep[s] = 1;
	queue<int> q;
	q.push(s);
	while(!q.empty()){
		int x = q.front();
		q.pop();
		for(int i = head[x]; i; i = edges[i].next){
			if(dep[edges[i].to] == 0 && edges[i].w){
				dep[edges[i].to] = dep[x] + 1;
				if(edges[i].to == t){
					return true;
				}
				q.push(edges[i].to);
			}
		}
	}
	return false;
}

int dfs(int x, int flow){
  if(x == t){
    vis[t] = true;
		return flow;
	}
	int tmp = 0, sum = 0;
  for(int i = st[x]; i; i = edges[i].next){
    st[x] = i;
    if(edges[i].w && dep[edges[i].to] == dep[x] + 1){
			if(tmp = dfs(edges[i].to, min(flow - sum, edges[i].w))){
				edges[i].w -= tmp;
				edges[i ^ 1].w += tmp;
				sum += tmp;
			}
			if(flow == sum){
				break;
			}
    }
  }
  if(!sum){
  	dep[x] = 0;
	}
  return sum;
}

int dinic(){
	int ans = 0, sum;
	while(bfs()){
	  memcpy(st, head, sizeof(head));
	  vis[t] = true;
	  while(vis[t]){
	    vis[t] = false;
		  while(sum = dfs(s, INF)){
			  ans += sum;
		  }
	  }
	}
	return ans;
}

void Solve(){
  cin >> n >> m;
  for(int i = 1; i <= m; i++){
    cin >> u[i] >> v[i] >> w[i];
  }
  int L;
  cin >> s >> t >> L;
  for(int i = 1; i <= m; i++){
    if(w[i] > L){
      add(u[i], v[i], 1); // 这里由于是无向图，所以正反两边都为 1
      add(v[i], u[i], 1);
    }
  }
  ans += dinic();
  tot = 1;
  memset(head, 0, sizeof(head));
  for(int i = 1; i <= m; i++){
    if(w[i] < L){
      add(u[i], v[i], 1);
      add(v[i], u[i], 1);
    }
  }
  ans += dinic();
  cout << ans;
}

signed main(){
#ifdef debug
  freopen("Code.in", "r", stdin);
  freopen("Code.out", "w", stdout);
#endif
  Solve();
  return 0;
}
```

---

## 作者：wjl1100 (赞：0)

## [原题传送门](https://www.luogu.com.cn/problem/P5934)

## 思路

我们先思考一下什么时候一条边会出现在最小生成树上，根据 kruskal 的实现过程，我们可以发现如果这条边的边权是连接它两端端点所在联通块中所有边中最小的，那么这条边一定会出现在最小生成树中，而最大生成树同理，我们可以发现如果这条边的边权是连接它两端端点所在联通块中所有边中最大的，那么这条边一定会出现在最大生成树中，现在的问题是如何保证这条边是最小或最大的。

其实很简单，只需要将连接这两个联通块之间比这条边小的边都删除就好了，这时我们就会想到最小割，这样我们就可以以最小的代价断开这两个连通块，那么实现思路就很明了了，首先把所有小于这条边边权的边提出来，建成一个图后以两个端点分别为汇点和源点跑最大流，然后把所有大于这条边边权的边提出来，建成一个图后以两个端点分别为汇点和源点跑最大流，将答案加起来即可。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define inf 0x7f7f7f7f
#define mod 1000000007
using namespace std;
const int maxn = 1e6 + 100;
inline int read() {
	int x = 0 , f = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9' ) {if (ch == '-') f = -1; ch = getchar();}
	while (ch >= '0' && ch <= '9') { x = x * 10 + ch - 48; ch = getchar();}
	return x * f;
}
inline void write(int x) {
	if(x < 0) x = ~(x - 1) , putchar('-');
	if(x > 9) write(x / 10);
	putchar(x % 10 + '0');
}
inline void writeh(int x) {
	write(x);
	putchar('\n');
}
inline void writek(int x) {
	write(x);
	putchar(' ');
}
int n , m , u , v , w , head[maxn] , tot = 1 , dis[maxn] , cul[maxn] , l;
struct edge {
	int to , next , w;
}e[maxn];
struct node {
	int u , v , w;
}t[maxn];
inline void add(int u , int w , int v) {
	e[++tot].to = v;
	e[tot].w = w;
	e[tot].next = head[u];
	head[u] = tot;
}
inline void adde(int u , int v , int w) {
	add(u , w , v);
	add(v , 0 , u);
}
inline bool bfs(int s , int t) {
	queue<int> q;
	q.push(s);
	memset(dis , -1 , sizeof(dis));
	dis[s] = 0;
	while(!q.empty()) {
		int u = q.front();
		q.pop();
		for(int i = head[u]; i; i = e[i].next) {
			int v = e[i].to;
			if(dis[v] == -1 && e[i].w) {
				dis[v] = dis[u] + 1;
				q.push(v);
			}
		}
	}
	return dis[t] != -1;
}
inline int dfs(int u , int sum , int t) {
	if(u == t) return sum;
	int last = sum;
	for(int i = cul[u]; i; i = e[i].next) {
		cul[u] = i;
		int v = e[i].to;
		if(dis[v] == dis[u] + 1 && e[i].w) {
			int w = dfs(v , min(last , e[i].w) , t);
			e[i].w -= w;
			e[i ^ 1].w += w;
			last -= w;
			if(!last) break;
		}
	}
	return sum - last;
}
inline int maxflow(int s , int t) {
	int ans = 0;
	while(bfs(s , t)) {
		memcpy(cul , head , sizeof(head));
		ans += dfs(s , inf , t);
	}
	return ans;
}
signed main(){
	n = read();
	m = read();
	for(int i = 1; i <= m; i++) {
		u = read();
		v = read();
		w = read();
		t[i] = {u , v , w};
	}
	u = read();
	v = read();
	l = read();
	for(int i = 1; i <= m; i++) if(t[i].w > l) adde(t[i].u , t[i].v , 1) , adde(t[i].v , t[i].u , 1); 
	int sum = maxflow(u , v);
	tot = 1;
	memset(head , 0 , sizeof(head));
	memset(e , 0 , sizeof(e));
	for(int i = 1; i <= m; i++) if(t[i].w < l) adde(t[i].u , t[i].v , 1) , adde(t[i].v , t[i].u , 1);
	sum += maxflow(u , v);
	writeh(sum);
	return !("wjl1100 qwq");
}
```

---

## 作者：Conan15 (赞：0)

感觉挺套路的，但是不知道为什么觉得有点难想到。

以最小生成树为例，如果 $(u,v,L)$ 可能在最小生成树上出现，根据 Kruskal 的算法流程，需要满足：当加入所有边权 $\lt L$ 的边之后，$u,v$ 属于不同的连通块。\
显然此时可以通过 $(u,v,L)$ 将 $u,v$ 连通块合并，最大生成树同理。

回到题目，要求删掉若干条边，使得 $(u,v,L)$ 可能在最小生成树上。\
即在边权全都 $\lt L$ 的图中删除最少的边，使得 $u,v$ 不连通，这可以联想到**最小割**。

于是把 $\lt L$ 的图建出来跑最小割即可。\
对于最大生成树同理，把 $\gt L$ 的图建出来。\
由于 $\lt L$ 和 $\gt L$ 的边集的交集大小为 $0$，所以可以直接根据加法原理，将最小生成树和最大生成树跑出来的最小割相加，即为答案。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e4 + 15, M = 1e6 + 15;
const int INF = 0x3f3f3f;
int n, m;

struct Network_Flow {
    int n, S, T;
    int h[N], e[M], w[M], ne[M], idx = 0;
    void add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++; }
    void addedge(int a, int b, int c) { add(a, b, c), add(b, a, 0); }
    
    int ans;
    
    int d[N], cur[N];
    
    void init(int qwq, int st, int ed) {
        memset(h, -1, sizeof h), idx = 0;
        n = qwq, S = st, T = ed;
        ans = 0;
    }
    
    bool bfs() {
        queue<int> q; while (q.size()) q.pop();
        for (int i = 1; i <= n; i++) d[i] = 0;
        cur[S] = h[S], d[S] = 1, q.push(S);
        while (q.size()) {
            int u = q.front(); q.pop();
            for (int i = h[u]; ~i; i = ne[i]) {
                int v = e[i];
                if (!w[i] || d[v]) continue;
                d[v] = d[u] + 1, cur[v] = h[v];
                q.push(v);
                if (v == T) return 1;
            }
        }
        return 0;
    }
    int dfs(int u, int rest) {
        if (u == T) return rest;
        if (rest == 0) return 0;
        int flow = 0;
        for (int i = cur[u]; ~i; cur[u] = i = ne[i]) {
            int v = e[i];
            if (d[v] != d[u] + 1 || w[i] == 0) continue;
            int now = dfs(v, min(w[i], rest - flow));
            if (now == 0) d[v] = -1;
            else w[i] -= now, w[i ^ 1] += now, flow += now;
            if (flow == rest) break;
        }
        return flow;
    }
    int dinic() { while (bfs()) ans += dfs(S, INF); return ans; }
} G;

struct Edges {
    int u, v, w;
} edge[M];
bool cmp(Edges a, Edges b) { return a.w < b.w; }

int st, ed, L;
int ans1 = 0, ans2 = 0;

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i++) scanf("%d%d%d", &edge[i].u, &edge[i].v, &edge[i].w);
    scanf("%d%d%d", &st, &ed, &L);
    sort(edge + 1, edge + 1 + m, cmp);
    
    G.init(n, st, ed);
    for (int i = 1; i <= m; i++) {
        if (edge[i].w >= L) break;
        G.addedge(edge[i].u, edge[i].v, 1);
        G.addedge(edge[i].v, edge[i].u, 1);
    }
    ans1 = G.dinic();
    
    G.init(n, st, ed);
    for (int i = m; i >= 1; i--) {
        if (edge[i].w <= L) break;
        G.addedge(edge[i].u, edge[i].v, 1);
        G.addedge(edge[i].v, edge[i].u, 1);
    }
    ans2 = G.dinic();
    
    printf("%d\n", ans1 + ans2);
    return 0;
}
```

---

## 作者：封禁用户 (赞：0)

**主要思路：网络流。**

## 思路

先考虑最小生成树，如果一条边边权大于等于选中的边，那么这条边是否删去没有任何影响。

按边权排序，对于边 $(u,v,L)$，若要加上当且仅当 $u$ 和 $v$ 并不联通。

把所有边权比选定的边的边权小的边拿出来连上，流量均为 $1$，最小割。

最大树同理，连上边权比选定的边的边权大的边，接着跑最大流。

两次答案相加。

## AC code


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int inf = 1e9 + 7;
struct node {
	int nxt, to, val;
} e[3000005];
int num = 1, h[250000], s, t;
void add(int from, int to, int dis) {
	e[++num].nxt = h[from],e[num].to = to,e[num].val = dis,h[from] = num,e[++num].nxt = h[to],e[num].to = from,e[num].val = 1,h[to] = num;
}
queue<int>q;
int n, m, ans, dep[250000];
int u[2500000], v[2500000], w[2500000], l;
bool bfs(int s,int t){
	memset(dep,0x3f,sizeof(dep));
	while(!q.empty())q.pop();
	dep[s]=0;
	q.push(s);
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(int i=h[u];i;i=e[i].nxt){
			int v=e[i].to;
			if(dep[v]>inf&&e[i].val){
				dep[v]=dep[u]+1;
				q.push(e[i].to);
			}
		}
	}
	if(dep[t]<inf)return 1;
	return 0;
}
int dfs(int u,int t,int lim){
	if(!lim||t==u)return lim;
	int flow=0,f;
	for(int i=h[u];i;i=e[i].nxt){
		int v=e[i].to;
		int &w=e[i].val;
		if(dep[v]==dep[u]+1&&(f=dfs(v,t,min(lim,w)))){
			flow+=f;
			lim-=f;
			w-=f;
			e[i^1].val+=f;
			if(!lim)break;
		}
	}
	return flow;
}
void dinic(int s, int t) {
	while (bfs(s, t))ans += dfs(s, t, inf);
}
signed main() {
	cin >> n >> m;
	for (int i = 1; i <= m; i++)cin >> u[i] >> v[i] >> w[i];
	cin >> s >> t >> l;
	for (int i = 1; i <= m; i++)if (w[i] < l)add(v[i], u[i], 1);
	dinic(s, t);
	memset(h,0,sizeof(h));
	num=1;
	for(int i=1;i<=m;i++)if(w[i]>l)add(v[i],u[i],1);
	dinic(s,t);
	cout<<ans;
	return 0;
}
```

---

## 作者：HJY2022 (赞：0)

考虑 `kruskal` 算法的过程。

先将边按边权排序，考虑当加入 $(u,v)$ 时只有 $(u,v)$ 不联通才可能使得其出现在最小生成树中，所以对于所有的边权小于 $L$ 的边，我们希望去除尽可能少的边使得 $(u,v)$ 不联通。这显然是一个网络流模型。对于每一条边 $(x,y)$ 建立一条容量为 $1$ 的边，最小割即为答案。

最大生成树的过程是类似的，加入所有边权大于 $L$ 的边跑最小割，将两次网络流的答案加起来即可。

复杂度分析：
由于容量均为 $1$，所以在使用 `Dinic` 算法时间复杂度会降低，具体分析参考[OI-wiki Dinic算法特殊情境下的复杂度分析](https://oi-wiki.org/graph/flow/max-flow/#%E7%89%B9%E6%AE%8A%E6%83%85%E5%BD%A2%E4%B8%8B%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90)~~反正能过就对了~~

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int MX=1e6+7;
const ll INF=1e18+7;
struct Edge{
	int from,to;
	ll cap,flow;
	int nxt;
}edge[MX];
struct e{
	int u,v,c;
}cedge[MX];
bool cmp(e x,e y){return x.c<y.c;}
int head[MX],cur[MX],d[MX],tNode=0,cnt=0;
bool vis[MX];
int n,m,s,t,L;
void addE(int u,int v,ll c){
	edge[tNode].from=u;
	edge[tNode].to=v;
	edge[tNode].cap=c;
	edge[tNode].flow=0;
	edge[tNode].nxt=head[u];
	head[u]=tNode;
	tNode++;
}

queue<int > q; 

bool BFS() {
	memset(vis,false,sizeof(vis));
	d[s]=0;
	vis[s]=true;
	q.push(s);
	while(!q.empty()){
		int p=q.front();
		q.pop();
		for(int i=head[p];i!=-1;i=edge[i].nxt){
			int to=edge[i].to;
			if(!vis[to]&&edge[i].flow<edge[i].cap){
				d[to]=d[p]+1;
				vis[to]=true;
				q.push(to);
			}
		}
	}
	return vis[t];
}

ll DFS(int x,ll a){
	//cout<<x<<endl;
	if(x==t||a==0)return a;
	ll flow=0,f;
	for(int &i=cur[x];i!=-1;i=edge[i].nxt){
		int to=edge[i].to;
		if(d[x]+1==d[to]&&(f=DFS(to,min(a,edge[i].cap-edge[i].flow)))>0){
			flow+=f;
			a-=f;
			edge[i].flow+=f;
			edge[i^1].flow-=f;
			if(a==0)break;
		}
	}
	return flow;
}

ll DINIC(){
	ll ret=0;
	while(BFS()){
		for(int i=1;i<=n;i++)cur[i]=head[i];
		ret+=DFS(s,INF);
	}
	return ret;
}

void add(int x,int y,ll c){
	addE(x,y,c);
	addE(y,x,0);
}

ll solve(int l,int r){
	for(int i=1;i<=n;i++)head[i]=-1;
	tNode=0;
	for(int i=l;i<=r;i++){
		add(cedge[i].u,cedge[i].v,1);
		add(cedge[i].v,cedge[i].u,1);
	}
	return DINIC();
}

int main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++)cin>>cedge[i].u>>cedge[i].v>>cedge[i].c;
	sort(cedge+1,cedge+1+m,cmp);
	cin>>s>>t>>L;
	int pos1=0,pos2=0;
	for(int i=1;i<=m;i++){
		if(cedge[i].c>=L&&pos1==0)pos1=i;
		if(cedge[i].c>L&&pos2==0)pos2=i;
	}
	cout<<solve(1,pos1-1)+solve(pos2,m)<<endl;
	return 0;
}
```

---

## 作者：xuyuansu (赞：0)

## 简要题意
给一个无向图和一条边，问需要删除几条边才能让这条边可能在最小和最大生成树内
## 题解
Kruskal 求最小生成树我们是学过的，我们知道当一条边是它两边所在的联通块之间最短的，这条边就必定在生成树内。

这道题的思路也差不多，我们可以设想包含给定的边的环，这样包含了所有可能的上述操作，也就是说，我们要保证这条边一定是联通每个环上的点的可能连边，这要求给定的边不能是环上最差的。

这样的话我们就把比给定边差或者一样的全部删掉，如果剩下的边还有环，那么给定的边一定是最差的，接下来只要计算去掉多少边就可以了，用最小割解决。

关于同时要在最小和最大两颗生成树中，其实不需要担心会有交集什么的，上面忽略更差边已经保证了两次求解不会产生边交集，放心大胆做两次加起来就好了。

注意：是无向图，向哪边流都有可能。
```c
#include<bits/stdc++.h>
using namespace std;
const int N=20005,M=1e6+5;
int n,m,num,ver[M],ne[M],val[M],head[N],tot=1,dis[N],now[N],ans,s,t;
int a[M],b[M],c[M],v;
void add(int x,int y,int z)
{
	ver[++tot]=y;ne[tot]=head[x];head[x]=tot;val[tot]=z;
	ver[++tot]=x;ne[tot]=head[y];head[y]=tot;val[tot]=z;
}
bool bfs()
{
	memset(dis,0,sizeof(dis));
	queue<int> q;dis[s]=1;
	now[s]=head[s];q.push(s);
	while(q.size())
	{
		int x=q.front();q.pop();
		for(int i=head[x];i;i=ne[i])
		{
			int y=ver[i];
			if(!val[i] || dis[y]) continue;
			dis[y]=dis[x]+1;now[y]=head[y];
			q.push(y);
		}
	}
	if(dis[t]) return 1;
	return 0;
}
int dinic(int x,int flow)
{
	if(x==t) return flow;
	int k,rest=flow;
	for(int i=now[x];i && rest;i=ne[i])
	{
		int y=ver[i];now[x]=i;
		if(!val[i] || dis[y]!=dis[x]+1) continue;
		k=dinic(y,min(rest,val[i]));
		if(!k) dis[y]=0;
		val[i]-=k;val[i^1]+=k;rest-=k;
	}
	return flow-rest;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		int x,y,z;scanf("%d%d%d",&x,&y,&z);
		a[i]=x;b[i]=y;c[i]=z;
	}
	scanf("%d%d%d",&s,&t,&v);
	for(int i=1;i<=m;i++)
	{
		if(c[i]>=v) continue;
		add(a[i],b[i],1);
	}
	while(bfs())
	{
		int flow;
		while(flow=dinic(s,0x3f3f3f3f)) ans+=flow;
	}
	memset(head,0,sizeof(head));tot=1;
	for(int i=1;i<=m;i++)
	{
		if(c[i]<=v) continue;
		add(a[i],b[i],1);
	}
	while(bfs())
	{
		int flow;
		while(flow=dinic(s,0x3f3f3f3f)) ans+=flow;
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：happybob (赞：0)

## 题意

给定一张无向有权图和一条额外的边，问最少删除多少条边，可以使得这条额外的边即有可能出现在这张图的最小生成树中，也有可能出现在最大生成树中。

## 解法

考虑用 Kruskal 求最小生成树时，对于额外的这条边 $(u, v)$，其权值为 $l$，如果前面边权 $<l$ 的边连接后 $u,v$ 已经联通，那么 $u,v$ 就不会被选，所以考虑对于所有边权 $<l$ 的边，连一条双向边，容量为 $1$，事实上就是求这个图的最小割。

最大生成树同理，答案是两个最小割之和。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long

const int N = 1e6 + 5;

int u[N], v[N], w[N], cur[N], d[N];
int n, m, s, t, L, ans = 0;

int e[N], c[N], h[N], ne[N], idx;

void add(int U, int V, int W)
{
	e[idx] = V, c[idx] = W, ne[idx] = h[U], h[U] = idx++;
	e[idx] = U, c[idx] = 0, ne[idx] = h[V], h[V] = idx++;
}

int bfs()
{
	for (int i = 1; i <= n; i++) d[i] = -1;
	cur[s] = h[s];
	d[s] = 0;
	queue<int> q;
	q.push(s);
	while (q.size())
	{
		int u = q.front();
		q.pop();
		for (int i = h[u]; ~i; i = ne[i])
		{
			int j = e[i];
			if (d[j] == -1 && c[i] > 0)
			{
				d[j] = d[u] + 1;
				cur[j] = h[j];
				if (j == t) return 1;
				q.push(j);
			}
		}
	}
	return 0;
}

int dfs(int u, int lim)
{
	if (u == t) return lim;
	int flow = 0;
	for (int i = cur[u]; ~i && flow < lim; i = ne[i])
	{
		cur[u] = i;
		int j = e[i];
		if (d[j] == d[u] + 1 && c[i] > 0)
		{
			int t = dfs(j, min(c[i], lim - flow));
			if (t == 0) d[j] = -1;
			flow += t;
			c[i] -= t, c[i ^ 1] += t;
		}
	}
	return flow;
}

int dinic()
{
	int ret = 0, f;
	while (bfs())
	{
		while (f = dfs(s, (int)2e9)) ret += f;
	}
	return ret;
}

signed main()
{
	memset(h, -1, sizeof h);
	scanf("%lld%lld", &n, &m);
	for (int i = 1; i <= m; i++)
	{
		scanf("%lld%lld%lld", &u[i], &v[i], &w[i]);
	}
	scanf("%lld%lld%lld", &s, &t, &L);
	for (int i = 1; i <= m; i++)
	{
		if (w[i] < L)
		{
			add(u[i], v[i], 1);
			add(v[i], u[i], 1);
		}
	}
	ans = dinic();
	memset(h, -1, sizeof h);
	idx = 0;
	for (int i = 1; i <= m; i++)
	{
		if (w[i] > L)
		{
			add(u[i], v[i], 1);
			add(v[i], u[i], 1);
		}
	}
	ans += dinic();
	printf("%lld\n", ans);
	return 0;
}
```


---

## 作者：lx_zjk (赞：0)

# $\text{Description}$

求使$(u,v,w)$这条边既在图的最小生成树上也在最大生成树上，最少需要删除的边的数量。
# $\text{Solution}$
我们先考虑最小生成树

我们模拟$\text{Kruskal}$的算法过程，如果$(u,v,w)$要在最小生成树上的话，那么在选这条边的时候，前面比他小的边都没有使$(u,v)$联通。

这样相当于我们要使$(u,v)$在比他小的边集中，不让他们联通，即求最小割。

最大生成树也同理。

# $\text{Code}$
```cpp
inline void Build() {
	read(n); read(m); Flow.n = n; 
	for (int i = 1; i <= m; ++i) read(a[i]), read(b[i]), read(c[i]);
	read(Flow.s); read(Flow.t); read(w);
	Flow.Clear();
	for (int i = 1; i <= m; ++i) if (w < c[i]) Flow.Add(a[i], b[i], 1);//这里建的是两边流量均为1的边
	Flow.Dinic(Flow.s, Flow.t, Flow.n);
	Flow.Clear();
	for (int i = 1; i <= m; ++i) if (w > c[i]) Flow.Add(a[i], b[i], 1);
	Flow.Dinic(Flow.s, Flow.t, Flow.n); 
	printf("%d\n", ans);
}
```

---

## 作者：MikukuOvO (赞：0)

首先考虑最小生成树的情况：

考虑如何使得$<u,v>$不在最小生成树上，不难发现如果只使用$<L$的边就能使得$u,v$联通那么就不在最小生成树上。

那么我们就将问题转化成了删去最少的边使得$u,v$不连通，也就是求最小割了。

最大生成树同理。

代码：

```cpp
const int N=2e4+5;
const int M=2e5+5;

int n,m,cnt,s,t;
int u[M],v[M],w[M];
int head[N],dep[N];

struct edge
{
    int to,nxt,w;
};
edge e[M<<2];

void add(int x,int y,int z)
{
    e[++cnt].to=y;
    e[cnt].nxt=head[x];
    e[cnt].w=z;
    head[x]=cnt;
}
void link(int x,int y,int z)
{
    add(x,y,z),add(y,x,0);
}
bool bfs()
{
    queue<int>q;
    ms(dep);
    q.push(s),dep[s]=1;
    while(!q.empty())
    {
	int x=q.front();
	q.pop();
	for(int i=head[x];i;i=e[i].nxt)
	{
	    int v=e[i].to;
	    if(e[i].w&&!dep[v])
	    {
		dep[v]=dep[x]+1;
		q.push(v);
		if(v==t) return true;
	    }
	}
    }
    return false;
}
int dfs(int x,int flow)
{
    if(x==t) return flow;
    int res=flow,delta;
    for(int i=head[x];i;i=e[i].nxt)
    {
	int v=e[i].to;
	if(!res) return flow;
	if(e[i].w&&dep[v]>dep[x])
	{
	    delta=dfs(v,min(e[i].w,res));
	    if(!delta) dep[v]=0;
	    e[i].w-=delta,e[i^1].w+=delta;
	    res-=delta;
	}
    }
    return flow-res;
}
int dinic()
{
    int res=0,flow=0;
    while(bfs()) while(flow=dfs(s,INF)) res+=flow;
    return res;
}
int main()
{
    fio();
    gi(n),gi(m);
    for(int i=1;i<=m;++i) gi(u[i],v[i],w[i]);
    int l,ans=0;
    gi(s,t,l);
    cnt=1,ms(head);
    for(int i=1;i<=m;++i) if(w[i]<l) link(u[i],v[i],1),link(v[i],u[i],1);
    ans+=dinic();
    cnt=1,ms(head);
    for(int i=1;i<=m;++i) if(w[i]>l) link(u[i],v[i],1),link(v[i],u[i],1);
    ans+=dinic();
    print(ans);
    end();
}
```

---

## 作者：Elma_ (赞：0)

回顾 $\mathrm{kruskal}$ 的过程，一条边 $(u,v,w)$ 可能出现在最小生成树上，必须保证所有 $w$ 值小于该边的边加入图后 $(u,v)$ 仍然不连通。那么原题相当于询问最少删去几条边，使得 $(u,v)$ 无法通过边权小于 $L$ 的边连通（最大生成树同理）。

容易发现这是一个最小割问题，众所周知最大流等于最小割。将 $u,v$ 看做图的源点和汇点，对于所有边权小于 $L$ 的边 $(u',v')$ ，在图中连接两条容量为 $1$ 的边 $u' \to v'$ 和 $v' \to u'$，然后在这张图上跑最大流就是使得边 $(u,v,L)$ 可能出现在最小生成树上的答案，最大生成树同理。把两个答案加起来就行了（显然边权大于 $L$ 的边和边权小于 $L$ 的边不可能有交）。

```cpp
#define int long long
 
const int maxn = 1e6 + 5;
const int inf = 0x3f3f3f3f3f3f3f;

struct node {
    int nxt, to, flow;
} edge[maxn << 1];
int n, m, s, t, w, tot = 1, head[maxn];

inline void addedge(int u, int v, int w) {
    edge[++tot] = (node){head[u], v, w}, head[u] = tot;
}

int dep[maxn];
queue <int> q;

inline bool bfs(int s, int t) {
    for (int i = 1;i <= n;i++) dep[i] = 0;
    dep[s] = 1, q.push(s);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int i = head[u];i;i = edge[i].nxt) {
            int v = edge[i].to;
            if (edge[i].flow && !dep[v]) {
                dep[v] = dep[u] + 1;
                q.push(v);
            }
        }
    }
    return dep[t];
} 

int cur[maxn];

inline int dfs(int u, int rest = inf) {
    if (u == t) return rest;
    int flow = 0;
    for (int i = cur[u];i;i = edge[i].nxt) {
        cur[u] = i;
        int v = edge[i].to;
        if (edge[i].flow && dep[v] == dep[u] + 1) {
            int x = dfs(v, min(rest, edge[i].flow));
            edge[i].flow -= x;
            edge[i ^ 1].flow += x;
            rest -= x;
            flow += x;
        }
        if (!rest) break;
    }
    return flow;
}

inline int dinic(int s, int t) {
    int ans = 0;
    while (bfs(s, t)) {
        for (int i = 1;i <= n;i++) cur[i] = head[i];
        ans += dfs(s);
    }
    return ans;
}

struct Edge {
    int u, v, w;
} e[maxn << 1];
int ans;

signed main(void) {
    n = read(), m = read();
    for (int i = 1;i <= m;i++) {
        e[i].u = read(), e[i].v = read(), e[i].w = read();
    }
    s = read(), t = read(), w = read();
    for (int i = 1;i <= m;i++) {
        if (e[i].w < w) {
            addedge(e[i].u, e[i].v, 1), addedge(e[i].v, e[i].u, 0);
            addedge(e[i].v, e[i].u, 1), addedge(e[i].u, e[i].v, 0);
        }
    }
    ans += dinic(s, t);
    for (int i = 1;i <= n;i++) head[i] = 0;
    tot = 1;
    for (int i = 1;i <= m;i++) {
        if (e[i].w > w) {
            addedge(e[i].u, e[i].v, 1), addedge(e[i].v, e[i].u, 0);
            addedge(e[i].v, e[i].u, 1), addedge(e[i].u, e[i].v, 0);
        }
    }
    ans += dinic(s, t);
    printf("%lld\n", ans);
    return 0;
}
```


---


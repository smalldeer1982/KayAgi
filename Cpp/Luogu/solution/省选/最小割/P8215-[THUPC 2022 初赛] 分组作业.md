# [THUPC 2022 初赛] 分组作业

## 题目描述

老师布置了分组作业。在此之前，老师将班上 $2n$ 个学生分成了 $n$ 组，每组两个人。其中 $1$ 号和 $2$ 号为一组，$3$ 号和 $4$ 号为一组，……，$2n-1$ 号和 $2n$ 号为一组。

老师让每个队伍自行安排分工。这样是否合作就成了一个大问题。大家决定用表决的方式来确定。首先每个人决定是否愿意和队友合作。不同的人因为自己的原因和分配的队友的原因，对合作的意愿不一样，对于第 $i$ 个学生，选择“愿意”会产生 $c_i$ 的不满，选择“不愿意”会产生 $d_i$ 的不满。

如果两名队友都选择“愿意”，那么根据实际情况他们可以合作或者不合作。但是如果有一名队友选择“不愿意”，那么他们只能不合作。

学生中还有 $m$ 个单向的喜欢关系，一个关系形如“$A$ 喜欢 $B$”。在这样一个关系中，如果 $A$ 没有和队友合作，且 $B$ 选择了“愿意”，$A$ 会有略微沮丧，产生 $a_i$ 的不满；如果 $A$ 表决了“不愿意”，但 $B$ 成功与队友合作，那么 $A$ 会羡慕嫉妒恨并产生 $b_i$ 的不满。（由于当 $A$ 和 $B$ 在同一组时这种设定会变得很奇怪，所以题目保证不会有这种情况）其中 $i$ 表示第 $i$ 个关系。

如果一个学生 $i$ 选择了“愿意”但是他的队友选择了“不愿意”，那么他会因为队友产生 $e_i$ 的不满。

问所有情况下最小的不满之和是多少。

## 说明/提示

【数据范围】

保证 $1\le n \le 5000$，$0\le m \le 10000$，$1\le a_i,b_i,c_i,d_i,e_i\le 10^9$。

## 样例 #1

### 输入

```
2 1
8 6 7
5 2 8
7 1 5
6 5 8
1 4 4 3```

### 输出

```
14```

# 题解

## 作者：Exber (赞：16)

## 做法

最小割。

这是我第一次在赛场上做出有难度的网络流，写篇题解纪念一下。

赛后发现**我的建模方法和官方题解并不相同**，所以这篇题解也算是提供了一种新奇的建图思路吧。

首先**观察到每个人有两种选择：愿意和不愿意**。那么可以用源点表示愿意，汇点表示不愿意。具体就是**对第 $i$ 个人建立节点 $i$，然后从源点向 $i$ 连一条流量为 $d_i$ 的边，从 $i$ 向汇点连一条流量为 $c_i$ 的边**：

![](https://cdn.luogu.com.cn/upload/image_hosting/lcz0hk8f.png)

然后考虑同一组内的两个人 $x,y$ 意见不同（$x$ 选择了愿意）的情况，此时情况如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/eznq6i04.png)

因为会产生 $e_x$ 的不满，所以**从 $x$ 向 $y$ 连一条流量为 $e_x$ 的边来增加不满**。

对于 $y$ 选择了愿意但是 $x$ 选择了不愿意的情况亦然。

加上这些边之后的图如下：（两个奇奇怪怪的点是用来防止边权重叠的）

![](https://cdn.luogu.com.cn/upload/image_hosting/qxt14ja3.png)

接下来我们就需要解决最棘手的喜欢关系了。（赛场上想了 1h 左右/ll）

首先可以发现，只有一组里两个人都选择愿意才可以合作。所以**可以给每一组引入一个点 $x_i$，从 $x_i$ 分别向两个成员连流量为 $\inf$ 的边**：

![](https://cdn.luogu.com.cn/upload/image_hosting/mnqf3c2s.png)

这么连边的目的是，假设有一些流量送到了 $x_i$：

![](https://cdn.luogu.com.cn/upload/image_hosting/awfurcaq.png)

那么就**可以保证每一组如果不合作的话给 $x_i$ 送流量的边都要被割断，如果合作的话就不隔断，并且如果一组中有一个或以上人选择了不愿意那么就必须不合作**。换句话说，**$x_i$ 没有流量代表这一组不合作，否则代表这一组合作**。

现在我们可以表示合不合作了，接下来考虑喜欢关系的连边。

若第 $j$ 组关系是 $x_j$ 喜欢 $y_j$，**设 $u$ 表示 $x_j$ 那一组的 $x_i$，$v$ 表示 $y_j$ 那一组的 $x_i$**，那么：

如果 $x_j$ 没有和队友合作，并且 $y_j$ 选择了愿意，在图上就是 $y_j$ 有流量并且 $u$ 不能有流量。此时会产生 $a_j$ 的不满，那么我们可以**从有流量的 $y_j$ 向不能有流量的 $u$ 连一条流量为 $a_j$ 的边**。

如果 $x_j$ 选择了不愿意，并且 $y_j$ 和队友合作了，在图上就是 $x_j$ 连向汇点的边没有被割断并且 $v$ 有流量。此时会产生 $b_j$ 的不满，那么我们可以**从有流量的 $v$ 向可以到达汇点的 $x_j$ 连一条流量为 $b_j$ 的边**。

加上这些边后的图：（假设有一条喜欢关系：$2$ 喜欢 $3$）

![](https://cdn.luogu.com.cn/upload/image_hosting/objy4fqi.png)

这样我们就建完图了，跑最小割即可。

## AC 代码

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <queue>
#include <vector>
#include <map>
#include <set>

using namespace std;

struct node
{
};

typedef long long ll;

const ll S=5000005,MS=1000005;

int n,m,s,t;
int xid[MS];
int esum,to[S],nxt[S],h[MS];
ll c[S];
int dep[MS];

inline void init()
{
	esum=1;
	memset(h,0,sizeof(h));
	s=0;
	t=1000003;
}

inline void add(int x,int y,ll w)
{
	c[++esum]=w;
	to[esum]=y;
	nxt[esum]=h[x];
	h[x]=esum;
}

inline bool bfs()
{
	memset(dep,0,sizeof(dep));
	queue<int> q;
	q.push(s);
	dep[s]=1;
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		for(int i=h[u];i;i=nxt[i])
		{
			int v=to[i];
			if(c[i]>0&&dep[v]==0)
			{
				dep[v]=dep[u]+1;
				q.push(v);
			}
		}
	}
	return dep[t]!=0;
}

ll dfs(int u,ll w)
{
	if(u==t)
	{
		return w;
	}
	ll sum=0;
	for(int i=h[u];i;i=nxt[i])
	{
		int v=to[i];
		if(c[i]>0&&dep[v]==dep[u]+1)
		{
			ll re=dfs(v,min(w,c[i]));
			c[i]-=re;
			c[i^1]+=re;
			sum+=re;
			w-=re;
			if(w==0)
			{
				break;
			}
		}
	}
	if(sum==0)
	{
		dep[u]=0;
	}
	return sum;
}

inline ll dinic()
{
	ll ans=0;
	while(bfs())
	{
		ans+=dfs(s,1e17);
	}
	return ans;
}

inline void slove()
{
	scanf("%d%d",&n,&m);
	n*=2;
	init();
	for(int i=1;i<=n;i++)
	{
		ll C,D,E;
		scanf("%lld%lld%lld",&C,&D,&E);
		add(s,i,D);
		add(i,s,0);
		add(i,t,C);
		add(t,i,0);
		int v=(i&1)?i+1:i-1;
		add(i,v,E);
		add(v,i,0);
	}
	for(int i=1;i<=n;i+=2)
	{
		int u=n+(i+1)/2;
		add(u,i,1e17);
		add(i,u,0);
		add(u,i+1,1e17);
		add(i+1,u,0);
		xid[i]=u;
		xid[i+1]=u;
	}
	for(int i=1;i<=m;i++)
	{
		int x,y;
		ll a,b;
		scanf("%d%d%lld%lld",&x,&y,&a,&b);
		int u1=xid[y],v1=xid[x];
		add(u1,x,b);
		add(x,u1,0);
		add(y,v1,a);
		add(v1,y,0);
	}
	printf("%lld\n",dinic());
}

int main()
{
	int _=1;
//	scanf("%d",&_);
	while(_--)
	{
		slove();
	}
	return 0; 
}
```

---

## 作者：FjswYuzu (赞：11)

本题解重点讲解构图的思路，请着重留意括号内内容。

奇奇怪怪的题目，考虑网络流。这里没有一个人多次使用的情况，且求的是最小，那么考虑最小割。

假设没有「合作」这样复杂的状态。对于一个人，存在「同意」和「不同意」两种状态，我们二者只取其一。并且有一个额外的花费存在于组内，建立于一个人同意且另一个人不同意的基础上。

先考虑单一的一个人：一个人要么同意，要么不同意，我们就建出一个点表示人，并且这个点分别往前面和后面的某个点连了一条边，表示「同意」和「不同意」（注意到我并不知道这个边的实际意义），并且保证我们的实际方案中，只割掉其中的一条边（**一个人不可能同意也不同意**）。

然后考虑组内人与人之间的关系，一个人选择「同意」，割掉了代表同意的边，但是在另一个人「不同意」的情况下还是造成了一定的不满值，这个不满值代表的边从「源点到汇点经过组内第一个人的点的路径」到了「源点到汇点经过组内第二个人的点的路径」上。注意到第二个人选择的是「不同意」（**这代表连向后面的边，代表的意义绝不是「同意」**），那么我们之前一个人连向前后的点的边的意义就清晰了。连向前面的点的边，代表的是「不同意」，边权 $d_i$；连向后面的点的边，代表的是「同意」，边权 $c_i$。第 $i$ 个人连向组内另一个人的边代表 $i$ 选择「同意」但另一个人「不同意」造成的不满值，流量为 $e_i$（另一个人流向 $i$ 的边也是要加上的）。

然后考虑「合作」这个状态（**这个状态理应不同于二者同时「同意」的状态，因此之前无论是「同意」或者是「不同意」都不该被割掉**，不要被两者「同意」是「合作」的基础这一想法束缚）。我们将组内两个人「不同意」的边指向同一个点，该点（在之后记作 $i$ 组的同意点）向后面的某个点连一条边，流量为 $c_i+c_{i+1}$。这个后面的点表示二人「合作」时的状态（**我们将二者「同意」与「合作」两种状态分割开的标准是，最终进行一个可行的割，二者同意会使这个新点留在 $T$ 集，否则会留在 $S$ 集**）。

验证一下只有一组的情况：

- 如果两者「合作」：割掉了 $c_i+c_{i+1}$ 边；   
- 如果两者皆「不同意」：割掉了 $d_i,d_{i+1}$ 两条边；   
- 如果两者皆「同意」，但不「合作」：割掉了 $c_i,c_{i+1}$ 两条边；   
- 如果 $i$「同意」但 $i+1$「不同意」：割掉了 $c_{i},d_{i+1},e_i$ 两条边。

容易验证，上面的割法可以使 $S,T$ 不连通，且意义与题目符合。

在做完组的基础上继续弄组与组之间的关系，处理这个关系的难点在于不知道到底从谁指向谁。考虑一个「喜欢」关系 $A \to B$：

- $A$ 没有和队友合作（没有割掉 $c_i+c_{i+1}$ 边），且 $B$ 选择了愿意（割掉了 $c_i$ 边），会产生 $a_i$ 不满值；   
- $A$ 选择了不愿意（割掉了 $d_i$ 边），但 $B$ 和队友合作（割掉了 $c_i+c_{i+1}$ 边），会产生 $b_i$ 不满值。

先考虑第一部分：既然 $A$ 组中，我们没有割掉 $c_i+c_{i+1}$ 边（**这代表了 $A$ 这一组前面的边已经被割到源点不能从 $A$ 组到汇点**），那我们只能选择从 $B$ 到 $A$。其中边为从代表 $B$ 这个人的点连向 $A$ 组的同意点，流量为 $a_i$ 的边（不连向同意点后面的点的原因是，这样无论同不同意都要求割掉这个边，且放在同意点不影响意义，还有答案……？）。

第二部分类似：$B$ 组割掉了 $c_i+c_{i+1}$ 边，我们又不好从 $A$ 直接导向 $B$ 组任意一个点（放在 $B$ 组同意点前会导致这条边没有意义，已经不连通；放在后面与意义不符合，这个边按道理来说一定要割），那么又是从 $B$ 到 $A$。我们建一条 $B$ 组同意点指向代表 $A$ 这个人的点，流量为 $b_i$。正确性分析类似于上面。

但是其实上面的做法只是保证了割特定边集的意义是正确的，我可能会避免关系导致的不满值，而让一个人同时「同意」和「不同意」。但是一组里面，一个人要么「同意」要么「不同意」，我们让选择「同意」/「不同意」花一点巨额花费，最后减掉就好了。也就是说记 $c_i' = c_i + ∞,d_i' = d_i + ∞$，一样的建边。只是最后答案要减去 $2n \times ∞$。

可以说是集网络流千万套路的题目。图可以自己手画懒了。

只给出关键的建图代码。

```cpp
int main(){
	n=read(),m=read();
	S=3*n+1,T=S+1;
	for(LL i=1;i<=2*n;i+=2)
	{
		LL cx=read(),dx=read(),ex=read(),cy=read(),dy=read(),ey=read();
		addEdge(S,i,dx+der),addEdge(S,i+1,dy+der);
		addEdge(i,i+1,ex),addEdge(i+1,i,ey);
		addEdge(i,(i+1)/2+2*n,cx+der),addEdge(i+1,(i+1)/2+2*n,cy+der);
		addEdge((i+1)/2+2*n,T,cx+cy+2*der);
	}
	for(LL i=1;i<=m;++i)
	{
		LL A=read(),B=read(),a=read(),b=read();
		addEdge(B,(A+1)/2+2*n,a);
		addEdge((B+1)/2+2*n,A,b);
	}
	LL ans=0;
	while(bfs())	ans+=Dinic(S,inf);
	write(ans-2*n*der);
	return 0;
}
```

---

## 作者：Alex_Wei (赞：7)

> *I. [P8215 [THUPC2022 初赛] 分组作业](https://www.luogu.com.cn/problem/P8215)*
>
> [网络流与二分图](https://www.cnblogs.com/alex-wei/p/Network_Flow_and_Bipartite_Graph.html)。

裸的集合划分模型，比赛的时候竟然没想到。

考虑建出一张图求最小割。如果一个点最终与 $S$ 相连，表示同意，否则与 $T$ 相连，表示不同意。因此 $S\to i$ 连权值为 $d_i$ 的边，$i\to T$ 连权值为 $c_i$ 的边。

根据集合划分模型，我们可以用 $i\to j$ 权值为 $w$ 的边表示若 $i$ 同意且 $j$ 不同意，则代价加上 $w$。因此 $i$ 向与其同组的人连权为 $e_i$ 的边。

合作是本题的一大难点，但只要想到 **独立每个人的状态和每个组的合作状态**，问题就迎刃而解了。设组 $j$ 在最终的残量网络上与 $S$ 相连表示合作，与 $T$ 相连表示不合作。

首先，如果任何一个人 $i$ 不同意，其对应的组 $j$ 均不可以合作，那么 $j\to i$ 连权值为 $+\infty$ 的边，表示如果合作且 $i$ 不同意，则代价为 $+\infty$。

剩下来就好办了。对于每个关系 $A, B$，$B$ 向 $A$ 对应的组连边 $a_i$，表示若 $B$ 同意且 $A$ 没有合作则有 $a_i$ 的代价。同理，$B$ 对应的组向 $A$ 连边 $b_i$，表示若 $B$ 合作且 $A$ 不同意则有 $b_i$ 的代价。

对上述网络跑最大流即可。时间复杂度 $\mathcal{O}(\mathrm{maxflow}(3n, 8n + 2m))$。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e4 + 5;
const int M = 6e4 + 5;
struct graph {
	int cnt = 1, hd[N], nxt[M << 1], to[M << 1];
	long long lim[M << 1];
	void add(int u, int v, long long w) {
		nxt[++cnt] = hd[u], hd[u] = cnt, to[cnt] = v, lim[cnt] = w;
		nxt[++cnt] = hd[v], hd[v] = cnt, to[cnt] = u, lim[cnt] = 0;
	}
	int T, dis[N], cur[N];
	long long dfs(int id, long long res) {
		if(id == T) return res;
		long long flow = 0;
		for(int i = cur[id]; i && res; i = nxt[i]) {
			int it = to[i], c = min(lim[i], res);
			cur[id] = i;
			if(c && dis[id] + 1 == dis[it]) {
				long long k = dfs(it, c);
				flow += k, res -= k, lim[i] -= k, lim[i ^ 1] += k;
			}
		}
		if(!flow) dis[id] = -1;
		return flow;
	}
	long long maxflow(int S, int _T) {
		T = _T;
		long long ans = 0;
		while(1) {
			queue <int> q; 
			memset(dis, -1, sizeof(dis));
			q.push(S), dis[S] = 0;
			memcpy(cur, hd, sizeof(hd));
			while(!q.empty()) {
				int t = q.front(); q.pop();
				for(int i = hd[t]; i; i = nxt[i]) {
					int it = to[i];
					if(dis[it] == -1 && lim[i]) dis[it] = dis[t] + 1, q.push(it);
				}
			}
			if(dis[T] == -1) break;
			ans += dfs(S, 1e18);
		}
		return ans;
	}
} G;
int n, m, T;
int main() {
	cin >> n >> m, T = n * 3 + 1;
	for(int i = 1; i <= n * 2; i++) {
		int c, d, e;
		cin >> c >> d >> e;
		G.add(0, i, d), G.add(i, T, c);
		if(i & 1) G.add(i, i + 1, e);
		else G.add(i, i - 1, e);
		G.add(n * 2 + (i + 1 >> 1), i, 1e18);
	}
	for(int i = 1; i <= m; i++) {
		int A, B, a, b;
		cin >> A >> B >> a >> b;
		G.add(B, n * 2 + (A + 1 >> 1), a);
		G.add(n * 2 + (B + 1 >> 1), A, b);
	}
	cout << G.maxflow(0, T) << endl;
	return 0;
}
```

---

## 作者：Doubeecat (赞：6)

> [THUPC2022 初赛 I 分组作业](https://www.luogu.com.cn/problem/P8215)
>
> 班上 $2n$ 个学生分成了 $n$ 组，每组两个人。其中 $1$ 号和 $2$ 号为一组，$3$ 号和 $4$ 号为一组，……，$2n-1$ 号和 $2n$ 号为一组。
>
> 每个人决定是否愿意和队友合作，对于第 $i$ 个学生，选择“愿意”会产生 $c_i$ 的不满，选择“不愿意”会产生 $d_i$ 的不满。
>
> 如果两名队友都选择“愿意”，那么根据实际情况他们**可以合作或者不合作**。但是如果有一名队友选择“不愿意”，那么他们只能不合作。
>
> 如果一个学生 $i$ 选择了“愿意”但是他的队友选择了“不愿意”，那么他会因为队友产生 $e_i$ 的不满。
>
> 学生中还有 $m$ 个单向的喜欢关系，一个关系形如“$A$ 喜欢 $B$”。在这样一个关系中，有两种情况（其中 $i$ 表示第 $i$ 个关系，且保证 $A$ 和 $B$ 不在同一组）：
>
> - 如果 $A$ 没有和队友合作，且 $B$ 选择了“愿意”，$A$ 会有产生 $a_i$ 的不满
> - 如果 $A$ 表决了“不愿意”，但 $B$ 成功与队友合作，那么 $A$ 会产生 $b_i$ 的不满。
>
> 问所有情况下最小的不满之和是多少。
>
> $n \leq 5000,m \leq 10000$

<!--more-->

## 解题思路：

[~~场上这个题把队友演了，给队友磕个头~~](https://doubeecat.blog.luogu.org/yan-li-qian-ze-yan-yun-xing-wei)

我们先考虑分组的部分，首先确定这个题的模型要最小化不满，那就应该是最小割。

对每一组建图，每个人建一个点，每个组建一个点：

- 源点向每个人连一条容量为 $d_i$ 的边，表示不愿意
- 每个人向所在小组连一条容量为 $c_i$ 的边，表示愿意
- 每个小组再向每个人连一条容量为 $\text{INF}$ 的边，表示给选了愿意的一条回退的路（最小割建图经典方法）
- 两个人之间连边容量分别为 $e_x,e_y$ 表示一方愿意但是另一方不愿意
- 最后，每个小组向汇点连容量为 $c_i$ 的边，表示双方合作

如图（图源官方讲评 PPT）：

![image-20220316172451486](https://s2.loli.net/2022/03/16/KahX6YFiObIJ5m4.png)

这样的流一共有五种情况（图源官方讲评 PPT）：

![image-20220316172536632](https://s2.loli.net/2022/03/16/ZFwE8mQhHWnvXaU.png)

第一种情况是双方均不愿意，第二/三种情况是 $y/x$ 愿意但另一方不愿意。

这样我们就完成了没有喜欢关系的部分，喜欢关系的部分乍看之下需要拆点，实际上不用，对于一个喜欢关系我们可以这样建图：

- 从 $B$ 所在小组向 $A$ 连容量为 $b$ 边，表示 $A$ 不愿意但是 $B$ 合作了
- 从 $B$ 向 $A$ 所在小组连容量为 $a$ 边，表示 $A$ 没有成功合作但是 $B$ 愿意了。

这样我们就解决了本题。

## 代码：

```cpp
const int N = 5e6 + 10;

struct edge {
    int cap,flow;
}e[N];

vector <pii> G[N];

int n,m,s,t,tot = -1,dis[N],cur[N];
bool vis[N];

bool BFS() {
    memset(dis,0,sizeof dis);
    memset(vis,0,sizeof vis);
    queue <int> q;
    q.push(s);dis[s] = 0;vis[s] = 1;
    while (!q.empty()) {
        int x = q.front();q.pop();
        for (auto ed : G[x]) {
            int y = ed.first,num = ed.second;
            if (!vis[y] && e[num].cap > e[num].flow) {
                vis[y] = 1;
                dis[y] = dis[x] + 1;
                q.push(y);
            }
        }
    }
    return vis[t];
}

int DFS(int x,int res) {
    if (x == t || res == 0) return res;
    int now = 0;
    for (int& i = cur[x];i < G[x].size();++i) {
        pii ed = G[x][i];
        int y = ed.first,num = ed.second;
        if (dis[x] + 1 == dis[y]) {
            int f = DFS(y,min(res,e[num].cap - e[num].flow));
            if (f > 0) {
                e[num].flow += f;
                e[num ^ 1].flow -= f;
                now += f;
                res -= f;
                if (!res) break;
            }
        }
    }
    return now;
}

int maxflow() {
    int ans = 0;
    while (BFS()) {
        memset(cur,0,sizeof cur);
        ans += DFS(s,0x3f3f3f3f3f3f3f3fLL);
    }
    return ans;
}

void addedge(int x,int y,int w) {
    G[x].push_back(mp(y,++tot));
    e[tot].cap = w;e[tot].flow = 0;
    G[y].push_back(mp(x,++tot));
    e[tot].cap = 0;e[tot].flow = 0;
}

signed main() {
    read(n,m);
    s = 0,t = 3 * n + 1; 
    for (int i = 1;i <= 2*n;++i) {
        int c,d,E;read(c,d,E);
        addedge(s,i,d);
        addedge(i,2 * n + ((i + 1) >> 1),c);
        addedge(2 * n + ((i + 1) >> 1),i,0x3f3f3f3f3f3f3f3fLL);
        addedge(2 * n + ((i + 1) >> 1),t,c);
        addedge(i,(i % 2 ? i + 1 : i - 1),E);
    }
    for (int i = 1;i <= m;++i) {
        int x,y,a,b;read(x,y,a,b);
        addedge(2 * n + ((y+1) >> 1),x,b);
        addedge(y,2 * n + ((x+1) >> 1),a);
    }
    printf("%lld\n",maxflow());
	return 0;
}
```



---

## 作者：Celtic (赞：3)

来一发和官方题解不一样的做法

还是最小割。

把每个点拆成 $4$ 个点，分别表示选择不愿意，愿意但不和队友合作和不愿意和一个没用的点（因为要 $3$ 条边）。

源点向不愿意，没用点向汇点分别连 $\inf$ 的边。
中间连上表示权值的边，割掉表示选择这个状态。

然后我们对合作的条件做限制，就是队友不能一个选择合作一个不合作，做法就是在上下两个表示合作的点之间连上边权为 $\inf$ 的双向边，这样如果一个合作一个不合作就会割掉这条边让答案不优。

再处理 $e_i$ ，就是队友之间一个愿意一个不愿意产生的价值，同理在两个表示愿意的点之间连流量为 $e_i$（反向边为 $e_{i+1}$）的边。

对于 A 喜欢 B，首先考虑 B 愿意且 A 未合作，就从 B 的愿意点向 A 的合作点连边权为 $a$ 的边，这样如果上面这个条件满足的话源点就会从 B 到 A 流到汇点 使图连通，这条边就要割掉。

然后考虑 A 不愿意且 B 合作，同理从 B 的合作向 A 的愿意点连边权为 $b$ 的边。

但是这个建法有一个问题，就是可能会在同一个人割两条边使得答案更优。

这个时候有个骚操作就是把同一行的反向边全都设成 $\inf$ 就行了（证明见文末）。

图大概长这个样子
![](https://cdn.luogu.com.cn/upload/image_hosting/expvnsub.png)

$\sf{Code}$

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<cstdlib>
#include<queue> 
#define eps 1e-10
#define re register
#define N 2001001
#define MAX 2001
#define PI acos(-1)
#define inf 1e18
using namespace std;
typedef long long ll;
typedef double db;
const ll P=1e9+6;
inline void read(re ll &ret)
{
    ret=0;re ll pd=0;re char c=getchar();
    while(!isdigit(c)){pd|=c=='-';c=getchar();}
    while(isdigit(c)){ret=(ret<<1)+(ret<<3)+(c^48);c=getchar();}
    ret=pd?-ret:ret;
}
ll m,s,t,dep[N],cnt=-1;
ll x,y,z,head[N];
struct edge
{
    ll from,to,dis,nxt;
}e[N];
inline void add(re ll x,re ll y,re ll z)
{
    e[++cnt].from=x;
    e[cnt].to=y;
    e[cnt].dis=z;
    e[cnt].nxt=head[x];
    head[x]=cnt;
    return;
}
inline bool bfs()
{
    memset(dep,0,(t+1)*sizeof(ll));
	queue<ll>q;
	q.push(s);
	dep[s]=2;
	while(!q.empty())
	{
		re ll ver=q.front();
		q.pop();
		for(re int i=head[ver];i!=-1;i=e[i].nxt)
		{
		    re int to=e[i].to,dis=e[i].dis;
		    if(dis&&!dep[to])
		    {
		        dep[to]=dep[ver]+1;
		        q.push(to);
		    }
		}
	}
	return dep[t];
}
inline ll dfs(re ll ver,re ll lim)
{
    if(ver==t)
        return lim;
    re ll ans=0;
    for(re int i=head[ver];i!=-1&&lim;i=e[i].nxt)
    {
        re ll to=e[i].to,dis=e[i].dis;
        if(dis&&dep[to]==dep[ver]+1)
        {
            re ll ret=dfs(to,min(lim,dis));
            e[i].dis-=ret;
            e[i^1].dis+=ret;
            lim-=ret;
            ans+=ret;
        }
        if(!lim)
            break;
    }
    if(!ans)
        dep[ver]=0;
    return ans;
}
inline ll dinic(re ll s,re ll t)
{
    re ll ret=0;
    while(bfs())
    	ret+=dfs(s,inf);
    return ret;
}
ll n,a[N],b[N],c[N],d[N],E[N],A,B;
signed main()
{
    memset(head,-1,sizeof(head));
	read(n);
	read(m);
	s=0,t=8*n+1;
	for(int i=1;i<=(n<<1);i++)
	{
		add(s,i,inf);
		add(i,s,inf);
	}
	for(int i=1;i<=(n<<1);i++)   
	{
		read(c[i]),read(d[i]),read(E[i]);
		add(i,i+n*2,d[i]);
		add(i+n*2,i,inf);
		add(i+n*2,i+(n<<1)*2,c[i]);
		add(i+(n<<1)*2,i+n*2,inf);
		add(i+(n<<1)*2,i+n*3*2,c[i]);
		add(i+n*3*2,i+n*2*2,inf);
		add(i+n*3*2,t,inf);
		add(t,i+n*3*2,inf);
	}
	for(int i=1;i<=n*2;i+=2)
	{
		add(i+n*2*2,i+1+n*2*2,inf);
		add(i+1+n*2*2,i+n*2*2,inf);
		add(i+n*2,i+1+n*2,E[i]);
		add(i+1+n*2,i+n*2,E[i+1]);
	}
	for(int i=1;i<=m;i++)
	{
		read(A),read(B),read(a[i]),read(b[i]);
		add(B+n*2*2,A+n*2,b[i]);
		add(A+n*2,B+n*2*2,0);
		add(B+n*2,A+n*2*2,a[i]);
		add(A+n*2*2,B+n*2,0);
	}
	printf("%lld\n",dinic(s,t));
    exit(0);
}
```

关于上面提到的骚操作的证明：

假设割完形成的两个集合分别为 $S,T$。

那么割掉的边一定是所有 $S,T$ 之间的边（因为在同一个集合内部割的边是不必要的）

那么如果在同一行割了两条边，这行就一定存在一条从 $T$ 集合到 $S$ 集合的边（不然是怎么回来的）

这时由于我们把反向边设为了 $\inf$，$S$ 到 $T$ 就一定有一条 $\inf$ 边被割掉，而这显然是不优的。

这种操作能解决一条路径上只能割一条边的问题。

---

## 作者：mqmhaaaa1 (赞：2)

这是我近期来做的比较有意思的网络流题了，想的时候好几次错过正解，最后脑子一掰想明白了 ~~（绝对不是我把选和不选搞反了）~~

做这道题建议先对最小割有充足的认识，先把像小 M 的作物这类经典的贡献计算问题搞懂再说。



---



# 正片

对于一个人**同意**或**不同意**，我们首先能想到最小割，我在这里以选源点 $s$ 集合代表同意，选汇点 $t$ 集合代表不同意。



---



## part1 个人的同意与不同意

我们首先搞明白，贡献到底是什么 ~~绝对不是因为我在这上面搞了半小时~~。按最小割套路，我们把每个人看做一个点，由 $s$ 向每个点连边，再由每个点向 $t$ 连边。

至于边权，想明白，我们把不满值转化为贡献的思想。当同意时，他会获得 $d_i$（不同意的不满值）的贡献，反之，不同意时，会获得 $c_i$（同意的不满值）的贡献。按这个设边权就行。



---



## part2 队内选择不同产生的不满值

下一步是对于组内两人选择不同所产生的不满值 $e_i$，这个比上面还简单。会最小割就知道，两人选择不同时，必有一个人没割 $s$ 的边，一个人没割 $t$ 的边，我们只需要在两点间连边就必定产生 $s \to t$ 的路径，我们就需要再割边，可以用这一点来计算两人选择不同的不满值。

不懂看图（这个 jb 是用来更清楚的看边的）。

![](https://cdn.luogu.com.cn/upload/image_hosting/4klnekz4.png)



---



## part3 喜欢关系（重点

接下来是不一样的部分，**喜欢关系**。

这个初看真是令人头大（削除走路人同款），事实上只要对最小割计算贡献足够熟悉就能想明白。

对于每个 $A$ 喜欢 $B$，有两种产生贡献的方式：

1. $A$ 的队伍不合作，但 $B$ 表决**同意**，产生 $a$ 的不满。

2. $A$ 表决**不同意**，但 $B$ 的队伍合作，产生 $b$ 的不满。



---



### 小 part 合作关系

对很多人不好想的是怎么表达**合作**关系，事实上很简单。参考小 M 的作物那类划分题，当两人都处于 $s$ 集合，就先**假定为合作关系**，那么我们对每个队伍建立虚点，虚点向对内成员连容量 $inf$ 的边表示只有两个都处于 $s$ 集合才会**合作**。（这里没有像其他划分问题那样由 $s$ 向他连边是因为**合作**关系本身没有贡献）

图就不画了（很基础）。

---

再回到上面的喜欢关系，这两种情况就可以这样表示（设 $Ax$ 为 $A$ 所在组的虚点，$B$ 同理）：

1. 当 $Ax$ 没有被选到 $s$ 集合且 $B \to t$ 的边被割了。

2. 当 $s \to A$ 的边被割了且 $Bx$ 被选到了 $s$ 集合。

接下来我们就可以像是处理**组内选择不同**关系那样，在这两点间建一条边使得出现一条新的 $s \to t$ 的路径，新的边需要被割掉或换一种割边方式才保证不存在 $s \to t$ 的路径。

具体建图如下

1. 连 $B \to Ax$ 容量为 $a$。

2. 连 $Bx \to A$ 容量为 $b$。

总体建出来的图大概这样（$2$ 喜欢 $4$）：

![](https://cdn.luogu.com.cn/upload/image_hosting/85gf7cwd.png)

有点乱别见谅

这时，会有很多人有一个疑问：及时一个组内都**同意**，那么是不是也可以不**合作**以此抚慰某些舔狗的心减少不满值呢？

这就是为什么我建图时说的是**假定**。当一个虚点 $x$ 在图中没有流量能进入时，自然说明选到 $s$ 集合中产生的**合作**关系是**无贡献**的，也就是说，**它不会参与到 $s \to t$ 路径中**，自然在跑最小割的过程中不会管这个点，相当于爱 jb 选哪个选哪个。当这个点能完整地流出流量与流入流量时，说明它真正的**参与**到了 $s \to t$ 的路径中，**产生了贡献**，这时会在最小割过程中为该点划分集合。在本题中，每个虚点就是这样被选在 $s$ 或 $t$ 集合中的。

说完长篇大论，看看代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
void write(ll x) {static ll sta[35];ll top = 0;do {sta[top++] = x % 10, x /= 10;} while (x);while (top) putchar(sta[--top] + 48);}
ll read() {ll x = 0, w = 1;char ch = 0;while (ch < '0' || ch > '9') {  if (ch == '-') w = -1;ch = getchar();}while (ch >= '0' && ch <= '9') {x = x * 10 + (ch - '0'); ch = getchar(); }return x * w; }
const ll N=1e5+10,M=5e6+10,inf=0x3f3f3f3f3f3f3f3f;
ll to[M<<1],nxt[M<<1],w[M<<1],bh[N],tot=1;
ll head[N],st[N];
bool vis[N];
inline void add(ll u,ll v,ll z){
	to[++tot]=v;
	nxt[tot]=bh[u];
	w[tot]=z;
	bh[u]=tot;
//	cout<<u<<" "<<v<<" "<<z<<'\n';
	to[++tot]=u;
	nxt[tot]=bh[v];
	w[tot]=0;
	bh[v]=tot;
}
ll s,t;
inline bool bfs(){
	for(ll i=s;i<=t;i++){
		head[i]=bh[i];
		vis[i]=0;
		st[i]=0;
	}
	queue<ll>q;
	q.push(s);
	st[s]=0;vis[s]=1;
	while(q.size()){
		ll u=q.front();q.pop();
//		cout<<u<<'\n';
		vis[u]=0;
		for(ll i=bh[u];i;i=nxt[i]){
			ll v=to[i];
			if(w[i]&&!st[v]&&v!=s){
				st[v]=st[u]+1;
				if(!vis[v]){
					vis[v]=1;
					q.push(v);
				}
			}
		}
	}
	return st[t];
}
ll mxf=0;
ll dic(ll u,ll flow){
//	cout<<u<<" "<<flow<<'\n';
	vis[u]=1;
	if(u==t){
		mxf+=flow;return flow;
	}
	ll zy=0;
	for(ll i=head[u];i&&flow;i=nxt[i]){
		ll v=to[i];head[u]=i;
		if(w[i]&&(!vis[v]||v==t)&&st[v]==st[u]+1){
			ll jb=dic(v,min(w[i],flow));
			w[i]-=jb,w[i^1]+=jb;
			zy+=jb;flow-=jb;
			if(!flow)break;
		}
	}
	vis[u]=0;
	return zy;
}//优质のdinic 
ll n,m,rn;
inline ll lyg(ll u){
	return (u%2)?u+1:u-1;
}//求这个队伍中另一个人（不过没什么用 
int main(){
	n=read(),m=read();
	rn=2*n;
	s=0;t=rn+n+1;
	for(ll i=1;i<=n;i++){
		ll u=i*2-1;
		ll x=rn+i;
		ll c=read(),d=read(),e=read();
		add(s,u,d),add(u,t,c);
		add(u,lyg(u),e);
		add(x,u,inf);
		
		u=i*2;
		c=read(),d=read(),e=read();
		add(s,u,d),add(u,t,c);
		add(u,lyg(u),e);
		add(x,u,inf);
	}//不良码风不要学 
	for(ll i=1;i<=m;i++){
		ll u=read(),v=read(),a=read(),b=read();
		ll ux=rn+(u+1)/2,vx=rn+(v+1)/2;
		add(v,ux,a);
		add(vx,u,b);
	}
	while(bfs()){
		vis[t]=1;
		while(vis[t]){
			memset(vis,0,sizeof vis);
			dic(s,inf);
		}
	}
	cout<<mxf;//本题求的就是最小割 
}

```

这是我写的最长的题解了，写到十点半连打歌时间都没有了，对了，还有 ave mujika 更新。

---

## 作者：望月Asta (赞：2)

## 题意

状态：

- 有 $2n$ 个人，按照 $(1,2),(3,4),\cdots,(n-  1,n)$ 的顺序分成 $n$ 组。 
- 每个人处于两种状态之一：愿意、不愿意。
- 一组两个人都愿意时可以选择合作或不合作，两人有任意一个不愿意都不可合作。

代价：

- 第 $i$ 个人选择愿意代价为 $c_i$，选择不愿意代价为 $d_i$，$i$ 选愿意 $i$ 的队友选不愿意代价为 $e_i$。
- 有 $m$ 个四元组 $(A,B,a,b)$ 代表：
  - $A$ 和 $A$ 的队友 **不合作**（任意一人不愿意或者都愿意且选择不合作）且 $B$ 选择 **愿意**，付出 $a$ 的代价。
  - $B$ 和 $B$ 的队友 **合作** （都选择愿意且选择愿意合作）且 $A$ 选择不愿意，付出 $b$ 的代价。

给定上述的 $n,m,c,d,e$ 和 $(A,B,a,b)$，最小化代价。

## 解法

首先考虑只有 $c,d,e$ 这三个条件时如何最小化代价，可以转化为网络流模型，使用最小割解决。

每个人分配一个点，令与源点连通的点集表示不愿意合作，与汇点连通的点集表示愿意合作，那么与源点连通需要割与汇点相连的边，此时需要付出代价 $d_i$，也就是 $[1,2n]$ 每个点向汇点连一条容量 $d_i$ 的边，同理，源点向每个点连一条容量 $c_i$ 的边。

如果一队人 $(u,v)$ 中 $u$ 与源点连通，$v$ 与汇点连通需要付出 $e_v$ 的代价，那么从 $u$ 到 $v$ 连一条容量为 $e_v$ 的边，从 $v$ 向 $u$ 连一条容量为 $e_u$ 的边。

然后考虑把是否合作这一部分加入模型，首先建立 $n$ 个虚点代表 $n$ 个组是否愿意合作。

虚点与源点连通表示不合作，与汇点连通表示合作，这样一组两点任意一个不愿意都必须选择不合作，为了先割表示代价的边， 源点向 $n$ 个虚点连无限流边，虚点向汇点连无限流边。

由于 $n$ 个虚点与源汇都相连需要多割 $n \times \inf$，最后减去即可。

以下令 $PA$ 表示 $A$ 的队友点，$PB$ 表示 $B$ 的队友点，$WA$ 表示 $A$ 所在那一组是否合作的虚点，$WB$ 表示 $B$ 所在那一组是否合作的虚点。

### 代价 $a$ 情况一

此时 $B$ 选择愿意，$A$ 与 $PA$ 有任意一个不愿意或者都愿意且不合作。

即 $B$ 与汇点相连，$WA$ 连源点：

此时我们从 $A,PA$ 向 $WA$ 连无限流的边防止被割，从 $WA$ 向 $B$ 连一条容量为 $a$ 的边。

![](https://cdn.luogu.com.cn/upload/image_hosting/m4dpainh.png)

### 代价 $b$

此时 $A$ 选择不愿意且 $B$ 和 $PB$ 合作。

即 $A$ 与源点连通，$B,PB$ 均与汇点连通且 $WB$ 连汇点。

从 $A$ 向 $WB$ 连一条容量为 $b$ 的边。

![](https://cdn.luogu.com.cn/upload/image_hosting/xitvgn20.png)

## 代码

最大流部分记得开 `long long`，以及 `INF` 开大一点。

```cpp
int main() {
    memset(head,-1,sizeof(head));
	int n = read(),m = read(),cnt = n << 1;
	s = ++cnt,t = ++cnt;
	rep(i,1,(n << 1)) {
		int c = read(),d = read(),e = read();
		int pi = (i & 1) ? i + 1 : i - 1;
		AddEdge(s,i,c),AddEdge(i,t,d);
		AddEdge(pi,i,e);
	}
	rep(i,1,n) {
		co[i] = ++cnt;// 虚点编号
		AddEdge(s,co[i],INF);
		AddEdge(co[i],t,INF);
		AddEdge((i << 1) - 1,co[i],INF);
		AddEdge((i << 1),co[i],INF);
	}
	rep(i,1,m) {
		int A = read(),B = read(),a = read(),b = read();
		int WA = co[(A + 1) >> 1],WB = co[(B + 1) >> 1];
		AddEdge(WA,B,a);
		AddEdge(A,WB,b);
	}
	write(dinic() - (ll)n * INF),enter;
    return 0;
}
```

---

## 作者：xiezheyuan (赞：1)

[也许有更好的阅读体验](https://www.xiezheyuan.xyz/hnoi2025camp/graph/p8215.html)。

## 简要题意

有 $2n$ 个人，第 $2k-1$ 个人和第 $2k$ 个人为一组（$k\in\mathbb{Z}_+$）。

每个人可以选择是否愿意合作，第 $i$ 个人选择愿意需要 $c_i$ 的代价，选择不愿意需要 $d_i$ 的代价，选择愿意但队友选择不愿意需要 $e_i$ 的额外代价。若两个人愿意合作，则可以选择合作或不合作。

有 $m$ 条单向关系，每条形如 $(A,B,a,b)$（保证 $A,B$ 互不为队友），表示：

- 若 $A$ 未与队友合作，且 $B$ 选择愿意合作，代价为 $a$。
- 若 $A$ 选择不愿意合作，且 $B$ 与队友合作，代价为 $b$。

求最小可能的代价总和。

$1\leq n\leq 5\times 10^3,0\leq m\leq 10^4$。

## 思路

最小割建模 trick 多合一。

首先如果没有“选择合作或不合作”一说，那么可以考虑下面一个建图（我们使用 $A_1,A_2$ 表示一组的两个组员）：

![](https://cdn.luogu.com.cn/upload/image_hosting/euk9tv7i.png)

这个建模是十分经典的，将一个代表人的点划归 $c(S)$ 表示愿意合作，$c(T)$ 表示不愿意合作，如果同一组的两个人意愿不同，则必须割断 $A_1,A_2$ 间的某一条边。

现在我们需要加上选择合作的情况。由于选择合作必须两人都愿意合作，因此自然想到在 $T$ 一边扩展：

![](https://cdn.luogu.com.cn/upload/image_hosting/89xxgb98.png)

我们添加一个点 $A$。此时将 $A$ 划归 $c(S)$ 表示选择合作，否则表示不选择合作。如果不选择合作且 $(A_x,A)$ 在割集中，则表示 $A_x$ 愿意合作，否则不愿意。不过这要有一点小问题，我们会不会同时割断 $(S,A_1),(A,T)$？你发现这是有可能的！但这是不合法的，因为如果 $A_1$ 不愿意合作，则不可能选择合作，因此我们需要连接两条辅助边：

![](https://cdn.luogu.com.cn/upload/image_hosting/pja5txcq.png)

连边 $(A,A_1, \infty),(A,A_2,\infty)$ 相当于强制钦定不可能出现 $A$ 归属 $c(S)$，$A_1,A_2$ 归属 $c(T)$ 的情况，规避了上述不可能的情况。

现在来考虑单向关系。这里我们假设单项关系为 $(A_2,B_1,a,b)$。

对于【若 $A_2$ 未与队友合作，且 $B_1$ 选择愿意合作，代价为 $a$。】的情况，我们需要连边 $(B_1, A, a)$。这表示若 $B_1$ 位于 $c(S)$（即愿意合作），且 $A$ 位于 $c(T)$（即未合作）需要割断这条边。

同理，【若 $A_2$ 选择不愿意合作，且 $B_1$ 与队友合作，代价为 $b$】的情况，需要连边 $(B, A_1, b)$。

![](https://cdn.luogu.com.cn/upload/image_hosting/35e3ykwp.png)

时间复杂度 $O(\mathrm{maxflow}(n, n+m))$，[Submission in QOJ](https://qoj.ac/submission/1064124)。

PS：[Google Gemini 2.5 Pro 提出了一个看起来可行的方法，不过太复杂了](https://g.co/gemini/share/5f5b6946ad97)。

---

## 作者：Filberte (赞：1)

很全面的一个网络流练习题。“每个同学要么选择愿意产生 $c_i$ 的不满，要么不愿意产生 $d_i$ 的不满”，这样的表达，启示我们从集合划分模型以及最小割模型这个角度思考本题。

建立源点 $s$，汇点 $t$，已经每个人对应一个点 $i$，每个组对应一个点 $g_i$。从 $s$ 向每个点 $i$ 连一条容量为 $d_i$ 的边，从每个点 $i$ 向 $t$ 连接一容量为 $c_i$ 的边。此时若网络中 $s$ 可以到达 $i$（下文称 $i\in S$），则表示一定割断了 $i\rightarrow t$ 的边，表示 $i$ 同学愿意合作。同理，若 $i$ 可以到达 $t$（下文称$i\in T$），表示 $i$ 同学不愿意合作。如果 $i$ 愿意合作且 $i$ 的合作伙伴 $j$ 不愿意，则 $i$ 会产生 $e_i$ 的不满，因此从 $i$ 向 $j$ 连一条容量为 $e_i$ 的边。也就是当 $i\in S,j\in T$ 的时候，需要花额外 $e_i$ 的代价来保证 $s$ 无法到 $t$，否则就会存在路径 $s\rightarrow i\rightarrow j\rightarrow t$。

现在考虑喜欢关系的问题。我们为每两个人增设一个点 $g_x$，表示他们合作与否。若最终 $g_i \in S$，则表示合作，否则表示不合作。但只要两人有一人不愿意，他们就无法合作。因此由 $g_x$ 向对应的两个人 $i,j$ 分别连一条容量为 $+\infin$ 的边，表示 $g_x \in S$ 而 $(i\in T$ 或 $j \in T)$ 这样的情况不能发生。若 $B$ 愿意且 $A$ 没有合作，对应 $B \in S$ 和 $g_A \in T$，需要额外 $a_i$ 代价，因此由 $B$ 向 $g_A$ 连一条容量为 $a_i$ 的边，同理由 $g_B$ 向 $A$ 连一条容量为 $b_i$ 的边。

最后在上述网络上求出最小割即可。

```c++
#include <bits/stdc++.h>
using namespace std;
namespace MF{
    #define int_64 long long
    static const int maxn = 15500;
    static const int maxm = 3e5;
    const int_64 Mxf = 1e18;
    struct E{int to, nxt;int_64 f;}e[maxm];
    int hd[maxn], cur[maxn], _te = 1;
    void add_edge(int u, int v, int_64 w){
        e[++_te] = {v, hd[u], w};hd[u] = _te;  
        e[++_te] = {u, hd[v], 0};hd[v] = _te;
    }
    int nods, s, t;
    int_64 maxf = 0;
    int d[maxn];
    bool bfs(){
        for(int i = 0;i <= nods;i++) d[i] = 0, cur[i] = hd[i];
        queue<int> q;q.push(s);d[s] = 1;
        while(!q.empty()){
            int u = q.front();q.pop();
            for(int i = hd[u];i;i = e[i].nxt){
                int v = e[i].to;
                if(e[i].f && !d[v]){
                    d[v] = d[u] + 1;
                    q.push(v);
                    if(v == t) return 1;
                }
            }
        }
        return 0;
    }
    int_64 dfs(int u, int_64 flow){
        if(u == t) return flow;
        int_64 sum = 0;
        for(int &i = cur[u];i;i = e[i].nxt){
            int v = e[i].to;
            if(e[i].f && d[v] == d[u] + 1){
                int_64 gt = dfs(v, min(e[i].f, flow));
                e[i].f -= gt, e[i ^ 1].f += gt;
                sum += gt, flow -= gt;
            }
        }
        if(!sum) d[u] = 0;
        return sum;
    }
    void dinic(){
        while(bfs()) maxf += dfs(s, Mxf);
    }
}
using namespace MF;
int n, m;
int g(int x){return (x + 1) / 2 + 2 * n;}
int main(){
    cin >> n >> m;
    nods = 3 * n + 1, s = 0, t = nods;
    for(int i = 1;i <= 2 * n;i++){
        int x, y, z;
        cin >> x >> y >> z;
        add_edge(s, i, y);
        add_edge(i, t, x);  
        add_edge(i, (i & 1) ? i + 1 : i - 1, z);
        add_edge(g(i), i, Mxf);
    } 
    for(int i = 1;i <= m;i++){
        int u, v, x, y;
        cin >> u >> v >> x >> y;
        add_edge(v, g(u), x);
        add_edge(g(v), u, y);
    }
    dinic();
    cout << maxf << endl;
}
```

---

## 作者：RedreamMer (赞：1)

## 思路

关系比较多，但是发现都可以用最小割模型表示出来，注意两人都愿意不代表必须合作。

建 $2$ 类点，分别表示每个人和每个队伍是否合作。

对于第一类点，设 $S$ 表示源点，$T$ 表示终点，$x$ 和 $y$ 组队：

+ 割 $(x, T)$ 表示 $x$ 愿意合作代价。

+ 割 $(S, x)$ 表示 $x$ 不愿意合作代价。

+ 割 $(x, y)$ 表示 $x$ 愿意合作而 $y$ 不愿意合作代价。

对于第二类点，设 $n$ 为 $x$ 和 $y$ 的队伍：

+ 割 $(n, x), (n, y)$ 代价为 $\text{inf}$，若表示 $x, y$ 合作，那两人必须都愿意。

对于 $A$ 喜欢 $B$ 的条件，令 $n$ 为 $A$ 的队伍，$m$ 为 $B$ 的队伍，满足：

+ 割 $(B, n)$ 表示 $B$ 愿意，但 $A$ 没合作代价。

+ 割 $(m, A)$ 表示 $B$ 组队，但 $A$ 不愿意代价。

## 代码

```cpp
int a, b;
int id(int n) {return (n + 1) / 2 + a * 2;}

signed main() {
	// freopen("in2.in", "r", stdin);
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> a >> b;
	F.init();
	const int S = 3 * a + 1, T = 3 * a + 2;
	F.S = S, F.T = T;
	int x, y, z, w;
	rep(i, 1, a * 2) {
		cin >> x >> y >> z;
		F.add(i, T, x), F.add(S, i, y), F.add(i, i & 1 ? i + 1 : i - 1, z);
	}
	rep(i, 1, a) F.add(i + a * 2, i * 2 - 1, inf), F.add(i + a * 2, i * 2, inf);
	rep(i, 1, b) {
		cin >> x >> y >> z >> w;
		F.add(y, id(x), z), F.add(id(y), x, w);
	}
	cout << F.dinic();
	return 0;
}
```

---

## 作者：sangshang (赞：0)

# Description

有 $n$ 个分组，每个分组有两人。每个人可选择愿意合作或不愿意合作，分别产生 $c_i$ 和 $d_i$ 的不满。若第 $i$ 人选愿意，但队友不愿意，又会产生 $e_i$ 的不满。只有两人都选愿意时，才能选择合作或不合作，否则只能不合作。

有 $m$ 个喜欢关系。如 $A$ 喜欢 $B$。如果 $A$ 没有和队友合作，且 $B$ 选择了“愿意”，$A$ 会有略微沮丧，产生 $a_i$ 的不满；如果 $A$ 表决了“不愿意”，但 $B$ 成功与队友合作，那么 $A$ 会羡慕嫉妒恨并产生 $b_i$ 的不满。

求最小不满总和。

# Solution

这题可以说是大多是网络流建模套路的综合。考虑最小割模型。做之前建议先做[小 M 的作物](https://www.luogu.com.cn/problem/P1361)。

为表示愿意或不愿意这种二选一的关系，使用“串联电路”。从源点向代表第 $i$ 人的点连一条容量为 $d_i$ 的边，将其割掉表示让第 $i$ 人选不愿意。从代表第 $i$ 人的点向汇点连一条容量为 $c_i$ 的边，将其割掉表示愿意。两条边必须且只会割掉其中一条边。

第 $i$ 人选择愿意时，源点可以到达代表他的点；选择不愿意时，代表他的点可到达汇点。据此性质，从代表第 $i$ 人的点向代表他的队友的点连一条容量为 $e_i$ 的边，表示他选愿意，但队友不愿意时多产生的不满。

现在的问题就是设计一种“开关”，表示是否合作。因为只有两人都愿意才能选择合作或不合作，否则只能不合作。所以对于第 $i$ 队，虚拟一个点，从此点向代表本队的两人的点分别连一条容量为 $+\infty$ 的边。从源点向此虚拟的点连一条容量为 $+\infty$ 的边，从此虚拟点向汇点连一条容量为 $+\infty$ 的边。注意，这里的 $+\infty$ 并不是绝对的无限，是可计算的，不过比题目中的数据规模大很多。这样，虽然一定要割掉两条容量为 $+\infty$ 中的一条，但不论在任意情况下，只要割掉其中一条就够了，又因为两边容量一样，所以并不影响求出最优解，只需要最后输出答案时减去此费用即可，这是本题建模比较新颖的一点。只有当本队两人都愿意时，才可选择割掉从虚拟点到汇点的边，表示合作，或割掉从源点到虚拟点的边，表示不合作；否则只能割掉从源点到虚拟点的边，表示不合作。

注意，要再虚拟一点，夹在表示是否合作的点与汇点的连边上，后面有关合作的边都与此点相连，为的是防止有关合作的边影响到代表队员的点，导致求出错误答案。

对于一个喜欢关系，$A$ 喜欢 $B$，当 $A$ 没有和队友合作时，代表合作的点可以到达汇点；当 $B$ 选择愿意时，源点可以到达代表 $B$ 的点。因此，从代表 $B$ 的点向 $A$ 所在分组代合作的点连容量为 $a_i$ 的边。同理，$B$ 成功合作时，源点可以到达 $B$ 所在分组代表合作的点，$A$ 选不愿意时，代表 $A$ 的点可以到达汇点。所以从 $B$ 所在分组代表合作的点，向代表 $A$ 的点连容量为 $b_i$ 的边。

最后求出的最小割，减去 $+\infty \times n$ 就是实际最小不满。记得开 `long long`。

# C++ Code

```cpp
#include <bits/stdc++.h>
using namespace std;

class Dinic {
	public:
		typedef long long TYPE;
		static const int maxn = 5000 * 5, inf = 0x7f7f7f7f, maxm = inf;
		class edge {
			public:
				int to, rev;
				TYPE flow;
				edge(int to, TYPE flow, int rev): to(to), flow(flow), rev(rev) {}
				edge() {}
		};
		std::vector<edge>vec[maxn];
		int h[maxn], cur[maxn], n, m, s, t;
		Dinic(int n, int m, int s, int t): n(n), m(m), s(s), t(t),
			h({0}), cur({0}) {}
		Dinic() {}
		inline bool bfs() {
			std::memset(h, inf, sizeof(h));
			h[t] = 0;
			std::memset(cur, 0, sizeof(cur));
			int q[maxn], front = 0, back = -1;
			std::memset(q, 0, sizeof(q));
			for (q[++back] = t; front <= back;) {
				int u = q[front++];
				for (edge &e : vec[u]) {
					int v = (e.to);
					if (vec[v][e.rev].flow && h[v] == inf) {
						h[v] = h[u] + 1;
						q[++back] = v;
					}
				}
			}
			return h[s] != inf;
		}
		inline TYPE dfs(int u, TYPE flow) {
			if (u == t || !flow) {
				return flow;
			}
			TYPE res = 0;
			int sz = vec[u].size();
			for (int &i = cur[u]; i < sz && flow; ++i) {
				edge &e = vec[u][i];
				int v = e.to;
				if (e.flow && h[v] + 1 == h[u]) {
					TYPE Preflow = dfs(v, std::min(e.flow, flow));
					flow -= Preflow, res += Preflow;
					e.flow -= Preflow, vec[v][e.rev].flow += Preflow;
				}
			}
			return res;
		}
		inline TYPE GetMaxFlow() {
			TYPE res = 0;
			while (bfs()) {
				TYPE Preflow = 0;
				while ((Preflow = dfs(s, inf))) {
					res += Preflow;
				}
			}
			return res;
		}
		inline void Add_Edge(int from, int to, TYPE flow) {
			vec[from].push_back(edge(to, flow, vec[to].size()));
			vec[to].push_back(edge(from, 0, vec[from].size() - 1));
		}
		inline void Solve() {
#define id(a,CLASS) (a+(CLASS)*(N))
#define Which(a) ((a-1)/2+1)
			int N, M;
			scanf("%d%d", &N, &M);
			this[0] = Dinic((N << 2) + 2, inf, 0, (N << 2) + 1);
			for (int i = 1; i <= (N << 1); ++i) {
				int c, d, e;
				scanf("%d%d%d", &c, &d, &e);
				Add_Edge(id(Which(i), !(i & 1)), t, c);
				Add_Edge(s, id(Which(i), !(i & 1)), d);
				Add_Edge(id(Which(i), !(i & 1)), id(Which(i), (i & 1)), e);
			}
			for (int i = 1; i <= N; ++i) {
				Add_Edge(s, id(i, 2), inf);
				Add_Edge(id(i, 3), t, inf);
				Add_Edge(id(i, 2), id(i, 3), inf);
				Add_Edge(id(i, 2), id(i, 0), inf);
				Add_Edge(id(i, 2), id(i, 1), inf);
			}
			for (int i = 1; i <= M; ++i) {
				int A, B, a, b;
				scanf("%d%d%d%d", &A, &B, &a, &b);
				Add_Edge(id(Which(B), !(B & 1)), id(Which(A), 3), a);
				Add_Edge(id(Which(B), 3), id(Which(A), !(A & 1)), b);
			}
			printf("%lld\n", GetMaxFlow() - (long long)inf * N);
		}
};
Dinic Main;

int main() {
	Main.Solve();
	return 0;
}
```


---


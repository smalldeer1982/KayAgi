# [CEOI 2024] 文本编辑器

## 题目描述

**题目译自 [CEOI 2024](https://ceoi2024.fi.muni.cz/) Day1 T3「[Text editor](https://ceoi2024.fi.muni.cz/page/tasks/statements/editor.pdf)」**

罗伯特正在参加 2024 年 CEOI 编程竞赛。他几乎完成了当天最难的一道题的代码，而且他确信能拿满分！但问题出在一个小小的细节上：他打错了一个字！更糟糕的是，他从 2008 年就开始使用的那只心爱鼠标彻底罢工了，一点反应也没有。因此，他只能用键盘上的方向键移动光标去找到那个错别字。

罗伯特的程序有 $N$ 行，每行的长度分别为 $l_1, l_2, \ldots , l_N$。罗伯特总是以空行作为程序的结尾，所以 $l_N = 0$。光标可以放在两个字符之间，也可以放在行的开头或结尾。因此，第 $i$ 行有 $l_i + 1$ 个可用的光标位置（称为列），编号从 $1$ 到 $l_i + 1$。例如，下面是光标位于第 $2$ 行第 $6$ 列的情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/4p5zr0jw.png)

罗伯特想把光标从第 $s_l$ 行的第 $s_c$ 列移动到第 $e_l$ 行的第 $e_c$ 列。他想求出最少需要的按键次数。

水平方向键的使用比较简单。按下 **左键** 会将光标移动到前一列，除非光标位于行首，则会移动到前一行的行尾。类似地，按下 **右键** 会将光标移动到后一列，或者如果光标位于行尾，则会移动到下一行的行首。

例如，**左键** 的移动可以像这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/lig1idke.png)

而 **右键** 的移动可以像这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/zy9hu3u5.png)

在文件的最开头按下 **左键** 或在文件的最结尾按下 **右键** 都不会有任何效果。

垂直方向键的使用稍微复杂一些。按下 **上键** 会将光标移动到上一行，按下 **下键** 会将光标移动到下一行，列数不会改变。但是，如果这样会使光标超出新行的结尾，光标则会跳到该行末尾。

例如，**上键** 的移动可以像这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/2zixw04v.png)

而 **下键** 的移动可以像这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/wr5ld99o.png)

如果按下 **上键** 或 **下键** 会把光标移动到不存在的行，则光标根本不会移动。

## 说明/提示

**样例解释 1**

罗伯特可以通过按顺序按 **上键**、**左键** 和 **下键**三个键来将光标移动到目标位置：

![](https://cdn.luogu.com.cn/upload/image_hosting/wsz8bcr4.png)

或者，他也可以通过按 **左键**、**上键** 和 **下键** 来同样快速地将光标移动到目标位置。

**样例解释 2**

可以很容易地证明，不可能使用最多两个按键到达目标位置。

最短的可能按键序列是按两次 **下键** 然后按十四次 **右键**。

对于所有输入数据，满足：

- $1 \leq N \leq 10^6$
- $0 \leq l_i \leq 10^9\ (1\leq i\leq n)$
- $l_N = 0$
- $1 \leq s_l, e_l \leq N$
- $1 \leq s_c \leq l_{s_l} + 1$
- $1 \leq e_c \leq l_{e_l} + 1$

详细子任务附加限制及分值如下表所示。

| 子任务 | 附加限制 | 分值 |
| :--: | :--: | :--: |
|  $1$  | $N \leq 2$ | $5$  |
|  $2$  | $N \leq 1\,000, l_i \leq 5\,000\ (1 \leq i \leq N)$| $14$ |
|  $3$  | $N \leq 1\,000$ | $26$ |
|  $4$  | $l_i = l_j\ (1 \leq i, j \leq N - 1)$ | $11$ |
|  $5$  | 无附加限制| $44$ |

## 样例 #1

### 输入

```
5
3 1
2 8
7 10 9 9 0```

### 输出

```
3```

## 样例 #2

### 输入

```
5
1 20
3 25
25 10 40 35 0```

### 输出

```
16```

# 题解

## 作者：Exp10re (赞：3)

挺恶心的分讨，被拿来当签到了。/kel

## 解题思路

感性理解可以发现：如果想让光标移动次数尽可能少，那么很有可能光标经过了某一行的行末。

为什么？因为从下一行的行末到这一行的行头只需要按一个键，却能使光标所在的列一次性增加一个很大的值。

那么，光标从起点到终点，要么不经过任意一行的行末，要么就经过其中至少一行的行末。

前者很好处理，接下来看看后者。

我们尝试维护从起点到每一行行末所需要的最少按键数，以及从每一行行末到终点所需要的最少按键数。

从起点到每一行行末的最少按键数，直观理解可以得到如下两种方案：

- 一直走到这一行，然后从当前位置一直按右键直到行末。
- 走到下一行的行头，然后按左键。

从起点左右扫一遍就可以 $O(n)$ 计算。

但是这种朴素的想法不是最优的，为什么？因为它没有最优化到达行头的时间。

如下所示：

$$\texttt{20,25,35,40,0}$$

假设我们在 $(4,20)$，想到达 $(3,36)$，最好的方案不是直接按 $19$ 次左键到达 $(4,1)$ 再左键到达 $(3,36)$，也不是先按上到达 $(3,20)$ 再按 $16$ 次右键到达 $(3,36)$，而是先按下到达 $(5,1)$，再按上到达 $(4,1)$，再左键到达 $(3,36)$。

由此我们可以得知：想到达一行的行头，我们可以先到达其他行的行末，再从这个行末到达其他行头。

那么我们可以从一个行末的最短路转移到其他行末的最短路。记到达第 $i$ 行行末的最少按键数量为 $cnt_i$，我们想转移到第 $j(j\leq i)$ 行的 $cnt_j$，则有：

$$cnt_j=\begin{cases}
cnt_i+|i-j| & l_i=0\\
cnt_i+|i-j|+2 &l_i\ne 0\\
\end{cases}$$

对于 $j\gt i$ 也有：

$$cnt_j=\begin{cases}
cnt_i+|i-j| & l_j=0\\
cnt_i+|i-j|+2 &l_j\ne 0\\
\end{cases}$$

注意上下两条的条件不同。

自行模拟就可以得到相同结论，故不作证明。

以上可以 $O(n)$ 递推转移。

接下来计算每一行行末到达终点的最小按键次数。

若位于第 $i$（$i\leq el$，在 $i\geq el$ 的情况同理）行行末，想要到达位于 $(el,ec)$ 的终点，记 $t=\min\limits_{i\lt j \lt el} l_j+1$，到达终点的最少按键数量为 $b_i$，则有：

$$b_i=\begin{cases}
|l_i+1-ec|+|i-el| & t\geq l_i+1\\
|t-ec|+|i-el| & otherwise.\\
\end{cases}$$

不要忘了行末是可以一步到行头的，记得将 $b_i$ 与 $|i+1-el|+ec$（从第 $el$ 行的行头走到第 $ec$ 列）取 $\min$。

最后，不经过任何行末的答案与所有 $\min\limits_{1\leq i \leq n} cnt_i+b_i$ 取 $\min$ 即为最终答案。

期间需要计算区间 rmq，随便用一个数据结构维护就行了。

时间复杂度 $O(n\log n)$，瓶颈在区间 rmq。

---

## 作者：xie_lzh (赞：2)

简单分讨题。

容易发现只有左右移动换行时会影响答案。

我们推测答案只会由几种情况得到，即由起点直接得到，由起点先移动到某行开头再走到终点得到，由起点先走到某行末尾再走到终点得到。

我们发现，从起点移动到行首与行末的最优方案最多只会使用两次左右移动换行。

则我们可以先求出不使用左右移动换行移动到任意一行行首与行末的答案。

然后从上到下，由移动到上一行末尾的答案加一和移动到上一行开头的答案加一来尝试更新移动到下一行开头的答案。再从下到上按相似的方法更新。

最后就能得到由起点到每行开头结尾的最短路。

不使用左右换行的答案是好求的，只要判以下上下移动过程中关于长度小于当前位置的行的移动即可。

用st表维护的话，复杂度是 $\Theta(n\log n)$ 的。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;
int l[N],n,sx,sy,ex,ey,T,L[N],R[N];
int st[N][20];
int ask(int l,int r)
{
    if(l>r) swap(l,r);
    int len=__lg(r-l+1);
    return min(st[l][len],st[r-(1<<len)+1][len]);
}
int getdis(int x,int y,int X,int Y)
{
    int ans=abs(x-X);
    int ny=min(ask(x,X),y);
    return ans+abs(ny-Y);
}
void solve()
{
    cin>>n;
    cin>>sx>>sy>>ex>>ey;
    for(int i=1;i<=n;i++) cin>>l[i],l[i]++,st[i][0]=l[i];
    for(int j=1;j<20;j++)
    for(int i=1;i+(1<<j)-1<=n;i++)
        st[i][j]=min(st[i][j-1],st[i+(1<<(j-1))][j-1]);
    int nx=sx,ny=sy;
    while(nx<=n)
    {
        ny=min(ny,l[nx]);
        L[nx]=nx-sx+ny-1;
        R[nx]=nx-sx+l[nx]-ny;
        nx++;
    }
    nx=sx; ny=sy;
    while(nx>=1)
    {
        ny=min(ny,l[nx]);
        L[nx]=sx-nx+ny-1;
        R[nx]=sx-nx+l[nx]-ny;
        nx--;
    }
    for(int i=1;i<n;i++)
    {
        L[i+1]=min(L[i+1],R[i]+1);
        L[i+1]=min(L[i+1],L[i]+1);
    }
    for(int i=n;i>1;i--)
    {
        R[i-1]=min(R[i-1],L[i]+1);
        L[i-1]=min(L[i-1],L[i]+1);
    }
    for(int i=1;i<n;i++)
        L[i+1]=min(L[i+1],R[i]+1);
    for(int i=n;i>1;i--)
        R[i-1]=min(R[i-1],L[i]+1);
    int nans=getdis(sx,sy,ex,ey);
    for(int i=1;i<=n;i++)
        nans=min({nans,getdis(i,1,ex,ey)+L[i],getdis(i,l[i],ex,ey)+R[i]});
    cout<<nans<<'\n';
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    solve();
}
```

---

## 作者：forgotmyhandle (赞：2)

[洛谷传送门](https://www.luogu.com.cn/problem/P10803)

## 分析

首先想到最短路。

直接对所有位置跑最短路不现实，考虑选取关键点跑最短路。容易想到的是把每一行的开头结尾两个作为关键点，再加上起点终点。

接下来考虑路径的两种情况：

- 直接从起点按曼哈顿距离走到终点。这种情况并不总是可以达成，但是若不可达成，则必为下一种。

- 经过关键点。

第一种略过。接下来考虑经过关键点的路径。

这种路径必然是从起点先走到关键点，然后从路径最后一个关键点走到终点。因此发现起点和终点并不必然作为关键点。对于起点，只需要把它能走到的关键点都扔进 dijkstra 中作为起点扩展；对于终点，只需要枚举关键点算一下到它的距离。

然后考虑从起点都走到哪些关键点。容易发现从起点**一直按**上下键能走到的关键点 和 与起点在同一行的关键点 才是重要的，我们需要把这些关键点作为 dijkstra 的起点扩展，因为关键点之间的转移并不包括这些转移。而其他的关键点，要么可以通过关键点之间的转移到达，要么根本不会对答案产生影响。

然后就只需要把关键点之间转移的边正确地建出来，跑一遍 dijkstra 就可以了。

也许你会发现这样做可能会把起点到一些关键点的最短路算长，但是这并不影响答案。由于已经特判了答案为曼哈顿距离的情况，而这些被算错的关键点原本对答案的贡献就一定不优于曼哈顿距离，因此把它们的距离算长必然不会影响答案。


## 代码

```cpp
#include <iostream>
#include <string.h>
#include <queue>
#include <map>
#define int long long
using namespace std;
int n;
int sx, sy, tx, ty;
int len[1000005];
map<pair<int, int>, int> mp;
int ncnt;
int head[4000005], nxt[40000005], to[40000005], ew[40000005], ecnt;
struct node {
    int x, dis;
};
bool operator<(node a, node b) { return a.dis > b.dis; }
priority_queue<node> q;
int dist[4000005];
void add(int u, int v, int ww) { to[++ecnt] = v, nxt[ecnt] = head[u], head[u] = ecnt, ew[ecnt] = ww; }
int a[1000005];
int b[1000005];
int c[1000005];
bool vis[4000005];
void dijkstra() {
    while (!q.empty()) {
        node tmp = q.top();
        q.pop();
        int x = tmp.x;
        if (vis[x]) 
            continue;
        vis[x] = 1;
        for (int i = head[x]; i; i = nxt[i]) {
            int v = to[i];
            if (dist[v] > dist[x] + ew[i]) 
                q.push((node) { v, dist[v] = dist[x] + ew[i] });
        }
    }
    // for (int i = 1; i <= ncnt; i++) cout << i << " " << dist[i] << "\n";
}
signed main() {
    // freopen("data.in", "r", stdin);
    // freopen("data.out", "w", stdout);
    cin >> n;
    cin >> sx >> sy >> tx >> ty;
    for (int i = 1; i <= n; i++) cin >> len[i];
    for (int i = 1; i <= n; i++) {
        mp[make_pair(i, 1)] = ++ncnt;
        mp[make_pair(i, len[i] + 1)] = ++ncnt;
        if (sy < len[i] + 1) 
            mp[make_pair(i, sy)] = ++ncnt;
        a[i] = mp[make_pair(i, 1)];
        b[i] = mp[make_pair(i, sy)];
        c[i] = mp[make_pair(i, len[i] + 1)];
        if (b[i]) {
            add(a[i], b[i], sy - 1);
            add(b[i], c[i], len[i] + 1 - sy);
            add(b[i], a[i], sy - 1);
            add(c[i], b[i], len[i] + 1 - sy);
        } else {
            add(a[i], c[i], len[i]);
            add(c[i], a[i], len[i]);
        }
        // cout << a[i] << " " << b[i] << " " << c[i] << " " << d[i] << "\n";
    }
    for (int i = 1; i <= ncnt; i++) dist[i] = 2147483647;
    for(int i = sx, tmp = sy; i; i--){
        tmp = min(tmp, len[i] + 1);
        int x = mp[make_pair(i, tmp)];
        q.push((node) { x, dist[x] = sx - i });
    }
    for(int i = sx, tmp = sy; i <= n; i++){
        tmp = min(tmp, len[i] + 1);
        int x = mp[make_pair(i, tmp)];
        q.push((node) { x, dist[x] = i - sx });
    }
    for (int i = 1; i < n; i++) {
        add(a[i], a[i + 1], 1);
        add(a[i + 1], a[i], 1);
        add(a[i], c[i + 1], len[i + 1] + 1);
        add(c[i + 1], a[i], len[i + 1] + 1);
        add(c[i], a[i + 1], 1);
        add(a[i + 1], c[i], 1);
        if (len[i] >= len[i + 1]) {
            add(c[i], c[i + 1], 1);
            add(c[i + 1], c[i], len[i] - len[i + 1] + 1);
        }
        if (len[i] <= len[i + 1]) {
            add(c[i + 1], c[i], 1);
            add(c[i], c[i + 1], len[i + 1] - len[i] + 1);
        }
        if (b[i] && b[i + 1]) {
            add(b[i], b[i + 1], 1);
            add(b[i + 1], b[i], 1);
        }
        if (b[i]) {
            add(b[i], c[i + 1], b[i + 1] ? (len[i + 1] + 1 - sy + 1) : 1);
            add(b[i], a[i + 1], sy);
            add(c[i + 1], b[i], abs(sy - len[i + 1]));
            add(a[i + 1], b[i], sy);
        }
        if (b[i + 1]) {
            add(a[i], b[i + 1], sy);
            add(c[i], b[i + 1], abs(sy - len[i]));
            add(b[i + 1], c[i], b[i] ? (len[i] + 1 - sy + 1) : 1);
            add(b[i + 1], a[i], sy);
        }
    }
    dijkstra();
    int ans = 2147483647;
    for (int i = tx, tmp = len[tx] + 1; i; i--) {
        tmp = min(tmp, len[i] + 1);
        ans = min(ans, dist[a[i]] + tx - i + ty - 1);
        ans = min(ans, dist[c[i]] + tx - i + abs(len[i] + 1 - tmp) + abs(ty - tmp));
        if (b[i]) 
            ans = min(ans, dist[b[i]] + tx - i + abs(ty - tmp) + abs(tmp - sy));
    }
    for (int i = tx, tmp = len[tx] + 1; i <= n; i++) {
        tmp = min(tmp, len[i] + 1);
        ans = min(ans, dist[a[i]] + i - tx + ty - 1);
        ans = min(ans, dist[c[i]] + i - tx + abs(len[i] + 1 - tmp) + abs(ty - tmp));
        if (b[i]) 
            ans = min(ans, dist[b[i]] + i - tx + abs(ty - tmp) + abs(tmp - sy));
    }
    int tmp = 2147483647;
    for (int i = min(sx, tx); i <= max(sx, tx); i++) tmp = min(tmp, len[i] + 1);
    if (tmp >= ty && tmp >= sy) 
        ans = min(ans, abs(sx - tx) + abs(sy - ty));
    cout << ans << "\n";
    return 0;
}
```

---

## 作者：Unnamed114514 (赞：1)

容易想到答案只有两种形式：

- 两点之间的曼哈顿距离，如果可以到的话，显然用个 RMQ 求两行之间所有行的 $l_{min}$ 不小于两端的 $y$ 的最小值即可。

- 快速换行之后走曼哈顿距离，如果直接普通换行的话，就变成曼哈顿距离了。

因为需要快速换行，我们肯定不能用普通的规则，所以更进一步地，容易想到在这种情况下，只会有行头和行尾会有用，中间的点一定是在曼哈顿上经过的，这样我们就把有用的状态数减少到了 $O(n)$。

对于每个状态，我们显然可以快速求出曼哈顿距离，然后对答案造成的贡献。对于特殊换行，我们上下左右走一下即可。

- 对于行头：

向右走，走到的是行尾；向左走，走到的是上一行的行尾；向上走，走到的是上一行的行头；向下走，走到的是下一行的行头。

- 对于行尾：

向右走，走到的是下一行的行头；向左走，走到的是这一行的行头；向上走，走到第一个 $l$ 小于它的行头；向下走同理。

向上向下走的目的地可以借助我们最先求出的 RMQ 直接二分求解。

起点同理向上下左右走都要判一下，只是上下的时候走到第一个 $l$ 小于它的位置前的也要判，因为可能会出现 $sy<l_i<l_{sx}$，此时显然不等价于走到该行的行尾再向上向下走，这个步数显然是不优的。

对于每个状态，我们显然只需要起点到它的最小值，优先队列 BFS 即可。

```cpp
#include<bits/stdc++.h>
#define int long long
#define endl '\n'
using namespace std;
const int N=1e6+5;
int n,sx,sy,tx,ty,l[N],st[20][N],Log[N],ans=1e18,pre[N],suf[N];
bool vis[N<<1];
int qmin(int l,int r){
	if(l>r) swap(l,r);
	int k=Log[r-l+1];
	return min(st[k][l],st[k][r-(1<<k)+1]);
}
priority_queue<pair<int,int> > q;
void BFS(){
	q.emplace(make_pair(-abs(sy-1),sx));
	q.emplace(make_pair(-abs(l[sx]-sy),sx+n));
	for(int i=sx-1;i>=1;--i){
		if(l[i]<sy){
			q.emplace(make_pair(-abs(sx-i),i+n));
			break;
		}
		q.emplace(make_pair(-(abs(sx-i)+abs(l[i]-sy)),i+n));
	}
	for(int i=sx+1;i<=n;++i){
		if(l[i]<sy){
			q.emplace(make_pair(-abs(sx-i),i+n));
			break;
		}
		q.emplace(make_pair(-(abs(sx-i)+abs(l[i]-sy)),i+n));
	}
	while(q.size()){
		int u=q.top().second,s=-q.top().first;
		q.pop();
		if(vis[u]) continue;
		vis[u]=1;
		if(u<=n){
			ans=min(ans,s+abs(tx-u)+abs(ty-1));
			q.emplace(make_pair(-(s+abs(l[u]-1)),u+n));
			if(u>1){
				q.emplace(make_pair(-(s+1),u-1+n));
				q.emplace(make_pair(-(s+1),u-1));
			}
			if(u<n) q.emplace(make_pair(-(s+1),u+1));
		} else{
			if(qmin(u-n,tx)>=min(l[u-n],ty)) ans=min(ans,s+abs((u-n)-tx)+abs(l[u-n]-ty));
			q.emplace(make_pair(-(s+abs(l[u-n]-1)),u-n));
			if(u-n<n) q.emplace(make_pair(-(s+1),u+1-n));
			if(pre[u-n]) q.emplace(make_pair(-(s+(abs((u-n)-pre[u-n]))),pre[u-n]+n));
			if(suf[u-n]) q.emplace(make_pair(-(s+(abs((u-n)-suf[u-n]))),suf[u-n]+n));
		}
	}
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>sx>>sy>>tx>>ty;
	for(int i=1;i<=n;++i) cin>>l[i],++l[i];
	for(int i=2;i<=n;++i) Log[i]=Log[i>>1]+1;
	for(int i=1;i<=n;++i) st[0][i]=l[i];
	for(int j=1;j<=Log[n];++j) for(int i=1;i+(1<<j)-1<=n;++i) st[j][i]=min(st[j-1][i],st[j-1][i+(1<<j-1)]);
	if(qmin(sx,tx)>=min(sy,ty)) ans=min(ans,abs(sx-tx)+abs(sy-ty));
	for(int i=1;i<=n;++i){
		if(i>1&&qmin(1,i-1)<l[i]){
			int L=1,R=i-1;
			while(L<R){
				int mid=L+R+1>>1;
				if(qmin(mid,i-1)<l[i]) L=mid;
				else R=mid-1;
			}
			pre[i]=R;
		}
		if(i<n&&qmin(i+1,n)<l[i]){
			int L=i+1,R=n;
			while(L<R){
				int mid=L+R>>1;
				if(qmin(i+1,mid)<l[i]) R=mid;
				else L=mid+1;
			}
			suf[i]=R;
		}
	}
	BFS();
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：drmr (赞：1)

**题意**：在文本编辑器中，有 $N$ 行字符串，第 $i$ 行长度为 $l_i$，现在你要将光标从 $(s_l, s_c)$ 到 $(e_l, e_c)$，求最小的操作次数。

如果按下左键，使得光标行数改变，则称之为特殊操作。若没有特殊操作，答案是显而易见的，先上下移动至目标行，在左右调整。

考虑特殊操作，能够证明最多只会有两次特殊操作，否则不优。如有两次向左的特殊操作，则可以省略第一次。

那么，我们尝试刻画特殊操作。每一次特殊操作都只会在第一行、最后一行发生，因此考虑维护 $L_i, R_i$ 表示到达第 $i$ 行的左端点和右端点的操作次数，转移两次即可。

这样，时间复杂度为 $O(n \log n)$，其中 $\log$ 为区间求最小值。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 1e6 + 10;
int n, sx, sc, ex, ec, a[N], st[N][22], l[N], r[N];

int Query(int l, int r){
	if(l > r) swap(l, r);
	int k = log2(r - l + 1);
	return min(st[l][k], st[r - (1 << k) + 1][k]);
}

int dis(int sx, int sc, int ex, int ec){
	return abs(sx - ex) + abs(min(sc, Query(sx, ex)) - ec);
}

signed main(){
	cin >> n;
	cin >> sx >> sc;
	cin >> ex >> ec;
	for(int i = 1; i <= n; i++)
		cin >> a[i], st[i][0] = ++a[i];
	
	for(int i = 1; i <= 20; i++)
		for(int j = 1; j + (1 << i) <= n + 1; j++)
			st[j][i] = min(st[j][i - 1], st[j + (1 << (i - 1))][i - 1]);
	
	for(int i = sx, j = sc; i >= 1; j = min(j, a[--i])){
		l[i] = sx - i + j - 1;
		r[i] = sx - i + a[i] - j;
	}
	for(int i = sx, j = sc; i <= n; j = min(j, a[++i])){
		l[i] = i - sx + j - 1;
		r[i] = i - sx + a[i] - j;
	}

	for(int cont = 0; cont < 2; cont++){
		for(int i = 2; i <= n; i++)
			l[i] = min(l[i], min(l[i - 1], r[i - 1]) + 1);
		for(int i = n - 1; i; i--)
			l[i] = min(l[i], l[i + 1] + 1),
			r[i] = min(r[i], l[i + 1] + 1);
	}

	int ans = dis(sx, sc, ex, ec);
	for(int i = 1; i <= n; i++)
		ans = min(ans, l[i] + dis(i, 1, ex, ec));
	for(int i = 1; i <= n; i++)
		ans = min(ans, r[i] + dis(i, a[i], ex, ec));
	cout << ans;
	return 0;
}
```

---

## 作者：takanashi_mifuru (赞：1)

假设这个文本编辑器非常的菜，他在一行最左最右不支持操作，那么这个题的答案就很明了，我们能够借助的跳板仅有“每次换行的时候和当前行所能容纳的最大值”，只需要枚举一行，然后跑到那一行去，再从那一行暴跑到终点就可以了。

可惜这个文本编辑器虽然很菜但是其实也不是很菜，他可以左右换行，但是我们马上就发现，这个左右换行操作最多做两次。

因为很容易就能发现，我与其进行多次左右换行，还不如在我在某一行开头的时候直接跳到我在不断左右换行之后到达的终点。

然后就是模拟了，找一行中转一下，然后直接跑过去就做完了。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int inf=2e9;
int T;
int n,stx,sty,edx,edy;
int A[1000005];
int to0[1000005];
int ton[1000005];
int main(){
    // freopen("secret.in","r",stdin);
    // freopen("secret.out","w",stdout);
    // scanf("%d",&T);
    T=1;
    while(T--){
        scanf("%d",&n);
        scanf("%d%d%d%d",&stx,&sty,&edx,&edy);
        for(int i=1;i<=n;i++){
            scanf("%d",&A[i]);
        }
        for(int i=1;i<=n;i++)to0[i]=ton[i]=inf;
        int nowy=sty;
        for(int i=stx-1;i>=1;i--){
            //计算从(stx,sty)到(i,0)的最短距离，最小值？
            //这里用这个东西计算一下，然后后面用距离更新，正着反着跑吧，反正。
            nowy=min(nowy,A[i]+1);
            int len=(stx-i)+(A[i]+1-nowy)+1;
            to0[i+1]=len;
        }
        nowy=sty;
        for(int i=stx;i<n;i++){
            nowy=min(nowy,A[i]+1);
            int len=(i-stx)+(A[i]+1-nowy)+1;
            to0[i+1]=len;
        }
        nowy=sty;
        for(int i=stx-1;i>=1;i--){
            nowy=min(nowy,A[i]+1);
            to0[i]=min(to0[i],(stx-i)+(nowy-1));
        }
        nowy=sty;
        for(int i=stx;i<=n;i++){
            nowy=min(nowy,A[i]+1);
            to0[i]=min(to0[i],(i-stx)+(nowy-1));
            // printf("%d %d %d %d\n",i,nowy,stx,to0[i]);
        }
        // for(int i=1;i<=n;i++){
        //     printf("%d ",to0[i]);
        // }
        // puts("");
        for(int i=2;i<=n;i++){
            to0[i]=min(to0[i],to0[i-1]+1);
        }
        for(int i=n-1;i>=1;i--){
            to0[i]=min(to0[i],to0[i+1]+1);
        }
        // for(int i=1;i<=n;i++){
        //     printf("%d ",to0[i]);
        // }
        // puts("");
        //如果只是要到行末，不见得要过0
        //------------------------------------------------
        ton[n]=to0[n];
        for(int i=1;i<n;i++){
            ton[i]=to0[i+1]+1;
        }
        nowy=sty;
        for(int i=stx;i>=1;i--){
            nowy=min(nowy,A[i]+1);
            ton[i]=min(ton[i],(stx-i)+(A[i]+1-nowy));
        }
        nowy=sty;
        for(int i=stx;i<=n;i++){
            nowy=min(nowy,A[i]+1);
            ton[i]=min(ton[i],(i-stx)+(A[i]+1-nowy));
        }
        // for(int i=1;i<=n;i++){
        //     ;
        // }
        // for(int i=1;i<=n;i++){
        //     printf("%d ",ton[i]);
        // }
        // puts("");
        int Min=inf,ans=inf;
        for(int i=edx;i>=1;i--){
            Min=min(Min,A[i]+1);
            ans=min(ans,to0[i]+(edx-i)+(edy-1));//直接走过来，或者是从n过来
            ans=min(ans,ton[i]+(edx-i)+abs(Min-edy));
        }
        Min=inf;
        for(int i=edx;i<=n;i++){
            Min=min(Min,A[i]+1);
            ans=min(ans,to0[i]+(i-edx)+(edy-1));
            ans=min(ans,ton[i]+(i-edx)+abs(Min-edy));
        }
        Min=sty;
        if(stx==edx)ans=min(ans,abs(edy-sty));
        if(stx<edx){
            for(int i=stx+1;i<=edx;i++)Min=min(Min,A[i]+1);
            ans=min(ans,abs(stx-edx)+abs(Min-edy));
        }
        if(stx>edx){
            for(int i=edx;i<stx;i++)Min=min(Min,A[i]+1);
            ans=min(ans,abs(stx-edx)+abs(Min-edy));
        }
        printf("%d\n",ans);
    }
    return 0;
}
/*
观察容易发现，跳跃最多发生两次，一次跳出，一次跳进。

考虑对于一个下标什么时候跳进比较好。

容易发现跳进一定是作为一个末尾出现的，对于每个末尾我们都能计算出跳进之后要走的距离，问题就变成了跳过来的最快距离。

有两种方案，一种是直接走过来，另一种是跳过来，其实都好计算。

然后跳进了之后，再想要计算到终点的距离，其实用最小值算两遍就做完了。

考虑我想跳到开头，有三种可能性：

1. 我直接跳
2. 我跳到我后面的第一个比我小的值，然后跳行
3. 我跳到我前面的第一个比我小的值，然后跳行
4. 我跳到一个反正离结尾比较近的地方，然后跳结尾。
容易发现一种权值贡献只要有就行，不管在哪里贡献都是满的。

显然不可以统计从别的地方的最小值跳过来的答案，因为这个东西早就贡献了。

然后再统计一下最大值，这个东西其实就是好统计的了，先用最小值更新一轮，然后我再去更新直接走的。

最后怎么统计到达终点的路程？

考虑和最小值最大值都谈一谈。直接走过来的路程可以直接计算。

时间复杂度O(n)
1
3
2 329297073
2 34677903
3369004 342250692 0 
*/
```

---

## 作者：晴空一鹤 (赞：1)

~~通过观察，我们可以发现，该题光标移动方向与文本编辑器略有不同，因此，用 C++ 写一个改编版的人工智能或自适应的文本编辑器即可。~~

观察题面，发现光标的移动非常复杂，$4$ 个方向上还要细分几种情况，很烦。又不能直接规约成网格图，直接暴力建图时空复杂度都无法接受。

困扰我们的主要是以下几种神奇走法：从某一行向上或向下跑到相邻行的末尾，从某一行的行首或行末跑到相邻行的行末或行首。去掉这两个走法其实就是简单的网格图距离计算。

发现这些神奇走法都与行末以及行首有关，因此考虑把每一行行首行末拎出来建点。

考虑一条起点到终点的路径，可知其要么经过行末，要么不经过行末。不经过行末的直接是曼哈顿距离，判断一下是否可行即可。

经过行末的路径将其拆成 $3$ 部分：（起点->行首/行末）+（行首/行末->行首/行末）+（行首/行末->终点）。第一部分与第三部分同样为曼哈顿距离，可直接计算，第二部分我们采用跑最短路的方式。

首先将相邻的行首连上长为 $1$ 的边,除第 $1$ 行外每一行的行首向上一行末连一条长为 $1$ 的边，同行的行首和行末连上长为 $l_i$ 的边。

注意到行末之间此时的最短路至多为纵向距离 $+2$，把能让距离更短的边连上。具体来说，每一行行末分别向左右两侧离得最近的比他字符少或相等的行末连边，以及恰好比他多 $1$ 的行末连边。

先求出第一部分每个行首行末的答案，一起丢进队列里跑一遍 Dijkstra，求出新答案后加上第三部分的答案即可。

注意这题一定要理清思路再写，否则容易写傻了。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define ii (i>>1)
int T,n,ex,ey,ax,ay,l[2000005],ans[4000005],mi,qwq,qaq,qeq,rans;
int vis[4000005];
const int INF=1e9+1e7;
vector<int>v[4000005],w[4000005];
deque<int>qp;
struct no{
   int x,y;
   friend bool operator<(no a,no b){
   if(a.y==b.y)return a.x<b.x;return a.y>b.y;
   }
}t,tt;
priority_queue<no>q;
void inline Dij(){
    for(int i=1;i<=(n<<1);i++){t.x=i,t.y=ans[i];q.push(t);}
    while(!q.empty()){
    t=q.top();q.pop();if(vis[t.x])continue;
    vis[t.x]=1;
    for(int i=0;i<v[t.x].size();i++)
    if((!vis[v[t.x][i]])&&(w[t.x][i]+ans[t.x]<ans[v[t.x][i]])){
    ans[v[t.x][i]]=w[t.x][i]+ans[t.x];
    tt.x=v[t.x][i];
    tt.y=ans[v[t.x][i]];
    q.push(tt);
    }
    }
}
void inline clean(){
    for(int i=1;i<=2*n;i++)ans[i]=INF;
    for(int i=1;i<=2*n;i++)vis[i]=0;
    for(int i=1;i<=2*n;i++)v[i].clear(),w[i].clear();
}
int main(){

    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);

    cin>>n>>ax>>ay>>ex>>ey; 
    clean();
    mi=INF;qwq=(ax<<1)-1;qaq=(ax<<1)+1;qeq=(n<<1)-1;
    for(int i=1;i<=n;i++){cin>>l[i];l[i]++;}mi=ay;
    for(int i=qwq;i>=1;i-=2){ans[i]=abs(ax-(i+1>>1))+ay-1;if((mi<=l[i+1>>1]))ans[i+1]=abs(ax-(i+1>>1))+abs(l[i+1>>1]-ay);else ans[i+1]=abs(ax-(i+1>>1));mi=min(mi,l[i+1>>1]);if(l[i+1>>1]<ay)break;}
    mi=ay;
    for(int i=qaq;i<=qeq;i+=2){ans[i]=abs(ax-(i+1>>1))+ay-1;if((mi<=l[i+1>>1]))ans[i+1]=abs(ax-(i+1>>1))+abs(l[i+1>>1]-ay);else ans[i+1]=abs(ax-(i+1>>1));mi=min(mi,l[i+1>>1]);if(l[i+1>>1]<ay)break;}
    for(int i=1;i<=2*n-1;i+=2){//if(l[i+1>>1]==1){ans[i]=min(ans[i],ans[i+1]);ans[i+1]=min(ans[i],ans[i+1]);
    v[i].emplace_back(i+1);v[i+1].emplace_back(i);w[i].emplace_back(l[i+1>>1]-1);w[i+1].emplace_back(l[i+1>>1]-1);}
    for(int i=3;i<=qeq;i+=2)
    {v[i].emplace_back(i-2);
    v[i-2].emplace_back(i);
    w[i].emplace_back(1);
    w[i-2].emplace_back(1);
    v[i-1].emplace_back(i);
    v[i].emplace_back(i-1);
    w[i-1].emplace_back(1);
    w[i].emplace_back(1);
    }
    for(int i=2;i<=(n<<1);i+=2)
    {
     while(!qp.empty()&&l[qp.back()]>l[i>>1]+1)qp.pop_back();
     if(!qp.empty()){
     v[i].push_back(qp.back()<<1);
     if(l[qp.back()]==l[i>>1]+1){
     w[i].push_back((i>>1)-qp.back()+1);
     while(!qp.empty()&&l[qp.back()]>l[i>>1])qp.pop_back();;
     if(!qp.empty()){v[i].push_back(qp.back()<<1);w[i].push_back((i>>1)-qp.back());}
     }
     else w[i].push_back((i>>1)-qp.back());}
     qp.push_back(i>>1);
     
    }
    qp.clear();
    for(int i=(n<<1);i>=2;i-=2)
    {
     while(!qp.empty()&&l[qp.back()]>l[i>>1]+1)qp.pop_back();
     if(!qp.empty()){
     v[i].push_back(qp.back()<<1);
     if(l[qp.back()]==l[i>>1]+1){
     w[i].push_back(qp.back()-(i>>1)+1);
     while(!qp.empty()&&l[qp.back()]>l[i>>1])qp.pop_back();;
     if(!qp.empty()){v[i].push_back(qp.back()<<1);w[i].push_back(qp.back()-(i>>1));}
     }
     else w[i].push_back(qp.back()-(i>>1));}
     qp.push_back(i>>1);
     
    }
    qp.clear();
    
    Dij();rans=INF;
    
    for(int i=(ex<<1)-1;i>=1;i-=2){rans=min(rans,ans[i]+abs(ex-(i+1>>1))+ey-1);rans=min(rans,ans[i+1]+abs(ex-(i+1>>1))+abs(l[i+1>>1]-ey));if(l[i+1>>1]<ey)break;}
    for(int i=(ex<<1)+1;i<=qeq;i+=2){rans=min(rans,ans[i]+abs(ex-(i+1>>1))+ey-1);rans=min(rans,ans[i+1]+abs(ex-(i+1>>1))+abs(l[i+1>>1]-ey));if(l[i+1>>1]<ey)break;}
    mi=INF;
    for(int i=min(ax,ex);i<=max(ax,ex);i++)mi=min(mi,l[i]);
    if(mi>=min(ay,ey))rans=min(rans,abs(ex-ax)+abs(ay-ey));
    cout<<rans<<"\n";

    return 0;
}
```

---


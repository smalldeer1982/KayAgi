# [NOI2010] 海拔

## 题目描述

YT 市是一个规划良好的城市，城市被东西向和南北向的主干道划分为 $n \times n$ 个区域。简单起见，可以将 YT 市看作 一个正方形，每一个区域也可看作一个正方形。从而，YT 城市中包括 $(n+1) \times (n+1)$ 个交叉路口和 $2n \times (n+1)$ 条双向道路（简称道路），每条双向道路连接主干道上两个相邻的交叉路口。下图为一张 YT 市的地图（$n = 2$），城市被划分为 $2 \times 2$ 个区域，包括 $3 \times 3$ 个交叉路口和 $12$ 条双向道路。

 ![](https://cdn.luogu.com.cn/upload/pic/1133.png) 

小 Z 作为该市的市长，他根据统计信息得到了每天上班高峰期间 YT 市每条道路两个方向的人流量，即在高峰期间沿着该方向通过这条道路的人数。每一个交叉路口都有不同的海拔高度值，YT 市市民认为爬坡是一件非常累的事情，每向上爬 $h$ 的高度，就需要消耗 $h$ 的体力。如果是下坡的话，则不需要耗费体力。因此如果一段道路的终点海拔减去起点海拔的值为 $h$（注意 $h$ 可能是负数），那么一个人经过这段路所消耗的体力是 $\max\{0, h\}$。

小 Z 还测量得到这个城市西北角的交叉路口海拔为 $0$，东南角的交叉路口海拔为 $1$（如上图所示），但其它交叉路口的海拔高度都无法得知。小 Z 想知道在最理想的情况下（即你可以任意假设其他路口的海拔高度），每天上班高峰期间所有人爬坡消耗的总体力和的最小值。

## 说明/提示

![](https://cdn.luogu.com.cn/upload/pic/1134.png) 

### 数据范围

- 对于 $20\%$ 的数据：$n \leq 3$；
- 对于 $50\%$ 的数据：$n \leq 15$；
- 对于 $80\%$ 的数据：$n \leq 40$；
- 对于 $100\%$ 的数据：$1 \leq n \leq 500$，$0 \leq \text{流量} \leq 10^6$ 且所有流量均为整数。

## 样例 #1

### 输入

```
1
1
2
3
4
5
6
7
8```

### 输出

```
3```

# 题解

## 作者：Daniel13265 (赞：25)

本文仅用于补充其他题解。其他题解未详细说明结论「存在至少一组最优方案使得每个交叉路口海拔都为 $0$ 或 $1$，且海拔都为 $0$ 和 $1$ 的交叉路口分别仅构成一个极大四连通块」，本文予以简要证明。本文由讨论中单独提出，应@yurzhang 要求提交为题解（详见原讨论[此题题解存在共同问题](/discuss/411844)）。

---

下文「连通块」指「内部点高度相同的极大四连通块」。

对于一个方案，若存在高度小于 $0$ 的点，则令所有这些点的高度为 $0$ 更优，因为这些点之间的贡献减小为 $0$，而其他点的高度无论在调整前后都大于等于这些点的，所以这些点与其他点的贡献一定减小了。同理若存在高度大于 $1$ 的点，则令所有这些点的高度为 $1$ 更优。

现在每个点高度在 $[0,1]$ 区间内，假设其不全为 $0$ 或 $1$。对于所有不包含西北角的连通块，找到高度最小的一个（称为 $S$），这个连通块一定存在且不包含东南角。

- 若 $S$ 不与西北角所在的连通块相邻，则将其高度调整为与其相邻的点中的最小高度一定更优，因为 $S$ 内点之间的贡献不变为 $0$，而相邻点的高度无论在调整前后都大于等于这些点的，所以 $S$ 内的点与其相邻点的贡献一定减小了。
- 若 $S$ 与西北角所在的连通块相邻，则找到与之相邻的点中高度不为 $0$ 且最小的（假设高度为 $h$），$S$ 的高度一定在 $0$ 与 $h$ 之间。如果将 $S$ 的高度看作自变量 $x\in[0,h]$，那么令 $x=0$ 或 $x=h$ 一定不更劣，因为 $S$ 内点之间的贡献不变为 $0$，而 $S$ 内的点与其相邻点的贡献是线性函数，最小值一定能在两端取到。

无论是哪种情况，都存在一种不更劣的、连通块更少的方案。不断进行调整，最终每个点的高度一定会停于 $0$ 或 $1$。从而，一定存在一组最优方案使得点的高度都为 $0$ 或 $1$。

---

## 作者：lhm_ (赞：14)

首先进行贪心，发现海拔有梯度时一定是不优的，最优的情况是海拔像断崖一样上升，也就是左上角有一片海拔高度为$0$，右下角有一片海拔高度为$1$。

发现这样的性质后，不难想到用最小割来解决问题，但数据规模过大，需要进行优化。

考虑到网格图是特殊的平面图，那么我们就将平面图转化为对偶图，通过对偶图求最短路来求平面图的最小割。

下面分析如何转化为对偶图：

我的做法是先$n++$，使$n×n$个区域转化为$n×n$个点。

![](https://s2.ax1x.com/2019/12/24/lPwO6x.png)

一个区域用其左上角点的坐标来表示。（图中的红点）

平面图中的有向边顺时针旋转$90°$后作为对偶图中的边，例如当原图的有向边为自西向东（从左到右）时，连边情况应为：

![](https://s2.ax1x.com/2019/12/24/lPDeYQ.png)

黄色箭头表示原平面图中的边，蓝色箭头表示对偶图中的边，其他三种情况同理。

建完对偶图后，从$S$到$T$的最短路即为答案。

实现细节就看代码吧

$code:$
```cpp
#include<bits/stdc++.h>
#define maxn 1200000
#define inf 2000000000
using namespace std;
template<typename T> inline void read(T &x)
{
	x=0;char c=getchar();bool flag=false;
	while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
	while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
	if(flag) x=-x;
}
int n,s,t;
struct edge
{
    int to,nxt,v;
}e[maxn];
int head[maxn],edge_cnt;
void add(int from,int to,int val)
{
    e[++edge_cnt]=(edge){to,head[from],val};
    head[from]=edge_cnt;
}
int num(int x,int y)
{
	return y+(x-1)*n;
}
struct node
{
    int val,num;
    friend bool operator <(const node &x,const node &y)
    {
        return x.val>y.val;
    }
};  
priority_queue<node> q;
int dis[maxn];
bool vis[maxn];
void dijkstra()
{
    for(int i=s;i<=t;++i) dis[i]=inf;
    dis[s]=0;
    q.push((node){0,s});
    while(!q.empty())
    {
        node tmp=q.top();
        q.pop();
        int x=tmp.num;
        if(vis[x]) continue;
        vis[x]=true;
        for(int i=head[x];i;i=e[i].nxt)
        {
            int y=e[i].to,v=e[i].v;
            if(dis[y]>dis[x]+v)
            {
                dis[y]=dis[x]+v;
                q.push((node){dis[y],y});
            }
        }
    }
}
int main()
{
	read(n),n++;
    t=n*n+1;
    for(int i=1;i<=n;++i)
    {
        for(int j=1;j<n;++j)
        {
            int val;
            read(val);
            if(i==1) add(s,num(i,j),val);
            else if(i==n) add(num(i-1,j),t,val);
            else add(num(i-1,j),num(i,j),val);
        }
    }
    for(int i=1;i<n;++i)
    {
        for(int j=1;j<=n;++j)
        {
            int val;
            read(val);
            if(j==1) add(num(i,j),t,val);
            else if(j==n) add(s,num(i,j-1),val);
            else add(num(i,j),num(i,j-1),val);
        }
    }
    for(int i=1;i<=n;++i)
    {
        for(int j=1;j<n;++j)
        {
            int val;
            read(val);
            if(i==1) add(num(i,j),s,val);
            else if(i==n) add(t,num(i-1,j),val);
            else add(num(i,j),num(i-1,j),val);
        }
    }
    for(int i=1;i<n;++i)
    {
        for(int j=1;j<=n;++j)
        {
            int val;
            read(val);
            if(j==1) add(t,num(i,j),val);
            else if(j==n) add(num(i,j-1),s,val);
            else add(num(i,j-1),num(i,j),val);
        }
    }
    dijkstra();
    printf("%d",dis[t]);
	return 0;
}
```


---

## 作者：Aiopr_2378 (赞：9)

# Solution P2046 [NOI2010] 海拔

### 一、理清思路

根据题目，我们所求的每个人的体力为 $\max\{0,h\}$，又因为起点高度为 $0$，终点高度为 $1$，由贪心得出以下结论：

1. 其他点要么是 $1$，要么是 $0$。因为让体力和最少的最好办法就是减少高度差，很明显，分层式的坡不如一个大坡。

1. 为了让高度差最小，我们应该让 $0$ 和 $1$ 分成两部分，这样能保证在每部分的内部是没有高度差的，进而降低总体力

1. 还有，我们需要让 $0$ 的那部分靠近起点，另一部分靠近终点，这样就能消除起终点附近产生的高度差

综上所述，我们将问题转化成了另一个问题：现在有一个连通图，想要分成两部分，求不让他们联通的需要割掉的边权值和。

这是什么？**最小割**

### 二、进阶思考

运用最小割的方法已经可以初步解决我们的问题，运用dinic算法就可以在 $O(n^2m)$ 的时间复杂度内算出结果，预计可以获得 $80$ 分。

但是 $n$ 是比较大的，数据范围为 $1\leq n\leq 500$，也就是说，我们需要处理 $2.5\times10^5$ 个节点的最小割。

那么我们就需要进行一种转换：**平面图转对偶图**

### 三、解决方案

如果你还不知道什么是对偶图的话，可以参考一下博客方便学习：

- [关于平面图到对偶图的转化](https://blog.csdn.net/MaxMercer/article/details/77976666)

- [对偶图对于平面图最小割的求解](https://blog.csdn.net/MaxMercer/article/details/77977447)

根据博客中的说明，我们可以将平面图转化为对偶图进行解决。因为在对偶图中从起点到终点的连线就是对应平面图的割，在对偶图中从起点到终点的最短路就是对应平面图的最小割。

在知道这些特性之后，我们就可以通过旋转 $90^\circ$ 的方法进行变换（为什么？仔细想想）

最后，还需要有一点提示：

1. 不要用spfa，会达到和最小割一样的效果。

1. 数组不要开的太大，容易MLE，也别开的太小，建议直接开 $505\times505$ 的数组。

### 四、参考代码

```cpp
#include<iostream>
#include<queue>
#include<vector>
#include<cstring>
using namespace std;
#define MAXM 4000005
#define MAXN 505
struct node{
    int to,w;
    bool operator<(const node &a) const{
        return w>a.w;
    }
};
vector<node> v[MAXM];
int n,s,t,id[MAXN][MAXN],d[MAXM];
bool vis[MAXM];
inline int read(){
	int x=0,f=1;
    char ch=getchar();
	while(!isdigit(ch)){
        if(ch=='-') f=-1;
        ch=getchar();
    }
	while(isdigit(ch)){
        x=x*10+ch-48;
        ch=getchar();
    }
	return x*f;
}
int dij(){
    memset(d,0x3f,sizeof(d));
    d[s]=0;
    priority_queue<node> q;
    q.push(node{s,0});
    while(q.size()){
        node nd=q.top();
        q.pop();
        int x=nd.to;
        if(vis[x]) continue;
        vis[x]=1;
        for(int i=0;i<v[x].size();i++){
            int y=v[x][i].to;
            if(d[y]>d[x]+v[x][i].w){
                d[y]=d[x]+v[x][i].w;
                q.push(node{y,d[y]});
            }
        }
    }
    return d[t];
}
int main(){
    n=read();
    n++;
    s=n*n+1;
    t=n*n+2;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            id[i][j]=(i-1)*n+j;
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<n;j++){
            int x;
            x=read();
            if(i==1) v[s].push_back(node{id[i][j],x});
            else if(i==n) v[id[i-1][j]].push_back(node{t,x});
            else v[id[i-1][j]].push_back(node{id[i][j],x});
        }
    }
    for(int i=1;i<n;i++){
        for(int j=1;j<=n;j++){
            int x;
            x=read();
            if(j==1) v[id[i][j]].push_back(node{t,x});
            else if(j==n) v[s].push_back(node{id[i][j-1],x});
            else v[id[i][j]].push_back(node{id[i][j-1],x});
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<n;j++){
            int x;
            x=read();
            if(i==1) v[id[i][j]].push_back(node{s,x});
            else if(i==n) v[t].push_back(node{id[i-1][j],x});
            else v[id[i][j]].push_back(node{id[i-1][j],x});
        }
    }
    for(int i=1;i<n;i++){
        for(int j=1;j<=n;j++){
            int x;
            x=read();
            if(j==1) v[t].push_back(node{id[i][j],x});
            else if(j==n) v[id[i][j-1]].push_back(node{s,x});
            else v[id[i][j-1]].push_back(node{id[i][j],x});
        }
    }
    cout<<dij();
    return 0;
}
```

### 五、结束语

对以上过程如有错误请指正，请您指教

如有疑问可以分享在 `评论区` 哈

感谢观看

---

## 作者：chdy (赞：6)

这道题 我很久之前就看了但是一直没想做。(~~对偶图最短路不会跑~~。。

这道题坑点还是很多的:

1. 我们需要看出海拔多高都是没用的0 1 海拔足以。证明可以用反证法证明一下。

2. 最小割是可能拐 很多圈的 所以 题目中给出的一些边的边权有些都是必要的！（我曾以为由西到东是不必要的

3. 建图比较复杂 尽量 话一张图来分析一下。

4. 数组开四倍。

然后对偶图最短路跑一下即可。

```cpp
//#include<bits/stdc++.h>
#include<iomanip>
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<queue>
#include<deque>
#include<cmath>
#include<ctime>
#include<cstdlib>
#include<stack>
#include<algorithm>
#include<vector>
#include<cctype>
#include<utility>
#include<set>
#include<bitset>
#include<map>
#define INF 1000000000
#define ll long long
#define min(x,y) (x>y?y:x)
#define max(x,y) (x>y?x:y)
#define RI register ll
#define up(p,i,n) for(ll i=p;i<=n;++i)
#define db double
using namespace std;
char buf[1<<15],*fs,*ft;
inline char getc()
{
    return (fs==ft&&(ft=(fs=buf)+fread(buf,1,1<<15,stdin),fs==ft))?0:*fs++;
}
inline int read()
{
    int x=0,f=1;char ch=getc();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getc();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getc();}
    return x*f;
}
//或许是因为梦的缘故 琉璃之人追逐幻影 ---龙族
const int MAXN=510;
int n,S,T,len;
int lin[MAXN*MAXN],nex[MAXN*MAXN<<2],ver[MAXN*MAXN<<2],e[MAXN*MAXN<<2];
int dis[MAXN*MAXN],vis[MAXN*MAXN];
priority_queue<pair<int,int> > q;
inline void add(int x,int y,int z)
{
    ver[++len]=y;
    nex[len]=lin[x];
    lin[x]=len;
    e[len]=z;
}
inline void get_horizen(int x,int y,int z)//由西到东 由左到右建 单向边
{
    int flag=0;
 	if(x==1){add(S,(x-1)*n+y,z);flag=1;}
    if(x==n){add((x-2)*n+y,T,z);flag=1;}
    if(flag)return;
    add((x-2)*n+y,(x-1)*n+y,z);return;
}
inline void get_horizen1(int x,int y,int z)//由东到西
{
    int flag=0;
    if(x==1){add((x-1)*n+y,S,z);flag=1;}
    if(x==n){add(T,(x-2)*n+y,z);flag=1;}
    if(flag)return;
    add((x-1)*n+y,(x-2)*n+y,z);return;
}
inline void get_list(int x,int y,int z)//由北到南 由上到下建 单向边
{
    int flag=0;
    if(y==1){add((x-1)*n+y,T,z);flag=1;}
    if(y==n){add(S,(x-1)*n+y-1,z);flag=1;}
    if(flag)return;
    add((x-1)*n+y,(x-1)*n+y-1,z);return;
}
inline void get_list1(int x,int y,int z)
{
    int flag=0;
    if(y==1){add(T,(x-1)*n+y,z);flag=1;}
    if(y==n){add((x-1)*n+y-1,S,z);flag=1;}
    if(flag)return;
    add((x-1)*n+y-1,(x-1)*n+y,z);return;
}
inline void dij(int x)
{
    memset(dis,10,sizeof(dis));
    dis[x]=0;q.push(make_pair(dis[x],x));
    while(q.size())
    {
        int te=q.top().second;
        q.pop();
        if(vis[te])continue;
        vis[te]=1;
        for(int i=lin[te];i;i=nex[i])
        {
            int tn=ver[i];
            if(vis[tn])continue;
            if(dis[tn]>dis[te]+e[i])
            {
                dis[tn]=dis[te]+e[i];
                q.push(make_pair(-dis[tn],tn));
            }
        }
    }
}
int main()
{
    //freopen("1.in","r",stdin);
    n=read();++n;S=n*n+1;T=S+1;
    for(int i=1;i<=n;++i)
        for(int j=1;j<=n-1;++j)get_horizen(i,j,read());
    for(int i=1;i<=n-1;++i)
        for(int j=1;j<=n;++j)get_list(i,j,read());
    for(int i=1;i<=n;++i)
        for(int j=1;j<=n-1;++j)get_horizen1(i,j,read());
    for(int i=1;i<=n-1;++i)
        for(int j=1;j<=n;++j)get_list1(i,j,read());
    dij(S);printf("%d\n",dis[T]);
    return 0;
}

```
~~其实也就是最短路水题~~

---

## 作者：magolor (赞：5)

竟然没有题解……


显然（抱歉），H不可能是小数，一定是0或1，而且0和1一定各自联通


从样例也可以看出来，答案就是最小割->最大流->最短路 （平面图最小割等于最大流等于对偶图的最短路）

![](http://t.williamgates.net/image-7CDE\_5322E041.gif)

（以上图片来自网络）


然后就是了，对偶图建出来，跑一边最短路。本人代码是这样的：原图左上角是（1，1），对偶图左上角是（1，1），对偶图最小标号是0，坐标到对偶图点号的转换：



#define P(x,y) (~-(x)\*N+~-(y))

本人代码并没有建原图，直接建立对偶图，原图和对偶图的坐标转换见代码注释。

对了，方向真的特别乱！**边都是先从左到右后从上到下的！是的！我没打错！边都是先从左到右后从上到下的！**










    
    
    
    
```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
#define MAXN 300000
#define MAXM 2000000
#define MEMINF 0x3f
#define ll long long
#define P(x,y) (~-(x)*N+~-(y))
struct Edge
{
    int to,nex,w;
    Edge(){}
    Edge(int _to, int _nex, int _w):to(_to),nex(_nex),w(_w){}    
};
Edge e[MAXM+5];
int first[MAXN+5], q[MAXN+5], tot, n, v, N, S, T;
ll dis[MAXN+5]; 
bool book[MAXN+5];
void Add(int a, int b, int w)
{
    e[tot] = Edge(b,first[a],w);
    first[a] = tot++;
    return;
}
void SPFA()
{
    memset(dis,MEMINF,sizeof(dis));
    q[0] = S, dis[S] = 0, book[S] = true;
    for(register int head = 0, tail = 1, u, t; head != tail; book[t] = false) 
        for(t = q[head++], head %= MAXN, u = first[t]; u+1; u = e[u].nex)
            if(dis[e[u].to] > dis[t] + e[u].w)
            {
                dis[e[u].to] = dis[t] + e[u].w;
                if(!book[e[u].to])
                    book[e[u].to] = true, q[tail++] = e[u].to, tail %= MAXN; 
            }
    return;
}
int main()
{
    scanf("%d",&n), n++, N = -~n, S = P(1,N), T = P(N,1);
    memset(first,-1,sizeof(first));
    //x'(/N) = x(/n), y'(modN) = y(modn)
    //(x,y)->(x,y+1)    ==>        (x',y'+1)->(x'+1,y'+1)
    for(register int x = 1, y = 1, nx, ny; x <= n; y = y%(n-1)+1, x += (y==1))
        scanf("%d",&v), Add(P(x,y+1),P(x+1,y+1),v); 
    //(x,y)->(x+1,y)    ==>        (x'+1,y'+1)->(x'+1,y')
    for(register int x = 1, y = 1, nx, ny; x < n; y = y%n+1, x += (y==1))
        scanf("%d",&v), Add(P(x+1,y+1),P(x+1,y),v); 
    //(x,y)->(x,y-1)    ==>        (x'+1,y')->(x',y')
    for(register int x = 1, y = 2, nx, ny; x <= n; y = y%n+1, x += (y==1), y += (y==1))
        scanf("%d",&v), Add(P(x+1,y),P(x,y),v); 
    //(x,y)->(x-1,y)    ==>        (x',y')->(x',y'+1)
    for(register int x = 2, y = 1, nx, ny; x <= n; y = y%n+1, x += (y==1))
        scanf("%d",&v), Add(P(x,y),P(x,y+1),v); 
    for(register int i = 2; i < N; i++)
        Add(S,P(1,i),0), Add(S,P(i,N),0), Add(P(i,1),T,0), Add(P(N,i),T,0);
    SPFA(), printf("%lld\n",dis[T]);
     return 0;
}

```

---

## 作者：wjl1100 (赞：2)

## [原题传送门](https://www.luogu.com.cn/problem/P2046)

## 前置芝士

~~众所周知~~，对偶图上的最短路等于原图的最小割。

## 思路

这道题我们可以很容易地发现这是一道最小割，但我们如果直接跑最小割的话一定会超时，所以我们运用前置知识，先把网格图转化为对偶图，再跑一遍最短路，就可以快速的通过了。

## 建图

![](https://cdn.luogu.com.cn/upload/image_hosting/wt9i0xpo.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

（图中蓝点为平面图中的点，红点为对偶图中的点）

而方格图转对偶图建边也非常简单，只需要将平面图中的每一条边顺时针旋转 90 度即可。

like this

![](https://cdn.luogu.com.cn/upload/image_hosting/97wptsca.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

最后将上方和左方连到外面的边连到源点，右边和下方连到外面的边连到汇点，以源点为起点，汇点为终点跑最短路即可。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define inf 0x7f7f7f7f
using namespace std;
const int maxn = 1e6 + 100;
inline int read() {
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
int n , dis[maxn] , head[maxn] , cul[maxn] , tot = 1 , s , t , vis[maxn];
struct edge {
	int to , w;
};
vector<edge> tt[maxn];
struct node {
	int to , next , w;
}e[maxn];
inline void add(int u , int v , int w) {
	e[++tot] = {v , head[u] , w};
	head[u] = tot;                           
}
inline void spfa() {
	memset(dis , inf , sizeof(dis));
	dis[s] = 0;
	queue<int> q;
	q.push(s);
	while(!q.empty()) {
		int u = q.front();
		q.pop();
		vis[u] = 0;
		for(auto y:tt[u]) {
			int v = y.to;
			if(dis[v] > dis[u] + y.w) {
				dis[v] = dis[u] + y.w;
				if(!vis[v]) {
					vis[v] = 1;
					q.push(v);
				}
			}
		}
	}
	printf("%lld\n" , dis[t]);
}
inline int wei(int x , int y) {
	return (x - 1) * n + y;
}
signed main() {
	n = read();
	s = 0;
	t = (n + 1) * (n + 1) + 1;
	for(int i = 1; i <= n + 1; i++) {
		for(int j = 1; j <= n; j++) {
			int w = read();
			if(i == 1) {
				tt[s].push_back({wei(i , j) , w});
			}else if(i == n + 1) {
				tt[wei(i - 1 , j)].push_back({t , w});
			}else {
				tt[wei(i - 1 , j)].push_back({wei(i , j) , w});
			}
		}
	}
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= n + 1; j++) {
			int w = read();
			if(j == 1) {
				tt[wei(i , j)].push_back({t , w});
			}else if(j == n + 1) {
				tt[s].push_back({wei(i , j - 1) , w});
			}else {
				tt[wei(i , j)].push_back({wei(i , j - 1) , w});
			}
		}
	}
	for(int i = 1; i <= n + 1; i++) {
		for(int j = 1; j <= n; j++) {
			int w = read();
			if(i == 1) {
				tt[wei(i , j)].push_back({s , w});
			}else if(i == n + 1) {
				tt[t].push_back({wei(i - 1 , j) , w});
			}else {
				tt[wei(i , j)].push_back({wei(i - 1 , j) , w});
			}
		}
	}
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= n + 1; j++) {
			int w = read();
			if(j == 1) {
				tt[t].push_back({wei(i , j) , w});
			}else if(j == n + 1) {
				tt[wei(i , j - 1)].push_back({s , w});
			}else {
				tt[wei(i , j - 1)].push_back({wei(i , j) , w});
			}
		}
	}
	spfa();
	return 0;
} 
```

---

## 作者：Steven_lzx (赞：2)

在 [博客园食用](https://www.cnblogs.com/2020gyk080/p/solution-luogu-p2046.html) 以获取更好的体验。

## 前置知识

- SPFA
- 网络流
- 平面图转对偶图

## 分析

尝试贪心之后发现，可以用最小割来解决问题，然而直接套用经典算法发现：TLE！

### 最大流—最小割定理

> 定理：在一个网络流中，能够从源点到达汇点的最大流量等于如果从网络中移除就能够导致网络流中断的边的集合的最小容量和。即在任何网络中，最大流的值等于最小割的容量。

### 证明

定义 $s-t$ 平面图为源点 $s$ 和汇点 $t$ 都在图中无界面的边界上。

已知平面图的性质有：

1. 欧拉公式，一个连通的平面图有 $n$ 个点，$m$ 条边和 $f$ 个面，则 $f=m-n+2$。
2. 每个平面图 $\text{G}$ 都有与其对偶的平面图 $\text{G*}$。

那么，对于 $\text{G}$ 中的每条边 $e$，若它属于两个面 $f_1,f_2$，则加入边 $\operatorname{edge}(f_1^*,f_2^*)$；

![对偶图1](https://cdn.luogu.com.cn/upload/image_hosting/x37mt59x.png)

若它只属于一个面 $f$，加入回边 $\operatorname{edge}(f^*,f^*)$。

![对偶图2](https://cdn.luogu.com.cn/upload/image_hosting/hfxc98n7.png)

平面图 $\text{G}$ 与其对偶图 $\text{G*}$ 有如下关系：
 
- $\text{G}$ 的面数等于 $\text{G*}$ 的点数，$\text{G}$ 的点数等于 $\text{G*}$ 的面数，$\text{G}$ 的边数与 $\text{G*}$ 的边数相等。
- $\text{G*}$ 中的环与 $\text{G}$ 中的割一一对应。

### 应用

直接求解仍然困难，不如利用转化思想，想办法求出最小割。而当长度等于容量时，最小割的容量等于最短路的长度，我们就可以跑最短路来实现了。

## 实现细节

可以不用建原图，直接在对偶图上跑 SPFA，但 #6 的时间危险，不吸氧（开 O2）可能 TLE。

注意细节（包括但不限于方向）。

## Talk is cheap, show me the code. 

```cpp
namespace LZX
{
    using namespace std;
    typedef long long i64;
    const int MAXN=300005;
    struct Edge
    {
        int to,nxt,w;
    }e[2000005];
    int head[MAXN],cnt=-1,n,v,base,s,t;
    i64 dis[MAXN];
    bool vis[MAXN];
    queue<int> que;
    #define pos(x,y) (~-(x)*base+~-(y))
    void g_addedge(int x,int y,int z)
    {
        e[++cnt].nxt=head[x];
        head[x]=cnt;
        e[cnt].to=y;
        e[cnt].w=z;
        return;
    }
    void g_sp_SPFA()
    {
        int x,y;
        memset(dis,0x3f,sizeof(dis));
        dis[s]=0;
        que.push(s);
        vis[s]=true;
        do
        {
            x=que.front();
            que.pop();
            vis[x]=false;
            for(int i=head[x];~i;i=e[i].nxt)
            {
                y=e[i].to;
                if(dis[y]>dis[x]+e[i].w)
                {
                    dis[y]=dis[x]+e[i].w;
                    if(!vis[y])
                    {
                        que.push(y);
                        vis[y]=true;
                    }
                }
            }
        }
        while(!que.empty());
        return;
    }
    int _main()
    {
        scanf("%d",&n);
        n++;
        base=-~n;
        s=pos(1,base);
        t=pos(base,1);
        memset(head,-1,sizeof(head));
        for(int i=1,j=1;i<=n;j=j%(n-1)+1,i+=(j==1))
        {
            scanf("%d",&v);
            g_addedge(pos(i,j+1),pos(i+1,j+1),v);
        }
        for(int i=1,j=1;i<n;j=j%n+1,i+=(j==1))
        {
            scanf("%d",&v);
            g_addedge(pos(i+1,j+1),pos(i+1,j),v);
        }
        for(int i=1,j=2;i<=n;j=j%n+1,i+=(j==1),j+=(j==1))
        {
            scanf("%d",&v);
            g_addedge(pos(i+1,j),pos(i,j),v);
        }
        for(int i=2,j=1;i<=n;j=j%n+1,i+=(j==1))
        {
            scanf("%d",&v);
            g_addedge(pos(i,j),pos(i,j+1),v);
        }
        for(int i=2;i<base;i++)
        {
            g_addedge(s,pos(1,i),0);
            g_addedge(s,pos(i,base),0);
            g_addedge(pos(i,1),t,0);
            g_addedge(pos(base,i),t,0);
        }
        g_sp_SPFA();
        printf("%lld\n",dis[t]);
        return 0;
    }
}
```

参考文献：周冬《两极相通——浅析最大—最小定理在信息学竞赛中的应用》。

---

## 作者：KobeBeanBryantCox (赞：1)

# P2046 [NOI2010] 海拔 题解

[题目传送门](https://www.luogu.com.cn/problem/P2046)。

加快读快输 $57$ 行，算短的了吧。

## 题意

有一个 $n\times n$ 的方格，给每一条道路选择海拔，给出人流，求所有人爬升的高度和最小值。

具体见题目描述。

## 思路

边权赋值为人流。

贪心考虑怎么选择海拔。

由于起点为 $0$ 终点为 $1$，显然不可能选择大于 $1$ 的海拔，因为显然不优。

考虑先升再降，这种情况不优，因为降完后必须升才能到终点，还不如刚开始升后面不降了。

所以我们得到最优的情况：

起点和终点由一条线分割，线左上方海拔都为 $0$，右下方海拔都为 $1$。线的形状可能不规则。

考虑怎么选这一条线。

显然的最小割问题。

由于方格是典型的平面图，而平面图最小割又等于对偶图最短路，所以建对偶图跑最短路即可。

不懂的可以看这个（不是我写的）：

- [关于平面图到对偶图的转化](https://blog.csdn.net/MaxMercer/article/details/77976666)。
- [对偶图对于平面图最小割的求解(网络流问题)](https://blog.csdn.net/MaxMercer/article/details/77977447)。

复杂度 $O(n^2\log n)$。

## AC 代码

我的对偶图是左下为起点，右上为终点的图。

```cpp
#include<bits/stdc++.h>
#define Code using
#define by namespace
#define wjb std
Code by wjb;
int in()
{
	int k=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')k=k*10+c-'0',c=getchar();
	return k*f;
}
void out(int x)
{
	if(x<0)putchar('-'),x=-x;
	if(x<10)putchar(x+'0');
	else out(x/10),putchar(x%10+'0');
}
const int N=505*505,inf=1e9;
vector<pair<int,int> >e[N];
int n,s,t;
void add(int u,int v,int l){e[u].push_back({v,l});}
priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >q;
int f[N];bool b[N];
void dijkstra(int s)
{
	for(int i=0;i<N;i++)f[i]=inf,b[i]=false;
	f[s]=0,q.push({0,s});
	while(!q.empty())
	{
		int u=q.top().second;q.pop();
		if(b[u])continue;
		b[u]=true;
		for(auto [v,l]:e[u])
			if(f[v]>f[u]+l)f[v]=f[u]+l,q.push({f[v],v});
	}
}
int main()
{
	n=in(),s=0,t=n*n+1;
	auto get=[&](int x,int y)
	{
		if(x==0||y>n)return t;
		if(x>n||y==0)return s;
		return (x-1)*n+y;
	};
	for(int i=1;i<=n+1;i++)
		for(int j=1;j<=n;j++)add(get(i,j),get(i-1,j),in());
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n+1;j++)add(get(i,j-1),get(i,j),in());
	for(int i=1;i<=n+1;i++)
		for(int j=1;j<=n;j++)add(get(i-1,j),get(i,j),in());
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n+1;j++)add(get(i,j),get(i,j-1),in());
	dijkstra(s),out(f[t]);
	return 0;
}
```

---

## 作者：aCssen (赞：1)

首先考虑一下，如果没有说终点高度是 $1$，那么可以令海拔全为 $0$ 而达到 $0$ 代价。那么问题其实都是 $1$ 带来的。那么我们不会选一个 $>1$ 的海拔，否则把它向下调整会更优（因为高度差小了）。同理，也不会有 $<0$ 的海拔。

现在知道海拔的范围是 $[0,1]$，自然猜测其一定是整数。证明就是考虑一个高度 $w\in (0,1)$。有一个 $i \xrightarrow{a} j \xrightarrow{b} k$ 的结构。$i$ 的海拔确定为 $0$，$k$ 的海拔确定为 $1$。因为如果等于的话，直接令中间点的海拔相同即可。

那么取 $0$ 代价为 $b$，取 $1$ 代价为 $a$，因此可以达到 $\min(a,b)$ 的花费，取 $w$ 的花费则是 $wa+(1-w)b=w(a-b)+b$。如果 $a\le b$，那么 $\min(a,b)=a$，想要取 $w$ 需要 $w(a-b)+b<a$ 即 $w(a-b)<a-b$，由于 $a-b<0$，可以推出 $w>1$，与假设矛盾；如果 $a>b$，那么 $w(a-b)>0$，$w(a-b)+b>b=\min(a,b)$，因此这样的结构中，一定不会选择一个非 $0,1$ 的海拔。推广归纳一下就可以得到，每个点的海拔只会是 $0,1$。

既然如此，考虑对每个点的海拔套用集合划分模型，建立最小割模型，一个点与 $S$ 相连表示其海拔为 $0$，与 $T$ 相连表示海拔为 $1$。那么两个点 $i,j$ 如果 $i$ 取 $0$，$j$ 取 $1$ 就会产生 $i \to j$ 边权的代价。在网络上就表现为 $S \to i \xrightarrow{c_{i \to j}} j \to T$ 连边。

按道理，每个点取 $0$ 取 $1$ 都可以，没有代价，但是 $(1,1)$ 和 $(n+1,n+1)$ 必须是 $0$ 和 $1$，因此连边 $S \to(1,1)$ 和 $(n+1,n+1) \to T$，边权均为 $+\infty$ 表示不能割断。其余的边因为边权是 $0$ 所以没必要加了。

这样我们发现，所谓的模型就只是一个 $(1,1)$ 到 $(n+1,n+1)$ 的最小割。使用平面图最小割等于对偶图最短路的结论求解即可。

如果你 $10$ 分，请仔细阅读边的输入格式。

---

## 作者：sangshang (赞：1)

## 题意分析

有 $(n+1)^2$ 个点，每个点与上下左右四个点相邻，每个点有它的海拔，下文记作 $h$，左上角固定为 $0$，右下角固定为 $1$，对于每条有向边 $(i,j)\in E$，有一个流量 $f$，并会花费 $\max\{0,(h_j-h_i)\times f\}$。求出一种方案使得花费最小。

## 贪心策略

如果一些个节点，它的高度大于 $1$ 或小于 $0$，那一定不是最优的，因为如果将这些节点高度调整到 $[0,1]$。首先，这些点与高度在 $[0,1]$ 的点之间花费减少，而这些点内部花费也没道理增加。

如果一个点，它的高度比周围点都高，那将他的高度调到 $\max\{h_{\text{周围节点}}\}$，一定更优。因为原来下坡的路，现在花费一定还是 $0$；原来上坡的路，现在花费一定减少了。同理，如果一个点，高度比周围都低，将他的高度调到 $\min\{h_{\text{周围节点}}\}$ 一定更优，因为原来下坡的路花费还是 $0$，原来上坡的路，花费一定会减小。

遵循如上规则，对图的高度进行调整。对于一个点，要么被当作较高点，同左上角一片点，高度被调为 $0$。要么，被同右下角的一片点，被当作高度较低的点，高度被调为 $1$。因此，最后图的高度会类似断崖，左上角是 $0$，右下角是 $1$。

此时我们要做的就是求出图的最小割。

## 求解

根据定理，最小割等于最大流，但此题数据过大，使用最大流算法会被第二组测试数据卡掉。我们要转网格图最小割为对偶图最短路。

将每个点之间的网格转化为点，两个点之间连一条边，边权就是原图上两点之间边权。原图上以左上角为起点，右下角为终点，那，对偶图以左下角为起点，右上角为终点。对偶图上的最短路径类似于原图上沿着一条路径将边切开，阻断原图的起点和终点。

对于处在原图边上的边，要相应把边连在起点或终点上，表示将图切开。

最后，关于 SPFA，它死了，对于边权非负的单源最短路问题，应该使用 dijkstra 求解。

## C++ Code

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace IO {
	const int IN_LEN = (1 << 21);
	char buf[IN_LEN], *front = buf, *back = buf;
	inline char FastGetchar() {
		if (front == back) {
			back = (front = buf) + fread(buf, 1, IN_LEN, stdin);
			if (front == back) {return EOF;}
		}
		return (front++)[0];
	}
	inline int read() {
		int in = 0;char ch = FastGetchar();bool flag = false;
		while (ch < '0' || ch > '9') {
			if (ch == '-') {flag = true;}
			ch = FastGetchar();
		}
		while (ch >= '0' && ch <= '9') {in = in * 10 + ch - '0';ch = FastGetchar();}
		if (flag) {in = -in;}
		return in;
	}
}
using namespace IO;
const int  maxn = 1200000, maxm = 1200000, inf = 0x7f7f7f7f;
#define id(x,y) ((x-1)*n+y)
int dis[maxn];bool vis[maxn];
class edge {
	public:
		int to, cost;
		edge(int to, int cost): to(to), cost(cost) {};
		edge() {}
};
vector<edge>E[maxn];
inline void add(int u, int v, int c) {E[u].push_back(edge(v, c));}
inline int dijkstra(int s, int t) {
	memset(vis, false, sizeof(vis));memset(dis, inf, sizeof(dis));dis[s] = 0;
	priority_queue<pair<int, int>, vector< pair<int, int> >, greater< pair<int, int> > >q;
	q.push(make_pair(0, s));
	while (!q.empty()) {
		int tmp = q.top().second;q.pop();
		if (vis[tmp]) {continue;}
		if (tmp == t) {return dis[t];}
		vis[tmp] = true;
		for (edge &e : E[tmp]) {
			int v = e.to;
			if (dis[v] > dis[tmp] + e.cost) {
				dis[v] = dis[tmp] + e.cost;
				if (!vis[v]) {q.push(make_pair(dis[v], v));}
			}
		}
	}
	return dis[t];
}
int main() {
	int n;n = read();++n;int s = 0, t = n * n + 2;
	for (int i = 1; i <= n; ++i) {
		for (int j = 1; j < n; ++j) {
			int f;f = read();
			if (i == 1) {add(s, id(i, j), f);
			} else if (i == n) {add(id(i - 1, j), t, f);
			} else {add(id(i - 1, j), id(i, j), f);}
		}
	}
	for (int i = 1; i < n; ++i) {
		for (int j = 1; j <= n; ++j) {
			int f;f = read();
			if (j == 1) {add(id(i, j), t, f);
			} else if (j == n) {add(s, id(i, j - 1), f);
			} else {add(id(i, j), id(i, j - 1), f);}
		}
	}
	for (int i = 1; i <= n; ++i) {
		for (int j = 1; j < n; ++j) {
			int f;f = read();
			if (i == 1) {add(id(i, j), s, f);
			} else if (i == n) {add(t, id(i - 1, j), f);
			} else {add(id(i, j), id(i - 1, j), f);}
		}
	}
	for (int i = 1; i < n; ++i) {
		for (int j = 1; j <= n; ++j) {
			int f;f = read();
			if (j == 1) {add(t, id(i, j), f);
			} else if (j == n) {add(id(i, j - 1), s, f);
			} else {add(id(i, j - 1), id(i, j), f);}
		}
	}
	printf("%d\n", dijkstra(s, t));return 0;
}
```


---

## 作者：ty_xyz (赞：1)

看到这道题的题解已经相当多了，所以就来讲一下自己对于这道题的理解。

首先关于这道题的几个结论（当答案最优时原图的情况）：

1. 路口的高度必然全为 $0$ 或 $1$。

2. 左上角的路口与任意一个高度为 $0$ 的路口，都必然存在一条路径，满足这条路径上经过的所有路口的高度都为 $0$，反之也必然。

这两个结论都已经被发了题解的大佬们提及并证明过了，这里就不再赘述。

那么我们可以由这两个结论，得到结论 3：整个图被一条分割线分成两部分，一部分的高度为 $0$（左上角的部分），一部分的高度为 $1$（右下角的部分），如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/mozhpp03.png)

其中黑色点为路口，旁边标着的数字就是路口的高度，横穿红色网格的弯曲黑线就是“割线”。（当然这张图是在不考虑边权的情况下画的）

那么问题就转化为求最小割，但在 $n=500$ 的情况下肯定会超时。

考虑优化，可以想到将四个路口围成的每一个区域都抽象为一个点，再在这些点的外面加一圈点，然后十字连边建成一张图，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/h6xkiq8q.png)

于是问题就变成求左下角到右上角的最短路。

那么怎么给这张图赋上边权呢？

首先标绿的边边权为 $0$，因为它们所连接的点都属于“左下角”或“右上角”。那么不画左上角和右下角的点的理由就是：若添加这两个点，则“左下角”和“右上角”就连在一起，跑最短路就失去了意义。

而如果跑完一遍最短路，则形成的最短路径即为上文的“割线”。若给割线标上按最短路的方向，则若割线向上穿过网格边线，则海拔左边低，右边高，反之亦然；若割线向右穿过网格边线，则海拔上边低，下边高，反之亦然。

因此我们只要给建出的图按照“（若）割线从这里穿过的方向”预处理边权再跑最短路即可，建图细节见代码。

时间复杂度：建图 $\mathcal{O}(n^2)$，最短路 $\mathcal{O}(n^2\log n)$，总时间复杂度 $\mathcal{O}(n^2\log n)$。

空间复杂度 $\mathcal{O}(n^2)$。

在 $n=500$ 的情况下，可以通过评测。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct stu
{
	int id,d;
	bool operator<(stu a)const
	{
		return d>a.d;
	}
};
int n,d[300001];
vector<stu>g[300001];
bool vis[300001];
priority_queue<stu>q;
void dijsktra()
{
	for(int i=0;i<=(n+1)*(n+1)-1;i++)d[i]=2147483647;
	d[(n+1)*n]=0;//左下角起点
	q.push((stu){(n+1)*n,d[(n+1)*n]});
	while(!q.empty())
	{
		int u=q.top().id;
		q.pop();
		vis[u]=1;
		for(int i=0;i<g[u].size();i++)
		{
			int v=g[u][i].id,w=g[u][i].d;
			if(!vis[v]&&d[u]+w<d[v])
			{
				d[v]=d[u]+w;
				q.push((stu){v,d[v]});
			}
		}
	}
}
signed main()
{
	cin>>n;//建图时，为每个点(x,y)赋上单一键值x*(n+2)+y
	for(int i=0;i<=n;i++)//西向东
	{
		for(int j=1,x;j<=n;j++)
		{
			scanf("%d",&x);
			g[(i+1)*(n+2)+j].push_back((stu){i*(n+2)+j,x});//图中下往上
		}
	}
	for(int i=1;i<=n;i++)//北向南
	{
		for(int j=0,x;j<=n;j++)
		{
			scanf("%d",&x);
			g[i*(n+2)+j].push_back((stu){i*(n+2)+j+1,x});//图中左往右
		}
	}
	for(int i=0;i<=n;i++)//东向西
	{
		for(int j=1,x;j<=n;j++)
		{
			scanf("%d",&x);
			g[i*(n+2)+j].push_back((stu){(i+1)*(n+2)+j,x});//图中上往下
		}
	}
	for(int i=1;i<=n;i++)//南向北
	{
		for(int j=0,x;j<=n;j++)
		{
			scanf("%d",&x);
			g[i*(n+2)+j+1].push_back((stu){i*(n+2)+j,x});//图中右往左
		}
	}
	for(int i=1;i<=n;i++)//建图中绿色边
	{
		g[i].push_back((stu){i+1,0});
		g[i+1].push_back((stu){i,0});
		g[(n+2)*(n+1)+i-1].push_back((stu){(n+2)*(n+1)+i,0});
		g[(n+2)*(n+1)+i].push_back((stu){(n+2)*(n+1)+i-1,0});
		g[i*(n+2)].push_back((stu){(i+1)*(n+2),0});
		g[(i+1)*(n+2)].push_back((stu){i*(n+2),0});
		g[n+1+(i-1)*(n+2)].push_back((stu){n+1+i*(n+2),0});
		g[n+1+i*(n+2)].push_back((stu){n+1+(i-1)*(n+2),0});
	}
	++n;
	dijsktra();
	cout<<d[n];//右上角终点
	return 0;
}
```

---

## 作者：灵华 (赞：1)

## P2046 [NOI2010] 海拔

[My blog](https://www.cnblogs.com/linghuabaobao/p/15733233.html)

### 题目描述

[题目链接](https://www.luogu.com.cn/problem/P2046)

YT 市是一个规划良好的城市，城市被东西向和南北向的主干道划分为 $n \times n$ 个区域。简单起见，可以将 YT 市看作 一个正方形，每一个区域也可看作一个正方形。从而，YT 城市中包括 $(n+1) \times (n+1)$ 个交叉路口和 $2n \times (n+1)$ 条双向道路（简称道路），每条双向道路连接主干道上两个相邻的交叉路口。

小 Z 作为该市的市长，他根据统计信息得到了每天上班高峰期间 YT 市每条道路两个方向的人流量，即在高峰期间沿着该方向通过这条道路的人数 $w_i$。每一个交叉路口都有不同的海拔高度值，YT 市市民认为爬坡是一件非常累的事情，每向上爬 $h$ 的高度，就需要消耗 $h$ 的体力。如果是下坡的话，则不需要耗费体力。因此如果一段道路的终点海拔减去起点海拔的值为 $h$（注意 $h$ 可能是负数），那么一个人经过这段路所消耗的体力是 $\max\{0,h\}$。

小 Z 还测量得到这个城市西北角的交叉路口（也就是起点）海拔为 $0$，东南角的交叉路口海拔（也就是终点）为 $1$，但其它交叉路口的海拔高度都无法得知。小 Z 想知道在最理想的情况下（即你可以任意假设其他路口的海拔高度），每天上班高峰期间所有人爬坡消耗的总体力和的最小值。

数据范围：$1\le n\le 500,0\le w_i \le 10^6$，且所有流量均为整数。

### 解法：

由题，要求总体力和的最小值，一件非常显然的事情就是，所有城市的海拔只会是 $0$ 或 $1$，因为如果是其他的值，那爬下去不消耗体力，但是爬上来要消耗更多的体力，所以肯定不是最优的。

然后我们考虑每一条路径，如果说只有 $0$ 和 $1$ 的话，那么显然是让他在每条路径上只变化一次，即 $0$ 和 $1$ 的分界线只有一个，那么对于整个图上所有的路径只有一个分界线，那么就意味着在这样图上有一条 $01$ 的分界线将图分成了两部分，一部分连接起点，一部分连接终点。

想到这里，正解就出来一半了，这显然就是求最小割的板子。但是直接求最小割是不行的，因为 $n$ 的范围在 $500$， $n^2$ 的范围就是 $250000$，如果直接跑最小割显然会爆掉。

对于这种情况，我们引入一个叫对偶图的东西。

我们正常求最小割，都是对着平面图跑的，而且都用到了定理“最大流等于最小割”，这些所有的算法复杂度都是三次方级别左右的，在数据范围小的时候可以，但是数据范围一大就不好使了，这时候一种对最小割求法的优化，对偶图就应运而生。

对平面图求最小割的时候，其实就是求一条能够将原图割成两半的一条路径（即原题目的），我们可以将平面上每个节点围成的一个面当做一个节点，每两个相邻的面肯定会有一条边将其分开，那这两个面所对应的节点就会相应的有一条边，这条边的权值就是这条将这两个面分开的边的容量。

在最外层，如果要求能将图割成两半的路径的话，那么显然要将原图最外层的部分分成两部分，被起点和终点隔开。如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/mwrea7x9.png)

在这个图中黑色的点表示原图的点，红色的表示原图建成的对偶图所对应的点。黑色的线条表示原图中的路径，蓝色的表示对偶图中的边，灰色的表示辅助边。

所以我们对上图中 $S-T$ 的最小值就是红色节点 $1-6$ 的最短路。对于此题的话，用 Dijkstra 就行。

### Code：

```cpp
#include <iostream>
#include <cstring>
#include <queue>
using namespace std ;

const int N = 2500005 ;
int n , s , t , dis[N] ;

struct Edge
{
	int nxt , to , len ;
} edge[N*10] ;

int cnt = 1 , head[N] , cur[N] ;
void insert ( int u , int v , int w )
{
	edge [ ++ cnt ] .nxt = head [ u ] ;
	edge [ cnt ] .to = v ;
	edge [ cnt ] .len = w ;
	head [ u ] = cnt ;
}

struct Dist
{
	int x , dist ;
	Dist ( int _x = 0 , int _dist = -1 ) : x ( _x ) , dist ( _dist ) { }
	bool operator ( ) ( Dist u , Dist v )
	{
		return u .dist > v .dist ;
	}
} ;

priority_queue < Dist , vector < Dist > , Dist > q ;

void Dijkstra ( )
{
	memset ( dis , 0x3f , sizeof ( dis ) ) ;
	dis [ s ] = 0 ;
	q .push ( Dist ( s , 0 ) ) ;
	while ( ! q .empty ( ) )
	{
		Dist tmp = q .top ( ) ; q .pop ( ) ;
		int x = tmp .x ;
		if ( dis [ x ] != tmp .dist )
			continue ;
		for ( int i = head [ x ] ; i ; i = edge [ i ] .nxt )
		{
			int y = edge [ i ] .to ;
			if ( dis [ y ] > dis [ x ] + edge [ i ] .len )
			{
				dis [ y ] = dis [ x ] + edge [ i ] .len ;
				q .push ( Dist ( y , dis [ y ] ) ) ;
			}
		}
	}
}

int id ( int x , int y )
{
	return ( x - 1 ) * ( n + 1 ) + y ;
}

signed main ( )
{
	cin >> n ;
	t = ( n + 1 ) * ( n + 1 ) + 1 ;
	int x ;
	for ( int i = 1 ; i <= n + 1 ; ++ i )
		for ( int j = 1 ; j <= n ; ++ j )
		{
			cin >> x ;
			if ( i == 1 )
				insert ( s , id ( i , j ) , x ) ;
			else if ( i == n + 1 )
				insert ( id ( i - 1 , j ) , t , x ) ;
			else
				insert ( id ( i - 1 , j ) , id ( i , j ) , x ) ;
		}
	for ( int i = 1 ; i <= n ; ++ i )
		for ( int j = 1 ; j <= n + 1 ; ++ j )
		{
			cin >> x ;
			if ( j == 1 )
				insert ( id ( i , j ) , t , x ) ;
			else if ( j == n + 1 )
				insert ( s , id ( i , j - 1 ) , x ) ;
			else
				insert ( id ( i , j ) , id ( i , j - 1 ) , x ) ;
		}
	for ( int i = 1 ; i <= n + 1 ; ++ i )
		for ( int j = 1 ; j <= n ; ++ j )
		{
			cin >> x ;
			if ( i == 1 )
				insert ( id ( i , j ) , s , x ) ;
			else if ( i == n + 1 )
				insert ( t , id ( i - 1 , j ) , x ) ;
			else
				insert ( id ( i , j ) , id ( i - 1 , j ) , x ) ;
		}
	for ( int i = 1 ; i <= n ; ++ i )
		for ( int j = 1 ; j <= n + 1 ; ++ j )
		{
			cin >> x ;
			if ( j == 1 )
				insert ( t , id ( i , j ) , x ) ;
			else if ( j == n + 1 )
				insert ( id ( i , j - 1 ) , s , x ) ;
			else
				insert ( id ( i , j - 1 ) , id ( i , j ) , x ) ;
		}
	Dijkstra ( ) ;
	cout << dis [ t ] << '\n' ;
	return 0 ;
}
```

相似对偶图例题：[狼抓兔子](https://www.luogu.com.cn/problem/P4001)

update:22.1.12:修正了图的问题

---

## 作者：YZren (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P2046)

# 思路

- 看到题目，我们很容易想到一个贪心，把靠近起点的地方高度设为零，靠近终点的地方高度设为一，这样可以只上一个高度，可以发现是最优的。

- 可以发现就是一个最小割的题，总所周知，最小割等于最大流，可以跑一个最大流求解，然后会发现 TLE。

- 注意到这是一个网格图，我们知道平面图上的最大流等于对偶图上的最短路，可以将这个题转化为对偶图来做，大概操作就是将每条边顺时针转 $90$ 度，重新连起来，上边和右边连到外面的边连源点，左边和下边连到外面的边连汇点，最后跑一遍 Dijkstra 即可，不会平面图转对偶图的可以看下[ pengyule 的博客](https://www.cnblogs.com/impyl/p/16459675.html)。

# Code

```cpp
#include<bits/stdc++.h>
#define int long long
#define endl "\n"
#define f(i,j,k) for(int i=j;i<=k;i++)
#define F(i,j,k) for(int i=j;i>=k;i--)
using namespace std;
const int maxn=3e5+10;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
inline void write(int x){
	if(x<0) {x=~(x-1); putchar('-');}
	if(x>9) write(x/10);
	putchar(x%10+'0');
}
int n=read()+1,S=0,T=n*n+1,dis[maxn],u,v,w,vis[maxn];
struct edge{int id,val;}; vector<edge> vec[maxn];
struct node{
	int u,val;
	bool friend operator<(node n1,node n2){
		return n1.val>n2.val;
	}
};
inline void Dijkstra(){
	priority_queue<node> q;
	memset(dis,0x7f,sizeof(dis));
	q.push({S,0}); dis[S]=0;
	while(!q.empty()){
		node p=q.top(); q.pop();
		if(vis[p.u]) continue;
		vis[p.u]=1;
		for(auto y:vec[p.u]) if(dis[y.id]>dis[p.u]+y.val) dis[y.id]=dis[p.u]+y.val,q.push({y.id,dis[y.id]});
	}
	write(dis[T]);
}
inline void work(){
	f(i,1,n) f(j,1,n-1){
		w=read(); u=(i-2)*n+j; v=(i-1)*n+j;
		if(i==1) vec[S].push_back({v,w});
		else if(i==n) vec[u].push_back({T,w});
		else vec[u].push_back({v,w});
	}
	f(i,1,n-1) f(j,1,n){
		w=read(); u=(i-1)*n+j; v=u-1;
		if(j==1) vec[u].push_back({T,w});
		else if(j==n) vec[S].push_back({v,w});
		else vec[u].push_back({v,w});
	}
	f(i,1,n) f(j,1,n-1){
		w=read(); u=(i-2)*n+j; v=(i-1)*n+j;
		if(i==1) vec[v].push_back({S,w});
		else if(i==n) vec[T].push_back({u,w});
		else vec[v].push_back({u,w});
	}
	f(i,1,n-1) f(j,1,n){
		w=read(); u=(i-1)*n+j; v=u-1;
		if(j==1) vec[T].push_back({u,w});
		else if(j==n) vec[v].push_back({S,w});
		else vec[v].push_back({u,w});
	}
	Dijkstra();
}
signed main(){work();return 0;}
```

---

## 作者：ivyjiao (赞：0)

这题你要跟我说是对偶图那肯定秒切了，但是得对题意进行转化。

容易发现海拔只能是 $0,1$：

1. 先小再大或者先大（大于 $1$）再小的话高度差只可能更大，所以中间的部分只能是在 $0\sim1$ 中间。
2. 让体力和最少的办法就是减少高度差，很明显，有梯度的坡不如一个大坡简便，所以只有 $0,1$ 一定最优（不然为啥要保留到整数啊）。
3. 为了让高度差最小，我们应该让 $0,1$ 有且仅有两部分，这样能保证在每部分的内部没有高度差，进而降低体力和。
4. 我们需要让 $0$ 的部分靠近起点，$1$ 的部分靠近终点，这样就能保证每个人爬且只爬一次坡。

然后我们还能发现，在这种情况下，每个人爬且只爬一次高度为 $1$ 的坡。

那么我们就可以将问题转化为另一个问题：现在有一个连通图，想要分成两部分，求不让他们联通的需要割掉的边权值和。

显然可以最小割，然而我不会。

我们（其实只有我）发现这道题位于 accoders 的 `【省选基础 图论 平面图转对偶图】[Noi2010]海拔` 中，所以可以往对偶图上想。

因为每个人爬且只爬一次高度为 $1$ 的坡，所以边权不用动，直接建对偶图跑最短路就行。

建边的一般过程（其实就是这题）就是把原图的面转化成点，对原图的每条两点之间的边建一条垂直于该边的连接面的边，最上或左面一层连 $0$，最下或右面一层连 $n^2+1$。不会建对偶图的去 [P4001 [ICPC-Beijing 2006] 狼抓兔子](https://www.luogu.com.cn/problem/P4001)，哦对了，这题的建边比那题阳间不少（真的）。

代码：

```cpp
#include<bits/stdc++.h>
#define PII pair<int,int>
#define fi first
#define se second
using namespace std;
const int N=1e5+1;
int n,u,v,w,dis[N],t;
bool vis[N];
priority_queue<PII,vector<PII>,greater<PII> >q;
vector<PII>G[N];
int main(){
    cin>>n;
    n++;
    t=n*n+1;
    for(int i=1;i<=n;i++){
        for(int j=1;j<n;j++){
            cin>>w;
            u=(i-2)*n+j,v=(i-1)*n+j;
            if(i==1) G[0].push_back({w,v});
            else if(i==n) G[u].push_back({w,t});
            else G[u].push_back({w,v});
        }
    }
    for(int i=1;i<n;i++){
        for(int j=1;j<=n;j++){
            cin>>w;
            u=(i-1)*n+j,v=u-1;
            if(j==1) G[u].push_back({w,t});
            else if(j==n) G[0].push_back({w,v});
            else G[u].push_back({w,v});
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<n;j++){
            cin>>w;
            u=(i-2)*n+j,v=(i-1)*n+j;
            if(i==1) G[v].push_back({w,0});
            else if(i==n) G[t].push_back({w,u});
            else G[v].push_back({w,u});
        }
    }
    for(int i=1;i<n;i++){
        for(int j=1;j<=n;j++){
            cin>>w;
            u=(i-1)*n+j,v=u-1;
            if(j==1) G[t].push_back({w,u});
            else if(j==n) G[v].push_back({w,0});
            else G[v].push_back({w,u});
        }
    }
    memset(dis,0x3f,sizeof dis);
    dis[0]=0;
    q.push({0,0});
    while(q.size()){
        int u=q.top().se;
        q.pop();
        if(vis[u]) continue;
        vis[u]=1;
        for(int i=0;i<G[u].size();i++){
            int v=G[u][i].se;
            if(dis[v]>dis[u]+G[u][i].fi){
                dis[v]=dis[u]+G[u][i].fi;
                if(!vis[v]) q.push({dis[v],v});
            }
        }
    }
    cout<<dis[t];
}
```

---

## 作者：Purslane (赞：0)

# Solution

真没素质，出题人能不能似一似啊。

结论：问题可以等价于所有点海拔为 $0/1$ 的情形。

现证明把海拔设为 $0/1$ 满足条件。这是因为，假设存在一个 $0/1$ 的解，我们可以给每个点定义一个 $\epsilon_u > 0$，任意小且互不相同。如果这个点原始海拔为 $0$，我们设为 $\epsilon_u$；如果这个点原始海拔为 $1$，我们设为 $1 - \epsilon_u$。这样对人的劳累程度总和的改变是 $O(n^2f \epsilon)$ 的，$f$ 是每条边的流量的量级。当 $\epsilon$ 足够小，它会小于 $\dfrac{1}{2}$，四舍五入之后相当于没有改变。

再证明所有点不是 $0$ 就是 $1$。

这是因为，假设有 $>1$ 的，我们把全部砍成 $1$，肯定不劣；

如果有在 $(0,1)$ 中的，注意到固定其他点，改变这个点，总的劳累程度将会是关于这个点高度的一次函数，那么最值必定在两个端点：$0$ 和 $1$ 的时候取到。

然后显然发现为 $0$ 和 $1$ 的部分必然组成两个连通块，于是又变成了最小割问题。

我发现，我不会，有向平面图的，最小割 /fad

其实就是对偶图加上双向边。你画几个图看一看，我从一个格子跑到另一个格子，两个方向分别是割哪一条边即可。

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=500+10,MAXV=MAXN*MAXN;
int n,tot,s,t,id[MAXN][MAXN],vis[MAXV],dis[MAXV];
vector<pair<int,int>> G[MAXV];
struct Node {int u,dis;};
bool operator <(Node A,Node B) {return A.dis>B.dis;}
void add_edge(int u,int v,int w) {return G[u].push_back({v,w}),void();}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n;
	ffor(i,1,n) ffor(j,1,n) id[i][j]=++tot;
	s=0,t=++tot;
	ffor(i,1,n+1) id[0][i]=t;
	ffor(i,0,n) id[i][n+1]=t;
	ffor(i,1,n+1) ffor(j,1,n) {
		int v; cin>>v;
		add_edge(id[i][j],id[i-1][j],v);	
	}
	ffor(i,1,n) ffor(j,1,n+1) {
		int v; cin>>v;
		add_edge(id[i][j-1],id[i][j],v);	
	}
	ffor(i,1,n+1) ffor(j,1,n) {
		int v; cin>>v;
		add_edge(id[i-1][j],id[i][j],v);	
	}
	ffor(i,1,n) ffor(j,1,n+1) {
		int v; cin>>v;
		add_edge(id[i][j],id[i][j-1],v);	
	}
	priority_queue<Node> q;
	memset(dis,0x3f,sizeof(dis));
	dis[s]=0,q.push({s,0});
	while(!q.empty()) {
		int u=q.top().u; q.pop();
		if(vis[u]) continue ;
		vis[u]=1;
		for(auto pr:G[u]) {
			int v=pr.first,w=pr.second;
			if(dis[u]+w<dis[v]) dis[v]=dis[u]+w,q.push({v,dis[v]});
		}
	}
	cout<<dis[t];
	return 0;
}
```

---

## 作者：Msents (赞：0)

先猜一发结论：**答案所对应的各个城市的海拔高度一定是左上角延申出来一堆联通的 $0$，右下角延申出来一堆联通的 $1$。**

接下来证明为什么是这样。

先证明答案的方案中为什么只有 $0$ 和 $1$。

对于当前任意一种有城市的海拔大于 $1$ 的方案，总是存在一种方案的总体力和小于等于当前方案的总体力和，这个方案可以通过将当前方案所有海拔最高的城市的海拔减去一得到。

现在证明答案的方案为什么是左上角延申出来一堆联通的 $0$，右下角延申出来一堆联通的 $1$。

如果联通的 $0$ 中出现了一个 $1$ 且这个 $1$ 不与其它 $1$ 联通，那么可以将这个 $1$ 改为 $0$，总体力和是小于等于之前的。

反之同理。

于是题意转化为**将整个图通过砍掉一定数量的边，使得从左上角无法走到右下角，求砍掉边的最小权值和。**

也就是有向图最小割。

数据规模很大，注意到图是平面图，根据平面图最小割等于对偶图最短路定理，可以转成对偶图使用 Dijkstra 算法，时间复杂度 $O(n^2\log n^2)$。

关于这个定理这里不再阐述，可以参考这个[板子题的题解](/problem/P4001)和这个[博客](https://www.cnblogs.com/llmmkk/p/15566132.html)。

由于这是有向图，注意建边方向。

码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MaxN=500,MaxM=255000,s=1,t=2,Inf=1e8;
int n;
int GetID(int x,int y){return (x-1)*n+y+2;}
vector<pair<int,int> >g[MaxM+1];
int dis[MaxM+1];
bool vst[MaxM+1];
void Dijkstra(int st){
	priority_queue<pair<int,int>,vector<pair<int,int>>,greater<>>q;
	for(int i=1;i<=n*n+2;i++)dis[i]=Inf,vst[i]=false;
	dis[st]=0;
	q.emplace(0,st);
	while(!q.empty()){
		int u=q.top().second;
		q.pop();
		if(vst[u])continue;
		vst[u]=true;
		for(auto&pi:g[u]){
			int v=pi.first,d=pi.second;
			if(dis[u]+d<dis[v]){
				dis[v]=dis[u]+d;
				if(!vst[v])q.emplace(dis[v],v);
			}
		}
	}
}
void Solve(){
	cin>>n;
	n++;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n-1;j++){
			int val,a=(i==1)?s:GetID(i-1,j),b=(i==n)?t:GetID(i,j);
			cin>>val;
			g[a].emplace_back(b,val);
		}
	}
	for(int i=1;i<=n-1;i++){
		for(int j=1;j<=n;j++){
			int val,a=(j==1)?t:GetID(i,j-1),b=(j==n)?s:GetID(i,j);
			cin>>val;
			g[b].emplace_back(a,val);
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n-1;j++){
			int val,a=(i==1)?s:GetID(i-1,j),b=(i==n)?t:GetID(i,j);
			cin>>val;
			g[b].emplace_back(a,val);
		}
	}
	for(int i=1;i<=n-1;i++){
		for(int j=1;j<=n;j++){
			int val,a=(j==1)?t:GetID(i,j-1),b=(j==n)?s:GetID(i,j);
			cin>>val;
			g[a].emplace_back(b,val);
		}
	}
	Dijkstra(s);
	cout<<dis[t];
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	Solve();
	return 0;
}
```

---

## 作者：⚡114514_zzm⚡ (赞：0)

首先我们需要能够分析出下面两个结论：
1. 选0/1外的值作为海拔没有必要
- 小于0的值改为0，大于1的值改为1，答案不会更差。
- 对(0, 1)之间的值，不如选0/1更优。
2. 海拔为0/1的分别只有一个连通块
- 如果海拔为1的点有≥2个连通块，把不包含 （n,n）的连通块全部变为0，答案不会更差。

所以最终肯定是与左上角连通的一部分点海拔为0，与右下角连通的一部分点的海拔为1。而上班的人消耗的体力，就是海拔为0的点与海拔为1的点之间的边权之和。

这不就是割的定义吗，我们把海拔为0的点看作是点集S ，把海拔为1的点看作是点集 T， (S,T)就构成了一个割。而本题的要求则恰恰是让这个割最小，即要求左上角和右下角的最小割。

因此我们只需要将给出的平面图转化成它的对偶图，再用 Dijkstra算法跑对偶图的s' 和t' 最短路即为答案。

```
#include <bits/stdc++.h>
#define fst first
#define scd second
#define mp make_pair
#define rep(i, x) for(int i = 1; i <= (x); i++)
using namespace std;
typedef pair<int, int> HeapNode;
struct Edge { int v, len, next; };
const int MAXN = 3e5, MAXM = 2e6;
int n, s, t, e_ptr = 1, dist[MAXN+10], head[MAXN+10]; Edge E[(MAXM+10)<<1];
inline int idx(int i, int j) { return (i-1) * n + j; }
inline bool valid(int i, int j) { return i >= 1 && i <= n && j >= 1 && j <= n; }
inline void AddEdge(int u, int v, int len) {
	E[++e_ptr] = (Edge) { v, len, head[u] }; head[u] = e_ptr;
}
int Dijkstra() {
	priority_queue<HeapNode, vector<HeapNode>, greater<HeapNode> > pq;
	memset(dist, 0x3f, sizeof(dist));
	dist[s] = 0; pq.push(mp(dist[s], s));
	while(!pq.empty()) {
		HeapNode p = pq.top(); pq.pop();
		int u = p.scd;
		if(dist[u] != p.fst) continue;
		for(int j=head[u]; j; j=E[j].next) {
			int v = E[j].v, len = E[j].len;
			if(dist[v] > dist[u] + len) {
				dist[v] = dist[u] + len;
				pq.push(mp(dist[v], v));
			}
		}
	}
	return dist[t];
}
inline int readint() {
	int f=1, r=0; char c=getchar();
	while(!isdigit(c)) { if(c=='-')f=-1; c=getchar(); }
	while(isdigit(c)) { r=r*10+c-'0'; c=getchar(); }
	return f*r;
}
void Init() {
	n = readint(); s = MAXN - 1; t = MAXN;
	rep(i, n+1) rep(j, n) {
		int x = readint();
		if(i == 1)
			AddEdge(idx(i, j), t, x);
		else if(i == n+1)
			AddEdge(s, idx(i-1, j), x);
		else
			AddEdge(idx(i, j), idx(i-1, j), x);
	}
	rep(i, n) rep(j, n+1) {
		int x = readint();
		if(j == 1)
			AddEdge(s, idx(i, j), x);
		else if(j == n+1)
			AddEdge(idx(i, j-1), t, x);
		else
			AddEdge(idx(i, j-1), idx(i, j), x);
	}
	rep(i, n+1) rep(j, n) {
		int x = readint();
		if(i == 1)
			AddEdge(t, idx(i, j), x);
		else if(i == n+1)
			AddEdge(idx(i-1, j), s, x);
		else
			AddEdge(idx(i-1, j), idx(i, j), x);
	}
	rep(i, n) rep(j, n+1) {
		int x = readint();
 		if(j == 1)
 			AddEdge(idx(i, j), s, x);
 		else if(j == n+1)
 			AddEdge(t, idx(i, j-1), x);
		else
			AddEdge(idx(i, j), idx(i, j-1), x);
	}
}
void Work() {
 	cout << Dijkstra();
}
int main() {
	Init(); Work();
 	return 0;
}
```



---


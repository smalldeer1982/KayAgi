# [CQOI2015] 网络吞吐量

## 题目背景

路由是指通过计算机网络把信息从源地址传输到目的地址的活动，也是计算机网络设计中的重点和难点。网络中实现路由转发的硬件设备称为路由器。为了使数据包最快的到达目的地，路由器需要选择最优的路径转发数据包。例如在常用的路由算法 OSPF (开放式最短路径优先) 中，路由器会使用经典的 Dijkstra 算法计算最短路径，然后尽量沿最短路径转发数据包。


## 题目描述

现在，若已知一个计算机网络中各路由器间的连接情况，以及各个路由器的最大吞吐量（即每秒能转发的数据包数量），网络中的路由器使用 $1$ 到 $n$ 编号，假设所有数据包一定沿最短路径转发，试计算从路由器 $1$ 到路由器 $n$ 的网络的最大吞吐量。计算中忽略转发及传输的时间开销，不考虑链路的带宽限制，即认为数据包可以瞬间通过网络。路由器 $1$ 到路由器 $n$ 作为起点和终点，自身的吞吐量不用考虑，网络上也不存在将 $1$ 和 $n$ 直接相连的链路。


## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq n \leq 500$，$1 \leq m \leq 10^5$，$1 \leq w, c_i \leq 10^9$。


## 样例 #1

### 输入

```
7 10
1 2 2
1 5 2
2 4 1
2 3 3
3 7 1
4 5 4
4 3 1
4 6 1
5 6 2
6 7 1
1
100
20
50
20
60
1```

### 输出

```
70```

# 题解

## 作者：w4p3r (赞：33)

#### 前言:
本来自己曾想到与这道题一模一样的模型的，我本来还准备自己出道这样的题的，结果被自己省的省选先出了，那就只能写篇题解了。。。
#### 思路：
通过分析，我们可以得出，这道题实质所求的是：

在第i个点只能选$A[i]$次的情况下（$A[1],A[n]=inf$）,能选出多少条$1-n$的最短路

设$1$到第$i$个点的最短路径为$dist[i]$,第$i$个点和第$j$个点之间的边长为$e[i][j]$(没有的话当然就是$inf$了),那么显然的:

**若我们要走$1$到$n$的最短路，我们只能走:$dist[v]=dist[u]+e[u][v]$的边**

然后现在只剩下满足条件的边后，思路也很明显了，很显然这是一个最大流的问题，但是唯一讨厌的就是改题是对经过点的容量进行了限制，而不是对边。

那怎么办呢？

做过一些最大流的同学也都知道，现在当然就该拆点了。

拆完点，然后跑最大流就好了。

#### 做法：
先跑最短路，留下在最短路中的边。

将$n$个点拆成$2n$个点，（其中$1$对应$1+n$,$2$对应$2+n$...）

从第$i(1<=i<=n)$个点向第$i+n$个点建一条容量为$A[i]$的边(**为了每个点经过的流不超过A**)

对于每条在最短路中的$e[u][v]$，从第$u+n$个点朝第$v$个点建一条容量为$inf$的边

从源点$s$朝点$1$建一条容量为$inf$的边,从点$2*n$朝汇点$t$建一条容量为$inf$的边

最后跑最大流即可。

#### 代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
#include<cmath>
#include<queue>
#define inf 0x7fffffffff/2
#define eps 1e-6
#define N 2010
#define M 100010
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
inline ll read()
{
	char ch=getchar();
	ll s=0,w=1;
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}
	return s*w;
}
ll dist[N];//这道题最坑的就是没开long long 0分,rip for 2015年参加省选没开long long的学长们
struct edge
{
	int next,to;
	ll fl;
}e[M<<1];
int cnt=1,head[N];
int n,m;
int vis[N];
ll c[N];
int s,t;
int depth[N];
queue<int>Q;
vector<int>to[N];
vector<ll>v[N];
inline void add_edge(int from,int to,ll fl)
{
	e[++cnt].to=to;
	e[cnt].next=head[from];
	e[cnt].fl=fl;
	head[from]=cnt;
}//建边
inline int bfs()
{
	while(!Q.empty())Q.pop();memset(depth,0,sizeof(depth));
	Q.push(s);depth[s]=1;
	while(!Q.empty())
	{
		int x=Q.front();Q.pop();
		for(register int i=head[x];i;i=e[i].next)
		{
			if(!depth[e[i].to]&&e[i].fl>0)
			{
				depth[e[i].to]=depth[x]+1;
				Q.push(e[i].to);
			}
		}
	}
	return depth[t];
}
ll dfs(int now,ll flow)
{
	if(now==t)return flow;
	ll ret=0;
	for(register int i=head[now];i;i=e[i].next)
	{
		if(ret==flow)return ret;
		if(depth[e[i].to]==depth[now]+1&&e[i].fl>0)
		{
			ll fl=dfs(e[i].to,min(flow-ret,e[i].fl));
			if(fl>0)
			{
				ret+=fl;
				e[i].fl-=fl;
				e[i^1].fl+=fl;
			}
		}
	}
	return ret;
}
inline ll Dinic()
{
	ll sum=0;
	while(bfs())
	{
		ll x=1;while(x){x=dfs(s,inf);sum+=x;}
	}
	return sum;
}//最大流
inline void spfa()
{
	for(register int i=2;i<=n;i++)dist[i]=inf;
	while(!Q.empty())Q.pop();
	Q.push(1);vis[1]=1;
	while(!Q.empty())
	{
		int x=Q.front();Q.pop();vis[x]=0;
		for(register int i=0;i<to[x].size();i++)
		{
			int go=to[x][i];
			ll val=v[x][i];
			if(dist[x]+val<dist[go])
			{
				dist[go]=dist[x]+val;
				if(!vis[go])
				{
					vis[go]=1;
					Q.push(go);
				}
			}
		}
	}
}//最短路，Dijkstra过不了· 
int main()
{
	n=read(),m=read();
	t=n*2+1;
	for(register int i=1;i<=m;i++)
	{
		int x=read(),y=read();
		ll val=read();
		to[x].push_back(y);v[x].push_back(val);
		to[y].push_back(x);v[y].push_back(val);
	}
	spfa();
	for(register int i=1;i<=n;i++)c[i]=read();
	add_edge(s,1,inf);add_edge(1,s,0);
	add_edge(2*n,t,inf);add_edge(t,2*n,0);
	for(register int i=1;i<=n;i++)
	{
		if(i!=1&&i!=n){add_edge(i,i+n,c[i]);add_edge(i+n,i,0);}
		else {add_edge(i,i+n,inf),add_edge(i+n,i,0);}
	}//通过拆点对每个点经过的流量进行限制
	for(register int i=1;i<=n;i++)
	{
		for(register int j=0;j<to[i].size();j++)
		{
			int go=to[i][j];
			ll val=v[i][j];
			if(dist[go]==dist[i]+val)//在最短路中
			{
				add_edge(i+n,go,inf);add_edge(go,i+n,0);
			}
		}
	}//对在最短路中的边建边 
	printf("%lld\n",Dinic());
	return 0;
}

```

#### 后记：
这道题与网络流24题中的最长不下降序列问题类似，都是对DP方案数的讨论（最短路我认为也是一种DP），做完这道题没做那道题的经验可以去A一下（~~双倍经验~~）

#### 如果认为我这篇题解对你有帮助的可以给我点一下赞qwq。如果有任何疑问，或者认为我的题解有什么问题的话，请务必私信我，感激不尽！我会努力把我的题解写得最好的!


---

## 作者：AlanSP (赞：4)

### 模拟赛爆零的T1QAQ

~~本来以为是道水题，没想到是坑。~~

刚开始以为可以直接在原图上跑费用流。

但是有点权和最短路的限制，显然我们要重新建图。

在建图前跑SPFA求最短路（数据应该卡不掉，~~只要你常数小~~）。

由于只能在最短路上流，我们可以枚举每条边看是否在最短路上。

如果在就连边。

**注意：**这题的数据有重边，如果用邻接矩阵，要特判取min！！！！

如果你用vector就没事。

（这就是我爆零原因/kk）。

而对于c的限制，我们可以拆点，从i向i‘连一条ci的边。

但是1和n要连无限大。

最后就可以跑最大流惹qwq。

另：此题不用建源汇点，直接用1和n就行  ~~虽然我还是建了~~。

#### 很重要：

1.不开longlong见祖宗！

2.INF赋小见上帝！

3.不判重两行泪！

~~出题人好毒QAQ~~

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+9,INF=5e17;

int dis[N],ver[N<<1],w[N<<1],nxt[N<<1],h[N],cur[N],dep[N];
int n,m,c[N],x,y,z,ans,g[509][509],tot=1,s=0,t=1501;
bool vis[N];

inline void SPFA()
{
	queue<int> Q;
	for(int i=2;i<=n;i++) dis[i]=INF;
	Q.push(1),vis[1]=true;dis[1]=0;
	while(!Q.empty())
	{
		int u=Q.front();Q.pop();
		vis[u]=0;
		for(int i=0;i<=n;i++)
		{
			if(dis[i]>dis[u]+g[u][i]&&g[u][i]!=-1)
			{
				dis[i]=dis[u]+g[u][i];
				if(!vis[i]) Q.push(i),vis[i]=true;
			}
		}
	}
}

inline void addedge(int x,int y,int z)
{
	ver[++tot]=y,w[tot]=z,nxt[tot]=h[x],h[x]=tot;
	ver[++tot]=x,w[tot]=0,nxt[tot]=h[y],h[y]=tot;
}

inline bool bfs()
{
	queue<int> Q;
	memset(dep,-1,sizeof dep);
	Q.push(s);dep[s]=0;
	while(!Q.empty())
	{
		int u=Q.front();Q.pop();
		for(int i=h[u];i;i=nxt[i])
		{
			int v=ver[i];
			if(dep[v]==-1&&w[i]>0)
			{
				Q.push(v);
				dep[v]=dep[u]+1;
			}
		}
	}
	return dep[t]!=-1;
}

inline int dfs(int u,int flow)
{
	if(u==t) return flow;
	int delta,max_flow=0;
	for(int i=cur[u];i;i=nxt[i])
	{
		cur[u]=i;
		int v=ver[i];
		if(dep[v]==dep[u]+1&&w[i]>0)
		{
			delta=dfs(v,min(w[i],flow));
			flow-=delta;
			max_flow+=delta;
			w[i]-=delta;
			w[i^1]+=delta;
			if(!flow) break;
		}
	}
	return max_flow;
}

inline void Dinic()
{
	while(bfs())
	{
		memcpy(cur,h,sizeof h);
		ans+=dfs(s,INF);
	}
}

signed main()
{
    // freopen("Alansp.out","w",stdout);
	scanf("%lld%lld",&n,&m);
	t=n*2+1;
     memset(g,-1,sizeof g);
    for(int i=1;i<=m;i++) 
    {
        scanf("%lld%lld%lld",&x,&y,&z);
        if(g[x][y]==-1) g[x][y]=g[y][x]=z;
        else g[x][y]=min(g[x][y],z),g[y][x]=g[x][y];
    }
	// for(int i=1;i<=n;i++)
    // {
    //     for(int j=1;j<=n;j++) if(g[i][j]!=-1) cout<<i<<' '<<j<<endl;
    // }
    for(int i=1;i<=n;i++) scanf("%lld",&c[i]);
	SPFA();
    // for(int i=1;i<=n;i++) cout<<dis[i]<<endl;
	addedge(s,1,INF),addedge(n*2,t,INF);
	for(int i=1;i<=n;i++) 
	{
		if(i!=1&&i!=n) addedge(i,i+n,c[i]);
		else addedge(i,i+n,INF);
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{ 
			if(i==j) continue;
			if(dis[i]+g[i][j]==dis[j]&&g[i][j]!=-1) addedge(i+n,j,INF);
		}
	}
	Dinic();
	printf("%lld",ans);
	return 0;
}
```





---

## 作者：Newuser (赞：2)

//蒟蒻博客同步阅读:[Newuser小站！](http://www.newuser.top/2018/04/13/cqoi2015wangluotuntu/)

   #### 不开longlong 毁一生

首先先跑一个最短路上的所有最短路径，然后加入图中跑一次最大流就可以，还是比较裸的一道题。if(dis[x]+len[y]==dis[y])则这条路在最短路上。然后看每个点的吞吐量限制，我们将每个路由器拆成两个点来考虑，从一个点到这个点的镜像结点的容量为其限制就可以了，其他边直接连图，容量为inf。

然而这道题有坑点。。首先起始点没有吞吐量限制！要特判！还有就是要开longlong ,inf也要设大一些。int,一分都没有，，，

大概就是这样吧。。以下是sap代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m;
long long owo,dis[300005],en[300005],nt[300005],la[300005],len[300005];
long long v[1005][1005];
long long fr[300005],to[300005],cd[300005];
long long cnt[1005]; 
void addedge(long long a,long long b,long long c)
{
	en[++owo]=b; nt[owo]=la[a]; la[a]=owo; len[owo]=c;
}
long long dijdis[1005];
struct node
{
	long long di,tt;
}tmp;
priority_queue<node>q;
bool operator<(const node &aa,const node &bb)
{ return aa.di>bb.di; }  
void dijkstra(long long x)
{
	long long ddd;
	for(long long i=1;i<=n;i++) dijdis[i]=0x3f3f3f3f;
	dijdis[1]=0; q.push((node){0,1});
	while(q.size())
	{
		x=q.top().tt; ddd=q.top().di; q.pop();
		if(ddd!=dijdis[x]) continue;
		for(long long it=la[x];it;it=nt[it])
		{
			if(dijdis[en[it]]>ddd+len[it])
			{
				dijdis[en[it]]=ddd+len[it];
				q.push((node){ddd+len[it],en[it]});
			}
		}
	}
}
long long sap(long long x,long long flow)
{
	if(x==2*n) return flow;
	long long delta=0,tmp;
	for(long long i=1;i<=2*n;i++)
	{
		if(v[x][i]&&dis[x]==dis[i]+1)
		{
			tmp=sap(i,min(flow-delta,v[x][i]));
			delta+=tmp;
			v[x][i]-=tmp;
			v[i][x]+=tmp;
			if(delta==flow||dis[1]>=2*n) return delta;
		}
	}
	if(dis[1]>=2*n) return delta;
	cnt[dis[x]]--;
	if(!cnt[dis[x]]) dis[1]=2*n;
	dis[x]++;
	cnt[dis[x]]++;
	return delta;
}
int main()
{
	long long a,b,c;
	scanf("%lld%lld",&n,&m);
	for(long long i=1;i<=m;i++)
	{
		scanf("%lld%lld%lld",&a,&b,&c);
		addedge(a,b,c);
		addedge(b,a,c);
		fr[i]=a; to[i]=b; cd[i]=c;
	}
	dijkstra(1);
	long long x,y;
	for(long long i=1;i<=n;i++)
	{
		scanf("%lld",&x);
		if(i!=n&&i!=1)v[i][i+n]=x;
		else v[i][i+n]=1e14;
	}
	for(long long i=1;i<=m;i++)
	{
		if(dijdis[fr[i]]+cd[i]==dijdis[to[i]]) v[fr[i]+n][to[i]]=1e14;
		if(dijdis[to[i]]+cd[i]==dijdis[fr[i]]) v[to[i]+n][fr[i]]=1e14;
	}
	long long ans=0;
	while(dis[1]<2*n)
	{
		ans+=sap(1,1e14);
	}
	printf("%lld",ans);
}

```


---

## 作者：1124828077ccj (赞：2)

刚学最大流，来做做这题

首先，我们先求出以起点出发的最短路。

然后判断每条边属不属于最短路的一部分。

那么，怎么判断呢？

其实很简单，比如从u到v有一条有向边，如果起点到u的距离+这条边权=起点到v的距离，那么这条边就是最短路的一部分了。

然后跑最大流。

等等！！这限制是在点上啊，好像没法直接跑？

~~如果你觉得没问题可以直接跑，那你就跑吧说不定明天就有个新算法了。。。~~

我们可以拆点，把一个点拆成两个点，其中连一条边，这条边的容量就是这个点的容量。

然后就可以跑了，我用了Edmonds-Karp算法（目前只会这个）

附代码

```cpp
#include<cstdio>
#include<queue>
#include<vector>
#include<cstring>
#include<algorithm>
#include<cstdlib>
using namespace std;
const long long INF=1e18;
int n,m,c,r[1002];
bool f[502];
long long a[1002],d[502];
typedef struct{
    int to,dist;
}P;
struct Edge{
    int from,to;
    long long cap,flow;
    Edge(int u,int v,long long c,long long f):from(u),to(v),cap(c),flow(f){}
};
vector<Edge>edges;
vector<int>g[1002];
vector<P>p[502];
P aa;
void spfa(int s){
    queue<int>q;
    for (int i=1;i<=n;i++)d[i]=INF;
    d[s]=0;q.push(s);f[s]=1;
    while(!q.empty())
    {
        int u=q.front();q.pop();f[u]=0;
        for (int i=0;i<p[u].size();i++)
        if (d[u]+p[u][i].dist<d[p[u][i].to])
        {
            d[p[u][i].to]=d[u]+p[u][i].dist;
            if (!f[p[u][i].to])
            {
                f[p[u][i].to]=1;q.push(p[u][i].to);
            }
        }
    }
}
void add(int from,int to,long long cap){
    edges.push_back(Edge(from,to,cap,0));
    edges.push_back(Edge(to,from,0,0));
    g[from].push_back(edges.size()-2);
    g[to].push_back(edges.size()-1); 
}
long long maxflow(int s,int t){
    long long flow=0;
    while(1)
    {
        memset(a,0,sizeof(a));
        queue<int>q;
        q.push(s);
        a[s]=INF;
        while(!q.empty())
        {
            int x=q.front();q.pop();
            for (int i=0;i<g[x].size();i++)
            {
                Edge e=edges[g[x][i]];
                if (!a[e.to] && e.cap>e.flow)
                {
                    r[e.to]=g[x][i];
                    a[e.to]=min(a[x],e.cap-e.flow);
                    q.push(e.to); 
                }
            }
            if (a[t])break;
        }
        if (!a[t])break;
        for (int u=t;u!=s;u=edges[r[u]].from)
        {edges[r[u]].flow+=a[t];edges[r[u]^1].flow-=a[t];}
        flow+=a[t];
    }
    return flow;
}
int main()
{
    scanf("%d%d",&n,&m);int u,v,w;
    for (int i=0;i<m;i++)
    {
        scanf("%d%d%d",&u,&v,&w);
        aa.to=v;aa.dist=w;
        p[u].push_back(aa);
        aa.to=u;
        p[v].push_back(aa); 
    }
    spfa(1);
    for (int i=1;i<=n;i++)
    for (int j=0;j<p[i].size();j++)
    if (d[i]+p[i][j].dist==d[p[i][j].to])
    add(i+n,p[i][j].to,INF);
    for (int i=1;i<=n;i++)
    {
        scanf("%d",&c);
        if (i!=1 && i!=n)add(i,i+n,c);else add(i,i+n,INF);
    }
    printf("%lld",maxflow(1,n));
    return 0;
}
```

---

## 作者：chenzida (赞：1)

这题还满简单的

这题要求必须要走最短路，这个问题是和网络流模板不一样的，考虑解决这个问题。

也就是说只有在最短路上的边才是有用的，所以我们只需要处理出哪些边在最短路上即可。考虑用 $\text{spfa}$ 计算出所有点的 $dis$ 值，那么有用的边一定是 $dis_u+val=dis_v$ 的边，这种边才有可能在最短路上，预处理出来即可。

注意一下，直接枚举边进行判断正确性是没有问题的，因为如果满足 $dis_u+val=dis_v$ 但其实不在最短路上的话，在 $v$ 到 $n$ 的路上一定会出现断流，所以直接建边即可。

然后跑一遍最大流。~~INF一定不能设0x3f3f3f3f，我调这玩意调了1h~~

代码如下：

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int NR=1005+10;
const int MR=3e5+10;
const int INF=1e18;
void Min(int& x,int y){x=min(x,y);}
void Max(int& x,int y){x=max(x,y);}
int n,m;
int a[NR];
int to[MR*5],nxt[MR*5],val[MR*5];
int head[NR<<1];
int tot=1;
void add(int x,int y,int z)
{
	to[tot]=y;
	val[tot]=z;
	nxt[tot]=head[x];
	head[x]=tot++;
}
int s[MR],t[MR],v[MR];
bool vis[NR];
int dis[NR];
void spfa()
{
	memset(vis,0,sizeof(vis));
	memset(dis,0x3f,sizeof(dis));
	dis[1]=0;vis[1]=1;queue<int>q;q.push(1);
	while(!q.empty())
	{
		int x=q.front();q.pop();vis[x]=0;
		for(int i=head[x];i;i=nxt[i])
		{
			int y=to[i];
			if(dis[y]>dis[x]+val[i])
			{
				dis[y]=dis[x]+val[i];
				if(!vis[y])vis[y]=1,q.push(y);
			}
		}
	}
}
int S,T;
int dep[NR<<1];
int now[NR<<1];
bool bfs()
{
	memcpy(now,head,sizeof(now));
	memset(dep,0,sizeof(dep));
	queue<int>q;q.push(S);dep[S]=1;
	while(!q.empty())
	{
		int x=q.front();q.pop();
		for(int i=head[x];i;i=nxt[i])
		{
			int y=to[i];if(!val[i]||dep[y])continue;
			dep[y]=dep[x]+1;q.push(y);if(y==T)return 1;
		}
	}return 0;
}
int dinic(int x,int flow)
{
	if(x==T)return flow;int mxflow=0;
	for(int i=head[x];i;i=nxt[i])
	{
		if(flow==mxflow)return flow;
		int y=to[i];now[x]=i;
		if(!val[i]||dep[y]!=dep[x]+1)continue;
		int num=dinic(y,min(val[i],flow-mxflow));
		mxflow+=num;val[i]-=num,val[i*2-(i^1)]+=num;
	}
	return mxflow;
}
int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch<='9'&&ch>='0'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return x*f;
}
signed main()
{
//	freopen("1.in","r",stdin);
//	freopen("1.out","w",stdout);
	n=read(),m=read();
	for(int i=1;i<=m;i++)
	{
		int x=read(),y=read(),z=read();
		s[i]=x,t[i]=y;v[i]=z;add(x,y,z),add(y,x,z);
	}spfa();
	memset(head,0,sizeof(head));tot=1;
	for(int i=1;i<=m;i++)
	{
		if(dis[t[i]]==dis[s[i]]+v[i])add(s[i]+n,t[i],INF),add(t[i],s[i]+n,0);
		if(dis[s[i]]==dis[t[i]]+v[i])add(t[i]+n,s[i],INF),add(s[i],t[i]+n,0);
	}
	for(int i=1;i<=n;i++)a[i]=read();S=1,T=n*2;
	add(1,n+1,INF),add(n+1,1,0);add(n,n*2,INF),add(n*2,n,0);
	for(int i=2;i<n;i++)add(i,i+n,a[i]),add(i+n,i,0);
	int ans=0;while(bfs())ans+=dinic(S,INF);printf("%lld\n",ans);
	return 0;
}


---

## 作者：arfa (赞：1)

来刷水题。

题目讲得很清楚,我们就直接干下面的事情就好了: 跑最短路然后连边跑最大流。

注意到我们要知道哪条边在最短路里面,所以我们可以这样子判断: ``dis[from[i]]+value[i]=dis[reach[i]]`` 那么 $i$ 号边就是一条最短路里面的边。

注意到给的是点的流量限制,我们直接拆点就好了。

很多人用邻接矩阵,我还是照常用链式前向星。

~~至于我为什么一页的 $20$ 分:是因为我的流量开的是 $\max longint$ 而显然答案可能会超。(还让我改出了一堆细节错误)~~

```pascal
// luogu-judger-enable-o2
Uses math;

var
    value,reach,next:array[-1..210000] of int64;
    gap,dis,cnt,long:array[-1..210000] of int64;
    queue:array[-1..620000,1..2] of int64;
    ask:array[-1..210000] of boolean;
    _:array[-1..210000] of int64;
    i:longint;
    n,m,l,r,k,maxflow,j,tot,tail,sink,source:int64;

procedure add(l,r,sum:int64);
begin
    inc(tot); reach[tot]:=r; value[tot]:=sum; next[tot]:=cnt[l]; cnt[l]:=tot;
end;

procedure SPFA;
var
    i,l,head,tail:int64;
begin
    fillchar(ask,sizeof(ask),False);
    head:=1; tail:=1; _[1]:=1; long[1]:=0; ask[1]:=True;
    repeat
        l:=_[head]; ask[l]:=False;
        i:=cnt[l];
        while i<>-1 do
        begin
            if long[l]+value[i]<=long[reach[i]] then
            begin
                long[reach[i]]:=long[l]+value[i];
                if ask[reach[i]]=False then
                begin
                    inc(tail); ask[reach[i]]:=True;
                    _[tail]:=reach[i];
                end;
            end;
            i:=next[i];
        end;
        inc(head);
    until head>tail;
end;

function Dfs(now,flow:int64):int64;
var 
    i,k,mindis,ret:int64;
begin
    mindis:=n-1; ret:=flow;
    if now=sink then exit(flow);
    i:=cnt[now];
    while i<>-1 do
    begin
        if value[i]>0 then
        begin
            if dis[now]=dis[reach[i]]+1 then
            begin
                k:=Dfs(reach[i],min(ret,value[i]));
                dec(value[i],k);inc(value[i xor 1],k);
                dec(ret,k);
                if dis[source]>=n then exit(flow-ret);
                if ret=0 then break;
            end;
             mindis:=min(mindis,dis[reach[i]]);
        end;
        i:=next[i];
    end;
    if ret=flow then
    begin
        dec(gap[dis[now]]);
        if gap[dis[now]]=0 then dis[source]:=n;
        dis[now]:=mindis+1;
        inc(gap[dis[now]]);
    end;
    exit(flow-ret);
end;

begin
    filldword(cnt,sizeof(cnt) div 4,maxlongint*2+1);
    fillchar(long,sizeof(long),1);
    read(n,m);
    for i:=1 to m do begin read(l,r,k); add(l,r,k); add(r,l,k); end;
    SPFA;
    for i:=1 to n do
    begin
        j:=cnt[i];
        while j<>-1 do
        begin
            if (long[i]+value[j]=long[reach[j]]) then
            begin
                inc(tail);
                queue[tail,1]:=i;
                queue[tail,2]:=reach[j];
            end;
            j:=next[j];
        end;
    end;

    filldword(cnt,sizeof(cnt) div 4,maxlongint*2+1);
    fillchar(value,sizeof(value),0);
    fillchar(reach,sizeof(reach),0);
    fillchar(next,sizeof(next),0); tot:=1;
    for i:=1 to tail do
    begin
        add(queue[i,1]+n,queue[i,2],maxlongint*888);
        add(queue[i,2],queue[i,1]+n,0);
    end;
    for i:=1 to n do
    begin
        read(k);
        if (i=1)or(i=n) then
        begin
            add(i,i+n,maxlongint*888);
            add(i+n,i,0);
        end else
        begin
            add(i,i+n,k); add(i+n,i,0);
        end;
    end;
    source:=1; sink:=n << 1; n:=sink; gap[source]:=n;
    while dis[source]<n do inc(maxflow,Dfs(source,maxlongint*888));
    writeln(maxflow);
end.
```

---

## 作者：wjyyy (赞：1)

来发一篇非完美解法的题解;[我的博客](http://www.wjyyy.top/771.html)

# 非完美解法：

   看到这个题，用网络流来**限流**当然是第一想法。于是先spfa求最短路，接着枚举每个点是否在最短路上。判断方法：从起点/终点出发各跑一遍最短路，记录dis[0]和dis[1]，最后枚举每条边是否满足$dis[0][u]+w+dis[1][v]=dis[0][t]$（t表示终点）。如果在，就把它加入网络流图中，**流量为两端点中吞吐量较小的一个**。这种做法看上去没有问题，因为两个点相连新吞吐量依赖于较低的点的吞吐量。



   不过一个点**不一定只有这一条流连接**，当有多条流流入且有多条流流出时，它的流量可以被**扩充**超过它的吞吐量。比如说十字路口这种图：

![](http://www.wjyyy.top/wp-content/uploads/2018/07/201807071657.png)所有点的吞吐量均为1。

   即使4号点的吞吐量为1，也只能构建出这样的图，而这时最大流为2，不符合题意。当这个十字路口变为度为2k的点时，它的流量可以达到吞吐量×k。



   可能是数据不够强，致使我这种非完美解法能通过。



# 正确解法：

   把一个点拆成两个，一个管进入，一个管流出，两个点之间以吞吐量为流量的边连接起来。再把最短路上满足条件的点（分拆点的进出）相连，权值为inf。直接跑1到n的最大流，最大流就是答案了。
   
   贴一下非完美解法的Code，完美解法参考其他dalao的题解。
   
## Code：
```cpp
#include<cstdio>
#include<cstring>
#include<queue>
using std::deque;
int min(int x,int y)
{
    return x<y?x:y;
}
namespace graph//建了两个图所以用命名空间
{
struct edge
{
    int n;
    int v;
    int nxt;
    edge(int n,int v,int nxt)
    {
        this->n=n;
        this->v=v;
        this->nxt=nxt;
    }
    edge()
    {
        nxt=-1;
    }
}e[210000];
int head[501],cnt=-1;
void add(int from,int to,int v)
{
    e[++cnt]=edge(to,v,head[from]);
    head[from]=cnt;
    e[++cnt]=edge(from,v,head[to]);
    head[to]=cnt;
}
void init()
{
    memset(head,-1,sizeof(head));
}
long long dis[2][510];
void spfa(int x)
{
    deque<int> q;
    bool used[510];
    memset(used,0,sizeof(used));
    memset(dis[x!=1],0x3f,sizeof(dis[x!=1]));
    used[x]=1;
    dis[x!=1][x]=0;
    int flag=(x!=1);
    q.push_back(x);
    while(!q.empty())
    {
        int k=q.front();
        q.pop_front();
        used[k]=false;
        for(int i=head[k];~i;i=e[i].nxt)
        {
            if(dis[flag][e[i].n]>dis[flag][k]+e[i].v)
            {
                dis[flag][e[i].n]=dis[flag][k]+e[i].v;
                if(!used[e[i].n])
                {
                    if(q.empty()||dis[flag][e[i].n]<dis[flag][q.front()])
                        q.push_front(e[i].n);
                    else
                        q.push_back(e[i].n);
                    used[e[i].n]=true;
                }
            }
        }
    }
}
}
int flow[510];
long long sum=0;//要开long long
namespace Flow
{
struct edge
{
    int n,v;
    int nxt;
    edge(int n,int v,int nxt)
    {
        this->n=n;
        this->v=v;
        this->nxt=nxt;
    }
    edge()
    {
        nxt=-1;
    }
}e[210000];
int head[505],cnt=-1;
void add(int from,int to,int v)
{
    e[++cnt]=edge(to,v,head[from]);
    head[from]=cnt;
    e[++cnt]=edge(from,0,head[to]);
    head[to]=cnt;
}
void init()
{
    memset(head,-1,sizeof(head));
}
int d[505],gap[505];
void bfs(int x)
{
    memset(d,0,sizeof(d));
    int q[505],l=0,r=0;
    q[++r]=x;
    d[x]=1;
    gap[0]=123456;
    while(l<r)
    {
        int k=q[++l];
        for(int i=head[k];~i;i=e[i].nxt)
        {
            if(!d[e[i].n])
            {
                d[e[i].n]=d[k]+1;
                gap[d[e[i].n]]++;
                q[++r]=e[i].n;
            }
        }
    }
}
void isap(int x)//x表示有多少个点
{
    bfs(x);
    int s=1;
    int pre[505];
    memset(pre,-1,sizeof(pre));
    int cur[505];
    for(int i=1;i<=x;i++)
        cur[i]=head[i];
    while(d[1]<=x)
    {
        if(s==x)
        {
            int minn=1234567890;
            int p=pre[s];
            while(~p)
            {
                minn=min(minn,e[p].v);
                p=pre[e[p^1].n];
            }
            sum+=minn;
            p=pre[s];
            while(~p)
            {
                e[p].v-=minn;
                e[p^1].v+=minn;
                p=pre[e[p^1].n];
            }
            s=1;
        }
        int flag=0;
        for(int i=cur[s];~i;i=e[i].nxt)
            if(e[i].v&&d[e[i].n]+1==d[s])
            {
                pre[e[i].n]=i;
                cur[s]=e[i].nxt;
                flag=1;
                s=e[i].n;
                break;
            }
        if(flag==0)
        {
            int tmp=d[s];
            d[s]=x+1;
            for(int i=head[s];~i;i=e[i].nxt)
                if(e[i].v)
                    d[s]=min(d[s],d[e[i].n]+1);
            gap[tmp]--;
            gap[d[s]]++;
            if(gap[tmp]==0)
                return;
            cur[s]=head[s];
            if(s!=1)
                s=e[pre[s]^1].n;
        }
    }
}
}
int main()
{
    using namespace graph;
    init();
    Flow::init();
    int n,m,u,v,w;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d%d",&u,&v,&w);
        add(u,v,w);
    }
    for(int i=1;i<=n;i++)
        scanf("%d",&flow[i]);
    flow[1]=1234567890;
    flow[n]=1234567890;
    spfa(1);
    spfa(n);
    for(int i=1;i<=n;i++)
        for(int j=head[i];~j;j=e[j].nxt)
            if(dis[0][i]+e[j].v+dis[1][e[j].n]==dis[0][n])
                Flow::add(i,e[j].n,min(flow[i],flow[e[j].n]));
    Flow::isap(n);
    printf("%lld\n",sum);
    return 0;
}
```

---

## 作者：⚡114514_zzm⚡ (赞：0)


这不禁让我们想到最短路径树和最短路径图，他们中的所有边都在某一条从源点出发的最短路径上，不过最短路径树上并不能包含所有可能在最短路上的边，因此我们选择最短路径图来解决问题。

于是题目就非常清晰与简单了，所有的数据包只能在最短路径图上进行传输，从路由器1传输到n路由器 ，每个路由器有一个最大吞吐量，问从1到n 传输数据的最大吞吐量。

我们可以考虑对个点i ，拆点为 i_1,i_2 。从 i_1 向i_2 连容量为i 的吞吐量的边，这样就限制了经过路由器i 的数据流量，对于最短路径图上的一条边 (v,v)，从 u_2 向v1 连容量为无穷的边来代表从 u向 v发送数据时的情况，从 v_2 向 u_1 连容量为无穷的边代表u 向 v发送数据的情况，这样就能使得经过的数据一定通过 u_1->u_2 这条边从而限制流量大小。

源点 s为 1_1 ，汇点 t为 n_2 ，跑最大流即可。

```
#include<bits/stdc++.h>
#define N 200020
#define maxn 1000
#define maxm 1000010
#define inf 1000000000000000LL
using namespace std;
int read()
{
	int x=0,f=1; char ch=getchar();
	while (ch<'0' || ch>'9') {if (ch=='-') f=-1; ch=getchar();}
	while (ch>='0' && ch<='9') {x=x*10+ch-'0'; ch=getchar();}
	return x*f;
}

int n,m;
struct EdgeNode{int to,next;long long cap;}edge[maxm];
struct RoadNode{int to,next,len;}road[maxn<<1];
int head[maxn<<1],cnt=1,last[maxn],tot;
void addroad(int u,int v,int w) {
	tot++; road[tot].to=v; road[tot].next=last[u];
	last[u]=tot; road[tot].len=w;
}
void insertroad(int u,int v,int w) {addroad(u,v,w); addroad(v,u,w);}
void addedge(int u,int v,long long w) {
	cnt++; edge[cnt].next=head[u];
	head[u]=cnt; edge[cnt].to=v; edge[cnt].cap=w;
}
void insertedge(int u,int v,long long w) {addedge(u,v,w); addedge(v,u,0);}
long long dis[maxn]; int s,t; bool visit[maxn];

void spfa()
{
	for (int i=s; i<=t; i++) dis[i]=inf;
	queue<int>q; q.push(s); visit[s]=1; dis[s]=0;
	while (!q.empty())
	{
		int now=q.front(); q.pop(); visit[now]=0;
		for (int i=last[now]; i; i=road[i].next)
		if (dis[road[i].to]>dis[now]+road[i].len)
		{
			dis[road[i].to]=(long long)(dis[now]+road[i].len);
			if (!visit[road[i].to])
				visit[road[i].to]=1,q.push(road[i].to);
		}
	}
}
int h[maxn<<1],cur[maxn<<1],S,T;
queue<int>Q;
bool in[N];
long long xf[N];
int l[N];
long long PR()
{
	for(int i=S;i<=T;i++)if(i!=S)xf[i]=0,l[i]=0;else l[i]=T+1;
	for(int i=head[S];i;i=edge[i].next)
	{
		int v=edge[i].to;
		if(edge[i].cap==0)continue;
		edge[i^1].cap+=edge[i].cap;
		xf[v]+=edge[i].cap,xf[S]-=edge[i].cap;
		edge[i].cap=0;
		if(v!=S&&v!=T&&!in[v])Q.push(v),in[v]=1;
	}
	while(!Q.empty())
	{
		int u=Q.front();Q.pop();in[u]=0;
		for(int i=head[u];i;i=edge[i].next)
		{
			int v=edge[i].to;
			if(l[u]!=l[v]+1||edge[i].cap==0)continue;
			long long flow=min(edge[i].cap,xf[u]);
			edge[i].cap-=flow,edge[i^1].cap+=flow;
			xf[v]+=flow,xf[u]-=flow;
			//if(v==T)while(1);
			if(v!=S&&v!=T&&!in[v])Q.push(v),in[v]=1;
		}
		if(xf[u]==0)continue;
		int tmp=1000000000;
		for(int i=head[u];i;i=edge[i].next)
		{
			if(edge[i].cap==0)continue;
			tmp=min(tmp,l[edge[i].to]+1);
		}
		if(tmp<=2*(T+1)-1)
		{
			l[u]=tmp;
			if(!in[u])Q.push(u);
		}
	}
	return xf[T];
}
int tt[maxn],uu[maxm],vv[maxm],ww[maxm];
int main()
{
	n=read(),m=read();
	for (int i=1; i<=m; i++)
		uu[i]=read(),vv[i]=read(),ww[i]=read(),insertroad(uu[i],vv[i],ww[i]);
	s=1,t=n; spfa();
	for (int i=1; i<=n; i++) tt[i]=read();
		S=0; T=n*2+1;
	for (int i=2; i<=n-1; i++) insertedge(i,i+n,(long long)tt[i]);
	insertedge(S,1,inf); insertedge(1,1+n,inf); insertedge(n,n+n,inf);
	insertedge(n+n,T,inf);
	for (int i=1; i<=m; i++)
	{
		if (dis[uu[i]]+ww[i]==dis[vv[i]]) insertedge(uu[i]+n,vv[i],inf);
		if (dis[vv[i]]+ww[i]==dis[uu[i]]) insertedge(vv[i]+n,uu[i],inf);
	}
	printf("%lld\n",PR());
	return 0;
}
```


---

## 作者：xudaxia (赞：0)

## 震惊！我居然用费用流把这题水过去了。

首先先说一下思路：
把一个点拆为一个入点和一个出点。
然后入点向出点连一条流量为边权，费用为0的边。

然后原图中一条从$u$到$v$长度为$w$的边，对应着新建的图中一条从$u$的出点到$v$的入点费用为$w$，流量为INF的边和一条从$v$的出点到$u$的入点费用为$w$，流量为$INF$的边。

然后跑费用流。

因为费用流的原理是找最短路增广，所以当某一次的最短路与上一次的最短路不一样时，结束就行了。

也许很多人也这么想过，我也想过这样会$T$，但是人总是要有梦想。然后我一交果然$T$了。。。

之后我脑子里突然出现了一个神奇的想法，一个随机的图应该很多边都有重复。（虽然这种情况可以避免）我决定碰碰运气，我只把两个点之间最短的边留下建图。然后一交居然过了。。

我立马去$BZOJ$上交果然$T$了，所以我**建议加强一下数据！！！**

~~所以我就写了这篇题解。我知道一定审核不过，但是如果管理员不看的话，也许就有可能（滑稽）。如果看到的话就当做为社区做贡献了。~~
```cpp
// luogu-judger-enable-o2
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<queue>
using namespace std;
#define int long long
const int INF=1e14+1e8;
const int N=10100;
const int M=201000;
int book[N][N];
struct edge{
    int to,nxt,flow;
    long long cost;
}e[M*2];
int cnt=1,head[N];
void add_edge(int u,int v,int flow,long long cost){
    cnt++;
    e[cnt].nxt=head[u];
    e[cnt].to=v;
    e[cnt].flow=flow;
    e[cnt].cost=cost;
    head[u]=cnt;
    cnt++;
    e[cnt].nxt=head[v];
    e[cnt].to=u;
    e[cnt].flow=0;
    e[cnt].cost=-cost;
    head[v]=cnt;
}
long long dis[N],mn;
int road[N],ans,S,T,n,m;
bool vis[N];
bool spfa(){
    queue<int> q;
    for(int i=S;i<=T;i++)dis[i]=INF;
    memset(vis,0,sizeof(vis));
    dis[S]=0;
    vis[S]=1;
    q.push(S);
    while(!q.empty()){
        int u=q.front();
        q.pop();
        vis[u]=0;
        for(int i=head[u];i;i=e[i].nxt){
            int v=e[i].to;
            if(dis[v]>dis[u]+e[i].cost&&e[i].flow){
                dis[v]=dis[u]+e[i].cost;
                road[v]=i;
                if(vis[v]==0){
                    vis[v]=1;
                    q.push(v);
                }
            }
        }
    }
    if(dis[T]==INF)return false;
    if(mn==1e14)mn=min(mn,dis[T]);
    else if(dis[T]!=mn)return false;
    int minn=INF;
    for(int i=T;i!=S;i=e[road[i]^1].to)
        minn=min(minn,e[road[i]].flow);
    ans+=minn;
    for(int i=T;i!=S;i=e[road[i]^1].to){
        e[road[i]].flow-=minn;
        e[road[i]^1].flow+=minn;
    }
    return true;
}
int read(){
    int sum=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){sum=sum*10+ch-'0';ch=getchar();}
    return sum*f;
}
signed main(){
    n=read();m=read();
    for(int i=1;i<=m;i++){
        int u=read(),v=read(),w=read();
        if(book[u][v])book[u][v]=book[v][u]=min(book[u][v],w);
        else book[u][v]=book[v][u]=w;
    }
    for(int i=1;i<=n;i++)
    	for(int j=i+1;j<=n;j++)
    		if(book[i][j]){
        		add_edge(i+n,j,INF,book[i][j]);
        		add_edge(j+n,i,INF,book[i][j]);
    		}
    for(int i=1;i<=n;i++){
        int w=read();
        if(i==1||i==n)add_edge(i,i+n,INF,0);
        else add_edge(i,i+n,w,0);
    }
    S=1;T=n+n;
    mn=1e14;
    while(spfa());
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：东寺丶闲人 (赞：0)

###Dinic+SPFA

###开long long

###如果看过上面两条还没明白的，问题应该就在怎么在spfa之后找出最短路径。可以遍历一边所有点及其相邻点，若v[y]==v[i]+E[o].w则在最短路径中。具体见代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 200005
#define inf 9223372036854775807
#define int long long
int n,S=1,T,m,num_e=1,ans,num_E=1;
int head[maxn],dis[maxn],had[maxn];
bool in_que[maxn];
int vis[maxn],v[maxn],maxx[maxn];
struct edge{
    int to,nex,rest,w;
}e[maxn],E[maxn];
void add(int x,int y,int z){
    E[++num_E].to=y;E[num_E].nex=had[x];had[x]=num_E;E[num_E].w=z;
    E[++num_E].to=x;E[num_E].nex=had[y];had[y]=num_E;E[num_E].w=z;
}
void add_edge(int x,int y,int z){
    e[++num_e].to=y;e[num_e].nex=head[x];head[x]=num_e;e[num_e].rest=z;
    e[++num_e].to=x;e[num_e].nex=head[y];head[y]=num_e;e[num_e].rest=0;
}
void SPFA(){
    queue<int> q;
    q.push(S);
    in_que[S]=true;
    for(int i=1;i<=n;i++) v[i]=inf;
    v[S]=0;
    while(!q.empty()){
        int x=q.front();q.pop();in_que[x]=false;
        for(int i=had[x];i;i=E[i].nex){
            int y=E[i].to;
            if(v[y]>v[x]+E[i].w){
                v[y]=v[x]+E[i].w;
                if(!in_que[y]) q.push(y),in_que[y]=true;
            }
        }
    }
    for(int i=1;i<=n;i++){
        add_edge(i,i+n,maxx[i]);
        for(int o=had[i];o;o=E[o].nex){
            int y=E[o].to;
            if(v[y]==v[i]+E[o].w){
                add_edge(i+n,y,inf);
            }
        }
    }
}
bool bfs(){
    memset(dis,0,sizeof(dis));
    queue<int> q;
    q.push(S);
    dis[S]=1;
    while(!q.empty()){
        int x=q.front();q.pop();
        for(int i=head[x];i;i=e[i].nex){
            int y=e[i].to;
            if(!dis[y]&&e[i].rest) dis[y]=dis[x]+1,q.push(y);
        }
    }
    if(dis[T]) return true;
    return false;
}
int dfs(int x,int minn){
    if(x==T) return minn;
    int sum=0,qaq=0;
    for(int i=head[x];i;i=e[i].nex){
        int y=e[i].to;
        if(dis[y]==dis[x]+1&&e[i].rest){
            qaq=dfs(y,min(minn-sum,e[i].rest));
            e[i].rest-=qaq;
            e[i^1].rest+=qaq;
            sum+=qaq;
            if(sum==minn) return sum;
        }
    }
    if(!sum) dis[x]=0;
    return sum;
}
int dinic(){
    int anss=0;
    while(bfs()) anss+=dfs(S,inf);
    return anss;
}
int b[maxn];
#undef int
int main(){
    scanf("%lld%lld",&n,&m);
    int a,b,c;
    for(int i=1;i<=m;i++){
        scanf("%d%d%d",&a,&b,&c);
        add(a,b,c);
    }
    for(int i=1;i<=n;i++) scanf("%lld",&maxx[i]);
    maxx[1]=maxx[n]=inf;
    SPFA();S=1;T=n*2;
    printf("%lld",dinic());

    return 0;
}

```

---

## 作者：Mys_C_K (赞：0)

哇塞楼下初中生都开始做网络流了啊伤QwQ

最短路网络流套路模板，

最短路貌似选用不加对优化的dijkstra或者spfa更好？不管反正写dijk+heap写习惯了就懒得改了QwQ

网络流采用dinic，套路是拆点。

本题解主要是用来膜拜楼下ccj大佬的QwQ【逃

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
#include<queue>
#include<climits>
#define INF (LLONG_MAX/3)
#define MAXN 1010
#define MAXM 200010
#define lint long long
#define debug(x) cerr<<#x<<"="<<x
#define sp <<" "
#define ln <<endl
using namespace std;
int n;bool vis[MAXN];lint d[MAXN];
struct node{
    int to,wgt;
    node(int _t,int _w)
    {
        to=_t;
        wgt=_w;
    }
};
vector<node> g[MAXN];
struct heapnode{
    int id;lint dist;
    heapnode(int _i,lint _d)
    {
        id=_i;
        dist=_d;
    }
    bool operator<(const heapnode &hn)const
    {
        return this->dist>hn.dist;
    }
};
priority_queue<heapnode> heap;
struct edges{
    int to,pre;lint resf;
}e[MAXM];
int etop,h[MAXN],cur[MAXN];
inline int add_edge(int u,int v,lint c)
{
    etop++;
    e[etop].to=v;
    e[etop].resf=c;
    e[etop].pre=h[u];
    h[u]=etop;
    return 0;
}
inline int build_edge(int u,int v,lint c)
{
    add_edge(u,v,c),add_edge(v,u,0);return 0;
}
lint dijkstra(int s,int t)
{
    memset(vis,false,sizeof(vis));
    while(!heap.empty()) heap.pop();
    for(int i=1;i<=n;i++) d[i]=INF;
    heap.push(heapnode(s,d[s]=0));
    while(!heap.empty())
    {
        int x=heap.top().id;heap.pop();
        if(vis[x]) continue;vis[x]=true;
        for(int i=0;i<g[x].size();i++)
        {
            int v=g[x][i].to;lint w=g[x][i].wgt;
            if(!vis[v]&&d[v]>d[x]+w)
                heap.push(heapnode(v,d[v]=d[x]+w));
        }
    }
    return d[t];
}
queue<int> q;int lev[MAXN];
inline bool bfs(int s,int t)
{
    memset(vis,false,sizeof(vis));
    while(!q.empty()) q.pop();
    memset(lev,0,sizeof(lev));
    lev[s]=0;q.push(s);vis[s]=true;
    while(!q.empty())
    {
        int x=q.front();q.pop();
        for(int i=h[x];i;i=e[i].pre)
            if(!vis[e[i].to]&&e[i].resf)
            {
                vis[e[i].to]=true;
                lev[e[i].to]=lev[x]+1;
                q.push(e[i].to);
            }
    }
    return vis[t];
}
inline lint dfs(int s,int t,lint a)
{
    if(s==t||!a) return a;
    lint flow=0,f;
    for(int &i=cur[s];i;i=e[i].pre)
        if(lev[e[i].to]==lev[s]+1&&(f=dfs(e[i].to,t,min(e[i].resf,a)))>0)
        {
            a-=f;flow+=f;e[i].resf-=f;
            e[((i-1)^1)+1].resf+=f;
            if(!a) break;
        }
    return flow;
}
int main()
{
    int m;scanf("%d%d",&n,&m);
    while(m--)
    {
        int u,v,w;scanf("%d%d%d",&u,&v,&w);
        g[u].push_back(node(v,w));
        g[v].push_back(node(u,w));
    }
    for(int i=1;i<=n;i++)
    {
        int c;scanf("%d",&c);
        if(i==1||i==n) build_edge(i,i+n,INF);
        else build_edge(i,i+n,c);
    }
    int s=1,t=n<<1;
    dijkstra(1,n);
    for(int i=1;i<=n;i++)
        for(int j=0;j<g[i].size();j++)
            if(d[i]+g[i][j].wgt==d[g[i][j].to])
                build_edge(i+n,g[i][j].to,INF);
    lint flow=0;
    while(bfs(s,t))
    {
        for(int i=s;i<=t;i++)
            cur[i]=h[i];
        flow+=dfs(s,t,INF);
    }
    printf("%lld\n",flow);return 0;
}
```

---

## 作者：Tyw_ei (赞：0)

看上去没有一份像样的题解；

其实是一道不算难的省选题，就是练练板子（spfa+最大流）；

把最短路跑出来后根据dis[a[i]]+w[i]==dis[b[i]],来建网络流的图；

注意开long long！

~~~










```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <queue>
#define N 100005
#define LL long long
using namespace std;
LL LINF=1;
struct node{
    int a,b,nt;
    LL w;
}e[N],mp[N];
int cnt,p[N],dis[N],d[N],cur[N],qq[N*4],n,m;bool vis[N];
queue<int>q;
void add(int x,int y,LL z){
    cnt++;
    e[cnt].a=x;e[cnt].b=y;e[cnt].w=z;
    e[cnt].nt=p[x];
    p[x]=cnt;
}
void add1(int x,int y,LL z){
    cnt++;
    mp[cnt].a=x;mp[cnt].b=y;mp[cnt].w=z;
    mp[cnt].nt=p[x];
    p[x]=cnt;
}
void spfa(){
    memset(dis,63,sizeof(dis));
    q.push(1);
    vis[1]=true;dis[1]=0;
    while(!q.empty()){
        int k=q.front();q.pop();vis[k]=false;
        for(int i=p[k];i;i=e[i].nt){
            int kk=e[i].b;
            if(dis[kk]>dis[k]+e[i].w){
                dis[kk]=dis[k]+e[i].w;
                if(!vis[kk]){
                    vis[kk]=true;
                    q.push(kk);
                }
            }
        }
    }
}
int bfs(){
    memset(d,-1,sizeof(d));
    int head=0,tail=1;
    qq[0]=1;d[1]=0;
    while(head<tail){
        int k=qq[head];head++;
        cur[k]=p[k];
        for(int i=p[k];i;i=mp[i].nt){
            int kk=mp[i].b;
            if(mp[i].w>0&&d[kk]<0){
                d[kk]=d[k]+1;
                qq[tail++]=kk;
            }
        }
    }
    if(d[2*n]<0)return 0;
    else return 1;
}
int deal(int x){
    if(x&1)return x+1;
    else return x-1;
}
LL dfs1(int k,LL flow){
    LL a=0;
    if(k==2*n)return flow;
    for(int i=p[k];i;i=mp[i].nt){
        int kk=mp[i].b;
        if(mp[i].w>0&&d[kk]==d[k]+1)
            if(a=dfs1(kk,min(flow,mp[i].w))){
                   //cur[k]=i;
                mp[i].w-=a;
                mp[deal(i)].w+=a;
                return a;
            }
    }
    return 0;
}
LL dfs(int k,LL flow){
    LL a=0;
    if(k==2*n)return flow;
    for(int i=cur[k];i;i=mp[i].nt){
        int kk=mp[i].b;
        if(mp[i].w>0&&d[kk]==d[k]+1){
            LL f=dfs(kk,min(flow-a,mp[i].w));
            a+=f;
            mp[i].w-=f;
            mp[deal(i)].w+=f;
        }
    }
    return a;
}
int main()
{
    for(int i=1;i<=60;i++)LINF*=2;
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        int x,y;
        LL z;
        scanf("%d%d%lld",&x,&y,&z);
        add(x,y,z);
        add(y,x,z);
    }
    spfa();
    for(int i=1;i<=2*n;i++)p[i]=0;
    for(int i=1;i<=2*m;i+=2){
        if(dis[e[i].a]+e[i].w==dis[e[i].b]){
            add1(e[i].a+n,e[i].b,LINF);
            add1(e[i].b,e[i].a+n,0);
        }
        if(dis[e[i].b]+e[i].w==dis[e[i].a]){
            add1(e[i].b+n,e[i].a,LINF);
            add1(e[i].a,e[i].b+n,0);
        }
    }
    for(int i=1;i<=n;i++){
        LL c;scanf("%lld",&c);
        if(i!=1&&i!=n)add1(i,i+n,c);
        else add1(i,i+n,LINF);
        add1(i+n,i,0);
    }
    LL ans=0;
    while(bfs()){
        LL t;
        while(t=dfs(1,1<<30))ans+=t;
    }
    cout<<ans;
    return 0;
}
```
~~~

---

## 作者：ljt12138 (赞：0)

题面即题解的题...思路很显然，**先用dijkstra跑出最短路，然后倒着建一张最短路图，然后随便跑最大流就好了。**

唯一坑的是精度问题..一定注意用long long，INF要够大..


```cpp
#include <bits/stdc++.h>
using namespace std;

struct graph{
    struct node {
        int to, next, neg;
        long long dis;
    }edge[400005];
    int head[505], top;
    graph(){top = 0; memset(head, 0, sizeof head);}
    void push(int i, int j, long long k)
    {
        edge[++top].to = j;
        edge[top].dis  = k;
        edge[top].next = head[i];
        head[i] = top;
    }
}g_nor, g_build;

int n, m;
long long siz[505];
long long dis[505];
int did[505][505];
int vis[505];

void dijkstra()
{
    memset(dis, 0x7f, sizeof dis);
    memset(vis, 0, sizeof vis);
    memset(did, 0, sizeof did);
    dis[1] = 0;
    for (int i = 2; i <= n; i++) {
        int k = 0;
        for (int j = 1; j <= n; j++)
            if (!vis[j] && dis[j] < dis[k])
                k = j;
        vis[k] = 1;
        for (int j = g_nor.head[k]; j; j = g_nor.edge[j].next)
            dis[g_nor.edge[j].to] = min(dis[g_nor.edge[j].to], dis[k]+g_nor.edge[j].dis);
    }
}

void build(int i)
{
    for (int k = g_nor.head[i]; k; k = g_nor.edge[k].next) {
        int to = g_nor.edge[k].to; long long d = g_nor.edge[k].dis;
        if (dis[to] + d == dis[i] && !did[to][i]) {
            g_build.push(to, i, min(siz[to], siz[i]));
            g_build.push(i, to, 0);
            g_build.edge[g_build.top].neg = g_build.top-1;
            g_build.edge[g_build.top-1].neg = g_build.top;
            did[to][i] = 1;
            build(to);
        }
    }
}

int S, T;
int lev[505], bfstime = 0;
queue<int> que;
bool bfs()
{
    lev[S] = 1; vis[S] = ++bfstime;
    que.push(S);
    while (!que.empty()) {
        int t = que.front(); que.pop();
        for (int k = g_build.head[t]; k; k = g_build.edge[k].next) {
            if (!g_build.edge[k].dis || vis[g_build.edge[k].to] == bfstime) continue;
            int to = g_build.edge[k].to;
            lev[to] = lev[t] + 1;
            vis[to] = bfstime;
            que.push(to);
        }
    }
    return vis[T] == bfstime;
}
long long dfs(int nd, long long maxflow)
{
    if (nd == T || !maxflow) return maxflow;
    long long ans = 0, t;
    for (int k = g_build.head[nd]; k; k = g_build.edge[k].next) {
        if (!g_build.edge[k].dis || lev[g_build.edge[k].to] != lev[nd]+1) continue;
        int to = g_build.edge[k].to, neg = g_build.edge[k].neg;
        long long d = g_build.edge[k].dis;
        t = dfs(to, min(maxflow, d));
        maxflow -= t;
        ans += t;
        g_build.edge[k].dis -= t;
        g_build.edge[neg].dis += t;
    }
    if (maxflow) lev[nd] = -1;
    return ans;
}
long long dinic()
{
    long long ans = 0; S = 1, T = n;
    while (bfs())
        ans += dfs(S, LONG_MAX);
    return ans;
}

int main()
{
    //freopen("cqoi15_network.in", "r", stdin);
    //freopen("cqoi15_network.out", "w", stdout);
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i++) {
        int a, b;
        long long d;
        scanf("%d%d%lld", &a, &b, &d);
        g_nor.push(a, b, d);
        g_nor.push(b, a, d);
    }
    for (int i = 1; i <= n; i++)
        scanf("%lld", &siz[i]);
    siz[1] = siz[n] = 1ll<<60;
    dijkstra();
    build(n);
    memset(vis, 0, sizeof vis);
    cout << dinic() << endl;
    return 0;
}
```

---


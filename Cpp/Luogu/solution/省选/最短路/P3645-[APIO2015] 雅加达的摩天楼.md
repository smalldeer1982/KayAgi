# [APIO2015] 雅加达的摩天楼

## 题目描述

印尼首都雅加达市有 $N$ 座摩天楼，它们排列成一条直线，我们从左到右依次将它们编号为 $0$ 到 $N − 1$。除了这 $N$ 座摩天楼外，雅加达市没有其他摩天楼。

有 $M$ 只叫做 “doge” 的神秘生物在雅加达市居住，它们的编号依次是 $0$ 到 $M − 1$。编号为 $i$ 的 doge 最初居住于编号为 $B_i$ 的摩天楼。每只 doge 都有一种神秘的力量，使它们能够在摩天楼之间跳跃，编号为 $i$ 的 doge 的跳跃能力为 $P_i$ （$P_i > 0$）。

在一次跳跃中，位于摩天楼 $b$ 而跳跃能力为 $p$ 的 doge 可以跳跃到编号为 $b - p$ （如果 $0 \leq b - p < N$）或 $b + p$ （如果 $0 \leq b + p < N$）的摩天楼。

编号为 $0$ 的 doge 是所有 doge 的首领，它有一条紧急的消息要尽快传送给编号为 $1$ 的 doge。任何一个收到消息的 doge 有以下两个选择:

- 跳跃到其他摩天楼上；
- 将消息传递给它当前所在的摩天楼上的其他 doge。

请帮助 doge 们计算将消息从 $0$ 号 doge 传递到 $1$ 号 doge 所需要的最少总跳跃步数，或者告诉它们消息永远不可能传递到 $1$ 号 doge。


## 说明/提示

【样例解释】

下面是一种步数为 $5$ 的解决方案：

$0$ 号 doge 跳跃到 $2$ 号摩天楼，再跳跃到 $4$ 号摩天楼（$2$ 步）。

$0$ 号 doge 将消息传递给 $2$ 号 doge。

$2$ 号 doge 跳跃到 $3$ 号摩天楼,接着跳跃到 $2$ 号摩天楼，再跳跃到 $1$ 号摩天楼（$3$ 步）。

$2$ 号 doge 将消息传递给 $1$ 号 doge。

【数据范围】

所有数据都保证 $0 \leq B_i < N$。

子任务 1 （10 分）$1 \leq N \leq 10$

$1 \leq P_i \leq 10$

$2 \leq M \leq 3$


子任务 2 （12 分）$1 \leq N \leq 100$

$1 \leq P_i \leq 100$

$2 \leq M \leq 2000$


子任务 3 （14 分）$1 \leq N \leq 2000$

$1 \leq P i ≤ 2000$

$2 \leq M \leq 2000$


子任务 4 （21 分）$1 \leq N \leq 2000$

$1 \leq P_i \leq 2000$

$2 \leq M \leq 30000$


子任务 5 （43 分）$1 \leq N \leq 30000$

$1 \leq P_i \leq 30000$

$2 \leq M \leq 30000$


## 样例 #1

### 输入

```
5 3
0 2
1 1
4 1```

### 输出

```
5```

# 题解

## 作者：浮尘ii (赞：58)

根本不需要最短路算法，这是一个无权图最短路，所以直接 BFS 就行。

也不需要显式建图，直接 BFS 转移即可。

状态 $(i,j)$ 表示，当前在第 $i$ 个点，当前的 doge 跳跃能力为 $j$。

当 $j \le \sqrt{n}$ 时，只有 $n \sqrt{n}$ 个状态。

当 $j \gt \sqrt{n}$ 时，只有 $m \sqrt{n}$ 个状态（最多有 $m$ 只 doge，每只 doge 只有 $\frac{n}{j}\lt \sqrt{n}$ 个可行位置）。

$(i,j)$ 可以转移到 $(i-j, j)(i-j\ge0)$ 和 $(i+j,j) (i+j\lt n)$，同时对于第一次访问到的 $i$，把初始在 $i$ 的所有 doge 加入队列。

状态判重时使用 `std::set` 会 TLE，可以用 hash 或者 `std::bitset`。

时间复杂度 $O((n+m)\sqrt{n})$。

另外原题数据有点水，同时洛谷只取了原题的很少一部分数据所以更水，建议大家去 [UOJ](http://uoj.ac/problem/111) 提交此题以进一步检验程序正确性。

```cpp
#include <queue>
#include <tuple>
#include <bitset>
#include <cstdio>
#include <vector>
#include <algorithm>

const int maxN = 30005;

int N, M, S, T;
std::vector<int> Doge[maxN];
std::queue<std::tuple<int, int, int>> Q;
std::bitset<maxN> vis[maxN];
bool Vis[maxN];

void insert(int i, int p, int step)
{
	if (!Vis[i])
	{
		Vis[i] = true;
		for (auto x : Doge[i])
			if (!vis[i].test(x))
				vis[i].set(x), Q.emplace(i, x, step);
	}
	if (!vis[i].test(p))
		vis[i].set(p), Q.emplace(i, p, step);
}

int main()
{
	scanf("%d%d", &N, &M);
	for (int i = 0, b, p; i != M; ++i)
	{
		scanf("%d%d", &b, &p);
		if (i == 0)
			S = b;
		if (i == 1)
			T = b;
		Doge[b].push_back(p);
	}

	if (S == T)
	{
		puts("0");
		return 0;
	}

	Vis[S] = true;
	for (auto x : Doge[S])
		if (!vis[S].test(x))
		{
			vis[S].set(x);
			Q.emplace(S, x, 0);
		}

	while (!Q.empty())
	{
		int i, p, step;
		std::tie(i, p, step) = Q.front();
		Q.pop();
		if (i - p == T || i + p == T)
		{
			printf("%d\n", step + 1);
			return 0;
		}
		if (i - p >= 0)
			insert(i - p, p, step + 1);
		if (i + p < N)
			insert(i + p, p, step + 1);
	}

	puts("-1");

	return 0;
}
```

---

## 作者：StudyingFather (赞：25)

## 一种建模方法（直接连边）

对于每个 doge 所在点，我们直接从出发点向其可达点连边，边权为需要跳的步数。

在建成的图上直接跑最短路即可。

这种情况下，图上的边规模最大可能达到 $O(n^2)$（本文默认 $n,m$ 同阶）。

## 另一种建模方法（分层图）

我们发现直接连边过程中，边可以拆分。

例如 $u \to p \to v$ 这条路径，我们连了 $u \to p$，$u \to v$ 两条边，事实上我们可以连 $u \to p$，$p \to v$ 这两条边，达到同样的目的。

但是直接在原图上连边会出问题。原因在于我们到某个中间点的时候，并不一定能就地更换 doge。

考虑建立分层图。对于每个 doge 建立 $n$ 个点，这 $n$ 个点之间按上文的方式连边，同时这 $n$ 个点可以向原图相对应的点，连一条边权为 $0$ 的单向边（表示可以更换 doge），从原图中 doge 所在的出发位置向其所在的层中的对应点，连一条边权为 $0$ 的单向边（意义同上）。

事实上这种建模方式，在最坏情况下连边的数量仍然为 $O(n^2)$。

## 满分做法

联想到根号分治，我们想到一种利用分块思想，结合上面两种建图方式，实现优化的方法：设置一个分界点 $k$，对于 $p \leq k$ 的 doge，采用分层图方式建图，而对于 $p \geq k$ 的 doge，则采用直接连边的方式建图。

问题在于这个分界点 $k$ 该取到多少？

我们可以证明，当 $k=\sqrt{\dfrac{n}{3}}$ 时，图上的边数达到最少。

下面是证明：

- 对于采用分层图建图的部分，每个层的点需要连三条边（一条向左，一条向右，还有一条连向原图上的相应点），因为一共有 $k$ 层，故最多需要 $3kn$ 条边。
- 对于直接连边建图的部分，每个点最多需要对外连 $\dfrac{n}{k}$ 条边，故最多有 $\dfrac{n^2}{k}$ 条边。
- 即总边数为 $3kn+\dfrac{n^2}{k}$ 条边。
- 由均值不等式可知，当 $3kn=\dfrac{n^2}{k}$，即 $k=\sqrt{\dfrac{n}{3}}$ 时，图上的边数达到最小值 $2n\sqrt{3n}$。

## 细节

1. 把图建出来需要的内存空间较大（虽然注意实现细节的话，并不会超过内存限制），可以考虑不显式连边，而是在转移的时候进行讨论。
2. 总点数和边数较大，注意常数。

```cpp
// Problem: P3645 [APIO2015] 雅加达的摩天楼
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P3645
// Author : StudyingFather
// Site : https://studyingfather.com
// Memory Limit: 256 MB
// Time Limit: 1000 ms
//
// Powered by CP Editor (https://cpeditor.org)

#include <cmath>
#include <cstring>
#include <iostream>
#include <queue>
using namespace std;
typedef pair<int, int> pii;
const int INF = 0x3f3f3f3f;
struct edge {
  int v, w, next;
} e[18000005];
int head[3100005], id[105][30005], dis[3100005], cnt;
bool vis[3100005];
int n, m;
void addedge(int u, int v, int w) {
  e[++cnt].v = v;
  e[cnt].w = w;
  e[cnt].next = head[u];
  head[u] = cnt;
}
int dijkstra(int s, int t) {
  priority_queue<pii, vector<pii>, greater<pii> > pq;
  memset(dis, INF, sizeof(dis));
  dis[s] = 0;
  pq.push(make_pair(0, s));
  while (!pq.empty()) {
    int u = pq.top().second;
    pq.pop();
    if (vis[u]) continue;
    vis[u] = true;
    for (int i = head[u]; i; i = e[i].next) {
      int v = e[i].v;
      if (dis[v] > dis[u] + e[i].w) {
        dis[v] = dis[u] + e[i].w;
        pq.push(make_pair(dis[v], v));
      }
    }
  }
  return dis[t] != INF ? dis[t] : -1;
}
int main() {
  ios::sync_with_stdio(false);
  cin >> n >> m;
  int maxp = sqrt(n / 3);
  int s, t;
  for (int i = 1; i <= maxp; i++)
    for (int j = 0; j < n; j++) id[i][j] = i * n + j;
  for (int i = 1; i <= maxp; i++)
    for (int j = 0; j < n; j++) {
      addedge(id[i][j], j, 0);
      if (i + j >= n) break;
      addedge(id[i][j], id[i][j + i], 1);
      addedge(id[i][j + i], id[i][j], 1);
    }
  for (int i = 0; i < m; i++) {
    int b, p;
    cin >> b >> p;
    if (p <= maxp)
      addedge(b, id[p][b], 0);
    else {
      for (int j = 1; b + j * p < n; j++) addedge(b, b + j * p, j);
      for (int j = 1; b - j * p >= 0; j++) addedge(b, b - j * p, j);
    }
    if (i == 0) s = b;
    if (i == 1) t = b;
  }
  for (int i = 1; i <= maxp; i++)
    for (int j = 0; j < n; j++)
      if (head[id[i][j]]) addedge(id[i][j], j, 0);
  cout << dijkstra(s, t) << endl;
  return 0;
}
```

---

## 作者：GoldenPotato137 (赞：14)

[戳我获得更好的阅读体验qwq](https://www.goldenpotato.cn/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/luogu-p3645-apio2015%E9%9B%85%E5%8A%A0%E8%BE%BE%E7%9A%84%E6%91%A9%E5%A4%A9%E6%A5%BC/)

---
# Solution
与其说这题是分块妙题，我更倾向于把这题称为分层图妙题。

这题有一个一眼贪心做法：**对于每只doge，我们都暴力地去建它连向它能跳到的点的边，边权为跳的次数。然后直接求一遍单元最短路即可**。

很显然，这玩意的边的数量是$O(n^2)$的，求一遍最短路的复杂度达到了惊人的$n^2logn^2$

这显然是要T飞的，但是我们会从中发现一个问题：既然一个doge的跳跃是多步的，那我们能否直接把几步拆开来，然后省略重复的边？
例如：
![Au13S1.png](https://s2.ax1x.com/2019/03/19/Au13S1.png)
优化为：
![Au8AbT.png](https://s2.ax1x.com/2019/03/19/Au8AbT.png)

这样做看起来很星，很不幸的是，这样是不行的。因为我们在计算最短路的时候，我们有可能直接从中间某个点出发，但是很不幸的是，这样是不可行的。

怎么办呢？这时我们可以考虑把网络流的分层图那一套搬出来。
我们可以考虑使用“拆点”的做法来限制从某个点出发去更新别的点的最短路。
考虑把一个点拆分为size个点，**每个拆分点的含义为所有一次跳x步的都从它出发，并到达它那里**。

**从每个点的拆分点出发，向它的原点连一条边权为0的有向边**

**如果能从某个点出发，则对应的从原点连向那个跳x格远的分点连一条边权为0的边**

**接下来我们从每个点的对应的跳x格远的的点连向其他的点的跳x格的点，边权为1**

一图胜千言：
![AuUNi8.png](https://s2.ax1x.com/2019/03/19/AuUNi8.png)
变为
**最后一行的所有点即为原来的点**
**从下往上第x行的点即为某个原点的第x个分点**
[![AuaFfS.png](https://s2.ax1x.com/2019/03/19/AuaFfS.png)](https://imgchr.com/i/AuaFfS)

通过这样一轮拆分，我们就已经可以解决问题啦。

啥？你说这样会有$n^2$个点？这是就得用到分块思想啦。你想，如果一个doge一次能跳的距离超过$\sqrt n$格远，那总共连出来的边不会超过$\sqrt n$条，我们直接在原点连就好啦qwq。


~~根据玄学证明，这里的块大小取100是最好的（我并不会证）~~
时间复杂度O(能过)

---
# Code
```cpp
// luogu-judger-enable-o2
#include<iostream>
#include<cstdio>
#include<vector>
#include<cmath>
#include<cstring>
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=30000+100;
const int M=100+20;
struct edge
{
    int to,w;
    edge (int x,int y)
    {
        to=x,w=y;
    }
};
vector <edge> e[N*M];
int n,m,size,dis[N*M],S,T;
void spfa()
{
    static int InQueue[N*M],mqueue[N*M*10],front,tail;
    memset(dis,0x3f,sizeof dis);
    front=tail=0;
    mqueue[tail++]=S*size,dis[S*size]=0;
    while(tail>front)
    {
        int now=mqueue[front++];
        InQueue[now]=false;
        for(int i=0;i<int(e[now].size());i++)
            if(dis[e[now][i].to]>dis[now]+e[now][i].w)
            {
                dis[e[now][i].to]=dis[now]+e[now][i].w;
                if(InQueue[e[now][i].to]==false)
                {
                    InQueue[e[now][i].to]=true;
                    mqueue[tail++]=e[now][i].to;
                }
            }
    }
}
int main()
{
    //freopen("3645.in","r",stdin);
    //freopen("3645.out","w",stdout);
    
    int t=clock();
    n=read(),m=read();
    size=min(int(sqrt(n)),50);
    int to=n*size;
    for(int i=1;i<=to;i++)
        e[i].reserve(4);
    for(int i=0;i<n;i++)
        for(int j=1;j<size;j++)
            e[i*size+j].push_back(edge(i*size,0));
    for(int i=1;i<=m;i++)
    {
        int b=read(),p=read();
        if(i==1) S=b;
        if(i==2) T=b;
        if(p>=size)
        {
            for(int j=b+p,k=1;j<n;j+=p,k++)
                e[b*size].push_back(edge(j*size,k));
            for(int j=b-p,k=1;j>=0;j-=p,k++)
                e[b*size].push_back(edge(j*size,k));
        }
        else
        {
            e[b*size].push_back(edge(b*size+p,0));
            for(int j=b;j<n-p;j+=p)
            {
                bool OK=false;
                for(int k=0;k<int(e[j*size+p].size());k++)
                    if(e[j*size+p][k].to==(j+p)*size+p)
                    {
                        OK=true;
                        break;
                    }
                if(OK==true) break;
                e[j*size+p].push_back(edge((j+p)*size+p,1));
            }
            for(int j=b;j>=p;j-=p)
            {
                bool OK=false;
                for(int k=0;k<int(e[j*size+p].size());k++)
                    if(e[j*size+p][k].to==(j-p)*size+p)
                    {
                        OK=true;
                        break;
                    }
                if(OK==true) break;
                e[j*size+p].push_back(edge((j-p)*size+p,1));
            }
        }
    }
    
    spfa();
    
    if(dis[T*size]<0x3f3f3f3f)
        printf("%d",dis[T*size]);
    else
        printf("-1");
    cerr<<clock()-t;
    return 0;
}

```






---

## 作者：TopCarry (赞：13)

事实上,块的大小不是sqrt(n)，对sqrt(n)和100取min也不是什么严谨的做法，仅仅是碰巧卡过去了而已。

关于分块优化建图之前的题解都说了，但分块常常要根据实际调整块的大小，比如在这道题当中，设这个界限为k,对于>k的暴力连边，每个点最多跳n/k次,最多有n*(n/k)条边，<k的在k层“虚”图预处理连边，因为每个“虚”点往左右下连三条边，每层n个点，共有3nk条边，所以边数m=3kn+n*n/k.

可以发现这是一个对勾函数，在3k^2=n即k=sqrt(n/3)时取最小值，而我们最短路算法的时间复杂度和空间复杂度都和边数成正比，所以按照这个大小分块为最优。

当大家把n=30000带进去,会发现k=sqrt(n/3)=100，这就是为什么前面的题解通过对100取min卡过去了。

另外这样算m最多为18000000,是可以开的下的，虽然其实可以不用真的开出来，因为每一层的建图规则是固定的，所有边的长度是固定的,那么可以在过程中加上判断直接跳过去而不真的连边。（~~然而懒惰的我还是连了~~）

最后说一点：spfa诈尸了，但djikstra吸氧也没有问题。
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<queue>
using namespace std;
static char buf[100000],*pa,*pd;
#define gc pa==pd&&(pd=(pa=buf)+fread(buf,1,100000,stdin),pa==pd)?EOF:*pa++
inline int read(){
    register int x(0);register char c(gc);
    while(c>'9'||c<'0')c=gc;
    while(c>='0'&&c<='9')x=x*10+c-48,c=gc;
    return x;
}
const int N=3100000; 
struct edge{
    int to,w,next;
}e[18100000];
int head[N],tot;
void add(int x,int y,int z){
    e[++tot].to=y;e[tot].next=head[x];e[tot].w=z;head[x]=tot;
} 
int block,m,n,dis[N];
#define get(a,b) (a*n+b)
void build(int Floor){
    register int i;
    for(i=get(Floor,Floor);i<=get(Floor,n-1-Floor);i++){
        add(i,i+Floor,1);
        add(i,i-Floor,1);
    }
    for(i=get(Floor,0);i<=get(Floor,Floor-1);i++)
        add(i,i+Floor,1);
    for(i=get(Floor,n-Floor);i<=get(Floor,n-1);i++)
        add(i,i-Floor,1);
    for(i=0;i<n;i++)add(get(Floor,i),i,0);
}
int S,T;
void init(){
    register int i,x,p;
    for(i=1;i<=block;i++)
        build(i);
    for(i=1;i<=m;i++){
        x=read();p=read();
        if(i==1)S=x;
        if(i==2)T=x;
        if(p<=block)add(x,get(p,x),0);
        else{
            int cnt=1;
            while(x+cnt*p<n){
                add(x,x+cnt*p,cnt);
                cnt++;
            }
            cnt=1;
            while(x-cnt*p>=0){
                add(x,x-cnt*p,cnt);
                cnt++;
            }
        }
    }
}
queue<int> q;
bool vis[N];
void spfa(){
	register int i;
	memset(dis,127,sizeof(dis));
	dis[S]=0;vis[S]=1;q.push(S);
	while(!q.empty()){
		int u=q.front();q.pop();vis[u]=0;
		for(i=head[u];i;i=e[i].next)
			if(dis[u]+e[i].w<dis[e[i].to]){
				dis[e[i].to]=dis[u]+e[i].w;
				if(!vis[e[i].to]){
					vis[e[i].to]=1;
					q.push(e[i].to);
				}
			}
	}
	if(dis[T]<2000000000)
    cout<<dis[T];
    else cout<<-1; 
}
int main(){
    n=read();m=read();
    block=sqrt(n/3);
    init();
    spfa();
}
```

---

## 作者：RichardSong (赞：10)

# Problem

有 $m$ 只 $doge$ 分布在 $n$ 个摩天大楼上。楼和 $doge$ 都是从 $0$ 开始编号。

每只 $doge$ 初始位置 $b[i]$ ，弹跳力 $p[i]$。
它每一次跳会恰好跳 $p[i]$ 个大楼。比如从 $x$ 可以到 $x ± p[i]$。

现在， $0$ 号 $doge$ 要把某信息传给 $1$ 号 $doge$ 。
对于一只 $doge$ ，若它尚未知道信息，就不能动。
对于一只 $doge$ ，若它已经知道信息，可以选择把信息告诉处于同一位置的 $doge$ 们，或者跳去别的位置。

求最少跳的步数。

# Solution
### · 直观暴力
对于每一只 $doge$ ，我们从 $b[i]$ 连边到所有它可以跳到（可以跳好多步）的位置，边权为需要跳的次数。

从 $b[0]$ 跑一下最短路即可。

**Obviously，这个边数有点多。**


### · 追逐梦想
考虑一个问题。
一只 $doge$ 可以跳到的位置，显然是一个公差为 $p[i]$ 的等差数列。
我们如果把相邻两项用权为 $1$ 的边连起来，可行吗？

**事实证明，你连样例都过不了。**

![title](https://leanote.com/api/file/getImage?fileId=5b9a47b3ab644172f600392a)

如果你这样连边，你的答案是 $2$ 。而 $3$ 号点没 $doge$ ，并不可以跳。

但是对于这种情况，我们可以把它变成这样。

![title](https://leanote.com/api/file/getImage?fileId=5b9a493aab644172f6003981)


我们引入一个子图的概念，即，由 $n$ 个点构成，每个点 $i$ 都连向 $i + d$ 与 $i - d$ 。

这样连边肯定是没问题的。

然后我们用一波分块思想。对于 $d\in[1,\sqrt n$ $]$，我们建立子图，那么 $d_i ≤ \sqrt n$ 的每个点就只需要连一条边指向子图中的自己。

对于$d_i > \sqrt n$ 的部分，我们采用“直观暴力”部分的连边方式，显然边数不会超过 $\sqrt n$ 。

于是可以愉快的跑最短路了。

注意卡一下空间问题。

# Trick

1$^~$. dijkstra有可能会 tle ，但 spfa 不会。

2$^~$. 分块时不要真的按照 $\sqrt n$ ，要 $min(\sqrt n$ $,100 )$。

3$^*$. 你可以不必连边。因为连边的逻辑你是知道的，在跑 $spfa$ 的时候分情况现写一波就好。

4$^*$. UOJ Extra Test #8。
# Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define M 30010
inline char gc() {
    static char now[1<<16], *S, *T;
    if(S == T) {T = (S = now) + fread(now, 1, 1<<16, stdin); if(S == T) return EOF;}
    return *S++;
}
inline int read() {
    int x = 0, f = 1; char c = gc();
    while(c < '0' || c > '9') {if(c == '-') f = -1; c = gc();}
    while(c >= '0' && c <= '9') {x = x * 10 + c - 48; c = gc();}
    return x * f;
}
struct adj {int to, val, nxt;}e[M*500];
int n, m, b[M], p[M], hd[M*200], cnt = 1, blank;
inline void addedge(int x, int y, int z) {
    e[++cnt] = (adj){y, z, hd[x]}; hd[x] = cnt;
}
int dis[M*200]; queue<int> Q; bool inq[M*200];
inline int dijk(int st, int ed) {
    memset(dis, 63, sizeof(dis));
    memset(inq, 0, sizeof(inq));
    Q.push(st); inq[st] = 1; dis[st] = 0;
    while(!Q.empty()) {
        int u = Q.front(); Q.pop(); inq[u] = 0;
        for(int i = hd[u]; i; i = e[i].nxt) {
            int v = e[i].to;
            if(dis[v] > dis[u] + e[i].val) {
                dis[v] = dis[u] + e[i].val;
                if(!inq[v]) Q.push(v);
            }
        }
    }
    return dis[ed];
}
inline int id(int i, int k) {
    return n * k + i;
}
int main() {
    n = read(); m = read();
    int blank = min(100, (int)sqrt(n));
    for(int i = 1; i <= blank; ++i) {
        for(int j = 0; j + i < n; ++j) {
            addedge(id(j, i), id(j + i, i), 1);
            addedge(id(j + i, i), id(j, i), 1);
        }
        for(int j = 0; j < n; ++j) addedge(id(j, i), j, 0);
    }
    for(int i = 0; i <= m - 1; ++i) {
        b[i] = read(); p[i] = read();
        if(p[i] <= blank) {
            addedge(b[i], id(b[i], p[i]), 0);
        }else {
            for(int j = b[i] - p[i]; j >= 0; j-= p[i]) {
                addedge(b[i], j, (b[i] - j)/p[i]);
            }
            for(int j = b[i] + p[i]; j < n; j+= p[i]) {
                addedge(b[i], j, (j - b[i])/p[i]);
            }
        }
    }
    int ans = dijk(b[0], b[1]);
    printf("%d", (ans != 0x3f3f3f3f) ? ans : (-1));
    return 0;
}
```






---

## 作者：wurzang (赞：9)

这题本质就是个 bfs 啊。

考虑根号分治。对于 $p > \sqrt{n}$ ，可以到达的点不超过 $\sqrt{n} $ 个；对于 $p \leq \sqrt{n}$ ，可以走的距离不超过 $\sqrt{n}$ 。

因此可以直接取 $(b,p)$ 作为状态，表示我们的 doge 在 $b$ 点，可以走的距离为 $p$ ，这个状态数量肯定不超过 $n \sqrt{n}$ 个。


然后就可以用这个状态直接去 bfs，用 bitset 判重，时间复杂度为 $\mathcal{O}(n\sqrt{n})$ 或 $\mathcal{O}(\frac{nm}{w})$

$n \leq 3 \times 10^4$，因此 bitset 复杂度正确。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=30000+5;
bitset<N> vis[N];
vector<int> p[N];
struct node{
	int pos,jump,dep;
	node(){
	}
	node(int _p,int _j,int _d){
		pos=_p;jump=_j;dep=_d;
	}
};
deque<node> q;
int n,B[N],P[N];
void bfs(){
	node u;
	while(!q.empty()){
		u=q.front();q.pop_front();
		//cout<<u.pos<<" "<<u.jump<<endl;
		if(u.pos==B[1]) cout<<u.dep,exit(0);
		if(vis[u.pos][u.jump]) continue;
		vis[u.pos][u.jump]=1;
		for(int i=0;i<p[u.pos].size();++i)
			q.push_front(node(u.pos,p[u.pos][i],u.dep));
		if(u.pos-u.jump>=0) q.push_back(node(u.pos-u.jump,u.jump,u.dep+1));
		if(u.pos+u.jump<n) q.push_back(node(u.pos+u.jump,u.jump,u.dep+1));
	}
	cout<<-1;
}
int main(){
	int m;
	cin>>n>>m;
	for(int i=0;i<m;++i){
		cin>>B[i]>>P[i];
		p[B[i]].push_back(P[i]);
	}
	q.push_back(node(B[0],P[0],0));
	bfs();
	return 0;
}
 
```


---

## 作者：yangshurong (赞：4)

一看求最短先想dp，发现要考虑的状态和转移太多没法做。
再一看是从一个点往另一个点跳，可以考虑最短路。

直接建边会O(n^2)

优化：本题中，每个点之间的各种各样。可以先建n个虚图。
其中第i个虚图包含n个点，每个点对应这n座大楼。
这n座大楼任意两个如果相差距离为i，则连边，边长为1.。
但这样还是n^2。

发现当距离大于sqrt(n)时，边就很少了。此时干脆直接去掉sqrt(n)到n的虚图。
这些点的边在原图中暴力连接。

只建立距离<=sqrt(n)的虚图。 

总结：
**边多则想虚点**
**先想暴力图,再根据暴力图的条件，设置虚点，
使得实点到该实点的对应虚点距离为0，
虚点间根据条件设计距离，达到减少边的数量的目的。** 

注意：
有时候要**调整分块的大小**。例如本题中虚点往：
左右和它距离符合条件的点连边，同时此店还会和原来的实点连边
设t=sqrt(n)
此时已经有有3nt条边。
而对于p[i]>t的情况，有nn/t条边。
所以边数m=3tn+nn/t.（t=sqrt(n)）
发现当n取最大时，仅当t=100时可以使得边的数量最小。
因此blank要取min(100,sqrt(n))，已达到使边的数量尽量小的目的

```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<stack>
#include<algorithm>
#include<cstring>
#include<vector>
#include<ctime>
#include<map>
#include<cstdlib>
#include<cmath>
#define rel(a) a=readl()
#define r(i,a,b) for(int i=a;i<=b;i++)
#define rr(i,a,b) for(int i=a;i>=b;i--)
#define inf 0x3f3f3f3f
#define mem(a) memset(a,0x3f,sizeof(a))
#define re(a) a=read()
#define pr(a) printf("%d\n",a)
#define me(a) memset(a,0,sizeof(a))
#define in inline
#define ll long long
#define db double
#define id(i,j) (n*j)+i
using namespace std;
const int N=30007;
const int M=207;
inline int read(){
    char ch=getchar();
    int w=1,x=0;
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0',ch=getchar();}
    return x*w;
}
int n,m,head[N*300],b[N],p[N],blank,cnt=0,vis[N*300],d[N*300];
struct edge{
    int v,nxt,w;
}e[N*600];
in void add(int u,int v,int w){
    e[++cnt].v=v;
    e[cnt].w=w;
    e[cnt].nxt=head[u];
    head[u]=cnt;
}
queue<int> q;
in void bfs(int S){
    mem(d),me(vis);
    q.push(S),vis[S]=1,d[S]=0;
    int u,v,w;
    while(!q.empty()){
        u=q.front(),v,w;
        vis[u]=0;
        q.pop();
        for(int i=head[u];i;i=e[i].nxt){
            v=e[i].v,w=e[i].w;
            if(d[v]>d[u]+w){
                d[v]=d[u]+w;
                if(!vis[v]){
                    q.push(v);vis[v]=1;
                }
            }
        }
    }
}
int main(){
    re(n),re(m);
    blank=min((int)sqrt(n),100);
    r(i,1,blank){
        r(j,0,n-i-1){
            add(id(j,i),id(j+i,i),1);
            add(id(j+i,i),id(j,i),1);
        }
        r(j,0,n-1)add(id(j,i),j,0);
    }
    r(i,0,m-1){
        re(b[i]),re(p[i]);
        if(p[i]<=blank)add(b[i],id(b[i],p[i]),0);
        else{
            for(int j=b[i]-p[i];j>=0;j-=p[i])add(b[i],j,(b[i]-j)/p[i]);
            for(int j=b[i]+p[i];j<=n-1;j+=p[i])add(b[i],j,(j-b[i])/p[i]);
        }
    }
    bfs(b[0]);
    printf("%d\n",d[b[1]]<inf?d[b[1]]:-1);
    return 0;
}

```




---

## 作者：埃罗芒阿老师· (赞：4)

思路{


对于一条楼上的每一条狗.最直观的方法是把一个点拆成N条狗的点，然后最短路即可。

然而炸空间我也是醉了。

因此我们要用到一个调调的分块优化。

应当是每个点的连通状态。意会一下。

把一座楼分成1-块长层，那对于任意相同层数的狗可以在高空乱JB走。

但连通长度p>块长的呢？------直接连边就可以了。

然后YY一下，处理每条狗的激活关系。SPFA就可以了。

```cpp
}
#include<bits/stdc++.h>
#define RG register
#define il inline 
#define N 5500000
#define Inf 2
#define U unsigned short
#define pos(i,j) (i*n+j)
using namespace std;
struct ed{int nxt,to,c;}e[30005*500];
int head[30005*105],dis[30005*105],n,m,q,b,s,t;bool in[30005*105];int tot;
void add(int u,int v,int c){e[tot].nxt=head[u];e[tot].to=v;e[tot].c=c;head[u]=tot++;}
void ADD(int u,int v,int c){add(u,v,c),add(v,u,c);}
void spfa(){
  queue<int>que;memset(dis,Inf,sizeof(dis));int SS=dis[t];
  que.push(s),in[s]=true,dis[s]=0;
  while(!que.empty()){
    int u=que.front();que.pop();in[u]=false;
    for(int i=head[u];i!=-1;i=e[i].nxt)if(dis[e[i].to]>dis[u]+e[i].c){
    int v=e[i].to;dis[v]=dis[u]+e[i].c;
    if(!in[v])que.push(v),in[v]=true;
      }
  }if(dis[t]==SS)cout<<"-1";
  else cout<<dis[t];
}
int main(){
  freopen("skyscraper.in","r",stdin);
  freopen("skyscraper.out","w",stdout);
  memset(head,-1,sizeof(head));
  cin>>n>>m;U int len=min((int)sqrt(n),100);
  for(RG int i=1;i<=len;++i)for(int j=1;j<=n;++j)add(pos(i,j),j,0);
  for(RG int i=1;i<=len;++i)for(int j=1;j<=n-i;++j)ADD(pos(i,j),pos(i,j+i),1);
  for(RG int i=1;i<=m;++i){int b,p;
    cin>>b>>p;b++;
    if(i==1)s=b;if(i==2)t=b;
    if(p<=len)add(b,pos(p,b),0);
    else {
      for(int j=1;j*p+b<=n;++j)add(b,b+j*p,j);
      for(int j=1;b-j*p>0;++j)add(b,b-j*p,j);
    }
  }spfa();
  return 0;
}
```

---


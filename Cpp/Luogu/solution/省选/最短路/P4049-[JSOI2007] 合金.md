# [JSOI2007] 合金

## 题目描述

某公司加工一种由铁、铝、锡组成的合金。他们的工作很简单。首先进口一些铁铝锡合金原材料，不同种类的原材料中铁铝锡的比重不同。然后，将每种原材料取出一定量，经过融解、混合，得到新的合金。新的合金的铁铝锡比重为用户所需要的比重。 

现在，用户给出了 $n$ 种他们需要的合金，以及每种合金中铁铝锡的比重。公司希望能够订购最少种类的原材料，并且使用这些原材料可以加工出用户需要的所有种类的合金。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，满足 $1\le m,n\le 500$，$0 \leq a_i,b_i,c_i,d_i,e_i,f_i \leq 1$，且 $a_i+b_i+c_i=1$，$d_i+e_i+f_i=1$，小数点后最多有六位数字。

## 样例 #1

### 输入

```
10 10
0.1 0.2 0.7
0.2 0.3 0.5
0.3 0.4 0.3
0.4 0.5 0.1
0.5 0.1 0.4
0.6 0.2 0.2
0.7 0.3 0
0.8 0.1 0.1
0.9 0.1 0
1 0 0
0.1 0.2 0.7
0.2 0.3 0.5
0.3 0.4 0.3
0.4 0.5 0.1
0.5 0.1 0.4
0.6 0.2 0.2
0.7 0.3 0
0.8 0.1 0.1
0.9 0.1 0
1 0 0```

### 输出

```
5```

# 题解

## 作者：FutaRimeWoawaSete (赞：6)

1h 内没有做出来感觉还是挺亏的，要放真实省选就爆炸了（        

还是不该在网络流和 dp 上面绕太久……

凭借初中数学的直觉，比较容易发现的是原题其实等价于一个二维平面问题，因为在三维之和确定的情况下，一二维确定第三维就确定了，所以直接扔掉第三维。              

接着比较好发现的是复合两个点得到的点一定在两点的连线上，复合三个点（三点不共线）得到的点一定在构成的三角形内。             

由此发现如果选定一个可以构成规则多边形的点集，那么这个多边形内部的点集肯定都可以被构造出来，所以问题转化成了找一个最小的材料点集构成的凸包囊括所有用户点。             

~~然后我就开始了网络流和 dp 的奇妙冒险。~~              

这里我们不妨先观察，可以先对凸包的边进行定向，使得所有点都在边的左边或者右边。                 

然后对于每条边判断是否能将所有点都割到左边/右边去，如果可以那么就将这条边权置为 $1$ 否则置为无穷大，最后我们跑 Floyd 找最小环即可。      

这里选左边右边都无妨，体现在答案上只是顺时针和逆时针的走法，不影响图形本身。

~~我该说我想不到的理由是我不会 Floyd 找最小环吗~~          

```cpp
#include "bits/stdc++.h"
using namespace std;
const int Len = 5e2 + 5 , Inf = 1e9;
int n,m;
struct point
{
	double x,y;
	point(){x = 0.0 , y = 0.0;}
	point(double X,double Y){x = X , y = Y;}
	point operator - (const point &Ano) const
	{
		return point(x - Ano.x , y - Ano.y);
	}
	double operator ^ (const point &Ano) const
	{
		return x * Ano.y - y * Ano.x;
	}
}p[Len],t[Len];
int mp[Len][Len];
double fw;
int aside(point a,point b,point c)
{
	double mul = (b - a) ^ (c - a);
	if(mul > 0) return 1;
	if(mul < 0) return 0;
	double minx = min(a.x , b.x) , maxx = max(a.x , b.x) , miny = min(a.y , b.y) , maxy = max(a.y , b.y);
	return (minx <= c.x) && (c.x <= maxx) && (miny <= c.y) && (c.y <= maxy);
}
int main()
{
	scanf("%d %d",&m,&n);
	for(int i = 1 ; i <= m ; i ++) 
	{
		scanf("%lf %lf %lf",&p[i].x,&p[i].y,&fw);
		p[i].x *= 1000.0 , p[i].y *= 1000.0;
	}
	for(int i = 1 ; i <= n ; i ++) 
	{
		scanf("%lf %lf %lf",&t[i].x,&t[i].y,&fw);
		t[i].x *= 1000.0 , t[i].y *= 1000.0;
	}
	for(int i = 1 ; i <= m ; i ++)
		for(int j = 1 ; j <= m ; j ++) mp[i][j] = Inf;
	for(int i = 1 ; i <= m ; i ++)
		for(int j = 1 ; j <= m ; j ++)
		{
			bool flaw = 1;
			for(int k = 1 ; k <= n ; k ++) if(!aside(p[i] , p[j] , t[k])){flaw = 0;break;}
			if(flaw) mp[i][j] = 1;
			else mp[i][j] = Inf;
		}
	int Minn = Inf;
	for(int k = 1 ; k <= m ; k ++)
		for(int i = 1 ; i <= m ; i ++)
			for(int j = 1 ; j <= m ; j ++) mp[i][j] = min(mp[i][j] , mp[i][k] + mp[k][j]);
	for(int i = 1 ; i <= m ; i ++) Minn = min(Minn , mp[i][i]);
	if(Minn > m) puts("-1");
	else printf("%d\n",Minn);
	return 0;
}
```

---

## 作者：s_r_f (赞：6)

首先，材料的前两个属性可以唯一确定一个材料，合金的前两个树形也可以唯一确定一个材料。

那么材料和合金都可以被看成平面上的点$(a_i,b_i)$或$(d_i,e_i)$

不难发现，一些材料能表示出一种合金当且仅当**这个合金（在平面上的点）在选取的材料（在平面上的点）组成的凸包内**。

不难发现，选取的点凸包上的边一定满足：所有的合金代表的点都**在这条边的某一侧，或者在这条线段上（不是直线上）**

那么我们直接求个最小环就行了。

复杂度$O(n^3+mn^2).$

注意特判答案为 1 或 2 的情况。

```cpp
#include <bits/stdc++.h>
#define db long double
#define eps 1e-7
using namespace std;
const int N = 505,M = 505;
struct point{
	db x,y;
	point(db xx=0,db yy=0){ x = xx,y = yy; }
	bool operator < (const point w) const{
		if (fabs(x-w.x) > eps) return x < w.x;
		if (fabs(y-w.y) > eps) return y < w.x;
		return 0;
	}
}a[N],b[M];
bool operator == (point a,point b){ return fabs(a.x-b.x) < eps && fabs(a.y-b.y) < eps; }
point operator + (point a,point b){ return point(a.x+b.x,a.y+b.y); }
point operator - (point a,point b){ return point(a.x-b.x,a.y-b.y); }
inline db operator * (point a,point b){ return a.x * b.y - a.y * b.x; }
inline bool left(point a,point b,point p){ return fabs((b-a) * (p-a)) > eps && ((b-a) * (p-a)) > eps;  }
int n,m,dp[N][N],ans;
inline bool check(point p1,point p2){
	if (p1 == p2) return 0;
	for (int i = 1; i <= m; ++i) if (left(p1,p2,b[i])) return 0;
	for (int i = 1; i <= m; ++i) if (fabs((p2-p1)*(b[i]-p1)) < eps){
		if (p1 == b[i] || p2 == b[i]) continue;
		db l,r;
		l = p1.x,r = p2.x; if (l > r) swap(l,r); if (l-eps > b[i].x || b[i].x > r+eps) return 0;
		l = p1.y,r = p2.y; if (l > r) swap(l,r); if (l-eps > b[i].y || b[i].y > r+eps) return 0;
	}
	return 1;
}
int main(){
	int i,j,k;
	cin >> n >> m;
	for (i = 1; i <= n; ++i) cin >> a[i].x >> a[i].y >> a[0].x; sort(a+1,a+n+1);
	for (i = 1; i <= m; ++i) cin >> b[i].x >> b[i].y >> a[0].x; sort(b+1,b+m+1);
	for (i = 1; i <= n; ++i) a[i].x *= 1000000,a[i].y *= 1000000;
	for (i = 1; i <= m; ++i) b[i].x *= 1000000,b[i].y *= 1000000;
	n = unique(a+1,a+n+1) - (a+1);
	m = unique(b+1,b+m+1) - (b+1);
	for (i = 1; i <= n; ++i) for (j = 1; j <= n; ++j) dp[i][j] = 10000000;
	ans = 10000000;
	for (i = 1; i <= n; ++i) for (j = 1; j <= n; ++j)
		if (i != j && check(a[i],a[j])) dp[i][j] = 1;
	for (k = 1; k <= n; ++k) for (i = 1; i <= n; ++i) for (j = 1; j <= n; ++j)
		dp[i][j] = min(dp[i][j],dp[i][k] + dp[k][j]);
	for (i = 1; i <= n; ++i) ans = min(ans,dp[i][i]);
	if (n == 1 && m == 1 && a[1] == b[1]) ans = 1;
	if (ans > n) cout << -1 << '\n'; else cout << ans << '\n';
	return 0;
}
```

---

## 作者：大奕哥 (赞：6)

可以联想到矩阵的线性相关。

根据题意得出所求的合金应该是在材料的一个凸包内。

而要求是凸包的边尽量少。

建图跑floyd最短路。

每次判断点是否都在线段左侧，第二个判断是判断共线时点是否在线段上。

叉积正负判断顺逆时针，点积正负判断夹角大小。

By：大奕哥

```cpp
http://www.cnblogs.com/nbwzyzngyl/p/8323605.html
#include<bits/stdc++.h>
#define eps 1e-7
#define N 510
using namespace std;
struct node{
    double x,y,z;
}a[N],b[N];
node vet(node a,node b)
{
    node c;c.x=a.x-b.x;c.y=a.y-b.y;
    return c;
}
double xmul(node a,node b){return a.x*b.y-b.x*a.y;}
double pmul(node a,node b){return a.x*b.x+a.y*b.y;}
int n,m,ans,f[N][N];
void floyd()
{
    ans=1e9;
    for(int k=1;k<=n;++k)
        for(int i=1;i<=n;++i)
            for(int j=1;j<=n;++j)
                f[i][j]=min(f[i][j],f[i][k]+f[k][j]);
    for(int i=1;i<=n;++i)ans=min(ans,f[i][i]);
}
int main()
{
    scanf("%d%d",&n,&m);
    memset(f,0x3f,sizeof(f));
    for(int i=1;i<=n;++i)scanf("%lf%lf%lf",&a[i].x,&a[i].y,&a[i].z);
    for(int i=1;i<=m;++i)scanf("%lf%lf%lf",&b[i].x,&b[i].y,&b[i].z);
    for(int i=1;i<=n;++i)
    for(int j=1;j<=n;++j)
    {
        bool flag=0;
        for(int k=1;k<=m;++k)
        {
            double cross=xmul(vet(a[i],b[k]),vet(a[j],b[k]));
            if(cross>eps){flag=1;break;}
            if(fabs(cross)<eps&&pmul(vet(a[i],b[k]),vet(a[j],b[k]))>eps)
            {flag=1;break;}
        }
        if(!flag)f[i][j]=1;
    }
    floyd();
    if(ans==1e9)puts("-1");
    else printf("%d",ans);
    return 0;
}
```

---

## 作者：whhsteven (赞：1)

## 题目链接

[P4049](https://www.luogu.com.cn/problem/P4049)

&nbsp;

## 题意

企业制造铁铝锡合金产品。有 $m$ 种铁铝锡配比的合金作为原材料，有 $n$ 种需要的配比。求最少需要几种原材料，使得可以通过按一定比例混合这些原材料得到每一种需要的配比。

&nbsp;

## 题解

每一种配比的三项系数之和为 $1$，故实际只需考虑两维。

题目转化为：给定平面上第一象限和 $x,y$ 非负半轴上已有的 $m$ 个向量和需要的 $n$ 个向量，求最少需要选出已有向量中的多少个，使得可以将 $n$ 个所需向量均表示为所选向量的线性组合的形式，要求每一项系数均非负且系数和为 $1$。

&nbsp;

以下默认向量起点均为坐标原点，用点表示其位置向量，并称系数和为 $1$ 的非负系数线性组合为「合法线性组合」。

考虑定比分点公式。可以知道，向量 $\boldsymbol c$ 可以用两向量 $\boldsymbol a,\boldsymbol b$ 的合法线性组合表示，当且仅当 $\boldsymbol c$ 的终点在 $\boldsymbol a,\boldsymbol b$ 终点所连成的线段上。

进一步地，向量 $\boldsymbol c$ 可以用 $n$ 个第一象限的向量 $\boldsymbol a_1,\boldsymbol a_2, \cdots, \boldsymbol a_n$ 的合法线性组合表示，当且仅当 $\boldsymbol c$ 的终点在 $\boldsymbol a_1,\boldsymbol a_2, \cdots, \boldsymbol a_n$ 终点所围成的凸包的内部或边界上。

先证充分性。$\boldsymbol c$ 的终点在凸包边界上时充分性显然。$\boldsymbol c$ 的终点在凸包内部时，连接凸包任一顶点 $A$ 和 $\boldsymbol c$ 终点 $C$ 并延长，必然交凸包边界于另一点 $P$。易见 $\boldsymbol c$ 可以用 $A$ 和 $P$ 的合法线性组合表示。凸包边界上任意一点均可以用两已有向量的合法线性组合表示，因为这个线性组合的系数之和为 $1$，所以 $P$ 与 $A$ 的合法线性组合分解成已有向量的线性组合后系数和一定依然为 $1$。由此可知，$\boldsymbol c$ 一定能够表示为已有向量的合法线性组合。

再证必要性。仔细思考不难看出，若干第一象限的向量的合法线性组合表示的向量，终点不会在这些向量终点围成的凸包边界外。

&nbsp;

有了上面的结论，问题进一步转化为：求一个由已有向量的终点围成的凸包，满足所有所需向量的终点均在凸包内部或边界上，且凸包顶点尽可能少。

枚举 $m$ 个已有向量终点连成的 $m(m-1)$ 条有向边，如果所有所需向量终点均在一条边的右侧，则这条边有可能成为凸包上的边。点在有向线段左右可以用叉积正负来判断。

找到所有有可能成为凸包上边的边，用 Floyd 算法求出最小环，这个环的边数（也即顶点数）即为所求。

注意处理所有所需向量相等且等于某一条已有向量的情形和所需向量与步骤中连出的有向边共线的情形。

&nbsp;

时间复杂度 $O(nm^2 + m^3)$。

&nbsp;

## 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

namespace acah
{
	constexpr int maxn = 507;
	constexpr double eps = 1e-9;
	
	struct vec {
		double x, y;
		vec() {} vec(double _x, double _y) : x(_x), y(_y) {}
		const vec operator - (const vec &b) const {return vec(x - b.x, y - b.y);}
		double operator * (const vec &b) const {return x * b.y - y * b.x;}
	} mt[maxn], pd[maxn];
	
	int N, M, ans;
	int d[maxn][maxn];
	
	int work()
	{
		scanf("%d%d", &M, &N), ans = M + 1;
		for(int i = 1; i <= M; i++) scanf("%lf%lf%*f", &mt[i].x, &mt[i].y);
		for(int i = 1; i <= N; i++) scanf("%lf%lf%*f", &pd[i].x, &pd[i].y);
		
		memset(d, 63, sizeof d);
		for(int i = 1; i <= M; i++) for(int j = 1; j <= M; j++) {
			bool fl = true; double xm;
			for(int k = 1; k <= N; k++)
				if((xm = (mt[j] - mt[i]) * (pd[k] - mt[i])) > eps ||
				(fabs(xm) <= eps && (max(mt[i].x, mt[j].x) < pd[k].x || min(mt[i].x, mt[j].x) > pd[k].x)))
					{fl = false; break;}
			if(fl) d[i][j] = 1;
		}
		
		for(int k = 1; k <= M; k++) for(int i = 1; i <= M; i++) for(int j = 1; j <= M; j++)
			d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
		
		for(int i = 1; i <= M; i++) ans = min(ans, d[i][i]);
		
		printf("%d", (ans == M + 1) ? -1 : ans);
		
		return 0;
	}
}

int main() {return acah::work();}
```

---

## 作者：partychicken (赞：1)

## 凸包+Floyd最小环

#### 做法：
1.用前两维分别作为横纵坐标，将合金表示成平面直角坐标系中的点

2.求原材料的凸包，然后判断这个凸包是否包含所有待加工的合金。如果不是，则无解。

3.对凸包上的所有点建图，建图方式如下：

枚举任意两个点。若所有待加工合金均在两个点所连直线的一侧，则两个点间距离为$1$，否则为$inf$

#### 理由：

首先，考虑模型的转化。

1.第三维显然没用，可以去掉

2.前两维可以表示为坐标系内的一个点

3.两个点所能表示出的所有点均在以两点为端点的线段上

4.首尾相接的两条线段$AB,BC$可以表示出$\triangle ABC$内的所有点（感性理解一下，或者通过推式子也能得出相同的结论）。

5.对第4条进行合理推广，一个由多条首尾相接线段所构成的多边形可以表示出其内部所有点，因此求原材料的凸包就可以判断是否有解了。

然后，考虑求出的凸包中有些点是没用的，因为我们只需要包住所有待加工合金的点，而不需要包住所有原材料的点。

按照上面提到的建图方式建图，求最小环即可去掉无用的点。可以性感理解一下。我尝试这用我垃圾的语文功底尝试解说一个。

两个点之间连边表示两个凸包上的点可以直接相连，所以如果待加工合金的点分布在线段两侧，那么说明我们把凸包切开了，这两个点直接相连是不合法的。否则，说明这两个点可以直接相连，而不需要其他点来形成对于待加工合金的凸包。

- Q：为什么是最小环？

- A：因为要求凸包，一定要首尾相接，所以要成环。因为要尽量去掉无用的点，所以要一个最小环。

---

## 作者：C_Pos_Princess (赞：0)

# [JSOI2007] 合金

## 题目描述

某公司加工一种由铁、铝、锡组成的合金。他们的工作很简单。首先进口一些铁铝锡合金原材料，不同种类的原材料中铁铝锡的比重不同。然后，将每种原材料取出一定量，经过融解、混合，得到新的合金。新的合金的铁铝锡比重为用户所需要的比重。 

现在，用户给出了 $n$ 种他们需要的合金，以及每种合金中铁铝锡的比重。公司希望能够订购最少种类的原材料，并且使用这些原材料可以加工出用户需要的所有种类的合金。

#### 数据规模与约定

对于全部的测试点，满足 $1\le m,n\le 500$，$0 \leq a_i,b_i,c_i,d_i,e_i,f_i \leq 1$，且 $a_i+b_i+c_i=1$，$d_i+e_i+f_i=1$，小数点后最多有六位数字。

## 题解
总而言之，就是让我们用已有的材料融合出需要的材料。

我们可以注意到，一种材料可以被合成，当且仅当他在已有材料围成的凸包内。

需要找最少的材料，即凸包的边最少，所以我们把所有可以作为凸包上的找出来，然后 floyd 跑一边最短路就可以得到最小环，即凸包。

找边的时候，我们只需要锚定一个方向找就可以（因为是双向边）。

#### 几个性质

已知两个向量 $\bold a,\bold b$。

**叉乘**
- $\bold a \times \bold b > 0$：$\bold a$ 向量在 $\bold b$ 向量左边
- $\bold a \times \bold b < 0$：$\bold a$ 向量在 $\bold b$ 向量右边
- $\bold a \times \bold b = 0$：$\bold a$ 向量在 $\bold b$ 向量方向相同


**点乘**
- 大于 $0$：夹角小于 $90$ 度
- 小于 $0$：夹角大于 $90$ 度

## 代码
```cpp
const int N = 1e6 + 10;
const int INF = 0x3f3f3f3f;
using namespace std;
struct node {
	double x, y, z;
} a[N], b[N];
const double eps = 1e-7;

node vet(node a, node b) {
	node c;
	c.x = a.x - b.x;
	c.y = a.y - b.y;
	return c;
}

double xmul(node a, node b) {
	return a.x * b.y - a.y * b.x;
}
double pmul(node a, node b) {
	return a.x * b.x + a.y * b.y;
}
int n, m;
int f[510][510];
int ans;
void floyd() {
	ans = 1e9;
	for(int k = 1;k<=n;k++){
		for(int i = 1;i<=n;i++){
			for(int j = 1;j<=n;j++){
				f[i][j] = min(f[i][j],f[i][k]+f[k][j]);
			}
		}
	}
	for(int i = 1;i<=n;i++) ans = min(ans,f[i][i]);
}

int main() {
	read(n, m);
	memset(f, 0x3f, sizeof f);
	for (int i = 1; i <= n; i++) {
		scanf("%lf%lf%lf",&a[i].x,&a[i].y,&a[i].z);
	}
	for (int i = 1; i <= m; i++) {
		scanf("%lf%lf%lf",&b[i].x,&b[i].y,&b[i].z);
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			bool flag = 0;
			for (int k = 1; k <= m; k++) {
				double cross = (xmul(vet(a[i], b[k]), vet(a[j], b[k])));
				// 顺时针找，ij直接连，把b_k 包住 
				if (cross > eps) {
					flag = 1;
					break;
				}
				if (fabs(cross) < eps && pmul(vet(a[i], b[k]), vet(a[j], b[k])) > eps) {
					flag = 1;
					break;
				}
				//点积正负判断夹角大小。
				//判断是判断共线时点是否在线段上。

			}
			if (flag == 0) f[i][j] = 1;
		}

	}
	floyd();
	if(ans == 1e9) ans = -1;
	write(ans);

	return 0;
}

```

---

## 作者：DiDi123 (赞：0)

感觉很妙的题，这里给一些简单的证明。

首先是为什么只用考虑两维，设我们有 $k$ 个三维的点 $(x_1,y_1,z_1),(x_2,y_2,z_2),\cdots ,(x_k,y_k,z_k)$，用这些点配一定系数能得到 $(a,b,c)$。设 
$$
\left\{
\begin{aligned}
t_1x_1+t_2x_2+\cdots+t_kx_k &=a\\
t_1y_1+t_2y_2+\cdots+t_ky_k &=b\\
t_1z_1+t_2z_2+\cdots+t_kz_k &=c

\end{aligned}
\right.
$$

注意到 $x_i+y_i+z_i=1,a+b+c=1$，那么有 $t_1+t_2+\cdots+t_k=1$，我们把 $c$ 和 $z_i$ 用前两维表示，有 
$$
\left\{
\begin{aligned}

& t_1x_1+t_2x_2+\cdots+t_kx_k=a\\
& t_1y_1+t_2y_2+\cdots+t_ky_k =b\\
& \sum t_i -t_1(x_1+y_1)-t_2(x_2+y_2)-\cdots-t_k(x_k+y_k) &=1-a-b

\end{aligned}
\right.
$$

发现如果前两个式子成立，则第三个式子也一定成立，故可以忽略第三位。

然后证明一下为什么三个点能配出来的点一定在这三个点的三角形内。

对于一个点，我们可以把一个点设为坐标原点，然后用向量考虑：

![图片](https://cdn.luogu.com.cn/upload/image_hosting/lebtafdo.png)

我们需要证明对于任意 $\triangle OAB$ 内的点 $D$，都存在 $\overrightarrow{OD}=x\overrightarrow{OA}+y\overrightarrow{OB}$，其中 $x+y\leq 1,x,y\geq 0$。

当 $x+y=1$ 的时候，我们知道此时的 $D$ 一定在线段 $AB$ 上。设这个点是 $C$，那么我们可以令 $\overrightarrow{OC'}=\lambda \overrightarrow{OC}(0\leq \lambda \leq 1)$，这样 $C'$ 就能取遍 $OC$ 上的所有点，并且满足 $x,y$ 的限制。那么当 $C$ 在 $AB$ 上移动时，$C'$ 就能取遍三角形内的所有点。

对于一个凸多边形，我们可以将其进行三角形分割，这样就可以得出若干个凸多边形的顶点能组成的点也在凸多边形内。

接下来我们需要考虑至少选多少个原材料代表的点能构成凸多边形使得所有的合金代表的点都在这个多边形内。我们可以将所有边定向，我们希望能选出来一组边构成一个封闭的多边形，如下图：

![图片](https://cdn.luogu.com.cn/upload/image_hosting/emaqw9n0.png)

那么我们可以对每条边考虑所有的点是否在它的**顺时针/逆时针**一侧。假设我们希望多边形为上图的逆时针多边形，则我们需要对每条选中的边，都有所有点在它的逆时针一侧。我们就可以考虑每个点到这条边两个端点的向量的夹角关系，如下图：

![tp](https://cdn.luogu.com.cn/upload/image_hosting/kkz74tfr.png)

我们需要 $0<\langle \overrightarrow{OA},\overrightarrow{OB}\rangle<\pi$，这是我们可以用到向量的**叉乘**，因为有 $\overrightarrow{a}\times \overrightarrow{b}=|\overrightarrow{a}||\overrightarrow{b}|\sin \theta$，当 $\sin \theta>0$ 时满足条件。

我们还需要特判向量共线的时候，这个时候我们可以用到**点乘**。如果两个向量的方向相同，这时候合金代表的点是在选中的线段的外面的，我们需要排除这种情况。

判断了每条边是否符合条件之后，我们再用一下 Floyd 求最小环，这样就解决问题了。

---

## 作者：redegg (赞：0)

既然能用 Floyd 求最小环，那 dp 也行。

发现三个数之和为 $1$ ，则用前两个数就能代表这三个数了，然后是基础向量知识：

$$a+b=1  \Rightarrow a\vec x +b\vec y=k(\vec y-\vec x),k\in[-1,1]$$

把材料 $(a,b,c)$ 看做向量，前面因为可以省去一位，我们省去 $c$ 。会发现，如果只有两个原料，则能被合成的合金一定在两原料向量相减后的向量上。那么我们任意两个原材料可以合成出一条向量上所有的合金，如果这些向量围起来，就能合成围起来区间里的所有合金。

那么现在就是求一个能把所有合金围起来的多边形，并且顶点数尽量少，那么一定是一个凸包。

如果两个原材料相减后的向量左右两侧都有合金，那么这个向量无法作为凸包的边。

我们可以把符合要求的凸包的边（向量）筛出来，然后按照极角排一次序。每次枚举一个凸包的起点，然后按顺序枚举边（向量），注意这个顺序和凸包边界是顺时针还是逆时针有关。

转移方程比较简单：$dist[v_i]=min(dist[u_i]+1,dis[v_i])$，$u_ie_i$是符合要求的边。初始化是每次枚举一个凸包起点后，把凸包起点指向的点赋值为$1$，其余点为正无穷。

```
#include <bits/stdc++.h>
using namespace std;

int n,m,cnt;
const int MAXN=505;
const double pi=acos(-1);
const double esp=1e-9;

int minn[MAXN],st[MAXN];

struct vec{
    double x,y;
    double theta;
    int st,en;
}q[MAXN*MAXN],pa[MAXN],pb[MAXN];

vec operator + (const vec &aa,const vec &bb){return (vec){aa.x+bb.x,aa.y+bb.y,0,0,0};}
vec operator - (const vec &aa,const vec &bb){return (vec){aa.x-bb.x,aa.y-bb.y,0,0,0};}
double operator * (const vec &aa,const vec &bb){return aa.x*bb.x+aa.y*bb.y;}
double operator ^ (const vec &aa,const vec &bb){return aa.x*bb.y-aa.y*bb.x;}
double xa[MAXN],ya[MAXN],xb[MAXN],yb[MAXN],lins;
double dis(const vec &aa){
    return (aa.x*aa.x+aa.y*aa.y);
}
bool check(const vec &aa,const vec &bb){
    if(fabs(aa^bb)>esp)return (aa^bb)>esp;
    if(aa.x!=0)return bb.x/aa.x<=1-esp;
    if(aa.y!=0)return bb.y/aa.y<=1-esp;
    return false;
}
bool cmp (const vec &aa,const vec &bb){
    return aa.theta<bb.theta-esp;
}

int main()
{
    scanf("%d%d",&n,&m);
    for(register int i=1;i<=n;i++){
        scanf("%lf%lf%lf",&pa[i].x,&pa[i].y,&lins);
    }
    for(register int i=1;i<=m;i++){
        scanf("%lf%lf%lf",&pb[i].x,&pb[i].y,&lins);
    }
    if(n==1){
        bool ok=1;
        for(int i=1;i<=m;i++){
            if(fabs(pb[i].x-pa[1].x)>esp||fabs(pb[i].y-pa[1].y)>esp)ok=0;
        }
        if(!ok)printf("-");
        printf("1\n");
        return 0;
    }
    for(register int i=1;i<=n;i++){
        for(register int j=1;j<=n;j++){
            if(i==j)continue;bool ok=0;
            for(register int k=1;k<=m;k++){
                if(check((pb[k]-pa[i]),(pa[j]-pa[i]))){
                    ok=1;break;
                }
            }
            if(ok)continue;
            cnt++;
            q[cnt]=pa[j]-pa[i];
            q[cnt].st=i;
            q[cnt].en=j;
            q[cnt].theta=atan2(q[cnt].x,q[cnt].y);
        }
    }
    sort(q+1,q+1+cnt,cmp);
    int ans=1e8;
    for(register int i=1;i<=n;i++){
        for(register int j=1;j<=n;j++)minn[j]=st[j]=1e8;
        st[i]=0;
        for(register int j=cnt;j>=1;j--){
            minn[q[j].en]=min(minn[q[j].en],min(minn[q[j].st]+1,st[q[j].st]+1));
        }
        ans=min(ans,minn[i]);
    }
    if(ans>1000)printf("-1\n");
    else printf("%d\n",ans);

    return 0;
}

```

---


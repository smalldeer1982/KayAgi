# [Code+#1] 大吉大利，晚上吃鸡！

## 题目背景

最近《绝地求生：大逃杀》风靡全球，皮皮和毛毛也迷上了这款游戏，他们经常组队玩这款游戏。

在游戏中，皮皮和毛毛最喜欢做的事情就是堵桥，每每有一个好时机都能收到不少的快递。

当然，有些时候并不能堵桥，皮皮和毛毛会选择在其他的必经之路上蹲点。

K博士作为一个老年人，外加有心脏病，自然是不能玩这款游戏的，但是这并不能妨碍他对这款游戏进行一些理论分析，比如最近他就对皮皮和毛毛的战术很感兴趣。


## 题目描述

游戏的地图可以抽象为一张 $n$ 个点 $m$ 条无向边的图，节点编号为 $1$ 到 $n$ ，每条边具有一个正整数的长度。

**假定大魔王都会从 $S$ 点出发到达 $T$ 点（ $S$ 和 $T$ 已知），并且只会走最短路，**皮皮和毛毛会在 $A$ 点和 $B$ 点埋伏大魔王。

为了保证一定能埋伏到大魔王，同时又想留大魔王一条生路，皮皮和毛毛约定 $A$ 点和 $B$ 点必须满足：

- 大魔王所有可能路径中，必定会经过 $A$ 点和 $B$ 点中的任意一点

- 大魔王所有可能路径中，不存在一条路径同时经过 $A$ 点和 $B$ 点

K博士想知道，满足上面两个条件的 $A,B$ 点对有多少个，交换 $A,B$ 的顺序算相同的方案。


## 说明/提示

### 样例1解释

合法的方案为$<2,3>,<2,4>,<4,3>,<4,5>,<6,3>,<6,5>$ 。

 ![](https://cdn.luogu.com.cn/upload/pic/12824.png) 

来自 CodePlus 2017 11 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。

Credit：idea/陈宇 命题/陈宇 验题/邢健开

Git Repo：https://git.thusaac.org/publish/CodePlus201711

感谢腾讯公司对此次比赛的支持。


## 样例 #1

### 输入

```
7 7 1 7
1 2 2
2 4 2
4 6 2
6 7 2
1 3 2
3 5 4
5 7 2```

### 输出

```
6```

## 样例 #2

### 输入

```
5 5 1 4
1 2 1
1 3 1
2 4 1
3 4 1
4 5 1```

### 输出

```
3```

## 样例 #3

### 输入

```
6 7 1 4
1 2 1
1 3 1
2 4 1
3 4 1
4 5 1
1 6 2
6 4 2```

### 输出

```
5```

# 题解

## 作者：wsyhb (赞：20)

## 前言

巨佬们的题解都好难懂（我是仔细阅读了 @[Cyhlnj](https://www.luogu.com.cn/user/47640) 题解中的每一句代码才弄懂的），于是我这个蒟蒻打算写一篇**思路清晰、尽可能严谨**的题解，如有错误还请指正。

顺带一提，[这里](https://www.luogu.com.cn/paste/r3wirkn6)有两组 Hack 数据。截止本文发布前（2021.8.25），本题题解区只有 FrenkiedeJong21 的题解能通过这两组数据（当然本题解的代码是可以过的），具体原因见[这个帖子](https://www.luogu.com.cn/discuss/show/345428)。

## 题意简述

给定 $n$ 个点，$m$ 条边的无向图，以及起点 $S$ 和终点 $T$。求满足下列条件的无序点对 $(A,B)$ 的数量。

条件：对于任意一条从 $S$ 到 $T$ 的最短路径，其**恰好经过 $A$ 和 $B$ 其中之一**。

**数据范围**：$1 \le n,m \le 5 \times 10^4$，边权 $w$ 满足 $1 \le w \le 10^9$。

P.S. 本题数据可能出现从 $S$ 出发无法到达 $T$ 的情况。根据前人的经验，此时应输出 $\binom{n}{2}=\dfrac{n(n-1)}{2}$。

------------

P.S. 为了方便叙述，**默认下文中的“路径”“最短路径”等均指“从 $S$ 到 $T$ 的最短路径”**。

## 分析

设 $F(i)$ 表示经过 $i$ 号点的路径数量，那么 $F$ 可以通过**正反两次 Dijkstra** 求出。

容易想到一个满足题意的必要条件：$F(A)+F(B)=F(T)$，即经过 $A,B$ 两个点的路径数之和等于总路径数。

进一步，答案应为：满足 $F(A)+F(B)=F(T)$ 且不存在一条路径同时经过 $A$ 和 $B$ 的无序点对 $(A,B)$ 的数量。（因为数量之和达到上限，所以只需保证每条路径只经过至多一个点，即：在 $F(A)$ 和 $F(B)$ 中至多一个提供贡献）

由于 $F(A)+F(B)=F(T)$ 是一个简单的数量关系限制，容易处理。于是考虑**如何求出不存在一条路径同时经过 $A$ 和 $B$ 的无序点对 $(A,B)$**（当然不是一个一个列举出，而是计算出能代表其特征的数据），再计算出其中满足 $F(A)+F(B)=F(T)$ 的数量。

## 题解

首先任取一条 $S$ 到 $T$ 的最短路径 $P$，那么 $A$ 和 $B$ 中恰好一个在 $P$ 上。不妨设 $A$ 在路径 $P$ 上，则 $B$ 不在路径 $P$ 上。

### 结论一

对于固定的 $B$，使得 $A$ 和 $B$ 满足特殊性质的全体 $A$，在路径 $P$ 上是连续的一段。（**“$x$ 和 $y$ 满足特殊性质”指“不存在一条路径同时经过 $x$ 和 $y$”，下同**）

### 结论一证明

设 $X,Y,Z$ 为路径 $P$ 上顺次（**“顺次”指按从 $S$ 到 $T$ 依次经过的顺序，不一定连续，下同**）出现的三个点。假设 $X$ 和 $B$，$Z$ 和 $B$ 都满足特殊性质，但 $Y$ 和 $B$ 不满足特殊性质。

那么有两种情况：

1. 存在一条最短路径 $P_1$，先经过 $Y$ 再经过 $B$。
	- 将路径 $P_1$ 从 $S$ 到 $Y$ 的部分用路径 $P$ 从 $S$ 到 $Y$ 的部分替换，得到路径 $P_2$。显然 $P_2$ 也为最短路径，且 $P_2$ 先经过 $X$ 再经过 $B$，这与 $X$ 和 $B$ 满足特殊性质矛盾。
1. 存在一条最短路径 $P_3$，先经过 $B$ 再经过 $Y$。
	- 将路径 $P_3$ 从 $Y$ 到 $T$ 的部分用路径 $P$ 从 $Y$ 到 $T$ 的部分替换，得到路径 $P_4$。显然 $P_4$ 也为最短路径，且 $P_4$ 先经过 $B$ 再经过 $Z$，这与 $Z$ 和 $B$ 满足特殊性质矛盾。

因此假设不成立，则结论一成立。

### 结论二

设 $X,Y$ 为**任意**最短路径上顺次出现的两个点，则不存在最短路径先经过 $Y$ 再经过 $X$。

### 结论二证明

设 $S$ 到 $X$ 的最短距离为 $a$，$X$ 到 $Y$ 的最短距离为 $e$，$Y$ 到 $T$ 的最短距离为 $b$，则 $S$ 到 $T$ 的最短路径距离为 $a+e+b$。再设 $S$ 到 $Y$ 的最短距离为 $c$，$X$ 到 $T$ 的最短路径为 $d$。

假设存在一条先经过 $Y$ 再经过 $X$ 的最短路径，则 $c+e+d=a+e+b$。进一步有 $c \le a$ 且 $d \ge b$，或 $c \ge a$ 且 $d \le b$。

若 $c \le a$，则 $S$ 到 $T$ 存在一条经过 $Y$ 的路径，其长度为 $c+b \le a+b < a+e+b$。

若 $d \le b$，则 $S$ 到 $T$ 存在一条经过 $X$ 的路径，其长度为 $a+d \le a+b < a+e+b$。

这与 $S$ 到 $T$ 的最短距离为 $a+e+b$ 矛盾，因此假设不成立。

故结论二成立。

### 推论

由结论二可知：**把所有最短路径看成有向路径，然后取它们的并集，所形成的有向图是一个 DAG**（Directed Acyclic Graph，有向无环图）。

### 求解不存在路径同时经过 $x$ 和 $y$ 的无序点对 $(x,y)$

将路径 $P$ 上的点顺次记为 $p_1,p_2,\cdots,p_t$，其中 $t$ 为路径 $P$ 上的点数。（Dijkstra 时记录每个点的前驱，即可求出某条最短路径 $P$ 上的 $p_1,p_2,\cdots,p_t$）

由结论一，**设路径 $P$ 上和 $i$ 号点有特殊性质的全体点为 $p_{L(i)},p_{L(i)+1},\cdots,p_{R(i)}$**（$L(i)>R(i)$ 表示不存在），则有如下等式：

$$L(i)=\max_{p_{_k} \to i}k+1$$

$$R(i)=\min_{i \to p_{_k}}k-1$$

其中**条件 $x \to y$ 表示存在先经过 $x$ 再经过 $y$ 的最短路径**。

为了便于计算，我们将其改成递推形式：

$$L(i)=\begin{cases}
j+1 \quad (i=p_j)\\
\max_{(k,i) \in E}L(k) \quad (\text{otherwise})
\end{cases}$$

$$R(i)=\begin{cases}
j-1 \quad (i=p_j)\\
\min_{(i,k) \in E}R(k) \quad (\text{otherwise})
\end{cases}$$

其中**条件 $(x,y) \in E$ 表示 $x$ 和 $y$ 之间存在直接相连的边，且存在一条最短路径先经过 $x$ 再经过 $y$**。

由推论可知，由于有向最短路径的并集形成的图是 DAG，可以使用**拓扑排序**对 $L$ 和 $R$ 进行转移。（即：只考虑最短路径可能经过的边，进行拓扑排序）

### 求解其中满足 $F$ 之和等于 $F(T)$ 的无序点对数量

由上一部分知，所有的、不存在路径同时经过 $x$ 和 $y$ 的无序点对 $(x,y)$ 为全体 $(i,p_j)$，其中 $i$ 不在路径 $P$ 上且 $j \in [l(i),r(i)]$。

至此，只需解决最后一个问题：对于每个 $i$，求出满足 $j \in [l(i),r(i)]$ 且 $F(i)+F(p_j)=F(T)$ 的 $j$ 的数量。

拿一个 **map** 当桶，在计算 $p_{l(i)}$ 的贡献前把值 $F(i)$ 加入，在计算 $p_{r(i)}$ 的贡献后把值 $F(i)$ 删除，$F(i)+F(p_j)=F(T)$ 的 $i$ 的数量即为计算时 map 中值 $F(T)-F(p_j)$ 的数量。

注意：在本题的限制下，起点 $S$ 到终点 $T$ 的最短路径数量 $F$ 可以达到指数级别。因此，**要将最短路径的数量 $F$ 对大质数取模**，否则可以被【前言】中提到的 Hack 数据 Hack。

### 时间复杂度分析

堆优化 Dijkstra 是 $O(m\log{m})$ 的，拓扑排序是 $O(m)$ 的，map 的加入、删除、查询次数为 $O(n)$，因此总时间复杂度为 $O(m\log{m}+n\log{n})$。

## 代码

``` cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,S,T;
const int max_n=5e4+5;
const int max_m=5e4+5;
int End[max_m<<1],Last[max_n],Next[max_m<<1],Len[max_m<<1],e;
inline void add_edge(int x,int y,int z)
{
	End[++e]=y,Next[e]=Last[x],Last[x]=e,Len[e]=z;
	End[++e]=x,Next[e]=Last[y],Last[y]=e,Len[e]=z;
}
typedef pair<long long,int> P;
priority_queue<P,vector<P>,greater<P> > Q;
long long dis[2][max_n];
const int mod=1e9+7;
inline void add(int &a,int b)
{
	a=a+b-(a+b>=mod?mod:0);
}
inline int get_dif(int a,int b)
{
	return a-b+(a<b?mod:0);
}
int f[2][max_n],pre[max_n];
inline void Dijkstra(int op)
{
	for(int i=1;i<=n;++i)
		dis[op][i]=1e18;
	if(!op)
	{
		dis[op][S]=0,f[op][S]=1;
		Q.push(P(0,S));
	}
	else
	{
		dis[op][T]=0,f[op][T]=1;
		Q.push(P(0,T));
	}
	while(Q.size())
	{
		long long d=Q.top().first;
		int x=Q.top().second;
		Q.pop();
		if(dis[op][x]<d)
			continue;
		for(int i=Last[x];i;i=Next[i])
		{
			int y=End[i];
			if(d+Len[i]<dis[op][y])
			{
				dis[op][y]=d+Len[i];
				f[op][y]=f[op][x];
				if(op)
					pre[y]=x;
				Q.push(P(dis[op][y],y));
			}
			else if(d+Len[i]==dis[op][y])
				add(f[op][y],f[op][x]);
		}
	}
}
inline bool check(int op,int x,int y,int w)
{
	return dis[op][x]+w+dis[op^1][y]==dis[0][T];
}
int p[max_n],tot,l[max_n],r[max_n],d[max_n],que[max_n],head,tail;
inline void TopSort(int op)
{
	for(int x=1;x<=n;++x)
		for(int i=Last[x];i;i=Next[i])
		{
			int y=End[i];
			if(check(op,x,y,Len[i]))
				++d[y];
		}
	head=1,tail=0;
	for(int i=1;i<=n;++i)
	{
		if(!d[i])
			que[++tail]=i;
	}
	while(head<=tail)
	{
		int x=que[head++];
		for(int i=Last[x];i;i=Next[i])
		{
			int y=End[i];
			if(check(op,x,y,Len[i]))
			{
				op?r[y]=min(r[x],r[y]):l[y]=max(l[x],l[y]);
				if(!--d[y])
					que[++tail]=y;
			}
		}
	}
	assert(tail==n);
}
int F[max_n];
vector<int> id_l[max_n],id_r[max_n];
map<int,int> cnt;
int main()
{
	scanf("%d%d%d%d",&n,&m,&S,&T);
	for(int i=1;i<=m;++i)
	{
		int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		add_edge(u,v,w);
	}
	Dijkstra(0);
	if(dis[0][T]==1e18)
	{
		printf("%lld\n",n*(n-1ll)>>1);
		return 0;
	}
	Dijkstra(1);
	for(int i=S;i;i=pre[i])
		p[++tot]=i,l[i]=tot+1,r[i]=tot-1;
	for(int i=1;i<=n;++i)
	{
		if(dis[0][i]+dis[1][i]==dis[0][T])
			F[i]=1ll*f[0][i]*f[1][i]%mod;
		if(!l[i])
			l[i]=1,r[i]=tot;
	}
	TopSort(0),TopSort(1);
	for(int i=1;i<=n;++i)
	{
		if(l[i]<=r[i])
		{
			id_l[l[i]].push_back(i);
			id_r[r[i]].push_back(i);
		}
	}
	long long ans=0;
	for(int i=1;i<=tot;++i)
	{
		for(vector<int>::iterator it=id_l[i].begin();it!=id_l[i].end();++it)
			++cnt[F[*it]];
		ans+=cnt[get_dif(F[T],F[p[i]])];
		for(vector<int>::iterator it=id_r[i].begin();it!=id_r[i].end();++it)
			--cnt[F[*it]];
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：JoaoFelix (赞：6)

讲一种和题解不大一样的做法，但是都要用bitset

首先这题有种不靠谱的过题办法，就是我们发现其实它造的数据不强，~~很弱~~，因为所有数据里面的最短路都只有一条，那么我们就有非常方便的办法解决了！

Ans就是在最短路上的点数乘以不在最短路上的点数，我们用一个cnt数组记录一下当前最短路的点数就可以。

代码：
```cpp
#include<bits/stdc++.h>
#define LL long long
#define pb push_back
#define pii pair<int,int>
using namespace std;
const int N=5e4+5;
const LL Inf=1e18;
int n,m,s,t,cnt[N];LL dis[N];bool inq[N];
vector<pii>adj[N];queue<int>q;
int main(){
	scanf("%d%d%d%d",&n,&m,&s,&t);
	for(int i=1,u,v,w;i<=m;i++)scanf("%d%d%d",&u,&v,&w),adj[u].pb(pii(v,w)),adj[v].pb(pii(u,w));
	for(int i=1;i<=n;i++)dis[i]=Inf;
	q.push(s);dis[s]=0;cnt[s]=1; 
	while(!q.empty()){
		int u=q.front(),v,w;q.pop();inq[u]=false;
		for(auto e:adj[u]){
			v=e.first;w=e.second;
			if(dis[v]>dis[u]+(LL)w){
				dis[v]=dis[u]+(LL)w;cnt[v]=cnt[u]+1;
				if(!inq[v])q.push(v),inq[v]=true;
			}
		}
	}
	if(dis[t]>=Inf)printf("%lld\n",(LL)n*(n-1)/2);else printf("%d\n",cnt[t]*(n-cnt[t]));
	return 0;
}
```

我们考虑正解怎么做？

首先我们考虑如果这个图没有最短路，也就是不连通，那么我们是不是所有的选择方案都可以？

我们先考虑，如果这题的范围是n<=2000，那么我们是不是可以用n方的时间去枚举这两个点，然后我们判断一下这两个点是否满足题目所要求的的关系

怎么判断呢？

我们发现情况大概分为两类，

一类是两个点都在最短路上，那么我们需要满足的条件应该是两个点不能出现在同一条最短路上，并且我们考虑记录一下每个点u出现在多少条最短路上为F(u)

那么F(u)+F(v)=F(t)，F(t)表示终点，这里指的就是所有最短路的条数

还有另外一类就是一个点出现在所有的最短路上，还有一个点在所有最短路上都没有出现过，那么我们这个可以预处理出出现在所有的最短路上的点，以及所有最短路上都没有出现过的点，然后就可以O(1)判断

我们来简要地说一下这个F和是否出现在最短路上怎么是实现？

大概是我们用s和t分别作为起点来跑最短路，如果一个点在最短路上就是一个点s为起点的dis加上t为起点的dis等于原图的最短路长度，

同理，我们通过cnt数组记录了一个点最短路的条数，我们用这个点在原图和反图的cnt乘一下，就可以得到这个点在多少最短路上，我们这里用了一个模数，因为这个条数可能很大，这里998244353不会被卡，可以放心使用。

然后两个点是否出现在同一个最短路上，我们可以用类似于记录cnt的方法，对于每个点维护个bitset，这里将近1G的内存是可以接受50000的这个规模的。

于是我们大概得出了O(n^2)的暴力代码：
（加上不连通的判断可以通过90%的测试点）
```cpp
#include<bits/stdc++.h>
#define LL long long
#define pii pair<LL,int>
using namespace std;
const int N=5e4+5,P=998244353;
const LL Inf=1e18;
struct Edge{int to,w,nxt;}e[N<<1];
int n,m,s,t,fst[N],tote,ans;bool fl[2005][2005];
bitset<N>b[N];
void adde(int u,int v,int w){e[++tote]=(Edge){v,w,fst[u]};fst[u]=tote;}
struct Dij{
	LL dis[N];int cnt[N];bool vis[N];
	priority_queue<pii>q;
	void dij(int s,int type){
		for(int i=1;i<=n;i++)dis[i]=Inf,vis[i]=false;
		q.push(pii(0,s));dis[s]=0;cnt[s]=1;
		if(type==1)b[s].set(s);
		while(!q.empty()){
			int u=q.top().second;q.pop();
			if(vis[u])continue;vis[u]=true;
			for(int i=fst[u],v,w;i;i=e[i].nxt){
				v=e[i].to;w=e[i].w;
				if(dis[v]>dis[u]+(LL)w){
					dis[v]=dis[u]+(LL)w,q.push(pii(-dis[v],v));
					if(type==1)b[v].reset(),b[v].set(v),b[v]|=b[u];
					cnt[v]=cnt[u];
				}else if(dis[v]==dis[u]+(LL)w){
					if(type==1)b[v]|=b[u];
					cnt[v]=(cnt[v]+cnt[u])%P;
				}
			}
		}
	}
}G,G2;
int main(){
	scanf("%d%d%d%d",&n,&m,&s,&t);
	for(int i=1,u,v,w;i<=m;i++)scanf("%d%d%d",&u,&v,&w),adde(u,v,w),adde(v,u,w);
	G.dij(s,1);G2.dij(t,2);
	//for(int i=1;i<=n;i++,puts(""))for(int j=1;j<=n;j++)printf("%d",(int)b[i][j]);
	//for(int i=1;i<=n;i++)printf("i:%d %d %d\n",i,G.cnt[i],G2.cnt[i]);
	if(G.dis[t]>=Inf){printf("%lld\n",(LL)n*(n-1)/2);return 0;}
	for(int i=1;i<=n;i++)for(int j=1;j<=n;j++){
		if(!b[i][j]&&!b[j][i]&&G.dis[i]+G2.dis[i]==G.dis[t]&&G.dis[j]+G2.dis[j]==G.dis[t]&&
		((LL)G.cnt[i]*G2.cnt[i]%P+(LL)G.cnt[j]*G2.cnt[j])%P==G.cnt[t])fl[i][j]=true;
		if((G.dis[i]+G2.dis[i]!=G.dis[t]&&G.dis[j]+G2.dis[j]==G.dis[t]&&(LL)G.cnt[j]*G2.cnt[j]%P==G.cnt[t])||
		(G.dis[j]+G2.dis[j]!=G.dis[t]&&G.dis[i]+G2.dis[i]==G.dis[t]&&(LL)G.cnt[i]*G2.cnt[i]%P==G.cnt[t]))fl[i][j]=true;
	}
	for(int i=1;i<=n;i++)for(int j=i+1;j<=n;j++)if(fl[i][j])ans++;
	printf("%d\n",ans);
	return 0;
}
```

然后我们的事情是怎么优化这个暴力的代码？

我们发现第一个我们可以用bitset优化，我们下面的两步也可以用bitset来优化。

我们这里需要多开几个bitset：

我们首先求出一个点的满足范围的点数是哪些？

首先我们要求出在最短路上的点记在can里面，然后我们每个点如果是和它再一条最短路上的点我们就G[i][j]=1，我们只需要在最后flip一下，并且和can去一个&就可。

然后我们需要求一个方案数的加法为总最短路的条数的个数？

这个我们可以把方案数存在一个map里面，每次动态更新一个bitset now，表示当前情况下满足条件的解，存在这个now里面。

需要注意的是，如果两个方案数相同这里我们可以直接使用这个now，然后在不同的时候我们在把之前的撤销，放上新的满足的点，这样我们更新的点数是O(n)的，可以保证复杂度。

我们开n个bitset，分别代表Ans[i]，如果Ans[i][j]，那么这就代表i和j是满足条件的，

我们只需要把所有的条件&在一起就可以求出第一种情况的所有解，然后我们是第二种情况。

我们发现第二种情况比第一种情况简单的多，我们求一个不在最短路上点和在所有最短路上的点，然后我们每次对于一个i，判断一下它的类型，然后分别取or就可以。

这个可能比较好理解，看下代码应该就行了，如果不理解的可以尝试理解一下暴力的代码，或许理解了一个发现这步是很简单的！

然后我们开好多个bitset就ok了，实测不会mle，因为50000方的bitset的空间实际上很小的，因此我们/64以后开三个这样大小的bitset在对于1G这个空间限制是绰绰有余的。

给出100分正解代码：

```cpp
#include<bits/stdc++.h>
#define LL long long
#define pb push_back
#define pii pair<LL,int>
using namespace std;
const int N=5e4+5,P=998244853;
const LL Inf=1e18;
struct Edge{int to,w,nxt;}e[N<<1];
int n,m,s,t,fst[N],tote;LL ans; 
bitset<N>can,now,Ans[N],noin,imp;
void adde(int u,int v,int w){e[++tote]=(Edge){v,w,fst[u]};fst[u]=tote;}
struct Dij{
	LL dis[N];int cnt[N];bool vis[N];
	priority_queue<pii>q;bitset<N>b[N];
	void dij(int s,int type){
		for(int i=1;i<=n;i++)dis[i]=Inf,vis[i]=false;
		q.push(pii(0,s));dis[s]=0;cnt[s]=1;
		if(type==1)b[s].set(s);
		while(!q.empty()){
			int u=q.top().second;q.pop();
			if(vis[u])continue;vis[u]=true;
			for(int i=fst[u],v,w;i;i=e[i].nxt){
				v=e[i].to;w=e[i].w;
				if(dis[v]>dis[u]+(LL)w){
					dis[v]=dis[u]+(LL)w,q.push(pii(-dis[v],v));
					b[v].reset();b[v].set(v);b[v]|=b[u];
					cnt[v]=cnt[u];
				}else if(dis[v]==dis[u]+(LL)w)
					b[v]|=b[u],cnt[v]=(cnt[v]+cnt[u])%P;
			}
		}
	}
}G,G2;
int c[N],id,ord[N];
unordered_map<int,int>rb;
vector<int>vec[N];
bool Cmp(int a,int b){return c[a]<c[b];}
int main(){
	scanf("%d%d%d%d",&n,&m,&s,&t);
	for(int i=1,u,v,w;i<=m;i++)scanf("%d%d%d",&u,&v,&w),adde(u,v,w),adde(v,u,w);
	G.dij(s,1);G2.dij(t,2);
	if(G.dis[t]>=Inf){printf("%lld\n",(LL)n*(n-1)/2);return 0;}
	for(int i=1;i<=n;i++)if(G.dis[i]+G2.dis[i]==G.dis[t])can[i]=true;
	for(int i=1;i<=n;i++)G.b[i].flip(),G2.b[i].flip(),G.b[i]&=can,G2.b[i]&=can;
	for(int i=1;i<=n;i++){
		c[i]=(LL)G.cnt[i]*G2.cnt[i]%P;
		if(!rb[c[i]])rb[c[i]]=++id;
		ord[i]=i;vec[rb[c[i]]].pb(i);
	}
	sort(ord+1,ord+n+1,Cmp);
	for(int i=1,nt;i<=n;i++){
		nt=ord[i];
		if(i==1||c[nt]!=c[ord[i-1]]){
			if(i>1)for(auto x:vec[rb[(G.cnt[t]-c[ord[i-1]]+P)%P]])now[x]=false;
			for(auto x:vec[rb[(G.cnt[t]-c[nt]+P)%P]])now[x]=true;
		}
		if(can[nt])Ans[nt]=(now&G.b[nt]&G2.b[nt]);
	}
	for(int i=1;i<=n;i++)if(G.dis[i]+G2.dis[i]!=G.dis[t])noin[i]=true;
	for(int i=1;i<=n;i++)if(G.dis[i]+G2.dis[i]==G.dis[t]&&(LL)G.cnt[i]*G2.cnt[i]%P==G.cnt[t])imp[i]=true;
	for(int i=1;i<=n;i++){
		if(noin[i])Ans[i]|=imp;
		if(imp[i])Ans[i]|=noin;
	}
	for(int i=1;i<=n;i++)Ans[i][i]=false;
	for(int i=1;i<=n;i++)ans+=(LL)Ans[i].count();
	printf("%lld\n",ans>>1);
	return 0;
}
```


---

## 作者：wangziyue_AK (赞：2)

介绍题解中没有的一种简单且有正确性保证的做法。
## 限制转化：
首先有一个显然的结论，记 $S$ 到 $T$ 的最短路中经过 $i$ 的路径个数为 $f(i)$，点对 $(A,B)$ 合法的一个**必要条件**是 $f(A)+f(B)=f(S)=f(T)$。也就是 $A,B$ 两个点把 $S$ 到 $T$ 的路径刚好全部堵住。但这并不充分，考虑一种边集：$(1,2),(2,3),(3,4),(1,4)$，其中 $S=1,T=4$，这时 $f(2)=f(3)=1$，而 $f(S)=f(T)=2$，按照上述方式会认为 $(2,3)$ 是一个合法的点对，但实际上不合法。
## 解决方案：
考虑一个类似和哈希的东西，把每一条边随机变为若干条边，再求方案数，这样出现不合法点对的概率就会大大减小。**注意，这不是随机化乱搞，这可以看做是一种哈希**。但还有一个小问题，$f$ 的值可以达到指数级，难以存储和计算，所以要对一个大指数取模，必要的话可以使用双模哈希。
## 如何求 $f(i)$：
若 $dis_{S->i}+dis_{i->T}$，则正着求一遍 $S$ 到 $i$ 的最短路个数，反着再求一遍 $T$ 到 $i$ 的最短路个数，若 $dis_{S->i}+dis_{i->T}$，相乘即可，否则答案自然为 $0$。

---

## 作者：AyeeMinerva (赞：1)

蒟蒻使用野生的 dijskra 算法和 stl 容器。

# 分析

题设要求求出 $s$ 到 $t$ 的所有可能最短路径，采用（野生的）dijskra 算法并记录路径。

在改造的野生 dijskra 算法中，大概思路如下:
1. 使用堆优化，堆顶则为当前最短路径长度最短的，对于未使用其更新过的节点，用它尝试更新其邻接点的最短路径长度。
2. 若其邻接点新得到的路径长度小于它当前的最短路径长度，说明取得更短路，更新路径。
3. 若其邻接点新得到的路径长度等于它当前的最短路径长度，说明有另几种方式，增加路径。

对于序对 $(a,b)$ 的要求，翻译为：
1. $a$ 和 $b$ 覆盖所有路径（对于任意一条最短路，要么经过 $a$ 要么经过 $b$）。
2. $a$ 和 $b$ 不能同时出现在同一条路径中。

其余的东西都在代码里了。

不过注意本题有个坑点就是在于 $t$ 不能到达时，应该取 $t \times (t-1)/2$ ，但是对于 $t\times (t-1)$，long long可能溢出，故应该先除。

# 个人代码

```cpp
#include <iostream>
#include <vector>
#include <unordered_map>
#include <set>
#include <queue>
using namespace std;
#define ll long long
const ll N = 5e4 + 10;
const ll M = 2 * N;
ll head[N], to[M], nxt[M], wei[M], tot = 0;
void add(ll a, ll b, ll w)
{
    to[++tot] = b;
    nxt[tot] = head[a];
    head[a] = tot;
    wei[tot] = w;
}
vector<vector<ll>> ways[N];//ways[i]:到i点的所有可行最短路
struct node
{
    ll dis;
    ll num;
    bool operator<(node b) const
    {
        return dis > b.dis;
    }
};
void dij(ll root)//dijskra算法，寻找以root点出发的到所有其他点的最短路径
{
    priority_queue<node> que;//使用堆优化
    ll miniLen[N];
    for (ll i = 0; i < N; i++)
        miniLen[i] = 1e12;
    bool used[N]{0};//是否用过i号节点进行更新
    ways[root].push_back(vector<ll>{root});
    que.push({0, root});
    while (!que.empty())
    {
        //使用队头进行更新
        node top = que.top();
        que.pop();
        if (used[top.num])
            continue;
        for (ll i = head[top.num]; i; i = nxt[i])
            if (top.dis + wei[i] == miniLen[to[i]])
            {
                for (vector<ll> t : ways[top.num])//增加这条路径
                {
                    ways[to[i]].push_back(t);
                    ways[to[i]].back().push_back(to[i]);
                }
            }
            else if (top.dis + wei[i] < miniLen[to[i]])//重置更新到这点的最短路
            {
                ways[to[i]].clear();
                miniLen[to[i]] = top.dis + wei[i];
                for (vector<ll> t : ways[top.num])
                {
                    ways[to[i]].push_back(t);
                    ways[to[i]].back().push_back(to[i]);
                }
                que.push({top.dis + wei[i], to[i]});
            }
        used[top.num] = true;
    }
}

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    ll n, m, s, t;
    cin >> n >> m >> s >> t;
    for (ll i = 0; i < m; i++)
    {
        ll a, b, c;
        cin >> a >> b >> c;
        add(a, b, c);
        add(b, a, c);
    }
    dij(s);
    if (ways[t].empty())//特判t不能到达的情况：所有点都可以
    {
        //此处如果不先除，则会有精度溢出的问题！！
        if (n & 1)
            cout << (n - 1) / 2 * n;
        else
            cout << n / 2 * (n - 1);
        return 0;
    }
    set<ll> appeared;//记录最短路中出现的节点
    unordered_map<ll, ll> varNum; // varNum[i]: i在最短路中的出现的次数/多少条最短路中经给i
    for (auto x : ways[t])
    {
        for (ll y : x)
        {
            ++varNum[y];
            appeared.insert(y);
        }
    }
    unordered_map<ll, set<ll>> varWith;//varWith[i]:和i同时出现过的元素集合
    for (auto x : ways[t])
    {
        for (auto y = x.begin(); y != x.end(); y++)
            for (auto z = y + 1; z != x.end(); z++)
            {
                varWith[*y].insert(*z);
                varWith[*z].insert(*y);
            }
    }
    set<pair<ll, ll>> pairs;//储存可能的序对(a,b)
    //1. a和b没有同时出现  2. a和b覆盖所有路径
    for (auto a : appeared)//FAQ:此处不用for(auto [a,_]:varNum)的原因：unordered_map只要查询不到mp[i]就会插入一个{i,默认数据类型}的键值对，会产生不合预期的错误
        for (ll b = 1; b <= n; b++)
            if (a != b && varWith[a].count(b) == 0 && varNum[b] + varNum[a] == ways[t].size())
            {
                pairs.insert(make_pair(a, b));
                pairs.insert(make_pair(b, a));
            }
    cout << pairs.size() / 2;

    return 0;
}
```

---


# 荒芜的海洋

## 题目背景

在一个渺远的海洋中，一场世纪大战级别的游戏上演了。

感谢 [lsq](https://www.luogu.org/space/show?uid=26556) 本人参与验题

## 题目描述

这块海洋上有n个小岛，小岛有m座石桥相连。有一些小岛上有wzt埋下的奖赏，它们非常诱人。它们的诱惑力用整数ki描述。而一些小岛上有lsq的雇佣兵，他们有一个价格，用整数bi描述。lsq必须花钱，他的雇佣兵才会帮他寻找奖赏。 

雇佣兵的价格并不会变。对于每一个雇佣兵，在寻找过程中，他会越过一座座的桥，这过程中，他的价格会 **加上他所经过的所有桥的长度** 。

遗憾的是，不只有桥的阻挡，每座岛上有许多猛兽，虽然雇佣兵们都英勇无比，但驱逐猛兽的过程会让人很不爽。因此，对于每一个雇佣兵，价格会 **加上他所经过的所有岛（包括出发岛）上的猛兽数量之和**。

lsq了解这里的一切情况，他需要做出决策，即决定他的每个雇佣兵应该去找哪个奖赏。lsq的目的是找到所有奖赏，并取得最大收益。每个雇佣兵只能雇佣一次。

收益的定义为： **所有奖赏的诱惑力减去lsq花的所有的钱**

lsq的决策异常艰难，于是只好请 ~~AK过NOI~~ 的你来帮忙。

## 说明/提示

对于30% 的数据，满足n<=200，m<=200，b<=a<=30

对于50% 的数据，满足n<=500，m<=800，b<=a<=100

对于100% 的数据，满足n<=1000，m<=15000，b<=a<=300，其余数据保证不会爆int(Pascal语言为longint)

![](https://cdn.luogu.com.cn/upload/pic/14497.png)
![](https://cdn.luogu.com.cn/upload/pic/14498.png)

By [Ebola](https://www.luogu.org/space/show?uid=20158)

## 样例 #1

### 输入

```
4 6 3 2
16 37 22 24 
1 4 25
1 1 23
4 1 20
3 1 47
1 1 18
3 3 24
213 1
174 2
62 4
1493 3
2632 4```

### 输出

```
Yes
3741```

## 样例 #2

### 输入

```
4 2 3 2
16 37 22 24
1 4 25
1 3 12
213 1
174 3
62 4
1493 2
2632 4```

### 输出

```
No
1```

# 题解

## 作者：Tweetuzki (赞：11)

最小费用最大流。

租每一个雇佣兵，我们就从超级源向这个雇佣兵所在岛屿连一条容量为1（因为只能雇佣一次），费用为该雇佣兵价格的边。

对于每座桥，我们看作是一条连接点的无向边。则从该桥两边向彼此连一条容量为INF，费用为该桥长度的边。

对于每座岛上的野兽，我们可以拆点。把该岛拆成入点和出点，入点向出点连一条容量为INF，费用为该岛野兽数量的边。

对于每一个奖赏，都向超级汇连一条长度为1（因为只能取一次），费用为0的边。

最后求解最小费用最大流即可。

若最大流流量小于宝藏数量，则无法获得所有的奖赏。输出最大流的流量。

否则可以获得所有的宝藏。输出所有奖赏的诱惑力减去最小费用。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <queue>
using namespace std;

typedef pair<int, int> P;

const int MAXN = 2001, MAXM = 15000, INF = 0x7F7F7F7F;

struct edge {
    int to, cap, cost, rev;
};

int n, m, a, b, sum;
vector <edge> G[MAXN + 1];

edge make_edge(int to, int cap, int cost, int rev) {
    edge x;
    x.to = to, x.cap = cap, x.cost = cost, x.rev = rev;
    return x;
}

void add_edge(int from, int to, int cap, int cost) {
    G[from].push_back(make_edge(to, cap, cost, G[to].size()));
    G[to].push_back(make_edge(from, 0, -cost, G[from].size() - 1));
}

void init() {
    scanf("%d%d%d%d", &n, &m, &a, &b);
    for (int i = 1; i <= n; ++i) {
        int x;
        scanf("%d", &x);
        add_edge(i, i+n, INF, x);
    }
    for (int i = 1; i <= m; ++i) {
        int u, v, w;
        scanf("%d%d%d", &u, &v, &w);
        add_edge(u + n, v, INF, w);
        add_edge(v + n, u, INF, w);
    }
    for (int i = 1; i <= a; ++i) {
        int q, p;
        scanf("%d %d", &q, &p);
        add_edge(0, p, 1, q);
    }
    for (int i = 1; i <= b; ++i) {
        int k, q;
        scanf("%d %d", &k, &q);
        sum += k;
        add_edge(q + n, n + n + 1, 1, 0);
    }
}

namespace EK_SPFA {
    int dis[MAXN + 1];
    int prev[MAXN + 1];
    int pree[MAXN + 1];

    void bfs(int s) {
        bool mark[MAXN + 1];
        memset(dis, 0x7F, sizeof(dis));
        memset(prev, -1, sizeof(prev));
        memset(pree, -1, sizeof(pree));
        memset(mark, 0, sizeof(mark));
        queue <int> q;
        dis[s] = 0;
        q.push(s);
        while (!q.empty()) {
            int x = q.front();
            q.pop();
            mark[x] = false;
            for (int i = 0; i < G[x].size(); ++i) {
                edge &e = G[x][i];
                if (e.cap > 0  &&  dis[x] + e.cost < dis[e.to]) {
                    dis[e.to] = dis[x] + e.cost;
                    prev[e.to] = x;
                    pree[e.to] = i;
                    if (!mark[e.to]) {
                        mark[e.to] = true;
                        q.push(e.to);
                    }
                }
            }
        }
    }

    P min_cost_max_flow(int s, int t) {
        int flow = 0, cost = 0;
        for(;;) {
            bfs(s);
            if (dis[t] == INF)
                return make_pair(flow, cost);
            int d = INF;
            for (int i = t; prev[i] != -1; i = prev[i])
                d = min(d, G[prev[i]][pree[i]].cap);
            flow += d;
            cost += d*dis[t];
            for (int i = t; prev[i] != -1; i = prev[i]) {
                edge &e = G[prev[i]][pree[i]];
                e.cap -= d;
                G[e.to][e.rev].cap += d;
            }
        }
    }
}

int main() {
    init();
    P ans = EK_SPFA::min_cost_max_flow(0, n + n + 1);
    if (ans.first < b) {
        puts("No");
        printf("%d\n", ans.first);
    } else {
        puts("Yes");
        printf("%d\n", sum - ans.second);
    }
    return 0;
}
```

---

## 作者：Maniac丶坚果 (赞：2)

**注意关键字:每个雇佣兵最多只能雇用一次**

看到这个关键字就是SB题了。

先跑a遍最短路得出每个雇佣兵拿每个宝物需要的代价（事实证明并没有卡spfa,不必写dijkstra+堆），然后做一次二分匹配即可。

（考试的时候居然忘了KM 怎么写...回过神来才想起确定了两边点以后的二分匹配网络流也是能做的QAQ）

代码：
```
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1003;
const int maxm = 15003;
const int INF = 0x3f3f3f3f;
inline int read()
{
    int x = 0, f = 1;
    char ch = 0;
    for (;!isdigit(ch);ch = getchar()) if (ch == '-') f = -1;
    for (;isdigit(ch);ch = getchar()) x = x *10 + ch - 48;
    return x * f;
}
const int S = 0, T = 1001;
struct node{int ne,to,dis,w,f;}e[maxm <<7];
int n,m,A,B;
int a[maxn][maxn],s[maxn],bing[maxn][2],bao[maxn][2],he[maxn],nume;
int dis[305][maxn],Dis[maxn],pre[maxn],ed[maxn],flow,cost;
int que[maxn << 4],He,ta;
bool vis[maxn],used[maxn];
int C[maxn];
inline void add(int p,int q,int r,int s)
{
    //printf("%d %d %d %d\n",p,q,r,s);
    e[++nume].to = q; e[nume].w = r; e[nume].f = s; e[nume].ne = he[p]; he[p] = nume;
    e[++nume].to = p; e[nume].w = -r; e[nume].f = 0; e[nume].ne = he[q]; he[q] = nume;
}
inline void addside(int p,int q,int r)
{
//	printf("%d %d %d\n",p,q,r);
    if (p == q) return;
    e[++nume].to = q; e[nume].ne = he[p]; he[p] = nume; e[nume].dis = r;
}
bool Spfa() 
{
    memset(Dis,63,sizeof(Dis));
    memset(vis,0,sizeof(vis));
    Dis[S] = 0;vis[S] = 1;
    queue<int> q; q.push(S);
    while (!q.empty())
    {
        int f = q.front(); q.pop();vis[f] = 0;
        for (int i = he[f]; i; i = e[i].ne)
        {
            if (Dis[e[i].to] > Dis[f] + e[i].w && e[i].f)
            {
                pre[e[i].to] = f,Dis[e[i].to] = Dis[f] + e[i].w; ed[e[i].to] = i;
                if (!vis[e[i].to]) vis[e[i].to] = 1, q.push(e[i].to);				
            }
        }
    }
    if (Dis[T] == INF) return 0;
    int tmp = INF,all = 0; 
    for (int i = T; i != S; i = pre[i]) tmp = min(tmp,e[ed[i]].f);
    for (int i = T; i != S; i = pre[i]) e[ed[i]].f-= tmp, e[ed[i]^1].f += tmp;
    flow += tmp; cost += Dis[T];
    return 1;
}
void spfa(int now)
{
    memset(vis,0,sizeof(vis));
    dis[now][bing[now][1]] = s[bing[now][1]];
    He = ta = 1;que[He] = bing[now][1];
    while (He <= ta)
    {
        int f = que[He];
        for (int i = he[f]; i; i = e[i].ne)
        {
            if (dis[now][e[i].to] > dis[now][f] + e[i].dis + s[e[i].to])
            {
                dis[now][e[i].to] = dis[now][f] + e[i].dis + s[e[i].to];
                if (!vis[e[i].to]) que[++ta] = e[i].to, vis[e[i].to] = 1;
            }
        }
        vis[f] = 0;He++;
    }
    for (int i = 1; i <= n; ++i) dis[now][i] += bing[now][0];
}
int main()
{
    memset(a,63,sizeof(a));memset(dis,63,sizeof(dis));
    n = read(); m = read(), A = read(); B = read();
    for (int i = 1; i <= n; ++i) s[i] = read();
    for (int i = 1; i <= m; ++i) 
    {
        int u = read(), v = read(), w = read();
        a[u][v] = min(a[u][v],w); a[v][u] = min(a[v][u],w);
    }
    for (int i = 1; i <= A; ++i) bing[i][0] = read(), bing[i][1] = read();
    for (int i = 1; i <= B; ++i) bao[i][0] = read(), bao[i][1] = read();
    for (int i = 1; i <= n; ++i)
    for (int j = i + 1; j <= n; ++j)
    {
        if (a[i][j] == INF) continue;
        else addside(i,j,a[i][j]),addside(j,i,a[i][j]); 
    }
    for (int i = 1; i <= A; ++i) spfa(i);
    memset(he,0,sizeof(he)); nume = 1;
    for (int i = 1; i <= A; ++i)
    for (int j = 1; j <= B; ++j)
        if (dis[i][bao[j][1]] < (int)1e9)add(i,j+A+5,dis[i][bao[j][1]],1);
    for (int i = 1; i <= A; ++i) add(S,i,0,1);
    for (int i = 1; i <= B; ++i) add(i+A+5,T,0,1);
    while (Spfa());
    int tot = 0;
    for (int i = 1; i<= B; ++i) tot += bao[i][0];
    if (flow != B) printf("No\n%d\n",flow);
    else printf("Yes\n%d\n",tot - cost);
}
```

---

## 作者：JK_LOVER (赞：1)

## 题意
给出一张有 $n$ 节点图，每条边和每个点都有花费，求出所有目标点都可到达的输出最小花费，如果不能则输出最多可到达的目标点个数。[QWQ](https://www.luogu.com.cn/blog/xzc/solution-p4237)
## 分析
我们先考虑一个出发点和一个目标点的情况，那么我们发现这就是个最短路，路的长度为经过的边和点权的和。那么有多个出发点和多个目标点时，这就把原图转化为一个二分图，这里就是求二分图最小权完美匹配。

- $KM$ 和 $MCMF$ 都可以求解。那我们直接做个费用流，将最短路的部分在主函数中处理，而不是预处理后再做二分图匹配，那么这就是个费用流的板子题了，只是要记住拆点。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int inf = 0x3f3f3f3f;
const int N = 30510;
int n,m,maxflow,mincost,A,B,head[N],lastn[N],laste[N],dis[N],vis[N],a[N],cnt = 1;
struct Edge{int flow,cap,to,nxt,cost;}e[N<<1];
void Add(int x,int y,int cap,int cost){
	e[++cnt].flow = 0;e[cnt].cap = cap;e[cnt].to = y;e[cnt].nxt = head[x];e[cnt].cost = cost;head[x] = cnt;
	e[++cnt].flow = 0;e[cnt].cap = 0; e[cnt].to = x;e[cnt].nxt = head[y];e[cnt].cost = -cost;head[y] = cnt; 
}
queue<int> Q;
bool Bfs(int s,int t){
	memset(dis,inf,sizeof(dis));dis[s] = 0;
	memset(a,0,sizeof(a)); a[s] = inf;
	memset(vis,0,sizeof(vis)); vis[s] = 1;
	Q.push(s);
	while(Q.size()){
		int x = Q.front();Q.pop();vis[x] = 0;
		for(int i = head[x];i;i = e[i].nxt)
		{
			int y = e[i].to;
			if(e[i].cap > e[i].flow && dis[y] > dis[x] + e[i].cost)
			{
				dis[y] = dis[x] + e[i].cost;
				lastn[y] = x;
				laste[y] = i;
				a[y] = min(a[x],e[i].cap - e[i].flow);
				if(vis[y]) continue;
				vis[y] = 1;Q.push(y);
			}
		}
	}
	return a[t] > 0;
}
void Mcmf(int s,int t)
{
	while(Bfs(s,t)){
		int u = t;
		while(u != s){
			e[laste[u]].flow += a[t];
			e[laste[u]^1].flow -= a[t];
			u = lastn[u];
		}
		maxflow += a[t];
		mincost += a[t] * dis[t];
	} 
}
int read(){
	int x;scanf("%d",&x);return x;
}
int main()
{
	n = read();m = read();A = read();B = read();
	for(int i = 1;i <= n;i++)
	{
		int cost = read();
		Add(i,i+n,inf,cost);
	}
	for(int i = 1;i <= m;i++)
	{
		int a = read(),b = read(),w = read();
		Add(a+n,b,inf,w);
		Add(b+n,a,inf,w);
	}
	int s = 0,t = 2*n+1;
	for(int i = 1;i <= A;i++){
		int q = read(),p = read();
		Add(s,p,1,q);
	}
	for(int i = 1;i <= B;i++){
		int k = read(),q = read();
		Add(q+n,t,1,-k);
	}
	Mcmf(s,t);
	if(maxflow == B){	
		printf("Yes\n%d\n",-mincost);
	}
	else printf("No\n%d\n",maxflow);
	return 0;
}



```


---

## 作者：happybob (赞：0)

我们先要保证奖赏尽量多，其次费用尽量小。应该可以看出，是一个最小费用最大流。如何建模？

考虑拆点。

每个岛屿分成一个入点一个出点。对于有雇佣兵的岛屿，源点向这个入点连容量为 $1$，费用为费用的边。对于怪兽的岛屿，连这个点的入点和出点，容量为 $+\infty$，费用为打怪兽的价格。对于桥梁，连出点和入点，容量为 $+\infty$，费用为经过的价格。对于有奖赏的岛，出点向汇点连边，容量为 $1$，费用为 $0$ 的边。

最小费用最大流即可，注意桥梁是双向边。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <string>
#include <vector>
#include <queue>
#include <climits>
using namespace std;

#define int long long

const int N = 5e5 + 5;

int n, m, a, b;
int S = 0, T = 0;
int e[N], h[N], c[N], cs[N], ne[N], idx;

void add(int u, int v, int w, int cc)
{
	//cout << "!!: " << u << " " << v << " " << w << " " << cc << "\n";
	e[idx] = v, c[idx] = w, ne[idx] = h[u], cs[idx] = cc, h[u] = idx++;
	e[idx] = u, c[idx] = 0, ne[idx] = h[v], cs[idx] = -cc, h[v] = idx++;
}

int dis[N], cur[N];
bool isin[N];

bool spfa()
{
	for (int i = 0; i <= T; i++)
	{
		isin[i] = 0;
		dis[i] = 5e9;
		cur[i] = -1;
	}
	queue<int> q;
	q.push(S);
	dis[S] = 0, cur[S] = h[S];
	while (q.size())
	{
		int u = q.front(); 
		q.pop();
		isin[u] = 0;
		for (int i = h[u]; ~i; i = ne[i])
		{
			int j = e[i];
			if (c[i] > 0 && dis[j] > dis[u] + cs[i])
			{
				//cout << j << "\n";
				cur[j] = h[j];
				dis[j] = dis[u] + cs[i];
				if (!isin[j])
				{
					q.push(j);
					isin[j] = 1;
				}
			}
		}
	}
	//cout << dis[T] << " " << dis[N - 1] << "\n";
	//system("pause");
	return (dis[T] != 5e9);
}

int mincost = 0;

int dfs(int u, int lim)
{
	if (u == T) return lim;
	isin[u] = 1;
	int sum = 0;
	for (int i = cur[u]; ~i && sum < lim; i = ne[i])
	{
		cur[u] = i;
		int j = e[i];
		if (dis[j] == dis[u] + cs[i] && c[i] > 0 && !isin[j])
		{
			int p = dfs(j, min(c[i], lim - sum));
			sum += p;
			c[i] -= p;
			c[i ^ 1] += p;
			mincost += p * cs[i];
		}
	}
	isin[u] = 0;
	return sum;
}

int dinic()
{
	int res = 0;
	while (spfa())
	{
		while (int p = dfs(S, INT_MAX)) res += p;
	}
	return res;
}

signed main()
{
	ios::sync_with_stdio(0), cin.tie(nullptr), cout.tie(nullptr);
	memset(h, -1, sizeof h);
	cin >> n >> m >> a >> b;
	for (int i = 1; i <= n; i++)
	{
		int x;
		cin >> x;
		add(i, i + n, INT_MAX, x);
	}
	T = 2 * n + 1;
	for (int i = 1; i <= m; i++)
	{
		int u, v, w;
		cin >> u >> v >> w;
		if (u == v) continue;
		add(u + n, v, INT_MAX, w);
		add(v + n, u, INT_MAX, w);
	}
	for (int i = 1; i <= a; i++)
	{
		int p, q;
		cin >> q >> p;
		add(S, p, 1, q);
	}
	int sum = 0LL;
	for (int i = 1; i <= b; i++)
	{
		int k, q;
		cin >> k >> q;
		sum += k;
		add(q + n, T, 1, 0);
	}
	int g = dinic();
	if (g == b)
	{
		cout << "Yes\n" << sum - mincost << "\n";
	}
	else
	{
		cout << "No\n" << g << "\n";
	}
	return 0;
}
```




---

## 作者：TianLuen (赞：0)

## 【荒芜的海洋】 C++题解
### 题意简述

- 可以至多雇佣 $a$ 个人，去寻找 $b$ 个宝藏。
- 宝藏分布在 $n$ 个岛，岛与岛之间共有 $m$ 座桥相连。
- 通过每个岛，需要一定代价 $x_i$ （对应到岛上的野兽数量）。
- 通过每座桥，需要一定代价 $w_i$ （对应到桥的长度）。
- 雇佣每个人，需要一定代价 $q_i$ （对应到雇佣的价格）。
- 每个人一开始都在特定的岛 $p_i$ 上，且只能带一个宝藏离开。
- 每个宝藏都在特定的岛 $q_i$ 上，都有特定的价值 $k_i$。
- 问，能否获取全部宝藏？能，则输出最终收益；不能，则输出获取的宝藏数。

最终收益是 $\sum\limits_{i=1}^{b} k_i$ 减去全部代价。

### 题意分析

这是一个费用流的题目，需要用到拆点、超级源汇。因为有点权，所以需要拆成两个点操作；因为起点、终点都有多个，所以需要将所有起点与超级源相接，所有终点与超级汇相接。因此，建图方式如下：

|对象|连接方式|容量|费用|
|:-:|:-|:-:|:-:|
|岛|拆成两点，连有向边|$\inf$|$x_i$|
|桥|连无向边|$\inf$|$w_i$|
|人|超级源指向 $p_i$|$1$|$q_i$|
|宝藏|$q_i$ 指向超级汇|$1$|$0$|

进行一遍费用流，得到流和费用，按要求输出即可。

### 代码

这里给出费用流的模板，[链接](https://www.luogu.com.cn/paste/4lg5ijl3)。

这份模板可以应对绝大多数费用流的题目，通常不需要修改。调用 `.link(a,b,c,d)` 建图，调用 `.MCMF(a,b)` 可以得到一个 `pair<int,int>` 类型的结果，分别是最大流和最小费用。

除了模板以外的代码如下：

```
graph G;
int main()
{
	int n,m,a,b,sum=0;
	scanf("%d%d%d%d",&n,&m,&a,&b);
	int S=n*2+1,T=n*2+2;	//超级源汇
	for(int i=1;i<=n;i++)	//岛
	{  
	    int x;
	    scanf("%d",&x);
	    G.link(i,i+n,2147483647,x);
	}
	for(int i=1;i<=m;i++)	//桥
	{
	    int u,v,w;
	    scanf("%d%d%d",&u,&v,&w);
	    G.link(u+n,v,2147483647,w);
        G.link(v+n,u,2147483647,w);
	}
	for(int i=1;i<=a;i++)	//人
	{
	    int q,p;
	    scanf("%d%d",&q,&p);
	    G.link(S,p,1,q);
	}
	for(int i=1;i<=b;i++)	//宝藏
	{
	    int k,q;
	    scanf("%d%d",&k,&q);
	    sum+=k;
	    G.link(q+n,T,1,0);
	}
	pair<int,int>ans=G.MCMF(S,T);
	if(ans.first<b)
	    printf("No\n%d",ans.first);
	else
	    printf("Yes\n%d",sum-ans.second);
	return 0;
}
```



---

## 作者：gargantuar (赞：0)

本题题意较为复杂，略考验语文能力。但若找到重点，就能发现这其实是一个裸的最小费用最大流。

**重点**：一个人只能找**一个**奖励。若有能力拿走所有奖励，则必须**全部**拿走（就算费用高于奖励，>导致总收益为负也不例外）。

与普通费用流相同，我们建超级原和超级汇，源向佣兵连流为 $1$ 费用为佣金与野兽数量之和的边，奖励向汇连边，流为 $1$，费用为 $0$，岛与岛之间情况比较复杂，野兽和桥都会产生花费，但其实我们 **没必要拆点** ，考虑双向连边，流量显然为正无穷，只需要将费用设为桥长与终点野兽数量之和就行了，减少了一半的点之后会节省很大常数。当能拿到所有奖励，就输出全部奖励值减去最小费用。如果不能，就输出最大流。

代码如下，现居最优解 rank1 ~~因为暂时没有大佬来秀卡常~~
```cpp
#include<algorithm>
#include<cstdio>
#include<cmath>
#include<queue>
#define MX 1987654321
using namespace std;
//	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=fast read
inline int read() {
	register int a=0,f=1;
	register char g=getchar();
	while(g<'0'||'9'<g) {
		if(g=='-')f=-1;
		g=getchar();
	}
	while('0'<=g&&g<='9') {
		a=a*10+g-'0';
		g=getchar();
	}
	return a*f;
}
//	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=basic var
int n,m,start,aaa,bbb,endd,mon[2047];
//	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=chain forward star
int head[2047],cont=1;
struct li {
	int s,to,next,val,cost;
} e[114514];
inline void add(int s,int t,int cs,int v) {
	e[++cont].s=s;
	e[cont].to=t;
	e[cont].cost=cs;
	e[cont].val=v;
	e[cont].next=head[s];
	head[s]=cont;
	e[++cont].s=t;
	e[cont].to=s;
	e[cont].cost=-cs;
	e[cont].val=0;
	e[cont].next=head[t];
	head[t]=cont;
}
//	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=dinic mcmf
int dis[2047],cur[2047],cst;
bool book[2047];
//	-	-	-	-	-	-	-	-	-	-	-	-	-	-	spfa
inline bool spfa() {
	for(int i=1; i<=n+2; ++i)cur[i]=head[i],dis[i]=MX;
	dis[start]=0;
	queue<int>q;
	q.push(start);
	int ak,vk,ck,th;
	while(!q.empty()) {
		th=q.front();
		q.pop();
		book[th]=0;
		for(int i=head[th]; i; i=e[i].next) {
			ak=e[i].to,vk=e[i].val,ck=e[i].cost;
			if(vk&&dis[ak]>dis[th]+ck) {
				dis[ak]=dis[th]+ck;
				if(!book[ak])book[ak]=1,q.push(ak);
			}
		}
	}
	return dis[endd]!=MX;
}
//	-	-	-	-	-	-	-	-	-	-	-	-	-	-	dfs
int dfs(int a,int flow) {
	if(a==endd)return flow;
	book[a]=1;
	int rnm=flow,ak,vk,ck;
	for(int i=cur[a]; i&&rnm; i=e[i].next) {
		cur[a]=i;
		ak=e[i].to,vk=e[i].val,ck=e[i].cost;
		if(!book[ak]&&vk>0&&dis[ak]==dis[a]+ck) {
			int c=dfs(ak,min(rnm,vk));
			if(c) {
				cst+=c*ck;
				rnm-=c;
				e[i].val-=c;
				e[i^1].val+=c;
			}
		}
	}
	book[a]=0;
	return flow-rnm;
}
//	-	-	-	-	-	-	-	-	-	-	-	-	-	-	dinic
inline int mcmf(){
	int ans=0;
	while(spfa()){
		int l;
		while((l=dfs(start,MX)))ans+=l;
	}
	return ans;
}
//	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=main
int main() {
	n=read(),m=read(),aaa=read(),bbb=read();
	start=n+1;
	endd=n+2;
	for(int i=1;i<=n;++i){
		mon[i]=read();
	}
	int ls,lss,lsss;
	for(int i=1;i<=m;++i){
		ls=read(),lss=read(),lsss=read();
		if(ls==lss)continue;
		add(ls,lss,lsss+mon[lss],MX);
		add(lss,ls,lsss+mon[ls],MX);
	}
	for(int i=1;i<=aaa;++i){
		ls=read(),lss=read();
		add(start,lss,ls+mon[lss],1);
	}
	int ttt=0;
	for(int i=1;i<=bbb;++i){
		ls=read(),lss=read();
		ttt+=ls;
		add(lss,endd,0,1);
	}
	n+=2;
	int kkksc3=mcmf();
	if(kkksc3==bbb){
		printf("Yes\n%d",ttt-cst);
	}else{
		printf("No\n%d",kkksc3);
	}
	return 0;
}
```


---


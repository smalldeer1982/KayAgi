# [NOI2018] 归程

## 题目描述

本题的故事发生在魔力之都，在这里我们将为你介绍一些必要的设定。

魔力之都可以抽象成一个 $n$ 个节点、$m$ 条边的无向连通图（节点的编号从 $1$ 至 $n$）。我们依次用 $l,a$ 描述一条边的**长度、海拔**。

作为季风气候的代表城市，魔力之都时常有雨水相伴，因此道路积水总是不可避免的。由于整个城市的排水系统连通，因此**有积水的边一定是海拔相对最低的一些边**。我们用**水位线**来描述降雨的程度，它的意义是：所有海拔**不超过**水位线的边都是**有积水**的。

Yazid 是一名来自魔力之都的 OIer，刚参加完 ION2018 的他将踏上归程，回到他温暖的家。Yazid 的家恰好在魔力之都的 $1$ 号节点。对于接下来 $Q$ 天，每一天 Yazid 都会告诉你他的出发点 $v$ ，以及当天的水位线 $p$。

每一天，Yazid 在出发点都拥有一辆车。这辆车由于一些故障不能经过有积水的边。Yazid 可以在任意节点下车，这样接下来他就可以步行经过有积水的边。但车会被留在他下车的节点并不会再被使用。
需要特殊说明的是，第二天车会被重置，这意味着：
- 车会在新的出发点被准备好。
- Yazid 不能利用之前在某处停放的车。

Yazid 非常讨厌在雨天步行，因此他希望在完成回家这一目标的同时，最小化他**步行经过的边**的总长度。请你帮助 Yazid 进行计算。

本题的部分测试点将强制在线，具体细节请见【输入格式】和【子任务】。

## 说明/提示

### 更多样例

更多样例请在附加文件中下载。

#### 样例 3

见附加文件中的 `return3.in` 与 `return3.ans`。

该样例满足海拔为一种，且不强制在线。

#### 样例 4

见附加文件中的 `return4.in` 与 `return4.ans`。

该样例满足图形态为一条链，且强制在线。

#### 样例 5

见附加文件中的 `return5.in` 与 `return5.ans`。

该样例满足不强制在线。

### 样例 1 解释

第一天没有降水，Yazid 可以坐车直接回到家中。

第二天、第三天、第四天的积水情况相同，均为连接 1，2 号节点的边、连接 3，4 号点的边有积水。

对于第二天，Yazid 从 2 号点出发坐车只能去往 3 号节点，对回家没有帮助。因此 Yazid 只能纯靠徒步回家。

对于第三天，从 4 号节点出发的唯一一条边是有积水的，车也就变得无用了。Yazid 只能纯靠徒步回家。

对于第四天，Yazid 可以坐车先到达 2 号节点，再步行回家。

第五天所有的边都积水了，因此 Yazid 只能纯靠徒步回家。

### 样例 2 解释

本组数据强制在线。

第一天的答案是 $0$，因此第二天的 $v=\left( 5+0-1\right)\bmod 5+1=5$，$p=\left(2+0\right)\bmod\left(3+1\right)=2$。

第二天的答案是 $2$，因此第三天的 $v=\left( 2+2-1\right)\bmod 5+1=4$，$p=\left(0+2\right)\bmod\left(3+1\right)=2$。

第三天的答案是 $3$，因此第四天的 $v=\left( 4+3-1\right)\bmod 5+1=2$，$p=\left(0+3\right)\bmod\left(3+1\right)=3$。

### 数据范围与约定

所有测试点均保证 $T\leq 3$，所有测试点中的所有数据均满足如下限制：

- $n\leq 2\times 10^5$，$m\leq 4\times 10^5$，$Q\leq 4\times 10^5$，$K\in\left\{0,1\right\}$，$1\leq S\leq 10^9$。
- 对于所有边：$l\leq 10^4$，$a\leq 10^9$。
- 任意两点之间都直接或间接通过边相连。

**为了方便你快速理解，我们在表格中使用了一些简单易懂的表述。在此，我们对这些内容作形式化的说明：**

- 图形态：对于表格中该项为 “一棵树” 或 “一条链” 的测试点，保证 $m = n-1$。除此之外，这两类测试点分别满足如下限制：
  - 一棵树：保证输入的图是一棵树，即保证边不会构成回路。
  - 一条链：保证所有边满足 $u + 1 = v$。
- 海拔：对于表格中该项为 “一种” 的测试点，保证对于所有边有 $a = 1$。
- 强制在线：对于表格中该项为 “是” 的测试点，保证 $K = 1$；如果该项为 “否”，则有 $K = 0$。
- 对于所有测试点，如果上述对应项为 “不保证”，则对该项内容不作任何保证。

$n$|$m$|$Q=$|测试点|形态|海拔|强制在线
-|-|-|-|-|-|-
$\leq 1$|$\leq 0$|$0$|1|不保证|一种|否
$\leq 6$|$\leq 10$|$10$|2|不保证|一种|否
$\leq 50$|$\leq 150$|$100$|3|不保证|一种|否
$\leq 100$|$\leq 300$|$200$|4|不保证|一种|否
$\leq 1500$|$\leq 4000$|$2000$|5|不保证|一种|否
$\leq 200000$|$\leq 400000$|$100000$|6|不保证|一种|否
$\leq 1500$|$=n-1$|$2000$|7|一条链|不保证|否
$\leq 1500$|$=n-1$|$2000$|8|一条链|不保证|否
$\leq 1500$|$=n-1$|$2000$|9|一条链|不保证|否
$\leq 200000$|$=n-1$|$100000$|10|一棵树|不保证|否
$\leq 200000$|$=n-1$|$100000$|11|一棵树|不保证|是
$\leq 200000$|$\leq 400000$|$100000$|12|不保证|不保证|否
$\leq 200000$|$\leq 400000$|$100000$|13|不保证|不保证|否
$\leq 200000$|$\leq 400000$|$100000$|14|不保证|不保证|否
$\leq 1500$|$\leq 4000$|$2000$|15|不保证|不保证|是
$\leq 1500$|$\leq 4000$|$2000$|16|不保证|不保证|是
$\leq 200000$|$\leq 400000$|$100000$|17|不保证|不保证|是
$\leq 200000$|$\leq 400000$|$100000$|18|不保证|不保证|是
$\leq 200000$|$\leq 400000$|$400000$|19|不保证|不保证|是
$\leq 200000$|$\leq 400000$|$400000$|20|不保证|不保证|是


## 样例 #1

### 输入

```
1
4 3
1 2 50 1
2 3 100 2
3 4 50 1
5 0 2
3 0
2 1
4 1
3 1
3 2```

### 输出

```
0
50
200
50
150```

## 样例 #2

### 输入

```
1
5 5
1 2 1 2
2 3 1 2
4 3 1 2
5 3 1 2
1 5 2 1
4 1 3
5 1
5 2
2 0
4 0```

### 输出

```
0
2
3
1```

# 题解

## 作者：ldxcaicai (赞：152)

新鲜出炉的noi2018试题。
下面讲讲这题的解法：
首先要学习一个叫做$kruskal$重构树的东东。

听名字就知道跟$kruskal$算法有关，没错，原来的$kruskal$算法就是用并查集实现的，但当我们使用$kruskal$重构树的时候，对于每次找出的不同的两个连通块的祖先，我们都新建一个点作为两个祖先的父亲，并将当前边的边权转化为新点的点权。然而，路径压缩的时候会让我们丢失这种辛辛苦苦创造的树的形状。。。因此我们需要在使用并查集维护连通性的同时使用二叉树来维护树的形状。这样维护出来的树就是$kruskal$重构树。

不难发现$kruskal$重构树有几条重要的性质：
1.树上除叶子结点以外的点都对应着原来生成树中的边，叶子结点就是原来生成树上的节点。
2.由于新点的创建顺序与原来生成树上边权的大小有关，可以发现，从每个点到根节点上除叶子结点外按顺序访问到的点的点权是单调的。
3.出于$kruskal$算法贪心的性质，两个点$u$和$v$的$lca$的点权就对应着它们最小生成树上的瓶颈。
4.实际上这棵树就是一个二叉堆

所以这道题如何用$krukal$重构树做呢？

如果我们以海拔为第一关键字对边进行从大到小的排序，然后修建$kruskal$重构树，这样就弄出了一颗以海拔为关键字的小根堆。然后对于每一棵子树，如果询问中的水位线是低于子树的根节点的，那么此时这棵子树中的所有叶子结点都是连通的。放到题中就是说这颗子树中任选一个点出发，到子树中的其它点都不需要花费。

然后我们假设对于当前询问，我们找到了一个子树的根节点$u$，满足$d[u]>p$且$d[fa[u]]<=p$且出发点$v$在子树中，这时从$v$出发可以直接抵达子树中的任意一个叶子结点。因此我们需要从众多叶子节点中选出一个距离$1$号点花费最小的。

然后再捋一捋思路。我们首先要求出每个点到$1$号点的最小花费，这个直接$dijstra$+最短路预处理。然后是要建出$kruskal$重构树，再然后维护以每个点作为根节点时子树中距离$1$号点的最小花费，这个建完树后一个简单的$dfs$搞定。最后是如何找到点$u$，这时我们要让一个重要的算法登场：倍增算法。直接加上点权$>p$的限制在树上倍增即可。

总时间复杂度$O$（$T*nlogn$）。

代码如下：

```
#include<bits/stdc++.h>
#define N 400005
#define M 800005
using namespace std;
inline int read(){
	int ans=0;
	char ch=getchar();
	while(!isdigit(ch))ch=getchar();
	while(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch^48),ch=getchar();
	return ans;
}
inline void write(int x){
	if(x>9)write(x/10);
	putchar(x%10+'0');
}
int n,m,T,q,k,s,vis[N],first[N<<1],head[N],cntx=0,d[N],dep[N],f[N][20],fa[N<<1],lastans=0,totx=0;
struct Node{int u,v,l,a;}e[M],p[N<<1];
struct edge{int v,next;}tr[M<<1];
struct node{int v,next,w;}t[M];
struct heap{int u,v;};
inline bool operator<(heap a,heap b){return a.v>b.v;}
inline void dijstra(int s=1){
	memset(vis,false,sizeof(vis));
	memset(d,0x3f,sizeof(d));
	priority_queue<heap>q;
	d[s]=0;
	q.push((heap){s,d[s]});
	while(!q.empty()){
		heap x=q.top();
		q.pop();
		if(vis[x.u])continue;
		vis[x.u]=true;
		for(int i=head[x.u];i;i=t[i].next){
			int v=t[i].v;
			if(vis[v])continue;
			if(d[v]>d[x.u]+t[i].w){
				d[v]=d[x.u]+t[i].w
				;
				q.push((heap){v,d[v]});
			}
		}
	}
	for(int i=1;i<=n;++i)p[i].l=d[i];
}
inline bool cmp(Node a,Node b){return a.a>b.a;}
inline int find(int x){return x==fa[x]?fa[x]:fa[x]=find(fa[x]);}
inline void add(int u,int v){
	tr[++cntx].v=v;
	tr[cntx].next=first[u];
	first[u]=cntx;
}
inline void addx(int u,int v,int w){
	t[++totx].v=v;
	t[totx].next=head[u];
	t[totx].w=w;
	head[u]=totx;
}
inline void dfs(int u,int pa){
	dep[u]=dep[pa]+1,f[u][0]=pa;
	for(int i=1;i<=19;++i)f[u][i]=f[f[u][i-1]][i-1];
	for(int i=first[u];i;i=tr[i].next){
		int v=tr[i].v;
		dfs(v,u);
		p[u].l=min(p[u].l,p[v].l);
	}
}
inline int query(int x,int y){
	for(int i=19;i>=0;--i)if(dep[x]-(1<<i)>0&&p[f[x][i]].a>y)x=f[x][i];
	return p[x].l;
}
inline void kruskal(){
	int tot=0,cnt=n;
	for(int i=1;i<=(n<<1);++i)fa[i]=i;
	sort(e+1,e+m+1,cmp);
	for(int i=1;i<=m;++i){
		int u=e[i].u,v=e[i].v;
		int fx=find(u),fy=find(v);
		if(fx!=fy){
			add(++cnt,fx);
			add(cnt,fy);
			fa[fx]=cnt;
			fa[fy]=cnt;
			p[cnt].a=e[i].a;
			++tot;
		}
		if(tot==n-1)break;
	}
	dfs(cnt,0);
	while(q--){
		int x=(k*lastans+read()-1)%n+1,y=(k*lastans+read())%(s+1);
		write(lastans=query(x,y));
		puts("");
	}
}
int main(){
	T=read();
	while(T--){
		lastans=0,n=read(),m=read();
		memset(e,0,sizeof(e)),cntx=0,totx=0;
		memset(first,0,sizeof(first));
		memset(head,0,sizeof(head));
		memset(f,0,sizeof(f));
		for(int i=1;i<=m;++i)e[i].u=read(),e[i].v=read(),e[i].l=read(),e[i].a=read(),addx(e[i].u,e[i].v,e[i].l),addx(e[i].v,e[i].u,e[i].l);
		for(int i=n+1;i<=(n<<1);++i)p[i].l=0x3f3f3f3f;
		dijstra();
		q=read(),k=read(),s=read();
		kruskal();
	}
	return 0;
}
```

---

## 作者：FlashHu (赞：53)

### 闲话

一个蒟蒻，在网络同步赛上进行了这样的表演——

T2组合计数不会，T3字符串数据结构不会，于是爆肝T1

一开始以为整个地图都有车，然后写了2h+的树套树，终于发现样例过不去

然后写可持久化并查集Debug到13:20过了前4个样例，然后第5个T飞了。

FST？

。。。。。。

FST！

完美收获50分暴力分。

原来是按秩合并那里咕咕了。

从50到100的蜕变，只需一行，你值的拥有。

## 思路

不会kruscal重构树

容易发现，假设我们确定了水位线，那么就确定了图中有哪些边是连通的。这时候的答案该如何确定呢？因为车可以在一个连通块里随便开，所以同一个连通块里的点的答案都是一样的，为连通块内离$1$最近的点到$1$的距离。

那当然要首先把单源最短路求出来。~~SPFA死了？被固定了？（参考生物必修3）~~，还好蒟蒻写的是dijkstra。

因为并查集只能合并，所以我们要按高度从大到小排序依次加边。如果是离线那好办了，把询问也按高度排个序，每在并查集里加一条边就可以完成若干个询问。

那强制在线？当然要把合并过程中的每个版本都存起来啦！用可持久化并查集（蒟蒻之前写过一篇[blog](https://www.cnblogs.com/flashhu/p/8419760.html)）

当然，高度要离散化，为了让每个询问通过二分找到对应版本。

复杂度$O(n\log m+(m+q)\log^2n)$，当然这里写的有点丑，在倒序合并的过程中可以在外面放并查集，祖先到并查集里跳，比在可持久化并查集里跳快多了，复杂度$O(n\log m+m\log n+q\log^2n)$。
```cpp
#include<cstdio>
#include<cstring>
#include<queue>
#include<algorithm>
#define UI unsigned int
#define RG register
#define I inline
#define R RG UI
#define G c=getchar()
using namespace std;
const int N=2e5+9,M=8e5+9,S=2e7;
struct NODE{
	UI u,d;
	I bool operator<(RG NODE x)const{return d>x.d;}
};//堆优化dijkstra的节点
struct EDGE{
	UI u,v,a;
	I bool operator<(RG EDGE x)const{return a<x.a;}
}e[M];//对边排序
priority_queue<NODE>q;
UI n,L,p,he[N],ne[M],to[M],l[M],a[M],b[M],d[N],rt[M],lc[S],rc[S],f[S],mn[S],dep[S];
bool vis[N];
I UI in(){
	RG char G;
	while(c<'-')G;
	R x=c&15;G;
	while(c>'-')x*=10,x+=c&15,G;
	return x;
}
void build(R&u,R l,R r){//建初始并查集
	u=++p;
	if(l==r){mn[u]=d[f[u]=l];return;}
	R m=(l+r)>>1;
	build(lc[u],l,m);
	build(rc[u],m+1,r);
}
UI ins(R*u,R v,R t){//插入
	R l=1,r=n,m;
	while(l!=r){
		*u=++p;m=(l+r)>>1;
		if(t<=m)r=m,rc[*u]=rc[v],u=lc+*u,v=lc[v];
		else  l=m+1,lc[*u]=lc[v],u=rc+*u,v=rc[v];
	}
	return *u=++p;
}
UI getf(R rt,R t){//跳祖先
	R u,l,r,m;
	while(1){
		u=rt;l=1;r=n;
		while(l!=r){
			m=(l+r)>>1;
			if(t<=m)r=m,u=lc[u];
			else  l=m+1,u=rc[u];
		}
		if(t==f[u])break;
		t=f[u];
	}
	return u;
}
int main(){
	freopen("return.in","r",stdin);
	freopen("return.out","w",stdout);
	R T=in(),m,i,j,u,v,w;
	while(T--){
		p=0;n=in();m=in();//时刻注意清空变量！
		for(i=1;i<=m;++i){
			u=in();v=in();
			ne[++p]=he[u];to[he[u]=p]=v;
			ne[++p]=he[v];to[he[v]=p]=u;
			l[p]=l[p-1]=in();
			e[i]=(EDGE){u,v,a[p]=a[p-1]=in()};
		}
		memset(d,-1,(n+1)<<2);//dijkstra开始
		p=d[1]=0;q.push((NODE){1,0});
		while(!q.empty()){
			RG NODE cur=q.top();q.pop();
			if(vis[u=cur.u])continue;
			vis[u]=1;
			for(i=he[u];i;i=ne[i])
				if(d[to[i]]>d[u]+l[i])
					q.push((NODE){to[i],d[to[i]]=d[u]+l[i]});
		}
		R q=in(),k=in(),s=in(),lans=0;
		sort(e+1,e+m+1);
		for(i=1;i<=m;++i)b[i]=e[i].a;
		b[m+1]=s+1;L=unique(b+1,b+m+2)-b-1;//离散化，注意加入s+1
		build(rt[L],1,n);
		for(i=L-1,j=m;i;--i){
			rt[i]=rt[i+1];
			for(;j&&e[j].a==b[i];--j){
				if((u=getf(rt[i],e[j].u))==(v=getf(rt[i],e[j].v)))continue;//可优化的地方
				if(dep[u]>dep[v])swap(u,v);//按秩合并
				f[ins(&rt[i],rt[i],f[u])]=f[v];
				w=ins(&rt[i],rt[i],f[v]);
				f[w]=f[v];mn[w]=min(mn[u],mn[v]);//因为按秩合并所以min必须要记
				dep[w]=dep[v]+(dep[u]==dep[v]);//50分就是因为这一行！
			}
		}
		while(q--){
			v=(in()+k*lans-1)%n+1;u=(in()+k*lans)%(s+1);
			printf("%u\n",lans=mn[getf(rt[upper_bound(b+1,b+L+1,u)-b],v)]);
		}//谨慎选择lower_bound和upper_bound
		memset(vis,0,n+1);
		memset(he,0,(n+1)<<2);
		memset(rt,0,(L+1)<<2);
		memset(lc,0,(p+1)<<2);
		memset(rc,0,(p+1)<<2);
		memset(f,0,(p+1)<<2);
		memset(mn,0,(p+1)<<2);
		memset(dep,0,(p+1)<<2);//该清空的都要清空
	}
	return 0;
}
```

---

## 作者：niiick (赞：46)

####update8.31

最近有小伙伴私信问我有没有Kruskal重构树的讲解，说实话网上确实特别少~~(其实这个算法也比较冷门)~~，所以蒟蒻自己简单总结了一下，希望对大家有所帮助
####[Kruskal重构树—学习笔记](https://blog.csdn.net/niiick/article/details/81952126)
*********************
蒟蒻打同步赛的时候写了个暴力只得了六十多，
比赛结束后冥思苦想终于想出了正解，
然而还是调了一天才调出来

咳咳，回到正题
，这题正解就是**Kruskal重构树**

从大体思路入手，
我们可以把从v到1的路径分成两部分，
一半全开车，一半全走路

也就是说要**枚举n个节点作为断点**(假设当前断点为u)，
这个断点是可行解与最优解当且仅当

**存在一条从v到u的路径可以全部开车**

**且从u到1全部走路的最短路是满足上一条件中最短的**

那么要怎么求出从v出发可以开车到的点呢，
显然从v出发开车可以到的点，
一定满足**路径上所有边海拔都高于水位**

这里已经很明显可以用**Kruskal重构树**求解了

我们把每条边**按海拔降序排序**，
重构树完成后，
对于每次询问，
找到树中**深度最小且海拔大于水位的节点**，
那么**他的子树的全部节点都可以由v开车到达**

这一点可以由**重构树是小根堆**的性质简单得证，
即每个节点子树内所有节点海拔都比该节点大

而求解这个**深度最小且海拔大于水位的节点**可以用树上倍增，两行解决

现在要求的最后一步就是这个子树内**所有节点到1号节点的步行最短路**，
因为是无向图，所以一开始预处理1节点到所有节点最短路就好，
然后dfs可以顺便求出某个节点子树内的最短路
*******************

```
//niiick
#include<iostream>
#include<cmath>
#include<algorithm>
#include<queue>
#include<cstring>
#include<cstdio>
using namespace std;
typedef long long lt;

lt read()
{
    lt f=1,x=0;
    char ss=getchar();
    while(ss<'0'||ss>'9'){if(ss=='-')f=-1;ss=getchar();}
    while(ss>='0'&&ss<='9'){x=x*10+ss-'0';ss=getchar();}
    return f*x;
}


const int maxn=800010;
int n,m,cnt;
lt Q,K,S;

struct node{int u, v;lt hi;}edge[maxn<<1];
bool cmp(node a,node b){return a.hi>b.hi;}

struct node2{int v,nxt;lt dis;}E[maxn<<1];
int head[maxn],tot;

lt d[maxn],vis[maxn],ff[maxn];
priority_queue< pair<lt,int> > q;

lt mi[maxn],val[maxn];
int gra[maxn][23];

void add(int u,int v,lt dis)
{
    E[++tot].nxt=head[u];
    E[tot].v=v; E[tot].dis=dis;
    head[u]=tot;
}

void dij()
{
    memset(vis,0,sizeof(vis));
    memset(d,111,sizeof(d)); d[1]=0;
    q.push(make_pair(0,1));

    while(!q.empty())
    {
        int u=q.top().second; q.pop();
        if(vis[u]) continue;

        vis[u]=1;
        for(int i=head[u];i;i=E[i].nxt)
        {
            int v=E[i].v;
            if(d[u]+E[i].dis<d[v])
            {
                d[v]=d[u]+E[i].dis;
                q.push(make_pair(-d[v],v));
            }
        }
    }
}

int find(int x)
{
    if(x==ff[x])return x;
    else return ff[x]=find(ff[x]);
}

void dfs(int u) 
{
    mi[u]=d[u];
    for(int i=head[u];i;i=E[i].nxt)
    {
        int v=E[i].v;
        gra[v][0]=u;
        dfs(v);
        mi[u]=min(mi[u],mi[v]);
    }
    //if(u<=n) 
}

void kruskal()
{
    memset(head,0,sizeof(head)); tot=1;
    sort(edge+1,edge+1+m,cmp);
    for(int i=1;i<=n;++i)ff[i]=i; 
    for(int i=1;i<=m;i++) 
    {
        int fu=find(edge[i].u), fv=find(edge[i].v);
        if(fu!=fv)
        {
            val[++cnt]=edge[i].hi;
            ff[fu]=ff[fv]=ff[cnt]=cnt;
            add(cnt,fu,0); add(cnt,fv,0);
        }
    }
    dfs(cnt);
}

void init()
{
    memset(head,0,sizeof(head)); tot=1;
    memset(gra,0,sizeof(gra)); 
    memset(mi,111,sizeof(mi));
}

int main() 
{
    int T=read();
    while(T--) 
    {
        init();
        n=read();m=read();cnt=n;
        
        for(int i=1;i<=m;i++)
        {
            int u=read(),v=read(),dis=read(),hi=read();
            add(u,v,dis); add(v,u,dis);
            edge[i].u=u; edge[i].v=v; edge[i].hi=hi;
        }
        dij();//预处理1到所有节点最短路
        kruskal();//重构树
        
        for(int i=1;(1<<i)<=cnt;i++)
        for(int u=1;u<=cnt;u++)
        gra[u][i]=gra[gra[u][i-1]][i-1];
                
        Q=read();K=read();S=read();
        lt last=0;
        while(Q--) 
        {
            int vi=read(),pi=read();
            vi=(vi+K*last-1)%n+1;
            pi=(pi+K*last)%(S+1);
            
            for(int j=22;j>=0;--j)//找到深度最小且海拔大于水位的节点
            if(gra[vi][j]&&val[gra[vi][j]]>pi) 
            vi=gra[vi][j];
            
            printf("%lld\n",last=mi[vi]);
        }
    }
    return 0;
}

```

---

## 作者：alecli (赞：37)

### 此题部分分很多，逐层次考虑部分分

## $30\%$

对于只有一种海拔的情况，要么所有边海拔高于当前水位线(汽车能经过所有边，输出 $0$ ) ，要么只能步行。跑一遍 $dijkstra$， 然后 $O(1)$ 特判一下，期望得分 $30$。

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
#include<algorithm>
const int M = 400040;
const int N = 200020;
using namespace std;
int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x * f;
}
struct node{
    int nxt, to, dis, h;
}edge[M << 1];
int head[N], num;
void build(int from, int to, int dis, int h){
    edge[++num].nxt = head[from];
    edge[num].h = h;
    edge[num].to = to;
    edge[num].dis = dis;
    head[from] = num;
}
int Q, K, S;
int n, m, s, H, T, lastans = 0;
int getv(int lastans, int v0){
    return (v0 + K * lastans - 1) % n + 1;
}
int geth(int lastans, int p0){
    return (p0 + K * lastans) % (S+1);
}
int dist[N], vis[N];
void dijkstra(){
    priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > q;
    memset(dist, 0x3f, sizeof(dist));
    memset(vis, 0, sizeof(vis));
    q.push( make_pair(0, 1) ); dist[1] = 0;
    while(!q.empty()){
        int u = q.top().second; q.pop();
        if(vis[u]) continue; vis[u] = 1;
        for(int i=head[u]; i; i=edge[i].nxt){
            int v = edge[i].to, d = edge[i].dis;
            if(dist[v] > dist[u] + d){
                dist[v] = dist[u] + d;
                q.push( make_pair(dist[v], v) );
            }
        }
    }
}
void clearx(){
    memset(head, 0, sizeof(head));
    num = 0;
}
int main(){
    T = read();
    while(T --){
        lastans = 0;
        clearx();
        n = read(); m = read();
        for(int i=1; i<=m; i++){
            int u, v, l, a;
            u = read(); v = read(); l = read(); a = read();
            build(u, v, l, a);
            build(v, u, l, a);
        }
        Q = read(); K = read(); S = read();
        dijkstra();
        while(Q --){
            int v0, p0; v0 = read(); p0 = read();
            s = getv(lastans, v0);
            H = geth(lastans, p0);
            if(H < edge[1].h){
                puts("0");
                lastans = 0;
                continue;
            }
            else{
                lastans = dist[s];
                cout<<dist[s]<<endl;
            }
        }
    }
    return 0;
}

```

## 另外 $ 25\% $

对于树和链的情况，由于各个点到家的路径唯一，只要找到当前路径上，此水位线能到达的并且离起点距离最小的点即可，$dijkstra$预处理，考虑倍增，期望得分 $25$。

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
#include<algorithm>
const int M = 400040;
const int N = 200020;
using namespace std;
int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x * f;
}


struct node{
    int nxt, to, dis, h;
}edge[M << 1];
int head[N], num;
void build(int from, int to, int dis, int h){
    edge[++num].nxt = head[from];
    edge[num].h = h;
    edge[num].to = to;
    edge[num].dis = dis;
    head[from] = num;
}
int dist[N], vis[N];
void dijkstra(){
    priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > q;
    memset(dist, 0x3f, sizeof(dist));
    memset(vis, 0, sizeof(vis));
    q.push( make_pair(0, 1) ); dist[1] = 0;
    while(!q.empty()){
        int u = q.top().second; q.pop();
        if(vis[u]) continue; vis[u] = 1;
        for(int i=head[u]; i; i=edge[i].nxt){
            int v = edge[i].to, d = edge[i].dis;
            if(dist[v] > dist[u] + d){
                dist[v] = dist[u] + d;
                q.push( make_pair(dist[v], v) );
            }
        }
    }
}


int n, m, S, K, T, Q, lastans;
int fa[N][21], H[N][21];
void dfs(int u, int f){
    for(int i=head[u]; i; i=edge[i].nxt){
        int v = edge[i].to, h = edge[i].h;
        if(v == f) continue;
        fa[v][0] = u;
        H[v][0] = h;
        dfs(v, u);
    }
}
void init(){
    dfs(1, 0);
    for(int i=1; i<=20; i++)
        for(int j=1; j<=n; j++){
            fa[j][i] = fa[fa[j][i-1]][i-1];
            H[j][i] = min(H[fa[j][i-1]][i-1], H[j][i-1]);
        }
}


int getv(int lastans, int v0){
    return (v0 + K * lastans - 1) % n + 1;
}
int geth(int lastans, int p0){
    return (p0 + K * lastans) % (S+1);
}
int work(int x, int now){
    if(now == 0) return 1;
    for(int i=20; i>=0; i--){
        if(H[x][i] > now) x = fa[x][i];
    }
    return x;
}
void clearx(){
    memset(head, 0, sizeof(head));
    memset(H, 0, sizeof(H));
    memset(fa, 0, sizeof(fa));
    num = 0;
}
int main(){
    T = read();
    while(T --){
        lastans = 0;
        clearx();
        n = read(); m = read();
        for(int i=1; i<=m; i++){
            int u, v, l, a;
            u = read(); v = read(); l = read(); a = read();
            build(u, v, l, a);
            build(v, u, l, a);
        }
        Q = read(); K = read(); S = read();
        dijkstra(); init();
        for(int i=1; i<=Q; i++){
            int v0, p0; v0 = read(); p0 = read();
            int v = getv(lastans, v0), h = geth(lastans, p0);
            lastans = dist[work(v, h)];
            cout<<lastans<<endl;
        }
    }
    return 0;
}

```

## 离线？
## $65\%$


可以想到将询问按照某个值排序，单调地处理每个询问。

$dijkstra$预处理最短路，将询问按水位从大到小排序，将所有边按照海拔从大到小排序，依次处理每个询问，如果边的海拔高于当前水位线，加入该边，由于水位线是单调下降的，所以加完边后该边永久有效，考虑用并查集维护，期望得分 $65$。

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
#include<algorithm>
const int M = 400040;
const int N = 200020;
using namespace std;
int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x * f;
}


struct node{
    int nxt, from, to, dis, h;
}edge[M << 1], tmp[M << 1];
int head[N], num;
void build(int from, int to, int dis, int h){
    edge[++num].nxt = head[from];
    edge[num].h = h;
    edge[num].from = from;
    edge[num].to = to;
    edge[num].dis = dis;
    head[from] = num;
}
bool cmp(node a, node b){
    return a.h > b.h;
}


int n, m, S, K, T, Q, lastans;
struct node2{
    int u, h, ans, id;
}Que[M];
bool cmp2(node2 a, node2 b){
    return a.h > b.h;
}
bool cmp3(node2 a, node2 b){
    return a.id < b.id;
}
int getv(int lastans, int v0){
    return (v0 + K * lastans - 1) % n + 1;
}
int geth(int lastans, int p0){
    return (p0 + K * lastans) % (S+1);
}


int dist[N], vis[N];
void dijkstra(){
    priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > q;
    memset(dist, 0x3f, sizeof(dist));
    memset(vis, 0, sizeof(vis));
    q.push( make_pair(0, 1) ); dist[1] = 0;
    while(!q.empty()){
        int u = q.top().second; q.pop();
        if(vis[u]) continue; vis[u] = 1;
        for(int i=head[u]; i; i=edge[i].nxt){
            int v = edge[i].to, d = edge[i].dis;
            if(dist[v] > dist[u] + d){
                dist[v] = dist[u] + d;
                q.push( make_pair(dist[v], v) );
            }
        }
    }
}
void clearx(){
    memset(head, 0, sizeof(head));
    memset(Que, 0, sizeof(Que));
    num = 0;
}


int fa[N];
int findx(int x){
    if(fa[x] == x) return x;
    return fa[x] = findx(fa[x]);
}
void mergex(int x, int y){
    int fx = findx(x), fy = findx(y);
    if(fx == fy) return;
    if(dist[fx] > dist[fy]) fa[fx] = fy;
    else fa[fy] = fx;
}


int main(){
    T = read();
    while(T --){
        lastans = 0;
        clearx();
        n = read(); m = read();
        for(int i=1; i<=n; i++) fa[i] = i;
        for(int i=1; i<=m; i++){
            int u, v, l, a;
            u = read(); v = read(); l = read(); a = read();
            tmp[i].from = u; tmp[i].to = v; tmp[i].h = a; tmp[i].dis = l;
            build(u, v, l, a);
            build(v, u, l, a);
        }
        sort(tmp+1, tmp+m+1, cmp);
        Q = read(); K = read(); S = read();
        dijkstra();
        for(int i=1; i<=Q; i++){
            int v0, p0; v0 = read(); p0 = read();
            Que[i].u = v0;
            Que[i].h = p0;
            Que[i].id = i;
        }
        sort(Que+1, Que+Q+1, cmp2);
        int now = 1;
        for(int i=1; i<=Q; i++){
            while(now<=m && tmp[now].h > Que[i].h){
                mergex(tmp[now].from, tmp[now].to); now ++;
            }
            Que[i].ans = dist[findx(Que[i].u)];
        }
        sort(Que+1, Que+Q+1, cmp3);
        for(int i=1; i<=Q; i++){
            cout<<Que[i].ans<<endl;
        }
    }
    return 0;
}

```


## 数据分治
## $70\% $ ~ $ 80\% $

对后几个小范围的点数据分治结合前面的离线算法可以拿$70$ ~ $80 pts$，十分优秀

## $kruskal$重构树 / 可持久化并查集
## $100\%$

根据离线算法，可以想到用可持久化并查集实现在线，然而正解好像是 $kruskal$重构树，(在做这题之前我还没听说过qwq)，(先将边权排序)，$kruskal$重构树其实就是将边转换为一个节点，边权转换为该节点点权，将此节点作为两点的父节点，连边；可以知道，$kruskal$重构树为一棵二叉树，根节点为最后加入的边，两点之间的最小/最大权值为两点 $lca$ 的权值。

对于该题，可以将边按照海拔从大到小排序，然后建树，这样，建的树就是一个小根堆，某节点的权值为它子树海拔的最小值。查询时，只要找到权值大于当前水位线的节点，那么它所有子树中的节点开车都可以到达，预处理子树中所有节点离家距离的最小值即可，(根据树的部分分),我们可以想到用倍增法找子树根节点。

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
#include<algorithm>
const int M = 800080;
const int N = 400040;
using namespace std;
typedef long long ll;
ll read(){
    ll x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x * f;
}


ll n, m, S, K, T, Q, lastans, cnt;
struct node{
    int nxt, from, to;
    ll dis, h;
}edge[M << 1], E[M << 1];
int head[N << 1], num;
void build(int from, int to, ll dis, ll h){
    edge[++num].nxt = head[from];
    edge[num].h = h;
    edge[num].to = to;
    edge[num].dis = dis;
    head[from] = num;
}
bool cmp(node a, node b){
    return a.h > b.h;
}


ll dist[N << 1];
int vis[N << 1];
void dijkstra(){
    priority_queue<pair<ll, int>, vector<pair<ll, int> >, greater<pair<ll, int> > > q;
    memset(dist, 111, sizeof(dist));
    memset(vis, 0, sizeof(vis));
    q.push( make_pair(0, 1) ); dist[1] = 0;
    while(!q.empty()){
        int u = q.top().second; q.pop();
        if(vis[u]) continue; vis[u] = 1;
        for(int i=head[u]; i; i=edge[i].nxt){
            ll v = edge[i].to; ll d = edge[i].dis;
            if(dist[v] > dist[u] + d){
                dist[v] = dist[u] + d;
                q.push( make_pair(dist[v], v) );
            }
        }
    }
}


ll fa[N << 1];
ll findx(ll x){
    if(fa[x] == x) return x;
    return fa[x] = findx(fa[x]);
}


ll ch[N<<1][2], f[N<<1][21], d[N<<1], val[N<<1];
ll MIN[N<<1];
void dfs(int u) {
    MIN[u] = dist[u];
    for(int i=head[u]; i; i=edge[i].nxt){
        int v = edge[i].to;
        f[v][0]=u;
        dfs(v);
        MIN[u] = min(MIN[u], MIN[v]);
    }
}
void kruskal(){
    memset(head, 0, sizeof(head)); num = 0;
    sort(E+1, E+m+1, cmp);
    for(int i=1; i<=m; i++){
        int u = E[i].from, v = E[i].to;
        int fu = findx(u), fv = findx(v);
        if(fu == fv) continue;
        cnt ++;
        fa[fu] = fa[fv] = fa[cnt] = cnt;
        build(cnt, fu, 0, 0); build(cnt, fv, 0, 0);
        val[cnt] = E[i].h;
    }
    d[cnt] = 1;
    dfs(cnt);
    for(int j=1; (1<<j)<=cnt; j++)
        for(int i=1; i<=(n<<1); i++)
            f[i][j] = f[f[i][j-1]][j-1];
}


void clearx(){
    memset(head, 0, sizeof(head));
    memset(f, 0, sizeof(f));
    memset(MIN, 111, sizeof(MIN));
    num = 0;
}
ll getv(ll lastans, int v0){
    return (v0 + K * lastans - 1) % n + 1;
}
ll geth(ll lastans, int p0){
    return (p0 + K * lastans) % (S+1);
}


int main(){
    T = read();
    while(T --){
        lastans = 0;
        clearx();
        n = read(); m = read(); cnt = n;
        for(int i=1; i<=n; i++) fa[i] = i;
        for(int i=1; i<=m; i++){
            ll u, v, l, a;
            u = read(); v = read(); l = read(); a = read();
            E[i].from = u; E[i].to = v; E[i].h = a;
            build(u, v, l, a);
            build(v, u, l, a);
        }
        Q = read(); K = read(); S = read();
        dijkstra();
        kruskal();
        while(Q --){
            ll v0, p0; v0 = read(); p0 = read();
            ll v = (v0 + K * lastans - 1) % n + 1;
            ll p = (p0 + K * lastans) % (S+1);
            for(int i=20; i>=0; i--)
                if(f[v][i] && val[f[v][i]] > p)
                    v = f[v][i];
            lastans = MIN[v];
            printf("%lld\n", lastans);
        }
    }
    return 0;
}

```


---

## 作者：Siyuan (赞：20)

[$$\Large\texttt{My Blog}$$](https://hydingsy.github.io/)

---

> 题目链接：[Luogu 4768](https://www.luogu.org/problemnew/show/P4768)

魔力之都可以抽象成一个 $n$ 个节点、$m$ 条边的**无向连通图**。我们依次用 $l,a$ 描述一条边的**长度**、**海拔**。

作为季风气候的代表城市，魔力之都时常有雨水相伴，因此道路积水总是不可避免的。由于整个城市的排水系统连通，因此**有积水的边一定是海拔相对最低的一些边**。

我们用**水位线**来描述降雨的程度，它的意义是：所有海拔**不超过**水位线的边都是**有积水**的。

Yazid 是一名来自魔力之都的 OIer，刚参加完 ION2018 的他将踏上归程，回到他温暖的家。

Yazid 的家恰好在魔力之都的 $1$ 号节点。对于接下来 $Q$ 天，每一天 Yazid 都会告诉你他的出发点 $v$ ，以及当天的水位线 $p$。

每一天，Yazid 在出发点都拥有一辆**车**。这辆车由于一些故障不能经过有积水的边。Yazid 可以在任意节点下车，这样接下来他就可以步行经过有积水的边。但车会被留在他下车的节点并不会再被使用。

需要特殊说明的是，第二天车会被重置，这意味着：

- 车会在新的出发点被准备好。
- Yazid 不能利用之前在某处停放的车。

Yazid 非常讨厌在雨天步行，因此他希望在完成回家这一目标的同时，最小化他**步行经过的**边的总长度。请你帮助 Yazid 进行计算。

注意：本题有多组数据，并且**强制在线**！

数据范围：$T\le 3$，$n\le 2\times 10^5$，$m,Q\le 4\times 10^5$，$l\le 10^4$，$a\le 10^9$

------

## Solution

我们先分析一下询问的本质：将 $1$ 到 $v$ 的路径分成两个部分，一段全部开始，后一段全部走路。那我们可以枚举一个**断点** $u$，在满足 $u$ 到 $v$ 的路径上所有的边的海拔都大于 $p$ 的情况下，要求 $1$ 到 $u$ 的最短路最短。

我们怎么求出从 $v$ 出发可以到达的点呢？这些点显然满足从 $v$ 出发，路径上所有边的海拔都大于 $p$。由此可以想到，这些路径一定在原图的**最大生成树**上！

至此，已经可以发现能用 $\texttt{Kruskal}$ 重构树求解了。关于 $\texttt{Kruskal}$ 重构树的求法，请见[「算法笔记」Kruskal 重构树](https://hydingsy.github.io/articles/algorithm-Extended-Kruskal/)。

我们把每条边**按照海拔降序排列**，求出关于海拔的最大生成树。由于这样的重构树是一个**小根堆**（每个节点子树内的所有节点的点权都不小于该节点），对于每次询问求出包含 $v$ 的子树中根节点深度最小并且海拔（点权）大于 $p$ 的子树 $x$，那么 $x$ 子树内的所有节点都可以由 $v$ 开车到达！

求解深度最小的满足条件的节点，可以直接用树上倍增解决，这个倍增数组可以在 $\texttt{Kruskal}$ 的过程中求出来。

现在，这棵子树内的所有点都可以作为上文所说的断点，我们只需要求出子树内的点到点 $1$ 的最短距离的最小值。我们可以预处理每个点到 $1$ 的最短距离，然后对于每棵子树求个 $\min$ 即可。由于重构树的求解过程中我们可以知道这棵树的形态，所以这个取 $\min$ 的过程不需要 $\texttt{DFS}$，而是可以直接在 $\texttt{Kruskal}$ 中完成！

**时间复杂度**：$O(T\cdot n\log n)$（此处认为 $n,m,Q$ 三者同阶）

------

## Code

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>
typedef std::pair<int,int> pii;
#define mk std::make_pair
inline char nc() {
    static char buf[1000000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++;
}
template <class Tp> inline void read(register Tp &s) {
    s=0;char c=nc();for(;c<'0'||c>'9';c=nc());for(;c>='0'&&c<='9';s=s*10+(c^48),c=nc());
}

const int N=4e5+5,M=8e5+5,logN=19+1;
int n,m,tot,lnk[N],ter[M],nxt[M],val[M],fa[N],f[N][logN],dis[N],hei[N];
bool vis[N];
struct Edge {
    int u,v,h;
    bool operator < (const Edge &rhs) const {
        return h>rhs.h;
    }
}e[M];

void add(int u,int v,int w) {
    ter[++tot]=v,nxt[tot]=lnk[u],val[tot]=w,lnk[u]=tot;
}
void input() {
    tot=0,memset(lnk,0,sizeof(lnk));
    read(n),read(m);
    for(int i=1;i<=m;++i) {
        int u,v,w,h;
        read(u),read(v),read(w),read(h);
        add(u,v,w),add(v,u,w);
        e[i].u=u,e[i].v=v,e[i].h=h;
    }
}
void dijkstra(int s) {
    memset(dis,0x7f,sizeof(dis));
    memset(vis,0,sizeof(vis));
    std::priority_queue<pii,std::vector<pii>,std::greater<pii> > q;
    q.push(mk(dis[s]=0,s));
    while(!q.empty()) {
        int u=q.top().second; q.pop();
        if(vis[u]) continue;
        vis[u]=1;
        for(int i=lnk[u];i;i=nxt[i]) {
            int v=ter[i];
            if(dis[v]>dis[u]+val[i]) {
                dis[v]=dis[u]+val[i];
                if(!vis[v]) q.push(mk(dis[v],v));
            }
        }
    }
}
int find(int x) {
    return fa[x]==x?x:fa[x]=find(fa[x]);
}
void exKruskal() {
    std::sort(e+1,e+m+1);
    for(int i=1;i<=n+n;++i) fa[i]=i;
    int idx=n;
    for(int i=1;i<=m;++i) {
        int fu=find(e[i].u),fv=find(e[i].v);
        if(fu==fv) continue;
        fa[fu]=fa[fv]=++idx,hei[idx]=e[i].h;
        dis[idx]=std::min(dis[fu],dis[fv]);
        f[fu][0]=f[fv][0]=idx;
    }
    for(int j=1;(1<<j)<=idx;++j) for(int i=1;i<=idx;++i) f[i][j]=f[f[i][j-1]][j-1];
}
int query(int u,int p) {
    for(int i=19;~i;--i) if(f[u][i]&&hei[f[u][i]]>p) u=f[u][i];
    return dis[u];
}
void solve() {
    int q,k,s;
    read(q),read(k),read(s);
    int lastans=0;
    while(q--) {
        int v,p;
        read(v),read(p);
        v=(v+k*lastans-1)%n+1;
        p=(p+1LL*k*lastans)%(s+1);
        printf("%d\n",lastans=query(v,p));
    }
}
int main() {
    int T;
    for(scanf("%d",&T);T--;) {
        input();
        dijkstra(1);
        exKruskal();
        solve();
    }
    return 0;
}
```



---

## 作者：teafrogsf (赞：18)

写一下这位dalao@栓犬 告诉我的做法。$Orz$  
$Dijkstra$之后~~（出题人：$Spfa$死了）~~，有一个很显然的离线想法是，询问与边都按从大到小排序，然后每次询问倒序进去的时候按比海拔高的约束加入能开车的边，这个东西可以用并查集维护。每次维护这个点子树的最小距离，直接输出就好了。复杂度$O(n\log m+m\log n+q\log n)$。~~然后就有许多同学直接用可持久化并查集直接$O(n\log m+m\log n+q\log ^2n)$暴力艹过去了~~  
但实际上这题是可以写到$1$个$\log$的，除了$Kruskal$重构树之外，还可以用$vector$+二分的做法。  
我们可以发现，边排序后，答案随着高度变低、并查集合并而逐渐减少，即对于每个点，答案都具有单调递减性。  
我们可以开一个$vector$记录每个点在以高度为版本（高度越高，版本越老）的答案，于是并查集合并时直接把小的答案加入父亲的$vector$里。在询问时，找到最近的版本比它老的答案最小的版本，也就是最靠近它且高度比它大的版本。  
注意每个点先加入一个版本为$inf$，答案为$dis_i$的答案。  
用启发式合并保证复杂度，总时间复杂度为$O(n\log m+m\log n+q\log n)$。  
~~还有没有人和我一样考场上没清空$lastans$拿了$65/70pts$的选手啊qwq~~
```cpp
#include<cstdio>
#include<cstring>
#include<queue>
#include<ext/pb_ds/assoc_container.hpp>
#define neko 1000010
#define meko 1000010
#define qeko 1000010
#define fi first
#define se second
#define chkmin(a,b) ((a)<(b)?(a):(b))
#define chkmax(a,b) ((a)>(b)?(a):(b))
#define f(i,a,b) for(register int i=(a);i<=(b);i=-(~(i)))
using namespace std;
typedef long long ll;
typedef pair<ll,int> pi;
struct qwq
{ll ver,ans;};
vector<qwq>vec[neko];
struct node
{int u,v,h,nex;ll w;}e[meko<<1],E[meko];
int t,Et,tp,n,m,Q,K,maxA;
typedef int arr[neko];
arr head,fa,verfa,book,dep;
ll mindis[neko],dis[neko],ans[neko],inf=2e9+1e8,lastans;
template<typename T>
void read(T &x)
{
	char c=getchar();x=0;
	while(!isdigit(c))c=getchar();
	while(isdigit(c))x=(x<<1)+(x<<3)+(c^'0'),c=getchar();
}
namespace Path
{
	void add(int x,int y,ll z,int o)
	{
		e[++t].u=E[++Et].u=x;
		e[t].v=E[Et].v=y;
		e[t].w=E[Et].w=z;
		e[t].h=E[Et].h=o;
		e[t].nex=head[x];
		head[x]=t;
		e[++t].u=y;
		e[t].v=x;
		e[t].w=z;
		e[t].h=o;
		e[t].nex=head[y];
		head[y]=t;
	}
	void dijkstra()
	{
		priority_queue<pi,vector<pi>,greater<pi> >q;
		memset(dis,0x3f,sizeof(dis));
		dis[1]=0,q.push(pi(0,1));
		int u;pi x;
		while(!q.empty())
		{
			x=q.top(),q.pop();
			u=x.se;
			if(!book[u])
			{
				book[u]=1;
				for(register int i=head[u],v=e[i].v;i;i=e[i].nex,v=e[i].v)
				{
					if(dis[v]>=x.fi+e[i].w)
					{
						dis[v]=x.fi+e[i].w;
						q.push(pi(dis[v],v));
					}
				}
			}
		}
	}
}
namespace Uset
{
	int find(int x)
	{
		while(fa[x])x=fa[x];
		return x;
	}
	void insert(int x,ll nowans,ll ver)
	{
		int len=vec[x].size()-1;
		if(nowans<vec[x][len].ans)vec[x].push_back((qwq){ver,nowans});
		//printf("xx %lld %lld\n",ver,nowans);
	}
	void merge(int u,int v,ll w)
	{
		int x=find(u),y=find(v);	
		if(x^y)
		{
			if(dep[x]>dep[y])std::swap(x,y);
			fa[x]=y,verfa[x]=w;
			dep[y]=chkmax(dep[x]+1,dep[y]);
			insert(y,vec[x][vec[x].size()-1].ans,w);
		}
	}
	ll solve(int x,int ver)
	{
		while(fa[x]&&verfa[x]>ver)x=fa[x];
		ll now=2e9+1e8;
		int l=0,r=vec[x].size()-1;
		while(l<=r)
		{
			int mid=(l+r)>>1;
			if(vec[x][mid].ver>ver)now=chkmin(now,vec[x][mid].ans),l=mid+1;
			else r=mid-1;
		}return lastans=now;
	}
	void init()
	{memset(dep,0,sizeof(dep)),memset(fa,0,sizeof(fa));}
}
void Init()
{
	memset(book,0,sizeof(book));
	memset(head,0,sizeof(head));
	t=Et=lastans=0;
}
bool cmp2(node a,node b)
{return a.h>b.h;}
int main()
{
	using namespace Path;
	using namespace Uset;
	int x,y,o,cas;ll z;
	read(cas);
	while(cas--)
	{
		Init();
		read(n),read(m);
		f(i,1,m)
		{
			read(x),read(y),read(z),read(o);
			add(x,y,z,o);
		}dijkstra(),init();
		f(i,1,n)vec[i].clear(),vec[i].push_back((qwq){inf,dis[i]});
		sort(E+1,E+Et+1,cmp2);
		f(i,1,m)merge(E[i].u,E[i].v,E[i].h);
		read(Q),read(K),read(maxA);
		f(i,1,Q)
		{
			read(x),read(y);
			x=(x+K*lastans-1)%n+1,y=(y+K*lastans)%(maxA+1);
			printf("%lld\n",solve(x,y));
		}
		//cerr<<clock()<<endl;
	}
}

```

---

## 作者：kikuss (赞：10)

# Solution
那么大概复述一下题目大意

n个点,m条边,保证图联通,每条边有两个权值,一个**长度**,一个**海拔**,多组询问,告诉你起点和水位线,**小于等于**水位线的边都会被淹没,只能走路,否则可以开车,问从当天起点到1号节点最少**步行经过的长度**,有些询问会强制在线

这道题是今年NOI的D1T1,当时在线打的时候,只打了个SPFA48分(直接跑),倍增优化60分

- - -

**正解:Kruskal重构树/可持久化并查集**

由于博主蒟蒻不会可持久化数据结构,所以讲Kruskal重构树

首先复习一下Kruskal最小生成树,是以并查集为辅助实现的,并通过路径压缩保证了时间复杂度,显然这样同时也会破坏树的原本的结构,但由于最小生成树不用保存这些信息,所以没什么影响,但Kruskal重构树就不同了....

Kruskal重构树的经典例题:给你一张图,每次询问两点之间所有简单路径中最大边权的最小值

常规做法,建出一棵最小生成树,答案就是树上的边权最小值

- - -

那么Kruskal重构树怎么做呢?
和kruskal类似,依然需要将边排序.
不同的是,我们建一个虚点,让两个联通快(查询的两个点的祖先)分别与虚点相连,这个虚点带有点权,点权就是本应相连的两个点之间的边权

这样的树有两个优雅的性质
>1. 这是一颗二叉树，并且相当于一个堆，因为边是有顺序合并的.
>2.  最小生成树上路径的边权信息转化成了点权信息.

那么刚才那道经典例题就变成了询问两点lca的权值

那么回看这道题,应该比较好理解了,因为要求边的海拔要**大于**水位线,所以把海拔**从大到小**排序,为什么是从大到小,因为这样海拔高的先合并,也就是树根的点权就是最小的边权,如果一个点的点权大于水位线,那么以它为根的子树也会大于水位线,那么我们就可以在它的子树中找到步行距离最小是多少
所以每次跳lca直到点权大于水位线

- - - 

再复述一遍思路
1. 首先一遍dijkstra预处理出所有点到1的最短步行距离
2. 建出Kruskal重构树
3. dfs一遍$O(n)$处理处以Kruskal重构树的根为根的子树中到1点的最短步行距离
4. lca预处理
5. 求两点lca在线回答询问

**提示1:因为我们已经建了虚点来连向两个联通快,所以路径压缩并不会破坏Kruskal重构树的结构,只会影响原树的结构**


**提示2:关于边和点的数组大小,每建一个虚点要建4条边,因为原图有M条边,所以建M个虚点,那么就要开$M*4$的数组,至于点,每两条边一个虚点,就是M/2个点加上原来有N个点**


欢迎踩博客[real_l](https://www.cnblogs.com/real-l/p/9568354.html)
# Code
```cpp

#include<bits/stdc++.h>
#define Min(a,b) (a)<(b)?(a):(b)
#define Max(a,b) (a)>(b)?(a):(b)
using namespace std;
typedef long long lol;
const int N=200010,M=400010;

void in(int &ans)
{
    ans=0;int f=1;char i=getchar();
    while(i<'0' || i>'9') {if(i=='-') f=-1;i=getchar();}
    while(i>='0' && i<='9') ans=(ans<<1)+(ans<<3)+(i^48),i=getchar();
    ans*=f;
}

int T,n,m,Q,k,s,cnt,tq;
lol to[M<<2],nex[M<<2],w[M<<2],h[M<<2],head[N<<1];
lol fa[N<<1],dp[N<<1],dis[N<<1],vis[N],f[20][N<<1],v[N<<1];

struct node {
    lol x,y,v,h;
}A[M];

struct Node{
    lol id,v;
    bool operator < (const Node &a) const {return v>a.v;}
};

inline void add(lol a,lol b,lol c,lol d)
{
    to[++cnt]=b,nex[cnt]=head[a];
    w[cnt]=c,h[cnt]=d,head[a]=cnt;
}

int find(int x) {
    if(x!=fa[x]) fa[x]=find(fa[x]);
    return fa[x];
}

bool cmp(node a,node b) {return a.h>b.h;}

void dijkstra()
{
    memset(dis,0x3f,sizeof(dis));
    memset(vis,0,sizeof(vis));
    priority_queue<Node>q;
    Node tmp; tmp = (Node) {1,0};
    q.push(tmp); dis[1]=0;
    while(!q.empty()) {
        lol u=q.top().id; q.pop();
        if(vis[u]) continue; vis[u]=1;
        for(lol i=head[u];i;i=nex[i]) {
            if(dis[to[i]]>dis[u]+w[i]) {
                dis[to[i]]=dis[u]+w[i];
                tmp=(Node){to[i],dis[to[i]]};
                q.push(tmp);
            }
        }
    }
}

void init()
{
    for(lol i=1;i<=19;i++)
        for(lol j=1;j<=tq;j++)
            f[i][j]=f[i-1][f[i-1][j]];
}

void dfs(int u,int father)
{
    dp[u]=dis[u];
    for(lol i=head[u];i;i=nex[i]) {
        if(to[i]!=father) {
            f[0][to[i]]=u;
            dfs(to[i],u);
            dp[u]=Min(dp[u],dp[to[i]]);
        }
    }
}

lol lca(lol x,lol y) {
    for(lol i=19;i>=0;i--)
        if(v[f[i][x]]>y) x=f[i][x];
    return x;
}

int main()
{
    //freopen("return.in","r",stdin);
    //freopen("return.out","w",stdout);
    lol last; in(T);
    while(T--) {
        memset(head,0,sizeof(head));
	
        in(n), in(m), tq=n, last=cnt=0;
	
        for(int i=1;i<=m;i++) {
            int a, b, c, d;
            in(a), in(b), in(c), in(d);
            add(a,b,c,d), add(b,a,c,d);
            A[i] = (node) {a,b,c,d};
        }
	
        dijkstra();
	
        cnt=0; memset(head,0,sizeof(head));
	
        for(int i=1;i<=n;i++) fa[i]=i;
	
        sort(A+1, A+1+m, cmp);
	
        for(int i=1;i<=m;i++) {
            int fx = find(A[i].x),fy = find(A[i].y);
            if(fx == fy) continue;
            fa[fx] = ++tq, fa[fy] = tq, fa[tq] = tq, v[tq] = A[i].h;
            add(tq,fx,0,0), add(fx,tq,0,0);
            add(tq,fy,0,0), add(fy,tq,0,0);
        }
	
        dfs(tq,0); init();
        in(Q), in(k), in(s);
        /*for(int i=1;i<=tq;i++) cout<<dp[i]<<" ";
          cout<<endl;*/
	
        for(int i=1;i<=Q;i++) {
            int v,p; in(v), in(p);
            v=(v+k*last-1)%n+1, p=(p+k*last)%(s+1);
            printf("%lld\n",last=dp[lca(v,p)]);
        }
    }
    return 0;
}
```

---

## 作者：双管荧光灯 (赞：10)

第一眼看出来是最短路

所以先用dijkstra算法求出1到各点的最短路，如果是暴力做，那么只要从搜索与v连通的(也就是不经过有积水的边便能到达的)点中距离的最小值，时间O(n^2)，期望得50分

考虑如何优化，如果不是在线做，可以将水位线排序，用并查集维护(因为只会有加边操作),可得65分

那么在线做是一样的，先将边的海拔降序排序，然后一个一个加到并查集中，用可持久化并查集就能做了，但这还是很麻烦(我也不会写……)

考虑建一棵树，用正常的并查集维护它，它表示最优时车的行驶路径(不一定按照图中的边来建),它的父亲j到结点i的边表示图中i到j经过边的海拔的最小值最大是多少，其中1到j的距离大于1到i的距离，且根到任意一点上的边权是递增的

这样的树有什么用呢？显然要的到更优值，要尽可能地往根走，这样就能用倍增算法，具体不难实现

这棵树怎么维护呢？用并查集，并查集的根到1的距离在它所在集合中最小。将边按海拔排序，依次插入，当两个并查集合并时，把根结点距离小的向根节点距离大的连一条边。也就是说，这棵树就是并查集不路径压缩时的形态，由于边是降序的，这条树边边权就是当前边的海拔高度，树就建好了！

时间复杂度O(nlogn)



```cpp
#include<stdio.h>
#include<algorithm>
#include<queue>
#include<string.h>
#include<iostream>
using namespace std;
int d[200005],i,j,head[200005],Next[800005],adj[800005],t,k,lea[800005],ans,n,m,u,v,h,l,vis[200005],f[200005],fa[25][200005],fac[25][200005],qq,s,p;
void Push(int u,int v,int l)
{
	Next[++k]=head[u];
	head[u]=k;
	adj[k]=v;
	lea[k]=l;
}
struct str{
	int s,x;
};
struct edge{
	int u,v,h;
}e[400005];
bool operator <(str a,str b)
{
	return a.s>b.s;
}
priority_queue<str> q;
void Dijkstra()
{
	int j;
	q.push((str){0,1});
	memset(vis,0,sizeof(vis));
	memset(d,0x7f,sizeof(d));
	d[1]=0;
	while(!q.empty())
	{
		str t=q.top();
		q.pop();
		if(vis[t.x]==1)
			continue;
		vis[t.x]=0;
		for(j=head[t.x];j!=0;j=Next[j])
			if(d[adj[j]]>d[t.x]+lea[j])
			{
				d[adj[j]]=d[t.x]+lea[j];
				q.push((str){d[adj[j]],adj[j]});
			}
	}
}
bool cmp(edge a,edge b)
{
	return a.h>b.h;
}
int Find(int x)
{
	if(f[x]==0)
		return x;
	return f[x]=Find(f[x]);
}
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d %d",&n,&m);
		k=0;
		memset(head,0,sizeof(head));
		for(i=1;i<=m;i++)
		{
			scanf("%d %d %d %d",&u,&v,&l,&h);
			Push(u,v,l);
			Push(v,u,l);
			e[i]=(edge){u,v,h};
		}
		Dijkstra();
		sort(e+1,e+1+m,cmp);
		memset(f,0,sizeof(f));
		for(i=1;i<=m;i++)
		{
			int x=Find(e[i].u),y=Find(e[i].v);
			if(x!=y)
				if(d[x]<d[y])
				{
					f[y]=x;
					fa[0][y]=x;
					fac[0][y]=e[i].h;
				}
				else
				{
					f[x]=y;
					fa[0][x]=y;
					fac[0][x]=e[i].h;
				}
		}
		for(i=1;i<=20;i++)
			for(j=1;j<=n;j++)
			{
				fa[i][j]=fa[i-1][fa[i-1][j]];
				fac[i][j]=min(fac[i-1][j],fac[i-1][fa[i-1][j]]);
			}
		scanf("%d %d %d",&qq,&k,&s);
		ans=0;
		while(qq--)
		{
			scanf("%d %d",&v,&p);
			v=(v+k*ans-1)%n+1;
			p=(p+k*ans)%(s+1);
			for(i=0;fa[i][v]!=0&&fac[i][v]>p;i++);
			for(i--;i>=0;i--)
				if(fa[i][v]!=0&&fac[i][v]>p)
					v=fa[i][v];
			ans=d[v];
			printf("%d\n",ans);
		}
	}
}

```

---

## 作者：juju527 (赞：9)

本题大致有两种方法，kruskal重构树或者可持久化并查集

~~当然dijkstra必不可少~~

~~spfa的死亡祭~~

### kruscal 重构树
[kruskal重构树学习笔记](https://blog.csdn.net/zty_ju/article/details/105150534)

这里就不再复述

### 可持久化并查集

一句话题意：

询问从v点出发只经过海拔大于p的边能到达的所有点中，里点1最近距离最小的值

用$dis_i$表示从1到i点的最短路距离

那么我们可以理解为对于一个p，我们建一个图

图中只有海拔小于等于p的边

那么v点所在的联通块中的最小dis值即为所求

而联通块最经典的维护便是并查集

先把p离散化成m范围

对于每一个p都要一个并查集这样的空间复杂度高达$nm$

我们用可持久化把空间复杂度降到$n*logn$

可持久化并查集用**按秩合并**

路径压缩会改很多地方，而以可持久化修改就加点的原则来说，空间时间都不太对

由于对于p到p+1，并查集可能新增多条边

我们修改并查集时并非每一个p只加log个点

但均摊复杂度$O(mlogn)$

对于写这种码量恶心的东西，我想说

**kruskal重构树NB!!**
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=200005,maxm=400005;
const long long inf=0x3f3f3f3f3f3f3f3f;
struct node{
	int ls,rs;
	int f,rk;
	long long mn;
}tree[41*maxm];
int tot=0;
int root[maxm];
struct edge{
	int u,v,a;
	bool operator <(edge i)const{
		return a>i.a;
	}
}ed[maxm];
struct que{
	int id;
	long long data;
	bool operator <(que i)const{
		return data>i.data;
	}
};
struct Edge{
	int to;
	long long w;
	int nxt;
}e[2*maxm];
int cnt;
int head[maxn];
int n,m,Q,K,S;
long long dis[maxn];
bool vis[maxn];
priority_queue<que>q1;
int read(){
	int x=0,y=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return x*y;
}
void add(int u,int v,long long w){
	e[cnt].to=v;
	e[cnt].w=w;
	e[cnt].nxt=head[u];
	head[u]=cnt++;
	return ;	
}
void dijkstra(){
	memset(dis,0x3f,sizeof(dis));
	memset(vis,0,sizeof(vis));
	que u;
	u.id=1;u.data=0;dis[1]=0;
	q1.push(u);
	while(!q1.empty()){
		int k=q1.top().id;
		q1.pop();
		if(vis[k])continue;
		vis[k]=1;
		for(int i=head[k];i!=-1;i=e[i].nxt){
			int tmp=e[i].to;
			if(dis[tmp]<=dis[k]+e[i].w)continue;
			dis[tmp]=dis[k]+e[i].w;
			que o;
			o.id=tmp;o.data=dis[tmp];
			q1.push(o);
		}
	}
	return ;
}
void build(int x,int l,int r){
	if(l==r){
		tree[x].ls=tree[x].rs=0;
		tree[x].f=l;
		tree[x].rk=1;
		tree[x].mn=dis[l];
		return ;
	}
	int mid=l+((r-l)>>1);
	tree[x].f=tree[x].rk=0;
	tree[x].mn=inf;
	tree[x].ls=++tot;
	build(tree[x].ls,l,mid);
	tree[x].rs=++tot;
	build(tree[x].rs,mid+1,r);
	return ;
}
void modify(int x,int y,int l,int r,int p,int fa,int q,long long mn,int rk){
	if(l==r){
		if(l==p){
			tree[x].ls=tree[x].rs=0;
			tree[x].f=fa;
//			cout<<"###"<<p<<" "<<fa<<endl;
			tree[x].rk=tree[y].rk;
			tree[x].mn=tree[y].mn;
		}
		if(l==q){
			tree[x].ls=tree[x].rs=0;
			tree[x].f=tree[y].f;
			tree[x].rk=max(tree[y].rk,rk+1);
//			cout<<"$$$"<<q<<" "<<tree[y].mn<<" "<<mn<<endl;
			tree[x].mn=min(tree[y].mn,mn);
		}
		return ;
	}
	int mid=l+((r-l)>>1);
	tree[x].f=tree[x].rk=0;
	tree[x].mn=inf;
	if((p>=l&&p<=mid)||(q>=l&&q<=mid)){
		tree[x].ls=++tot;
		if(!((p<=r&&p>mid)||(q<=r&&q>mid)))
			tree[x].rs=tree[y].rs;
		modify(tree[x].ls,tree[y].ls,l,mid,p,fa,q,mn,rk);
	}
	if((p<=r&&p>mid)||(q<=r&&q>mid)){
		tree[x].rs=++tot;
		if(!((p>=l&&p<=mid)||(q>=l&&q<=mid)))
			tree[x].ls=tree[y].ls;
		modify(tree[x].rs,tree[y].rs,mid+1,r,p,fa,q,mn,rk);
	}
	return ;
}
long long query(int x,int l,int r,int p,int flag){
	if(l>p||r<p)return -1;
	if(l==r){
		if(flag==0)return tree[x].f;
		if(flag==1)return tree[x].rk;
		if(flag==2)return tree[x].mn;
	}
	int mid=l+((r-l)>>1);
	long long tmp1=query(tree[x].ls,l,mid,p,flag);
	long long tmp2=query(tree[x].rs,mid+1,r,p,flag);
	return max(tmp1,tmp2);
}
int getroot(int v,int p){
//	cout<<"@@@"; 
	while(1){
//		cout<<p<<" ";
		int fa=query(root[v],1,n,p,0);
		if(fa==p)break;
		p=fa;
	}
//	cout<<endl;
	return p;
}
int search(int x){
	int l=0,r=m+1;
	while(l+1<r){
		int mid=l+((r-l)>>1);
		if(ed[mid].a>=x)
			l=mid;
		else
			r=mid;
	}
	return l;
}
int main(){
	int t;
	t=read();
	while(t--){
		n=read();m=read();
		cnt=0;
		memset(head,-1,sizeof(head));
		for(int i=1;i<=m;i++){
			int u,v,l,a;
			u=read();v=read();l=read();a=read();
			add(u,v,l);
			add(v,u,l);
			ed[i].u=u;ed[i].v=v;ed[i].a=a;
		}
		dijkstra();
		tot=0;
		root[0]=++tot;
		build(1,1,n);
		sort(ed+1,ed+m+1);
		for(int i=1;i<=m;i++){
			int u=ed[i].u,v=ed[i].v,w=ed[i].a;
			u=getroot(i-1,u);
			v=getroot(i-1,v);
			if(u==v){root[i]=root[i-1];continue;}
			int rk1=query(root[i-1],1,n,u,1);
			int rk2=query(root[i-1],1,n,v,1);
			if(rk1>rk2){swap(u,v);swap(rk1,rk2);}
			long long mn=query(root[i-1],1,n,u,2);
			root[i]=++tot;
			modify(root[i],root[i-1],1,n,u,v,v,mn,rk1);
		}
		long long lastans=0;
		Q=read();K=read();S=read();
		for(int i=1;i<=Q;i++){
			int v,p;
			v=(read()+K*lastans-1)%n+1;
			p=(read()+K*lastans)%(S+1);
			int b=search(p+1);
//			cout<<b<<endl;
//			cout<<"*"<<getroot(b,v)<<endl;
			lastans=query(root[b],1,n,getroot(b,v),2);
			printf("%lld\n",lastans);
		}
	}
	return 0;
}
```

---

## 作者：liuzhangfeiabc (赞：8)

正解好像叫做“kruskal重构树”，不过本蒟蒻表示没听说过这个名词，那就尽量用通俗易懂的语言讲明白这是个什么东西吧。

如果不强制在线，有一种比较直观的做法：按高度降序排序后，每次加入一条边相当于合并两个连通块，询问相当于查询当前连通块中dis的最小值，显然可以直接用并查集维护。

然而这题要强制在线，咋办？可持久化并查集？

其实是可以的，因为 只有访问历史版本没有修改，可以通过一些操作使得复杂度控制在一个log，不过本蒟蒻并不会写……

（好像直接写普通的可持久化并查集再卡卡常也能过的样子）。

当然这东西比较烦谁都不想写，那么还可以怎样？利用“只有访问历史版本没有修改”的性质，我们可以设计如下算法：

在每次合并时，新建一个节点，将这两个连通块合并上去，同时记录当前节点的dis是两个集合的dis的min，高度是当前边的高度。

这样预处理完之后，整张图会被建成一棵树，原始节点是叶子，高度信息是从叶子到根递减的。

于是，对于一组询问，我们可以直接倍增找到对应的合并节点，然后直接查询dis即可。

复杂度O(nlogn)。

还有一个小插曲：求最短路时，写spfa会被卡！

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,m;
#define li long long
#define gc getchar()
#define pc putchar
int read(){
	int x = 0,c = gc;
	while(!isdigit(c)) c = gc;
	while(isdigit(c)){
		x = (x << 1) + (x << 3) + (c ^ '0');
		c = gc;
	}
	return x;
}
void print(int x){
	if(x >= 10) print(x / 10);
	pc(x % 10 + '0');
}
struct edge{
	int fr,to,nxt,val,hg;
}e[800010];
int ct,cnt,tc,fir[200010];
struct eg{
	int fr,to,hg;
}o[400010];
void ins(int u,int v,int w,int x){
	e[++cnt].fr = u;e[cnt].to = v;e[cnt].nxt = fir[u];fir[u] = cnt;e[cnt].val = w;e[cnt].hg = x;
	e[++cnt].fr = v;e[cnt].to = u;e[cnt].nxt = fir[v];fir[v] = cnt;e[cnt].val = w;e[cnt].hg = x;
	o[++ct].fr = u;o[ct].to = v;o[ct].hg = x;
}
bool operator < (eg q,eg w){
	return q.hg > w.hg;
}
int f[400010],vl[400010];
int fa[400010];
int st[20][400010],mn[400010];
li dis[200010];
const int inf = 2007654321;
int p,k,s;
li as; 
priority_queue<pair<int,int> > q;
#define mp make_pair
#define fi first
#define se second
void dij(){
	int i,j;
	for(i = 2;i <= n;++i) dis[i] = inf;
	dis[1] = 0;q.push(mp(0,1));
	while(!q.empty()){
		pair<int,int> t = q.top();q.pop();
		if(-t.fi != dis[t.se]) continue;
		for(i = fir[t.se];i;i = e[i].nxt){
			j = e[i].to;
			if(-t.fi + e[i].val < dis[j]){
				dis[j] = -t.fi + e[i].val;
				q.push(mp(-dis[j],j));
			}
		}
	}
} 
int getf(int q){
	return f[q] == q ? q : f[q] = getf(f[q]);
}
void mg(int u,int v,int w){
	int x = getf(u),y = getf(v);
	if(x == y) return;
	f[x] = f[y] = st[0][x] = st[0][y] = ++tc;
	mn[tc] = w;
	vl[tc] = min(vl[x],vl[y]);
}
int lgo[400010],dpt[400010];
void buildst(){
	register int i,j;
	for(i = 1;i <= lgo[tc];++i){
		for(j = 1;j <= tc;++j) st[i][j] = st[i - 1][st[i - 1][j]];
	}
}
void dfs(int q){
	if(dpt[q] || q == tc) return;
	dfs(st[0][q]);
	dpt[q] = dpt[st[0][q]] + 1;
}
int main(){
	int u,v,w,x;
	int i,j;
	for(i = 2;i <= 400000;++i) lgo[i] = lgo[i >> 1] + 1;
	t = read();
	while(t--){
		memset(fir,0,sizeof(fir));ct = cnt = as = 0;
		n = read();m = read();tc = n;
		for(i = 1;i <= m;++i){
			u = read();v = read();w = read();x = read();ins(u,v,w,x);
		}
		dij();
		sort(o + 1,o + ct + 1);
		for(i = 1;i <= n * 2;++i) f[i] = i,fa[i] = dpt[i] = 0;
		for(i = 1;i <= n;++i) vl[i] = dis[i];
		for(i = 1;i <= ct;++i) mg(o[i].fr,o[i].to,o[i].hg);
		buildst();
		for(i = 1;i <= tc;++i) if(!dpt[i]) dfs(i);
		p = read();k = read();s = read();
		int tot = 0; 
		for(i = 1;i <= p;++i){
			u = read();v = read();
			u = (u + k * as - 1) % n + 1;
			v = (v + k * as) % (s + 1);
			for(j = lgo[dpt[u]];j >= 0;--j) mn[st[j][u]] > v ? u = st[j][u] : 0;
			print(as = vl[u]);pc('\n');
		}
	}
	return 0;
}
```

---

## 作者：shadowice1984 (赞：6)

场外选手休闲做题 

kruskal重构树什么的根本没听说过啊……

~~这里是愚蠢的$O(nlog^2n)$做法，然而跑的飞起~~

__________________

首先如果我们仔细想一下的话，由于下车之后无论是不是积水的边都能走，所以下车之后一定会走到1号点的最短路

如此说来我们可以使用dijkstra算法处理出1号点到其他所有点的最短路

那么我们乘车的目的就是选择一个到一号点最短路最小的点下车

但是车是有使用限制的，我们只能走不积水的边

那么我们可以想到一个非常暴力的方式就是每次暴力的把所有还不积水的边塞到并查集里，此时我们查一发并查集中每个点到一号点的最小值即可知道此时到达一号点的最小步行距离

当然暴力是过不去的，但是我们可以考虑如何优化这个东西

发现每次的询问时给出了一个积水量，海拔大于这个积水量的边才有效。

那么我们可以尝试把所有边按照海拔排一个序，此时我们会发现每次询问相当于规定了一个前缀是生效的。

等等，每次一个边的前缀是生效的？

现在我们将边从大到小依次加入并查集中，我们认为这个顺序就是时间顺序

显然我们的并查集会有n个版本(因为每次合并集合总数减少1)

每次应对询问的时候我们二分一下可以确定到底哪些边是生效的

这些边都生效且另外的边都不生效时的并查集，其实时我们把边排序依次加入并查集这个过程的某一个历史版本

为了回答询问我们需要知道某一个这个并查集的某一个历史版本长什么样，然后在这个的并查集的历史版本里面查一下最小值即可了

所以说，我们要实现一个并查集资瓷快速访问历史版本

可持久化并查集！

如果不会的的话可以左转你站模板区

另外一件事时如果我们只是实现一个可持久化并查集的话会发现复杂度时$O((E+Q)log^2N)$基本过不去

但是我们做个小优化，我们写一个真实的不可持久化的并查集，然后将这个并查集的变化用可持久化数组记录下来

此时我们的复杂度变成了$O((N+E)logN+Qlog^2N)$此时常数压力就比较小了我们就可以(加)轻(上)松(快)的(读)通过本题

对了也是最重要的一点

# 关于spfa

~~它死了~~

被负责任的出题人干掉了，所以请使用dijkstra

上代码~

```C
// luogu-judger-enable-o2
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
template <class T>
void read(T &x){
    char c;
    bool op = 0;
    while(c = getchar(), c < '0' || c > '9')
    if(c == '-') op = 1;
    x = c - '0';
    while(c = getchar(), c >= '0' && c <= '9')
    x = x * 10 + c - '0';
    if(op) x = -x;
}
const int N=2*1e5+10;const int E=4*1e5+10;typedef long long ll;
int n;int m;int q;ll k;ll s;int T;int dis[N];int cnt;
struct data
{
    int u;int v;int dep;
    friend bool operator <(data a,data b){return a.dep>b.dep;}
}ed[E];
namespace dijkstra//最短路预处理
{
    int v[2*E];int x[2*E];int ct;int al[N];int val[2*E];
    inline void add(int u,int V,int va){v[++ct]=V;x[ct]=al[u];al[u]=ct;val[ct]=va;}
    struct nod{int dis;int u;friend bool operator <(nod a,nod b){return a.dis>b.dis;}};
    priority_queue <nod> pq;bool book[N];
    inline void solve()
    {
        for(int i=1;i<=n;i++)dis[i]=0x7f7f7f7f;dis[1]=0;pq.push((nod){0,1});
        while(!pq.empty())
        {
            nod nw=pq.top();pq.pop();if(book[nw.u])continue;book[nw.u]=true;
            for(int i=al[nw.u];i;i=x[i])
                if(!book[v[i]]&&dis[v[i]]>nw.dis+val[i])
                    dis[v[i]]=nw.dis+val[i],pq.push((nod){dis[v[i]],v[i]});
        }
    }
    inline void clear()
    {for(int i=1;i<=n;i++)book[i]=false;for(int i=1;i<=n;i++)al[i]=0;ct=0;}
}
struct per_array//可持久化数组
{
    int s[20*E][2];int root[E];int w[20*E];int ct;int tim;
    inline void setval(int p1,int p2,int l,int r,const int& pos,const int& val)
    {
        if(r-l==1){w[p1]=val;return;}int mid=(l+r)/2;
        if(pos<=mid)s[p1][0]=++ct,s[p1][1]=s[p2][1],setval(ct,s[p2][0],l,mid,pos,val);
        else s[p1][1]=++ct,s[p1][0]=s[p2][0],setval(ct,s[p2][1],mid,r,pos,val);
    }
    inline int find(int p,int l,int r,const int& pos)
    {
        if(r-l==1){return w[p];}int mid=(l+r)/2;
        if(pos<=mid)return find(s[p][0],l,mid,pos);
        else return find(s[p][1],mid,r,pos);
    }
    inline void ih(int p,int l,int r,int* st)//并查集由于一开始数组不为空所以要初始化
    {
        if(r-l==1){w[p]=st[r];return;}int mid=(l+r)/2;
        s[p][0]=++ct;s[p][1]=++ct;ih(s[p][0],l,mid,st);ih(s[p][1],mid,r,st);
    }
    inline void csval(const int& pos,const int& val)
    {root[++tim]=++ct;setval(root[tim],root[tim-1],0,n,pos,val);}
    inline void cih(int* st){ih(root[0]=++ct,0,n,st);}
    inline int cfind(const int& t,const int& p){return find(root[t],0,n,p);}
    inline void skip(){++tim;root[tim]=root[tim-1];}
    inline void clear(){ct=0;tim=0;}
}pa1,pa2;
struct bcj//普通的并查集，注意的是不要加路径压缩
{
    int fa[N];int siz[N];int mi[N];
    inline void ih()
    {
        for(int i=1;i<=n;i++)fa[i]=i;for(int i=1;i<=n;i++)siz[i]=1;for(int i=1;i<=n;i++)mi[i]=dis[i];
        pa1.cih(fa);pa2.cih(mi);
    }
    inline int f(int x){++cnt;return (fa[x]==x)?x:f(fa[x]);}
    inline void u(int x,int y)
    {
        int u=f(x);int v=f(y);
        if(u==v){pa1.skip();pa2.skip();return;}
        if(siz[u]>siz[v])swap(u,v);
        fa[u]=v;siz[v]+=siz[u];mi[v]=min(mi[v],mi[u]);
        pa1.csval(u,v);pa2.csval(v,mi[v]);
    }
}bj;
inline void solve()//解决问题
{
    read(n);read(m);
    for(int i=1,u,v,w,d;i<=m;i++)
    {
        read(u);read(v);read(w);read(d);
        dijkstra::add(u,v,w);dijkstra::add(v,u,w);ed[i]=(data){u,v,d};}
    dijkstra::solve();bj.ih();sort(ed+1,ed+m+1);ed[0].dep=0x7f7f7f7f;
    for(int i=1;i<=m;i++){bj.u(ed[i].u,ed[i].v);}
    ll lastans=0;read(q);read(k);read(s);
    for(int i=1;i<=q;i++)
    {
        ll v0;ll p0;read(v0);read(p0);
        v0=(v0+k*lastans-1)%n+1;p0=(p0+k*lastans)%(s+1);int l=0;int r=m;
        while(l!=r){int mid=(l+r+1)/2;if(ed[mid].dep<=p0)r=mid-1;else l=mid;}
        int p=v0;while(1){int fa=pa1.cfind(l,p);if(p==fa)break;else p=fa;}
        lastans=pa2.cfind(l,p);printf("%lld\n",lastans);
    }
}
inline void clear(){dijkstra::clear();pa1.clear();pa2.clear();}
int main(){scanf("%d",&T);for(int z=1;z<=T;z++)solve(),clear();return 0;}

```






---

## 作者：XG_Zepto (赞：5)

### 思路

这道题作为签到题思路还是非常简单的。把没有积水开车可以相互抵达的点并查集合并，同时维护一个“联通块”里走路到终点的最短路径。题目要求在线，那就用可持久化并查集。

初始状态是每个点相互独立，我们按海拔从高到低的顺序依次合并边的入点和出点，询问的时候二分一下版本直接在主席树里查找就可以。

代码的话，理解了思路是比较好打的，就是很多细节需要注意。建议在写这道题之前先 AC [【模板】可持久化并查集](https://www.luogu.org/problemnew/show/P3402)。

首发于[个人博客](https://www.xgzepto.cn/post/noi-2018-return)。

### 代码

```cpp
#include <bits/stdc++.h>
#define mid ((l+r)>>1)
#define maxn 400010
#define minn(a,b) a<b?a:b
#define maxx(a,b) a>b?a:b 
using namespace std;
int root[maxn],head[maxn],dis[maxn],n,m,cnt,cnt_e;
struct Edge{
    int to,next,val,lev;
    Edge(int a=0,int b=0,int c=0,int d=0){
        to=a,next=b,val=c,lev=d;
    }
}l[maxn<<2];//储存原图
struct Sp_Edge{
    int from,to,lev;
    Sp_Edge(int a=0,int b=0,int c=0){
        from=a,to=b,lev=c;
    }
    bool operator < (const Sp_Edge &x) const{
        return lev>x.lev;
    }
}e[maxn<<2];//用于排序和并查集合并
struct Node{
    int f,p,d;
    Node(int a=0,int b=0,int c=0){
        f=a,p=b,d=c;
    }
};//主席树节点
struct PT{
    int ls[maxn*44],rs[maxn*44],now;
    Node tree[maxn*44],ins;
    void ctl(int f,int p,int d){
        ins=Node(f,p,d);
    }//要插入的信息
    inline int build(int l,int r){
        int o=++now;
        if (l==r){
            tree[o]=Node(l,1,dis[l]);
            return o;
        }
        ls[o]=build(l,mid);
        rs[o]=build(mid+1,r);
        return o;
    }
    inline int insert(int pre,int l,int r,int x){
        int o=++now;
        tree[o]=tree[pre];
        ls[o]=ls[pre],rs[o]=rs[pre];
        if (l==r){
            tree[o]=ins;
            return o;
        }
        if (x<=mid) ls[o]=insert(ls[pre],l,mid,x);
            else rs[o]=insert(rs[pre],mid+1,r,x);
        return o;
    }
    inline Node query(int o,int l,int r,int x){
        if (l==r) return tree[o];
        if (x<=mid) return query(ls[o],l,mid,x);
        else return query(rs[o],mid+1,r,x);
    }
    inline void reset(){
        memset(ls,0,sizeof(ls));
        memset(rs,0,sizeof(rs));
        memset(tree,0,sizeof(tree));
        now=0;
    }
}ds;//主席树基本操作
struct d_node{
    int v,d;
    d_node(int a=0,int b=0){
        v=a,d=b;
    }
    bool operator < (const d_node &x) const{
        return d>x.d;
    }
};//用于堆优化 Dijistra
inline void Dijstra(){
    int vis[maxn];
    memset(dis,0x3f,sizeof(dis));
    memset(vis,0,sizeof(vis));
    priority_queue<d_node>q;
    q.push((d_node){1,0});
    dis[1]=0;
    while(!q.empty()){
        d_node hq=q.top();q.pop();
        if (vis[hq.v]) continue;
        vis[hq.v]=1;
        for (register int i=head[hq.v];i;i=l[i].next){
            int v=l[i].to;if (vis[v]) continue;
            if (dis[v]>dis[hq.v]+l[i].val)
            dis[v]=dis[hq.v]+l[i].val,q.push((d_node){v,dis[v]});
        }
    }
}
inline void Add(int fr,int to,int dis,int lev){
    l[++cnt]=Edge(to,head[fr],dis,lev);
    head[fr]=cnt;
    l[++cnt]=Edge(fr,head[to],dis,lev);
    head[to]=cnt;
    e[++cnt_e]=Sp_Edge(fr,to,lev);
}
inline int search(int x){
    int l=1,r=m,res=0;
    while(l<=r){
        if (e[mid].lev>x)
            res=mid,l=mid+1;
        else r=mid-1;
    }
    return res;
}//二分查找版本
inline int find(int now,int x){
    Node tem=ds.query(root[now],1,n,x);
    int fx=tem.f;
    if (fx==x) return x;
    return find(now,fx);
}//不能路径压缩
inline void merge(int now,int x,int y){
    int fx=find(now,x),fy=find(now,y);
    if (fx==fy) return;
    Node infx=ds.query(root[now],1,n,fx);
    Node infy=ds.query(root[now],1,n,fy);
    if (infx.p>=infy.p) swap(infx,infy),swap(fx,fy);//按深度合并
    ds.ctl(fy,infx.p,infx.d);
    root[now]=ds.insert(root[now],1,n,fx);
    ds.ctl(infy.f,maxx(infx.p+1,infy.p),minn(infx.d,infy.d));
    root[now]=ds.insert(root[now],1,n,fy);
}
inline void Solve(){
    cin>>n>>m;
    int x,y,z,w,v0,p0;
    for (register int i=1;i<=m;i++){
        cin>>x>>y>>z>>w;
        Add(x,y,z,w);
    }
    Dijstra();//预处理最短路
    sort(e+1,e+1+m);
    root[0]=ds.build(1,n);
    for (register int i=1;i<=m;i++){
        root[i]=root[i-1];
        merge(i,e[i].from,e[i].to);
    }//按海报高度合并
    int q,k,s,lastans=0;
    cin>>q>>k>>s;
    for (register int i=1;i<=q;i++){
        cin>>v0>>p0;
        v0=(v0+k*lastans-1)%n+1;
        p0=(p0+k*lastans)%(s+1);
        int pos=search(p0);
        int loc=find(pos,v0);
        Node tem=ds.query(root[pos],1,n,loc);
        lastans=tem.d;
        printf("%d\n",lastans);
    }
}
inline void Reset(){
    memset(root,0,sizeof(root));
    memset(head,0,sizeof(head));
    memset(l,0,sizeof(l));
    memset(e,0,sizeof(e));
    n=0,m=0,cnt=0,cnt_e=0;
    ds.reset();
}
int main(){
    int T;
    cin>>T;
    for (int i=1;i<=T;i++){
        Solve();
        if (i==T) break;
        Reset();
    }
    return 0;
}
```

---

## 作者：Hades18 (赞：4)

调了一天的并查集~~mdzz~~，忘加路径压缩和判一个连通块是什么鬼啊！！！~~（冷静一下情绪）~~

好了，先讲离线做法：
> 对边的$high$降序排序，对询问的$p$降序排序。

> 我们考虑讲$high>p$的所有边添加到图中，对于每一个连通块，我们记录连通块中点离1号点的最小距离，此时可以用$Dijkstra$+并查集来实现~~（SPFA会被卡是常识...）~~。

接下了代码长这样：

```cpp
for(int i=1;i<=n;++i)fat[i]=i;
for(int i=0;i<Q;++i)
{
	int v=que[i].v,p=que[i].p;
	for(;!pq.empty()&&pq.top().a>p;pq.pop())
	{
		int x=Fin(pq.top().u),y=Fin(pq.top().v);
		if(x==y)continue;
		dis[x]=min(dis[x],dis[y]);
		fat[y]=x;
	}
	ans[que[i].id]=dis[Fin(v)];
}
//pq是priority_queue，存边
//que是询问，Fin找根
```

`Dijkstra`长这样：
```cpp
memset(vis,0,sizeof vis);
memset(dis,63,sizeof dis);
dis[1]=0;pq.push(E{0,1});
for(;!pq.empty();)
{
	E t=pq.top();pq.pop();
	if(vis[t.v])continue;vis[t.v]=1;
	for(E x:fir[t.v])
		if(t.w+x.w<dis[x.v])
			pq.push(E{dis[x.v]=t.w+x.w,x.v});
}
```

从离线扩展到在线：
> 依旧对$high$降序排序，由于$p$的询问不确定，我们可以先将$edge$按$high$加入图中，同时维护上述值，此时我们只需要将加边的过程可持久化一下，*就*好了~~(什么叫就，根本不会可持久化并查集...)~~。

> 考虑并查集的每一次合并，就只是$father$数组与$mindis$数组改变了，于是*可持久化并查集*$->$*可持久化数组*。

> 我们自然而然地想到*可持久化数组*的一种水法，对于每一个点，将其$father$开成一个$vector$，每当其$father$改变时，我们在这个$vector$末尾插入一个$pair$，记录在哪个$high$改成什么，$mindis$同理。

预处理跃然纸上：
```cpp
//a.rbegin()为a这个vector的最后一个元素
for(int i=0;i<m;++i)
{
	int p=edg[i].p,u=Fin(edg[i].u),v=Fin(edg[i].v);if(u==v)continue;
	if(siz[u]<siz[v])
		u^=v^=u^=v;
	siz[u]=siz[u]+siz[v];
	fa[v]=u;
	mnn[u].push_back(E{p,min(mnn[u].rbegin()->v,mnn[v].rbegin()->v)});
	fat[v].push_back(E{p,u});
}
```
那我们怎么知道询问$p$时$v$的$father$是什么呢：

> 首先一个点的$fat$中元素是单调递减的，且每个元素有效范围是$[now.first,las.first)$，于是我们只需要在$fat$里`lower_bound`一下就好了。

> 当我们找到$v$在$p$水位线时的根时，再在$mindis$中`lower_bound`一下就出答案了。

源码：
```cpp
#pragma GCC optimize(3,"inline,Ofast")
#include<queue>
#include<cstdio>
#include<vector>
#include<cstring>
#include<algorithm>
#define N 200005
#define M 400005
inline int read(){
	int x=0,f=0;
	register char ch=getchar();
	for(;ch<48||ch>57;ch=getchar())f|=ch=='-';
	for(;ch>47&&ch<58;ch=getchar())
	x=(x<<1)+(x<<3)+(ch^48);
	return f?~x+1:x;
}
using namespace std;
struct E{int w,v;bool operator<(const E&o)const{return w>o.w;}};
struct O{int p,u,v;bool operator<(const O&o)const{return p>o.p;}}edg[M];
priority_queue<E>pq;
vector<E>fir[N],fat[N],mnn[N];
int vis[N],dis[N],siz[N],fa[N];
int Fin(int x){return fa[x]==x?x:fa[x]=Fin(fa[x]);}
int main()
{
	for(int cas=0,T=read();cas<T;++cas)
	{
		int n=read(),m=read(),las=0;
		for(int i=1;i<=n;++i)
			fir[i].clear(),fat[i].clear(),mnn[i].clear();
		for(int i=0;i<m;++i)
		{
			int u=read(),v=read(),l=read(),a=read();
			fir[u].push_back(E{l,v});
			fir[v].push_back(E{l,u});
			edg[i]=O{a,u,v};
		}sort(edg,edg+m);
        //Dijkstra begin
		memset(vis,0,sizeof vis);
		memset(dis,63,sizeof dis);
		dis[1]=0;pq.push(E{0,1});
		for(;!pq.empty();)
		{
			E t=pq.top();pq.pop();
			if(vis[t.v])continue;vis[t.v]=1;
			for(E x:fir[t.v])
				if(t.w+x.w<dis[x.v])
					pq.push(E{dis[x.v]=t.w+x.w,x.v});
		}
        //end
		for(int i=1;i<=n;++i)
			fat[i].push_back(E{(int)2e9,fa[i]=i}),
			mnn[i].push_back(E{(int)2e9,dis[i]}),siz[i]=1;
        //init begin
		for(int i=0;i<m;++i)
		{
			int p=edg[i].p,u=Fin(edg[i].u),v=Fin(edg[i].v);if(u==v)continue;
			if(siz[u]<siz[v])u^=v^=u^=v;siz[u]=siz[u]+siz[v];fa[v]=u;
			mnn[u].push_back(E{p,min(mnn[u].rbegin()->v,mnn[v].rbegin()->v)});
			fat[v].push_back(E{p,u});
		}
        //end
		int q=read(),k=read(),s=read();
		for(int i=0;i<q;++i)
		{
			int v=(read()+k*las-1)%n+1,p=(read()+k*las)%(s+1);
			for(int f;v!=(f=(--lower_bound(fat[v].begin(),fat[v].end(),E{p,0}))->v);v=f);
			printf("%d\n",las=(--lower_bound(mnn[v].begin(),mnn[v].end(),E{p,0}))->v);
		}
	}
	return 0;
}
```

写在后面：
> 这个算法的复杂度是$O(n*logm*logn)$，稍微算一下是能过的，可是我一直$TLE$，最终发现没有路径压缩和同连通块跳过，调了一个下午都没发现，~~md~~我还以为我复杂度错了呢，慌了半天。。。

---

## 作者：Slr神龙人 (赞：4)

突然就想给那些不会Kruscal重构树的同学写一个80分的题解（一定只有我不会）
怎么说呢，这个题打同步赛想了一上午，各种奇怪的想法+数据分治结合起来骗了80赶脚很开心（然而大家都A了）

先看一下数据，有65分是可以离线的。那离线应该怎么做呢？
首先跑个最短路求一下1号点到所有点的距离，按照边权从大到小排序，对于询问也按照水位线从大到小排一下序。显然，当一条边加入以后，就不可能再删除，因为水位线只会慢慢降低。这样这个问题就可以转化成，当前询问下，如果把所有大于当前水位线的边加入图中，那么从起点出发，求它所能到达的点中与1号点距离最小的点即可。加边时用并查集维护一下即可：即对于两个点a，b在并查集中的祖先x，y，如果dis[x]>dis[y]，则令fa[x]=y。这样并查集在查询时，就可以以常数的复杂度找到当前询问下的答案。注意加边是在一个查询开始前，将所有海拔大于水位线的边加进去。

然后我们就有65分了，然后我们发现还有一个树的点（5分），对于一棵树，显然两点之间路径唯一，那么以1为根，只需倍增维护一下i点向上跳2^j个单位时的点时多少，两点间最小值是多少即可，能跳就往上跳。最后查到的那个点的dis值极为答案。

对于后边4个点，发现n,m,q都很小，所以对每一次询问做一次离线的那个过程就行了。只要不写挂T1的80就到手啦~
```c
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<algorithm>
#define M 100010
#define INF 99999999
using namespace std;
inline int read()
{
    char c=getchar();int x=0,f=1;
    while(c<'0'||c>'9'){if(c=='-')f=-1; c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0'; c=getchar();}
    return x*f;
}

struct point{
    int next,to,dis,height,from;
}e[M<<3],a[M<<3];

struct Question{
    int v,p,id,ans;
}ask[M<<2];

int n,m,num,K,S,Q,lastans,T;
int head[M],dis[M],fa[M];
int fa1[M][21],fa2[M][21];
bool f[M];

void add(int from,int to,int dis,int aa)
{
    e[++num].next=head[from];
    e[num].to=to;
    e[num].dis=dis;
    e[num].height=aa;
    head[from]=num;
}

typedef pair<int,int> pii;
priority_queue<pii,vector<pii>,greater<pii> >q;

inline void DJ()
{
    for(int i=1;i<=n;i++) dis[i]=INF;
    dis[1]=0;
    q.push(make_pair(dis[1],1));
    while(!q.empty())
    {
        pii mind=q.top();
        q.pop();
        int k=mind.second;
        if(f[k]) continue;
        else
        {
            f[k]=true;
            for(int i=head[k];i;i=e[i].next)
            if(dis[e[i].to]>e[i].dis+dis[k])
            {
                dis[e[i].to]=e[i].dis+dis[k];
                q.push(make_pair(dis[e[i].to],e[i].to));
            }
        }
    }
}

int cmp1(Question x1,Question x2) {return x1.p>x2.p;}
int cmp2(point x1,point x2) {return x1.height>x2.height;}
int cmp3(Question x1,Question x2) {return x1.id<x2.id;}
int find(int x) {return fa[x]==x?x:fa[x]=find(fa[x]);}

inline void merge(int x,int y)
{
    int r1=find(x),r2=find(y);
    if(r1==r2) return;
    if(dis[r1]>dis[r2]) fa[r1]=r2;
    else fa[r2]=r1;
}

inline void work1()
{
    for(int i=1;i<=Q;i++) ask[i].v=read(),ask[i].p=read(),ask[i].id=i;
    sort(ask+1,ask+1+Q,cmp1);
    sort(a+1,a+1+m,cmp2);
    for(int i=1;i<=n;i++) fa[i]=i;
    int now=1;
    for(int i=1;i<=Q;i++)
    {
        while(now<=m&&a[now].height>ask[i].p) merge(a[now].from,a[now].to),now++;
        ask[i].ans=dis[find(ask[i].v)];
    }
    sort(ask+1,ask+1+Q,cmp3);
    for(int i=1;i<=Q;i++) printf("%d\n",ask[i].ans);
}

inline void dfs(int x,int fa)
{
    for(int i=head[x];i;i=e[i].next)
    {
        int to=e[i].to;
        if(to==fa) continue;
        fa1[to][0]=x;
        fa2[to][0]=e[i].height;
        dfs(to,x);
    }
}

int jump(int x,int limit)
{
    if(limit==0) return 1;
    for(int i=20;i>=0;i--)
        if(fa2[x][i]>limit)
            x=fa1[x][i];
    return x;
}

inline void work2()
{
    dfs(1,0);
    for(int j=1;j<=20;j++)
    for(int i=1;i<=n;i++)
    {
        fa1[i][j]=fa1[fa1[i][j-1]][j-1];
        fa2[i][j]=min(fa2[i][j-1],fa2[fa1[i][j-1]][j-1]);
    }
    for(int i=1;i<=Q;i++)
    {
        int v=(read()+K*lastans-1)%n+1;
        int p=(read()+K*lastans)%(S+1);
        int to=jump(v,p);
        lastans=dis[to];
        printf("%d\n",lastans);
    }
}
inline void work3()
{
    sort(a+1,a+1+m,cmp2);
    for(int kkk=1;kkk<=Q;kkk++)
    {
        for(int i=1;i<=n;i++) fa[i]=i;
        int now=1;
        int v=(read()+K*lastans-1)%n+1;
        int p=(read()+K*lastans)%(S+1);
        while(now<=m&&a[now].height>p) merge(a[now].from,a[now].to),now++;
        int x=find(v);
        lastans=dis[x];
        printf("%d\n",lastans);
    }
}

int main()
{
//	freopen("return.in","r",stdin);
//	freopen("return.out","w",stdout);
    cin>>T;
    while(T--)
    {
        memset(head,0,sizeof(head));
        memset(e,0,sizeof(e));
        memset(f,0,sizeof(f));
        lastans=num=0;
        n=read(); m=read();
        for(int i=1;i<=m;i++)
        {
            int u=read(),v=read(),l=read(),aa=read();
            a[i].from=u; a[i].to=v; a[i].dis=l; a[i].height=aa;
            add(u,v,l,aa); add(v,u,l,aa);
        }
        DJ();
        Q=read(),K=read(),S=read();
        if(K==0) work1();
        else if(m==n-1) work2();
        else if(n<=1500) work3();
    }
    return 0;
}
```

---

## 作者：Adove (赞：3)

Kruskal重构树

我们学LCA的时候知道倍增是除了baoli之外最慢的做法

在线情况下比较快的是树剖

我们可以先判一下top是否为root和top的fa是否满足要求

是就往上跳，否就二分

算是用代码复杂度换了代码的效率

```cpp
#include"cstdio"
#include"cstring"
#include"iostream"
#include"algorithm"
using namespace std;

const int MAXN=2e5+5;
const int MAXM=4e5+5;

int T,n,m,np,las;
int h[MAXM],ln[MAXM],hp[MAXN],id[MAXM];
struct rpg{
	int li,nx,ln;
}a[MAXM<<1];
struct l{
	int ls,nx,ln;
}L[MAXM];

int read()
{
	int x=0;char ch=getchar();
	while(ch<'0'||'9'<ch) ch=getchar();
	while('0'<=ch&&ch<='9') x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return x;
}

void add(int ls,int nx,int ln)
{
	a[++np]=(rpg){h[ls],nx,ln};h[ls]=np;
	a[++np]=(rpg){h[nx],ls,ln};h[nx]=np;
}

void up(int x)
{
	for(int i=x,j=i>>1;j;i=j,j>>=1){
		if(ln[hp[j]]>ln[hp[i]]) swap(id[hp[i]],id[hp[j]]),swap(hp[i],hp[j]);
		else break;
	}return;
}

void ins(int x)
{
	hp[++hp[0]]=x;
	id[x]=hp[0];
	up(id[x]);
	return;
}

void pop()
{
	id[hp[1]]=0;
	hp[1]=hp[hp[0]--];
	for(int i=1,j=2;j<=hp[0];i=j,j<<=1){
		if(j<hp[0]&&ln[hp[j+1]]<ln[hp[j]]) ++j;
		if(ln[hp[j]]<ln[hp[i]]) swap(hp[i],hp[j]),swap(id[hp[i]],id[hp[j]]);
		else break;
	}return;
}

void SPkstra()
{
	memset(id,0,sizeof(id));
	memset(ln,0x7f,sizeof(ln));
	ln[1]=0;ins(1);
	while(hp[0]){
		int nw=hp[1];pop();
		for(int i=h[nw];i;i=a[i].li){
			if(ln[a[i].nx]>ln[nw]+a[i].ln){
				ln[a[i].nx]=ln[nw]+a[i].ln;
				if(id[a[i].nx]) up(id[a[i].nx]);
				else ins(a[i].nx);
			}
		}
	}return;
}

int f[MAXM];
int v[MAXM];
int dep[MAXM],siz[MAXM],sn[MAXM],rid[MAXM],top[MAXM];

bool cmp(l a,l b){return a.ln>b.ln;}
int find(int x){return f[x]==x?x:f[x]=find(f[x]);}
void ad(int ls,int nx){a[++np]=(rpg){h[ls],nx};h[ls]=np;}

void dfs1(int x,int fa,int tp)
{
	siz[x]=1;
	f[x]=fa;
	dep[x]=tp;
	sn[x]=0;
	if(h[x]) ln[x]=2e9;
	for(int i=h[x];i;i=a[i].li){
		dfs1(a[i].nx,x,tp+1);
		siz[x]+=siz[a[i].nx];
		ln[x]=min(ln[x],ln[a[i].nx]);
		if(siz[a[i].nx]>siz[sn[x]]) sn[x]=a[i].nx;
	}return;
}

void dfs2(int x,int tpx)
{
	top[x]=tpx;
	id[x]=++id[0];
	rid[id[x]]=x;
	if(!sn[x]) return;
	dfs2(sn[x],tpx);
	for(int i=h[x];i;i=a[i].li){
		if(a[i].nx==sn[x]) continue;
		dfs2(a[i].nx,a[i].nx);
	}return;
}

void init()
{
	memset(h,0,sizeof(h));np=id[0]=0;
	n=read(),m=read();
	for(int i=1;i<=n<<1;++i) f[i]=i,v[i]=2e9;
	for(int i=1;i<=m;++i){
		int x=read(),y=read(),z1=read(),z2=read();
		L[i]=(l){x,y,z2};
		add(x,y,z1);
	}SPkstra();
	memset(h,0,sizeof(h));np=0;
	sort(L+1,L+m+1,cmp);int ct=0;
	for(int i=1;i<=m;++i){
		int fa=find(L[i].ls),fb=find(L[i].nx);
		if(fa!=fb){
			++ct;
			f[fa]=ct+n;
			f[fb]=ct+n;
			v[ct+n]=L[i].ln;
			ad(ct+n,fa);
			ad(ct+n,fb);
		}if(ct==n-1) break;
	}dfs1((n<<1)-1,(n<<1)-1,1);dfs2((n<<1)-1,(n<<1)-1);
	return;
}

int cq(int x,int vl)
{
	while(top[x]!=(n<<1)-1&&v[f[top[x]]]>vl) x=f[top[x]];
	int l=id[top[x]],r=id[x];
	while(l<r){
		int mid=l+r>>1;
		if(v[rid[mid]]>vl) r=mid;
		else l=mid+1;
	}return rid[l];
}

void solve()
{
	las=0;
	int Q=read(),K=read(),S=read();
	while(Q--){
		int v=(read()+K*las-1)%n+1,w=(read()+K*las)%(S+1);
		printf("%d\n",las=ln[cq(v,w)]);
	}return;
}

int main()
{
	T=read();
	while(T--){
		init();
		solve();
	}return 0;
}
```

---

## 作者：GoldenPotato137 (赞：3)


[戳我获得更好的阅读体验qwq](https://www.goldenpotato.cn/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/luogu-p4768-noi2018%E5%BD%92%E7%A8%8B/)

---
# Solution
这题可能要用到Kruskal重构树的相关知识，如果有需求的同学可以[看这里](https://www.goldenpotato.cn/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/kruskal%E9%87%8D%E6%9E%84%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/)

首先，根据我们之前在运输计划那道题的经验，我们会发现我们开车能经过的边一定在**以海拔为关键字的最大生成树上**。

根据Kruskal重构树的性质：**Kruskal重构树是一个堆**，我们可以考虑这样做：
我们先把Kruskal重构树按每条路的海拔从大到小建出来，那么**从某个点出发能开车到达的点一定是这个点的某个祖先的子树内的所有的点**，这个很好理解，因为Kruskal重构树是一个堆，那么堆之内的点的路一定>堆顶，堆外的点一定<=堆顶

所以说，我们只需要先把每个点到**1号节点的最短路**先求出来，每次我们**从出发点向上倍增**，找到刚好>积水线的点，然后找到这个点的子树内距离1最短的点即可，这个用简单的树形DP即可完成。

时间复杂度$O((q+n)logn)$
就酱，这题就被我们切掉啦~(*´ﾟ∀ﾟ｀)ﾉ 

---
# Code
```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<algorithm>
#include<queue>
#include<cstring>
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=2*200000+2000;
const int M=400000+1000;
struct EDGE
{
    int s,to,l,h;
}e1[M];
vector <EDGE> e2[N];//e2需要初始化
int n,m;
long long dis[N];
struct SIT
{
    int to;
    long long w;
    SIT (int x,long long y)
    {
        to=x,w=y;
    }
    friend bool operator < (SIT x,SIT y)
    {
        return x.w>y.w;
    }
};
priority_queue <SIT> mqueue;
void dj()
{
    static bool vis[N];
    memset(vis,0,sizeof vis);
    memset(dis,0x3f,sizeof dis);
    dis[1]=0,mqueue.push(SIT(1,0));
    while(mqueue.empty()==false)
    {
        int now=mqueue.top().to;
        mqueue.pop();
        if(vis[now]==true) continue;
        vis[now]=true;
        for(int i=0;i<int(e2[now].size());i++)
            if(dis[e2[now][i].to] > dis[now]+e2[now][i].l)
            {
                dis[e2[now][i].to]=dis[now]+e2[now][i].l;
                mqueue.push(SIT(e2[now][i].to,dis[e2[now][i].to]));
            }
    }
}
int fa[N][21],depth[N],cnt;//fa需要初始化
vector <int> e3[N];//e3需要初始化
int MIN[N],sl[N];//存放距离最小值位置
bool cmp(EDGE x,EDGE y)
{
    return x.h>y.h;
}
int FindFather(int x)
{
    if(fa[x][0]==0) return x;
    return fa[x][0]=FindFather(fa[x][0]);
}
void Kruskal()
{
    for(int i=1;i<=n;i++)
        MIN[i]=i;
    sort(e1+1,e1+1+m,cmp);
    cnt=n;
    for(int i=1;i<=m;i++)
    {
        int fa1=FindFather(e1[i].s),fa2=FindFather(e1[i].to);
        if(fa1==fa2) continue;
        fa[fa1][0]=fa[fa2][0]=++cnt;
        sl[cnt]=e1[i].h,MIN[cnt]=cnt;
        e3[cnt].push_back(fa1),e3[cnt].push_back(fa2);
    }
    fa[cnt][0]=cnt;
}
void dfs(int now)
{
    for(int i=1;i<=20;i++)
        fa[now][i]=fa[fa[now][i-1]][i-1];
    for(int i=0;i<int(e3[now].size());i++)
    {
        depth[e3[now][i]]=depth[now]+1;
        fa[e3[now][i]][0]=now;
        dfs(e3[now][i]);
        if(dis[MIN[e3[now][i]]]<dis[MIN[now]])
            MIN[now]=MIN[e3[now][i]];
    }
}
int Query(int x,int h)
{
    for(int i=20;i>=0;i--)
        if(sl[fa[x][i]]>h)
            x=fa[x][i];
    return dis[MIN[x]];
}
int main()
{
    int T=read();
    for(;T>0;T--)
    {
        n=read(),m=read();
        
        for(int i=0;i<=2*n+10;i++)
            e2[i].clear(),e2[i].reserve(4);
        memset(fa,0,sizeof fa);
        for(int i=0;i<=2*n+10;i++)
            e3[i].clear(),e3[i].reserve(4);
        
        for(int i=1;i<=m;i++)
        {
            e1[i].s=read(),e1[i].to=read(),e1[i].l=read(),e1[i].h=read();
            e2[e1[i].s].push_back(e1[i]);
            swap(e1[i].s,e1[i].to);
            e2[e1[i].s].push_back(e1[i]);
        }
        
        dj();
        Kruskal();
        dfs(cnt);
        
        long long ans=0,q=read(),K=read(),S=read();
        for(int i=1;i<=q;i++)
        {
            long long v=read(),p=read();
            v=(v+K*ans-1)%n+1,p=(p+K*ans)%(S+1);
            printf("%lld\n",ans=Query(v,p));
        }
    }
    return 0;
}

```









---

## 作者：little_sun (赞：2)

### 题目大意

有一个$n$个点$m$条边的无向联通图， 每条边有两个属性：长度$d$，海拔$h$

有$q$个询问，每个询问给定两个数$v$, $p$，你要找到一个节点$u$，其中$u$要满足$v$到$u$存在一条路径使得这条路径上的边海拔全部大于$p$，求所有可能的$u$到$1$的最短路长度的最小值

### 分析

显然，我们发现$v$到$u$的路径一定在$u$到$v$的最大生成树上。（例：货车运输）

把边按照海拔降序排列，建出该图的$\texttt{kruskal}$重构树，则对于一个节点$s$， 若$s$的点权$val \leq p$则该子树里的所有节点都互相连通（即能开车抵达）。

我们通过$\texttt{dijkstra}$预处理出每个点到$1$的最短路$dis_i$， 并在建出$\texttt{kruskal}$重构树之后在重构树上$\texttt{dfs}$求出每个节点的子树里$dis$的最小值$mind_i$。询问时只要找到$v$最大的点权$\leq p$的祖先$x$，则$mind_x$就是本题的答案。

$x$的寻找可以使用树上倍增算法，（在满足条件的情况下）逐级往上跳

时间复杂度$O(m \log m)$

### 一些额外的东西

这里补充讲一下$\texttt{kruskal}$重构树是怎么建出来的：

1.像正常的$\texttt{kruskal}$重构树那样把所有边按照边权降序/升序排序

2.在合并一条边的两个端点$u, \; v$时，我们不像原来那样把$v$联通块的根节点$fv$设为$fu$，而是新建一个节点$new$并把$new$设为$fu, \; fv$的父亲，并在图中连上$(new, \; fu)$和$(new, \; fv)$两条边，此时该新点的点权就是$u$, $v$最大/小生成树路径上最小/大值

3.重复步骤$2$直到所有边都被遍历一遍

### 代码

``` cpp
#include <bits/stdc++.h>

#define R register
#define ll long long
#define sum(a, b, mod) (((a) + (b)) % mod)

const int MaxN = 8e5 + 10;
const int MaxM = 1e6 + 10;

struct edge
{
    int next, to, dis;
};

struct Edge
{
    int u, v, ht;
};

struct node
{
    int pos, dis;
    bool operator<(node x) const { return dis > x.dis; }
};

edge e[MaxM];
Edge t[MaxN];
int n, m, q, k, s, cnt, num;
int head[MaxM], dep[MaxM], f[MaxM], val[MaxM], mind[MaxN];
int u[MaxN], v[MaxN], l[MaxN], a[MaxN], dis[MaxN], vis[MaxN], fa[MaxN][21];

int cmp(Edge a, Edge b) { return a.ht > b.ht; }

void link(int u, int v, int a) { ++cnt, t[cnt].u = u, t[cnt].v = v, t[cnt].ht = a; }

int getf(int x)
{
    if (x != f[x])
        f[x] = getf(f[x]);
    return f[x];
}

void rebuild()
{
    cnt = 0;
    for (int i = 1; i <= m; i++)
        link(u[i], v[i], a[i]);
}

int jump(int u, int k)
{
    for (int i = 20; ~i; i--)
        if (val[fa[u][i]] > k)
            u = fa[u][i];
    return u;
}

void add_edge(int u, int v, int d)
{
    ++cnt;
    e[cnt].to = v;
    e[cnt].dis = d;
    e[cnt].next = head[u];
    head[u] = cnt;
}

void init()
{
    n = m = cnt = num = 0;
    memset(f, 0, sizeof(fa));
    memset(fa, 0, sizeof(fa));
    memset(dep, 0, sizeof(dep));
    memset(vis, 0, sizeof(vis));
    memset(val, 0, sizeof(val));
    memset(head, 0, sizeof(head));
    memset(mind, 0x3f, sizeof(mind));
}

inline int read()
{
    int x = 0;
    char ch = getchar();
    while (ch > '9' || ch < '0')
        ch = getchar();
    while (ch <= '9' && ch >= '0')
        x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
    return x;
}

void dfs(int u, int fa)
{
    dep[u] = dep[fa] + 1, ::fa[u][0] = fa;
    for (int i = 1; i <= 20; i++)
        ::fa[u][i] = ::fa[::fa[u][i - 1]][i - 1];
    for (int i = head[u]; i; i = e[i].next)
    {
        int v = e[i].to;
        if (v == fa)
            continue;
        dfs(v, u), mind[u] = std::min(mind[u], mind[v]);
    }
}

void kruskal()
{
    num = n, cnt = 0;
    memset(head, 0, sizeof(head));
    std::sort(t + 1, t + m + 1, cmp);
    for (int i = 1; i <= n; i++)
        f[i] = i;
    for (int i = 1; i <= m; i++)
    {
        int fu = getf(t[i].u), fv = getf(t[i].v);
        if (fu != fv)
        {
            val[++num] = t[i].ht;
            f[num] = f[fu] = f[fv] = num;
            add_edge(fu, num, 0), add_edge(num, fu, 0);
            add_edge(fv, num, 0), add_edge(num, fv, 0);
        }
    }
    dfs(num, 0);
}

void dijkstra(int u)
{
    std::priority_queue<node> q;
    memset(dis, 0x3f, sizeof(dis));
    dis[u] = 0, q.push((node){u, 0});
    while (!q.empty())
    {
        node x = q.top();
        q.pop(), u = x.pos;
        if (vis[u])
            continue;
        vis[u] = 1;
        for (int i = head[u]; i; i = e[i].next)
        {
            int v = e[i].to;
            if (dis[u] + e[i].dis < dis[v])
            {
                dis[v] = dis[u] + e[i].dis;
                if (!vis[v])
                    q.push((node){v, dis[v]});
            }
        }
    }
    for (int i = 1; i <= n; i++)
        mind[i] = dis[i];
}

int main()
{
    int T = read();
    while (T--)
    {
        int lastans = 0;
        init(), n = read(), m = read();
        for (int i = 1; i <= m; i++)
        {
            u[i] = read(), v[i] = read(), l[i] = read(), a[i] = read();
            add_edge(u[i], v[i], l[i]), add_edge(v[i], u[i], l[i]);
        }
        dijkstra(1), rebuild(), kruskal();
        q = read(), k = read(), s = read();
        while (q--)
        {
            int v = (read() + k * lastans - 1) % n + 1, p = (read() + k * lastans) % (s + 1);
            lastans = mind[jump(v, p)], printf("%d\n", lastans);
        }
    }
    return 0;
}
```



---

## 作者：Sino_E (赞：2)

Kruskal重构树可以用于求解两点之间任意路径最大边的最小值。

就上面提到的这个问题来说，如果是离线的话，直接Kruskal做就行了。也是一个贪心的思想。

下面是引用自[这里](https://www.cnblogs.com/ZegWe/p/6243883.html)的Kruskal生成树构造法和性质。

> 我们按照kruskal求最小⽣成树的方式加边，但每次在加边时，新建⼀个节点，然后把两个联通块（其实是两棵⼆叉树）的根节点作为其左右儿⼦，把边权赋值给新建节点。那么我们可以发现这棵树有几个性质。
1. 是⼀棵⼆叉树；
2. 满⾜父节点的值⼤于等于儿⼦节点，是⼀个大顶堆，这是最关键的⼀点；
3. 原图上任意两点间路径最长边的最小值等于其lca的值；

当然如果是从大到小建的话，原理也一样。本题需要从大到小建，然后lca的意义就变成了路上最短边的最大值。也就是说u,v的这个值如果>T，则u,v联通。

则对于点权>T的子树，其中的叶子节点属于一个连通块（因为任意叶子节点的任意路径的最短边的最大值>T），而子树肯定不能与子树外的结点构成连通块（<=T）。

所以只需预处理出每个点到1的最短路值，再建Kruskal重构树预处理子树min值，查询时倍增即可。

代码仅供参考...
## Code
```cpp
// Code by ajcxsu
// Problem: return

#include<bits/stdc++.h>
#define CLR(x, y) memset(x, y, sizeof(x))
using namespace std;
typedef long long ll;

template<typename T> void gn(T &x) {
    char ch=getchar();
    x=0;
    while(ch<'0' || ch>'9') ch=getchar();
    while(ch>='0' && ch<='9') x=x*10+ch-'0', ch=getchar();
}

const int N=4e5+10, M=1e6+10;
int h[N], to[M], nexp[M], p=1;
ll W[M], f[N], nw[N];
inline void ins(int a, int b, ll w) { nexp[p]=h[a], h[a]=p, to[p]=b, W[p]=w, p++; }
struct Edge { int u, v; ll w; } e[M];
bool cmp(const Edge &a, const Edge &b) { return a.w>b.w; }
int n, m;
ll U;

ll dist[N];
bool S[N];
typedef pair<ll, int> mpair;
void SPFA() {
    CLR(dist, 0x3f), CLR(S, 0);
    priority_queue<mpair, vector<mpair>, greater<mpair> > pq;
    pq.push(mpair(0, 1));
    dist[1]=0;
    int na;
    for(int i=1;i<=n;i++) {
        while(S[pq.top().second] || pq.top().first>dist[pq.top().second]) pq.pop();
        na=pq.top().second, S[na]=1;
        for(int u=h[na];u;u=nexp[u])
            if(dist[to[u]]>dist[na]+W[u] && !S[to[u]])
                dist[to[u]]=dist[na]+W[u], pq.push(mpair(dist[to[u]], to[u]));
    }
}

int fa[N];
int Find(int x) { return fa[x]?fa[x]=Find(fa[x]):x; }

const int OP=22;
int gup[N][OP];
void dfs(int x) {
    for(int u=h[x];u;u=nexp[u])
        dfs(to[u]), f[x]=min(f[x], f[to[u]]), gup[to[u]][0]=x;
    if(x<=n) f[x]=dist[x];
}

int main() {
    int T;
    gn(T);
    while(T--) {
        CLR(h, 0), p=1;
        gn(n), gn(m);
        int u, v, w, a;
        for(int i=1;i<=m;i++)
            gn(u), gn(v), gn(w), gn(a),
            ins(u, v, w), ins(v, u, w),
            e[i]={u, v, a};
        sort(e+1, e+1+m, cmp);
        SPFA();
        int idx=n;
        CLR(h, 0), CLR(fa, 0), p=1;
        for(int i=1;i<=n;i++) W[i]=0;
        for(int i=1;i<=m;i++) {
            int af=Find(e[i].u), bf=Find(e[i].v);
            if(af==bf) continue;
            fa[af]=fa[bf]=++idx;
            ins(idx, af, 0), ins(idx, bf, 0);
            nw[idx]=e[i].w;
        }
        CLR(gup, 0), CLR(f, 0x3f);
        dfs(idx);
        for(int j=1;j<OP;j++)
            for(int i=1;i<=idx;i++)
                gup[i][j]=gup[gup[i][j-1]][j-1];
        ll Q,K,S;
        gn(Q), gn(K), gn(S);
        ll lastans=0;
        while(Q--) {
            gn(u), gn(U);
            u=(u+K*lastans-1)%n+1;
            U=(U+K*lastans)%(S+1);
            for(int j=OP-1;j>=0;j--)
                if(nw[gup[u][j]]>U) u=gup[u][j];
            printf("%lld\n", lastans=f[u]);
        }
    }
    return 0;
}
```

---

## 作者：zijinjun (赞：1)

# 题解：归程

标签（空格分隔）： 题解 NOI Kruskal重构树 可持久化 

---

我们可以把从v到1的路径分成两部分，一半全开车，一半全走路

也就是说要枚举n个节点作为断点(假设当前断点为u)，这个断点是可行解与最优解当且仅当存：在一条从v到u的路径可以全部开车且从u到1全部走路的最短路是满足上一条件中最短的

从v出发开车可以到的点， 一定满足路径上所有边海拔都高于水位

## Kruskal重构树:

这里已经很明显可以用Kruskal重构树求解了

我们把每条边按海拔降序排序，重构树完成后，对于每次询问，找到树中深度最小且海拔大于水位的节点，那么他的子树的全部节点都可以由v开车到达

这一点可以由重构树是小根堆的性质简单得证，即每个节点子树内所有节点海拔都比该节点大

现在要求的最后一步就是这个子树内所有节点到1号节点的步行最短路， 因为是无向图，所以一开始预处理1节点到所有节点最短路就好，然后dfs可以顺便求出某个节点子树内的最短路

--

$ps$：
这个题卡 $SPFA$ ~~CCF怎么能这样对我可爱的SPFA~~
所以必须打迪杰斯特拉

---

处理细节：

1. 莫名卡常（可能是我不优秀），对于一些数组不用清零的就别清了，比如倍增数组和最小值数组（删了HSYOJ就过了）
2. 克鲁斯卡尔重构树套路：清零!!!（数据不清空，爆零两行泪）

---

## 可持久化并查集

一定程度上，可持久化并查集的适用范围是大于克鲁斯卡尔重构树的，虽然在这里不是最优秀的做法，把$NlogN$的复杂度硬生生变成了$Nlog^2N$（卡卡常也是能过的），这里虽然不是正解，但也是一个好方案

#### 做法：
迪杰斯特拉预处理，然后可持久化并查集维护联通块（口胡完了）

#### 实现细节：
注意常数

---

## 代码：
（这里用的是Kruskal重构树）
```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <queue>
using namespace std;

#define ll long long
#define re register
#define gc getchar()
inline int read()
{
    re int x(0),f(1);re char ch(gc);
    while(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=gc;}
    while(ch>='0'&&ch<='9') x=(x*10)+(ch^48),ch=gc;
    return x*f;
}

const int N=8e5+10;
int h[N],cnt,n,m,f[N][22],tot;
ll val[N],_min[N],dis[N];

struct edge{int next,to;ll w;}e[N<<1];
void add(int u,int v,ll w){e[++cnt]=(edge){h[u],v,w},h[u]=cnt;} 
#define QXX(u) for(int i=h[u],v;v=e[i].to,i;i=e[i].next)

struct node{int u,v;ll h;}E[N<<1];
bool operator < (node a,node b){return a.h>b.h;}

struct Node{ll x;int id;};
bool operator < (Node a,Node b){return a.x<b.x;}
priority_queue <Node> q;
int vis[N];

int fa[N];
int find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}

void djs()
{
    memset(vis,0,sizeof(vis));
    memset(dis,127,sizeof(dis));
    q.push((Node){0,1});
    dis[1]=0;
    while(!q.empty())
    {
        Node t=q.top();q.pop();
        int u=t.id;
        if(vis[u]) continue;
        vis[u]=1;
        QXX(u)
            if(dis[u]+e[i].w<dis[v])
            {
                dis[v]=dis[u]+e[i].w;
                q.push((Node){-dis[v],v});
            }
        
    }
}
void dfs(int u)
{
    _min[u]=dis[u];
    QXX(u)
    {
        f[v][0]=u;
        dfs(v);
        _min[u]=min(_min[u],_min[v]);
    }
}
void kruskal()
{
    memset(h,0,sizeof(h));
    cnt=0;
    sort(E+1,E+1+m);
    for(int i=1;i<=n;++i) fa[i]=i;
    for(int i=1;i<=m;++i)
    {
        int u=find(E[i].u),v=find(E[i].v);
        if(u!=v)
        {
            val[++tot]=E[i].h;
            fa[u]=fa[v]=fa[tot]=tot;
            add(tot,u,0),add(tot,v,0);
        }
    }
    dfs(tot);
}
int main()
{
//	freopen("return.in","r",stdin);
    int T=read();
    while(T--)
    {
        memset(h,0,sizeof(h));
        memset(f,0,sizeof(f));
        memset(_min,127,sizeof(_min));
        n=read(),m=read(),cnt=0;tot=n;
        for(int i=1;i<=m;++i)
        {
            re int u=read(),v=read(),w=read(),h=read();
            add(u,v,w),add(v,u,w);
            E[i].u=u,E[i].v=v,E[i].h=h;
        }
        djs();
        kruskal();
        for(int i=1;(1<<i)<=tot;i++)
            for(int u=1;u<=tot;u++)
    		    f[u][i]=f[f[u][i-1]][i-1];
    	int Q=read(),K=read(),S=read();
        ll la=0;
        while(Q--) 
        {
            int vi=read(),pi=read();
            vi=(vi+K*la-1)%n+1;
            pi=(pi+K*la)%(S+1);
            for(int j=21;j>=0;--j)
                if(f[vi][j]&&val[f[vi][j]]>pi) 
    		        vi=f[vi][j];
    		la=_min[vi];
    		cout<<la<<endl;
        }
    }
    return 0;
}
```


---


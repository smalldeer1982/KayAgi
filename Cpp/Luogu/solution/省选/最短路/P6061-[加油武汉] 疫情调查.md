# [加油武汉] 疫情调查

## 题目描述

W 市爆发了严重的肺炎疫情。为了应对疫情，W 市需要对下属每一个社区进行巡回调查。

W市共有 $n$ 个街区，街区之间由 $m$ 条不相同的有向道路相连，没有任何一条道路是自己通向自己的，并且是保证弱联通的。通过每条道路需要消耗一定的燃油费用。

现在你需要派出一些工作人员来寻访每个街区。对于每个工作人员，你需要给他分派一些街区，之后工作人员会按照给定的顺序在这些街区反复循环，每周循环一次。请注意，工作人员只会检查你给他分配的街区，在分配的街区之间经过的街区，工作人员并不会下车。同时为了防止人员浪费，任何一个街区只能接受一位工作人员的检查。当然，如果必要，他也会经过重复的街区。

工作人员的花费是这样的：若是某个工作人员只分配到了一个街区 $u$，那么他需要每周消耗 $a_u$ 的停留费用。若是被分配到了多于一个的街区，那么他的花费就是环绕这些点一圈最后回到起点的道路燃油费用之和。

现在你需要知道，在工作人员数量无限的情况下，每周最少需要多少费用可以将整个 W 市完全巡查。

## 说明/提示

对于所有的数据 $1\leq n\leq 500,1\leq m\leq \min\{5000,n\times(n-1)\},0\leq a_i,w_i\leq 10^9$，保证图弱连通，无自环、无重边。

对于不同的测试点，我们有如下约束：

| 测试点编号 | $n\leq$ | $m\leq$ | 特殊性质 |
| :-: | :-: | :-: | :-: |
| $1\sim 6$ | $15$ | $100$ | $\times$ |
| $7\sim 10$ | $500$ | $5000$ | 对于所有的 $w_i=0$ |
| $11\sim 14$ | $500$ | $500$ | $n=m$ 且所有的节点出度为 $1$ |
| $15\sim 20$ | $500$ | $5000$ | $\times$ |

## 样例 #1

### 输入

```
3 3
30 25 30
1 2 3
2 3 5
3 1 10```

### 输出

```
18```

# 题解

## 作者：绝顶我为峰 (赞：23)

update1:感谢 @[linfourxu](https://www.luogu.com.cn/user/50477) 指出文章错误，已经更正。

update2:上次修改不完全，仍有残余错误。

给一个有向图，求用若干个环（或点）将整张图覆盖的最小花费。

求最小覆盖，想到带权二分图匹配问题，可以用费用流一波带走。

我们发现 $n\leq 500$ 其实很小，足够我们跑一遍 Floyd 求出覆盖两个点的最小花费。然后我们将每一个点拆成两个点 $(u,u')$ ，建立超级源超级汇 $s,t$ 进行如下建模：

- 从 $s$ 向 $u$ 连一条流量为 $1$，费用为 $0$ 的边；

- 从 $u'$ 向 $t$ 连一条流量为 $1$，费用为 $0$ 的边；

- 对于每一个点 $u$，从 $u$ 向 $u'$ 连一条流量为 $\inf$ ，费用为 $a_u$ 的边；

- 对于点对 $(u,v)$，如果从 $u$ 可以到达 $v$，就从 $u$ 向 $v'$ 连一条流量为 $1$，费用为 $dis_{i\rightarrow j}$ 的边。

我们发现这张图一定存在完美匹配，那么就跑一遍最小费用最大流就可以拿到 70pts。

为什么会超时呢？因为跑一遍 Floyd 会使 $m$ 达到 $O(n^2)$，显然无法承受。

我们考虑减少边的数量，由于最短路是由若干条路径拼成的，我们可以只在网络流建模中连接数据给出的边，同时从 $u'$ 向 $u$ 连一条流量为 $\inf$，费用为 $0$ 的边（这应该是标准套路了）。这样我们可以顺着这些边走出一条最短路径，而且边的数量减少到 $O(m+n)$，可以通过本题。

```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
#include<ext/pb_ds/priority_queue.hpp>
using namespace std;
using namespace __gnu_pbds;
#define int unsigned long long
struct edge
{
	int nxt,to,weight,value;
}e[1000001<<1];
int n,m,tot=1,h[10005],dep[10005],cur[10005],s,t,a[5001],cost,ans,hg[10005];
bool vis[10005];
inline int read()
{
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-')
			f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')
	{
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return x*f;
}
inline void add(int x,int y,int w,int val)
{
	e[++tot].nxt=h[x];
	h[x]=tot;
	e[tot].to=y;
	e[tot].weight=w;
	e[tot].value=val;
}
inline bool Dijkstra()
{
	for(register int i=0;i<=t;++i)
	{
		vis[i]=0;
		dep[i]=0x3f3f3f3f;
		cur[i]=h[i];
	}
	__gnu_pbds::priority_queue<pair<int,int>,greater<pair<int,int> >,pairing_heap_tag> q;
	q.push(make_pair(0,t));
	dep[t]=0;
	while(!q.empty())
	{
		pair<int,int> k=q.top();
		q.pop();
		if(vis[k.second])
			continue;
		vis[k.second]=1;
		for(register int i=h[k.second];i;i=e[i].nxt)
			if(e[i^1].weight&&dep[e[i].to]>dep[k.second]-e[i].value+hg[k.second]-hg[e[i].to])
			{
				dep[e[i].to]=dep[k.second]-e[i].value+hg[k.second]-hg[e[i].to];
				q.push(make_pair(dep[e[i].to],e[i].to));
			}
	}
	return dep[0]!=dep[s];
}
int dfs(int k,int f)
{
	int r=0;
	if(!f||k==t)
	{
		vis[t]=1;
		ans+=f;
		return f;
	}
	int used=0;
	vis[k]=1;
	for(register int i=cur[k];i;i=e[i].nxt)
	{
		cur[k]=i;
		if((!vis[e[i].to]||e[i].to==t)&&dep[e[i].to]==dep[k]-e[i].value+hg[k]-hg[e[i].to]&&e[i].weight)
			if((r=dfs(e[i].to,min(f-used,e[i].weight))))
			{
				cost+=e[i].value*r;
				e[i].weight-=r;
				e[i^1].weight+=r;
				used+=r;
				if(f==used)
				{
					//vis[k]=0;
					break;
				}
			}
	}
	return used;
}
inline int dinic()
{
	while(Dijkstra())
	{
		vis[t]=1;
		while(vis[t])
		{
			memset(vis,0,sizeof(vis));
			dfs(s,1<<20);
		}
		memset(vis,0,sizeof(vis));
		for(register int i=0;i<=t;++i)
			hg[i]+=dep[i];
	}
	return cost;
}
signed main()
{
	n=read(),m=read();
	s=n<<1|1;
	t=s+1;
	for(register int i=1;i<=n;++i)
	{
		a[i]=read();
		add(s,i,1,0);
		add(i,s,0,0);
		add(i+n,t,1,0);
		add(t,i+n,0,0);
		add(i,i+n,1<<20,a[i]);
		add(i+n,i,0,-a[i]);
		add(i+n,i,1<<20,0);
		add(i,i+n,0,0);
	}
	for(register int i=1;i<=m;++i)
	{
		int x=read(),y=read(),w=read();
		add(x,y+n,1<<20,w);
		add(y+n,x,0,-w);
	}
	printf("%lld\n",dinic());
	return 0;
}

```

---

## 作者：zcysky (赞：16)

下面是官方题解。

题意简述：用环来覆盖一张图的最小代价。

## 第一档部分分

$30 \%$ 暴力的去枚举所有可能的覆盖方案。

所有 $w_i=0$ :用点覆盖需要支付点权的代价，而环覆盖没有代价。用类似贪心的思想，尽可能多的用环去覆盖节点即可。

## 第二档部分分

$n=m$ ,所有点出度为 $1$ :整张图是一个巨大的环，那么只有两种可能：全部使用点覆盖/用一个大环覆盖。判断下即可。

## 正解

我们发现 $n$ 其实非常小，这个复杂度允许我们先进行一次floyed预处理，直接求出点对之间的最短路

然后我们回到问题本身，我们希望求得的方案是把图中所有节点全部覆盖，并且代价最小，这跟二分图的完美匹配很接近。

所以我们建造这样一个辅助图，两边都有 $n$ 个节点，对于原图中的点对 $u,v$ ，在左边的 $u$ 向右边的 $v$ 连一条边权为 $dis[u][v]$
的边。之后再把每一个左边的 $u$ 向右边的 $u$ 连接一条边权为 $a[u]$ 的 边。

我们发现这张图一定存在完美匹配，那么进一步的，我们求出最小代价的完美匹配就是答案。

接下来就是标准套路，采用KM算法或者费用流都可以解决，但是费用流在本题实际表现不如KM。

---

## 作者：junble19768 (赞：12)

~~为啥要跑$floyd$啊,为啥要卡常啊,啥是点覆盖啊,是我太菜了吗?~~

每个点都要经过,要么凑成环要么单点算费用

啊这,这不是上下界无源汇最小费用流吗???

~~什么你不会上下界无源汇最小费用流,与我何干~~

每个点拆成$(i,i')$

对于每个点$i \rightarrow i' (1,inf)\ cost=0$ 表示必须经过$ ｉ$点１次; $i'\rightarrow i(0,1)cost=a_i$  表示这个点可以选择单点算费用



对于每条边$(u,v)$  $u'\rightarrow v (0,inf)cost=d_{u,v}$ 

因为是无源汇,每个点的流量守恒,也就是说,每一个流量都是从点$x$流出,又流回了$x$

然后建图的时候直接按照上下界建图就行

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cstdio>
#include <queue>
#define maxn 500100
#define inf 0x7fffffff
#define ll long long
using namespace std;
namespace EK
{
    struct node { int v,nex,flow;ll cost; }p[maxn<<2];
    int fir[maxn],tot=1;
    inline void add(int fr,int to,int fl,int co)
    {
        p[++tot]=(node) { to,fir[fr],fl,co }; fir[fr]=tot;
        p[++tot]=(node) { fr,fir[to],0,-co }; fir[to]=tot;
    }
    ll d[maxn];
    int flow[maxn],pre[maxn],lat[maxn],book[maxn];
    bool bfs(int fr,int to)
    {
        memset(d,127,sizeof d); 
        memset(flow,127,sizeof flow);
        memset(book,0,sizeof book);
        queue<int> que; que.push(fr);
        d[fr]=0; book[fr]=1; lat[to]=-1;
        while(!que.empty())
        {
            int u=que.front(); que.pop(); book[u]=0;
            for(register int i=fir[u];i;i=p[i].nex)
            {
                int v=p[i].v; if(!p[i].flow) continue;
                if(d[v]>d[u]+p[i].cost)
                {
                    d[v]=d[u]+p[i].cost;
                    pre[v]=i;
                    lat[v]=u;
                    flow[v]=min(flow[u],p[i].flow);
                    if(!book[v])
                    {
                        book[v]=1; que.push(v);
                    }
                }
            }
        }
        return lat[to]!=-1;
    }
    inline ll MCMF(int fr,int to)
    {
        ll ans=0;
        while(bfs(fr,to))
        {
            ans+=d[to]*flow[to];
            int now=to;
            while(now!=fr)
            {
                p[pre[now]].flow-=flow[to];
                p[pre[now]^1].flow+=flow[to];
                now=lat[now];
            }
        }
        return ans;
    }
}
int n,m;
int s,t;
int main()
{
    scanf("%d %d",&n,&m); s=n*2+1,t=s+1;
    for(register int i=1,x;i<=n;i++)
    {
        scanf("%d",&x);
        EK::add(i+n,i,1,x); EK::add(i,i+n,inf,0);
        EK::add(s,i+n,1,0); EK::add(i,t,1,0);
    }
    for(register int i=1;i<=m;i++)
    {
        int x,y,d; scanf("%d %d %d",&x,&y,&d);
        EK::add(x+n,y,inf,d);
    }
    printf("%lld",EK::MCMF(s,t));
    return 0;
}
```


---

## 作者：功在不舍 (赞：10)

我来讲一下这个题的思路吧。

题目要求我们用点或者环（环的点和边可以重复走）将一张有向图覆盖，并且其权值最小。

一看数据范围N<=500 又是一个覆盖问题，自然能想到费用流来解决。

做过最小路径覆盖的同学，应该知道有个拆点的小技巧。

首先，像最小路径覆盖一样，由于我们可以分别把每个点都覆盖，因此本题一定有解，并且答案不会大于所有的点权和。而且被单独选中的点，不能再次被选中或者被选入某个环中（题干要求），因此我们把i号点拆成两个点i和点i+n，并且由i向i+n建一条流量为1，费用为i点点权的边。同时，我们建立s和t，由s向1，2，3……n 号点建立一条流量为1，费用为0的边，由n+1,n+2, ……2n向t号点建立一条流量为1，费用为0的边（流量为1是因为一个点只能被1位检查人员检查）。

接着，我们来处理环的情况。主要的难点在于，我们不允许用**不是环的路径来覆盖图**。这是个有向图，其实就是要求不能有跨越两个强连通分量的路径出现。

但是想在网络流图中禁止这种路径出现是做不到的，我们只能通过构造让这种路径一定达不到最大流从而被舍弃。对于具体如何“舍弃”，我们有两种手段来解决。

第一种：很明显，我们希望走的路程越短越好，那就用最短路长度来建边好了。多源最短路径当然用Floyd来求。之后若点i能到达点j，则从i号点向j+n号点建立一条费用为dis[i][j]，流量为1的边。之后跑最小费用最大流就好了。

为什么这样就可以“舍弃”不合法的路径？我们假设i号点所在的强连通分量为点集G，若i号点匹配了G以外的一个点x+n，则单独依靠G内的点无法把i+n号点这个空位补上，必须要有G外的点匹配到点i+n。若G外的点k能到达i+n号点（点k当然不能是点x，要不然点x就在G中了），则G中所有的点都不能到达k号点，无法与k+n号点匹配，否则K点也在G中。所以如果点k匹配了i+n号点，则造成k+n号点的空缺，而G中所有点都不可能匹配k+n号点，所以只能用G外的点匹配k+n号点。还记得开始被匹配的x+n号点吗？它导致点x被空出，同理点x不能匹配G中点，否则点x也在G中。所以如果不用点x（这类点）去匹配点k+n（这类点），则网络流图中G以外的部分无法达到满流，而用点x（这类点）去匹配k+n（这类点）又说明点x能到达点k，那点k和点x不就都在G中了吗？当然不成立！所以这样可以自动舍弃不合法的路径。

~~这只是口胡的说明，仅供参考~~

很遗憾，这种算法会TLE，只能得到70分。

原因由两个：
1. Floyd 500^3=1.25亿 洛谷IDE实测750ms左右，于是我们只剩下了最多300ms给其他部分。

2. 如果整张图都强连通，网络流图中的边数m会达到n^2的量级，费用流当场爆炸。

下面来讲第二种：上面一种没有在图中构建环，而是用最短路径达到了目的，这次我们在网络流图中构建环，让网络流的贪心发挥最短路的作用。如果原图中由一条由点x到点y的路程为z的路径，那么由点x向点y+n建立费用为z，流量为inf的边（注意流量是INF，因为环内的路径可以重复走的，“同一人”的限制在S发出的边上而不是在这里）。接着，从每一个点i+n向点i建立费用为1，流量为INF的边（道理同上）。

这样，原图中的强连通分量就对应到了新图中的强连通分量。它能“舍弃”不合法路径的原理和第一种方法是一样的，如果点i匹配到了它强连通分量外的点，那么一定无法达到最大流。

这个方法边数只有m+n条这个量级，而且避免了求最短路，机智地用网络流的贪心代替了最短路，速度当然快。

这个题其实没有卡SPFA，SPFA跑的飞快。我的SPFA加了LLL和SLF优化，不过没啥大用这个题只能快一点点（但是模板题可以快很多）。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
long long n,m,s,t,cnt,yes,head[100001],sum,costsum,map[501][501];
struct bian{
	long long to;
	long long flow;
	long long cost;
	long long next;
}edge[8000001];
void addedge(long long u,long long v,long long cost,long long flow)
{
	edge[++cnt].to=v;
	edge[cnt].cost=cost;
	edge[cnt].flow=flow;
	edge[cnt].next=head[u];
	head[u]=cnt;
}
long long inf=1e18,dis[100001];
long long inqueue[100001],cur[100001],vis[100001];
bool SPFA()
{
    for(int i=0;i<=2*n+2;i++)
    {
        vis[i]=0;
        cur[i]=head[i];
        dis[i]=inf;
    }
    deque <int> q;
    dis[s]=0;inqueue[s]=1;
    q.push_back(s);long long len=1,sum1=0;
    while(!q.empty())
    {
        int from=q.front();
        q.pop_front();
        if(dis[from]*len>sum1)
        {
        	q.push_back(from);
        	continue;
        }
        sum1-=dis[from];len--;
        for(int i=head[from];i!=0;i=edge[i].next)
        {
            int to=edge[i].to,cost=edge[i].cost;
            if(dis[from]+cost<dis[to]&&edge[i].flow)
            {
                dis[to]=dis[from]+cost;
                if(inqueue[to]==0)
                {
                    if(!q.empty()&&dis[to]<dis[q.front()])q.push_front(to);
                    else q.push_back(to);
                    inqueue[to]=1;
                    len++;sum1+=dis[to];
                }
            }
        }
        inqueue[from]=0;
    }
    return dis[t]!=inf;
} 
long long dfs(long long now,long long low)
{
	vis[now]=1;
	if(now==t)
	{
		yes=1;
		sum+=low;
		costsum+=low*dis[t];
		return low;
	}
	long long used=0,rlow=0;
	for(long long i=cur[now];i!=0;i=edge[i].next)
	{
		cur[now]=i;
		long long to=edge[i].to,cost=edge[i].cost;
		if(dis[now]+cost==dis[to]&&edge[i].flow&&(!vis[to]||to==t))
		{
			if(rlow=dfs(to,min(low-used,edge[i].flow)))
			{
				used+=rlow;
				edge[i].flow-=rlow;
				if(i%2==1)edge[i+1].flow+=rlow;
				else edge[i-1].flow+=rlow;
				if(used==low)break;
			}
		}
	}
	return used;
}
int main()
{
	scanf("%lld%lld",&n,&m);
	s=2*n+1;t=2*n+2;
	for(long long i=1;i<=n;i++)
	{
		long long x;
		scanf("%lld",&x);
		addedge(i,i+n,x,1);
		addedge(i+n,i,-x,0);
		addedge(i+n,i,0,inf);
		addedge(i,i+n,0,0);
		addedge(s,i,0,1);
		addedge(i,s,0,0);
		addedge(i+n,t,0,1);
		addedge(t,i+n,0,0);
	}
	for(long long i=1;i<=m;i++)
	{
		long long x,y,z;
		scanf("%lld%lld%lld",&x,&y,&z);
		addedge(x,y+n,z,inf);
		addedge(y+n,x,-z,0);
	}
	while(SPFA())
	{
		yes=1;
		while(yes)
		{
			yes=0;
			dfs(s,inf);
		}
	}
	cout<<costsum<<endl;
	return 0;
}

```




---

## 作者：Nangu (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P6061)
## 题意
- 给定一个无向图，在费用最小的情况下用环覆盖所有点。
- 不同的环之间不能有交点，但同一个环可以多次一点。

## 题解

我们考虑这样一幅图：

![](https://cdn.luogu.com.cn/upload/image_hosting/9hki29lf.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

我们显然不能走 $1-2-3-1$ 和 $1-4-5-1$ 两个环，因为这两个环之间存在交点。但 $1-2-3-1-4-5-1$ 这种走法可行，因为一环可以多次经过过同一点。而这两种走法本质上是一致的。也就是说，**我们不需要考虑环之间有无交点，只要任意一点都在至少一个环中就可以了**。

如何判断一个点是否在环上？显然，**仅当所有点的出度和入度都大于等于 $1$ 时，所有点都会在环上**。我们考虑反证法：若一点出度为 $0$，则这一点不能走到任意一点；若一点入度为 $0$，则任何一点都无法到达这一点。这两种情况都不满足环的性质。

接下来就好做啦。将原图的每一点拆成两点，记为 $u_1$ 和 $u_2$，$u_1$ 代表出度，$u_2$ 代表入度。
- $s$ 向 $u_1$ 连一条流量为 $1$，费用为 $0$ 的边。
- $u_2$ 向 $t$ 连一条流量为 $1$，费用为 $0$ 的边。
- $u_1$ 向 $u_2$ 连一条流量为 $INF$, 费用为 $a_u$ 的边。
- $u_2$ 向 $u_1$ 连一条流量为 $INF$，费用为 $0$ 的边。
- 对于原图中的边 $u,v,w$，$u_1$ 向 $v_2$ 连一条流量为 $INF$，费用为 $w$ 的边。
- 跑费用流。

## Code:

```cpp
#include <bits/stdc++.h>

#define F(i, j, k) for(int i=(j), ENDD=(k); i<=ENDD; ++i)
#define R(i, j, k) for(int i=(j), ENDD=(k); i>=ENDD; --i)
#define int long long

using namespace std;

const int E=5e6, INF=1e18, N=600;

struct edge{
	int v, w, c, nxt;
}e[E];

int head[N<<1], pre[N<<1], cur[N<<1], dis[N<<1], flow[N<<1], cost, cnt=1, s, t;
bool vis[N<<1];

void init(int u, int v, int w, int c){
	e[++cnt]={v, w, c, head[u]}, head[u]=cnt;
	e[++cnt]={u, 0, -c, head[v]}, head[v]=cnt;
}

bool spfa(){
	memset(dis, 0x3f, sizeof dis), memset(flow, 0, sizeof flow), memcpy(cur, head, sizeof head);
	queue<int> q; q.push(s), flow[s]=INF, dis[s]=0;
	while(!q.empty()){
		int u=q.front(), v; q.pop(), vis[u]=0;
		for(int i=head[u]; i; i=e[i].nxt)
			if(dis[v=e[i].v]>dis[u]+e[i].c && e[i].w){
				dis[v]=dis[u]+e[i].c, flow[v]=min(e[i].w, flow[u]), pre[v]=i;
				if(!vis[v]) vis[v]=1, q.push(v);
			}
	}
	if(!flow[t]) return 0;
	cost+=flow[t]*dis[t];
	int u=t;
	while(u!=s){
		int id=pre[u];
		e[id].w-=flow[t], e[id^1].w+=flow[t];
		u=e[id^1].v;
	}
	return 1;
}

int n, m;

signed main()
{
	cin.tie(0)->sync_with_stdio(0), cin.tie(0);
	cin>>n>>m, t=n*2+10;
	F(i, 1, n){
		int a;
		cin>>a;
		init(i+n, i, INF, 0);
		init(i, i+n, INF, a);
		init(s, i, 1, 0), init(i+n, t, 1, 0);
	}
	F(i, 1, m){
		int u, v, w;
		cin>>u>>v>>w;
		init(u, v+n, INF, w);
	}
	while(spfa());
	cout<<cost;
 	return 0;
}

---

## 作者：Mortis_Vampire (赞：2)

## Part 1:思路
简述一下这道题的做法：

首先 Floyed 预处理出任意一个节点到另外其他节点的最小费用。

建立一个二分图，左部 $n$ 个节点表示 $n$ 个街区，与右部 $n$ 个节点的 $n$ 个街区连边，边权为最小费用（若不可到达设边权为 -INF）。同时，左部节点 $i$ 与右部节点 $i$ 连边，边权为 $a_i$ ，因此这张二分图一定存在完备匹配，满足 KM 算法的使用条件。

然后直接跑 KM 就行了，不得不说出题人设置得挺巧妙的。

~~还有一件事，不开 long long 见祖宗~~
## Part 2：Code
```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#define inf 0x7fffffff
#define int long long
using namespace std;
int n,m,a[505],w[505][505];
int va[505],vb[505];//访问标记
int la[505],lb[505];//顶标
int match[505],upd[505];//匹配点、更新
bool dfs(int x) {//匈牙利
	va[x]=1;
	for(int y=1; y<=n; y++)
    if(w[x][y]!=-inf){
        if(!vb[y])
			if(la[x]+lb[y]==w[x][y]) {
				vb[y]=1;
				if(!match[y]||dfs(match[y])) {
					match[y]=x;
					return true;
				}
			} else upd[y]=min(upd[y],la[x]+lb[y]-w[x][y]);
    }
		
	return false;
}
int KM() {//KM板子
	memset(match,0,sizeof(match));
	for(int i=1; i<=n; i++) {
		la[i]=-inf;
		lb[i]=0;
		for(int j=1; j<=n; j++)
			la[i]=max(la[i],w[i][j]);
	}
	for(int i=1; i<=n; i++)
		while(true) {
			memset(va,0,sizeof(va));
			memset(vb,0,sizeof(vb));
			for(int j=1; j<=n; j++)upd[j]=inf;
			if(dfs(i))break;
			int delta=inf;
			for(int j=1; j<=n; j++)
				if(!vb[j])delta=min(delta,upd[j]);
			for(int j=1; j<=n; j++) {
				if(va[j])la[j]-=delta;
				if(vb[j])lb[j]+=delta;
			}
		}
	int ans=0;
	for(int i=1; i<=n; i++)
		ans+=w[match[i]][i];
	return ans;
}
signed main()
{
    scanf("%lld%lld",&n,&m);
    for(int i=1;i<=n;i++)
    scanf("%lld",&a[i]);
    for(int i=1;i<=n;i++)//赋初值
        for(int j=1;j<=n;j++)
        w[i][j]=inf;
    for(int i=1;i<=m;i++)
    {
        int x,y,z;
        scanf("%lld%lld%lld",&x,&y,&z);
        w[x][y]=z;
    }
    for(int k=1;k<=n;k++)//Floyed
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
            if(w[i][k]!=inf&&w[k][j]!=inf)
                if(w[i][j]>w[i][k]+w[k][j])
                    w[i][j]=w[i][k]+w[k][j];
    for(int i=1;i<=n;i++)
    w[i][i]=a[i];
    for(int i=1;i<=n;i++)//求二分图带权最小匹配只需要给边权取反
        for(int j=1;j<=n;j++)
        w[i][j]*=-1;
    printf("%lld",-KM());
    return 0;
}
```


---

## 作者：清平乐 (赞：2)

## ~~看题面来势汹汹，其实就是个最小环覆盖~~
### 言归正传

这个题首先要求全源最短路（可以用伪Johnson--反正没有负权边），然后重新把求出来的二维最短距离数组当作新图跑最小环覆盖，这里可以跑网络流，但是，我太菜了，只会把边权取反跑KM最佳匹配

这个题略微卡常，注意常数（跑二分图匹配的时候不要去每次都memset（vx,vy），这样太慢，赋个时间戳就好了，具体实现见代码吧）

最后要提醒一句

# 十年竞赛一场空，不打longlong见祖宗
```cpp
#include<stdio.h>//在某些编译器下，这个可以把scanf加速到比快读还快
#include<bits/stdc++.h>
#define max(a,b) (a)>(b)?(a):(b)
#define min(a,b) (a)<(b)?(a):(b)
#define int long long//懒
using namespace std;

const int INF=1e9,N=505,M=5005;
int n,m,u,v,w,k;
int a[N],head[N],d[N][N],lx[N],ly[N],link[N],slack[N],vx[N],vy[N];
bool visit[N];
struct edge{int v,w,next;}e[M];

inline void add(int u,int v,int w)
{
	e[++k]=(edge){v,w,head[u]};
	head[u]=k;
}
inline void Dijkstra(int *d,int s)
{
	typedef pair<int,int> pii;
	priority_queue<pii,vector<pii>,greater<pii> > q;
	memset(visit,0,sizeof(visit));
	q.push(make_pair(d[s]=0,s));
	visit[s]=true;
	while(!q.empty())
	{
		register int u=q.top().second;
		q.pop();
		for(register int i=head[u];i;i=e[i].next)
			if(d[e[i].v]>d[u]+e[i].w)
			{
				d[e[i].v]=d[u]+e[i].w;
				if(visit[e[i].v]) continue;
				visit[e[i].v]=true;
				q.push(make_pair(d[e[i].v],e[i].v));
			}
	}
}

inline void Johnson()
{
	for(register int i=1;i<=n;++i)
		for(register int j=1;j<=n;++j)
			d[i][j]=INF;
	for(register int i=1;i<=n;++i)
		Dijkstra(d[i],i);
	for(register int i=1;i<=n;++i)
		d[i][i]=a[i]; 
	for(register int i=1;i<=n;++i)
		for(register int j=1;j<=n;++j)
			d[i][j]=-d[i][j];
}

inline bool Hungary(int u,int id)
{
	vx[u]=id;
	for(register int i=1;i<=n;++i)
	{
		if(vy[i]==id||d[u][i]==-INF) continue;
		register int temp=lx[u]+ly[i]-d[u][i];
		if(!temp)
		{
			vy[i]=id;
			if(!link[i]||Hungary(link[i],id))
			{
				link[i]=u;
				return true;
			}
		}
		else slack[i]=min(slack[i],temp);
	}
	return false;
}

inline void update(int id)
{
	register int change=INF;
	for(register int i=1;i<=n;++i)
		if(vy[i]!=id) change=min(change,slack[i]);
	for(register int i=1;i<=n;++i)
	{
		if(vx[i]==id) lx[i]-=change;
		if(vy[i]==id) ly[i]+=change;
		else slack[i]-=change;
	}
}

inline int KM()
{
	memset(lx,128,sizeof(lx));
	register int ans=0,dfn=0;//dfn就是时间戳
	for(register int i=1;i<=n;++i)
		for(register int j=1;j<=n;++j)
			lx[i]=max(lx[i],d[i][j]);
	for(register int i=1;i<=n;++i)
	{
		memset(slack,0x3f,sizeof(slack));
		while(true)
			if(Hungary(i,++dfn)) break;
			else update(dfn);
	}
	for(register int i=1;i<=n;++i)
		if(link[i]) ans-=d[link[i]][i];
	return ans;
}

signed main(void)
{
	scanf("%lld%lld",&n,&m);
	for(register int i=1;i<=n;++i)
		scanf("%lld",a+i);
	for(register int i=1;i<=m;++i)
	{
		scanf("%lld%lld%lld",&u,&v,&w);
		add(u,v,w);
	}
	Johnson();
	printf("%lld\n",KM());
	return 0;
}
```
码风丑陋请见谅，
不开O2 1.40s，常数还行（主要是开了也没变化，我太菜了）

---

## 作者：detect (赞：1)

### [题目传送门](https://www.luogu.com.cn/problem/P6061)

题意：最小环覆盖。

因为一条边链接两个点。

所以我们把一个点拆成两个点。

然后发现如果从源点连流量为1的边到入点，再从出点连流量为1的边到汇点，最大流的形态一定把整个图分成了几个环形联通块，满足题意构造要求。（这种逆向思维是有点不对劲，但是我太菜了，正向讲不清楚）

现在要解决的是点与点之前费用的问题，一种略显暴力的做法是用弗洛伊德跑出多元最短路。然后直接连最短路距离的费用。正确性显然没问题，但是$n^2$级别的边数费用流跑不动。(但是可以取得70pts的高分

现在的情况是只要把边数压下来，什么都好说。

不如让费用流自行跑出最短路？

这个想法不错，把每个点的出点连一条流量无限，费用为0的边，这样找寻最短路的过程就交给费用流自行实现。（同时不破坏入点出点构成环形联通块的性质）

这样一来边数减少至$N$级别，可以用费用流解决问题。

code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
inline int getint(){
	int summ=0,f=1;char ch;
	for(ch=getchar();!isdigit(ch)&&ch!='-';ch=getchar());
	if(ch=='-')f=-1,ch=getchar();
	for(;isdigit(ch);ch=getchar()) summ=(summ<<3)+(summ<<1)+ch-48;
	return summ*f;
}
const int M=40000;
int n,m,etot=1,nex[M],go[M],head[M],w[M],val[M],S,T;
int a[M];
inline void Addedge(int u,int v,int wi,int vi){
	nex[++etot]=head[u];head[u]=etot;w[etot]=wi;val[etot]=vi;go[etot]=v;
	swap(u,v);
	nex[++etot]=head[u];head[u]=etot;w[etot]=0;val[etot]=-vi;go[etot]=v;
}
int vis[M],las[M],fa[M],dis[M],flow[M];
inline bool spfa(){
	memset(dis,0x7f,sizeof(dis));
	memset(flow,0x7f,sizeof(flow));
	memset(vis,0,sizeof(vis));
	queue <int> q;q.push(S);dis[S]=0;
	while(!q.empty()){
		int u=q.front();q.pop();vis[u]=0;
		for(int i=head[u];i;i=nex[i]){
			int v=go[i];
			if(w[i]&&dis[v]>dis[u]+val[i]){
				flow[v]=min(flow[u],w[i]);
				dis[v]=dis[u]+val[i];
				las[v]=i;fa[v]=u;
				if(!vis[v]){
					q.push(v);vis[v]=1;
				}
			}
		}
	}
	return dis[T]!=dis[0];
}
signed main(){
	cin>>n>>m;S=n+n+1,T=S+1;
	for(int i=1;i<=n;i++){
		Addedge(S,i,1,0);Addedge(i+n,T,1,0);Addedge(i+n,i,1e9,0);
	}
	for(int i=1;i<=n;i++){
		a[i]=getint();Addedge(i,i+n,1,a[i]);
	}
	for(int i=1,u,v,val;i<=m;i++){
		u=getint();v=getint();val=getint();
		Addedge(u,v+n,1e9,val);
	}
	int mincost=0;
	while(spfa()){
		mincost+=flow[T]*dis[T];
		int now=T;
		while(now!=S){
			w[las[now]]-=flow[T];
			w[las[now]^1]+=flow[T];
			now=fa[now];
		}
	}
	cout<<mincost<<endl;
	return 0;
}
```







---

## 作者：Genius_Star (赞：0)

### 题意：

用点或环覆盖整个图，求最小代价。

### 思路：

先用 Floyd 求出 $W_{i,j}$ 表示 $i \to j$ 的最短路。

我们需要使得任意一点都在至少一个环中，注意到仅当所有点的出度和入度都大于等于 $1$ 时，所有点都会在环上。

那么考虑拆点，将 $i$ 拆为 $(i,i+n)$；对于 $i \to j+n$ 的边权为 $W_{i,j}$；对于 $i \to i+n$ 的边权为 $a_i$。

那么就相当于求二分图最小权完美匹配，将边权转为负数，然后跑 KM 即可。

时间复杂度为 $O(N^3)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define full(l,r,x) for(auto it=l;it!=r;it++) (*it)=x
using namespace std;
typedef long long ll;
typedef double db;
const ll N=505,INF=1e18;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
ll n,m,x,y,z,ans;
ll A[N],a[N],lx[N],ly[N],fa[N],s[N];
ll W[N][N];
bool f[N];
void bfs(ll h){
	ll x=0,u=0,id=0,t;
	a[x]=h;
	while(a[x]){
		f[x]=1;
		u=a[x];
		t=INF;
		for(int v=1;v<=n;v++){
			if(f[v])
			  continue;
			if(s[v]>lx[u]+ly[v]-W[u][v]){
				s[v]=lx[u]+ly[v]-W[u][v];
				fa[v]=x;
			}
			if(s[v]<t){
				t=s[v];
				id=v;
			}
		}
		for(int i=0;i<=n;i++){
			if(f[i]){
				lx[a[i]]-=t;
				ly[i]+=t;
			}
			else
			  s[i]-=t;
		}
		x=id;
	}
	while(x){
		a[x]=a[fa[x]];
		x=fa[x];
	}
}
void KM(){
	ans=0;
	full(lx+1,lx+n+1,0);
	full(ly+1,ly+n+1,0);
	full(a+1,a+n+1,0);
	for(int i=1;i<=n;i++){
		full(f+1,f+n+1,0);
		full(fa+1,fa+n+1,0);
		full(s+1,s+n+1,INF);
		bfs(i);
	}
	for(int i=1;i<=n;i++)
	  ans+=W[a[i]][i];
}
int main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++){
		full(W[i]+1,W[i]+n+1,INF);
	    A[i]=read();
	}
	while(m--){
		x=read(),y=read(),z=read();
		W[x][y]=z;
	}
    for(int k=1;k<=n;k++)
      for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
          if(W[i][k]!=INF&&W[k][j]!=INF)
            if(W[i][j]>W[i][k]+W[k][j])
              W[i][j]=W[i][k]+W[k][j];
    for(int i=1;i<=n;i++)
      W[i][i]=A[i];
    for(int i=1;i<=n;i++)
      for(int j=1;j<=n;j++)
	    W[i][j]*=-1; 
	KM();
	write(-ans);
	return 0;
}
```

---


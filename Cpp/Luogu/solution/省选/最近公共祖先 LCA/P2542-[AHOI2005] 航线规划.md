# [AHOI2005] 航线规划

## 题目描述

对 Samuel 星球的探险已经取得了非常巨大的成就，于是科学家们将目光投向了 Samuel 星球所在的星系——一个巨大的由千百万星球构成的 Samuel 星系。

星际空间站的 Samuel II 巨型计算机经过长期探测，已经锁定了 Samuel 星系中 $n$ 个星球的空间坐标，并对这些星球以 $1$ 至 $n$ 依次编号。

一些先遣飞船已经出发，在星球之间开辟探险航线。

探险航线是双向的，例如从 $1$ 号星球到 $3$ 号星球开辟探险航线，那么从 $3$ 号星球到 $1$ 号星球也可以使用这条航线。

例如下图所示：

 ![](https://cdn.luogu.com.cn/upload/pic/1644.png) 

在 $5$ 个星球之间，有 $5$ 条探险航线。

$A,B$ 两星球之间，如果某条航线不存在，就无法从 $A$ 星球抵达 $B$ 星球，我们则称这条航线为关键航线。

显然上图中，$1$ 号与 $5$ 号星球之间的关键航线有 $1$ 条：即为 $4\leftrightarrow5$ 航线。

然而，在宇宙中一些未知的磁暴和行星的冲撞，使得已有的某些航线被破坏，随着越来越多的航线被破坏，探险飞船又不能及时恢复这些航线，可见两个星球之间的关键航线会越来越多。

假设在上图中，航线 $4\leftrightarrow2$（从 $4$ 号星球到 $2$ 号星球）被破坏。此时，$1$ 号与 $5$ 号星球之间的关键航线就有 $3$ 条：$1 \leftrightarrow 3$，$3 \leftrightarrow 4$，$4 \leftrightarrow 5$。

小联的任务是，不断关注航线被破坏的情况，并随时给出两个星球之间的关键航线数目。现在请你帮助完成。


## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证：

- $1 \leq n \leq 3 \times 10^4$，$1 \leq m \leq 10^5$。
- $-1 \leq op \leq 1$，$1 \leq u, v \leq n$。
- 无论航线如何被破坏，任意时刻任意两个星球都能够相互到达。在整个数据中，任意两个星球之间最多只可能存在一条直接的航线。
- 对于 $op = 0$ 的操作，保证操作前航线 $u \leftrightarrow v$ 存在。
- 询问与破坏航线的总次数不超过 $4 \times 10^4$。

## 样例 #1

### 输入

```
5 5
1 2
1 3
3 4
4 5
4 2
1 1 5
0 4 2
1 5 1
-1```

### 输出

```
1
3```

# 题解

## 作者：FlashHu (赞：35)

太弱了不会树剖，觉得LCT好写一些，就上LCT乱搞，当LCT维护双连通分量的练手题好了

正序删边是不好来维护连通性的，于是就像水管局长那样离线处理，逆序完成操作

显然，每个点可以代表一个双连通分量，查询就是链的长度-1

连接一条边，如果在LCT中还没连通就link，如果连通了，显然这里会出现一个环，然后暴力缩点，可以把当前辅助树的根节点当做集合的标志节点，然后dfs整个辅助树，把链上的其它点的并查集祖先暴力改成这个标志节点，最后再断开标志节点与子树的连接。总的暴力修改次数不会超过$N\log N$次，复杂度是对的

但是点缩完了，那它们的子树不会指空吗？所以，access的时候，要更新$x$为$geth(f[x])$

至于常数，LCT也并不是很慢啊。反正~~有了O2~~还是可以做到很优秀的

代码细节很多，调试真心累TAT
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
#define RG register
#define R RG short
#define I inline void
#define IB inline bool
#define IS inline short
#define G ch=getchar()
#define lc c[x][0]
#define rc c[x][1]
const int N=30009,M=100009;
short f[N],c[N][2],s[N],h[N],a[N],b[N],op[N],ans[M];
bool r[N],vis[M];
struct EDGE{//对边排序，方便查找该边是否被删除
    short x,y;
    IB operator<(const EDGE a)const{
        return x<a.x||(x==a.x&&y<a.y);
    }
}e[M];
template<typename T>
I in(RG T&z){
    RG char G;
    while(ch<'-')G;
    z=ch&15;G;
    while(ch>'-')z*=10,z+=ch&15,G;
}
IS geth(R x){
    if(x==h[x])return x;
    return h[x]=geth(h[x]);
}
IB nroot(R x){
    return c[f[x]][0]==x||c[f[x]][1]==x;
}
I pushup(R x){
    s[x]=s[lc]+s[rc]+1;
}
I pushdown(R x){
    if(r[x]){
        swap(lc,rc);
        r[lc]^=1;r[rc]^=1;r[x]=0;
    }
}
I pushall(R x){
    if(nroot(x))pushall(f[x]);
    pushdown(x);
}
I rotate(R x){
    R y=f[x],z=f[y],k=c[y][1]==x,w=c[x][!k];
    if(nroot(y))c[z][c[z][1]==y]=x;f[x]=z;
    c[x][!k]=y;f[y]=x;
    c[y][k]=w;f[w]=y;
    pushup(y);
}
I splay(R x){
    pushall(x);
    R y;
    while(nroot(x)){
        if(nroot(y=f[x]))
            rotate((c[f[y]][0]==y)^(c[y][0]==x)?x:y);
        rotate(x);
    }
    pushup(x);
}
I access(R x){
    for(R y=0;x;y=x,x=f[y]=geth(f[x]))//注意更新
        splay(x),rc=y,pushup(x);
}
I makeroot(R x){
    access(x);splay(x);
    r[x]^=1;
}
IS findroot(R x){
    access(x);splay(x);
    pushdown(x);
    while(lc)pushdown(x=lc);
    splay(x);
    return x;
}
I split(R x,R y){
    makeroot(y);
    access(x);splay(x);
}
I del(R x,R y){//函数递归缩点
    if(x)h[x]=y,del(lc,y),del(rc,y);
}
I merge(R x,R y){
    if(x==y)return;//在一个分量里什么都不用干
    makeroot(x);
    if(findroot(y)!=x){
        f[x]=y;return;//等于link
    }
    del(rc,x);
    rc=0;pushup(x);//缩点，删点
}
int main(){
    RG int n,m,i,j;
    R x,y;
    in(n);in(m);
    for(i=1;i<=n;++i)s[i]=1,h[i]=i;
    for(i=1;i<=m;++i){
        in(x);in(y);
        if(x>y)swap(x,y);//强制编号，方便以后查找
        e[i]=(EDGE){x,y};
    }
    sort(e+1,e+m+1);
    for(j=1;in(op[j]),op[j]!=131;++j){
        in(x);in(y);
        if(!op[j]){
            if(x>y)swap(x,y);
            vis[lower_bound(e+1,e+m+1,(EDGE){x,y})-e]=1;
        }//重载完小于号，直接二分找到，再打上删除记号
        a[j]=x;b[j]=y;
    }
    for(i=1;i<=m;++i)
        if(!vis[i])merge(geth(e[i].x),geth(e[i].y));
    for(i=0,--j;j;--j){
        x=geth(a[j]);y=geth(b[j]);
        if(op[j])split(x,y),ans[++i]=s[x]-1;
        else merge(x,y);
    }
    while(i)printf("%hd\n",ans[i--]);
    return 0;
}
```

---

## 作者：Soulist (赞：27)

一只蒟蒻介绍一种可能不太难想的解法。

~~（那些大佬好像都写了什么缩点双还是什么的，蒟蒻瑟瑟发抖啊$QAQ$）~~

不难想到要反向处理。

然后题目就变成了：先给一些边，然后不断加边，求$x-y$关键边数量。

因为只有加边操作，所以实际上只有关键边变非关键边，而不存在非关键边变成关键边。

不难发现，一条边如果为关键边，那么其联通了两个联通块，且没有其他边联通这两个联通块，所以对于一条关键边，从其联通的两个联通块中任意两个点到对方点的路径中其都为关键边，简单来讲，就是 **一条关键边对于任意两个过其的点都是关键边**

故我对每个边维护一下其是否为关键边，如果是其边权为$1$，否则其边权为$0$

由于前面加粗的字体所描述的优秀性质，所以我们询问$x-y$的路径上有多少关键路径，就是询问$x-y$的路径上边权和

有加边操作，所以考虑使用$LCT$，然后要把边拆为点。

现在考虑加边怎么做：

如果一条边连接了两个现在未联通的点，那么直接加边，且加入的这条边显然是一条关键边，假设当前边的编号为$Idnex$，那么$w[Idnex]=1$。

如果一条连接了两个已经联通的点呢？

看图理解$QWQ$

现在的图是这个样子的：

![](https://i.loli.net/2019/03/21/5c936c265921d.jpg)

我们加入一条这样的边，那么这条边连接了两个已经联通的点，其显然是一个非关键边。

![](https://i.loli.net/2019/03/21/5c936c308793f.jpg)

图中的红边是一条非关键边。

然后考虑其对答案的影响。

其会导致这些边变成非关键边：

![](https://i.loli.net/2019/03/21/5c936c358cff7.jpg)

（图中绿边）

那么我们如何把这些边改成非关键边？就是要将这些边的点权改为0

不难发现一条这样的红边对答案产生的影响就是：$x-y$的路径中的所有边。

这些边的边权都要被改为$0$

所以如果一条边连接的两个点在同一联通块内，就把这一条链拉出来，把边权全部覆盖为$0$，就操作如下：

先$slipt(x,y)$，然后给打上一个覆盖标记。

细节看代码$QWQ$

```cpp
#include<bits/stdc++.h>
using namespace std;
int read() {
	char cc = getchar(); int cn = 0, flus = 1;
	while(cc < '0' || cc > '9') {  if( cc == '-' ) flus = -flus;  cc = getchar();  }
	while(cc >= '0' && cc <= '9')  cn = cn * 10 + cc - '0', cc = getchar();
	return cn * flus;
}
#define ls(x) t[x].son[0]
#define rs(x) t[x].son[1]
#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )
#define drep( i, t, s ) for( register int i = t; i >= s; -- i )
const int N = 200000 + 5;
struct LCT {
	int son[2], val, fa, cover;
	bool mark;
}t[N];
struct E{
	int from, to, c;
}e[N];
map< int, int > mc1; 
int n, m, Opt[N], From[N], To[N], tot, w[N], Idnum, ans[N], Id[N];
void pushup( int x ) {
	t[x].val = t[ls(x)].val + t[rs(x)].val + w[x];
}
void push( int x ) { //cover表示覆盖标记，如果有覆盖标记，则此点的w值应改为0，且整棵子树都要被改为0 
	// 所以还要修改t[x].val = 0 
	w[x] = 0, t[x].cover = 1, t[x].val = 0;
}
void pushmark( int x ) {
	if( t[x].cover ) // 下传标记 
		t[x].cover = 0, push( ls(x) ), push( rs(x) ), t[x].val = 0;
	if( t[x].mark )
		t[x].mark = 0, t[ls(x)].mark ^= 1, t[rs(x)].mark ^= 1, swap( ls(x), rs(x) );
}
bool isroot( int x ) {
	return ( rs(t[x].fa) != x ) && ( ls(t[x].fa) != x );
}
void rotate( int x ) {
	int f = t[x].fa, ff = t[f].fa, qwq = ( rs(f) == x );
	t[x].fa = ff;
	if( !isroot(f) ) t[ff].son[rs(ff) == f] = x;
	t[t[x].son[qwq ^ 1]].fa = f, t[f].son[qwq] = t[x].son[qwq ^ 1];
	t[x].son[qwq ^ 1] = f, t[f].fa = x;
	pushup(f), pushup(x);
}
int st[N];
void Splay( int x ) {
	int top = 0, now = x; st[++top] = now;
	while( !isroot(now) ) st[++top] = ( now = t[now].fa );
	while( top ) pushmark( st[top--] );
	while( !isroot(x) ) {
		int f = t[x].fa, ff = t[f].fa;
		if( !isroot(f) ) ( ( rs(ff) == f ) ^ ( rs(f) == x ) ) ? rotate(x) : rotate(f);
		rotate(x);
	}
}
void access( int x ) {
	for( int y = 0; x; y = x, x = t[y].fa ) 
		Splay(x), t[x].son[1] = y, pushup(x);
}
void makeroot( int x ) {
	access( x ), Splay( x ), t[x].mark ^= 1, pushmark( x );
}
int findroot( int x ) {
	access( x ), Splay( x ), pushmark( x );
	while( ls(x) ) pushmark( x = ls(x) );
	return x;
}
void split( int x, int y ) {
	makeroot(x), access(y), Splay(y);
} 
void link( int x, int y ) {
	makeroot( x );
	if( findroot(y) != x ) t[x].fa = y;
}
bool check( int x, int y ) {
	makeroot( x );
	return findroot(y) == x;
}
void input() {
	n = read(), m = read();
	rep( i, 1, m ) {
		e[i].from = read(), e[i].to = read();
		if( e[i].from > e[i].to ) swap( e[i].from, e[i].to ); //swap, 方便统计 
		mc1[e[i].from * ( n + 1 ) + e[i].to] = i, w[i + n] = 1; //拆边，每条边的编号都是i+n，
		//同时在map内记录，方便查初始有那些边存在 
	}
	while( 1 ) {
		Opt[++ tot] = read(); //表示是那种操作 
		if( Opt[tot] == -1 ) break;
		From[tot] = read(), To[tot] = read(); 
		if( Opt[tot] == 0 ) {
			if( From[tot] > To[tot] ) swap( From[tot], To[tot] );
			Id[tot] = mc1[From[tot] * ( n + 1 ) + To[tot]];
			e[Id[tot]].c = 1; //标记这条边被用过了 
		}
	}
}
signed main()
{
	input(); //读入函数 
	rep( i, 1, m ) {
		if( !e[i].c ) { //若这条边没有被用过 
			int u = e[i].from, v = e[i].to;
			if( check( u, v ) )  split( u, v ), push(v); //如果u，v 在一个联通块内，则拉出u到v的链，然后打上标记 
			else link( e[i].from, i + n ), link( i + n, e[i].to ); //否则直接连边 
		}
	}
	drep( i, tot - 1, 1 ) {
		if( Opt[i] == 0 ) { //如果是0，就是连边操作，与前面类似 
			int u = From[i], v = To[i];
			if( check( u, v ) )  split( From[i], To[i] ), push(To[i]);
			else link( From[i], Id[i] + n ), link( Id[i] + n, To[i] );
		}
		if( Opt[i] == 1 ) //否则就是询问，直接split然后统计答案 
			split( From[i], To[i] ), ans[++Idnum] = t[To[i]].val;
	} 
	drep( i, Idnum, 1 ) printf("%d\n", ans[i]);
	return 0;
}
```

---

## 作者：cppascalinux (赞：24)

# 一个不用树链剖分和LCT的题解
~~其实是因为本蒟蒻不会树链剖分和LCT嘤嘤嘤~~

---

* **前半部分的想法和树链剖分是一样的**  
将所有操作按时间反转,将删边转化为加边。  
从最开始的图中随便取出一棵生成树,假设最开始树上所有边都是白边  
此后每添加一条非树边$(u,v)$,就将树上$u-v$的路径全部染黑  

* **然后不难发现,每次询问$(u,v)$,则$u-v$路径上的白边就是关键航线,$u-v$路径上的的白边数量就是答案**  
路径染色,查询路径上白边数量,不难想到用树链剖分+线段树来维护,时间复杂度$O(N\cdot log^2N)$

---

* 思考一下如何不用树链剖分  
发现每条边只用被染色一次~~黑的染多少次都是黑的~~  
**令白边的边权为1,黑边的边权为0**  
每次添加一条非树边$(u,v)$,就将$u-v$路径上所有未染黑的边边权都-1,并将这些边染黑   
**这样每次询问$(u,v)$的时候,答案就是$u-v$路径的边权和**

* ***如何保证每条边只被染黑一次？***  
每次染黑一条路径$u-v$的时候,用并查集将路径上所有边$(a,b)$的$father$设置为$u-v$的$LCA(u-v)$的$father$,这样下次再访问到$(a,b)$这条边的时候,直接跳过这条边,到$LCA(u-v)$处  
**由于每条边只会被缩一次，所以时间复杂度均摊$O(N)$**
* **每条边用较深的那个点来表示**  
例如,边$(a,b)$中,$a$为$b$的儿子  
$(a,b)$的$father$用$a$的$father$表示  
$(a,b)$的边权用$a$的点权表示

* **这部分有点复杂,详情可以见代码**

---
* 还剩一个小问题:如何不用树链剖分维护单点加,路径求和  
令$L(u)$表示$u$到根的边权和  
**$u-v$路径的边权和即为$L(u)+L(v)-2L(LCA(u,v))$**

* 不难发现,每次将点$u$的点权$+x$,则对于$u$子树中所有点$v$,$L(v)$会$+x$,子树外所有点$p$的$L(p)$都不变  
又因为,同一棵子树中的点的$DFS$序是连续的  
**问题就转化为了区间加,单点求值**

* 将正常的树状数组询问,修改时+,-的方向反过来,就得到了  
**资瓷区间加,单点求值的树状数组**  
(详情请见代码)

---

**时间复杂度$O(N\cdot logN)$,瓶颈在树状数组,倍增$LCA$,`std::map`上**

## 完结撒花~
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<map>
#define lb(x) (x&-x)//二进制最低位
#define pii pair<int,int>
#define fi first
#define se second
using namespace std;
int n,m,cnt,tme;//点数,边数,操作总数,DFS时间戳
int hd[30009],eg[60009],nxt[60009],tot;//存图
int dfn[30009],ed[30009],dep[30009];//依次为:DFS序,子树中DFS序最大值,节点深度
int c[30009];//树状数组
int fn[30009];//并查集数组
int f[30009][16];//倍增数组
pii e[100009],q[40009];//边集,询问
int del[100009],ont[100009];//边是否被删除,是否为生成树上的边
int typ[40009],ans[40009];//询问的种类,答案
map<pii,int> mp;//记录边的编号
void add(int x,int val)//树状数组[1,x]区间加val
{
    for(int i=x;i;i-=lb(i))
        c[i]+=val;
}
int ask(int x)//x单点求值
{
    int ans=0;
    for(int i=x;i<=n;i+=lb(i))
        ans+=c[i];
    return ans;
}
int fnd(int x)//并查集
{
    return x==fn[x]?x:fn[x]=fnd(fn[x]);
}
void ins(int a,int b)//加边
{
    eg[++tot]=b;
    nxt[tot]=hd[a];
    hd[a]=tot;
}
void dfs(int x,int fa)
{
    dep[x]=dep[fa]+1;
    ed[x]=dfn[x]=++tme;//标记DFS序
    f[x][0]=fa;//标记父亲
    for(int i=1;i<=15;i++)//预处理倍增数组
        f[x][i]=f[f[x][i-1]][i-1];
    for(int i=hd[x];i;i=nxt[i])
        if(eg[i]!=fa)//防止返祖访问
        {
            dfs(eg[i],x);
            ed[x]=max(ed[x],ed[eg[i]]);//更新ed
        }
}
int getlca(int x,int y)//倍增求LCA
{
    if(dep[x]<dep[y])
        swap(x,y);
    int l=dep[x]-dep[y];
    for(int i=0;i<=15;i++)
        if(l&(1<<i))
            x=f[x][i];
    if(x==y)
        return x;
    for(int i=15;i>=0;i--)
        if(f[x][i]!=f[y][i])
            x=f[x][i],y=f[y][i];
    return f[x][0];
}
void modify(int x,int y)//核心:并查集缩点(其实和树链剖分的修改操作很像)
{
    int fx=fnd(x),fy=fnd(y),lca=getlca(x,y);
    while(fx!=fy)
    {
        if(dep[fx]<dep[fy])//优先将深的点向上跳
            swap(fx,fy);
        if(fx!=lca)//将fx到fx父亲的边的边权-1,若fx为LCA则不用修改
        {
            add(ed[fx],-1);//树状数组区间修改
            add(dfn[fx]-1,1);//树状数组区间修改
        }
        x=fnd(f[fx][0]);//fx父亲所在集合的根
        fn[fx]=x;//将fx的根设置为fx父亲所在集合的根
        fx=x;//继续向上跳
    }
}//这里每条边只会被修改一次,所以时间复杂度均摊O(N)
int query(int x,int y)//询问u-v路径的边权和
{
    return ask(dfn[x])+ask(dfn[y])-2*ask(dfn[getlca(x,y)]);
}
void init()
{
    for(int i=1;i<=n;i++)//初始化并查集
        fn[i]=i;
    for(int i=1;i<=m;i++)//得到一棵生成树
        if(!del[i])
        {
            int a=e[i].fi,b=e[i].se;
            if(fnd(a)!=fnd(b))//若a,b不连通
            {
                ont[i]=1;//标记树边
                fn[fnd(a)]=fnd(b);//并查集合并
                ins(a,b);//加边
                ins(b,a);//加边
            }
        }
    dfs(1,0);
    for(int i=2;i<=n;i++)//将所有边的边权设为1
    {
        add(ed[i],1);//树状数组区间修改
        add(dfn[i]-1,-1);//树状数组区间修改
    }
    for(int i=1;i<=n;i++)//初始化并查集
        fn[i]=i;
    for(int i=1;i<=m;i++)//添加未被删除的非树边
        if(!del[i]&&!ont[i])
            modify(e[i].fi,e[i].se);
}
void solve()
{
    for(int i=cnt;i>=1;i--)//倒序处理操作
    {
        if(!typ[i])
            modify(q[i].fi,q[i].se);//添加非树边
        else
            ans[i]=query(q[i].fi,q[i].se);//处理询问
    }
    for(int i=1;i<=cnt;i++)//正序输出
        if(typ[i])
            printf("%d\n",ans[i]);
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1,a,b;i<=m;i++)
    {
        scanf("%d%d",&a,&b);
        if(a>b)
            swap(a,b);
        e[i]=pii(a,b);
        mp[e[i]]=i;//用map记录边的编号
    }
    int c,a,b;
    scanf("%d",&c);
    while(c!=-1)
    {
        scanf("%d%d",&a,&b);
        if(a>b)
            swap(a,b);
        q[++cnt]=pii(a,b);
        typ[cnt]=c;//记录操作种类
        if(!c)
            del[mp[q[cnt]]]=1;//这条边已被删除
        scanf("%d",&c);
    }
    init();
    solve();
    return 0;
}
```

---

## 作者：Haworthia (赞：14)

这是蒟蒻国庆集训时听的题，讲课的巨佬只给了思路，大致如下：

1、环上的边一定不是关键边。

2、时间反演，逆向处理操作，变成插入边和询问。

3、搞出来一棵树。

4、处理操作，如果我们在v[i]和u[i]之间加入了一条边，那么树上v[i]到u[i]之间的所有边都标记为不是关键边。询问，就是看树上v[i]到u[i]的路径上有多少条边还没有被标记。用树剖维护即可。

以上，和其他发题解的大佬的思路都是差不多的。蒟蒻这里主要是说一些细节，自己错误的地方（自己改得快要崩溃的时候就希望有这样的提示啊）

1、我第一次提交就MLE了。MLE一般就是两种：数组过大（这题显然不是），死循环/无限递归导致爆栈。我自己的情况是出在搞出一颗树，也即树剖的第一次dfs的时候。

分析：题目中给了m条边，然后删去了若干条。我们要时间反演，把他们都删掉，再加回来。**都删掉以后，剩下的边肯定是多于n-1条的。但我直接默认剩下刚好是一颗树，直接dfs，于是死循环。**（为啥是MLE而不是TLE呢？我也不知道）

改正：见代码注释。

2、然后就WA了。实在改不出来，于是参考题解，才发现和上一个错因一模一样。

分析：我还是默认剩下是一颗树（怎么会有这么蠢的人），相当于多删去了很多边。这些**被我误删的边，全部都要加回来**，即是dfs3。

改正：见代码注释。

~~其实WA了十多遍这种事怎么可能告诉别人呢~~，各种稀奇古怪的问题，主要在是搞出一颗树时，这一点我的思路一开始就是错的

AC code：
```
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define rint register int
#define lson l,m,rt<<1
#define rson m+1,r,rt<<1|1
using namespace std;
typedef long long ll;
const int N=40000+10,M=100000+10;
int n,m,a,b,x,y,z,bnt,cnt,dnt,tot;
int ans[N],head[N],siz[N],fa[N],dep[N],son[N],id[N],top[N],tr[N<<2],lazy[N<<2];
struct node
{
	int op,a,b;
}q[N];
struct mode
{
	int v,next,des;
}e[M<<1];
inline void adde(int u,int v)
{
	e[++cnt]=(mode){v,head[u]};
	head[u]=cnt;
}
inline void read(int &x)
{
	x=0;
	int f=1;
	char s=getchar();
	while(s<'0'||s>'9')
	{
		if(s=='-')
			f=-1;
		s=getchar();
	}
	while(s>='0'&&s<='9')
	{
		x=(x<<1)+(x<<3)+s-'0';
		s=getchar();
	}
	x*=f;
}
inline void pushup(int rt)
{
	tr[rt]=tr[rt<<1]+tr[rt<<1|1];
}
inline void pushdown(int rt)
{
	lazy[rt<<1]=lazy[rt<<1|1]=1;
	tr[rt<<1]=tr[rt<<1|1]=lazy[rt]=0;
}
void build(int l,int r,int rt)
{
	if(l==r)
	{
		tr[rt]=1;
		return;
	}
	int m=(l+r)>>1;
	build(lson);
	build(rson);
	pushup(rt);
}
void update(int L,int R,int l,int r,int rt)
{
	if(L<=l&&r<=R)
	{
		tr[rt]=0,lazy[rt]=1;
		return;
	}
	if(lazy[rt])
		pushdown(rt);
	int m=(l+r)>>1;
	if(L<=m)
		update(L,R,lson);
	if(m<R)
		update(L,R,rson);
	pushup(rt);
}
int query(int L,int R,int l,int r,int rt)
{
	if(L<=l&&r<=R)
		return tr[rt];
	if(lazy[rt])
		pushdown(rt);
	int m=(l+r)>>1,sum=0;
	if(L<=m)
		sum+=query(L,R,lson);
	if(m<R)
		sum+=query(L,R,rson);
	return sum;
}
void dfs1(int u,int va)
{
	fa[u]=va;
	siz[u]=1;
	dep[u]=dep[va]+1;
	for(rint i=head[u];~i;i=e[i].next)
	{
		int v=e[i].v;
		if(siz[v]||e[i].des)//改进1：如果siz[v]不为0，则v已经被遍历过了（相当于一个vis数组的功能） 
			continue;
		dfs1(v,u);
		siz[u]+=siz[v];
		if(siz[son[u]]<siz[v])
			son[u]=v;
	}
}
void dfs2(int u,int anc)
{
	id[u]=++bnt;
	top[u]=anc;
	if(!son[u])
		return;
	dfs2(son[u],anc);
	for(rint i=head[u];~i;i=e[i].next)
	{
		int v=e[i].v;
		if(fa[v]!=u||v==son[u]||e[i].des)
			continue;
		dfs2(v,v);
	}
}
inline void mark(int a,int b)
{
	while(top[a]!=top[b])
	{
		if(dep[top[a]]<dep[top[b]])
			swap(a,b);
		update(id[top[a]],id[a],1,n,1);
		a=fa[top[a]];
	}
	if(dep[a]<dep[b])
		swap(a,b);
	update(id[b]+1,id[a],1,n,1);
}
void dfs3(int u)//改进2：被误删的边，再时间反演之前全部补回来 
{
	for(rint i=head[u];~i;i=e[i].next)
	{
		int v=e[i].v;
		if(e[i].des)
			continue;
		if(fa[v]==u)
			dfs3(v);
		else
			if(dep[u]<dep[v])
				mark(u,v);
	}
}
int main()
{
//	freopen("1.in","r",stdin);
	read(n),read(m);
	memset(head,-1,sizeof head);
	for(rint i=1;i<=m;++i)
	{
		read(a),read(b);
		adde(a,b),adde(b,a);
	}
	for(;;)
	{
		read(x);
		if(x==-1)
			break;
		read(y),read(z);
		q[++dnt]=(node){x,y,z};
		if(x)
			continue;
		for(rint i=head[y];~i;i=e[i].next)
			if(e[i].v==z)
			{
				e[i].des=1;
				break;
			}
		for(rint i=head[z];~i;i=e[i].next)
			if(e[i].v==y)
			{
				e[i].des=1;
				break;
			}
	}
	dfs1(1,0);
	dfs2(1,1);
	build(1,n,1);
	dfs3(1);
	for(rint i=dnt;i>=1;--i)
	{
		a=q[i].a,b=q[i].b;
		if(!q[i].op)
			mark(a,b),ans[i]=-1;
		else
		{
			while(top[a]!=top[b])
			{
				if(dep[top[a]]<dep[top[b]])
					swap(a,b);
				ans[i]+=query(id[top[a]],id[a],1,n,1);
				a=fa[top[a]];
			}
			if(dep[a]<dep[b])
				swap(a,b);
			ans[i]+=query(id[b]+1,id[a],1,n,1); 
		}
	}
	for(rint i=1;i<=dnt;++i)
		if(ans[i]!=-1)
			printf("%d\n",ans[i]);
	return 0;
}
```


---

## 作者：Lucifer_Bartholomew (赞：8)

# 树链剖分+离线树转图
观察题面,我们发现关键边就是桥,如果没有删边操作,就是一道tarjan裸题了。虽然我们可以一边删边一边更新tarjan,但时间复杂度应该过不了。所以我们要换一种思路。

我们注意到题中一句话:"保证联通"。如果我们不断删边,又保证联通,那么整张图最后会变成什么样呢?明显会变成一棵树。树就是好东西了,很多数据结构都能在树上用。而且我们发现树上的边都是关键边,,所以我们可以先建一棵树,再在树上加边建图。

我们可以明显发现,只要在树上任意两点之间加了一条边就会形成一个环,而对于环上的边显然都不会是关键边。因为树上两点间路径确定,形成环后该路径上所有边就都不为关键边了,所以自然想到将整棵树的边权置为1,每次对于(u,v)加边就将u到v的路径上的所有边边权改为0。

边权转点权,树链剖分实现。查询就直接查询u到v路径上还有多少边边权为1就行了。

然后就是删边操作,删掉一条边又保证联通,显然只能删环上的边,即每次删边后关键边数量一定不减,(假设删边(u,v))若我们每次在u到v的路径上加1,显然无法最优,因为对于u到v路径上的边,不一定删掉(u,v)这条边就一定会让它变成关键边,有可能它还属于别的环。所以我们可以反向考虑,所有要删掉的边都先不加,相当于默认全部删完了,倒序查询询问后再一条一条加回去,这样就可以避免删边操作了。

离线所有操作再倒序实现。

当然删边并不一定会断掉所有环,还有的边连在树上形成环。所以在建树时用并查集维护保证只建出一棵树,再把没加但未来不会删掉的边用成环情况处理。

代码实现细节见代码。
```cpp
#include <map>
#include <stack>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define ll long long
#define lson l,m,rt<<1
#define rson m+1,r,rt<<1|1
using namespace std;
inline int read()
{
	char ch=getchar();
	int f=1,x=0;
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
	return x*f;
}
struct edge{
	int v,next;
}e[60001];
struct node{
	int t,a,b;
}dt[40001];//存查询,删边操作
int cnt,tot,head[30001],dep[30001],fa[30001],siz[30001],son[30001],top[30001],id[30001],dfn[30001],low[30001],x[100001],y[100001],add[120005],sum[120005];
bool vis[100001];//记录边是否在树中
map<pair<int,int>,bool> ma;//记录u到v的边会不会删
inline void adde(int u,int v)
{
	e[++cnt]=(edge){v,head[u]};
	head[u]=cnt;
}
inline int findf(int x)
{
	return fa[x]==x?x:fa[x]=findf(fa[x]);
}
inline void find(int u)//树剖模板不解释
{
	siz[u]=1;
	for(int i=head[u];~i;i=e[i].next)
	{
		int v=e[i].v;
		if(v!=fa[u])
		{
			fa[v]=u;
			dep[v]=dep[u]+1;
			find(v);
			siz[u]+=siz[v];
			if(siz[v]>siz[son[u]])son[u]=v;
		}
	}
}
inline void dfs(int u,int fat)
{
	top[u]=fat;
	id[dfn[u]=++tot]=u;
	if(son[u])dfs(son[u],fat);
	for(int i=head[u];~i;i=e[i].next)
	{
		int v=e[i].v;
		if(v!=son[u]&&v!=fa[u])dfs(v,v);
	}
	low[u]=tot;
}
inline void pushup(int rt)
{
	sum[rt]=sum[rt<<1]+sum[rt<<1|1];
}
inline void pushdown(int rt,int m)
{
	if(~add[rt])
	{
		add[rt<<1]=add[rt<<1|1]=add[rt];
		sum[rt<<1]=add[rt]*(m-(m>>1));
		sum[rt<<1|1]=add[rt]*(m>>1);
		add[rt]=-1;
	}
}
inline void build(int l,int r,int rt)//线段树初始赋值全为1
{
	add[rt]=-1;
	if(l==r)
	{
		sum[rt]=1;
		return;
	}
	int m=l+r>>1;
	build(lson);
	build(rson);
	pushup(rt);
}
inline void update(int L,int R,int c,int l,int r,int rt)//线段树要建成区间赋值的类型
{
	if(L<=l&&r<=R)
	{
		add[rt]=c;
		sum[rt]=c*(r-l+1);
		return;
	}
	pushdown(rt,r-l+1);
	int m=l+r>>1;
	if(L<=m)update(L,R,c,lson);
	if(m<R)update(L,R,c,rson);
	pushup(rt);
}
inline int query(int L,int R,int l,int r,int rt)//线段树查询不解释
{
	if(L<=l&&r<=R)return sum[rt];
	pushdown(rt,r-l+1);
	int m=l+r>>1,ret=0;
	if(L<=m)ret+=query(L,R,lson);
	if(m<R)ret+=query(L,R,rson);
	return ret;
}
int main()
{
	memset(head,-1,sizeof head);
	int n=read(),m=read();
	for(int i=1;i<=m;++i)//记边
	{
		x[i]=read();
		y[i]=read();
	}
	int tim=0;
	while(1)//离线 处理
	{
		int t=read();
		if(!(~t))break;
		int a=read(),b=read();
		dt[++tim]=(node){t,a,b};
		if(!t)ma[make_pair(a,b)]=ma[make_pair(b,a)]=1;//要删掉的边先不建
	}
	for(int i=1;i<=n;++i)
		fa[i]=i;
	for(int i=1;i<=m;++i)
	{
		int u=findf(x[i]),v=findf(y[i]);
		if(!ma[make_pair(x[i],y[i])]&&fa[u]!=v)//建树,用并查集维护是否成树
		{
			fa[u]=v;
			adde(x[i],y[i]);
			adde(y[i],x[i]);
			vis[i]=1;//记录边已加入
		}//这样建树就会保证只生成一棵树,之后就可以直接加边成环,不需要像其他的做法一样修改树剖的dfs处和dfs3次。
	}
	memset(fa,0,sizeof fa);
	find(1);
	dfs(1,1);
	build(1,n,1);
	for(int i=1;i<=m;++i)
		if(!vis[i]&&!ma[make_pair(x[i],y[i])])//边未加入树中且未来不会被删加入图中成环处理
		{
			int a=x[i],b=y[i];
			while(top[a]!=top[b])
			{
				if(dep[top[a]]>dep[top[b]])swap(a,b);
				update(dfn[top[b]],dfn[b],0,1,tot,1);
				b=fa[top[b]];
			}
			if(dep[a]>dep[b])swap(a,b);
			update(dfn[a]+1,dfn[b],0,1,tot,1);
		}
	stack<int> q;
	for(int i=tim;i;--i)//倒序处理操作
	{
		int ans=0,t=dt[i].t,a=dt[i].a,b=dt[i].b;
		while(top[a]!=top[b])
		{
			if(dep[top[a]]>dep[top[b]])swap(a,b);
			if(t)ans+=query(dfn[top[b]],dfn[b],1,tot,1);
			else update(dfn[top[b]],dfn[b],0,1,tot,1);
			b=fa[top[b]];
		}
		if(dep[a]>dep[b])swap(a,b);
		if(t)q.push(ans+query(dfn[a]+1,dfn[b],1,tot,1));
		else update(dfn[a]+1,dfn[b],0,1,tot,1);
	}
	while(!q.empty())//因为是倒序处理操作,所以答案要倒序输出
	{
		printf("%d\n",q.top());
		q.pop();
	}
    return 0;
}
```
~~我是蒟蒻~~

---

## 作者：菲斯斯夫斯基 (赞：5)

## P2542 [AHOI2005] 航线规划 题解

**前言**

本题我使用到的算法：Tarjan、树链剖分、线段树。

**题意**

给出一个无向图，要求支持两种操作：

1. 求出给出的两点的路径中割边的数量。

2. 删除两点之间的一条边。

**思路**

选择离线操作。在线操作比较麻烦，无法达到正确的时间复杂度。

首先将所有要删除的边删除，得到一个新的无向图。

接着将新的无向图使用 Tarjan 进行缩点，那么缩点之后就成了一颗树。

不难发现，两点路径中割边的数量即为在树上简单路径的长度。

我们可以使用线段树以及树剖，维护两点之间的权值和。

因为要求的是两点简单路径上的边数，所以初始时将除了根节点之外的每一个点赋值为 $1$，然后进行操作。

接着考虑删除的操作，因为我们一开始就将边给删去，所以正着做比较麻烦，所以不妨试试反着做。即从后往前循环，遇到一个删除操作，则将两点简单路径上的点的权值更改为 $0$。意为将此边“复活”，在图中对答案会有贡献，两点在同一个边双连通分量内。

注意的是，因为我们是将点代表边，所以在操作时需要忽略根节点。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n,m,cnt,l,num,p;
int dfn[N],low[N],now[N],siz[N],son[N],f[N],de[N],tp[N],id[N],ans[N];
stack<int>s; 
vector<int>v[N],g[N];
struct ccf
{
	int op,x,y;
}a[N];
struct tree
{
	int l,r,la,sum;
}t[N<<2];
map<pair<int,int>,int>mp;
bool era(int x,int y)
{
	if(x>y)swap(x,y);
	return mp[make_pair(x,y)];//此边已删除
}
void tarjan(int x,int fa)
{
	dfn[x]=low[x]=++cnt;
	s.push(x);
	for(int i=0;i<v[x].size();i++)
	{
		int to=v[x][i];
		if(to==fa||era(x,to))continue;
		if(!dfn[to])tarjan(to,x);
		low[x]=min(low[x],low[to]);
	}
	if(low[x]==dfn[x])
	{
		int t=-1;
		num++;
		while(t!=x)
		{
			t=s.top();
			s.pop();
			now[t]=num;
		}
	}
}//缩点
void dfs1(int x,int fa)
{
	f[x]=fa;
	siz[x]=1;
	de[x]=de[fa]+1;
	int ma=0;
	for(int i=0;i<g[x].size();i++)
	{
		int to=g[x][i];
		if(to==fa)continue;
		dfs1(to,x);
		siz[x]+=siz[to];
		if(siz[to]>ma)
			ma=siz[to],son[x]=to;
	}
}
void dfs2(int x,int top)
{
	tp[x]=top;
	id[x]=++p;
	if(!son[x])return ;
	dfs2(son[x],top);
	for(int i=0;i<g[x].size();i++)
	{
		int to=g[x][i];
		if(to==f[x]||to==son[x])continue;
		dfs2(to,to);
	}
}//树剖
void push_down(int k)
{
	if(!t[k].la)return ;
	int l=k*2,r=k*2+1;
	t[l].la=1,t[r].la=1;
	t[l].sum=0;
	t[r].sum=0;
	t[k].la=0;
}
void build(int k,int l,int r)
{
	if(r<l)return ;
	t[k].l=l,t[k].r=r;
	if(l==r)
	{
		if(l!=1)t[k].sum=1;
		return ;
	}
	int mid=(l+r)/2;
	build(k*2,l,mid);
	build(k*2+1,mid+1,r);
	t[k].sum=t[k*2].sum+t[k*2+1].sum;
}
void change(int k,int l,int r,int x,int y,int z)
{
	if(l>y||r<x)return ;
	if(x<=l&&r<=y)
	{
		t[k].sum=z;
		t[k].la=1;
		return ;
	}
	push_down(k);
	int mid=(l+r)/2;
	change(k*2,l,mid,x,y,z);
	change(k*2+1,mid+1,r,x,y,z);
	t[k].sum=t[k*2].sum+t[k*2+1].sum;
}
int ask(int k,int l,int r,int x,int y)
{
	if(l>y||r<x)return 0;
	if(x<=l&&r<=y)return t[k].sum;
	push_down(k);
	int mid=(l+r)/2;
	return ask(k*2,l,mid,x,y)+ask(k*2+1,mid+1,r,x,y);
}//线段树操作，区间修改，区间查询
void add(int x,int y,int z)
{
	while(tp[x]!=tp[y])
	{
		if(de[tp[x]]<de[tp[y]])
			swap(x,y);
		change(1,1,n,id[tp[x]],id[x],z);
		x=f[tp[x]];
	}
	if(de[x]>de[y])
		swap(x,y);
	change(1,1,n,id[x]+1,id[y],z);
}
int ask1(int x,int y)
{
	int ans=0;
	while(tp[x]!=tp[y])
	{
		if(de[tp[x]]<de[tp[y]])
			swap(x,y);
		ans+=ask(1,1,n,id[tp[x]],id[x]);
		x=f[tp[x]];
	}
	if(de[x]>de[y])
		swap(x,y);
	ans+=ask(1,1,n,id[x]+1,id[y]);
	return ans;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		v[x].push_back(y);
		v[y].push_back(x);
	}
	while(1)
	{
		scanf("%d",&a[++l].op);
		if(a[l].op==-1)break;
		scanf("%d%d",&a[l].x,&a[l].y);
		if(a[l].x>a[l].y)swap(a[l].x,a[l].y);
		if(a[l].op==0)
			mp[make_pair(a[l].x,a[l].y)]=1;
	}
	l--;
	tarjan(1,1);
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<v[i].size();j++)
		{
			int to=v[i][j];
			if(era(i,to)||now[i]==now[to])continue;
			g[now[i]].push_back(now[to]);
		}
	}
	for(int i=1;i<=l;i++)
	{
		a[i].x=now[a[i].x];
		a[i].y=now[a[i].y];
	}//缩点后的新编号
	dfs1(1,1);
	dfs2(1,1);
	build(1,1,n);
	for(int i=l;i>=1;i--)//倒着进行循环
	{
		switch(a[i].op)
		{
			case 0:
			{
				add(a[i].x,a[i].y,0);//每遇到一次已删除的边则“复活”
				break;
			}
			case 1:
			{
				ans[i]=(a[i].x==a[i].y?0:ask1(a[i].x,a[i].y));
				break;
			}
		}
	}
	for(int i=1;i<=l;i++)//重新按照正确的顺序输出答案
		if(a[i].op==1)
			printf("%d\n",ans[i]);
	return 0;
}
```

---

## 作者：一扶苏一 (赞：5)

## 【LCT】【P2542】 [AHOI2005] 航线规划

### Analysis

图论弱鸡也不知道啥叫双连通分量……就只能 LCT 乱搞一下子这样子。

首先根据套路，删边不好做，那就反过来变成加边。

注意到一个性质，对于一条边 $(u, v)$ 和一个询问 $(x, y)$ 以及当前图任意一个生成树，如果 $(u, v)$ 是 $(x, y)$ 间的关键边，那么边 $(u, v)$ 一定在这个生成树上。而当图本身是一棵树时，树上每条边都是关键边。

考虑从图的任意一棵生成树开始，对于每次加边维护两点间有多少关键边。注意到加入一条边 $(u, v)$ 以后，原来树上 $(u, v)$ 间的路径与新边产生了一个环。那么这个环上的所有边都不可能作为关键边了，而新加入的边对其他不在环上的边均无影响。因此我们考虑暴力的把这个环删掉，然后新建一个节点代表这个大环，把以前与环上点相连的边都连接到新节点上，每个节点属于哪个环用并查集维护。这样就保证了我们维护的图一定是一棵树，而且树上有且仅有关键边。对于一次查询 $(u, v)$，只需要查询 $u$ 所属的环与 $v$ 所属的环的路径上有多数关键边即可。

加边，删边，维护链信息，可以用 LCT 来处理。考虑当删除树上一条链时（被删除的环去掉新加的边在树上是一条链），会有很多节点的父亲作为虚边指向环上的节点。我们对每个节点维护一个 lnk 指针，如果该指针不为空，则表示当前节点已被删除，新建节点为 lnk 指向的节点。在对一个节点进行任何操作时，先将该节点的父亲通过不断跳 lnk 的方式跳到真正的父亲上去，然后进行 LCT 的操作即可。

考虑时间复杂度：每个节点只会被删除一次，因此暴力删除是均摊 $O(1)$ 的；LCT 的各种操作是均摊 $O(\log n)$ 的，跳 lnk 的过程与进行了路径压缩的并查集的过程是一致的，因此可以用同样的方式证明这部分的复杂度也是均摊 $O(\log n)$ 的。因此单次操作的均摊复杂度是 $O(\log n)$。总时间复杂度 $O(c \log n)$，其中 $c$ 是操作次数。

在实现时，可以发现在对于一个节点做任何操作之前一定会将该节点转到 splay 的根。因此只在 splay 的 pushdown 之前找父节点的过程中跳 lnk 即可。

### Code

```cpp
namespace Fusu {

const int maxn = 30005;
const int maxm = 500005;

void Init();
void Solve();

void Main() {
  Init();
  Solve();
}

struct OP {
  int op, u, v;
};
OP opt[maxm];

int n, m, ocnt;

struct Node {
  int sz = 1, id;
  bool rev;
  Node *ch[2], *fa, *lnk;

  void updf() { while (fa && fa->lnk) fa = fa->lnk; }

  void maketag() {
    rev = !rev;
    std::swap(ch[0], ch[1]);
  }
  void pushdown() {
    if (rev) {
      if (ch[0]) ch[0]->maketag();
      if (ch[1]) ch[1]->maketag();
      rev = false;
    }
  }
  void pushup() {
    sz = 1;
    for (auto u : ch) if (u != nullptr) {
      sz += u->sz;
    }
  }
  
  inline int GetSon() { return fa->ch[1] == this; }
  inline bool IsRot() { return (fa == nullptr) || (fa->ch[GetSon()] != this); }

  void rotate(const int x) {
    auto nt = ch[x];
    ch[x] = nt->ch[x ^ 1];
    nt->ch[x ^ 1] = this;
    if (ch[x]) ch[x]->fa = this;
    if (!IsRot()) fa->ch[GetSon()] = nt;
    nt->fa = fa; fa = nt;
    pushup(); nt->pushup();
  }

  void splay() {
    static Node *stk[maxm];
    int top = 0;
    auto u = this;
    while (true) {
      u->updf();  // 在这里跳 lnk 即可。
      stk[++top] = u;
      if (u->IsRot()) break;
      u = u->fa;
    }
    while (top) stk[top--]->pushdown();
    while (!IsRot()) {
      if (fa->IsRot()) {
        fa->rotate(GetSon());
      } else {
        auto pa = fa->fa;
        int k1 = GetSon(), k2 = fa->GetSon();
        if (k1 == k2) {
          pa->rotate(k2);
          fa->rotate(k1);
        } else {
          fa->rotate(k1);
          fa->rotate(k2);
        }
      }
    }
  }
};
Node Mem[maxm], *pool = Mem, *node[maxm];
inline Node* New() { 
  pool->id = pool - Mem + 1;
  return pool++; 
}

void beginning() {
  for (int i = 1; i <= n; ++i) {
    node[i] = New();
  }
}

std::vector<int> e[maxn];
void dfs(const int u, const int fa) {
  node[u]->fa = node[fa];
  for (auto v : e[u]) if (v != fa) {
    dfs(v, u);
  }
}

int ufs[maxm], rnk[maxm];
int find(const int x) { return (ufs[x] == x) ? ufs[x] : ufs[x] = find(ufs[x]); }

void unionn(int u, int v) {
  if (rnk[u] > rnk[v]) std::swap(u, v);
  ufs[u] = v;
  rnk[v] += rnk[u] == rnk[v];
}

std::vector<int> nct[maxn], cut[maxn];

void Init() {
  qr(n); qr(m);
  for (int i = 1; i <= n; ++i) {
    rnk[ufs[i] = i] = 1;
  }
  for (int u, v, x, y; m; --m) {
    qr(u); qr(v);
    if (u > v) std::swap(u, v);
    nct[u].push_back(v);
  }
  m = ocnt;
  int x, u, v;
  for (qr(x); x != -1; qr(x)) {
    qr(u); qr(v);
    if (u > v) std::swap(u, v);
    opt[++ocnt] = {x, u, v};
    if (x == 0) {
      cut[u].push_back(v);
    }
  }
  for (int u = 1, i, j; u <= n; ++u) {
    std::sort(nct[u].begin(), nct[u].end());
    std::sort(cut[u].begin(), cut[u].end());
    auto x = cut[u].begin();
    for (auto v : nct[u]) {
      while ((x != cut[u].end()) && (*x < v)) ++x;
      if ((x != cut[u].end()) && (v == *x)) continue;
      if ((i = find(u)) != (j = find(v))) {
        e[u].push_back(v);
        e[v].push_back(u);
        unionn(i, j);
      } else {
        opt[++ocnt] = {0, u, v};
      }
    }
  }
  beginning();
  dfs(1, 0);
  std::reverse(opt + 1, opt + ocnt + 1);
}

void access(Node *u) {
  for (Node *v = nullptr; u; u = (v = u)->fa) {
    u->splay();
    u->ch[1] = v;
    u->pushup();
  }
}

void makeroot(Node *u) {
  access(u);
  u->splay();
  u->maketag();
}

Node *bel[maxm];
void dfs(Node *const u, Node *const v) {
  unionn(find(u->id), find(v->id));
  u->pushdown();
  for (auto p : u->ch) if (p != nullptr) {
    dfs(p, v);
  }
  u->lnk = v;
}

int ncnt;
std::vector<int> ans;
void Solve() {
  ncnt = n;
  for (int i = 1; i <= n; ++i) {
    bel[i] = node[i];
    rnk[ufs[i] = i] = 1;
  }
  for (int i = 1, x, y; i <= ocnt; ++i) if (opt[i].op == 0) {
    if ((x = find(opt[i].u)) == (y = find(opt[i].v))) continue;
    auto u = bel[x], v = bel[y];
    makeroot(u); 
    access(v); v->splay();
    node[++ncnt] = New();
    rnk[ufs[ncnt] = ncnt] = 1;
    dfs(v, node[ncnt]);
    bel[find(ncnt)] = node[ncnt];
    node[ncnt]->fa = v->fa;
  } else {
    x = opt[i].u, y = opt[i].v;
    auto u = bel[find(x)], v = bel[find(y)];
    makeroot(u); 
    access(v); 
    v->splay();
    ans.push_back(v->sz - 1);
  }
  std::reverse(ans.begin(), ans.end());
  for (auto u : ans) {
    qw(u, '\n');
  }
}

} // namespace Fusu
```



---

## 作者：zhengrunzhe (赞：5)

### Tarjan:e-dcc缩点+ 树剖+线段树/并查集

### 先说一个比较简单的版本[poj3694 Network](http://poj.org/problem?id=3694)

题意：每次**增加一条边**，求图中**桥的数量**

首先进行一遍Tarjan求出所有的边双联通分量，然后**缩点成树**

得出初始图的桥的数量为树的边数即**tot(边双数量)-1**记作ans0

考虑添加一条边(x,y) (若用dcc[i]表示编号为i所在的双联通分量的编号)

#### 1.dcc[x]==dcc[y]

两点同处于一个边双中，显然不会对图的桥数有影响

#### 2.dcc[x]!=dcc[y]

**dcc[x]与dcc[y]路径上的所有边都不会再是桥**

考虑一种**暴力**的做法

先求出dcc[x]与dcc[y]的lca

然后暴力从dcc[x]暴力一个个跳到lca，跳过的点(除lca)若没有被标记则标记vis[i]=1

在同样地从dcc[y]往上跳，两次过程**标记到的点数则是减少的桥的数量(同时也是当前两点间桥的数量)**记作△ans

每次输出ans0=ans0-△ans

~~不过貌似poj能给过~~

**考虑更加优秀的做法**

每次有可能会跳过已经标记过的点，考虑**并查集**把已经标记过的压缩起来，每次跳的时候直接跳到集合的顶端就行了

另一种做法可以利用**树剖+线段树**，刚开始所有树边权都为1，每次先路径求和，为减少的桥数，然后把路径上的所有边权都改为0

### 现在回到这道题目

题意：每次**断掉一条边**，求**两点间桥数**

同样的，如果离线操作，把所有的操作先存下来，然后**倒序**，**断掉一条边的操作就变成了增加一条边**，就转化成了刚刚的那道题，两点间的桥数便是△ans

首先先建一幅**由没有被断掉的边构成的图**(因为保证无论航线如何被破坏，任意时刻任意两个星球都能够相互到达，所以建出的图一定连通)，进行缩点成树

然后倒序处理每一个操作，这里采用线段树，断边就是加边，路径边权赋0，询问就输出路径和

可以用一个map表示边是否被断掉，由于有重边~~(我一开始没想重边的wa了n编)~~，应存边(a,b)被删去的次数，因为可能有多条(a,b)，对于原图中的每一条边(a,b)，若map[(a,b)]>0(代表这条边会被删去)就把map[(a,b)]--，否则说明这条边不会被删去，就连接(a,b)
```cpp
#include<map>
#include<stack>
#include<cstdio>
#include<algorithm>
using namespace std;
template<class type>inline const void read(type &in)
{
    in=0;char ch=getchar();short fh=1;
    while (ch<48||ch>57)fh=ch=='-'?-1:fh,ch=getchar();
    while (ch>47&&ch<58)in=(in<<3)+(in<<1)+ch-48,ch=getchar();
    in*=fh;
}
const int N=3e4+10,M=1e5+10,Q=4e4+10;
int n,m,a[M],b[M];
stack<int>ans;
map<pair<int,int>,int>e;
struct question{int u,v,type;}q[Q]; //存储每个询问信息
class Edge
{
    private:
        int cnt;
    public:
        int head[N],to[M<<1],next[M<<1];
        inline const void addedge(int u,int v)
        {
            next[++cnt]=head[u];
            head[u]=cnt;
            to[cnt]=v;
        }
        inline const void connect(int u,int v)
        {
            addedge(u,v);
            addedge(v,u);
        }
}g,t;
class Double_Connected_Component //边双处理
{
    private:
        stack<int>s;
        int dfn[N],low[N],cnt;
    public:
    	int dcc[N],tot;
    protected:
        inline const void tarjan(int u,int fa)
        {
            dfn[u]=low[u]=++cnt;s.push(u);int v;
            for (int i=g.head[u];i;i=g.next[i])
                if ((v=g.to[i])!=fa)
                    if (!dfn[v])tarjan(v,u),low[u]=min(low[u],low[v]);
                    else if (!dcc[v])low[u]=min(low[u],dfn[v]);
            if (low[u]!=dfn[u])return;tot++;
            do v=s.top(),s.pop(),dcc[v]=tot;while (u!=v);
        }
    public:
        inline const void tarjan()
        {
            for (int i=1;i<=n;i++)
                if (!dfn[i])
                    tarjan(i,0);
        }
        inline const void rebuild() //缩点成树
        {
            for (int i=1;i<=n;i++)
                for (int u,v,j=g.head[i];j;j=g.next[j])
                    if ((u=dcc[i])!=(v=dcc[g.to[j]]))
                        t.addedge(u,v);
        }
}dcc;
class Segment_Tree  //线段树(指针)
{
    private:
        struct tree
        {
            int sum;
            bool tag;
            tree *lson,*rson;
            inline const void pushup()
            {
                sum=lson->sum+rson->sum;
            }
            inline const void cover()
            {
                tag=1;sum=0;
            }
            inline const void pushdown()
            {
                if (!tag)return;
                lson->cover();
                rson->cover();
                tag=0;
            }
            inline const void update(int l,int r,int L,int R)
            {
                if (l>R||r<L)return;
                if (l>=L&&r<=R)return cover();
                pushdown();
                int mid=l+r>>1;
                lson->update(l,mid,L,R);
                rson->update(mid+1,r,L,R);
                pushup();
            }
            inline const int query(int l,int r,int L,int R)
            {
                if (l>R||r<L)return 0;
                if (l>=L&&r<=R)return sum;
                pushdown();
                int mid=l+r>>1;
                return lson->query(l,mid,L,R)+rson->query(mid+1,r,L,R);
            }
        }memory_pool[N<<2],*tail;
        inline const void init()
        {
            tail=memory_pool;
        }
        inline tree *spawn()
        {
            tree *p=tail++;
            p->tag=p->sum=0;
            p->lson=p->rson=NULL;
            return p;
        }
    public:
        tree *root;
        inline Segment_Tree(){init();}
        inline const void build(tree *&p,int l,int r)
        {
            p=spawn();
            if (l==r)return (void)(p->sum=(l!=1)); //边权转点权，1号点(根节点)上面没有边，权值为0
            int mid=l+r>>1;
            build(p->lson,l,mid);
            build(p->rson,mid+1,r);
            p->pushup();
        }
}sgt;
class Heavy_Light_Decomposition //树剖
{
    private:
        int size[N],top[N],fa[N],dep[N],dfn[N],wson[N],cnt;
    public:
        inline const void dfs(int p)
        {
            size[p]=1;
            for (int i=t.head[p];i;i=t.next[i])
            {
                int son=t.to[i];
                if (son==fa[p])continue;
                fa[son]=p;dep[son]=dep[p]+1;
                dfs(son);size[p]+=size[son];
                if (size[son]>size[wson[p]])wson[p]=son;
            }	
        }
        inline const void dfs(int p,int tp)
        {
            top[p]=tp;dfn[p]=++cnt;
            if (wson[p])dfs(wson[p],tp);
            for (int son,i=t.head[p];i;i=t.next[i])
                if (!dfn[son=t.to[i]])
                    dfs(son,son);
        }
        inline const void update(int a,int b)
        {
            while (top[a]^top[b])
            {
                if (dep[top[a]]<dep[top[b]])swap(a,b);
                sgt.root->update(1,dcc.tot,dfn[top[a]],dfn[a]);
                a=fa[top[a]];
            }
            if (dep[a]>dep[b])swap(a,b);
            sgt.root->update(1,dcc.tot,dfn[a]+1,dfn[b]);
        }
        inline const int query(int a,int b)
        {
            int ans=0;
            while (top[a]^top[b])
            {
                if (dep[top[a]]<dep[top[b]])swap(a,b);
                ans+=sgt.root->query(1,dcc.tot,dfn[top[a]],dfn[a]);
                a=fa[top[a]];
            }
            if (dep[a]>dep[b])swap(a,b);
            return ans+sgt.root->query(1,dcc.tot,dfn[a]+1,dfn[b]);
        }
}hld;
int main()
{
    read(n);read(m);
    for (int i=1;i<=m;i++)read(a[i]),read(b[i]);
    int qtot;
    for (qtot=1;read(q[qtot].type),~q[qtot].type;qtot++)
    {
        read(q[qtot].u);read(q[qtot].v);
        if (q[qtot].type)continue;
        e[make_pair(q[qtot].u,q[qtot].v)]++;
		e[make_pair(q[qtot].v,q[qtot].u)]++; //无向图，反过来的也要更改
	}
    for (int i=1;i<=m;i++)
        if (e.find(make_pair(a[i],b[i]))!=e.end()&&e[make_pair(a[i],b[i])])
			e[make_pair(a[i],b[i])]--,e[make_pair(b[i],a[i])]--;
		else g.connect(a[i],b[i]);
    dcc.tarjan();dcc.rebuild();
    hld.dfs(1);hld.dfs(1,1);
    sgt.build(sgt.root,1,dcc.tot);
    for (int i=qtot-1;i;i--)
        if (q[i].type)ans.push(hld.query(dcc.dcc[q[i].u],dcc.dcc[q[i].v])); //由于是倒序处理，所以输出也要倒过来，因为tarjan缩点的时候会用到栈，干脆也用栈来实现倒序好了
        else hld.update(dcc.dcc[q[i].u],dcc.dcc[q[i].v]);
    while (ans.size())printf("%d\n",ans.top()),ans.pop();
    return 0;
}
```

---

## 作者：Mars_Dingdang (赞：3)

动态树维护双连通分量（所以标签中的 `强连通分量` 错了）。

## 题目大意
给出一张 $n$ 个节点 $m$ 条边的无向连通图，给出若干次操作，每次操作为下面两种之一：

0. 将 $(u, v)$ 之间的连边切断；
1. 询问 $u\to v$ 的路径上有多少条必经边（“关键航线”，即桥边）。

## 大体思路
参考 [P1197 星球大战](https://www.luogu.com.cn/problem/P1197) 可知，加边维护连通性显然比删边更加容易，因此我们将所有操作离线，倒序处理。此外，本题需要求桥边的数量，实际上就是按边双连通分量缩点以后形成的数上两点间的距离。我们考虑利用 LCT 维护这棵缩点后形成的树。

对于一次 $op=0$ 的操作，倒序处理后变为加边操作。如果加边前 $x, y$ 不连通，则这是一次 LCT 中常规的 $\operatorname{link}$ 操作；否则，说明链 $x\to y$ 形成了一个环，需要将环缩点。具体地，我们并查集维护每个节点所属的双连通分量的编号，初始 $fa_i=i$。通过 $\text{dfs}$ 修改 $fa$ 并递归缩点即可。最后，需要删除被缩掉的点。由于 $\text{link}$ 操作首先要 $\text{makeroot}(x)$，只需删去 $x$ 的右子树并更新即可。

同理，最初连接所有未被删除的边也用这种方法。

对于一次 $op=1$ 的操作，我们分理处 $x, y$ 所在的双连通分量 $x', y'$ 形成的链条，答案为链条长度，即节点数 $-1$。最后倒序处理答案即可。

需要注意的是，本题中所有的伸展树之间跳跃均是指双连通分量的编号，因此 $\text{access}(x)$ 的操作中需要更新 $x, \text{fa\_tree}(x)\leftarrow \text{find}(fa_x)$。

由于所有点最多被删除一次，删除操作均摊 $O(1)$，$\text{access}$ 与并查集复杂度相当，也是 $O(\log n)$，因此总复杂度 $O(q\log n)$。

## 完整代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define rep(ii,aa,bb) for(re int ii = aa; ii <= bb; ii++)
#define Rep(ii,aa,bb) for(re int ii = aa; ii >= bb; ii--)
typedef long long ll;
typedef unsigned long long ull;
typedef double db;
typedef pair<int, int> PII;
const int maxn = 1e5 + 5;
namespace IO_ReadWrite {
	#define re register
	#define gg (p1 == p2 && (p2 = (p1 = _buf) + fread(_buf, 1, 1<<21, stdin), p1 == p2) ? EOF :*p1++)
	char _buf[1<<21], *p1 = _buf, *p2 = _buf;
	template <typename T>
	inline void read(T &x){
		x = 0; re T f=1; re char c = gg;
		while(c > 57 || c < 48){if(c == '-') f = -1;c = gg;}
		while(c >= 48 &&c <= 57){x = (x<<1) + (x<<3) + (c^48);c = gg;}
		x *= f;return;
	}
	inline void ReadChar(char &c){
		c = gg;
		while(!isalpha(c)) c = gg;
	}
	template <typename T>
	inline void write(T x){
		if(x < 0) putchar('-'), x = -x;
		if(x > 9) write(x/10);
		putchar('0' + x % 10);
	}
	template <typename T>
	inline void writeln(T x){write(x); putchar('\n');}
}
using namespace IO_ReadWrite;
int n, m, q;
struct node {
	int son[2], fa, rev, sz;
	#define son(u, c) tr[u].son[c]
} tr[maxn];
int fa[maxn], ans[maxn], op[maxn];
bool del[maxn];
PII e[maxn], p[maxn];
inline int find(int k) {
	return (k == fa[k] ? k : fa[k] = find(fa[k]));
}
inline bool isroot(int x) {
	return (son(tr[x].fa, 0) != x) && (son(tr[x].fa, 1) != x);
}
inline void pushup(int x) {
	tr[x].sz = tr[son(x, 0)].sz + tr[son(x, 1)].sz + 1;
}
inline void push_rev(int x) {
	if(!x) return ;
	swap(son(x, 0), son(x, 1));
	tr[x].rev ^= 1;
}
inline void pushdown(int x) {
	if(tr[x].rev) {
		push_rev(son(x, 0));
		push_rev(son(x, 1));
		tr[x].rev = 0;
	}
}
inline void rotate(int x) {
	int y = tr[x].fa, z = tr[y].fa;
	int c = (son(y, 0) == x);
	son(y, c ^ 1) = son(x, c); tr[son(x, c)].fa = y;
	tr[x].fa = z;
	if(!isroot(y)) son(z, son(z, 1) == y) = x;
	son(x, c) = y, tr[y].fa = x;
	pushup(y); pushup(x);
}
int stk[maxn], top;
inline void splay(int x) {
	int u = x;
	stk[top = 1] = u;
	while(!isroot(u)) stk[++top] = u = tr[u].fa;
	while(top) pushdown(stk[top --]);
	while(!isroot(x)) {
		int y = tr[x].fa, z = tr[y].fa;
		if(!isroot(y))
			if((son(y, 0) == x) ^ (son(z, 0) == y)) rotate(x);
			else rotate(y);
		rotate(x);
	}
}
inline void access(int x) {
	int X = x;
	for(int y = 0; x; y = x, x = tr[x].fa = find(tr[x].fa)) {
		splay(x);
		son(x, 1) = y;
		pushup(x);
	}
	splay(X);
}
inline void makeroot(int x) {
	access(x);
	push_rev(x);
}
inline int findroot(int x) {
	access(x); pushdown(x);
	while(son(x, 0)) pushdown(x = son(x, 0));
	splay(x);
	return x;
}
inline void split(int x, int y) {
	makeroot(x);
	access(y);
}
inline void dfs(int x, int f) { // 递归缩点
	if(!x) return ;
	fa[x] = f;
	dfs(son(x, 0), f), dfs(son(x, 1), f);
}
inline void link(int x, int y) {
	x = find(x), y = find(y);
	if(x == y) return ; // 已经缩点
	makeroot(x);
	if(findroot(y) != x) tr[x].fa = y; // link
	else { // 暴力缩点
		dfs(son(x, 1), x);
		son(x, 1) = 0; // 删除
		pushup(x);
	}
}
int main () {
	read(n); read(m);
	rep(i, 1, n) tr[i].sz = 1, fa[i] = i;
	rep(i, 1, m) {
		int u, v;
		read(u); read(v);
		if(u > v) swap(u, v);
		e[i] = {u, v};
	}
	sort(e + 1, e + m + 1);
	for(int i = 1; 1; i ++) {
		read(op[i]);
		if(op[i] == -1) break;
		q ++;
		int x, y;
		read(x); read(y);
		if(op[i] == 0) {
			if(x > y) swap(x, y);
			int id = lower_bound(e + 1, e + m + 1, make_pair(x, y)) - e;
			del[id] = 1;
		} 
		p[i] = {x, y};
	}
	rep(i, 1, m) 
		if(!del[i]) link(e[i].first, e[i].second);
	Rep(i, q, 1) {
		int x = find(p[i].first), y = find(p[i].second);
		if(op[i] == 0) link(x, y);
		else {
			split(x, y);
			ans[++ans[0]] = tr[y].sz - 1;
		}
	}
	Rep(i, ans[0], 1) writeln(ans[i]);
	return 0;
}
```

---

## 作者：SrsgPrince_ (赞：2)

# Luogu P2542 [AHOI2005] 航线规划 题解

题面传送门：[P2542 航线规划](https://www.luogu.com.cn/problem/P2542)。

建议在 [博客](https://www.luogu.com.cn/blog/fy123333/LuoguP2542Solution) 中阅读。~~同时也顺便看看我之前写的博客~~。

## 题目分析 Hint

说明中提示了：无论航线如何被破坏，任意时刻任意两个星球都能够相互到达。在整个数据中，任意两个星球之间最多只可能存在一条直接的航线。且询问次数较少。所以我们用一个线段树+树链剖分。

## 思路 Solution

题目保证不存在重边，而且互相连通，又是无向图，所以我们可以知道缩点之后的图就是一棵树。也就是说，动态地维护树上的距离就可以了。因为要动态地维护，所以也可以用动态树解决，所以有一些大佬用 Link Cut Tree 做，也是可以的，而且我自己写的 LCT 的代码其实比这个线段树+树剖要少，只是 LCT 这个知识有点难。话说回来，树上两点之间连起来的是边，所以是要维护两点之间的边权。那么很自然地想到树链剖分，而且不用动态缩点。

先来讲一个重要的知识：**树链剖分**。

对于树上任意一个节点 $u$，设 $siz_u$ 是 $u$ 所在的子树的大小。在 $u$ 的孩子中，设 $u$ 子树的最大孩子 $wc_u$ (weightChild)，称为 $u$ 的重儿子。假设先访问重儿子，再访问轻儿子，从根节点起开始进行 `dfs()`，记录此时的 dfs 序。能发现 $u$ 和 $wc_u$ 在 dfs 序上是连续的。

如果一个节点是它父节点的重儿子，我们就叫它重节点，否则就是轻节点（根是轻节点）。从一个非重节点开始，向下访问它的重儿子，再递归下去，一直到叶子节点，构成一条链。这条链上的节点在 dfs 序上是连续的，并除了第一个节点之外是重节点，那么这条链就是树的重链。否则就是轻边。

![](https://cdn.luogu.com.cn/upload/image_hosting/2qxnltvw.png)

在上图中 $1-2-6-9$ 是一条重链，$5-8$ 也是。细线是轻边。而观察这张图能发现，任意两个重链中间有至少一条轻边连接。于是就有任意一个节点到根的路径上经过的重链条数不会超过路径上轻边数减 $1$。那么就有定理 1：它到根的路径上的重链条数不会超过 $\log n$，轻边的数量也不会超过 $\log n$。

那么就可以从这个定理得出：对于一个从 $x$ 到 $y$ 的修改，设 $w$ 是 $x, y$ 的 LCA，把修改的路径拆成两条：$x-w$ 和 $w-y$，然后能看出只要做出 $O(\log n)$ 次的区间修改就能完成了。

具体实现过程就是记录每一个重链的链头 $top$，设 $dfn_u$ 为 $u$ 在 dfs 序的下标，那么只需要修改 $[dfn_x, dfn_{top_x}]$ 的点权，然后令 $x$ 为链头的父节点。重复操作知道 $w$ 在当前的链上，那么只要修改 $w-x$ 这段区间 $[dfn_x, dfn_w]$ 就可以了。

最后来梳理一下过程：

1. 输入所有操作。
2. 离线逆序处理。
3. 随便在图上生成树，正常来说用的是 dfs 序（因为这个会舒服一点）。
4. 更新边权。
5. 经典树链剖分。

## 注意事项 Notice

这里面可能会有误删的边，所以要加第三遍   `dfs3()`，把误删的边加回来。

## 代码部分 Code

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 4e4 + 10, maxm = 1e5 + 10;
int n, m, a, b, x, y, z, cnt1, cnt2, cnt3, total;
int res[maxn], head[maxn], siz[maxn], fa[maxn], depth[maxn], son[maxn], id[maxn], top[maxn], tree[maxn << 2], lazyTag[maxn << 2];
// 此处省略快读快写的实现
struct SegmentTree {
    int v, nxt, dist;
}segTree[maxm << 1];
struct Node {
    int oper, a, b;
}q[maxn];
inline void add(int u, int v) {
    segTree[++cnt2] = (SegmentTree){v, head[u]};
    head[u] = cnt2;
}
inline void pushUp(int root) {
    tree[root] = tree[root << 1] + tree[root << 1 | 1];
}
inline void pushDown(int root) {
    lazyTag[root << 1] = lazyTag[root << 1 | 1] = 1;
    tree[root << 1] = tree[root << 1 | 1] = lazyTag[root] = 0;
}
inline void buildTree(int lft, int rgt, int root) {
    if (lft == rgt){
        tree[root] = 1;
        return;
    }
    int mid = (lft + rgt) >> 1;
    buildTree(lft, mid, root << 1);
    buildTree(mid+1, rgt, root << 1 | 1);
    pushUp(root);
}
inline void update(int lft, int rgt, int l, int r, int root) {
    if (lft <= l && r <= rgt) {
        tree[root] = 0, lazyTag[root] = 1;
        return;
    }
    if (lazyTag[root]) pushDown(root);
    int mid = (l + r) >> 1;
    if (lft <= mid){
        update(lft, rgt, l, mid, root << 1);
    }
    if (mid < rgt){
        update(lft, rgt, mid+1, r, root << 1 | 1);
    }
    pushUp(root);
}
inline int query(int lft, int rgt, int l, int r, int root) {
    if (lft <= l && r <= rgt) {
        return tree[root];
    }
    if (lazyTag[root]) {
        pushDown(root);
    }
    int mid = (l + r) >> 1, sum = 0;
    if (lft <= mid) {
        sum += query(lft, rgt, l, mid, root << 1);
    }
    if (mid < rgt) {
        sum += query(lft, rgt, mid+1, r, root << 1 | 1);
    }
    return sum;
}
// 上面真的就是线段树的板子，几乎一点不带改的
inline void dfs1(int u, int va) { // 第一遍 DFS 用来建树
    fa[u] = va;
    siz[u] = 1;
    depth[u] = depth[va]+1;
    for (int i = head[u];~i;i = segTree[i].nxt) {
        int v = segTree[i].v;
        if (siz[v] || segTree[i].dist) continue;
        dfs1(v, u);
        siz[u] += siz[v];
        if (siz[son[u]] < siz[v]) {
            son[u] = v;
        }
    }
}
inline void dfs2(int u, int an) { // 第二遍则是树剖
    id[u] = ++cnt1;
    top[u] = an;
    if (!son[u]) return;
    dfs2(son[u], an);
    for (int i = head[u];~i;i = segTree[i].nxt){
        int v = segTree[i].v;
        if (fa[v] != u || v == son[u] || segTree[i].dist) continue;
        dfs2(v, v);
    }
}
inline void dfs3(int u) { // 补回之前误删的边
    for (int i = head[u];~i;i = segTree[i].nxt) {
        int v = segTree[i].v;
        if (segTree[i].dist) continue;
        if (fa[v] == u) dfs3(v);
        else {
            if (depth[u] < depth[v]) {
                mark(u, v);
            }
        }
    }
}
inline void mark(int a, int b) {
    while (top[a] != top[b]) {
        if (depth[top[a]] < depth[top[b]]) {
            swap(a, b);
        }
        update(id[top[a]], id[a], 1, n, 1);
        a = fa[top[a]];
    }
    if(depth[a] < depth[b]){
        swap(a, b);
    }
    update(id[b]+1, id[a], 1, n, 1);
}
int main() {
    n = quickRead(), m = quickRead();
    memset(head, -1, sizeof(head));
    for (int i = 1;i <= m;++i){
        a = quickRead(), b = quickRead();
        addEdge(a, b), addEdge(b, a);
    }
    for (;;) {
        x = quickRead();
        if (x == -1) break;
        y = quickRead(), z = quickRead();
        q[++cnt3] = (Node){x, y, z};
        if (x) continue;
        for (int i = head[y];~i;i = segTree[i].nxt) {
            if (segTree[i].v == z) {
                segTree[i].dist = 1;
                break;
            }
        }
        for (int i = head[z];~i;i = segTree[i].nxt) {
            if (segTree[i].v == y) {
                segTree[i].dist = 1;
                break;
            }
        }
    }
    dfs1(1, 0);
    dfs2(1, 1);
    buildTree(1, n, 1);
    dfs3(1);
    for (int i = cnt3;i >= 1;--i){
        a = q[i].a, b = q[i].b;
        if (!q[i].oper) {
			mark(a, b), res[i] = -1;
        } else {
			while (top[a] != top[b]) {
				if (depth[top[a]] < depth[top[b]]) swap(a, b);
			    res[i] += query(id[top[a]], id[a], 1, n, 1);
				a = fa[top[a]];
			}
			if (depth[a] < depth[b]) swap(a, b);
			res[i] += query(id[b]+1, id[a], 1, n, 1); 
		}
    }
    for (int i = 1;i <= cnt3;++i) {
        if (res[i] != -1) quickWrite(res[i], '\n');
    }
    return 0;
}
```

本蒟蒻的第一篇题解（喜）。


---

## 作者：Messywind (赞：2)

**题意**

给定一个 $n$ 个点 $m$ 条边的图，有不超过 $40000$ 次的操作，每次操作有三个参数 $op, u, v$

若 $op =0$ ，表示删除点 $u,v$ 之间的边

若 $op = 1$，表示询问 $u, v$ 之间有多少**关键边**

**关键边：** $u, v$ 联通，若删除该边 $u, v$ 不连通，则为关键边

**分析：**

最朴素的想法是每次删完边之后 $\text{tarjan}$ 缩点，再维护树上两点距离，但这样显然会超时。

所以考虑逆序离线处理。

我们发现如果是一棵树，那么所有的边都是关键边，$u, v$ 两点的关键边数量就等于 $u, v$ 树上两点距离。并且在树上任意两点加一条边都会形成一个环，环内所有的边都不可能成为关键边，所以此时只需要将这两点路径上的每一条边的权值都变为 $0$ ，这个操作可以用树链剖分线段树维护。

先在图中随意找一颗生成树，可以用并查集维护，把这些树边标记一下，那么其他未标记的边就是要成环的边，也就是要进行路径上赋值为 $0$ 的点对。

之后读入操作，把要删除的边以点对的形式用 $\text{STL map}$ 维护，这些点对相当于**覆盖**一开始要进行路径上赋值为 $0$ 的点对，最后逆序地处理询问，逆序输出结果即可。

## 代码：

```cpp
#include <bits/stdc++.h>
#define int long long
#define x first
#define y second
#define PII pair<int, int>
using namespace std;
const int N = 1e5 + 5, M = N << 1;
int n, m, u[N], v[N], op, cnt, h[N], e[M], ne[M], idx, Size[N], top[N], dep[N], fa[N], son[N], id[N], Cnt, p[N];
bool st[N];
map<PII, int> mp;
vector<int> ans;
struct Query {
    int op, u, v;
} q[N];
struct SegmentTree {
    int l, r, add, sum;
} tr[N << 2];
int find(int x) {
    return p[x] == x ? p[x] : p[x] = find(p[x]);
}
void add(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}
void dfs1(int u, int father, int depth) {
    dep[u] = depth, fa[u] = father, Size[u] = 1;
    for (int i = h[u]; ~i; i = ne[i]) {
        int j = e[i];
        if (j == father) continue;
        dfs1(j, u, depth + 1);
        Size[u] += Size[j];
        if (Size[son[u]] < Size[j]) son[u] = j;
    }
}
void dfs2(int u, int t) {
    id[u] = ++ Cnt, top[u] = t;
    if (!son[u]) return ;
    dfs2(son[u], t);
    for (int i = h[u]; ~i; i = ne[i]) {
        int j = e[i];
        if (j == fa[u] || j == son[u]) continue;
        dfs2(j, j);
    }
}
void pushup(int u) {
    tr[u].sum = tr[u << 1].sum + tr[u << 1 | 1].sum;
}
void pushdown(int u) {
    if (tr[u].add != -1) {
        tr[u << 1].add = tr[u << 1 | 1].add = tr[u].add;
        tr[u << 1].sum = (tr[u << 1].r - tr[u << 1].l + 1) * tr[u].add;
        tr[u << 1 | 1].sum = (tr[u << 1 | 1].r - tr[u << 1 | 1].l + 1) * tr[u].add;
        tr[u].add = -1;
    }
}
void build(int u, int l, int r) {
    if (l == r) {
        tr[u] = {l, r, -1, 1};
    } else {
        tr[u] = {l, r, -1};
        int mid = l + r >> 1;
        build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }
}
void modify(int u, int l, int r, int c) {
    if (tr[u].l >= l && tr[u].r <= r) {
        tr[u].add = c;
        tr[u].sum = (tr[u].r - tr[u].l + 1) * c;
        return ;
    }
    pushdown(u);
    int mid = tr[u].l + tr[u].r >> 1;
    if (l <= mid) modify(u << 1, l, r, c);
    if (r > mid) modify(u << 1 | 1, l, r, c);
    pushup(u);
}
int ask(int u, int l, int r) {
    if (tr[u].l >= l && tr[u].r <= r) return tr[u].sum;
    pushdown(u);
    int mid = tr[u].l + tr[u].r >> 1, res = 0;
    if (l <= mid) res += ask(u << 1, l, r);
    if (r > mid) res += ask(u << 1 | 1, l, r);
    return res;
}
void modify_path(int u, int v, int k) {
    while (top[u] != top[v]) {
        if (dep[top[u]] < dep[top[v]]) swap(u, v);
        modify(1, id[top[u]], id[u], k);
        u = fa[top[u]];
    }
    if (dep[u] < dep[v]) swap(u, v);
    modify(1, id[v] + 1, id[u], k);
}
int ask_path(int u, int v) {
    int res = 0;
    while (top[u] != top[v]) {
        if (dep[top[u]] < dep[top[v]]) swap(u, v);
        res += ask(1, id[top[u]], id[u]);
        u = fa[top[u]];
    }
    if (dep[u] < dep[v]) swap(u, v);
    res += ask(1, id[v] + 1, id[u]);
    return res;
}
signed main() {
    memset(h, -1, sizeof h);
    cin >> n >> m;
    for (int i = 1; i <= n; i ++) p[i] = i;
    for (int i = 1; i <= m; i ++) cin >> u[i] >> v[i];
    for (int i = 1; i <= m; i ++) {
        int pu = find(u[i]), pv = find(v[i]);
        if (pu != pv) {
            p[pu] = pv;
            add(u[i], v[i]), add(v[i], u[i]);
            st[i] = 1;
        }
    }
    dfs1(1, -1, 1), dfs2(1, 1);
    build(1, 1, n);
    while (1) {
        cin >> op;
        if (op == -1) break;
        cnt ++;
        q[cnt].op = op;
        cin >> q[cnt].u >> q[cnt].v;
    }
    for (int i = 1; i <= cnt; i ++) {
        if (!q[i].op) {
            mp[{q[i].u, q[i].v}] = mp[{q[i].v, q[i].u}] = 1;
        }
    }
    for (int i = 1; i <= m; i ++) {
        if (!st[i] && !mp[{u[i], v[i]}]) {
            modify_path(u[i], v[i], 0);
        }
    }
    for (int i = cnt; i; i --) {
        if (!q[i].op) {
            modify_path(q[i].u, q[i].v, 0);
        } else if (q[i].op == 1) {
            ans.push_back(ask_path(q[i].u, q[i].v));
        }
    }
    for (int i = ans.size() - 1; ~i; i --) cout << ans[i] << endl;
}
```

---

## 作者：Coros_Trusds (赞：2)

# 题目大意

对 $\rm Samuel$ 星球的探险已经取得了非常巨大的成就，于是科学家们将目光投向了 $\rm Samuel$ 星球所在的星系——一个巨大的由千百万星球构成的 $\rm Samuel$ 星系。

星际空间站的 $\rm Samuel$ II 巨型计算机经过长期探测，已经锁定了 $\rm Samuel$ 星系中 $n$ 个星球的空间坐标，并对这些星球以 $1$ 至 $n$ 依次编号。

一些先遣飞船已经出发，在星球之间开辟探险航线。

探险航线是双向的，例如从 $1$ 号星球到 $3$ 号星球开辟探险航线，那么从 $3$ 号星球到 $1$ 号星球也可以使用这条航线。

例如下图所示：

 ![](https://cdn.luogu.com.cn/upload/pic/1644.png) 

在 $5$ 个星球之间，有 $5$ 条探险航线。

$A,B$ 两星球之间，如果某条航线不存在，就无法从 $A$ 星球抵达 $B$ 星球，我们则称这条航线为关键航线。

显然上图中，$1$ 号与 $5$ 号星球之间的关键航线有 $1$ 条：即为 $4\leftrightarrow5$ 航线。

然而，在宇宙中一些未知的磁暴和行星的冲撞，使得已有的某些航线被破坏，随着越来越多的航线被破坏，探险飞船又不能及时恢复这些航线，可见两个星球之间的关键航线会越来越多。

假设在上图中，航线 $4\leftrightarrow2$（从 $4$ 号星球到 $2$ 号星球）被破坏。此时，$1$ 号与 $5$ 号星球之间的关键航线就有 $3$ 条：$1 \leftrightarrow 3$，$3 \leftrightarrow 4$，$4 \leftrightarrow 5$。

小联的任务是，不断关注航线被破坏的情况，并随时给出两个星球之间的关键航线数目。现在请你帮助完成。

# 题目分析

删边不是很好写，但是如果是加边就好办了，所以我们把所有操作离线下来，倒序处理。这样如果要删一条边就变成了加一条边，最后加成题目给出的边，故我们可以标记那些边是会被删除的（也就是当前的图还没加上去的边）。

为方便，当前一步一步跟着操作正在变化的图叫 $G$，最终的图（题目给出的图）叫 $G'$。**注意我们的 $G'$ 不一定是一棵树，所以树链剖分的两个 $\verb!dfs!$ 需要改改。**

然后我们发现，求两个点之前的关键路线，可以转化为简单的树上操作：树上两点间的求和。为什么可以这么转化？首先 $G'$ 中的所有环内的边长度为 $0$，其他边长度为 $1$。随后我们直接按照 $\verb!dfs!$ 序在 $G'$ 中建**树** $T$。

之后，每加一条边，就把两条边之间的所有点的长度变为 $0$。因为题目提到“无论航线如何被破坏，任意时刻任意两个星球都能够相互到达。在整个数据中，任意两个星球之间最多只可能存在一条直接的航线。”所以我们可以得知，如果加了一条边 $(u,v)$，一定会制造一个含 $u,v$ 的环。既然如此，而我们 $T$ 是一棵树，所以之前 $u,v$ 是相互通达的，现在又来了，说明 $G'$ 中 $u\to v$ 不再只有一条路了。所以 $T$ 中 $u,v$ 之间的路径长度变为 $0$。

而询问操作就是平凡的模板。

----------------------

易错点：

$\#1$

因为 $G'$ 不是一定一颗树，所以判断条件不能写成 `v != fath`，因为这可能是一个环，如果写成这样就会爆栈导致 $\textsf{MLE}$。应该写成 `siz[v] == 0`。

正确的 `dfs1` 函数：

```cpp
inline void dfs1(int now,int fath,int depth) {
	fa[now] = fath,dep[now] = depth,siz[now] = 1;
	for (register int i = head[now];i;i = gra[i].nxt) {
		int v = gra[i].v;
		if (siz[v] == 0 && gra[i].vis == false) {
			dfs1(v,now,depth + 1);
			siz[now] += siz[v];
			if (siz[son[now]] < siz[v]) {
				son[now] = v;
			}
		}
	}
}
```

$\#2$

同理，在 `dfs2` 中也不能写成 `v != fa[now]`，反例还是刚才的环。应该写成什么呢，跟上面类似，如果真的还没有访问过，那么 $top$ 数组还没有更新吧。即 `top[v] == 0`。

正确的 `dfs2` 函数：

```cpp
inline void dfs2(int now,int topf) {
	top[now] = topf,dfn[now] = ++ num;
	if (son[now]) {
		dfs2(son[now],topf);
		for (register int i = head[now];i;i = gra[i].nxt) {
			int v = gra[i].v;
			if (top[v] == 0 && v != son[now] && gra[i].vis == false) {
				dfs2(v,v); 
			}
		}
	}
}
```

$\#3$

算是比较常见的套路了，这里写写以便读者理解。

边权怎么树剖？可以把边放到点上，所以要注意一下，如图：

![](https://cdn.luogu.com.cn/upload/pic/45367.png)

比如从 $5\to 7$，树上路径是 $5\to 2\to 7$，那么朴素树剖会直接统计 $5\to 2\to 6\to 7$ 路上所有点的和，但是我们注意本来点 $5$ 是不在路径上的（点 $5$ 存 $(5,8)$ 这条边的权值）。所以注意下边界，树剖的询问和修改都要加一。

具体详见代码

$\#4$

第三次 $\verb!dfs!$。

为什么还要第三次 $\verb!dfs!$？普通树剖不用是因为保证为树，而这里 $G'$ 可能不是树，所以我们处理出 $T$ 时会忽略掉很多 $G'$ 里的边（还没加边时）。也就是处理没有加入 $\verb!dfs!$ 树里的边。

看一下代码，也会解释一下：

```cpp
inline void dfs3(int now) {
	for (register int i = head[now];i;i = gra[i].nxt) {
		int v = gra[i].v;
		if (gra[i].vis == false) {
			if (fa[v] == now) {
				dfs3(v);
			}
			//没有加入 dfs 树中的那些边
			if (fa[now] != v && dep[v] < dep[now]) {
				update(now,v,0);
			}
		}
	}
}
```

如果 `fa[v] == now`，说明 $(now,v)$ 在 $T$ 里，那么我们跳过。如果是 $v$ 不是 $now$ 的父节点，并且 $v$ 在 $T$ 里的深度比 $now$ 在 $T$ 里的深度小，说明这条边没有加。否则 $dep[v]\gt dep[now]$。


# 代码

```cpp
// Problem: P2542 [AHOI2005] 航线规划
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P2542
// Memory Limit: 125 MB
// Time Limit: 1000 ms
// Date:2022-05-22 17:14
// 
// Powered by CP Editor (https://cpeditor.org)

#include <iostream>
#include <cstdio>
#include <climits>//need "INT_MAX","INT_MIN"
#include <cstring>//need "memset"
#include <numeric>
#include <algorithm>
#include <map>
#include <utility>
#define enter putchar(10)
#define debug(c,que) std::cerr << #c << " = " << c << que
#define cek(c) puts(c)
#define blow(arr,st,ed,w) for(register int i = (st);i <= (ed); ++ i) std::cout << arr[i] << w;
#define speed_up() std::ios::sync_with_stdio(false),std::cin.tie(0),std::cout.tie(0)
#define mst(a,k) memset(a,k,sizeof(a))
#define stop return(0)
const int mod = 1e9 + 7;
inline int MOD(int x) {
	if(x < 0) x += mod;
	return x % mod;
}
namespace Newstd {
	inline int read() {
		int ret = 0,f = 0;char ch = getchar();
		while (!isdigit(ch)) {
			if(ch == '-') f = 1;
			ch = getchar();
		}
		while (isdigit(ch)) {
			ret = (ret << 3) + (ret << 1) + ch - 48;
			ch = getchar();
		}
		return f ? -ret : ret;
	}
	inline void write(int x) {
		if(x < 0) {
			putchar('-');
			x = -x;
		}
		if(x > 9) write(x / 10);
		putchar(x % 10 + '0');
	}
}
using namespace Newstd;
using PII = std::pair<int,int>;

const int N = 1e5 + 5;
struct Ask {
	int opt,x,y;
} ask[N];
struct Graph {
	int v,nxt;
	bool vis;
} gra[N << 1];
int head[N],ans[N],dfn[N],siz[N],top[N],fa[N],dep[N],son[N];
std::map<PII,int>mp;
int n,m,idx,num;
inline void add(int u,int v) {
	gra[++ idx].v = v,gra[idx].nxt = head[u],gra[idx].vis = false,head[u] = idx;
	mp[std::make_pair(u,v)] = idx;
}
struct Segment_Tree {
	struct Node {
		int l,r;
		int tag,sum;
	} node[N << 2];
	#define lson (p << 1)
	#define rson (p << 1 | 1)
	inline void pushup(int p) {
		node[p].sum = node[lson].sum + node[rson].sum;
	}
	inline void build(int p,int l,int r) {
		node[p].l = l,node[p].r = r;
		if (l == r) {
			node[p].sum = 1;
			return;
		}
		int mid = l + r >> 1;
		build(lson,l,mid),build(rson,mid + 1,r);
		pushup(p);
	}
	inline void pushdown(int p) {
		if (node[p].tag) {
			node[lson].sum = node[rson].sum = 0;
			node[lson].tag = node[rson].tag = node[p].tag;
			node[p].tag = 0;
		}
	}
	inline void update(int x,int y,int p,int k) {
		if (x <= node[p].l && node[p].r <= y) {
			node[p].sum = k,node[p].tag = 1;
			return;
		}
		pushdown(p);
		int mid = node[p].l + node[p].r >> 1;
		if (x <= mid) update(x,y,lson,k);
		if (y > mid) update(x,y,rson,k);
		pushup(p);
	}
	inline int query(int x,int y,int p) {
		if (x <= node[p].l && node[p].r <= y) {
			return node[p].sum;
		}
		pushdown(p);
		int mid = node[p].l + node[p].r >> 1,res = 0;
		if (x <= mid) res += query(x,y,lson); 
		if (y > mid) res += query(x,y,rson);
		return res;
	}
	#undef lson
	#undef rson
} seg;
struct chain {
	inline void dfs1(int now,int fath,int depth) {
		fa[now] = fath,dep[now] = depth,siz[now] = 1;
		for (register int i = head[now];i;i = gra[i].nxt) {
			int v = gra[i].v;
			if (siz[v] == 0 && gra[i].vis == false) {
				dfs1(v,now,depth + 1);
				siz[now] += siz[v];
				if (siz[son[now]] < siz[v]) {
					son[now] = v;
				}
			}
		}
	}
	inline void dfs2(int now,int topf) {
		top[now] = topf,dfn[now] = ++ num;
		if (son[now]) {
			dfs2(son[now],topf);
			for (register int i = head[now];i;i = gra[i].nxt) {
				int v = gra[i].v;
				if (top[v] == 0 && v != son[now] && gra[i].vis == false) {
					dfs2(v,v); 
				}
			}
		}
	}
	inline void update(int x,int y,int k) {
		while (top[x] != top[y]) {
			if (dep[top[x]] < dep[top[y]]) std::swap(x,y);
			seg.update(dfn[top[x]],dfn[x],1,k);
			x = fa[top[x]];
		}
		if (dep[x] > dep[y]) std::swap(x,y);
		if (dep[x] != dep[y]) {
			seg.update(dfn[x] + 1,dfn[y],1,k);
		}
	}
	inline void dfs3(int now) {
		for (register int i = head[now];i;i = gra[i].nxt) {
			int v = gra[i].v;
			if (gra[i].vis == false) {
				if (fa[v] == now) {
					dfs3(v);
				}
				//没有加入 dfs 树中的那些边
				if (fa[now] != v && dep[v] < dep[now]) {
					update(now,v,0);
				}
			}
		}
	}
	inline int query(int x,int y) {
		int res = 0;
		while (top[x] != top[y]) {
			if (dep[top[x]] < dep[top[y]]) std::swap(x,y);
			res += seg.query(dfn[top[x]],dfn[x],1);
			x = fa[top[x]];
		}
		if (dep[x] > dep[y]) std::swap(x,y);
		if (dep[x] != dep[y]) {
			res += seg.query(dfn[x] + 1,dfn[y],1);
		}
		return res;
	}
} ch;
int main(void) {
	n = read(),m = read();
	for (register int i = 1;i <= m; ++ i) {
		int u = read(),v = read();
		add(u,v),add(v,u);
	}
	int asks = 0;
	while (true) {
		int opt = read();
		if (opt == -1) break;
		int x = read(),y = read();
		ask[++ asks] = (Ask){opt,x,y};
		if (opt == 0) {
			gra[mp[std::make_pair(x,y)]].vis = gra[mp[std::make_pair(y,x)]].vis = true;
		}
	}
	ch.dfs1(1,0,1),ch.dfs2(1,1),seg.build(1,1,n),ch.dfs3(1);
	for (register int i = asks;i >= 1; -- i) {
		int x = ask[i].x,y = ask[i].y;
		if (ask[i].opt == 0) {
			ch.update(x,y,0);
		} else {
			ans[i] = ch.query(x,y);
		}
	}
	for (register int i = 1;i <= asks; ++ i) {
		if (ask[i].opt == 1) {
			printf("%d\n",ans[i]);
		}
	}
	
	return 0;
}
```

---

## 作者：404Not_Found (赞：1)


首先套路离线删边转加边。

注意到每两个点之间最多只有一条路径，所以边双缩点之后一定是一棵树，接着只要维护树上距离就行了。每次询问都跑一遍 $\mathrm{Tarjan}$ 是 $\mathcal O(nq)$ 的 （ $q$ 是询问次数 ），不能接受。

注意到图可以变为一棵树 + 若干个环，环上的贡献显然为 $0$。而每次加边一定只会把关键边变为非关键边，而不会把非关键边变为关键边。

所以可以先随便找出一棵生成树，逆序处理操作询问，每次加边时把这条路径上的边权变为 $0$，用树链剖分维护边权和，最后逆序输出答案就做完了。

时间复杂度：$\mathcal{O}(q \log^2 n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 3e4+5;
const int M = 1e5+5;
map<pair<int,int>,int> mp;
struct edge{
	int to,nxt;
	bool vis;
} e[M<<1];
int head[N],cnt;
inline void add(int u,int v)
{
	e[++cnt].to=v;
	e[cnt].nxt=head[u];
	head[u]=cnt;
	mp[make_pair(u,v)]=cnt;
}
int n,m;
int id[N],top[N],fa[N],son[N],siz[N],dep[N],idx;
void dfs1(int u,int f)
{
	fa[u]=f; dep[u]=dep[f]+1; siz[u]=1;
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].to;
		if(siz[v]||e[i].vis) continue;
		dfs1(v,u);
		siz[u]+=siz[v];
		if(siz[v]>siz[son[u]]) son[u]=v;
	}
}
void dfs2(int u,int tp)
{
	top[u]=tp; id[u]=++idx;
	if(son[u]) dfs2(son[u],tp);
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].to;
		if(id[v]||e[i].vis||v==son[u]) continue;
		dfs2(v,v);
	}
}

int sum[N<<2],tag[N<<2];
void push_up(int p){sum[p]=sum[p<<1]+sum[p<<1|1];}
void build(int p,int l,int r)
{
	if(l==r){sum[p]=1;return;}
	int mid=(l+r)>>1;
	build(p<<1,l,mid); build(p<<1|1,mid+1,r);
	push_up(p);
}
void push_down(int p)
{
	if(tag[p])
	{
		tag[p<<1]=tag[p<<1|1]=tag[p];
		sum[p<<1]=sum[p<<1|1]=0;
		tag[p]=0;
	}
}
void modify(int p,int l,int r,int L,int R)
{
	if(L<=l&&r<=R){tag[p]=1;sum[p]=0;return;}
	int mid=(l+r)>>1; push_down(p);
	if(L<=mid) modify(p<<1,l,mid,L,R);
	if(R>mid) modify(p<<1|1,mid+1,r,L,R);
	push_up(p);
}
int query(int p,int l,int r,int L,int R)
{
	if(L<=l&&r<=R) return sum[p];
	int mid=(l+r)>>1,ret=0;
	push_down(p);
	if(L<=mid) ret+=query(p<<1,l,mid,L,R);
	if(R>mid) ret+=query(p<<1|1,mid+1,r,L,R);
	return ret;
}
void UpdRange(int u,int v)
{
	while(top[u]^top[v])
	{
		if(dep[top[u]]<dep[top[v]]) swap(u,v);
		modify(1,1,n,id[top[u]],id[u]);
		u=fa[top[u]];
	}
	if(dep[u]>dep[v]) swap(u,v);
	if(dep[u]!=dep[v]) modify(1,1,n,id[u]+1,id[v]);
}
int QryRange(int u,int v)
{
	int ret=0;
	while(top[u]^top[v])
	{
		if(dep[top[u]]<dep[top[v]]) swap(u,v);
		ret+=query(1,1,n,id[top[u]],id[u]);
		u=fa[top[u]];
	}
	if(dep[u]>dep[v]) swap(u,v);
	ret+=query(1,1,n,id[u]+1,id[v]);
	return ret;
}
void dfs3(int u)
{
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].to;
		if(e[i].vis) continue;
		if(fa[v]==u) dfs3(v);
		if(fa[u]!=v&&dep[v]<dep[u]) UpdRange(v,u);
	}
}
struct Query{
	int id,opt,u,v;
} q[N]; int len,ans[N];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1,u,v;i<=m;i++)
	{
		scanf("%d%d",&u,&v);
		add(u,v); add(v,u);
	}
	while(1)
	{
		int opt,u,v;
		scanf("%d",&opt);
		if(opt==-1) break;
		len++; q[len].id=len;
		q[len].opt=opt;
		scanf("%d%d",&u,&v);
		q[len].u=u; q[len].v=v;
		if(opt==0) e[mp[make_pair(u,v)]].vis=e[mp[make_pair(v,u)]].vis=1;
	}
	dfs1(1,0); dfs2(1,1);
	build(1,1,n);
	dfs3(1);
	for(int i=len;i>=1;i--)
		if(q[i].opt==1) ans[i]=QryRange(q[i].u,q[i].v);
		else UpdRange(q[i].u,q[i].v);
	for(int i=1;i<=len;i++) if(q[i].opt==1) printf("%d\n",ans[i]);
}
```

---

## 作者：chihik (赞：1)

删除边不好做，考虑将操作离线倒着加边。

考虑连边时维护割边。

- $u,v$ 不联通，直接连上即可，可以看出，这条边是割边。

- $u,v$ 已经联通，说明构成一个环，原来在 $u \to v$ 路径上的边都不再是割边。

如果把割边的值设为 $1$ ，非割边的值设为 $0$ ，那么只需要修改和维护链的和即可。

因为根会变，所以边的信息需要新建点来存储。

```cpp
#include <map>
#include <cstdio>
#include <iostream>
using namespace std;

const int MAXN = 2e5;
struct node {
    int ch[ 2 ] , fa;
    int val , Sum;
    bool rev , cov;
};
struct LinkCutTree {
    node Tree[ MAXN + 5 ];
    #define ls( x ) Tree[ x ].ch[ 0 ]
    #define rs( x ) Tree[ x ].ch[ 1 ]

    void Pushup( int x ) {
        Tree[ x ].Sum = Tree[ ls( x ) ].Sum + Tree[ x ].val + Tree[ rs( x ) ].Sum;
    }
    void Reverse( int x ) { swap( ls( x ) , rs( x ) ); Tree[ x ].rev ^= 1; }
    void Cov( int x ) { Tree[ x ].Sum = Tree[ x ].val = 0; Tree[ x ].cov = 1; }
    void Pushdown( int x ) {
        if( Tree[ x ].rev ) {
            if( ls( x ) ) Reverse( ls( x ) );
            if( rs( x ) ) Reverse( rs( x ) );
            Tree[ x ].rev = 0;
        }
        if( Tree[ x ].cov ) {
            if( ls( x ) ) Cov( ls( x ) );
            if( rs( x ) ) Cov( rs( x ) );
            Tree[ x ].cov = 0;
        }
    }
    
    bool isrt( int x ) { //是否为 splay 的 rt
        return ls( Tree[ x ].fa ) != x && rs( Tree[ x ].fa ) != x;
    }
    bool chk( int x ) { return rs( Tree[ x ].fa ) == x; }
    void Rotate( int x ) {
        int y = Tree[ x ].fa , z = Tree[ y ].fa , p = chk( x ) , a = Tree[ x ].ch[ !p ];
        if( !isrt( y ) ) Tree[ z ].ch[ chk( y ) ] = x; Tree[ x ].fa = z;
        Tree[ x ].ch[ !p ] = y; Tree[ y ].fa = x;
        Tree[ y ].ch[ p ] = a; if( a ) Tree[ a ].fa = y;
        Pushup( y ); 
    }
    void Pushcn( int x ) { //pushdown 根到x
        if( !isrt( x ) ) Pushcn( Tree[ x ].fa );
        Pushdown( x );
    }
    void Splay( int x ) {
        Pushcn( x );
        while( !isrt( x ) ) {
            int y = Tree[ x ].fa , z = Tree[ y ].fa;
            if( !isrt( y ) ) Rotate( chk( x ) == chk( y ) ? y : x );
            Rotate( x );
        }
        Pushup( x );
    }

    void Access( int x ) {
        for( int y = 0 ; x ; y = x , x = Tree[ x ].fa )
            Splay( x ) , rs( x ) = y , Pushup( x );
    }
    void Makeroot( int x ) {
        Access( x ); Splay( x );
        Reverse( x );
    }
    int Findroot( int x ) {
        Access( x ); Splay( x );
        for( ; ls( x ) ; x = ls( x ) ) Pushdown( x );
        Splay( x ); return x;
    }
    bool Connected( int u , int v ) {
        Makeroot( u ); return Findroot( v ) == u;
    }
    bool Link( int u , int v ) {
        if( Connected( u , v ) ) {
            Split( u , v ); Cov( v );
            return 0;
        }
        Tree[ u ].fa = v; return 1;
    }
    bool Cut( int u , int v ) {
        if( !Connected( u , v ) ) return 0;
        if( ls( v ) || Tree[ v ].fa != u ) return 0;
        Tree[ v ].fa = 0; rs( u ) = 0;
        return 1;
    }
    void Split( int u , int v ) {
        Makeroot( u ); Access( v ); Splay( v );
    }
}LCT;

struct Query {
    int op , u , v , Ans;
}Qry[ MAXN + 5 ];
map< int , bool > Graph[ MAXN + 5 ];
int n , m , q , cnt;
int main( ) {
    scanf("%d %d",&n,&m);
    for( int i = 1 , u , v ; i <= m ; i ++ ) {
        scanf("%d %d",&u,&v);
        Graph[ u ][ v ] = Graph[ v ][ u ] = 1;
        LCT.Tree[ n + i ].val = 1;
    }
    for( ; scanf("%d",&Qry[ ++ q ].op) && Qry[ q ].op != -1 ; ) {
        scanf("%d %d",&Qry[ q ].u,&Qry[ q ].v);
        if( Qry[ q ].op == 0 ) Graph[ Qry[ q ].u ][ Qry[ q ].v ] = Graph[ Qry[ q ].v ][ Qry[ q ].u ] = 0;
    } q --;
    for( int i = 1 ; i <= n ; i ++ )
        for( auto v : Graph[ i ] )
            if( v.second != 0 && v.first > i ) {
                cnt ++;
                LCT.Link( i , n + cnt ); 
                LCT.Link( n + cnt , v.first );
                //printf("%d %d\n", i , v.first );
            }
    for( int i = q ; i >= 1 ; i -- ) {
        if( Qry[ i ].op == 0 ) {
            cnt ++;
            LCT.Link( Qry[ i ].u , n + cnt );
            LCT.Link( n + cnt , Qry[ i ].v );
        }
        if( Qry[ i ].op == 1 ) {
            LCT.Split( Qry[ i ].u , Qry[ i ].v );
            Qry[ i ].Ans = LCT.Tree[ Qry[ i ].v ].Sum;
        }
    }
    for( int i = 1 ; i <= q ; i ++ )
        if( Qry[ i ].op == 1 ) printf("%d\n", Qry[ i ].Ans );
    return 0;
}
```

---

## 作者：KokiNiwa (赞：1)

# [AHOI2005]航线规划

[题目链接](https://www.luogu.com.cn/problem/P2542)

## 题意概括

首先给你一张图，然后不断删边，求两点间的割边的数量。

## 解法1

首先把删边转化为加边。

然后发现一个边只可能从是割边变为不是割边。然后对于一个边维护一个权值，这个权值为$1$则是割边，否则不是。对于一次加边操作，如果这两个点本身不连通，那么就直接给这两个点连上边。否则，这个边的两个端点在原来树上的边一都不是割边了。那么把那些边的权值都变为0。

## 解法2

其他的和解法1一样，但是对于在两个点已经联通的加边操作，然后每把这次的这个边双上的所有点（一定在一条链上），用一个点代替（具体可以每个点先维护一个并查集，然后把这个链上的所有点的并查集祖先都更改为这个链的辅助树根节点）。这样做的本质其实就是把一个图的边双缩点后，图就形成了一棵树。

## 知识点

+ ```LCT```维护边双模板题。
+ 可以发现，所有并查集中父亲与自己并不是同一个点的话，那么这个点就不再树上。因为在添加了一条连接两个已经联通的点之前，就已经把那个环上的除了当前这块的根节点的所有其他点都与树断开链接了。

## 代码

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>

using namespace std;

const int maxNodeNum =3e4 + 10;
const int maxEdgeNum = 1e5 + 10;
const int maxActNum = 4e4 + 10;
int nodeNum = 0, edgeNum = 0, actNum = 0;
bool vis[maxEdgeNum] = {};
struct EDGE {
	int uNode, vNode;
	EDGE() : uNode(0), vNode(0) {}
	EDGE(int u, int v) : uNode(u), vNode(v) {}
	bool operator < (const EDGE &d) const {
		return (uNode == d.uNode) ? (vNode < d.vNode) : (uNode < d.uNode);
	}
} edge[maxEdgeNum] = {};
struct ACTI {
	int type, uNode, vNode, ans;
	ACTI() : type(0), uNode(0), vNode(0) {}
} act[maxActNum] = {};
void swap(int &u, int &v) {
	int r = u;
	u = v;
	v = r;
}
int find(int uNode, int vNode) {
	return lower_bound(edge + 1, edge + edgeNum + 1, EDGE(uNode, vNode)) - edge;
}
struct LCT {
	int top;
	int fa[maxNodeNum], ch[maxNodeNum][2], size[maxNodeNum], dsu[maxNodeNum];
	int stk[maxNodeNum];
	bool rev[maxNodeNum];
	LCT() {
		memset(fa, 0, sizeof(fa));
		memset(ch, 0, sizeof(ch));
		memset(rev, 0, sizeof(rev));
		memset(size, 0, sizeof(size));
	}
	void out() {
		for (int id = 1; id <= nodeNum; ++id)
			printf("id : %d fa : %d left : %d right : %d\n", id, fa[id], ch[id][0], ch[id][1]);
		printf("\n");
	}
	void init() {
		for (int nodeId = 1; nodeId <= nodeNum; ++nodeId)
			dsu[nodeId] = nodeId;
	}
	int get(int now) {
		if (dsu[now] == now)
			return now;
		return dsu[now] = get(dsu[now]);
	}
	bool isNotR(int now) {
		return ch[fa[now]][0] == now || ch[fa[now]][1] == now;
	}
	bool chk(int now) {
		return ch[fa[now]][1] == now;
	}
	void update(int now) {
		size[now] = size[ch[now][0]] + size[ch[now][1]] + 1;
	}
	void connect(int now, int futureFa, bool side) {
		fa[now] = futureFa;
		ch[futureFa][side] = now;
	}
	void rotate(int now) {
		int par = fa[now], gra = fa[par];
		bool nowSide = chk(now);
		if (isNotR(par))
			ch[gra][chk(par)] = now;
		fa[now] = gra;
		connect(ch[now][nowSide ^ 1], par, nowSide);
		connect(par, now, nowSide ^ 1);
		update(par);
		update(now);
	}
	void flip(int now) {
		rev[now] ^= 1;
		swap(ch[now][0], ch[now][1]);
	}
	void spread(int now) {
		if (rev[now]) {
			if (ch[now][0])
				flip(ch[now][0]);
			if (ch[now][1])
				flip(ch[now][1]);
			rev[now] = 0;
		}
	}
	void splay(int now) {
		int go = stk[top = 1] = now;
		while (isNotR(go))
			go = stk[++top] = fa[go];
		while (top)
			spread(stk[top--]);
		while (isNotR(now)) {
			int par = fa[now];
			if (isNotR(par))
				rotate(chk(now) ^ chk(par) ? now : par);
			rotate(now);
		}
	}
	void access(int now) {
		//曾经把rec初始值写成了now 
		for (int rec = 0; now; now = fa[rec = now] = get(fa[now])) {
			splay(now); ch[now][1] = rec; update(now);
		}
	}
	void makeRoot(int now) {
		access(now);
		splay(now);
		flip(now);
	}
	void split(int uNode, int vNode) {
		makeRoot(uNode);
		access(vNode);
		splay(vNode);
	}
	int findRoot(int now) {
		access(now);
		splay(now);
		while (ch[now][0]) {
			spread(now);
			now = ch[now][0];
		}
		return splay(now), now;
	}
	void dfs(int now, int val) {
		dsu[now] = val;
		if (ch[now][0])
			dfs(ch[now][0], val);
		if (ch[now][1])
			dfs(ch[now][1], val);
	}
	void link(int uNode, int vNode) {
		if (uNode == vNode)
			return ;
		//在一块要忽略 
		makeRoot(uNode);
		if (findRoot(vNode) != uNode) {
			fa[uNode] = vNode;
		} else {
			split(uNode, vNode);
			dfs(vNode, vNode);
			ch[vNode][0] = ch[vNode][1] = 0;
			//需要断开连接 
		}
	}
	int pathNodeNum(int uNode, int vNode) {
		split(uNode, vNode);
		return size[vNode] - 1;
	}
} T;

int main() {
	scanf("%d%d", &nodeNum, &edgeNum);
	for (int edgeId = 1; edgeId <= edgeNum; ++edgeId) {
		scanf("%d%d", &edge[edgeId].uNode, &edge[edgeId].vNode);
		if (edge[edgeId].uNode > edge[edgeId].vNode)
			swap(edge[edgeId].uNode, edge[edgeId].vNode);
		vis[edgeId] = 1;
	}
	T.init();
	sort(edge + 1, edge + edgeNum + 1);
	int nowType;
	scanf("%d", &nowType);
	while (nowType != -1) {
		act[++actNum].type = nowType;
		scanf("%d%d%d", &act[actNum].uNode, &act[actNum].vNode, &nowType);
		if (act[actNum].uNode > act[actNum].vNode)
			swap(act[actNum].uNode, act[actNum].vNode);
		if (act[actNum].type == 0)
			vis[find(act[actNum].uNode, act[actNum].vNode)] = 0;
	}
	for (int edgeId = 1; edgeId <= edgeNum; ++edgeId)
		if (vis[edgeId])
			T.link(T.get(edge[edgeId].uNode), T.get(edge[edgeId].vNode));
			//这句话必须写 T.get()
			//因为在连边的过程中就会出现有些点连成一团的情况了，虽然这个循环之前没有 
	for (int actI = actNum; actI >= 1; --actI) {
		act[actI].uNode = T.get(act[actI].uNode);
		act[actI].vNode = T.get(act[actI].vNode);
		if (act[actI].type == 0)
			T.link(act[actI].uNode, act[actI].vNode);
		else
			act[actI].ans = T.pathNodeNum(act[actI].uNode, act[actI].vNode);
	}
	for (int actI = 1; actI <= actNum; ++actI)
		if (act[actI].type == 1)
			printf("%d\n", act[actI].ans);
	return 0;
}
```



---

## 作者：Christopher_Yan (赞：1)

本想当作树剖模板练练手，没想到调了整整一上午。。。

### 解题思路
时间倒流（自己起的名字）+树链剖分

> 
我们保证无论航线如何被破坏，任意时刻任意两个星球都能够相互到达。

这句话加上删除边的操作，我们应该很容易的想到时间倒流的离线处理方法，这个比较套路。

然后对于加边操作（已经时间倒流了），我们等同于消去了树上一条路径的贡献，直接树链剖分路径修改就可以做，而询问也可以路径询问。

一开始为了树剖写了缩点（缩完是棵树），后来种种细节可能出了锅，一直没有过样例，后来却发现这个缩点没有任何必要，我们只需在图上随便跑一颗树出来就可以了。

几个细节：
1. 边权下落到点上，变为点权。
2. 关于LCA的细节处理务必要小心。
3. 路径操作时，我们要比较$a$,$b$的$dep[top[]]$，而非$dep[]$，这个错误调了好久。。。

### AC代码
```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cctype>
#include <map>

#define ls u << 1
#define rs u << 1 | 1

using namespace std;

const int N = 420200;

int n, m, cnt, id;
int a[N], b[N], c[N], nid[N], ed[N], top[N], w[N], add[N], out[N];
int son[N], dep[N], faz[N], vis[N], used[N], old[N], el[N], er[N];
int ec = -1, to[N], bg[N], nxt[N], f[N], siz[N];

map <long long, int> M;

inline bool read(int &x)
{
	int k = 1; x = 0;
	char c = getchar();
	while (!isdigit(c))
		if (c == '-') c = getchar(), k = -1;
		else c = getchar();
	while (isdigit(c))
		x = (x << 1) + (x << 3) + (c ^ 48),
		c = getchar(); x *= k; 
	return true;
}

inline void Addedge(int a, int b)
{
	++ec, to[ec] = b, bg[ec] = a, nxt[ec] = f[a], f[a] = ec;
	++ec, to[ec] = a, bg[ec] = b, nxt[ec] = f[b], f[b] = ec;
}

void DFS1(int u, int fa)
{
	siz[u] = 1, vis[u] = 1, faz[u] = fa;
	dep[u] = (u == 1 ? 1 : dep[fa] + 1);
	for (int i = f[u]; i != -1; i = nxt[i])
		if (!vis[to[i]] && !used[i])
		{
			used[i ^ 1] = -1, used[i] = 1; ed[to[i]] = i;
			DFS1(to[i], u), siz[u] += siz[to[i]];
			if (!son[u] || siz[to[i]] > siz[son[u]]) 
				son[u] = to[i];
		}
}

void DFS2(int u, int head)
{
	nid[u] = ++id, top[u] = head, old[id] = u;
	if (!son[u]) return; DFS2(son[u], head);
	for (int i = f[u]; i != -1; i = nxt[i])
		if (!nid[to[i]] && used[i] == 1)
			DFS2(to[i], to[i]);
}

inline void Pushup(int u)
{
	w[u] = w[ls] + w[rs];
}

inline void Pushdown(int u, int l, int r)
{
	if (add[u] == -1) return;
	add[ls] = add[rs] = 0;
	w[ls] = w[rs] = 0;
	add[u] = -1;
}	

void Build(int u, int l, int r)
{
	add[u] = -1; if (l == r) { w[u] = ed[old[l]] != -1; return; }
	int mid = (l + r) >> 1; Build(ls, l, mid), Build(rs, mid + 1, r), Pushup(u);
}

void Add(int u, int l, int r, int ql, int qr)
{
	if (ql <= l && r <= qr)
	{ add[u] = 0, w[u] = 0; return; }
	int mid = (l + r) >> 1; Pushdown(u, l, r);
	if (ql <= mid) Add(ls, l, mid, ql, qr);
	if (qr > mid) Add(rs, mid + 1, r, ql, qr);
	Pushup(u);
}

int Query(int u, int l, int r, int ql, int qr)
{
	if (ql <= l && r <= qr) return w[u];
	int mid = (l + r) >> 1, res = 0; Pushdown(u, l, r);
	if (ql <= mid) res += Query(ls, l, mid, ql, qr);
	if (qr > mid) res += Query(rs, mid + 1, r, ql, qr);
	return res;
}

inline void Put(int a, int b)
{
	while (top[a] != top[b])
	{
		if (dep[top[a]] < dep[top[b]]) swap(a, b);
		Add(1, 1, n, nid[top[a]], nid[a]);
		a = faz[top[a]];
	}
	if (dep[a] < dep[b]) swap(a, b);
	if (dep[a] ^ dep[b]) Add(1, 1, n, nid[b] + 1, nid[a]);
}

inline int Ret(int a, int b)
{
	int ans = 0;
	while (top[a] != top[b])
	{
		if (dep[top[a]] < dep[top[b]]) swap(a, b);
		ans += Query(1, 1, n, nid[top[a]], nid[a]);
		a = faz[top[a]];
	}
	if (dep[a] < dep[b]) swap(a, b);
	ans += Query(1, 1, n, nid[b], nid[a]);
	ans -= Query(1, 1, n, nid[b], nid[b]);
	return ans;
}

inline int ID(int x, int y)
{
	return x * 100000 + y;
}

signed main()
{
	read(n), read(m);
	memset(f, -1, sizeof(f)); memset(ed, -1, sizeof(ed));
	for (int i = 1; i <= m; ++i) read(el[i]), read(er[i]);
	for (; read(c[++cnt]); )
		if (c[cnt] == -1) break;
		else if (c[cnt] == 0) read(a[cnt]), read(b[cnt]), M[ID(a[cnt], b[cnt])] = true; 
		else read(a[cnt]), read(b[cnt]); --cnt;
	for (int i = 1; i <= m; ++i)
		if (!M[ID(el[i], er[i])] && !M[ID(er[i], el[i])])
			Addedge(el[i], er[i]);
	DFS1(1, 0), DFS2(1, 1), Build(1, 1, id);
	for (int i = 0; i <= ec; ++i)
		if (!used[i]) used[i] = used[i ^ 1] = -1, Put(to[i], bg[i]);
	for (int i = cnt; i >= 1; --i)
		if (!c[i]) Put(a[i], b[i]);
		else out[i] = Ret(a[i], b[i]);
	for (int i = 1; i <= cnt; ++i) 
		if (c[i]) printf("%d\n", out[i]);
	return 0;
}

/*
题目整体思路：
时间倒流+树链剖分
*/
```

---

## 作者：远航之曲 (赞：1)

这道题 非常的好


大概分为这几个步骤


1.读入所有的问题

2.把所有要删的边都删掉

3.把图缩成一颗树

4.树上跑dfs记下点的欧拉迹，并把点的深度维护一个线段树

5.欧拉迹放到rmq中，便于查询lca

6.对于每一条增加的边，假如形成了环，接着缩点，并在线段树上维护深度变化（lca不变

7.查询树上两点距离，输出


详见代码


```cpp
#include<iostream>
#include <cstdio>
#include <cstring>
#include<cmath>
using namespace std;
const int Limit=30010;
const int Limitedge=100010;
const int Limitquery=200010;
const int Limithash=1999997;
const int Limitlog=18;
const int Limittree=32767;
struct Tmap//边
{
    int p1,p2;
    int link;
    bool vis;
}map[Limitedge*2],tmp[Limitedge*2];
struct Query//问题
{
    int kind;
    int p1,p2;
    int ans;
}Que[Limitquery];
struct Point
{
    int p1,p2;
};
struct THash//处理边
{
    Point save;//hash值为hashnum的边连接的点
    int data;//hash值为hashnum的边是哪条
}Hash[Limithash];
int rank[Limit];//基数排序
int tail[Limit];//i的孩子们是i到tail[i]
int code[Limit];//重标号
bool visit[Limit];
int tree_father[Limit];//dfs树中的父亲
int tree[Limit*3];//线段树
int source[Limit*3];//dfs序
int RMQ_rank[Limit*3];//在dfs序中的哪个位置
int ancestor[Limit*3][Limitlog];
int father[Limit];//并查集
int cnt;
int RMQ_tot;//dfs序的个数
int N,M,Q;
void init()
{
    scanf("%d%d",&N,&M);
    for (int i=1;i<=M;i++)
    {
        scanf("%d%d",&map[i].p1,&map[i].p2);
        map[i+M].p1=map[i].p2;//记录反向边
        map[i+M].p2=map[i].p1;
        map[i].link=i+M; map[i+M].link=i;
    }
    M*=2;
    Q=0;
    while (1==1)
    {
        Q++;
        scanf("%d",&Que[Q].kind);
        if (Que[Q].kind==-1)
        {
            Q--;
            break;
        }
        scanf("%d%d",&Que[Q].p1,&Que[Q].p2);
    }
}
void radixsort()
{
    for (int i=1;i<=M;i++) tmp[i]=map[i];
    for (int i=1;i<=N;i++) rank[i]=0;
    for (int i=1;i<=M;i++) rank[tmp[i].p1]++;
    for (int i=2;i<=N;i++) rank[i]+=rank[i-1];
    for (int i=M;i>=1;i--)
    {
        map[rank[tmp[i].p1]--]=tmp[i];
        if (tmp[i].vis)
            map[tmp[i].link].link=rank[tmp[i].p1]+1;
        else
        {
            tmp[tmp[i].link].link=rank[tmp[i].p1]+1;
            tmp[tmp[i].link].vis=1;
        }
    }
    for (int i=1;i<=N;i++) rank[i]++;
    for (int i=1;i<=M;i++) map[i].vis=0;
}
int Hash_calc(int p1,int p2)
{
    return (p1*12351+p2*9591)%Limithash;
}
bool compare(Point p,int p1,int p2)
{
    return (p.p1==p1 && p.p2==p2);
}
void Hash_add(int k)
{
    int hashnum=Hash_calc(map[k].p1,map[k].p2);
    while (Hash[hashnum].data!=0 && !compare(Hash[hashnum].save,map[k].p1,map[k].p2))
    {
        hashnum++;
        if (hashnum==Limithash)
            hashnum=0;
    }
    Hash[hashnum].data=k;
    Hash[hashnum].save.p1=map[k].p1; Hash[hashnum].save.p2=map[k].p2;
}
int Hash_find(int p1,int p2)
{
    int hashnum=Hash_calc(p1,p2);
    while (!compare(Hash[hashnum].save,p1,p2))
    {
        hashnum++;
        if (hashnum==Limithash) hashnum=0;
    }
    return Hash[hashnum].data;
}
void RMQ_add(int k)
{
    source[++RMQ_tot]=k;
    RMQ_rank[k]=RMQ_tot;
}
void RMQ_make()
{
    for (int i=1;i<=RMQ_tot;i++) 
        ancestor[i][0]=source[i];
    for (int j=1;(1<<j)<=RMQ_tot;j++)
        for (int i=1;i+(1<<j)-1<=RMQ_tot;i++)
            ancestor[i][j]=min(ancestor[i][j-1],ancestor[i+(1<<(j-1))][j-1]);
}
int RMQ_LCA(int p1,int p2)
{
    p1=RMQ_rank[p1]; p2=RMQ_rank[p2];
    if (p2<p1) swap(p1,p2);
    int len=floor(log((double)p2-p1+1)/log(2.0));
    return min(ancestor[p1][len],ancestor[p2-(1<<len)+1][len]);
}
void dfs_build(int k)
{
    cnt++; visit[k]=1;
    int now=cnt; code[k]=now;
    int i=rank[k]; RMQ_add(now);
    while (i<=M && map[i].p1==k)
    {
        if (!map[i].vis)
            if (!visit[map[i].p2])
            {
                map[map[i].link].vis=1;
                dfs_build(map[i].p2);
                RMQ_add(now);
                tree_father[code[map[i].p2]]=now;
            }
            else
            {
                map[map[i].link].vis=1;
                Que[++Q].kind=0;
                Que[Q].p1=map[i].p1; Que[Q].p2=map[i].p2;
            }
        i++;
    }
    tail[now]=cnt;
}
void tree_add(int l,int r,int val)
{
    l+=Limittree; r+=Limittree;
    while (l<=r)
    {
        if (l%2==1) {tree[l]+=val; l++;}
        if (r%2==0) {tree[r]+=val; r--;}
        l/=2; r/=2;
    }
}
int tree_query(int x)
{
    int ans=0;
    x+=Limittree;
    while (x!=0)
    {
        ans+=tree[x];
        x/=2;
    }
    return ans;
}
int Merge_find(int x)
{
    if (x!=father[x])
        father[x]=Merge_find(father[x]);
    return father[x];
}
void Merge_dfs(int p,int root)
{
    if (p!=root)
    {
        Merge_dfs(Merge_find(tree_father[p]),root);
        father[p]=root; tree_add(p,tail[p],-1);
    }
}
void Merge(int p1,int p2)
{
    int LCA=Merge_find(RMQ_LCA(p1,p2));
    Merge_dfs(p1,LCA);
    Merge_dfs(p2,LCA);
}
void work()
{
    radixsort();//基数排序
    for (int i=1;i<=M;i++) Hash_add(i);//做读入边的hash
    for (int i=1;i<=Q;i++)
        if (!Que[i].kind)//必须删的边先去掉
        {
            map[Hash_find(Que[i].p1,Que[i].p2)].vis=1;
            map[Hash_find(Que[i].p2,Que[i].p1)].vis=1;
        }
    memset(visit,0,sizeof(visit));
    dfs_build(1);//做dfs序
    RMQ_make();
    for (int i=1;i<=N;i++) father[i]=i;//并查集
    tree[1+Limittree]=1;
    for (int i=2;i<=N;i++) tree[i+Limittree]=tree[tree_father[i]+Limittree]+1;//赋线段树叶子结点的值
    for (int i=Q;i>=1;i--)
    {
        int p1=Merge_find(code[Que[i].p1]);
        int p2=Merge_find(code[Que[i].p2]);
        if (!Que[i].kind)
            Merge(p1,p2);//添边
        else
        {
            int LCA=Merge_find(RMQ_LCA(p1,p2));
            int deep1=tree_query(p1);
            int deep2=tree_query(p2);
            int deepLCA=tree_query(LCA);
            Que[i].ans=deep1+deep2-deepLCA*2;
        }
    }
}
void out()
{
    for (int i=1;i<=Q;i++)
        if (Que[i].kind)
            printf("%d\n",Que[i].ans);
}
int main()
{
    init();
    work();
    out();
}
```

---

## 作者：EnochWenzhou (赞：1)

（我做这道题是以学校OJ上的题面为准的，那里是先输入操作次数之后操作，最后不会输出-1的）



考试时考这道题已经没多少时间了，于是使用了超级骗分法：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,a1,b1,c1;
int main(){
	cin>>n>>m>>k;
	for(int i=1;i<=m;i++) scanf("%d%d",&a1,&b1);
	for(int i=1;i<=k;i++{
		scanf("%d%d%d",&c1,&a1,&b1);
		if(c1){
			if(m==n-1) printf("%d\n",m);
			else printf("0\n");
		}
	}
	return 0;
}
```

在luogu上得了10分但在学校OJ上得了60分？？！？？？？！！！


话不多说，进入正题：

60分：

也就是没有删边的情况，可以先使用tarjin缩点变为树（任意一个连通子集上的边必为不取），之后使用lca即可。

100分：

我的思路是树剖+并查集+BIT（树状数组）+dfs序。

1.先以那些没有被删掉的边取n-1个来建树。在树链剖分的预处理上就可以做到了。并且顺便存一下dfs序，以便后续使用BIT。在第二次dfs时每搜到一个点且不为1就在树状数组上的这个点+1（while(x<=n) c[x]+=1,x+=x&-x;）

2.此时假如只有这n-1条边就能保证任意两点的关键边个数为两点树上路径边的个数。那么每连一条边都能使这两点的路径上所有的点都变为不可能被成为关键边的边（好绕）。这种情况使用树链剖分是不太可能做到的，如果暴力枚举一遍复杂度为n*m也炸了，但是注意到最多只有n-1条边会被改变因此可以想办法去重，也就是保证已被改变的点不会再次被更新即可。因此可以使用并查集存每个点的最低的还未修改过的祖先，这样x就可以每次跳到find(x)上并且将Fa[find(x)]=find(fa[x]).Fa为并查集中的父节点，fa为树上的父节点，这样就能将时间复杂度缩减到O(n)的级别。每搜到一个点还要在树状数组上-1。

3.之后倒叙操作每一步询问/修改，询问使用树链剖分即可，修改同2.。
	

因此就A了。
代码：
```cpp
#include<bits/stdc++.h>
#define M 100100
using namespace std;

//定义基本变量=====
int n,m,k,ans[M],sum;
int st[M],en[M]/*表示输入的边的起点终点*/;
int st2[M],en2[M]/*表示查询的边的起点终点*/,pd[M];
int sE[M]/*记录每一条边所对应的是第几个询问*/;
map<int,int>E[M]/*E[x][y]表示x到y对应的是第几条边*/;
//================= 

//邻接表=========== 

int cnt,to[M*2],id[M*2],nxt[M*2],first[M];

void addedge(int x,int y,int z){
	cnt++;
	to[cnt]=y;
	id[cnt]=z;
	nxt[cnt]=first[x];
	first[x]=cnt;
}

//=================
 
//bit==============

int c[M];

void addsum(int x,int w){
	while(x<=n)c[x]+=w,x+=x&-x;
}

int ask(int x){
	int res=0;
	while(x)res+=c[x],x-=x&-x;
	return res;
}

//=================

//树链剖分========= 

int gone[M]/*表示是否走过此点*/;
int in[M]/*表示树中是否有此边*/;
int dep[M],sz[M],son[M],fa[M];
int ID[M]/*记录dfs序*/,top[M],C/*dfs序*/; 

void search(int x,int f){
	fa[x]=f,sz[x]=1,gone[x]=1,dep[x]=dep[f]+1;
	for(int i=first[x];i;i=nxt[i]){
		int y=to[i];
		if(y==f||gone[y]||sE[id[i]]) continue;
		in[id[i]]=1,search(y,x);
		sz[x]+=sz[y];
		if(sz[y]>sz[son[x]]) son[x]=y;
	}
}

void dfs(int x,int tp){
	ID[x]=++C,top[x]=tp;
	if(son[x]) dfs(son[x],tp);
	if(x!=1) addsum(ID[x],1);
	for(int i=first[x];i;i=nxt[i]){
		int y=to[i];
		if(y!=fa[x]&&y!=son[x]&&in[id[i]]) dfs(y,y);
	}
}

int query(int x,int y){
	int res=0;
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		res+=ask(ID[x])-ask(ID[top[x]]-1);
		x=fa[top[x]];
	}
	if(dep[x]<dep[y]) swap(x,y);
	res+=ask(ID[x])-ask(ID[y]);
	return res;
}

//=================

//并查集处理===========

int Fa[M],mark[M];

int find(int x){
	if(Fa[x]!=x) Fa[x]=find(Fa[x]);
	return Fa[x];
}

void jump(int x,int y){
	x=find(x),y=find(y);
	if(x!=y)Fa[x]=y;
}

void Add(int x,int y){
	while(x!=y){
		if(dep[x]<dep[y]) swap(x,y);
		jump(x,fa[x]);
		if(x!=1&&!mark[x]) mark[x]=1,addsum(ID[x],-1);
		x=find(x);
	}
}

//=================

//主程序===========

int main(){
	
	//输入=========ok
	
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++) Fa[i]=i;
	for(int i=1;i<=m;i++){
		scanf("%d%d",&st[i],&en[i]);
		addedge(st[i],en[i],i),addedge(en[i],st[i],i);
		E[st[i]][en[i]]=i;
	}
	for(int i=1;i<=k;i++){
		scanf("%d%d%d",&pd[i],&st2[i],&en2[i]);
		if(!pd[i]) sE[E[st2[i]][en2[i]]]=i;
	}
	
	//cout<<"读入完毕"<<endl;
	
	//预处理树剖===ok
	
	search(1,0),dfs(1,1);
	
	//cout<<"树剖预处理完毕"<<endl;
	
	//建树=========ok
	
	for(int i=1;i<=m;i++)
		if(!in[i]&&!sE[i]){
			Add(st[i],en[i]);
		}
		
	//cout<<"建树完毕"<<endl;
	
	//处理询问=====ok
	
	for(int i=k;i>=1;i--){
		if(pd[i])ans[++sum]=query(st2[i],en2[i]);
		else if(E[st2[i]][en2[i]])Add(st2[i],en2[i]);
	}
	
	//cout<<"处理询问完毕"<<endl;
	
	//输出=========ok
	
	for(int i=sum;i>=1;i--) printf("%d\n",ans[i]);
	
	//cout<<"输出完毕"<<endl;
	
	//over=========ok
	
	return 0;
	
	//=============
	
}

//=================
```
（字数强行卡到了3000字整）


---

## 作者：Avocadooo (赞：0)

首先观察到题目中带有删边操作。

考虑到删边之后连通性比较难判断，考虑离线后倒序操作，删边就变为了加边。

我们做以下规定方便讲解：

- 定义倒序操作后的开始图为 $ P_0 $（即正序操作结束状态）。

- $ P_0 $ 为一个 $ n $ 点连通的无向图。

- 定义 $ P_0 $ 的一棵 dfs 树 $ T_0 $ 为任意一棵以 $ 1 $ 为根的生成树。

- 定义 $ T_0 $ 以外的边为额外边，额外边构成的集合为 $ E_0 $。

我们考虑在倒序操作的开头插入所有的 $ E_0 $ 中的边。那么 $ P_0 $ 就变为了一棵树，则有 $ P_0=T_0 $。

那么对于每一次操作，就相当于在 $ T_0 $ 上新增加了一条额外边。

显然额外边不是关键边，因为删掉它不会影响连通性。

而额外边 $ e=(u,v) $ 使得新增加了一条从 $ u $ 至 $ v $ 的道路，那么断开 $ u $ 到 $ v $ 之间的任意边都不会影响连通性。即在此之后，$ u $ 到 $ v $ 的所有边都不是关键边。如这个例子：

![](https://s1.ax1x.com/2022/11/05/xO3Wp8.png)

![](https://s1.ax1x.com/2022/11/05/xO3qhV.png)

![](https://s1.ax1x.com/2022/11/05/xO3X1U.png)

那么整道题变为了树上的边权赋值问题：

- 最开始每条边边权为 $ 1 $。（均是关键边）

- 每次加上一条额外边 $ e=(u,v) $，$ T_0 $ 上从 $ u $ 到 $ v $ 的边边权全部改为 $ 0 $。

- 每次询问 $ Q=(x,y) $，答案即为 $ T_0 $ 上 $ x $ 到 $ y $ 的路径上的边权和。

那么直接树剖 + 线段树维护一下即可。

代码如下：

```cpp
#include<bits/stdc++.h>
typedef long long ll;
using namespace std;
const int N=1000005;
int n,m,op[N],x[N],y[N],tot;
map<pair<int,int>,int> mp;
vector<int> Ans;
vector< pair<int,int> > els;
namespace dsu{
	int f[N];
	void clear(int n){for(int i=1;i<=n;f[i]=i,i++);}
	int fa(int s){return f[s]==s?s:f[s]=fa(f[s]);}
}
using namespace dsu;
namespace Chain{
	int h[N],cnt;
	struct Edge{int next,to;}e[N<<1];
	void AddEdge(int c,int d){e[++cnt]=(Edge){h[c],d};h[c]=cnt;}
}
using namespace Chain;
int fp[N];
namespace seg{
	int v[N<<2],lz[N<<2];
	#define lc (p<<1)
	#define rc (lc|1)
	void pushup(int p){v[p]=v[lc]+v[rc];}
	void bd(int p,int x,int y)
	{
		if(x==y) return void(v[p]=(fp[x]!=1));
		int mid=x+y>>1;
		bd(lc,x,mid),bd(rc,mid+1,y);
		pushup(p);
	}
	void pushdown(int p)
	{
		if(!lz[p]) return;
		lz[lc]=lz[rc]=lz[p];
		v[lc]=v[rc]=0;
		lz[p]=0;
	}
	void update(int p,int x,int y,int l,int r)
	{
		if(x>r || y<l) return;
		if(l<=x && y<=r) return v[p]=0,lz[p]=1,void();
		pushdown(p);
		int mid=x+y>>1;
		if(l<=mid) update(lc,x,mid,l,r);
		if(mid+1<=r) update(rc,mid+1,y,l,r);
		pushup(p);
	}
	int getans(int p,int x,int y,int l,int r)
	{
		if(x>r || y<l) return 0;
		if(l<=x && y<=r) return v[p];
		pushdown(p);
		int mid=x+y>>1,rec=0;
		if(l<=mid) rec+=getans(lc,x,mid,l,r);
		if(mid+1<=r) rec+=getans(rc,mid+1,y,l,r);
		return rec;
	}
}
using namespace seg;
namespace ts{
	int top[N],son[N],sign;
	int prt[N],siz[N],dep[N],p[N];
	void dfs(int r,int fa,int d)
	{
		siz[r]=1; prt[r]=fa; dep[r]=d;
		for(int i=h[r];i;i=e[i].next)
		{
			int y=e[i].to;
			if(y==fa) continue;
			dfs(y,r,d+1);
			siz[r]+=siz[y];
			if(!son[r] || siz[son[r]]<siz[y]) son[r]=y;
		}
	}
	void pre(int r,int _)
	{
		top[r]=_;
		p[r]=++sign; fp[sign]=r;
		if(son[r]) pre(son[r],_);
		for(int i=h[r];i;i=e[i].next)
		{
			int y=e[i].to;
			if(y==prt[r] || y==son[r]) continue;
			pre(y,y);
		}
	}
	void add(int x,int y)
	{
		int f1=top[x],f2=top[y];
		while(f1!=f2)
		{
			if(dep[f1]<dep[f2]) swap(f1,f2),swap(x,y);
			update(1,1,n,p[f1],p[x]);
			x=prt[f1],f1=top[x];
		}
		if(x==y) return;
		if(dep[x]>dep[y]) swap(x,y);
		update(1,1,n,p[son[x]],p[y]);
	}
	int ask(int x,int y)
	{
		int f1=top[x],f2=top[y],rec=0;
		while(f1!=f2)
		{
			if(dep[f1]<dep[f2]) swap(f1,f2),swap(x,y);
			rec+=getans(1,1,n,p[f1],p[x]);
			x=prt[f1],f1=top[x];
		}
		if(x==y) return rec;
		if(dep[x]>dep[y]) swap(x,y);
		return rec+getans(1,1,n,p[son[x]],p[y]);
	}
	void output()
	{
		for(int i=1;i<=n;i++) printf("%d %d\n",i,getans(1,1,n,p[i],p[i]));puts("");
	}
}
int main()
{
	scanf("%d %d",&n,&m);
	clear(n);
	for(int i=1,A,B;i<=m;i++) 
	{
		scanf("%d %d",&A,&B);
		mp[make_pair(A,B)]++;
	}
	while(true)
	{
		++tot;
		scanf("%d",&op[tot]);
		if(op[tot]==-1) break;
		scanf("%d %d",x+tot,y+tot);
		if(op[tot]==0)
			if(mp.count(make_pair(x[tot],y[tot]))) mp[make_pair(x[tot],y[tot])]--;
			else mp[make_pair(y[tot],x[tot])]--;
	} --tot;
	
	for(map<pair<int,int>,int>::iterator it=mp.begin();it!=mp.end();++it)
	{
		if(!it->second) continue;
		int x=it->first.first,y=it->first.second;
		if(fa(x)==fa(y)) els.push_back(it->first);// P_0 中除 T_0 以外的边 
		else
		{
			f[fa(x)]=fa(y);
			AddEdge(x,y),AddEdge(y,x);
		}
	}
	ts::dfs(1,-1,0); ts::pre(1,1);
	bd(1,1,n);
	for(int i=0;i!=els.size();++i) ts::add(els[i].first,els[i].second);
	for(int i=tot;i>=1;i--)
	{
		if(op[i]==1) Ans.push_back(ts::ask(x[i],y[i]));
		else if(op[i]==0) ts::add(x[i],y[i]);
	}
	reverse(Ans.begin(),Ans.end());
	for(int i=0;i!=Ans.size();++i) printf("%d\n",Ans[i]);
}
```

---

## 作者：too_later (赞：0)

[题](https://www.luogu.com.cn/problem/P2542)

### 题目大意：

对于一个图，支持两种操作：

- 1 u v，询问 u,v 路径上必经过的路径的个数。

- 0 u v，断开 u,v。

$1\le n\le 3\times 10^4,1≤m≤10^5,1\le q\le 4\times 10^4$。

### 思路：

必须经过的边，也就是断了这条边之后两点没有路径。

这是不是很像“桥”的定义？

直接 e-DCC，处理环之后，答案就是两点路径上的个数。

怎么维护一个 e-DCC 呢？

断边操作比较复杂（至少现在我是不知道怎么做），处理环的时候如果加边就可以用并查集维护了。

考虑离线加边操作。用 LCT 来维护这个 siz。

如果一些点在一个环上，那么这群个点视为一个点。

每次操作之前先 find(x) 一下，然后对于这个点，断开与其为环的所有连边。

这样时间复杂度就能保证了。

一些要注意的细节：

- 哪里都要 find(p) 一下。

- 一开始判重是双向边，所以要双向判重。

### Code:

```cpp
// 未加防作弊
#include <bits/stdc++.h>
#define I inline
#define RI register int
#define CI const int
#define ls ch[p][0]
#define rs ch[p][1]
#define N 30005
#define M 100005
using namespace std;

int top, t, n, m, u, v, op, x, y, tot, X[N], Y[N], OP[N], ans[N], st[N], f[N], sz[N], tag[N], fa[N], ch[N][2];
map<int, map<int, int> > mp;

I int find(CI x) { return x == fa[x] ? x : fa[x] = find(fa[x]); }
I void merge(CI x, CI y) {
    RI fx = find(x), fy = find(y);
    if (fx != fy)
        fa[fx] = fy;
}
I bool get(CI p) { return ch[find(f[p])][1] == p; }
I bool isroot(CI p) { return ch[find(f[p])][0] != p && ch[find(f[p])][1] != p; }
I void down(CI p) {
    if (!tag[p])
        return;
    swap(ls, rs), tag[ls] ^= 1, tag[rs] ^= !(tag[p] = 0);
}
I void up(CI p) {
    down(ls), down(rs);
    sz[p] = 1 + (ls ? sz[ls] : 0) + (rs ? sz[rs] : 0);
}
I void rotate(int x) {
    x = find(x);
    RI y = find(f[x]), z = find(f[y]), k = get(x);
    if (!isroot(y))
        ch[z][ch[z][1] == y] = x;
    f[ch[y][k] = ch[x][!k]] = y;
    f[ch[x][!k] = y] = x;
    f[x] = z;
    up(y), up(x);
}
I void splay(CI x) {
    RI i = x, y;
    st[top = 1] = find(i);
    while (!isroot(i)) st[++top] = i = find(f[i]);
    while (top) down(st[top--]);
    for (i = find(x); y = find(f[i]), !isroot(i); rotate(i))
        if (!isroot(y))
            rotate(get(i) == get(y) ? y : i);
}
I void access(CI x) {
    RI p = find(x), q;
    for (q = 0; p; q = p, p = find(f[p])) splay(p), rs = q, up(p);
}
I void makeroot(int x) {
    x = find(x);
    access(x), splay(x), tag[x] ^= 1;
}
I int findroot(int x) {
    RI p = (x = find(x));
    access(x), splay(x);
    while (ls) down(ls), p = ls;
    return splay(p), p;
}
I void split(CI x, CI y) { makeroot(x), access(y), splay(y); }
I void dfs(CI p, CI q) {
    down(p);
    if (ls)
        merge(ls, q), dfs(ls, q);
    if (rs)
        merge(rs, q), dfs(rs, q), ls = rs = 0, up(p);
}

int main() {
    RI i;
    for (scanf("%d%d", &n, &m), i = 1; i <= m; i++) scanf("%d%d", &x, &y), mp[x][y] = mp[y][x] = 1;
    for (i = 1; i <= n; i++) fa[i] = i;
    while (scanf("%d", &op) && op != -1) {
        scanf("%d%d", &x, &y), OP[++tot] = op, X[tot] = x, Y[tot] = y;
        if (!op)
            mp[x][y] = mp[y][x] = 0;
    }
    for (map<int, map<int, int> >::iterator it = mp.begin(); it != mp.end(); it++) {
        for (map<int, int>::iterator it2 = mp[it->first].begin(); it2 != mp[it->first].end(); it2++) {
            if (!(it2->second))
                continue;
            mp[it2->first][it->first] = 0;
            x = find(it->first), y = find(it2->first);
            if (x == y)
                continue;
            if (findroot(x) != findroot(y))
                makeroot(x), f[x] = y;
            else
                split(x, y), dfs(y, y), up(y), 0;
        }
    }
    for (i = tot; i; i--) {
        x = find(X[i]), y = find(Y[i]);
        if (!OP[i])
            split(x, y), dfs(y, y), up(y);
        else
            split(x, y), ans[++ans[0]] = sz[y] - 1;
    }
    for (i = ans[0]; i; i--) printf("%d\n", ans[i]);
    return 0;
}
```

---


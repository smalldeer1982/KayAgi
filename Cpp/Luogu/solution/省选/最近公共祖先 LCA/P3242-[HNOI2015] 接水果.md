# [HNOI2015] 接水果

## 题目描述

风见幽香非常喜欢玩一个叫做 osu! 的游戏，其中她最喜欢玩的模式就是接水果。由于她已经 DT FC 了 The big black，她觉得这个游戏太简单了，于是发明了一个更加难的版本。

首先有一个地图，是一棵由 $n$ 个顶点，$n-1$ 条边组成的树。

这颗树上有 $p$ 个盘子，每个盘子实际上是一条路径，并且每个盘子还有一个权值。第 $i$ 个盘子就是顶点 $a_i$ 到顶点 $b_i$ 的路径（由于是树，所以从 $a_i$ 到 $b_i$ 的路径是唯一的），权值为 $c_i$。

接下来依次会有 $q$ 个水果掉下来，每个水果本质上也是一条路径，第 $i$ 个水果是从顶点 $u_i$ 到顶点 $v_i$ 的路径。

幽香每次需要选择一个盘子去接当前的水果：一个盘子能接住一个水果，当且仅当盘子的路径是水果的路径的子路径。这里规定：从 $a$ 到 $b$ 的路径与从 $b$ 到 $a$ 的路径是同一条路径。

当然为了提高难度，对于第 $i$ 个水果，你需要选择能接住它的所有盘子中，权值第 $k_i$ 小的那个盘子，每个盘子可重复使用（没有使用次数的上限：一个盘子接完一个水果后，后面还可继续接其他水果，只要它是水果路径的子路径）。幽香认为这个游戏很难，你能轻松解决给她看吗？


## 说明/提示

对于 $100\%$ 的数据，$1\leq n,p,q \leq4\times 10^4$，$0 \le c \le 10^9$。


## 样例 #1

### 输入

```
10 10 10
1 2
2 3
3 4
4 5
5 6
6 7
7 8
8 9
9 10
3 2 217394434
10 7 13022269
6 7 283254485
6 8 333042360
4 6 442139372
8 3 225045590
10 4 922205209
10 8 808296330
9 2 486331361
4 9 551176338
1 8 5
3 8 3
3 8 4
1 8 3
4 8 1
2 3 1
2 3 1
2 3 1
2 4 1
1 4 1```

### 输出

```
442139372 
333042360 
442139372 
283254485 
283254485 
217394434 
217394434 
217394434 
217394434 
217394434```

# 题解

## 作者：Owen_codeisking (赞：43)

从下午三点开此题调到到七点，$A$ 掉此题的感觉真的是太爽了！！！

而且我觉得这道题对于练整体二分非常的好，就是写的人有点少。

不过为什么盘子是水果的子路径才是接住啊。。。不应该盘子比水果大的嘛。。。

我们将此路径覆盖分两类讨论：

不妨令 $st_x<st_y$

1、$LCA(x,y)=x$

那么我们发现其实路径一个端点在 $[st_y,ed_y]$，另一个不在除 $x,y$ 外 $x->y$ 的路径上的点 $z$ 的子树内就行了，即 $[1,st_z-1]\ or\ [ed_z+1,n]$。其实用树剖一直向上跳，跳到离 $x$ 最近的点且其子树内包含 $y$ 就是 $z$ 了。

2、$LCA(x,y)\not =x$

那么一个点在 $[st_x,ed_x]$，另一个点在 $[st_y,ed_y]$ 就行了

发现可以做一遍扫描线，直接暴力树套树。在内层线段树动态开点，然后二分答案，$\log^2 n$ 验证，时间复杂度 $O(n\log^3n)$，空间复杂度 $O(n\log^2 n)$

那有没有更好的解法呢？发现没有离线，第 $k$ 小，

我们可以请出我们的整体二分！

然后正解就是扫描线+整体二分了。把矩形差分一下，然后区间加，单点查，套一个差分的树状数组就好了。时间复杂度 $O(n\log^2 n)$，空间复杂度 $O(n)$

$Code\ Below:$

```cpp
#include <bits/stdc++.h>
#define lowbit(x) ((x)&(-(x)))
using namespace std;
const int maxn=40000+10;
int n,m,Q,c[maxn],ans[maxn],mp[maxn],lim,head[maxn],to[maxn<<1],nxt[maxn<<1],tot,cnt;
int top[maxn],dep[maxn],siz[maxn],son[maxn],fa[maxn],st[maxn],ed[maxn],tim;

struct Query{
    int op,x,l,r,k,v,id;
}q[maxn*5],q1[maxn*5],q2[maxn*5];

bool cmp(Query a,Query b){
    if(a.x!=b.x) return a.x<b.x;
    return a.op<b.op;
}

inline void read(int &x){
    x=0;int f=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
    while(isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
    if(f==-1) x=-x;
}
void print(int x){
    if(x<0){putchar('-');x=-x;}
    if(x>9) print(x/10);
    putchar(x%10+'0');
}

inline void upd(int x,int y){
    for(;x<=n;x+=lowbit(x)) c[x]+=y;
}
inline int sum(int x){
    int ans=0;
    for(;x;x-=lowbit(x)) ans+=c[x];
    return ans;
}

inline void add(int x,int y){
    to[++tot]=y;
    nxt[tot]=head[x];
    head[x]=tot;
}

void dfs1(int x,int f){
    fa[x]=f;siz[x]=1;
    dep[x]=dep[f]+1;
    int maxson=-1;
    for(int i=head[x],y;i;i=nxt[i]){
        y=to[i];
        if(y==f) continue;
        dfs1(y,x);
        siz[x]+=siz[y];
        if(siz[y]>maxson){
            maxson=siz[y];
            son[x]=y;
        }
    }
}

void dfs2(int x,int topf){
    top[x]=topf;
    st[x]=++tim;
    if(son[x]) dfs2(son[x],topf);
    for(int i=head[x],y;i;i=nxt[i]){
        y=to[i];
        if(y==fa[x]||y==son[x]) continue;
        dfs2(y,y);
    }
    ed[x]=tim;
}

int LCA(int x,int y){
    while(top[x]!=top[y]){
        if(dep[top[x]]<dep[top[y]]) swap(x,y);
        x=fa[top[x]];
    }
    if(dep[x]>dep[y]) swap(x,y);
    return x;
}

int getson(int x,int y){
    while(top[x]!=top[y]){
        if(fa[top[x]]==y) return top[x];
        x=fa[top[x]];
    }
    return son[y];
}

void solve(int L,int R,int l,int r){
    if(L>R) return ;
    if(l==r){
        for(int i=L;i<=R;i++)
            if(q[i].op==2) ans[q[i].id]=mp[l];
        return ;
    }
    int mid=(l+r)>>1,cnt1=0,cnt2=0,val;
    for(int i=L;i<=R;i++){
        if(q[i].op==1){
            if(q[i].k<=mid){
                upd(q[i].l,q[i].v);upd(q[i].r+1,-q[i].v);
                q1[++cnt1]=q[i];
            }
            else q2[++cnt2]=q[i];
        }
        else {
            val=sum(q[i].l);
            if(val>=q[i].k) q1[++cnt1]=q[i];
            else q[i].k-=val,q2[++cnt2]=q[i];
        }
    }
    for(int i=1;i<=cnt1;i++) q[L+i-1]=q1[i];
    for(int i=1;i<=cnt2;i++) q[L+i+cnt1-1]=q2[i];
    solve(L,L+cnt1-1,l,mid);solve(L+cnt1,R,mid+1,r);
}

int main()
{
    read(n),read(m),read(Q);
    int x,y,z,l,r,k,lca;
    for(int i=1;i<n;i++){
        read(x),read(y);
        add(x,y);add(y,x);
    }
    dfs1(1,0);dfs2(1,1);
    for(int i=1;i<=m;i++){
        read(x),read(y),read(k);mp[i]=k;
        if(st[x]>st[y]) swap(x,y);
        lca=LCA(x,y);
        if(lca==x){
            z=getson(y,x);
            if(st[z]>1){
                q[++cnt]=(Query){1,1,st[y],ed[y],k,1,0};
                q[++cnt]=(Query){1,st[z],st[y],ed[y],k,-1,0};
            }
            if(ed[z]<n){
                q[++cnt]=(Query){1,st[y],ed[z]+1,n,k,1,0};
                q[++cnt]=(Query){1,ed[y]+1,ed[z]+1,n,k,-1,0};
            }
        }
        else {
            q[++cnt]=(Query){1,st[x],st[y],ed[y],k,1,0};
            q[++cnt]=(Query){1,ed[x]+1,st[y],ed[y],k,-1,0};
        }
    }
    sort(mp+1,mp+m+1);
    lim=unique(mp+1,mp+m+1)-mp-1;
    for(int i=1;i<=cnt;i++) q[i].k=lower_bound(mp+1,mp+lim+1,q[i].k)-mp;
    for(int i=1;i<=Q;i++){
        read(x),read(y),read(k);
        if(st[x]>st[y]) swap(x,y);
        q[++cnt]=(Query){2,st[x],st[y],0,k,0,i};
    }
    sort(q+1,q+cnt+1,cmp);
    solve(1,cnt,1,lim);
    for(int i=1;i<=Q;i++) printf("%d\n",ans[i]);
    return 0;
}
```

---

## 作者：Kelin (赞：33)

## [题意](https://blog.csdn.net/BeNoble_/article/details/79894444)

给你一个树上路径集合$S,$每条路径有个权值

每次询问一条路径$p:x\to y,$问他在$S$中包含的路径中权值第$k$小的是多少

---

## 题解

### 先考虑怎么判断一条路径是否被另一条路径包含

先求出这棵树的$dfs$序$,$记$L_u=dfn_u,R_u=dfn_u+sz_u-1$

考虑把一条路径$u\to v$投影成二维平面上的点$(L_u,L_v),L_u<L_v$

一$.$如果是在链上

>那么包含$u\to v$的路径$x\to y$要满足$1\le L_x\le L_u,L_v\le L_y\le R_v$

>也就是要求点$(L_x,L_y)$在矩形$\{(1,L_v),(L_u,R_v)\}$中

**所以**

>一条路径包含多少条路径$\Leftrightarrow$对应点被多少个矩形覆盖

>后者可以按照$x$排序扫描线然后维护$y$坐标的前缀和求出

二$.$考虑在树上

$1.$如果$lca(u,v)\neq u$

>那么就要求路径$p$满足$x$在$u$的子树里$,y$在$v$的子树里

>也就是$L_u\le L_x\le R_u,L_v\le L_y\le R_v$

>即$(L_x,L_y)$在矩形$\{(L_u,L_v),(R_u,R_v)\}$里

$2.$如果$lca(u,v)=u$

>设$z$是$u\to v$上的第一个点

>那么就要求路径$p$满足一个节点在$v$子树内$,$一个节点在$z$子树外

>也就是$(L_x,L_y)$在矩形$\{(1,L_v),(L_z-1,R_v)\}\cup\{(L_v,R_z+1),(R_v,n)\}$中


### 考虑怎么求解

如果只有一个询问我们可以二分一个答案

然后加入权值小于这个答案的路径对应的矩形$,$然后判断$(L_x,L_y)$被覆盖了多少次

如果询问很多我们就可以用整体二分

### 考虑怎么卡常

$1.lca(u,v)=u\Leftrightarrow L_v\in[L_u,R_u]$

$2.$找路径上第一个点可以用树剖$,$比倍增快很多

$3.$维护$y$坐标前缀和用树状数组即可

$4.$二分答案的区间应该是$[1,P]$而不是$[1,\infty]$

$5.$不要存矩形$,$直接存扫描线

$6.$先在外面把点和扫描线按照$x$排序然后在整体二分里面只要$two-pointer$扫一下

$7.two-pointer$时以点的$x$坐标为基准会好写一些

$8.$整体二分中传下去的操作也要满足$x$升序这样就不要每次排序了

$9.$用指针也许会快一些


非指针版
```
#include<bits/stdc++.h>
#define fp(i,a,b) for(register int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(register int i=a,I=b-1;i>I;--i)
#define go(u) for(register int i=fi[u],v=e[i].to;i;v=e[i=e[i].nx].to)
#define file(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
template<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}
template<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}
using namespace std;
char ss[1<<17],*A=ss,*B=ss;
inline char gc(){return A==B&&(B=(A=ss)+fread(ss,1,1<<17,stdin),A==B)?-1:*A++;}
template<class T>inline void sd(T&x){
    char c;T y=1;while(c=gc(),(c<48||57<c)&&c!=-1)if(c==45)y=-1;x=c-48;
    while(c=gc(),47<c&&c<58)x=x*10+c-48;x*=y;
}
char sr[1<<21],z[20];int C=-1,Z;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
template<class T>inline void we(T x){
    if(C>1<<20)Ot();if(x<0)sr[++C]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]='\n';
}
const int N=2e5+5,inf=1e9;
typedef int arr[N];
struct eg{int nx,to;}e[N];
struct Line{
    int x,L,R,w,val;
    inline bool operator<(const Line b)const{return x<b.x;}
}p[N],tp[N];
struct qry{
    int x,y,k,id;
    inline bool operator<(const qry b)const{return x<b.x;}
}q[N],tq[N];
int n,m,Q,dft;arr c,h,fa,fi,sz,Lx,Rx,dep,son,top,ans;
void dfs(int u){
    dep[u]=dep[fa[u]]+(sz[u]=1);
    go(u)if(v^fa[u]){
        fa[v]=u,dfs(v),sz[u]+=sz[v];
        if(sz[v]>sz[son[u]])son[u]=v;
    }
}
void dfs(int u,int t){
    Lx[u]=++dft;top[u]=t;if(son[u])dfs(son[u],t);
    go(u)if(v^fa[u]&&v^son[u])dfs(v,v);Rx[u]=dft;
}
inline int Go(int u,int p){
    while(top[u]^top[p]){
        if(fa[top[u]]==p)return top[u];
        u=fa[top[u]];
    }return top[u]==u?u:son[p];
}
inline void mdy(int i,int w){for(;i<=n;i+=i&-i)c[i]+=w;}
inline int qry(int i){int w=0;for(;i;i-=i&-i)w+=c[i];return w;}
inline void mdy(int L,int R,int w){mdy(L,w),mdy(R+1,-w);}
void sol(int b,int e,int s,int t,int L,int R){
    if(b>e||s>t)return;
    if(L==R){fp(i,s,t)ans[q[i].id]=h[L];return;}
    int mid=(L+R)>>1,tl=b,tr=e,sl=s,sr=t,j=b,sp;
    fp(i,s,t){
        for(;j<=e&&p[j].x<=q[i].x;++j)
            if(p[j].val>h[mid])tp[tr--]=p[j];
            else mdy(p[j].L,p[j].R,p[j].w),tp[tl++]=p[j];
        q[i].k>(sp=qry(q[i].y))?q[i].k-=sp,tq[sr--]=q[i]:tq[sl++]=q[i];
    }
    for(;j<=e;++j)if(p[j].val>h[mid])tp[tr--]=p[j];
        else mdy(p[j].L,p[j].R,p[j].w),tp[tl++]=p[j];
    fp(i,b,tr)mdy(tp[i].L,tp[i].R,-tp[i].w);
    fp(i,b,tr)p[i]=tp[i];fp(i,tl,e)p[e+tl-i]=tp[i];
    fp(i,s,sr)q[i]=tq[i];fp(i,sl,t)q[t+sl-i]=tq[i];
    sol(b,tr,s,sr,L,mid);sol(tl,e,sl,t,mid+1,R);
}
inline void add(int u,int v){static int ce=0;e[++ce]={fi[u],v},fi[u]=ce;}
int main(){
    #ifndef ONLINE_JUDGE
        file("s");
    #endif
    int u,v,w;sd(n),sd(w),sd(Q);
    fp(i,2,n)sd(u),sd(v),add(u,v),add(v,u);
    dfs(1),dfs(1,1);
    fp(i,1,w){
        sd(u),sd(v),sd(h[i]);
        if(Lx[u]>Lx[v])swap(u,v);
        if(Lx[u]<=Lx[v]&&Rx[v]<=Rx[u]){
            int z=Go(v,u);
            p[++m]={1,Lx[v],Rx[v],1,h[i]};
            p[++m]={Lx[z],Lx[v],Rx[v],-1,h[i]};
            if(Rx[z]<n)p[++m]={Lx[v],Rx[z]+1,n,1,h[i]},
                p[++m]={Rx[v]+1,Rx[z]+1,n,-1,h[i]};
        }else p[++m]={Lx[u],Lx[v],Rx[v],1,h[i]},p[++m]={Rx[u]+1,Lx[v],Rx[v],-1,h[i]};
    }sort(p+1,p+m+1);sort(h+1,h+w+1);h[0]=unique(h+1,h+w+1)-h-1;
    fp(i,1,Q){
        sd(u),sd(v),sd(w);
        if(Lx[u]>Lx[v])swap(u,v);
        q[i]={Lx[u],Lx[v],w,i};
    }sort(q+1,q+Q+1);
    sol(1,m,1,Q,1,h[0]);
    fp(i,1,Q)we(ans[i]);
return Ot(),0;
}
```
指针版$($写起来好像也没啥区别$,$应该是我不太会用吧$)$
```
#include<bits/stdc++.h>
#define fp(i,a,b) for(register int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(register int i=a,I=b-1;i>I;--i)
#define go(u) for(register int i=fi[u],v=e[i].to;i;v=e[i=e[i].nx].to)
#define file(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
template<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}
template<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}
using namespace std;
char ss[1<<17],*A=ss,*B=ss;
inline char gc(){return A==B&&(B=(A=ss)+fread(ss,1,1<<17,stdin),A==B)?-1:*A++;}
template<class T>inline void sd(T&x){
    char c;T y=1;while(c=gc(),(c<48||57<c)&&c!=-1)if(c==45)y=-1;x=c-48;
    while(c=gc(),47<c&&c<58)x=x*10+c-48;x*=y;
}
char sr[1<<21],z[20];int C=-1,Z;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
template<class T>inline void we(T x){
    if(C>1<<20)Ot();if(x<0)sr[++C]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]='\n';
}
const int N=2e5+5,inf=1e9;
typedef int arr[N];
struct eg{int nx,to;}e[N];
struct Line{
    int x,L,R,w,val;
    inline bool operator<(const Line b)const{return x<b.x;}
}Li[N],*p[N],*tp[N];
struct qry{
    int x,y,k,id;
    inline bool operator<(const qry b)const{return x<b.x;}
}Qr[N],*q[N],*tq[N];
int n,m,Q,dft;arr c,h,fa,fi,sz,Lx,Rx,dep,son,top,ans;
void dfs(int u){
    dep[u]=dep[fa[u]]+(sz[u]=1);
    go(u)if(v^fa[u]){
        fa[v]=u,dfs(v),sz[u]+=sz[v];
        if(sz[v]>sz[son[u]])son[u]=v;
    }
}
void dfs(int u,int t){
    Lx[u]=++dft;top[u]=t;if(son[u])dfs(son[u],t);
    go(u)if(v^fa[u]&&v^son[u])dfs(v,v);Rx[u]=dft;
}
inline int Go(int u,int p){
    while(top[u]^top[p]){
        if(fa[top[u]]==p)return top[u];
        u=fa[top[u]];
    }return top[u]==u?u:son[p];
}
inline void mdy(int i,int w){for(;i<=n;i+=i&-i)c[i]+=w;}
inline int qry(int i){int w=0;for(;i;i-=i&-i)w+=c[i];return w;}
inline void mdy(int L,int R,int w){mdy(L,w),mdy(R+1,-w);}
void sol(int b,int e,int s,int t,int L,int R){
    if(b>e||s>t)return;
    if(L==R){fp(i,s,t)ans[q[i]->id]=h[L];return;}
    int mid=(L+R)>>1,tl=b,tr=e,sl=s,sr=t,j=b,sp;
    fp(i,s,t){
        for(;j<=e&&p[j]->x<=q[i]->x;++j)
            if(p[j]->val>h[mid])tp[tr--]=p[j];
            else mdy(p[j]->L,p[j]->R,p[j]->w),tp[tl++]=p[j];
        q[i]->k>(sp=qry(q[i]->y))?q[i]->k-=sp,tq[sr--]=q[i]:tq[sl++]=q[i];
    }
    for(;j<=e;++j)if(p[j]->val>h[mid])tp[tr--]=p[j];
        else mdy(p[j]->L,p[j]->R,p[j]->w),tp[tl++]=p[j];
    fp(i,b,tr)mdy(tp[i]->L,tp[i]->R,-tp[i]->w);
    fp(i,b,tr)p[i]=tp[i];fp(i,tl,e)p[e+tl-i]=tp[i];
    fp(i,s,sr)q[i]=tq[i];fp(i,sl,t)q[t+sl-i]=tq[i];
    sol(b,tr,s,sr,L,mid);sol(tl,e,sl,t,mid+1,R);
}
inline void add(int u,int v){static int ce=0;e[++ce]={fi[u],v},fi[u]=ce;}
int main(){
    #ifndef ONLINE_JUDGE
        file("s");
    #endif
    int u,v,w;sd(n),sd(w),sd(Q);
    fp(i,2,n)sd(u),sd(v),add(u,v),add(v,u);
    dfs(1),dfs(1,1);
    fp(i,1,w){
        sd(u),sd(v),sd(h[i]);
        if(Lx[u]>Lx[v])swap(u,v);
        if(Lx[u]<=Lx[v]&&Rx[v]<=Rx[u]){
            int z=Go(v,u);
            Li[++m]={1,Lx[v],Rx[v],1,h[i]};
            Li[++m]={Lx[z],Lx[v],Rx[v],-1,h[i]};
            if(Rx[z]<n)Li[++m]={Lx[v],Rx[z]+1,n,1,h[i]},
                Li[++m]={Rx[v]+1,Rx[z]+1,n,-1,h[i]};
        }else Li[++m]={Lx[u],Lx[v],Rx[v],1,h[i]},Li[++m]={Rx[u]+1,Lx[v],Rx[v],-1,h[i]};
    }sort(Li+1,Li+m+1);fp(i,1,m)p[i]=Li+i;
    sort(h+1,h+w+1);h[0]=unique(h+1,h+w+1)-h-1;
    fp(i,1,Q){
        sd(u),sd(v),sd(w);
        if(Lx[u]>Lx[v])swap(u,v);
        Qr[i]={Lx[u],Lx[v],w,i};
    }
	sort(Qr+1,Qr+Q+1);fp(i,1,Q)q[i]=Qr+i;
    sol(1,m,1,Q,1,h[0]);fp(i,1,Q)we(ans[i]);
return Ot(),0;
}
```

写在最后$:$窝再也不敢乱卡常了$,$写完后调试到绝望![这里写图片描述](https://img-blog.csdn.net/20180411114923645?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JlTm9ibGVf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

---

## 作者：Vocalise (赞：14)

挺毒的一道题。

首先还是要说说如何将问题转化的，即如何考虑路径之间的包含关系。

我们有 DFS 序：入序 $ln_x$ 及出序 $rn_x=ln_x+size_x-1$。

设有 $ln_x < ln_y$，$ln_v < ln_u$，路径 $(x,y)$ 包含 $(v,u)$。

讨论 $(v,u)$ 路径的形态。

---

$u$ 在 $v$ 的子树中，可以表示为 $rn_u \leq rn_v$：

![](https://cdn.luogu.com.cn/upload/image_hosting/w7zzkn6u.png)

考虑 $z$ 为 $(v,u)$ 路径上距离 $v$ 最近的点，发现 $(x,y)$ 一个在 $z$ 的子树之外，一个在 $u$ 的子树之内。求 $z$ 可以倍增或树剖随便。

前者的 $ln$ 区间为 $[1,ln_z)\cup(rn_z,n]$，而后者为 $[ln_u,rn_u]$。

于是 $x$ 就是前者， $y$ 就是后者吗？也不尽然。

如果 $ln_z > 1$，则 $x\in[1,ln_z)$， $y\in[ln_u,rn_u]$ 时包含；

同时如果 $rn_z < n$，则 $x\in[ln_u,rn_u]$，$y\in(rn_z,n]$ 时包含。

发现两种情况没有交集，看作两个条件即可。

---

$u$ 和 $v$ 互不为祖先。

![](https://cdn.luogu.com.cn/upload/image_hosting/b4h6f66q.png)

这种情况就是 $x,y$ 分别在 $v,u$ 子树中了。即：$x\in[ln_v,rn_v],y\in[ln_u,rn_u]$。

---

发现对于每个条件， $x$ 和 $y$ 都属于一个区间，即对于一个点 $(x,y)$，它在一个矩形中时，这条路径 $(x,y)$ 被该路径包含。

问题变为：求若干点包含其的权值 $k$ 大矩形。

考虑一个弱化问题：求若干点包含其的矩形数。

自然问矩形包含的点数我们知道怎么求：把一个坐标轴变为时间轴，矩形拆成 $4$ 个前缀，扫描线顺序插入，维护树状数组即可。

事实上这个问题也可以这么做。树状数组单点加区间查改成区间加单点查即可，具体地：

![](https://cdn.luogu.com.cn/upload/image_hosting/0kf1zafc.png)

从下往上扫，到 $x1$ 位置时在 $[y1,y2]$ 上加一，到询问点时查询其横坐标上的值，到 $x2 + 1$ 时在 $[y1,y2]$ 上减一。

这个问题带上 $k$ 大且可以离线，整体二分。

在二分里不用排序，之前按 $y$ 坐标第一，修改在前第二排好序；树状数组维护 $x$ 坐标轴；二分本身维护权值轴。

整体二分本身是模板，可以去其它题目如 [P3332 [ZJOI2013]K大数查询](https://www.luogu.com.cn/problem/P3332) 看看。

求包含数的子问题是 $O(n\log n)$ 的，套上整体二分，总复杂度是 $O(n\log^2n)$ 的。

> 注意：

1. $(x,y)$ 和 $(v,u)$ 都是有序的；
3. 操作中直接存矩形的边界线即可；
2. $y$ 坐标相同时，修改应该在前；
4. 操作数组的空间较大。

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <cmath>
#include <algorithm>

const int MAXN = 50001;

inline int read() {
    int x = 0, f = 1; char ch = getchar();
    while(ch > '9' || ch < '0') { if(ch == '-') f = -1; ch = getchar(); }
    do x = x * 10 + ch - 48, ch = getchar(); while(ch >= '0' && ch <= '9');
    return x * f;
}

struct Edge {
    int u; Edge *nxt;
} *adj[MAXN];
void ins(int v,int u) {
    Edge *e = new Edge; e -> u = u;
    e -> nxt = adj[v], adj[v] = e;
}

int fa[MAXN],d[MAXN],sv[MAXN],son[MAXN],top[MAXN];
int ln[MAXN],rn[MAXN],dfn;

void Dfs1(int v,int f) {
    ln[v] = ++dfn;
    fa[v] = f, d[v] = d[f] + 1, sv[v] = 1;
    for(Edge *i = adj[v];i;i = i -> nxt) {
        int u = i -> u;
        if(u == f) continue;
        Dfs1(u,v);
        sv[v] += sv[u]; if(sv[u] > sv[son[v]]) son[v] = u;
    }
    rn[v] = dfn;
}

void Dfs2(int v,int t) {
    top[v] = t;
    if(!son[v]) return;
    Dfs2(son[v],t);
    for(Edge *i = adj[v];i;i = i -> nxt) {
        int u = i -> u;
        if(top[u]) continue;
        Dfs2(u,u);
    }
}

int GetSon(int v,int u) {
    while(top[v] != top[u]) {
        if(fa[top[v]] == u) return top[v];
        v = fa[top[v]];
    }
    return son[u];
}

struct Item {
    int tp,y,l,r,k,id;
    Item() {}
    Item(int _tp,int _y,int _l,int _r,int _k,int _id) :
        tp(_tp), y(_y), l(_l), r(_r), k(_k), id(_id) {}
    friend bool operator <(const Item &x,const Item &y) {
        if(x.y != y.y) return x.y < y.y;
        else return x.tp < y.tp;
    }
} p[MAXN * 4], p1[MAXN * 4], p2[MAXN * 4];
int n,m,q,b[MAXN],ans[MAXN],f[MAXN];

void Add(int i,int x) {
    for(;i <= n;i += i & (-i))
        f[i] += x;
}

int Sum(int i) {
    int ans = 0;
    for(;i;i -= i & (-i)) ans += f[i];
    return ans;
}

void Solve(int l,int r,int L,int R) {
    if(L > R) return;
    if(l == r) {
        for(int i = L;i <= R;i++)
            if(p[i].tp) ans[p[i].id] = l;
        return;
    }
    int m = (l + r) >> 1, c1 = 0, c2 = 0;
    for(int i = L;i <= R;i++) if(!p[i].tp) {
        if(p[i].k <= m) Add(p[i].l,p[i].id), Add(p[i].r + 1,-p[i].id), p1[++c1] = p[i];
        else p2[++c2] = p[i];
    } else {
        int s = Sum(p[i].l);
        if(s >= p[i].k) p1[++c1] = p[i];
        else p[i].k -= s, p2[++c2] = p[i];
    }
    for(int i = 1;i <= c1;i++) p[L + i - 1] = p1[i];
    for(int i = 1;i <= c2;i++) p[R - c2 + i] = p2[i];
    Solve(l,m,L,L + c1 - 1), Solve(m + 1,r,L + c1,R);
    return;
}

int main() {
    n = read(), m = read(), q = read();
    for(int i = 2;i <= n;i++) {
        int v = read(), u = read();
        ins(v,u), ins(u,v);
    }
    Dfs1(1,1), Dfs2(1,1);
    int t = 0;
    for(int i = 1;i <= m;i++) {
        int v = read(), u = read(), k = b[i] = read();
        if(ln[v] > ln[u]) std::swap(v,u);
        if(rn[v] >= rn[u]) {
            v = GetSon(u,v);
            if(ln[v] > 1) {
                p[++t] = Item(0,ln[u],1,ln[v] - 1,k,1);
                p[++t] = Item(0,rn[u] + 1,1,ln[v] - 1,k,-1);
            }
            if(rn[v] < n) {
                p[++t] = Item(0,rn[v] + 1,ln[u],rn[u],k,1);
                p[++t] = Item(0,n + 1,ln[u],rn[u],k,-1);
            }
        } else {
            p[++t] = Item(0,ln[u],ln[v],rn[v],k,1);
            p[++t] = Item(0,rn[u] + 1,ln[v],rn[v],k,-1);
        }
    }
    std::sort(b + 1,b + 1 + m);
    int tmp = std::unique(b + 1,b + 1 + m) - b - 1;
    for(int i = 1;i <= t;i++) p[i].k = std::lower_bound(b + 1,b + 1 + tmp,p[i].k) - b;
    for(int i = 1;i <= q;i++) {
        int v = read(), u = read(), k = read();
        if(ln[v] > ln[u]) std::swap(v,u);
        p[++t] = Item(1,ln[u],ln[v],0,k,i);
    }
    std::sort(p + 1,p + 1 + t);
    // for(int i = 1;i <= t;i++) std::printf("i=%d tp=%d y=%d l=%d r=%d k=%d id=%d\n",i,p[i].tp,p[i].y,p[i].l,p[i].r,p[i].k,p[i].id);
    Solve(1,tmp,1,t);
    for(int i = 1;i <= q;i++) std::printf("%d\n",b[ans[i]]);
    return 0;
}

```

同样有不用整体二分的做法。扫描线的同时，权值线段树套动态开点线段树区间加，单点查即可。空间 $O(n\log^2 n)$ 时间 $O(n\log^2n)$。

---

## 作者：totorato (赞：8)

# 论如何使用K-D tree 卡过这道题

### 思路：
首先，我们会比较自然地想到将盘子和水果的关系抽象成整棵树的DFS序上的点对。
如果一条树上路径\[a,b\]是\[c,d\]的子路径，那么c和d一定会在与a,b有关的特定的区间内。

因此求多少已知路径包含给定路径将非常容易，因为这个问题可以转化为有多少点对(x,y)满足$x\in [l_1,r_1],y\in [l_2,r_2]$。这个问题可以由K-D树或者扫描线或者什么诡异的方法解决，如用k-d树，我们只需要实现区间加和单点修改。

接着我们在此基础上，考虑如何满足“第k大”这个限制。

如果我们二分每这个第k大值，该问题又可以转化为判定性问题：求有多少小于该值的满足条件的点对。

所以我们对每个水果，同时二分答案，按二分的第k大值排序。盘子也按权值排序。将水果和盘子按权值从小到达，把盘子插入到k-d树中，用水果询问。这样我们就知道每个水果路径包含了多少比他小的盘子路径，利用这个数量继续二分即可。

这是一种类似整体二分的方法，但相比整体二分，这种方法更像二分答案。

时间复杂度$O(n\sqrt{n}log{n})$

### 卡·常数 的诅咒
然而非常激动地想到这种做法，非常激动地码完，非常激动地过了样例，却只有20分，剩下全部TLE。开O2后还是只有70分。
找到本地数据测试后，发现有一些精心构造的数据需要5秒才能通过，于是理所当然地在洛谷上TLE了。

于是我开始优化代码

-	问题1：同时二分时有些的l,r区间已经重合，没有必要处理这些询问。
-	解决1：特判掉这些没用的询问-0.07s
-	问题2：二分的区间太大，没有必要二分0到1e9的所有数。
-	解决2：将所有可能作为答案的数离散化，二分这些数的编号-0.5s
-	问题3：gprof后发现各种运算符重载和min,max等比较耗时
-	解决3：运算符用const&重载，手写min,max-0.3s
-	问题4：读入也许比较耗时
-	解决4：读入优化-0.04s
-	问题5：最影响整体复杂度的是kd树的区间加
-	解决5：对kd树实行标记永久化，榨干区间加的常数-0.6s
-	问题6：二分答案时会多次询问同样的矩形，每次在kd树中递归非常浪费时间
-	解决6：预处理所有可能用到的矩形在kd树中用到了哪些节点，以及对这些节点实行了什么操作，真正区间加时直接访问这些节点-0.8s

至此，我将5s的代码优化成了2.7s，于是我就仰天长啸，拍案而起，但最终还是
觉得对得起浪费掉的这两个晚上的。

(由于各种原因，代码非常长)

```cpp
#pragma GCC optimize("Ofast")
#pragma GCC target("sse3","sse2","sse")
#pragma GCC target("avx","sse4","sse4.1","sse4.2","ssse3")
#pragma GCC target("f16c")
#pragma GCC optimize("inline","fast-math","unroll-loops","no-stack-protector")
#pragma GCC diagnostic error "-fwhole-program"
#pragma GCC diagnostic error "-fcse-skip-blocks"
#pragma GCC diagnostic error "-funsafe-loop-optimizations"
#pragma GCC diagnostic error "-std=c++14"
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <ctime>
#define MX 40004

int D;
int real[MX],rnum;
int gfake(int a)
{
	return std::lower_bound(real+1,real+rnum+1,a)-real;
}
void lsh()
{
	std::sort(real+1,real+rnum+1);
	rnum=std::unique(real+1,real+rnum+1)-real-1;
}
struct node
{
	int p[2],mn[2],mx[2],s[2],cnt,laz;
	bool operator < (const node& t)const{return p[D]!=t.p[D]?p[D]<t.p[D]:p[D^1]<t.p[D^1];}
}tseq[MX*2];
struct edge
{
	int u,v,w;
}e[MX*2],plt[MX],qur[MX];
struct bina
{
	int t,u,v,k,l,r,m,a,id;		//type; u; v; kth; l; r; mid; ans; id;
	bool operator < (const bina& tmp)const{return real[m]==real[tmp.m]?t<tmp.t:real[m]<real[tmp.m];}
}bin[MX*2];
int n,p,q;
int fst[MX],nxt[MX*2],lnum;
int dfn[MX],rak[MX],mst[MX][2],dcnt;
int out[MX],rout[MX][1000],rtyp[MX][1000],rsiz[MX];

int mmin(const int &a,const int &b){return a>b?b:a;}
int mmax(const int &a,const int &b){return a<b?b:a;}

struct KDT
{
	node tre[MX*2];
	int cnt,rot;
	void init(){for(int i=1;i<=cnt;++i)tre[i].cnt=tre[i].laz=0;}
	void upd(int a)
	{
		tre[a].mn[0]=tre[a].mx[0]=tre[a].p[0];
		if(tre[a].s[0])
		{
			tre[a].mn[0]=mmin(tre[a].mn[0],tre[tre[a].s[0]].mn[0]),
			tre[a].mx[0]=mmax(tre[a].mx[0],tre[tre[a].s[0]].mx[0]);
		}
		if(tre[a].s[1])
		{
			tre[a].mn[0]=mmin(tre[a].mn[0],tre[tre[a].s[1]].mn[0]),
			tre[a].mx[0]=mmax(tre[a].mx[0],tre[tre[a].s[1]].mx[0]);
		}
		tre[a].mn[1]=tre[a].mx[1]=tre[a].p[1];
		if(tre[a].s[0])
		{
			tre[a].mn[1]=mmin(tre[a].mn[1],tre[tre[a].s[0]].mn[1]),
			tre[a].mx[1]=mmax(tre[a].mx[1],tre[tre[a].s[0]].mx[1]);
		}
		if(tre[a].s[1])
		{
			tre[a].mn[1]=mmin(tre[a].mn[1],tre[tre[a].s[1]].mn[1]),
			tre[a].mx[1]=mmax(tre[a].mx[1],tre[tre[a].s[1]].mx[1]);
		}
	}
	void psd(int a)
	{
		if(!tre[a].laz)return;
		tre[tre[a].s[0]].cnt+=tre[a].laz,
		tre[tre[a].s[1]].cnt+=tre[a].laz,
		tre[tre[a].s[0]].laz+=tre[a].laz,
		tre[tre[a].s[1]].laz+=tre[a].laz,
		tre[a].laz=0;
	}
	bool itsct(const node& a,const node& b)
	{
		return (*a.mn<=*b.mx&&*b.mn<=*a.mx&&
				*(a.mn+1)<=*(b.mx+1)&&*(b.mn+1)<=*(a.mx+1));
	}
	void build(int &a,int l,int r,int d)
	{
		if(l>r)return;
		D=d;
		int mid=(l+r)>>1;
		std::nth_element(tseq+l,tseq+mid,tseq+r+1);
		tre[a=++cnt]=tseq[mid];
		build(tre[a].s[0],l,mid-1,d^1);
		build(tre[a].s[1],mid+1,r,d^1);
		upd(a);
	}
	void pre_add(int a,node &t,int tar)
	{
		++rsiz[tar];
		rout[tar][rsiz[tar]]=a;
		if(	*t.mn<=*tre[a].mn&&*tre[a].mx<=*t.mx&&
			*(t.mn+1)<=*(tre[a].mn+1)&&*(tre[a].mx+1)<=*(t.mx+1))
			{rtyp[tar][rsiz[tar]]|=1;return;}
		if(	*t.mn<=*tre[a].p&&*tre[a].p<=*t.mx&&
			*(t.mn+1)<=*(tre[a].p+1)&&*(tre[a].p+1)<=*(t.mx+1))
			{rtyp[tar][rsiz[tar]]|=2;}
		int ls=*tre[a].s,rs=*(tre[a].s+1);
		if(	ls&&itsct(*(tre+ls),t))pre_add(ls,t,tar);
		if(	rs&&itsct(*(tre+rs),t))pre_add(rs,t,tar);
	}
	void add(int id)
	{
		for(int i=1;i<=rsiz[id];++i)
		{
			if(rtyp[id][i]&1)++tre[rout[id][i]].laz;
			if(rtyp[id][i]&2)++tre[rout[id][i]].cnt;
		}
	}
	int query(int a,node &t,int d)
	{
		if(!a)return 0;
		D=d;
		if(t.p[0]==tre[a].p[0]&&t.p[1]==tre[a].p[1])return tre[a].cnt+tre[a].laz;
		else if(t<tre[a])return query(tre[a].s[0],t,d^1)+tre[a].laz;
		else return query(tre[a].s[1],t,d^1)+tre[a].laz;
	}
}ktr;

struct LCA
{
	int fa[17][MX],dep[MX];
	void init()
	{
		for(int i=1;i<=16;++i)
			for(int j=1;j<=n;++j)
				fa[i][j]=fa[i-1][fa[i-1][j]];
	}
	int lca(int a,int b)
	{
		if(dep[a]<dep[b])a^=b,b^=a,a^=b;
		for(int i=16;i>=0;--i)
			if(dep[fa[i][a]]>=dep[b])
				a=fa[i][a];
		if(a==b)return a;
		for(int i=16;i>=0;--i)
			if(fa[i][a]!=fa[i][b])
				a=fa[i][a],b=fa[i][b];
		return fa[0][a];
	}
	int son(int a,int b)
	{
		for(int i=16;i>=0;--i)
			if(dep[fa[i][b]]>dep[a])
				b=fa[i][b];
		return b;
	}
}lca;

void addeg(int nu,int nv)
{
	nxt[++lnum]=fst[nu];
	fst[nu]=lnum;
	e[lnum]=(edge){nu,nv};
}

int read()
{
	int x=0;char ch=getchar();
	while(!isdigit(ch))ch=getchar();
	while(isdigit(ch))x=x*10+ch-'0',ch=getchar();
	return x;
}

void input()
{
	int a,b;
	memset(fst,0xff,sizeof(fst)),lnum=-1;
	n=read(),p=read(),q=read();
	for(int i=1;i<n;++i)
	{
		a=read(),b=read();
		addeg(a,b);
		addeg(b,a);
	}
	for(int i=1;i<=p;++i)plt[i].u=read(),plt[i].v=read(),plt[i].w=read();
	for(int i=1;i<=q;++i)qur[i].u=read(),qur[i].v=read(),qur[i].w=read();
}

void dfs(int x,int f,int d)
{
	lca.fa[0][x]=f;
	lca.dep[x]=d;
	dfn[x]=++dcnt;
	rak[dcnt]=x;
	mst[x][0]=dcnt;
	for(int i=fst[x];i!=-1;i=nxt[i])
		if(e[i].v!=f)
			dfs(e[i].v,x,d+1);
	mst[x][1]=dcnt;
}

void work()
{
	node t;int tmp=0,f;
	dfs(1,0,1);
	lca.init();
	for(int i=1;i<=p;++i)real[++rnum]=plt[i].w;
	lsh();
	for(int i=1;i<=p;++i)
	{
		int u=plt[i].u,v=plt[i].v;
		if(dfn[u]>dfn[v])u^=v,v^=u,u^=v;
		bin[i]=(bina){0,u,v,0,0,0,gfake(plt[i].w),0,i};
	}
	for(int i=1;i<=q;++i)
	{
		int u=qur[i].u,v=qur[i].v;
		if(dfn[u]>dfn[v])u^=v,v^=u,u^=v;
		bin[p+i]=(bina){1,u,v,qur[i].w,1,rnum,(rnum+1)>>1,0,i};
	}
	for(int i=1;i<=p+q;++i)
		if(bin[i].t)
		{
			int du=dfn[bin[i].u],dv=dfn[bin[i].v];
			tseq[++tmp]=(node){du,dv,du,dv,du,dv,0,0,0,0};
		}
	ktr.build(ktr.rot,1,tmp,0);
	for(int j=1;j<=p+q;j++)
		if(!bin[j].t)
		{
			int u=bin[j].u,v=bin[j].v,g=lca.lca(u,v);
			if(g!=u&&g!=v)
			{
				t=(node){0,0,mst[u][0],mst[v][0],mst[u][1],mst[v][1],0,0,0,0};
				if(t.mn[0]<=t.mx[0]&&t.mn[1]<=t.mx[1])ktr.pre_add(ktr.rot,t,bin[j].id);
			}
			else
			{
				int x=lca.son(u,v);
				t=(node){0,0,1,mst[v][0],mst[x][0]-1,mst[v][1],0,0,0,0};
				if(t.mn[0]<=t.mx[0]&&t.mn[1]<=t.mx[1])ktr.pre_add(ktr.rot,t,bin[j].id);
				t=(node){0,0,mst[v][0],mst[x][1]+1,mst[v][1],n,0,0,0,0};
				if(t.mn[0]<=t.mx[0]&&t.mn[1]<=t.mx[1])ktr.pre_add(ktr.rot,t,bin[j].id);
			}
		}
	for(int i=1;i<=17;++i)
	{
		f=0;
		ktr.init();
		std::sort(bin+1,bin+p+q+1);
		for(int j=1;j<=p+q;++j)
		{
			if(!bin[j].t)
			{
				int u=bin[j].u,v=bin[j].v,g=lca.lca(u,v);
				if(g!=u&&g!=v)ktr.add(bin[j].id);
				else ktr.add(bin[j].id);
			}
			else if(bin[j].l<bin[j].r)
			{
				f=1;
				t=(node){dfn[bin[j].u],dfn[bin[j].v],0,0,0,0,0,0,0,0};
				bin[j].a=ktr.query(ktr.rot,t,0);
				if(bin[j].a>=bin[j].k)bin[j].r=bin[j].m;
				else bin[j].l=bin[j].m+1;
				bin[j].m=(bin[j].l+bin[j].r)>>1;
			}
		}
		if(!f)break;
	}
	for(int i=1;i<=p+q;++i)if(bin[i].t)out[bin[i].id]=bin[i].m;
	for(int i=1;i<=q;++i)printf("%d\n",real[out[i]]);
}

int main()
{

	input();
	work();
	return 0;
}
```

---

## 作者：Ynoi (赞：7)

这里是好写好想的bitset做法。

首先我们考虑对于一条路径,考虑它如果是一个路径的子路径，这个路径满足的性质。

先把盘子按照权值排序。

分两种情况。

第一种：

$v$是$u$的子节点，或$u$是$v$的子节点。

不妨设$u$是$v$的祖先。

这个的话就是路径一个点在$v$子树内，另一个点**不在**$u$向$v$方向的子节点子树内。

第二种：

所有不是第一种的情况。

就是一个点在$u$子树内，另一个点在$v$子树内。

我们首先假设水果路径是有向的。

现在对于一个水果$x->y$。

然后我们就可以在对于每个盘子，在一些节点标记一下，表示这个$x$需要在这个子树里才可能包含(当然对于第一种情况要标记不可能包含)这个盘子。

对于$y$也类似的方法处理。

然后我们$dfs$一遍，就可以求出每个节点作为水果的$x$($y$),是否每种盘子路径是否被包含，这个我们用$bitset$压一下位就行了。设$u$作为$x$的bitset为$c_u$,作为$y$的为$d_u$。

然后考虑转换为无向路径。

其实很简单，

对于水果$u,v$，只要$(c_u \text{ and }d_v) | (c_v \text{ and }d_u)$即可,就可以求出每个盘子是不是这个水果的子路径

不过这样常数就$3$倍了，希望看我题解的dalao可以想想有没有更好的方法

bitset求k小就不用说了吧=-=，扫一遍就行了

具体见代码，我bitset是手写的QAQ


```
#include<bits/stdc++.h>
using namespace std;

#define MAXN 40005
#define ui unsigned int
#define pb push_back 

const int len = MAXN/30;

int n,m,q;

struct bian {
	int x,y,ls;
}b[MAXN<<1];
int t[MAXN],cnt;

struct pan {
	int x,y,k;
}p[MAXN];

int ppc[1<<20];
struct bs {
	unsigned int a[MAXN/30+5];
}c[MAXN],d[MAXN]; 

vector<int>v[MAXN]; 

inline bs operator &(bs a,bs b) {
	bs c;
	for(int i = 0; i < len; i ++)
		c.a[i] = a.a[i]&b.a[i];
	return c;
}

inline bs operator |(bs a,bs b) {
	bs c;
	for(int i = 0; i < len; i ++)
		c.a[i] = a.a[i]|b.a[i];
	return c;
}

inline int kth(bs a,int k) {
	for(int i = 0; i < len; i ++)  {
		int t = ppc[a.a[i]>>16] + ppc[a.a[i]&65535];
		if(k <= t) {
			int p = a.a[i];
			for(int j = 0; j <= 31; j ++) {
				k -= (p&1);
				p >>= 1;
				if(k == 0) return j + (i<<5);
			}
		} else {
			k -= t;
		}
	}
}

void jb(int x,int y) {
	cnt ++;
	b[cnt].x = x;
	b[cnt].y = y;
	b[cnt].ls = t[x];
	t[x] = cnt;
}

bool cmp(pan a,pan b) {
	return a.k < b.k;
}

void rd()
{
	cin >> n >> m >> q;
	for(int i = 1; i < n; i ++) {
		int x,y;
		cin >> x >> y;
		jb(x,y);
		jb(y,x);
	}
	for(int i = 1; i <= m; i ++) {
		cin >> p[i].x >> p[i].y >> p[i].k;
	}
	sort(p+1,p+m+1,cmp);
}

int fa[MAXN],a[MAXN]; 
int f[MAXN][22],h[MAXN]; 

void dfs(int x) {
	h[x] = h[fa[x]] +1;
	cnt ++;
	a[x] = cnt;
	for(int i = t[x]; i != 0; i = b[i].ls) {
		int y = b[i].y;
		if(y != fa[x]) {
			fa[y] = x;
			dfs(y);
		}
	}
}

bs ww,fw;
void wxw(int x)
{
	for(int i = 0; i < v[x].size(); i ++) {
		int y = v[x][i];
		if(y > 0) {
			y --;
			ww.a[y>>5] ^= ((ui)1<<(y&31));
		} else {
			y = -y;
			y --; 
			fw.a[y>>5] ^= ((ui)1<<(y&31));
		}
	}
	
	c[x] = ww;
	d[x] = fw;
	for(int i = t[x]; i != 0; i = b[i].ls) {
		int y = b[i].y;
		if(y != fa[x]) {
			wxw(y);
		}
	}
	
	for(int i = 0; i < v[x].size(); i ++) {
		int y = v[x][i];
		if(y > 0) {
			y --;
			ww.a[y>>5] ^= ((ui)1<<(y&31));
		} else {
			y = -y;
			y --;
			fw.a[y>>5] ^= ((ui)1<<(y&31));
		}
	}
}

bs an;

void jianbiao()
{
	for(int i = 1; i <= n; i ++)
		f[i][0] = fa[i];
	for(int j = 1; j <= 20; j ++)
		for(int i = 1; i <= n; i ++)
			f[i][j] = f[f[i][j-1]][j-1];
}

int jump(int x,int y) {//k级祖先
	for(int i = 20; i >= 0; i --)
	if(y >= (1<<i))  {
		x = f[x][i];
		y -= (1<<i);
	}
	return x;	
}

signed main() {
	for(int i = 1; i < (1<<16); i ++)
		ppc[i] = ppc[i>>1] + (i&1);
	rd();
	cnt = 0;
	dfs(1);
	jianbiao();
	for(int i = 1; i <= m; i ++) {
		if(a[p[i].x] > a[p[i].y]) {
			swap(p[i].x,p[i].y); 
		} 
		int x = p[i].x,y = p[i].y;
		if(jump(y,h[y] - h[x]) == x) {
			v[1].pb(i);
			int t = jump(y,h[y]-h[x]-1);
			v[t].pb(i);
			v[y].pb(-i);		//i > 0表示作为x,否则作为y
		} else {
			v[p[i].x].pb(i);
			v[p[i].y].pb(-i);
		}
	}
	
	wxw(1);
	
	
	for(int i = 1; i <= q; i ++) {
		int x,y,k;
		cin >> x >> y >>  k;
		if(a[x] > a[y]) swap(x,y);
		an = (c[x]&d[y])|(d[x]&c[y]);
		int ans = kth(an,k);
		cout<<p[ans+1].k<<"\n";
	}
	return 0;
 } 
```

---

## 作者：Aleph1022 (赞：7)

此文同步发表于我的博客：https://www.alpha1022.me/articles/bzoj-4009.htm

按照套路，可以用 DFS 序把问题转化成询问覆盖一个点的所有矩形中的第 $k$ 小权值。  
这个别人都讲烂了。

然后，就可以用数据结构维护辣！  
但是为什么大家都写了整体二分……

我永远喜欢树套树！  
于是我选择了用树套树维护扫描线。  
但是这样子卡不过去。

我用了一些卡常的技巧：
- 读入优化。
- 权值离散化，单次操作从 $O(\log n \log c)$ 降到了 $O(\log n \log p)$。
- 发现我们不用每个矩形都存两个（旋转 $90^\circ$），而是保证所有坐标点 $(x,y)$ 都满足 $x \le y$，这样就只用存一个矩形。

于是这样子就能在某谷和 LibreOJ 上通过了。  
但是依然跑不过土豆。

代码：
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

const int BUFF_SIZE = 1 << 20;
char BUFF[BUFF_SIZE],*BB,*BE;
#define gc() (BB == BE ? (BE = (BB = BUFF) + fread(BUFF,1,BUFF_SIZE,stdin),BB == BE ? EOF : *BB++) : *BB++)
template<class T>
inline void read(T &x)
{
	x = 0;
	char ch = 0,w = 0;
	while(ch < '0' || ch > '9')
		w |= ch == '-',ch = gc();
	while(ch >= '0' && ch <= '9')
		x = (x << 3) + (x << 1) + (ch ^ '0'),ch = gc();
	w ? x = -x : x;
}

const int N = 4e4;
const int LG = 16;
const int C = 1e9;
int n,p,q;
int to[(N << 1) + 5],pre[(N << 1) + 5],first[N + 5];
inline void add(int u,int v)
{
	static int tot = 0;
	to[++tot] = v;
	pre[tot] = first[u];
	first[u] = tot;
}
int id[N + 5],sz[N + 5],dep[N + 5],f[N + 5][LG + 5];
void dfs(int p)
{
	static int tot = 0;
	sz[p] = 1,id[p] = ++tot;
	for(register int i = 1;i <= LG;++i)
		f[p][i] = f[f[p][i - 1]][i - 1];
	for(register int i = first[p];i;i = pre[i])
		if(to[i] ^ f[p][0])
			f[to[i]][0] = p,dep[to[i]] = dep[p] + 1,dfs(to[i]),sz[p] += sz[to[i]];
}
struct segnode
{
	int sum,tag;
	int ls,rs;
} seg[N * 930 + 10];
struct node
{
	int rt;
	int ls,rs;
} tree[N * 500 + 10];
int rt;
void update(int l,int r,int k,int &p,int tl,int tr)
{
	static int tot = 0;
	if(!p)
		p = ++tot;
	if(l <= tl && tr <= r)
	{
		seg[p].sum += k * (tr - tl + 1),seg[p].tag += k;
		return ;
	}
	int mid = tl + tr >> 1;
	if(l <= mid)
		update(l,r,k,seg[p].ls,tl,mid);
	if(r > mid)
		update(l,r,k,seg[p].rs,mid + 1,tr);
	seg[p].sum = seg[seg[p].ls].sum + seg[seg[p].rs].sum;
}
int query(int x,int p,int tl,int tr)
{
	if(!p || tl == tr)
		return seg[p].sum;
	int mid = tl + tr >> 1;
	if(x <= mid)
		return seg[p].tag + query(x,seg[p].ls,tl,mid);
	else
		return seg[p].tag + query(x,seg[p].rs,mid + 1,tr);
}
void insert(int l,int r,int x,int k,int &p,int tl,int tr)
{
	static int tot = 0;
	if(!p)
		p = ++tot;
	update(l,r,k,tree[p].rt,1,n);
	if(tl == tr)
		return ;
	int mid = tl + tr >> 1;
	if(x <= mid)
		insert(l,r,x,k,tree[p].ls,tl,mid);
	else
		insert(l,r,x,k,tree[p].rs,mid + 1,tr);
}
int query(int x,int k,int p,int tl,int tr)
{
	if(!p || tl == tr)
		return tl;
	int mid = tl + tr >> 1;
	int cnt = query(x,tree[tree[p].ls].rt,1,n);
	if(k <= cnt)
		return query(x,k,tree[p].ls,tl,mid);
	else
		return query(x,k - cnt,tree[p].rs,mid + 1,tr);
}
struct edge
{
	int x,y1,y2,w,k,id;
	inline bool operator<(const edge &o) const
	{
		return x < o.x || (x == o.x && k > o.k);
	}
} e[N * 9 + 10];
int tot;
int ans[N + 5];
int ind[N + 5],len;
int main()
{
	read(n),read(p),read(q);
	int u,v;
	for(register int i = 1;i < n;++i)
		read(u),read(v),add(u,v),add(v,u);
	dep[1] = 1,dfs(1);
	int a,b,c;
	for(register int i = 1;i <= p;++i)
	{
		read(a),read(b),read(c),ind[i] = c;
		if((id[a] <= id[b] && id[b] < id[a] + sz[a]) || (id[b] <= id[a] && id[a] < id[b] + sz[b]))
		{
			if(dep[a] > dep[b])
				swap(a,b);
			int t = b;
			for(register int j = LG;~j;--j)
				if(f[t][j] && dep[f[t][j]] > dep[a])
					t = f[t][j];
			if(id[t] > 1)
			{
				e[++tot] = (edge){1,id[b],id[b] + sz[b] - 1,c,1,0};
				e[++tot] = (edge){id[t] - 1,id[b],id[b] + sz[b] - 1,c,-1,0};
			}
			if(id[t] + sz[t] <= n)
			{
				e[++tot] = (edge){id[b],id[t] + sz[t],n,c,1,0};
				e[++tot] = (edge){id[b] + sz[b] - 1,id[t] + sz[t],n,c,-1,0};
			}
		}
		else
		{
			if(id[a] > id[b])
				swap(a,b);
			e[++tot] = (edge){id[a],id[b],id[b] + sz[b] - 1,c,1,0};
			e[++tot] = (edge){id[a] + sz[a] - 1,id[b],id[b] + sz[b] - 1,c,-1,0};
		}
	}
	sort(ind + 1,ind + p + 1);
	len = unique(ind + 1,ind + p + 1) - ind - 1;
	for(register int i = 1;i <= q;++i)
	{
		read(a),read(b),read(c);
		if(id[a] > id[b])
			swap(a,b);
		e[++tot] = (edge){id[a],id[b],0,c,0,i};
	}
	sort(e + 1,e + tot + 1);
	for(register int i = 1;i <= tot;++i)
	{
		if(!e[i].k)
			ans[e[i].id] = ind[query(e[i].y1,e[i].w,rt,1,len)];
		else
			insert(e[i].y1,e[i].y2,lower_bound(ind + 1,ind + len + 1,e[i].w) - ind,e[i].k,rt,1,len);
	}
	for(register int i = 1;i <= q;++i)
		printf("%d\n",ans[i]);
}
```


---

## 作者：liangs333 (赞：7)

## 提供一个整体二分+BIT的题解。
考虑整体二分。按照整体二分的套路，我们对于一个二分的mid，将所有值小于等于mid的盘子加入数据结构，再对于处在该次二分区间内的询问查询数据结构中被这个水果覆盖的盘子的个数是否大于K，再考虑将此次询问划分给左边或是右边。

考虑如何使用数据结构维护这样的链。我们首先对于整颗以1为根节点的树建立DFS序，并且记录每个节点在DFS序中的位置、该节点子树在DFS序中的结束位置（代码中为inn和ott）

假设一个盘子的左右端点分别为l,r，令LCA(l,r)=T,对于T和l，r的关系，分两种情况讨论。

情况1，T与l，r均不同。此时，若有一个水果的一个端点在$[inn[l],ott[l]]$，一个端点在$[inn[r],ott[r]]$
，则这个水果完全包含了这个盘子。

情况2，不妨设T为l，定义在l，r这条链上，且比l的深度大1的点为k。此时，若有一个水果的左端点在$[inn[r],ott[r]]$，右端点不在$[inn[k],ott[k]]$，则这个水果完全包含了这个盘子。

则该问题被转化成了一个二维数点问题，简单BIT+扫描线+整体二分即可，具体细节详见代码。

``` c++
#include<bits/stdc++.h>
using namespace std;
int n,p,q,ocnt;
int inn[40010],ott[40010],ord[40010],fa[40010],tp[40010][17],dep[40010];
int pw[20];
vector<int>ed[40010];
int num[40010],alis[40010];
int ncnt;
map<int,int>lis; 
char c;
inline void read(int &a) { 
	a=0,c=getchar();
	while(!isdigit(c)) c=getchar();
	while(isdigit(c)) a=a*10+c-'0',c=getchar();
} 
void lish() { 
	int nb=0;
	sort(num+1,num+ncnt+1);
	num[0]=-123123;
	for(int i=1;i<=ncnt;++i) { 
		if(num[i]!=num[i-1]) lis[num[i]]=++nb,alis[nb]=num[i];
	} 
} 
inline void ade(int l,int r) {ed[l].push_back(r),ed[r].push_back(l);} 
void dfs(int k,int fro) { 
	inn[k]=++ocnt,fa[k]=tp[k][0]=fro,dep[k]=dep[fro]+1,ord[ocnt]=k;
	for(int i=0;i<ed[k].size();++i) { 
		int tar=ed[k][i];
		tar==fro ? void() : dfs(tar,k);
	} ott[k]=ocnt;
} 
void b_init() { 
	pw[0]=1;for(int i=1;i<=16;++i) pw[i]=2*pw[i-1];
	for(int i=1;i<=16;++i) { for(int j=1;j<=n;++j) { 
			tp[j][i]=tp[tp[j][i-1]][i-1];
	} } 
} 
int lca(int l,int r) { 
	if(dep[l]>dep[r]) swap(l,r);
	if(dep[l]!=dep[r]) { for(int i=15;i>=0;--i) if(dep[tp[r][i]]>dep[l]) r=tp[r][i]; r=tp[r][0];} 
	if(l==r) return l;
	for(int i=16;i>=0;--i) if(tp[l][i]!=tp[r][i]) l=tp[l][i],r=tp[r][i];
	return tp[l][0];
} 
int go(int k,int len) { 
	for(int i=16;i>=0;--i) if(len-pw[i]>=0) k=tp[k][i],len-=pw[i];
	return k;
} 
namespace ds { 
	#define low(x) (x&(-x))
	int lim;
	int num[50010];
	inline void init() { 
		lim=n;
	} 
	inline void add(const int &l,const int &r,const int &val) { 
		for(register int i=l;i<=lim;i+=low(i)) num[i]+=val;
		for(register int i=r+1;i<=lim;i+=low(i)) num[i]-=val;
	} 
	inline int query(const int &k) { 
		register int ret=0;
		for(register int i=k;i>0;i-=low(i)) ret+=num[i];
		return ret;
	} 
} 
struct op { //0-> change   1->query
	int type,l,r,val,x,num;
	bool operator < (const op &a) const { 
		return x==a.x ? type < a.type : x < a.x;
	} 
};
op sth[210010],lef[210010],rig[210010];
int ans[40010];
int xl,xr,yl,yr,scnt,acnt;
void supdiv(int ql,int qr,int vl,int vr) { 
	int lcnt=0,rcnt=0,tcnt=0;
	if(ql>qr) return;
	if(vl==vr) { 
		for(int i=ql;i<=qr;++i) if(sth[i].type==1) ans[sth[i].num]=vl;
		return;
	} 
	int mid=vl+vr>>1;
	for(register int i=ql;i<=qr;++i) { 
		if(sth[i].type==1) { 
			int nv=ds::query(sth[i].l);
			if(sth[i].val<=nv) lef[++lcnt]=sth[i];
			else sth[i].val-=nv,rig[++rcnt]=sth[i];
		} 
		else { 
			if(sth[i].val<=mid) { 
				ds::add(sth[i].l,sth[i].r,sth[i].num),lef[++lcnt]=sth[i];
			} 
			else rig[++rcnt]=sth[i];
		} 
	} 
	for(int i=1;i<=lcnt;++i) sth[ql+(tcnt++)]=lef[i];
	for(int i=1;i<=rcnt;++i) sth[ql+(tcnt++)]=rig[i];
	supdiv(ql,ql+lcnt-1,vl,mid),supdiv(ql+lcnt,qr,mid+1,vr);
} 
int main() { 
	int l,r,val;
	read(n),read(p),read(q);
	for(int i=1;i<n;++i) read(l),read(r),ade(l,r);
	dfs(1,1),b_init();ds::init();
	for(register int i=1;i<=p;++i) { 
		read(l),read(r),read(val);int lc=lca(l,r);
		num[++ncnt]=val;
		if(lc!=l&&lc!=r) { 
			xl=inn[l],xr=ott[l],yl=inn[r],yr=ott[r];
			if(xl>yl) swap(xl,yl),swap(xr,yr);
			sth[++scnt]=(op){0,yl,yr,val,xl,1};
			sth[++scnt]=(op){0,yl,yr,val,xr+1,-1};
			if(xl>xr||yl>yr) scnt-=2,scnt=max(0,scnt);
		} 
		else { 
			if(dep[r]<dep[l]) swap(l,r);// L is higher.
			int nd=dep[r]-dep[l],ntar=go(r,nd-1);
			yl=inn[r],yr=ott[r],xl=1,xr=inn[ntar]-1;
			if(xl>yl) swap(xl,yl),swap(xr,yr);
			sth[++scnt]=(op){0,yl,yr,val,xl,1};
			sth[++scnt]=(op){0,yl,yr,val,xr+1,-1};
			if(xl>xr||yl>yr) scnt-=2,scnt=max(0,scnt);
			xl=inn[r],xr=ott[r],yl=ott[ntar]+1,yr=ott[1];
			if(xl>yl) swap(xl,yl),swap(xr,yr);
			sth[++scnt]=(op){0,yl,yr,val,xl,1};
			sth[++scnt]=(op){0,yl,yr,val,xr+1,-1};
			if(xl>xr||yl>yr) scnt-=2,scnt=max(0,scnt);
		} 
	} 
	for(register int i=1;i<=q;++i) { 
		read(l),read(r),read(val);
		int nx=inn[l],ny=inn[r];
		if(nx>ny) swap(nx,ny);
		sth[++scnt]=(op){1,ny,0,val,nx,++acnt};
	} sort(sth+1,sth+scnt+1);
	lish();
	for(register int i=1;i<=scnt;++i) if(sth[i].type==0) sth[i].val=lis[sth[i].val];
	supdiv(1,scnt,1,n);
	for(register int i=1;i<=acnt;++i) printf("%d\n",alis[ans[i]]);
	return 0;
} 
```


---

## 作者：埃罗芒阿老师· (赞：6)

思路{


BZOJ上这个题被卡评测了,结果改成了权限题。。。。。。。。只好到WG的OJ上写。。。。。。


首先不考虑路径的话是区间K大的问题，考虑使用整体二分。


统计在答案区间内的覆盖的盘子数量,


比较每次询问的K值大小判断丢入左答案区间还是右答案区间。


(大于K丢入右区间，小于K丢入左区间:ps:还要统计贡献！)。


这样就解决了答案查询问题。关键是怎么搞出所覆盖的盘子数呢？？？？？？


我们不妨分类讨论:


①一个盘子左右端点a,b其中一个为LCA时：


水果一端一定在深度较深的盘子端点的子树中,另一端在LCA外。


②a,b均不为LCA时：水果两端都在两端盘子的子树中。


具体用数量关系表示的话，我们考虑用DFS序。


设DFN[i]为i的dfs序，LAST[i]为以i为根的子树的DFS序的最大值.


对于①：水果两端u,v,满足:DFN[b]<=DFN[v]<=LAST[b],



　　(1<=DFN[u]<=DFN[w]-1)或(LAST[w]+1<=DFN[u]<=n)

对于②：水果两端u,v满足:DFN[a]<=DFN[u]<=LAST[a],DFN[b]<=DFN[v]<=LAST[b].


把这些盘子，水果分别抽象成一个个矩形，点：问题转化成求点被多少矩形覆盖！


然后就可以扫描线算法解决查询问题了！


}-

---

## 作者：grard4 (赞：4)

怎么大家都用的是整体二分？看来还是我太弱了/ll

这里提供一种扫描线+树套树的做法。常数比较大，但易于理解。

建议先完成[【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368) 、[【模板】扫描线 & 矩形面积并](https://www.luogu.com.cn/problem/P5490) 、[【模板】树套树](https://www.luogu.com.cn/problem/P3380) 后再看本篇题解。

## 正篇：

通过 $dfs$ 序来判断一条路径包含另一条路径的方法，可以去查看其它题解，这里直接给出结论。

包含 $u \rightarrow v$ 的路径 $x \rightarrow y$ 要满足以下条件（此处默认 $L_u < L_v$）：

$1$.如果 $lca(u,v)\ne u$，则点 $(L_x,L_y)$ 在矩形 $\{(L_u,L_v),(R_u,R_v)\}$ 中。

$2$.如果 $lca(u,v)=u$，则点 $(L_x,L_y)$ 在矩形 $\{(1,L_v),(L_z-1,R_v)\}\cup\{(L_v,R_z+1),(R_v,n)\}$ 中,其中 $z$ 是 $u \rightarrow v$ 路径上的第一个点。

问题就转化为了求包含某个点的所有矩形中权值第 $k$ 小的值。

这时候就可以扫描线扫描纵坐标，树套树外层维护横坐标，内层维护矩形的权值。

将每个矩形按照下边界从小到大排序，扫描到下边界时将对应的权值+1，扫描到上边界时将对应的权值-1，由于要做的只是区间修改和单点查询，所以外层可以直接用树状数组做差分。

将每个询问 $(L_x,L_y)$ 按照纵坐标排序，对于每一个询问处理完矩形以后即可在内层树套树上二分得出答案。

时间复杂度：$O(n \log^3 n)$,记得树套树的数组要开大些。

$code$：

```cpp
#include<bits/stdc++.h>
#define MAXN 40005
#define M (L+R>>1)
#define low(x) (x&(-x))
#define pb push_back
using namespace std;
int n,m,q,cnt,tot1,tot2,tot3,num,d[MAXN],wc[MAXN],st[MAXN],ed[MAXN];
int sz[MAXN],dep[MAXN],rt[MAXN],fa[MAXN],top[MAXN],tmp[MAXN],ans[MAXN];
vector<int> G[MAXN];
//st[i] 即为 L[i],ed[i] 即为 R[i]
struct qur{
    int u,v,k,id;
    friend bool operator<(const qur &x,const qur &y){
        return st[x.v]<st[y.v];
    }
}Q[MAXN];
struct xian{
    int l,r,h,v,w;
    friend bool operator<(const xian &x,const xian &y){
        return x.h<y.h;
    }
}p[MAXN<<2];
//树状数组套权值线段树部分
struct tree{
    int ls,rs,v;
}t[MAXN<<8];
void pushup(int o){
    t[o].v=t[t[o].ls].v+t[t[o].rs].v;
    return;
}
void change(int &o,int L,int R,int w,int v){
    if (!o) o=++tot3;
    if (L==R) {t[o].v+=v;return;}
    if (w<=M) change(t[o].ls,L,M,w,v);
    else change(t[o].rs,M+1,R,w,v);
    pushup(o);
}
void add(int o,int w,int v){
    for (int i=o;i<=n;i+=low(i))
      change(rt[i],1,tot1,w,v);
    return;
}
int query(int L,int R,int k){
    if (L==R) return L;int sum=0;
    for (int i=1;i<=num;i++) sum+=t[t[tmp[i]].ls].v;
    if (sum>=k){
        for (int i=1;i<=num;i++) tmp[i]=t[tmp[i]].ls;
        return query(L,M,k);
    }
    else{
        for (int i=1;i<=num;i++) tmp[i]=t[tmp[i]].rs;
        return query(M+1,R,k-sum);
    }
}
int qry(int x,int k){
    num=0;
    for (int i=x;i;i-=low(i)) tmp[++num]=rt[i];
    return query(1,tot1,k);
}
//这里通过树剖来求 LCA
void dfs1(int u,int f){
    fa[u]=f,sz[u]=1,dep[u]=dep[f]+1;
    for (auto v:G[u]){
        if (v==f) continue;
        dfs1(v,u);sz[u]+=sz[v];
        if (sz[v]>sz[wc[u]]) wc[u]=v;
    }
    return;
}
void dfs2(int u,int Top){
    top[u]=Top,st[u]=++cnt;
    if (wc[u]){
        dfs2(wc[u],Top);
        for (auto v:G[u]){
            if (v==fa[u]||v==wc[u]) continue;
            dfs2(v,v);
        }
    }
    ed[u]=cnt;
    return;
}
int lca(int x,int y){
    while(top[x]^top[y]){
        if (dep[top[x]]<dep[top[y]]) swap(x,y);
        x=fa[top[x]];
    }
    return dep[x]<dep[y] ? x:y;
}
int son(int x,int y){      //求 y->x 路径上的第一个点，注意 x 深度更深
    while(top[x]^top[y]){
        if (fa[top[x]]==y) return top[x];
        x=fa[top[x]];
    }
    return wc[y];
}
int main(){
    cin>>n>>m>>q;
    for (int i=1;i<n;i++){
    	int u,v;cin>>u>>v;
        G[u].pb(v),G[v].pb(u);
    }
    dfs1(1,0),dfs2(1,0);
    for (int i=1;i<=m;i++){
    	int a,b,c;
    	cin>>a>>b>>c;d[i]=c;
        if (st[a]>st[b]) swap(a,b);
        int z=lca(a,b);
        if (z!=a){
            p[++tot2]={st[a],ed[a],st[b],1,c};
            //如果 ed[b]=n 则不必添加矩形的上边界，下面同理
            if (ed[b]<n) p[++tot2]={st[a],ed[a],ed[b]+1,-1,c};
        }
        else{
            z=son(b,a);
            p[++tot2]={1,st[z]-1,st[b],1,c};
            if (ed[b]<n) p[++tot2]={1,st[z]-1,ed[b]+1,-1,c};
            if (ed[z]<n) p[++tot2]={st[b],ed[b],ed[z]+1,1,c};
        }
    }
    sort(p+1,p+tot2+1);            //将矩形的边从低到高排序
    sort(d+1,d+m+1),tot1=unique(d+1,d+m+1)-d-1;    //离散化每条路径的权值
    for (int i=1;i<=tot2;i++) p[i].w=lower_bound(d+1,d+tot1+1,p[i].w)-d;
    for (int i=1;i<=q;i++) cin>>Q[i].u>>Q[i].v>>Q[i].k,Q[i].id=i;
    sort(Q+1,Q+q+1);               //将询问的点按照纵坐标从小到大排序
    int rr=1;
    for (int i=1;i<=q;i++){
        while(rr<=tot2&&p[rr].h<=st[Q[i].v]){  //处理每个矩形
            add(p[rr].l,p[rr].w,p[rr].v);
            add(p[rr].r+1,p[rr].w,-p[rr].v);
            rr++;
        }
        ans[Q[i].id]=d[qry(st[Q[i].u],Q[i].k)];
    }
    for (int i=1;i<=q;i++) cout<<ans[i]<<endl;
    return 0;
}
```

---

## 作者：Jμdge (赞：4)

交了一发结果才第二页呢，果然人丑常数大...（顺便在打代码的时候发现自己出的一道题评测的时候被一位神仙 0 ms 过了，标算 1.470 S /kk）

正经讲题解：

首先我们考虑把原树树剖，然后记录树剖的 dfs 序（出入都要记），然后我们把每条路径映射到二维平面上的一个点

然后题目盘子要是苹果的子路径，我们可以把一个盘子能接住的苹果路径范围表示为二维平面上的一个矩形区间（或者两个），然后我们这时候只要查某个点的第 k 小覆盖覆盖矩形就好了，貌似是可以树套树的 QwQ

不过这里用了整体二分，我们以答案为二分的值，然后分层确定每个询问的答案位置就好了，分治的时候用到了扫描线思想以及常数较小（且好写）的树状数组维护

至于树状数组中询问内容是单点被覆盖了多少次，因为这时候我们就不用管什么 k 小不 k 小了，查询出来和询问的 k 比一下，大的减去覆盖次数丢右边，小的直接丢左边，然后继续向下二分就好了

本末倒置一下，现在讲怎么把盘子能接住的苹果路径范围表示出来：

我们发现如果盘子的路径两端点 x、y 为兄弟关系，那么能接住的苹果就要两端分别在 x 和 y 子树内，然后我们

然后盘子路径两端点 x、y 是父子关系，那么苹果两端一个在儿子子树内，另一个就是除去 y 对应上去的 x 子节点的子树以外的任意一个点，不如这么解释：

>假设路径为 x,a,b,c,d,.....,y ，那么 y 对应上去的 x 子节点就是 a ，然后另一个节点就不能在 a 这棵子树内

这个判断父子关系很好实现，用 dfs 序就好了，找到 a 这个节点有点困难，但实际上用树剖就能实现：

>首先做法是我们让 y 一直跳到 f[top[y]] ， 然后我们考虑节点间 top 的关系

>如果 a 是 x 的重儿子，那么我们在发现 top[y]==top[x] 的时候就确认了这个关系，那么直接返回 son[x] 就行了

>如果是轻儿子，那么我们已知跳直到 f[top[y]]=x ，返回 top[y] 即可


别的没了，常规操作（咱貌似做了好几天？【逃）


# Code

狠短的代码！
```
//by Judge
#define HGS_AK_IOI true
#include<bits/stdc++.h>
#define Rg register
#define fp(i,a,b) for(Rg int i=(a),I=(b)+1;i<I;++i)
#define fd(i,a,b) for(Rg int i=(a),I=(b)-1;i>I;--i)
#define go(u) for(Rg int i=head[u],v=e[i].to;i;v=e[i=e[i].nxt].to)
#define open(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
#define ll long long
using namespace std;
const int M=2e5+3;
typedef int arr[M];
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} char sr[1<<21],z[20];int CCF=-1,Z;
inline void Ot(){fwrite(sr,1,CCF+1,stdout),CCF=-1;}
inline void print(int x,char chr='\n'){
	if(CCF>1<<20)Ot();if(x<0)sr[++CCF]=45,x=-x;
	while(z[++Z]=x%10+48,x/=10);
	while(sr[++CCF]=z[Z],--Z);sr[++CCF]=chr;
}
int n,m,P,Q; arr h,ans;
struct Line{ int x,l,r,v,val; Line(){}
	Line(int _x,int _l,int _r,int _v,int V){x=_x,l=_l,r=_r,v=_v,val=V;}
	bool operator <(const Line& b)const{return x<b.x;}
}Li[M],*p[M],*tp[M];
struct Qry{ int x,y,k,id; Qry(){}
	Qry(int _x,int _y,int _k,int _id){x=_x,y=_y,k=_k,id=_id;}
	bool operator <(const Qry& b)const{return x^b.x?x<b.x:id>b.id;}
}Qr[M],*q[M],*tq[M];
namespace TC{ int tim; arr f,son,siz,dep,top,In,Out;
	int pat,head[M]; struct Edge{int to,nxt;}e[M<<1];
	inline void add(int u,int v){
		e[++pat]=(Edge){v,head[u]},head[u]=pat;
		e[++pat]=(Edge){u,head[v]},head[v]=pat;
	}
	void dfs(int u,int fa){ dep[u]=dep[fa]+1,siz[u]=1;
		go(u) if(v^fa){ f[v]=u,dfs(v,u),siz[u]+=siz[v];
			if(siz[v]>siz[son[u]]) son[u]=v;
		}
	}
	void dfs(int u){ In[u]=++tim; if(!top[u]) top[u]=u;
		if(son[u]) top[son[u]]=top[u],dfs(son[u]);
		go(u) if(v^f[u]&&v^son[u]) dfs(v); Out[u]=tim;
	}
	inline int Get(int u,int p){
		for(;top[u]^top[p];u=f[top[u]])
			if(f[top[u]]==p) return top[u];
		return top[u]==u?u:son[p];
	}
} using namespace TC;
namespace BIT{ arr c;
#define lowbit(x) (x&-x)
	inline void add(int x,int v){ while(x<=n) c[x]+=v,x+=lowbit(x); }
	inline int ask(int x){ Rg int s=0; while(x) s+=c[x],x^=lowbit(x); return s; }
	inline void upd(int l,int r,int v){ add(l,v),add(r+1,-v); }
}
void CDQ(int pl,int pr,int ql,int qr,int hl,int hr){
	if(pl>pr||ql>qr) return ; int mid=(hl+hr)>>1;
	if(hl==hr){ fp(i,ql,qr) ans[q[i]->id]=h[hl]; return ; }
	Rg int tpl=pl-1,tpr=pr+1,tql=ql-1,tqr=qr+1,j=pl,pp;
	fp(i,ql,qr){
		while(j <= pr && p[j]->x <= q[i]->x)
			if(p[j]->val > h[mid]) tp[--tpr]=p[j],++j;
			else BIT::upd(p[j]->l, p[j]->r, p[j]->v),tp[++tpl]=p[j],++j;
		(q[i]->k > (pp=BIT::ask(q[i]->y))) ? q[i]->k -= pp,tq[--tqr]=q[i] : tq[++tql]=q[i];
	}
	fp(i,pl,j-1) if(p[i]->val <= h[mid]) BIT::upd(p[i]->l, p[i]->r, -p[i]->v);
	while(j<=pr) ((p[j]->val > h[mid])?tp[--tpr]:tp[++tpl])=p[j],++j;
	fp(i,pl,tpl) p[i]=tp[i]; fp(i,tpr,pr) p[pr+tpr-i]=tp[i];
	fp(i,ql,tql) q[i]=tq[i]; fp(i,tqr,qr) q[qr+tqr-i]=tq[i];
	CDQ(pl,tpl,ql,tql,hl,mid),CDQ(tpr,pr,tqr,qr,mid+1,hr);
}
signed main(){
	n=read(),P=read(),Q=read(); int x,y,z;
	fp(i,2,n) x=read(),y=read(),add(x,y); dfs(1,0),dfs(1);
	fp(i,1,P){ x=read(),y=read(),h[i]=read(); if(In[x]>In[y]) swap(x,y);
		if(In[x]<=In[y]&&In[y]<=Out[x]){ z=Get(y,x);
			Li[++m]=Line(1,In[y],Out[y],1,h[i]),Li[++m]=Line(In[z],In[y],Out[y],-1,h[i]);
			if(Out[z]<n) Li[++m]=Line(In[y],Out[z]+1,n,1,h[i]),Li[++m]=Line(Out[y]+1,Out[z]+1,n,-1,h[i]);
		} else Li[++m]=Line(In[x],In[y],Out[y],1,h[i]),Li[++m]=Line(Out[x]+1,In[y],Out[y],-1,h[i]);
	}
	fp(i,1,Q){ x=read(),y=read(),z=read(); if(In[x]>In[y]) swap(x,y); Qr[i]=Qry(In[x],In[y],z,i); }
	sort(Li+1,Li+1+m); fp(i,1,m) p[i]=Li+i; sort(Qr+1,Qr+1+Q); fp(i,1,Q) q[i]=Qr+i;
	sort(h+1,h+1+P),*h=unique(h+1,h+1+P)-h-1,CDQ(1,m,1,Q,1,h[0]); fp(i,1,Q) print(ans[i]); return Ot(),0;
}
```


（被扇了两巴掌后）以后再也不压行了（反正就是香）

```
//by Judge
#define HGS_AK_IOI true
#include<bits/stdc++.h>
#define Rg register
#define fp(i,a,b) for(Rg int i=(a),I=(b)+1;i<I;++i)
#define fd(i,a,b) for(Rg int i=(a),I=(b)-1;i>I;--i)
#define go(u) for(Rg int i=head[u],v=e[i].to;i;v=e[i=e[i].nxt].to)
#define open(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
#define ll long long
using namespace std;
const int M=2e5+3;
typedef int arr[M];
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} char sr[1<<21],z[20];int CCF=-1,Z;
inline void Ot(){fwrite(sr,1,CCF+1,stdout),CCF=-1;}
inline void print(int x,char chr='\n'){
	if(CCF>1<<20)Ot();if(x<0)sr[++CCF]=45,x=-x;
	while(z[++Z]=x%10+48,x/=10);
	while(sr[++CCF]=z[Z],--Z);sr[++CCF]=chr;
}
int n,m,P,Q; arr h,ans;
struct Line{ int x,l,r,v,val; Line(){}
	Line(int _x,int _l,int _r,int _v,int V){x=_x,l=_l,r=_r,v=_v,val=V;}
	bool operator <(const Line& b)const{return x<b.x;}
}Li[M],*p[M],*tp[M];
struct Qry{ int x,y,k,id; Qry(){}
	Qry(int _x,int _y,int _k,int _id){x=_x,y=_y,k=_k,id=_id;}
	bool operator <(const Qry& b)const{return x^b.x?x<b.x:id>b.id;}
}Qr[M],*q[M],*tq[M];
namespace TC{ //模板怎能不压行 /kk 
	int tim; arr f,son,siz,dep,top,In,Out;
	int pat,head[M];
	struct Edge{int to,nxt;}e[M<<1];
	inline void add(int u,int v){
		e[++pat]=(Edge){v,head[u]},head[u]=pat;
		e[++pat]=(Edge){u,head[v]},head[v]=pat;
	}
	void dfs(int u,int fa){ dep[u]=dep[fa]+1,siz[u]=1;
		go(u) if(v^fa){ f[v]=u,dfs(v,u),siz[u]+=siz[v];
			if(siz[v]>siz[son[u]]) son[u]=v;
		}
	}
	void dfs(int u){ In[u]=++tim; if(!top[u]) top[u]=u;
		if(son[u]) top[son[u]]=top[u],dfs(son[u]);
		go(u) if(v^f[u]&&v^son[u]) dfs(v); Out[u]=tim;
	}
	inline int Get(int u,int p){
		for(;top[u]^top[p];u=f[top[u]])
			if(f[top[u]]==p) return top[u];
		return top[u]==u?u:son[p];
	}
} using namespace TC;
namespace BIT{ arr c;
#define lowbit(x) (x&-x)
	inline void add(int x,int v){ while(x<=n) c[x]+=v,x+=lowbit(x); }
	inline int ask(int x){ Rg int s=0; while(x) s+=c[x],x^=lowbit(x); return s; }
	inline void upd(int l,int r,int v){ add(l,v),add(r+1,-v); }
}
void CDQ(int pl,int pr,int ql,int qr,int hl,int hr){
	if(pl>pr||ql>qr) return ;
	if(hl==hr){
		fp(i,ql,qr) ans[q[i]->id]=h[hl];
		return ;
	}
	int mid=(hl+hr)>>1;
	Rg int tpl=pl-1,tpr=pr+1;
	Rg int tql=ql-1,tqr=qr+1;
	Rg int j=pl,pp;
	fp(i,ql,qr){
		while(j <= pr && p[j]->x <= q[i]->x){
			if(p[j]->val > h[mid])
				tp[--tpr]=p[j],++j;
			else{
				BIT::upd(p[j]->l, p[j]->r, p[j]->v),
				tp[++tpl]=p[j],++j;
			}
		}
		if(q[i]->k > (pp=BIT::ask(q[i]->y))) 
			q[i]->k -= pp,tq[--tqr]=q[i];
		else tq[++tql]=q[i];
	}
	fp(i,pl,j-1) if(p[i]->val <= h[mid])
		BIT::upd(p[i]->l, p[i]->r, -p[i]->v);
	while(j<=pr){
		if(p[j]->val > h[mid])
			tp[--tpr]=p[j],++j;
		else tp[++tpl]=p[j],++j;
	}
	fp(i,pl,tpl) p[i]=tp[i];
	fp(i,tpr,pr) p[pr+tpr-i]=tp[i];
	fp(i,ql,tql) q[i]=tq[i];
	fp(i,tqr,qr) q[qr+tqr-i]=tq[i];
	CDQ(pl,tpl,ql,tql,hl,mid);
	CDQ(tpr,pr,tqr,qr,mid+1,hr);
}
signed main(){
	n=read(),P=read(),Q=read();
	int x,y,z;
	fp(i,2,n) x=read(),y=read(),add(x,y);
	dfs(1,0),dfs(1);
	fp(i,1,P){
		x=read(),y=read(),h[i]=read();
		if(In[x]>In[y]) swap(x,y);
		if(In[x]<=In[y]&&In[y]<=Out[x]){
			z=Get(y,x);
			Li[++m]=Line(1,In[y],Out[y],1,h[i]);
			Li[++m]=Line(In[z],In[y],Out[y],-1,h[i]);
			if(Out[z]<n){
				Li[++m]=Line(In[y],Out[z]+1,n,1,h[i]);
				Li[++m]=Line(Out[y]+1,Out[z]+1,n,-1,h[i]);
			}
		} else{
			Li[++m]=Line(In[x],In[y],Out[y],1,h[i]);
			Li[++m]=Line(Out[x]+1,In[y],Out[y],-1,h[i]);
		}
	}
	fp(i,1,Q){
		x=read(),y=read(),z=read();
		if(In[x]>In[y]) swap(x,y);
		Qr[i]=Qry(In[x],In[y],z,i);
	}
	sort(Li+1,Li+1+m);
	fp(i,1,m) p[i]=Li+i;
	sort(Qr+1,Qr+1+Q);
	fp(i,1,Q) q[i]=Qr+i;
	sort(h+1,h+1+P);
	*h=unique(h+1,h+1+P)-h-1;
	CDQ(1,m,1,Q,1,h[0]);
	fp(i,1,Q) print(ans[i]);
	return Ot(),0;
}
```


# 效果展示

压行前：

![](https://cdn.luogu.com.cn/upload/image_hosting/tcvwc71j.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

压行后：

![](https://cdn.luogu.com.cn/upload/image_hosting/yolfs0qy.png?x-oss-process=image/resize,m_lfit,h_170,w_225)




---

## 作者：_ctz (赞：4)

[安利$\mathbb{blog}$](https://ctz45562.github.io/2019/09/25/%E6%B4%9B%E8%B0%B7-P3242-HNOI2015-%E6%8E%A5%E6%B0%B4%E6%9E%9C/)

[传送门](https://www.luogu.org/problem/P3242)

> 不要...不要误会，我不是针对莫队，我是说在座的莫队都假了。

~~（虽然我也写的假莫队）~~

给你一棵树和若干条带权模式链，多次询问，给出一条链，求所有为其子链的模式链中，权值第$k$小是多少。

用树上莫队+分块解决。

关键在于怎么判断某条模式链是否为当前区间代表的链的子链。

首先能想到每个点开一个`vector`，把每个模式链插进两端点的`vector`中。移动指针时，扫一遍`vector`，如果一条链的另一个端点也位于当前链，就把它加进块里/从块里删除。

但这个做法复杂度对吗？

用`vector`存信息时，必须保证**每个`vector`被遍历的次数是均等的**，才能把复杂度均摊掉。

显然莫队不能保证每个位置被扫过的次数是均等的。通俗来讲，**莫队的指针移动次数是$O(n\sqrt{m})$的，但每个位置被扫过的次数不是$O(\sqrt{m})$的**。

这样卡掉这个做法就很容易了，将模式链全部插入第一个块里，询问左端点也全放到第一个块里，构造右端点，使排序后的询问左端点会呈这种方式移动：

![](https://ctz45562.github.io/images/接水果-1.png)

复杂度就是$O(nm)$的。只不过数据水没卡。

解决方案：把每个位置按`vector`的元素拆成若干个新点，重新制定询问区间。在新序列和新询问区间上跑莫队。

然而这样写很麻烦，细节很繁琐，~~所以我还是写的假莫队~~

代码：

``` cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <vector>

#define maxn 80005
#define inf 0x3f3f3f3f

using namespace std;

inline int read(){
	int x=0,y=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return y?-x:x;
}
int son[maxn],siz[maxn],seg[maxn],deep[maxn],fa[maxn],top[maxn],dis[maxn],ans[maxn],len;
int fir[maxn],en[maxn],be[maxn],pos[maxn],h[maxn],bel[maxn],bc[maxn],c[maxn],num,cnt,all;
vector<pair<int,int> >p[maxn];
vector<pair<int,int> >::iterator iter;
bool vis[maxn];
struct edge{
	int pre,to;
}e[maxn];
struct Query{
	int l,r,num,lc,k;
	bool operator < (const Query &x)const{
		if(be[l]!=be[x.l])return be[l]<be[x.l];
		if(be[l]&1)return r<x.r;
		return r>x.r;
	}
}q[maxn>>1];
inline void adde(int from,int to){
	e[++num]=(edge){h[from],to};
	h[from]=num;
}
void dfs1(int node=1){
	pos[fir[node]=++cnt]=node;
	siz[node]=1;
	for(register int i=h[node],x;i;i=e[i].pre){
		x=e[i].to;
		if(siz[x])continue;
		deep[x]=deep[node]+1,fa[x]=node;
		dfs1(x),siz[node]+=siz[x];
		if(siz[x]>siz[son[node]])son[node]=x;
	}
	pos[en[node]=++cnt]=node;
}
void dfs2(int node=1){
	seg[node]=++all;
	if(!son[node])return;
	int x;
	top[son[node]]=top[node],dfs2(son[node]);
	for(register int i=h[node],x;i;i=e[i].pre){
		x=e[i].to;
		if(!seg[x])top[x]=x,dfs2(x);
	}
}
int lca(int x,int y){
	while(top[x]!=top[y])deep[top[x]]<deep[top[y]]?y=fa[top[y]]:x=fa[top[x]];
	return deep[x]<deep[y]?x:y;
}
void process(int x,int y,int k,int i){
	int l=lca(x,y);
	if(l!=x&&l!=y){
		if(en[x]>fir[y])swap(x,y);
		q[i]=(Query){en[x],fir[y],i,l,k};
	}
	else {
		if(l==y)swap(x,y);
		q[i]=(Query){fir[x],fir[y],i,0,k};
	}
}
inline void add(int x){++c[x],++bc[bel[x]];}
inline void del(int x){--c[x],--bc[bel[x]];}
inline void modify(int x){
	vis[x]^=1;
	if(!vis[x]){
		for(iter=p[x].begin();iter!=p[x].end();++iter)
			if(vis[iter->first])del(iter->second);
	}
	else {
		for(iter=p[x].begin();iter!=p[x].end();++iter)
			if(vis[iter->first])add(iter->second);
	}
}
int main(){
	int n=read(),m=read(),t=read(),sq,L,ssq,x,y,z;
	for(register int i=1;i<n;++i)x=read(),y=read(),adde(x,y),adde(y,x);
	dfs1(),dfs2();
	sq=cnt/sqrt(t),L=cnt/sq+bool(cnt%sq);
	for(register int i=1;i<=L;++i)
		for(register int j=sq*(i-1)+1,r=min(cnt,j+sq-1);j<=r;++j)
			be[j]=i;
	while(m--){
		x=read(),y=read(),dis[++len]=z=read();
		p[x].push_back(make_pair(y,z)),p[y].push_back(make_pair(x,z));
	}
	sort(dis+1,dis+1+len);
	len=unique(dis+1,dis+1+len)-dis-1;
	ssq=sqrt(len),L=len/ssq+bool(len%ssq);
	for(register int i=1;i<=L;++i)
		for(register int j=ssq*(i-1)+1,r=min(len,j+ssq-1);j<=r;++j)
			bel[j]=i;
	for(register int i=1;i<=n;++i)
		for(iter=p[i].begin();iter!=p[i].end();++iter)
			iter->second=lower_bound(dis+1,dis+1+len,iter->second)-dis;
	for(register int i=1;i<=t;++i){
		x=read(),y=read(),z=read();
		process(x,y,z,i);
	}
	sort(q+1,q+1+t);
	int l=1,r=1,j;
	modify(pos[1]);
	for(register int i=1;i<=t;++i){
		while(l<q[i].l)modify(pos[l++]);
		while(l>q[i].l)modify(pos[--l]);
		while(r<q[i].r)modify(pos[++r]);
		while(r>q[i].r)modify(pos[r--]);
		if(q[i].lc)modify(q[i].lc);
		for(j=1;j<=L&&q[i].k>bc[j];++j)q[i].k-=bc[j];
		for(j=(j-1)*ssq+1,x=min(n,j+ssq-1);j<=x&&q[i].k>c[j];++j)q[i].k-=c[j];
		if(q[i].lc)modify(q[i].lc);
		ans[q[i].num]=dis[j];
	}
	for(register int i=1;i<=t;++i)printf("%d\n",ans[i]);
}
```



---

## 作者：劉子颺 (赞：3)

这里给一个无脑毒瘤的题解

整体二分+树套树

明显树套树套树是可以A的

但是Splay空间开不好

考虑整体二分后用树套树维护矩形

然后动态开点清空是O1的

注意点 严格定义SL和EL的大小关系

```
struct Node{
    int Sl,Sr,El,Er,K;
}A[N<<2];
int acnt=0;
struct Query{
    int Sl,Sr,El,Er,K,opt;
}Que[N*10],tmp1[N*10],tmp2[N*10];
int qcnt=0;
//
int ans[N];
//Out
int Rt;
int root[N<<2];//inner root;
int L[N<<2];
int R[N<<2];
int Ftot=0;
//In
int lson[N*80];
int rson[N*80];
int sum[N*80];
int lazy[N*80];
int Stot=0;
//
int SNew(){
    ++Stot;
    lson[Stot]=rson[Stot]=sum[Stot]=lazy[Stot]=0;
    return Stot;
}
void PushUp(int x){
    sum[x]=0;
    if(lson[x])sum[x]+=sum[lson[x]];
    if(rson[x])sum[x]+=sum[rson[x]];
}
void PushNow(int x,int v){
    sum[x]+=v;
    lazy[x]+=v;
}
void PushDown(int x){
    if(!lazy[x])return;
    if(!lson[x])lson[x]=SNew();
    if(!rson[x])rson[x]=SNew();
    if(lazy[x]){
        PushNow(lson[x],lazy[x]);
        PushNow(rson[x],lazy[x]);
        lazy[x]=0;
    }
}
void Modify(int &x,int l,int r,int dl,int dr,int v){
    if(!x)x=SNew();
    if(dl<=l&&r<=dr){
        PushNow(x,v);
        return;
    }
    PushDown(x);
    int mid=(l+r)>>1;
    if(dl<=mid)Modify(lson[x],l,mid,dl,dr,v);
    if(mid< dr)Modify(rson[x],mid+1,r,dl,dr,v);
    PushUp(x);
}
int QueryIn(int x,int l,int r,int dpos){
    if(!x)return 0;
    if(l==r){
        return sum[x];
    }
    PushDown(x);
    int mid=(l+r)>>1;
    int ret=0;
    if(dpos<=mid)ret=ret+QueryIn(lson[x],l,mid,dpos);
    else ret=ret+QueryIn(rson[x],mid+1,r,dpos);
    return ret;
}
//
int FNew(){
    ++Ftot;
    L[Ftot]=R[Ftot]=root[Ftot]=0;
    return Ftot;
}
void Update(int &x,int l,int r,int dl,int dr,int ql,int qr,int v){
    if(!x)x=FNew();
    if(dl<=l&&r<=dr){
        Modify(root[x],1,n,ql,qr,v);
        return;
    }
    int mid=(l+r)>>1;
    if(dl<=mid)Update(L[x],l,mid,dl,dr,ql,qr,v);
    if(mid< dr)Update(R[x],mid+1,r,dl,dr,ql,qr,v);
}
int QueryOut(int x,int l,int r,int dpos,int qpos){
    if(!x)return 0;
    if(l==r){
        return QueryIn(root[x],1,n,qpos);
    }	
    int mid=(l+r)>>1;
    int ret=QueryIn(root[x],1,n,qpos);
    if(dpos<=mid)ret=ret+QueryOut(L[x],l,mid,dpos,qpos);
    else ret=ret+QueryOut(R[x],mid+1,r,dpos,qpos);
    return ret;
}
//
int mmp[N];
void CDQ(int dl,int dr,int l,int r){
    if(dl>dr)return;
    if(l==r){
        for(int i=dl;i<=dr;++i){
            if(Que[i].opt)ans[Que[i].opt]=l;
        }
        return;
    }
    int mid=(l+r)>>1;
    int tot1=0,tot2=0;
    for(int i=dl;i<=dr;++i){
        if(!Que[i].opt){
            if(Que[i].K<=mid){
                Update(Rt,1,n,Que[i].Sl,Que[i].Sr,Que[i].El,Que[i].Er,1);	
                tmp1[++tot1]=Que[i];
            }
            else tmp2[++tot2]=Que[i];
        }
        else{
            int sum=QueryOut(Rt,1,n,Que[i].Sl,Que[i].Sr);
            if(sum>=Que[i].K){
                tmp1[++tot1]=Que[i];
            }
            else{
                tmp2[++tot2]=Que[i];
                tmp2[tot2].K-=sum;
            }
        }
    }
    Rt=Ftot=Stot=0;
    for(int i=1;i<=tot1;++i)Que[dl+i-1]=tmp1[i];
    for(int i=1;i<=tot2;++i)Que[dl+tot1+i-1]=tmp2[i];
    //DeBug
    #define Clr(A) memset(A,0,sizeof(A));
//	Clr(lson);Clr(rson);
//	Clr(sum);
//	Clr(L);Clr(R);Clr(lazy);Clr(root);
    #undef Clr
    //
    CDQ(dl,dl+tot1-1,l,mid);
    CDQ(dl+tot1,dr,mid+1,r);
}
```


---

## 作者：Genius_Z (赞：2)

[$\Large \color{blue}Blog$](http://geiz-revive.github.io/)

树上莫队 + 值域分块，复杂度$\Theta(n\sqrt n+nlogn)$

我们把一个盘子看做是两个点，然后当在莫队同时加入这个两个点时，我们就相应的把这个盘子加入值域分块中，删除同理。用一个$vector$维护每个点上带着的盘子。

值域分块的$trick$和[这个题](https://www.luogu.org/problemnew/show/P2617)一样，查询$\sqrt n$，加入删除都是$\Theta(1)$的，和莫队的复杂度摊掉了，然后看到$1e9$的值域很显然是要离散化，然后这题差不多就做完了。

本蒟蒻做的时候$LCA$写错调了好久，希望各位不要犯这种睿智错误，$LCA$用的是$\Theta(nlogn)/\Theta(1)$$LCA$

$\Large Code:$

```cpp
#pragma region revive
#include <set>
#include <map>
#include <cmath>
#include <queue>
#include <stack>
#include <bitset>
#include <cstdio>
#include <vector>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <iostream>
#include <algorithm>
#include <unordered_map>
#define inl inline
#define re register int
#define fa(x) t[x].fa
#define son(x, y) t[x].child[y]
#define ls(x) t[x].child[0]
#define rs(x) t[x].child[1]
#define ll long long
const int inf = 0x3f3f3f3f;
#define lowbit(x) ((x) & (-x))
using namespace std;
#ifndef _DEBUG
#define getchar() (*(IOB.in.p++))
#define putchar(c) (*(IOB.out.p++) = (c))
#define io_eof() (IOB.in.p >= IOB.in.pend)
struct IOBUF {
	struct {
		char buff[1 << 26], *p, *pend;
	} in;
	struct {
		char buff[1 << 26], *p;
	} out;
	IOBUF() {
		in.p = in.buff;
		out.p = out.buff;
		in.pend = in.buff + fread(in.buff, 1, 1 << 26, stdin);
	}
	~IOBUF() { fwrite(out.buff, 1, out.p - out.buff, stdout); }
} IOB;
#endif
template <typename IO>
inl void write(IO x) {
	if (x == 0) return (void)putchar('0');
	if (x < 0) putchar('-'), x = -x;
	static char buf[30];
	char *p = buf;
	while (x) {
		*(p++) = x % 10 + '0';
		x /= 10;
	}
	while (p > buf)
		putchar(*(--p));
}
inl void writestr(const char *s) {
	while (*s != 0)
		putchar(*(s++));
}
template <typename IO>
inl void writeln(IO x) { write(x), putchar('\n'); }
template <typename IO>
inl void writesp(IO x) { write(x), putchar(' '); }
inl int readstr(char *s) {
	char *begin = s, c = getchar();
	while (c < 33 || c > 127) {
		c = getchar();
	}
	while (c >= 33 && c <= 127) {
		*(s++) = c;
		c = getchar();
	}
	*s = 0;
	return s - begin;
}
template <typename IO>
inl IO read() {
	IO x = 0;
	register bool w = 0;
	register char c = getchar();
	while (c > '9' || c < '0') {
		if (c == '-') w = 1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + (c ^ 48);
		c = getchar();
	}
	return w ? -x : x;
}
#pragma endregion
int f[100001][20], dep[50001], st[50001], ed[50001], o[100001], euler[100001], head[50001], mp[100001], lg[100001], len, tot, num, a[100001], b[100001], t[100001];
vector<int> ve[40001];
struct edge {
	int next, to;
} e[100001];
inl void adde(int x, int y) {
	e[++tot] = edge{ head[x], y }, head[x] = tot;
	e[++tot] = edge{ head[y], x }, head[y] = tot;
}
inl void dfs(int x, int fa) {
	euler[++euler[0]] = x, o[++len] = x, st[x] = euler[0], mp[x] = len, dep[x] = dep[fa] + 1;
	for (re i = head[x]; i; i = e[i].next) {
		if (e[i].to != fa) {
			dfs(e[i].to, x);
			o[++len] = x;
		}
	}
	euler[++euler[0]] = x, ed[x] = euler[0];
}
inl int lca(int l, int r) {
	l = mp[l], r = mp[r];
	re x = min(l, r), y = max(l, r), k = lg[y - x + 1];
	l = x, r = y;
	return dep[f[l][k]] < dep[f[r - (1 << k) + 1][k]] ? f[l][k] : f[r - (1 << k) + 1][k];
}
int s[100001], sum[1001], sz[1001], cnt[100001], buc[100001], ans[100001];
inl void init() {
	dfs(1, 0);
	for (re i = 2; i <= len; i++)lg[i] = lg[i >> 1] + 1;
	for (re i = 1; i <= len; i++)f[i][0] = o[i];
	for (re j = 1; j <= lg[len]; j++) {
		for (re i = 1; i + (1 << j) - 1 <= len; i++) {
			f[i][j] = dep[f[i][j - 1]] < dep[f[i + (1 << (j - 1))][j - 1]] ? f[i][j - 1] : f[i + (1 << (j - 1))][j - 1];
		}
	}
	num = sqrt(euler[0]);
	for (re i = 1; i <= euler[0]; i++)s[i] = (i - 1) / num + 1, sz[s[i]]++;
}
bool vis[100001];
struct quiz {
	int l, r, k, lca, id;
	bool operator<(const quiz &a) {
		return s[l] == s[a.l] ? s[l] & 1 ? r < a.r : r > a.r : s[l] < s[a.l];
	}
} q[100001];
inl void add(int x) {
	for (auto i : ve[x])((++buc[i]) == 2) ? (cnt[a[i]]++, sum[s[a[i]]]++) : 0;
}
inl void del(int x) {
	for (auto i : ve[x])(buc[i] == 2) ? (cnt[a[i]]--, buc[i]--, sum[s[a[i]]]--) : (buc[i]--);
}
inl void oper(int x) {
	(vis[x] ^= 1) ? add(x) : del(x);
}
signed main() {
	re n = read<int>(), p = read<int>(), m = read<int>(), x, y, w, f;
	for (re i = 1; i < n; i++) x = read<int>(), y = read<int>(), adde(x, y);
	init();
	for (re i = 1; i <= p; i++) {
		x = read<int>(), y = read<int>(), w = read<int>();
		ve[x].push_back(i), ve[y].push_back(i), a[i] = b[i] = w;
	}
	sort(b + 1, b + 1 + p);
	re siz = unique(b + 1, b + 1 + p) - b - 1;
	for (re i = 1; i <= p; i++) {
		re k = a[i];
		t[a[i] = lower_bound(b + 1, b + 1 + siz, a[i]) - b] = k;
	}
	for (re i = 1; i <= m; i++) {
		x = read<int>(), y = read<int>(), w = read<int>();
		if (st[x] > st[y]) swap(x, y);
		f = lca(x, y);
		if (x != f) q[i] = quiz{ ed[x], st[y], w, f, i };
		else q[i] = quiz{ st[x], st[y], w, 0, i };
	}
	sort(q + 1, q + 1 + m);
	re l = 1, r = 0, res = 0;
	for (re i = 1; i <= m; i++) {
		while (l < q[i].l)oper(euler[l++]);
		while (l > q[i].l)oper(euler[--l]);
		while (r < q[i].r)oper(euler[++r]);
		while (r > q[i].r)oper(euler[r--]);
		if (q[i].lca) oper(q[i].lca);
		res = 0;
		for (re j = 1; j <= s[siz]; j++) {
			if (res + sum[j] < q[i].k)res += sum[j];
			else {
				for (re l = (j - 1) * num + 1, r = l + sz[j] - 1; l <= r; l++) {
					if ((res += cnt[l]) >= q[i].k) {
						ans[q[i].id] = t[l];
						goto begin;
					}
				}
			}
		}
	begin:
		if (q[i].lca)oper(q[i].lca);
	}
	for (re i = 1; i <= m; i++)writeln(ans[i]);
}
```



---

## 作者：Shunpower (赞：0)

[可能更好的阅读体验](https://www.cnblogs.com/lemonniforever/p/18077195)

好吧好吧，自己做出来的第一道整体二分。

省流：理解能力比较强的话直接拖到最后看算法流程吧。

**下面我们称输入时盘子的权值为“盘子的大小”，与文中使用的算法给盘子的赋权区分开。**

------------

一堆询问第 $k_i$ 小，考虑整体二分。

先考虑外部过程。

上整体二分板子，每次二分 $mid$，形象地把盘子集合掰成两半，左集合里的盘子满足大小都 $\leq mid$，右集合就是剩下一半。

接下来只考虑左集合的盘子，计算出对于水果集合中第 $i$ 个水果包含了多少个左集合中的盘子，记为 $c_i$。把 $c_i\leq k_i$ 的那一部分水果随着左集合向左侧二分 $[l,mid]$，剩下的水果 $k_i\gets k_i-c_i$ 排除掉左集合贡献之后，再随着右集合向右侧二分 $[mid+1,r]$ 即可。

当 $l=r$ 时，直接给水果集合里的水果答案就行。

真正麻烦的其实是怎么能快速算出来每个水果包含了多少个左集合中的盘子。

考虑找出一条路径 $u'\leftrightarrow v'$ 是母路径 $u\leftrightarrow v$ 的子路径的充要条件，可以发现当且仅当 $u'$ 和 $v'$ 都在 $u\leftrightarrow v$ 上，$u'\leftrightarrow v'$ 才构成 $u\leftrightarrow v$ 的子路径。那么想数出子路径数量，就是想数有多少条路径两个端点都同时在母路径上。这种两个同时存在做贡献只存在一个或者不存在都不做贡献的形式，容易想到做异或哈希。

然而你发现这很难异或哈希，因为异或哈希不能维护满足条件的路径数量，但是这启发我们使用异或并尝试使得位与位间不冲突以维护子路径数量。

我们不妨给所有盘子一个互不相同的编号 $i$，权值设置为 $2^i$ 并把权值挂在两个端点上，这样我们可以查询水果 $u\leftrightarrow v$ 这一路上的权值异或和，而它的 popcount 就是水果 $u\leftrightarrow v$ 里有多少个盘子的恰好一个端点。再做一次补集转化，用 $u\leftrightarrow v$ 里盘子端点的总数减掉这个 popcount 再除以 $2$，就是水果 $u\leftrightarrow v$ 里两个端点同时都在的盘子数量。

为了降低时间复杂度，编号可以直接依次给成 $0\sim p-1$，然后开 $n$ 个大小为 $p$ 的 bitset，这样每次对权值的操作（异或或者查 popcount，以及实现过程中需要做的清空等）就都是 $\mathcal O(1)$ 或者 $\mathcal O(\frac{p}{w})$ 的了。

现在问题转化成，每次只有左集合的那一部分盘子是有效的，怎么求一条路径上的异或和。为了保证复杂度，我们不能每一次都扫一遍整棵树，但是我们发现只有左集合盘子的端点的权值是有用的，这启发我们每一次都把左集合盘子的端点当做关键点建立虚树，建立虚树的复杂度和虚树上的节点数量都是左集合大小级别的，复杂度没有问题。

为了让虚树总是树从而方便操作，可以把根节点当做权值为 $0$ 的关键点也加进虚树，无伤大雅。

建立虚树之后事情就简单多了，对虚树垒一波树上异或前缀和，然后把查询的水果 $u\leftrightarrow v$ 路径的端点 $u,v$ **等价地**挪移到虚树节点上，然后直接类似树上差分，把四个 bitset 异或在一起就是水果 $u\leftrightarrow v$ 路径在只有左集合盘子的情况下的权值异或和。

这里挪移端点是因为水果 $u\leftrightarrow v$ 的端点 $u,v$ 并不一定都在虚树上，但是我们只有虚树上的点是有信息的，所以我们要收缩这条路径为它的一个子路径，这条子路径需要满足两端都是虚树节点，且没有损失任何信息（在收缩过程中没有丢掉任何一个关键的虚树节点）。换句话说，这个收缩的过程就像是把左右端点分别向路径中间收缩，直到各自都收缩到一个虚树节点。这样我们原来想查的 $u\leftrightarrow v$ 权值异或和，就可以转化成查这两个虚树节点在虚树上的路径的异或和，而这是一个简单的虚树上的树上差分。

挪移端点需要进行分类讨论，还要查询树上一段路径上有没有关键点。鉴于我们计算每个水果的总答案时还要查询一条路径上关键点的数量，但是我们每次都只需要设置一些点是关键点，使用树上差分加树状数组可以较快地解决。

有点麻烦，梳理一下算法流程：

1. 按照输入顺序，给输入的第 $i$ 个盘子权值 $2^{i-1}$。
2. 整体二分，以 $\leq mid$ 为盘子大小的分界线，得到盘子的左集合。
3. 将左集合盘子的路径端点设置为关键点，建立虚树，然后把左集合盘子的权值挂到路径端点上。
4. 对虚树垒权值的异或前缀和。
5. 考虑水果，对于水果 $u\leftrightarrow v$，把两个端点等价收缩到虚树上。
6. 查询收缩后的两端点在虚树上的路径权值异或和，可以通过树上差分得到，显然这个等价于在只有左盘子集合的情况下原 $u\leftrightarrow v$ 的路径权值异或和。
7. 查到这个东西，再查一个 $u\leftrightarrow v$  路径上关键点的数量，就可以算出来这个水果包含了多少个左盘子集合里的盘子。以此再划分水果，整体二分递归下去就可以了。

对于每一次判定，建立虚树复杂度 $\mathcal O(n'\log n)$，给虚树垒前缀异或和复杂度 $\mathcal O(\frac{n'p}{w})$，对于每个水果计算包含盘子数量复杂度 $\mathcal O(n' \log n+\frac{n'p}{w})$。给盘子大小做离散化之后，整体的复杂度就应该是 $\mathcal O(n\log^2 n+\frac{np}{w}\log n)$ 的。写的时候我直接把 bitset 大小开到了 $4\times 10^4$，也就是 $p$ 总是 $4\times 10^4$。

这玩意算出来倒不是很抽象，但是常数很大。然而并不妨碍开了 O2 之后 bitset 快得飞起，可以在 3s 内通过，~~不开 O2 无法通过~~。总时间来说比 SA 又 `assert` 又不开 O2 的 $\mathcal O(n\log ^2 n)$ 跑得快八秒（

实现的时候细节很多，要特判各种 LCA 是根节点的情况，还要写一堆板子，还有清空（清空虚树和树状数组）。但是最后想清楚了写出来还是觉得蛮清晰的。我大概调了两个小时。

代码写了 7.3K，[太长了就放这里吧](https://www.luogu.com.cn/paste/y88punbp)。

[AC Record](https://www.luogu.com.cn/record/151089078)。

---


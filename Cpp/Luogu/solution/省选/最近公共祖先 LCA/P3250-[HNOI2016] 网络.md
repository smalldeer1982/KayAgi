# [HNOI2016] 网络

## 题目描述

一个简单的网络系统可以被描述成一棵无根树。每个节点为一个服务器。连接服务器与服务器的数据线则看做一条树边。两个服务器进行数据的交互时，数据会经过连接这两个服务器的路径上的所有服务器（包括这两个服务器自身）。

由于这条路径是唯一的，当路径上的某个服务器出现故障，无法正常运行时，数据便无法交互。此外，每个数据交互请求都有一个重要度，越重要的请求显然需要得到越高的优先处理权。现在，你作为一个网络系统的管理员，要监控整个系统的运行状态。系统的运行也是很简单的，在每一个时刻，只有可能出现下列三种事件中的一种：

1. 在某两个服务器之间出现一条新的数据交互请求；  
2. 某个数据交互结束请求；
3. 某个服务器出现故障。系统会在任何故障发生后立即修复。也就是在出现故障的时刻之后，这个服务器依然是正常的。但在服务器产生故障时依然会对需要经过该服务器的数据交互请求造成影响。

你的任务是在每次出现故障时，维护未被影响的请求中重要度的最大值。注意，如果一个数据交互请求已经结束，则不将其纳入未被影响的请求范围。


## 说明/提示

样例给出的树如下所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/ka4zpxia.png)

解释其中的部分询问；下面的解释中用 $(a,b;t,v)$ 表示在 $t$ 时刻出现的服务器 $a$ 和 $b$ 之间的重要度为 $v$ 的请求：

对于第一个询问（在时刻 $1$），此时没有任何请求，输出 $-1$。

对于第四个询问（在时刻 $6$），此时有两条交互$(8,13;2,3),(9,12;3,5)$，所有询问均经过 $2$ 号服务器，输出 $-1$。

对于第五个询问（在时刻 $8$），此时有三条交互 $(8,13;2,3),(9,12;3,5),(10,12;7,1)$，只有交互 $(10,12;7,1)$ 没有经过 $2$ 号服务器，因此输出其重要度 $1$。

对于最后一个询问（在时刻 $23$），此时有三条交互 $(9,5;12,6),(9,12;16,4),(10,5;17,7)$。当 $3$ 号服务器出现故障时，只有交互 $(9,5;12,6)$ 没有经过 $3$ 号服务器，因此输出 $6$。

$\text{upd 2016.5.20}$：新加一组 $\text{Hack}$ 数据。

## 样例 #1

### 输入

```
13 23
1 2
1 3
2 4
2 5
3 6
3 7
4 8
4 9
6 10
6 11
7 12
7 13
2 1
0 8 13 3
0 9 12 5
2 9
2 8
2 2
0 10 12 1
2 2
1 3
2 7
2 1
0 9 5 6
2 4
2 5
1 7
0 9 12 4
0 10 5 7
2 1
2 4
2 12
1 2
2 5
2 3```

### 输出

```
-1 
3 
5 
-1 
1 
-1 
1 
1 
3 
6 
7 
7 
4 
6```

# 题解

## 作者：Salamander (赞：38)

用时间线段树或者直接暴力维护是$O(n\log^3n)$的，虽然卡卡常可以过但是有更好的做法。
	
考虑二分答案，如果某个询问点被所有大于当前答案的路径所经过，那么答案小于等于当前答案，否则大于等于当前答案。查询经过一个点的路径条数，把路径两端点权加一，然后lca和lca父亲的点权减一，用树状数组维护一下子树权值和即可。
	
但是我们还要考虑一条路径在当前时刻是否出现，以及计算出比当前答案大的路径有多少条。
	
所以我们考虑整体二分。整体二分中当前部分的各个操作依旧是按照时间顺序进行的，可以同时维护当前时刻路径是否存在，以及计算出比当前答案大的路径有多少条。
	
假设当前二分的答案是mid，要处理的操作队列为q。我们只需要扫一遍q，如果是询问那么就查询一下经过它的路径，判断它下次会被丢到左边递归还是丢到右边递归；如果是修改，那么如果这次修改对应的路径权值大于mid，就进行修改，然后丢到右边递归，否则对当前情况下其他的询问没有影响，直接丢到左边递归即可。
	
复杂度$O(n\log^2n)$，不需要任何优化跑得飞快。

```
#include<bits/stdc++.h>
using std::vector;

#define For(i,_beg,_end) for(int i=(_beg),i##end=(_end);i<=i##end;++i)
#define Rep(i,_beg,_end) for(int i=(_beg),i##end=(_end);i>=i##end;--i)

template<typename T>T Max(const T &x,const T &y){return x<y?y:x;}
template<typename T>T Min(const T &x,const T &y){return x<y?x:y;}
template<typename T>int chkmax(T &x,const T &y){return x<y?(x=y,1):0;}
template<typename T>int chkmin(T &x,const T &y){return x>y?(x=y,1):0;}
template<typename T>void read(T &x){
	T f=1;char ch=getchar();
	for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;
	for(x=0;ch>='0'&&ch<='9';ch=getchar())x=x*10+ch-'0';
	x*=f;
}

const int maxn=200010;
struct edge{
	int to,nxt;
}e[maxn];
struct Query{
	int op,t,x,res;
	bool operator<(const Query &b)const{return t<b.t;}
}q[maxn],ql[maxn],qr[maxn];
int n,m,num,head[maxn],c[maxn];
int fa[maxn],top[maxn],size[maxn],son[maxn],dep[maxn];
int A[maxn],B[maxn],C[maxn],tL[maxn],tR[maxn],dfn,mx;

void add(int,int);
int qry(int);
int qry(int,int);
void addedge(int,int);
void Dfs1(int,int);
void Dfs2(int,int);
int lca(int,int);
void Solve(int,int,int,int);
void modify(int,int,int);

int main(){
	read(n);read(m);
	For(i,1,n-1){
		int u,v;read(u);read(v);
		addedge(u,v);
	}
	Dfs1(1,0);Dfs2(1,1);
	For(i,1,m){
		read(q[i].op);
		q[i].t=i;
		if(!q[i].op){
			read(A[i]);read(B[i]);
			read(C[i]);
			q[i].x=i;
			chkmax(mx,C[i]);
		}
		else read(q[i].x);
	}
	Solve(-1,mx,1,m);
	std::sort(q+1,q+m+1);
	For(i,1,m) if(q[i].op==2) printf("%d\n",q[i].res);
	return 0;
}

void Solve(int l,int r,int L,int R){
	if(l==r){
		For(i,L,R) if(q[i].op==2) q[i].res=l;
		return;
	}
	int mid=(l+r)>>1,path=0,cntl=0,cntr=0;
	For(i,L,R){
		if(q[i].op==2){
			if(qry(tL[q[i].x],tR[q[i].x])==path) ql[++cntl]=q[i];
			else qr[++cntr]=q[i];
		}
		else{
			if(C[q[i].x]<=mid) ql[++cntl]=q[i];
			else{
				int v=q[i].op?-1:1;
				path+=v;
				modify(A[q[i].x],B[q[i].x],v);
				qr[++cntr]=q[i];
			}
		}
	}
	For(i,1,cntr) if(qr[i].op!=2){
		int v=qr[i].op?1:-1;
		modify(A[qr[i].x],B[qr[i].x],v);
	}
	For(i,1,cntl) q[L+i-1]=ql[i];
	For(i,1,cntr) q[L+cntl+i-1]=qr[i];
	if(cntl) Solve(l,mid,L,L+cntl-1);
	if(cntr) Solve(mid+1,r,L+cntl,R);
}
void modify(int x,int y,int v){
	int z=lca(x,y);
	add(tL[x],v);add(tL[y],v);add(tL[z],-v);
	if(fa[z]) add(tL[fa[z]],-v);
}
void Dfs1(int x,int f){
	dep[x]=dep[fa[x]=f]+1;
	size[x]=1;tL[x]=++dfn;
	for(int i=head[x];i;i=e[i].nxt)
		if(e[i].to!=f){
			Dfs1(e[i].to,x);
			size[x]+=size[e[i].to];
			if(size[e[i].to]>size[son[x]]) son[x]=e[i].to;
		}
	tR[x]=dfn;
}
void Dfs2(int x,int tp){
	top[x]=tp;
	if(son[x]) Dfs2(son[x],tp);
	for(int i=head[x];i;i=e[i].nxt)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			Dfs2(e[i].to,e[i].to);
}
int lca(int u,int v){
	int x=top[u],y=top[v];
	while(x!=y){
		if(dep[x]>dep[y]) x=top[u=fa[x]];
		else y=top[v=fa[y]];
	}
	return dep[u]<dep[v]?u:v;
}
void addedge(int u,int v){
	e[++num].to=v;e[num].nxt=head[u];head[u]=num;
	e[++num].to=u;e[num].nxt=head[v];head[v]=num;
}
void add(int x,int v){for(;x<=n;x+=x&-x) c[x]+=v;}
int qry(int x){
	int res=0;
	for(;x;x-=x&-x) res+=c[x];
	return res;
}
int qry(int l,int r){return qry(r)-qry(l-1);}
```

---

## 作者：yybyyb (赞：15)

这题真是相当的暴力。。。

树链剖分搞出DFS序，以及用来求LCA

既然是不在这个节点上的最大值

那就把除了这个路径上的点之外的所有点全部丢到一个堆里面

具体的讲：

类似于线段树套一个堆？？？

具体的实现还是看代码把。。。

[但是我就喜欢强行把博客插进来](http://www.cnblogs.com/cjyyb/p/7623995.html)

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<set>
#include<map>
#include<queue>
#include<vector>
#define MAX 110000
#define lson (now<<1)
#define rson (now<<1|1)
using namespace std;
inline int read()
{
    int x=0,t=1;char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
    if(ch=='-')t=-1,ch=getchar();
    while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
    return x*t;
}
struct Line
{
    int v,next;
}e[MAX*2];
struct Link
{
    int l,r;
}li[MAX];
struct Record
{
    int u,v,w;
}tt[MAX];
inline bool operator <(Link a,Link b)
{
    if(a.l!=b.l)return a.l<b.l;
    else return a.r<b.r;
}
int size[MAX],hson[MAX];
int h[MAX],cnt=1,dep[MAX],top[MAX],ff[MAX];
inline void Add(int u,int v)
{
    e[cnt]=(Line){v,h[u]};
    h[u]=cnt++;
}
struct PQ
{
    priority_queue<int> Q1;
    priority_queue<int> Q2;
    void push(int x)
        {
            Q1.push(x);
        }
    void del(int x)
        {
            Q2.push(x);
        }
    int top()
        {
            while(!Q2.empty()&&Q1.top()==Q2.top()){Q1.pop();Q2.pop();}
            return Q1.empty()?-1:Q1.top();
        }
}t[MAX*5];
int tim,N,M,dfn[MAX];
void DFS1(int u,int f)
{
    size[u]=1;dep[u]=dep[f]+1;
    for(int i=h[u];i;i=e[i].next)
    {
        int v=e[i].v;
        if(v==f)continue;
        ff[v]=u;
        DFS1(v,u);
        size[u]+=size[v];
        if(size[v]>size[hson[u]])hson[u]=v;
    }
}
void DFS2(int u,int tp)
{
    top[u]=tp;dfn[u]=++tim;
    if(hson[u])DFS2(hson[u],tp);
    for(int i=h[u];i;i=e[i].next)
    {
        int v=e[i].v;
        if(v==ff[u]||v==hson[u])continue;
        DFS2(v,v);
    }
}
void Update(int now,int l,int r,int al,int ar,int k,int opt)
{
    if(al==l&&ar==r)
    {
        opt?t[now].del(k):t[now].push(k);
        return;
    }
    int mid=(l+r)>>1;
    if(ar<=mid)Update(lson,l,mid,al,ar,k,opt);
    else if(al>mid)Update(rson,mid+1,r,al,ar,k,opt);
    else{Update(lson,l,mid,al,mid,k,opt);Update(rson,mid+1,r,mid+1,ar,k,opt);}
}
int Query(int now,int l,int r,int x)
{
    if(l==r)return t[now].top();
    int mid=(l+r)>>1;
    int ans=t[now].top();
    if(x<=mid)return max(ans,Query(lson,l,mid,x));
    else return max(ans,Query(rson,mid+1,r,x));
}
void Happen(int u,int v,int opt,int xx)
{
    int qq=0;
    while(top[u]!=top[v])
    {
        if(dep[top[u]]<dep[top[v]])swap(u,v);
        li[++qq]=(Link){dfn[top[u]],dfn[u]};
        u=ff[top[u]];
    }
    if(dep[u]<dep[v])swap(u,v);
    li[++qq]=(Link){dfn[v],dfn[u]};
    sort(&li[1],&li[qq+1]);
    int Left=0;
    for(int i=1;i<=qq;Left=max(Left,li[i++].r))
        if(Left+1<li[i].l)Update(1,1,N,Left+1,li[i].l-1,xx,opt);
    if(Left<N)Update(1,1,N,Left+1,N,xx,opt);
}
int main()
{
    freopen("4538.in","r",stdin);
    N=read();M=read();
    for(int i=1;i<N;++i)
    {
        int u=read(),v=read();
        Add(u,v);Add(v,u);
    }
    DFS1(1,0);DFS2(1,1);
    for(int i=1;i<=M;++i)
    {
        int opt=read();
        if(opt==2)
        {
            int x=read();
            printf("%d\n",Query(1,1,N,dfn[x]));
        }
        else if(opt==1)
        {
            int r=read();
            Happen(tt[r].u,tt[r].v,opt,tt[r].w);
        }
        else
        {
            tt[i]=(Record){read(),read(),read()};
            Happen(tt[i].u,tt[i].v,opt,tt[i].w);
        }
    }
    return 0;
}
```

---

## 作者：破壁人 (赞：15)

由于这道题的操作只与两个点之间的路径有关，因此以哪个节点为根不影响结果。

再分析题目其实就是一棵树支持添加和删除路径并支持单点询问，这就是树链剖分了。

因此我们随便以一个点为根，把树进行重链剖分加线段树维护。

由于题目要问的是不受某个点影响的最大重要度，

因此我们把每个线段树结点变成一个堆，

然后添加路径的时候把所有不在这条路径上的点所在的线段树结点的堆中加入这条路径的重要度，

因为这些点肯定不会影响这条路径的畅通。

那么直接O(N)的寻找所有不在这条路径上的点肯定会T那么我们采取更高效的办法：

在沿着重链向上跳的过程中，把所经过的重链的首尾记录下来排序之后把与之交错的区间加入线段树即可。

因为同一条重链在线段树中肯定是连续的。

问题在于题目还支持删除路径操作，那么怎么满足呢？

再维护一个堆，删除时把重要度加入这个堆，求值时判断一下两个堆的堆顶元素，

若相同同时pop掉，否则加入堆的堆顶元素就是要求的值。（常规操作，证明很简单就略去了）

当然仅仅使用以上操作你不但会被T飞而且会被M飞。

那么问题出在哪呢？

我们在用线段树求值的时候，一旦发现目标区间包含了当前区间那么当前区间所有值肯定会影响目标区间。

所以维护线段树时是不用下传和合并的。这样就节约了大量时间和空间。

经过层层优化终于可以AC了。














```cpp
#include<iostream>
#include<vector>
#include<queue>
#include<cstring>
#include<algorithm>
using namespace std;
struct opq
{
    int ax;
    int ay;
}kk[200001];
vector<int> a[200001];
priority_queue<int> segmenttree1[500001],segmenttree2[500001];
int n,m,size[200001],top[200001],position[200001];
int deep[200001],son[200001],fa[200001],z=0;
int u[200001],v[200001],importance[200001];
bool cmp(opq a1,opq a2)
{
    return a1.ax<a2.ax;
}
void dfs1(int o,int p)
{
    size[o]=1;
    fa[o]=p;
    deep[o]=deep[p]+1;
    if(a[o].empty()) return;
    int maxx=0;
    for(int i=0;i<a[o].size();i++)
        if(a[o][i]!=fa[o])
        {
            if(!size[a[o][i]]) dfs1(a[o][i],o);
            size[o]+=size[a[o][i]];
            if(size[a[o][i]]>maxx)
            {
                maxx=size[a[o][i]];
                son[o]=a[o][i];
            }
        }
}
void dfs2(int o,int p)
{
    z++;
    position[o]=z;
    top[o]=p;
    if(son[o]!=0) 
        dfs2(son[o],top[o]);
    for(int i=0;i<a[o].size();i++)
        if((a[o][i]!=son[o])&&(a[o][i]!=fa[o]))
            dfs2(a[o][i],a[o][i]);
}
void put1(int o,int p,int q,int r,int s,int t)//加入堆的操作
{
    if(q>r) return;
    if((q>=o)&&(r<=p)) 
    {
        segmenttree1[s].push(t);
        return;
    }
    int mid=(q+r)/2;
    if(p<=mid) put1(o,p,q,mid,s*2,t);else
    if(o>mid)put1(o,p,mid+1,r,s*2+1,t);else
    {put1(o,mid,q,mid,s*2,t);put1(mid+1,p,mid+1,r,s*2+1,t);}
}
void puttree1(int o,int p,int q)//加入堆的操作
{
    int yu=0;
    while(top[o]!=top[p])
    {
        if(deep[top[o]]<deep[top[p]]){int t=o;o=p;p=t;}
        kk[++yu].ay=position[o];
        kk[yu].ax=position[top[o]];
        o=fa[top[o]];
    }
    if(deep[o]>deep[p]){int t=o;o=p;p=t;}
    kk[++yu].ax=position[o];
    kk[yu].ay=position[p];
    sort(kk+1,kk+yu+1,cmp);//把所经过的重链的首尾记录下来排序
    kk[0].ay=0;
    kk[++yu].ax=n+1;
    for(int i=1;i<=yu;i++)
        if(kk[i-1].ay+1<=kk[i].ax-1)
            put1(kk[i-1].ay+1,kk[i].ax-1,1,n,1,q);//把与之交错的区间加入线段树。
}
void put2(int o,int p,int q,int r,int s,int t)//删除堆的操作
{
    if(q>r) return;
    if((q>=o)&&(r<=p))
    {
        segmenttree2[s].push(t);
        return;
    }
    int mid=(q+r)/2;
    if(p<=mid) put2(o,p,q,mid,s*2,t);else
    if(o>mid)put2(o,p,mid+1,r,s*2+1,t);else
    {put2(o,mid,q,mid,s*2,t);put2(mid+1,p,mid+1,r,s*2+1,t);}
}
void puttree2(int o,int p,int q)//删除堆的操作
{
    int yu=0;
    while(top[o]!=top[p])
    {
        if(deep[top[o]]<deep[top[p]]){int t=o;o=p;p=t;}
        kk[++yu].ay=position[o];
        kk[yu].ax=position[top[o]];
        o=fa[top[o]];
    }
    if(deep[o]>deep[p]){int t=o;o=p;p=t;}
    kk[++yu].ax=position[o];
    kk[yu].ay=position[p];
    sort(kk+1,kk+yu+1,cmp);
    kk[0].ay=0;
    kk[++yu].ax=n+1;
    for(int i=1;i<=yu;i++)
        if(kk[i-1].ay+1<=kk[i].ax-1)
            put2(kk[i-1].ay+1,kk[i].ax-1,1,n,1,q);
}
int get(int o,int p,int q,int r,int s)//回答询问，求值。
{
    int xxx=-1;
    if((q<=o)&&(r>=p))
    {
        while((!segmenttree1[s].empty())&&(!segmenttree2[s].empty()))
        {
            if(segmenttree1[s].top()!=segmenttree2[s].top())break;
            segmenttree1[s].pop();
            segmenttree2[s].pop();
        }
        if(!segmenttree1[s].empty()) xxx=segmenttree1[s].top();
    }
    if(q==r) return xxx;
    int mid=(q+r)/2;
    if(p<=mid) return max(xxx,get(o,p,q,mid,s*2));else
    if(o>mid)return max(xxx,get(o,p,mid+1,r,s*2+1));
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<n;i++)
    {
        int x,y;
        cin>>x>>y;
        a[x].push_back(y);
        a[y].push_back(x);
    }
    memset(son,0,sizeof(son));
    memset(size,0,sizeof(size));
    dfs1(1,0);//重链剖分第一次dfs，求出每个结点的重儿子父亲和以其为根的子树大小。
    dfs2(1,1);//重链剖分第二次dfs，求出每个节点在线段树中的位置和所在重链的头。
    for(int i=1;i<=m;i++)
    {
        int yu;
        cin>>yu;
        if(yu==0){cin>>u[i]>>v[i]>>importance[i];puttree1(u[i],v[i],importance[i]);}
        if(yu==1){cin>>u[i];puttree2(u[u[i]],v[u[i]],importance[u[i]]);}
        if(yu==2){cin>>u[i];cout<<get(position[u[i]],position[u[i]],1,n,1)<<endl;}
    }
    return 0;
}
```

---

## 作者：Rainybunny (赞：7)

# 题目

&emsp;&emsp;[luogu](https://www.luogu.com.cn/problem/P3250).

# 题解

&emsp;&emsp;~~%%%yyb~~

&emsp;&emsp;树剖 + 双堆 trick。

&emsp;&emsp;既然“交互请求”出现在路径上，询问又会破坏路径，那么我们反其道而行之：把交互请求挂在**除路径以外的所有结点**上。

&emsp;&emsp;再因为涉及到求最大值以及删除元素，不难联想到一个 trick：维护两个堆，一个堆标记现有元素（包括一些被标记删除的元素），另一个堆维护删除标记。在最大值时，先同步弹出两个堆的堆顶元素直到两个堆堆顶不同，此时第一个堆的堆顶就是未被删除的最大值。

&emsp;&emsp;接着，自然地树剖：维护一颗线段树，每个结点是如上文的一个双堆，表示**完全覆盖该区间的交互信息**。更新时向所有 **$dfn$ 未被覆盖的点插入交互信息**；查询时单点查询即可。
## 代码
```cpp
#include <queue>
#include <cstdio>
#include <iostream>
#include <algorithm>

inline int rint () {
	int x = 0, f = 1; char s = getchar ();
	for ( ; s < '0' || '9' < s; s = getchar () ) f = s == '-' ? -f : f;
	for ( ; '0' <= s && s <= '9'; s = getchar () ) x = x * 10 + ( s ^ '0' );
	return x * f;
}

template<typename Tp>
inline void wint ( Tp x ) {
	if ( x < 0 ) putchar ( '-' ), x = ~ x + 1;
	if ( 9 < x ) wint ( x / 10 );
	putchar ( x % 10 ^ '0' );
}

const int MAXN = 1e5, MAXM = 2e5;
int n, m, indx, ecnt, head[MAXN + 5];
int dep[MAXN + 5], fa[MAXN + 5], siz[MAXN + 5], son[MAXN + 5];
int dfn[MAXN + 5], top[MAXN + 5];
std :: pair<int, int> cover[MAXN + 5];

struct MultiPriorityQueue {
private:
	std :: priority_queue<int> ele, rem;

public:
	inline int top () {
		for ( ; ! rem.empty () && ! ele.empty () && ele.top () == rem.top (); ele.pop (), rem.pop () );
		return ele.empty () ? -1 : ele.top ();
	}
	inline void insert ( const int val ) { ele.push ( val ); }
	inline void erase ( const int val ) { rem.push ( val ); }
};

class SegmentTree {
private:
	MultiPriorityQueue mpq[MAXN << 2];

public:
	inline void update ( const int rt, const int ul, const int ur, const int l, const int r, const int val, const bool opt ) {
		if ( ul <= l && r <= ur ) return opt ? mpq[rt].insert ( val ) : mpq[rt].erase ( val );
		int mid = l + r >> 1;
		if ( ul <= mid ) update ( rt << 1, ul, ur, l, mid, val, opt );
		if ( mid < ur ) update ( rt << 1 | 1, ul, ur, mid + 1, r, val, opt );
	}
	inline int query ( const int rt, const int x, const int l, const int r ) {
		if ( l == r ) return mpq[rt].top ();
		int mid = l + r >> 1, tmp = mpq[rt].top ();
		if ( x <= mid ) return std :: max ( tmp, query ( rt << 1, x, l, mid ) );
		else return std :: max ( tmp, query ( rt << 1 | 1, x, mid + 1, r ) );
	}
} st;

struct Edge { int to, nxt; } graph[MAXN * 2 + 5];

struct Task { int a, b, v; } task[MAXM + 5];

inline void link ( const int s, const int t ) { graph[++ ecnt] = { t, head[s] }, head[s] = ecnt; }

inline void DFS1 ( const int u, const int f ) {
	dep[u] = dep[fa[u] = f] + 1, siz[u] = 1;
	for ( int i = head[u], v; i; i = graph[i].nxt ) {
		if ( ( v = graph[i].to ) ^ f ) {
			DFS1 ( v, u ), siz[u] += siz[v];
			if ( siz[son[u]] < siz[v] ) son[u] = v;
		}
	}
}

inline void DFS2 ( const int u, const int tp ) {
	dfn[u] = ++ indx, top[u] = tp;
	if ( son[u] ) DFS2 ( son[u], tp );
	for ( int i = head[u], v; i; i = graph[i].nxt ) {
		if ( ( v = graph[i].to ) ^ fa[u] && v ^ son[u] ) {
			DFS2 ( v, v );
		}
	}
}

inline void update ( int x, int y, const int val, const int opt ) {
	int sec = 0;
	while ( top[x] ^ top[y] ) {
		if ( dep[top[y]] > dep[top[x]] ) x ^= y ^= x ^= y;
		cover[++ sec] = { dfn[top[x]], dfn[x] };
		x = fa[top[x]];
	}
	if ( dep[y] > dep[x] ) x ^= y ^= x ^= y;
	cover[++ sec] = { dfn[y], dfn[x] };
	std :: sort ( cover + 1, cover + sec + 1 );
	for ( int i = 1, l = 0; i <= sec; l = cover[i ++].second ) {
		if ( l + 1 != cover[i].first ) {
			st.update ( 1, l + 1, cover[i].first - 1, 1, n, val, opt );
		}
	}
	if ( cover[sec].second ^ n ) st.update ( 1, cover[sec].second + 1, n, 1, n, val, opt );
}

int main () {
	n = rint (), m = rint ();
	for ( int i = 1, u, v; i < n; ++ i ) {
		u = rint (), v = rint ();
		link ( u, v ), link ( v, u );
	}
	DFS1 ( 1, 0 ), DFS2 ( 1, 1 );
	for ( int i = 1, opt, a, b, v; i <= m; ++ i ) {
		opt = rint (), a = rint ();
		if ( ! opt ) {
			b = rint (), v = rint ();
			task[i] = { a, b, v };
			update ( a, b, v, true );
		}
		else if ( opt & 1 ) update ( task[a].a, task[a].b, task[a].v, false );
		else wint ( st.query ( 1, dfn[a], 1, n ) ), putchar ( '\n' );
	}
	return 0;
}
```



---

## 作者：Forwarcl (赞：6)

值得一做的题目  

首先从查询操作入手，设有一查询操作，不妨设查询节点编号为 $u$ 。首先我们需要考虑，如果答案**大于等于** $x$ ，那么对于 $u$ 来说，它需要满足什么？需要至少存在一条交互请求重要度**大于等于** $x$ 且不经过 $u$ 号节点即可。但是这条性质对代码并不是非常的友好，那么我们可以换一种说法，这样我们就得到了 **性质1：**  

**重要度大于等于 $x$ 的请求数 $>$ 经过 $u$ 且重要度大于等于 $x$ 的请求数**  

因为答案求的是最大值，所以我们需要最大化 $x$ 。  
看到最大，一般想到数据结构或者单调性相关的问题。在这个情景中，数据结构显然并不怎么好用。于是考虑单调性。如果真的往单调性想了，会比较容易地发现一个简单又重要的性质：  

**设由所有 $x$ 组成的集合为 $D$，那么若 $k \in D$，那么 $\forall m < k, m \in Z_+$ ，那么 $ m \in D$**

所以，$x$ 的分布具有单调性！  

根据单调性，考虑二分。  
仍然是上面的情景，查询 $u$ 号节点，设当前答案在 $[l,r]$ 范围内，枚举答案为 $mid=\left\lfloor\frac{l+r}{2}\right\rfloor$，如果重要度**大于（注意这里没有等于，下文同，全部经过了加粗处理）** $mid$ 的请求数 $=$ 经过 $u$ 的重要度**大于** $mid$ 的请求数，根据单调性，说明 $mid$ 太大，$r=mid+1$，否则 $l=mid$（为什么是$mid$呢？因为这条请求的答案值域是 $[l,mid]$，注意加粗部分）。  

如何维护一个点被经过多少次？考虑树上差分，对于请求 $(u,v)$ （从 $u$ 到 $v$ ），$ val[u]=val[u]+1, val[v]=val[v]+1, val[LCA(u, v)]=val[LCA(u, v)]-1 $ （注意是 $-1$ ） ，每个点被经过多少次就是它的子树权值和（初始值 $0$ ），但是为了让 $LCA(u, v)$ 的祖先答案不受影响，所以 $val[father[LCA(u, v)]]=val[father[LCA(u, v)]]-1$（注意是 $-1$ ）。因为要维护子树和，有要求 $LCA$， 想到树链剖分+树状数组 ~~（线段树太麻烦了~~ 。  

此时，因为需要实时维护过 $u$ 的所有权值大于等于 $mid$ 的请求数，复杂度偏高。    
既然一个个维护的时间太多，那么可不可以一起维护呢？考虑整体二分。  
对于某一个操作子序列，值域 $[l,r]$，枚举答案 $mid=\left\lfloor\frac{l+r}{2}\right\rfloor$。从前往后遍历操作子序列，对于查询操作，如果重要度**大于** $mid$ 的请求数 $=$ 经过 $u$ 的重要度**大于** $mid$ 的请求数，根据单调性，说明 $mid$ 太大，$r=mid+1$（进入左侧递归），否则 $l=mid$（进入右侧递归）。那么如何处理修改操作（进入左侧递归\右侧递归）？因为我们只关心重要度**大于** $mid$ 的请求，所以对于重要度**小于等于** $mid$ 的请求，进入左侧递归即可，因为只有让 $mid$ 变小才可以让这条请求有可能发挥作用。如果这条修改操作重要度**大于** $mid$ ，那么我们按照上文所说的，进行该有的修改，并进入右侧递归，让它在 $mid$ 更大的位置发挥作用。这种操作没有必要进入左侧递归，因为左侧递归的值域为当前递归的 $[l,mid]$（如果进入左区间修改的时候一定会被修改，还不如降低一下复杂度）。  
最后考虑，如何输出 $-1$ 的情况？只需要在一开始递归的时候，将左边界设成 $-1$ ，这样答案是 $-1$ 就会不断进入左区间，直到到达 $-1$ 。  

复杂度：二分 $\log n$， 维护 $\log n$ ，合起来就是 $O(m \times  \log^2 n)$。

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <vector>
#include <cstdio>
using namespace std;

inline int read () {
	int ans = 0; char ch = getchar();
	while(!isdigit(ch)) ch = getchar();
	while(isdigit(ch)) ans = ans * 10 + ch - '0', ch = getchar();
	return ans;
}

const int N = 100005;
const int Q = 200005;
const int INF = 0x3f3f3f3f;
int n, m;
int num;
int head[N];
struct edge {
	int to, nxt;
} e[N << 1];

inline void add (int u, int v) {
	e[++ num].nxt = head[u];
	e[num].to = v;
	head[u] = num;
}

//树状数组，维护子树权值和
int sum[N];
inline int lowbit (int x) { return x & (-x); }
void update (int x, int k) { // 单点修改第 x 个点
	while(x <= n) {
		sum[x] += k;
		x += lowbit(x);
	}
}

int query (int x) { // 查询 [1, x]和
	int ret = 0;
	while(x > 0) {
		ret += sum[x];
		x -= lowbit(x);
	}
	
	return ret;
}

// 树链剖分，维护子树权值和和LCA
int cnt;
int fa[N], siz[N], son[N], depth[N];
int top[N], id[N];

void dfs1 (int u, int father) {
	fa[u] = father;
	depth[u] = depth[fa[u]] + 1;
	siz[u] = 1;
	
	for(int i = head[u]; i; i = e[i].nxt) {
		int v = e[i].to;
		if(v == fa[u]) continue;
		
		dfs1(v, u);
		siz[u] += siz[v];
		if(siz[v] > siz[son[u]]) son[u] = v;
	}
}

void dfs2 (int u, int tp) {
	id[u] = ++ cnt;
	top[u] = tp;
	
	if(!son[u]) return;
	dfs2(son[u], tp);
	
	for(int i = head[u]; i; i = e[i].nxt) {
		int v = e[i].to;
		if(v == fa[u] || v == son[u]) continue;
		
		dfs2(v, v);
	}
}

int LCA (int u, int v) { // 树剖求LCA
	while(top[u] != top[v]) {
		if(depth[top[u]] < depth[top[v]]) swap(u, v);
		u = fa[top[u]];
	}
	
	if(depth[u] > depth[v]) return v; // 深度浅的才是LCA
	return u;
}

struct query_ { // 离线处理
	int op;
	int u, v, w;
	int x;
	int ans;
} q[Q]; // q 存的是询问（按输入顺序）

inline void updatecounter (int u, int v, int w) { // 树上差分，文中所说的方法
	int lca = LCA(u, v);
	update(id[u], w);
	update(id[v], w);
	update(id[lca], -w);
	if(fa[lca] != 0) update(id[fa[lca]], -w); // 这里一定要注意fa[lca] != 0 !!
}

int querytree (int u) {
	return (query(id[u] + siz[u] - 1) - query(id[u] - 1)); // 查询子树权值和
}

void split (int l, int r, vector <int> p) { // p是操作序列，p[0]代表这层递归最先执行的操作是 q[p[0]] （参数传的是按输入顺序的编号）
	if(!p.size()) return;
	if(l == r) {
		for(int i = 0; i < p.size(); ++ i) if(q[p[i]].op == 2) q[p[i]].ans = l;
		return;
	}
	
	int mid = l + r >> 1;
	int cnt = 0; // 目前重要度大于等于 mid 的请求数量（我们只更新重要度大于等于mid的请求）
	vector <int> lft, rgt; // 接下来左递归和右递归的子序列（编号）
	// left right的缩写
	
	for(int i = 0; i < p.size(); ++ i) { // p存的是原来操作的下表，所以第i个操作应该是q[p[i]]
		if(q[p[i]].op == 2) { // 查询操作
			if(querytree(q[p[i]].x) == cnt) // 数量相同，进入左侧递归（此处维护方法即为文中所说的树上差分
				lft.push_back(p[i]);
			else rgt.push_back(p[i]); // 进入右侧递归
		}
		else { // 修改操作
			if(q[p[i]].w > mid) { // 只修改重要度大于等于mid的请求
				int t;
				if(q[p[i]].op == 0) t = 1; else t = -1; // 取消一条请求和加入一条请求正好相反
				cnt += t; // 多了/少了一条重要度大于等于mid的请求
				updatecounter(q[p[i]].u, q[p[i]].v, t);
				rgt.push_back(p[i]);
			}
			else lft.push_back(p[i]);
		}
	}
	
	for(int i = 0; i < p.size(); ++ i) { // 方便下次修改（让树状数组清零，与上面那段代码正好相反）
		if(q[p[i]].op == 2) continue;
		if(q[p[i]].w > mid) {
			int t;
			if(q[p[i]].op == 0) t = -1; else t = 1;
			updatecounter(q[p[i]].u, q[p[i]].v, t);
		}
	}
	
	split(l, mid, lft); // 递归 [l, mid]
	split(mid + 1, r, rgt); // 递归 [mid + 1, r]
}

int main () {

	n = read(); m = read();
	for(int i = 1; i < n; ++ i) {
		int u, v;
		u = read(); v = read();
		add(u, v); add(v, u);
	}
	
	dfs1(1, 0);
	dfs2(1, 1); // 树链剖分

	for(int i = 1; i <= m; ++ i) { // 离线处理
		int op = read();
		q[i].op = op;
		if(op == 0) {
			int u, v, w;
			u = read(), v = read(); w = read();
			q[i].u = u; q[i].v = v; q[i].w = w;
		}
		else if(op == 1) {
			int k = read();
			q[i].u = q[k].u; q[i].v = q[k].v; q[i].w = q[k].w; 
		}
		else {
			int x;
			x = read();
			q[i].x = x;
		}
	}
	
	vector <int> f;
	for(int i = 1; i <= m; ++ i) f.push_back(i); // 处理 1 ~ m 的操作 （编号）
	split(-1, (int)(1e9), f); // 左边界为 -1
	
	for(int i = 1; i <= m; ++ i) if(q[i].op == 2) printf("%d\n", q[i].ans);
	
	return 0;
}
```

---

## 作者：λᴉʍ (赞：6)

打一波广告：https://www.cnblogs.com/xzz_233/p/9884562.html

显然可以想到二分答案。二分一个答案mid，如果所有长度$\geq mid$的路径都过x，那么答案一定$<mid$，否则答案$\geq mid$。

~~那么就可以写出代码了，树状数组套动态开点线段树即可。时间复杂度$O(n(log_2n)^3)$~~

然后因为出题人卡空间就炸了。。。如果256M就能过了。。

```cpp
#include<bits/stdc++.h>
#define il inline
#define vd void
typedef long long ll;
il int gi(){
    int x=0,f=1;
    char ch=getchar();
    while(!isdigit(ch)){
        if(ch=='-')f=-1;
        ch=getchar();
    }
    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();
    return x*f;
}
int n,m,fir[100010],nxt[200010],dis[200010],id;
il vd link(int a,int b){
    nxt[++id]=fir[a],fir[a]=id,dis[id]=b;
    nxt[++id]=fir[b],fir[b]=id,dis[id]=a;
}
int dfn[100010],dep[100010],fa[100010],siz[100010],son[100010];
il vd dfs(int x){
    siz[x]=1;
    for(int i=fir[x];i;i=nxt[i]){
        if(dep[dis[i]])continue;
        dep[dis[i]]=dep[x]+1;
        fa[dis[i]]=x;
        dfs(dis[i]);
        siz[x]+=siz[dis[i]];
        if(siz[son[x]]<=siz[dis[i]])son[x]=dis[i];
    }
}
int top[100010];
il vd dfs2(int x,int tp){
    top[x]=tp;dfn[x]=++dfn[0];
    if(son[x])dfs2(son[x],tp);
    for(int i=fir[x];i;i=nxt[i])if(fa[x]!=dis[i]&&son[x]!=dis[i])dfs2(dis[i],dis[i]);
}
int o[200010],u[200010],v[200010],w[200010];
int uni_w[200010],uni_w_tot;
int cnt,rt[200010],ls[15000001],rs[15000001],lz[15000001];
#define mid ((l+r)>>1)
il vd _update(int&x,int l,int r,const int&L,const int&R,const int&d){
    if(!x)x=++cnt;
    if(L<=l&&r<=R){lz[x]+=d;return;}
    if(L<=mid)_update(ls[x],l,mid,L,R,d);
    if(mid<R)_update(rs[x],mid+1,r,L,R,d);
}
il int _query(int&x,int l,int r,const int&p){
    if(!x)return 0;
    if(l==r)return lz[x];
    if(p<=mid)return lz[x]+_query(ls[x],l,mid,p);
    else return lz[x]+_query(rs[x],mid+1,r,p);
}
#undef mid
il vd Update(const int&p,const int&l,const int&r,const int&d){
    int x=p;
    while(x<=uni_w_tot)_update(rt[x],1,n,l,r,d),x+=x&-x;
}
il int Query(const int&p,const int&l){
    int x=p,ret=0;
    while(x)ret+=_query(rt[x],1,n,l),x-=x&-x;
    return ret;
}
int t[200010];
il vd bit_update(int x,int d){while(x<=uni_w_tot)t[x]+=d,x+=x&-x;}
il int bit_query(int x){int r=0;while(x)r+=t[x],x-=x&-x;return r;}
int main(){
    n=gi(),m=gi();
    for(int i=1;i<n;++i)link(gi(),gi());
    int RT=rand()%n+1;
    dep[RT]=1,dfs(RT),dfs2(RT,RT);
    for(int i=1;i<=m;++i){
        o[i]=gi();
        if(o[i]==0)u[i]=gi(),v[i]=gi(),w[i]=gi(),uni_w[++uni_w_tot]=-w[i];
        else if(o[i]==1){
            int t=gi();
            u[i]=u[t],v[i]=v[t],w[i]=w[t];
        }else if(o[i]==2)u[i]=gi();
    }
    std::sort(uni_w+1,uni_w+uni_w_tot+1);uni_w_tot=std::unique(uni_w+1,uni_w+uni_w_tot+1)-uni_w-1;
    for(int i=1;i<=m;++i)if(o[i]!=2)w[i]=std::lower_bound(uni_w+1,uni_w+uni_w_tot+1,-w[i])-uni_w;
    for(int i=1;i<=uni_w_tot;++i)uni_w[i]=-uni_w[i];
    for(int i=1;i<=m;++i){
        if(o[i]^2){
            int x=u[i],y=v[i],d=o[i]==0?1:-1;
            while(top[x]!=top[y])
                if(dep[top[x]]>dep[top[y]])Update(w[i],dfn[top[x]],dfn[x],d),x=fa[top[x]];
                else Update(w[i],dfn[top[y]],dfn[y],d),y=fa[top[y]];
            if(dfn[x]>dfn[y])std::swap(x,y);
            Update(w[i],dfn[x],dfn[y],d);
            bit_update(w[i],d);
        }else{
            if(!bit_query(uni_w_tot)){puts("-1");continue;}
            int l=1,r=uni_w_tot+1,mid;
            while(l<r){
                mid=((l+r)>>1);
                if(Query(mid,dfn[u[i]])==bit_query(mid))l=mid+1;
                else r=mid;
            }
            if(l<=uni_w_tot)printf("%d\n",uni_w[l]);
            else puts("-1");
        }
    }
    return 0;
}
```

然后学了一发神仙整体二分

大概就是说答案要用二分求，可以放在一起二分

大概就是`void solve(int l,int r,int L,int R)`，就是$[L,R]$的操作/询问，操作的权值都$\in[l,r]$，这里面的查询都已经确定了在$[l,r]$范围内。

如果$l=r$直接更新答案就好了，否则要确定这里面所有查询的

按时间顺序操作，如果当前是修改而且权值$\geq mid$，就加入/删除一条u-v的路径；如果是询问就所有的路径是否都经过当前点即可，就能知道这个询问的答案是否$\geq mid$。具体实现可以简单树上差分。

然后递归调用下去。

然后代码为了卡常把$\geq$改成了$\leq$，具体见代码。。

```cpp
#include<bits/stdc++.h>
#define il inline
#define vd void
typedef long long ll;
il int gi(){
    int x=0;
    char ch=getchar();
    while(!isdigit(ch))ch=getchar();
    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();
    return x;
}
int n,m,fir[100010],nxt[200010],dis[200010],id;
il vd link(int a,int b){
    nxt[++id]=fir[a],fir[a]=id,dis[id]=b;
    nxt[++id]=fir[b],fir[b]=id,dis[id]=a;
}
int dfn[100010],dep[100010],fa[100010],siz[100010],son[100010];
il vd dfs(int x){
    siz[x]=1;
    for(int i=fir[x];i;i=nxt[i]){
        if(dep[dis[i]])continue;
        dep[dis[i]]=dep[x]+1;
        fa[dis[i]]=x;
        dfs(dis[i]);
        siz[x]+=siz[dis[i]];
        if(siz[son[x]]<=siz[dis[i]])son[x]=dis[i];
    }
}
int top[100010];
il vd dfs2(int x,int tp){
    top[x]=tp;dfn[x]=++dfn[0];
    if(son[x])dfs2(son[x],tp);
    for(int i=fir[x];i;i=nxt[i])if(fa[x]!=dis[i]&&son[x]!=dis[i])dfs2(dis[i],dis[i]);
}
struct ques{int o,u,v,w,i,lca;bool y;}s[200010],a[200010],b[200010];
int uni_w[200010],uni_w_tot,ans[200010];
int t[200010];
il vd update(int x,int d){while(x<=n)t[x]+=d,x+=x&-x;}
il int query(int x){int r=0;while(x)r+=t[x],x-=x&-x;return r;}
il vd solve(int l,int r,int L,int R){
	if(L>R)return;
	for(int i=L;i<=R;++i)if(s[i].o==2)goto GG;
	return;GG:;
	if(l==r){for(int i=L;i<=R;++i)if(s[i].i)ans[s[i].i]=l;return;}
	int mid=(l+r)>>1,tot=0,A=0,B=0;
	for(int i=L;i<=R;++i)
		if(s[i].o==2){
			if(query(dfn[s[i].u]+siz[s[i].u]-1)-query(dfn[s[i].u]-1)==tot)b[++B]=s[i];
			else a[++A]=s[i];
		}else if(s[i].w<=mid){
			int d=s[i].o?-1:1;
			tot+=d;
			update(dfn[s[i].u],d);update(dfn[s[i].v],d);
			update(dfn[s[i].lca],-d);if(s[i].lca!=1)update(dfn[fa[s[i].lca]],-d);
			a[++A]=s[i];
		}else b[++B]=s[i];
	memcpy(s+L,a+1,(sizeof(ques))*A);
	memcpy(s+L+A,b+1,(sizeof(ques))*B);
	for(int i=L;i<=R;++i)
		if(s[i].o!=2&&s[i].w<=mid&&s[i].y){
			int d=s[i].o?1:-1;
			update(dfn[s[i].u],d);update(dfn[s[i].v],d);
			update(dfn[s[i].lca],-d);if(s[i].lca!=1)update(dfn[fa[s[i].lca]],-d);
		}
	solve(l,mid,L,L+A-1),solve(mid+1,r,L+A,R);
}
int main(){
    n=gi(),m=gi();
    for(int i=1;i<n;++i)link(gi(),gi());
    dep[1]=1,dfs(1),dfs2(1,1);
    for(int i=1;i<=m;++i){
        s[i].o=gi();
        if(s[i].o==0){
			s[i].u=gi(),s[i].v=gi(),s[i].w=gi(),uni_w[++uni_w_tot]=-s[i].w;s[i].y=1;
			int x=s[i].u,y=s[i].v;
			while(top[x]!=top[y]){
				if(dep[top[x]]>dep[top[y]])x=fa[top[x]];
				else y=fa[top[y]];
			}
			s[i].lca=(dep[x]<dep[y])?x:y;
        }else if(s[i].o==1){
			int x=gi();
			s[i]=s[x],s[i].o=1;
			s[i].y=s[x].y=0;
		}else s[i].u=gi(),s[i].i=++ans[0];
	}
	uni_w[++uni_w_tot]=1;
	std::sort(uni_w+1,uni_w+uni_w_tot+1);uni_w_tot=std::unique(uni_w+1,uni_w+uni_w_tot+1)-uni_w-1;
	for(int i=1;i<=m;++i)if(s[i].o!=2)s[i].w=std::lower_bound(uni_w+1,uni_w+uni_w_tot+1,-s[i].w)-uni_w;
	for(int i=1;i<=uni_w_tot;++i)uni_w[i]=-uni_w[i];
	solve(1,uni_w_tot,1,m);
	for(int i=1;i<=ans[0];++i)printf("%d\n",uni_w[ans[i]]);
	return 0;
}
```

卡了一波常数就洛咕rk1，bzoj rk7了。。

---

## 作者：CodyTheWolf (赞：3)

### [开头小广告：自己做的一个模板库OwO](https://www.luogu.org/blog/29354/Templet)
------------
### 思路:
~~一眼过去就是一道树剖题。~~

读完题目我们发现其实“交互请求”贡献的并不是请求路线上的点，而是他的补集。这很容易，我们在询问的时候记下树剖的至多$log$个区间，按照左右端点排序都可以（因为这些区间肯定不会相交），然后取补集区间就好了：

设我们的区间长这个样子：$[x_i,y_i]$，那么$[y_{i-1}+1,x_{i}-1]$就是我们的补集区间。类似的，$[y_{i}+1,x_{i+1}-1]$当然也是啦~（注意1和n的处理，也就是边界）

那么现在我们已经会修改了，如果不需要恢复修改的话，那么上个最大值线段是就算结束了，但是现在要恢复修改怎么办？我们肯定不能在最大值线段树上动手，否则当前的最大值被恢复了以后就不是再小一点的值了，因为它没有记录功能。

我们考虑能不能用线段树套一个数据结构记录：平衡树是我第一个想到的。用平衡树储存线段树区间对应拥有的值。

设我们的线段树区间长这个样子：$[x,y]$，那么当修改区间$[l,r]$包含它的时候，按照我们做其他区间修改的线段树的惯例，是应该修改权值并打标记的，但是如果我们要打标记就还得开数据结构存储标记，又要下放非常麻烦。我们可以用标记永久化避免这样的麻烦，那么平衡树也就是我们的标记池了（姑且这么叫吧）了。添加删除都是一样的，遇到区间包含就操作对应的平衡树。

要查询的时候，因为是单点的，我们直接从树根一路走下来，遇到一个区间就在平衡树上查询一下最大值（记得还有-1这回事）。

时间复杂度$O(nlog^3n)$，应该是可以卡过去的吧。。。。（to be continue

## Code
```cpp
// luogu-judger-enable-o2
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

const int MAXN = 1e6 + 5, MAXM = MAXN << 1, MAXT = 5e7 + 5;

int l[MAXT], r[MAXT], heap[MAXT], val[MAXT], sz[MAXT], root[MAXT], tot;
struct FHQTreap
{
    inline void Update(int x)
    {
        sz[x] = sz[l[x]] + sz[r[x]] + 1;
        return;
    }

    inline int Merge(int x, int y)
    {
        if (!x || !y)
            return x + y;
        if (heap[x] < heap[y])
            return r[x] = Merge(r[x], y), Update(x), x;
        return l[y] = Merge(x, l[y]), Update(y), y;
    }

    inline void Split(int x, int key, int &u, int &v)
    {
        if (!x)
        {
            u = v = 0;
            return;
        }

        if (val[x] <= key)
            u = x, Split(r[x], key, r[u], v);
        else
            v = x, Split(l[x], key, u, l[v]);
        Update(x);

        return;
    }

    inline int Create(int key)
    {
        heap[++tot] = rand(), val[tot] = key, sz[tot] = 1;
        return tot;
    }

    int x, y, z;

    inline void Insert(int &root, int key)
    {
        Split(root, key, x, y);
        root = Merge(x, Merge(Create(key), y));
        return;
    }

    inline void Delete(int &root, int key)
    {
        Split(root, key, x, z);
        Split(x, key - 1, x, y);
        y = Merge(l[y], r[y]);
        root = Merge(x, Merge(y, z));
        return;
    }

    inline int Top(int x)
    {
        while (r[x])
            x = r[x];
        return val[x];
    }

} FT;

#define mid ((x + y) >> 1)
#define lson (pos << 1)
#define rson (pos << 1 | 1)

struct SegmentTree
{
    inline void Update(int x, int y, int pos, int l, int r, int key, int opt)
    {
        if (y < l || x > r)
            return;
        if (l <= x && y <= r)
        {
            if (opt)
                FT.Insert(root[pos], key);
            else
                FT.Delete(root[pos], key);

            return;
        }

        Update(x, mid, lson, l, r, key, opt), Update(mid + 1, y, rson, l, r, key, opt);
        return;
    }

    inline int Query(int x, int y, int pos, int p)
    {
        register int ans = FT.Top(root[pos]);

        if (x != y)
        {
            if (p <= mid)
                return max(ans, Query(x, mid, lson, p));
            else
                return max(ans, Query(mid + 1, y, rson, p));
        }

        return ans;
    }

} ST;

int head[MAXM], nxt[MAXM], v[MAXM], cnt;

int dad[MAXN], son[MAXN], siz[MAXN], depth[MAXN], rt;
int id[MAXN], rak[MAXN], top[MAXN], dfx;

int tx[MAXN], ty[MAXN], tk[MAXN];

int n, m;

inline void Addline(int x, int y)
{
    v[cnt] = y;
    nxt[cnt] = head[x], head[x] = cnt++;
    return;
}

inline void Make(int x, int fa)
{
    dad[x] = fa, depth[x] = depth[fa] + 1, siz[x] = 1;

    for (register int i = head[x]; ~i; i = nxt[i])
        if (v[i] != fa)
        {
            Make(v[i], x);
            siz[x] += siz[v[i]];

            if (siz[son[x]] < siz[v[i]])
                son[x] = v[i];
        }

    return;
}

inline void Mark(int x, int tp)
{
    top[x] = tp, id[x] = ++dfx, rak[id[x]] = x;

    if (son[x])
        Mark(son[x], tp);

    for (register int i = head[x]; ~i; i = nxt[i])
        if (v[i] != dad[x] && v[i] != son[x])
            Mark(v[i], v[i]);

    return;
}

struct Interval
{
    int x, y;
} ITV[MAXN];

inline bool Compare(Interval a, Interval b)
{
    return a.x < b.x;
}

inline void Update(int x, int y, int key, int opt)
{
    register int tail = 0;
    while (top[x] != top[y])
    {
        if (depth[top[x]] < depth[top[y]])
            swap(x, y);

        ITV[++tail].x = id[top[x]];
        ITV[tail].y = id[x];
        x = dad[top[x]];
    }

    if (id[x] > id[y])
        swap(x, y);
    ITV[++tail].x = id[x];
    ITV[tail].y = id[y];

    sort(ITV + 1, ITV + tail + 1, Compare);

    register int pos = 1;
    for (register int i = 1; i <= tail; i++)
    {
        if (pos <= ITV[i].x - 1)
            ST.Update(1, n, 1, pos, ITV[i].x - 1, key, opt);
        pos = ITV[i].y + 1;
    }
    if (pos <= n)
        ST.Update(1, n, 1, pos, n, key, opt);

    return;
}

inline int Read()
{
    register char c = getchar();
    while (c < '0' || c > '9')
        c = getchar();

    register int x = 0;
    while (c >= '0' && c <= '9')
        x = (x << 3) + (x << 1) + c - '0', c = getchar();

    return x;
}

signed main(void)
{
    memset(head, -1, sizeof head);
    val[0] = -1;

    cin >> n >> m;
    for (register int i = 1; i < n; i++)
    {
        register int x = Read(), y = Read();
        Addline(x, y), Addline(y, x);
    }

    Make(rt = rand() % n + 1, 0), Mark(rt, rt);

    for (register int i = 1, opt, x, y, k, t; i <= m; i++)
    {
        opt = Read();

        if (opt == 0)
        {
            x = Read(), y = Read(), k = Read();
            Update(x, y, k, 1), tx[i] = x, ty[i] = y, tk[i] = k;
        }

        if (opt == 1)
        {
            t = Read();
            Update(tx[t], ty[t], tk[t], 0);
        }

        if (opt == 2)
        {
            x = Read();
            printf("%d\n", ST.Query(1, n, 1, id[x]));
        }
    }

    return 0;
}

```

码了250+行的树剖+树套树，一交竟然T了qwq。
卡了卡常也过不去qwq。
然后意识到FHQTreap或许常数太大了，加上本身就是3个$log$。。。

~~我们打开了题解~~发现并不需要用一颗平衡树维护，把平衡树换成两个大根堆，一个放添加的值，一个放删除的值。查询的时候先把两个堆的堆顶对比一些，如果相同说明这个值被删掉了，那么两个堆都弹掉。不相等时，添加的那个堆的堆顶就是最大值了（要注意一下堆空的问题）。

虽然复杂度没有变，但是常数小了很多，一发不开O2（实际上是忘了XD）就跑过了！（最大点1600ms）

这告诉我们FHQTreap的常数是有多大qwq

当然码的快的神犇们可以试试套一些常数小的平衡树qwq

## Code
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>
#include <vector>
using namespace std;

const int MAXN = 2e5 + 5, MAXM = MAXN << 1;

#define mid ((x + y) >> 1)
#define lson (pos << 1)
#define rson (pos << 1 | 1)

priority_queue<int> I[MAXN << 2], D[MAXN << 2];

struct SegmentTree
{
    inline void Update(int x, int y, int pos, int l, int r, int key, int opt)
    {
        if (y < l || x > r)
            return;
        if (l <= x && y <= r)
        {
            if (opt)
                I[pos].push(key);
            else
                D[pos].push(key);

            return;
        }

        Update(x, mid, lson, l, r, key, opt), Update(mid + 1, y, rson, l, r, key, opt);
        return;
    }

    inline int Query(int x, int y, int pos, int p)
    {
        while (!I[pos].empty() && !D[pos].empty() && I[pos].top() == D[pos].top())
            I[pos].pop(), D[pos].pop();
        int ans = I[pos].empty() ? -1 : I[pos].top();

        if (x != y)
        {
            if (p <= mid)
                return max(ans, Query(x, mid, lson, p));
            else
                return max(ans, Query(mid + 1, y, rson, p));
        }

        return ans;
    }

} ST;

int head[MAXM], nxt[MAXM], v[MAXM], cnt;

int dad[MAXN], son[MAXN], siz[MAXN], depth[MAXN], rt;
int id[MAXN], rak[MAXN], top[MAXN], dfx;

int tx[MAXN], ty[MAXN], tk[MAXN];

int n, m;

inline void Addline(int x, int y)
{
    v[cnt] = y;
    nxt[cnt] = head[x], head[x] = cnt++;
    return;
}

inline void Make(int x, int fa)
{
    dad[x] = fa, depth[x] = depth[fa] + 1, siz[x] = 1;

    for (register int i = head[x]; ~i; i = nxt[i])
        if (v[i] != fa)
        {
            Make(v[i], x);
            siz[x] += siz[v[i]];

            if (siz[son[x]] < siz[v[i]])
                son[x] = v[i];
        }

    return;
}

inline void Mark(int x, int tp)
{
    top[x] = tp, id[x] = ++dfx, rak[id[x]] = x;

    if (son[x])
        Mark(son[x], tp);

    for (register int i = head[x]; ~i; i = nxt[i])
        if (v[i] != dad[x] && v[i] != son[x])
            Mark(v[i], v[i]);

    return;
}

struct Interval
{
    int x, y;
} ITV[MAXN];

inline bool Compare(Interval a, Interval b)
{
    return a.x < b.x;
}

inline void Update(int x, int y, int key, int opt)
{
    register int tail = 0;
    while (top[x] != top[y])
    {
        if (depth[top[x]] < depth[top[y]])
            swap(x, y);

        ITV[++tail].x = id[top[x]];
        ITV[tail].y = id[x];
        x = dad[top[x]];
    }

    if (id[x] > id[y])
        swap(x, y);
    ITV[++tail].x = id[x];
    ITV[tail].y = id[y];

    sort(ITV + 1, ITV + tail + 1, Compare);

    register int pos = 1;
    for (register int i = 1; i <= tail; i++)
    {
        if (pos <= ITV[i].x - 1)
            ST.Update(1, n, 1, pos, ITV[i].x - 1, key, opt);
        pos = ITV[i].y + 1;
    }
    if (pos <= n)
        ST.Update(1, n, 1, pos, n, key, opt);

    return;
}

inline int Read()
{
    register char c = getchar();
    while (c < '0' || c > '9')
        c = getchar();

    register int x = 0;
    while (c >= '0' && c <= '9')
        x = (x << 3) + (x << 1) + c - '0', c = getchar();

    return x;
}

signed main(void)
{
    memset(head, -1, sizeof head);

    cin >> n >> m;
    for (register int i = 1; i < n; i++)
    {
        register int x = Read(), y = Read();
        Addline(x, y), Addline(y, x);
    }

    Make(rt = rand() % n + 1, 0), Mark(rt, rt);

    for (register int i = 1, opt, x, y, k, t; i <= m; i++)
    {
        opt = Read();

        if (opt == 0)
        {
            x = Read(), y = Read(), k = Read();
            Update(x, y, k, 1), tx[i] = x, ty[i] = y, tk[i] = k;
        }

        if (opt == 1)
        {
            t = Read();
            Update(tx[t], ty[t], tk[t], 0);
        }

        if (opt == 2)
        {
            x = Read();
            printf("%d\n", ST.Query(1, n, 1, id[x]));
        }
    }

    return 0;
}

```



---

## 作者：hl666 (赞：2)

woc国庆作业TMD终于写完了，然而明天我们班就开学了233

这题其实是昨天写的，然后昨天晚上被Atcoder的一道题卡住了很久~~（MD是B题）~~所以就没写博客

好吧我们来看这道题，理解题意以后相信你会以为我又再写**线段树分治**然后码出一个三个$\log$的东西

大致讲一下哈，还是套路地维护数据交互出现的时间区间在线段树上，然后考虑树剖出两点之间的路径区间（$\log n$个），然后它们的补集就是合法的区间，然后再拿一个**动态开点线段树**维护里面的最值即可，复杂度$O(n\log^3 n)$，代码极其难写（没写）

那么我们考虑有没有什么好一点的写法，仔细观察可以发现答案具有**二分性质**

即对于一个询问的二分的值$mid$，如果所有权值$\ge mid$的路径都经过了这个点，那么$mid$就不合法，否则就是可行的

然后我们又有了一个对于每个询问做一次的方法，结合上面的动态开点线段树又是一个$O(n\log^3 n)$的做法（还是没写）

但是我们仔细一想发现这种可离线的题目可以直接上**整体二分**，考虑每次二分的区间值$[l,r]$，我们把修改值在这个区间里的修改和确定了答案在这个区间里的询问放在一起，然后按时间顺序操作即可

最后对于所有路径经过这个点来说，可以在加入一条路径的时候把路径上的权值全部$+1$，然后查询这个点的点权是否等于路径条数即可

直接上树剖是三个$\log$的~~TMD和三个$\log$过不去~~，然后我们发现这个可以直接**树上差分**以后再DFS序上用**树状数组**统计，终于得到了现在的小常数$O(n\log n)$做法

PS：据说还有我没想到的动态开点线段树套堆的两个$\log$以及只有一个$\log$的神仙做法，我还是太弱了

```cpp
#include<cstdio>
#include<cctype>
#include<iostream>
#include<algorithm>
#define RI register int
#define CI const int&
#define Tp template <typename T>
using namespace std;
const int N=200005;
		static const int P=18;
struct event
{
	int opt,x,y,lca,v,id;
	friend inline bool operator < (const event& A,const event& B)
	{
		return A.id<B.id;
	}
}et[N],tp1[N],tp2[N]; int n,m,x,y,rst[N],tot;
struct edge
{
	int to,nxt;
}e[N<<1]; int head[N],cnt,ans[N],fir[N],lst[N],anc[N][P];
class FileInputOutput
{
	private:
		static const int S=1<<21;
		#define tc() (A==B&&(B=(A=Fin)+fread(Fin,1,S,stdin),A==B)?EOF:*A++)
		#define pc(ch) (Ftop!=Fend?*Ftop++=ch:(fwrite(Fout,1,S,stdout),*(Ftop=0)++=ch))
		char Fin[S],Fout[S],*A,*B,*Ftop,*Fend; int pt[15];
	public:
		FileInputOutput(void) { Ftop=Fout; Fend=Fout+S; }
		Tp inline void read(T& x)
		{
			x=0; char ch; while (!isdigit(ch=tc()));
			while (x=(x<<3)+(x<<1)+(ch&15),isdigit(ch=tc()));
		}
		Tp inline void write(T x)
		{
			if (x<0) pc('-'),x=-x; RI ptop=0; while (pt[++ptop]=x%10,x/=10);
			while (ptop) pc(pt[ptop--]+48); pc('\n');
		}
		inline void flush(void)
		{
			fwrite(Fout,1,Ftop-Fout,stdout);
		}
		#undef tc
		#undef pc
}F;
inline void addedge(CI x,CI y)
{
	e[++cnt]=(edge){y,head[x]}; head[x]=cnt;
	e[++cnt]=(edge){x,head[y]}; head[y]=cnt;
}
class Double_Increased_On_Tree
{
	private:
		int idx,dep[N];
		inline void reset(CI now)
		{
			for (RI i=0;i<P-1;++i) if (anc[now][i])
			anc[now][i+1]=anc[anc[now][i]][i]; else break;
		}
	public:
		#define to e[i].to
		inline void DFS(CI now=1,CI fa=0)
		{
			fir[now]=++idx; dep[now]=dep[fa]+1; anc[now][0]=fa; reset(now);
			for (RI i=head[now];i;i=e[i].nxt) if (to!=fa) DFS(to,now); lst[now]=idx;
		}
		#undef to
		inline int getlca(int x,int y)
		{
			RI i; if (dep[x]<dep[y]) swap(x,y); for (i=P-1;~i;--i)
			if (dep[anc[x][i]]>=dep[y]) x=anc[x][i]; if (x==y) return x;
			for (i=P-1;~i;--i) if (anc[x][i]!=anc[y][i])
			x=anc[x][i],y=anc[y][i]; return anc[x][0];
		}
}T;
class Tree_Array
{
	private:
		int bit[N];
	public:
		#define lowbit(x) x&-x
		inline void add(RI x,CI y)
		{
			for (;x<=n;x+=lowbit(x)) bit[x]+=y;
		}
		inline int get(RI x,int ret=0)
		{
			for (;x;x-=lowbit(x)) ret+=bit[x]; return ret;
		}
		#undef lowbit
}BIT;
inline void expand(const event& p,CI d)
{
	BIT.add(fir[p.x],d); BIT.add(fir[p.y],d); BIT.add(fir[p.lca],-d);
	if (anc[p.lca][0]) BIT.add(fir[anc[p.lca][0]],-d);
}
inline void solve(CI st=1,CI ed=m,CI l=0,CI r=tot)
{
	RI i,ct1=0,ct2=0; int mid=l+r+1>>1,cur=0; if (l==r)
	{
		if (l) for (i=st;i<=ed;++i) if (et[i].opt==2)
		ans[et[i].id]=rst[l]; return;
	}
	for (i=st;i<=ed;++i) switch (et[i].opt)
	{
		case 0:
			if (et[i].v<mid) tp1[++ct1]=et[i]; else tp2[++ct2]=et[i],expand(et[i],1),++cur; break;
		case 1:
			if (et[i].v<mid) tp1[++ct1]=et[i]; else tp2[++ct2]=et[i],expand(et[i],-1),--cur; break;
		case 2:
			if (BIT.get(lst[et[i].x])-BIT.get(fir[et[i].x]-1)==cur)
			tp1[++ct1]=et[i]; else tp2[++ct2]=et[i]; break;
	}
	for (i=st;i<=ed;++i) if (et[i].opt!=2&&et[i].v>=mid) expand(et[i],et[i].opt?1:-1);
	for (i=1;i<=ct1;++i) et[st+i-1]=tp1[i]; for (i=1;i<=ct2;++i) et[st+ct1+i-1]=tp2[i];
	solve(st,st+ct1-1,l,mid-1); solve(st+ct1,ed,mid,r);
}
int main()
{
	//freopen("CODE.in","r",stdin); freopen("CODE.out","w",stdout);
	RI i; for (F.read(n),F.read(m),i=1;i<n;++i)
	F.read(x),F.read(y),addedge(x,y);
	for (T.DFS(),i=1;i<=m;++i)
	{
		F.read(et[i].opt); et[i].id=i;
		switch (et[i].opt)
		{
			case 0:
				F.read(et[i].x); F.read(et[i].y); F.read(et[i].v);
				et[i].lca=T.getlca(et[i].x,et[i].y); rst[++tot]=et[i].v; break;
			case 1:
				F.read(x); et[i]=et[x]; et[i].opt=1; et[i].id=i; break;
			case 2:
				F.read(et[i].x); ans[i]=-1; break;
		}
	}
	sort(rst+1,rst+tot+1); tot=unique(rst+1,rst+tot+1)-rst-1;
	for (i=1;i<=m;++i) if (et[i].opt!=2) et[i].v=lower_bound(rst+1,rst+tot+1,et[i].v)-rst;
	for (solve(),sort(et+1,et+m+1),i=1;i<=m;++i) if (et[i].opt==2) F.write(ans[i]);
	return F.flush(),0;
}
```

---

## 作者：never_see (赞：2)

这是一个要开O2的TJ

强行树链剖分

强行在每个点上维护两个大根堆

一个表示进入的，一个表示删除的

堆顶相同则删掉

每一次删掉或添加一个网络将所有不再该网络上的点的堆中添加当前的网络

然后卡过


```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;

template <typename Type> inline void Read( Type &in ){
    in=0;char ch=getchar();Type f=1;
    for(;ch> '9'||ch< '0';ch=getchar())if(ch=='-')f=-1;
    for(;ch>='0'&&ch<='9';ch=getchar())in=in*10+ch-'0';in*=f;
}

static const int MAXN = 1e5 +1;
static const int MAXM = MAXN<<1;

int n,m,Num,Ct,u,v,Opt,k,Ans;
int Nt[MAXM],H[MAXN],To[MAXM];
int Qu[MAXM],Qv[MAXM],Qw[MAXM];
int Size[MAXN],Top[MAXN],Son[MAXN],Rank[MAXN],Fa[MAXN],Dep[MAXN];

inline void Ins( int From,int _To ){
    Nt[++Num] = H[From];
    H[From] = Num;
    To[Num] = _To;
}

inline void Dfs1( int A ){
    Size[A] = 1;
    for( int i=H[A];i;i=Nt[i] ){
        int B = To[i];if( Fa[A]==B )continue;
        Fa[B] = A;Dep[B] = Dep[A] +1;
        Dfs1( B );
        Size[A] += Size[B];
        if( Size[B]>=Size[Son[A]] ) Son[A] = B;
    }
}

inline void Dfs2( int A,int Chain ){
    Rank[A] = ++Ct;
    Top [A] = Chain;
    if( Son[A] ) Dfs2( Son[A],Chain );
    for( int i=H[A];i;i=Nt[i] )
        if( To[i]!=Fa[A]&&To[i]!=Son[A] )
            Dfs2( To[i],To[i] );
}

struct Segment_Tree{
    priority_queue< int > Ext[2];
    inline int Get(){
        for( ;!Ext[0].empty()&&!Ext[1].empty()&&Ext[0].top()==Ext[1].top();Ext[0].pop(),Ext[1].pop());
        if( Ext[0].empty() ) return -1;
        return Ext[0].top();
    }
}Max[MAXN<<2];

inline void MF( int Nd,int l,int r,int s,int t,int w ){
    if( l>=s&&r<=t ){
        Max[Nd].Ext[Opt].push( w );
        return;
    }
    int Mid = ( l+r )>>1;
    if( Mid>=s )MF( Nd<<1,l,Mid,s,t,w );if( Mid<t )MF( Nd<<1|1,Mid+1,r,s,t,w );
}

inline void Query( int Nd,int l,int r,int s ){
    Ans = max( Ans,Max[Nd].Get() );
    if( l==r )return;
    int Mid = ( l+r )>>1;
    if( Mid>=s ) Query( Nd<<1,l,Mid,s );
    else Query( Nd<<1|1,Mid+1,r,s );
}

struct QUE{
    int l,r;
    inline bool operator < (QUE T)const{return l<T.l;}
}Que[MAXN];

inline void Solve( int A,int B,int C ){
    int Cnt = 0;
    while( Top[A]!=Top[B] ){
        if( Dep[Top[A]]<Dep[Top[B]] )A^=B^=A^=B;
        Que[++Cnt].l=Rank[Top[A]];Que[Cnt].r=Rank[A];
        A = Fa[Top[A]];
    }
    if( Rank[A]>Rank[B] )A^=B^=A^=B;
    Que[++Cnt].l=Rank[A];Que[Cnt].r=Rank[B];
    sort( Que+1,Que+1+Cnt );
    for( int i=1;i<=Cnt;i++ )if( Que[i-1].r+1<=Que[i].l-1 ) MF( 1,1,n,Que[i-1].r+1,Que[i].l-1,C );
    if( Que[Cnt].r+1<=n ) MF( 1,1,n,Que[Cnt].r+1,n,C );
}

int main(){
    
    Read( n );Read( m );
    for( int i=1;i< n;i++ )Read( u ),Read( v ),Ins( u,v ),Ins( v,u );
    Dfs1( 1 );Dfs2( 1,0 );
    for( int i=1;i<=m;i++ ){
        Read( Opt );
        switch( Opt ){
            case 0:Read( Qu[i] );Read( Qv[i] );Read( Qw[i] );Solve( Qu[i],Qv[i],Qw[i] );break;
            case 1:Read( u );Solve( Qu[u],Qv[u],Qw[u] );break;
            case 2:Read( u );Ans=-1;Query( 1,1,n,Rank[u] );printf("%d\n",Ans);break;
        }
    }
    return 0;
}```

---

## 作者：7KByte (赞：1)

很久没打整体二分，发现自己居然没有忘记……

这里提供一个跑的比大多数题解快的$\operatorname{O(N\ log^3\ N)}$做法。

首先树链剖分，将链上操作转化为序列操作。由于是区间修改单点查询，所以我们用树状数组代替线段树。

对于$m$个操作我们用整体二分。对于每个大于$mid$的请求，我们将链上的所有点权值加$1$。同理，撤回操作就是减一。查询时，查询该点的权值，如果权值小于当前所有存在的请求数，说明有大于$mid$的请求不经过该点，将它塞到右边。否则将它塞到左边。

至于其他的，直接套【模板】树链剖分+【模板】树状数组2+【模板】整体二分。


最后贴下代码。


树状数组、树剖、二分的常数都很小，所以实践证明效率非常优秀[记录](https://www.luogu.com.cn/record/34428938)


```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define N 100005
#define M 200005
using namespace std;
int n,m,h[N],tot;
struct edge{
	int to,nxt;
}e[N<<1];
void add(int x,int y){
	e[++tot].nxt=h[x];h[x]=tot;e[tot].to=y;
}
int idx,dfn[N],sz[N],son[N],top[N],fa[N],d[N];
void dfs1(int x,int f){
	sz[x]=1;fa[x]=f;d[x]=d[f]+1;
	for(int i=h[x];i;i=e[i].nxt)if(e[i].to^f){
		dfs1(e[i].to,x),sz[x]+=sz[e[i].to];
		if(sz[e[i].to]>sz[son[x]])son[x]=e[i].to;
	}
}
void dfs2(int x,int tp){
	dfn[x]=++idx;top[x]=tp;
	if(!son[x])return;
	dfs2(son[x],tp);
	for(int i=h[x];i;i=e[i].nxt)if(e[i].to^fa[x]&&e[i].to^son[x])dfs2(e[i].to,e[i].to);
}
int c[N];
inline void addval(int x,int y){
	for(;x<=n;x+=x&-x)c[x]+=y;
}
inline int ask(int x){
	int sum=0;
	for(;x;x-=x&-x)sum+=c[x];
	return sum;
}
inline void change(int l,int r,int val){
	addval(l,val);addval(r+1,-val);
}
inline void modify(int x,int y,int val){
	while(top[x]^top[y]){
		if(d[top[x]]<d[top[y]])swap(x,y);
		change(dfn[top[x]],dfn[x],val),x=fa[top[x]];
	}
	if(d[x]>d[y])swap(x,y);
	change(dfn[x],dfn[y],val);
}
struct node{
	int op,x,y,val;
}a[M],lt[M],rt[M];
int b[M],o[M],t,T,cnt,ans[M];
void solve(int ls,int rs,int l,int r){
	if(l==r){
		rep(i,ls,rs)if(a[i].op>0)ans[a[i].op]=l;
		return;
	}
	int mid=(l+r)>>1,ll=0,rr=0,s=0;
	rep(i,ls,rs){
		if(a[i].op>0){
			int sum=ask(dfn[a[i].x]);
			if(sum^s)rt[++rr]=a[i];else lt[++ll]=a[i];
		}
		else if(a[i].op){
			if(a[i].val>mid)modify(a[i].x,a[i].y,-1),rt[++rr]=a[i],s--;
			else lt[++ll]=a[i];
		}
		else{
			if(a[i].val>mid)modify(a[i].x,a[i].y,1),rt[++rr]=a[i],s++;
			else lt[++ll]=a[i];
		}
	}
	rep(i,1,rr)if(rt[i].op==0){
		if(rt[i].val>mid)modify(rt[i].x,rt[i].y,-1);
	}
	else if(rt[i].op==-1&&rt[i].val>mid)modify(rt[i].x,rt[i].y,1);
	rep(i,1,ll)a[ls+i-1]=lt[i];rep(i,1,rr)a[ls+ll+i-1]=rt[i];
	solve(ls,ls+ll-1,l,mid);solve(ls+ll,rs,mid+1,r);
}
int main(){
	scanf("%d%d",&n,&m);
	int x,y;
	rep(i,1,n-1)scanf("%d%d",&x,&y),add(x,y),add(y,x);
	dfs1(1,0);dfs2(1,1);
	
	rep(i,1,m){
		scanf("%d%d",&a[i].op,&a[i].x);
		if(a[i].op==0)scanf("%d%d",&a[i].y,&a[i].val),o[++t]=a[i].val;
	}
	sort(o+1,o+t+1);
	rep(i,1,t)if(i==1||o[i]^o[i-1])b[++T]=o[i];
	rep(i,1,m){
		if(a[i].op==0)a[i].val=lower_bound(b+1,b+T+1,a[i].val)-b;
		else if(a[i].op==1)a[i]=a[a[i].x],a[i].op=-1;
		else a[i].op=++cnt;
	}
	solve(1,m,0,T);
	b[0]=-1;
	rep(i,1,cnt)printf("%d\n",b[ans[i]]);
	return 0;
} 
```

---

## 作者：chen_qian (赞：0)

线段树上二分好题。本题解思路大致与[大佬Freopen](https://www.luogu.com.cn/user/30037)相同，但代码实现略有不同，如果有不太习惯 zkw 线段树的同学可以来看看我的代码，因为这道题确实细节不少，特别是线段树二分的部分。

首先，我们来考虑一个暴力的思路，对于全局维护一个堆，插入删除操作都能被很好支持，唯独询问操作时，我们只能不断取出堆顶，判断询问点在在不在路径上。这样的暴力很容易被卡成 $O(n^2\ \log\ n)$。

这样的暴力思路给了我们一个启示，我们需要找的是一个排好序的序列中，第一个满足条件的点。那么我们是不是能考虑转换成二分答案的问题呢？

显然是可以的，那么剩下的任务就是如何判定一个点是不是在一些点对的路径并上。另外，我们还要支持动态的加入和删除路径。

能够动态增删和排序的，只有堆，平衡树和值域线段树。前两者不好维护前缀信息，我们选择值域线段树。

我们将所有点对的权值离散化，相同的权值就更具时间先后分开。那么我们最后的问题就是如何左右有两个区间的路径求并。

假如当前有 $(x,y)$ 和 $(u,v)$ 两条树上路径。那么这四个点两两组合四种情况的 lca 中，最深的两个如果不相等，呢么这两个点就是路径的交，如果相等，再判断是不是在路径上即可。

$O(1)$ 求 lca 能够将合并优化到 $O(\log\ n)$。但是这里会有一边没有的情况，鉴于我们之后要使用线段树上二分，我们记录一个 $tag_p$ ,表示线段树上节点 $p$ 所对应的区间有没有点对。合并时，假如两边都为空，那么当前节点为空，假如两边有一边为空，那么继承不为空的一段，假如两边都不为空，但路径没有交，那么端点记为 $0$。

判断的时候，只要右节点不为空且右节点的两个端点为 $0$ 或当前点不在路径并上，那么往右边走，否则向左。

线段树上二分，一定要保证查找的区间一定有解，才往那边递归。

```
#include<bits/stdc++.h>
#define N 200005
using namespace std;
int n,m,head[N],idx,dep[N],dfn[N*2],rev[N],cnt,fa[N];
int st[N][30];
struct edge{
	int v,next;
}e[2*N];
void add(int u,int v){
	e[++idx].v=v;
	e[idx].next=head[u];
	head[u]=idx;
}
void dfs(int x,int f){
	fa[x]=f;
	dep[x]=dep[f]+1;
	dfn[++cnt]=x;
	rev[x]=cnt;
	for(int i=head[x];i;i=e[i].next){
		int y=e[i].v;
		if(y==f) continue;
		dfs(y,x);
		dfn[++cnt]=x;
	}
}
void prework(){
	int t=log(cnt)/log(2);
	for(int i=1;i<=cnt;i++) st[i][0]=dfn[i];
	for(int j=1;j<=t;j++){
		for(int i=1;i<=cnt-(1<<j)+1;i++){
			if(dep[st[i][j-1]]>dep[st[i+(1<<(j-1))][j-1]]) st[i][j]=st[i+(1<<(j-1))][j-1];
			else st[i][j]=st[i][j-1];
		}
	}
}
int LCA(int x,int y){
	int l=rev[x],r=rev[y];
	if(l>r) swap(l,r);
	int k=log(r-l+1)/log(2);
	int lca;
	if(dep[st[l][k]]<dep[st[r-(1<<k)+1][k]]) lca=st[l][k];
 	else lca=st[r-(1<<k)+1][k];
 	return lca;
}
int num=0;
struct path{
	int x,y,z,id;
}p[N];
bool cmp(path x,path y){
	if(x.z!=y.z) return x.z<y.z;
	return x.id<y.id;
} 
struct node{
	int op,x,y,z;
}opt[N];
int back[N];
int tag[N<<2],s[N<<2],t[N<<2];
bool cmp1(int x,int y){
	return dep[x]>dep[y];
}
void push_up(int p){
	if(!tag[p<<1]&&!tag[p<<1|1]){
		tag[p]=0;
		return ;
	}
	tag[p]=1;
	if(!tag[p<<1]){
		s[p]=s[p<<1|1];
		t[p]=t[p<<1|1];
		return ;
	}
	if(!tag[p<<1|1]){
		s[p]=s[p<<1];
		t[p]=t[p<<1];
		return ;
	}
	int w[5];
	w[1]=LCA(s[p<<1],s[p<<1|1]),w[2]=LCA(t[p<<1],t[p<<1|1]),w[3]=LCA(s[p<<1],t[p<<1|1]),w[4]=LCA(s[p<<1|1],t[p<<1]);
	sort(w+1,w+5,cmp1);
	if(w[1]!=w[2]) s[p]=w[1],t[p]=w[2];
	else if(w[1]==LCA(s[p<<1],t[p<<1])||w[1]==LCA(s[p<<1|1],t[p<<1|1])) s[p]=t[p]=w[1];
	else s[p]=t[p]=0;
	return ;
}
void modify(int p,int l,int r,int x,int u,int v){
	if(l==r){
		tag[p]=1;
		s[p]=u;
		t[p]=v;
		return ;
	}
	int mid=(l+r)>>1;
	if(x<=mid) modify(p<<1,l,mid,x,u,v);
	else modify(p<<1|1,mid+1,r,x,u,v);
	push_up(p); 
}
void del(int p,int l,int r,int x){
	if(l==r){
		tag[p]=0;
		s[p]=0;
		t[p]=0;
		return ;
	}
	int mid=(l+r)>>1;
	if(x<=mid) del(p<<1,l,mid,x);
	else del(p<<1|1,mid+1,r,x);
	push_up(p);
}
bool check(int u,int v,int x){
	if(!u&&!v) return true;
	int lca=LCA(u,v);
	if(LCA(x,lca)!=lca) return true;
	if(LCA(u,x)!=x&&LCA(v,x)!=x) return true;
	return false;
}
int query(int p,int l,int r,int x){
	if(!tag[p]) return -1;
	while(l!=r){
		int mid=(l+r)>>1;
		if(tag[p<<1|1]&&check(s[p<<1|1],t[p<<1|1],x)){
			p=p*2+1;
			l=mid+1;
		}
		else{
			p<<=1;
			r=mid;
		}
	}
	if(!tag[p]||!check(s[p],t[p],x)) return -1;
	return l;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<n;i++){
		int u,v;
		scanf("%d%d",&u,&v);
		add(u,v);
		add(v,u);
	}	
	dfs(1,0);
	prework();
	for(int i=1;i<=m;i++){
		scanf("%d%d",&opt[i].op,&opt[i].x);
		if(opt[i].op==0){
			scanf("%d%d",&opt[i].y,&opt[i].z);
			p[++num].x=opt[i].x;
			p[num].y=opt[i].y;
			p[num].z=opt[i].z;
			p[num].id=i;
		}
	}
	sort(p+1,p+num+1,cmp);
	for(int i=1;i<=num;i++){
		back[i]=p[i].z;
		opt[p[i].id].z=i;
	}
	for(int i=1;i<=m;i++){
		if(opt[i].op==0) modify(1,1,num,opt[i].z,opt[i].x,opt[i].y);
		if(opt[i].op==1) del(1,1,num,opt[opt[i].x].z);
		if(opt[i].op==2){
			int ans=query(1,1,num,opt[i].x);
			if(ans==-1) puts("-1");
			else printf("%d\n",back[query(1,1,num,opt[i].x)]);
		}
	}
	return 0;
}

```


---


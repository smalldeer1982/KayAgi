# 遥远的国度

## 题目描述

`zcwwzdjn` 在追杀 `zhx` ，而 `zhx` 逃入了一个遥远的国度。当 `zcwwzdjn` 准备进入遥远的国度继续追杀时，守护神 `RapiD` 阻拦了 `zcwwzdjn` 的去路，他需要 `zcwwzdjn` 完成任务后才能进入遥远的国度继续追杀。

问题是这样的：遥远的国度有 $n$ 个城市，这些城市之间由一些路连接且这些城市构成了一颗树。这个国度有一个首都，我们可以把这个首都看做整棵树的根，但遥远的国度比较奇怪，首都是随时有可能变为另外一个城市的。遥远的国度的每个城市有一个防御值，第 $i$ 个的防御值为 $val_i$，有些时候 `RapiD` 会使得某两个城市之间的路径上的所有城市的防御值都变为某个值。

`RapiD` 想知道在某个时候，如果把首都看做整棵树的根的话，那么以某个城市为根的子树的所有城市的防御值最小是多少。

由于 `RapiD` 无法解决这个问题，所以他拦住了 `zcwwzdjn` 希望他能帮忙。但 `zcwwzdjn` 还要追杀 `zhx`，所以这个重大的问题就被转交到了你的手上。

## 说明/提示

对于 $20\%$ 的数据，$n\le 1000,m\le 1000$。

对于另外 $10\%$ 的数据，$n\le 100000,m\le 100000$，保证修改为单点修改。

对于另外 $10\%$ 的数据，$n\le100000,m \le 100000$，保证树为一条链。

对于另外 $10\%$ 的数据，$n\le 100000,m\le100000$，没有修改首都的操作。

对于 $100\%$ 的数据，$1 \leq n\le 100000,1 \leq m \le 100000,0<val_i<2^{31}$。

## 样例 #1

### 输入

```
3 7
1 2
1 3
1 2 3
1
3 1
2 1 1 6
3 1
2 2 2 5
3 1
2 3 3 4
3 1```

### 输出

```
1
2
3
4```

# 题解

## 作者：寒酥 (赞：50)

树剖换根啊,,zz的我zz的请教lxl,大师拍案大笑,不语,少顷,我大呼:"我是zz!"呵呵,太尴尬了...

+ 记当前根为rt,查询节点u,换根无非三种情况:
	+ 1:u==rt,return minn[1];
	+ 2:u不是rt的祖先,即u不在1->rt这条路径上,无所谓,直接按u为根的子树返回
	+ 3:u是rt的祖先,即u在1->rt这条路径上,**最特殊的情况**

主要就是第3种嘛,其实也很好想

*找到路径u->rt上的u的直系儿子v*,

就会发现rt为根时,u子树覆盖不到的地方是**v及v的子树**	

那么我们就可以把那一段抠出来,因为**子树的重儿子序一定是连续的嘛!**之后计算剩余部分就可以了
```cpp
#include<bits/stdc++.h>
#define INF 0x7fffffff
#define lson l,m,rt<<1
#define rson m+1,r,rt<<1|1
using namespace std;
const int N=1e5+5;
int rt,n,m,dep[N],f[N],num[N],son[N],top[N],tpos[N],pre[N],tot,cnt,bj[N<<2],minn[N<<2],first[N],w[N];
struct edge{int nt,to;}e[N<<1];
void add(int u,int v){e[++cnt]=(edge){first[u],v};first[u]=cnt;}
void dfs1(int u,int fa)
{
	num[u]=1;
	for(int i=first[u];i;i=e[i].nt)
	{
		int v=e[i].to;
		if(v==fa) continue;
		f[v]=u,dep[v]=dep[u]+1;
		dfs1(v,u);
		num[u]+=num[v];
		if(num[v]>num[son[u]]) son[u]=v;
	}
}
void dfs2(int u,int tp)
{
	top[u]=tp,tpos[u]=++tot,pre[tot]=u;
	if(son[u]) dfs2(son[u],tp);
	for(int i=first[u];i;i=e[i].nt)
	{
		int v=e[i].to;
		if(v==f[u]||v==son[u]) continue;
		dfs2(v,v);
	}
}
void pushup(int rt){minn[rt]=min(minn[rt<<1],minn[rt<<1|1]);}
void pushdown(int rt)
{
	if(bj[rt])
	{
		bj[rt<<1]=bj[rt<<1|1]=bj[rt];
		minn[rt<<1]=minn[rt<<1|1]=bj[rt];
		bj[rt]=0;
	}
}
void build(int l,int r,int rt)
{
	if(l==r)
	{
		minn[rt]=w[pre[l]];
		return;
	}
	int m=(l+r)>>1;
	build(lson),build(rson);
	pushup(rt);
}
void modify(int l,int r,int rt,int nowl,int nowr,int c)
{
	if(nowl<=l&&r<=nowr)
	{
		minn[rt]=bj[rt]=c;
		return;
	}
	int m=(l+r)>>1;
	pushdown(rt);
	if(nowl<=m) modify(lson,nowl,nowr,c);
	if(nowr>m) modify(rson,nowl,nowr,c);
	pushup(rt);
}
int query(int l,int r,int rt,int nowl,int nowr)
{
	if(nowl<=l&&r<=nowr) return minn[rt];
	int m=(l+r)>>1,ans=INF;
	pushdown(rt);
	if(nowl<=m) ans=min(ans,query(lson,nowl,nowr));
	if(nowr>m) ans=min(ans,query(rson,nowl,nowr));
	pushup(rt);
	return ans;
}
void chain_modify(int u,int v,int w)
{
	while(top[u]!=top[v])
	{
		if(dep[top[u]]<dep[top[v]]) swap(u,v);
		modify(1,n,1,tpos[top[u]],tpos[u],w);
		u=f[top[u]];
	}
	if(dep[u]>dep[v]) swap(u,v);
	modify(1,n,1,tpos[u],tpos[v],w);
}
int find(int u)
{
	if(u==rt) return -1;
	if(tpos[u]>=tpos[rt]||tpos[u]+num[u]-1<tpos[rt]) return 0;
	int now=rt;
	while(top[now]!=top[u])
	{
		if(f[top[now]]==u) return top[now];
		now=f[top[now]];
	}
	return son[u];
}
int tree_query(int u)
{
	int bo=find(u);
	if(bo==-1) return minn[1];
	if(bo==0) return query(1,n,1,tpos[u],tpos[u]+num[u]-1);
	else
	{
		int ans=query(1,n,1,1,tpos[bo]-1);
		if(tpos[bo]+num[bo]-1!=n) ans=min(ans,query(1,n,1,tpos[bo]+num[bo],n));
		return ans;
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1,u,v;i<n;++i) scanf("%d%d",&u,&v),add(u,v),add(v,u);
	for(int i=1;i<=n;++i) scanf("%d",&w[i]);
	dfs1(1,0),dfs2(1,1),build(1,n,1);
	scanf("%d",&rt);
	for(int i=1,bo,u,v,w;i<=m;++i)
	{
		scanf("%d",&bo);
		if(bo==1) scanf("%d",&rt);
		if(bo==2) scanf("%d%d%d",&u,&v,&w),chain_modify(u,v,w);
		if(bo==3) scanf("%d",&u),printf("%d\n",tree_query(u));
	}
	return 0;
}
```

---

## 作者：Farkas_W (赞：36)

$$\text{前言}$$

$\quad$可以看看我的一篇blog[关于树链剖分"换根操作"笔记](https://www.luogu.com.cn/blog/Farkas/guan-yu-shu-lian-pou-fen-huan-gen-cao-zuo-bi-ji)(内容都差不多)

$\quad$另外洛谷上还有一道关于换根操作的题目：[CF916E Jamie and Tree](https://www.luogu.com.cn/problem/CF916E)([我的题解](https://www.luogu.com.cn/blog/Farkas/solution-cf916e))

$$\text{关于题目要求的操作}$$

1. 换根，直接换即可

2. 路径修改，就和普通树剖一样。

3. 子树修改，这个需要分类讨论。(下面会细讲)

![](https://cdn.luogu.com.cn/upload/image_hosting/gmu2iblr.png))

$$\text{换根}$$

$\quad$因为每换一次根，树中的很多信息都会改变，不可能每次换根都跑两便 $dfs$ 预处理，所以我们考虑其他方法，对于单纯的换根操作，只需要设置一个全局变量 $root$ 来存储根的编号( $root$ 初始化为 $1$ ，默认以 $1$ 为根)，对于其他操作，再通过分类讨论 $root$ 的位置来进行操作。

$$\text{子树修改(查询)}$$

![](https://cdn.luogu.com.cn/upload/image_hosting/4ar4m3w5.png)

$\quad$ 情况 $1$ ：当 $x=root$ 时， $x$ 就是此时整棵树的根，那么就是全局修改(查询)。

$\quad$ 情况 $2$ ：当 $root$ 在x子树中时，就需要特别判断了，根据图像我们可以发现此时x的真正子树是包括除了 $root$ 方向上的子树之外其他所有节点。

$\quad$ 对于求最小值，需要去除root这颗子树上的范围，所以我打了一个特别的线段树查询，另外还需要一个find操作来寻找x中root所在的儿子节点。
```cpp
il int query2(int k,int l,int r,int x,int y)
{
  if(l>y||r<x)return sum[k];
  if(x<=l&&y>=r)return inf;
  int mid=l+r>>1,res=inf;
  if(c[k])pushdown(k,l,r,mid);
  res=min(res,query2(k<<1,l,mid,x,y));
  res=min(res,query2(k<<1|1,mid+1,r,x,y));
  return res;
}
il int find(int x,int y)
{
  int fx=top[x],fy=top[y];
  while(fx!=fy)
    {
      if(dep[fx]<dep[fy])swap(x,y),swap(fx,fy);
      if(father[fx]==y)return top[x];
      x=father[fx];fx=top[x];
    }
  if(dep[x]>dep[y])swap(x,y);
  return son[x];
}
il int query1(int x)
{
  int res=0;
  if(x==root){return query(1,1,n,1,n);}
  if(seg[root]>=seg[x]&&seg[root]<=seg[x]+size[x]-1){//判断root在x的子树中
    int y=find(x,root);
    res=query2(1,1,n,seg[y],seg[y]+size[y]-1);
    return res;
  }
  return query(1,1,n,seg[x],seg[x]+size[x]-1);
}
```

$\quad$ 情况 $3$ ：其他情况下 $x$ 的子树以 $root$ 为根和以 $1$ 为根是一样的。


$$\text{完整代码}$$

```cpp

#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<stack>
using namespace std;
#define int long long
#define next neee
#define re register int
#define il inline
#define inf 1e18
il int read()
{
	int x=0,f=1;char ch=getchar();
    while(!isdigit(ch)&&ch!='-')ch=getchar();
    if(ch=='-')f=-1,ch=getchar();
    while(isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
    return x*f;}
il void print(int x)
{
	if(x<0)putchar('-'),x=-x;
    if(x/10)print(x/10);
    putchar(x%10+'0');}
const int N=1e6+5;
int n,m,next[N<<1],go[N<<1],head[N],tot,a[N],top[N],root;
int sum[N<<2],seg[N],rev[N],son[N],size[N],dep[N],father[N],c[N<<2];
il void Add(int x,int y)
{next[++tot]=head[x];head[x]=tot;go[tot]=y;}
il void dfs1(int x,int fa)
{
  father[x]=fa;dep[x]=dep[fa]+1;size[x]=1;
  for(re i=head[x],y;i,y=go[i];i=next[i])
    {
      if(y==fa)continue;
      dfs1(y,x);
      size[x]+=size[y];
      if(size[y]>size[son[x]])son[x]=y;
    }
}
il void dfs2(int x,int topf)
{
  top[x]=topf;seg[x]=++seg[0];rev[seg[x]]=x;
  if(!son[x])return;
  dfs2(son[x],topf);
  for(re i=head[x],y;i,y=go[i];i=next[i])
    {
      if(top[y])continue;
      dfs2(y,y);
    }
}
il void build(int k,int l,int r)//建树
{
  if(l==r){sum[k]=a[rev[l]];return;}
  int mid=l+r>>1;
  build(k<<1,l,mid);build(k<<1|1,mid+1,r);
  sum[k]=min(sum[k<<1],sum[k<<1|1]);
}
il void ADD(int k,int l,int r,int v){sum[k]=c[k]=v;}//修改
il void pushdown(int k,int l,int r,int mid)//下传懒标记
{
  if(l==r){c[k]=0;return;}
  ADD(k<<1,l,mid,c[k]);ADD(k<<1|1,mid+1,r,c[k]);
  c[k]=0;}
il void change1(int k,int l,int r,int x,int y,int z)//区间修改
{
  if(x<=l&&y>=r){ADD(k,l,r,z);return;}
  int mid=l+r>>1;
  if(c[k])pushdown(k,l,r,mid);
  if(x<=mid)change1(k<<1,l,mid,x,y,z);
  if(y>mid)change1(k<<1|1,mid+1,r,x,y,z);
  sum[k]=min(sum[k<<1],sum[k<<1|1]);
}
il int query(int k,int l,int r,int x,int y)//区间询问
{
  if(x<=l&&y>=r)return sum[k];
  int mid=l+r>>1,res=inf;
  if(c[k])pushdown(k,l,r,mid);
  if(x<=mid)res=query(k<<1,l,mid,x,y);
  if(y>mid)res=min(res,query(k<<1|1,mid+1,r,x,y));
  return res;
}
il int query2(int k,int l,int r,int x,int y)//特殊的区间询问
{
  if(l>y||r<x)return sum[k];
  if(x<=l&&y>=r)return inf;
  int mid=l+r>>1,res=inf;
  if(c[k])pushdown(k,l,r,mid);
  res=min(res,query2(k<<1,l,mid,x,y));
  res=min(res,query2(k<<1|1,mid+1,r,x,y));
  return res;
}
il int find(int x,int y)//找root所在的儿子
{
  int fx=top[x],fy=top[y];
  while(fx!=fy)
    {
      if(dep[fx]<dep[fy])swap(x,y),swap(fx,fy);
      if(father[fx]==y)return top[x];
      x=father[fx];fx=top[x];
    }
  if(dep[x]>dep[y])swap(x,y);
  return son[x];
}
il void change2(int x,int y,int z)//路径修改
{
  int fx=top[x],fy=top[y];
  while(fx!=fy)
    {
      if(dep[fx]<dep[fy])swap(x,y),swap(fx,fy);
      change1(1,1,n,seg[fx],seg[x],z);
      x=father[fx];fx=top[x];
    }
  if(dep[x]>dep[y])swap(x,y);
  change1(1,1,n,seg[x],seg[y],z);
}
il int query1(int x)//子树修改
{
  int res=0;
  if(x==root){return query(1,1,n,1,n);}
  if(seg[root]>=seg[x]&&seg[root]<=seg[x]+size[x]-1){
    int y=find(x,root);
    res=query2(1,1,n,seg[y],seg[y]+size[y]-1);
    return res;
  }
  return query(1,1,n,seg[x],seg[x]+size[x]-1);
}
signed main()
{
  n=read();m=read();
  for(re i=1;i<n;i++){re x=read(),y=read();Add(x,y);Add(y,x);}
  for(re i=1;i<=n;i++)a[i]=read();
  root=read();dfs1(root,0);dfs2(root,root);build(1,1,n);
  while(m--)
    {
      re k=read();
      if(k==1)root=read();
      if(k==2){re x=read(),y=read(),z=read();change2(x,y,z);}
      if(k==3){re x=read();print(query1(x));putchar('\n');}
    }
  return 0;
}

```

$\quad$ 以上就是全部内容了，写题解不易，不妨点个赞吧！

---

## 作者：Genius_Z (赞：15)

做完这题想必会对$LCT$有一个新的认识吧。

曾经有人说过树剖能做的题$LCT$都能做（虽然可能会很麻烦）

先看这题的操作：

- 换根
- 链修改
- 子树求最小值

若没有$3$操作显然优先考虑$LCT$。

那如何处理$3$操作呢

我们考虑分开处理子树与链的贡献，记子树的最小值为$ts$，链的最小值为$tc$

那么显然$min(ts,tc)$即为所求

链的最小值非常好处理，就是$LCT$的板子，不多加赘述了

主要考虑子树的贡献

考虑与每个节点相连的边，不是实边就是虚边，实边的信息由链处理了。

那么我们要考虑的只有虚边，由记录虚子树的做法，我们可以联想到用某种东西维护虚子树

支持插入，删除，维护最小值的数据结构，当然是平衡树了

这里偷懒使用了$multiset$（第一遍$splay$写挂了，写了200+行，又丑又长）

注意本题最大的细节就在于对于根的处理，由于链修改会换根，所以需要在链修改后把根换回来

用一个变量记录当前的根，每次操作后$makeroot$

code：（码风应该还算正常）

```cpp
#include <map>
#include <set>
#include <cmath>
#include <queue>
#include <bitset>
#include <cstdio>
#include <vector>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
#define inl inline
#define re register int
#define lowbit(x) ((x) & (-x))
#define ll long long
#define ls(x) t[x].child[0]
#define rs(x) t[x].child[1]
#define fa(x) t[x].fa
const int inf = 0x7fffffff;
using namespace std;
template < class Read >
inl Read read() {
	Read x = 0;
	register bool w = 0;
	register char c = getchar();
	while (c > '9' || c < '0') {
		if (c == '-') w = 1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + (c ^ 48);
		c = getchar();
	}
	return w ? -x : x;
}
struct node {
	int child[2], fa, w, tot, tc, ts;
	bool filp, modify;
	multiset<int>s;
} t[200001];
bool vis[200001];
inl void upd(int x) {
	t[x].tc = t[x].tot = t[x].w, t[x].ts = inf;
	t[x].tc = min(min(t[ls(x)].tc, t[rs(x)].tc), t[x].tc);//链
	t[x].ts = min(min(t[ls(x)].ts, t[rs(x)].ts), *t[x].s.begin());//子树
	t[x].tot = min(t[x].tc, t[x].ts);
}
inl void reverse(int x) {
	swap(ls(x), rs(x));
	t[x].filp ^= 1;
}
inl void change(int x, int w) {
	if (!x)return;
	t[x].tc = t[x].w = w, t[x].modify = 1, t[x].tot = min(t[x].tc, t[x].ts);
}
inl void pushdown(int x) {
    //注意这里的修改不能清空filp标记，因为这里的filp并不是链翻转
	if (t[x].modify) {
		if (ls(x))change(ls(x), t[x].w);
		if (rs(x))change(rs(x), t[x].w);
		t[x].modify = 0;
	}
	if (t[x].filp) {
		if (ls(x))reverse(ls(x));
		if (rs(x))reverse(rs(x));
		t[x].filp = 0;
	}
}
inl bool poi(int x) {
	return rs(fa(x)) == x;
}
inl bool nroot(int x) {
	return ls(fa(x)) == x || rs(fa(x)) == x;
}
inl void rotate(int x) {
	int f = fa(x), gf = fa(f);
	bool fs = poi(x), gfs = poi(f);
	int s = t[x].child[fs ^ 1];
	if (nroot(f))t[gf].child[gfs] = x;
	t[f].child[fs] = s, t[x].child[fs ^ 1] = f;
	fa(x) = gf, fa(f) = x;
	if (s)fa(s) = f;
	upd(f);
}
inl void push(int x) {
	if (nroot(x))push(fa(x));
	pushdown(x);
}
inl void splay(int x) {
	push(x);
	while (nroot(x)) {
		if (nroot(fa(x)))poi(x) == poi(fa(x)) ? rotate(fa(x)) : rotate(x);
		rotate(x);
	}
	upd(x);
}
inl void access(int x) {
	for (re i = 0; x; x = t[i = x].fa) {
		splay(x);
		if (i) t[x].s.erase(t[x].s.lower_bound(t[i].tot));
		if (rs(x))t[x].s.insert(t[rs(x)].tot);
		rs(x) = i, upd(x);
	}
}
inl void makeroot(int x) {
	access(x), splay(x), reverse(x);
}
inl void split(int x, int y) {
	makeroot(y), access(x), splay(x);
}
struct edge {
	int next, to;
}e[5000001];
int tot, head[5000001];
inl void add(int x, int y) {
	e[++tot] = edge{ head[x],y }, head[x] = tot;
}
void dfs(int x, int fa) {
	t[x].s.insert(inf);
	t[x].fa = fa;
	for (re i = head[x]; i; i = e[i].next) {
		if (e[i].to != fa) {
			dfs(e[i].to, x);
			t[x].s.insert(t[e[i].to].tot);
		}
	}
	upd(x);
}
signed main() {
	t[0].tc = t[0].ts = t[0].tot = inf;
	t[0].s.insert(inf);//由于0节点是每个节点初始时的儿子，为了少加几句if所以直接赋值成inf;
	re n = read<int>(), m = read<int>(), x, y, w, root, op;
	for (re i = 1; i < n; i++) {
		x = read<int>(), y = read<int>();
		add(x, y), add(y, x);
	}
	for (re i = 1; i <= n; i++)t[x].tot = t[x].tc = t[i].w = read<int>(), t[x].ts = inf;//初始化
	root = read<int>();
	dfs(root, 0);
	makeroot(root);
	while (m--) {
		op = read<int>();
		if (op == 1) {
			makeroot(root = read<int>());
		}
		else if (op == 2) {
			x = read<int>(), y = read<int>(), w = read<int>();
			split(x, y), change(x, w), makeroot(root);
		}
		else {
			x = read<int>();
			access(x), splay(x), printf("%d\n", min(t[x].w, *t[x].s.begin()));
		}
	}
}
```



---

## 作者：Drifterming (赞：14)

```
//这道题给它打普及+的标签实在是亏了这道题
//除了换根之外，别的操作好像就是树剖的基本操作了
//换根怎么搞呢？不能换过来然后重新求dfs序然后建树吧
//画一下图，可以看出来，换根之后树的形态是会改变的，在新树根上边的点，他们的爸爸兄弟变成了自己的儿子
//但是，新树根的儿子们的形态是没有改变的，和新树根不在同一条链上的点的子树也是没有变的
//变了的只是新树根到一开始的树根那条链上的点
//所以，如果要查询的点是在这条链上，我们怎么做呢？
//可以发现，要查询的点的爸爸变成了和他用属于这条链上的那个儿子，
//所以这个点所掌管的子树就是整棵树挖去了这个儿子的子树 
//那么它的新儿子们在线段树对应的区间是哪一块呢？
//就是1->fa_s-1  fa_t+1->n， 
//所以我们求出它的这条链上的儿子，然后query上边的那两个区间就行了。
//但是怎么找这个儿子呢？我们知道它一定在这条链上，那么树剖处理的top是不能找到这个儿子的
//那我们要沿着now_root的father一个一个向上跳？
//不可能的   我们可以在处理一个倍增数组，用这个倍增数组来找儿子。
//然后问题就完美的解决了。 

#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int N=1e5+5;
const int INF=2147483647;

int n,m,id;
int opt,p1,p2,v,now_root;
int w[N];
int fa[N][17];
int head[N],num_edge;
struct Edge
{
	int v,nxt;
}edge[N<<1];
struct Node
{
	int fa,son;
	int dep;
	int top;
	int size;
	int s,t;
}node[N];
struct TREE
{
	TREE *lson,*rson;
	int l,r,mid;
	int minn,lazy;
}tree[N<<2];

typedef TREE* Tree;
Tree Root,now_node=tree;

inline int read()
{
	char c=getchar();int num=0;
	for(;!isdigit(c);c=getchar());
	for(;isdigit(c);c=getchar())
		num=num*10+c-'0';
	return num;
}

inline void add_edge(int u,int v)
{
	edge[++num_edge].v=v;
	edge[num_edge].nxt=head[u];
	head[u]=num_edge;
}

void dfs1(int u)
{
	for(int i=1;i<=17;++i)	//处理倍增数组 
	{
		fa[u][i]=fa[fa[u][i-1]][i-1];
		if(!fa[u][i])
			break;
	}
	node[u].size=1;
	for(int i=head[u],v;i;i=edge[i].nxt)
	{
		v=edge[i].v;
		if(v==node[u].fa)
			continue;
		node[v].fa=u;
		node[v].dep=node[u].dep+1;
		fa[v][0]=u;		//爸爸 
		dfs1(v);
		node[u].size+=node[v].size;
		if(node[v].size>node[node[u].son].size)
			node[u].son=v;		//重儿子 
	}
}

int bound;
void dfs2(int u,int top)
{
	node[u].top=top;
	node[u].s=++bound;		//线段树对应区间的左端点 
	if(node[u].son)
	{
		dfs2(node[u].son,top);
		for(int i=head[u],v;i;i=edge[i].nxt)
		{
			v=edge[i].v;
			if(v==node[u].fa||v==node[u].son)
				continue;
			dfs2(v,v);
		}
	}
	node[u].t=bound;	//线段树对应区间的右端点 
}

void build(Tree &root,int l,int r)
{
	root=++now_node;
	root->l=l,root->r=r,root->mid=l+r>>1;
	root->lazy=-1;
	if(l==r)
		return;
	build(root->lson,l,root->mid);
	build(root->rson,root->mid+1,r);
}

inline void pushdown(Tree root)
{
	if(root->lazy!=-1)
	{
		root->lson->lazy=root->lazy;
		root->rson->lazy=root->lazy;
		root->lson->minn=root->lazy;
		root->rson->minn=root->lazy;
		root->lazy=-1;
	}
}

void update(Tree root,int l,int r,int val)		//线段树修改 
{
	if(l<=root->l&&root->r<=r)
	{
		root->minn=val;
		root->lazy=val;
		return;
	}
	pushdown(root);
	if(r<=root->mid)
		update(root->lson,l,r,val);
	else if(l>root->mid)
		update(root->rson,l,r,val);
	else
	{
		update(root->lson,l,root->mid,val);
		update(root->rson,root->mid+1,r,val);
	}
	root->minn=min(root->lson->minn,root->rson->minn);
}

int query(Tree root,int l,int r)	//线段树查询 
{
	if(l<=root->l&&root->r<=r)
		return root->minn;
	pushdown(root);
	if(r<=root->mid)
		return query(root->lson,l,r);
	else if(l>root->mid)
		return query(root->rson,l,r);
	else
		return min(query(root->lson,l,root->mid),query(root->rson,root->mid+1,r));
}

inline void Modify(int x,int y,int val)		//树剖的modify操作 
{
	int fx=node[x].top,fy=node[y].top;
	while(fx!=fy)
	{
		if(node[fx].dep>node[fy].dep)
		{
			update(Root,node[fx].s,node[x].s,val);
			x=node[fx].fa;
			fx=node[x].top;
		}
		else
		{
			update(Root,node[fy].s,node[y].s,val);
			y=node[fy].fa;
			fy=node[y].top;
		}
	}
	if(node[x].dep>node[y].dep)
		update(Root,node[y].s,node[x].s,val);
	else
		update(Root,node[x].s,node[y].s,val);
}

inline bool judge(int Y)	//判断一下在不在一条链上 
{
	int x=now_root,y=Y;
	if(node[x].dep<node[y].dep)
		swap(x,y);
	int cha=node[x].dep-node[y].dep;
	for(int i=0;i<=17;++i)
	{
		if(cha&(1<<i))
			x=fa[x][i];
	}
	if(x!=y)
	{
		for(int i=17;i>=0;--i)
		{
			if(fa[x][i]!=fa[y][i])
				x=fa[x][i],y=fa[y][i];
		}
		x=fa[x][0];
	}
	if(x==Y)
		return 1;
	return 0;
}

inline int jump(int x,int dep)		//倍增往上跳，找儿子 
{
	for(int i=0;i<=17;++i)
		if(dep&(1<<i))
			x=fa[x][i];
	return x;
}

int main()
{
	n=read(),m=read();
	int u,v;
	for(int i=1;i<n;++i)
	{
		u=read(),v=read();
		add_edge(u,v);
		add_edge(v,u);
	}
	for(int i=1;i<=n;++i)
		w[i]=read();
	id=read(),now_root=id;
	dfs1(id);
	dfs2(id,id);
	build(Root,1,n);
	for(int i=1;i<=n;++i)
		update(Root,node[i].s,node[i].s,w[i]);
	for(int i=1;i<=m;++i)
	{
		opt=read();
       	if(opt==1)
		{
			id=read();
			now_root=id;
		}
		else if(opt==2)
		{
			p1=read(),p2=read(),v=read();
			Modify(p1,p2,v);
		}
		else
		{
			p1=read();
			if(p1==now_root)	//当前点是树根，查询整棵树 
				printf("%d\n",query(Root,1,n));
			else if(node[p1].s>=node[now_root].s&&node[p1].s<=node[now_root].t)		//当前点是当前树根的儿子或者等于当前树根 
				printf("%d\n",query(Root,node[p1].s,node[p1].t));
			else if(judge(p1))		//当前点和树根在一条链上 
			{
//				int minn=INF;
//				minn=min(minn,query(Root,1,node[now_root].s-1));
//				if(node[now_root].t<n)
//					minn=min(minn,query(Root,node[now_root].t+1,n));
//				printf("%d\n",minn);
				int dep=node[now_root].dep-node[p1].dep-1;
				int tmp=jump(now_root,dep);
				int minn=INF;
				if(node[tmp].s>1)
					minn=min(minn,query(Root,1,node[tmp].s-1));
				if(node[tmp].t<n)
					minn=min(minn,query(Root,node[tmp].t+1,n));
				printf("%d\n",minn);
			}
			else	//不在一条链上，没影响 
				printf("%d\n",query(Root,node[p1].s,node[p1].t));
		}
	}
	return 0;
}
/*
8 100
1 2
1 3
2 4
2 5
5 8
3 6
6 7
7 5 3 2 4 1 8 6
1
1 3
3 1
*/
```

---

## 作者：Saliеri (赞：12)

我们考试T3 初一蒟蒻莫名会做

**大雾**
___
### 一、基本分析

首先观察题目操作

- 路径修改

- 查询子树最值

如果只有此二操作肯定是树剖裸题一道

**但是**

*“如果 opt=1，接下来有一个整数 id，代表把首都（树根）修改为 id”*

**有换根操作**

裸树剖瞬间崩塌（总剖分复杂度都已经$\Theta(nq)$了...)

考虑如何实现换根

### 二、换根的实现

假设有一颗~~美丽的~~树，它长这样：

![](https://s2.ax1x.com/2019/09/18/nTRYWV.png)

首先以 **1** 为根剖一下

考虑换根为 **5**

树就变成了这样

![](https://s2.ax1x.com/2019/09/18/nT4lcV.png)

对现在而言，我们考虑一下所有点先后的答案

- 答案一样的 ： 2， 3， 4， 6

- 不同的：

——————**1**：答案变为除 **5** 子树外的答案

——————**5**：答案变为全树

看出什么没有？

若设当前根节点为**root**,询问节点为**id**；

方案 ： 

- 若**root==id**，答案为全树（这不用理解吧）

- 若**root与id不在同一子树** 或 **dep[id] < dep[root]** 答案不变（影都影响不到）

- 若**id在 root-->1 这条路径上** 答案就是 **全树的答案减去root所在的id的子树中的答案**

情况 3 写成判断就是
```cpp
dep[x] < dep[root] && fa[temp=LCAson(x,root)] == x//LCAson是lca于root方向的儿子
```
然后

就是几乎裸的树剖了。。。

### 三、$\mathfrak{Code}$

如果不懂树剖请右转 [P3384](https://www.luogu.org/problem/P3384)

最后附上我丑陋的考场代码

```cpp
//树剖换根（大雾）
#include <cstdio>
const int maxn = 1e5+5;
inline int re() {
	char c;
	int w=1;
	while((c=getchar())<'0'||c>'9')if(c=='-')w=-1;
	int res = c-'0';
	while((c=getchar())>='0' && c<='9')res = (res<<3) + (res<<1) + c - '0';
	return res * w;
}
inline long long min(long long a,long long b) {
	return a<b?a:b;
}
inline void swap(int &x,int &y){
	x ^= y,y ^= x,x ^= y;
}
int n,m,root;
int head[maxn],tot;
struct Edge {
	int next,to;
} e[maxn<<1];
inline void add_edge(int x,int y) {
	e[++tot].next = head[x];
	e[tot].to = y;
	head[x] = tot;
}
//树剖
long long val[maxn];
int fa[maxn],dep[maxn],son[maxn],siz[maxn],top[maxn],tid[maxn],rank[maxn],time;
inline void dfs1(int u,int fath) {
	int maxson = -1;
	dep[u] = dep[fath] + 1;
	fa[u] = fath;
	siz[u] = 1;
	for(int i=head[u],v; v=e[i].to,i; i=e[i].next) {
		if(v == fath)continue;
		dfs1(v,u);
		siz[u] += siz[v];
		if(siz[v] > maxson)maxson = siz[v],son[u] = v;
	}
	return ;
}
inline void dfs2(int u,int topf) {
	tid[u] = ++time;
	rank[time] = u;
	top[u] = topf;
	if(!son[u])return ;
	dfs2(son[u],topf);
	for(int i=head[u],v; v=e[i].to,i; i=e[i].next) {
		if(v == fa[u] || v == son[u])continue;
		dfs2(v,v);
	}
	return ;
}
//Segment tree
long long MIN[maxn << 2];
long long lazy[maxn << 2];
inline void markdown(int k,int l,int r,int mid){
	if(!lazy[k])return;
	if(l==r)lazy[k] = 0;
	MIN[k<<1] = MIN[k<<1|1] = lazy[k<<1] = lazy[k<<1|1] = MIN[k];
	lazy[k] = 0;
}
inline void build(int k,int l,int r) {
	if(l == r) {
		MIN[k] = val[rank[l]];//bg
		return;
	}
	int mid = l+r >> 1;
	build(k<<1,l,mid),build(k<<1|1,mid+1,r);
	MIN[k] = min(MIN[k<<1],MIN[k<<1|1]);
	return ;
}
inline void update(int k,int l,int r,int x,int y,int v) {
	if(l>y||r<x)return ;
	if(l>=x&&r<=y){
		MIN[k] = v;
		lazy[k] = v;
		return ;
	}
	int mid = l+r >> 1;
	markdown(k,l,r,mid);
	update(k<<1,l,mid,x,y,v),update(k<<1|1,mid+1,r,x,y,v);
	MIN[k] = min(MIN[k<<1],MIN[k<<1|1]);
	return ;
}
inline long long query(int k,int l,int r,int x,int y) {
	if(l>y||r<x)return 0x7ffffffffff;
	if(l>=x&&r<=y)return MIN[k];
	int mid = l+r>>1;
	markdown(k,l,r,mid);
	return min(query(k<<1,l,mid,x,y),query(k<<1|1,mid+1,r,x,y));
}
//继续树剖
inline void path_modify(int x,int y,int v){
	while(top[x] != top[y]){
		if(dep[top[x]] < dep[top[y]])swap(x,y);
		update(1,1,n,tid[top[x]],tid[x],v);
		x = fa[top[x]];
	}
	if(dep[x] > dep[y])swap(x,y);
	update(1,1,n,tid[x],tid[y],v);
	return ;
}
inline int LCAson(int x,int y){
	while(top[x] != top[y]){
		if(dep[top[x]] < dep[top[y]])swap(x,y);
		if(fa[top[x]] == y)return top[x];
		x = fa[top[x]];
	}
	if(dep[x] > dep[y])swap(x,y);
	return son[x];
}
inline long long Query(int x){
	int temp;
	if(x == root)return MIN[1];
	else if(dep[x] >= dep[root])return query(1,1,n,tid[x],tid[x] + siz[x] - 1);
	else if(dep[x] < dep[root] && fa[temp=LCAson(x,root)] == x){
		return min(query(1,1,n,1,tid[temp]-1),query(1,1,n,tid[temp] + siz[temp]/* - 1 + 1*/,n));
	}
	else return query(1,1,n,tid[x],tid[x] + siz[x] - 1);
}
int main() {
//	freopen("country.in","r",stdin);
//	freopen("country.out","w",stdout);
	n=re(),m=re();
	for(int i=1,u,v;i<n;++i)u = re(),v = re(),add_edge(u,v),add_edge(v,u);
	for(int i=1;i<=n;++i)scanf("%lld",&val[i]);
	root = re();
	dfs1(1,0),dfs2(1,1);
	build(1,1,n);
/*	for(int i=1;i<=n;++i)printf("%d ",siz[i]);
	puts("");*/
	for(int i=1,opt,p1,p2,v;i<=m;++i){
		opt = re();
		if(opt == 1)root = re();
		if(opt == 2)p1 = re(),p2 = re(),v = re(),path_modify(p1,p2,v);
		if(opt == 3)printf("%lld\n",Query(re()));
	}
	return 0;
}
```
~~完结不撒花~~



---

## 作者：MloVtry (赞：9)

~~看起来像颗LCT可我不会维护子树~~

树链~~生疏~~剖分+分类讨论

~~长者的题就是好~~

如果没有换根就是一个树剖裸题，有了换根呢？

不妨分类讨论一下（画画图找找规律）。

首先设根为rot，询问x的子树。

1> rot==x

显然就是整棵树的最小值。

2> lca(rot,x)!=x

此时rot与x没什么关系，如果rot不在x的子树里，那么rot在哪里，x的子树还是那一坨。

由此3> lca(rot,x)==x

rot在x的子树里，那就得扭一下。此时找到x的rot方向上的儿子，除去这个儿子在原树里的子树，剩下的都属于现在x的子树。

由此树剖+讨论一波就可以了。

代码
```cpp
#define inf (1<<30)
#include<iostream>
#include<cstdio>
#define N 100005
#define M N*2
using namespace std;
int head[N],to[M],Next[M],e,st[N][25],a[N];
void buid(int u,int v)
{
    Next[++e]=head[u];head[u]=e;to[e]=v;
}
int dep[N],wson[N],siz[N],fa[N];
void dfs(int now)
{
    st[now][0]=fa[now];
    dep[now]=dep[fa[now]]+1;
    siz[now]=1;
    for(int i=head[now];i;i=Next[i])
    {
        int j=to[i];if(j==fa[now]) continue;
        fa[j]=now;dfs(j);
        siz[now]+=siz[j];
        if(siz[j]>siz[wson[now]]) wson[now]=j; 
    }
}
int top[N],id[N],who[N],knt;
void dfs(int now,int fl)
{
    top[now]=fl;
    id[now]=++knt;who[knt]=now;
    if(!wson[now]) return;
    dfs(wson[now],fl); 
    for(int i=head[now];i;i=Next[i])
    {
        int j=to[i];
        if(j==fa[now]||j==wson[now]) continue;
        dfs(j,j);
    }
}
struct node
{
    int lazy,mi;
    node()
    {
        lazy=0;mi=inf;
    }
}tre[N*5];
void down(int now,int lson,int rson)
{
    if(tre[now].lazy)
    {
        int it=tre[now].lazy;tre[now].lazy=0;
        tre[lson].mi=tre[lson].lazy=it;
        tre[rson].mi=tre[rson].lazy=it;
    }
}
void update(int now,int lson,int rson)
{
    tre[now].mi=min(tre[lson].mi,tre[rson].mi);
}
void change(int u,int v,int l,int r,int now,int it)
{
    if(u<=l&&v>=r)
    {
        tre[now].lazy=tre[now].mi=it;
        return;
    }
    int mid=(l+r)>>1,lson=now<<1,rson=lson|1;
    down(now,lson,rson);
    if(v<=mid) change(u,v,l,mid,lson,it);
    else if(u>mid) change(u,v,mid+1,r,rson,it);
    else change(u,mid,l,mid,lson,it),change(mid+1,v,mid+1,r,rson,it);
    update(now,lson,rson);
}
int ask(int u,int v,int l,int r,int now)
{
    if(u>v) return inf;
    if(u<=l&&v>=r) return tre[now].mi;
    int mid=(l+r)>>1,lson=now<<1,rson=lson|1;
    down(now,lson,rson);
    if(v<=mid) return ask(u,v,l,mid,lson);
    else if(u>mid) return ask(u,v,mid+1,r,rson);
    else return min(ask(u,mid,l,mid,lson),ask(mid+1,v,mid+1,r,rson));
}
void buid(int l,int r,int now)
{
    if(l==r)
    {
        tre[now].mi=a[who[l]];
        return;
    }
    int mid=(l+r)>>1,lson=now<<1,rson=lson|1;
    buid(l,mid,lson);
    mid++;
    buid(mid,r,rson);
    update(now,lson,rson); 
}
int n,m,rot;
void buid_st()
{
    for(int i=1;i<20;++i)
    for(int now=1;now<=n;++now)
    st[now][i]=st[st[now][i-1]][i-1];
}
void C()
{
    int u,v,it;scanf("%d%d%d",&u,&v,&it);
    int tu=top[u],tv=top[v];
    while(tu!=tv)
    {
        if(dep[tu]<dep[tv]) swap(u,v),swap(tu,tv);
        change(id[tu],id[u],1,n,1,it);
        u=fa[tu],tu=top[u];
    }
    if(dep[u]<dep[v]) swap(u,v);
    change(id[v],id[u],1,n,1,it);	
}
int lca(int u,int v)
{
    if(dep[u]<dep[v]) swap(u,v);
    int c=dep[u]-dep[v];
    for(int i=0;i<20;++i)
    if(c&(1<<i)) u=st[u][i];
    if(u==v) return u;
    for(int i=19;i>=0;--i)
    if(st[u][i]!=st[v][i])
    u=st[u][i],v=st[v][i];
    return st[u][0];
}
void A()
{
    int x;scanf("%d",&x);
    if(x==rot)
    {
        printf("%d\n",tre[1].mi);
        return;
    }
    int lt=lca(x,rot);
    if(lt==x)
    {
        int c=dep[rot]-dep[x]-1;
        int v=rot;
        for(int i=0;i<20;++i)
        if(c&(1<<i)) v=st[v][i];
        int ans=min(ask(1,id[v]-1,1,n,1),ask(id[v]+siz[v],n,1,n,1));
        printf("%d\n",ans);
    }
    else printf("%d\n",ask(id[x],id[x]+siz[x]-1,1,n,1));
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<n;++i)
    {
        int u,v;scanf("%d%d",&u,&v);
        buid(u,v);buid(v,u);
    }
    for(int i=1;i<=n;++i) scanf("%d",&a[i]);
    dfs(1);dfs(1,1);
    buid(1,n,1);buid_st();
    scanf("%d",&rot);
    while(m--)
    {
        int fl;scanf("%d",&fl);
        if(fl==1) scanf("%d",&rot);
        else if(fl==2) C();
        else A();
    }
    return 0;
}
```


---

## 作者：loceaner (赞：6)

## 思路

一道树链剖分~~不~~好题。

> 爆零小技巧：设置最大值比给出序列的最大值还小

如果没有修改根的操作，那必定是个树链剖分板子题，只需要求线段树区间最小值，以及进行区间修改即可。

但是，有了换根操作就有了麻烦，不过可以发现一个小性质，那就是不管根是什么，一个点 $x$ 到另一点 $y$ 的路径都是不变的。

所以就可以直接以$1$为根进行树剖，每次修改时像普通树剖一样进行修改，所以现在的问题就是如何处理查询操作。

设当前要查询的节点为 $x$，当前的根为 $root$，在查询时分多种情况：

- $root$ 等于 $x$ 时，直接输出全局最小值
- $root$ 不在 $x$ 的子树中时，$x$ 的子树还是以 $1$ 为根时的子树，直接对 $x$ 进行查询
- $root$ 在 $x$ 的子树当中时，$x$ 的子树中不能访问到的是 $root$ 所在支链，求出 $x$ 在 $root$ 支链处的儿子 $sonn$，因为在 $dfn$ 序中，一个点以及其子树内所有点的编号是连续的，所以直接求$1\sim dfn[sonn]-1$ 中的最小值和 $dfn[sonn] + siz[sonn]\sim n$中的最小值，取 $\min$ 即可

时间复杂度 $O(n\log^2 n)$

## 代码

```cpp
/*
Author:loceaner
*/
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;

const int A = 2e5 + 11;
const int B = 1e6 + 11;
const int mod = 1e9 + 7;
const int inf = 0x7fffffff;

inline int read() {
  char c = getchar();
  int x = 0, f = 1;
  for ( ; !isdigit(c); c = getchar()) if (c == '-') f = -1;
  for ( ; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
  return x * f;
}

int n, m, root, cnt, pre[A], val[A], head[A]; 
struct node { int to, nxt; } e[A << 1];

inline void add(int from, int to) {
  e[++cnt].to = to;
  e[cnt].nxt = head[from];
  head[from] = cnt;
}

namespace Seg {
  #define lson rt << 1
  #define rson rt << 1 | 1
  
  struct tree { int l, r, minn, lazy; } t[A << 2];
  
  inline void pushup(int rt) {
    t[rt].minn = min(t[lson].minn, t[rson].minn);
  }
  
  inline void pushdown(int rt) {
    t[lson].minn = t[rt].lazy;
    t[rson].minn = t[rt].lazy;
    t[lson].lazy = t[rt].lazy;
    t[rson].lazy = t[rt].lazy;
    t[rt].lazy = 0;
  }
  
  void build(int rt, int l, int r) {
    t[rt].l = l, t[rt].r = r, t[rt].lazy = 0;
    if (l == r) {
      t[rt].minn = val[pre[l]];
      return;
    }
    int mid = (l + r) >> 1;
    build(lson, l, mid), build(rson, mid + 1, r);
    pushup(rt);
  }

  void update(int rt, int l, int r, int k) {
    if (l <= t[rt].l && t[rt].r <= r) {
      t[rt].lazy = t[rt].minn = k; 
      return;
    }
    if (t[rt].lazy) pushdown(rt);
    int mid = (t[rt].l + t[rt].r) >> 1;
    if (l <= mid) update(lson, l, r, k);
    //debug: l, r 写成 l, mid 
    if (r > mid) update(rson, l, r, k);
    //debug: l, r 写成 mid + 1, r 
    pushup(rt);
  }
  
  int query(int rt, int l, int r) {
    if (l <= t[rt].l && t[rt].r <= r) return t[rt].minn;
    if (t[rt].lazy) pushdown(rt);
    int mid = (t[rt].l + t[rt].r) >> 1, ans = inf;
    if (l <= mid) ans = min(ans, query(lson, l, r));
    //debug: l, r 写成 l, mid 
    if (r > mid) ans = min(ans, query(rson, l, r));
    //debug: l, r 写成 mid + 1, r 
    return ans;
    //爆零小技巧：在有返回值的函数中不加return 
  }
}

int dfscnt, dep[A], fa[A], siz[A], son[A], dfn[A], top[A];

void prepare(int x, int f) {
  siz[x] = 1, fa[x] = f, dep[x] = dep[f] + 1;
  for (int i = head[x]; i; i = e[i].nxt) {
    int to = e[i].to;
    if (to == f) continue;
    prepare(to, x), siz[x] += siz[to];
    if (siz[to] > siz[son[x]]) son[x] = to;
  }
}

void dfs(int x, int tp) {
  dfn[x] = ++dfscnt, pre[dfscnt] = x, top[x] = tp;
  if (son[x]) dfs(son[x], tp);
  for (int i = head[x]; i; i = e[i].nxt) {
    int to = e[i].to;
    if (to == fa[x] || to == son[x]) continue;
    dfs(to, to);
  } 
} 

inline void upd(int x, int y, int val) {
  while (top[x] != top[y]) {
    if (dep[top[x]] < dep[top[y]]) swap(x, y);
    Seg::update(1, dfn[top[x]], dfn[x], val);
    x = fa[top[x]];
  }
  if (dep[x] > dep[y]) swap(x, y);
  Seg::update(1, dfn[x], dfn[y], val); return;
}

inline int prove(int x) {
  if (root == x) return 1;
  if (dfn[root] <= dfn[x] || dfn[root] > dfn[x] + siz[x] - 1) return 2;
  return 0;
}

inline void solve(int x) {
  int flag = prove(x);
//  cout << flag << " ";
  if (flag == 1) cout << Seg::t[1].minn << '\n';
  else if (flag == 2) cout << Seg::query(1, dfn[x], dfn[x] + siz[x] - 1) << '\n';
  else {
    int now = root, sonn = 0;
    while (top[now] != top[x]) {
      if (fa[top[now]] == x) { sonn = top[now]; break; }
      now = fa[top[now]]; 
    }
    if (!sonn) sonn = son[x];
    int ans = Seg::query(1, 1, dfn[sonn] - 1);
    if (dfn[sonn] + siz[sonn] - 1 != n) 
      ans = min(ans, Seg::query(1, dfn[sonn] + siz[sonn], n));
    cout << ans << '\n';
  }
}

int main() {
//  freopen("a.in", "r", stdin);
//  freopen("1.out", "w", stdout);
  n = read(), m = read();
  for (int i = 1; i < n; i++) {
    int x = read(), y = read();
    add(x, y), add(y, x);
  }
  for (int i = 1; i <= n; i++) val[i] = read();
  prepare(1, 0), dfs(1, 1), Seg::build(1, 1, n);
  root = read();
  while (m--) {
    int opt = read(), x = read(), y, val;
    if (opt == 1) root = x;
    else if (opt == 2) y = read(), val = read(), upd(x, y, val);
    else if (opt == 3) solve(x);
  }
  return 0;
}
```

---

## 作者：beretty (赞：6)

  ~~好像除了换根操作之外就是板子~~
  
  ##### 那我们就讲下换根吧 
  
  ###### 换根  ： 我们分3种情况讨论

1  . 如果now 和 root 重合 ，那就是查询整棵树 ，直接输出tmin[1]就好了

2  . 如果LCA（now，root） != now 
     这时根与now没有关系，直接查询now的子树即可
     
3  . 如果LCA（now,root) = now

   ~~这时就比较麻烦了~~

我们可以先找一下now的所有儿子
	
   ###### 由于 一个子树的dfs序是连续的
    
	所以 如果这个儿子的id大于等于root
	
    并且这个子树中的最大dfs序（id[son]+size[son]-1）小于等于当前的root
	
    那么就可以判断出root在这个儿子中或者就是这个儿子,记录下这个儿子
    
	还是那句话 ：一个子树的dfs序是连续的
    
	这时now的子树就是去除包含root的那个儿子的子树的整棵树了 
 
~~然而我讲的并不清楚，要是实在不懂可以手胡一下对吧~~
 
 放一下代码，帮助各位dalao理解下吧
 
    
  ```
  #include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
# define ls now<<1
# define rs now<<1|1
const int M = 100005 ;
const int inf = 2100000000 ;
using namespace std;
inline int read(){
	char c=getchar(); int x=0,w=1;
	while(c>'9'||c<'0'){if(c=='-') w=-1 ;c=getchar();}
	while(c>='0'&&c<='9'){x=x*10+c-'0'; c=getchar();}
	return x*w;
}
int n,m;
struct E{
	int nex,to;
}edge[M<<1];
int hea[M],num;
inline void add_edge(int from,int to){
	edge[++num].nex=hea[from];
	edge[num].to=to;
	hea[from]=num;
}
int fa[M],dep[M],size[M],son[M];
int val[M],root;
void dfs1(int u,int father,int deep){
	dep[u]=deep; 
	fa[u]=father;
	size[u]=1 ;
	int Maxson=-1;
	for(int i=hea[u];i;i=edge[i].nex){
		int v=edge[i].to;
		if(v==father) continue ;
		dfs1(v,u,deep+1);
		size[u]+=size[v];
		if(size[v]>Maxson){
			Maxson=size[v];
			son[u]=v;
			
		}
	}
}
int id[M],cnt,top[M],p[M];
void dfs2(int u,int topf){
	top[u]=topf; 
	id[u]=++cnt;
	p[cnt]=val[u];
	if(!son[u]) return ;
	dfs2(son[u],topf);
	for(int i=hea[u];i;i=edge[i].nex){
		int v=edge[i].to;
		if(!id[v])
		  dfs2(v,v);
	}
}
inline int LCA(int x,int y){
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		x=fa[top[x]];
	}
	return dep[x]<=dep[y]?x:y;
}
int tmin[M<<2],tag[M<<2];
inline void pushup(int now){
	tmin[now]=min(tmin[ls],tmin[rs]);
}
inline void pushdown(int now){
	if(tag[now]!=-1){
		tmin[ls]=tmin[rs]=tag[now];
		tag[ls]=tag[rs]=tag[now];
		tag[now]=-1;
	}
}
void Build(int l,int r,int now){
	tag[now]=-1;
	if(l==r){
		tmin[now]=p[l];
		return ;
	}
	int mid=(l+r)>>1;
	Build(l,mid,ls);
	Build(mid+1,r,rs);
	pushup(now);
}
void change(int L,int R,int C,int l,int r,int now){
	if(l==L&&r==R){
		tmin[now]=C;
		tag[now]=C;
		return ;
	}
	int mid=(l+r)>>1;
	pushdown(now);
	if(mid>=R) change(L,R,C,l,mid,ls);
	else if(mid<L) change(L,R,C,mid+1,r,rs);
	else{
		change(L,mid,C,l,mid,ls);
		change(mid+1,R,C,mid+1,r,rs);
	}
	pushup(now);
}
void change1(int x,int y,int C){
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		change(id[top[x]],id[x],C,1,n,1);
		x=fa[top[x]];
	}
	if(dep[x]>dep[y]) swap(x,y);
	change(id[x],id[y],C,1,n,1);
}
int query(int L,int R,int l,int r,int now){
	if(l>R||r<L) return inf;
	if(l>=L&&r<=R) return tmin[now];
	int mid=(l+r)>>1;
	pushdown(now);
	int Ans=query(L,R,l,mid,ls);
	Ans=min(Ans,query(L,R,mid+1,r,rs));
	return Ans;
}
int main(){
	n=read(); m=read();
	int u,v;
	for(int i=1;i<n;i++){
		u=read(); v=read();
		add_edge(u,v);
	    add_edge(v,u);
	}
	for(int i=1;i<=n;i++) val[i]=read();
	root=read();
	dfs1(1,1,1);
	dfs2(1,1);
	Build(1,n,1);
	while(m--){
		int opt=read();
		if(opt==1){
			int x=read();
			root=x;
		}
		else if(opt==2){
			int u=read(),v=read(),w=read();
			change1(u,v,w);
		}
		else{
			int x=read();
			if(x==root) printf("%d\n",tmin[1]);
			else{
				int lca=LCA(x,root);
				if(lca==x){
					int y;
					for(int i=hea[x];i;i=edge[i].nex){
						int v=edge[i].to;
						if(id[v]<=id[root]&&id[v]+size[v]-1>=id[root]){
							y=v;
							break;
						}
					}
					int Ans=query(1,id[y]-1,1,n,1);
					Ans=min(Ans,query(id[y]+size[y],n,1,n,1));
				    printf("%d\n",Ans);
				}
				else printf("%d\n",query(id[x],id[x]+size[x]-1,1,n,1));
			}
		}
	}
	return 0;
}
```

---

## 作者：Captain_Paul (赞：3)

这道题看起来像一道树剖~~（显然就是树剖）~~

与普通树剖不同的地方在于有一种操作叫换根

然而我们并不能在换根的时候重构整棵树~~（显然会T）~~

所以就需要考虑其他对策（分类讨论！）

一开始先以1为根把树建好

然后再查询子树最小值时，可以发现

如果当前根节点不在查询的子树中，它对这棵子树是没有影响的

所以就查询idx[x]到idx[x]+tot[x]-1就好了

但如果根节点在查询的这棵子树中，

那我们真正要查询的子树其实是原子树去掉根节点所在的部分以外的部分

~~（好像有点拗口）~~具体见代码

这个题的精髓也就在这里了，其余操作同树剖模板

丑陋的代码：

```cpp
#include<cstdio>
#include<cstring>
#include<cctype>
#include<algorithm>
#define reg register
using namespace std;
const int N=1e5+5;
struct edge
{
	int to,nxt;
}edge[N<<1];
int n,q,num,head[N],w[N],fa[N],son[N],tot[N];
int root,cnt,idx[N],top[N],dep[N],a[N];
int minn[N<<2],tag[N<<2];
inline int read()
{
	int x=0,w=1;
	char c=getchar();
	while (!isdigit(c)&&c!='-') c=getchar();
	if (c=='-') c=getchar(),w=-1;
	while (isdigit(c))
	{
		x=(x<<1)+(x<<3)+c-'0';
		c=getchar();
	}
	return x*w;
}
inline void add_edge(int from,int to)
{
	edge[++num].nxt=head[from];
	edge[num].to=to;
	head[from]=num;
}
void dfs(int k,int father,int deep)
{
	int bigson=0;
	fa[k]=father; dep[k]=deep; tot[k]=1;
	for (reg int i=head[k];i;i=edge[i].nxt)
	{
		int v=edge[i].to;
		if (v==father) continue;
		dfs(v,k,deep+1); tot[k]+=tot[v];
		if (bigson<tot[v])
		{
			bigson=tot[v]; son[k]=v;
		}
	}
}
void dfs(int k,int tp)
{
	idx[k]=++cnt; top[k]=tp; a[cnt]=w[k];
	if (!son[k]) return; dfs(son[k],tp);
	for (reg int i=head[k];i;i=edge[i].nxt)
	{
		int v=edge[i].to;
		if (!idx[v]) dfs(v,v);
	}
}
inline void pushup(int now)
{
	minn[now]=min(minn[now<<1],minn[now<<1|1]);
}
inline void pushdown(int now)
{
	if (tag[now]==-1) return;
	tag[now<<1]=tag[now<<1|1]=tag[now];
	minn[now<<1]=minn[now<<1|1]=tag[now];
	tag[now]=-1;
}
void build(int l,int r,int now)
{
	tag[now]=-1;
	if (l==r)
	{
		minn[now]=a[l]; return;
	}
	int mid=(l+r)>>1;
	build(l,mid,now<<1);
	build(mid+1,r,now<<1|1);
	pushup(now);
}
void inchange(int L,int R,int l,int r,int now,int c)
{
	if (l>R||r<L) return;
	if (l>=L&&r<=R)
	{
		minn[now]=c; tag[now]=c; return;
	}
	int mid=(l+r)>>1; pushdown(now);
	if (mid>=R) inchange(L,R,l,mid,now<<1,c);
	else if (mid<L) inchange(L,R,mid+1,r,now<<1|1,c);
	else
	{
		inchange(L,mid,l,mid,now<<1,c);
		inchange(mid+1,R,mid+1,r,now<<1|1,c);
	}
	pushup(now);
}
int getmin(int L,int R,int l,int r,int now)
{
	if (l>R||r<L) return 2e9;
	if (l>=L&&r<=R) return minn[now];
	int mid=(l+r)>>1; pushdown(now);
	if (mid>=R) return getmin(L,R,l,mid,now<<1);
	if (mid<L) return getmin(L,R,mid+1,r,now<<1|1);
	return min(getmin(L,mid,l,mid,now<<1),getmin(mid+1,R,mid+1,r,now<<1|1));
}
inline void treechange(int x,int y,int val)
{
	while (top[x]!=top[y])
	{
		if (dep[top[x]]<dep[top[y]]) swap(x,y);
		inchange(idx[top[x]],idx[x],1,n,1,val);
		x=fa[top[x]];
	}
	if (dep[x]>dep[y]) swap(x,y);
	inchange(idx[x],idx[y],1,n,1,val);
}
inline bool check(int root,int v)
{
	return idx[root]>=idx[v]&&idx[root]<=idx[v]+tot[v]-1;
}
int main()
{
	n=read(),q=read();
	for (reg int i=1;i<n;i++)
	{
		int x=read(),y=read();
		add_edge(x,y);
		add_edge(y,x);
	}
	for (reg int i=1;i<=n;w[i++]=read());
	dfs(1,0,1); dfs(1,1); build(1,n,1);
	for (root=read();q;q--)
	{
		int opt=read();
		if (opt==1) root=read();
		if (opt==2)
		{
			int x=read(),y=read(),z=read();
			treechange(x,y,z);
		}
		if (opt==3)
		{
			int x=read();
			if (x==root) printf("%d\n",minn[1]);
			else
			{
				int now=0;
				for (reg int i=head[x];i&&!now;i=edge[i].nxt)
				{
					int v=edge[i].to;
					if (v==fa[x]) continue;
					if (check(root,v)) now=v;
				}
				if (now)
				{
					int l=getmin(1,idx[now]-1,1,n,1),r=2e9;
					if (idx[now]+tot[now]<=n)
					  r=getmin(idx[now]+tot[now],n,1,n,1);
					int ans=getmin(idx[x],idx[x],1,n,1);
					printf("%d\n",min(ans,min(l,r)));
				}
				else printf("%d\n",getmin(idx[x],idx[x]+tot[x]-1,1,n,1));
			}
		}
	}
}
```

---

## 作者：smilke (赞：2)

前置芝士：树的dfs序，线段树

这道题，怎么说呢，是一道非常适合入门树剖的一道题，因为它比较模板吧。观察题意，发现这道题让我们求的是这样一个东西：

给定一棵有根树，需要支持以下操作：

1.将根改变为root.

2.将x，y路径之间的点权修改为val.

3.查询x子树内的最小点权.

观察2,3两个操作，发现这是树链剖分的基本操作，不熟悉的同学可以做一下这道题：[【模板】树链剖分](https://www.luogu.org/problem/P3384) 

这道题的难点就在于操作1的换根。翻了很多博客，发现他们都没有把这个最重要的部分说明白，那么我就按照自己的理解详细叙述一下吧，希望能帮到大家（如有错误之处请多多指教）。

由于换根，有许多点的子树内的信息都要变化，这个需要怎么去维护呢？

我们观察一下换根的性质.

下图是一棵已经进行轻重链剖分的树：

![](https://s2.ax1x.com/2019/10/15/KCuuTS.png)

此时它的根节点为A. 好，我们将它换根为B.

那么树的形态将会长这样（略丑，原谅我的画图技术QAQ）：

![](https://s2.ax1x.com/2019/10/15/KCus61.png)

然后我们观察各个子树间的信息，我们可以发现，节点C，D，E，F，H的子树的信息并未改变，改变只是节点A，B的信息，由于B变为了根节点，所以它的子树为整棵树，下属节点由CED -> CEADFH，而我们观察A，发现A的下属节点由BFCEHD -> FH。

由此，我们可以显而易见地发现，原根节点和换根后的节点形成一条路径，这条路径之外的点在换根前后的子树信息是不会变化的，我们需要考虑的是换根会对这条路径上的点的子树信息会产生什么影响.

这个情况比较好判断，我们可以举个例子,画一条链来看看（加粗的线为两个根节点之间的路径）：

![](https://s2.ax1x.com/2019/10/15/KCKScn.png)

上面的图是原来的链，A为根节点，现将它换根为E.

![](https://s2.ax1x.com/2019/10/15/KCuWkD.png) 

于是，由上面的图，我们可以看到，路径中，E节点的子树变为整棵树，C，D节点的子树改变成整棵树减去原子树的部分，而A点的子树由原整棵树变为除AE路径的另一端子树上，也就是A点重儿子以下的节点不再归属于A，并为E的子树上去了。

那么这就十分的清晰了.

对于换根，我们可以总结出以下规律：

1.换根前后两个根节点之间路径之外的点子树信息不变.,

2.对于路径中的点，新根节点的的子树变为整棵树。

3.对于路径上其他的点，它的子树变成了整棵树减去一棵子树，减去的子树就是他的包含root的重儿子的子树。

那么怎么判断询问点和根节点有没有在一条路径上呢？ 这也十分好判断，直接询问他们的祖先是不是root即可。询问重儿子也很简单，返回LCA的重儿子即为所求。 

操作3询问的代码如下：

```cpp
int treequery(int x) {
	if(x == root) return ask(1, 1, n); // 情况二，询问点为现根节点，这时它的子树即为整棵树。 
	int p = lca(x, root);
	if(p != x) return ask(1, id[x], id[x] + size[x] - 1);  //情况一 ，询问点不在路径上，直接返回原子树的信息。 
	else { //情况三，找到root包含的重儿子。 
		int q = find(x, root);
		return min(ask(1, 1, id[q]-1), ask(1, id[q] + size[q], cont));//除去root包含重儿子子树的部分即为所求。 
	}
}
```
树链剖分以及求dfs序的代码:
```cpp
int size[N], son[N], f[N], dep[N];
void dfs1(int x, int fa) {// 处理树的基本信息 
	f[x] = fa; size[x] = 1;
	for(int i = head[x]; i; i = e[i].next) {
		int y = e[i].to;
		if(y == fa) continue;
		dep[y] = dep[x] + 1;
		dfs1(y, x);
		size[x] += size[y];
		if(size[y] > size[son[x]]) son[x] = y;
	}
}
int id[N], b[N], cont = 0, top[N];
void dfs2(int x, int topf) {
  	id[x] = ++cont; b[cont] = a[x]; // 建立树的dfs序 
	top[x] = topf; if(!son[x]) return;
	dfs2(son[x], topf); // 重链剖分 
	for(int i = head[x]; i; i = e[i].next) {
	  	int y = e[i].to;
	  	if(y == f[x] || y == son[x]) continue;
	  	dfs2(y, y); // 轻链剖分 
	}
}
```
线段树维护dfs序的代码：

```cpp
void build(int p, int l, int r) { //建树 
	t[p].l = l; t[p].r = r;
	if(l == r) { t[p].mn = b[l]; return; }
	int mid = (l + r) >> 1;
	build(p<<1, l, mid);
	build(p<<1|1, mid+1, r);
	t[p].mn = min(t[p<<1].mn, t[p<<1|1].mn);
}
void spread(int p){ // 下传标记 
	if(t[p].ad) {
	   t[p<<1].mn = t[p<<1|1].mn = t[p].ad;
		t[p<<1].ad = t[p<<1|1].ad = t[p].ad;
		t[p].ad = 0;
	}
}
void change(int p, int l, int r, int d) { // 区间修改 
	if(t[p].l >= l && t[p].r <= r) { t[p].mn = d; t[p].ad = d; return; }
	spread(p);
	int mid = (t[p].l + t[p].r) >> 1;
	if(l <= mid) change(p<<1, l, r, d);
	if(r > mid) change(p<<1|1, l, r, d);
	t[p].mn = min(t[p<<1].mn, t[p<<1|1].mn); 
}
int ask(int p, int l, int r) { // 区间最小值查询 
	if(t[p].l >= l && t[p].r <= r) return t[p].mn;
	spread(p);
	int mid = (t[p].l + t[p].r) >> 1, val = 1<<30;
	if(l <= mid) val = min(val, ask(p<<1, l, r));
	if(r > mid) val = min(val, ask(p<<1|1, l, r));
	return val;
}
```
操作二修改链的代码：

```cpp
void treechange(int x, int y, int val) {
	while(top[x] != top[y]) {
		if(dep[top[x]] < dep[top[y]]) swap(x, y);
		change(1, id[top[x]], id[x], val);
		x = f[top[x]];
	}
	if(dep[x] > dep[y]) swap(x, y);
	change(1, id[x], id[y], val);
}
```
求lca以及其重儿子的代码：
```cpp
int lca(int x, int y) { // 求x, y 的 LCA
	while(top[x] != top[y]) {
		if(dep[top[x]] < dep[top[y]]) swap(x, y);
		x = f[top[x]];
	}
	return dep[x] < dep[y] ? x : y;
}
int find(int x, int y) { // 返回两者链顶的重儿子 
	while(top[x] != top[y]) {
		if(dep[top[x]] < dep[top[y]]) swap(x, y);
		if(f[top[x]] == y) return top[x];
		x = f[top[x]];
	} 
	if(dep[x] < dep[y]) swap(x, y);
	return son[y];
} 
```
那么这道题的主要做法就到这里了.

贴一下完整的代码吧：

```cpp
#include<bits/stdc++.h>

#define ll long long
#define mp make_pair
#define rep(i, a, b) for(int i = (a); i <= (b); i++)
#define per(i, a, b) for(int i = (a); i >= (b); i--)

using namespace std;

typedef pair<int, int> pii;
typedef double db;
const int N = 1e6 + 50;
int n, m, root, a[N];
int head[N], cnt = 0;
struct node { int to, next; } e[N]; 
struct tree { int l, r, mn, sum, ad; } t[N];
inline int read(){
	int x = 0, f = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9') { if(ch == '-') f = -1; ch = getchar();}
	while(ch >='0' && ch <='9') { x = (x<<3)+(x<<1)+(ch^48); ch = getchar();}
	return x*f;
}
void add(int x, int y) { e[++cnt].to = y; e[cnt].next = head[x]; head[x] = cnt; }
int size[N], son[N], f[N], dep[N];
void dfs1(int x, int fa) {// 处理树的基本信息 
	f[x] = fa; size[x] = 1;
	for(int i = head[x]; i; i = e[i].next) {
		int y = e[i].to;
		if(y == fa) continue;
		dep[y] = dep[x] + 1;
		dfs1(y, x);
		size[x] += size[y];
		if(size[y] > size[son[x]]) son[x] = y;
	}
}
int id[N], b[N], cont = 0, top[N];
void dfs2(int x, int topf) {
	id[x] = ++cont; b[cont] = a[x]; // 建立树的dfs序 
	top[x] = topf; if(!son[x]) return;
	dfs2(son[x], topf); // 重链剖分 
	for(int i = head[x]; i; i = e[i].next) {
		int y = e[i].to;
		if(y == f[x] || y == son[x]) continue;
		dfs2(y, y); // 轻链剖分 
	}
}
void build(int p, int l, int r) { //建树 
	t[p].l = l; t[p].r = r;
	if(l == r) { t[p].mn = b[l]; return; }
	int mid = (l + r) >> 1;
	build(p<<1, l, mid);
	build(p<<1|1, mid+1, r);
	t[p].mn = min(t[p<<1].mn, t[p<<1|1].mn);
}
void spread(int p){ // 下传标记 
	if(t[p].ad) {
		t[p<<1].mn = t[p<<1|1].mn = t[p].ad;
		t[p<<1].ad = t[p<<1|1].ad = t[p].ad;
		t[p].ad = 0;
	}
}
void change(int p, int l, int r, int d) { // 区间修改 
	if(t[p].l >= l && t[p].r <= r) { t[p].mn = d; t[p].ad = d; return; }
	spread(p);
	int mid = (t[p].l + t[p].r) >> 1;
	if(l <= mid) change(p<<1, l, r, d);
	if(r > mid) change(p<<1|1, l, r, d);
	t[p].mn = min(t[p<<1].mn, t[p<<1|1].mn); 
}
int ask(int p, int l, int r) { // 区间最小值查询 
	if(t[p].l >= l && t[p].r <= r) return t[p].mn;
	spread(p);
	int mid = (t[p].l + t[p].r) >> 1, val = 1<<30;
	if(l <= mid) val = min(val, ask(p<<1, l, r));
	if(r > mid) val = min(val, ask(p<<1|1, l, r));
	return val;
}
int lca(int x, int y) { // 求x, y 的 LCA
	while(top[x] != top[y]) {
		if(dep[top[x]] < dep[top[y]]) swap(x, y);
		x = f[top[x]];
	}
	return dep[x] < dep[y] ? x : y;
}
int find(int x, int y) { // 返回y的重儿子 
	while(top[x] != top[y]) {
		if(dep[top[x]] < dep[top[y]]) swap(x, y);
		if(f[top[x]] == y) return top[x];
		x = f[top[x]];
	} 
	if(dep[x] < dep[y]) swap(x, y);
	return son[y];
} 
void treechange(int x, int y, int val) {
	while(top[x] != top[y]) {
		if(dep[top[x]] < dep[top[y]]) swap(x, y);
		change(1, id[top[x]], id[x], val);
		x = f[top[x]];
	}
	if(dep[x] > dep[y]) swap(x, y);
	change(1, id[x], id[y], val);
}
int treequery(int x) {
	if(x == root) return ask(1, 1, n); // 情况二，询问点为现根节点，这时它的子树即为整棵树。 
	int p = lca(x, root);
	if(p != x) return ask(1, id[x], id[x] + size[x] - 1);  //情况一 ，询问点不在路径上，直接返回原子树的信息。 
	else { //情况三，找到root包含的重儿子。 
		int q = find(x, root);
		return min(ask(1, 1, id[q]-1), ask(1, id[q] + size[q], cont));//除去root包含重儿子的部分即为所求。 
	}
}
void init(){
	n = read(); m = read();
	rep(i, 1, n-1) { int xx = read(), yy = read(); add(xx, yy); add(yy, xx); }
	rep(i, 1, n) a[i] = read(); root = read();
	dfs1(root, 0); dfs2(root, root); build(1, 1, n);
	rep(i, 1, m) {
		int op = read();
		if(op == 1) root = read();
		if(op == 2) {
			int x = read(), y = read(), z = read();
			treechange(x, y, z);
		}
		if(op == 3) {
			int x = read(); 
			printf("%d\n", treequery(x));
		}
	}
} 
int main(){ init(); return 0; }

```


---

## 作者：Santiego (赞：1)

### 思路

需要想一下的树剖题，对于询问三需要处理换跟后的情况。我们以1为树根跑一遍剖分，对于换跟进行分类讨论，算出实际答案。讨论有三种情况：

（以1为树根的树上）

- 跟在询问节点的祖先上：因为不影响，所以直接求子树最小值

- 跟即询问节点：直接查全树

- 跟在询问节点子树中：画图容易得出，**此时询问节点范围包含全树除了$son$的子树**，其中$son$为跟向上跳达到询问节点的上一个节点。于是我们除去线段树区间$[idx[son], idx[son]+sz[son]-1]$分左右区间讨论就好了。


### 例码

```cpp
#include <cstdio>
#include <algorithm>
#define MAXN 100010
#define ll long long
#define sl (x<<1)
#define sr (x<<1|1)
using namespace std;
int head[MAXN],vv[MAXN*2],nxt[MAXN*2],tot;
const int INF=0x3fffffff;
inline void add_edge(int u, int v){
    vv[++tot]=v;
    nxt[tot]=head[u];
    head[u]=tot;
}
int nod_val[MAXN];
int mxs[MAXN],sz[MAXN],dep[MAXN];
int f[MAXN][20];
void dfs1(int u, int fa){
    dep[u]=dep[fa]+1;
    f[u][0]=fa;
    for(int i=1;i<=17;++i)
        f[u][i]=f[f[u][i-1]][i-1];
    sz[u]=1;
    int mxsz=-1;
    for(int i=head[u];i;i=nxt[i]){
        int v=vv[i];
        if(v==fa) continue;
        dfs1(v, u);
        sz[u]+=sz[v];
        if(mxsz<sz[v]){
            mxsz=sz[v];
            mxs[u]=v;
        }
    }
}
int idx[MAXN],topf[MAXN],cnt,wnew[MAXN];
void dfs2(int u, int top){
    idx[u]=++cnt;
    topf[u]=top;
    wnew[cnt]=nod_val[u];
    if(mxs[u]==0) return;
    dfs2(mxs[u], top);
    for(int i=head[u];i;i=nxt[i]){
        int v=vv[i];
        if(v==f[u][0]||v==mxs[u]) continue;
        dfs2(v, v);
    }
}
struct nod{
    int l, r;
    int val,lazy;
} tre[MAXN*4];

void buildt(int x, int l, int r){
    tre[x].l=l,tre[x].r=r,tre[x].lazy=0;
    if(l==r){
        tre[x].val=wnew[l];
        return;
    }
    int mid=(l+r)>>1;
    buildt(sl, l, mid);
    buildt(sr, mid+1, r);
    tre[x].val=min(tre[sl].val, tre[sr].val);
}
void push_down(int x){
    if(tre[x].lazy==0) return;
    tre[sl].lazy=tre[sl].val=tre[x].lazy;
    tre[sr].lazy=tre[sr].val=tre[x].lazy;
    tre[x].lazy=0;
}
void change(int x, int l, int r, int val){
    if(l<=tre[x].l&&tre[x].r<=r){
        tre[x].lazy=tre[x].val=val;
        return;
    }
    push_down(x);
    int mid=(tre[x].l+tre[x].r)>>1;
    if(l<=mid) change(sl, l, r, val);
    if(mid<r) change(sr, l, r, val);
    tre[x].val=min(tre[sl].val, tre[sr].val);
}
int query(int x, int l, int r){
    if(l<=tre[x].l&&tre[x].r<=r){
        return tre[x].val;
    }
    push_down(x);
    int mid=(tre[x].l+tre[x].r)>>1;
    int ans=INF;
    if(l<=mid) ans=min(query(sl, l, r), ans);
    if(mid<r) ans=min(query(sr, l, r), ans);
    return ans;
}
void tre_change(int a, int b, int val){
    while(topf[a]!=topf[b]){
        if(dep[topf[a]]<dep[topf[b]]) swap(a,b);
        change(1, idx[topf[a]], idx[a], val);
        a=f[topf[a]][0];
    }
    if(dep[a]<dep[b]) swap(a,b);
    change(1, idx[b], idx[a], val);
}
int tre_lca(int a, int b){
    while(topf[a]!=topf[b]){
        if(dep[topf[a]]<dep[topf[b]]) swap(a,b);
        a=f[topf[a]][0];
    }
    if(dep[a]<dep[b]) return a;
    return b;
}
int tre_query(int a){
    return query(1, idx[a], idx[a]+sz[a]-1);
}
int get_son(int a, int b){
    for(int i=17;i>=0;--i)
        if(dep[f[b][i]]>dep[a]) b=f[b][i];
    return b;
}
int n,q,cap;
int main()
{
    scanf("%d %d", &n, &q);
    for(int i=1;i<n;++i){
        int a,b;
        scanf("%d %d", &a, &b);
        add_edge(a, b);
        add_edge(b, a);
    }
    for(int i=1;i<=n;++i) scanf("%d", &nod_val[i]);
    scanf("%d", &cap);
    dfs1(1, 1);
    dfs2(1, 1);
    buildt(1, 1, n);
    while(q--){
        int opt;
        scanf("%d", &opt);
        if(opt==1){
            scanf("%d", &cap);
        }else if(opt==2){
            int l,r,v;
            scanf("%d %d %d", &l, &r, &v);
            tre_change(l, r, v);
        }else if(opt==3){
            int t;
            scanf("%d", &t);
            int lca=tre_lca(t, cap);
            if(t==cap) printf("%d\n", query(1, 1, n));
            else if(lca!=t) printf("%d\n", tre_query(t));
            else{
                int son=get_son(t, cap);
                int ans=min(query(1, 1, idx[son]-1), query(1, idx[son]+sz[son], n)); // 除去中间那个区间，分左右区间求
                printf("%d\n", ans);
            }
        }else puts("Erro!");
    }
    return 0;
}
```



---

## 作者：zhengrunzhe (赞：1)

### Self-adjusting Top Trees

观察题面:1.换根 2.路径覆盖 3.子树最小值

做法：

1.树剖线段树

不看换根据裸树剖，基于dfs序，换根考虑一下做一点小变换就做完了

查询时间复杂度:$O(n \log n)$

修改时间复杂度:$O(n \log^2 n)$

2.lct套multiset

子树信息的维护需要每个节点挂一个multiset装轻子树信息，access切换虚实更新一下就完事了

时间复杂度:$O(n \log^2 n)$

3.top tree

学习见：[negiizhao的博客](http://negiizhao.blog.uoj.ac/blog/4912)

每个节点维护簇路径最小值，簇中簇路径以外的内点的最小值，以及路径的染色标记

板子题，做完了

不公开完整satt代码

```cpp
#include<cstdio>
#include<cstddef>
template<class type>inline const void read(type &in)
{
	in=0;char ch(getchar());bool f(0);
	while (ch<48||ch>57){if (ch=='-')f=1;ch=getchar();}
	while (ch>47&&ch<58)in=(in<<3)+(in<<1)+(ch&15),ch=getchar();
	if (f)in=-in;
}
template<class type>inline const void swap(type &a,type &b)
{
	const type c(a);a=b;b=c;
}
template<class type>inline const type min(const type &a,const type &b)
{
	return a<b?a:b;
}
const int N(1e5+10),inf(2147483647);
namespace Self_Adjusting_Top_Trees
{
}using namespace Self_Adjusting_Top_Trees;
int n,m,u[N],v[N];
int main()
{
	read(n);read(m);
	node0=new tree[n+1];
	for (int i(1);i<n;i++)read(u[i]),read(v[i]);
	for (int i(1);i<=n;i++)read(node(i)->val),node(i)->path_min=node(i)->val;
	for (int i(1);i<n;i++)link(node(u[i]),node(v[i]));
	int rt;read(rt);makeroot(node(rt));
	for (int opt,x,y,z;m--;)
		switch (read(opt),read(x),opt)
		{
			case 1:makeroot(node(x));break;
			case 2:read(y);read(z);cover(node(x),node(y),z);break;
			case 3:printf("%d\n",query(node(x)));break;
		}
	return 0;
}
```

---

## 作者：shiroi (赞：1)

这里提供一种无指针AAA树的写法

AAA树属于魔改版LCT，具有可以维护子树信息的性质，应该属于类Top tree的一种。

题目中要求维护换根操作，同时维护链上赋值和子树最小值。

由于题目中要求维护子树信息，普通的LCT难以维护，因此考虑使用AAA树同时维护子树信息。

实现时子树修改标记和链的修改标记需要分别下传，最后完成统计。

题目总的时间复杂度为$O(logn)$，但常数远远大于LCT和树剖写法，并且实现难度很大，需要注意的细节也比较多。

```cpp
#include <bits/stdc++.h>
using namespace std;

inline int read()
{
	int x=0; int f=1; char ch=getchar();
	while(!isdigit(ch)) {if(ch=='-')f=-1; ch=getchar();}
	while(isdigit(ch)) {x=x*10+ch-'0'; ch=getchar();}
	return x*f;
}

struct Tag
{
	int mul,add;

	Tag(int mulv=1,int addv=0)
	{mul=mulv,add=addv;}

	bool emp() {return mul==1 && add==0;}

	friend Tag operator + (Tag u,Tag v)
	{return Tag(u.mul*v.mul,u.add*v.mul+v.add);}
};

struct Data
{
	int mx,mn,sm,sz;

	Data(int mxv=0,int mnv=0,int smv=0,int szv=0)
	{mx=mxv,mn=mnv,sm=smv,sz=szv;}

	friend Data operator + (Data u,Tag v)
	{
		if(u.sz)
		{
			int mxv=u.mx*v.mul+v.add;
			int mnv=u.mn*v.mul+v.add;
			int smv=u.sm*v.mul+v.add*u.sz;
			return Data(mxv,mnv,smv,u.sz);
		}
		return u;
	}

	friend Data operator + (Data u,Data v)
	{
		int mxv=max(u.mx,v.mx);
		int mnv=min(u.mn,v.mn);
		int smv=u.sm+v.sm;
		int szv=u.sz+v.sz;
		return Data(mxv,mnv,smv,szv);
	}
};

const int MAXN = 200005;
struct Edge { int from,to; } e[MAXN];
int fa[MAXN],ch[MAXN][4],val[MAXN];
Tag stag[MAXN],xtag[MAXN];
Data sld[MAXN],vir[MAXN],all[MAXN];
bool rev[MAXN],isx[MAXN];
int bin[MAXN],cnt,ft;
int rt,n,m;

inline void pushr(int x)
{swap(ch[x][0],ch[x][1]),rev[x]^=1;}

inline void tagsld(int x,Tag w)
{
	stag[x]=stag[x]+w; sld[x]=sld[x]+w;
	val[x]=val[x]*w.mul+w.add;
	all[x]=sld[x]+vir[x];
}

inline void tagvir(int x,Tag w,bool fg=1)
{
	xtag[x]=xtag[x]+w; all[x]=all[x]+w;
	vir[x]=vir[x]+w;
	if(fg) tagsld(x,w);
}

inline void pushup(int x)
{
	sld[x]=vir[x]=all[x]=Data(-(1<<30),1<<30,0,0);
	if(!isx[x]) all[x]=sld[x]=Data(val[x],val[x],val[x],1);
	for (int i = 0; i < 2; ++i)
	{
		if(ch[x][i])
		{
			sld[x]=sld[x]+sld[ch[x][i]];
			vir[x]=vir[x]+vir[ch[x][i]];
		}
	}
	for (int i = 0; i < 4; ++i)
		if(ch[x][i]) all[x]=all[x]+all[ch[x][i]];
	for (int i = 2; i < 4; ++i)
		if(ch[x][i]) vir[x]=vir[x]+all[ch[x][i]];
}

inline void pushdown(int x)
{
	if(rev[x])
	{
		if(ch[x][0]) pushr(ch[x][0]);
		if(ch[x][1]) pushr(ch[x][1]);
		rev[x]=0;
	}
	if(!xtag[x].emp())
	{
		for (int i = 0; i < 4; ++i)
			if(ch[x][i]) tagvir(ch[x][i],xtag[x],i>=2);
		xtag[x]=Tag(1,0);
	}
	if(!stag[x].emp())
	{
		for (int i = 0; i < 2; ++i)
			if(ch[x][i]) tagsld(ch[x][i],stag[x]);
		stag[x]=Tag(1,0);
	}
}

inline int son(int x,int y)
{
	if(ch[x][y]) pushdown(ch[x][y]);
	return ch[x][y];
}

inline int find(int x)
{
	for (int i = 0; i < 4; ++i)
		if(ch[fa[x]][i]==x) return i;
	return -1;
}

inline void sets(int x,int w,int tp)
{if(w) fa[w]=x; ch[x][tp]=w;}

inline bool chk(int x,int tp=0)
{
	if(!tp)
		return !fa[x] || ch[fa[x]][0]!=x && ch[fa[x]][1]!=x;
	return !fa[x] || !isx[x] || !isx[fa[x]];
}

inline void rotate(int x,int tp)
{
	if(chk(x,tp)) return;
	int y=fa[x];
	if(fa[y]) sets(fa[y],x,find(y));
	else fa[x]=0; fa[y]=x;
	if(ch[y][tp]==x)
	{
		ch[y][tp]=ch[x][tp+1];
		ch[x][tp+1]=y;
		if(ch[y][tp])
			fa[ch[y][tp]]=y;
	}
	else
	{
		ch[y][tp+1]=ch[x][tp];
		ch[x][tp]=y;
		if(ch[y][tp+1])
			fa[ch[y][tp+1]]=y;
	}
	pushup(y); pushup(x);
}

inline void update(int x)
{if(fa[x]) update(fa[x]); pushdown(x);}

inline void split(int x,int tp=0)
{
	pushup(x);
	while(!chk(x,tp))
	{
		int y=fa[x];
		if(chk(y,tp)) rotate(x,tp);
		else
		{
			if((ch[fa[y]][tp]==y)^(ch[y][tp]==x))
				rotate(x,tp);
			else rotate(y,tp);
			rotate(x,tp);
		}
	}
}

inline int newnode()
{
	int x=ft ? bin[ft--] : ++cnt;
	for (int i = 0; i < 4; ++i)
		ch[x][i]=0;
	fa[x]=0; stag[x]=xtag[x]=Tag(1,0);
	sld[x]=vir[x]=all[x]=Data(-(1<<30),1<<30,0,0);
	isx[x]=1; rev[x]=val[x]=0;
	return x;
}

inline void recycle(int x)
{ bin[++ft]=x; }

inline void add(int x,int w)
{
	for (int i = 2; i < 4; ++i)
		if(!ch[w][i]) { sets(w,x,i); return;}
	int y=newnode(),u;
	for (u = w; isx[ch[u][2]]; u = son(u,2));
	sets(y,ch[u][2],2); sets(y,x,3);
	sets(u,y,2); split(y,2);
}

inline void del(int x)
{
	if(isx[fa[x]])
	{
		sets(fa[fa[x]],ch[fa[x]][5-find(x)],find(fa[x]));
		recycle(fa[x]); split(fa[fa[x]],2);
	}
	else sets(fa[x],0,find(x));
	fa[x]=0;
}

inline void access(int x)
{
	int y; update(x); split(x);
	if(ch[x][1])
	{
		y=ch[x][1]; ch[x][1]=0;
		add(y,x); pushup(x);
	}
	while(fa[x])
	{
		for(y = fa[x]; isx[y]; y = fa[y]);
		split(y);
		if(ch[y][1])
		{
			sets(fa[x],ch[y][1],find(x));
			split(fa[x],2);
		}
		else del(x); sets(y,x,1);
		pushup(y); x=y;
	}
}

inline void makeroot(int x)
{access(x),split(x),pushr(x);}

inline int findroot(int x)
{
	access(x); split(x); x=son(x,0);
	while(x && ch[x][1])
		x=son(x,1);
	return x;
}

inline int getroot(int x)
{
	while(fa[x]) x=fa[x];
	return x;
}

inline int cut(int x)
{
	int y=findroot(x);
	if(y)
	{
		access(y); split(y);
		del(x); pushup(y);
	}
	return y;
}

inline void link(int x,int w)
{
	int y=cut(x);
	if(getroot(x)!=getroot(w))
		y=w;
	if(y)
	{
		access(y); split(y);
		add(x,y); pushup(y);
	}
}

inline void update_chain_sum(int u)
{
	makeroot(u); access(read()); split(u);
	tagsld(u,Tag(0,read()));
	makeroot(rt);
}

inline void change_root(int u)
{makeroot(u),rt=u;}

inline int query_subtree(int u)
{
	access(u); split(u);
	int ans=val[u];
	for (int j = 2; j < 4; ++j)
	{
		if(ch[u][j])
		{
			Data p=all[ch[u][j]];
			ans=min(ans,p.mn);
		}
	}
	return ans;
}

int main(int argc, char const *argv[])
{
	n=read(); m=read(); rt=1;
	for (int i = 1; i < n; ++i)
		e[i].from=read(),e[i].to=read();
	for (int i = 1; i <= n; ++i)
		val[++cnt]=read(),pushup(cnt);
	for (int i = 1; i < n; ++i)
	{
		makeroot(e[i].from);
		makeroot(e[i].to);
		link(e[i].from,e[i].to);
	}
	rt=read(); makeroot(rt);
	int opt,u,w;
	for (int i = 1; i <= m; ++i)
	{
		opt=read(); u=read();
		if(opt==1) change_root(u);
		if(opt==2) update_chain_sum(u);
		if(opt==3) printf("%d\n", query_subtree(u));
	}
	return 0;
}
```

---

## 作者：Goldia (赞：1)

为什么没人写top tree呢？~~是太毒瘤了吗~~

这道题有换根操作与链修改操作，考虑用lct，但有子树查询，于是我们考虑用一种更强大的数据结构 top tree

对于top tree 我推荐一篇[博客](https://blog.csdn.net/u012732945/article/details/43494481)供大家学习 

- 对于1操作 我们直接用一个变量记录root是谁就行了
- 对于2操作 我们可以维护一个tag，tag中维护一个乘和一个加，这样区间赋值就相当于 **原来的权值*0+新的权值**。
- 对于3操作 我们可以直接Access 然后查一下他的虚链上的权值
- 注意2操作split是会改变根的 所以记得每次操作后makeroot回去

感觉top tree很强，不过板子有点长，而且常数巨大，复杂度和树剖是一样的，考场上应该没有机会写吧。

### code
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
#define LL long long
#define R register
const int N=2e5+5;
int n,m;
struct ccf
{
    int ma,mi,sum,siz;
    ccf(){}
    ccf(int a,int b,int c,int d):ma(a),mi(b),sum(c),siz(d){}
};
struct tag
{
    int mul,add;
    tag(){mul=1;add=0;};
    tag(int a,int b):mul(a),add(b){}
    inline bool empty(){return mul==1&&add==0;} 
};
ccf operator+(const ccf&a,const ccf&b)
{
    return ccf(max(a.ma,b.ma),min(a.mi,b.mi),a.sum+b.sum,a.siz+b.siz);
}
ccf operator+(const ccf&a,const tag&b)
{
    if(!a.siz)return a;
    return ccf(a.ma*b.mul+b.add,a.mi*b.mul+b.add,a.sum*b.mul+b.add*a.siz,a.siz);
}
tag operator+(const tag&a,const tag&b)
{
    return tag(a.mul*b.mul,a.add*b.mul+b.add);
}
struct lct
{
    lct *ch[4],*par;
    tag CHAIN,ALL;
    ccf cha,sub,all;
    int rev,inr,val;
    inline void filp(){rev^=1;swap(ch[0],ch[1]);}
    inline void pushshi(const tag&a)
    {
        cha=cha+a;
        CHAIN=CHAIN+a;
        val=val*a.mul+a.add;
        all=cha+sub;
    }
    inline void pushxu(const tag&a,bool fff=1)
    {
        ALL=ALL+a;
        all=all+a;
        sub=sub+a;
        if(fff)pushshi(a);
    }
    inline void rz()
    {
        cha=all=sub=ccf(-(1<<30),1<<30,0,0);
        if(!inr)all=cha=ccf(val,val,val,1);
        for(int i=0;i<2;i++)if(ch[i])cha=cha+ch[i]->cha,sub=sub+ch[i]->sub;
        for(int i=2;i<4;i++)if(ch[i])sub=sub+ch[i]->all;
        for(int i=0;i<4;i++)if(ch[i])all=all+ch[i]->all;
    }
    inline void pushdown()
    {
        if(rev)
        {
            if(ch[0])ch[0]->filp();
            if(ch[1])ch[1]->filp();
            rev=0;
        }
        if(!ALL.empty())
        {
            for(int i=0;i<4;i++)
                if(ch[i])ch[i]->pushxu(ALL,i>=2);
            ALL=tag(1,0);
        }
        if(!CHAIN.empty())
        {
            for(int i=0;i<2;i++)
                if(ch[i])ch[i]->pushshi(CHAIN);
            CHAIN=tag(1,0);
        }
    }
    inline lct *CH(int now){if(ch[now])ch[now]->pushdown();return ch[now];}
    inline bool CHK(int now){return par->ch[now+1]==this;}
    inline int chk(){for(int i=0;i<4;i++)if(par->ch[i]==this)return i;return 0;}
    inline void sets(lct *now,int d){if(now)now->par=this;ch[d]=now;}
    inline bool get(int ty)
    {
        if(!ty)return !par||(par->ch[0]!=this&&par->ch[1]!=this);
        return !par||!par->inr||!inr;
    }
}tr[N<<1],*cur=tr+N,*pool[N],**CUR=pool;
int totcnt=0;
inline lct *newlct()
{
    ++totcnt;
    lct *now=(CUR==pool)?cur++:*(--CUR);
    for(int i=0;i<4;i++)now->ch[i]=0;
    now->par=0;
    now->ALL=now->CHAIN=tag(1,0);
    now->all=now->cha=ccf(-(1<<30),1<<30,0,0);
    now->inr=1;now->rev=0;now->val=0;
    return now;
}
inline void deld(lct *now){*(CUR++)=now;}
inline void zhuan(lct *now,int ty)
{
    lct *p=now->par;int d=now->CHK(ty);
    if(!p->par)now->par=0;
    else p->par->sets(now,p->chk());
    p->sets(now->ch[!d+ty],d+ty);
    now->sets(p,!d+ty);
    p->rz();
}
inline void splay(lct *now,int ty=0)
{
    while(!now->get(ty))
    {
        if(now->par->get(ty))zhuan(now,ty);
        else if(now->CHK(ty)==now->par->CHK(ty))zhuan(now->par,ty),zhuan(now,ty);
        else zhuan(now,ty),zhuan(now,ty);   
    }
    now->rz();
}
inline void add(lct *a,lct *b)
{
    b->pushdown();
    for(int i=2;i<4;i++)
        if(!b->ch[i]){b->sets(a,i);return;}
    lct *x=newlct(),*v;
    for(v=b;v->ch[2]->inr;v=v->CH(2));
    x->sets(v->ch[2],2);x->sets(a,3);
    v->sets(x,2);splay(x,2);
}
inline void del(lct *now)
{
    if(now->par->inr)
    {
        now->par->par->sets(now->par->ch[5-now->chk()],now->par->chk());
        deld(now->par);
        splay(now->par->par,2);
    }
    else now->par->sets(0,now->chk());
    now->par=0;
}
lct *sta[N];
inline void Access(lct *now)
{
    int top=0;
    lct *v=now,*u;
    for(u=now;u;u=u->par)sta[++top]=u;
    while(top)sta[top--]->pushdown();
    splay(now);
    if(now->ch[1])
    {
        u=now->ch[1];
        now->ch[1]=0;
        add(u,now);
        now->rz();
    }
    while(now->par)
    {
        //cout<<"f="<<now->par->val<<endl;
        for(u=now->par;u->inr;u=u->par);
        splay(u);
        if(u->ch[1])
        {
            now->par->sets(u->ch[1],now->chk());
            splay(now->par,2);
        }
        else del(now);
        u->sets(now,1);
        (now=u)->rz();
    }
    splay(v);
}
inline void makeroot(lct *now)
{
    Access(now);
    now->filp();
}
inline lct *findpar(lct *now)
{
    Access(now);
    now=now->CH(0);
    while(now&&now->ch[1])now=now->CH(1);
    return now;
}
inline lct *findrt(lct *now)
{
    for(;now->par;now=now->par);
    return now;
}
inline lct *cut(lct *now)
{
    lct *v=findpar(now);
    if(v)
    {
        Access(v);
        del(now);
        v->rz();
    }
    return v;
}
inline void link(lct *a,lct *b)
{
    lct *now=cut(a);
    if(findrt(a)!=findrt(b))now=b;
    if(now)
    {
        //cout<<now->val<<endl;
        Access(now);
        //cout<<666<<endl;
        add(a,now);
        now->rz();
    }
}
inline void split(lct *a,lct *b)
{
    makeroot(a);
    Access(b);
    splay(a);
}
int U[N],V[N],root;
inline int rd()
{
    char p=getchar();int x=0,f=1;
    while(p>'9'||p<'0')
    {
        if(p=='-')f=-1;
        p=getchar();
    }
    while(p<='9'&&p>='0')x=(x<<1)+(x<<3)+(p^48),p=getchar();
    return x*f;
}
int main()
{
	//freopen("666.in","r",stdin);
    n=rd();m=rd();
    for(int i=1;i<n;i++)
    	U[i]=rd(),V[i]=rd();
	for(int i=1;i<=n;i++)
    {
        tr[i].val=rd();
        //cout<<"tr="<<tr[i].val<<endl;
        tr[i].rz();
    }
	for(int i=1;i<n;i++)
    {
        makeroot(tr+U[i]);
        //cout<<U[i]<<" "<<V[i]<<endl; 
        link(tr+U[i],tr+V[i]);
    }
    root=rd();
    makeroot(tr+root);
    int x,op,y,z;
    lct *u;
    //cout<<"fuck"<<endl;
    while(m--)
	{
		op=rd();x=rd();u=tr+x;
		//printf("op=%d x=%d\n",op,x);
		makeroot(tr+root);
		if(op==1)root=x;
		else if(op==2)
		{
			y=rd();z=rd();
			split(u,tr+y);
			u->pushshi(tag(0,z));
		}
		else
		{
			u=tr+x;
			Access(u);
            int ans=u->val;
            for(int i=2;i<4;i++)if(u->ch[i])
            {
                ccf res=u->ch[i]->all;                    
                ans=min(ans,res.mi);
            }
            printf("%d\n",ans);
		}
	}
    return 0;
}
```


---

## 作者：GNAQ (赞：1)

我来一篇带图的

遥远的行星？ 神奇的国度？

NO，遥远的国度.

这题真皮OVO

考虑换根之后只有两种情况答案会变

一是根与询问点重合 答案整棵树

二是在询问点的子树内，这时候需要……枚举子树树根！

然后用dfs序来判断，这玩意是连续的（嗯……？），而且在每个子树内也是连续的（！）

锁定在哪颗子树内！

```cpp
if (dfn[child]<=dfn[croot] && dfn[child]+tsize[child]-1>=dfn[croot])
```

然后你抓着这个子树的根节点把它拎起来，这整棵树其余的部分就耷拉到下面了

然后你就会发现这时候实际是询问这个红色的部分

然后就行了。
![](https://cdn.luogu.com.cn/upload/pic/16702.png)

画风奇怪？？

[查看完整代码](https://fancydreams.ink/2018/04/03/bzoj3083-%E9%81%A5%E8%BF%9C%E7%9A%84%E5%9B%BD%E5%BA%A6/)

---

## 作者：傅思维666 (赞：0)

## 题解：

前置知识，树链剖分。

附上讲解链接：

[浅谈树链剖分](https://www.cnblogs.com/fusiwei/p/11519470.html)

学习完树链剖分我们可以完美地解决链上修改操作和子树查询操作。

就是这个换根，真的烦人。

思考换根的处理方法：

如果每次暴力重构树，重新进行树链剖分的话，显然不行。这个复杂度只能支持我们进行一次树链剖分的预处理。那么我们只能考虑如何用一次预处理，只在查询上下些功夫，来解决掉这个换根问题。

通过换根DP的启发，我们可以发现，探究性质是一个不错的选择。

随便手画几个图。发现，改完根之后，对于大多数节点的答案是没有影响的。

所以想到分类讨论：什么情况下对答案没有影响，什么情况下对答案有影响。

* 情况1：询问点`idx`与当前根`now`重合。此时即为全局最小值。

* 情况2：询问点与当前根离得很远，不在一条链上，或者从1到`now`不包括询问点`idx`。此时对答案不影响，直接树剖询问子树输出即可。

* 情况3：询问点在1到`now`的链上，此时对答案有影响。

于是我们考虑有什么影响。随便手画图可以看出，这时询问点的答案只不包括询问点到当前根这整条路径（一直到底）这部分。所以我们可以求两个最小值，再求一次最小。类似于容斥原理的思想。

所以有代码：

```cpp
#include<cstdio>
#include<algorithm>
#define lson pos<<1
#define rson pos<<1|1
using namespace std;
const int maxn=1e5+10;
const int INF=2147483647;
int n,m;
int tot,to[maxn<<1],nxt[maxn<<1],head[maxn],a[maxn];
int size[maxn],deep[maxn],fa[maxn],son[maxn],top[maxn],id[maxn],cnt,w[maxn];
int tree[maxn<<2],lazy[maxn<<2];
int now;
int tmp;
bool flag;
void add(int x,int y)
{
    to[++tot]=y;
    nxt[tot]=head[x];
    head[x]=tot;
}
void dfs1(int x,int f)
{
    deep[x]=deep[f]+1;
    fa[x]=f;
    size[x]=1;
    for(int i=head[x];i;i=nxt[i])
    {
        int y=to[i];
        if(y==f)
            continue;
        dfs1(y,x);
        size[x]+=size[y];
        if(!son[x]||size[y]>size[son[x]])
            son[x]=y;
    }
}
void dfs2(int x,int t)
{
    top[x]=t;
    id[x]=++cnt;
    w[cnt]=a[x];
    if(!son[x])
        return;
    dfs2(son[x],t);
    for(int i=head[x];i;i=nxt[i])
    {
        int y=to[i];
        if(y==fa[x]||y==son[x])
            continue;
        dfs2(y,y);
    }
}
void build(int pos,int l,int r)
{
    int mid=(l+r)>>1;
    if(l==r)
    {
        tree[pos]=w[l];
        return;
    }
    build(lson,l,mid);
    build(rson,mid+1,r);
    tree[pos]=min(tree[lson],tree[rson]);
}
void mark(int pos,int l,int r,int k)
{
    tree[pos]=k;
    lazy[pos]=k;
}
void pushdown(int pos,int l,int r)
{
    int mid=(l+r)>>1;
    mark(lson,l,mid,lazy[pos]);
    mark(rson,mid+1,r,lazy[pos]);
    lazy[pos]=0;
}
void update(int pos,int l,int r,int x,int y,int k)
{
    int mid=(l+r)>>1;
    if(x<=l && r<=y)
    {
        mark(pos,l,r,k);
        return;
    }
    if(lazy[pos])
        pushdown(pos,l,r);
    if(x<=mid)
        update(lson,l,mid,x,y,k);
    if(y>mid)
        update(rson,mid+1,r,x,y,k);
    tree[pos]=min(tree[lson],tree[rson]);
}
void upd_chain(int x,int y,int k)
{
    while(top[x]!=top[y])
    {
        if(deep[top[x]]<deep[top[y]])
            swap(x,y);
        update(1,1,n,id[top[x]],id[x],k);
        x=fa[top[x]];
    }
    if(deep[x]<deep[y])
        swap(x,y);
    update(1,1,n,id[y],id[x],k);
}
int goal(int x,int y)
{
	while(top[x]!=top[y])
    {
		if(deep[top[x]]<deep[top[y]])
            swap(x,y);
		if(fa[top[x]]==y)
            return top[x];
		x=fa[top[x]];
	}
	if(deep[x]>deep[y])
        swap(x,y);
	return son[x];
}
int query(int pos,int l,int r,int x,int y)
{
    int ret=INF;
    int mid=(l+r)>>1;
    if(x<=l && r<=y)
        return tree[pos];
    if(lazy[pos])
        pushdown(pos,l,r);
    if(x<=mid)
        ret=min(ret,query(lson,l,mid,x,y));
    if(y>mid)
        ret=min(ret,query(rson,mid+1,r,x,y));
    return ret;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<n;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        add(x,y);
        add(y,x);
    }
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    dfs1(1,0);
    dfs2(1,1);
    build(1,1,n);
    scanf("%d",&now);
    while(m--)
    {   
        int opt,idx,x,y,v;
        scanf("%d",&opt);
        if(opt==1)
        {
            scanf("%d",&idx);
            now=idx;
        }
        else if(opt==2)
        {
            scanf("%d%d%d",&x,&y,&v);
            upd_chain(x,y,v);
        }
        else
        {
            scanf("%d",&idx);
            if(idx==now)
                printf("%d\n",tree[1]);
            else if(deep[idx]<deep[now]&&fa[tmp=goal(idx,now)]==idx)
            {
                int a,b,c;
                a=query(1,1,n,1,id[tmp]-1);
                b=query(1,1,n,id[tmp]+size[tmp],n);
                printf("%d\n",min(a,b));
            }
            else
                printf("%d\n",query(1,1,n,id[idx],id[idx]+size[idx]-1));
        }
    }
    return 0;
}
```



---

## 作者：crashed (赞：0)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.com.cn/problem/P3979)看题目。  
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然是一道树剖的题，考虑如何实现。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于操作$opt=2$：树剖的模板，不说了。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于操作$opt=1$：我们用一个变量$t$存下来当前的根的编号，这个操作就相当于重新读入$t$。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于操作$opt=3$：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们有三种处理方法——  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$1.LCT$（不会呀$QaQ$）  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$2.$每次换根就重新剖分，时间可以达到......优秀的$O(nm)$。~~跟模拟一样了~~  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$3.$使用技巧，比如下面这棵树：  
![](https://i.loli.net/2019/09/15/dXcjowv3iHRQlBu.png)  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假如最初的根为$t_0$，当前的根为$t$。在这个例子里，$t_0=1,t=6$。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么我们在处理操作$3$的时候，可以把点分成三类点：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$1.A=\{t\}$。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$2.B=\{v|v\text{在}t- t_0\text{的路径上且} v\not=t\}$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$3.C=\{v|v\text{不在}t-t_0\text{的路径上}\}$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于$1$类点，这相当于查询全局最小值，直接上线段树。对于$3$类点，我们会发现，在以$t$为根的树上，它们的**子树中的点和以$t_0$为根时是一样的**，所以正常查询。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于$2$类点，它们的子树发生了变化。比如，在例子里，$1$在$t_0$为根时，子树中的点为$V$（所有点）；在$t$为根时，子树中的点为$\{1,2,8,9,4,7\}$，也就相当于$V-\{3,5,6,10,11,12\}$。我们可以理解为$V-\{3\text{的子树的点}\}$。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设$s(u)$为$u$在以$t_0$为根时子树中点的集合,$s'(u)$为$u$在以$t$为根时子树中点的集合，$dep(u)$为$u$在以$t_0$为根时的深度（$dep(t_0)=0$）。于是就可以发现如下的规律——  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**对于$u\in B$，找出在$u-t$的路径上$dep$最小且$\not=u$的点$v$，那么在新树上的$u$的子树的点$s'(u)=V-s(v)$** 。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如，在上例中，若$u=1$，则$v=3$，$s'(u)=V-s(3)$，与我们的结果是吻合的。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是就可以在处理操作$3$的时候分类处理就可以了。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总时间$O(m\log_2^2n)$。  
# 代码
```cpp
#include <cmath>
#include <cstdio>

typedef unsigned int ui;

const ui INF = ( 1u << 31 ) + 1;
const int MAXN = 100005, MAXM = 100005, MAXLOG = 20;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar(); int f = 1;
	while( s < '0' || '9' < s ){ f = 1; if( s == '-' ) f = -1; s = getchar(); }
	while( '0' <= s && s <= '9' ){ x = ( x << 3 ) + ( x << 1 ) + s - '0', s = getchar(); }
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ), x = -x; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
_T MIN( const _T a, const _T b )
{
	return a < b ? a : b;
}

struct edge
{
	int to, nxt;
}Graph[MAXN << 1];

struct segmentTreeNode
{
	ui mn, tag;
	#define mn( a ) ( segTree[a].mn )
	#define tag( a ) ( segTree[a].tag )
}segTree[MAXN << 2];

int f[MAXN][MAXLOG];
int seq[MAXN], LTail[MAXN];
ui def[MAXN];
int head[MAXN], siz[MAXN], dep[MAXN], heavy[MAXN], bel[MAXN], LPos[MAXN];
int N, M, rt, cnt, ID, tot, lg2;

void setVal( const int u, const ui v ) { mn( u ) = v, tag( u ) = v; }
void upt( const int u ) { mn( u ) = MIN( mn( u << 1 ), mn( u << 1 | 1 ) ); }
void addEdge( const int from, const int to ) { Graph[++ cnt].to = to, Graph[cnt].nxt = head[from], head[from] = cnt; }
void normalize( const int u ) { if( ~ tag( u ) ) setVal( u << 1, tag( u ) ), setVal( u << 1 | 1, tag( u ) ), tag( u ) = -1; }
void balance( int &u, const int steps ) { for( int i = 0 ; ( 1 << i ) <= steps ; i ++ ) if( steps & ( 1 << i ) ) u = f[u][i]; }

void build( const int u, const int l, const int r )
{
	if( l > r ) return ; tag( u ) = -1;
	if( l == r ) { mn( u ) = def[seq[l]]; return; }
	int mid = l + r >> 1;
	build( u << 1, l, mid ), build( u << 1 | 1, mid + 1, r );
	upt( u );
}

void update( const int u, const int l, const int r, const int segL, const int segR, const ui v )
{
	int mid = l + r >> 1;
	if( segL <= l && r <= segR ) { setVal( u, v ); return ; }
	if( l == r ) return ; normalize( u );
	if( segL <= mid ) update( u << 1, l, mid, segL, segR, v );
	if( segR > mid ) update( u << 1 | 1, mid + 1, r, segL, segR, v );
	upt( u );
}

ui query( const int u, const int l, const int r, const int segL, const int segR )
{
	if( segL > segR ) return INF;
	int mid = l + r >> 1; ui ret = INF;
	if( segL <= l && r <= segR ) return mn( u );
	if( l == r ) return INF; normalize( u );
	if( segL <= mid ) ret = MIN( ret, query( u << 1, l, mid, segL, segR ) );
	if( segR > mid ) ret = MIN( ret, query( u << 1 | 1, mid + 1, r, segL, segR ) );
	return ret;
}

void DFS1( const int u, const int fa )
{
	dep[u] = dep[fa] + 1, f[u][0] = fa, siz[u] = 1, heavy[u] = -1;
	for( int i = head[u], v ; i ; i = Graph[i].nxt )
		if( ( v = Graph[i].to ) ^ fa )
		{
			DFS1( v, u ), siz[u] += siz[v];
			if( heavy[u] == -1 || siz[heavy[u]] < siz[v] ) heavy[u] = v;
		}
}

void DFS2( const int u, const int fa )
{
	seq[++ ID] = u, LPos[u] = ID;
	if( ~ heavy[u] ) DFS2( heavy[u], u ), bel[u] = bel[heavy[u]];
	else bel[u] = ++ tot;
	LTail[bel[u]] = u;
	for( int i = head[u], v ; i ; i = Graph[i].nxt )
		if( ( v = Graph[i].to ) ^ fa && v ^ heavy[u] )
			DFS2( v, u );
}

void init()
{
	lg2 = log2( N );
	for( int j = 1 ; j <= lg2 ; j ++ )
		for( int i = 1 ; i <= N ; i ++ )
			f[i][j] = f[f[i][j - 1]][j - 1];
}

int LCA( int u, int v )
{
	if( dep[u] > dep[v] ) balance( u, dep[u] - dep[v] );
	if( dep[v] > dep[u] ) balance( v, dep[v] - dep[u] );
	if( u == v ) return u;
	for( int i = lg2 ; ~ i ; i -- ) if( f[u][i] ^ f[v][i] ) u = f[u][i], v = f[v][i];
	return f[u][0];
}

void change( int u, int v, const int nVal )
{
	int lca = LCA( u, v );
	while( bel[lca] ^ bel[u] ) update( 1, 1, N, LPos[LTail[bel[u]]], LPos[u], nVal ), u = f[LTail[bel[u]]][0];
	while( bel[lca] ^ bel[v] ) update( 1, 1, N, LPos[LTail[bel[v]]], LPos[v], nVal ), v = f[LTail[bel[v]]][0];
	update( 1, 1, N, LPos[lca], LPos[u], nVal ), update( 1, 1, N, LPos[lca], LPos[v], nVal );
}

ui query( const int u )
{
	if( u == rt ) return query( 1, 1, N, 1, N );
	int lca = LCA( rt, u );
	if( lca ^ u ) return query( 1, 1, N, LPos[u], LPos[u] + siz[u] - 1 );
	else
	{
		int del = rt; balance( del, dep[rt] - dep[u] - 1 );
		return MIN( query( 1, 1, N, 1, LPos[del] - 1 ), query( 1, 1, N, LPos[del] + siz[del], N ) );
	}
}

int main()
{
	int u, v, opt, nVal;
	read( N ), read( M );
	for( int i = 1 ; i < N ; i ++ ) read( u ), read( v ), addEdge( u, v ), addEdge( v, u );
	for( int i = 1 ; i <= N ; i ++ ) read( def[i] );
	read( rt );
	DFS1( rt, 0 ), DFS2( rt, 0 ), init();
	build( 1, 1, N );
	while( M -- )
	{
		read( opt );
		if( opt == 1 ) read( rt );
		if( opt == 2 ) read( u ), read( v ), read( nVal ), change( u, v, nVal );
		if( opt == 3 ) read( u ), write( query( u ) ), putchar( '\n' );
	}
	return 0;
}
```

---

## 作者：Setsugesuka (赞：0)

看到链赋值，不难想到区间赋值。

$ODT$ 可以高效地解决这一类问题。

注意到题目中存在每次修改的节点不超过 $1$ 以及树的形态是一条链的部分分，事实上，当我们维护的树同时满足以上两种性质的时候，$ODT$ 并不能很好地维护。

这是因为当树是一条链的时候，树剖等于没有剖，每次修改又是单点修改，这就等价于我们在数组上作 $for$ 循环暴力，显然是会超时的。

于是我们只需要特判一下这种情况即可。

```cpp
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#include <bits/stdc++.h>
using namespace std;

template <class T>
inline void write(T x)
{
    if(x>9)
    {
        write(x/10);
    }
    putchar(x%10+'0');
}

inline char nc()
{
    static char buf[1000000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++;
}

inline void read(int &sum)
{
    char ch=nc();
    int tf=0;
    sum=0;
    while((ch<'0'||ch>'9')&&(ch!='-')) ch=nc();
    tf=((ch=='-')&&(ch=nc()));
    while(ch>='0'&&ch<='9') sum=sum*10+(ch-48),ch=nc();
    (tf)&&(sum=-sum);
}

const int MAXN=1e6+10;
const long long INF=0x3f3f3f3f;

struct edge
{
    int u,v,nex;
};

edge e[MAXN<<1];
int n,m,root,T;
int head[MAXN],cnt=0;
int a[MAXN];

inline void add(int u,int v)
{
    e[++cnt].u=u;
    e[cnt].v=v;
    e[cnt].nex=head[u];
    head[u]=cnt;
}

int dep[MAXN],fa[MAXN][30],son[MAXN],sz[MAXN],top[MAXN],id[MAXN],rk[MAXN],tot=0;

void dfs1(int u)
{
    sz[u]=1;
    for(int i=1;i<=T;++i)
    {
        fa[u][i]=fa[fa[u][i-1]][i-1];
        if(!fa[u][i]) break;
    }
    for(int i=head[u];i;i=e[i].nex)
    {
        int v=e[i].v;
        if(dep[v]) continue;
        fa[v][0]=u;
        dep[v]=dep[u]+1;
        dfs1(v);
        sz[u]+=sz[v];
        if(sz[v]>sz[son[u]])
            son[u]=v;
    }
}

void dfs2(int u,int tp)
{
    top[u]=tp;
    id[u]=++tot;
    rk[tot]=u;
    if(!son[u]) return;
    dfs2(son[u],tp);
    for(int i=head[u];i;i=e[i].nex)
    {
        int v=e[i].v;
        if(v!=fa[u][0]&&v!=son[u]) dfs2(v,v);
    }
}

inline int getfa(int u,int k)
{
    for(int i=T;i>=0;--i)
    {
        if(k>=(1<<i))
            u=fa[u][i],k-=(1<<i);
    }
    return u;
}

struct qnode
{
    int lx,x,y,z;
};

qnode q[MAXN];

namespace solve1
{
    long long tre[MAXN],s[MAXN];

    inline int lowbit(int x)
    {
        return x&(-x);
    }

    inline void update(int x)
    {
        while(x<=n)
        {
            tre[x]=s[x];
            int t=lowbit(x);
            for(int i=1;i<t;i<<=1)
                tre[x]=min(tre[x],tre[x-i]);
            x+=lowbit(x);
        }
    }

    inline long long query(int l,int r)
    {
        long long ret=INF;
        while(r>=l)
        {
            ret=min(ret,s[r]);
            --r;
            for(;r-lowbit(r)>=l;r-=lowbit(r))
                ret=min(ret,tre[r]);
        }
        return ret;
    }

    void main()
    {
        memset(tre,INF,sizeof(tre));
        for(int i=1;i<=n;++i)
            s[i]=a[rk[i]];
        for(int i=1;i<=n;++i)
            update(i);
        for(int i=1;i<=m;++i)
        {
            int op=q[i].lx;
            if(op==1)
                root=q[i].x;
            else if(op==2)
            {
                s[id[q[i].x]]=q[i].z;
                update(id[q[i].x]);
            }
            else
            {
                int x=q[i].x;
                long long ret;
                if(x==root)
                    ret=query(1,n);
                else
                {
                    int cc=getfa(root,dep[root]-dep[x]-1);
                    if(dep[x]<dep[root]&&fa[cc][0]==x)
                    {
                        ret=query(1,id[cc]-1);
                        if(id[cc]+sz[cc]<=n)
                            ret=min(ret,query(id[cc]+sz[cc],n));
                    }
                    else
                        ret=query(id[x],id[x]+sz[x]-1);
                }
                write(ret);
                putchar('\n');
            }
        }
    }
}

namespace solve2
{
    struct node
    {
        int l,r,v;
        node(){}
        node(int L,int R=-1,int V=0):l(L),r(R),v(V){}
        bool operator <(const node &o) const
        {
            return l<o.l;
        }
    };

    set<node> s;

    inline set<node>::iterator split(int pos)
    {
        set<node>::iterator it=s.lower_bound(node(pos));
        if(it!=s.end()&&it->l==pos) return it;
        --it;
        int L=it->l,R=it->r,V=it->v;
        s.erase(it);
        s.insert(node(L,pos-1,V));
        return s.insert(node(pos,R,V)).first;
    }

    inline void assignval(int l,int r,int v)
    {
        set<node>::iterator itr=split(r+1),itl=split(l);
        s.erase(itl,itr);
        s.insert(node(l,r,v));
    }

    inline int query(int l,int r)
    {
        int ret=INT_MAX;
        set<node>::iterator itr=split(r+1),itl=split(l);
        for(;itl!=itr;++itl)
            ret=min(ret,itl->v);
        return ret;
    }

    inline void change(int x,int y,int val)
    {
        while(top[x]!=top[y])
        {
            if(dep[top[x]]<dep[top[y]]) swap(x,y);
            assignval(id[top[x]],id[x],val);
            x=fa[top[x]][0];
        }
        if(id[x]>id[y]) swap(x,y);
        assignval(id[x],id[y],val);
    }

    void main()
    {
        for(int i=1;i<=n;++i)
            s.insert(node(i,i,a[rk[i]]));
        for(int i=1;i<=m;++i)
        {
            int op=q[i].lx;
            if(op==1)
                root=q[i].x;
            else if(op==2)
                change(q[i].x,q[i].y,q[i].z);
            else
            {
                int x=q[i].x,ret;
                if(x==root)
                    ret=query(1,n);
                else
                {
                    int cc=getfa(root,dep[root]-dep[x]-1);
                    if(dep[x]<dep[root]&&fa[cc][0]==x)
                    {
                        ret=query(1,id[cc]-1);
                        if(id[cc]+sz[cc]<=n)
                            ret=min(ret,query(id[cc]+sz[cc],n));
                    }
                    else
                        ret=query(id[x],id[x]+sz[x]-1);
                }
                write(ret);
                putchar('\n');
            }
        }
    }
}

int main()
{
    bool flag1=true,flag2=true;
    read(n),read(m);
    T=(int)(log(n)/log(2))+1;
    for(int i=1;i<n;++i)
    {
        int x,y;
        read(x),read(y);
        add(x,y);
        add(y,x);
        if(abs(x-y)!=1)
            flag2=false;
    }
    for(int i=1;i<=n;++i)
        read(a[i]);
    read(root);
    for(int i=1;i<=m;++i)
    {
        read(q[i].lx);
        if(q[i].lx==1)
            read(q[i].x);
        else if(q[i].lx==2)
        {
            read(q[i].x),read(q[i].y),read(q[i].z);
            if(q[i].x!=q[i].y)
                flag1=false;
        }
        else
            read(q[i].x);
    }
    dep[1]=1;
    dfs1(1);
    dfs2(1,1);
    if(flag1&&flag2)
        solve1::main();
    else
        solve2::main();
    return 0;
}
```


---

## 作者：_ctz (赞：0)

一道换根树剖好题，思维很巧妙

去食堂时开玩笑跟机房数据结构之神说树剖可以换根，他一本正经的说：“树剖真的可以换根。”然后当晚考试就考了这道题。~~（一口毒奶）~~

本题要求:换根+链修改+子树min

换根和链修改首先可以想到LCT，然而LCT弱于维护子树，这种维护子树最值更是麻烦。

考虑树剖。换根肯定不能重构树剖。那就转化一下？

画个图看看：

![](https://cdn.luogu.com.cn/upload/pic/51549.png)

换完后长这样：

![](https://cdn.luogu.com.cn/upload/pic/51551.png) 

（x为原树根，y为要换的根）

抽象点理解，就是**把y拎了起来**（可以在脑中yy一个GIF）

注意到，点1和点x子树变了，其他的都没变。这两个点都是y的祖先，也就是说原树中为y的祖先的点子树变了

抽象来说，对于某个点，y本来在它下面。现在要把在它下面的点y拎到上面去变成根，那么本来在它上面的点就要坠下去变成它的子树，而本来在它下面的点就要跑到上面去，从它的子树中分开。（可能很绕口。。。）

那它的子树变成啥了？在原树中从y向上跳，一直到它的某一个儿子，那么**整棵树-这个儿子的子树=它的新子树**

为什么呢？假设y向上跳到的它的儿子为z，z的子树都会跑到它的上面，而它上面的点成了它的新子树，再加上它原子树中剩下的点就是新子树

（z的子树+它原子树中不是z的子树的点+它上面的点【不是它子树中的点】=整棵树，它原子树中不是z的子树的点+它上面的点=新子树->整棵树-z的子树=它的新子树）

然后就是怎么跳了。当然可以用倍增LCA。不过树剖写都写了，怎么能不好好用用树剖呢？考虑直接跳重链（假设从x跳到y的儿子z）：

1.如果z是y的重儿子，一定会有某一时刻top[x]==top[y]（因为它们在同一条重链上），那就返回y的重儿子

2.如果z是y的轻儿子，一定会有某一时刻top[x]的父亲是y，那就返回top[x]（可以画个图理解）

这样就可以不改变树的结构换根了QwQ

最后说一下小细节：

1.数据范围是小于**等于**$2^{31}$，等于的话会爆int啊，也不要像我一样inf只开到0x3f3f3f3f，WA调了一小时。。。

2.可以用LCA来判断是否是当前树根的祖先。而且树剖都写了，正好用树剖求LCA，省空间省时间省码量（而且据说树剖LCA比倍增常数小）

3.树剖大法好！

上代码：
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>

#define maxn 100005
#define inf 0x3f3f3f3f

const long long INF = 1e11;

using namespace std;

inline int read(){
    int x=0,y=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return y?-x:x;
}
template<class T>
inline T read(){
    T x=0;
    int y=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar()；}
    while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return y?-x:x;
}//快读
int head[maxn],num;
struct edge{
    int pre,to;
}e[maxn<<1];
inline void add(int from,int to){
    e[++num].pre=head[from],head[from]=num,e[num].to=to;
}//邻接表
long long a[maxn];
int seg[maxn],top[maxn],pos[maxn],deep[maxn],fa[maxn],son[maxn],siz[maxn],cap;
//seg就是树剖第二次dfs打的标记，cap是当前首都
struct Segment_Tree{
#define ls(x) (x<<1)
#define rs(x) (x<<1|1)
    long long dat[maxn<<2];
    int tag[maxn<<2];
    inline void update(int node){
        dat[node]=min(dat[ls(node)],dat[rs(node)]);
    }
    inline void pushdown(int node){
        dat[ls(node)]=dat[rs(node)]=dat[node];
        tag[ls(node)]=tag[rs(node)]=1;
        tag[node]=0;
    }
    void build(int l,int r,int node){
        if(l==r){
            dat[node]=a[pos[l]];
            return;
        }
        int mid=l+r>>1;
        build(l,mid,ls(node));
        build(mid+1,r,rs(node));
        update(node);
    }
    void change(int L,int R,int l,int r,int node,long long d){
        if(L<=l&&R>=r){
            dat[node]=d,tag[node]=1;
            return;
        }
        if(tag[node])pushdown(node);
        int mid=l+r>>1;
        if(L<=mid)change(L,R,l,mid,ls(node),d);
        if(R>mid)change(L,R,mid+1,r,rs(node),d);
        update(node);
    }
    long long ask(int L,int R,int l,int r,int node){
        if(L<=l&&R>=r)return dat[node];
        if(tag[node])pushdown(node);
        int mid=l+r>>1;
        long long ans=INF;
        if(L<=mid)ans=ask(L,R,l,mid,ls(node));
        if(R>mid)ans=min(ans,ask(L,R,mid+1,r,rs(node)));
        return ans;
    }
};//线段树
struct Tree_Chain_Spilt{
//问一句，有谁知道树剖真正的英文名是啥吗。。。我强迫症受不了啊。。。
    Segment_Tree st;
    void dfs1(int node){
        siz[node]=1;
        for(register int i=head[node];i;i=e[i].pre){
            if(!siz[e[i].to]){
                fa[e[i].to]=node;
                deep[e[i].to]=deep[node]+1;
                dfs1(e[i].to);
                if(siz[e[i].to]>siz[son[node]])son[node]=e[i].to;
                siz[node]+=siz[e[i].to];
            }
        }
    }
    void dfs2(int node){
        seg[node]=++seg[0];
        pos[seg[0]]=node;
        if(son[node]){
            top[son[node]]=top[node];
            dfs2(son[node]);
            for(register int i=head[node];i;i=e[i].pre)
                if(!seg[e[i].to]){
                    top[e[i].to]=e[i].to;
                    dfs2(e[i].to);
                }
        }
    }
    int lca(int x,int y){
        while(top[x]!=top[y]){
            if(deep[top[x]]<deep[top[y]])swap(x,y);
            x=fa[top[x]];
        }
        return deep[x]<deep[y]?x:y;
    }//树剖求LCA
    void change(int x,int y,int d){
        while(top[x]!=top[y]){
            if(deep[top[x]]<deep[top[y]])swap(x,y);
            st.change(seg[top[x]],seg[x],1,seg[0],1,d);
            x=fa[top[x]];
        }
        if(deep[x]<deep[y])swap(x,y);
        st.change(seg[y],seg[x],1,seg[0],1,d);
    }
    int Get(int x,int y){
        while(top[x]!=top[y]&&fa[top[y]]!=x)y=fa[top[y]];	
        if(fa[top[y]]==x)return top[y];
        return son[x];
    }//向上跳的函数
    long long ask(int x){
        if(x==cap)return st.dat[1];//注意特判查询首都
        else if(lca(cap,x)==x){//用LCA判断x是否是cap的祖先
            int k=Get(x,cap);
            long long ans=INF;
            if(seg[k]>1)ans=st.ask(1,seg[k]-1,1,seg[0],1);
            if(seg[k]+siz[k]<=seg[0])ans=min(ans,st.ask(seg[k]+siz[k],seg[0],1,seg[0],1));
            //注意判一下seg的边界，不过好像不判也行。。
            return ans;
        }
        else return st.ask(seg[x],seg[x]+siz[x]-1,1,seg[0],1);
    }
}tcs;
int main(){
    int n=read(),m=read();
    for(register int i=1;i<n;++i){
        int x=read(),y=read();
        add(x,y),add(y,x);
    }
    for(register int i=1;i<=n;++i)
        a[i]=read<long long>();
    cap=read();
    tcs.dfs1(cap);
    tcs.dfs2(cap);
    tcs.st.build(1,seg[0],1);
    while(m--){
        int s=read();
        if(s==1)cap=read();
        else if(s==2){
            int x=read(),y=read();
            long long d=read<long long>();
            tcs.change(x,y,d);
        }
        else {
            int x=read();
            printf("%lld\n",tcs.ask(x));
        }
    }
    return 0;
}
```

---

## 作者：白いバラの夜 (赞：0)

给定一棵有根树，每个点有一个权值，提供三种操作： 

1. 将x节点变为根节点 
2. 将x到y路径上的点的权值全部改为v 

3. 询问x的子树中点权的最小值

这种题一看就是树链剖分，只不过开始没初始化WA了一次

分类小讨论一波，容易发现，rt=x的时候就是整个子树，x在rt到根的路径上时就是整个树去掉x到rt方向上第一个点的子树，这个在树剖上跑一下就行了，不在重链上直接跳，否则用dfs序取出重链上的某个距离上的点。然后就是把dfs序分成2个区间求解。否则就是正常的求子树。 
一开始以为权值能是0，网上搞了一份代码下来拍，把tag值改成1e15，结果标记下放完tag=0,调了7days可以说是很灵性了。

可爱的代码：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int N=1e5+5;
int n,m,a[N],cnt,ans[N<<2],mar[N<<2],head[N];
int d[N],f[N],son[N],size[N],top[N],id[N],rk[N];
struct edge{
    int v,nex;
}e[N<<2];
void addedge(int u,int v){
    e[++cnt]=(edge){v,head[u]};
    head[u]=cnt;
}
void dfs(int u){
    size[u]=1;
    for(int i=head[u];i;i=e[i].nex){
        int v=e[i].v;
        if(v==f[u])continue;
        d[v]=d[u]+1;
        f[v]=u;
        dfs(v);
        size[u]+=size[v];
        if(size[son[u]]<size[v])son[u]=v;
    }
}
void dfs2(int u,int t){
    top[u]=t;id[u]=++cnt;rk[cnt]=u;
    if(son[u])dfs2(son[u],t);
    for(int i=head[u];i;i=e[i].nex){
        int v=e[i].v;
        if(v==f[u]||v==son[u])continue;
        dfs2(v,v);
    }
}
void build(int l,int r,int id){
    if(l==r){
        ans[id]=a[rk[l]];
        return;
    }
    int mid=(l+r)>>1;
    build(l,mid,id<<1);
    build(mid+1,r,id<<1|1);
    ans[id]=min(ans[id<<1],ans[id<<1|1]);
}
bool get(int x,int y){
    if(id[x]>id[y]||id[x]+size[x]-1<id[y])return 0;
    return 1;
}
void pushdown(int l,int r,int id){
    if(!mar[id])return;
    ans[id<<1]=ans[id<<1|1]=mar[id<<1]=mar[id<<1|1]=mar[id];
    mar[id]=0;
}
void add(int nl,int nr,int k,int l,int r,int id){
    if(nl<=l&&r<=nr){
        ans[id]=mar[id]=k;
        return;
    }
    pushdown(l,r,id);
    int mid=(l+r)>>1;
    if(nl<=mid)add(nl,nr,k,l,mid,id<<1);
    if(nr>mid)add(nl,nr,k,mid+1,r,id<<1|1);
    ans[id]=min(ans[id<<1],ans[id<<1|1]);
}
void change(int x,int y,int k){
    while(top[x]!=top[y]){
        if(d[top[x]]<d[top[y]])swap(x,y);
        add(id[top[x]],id[x],k,1,n,1);
        x=f[top[x]];
    }
    if(d[x]>d[y])swap(x,y);
    add(id[x],id[y],k,1,n,1);
}
int found(int nl,int nr,int l,int r,int id){
    if(nl<=l&&r<=nr)return ans[id];
    pushdown(l,r,id);
    int mid=(l+r)>>1,res=0x7fffffff;
    if(nl<=mid)res=min(res,found(nl,nr,l,mid,id<<1));
    if(nr>mid)res=min(res,found(nl,nr,mid+1,r,id<<1|1));
    return res;
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<n;i++){
        int u,v;
        scanf("%d%d",&u,&v);
        addedge(u,v);
        addedge(v,u);
    }
    for(int i=1;i<=n;i++)scanf("%d",&a[i]);
    cnt=0,dfs(1),dfs2(1,1);
    build(1,n,1);
    int r;
    scanf("%d",&r);
    int op,x,y,k;
    while(m--){
        scanf("%d%d",&op,&x);
        if(op==1)r=x;
        else if(op==2){
            scanf("%d%d",&y,&k);
            change(x,y,k);
        }
        else{
            if(x==r)printf("%d\n",ans[1]);
            else if(get(x,r)){
                int fa=0;
                for(int i=head[x];i;i=e[i].nex){
                    if(get(e[i].v,r)){
                        fa=e[i].v;
                        break;
                    }
                }
                int res=found(1,id[fa]-1,1,n,1);
                if(id[fa]+size[fa]<=n)res=min(res,found(id[fa]+size[fa],n,1,n,1));
                printf("%d\n",res);
            }
            else printf("%d\n",found(id[x],id[x]+size[x]-1,1,n,1));
        }
    }
}
```

---

## 作者：ldxcaicai (赞：0)

这题如果没有操作$1$就是一个裸的树链剖分：操作$2$路径修改，操作$3$维护子树和。

那么在加入了操作$1$之后，操作$2$的部分显然没有发生变化
代码：
```
inline void change(int x,int y,long long v){
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		update(1,num[top[x]],num[x],v);
		x=fa[top[x]];
	}
	if(dep[x]<dep[y])swap(x,y);
	update(1,num[y],num[x],v);
}
```
其中$update$是指线段树的区间修改操作，$num$数组记录$dfs$序。

所以我们只需要考虑换根对维护子树和信息的影响，那么我们可以分类讨论一波：

我们设当前询问的子树的根为$u$,当前的根节点为$root$。

**第一种情况：$lca$($u$,$root$)！=$u$**，那么我们发现在以$root$为根时$u$原来的子树就是现在的子树，直接线段树区间查询。

**第二种情况：$u$==$root$**，那么此时$u$就是根节点，直接返回线段树根节点的$maxn$值

**第三种情况：$root$在$u$原来的子树内,即$lca$($root$,$u$)==$u$&&$u$!=$root$**,怎么做呢？
我们找到$u$在$root$->$u$这条链上$u$的儿子$s$，那么子树$s$的补集就是我们查询的区间。

没有其他情况了

贴一发代码
```
#include<bits/stdc++.h>
#define N 100005
#define lc (p<<1)
#define rc (p<<1|1)
#define mid (T[p].l+T[p].r>>1)
using namespace std;
inline long long read(){
	long long ans=0;
	char ch=getchar();
	while(!isdigit(ch))ch=getchar();
	while(isdigit(ch))ans=(ans<<3)+(ans<<1)+ch-'0',ch=getchar();
	return ans;
}
struct Node{int l,r;long long minn,lz;}T[N<<2];
struct node{int v,next;}e[N<<1];
long long a[N];
int first[N],dep[N],top[N],fa[N],hson[N],siz[N],num[N],pred[N],root,n,m,cnt=0,tot=0;
inline void add(int u,int v){e[++cnt].v=v,e[cnt].next=first[u],first[u]=cnt;}
inline void dfs1(int p){
	siz[p]=1,hson[p]=0;
	for(int i=first[p];i;i=e[i].next){
		int v=e[i].v;
		if(v==fa[p])continue;
		fa[v]=p,dep[v]=dep[p]+1,dfs1(v),siz[p]+=siz[v];
		if(siz[v]>siz[hson[p]])hson[p]=v;
	}
}
inline void dfs2(int p,int tp){
	top[p]=tp,num[p]=++tot,pred[tot]=p;
	if(hson[p])dfs2(hson[p],tp);
	for(int i=first[p];i;i=e[i].next){
		int v=e[i].v;
		if(v!=fa[p]&&v!=hson[p])dfs2(v,v);
	}
}
inline long long min(long long a,long long b){return a<b?a:b;}
inline void pushup(int p){T[p].minn=min(T[lc].minn,T[rc].minn);}
inline void pushnow(int p,long long v){T[p].minn=v,T[p].lz=v;}
inline void pushdown(int p){
	if(T[p].lz==0)return;
	pushnow(lc,T[p].lz),pushnow(rc,T[p].lz),T[p].lz=0;
}
inline void build(int p,int l,int r){
	T[p].l=l,T[p].r=r,T[p].lz=0;
	if(l==r){T[p].minn=a[pred[l]];return;}
	build(lc,l,mid);
	build(rc,mid+1,r);
	pushup(p);
}
inline void update(int p,int ql,int qr,long long v){
	if(T[p].l>qr||T[p].r<ql)return;
	if(ql<=T[p].l&&T[p].r<=qr){pushnow(p,v);return;}
	pushdown(p);
	if(qr<=mid)update(lc,ql,qr,v);
	else if(ql>mid)update(rc,ql,qr,v);
	else update(lc,ql,mid,v),update(rc,mid+1,qr,v);
	pushup(p);
}
inline long long query(int p,int ql,int qr){
	if(T[p].l>qr||T[p].r<ql)return 1e16;
	if(ql<=T[p].l&&T[p].r<=qr)return T[p].minn;
	pushdown(p);
	if(qr<=mid)return query(lc,ql,qr);
	if(ql>mid)return query(rc,ql,qr);
	return min(query(lc,ql,mid),query(rc,mid+1,qr));
}
inline void change(int x,int y,long long v){
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		update(1,num[top[x]],num[x],v);
		x=fa[top[x]];
	}
	if(dep[x]<dep[y])swap(x,y);
	update(1,num[y],num[x],v);
}
inline int lca(int x,int y){
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		x=fa[top[x]];
	}
	return dep[x]<dep[y]?x:y;
}
inline int fid(int x,int y){
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		if(fa[top[x]]==y)return top[x];
		x=fa[top[x]];
	}
	if(dep[x]<dep[y])swap(x,y);
	return hson[y];
}
int main(){
	n=read(),m=read();
	for(int i=1;i<n;++i){
		int u=read(),v=read();
		add(u,v),add(v,u);
	}
	for(int i=1;i<=n;++i)a[i]=read();
	root=read();
	dfs1(root);
	dfs2(root,root);
	build(1,1,n);
	while(m--){
		int op=read(),u=read();
		if(op==1){root=u;continue;}
		if(op==2){int v=read();long long w=read();change(u,v,w);continue;}
		if(u==root){printf("%lld\n",T[1].minn);continue;}
		int t=lca(u,root);
		if(t!=u){printf("%lld\n",query(1,num[u],num[u]+siz[u]-1));continue;}
		int s=fid(u,root);
		printf("%lld\n",min(query(1,1,num[s]-1),query(1,num[s]+siz[s],n)));
	}
	return 0;
}
```



---


# [SDOI2016] 游戏

## 题目描述

Alice 和 Bob 在玩一个游戏。

游戏在一棵有 $n$ 个点的树上进行。最初，每个点上都只有一个数字，那个数字是 $123456789123456789$。

有时，Alice 会选择一条从 $s$ 到 $t$ 的路径，在这条路径上的每一个点上都添加一个数字。对于路径上的一个点 $r$，若 $r$ 与 $s$ 的距离是 $dis$，那么 Alice 在点 $r$ 上添加的数字是 $a\times dis+b$。

有时，Bob 会选择一条从 $s$ 到 $t$ 的路径。他需要先从这条路径上选择一个点，再从那个点上选择一个数字。

Bob 选择的数字越小越好，但大量的数字让 Bob 眼花缭乱。Bob 需要你帮他找出他能够选择的最小的数字。


## 说明/提示

测试点 1 ~ 2：$ n \leq 10 $，$ m \leq 10 $，$ | a | \leq 10000 $；

测试点 3 ~ 4：$ n \leq 1000 $，$ m \leq 1000 $，$ | a | \leq 10000 $；

测试点 5：$ n \leq 100000 $，$ m \leq 100000 $，$ a = 0 $，树是一条链；

测试点 6 ~ 7：$ n \leq 100000 $，$ m \leq 100000 $，$ a = 0 $；

测试点 8：$ n \leq 100000 $，$ m \leq 100000 $，$ a = 1 $，树是一条链；

测试点 9 ~ 10：$ n \leq 100000 $，$ m \leq 100000 $，$ a = 1 $；

测试点 11 ~ 13：$ n \leq 100000 $，$ m \leq 100000 $，$ | a | \leq 10000 $，树是一条链；

测试点 14 ~ 20：$ n \leq 100000 $，$ m \leq 100000 $，$ | a | \leq 10000 $。

对于所有数据，$0\le w, |b|\le 10^9$。

## 样例 #1

### 输入

```
3 5
1 2 10
2 3 20
2 1 3
1 2 3 5 6
2 2 3
1 2 3 -5 -6
2 2 3```

### 输出

```
123456789123456789
6
-106```

# 题解

## 作者：disangan233 (赞：26)

### 思路

由$a\times dis + b$可以看出这个东西是个一次函数。  
然后你就会发现这个东西可以用**永久化标记的李超线段树**做。   

* 仔细分析这个柿子：    
  $$ans=max\{ a\times (dis[i]-dis[s])+ b\}\ \ \ i\in \{s,\cdots t\}$$
  

然后把它优雅地拆开，令$x=lca(s,t)$。
* 那么$s$到$x$就可以表示为这么一条直线：   
  $$y=-a\times dis[i]+(a\times dis[s]+b)\ \ \ i\in \{s,\cdots x\}$$
* $t$到$x$同理为：  
  $$y=a\times dis[i]+a\times (dis[s]-2\times dis[x])\ \ \ i\in \{s,\cdots x\}$$

于是直接上李超线段树，用树链剖分维护树上的$id[i]$，并对线段树里记录一个原始编号$bel[id[i]]=i$，每次的$dis[i]$就可以求了。
* 记得要`push_up()`来维护线段树的最小值，其他就跟模板一样。
  
### Code  
```
#include<bits/stdc++.h>
using namespace std;
#define db double
#define re register int
#define ak *
#define ll long long
#define inf 123456789123456789ll
char qwq;
inline char getch()
{
	static char buf[10000],*p1=buf,*p2=buf;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,10000,stdin),p1==p2)?EOF:*p1++;
}
inline int read()
{
	re lf=0,ioi=1;qwq=getch();
	while(qwq<'0'||qwq>'9') ioi=qwq=='-'?~ioi+1:1,qwq=getch();
	while(qwq>='0'&&qwq<='9') lf=(lf<<3)+(lf<<1)+(qwq^48),qwq=getch();
	return lf ak ioi;
}
#define ls(x) (x<<1)
#define rs(x) (x<<1|1)
int n,m,tot,h[100005],cnt,dep[100005],top[100005],son[100005];
int size[100005],id[100005],bel[100005],fa[100005];
ll k[400005],b[400005],mn[400005],t[400005],dis[100005];
struct did{int next,to,w;}e[200005];
inline void add(re x,re y,re z)
{
	e[++cnt]=(did){h[x],y,z},h[x]=cnt;
	e[++cnt]=(did){h[y],x,z},h[y]=cnt;
}
void build(re p,re l,re r)
{
	mn[p]=inf;t[p]=1;
	if(l==r) return;
	re mid=(l+r)>>1;
	build(ls(p),l,mid);build(rs(p),mid+1,r);
}
inline ll cal(re x,re id) {return k[id]*dis[bel[x]]+b[id];}
inline void push_up(re x) {mn[x]=min(mn[x],min(mn[ls(x)],mn[rs(x)]));}
void update(re nl,re nr,re p,re l,re r,re x)
{
	re mid=(l+r)>>1;
	if(nl<=l&&r<=nr)
	{
		if(cal(l,x)<=cal(l,t[p])&&cal(r,x)<=cal(r,t[p]))
		{
			t[p]=x,mn[p]=min(mn[p],min(cal(l,x),cal(r,x)));
			return;
		}
		if(cal(l,x)>=cal(l,t[p])&&cal(r,x)>=cal(r,t[p])) return;
		if(k[x]<k[t[p]])
		{
			if(cal(mid,x)<=cal(mid,t[p])) update(nl,nr,ls(p),l,mid,t[p]),t[p]=x;
			else update(nl,nr,rs(p),mid+1,r,x);
		}
		else
		{
			if(cal(mid,x)<=cal(mid,t[p])) update(nl,nr,rs(p),mid+1,r,t[p]),t[p]=x;
			else update(nl,nr,ls(p),l,mid,x);
		}
		return mn[p]=min(mn[p],min(cal(l,x),cal(r,x))),push_up(p),void();
	}
	if(nl<=mid) update(nl,nr,ls(p),l,mid,x);
	if(nr>mid) update(nl,nr,rs(p),mid+1,r,x);
	push_up(p);
}
ll query(re ql,re qr,re p,re l,re r)
{
	if(ql<=l&&r<=qr) return mn[p];
	re mid=(l+r)>>1;ll res=inf;
	if(b[t[p]]!=inf) res=min(cal(max(l,ql),t[p]),cal(min(r,qr),t[p]));
	if(ql<=mid) res=min(res,query(ql,qr,ls(p),l,mid));
	if(mid<qr) res=min(res,query(ql,qr,rs(p),mid+1,r));
	return res;
}
void dfs1(re u,re prt)
{
	fa[u]=prt,dep[u]=dep[prt]+1,size[u]=1;
	for(re i=h[u],v;v=e[i].to,i;i=e[i].next)
	{
		if(v==prt) continue;
		dis[v]=dis[u]+e[i].w;dfs1(v,u);size[u]+=size[v];
		if(size[v]>size[son[u]]) son[u]=v;
	}
}
void dfs2(re u,re tp)
{
	top[u]=tp,bel[id[u]=++id[0]]=u;
	if(son[u]) dfs2(son[u],tp);
	for(re i=h[u],v;v=e[i].to,i;i=e[i].next)
	if(v!=fa[u]&&v!=son[u]) dfs2(v,v);
}
inline int lca(re u,re v)
{
	while(top[u]!=top[v]) dep[top[u]]>dep[top[v]]?u=fa[top[u]]:v=fa[top[v]];
	return dep[u]>dep[v]?v:u;
}
inline void updrange(re u,re v)
{
	while(top[u]!=top[v]) update(id[top[u]],id[u],1,1,n,tot),u=fa[top[u]];
	update(id[v],id[u],1,1,n,tot);
}
inline ll ask(re u,re v)
{
	ll ans=inf;
	while(top[u]!=top[v])
	{
		if(dep[top[u]]<dep[top[v]]) swap(u,v);
		ans=min(ans,query(id[top[u]],id[u],1,1,n));
		u=fa[top[u]];
	}
	if(dep[u]>dep[v]) swap(u,v);
	return min(ans,query(id[u],id[v],1,1,n));
}
int main()
{
	n=read(),m=read();
	for(re i=1;i<n;i++)
	{
		re a=read(),b=read(),c=read();
		add(a,b,c);
	}
	dfs1(1,0);dfs2(1,1);
	k[++tot]=0,b[tot]=inf;build(1,1,n);
	while(m--)
	{
		ll op=read(),s=read(),t=read(),w=lca(s,t),x,y;
		if(op==1)
		{
			x=read(),y=read();
			k[++tot]=-x,b[tot]=x*dis[s]+y;updrange(s,w);
			k[++tot]=x,b[tot]=x*(dis[s]-(dis[w]<<1))+y;updrange(t,w);
		}
		else printf("%lld\n",ask(s,t));
	}
	return 0;
}
```

---

## 作者：SovietPower✨ (赞：17)

每次在路径上加的数是个一次函数，容易看出是树剖+李超线段树维护函数最小值。~~所以其实依旧是模板题。~~

横坐标自然是取个确定的距离标准。取每个点到根节点的距离$dis[i]$作为$i$的横坐标好了，这样对于同一条重链，横坐标还是递增的。

令$w=LCA(u,v)$。如果在$(u,v)$路径上加入直线$y=kx+b$：

对于在$u\to w$路径上的点，每个点$i$的横坐标就是$dis_u-dis_i$，所以对于$i$，$y=k(dis_u-dis_i)+b=-k\cdot dis_i+k\cdot dis_u+b$，依旧是原坐标系一条$k=-k,\quad b=k\cdot dis_u+b$的直线。所以直接树剖+线段树维护即可。

另一条$w\to v$的路径同理。

线段树的每个节点维护它以及它儿子中的最小值$mn[rt]$（每个节点维护的都是一条直线，所以最小值显然就在两端点中取）。

区间查询的时候，如果当前区间完全包含于询问区间，就直接返回$mn[rt]$；否则答案与当前点维护的线段两端点的函数值取个$\min$，继续递归即可。

这样区间修改+树剖的复杂度是$O(n\log^3n)$，你只要相信树剖+李超线段树的常数很小就好了。。

[一个可能的解释](https://www.cnblogs.com/1-1-1-1/p/6690641.html)：
> 一.因为一个线段的交点正好在区间的左数第二个点和右数第二个点的几率特别小，所以每次二分不一定要到末尾才结束，所以一般可以把交点平均在二分中间时刻停止，因此这里有个二分之一的常数；二.线段树不一定是最坏情况(每层都有两个点)，所以这里有个约3/4的常数，又由于树链剖分不一定是最坏情况，所以这里又有个约1/2的常数，多亏了出题人良心)，所以这题$O(n\log^3n)$是可以通过的。

注意线段树里的下标都是代表DFS序中的$dis[i]$。

一份常数特别大的代码：

```cpp
#include <cstdio>
#include <cctype>
#include <assert.h>
#include <algorithm>
#define gc() getchar()
typedef long long LL;
const int N=1e5+5;
const LL INF=123456789123456789ll;

int n,H[N],Enum,nxt[N<<1],to[N<<1],len[N<<1],fa[N],dep[N],sz[N],son[N],top[N],dfn[N],ref[N];
LL dis[N];
struct Segment_Tree
{
	#define ls rt<<1
	#define rs rt<<1|1
	#define lson l,m,ls
	#define rson m+1,r,rs
	#define S N<<2
	LL K[S],B[S],mn[S],Lx[S],Rx[S],Mx[S];
	#undef S
	#define Update(rt) mn[rt]=std::min(mn[rt],std::min(mn[ls],mn[rs]))
	void Build(int l,int r,int rt)
	{
		B[rt]=mn[rt]=INF, Lx[rt]=dis[ref[l]], Rx[rt]=dis[ref[r]];
		if(l==r) return;
		int m=l+r>>1; Mx[rt]=dis[ref[m]], Build(lson), Build(rson);
	}
	void Modify(int l,int r,int rt,int L,int R,LL k,LL b)
	{
		if(L<=l && r<=R)
		{
			LL lx=Lx[rt],rx=Rx[rt],l0=K[rt]*lx+B[rt],r0=K[rt]*rx+B[rt],l1=k*lx+b,r1=k*rx+b;
			if(l0<=l1 && r0<=r1) return;
			if(l1<=l0 && r1<=r0) {K[rt]=k, B[rt]=b, mn[rt]=std::min(mn[rt],std::min(l1,r1)); return;}//更新mn！
			int m=l+r>>1;
			LL mx=Mx[rt]; double p=1.0*(B[rt]-b)/(k-K[rt]);
			if(l0<l1)
				if(p<=(double)mx) Modify(lson,L,R,K[rt],B[rt]), K[rt]=k, B[rt]=b;
				else Modify(rson,L,R,k,b);
			else
				if(p<=(double)mx) Modify(lson,L,R,k,b);
				else Modify(rson,L,R,K[rt],B[rt]), K[rt]=k, B[rt]=b;
			mn[rt]=std::min(mn[rt],std::min(l1,r1)), Update(rt);//!
			return;
		}
		int m=l+r>>1;
		if(L<=m) Modify(lson,L,R,k,b);
		if(m<R) Modify(rson,L,R,k,b);
		Update(rt);
	}
	LL Query(int l,int r,int rt,int L,int R)
	{
		if(L<=l && r<=R) return mn[rt];
		LL res=INF;
		if(B[rt]!=INF)
		{
			LL lx=std::max(l,L),rx=std::min(r,R);
			res=std::min(K[rt]*dis[ref[lx]],K[rt]*dis[ref[rx]])+B[rt];
		}
		int m=l+r>>1;
		if(L<=m) res=std::min(res,Query(lson,L,R));
		if(m<R) res=std::min(res,Query(rson,L,R));
		return res;
	}
}T;

inline int read()
{
	int now=0,f=1;register char c=gc();
	for(;!isdigit(c);c=='-'&&(f=-1),c=gc());
	for(;isdigit(c);now=now*10+c-'0',c=gc());
	return now*f;
}
inline void AE(int w,int u,int v)
{
	to[++Enum]=v, nxt[Enum]=H[u], H[u]=Enum, len[Enum]=w；
	to[++Enum]=u, nxt[Enum]=H[v], H[v]=Enum, len[Enum]=w；
}
inline int LCA(int u,int v)
{
	while(top[u]!=top[v]) dep[top[u]]>dep[top[v]]?u=fa[top[u]]:v=fa[top[v]];
	return dep[u]>dep[v]?v:u;
}
void DFS1(int x)
{
	int mx=0; sz[x]=1;
	for(int i=H[x],v; i; i=nxt[i])
		if((v=to[i])!=fa[x])
			fa[v]=x, dep[v]=dep[x]+1, dis[v]=dis[x]+len[i], DFS1(v), sz[x]+=sz[v], sz[v]>mx&&(mx=sz[v],son[x]=v);
}
void DFS2(int x,int tp)
{
	static int Index=0;
	top[x]=tp, ref[dfn[x]=++Index]=x;
	if(son[x])
	{
		DFS2(son[x],tp);
		for(int i=H[x],v; i; i=nxt[i])
			if((v=to[i])!=fa[x]&&v!=son[x]) DFS2(v,v);
	}
}
void Modify(int u,int w,LL k,LL b)
{
	while(top[u]!=top[w])
		T.Modify(1,n,1,dfn[top[u]],dfn[u],k,b), u=fa[top[u]];
	T.Modify(1,n,1,dfn[w],dfn[u],k,b);
}
LL Query(int u,int v)
{
	LL res=INF;
	while(top[u]!=top[v])
	{
		if(dep[top[u]]<dep[top[v]]) std::swap(u,v);
		res=std::min(res,T.Query(1,n,1,dfn[top[u]],dfn[u])), u=fa[top[u]];
	}
	if(dep[u]>dep[v]) std::swap(u,v);
	return std::min(res,T.Query(1,n,1,dfn[u],dfn[v]));
}

int main()
{
	n=read(); int m=read();
	for(int i=1; i<n; ++i) AE(read(),read(),read());
	DFS1(1), DFS2(1,1), T.Build(1,n,1);
	for(int i=1; i<=m; ++i)
		switch(read())
		{
			case 1:
			{
				int u=read(),v=read(),w=LCA(u,v),k=read(),b=read();
				Modify(u,w,-k,dis[u]*k+b), Modify(v,w,k,(dis[u]-(dis[w]<<1))*k+b);
				break;
			}
			case 2: printf("%lld\n",Query(read(),read())); break;
		}

	return 0;
}
```

---

## 作者：Rubyonly (赞：14)

首先看到 $a\times dis+b$，是一个一次函数的形式，不妨考虑先树剖一下，然后用李超树维护最大值

对于每次插入操作，先求出 $s$ 和 $t$ 的 $lca$，预处理出每个点到根节点的距离 $dis[u]$，然后化简一下式子

对于 $s$ 到 $lca$ 的那条路径上的点 $u$，增加的贡献是

$$a\times (dis[s]-dis[u])+b$$

$$=-a\times dis[u] + a\times dis[s] +b$$

对于 $t$ 到 $lca$ 的那条路径上的点，增加的贡献是

$$a\times (dis[s]+dis[u]-2\times dis[lca])+b$$

$$=a\times dis[u] + a\times (dis[s]-2\times dis[lca]) +b$$

然后就可以直接插入了

现在问题就剩如果维护区间最小值，容易发现对于一个区间内的线段，最小值无非就是从两个端点的地方取到，所以线段树上再维护一个区间最小值，每次 $Pushup$，最后区间查询的时候，经过的区间上存的优势线段也能为答案作出贡献，算上就好了

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

typedef long long ll;

using namespace std;

const int maxn = 2e5 + 50;
const ll INF = 123456789123456789;

inline int read () {
	register int x = 0, w = 1;
	register char ch = getchar ();
	for (; ch < '0' || ch > '9'; ch = getchar ()) if (ch == '-') w = -1;
	for (; ch >= '0' && ch <= '9'; ch = getchar ()) x = x * 10 + ch - '0';
	return x * w;
}

int n, m;

struct Line {
	int k;
	ll b;
	Line () {}
	Line (register int x, register ll y) { k = x, b = y; }
};

struct Tree {
	Line seg;
	ll val;
	Tree () { seg.k = 0, seg.b = val = INF; }
} tree[maxn << 2];

inline ll Calc (register Line a, register ll x) { return a.k * x + a.b; }

struct Edge {
	int to, next, w;
} e[maxn << 1];

int tot, head[maxn];

inline void Add (register int u, register int v, register int w) {
	e[++ tot].to = v;
	e[tot].w = w;
	e[tot].next = head[u];
	head[u] = tot;
}

int deep[maxn], size[maxn], son[maxn], f[maxn];
int tic, top[maxn], dfn[maxn], rk[maxn];
ll dis[maxn];

inline void DFS0 (register int u, register int fa) {
	deep[u] = deep[fa] + 1, size[u] = 1;
	for (register int i = head[u]; i; i = e[i].next) {
		register int v = e[i].to;
		if (v == fa) continue;
		dis[v] = dis[u] + e[i].w, f[v] = u, DFS0 (v, u), size[u] += size[v];
		if (size[son[u]] < size[v]) son[u] = v;
	}
}

inline void DFS1 (register int u, register int t) {
	top[u] = t, dfn[u] = ++ tic, rk[tic] = u;
	if (son[u]) DFS1 (son[u], t);
	for (register int i = head[u]; i; i = e[i].next) {
		register int v = e[i].to;
		if (v == f[u] || v == son[u]) continue;
		DFS1 (v, v);
	}
}

inline int LCA (register int u, register int v) {
	while (top[u] != top[v]) {
		if (deep[top[u]] < deep[top[v]]) swap (u, v);
		u = f[top[u]];
	}
	return deep[u] < deep[v] ? u : v;
}

inline void Pushup (register int rt, register int l, register int r) {
	tree[rt].val = min (tree[rt].val, min (Calc (tree[rt].seg, dis[rk[l]]), Calc (tree[rt].seg, dis[rk[r]])));
	tree[rt].val = min (tree[rt].val, min (tree[rt << 1].val, tree[rt << 1 | 1].val));
}

inline void Modify (register int rt, register int l, register int r, register int s, register int t, register Line x) {
	register int mid = (l + r) >> 1;
	if (s <= l && r <= t) {
		if (Calc (x, dis[rk[mid]]) < Calc (tree[rt].seg, dis[rk[mid]])) swap (tree[rt].seg, x);
		if (Calc (x, dis[rk[l]]) < Calc (tree[rt].seg, dis[rk[l]])) Modify (rt << 1, l, mid, s, t, x);
		if (Calc (x, dis[rk[r]]) < Calc (tree[rt].seg, dis[rk[r]])) Modify (rt << 1 | 1, mid + 1, r, s, t, x);
		return Pushup (rt, l, r), void ();
	}
	if (s <= mid) Modify (rt << 1, l, mid, s, t, x);
	if (t > mid) Modify (rt << 1 | 1, mid + 1, r, s, t, x);
	Pushup (rt, l, r);
}

inline ll Query (register int rt, register int l, register int r, register int s, register int t) {
	if (s <= l && r <= t) return tree[rt].val;
	register int mid = (l + r) >> 1;
	register ll ans = min (Calc (tree[rt].seg, dis[rk[max (l, s)]]), Calc (tree[rt].seg, dis[rk[min (r, t)]]));
	if (s <= mid) ans = min (ans, Query (rt << 1, l, mid, s, t));
	if (t > mid) ans = min (ans, Query (rt << 1 | 1, mid + 1, r, s, t));
	return ans;
}

inline void TreeModify (register int u, register int v, register Line x) {
	while (top[u] != top[v]) {
		if (deep[top[u]] < deep[top[v]]) swap (u, v);
		Modify (1, 1, n, dfn[top[u]], dfn[u], x), u = f[top[u]];
	}
	if (dfn[u] > dfn[v]) swap (u, v);
	Modify (1, 1, n, dfn[u], dfn[v], x);
}

inline ll TreeQuery (register int u, register int v, register ll ans = INF) {
	while (top[u] != top[v]) {
		if (deep[top[u]] < deep[top[v]]) swap (u, v);
		ans = min (ans, Query (1, 1, n, dfn[top[u]], dfn[u])), u = f[top[u]];
	}
	if (dfn[u] > dfn[v]) swap (u, v);
	return min (ans, Query (1, 1, n, dfn[u], dfn[v]));
}

int main () {
	n = read(), m = read();
	for (register int i = 1, u, v, w; i <= n - 1; i ++) 
		u = read(), v = read(), w = read(), Add (u, v, w), Add (v, u, w);
	DFS0 (1, 0), DFS1 (1, 1);
	while (m --) {
		register int opt = read(), u = read(), v = read();
		if (opt == 1) {
			register int a = read(), b = read(), lca = LCA (u, v);
			TreeModify (u, lca, Line (- a, a * dis[u] + b));
			TreeModify (lca, v, Line (a, a * dis[u] - 2 * a * dis[lca] + b));
		} else printf ("%lld\n", TreeQuery (u, v));
	}
	return 0;
}
```

---

## 作者：spider_oyster (赞：4)

不难看出 $a\times dis +b$ 是一次函数的样子。

这个样子不好维护，显然要让这条直线的 $x$ 为与 $s,t$ 无关的值。

- 记 $lca=\operatorname{lca}(s,t)$，则路径分两种情况：
- 对于路径 $(s,lca)$ 上的点 $i$，可以表示为 $a(dis_s-dis_i)+b$。
- 变式得 $-a\cdot dis_i+a \cdot dis_s+b$。
- 对于路径 $(lca,t)$ 上的点 $i$，可以表示为 $a(dis_s+dis_i-2\cdot dis_{lca})+b$。
- 变式得 $a\cdot dis_i+a\cdot (dis_s-2\cdot dis_{lca})+b$。

把 $dis_i$ 作为 $x$，则每次 Alice 操作就插入两条线段，用李超树维护即可。

插入的线段是在树上的，用树剖维护即可。

- 由于查询的是区间最小值，故李超树还要维护一个区间最小值。

- 注意到线段最值取在两端，故每次用当前区间的两端点更新最小值。

李超树维护线段是 $O(\log^2n)$ 的，再加上树剖跳链的复杂度，总复杂度 $O(n\log^3n)$。

~~5e8 现在计算机不是随便跑嘛。~~

我代码应该算比较短的吧。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

const int N=1e5+5;
const ll inf=123456789123456789;
int n,m,tot,sz[N],dep[N],fa[N],son[N];
int Ti,dfn[N],rev[N],top[N];
ll dis[N];
vector<pair<int,int>> G[N];
struct line{
    ll k,b;
    ll operator()(const int &x){return k*dis[rev[x]]+b;}
}p[N*2];
struct SegmentTree{
    ll mi[N<<2];
    int id[N<<2];
    #define lc (k<<1)
    #define rc (k<<1|1)
    #define mid ((l+r)>>1)
    inline ll min(ll x,ll y) {return x<y?x:y;}
    inline void init() {for(int i=1;i<=n*4;i++) mi[i]=inf;p[0].b=inf;}//把第 0 条线段值设为 inf
    inline void pushup(int k) {mi[k]=min(mi[k],min(mi[lc],mi[rc]));}

    void upd(int k,int l,int r,int u)
    {
        int &v=id[k];
        mi[k]=min(mi[k],min(p[u](l),p[u](r)));
        if(p[u](mid)<p[v](mid)) swap(u,v);
        if(l==r) return;
        if(p[u](l)<p[v](l)) upd(lc,l,mid,u);
        if(p[u](r)<p[v](r)) upd(rc,mid+1,r,u);
        pushup(k);
    }

    void update(int x,int y,int u,int k=1,int l=1,int r=n)
    {
        if(l>=x&&r<=y) return upd(k,l,r,u);
        if(x<=mid) update(x,y,u,lc,l,mid);
        if(mid<y) update(x,y,u,rc,mid+1,r);
        pushup(k);
    }

    ll query(int x,int y,int k=1,int l=1,int r=n)
    {
        if(l>=x&&r<=y) return mi[k];
        ll res=min(p[id[k]](max(l,x)),p[id[k]](min(r,y)));//注意区间和查询边界
        if(x<=mid) res=min(res,query(x,y,lc,l,mid));
        if(mid<y) res=min(res,query(x,y,rc,mid+1,r));
        return res;
    }
}T;

void dfs1(int u,int f,ll d)
{
    dep[u]=dep[f]+1,fa[u]=f,sz[u]=1,dis[u]=d;
    for(auto [v,w]:G[u])
    {
        if(v==f) continue;
        dfs1(v,u,d+w);
        sz[u]+=sz[v];
        if(sz[v]>sz[son[u]]) son[u]=v;
    }
}

void dfs2(int u,int topf)
{
    dfn[u]=++Ti,rev[Ti]=u,top[u]=topf;
    if(son[u]) dfs2(son[u],topf);
    for(auto [v,w]:G[u]) if(v!=fa[u]&&v!=son[u]) dfs2(v,v);
}

inline int LCA(int u,int v)
{
    while(top[u]!=top[v])
    {
        if(dep[top[u]]<dep[top[v]]) swap(u,v);
        u=fa[top[u]];
    }
    return dep[u]<dep[v]?u:v;
}

inline void modify(int u,int v)//注意 v 已经是 u 的 lca 了，可以直接跳
{
    while(top[u]!=top[v]) T.update(dfn[top[u]],dfn[u],tot),u=fa[top[u]];
    T.update(dfn[v],dfn[u],tot);
}

inline ll qmin(int u,int v)
{
    ll ans=inf;
    while(top[u]!=top[v])
    {
        if(dep[top[u]]<dep[top[v]]) swap(u,v);
        ans=min(ans,T.query(dfn[top[u]],dfn[u]));
        u=fa[top[u]];
    }
    if(dep[u]>dep[v]) swap(u,v);
    return min(ans,T.query(dfn[u],dfn[v]));
}

inline int rd()
{
    int x=0,f=1;char c=getchar();
    for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
    for(; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(c^48);
    return x*f;
}

int main()
{
    n=rd(),m=rd();
    for(int i=1,u,v,w;i<n;i++) u=rd(),v=rd(),w=rd(),G[u].push_back({v,w}),G[v].push_back({u,w});
    dfs1(1,0,0),dfs2(1,1);
    T.init();
    while(m--)
    {
        int op=rd(),s=rd(),t=rd();
        if(op==1)
        {
            int a=rd(),b=rd();
            int lca=LCA(s,t);
            p[++tot]={-a,a*dis[s]+b};//插入 (s,lca) 路径的线段
            modify(s,lca);
            p[++tot]={a,a*(dis[s]-dis[lca]*2)+b};//插入（lca,t）路径的线段
            modify(t,lca);
        }
        else printf("%lld\n",qmin(s,t));
    }
}
```


---

## 作者：不存在之人 (赞：4)

对于一次修改$(s,t,a,b)$，设$s$和$t$的最近公共祖先是$lca$。可以推出，当$x$节点在$s$到$lca$的路径上时，$x$节点上要添加的数字就是$-a*dist[x]+a*dist[s]+b$；当x节点在lca到t的路径上时，这个节点要添加的数字是$a*dist[x]+a*dist[s]-2*a*dist[lca]+b$

　　树剖转成序列，问题就变成了：支持给一个区间添加一条线段，询问区间最小值。

　　使用线段树来维护。

　　每一个节点上，都有且仅有一条线段，这条线段用$a$、$b$、$dl$、$dr$来描述，分别表示斜率、截距、左端点和右端点的自变量。

　　可以使用标记永久化，即没有下放标记的操作。线段树中记录了子树的最小值，使用传统的线段树查询时，当$l<=p->l$且$r>=p->r$时，应当直接返回所记录的子树中的最小值。否则，由于查询区间不完全包含当前区间，所以应该取$max(l,p->l)$和$min(r,p->r)$处的自变量在当前节点所对应的函数上的取值，让之参与最小值的比较。

　　其实算法的重点在于，怎样合并两条线段。

　　$case1$：如果新线段在当前节点的定义域中，完全小于原来的线段，那应当舍去原来的线段，并且用当前线段的两个端点更新最小值。

　　$case2$：新线段在当前节点的定义域中，完全大于原来的线段，应当舍去这条新线段。

　　$case3$：新加入的线段和原来的线段在当前的定义域中有交点。求一下两条线段的交点横坐标$x$。如果新线段的左端点大于旧线段的左端点，或$x<=mid$，就向左下放；如果新线段的右端点小于旧线段的右交点，或$x>mid$，就往右下放。
```cpp
#include<cstdio>
#include<algorithm>
#define ll long long
#define inf 123456789123456789ll
#define maxn 210000
#define maxk 17
using namespace std;
ll N,M,head[maxn],next[maxn],w[maxn],to[maxn],top[maxn],tid[maxn],tim,
    dist[maxn],size[maxn],son[maxn],fa[maxn],tot,anc[maxn][maxk+3],
    deep[maxn],untid[maxn];
struct segtree
{
    ll l,r,min,taga,tagb,dl,dr;
    segtree *lch,*rch;
    segtree(){min=inf;lch=rch=0;taga=0;tagb=inf;}
}*root;
void adde(ll a,ll b,ll v)
{
	to[++tot]=b;
	w[tot]=v;
	next[tot]=head[a];
	head[a]=tot;
}
ll f(ll a,ll b,ll x){return a*x+b;}
void addline(segtree *p,ll taga,ll tagb)
{
    ll f1,f2,f3,f4,x,mid;
    f1=f(p->taga,p->tagb,p->dl),f2=f(p->taga,p->tagb,p->dr);
    f3=f(taga,tagb,p->dl),f4=f(taga,tagb,p->dr);
    if(f3<=f1 and f4<=f2)
    {
        p->taga=taga,p->tagb=tagb;
        p->min=min(min(f3,f4),p->min);
        return;
    }
    if(f3>f1 and f4>f2) return;
    x=(tagb-p->tagb)/(p->taga-taga);
    mid=p->lch->dr;
    if(f3<=f1 or x<=mid) addline(p->lch,taga,tagb);
    if(f4<=f2 or x>mid) addline(p->rch,taga,tagb);
    p->min=min(p->min,min(p->lch->min,p->rch->min));
}
void segtag(segtree*p,ll l,ll r,ll a,ll b)
{
    ll mid=(p->l+p->r)>>1;
    if(l<=p->l and r>=p->r)
    {
        addline(p,a,b);
        return;
    }
    if(l<=mid) segtag(p->lch,l,r,a,b);
    if(r>mid) segtag(p->rch,l,r,a,b);
    p->min=min(p->min,min(p->lch->min,p->rch->min));
}
ll segmin(segtree*p,ll l,ll r)
{
    ll mid=(p->l+p->r)>>1,ans=inf;
    if(l<=p->l and r>=p->r) return p->min;
    if(l<=mid) ans=min(ans,segmin(p->lch,l,r));
    if(r>mid) ans=min(ans,segmin(p->rch,l,r));
    l=max(l,p->l),r=min(r,p->r);
    ans=min(ans,f(p->taga,p->tagb,dist[untid[l]]));
    ans=min(ans,f(p->taga,p->tagb,dist[untid[r]]));
    return ans;
}
void build(segtree*p,ll l,ll r)
{
    ll mid=(l+r)>>1;
    p->l=l,p->r=r;
    if(l==r){p->dl=p->dr=dist[untid[l]];return;}
    build(p->lch=new segtree,l,mid);
    build(p->rch=new segtree,mid+1,r);
    p->dl=p->lch->dl;p->dr=p->rch->dr;
}
void dfs1(ll pos)
{
    ll p,v;
    size[pos]=1;
    for(p=head[pos];p;p=next[p])
    {
        if((v=to[p])==fa[pos]) continue;
        fa[v]=pos;
        dist[v]=dist[pos]+w[p];
        deep[v]=deep[pos]+1;
        dfs1(v);
        if(size[v]>size[son[pos]]) son[pos]=v;
        size[pos]+=size[v];
    }
}
void dfs2(ll pos,ll tp)
{
    ll p,v;
    top[pos]=tp;
    tid[pos]=++tim;
    untid[tid[pos]]=pos;
    if(son[pos]) dfs2(son[pos],tp);
    for(p=head[pos];p;p=next[p])
        if((v=to[p])!=fa[pos] and v!=son[pos])dfs2(v,v);
}
ll findmin(ll a,ll b)
{
    ll ta=top[a],tb=top[b],ans=inf;
    while(ta!=tb)
    {
        if(deep[ta]<deep[tb]) swap(a,b),swap(ta,tb);
        ans=min(ans,segmin(root,tid[ta],tid[a]));
        a=fa[ta];ta=top[a];
    }
    if(deep[a]>deep[b])swap(a,b);
    ans=min(ans,segmin(root,tid[a],tid[b]));
    return ans;
}
void maketag(ll a,ll b,ll taga,ll tagb)
{
    ll ta=top[a],tb=top[b];
    while(ta!=tb)
    {
        if(deep[ta]<deep[tb]) swap(a,b),swap(ta,tb);
        segtag(root,tid[ta],tid[a],taga,tagb);
        a=fa[ta];ta=top[a];
    }
    if(deep[a]>deep[b])swap(a,b);
    segtag(root,tid[a],tid[b],taga,tagb);
}
void calcf()
{
    ll i, k;
    for(i=1;i<=N;i++) anc[i][0]=fa[i];
    for(k=1;k<=maxk;k++)
        for(i=1;i<=N;i++)
            anc[i][k]=anc[anc[i][k-1]][k-1];
}
ll LCA(ll x, ll y)
{
    ll k;
    if(deep[x]<deep[y])swap(x,y);
    for(k=maxk;k>=0;k--)
		if(deep[anc[x][k]]>=deep[y])
			x=anc[x][k];
    if(x==y)return x;
    for(k=maxk;k>=0;k--)
		if(anc[x][k]!=anc[y][k])
			x=anc[x][k],y=anc[y][k];
    return anc[x][0];
}
void solve()
{
    ll type,s,t,a,b,i,lca;
    for(i=1;i<=M;i++)
    {
        scanf("%lld%lld%lld",&type,&s,&t);
        if(type==1)
        {
            scanf("%lld%lld",&a,&b);
            lca=LCA(s,t);
            maketag(s,lca,-a,a*dist[s]+b);
            maketag(lca,t,a,a*dist[s]-2*a*dist[lca]+b);
        }
        else printf("%lld\n",findmin(s,t));
    }
}
void init()
{
    ll i,a,b,v;
    scanf("%lld%lld",&N,&M);
    for(i=1;i<N;i++)
		scanf("%lld%lld%lld",&a,&b,&v),adde(a,b,v),adde(b,a,v);
    deep[1]=1;
    dist[1]=0;
    dfs1(1);
    dfs2(1,1);
    calcf();
    build(root=new segtree,1,N);
}
int main()
{
    init();
    solve();
    return 0;
}
```

---

## 作者：Fizzmy (赞：4)



## Solution：

首先考虑树是一条链的情况：

我们可以把等差序列看成一个一次函数，然后转化一下题意：

1.区间插入一条线段

2.求区间内最靠下的点

显然可以用超哥线段树来解决



因为每条边的长度不同，所以我们需要引入一个dis数组，dis[i]表示i距根节点的距离

我们对于每个线段树节点所代表的区间维护一条线段，表示**在这个区间的所有最小值点中，有点在这条线段上**

考虑在一个区间$[l,r]$中已经有一条线段f1，现在我们再加入一条线段f2，求出f1的在l的取值l1，在r的取值r1和f2在l,r的取值l2,r2，那么我们就可以分类讨论：

1.l1<=l2,r1<=r2 显然f2没有任何点会比f1优，直接退出即可

2.l1>l2 r1>r2 用f2覆盖f1即可

3.l1>l2 r1<=r2

我们求出f1,f2在mid处的取值m1,m2，再分类讨论：

(1)m1>m2 说明在左半边都是f2更优，对于整个区间，用f2覆盖f1，**在右半边讨论f1**

(2)m1<=m2 说明在右半边都是f1更优，左半边讨论f2即可

4.l1<=l2 r1>r2 类似第三种情况讨论即可



链上问题转到树上，树链剖分即可



在这里还需要用到标记永久化的技巧，即我们不下传标记，在求区间最小值的时候，每次访问到一个和询问区间有交集的区间，把答案和这个区间所维护的线段取min，具体细节请看代码



代码：

```
#include<cstdio>
#include<iostream>
#define ll long long
using namespace std;
const int N=100010;
const long long inf=123456789123456789; 
int n,m;
struct edg{
	int to,next,v;
}e[2*N];
struct tree{
	int l,r;
	long long x,y,v;
	bool tag;
}tr[4*N];
bool vis[N];
long long ans,dis[N];
int head[N],top[N],size,dep[N],hs[N],sz[N],f[N][31],dfn[N],cnt,p[N];
void add(int x,int y,int v){size++;e[size]={y,head[x],v};head[x]=size;}
void dfs1(int x,int fa)
{
	dep[x]=dep[fa]+1;sz[x]=1;f[x][0]=fa;
	for (int i=head[x];i;i=e[i].next)
	{
		int y=e[i].to;
		if (dep[y]) continue;
		dis[y]=dis[x]+e[i].v;
		dfs1(y,x);
		sz[x]+=sz[y];
		if (sz[y]>sz[hs[x]]) hs[x]=y;
	}
}
void dfs2(int x,int ff)
{
	top[x]=ff;dfn[x]=++cnt;vis[x]=1;p[cnt]=x;
	if (hs[x]) dfs2(hs[x],ff);
	for (int i=head[x];i;i=e[i].next)
	{
		int y=e[i].to;
		if (vis[y]) continue;
		dfs2(y,y);
	}
}
void build(int i,int l,int r)
{
	tr[i].l=l,tr[i].r=r;tr[i].v=inf;
	if (l==r) return;
	int mid=l+r>>1;
	build(i<<1,l,mid);build(i<<1|1,mid+1,r);
}
int LCA(int x,int y)
{
	if (dep[x]<dep[y]) swap(x,y);
	for (int i=30;i>=0;i--) if (dep[f[x][i]]>=dep[y]) x=f[x][i];
	if (x==y) return x;
	for (int i=30;i>=0;i--) if (f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];
	return f[x][0];
}
void update(int i){tr[i].v=min(tr[i].v,min(tr[i<<1].v,tr[i<<1|1].v));}
void add(int i,ll a,ll b)
{
	int L=tr[i].l,R=tr[i].r;
	if (!tr[i].tag) {tr[i].tag=1,tr[i].x=a,tr[i].y=b,tr[i].v=min(tr[i].v,min(1ll*dis[p[L]]*b+a,1ll*dis[p[R]]*b+a));return;}
	ll l1=tr[i].y*dis[p[L]]+tr[i].x;
	ll l2=b*dis[p[L]]+a;
	ll r1=tr[i].y*dis[p[R]]+tr[i].x;
	ll r2=b*dis[p[R]]+a;
	if (l2>=l1&&r2>=r1) return;
	if (l2<l1&&r2<r1) {tr[i].x=a,tr[i].y=b;tr[i].v=min(tr[i].v,min(1ll*dis[p[L]]*b+a,1ll*dis[p[R]]*b+a));return;}
	int mid=L+R>>1;
	ll m1=tr[i].y*dis[p[mid]]+tr[i].x;
	ll m2=b*dis[p[mid]]+a;
	if (l2>=l1)
	{
		if (m2>=m1) add(i<<1|1,a,b);
		else add(i<<1,tr[i].x,tr[i].y),tr[i].x=a,tr[i].y=b,tr[i].v=min(tr[i].v,min(1ll*dis[p[L]]*b+a,1ll*dis[p[R]]*b+a));
	}
	else
	{
		if (m2>=m1) add(i<<1,a,b);
		else add(i<<1|1,tr[i].x,tr[i].y),tr[i].x=a,tr[i].y=b,tr[i].v=min(tr[i].v,min(1ll*dis[p[L]]*b+a,1ll*dis[p[R]]*b+a));
	}
	update(i);
}
void modify(int i,int l,int r,ll a,ll b)
{
	int L=tr[i].l,R=tr[i].r;
	if (L>r||l>R) return;
	if (l<=L&&R<=r) {add(i,a,b);return;}
	modify(i<<1,l,r,a,b);modify(i<<1|1,l,r,a,b);
	update(i);
}
void query(int i,int l,int r)
{
	int L=tr[i].l,R=tr[i].r;
	if (L>r||l>R) return;
	if (l<=L&&R<=r) {ans=min(ans,tr[i].v);return;}
	if (tr[i].tag) ans=min(ans,min(1ll*dis[p[max(L,l)]]*tr[i].y+tr[i].x,1ll*dis[p[min(R,r)]]*tr[i].y+tr[i].x));
	query(i<<1,l,r);query(i<<1|1,l,r);
}
int main()
{
	scanf("%d%d",&n,&m);
	for (int x,y,v,i=1;i<n;i++) scanf("%d%d%d",&x,&y,&v),add(x,y,v),add(y,x,v);
	dfs1(1,0);dfs2(1,1);
	build(1,1,n);
	for (int i=1;i<=30;i++)
		for (int j=1;j<=n;j++)
			f[j][i]=f[f[j][i-1]][i-1];
	long long a,b;
	for (int x,y,z,i=1;i<=m;i++)
	{
		scanf("%d%d%d",&z,&x,&y);
		if (z==1)
		{
			scanf("%lld%lld",&b,&a);
			int xx=x;
			int lca=LCA(x,y);
			ll na=a+b*dis[x];
			ll nb=-b;
			while (top[x]!=top[lca])
			{
				modify(1,dfn[top[x]],dfn[x],na,nb);
				x=f[top[x]][0];
			}
			modify(1,dfn[lca],dfn[x],na,nb);
			na=a+b*(dis[xx]-dis[lca])-b*dis[lca];		
			nb=b;
			while (top[y]!=top[lca])
			{
				modify(1,dfn[top[y]],dfn[y],na,nb);
				y=f[top[y]][0];
			}
			modify(1,dfn[lca],dfn[y],na,nb);
		}
		else
		{
			ans=inf;
			while (top[x]!=top[y])
			{
				if (dep[top[x]]<dep[top[y]]) swap(x,y);
				query(1,dfn[top[x]],dfn[x]);
				x=f[top[x]][0];
			}
			if (dep[x]<dep[y]) swap(x,y);
			query(1,dfn[y],dfn[x]);
			printf("%lld\n",ans);
		}
	}
} 
```

---

## 作者：cqbzlzm (赞：2)

### Description

给你一棵树，初始每个数都是 `123456789123456789`。每次有如下两种操作/询问：

- `1 s t a b` ：将 $s$ 到 $t$ 路径上的每个点权值都与 $dis(s,u)\times a+b$ 取一个 $\min$。
- `2 s t `：求 $s$ 到 $t$ 路径上的所有点的权值的最小值。

### Solution

先进行一次树链剖分，这样，我们就把链上的操作询问转移到了序列上。

因为 $dis(s,u)$ 可以用 $dep_s-dep_u$ 来表示，所以我们把 $s$ 到 $t$ 的链分成两部分，分成 $s$ 到 $lca$ 和 $lca$ 到 $t$。

所以对于第一段的一个点 $u$，我们设它对应的修改权值为 $w$，则：
$$
w=(dep_s-dep_u)\times a+b=-a\times dep_u+(a\times dep_s+b)
$$
这个很像一个直线斜截式，且斜率和截距都是定值，自变量是 $dep_u$。同理我们来看第二段：
$$
w=(dep_s-dep_{lca}+dep_u-dep_{lca})\times a+b=a\times dep{u}+(-2a\times dep_{lca}+dep_{s}\times a+b)
$$
这也是一个斜截式，自变量还是 $dep_u$。

所以我们相当于是 $s$ 到 $lca$ 和 $lca$ 到 $t$ 整体分别添加了两条直线，然后每个点把自己的 $dep_u$ 带进去算，算出来的就是这一次修改对它的贡献。

由于一条重链它的 $dep$ 是**单调递增**的，所以我们可以用**李超线段树**来维护。每次我们添加**线段**，查询某个区间内的最低的纵坐标。所以我们除了维护区间最优先段外还要再维护一个区间最低纵坐标，每次要注意 `update` 一下。

### Code

一定要注意及时 `update`。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 100000;
const long long INF = 123456789123456789;
int n, m;
struct edge {int v, w; };
vector<edge> G[MAXN + 5];
int cnt, L[MAXN + 5], R[MAXN + 5], son[MAXN + 5], father[MAXN + 5], head[MAXN + 5], siz[MAXN + 5], FF[MAXN + 5];
long long dep[MAXN + 5];
void dfs1(int u, int fa) {
	siz[u] = 1;
	for (auto E : G[u]) {
		int v = E.v, w = E.w;
		if (v == fa) continue;
		dep[v] = dep[u] + w; 
		father[v] = u;
		dfs1(v, u);
		if (siz[v] > siz[son[u]]) son[u] = v;
		siz[u] += siz[v];
	}
	return;
}
void dfs2(int u, int fa, int tp) {
    L[u] = ++ cnt; head[u] = tp; FF[cnt] = u;
    if (son[u]) dfs2(son[u], u, tp);
    for (auto E : G[u]) {
    	int v = E.v, w = E.w;
        if (v == fa || v == son[u]) continue;
        dfs2(v, u, v);
    }
    R[u] = cnt;
    return;
}
struct line {
    long long k, b;
};
long long get(line l, int x) {return l.k * dep[FF[x]] + l.b;}
struct node {
	int L, R;
	long long val;
	line li;
} seg[4 * MAXN + 5];
void build(int id, int l, int r) {
    line t = {0, INF};
    seg[id] = {l, r, INF, t};
    if (l == r) return;
    int mid = (l + r) / 2;
    build(id << 1, l, mid);
    build(id << 1 | 1, mid + 1, r);
    return ;
}
void update(int id) {
	seg[id].val = min(seg[id].val, min(seg[id << 1].val, seg[id << 1 | 1].val));
	seg[id].val = min(seg[id].val, min(get(seg[id].li, seg[id].L), get(seg[id].li, seg[id].R)));
	return ;
}
void cover(int id, line q) {
    int mid = (seg[id].L + seg[id].R) / 2;
    if (get(q, mid) < get(seg[id].li, mid)) swap(q, seg[id].li);
    if (seg[id].L == seg[id].R) {
    	seg[id].val = min(seg[id].val, min(get(seg[id].li, seg[id].L), get(seg[id].li, seg[id].R)));
    	return;
	}
    if (get(q, seg[id].L) < get(seg[id].li, seg[id].L))
        cover(id << 1, q);
    if (get(q, seg[id].R) < get(seg[id].li, seg[id].R))
        cover(id << 1 | 1, q);
    update(id);
    return;
}
void modify(int id, int linel, int liner, line q) {
    if (seg[id].R < linel || liner < seg[id].L) return ;
    if (linel <= seg[id].L && seg[id].R <= liner) {
        cover(id, q);
        return;
    }
    modify(id << 1, linel, liner, q);
	modify(id << 1 | 1, linel, liner, q);
	update(id);
    return ;	
}
long long query(int id, int ql, int qr) {
	if (ql <= seg[id].L && seg[id].R <= qr) {
		return seg[id].val;
	}
	if (seg[id].L > qr || seg[id].R < ql) return INF;
	long long ans = min(get(seg[id].li, max(ql, seg[id].L)), get(seg[id].li, min(qr, seg[id].R)));
	return min(ans, min(query(id << 1, ql, qr), query(id << 1 | 1, ql, qr)));
}
void add(int x, int y, line q) {
    while (head[x] != head[y]) {
        if (dep[head[x]] < dep[head[y]]) swap(x, y);
        modify(1, L[head[x]], L[x], q);
        x = father[head[x]];
    }
    if (dep[x] > dep[y]) swap(x, y);
    modify(1, L[x], L[y], q);
    return ;
}
long long ask(int x, int y) {
    long long ans = INF;
    while (head[x] != head[y]) {
        if (dep[head[x]] < dep[head[y]]) swap(x, y);
        ans = min(ans, query(1, L[head[x]], L[x]));
        x = father[head[x]];
    }
    if (dep[x] > dep[y]) swap(x, y);
    ans = min(ans, query(1, L[x], L[y]));
    return ans;
}
int getlca(int x, int y) {
    while (head[x] != head[y]) {
        if (dep[head[x]] < dep[head[y]]) swap(x, y);
        x = father[head[x]];
    }
    if (dep[x] > dep[y]) swap(x, y);
    return x;
}
signed main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i < n; i ++) {
		int u, v, w;
		scanf("%d%d%d", &u, &v, &w);
		G[u].push_back({v, w});
		G[v].push_back({u, w});
	}
    dfs1(1, 0); dfs2(1, 0, 1);
    build(1, 1, cnt);
    for (int i = 1; i <= m; i ++) {
    	int op; scanf("%d", &op);
    	if (op == 1) {
    		int s, t, a, b;
    		scanf("%d%d%d%d", &s, &t, &a, &b);
    		int lc = getlca(s, t);
    		line tmp = {-a, a * dep[s] + b};
    		add(s, lc, tmp);
    		tmp = {a, dep[s] * a - 2 * dep[lc] * a + b};
    		add(lc, t, tmp);
		} else {
			int s, t;
			scanf("%d%d", &s, &t);
			printf("%lld\n", ask(s, t));
		}
	}
    return 0;
}
```

---

## 作者：VenusM1nT (赞：2)

李超树 + 树剖。  
虽然是板子题，但是一切东西上树了就会显得毒瘤（确信）  
对于这题，修改的方式就是经典的线段版李超树（[`P4097 [HEOI2013]Segment`](https://www.luogu.com.cn/problem/P4097)），而树上的一段路径 $u\to v$，可以将其视作 $u\to \text{lca}$ 和 $\text{lca}\to v$ 两段分别处理。同时李超树要稍作修改，可以像普通线段树一样维护一个 $\text{minx}$ 以查询最小值。  
```cpp
#include<bits/stdc++.h>
#define MAXN 100005
#define reg register
#define inl inline
#define int long long
using namespace std;
const int inf=123456789123456789ll;
int cnt,fst[MAXN],nxt[MAXN<<1],to[MAXN<<1],w[MAXN<<1];
int n,Q,k[MAXN],b[MAXN],tot;
int dfn[MAXN],idx,top[MAXN],son[MAXN],siz[MAXN],faz[MAXN],dep[MAXN],rk[MAXN],dis[MAXN];
inl void AddEdge(reg int u,reg int v,reg int c)
{
	to[++cnt]=v;
	nxt[cnt]=fst[u];
	fst[u]=cnt;
	w[cnt]=c;
}
void Dfs1(reg int u,reg int pre)
{
	siz[u]=1;
	son[u]=0;
	for(reg int i=fst[u];i;i=nxt[i])
	{
		reg int v=to[i];
		if(v==pre) continue;
		faz[v]=u;
		dep[v]=dep[u]+1;
		dis[v]=dis[u]+w[i];
		Dfs1(v,u);
		siz[u]+=siz[v];
		if(siz[v]>siz[son[u]]) son[u]=v;
	}
}
void Dfs2(reg int u,reg int rt)
{
	dfn[u]=++idx;
	rk[idx]=u;
	top[u]=rt;
	if(son[u]) Dfs2(son[u],rt);
	for(reg int i=fst[u];i;i=nxt[i])
	{
		reg int v=to[i];
		if(v==faz[u] || v==son[u]) continue;
		Dfs2(v,v);
	}
}
struct LCSegment
{
	int t[MAXN<<2],minx[MAXN<<2];
	inl void PushUp(reg int rt)
	{
		minx[rt]=min(minx[rt],min(minx[rt<<1],minx[rt<<1|1]));
	}
	inl int Calc(reg int x,reg int rt)
	{
		return k[rt]*dis[rk[x]]+b[rt];
	}
	void Build(reg int rt,reg int l,reg int r)
	{
		t[rt]=1; minx[rt]=inf;
		if(l==r) return;
		reg int mid=(l+r)>>1;
		Build(rt<<1,l,mid);
		Build(rt<<1|1,mid+1,r);
		PushUp(rt);
	}
	void Modify(reg int rt,reg int l,reg int r,reg int tl,reg int tr,reg int x)
	{
		reg int mid=(l+r)>>1;
		if(tl<=l && r<=tr)
		{
			if(Calc(l,x)<=Calc(l,t[rt]) && Calc(r,x)<=Calc(r,t[rt]))
			{
				t[rt]=x;
				minx[rt]=min(minx[rt],min(Calc(l,x),Calc(r,x)));
				return;
			}
			if(Calc(l,x)>=Calc(l,t[rt]) && Calc(r,x)>=Calc(r,t[rt])) return;
			if(k[x]<k[t[rt]])
			{
				if(Calc(mid,x)<=Calc(mid,t[rt]))
				{
					Modify(rt<<1,l,mid,tl,tr,t[rt]);
					t[rt]=x;
				}
				else Modify(rt<<1|1,mid+1,r,tl,tr,x);
			}
			else
			{
				if(Calc(mid,x)<=Calc(mid,t[rt]))
				{
					Modify(rt<<1|1,mid+1,r,tl,tr,t[rt]);
					t[rt]=x;
				}
				else Modify(rt<<1,l,mid,tl,tr,x);
			}
			minx[rt]=min(minx[rt],min(Calc(l,x),Calc(r,x)));
			PushUp(rt);
		}
		else
		{
			if(tl<=mid) Modify(rt<<1,l,mid,tl,tr,x);
			if(tr>mid) Modify(rt<<1|1,mid+1,r,tl,tr,x);
			PushUp(rt);
		}
	}
	int Query(reg int rt,reg int l,reg int r,reg int tl,reg int tr)
	{
		if(tl<=l && r<=tr) return minx[rt];
		reg int mid=(l+r)>>1,res=inf;
		if(b[t[rt]]!=inf) res=min(Calc(max(l,tl),t[rt]),Calc(min(r,tr),t[rt]));
		if(tl<=mid) res=min(res,Query(rt<<1,l,mid,tl,tr));
		if(tr>mid) res=min(res,Query(rt<<1|1,mid+1,r,tl,tr));
		return res;
	}
}T;
inl int LCA(reg int x,reg int y)
{
	while(top[x]!=top[y])
	{
		if(dep[top[x]]>dep[top[y]]) x=faz[top[x]];
		else y=faz[top[y]];
	}
	return dep[x]>dep[y]?y:x;
}
inl void Modify(reg int u,reg int v)
{
	while(top[u]!=top[v])
	{
		T.Modify(1,1,n,dfn[top[u]],dfn[u],tot);
		u=faz[top[u]];
	}
	T.Modify(1,1,n,dfn[v],dfn[u],tot);
}
inl int Query(reg int u,reg int v)
{
	reg int res=inf;
	while(top[u]!=top[v])
	{
		if(dep[top[u]]<dep[top[v]]) swap(u,v);
		res=min(res,T.Query(1,1,n,dfn[top[u]],dfn[u]));
		u=faz[top[u]];
	}
	if(dep[u]>dep[v]) swap(u,v);
	res=min(res,T.Query(1,1,n,dfn[u],dfn[v]));
	return res;
}
template <typename T> inl void Read(reg T &x)
{
	x=0;
	reg int fu=1;
	reg char ch=getchar();
	for(;!isdigit(ch);ch=getchar()) if(ch=='-') fu=-1;
	for(;isdigit(ch);ch=getchar()) x=x*10+ch-48;
	x*=fu;
}
signed main()
{
	Read(n);
	Read(Q);
	for(reg int i=1;i<n;i++)
	{
		reg int x,y,z;
		Read(x);
		Read(y);
		Read(z);
		AddEdge(x,y,z);
		AddEdge(y,x,z);
	}
	dep[1]=1;
	Dfs1(1,0);
	Dfs2(1,1);
	k[++tot]=0;
	b[tot]=inf;
	T.Build(1,1,n);
	while(Q--)
	{
		reg int opt,x,y;
		Read(opt);
		Read(x);
		Read(y);
		if(opt==1)
		{
			reg int K,B,lca=LCA(x,y);
			Read(K);
			Read(B);
			k[++tot]=-K;
			b[tot]=K*dis[x]+B;
			Modify(x,lca);
			k[++tot]=K;
			b[tot]=K*(dis[x]-(dis[lca]<<1))+B;
			Modify(y,lca);
		}
		else printf("%lld\n",Query(x,y));
	}
	return 0;
}
```

---

## 作者：Helloworldwuyuze (赞：1)

# P4096 题解

## 前置知识

[树链剖分](https://www.luogu.com.cn/problem/P3384)，[李超线段树](https://www.luogu.com.cn/problem/P4097)，[LCA](https://www.luogu.com.cn/problem/P3379)。

## 题意

有一颗节点为 $n$ 的树，一点到根节点的距离 $dis_u$，有两种操作：

- 在树上一条链上每个点都加上一个数$x$，其中 $x=k\times dis_{(u,i)}+b$，其中 $i$ 是当前节点，$s$ 是起始节点，给出 $k,b$。

- 查询树上一条链 $[s,t]$ 内的数的最小值。

## Solution

这个题在树上进行链的操作一眼剖，同时好需要插入一条类似于一次函数 $y=kx+b$ 的东西一眼李超线段树，于是这个题就是 $n\log^3 n$ 的树剖+李超，其中剖一个 $\log n$，李超两个。

发现这个东西分为两个过程。如果设 $f=\operatorname{LCA}(s,y)$，那么 $[s,f]$ 和 $[f,t]$ 需要分别讨论。

- 对于 $[s,f]$，显然 $y_i=k\times (dis_s-dis_i)+b=-k\times dis_i+k\times dis_s+b$，即这一条线段 $k_i=-k,b_i=k\times dis_s+b$。

- 对于 $[f,t]$，显然 $y_i=k\times (dis_i-dis_f+dis_s-dis_f)+b=k\times dis_i+k\times (dis_s-2\times dis_f)+b$，即这一条线段 $k_i=k,b_i=k\times (dis_s-2\times dis_f)+b$。

## CODE

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<queue>
#include<stack>
#include<algorithm>
#include<map>

#include<bitset>
#include<set>

#include<deque>
#include<cassert>
#include<cstdlib>
#include<cmath>
#include<ctime>
#include<vector>

#define fi first
#define se second
#define pb push_back
#define mk make_pair
#define DBG cerr << __LINE__ << ' ' << __FUNCTION__ << endl

#define DRE default_random_engine
#define UID uniform_int_distribution
#define y0 Y0
#define y1 Y1

#define pi acos(-1)
#define eps (1e-8)
#define int long long

using namespace std;

const int INF = 123456789123456789;
typedef pair<int,int> PII;
typedef pair<int,PII> PIII;
const int N = 2e5 + 10;
const int M = 1e6 + 10;

int n,m,x,y,z,op,s,t;
vector<PII> g[N];
int siz[N],dfn[N],idx,rk[N],dep[N],fa[N][20],top[N],son[N],dis[N];
int k[N<<2],b[N<<2],tot;

//预处理

void dfs1(int u,int fat){
    fa[u][0]=fat; siz[u]=1;
    dep[u]=dep[fat]+1;
    int t=log(n)/log(2)+1;
    for(int i=1;i<=t;++i)
        fa[u][i]=fa[fa[u][i-1]][i-1];
    for(PII v:g[u]){
        if(v.fi==fat)  continue;
        dis[v.fi]=dis[u]+v.se;
        dfs1(v.fi,u);
        siz[u]+=siz[v.fi];
        if(siz[v.fi]>siz[son[u]])   son[u]=v.fi;
    }
}
void dfs2(int u,int tp){
    top[u]=tp;dfn[u]=++idx; rk[idx]=u; 
    if(son[u])  dfs2(son[u],tp);
    for(PII v:g[u])
        if(v.fi!=fa[u][0]&&v.fi!=son[u])   dfs2(v.fi,v.fi);
}

//倍增LCA

int LCA(int x,int y){
    int t=log(n)/log(2)+1;
    if(dep[x]<dep[y])   swap(x,y);
    for(int i=t;i>=0;--i)
        if(dep[fa[x][i]]>=dep[y])   x=fa[x][i];
    if(x==y)    return x;
    for(int i=t;i>=0;--i)
        if(fa[x][i]!=fa[y][i])  x=fa[x][i], y=fa[y][i];
    return fa[x][0];
}

//SegMent Tree
inline int val(int i,int x){ return k[i]*dis[rk[x]]+b[i]; }
int tr[N<<2], mn[N<<2];
inline void push_up(int p){ mn[p]=min(mn[p],min(mn[p<<1],mn[p<<1|1])); }
void update(int p,int left,int right,int l,int r,int x){
    int mid=l+r>>1;
    if(left<=l&&r<=right){
        if(val(x,l)<=val(tr[p],l)&&val(x,r)<=val(tr[p],r)){
            tr[p]=x; mn[p]=min(mn[p],min(val(x,l),val(x,r)));
            return ;
        }if(val(x,l)>=val(tr[p],l)&&val(x,r)>=val(tr[p],r)) return ;
        if(k[x]<k[tr[p]]){
            if(val(x,mid)<=val(tr[p],mid))  update(p<<1,left,right,l,mid,tr[p]), tr[p]=x;
            else    update(p<<1|1,left,right,mid+1,r,x);
        }else{
            if(val(x,mid)<=val(tr[p],mid))  update(p<<1|1,left,right,mid+1,r,tr[p]), tr[p]=x;
            else    update(p<<1,left,right,l,mid,x);
        }
    }
    if(left<=mid)   update(p<<1,left,right,l,mid,x);
    if(right>mid)   update(p<<1|1,left,right,mid+1,r,x);
    push_up(p);
}
int query(int p,int left,int right,int l,int r){
    if(left<=l&&r<=right)    return mn[p];
    int mid=l+r>>1, res=INF;
    if(b[tr[p]]!=INF)    res=min(val(tr[p],max(l,left)),val(tr[p],min(r,right)));
    if(left<=mid)   res=min(res,query(p<<1,left,right,l,mid));
    if(right>mid)   res=min(res,query(p<<1|1,left,right,mid+1,r));
    return res;
}
void build(int p,int l,int r){
    mn[p]=INF, tr[p]=1;
    if(l==r)    return ;
    int mid=l+r>>1;
    build(p<<1,l,mid), build(p<<1|1,mid+1,r);
}

//Tree Cut
void change(int x,int y){
    while(top[x]!=top[y])   update(1,dfn[top[x]],dfn[x],1,n,tot), x=fa[top[x]][0];
    update(1,dfn[y],dfn[x],1,n,tot);
}
int ask(int x,int y){
    int ans=INF;
    while(top[x]!=top[y]){
        if(dep[top[x]]<dep[top[y]]) swap(x,y);
        ans=min(ans,query(1,dfn[top[x]],dfn[x],1,n));
        x=fa[top[x]][0];
    }
    if(dep[x]<dep[y])   swap(x,y);
    return min(ans,query(1,dfn[y],dfn[x],1,n));
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<n;++i)    cin>>x>>y>>z, g[x].pb(mk(y,z)), g[y].pb(mk(x,z));
    dfs1(1,0); dfs2(1,1);
    k[++tot]=0, b[tot]=INF; build(1,1,n);
    while(m--){
        cin>>op;
        if(op==1){
            cin>>s>>t>>x>>y;
            int w=LCA(s,t);
            k[++tot]=-x, b[tot]=x*dis[s]+y, change(s,w);
            k[++tot]=x, b[tot]=x*(dis[s]-2*dis[w])+y, change(t,w);
        }else   cin>>s>>t, cout<<ask(s,t)<<endl;
    }
    return 0;
}
```

---

## 作者：__ycx2010__ (赞：1)

### 思路

设 $dis_i$ 表示从根到 $i$ 的距离。

对于每一次的添加 $s, t, a, b$，设 $d = lca(s, t)$，则：

- 在 $s$ 到 $d$ 之间的点 $x$ 添加的数为

$$(dis_s - dis_x)\times a + b = -a\times dis_x + (a\times dis_s + b)$$

- 在 $t$ 到 $d$ 之间的点 $x$ 添加的数为

$$(dis_x + dis_s - 2dis_d)\times a + b = a\times dis_x + a\times (dis_s - 2dis_d) + b$$

对于每一条重链，$dis$ 的值一定递增，所以可以以 $dis$ 作为横坐标，建一颗李超线段树，每次添加相当于加入 $O(\log n)$ 条线段，询问的是区间中的最小值，最小值一定是在线段的左右端点上。

总时间复杂度 $O(n\log^3 n)$ 。

### code

```cpp
#include <bits/stdc++.h>
#define int long long
#define ll long long
#define fi first
#define se second
#define pb push_back
#define lb lower_bound
#define re register
#define sz(x) (int(x.size()))
#define all(x) x.begin(), x.end()
#define mst(x, bit) memset(x, bit, sizeof(x))

using namespace std;

const int N = 1e5 + 10, M = 2e6 + 10;
int n, cnt, tot;
int h[N], e[N * 2], w[N * 2], ne[N * 2], idx;
int p[N][25], dep[N], dis[N], siz[N], son[N];
int top[N], g[N], pos[N];

ll rd() {
	ll w = 0, f = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9') {if (ch == '-') f = -1; ch = getchar();}
	while (ch >= '0' && ch <= '9') {w = (w << 3) + (w << 1) + ch - 48; ch = getchar();}
	return f * w;
}

int cmp(ll x, ll y) {
	if (x == y) return 0;
	return x > y ? 1 : -1;
}

void chkmin(ll &x, ll y) {x = min(x, y);}

struct Segment {
	int l, r;
	ll b, slope;
} seg[M];

void add(int a, int b, int c) {
	e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

ll calc(int x, int k) {
	if (!k) return 2e18;
	if (seg[k].l <= x && x <= seg[k].r)
		return seg[k].b + x * seg[k].slope;
	return 2e18;
}

bool cmp2(int k, int x, int y) {
	int g = cmp(calc(k, x), calc(k, y));
	if (g == -1 || (g == 0 && x < y)) return true;
	return false;
}

ll Min(int l, int r, int k) {
	return min(calc(max(seg[k].l, dis[g[l]]), k), calc(min(seg[k].r, dis[g[r]]), k));
}

struct Node{
	int mvp;
	ll mn;
} tr[N << 2];

void upd(int u, int l, int r, int k) {
	int mid = l + r >> 1;
	if (tr[u].mvp == k) return;
	if (cmp2(dis[g[mid]], k, tr[u].mvp)) swap(tr[u].mvp, k);
	if (cmp2(dis[g[l]], tr[u].mvp, k) && cmp2(dis[g[r]], tr[u].mvp, k)) return;
	if (cmp2(dis[g[l]], k, tr[u].mvp)) upd(u << 1, l, mid, k);
	else upd(u << 1 | 1, mid + 1, r, k);
}

void insert(int u, int L, int R, int l, int r, int d) {
    if (l <= L && R <= r) {
		upd(u, L, R, d);
		chkmin(tr[u].mn, min(calc(dis[g[L]], d), calc(dis[g[R]], d)));
		return;
    }
    int mid = L + R >> 1;
    if (l <= mid) insert(u << 1, L, mid, l, r, d);
    if (r > mid) insert(u << 1 | 1, mid + 1, R, l, r, d);
    tr[u].mn = min(Min(L, R, tr[u].mvp), min(tr[u << 1].mn, tr[u << 1 | 1].mn));
}

ll query(int u, int l, int r, int s, int t) {
    if (s <= l && r <= t) return tr[u].mn;
    int mid = l + r >> 1;
    if (s > mid) return min(Min(s, t, tr[u].mvp), query(u << 1 | 1, mid + 1, r, s, t));
    if (t <= mid) return min(Min(s, t, tr[u].mvp), query(u << 1, l, mid, s, t));
    return min(Min(s, t, tr[u].mvp), min(query(u << 1, l, mid, s, t), query(u << 1 | 1, mid + 1, r, s, t)));
}

void dfs1(int u, int fa) {
	siz[u] = 1, p[u][0] = fa, dep[u] = dep[fa] + 1;
	for (int i = 1; i < 20; i ++ ) p[u][i] = p[p[u][i - 1]][i - 1];
	for (int i = h[u]; ~i; i = ne[i]) {
		int ver = e[i];
		if (ver == fa) continue;
		dis[ver] = dis[u] + w[i];
		dfs1(ver, u);
		siz[u] += siz[ver];
		if (siz[ver] > siz[son[u]]) son[u] = ver;
	}
}

void dfs2(int u, int topf) {
	top[u] = topf, pos[u] = ++ tot, g[tot] = u;
	if (son[u]) dfs2(son[u], topf);
	for (int i = h[u]; ~i; i = ne[i]) {
		int ver = e[i];
		if (ver == p[u][0] || ver == son[u]) continue;
		dfs2(ver, ver);
	}
}

int lca(int a, int b) {
	if (dep[a] < dep[b]) swap(a, b);
	for (int i = 19; i >= 0; i -- )
		if (dep[p[a][i]] >= dep[b])
			a = p[a][i];
	if (a == b) return a;
	for (int i = 19; i >= 0; i -- )
		if (p[a][i] != p[b][i])
			a = p[a][i], b = p[b][i];
	return p[a][0];
}

signed main() {
	int n = rd(), m = rd();
	memset(h, -1, sizeof h);
	for (int i = 1; i < n; i ++ ) {
		int u = rd(), v = rd(), w = rd();
		add(u, v, w), add(v, u, w);
	}
	dfs1(1, 0);
	dfs2(1, 1);
	for (int i = 1; i <= n << 4; i ++ ) tr[i].mn = 2e18;
	while (m -- ) {
		int op = rd();
		if (op == 1) {
			int t = rd(), s = rd(), a = rd(), b = rd();
			int d = lca(s, t);
			int x = s, y = t;
			while (dep[top[x]] >= dep[d]) {
				seg[++ cnt] = {dis[g[pos[top[x]]]], dis[g[pos[x]]], (dis[t] - 2 * dis[d]) * a + b, a};
				insert(1, 1, tot, pos[top[x]], pos[x], cnt);
				x = p[top[x]][0];
			}
			if (dep[x] >= dep[d]) {
				seg[++ cnt] = {dis[g[pos[d]]], dis[g[pos[x]]], (dis[t] - 2 * dis[d]) * a + b, a};
				insert(1, 1, tot, pos[d], pos[x], cnt);
			}
			while (dep[top[y]] >= dep[d]) {
				seg[++ cnt] = {dis[g[pos[top[y]]]], dis[g[pos[y]]], dis[t] * a + b, -a};
				insert(1, 1, tot, pos[top[y]], pos[y], cnt);
				y = p[top[y]][0];
			}
			if (dep[y] >= dep[d]) {
				seg[++ cnt] = {dis[g[pos[d]]], dis[g[pos[y]]], dis[t] * a + b, -a};
				insert(1, 1, tot, pos[d], pos[y], cnt);
			}
		} else {
			int s = rd(), t = rd();
			ll ans = 123456789123456789;
			while (top[s] != top[t]) {
				if (dep[top[s]] < dep[top[t]]) swap(s, t);
				ans = min(ans, query(1, 1, tot, pos[top[s]], pos[s]));
				s = p[top[s]][0];
			}
			if (dep[s] > dep[t]) swap(s, t);
			ans = min(ans, query(1, 1, tot, pos[s], pos[t]));
			printf("%lld\n", ans);
		}
	}
	return 0;
}
```

---

## 作者：tsqtsqtsq0309 (赞：1)

[更好的阅读体验](https://www.cnblogs.com/tsqtsqtsq/p/17818497.html)

# 简要题意

给定一棵 $n$ 个点的树，树有边权。

对每个点维护一个集合 $S_u$，一开始集合均包含整数 $123456789123456789$。

设 ${\rm dis}_{a,b}$ 为树上两点 $a$，$b$ 的距离。

共 $m$ 次操作，分为如下两种：

- `s t a b`: 设 $f$ 为 $s$，$t$ 路径上的点集，对与 $\forall t\in f$，给 $t$ 所对应的集合里加入 $a\times {\rm dis}_{s,t} + b$。
- `s t`: 设 $f$ 为 $s$，$t$ 路径上的点集，求 $\min\{\bigcup_{x\in f} S_x\}$ 的值。

其中 $1\le n\le 10^5$。

# 前置知识

1. 树链剖分
2. 李超线段树

# 解题方法

首先看到 $a\times dis+b$，是一个一次函数的形式，不妨考虑先树剖一下，然后用永久化标记的李超线段树维护最大值。

横坐标自然是取个确定的距离标准。取每个点到根节点的距离 $dis[i]$ 作为 $i$ 的横坐标好了，这样对于同一条重链，横坐标还是递增的。

对于每次插入操作，先求出 $s$ 和 $t$ 的 $lca$，预处理出每个点到根节点的距离 $dis[u]$，然后化简一下式子。

1. 对于 $s$ 到 $lca$ 的那条路径上的点 $u$，增加的贡献是

$$
a\times (dis[s]-dis[u])+b=-a\times dis[u] + a\times dis[s] +b
$$

2. 对于 $t$ 到 $lca$ 的那条路径上的点，增加的贡献是

$$
a\times (dis[s]+dis[u]-2\times dis[lca])+b=a\times dis[u] + a\times (dis[s]-2\times dis[lca]) +b
$$

然后就可以插入了。

现在问题就剩如果维护区间最小值，容易发现对于一个区间内的线段，最小值无非就是从两个端点的地方取到，所以线段树上再维护一个区间最小值，每次向上传递，最后区间查询的时候，经过的区间上存的优势线段也能为答案作出贡献，算上就好了。重点在于怎样合并两条线段，具体可以分为以下三种情况：

1. 如果新线段在当前节点的定义域中完全小于原来的线段。应舍去原来的线段，并用当前线段的两个端点更新最小值。

2. 新线段在当前节点的定义域中完全大于原来的线段，应舍去这条新线段。

3. 新加入的线段和原来的线段在当前的定义域中有交点。求一下两条线段的交点横坐标 $x$。如果新线段的左端点大于旧线段的左端点，或 $x\le mid$，就往左下放；如果新线段的右端点小于旧线段的右端点，或 $x>mid$，就往右下放。

李超树维护线段是 $O(\log^2n)$ 的，再加上树剖跳链的复杂度，总的时间复杂度是 $O(n\log^3n)$，应该是可以过的吧……

```cpp
#include <iostream>
#define MAXN 100005
using namespace std;
const long long INF = 123456789123456789;
int n, m, u, v, w, op, s, t, tmp, tp;
struct edge{int w, to, nxt;}e[MAXN << 1];
int head[MAXN], cnt = 1;
int fa[MAXN], dep[MAXN], siz[MAXN], son[MAXN];
int dfn[MAXN], vis[MAXN], rnk[MAXN], tot;
long long dis[MAXN], k[MAXN << 1], b[MAXN << 1];
struct seg{
	int ls, rs, tag;
	long long minn;
}tree[MAXN << 2];
int read(){
	int t = 1, x = 0;char ch = getchar();
	while(!isdigit(ch)){if(ch == '-')t = -1;ch = getchar();}
	while(isdigit(ch)){x = (x << 1)+ (x << 3)+ (ch ^ 48);ch = getchar();}
	return x * t;
}
void write(long long x){
	if(x < 0){putchar('-');x = -x;}
	if(x >= 10)write(x / 10);
	putchar(x % 10 ^ 48);
}
void add(int u, int v, int w){
	cnt++;e[cnt].w = w;e[cnt].to = v;e[cnt].nxt = head[u];head[u] = cnt;
	cnt++;e[cnt].w = w;e[cnt].to = u;e[cnt].nxt = head[v];head[v] = cnt;
}
long long calc(int id, int x){
	return k[id] * dis[rnk[x]] + b[id];
}
void dfs1(int now, int fat, int deep){
    dep[now] = deep;siz[now] = 1;fa[now] = fat;int maxson = -1;
    for(int i = head[now] ; i != 0 ; i = e[i].nxt){
        int v = e[i].to, w = e[i].w;
        if(v != fat){
            dis[v] = dis[now] + w;
			dfs1(v, now, deep + 1);siz[now] += siz[v];
            if(siz[v] > maxson){
                maxson = siz[v];son[now] = v;
            }
        }
    }
}
void dfs2(int now, int fat, int top){
    tot++;dfn[now] = tot;rnk[tot] = now;vis[now] = top;
    if(son[now] != 0){
        dfs2(son[now], now, top);
        for(int i = head[now] ; i != 0 ; i = e[i].nxt){
            int v = e[i].to;
            if(v != fat && v != son[now])dfs2(v, now, v);
        }
    }
}
int lca(int u, int v){
    while(vis[u] != vis[v]){
        if(dep[vis[u]] < dep[vis[v]])swap(u, v);
        u = fa[vis[u]];
    }
    return dep[u] < dep[v] ? u : v;
}
void pushup(int node){
    if(tree[node].ls == tree[node].rs)
        tree[node].minn = min(calc(tree[node].tag, tree[node].ls), 
	  						  calc(tree[node].tag, tree[node].rs));
    else tree[node].minn = min(min(tree[node << 1].minn, 
	                               tree[node << 1 | 1].minn), 
							   min(calc(tree[node].tag, tree[node].ls), 
							   	   calc(tree[node].tag, tree[node].rs)));
}
void build(int node, int left, int right){
    tree[node].ls = left;
	tree[node].rs = right;
	tree[node].minn = INF;
    if(left != right){
		int mid = (left + right) >> 1;
		build(node << 1, left, mid);
		build(node << 1 | 1, mid + 1, right);
	}
}
void change(int node, int x){
    int &y = tree[node].tag;
	int mid = (tree[node].ls + tree[node].rs) >> 1;
    if(calc(x, mid) < calc(y, mid))swap(x, y);
    if(calc(x, tree[node].ls) < calc(y, tree[node].ls))change(node << 1, x);
    if(calc(x, tree[node].rs) < calc(y, tree[node].rs))change(node << 1 | 1, x);
}
void update(int node, int left, int right, int x){
    if(left <= tree[node].ls && tree[node].rs <= right)return change(node, x), pushup(node), void();
    int mid = (tree[node].ls + tree[node].rs) >> 1;
    if(left <= mid)update(node << 1, left, right, x);
    if(right > mid)update(node << 1 | 1, left, right, x);
    pushup(node);
}
long long query(int node, int left, int right){
    if(left <= tree[node].ls && tree[node].rs <= right)return tree[node].minn;
    int mid = (tree[node].ls + tree[node].rs) >> 1;
    long long res = min(calc(tree[node].tag, max(left, tree[node].ls)), 
						calc(tree[node].tag, min(right, tree[node].rs)));
    if(left <= mid)res = min(res, query(node << 1, left, right));
    if(right > mid)res = min(res, query(node << 1 | 1, left, right));
    return res;
}
void updtree(int u, int v, int x){
    while (vis[u] != vis[v]){
        if(dep[vis[u]] < dep[vis[v]])swap(u, v);
        update(1, dfn[vis[u]], dfn[u], x);
        u = fa[vis[u]];
    }
    if(dep[u] > dep[v])swap(u, v);
    update(1, dfn[u], dfn[v], x);
}
long long quetree(int u, int v){
    long long res = INF;
    while (vis[u] != vis[v]){
        if(dep[vis[u]] < dep[vis[v]])swap(u, v);
        res = min(res, query(1, dfn[vis[u]], dfn[u]));
        u = fa[vis[u]];
    }
    if(dep[u] > dep[v])swap(u, v);
    res = min(res, query(1, dfn[u], dfn[v]));
    return res;
}
int main(){
    n = read();m = read();
	for(int i = 1 ; i < n ; i ++)
		u = read(),v = read(),w = read(),add(u, v, w);
    dfs1(1, 0, 0);dfs2(1, 0, 1);b[0] = INF;build(1, 1, n);
    while(m--){
        op = read();
        if(op == 1){
            u = read();v = read();s = read();t = read();tmp = lca(u, v);
            tp++;k[tp] = -s;b[tp] = t + 1LL * dis[u] * s;updtree(u, tmp, tp);
            tp++;k[tp] = s;b[tp] = t + 1LL * dis[u] * s - 2LL * dis[tmp] * s;updtree(tmp, v, tp);
        }else cout << quetree(read(), read()) << endl;
    }
    return 0;
}
```



---

## 作者：wcyQwQ (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P4069)

[可能更好的阅读体验](https://chenyu-w.github.io./2023/05/03/P4069%20%E6%B8%B8%E6%88%8F/)

简单的李超线段树板子。

观察到插入进去的是一个一次函数，所以考虑树剖加李超线段树做法。

我们考虑取每个点到根节点的距离 $d_i$ 作为横坐标，然后我们增加的时候可以先求出 $p = \text{LCA(s, t)}$，对于 $s \rightarrow p$ 上的节点 $i$，它上面新放的数即为 $a \times (d_s - d_i) + b = -a \times d_i + a \times d_s + b$，这样就变成了一个以 $d_i$ 为横坐标的一次函数的形式。同理，对于 $p \rightarrow t$ 上的节点 $i$，它上面新放的数为 $a \times (d_s + d_i - 2d_p) + b$，这样我们就完成了转化。

我们用树链剖分把问题转到序列上后，就需要我们支持插入直线，维护区间最小值，不难发现其实是和普通的李超数差不多的。只是要支持一个 `pushup` 操作，因为这棵树是标记永久化的，所以我们在 `pushup` 时要考虑到当前区间优势线段的贡献。又因为每一条重链上的 $d_i$ 都是单调的，当前优势线段只可能在区间左右侧取到最值，所以可以这么写。

```c++
inline void pushup(int p) {
    if (t[p].l == t[p].r) t[p].min = min(calc(t[p].tag, t[p].l), calc(t[p].tag, t[p].r));
    else t[p].min = min({t[p << 1].min, t[p << 1 | 1].min, calc(t[p].tag, t[p].l), calc(t[p].tag, t[p].r)});
}
```

查询的时候也注意考虑一下当前区间优势线段最小值即可。

```c++
#include <bits/stdc++.h>
#define L(i, j, k) for (int i = (j); i <= (k); i++)
#define R(i, j, k) for (int i = (j); i >= (k); i--)
#define ll long long
#define ld long double
#define ull unsigned long long

using namespace std;
const int N = 1e5 + 10;
const ll INF = 123456789123456789;
int h[N], e[N << 1], ne[N << 1], w[N << 1], idx;
int dep[N], fa[N], sz[N], son[N], dfn[N], top[N], rk[N], tt;
ll dis[N], k[N << 1], b[N << 1];
struct Sgt {
    int l, r, tag;
    ll min;
} t[N << 2];

template<class T = int> T read() {
    T x = 0, y = 1; char c = getchar();
    while (c < '0' || c > '9') {if (c == '-') y = -1; c = getchar();}
    while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
    return x * y;
}

inline void add(int a, int b, int c) {e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx++;}

inline ll calc(int i, int x) {return k[i] * dis[rk[x]] + b[i];}

inline void dfs1(int u, int p) {
    dep[u] = dep[fa[u] = p] + 1, sz[u] = 1;
    for (int i = h[u]; ~i; i = ne[i]) {
        int v = e[i];
        if (v == p) continue;
        dis[v] = dis[u] + w[i], dfs1(v, u), sz[u] += sz[v];
        if (sz[v] > sz[son[u]]) son[u] = v; 
    }
}

inline void dfs2(int u, int t) {
    top[u] = t, rk[dfn[u] = ++tt] = u;
    if (!son[u]) return;
    dfs2(son[u], t);
    for (int i = h[u]; ~i; i = ne[i]) {
        int v = e[i];
        if (v == fa[u] || v == son[u]) continue;
        dfs2(v, v);
    }
}

inline int lca(int u, int v) {
    while (top[u] != top[v]) {
        if (dep[top[u]] < dep[top[v]]) swap(u, v);
        u = fa[top[u]];
    }
    return dep[u] < dep[v] ? u : v;
}

inline void pushup(int p) {
    if (t[p].l == t[p].r) t[p].min = min(calc(t[p].tag, t[p].l), calc(t[p].tag, t[p].r));
    else t[p].min = min({t[p << 1].min, t[p << 1 | 1].min, calc(t[p].tag, t[p].l), calc(t[p].tag, t[p].r)});
}

inline void build(int p, int l, int r) {
    t[p].l = l, t[p].r = r, t[p].min = INF;
    if (l == r) return;
    int mid = (l + r) >> 1;
    build(p << 1, l, mid), build(p << 1 | 1, mid + 1, r);
}

inline void change(int p, int x) {
    int &y = t[p].tag, mid = (t[p].l + t[p].r) >> 1;
    if (calc(x, mid) < calc(y, mid)) swap(x, y);
    if (calc(x, t[p].l) < calc(y, t[p].l)) change(p << 1, x);
    if (calc(x, t[p].r) < calc(y, t[p].r)) change(p << 1 | 1, x);
}

inline void modify(int p, int l, int r, int x) {
    if (l <= t[p].l && t[p].r <= r) return change(p, x), pushup(p), void();
    int mid = (t[p].l + t[p].r) >> 1;
    if (l <= mid) modify(p << 1, l, r, x);
    if (r > mid) modify(p << 1 | 1, l, r, x);
    pushup(p);
}

inline ll query(int p, int l, int r) {
    if (l <= t[p].l && t[p].r <= r) return t[p].min;
    int mid = (t[p].l + t[p].r) >> 1;
    ll res = min(calc(t[p].tag, max(l, t[p].l)), calc(t[p].tag, min(r, t[p].r)));
    if (l <= mid) res = min(res, query(p << 1, l, r));
    if (r > mid) res = min(res, query(p << 1 | 1, l, r));
    return res;
}

inline void modifyPath(int u, int v, int x) {
    while (top[u] != top[v]) {
        if (dep[top[u]] < dep[top[v]]) swap(u, v);
        modify(1, dfn[top[u]], dfn[u], x);
        u = fa[top[u]];
    }
    if (dep[u] > dep[v]) swap(u, v);
    modify(1, dfn[u], dfn[v], x);
}

inline ll queryPath(int u, int v) {
    ll res = INF;
    while (top[u] != top[v]) {
        if (dep[top[u]] < dep[top[v]]) swap(u, v);
        res = min(res, query(1, dfn[top[u]], dfn[u]));
        u = fa[top[u]];
    }
    if (dep[u] > dep[v]) swap(u, v);
    res = min(res, query(1, dfn[u], dfn[v]));
    return res;
}

int main() {
    memset(h, -1, sizeof h);
    int n = read(), m = read(), tot = 0;
    L(i, 1, n - 1) {
        int a = read(), b = read(), c = read();
        add(a, b, c), add(b, a, c);
    }
    dfs1(1, 0), dfs2(1, 1);
    b[0] = INF;
    build(1, 1, n);
    while (m--) {
        int op = read();
        if (op == 1) {
            int u = read(), v = read(), s = read(), t = read();
            int p = lca(u, v);
            tot++; k[tot] = -s, b[tot] = t + 1ll * dis[u] * s;
            modifyPath(u, p, tot);
            tot++; k[tot] = s, b[tot] = t + 1ll * dis[u] * s - 2ll * dis[p] * s;
            modifyPath(p, v, tot);
        }
        else printf("%lld\n", queryPath(read(), read()));
    }
    return 0;
}
```



---

## 作者：feicheng (赞：1)

## Description

给定一棵 $n$ 个点的树，树有边权，对每个点维护一个集合 $S_u$，一开始集合均包含整数 $123456789123456789$。

设 ${\rm dis}_{a,b}$ 为树上两点 $a,b$ 的距离。

共 $m$ 次操作，分为如下两种：

- `u v a b`: 设 $T$ 为 $u,v$ 路径上的点集，对任意的 $t\in T$，给 $t$ 所对应的集合里加入 $a\times {\rm dis}_{u,t} + b$
- `u v`: 设 $T$ 为 $u,v$ 路径上的点集，求

$$
\min\{\bigcup_{t\in T} S_t\}
$$


**限制：**

$1\le n\le 10^5$。

## Solution

### 前置知识
- 树链剖分。
- 李超线段树。
  
不得不说这又是一道强行上树的题目。。

首先进行重链剖分，然后我们考虑对 $\rm dfn$ 序建立一棵李超线段树。

我们想一想李超线段树可以干的事情：
- 区间插入一条线段
- 询问经过某个点的线段在该点的最值

我们的目标就是把题目所给的操作转化到这两个操作上去。

首先考虑修改操作：

记 ${\rm dis}_u$ 为根节点到 $u$ 的距离。

设 $w = {\rm lca}(u,v)$，将问题分 $u\rightarrow w,w\rightarrow v$ 来考虑。

对 $u\rightarrow w$ 上的点 $t$，实际上插入的直线为 $a\times({\rm dis}_u-{\rm dis}_t)+b=-a\times {\rm dis}_t+(a\times{\rm dis_u}+b)$。

对 $w\rightarrow v$ 上的点 $t$，实际上插入的直线为 $a\times({\rm dis}_u+{\rm dis}_t-2\times {\rm dis}_w)+b=a\times {\rm dis}_t + (a\times{\rm dis}_u+2a\times{\rm dis}_w+b) $。

也就是说，修改操作可以转化成对 $\log n$ 个区间插入一条线段。

然后考虑询问操作：

由于一次函数的单调性，最小值只可能在两个端点取得，所以我们对李超树上的每个节点额外维护一个 $\rm mn$ 表示这个节点所代表的区间里包含的线段的最小值即可。

时间复杂度：$\mathcal O(n\log^3 n)$

## Code

由于代码很长（有 400 行），所以把它放到这个剪切板上了，点击[此处](https://pastebin.com/V4UYxF83)即可。

---

## 作者：JoaoFelix (赞：1)

15分钟左右码完，结果出现了点问题，甚至连top只是定义了，都没有赋值！QwQ

首先分析这道题，感觉与普通的李超树不同，因为它不是一个以x为横坐标的一次函数！

我们化一下式子，发现可以转换为一个以dis为横坐标的一次函数！

但是这个可以用李超树维护吗？

事实证明：只要任意两个函数最多只有一个交点，那么就可以用李超树（By jiangly）

感觉还是挺好理解的，只有一个交点，或许应该就是单调的!

这道题的dis是在祖先关系中是单调增，显然可以！

然后就要有一个李超树区间插入，区间最值的问题！

这比我们的整体插入，整体最值要难写一点！还有许多细节！

以下是某位dalao的代码，由于码风优秀，在这里借鉴一下！

```cpp
struct LiChaoTree {
	
	#define ls rt << 1
	#define rs rt << 1 | 1
	
	int t[MAXN << 2]; LL Mn[MAXN << 2];
	
	inline void Init() { t[0] = 1; Mn[0] = INFLL; }
	inline void update(int rt) { Mn[rt] = min(Mn[rt], min(Mn[ls], Mn[rs])); }
	inline LL calc(int x, int id) { return k[id] * (LL)dis[bl[x]] + b[id]; }
	inline void build(int rt, int l, int r) {
		t[rt] = 1; Mn[rt] = INFLL;
		if (l == r) return;
		int mid = (l + r) >> 1;
		build(ls, l, mid); build(rs, mid + 1, r);
		update(rt);
	}
	inline void insert(int rt, int l, int r, int L, int R, int id) {
		int mid = (l + r) >> 1;
		if (L <= l && r <= R) {
			if (calc(l, id) <= calc(l, t[rt]) && calc(r, id) <= calc(r, t[rt])) {
				t[rt] = id;
				chkmin(Mn[rt], min(calc(l, t[rt]), calc(r, t[rt])));
				return;
			}
			if (calc(l, id) >= calc(l, t[rt]) && calc(r, id) >= calc(r, t[rt])) return;
			if (calc(mid, id) <= calc(mid, t[rt])) swap(t[rt], id);
			insert(ls, l, mid, L, R, id);
			insert(rs, mid + 1, r, L, R, id);
			chkmin(Mn[rt], min(calc(l, t[rt]), calc(r, t[rt])));
			update(rt);
		}
		if (L <= mid) insert(ls, l, mid, L, R, id);
		if (R > mid) insert(rs, mid + 1, r, L, R, id);
		update(rt);
	}
	inline LL Query(int rt, int l, int r, int L, int R) {
		if (L <= l && r <= R) return Mn[rt];
		int mid = (l + r) >> 1; LL ret = INFLL;
		if (b[t[rt]] != INFLL) ret = min(calc(max(l, L), t[rt]), calc(min(r, R), t[rt]));
		if (L <= mid) chkmin(ret, Query(ls, l, mid, L, R));
		if (R > mid) chkmin(ret, Query(rs, mid + 1, r, L, R));
		return ret;
	}
		
} T;
```

具体讲解一下：

```cpp
inline void Init() { t[0] = 1; Mn[0] = INFLL; }
inline void update(int rt) { Mn[rt] = min(Mn[rt], min(Mn[ls], Mn[rs])); }
```
一个是初始化，一个是更新，应该比较好理解！

```cpp
inline LL calc(int x, int id) { return k[id] * (LL)dis[bl[x]] + b[id]; }
inline void build(int rt, int l, int r) {
	t[rt] = 1; Mn[rt] = INFLL;
	if (l == r) return;
	int mid = (l + r) >> 1;
	build(ls, l, mid); build(rs, mid + 1, r);
	update(rt);
}
```
calc写在这里可以减少码量！
下面的build函数也是初始化！

步入正题！

```cpp
inline void insert(int rt, int l, int r, int L, int R, int id) {
	int mid = (l + r) >> 1;
	if (L <= l && r <= R) {
		if (calc(l, id) <= calc(l, t[rt]) && calc(r, id) <= calc(r, t[rt])) {
			t[rt] = id;
			chkmin(Mn[rt], min(calc(l, t[rt]), calc(r, t[rt])));
			return;
		}
		if (calc(l, id) >= calc(l, t[rt]) && calc(r, id) >= calc(r, t[rt])) return;
		if (calc(mid, id) <= calc(mid, t[rt])) swap(t[rt], id);
		insert(ls, l, mid, L, R, id);
		insert(rs, mid + 1, r, L, R, id);
		chkmin(Mn[rt], min(calc(l, t[rt]), calc(r, t[rt])));
		update(rt);
	}
	if (L <= mid) insert(ls, l, mid, L, R, id);
	if (R > mid) insert(rs, mid + 1, r, L, R, id);
	update(rt);
}
```
insert函数：

我们先定位，然后定位完了以后我们和普通李超树一样更新！

首先判断大小关系，check是否能完全覆盖！

如果都比它优就直接覆盖！都比它劣就直接return！

然后我们考虑mid记录的是最优的，我们把当前插入的和原有的比较一下，哪个mid更
优就把哪个放在当前节点，另一个下传！

值得注意的是，因为我们本题需要支持区间查询最值，因此我们要在每个节点记录一下这个节点的区间最值，由于都是一次函数，因此最值只可能在两端点处，因此我们这个区间的最优值，就是当前区间端点最值和左儿子右二子的最值分别取最值！

注意函数末要update！

```cpp
inline LL Query(int rt, int l, int r, int L, int R) {
	if (L <= l && r <= R) return Mn[rt];
	int mid = (l + r) >> 1; LL ret = INFLL;
	if (b[t[rt]] != INFLL) ret = min(calc(max(l, L), t[rt]), calc(min(r, R), t[rt]));
	if (L <= mid) chkmin(ret, Query(ls, l, mid, L, R));
	if (R > mid) chkmin(ret, Query(rs, mid + 1, r, L, R));
	return ret;
}
```
Query：函数

还是先定位，只是这个定位与普通的线段树定位相同，如果有完全覆盖，直接返回！

否则我们要考虑当前节点对ans的贡献，同样还是要两个端点，注意取min和max！

（一个易错点：由于我们是区间插入，因此我们没有完全覆盖，当前的L和R有些点没有被覆盖到，因此一定要取min和max）

然后当前这个点查完以后，我们继续类似于普通的线段树一样往下查询！

其实过程和segment那题差不多！

只是多了区间最值，因此我们要多维护一个min和注意一些细节，诸如区间端点这样的东西！

（李超线段树也不一定只能维护以普通值域1 ~ N的一次函数，也可以维护一些其他的单调函数）

需要我们去化简一些式子，使其满足条件！

这道题我们要用树剖辅助维护李超线段树！

插入我们要把一段路径在LCA出劈成两半，分别维护。

然后需要注意的是，一条链上的维护，我们可以类比于不是一条链上的维护方法，top函数在jump的时候注意不要写一些自己yy的方法，我就因为这个卡了很久QwQ！

可以当做是不是一条链的情况，只是只有一个节点在一直往上跳！

查询就是普通的树链剖分查询，取最值即可！

---

## 作者：arrow_king (赞：0)

# 题意

维护一个带边权、有点权（初始点权为 $p_u=123456789123456789$）的无根树，支持以下两种操作：

1. 选择一条链的起点和终点 $u,v$，对于所有 $x\in(u,v)$，记 $dis_x$ 为 $x$ 到 $u$ 的距离，将 $p_x\leftarrow\min\{p_x,a\cdot dis_x+b\}$。
2. 选择一条链的起点和终点 $u,v$，对于所有 $x\in(u,v)$ 计算 $p_x$ 的最小值。

# 做法

看到 $a\cdot dis_x+b$ 这个一次函数形式想到李超树维护。

但是这个形式的自变量 $dis_x$ 随着起点 $u$ 的变化而变化，不能当作维护的自变量，需要将自变量统一。

令 $1$ 为根，记 $\mathrm{lca}$ 为 $u,v$ 的最近公共祖先，将 $u-v$ 这条链拆做 $u-\mathrm{lca}$ 和 $\mathrm{lca}-v$ 两条链。

然后对这两条链分别推式子：

## 左半部分

显然 $dis_x=dep_{u}-dep_x$（$dep$ 是深度），这样把这个式子代入进去得：
$$a\cdot dis_x+b=a(dep_u-dep_x)+b=-a\cdot dep_x+(a\cdot dep_u+b)$$
这样就变成了一个以 $dep_x$ 为自变量的一次函数。

## 右半部分

同样，$dis_x=(dep_x+dep_u-2dep_{\mathrm{lca}})$，代入就可以发现
$$\begin{aligned}
a\cdot dis_x+b&=a(dep_x+dep_u-2dep_{\mathrm{lca}})+b\\
&=a\cdot dep_x+(a\cdot dep_u+2a\cdot dep_{\mathrm{lca}}+b)
\end{aligned}$$

这样就得到了两边关于 $dep_x$ 的一次函数形式的式子，可以树链剖分后使用李超线段树维护区间最小值，时间复杂度 $O(n\log^3n)$。

# 代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
using namespace std;
#define ll long long
#define il inline
#define N 100005
#define lc(x) (x<<1)
#define rc(x) (x<<1)|1
il ll read() {
	ll x=0,f=1;char c=getchar();
	while(c<'0'||c>'9') {if(c=='-') {f=-1;} c=getchar();}
	while(c>='0'&&c<='9') {x=(x<<3)+(x<<1)+(c^48);c=getchar();}
	return x*f;
}
const ll INF=1e18;
struct Edge {
	ll next,u,v,w;
};
struct sgt {
	ll l,r,maxid,minn;
};
sgt tr[N<<2];
ll n,m;
Edge edge[N<<1];
ll head[N],num_edge;
il void add_edge(ll u,ll v,ll w) {
	edge[++num_edge].next=head[u];
	edge[num_edge].u=u,edge[num_edge].v=v,edge[num_edge].w=w;
	head[u]=num_edge;
}
ll fa[N],dep[N],son[N],siz[N];
ll seg[N],rev[N],top[N],tot;
il void dfs1(ll u,ll f,ll ww) {
	fa[u]=f,dep[u]=dep[f]+ww,siz[u]=1;
	for(int i=head[u];i;i=edge[i].next) {
		ll v=edge[i].v,w=edge[i].w;
		if(v==f) continue;
		dfs1(v,u,w);
		siz[u]+=siz[v];
		if(siz[v]>siz[son[u]]) son[u]=v;
	}
}
il void dfs2(ll u,ll f) {
	if(son[u]!=0) {
		seg[son[u]]=++tot;
		rev[tot]=son[u];
		top[son[u]]=top[u];
		dfs2(son[u],u);
	} 
	for(int i=head[u];i;i=edge[i].next) {
		int v=edge[i].v;
		if(seg[v]) continue;
		seg[v]=++tot;
		rev[tot]=v;
		top[v]=v;
		dfs2(v,u);
	}
}
struct Line {
	ll k,b,id;
	Line() {}
	Line(ll a,ll bb,ll i) {
		k=a,b=bb,id=i;
	}
	ll val(ll x) {
		return k*dep[rev[x]]+b;
	}
};
Line a[N<<1];
il void push_up(ll now) {
	tr[now].minn=min(tr[lc(now)].minn,tr[rc(now)].minn);
	tr[now].minn=min(tr[now].minn,min(a[tr[now].maxid].val(tr[now].l),a[tr[now].maxid].val(tr[now].r)));
}
il void build(ll now,ll l,ll r) {
	tr[now].l=l,tr[now].r=r;
	if(l==r) {
		tr[now].maxid=0,tr[now].minn=123456789123456789ll;
		return;
	}
	ll mid=(l+r)>>1;
	build(lc(now),l,mid);
	build(rc(now),mid+1,r);
	push_up(now);
}
il void cover(ll l,ll r,ll now,ll id) {
    ll mid=(l+r)>>1;
    if(a[id].val(mid)<a[tr[now].maxid].val(mid)) swap(id,tr[now].maxid);
    if(l==r) {
    	tr[now].minn=min(tr[now].minn,min(a[tr[now].maxid].val(l),a[tr[now].maxid].val(r)));
    	return;
	}
    if(a[id].val(l)<a[tr[now].maxid].val(l)) cover(l,mid,lc(now),id);
    if(a[id].val(r)<a[tr[now].maxid].val(r)) cover(mid+1,r,rc(now),id);
    push_up(now);
    return;
}
il void modify(ll nl,ll nr,ll l,ll r,ll now,ll id) {
    if(r<nl||nr<l) return;
    if(nl<=l&&r<=nr) {
        cover(l,r,now,id);
        return;
    }
    ll mid=(l+r)>>1;
    modify(nl,nr,l,mid,lc(now),id);
	modify(nl,nr,mid+1,r,rc(now),id);
	push_up(now);
    return;	
}
il ll query(ll qx,ll qy,ll l,ll r,ll now) {
	if(qx<=l&&r<=qy) return tr[now].minn;
	if(qy<l||r<qx) return INF;
	ll ans=min(a[tr[now].maxid].val(max(qx,l)),a[tr[now].maxid].val(min(qy,r))),mid=(l+r)>>1;
	return min(ans,min(query(qx,qy,l,mid,lc(now)),query(qx,qy,mid+1,r,rc(now))));
}
il ll LCA(ll x,ll y) {
	while(top[x]!=top[y]) {
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		x=fa[top[x]];
	}
	if(dep[x]>dep[y]) swap(x,y);
	return x;
}
il void add(ll x,ll y,ll id) {
	ll fx=top[x],fy=top[y];
	while(fx!=fy) {
		if(dep[fx]<dep[fy]) swap(x,y),swap(fx,fy);
		modify(seg[fx],seg[x],1,n,1,id);
		x=fa[fx];
		fx=top[x];
	}
	if(dep[x]>dep[y]) swap(x,y);
	modify(seg[x],seg[y],1,n,1,id);
}
il ll ask(ll x,ll y) {
	ll ans=INF,fx=top[x],fy=top[y];
	while(fx!=fy) {
		if(dep[fx]<dep[fy]) swap(x,y),swap(fx,fy);
		ans=min(ans,query(seg[fx],seg[x],1,n,1));
		x=fa[fx],fx=top[x];
	}
	if(dep[x]>dep[y]) swap(x,y);
	ans=min(ans,query(seg[x],seg[y],1,n,1));
	return ans;
}
int main() {
	a[0].b=123456789123456789ll,a[0].k=0;
	n=read(),m=read();
	for(int i=1;i<n;i++) {
		ll u=read(),v=read(),w=read();
		add_edge(u,v,w);
		add_edge(v,u,w);
	}
	tot=1;
	seg[1]=1;
	rev[1]=1;
	top[1]=1;
	dfs1(1,0,0);
	dfs2(1,0);
	build(1,1,n);
	tot=0;
	for(int i=1;i<=m;i++) {
		ll opt=read(),s=read(),t=read();
		if(opt==1) {
			ll AAA=read(),BBB=read();
			ll lca=LCA(s,t);
			a[++tot]=Line(-AAA,AAA*dep[s]+BBB,tot);
			add(s,lca,tot);
			a[++tot]=Line(AAA,dep[s]*AAA-2*dep[lca]*AAA+BBB,tot);
			add(lca,t,tot);
		}
		else {
			printf("%lld\n",ask(s,t));
		}
		//for(int i=1;i<=n;i++) printf("%lld ",query(seg[i],seg[i],1,n,1));
		//putchar('\n');
	}
	return 0;
}

```

---

## 作者：lhc0707 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P4069)

### 题解

树剖再套个李超线段树即可。观察到 $a \times dis + b$ 这个形式很像一次函数，那我们把 $i$ 点到根节点的距离 $dis(i)$ 看做 $x$，结果看成 $y$，求函数解析式即可。

设 $w = lca(s,t)$，然后把 $s$ 到 $t$ 的路径拆成两段，即 $s$ 到 $w$ 与 $t$ 到 $w$ 两段。

对于 $s$ 到 $w$ 这段，$y = -a \times dis(i) + a\times dis(s) + b$。

对于 $t$ 到 $w$ 这段，$y = a \times dis(i) + a \times (dis(s)-2dis(w))+b$ 。

然后就可以上李超线段树了。注意要开 `long long` 。

```cpp
#include<iostream>
#include<cstdio>
#define ls(p) (p<<1)
#define rs(p) (p<<1|1)
#define int long long
using namespace std;
const int N=1e5+10;
const int INF=123456789123456789ll;
int n,m,h[N],tot;
struct edge{
    int v,w,nxt;
}e[N<<1];
void add(int u,int v,int w)
{
    e[++tot].v=v,e[tot].w=w;
    e[tot].nxt=h[u],h[u]=tot;
}
int fa[N],dep[N],siz[N],hson[N],dfn[N],top[N],Time,dis[N],w[N];
void dfs1(int u,int fath)
{
    fa[u]=fath,dep[u]=dep[fath]+1,siz[u]=1;
    for(int i=h[u];i;i=e[i].nxt)
    {
        int v=e[i].v;
        if(v==fath)continue;
        dis[v]=dis[u]+e[i].w;
        dfs1(v,u);siz[u]+=siz[v];
        if(!hson[u]||siz[v]>siz[hson[u]])hson[u]=v;
    }
}
void dfs2(int u,int tp)
{
    top[u]=tp,dfn[u]=++Time,w[Time]=u;
    if(hson[u])dfs2(hson[u],tp);   
    for(int i=h[u],v;i;i=e[i].nxt)
        if((v=e[i].v)!=fa[u]&&v!=hson[u])dfs2(v,v);
}
inline int LCA(int x,int y)
{
    while(top[x]!=top[y])
    {
        if(dep[top[x]]<dep[top[y]])swap(x,y);
        x=fa[top[x]];
    }
    return dep[x]>dep[y]?y:x;
}
int mn[N<<2],k[N<<2],b[N<<2],cnt;int t[N<<2]; 
inline int val(int id,int x){return k[id]*dis[w[x]]+b[id];}
void build(int p,int pl,int pr)
{
    mn[p]=INF,t[p]=1;
    if(pl==pr)return;
    int mid=(pl+pr)>>1;
    build(ls(p),pl,mid);
    build(rs(p),mid+1,pr);
}
inline void push_up(int p){mn[p]=min(mn[p],min(mn[ls(p)],mn[rs(p)]));}
void update(int p,int pl,int pr,int L,int R,int x)
{
	int mid=(pl+pr)>>1;
	if(L<=pl&&pr<=R)
	{
		bool fl=val(x,pl)<=val(t[p],pl);
		bool fr=val(x,pr)<=val(t[p],pr);
		if(fl&&fr){t[p]=x,mn[p]=min(mn[p],min(val(x,pl),val(x,pr)));return;}
		if(!fl&&!fr)return;
		if(k[x]<=k[t[p]])
		{
			if(val(x,mid)<=val(t[p],mid))update(ls(p),pl,mid,L,R,t[p]),t[p]=x;
			else update(rs(p),mid+1,pr,L,R,x);
		}
		else
		{
			if(val(x,mid)<=val(t[p],mid))update(rs(p),mid+1,pr,L,R,t[p]),t[p]=x;
			else update(ls(p),pl,mid,L,R,x);
		}
		mn[p]=min(mn[p],min(val(x,pl),val(x,pr)));
		push_up(p);return;
	}
	if(L<=mid)update(ls(p),pl,mid,L,R,x);
	if(R>mid)update(rs(p),mid+1,pr,L,R,x);
	push_up(p);return;
}
int query(int p,int pl,int pr,int L,int R)
{
    if(L<=pl&&pr<=R)return mn[p];
    int mid=(pl+pr)>>1,ret=INF;
    if(b[t[p]]!=INF)ret=min(val(t[p],max(pl,L)),val(t[p],min(pr,R)));
    if(L<=mid)ret=min(ret,query(ls(p),pl,mid,L,R));
    if(R>mid)ret=min(ret,query(rs(p),mid+1,pr,L,R));
    return ret;
}
void update_range(int x,int y,int id)
{
    while(top[x]!=top[y])update(1,1,n,dfn[top[x]],dfn[x],id),x=fa[top[x]];
    update(1,1,n,dfn[y],dfn[x],id);
}
int query_range(int x,int y)
{
    int ret=INF;
    while(top[x]!=top[y])
    {
        if(dep[top[x]]<dep[top[y]])swap(x,y);
        ret=min(ret,query(1,1,n,dfn[top[x]],dfn[x]));
        x=fa[top[x]];
    }
    if(dep[x]>dep[y])swap(x,y);
    ret=min(ret,query(1,1,n,dfn[x],dfn[y]));
    return ret;
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<n;i++)
    {
        int u,v,w;cin>>u>>v>>w;
        add(u,v,w),add(v,u,w);
    }
    dfs1(1,0),dfs2(1,1);
    build(1,1,n);
    k[++cnt]=0,b[cnt]=INF;
    int op,s,t,x,y;
    while(m--)
    {
        cin>>op>>s>>t;
        if(op==1)
        {
            cin>>x>>y;
            int w=LCA(s,t);
            k[++cnt]=-x,b[cnt]=x*dis[s]+y;
            update_range(s,w,cnt);
            k[++cnt]=x,b[cnt]=x*(dis[s]-2*dis[w])+y;
            update_range(t,w,cnt);
        }
        else cout<<query_range(s,t)<<"\n";
    }
    return 0;
}
```

---

## 作者：JWRuixi (赞：0)

### 题意

给定一颗 $n$ 个节点的树，每个节点有一个初始数字 $123456789123456789$，$m$ 次操作：

- `1 s t k b`，对每个结点 $u \in \operatorname{Path}(s, t)$，在节点 $u$ 上插入数字 $k\operatorname{dis}(u, s) + b$；
- `2 s t`，查询 $s$ 到 $t$ 的路径上数字的最小值。

$n, m \le 10^5$，提交地址：<https://www.luogu.com.cn/problem/P4069>。

### 分析

考虑看到距离先拆成深度，即变成 $k \times (dep_s + dep_u - 2 \times dep_{\operatorname{lca}(s, u)}) + b$ 的形式，不难想到将将路径拆成上下两部分：

上，式子可以化成：
$$
\begin{aligned}
&= k \times (dep_s - dep_u) + b \\
&= (-k) \times dep_u + (k \times dep_s + b)
\end{aligned}
$$
下，同理（记 $l$ 为 $\operatorname{lca}(s, t)$）：
$$
\begin{aligned}
&= k \times (dep_s + dep_u - 2 \times dep_l) + b \\
&= k \times dep_u + (k \times (dep_s - 2 \times dep_l) + b)
\end{aligned}
$$
两个都是关于 $dep$ 的一次函数，我们考虑维护路径信息，于是进行树剖，不难发现在一条重链上，$dep$ 是单增的，所以李超线段树可以直接使用，直接维护就好了。

时间复杂度 $\mathcal O(n\log^2 n)$。

### Code

提交记录：<https://www.luogu.com.cn/record/137260633>。



---

## 作者：未来姚班zyl (赞：0)

## 题目大意

在一棵带边权的树上，有 $m$ 次操作，每一次操作给定 $x$ 和 $y$，要么给定 $a$ 和 $b$，为 $x$ 和 $y$ 路径上的每个点 $z$ 增加一个 $a\times\operatorname{dis}(x,z)+b$。要么查询 $x$ 到 $y$ 路径上点包含的数的最小值。

## 题目分析

李超线段树板子题。

树链剖分加线段树等于[这道题](https://www.luogu.com.cn/problem/P3384)（蓝）。

树链剖分加可持久化线段树等于[这道题](https://www.luogu.com.cn/problem/P7671)（紫，但感觉比这题还难写）。

树链剖分加李超线段树等于现在的这一题，~~不知道为什么评黑。~~

- 对于添加操作

显然，树上距离肯定是要转换为深度，把路径分为 $x$ 到 $lca$ 和 $y$ 到 $lca$ 两段，这样就可以使得**操作添加的值只和被添加节点的深度有关**，而深度是可以深搜预处理出来的。

然后可以一眼发现添加的数是一个有关 $dep_x$ 的一次函数，可以用带标记永久化的李超线段树轻松维护。

李超线段树的复杂度为 $O(\log^2 n)$，树剖的复杂度为 $O(\log n)$，这一部分操作复杂度为 $O(\log^3 n)$。

- 对于查询操作

由于是要查询区间的最小值，我们在李超线段树的节点中增加一个量表示当前区间的最小值，不然走到底复杂度会爆炸。

其次，一次函数的最值肯定是在定义域的左右端点出现，所以查询时只用记录一下经过的线段树节点的左右端点的取值。

这一部分复杂度为 $O(\log^2 n)$。

总复杂度 $O(n\log^3 n)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define int ll
#define L x<<1
#define R x<<1|1
#define mid (l+r>>1)
#define lc L,l,mid
#define rc R,mid+1,r
#define Root 1,1,n
#define OK l>=Ll&&r<=Rr
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define per(x,y,z) for(int x=(y);x>=(z);x--)
#define pb push_back
#define ull unsigned long long
#define e(x) for(int i=h[x],y=to[i];i;i=nxt[i],y=to[i])
#define E(x) for(auto y:p[x])
#define Pi pair<int,int>
#define ui unsigned int 
inline int read(){int s=0,w=1;char c=getchar();while(c<48||c>57) {if(c=='-') w=-1;c=getchar();}while(c>=48&&c<=57) s=(s<<1)+(s<<3)+c-48,c=getchar();return s*w;}
inline void pf(ll x){if(x<0) putchar('-'),x=-x;if(x>9)pf(x/10);putchar(x%10+48);}
const int N =1e5+5,M=4e5+5,inf=2147000000;
const double eps=1e-6;
const ll mod=998244353,llf=123456789123456789;
using namespace std;
int n=read(),m=read(),h[N],to[N<<1],nxt[N<<1],w[N<<1],cnt,f[N],dep[N],siz[N],son[N],top[N],dfn[N],Time,Id[N];
inline void add(int a,int b,int c){
	to[++cnt]=b,nxt[cnt]=h[a],h[a]=cnt,w[cnt]=c;
} 
inline void dfs(int x,int fa){
	f[x]=fa,siz[x]=1;
	e(x)if(y^fa){
		dep[y]=dep[x]+w[i],dfs(y,x),siz[x]+=siz[y];
		if(siz[y]>siz[son[x]])son[x]=y;
	}
}
inline void Dfs(int x,int low){
	dfn[x]=++Time,Id[Time]=x,top[x]=low;
	if(son[x])Dfs(son[x],low);
	e(x)if(y^f[x]&&y^son[x])Dfs(y,y);
}
struct seg{
	int w,id;
}xd[N<<2];
struct segment{
	int k,b;
}s[N<<1];
int tot;
inline void create(int x,int y){
	s[++tot]={x,y};
}
inline int lca(int x,int y){
	while(top[x]^top[y])dep[top[x]]>dep[top[y]]?x=f[top[x]]:y=f[top[y]];
	return dep[x]<dep[y]?x:y;
}
inline void getup(int x){
	xd[x].w=min({xd[L].w,xd[R].w,xd[x].w});
}
inline int got(int x,int id){
	return dep[Id[x]]*s[id].k+s[id].b;
}
inline bool cmp(int a,int b){
	return a<b;
}
inline void solve(int x,int l,int r,int id){
	if(!xd[x].id)xd[x].id=id;
	if(cmp(got(mid,id),got(mid,xd[x].id)))swap(id,xd[x].id);
	xd[x].w=min({xd[x].w,got(l,xd[x].id),got(r,xd[x].id)});
	if(cmp(got(l,id),got(l,xd[x].id)))solve(lc,id);
	if(cmp(got(r,id),got(r,xd[x].id)))solve(rc,id);
	if(l^r)getup(x);//这里要注意，线段树叶子节点pushup很可能会出现bug，在平常写线段树不会注意到，但李超线段树的递归下传可能会达到叶子结点，所以要特判。
}
inline void build(int x,int l,int r){
	xd[x].w=llf;
	if(l==r)return;
	build(lc),build(rc);
}
inline void modify(int x,int l,int r,int Ll,int Rr,int id){
	if(OK){
		solve(x,l,r,id);
		return;
	}
	if(Rr<=mid)modify(lc,Ll,Rr,id);
	else if(Ll>mid)modify(rc,Ll,Rr,id);
	else modify(lc,Ll,Rr,id),modify(rc,Ll,Rr,id);
	getup(x);
}
inline int query(int x,int l,int r,int Ll,int Rr){
	if(OK)return xd[x].w;
	int now=llf;
	if(xd[x].id)now=min({now,got(max(l,Ll),xd[x].id),got(min(Rr,r),xd[x].id)});
	if(Rr>=l&&Ll<=mid)now=min(now,query(lc,Ll,Rr));
	if(Ll<=r&&Rr>mid)now=min(now,query(rc,Ll,Rr));
	return now;
}
inline void insert(int x,int y,int a,int b){
	int Lca=lca(x,y);
	create(-a,a*dep[x]+b),create(a,a*(dep[x]-2LL*dep[Lca])+b);
	while(top[x]^top[Lca]){
		modify(Root,dfn[top[x]],dfn[x],tot-1);
		x=f[top[x]];
	}
	modify(Root,dfn[Lca],dfn[x],tot-1);
	while(top[y]^top[Lca]){
		modify(Root,dfn[top[y]],dfn[y],tot);
		y=f[top[y]];
	}
	modify(Root,dfn[Lca],dfn[y],tot);
}
inline int quest(int x,int y){
	int ans=llf;
	while(top[x]^top[y]){
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		ans=min(ans,query(Root,dfn[top[x]],dfn[x])),x=f[top[x]];
	}
	if(dep[x]>dep[y])swap(x,y);
	ans=min(ans,query(Root,dfn[x],dfn[y]));
	return ans;
}
signed main(){
	for(int i=1,x,y,z;i^n;i++)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z);
	dfs(1,0),Dfs(1,1),build(Root);
	for(int i=1,opt,x,y,a,b;i<=m;i++){
		opt=read();
		if(opt==1)x=read(),y=read(),a=read(),b=read(),insert(x,y,a,b);
		else x=read(),y=read(),pf(quest(x,y)),putchar('\n');
	}
	return 0;
}
```


---


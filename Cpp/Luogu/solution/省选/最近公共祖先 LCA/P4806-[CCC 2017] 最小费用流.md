# [CCC 2017] 最小费用流

## 题目描述

 **译自 [CCC2017](https://cemc.math.uwaterloo.ca/contests/computing/2017/index.html) Senior T4「[Minimum Cost Flow](https://cemc.math.uwaterloo.ca/contests/computing/2017/stage%201/seniorEF.pdf)」**

Watermoo 中有编号为 $1,2,\dots,N$ 的建筑物。其中还有 $M$ 条管道将建筑物两两连接。由于城市规划的疏漏，$1$ 号建筑是全市唯一的污水处理厂。每条管道可能是*活动的*或是*非活动的*。如果建筑 $1$ 通过活动管道直接或是间接地与其他每个建筑连通，则称活动管道集是一个有效的方案。（每条管道将两个建筑直接连接。如果建筑 $X$ 直接或间接连接建筑 $Y$，且建筑 $Y$ 直接或间接连接建筑 $Z$，那么我们说 $X$ 和 $Z$ 间接连接。）

Watermoo 的市政府正在使用一个 $N-1$ 条管道组成的显然有效的方案，但是这使得政府已经透支很多经费了！每条管道都有各自的月维修费，这是在其活动时必须支付的，一个有效方案的总成本为所有有效管道的维修费的总和。（非活动的管道不花费一分钱。）

此外，一个好消息是：Watermoo 大学的研究人员开发出了一种不完善的管道推进器，你可以在一条管道上使用它。它将从 $C$ 到 $\mathrm{max}(0,C-D)$ 降低该管道的维修成本，$D$ 为该推进器的强度。

市政府希望将成本降到最低，同时也希望你能尽快完成这个任务。每天，城市会允许你激活一条管道并关闭另一条管道。问：你需要多少天才能使一组活动管道形成一个有效方案并使其在所有有效方案和推进方案中费用最小？

请注意，在你规划的过程中方案可能会无效，但是到最后，他应该是一个有效的方案。

## 说明/提示

#### 样例解释 1
因为 $D=0$，所以管道推进器一无是处。

第一天，你应当关闭建筑 $2$ 到 $3$ 的管道并激活建筑 $4$ 到 $1$ 的管道。

#### 样例解释 2
一个可行的解为：首先在连接建筑 $1,2$ 的管道上安装推进器，使成本降低到 $3$。第一天，以连接 $1,3$ 的管道替换连接 $2,3$ 的管道。第二天，以连接 $1,5$ 的管道替换连接 $1,4$ 的管道。

此外，在连接 $1,3$ 或连接 $1,5$ 的管道上安装推进器毫无意义。这样做将会使得该管道的维修成本为 $0$，最优的费用为 $11$ （如你所见，我们已经找到了费用为 $10$ 的方案）。

#### 样例解释 3
初始的方案即最优方案。请注意整数上溢。

对于 $\frac3{15}$ 的数据，$N \le 8,M \le 28,D=0$。

对于另外 $\frac5{15}$ 的数据，$N \le 1\ 000,M \le 5\ 000,D=0$。

对于另外 $\frac3{15}$ 的数据，$D=0$。

对于另外 $\frac2{15}$ 的数据，$N \le 1\ 000,M \le 5\ 000$。

## 样例 #1

### 输入

```
4 4 0
1 2 1
2 3 2
3 4 1
4 1 1```

### 输出

```
1```

## 样例 #2

### 输入

```
5 6 2
1 2 5
2 3 5
1 4 5
4 5 5
1 3 1
1 5 1```

### 输出

```
2```

## 样例 #3

### 输入

```
4 4 0
1 2 715827882
2 3 715827882
3 4 715827882
4 1 715827884```

### 输出

```
0```

# 题解

## 作者：Graphcity (赞：6)

- **简要题意**

给定一张 $n$ 个点，$m$ 条边的带权无向图，其中前 $n-1$ 条边为黑色并构成一棵树，其它边为白色。你需要给出一棵生成树，使得将其中一条边 $(u,v,w)$ 的边权减去 $\min(w,d)$ 后，边权总和最小的同时黑边数量最多。

- **解析**

首先需要构造出边权和最小的生成树。不难想到最小生成树。在构造出最小生成树后，把最大的边权减去 $d$ 即可。这样显然是最优的。

然后考虑黑边数量最多的条件。首先这棵最小生成树的黑边要最多。这个很简单，排序时将边权设为第一关键字，边的颜色设为第二关键字就行了。

但这棵生成树的黑边个数就是最终答案了吗？

当然不一定。你可以用一条不在生成树的黑边换掉在生成树的白边，并使得最后的边权和相同。这可以拆解为三个条件：

- 白边在生成树中黑边两端点组成的路径上。
- 选出的黑边和白边边权均 $\le d$。
- 白边的边权在这棵生成树中最大。

倍增可以轻松解决问题。时间复杂度 $O(m\log m+(n+m)\log n)$。

```cpp
#include<bits/stdc++.h>
#define ll long long 
#define For(i,a,b) for(int i=(a);i<=(b);++i)
#define Rof(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
const int Maxn=2e5;

inline int read()
{
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0' || ch>'9')
    {
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0' && ch<='9')
    {
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}

struct Node{int u,v,w,typ;} Edge[Maxn+5];
inline bool operator<(Node a,Node b) {return (a.w!=b.w?a.w<b.w:a.typ<b.typ);}
inline bool operator>(Node a,Node b) {return (a.w!=b.w?a.w>b.w:a.typ>b.typ);}
int n,m,d,cnt,sum,ans,fa[Maxn+5],vis[Maxn+5];
inline int Find(int x) {return fa[x]==x?x:fa[x]=Find(fa[x]);}

struct Graph
{
    struct Point{int to,nxt,w;} E[Maxn*2+5];
    int Head[Maxn+5],tot;
    inline void Addedge(int x,int y,int z)
    {
        E[++tot]=(Point){y,Head[x],z};
        Head[x]=tot;
    }
    int val[Maxn+5],fa[Maxn+5],anc[Maxn+5][20];
    int num[Maxn+5][20],dep[Maxn+5];
    inline int fmin(int x,int y) {return Edge[x]>Edge[y]?x:y;}
    inline void dfs(int x,int f)
    {
        fa[x]=anc[x][0]=f,num[x][0]=val[x],dep[x]=dep[f]+1;
        For(i,1,19) anc[x][i]=anc[anc[x][i-1]][i-1],
                    num[x][i]=fmin(num[x][i-1],num[anc[x][i-1]][i-1]);
        for(int i=Head[x];i;i=E[i].nxt)
        {
            int y=E[i].to;
            if(y==f) continue;
            val[y]=E[i].w,dfs(y,x);
        }
    }
    inline int LCA(int x,int y)
    {
        int res=0;
        if(dep[x]<dep[y]) swap(x,y);
        Rof(i,19,0) if(dep[anc[x][i]]>=dep[y])
            res=fmin(res,num[x][i]),x=anc[x][i];
        if(x==y) return res;
        Rof(i,19,0) if(anc[x][i]!=anc[y][i])
            res=fmin(res,num[x][i]),res=fmin(res,num[y][i]),
            x=anc[x][i],y=anc[y][i];
        return fmin(res,fmin(num[x][0],num[y][0]));
    }
    inline void Build() {dfs(1,0);}
} G;

int main()
{
    n=read(),m=read(),d=read();
    For(i,1,m)
    {
        int a=read(),b=read(),c=read();
        if(i<n) Edge[i]=(Node){a,b,c,0};
        else Edge[i]=(Node){a,b,c,1};
    }
    For(i,1,n) fa[i]=i;
    sort(Edge+1,Edge+m+1);
    For(i,1,m)
    {
        int u=Edge[i].u,v=Edge[i].v;
        if(Find(u)!=Find(v))
        {
            fa[Find(u)]=Find(v),vis[i]=1;
            if(!Edge[i].typ) cnt++;
            G.Addedge(u,v,i),G.Addedge(v,u,i);
            sum=max(sum,min(d,Edge[i].w));
        }
    }
    ans=cnt,G.Build();
    For(i,1,m)
    {
        if(vis[i] || Edge[i].typ==1) continue;
        int u=Edge[i].u,v=Edge[i].v,w=Edge[i].w;
        int id=G.LCA(u,v);
        if(Edge[id].typ==0) continue;
        if(sum==Edge[id].w+min(d,Edge[i].w)-Edge[i].w)
            ans=cnt+1;
    }
    printf("%d\n",n-1-ans);
    return 0;
}
```

---

## 作者：bellmanford (赞：3)

我们把原先的 $n$ 条边称作**实边**，其它边称作**虚边**。

先求出原图的最小生成树 $\mathcal{T}$ 。

对于 $D=0$ 的情况，最优的方案肯定就是 $\mathcal{T}$ ，那么答案就是 $\mathcal{T}$ 中虚边的数量。

对于 $D\ge 0$ 的情况，显然地，使用管道推进器的边一定是“有效方案”里的最大边。

我们考虑在 $\mathcal{T}$ 上进行调整，由于使用推进器的边费用至多被减为 $0$ ，那么用实边 $x\notin \mathcal{T}$ 替换虚边 $y\in \mathcal{T}$ 使得费用总和不变的充要条件是：

- 将 $x$ 替换  后还是一棵生成树（保证方案有效）。
- $y$ 是 $\mathcal{T}$ 中的最大边。
- $w(x),w(y)\le D$ ，即使用推进器后 $x,y$ 费用均为 $0$ （保证总费用不变）。

于是只需要判断是否存在满足条件的 $x,y$ ，若无则答案同 $D=0$ 的情况，反之答案为 $D=0$ 的情况 $-1$ 。

那么怎么判断呢？~~只要找到满足条件的 $y$ ，然后**相信**一定存在满足条件的 $x$ 把它替换就能过了。~~

只要找到满足条件的 $y$ ，然后枚举边权 $\le D$ 且不在 $\mathcal{T}$ 上的实边 $x$ ，判断一下 $y$ 是否在 $u(x)$ 到 $v(x)$ 在  上的路径里即可，这个写个 LCA 就能维护了。

---

## 作者：bobo2007 (赞：1)

### 题意

给出一张无向图，其中前 $n-1$ 条边为黑边，其余为白边，要求在把任意正好一条边$i$的权值变成 $\max(c_i-d,0)$ 的情况下求生成树**权值最小**的同时白边的最少数目。

### 题解

首先，对于求最小生成树，我们可以使用 `kruskal` 算法求解，设排序的第一关键字为边权大小，第二关键字为边是黑色/白色，按边权小优先，黑边优先的方式求出。

然后对于那一条减去 $d$ 权值的边，根据贪心易知，当边权小于等于 $d$ 时，这条边原来的边权越大减去的边权也越大，当边权大于 $d$ 时，减去的边权总为 $d$，据此可知，减去的边一定是当前生成树中权值最大的边。

我们的目的是尝试使用一条原图中减去 $d$ 的边去**代替**最小生成树中减去 $d$ 的边或维持原样，使得黑边数量**尽量多**。

比如现在最小生成树中边权最大的边边权为 $5$ 且为白边，$d=4$，那么就可以用另一条同样可构成生成树且边权为 $5$ 的黑边去代替。

由此，我们得出初步的算法，用 `kruskal` 求出最小生成树后，对于这颗生成树中边权最大的一条边，其权值设为 $maxx$，将原图中边权等于 $maxx$ 的边记录下来，把它在原图上的边权赋值成 $\max(c_i-d,0)$ 再在原图上跑一次最小生成树，将边的黑/白情况统计下来即可。

但是它不能AC，原因是如果 $maxx < d$，那么就会出现有一些原图上的边，它的权值大于 $maxx$，但是它减去 $d$ 的值也可能小于等于 $0$，此时这些边也可以成为代替的边，叫做"可代替边"。

比如 $maxx = d$，同时 $d=6$，那么我们不仅可以用边权为 $5$ 的边去代替，还可以用边权为 $6$ 的边代替。

于是我们可以重新得出另一个不完整的”生成树“，其中边权小于 $maxx$，再将”可代替边“记录下来，按黑白排序，**只选择一条**这种边组成最小生成树，代表只给一条边减权值，接着在选择了边的”生成树“上再用没有用过的边跑最小生成树，统计黑/白情况即可。

时间复杂度 $O(m\log m)$，忽略并查集复杂度。

### code

```cpp
#include<bits/stdc++.h>
using namespace std;
struct NODE
{
	int x,y,s,o;
	friend bool operator <(NODE u,NODE v)
		{return u.s<v.s||(u.s==v.s&&u.o<v.o);}
}a[200010],b[200010];
int n,m,d,fa[100010],use[100010];
int getfa(int x)
{
	if(fa[x]==x)return x;
	return fa[x]=getfa(fa[x]);
}
int main()
{
	scanf("%d%d%d",&n,&m,&d);
	int i,tot=0,cnt=0;
	for(i=1;i<=m;i++) scanf("%d%d%d",&a[i].x,&a[i].y,&a[i].s);
	for(i=n;i<=m;i++) a[i].o=1;
	for(i=1;i<=n;i++) fa[i]=i;
	sort(a+1,a+1+m);
	for(i=1;i<=m;i++)
	{
		int x=getfa(a[i].x),y=getfa(a[i].y);
		if(x!=y) fa[x]=y,tot++;
		if(tot>=n-1) break;
	}
	int maxs=a[i].s,ans=0;tot=0;
	for(i=1;i<=n;i++) fa[i]=i;
	for(i=1;i<=m;i++)
	{
		if(a[i].s>=maxs)
			{b[++cnt]=(NODE){a[i].x,a[i].y,max(a[i].s-d,0),a[i].o};continue;}
		int x=getfa(a[i].x),y=getfa(a[i].y);
		if(x!=y) fa[x]=y,tot++,ans+=a[i].o;
	}
	sort(b+1,b+1+cnt);
	for(i=1;i<=cnt;i++)
	{
		int x=getfa(b[i].x),y=getfa(b[i].y);
		if(x!=y) {fa[x]=y,tot++,ans+=b[i].o;break;}
	}
	for(i=1;i<=m;i++)
	{
		int x=getfa(a[i].x),y=getfa(a[i].y);
		if(x!=y) fa[x]=y,tot++,ans+=a[i].o;
		if(tot>=n-1) break;
	}
	printf("%d",ans);
	return 0;
}
```

膜拜[@Graphcity](https://www.luogu.com.cn/user/148913)巨佬

---

## 作者：JLGxy (赞：0)

下文我们简称前 $n-1$ 条边为黑边，其余边为白边。

我们先考虑 $D=0$ 的情况，此时费用最小的方案一定是一棵最小生成树，为了使最小生成树中的黑边最多，我们可以对每条边设第二关键字，黑边的第二关键字为 $0$，白边为 $1$。之后跑 `kruskal` 算法求最小生成树。

当 $D\neq 0$ 时，一定是在最小生成树中加一条黑边，再从形成的环上断一条白边。我们假设断掉的白边权值为 $x$，新加的黑边权值为 $y$。

- 当 $y>d$ 时，换边一定是不优的。
- 当 $x>d,y\le d$ 时，与最小生成树矛盾，因此不存在这样的两条边。
- 当 $x\le d,y\le d$ 时，可能更优。

除了 $x\le d,y\le d$ 这个条件以外，为了让费用不变还要满足删掉的边是最小生成树中权值最大的边。

那么如何判断是否存在这样的两条边呢，只需要枚举所有白边 $(u,v)$，判断 $u-\mathrm{lca}(u,v)-v$ 的路径上有没有满足条件的黑边即可。

---

## 作者：MuelsyseU (赞：0)

> 题意：给出一无向图及其一生成树，允许将一条边的权值减少 $d$（最多减小至 $0$）使得原图最小生成树权值和最小，在此基础上求原给定生成树需要改变多少条边方可形成新图的一棵最小生成树。

采用了可撤销并查集简化代码。

那么求出最小生成树，但是对于相同边优先选已经活动的边即可。考虑减小权值。显然最好情形下造成 $-d$ 的贡献，为了贡献绝对值尽可能大，贪心地在生成树上最长边中选取。

那么考虑此时能否减小所需天数。很显然当且仅当最长边 $x$ 一开始非活动，并且找到一条活动边 $y$ 替换之仍能构成最小生成树。

注意到我们求最小生成树时如果选入了非活动边，一定是没有权值不大于自身的活动边可以替换（即不存在连接相同的连通块的活动边）。所以此时一定有 $y$ 的权值大于 $x$ 的权值。

因此 $y$ 仍然为生成树上最长边，也会使用推进器。

于是找到两个连通块间的所有边，这也是简单的。可撤销并查集把最后一条边（肯定最大）撤了即可。对这些边，如果贡献不改变，也就是 $x < y$ 但 $\max(x - d, 0) = \max(y - d, 0)$ 当且仅当两者均取到 $0$。枚举判断即可。


```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn = 400005;
int n, m, d, x, y, lt, fa[maxn], sz[maxn];
int lx, lf, ls, num, ans;
struct Edg {
    int x, y, z, t;
} e[maxn];
inline void merge(int z, int x, int y) {
    // 回滚：fa[fx] = fx.
    lt = z, lx = lf = x, ls = sz[x];
    fa[x] = y, sz[y] += sz[x], ans += e[z].t, ++num;
}
inline bool cmp(Edg a, Edg b) { return a.z == b.z ? a.t < b.t : a.z < b.z; }
inline int find(int x) {
    while (x != fa[x]) x = fa[x] = fa[fa[x]];
    return x;
}
signed main() {
    scanf("%d%d%d", &n, &m, &d);
    for (int i = 1; i <= n; ++i) fa[i] = i;
    for (int i = n; i <= m; i++) e[i].t = 1;
    for (int i = 1; i <= m; ++i) scanf("%d%d%d", &e[i].x, &e[i].y, &e[i].z);
    sort(e + 1, e + m + 1, cmp);
    for (int i = 1; i <= m; ++i) {
        x = find(e[i].x), y = find(e[i].y);
        if (x != y) merge(i, x, y);
        if (num >= n - 1) break;
    }
    // 最后一条边是 lt.
    if (!e[lt].t || e[lt].z > d) {
        printf("%d", ans);
        return 0;
    }
    fa[lx] = lf, sz[lx] = ls;
    for (int i = 1; i <= m; ++i) {
        if (find(e[i].x) != find(e[i].y) && e[i].z <= d) {
            printf("%d", ans - 1);
            return 0;
        }
    }
    printf("%d", ans);
    return 0;
}
```


---


# 「EZEC-1」越狱

## 题目背景

由于监狱长 PF 的疏忽，罪犯小 E 找到了机会越狱。

然而，不学无术的小 E 不懂得保密。PF 很快发现了他的计划，并对他展开了追捕。

因为小 E 自己造船，而狱长 PF 坐的是官方的船，所以在每条航道上的表现不一样，通过时间可能不同。具体见输入格式。

为了不饿肚子，小 E 准备买一个包来装食物。

## 题目描述

小 E 的逃跑路线可以被看作是在 $n$ 个岛屿上，这些岛屿由 $n-1$ 条航线两两相连。

每个岛上都有足够的补给。**假设他每在海上航行一天，就要花费一个单位的食物**。黑心老板规定，**能装 $k$ 单位的食物的背包将会卖 $k$ 万元**。

PF 可以命令在任意两个**通过时间不超过 $d$**，**并且岛 $v$ 到岛 $u$ 的航线上至少有 $q$ 个岛屿**（**不包括 $u$ 和 $v$**）的岛屿 $u$ 与 $v$ 之间建立一条双向航线，通过这条航线的时间为 $\left\lfloor \dfrac{time(u \to v)}{2}\right\rfloor$。由于经济问题，**他只能建造一条额外的航线**。

小 E 可以根据官方给出的航线（**包括新增的航线**）确认 PF 到每个岛上的**最短时间**。

PF 将会在 $t$ 时发现小 E 逃走并开始追击。

为了节省钱，同时逃脱 PF 的追捕，小 E 想请你帮他编一个程序，计算最小的 $k$，使得他能够顺利逃脱到至少 $l$ 个岛屿。

**补给不需要时间，中途抓住也算抓住，同时到达则不算。**

**在岛屿上进行补给不需要时间，可以无限进行补给，只要背包装得下。**

题意概括：

有两个人 $a$，$b$ 和一颗 $n$ 个节点组成的树，$a$ 比 $b$早出发 $t$ 秒。如果两个节点之间通过时间不超过 $d$ 则 $b$ 可以在这两点之间建一条通过时间为 $\left\lfloor \dfrac{time(u \to v)}{2}\right\rfloor$ 的线路，求一个方案使 $a$ 至少到 $l$ 个点的最短时间不比 $b$ 长，并在此基础下要求岛屿之间距离最大值尽量小。

## 说明/提示

【样例解释】

样例 $1$：

![](https://cdn.luogu.com.cn/upload/image_hosting/sc3vdm8k.png)

对于样例 $1$，最后能到的点为 $1,2,4,5$，最小花费为 $7$。由于狱长 PF 从点 $3\to 5$ 要经过点为 $5\to1\to2\to3$，满足中间的点数 $\ge q$，故狱长 PF 可以连边点 $3$ 和点 $5$。如果狱长 PF 选择连边 $5\to3$，那么到点 $3$ 的时间为 $3+1+ \left\lfloor \dfrac{1+5+5}{2}\right\rfloor = 9$。而小 E 到点 $3$ 的最短时间为 $5 + 5 = 10$，不满足条件，故无论 $k$ 的大小，点 $3$ 都是不可到达的。


------------

【数据范围】

| 测试点编号 | $n\le$ | $t\le$ | $p_i,e_i\le$ |    $d\le$    | 时间限制| 空间限制 |特点|
| :----------: | :----------: | :----------: | :----------: | :----------: |:-----: | :----------: |:----------: |
|$1$ | $10$ | $50$ | $50$ | $50$ |$1s$ | $128M$ |加边操作 不影响答案|
|$2$ | $16$ | $50$ | $50$ | $50$ |$1s$ | $128M$ |无|
| $3,4$ | $500$ | ${500}$ | ${500}$ |$500$ | $1s$ |  $128M$ |加边操作 不影响答案|
| $5$ | $500$ | ${500}$ | ${500}$ |${500}$ | $1s$ |  $128M$ |$q = 0$|
| $6,7$ | $500$ | ${500}$ | ${500}$ |${500}$ | $1s$ |  $128M$ |无|
| $8$ | $\small{2.5 \times 10^3}$ | $10^8$ | $10^8$ |$10^8$ | $1s$ | $128M$ |加边操作 不影响答案|
| $9,10$ | $\small{2.5 \times 10^3}$ | $10^8$ | $10^8$ |$10^8$ | $1s$ | $128M$ |$q = 0$|
| $11 \sim 14$ | $\small{2.5 \times 10^3}$ | $10^8$ | $10^8$ |$10^8$ | $1s$ | $128M$ |无|
| $15$ | $\small{2.5 \times 10^3}$ | $10^8$ | $10^8$ |$10^8$ | $1s$ | $256M$ |无|
| $16$ | $\small{7.5 \times 10^3}$ | $10^8$ | $10^8$ |$10^8$ |  $2s$ | $256M$ |无|
| $17$ | $\small{7.5 \times 10^3}$ | $10^8$ | $10^8$ |$10^8$ |  $1s$ | $256M$ |无|
| $18 \sim 20$ | $\small{7.5 \times 10^3}$ | $10^8$ | $10^8$ |$10^8$ |  $3s$ |$512M$ |无|

对于 $100 \%$ 的数据，$n\le 7.5\times 10^3$，$1\le l\le n$，$0\le t \le 10^8$，$0 \le u_i<v_i \le n$，$1\le p_i,e_i,d\le 10^8$，$0\le q\le 20$。

**保证可能新建立的双向航线方案数不超过 $5 \times 10^6$**。


## 样例 #1

### 输入

```
5 3 20 4 2
1 2 5 5
2 3 5 5
2 4 7 10
1 5 4 1```

### 输出

```
7
4```

## 样例 #2

### 输入

```
5 2 6 3 2
1 2 5 3
2 3 8 6
1 4 8 2
2 5 4 6```

### 输出

```
5
3```

## 样例 #3

### 输入

```
5 0 23 4 1
1 2 21 26
1 3 14 16
3 4 4 5
1 5 19 18```

### 输出

```
no solution```

# 题解

## 作者：pocafup (赞：10)

**题外话：**

EZEC官方题解：

有点桑心啊。。。这次除了内部人员居然没人AC这题，搞了好久的说。

唯一一个35分的代码还是写的无优化LCA解法，~~而且他思路我还没看懂~~

被吐槽除了算法之外有点裸，这里讲一下：这题原本的想法其实是后面讲到的正解第二种（虽然当时没有想到tarjan），但是原本的思路并没有第一种正解那么裸

------------

对于 $N \le 10$ 的数据，实时记录小E和PF到每个岛的距离，然后 $dfs$ 枚举每种可能的走法。复杂度 $N!$。

------------

对于 $N \le 16$ 的数据，考虑状压dp。$dp[i][j]$ 记录当前的状态以及当前所在的点。状压完后对每个状态进行统计。如果状态数超过 $l$ 并且小于当前所能得到的最小值 ，那么就更新答案。

在状压过程中更新答案会更快~~但这个跟正解没啥关系~~。

复杂度为 $n*2^n$，可以过。

代码略（~~状压你都会你跟我讲你想不出正解？~~）

------------


当数字变大后，指数级别的答案肯定不合法。因此，我们需要一个更快的方法。

第一步观察到狱长的最短距离在加边前后都是一个固定值（未必相等）。因此，我们可以预处理这个距离，加边，然后再预处理一次。

可以发现，由于只有 $N-1$ 条边，在加边之前每一条边到另一条边都有唯一的最短路。

在 $N\le500$ 的数据时，我们可以对每个点跑一次 $dij$，预处理出每个点到其他任意点的距离和长度，再进行加边操作。**狱长只能加一次边的操作我们可以使用分层图来实现。**

加完边后，暴力枚举 $K$，取最大的 $K$ 作为答案。

暴力枚举的部分代码：

```cpp
//maxi为最大的p_i和e_i的值
inline void find_ans(){
  int ans1=-1,ans2;
  for (int i=1;i<=maxi;i++){
    int re = dijk(1,i);
    if(re>=L) ans1 = i,ans2 = re;
  }
  if (ans1==-1) cout << "no solution";
  else cout << ans1 << endl << ans2;
}
```

这个算法复杂度为 $N^2 \times Max(p_i,e_i)$，大约为 $500^3$，可以在规定时间内跑完。

另一种方法为保留到每条边的最小 $K$ 值，预处理后对整张图统计一次最小答案，这里留给读者自行思考。

------------

当 $N \le2500$ 的时候，我们需要一个更加简单的方法。

我们可以发现，既然每两点只有一条边互通，那么他们只有一个公共祖先。他们之间的最短距离可以表示为两点分别到公共祖先的距离的和，他们之间的点的数量可以表示为两个点的深度减去祖先的深度。这个操作可以使用 $LCA$ 来实现。

因此，我们只需要从点 $1$ 开始跑一个 $dij$ ，然后对于每两点判断一下是否能够加边。

加完边后，我们可以二分 $K$，如果小 E 能够跑到 $L$ 个点上，并且到每个点的距离都比狱长小，那么这个 $K$ 是可实现的。

这个做法的复杂度为 $N^2logN$ ，可以过 $N \le 2500$ 的数据

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>
#include <fstream>
#include <cstring>
#include <math.h>
using namespace std;
const int MAXN = 5e3+5;
#define pp pair<long long,long long>
#define f first
#define s second
const int BD = 14;
int n,m,t,L,q,d,level[MAXN<<1],pa[MAXN<<1][BD];
inline long long read() {
  long long x=0,w=1;
  char ch;
  while(ch<'0'||ch>'9'){
    if(ch=='-') w=-1;
    ch=getchar();
  }
  while(ch>='0'&&ch<='9')
  x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
  return x*w;
}
bool inq[MAXN<<1];
vector<pp> adj[MAXN<<1],adj2[MAXN<<1];
long long dist1[MAXN<<1],dist2[MAXN<<1],dist3[MAXN];
int LCA(int u, int v) {
	if(level[u] < level[v]) swap(u,v);
	int diff = level[u] - level[v];
	for(int i=0; i<BD; i++) if((diff>>i)&1 ) u = pa[u][i];
	if(u == v) return u;
	for(int i=BD-1; i>=0; i--) if(pa[u][i] != pa[v][i]) {
		u = pa[u][i];
		v = pa[v][i];
	}
	return pa[u][0];
}//找LCA的板子
void set_up_lca(int nn){
  for(int i = 1 ; i <= BD ; i++){
    for(int j = 0; j < nn ; j++){
      if(pa[j][i-1] != -1) pa[j][i] = pa[pa[j][i-1]][i-1] ;
    }
  }
}//lca的板子
void dfs(int pos, int lev, int prev){
  pa[pos][0] = prev;
  level[pos] = lev;
  for (pp v : adj[pos]){
    if (v.f==prev) continue;
    dfs(v.f,lev+1,pos);
  }
}//把深度找出来
inline void dij(int source, vector<pp> adja[MAXN], long long dist[MAXN]){
  for (int i=0;i<=2*n;i++) dist[i] = 1e9;
  queue<int> q;
  dist[source] = t;
  q.push(source);
  while(!q.empty()){
    long long qs = q.front(); q.pop();
    inq[qs] = false;
    for (pp v : adja[qs]){
      if (dist[v.f]>dist[qs]+v.s){
        dist[v.f]=dist[qs]+v.s;
        if (!inq[v.f]) inq[v.f] = true,q.push(v.f);
      }
    }
  }
}//预处理距离
inline void add_edge(){
  for (int i=1;i<=n;i++){
    for (int j=i+1;j<=n;j++){
      if(i==j)continue;
      int lca = LCA(i,j);
      long long dis = dist2[i]+dist2[j]-2*dist2[lca];
      if (dis<=d && level[i]+level[j]-2*level[lca]-1>=q){//如果他们距离小于D且之间有超过Q个点
        adj2[i].push_back(make_pair(j+n,floor(dis/2)));
        adj2[j].push_back(make_pair(i+n,floor(dis/2)));
      }
    }
  }
}
bool seem[MAXN];
inline int dijk(int source, long long num){
  memset(dist1,0x3f3f3f,sizeof(dist1));
  memset(seem,0,sizeof(seem));
  queue<int> q;
  int re = 0;
  dist1[source] = 0;
  q.push(source);
  while(!q.empty()){
    long long qs = q.front(); q.pop();
    inq[qs] = false;
    if (!seem[qs]) seem[qs] = true,re++;
    for (pp v : adj[qs]){
      if (v.s>num) continue;//如果这条边的距离用K足够
      if (dist1[v.f]>dist1[qs]+v.s && dist1[qs]+v.s<=dist3[v.f]){//如果
        dist1[v.f]=dist1[qs]+v.s;
        if (!inq[v.f])inq[v.f] = true,q.push(v.f);
      }
    }
  }
  return re;
}
inline void bs(){
  long long l = 0, r = 1e18;
  while(l!=r-1){
    long long mid = (l+r)/2;
    if (dijk(1,mid)>=L) r = mid;
    else l = mid;
  }//二分
  if (dijk(1,l)>=L) cout << l << endl << dijk(1,l);
  else if (dijk(1,r)>=L) cout << r << endl << dijk(1,r);
  else cout << "no solution";
}
inline void update_dis(){
  for (int i=1;i<=n;i++) dist3[i] = min(dist2[i],dist2[i+n]);
}

int u,v,p,e;
int main(){
  n = read(); t= read(); d = read(); L = read();q = read();
  for (int i=0;i<n-1;i++){
    u = read(); v = read(); p = read(); e = read();
    adj[u].push_back(make_pair(v,p));
    adj[v].push_back(make_pair(u,p));
    adj[u+n].push_back(make_pair(v+n,p));
    adj[v+n].push_back(make_pair(u+n,p));
    adj2[u].push_back(make_pair(v,e));
    adj2[u+n].push_back(make_pair(v+n ,e));
    adj2[v].push_back(make_pair(u,e));
    adj2[v+n].push_back(make_pair(u+n ,e));//别忘了双向边和分层图边的加法
  }
  for (int i=1;i<(MAXN<<1);i++){
    for (int j=0;j<BD;j++){
      pa[i][j] = -1;
    }
  }
  dfs(1,0,-1);
  set_up_lca(n*2);//预处理公共祖先
  dij(1,adj2,dist2);//预处理距离
  add_edge();//加边
  dij(1,adj2,dist2);//再预处理距离
  update_dis();//更新距离
  bs();//二分
}
```

另一种更简单的思维方法是暴力枚举节点进行 $dijkstra$ ，这里留给读者自行思考


------------


当 $N\le 7500$ 的时候，$N^2logN$ 会直接被卡掉。

这时候，我们需要一个更简便的方法。

这时候，万能的 $dfs$ 就出来了。

暴力枚举每个节点，顺着边往下走。当距离超过 $D$ 时就返回，否则如果中间岛屿超过 $Q$ 就加边。

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>
#include <math.h>
using namespace std;
#define G() Cr=getchar()
#define LL long long
LL Xr,Fr;char Cr;
int bian;
inline LL rd(){
	Xr=0,Fr=1;G();
	while(Cr<'0'||Cr>'9'){if(Cr=='-')Fr=-1;G();}
	while(Cr>='0'&&Cr<='9')Xr=(Xr<<1)+(Xr<<3)+Cr-'0',G();
	return Xr*Fr;
}
#define MAX_N 15000
#define MAX_M 10000000
#define oo 9999999999999999
int n, T, D, L, Q;
LL dis[MAX_N], Dis[MAX_N];
LL va[MAX_N], Va[MAX_M];
int to[MAX_N], ne[MAX_N], he[MAX_N], cnt;
int To[MAX_M], Ne[MAX_M], He[MAX_M], Cnt;
int add_u[MAX_M], add_v[MAX_M], add_t;
LL add_d[MAX_M];
int a, b;
LL c, d;
bool vis[MAX_N];
LL ans, Ans, Ma, num;

void add(int u, int v){
	to[++cnt]=v;
	ne[cnt]=he[u];
	he[u]=cnt;
	va[cnt]=c;
}

void Add(int u, int v){
	To[++Cnt]=v;
	Ne[Cnt]=He[u];
	He[u]=Cnt;
	Va[Cnt]=d;
}

void dfs_ae(int U, int u, LL dd, int t, int la){
	if(dd>D)return;
	if(t>=Q) add_u[++add_t]=U, add_v[add_t]=u, add_d[add_t]=floor(dd/2);
	for(int i=He[u];i;i=Ne[i]) if(To[i]!=la && To[i]<=n) dfs_ae(U,To[i],dd+Va[i],t+1,u);
}//预处理

void Dijk(int U){
	priority_queue< pair<int,int> >q;
	q.push(make_pair(0,U));
	for(int i=1;i<=2*n;i++) Dis[i]=oo;
	Dis[U]=0;
	while(!q.empty()){
		int u=q.top().second;
		if (-q.top().first>Dis[u]) {q.pop(); continue;}
		q.pop();
		vis[u]=1;
		for(int i=He[u];i;i=Ne[i]){
			int v=To[i];
			if(vis[v])continue;
			if(Dis[v]>Dis[u]+Va[i]){//跟之前同样的操作
				Dis[v]=Dis[u]+Va[i];
				q.push(make_pair(-Dis[v],v));
			}
		}
	}
}
bool seem[MAX_N];
void dijk(int t){
	memset(seem,0,sizeof(seem));
	priority_queue< pair<int,int> >q;
	q.push(make_pair(0,1));
	for(int i=1;i<=n;i++) dis[i]=oo, vis[i]=0;
	dis[1]=0;
	while(!q.empty()){
		int u=q.top().second;
		q.pop();
		num++;
		seem[u] = true;
		for(int i=he[u];i;i=ne[i]){
			int v=to[i];
			if(seem[v])continue;
			if(dis[v]>dis[u]+va[i] && dis[u]+va[i]<=T+Dis[v] && va[i]<=t){
				dis[v]=dis[u]+va[i];
				q.push(make_pair(-dis[v],v));
			}
		}
	}
}

bool check(int t){
	num=0;
	dijk(t);
	if(num>=L){
		Ans=num;
		return 1;
	}
	else return 0;
}//某数字是否能实现

int main(){
	cin>>n>>T>>D>>L>>Q;
	for(int i=1;i<n;i++){
		a=rd(), b=rd(), c=rd(), d=rd();
		Ma=max(Ma,c);
		if(c) add(a,b), add(b,a);
		if(d) Add(a,b), Add(b,a), Add(a+n,b+n), Add(b+n,a+n);
	}
	for(int i=1;i<=n;i++) dfs_ae(i,i,0,-1,0);//预处理狱长距离
	for(int i=1;i<=add_t;i++) {
		d=add_d[i], Add(add_u[i],add_v[i]+n);}//加边
	Dijk(1);//二次处理
	for(int i=1;i<=n;i++)Dis[i]=min(Dis[i],Dis[i+n]);//更新距离
	ans=2147483647;
	int l=0, r=Ma;
	while(l<=r){
		int mid=(l+r)>>1;
		if(check(mid)) ans=mid, r=mid-1;
		else l=mid+1;
	}//二分套路
	if(ans==2147483647)puts("no solution");
	else cout<<ans<<endl<<Ans;
}
```

正解其实并不比75分做法难想。然而，这题有一个玄学的地方：

```cpp
void dfs_ae(int U, int u, LL dd, int t, int la){
	if(dd>D)return;
	if(t>=Q) add_u[++add_t]=U, add_v[add_t]=u, add_d[add_t]=floor(dd/2);//这行
	for(int i=He[u];i;i=Ne[i]) if(To[i]!=la && To[i]<=n) dfs_ae(U,To[i],dd+Va[i],t+1,u);
}
```

看起来确实像是多此一举。貌似还多开了一个数组。

然而，如果将这里改成这样:

```cpp
void dfs_ae(int U, int u, LL dd, int t, int la){
	if(dd>D)return;
	d = floor(dd/2);
	Add(U,u);
	// if(t>=Q) add_u[++add_t]=U, add_v[add_t]=u, add_d[add_t]=floor(dd/2);
	for(int i=He[u];i;i=Ne[i]) if(To[i]!=la && To[i]<=n) dfs_ae(U,To[i],dd+Va[i],t+1,u);
}
```

就会惊奇的发现获得了70分的成绩。虽然总复杂度不变，但是如此建边有一个特点：每次 dfs 边加边，会导致所有边都被枚举了一次，最后复杂度可能变为 $O(N(N+M))$ ， $M$ 为加边条数，导致时间复杂度爆炸。

这种解法复杂度为 $N^2$，能够在规定时间跑完。

------------


另一种较为复杂的方法为 $LCA$ $+$ $tarjan$ 。我们可以发现，如果从树的顶端往下跑，那么当某两个点在同一棵树内，他们的祖先的祖先对他没有任何意义。同理，如果从下往上跑，那么子树对于父节点也没有任何意义。于是，当我们处理完子树，我们可以直接合并子树的祖先。（~~其实只能说类似tarjan~~）

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>
#include <fstream>
#include <cstring>
#include <math.h>
using namespace std;
const int MAXN = 7e3+505;
#define pp pair<long long,long long>
#define f first
#define s second
const int BD = 12;
const int MAXB = 10000000;
int n,m,t,L,q,ed,d,level[MAXN<<1];
inline long long read() {
	long long x=0,w=1;
	char ch;
	while(ch<'0'||ch>'9'){
		if(ch=='-') w=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
	return x*w;
}
struct Edge{
  int t,d,nxt;
}edge[MAXB],edge2[MAXB];
int head[MAXN],head2[MAXN<<1],tot,tot2;
inline void add(int from, int to, int dis){
  edge[++tot].t = to;
  edge[tot].d = dis;
  edge[tot].nxt = head[from];
  head[from] = tot;
}
inline void add2(int from, int to, int dis){
  edge2[++tot2].t = to;
  edge2[tot2].d = dis;
  edge2[tot2].nxt = head2[from];
  head2[from] = tot2;
}
bool inq[MAXN<<1];
long long dist1[MAXN],dist2[MAXN<<1],dist3[MAXN];
void dfs(int pos, int lev, int prev){
	level[pos] = lev;
	for(int i = head[pos];i;i=edge[i].nxt){
    int to =edge[i].t;
		if (to==prev) continue;
		dfs(to,lev+1,pos);
	}//同样写lca的配方
}
inline void dij(int source){
  fill(dist2+1,dist2+1+2*n,1e18);
	queue<int> q;
	dist2[source] = t;
	q.push(source);
	while(!q.empty()){
		long long qs = q.front(); q.pop();
		inq[qs] = false;
    for (int i=head2[qs];i;i=edge2[i].nxt){
      int to = edge2[i].t,d = edge2[i].d;
      if (dist2[to]>dist2[qs]+d){
        dist2[to]=dist2[qs]+d;
        if (!inq[to])inq[to] = true,q.push(to);
      }
    }
	}
}//还是同样的方法
int father[MAXN];
int LCA(int x){
	return father[x]^x?father[x]=LCA(father[x]):x;
}//lca的方法
int bian = 0;
bool visit[MAXN];
inline void add_edge(int i,int fa){
	father[i]=i;
	for(int j=head2[i];j;j=edge2[j].nxt){
    int to = edge2[j].t;
		if(to^fa && !visit[to]){
			add_edge(to,i);
			father[to]=i;
		}//先建子树,然后合并
	}
	visit[i]=true;
	for (int j=1;j<=n;j++){
		if(i==j || !visit[j])continue;
		int lca = LCA(j);
		long long dis = dist2[i]+dist2[j]-(dist2[lca]<<1);
		if (dis<=d && level[i]+level[j]-(level[lca]<<1)-1>=q){
			bian+=2;
      add2(i,j+n,dis/2);
      add2(j,i+n,dis/2);
		}
	}//建边
}
bool seem[MAXN];
inline int dijk(int source, long long num){
	memset(dist1,0x3f3f3f,sizeof(dist1));
	memset(seem,0,sizeof(seem));
	queue<int> q;
	int re = 0;
	dist1[source] = 0;
	q.push(source);
	while(!q.empty()){
		long long qs = q.front(); q.pop();
		inq[qs] = false;
		if (!seem[qs]) seem[qs] = true,re++;
		for(int i = head[qs];i;i=edge[i].nxt){
      int to = edge[i].t,d = edge[i].d;
			if (d>num) continue;
			if (dist1[to]>dist1[qs]+d && dist1[qs]+d<=dist3[to]){
				dist1[to]=dist1[qs]+d;
				if (!inq[to])inq[to] = true,q.push(to);
			}
		}
	}
	return re;
}//二分dij
inline void bs(){
	long long l = 0, r = 1e18;
	while(l!=r-1){
		long long mid = (l+r)/2;
		if (dijk(1,mid)>=L) r = mid;
		else l = mid;
	}
	if (dijk(1,l)>=L) cout << l << endl << dijk(1,l);
	else if (dijk(1,r)>=L) cout << r << endl << dijk(1,r);
	else cout << "no solution";
}//二分
inline void update_dis(){
	for (int i=1;i<=n;i++) dist3[i] = min(dist2[i],dist2[i+n]);
}//更新
int u,v,p,e;
int main(){
	n = read(); t= read(); d = read(); L = read();q = read();
	ed = n;
	for (int i=0;i<n-1;i++){
		u = read(); v = read(); p = read(); e = read();
    add(u,v,p);
    add(v,u,p);
    add2(u,v,e);
    add2(v,u,e);
    add2(u+n,v+n,e);
    add2(v+n,u+n,e);
	}
	dfs(1,0,-1);
	dij(1);
	add_edge(1,-1);
	dij(1);
	update_dis();
	bs();//这里方法基本与上面一样
}
```

------------

部分分方法：

对于 $Q=0$ 的点，我们可以直接两两判断时间是否超越 $D$，并不需要判断之间的距离。期望得分 $35$，实际得分 $45$。

对于不加边的做法，~~我们就不加边~~，不使用分层图，预计得分 $20$，实际得分 $20$。

------------


对于大常数选手（比如我），我们给与了足够大的空间和时间（ $2$ 倍空间时间）。但由于要卡 $75$ 分做法，如果正解常数巨大的话无法满分。

---

## 作者：verden (赞：2)

首先思路是按照出题人的题解思路。

对于小E，我们按照题目给的进行建图。

对于监狱长建一个图，然后对于额外航线，我们使用分层图。一层是没有使用过额外航线，一层是使用过额外航线。两层之间使用额外航线进行连接。

然后每次进行二分，二分背包的容量，也就是可以经过的最大边。然后在这个限制下，进行最短路，这个最短路的dist要小于等于监狱长的dist(就是小E到达这个点的时间小于监狱长到达这个点的时间)，才可以更新。

然后每次返回容量是一个值的情况下小E可以到达的点的数量，其实就是`dijkstra`算法中多少个点的`st`被设置为`true`。

然后重点就是进行建边。

1. 我们可以暴力进行枚举两个点，然后每次求解`lca`，然后对于满足要求的点对进行建边，这里时间复杂度为 $O(n^2log(n))$ 。[提交记录65分](https://www.luogu.com.cn/record/92554784)
2. 可以使用dfs，从每个点开始进行dfs，然后找到其中一个点为当前点时的额外航线，进行统一加边，时间复杂度为 $O(n^2)$ 。[提交记录85分](https://www.luogu.com.cn/record/92555111)
3. 由于我写的代码常数巨大，出题人提到的2，dfs建边的方式只得到了85分，然后我考虑到可以使用dsu on tree 来进行统计有那些边,然后就通过了。[提交记录100](https://www.luogu.com.cn/record/92560015)

参考代码：

```
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <vector>
#include <queue>
#include <set>

using namespace std ;

using ll = long long ;
using pii = pair<ll,ll> ;

const int N = 4e5 + 100,M = 6 * N,ZZ = 6e6 + 10 ;
const int INF = 0x3f3f3f3f ;

int n,zzz,ddt,qt ;
int h1[N],h2[N],e[M+ZZ],ne[M+ZZ],idx ;
struct Node{
    int a,b ;
    ll c ;
}eg[ZZ] ;
ll dist1[N],dist2[N],w[M+ZZ] ;
int dfn[N],son[N],sz[N],dui[N],time_stamp ;
ll dist[N],dep[N] ;
set<pii> ss ;
bool st[N] ;

void add(int h[],int a,int b,ll c){
    e[idx] = b,w[idx] = c,ne[idx] = h[a],h[a] = idx ++ ;
}


// 对图2进行第一次dfs，处理出dfn，和dist，dep，sz，和重儿子 son
void dfs(int u,int fa,int depth,ll distance){
    dfn[u] = ++ time_stamp,dui[time_stamp] = u ;
    sz[u] = 1 ;
    dist[u] = distance,dep[u] = depth ;
    for(int i = h2[u] ; ~ i ; i = ne[i]){
        int j = e[i] ;
        if(j == fa) continue ;
        dfs(j,u,depth+1,distance+w[i]) ;
        sz[u] += sz[j] ;
        if(sz[son[u]] < sz[j]) son[u] = j ;
    }
}

// 进行dsu on tree
void dfs2(int u,int fa,int tag){  // tag代表当前是否清空
    for(int i = h2[u] ; ~ i ; i = ne[i]){
        int j = e[i] ;
        if(j == fa || j == son[u]) continue ;
        dfs2(j,u,1) ; // 进行处理所有轻儿子，从轻儿子回来要清空
    }

    if(son[u]) dfs2(son[u],u,0) ; // 进行变量重儿子

    // 进行暴力添加所有的轻儿子
    for(int i = h2[u] ; ~ i ; i = ne[i]){
        int j = e[i] ;
        if(j == fa || j == son[u]) continue ;

        // 变量轻儿子j
        for(int x = dfn[j] ; x <= dfn[j] + sz[j] - 1 ; x ++){
            int id = dui[x] ;
            // 进行加边的操作
            ll totdis = dist[id] - 2 * dist[u] ;

            for(pii t : ss){
                if(t.first + totdis > ddt) break ;  // 当超过最大时间就直接break
                if(dep[t.second] + dep[id] - 2 * dep[u] - 1 >= qt) eg[++zzz] = {t.second,id,(t.first+totdis)/2} ;
            }
        }

        // 向set中添加元素
        for(int x = dfn[j] ; x <= dfn[j] + sz[j] - 1 ;x ++){
            int id = dui[x] ;
            ss.insert({dist[id],id}) ;
        }
    }

    // 进行统计 u 与 u子树中满足的点对
    for(pii t : ss){
        if(t.first - dist[u] > ddt) break ;
        if(dep[t.second] - dep[u] - 1 >= qt) eg[++zzz] = {u,t.second,(t.first-dist[u])/2} ;
    }

    // 向set中添加元素
    ss.insert({dist[u],u}) ;

    if(tag){
        ss.clear() ;
    }
}

// 进行求解最短路
// len代表节点个数
// h代表使用那个图，因为是链式前向星进行建图
// dist代表求解放到那个数组中
// sta代表初始值，对于监狱长是有初始值（发现时间），对于逃犯初始值是0
// tag 代表最短路的判断条件，因为逃犯在求最短路的时候经过的最大边要小于等于lim
// 并且还要时间小于监狱长的最短时间
int dijkstra(int len,int h[],ll dist[],int sta,int tag,int lim){
    fill(dist,dist+len+1,INF) ;
    fill(st,st+len+1,0) ;
    dist[1] = sta ;
    priority_queue<pii,vector<pii>,greater<pii>> q ;
    q.push({sta,1}) ;

    while(q.size()){
        pii t = q.top() ;
        q.pop() ;
        ll ver = t.second,distance = t.first ;
        
        if(st[ver]) continue ;
        st[ver] = 1 ;

        for(int i = h[ver] ; ~ i ; i = ne[i]){
            int j = e[i] ; 
            if(tag){
                if(w[i] > lim) continue ;
                if(dist[j] > distance + w[i] && distance + w[i] <= dist2[j]){
                    dist[j] = distance + w[i] ;
                    q.push({dist[j],j}) ;
                }
            }
            else {
                if(dist[j] > distance + w[i]){
                    dist[j] = distance + w[i] ;
                    q.push({dist[j],j}) ;
                }
            }
        }
    }

    int ct = 0 ;
    for(int i = 1 ; i <= len ; i ++)  ct += st[i] ;
    return ct ;
}

int main(){
    int t,target ;
    scanf("%d%d%d%d%d",&n,&t,&ddt,&target,&qt) ;
    memset(h1,-1,sizeof h1) ;
    memset(h2,-1,sizeof h2) ;
    int mx = 0 ;
    for(int i = 1 ; i <= n - 1 ; i ++){
        int a,b,c,d ;
        scanf("%d%d%d%d",&a,&b,&c,&d) ;

        // 这里进行建边，建个分层图
        // 对于分层图来说，h1 是p的边，h2里面存储pf的边
        add(h1,a,b,c),add(h1,b,a,c) ;
        mx = max(mx,c) ;
        add(h2,a,b,d),add(h2,b,a,d) ;
        add(h2,a+n,b+n,d),add(h2,b+n,a+n,d) ;
    }
    // 对第第二个进行处理,处理出所有的加边
    
    // 这里使用set进行存边，然后使用类似于dsu on tree 的方式进行运算
    dfs(1,0,0,0) ;
    dfs2(1,-1,0) ;
    // 进行加边
    for(int i = 1 ; i <= zzz ; i ++)
        add(h2,eg[i].a,eg[i].b+n,eg[i].c),add(h2,eg[i].b,eg[i].a+n,eg[i].c) ;
    // 处理出监狱长的最短路
    dijkstra(2 * n,h2,dist2,t,0,0) ;
    for(int i = 1 ; i <= n ;i ++) dist2[i] = min(dist2[i],dist2[i+n]) ;
    
    // 进行二分
    int l = 0,r = mx ;
    while(l < r){
        int mid = l + r >> 1 ;
        if(dijkstra(n,h1,dist1,0,1,mid) >= target) r = mid ;
        else l = mid + 1 ;
    }

    if(dijkstra(n,h1,dist1,0,1,l) >= target) printf("%d\n%d\n",l,dijkstra(n,h1,dist1,0,1,l)) ;
    else puts("no solution") ;
    return 0 ;
}
```

---


# 「KDOI-07」对树链剖分的爱

## 题目背景

楼下说得对，但是 sszcdjr 在 NOI 2024 D2T2 用巧妙做法把我的暴力树剖爆掉了。

楼上说得对，但是树链剖分把我送上 10√ 了，所以我出了这道题以表示我对树链剖分的爱喵。

## 题目描述

给出一棵 $n$ 个节点以 $1$ 为根的有根树。对于第 $2\leq i\leq n$ 个节点，其父亲 $f_i$ 在 $[l_i,r_i]$ 中均匀随机。每个树的边有边权，初始为 $0$。

现在有 $m$ 次操作，第 $i$ 次操作表示将 $(u_i,v_i)$ 的路径上所有的边的权值统一加上 $w_i$。$m$ 次操作结束后，对于所有 $i=2\sim n$，求 $(i,f_i)$ 边上权值的期望，对 $998244353$ 取模。

## 说明/提示

### 样例解释 1

所有节点的父亲共有 $2$ 种可能的情况：

- $f_2=1,f_3=1$，此时 $(f_2,2),(f_3,3)$ 边上的权值分别是 $0,2$。

- $f_2=1,f_3=2$，此时 $(f_2,2),(f_3,3)$ 边上的权值分别是 $2,2$。

于是边 $(f_2,2)$ 边权的期望为 $\dfrac{0+2}{2}=1$，边 $(f_3,3)$ 边权的期望为 $\dfrac{2+2}{2}=2$。


---
### 数据规模与约定
**本题采用捆绑测试。**

| $\text{Subtask}$ | $n\leq$ | $m\leq$ | 分数 |
| :-----------: | :-----------: |  :-----------: | :-----------: |
| $1$ | $10$ | $10$ | $20$ |
| $2$ | $50$ | $50$ | $20$ |
| $3$ | $500$ | $500$ | $20$ |
| $4$ | $5000$ | $1$ | $20$ |
| $5$ | $5000$ | $5000$ | $20$|


对于所有数据，保证 $1\leq n,m\leq5000$，$1\leq l_i\leq r_i<i$，$1\leq u_i,v_i\leq n$，$1\leq w_i\leq 10^9$。

## 样例 #1

### 输入

```
3
1 1
1 2
1
1 3 2```

### 输出

```
1 2```

## 样例 #2

### 输入

```
5
1 1
1 2
3 3
2 4
9
2 5 497855355
1 5 840823564
3 1 295265328
2 3 457999227
4 4 235621825
2 1 86836399
5 2 800390742
5 3 869167938
2 4 269250165```

### 输出

```
405260353 409046983 606499796 13504540```

# 题解

## 作者：xhgua (赞：13)

我们考虑对于一次操作的 $u, v$，不妨设 $u\lt v$，则 $(v, f_v)$ 这条边一定被加上了 $w$，证明显然。

于是我们可以考虑这样一个做法：每次给 $v$ 的答案加上 $w$，然后以相同的概率跳到 $f_v\in [l_v, r_v]$ 的其中一个父亲，同时令 $w \leftarrow \dfrac{w}{r_v - l_v + 1}$，此时该问题被我们递归到了一个规模更小的子问题。

发现这个形式十分像 dp，我们不妨将一次操作先挂在 $g_{u, v}$ 上，$m$ 次操作结束后，我们对 $g$ 进行 dp，设当前状态为 $g_{u, v}(u\lt v)$，枚举 $v$ 的父亲 $k\in [l_v, r_v]$，有转移：
$$
g_{u, k} \leftarrow g_{u, k} + \dfrac{g_{u, v}}{r_v - l_v + 1}
$$
这里同样钦定 $u\lt k$，若 $u\gt k$ 需要将 $g_{u, k}$ 改为 $g_{k, u}$，时间复杂度 $\mathcal{O}(n^3 + m)$。

最后点 $u$ 的答案即为 $\sum\limits_{u\gt v}g_{v, u}$。

我们考察这个转移形式，发现相当于是给 $g$ 数组的一段 L 形区域加上了一个固定值，使用二维差分优化即可，时间复杂度 $\mathcal{O}(n^2 + m)$。

结合代码可能比较好理解。

```cpp
#include <bits/stdc++.h>

using i64 = long long;

constexpr int N = 5e3 + 5, P = 998244353;

using Z = ModInt<P>;

int n, m;
int l[N], r[N];
Z g[N][N], inv[N], ans[N];

int main() {

	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);

	std::cin >> n;	
	for (int i = 2; i <= n; i++) std::cin >> l[i] >> r[i];
	for (int i = 1; i <= n; i++) inv[i] = Z(1) / i;

	auto add = [&](int l1, int r1, int l2, int r2, Z val) -> void {
		g[r1][r2] += val;
		g[l1 - 1][r2] -= val;
		g[r1][l2 - 1] -= val;
		g[l1 - 1][l2 - 1] += val;
	};

	std::cin >> m;
	for (int i = 1; i <= m; i++) {
		int u, v, w; std::cin >> u >> v >> w;
		if (u == v) continue;
		if (u > v) std::swap(u, v);
		add(u, u, v, v, w);
	}

	for (int j = n; j >= 1; j--) {
		for (int i = n; i >= 1; i--) {
			g[i][j] += g[i + 1][j] + g[i][j + 1] - g[i + 1][j + 1]; 

			// k\in [l, r], i
			// k <= i, g[k][i] += g[i][j] * inv[r[j] - l[j] + 1];
			// k > i,  g[i][k] += g[i][j] * inv[r[j] - l[j] + 1];

			if (i < j) {
				if (i >= l[j]) add(l[j], std::min(r[j], i), i, i, g[i][j] * inv[r[j] - l[j] + 1]);
				if (i <= r[j]) add(i, i, std::max(l[j], i), r[j], g[i][j] * inv[r[j] - l[j] + 1]);					
			}
		}
	}

	for (int i = 1; i <= n; i++) for (int j = i + 1; j <= n; j++) ans[j] += g[i][j];
	for (int i = 2; i <= n; i++) std::cout << ans[i] << " ";

	return 0;
}
```

---

## 作者：Otomachi_Una_ (赞：9)

## Subtask 1

我会爆搜！

时间复杂度：$\mathcal O(n!·m)$。

期望得分：$20$。

## Subtask 2,3

对每个操作分别计算贡献。

注意到一个操作 $(u,v,w)$ 对一条边 $(x,f_x)$ 有贡献当且仅当 $x$ 恰为 $u,v$ 的祖先之一。如果用 $P(u,x)$ 表示 $x$ 是否为 $u$ 的祖先，那么这个操作对这条边的贡献可以写成：$(P(u,x)+P(v,x)-2P(u,x)·P(v,x))·w$。

我们可以把式子拆开，首先考虑计算 $P(u,x)=1$ 的概率：假设 $f_{i,j}$ 表示 $i$ 是 $j$ 的祖先的概率，那么初始情况是 $f_{i,i}=1$，考虑 $f_{i,j}$ 当中 $j$ 的父亲在 $[l_j,r_j]$ 随机，于是就有：
$$
f_{i,j}=\dfrac{\sum_{k=l_j}^{r_j}f_{i,k}}{r_j-l_j+1}
$$
这里可以利用前缀和优化快速算出。

利用 $f$ 我们就能算出前面 $(P(u,x)+P(v,x))·w$ 造成的贡献，考虑计算后面的 $P(u,x)·P(v,x)·w$ 的贡献：

定义 $g_{p,u,v}$ 表示 $p$ 同时是 $u,v$ 祖先的概率，像 $f$ 转移一样，每次把 $u,v$ 当中较大者跳到父亲，利用前缀和优化就能 $\mathcal O(n^3)$ 求出 $g$ 了。

时间复杂度：$\mathcal O(n^3+nm)$。

期望得分：$60$ 分。

## Subtask 4

考虑 $m=1$ 的做法。

考虑如何绕开求 $g_{p,u,v}$。首先 $g_{p,u,v}\neq f_{p,u}·f_{p,v}$，这是因为后式在计算的时候，对 $p\sim \operatorname{lca}(u,v)$ 的点选取 $f$ 的时候进行了两次独立选取。

考虑容斥，假设 $g_x$ 表示 $x=\operatorname{lca}(u,v)$ 的概率，初始我们假定 $g_x=f_{x,u}·f_{x,v}$。不难发现 $g_n$ 的结果已经是正确的，依次枚举 $i=n,n-1,\dots,1$，考虑当 $i=\operatorname{lca}(u,v)$ 的时候，对每个 $j<i$，每个 $g_j$ 应当减掉 $g_i·f_{j,i}^2$。这样子我们就能算出 $g_x$，有了 $g_*$，那么就有 $P(u,x)·P(v,x)=\sum g_i·f_{x,i}$。

时间复杂度：$\mathcal O(mn^2)$。

期望得分：$80$ 分。

## Subtask 5

瓶颈在算每个操作对应的 $g$。但是实际上我们只需要求每个 $g$ 的和，我们可以把上面每个操作初始的 $g$ 相加，然后只需要容斥依次就能直到所有最终的 $g$ 的和了。

时间复杂度：$\mathcal O((n+m)n)$。

期望得分：$100$ 分。

## 另解

仿照计算 $g$ 的方式，每次往上跳较大值也能完成本题。时间复杂度：$\mathcal O(n^2+m)$。

期望得分：$100$ 分。

---

## 作者：sgl654321 (赞：6)

## 前言
> 依次枚举 $i = n, n-1,\cdots,1$，考虑当 $i = \text{lca}(u,v)$ 时，对于每个 $j < i$，每个 $g_j$ 应当减掉 $g_i\times f_{j,i}^{2}$。

上文摘自官方题解，这里应该是最核心的部分，却只是一笔带过，给我造成不小的理解困扰。

因此我这里不使用这种方法，而是用官方题解中的“另解”的思路，展开这篇题解。
## 题目大意
给定一个树，根为 $1$，$i$ 的父亲在 $l_i\sim r_i$ 中等概率选取。接下来有 $m$ 次操作，每次把 $x,y$ 的路径上的所有边的边权加上 $z$。

问所有操作结束后，边 $(i,fa_i)$ 的权值期望是多少。

## 解题思路

### 如何寻找最近公共祖先？
首先我们考虑一次路径加操作，会使哪些 $(i,fa_i)$ 边受到影响。假设我们已经确定了树的形态，那么显然是路径上除了 $\text{lca}(x,y)$ 的点对应的边受到影响。

这里出现了 $\text{lca}(x,y)$，启示我们要考虑如何找两个点的最近公共祖先。

可以发现，我们找最近公共祖先不仅可以像常规方法那样，每次跳深度较深的那一个点。在这题中，还可以每次跳编号较大的那个点，直至两个点编号大小相等。因为本题中的树有一个关键性质：父亲的编号严格小于儿子。

那么在寻找最近公共祖先的过程中，你每次就可以把较大编号的那个点所对应的边权加上 $z$，同时把他变成他的父亲。

### $m = 1$ 的情况
这时我们只有一次操作 $(x,y,z)$。我们先交换使得 $x\le y$。考虑 dp，我们设 $f_{i,j}(i\le j)$ 表示从 $(x,y)$ 开始向上跳，跳到 $(i,j)$ 这个状态的概率，注意这里要满足 $i\le j$。

初始状态肯定是 $f_{x,y} = 1$，最后答案统计，我们有 $ans_i = z\times \sum_{j = 1}^{i - 1} f_{j,i}$。因为每次都是把编号较大的那个点对应的边权加上 $z$ 吗。

接下来考虑转移。$(x,y)(x\le y)$ 可以通过一次跳跃，把 $y$ 变成 $l_y \sim r_y$ 中的一个。因此对于任意的 $k\in[l_y,r_y]$，$f_{\min(k, x), \max(k,x)}$ 要自增 $\dfrac{f_{x,y}}{r_y - l_y + 1}$。

至此我们就有一个 $O(n^3)$ 的算法了。

那么我们考虑如何优化成平方级别。首先你可以每次就把 $f_{x,k}$ 加上 $\dfrac{f_{x,y}}{r_y - l_y + 1}$ 这个值。你可能会说 $x>k$ 怎么办呢？其实没有关系，等我们处理到 $f_{k,x}$ 的转移时，我们把 $f_{k,x}$ 加上 $f_{x,k}$ 就行了。

那么我们 $k$ 的操作是一个区间，相当于区间加上一个数。然后单点查询。因为这是一个静态问题，$k$ 保证大于 $y$ 了。我们可以使用差分的方法解决。

具体的，我们每次操作把 $r_y$ 这里的差分数组值加上 $\dfrac{f_{x,y}}{r_y - l_y + 1}$，把 $l_y - 1$ 这里的差分数组值减去 $\dfrac{f_{x,y}}{r_y - l_y + 1}$。然后每次累加差分数组的值就行了。

那么我们就做到单次操作 $O(n^2)$ 的复杂度了。

### $m > 1$ 的情况
还是从 $m = 1$ 的情况开始思考。首先，你可以修改一下 $f$ 数组的状态定义。你就直接把 $f_{x,y}$ 的初值设成 $z$ 而非 $1$。这样你就不需要统计答案的时候每一个都乘以 $z$ 了。

如果 $m > 1$ 呢？其实很简单，你直接把每一个 $(x_i,y_i,z_i)$ 都做一遍 $f_{x_i,y_i}$ 自增 $z_i$，然后同样的 dp。这里其实是利用了期望的线性性质，每一次操作互相独立。

因此总时间复杂度就是 $O(n^2 + m)$。

## 参考代码
注意点：先预处理出逆元数组，而不是每次再重新费马小定理快速幂算出逆元。$5000^2$ 对于我这种大常选手来说已经比较紧张了，再加上一个逆元的 $\log$，就救不活了。这也是我前面为什么不用树状数组无脑做，而是用差分的原因。

```cpp
#include<bits/stdc++.h>
#define maxn 5010
using namespace std;
typedef long long ll;
const ll mod = 998244353;

ll n, l[maxn], r[maxn], m, x, y, z, f[maxn][maxn], d[maxn], ans[maxn], s, inv[maxn]; 
ll qpow(ll x, ll y){
	ll ret = 1;
	while(y){
		if(y & 1) ret = ret * x % mod;
		x = x * x % mod;
		y >>= 1;
	}
	return ret;
}
int main(){
	cin >> n;
	for(int i = 2; i <= n; i++) cin >> l[i] >> r[i];
	cin >> m;
	while(m--){
		cin >> x >> y >> z;
		if(x > y) swap(x, y);
		f[x][y] += z; f[x][y] %= mod;
	}
	for(int i = 1; i <= n; i++)  inv[i] = qpow(i, mod - 2);
	
	for(int i = n; i >= 1; i--){
		for(int j = 1; j <= n; j++) d[j] = 0; s = 0;
		for(int j = n; j >= i + 1; j--){
			f[i][j] = (f[i][j] + f[j][i]) % mod; 
			s += d[j]; s %= mod; f[i][j] = (f[i][j] + s) % mod;
			d[r[j]] += inv[r[j] - l[j] + 1] * f[i][j] % mod, d[r[j]] %= mod;
			d[l[j] - 1] -= inv[r[j] - l[j] + 1] * f[i][j] % mod, d[l[j] - 1] = (d[l[j] - 1] % mod + mod) % mod;
		}
		for(int j = i; j >= 1; j--){
			s += d[j]; s %= mod;
			f[i][j] = (f[i][j] + s) % mod;
		}
	}
	
	for(int i = 2; i <= n; i++)
		for(int j = 1; j < i; j++) ans[i] = (ans[i] + f[j][i]) % mod;
	for(int i = 2; i <= n; i++) cout << ans[i] << ' ';
	cout << endl;
			
	
	return 0;
}

```

---

## 作者：DaiRuiChen007 (赞：5)

[Problem Link](https://www.luogu.com.cn/problem/P10879)

**题目大意**

> 给定 $n$ 个点的树，其中第 $i$ 个点的父亲在 $[l_i,r_i]$ 中均匀随机，$m$ 次操作给 $u\to v$ 路径边权 $+w$，求出每条 $u\to fa(u)$ 的边的期望边权。
>
> 数据范围：$n,m\le 5000$。

**思路分析**

考虑如何刻画路径边权，考虑一个类似朴素 LCA 的过程，如果 $u>v$，那么 $u\to fa(u)$ 的边一定被覆盖。

那么可以设计一个简单 dp，$f_{i,j}$ 表示从 $(u,v)$ 开始跳到 $(i,j)$ 的概率。

转移就是 $\dfrac{f_{u,v}}{r_u-l_u+1}\to f_{l_u\sim r_u,v}$，但是要时刻保证 $u>v$，因此可以看成 $f$ 上的两个区间加，差分维护。

算答案就是把每个 $w\times f_{i,j}$  加进 $i$ 的答案，对每条路径 dp 复杂度 $\mathcal O(n^2m)$。

对每个 $(u,v)$ 都 dp 一遍复杂度不能接受，但我们可以合并起点，即把每条路径看成令初始的 $f_{u,v}$ 加 $w$，一遍 dp 即可算出答案。

时间复杂度 $\mathcal O(n^2+m)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=5005,MOD=998244353;
int n,m,l[MAXN],r[MAXN],f[MAXN][MAXN],inv[MAXN],g[MAXN];
int a[MAXN][MAXN],b[MAXN][MAXN];
void add(int &x,int y) { x=(x+y>=MOD)?x+y-MOD:x+y; }
void sub(int &x,int y) { x=(x>=y)?x-y:x+MOD-y; }
signed main() {
	scanf("%d",&n),inv[1]=1;
	for(int i=2;i<=n;++i) scanf("%d%d",&l[i],&r[i]),inv[i]=1ll*(MOD-MOD/i)*inv[MOD%i]%MOD;
	scanf("%d",&m);
	for(int i=1,u,v,w;i<=m;++i) {
		scanf("%d%d%d",&u,&v,&w);
		add(f[max(u,v)][min(u,v)],w%MOD);
	}
	for(int j=n;j>=1;--j) {
		for(int i=n;i>j;--i) {
			add(a[i][j],a[i+1][j]),add(f[i][j],a[i][j]);
			add(b[i][j],b[i][j+1]),add(f[i][j],b[i][j]);
			add(g[i],f[i][j]);
			int z=1ll*f[i][j]*inv[r[i]-l[i]+1]%MOD;
			if(j<l[i]) add(a[r[i]][j],z),sub(a[l[i]-1][j],z);
			else if(r[i]<j) add(b[j][r[i]],z),sub(b[j][l[i]-1],z);
			else {
				add(a[r[i]][j],z),sub(a[j][j],z);
				add(b[j][j-1],z),sub(b[j][l[i]-1],z);
			}
		}
	}
	for(int i=2;i<=n;++i) printf("%d ",g[i]); puts("");
	return 0;
}
```

---

## 作者：Re_Star (赞：4)

[题面](https://www.luogu.com.cn/problem/P10879)

[更好的阅读体验](https://www.cnblogs.com/Re-Star/p/18829088)

一道很好的 DP 题，看了题解才会的。首先我们考虑对于一颗固定的树有什么比较有前途的做法，注意到这道题的树每个点都满足 $fa_i<i$，所以我们令 $u>v$，那么 $u$，$v$ 之间的路径必定经过了 $u$ 到 $fa_u$ 的边。我们就可以将这条边的边权加上 $w$，然后将 $u$ 跳到其父亲的位置上，重复下去。这种方法的好处是我们不需要对比两个点的深度，只需要比较编号大小，所以树的具体形态也就不重要了。

上面的方法很容易拓展一下得到这道题的DP做法，对于每一对 $(u,v)$，我们设 $f_{i,j}$ 表示 $(u,v)$ 跳到状态 $(i,j)$ 的概率。转移也很简单，我们只需要枚举 $i$ 可能的父亲，将 $\frac{f_{i,j}}{r_i-l_i+1}$ 加到 $f_{fa_i,j}$ 就可以了，这个转移是 $O(n^3)$ 的，但是我们发现每次转移都可以看做是 $f$ 数组连续一段上加一个相同的数，差分一下就可以做到 $O(n^2)$。但是我们需要对每组询问 DP ，总复杂度依然达到了 $O(n^2m)$。

但是我们可以发现每组询问的转移之间是独立的，所以我们在一开始在 $f_{u,v}$ 上加上 $w$，然后直接倒序枚举进行转移就可以了，复杂度为 $O(n^2+m)$。

code：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=5e3+10,mod=998244353;
ll f[N][12][12],S,T,inv[12],ans,k;
char s[N],t[12];
ll qp(ll x,ll y)
{
	ll res=1;
	while(y)
	{
		if(y&1) (res*=x)%=mod;
		(x*=x)%=mod,y>>=1;
	}
	return res;
} 
ll C(ll x)
{
	ll res=1;
	for(int i=0;i<x;i++) (res*=(k-i)%mod)%=mod;
	return res*inv[x]%mod;
}
void dfs(int l,int pos,ll res)
{
	if(l>T) return (ans+=res*C(pos))%=mod,void();
	for(int r=l;r<=T;r++) dfs(r+1,pos+1,res*f[S][l][r]%mod);
}
int main()
{
	cin>>k;inv[1]=1;
	for(int i=2;i<=10;i++) inv[i]=inv[i-1]*qp(i,mod-2)%mod;
	scanf("%s%s",s+1,t+1);
	S=strlen(s+1),T=strlen(t+1); 
	for(int i=1;i<=S;i++)
		for(int l=1;l<=T;l++)
			for(int r=l;r<=T;r++)
			{
				f[i][l][r]=f[i-1][l][r];
				if(s[i]==t[r]) (f[i][l][r]+=(l==r?1:f[i-1][l][r-1]))%=mod;
			}
	dfs(1,0,1);
	cout<<ans;
	return 0;
} 
```

---

## 作者：wxzzzz (赞：4)

这题需要用一个神奇的 trick，暂且将其称为树上期望差分。

### 思路

树上差分，设 $d_i$ 为 $(i,fa_i)$ 的差分权值的期望，假设现在已经得到所有 $d_i$，考虑求出答案。

答案由 $d_i$ 进行一系列转移得到，该转移为：

$$d_i=\sum_{j=i+1}^n d_j\times\frac{1}{r_j-l_j+1}[l_j\le i\le r_j]$$

即枚举 $i$ 的子节点 $j$，按公式计算期望。

现在考虑如何求得 $d_i$。

对于一次询问 $(u,v,w)$，假设 $k=\operatorname{LCA}(u,v)$，需要做的便是更新 $d_u\gets d_u+w,d_v\gets d_v+w,d_k\gets d_k-2w$。而对于随机的树，$d_k$ 加的权值需要乘上 $k=\operatorname{LCA}(u,v)$ 的概率。

令 $g_k$ 为 $k=\operatorname{LCA}(u,v)$ 的概率。

首先设 $f_{i,j}$ 为 $i$ 是 $j$ 祖先的概率，$k$ 是 $u,v$ 共同祖先的概率为 $f_{k,u}\times f_{k,v}$

然后需要容斥掉那些以 $k$ 为祖先的节点作为 LCA 的概率。

$$g_k=f_{k,u}\times f_{k,v}-\sum_{i=k+1}^n {f_{k,i}}^2\times g_i$$

上式中 $f_{k,i}$ 要平方，因为减去的概率中需要包含路径 $k\to u,k\to v$ 均经过 $k$ 的概率，即 $f_{k,i}\times f_{i,u}\times f_{k,i}\times f_{i,v}$，而 $g_i$ 中恰好包含了 $f_{i,u}\times f_{i,v}$，故剩下一个 ${f_{k,i}}^2$ 需要计算。

更新 $d_u\gets d_u+w,d_v\gets d_v+w,\forall k\in[1,n]:d_k\gets d_k-2w\times g_k$ 即可。

复杂度为 $O(n^2m)$ 考虑优化。

发现 $g$ 的容斥式是相同的，只是每次初始值不同，故将 $g$ 每次的容斥初始值乘上 $2w$ 并加起来，最终统一做一遍容斥。

因为所有 $g_k$ 乘上的数相同，故不影响转移正确性。

最后还剩下一个 $f_{i,j}$ 要计算，考虑枚举 $k$ 为 $j$ 的父节点，从上往下更新：

$$f_{i,j}=\frac{\sum_{k=l_j}^{r_j}f_{i,k}}{r_j-l_j+1}$$

前缀和优化即可。

### 代码

```cpp
#include <bits/stdc++.h>
#define MOD 998244353
using namespace std;
long long mod(long long x) {
    return x % MOD;
}
pair<long long, long long> exgcd(long long a, long long b) {
    if (!b)
        return {1, 0};

    pair<long long, long long> t = exgcd(b, a % b);

    long long x = t.first, y = t.second;

    return {y, mod(mod(x - a / b * y) + MOD)};
}
int n, m, fl[5005], fr[5005];
long long s[5005], g[5005], tmp[5005], ans[5005], f[5005][5005];
int main() {
    cin >> n;

    for (int i = 1; i <= n; i++)
        f[i][i] = 1;

    for (int i = 2; i <= n; i++) {
        cin >> fl[i] >> fr[i];
        tmp[i] = exgcd(fr[i] - fl[i] + 1, MOD).first;

        for (int j = fl[i]; j <= fr[i]; j++)
            f[j][i] = tmp[i];
    }

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++)
            s[j] = 0;

        s[i] = 1;

        for (int j = i + 1; j <= n; j++) {
            f[i][j] = mod((s[fr[j]] - s[fl[j] - 1]) * tmp[j]);
            s[j] = mod(s[j - 1] + f[i][j]);
        }
    }

    cin >> m;

    while (m--) {
        int x, y;
        long long w;
        cin >> x >> y >> w;
        ans[x] = mod(ans[x] + w);
        ans[y] = mod(ans[y] + w);

        for (int i = n; i >= 1; i--)
            g[i] = mod(g[i] + mod(f[i][x] * f[i][y]) * 2 * w);
    }

    for (int i = n; i >= 1; i--)
        for (int j = i + 1; j <= n; j++)
            g[i] = mod(mod(g[i] - mod(f[i][j] * f[i][j]) * g[j]) + MOD);

    for (int i = 1; i <= n; i++)
        ans[i] = mod(ans[i] - g[i] + MOD);

    for (int i = n; i >= 1; i--)
        for (int j = i + 1; j <= n; j++)
            if (i >= fl[j] && i <= fr[j])
                ans[i] = mod(ans[i] + ans[j] * tmp[j]);

    for (int i = 2; i <= n; i++)
        cout << ans[i] << ' ';

    return 0;
}
```

---

## 作者：XuYueming (赞：3)

## 前言

题目链接：[洛谷](https://www.luogu.com.cn/problem/P10879)。

[更好？的体验](https://www.cnblogs.com/XuYueming/p/18365079)。

## 题意简述

给出一棵 $n$ 个节点以 $1$ 为根的有根树。对于第 $2\leq i\leq n$ 个节点，其父亲 $f_i$ 在 $[l_i,r_i]$ 中均匀随机。每个树的边有边权，初始为 $0$。

现在有 $m$ 次操作，第 $i$ 次操作表示将 $(u_i,v_i)$ 的路径上所有的边的权值统一加上 $w_i$。$m$ 次操作结束后，对于所有 $i=2\sim n$，求 $(i,f_i)$ 边上权值的期望，对 $998244353$ 取模。

$1\leq l_i\leq r_i<i$，$n \leq 5 \times 10^3$，$m \leq 10^5$。（原题 $m \leq 5 \times 10^3$。）

## 题目分析

这道题树的形态十分鬼畜，平常树上那一套都不管用了，于是变得无从下手。似乎能下手的只有随机等概率跳父亲这一操作。

修改之间独立，考虑某一次修改 $(u_i, v_i, w_i)$，我们要对 $u_i \sim v_i$ 上，除了 $\operatorname{lca}(u_i, v_i)$ 处的答案都加上 $w_i$ 与这种树的形态的概率之积，即期望。联想到跳 $\operatorname{lca}$ 的过程，在 $u = v$ 之前，每次选取深度较深的结点，往上等概率地跳一次父亲。

对于本题，深度不确定，但是我们只用保证不会跳过 $\operatorname{lca}$ 即可。什么情况下会跳过呢？就是 $u$ 跳到了可能成为 $\operatorname{lca}$ 的点，下一步不能让它往上跳。显然，可能成为 $\operatorname{lca}$ 的点是 $u$ 和 $v$ 当中较小的一个。

即，假设 $u < v$，$ans_v \gets ans_v + w$，$v \gets f_v \in [l_v, r_v]$，$w \gets \cfrac{w}{r_v - l_v + 1}$。

发现，一对 $(u, v)$ 会被多次访问，与其多次重复操作，不妨先将其记下来，然后一起往上更新。数据范围允许我们设 $f_{u, v}$ 表示当前已经跳到了 $(u, v)$，对 $u \sim v$ 这条树链修改的期望。类比上面的转移，有：

$$
\forall k \in [l_v, r_v], f_{u, k} \gets f_{u, k} + \cfrac{f_{u, v}}{r_v - l_v + 1}
$$

初始 $f_{u_i, v_i} = w_i$。我们要保证转移时刻有意义，即保证 $u < v$。上式若出现 $k = u$ 的状态应舍弃；若出现 $k < u$，要把 $f_{u, k}$ 变成 $f_{k, u}$。由于修改独立，我们在 $m$ 次操作后一起转移。

至此，时间复杂度是 $\Theta(n^3 + m)$，考虑优化。

发现加上的数都是相同的，设 $C = \cfrac{f_{u, v}}{r_v - l_v + 1}$，对于 $k < u$ 的情况和 $k > u$ 的情况分别拎出来观察：

$$
\forall k \in [l_v, \min \lbrace r_v, u - 1 \rbrace], f_{k, u} \gets f_{k, u} + C
$$

$$
\forall k \in [\max \lbrace l_v, u + 1 \rbrace, r_v], f_{u, k} \gets f_{u, k} + C
$$

很明显的区间加操作，使用二维前缀和维护即可。

时间复杂度：$\Theta(n ^ 2 + m)$。

## 代码

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
using namespace std;

const int N = 5020;
const int mod = 998244353;

inline int add(int a, int b) {
    return a + b >= mod ? a + b - mod : a + b;
}

inline int sub(int a, int b) {
    return a - b < 0 ? a - b + mod : a - b;
}

inline int mul(int a, int b) {
    return 1ll * a * b % mod;
}

int Inv[N];

int n, m, L[N], R[N];
int f[N][N];
int ans[N];

inline void add(int x1, int y1, int x2, int y2, int v) {
    if (x1 > x2 || y1 > y2) return;
    f[x2][y2] = add(f[x2][y2], v);
    f[x1 - 1][y1 - 1] = add(f[x1 - 1][y1 - 1], v);
    f[x1 - 1][y2] = sub(f[x1 - 1][y2], v);
    f[x2][y1 - 1] = sub(f[x2][y1 - 1], v);
}

signed main() {
    scanf("%d", &n);
    Inv[1] = 1;
    for (int i = 2; i <= n; ++i)
        Inv[i] = mul(mod - mod / i, Inv[mod % i]);
    for (int i = 2; i <= n; ++i)
        scanf("%d%d", &L[i], &R[i]);
    scanf("%d", &m);
    for (int _ = 1, u, v, w; _ <= m; ++_) {
        scanf("%d%d%d", &u, &v, &w);
        if (u == v) continue;
        if (u > v) swap(u, v);
        add(u, v, u, v, w);
    }
    for (int u = n; u >= 1; --u) {
        for (int v = n; v >= u; --v) {
            f[u][v] = add(f[u][v], f[u + 1][v]);
            f[u][v] = add(f[u][v], f[u][v + 1]);
            f[u][v] = sub(f[u][v], f[u + 1][v + 1]);
            if (v > u) {
                int val = mul(Inv[R[v] - L[v] + 1], f[u][v]);
                add(u, max(u + 1, L[v]), u, R[v], val);
                add(L[v], u, min(u - 1, R[v]), u, val);
                ans[v] = add(ans[v], f[u][v]);
            }
            // for (int o = max(u + 1, L[v]); o <= R[v]; ++o) {
            //     f[u][o] = add(f[u][o], mul(Inv[R[v] - L[v] + 1], f[u][v]));
            // }
            // for (int o = L[v]; o <= min(u - 1, R[v]); ++o) {
            //     f[o][u] = add(f[o][u], mul(Inv[R[v] - L[v] + 1], f[u][v]));
            // }
        }
    }
    for (int i = 2; i <= n; ++i)
        printf("%d ", ans[i]);
    return 0;
}
```

## 后记 & 反思

遇到期望 / 概率的题目，要往 DP 的方向思考，而不是像无头苍蝇一样只会写一个爆搜。

遇到宏观情况很鬼畜的问题，往往微观上一次操作是可控的，那么着眼于微观，每次迈出一小步即可。

---

## 作者：Disjoint_cat (赞：3)

# [P10879 「KDOI-07」对树链剖分的爱](https://www.luogu.com.cn/problem/P10879)

难得一见的小清新 OU 题。~~OU 这么喜欢树剖？~~

首先因为树的结构是不确定的，所以那些树上算法基本上全都废了。只能考虑另辟蹊径。

现在几乎唯一能处理的操作就是跳父亲；所以考虑挖掘祖孙的关系。

考虑一个操作 $(x,y,z)$ 什么时候会对一条边 $(i,f_i)$ 的权值产生贡献。简单画图可以得出，产生贡献当且仅当 $i$ 至少是 $x,y$ 之一的祖先，但不能是 $\operatorname{lca}(x,y)$ 的祖先。

这样就舒服多了。此时，这个贡献可以容斥成，$i$ 是 $x$ 的祖先时的贡献加上 $i$ 是 $y$ 的祖先时的贡献，在减去两倍的 $i$ 是 $\operatorname{lca}(x,y)$ 的祖先的贡献。

首先考虑如何求 $i$ 是 $x$ 的祖先时的贡献。此时我们可以 dp，令 $dp_{c}$ 表示结点 $c$ 是 $x$ 的祖先的概率。那么显然有以下转移：

$$dp_{x}=1$$

$$dp_{p}\gets\frac{dp_{c}}{r_c-l_c+1}\;(l_c\le p\le r_c)$$

$y$ 的祖先的情况是类似的，设它的 dp 数组为 $fp$。

然后就是 $i$ 是 $\operatorname{lca}(x,y)$ 的祖先的情况了。有的人可能会说：我知道！这样就等价于 $i$ 既是 $x$ 的祖先，又是 $y$ 的祖先，那么概率就是 $dp_i\cdot fp_i$！

很可惜，这样其实是错误的。因为「$i$ 是 $x$ 的祖先」和「$i$ 是 $y$ 的祖先」这两件事情不是独立的。比如 $x=y$ 的情况就是反例之一。

所以就必须 $x$ 和 $y$ 一起考虑。

考虑模拟找 $\operatorname{lca}$ 的过程（当然也只能是最暴力的跳父亲）。令 $gp_{c,d}$ 表示寻找 $\operatorname{lca}(x,y)$ 的过程中，两点分别已经跳到 $c,d$ 的概率。

此时需要指定一种（唯一的）跳父亲的方式。因为 $f_i<i$，所以每次跳编号大的那个就能保证结果正确。转移和上面差不多。

那么当 $c=d$ 时就表示 $\operatorname{lca}(x,y)=c$ 的概率是 $gp_{c,d}$。再设 $lp_e$ 为 $e$ 是 $\operatorname{lca}(x,y)$ 的祖先的概率，那么除了初值为 $lp_e=gp_{e,e}$ 外，转移也没有任何区别。于是我们就求出了所需的概率。

此时对于每次操作，都有一个状态数为 $\Theta(n^2)$ 的 dp，转移时运用前缀和优化可以做到 $\Theta(1)$，总复杂度为 $\Theta(n^2m)$，可以得到 $80$ 分。

考虑优化。现在对于每次操作都要 dp 一次，这很不优美。可以发现每次 dp 的转移都是一模一样且独立的，完全可以一起 dp。由于每次操作贡献都要乘一个 $z$，直接把 $z$ 乘到初值里就行了。

（甚至你的 $dp,fp,lp$ 都是一样的，也可以扔一个数组里。）

现在只需要 dp 一次了，时间复杂度为 $\Theta(n^2+m)$。所以为啥 $m$ 只开到 $5000$？

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define endl '\n'
#define PB emplace_back
#define PPB pop_back
#define MP make_pair
#define ALL(Name) Name.begin(),Name.end()
#define PII pair<int,int>
#define VI vector<int>
#define GI greater<int>
#define fi first
#define se second

const int N=5005,MOD=998244353;
int n,m,l[N],r[N],ans[N],inv[N];
int dp[N],gp[N][N];
void add(int &x,int y){if((x+=y)>=MOD)x-=MOD;}

int main()
{
	ios::sync_with_stdio(false),cin.tie(nullptr);
//	int _;cin>>_;while(_--)

	cin>>n;
	for(int i=2;i<=n;i++)cin>>l[i]>>r[i];
	inv[1]=1;
	for(int i=2;i<=n;i++)inv[i]=1ll*(MOD-MOD/i)*inv[MOD%i]%MOD;
	cin>>m;
	while(m--)
	{
		int x,y,z;
		cin>>x>>y>>z;
		add(dp[x],z%MOD),add(dp[y],z%MOD),add(dp[x-1],(2*MOD-z)%MOD),add(dp[y-1],(2*MOD-z)%MOD);
		add(gp[x][y],z%MOD),add(gp[x][y-1],(2*MOD-z)%MOD);
	}
	for(int i=n,d=0,g;i>1;i--)
	{
		g=0;
		for(int j=n;j>1;j--)
		{
			add(g,gp[i][j]);
			if(i!=j)
			{
				int s=i,t=j;if(s>t)swap(s,t);
				int p=1ll*inv[r[t]-l[t]+1]*g%MOD;
				add(gp[s][r[t]],p);
				add(gp[s][l[t]-1],MOD-p);
			}
			else add(dp[i],MOD-g),add(dp[i],MOD-g),add(dp[i-1],g),add(dp[i-1],g);
		}
		add(d,dp[i]);
		ans[i]=d;
		dp[r[i]]=(dp[r[i]]+1ll*inv[r[i]-l[i]+1]*d)%MOD,
		add(dp[l[i]-1]=(dp[l[i]-1]-1ll*inv[r[i]-l[i]+1]*d)%MOD,MOD);
	}
	for(int i=2;i<=n;i++)cout<<ans[i]<<" ";

	return 0;
}

```

---

## 作者：operator_ (赞：3)

# P10879 「KDOI-07」对树链剖分的爱

[题目传送门](https://www.luogu.com.cn/problem/P10879)

## 题解

如果看到了 $1\le l_i\le r_i<i$ 应该是挺好做的（~~但是我怎么看不懂官方题解啊啊啊~~）。

因为每个点只会向前面连边，所以一个简单的想法就是从后往前考虑。我们在扫的过程中动态维护一下 $a_{i,j}$ 表示当前状态下 $i$ 到 $j$ 路径上期望加多少。具体来讲，我们每次找到当前点 $u$ 对应的所有路径 $(u,v)$，显然 $v$ 应当小于 $u$。然后对于所有 $(v,k)$，$l_u\le k\le r_u$，我们都要使 $a_{v,k}$ 加上 $\dfrac{a_{u,v}}{r_u-l_u+1}$（有等概率转移到任何一个状态），至此已经做到了 $O(n^3)$。

想要优化到 $O(n^2)$ 你只需要在扫的同时进行二维差分即可（两个一维差分也是可以等价替代的）。
 
代码（赛时我为了让自己想的更清楚，我代码里钦定只记录 $u\le v$ 的 $a_{u,v}$，导致有点繁琐）：

```cpp
//Date: 2024-08-15 13:12:20
#include<bits/stdc++.h>
using namespace std;
#define int long long
inline int rd() {
    int s=0,m=0;char ch=getchar();
    while(!isdigit(ch)) {if(ch=='-')m=1;ch=getchar();}
    while( isdigit(ch)) s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
    return m?-s:s;
}
bool MBE;
namespace SOLVER {
const int M=998244353;
int qpow(int x,int y=M-2,int mod=M) {int s=1;for(;y;y>>=1,x=x*x%mod) if(y&1) s=s*x%mod;return s;}
int n,m,inv[5005],l[5005],r[5005],a[5005][5005],ans[5005];
void MAIN() {
    inv[1]=1;for(int i=2;i<=5000;i++) inv[i]=(M-M/i*inv[M%i]%M)%M;
    cin>>n;for(int i=2;i<=n;i++) l[i]=rd(),r[i]=rd();
    cin>>m;
    for(int i=1,u,v,w;i<=m;i++) {
        u=rd(),v=rd(),w=rd();
        if(u>v) swap(u,v);
        a[u][v]+=w,a[u-1][v]-=w,a[u][v-1]-=w,a[u-1][v-1]+=w;
    }
    for(int i=n;i>=2;i--) {
        for(int j=n;j>=1;j--) a[j][i]+=a[j+1][i]+a[j][i+1]-a[j+1][i+1]+M,a[j][i]%=M;
        for(int j=1;j<i;j++) {
            ans[i]+=a[j][i],ans[i]%=M;int ww=a[j][i]*inv[r[i]-l[i]+1]%M;
            if(l[i]<=j) {
                int R=min(j,r[i]);
                a[R][j]=(a[R][j]+ww)%M,a[R][j-1]=(a[R][j-1]-ww+M)%M;
                a[l[i]-1][j]=(a[l[i]-1][j]-ww+M)%M,a[l[i]-1][j-1]=(a[l[i]-1][j-1]+ww)%M;
            }
            if(r[i]>j) {
                int L=max(j+1,l[i]);
                a[j][r[i]]=(a[j][r[i]]+ww)%M,a[j-1][r[i]]=(a[j-1][r[i]]-ww+M)%M;
                a[j][L-1]=(a[j][L-1]-ww+M)%M,a[j-1][L-1]=(a[j-1][L-1]+ww)%M;
            }
        }
    }
    for(int i=2;i<=n;i++) cout<<ans[i]<<' ';
}
}
bool MED;
signed main() {
    //freopen(".in","r",stdin);freopen(".out","w",stdout);
    for(int tt=1;tt;tt--) SOLVER::MAIN();
    cerr<<(&MBE-&MED)/1024<<" B, "<<1000*clock()/CLOCKS_PER_SEC<<" ms\n";
    return 0;
}
```

---

## 作者：Petit_Souris (赞：2)

如何刻画一条路径？对于一条路径 $u\to v$，我们不妨效仿暴力 LCA，每次让编号较大的那个点向上跳。

用 dp 来记录这个过程。设 $f_{u,v}(u>v)$ 表示从初始路径跳到 $u\to v$ 这条路径的概率，那么转移就是 $f_{u,v}\cdot \frac{1}{r_u-l_u+1} \to f_{p,v}(p\in [l_u,r_u])$。注意转移到的 $(p,v)$ 如果满足 $p<v$ 需要交换一下 $p,v$。

这样就可以做到 $\mathcal O(n^3m)$ 了。发现可以用前缀和优化，这样就是 $\mathcal O(n^2m)$ 了。

实际上由于期望的线性性，我们根本没必要把 $m$ 条路径分别 dp，直接把对应的 $w$ 记在 $dp_{u,v}$ 上，做一遍转移就行了。时间复杂度 $\mathcal O(n^2+m)$。我认为这是好题，出题人很牛。

```cpp
#include<bits/stdc++.h>
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
#define pii pair<ll,ll>
#define rep(i,a,b) for(ll i=(a);i<=(b);++i)
#define per(i,a,b) for(ll i=(a);i>=(b);--i)
using namespace std;
bool Mbe;
ll read(){
    ll x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
void write(ll x){
    if(x<0)putchar('-'),x=-x;
    if(x>9)write(x/10);
    putchar(x%10+'0');
}
const ll N=5009,Mod=998244353;
ll pw(ll x,ll p){
    ll res=1;
    while(p){
        if(p&1)res=res*x%Mod;
        x=x*x%Mod,p>>=1;
    }
    return res;
}
ll n,m,L[N],R[N],dp[N][N],row[N][N],col[N][N],ans[N];
ll fac[N],ifac[N],inv[N];
bool Med;
int main(){
    cerr<<fabs(&Med-&Mbe)/1048576.0<<"MB\n";
    n=read();
    rep(i,2,n)L[i]=read(),R[i]=read();
    m=read();
    while(m--){
        ll x=read(),y=read(),w=read();
        if(x==y)continue;
        if(x<y)swap(x,y);
        dp[x][y]=(dp[x][y]+w)%Mod;
    }
    fac[0]=1;
    rep(i,1,n)fac[i]=fac[i-1]*i%Mod;
    ifac[n]=pw(fac[n],Mod-2);
    per(i,n-1,0)ifac[i]=ifac[i+1]*(i+1)%Mod;
    rep(i,1,n)inv[i]=ifac[i]*fac[i-1]%Mod;
    per(j,n,1){
        per(i,n,j){
            row[i][j]=(row[i][j]+row[i][j+1])%Mod;
            col[i][j]=(col[i][j]+col[i+1][j])%Mod;
            dp[i][j]=(dp[i][j]+row[i][j]+col[i][j])%Mod;
            ans[i]=(ans[i]+dp[i][j])%Mod;
            ll coef=dp[i][j]*inv[R[i]-L[i]+1]%Mod;
            if(L[i]>j){
                col[R[i]][j]=(col[R[i]][j]+coef)%Mod;
                col[L[i]-1][j]=(col[L[i]-1][j]-coef+Mod)%Mod;
            }
            else if(R[i]<j){
                row[j][R[i]]=(row[j][R[i]]+coef)%Mod;
                row[j][L[i]-1]=(row[j][L[i]-1]-coef+Mod)%Mod;
            }
            else {
                col[R[i]][j]=(col[R[i]][j]+coef)%Mod;
                col[j][j]=(col[j][j]-coef+Mod)%Mod;
                row[j][j-1]=(row[j][j-1]+coef)%Mod;
                row[j][L[i]-1]=(row[j][L[i]-1]-coef+Mod)%Mod;
            }
        }
    }
    rep(i,2,n)write(ans[i]),putchar(' ');
    cerr<<"\n"<<clock()*1.0/CLOCKS_PER_SEC*1000<<"ms\n";
    return 0;
}
```

---

## 作者：_Ch1F4N_ (赞：1)

本题约束下，两个点在树上构成的链很难直接描述，但是考虑到树剖求 LCA 过程中“两个点中的较深点跳向其链顶”的一步，你会发现链上除了 $u,v$ 还有一个点是相对固定的，那就是 $\max(u,v)$ 的父亲。

想象一下有这样一个函数 $add(u,v,w)$ 表示将链 $u,v$ 上所有边的边权加 $w$，根据上文的分析，假定 $u<v$，那么函数 $add(u,v,w)$ 调用的效果就是给边 $(fa_v,v)$ 加上 $w$ 后调用 $add(u,fa_v,w)$，如果把处理所有 $u \not = v$ 的 $add(u,v,w)$ 的调用视作一个问题的话，那这个过程中我们把一个问题归纳到了子问题上，所以不妨设 $w_{i,j}$ 表示期望意义下所有形如 $add(i,j,c)$ 的调用中的 $c$ 之和，那么 $w_{i,j}$ 就会以 $\frac{1}{r_j - l_j + 1}$ 的系数转移到 $w_{i,k}$ 其中 $l_j \leq k \leq r_j$，同时会以同样的系数加到边 $k,j$ 其中依然 $l_j \leq k \leq r_j$，假若转移后 $i > j$，那么遍历到这个状态时就把值加到 $w_{j,i}$ 上，转移顺序就是两维均从大到小转移，使用差分优化即可做到 $O(n^2)$。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod = 998244353;
const int maxn = 5e3+114;
int pre[maxn][maxn];
int l[maxn],r[maxn],inv[maxn];
int w[maxn][maxn],e[maxn][maxn];
int qpow(int a,int b){
	if(b==0) return 1;
	if(b==1) return a;
	int res=qpow(a,b/2);
	res=1ll*res*res%mod;
	if(b%2==1) res=1ll*res*a%mod;
	return res;
}
int n,m; 
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=2;i<=n;i++) cin>>l[i]>>r[i],inv[i]=qpow(r[i]-l[i]+1,mod-2);
	cin>>m;
	while(m--){
		int u,v,c;
		cin>>u>>v>>c;
		if(v<u) swap(u,v);
		w[u][v]=(1ll*w[u][v]+c)%mod;
	} 
	for(int i=n;i>=1;i--){
		for(int j=n;j>=1;j--){
			pre[i][j]=(1ll*pre[i][j]+pre[i][j+1])%mod;
			w[i][j]=(1ll*w[i][j]+pre[i][j])%mod;
			if(j>i){
				pre[i][r[j]]=(1ll*pre[i][r[j]]+1ll*w[i][j]*inv[j]%mod)%mod;
				pre[i][l[j]-1]=(1ll*pre[i][l[j]-1]+mod-1ll*w[i][j]*inv[j]%mod)%mod;
				e[j][r[j]]=(1ll*e[j][r[j]]+1ll*w[i][j]*inv[j]%mod)%mod;
				e[j][l[j]-1]=(1ll*e[j][l[j]-1]+mod-1ll*w[i][j]*inv[j]%mod)%mod;
			}else if(j<i){
				w[j][i]=(1ll*w[j][i]+w[i][j]);
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=n;j>=1;j--) e[i][j]=(1ll*e[i][j]+e[i][j+1])%mod; 
	}
	for(int i=2;i<=n;i++){
		int res=0;
		for(int j=l[i];j<=r[i];j++) res=(1ll*res+e[j][i]+e[i][j])%mod;
		cout<<res<<' ';
	}
	return 0;
}
```

---

## 作者：orange_new (赞：0)

节选自：[DP做题记录（三）（2025.4.5 - 2025.4.19）](https://www.luogu.com.cn/article/tobtmxka)

[安利一下我的博客](https://www.cnblogs.com/JPGOJCZX/p/18834576)

我们考虑通常如何把一条树链 $(u, v)$ 增加 $w$ 的权值，最暴力的做法就是把 $u$ 和 $v$ 分别到根的路径上的边权加 $w$，再将 $u$ 和 $v$ 的 LCA 到根的路径上的边权减 $2 \times w$。其实可以发现，不管 $u$ 和 $v$ 是否是祖先关系，它们中深度更深的点的父边一定加上了 $w$。而且这道题目有一个有趣的性质，那就是一个点 $u$ 的父亲一定比 $u$ 的编号小，那也就是 $u, v$ 中编号更大的点的父边一定加上了 $w$。

推出了性质后，我们从简单情况一步一步分析。假设只有一组修改 $(u, v, w)$，那么我们直接设 $ dp_{i, j}(i \geq j)$ 表示从点对 $(u, v)$ 往上走到 $(i, j)(u \leq i, j \leq v)$，$i$ 的父边权值的期望，由于推出的性质，只有 $i$ 的父边一定加上了 $w$，因此可以很轻松写出转移方程，枚举 $fa_i \in [l_i, r_i]$，那么若 $fa_i \geq j$，$f_{fa_i, j} = \displaystyle\frac{w}{r_i - l_i + 1}$；若 $fa_i < j$，$f_{j, fa_i} = \displaystyle\frac{w}{r_i - l_i + 1}$。

我们考虑期望的线性性，两个独立事件的期望和，等于这两个事件至少发生一件的期望，那么由于这几个加法操作相互独立，它们的期望可以直接加在一起，于是改变 $f_{i, j}(i \geq j)$ 的含义，为所有能够往上走到 $(i, j)$ 的所有点对 $(u, v)$，从 $(u, v)$ 往上走到 $(i, j)$，$i$ 的父边权的期望的和，转移方程几乎不变，只是把赋值变成加操作。此时一个点 $u$ 的答案就是 $\displaystyle\sum_{u > v} dp_{v, u}$。不过这样时间复杂度是 $O(n^3)$，还是过不了。

我们考虑转移方程，对于所有 $fa_i \geq j$，$f_{fa_i, j} = \displaystyle\frac{w}{r_i - l_i + 1}$，此时 $j$ 是不变的，而 $fa_i$ 在区间 $[j, r_i]$ 中，这相当于是对平面上一个 $1 \times (r_i - j + 1)$ 的矩阵加上了 $w$；同理，对于所有 $fa_i < j$，这相当于是对平面上一个 $(j - l_i) \times 1$ 的矩阵加上了 $w$，由于是把所有操作都执行完后才进行询问，于是可以用二维差分将时间复杂度优化成 $O(n^2 + m)$，足以通过此题。

完整代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 5e3 + 9, MOD = 998244353;
int f[N][N], s1[N][N], s2[N][N], inv[N], l[N], r[N], ans[N], n, m;
void init(){
	inv[1] = 1;
	for(int i = 2; i < N; i++)
		inv[i] = (MOD - MOD / i) * inv[MOD % i] % MOD;
}
signed main(){
	init();
	scanf("%lld", &n);
	for(int i = 2; i <= n; i++)
		scanf("%lld%lld", &l[i], &r[i]);
	scanf("%lld", &m);
	for(int i = 1; i <= m; i++){
		int u, v, w;
		scanf("%lld%lld%lld", &u, &v, &w);
		if(u < v)
			swap(u, v);
		f[u][v] = (f[u][v] + w) % MOD;
	}
	for(int i = n; i >= 1; i--){
		for(int j = i - 1; j >= 1; j--){
			s1[i][j] = (s1[i][j] + s1[i + 1][j]) % MOD;
			s2[i][j] = (s2[i][j] + s2[i][j + 1]) % MOD;
			f[i][j] = (f[i][j] + s1[i][j] + s2[i][j]) % MOD;
			ans[i] = (ans[i] + f[i][j]) % MOD;
			int num = f[i][j] * inv[r[i] - l[i] + 1] % MOD;
			if(j < l[i]){
				s1[r[i]][j] = (s1[r[i]][j] + num) % MOD;
				s1[l[i] - 1][j] = ((s1[l[i] - 1][j] - num) % MOD + MOD) % MOD;
			} else if(j > r[i]){
				s2[j][r[i]] = (s2[j][r[i]] + num) % MOD;
				s2[j][l[i] - 1] = ((s2[j][l[i] - 1] - num) % MOD + MOD) % MOD;
			} else {
				s2[j][j] = (s2[j][j] + num) % MOD;
				s1[r[i]][j] = (s1[r[i]][j] + num) % MOD;
				s2[j][l[i] - 1] = ((s2[j][l[i] - 1] - num) % MOD + MOD) % MOD;
				s1[j][j] = ((s1[j][j] - num) % MOD + MOD) % MOD;
			}
		}
	}
	for(int i = 2; i <= n; i++)
		printf("%lld ", ans[i]);
	return 0;
}
```

---

## 作者：BreakPlus (赞：0)

考虑 $m=1, w=1$ 的时候怎么做。

令 $P(a \to b)$ 表示 $a$ 不断跳父亲能经过 $b$ 的概率；$P(a,b \to c)$ 表示 $a,b$ 的 LCA 为 $c$ 的概率。

一个经典的拆贡献方式（树上差分）：对于一个点 $x$，其贡献应为 $P(u \to x) + P(v \to x) - 2\sum_{x_0} P(u,v \to x_0) \cdot P(x_0 \to x)$。

不难发现对于任意 $(a,b)$，$P(a \to b)$ 可以较轻松地预处理出来。枚举 $b$，按编号从小到大，前缀和优化 DP 即可：

$$P(a \to b) = \dfrac{1}{r_a-l_a+1}\sum_{x \in [l_a, r_a]} P(x \to b)$$

问题在于如何计算 $P(a,b \to c)$。为什么不是 $P(a \to c) \cdot P(b \to c)$ 呢？因为有可能 $a,b$ 在未到达 $c$ 的时候就已经相交，算多了。

考虑通过钦定的手段，容斥计算答案。

+ 如果钦定 $a,b$ **最后一次相交**在 $c_0$ 处，那么计算 $Q(x \to y)$ 表示 $x$ 到 $y$ 走两条不相交路径的概率。但是 $Q$ 本身也只能容斥算了，似乎规约到很复杂的问题，一般来说必须 $\mathcal{O}(n^3)$。

+ 如果钦定 $a,b$ **第一次相交**在 $c_0$ 处，那么 $c_0$ 到 $c$ 的路径就任意了。我们可以很简单地写出转移：

$$P(a,b \to c) = P(a\to c) \cdot P(b \to c) - \sum_{c_0} P(a,b \to c_0) \cdot P^2(c_0 \to c)$$

也就是 $a,b$ 先走到 $c_0$，再各走各路（可以任意相交）走到 $c$。

综上，我们在 $\mathcal{O}(n^2)$ 的时间复杂度内解决了 $m=1$ 的问题。

----

由于期望线性性，我们可以对所有的点对 $(u_i, v_i)$，把所有的 $P(u_i, v_i \to x)$ 全叠在一起转移。正确性显然，每次修改转移都一样。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
inline ll read(){
	ll x; scanf("%lld",&x); return x;
}
const ll mod = 998244353;
inline ll qpow(ll a,ll b){
	ll ans=1, base=a;
	while(b){
		if(b&1) ans=ans*base%mod;
		base=base*base%mod;
		b>>=1;
	}
	return ans;
}
ll n,l[5005],r[5005],inv[5005];
ll m,u[5005],v[5005],w[5005],ans[5005];
ll dp[5005][5005], sum[5005][5005], out[5005];
int main(){
	n=read();
	for(ll i=0;i<=n;i++) inv[i]=qpow(i,mod-2);
	for(ll i=2;i<=n;i++){
		l[i]=read(), r[i]=read();
	}
	for(ll i=1;i<=n;i++){
		dp[i][i] = 1; sum[i][i] = 1;
		for(ll j=i+1;j<=n;j++){
			dp[i][j]=(sum[i][r[j]]-sum[i][l[j]-1]+mod)*inv[r[j]-l[j]+1]%mod;
			sum[i][j]=(dp[i][j]+sum[i][j-1])%mod;
		}
	}
	m=read();
	for(ll i=1;i<=m;i++){
		u[i]=read(), v[i]=read(), w[i]=read();
		for(ll j=1;j<=n;j++){
			ans[j]=(ans[j]+dp[j][u[i]]*dp[j][v[i]]%mod*w[i])%mod;
		}
	}
	for(ll i=n;i>=1;i--){
		for(ll j=i+1;j<=n;j++){
			ans[i]=(ans[i]+(mod-ans[j])*dp[i][j]%mod*dp[i][j])%mod;
		}
	}
	for(ll i=n;i>=2;i--){
		for(ll j=1;j<=m;j++){
			out[i]=(out[i]+(dp[i][u[j]]+dp[i][v[j]])*w[j])%mod;
		}
		for(ll j=i;j<=n;j++){
			out[i]=(out[i]+2*(mod-dp[i][j])*ans[j])%mod;
		}
	}
	for(ll i=2;i<=n;i++) printf("%lld ", out[i]);
	return 0;
}

```

---

## 作者：JWRuixi (赞：0)

## P10879 「KDOI-07」对树链剖分的爱

### 题意

给定 $(l_i, r_i), i = 2, \dots, n$ 满足 $l_i \le r_i < i$，对于任意 $i$ 在 $[l_i, r_i]$ 内随机选择父亲可以生成一棵 $n$ 个点的树。

给定 $m$ 个修改 $(u, v, w)$ 表示给 $u$ 到 $v$ 的路径上的边加 $w$。

对于 $i = 2, \dots, n$，求 $i$ 到父亲的期望边权。

### 分析

考虑 $u, v$ 不停的向上跳父边，直到 LCA 的过程，这可以刻画成 $u, v$ 均一直跳到根，在第一个被同时被两个点经过的位置截断，两个过程是等价的。记 $P_u$ 为 $u$ 跳到根的路径，那么修改相当于对 $P_u$ 和 $P_v$ 被截断前的所有点加 $w$。

记 $P_u$ 被截断的剩下的部分为 $Q_u$，很难不发现 $Q_u \cap Q_v = \empty$，也就是说，维护 $(Q_u, Q_v)$ 和维护 $Q_u \cup Q_v$ 是等价的。进一步观察可以发现，我们实际上可以在走完之前就确定某一个点是否被修改，具体的：对于 $x$，我们只需要走完 $\ge x$ 的部分就可以确定了！

记 $P((u_t, v_t) \to (i, j))$ 表示 $u_t, v_t$ 两个点走不相交的两条路径，分别到达 $i, j$ 或 $j, i$ 的概率。由于路径 $\ge j$ 的部分已经确定了，我们发现修改的贡献相当于 $ans_j \gets P((u_t, v_t) \to (i, j))w_t$。

发现不同的修改互相独立，于是可以设计 $f_{i, j}(i < j)$ 表示 $\sum\limits_{t \le m} P((u_t, v_t) \to (i, j)) w_t$。转移考虑移动 $j$，不能移动到 $i$ 上，统计答案是简单的。

考虑所有转移的形式都形如 $w \to f_{[L, R], j}$ 或 $w \to f_{i, [L, R]}$。所以我们分别对两维进行差分优化即可！

### Code

<https://pastebin.com/bcKp4CGM>。

---


# [HNOI2011] XOR和路径

## 题目描述

给定一个无向连通图，其节点编号为 $1$ 到 $N$，其边的权值为非负整数。试求出一条从 $1$ 号节点到 $N$ 号节点的路径，使得该路径上经过的边的权值的“XOR 和”最大。该路径可以重复经过某些节点或边，当一条边在路径中出现多次时，其权值在计算“XOR 和”时也要被重复计算相应多的次数。


直接求解上述问题比较困难，于是你决定使用非完美算法。具体来说，从 $1$ 号节点开始，以相等的概率，随机选择与当前节点相关联的某条边，并沿这条边走到下一个节点，重复这个过程，直到走到 $N$ 号节点为止，便得到一条从 $1$ 号节点到 $N$ 号节点的路径。显然得到每条这样的路径的概率是不同的并且每条这样的路径的“XOR 和”也不一样。现在请你求出该算法得到的路径的“XOR 和”的期望值。

## 说明/提示

### 样例解释

有 $\dfrac{1}{2}$ 的概率直接从 $1$ 号节点走到 $2$ 号节点，该路径的“XOR和”为 $3$；有 $\dfrac{1}{4}$ 的概率从 $1$ 号节点走一次 $1$ 号节点的自环后走到 $2$ 号节点，该路径的“XOR和”为 $1$；有 $\dfrac{1}{8}$ 的概率从 $1$ 号节点走两次 $1$ 号节点的自环后走到 $2$ 号节点，该路径的“XOR和”为 $3$…依此类推，可知“XOR和”的期望值为：$\dfrac{3}{2}+\dfrac{1}{4}+\dfrac{3}{8}+\dfrac{1}{16}+\dfrac{3}{32}+\cdots=\dfrac{7}{3}$，约等于 $2.333$。

### 数据范围

- $30\%$ 的数据满足 $N\le 30$。  
- $100\%$ 的数据满足 $2\le N\le 100$，$M\le 10000$，但是图中可能有重边或自环。

## 样例 #1

### 输入

```
2 2
1 1 2
1 2 3```

### 输出

```
2.333```

# 题解

## 作者：花里心爱 (赞：35)

[题目链接](https://www.luogu.org/problemnew/show/P3211)

一般来说，遇到求期望的题时，我们都要转化期望的形式使其便于求解。

对于这道题，我们可以将它转化为一个期望dp模型。

我们先试着列一下dp式子：

设$f[i]$为当前在$i$号节点，走到$n$号节点得到的异或和的期望值。

然后对于每个$f[i]$，它可以由每个与它相邻的节点的状态转移过来。所以状态转移方程为：

$$f[i] = \sum{(f[to[p]] \operatorname{xor} val[p])/deg[i]}$$

（这里$p$表示与$i$相邻的边，$to[p]$为这条边连接的另一个点，$val[p]$为边权，$deg[i]$表示$i$的度）

然后我们就可以~~愉快地~~转移……了吗？

由于这个图不是一个$DAG$，所以通过一个点可能经过某条路径使它能够回到原点。也就是说，这里的状态是有后效性的。

看起来状态有后效性的题我们似乎并不能dp求解。

然而这里的答案（期望）~~显然~~是存在的。

于是我们设所有的$f[i]$为未知数，根据上面的式子列方程求解。

我们把原式转化一下：

$$deg[i] \times f[i] = \sum{(f[to[p]] \operatorname{xor} val[p])}$$

（其中所有的$f$为未知量）

我们需要用到高斯消元，时间复杂度为$O(n^3)$

然后我们就会发现，上面列的dp式子带一个$\operatorname{xor}$，不能直接用这个式子列方程。

于是我们就考虑期望的~~各种神奇的~~性质（好吧我们知道的关于期望的性质只有一个，那就是期望具有线性性，即$E(a+b) = E(a) + E(b)$）

那么由于异或运算的每一位互不影响，我们可以把每一位拆开。这样我们的$val[p]$就只剩下了0或1。

然后我们的$f[i]$定义就变成了：当前在$i$号节点，走到$n$号节点得到的异或和为1的期望值（也就是该位为1的概率）。

然后我们就能把$\operatorname{xor}$拆成两种情况，即：

$$deg[i] \times f[i] = \sum_{val[p]=0}{f[to[p]]}+\sum_{val[p]=1}{(1-f[to[p]])}$$

$$\sum_{val[p]=0}{f[to[p]]}-\sum_{val[p]=1}{f[to[p]]} - deg[i] \times f[i] = -\sum_{val[p]=1}{1}$$

（因为$1\operatorname{xor}0=0\operatorname{xor}1=1$）

对于每一位都做一遍，最终答案为$\sum_{i=0}^{30}{2^if[1]}$

时间复杂度为$O(30n^3)$

下面放代码：
```cpp
#include <cstdio>
#include <cctype>
#include <cstring>
#include <algorithm>
#define maxn 105
#define maxm 20005
inline int read() {
	int d=0;char ch=getchar();while(!isdigit(ch))ch=getchar();
	while(isdigit(ch)){d=d*10+ch-48;ch=getchar();}return d;
}

const double eps = 1e-9;
inline double fabs(double x) {return x < 0 ? -x : x;}
inline int sgn(double x) {return x > eps ? 1 : x < -eps ? -1 : 0;}

int n, m, u, v, w;
int head[maxn], ver[maxm], edge[maxm], nxt[maxm], tot;
int deg[maxn];

inline void add(int u, int v, int w) {
	ver[++tot] = v, edge[tot] = w, nxt[tot] = head[u], head[u] = tot;
}

double a[maxn][maxn];
double ans;

void gauss() { // 高斯消元过程
	double div;
	for(int i = 1; i <= n; ++i) {
		int m = i;
		for(int j = i+1; j <= n; ++j)
			if(sgn(fabs(a[j][i])-fabs(a[m][i])) == 1)
				m = j;
		for(int k = i; k <= n+1; ++k)
			std::swap(a[m][k], a[i][k]);
		div = a[i][i];
		for(int k = i; k <= n+1; ++k)
			a[i][k] /= div;
		for(int j = 1; j <= n; ++j) {
			if(j != i) {
				div = a[j][i];
				for(int k = i; k <= n+1; ++k)
					a[j][k] -= div*a[i][k];
			}
		}
	}
}

int main() {
	n = read(), m = read();
	for(int i = 1; i <= m; ++i) {
		u = read(), v = read(), w = read();
		if(u == v) { // 注意有自环的情况，此时只能统计一次
			++deg[u];
			add(u, v, w);
		}
		else {
			++deg[u], ++deg[v];
			add(u, v, w), add(v, u, w);
		}
	}
	for(int k = 30; k >= 0; --k) { // 对于每一位拆开来做
		memset(a, 0, sizeof(a));
		for(int i = 1; i < n; ++i) {
			a[i][i] = -deg[i];
			for(int p = head[i]; p; p = nxt[p]) {
				int v = ver[p], w = (edge[p]>>k)&1; // w为边权在2进制下的第k位
				if(w) a[i][v] -= 1, a[i][n+1] -= 1;
				else a[i][v] += 1; 
			}
		}
		a[n][n] = 1;
		gauss();
		ans += (1<<k)*a[1][n+1]; // 合并答案
	}
	printf("%.3lf", ans);
	return 0;
}
```

---

## 作者：Kelin (赞：26)

## [题意](https://blog.csdn.net/BeNoble_/article/details/79825013)

给你一幅无向图$,$一条路径的权值为路径上边权的异或和

你在每个点可以等概率的走向相连的点

求$1\to n$路径权值的期望(有自环重边)

---

一开始想偏了$,$以为期望的异或就是异或的期望

后来发现可以按位处理

---

## 题解

~~整个处理显然是不行的~~

因为每一位都是独立的$,$所以考虑按位处理$,$求出每一位是$1$的概率

还是~~按照套路~~设$f[u]$表示$u\to n$的路径这一位为$1$的概率,$dg[u]$表示$u$的出度

那么$1-f[u]$就是$u\to n$的路径这一位为$0$的概率

$$\forall_{(u,v)\in E}\ f[u]=\frac1{dg[u]}(\sum_{w(u,v)=0}f[v]+\sum_{w(u,v)=1}1-f[v])$$

$$\Rightarrow\forall_{(u,v)\in E}\ dg[u]f[u]=\sum_{w(u,v)=0}f[v]+\sum_{w(u,v)=1}1-f[v]$$

也就是这条边这一位是$1$那么$v\to n$的权值就要是$0;$反之则为$1$

方程即为

$$dg[u]f[u]-\sum_{w(u,v)=0}f[v]+\sum_{w(u,v)=1}f[v]=\sum_{w(u,v)=1}1$$

高斯消元即可

最后$ans=\sum_i2^if_i[1]$

注意这题虽然是无向图$,$但是自环也不能加两次$,$需要特判

```
#include<bits/stdc++.h>
#define fp(i,a,b) for(register int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(register int i=a,I=b-1;i>I;--i)
#define go(u) for(register int i=fi[u],v=e[i].to;i;v=e[i=e[i].nx].to)
#define file(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
template<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}
template<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}
using namespace std;
char ss[1<<17],*A=ss,*B=ss;
inline char gc(){return A==B&&(B=(A=ss)+fread(ss,1,1<<17,stdin),A==B)?-1:*A++;}
template<class T>inline void sd(T&x){
    char c;T y=1;while(c=gc(),(c<48||57<c)&&c!=-1)if(c==45)y=-1;x=c-48;
    while(c=gc(),47<c&&c<58)x=x*10+c-48;x*=y;
}
char sr[1<<21],z[20];int C=-1,Z;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
template<class T>inline void we(T x){
    if(C>1<<20)Ot();if(x<0)sr[++C]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]='\n';
}
const int N=105,M=2e4+5;
const double eps=1e-9;
typedef int arr[N];
typedef double db;
struct eg{int nx,to,w;}e[M];
int n,m,Mx;arr dg,fi;db Ans,ans[N],G[N][N];
inline void build(int x){
    G[n][n]=1;
    fp(u,1,n-1){
        G[u][u]=dg[u];
        go(u)
            if(e[i].w&x)++G[u][v],++G[u][n+1];
            else --G[u][v];
    }
}
inline int cmp(db x){return fabs(x)<eps?0:x<0?-1:1;}
inline void Gauss(int n){
    db t;int mx;
    fp(i,1,n){mx=i;
        fp(j,i,n)if(cmp(G[mx][i]-G[j][i]))mx=j;
        fp(j,i+1,n)if(cmp(G[j][i])){
            t=G[j][i]/G[i][i];
            fp(k,i,n+1)G[j][k]-=G[i][k]*t;
        }
    }
    fd(i,n,1){
        fp(j,i+1,n)G[i][n+1]-=G[i][j]*ans[j];
        ans[i]=G[i][n+1]/G[i][i];
    }

    fp(i,1,n)fp(j,1,n+1)G[i][j]=0;
}
inline void add(int u,int v,int w){static int ce=0;e[++ce]={fi[u],v,w},fi[u]=ce;}
int main(){
    #ifndef ONLINE_JUDGE
        file("s");
    #endif
    sd(n),sd(m);int u,v,w;
    while(m--){
        sd(u),sd(v),sd(w),add(u,v,w),++dg[u];
        if(u^v)add(v,u,w),++dg[v];cmax(Mx,w);
    }
    for(int i=1;i<=Mx;i<<=1)
        build(i),Gauss(n),Ans+=ans[1]*i;
    printf("%.3lf\n",Ans);
return 0;
}
```

---

## 作者：是个汉子 (赞：13)

[洛谷传送门](https://www.luogu.com.cn/problem/P3211)

### Solution

我们可以发现这个题和游走很像（虽然游走是HNOI2013，这个是HNOI2011吧）

但是这个题是要求异或和，每一位是互不干扰的，再加上期望的线性性，所以考虑**每一位单独计算**。

我们设 $f_i$ 表示从 $i$ 到 $n$ 路径这一位异或和为 $1$ 的概率，那么我们可以~~显然的~~得到转移方程：
$$
f_u=\sum_{v\in w_{u,v} 此位为 0} \frac {f_v}{d_u}+\sum_{v\in w_{u,v} 此位为 1} \frac {1-f_v}{d_u}
$$
（其中 $w_{u,v}$ 表示 $\langle u,v\rangle$ 这条边的边权， $d_u$ 表示 $u$ 的度数，即与 $u$ 相连的边数，包括自环）

前面的 $\sum$ 表示要在 $v$ 中找 $0$ 的概率，后面的表示要在 $v$ 中找 $1$ 的概率。

我们发现这个方程是有后效性的，所以还要继续考虑。发现进一步转化可以得到：
$$
-\sum_{v\in w_{u,v} 此位为 1}\frac 1{d_u}=-f_u+\sum_{v\in w_{u,v} 此位为 0} \frac {f_v}{d_u}-\sum_{v\in w_{u,v} 此位为 1} \frac {f_v}{d_u}
$$

哦~这长得很像 $n-1$ 元方程啊，而我们总共有 $n-1$ 个方程，所以考虑用高斯消元求解。

（ 因为到达 $n$ 的时候就停止了，所以 $f_n=0$ ，在计算的时候不考虑）

再简单的提一下计算答案： 设当前位为 $i$ ，那就 $ans+=f_1\times 2^i$ 即可。

注意：一个自环只能增加一条边，重边在累加方程系数的时候都要算上。

时间复杂度为 $O(n^3\log w)$ 

~~完结撒花~~

---

你不会以为这就完了吧(⊙_⊙)

为什么是从 $u$ 到 $n$ 逆推呢？我相信只有我一个蒟蒻感到疑惑，但是还是要说一下。

因为异或和不为 $1$ 的概率是 $1-f_u$ ，但是正推此时的含义是： $1$ 到 $u$ 异或和不为 $1$ 的概率和**从 $1$ 无法走到 $u$ 的概率**；但是逆推的话， $1-f_u$ 就还是走到 $n$ ヾ(≧▽≦*)o

正式完结撒发。

### Code

```c++
#include<bits/stdc++.h>
#define re register

using namespace std;
const int N=110;
const double eps=1e-9;
int n,m,head[N],cnt,d[N],pw[N];
double a[N][N],f[N],ans;
struct edge{
    int to,nxt,w;
}e[N*N<<1];

inline int read(){
    int x=0,f=1;
    char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
    while(isdigit(ch)){x=x*10+(ch^48);ch=getchar();}
    return x*f;
}

inline void add(int u,int v,int w){
    e[++cnt].to=v;
    e[cnt].w=w;
    e[cnt].nxt=head[u];
    head[u]=cnt;
    d[v]++;
}

inline void Gauss(){
    for(re int i=1;i<n;i++)
        for(re int j=i+1;j<=n;j++){
            double tmp=a[j][i]/a[i][i];
            for(re int k=1;k<=n+1;k++) a[j][k]-=a[i][k]*tmp;
        }
    for(re int i=n;i;i--){
        f[i]=a[i][n+1]/a[i][i];
        for(re int j=i-1;j;j--) a[j][n+1]-=a[j][i]*f[i];
    }
}

int main(){
    n=read(); m=read();
    memset(head,-1,sizeof(head));
    pw[0]=1;
    for(re int i=1;i<=30;i++) pw[i]=pw[i-1]*2;
    for(re int i=1,u,v,w;i<=m;i++){
        u=read(); v=read(); w=read();
        add(u,v,w); if(u!=v) add(v,u,w);
    }
    for(re int i=0;i<=30;i++){
        memset(a,0,sizeof(a)); a[n][n]-=1.0;
        for(re int u=1;u<n;u++){
            a[u][u]=-1;
            for(re int j=head[u];j!=-1;j=e[j].nxt){
                int v=e[j].to;
                if(~e[j].w&pw[i]) a[u][v]+=1.0/d[u];
                else a[u][n+1]-=1.0/d[u],a[u][v]-=1.0/d[u];
            }
        }
        Gauss();
        ans+=f[1]*pw[i];
    }
    printf("%.3lf\n",ans);
    return 0;
}
```

小彩蛋：题目描述中的第一段的题也是真实出现的，就是[介个](https://www.luogu.com.cn/problem/P4151)。

---

## 作者：Holy_Push (赞：7)

我还是tcl做不动期望题……

一般来说，这种路径随机并且数据范围较小（一般为几百）的期望题，高斯消元是一个非常不错的选择。

如果这道题的边组成了一张$DAG$（有向无环图），那很显然，我们可以很轻松地列出$dp$方程。然而，这道题不仅是无向图，而且还有自环、重边（第一次因为没有注意到重边的存在挂成10分）等恶心人的东西，所以我们的$dp$做法就$GG$啦。

但是我们又不想放弃我们的$dp$做法，因为它看起来是正确的。那怎么办呢？

我们每个点都能列出一个$dp$方程，那是不是组在一起就是一个方程组了呢？显然是可以的。

由于位运算比较恶心，所以我们一般会选择按位来处理。我们接下来假设已经算到了第$t$位。

我们令$f[i]$表示走到$i$这个点，第$t$位的异或值为$1$的概率。

然后我们发现由于$1$这个点不好定初始值，因为$1$可以走很多次，样例里甚至给出了自环这种东西，所以这样设状态可能会非常难做。

我们发现$n$号点走到之后就不能继续走了，那我们是不是可以考虑一下，将状态改为$f[i]$表示从$i$点走到$n$点第$t$位上的值为1的概率？

显然这样更加方便。因为我们可以很容易地知道$f[n]=0$（你在这个点已经不能动了所以路径异或和为$0$）。由于概率之和肯定为1，所以从$i$点走到$n$点这一位上的异或和为$0$的概率为$1-f[i]$。

然后我们考虑其他点的方程。

我们设$p$点与$i$点相连，并且要从$p$点走到$i$点，$p->i$这条边权值在二进制下的第$t$位为$s$，第$i$个点的度数为$deg[i]$。

若$s=1$，那么要使$p$走到$i$后第$t$位为1，那么走到$p$点的异或和在第$t$位上必须为0（因为$1 xor 0=1$）。而走到$i$这个点是从$p$这个点走过来的概率又为$\frac{1}{deg[i]}$，所以$p$对$i$的贡献为$\frac{1-f[p]}{deg[i]}$

若$s=0$，那么要使$p$走到$i$后第$t$位为1，那么走到$p$点的异或和在第$t$位上必须为1（因为$0 xor 1=1$）。而走到$i$这个点是从$p$这个点走过来的概率又为$\frac{1}{deg[i]}$，所以$p$对$i$的贡献为$\frac{f[p]}{deg[i]}$

综上所述，
$f[i]=\sum_{p,s(val[i->p])=1}\frac{1-f[p]}{deg[i]}+\sum_{p,s(val[i->p])=0}\frac{f[p]}{deg[i]}(i<n)$

最后结果即为$\sum f[1]×2^{t-1}$

以样例为例吧。

先做第一位（从低位到高位）。对于$1$号点，有两个点$1,2$与它相连。$1$号点和$1$号点的边权为$2$，第$1$位为0，$2$号点和$1$号点的边权为3，第$1$位为1。所以可以列出方程

$f[1]=\frac{1}{2}f[1]+\frac{1}{2}(1-f[2])$

$f[2]=0$

解得$f[1]=1,f[2]=0$。所以第$1$位的贡献为$1×2^{0}=1$。

同理，第二位的两个方程是

$f[1]=\frac{1}{2}(1-f[1])+\frac{1}{2}(1-f[2])$

$f[2]=0$

解得$f[1]=\frac{2}{3},f[2]=0$
。所以第$2$位的贡献为$\frac{2}{3}×2^1=\frac{4}{3}$。

两者相加即为答案，$1+\frac{4}{3}=\frac{7}{3}$

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=102;
#define db double

int n,m,deg[N],first[N],f[N][N],w;
db a[N][N],ans;

struct ed
{
	int to,nxt,dis;
} edge[N*N*2];

void read(int &x,int &y) {scanf("%d %d",&x,&y);}
void read(int &x,int &y,int &z) {scanf("%d %d %d",&x,&y,&z);}

void add(int x,int y,int z)
{
	edge[++w].to=y,edge[w].nxt=first[x],edge[w].dis=z,first[x]=w;
}

int getw(int x,int i)
{
	return (x&(1<<(i-1)))>>(i-1);
}

void Gauss(int t)
{
	for (int i=1;i<=n;i++)
		for (int j=1;j<=n+1;j++)
			a[i][j]=0;
	for (int i=1;i<n;i++)
	{
		a[i][i]=1;
		for (int j=first[i];j;j=edge[j].nxt)
		{
			int v=edge[j].to;
			if (getw(edge[j].dis,t)==1) a[i][v]+=(db)1/deg[i],a[i][n+1]+=(db)1/deg[i];
				else a[i][v]-=(db)1/deg[i];
		}
	}
	a[n][n]=1;
	for (int i=1;i<=n;i++)
	{
		int p=i;
		while (!a[p][i]) ++p;
		for (int j=1;j<=n+1;j++) swap(a[i][j],a[p][j]);
		for (int j=1;j<=n;j++)
			if (j!=i)
			{
				db r=a[j][i]/a[i][i];
				for (int k=1;k<=n+1;k++) a[j][k]-=a[i][k]*r;
			}
	}
	ans+=a[1][n+1]/a[1][1]*(1<<(t-1));
}

int main()
{
	read(n,m);
	for (int i=1;i<=m;i++)
	{
		int u,v,w;read(u,v,w);add(u,v,w);deg[u]++;
		if (u!=v) deg[v]++,add(v,u,w);
	}
	for (int i=1;i<=31;i++) Gauss(i);
	printf("%.3lf",ans);
}
```

还是要注意重边！！！不要用邻接矩阵！！！

---

## 作者：pzc2004 (赞：4)

# 题目分析
容易发现异或时不同的二进制位不会互相影响，所以我们可以分别考虑每一个二进制位。  
对于当前考虑的二进制位，显然每条边只有0或者1两种情况。同时到达每个点时当前路径的异或和也只有0或1两种情况。我们就可以直接用高斯消元计算出经过第 $i$ 个点时当前的异或和是0和1的期望次数。计算出后只需用 $n$ 节点的异或和的期望次数乘以当前二进制位的大小即可。 
令 $f_{x,0}$ 表示经过点 $x$ 时异或和为0的期望，$f_{x,1}$ 表示经过点 $x$ 时异或和为1的期望，令 $tot_x$ 表示点 $x$ 的入度，$y$ 表示到 $x$ 有边权为0的点，$z$ 表示到 $x$ 有边权为1的点。则 
$$f_{x,0}=\sum\limits_{y}f_{y,0}+\sum\limits_{z}f_{z,1}$$
$$f_{x,1}=\sum\limits_{y}f_{y,1}+\sum\limits_{z}f_{z,0}$$
特别的，$f_{1,0}=\sum\limits_{y}f_{y,0}+\sum\limits_{1}f_{z,1}+1$。因为一开始就经过了节点1一次。  
同时注意到达 $n$ 节点时就会停止，自环只能计算一遍。  
然后只需要高斯消元就好了，复杂度$O(N^3logw)$。
``` cpp
#include<bits/stdc++.h>
using namespace std;
template<class T>inline void read(T &x)
{
	x=0;
	char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))x=x*10+(c&15),c=getchar();
}
#define N 105
#define M 10001
const double eps=0.000000000001;
int n,m,head[N],cnt,tot[N];
double a[N<<1][N<<1],ans;
struct Edge//链式前向星
{
	int a,b,c;
}e[M<<1];
inline void add(int a,int b,int c)
{
	e[++cnt].a=head[a],e[cnt].b=b,e[cnt].c=c,head[a]=cnt;
}
signed main()
{
	read(n),read(m);
	for(register int i=1,x,y,z;i<=m;i++)//加边，同时断掉n节点的所有出边
	{
		read(x),read(y),read(z);
		if(x>y)swap(x,y);
		if(x==n && y==n)continue;else if(y==n || x==y)add(x,y,z),++tot[x];else if(x!=y)add(x,y,z),add(y,x,z),++tot[x],++tot[y];
	}
	for(register int xi=0,y=1;xi<=30;xi++,y<<=1)//2^30>1e9
	{
		memset(a,0,sizeof(a));
		for(register int x=1;x<=n;x++)//列方程
		{
			a[x][x]=a[x+n][x+n]=1;
			if(x==1)a[x][n<<1|1]=1;
			for(register int i=head[x];i;i=e[i].a)
			{
				if(e[i].c&y)
				{
					a[e[i].b][x+n]-=1.0/tot[x];
					a[e[i].b+n][x]-=1.0/tot[x];
				}
				else
				{
					a[e[i].b][x]-=1.0/tot[x];
					a[e[i].b+n][x+n]-=1.0/tot[x];
				}
			}
		}
		for(register int i=1;i<=n<<1;i++)//高斯消元
		{
			double x=a[i][i];
			for(register int j=1;j<=(n<<1|1);j++)a[i][j]/=x;
			for(register int j=1;j<=n<<1;j++)
			{
				if(fabs(a[j][i])<=eps || j==i)continue;
				x=a[j][i];
				for(register int k=1;k<=(n<<1|1);k++)a[j][k]-=x*a[i][k];
			}
		}
		ans+=a[n<<1][n<<1|1]*y;//统计答案
	}
	printf("%0.3lf",ans);
	return 0;
}
```

---

## 作者：SoyTony (赞：3)

在此之前，建议先完成[本题](https://www.luogu.com.cn/problem/P3232)，解决方式是类似的。
### （1）转移方程
我们设置 $f_u$ 表示节点 $u$ 到 $n$ 路径异或和的期望，发现这是由与 $u$ 相连的节点转移而来的，于是就有：
$$f_u=\frac{1}{deg_u}\sum_{(u,v)\in E}(f_v \operatorname{xor} w)$$

然而我们面临两个问题。

首先，这个方程并非在 $\operatorname{DAG}$ 上，不能靠拓扑排序等方式直接转移。其次，若使用上面例题“游走”的高斯消元，这个 $\operatorname{xor}$ 运算也是不可做的。

### （2）求解
然而你发现，期望是线性的，因此每一位上的贡献之和（按位进制转换后）就是我们的答案，因此考虑把每个权值拆开。发现每一位贡献只可能是 $0/1$，然后仿照上式就得到：
$$f_u=\frac{1}{deg_u}\left(\sum_{w(u,v)=0} f_v+\sum_{w(u,v)=1} (1-f_v)\right)$$

然后把式子再拆一拆，就能得到：
$$f_u\times deg_u-\sum_{w(u,v)=0} f_v+\sum_{w(u,v)=1}f_v=\sum_{w(u,v)=0}1$$

显然套到高斯消元里就能求解了。

```cpp
inline void G(int n){
	for(int i=1;i<=n;i++){
		int pos=i;
		for(int j=i+1;j<=n;j++){
			if(fabs(a[j][i])-fabs(a[pos][i])>eps)
				pos=j;
		}
		if(pos!=i) swap(a[i],a[pos]);
		db q=a[i][i];
		for(int j=i;j<=n+1;j++){
			a[i][j]/=q;
		}
		for(int j=1;j<=n;j++){
			if(i!=j){
				q=a[j][i];
				for(int k=i;k<=n+1;k++){
					a[j][k]-=q*a[i][k];
				}
			}
		}
	}
}
db ans;
int main(){
	n=read(),m=read();
	for(int i=1;i<=m;i++){
		int u=read(),v=read(),w=read();
		add_edge(u,v,w); deg[u]++;
		if(u!=v){
			add_edge(v,u,w); deg[v]++;
		}
	}
	for(int k=30;k>=0;k--){
		memset(a,0,sizeof(a));
		for(int u=1;u<n;u++){
			a[u][u]=-deg[u];
			for(int i=head[u];i;i=e[i].nxt){
				int v=e[i].to,w=(e[i].w>>k)&1;
				if(w){
					a[u][v]-=1.0; a[u][n+1]-=1.0;
				}
				else{
					a[u][v]+=1.0;
				}
			}
		}
		a[n][n]=1.0;
		G(n);
		ans+=(1<<k)*a[1][n+1];
	}
	printf("%.3lf\n",ans);
}
```

---

## 作者：jijidawang (赞：3)

我趣，好毒瘤

由期望定义，可以拆贡献 .

xor 可以按位考虑，于是我们对每位做处理 .

令 $dp_u$ 表示从 $u$ 到 $n$ 路径 xor 和为 $1$ 的概率，于是
$$dp_u=\dfrac1{\deg u}\left(\sum_{val(u,v)=0}(1-dp_v)+\sum_{val(u,v)=1}dp_v\right)$$
由于可能有后效性，于是考虑 Gauss 消元 .

做完了，注意重边自环的影响 .

时间复杂度 $O(wn^3)$，其中 $w$ 是边权的位数 .

Code:
```cpp
using namespace std;
const int N = 333;
const double eps = 1e-9;
int n, m, deg[N];
double a[N][N];
vector<pair<int, int> > g[N];
inline void addedge(int u, int v, int w){g[u].emplace_back(make_pair(v, w)); ++deg[v];}
inline void ade(int u, int v, int w){addedge(u, v, w); addedge(v, u, w);}
void create(int _)
{
	a[n][n] = 1;
	for (int u=1; u<n; u++)
	{
		
		a[u][u] = deg[u];
		for (auto e : g[u])
		{
			int v = e.first, w = e.second;
			if (w & (1 << _)){++a[u][v]; ++a[u][n+1];}
			else --a[u][v]; // 重边自环 
		}
	}
}
inline bool z(const double& x){return abs(x)<eps;}
int Gauss() // O(n^3)
{
	int c, r;
	for (c=1, r=1; c<=n; c++)
	{
		int m = r;
		for (int i=r; i<=n; i++)
			if (abs(a[i][c]) > abs(a[m][c])) m = i;
		if (z(a[m][c])) continue;
		for (int i=c; i<=n+1; i++) swap(a[m][i],a[r][i]);
		for (int i=n+1; i>=c; i--) a[r][i] /= a[r][c];
		for (int i=r+1; i<=n; i++)
			if (!z(a[i][c]))
				for (int j=n+1; j>=c; j--) a[i][j] -= a[r][j] * a[i][c];
		r++;
	}
	for (int i=n; i>=0; i--) //回代
		for (int j=i+1; j<=n; j++) a[i][n+1] -= a[i][j] * a[j][n+1];
	if (r <= n)
	{
		for (int i=r; i<=n; i++)
			if (!z(a[i][n+1])) return -1;
		return 0;
	} return 1;
}
int main()
{
	scanf("%d%d", &n, &m);
	for (int i=0, u, v, w; i<m; i++)
	{
		scanf("%d%d%d", &u, &v, &w); addedge(u, v, w);
		if (u != v) addedge(v, u, w);
	}
	double ans = 0;
	for (int i=0; i<32; i++)
	{
		memset(a, 0, sizeof a);
		create(i); Gauss();
		ans += pow(2, i) * a[1][n+1];
	}
	printf("%.3f", ans);
	return 0;
}
```

---

## 作者：玫葵之蝶 (赞：2)

###看见没人水题解，我就来水一篇（手动滑稽）

我的[blog](http://blog.csdn.net/stone41123/article/details/78027949)

题解：

首先，异或的话直接讨论不好讨论，那么我们可以按位讨论，对于每一位讨论出来一个结果，然后将结果相加就好了。

然后考虑怎么讨论一位上的结果。

我们可以设出来一个dp方程：f(i)表示i到n的异或和期望值，则初始状态为f(n)=0

dp转移方程就是：其中weight(u,v)代表(u,v)的那一位的值

f(v)=∑(u,v)∈Ef(u)/degree(v) weight(u,v)=0 

f(v)=∑(u,v)∈E(1−f(u))/degree(v) weight(u,v)=1 

则对于每一个ｉ，都会有一个线性方程：

f[i]=f[j1]/degree[i]+(1−f[j2])/degree[i]+...... 

然后预处理出矩阵来，高斯消元即可。

代码：

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#define ll long long
using namespace std;
inline int read(){
    int x=0;char ch=' ';int f=1;
    while(ch<'0'||ch>'9')ch=getchar();
    if(ch=='-'){
        f=-1;ch=getchar();
    }
    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
    return x*f;
}
struct edge{
    int to,next,w;
}e[20001];
int n,m,tot;
int head[101];
int in[101];
double a[101][101];
void gauss(){
    for(int i=1;i<=n;i++){
        int mx=i;
        while(!a[mx][i])mx++;
        if(i!=mx)swap(a[i],a[mx]);
        double mul=a[i][i];
        for(int j=i;j<=n+1;j++)a[i][j]/=mul;
        for(int k=1;k<=n;k++){
            if(k!=i&&a[k][i]){
                mul=a[k][i];
                for(int j=i;j<=n+1;j++){
                    a[k][j]-=mul*a[i][j];
                }
            }
        }
    }
}
inline void addedge(int x,int y,int l){
    e[++tot].to=y;e[tot].next=head[x];e[tot].w=l;head[x]=tot;in[y]++;
}
int main(){
    n=read();m=read();
    for(int i=1;i<=m;i++){
        int x=read(),y=read(),l=read();
        if(x!=y)addedge(x,y,l),addedge(y,x,l);
        else addedge(x,y,l);
    }
    double ans=0;
    for(int k=0;k<=30;k++){
        memset(a,0,sizeof(a));
        for(int x=1;x<n;x++){
            a[x][x]=1.0;
            for(int i=head[x];i;i=e[i].next){
                int u=e[i].to;
                if((e[i].w>>k)&1){
                    a[x][u]+=1.0/in[x];a[x][n+1]+=1.0/in[x];
                }
                else{
                    a[x][u]-=1.0/in[x];
                }
            }
        }
        a[n][n]=1.0;
        gauss();
        ans+=a[1][n+1]*1.0*(1<<k);
    }
    printf("%.3lf",ans);
    return 0;
}
```

---

## 作者：tommymio (赞：1)

$\text{xor}$ 运算显然不同于其他运算，我们必须知道准确的整数才能够求这类期望问题。所以直接设 $f_i$ 为 $i\to n$ 的期望 $\mathrm{xor}$ 值是无法做的。

对于这一类与位运算相关的问题，既然不能直接做，那就尝试拆位做，这个做法正确性基于答案的每一位之间是独立的，并且对于第 $i$ 位，它的取值只能是 $0/1$。

如果我们能求出任意第 $X$ 位上的期望值 $E[X]$，那么就能够得到最终的期望是 $\sum\limits_{x}E[X]\times 2^X$。由于每一位上的取值只能是 $0/1$，根据期望定义式，二进制意义下第 $X$ 位的期望值就为第 $X$ 位为 $1$ 的概率。

设 $f_i$ 为从 $i\to n$ 第 $X$ 位上的值为 $1$ 的概率，于是有：

$$
f_i=\frac{1}{du_i}\left(\sum_{w(i,j)=0}f_j+\sum_{w(i,j)=1} 1-f_j\right)
$$

其中 $w(i,j)$ 为 $w(i,j)$ 这条边在二进制意义下的 $X$ 位的值。

根据这个式子，对于每一位直接高斯消元求解即可。注意自环只能加一次边，并且要处理重边的情况。求得 $f_1$ 后，根据上述分析统计答案。

为什么不定义 $f_i$ 为 $1\to i$ 的状态呢？~~写一写状态转移方程你就知道了（雾~~。其实也是可以的，不过对于边界和初值的情况要有更慎重的处理。

总时间复杂度为 $O(n^3 \log V)$，其中 $V$ 为边权最大值。（~~但是 $\text{tommy}$ 太懒了，代码里没有求 $V$ 而是直接将 $V=10^9$~~

```cpp
#include<cstdio>
int cnt=0;
int h[105],du[105],to[20005],ver[20005],w[20005];
double a[105][105];
inline int read() {
    register int x=0,f=1;register char s=getchar();
    while(s>'9'||s<'0') {if(s=='-') f=-1;s=getchar();}
    while(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();}
    return x*f;
}
inline void swap(double &x,double &y) {double tmp=x;x=y;y=tmp;}
inline void add(int x,int y,int z) {++du[x]; to[++cnt]=y; ver[cnt]=h[x]; w[cnt]=z; h[x]=cnt;}
inline void BuildMatrix(int n,int bit) {
    for(register int x=1;x<=n;++x) for(register int y=1;y<=n+1;++y) a[x][y]=0.00;
    a[n][n]=1;//very important
    for(register int x=1;x<n;++x) {
        a[x][x]=du[x];
        for(register int i=h[x];i;i=ver[i]) {
            if(w[i]>>bit&1) ++a[x][to[i]],++a[x][n+1];
            else --a[x][to[i]];
        }
    }
}
inline void Guass(int n) {
    for(register int i=1;i<=n;++i) {
        int tmp=0;
        for(register int j=i;j<=n;++j) if(a[j][i]) {tmp=j;break;}
        if(!tmp) continue;
        for(register int j=1;j<=n+1;++j) swap(a[i][j],a[tmp][j]);
        for(register int j=1;j<=n;++j) {
            if(j==i) continue;
            double t=a[j][i]/a[i][i];
            for(register int k=i;k<=n+1;++k) a[j][k]-=t*a[i][k];
        }
    }
}
int main() {
    int n=read(),m=read();
    double ans=0.00;
    for(register int i=1;i<=m;++i) {
        int u=read(),v=read(),w=read();
        add(u,v,w); if(u^v) add(v,u,w);
    }
    for(register int i=0;i<=30;++i) {BuildMatrix(n,i); Guass(n); ans+=(a[1][n+1]*(1<<i)/a[1][1]);}
    printf("%.3lf\n",ans);
    return 0;
}
```

---

## 作者：Gmt丶FFF (赞：0)

很明显期望 dp。

开始时想到设 $f_i$ 为 $i$ 到 $n$ 的期望值。

但由于这题是异或，所以要拆分成 $2$ 进制，分成每一位的子任务解决。

那么改变定义，设 $f_i$ 为点 $i$ 到 $n$ 第 $x$ 位为 $1$ 的期望值，$r_i$ 代表 $i$ 号点的出度。对于每一条边 $(i,j)$ 那么：

$$f_i=\frac{1}{r_i}(\sum_{(i,j)=0}f_j+\sum_{(i,j)=1}(1-f_j))$$

$$r_if_i-\sum_{(i,j)=0}f_v+\sum_{(i,j)=1}f_v=\sum_{(i,j)=1}1$$

那么我们可以把 $f_i$ 看成未知数，先建方程，再解方程即可。

但是 $n$ 个未知数，$n-1$ 个方程，所以还有一个初始方程 $f_n=0$。

很好理解，因为到了点 $n$ 以后无法再移动，所以点 $n$ 到 $n$ 期望值赋为 $0$。

答案就是起始点 $1$ 的期望值乘上对应的位数，即 $\sum f_1\times 2^{x-1}$。

复杂度：$O(n^3)$
```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<cstring>
#define int long long
using namespace std;
const int N=105;
int n,m,cnt,r[N];
double ans[N],t[N][N];
struct node
{
	int to,data;
};
vector<node>a[N];
inline int tabs(int x)
{
	return x>0?x:-x;
}
void build(int x)
{
	memset(t,0,sizeof(t));
	t[n][n]=1;
	for(int i=1;i<n;i++)
	{
		t[i][i]=r[i];
		int len=a[i].size();
		for(int j=0;j<len;j++)
		{
			if(a[i][j].data&x)t[i][a[i][j].to]++,t[i][n+1]++;
			else t[i][a[i][j].to]--;
		}
	}
}
void xiao()
{
	ans[1]=0;
	for(int i=1;i<=n;i++)
	{
		int ma=i;
		for(int j=i+1;j<=n;j++)if(tabs(t[j][i])>tabs(t[ma][i]))ma=i;
		for(int j=1;j<=n+1;j++)swap(t[i][j],t[ma][j]);
		if(!t[i][i])return;
		for(int j=1;j<=n;j++)
		{
			if(j==i)continue;
			double num=t[j][i]/t[i][i];
			for(int k=1;k<=n+1;k++)t[j][k]-=t[i][k]*num;
		}
	}
	for(int i=1;i<=n;i++)ans[i]=t[i][n+1]/t[i][i];
}
signed main()
{
	//freopen("xor.in","r",stdin);
	//freopen("xor.out","w",stdout);
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=m;i++)
	{
		int u,v,w;
		scanf("%lld%lld%lld",&u,&v,&w);
		a[u].push_back((node){v,w}),r[u]++;
		if(u!=v)a[v].push_back((node){u,w}),r[v]++;
	}
	double res=0;
	for(int i=1;i<=1e9;i<<=1)
	{
		build(i);
		xiao();
		res+=i*ans[1];
	}
	printf("%.3f",res);
	return 0;
}
```

---

## 作者：TYxxj (赞：0)

这题是概率题

对于这道题我们可以考虑按位处理

因为每一位都互不影响

我们枚举每一位

用 $f_{i}$ 表示点i在这一位是 $1$ 的概率

显然点i在这一位是0的概率就是 $1-f_{i}$

$d_{i}$ 表示点 $i$ 的度

如果 $v \sim u$ 的这条边在这一位是 $1$

那就要用 $(1-f_{v})$ (点 $v$ 在这一位是0的概率)转移才能使点u在这一位是 $1$

在 $v \sim u$ 的这条边是 $0$ 同理

这样就可以写出 $dp$ 式子：

$f_{i}=\frac{1}{d_{i}}(\sum_{edge(u,v)=0 }f_{v}+\sum_{edge(u,v)=1}1-f_{v})$

显然有后效性，不能直接递推

那就把式子化成这样 :$d_{i}∗f_{i}−\sum_{edge(u,v)=0}f_{v}+\sum_{edge(u,v)=1}f_{v}=\sum_{edge(u,v)=1}1$

这样就可以高斯消元了对吧

然后还要注意两点

1.如果有自环就只要连一条边(因为自环走两次相当于没走)

2.矩阵的第n行只有（n,n）是1，其他列都是0，其他行的第n列都是0（因为走到n就结束了，不能通过n来转移）

代码：
```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<algorithm>
const int M = 105 ;
const int N = 10005 ;
const double eps = 1e-7 ;
using namespace std ;
inline int read() {
    char c = getchar() ; int x = 0 , w = 1 ;
    while(c>'9'||c<'0') { if(c=='-') w = -1 ; c = getchar() ; }
    while(c>='0'&&c<='9') { x = x*10+c-'0' ; c = getchar() ; }
    return x*w ;
}
 
 
int n , m ;
struct E {
    int Nxt , to , dis ;
}edge[N<<1]; 
int hea[M] , num ;
inline void add_edge(int from , int to , int dis) {
    edge[++num].Nxt = hea[from] ;
    edge[num].to = to ;
    edge[num].dis = dis ;
    hea[from] = num ;
}
int d[M] , Mx ;
double B[M][M] , Ans ;
inline void Solve(int x) {
    memset(B , 0 , sizeof(B)) ;
    for(int i = 1 ; i < n ; i ++) {
        B[i][i] = d[i] ;
        for(int j = hea[i] ; j ; j = edge[j].Nxt) {
            int v = edge[j].to ;
            if(edge[j].dis&(1<<(x - 1)))
              ++B[i][v] , ++B[i][n + 1] ;
            else --B[i][v] ;
        }
    }
    for(int i = 1 ; i < n ; i ++) B[i][n] = 0 ;
    B[n][n] = 1 ;
}
inline void Gauss() {
    for(int i = 1 , Tab ; i <= n ; i ++) {
        Tab = i ;
        for(int j = i + 1 ; j <= n ; j ++)
          if(fabs(fabs(B[j][i]) - fabs(B[Tab][i])) <= eps)
            Tab = j ;
        if(Tab != i)
          for(int j = 1 ; j <= n + 1 ; j ++) swap(B[i][j] , B[Tab][j]) ;
        for(int j = i + 1 ; j <= n + 1 ; j ++) B[i][j] /= B[i][i] ;
        for(int j = 1 ; j <= n ; j ++)
          if(i != j)
            for(int k = i + 1 ; k <= n + 1 ; k ++)
              B[j][k] -= B[j][i] * B[i][k] ;
    }
}
int main() {
    n = read() ; m = read() ;
    for(int i = 1 , u , v , w ; i <= m ; i ++) {
        u = read() , v = read() , w = read() ;
        Mx = max(Mx , w) ;
        add_edge(u , v , w) ; ++d[u] ;
        if(u ^ v) add_edge(v , u , w) , ++d[v] ;
    }
    for(int i = 1 ; i <= 31 ; i ++) {
        if((1<<(i - 1)) > Mx) break ;
        Solve(i) ; Gauss() ;
        Ans += (1<<(i - 1)) * B[1][n + 1] ;
    }
    printf("%.3lf\n",Ans) ;
    return 0 ;
}
  ```

---

## 作者：chihik (赞：0)

异或的期望不能直接算，对每一位单独考虑。

$f[u][0/1]$:节点 $u$ 的第 $i$ 位为 $0/1$ 的概率。

注意经过节点 $u$ 的概率不一定为 $1$ ，所以 $f[u][0]+f[u][1]$ 的值不一定为 $1$。

$$f[1][0]=1,f[1][1]=0$$

$$f_{u,0} = \begin{cases}
\frac{f_{v,1}}{\deg_v} & \text{w第i位为1}  \\
		  \frac{f_{v,0}}{\deg_v} & \text{w第i位为0}
\end{cases}$$
$f_{u,1}$ 同理。

高斯消元得到 $f_{n,1}$ , 乘上该位所对应的数即为该位的期望。对所有位求和即为答案。

时间复杂度 $\mathcal O(n^3\log w)$。

注意重边和自环的处理。

```cpp
#include <cmath>
#include <cstdio>
#include <vector>
#include <cstring>
#include <iostream>
using namespace std;
#define eps 1e-8

const int MAXN = 200 , LOG = 31;

int w; double a[ MAXN + 5 ][ MAXN + 5 ];
void Gauss( ) {
	for( int i = 1 ; i <= w ; i ++ ) {
		int pos = i;
		for( int j = i + 1 ; j <= w ; j ++ )
			if( fabs( a[ pos ][ i ] ) < fabs( a[ j ][ i ] ) ) pos = j;
		swap( a[ i ] , a[ pos ] );
		if( fabs( a[ i ][ i ] ) < eps ) continue;
		for( int j = 1 ; j <= w ; j ++ )
			if( i != j ) {
				double del = a[ j ][ i ] / a[ i ][ i ];
				for( int k = 1 ; k <= w + 1 ; k ++ )
					a[ j ][ k ] -= a[ i ][ k ] * del; 
			}
	}
	for( int i = 1 ; i <= w ; i ++ ) if( fabs( a[ i ][ i ] ) > eps ) a[ i ][ w + 1 ] /= a[ i ][ i ];
}

int n , m , deg[ MAXN + 5 ];
struct node { int v , w; node(){} node( int V , int W ) { v = V , w = W; } };
vector< node > Graph[ MAXN + 5 ];

int main( ) {
	scanf("%d %d",&n,&m);
	for( int i = 1 , u , v , w ; i <= m ; i ++ ) {
		scanf("%d %d %d",&u,&v,&w);
		deg[ u ] ++; Graph[ u ].push_back( node( v , w ) );
		if( u != v ) deg[ v ] ++ , Graph[ v ].push_back( node( u , w ) );
	}
	
	w = 2 * n;
	double Ans = 0;
	for( int i = 0 ; i <= LOG ; i ++ ) {
		memset( a , 0 , sizeof( a ) );
		
		a[ 1 ][ w + 1 ] = 1;
		for( int u = 1; u <= n ; u ++ ) {
			a[ u ][ u ] = 1; a[ u + n ][ u + n ] = 1;
			for( node s : Graph[ u ] )
				if( s.v != n ) {
					if( ( s.w >> i ) & 1 ) {
						a[ u ][ s.v ] -= 0;
						a[ u ][ s.v + n ] -= 1.0 / deg[ s.v ];
						a[ u + n ][ s.v ] -= 1.0 / deg[ s.v ];
						a[ u + n ][ s.v + n ] -= 0;
					}
					else {
						a[ u ][ s.v ] -= 1.0 / deg[ s.v ];
						a[ u ][ s.v + n ] -= 0;
						a[ u + n ][ s.v ] -= 0;
						a[ u + n ][ s.v + n ] -= 1.0 / deg[ s.v ];
					}
				}
		}
		
		Gauss();
		Ans += a[ w ][ w + 1 ] * ( 1 << i );
	}
	printf("%.3f\n", Ans );
	return 0;
} 
```


---


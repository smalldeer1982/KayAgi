# [HNOI2013] 游走

## 题目描述

给定一个 $n$ 个点 $m$ 条边的无向连通图，顶点从 $1$ 编号到 $n$，边从 $1$ 编号到 $m$。 

小 Z 在该图上进行随机游走，初始时小 Z 在 $1$ 号顶点，每一步小 Z 以相等的概率随机选择当前顶点的某条边，沿着这条边走到下一个顶点，获得等于这条边的编号的分数。当小 Z 到达 $n$ 号顶点时游走结束，总分为所有获得的分数之和。 现在，请你对这 $m$ 条边进行编号，使得小 Z 获得的总分的期望值最小。

## 说明/提示

#### 样例输入输出 1 解释

边 $(1,2)$ 编号为 $1$，边 $(1,3)$ 编号 $2$，边 $(2,3)$ 编号为 $3$。

---

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n\leq 10$。
- 对于 $100\%$ 的数据，保证 $2\leq n \leq 500$， $1 \leq m \leq 125000$，$1 \leq u, v \leq n$，给出的图无重边和自环，且从 $1$ 出发可以到达所有的节点。

## 样例 #1

### 输入

```
3 3
2 3
1 2
1 3```

### 输出

```
3.333```

# 题解

## 作者：Siyuan (赞：89)

[$$\Large\texttt{My Blog}$$](https://hydingsy.github.io/articles/problem-HNOI-2013-Walk/)

---

## Description

> 题目链接：[Luogu 3232](https://www.luogu.org/problemnew/show/P3232)

有一个无向简单连通图，顶点从 $1$ 编号到 $n$，边从 $1$ 编号到 $m$。

小 Z 在该图上进行随机游走，初始时小 Z 在 $1$ 号顶点，每一步小 Z 以相等的概率随机选择当前顶点的某条边，沿着这条边走到下一个顶点，获得等于这条边的编号的分数。当小 Z 到达 $n$ 号顶点时游走结束，总分为所有获得的分数之和的，答案保留 $3$ 位小数。

现在，请你对这 $m$ 条边进行编号，使得小Z获得的总分的期望值最小。

数据范围：$2\le n\le 500$

------

## Solution

由于没有对 $m$ 的范围进行限定，那么 $m$ 的最大值可以达到 $O(n^2)$，这是无法接受的，因此我们考虑先统计**点的期望次数**。

我们设 $deg_i$ 表示第 $i$ 个点的度数，$f_i$ 表示第 $i$ 个点期望经过次数：
$$f_i=\begin{cases}f_1=\sum_{(i,j)\in E,j\neq n} \frac{f_j}{deg_j}+1 & i=1\\f_i=\sum_{(i,j)\in E,j\neq n} \frac{f_j}{deg_j} & 1<i<n\end{cases}$$
由于 $n$ 点时就停止游走了，因此不能考虑 $n$ 点的贡献。接下来我们对 $n-1$ 个 $f_i$ 进行高斯消元求解。

我们设 $g_i$ 表示第 $i$ 条边期望经过次数：
$$g_i=\frac{f_u}{d_u}+\frac{f_v}{d_v}\quad E_i=(u,v),u\neq n, v\neq n$$
排序贪心，期望越大的边标号越小。

**时间复杂度**：$O(n^3)$

------

## Code

```cpp
#include <cstdio>
#include <cmath>
#include <algorithm>

const int N=505,M=5e5+5;
int n,m,tot,lnk[N],ter[M],nxt[M],st[M],ed[M],deg[N];
double a[N][N],b[N],x[N],f[M];

void add(int u,int v) {
	ter[++tot]=v,nxt[tot]=lnk[u],lnk[u]=tot;
}
void Gauss(int n) {
	for(int i=1;i<=n;++i) {
		int p=i;
		for(int k=i+1;k<=n;++k) if(fabs(a[k][i])>fabs(a[p][i])) p=k;
		if(i!=p) std::swap(a[i],a[p]),std::swap(b[i],b[p]);
		for(int k=i+1;k<=n;++k) {
			double d=a[k][i]/a[i][i];
			b[k]-=d*b[i];
			for(int j=i;j<=n;++j) a[k][j]-=d*a[i][j];
		}
	}
	for(int i=n;i>=1;--i) {
		for(int j=i+1;j<=n;++j) b[i]-=x[j]*a[i][j];
		x[i]=b[i]/a[i][i];
	}
}
int main() {
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;++i) {
		scanf("%d%d",&st[i],&ed[i]);
		add(st[i],ed[i]),add(ed[i],st[i]);
		++deg[st[i]],++deg[ed[i]];
	}
	for(int u=1;u<n;++u) {
		a[u][u]=1.0;
		for(int i=lnk[u];i;i=nxt[i]) {
			int v=ter[i];
			if(v!=n) a[u][v]=-1.0/deg[v];
		}
	}
	b[1]=1;
	Gauss(n-1);
	for(int i=1;i<=m;++i) {
		int a=st[i],b=ed[i];
		if(a!=n) f[i]+=x[a]/deg[a];
		if(b!=n) f[i]+=x[b]/deg[b];
	}
	std::sort(f+1,f+m+1);
	double ans=0;
	for(int i=1;i<=m;++i) ans+=(m-i+1)*f[i];
	printf("%.3lf\n",ans);
}
```



---

## 作者：是个汉子 (赞：42)

[洛谷传送门](https://www.luogu.com.cn/problem/P3232)

### Solution

看到题不要慌，不要因为是期望而慌张。~~像我一样~~

我们一步一步分析(●'◡'●)

首先，根据贪心的思想，期望经过次数多的边我们给它更小的编号。

那么现在就想怎么求出**每条边的期望经过次数**？

经过一番思考，发现每条边只与它的两个点及点的度数有关，用式子写一下就是：
$$
g_e=\frac {f_u}{d_u}+\frac {f_v}{d_v}
$$
（其中 $e$ 为 $\langle u,v\rangle$ 这条边， $g_e$ 表示 $e$ 的期望经过次数， $f_u$ 表示 $u$ 这个点的期望经过次数， $d_u$ 表示 $u$ 的度数， $f_v,d_v$ 同理。）

因为每次经过 $u$ 的时候，都有 $\dfrac 1{d_u}$ 的概率经过这条边， $v$ 同理。

那那么我们就把问题转化到怎么求出**每个点的期望经过次数**？

又经过一波观察，发现每个点只和它相连的点及点的度数有关，用式子写出来就是：
$$
f_u=\sum_{v\in E_u}\frac {f_v}{d_v	}
$$
（其中 $E_u$ 表示和 $u$ 相连的点集。）

这个式子的道理和上面和边有关的那个式子是一样的\^o^/

但是有两个特殊的点：

1.第 $1$ 个节点是开始的节点，也就是刚开始就走过了，所以 $f_1$ 的转移不一样： $f_1=1+\sum \frac {f_v}{d_v}$ 。

2.第 $n$ 个节点是结束的节点，也就是走到 $n$ 即结束，所以任何一个点不能从 $n$ 转移，计算 $g$ 的时候也不能将 $\dfrac {f_n}{d_n}$ 计入答案。最简单的方法就是 $f_n=0$ 。

---

接下来我们可以将 $f$ 的 $n-1$ 个式子看做 $n-1$ 个 $n-1$ 元方程组，用高斯消元求解即可。

注意：因为是方程组，式子的形式都是 $a_{k,1}*f_1+a_{k,2}*f_2+\cdots+a_{k,i}*f_i+\cdots +a_{k,n}*f_n=f_k$ （ $a_{k,i}$ 代表 $f_i$ 在第 $k$ 个式子中的系数），所以对于特殊的 $f_1$ ，式子要变成 $\sum a_{1,i}*f_i=f_1-1$ 。

### Code

```c++
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>

using namespace std;
const int N=510,M=125010;
const double eps=1e-9;
int n,m,cnt,head[N],d[N],u[M],v[M];
struct edge{
    int to,nxt;
}e[M<<1];
double a[N][N],g[M],ans;

inline int read(){
    int x=0,f=1;
    char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
    while(isdigit(ch)){x=x*10+(ch^48);ch=getchar();}
    return x*f;
}

inline void add(int u,int v){
    e[++cnt].to=v;
    e[cnt].nxt=head[u];
    head[u]=cnt;

    e[++cnt].to=u;
    e[cnt].nxt=head[v];
    head[v]=cnt;

    d[u]++; d[v]++;
}

inline void gauss(){
    for(int i=1;i<=n;i++){
        int max=i;
        for(int j=i+1;j<=n;j++) if(fabs(a[j][i])>fabs(a[max][i])) swap(max,j);
        if(max!=i)
            for(int j=1;j<=n+1;j++) swap(a[i][j],a[max][j]);
        if(fabs(a[i][i])<eps) continue;
        for(int j=1;j<=n;j++){
            if(j!=i){
                double tmp=a[j][i]/a[i][i];
                for(int k=i+1;k<=n+1;k++)
                    a[j][k]-=a[i][k]*tmp;
            }
        }
    }
    for(int i=1;i<=n;i++)
        a[i][n+1]/=a[i][i];
}

int main(){
    n=read(); m=read();
    for(int i=1;i<=m;i++){
        u[i]=read(); v[i]=read();
        add(u[i],v[i]);
    }
    n--; a[1][n+1]=-1.0;
    for(int u=1;u<=n;u++){
        a[u][u]=-1;
        for(int i=head[u];i;i=e[i].nxt){
            int v=e[i].to;
            if(v!=n+1) a[u][v]=1.0/d[v];
        }
    }
    gauss();
    for(int i=1;i<=m;i++)
        g[i]=a[u[i]][n+1]/d[u[i]]+a[v[i]][n+1]/d[v[i]];
    sort(g+1,g+m+1);
    for(int i=1;i<=m;i++)
        ans+=g[i]*(m-i+1);
    printf("%.3lf\n",ans);
    return 0;
}
```



---

## 作者：League丶翎 (赞：31)

安利一波博客 [Chlience](https://chlience.com)

很容易就能看出这是一道期望题

我们要知道每条边被经过的期望值，然后期望值小的给一个比较大的编号

怎么求每条边被经过的期望值？

每条边是否被经过只由它所连接的两端节点决定

由于每个点到与之相连的任意一条边的期望相等，所以到某条特定的边的期望就是经过这个点的期望值乘上$1/$该点的总边数

那么一条边被经过的期望就应该是两端点到这条边的期望值之和

那么我们就将求边的期望转化为求点的期望

显然的,可以看出每个点的期望是由与其相连的点的期望决定的

设$f[x]$为点$x$的期望,$num[x]$为点$x$的总边数,点$x_1,x_2,x_3,...,x_k$与其相邻,则$f[x]=\sum_{i=1}^{k}\frac{f[i]}{num[i]}$

每个点都能够列出这样一个方程


直接用高斯消元法解即可

**注意**

点$1$与点$n$有些特殊

由于"游走"是从点$1$开始,则计算点$1$期望时实际期望应该是原期望+1

若有点和$n$相连,那么在计算期望时是不需要将其算入的,因为到了点$n$的时候是不会继续"游走"了

注意这两个点,就没有什么问题了

记得将每条边的两端存起来这样最后计算每条边的期望就很简单了

**代码如下**
```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 510
#define eps 1e-8
int to[N*N*2],next[N*N*2],head[N],tot;
int F[N*N],T[N*N];
double q[N*N];
int num[N];
double f[N][N];
double im[N*N*2];
int n,m;
int read() {
	int ans=0,flag=1;
	char ch=getchar();
	while((ch>'9' || ch<'0') && ch!='-') ch=getchar();
	if(ch=='-') flag=-1,ch=getchar();
	while(ch>='0' && ch<='9') ans=ans*10+ch-'0',ch=getchar();
	return ans*flag;
}
void addedge(int u,int v) {
	num[u]++;
	to[++tot]=v;
	next[tot]=head[u];
	head[u]=tot;
}
int main() {
	n=read(),m=read();
	for(int i=1;i<=m;i++) {
		int u=read(),v=read();
		addedge(u,v);
		addedge(v,u);
		F[i]=u;T[i]=v;
	}
	f[1][n]=1;
	for(int i=1;i<n;i++) {
		f[i][i]=1;
		for(int j=head[i];j;j=next[j])
			if(to[j]!=n)
				f[i][to[j]]=-1.0/num[to[j]];
	}
	for(int i=1;i<n;i++) {
		int now=i;
		double s=f[i][i];
		for(int j=i+1;j<n;j++)
			if(fabs(s-1.0)-fabs(f[j][i]-1.0)>=eps)
				{now=j;s=f[j][i];}
		if(now!=i) {
			for(int j=1;j<=n;j++)
				swap(f[i][j],f[now][j]);
		}
		for(int j=n;j>=i;j--) f[i][j]/=f[i][i];
		for(int j=1;j<n;j++)
			if(i!=j)
				for(int k=n;k>=i;k--)
					f[j][k]-=f[j][i]*f[i][k];
	}
	for(int i=1;i<=m;i++) {
		if(F[i]!=n)
			q[i]+=f[F[i]][n]*(1.0/num[F[i]]);
		if(T[i]!=n)
			q[i]+=f[T[i]][n]*(1.0/num[T[i]]);
	}
	sort(q+1,q+m+1);
	double ans=0;
	for(int i=1;i<=m;i++)
		ans+=q[i]*((m-i+1)*1.0);
	printf("%.3lf\n",ans);
	return 0;
}
```

---

## 作者：远航之曲 (赞：16)

更多有关概率和期望的姿势，欢迎来[blog](http://www.yhzq-blog.cc/概率数学期望总结/)


这题的基本思路就是，我们计算出每条边走的概率，设的时候概率大就编号小，最后把概率乘上编号，加起来就是期望。


如何算边的概率呢？可以算出点的概率，然后


$p(x,y)={p[x]\over d[x]}+{p[y] \over d[y]}$


$p[i]$表示这个点经过的概率，$d[i]$表示这个点的度。


那点的概率该怎么求呢？


$p[i]=\sum_{(i,j)\in G} {p[j]\over d[j]}$


就是和他相邻点转移到他的概率。


但是我们发现这会产生环，无法简单的递推（它旁边的点的概率需要它自己的概率推出，它自己的概率需要旁边点的概率推出）


这该如何是好呢？其实可以用列方程的思想。


我们把所有的点的概率设成未知数，然后对每个概率都列出一个式子，最后对这个方程组求解。


对方程组求解的效率是$O(n^3)$，具体可以看[这个](http://www.yhzq-blog.cc/高斯消元总结/)总结。


我们可以看下这道题的列方程的过程


```cpp
for (int i=1;i<n;i++)
{
    f[i][i]=1.0;
    for (int j=st[i];j;j=e[j].next)
        if (e[j].to!=n)
            f[i][e[j].to]=-1/d[e[j].to];
}
f[1][n]=1;
```

首先要明白我们填进去的数都是这一位的系数。所以$f[i][j]$就表示j这个点转移到i这个点的概率。这个概率再乘上未知数（这个点的概率）就求出了它对i这个点的概率的贡献。


这样的话$f[i][i]$所对的未知数就是i这个点的概率，也就是我们要解的答案。因为每个点的概率=所有转移过来点的概率和，所以其实高斯消元解的方程式这样的：


$$这个点的概率\times 1-\sum所有相邻的点转移过来的概率=0$$


而且因为一开始就在第一个点，第一个方程的结果要设成1


代码

```cpp
#include <cstdio>
#include <algorithm>
#define N 600
using namespace std;
struct edge
{
    int to,next;
}e[N*N*2];
int st[N*N*2],n,m,tot,x,y,s[N*N*2],ed[N*N*2];
double d[N],f[N][N],ans[N],sum,E[N*N*2];
void add(int x,int y)
{
    e[++tot].to=y;
    e[tot].next=st[x];
    st[x]=tot;
}
const double eps=1e-7;
int dcmp(double x)
{
    if (x<=eps&&x>=-eps) return 0;
    return (x>0)?1:-1;
}
void gauss()
{
    for (int i=1;i<n;i++)
    {
        int num=i;
        for (int j=i+1;j<n;j++)
            if (dcmp(f[j][i]-f[num][i])>0) num=j;
        if (num!=i)
            for (int j=1;j<n+1;j++)
                swap(f[i][j],f[num][j]);
        for (int j=i+1;j<n;j++)
            if (dcmp(f[j][i]))
            {
                double t=f[j][i]/f[i][i];
                for (int k=1;k<n+1;k++)
                    f[j][k]-=t*f[i][k];
            }
    }
    for (int i=n-1;i>=1;i--)
    {
        for (int j=i+1;j<n;j++)
            f[i][n]-=f[i][j]*ans[j];
        ans[i]=f[i][n]/f[i][i];
    }
}
main()
{
    scanf("%d%d",&n,&m);
    for (int i=1;i<=m;i++)
    {
        scanf("%d%d",&x,&y);
        add(x,y),add(y,x);
        d[x]+=1.0,d[y]+=1.0;
        s[i]=x,ed[i]=y;
    }
    for (int i=1;i<n;i++)
    {
        f[i][i]=1.0;
        for (int j=st[i];j;j=e[j].next)
            if (e[j].to!=n)
                f[i][e[j].to]=-1/d[e[j].to];
    }
    f[1][n]=1;
    gauss();
//    for (int i=1;i<n;i++)
//        printf("%lf ",ans[i]);
    for (int i=1;i<=m;i++)
        E[i]=ans[s[i]]/d[s[i]]+ans[ed[i]]/d[ed[i]];
    sort(E+1,E+m+1);
    for (int i=1;i<=m;i++)
        sum+=E[i]*(m-i+1.0);
    printf("%.3lf",sum);
}
```

---

## 作者：chihik (赞：7)

这道题边的数量最高是10000多，而点只有500，这提醒我们，我们不能直接对边求期望，而是点。

设$Expection[u]$表示点$u$的期望走过次数，$Degree[u]$表示点$u$的度数。

那么，
$$Expection[u]=\sum_{v \in u}\frac{Expection[v]}{Degree[v]}$$

但是，你会发现，$Expection[v]$要依靠$Expection[u]$，不能直接计算。

再次观察后，既然每一项都有其他项，类似方程形式，那我们可以用高斯消元解决，计算出每一点的$Expection$。

然后，我们先不考虑边权，根据点算出边的期望，当点$u,v$之间存在一条边时，$(u,v)$这条边显然只与点$u,v$有关，且该边的期望为：
$$
Expection(u,v)=\frac{Expection[u]}{Degree[u]}+\frac{Expection[v]}{Degre[v]}
$$

之后，利用贪心的思想，期望经过值越大，我们就分配越小的权值，统计一下答案就好了。

注意：边数可达点数平方/2，跟边有关的数组开 $\text{MAXN}$ 的平方。

```cpp
// luogu-judger-enable-o2
#include <cstdio>
#include <cmath>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;
#define eps 1e-10

const int MAXN = 500;
int n , m , u , v , Degree[ MAXN + 5 ] , S[ MAXN * MAXN ] , T[ MAXN * MAXN ];
double a[ MAXN + 5 ][ MAXN + 5 ] , Expection[ MAXN * MAXN + 5 ]; //a数组为点i到点n，点i的期望走过次数
vector< int > Graph[ MAXN + 5 ];

void Gauss( ) {
    int Row , Column;
    for( int i = 1 ; i < n ; i ++ ) {
        Column = i;
        for( int j = i ; j <= n ; j ++ )
            if( fabs( a[ j ][ i ] ) > fabs( a[ Column ][ i ] ) )
                Column = j;
        swap( a[ i ] , a[ Column ] );
        for( int j = n ; j >= i ; j -- ) 
        	a[ i ][ j ] /= a[ i ][ i ];
        for( int j = 1 ; j < n ; j ++ )
            if( i != j )
				for( int k = n ; k >= i ; k -- )
                	a[ j ][ k ] -= a[ j ][ i ] * a[ i ][ k ];
    }
}

int main( ) {
    scanf("%d %d",&n,&m);
    for( int i = 1 ; i <= m ; i ++ ) {
        scanf("%d %d",&u,&v);
        Degree[ u ] ++ , Degree[ v ] ++;
        Graph[ u ].push_back( v );
        Graph[ v ].push_back( u );
        S[ i ] = u , T[ i ] = v;
    }
    a[ 1 ][ n ] = 1;
    for( int i = 1 ; i < n ; i ++ )  {
        a[ i ][ i ] = 1;
        for( int j = 0 ; j < Graph[ i ].size( ) ; j ++ ) {
            int v = Graph[ i ][ j ];
            if( v != n ) a[ i ][ v ] = -1.0 / Degree[ v ];
        }
    }
    Gauss( );

    for( int i = 1 ; i <= m ; i ++ ) {
        if( S[ i ] != n )
            Expection[ i ] += a[ S[ i ] ][ n ] * ( 1.0 / Degree[ S[ i ] ] );
        if( T[ i ] != n )
            Expection[ i ] += a[ T[ i ] ][ n ] * ( 1.0 / Degree[ T[ i ] ] );
    }
    sort( Expection + 1 , Expection + m + 1 );

    double Ans = 0;
    for( int i = 1 ; i <= m ; i ++ )
        Ans += Expection[ i ] * 1.0 * ( m - i + 1 );
    printf("%.3lf",Ans);
    return 0;
}
```


---

## 作者：Mr_QwQ (赞：7)

高斯消元，应该不算太难

先看点，设每个点的度数为$d_u$，那么这个点经过次数的期望值就是（相邻点的期望值除以$d_v$）之和

然而题目中要求的是边权最小，所以要把边旁边的两个点分别计算经过该边的期望值并加起来

然后排序，就做完了

奇怪的是你们为什么都说这题卡$eps$精度？我没设$eps$都过了qwq

代码：
```
#include <iostream>
#include <cstdio>
#include <vector>
#include <cmath>
#include <algorithm>
using namespace std;
double a[510][510],du[510],r[260000],ans;
vector<int> to[510];
int n,m,tmp,temp,fr[260000],too[360000];
void gauss(){
    int r;
    for(int i=0;i<n;i++){
        r=i;
        for(int j=i+1;j<n;j++)if(fabs(a[j][i])>fabs(a[r][i]))r=j;
        if(r!=i)for(int j=0;j<=n;j++)swap(a[r][j],a[i][j]);
        for(int k=i+1;k<n;k++){
            double f=a[k][i]/a[i][i];
            for(int j=i;j<=n;j++)a[k][j]-=f*a[i][j];
        }
    }
    for(int i=n-1;i>=0;i--){
        for(int j=i+1;j<n;j++)a[i][n]-=a[j][n]*a[i][j];
        a[i][n]/=a[i][i];
    }
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++){
        scanf("%d%d",&tmp,&temp);fr[i]=tmp,too[i]=temp;
        to[tmp].push_back(temp);to[temp].push_back(tmp);
        du[tmp]+=1;du[temp]+=1;
    }
    for(int i=1;i<=n;i++){
        for(int j=0;j<to[i].size();j++)if(to[i][j]!=n)a[i-1][to[i][j]-1]=1/du[to[i][j]];
        a[i-1][i-1]=-1;
    }
    a[0][n]=-1;
    gauss();
    for(int i=1;i<=m;i++){
        r[i]=a[fr[i]-1][n]/du[fr[i]]+a[too[i]-1][n]/du[too[i]];
        if(fr[i]==n)r[i]-=a[fr[i]-1][n]/du[fr[i]];
        if(too[i]==n)r[i]-=a[too[i]-1][n]/du[too[i]];
    }
    sort(r+1,r+m+1);
    for(int i=1;i<=m;i++)ans+=(m-i+1)*r[i];
    printf("%.3f",ans);
    return 0;
}
```

---

## 作者：Varuxn (赞：6)

# 洛谷[P3232[NOI2013]游走](https://www.luogu.com.cn/problem/P3232)

## 题目描述

给定一个 n 个点 m 条边的无向连通图，顶点从 1 编号到 n，边从 1 编号到 m。

小 Z 在该图上进行随机游走，初始时小 Z 在 1 号顶点，每一步小 Z 以相等的概率随机选择当前顶点的某条边，沿着这条边走到下一个顶点，获得等于这条边的编号的分数。当小 Z 到达 n 号顶点时游走结束，总分为所有获得的分数之和。 现在，请你对这 m 条边进行编号，使得小 Z 获得的总分的期望值最小。


## 输入格式

第一行是两个整数，分别表示该图的顶点数 n 和边数 m。

接下来 m 行每行两个整数 u,v表示顶点 u 与顶点 v 之间存在一条边。

## 输出格式

输出一行一个实数表示答案，保留三位小数。

## 输入输出样例

### 输入
```cpp
3 3
2 3
1 2
1 3
```
### 输出
```cpp
3.333
```
### 说明提示
边 (1,2)编号为 1，边(1,3) 编号2，边(2,3) 编号为 3。

# 题解

正解的做法应该是期望dp+高斯消元QAQ

第一次接触到这样的题，我也是鼓捣了好半天

要想总体的期望值最小，就必须让经过次数越多的边的编号越小

那么这道题的主要部分就是搞每条边的期望经过次数

问题来了，边的期望并不好求，但是点的好求！！

用du[i]为点i的出度或入度，num[i]表示i点的期望经过值，f(u,v)为期望经过值

$f(u,v)=\frac{num[u]} {du[u]}+\frac{num[v]} {du[v]}$

求一个点的期望经过值就要用到高斯消元了

设s[i][j]为第i个方程第j项的系数

每个点经过自己的系数定为1;

$s[i][i]=1$

如果某个点与i相连接那么他的系数就是-1/该点的出度

$s[i][j]=-\frac{1}{du[j]}$

其他的系数就是0了

特殊的对于n而言，经过他就不会在出去，所以第n个方程处第n项外其余系数均为0

点1与点n一定会被经过，所以只有这两个式子的值是1,其余均为0，为了方便计算，我们把第i个式子的值存到s[i][n+1]上。

$s[i][n+1]= \sum_{j=1}^n x_j*s[i][j] $

最后在排个序就OK了

# Code

```cpp
#include<bits/stdc++.h>//万能头
#define ll long long
using namespace std;
const int M=125e3;
int n,m,sum,tot,head[2*M+5],ver[2*M+5],nxt[2*M+5],fro[2*M+5];
double du[505],s[505][505],num[505],ans;
priority_queue<double> q;//利用优先队列排序
void add(int u,int v)//邻接表存边
{
	ver[++tot]=v;
	fro[tot]=u;
	nxt[tot]=head[u];
	head[u]=tot;
}
void init()//初始化
{
	scanf("%d%d",&n,&m);
	for(int i=1,u,v;i<=m;i++)
	{
		scanf("%d%d",&u,&v);
		add(u,v); add(v,u);
		du[u]++; du[v]++;
	}
}
void gauss()//高斯消元 
{
	for(int i=1;i<=n;i++)//正推
	{
		int pos=0;
		for(int j=1;j<=n;j++)
			if(s[i][j])
			{
				pos=j;
				break;
			}
		if(s[i][pos]!=1&&s[i][pos])
			for(int j=n+1;j>=pos;j--)
				s[i][j]/=s[i][pos];
		for(int j=i+1;j<=n;j++)
		{
			if(!s[j][pos])
				continue;
			for(int k=n+1;k>=pos;k--)
				s[j][k]-=s[i][k]*s[j][pos];
		}
	}
	
	for(int i=n;i>=2;i--)//逆推
	{
		int pos=0;
		for(int j=1;j<=n;j++)
			if(s[i][j])
			{
				pos=j;
				break;
			}
		if(s[i][pos]!=1&&s[i][pos])
			for(int j=n+1;j>=pos;j--)
				s[i][j]/=s[i][pos];
		for(int j=1;j<i;j++)
		{
			if(!s[j][pos])
				continue;
			for(int k=n+1;k>=pos;k--)
				s[j][k]-=s[i][k]*s[j][pos];
		}
	}
}
int main()
{
	init();//初始化
	for(int i=1;i<=n;i++)
		for(int j=head[i];j;j=nxt[j])
		{
			int from=ver[j];
			if(from!=n)//因为n不可能出来，所以第i个xn系数一定为0
				s[i][from]=-1/du[from];
		}
	for(int i=1;i<=n;i++)
		s[i][i]=1;
	for(int i=1;i<n;i++)
		s[n][i]=0;
	s[n][n+1]=s[1][n+1]=1;
	gauss();//高斯消元
	for(int i=1;i<=n;i++)//记录xi的值
		for(int j=1;j<=n;j++)
			if(s[i][j]==1)
			{
				num[j]=s[i][n+1];
				break;
			}
	for(int i=1;i<tot;i+=2)//计算每条边的期望经过值
	{
		int x=fro[i],y=ver[i];
		q.push(num[x]/du[x]*(x!=n)+num[y]/du[y]*(y!=n));
	}
	while(!q.empty())//优先队列排序
	{
		sum++;
		ans+=sum*q.top();
		q.pop();
	}
	printf("%.3lf",ans);
	return 0;
}
```
第一次用LaTeX，不熟练，望包涵orz

---

## 作者：Zimse (赞：5)

#### [题目链接](https://www.luogu.com.cn/problem/P3232)

求出每条边的期望经过次数,排序后进行编号即可,问题在于如何求每条边的期望经过次数

当小Z在编号 $i$ 的点上时,向相邻的每个点移动的概率是$\frac{1}{deg_i}$

用 $f_i$ 表示第 $i$ 个点的期望经过次数

那么一条边 $(i,j)$ 的期望经过次数为

### $\frac{f_i}{deg_i}+\frac{f_j}{deg_j}$

注意点 $n$ 不能做出贡献 (走到 $n$ 就结束了)

于是把问题转换为求每个点的期望经过次数



------------


当 $i=1$ 时

### $f_i=\sum_{(i,j)\in{E} , j\not=n}\frac{f_j}{deg_j}+1$

否则

### $f_i=\sum_{(i,j)\in{E} , j\not=n}\frac{f_j}{deg_j}$

于是可以用高斯消元求解 $f_i$

时间复杂度 $O(n^3)$



------------


```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <vector>
#include <cmath>
#include <set>
#include <map>
#include <queue>
#include <stack>
#include <iostream>

#define ll long long
#define ull unsigned long long

using namespace std;

int read(){
	int __x=0,__y=1;char __c=' ';
	while(__c<'0'||__c>'9'){__c=getchar();if(__c=='-'){__y=-1,__c=getchar();break;}}
	while(__c>='0'&&__c<='9')__x=__x*10+__c-'0',__c=getchar();
	return __x*__y;}

const int N=1e3+7,M=1e6+7,Mod=998244353,INF=1e9+7,EPS=1e-8;
int n,m,d[N],U[M],V[M];
double a[N][N],f[M],ans;
vector<int> to[N];

void Gauss(){
	for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++)if(abs(a[j][i])>EPS){
			if(i!=j)for(int k=0;k<=n;k++){int t=a[i][k];a[i][k]=a[j][k],a[j][k]=t;}
			break;
		}
		for(int j=0;j<=n;j++)if(j!=i)a[i][j]/=a[i][i];a[i][i]=1;
		for(int j=1;j<=n;j++)if(j!=i){
			for(int k=0;k<=n;k++)if(k!=i)a[j][k]-=a[i][k]*a[j][i];
			a[j][i]=0;
		}
	}
	return;
}

int main(){
	n=read(),m=read();
	for(int i=1,u,v;i<=m;i++)u=read(),v=read(),++d[u],++d[v],to[u].push_back(v),to[v].push_back(u),U[i]=u,V[i]=v;
	a[1][0]=1.0;
	for(int i=1;i<n;i++){
		a[i][i]=1.0;
		for(int j=0;j<to[i].size();j++){
			int v=to[i][j];
			if(v!=n)a[i][v]-=1.0/d[v];
		}
	}
	--n,Gauss(),++n;
	for(int i=1;i<=m;i++){
		int u=U[i],v=V[i];
		if(u!=0)f[i]+=a[u][0]/d[u];
		if(v!=0)f[i]+=a[v][0]/d[v];
	}
	sort(f+1,f+m+1);
	for(int i=1;i<=m;i++)ans+=f[i]*(m-i+1);
	printf("%.3f\n",ans);
	
	return 0;
}
```


---

## 作者：_ztyqwq (赞：5)

首先这是一道期望题。什么是期望？某个数的期望差不多就是这个数在平均情况下的值~~解释不清自行baidu吧~~

那么很明显（事实上这是期望的计算公式）总分的期望值 $ = \sum\limits_{(u, v) \in E}(E_{u,v} \times V_{u,v}) $，其中 $ E_{u,v} $ 是 $ (u, v) $ 这条边经过的期望次数，$ V_{u,v} $ 是 $ (u, v) $ 这条边的编号（其实就是权值）

因为边可能比较多，用边列方程可能会TLE，所以我们先**求出每个点经过的期望次数**。

如果一个点 $ u $ 相邻的点分别为 $ v_1, v_2, v_{D_u} $，那么很明显 $ u $ 经过的期望次数 =  $ v_1 $ 走到 $ u $ 的期望 +  $ v_2 $ 走到 $ u $ 的期望 + ... + $ v_{D_u} $ 走到 $ u $ 的期望。举个例子，从点 $ a $ 走到 $ u $ 的期望值就是点 $ a $ 走过次数的期望值 $ \times $ 每次走到点 $ a $往 $ u $ 走的概率，就是 $ \frac{E_a}{D_a} $（在 $ D_a $ 条边中随机选一条走）。这样我们就可以用 $ E_{v_1}, E_{v_2}, E_{v_{D_u}} $ 和 $ E_u $ 列出方程：

### $ E_u = \sum\limits_v\frac{E_v}{D_v} $

如果 $ u = 1 $，等式右端还要再 $ + 1 $。而且注意，如果 $ v = n $，则因为 $ n $ 不能再走出来，所以这一项要忽略。

移项可以得到 $ \sum\limits_v\frac{E_v}{D_v} - E_u = 0 $，如果 $ u = 1 $，等式右端是 $ -1 $。

这就是**高斯消元**的标准形式，$ O(n^3) $ 高斯消元搞掉即可。

明显一条边经过次数的期望等于 它的起点走过这条边的期望 + 它的终点走过这条边的期望（记得是**无向图**），也就是说 $ E_{u,v} = \frac{E_u}{D_u} + \frac{E_v}{D_v} $，其中 $ E_u $ 是 $ u $ 这个点经过的期望次数，$ D_u $ 是 $ u $ 这个点的度，也就是经过这个点的边的数量。

然后因为要求 $ \sum\limits_{(u, v) \in E}(E_{u,v} \times V_{u,v}) $ 最小，所以~~很明显~~最大的 $ E_{u,v} $ 要配上最小的 $ V_{u,v} $。换句话说，经过次数越多的边权值（编号）要越小（显然吧）

所以按 $ E_{u,v} $ 从大到小排序，再配上 $ 1 - m $，统计答案就做完了。

Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int> g[501];
struct Edge
{
    int u,v;
    double val;
    bool operator<(const Edge& ano)const
    {
        return val>ano.val;
    }
}e[125000];
double f[501][501];
int main()
{
    int n,m;
    scanf("%d %d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d %d",&e[i].u,&e[i].v);
        g[e[i].u].push_back(e[i].v);
        g[e[i].v].push_back(e[i].u);
    }
    n--;
    for(int i=1;i<=n;i++)
    {
        for(vector<int>::iterator iter=g[i].begin();iter!=g[i].end();iter++)
        {
            int v=*iter;
            if(v==n+1)
                continue;
            f[i][v]=1.0/g[v].size();
        }
        f[i][i]=-1;
        if(i==1)
            f[i][n+1]=-1;
    }
    for(int i=1;i<=n;i++)
    {
        int p=i;
        for(int j=i+1;j<=n;j++)
            if(abs(f[j][i])>abs(f[p][i]))
                p=j;
        for(int j=i;j<=n+1;j++)
            swap(f[i][j],f[p][j]);
        for(int j=i+1;j<=n;j++)
            for(int k=i+1;k<=n+1;k++)
                f[j][k]-=f[i][k]*f[j][i]/f[i][i];
    }
    for(int i=n;i>=1;i--)
    {
        for(int j=i+1;j<=n;j++)
            f[i][n+1]-=f[j][n+1]*f[i][j];
        f[i][n+1]/=f[i][i];
    }
    for(int i=1;i<=m;i++)
        e[i].val=f[e[i].u][n+1]/g[e[i].u].size()+f[e[i].v][n+1]/g[e[i].v].size();
    sort(e+1,e+m+1);
    double ans=0;
    for(int i=1;i<=m;i++)
        ans+=e[i].val*i;
    printf("%.3lf\n",ans);
    return 0;
}
```

---

## 作者：crashed (赞：3)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.org/problem/P3232)看题目。
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;边的情况比较难搞，我们考虑点的情况。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设$E(u)$表示从$1$号点出发，走过$u$点的期望次数。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设$E$为边集,$d(u)$为$v$的度数，则很容易看出如下的递推方式：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$\begin{cases} \displaystyle E(1)=1+\sum_{e(1,v)\in E}\frac{E(v)}{d(v)}\\\displaystyle E(u)=\sum_{e(u,v)\in E}\frac{E(v)}{d(v)} & u\not=n \\\displaystyle E(n)=0\end{cases}$   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个也许可以$DP$？  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很遗憾不行！$DP$过程中会出现环状转移。不过由于递推式子中间没有$\min$或者$\max$函数，所以我们可以把这个变成方程，然后高斯消元一波解。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在我们来考虑边的期望。很容易看出$E(u,v)=\frac{E(u)}{d(u)}+\frac{E(v)}{d(v)}$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，期望走过次数越多的边，我们应该赋予它越小的权值，这个可以排序后贪心。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，设边$(u,v)$被赋予的权值为$V(u,v)$，走到$n$节点的期望权值和就是$\sum_{e(u,v)\in E}E(u,v)\times V(u,v)$啦。  
# 代码
```cpp
//#pragma GCC optimize(2)
#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;

namespace MySpace
{

	const double eps = 1e-7;
	const int MAXN = 505, MAXM = 250005;
	
	template<typename _T>
	void read( _T &x )
	{
	    x = 0;char s = getchar();int f = 1;
	    while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	    while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	    x *= f;
	}
	
	template<typename _T>
	void write( _T x )
	{
	    if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	    if( 9 < x ){ write( x / 10 ); }
	    putchar( x % 10 + '0' );
	}
	
	template<typename _T>
	_T ABS( const _T a )
	{
		return a < 0 ? -a : a;
	}
	
	struct edgeS
	{
		double E;
		int from, to;
		bool operator < ( const edgeS & other ) const
		{
			return E > other.E;
		}
	}edgeSet[MAXM];
	
	double A[MAXN][MAXN], E[MAXN];
	int d[MAXN];
	int N, M;
	
	void Gauss()
	{
		double tmp;
		int opt = 1, indx, l;
		for( int i = 1 ; i <= N && opt <= N ; i ++, opt ++, l = i )
		{
			indx = -1;
			for( int j = i ; j <= N ; j ++ )
			{
				if( ( ABS( A[j][opt] ) > eps && ( indx == -1 || ABS( A[j][opt] ) > ABS( A[indx][opt] ) ) ) )
				{
					indx = j;
				}
			}
			if( indx == -1 )
			{
				i --;
				continue;
			}
			swap( A[indx], A[i] );
			tmp = A[i][opt];
			for( int j = 1 ; j <= N + 1 ; j ++ ) A[i][j] /= tmp;
			for( int j = i + 1 ; j <= N ; j ++ )
			{
				tmp = A[j][opt] / A[i][opt];
				for( int k = 1 ; k <= N + 1 ; k ++ )
				{
					A[j][k] -= A[i][k] * tmp;
				}
			}
		}
		l --;
		for( int i = l ; i ; i -- )
		{
			indx = -1;
			for( int j = 1 ; j <= N ; j ++ )
			{
				if( A[i][j] == 1 )
				{
					indx = j;
					break;
				}
			}
			if( ~ indx )
			{
				E[indx] = A[i][N + 1];
				for( int j = 1 ; j < i ; j ++ )
				{
					A[j][N + 1] -= A[j][indx] * A[i][N + 1];
					A[j][indx] = 0;
				}
			}
		}
	}

}

int main()
{
	using namespace MySpace;
	read( N ), read( M );
	for( int i = 1 ; i <= N ; i ++ ) A[i][i] = 1;
	for( int i = 1 ; i <= M ; i ++ )
	{
		read( edgeSet[i].from ), read( edgeSet[i].to );
		d[edgeSet[i].from] ++, d[edgeSet[i].to] ++;
	}
	int fr, to;
	for( int i = 1 ; i <= M ; i ++ )
	{
		fr = edgeSet[i].from, to = edgeSet[i].to;
		if( fr ^ N ) A[fr][to] = -1.0 / d[to];
		if( to ^ N ) A[to][fr] = -1.0 / d[fr];
	}
	A[1][N + 1] = 1;
	Gauss();
	for( int i = 1 ; i <= M ; i ++ )
	{
		edgeS &now = edgeSet[i];
		now.E = E[now.from] / d[now.from] + E[now.to] / d[now.to];
	}
	sort( edgeSet + 1, edgeSet + 1 + M );
	double res = 0;
	for( int i = 1 ; i <= M ; i ++ )
	{
		res += edgeSet[i].E * i;
	}
	printf( "%.3lf\n", res );
	return 0;
}
```

---

## 作者：Jayun (赞：2)

# 链接：

[题目](https://www.luogu.com.cn/problem/P3232)

[博客园](https://www.cnblogs.com/GJY-JURUO/p/14252975.html)

# 题目描述：

给定一个 $n$ 个点 $m$ 条边的无向连通图，顶点从 $1$ 编号到 $n$，边从 $1$ 编号到 $m$。

小 Z 在该图上进行随机游走，初始时小 Z 在 $1$ 号顶点，每一步小 Z 以相等的概率随机选择当前顶点的某条边，沿着这条边走到下一个顶点，获得等于这条边的编号的分数。当小 Z 到达 $n$ 号顶点时游走结束，总分为所有获得的分数之和。 现在，请你对这 $m$ 条边进行编号，使得小 Z 获得的总分的期望值最小。

$2\leq n \leq 500,1 \leq m \leq 125000$。

# 正文：

边的数量太大，所以我们不能以直接求边的期望经过次数。那我们就求每个点的。设 $f_i$ 表示第 $i$ 个点的期望经过次数。那么第 $i$ 条边的期望经过次数 $g_i$ 就很好求了：

$$g_i=\frac{f_u}{deg_u}+\frac{f_v}{deg_v}$$

其中 $deg_i$ 表示第 $i$ 个点的度数。

---

现在我们的问题是如何求 $f_i$ 了。

容易得到：

$$f_i=\sum_{(i,j)\in E,j\not=n}\frac{f_j}{deg_u}+(i==1)$$

如果我们直接 DFS，肯定是过不了的。可以用高斯消元。

首先 $1$ 号点到 $n$ 点的概率肯定是 $1$，其次是点 $i$ 的期望次数减去其它点转移过来的期望次数肯定是 $0$。

因为到 $n$ 停止游走，不能考虑 $n$，这样就能构成 $n-1$ 个线性方程组，可以开搞高消了。

最后将 $g_i$ 倒序排序，就能得到答案了。

# 代码：

```cpp
int n, m;
int deg[N];
double f[N], a[N][N], g[M], ans;

struct edge
{
	int from, to, nxt;
}e[M << 1];
int head[N], tot;

void add (int u, int v)
{
	e[++tot] = (edge){u, v, head[u]}, head[u] = tot;
}

void Gauss(int n)
{
	for (int i = 1; i <= n; i++)
	{
		int mxi = i;
		for (int j = i + 1; j <= n; j++)
			if(fabs(a[mxi][i]) < fabs(a[j][i])) mxi = j;
		swap(a[mxi], a[i]);
		double inv = a[i][i];
		for (int j = i; j <= n + 1; j++)
			a[i][j] /= inv;
		for (int j = i + 1; j <= n; j++)
		{
			inv = a[j][i];
			for (int k = i; k <= n + 1; k++)
				a[j][k] -= a[i][k] * inv;
		}
	} 
	f[n] = a[n][n + 1];
	for (int i = n - 1; i; --i)
	{
		for (int j = i + 1; j <= n; ++j)
			a[i][n + 1] -= f[j] * a[i][j];
		f[i] = a[i][n + 1] / a[i][i];
	}
}

int main()
{
	scanf ("%d%d", &n, &m);
	for (int i = 1; i <= m; i++)
	{
		int x, y;
		scanf ("%d%d", &x, &y);
		add (x, y), add(y, x);
		deg[x]++, deg[y]++;
	}
	
	for (int i = 1; i < n; i++)
	{
		a[i][i] = 1.0;
		for (int j = head[i]; j; j = e[j].nxt)
		{
			int v = e[j].to;
			if (v != n) a[i][v] -= 1.0 / deg[v];
		}
	}
	a[1][n] = 1;
	
	Gauss (n - 1);
	
	for (int i = 1; i <= m; i++)
		g[i] = f[e[i<<1].from] / deg[e[i<<1].from] + f[e[i<<1].to] / deg[e[i<<1].to];
	sort (g + 1, g + 1 + m);
	for (int i = 1; i <= m; i++)
		ans += g[i] * (m - i + 1.0);
	printf ("%.3lf", ans);
	return 0;
}
```

---

## 作者：tommymio (赞：2)

贪心的想法：经过次数越多的边权值越小，可以使用排序不等式证明。

那么计算出一条边被期望经过的次数 $E[(u,v)]$。而这个次数，可以通过经过 $u$ 的期望次数乘上走 $(u,v)$ 这条边的概率 $+$ 经过 $v$ 的期望次数乘上走 $(u,v)$ 这条边的概率。

一个点可能会被反复走多次，存在后效性，使用约旦-高斯消元法解状态转移方程构成的方程组即可。

手写 $\text{swap}$ 毁一生。~~菜鸡写了一个手写 $\text{swap}$ 临时变量类型是 $\text{int}$~~，结果样例都过不了，哭哭。

```cpp
#include<cmath>
#include<cstdio>
#include<vector>
#include<algorithm>
struct edge {int x,y;} e[125005];
std::vector<int> mp[505];
double f[505],g[120005],a[505][505];
inline int read() {
    register int x=0,f=1;register char s=getchar();
    while(s>'9'||s<'0') {if(s=='-') f=-1;s=getchar();}
    while(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();}
    return x*f;
}
inline void swap(double &x,double &y) {double tmp=x;x=y;y=tmp;}
inline void show(int n) {
    for(register int x=1;x<n;++x) {for(register int i=1;i<=n;++i) printf("%.3lf ",a[x][i]); printf("\n");}
}
int main() {
    int n=read(),m=read();
    double ans=0.00;
    for(register int i=1;i<=m;++i) {
        int x=read(),y=read(); e[i].x=x; e[i].y=y;
        mp[x].push_back(y); mp[y].push_back(x);
    }
    a[1][n]=1.00;
    for(register int x=1;x<n;++x) {
        a[x][x]=1.00; 
        for(register int i=0;i<mp[x].size();++i) {int y=mp[x][i]; if(y!=n) a[x][y]=-1.00/mp[y].size();}
    }
    for(register int i=1;i<n;++i) {
        int tmp=0; 
        for(register int j=i;j<n;++j) if(fabs(a[j][i])>0) {tmp=j;break;}
        for(register int j=1;j<=n;++j) swap(a[i][j],a[tmp][j]);
        for(register int j=1;j<n;++j) {
            if(i==j) continue;
            double t=a[j][i]/a[i][i];
            for(register int k=i;k<=n;++k) a[j][k]-=t*a[i][k];
        }
    }
    for(register int i=1;i<n;++i) f[i]=a[i][n]/a[i][i];//,printf("%.3lf\n",f[i]);
    for(register int i=1;i<=m;++i) {
        if(e[i].x!=n) g[i]+=f[e[i].x]/mp[e[i].x].size();
        if(e[i].y!=n) g[i]+=f[e[i].y]/mp[e[i].y].size();
    }
    std::sort(g+1,g+1+m);
    for(register int i=1;i<=m;++i) ans+=g[i]*(m-i+1);
    printf("%.3lf",ans);
    return 0;
}
```

---

## 作者：Lonely_NewYear (赞：1)

# 洛谷 P3232 题解

## 题目分析

小Z最后获得的总分的期望应为每条边期望被经过的次数乘以这条边的编号，为了使总积分最少，一条边期望被经过的次数越高，分配的编号应该越低。然而边的期望不太好求，考虑把期望转移到点上。

设 $g_{i,j}$ 表示 $i$ 到 $j$ 这条边期望经过的次数， $f_i$ 表示点 $i$ 期望经过的次数，$deg_u$ 表示点 $i$ 的度数，易得：

$g_{u,v}=\frac{f_u}{deg_u}+\frac{f_v}{deg_v}$

（由于到了点 $n$ 就结束了，不会产生贡献，所以 $f_n$ 应该为 $0$。）

现在问题变成了如何求 $f_i$，那么很显然也可以得出：

$f_i=\sum_{(i,j)\in G}\frac{f_j}{deg_j}\qquad \quad 1<i<n$

$f_i=\sum_{(i,j)\in G}\frac{f_j}{deg_j}+1\quad \ i=1$

整理一下就是：

$f_i-\sum_{(i,j)\in G}\frac{f_j}{deg_j}=0\quad \ 1<i<n$

$f_i-\sum_{(i,j)\in G}\frac{f_j}{deg_j}=1\quad \ i=1$

（注意点 $n$ 还是不应该产生贡献。）

这样就列出了 $n-1$ 个方程，高斯消元即可，时间复杂度 $O(n^3)$。

## 代码

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
struct edge
{
	int to,next;
}g[250001];
int cnt,head[501],d[501],fr[125001],to[125001];
double a[500][501],b[501],f[125001];
void add(int u,int v)
{
	g[++cnt]=(edge){v,head[u]};
	head[u]=cnt;
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&fr[i],&to[i]);
		d[fr[i]]++,d[to[i]]++;
		add(fr[i],to[i]),add(to[i],fr[i]);
	}
	for(int u=1;u<n;u++)
	{
		a[u][u]=1;
		for(int i=head[u];i;i=g[i].next)
		{
			int v=g[i].to;
			if(v!=n)a[u][v]=-1.0/d[v];
		}
	}
	a[1][n]=1;
	for(int i=1;i<n;i++)
	{
		int pos=i;
		for(int j=i+1;j<n;j++)
			if(fabs(a[j][i])>fabs(a[pos][i]))
				pos=j;
		swap(a[i],a[pos]);
		for(int j=1;j<n;j++)
		{
			if(i==j)continue;
			double div=a[j][i]/a[i][i];
			for(int k=i;k<=n;k++)
				a[j][k]-=a[i][k]*div;
		}
	}
	for(int i=1;i<n;i++)
		b[i]=a[i][n]/a[i][i];
	for(int i=1;i<=m;i++)
	{
		int u=fr[i],v=to[i];
		f[i]=b[u]/d[u]+b[v]/d[v];
	}
	sort(f+1,f+m+1);
	double ans=0;
	for(int i=1;i<=m;i++)
		ans+=f[i]*(m-i+1);
	printf("%.3lf",ans);
	return 0;
}
```

谢谢观看！

---

## 作者：hzoi_liuchang (赞：1)

## 分析
因为要使获得总分的期望值最小

所以我们肯定要给经过次数少的边赋大权值

但是边的期望经过次数不好直接求

但是我们可以求出点的期望经过次数

边的期望经过次数就是它所连点的期望经过次数除以点的入度再加和

我们设点 $u$ 的期望经过次数为 $f[u]$

那么 $f[u]= \sum_{v-u}f[v]/du[v]$

其中 $du[v]$ 是节点 $v$ 的入度

初始化 $f[n]=1$

要注意的是当 $u=1$ 时，还要把 $f[u]$ 加上 $1$

因为一开始是从 $1$ 号节点出发的

然后就可以高斯消元求解了
## 代码
``` cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<iostream>
#include<queue>
inline int read(){
	int x=0,fh=1;
	char ch=getchar();
	while(ch<'0' || ch>'9'){
		if(ch=='-') fh=-1;
		ch=getchar();
	}
	while(ch>='0' && ch<='9'){
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x*fh;
}
const int maxn=505,maxm=125005;
const double eqs=1e-10;
int n,m,head[maxn],tot=1;
struct asd{
	int from,to,next;
}b[maxm<<1];
void ad(int aa,int bb){
	b[tot].from=aa;
	b[tot].to=bb;
	b[tot].next=head[aa];
	head[aa]=tot++;
}
int du[maxn];
double mp[maxn][maxn],ans[maxn];
void gsxy(){
	int now=1;
	for(int i=1;i<=n;i++){
		double mmax=0;
		int jl;
		for(int j=now;j<=n;j++){
			if(std::fabs(mmax)<std::fabs(mp[j][i])){
				mmax=mp[j][i];
				jl=j;
			}
		}
		if(std::fabs(mmax)<eqs) continue;
		if(jl!=now) std::swap(mp[jl],mp[now]);
		for(int j=i+1;j<=n+1;j++){
			mp[now][j]/=mp[now][i];
		}
		mp[now][i]=1.0;
		for(int j=now+1;j<=n;j++){
			double cs=mp[j][i];
			for(int k=i;k<=n+1;k++){
				mp[j][k]-=mp[now][k]*cs;
			}
		}
		now++;
	}
	ans[n]=mp[n][n+1];
	for(int i=n-1;i>=1;i--){
		ans[i]=mp[i][n+1];
		for(int j=i+1;j<=n;j++){
			ans[i]-=ans[j]*mp[i][j];
		}
	}
}
std::priority_queue<double> q;
int main(){
	memset(head,-1,sizeof(head));
	n=read(),m=read();
	for(int i=1;i<=m;i++){
		int aa,bb;
		aa=read(),bb=read();
		ad(aa,bb);
		ad(bb,aa);
		du[aa]++;
		du[bb]++;
	}
	for(int i=1;i<=n;i++){
		for(int j=head[i];j!=-1;j=b[j].next){
			int u=b[j].to;
			if(u==n) continue;
			mp[i][u]=-1.0/du[u];
		}
	}
	for(int i=1;i<=n;i++){
		mp[i][i]=1;
	}
	for(int i=1;i<n;i++){
		mp[n][i]=0;
	}
	mp[n][n]=1;
	mp[n][n+1]=1;
	mp[1][n+1]=1;
	gsxy();
	for(int i=1;i<tot;i+=2){
		int aa=b[i].from;
		int bb=b[i].to;
		q.push((double)(ans[aa]/du[aa]*(aa!=n)+ans[bb]/du[bb]*(bb!=n)));
	}
	double nans=0;
	for(int i=1;i<=m;i++){
		if(!q.empty()){
			nans+=q.top()*i;
			q.pop();
		}
	}
	printf("%.3f\n",nans);
	return 0;
}
```

---

## 作者：dz_ice (赞：1)

## 题意

   给你一个$n$个点$m$条边的无向连通图从 1 号点出发，每次随机选择当前顶点的某条边走到下一个点，并获得这条边的分数，分数为这条边的编号，一旦到了$n$号点就结束游走，总分为获得分数的总和。安排每条边的编号，使总分的期望值最小，并输出最小的期望值

## 题解
   看完题目能够发现，我们只要求出经过每一条边的期望，再把小的编号安排到期望值大的边上，把大的编号安排到期望值小的边上，就可以使总分的期望值最小

分析一波，发现边的期望值并不好求，但是可以先求出点的期望值

显然,每个点的期望是由相连的点的期望决定的。设$f[x]$为点$x$的期望， $du[x]$为点$x$的度数,点$x1,x2,x3....xk$与点$x$相邻，则$f[x]= \sum_{i=1}^k \frac {f[x_i]}{du[x_i]}$

这样，点的期望值就转化为了一个方程组，这个时候就要用到我们的高斯消元了，不过要注意的是，因为到了点$n$就会停止游走，所以点$n$的期望是不用管的。还有，因为起点为1号点，所以点1的实际期望为原期望+1

接下来要做的就是把点的期望转化为边的期望，每条边的期望都由其连接的两个端点决定，最后排个序，安排一下编号即可

最后上代码

```
#include <bits/stdc++.h>
using namespace std;
const double eps = 1e-8;
double a[503][503], b[503], f[503], chu, ff[1000000], sum, du[503];
int n, m, max1, x, y, bian[1000000], bian1[1000000];
vector<int> l[503];
signed main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i++) {
        scanf("%d%d", &x, &y);
        l[x].push_back(y), l[y].push_back(x), du[x]++, du[y]++, bian[i] = x, bian1[i] = y;
    }
    b[1] = 1;
    for (int i = 1; i < n; i++) {
        a[i][i] = 1.0;
        for (int j = 0; j < l[i].size(); j++)
            if (l[i][j] != n)
                a[i][l[i][j]] += -1.0 / (double)du[l[i][j]];
    }
    for (int i = 1; i < n; i++) {
        max1 = i;
        for (int j = i + 1; j < n; j++)
            if (a[j][i] > a[max1][i])
                max1 = j;
        if (i != max1)
            swap(a[i], a[max1]), swap(b[i], b[max1]);
        for (int j = i + 1; j < n; j++) {
            chu = a[j][i] / a[i][i], b[j] -= b[i] * chu;
            for (int k = i; k < n; k++) a[j][k] -= a[i][k] * chu;
        }
    }
    for (int i = n - 1; i >= 1; i--) {
        f[i] = b[i] / a[i][i];
        for (int j = 1; j < i; j++) b[j] -= a[j][i] * f[i];
    }
    for (int i = 1; i <= m; i++)
        ff[i] = f[bian[i]] / (double)du[bian[i]] + f[bian1[i]] / (double)du[bian1[i]];
    sort(ff + 1, ff + m + 1);
    for (int i = 1; i <= m; i++) sum += ff[i] * (double)(m - i + 1);
    printf("%.3lf", sum);
    return 0;
}
```


   

---

## 作者：Rainybunny (赞：1)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[题目链接](https://www.luogu.org/problem/P3232).
# 题解
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~~一道简单的板题.~~  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先, 设$d(u)$表示$u$的度数, 则对于某条边$<u,v>$, 考虑走过该边的期望, 当然这只与$u$与$v$相关: $E(<u,v>)=\frac{E(u)}{d(u)}+\frac{E(v)}{d(v)}$.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以, 此时的问题成为求走到某个结点的期望, 考察结点$u$, 那么应有$E(u)=\sum_{v,<u,v>\in E}\frac{E(v)}{d(v)}$. 列出方程, 高斯消元即可. 此后, 我们运用贪心的思想, 把期望较大的的边赋较小的权值就行了.
```cpp
#include <cstdio>
#include <vector>
#include <assert.h>
#include <iostream>
#include <algorithm>

#define Int register int
#define Type template<typename _T>

using namespace std;

const double EPS = 1e-8;
const int MAXN = 500, MAXM = MAXN * ( MAXN - 1 ) >> 1;
int n, m, Cnte, Head[MAXN + 5] = {}, d[MAXN + 5] = {};
double a[MAXN + 5][MAXN + 5] = {}, b[MAXN + 5] = {}, x[MAXN + 5] = {};
double E[MAXM + 5] = {};
vector<pair<int, int> > e;

struct Edge {
	int To, _nxt;
} Graph[MAXM << 1 | 1] = {};

Type inline _T Abs ( const _T x ) {
	return x < 0 ? -x : x;
}

inline void Link ( const int From, const int To ) {
	Graph[++ Cnte] = { To, Head[From] };
	++ d[From], Head[From] = Cnte;
}

inline bool Gauss ( const int n ) {
	for ( Int i = 1; i <= n; ++ i ) {
		int p = i;
		for ( Int j = i + 1; j <= n; ++ j ) {
			if ( Abs ( a[j][i] ) > Abs ( a[p][i] )) {
				p = j;
			}
		}
		swap ( a[i], a[p] ), swap ( b[i], b[p] );
		if ( Abs ( a[i][i] ) <= EPS ) return false;
		for ( Int j = i + 1; j <= n; ++ j ) {
			double d = a[j][i] / a[i][i];
			b[j] -= d * b[i];
			for ( Int k = i; k <= n; ++ k ) {
				a[j][k] -= d * a[i][k];
			}
		}
	}
	for ( Int i = n; i; -- i ) {
		for ( Int j = i + 1; j <= n; ++ j ) {
			b[i] -= x[j] * a[i][j];
		}
		x[i] = b[i] / a[i][i];
	}
	return true;
}

inline void Work () {
	scanf ( "%d %d", &n, &m );
	for ( Int i = 1, u, v; i <= m; ++ i ) {
		scanf ( "%d %d", &u, &v );
		Link ( u, v ), Link ( v, u );
		e.push_back ( { u, v } );
	}
	for ( Int i = 1; i ^ n; ++ i ) {
		a[i][i] = 1.0;
		for ( Int j = Head[i], v; j; j = Graph[j]._nxt ) {
			if ( ( v = Graph[j].To ) ^ n ) {
				a[i][v] = -1.0 / d[v];
			}
		}
	}
	b[1] = 1.0;
	assert ( Gauss ( n - 1 ) );
//	for ( Int i = 1; i ^ n; ++ i ) {
//		printf ( "%.2lf\n", x[i] );
//	}
	for ( unsigned int i = 0; i ^ m; ++ i ) {
		int u = e[i].first, v = e[i].second;
		if ( u ^ n ) E[i + 1] += 1.0 * x[u] / d[u];
		if ( v ^ n ) E[i + 1] += 1.0 * x[v] / d[v];
	}
	sort ( E + 1, E + m + 1 );
	double Ans = 0;
	for ( Int i = 1; i <= m; ++ i ) {
		Ans += ( m - i + 1.0 ) * E[i];
	}
	printf ( "%.3lf\n", Ans );
}

int main () {
	Work ();
	return 0;
}
```

---

## 作者：QiFeng233 (赞：0)

# 思路简述
这题有一个显然的贪心：把每条边经过的期望次数求出来，然后排个序，期望大的给他赋成边权小的。

但是求边的期望经过次数不好求啊，我们转变思路来求每个点的期望。设$g_i$为点$i$的期望次数，$deg_i$是点$i$的度数，那么有：

$g_i=\sum\limits_{j \in E(i,j),j\not=n}\dfrac{g_j}{deg_j}$

特殊地，因为我们一开始在一号点，所以$g_1$还要再加1:

$g_1=1+\sum\limits_{j \in E(1,j),j\not=n}\dfrac{g_j}{deg_j}$

之所以$j \not=n$是因为走到点$n$就停下了，所以不可能从$n$点走出来。

然而我们发现这个东西直接展开求不了。怎么办？高斯消元。

之后设$f_i$为第$i$条边的期望经过次数，那么这条边既可以是从起点走向终点，又可以是由终点走向起点，那么显然有：

$f_i=\dfrac{s_i}{g_{s_i}}+\dfrac{e_i}{g_{e_i}}$

其中$s,e$为第$i$条边的起点和终点。

至此，问题解决。
# 代码时间
```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
using std::sort; 
using std::swap;
namespace QiFeng233{
	const int maxn=5e2+10,maxm=5e5+10;
	const double eps=1e-7;
	int n,m,cnt,head[maxn],BG[maxm],ED[maxm],d[maxn];
	double f[maxm],a[maxn][maxn];
	struct edge{
		int to,nxt;	
	}g[maxm];
	void add(int u,int v){
		g[++cnt].to=v;
		g[cnt].nxt=head[u];
		head[u]=cnt;
	}
	void Gauss(int n){
		for(int i=1;i<=n;++i){
			int row=i;
			for(int j=i+1;j<=n;++j){
				if(fabs(a[row][i])<fabs(a[j][i]))
					row=j;
			}
			if(row!=i)swap(a[row],a[i]);
			double div1=a[i][i];
			for(int j=i;j<=n+1;++j)
				a[i][j]/=div1;
			for(int j=i+1;j<=n;++j){
				double div2=a[j][i];
				for(int k=i;k<=n+1;++k){
					a[j][k]-=a[i][k]*div2;
				}
			}
		}
		for(int i=n;i;--i){
			for(int j=n;j>i;--j){
				a[i][n+1]-=a[i][j]*a[j][n+1];
			} 
		} 
	}
	void solve(){
		scanf("%d%d",&n,&m);
		for(int i=1;i<=m;++i){
			int u,v;
			scanf("%d%d",&u,&v);
			add(u,v),add(v,u);
			++d[u],++d[v];
			BG[i]=u,ED[i]=v;
		}
		for(int i=1;i<n;++i){
			a[i][i]=1.0;
			for(int j=head[i];j;j=g[j].nxt){
				int end=g[j].to;
				if(end!=n)a[i][end]=-1.0/(double)d[end];
			}
		}
		a[1][n]=1.0;
		Gauss(n-1);
		for(int i=1;i<=m;++i){
			if(BG[i]!=n)f[i]+=a[BG[i]][n]/(double)d[BG[i]]; 
			if(ED[i]!=n)f[i]+=a[ED[i]][n]/(double)d[ED[i]];
		}
		sort(f+1,f+m+1);
		double ans=0;
		for(int i=1;i<=m;++i)ans+=f[i]*(double)(m-i+1);
		printf("%.3lf",ans);
	}
}
signed main(){
	//freopen("P3232.in","r",stdin);
	QiFeng233::solve();
	return 0; 
}
```
# 反思总结
- 高斯校园在概率题中很常见，是个有力的工具，并且很简单，~~小学二年级就应该学~~（毕导梗）。
- 要灵活转化问题目标，直接求边的期望不好求我们就根据边被经过的时候既可以是起点走向终点，又可以是终点走向起点来求点的期望次数，进而得到边的期望次数。

---

## 作者：寒鸽儿 (赞：0)

[在窝的博客中阅读](https://froldh.github.io/2019/08/28/OI/daily/20190828/[HNOI2013]游走/youzou/)  
[在窝的洛谷博客中阅读](https://www.luogu.org/blog/oldherd/solution-P3232)    
### 分析
在边上的问题比较难解决的往往转化到点上进行。  
在本题中直接对边统计期望大概是没有什么思路的。因此考虑转移到点上进行。  
我们只需要求经过每个点的期望次数,根据走的每条边概率相等的原则,将这个次数平均分配到边上就是边的期望经过次数。  
### 关于转移:  
记$size_i$为结点$i$的度。经过某个结点的事件发生在所有与这个点直接连接的结点$t$由$\frac{1}{size_t}$的概率走到。因此某个点的期望经过次数也由其直接连接的结点的期望经过次数按照这种法则直接转化而来。 
转移方程: $\displaystyle f_i = \sum_{t \in \{t | \exists edge(i, t) \}}f_t * \frac{1}{size_t}$.  
### 边界条件和特殊情况:  
如果到达终点n,将不会继续向其他点转移,因而,$\displaystyle f_i = \sum_{t \in \{t | \exists edge(i, t), t \neq n \}}f_t * \frac{1}{size_t}$。此外,我们的初始局面是站在结点$1$，因而结点$1$的期望经过次数还要多加1,即为$\displaystyle f_1 = \sum_{t \in \{t | \exists edge(1, t),t \neq n \}}f_t * \frac{1}{size_t}+1$。  
### 结论与处理:  
因而我们最终得到的转移式子为:  
$\displaystyle f_i = \sum_{t \in \{t | \exists edge(i, t), t \neq n \}}f_t * \frac{1}{size_t} \qquad (i \neq 1)$  
$\displaystyle f_1 = \sum_{t \in \{t | \exists edge(1, t),t \neq n \}}f_t * \frac{1}{size_t}+1$  
对于没有环形的转移优先考虑dp,对于有环形的转移则可以考虑使用高斯消元来处理。此处当然是高斯消元。复杂度为O($n^3$).  
### 代码:  
```cpp
#include <iostream>
#include  <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>

using namespace std;

const int maxn = 510, maxm = maxn*maxn;
double f[maxn][maxn], s[maxn], e[maxm];
int head[maxn], deg[maxn], ver[maxm<<1], nex[maxm<<1], ut[maxm], vt[maxm], tot, n;

inline void addedge(int u, int v) {
	ver[tot] = v; nex[tot] = head[u]; head[u] = tot++;
}

void gauss() {
	for(int i = 1, k = 1; i <= n; i++, k = i) {
		for(int j = i+1; j <= n; j++) if(fabs(f[j][i])>fabs(f[k][i])) k = j;
		if(i != k) swap(f[i], f[k]); swap(s[i], s[k]);
		for(int j = 1; j <= n; j++) if(i != j) {
			double z = f[j][i] / f[i][i];
			for(int k = i; k <= n; k++) f[j][k] -= z * f[i][k];
			s[j] -= s[i] * z;
		}
	}
}

int main() {
	ios::sync_with_stdio(false); 
	memset(head, -1, sizeof(head));
	double ans = 0;
	int m, u, v;
	cin >> n >> m;
	for(int i = 1; i <= m; i++) {
		cin >> u >> v;
		addedge(u, v); addedge(v, u);
		deg[u]++; deg[v]++; ut[i] = u; vt[i] = v;
	}
	for(int i = 1; i < n; i++) {
		for(int j = head[i]; j != -1; j = nex[j]) if(ver[j] != n)
			f[i][ver[j]] = (double)1 / deg[ver[j]];
		f[i][i] = -1;
	}
	s[1] = -1; s[n] = 1; f[n][n] = 1;
	gauss();
	for(int i = 1; i <= m; i++) {
		if(ut[i] != n) e[i] += s[ut[i]] / f[ut[i]][ut[i]] / deg[ut[i]];
		if(vt[i] != n) e[i] += s[vt[i]] / f[vt[i]][vt[i]] / deg[vt[i]];
	}
	sort(e+1, e+m+1);
	for(int i = 1; i <= m; i++)
		ans += e[i] * (m-i+1);
	printf("%.3f\n", ans);
	return 0;
}
```

---

## 作者：C20203030 (赞：0)

## 一、题目
[点此看题](https://www.luogu.org/problem/P3232)

**题目：**
$n$个点，$m$条边的联通无向图，边的权值从$1$到$m$，一开始在1号点，每次等概率走向当前点的邻接点。问怎么样给边赋值，使得走到$n$号点时期望走过的边权和最小。

**数据范围：**
$2\leq N\leq 500$
## 二、解法
这种等概率走向当前点的邻接点的问题叫**随机游走问题**。

走到$n$号点时期望走过的边数$=$每条边期望走过的次数之和。

边$(u,v)$期望走过次数$=$点$u$期望走过次数除以$u$的度数$+$点$v$期望走过次数除以$v$的度数:

$E(u,v)=E(u)/deg(u)+E(v)/deg(v)$

设$u$和$v$邻接点，再考虑$E(u)$和$E(v)$之间的关系。
对于这道题，我们尝试高斯消元。

因为$E(u)=\sum_{i=1}^{n}\frac{Graph(u)(i)\times E(i)}{deg(i)}$，所以有：

$E(1)=1$

$E(1)$$−$$\sum_{i=1}^{n}$$\frac{Graph(1)(i)\times E(i)}{deg(i)}=0$

$……$

$E(n-1)$$−$$\sum_{i=1}^{n}$$\frac{Graph[n-1][i] \times E(i)}{deg[i]}=0 $

$n$个未知数，$n$个方程，必可解。

得到$E(i)$之后，我们计算$E(u,v)$，把它从大到小排序，把$[1,m]$挨个赋值（贪心），乘上累加即可。

作者口胡完了，如果还有不懂，请看代码。

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#define eps 1e-7
using namespace std;
const int MAXN = 505;
int read()
{
	int x=0,flag=1;char c;
	while((c=getchar())<'0' || c>'9') if(c=='-') flag=-1;
	while(c>='0' && c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return x*flag;
}
int n,m;
bool b[MAXN][MAXN];
double a[MAXN][MAXN],q[MAXN*MAXN],deg[MAXN];
struct edge
{
	int u,v;
}e[MAXN*MAXN];
bool cmp(double a,double b)
{
	return a>b;
}
int main()
{
	n=read();m=read();
	for(int i=1;i<=m;i++)
	{
		int u=read(),v=read();
		b[u][v]=b[v][u]=1;
		e[i]=edge{u,v};
		deg[u]+=1.0;deg[v]+=1.0;
	}
	a[1][n]=1.0;
	for(int i=1;i<n;i++)
	{
		a[i][i]=1.0;
		for(int j=1;j<n;j++)
			if(b[i][j])
				a[i][j]=-1.0/deg[j];
	}
	for(int i=1;i<n;i++)
	{
		int Max=i;
		for(int r=i+1;r<n;r++)
			if(a[r][i]-a[Max][i]>eps)
				Max=r;
		if(i^Max)swap(a[i],a[Max]);
		for(int j=n;j>=i;j--)
			a[i][j]/=a[i][i];
		for(int j=1;j<n;j++)
		{
			if(i==j || !a[j][i]) continue;
			double tmp=a[j][i]/a[i][i];
			for(int k=i+1;k<=n;k++)
				a[j][k]-=a[i][k]*tmp;
			a[j][i]=0;
		}
	}
	for(int i=1;i<=m;i++)
	{
		int u=e[i].u,v=e[i].v;
		if(u^n) q[i]+=a[u][n]*(1.0/deg[u]);
		if(v^n) q[i]+=a[v][n]*(1.0/deg[v]);
	}
	sort(q+1,q+1+m,cmp);
	double ans=0;
	for(int i=1;i<=m;i++)
		ans+=q[i]*i;
	printf("%.3lf",ans);
	return 0;
}
```



---

## 作者：maomao9173 (赞：0)

[更好的阅读体验戳我。](https://www.cnblogs.com/maomao9173/p/10941115.html )

期望$DP$入门题目。

关键思想：无向边的转移作为有向边考虑。其他的就是直接上全期望公式。由于这个题目不是有向无环图，所以需要高斯消元搞一搞。

设每个点的期望经过次数是$g(x)$，那么有

$$g(u) = \sum_{v} \frac{1}{out(v)}*g(v)$$

特殊的，我们认为点$1$有一个一定经过的入边，且不考虑点$n$的所有出边。

这个$g$很好做啊，我们高斯消元搞一搞就好了。那边的期望经过次数$f(x)$也就显而易见。

$$f(x) = \frac{g(u)}{out(u)} + \frac{g(v)}{out(v)}$$

然后这个题就做完了。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 500 + 5;

int n, m, u[N * N], v[N * N], out[N];

vector <int> G[N];

double ans, f[N * N], g[N], mat[N][N];

void gauss_jordan () {
	for (int i = 1; i <= n; ++i) {
		int besti = i;
		for (int j = i; j <= n; ++j) {
			if (fabs (mat[besti][i]) < fabs(mat[j][i])) {
				besti = j;
			}
		}
		if (i != besti) swap (mat[i], mat[besti]);
		for (int j = 1; j <= n; ++j) {
			if (i == j) continue;
			double t = mat[j][i] / mat[i][i];
			for (int k = i; k <= n + 1; ++k) {
				mat[j][k] -= mat[i][k] * t;
			}
		}
	}
	for (int i = 1; i <= n; ++i) {
		g[i] = mat[i][n + 1] / mat[i][i];
	}
}

int main () {
	// freopen ("data.in", "r", stdin);
	cin >> n >> m;
	for (int i = 1; i <= m; ++i) {
		cin >> u[i] >> v[i];
		G[u[i]].push_back (v[i]); if (u[i] != n) out[u[i]]++;
		G[v[i]].push_back (u[i]); if (v[i] != n) out[v[i]]++;
	}
	mat[1][n + 1] = 1;
	for (int u = 1; u <= n; ++u) {
		mat[u][u] = 1;
		for (int i = 0; i < G[u].size (); ++i) {
			int v = G[u][i];
			if (v == n) {
				mat[n][v] = -1.0 / out[v];
			} else {
				mat[u][v] = -1.0 / out[v];
			}
		}
	}
	gauss_jordan ();
	for (int i = 1; i <= m; ++i) {
		if (u[i] != n) f[i] += g[u[i]] / out[u[i]];
		if (v[i] != n) f[i] += g[v[i]] / out[v[i]];
	}
	sort (f + 1, f + 1 + m);
	for (int i = 1; i <= m; ++i) {
		ans += (m - i + 1) * f[i];
	}
	cout << fixed << setprecision (3) << ans << endl;
}

```

---

## 作者：Gypsophila (赞：0)

### Description 

$n$ 个点 $m$ 条边的无向连通图，在上面从 $1$ 号点开始随机游走。现在你可以给每条边从 $1$ 到 $m$ 编号作为分数（经过就得分）。求如何编号使得总分的期望最小。输出这个最小值即可。

$n \leq 500$ 


### Solution 

如果知道了每条边被经过的期望次数，那么根据排序不等式显然是逆序分配最小。

设 $f_u$ 是 $u$ 点被经过的期望次数，$deg_u$ 表示 $u$ 的度数。那么边 $(u, v)$ 被经过的期望次数是 
$$
\frac{f_u}{deg_u}+\frac{f_v}{deg_v}
$$
$f$ 的求法比较简单，即 
$$
f_u = \sum\limits_{(u,v) \in E} \frac{f_v}{deg_v} 
$$
高斯消元一波再排个序就做完了。时间复杂度 $O(n^3)$

### Code

[看代码戳这里](https://acfunction.github.io/2019/03/22/BZOJ3143/)

---

## 作者：tkysss (赞：0)

只要求出每条边的概率

就可以按照概率从大到小贪心编号；

只要求出点的概率设为$dp_i$ , 每个点的度数设为$d_i$

走边(u,v)的概率
$P(u,v) = (u!=n) dp_u / d_u  + (v!=n) dp_v / d_v $

撕烤一下发现，对于$dp_i$,

$i==1 \ \ \ dp_i = 1 + \sum_{\exists:(1,v)}  dp_v / d_v $ 

$i==1 \ \ \ dp_i = \sum_{\exists:(1,v)}  dp_v / d_v $

注意上面的$v!=n$

这样用高斯消元求出来就好；

$O(N^3+2*N^2logN)$
```
#include<bits/stdc++.h>
#define ld long double
#define pb push_back
using namespace std;
const int N=510;
int n,m,x[N*N],y[N*N],d[N];
double a[N][N],p[N*N];
vector<int>g[N];
void gauss(){
	for(int i=1;i<=n;i++){
		int pos=i;ld mn=a[i][i];
		for(int j=i+1;j<=n;j++)if(fabs(a[j][i])>mn)mn=fabs(a[pos=j][i]);
		if(pos!=i)for(int j=i;j<=n+1;j++)swap(a[pos][j],a[i][j]);
		for(int j=n+1;j>=i;j--)a[i][j]/=a[i][i];
		for(int j=1;j<=n;j++)if(i!=j)
		for(int k=n+1;k>=i;k--){
			a[j][k]-=a[i][k]*a[j][i];
		}
	}
}
int main(){
	freopen("bzoj3143.in","r",stdin);
	freopen("bozj3143.out","w",stdout);
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		scanf("%d%d",&x[i],&y[i]);
		g[x[i]].pb(y[i]);
		g[y[i]].pb(x[i]);
		d[x[i]]++,d[y[i]]++;
	}
	for(int i=1;i<=n;i++){
		a[i][n+1]=(i==1)?-1:0;
		a[i][i]=-1;
		for(int j=0;j<(int)g[i].size();j++){
			int v = g[i][j];
			if(v!=n)a[i][v]=1.0/d[v];
		}
	}
	gauss();
	for(int i=1;i<=m;i++){
		if(x[i]!=n)p[i]+=a[x[i]][n+1]/d[x[i]];
		if(y[i]!=n)p[i]+=a[y[i]][n+1]/d[y[i]];
	}
	sort(p+1,p+m+1);
	ld ans=0;
	for(int i=1;i<=m;i++){
		ans += (m-i+1) * p[i];
	}
	printf("%.3Lf\n",ans);
	return 0;
}

```


---


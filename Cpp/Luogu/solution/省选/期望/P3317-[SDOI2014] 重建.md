# [SDOI2014] 重建

## 题目描述

T 国有 $N$ 个城市，用若干双向道路连接。一对城市之间至多存在一条道路。    

在一次洪水之后，一些道路受损无法通行。虽然已经有人开始调查道路的损毁情况，但直到现在几乎没有消息传回。    

幸运的是，此前 T 国政府调查过每条道路的强度，现在他们希望只利用这些信息估计灾情。具体地，给定每条道路在洪水后仍能通行的概率，请计算仍能通行的道路恰有 $N-1$ 条，且能联通所有城市的概率。


## 说明/提示

$1<N\leq 50$。

数据保证答案非零时，答案不小于 $10^{-4}$。


## 样例 #1

### 输入

```
3
0 0.5 0.5
0.5 0 0.5
0.5 0.5 0```

### 输出

```
0.375```

# 题解

## 作者：y2823774827y (赞：81)




## 做法

我们都知道(其实我是刚知道的)，矩阵树求的是：$\sum\limits_{T}\prod\limits_{e \in T}p_e$

而这题求的是：$\sum\limits_{T}(\prod\limits_{e\in T}p_e \prod\limits_{e\notin T} (1-p_e))$

通俗地将：枚举每个树，属于这个树边出现的概率$×$非树边出现的概率

$$\sum\limits_{T}(\prod\limits_{e\in T}p_e \prod\limits_{e\notin T} (1-p_e))$$

$$=\sum\limits_{T}(\prod\limits_{e\in T}p_e \frac{\prod_{e}(1-P_e)}{\prod_{e\in T}(1-P_e)})$$
$$=\prod\limits_{e}(1-p_e)(\sum\limits_{T}\prod\limits_{e\in T}\frac{pe}{(1-pe)})$$

化成标准形式套膜拜就好了

## [Code](https://www.cnblogs.com/y2823774827y/p/10266614.html)

---

## 作者：玫葵之蝶 (赞：32)

没人发题解？那我就来水一篇（逃）

首先，大家应该都能看出来这是矩阵树定理，然后大部分人应该就会把概率直接带进去算，然后就愉快地WA掉了（我当时就是这么想的，幸亏没交）

然后就来讲这个题的正解思路。

首先我们来看答案应该是怎样的：

$$ans=\sum_{Tree}\prod_{(u,v)\in E} P_{(u,v)}\prod_{(u,v)\notin E}\big(1-P_{(u,v)}\big)$$然后我们来想一下怎么来构造这个答案：首先，我们直接矩阵树用高斯算出来的结果应该是这个：

$$now=\sum_{Tree}\prod_{(u,v)\in E} P_{(u,v)}$$那我们怎么让它变成答案那个样子呢？直观地，我们可以这样：

$$now=now*\prod_{(u,v)}\big(1-P_{(u,v)}\big)$$然后就变成了这样子：

$$now=\sum_{Tree}\prod_{(u,v)\in E} P_{(u,v)}*\big(1-P_{(u,v)}\big)\prod_{(u,v)\notin E}\big(1-P_{(u,v)}\big)$$现在我们发现now与答案有着中间那一部分的差距，那么如何消除那个差距呢？

我们可以注意到式子中的第一个$P_{(u,v)}$其实就是矩阵的初值，那么也就是这个：

$$now=\sum_{Tree}\prod_{(u,v)\in E} A_{u,v}*\big(1-P_{(u,v)}\big)\prod_{(u,v)\notin E}\big(1-P_{(u,v)}\big)$$那么我们现在就是要让：

$$A_{u,v}*\big(1-P_{(u,v)}\big)\to P_{(u,v)}$$想必我说到现在大家应该就懂了吧，我们只要这样：

$$A_{u,v}=\frac {P_{(u,v)}}{\big(1-P_{(u,v)}\big)}$$这样我们现在的now值就是答案了！

$$tmp=\prod_{(u,v)}\big(1-P_{(u,v)}\big)$$ $$now=tmp*\sum_{Tree}\prod_{(u,v)\in E} \frac {P_{(u,v)}}{\big(1-P_{(u,v)}\big)}$$

还有就是几个技巧：

当矩阵中出现$|a|<eps$时就$a=eps$
当矩阵中出现$|1-a|<eps$时就$a=1-eps$
自己想一想为什么。

看我打公式这么辛苦，就来[我的blog](http://blog.csdn.net/stone41123/article/details/78050473)看看吧^\_^

代码如下：

```cpp
/**************************************************************
    Problem: 3534
    User: stone41123
    Language: C++
    Result: Accepted
    Time:16 ms
    Memory:1308 kb
****************************************************************/
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int n;
double a[51][51];
double ans;
double eps=1e-8;
void gauss(){
    for(int i=1;i<n;i++){
        int mx=i;
        for(int j=i+1;j<n;j++){
            if(fabs(a[j][i])>fabs(a[mx][i]))mx=j;
        }
        if(mx!=i)for(int j=1;j<n;j++)swap(a[i][j],a[mx][j]);
        for(int k=i+1;k<n;k++){
            double mul=a[k][i]/a[i][i];
            for(int j=i;j<n;j++){
                a[k][j]-=a[i][j]*mul;
            }
        }
        if(fabs(a[i][i])<eps){
            ans=0;
            return;
        }
    }
    for(int i=1;i<n;i++){
        ans*=a[i][i];
    }
    ans=fabs(ans);
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            scanf("%lf",&a[i][j]);
        }
    }
    ans=1;
    double tmp=1;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            if(fabs(a[i][j])<eps)a[i][j]=eps;
            if(fabs(1.0-a[i][j])<eps)a[i][j]=1-eps;
            if(i<j)tmp*=1.0-a[i][j];
            a[i][j]=a[i][j]/(1.0-a[i][j]);
        }
    }
    for(int i=1;i<=n;i++){
        a[i][i]=0;
        for(int j=1;j<=n;j++){
            if(i!=j)
            a[i][i]-=a[i][j];
        }
    }
    gauss();
    ans*=tmp;
    printf("%.10lf",ans);
    return 0;
}
```

---

## 作者：Kelin (赞：19)

### 题意

每条边都有一定概率$p\in[0,1]$出现在图中,求生成一棵树的概率是多少

---

### 题解

可以想一个简单的暴力枚举所有树$T$,然后

$$Ans=\sum_T\prod_{e\in T}p_e\prod_{e\notin T}(1-p_e)$$

题目中要问的生成树的概率,既然是生成树那么想一想应该要用到矩阵树定理来求

根据基尔霍夫矩阵的[定义](https://baike.baidu.com/item/%E5%8F%98%E5%85%83%E7%9F%A9%E9%98%B5-%E6%A0%91%E5%AE%9A%E7%90%86?fr=aladdin)我们可以知道他任意一个代数余子式是**所有生成树的边权积的和** 

~~说人话就是求的~~

$$\sum_T\prod_{e\in T}w_e$$

和上面要求的长得好像,但是后面那一坨怎么办?

考虑到

$$\prod_{e\notin T}(1-p_e)=\frac{\prod_e(1-p_e)}{\prod_{e\in T}(1-p_e)}$$

把这个带回去就得到了

$$Ans=\prod_e(1-p_e)\sum_T\prod_{e\in T}\frac{p_e}{1-p_e}$$

于是我们就可以令$w_e=\frac{p_e}{1-p_e}$然后用高斯消元求一遍行列式再乘上前面那一坨就好了

要是$p_e=1$怎么办$?$

考虑到$\frac1{1-p_e}\to\infty$又有$\frac1\epsilon\approx\infty$所以近似令$p_e=1-\epsilon$就好了

```
#include<bits/stdc++.h>
#define fp(i,a,b) for(register int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(register int i=a,I=b-1;i>I;--i)
#define go(u) for(register int i=fi[u],v=e[i].to;i;v=e[i=e[i].nx].to)
#define file(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
template<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}
template<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}
using namespace std;
const int N=55;
const double eps=1e-8;
typedef double d;
int n;d prod=1,G[N][N];
inline int cmp(double x){return fabs(x)<eps?0:(x<0?-1:1);}
inline d det(int n){
    int mx;d t,tp=1;
    fp(i,1,n){mx=i;
        fp(j,i+1,n)if(cmp(G[mx][i]-G[j][i])<0)mx=i;
        if(mx^i)fp(j,i,n)swap(G[i][j],G[mx][j]);
        if(!G[i][i])return 0;
        fp(j,i+1,n){
            t=G[j][i]/G[i][i];
            fp(k,i,n)G[j][k]-=G[i][k]*t;
        }tp*=G[i][i];
    }
    return fabs(tp);
}
int main(){
    #ifndef ONLINE_JUDGE
        file("s");
    #endif
    scanf("%d",&n);
    fp(i,1,n)fp(j,1,n){
        scanf("%lf",G[i]+j);
        if(i==j)continue;
        if(G[i][j]>1-eps)G[i][j]-=eps;
        if(i<j)prod*=(1-G[i][j]);
        G[i][j]/=(1-G[i][j]);
    }
    fp(i,1,n)fp(j,1,n)if(i^j)
        G[i][i]+=G[i][j],G[i][j]=-G[i][j];
    printf("%.8lf\n",det(n-1)*prod);
return 0;
}
```

---

## 作者：wwlw (赞：13)

[Link](https://www.luogu.com.cn/problem/P3317)
----------------

### Description
一个 $n$ 个点的图 $G$，每两个点之间都有一个概率 $p_{i,j}$ 存在一条边。求存在生成树的概率。

### Solution

对于一个特定的生成树 $T$，其边集为 $E$，那么生成它的概率就是
$$\prod_{e\in E} p_e \prod_{e'\notin E} (1-p_{e'})$$
即出现树边的概率积乘上不出现非树边的概率积。那么所有生成树的概率就是
$$\sum_{T} \prod_{e\in E} p_e \prod_{e'\notin E} (1-p_{e'})$$
但是这并不能直接套 Matrix-tree 。考虑到 Matrix-tree 求的是所有生成树的边权积之和，所以需要想办法将后面的式子化成边权积。不难发现，如果把边权设成 $\frac{p_e}{1-p_e}$ 就能很好的解决这个问题。答案即为
$$\prod_{e} (1-p_e)\sum_{T} \prod_{e\in E} \frac{p_e}{1-p_e}$$
还有一个问题，对于一条边，其出现的概率可能是 1。这就直接导致了分母为 0，除法会出问题。一开始想的是有没有什么做法可以求给定确定边的生成树个数，然后后面放弃了……转而回来想先前的做法。主要问题在于不能除 0，然后我非常灵性地对所有数加了一个 $eps=10^{-10}$ ……竟一发过了。

复杂度 $O(n^3)$

```cpp
#include<stdio.h>
#define N 53
#define eps 1e-10

int n;
double a[N][N];
int main(){
	scanf("%d",&n);
	double ans=1;
	for(int i=1;i<=n;i++)
    	for(int j=1;j<=n;j++){
        	double x;
        	scanf("%lf",&x);
        	x+=eps;
        	if(i!=j) a[i][j]=-x/(1-x),a[i][i]+=x/(1-x);
        	if(i<j) ans*=(1-x);
        }
	for(int i=2;i<=n;i++){
    	for(int j=i+1;j<=n;j++){
        	double t=a[j][i]/a[i][i];
        	for(int k=i;k<=n;k++)
            	a[j][k]-=a[i][k]*t;
        }
    	ans*=a[i][i];
    }
	printf("%.4lf",ans);
}
/*
3
0 0.5 0.5
0.5 0 0.5
0.5 0.5 0
*/
```

---

## 作者：_ctz (赞：9)

[Blog](https://ctz45562.github.io/2019/12/17/%E6%B4%9B%E8%B0%B7-P3317-SDOI2014-%E9%87%8D%E5%BB%BA/)

[传送门](https://www.luogu.com.cn/problem/P3317)

只有我是暴力缩点搞的吗。。。

令$E$为生成树边集，显然我们要求的就是$\sum\limits_E\left(\prod\limits_{e\in E}p_e\prod\limits_{e\notin E}(1-p_e)\right)$

令$P=\prod(1-p_e)$，即原图所有边的$1-p_e$之积。上面的式子就成了$P\sum\limits_E\left(\prod\limits_{e\in E}\dfrac{p_e}{1-p_e}\right)$

直接变元矩阵树定理搞它就完事了。。。吗？

若$p_e=1$，会出现分母为$0$的情况。其他题解里都是改为$1-eps$，精度误差可以接受。

没想到于是暴力缩点。$p_e=1$说明生成树中一定有这条边，用并查集缩成一个点。

对于两端点在同一并查集的$e$，若$p_e\neq 1$，当成自环不用管它；若$p_e=1$，说明一定会出来一个环，输出`0`。然而我一开始没判过了，大概是数据水了。

代码：

``` cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>

#define maxn 55
#define inf 0x3f3f3f3f

using namespace std;

inline int read(){
	int x=0,y=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return y?-x:x;
}
double a[maxn][maxn],e[maxn][maxn];
int cnt,fa[maxn],id[maxn];
inline void add(int x,int y,double l){a[x][x]+=l,a[y][y]+=l,a[x][y]-=l,a[y][x]-=l;}
int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}
double Gauss(){
	double ans=1.0;
	for(register int i=2;i<=cnt;++i){
		int t=i;
		for(register int j=i+1;j<=cnt;++j)if(fabs(a[j][i])>fabs(a[t][i]))t=j;
		if(t!=i)swap(a[t],a[i]),ans=-ans;
		for(register int j=i+1;j<=cnt;++j)
			for(register int k=cnt;k>=i;--k)
				a[j][k]-=a[i][k]*a[j][i]/a[i][i];
		ans*=a[i][i];
	}
	return ans;
}
int main(){
	int n=read();
	double P=1.0;
	for(register int i=1;i<=n;++i)fa[i]=i;
	for(register int i=1;i<=n;++i)
		for(register int j=1;j<=n;++j){
			scanf("%lf",&e[i][j]);
			if(i<j&&e[i][j]==1.0){
				int u=find(i),v=find(j);
				if(u==v){puts("0.000000");return 0;}
				fa[u]=v;
			}
		}
	for(register int i=1;i<=n;++i){
		if(!id[find(i)])id[find(i)]=++cnt;
		id[i]=id[find(i)];
	}
	for(register int i=1;i<=n;++i)
		for(register int j=1;j<=n;++j)
			if(i<j&&e[i][j]!=1.0)add(id[i],id[j],e[i][j]/(1.0-e[i][j])),P*=1.0-e[i][j];
	printf("%.8lf\n",Gauss()*P);
}
```


---

## 作者：_WA自动机 (赞：4)

本文同步发表于[我的个人博客](https://wa-automaton.github.io/2019/03/07/BZOJ3534/)qwq

# 题目大意：
你有一个无向完全图。在一场洪水（？）以后，每条边都可能会损毁。给定每条边没有被损毁的概率，求最后剩下的边正好组成原来的图的一棵生成树的概率。

# 分析
设一条边$w$损毁的概率为$E(w)$。由题意，我们要求的其实是
$$\sum_{T \ is \ a \ spanning \ tree \ of \ G}\prod_{e\in T}E(e)\prod_{e\in \complement_G^T}(1-E(e))\ \ \ (*)$$
把这个柿子写出来，我们发现它很像变元矩阵树定理..所以考虑怎么化成矩阵树定理的形式.  
我们是要把它化为$\sum_T \prod_{e\in T} w(e)$的形式...那么必须把后面一项向T中的边靠拢。怎么做呢？  
我们将后面一个连乘柿子变换一下形式...
$$\prod_{e\in \complement_G^T}(1-E(e))=\prod_{e \in G}(1-E(e))*\prod_{e \in T}\frac{1}{(1-E(e))}$$
则..
$$(*)=\prod_{e \in G}(1-E(e)) *\sum_T \prod_{e\in T}\frac{E(e)}{1-E(e)} $$
这就是矩阵树定理板子了..
注意一个细节：当概率等于1的时候，我们会算出来nan..于是我想缩点...其实并不需要复杂的分类讨论、缩点之类的，只需要将1减去一个eps就行了。造成的精度误差不会太大的^_^。
然后我们就珂以愉快地AC辣！
# 参考代码
```cpp
#include <cstdio>
#include <cmath>
#include <algorithm>

using std::swap;
using std::fabs;

const int maxn=1e3+1;
const double eps=1e-6;

double G[maxn][maxn];

inline double determinant(double (*A)[maxn],int n)
{
    for (int i=1,c=1,j;i<=n;++i)
    {
        for (j=c;j<=n && fabs(A[j][i])<eps;++j);
        if (j==n+1) continue;
        for (int k=1;k<=n;++k) swap(A[c][k],A[j][k]);
        for (int j=c+1;j<=n;++j)
            if (fabs(A[j][i])>eps)
            {
                double t=A[j][i]/A[c][i];
                for (int k=i;k<=n;++k)
                    A[j][k]-=A[c][k]*t;
            }
        ++c;
    }
    double ans=1;
    for (int i=1;i<=n;++i) ans*=A[i][i];
    return fabs(ans);
}

int main()
{
    int n;
    scanf("%d",&n);
    for (int i=1;i<=n;++i)
        for (int j=1;j<=n;++j)
        {
            scanf("%lf",&G[i][j]);
            if (G[i][j]==1) G[i][j]-=eps;
        }
    double prod=1;
    for (int i=1;i<=n;++i)
        for (int j=1;j<i;++j)
            prod*=1-G[i][j];
    for (int i=1;i<=n;++i)
        for (int j=1;j<=n;++j)
            if (i!=j) G[i][j]=G[i][j]/(1-G[i][j]),G[i][i]+=G[i][j],G[i][j]=-G[i][j];
    printf("%.10lf",prod*determinant(G,n-1));// BZOJ SPJ好像挂了，必须输出10位小数才能过...
}
```

---

## 作者：NashChen (赞：1)

# 题解 P3317[SDOI2014] 重建

## 【题意简述】

给定一个图，每条边有一定的概率被选中，求选中的所有边恰好组成一个原图的生成树的概率。

结点数$N\leq 50$

## 【分析】

为了做这道题，我们应该先了解无向图的矩阵树定理

可以移步我的博客 [矩阵树定理](https://www.luogu.com.cn/blog/NashChen/matrix-tree)

行列式的计算可以看 [线性代数总结2](https://www.luogu.com.cn/blog/NashChen/linear-algebra-2)

首先，经过简单的推广，矩阵树定理描述的是这样的结论

设无向图$G$的邻接矩阵为$E$，基尔霍夫矩阵为$K_G$，图$G$的所有生成树为$\{Tree_i\}$

$$|K_G|=\sum\limits_i(\prod\limits_{e\in Tree_i}e)$$

也就是说，$K_G$描述了$G$生成图有生成树的概率。也就是说描述了生成图至少是一棵树的概率。

但题目问的是生成图恰好是生成树的概率。这要求多余的边不生成。

也就是说，答案式子是这样的

$$Ans=\sum\limits_i[\prod\limits_{e_1\in Tree_i}e_1\prod\limits_{e_2\in\complement_G Tree_i}(1-e_2)]$$

然而矩阵树定理并不能处理生成树之外的边

于是我们想到了一个办法

$$Ans=\sum\limits_i\{[\prod\limits_{e\in Tree_i}e]\frac{\prod\limits_{e\in G}(1-e)}{\prod\limits_{e\in Tree_i}(1-e)}\}$$

$$=\prod\limits_{e\in G}(1-e)\sum\limits_i\frac{\prod\limits_{e\in Tree_i}e}{\prod\limits_{e\in Tree_i}(1-e)}$$

$$=\prod\limits_{e\in G}(1-e)[\sum\limits_i(\prod\limits_{e\in Tree_i}\frac{e}{1-e})]$$

只要将每条边的权值修改为$\frac{e}{1-e}$，计算新图的基尔霍夫矩阵的行列式$|K_{G'}|$,答案就是$|K_{G'}|\prod\limits_{e\in G}(1-e)$，注意$\prod\limits_{e\in G}(1-e)$应该提前算出来

## 【代码】

代码实现里有一个小问题，就是如果一条边必定会生成，那么$1-e=0$，不能作除数。这里只需要将必定生成当作无限接近$1$，即$1-eps$的概率生成，必定不生成改为无限小概率$eps$生成。这样就能继续运算并且在精度内不影响结果。

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;

const double eps=1e-8;
const int MAXN=105;
int N;
double edge[MAXN][MAXN],ans=1.0;

void rowswap(int i,int j){
	if(i==j) return;
	for(int k=1;k<=N;k++)
		swap(edge[i][k],edge[j][k]);
	return;
}

void rowcomb(int i,int j,double c){
	if(i==j) return;
	for(int k=1;k<=N;k++)
		edge[i][k]-=c*edge[j][k];
	return;
}

double calcdet(){
	double res=1.0,tag=1.0;
	for(int i=1;i<=N;i++){
		int maxr=i;
		for(int j=i+1;j<=N;j++)
			if(fabs(edge[j][i])-fabs(edge[maxr][i])>eps)
				maxr=j;
		if(i!=maxr) tag=-tag;
		rowswap(i,maxr);
		if(fabs(edge[i][i])<eps) return 0.0;
		for(int j=1;j<=N;j++)
			if(i!=j) rowcomb(j,i,edge[j][i]/edge[i][i]);
	}
	for(int i=1;i<=N;i++)
		res*=edge[i][i];
	return tag*res;
}

void Input(){
	scanf("%d",&N);
	for(int i=1;i<=N;i++)
		for(int j=1;j<=N;j++){
			scanf("%lf",&edge[i][j]);
			if(i<j) ans*=(1-edge[i][j]+eps);
		}
	for(int i=1;i<=N;i++)
		for(int j=1;j<=N;j++)
			edge[i][j]/=(1-edge[i][j]+eps);
	for(int i=1;i<=N;i++)
		for(int j=1;j<=N;j++)
			if(i!=j)
				edge[i][i]-=edge[i][j];
	for(int i=1;i<=N;i++)
		for(int j=1;j<=N;j++)
			edge[i][j]=-edge[i][j];
	return;
}
int main(){
	Input();
	N--;
	ans*=calcdet();
	printf("%lf\n",ans);
	return 0;
}
```

---

## 作者：_Ponder_ (赞：1)

[重建](https://www.luogu.com.cn/problem/P3317)

### 题目大意

给定一张无向图，第 $i$ 条边存在的概率为 $p_i$，求这个无向图是一颗树的概率。

### 思路分析

所求即为：

$$\sum_{T}\Bigg(\prod_{e\in T}p_e\Bigg)\Bigg(\prod_{e\not \in T}(1-p_e)\Bigg)$$

其中，$T$ 是一个边集，当 $T$ 中的边均存在时且其他边均不存在时，原图构成一颗树。

解释一下：枚举每一颗树，对每一颗树出现的概率求和，而一颗树出现当且仅当所有属于树的边均出现且所有不属于树的边均不出现。

发现这个东西长的很像矩阵树定理的形式，对比一下，矩阵树定理求的是

$$\sum_{T}\prod_{e\in T}w_e$$

也就是图的所有生成树的边权之积的和。

考虑转化一下：

$$\begin{aligned}\sum_{T}\Bigg(\prod_{e\in T}p_e\Bigg)\Bigg(\prod_{e\not \in T}(1-p_e)\Bigg)&=\sum_{T}\Bigg(\prod_{e\in T}p_e\Bigg)\Bigg(\frac{\prod (1-p_e)}{\prod_{e\in T}(1-p_e)}\Bigg)\\&=\Bigg(\prod (1-p_e)\Bigg)\sum_{T}\Bigg(\prod_{e\in T}\frac{p_e}{1-p_e}\Bigg)\end{aligned}$$

故只需要对于每条边，将边权设为 $\frac{p_i}{1-p_i}$，再用矩阵树定理跑一遍，最后乘上前面的那个积就可以了。

注意，可能存在 $p_i=1$ 的情况，这时可以将边权微调，比如设为 $1-\text{eps}$，这样对结果的影响在可接受精度之内。

### 代码

```cpp
#include <iostream>
#include <cstring>
#include <cmath>
#include <cstdio>
#include <algorithm>

using namespace std;
const int N=55;
#define eps 1e-8

int n;

double a[N][N],w[N][N],prod=1;

double solve(){
    double ans=1,f=1;
    for(int i=2;i<=n;i++)
        for(int j=i+1;j<=n;j++){
            while(a[i][i]>eps){
                double div=a[j][i]/a[i][i];
                for(int k=2;k<=n;k++)
                    a[j][k]-=div*a[i][k];
                swap(a[i],a[j]);f=-f;
            }
            swap(a[i],a[j]);f=-f;
        }
    for(int i=2;i<=n;i++) ans=ans*a[i][i];
    return ans;
}

void add(int u,int v,double w){
    a[u][u]+=w;a[v][v]+=w;
    a[u][v]-=w;a[v][u]-=w;
}

int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++){
            scanf("%lf",&w[i][j]);
            if(i<=j) continue;
            if(w[i][j]>1-eps) w[i][j]=1-eps;//微调
            prod*=1-w[i][j];
            w[i][j]=w[i][j]/(1-w[i][j]);
            add(i,j,w[i][j]);
        }
    printf("%.5lf\n",prod*solve());
    return 0;
}
```

---

## 作者：TonyYin (赞：0)

## $\rm{Description}$

给定无向图，每条边以 $p_i$ 的概率存在。求存在的边构成一棵生成树的概率。

点数 $2\leq N\leq 50$，无重边。

## $\rm{Solution}$

前置知识：[矩阵树定理 - OI Wiki](http://oi-wiki.com/graph/matrix-tree/)，[行列式计算 - OI Wiki](http://oi-wiki.com/math/gauss/#_12)，题解同步发表于 [TonyYin's Blog](https://www.tonyyin.top/2021/08/luogu-p3317/)。

看到 $N\leq 50$ 的范围和生成树，容易想到**矩阵树定理**。

### 矩阵树定理

对于一个无向图 $G$，设边 $e_i=(u_i, v_i)$，其边权为 $v_i = w(u_i, v_i)$.

定义邻接矩阵 $A$，$A_{i, j}=w(i, j)$.

定义度数矩阵 $D$，$D_{i, i}=\operatorname{deg}_{i}$，存储每个点的度数。

定义基尔霍夫矩阵 $L$ ，$L=D-A$.

任取 $i\in[1, N]$，将基尔霍夫矩阵删去第 $i$ 行和第 $i$ 列，构成一个 $(N-1)\times (N-1)$ 的子矩阵，不妨记为 $L'$.

根据无向图的矩阵树定理，有：
$$
\det L' = \sum_{T}{\prod_{e\in T}v_e}
$$
对矩阵 $L'$ 计算行列式，得到的**结果即为：每棵生成树中，所有边权乘积的和**。

### 分析

由概率的性质，我们最终求的答案可以表示为：
$$
\operatorname{Ans}=\sum_T[{\prod_{e\in T}p_e \prod_{e\notin T}(1-p_e)}]
$$
这里一定不要忘记乘上：$\prod_{e\notin T}(1-p_e)$.

注意到 $\operatorname{Ans}$ 的表示式与矩阵树定理很像，考虑如何将其转化成矩阵树定理的标准形式。

要转化为标准形式，我们需要去掉 $\prod_{e\notin T}$ 这个部分，具体转化步骤：

$$
\begin{aligned}
\operatorname{Ans}&=
\sum_T[{\prod_{e\in T}p_e \prod_{e\notin T}(1-p_e)}]\\
&=\sum_T[{\prod_{e\in T}p_e \frac{\prod_{e}{(1-p_e)}}{\prod_{e\in T}(1-p_e)}}]\\
\end{aligned}
$$

注意到分子部分为常数，于是：

$$
\begin{aligned}
\operatorname{Ans}&=
\sum_T[{\prod_{e\in T}p_e \frac{\prod_{e}{(1-p_e)}}{\prod_{e\in T}(1-p_e)}}]\\
&=\prod_{e}{(1-p_e)}\sum_T{\prod_{e\in T}\frac{p_e}{1-p_e}}\\
\end{aligned}
$$

这样，只需要将边权定为 $\dfrac{p_e}{1-p_e}$，之后利用矩阵树定理求解即可。

## $\rm{Code}$

实现时，为了防止边权的分母为 $0$，若 $p_e=1$，将 $p_e\leftarrow p_e+\varepsilon$ 即可避免问题发生。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 100;
const double eps = 1e-10;
int n;
double g[MAXN][MAXN], A[MAXN][MAXN];
double det() {
	for(int col = 2; col <= n; col++) {
		int max_row = col;
		for(int i = col + 1; i <= n; i++)
			if(A[i][col] > A[max_row][col]) max_row = i;
		if(max_row != col) swap(A[col], A[max_row]);
		for(int row = col + 1; row <= n; row++) {
			double t = A[row][col] / A[col][col];
			for(int i = 2; i <= n; i++) {
				A[row][i] -= A[col][i] * t;
			}
		}
	}
	double ans = 1.0;
	for(int i = 2; i <= n; i++) ans *= A[i][i];
	return ans;
}
int main() {
	scanf("%d", &n);
	double prod = 1.0;
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= n; j++) {
			scanf("%lf", &g[i][j]); g[i][j] -= eps;
			A[i][j] -= g[i][j] / (1.0 - g[i][j]);
		}
	}
	for(int i = 1; i <= n; i++) {
		for(int j = i + 1; j <= n; j++) {
			A[i][i] += g[i][j] / (1.0 - g[i][j]);
			A[j][j] += g[i][j] / (1.0 - g[i][j]);
			prod *= (1.0 - g[i][j]);
		}
	}
	cout << prod * det() << endl;
	return 0;
}
```

---

## 作者：楠枫 (赞：0)

## 题解
**前置芝士**：深度理解的矩阵树定理

矩阵树定理能求生成树个数的原因是，它本质上求的是：
$$
\sum_T \prod_{e\in T} w_e
$$
其中 $w_e$ 是边权，那么我们会发现其实当边权是 $1$ 时，本式所求即为生成树个数。

那么回到这题来，这题让求的是
$$
\sum_{T}\prod_{e\in T}w_e\prod_{e\notin T}(1-w_e)
$$
很容易看出来，这个式子和上面矩阵树的式子很像。让我们来推一波。
$$
(\sum_T \prod_{e\in T} w_e) × \prod_{e}w_e=\sum_T\prod_{e\in T}w_e(1-w_e)\prod_{e\notin T}(1-w_e)
$$
此式和上面答案更近了一步，我们只需把 $\prod_{e\in T}(1-w_e)$ 消掉即可。

显然
$$
w_e=(1-w_e)×\frac{w_e}{1-w_e}
$$
所以，我们要求的就是 $\sum_{T}\prod_{e\in T}\frac{w_e}{1-w_e}$　

于是我们在初始化 $Laplace$ 矩阵时直接以 $\frac{w_e}{1-w_e}$ 为边权。

有一个需要注意的地方，因为 $w_e\in [0,1]$，而 $w_e$ 为分子，当 $w_e=0$ 是，原式趋于无穷小，所以我们可以将其赋为 $eps$ ，在分母上的 $1-w_e$ 则反过来，若 $w_e=1$ 则原式趋于无穷大，所以可以赋其为 $1-eps$ 。

至于为什么这样，是为了防止式子在计算机中浮点数例外。

$AC\kern 0.5emCODE:$
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#define ri register signed
#define p(i) ++i
using namespace std;
namespace IO{
    char buf[1<<21],*p1=buf,*p2=buf;
    #define gc() p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++
    inline int read() {
        ri x=0,f=1;char ch=getchar();
        while(ch<'0'||ch>'9') {if (ch=='-') f=-1;ch=getchar();}
        while(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
        return x*f; 
    }
}
using IO::read;
namespace nanfeng{
    #define cmax(x,y) ((x)>(y)?(x):(y))
    #define cmin(x,y) ((x)>(y)?(y):(x))
    #define FI FILE *IN
    #define FO FILE *OUT
    typedef double db;
    static const int N=55;
    static const db eps=1e-8;
    db G[N][N],ans=1.0,tmp=1.0;
    int n;
    inline void Gauss() {
        int tr=0;
        for (ri i(1);i<=n;p(i)) {
            int k=i;
            for (ri j(i+1);j<=n;p(j)) if (fabs(G[j][i])>fabs(G[k][i])) k=j;
            if (k!=i) swap(G[i],G[k]),tr^=1;
            // for (ri j(1);j<=n;p(j)) printf("%.8lf ",G[i][j]);
            // puts("");
            for (ri j(i+1);j<=n;p(j)) {
                db tmp=G[j][i]/G[i][i];
                for (ri l(i);l<=n;p(l)) G[j][l]-=tmp*G[i][l];
            }
            if (fabs(G[i][i])<eps) {ans=0;return;} 
            ans=ans*G[i][i];
            // printf("ans=%.10lf G[i][i]=%.10lf\n",ans,G[i][i]);
        } 
        if (tr) ans=-ans;
    }
    inline int main() {
        // FI=freopen("nanfeng.in","r",stdin);
        // FO=freopen("nanfeng.out","w",stdout);
        n=read();
        for (ri i(1);i<=n;p(i)) {
            for (ri j(1);j<=n;p(j)) scanf("%lf",&G[i][j]); 
        }
        for (ri i(1);i<=n;p(i)) {
            for (ri j(1);j<=n;p(j)) {
                if (G[i][j]<eps) G[i][j]=eps;
                if ((1.0-G[i][j])<eps) G[i][j]=1.0-eps;
                if (i<j) tmp*=(1.0-G[i][j]);
                G[i][j]/=(1.0-G[i][j]);
            }
        }
        // printf("tmp=%.10lf\n",tmp);
        for (ri i(1);i<=n;p(i)) {
            G[i][i]=0.0;
            for (ri j(1);j<=n;p(j)) {
                if (i!=j) G[i][i]+=G[i][j],G[i][j]=-G[i][j];
            }
        }
        n-=1;
        Gauss();
        printf("%.10lf\n",ans*tmp);
        return 0;
    }
}
int main() {return nanfeng::main();}

```

---

## 作者：QiFeng233 (赞：0)

我们知道，Matrix-Tree 定理可以求 $\sum\limits_T\prod\limits_{e \in T}w_e$

而这题，每一种形态的树的期望是每条树中的边的期望*(1-不在树中的边的期望)，也就是 $\sum\limits_T\prod\limits_{e \in T}p_e\prod\limits_{e \not \in T}(1-p_e)$

而 $\prod\limits_{e \not \in T}(1-p_e)=\dfrac{\prod\limits_e(1-p_e)}{\prod\limits_{e \in T}(1-p_e)}$

所以原式化为 $\prod\limits_e(1-p_e)\sum\limits_T\prod\limits_{e \in T}\dfrac{p_e}{1-p_e}$

就可以用 Matrix-Tree 定理求解了

然鹅......nan?

$p_e=1$ 时，建议 $p_e-=eps$ 以避免 nan。当然也可以把那条必定出现的边缩点什么的，不过太麻烦了。

后记：写这篇题解也是为了提醒我自己，不知道怎么的，我做期望题老是会忘记乘上(1-不该出现在这种情况中的部分出现的概率)
```cpp
#include<cstdio>
#include<algorithm>
using std::swap;
typedef long double ld;
namespace QiFeng233{
	const int maxn=60;
	const ld eps=1e-8;
	ld A[maxn][maxn];
	int n;
	ld fabs(ld x){
		return x<0.0?-x:x;
	}
	ld gauss(){//默认去掉第一行 
		ld ret=1.0;
		for(int i=2;i<=n;++i){
			int raw=i;
			for(int j=i+1;j<=n;++j)if(fabs(A[j][i])-fabs(A[raw][i])>eps)raw=j;
			if(raw!=i)swap(A[raw],A[i]),ret*=-1;
			if(fabs(A[i][i])<eps)return 0;
			for(int j=i+1;j<=n;++j){
				ld div=A[j][i]/A[i][i];
				for(int k=i;k<=n;++k)A[j][k]-=A[i][k]*div;
			}
		}
		for(int i=2;i<=n;++i)ret*=A[i][i];
		return ret;
	}
	void solve(){
		ld ans=1.0;
		scanf("%d",&n);
		for(int i=1;i<=n;++i){
			for(int j=1;j<=n;++j){
				ld x;
				scanf("%Lf",&x);
				if(fabs(x)<eps)x=eps;
				if(fabs(1.0-x)<eps)x=1.0-eps;
				if(i<j)ans*=(1.0-x);
				A[i][j]=-x/(1.0-x);
			}
		}
		for(int i=1;i<=n;++i){
			A[i][i]=0;
			for(int j=1;j<=n;++j){
				if(i!=j)A[i][i]-=A[i][j];
			}
		}
		printf("%Lf",ans*gauss());
	}
}
signed main(){
	QiFeng233::solve();
	return 0;
}
```

---

## 作者：crashed (赞：0)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.org/problem/P3317)看题目。
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，题目要求这样一个东西：    
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;![示例1.PNG](https://i.loli.net/2019/08/21/RIiFnd7SN1KYJGM.png)    
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，我们的矩阵树定理，最多可以求出如下的东西。    
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;![示例2.PNG](https://i.loli.net/2019/08/21/8dK5z9bkg7XecML.png)  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过，我们发现：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;![示例3.PNG](https://i.loli.net/2019/08/21/Ju25qca8GIFQSje.png)  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后就可以愉快地拆式子了：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;![示例4.PNG](https://i.loli.net/2019/08/21/vI7tP85NUKrfeBE.png)  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;把边权改成$\frac{p_e}{(1-p_e)}$然后跑变元矩阵树定理即可。 注意$p=1$的时候需要特殊处理，简单来说就是$p=1-eps$，然后就可以正常操作。  
# 代码
```cpp
#include <cmath>
#include <cstdio>
#include <iostream>

const double eps = 1e-10;
const int MAXN = 55;

template<typename _T>
void read( _T &x )
{
    x = 0;char s = getchar();int f = 1;
    while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
    while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
    x *= f;
}

template<typename _T>
void write( _T x )
{
    if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
    if( 9 < x ){ write( x / 10 ); }
    putchar( x % 10 + '0' );
}

template<typename _T>
_T ABS( const _T a )
{
	return a < 0 ? -a : a;
}

double K[MAXN][MAXN];
double D[MAXN][MAXN], G[MAXN][MAXN];
double res;
int N;

double Gauss( const int n )
{
	double tmp;
	int opt = 1, indx, coe = 1;
	for( int i = 1 ; i <= n && opt <= n ; i ++, opt ++ )
	{
		indx = -1;
		for( int j = i ; j <= n ; j ++ )
		{
			if( K[j][opt] && ( indx == -1 || ABS( K[indx][opt] ) < ABS( K[j][opt] ) ) )
			{
				indx = j;
			}
		}
		if( indx == -1 )
		{
			return 0;
		}
		if( indx ^ i ) coe = -coe;
		std :: swap( K[i], K[indx] );
		for( int j = i + 1 ; j <= n ; j ++ )
		{
			tmp = K[j][opt] / K[i][opt];
			for( int k = 1 ; k <= n ; k ++ )
			{
				K[j][k] -= K[i][k] * tmp;
			}
		}
	}
	double ans = coe;
	for( int i = 1 ; i <= n ; i ++ )
	{
		ans = ans * K[i][i];
	}
	return ans;
}

void solve()
{
	for( int i = 1 ; i <= N ; i ++ )
	{
		for( int j = 1 ; j <= N ; j ++ )
		{
			D[i][i] += G[i][j];
		}
	}
	for( int i = 1 ; i <= N ; i ++ )
	{
		for( int j = 1 ; j <= N ; j ++ )
		{
			K[i][j] = D[i][j] - G[i][j];
		}
	}
	res = Gauss( N - 1 );
}

int main()
{
	read( N );
	double c = 1;
	for( int i = 1 ; i <= N ; i ++ )
	{
		for( int j = 1 ; j <= N ; j ++ )
		{
			scanf( "%lf", &G[i][j] );
			if( G[i][j] == 1 ) G[i][j] -= eps;
			if( i < j && G[i][j] ) c *= ( 1 - G[i][j] );
			G[i][j] = G[i][j] / ( 1 - G[i][j] );
		}
	}
	solve();
	printf( "%.12lf\n", c * res );
	return 0;
}
```

---

## 作者：kernel_panic (赞：0)

## 思路

生成树相关计数，考虑矩阵树定理．

矩阵树定理是用于求解形如下式的问题的：

$$
\sum_{T} \prod_{e \in T} w_e
$$

其中 $T$ 取遍图中所有生成树的边集，$w_e$ 是 $e$ 这条边的边权．

设 $p_{e}$ 为 $e$ 这条边存在的概率，对于这道题，我们要求的是：

$$
\sum_{T} \left(\prod_{e \in T} p_e\right) \times \left(\prod_{e \not\in T} 1 - p_e\right)
$$

发现右边的 $\prod$ 很烦人，它阻止我们直接使用矩阵树定理．考虑怎么让它与 $\sum$ 无关．提一个 $\prod\limits_e 1 - p_e$ 出来，式子可化为：

$$
\left(\prod_e 1 - p_e\right) \times \sum_{T} \prod_{e \in T} \frac{p_e}{1 - p_e}
$$

左边的 $\prod$ 可以直接算，右边的 $\sum$ 使用矩阵树定理．

注意到存在 $p_e = 1$ 的情况，直接做除法会除出来 inf，给分母加个微小扰动即可．

## 代码

```cpp
#include <cstdio>
#include <cmath>
#include <algorithm>

using f64 = double;

const int N = 50;
const f64 eps = 1e-9;

int n; f64 a[N + 5][N + 5];
int ct[N + 5];

int d;
f64 det() {
	int sgn = 1;
	for(int i = 1; i <= d; i++) {
		int p = i;
		for(int j = i + 1; j <= d; j++) {
			if(a[j][i] > a[p][i]) p = j;
		}
		if(p != i) sgn *= -1, std::swap(a[i], a[p]);
		for(int j = 1; j <= d; j++) {
			if(i == j) continue;
			f64 x = a[j][i] / a[i][i];
			for(int k = 1; k <= d; k++) {
				a[j][k] -= x * a[i][k];
			}
		}
	}
	f64 res = 1;
	for(int i = 1; i <= d; i++) res *= a[i][i];
	return res * sgn;
}

int main() {
	scanf("%d", &n);
	f64 rev = 1;
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= n; j++) {
			scanf("%lf", &a[i][j]);
		}
	}

	for(int i = 1; i <= n; i++) {
		for(int j = i + 1; j <= n; j++) {
			rev *= (1 - a[i][j] + eps);
		}
	}
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= n; j++) {
			a[i][j] /= (1 - a[i][j] + eps);
		}
	}
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= n; j++) {
			if(i == j) continue;
			a[i][i] += a[i][j];
		}
	}
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= n; j++) {
			if(i == j) continue;
			a[i][j] = -a[i][j];
		}
	}
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= n; j++) {
			a[i][j] = a[i + 1][j + 1];
		}
	}

	d = n - 1;
	printf("%.15lf\n", det() * rev);
	return 0;
}
```


---

## 作者：Mars_Dingdang (赞：0)

一道考验对矩阵树定理理解的题目。

## 题目大意
一张 $N$ 个节点的无向图 $G=(V,E)$，给定每条道路在洪水后仍能通行的概率，请计算仍能通行的道路恰有 $N-1$ 条，且能联通所有城市的概率。

## 大体思路
设 $T$ 表示生成树，则本题要求的是 $N-1$ 条道路连通，**剩余道路不连通**的概率之和，即

$$\sum_T\left(\prod_{e\in T}p_e\cdot\prod_{e\notin T}(1-p_e)\right)$$

用矩阵树定理求出的是生成树边权乘积之和，即

$$\sum_T\prod_{e\in T}p_e$$

所以，我们需要通过如下的转换方式，使得其称为能够用矩阵树定理计算的形式。注意到 $\{e|e\in T\}\cup \{e|e\notin T\}=E$，有

$$\prod_{e\notin T}(1-p_e)\cdot\prod_{e\in T}(1-p_e)=\prod_{e\in E}(1-p_e)$$

$$\sum_T\left(\prod_{e\in T}p_e\cdot\prod_{e\notin T}(1-p_e)\right)=\sum_T\left(\prod_{e\in T}p_e\cdot\dfrac{\prod_{e\in E}(1-p_e)}{\prod_{e\in T}(1-p_e)}\right)$$
$$=\prod_{e\in E}(1-p_e)\left(\sum_T\prod_{e\in T}\dfrac{p_e}{1-p_e}\right)$$

所以，我们可以预先计算出 $\prod_{e\in E}(1-p_e)$，并将 $w_e=\dfrac{p_e}{1-p_e}$ 作为边权建立基尔霍夫矩阵，用高斯消元计算行列式的值即可。

需要注意的是，直接这样交上去会获得 $30$ 分的好成绩，并且你会发现一个熟悉的 `nan`。这是因为当 $p=1$ 时，$1-p=0$ 不能作为分母。

考虑到 $p=1$ 时，$1-p=0$，$\dfrac{1}{1-p}\to \infty$，而 $\epsilon\to 0,\epsilon^{-1}\to \infty$，只需令 $1-p=\epsilon$，$p'=1-\epsilon=p-\epsilon$ 即可。

## 完整代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define rep(ii,aa,bb) for(re int ii = aa; ii <= bb; ii++)
#define Rep(ii,aa,bb) for(re int ii = aa; ii >= bb; ii--)
typedef long long ll;
typedef unsigned long long ull;
typedef double db;
typedef pair<int, int> PII;
const int maxn = 55;
const db eps = 1e-8;
namespace IO_ReadWrite {
	#define re register
	#define gg (p1 == p2 && (p2 = (p1 = _buf) + fread(_buf, 1, 1<<21, stdin), p1 == p2) ? EOF :*p1++)
	char _buf[1<<21], *p1 = _buf, *p2 = _buf;
	template <typename T>
	inline void read(T &x){
		x = 0; re T f=1; re char c = gg;
		while(c > 57 || c < 48){if(c == '-') f = -1;c = gg;}
		while(c >= 48 &&c <= 57){x = (x<<1) + (x<<3) + (c^48);c = gg;}
		x *= f;return;
	}
	inline void ReadChar(char &c){
		c = gg;
		while(!isalpha(c)) c = gg;
	}
	template <typename T>
	inline void write(T x){
		if(x < 0) putchar('-'), x = -x;
		if(x > 9) write(x/10);
		putchar('0' + x % 10);
	}
	template <typename T>
	inline void writeln(T x){write(x); putchar('\n');}
}
using namespace IO_ReadWrite;
int n;
db a[maxn][maxn], base;
inline void Guass() {
	db ans = base; ll w = 1;
	rep(i, 2, n)
		rep(j, i + 1, n) {
			while(fabs(a[i][i]) > eps) {
				db factor = a[j][i] / a[i][i];
				rep(k, i, n)
					a[j][k] -= a[i][k] * factor;
				swap(a[i], a[j]), w = -w;
			}
			swap(a[i], a[j]), w = -w;
		}
	rep(i, 2, n) ans *= a[i][i];
	printf("%.5lf", ans * w);
}
int main () {
	scanf("%d", &n);
	base = 1.0;
	rep(i, 1, n)
		rep(j, 1, n) {
			db w;
			scanf("%lf", &w);
			if(fabs(1.0 - w) < eps) w -= eps;
			if(i <= j) base *= (1.0 - w);
			if(w > eps) {
				a[i][i] += (w / (1.0 - w));
				a[i][j] -= (w / (1.0 - w));
			}
		}
	Guass();
	return 0;
}
```

---

## 作者：FjswYuzu (赞：0)

显然这是一个图，图上的边权有出现的概率。问出现的边恰好构成一棵树的概率是多少。

考虑每一棵合法的树的贡献。假设合法的树的集合是 $S$，设一棵树 $\text{Tree} \in S$ 出现的概率是 $p_{\text{Tree}}$，概率可加显然答案是 $\sum_{\text{Tree} \in S}p_{\text{Tree}}$。

考虑每一棵树的贡献。因为是一棵树，所以边有选和不选两种状态。对于一棵合法生成树 $\text{Tree}$ 来说，它的出现概率为：

$$
\prod_{E \in \text{Tree}} p_E \prod_{E \not \in \text{Tree}} (1-p_E)
$$

考虑将上面这个式子进行变换，使其尽量的好计算或者单单与 $\text{Tree}$ 有关。

$$
\prod_{E \in \text{Tree}} p_E  \dfrac{\prod_{E \in \text{Graph}} (1-p_E)}{\prod_{E \in \text{Tree}}(1-p_E)}
$$

显然分母上面的东西是个定值。提出来。

$$
\prod_{E\in \text{Tree}}  \dfrac{p_E}{1-p_E}
$$

接下来要做的就是这个了。

考虑到数据范围很小给予我们提示，并且众所周知求图中所有生成树边权乘积之和已经被出烂了。设出现概率为 $p_E$ 的边边权为 $\dfrac{p_E}{1-p_E}$，做 Matrix-Tree 定理的模板即可。注意乘上提出来的定值。

需要注意的是，边权存在 $1$ 或者 $0$。这样的话我们需要将其分别变为一个不是 $1$ 和 $0$ 但是非常接近的小数。具体操作可以看代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
const double eps=1e-7;
int n;
double sp[55][55],a[55][55];
double Gauss()
{
	double ans=1;
	--n;
	for(int i=1;i<=n;++i)
	{
		int maxn=i;
		for(int j=i+1;j<=n;++j)	if(fabs(a[j][i])>fabs(a[maxn][i]))	maxn=j;
		swap(a[i],a[maxn]);
		if(fabs(a[i][i])<eps)	return 0;
		for(int j=1;j<=n;++j)
		{
			if(i==j)	continue;
			double del=a[j][i]/a[i][i];
			for(int k=i+1;k<=n+1;++k)	a[j][k]-=a[i][k]*del;
		}
		ans*=fabs(a[i][i]);
	}
	return ans;
}
int main(){
	scanf("%d",&n);
	double ans=1;
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j<=n;++j)
		{
			scanf("%lf",&sp[i][j]);
			if(sp[i][j]<eps)	sp[i][j]=eps;
			if(1-sp[i][j]<eps)	sp[i][j]=1-eps;
			if(i<j)	ans*=(1-sp[i][j]);
			sp[i][j]=sp[i][j]/(1-sp[i][j]);
		}
	}
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j<=i-1;++j)
		{
			int u=i,v=j;
			a[u][u]+=sp[i][j];
			a[v][v]+=sp[i][j];
			a[u][v]-=sp[i][j];
			a[v][u]-=sp[i][j];
		}
	}
	printf("%.10f",ans*Gauss());
	return 0;
}
```

---

## 作者：1saunoya (赞：0)

矩阵树定理。

定义 $e_p$ 为这条边的出现概率

答案是 $\sum_T \prod e_p [e\in T] \times \prod (1-e_p) [e \notin T]$。

$\sum_T \prod e_p [e\in T] \times \prod (1-e_p) [e \notin T]$

$=\sum_T \left(\prod e_p [e\in T] \times \frac{\prod (1-e_p) }{\prod (1-e_p) [e \in T]}\right)$

然后把 $\prod (1-e_p)$ 提出来就是个模板了。

```cpp
#include <bits/stdc++.h>
int N;
double g[55][55];
const double eps = 1e-7;
double det() {
	--N; bool rev = false;
	for (int i = 0; i < N; i++) {
		int now = i;
		for (int j = i + 1; j < N; j++) {
			if (abs(g[j][i]) > abs(g[now][i])) { now = j; }
		}
		if (now != i) { std::swap(g[now], g[i]); rev ^= 1; }
		if (g[i][i] > -eps && g[i][i] < eps) { return 0.0; }
		for (int j = i + 1; j < N; j++) {
			double t = g[j][i] / g[i][i];
			for (int k = i; k < N; k++) { g[j][k] -= 1. * g[i][k] * t; }
		}
	}
	double answer = 1;
	for (int i = 0; i < N; i++) { answer = 1. * answer * g[i][i]; }
	if (rev) { answer = -answer; }
	return answer;
}
int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(NULL);
	std::cin >> N;
	double answer = 1;
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < N; j++) {
			std::cin >> g[i][j];
			if (g[i][j] == 1) { g[i][j] = 1 - eps; }
			if (g[i][j] < eps) { g[i][j] = eps; }
			if (i < j) { answer = 1. * answer * (1 - g[i][j]); }
			g[i][j] = 1. * g[i][j] / (1 - g[i][j]);
		}
	}
	for (int i = 0; i < N; i++) {
		g[i][i] = 0;
		for (int j = 0; j < N; j++) {
			if (i != j) { g[i][i] += g[i][j]; g[i][j] = -g[i][j]; }
		}
	}
	std::cout << std::fixed << std::setprecision(10) << answer * det() << '\n';
	return 0;
}

```

---


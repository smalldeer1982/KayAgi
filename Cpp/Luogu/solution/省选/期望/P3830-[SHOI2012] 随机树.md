# [SHOI2012] 随机树

## 题目背景

SHOI2012 D1T3


## 题目描述

一棵含 $n$ 个叶结点的二叉树可以通过如下方式生成。初始时只有根结点。首先，将根结点展开（本题中的“展开”是指给一个叶结点添上左、右两个子结点）：

[a]

然后，等概率地随机将两个叶结点中的一个展开，即生成以下两棵树之一：

[b]

之后，每次在当前二叉树的所有叶结点中，等概率地随机选择一个，将其展开。

不断地重复这一操作，直至产生 $n$ 个叶结点为止。例如，某棵含 5 个叶结点的二叉树可能按如下步骤生成。

[c]

对于按该方式随机生成的一棵含 $n$ 个叶结点的二叉树，求：

1. **叶结点平均深度** 的数学期望值。
2. **树深度** 的数学期望值。约定根结点的深度为 0。

![](https://cdn.luogu.com.cn/upload/image_hosting/7ql5uhxn.png)

## 说明/提示

### 【样例1、样例2说明】
数学期望值是随机变量的值乘以其概率的总和：记随机变量 $X$ 可能的取值为 $x_1,x_2,\cdots,x_n$，它们取到的概率分别为 $p_1,p_2,\cdots,p_n$，那么随机变量 $X$ 的数学期望值就是

$E(X)=\sum_{i = 1}^{n}p_ix_i$

例如，掷一枚写有 1、2、3、4、5、6 这 6 个数的均匀骰子，掷到的数的数学期望值是：

$E=\frac{1}{6}\times1+\frac{1}{6}\times2+\frac{1}{6}\times3+\frac{1}{6}\times4+\frac{1}{6}\times5+\frac{1}{6}\times6 = 3.5$

尽管 3.5 不是骰子上的某个数。又如，一道 4 选 1 的选择题，答对得 5 分，不答不得分，答错倒扣 1 分。那么，当我们不答时，一定得 0 分；而等概率地随便猜一个时，得分的数学期望值是：

本题中，根据二叉树的生成方式，当 $n = 4$ 时，下图中前四棵树被生成的概率均为 $1/6$，最后一棵树被生成的概率为 $1/3$。它们的叶结点平均深度分别是 $9/4$、$9/4$、$9/4$、2，因此叶结点平均深度的数学期望值是

$E=\frac{1}{6}\times\frac{9}{4}+\frac{1}{6}\times\frac{9}{4}+\frac{1}{6}\times\frac{9}{4}+\frac{1}{6}\times\frac{9}{4}+\frac{1}{3}\times2=\frac{13}{6}$

而它们的树深度分别是 3、3、3、3、2，因此树深度的数学期望值是

$E=\frac{1}{6}\times3+\frac{1}{6}\times3+\frac{1}{6}\times3+\frac{1}{6}\times3+\frac{1}{3}\times2=\frac{8}{3}$

### 【数据规模】
| 测试数据编号 | $q$ | $n$ |
| ---- | ---- | ---- |
| 1,2 | $q = 1$ | $2\leq n\leq10$ |
| 3,4,5 | $q = 1$ | $2\leq n\leq100$ |
| 6,7 | $q = 2$ | $2\leq n\leq10$ |
| 8,9,10 | $q = 2$ | $2\leq n\leq100$ | 

![](https://cdn.luogu.com.cn/upload/pic/6556.png) 

 ![](https://cdn.luogu.com.cn/upload/pic/6557.png) 

![](https://cdn.luogu.com.cn/upload/pic/6558.png)


## 样例 #1

### 输入

```
1 4```

### 输出

```
2.166667```

## 样例 #2

### 输入

```
2 4```

### 输出

```
2.666667```

## 样例 #3

### 输入

```
1 12```

### 输出

```
4.206421```

## 样例 #4

### 输入

```
2 12```

### 输出

```
5.916614```

# 题解

## 作者：BJpers2 (赞：115)

对于这道题目，很多题解都没有阐明第二问状态转移方程
$$f[i][j]=\sum_{k=1}^{i-1} \frac{f[k][j-1]+f[i-k][j-1]-f[k][j-1] \times f[i-k][j-1]}{i-1}$$
的正确性，其中$f[i][j]$表示在有$i$个叶子的随机树中，树的深度大于等于$j$的概率。他们几乎都没有讲清楚$/(i-1)$的来历。

显然，对于某一棵随机的，左儿子有$k$个叶子，右儿子有$i-k$个叶子的树，它的深度不小于$j$的概率为

$$P_k=f[k][j-1]+f[i-k][j-1]-f[k][j-1] \times f[i-k][j-1]$$

设操作$i-1$次，生成一棵的左儿子恰有$k$个叶子，右儿子有$i-k$个叶子的树的概率为$P'_k$

又因为在有$i$个叶子的随机树中，树的深度大于等于$j$的概率$P=\sum_{k=1}^{i-1} P_kP_k'$。

所以我们要证明$P_1'=P_2'=...=P_k'=...=P_{i-1}'=\frac{1}{i-1} (1)$

考虑一棵左儿子有$k$个叶子，右儿子有$i-k$个叶子的树是怎样生成的。如果把所有操作写成一个序列，$L$表示在左子树操作,$R$表示在右子树操作。由于最开始一定是根分裂，于是左右子树分别还有$k-1$,$i-k-1$个叶子需要生成。那最后看起来可能会是这样。

$$\underbrace{LRLLR....RLRLL}_{(k-1)*L,(i-k-1)*R}$$

它是一个有$k$个$L$和$i-k$个$R$的序列，也就是说，对于任何一对左右的操作序列，他们能组成$C_{i-k-1+k-1}^{k-1}=\frac{(i-2)!}{(k-1)!(i-k-1)!}$种不同的操作序列。

考虑生成一棵有$k$个叶子的树的方案数，也即有多少种操作序列。首先由$1$到$2$个叶子时只有一个选择，然后由$2$到$3$有两个选择......由$k-1$到$k$有$k-1$种选择。所以有$(k-1)!$种方案。

同理，生成一棵有$i-k$个叶子的树的方案数为$(i-k-1)!$

也即左子树可能的操作序列有$(k-1)!$种，右子树有$(i-k-1)!$种。

于是，将两条序列配对，共有$(k-1)!(i-k-1)!$种方案。

然后再乘上它们两条序列“揉在一起”的方案数(就是上面那个组合数)，就能得到生成一棵左儿子有$k$个叶子，右儿子有$i-k$个叶子的的树的方案数，它等于$(i-2)!$看起来与$k$无关。

这也就意味着，假如让我构造一颗有$100$个叶子的树，我左边放$99$个叶子,右边放$1$个叶子,跟我两边放五十个叶子的方案数竟然是一样的。也即等式$(1)$成立。

有了这个结论，我们才敢在转移时给每个概率除以$(i-1)$.



---

## 作者：Fizzmy (赞：43)

第一问很好处理：设$f_x$表示有x个叶子节点的树的叶子节点平均深度

我们考虑在一个有x-1个叶子节点的树里随机选择一个叶子节点展开，那么树的叶子节点深度总和会增加$f_{x-1}+2$

所以$f_x=\frac {f_{x-1}*(x-1)+f_{x-1}+2} x=f_{x-1}+\frac 2 x$

第二问就比较难受了：

首先我们知道一个式子：

$ E(x)=∑^{+∞}_{i=1}P(i\leq x) $

说人话就是随机变量x的期望为对于所有i，$i\leq x$的概率之和

我们设$f[i][j]$表示有i个叶子，树的深度$\geq j$的概率

转移时枚举左右子树有多少个叶子：

$f[i][j]=\sum_{k=1}^{i-1}\frac 1 {i-1}(f[k][j-1]+f[i-k][j-1]-f[k][j-1]*f[i-k][j-1])$

（括号里的式子含义：左右只要一边深度$\geq j-1$即可，所以式子展开其实是$f[k][j-1]*1+f[i-k][j-1]*1$，但这样会计算两次两边都$\geq j-1$的情况，所以需要减掉）

最后答案即为$\sum_{i=1}^{n-1}f[n][i]$





代码:

```
#include<cstdio>
#include<iostream>
using namespace std;
int p,n;
double f[110],dp[110][110],ans;
int main()
{
	scanf("%d%d",&p,&n);
	if (p==1)
	{
		f[1]=0;
		for (int i=2;i<=n;i++) f[i]=f[i-1]+2.0/i;
		printf("%.6f",f[n]);
	}
	else
	{
		for (int i=1;i<=n;i++) dp[i][0]=1;
		for (int i=2;i<=n;i++)
			for (int j=1;j<i;j++)
			{
				for (int k=1;k<i;k++)
					dp[i][j]+=dp[k][j-1]+dp[i-k][j-1]-dp[k][j-1]*dp[i-k][j-1];
				dp[i][j]/=(i-1);
			}
		for (int i=1;i<n;i++) ans+=dp[n][i];
		printf("%.6f",ans);
	}
} 
```



---

## 作者：emptysetvvvv (赞：29)

## 数学期望

### 背景

前人之述备矣，BJpers2神犇的证明更是极为精彩，让小萌新$\varnothing$深受触动。无奈$\varnothing$实在是太蒻了，只好属文以记之。

### 思路

- 考虑第一问

设 $g[i]$ 表示有 $i$ 个叶子的二叉树的期望叶子平均深度。

则 $i-1$ 个叶子的二叉树进行扩展后，叶节点数量变为 $i$，叶子深度之和增加$2$。

故有 $g[i]=g[i-1]+2/i,g[1]=0$。

即 $\displaystyle\sum_{i=2}^n\displaystyle\frac{2}{i}.$

- 考虑第二问

- 先证明一个小结论：**设扩展$i-1$次后，左子树有 $k$ 个叶子的概率、右子树有 $i-k$ 个叶子的概率为 $P(k)$。则有 $\forall k_1,k_2\in[1,i-1],P(k_1)=P(k_2)$。**

将扩展过程表示为序列，则其中 “扩展左子树” 有 $k-1$ 个，“扩展右子树” 有 $i-k-1$ 个，序列的形式数量为：

$$\displaystyle \binom{k-1+i-k-1}{k-1}=\displaystyle\frac{(i-2)!}{(k-1)!(i-k-1)!}.$$

再考虑 $k-1$ 次在左子树扩展形成的树的形态数，第 $i$ 次可有 $i$ 个叶节点可供扩展，故形态数为 $(k-1)!$。

同理，右子树的形态数有 $(i-k-1)!$。

故考虑扩展先后、树的形态，生成一个左子树有 $k$ 个叶节点、右子树有 $i-k$ 个叶节点的树的方案数为

$$\displaystyle\frac{(i-2)!}{(k-1)!(i-k-1)!} \cdot(k-1)!\cdot(i-k-1)!=(i-2)!$$

与 $k$ 无关，即 $P(k_1)=P(k_2)$。

- 前置芝士：**整数概率公式**

正整数随机变量 $x$ 的期望值为：

$$E(x)=\sum_{i=1}^{\infty}P(x\geqslant i)$$

>证明：

>$$E(x)=\sum_{i=1}^{\infty}P(x=i)\cdot i=\sum_{i=1}^{\infty}(P(x\geqslant i)-P(x\geqslant i+1))\cdot i$$

>$$=\sum_{i=1}^{\infty}P(x\geqslant i)\cdot i-P(x\geqslant i)\cdot(i-1)=\sum_{i=1}^{\infty}P(x\geqslant i)$$

- 计算概率

设 $f[i][j]$ 为树有 $i$ 个叶节点，深度不小于 $j$ 的概率，考虑枚举左子树叶节点数量为 $k$，有

$$\displaystyle f[i][j]=\displaystyle\frac{1}{i-1}\sum_{k=1}^{i-1}f[k][j-1]+f[i-k][j-1]-f[k][j-1]\cdot f[i-k][j-1]$$

解释如下，首先考虑左、右子树深度不小于 $j$ 的概率之和。再考虑左右子树深度皆大于等于 $j$ 的情况计算了两次，减去一倍即可。

前文我们证明过，左子树叶节点数为 $1,2,...,i-1$ 的概率相同，即均为 $1/(i-1)$。

初始条件，$f[i][0]=1$，因为无论有多少个叶子，深度大于等于 $0$ 的概率总为 $1$。

由整数概率公式可知，期望深度 $x$ 为：

$$E(x)=\sum_{i=1}^{\infty}P(x\geqslant i)=\sum_{i=1}^{n-1}f[n][i]\qquad(\forall x\geqslant n,P(x\geqslant i)=0).$$

### 代码

```cpp
#include <cstdio>
int n, op;
double ans, f[105][105];
void solve1() {
	for(int i = 2; i <= n; ++i) ans += 2.0 / i;
}
void solve2() {
	for(int i = 1; i <= n; ++i) f[i][0] = 1;
	for(int i = 2; i <= n; ++i)
		for(int j = 1; j < i; ++j)
			for(int k = 1; k < i; ++k)
				f[i][j] += (f[k][j-1] + f[i-k][j-1] - f[k][j-1]*f[i-k][j-1]) / (i-1);
	for(int i = 1; i < n; ++i) ans += f[n][i];
}
int main() {
	scanf("%d %d", &op, &n);
	if(op & 1) solve1();
	else solve2();
	printf("%.6lf\n", ans);
}
```


### p.s

毕竟$\varnothing$还比较蒻嘛......有写错的地方请告诉她。

~~没有的话.......求赞【可怜】......~~

---

## 作者：aoweiyin (赞：28)

呜呜，笔者花了近一天来完成此题，很是伤心。最后还是读完[Remoon](http://www.cnblogs.com/reverymoon/p/9507106.html) = [曦月__OFN](https://www.luogu.org/space/show?uid=54022)大佬的BLOG才把此题终结。所以为了帮助后来者，~~也为了加深自己对此题的理解~~，笔者决定写一篇题解

-----------
_Well,Let's go._

**1）** 首先，我们要审题。

好，Q1要求求平均叶子节点深度。Rujia Liu曾在蓝书上表达过这个意思：

> 该随机事件的期望(书面) 等价于 该随机事件在“平均状态”下是多少(口语)

所以我们可以从这两个方面来思考，而略微思考后，就会发现DP是可行的；

我们定义$f[i]$，表示有i个叶子节点的树的**平均**叶子深度

既然在定义中用到了_平均_，那我们就可以求出状态转移方程：

$f[i]=f[i-1]+\frac{2}{i}$ 

 边界$f[0]=1$

([Click here if you haven't understood yet](https://www.luogu.org/paste/qlb45wb5))

--------

**2)** Well，我们乘胜追击，发现那个“平均”似乎也不好用了。

但我们肯定知道，这道题是道概率题[手动滑稽]，而有关概率期望的公式就那么几个。

所以，我们“乱套”（~~“用直觉得出”~~）公式得出：

$Ans=\sum^{n-1}_{i=1}i\times f[n][i]$ （期望的线性性）

($f[i][j]$表示**构建**一棵有$i$个叶子节点且深度为$j$的树的概率)

让我们再“乱套”公式一波： (全概率公式)

$f[i][j]=\sum^{i-1}_{L=1}p[i][L]\times\sum^{j}_{x=1}\sum^{j}_{y=1} f[L][x]\times f[i-L][y]$ $(x==j-1 || y==j-1)$ 

$p[i][j]$表示对于一棵有i个叶子节点的树，j个在其左子树的概率

([Click here if you haven't understood the above equation](https://www.luogu.org/paste/ke5zm87h))

这时，会发现时间复杂度是$O(n^{4})$

而$n\leq100$，所以如果出题人比较良心的话，还是能卡过的；但是万一碰上了某些牛逼出题人的话，就呵呵了。

并且发现要优化似乎有点困难，

So，我们来点简单的；

设$f[i][j]$表示构建一棵有$i$个叶子节点且深度大于等于$j$的树的概率

可得（一个优美的等式）（本质原理和上一个式子差不多）：

$f[i][j]=\sum^{i-1}_{L=1}\frac{f[L][j-1]+f[i-L][j-1]-f[L][j-1]\times f[i-L][j-1]}{i-1}$

([Click here if you haven't understood the above equation](https://www.luogu.org/paste/y9ij43lj))

最后，我们才发现，咦，推答案的公式怎么不行了呢?

所以，这时就要用到一个很巧妙的处理：~~（完全不知道DALAOs是怎么想到的）~~

$Ans=\sum^{n-1}_{i=1}f[n][i]$

([Click here if you haven't understood the above equation](https://www.luogu.org/paste/zuloat8v))

然后，题解报告完毕；

And，if you want to see my code,please click [here](https://slay.one/) OR [there](https://www.luogu.org/paste/0jq0afhu) OR [over there](https://www.luogu.org/space/show?uid=77834);

Oh,I'm so sorry about this.[手动偷笑]

------

真心希望神犇能够指出此BLOG的漏洞，笔者极其感激。

最后，笔者在此感到抱歉，因实力有限，不能给大家以一定的拓展，只能就题论题。唉，我好菜啊，QwQ

**P.S.**笔者一直无法完成从

$f[i][j]=\sum^{i-1}_{L=1}p[i][L]\times\sum^{j}_{x=1}\sum^{j}_{y=1} f[L][x]\times f[i-L][y]$ $(x==j-1 || y==j-1)$

到

$f[i][j]=\sum^{i-1}_{L=1}\frac{f[L][j-1]+f[i-L][j-1]-f[L][j-1]\times f[i-L][j-1]}{i-1}$

的理论推导，所以很希望推出了的读者能够给予笔者帮助。

#####Thanks for reading!!!

---

## 作者：Scarlet_Hypoc (赞：23)

~~这篇题解可能算是比较全面的了吧qwq~~

第一问比较简单，设 $f[i]$ 表示有 $i$ 个叶子的树的叶节点平均深度，那么总深度就是 $f[i]\times i$，要从 $f[i-1]$ 转移到 $f[i]$ 的话，就是随机选一个叶子节点，减去它的深度，然后加上 $2\times$ (它的深度+1)，而它的期望深度就是 $f[i-1]$，所以有 $f[i]=\frac {f[i-1]\times (i-1)-f[i-1]+2\times (f[i-1]+1)} i=f[i-1]+\frac 2 i$。

第二问的话设 $g[i][j]$ 表示有 $i$ 个叶子的且深度**大于等于** $j$ 的树的出现概率。二叉树的比较经典的转移就是枚举根节点的左右子树大小了，这题就是枚举左右子树中叶子节点数量，于是有：
$$
g[i][j]=\sum_{k=1}^{i-1} \frac {g[k][j-1]+g[i-k][j-1]-g[k][j-1]*g[i-k][j-1]} {i-1}
$$


$k$ 枚举的是左子树中叶子数量，$g[k][j-1]$ 表示左子树深度大于等于 $j-1$ 的概率，此时不管右子树深度时多少，整棵树的深度都大于等于 $j$，$g[i-k][j-1]$ 则是右子树的概率，但是，左右子树深度都大于等于 $j-1$ 的情况在 $g[k][j-1]$ 和 $g[i-k][j-1]$ 中都被统计过，所以要去掉这个重复计算的部分，所以要减去 $g[k][j-1]*g[i-k][j-1]$。

而下面的除以 $i-1$，即乘以 $\frac 1 {i-1}$，表示一棵有 $i$ 个叶子的树，左子树有 $k$ 个叶子的概率，证明也不难：

我们先不考虑求这个概率，先求 **一棵有 $i$ 个叶子的树，左子树有 $k$ 个叶子的情况数**，

由于树中有 $i$ 个叶子，所以这棵树已经被展开过 $i-1$ 次，去掉一开始的展开根节点，对左右子树一共展开了 $i-2$ 次，而其中有 $k-1$ 次展开的是左子树，有 $i-k-1$ 次展开的是右子树，那么显然有 $C_{i-2}^{k-1}$ 种不同的情况，即 $\frac {(i-2)!} {(k-1)!(i-k-1)!}$。

再考虑对一个节点展开 $p$ 次有多少种情况：

1、第一次展开只有 $1$ 个点能选择，一共有 $1$ 种不同的情况
2、第二次展开有 $2$ 个点能选择，一共有 $2$ 种不同的情况
3、第三次展开有 $3$ 个点能选择，一共有 $3$ 种不同的情况
……

所以一共有 $p!$ 种情况。

所以，被展开了 $k-1$ 次的左子树一共有 $(k-1)!$ 种不同的情况，右子树有 $(i-k-1)!$ 种，和 $\frac {(i-2)!} {(k-1)!(i-k-1)!}$ 乘起来，就得到了 **一棵有 $i$ 个叶子的数，左子树有 $k$ 个叶子的情况数**，而这个值，是 $(i-2)!$，与 $k$ 无关。

所以，无论 $k$ 是多少，情况数都是固定的，而一棵有 $i$ 个叶子的树的总情况数有 $(i-1)!$ 种，所以对于每个 $k$，出现的概率就是 $\frac {(i-2)!} {(i-1)!}=\frac 1 {i-1}$。

于是，求出 $g$ 数组后，最后的答案就是 $\sum_{j=1}^{n-1} f[n][j]$。

你可能会问，期望不应该等于概率乘权值吗？你这是概率的总和啊。

注意看上面的定义：**深度至少为 $j$**，这意味着，一棵 $n$ 个叶子深度为 $j$ 的树，在 $f[n][1],f[n][1],f[n][2],...,f[n][j]$ 中都被统计过，所以他的出现概率被统计了 $j$ 次，就相当于概率乘以深度 $j$ 了。

于是代码如下：
```cpp
#include <cstdio>
#define maxn 110

int type,n;
double f[maxn];
void work1()
{
	for(int i=2;i<=n;i++)
	f[i]=f[i-1]+2.0/i;
	printf("%.6lf",f[n]);
}
double g[maxn][maxn],ans=0;
void work2()
{
	for(int i=1;i<=n;i++)
	g[i][0]=1;
	for(int i=2;i<=n;i++)
	for(int j=1;j<i;j++)
	for(int k=1;k<i;k++)
	g[i][j]+=(g[k][j-1]+g[i-k][j-1]-g[k][j-1]*g[i-k][j-1])/(i-1);
	for(int i=1;i<n;i++)
	ans+=g[n][i];
	printf("%.6lf",ans);
}

int main()
{
	scanf("%d %d",&type,&n);
	if(type==1)work1(); else work2();
}
```

后来想了想，为什么 $g$ 数组的定义是深度至少为 $j$，而不能恰好为 $j$ 呢？

事实上，是可以的，但是复杂度就会从 $n^3$ 变成 $n^4$。

在转移的时候，先看左子树，假如左子树深度为 $j-1$，那么右子树的深度只能是 $1$ ~ $j-2$，假如右子树深度为 $j-1$，左子树深度就只能是 $1$ ~ $j-2$，或者两棵子树深度都是 $j-1$。

而 $1$ ~ $j-2$ 这部分就需要再来一个循环进行累加了（不过多处理一个前缀和数组事实上还是可以把复杂度变回 $n^3$ 了）。

最后统计答案的时候，就变成了 $\sum_{j=1}^{n-1}f[n][j]\times j$ 了。

代码如下：
```cpp
#include <cstdio>
#define maxn 110

int type,n;
double f[maxn];
void work1()
{
	for(int i=2;i<=n;i++)
	f[i]=f[i-1]+2.0/i;
	printf("%.6lf",f[n]);
}
double g[maxn][maxn],ans=0;
void work2()
{
	g[1][0]=1;
	for(int i=2;i<=n;i++)
	for(int j=1;j<i;j++)
	for(int k=1;k<i;k++)
	{
		double tot1=0,tot2=0;
		for(int l=0;l<=j-1;l++)tot1+=g[i-k][l];
		for(int l=0;l<j-1;l++)tot2+=g[k][l];
		g[i][j]+=(g[k][j-1]*tot1+g[i-k][j-1]*tot2)/(i-1);
	}
	for(int i=1;i<n;i++)
	ans+=g[n][i]*i;
	printf("%.6lf",ans);
}

int main()
{
	scanf("%d %d",&type,&n);
	if(type==1)work1(); else work2();
}
```

---

## 作者：_Arahc_ (赞：13)

**upd**：一个转移的 $j,y$ 打反了，已更正。此外修复了部分错别字，图床换源。

## 题目大意

[题目传送门](https://www.luogu.com.cn/problem/P3830)。

> 一个初始情况只有根节点的二叉树，定义一个点的深度是这个点到根节点的路径边数，根节点深度为 $0$，一颗树的深度是所有点深度最大值。每次等概率地选择一个叶子，给它挂上一对左右儿子。直到叶子数量为 $n$。求：所有叶子节点平均深度的期望、整个树深度的期望，结果保留六位小数。（$n\leqslant 300$）

原题目是 $n\leqslant 100$，我加强一下，$n\leqslant 300$，卡一卡 $n^4$ 暴力。

## 题解

### 平均深度

朴素的概率 DP（裸题）里面很少出现求一个**平均**的东西的概率。不过还是可以尝试用平时写裸 DP 的方式去试一波。设 $f_i$ 表示已经建了 $i$ 个叶子，此时所有叶子的深度平均值。我们知道平均深度等于总深度除以叶子数，所以 $i$ 个叶子的树叶子深度之和为 $f_i\times i$。

考虑我现在造了一个树，这个树上对于某一个节点 $i$，深度为 $dep_i$，给 $i$ 挂一对儿子会对总的深度造成多少影响。首先这个点不再是叶子了，所以要减掉一个 $dep_i$，然后多了俩叶子，深度是这个叶子 $+1$。因此加上 $2dep_i+2$。总的贡献为：$dep_i+2$。同时叶子数量多 $1$，从 $f_{i-1}$ 转移到 $f_i$。

$i-1$ 个叶子，选到任意一个的概率都是 $\frac{1}{i-1}$，所以有：

$$
\begin{aligned}
f_i\times i
&=f_{i-1}\times(i-1)+\sum_j^{i-1}\frac{dep_j+2}{i-1} \\
&=f_{i-1}\times i-f_{i-1}+\sum_j^{i-1}\frac{dep_j}{i-1}+\frac{2(i-1)}{i-1} \\
\end{aligned}
$$

其中 $\sum_j^{i-1}\frac{dep_j}{i-1}$ 就是 $i-1$ 个叶子的平均深度，所以 $\sum_j^{i-1}\frac{dep_i}{i-1}=f_{i-1}$，所以有：

$$f_i\times i=f_{i-1}\times i+2$$

得到 $f_i=f_{i-1}+\frac{2}{i}$，初始值 $f_1=0$（唯一的叶子就是根节点），$\operatorname{O}(n)$ 递推即可。

### 总深度

#### 四次方级别

第二问求总深度期望。我们沿着上一问的思路，发现只设一维不太好转移。所以设 $f_{i,j}$ 表示有 $i$ 个叶子，此时深度为 $j$，这样子的树出现的概率。我们都知道期望就是值与对应概率乘积的和。注意根节点深度为 $0$，根据定义式：

$$Ans=\sum_{i=1}^{n-1} f_{n,i}\times i$$

考虑如何求出状态转移。不妨枚举根节点的左子树内部的情况。设 $p_{i,j}$ 表示一共有 $i$ 个叶子，其中 $j$ 个在根的左子树的概率。因为根节点的深度为 $0$，所以下图绿色部分的深度，等于两个红色部分深度的较大值加 $1$。

![](https://pic.imgdb.cn/item/617b95f02ab3f51d91e53e32.png)

因此我们枚举左子树的子树（LeftLeftSon 和 LeftRightSon）情况，当这两边有一边的深度为 $j-1$ 时，总的深度就是 $j$。所以有：

$$f_{i,j}=\sum_{k=1}^{i-1}p_{i,k}\times\sum_{x=1}^{j}\sum_{y=1}^{j}f_{k,x}\times f_{i-k,y} [x=j-1 \lor y=j-1]$$

因为后面两个 sigma 的条件是 $x,y$ 有一个满足是 $j-1$，所以没必要套起来。时间复杂度 $\operatorname{O}(n^4)$，原题可以用这个糊过去。但是实际上还有 $n^3$ 的做法。

#### 三次方级别

我们仍然假设 $p_{i,j}$ 表示一共有 $i$ 个叶子，其中 $j$ 个在根的左子树的概率。但是因为原本的 $f$ 状态行不太通，我们考虑换一下。

设 $f_{i,j}$ 表示有 $i$ 个叶子，且深度**大于等于** $j$ 的概率。

还是可以考虑根的左儿子的两个子树的情况，只要有一边的深度大于等于 $j-1$，整个树的深度就大于等于 $j-1$。因此分别考虑左子树和右子树是否有一边深度大于等于 $j-1$，注意两边都有可能大于等于 $j-1$，因此需要去除重复算的部分：

$$f_{i,j}=\sum_{k=1}^{i-1}p_{i,k}\times(f_{k,j-1}+f_{i-k,j-1}-f_{k,j-1}\times f_{i-k,j-1})$$

我们发现少枚举了一些东西。假设 $p$ 可以用视为常数的方法算出来，那么时间复杂度就是 $\operatorname{O}(n^3)$。现在最大的问题就是怎么求出 $p$ 的值。

考虑第一个 sigma 中枚举了一个 $k$ 表示左子树的叶子个数。我们来看看左子树里有恰好 $k$ 个叶子的树如何生成。首先第一步一定是根节点挂叶子。然后左子树与右子树以某种顺序挂叶子，只要左子树挂了 $k-1$ 次就够了。也就是说左子树要挂 $k-1$ 次，右子树要挂 $i-k-1$ 次。

挂的顺序并不影响左右子树叶子的个数，因此只要是 $k-1$ 次左边和 $i-k-1$ 从右边组成的挂节点顺序就可以了。两次挂左边顺序不影响，因此就是 $(i-k-1)+(k-1)$ 次挂子树机会里面选择 $k-1$ 个当成挂左边的组合数，即：$C_{i-2}^{k-1}=\frac{(i-2)!}{(k-1)!(i-k-1)!}$。

然后考虑左子树生成的方案数。也就是求挂 $k-1$ 次叶子可以生成多少种 $k$ 个叶子的树。$1$ 个叶子只有一种方法，$2$ 个叶子也只有一种方法。$3$ 个叶子有 $2$ 种方法，$4$ 个叶子有 $6$ 种方法……我们发现 $k$ 个叶子有 $(k-1)!$ 种方法。具体的证明，可以简单数学归纳：设 $k$ 个叶子有 $a_k$ 种方法，而 $k$ 个叶子相当于 $k-1$ 个叶子的情况任选叶子挂新节点，有 $a_k=a_{k-1}\times(k-1)$。

同理，右子树叶子数为 $i-k$，生成的方案数为 $(i-k-1)!$。两种方法相乘，总共有 $(k-1)!(i-k-1)!$ 种方案。乘上前面求出的左右子树生成顺序的方案数 $\frac{(i-2)!}{(k-1)!(i-k-1)!}$。我们发现生成一个左子树有 $k$ 个叶子，右子树有 $i-k$ 个叶子的树的方案数为 $(i-2)!$，与 $k$ 没有什么关系了。

回到 $p$ 的定义，$p_{i,j}$ 表示一共有 $i$ 个叶子，其中 $j$ 个在根的左子树的概率。我们知道了生成叶子是等概率纯随机的，而且与几个在左子树没有关系。也就是说 $p_{i,j}$ 与 $j$ 无关。而左子树至少有一个叶子（只要它不是根节点单独成叶子）。因此左子树的叶子数有：$1,2,3,\cdots,i-1$ 几种可能。因为是等概率的，所以我们得到：

$$\forall i,j,p_{i,j}=\frac{1}{i-1}$$

所以原转移方程变成了：

$$f_{i,j}=\sum_{k=1}^{i-1}\frac{f_{k,j-1}+f_{i-k,j-1}-f_{k,j-1}\times f_{i-k,j-1}}{i-1}$$

初始值为 $\forall i,f_{i,0}=1$。不难发现这样的递推是 $\operatorname{O}(n^3)$ 的。最后还剩下一个问题，我已经求出来这些 $f$ 了，最后的答案又是什么？

回到 $f$ 的状态设计：$f_{i,j}$ 表示有 $i$ 个叶子，且深度大于等于 $j$ 的概率。我们知道 $n$ 个叶子的树，深度不超过 $n-1$。因此我们设 $g_{i,j}$ 表示有 $i$ 个叶子，深度等于 $j$ 的概率。根据上面 $n^4$ 做法：

$$Ans=\sum_{i=1}^{n-1} g_{n,i}\times i$$

而且可以知道：

$$f_{i,j}=\sum_{k=j}^{n-1} g_{i,k}$$

我们对所有的 $f_{n,j}$ 求和：

$$
\begin{aligned}
\sum_{i=1}^{n-1} f_{n,i}
&=\sum_{i=1}^{n-1}\sum_{j=i}^{n-1} g_{n,j} \\
&=\sum_{i=1}^{n-1} g_{n,i}\times i \\
&=Ans
\end{aligned}
$$

因此，最后的答案就是 $\sum_{i=1}^{n-1} f_{n,i}$。

### 代码

都是推式子，程序实现没有很困难的地方。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int max_n=303;
inline int read(){
	int x=0;bool w=0;char c=getchar();
	while(c<'0' || c>'9') w|=c=='-',c=getchar();
	while(c>='0' && c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();
	return w?-x:x;
}

int n,T;
double f1[max_n],f[max_n][max_n];

signed main(){
	T=read()-1,n=read();
	if(T){
		for(register int i=0;i<=n;++i)
			f[i][0]=1;
		for(register int i=1;i<=n;++i)
			for(register int j=1;j<=i-1;++j){
				f[i][j]=0;
				for(register int k=1;k<=i-1;++k)
					f[i][j]+=f[k][j-1]+f[i-k][j-1]-f[k][j-1]*f[i-k][j-1];
				f[i][j]/=i-1;
			}
		double ans=0.0;
		for(register int i=1;i<=n-1;++i)
			ans+=f[n][i];
		printf("%.6lf",ans);
	}
	else{
		f1[1]=0;
		for(register int i=2;i<=n;++i)
			f1[i]=f1[i-1]+2.0/i;
		printf("%.6lf",f1[n]);
	}
	return 0;
}

```

---

## 作者：asuldb (赞：12)

感觉第一问就非常神仙，还有第二问怎么被我当成组合数学题来做了

首先是第一问

期望具有线性性，于是**深度平均值的期望等于深度和的期望值的平均**

设$dp_x$表示具有$x$个叶子节点的树的深度和的期望值是多少

我们发现扩展一个叶子节点的实质将其变成两个深度原来大一的叶节点，所以对整个答案的贡献也就是这个被扩展的叶子节点的深度乘$2$，再加上$2$

比如我们当前扩展的是叶子节点$1$，那么答案就从$dep_1+dep_2+...+dep_x$变成了$2*(dep_1+1)+dep_2+...+dep_x$

$dep_2,dep_3$同理，也就会发现在最终的答案里每个$dep$都出现了$x+1$次

设$dp[x]$表示$x$个叶子节点的期望深度和，$dp[x]=\sum_{i=1}^xdep_x$

那么期望是

$$dp[x+1]=\frac{\sum_{i=1}^x(dep_x+2)+x*\sum_{i=1}^xdep_x}{x}$$

$$dp[x+1]=\frac{2*x+(x+1)\sum_{x=1}^xdep_x}{x}$$

也就是

$$dp[x+1]=\frac{(x+1)dp[x]+2*x}{x}$$

最后的答案就是$\frac{dp[n]}{n}$了

之后第二问我就感受到了玄学的力量，各种玄学调参数

第二问好像非常麻烦的样子，没有办法像刚才那个样子从平均的角度来考虑了，而直接求期望好像不太好求，于是可以求出概率来

设$dp[x][h]$表示有$x$个叶子节点构成的树深度为$h$的概率是多少，那么答案就是$\sum_{h=1}^ndp[n][h]*h$

我们考虑一下如何求这个$dp[n][h]$

有一个比较套路的东西就是枚举左右子树有几个叶子节点

所以就有

$$dp[i][j]=\sum_{k=1}^{i-1}P_{i,k}(dp[k][j-1]*p[i-k][j-1]+dp[i-k][j-1]*p[k][j-1])$$

其中$p[i][j]=\sum_{k=1}^jdp[i][k]$也就是一个概率的前缀和，$P_{i,k}$表示一共$i$个叶子节点其中$k$个在左子树上的概率

也就是枚举左右子树的叶子节点的个数，之后对应好相应的深度，乘上这个转移发生的概率

先不考虑这个$P_{i,k}$怎么求，也会发现上面那个转移好像有些问题，它算重了左右两边子树的深度都是$j-1$的情况，于是上面还需要再减掉$dp[k][j-1]*dp[i-k][j-1]$

现在的问题就变成了$P_{i,k}$怎么求了

首先经过感性理解/手玩样例/归纳证明可以发现，**在不同的扩展顺序下使得左子树上有$k$个叶子节点的概率是一个固定的值**

我们要让左右两边共有$i$个叶子节点，也就是说我们一共需要扩展$i-1$次，**第一次扩展肯定是需要扩展在当前的这个节点上的，于是还要有$i-2$次扩展被分给了左右子树**

我们再来考虑一下使得左子树上有$k$个叶子节点的实质是什么，不就是分给左边的扩展次数为$k-1$吗，**那么这样一共有$\binom{i-2}{k-1}$种扩展情况会使得左子树上扩展了$k-1$次**

又因为这些不同的扩展顺序出现的概率是一样的，所以我们可以考虑一些求出这个概率

这个概率的分母上肯定是$2*3*4*5*...*(i-1)$，因为一共需要扩展产生$i$个节点每次选中左子树或者右子树的概率是$\frac{\text{左/右子树上叶子节点数量}}{\text{叶子节点的总数量}}$，而分子上由于我们在左边一共选择了$k$次，所以分母会有$1*2*..*(k-1)$，也就会有相应的$1*2*...*(i-k-1)$

所以

$$P_{i,k}=\frac{\binom{i-2}{k-1}(k-1)!(i-k-1)!}{(i-1)!}$$

我们再顺便化一下柿子

$$P_{i,k}=\frac{\frac{(i-2)!}{(k-1)!(i-2-k+1)!}(k-1)!(i-k-1)!}{(i-1)!}=\frac{(i-2)!}{(i-1)!}=\frac{1}{i-1}$$

我下面的代码预处理了阶乘和组合数，其实直接用$\frac{1}{i-1}$就好了

~~我才不会说我看到题解才想起来继续化柿子的~~

于是这样转移就好了

代码

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#define re register
#define maxn 105
inline int read()
{
    char c=getchar();
    int x=0;
    while(c<'0'||c>'9') c=getchar();
    while(c>='0'&&c<='9')
        x=(x<<3)+(x<<1)+c-48,c=getchar();
    return x;
}
int opt_Q;
int n;
namespace Ask1
{
    double dp[maxn];
    inline void init()
    {
        n=read();
        dp[1]=0;
        for(re int i=1;i<n;i++)
            dp[i+1]=((i+1)*dp[i]+2*i)/double(i);
        printf("%.6lf",dp[n]/double(n));
    }
}
namespace Ask2
{
    double dp[maxn][maxn+100],pre[maxn][maxn];
    long double fac[maxn];
    long double c[maxn][maxn];
    inline void init()
    {
        n=read();
        dp[1][0]=1;dp[2][1]=1;dp[3][2]=1;
        for(re int i=0;i<=n;i++) pre[1][i]=1;
        for(re int i=1;i<=n;i++) pre[2][i]=1;
        for(re int i=2;i<=n;i++) pre[3][i]=1;
        fac[0]=1;
        for(re int i=1;i<=n;i++) fac[i]=fac[i-1]*i;
        c[0][0]=1;
        for(re int i=1;i<=n;i++) c[i][0]=c[i][i]=1;
        for(re int i=2;i<=n;i++)
            for(re int j=1;j<n;j++)
                c[i][j]=c[i-1][j-1]+c[i-1][j];
        for(re int i=4;i<=n;i++)
            for(re int j=log2(i);j<=n;j++)
            {
                for(re int k=1;k<i;k++)
                    dp[i][j]+=(dp[k][j-1]*pre[i-k][j-1]+dp[i-k][j-1]*pre[k][j-1]-dp[k][j-1]*dp[i-k][j-1])*c[i-2][k-1]*fac[k-1]*fac[i-k-1]/fac[i-1];
                pre[i][j]=dp[i][j]+pre[i][j-1];
            }
        double ans=0;
        for(re int h=log2(n);h<=n;h++)
            ans+=dp[n][h]*h;
        printf("%.6lf",ans);
    }
}
int main()
{
    opt_Q=read();
    if(opt_Q==1) Ask1::init();
        else Ask2::init();
    return 0;
}
```

---

## 作者：kimi0503 (赞：7)

这题前两个子任务比较简单，对于询问$n$，直接将最后扩展出来的点的深度，设为$n-1$时的期望深度加一即可

后两个子任务，考虑原树的左子树有$j$个节点，右子树有$i-1-j$个节点，DP即可。注意DP时要用到两个变量最大值的期望值，所以状态要设为$f[i][d]$表示$i$个节点的树深度为$d$的概率，然后大力转移。

一开始想错了，以为$max(a,b)$的期望值就等于max($a$的期望值,$b$的期望值)。

这个题目告诉我们，某些函数的期望值，不止于各个变量的期望值有关，还跟各个变量的分布有关。


```cpp
#include<cstdio>
namespace solver1{
    int i;
    long double ans;
    long double main(int n){        
        for(i=2;i<=n;++i)ans+=2.0/i;
        return ans;
    }
}
int q,n;
long double ans;
inline int max(int a,int b){
    return a>b?a:b;
}
namespace solver2{
    int i,j,k,l,o;
    long double f[105][105],ans;
    long double main(int n){
        f[1][0]=1;
        f[2][1]=1;
        f[3][2]=1;
        for(i=4;i<=n;++i){
            for(j=1;j<i;++j)
                for(k=0;k<j;++k)
                    for(l=0;l<i-j;++l)f[i][max(k,l)+1]+=f[j][k]*f[i-j][l]/(i-1);
        }
        for(i=1;i<=n;++i)ans+=i*f[n][i];
        return ans;
    }
} 
int main(){
    scanf("%d%d",&q,&n);
    if(q==1)ans=solver1::main(n);
        else ans=solver2::main(n);
    printf("%.6Lf\n",ans);
    return 0;
}
```

---

## 作者：whiteqwq (赞：5)

[P3830 [SHOI2012]随机树](https://www.luogu.com.cn/problem/P3830)解题报告：

[更好的阅读体验](https://zybuluo.com/xiaoziyao/note/1754300)

## 题意

- 最开始给定一个根结点，然后进行$n-1$次操作，每次随机选定一个叶子结点给它添加一对左右子结点，求：
- 1.叶子结点平均深度的期望；
- 2.树深度的期望。
- 数据范围：$1\leqslant n\leqslant 100$。
- **注意：根结点深度为$0$。**

## 分析

期望神仙题。

### 第一问
我们考虑一次对深度为$i$的叶子结点的操作会造成什么影响——减少$1$个深度为$i$的叶子结点，增加两个深度为$i+1$的叶子结点，总贡献为$i+2$。

设$f_i$为$i$个叶子结点的情况下叶子结点平均深度的期望，那么有$f_i=\frac{f_{i-1}\cdot (i-1)+f_{i-1}+2}{i}=f_{i-1}+\frac{2}{i}$，解释一下，下面的$i$是叶子结点个数，上面左边的$f_{i-1}\cdot (i-1)$是原来$i-1$个叶子结点的总深度，$f_{i-1}+2$为新的叶子结点的贡献。

因为边界是$f_1=0$（根结点深度为$0$），因此答案为$\sum_{i=2}^n\frac{2}{i}$。

### 第二问
> 前置知识：正整数的期望公式，即对于正整数随机变量$x$，有$E(x)=\sum_{i=1}^{\infty}P(x\geqslant i)$

> 证明（须配合下方公式一同食用）：

> 第一步很显然是期望的定义，第二步是一个差分（因为$x$是正整数），第三步就是拆了一下式子，可以发现因为$i$趋近于无限，所以可以把求和挪过来一位，因此有了第四步（虽然没有可以挪到$i=1$的式子，但因为$i=1$时$i-1=0$，因此加上可以保持美观），最后相减就可以得到第五个式子了。

> $E(x)=\sum_{i=1}^{\infty}P(x=i)\cdot i$

> $=\sum_{i=1}^{\infty}(P(x\geqslant i)-P(x\geqslant i+1))\cdot i$

> $=\sum_{i=1}^{\infty}P(x\geqslant i)\cdot i-\sum_{i=1}^{\infty}P(x\geqslant i+1)\cdot i$

> $=\sum_{i=1}^{\infty}P(x\geqslant i)\cdot i-\sum_{i=1}^{\infty}P(x\geqslant i)\cdot(i-1)$

> $=\sum_{i=1}^{\infty}P(x\geqslant i)$


设$f_{i,j}$为$i$个叶子结点的情况下，树深度**大于等于**$j$的概率，那么根据上面的正整数期望公式，我们的答案就是$\sum_{i=1}^{n-1} f_{n,i}$（因为根结点深度为$0$，因此不可能深度等于$n$），边界为$f_{i,0}=1$。

然后考虑如何求$f_{i,j}$，可以考虑**枚举左子树的结点个数**，得到$f_{i,j}=\sum_{k=1}^{i-1} P(i,k)\cdot(f_{k,j-1}+f_{i-k,j-1}-f_{k,j-1}\cdot f_{i-k,j-1})$。

解释：前面的$P(i,k)$表示在$i$个叶子结点的树中，左子树有$k$个叶子结点的概率；后面的$f_{k,j-1}+f_{i-k,j-1}-f_{k,j-1}\cdot f_{i-k,j-1}$利用了一种**容斥**的思想，即左子树深度大于等于$j-1$或右子树深度大于等于$j-1$的概率等于它们的概率之和减去它们的概率之积。

然后我们的问题到了怎么求$P(i,k)$，有一个非常神奇的结论：**对于所有的$k\in[1,i-1]$，都有$P(k)$相等，即$P(k)=\frac{1}{i-1}$**。

考虑如何证明，我们发现**对左子树进行的操作是与右子树无关的**，我们**把所有操作分成扩展左子树和右子树**，那么如果扩展了$i-1$次且左子树扩展了$k-1$次，那么右子树扩展了的$k-i-1$次一定与左子树无关（子树的根结点也需要进行一次扩展），因此我们需要用一个式子来表达**选取这样的扩展方案的方案数**：${(k-1)+(i-k-1)\choose k-1}={i-2\choose k-1}=\frac{(i-2)!}{(k-1)!(i-k-1)!}$。

通过组合数我们知道了选定哪些操作，而这些**操作作用在不同的结点上又是不一样的方案**，因此我们还需要计算作用在不同结点上一共有多少种方案。对于左子树，第一次可以作用的结点数为$1$，第二次为$2$，第$k-1$为$k-1$，因此左子树方案数为$(k-1)!$，同理右子树的方案数为$(i-k-1)!$。

将选定操作的方案数和作用在不同结点上的方案数相乘就是左子树$k$个叶子结点，右子树$i-k$个叶子结点的方案：$\frac{(i-2)!}{(k-1)!(i-k-1)!}\cdot (k-1)!\cdot (i-k-1)!=(i-2)!$，它与$k$无关，因此**所有的情况概率相等**。又因为$k$的取值只有$i-1$种，所以$P(k)=\frac{1}{i-1}$。

故转移方程为$f_{i,j}=\sum_{k=1}^{i-1}\frac{1}{i-1}\cdot(f_{k,j-1}+f_{i-k,j-1}-f_{k,j-1}\cdot f_{i-k,j-1})$，答案为$\sum_{i=1}^{n-1} f_{n,i}$。

## 代码
```
#include<stdio.h>
const int maxn=105;
int q,n;
double ans;
double f[maxn][maxn];
int main(){
	scanf("%d%d",&q,&n);
	if(q==1)
		for(int i=2;i<=n;i++)
			ans+=2.0/i;
	if(q==2){
		for(int i=1;i<=n;i++){
			f[i][0]=1.0;
			for(int j=1;j<i;j++)
				for(int k=1;k<i;k++)
					f[i][j]+=1.0/(i-1)*(f[k][j-1]+f[i-k][j-1]-f[k][j-1]*f[i-k][j-1]);
		}
		for(int i=1;i<n;i++)
			ans+=f[n][i];
	}
	printf("%.6lf\n",ans);
	return 0;
}
```

---

## 作者：tommymio (赞：5)

思考整个展开的过程。看上去有点像超现实树（雾

每次选择一个叶子节点展开后叶子节点数增加 $1$。那么对于一个 $n$ 个节点的树，可以有 $1\times 2\times 3\times...\times (n-1)=(n-1)!$ 种方案展开。

现在来解决第一问。设 $f_i$ 为展开 $i-1$ 次后，期望叶节点的平均深度。则有：

$$
f_i=\frac{(i-1)f_{i-1}+f_{i-1}+2}{i}=f_{i-1}+\frac{2}{i}
$$

继续考虑一棵叶子节点数 $n\geq 2$ 的树，必然在根节点处展开了一次，其根的左、右子树内节点数不小于 $1$。那不妨用根作为分界点，这里我们需要用到一个结论。设根的左子树内叶子节点数为 $k$，右子树内叶子节点数为 $n-k$。那么左子树需要展开 $k-1$ 次，右子树需要展开 $n-k-1$ 次。将展开过程看成一个在左右子树上的操作序列的话，总共有 $\binom{n-k-1+k-1}{n-k-1}$ 种方案。其中，左子树具体的展开有 $(k-1)!$ 种，右子树具体的展开有 $(n-k-1)!$ 种。那么当展开后左子树内叶子节点有 $k$ 个，右子树内叶子节点有 $n-k$ 个时，总共有 $(n-2)!$ 种方式展开，也就是说与具体的 $k$ 无关。

想想期望的定义式，枚举深度，我们只需要求出达到这个最大深度的概率。但是求 $P(X=x)$ 是非常困难的，可以通过将求 $P(X=x)$ 转化为 $P(X\geq x)-P(X\geq x+1)$ 的方式求解。设 $f_{i,j}$ 为 $i$ 个叶子节点的树，深度为 $j$ 的概率，那么有：

$$
f_{i,j}=\frac{(i-2)!}{(i-1)!}\sum_{k=1}^{i-1}(f_{k,j-1}+f_{i-k,j-1}-f_{k,j-1}\times f_{i-k,j-1})
$$

初值为 $f_{1,0}=1.00$，最终答案就为 $\sum\limits_{i=0}^{n-1}(f_{n,i}-f_{n,i+1})\times i$，可以化为 $\sum\limits_{i=1}^{n-1} f_{n,i}$。

```cpp
#include<cstdio>
double f[105][105];
int main() {
    int q,n; scanf("%d%d",&q,&n);
    double ans=0.00;
    if(q==1) {
        for(register int i=2;i<=n;++i) ans+=2.00/i;
        printf("%.6lf\n",ans);
    }
    else {
        f[1][0]=1.00;
        for(register int i=2;i<=n;++i) {
            f[i][0]=1.00;
            for(register int j=1;j<i;++j) {
                for(register int k=1;k<i;++k) {//At least there is a son in the left/right subtree 
                    f[i][j]+=f[k][j-1]+f[i-k][j-1]-f[k][j-1]*f[i-k][j-1];
                }
                f[i][j]/=1.00*(i-1);
            }
        }
        for(register int j=1;j<n;++j) ans+=f[n][j];
        // for(register int j=1;j<n;++j) ans+=(f[n][j]-f[n][j+1])*j;
        printf("%.6lf\n",ans);
    }
    return 0;
}
```



---

## 作者：Jμdge (赞：3)

P3830 随机树

坑题，别人的题解我看了一个下午没一个看得懂的，我还是太弱了。

[blog 戳这里](https://www.cnblogs.com/Judge/p/9837561.html)

 

第一问很水，考虑每次新拓展节点就是让树的总深度加上 2 

也就是: $$f[i]= \dfrac{f[i-1]*(i-1) + f[i-1] + 2 }{i}$$

 

意思就是原来 i-1 个节点的平均深度，乘上 (i-1) 变成深度和，然后再加一次 平均深度，然后加 2 ，除以 i 个叶子结点得到当前答案。

化简后式子就变成了: $$f[i]=f[i-1] + \dfrac{2} {i} $$

 

然后来到第二问（关键问题）。

 

首先这是概率期望 dp ，于是我们考虑设计状态。

 

那么我们让 $f[i][j]$ 表示 i 个叶子节点，深度为 j 的概率（是概率）。

 

那么转移就是： $$ f[i][j] = \dfrac{ f[k][j-1] + f[i-k][j-1]-f[k][j-1] \times f[i-k][j-1] } {i-1} $$

其中 f[i][j] 表示新树状态，f[k][j-1] 为左子树状态，f[i-k][j-1] 为右子树状态。

 

很多题解到这儿就没了，就没了！也不解释一下的说（尤其 i-1 解释的是真草率）。

 

最后我自己口胡了一下大概可能也许想通了。

首先 f[i][j] 是我们现在构造出的树的状态，也就是说我们用两个子树拼凑出了一棵新树，而根是新加节点（新加节点会使得左右子树所有叶子结点深度均增加 1 ）。

所以这点很重要，也是尤其关键的一步，在强调一遍，f[i][j] 只是代表了新树的形态，且是已经确定了的形态。

那么形成这棵树的概率也就是上面的转移式了，左子树有 j-1 个节点的概率 + 右子树有 j-1 个节点的概率 - 左右子树同时有 j-1 个节点的概率（容斥）。

接着呢？ 我们考虑除去 i-1 的意义（自己的想法而已）：

 

我们让当前的这棵树回到上一个状态，也就是说我们令这棵树最后一次叶子结点的扩展取消，回到 i-1 的状态。 （请脑补）

然后聪明的你已经想出来了，这时候要达到当前状态的概率是？ 当然是 1/(i-1) 。因为当前这棵树删除的节点扩展回来的概率就是 1/(i-1)。

 

然后问题就解决了，放代码（非常短啊）。

 

 ```

 1 //by Judge
 2 #include<iostream>
 3 #include<cstdio>
 4 using namespace std;
 5 int q,n; double ans,f[111][111];
 6 int main(){ scanf("%d%d",&q,&n);
 7     if(q==1){
 8         for(int i=2;i<=n;++i) ans+=2.0/i;
 9         return printf("%.6lf\n",ans),0;
10     } f[1][0]=f[2][1]=f[3][2]=1;
11     for(int i=4;i<=n;++i) for(int j=1;j<=n;++j)
12         for(int k=0;k<j;++k) for(int l=0;l<i-j;++l)
13             f[i][max(k,l)+1]+=(f[j][k]*f[i-j][l])/(i-1);
14     for(int i=1;i<n;++i) ans+=f[n][i]*i; return printf("%.6lf\n",ans),0;
15 }
 ```

---

## 作者：csyakuoi (赞：2)

#乱搞AC了！

第一问见其它题解。

第二问：设$dp[i][j]$表示$i$个节点的树，深度不超过$j$的概率，枚举左子树节点个数转移。设左子树节点有$k$个，则$dp[i][j]+=dp[k][j-1]*dp[i-k][j-1]$。

代码：
```cpp
#include<cstdio>
using namespace std;
#define db double

int n,task_id;
db dp1[100],dp2[100][100];

int main(void)
{
	scanf("%d%d",&task_id,&n);
	if(task_id==1){
		dp1[0]=0;
		for(int i=1;i<n;i++)
			dp1[i]=dp1[i-1]+2.0/(i+1);
		printf("%lf\n",dp1[n-1]);
	}
	else{
		for(int i=0;i<n;i++)
			dp2[0][i]=1;
		for(int i=1;i<n;i++){
			for(int j=1;j<n;j++){
				dp2[i][j]=0;
                //左子树有k个节点
				for(int k=1;k<=i;k++)
					dp2[i][j]+=dp2[k-1][j-1]*dp2[i-k][j-1];
			}
			for(int j=1;j<n;j++)
				dp2[i][j]/=dp2[i][n-1];
		}
		db ans=0;
		for(int i=1;i<n;i++)
			ans+=(dp2[n-1][i]-dp2[n-1][i-1])*i;
        //方案数转概率
		printf("%lf\n",ans);
	}
	return 0;
}
```

---

## 作者：Rosyclouds (赞：1)

## 6830: [BZOJ2830]随机树

##### Q1:f[x]表示有x个叶子节点时的平均深度
    

$$
f[x]=\frac{f[x-1]*(x-1)+f[x-1]+2}{x}=f[x-1]+\frac{2}{x}
$$
##### Q2:f[x][y]表示有x个叶子节点，树深度>=y的概率



$$
f[x][y]=\sum_{k=1}^{i-1}\frac{f[k][y-1]+f[i-k][y-1]-f[k][y-1]*f[i-k][y-1]}{i-1}
$$

**其中 f[k][y-1]f[i-k][y-1] 是左右子树深度都>=j的概率，在之前被加了2次**

接下来的问题是证明 

#### 左右叶节点不同的出现的概率相等(本题核心)

举个例子，100个叶子节点的树，我们要证明
左边99个叶子节点,右边1个叶子节点的树出现的概率与两边都是50个叶子节点的树一样

接下来就是玄学的数学证明：

设一颗树有**i**个叶子节点，左子树有**k**个叶子节点，刚开始一定数从根展开，则左右子树分别还需展开(**k**-**1**)，(**i**-**k**-**1**)次;

我们可以发现根节点展开的顺序和最终结果无关

我们可以这样展开:

#### LLLRRR

也可以这样

#### LRRLRL

那么展开顺序的方案有
$$
C_{k-1+i-k-1}^{k-1}=C_{i-2}^{k-1}=\frac{\left(i-2\right)!}{\left(k-1\right)!\left(i-k-1\right)!}

$$
我们可以发现第一次展开时，只能选一个根节点，第二次可以选两个，第三次三个，所以展开k次的方案有 k！ 种

则左右子树分别展开(k-1),(i-k-1)的方案为

$$
\left(k-1\right)!\left(i-k-1\right)!
$$

总方案为 **展开顺序方案 × 展开方案**

也就是
$$
\left(i-2\right)!
$$

### 这居然和k无关！，所以我们之前的猜想是正确的

# ohohohohohohohohohoh!!!!!

可以开香槟庆祝了

完美结束

---

## 作者：derta (赞：0)

## $q=1$ 时
设 $f_i$ 为有 $i$ 个叶子时的答案

可以发现，新展开的两个叶子的期望深度为 $f_{i-1}+1$，故深度和的期望为 $2(f_{i-1}+1)+(i-1-1)f_{i-1}$，化简得

$$f_i=f_{i-1}+\frac{2}{i}$$

边界为 $f_{2}=1$，可以发现

$$f_n=2\sum_{i=2}^{n}\frac{1}{i}$$

暴力计算即可，时间复杂度 $O(n)$

## $q=2$ 时
这才是该题的重点

设 $P(x)$ 为事件 $x$ 发生的概率

答案即为

$$\sum_{i=1}^{n}i \cdot P(\textit{depth}=i)$$

发现这并不好计算，故转化为

$$\sum_{i=1}^{n}P(\textit{depth} \geq i)$$

令 $f_{i,j}$ 表示叶子数为 $i$，深度大于等于 $j$ 的概率

可以发现，叶子数为 $i$ 且深度大于等于 $j$ 等价于 根的左子树或右子树深度大于等于 $j-1$

故枚举左子树的叶子数量 $k$，并加上此时深度大于等于 $j$ 的概率乘上这种情况出现的概率。前者显然是 $f_{k,j-1}+f_{i-k,j-1}-f_{k,j-1}f_{i-k,j-1}$（注意到左右字数深度均大于等于 $j-1$ 的情况会被算两次，故减去之），那么只需求这种情况出现的概率即可

经过打表，猜测概率为 $\dfrac{1}{i-1}$（换句话说，对于每个 $k$ 概率相等）。考虑采用数学归纳法证明：

- $i=2$ 时，显然成立
- 设 $i=t-1$ 时成立，有两种情况
  - 在左子树展开，可能性 $\dfrac{k-1}{t-1}$。此时概率为 $\dfrac{k-1}{(t-2)(t-1)}$
  - 在右子树展开，可能性 $\dfrac{t-k-1}{t-1}$。此时概率为 $\dfrac{t-k-1}{(t-2)(t-1)}$
  加起来，即可得出概率为 $\dfrac{1}{t-1}$，得证

故转移方程为

$$f_{i,j}=\sum_{k=1}^{i-1}\frac{1}{i-1}(f_{k,j-1}+f_{i-k,j-1}-f_{k,j-1}f_{i-k,j-1})$$

朴素转移即可

---

## 作者：昨日之日 (赞：0)

luogu P3830 


已知叶节点的总数，求（1）叶节点平均深度的数学期望（2）树的深度的平均期望

###### 子问题1

 1.1设F（i）表示叶节点个数为i是的平均深度的期望。
 
（一个事实：展开一次，多出两个深度相同的结点，多出一个叶节点）。
 事实上在计算时可以直接看成在深度为F（i-1） 的一个叶节点上展开//期望->平均。
    
于是展开的两个结点之后深度增加了 $2（F（i-1）+1）-F（i-1）$
从而得出方程        
$$ F（i）=F（i-1）+\dfrac{2}{i} $$
当叶节点只有1个时，显然 $F（1）=0 $。



------------

1.2$ F(i）= \dfrac{F(i-1)*(i-1)+F(i-1)+2}{i}$

------------
###### 子问题2

 2.1 f[i][j]表示对于一颗随机的有i个叶子的树，树的深度>=j的概率。
 
 显然树的深度==max（左子树，右子树）+1
 
 故对于一颗有i个叶子结点，左子树的叶子结点个数为k个的树（右子树结点个数为i-K)
 
 深度>=j的概率P为
       $ P=f[k][j-1]+f[i-k][j-1]-f[k][j-1]*f[i-k][j-1]$//期望的线性性
   (在计算$f[k][j-1]$与$f[i-k][j-1]$的时候事实上已经包含了另一颗子树深度>=j-1的情况，算了两次，所以应当减去)
       
 代码中的f[i][j]计算的是概率，但是最后要求的答案是期望，E(x)=$\sum_1^n$p(i)*x(i)  。在这个算法中，对于一个dp[i][j]，答案在dp[i][1]~dp[i][j]中都出现过，就相当于已经乘了一个x（i）=j，最后得到的就是期望
 ```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =105;
int q,n;
double F[N];
double f[N][N];
int main(){
	cin>>q>>n;
	if(q==1){
		F[1]=0;
		for(int i=2;i<=n;++i)
			F[i]=F[i-1]+2.0/i;
		printf("%.6f\n",F[n]);
	}
	else {
		for(int i=1;i<=n;++i)
			f[i][0]=1;
		for(int i=2;i<=n;++i){
			for(int j=1;j<i;++j){
				for(int k=1;k<i;++k)
					f[i][j]+=f[k][j-1]+f[i-k][j-1]-f[k][j-1]*f[i-k][j-1];
				f[i][j]/=(i-1);
			}
		}
		double ans=0;
		for(int i=1;i<n;++i)
			ans+=f[n][i];
		printf("%.6f\n",ans);
	}
}
```
###### 对于代码中除以i-1的解释：
设想一下，如果让这颗树回到上一个状态（取消展开），上一个状态到当前状态的概率就是 
 $\dfrac{1}{i-1}$
 
 ~~自己yy出来的，不知道是不是这样解释~~

 ~~可能是最近推的最认真的一道题了~~

---


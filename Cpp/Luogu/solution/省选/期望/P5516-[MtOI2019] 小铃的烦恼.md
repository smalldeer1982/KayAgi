# [MtOI2019] 小铃的烦恼

## 题目背景

在幻想乡中，本居 小铃(Motoori Kosuzu)不仅经常被人撞，还要整理铃奈庵的书籍，她有很多烦恼。

## 题目描述

小铃每天都会整理一次铃奈庵的书籍。这次桌子上有 $n$ 本魔法书，这些书一次排成一排，每本书有一个魔法属性和编号。

最开始这些书的魔法属性都是一样的，但是因为被人多次使用，魔法属性发生了变化，小铃想让所有书的魔法属性重新全部相同。

这次小铃找到了雾雨 魔理沙(Kirisame Marisa)帮忙整理书籍，每次魔理沙可以释放选定魔法，魔法会随机选择两本书 $a,b$ ( $a$ 不等于 $b$ )。

选定这两本书后，魔理沙会释放转移魔法，使得有 $p_{a,b}\ (p_{a,b}\in (0,1])$ 的概率，第 $b$ 本书的魔法属性变成第 $a$ 本书的魔法属性。也就是说有 $1-p_{a,b}$ 的概率，使得你**即使选定了 $a,b$ 两本书，但是魔法属性的转移不成功，意味着这次操作是无效的** 。

注意 $p_{a,b}$ 是对于**转移是否成功的概率**，和随机选择两本书的操作互不影响。

现在小铃想知道，求期望操作多少次，才能使所有的书魔法属性都一样？由于时间紧迫，小铃找到了你，希望你可以帮其解决这个问题，不然小铃就不会给你这题的分了。

## 说明/提示

对于前 $10\%$ 的数据，$n\leq 10$，且最多有一种不同的魔法属性。

对于另外 $20\%$ 的数据，$n\leq10$，且最多有两种不同的魔法属性，并且其中一种的魔法属性的个数小于等于 $1$  。

对于 $100\%$ 的数据，$n\leq2\times 10^3$ 。

对于所有数据，满足 $\left(\sum\limits_{a=1}^{n}\sum\limits_{b=1}^{n}p_{a,b}\right) = n^2$ 。

### 题目来源

[迷途之家2019联赛](https://www.luogu.org/contest/20135)(MtOI2019) T3

出题人：Qiuly 


## 样例 #1

### 输入

```
NACLYFISHAKIOI
1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0
1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0
1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0
1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0
1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0
1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0
1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0
1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0
1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0
1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0
1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0
1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0
1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0
1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0```

### 输出

```
164.9```

## 样例 #2

### 输入

```
DSGAY
1.0 1.0 1.0 1.0 1.0
1.0 1.0 1.0 1.0 1.0
1.0 1.0 1.0 1.0 1.0
1.0 1.0 1.0 1.0 1.0
1.0 1.0 1.0 1.0 1.0

```

### 输出

```
16.0```

# 题解

## 作者：Scarlet_Hypoc (赞：19)

建议进博客看，不然LaTeX可能会炸qwq。

顺便安利一下蒟蒻的[CSDN博客](https://blog.csdn.net/a_forever_dream/article/details/105512284)。

根据 $\sum_{i=1}^n\sum_{j=1}^ns_{i,j}=n^2$ 这个约束，显然每个 $s_{i,j}$ 恒定为 $1$，也就是每次操作总会成功，所以可以忽略`成功概率`这个东西。

最后全部元素会相同，但是不知道是什么元素，所以我们需要枚举最后的元素（下面称为目标元素）是谁。

然后又发现，一种元素最后成为目标元素的概率，取决于一开始序列中有多少个这种元素，而每次操作，有概率使目标元素增加或减少 $1$，也可能不变，于是得到 $dp$ 方程：设 $p[i]$ 表示此时有 $i$ 个目标元素，使全部元素都变成目标元素的概率是多少。

那么有：
$$
\begin{aligned}
p[i]=\frac {i(n-i)} {n(n-1)} p[i-1]+\frac {i(n-i)} {n(n-1)}p[i+1]+(1-2\frac {i(n-i)} {n(n-i)})p[i]
\end{aligned}
$$

意思是，有 $\frac {i(n-i)} {n(n-1)}$ 的概率目标元素 $-1$，也有 $\frac {i(n-i)} {n(n-1)}$ 的概率 $+1$，剩下的概率就是不变，这个概率应该很好理解。

整理一下就是 $p[i]=\frac {p[i-1]+p[i+1]} 2$。

$\because p[i+1]-p[i]=p[i+1]-\frac {p[i+1]+p[i-1]} 2=\frac {p[i+1]-p[i-1]} 2$
且 $p[i]-p[i-1]=\frac {p[i+1]+p[i-1]} 2-p[i-1]=\frac {p[i+1]-p[i-1]} 2$
$\therefore p[i+1]-p[i]=p[i]-p[i-1]$ ，即 $p$ 是个等差数列

显然的，因为 $p[0]=0$（没有目标元素，不可能使全部元素变成目标元素），以及 $p[n]=1$（已经满足全部都是目标元素了），所以得到 $p[i]=\frac i n$。

为了方便，下面称`能使所有元素变为目标元素`为`有解`。

求出概率之后，**在这基础上**，考虑期望步数，因为如果无解的话，步数就无从谈起了。

设 $f[i]$ 表示有 $i$ 个目标元素，使全部元素变成目标元素的期望步数。

方程类似上面 $p[i]$ 的方程，但是只考虑`目标元素变化`的情况。可以发现，目标元素变化（$+1$ 或 $-1$）的概率为 $\frac {2i(n-i)} {n(n-1)}$，即操作 $1$ 次，期望变化 $\frac {2i(n-i)} {n(n-1)}$，我们要使得变化为 $1$，就要操作它的倒数 $\frac {n(n-1)} {2i(n-i)}$ 次，也就是满足`操作次数*单次操作变化量=总变化量`。

于是可以得到方程：
$$
p[i]f[i]=p[i]\times \frac {n(n-1)} {2i(n-i)}+\frac 1 2 p[i-1]f[i-1]+\frac 1 2 p[i+1]f[i+1]
$$

前面的 $\frac {n(n-1)} {2i(n-i)}$ 也就是操作次数，操作完后，参照上面 $p$ 的方程，可以发现目标元素数量 $-1$ 和 $+1$ 的概率相同，所以这里有一半几率转移到 $f[i-1]$，有一半几率转移到 $f[i+1]$。

以及上面的 $f[i]$ 前面乘了 $p[i]$，因为只有 $p[i]$ 的概率存在 $f[i]$（即有解），另外有 $1-p[i]$ 的概率无解，所以 $f[i]$ 能做出的期望贡献其实只有 $p[i]\times f[i]$。

以及在操作次数前乘的 $p[i]$ 也是类似的：只有 $p[i]$ 的概率往有解的方向转移。既然是往有解的方向转移了，那么后面的 $f[i-1]$ 和 $f[i+1]$ 自然也要乘上 $p[i-1]$ 和 $p[i+1]$。

由于 $p[i]$ 我们是知道的，所以整理一下这个柿子就变成了：
$$
\begin{aligned}
f[i]&=\frac {n(n-1)} {2i(n-i)}+\frac {i-1} {2i}f[i-1]+\frac {i+1} {2i}f[i+1]\\
f[i]-\frac {i-1} {2i}f[i-1]-\frac {i+1} {2i}f[i+1]&=\frac {n(n-1)} {2i(n-i)}
\end{aligned}
$$

边界的话显然有 $f[n]=0$，这样我们就得到了 $n-1$ 个方程，用高斯消元解一波就得到 $f$ 了。

什么？你说 $O(n^3)$ 过不了？不不不，这题我们需要用有技巧的高斯消元，只用 $O(n)$。

观察上式发现，第 $i$ 个方程只有第 $i-1,i,i+1$ 三项有系数，以及当 $i=1$ 时，$f[0]$ 的系数是 $0$，也就是大概长这样（$x$ 表示系数不为 $0$）：
$$
\begin{matrix}
& 0 & 1 & 2 & 3 & 4 & 5\\
1 & 0 & 1 & x_1 & 0 & 0 & 0\\
2 & 0 & x_2 & 1 & x_3 & 0 & 0\\
3 & 0 & 0 & x & 1 & x & 0\\
4 & 0 & 0 & 0 & x & 1 & x\\
\end{matrix}
$$

消元的时候，可以发现，第 $i$ 行只需要消第 $i+1$ 行就够了，并且只需要消第 $i$ 和第 $i+1$ 个元素即可，比如上面，第一行消第 $2$ 行得到：
$$
\begin{matrix}
& 0 & 1 & 2 & 3 & 4 & 5\\
1 & 0 & 1 & x_1 & 0 & 0 & 0\\
2 & 0 & 0 & 1-x_1x_2 & x_3 & 0 & 0\\
3 & 0 & 0 & x & 1 & x & 0\\
4 & 0 & 0 & 0 & x & 1 & x\\
\end{matrix}
$$

这样看来，实现的时候每行只需要记录 $3$ 个变量（上面看到的两个系数以及后面没写出来的常数），但是学习官方题解，我们可以更贪一点，只记两个变量，方法就是第 $i$ 行消完第 $i+1$ 行时，让 $i+1$ 行的方程全部除以第 $i+1$ 个元素，这样第 $i+1$ 个元素就是 $1$，就没必要存了，上面的例子弄一下就是：
$$
\begin{matrix}
& 0 & 1 & 2 & 3 & 4 & 5\\
1 & 0 & 1 & x_1 & 0 & 0 & 0\\
2 & 0 & 0 & 1 & \frac {x_3} {1-x_1x_2} & 0 & 0\\
3 & 0 & 0 & x & 1 & x & 0\\
4 & 0 & 0 & 0 & x & 1 & x\\
\end{matrix}
$$

别忘了常数也要除。

于是就可以看代码了（很短）：
```cpp
#include <cstdio>
#include <cstring>
#define maxn 2010

int n,tot[maxn];
char s[maxn];
double f[maxn],a[maxn],b[maxn],inv,p,ans=0.0;

int main()
{
	scanf("%s",s+1);n=strlen(s+1);
	for(int i=1;i<=n;i++)tot[s[i]-'A']++;
	a[1]=-1;b[1]=0.5*n;
	for(int i=2;i<n;i++)
	{
		inv=0.5/i,p=1-(1-i)*inv*a[i-1];
		//p就是上面说的"第i+1个元素"，由于这里是让第i-1行消第i行，所以这里应该说是第i个元素
		a[i]=(-1-i)*inv/p;//真正的第i+1个元素
		b[i]=(n*(n-1)*inv/(n-i)-(1-i)*inv*b[i-1])/p;//常数
	}
	for(int i=n-1;i>=1;i--)f[i]=b[i]-a[i]*f[i+1];
	for(int i=0;i<26;i++)ans+=1.0*tot[i]/n*f[tot[i]];
	printf("%.1lf",ans);
}
```

---

## 作者：寒鸽儿 (赞：15)

[在窝的博客阅读](https://froldh.github.io/2019/08/27/OI/MtOI/C/mtoi_c/)  
[在窝的洛谷博客阅读](https://www.luogu.org/blog/oldherd/solution-P5516)  
花了那么长时间~~再加上多次死皮赖脸地找出题人提问~~终于刚掉了这题。出题人的题解很棒，但是刚接触的期望萌新并不是很够智商。不过在出题人的耐心帮助下还是解决了。  
解决本题的关键在于对整体的状态空间的把握。对于一种元素,有转化成最终元素(以下或简记为成功转化)的情形和不成功转化的情形。而对于本数不同的属性成功的概率是不同的,也就意味着在状态空间内,每种属性成功的情况的数量不相同。  
对于任意钦定的魔法属性,若在状态中的个数为$i$,其为最终结果的概率设为$p_i$。因为在最终这个状态还是会转化出去的(除非$i = n$),而向两边转化的概率是相等的,所以 $p_i = \frac{p_{i-1} + p_{i+1}}{2}$。又由$p_n = 1$, $p_0$ = 0。故而$p_i = \frac{i}{n}$。  
设在取得成功转化的条件下步数的期望为$f_i$，$i$代表该属性下书的数量。我们考虑将它转移。转移的式子是$f_i = \frac{n(n-1)}{2i(n-i)} + \frac{i-1}{2i}f_{i-1} + \frac{i+1}{2i}f_{i+1}$。下面来解释这个式子。  
由古典概型,转移出去的概率是$\frac{2i(n-i)}{n(n-1)}$,所以转移出去的期望步数为它的倒数$\frac{n(n-1)}{2i(n-i)}$,这是转移的代价。接下来,要注意到我们的$f_i$定义为成功条件下的期望步数,所以我们的转移也是在成功的状态空间内进行的。这样,根据我们在开头提到的,转移成功概率不相等意味着在成功条件下的状态空间内的数目不相等,所以在成功条件下的状态空间中转移到$f_{i-1}$和$f_{i+1}$的概率也是不相等的。它们在成功的状态空间内的数量比应该等于其成功转化的概率比。而我们在成功条件下转化到$i-1$和$i+1$的概率也就是$i-1$和$i+1$在成功条件下在状态空间中的数目占比。  
然后是根据$f_i = \frac{n(n-1)}{2i(n-i)} + \frac{i-1}{2i}f_{i-1} + \frac{i+1}{2i}f_{i+1}$解方程,当然还有$f_n = 0$。出题人的线性高斯消元我没看懂。当然,如果直接套高斯消元的板子,按复杂度来讲会TLE。我们来观察一下这个矩阵的特性,以$n = 5$为例,($f_i$代表方程中$f_i$的系数,系数部分省略处均为0):    
![](https://cdn.luogu.com.cn/upload/pic/75175.png)  
如图,蓝线部分为该行的主元。我们发现,只要消掉红线部分,该矩形就成为了增广矩阵。而这些红线部分的主元就在上面一行,因而,在增广时只要将每一行向下一行增广即可。这样的话复杂度是线性的。然后,某行的主元只需要回代到上一行即可,所以回代时间也是线性的。  
然后,答案即为$\displaystyle\sum_{i=A}^{Z}p_{num_i}* f_{num_i}$,其中$num_i$为$i$号字母的在初始序列中的出现次数。  
那个,如果有大佬看懂出题人那个消元的写法还请赐教。  
代码如下:  
```cpp
#include <bits/stdc++.h>

using namespace std;

const double eps = 1e-8;
const int maxn = 2010;
string str;
double f[maxn][maxn], s[maxn], ans;
int num[30], n;

int main() {
	cin >> str;
	while(cin >> ans);
	n = str.length();
	for(int i = 0; i < n; i++) num[str[i]-'A']++;
	for(int i = 1; i <= n-1; i++) {
		f[i][i-1] = (double)(i-1) / (2*i); f[i][i] = -1;
		f[i][i+1] = (double)(i+1) / (2*i);  s[i] = -(double)n*(n-1)/(2*i*(n-i));
	}
	f[n][n] = 1; s[n] = 0;
	for(int i = 1; i <= n-1; i++) {
		if(fabs(f[i+1][i]) < eps) continue;
		double z = f[i+1][i] / f[i][i];
		for(int j = i; j <= n; j++) f[i+1][j] -= z * f[i][j];
		s[i+1] -= z * s[i];
	}
	for(int i = n; i > 1; --i) {
		if(fabs(f[i-1][i]) < eps) continue;
		double z = f[i-1][i] / f[i][i];
		for(int j = i; j <= n; j++) f[i-1][j] -= z * f[i][j];
		s[i-1] -= z * s[i];
	}
	ans = 0;
	for(int i = 0; i <= 'Z'-'A'; i++)
		if(num[i])
 			ans += (double)num[i] / n * s[num[i]] / f[num[i]][num[i]];
	printf("%.1f\n", ans);
	return 0;
}
```

---

## 作者：Mr_Wu (赞：8)

感觉对我这种数学萌新来说，这是一道很好的期望题。。

### 答案

设答案的期望为 $E[X]$，其中 $X$ 为步数的随机变量，若设 $Y$ 为最后字符的随机变量，则由**全期望公式**：
$$
E[X]=E[E[X|Y]]=\sum_{y=1}^{\sum} P(y=Y)E[X|Y=y]
$$

### 概率

假设当前字符为 $y$，出现次数为 $i$，若设 $OPT$ 为此次操作的随机变量，则由**全概率公式**，

$$ \begin{aligned} & P_i(Y=y)=\sum_{opt} P(OPT=opt)P_i(Y=y|OPT=opt) \\
& =\frac{i(i-1)+(n-i)(n-i-1)}{n(n-1)}P_i(Y=y)+\frac{i(n-i)}{n(n-1)}(P_{i+1}(Y=y)+P_{i-1}(Y=y)) \end{aligned} $$

化简得 $P_i(Y=y)=\frac{P_{i-1}(Y=y)+P_{i+1}(Y=y)}{2}$，发现是等差数列，由于 $P_0(y=Y)=0, P_n(Y=y)=1$，故 $P_i(Y=y)=\frac{i}{n}$。

### 期望

令 $T$ 为 $Y=y$ 这个事件，即最后的字符是 $y$。

设 $E_i[X|T]$ （事实上，这个下标 $i$，只是表示我们在不同的样本空间里罢了）表示最后字符为 $y$，当前这种字符有 $i$ 个，步数的期望。**这是条件期望**。若设 $OPT|T$ 为此次操作的随机变量（当然，是在事件 $T$ 发生的大前提下），则由全期望公式，

$$\begin{aligned} & E_i[X|T]=\sum_{opt} P_i((OPT|T)=opt)E_i[(X|T)|(OPT|T)] \\
& = 1+\sum_{opt} \frac{P_i(OPT=opt,T)}{P(T)} E_{next(i,OPT)}[X|T] \\ \end{aligned} $$

（第 3 步使用**条件概率公式**）

（重要） $P_i(OPT=opt,T)$ 是什么？它的意思是做完这个操作后这个字符能作为最后字符，这两部分是独立的，所以是 $P(OPT=opt)\times \frac{next(i,OPT)}{n}$。

因此，上式化为

$$ E_i[X|T]=1+\frac{i(n-i)}{n(n-1)} \frac{i-1}{i} E_{i-1}[X|T]+\frac{i(n-i)}{n(n-1)} \frac{i+1}{i} E_{i+1}[X|T]+\left(1 - \frac{2i(n-i)}{n(n-1)} \right) E_i[X|T]$$

故而

$$ E_i[X|T]=\frac{n(n-1)}{2i(n-i)}+\frac{i-1}{2i}E_{i-1}[X|T]+\frac{i+1}{2i}E_{i+1}[X|T] $$

### 实现

设 $f_i=E_i[X|T]$，则 $f_i=\frac{n(n-1)}{2i(n-i)}+\frac{i-1}{2i}f_{i-1}+\frac{i+1}{2i}f_{i+1}$。边界 $f_0=?, f_n=0$。（$f_0$ 是未定义的，但没关系，因为 $f_1$ 的式子中 $f_0$ 的系数是 $0$）。

答案为 $\sum\limits_{i=1}^{\sum} \frac{cnt_i}{n} f_{cnt_i}$。

现在的问题是求出 $f_i$，我们待定 $f_{n-1}$，将所有数都表示为关于 $f_{n-1}$ 的一次函数，此时还未使用 $f_1$ 的式子，用它来算出 $f_{n-1}$ 的值即可。

时间复杂度 $O(n)$。

### 我未解决的问题

样本空间是什么？如果说是操作序列的话，样本空间岂不就是无限集？

算了算了，非要纠结样本空间是什么的话，有些东西反而不太好说了。。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

const int MAXN = 100005;
int N, buc[30]; char S[MAXN]; double f[MAXN], a[MAXN], b[MAXN], ans;
int main() {
    scanf("%s", S + 1), N = strlen(S + 1); int i;
    for (i = 1; i <= N; ++i) ++buc[S[i] - 'A'];
    a[N - 1] = 1;
    for (i = N - 1; i >= 2; --i) {
        a[i - 1] = a[i] * 2 * i / (i - 1) - a[i + 1] * (i + 1) / (i - 1),
        b[i - 1] = b[i] * 2 * i / (i - 1) - b[i + 1] * (i + 1) / (i - 1) - (double)N * (N - 1) / (ll)((i - 1) * (N - i));
    }
    f[N - 1] = (N / 2.0 + b[2] - b[1]) / (a[1] - a[2]);
    for (i = 1; i <= N - 2; ++i) f[i] = a[i] * f[N - 1] + b[i];
    for (i = 0; i < 26; ++i) ans += f[buc[i]] * buc[i] / N;
    printf("%.1f\n", ans);
    return 0;
}
```




---

## 作者：To_our_starry_sea (赞：2)

### Solution

这是一篇与其他题解有所不同的题解。最终并不需要使用高斯消元。

首先，问题可以转化为有 $n$ 种不同颜色的小球，每种颜色有 $a_i$ 个，每次选取两个球进行染色，求所有颜色相同的期望步数。下文中 $s$ 表示 $\sum_{i = 1}^n a_i$。

接着，设 $dp_i$ 表示已知有 $i$ 个球为钦定的颜色，最后所有的颜色均为该钦定颜色的期望步数。

显然对于每一次操作，对于钦定的颜色 $x$，有以下几种结果：

1. 该颜色数量增加，从 $dp_{i - 1}$ 转移来，概率为 $\frac{i(s - i)}{s(s - 1)}$。

2. 该颜色数量减少，从 $dp_{i + 1}$ 转移来，概率为 $\frac{i(s - i)}{s(s - 1)}$。

3. 该颜色数量不变，从 $dp_{i}$ 转移来，概率为 $1 - \frac{2i(s - i)}{s(s - 1)}$。

综合以上可以得出下面的转移式：

$$
dp_i = \frac{i(s - i)}{s(s - 1)}dp_{i - 1} + \frac{i(s - i)}{s(s - 1)}dp_{i + 1} + (1 - \frac{2i(s - i)}{s(s - 1)})dp_i + w_i
$$

注意到 $w_i$ 表示该情况下对答案的期望贡献，即以该钦定颜色为最终颜色的概率。

考虑 $w_i$ 有以下关系。

$$
w_0 = 0 \text{，} w_s = 1
\newline
w_i = \frac{i(s - i)}{s(s - 1)}w_{i - 1} + \frac{i(s - i)}{s(s - 1)}w_{i + 1} + (1 - \frac{2i(s - i)}{s(s - 1)})w_i
$$

将上式稍加变化即可得到：

$$
w_{i + 1} - w_i = w_i - w_{i - 1}
\newline
w_i = \frac{i}{s}
$$

带入之前的式子可得：

$$
dp_i = \frac{i(s - i)}{s(s - 1)}dp_{i - 1} + \frac{i(s - i)}{s(s - 1)}dp_{i + 1} + (1 - \frac{2i(s - i)}{s(s - 1)})dp_i + \frac{i}{s}    
$$

注意，接下来我们的方法便出现了不同。

类似对 $w_i$ 进行变换的，我们对 $dp_i$ 的式子稍加变换得到：

$$
dp_{i + 1} = 2dp_i - dp_{i - 1} - \frac{s - 1}{s - i}
$$

也就是说我们得到了 $dp_i$ 的递推形式而不是带环的方程。

考虑 $dp_1$ 的值，我们可以得到以下的式子。

$$
dp_s = 0
\newline
dp_1 = dp_1 - dp_s = \sum\limits_{i = 2}^s dp_i - dp_{i - 1}
\newline
dp_1 = (s - 2)(s - 1) + (s - 1)(dp_1 - dp_2)
$$

当 $i = 1$ 时，由于 $dp_0 = 0$，$dp_2 = 2dp_1 - 1$。带入上式得到 $dp_1 = \frac{(s - 1)^2}{s}$，$dp_2 = \frac{2(s - 1)^2}{s} - 1$。

然后线性递推即可。

注意到，$dp_x = \sum\limits_{i = 2}^x \frac{x - i + 1}{i - s + 1}$。这个东西我们在分块之后多项式多点求值可以做到 $O(\sqrt{V} \log^2V + n\sqrt{V})$，其中 $V$ 为 $x$ 的值域，当 $V$ 很大时似乎更优~~更劣了~~。

### Code


```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 2005;
int n, sum[MAXN];
char s[MAXN];
double dp[MAXN];
inline int read() {
	int x = 0, f = 1; char ch = getchar();
	while (ch < '0' || ch > '9') {
		if (ch == '-') 
		   f = -1;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();
	return x * f;
}
int main() {
	scanf("%s", s + 1);
	n = strlen(s + 1);
	int maxn = 0;
	for (int i = 1; i <= n; i++) sum[s[i] - 'A' + 1]++, maxn = max(maxn, sum[s[i] - 'A' + 1]);
	dp[1] = 1.0 * (n - 1) * (n - 1) / n, dp[2] = 2.0 * dp[1] - 1.0;
	for (int i = 3; i <= maxn; i++) dp[i] = 2 * dp[i - 1] - dp[i - 2] - 1.0 * (n - 1) / (n - i + 1);
	double ans = 0;
	for (int i = 1; i <= 26; i++) ans += dp[sum[i]];
	printf("%0.1lf\n", ans);
	return 0;
}
```

---

## 作者：FutaRimeWoawaSete (赞：2)

**P5516 sol**

感觉在基础的期望方面令我受益匪浅。

萌新向题解。

-------------------------------------------------

我们先考虑一个很诈骗的限制：$\sum_{i = 1} ^ n\sum_{j = 1} ^ n p_{i,j} = n ^ 2$。这说明 $p$ 的限制本身是无用的，即任意施法必定交换成立。

不难想到颜色数是 $26$ 的，考虑枚举每个颜色作为答案的情况。即使得一个状态只和全局颜色数有关。

然后你发现直接分析期望是比较困难的，所以我们先来分析概率！

我们设 $p_i$ 表示当前全局钦定颜色数为 $i$ 的成功概率，显然当前有 $\frac{2i(n - i)}{n(n - 1)}$ 的概率使得 $i$ 可以产生移动（$-1/+1$），其中两个方向的概率都是 $\frac{i(n - i)}{n(n - 1)}$。

所以可以很简单地列出概率方程式：

- $p_i = \frac{i(n - i)}{n(n - 1)}p_{i - 1} + \frac{i(n - i)}{n(n - 1)}p_{i + 1} + (1 - \frac{2i(n - i)}{n(n + 1)})p_i$。

考虑化简一下。

- $p_i = \frac{p_{i - 1} + p_{i+ 1}}{2}$

再移项一下。

- $\frac{p_{i} - p{i - 1}}{2} = \frac{p_{i + 1} - p_i}{2}$

由于 $p_n = 1$，$p_0 = 0$，显然得出 $p_i = \frac{i}{n}$。

----------------------------------------------

稍微推出了个不是很废的性质，我们接下来继续思考如何求解期望。

这里我们先不吉吉国王，考虑用标准的形式先解决转移再来设 dp 状态。

记 $T = 1$ 表示当前是成功状态，注意到我们的样本空间**应全在成功状态下考虑**，设 $X$ 表示步数的随机变量，则我们所求的是 $E_i[X | T = 1]$，设出 $i$ 则表示的是当前有 $i$ 个钦定颜色的样本空间。

将 $X | T = 1$ 看成一个整体，枚举当前的事件变量 $u$，其相当于 $(-1/+1)$，用全期望公式展开！

- $E_i[X | T = 1] = \sum_u P_i((U = u) | T = 1) \times E_i[(X | T = 1) | ((U = u) | T = 1)]$

对比正常的全期望公式 $E(X) = E(E(X | Y)) = \sum_y E(X | Y = y) \times P(Y = y)$，我们发现枚举 $u$ 就相当于原本公式里面的 $Y$，只是被限制在了 $T = 1$ 的事件下才导致式子看起来这么繁琐。

还是解释一下，$P_i((U = u) | T = 1)$ 相当于是在成功事件下当前事件是 $u$（总颜色数 $-1/+1$）的概率，而 $E_i[(X | T = 1) | ((U = u) | T = 1)]$ 表示在执行了，成功事件下进行了事件 $u$ 后，成功的期望步数，有点循环定义但是确实是这样的 qwq。


接着我们发现，$E_i[(X | T = 1) | ((U = u) | T = 1)]$ 的定义其实就是我们必须消耗一步的代价进行转移后，**后继状态所需的期望步数**；而对于 $P_i((U = u) | T = 1)$ 我们套用条件概率：

- $= \sum_u \frac{P_i(U = u , T = 1)}{P_i(T = 1)} \times (E_{i + u}[X | T = 1] + 1)$

后面括号里的 $1$ 由于前面的概率和为 $1$ 可以再提出来，而对于这个概率，$P_i(U = u,T = 1)$ 其实就是选择了事件 $u$（$+1/-1$） 后成功的概率，两个事件是独立的，直接乘就好了，即$\frac{i(n - i)}{n(n - 1)} \times \frac{i + u}{n}$。

最后展开合并，我们可以得到如下的式子：

- $E_i[X | T = 1] = \frac{n(n - 1)}{2i(n - i)} + \frac{i - 1}{2i}E_{i - 1}[X | T = 1] + \frac{i + 1}{2i}E_{i + 1}[X | T = 1]$

我们发现将 $f_i$ 设为 $E_i[X | T = 1]$ 即可做正常的高斯消元，然后就可以算答案了，但是此时得用线性的高消才行。

所以事件复杂度瓶颈在于输入？（

---

## 作者：windrizzle (赞：0)

关于本题期望的推导其他题解已经讲得很清楚了。因为我太弱了看不懂线性消元，这里主要详细讲我得到这个结果的过程。

首先，我们已经得到 $N-1$ 条形式为：

$$F[x]=\frac{x+1}{2x}F[x+1]+\frac{x-1}{2x}F[x-1]+M $$

的方程。其中：

$$ M=\frac{n(n-1)}{2(n-x)x} $$

与另一条方程：

$$ F[n]=0 $$

将 $x=1$ 带回方程可知：

$$ F[1]=F[2]+\frac{n}{2}$$

因而可以推出：

$$ F[2] =F[1]-\frac{n}{2}$$

因为每一条方程都有三个未知量，因此我们可以将 $F[3]$ 到 $F[n]$ 均用 $F[1]$ 表示，再将关于 $F[1]$ 的方程带回 $F[n]=0$ ，就可以得出所有的未知量。

在解题时，我们将未知量表示为：

$$ F[x]=a[x]\times F[x] +b[x]$$

的形式。这里的 $a[x]$ 与 $b[x]$ 显然可以通过递推得到。

最后可以得出：


$$ a[x+1]\times F[x+1] +b[x+1]=\frac{2x}{x+1}\times (a[x]-\frac{x-1}{2x}a[x-1])F[1] + \frac{2x}{x+1}\times (b[x]-\frac{x-1}{2x}b[x-1]-M)F[1] $$

注意：此处 $x \in  [2,n-1]$ ，需要预处理 $x=1$ 与 $x=2$ 的情况。

核心代码：

```cpp
	a[1]=1.0,b[1]=0.0;
	a[2]=1.0,b[2]=-(n*1.0/2);
	for(int i=2;i<n;i++)
	{
		double R=(i*1.0+1.0)/(i*2.0);
		double M=((n*1.0-1.0)*n*1.0)/(2.0*(n*1.0-i*1.0)*i);
		double P=(i*1.0-1.0)/(i*2.0);
		a[i+1]=(a[i]-(a[i-1]*P))/R;
		b[i+1]=(b[i]-M-(b[i-1]*P))/R;
	}
	//f[n]=0
	f[1]=(-b[n]*1.0)/a[n]*1.0;
	for(int i=2;i<n;i++)
		f[i]=a[i]*f[1]+b[i];
```


---

## 作者：ZillionX (赞：0)

> 给定一个长度为 $n$ 的字符串 $s$，每次操作选择两个不同的下标 $a,b$，将 $s_a$ 变为 $s_b$，求使得整个 $s$ 完全相同的期望操作次数。  
$n \le 2 \times 10^3$，2s。

我们考虑全期望公式，答案显然可以表示为

$$E(X)=\sum_y P(Y=y)E(X|Y=y)$$

我们先考虑如何求出 $P(Y=y)$，也就是最终整个串变为 $y$ 的概率。

显然这个东西并不是处处相等的，我们考虑它和什么有关，暴力的想法是记录整个串每一位是否 $=y$ 的 $0/1$ 串。

容易发现事实上并不需要这么多状态，它只和当前串中 $=y$ 的字符数有关。那么我们可以浅做一个 DP，记 $f_i$ 为当前字符串中 $=y$ 的字符有 $i$ 个时最终整个串变为 $y$ 的概率，那么有（事实上，在状态确定后的这部分推导本质上属于全概率公式）

$$f_i=\frac{i(n-i)}{n(n-1)}f_{i-1}+\frac{i(n-i)}{n(n-1)}f_{i+1}+(1-\frac{2i(n-i)}{n(n-1)})f_{i}$$

整理得

$$f_i=\frac{f_{i-1}+f_{i+1}}{2}$$

显然有 $f_0=0,f_n=1$，我们从 $n$ 较小的情况开始归纳可以得到 $f_i=\frac{i}{n}$，即 $P_i(Y=y) = \frac{i}{n}$。

现在我们的问题就是求出 $E(X|Y=y)$。

我们还是考虑记录 $\sum [s_i=y]$ 做一个 DP，然而这次要乘上的概率有所不同。

设 $R$ 为刻画操作的随机变量，那么对于 $f$ 的 DP 我们只需要乘上 $P_i(R=r)$，而这次我们需要乘上的是 $P_i((R=r)|(Y=y))$，那么由贝叶斯公式有

$$P_i((R=r)|(Y=y))=\frac{P_i((Y=y)|(R=r))P_i(R=r)}{P_i(Y=y)}$$

显然 $P_i((Y=y)|(R=r))$ 相当于做完 $R=r$ 这个随机操作，$i$ 随机 $+1,-1$ 或不变后的 $P_i(Y=y)$。

设 $g_i$ 为当前字符串中 $=y$ 的字符有 $i$ 个时最终整个串变为 $y$ 的期望操作数，略去推导过程，同理有

$$g_i=\frac{n(n-1)}{2i(n-i)}+\frac{i-1}{2i}g_{i-1}+\frac{i+1}{2i}g_{i+1}$$

这个看起来就不是很好归纳了，我们考虑直接对它跑一个高斯消元，但是这是 $\mathcal O(n^3)$，又注意到这是每行只有三个数的经典矩阵，可以线性消元。从初等代数的角度来考虑，相当于待定 $f_{1}$ 后，可以表示出 $f_{2 \sim n}$，而此时再将 $f_n=0$ 代进去就可以解出来了。

复杂度瓶颈在于输入，若不输入全 ```1``` 矩阵，则时空复杂度均为 $\mathcal O(n)$。待定 $f_1$ 的递推的实现相当于扩域。

```cpp
const int N=2e3+5;
char s[N];
int n,c[26];
struct rs{
	db x,y;
	rs operator*(const db&p)const{return rs{x*p,y*p};}
	rs operator-(const db&p)const{return rs{x,y-p};}
	rs operator-(const rs&p)const{return rs{x-p.x,y-p.y};}
}f[N];
int main(){
	scanf("%s",s+1),n=strlen(s+1);
	for(int i=1;i<=n;i++)c[s[i]-'A']++;
	f[1]=rs{1,0};
	for(int i=1;i<n;i++){
		db p=i,x=n;
		f[i+1]=f[i]*((p*2)/(p+1))-f[i-1]*((p-1)/(p+1))-x*(x-1)/(p+1)/(x-p);
	}
	db f1=(-f[n].y)/f[n].x,as=0;
	for(int i=0;i<26;i++)as+=((db)c[i]/n)*(f[c[i]].x*f1+f[c[i]].y);
	printf("%.1lf",as);
	return 0;
}
```


---

## 作者：Exschawasion (赞：0)

如果要做出这道题，你需要具备：

- 线性高斯消元的相关知识，模板题：[$\texttt{P3389}$](https://www.luogu.com.cn/problem/P3389)；
- 高中水平的数学推导能力；
- 细心的读题能力。

***

复杂的题目需要一步一步分析。

观察本题数据范围，对于所有的 $p_{i,j}$，均有 $p_{i,j} \in (0, 1]$，且 $\sum_{i=1}^{n}\sum_{j=1}^{n}p_{i,j}=1$，这说明，所有的 $p_{i,j}=1$。也就是完全没有必要读入所谓的概率。事实上，样例中所有的 $p$ 也确实都是 $1.0$。

题目要求将给定的字符串转变成只由一个字符（以下称作**终点字符**）组成的字符串。然而，具体是哪个字符不清楚，需要枚举。记字符 $c$ 在原字符串中出现的次数为 $v_c$、$f(x)$ 表示出现次数为 $x$ 的字符 $c$ 作为终点字符时所需的期望步数，来推导状态转移。由于 $x$ 可以由 $x-1$ 和 $x+1$ 转化而来，写出以下式子：

$$f(x)=\Delta(x) + L(x)f(x-1) + R(x)f(x+1)$$

其中 $L(x)$ 表示从 $x-1$ 转移到 $x$ 的概率、$R(x)$ 表示从 $x+1$ 转移到 $x$ 的概率（$\Delta(x)$ 的意义在稍后阐明）。

由于所有转移有 $2x$ 种（即每个 $x$ 对应 $x+1$ 和 $x-1$ 两种转移），那么，从 $x-1$ 转移到 $x$ 的概率自然就是 $\frac{x-1}{2x}$，$x+1$ 转移到 $x$ 同理，所以：

$$
\begin{aligned}
L(x) = \frac{x-1}{2x} \\
R(x) = \frac{x+1}{2x}
\end{aligned}
$$

转移不仅要考虑如何从 $x \pm 1$ 转移到 $x$ 的情况，**还要考虑从 $x$ 转移到 $x \pm 1$ 的情况**。因为起始状态相同（即都是从 $x$ 转移出去，而不是像上面那样 $x \pm 1$ 两种起始状态），所以往两边转移的概率是相等的，即：

$$

\begin{aligned}
\Delta(x)&= \frac{x \times (n-x)}{n\times(n-1)} \times 2 \\
& = \frac{2 \times x \times (n-x)}{n\times(n-1)}
\end{aligned}
$$

将这些代入原本的式子，可以得到：


$$
\begin{aligned}
f(x) &=\Delta(x) + L(x)f(x-1) + R(x)f(x+1) \\
&=\frac{2 \times x \times (n-x)}{n\times(n-1)} + \frac{x-1}{2x}f(x-1)+\frac{x+1}{2x}f(x+1) 
\end{aligned}
$$

这就是状态转移方程了。然而，这只是完成了第一部分的工作。观察式子，$f(x)$ 和 $f(x \pm 1)$ 可以相互转移，普通的 $\texttt{dp}$ 很难胜任，怎么做呢？

我们需要的答案是 $f(x)$，具体如何计算出 $f(x)$ 我们并不关心，需要打开思路寻找另外一种方式。假设 $n=3$，则有下面的方程组：

$$

\begin{cases}
f(1)=\frac{2 \times 1 \times (3-1)}{3\times(3-1)} + \frac{1-1}{2}f(1-1)+\frac{1+1}{2}f(1+1) \\

f(2)=\frac{2 \times 2 \times (3-2)}{3\times(3-2)} + \frac{2-1}{2}f(2-1)+\frac{2+1}{2}f(2+1) \\

f(3)=\frac{2 \times 3 \times (3-3)}{3\times(3-3)} + \frac{3-1}{2}f(3-1)+\frac{3+1}{2}f(3+1) 

\end{cases}
$$

如何计算 $f(1)$，想必已经很清晰了。**在所有 $n$ 和 $x$ 都是已知的情况下，使用高斯消元就可以避开循环，直接求出状态转移的解**。

值得一提的是，当 $x=n$ 时，第一项（即 $\Delta(x)$）的分子与分母均为 $0$。其实当 $x=n$ 时相当于所有的 $n$ 个字符都相同了，目标状态不需要再往外转移，故此时 $\Delta(x)=0$。

***

最终的结果如何计算不必多说。因为一个字符可能出现多次，所以，$f(x)$ 在最终答案种占的比应为 $\frac{x}{n}$。令 $1$ 对应字符 $\texttt{A}$、$2$ 对应字符 $\texttt{B}$，以此类推，则有：

$$
\text{ans} = \sum_{i=1}^{26}
\begin{cases}
f(v_i) \times \frac{v_i}{n} &&(v_i \neq 0)\\
0 && (v_i =0)
\end{cases}
$$

还需要知道一点：因为 $n\leq2000$，普通的高斯消元是会超时的。其实，每个方程只有 $3$ 项，$O(n^2)$ 就能解决。这里使用的是回代法，具体可见代码：

```
#include <bits/stdc++.h>

using namespace std;

const int maxn = 2000 + 5;

const double eps = 1e-5;
int n;
double c[maxn][maxn];

string str;

double cost[maxn];
int cnt[maxn];

void pre() {
	for(int i = 0; i < str.length(); i++) {
		cnt[str[i] - 'A']++;
	}
	n = str.length();
	for(int i = 1; i < str.length(); i++) {
		c[i][i - 1] = (double)(i - 1) / (i * 2);
		c[i][i + 1] = (double)(i + 1) / (i * 2);
		c[i][i] = -1;
		c[i][n + 1] = (double)n * (n - 1) / (2 * i * (n - i));
	}
	c[n][n] = 1, c[n][n + 1] = 0;
}

void gauss() {
	for(int i = 1; i < n; i++) {
		if(eps > fabs(c[i + 1][i])) continue;
		double rate = c[i + 1][i] / c[i][i];
		for(int j = i; j <= n + 1; j++) {
			c[i + 1][j] -= rate * c[i][j];
		}
	}
	for(int i = n; i > 1; i--) {
		if(eps > fabs(c[i - 1][i])) continue;
		double rate = c[i - 1][i] / c[i][i];
		for(int j = i; j <= n + 1; j++) {
			c[i - 1][j] -= rate * c[i][j];
		}
	}
	for(int i = 1; i <= n; i++) {
		c[i][n + 1] /= c[i][i];
	}
}

int main() {
	cin >> str;
	pre(); gauss();
	double ans = 0;
	for(int i = 0; i < 26; i -= -1) {
		if(!cnt[i]) continue;
		ans += ((double)cnt[i] / n) * (c[cnt[i]][n + 1]);
	}
	if(eps > fabs(ans)) printf("0.0");
	else printf("%.1f", -ans);
	return 0;
}
```

当一个状态转移方程相互转移而无法循环计算时，如果每一项的系数是可知的，那么就可以考虑使用高斯消元来得到状态转移方程的解。


---


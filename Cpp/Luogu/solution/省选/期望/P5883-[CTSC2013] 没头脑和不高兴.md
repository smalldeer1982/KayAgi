# [CTSC2013] 没头脑和不高兴

## 题目描述

没头脑和不高兴是一对形影不离的好朋友，他们一起上学也一起玩耍。

这天，这对好朋友聚在一起玩纸牌游戏。他们所玩的纸牌总共有 $N$ 张，每一张上面都有一个 $1-N$ 的数字，任意两张纸牌上的数字都不相同。根据他们制定的游戏规则，在每局游戏的开始，所有的牌需要按照从 $1-N$ 的顺序排好。在开心地玩完了一局牌之后，他们发现牌的顺序被弄得乱七八糟，将它们排好序是一件挺麻烦的事情。

他们将凌乱的纸牌在桌面上排成一排，然后开始了排序工作。不高兴由于在上一局游戏中输了牌，非常不高兴。他只将其中**奇数位置**的牌排成了升序，然后把剩下的任务推给了没头脑。没头脑非常没头脑，他采取了一个有些笨的排序方式。每次，他找到两张相邻并且顺序不对的牌交换它们，直到整个序列被排好序为止。

乐于探究的你，想要研究在初始排列随机的情况下没头脑花在交换纸牌上的时间。假设没头脑每交换一对纸牌花费的时间为 $1$，你希望求出他排序时间的期望。此外，为了更好地分析这个问题，你还希望能够计算出所花时间的方差。更进一步地，如果**被不高兴排好序的位置发生了变化**，你是否还能求出没头脑用来排序时间的期望呢？

## 说明/提示

**样例说明**

在初始条件下，不高兴会将位置 $1$ 和 $3$ 的纸牌排好顺序。对于排列 $(1,2,3)$ 和 $(3,2,1)$，他将排列成 $(1,2,3)$，没头脑不需要操作；对于排列 $(1,3,2)$ 和 $(2,3,1)$，他将排列成 $(1,3,2)$ ，没头脑需要交换一次；对于排列 $(2,1,3)$ 和 $(3,1,2)$，他将排列成 $(2,1,3)$，没头脑需要交换一次。因此没头脑所花的时间期望为$\frac{0 \times 2+1 \times 2+1\times 2}{6}=\frac{2}{3}$；方差为 $\frac{ (0-\frac{2}{3})^2 \times 2 + (1-\frac{2}{3})^2 \times 2+(1-\frac{2}{3})^2 \times 2 }{6}=\frac{2}{9}$。

在进行了第一次修改之后，不高兴会只对位置 $1$ 排序，这和没有排序的效果一样；第二次修改之后，他会对位置 $1$,$2$ 排序；最后一次修改之后，他会对位置 $1$,$2$,$3$ 排序，这样没头脑完全不用参与排序工作。可据此求出对应情况下没头脑排序时间的期望。

**评分标准**
- 如果选手的前两行正确，其余行出现错误，可以得到 $40\%$ 的分数。
- 如果选手的前两行出现错误，其余行正确，可以得到 $50\%$ 的分数。
- 如果选手的所有行输出完全正确，可以得到 $100\%$ 的分数。
- 其余情况选手不得分。


**数据规模和约定**

| 测试点编号 | $N$ 的值 | $M$ 的值 |
| :----------: | :----------: | :----------: |
| $1$ | $4$ | $10$ |
| $2$ | $11$ | $100$ |
| $3$ | $100$ | $10^3$ |
| $4$ | $1001$ | $10^4$ |
| $5$ | $78590$ | $10^5$ |
| $6$ | $87933$ | $10^5$ |
| $7$ | $95000$ | $10^5$|
| $8$ | $99445$ | $10^5$ |
| $9$ | $99999$ | $10^5$ |
| $10$ | $100000$ |  $10^5$|

## 样例 #1

### 输入

```
3 3
2 3 0
2 2 1
1 3 1
```

### 输出

```
2/3
2/9
3/2
1/1
0/1
```

# 题解

## 作者：zJx_Lm (赞：6)

很好的期望题，很久之前学长讲的，~~但现在才填坑~~。

参考了 [Autoint's Blog](https://www.cnblogs.com/autoint/p/12109591.html)

首先转换一下题意，移动次数其实就是序列逆序对的数量。

所以我们实际上是在求序列逆序对数量的期望。

我们令 $P_{i,j}$ 表示位置 $(i,j)$ 上的数为逆序对的期望。

则：

$$Ans=\sum_{i=1}^{n}\sum_{j=i+1}^{n}P_{i,j}$$

考虑如何求 $P{i,j}$ ，我们分情况讨论：

* $(i,j)$ 均为排序点，期望为 0 。


* $(i,j)$ 均为未排序点，期望为 $\dfrac{1}{2}$ ， 即：$\dfrac{\sum_{i=1}^{n-1}i}{n(n-1)}=\dfrac{1}{2}$ 。

* 仅有 $i$ 为排序点，期望为 $\dfrac{V_{i}}{tot+1}$ 。

    首先假设共有 $m$ 个排序点,这种情况我们其实是在求从 $n-m$ 的数中再取一个数比原数小的期望。

    我们可以考虑直接选出 $m+1$ 个点，再从 $m+1$ 个点中选出未排序点、

    所以期望为 $\dfrac{V_{i}}{tot+1}$,其中 $V_{i}$ 未 $i$ 点的排名，$tot$ 为总排序数。

* 仅有 $j$ 为排序点，期望为 $\frac{tot+1-V_{j}}{tot+1}$ 。

证明同上。

再分情况讨论,设 $n'$ 为题中所给 $n$ ：

若 $n'=2n$ ：

$$Ans=\frac{1}{2}\binom{n}{2}+\frac{1}{n+1} \left ( \sum_{i=1}^{n}i(n-i+1)+\sum_{i=1}^{n-1}i(n-i) \right )=\frac{7n^2-n}{12}$$

若 $n'=2n+1$ ：

$$Ans=\frac{1}{2}\binom{n}{2}+\frac{1}{n+2} \left ( \sum_{i=1}^{n}i(n-i+1)+\sum_{i=1}^{n}i(n-i+1) \right )=\frac{7n^2+n}{12}$$

------------

题目第二问要求方差的期望，即：

$$Var(I_{n})=\frac{\sum(x-E(I_{n}))^2}{tots}=\frac{\sum(x^2-2xE(I_{n})+E(I_{n})^2)}{tots}=E(I_{n}^2)-E({I_{n}})$$

$tots$ 为总方案数。

可以用插值求出多项式系数。

最后：

若 $n'=2n$ ：

$$Var(I_n)=\frac{54n^3+13n^2+23n}{360}$$

若 $n'=2n+1$ ：

$$Var(I_n)=\frac{54n^3+55n^2-29n}{360}$$

------------

考虑怎么维护第一问。

若 $j$ 为未排序点，如果 $j$ 前面有 $k$ 个排序点，那对答案的贡献就为：

$$\dfrac{\sum_{i=1}^{k}i}{tot+1}=\frac{\binom{k}{2}+k}{tot+1}$$

设 1 为排序点，0 为未排序点，于是我们可以统计序列中 `110` 和 `10` 的个数来维护答案。

当 $i$ 为未排序点同理，统计序列中 `011` 和 `01` 的个数即可。

以上过程用线段树维护就可以了。

Code

```cpp
#include <bits/stdc++.h>
#define re register
#define int long long
// #define ll long long
// #define lls long long
#define pir make_pair
#define fr first 
#define sc second
#define db double
using namespace std;
const int mol=998244353;
const int maxn=2e5+10;
const int INF=1e9+10;
inline int qpow(int a,int b) { int ans=1; while(b) { if(b&1) (ans*=a)%=mol; (a*=a)%=mol; b>>=1; } return ans; }
inline int read() {
    int s=0,w=1; char ch=getchar();
    while(ch<'0'||ch>'9') { if(ch=='-') w=-1; ch=getchar(); }
    while(ch>='0'&&ch<='9') { s=s*10+ch-'0'; ch=getchar(); }
    return s*w;
}


int nn,n,m;
namespace STG {
	#define lid (id<<1)
	#define rid (id<<1|1)
	struct TREE { int c1,c0,c01,c10,c011,c110,lazy; } tre[maxn<<2];
	inline void update(int id) {
		tre[id].c0=tre[lid].c0+tre[rid].c0;
		tre[id].c1=tre[lid].c1+tre[rid].c1;
		tre[id].c01=tre[lid].c01+tre[rid].c01+tre[lid].c0*tre[rid].c1;
		tre[id].c10=tre[lid].c10+tre[rid].c10+tre[lid].c1*tre[rid].c0;
		tre[id].c011=tre[lid].c011+tre[rid].c011+tre[lid].c01*tre[rid].c1+tre[lid].c0*tre[rid].c1*(tre[rid].c1-1)/2;
		tre[id].c110=tre[lid].c110+tre[rid].c110+tre[lid].c1*tre[rid].c10+tre[rid].c0*tre[lid].c1*(tre[lid].c1-1)/2;
	}
	inline void build(int id,int l,int r) {
		tre[id].lazy=-1;
		if(l==r) { if(l&1) tre[id].c1=1; else tre[id].c0=1; return ; }
		int mid=(l+r)>>1;
		build(lid,l,mid); build(rid,mid+1,r);
		update(id);
	}
	inline void push_down(int id,int l,int r) {
		int v=tre[id].lazy; tre[id].lazy=-1;
		int mid=(l+r)>>1;
		if(v==1) {
			tre[lid]=(TREE){ mid-l+1,0 }; tre[rid]=(TREE){ r-mid,0 };
		}
		else {
			tre[lid]=(TREE){ 0,mid-l+1 }; tre[rid]=(TREE){ 0,r-mid };
		}
		tre[lid].lazy=tre[rid].lazy=v;
	}
	inline void ins(int id,int l,int r,int ll,int rr,int v) {
		if(ll<=l&&r<=rr) { tre[id]=(v!=0)? (TREE){ r-l+1,0 }:(TREE){ 0,r-l+1 }; tre[id].lazy=v; return ; }
		if(tre[id].lazy!=-1) push_down(id,l,r);
		int mid=(l+r)>>1;
		if(ll<=mid) ins(lid,l,mid,ll,rr,v); 
		if(rr>mid) ins(rid,mid+1,r,ll,rr,v);
		update(id);
	}
}

signed main(void) {
	nn=n=read(); m=read();
	if(nn&1) {
		n/=2;
		int a=7ll*n*n+n,b=12ll,gcd=__gcd(a,b);
		printf("%lld/%lld\n",a/gcd,b/gcd);
		a=54ll*n*n*n+55ll*n*n-29ll*n,b=360ll,gcd=__gcd(a,b);
		printf("%lld/%lld\n",a/gcd,b/gcd);
	} else {
		n/=2;
		int a=7ll*n*n-n,b=12ll,gcd=__gcd(a,b);
		printf("%lld/%lld\n",a/gcd,b/gcd);
		a=54ll*n*n*n+13ll*n*n+23ll*n,b=360ll,gcd=__gcd(a,b);
		printf("%lld/%lld\n",a/gcd,b/gcd);
	}
	STG::build(1,1,nn);
	for(re int i=1,l,r,v;i<=m;i++) {
		l=read(); r=read(); v=read();
		STG::ins(1,1,nn,l,r,v);
		STG::TREE t=STG::tre[1];
		int a1=t.c0*(t.c0-1),b1=4;
		int a2=t.c01+t.c10+t.c011+t.c110,b2=t.c1+1;
		a1=a1*b2+a2*b1,b1*=b2; int gcd=__gcd(a1,b1);
		printf("%lld/%lld\n",a1/gcd,b1/gcd);
	}
}
```
	


---

## 作者：_lmh_ (赞：3)

（如果你需要一个简单的做法，请跳过这篇题解。）

记 $a_i=0/1$ 为每个位置的状态，$0$ 代表不会被预先排序，$1$ 代表会被预先排序，初始状态下 $a_i=i\bmod 2$。

假设 $L_{d,i}=\sum_{j=1}^{i}[a_j=d],R_{d,i}=\sum_{j=i}^n[a_j=d],k=\sum_{i=1}^na_i$。

计算逆序对数量的期望是简单的：分成 $00$ 和 $01(10)$ 两类，第一类贡献显然为 $\frac{1}{2}$，计算第二类（$a_i=1,a_j=0$）的贡献考虑在 $1,2,3,\cdots ,m$ 中的一个位置插入一个数代表 $a_j$ 的排名，得到答案为 $\frac{L_i}{k+1}$。

将这个东西拆成形如 $a_i=1,a_j=1,a_k=0(i\le j<k\vee i\ge j>k)$ 的三元组，每个三元组贡献为 $\frac{1}{k+1}$，线段树维护即可获得 $50$ 分。

现在考虑算方差，它是每种情况下逆序对数量的平方的平均数减去期望的平方，后半部分是简单的。

前半部分的计算考虑对于每个 $((x,y),(z,w))(x<y,z<w)$ 求 $p_x>p_y\wedge p_z>p_w$ 的概率。

计算概率时，可以不考虑 $a_i=0$ 且 $i\ne x,y,z,w$ 的数，只考虑剩下的数的排名。

$x=z,y=w$ 是简单的。

$x,y,z,w$ 互不相等时，将其分为如下几类：

如果 $a_x=a_y=0$ 或 $a_z=a_w=0$，则二者互为独立事件，直接将概率相乘即可。实际计算时需要预处理选出一个 $a_x=a_y=0$ 的排列的方案数。

否则，肯定有 $a_x+a_y=a_z+a_w=1$。

考虑枚举 $a=1$ 的位置，分类讨论 $a_x=1,a_y=1$ 和 $a_z=1,a_w=1$，则所有概率之和分别为：

$$\frac{2}{(k+1)(k+2)}\sum_{i=1}^n\sum_{j=i+1}^n[a_i=a_j=1]L_{0,i}(L_{0,j}-1)(k-i+2)(k-j+1)
\\
\frac{2}{(k+1)(k+2)}\sum_{i=1}^n\sum_{j=i+1}^n[a_i=a_j=1](R_{0,i}-1)R_{0,j}\cdot i(j+1)
\\
\frac{2}{(k+1)(k+2)}\sum_{i=1}^n\sum_{j=i+1}^n[a_i=a_j=1]
i(k-j+1)(R_{0,i}L_{0,j}-(L_{0,j}-L_{0,i}))
\\
\frac{2}{(k+1)(k+2)}\sum_{i=1}^n\sum_{j=i+1}^n[a_i=a_j=1]L_{0,i}R_{0,j}(j(k-j+1)+(j+1)(j-i))
$$

从大到小枚举 $i$ 动态维护含 $j$ 的部分的和即可。

第三种情况是 $x,y,z,w$ 中恰有三个不同的值，此时考虑出现两次的值 $u$。

如果 $a_u=1$，则其余两个位置必定为 $0$，容易计算。

如果 $a_x=a_y=a_z=a_w=0$，则概率和位置无关，也容易计算。

否则如果 $u=x=z,a_x=0$，那么 $a_y+a_w=1$，在公共的位置计算贡献，相当于在右边选出一个 $0$ 一个 $1$，然后两个 $0$ 的值不能都比 $1$ 位置的值小，可以直接计算，需要维护 $\binom n2$ 的前缀和。

如果 $a_x=a_y=a_z=0,u=y=z,a_w=1$，那么在 $1$ 的位置计算贡献，需要在前面选出两个 $0$ 并且大小递减，这个是简单的。

如果 $a_x=a_z=1,u=y=w,a_y=0$，那么在 $x$ 的位置计算贡献，需要在右边选出一个 $1$ 一个 $0$ 且 $0$ 位置的值比 $x$ 位置的值更小。

以上所有情况都可以做到 $O(n)$，不存在其它本质不同的情况。总时间复杂度 $O(n)$。

需要使用 `__int128` 防止中间结果溢出。~~如果你知道代码里每一块对应的是哪一种情况的话~~，具体实现可以参考代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define lll __int128
#define lson (u<<1)
#define rson (u<<1|1)
const ll N=400007;
ostream& operator <<(ostream& out,__int128 x){
	static int stk[N],top;top=0;
	if (x==0){out<<0;return out;}
	if (x<0){out<<'-';x=-x;}
	while(x){
		stk[++top]=x%10;x/=10;
	}
	while(top) out<<stk[top--];
	return out;
}
__int128 abs(__int128 x){return x>=0?x:-x;}
__int128 gcd(__int128 A,__int128 B){return B?gcd(B,A%B):A;}
struct frac{
	__int128 A,B;
	frac(){A=0;B=1;}
	frac(__int128 a,__int128 b=1){
		A=a;B=b;
	}
	void output(){
		__int128 g=gcd(abs(A),abs(B));
		cout<<(A/=g)<<'/'<<(B/=g);
	}
	void refresh(){
		__int128 g=gcd(abs(A),abs(B));
		A/=g;B/=g;
	}
};
ostream& operator <<(ostream& out,const frac& a){
	__int128 g=gcd(abs(a.A),abs(a.B));
	out<<a.A/g<<'/'<<a.B/g;
	return out;
}
frac operator +(const frac& a,const frac& b){if (a.A==0) return b;if (b.A==0) return a;ll g=gcd(a.B,b.B);return frac(a.A*(b.B/g)+(a.B/g)*b.A,a.B/g*b.B);}
frac operator -(const frac& a,const frac& b){if (a.A==0) return frac(-b.A,b.B);if (b.A==0) return a;ll g=gcd(a.B,b.B);return frac(a.A*(b.B/g)-(a.B/g)*b.A,a.B/g*b.B);}
frac operator *(const frac& a,const frac& b){if (a.A==0||b.A==0) return frac();return frac(a.A*b.A,a.B*b.B);}
frac& operator +=(frac& a,const frac& b){a=a+b;return a;}
ll C2(ll n){return n*(n-1)/2;}
namespace X{
	frac ans1,ans2;
	__int128 pre[N];
	void solve(ll n,ll m){
		ll odd=n+1>>1,even=n>>1;m=odd;
		ans1=frac(C2(even),2);ans1.refresh();
		for (int i=1;i<=n;++i) pre[i]=pre[i-1]+C2(i);
		for (int i=1,p=1,L=0,R=even;i<=n;i+=2){
			ans1+=frac(L*(odd+1-p),odd+1)+frac(R*p,odd+1);
			++L;--R;++p;
		}
		ans1.refresh();
		cout<<ans1<<'\n';
		ans2=ans1+frac((__int128)even*(even-1)/2*(even-2)*(even-3)/4,2);
		ans2.refresh();
		__int128 S=C2(odd+2),K=C2(even-1),A=0;
		frac tmp=0;
		for (int i=1,p=1,L=0,R=even;i<=n;i+=2){
			ans2+=frac(L*(odd+1-p)*K,odd+1)+frac(R*p*K,odd+1);
			ans2.refresh();
			++L;--R;++p;
		}
		for (int i=1,p=1,L=0,R=even;i<=n;i+=2){
			ans2+=frac((__int128)C2(L)*C2(odd+2-p)*3,S);
			ans2+=frac((__int128)C2(R)*C2(p+1)*3,S);
			ans2+=frac((__int128)L*R*p*(odd+1-p),S);
			ans2+=frac(A*(m-p+1)*2,m+1);
			A+=L;
			ans2.refresh();
			++L;--R;++p;
		}
		for (int i=2,p=1,L=1,R=odd-1;i<=n;i+=2){
			ans2+=frac((even-p)*(R*S-pre[odd+1]+pre[p+1]),S);
			ans2+=frac((p-1)*(L*S-pre[odd+1]+pre[odd+1-p]),S);
			ans2+=frac((p-1)*(even-p)+(C2(p-1)+C2(even-p))*2,3);
			++L;--R;++p;
			ans2.refresh();
		}
		__int128 S1=0,S2=0,S3=0,S4=0,S5=0,S6=0;A=0;
		for (ll i=(n+1)/2,L=even-(n%2==0),R=(n%2==0);i;--i,--L,++R){
			ans2+=frac((L*(m-i+2)*S5+(R-1)*i*S2+((R-1)*i*S1+L*i*S3)+(L*S6-L*i*S2)),S);
			S1+=L*(m-i+1);S2+=R*(i+1);S3+=(m-i+1);S4+=R*(m-i+2)*i;S5+=(L-1)*(m-i+1);S6+=R*i*(m+2);
			ans2+=frac(i*A*2,(m+1));
			ans2.refresh();
			A+=R;
		}
		ans2.refresh();
		ans2=ans2-ans1*ans1;
		cout<<ans2<<'\n';
	}
}
struct sgt{
	ll tag[N],c0[N],c1[N];
	__int128 s0[N],s1[N],val[N],len[N];
	void pushup(ll u){
		c0[u]=c0[lson]+c0[rson];c1[u]=c1[lson]+c1[rson];
		s0[u]=s0[lson]+s0[rson]+c1[lson]*c0[rson];
		s1[u]=s1[lson]+s1[rson]+c1[lson]*c1[rson];
		val[u]=val[lson]+val[rson]+c1[lson]*s0[rson]+s1[lson]*c0[rson];
	}
	void cover(ll u,ll v){
		tag[u]=v;val[u]=0;
		if (v==0){
			c0[u]=len[u];c1[u]=s0[u]=s1[u]=0;
		}
		else{
			c0[u]=s0[u]=0;c1[u]=len[u];s1[u]=len[u]*(len[u]+1)/2;
		}
	}
	void pushdown(ll u){
		if (tag[u]!=-1){
			cover(lson,tag[u]);cover(rson,tag[u]);
			tag[u]=-1;
		}
	}
	void build(ll u,ll l,ll r,ll d){
		len[u]=r-l+1;tag[u]=-1;
		if (l==r){
			c0[u]=c1[u]=s0[u]=s1[u]=val[u]=0;
			if ((l&1)==d) c1[u]=s1[u]=1;
			else c0[u]=1;
			return;
		}
		int mid=l+r>>1;
		build(lson,l,mid,d);build(rson,mid+1,r,d);
		pushup(u);
	}
	void cover(ll u,ll l,ll r,ll L,ll R,ll v){
		if (L<=l&&r<=R){cover(u,v);return;}
		int mid=l+r>>1;pushdown(u);
		if (L<=mid) cover(lson,l,mid,L,R,v);
		if (R>mid) cover(rson,mid+1,r,L,R,v);
		pushup(u);
	}
}A,B;
ll n,m;
void output(){
	__int128 X=A.val[1],Y=B.val[1];
	ll cnt=A.c1[1];
	cout<<(frac(X+Y,cnt+1)+frac(C2(n-cnt),2))<<'\n';
}
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n>>m;
	X::solve(n,m);
	A.build(1,1,n,1);
	B.build(1,1,n,n&1);
	for (int l,r,v,i=1;i<=m;++i){
		cin>>l>>r>>v;
		A.cover(1,1,n,l,r,v);
		B.cover(1,1,n,n-r+1,n-l+1,v);
		output();
	}
	return 0;
}
```

---


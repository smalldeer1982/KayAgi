# [SDOI2012] 走迷宫

## 题目描述

Morenan 被困在了一个迷宫里。迷宫可以视为 $n$ 个点 $m$ 条边的有向图，其中 Morenan 处于起点 $s$，迷宫的终点设为 $t$。可惜的是，Morenan 非常的脑小，他只会从一个点出发随机沿着一条从该点出发的有向边，到达另一个点。这样，Morenan 走的步数可能很长，也可能是无限，更可能到不了终点。若到不了终点，则步数视为无穷大。但你必须想方设法求出 Morenan 所走步数的期望值。

## 说明/提示

| 测试点 | $n\leq$ | $m\leq$ |
| :----------: | :----------: | :----------: |
| $1\sim 6$ | $10$ | $100$ |
| $7\sim 12$ | $200$ | $10^4$ |
| $13\sim 20$ | $10^4$ | $10^6$ |

另外，均匀分布着 $40\%$ 的数据，图中没有环，也没有自环。

对于 $100\%$ 的数据，$1\leq n\leq 10^4$，$0\leq m \leq 10^6$，**保证强连通分量的大小不超过** $\boldsymbol{100}$。

## 样例 #1

### 输入

```
6 6 1 6
1 2
1 3
2 4
3 5
4 6
5 6```

### 输出

```
3.000```

## 样例 #2

### 输入

```
9 12 1 9
1 2
2 3
3 1
3 4
3 7
4 5
5 6
6 4
6 7
7 8
8 9
9 7```

### 输出

```
9.500```

## 样例 #3

### 输入

```
2 0 1 2```

### 输出

```
INF```

# 题解

## 作者：tzc_wk (赞：5)

[题面传送门](https://www.luogu.com.cn/problem/P6030)

之所以写个题解是因为题解区大部分题解的做法都有 bug（u1s1 周六上午在讨论区里连发两个 hack 的是我，由于我被禁言才让 ycx 代发的）

首先碰到这种期望题，我们套路地设 $dp_u$ 为从节点 $u$ 走到节点 $n$ 经过的节点数的期望值，那么显然有转移方程 $dp_u=\dfrac{1}{deg_u}(\sum\limits_{(u,v)\in E}dp_v)+1$，由于这个 $dp$ 方程存在环，故需按照 P3232 游走 的套路进行高斯消元，具体来说你将这 $n$ 个 $dp$ 转移式写成矩阵的形式高斯消元一下即可。

等等……$10^4$ 你让我跑高斯消元？

注意到题目中有个条件，就是每个强连通分量大小 $\le 100$，因此考虑先将原图进行一遍 SCC 缩点，缩点完成后显然原图变成了一个 DAG，我们考虑按这个 DAG 的**拓扑序倒序**（或者说，以 $t$ 为起点拓扑排序）对每个强连通分量中的点计算一遍 $dp$ 值，具体来说我们给当前强连通分量中的所有点重新编号，对于形如 $dp_u=\dfrac{1}{deg_u}(\sum\limits_{(u,v)\in E}dp_v)+1$ 的式子，如果 $v$ 与 $u$ 在同一个强连通分量中那就按照套路将式子改写成一个 $dp_u$ 与这样的 $dp_v$ 的关系式，否则由于我们按照拓扑序倒序计算答案，$dp_v$ 的值肯定已经计算好了，那么我们把它当作常数项拖到右边去即可。具体实现的时候可以以 $s$ 为起点跑一遍 `tarjan`，因为最终强连通分量的编号本身就是按拓扑序倒序编好号的了，就 duck 不必再写遍拓扑排序了，直接从 $1$ 枚举到 $\text{强连通分量个数}$ 依次计算即可。

记 $s_i$ 为强连通分量大小，那么该算法复杂度 $T(n)=\sum\limits_{i=1}^ms_i^3$，而 $s_i\le 100$，故 $T(n)\le\dfrac{10^4}{100}\times 100^3=10^8$，可以通过此题。

那么什么情况输出 `INF` 呢？显然如果 $s$ 不能到 $t$ 答案肯定是 `INF`，接下来就是我要强调的地方了，不少题解都认为，只要存在 $s$ 能到达但却不能到达 $t$ 的点就 `INF`，但考虑下面的数据：

```
3 2 1 3
1 3
3 2
```

事实上，$2$ 虽然能够从 $3$ 到达，但从 $1\to 2$ 的路径上已经经过 $3$ 了，因此是可以到达 $2$ 的，答案应当为 $1.000$。

还有的题解稍微明智些，把不能到达的点的 $dp$ 值设为 $\infty$，然后判是否有 $dp_s=\infty$，这样做是可以避免掉上述情况的，但由于实现上出了个小 bug（如果一个点出度为 $0$ 那么它的 $dp$ 值就是 $\infty$），导致其可以被以下的数据叉掉：

```
5 5 1 5
1 5
1 2
2 3
3 4
4 2
```

我的做法是，先建反图，以 $t$ 为起点做一遍 DFS 找出所有能到达 $t$ 的点，然后如果一个点不能到达 $t$ 那就令它的 $dp$ 值为 $\infty$，这样又可避免上述情况。

当然我的做法可能也存在漏洞（只是我发现不了了），如果发现漏洞请及时提出，谢谢。

我认为做题还是要严谨些，愿管理员把 hack 数据加入本题的测试数据中。

~~那问题就来了，为什么我就不能把我 hack 的这份热情放到 CF 比赛中呢~~

```cpp
const int MAXS=100;
const int MAXN=10000;
const int MAXM=1e6;
const double INF=1e15;
int n,m,s,t;
int hd[MAXN+5],to[MAXM*2+5],nxt[MAXM*2+5],ec=0;
void adde(int u,int v){to[++ec]=v;nxt[ec]=hd[u];hd[u]=ec;}
int bel[MAXN+5],cmp=0,dfn[MAXN+5],low[MAXN+5],tim=0;
bool vis[MAXN+5];int stk[MAXN+5],top=0;vector<int> scc[MAXN+5];
vector<int> rev[MAXN+5];bool can[MAXN+5];
void dfs(int x){
	if(can[x]) return;can[x]=1;
	for(int y:rev[x]) dfs(y);
}
void tarjan(int x){
	dfn[x]=low[x]=++tim;vis[x]=1;stk[++top]=x;
	for(int e=hd[x];e;e=nxt[e]){
		int y=to[e];
		if(!dfn[y]) tarjan(y),chkmin(low[x],low[y]);
		else if(vis[y]) chkmin(low[x],dfn[y]);
	}
	if(low[x]==dfn[x]){
		cmp++;int o;
		do {
			o=stk[top--];vis[o]=0;
			scc[bel[o]=cmp].pb(o);
		} while(o!=x);
	}
}
int id[MAXN+5],seq[MAXS+5],subsiz=0,deg[MAXN+5];
double dp[MAXN+5],a[MAXS+5][MAXS+5],f[MAXS+5];
int main(){
	scanf("%d%d%d%d",&n,&m,&s,&t);
	for(int i=1,u,v;i<=m;i++){
		scanf("%d%d",&u,&v);deg[u]++;
		adde(u,v);rev[v].pb(u);
	}
	tarjan(s);dfs(t);if(!dfn[t]) return puts("INF"),0;
	for(int i=1;i<=cmp;i++){
		subsiz=0;memset(a,0,sizeof(a));memset(f,0,sizeof(f));
		for(int u:scc[i]){seq[++subsiz]=u;id[u]=subsiz;}
		for(int u:scc[i]){
			int p=id[u];
			if(u==t){a[p][p]=1;continue;}
			a[p][p]=a[p][subsiz+1]=deg[u];
			for(int e=hd[u];e;e=nxt[e]){
				int v=to[e];
				if(bel[v]==bel[u]) a[p][id[v]]--;
				else a[p][subsiz+1]+=dp[v];
			}
			if(!can[u]) a[p][subsiz+1]=INF;
		}
//		for(int j=1;j<=subsiz;j++) for(int k=1;k<=subsiz+1;k++)
//			printf("%.3lf%c",a[j][k],(k==subsiz+1)?'\n':' ');
		for(int j=1;j<=subsiz;j++){
			int t=j;
			for(int k=j+1;k<=subsiz;k++) if(fabs(a[k][j])>fabs(a[t][j])) t=k;
			for(int k=j;k<=subsiz+1;k++) swap(a[t][k],a[j][k]);
			for(int k=j+1;k<=subsiz+1;k++) a[j][k]/=a[j][j];a[j][j]=1;
			for(int k=j+1;k<=subsiz;k++){
				for(int l=j+1;l<=subsiz+1;l++) a[k][l]-=a[k][j]*a[j][l];
				a[k][j]=0;
			}
		}
		for(int j=subsiz;j;j--){
			f[j]=a[j][subsiz+1];
			for(int k=j+1;k<=subsiz;k++) f[j]-=f[k]*a[j][k];
//			printf("%.3lf\n",f[j]);
		}
		for(int j=1;j<=subsiz;j++){
			if(f[j]>1e9) dp[seq[j]]=INF;
			else dp[seq[j]]=f[j];
		}
	}
//	for(int i=1;i<=n;i++) cout<<dp[i]<<endl;
	if(dp[s]>1e9) puts("INF");
	else printf("%.3lf\n",dp[s]);
	return 0;
}
```



---

## 作者：Rainybunny (赞：4)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[$luogu$](https://www.luogu.com.cn/problem/P6030).  
# 题解
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先, 列出期望方程:
$$
E(u)=1+\frac{1}{d_u}\sum_{u->v}E(v)
$$
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简单解释一下, $E(u)$表示**从$u$走到$T$的期望步数**, $d_u$是 **$u$的出度**, 那么$E(u)$就等于当前的一步$+$ $u$随机走到一个点的$v$, 点$v$走到$T$的期望步数$\times$走到$v$的概率$\frac{1}{d_u}$.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;直接消元是行不通的. 但我们注意到每个$SCC$的大小是不超过$100$的, 而联想到对于每个$SCC$内单独消元.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以, 先$Tarjan$缩点, 原图转化为了一个$DAG$. 我们按拓扑序从大到小处理每个$SCC$, 此时对于任意$u$的转移状态$v$, **若$E(v)$还没有计算, 那么$v$一定在$u$的$SCC$中**. 我们把已经计算的$E(v)$当做常数, 就能将$SCC$内的$E$构成一个方程组, 此时就能直接消元了.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意在构造方程组的时候, 特殊处理$u=T$时的$E(T)=0$和$d_u=0$时的$E(u)=+\infty$.
## 代码
```cpp
#include <cstdio>
#include <vector>
#include <cstring>

#define Int register int

using namespace std;

const double EPS = 1e-7, INF = 1e18;
const int MAXS = 100, MAXN = 1e4, MAXM = 1e6;
int n, m, S, T, Cnte, d[MAXN + 5], Head[MAXN + 5], ID[MAXN + 5];
// ID用于对同一个SCC中的E(u)编号.
int Indx, Top, CntS, DFN[MAXN + 5], Low[MAXN + 5], Stk[MAXN + 5], Col[MAXN + 5];
bool Instk[MAXN + 5];
double F[MAXN + 5], A[MAXS + 5][MAXS + 5], B[MAXS + 5], x[MAXS + 5];
vector<int> SCC[MAXN + 5];

struct Edge { int To, nxt; } Graph[MAXM + 5];

inline double Abs ( const double x ) { return x < 0 ? -x : x; }

inline int Min ( const int a, const int b ) { return a < b ? a : b; }

inline void Link ( const int s, const int t ) {
	Graph[++ Cnte].To = t;
	Graph[Cnte].nxt = Head[s];
	Head[s] = Cnte;
}

inline void Tarjan ( const int u ) {
	int v;
	DFN[u] = Low[u] = ++ Indx, Instk[Stk[++ Top] = u] = true;
	for ( Int i = Head[u]; i; i = Graph[i].nxt ) {
		if ( ! DFN[v = Graph[i].To] ) {
			Tarjan ( v );
			Low[u] = Min ( Low[u], Low[v] );
		} else if ( Instk[v] ) {
			Low[u] = Min ( Low[u], DFN[v] );
		}
	}
	if ( DFN[u] == Low[u] ) {
		++ CntS;
		do {
			Instk[v = Stk[Top --]] = false;
			Col[v] = CntS;
			ID[v] = int ( SCC[CntS].size () ) + 1;
			SCC[CntS].push_back ( v );
		} while ( u ^ v );
	}
}

inline bool Gauss ( const int n ) {
	for ( Int i = 1; i <= n; ++ i ) {
		int p = i;
		for ( Int j = i + 1; j <= n; ++ j ) {
			if ( Abs ( A[j][i] ) > Abs ( A[p][i] ) ) {
				p = j;
			}
		}
		if ( i ^ p ) swap ( A[i], A[p] ), swap ( B[i], B[p] );
		if ( Abs ( A[i][i] ) < EPS ) return false;
		for ( Int j = i + 1; j <= n; ++ j ) {
			double d = A[j][i] / A[i][i];
			B[j] -= d * B[i];
			for ( Int k = i; k <= n; ++ k ) A[j][k] -= d * A[i][k];
		}
	}
	for ( Int i = n; i; -- i ) {
		for ( Int j = i + 1; j <= n; ++ j ) B[i] -= x[j] * A[i][j];
		x[i] = B[i] / A[i][i];
	}
	return true;
}

inline void Work () {
	scanf ( "%d %d %d %d", &n, &m, &S, &T );
	for ( Int i = 1, u, v; i <= m; ++ i ) {
		scanf ( "%d %d", &u, &v );
		Link ( u, v ), ++ d[u];
	}
	Tarjan ( S );
	if ( ! DFN[T] ) return puts ( "INF" ), void ();
    // 基于Tarjan的退栈顺序, SCC的标号就是按拓扑序从大到小排序的编号. 直接循环即可.
	for ( Int i = 1; i <= CntS; ++ i ) {
		memset ( A, 0, sizeof A );
		memset ( B, 0, sizeof B );
		memset ( x, 0, sizeof x );
		for ( Int k = 0, u; k ^ SCC[i].size (); ++ k ) {
			u = SCC[i][k];
			if ( u == T ) { A[ID[u]][ID[u]] = 1.0; continue; }
			double p = 1.0 / d[u];
			A[ID[u]][ID[u]] = 1.0, B[ID[u]] = 1.0;
			for ( Int j = Head[u], v; j; j = Graph[j].nxt ) {
				if ( Col[u] == Col[v = Graph[j].To] ) {
					A[ID[u]][ID[v]] -= p;
				} else {
					B[ID[u]] += p * F[v];
				}
			}
			if ( ! Head[u] ) B[ID[u]] = INF;
		}
		Gauss ( SCC[i].size () );
		for ( Int k = 0; k ^ SCC[i].size (); ++ k ) {
			F[SCC[i][k]] = x[ID[SCC[i][k]]];
			if ( F[SCC[i][k]] > 1e10 ) F[SCC[i][k]] = INF;
		}
	}
//	for ( Int i = 1; i <= n; ++ i ) printf ( "%.3f%c", F[i], i ^ n ? ' ' : '\n' );
	if ( F[S] > 1e10 ) puts ( "INF" );
	else printf ( "%.3f\n", F[S] );
}

int main () {
	Work ();
	return 0;
}
```

---

## 作者：LastKismet (赞：1)

# Sol
可以被称之为模板的图上期望方程。~~但忘记高消干想半小时。~~

无解是简单的，当图上存在节点可以被 $s$ 不经过 $t$ 走到而无法走到 $t$ 则无解。缩点后跑一遍 dfs 即可。

如果是 DAG 那么就是简单期望问题了，逆拓扑序处理即可，期望方程过于基础就不写了。

考虑强连通分量，对于每一个强连通分量，我们都可以列出一个期望方程组，好，高斯消元一下解决了。

具体的，若当前分量有 $n$ 个节点，那么相当于 $n$ 个元，对于每一条连边，若指向的分量已经处理过，当成常数项移到右侧即可，否则指向本分量内部节点，移一下项放到等式左边，把那个 $+1$ 的常数留在右边即可。具体可以参见代码。

tarjan 缩点后点序即为逆拓扑序，所以遍历即可。

关于判无解，只需要从 $s$ 深搜一下即可，具体实现是简单的，可以参见代码。

跑的很快，最慢点 162ms，应该是快读快写和 `vector` 的功劳。

# Code
```cpp
#define poly vec<flt>
poly operator*(poly a,flt b){
    repl(i,0,a.size())a[i]*=b;
    return a;
}
poly operator+(poly a,poly b){
    repl(i,0,a.size())a[i]+=b[i];
    return a;
}
poly operator-(poly a,poly b){
    repl(i,0,a.size())a[i]-=b[i];
    return a;
}

const flt eps=1e-12;

vec<flt> Gauss(int n,vec<poly> mtx){
    int r=1;
    rep(i,1,n){
        int chs=0;
        rep(j,r,n)if(!chs||fabs(mtx[j][i])>fabs(mtx[chs][i]))chs=j;
        if(fabs(mtx[chs][i])<eps)continue;
        swap(mtx[chs],mtx[r]);
        rep(j,1,n)if(j!=r&&fabs(mtx[r][i])>eps)mtx[j]=mtx[j]-mtx[r]*(mtx[j][i]/mtx[r][i]);
        r++;
    }
    vec<flt> res(n+1);
    rep(i,1,n)res[i]=mtx[i][n+1]/mtx[i][i];
    return res;
}

int n,m,s,t;
int u,v;
vec<int> g[N];

int dcnt;
int dfn[N],low[N];
int scnt;
int scc[N];
stack<int> stk;
bool ins[N];
vec<int> SCC[N];
void tarjan(int x){
    dfn[x]=low[x]=++dcnt;
    stk.push(x),ins[x]=1;
    for(auto y:g[x]){
        if(!dfn[y]){
            tarjan(y);
            chmin(low[x],low[y]);
        }else if(ins[y])chmin(low[x],dfn[y]);
    }
    if(low[x]>=dfn[x]){
        ++scnt;
        while(1){
            int tp=stk.top();stk.pop();
            ins[tp]=0;
            scc[tp]=scnt;
            SCC[scnt].pub(tp);
            if(tp==x)break;
        }
    }
}

vec<int> G[N];
bool vis[N];

bool dfs(int x){
    if(vis[x])return 1;
    vis[x]=1;
    if(x==scc[t])return 1;
    if(G[x].empty())return 0;
    for(auto y:G[x])if(!dfs(y))return 0;
    return 1;
}

int rid[N];
flt f[N];

inline void Main(){
    read(n,m,s,t);
    rep(i,1,m){
        read(u,v);
        if(u!=t)g[u].pub(v);
    }
    rep(i,1,n)if(!dfn[i])tarjan(i);
    rep(i,1,n)if(i!=t)for(auto j:g[i])if(scc[i]!=scc[j])G[scc[i]].pub(scc[j]);
    if(!dfs(scc[s]))return put("INF");
    rep(i,1,scnt){
        if(!vis[i]||i==scc[t])continue;
        int n=SCC[i].size();
        vec<poly> mtx(n+1,poly(n+2,0));
        repl(j,0,n)rid[SCC[i][j]]=j+1,mtx[j+1][j+1]=1;
        for(auto x:SCC[i])for(auto y:g[x]){
            if(scc[x]==scc[y])mtx[rid[x]][rid[y]]-=1.0/g[x].size(),mtx[rid[x]][n+1]+=1.0/g[x].size();
            else mtx[rid[x]][n+1]+=(f[y]+1)/g[x].size();
        }
        auto res=Gauss(n,mtx);
        for(auto x:SCC[i])f[x]=res[rid[x]];
    }
    put(f[s]);
}
```

---

## 作者：Eltaos_xingyu (赞：1)

UPD On 2024/07/23：被 Hack 了，更新了提交记录，同时增加了对 Hack 数据的说明。

考虑这是一道随机游走的板子题，于是一定有 $O(n^3)$ 的朴素高斯消元解法。但是过不了。

题面中专门给了你这个加粗的字，然后一想，设强连通分量大小为 $x$，那么我们有一个 $O(x^3\times\frac{n}{x})$ 的复杂度，代表着对于每一个强连通分量进行高斯消元的做法复杂度正确。

首先判断特殊情况。如果我们 tarjan 缩点之后发现有一个**非只有经过终点才可达且非终点所在**的强连通分量出度为 $0$，那么进入这个强连通分量代表着一直到不了终点。根据期望的线性性，可以知道这个强连通分量对答案的贡献是 $+\infty$ 乘上一个常数。此时答案就是 $+\infty$。判断粗体部分就从 $s$ 开始进行不经过 $t$ 点的 DFS 就行。

然后拓扑排序，按拓扑序逆序求解每一个强连通分量。重新审视朴素求解随机游走的式子：
$$
f_{i}=[i\not = t]\left(1+\frac{1}{deg_i}\sum_{(i,j)\in E}f_j\right)
$$
发现对于缩点之后的结果，各个强连通分量之间的所有关系都是固定的，所以无后效性，可以直接转移。其他仍然用高斯消元求解即可。

判断 `INF` 的话要么就是终点不可达，要么就是存在上面说的情况。

实现起来有点史。

[AC 记录](https://www.luogu.com.cn/record/167906171)

---

## 作者：XuYueming (赞：0)

## 前言

题目链接：[洛谷](https://www.luogu.com.cn/problem/P6030)；[Hydro & bzoj](https://hydro.ac/d/bzoj/p/2707)。

[更好的体验](https://www.cnblogs.com/XuYueming/p/18317591)。

## 题意简述

有向图中，求起点到终点的期望步数。若期望不存在，输出 `INF`。

**保证强连通分量的大小不超过 $100$。**

## 题目分析

首先来想想什么情况下期望不存在。很显然是，从起点能走到一个点，而该点永远走不到终点，当然，是在走到终点马上停下的前提下。转化一下，就是从起点开始 BFS，如果遇到一个点，没有出度，并且这个点还不是终点，那么这种情况下应该输出 `INF`。但是，很多人都想错了这一步判 `INF`，详见[此帖](https://www.luogu.com.cn/discuss/862075)。

代码实现起来很简单：

```cpp
bool vis[10010];
bool check() {
	queue<int> Q;
	Q.push(S), vis[S] = true;
	bool can = false;
	while (!Q.empty()) {
		int now = Q.front(); Q.pop();
		if (now == T) {
			can = true;
			continue;
		}
		if (!xym.head[now]) return false;
		for (int i = xym.head[now], to; to = xym[i].to, i; i = xym[i].nxt) {
			if (vis[to]) continue;
			vis[to] = true;
			Q.push(to);
		}
	}
	return can;
}
```

接下来考虑如何求期望步数。

一个套路的想法，记 $f_i$ 为从 $i$ 到终点的期望步数，边界 $f_t = 0$，答案就是 $f_s$。转移就是在出边里等概率选择一条边。

$$
f_i = \cfrac{1}{du_i} \sum _ {i \to yzh} f_{yzh} + 1
$$

由于存在环形转移，所以使用高斯消元解方程组就行了。注意到，在预处理增广矩阵的时候，对于 $xym \to yzh$ 这条边，如果 $xym = t$，就不做处理；如果在之前 `check` 的时候没走到过 $xym$，即 $\operatorname{vis}[xym] = \text{false}$，也不要添加到矩阵里。

由于时间复杂度 $\Theta(n^3)$，能拿到 $70$ 分。考虑如何优化。

注意到之所以要用高斯消元，是因为存在环形转移。如果是在序列上，或者换句话说，在一个 DAG 上，我们直接 DP 就行了。所以考虑用 tarjan 缩点，强联通分量里高斯消元，分量外拓扑排序直接期望 DP。这么做正确性体现在题目中**保证强连通分量的大小不超过 $100$**，时间复杂度 $\Theta(\sum siz^3) \leq \mathcal{O}(n\max ^ 2siz)$。

具体地，我们反向跑拓扑。对于当前强联通分量里的每一个点连出的边，如果对方不是同一个强联通分量，则已经被我们计算过了，加到右边常数里；反之处理到左边系数矩阵里。

## 代码

挺快的，卡卡常[最优解](https://www.luogu.com.cn/record/168033586)。

```cpp
// #pragma GCC optimize(3)
// #pragma GCC optimize("Ofast", "inline", "-ffast-math")
// #pragma GCC target("avx", "sse2", "sse3", "sse4", "mmx")
#include <iostream>
#include <cstdio>
#define debug(a) cerr << "Line: " << __LINE__ << " " << #a << endl
#define print(a) cerr << #a << "=" << (a) << endl
#define file(a) freopen(#a".in", "r", stdin), freopen(#a".out", "w", stdout)
#define main Main(); signed main() { return ios::sync_with_stdio(0), cin.tie(0), Main(); } signed Main
using namespace std;

#include <algorithm>
#include <queue>
#include <vector>
#include <cstring>

template <size_t N, size_t M>
int guass(int, int, double [M][N], double [M], double [N]);

const double eps = 1e-10;

int n, m, S, T;
int U[1000010], V[1000010];
int du[10010];

struct Graph{
	struct node{
		int to, nxt;
	} edge[1000010 << 1];
	int eid, head[10010];
	inline void add(int u, int v){
		edge[++eid] = {v, head[u]};
		head[u] = eid;
	}
	inline node & operator [] (const int x){
		return edge[x];
	}
} xym, yzh;

bool vis[10010];
bool check() {
	queue<int> Q;
	Q.push(S), vis[S] = true;
	bool can = false;
	while (!Q.empty()) {
		int now = Q.front(); Q.pop();
		if (now == T) {
			can = true;
			continue;
		}
		if (!xym.head[now]) return false;
		for (int i = xym.head[now], to; to = xym[i].to, i; i = xym[i].nxt) {
			if (vis[to]) continue;
			vis[to] = true;
			Q.push(to);
		}
	}
	return can;
}

int dfn[10010], low[10010], timer;
int sccno[10010], scc_cnt;
int stack[10010], top;
bool in_stack[10010];
vector<int> scc[10010];
int whr[10010];
double key[110][110], val[110], res[10010][110];

void tarjan(int now) {
    dfn[now] = low[now] = ++timer, in_stack[stack[++top] = now] = true;
    for (int i = xym.head[now]; i; i = xym[i].nxt) {
        int to = xym[i].to;
        if (dfn[to] == 0) tarjan(to), low[now] = min(low[now], low[to]);
        else if (in_stack[to]) low[now] = min(low[now], dfn[to]);
    }
    if (low[now] == dfn[now]){
        ++scc_cnt;
        do {
        	int now = stack[top--];
        	in_stack[now] = false;
        	sccno[now] = scc_cnt;
			scc[scc_cnt].push_back(now);
			whr[now] = scc[scc_cnt].size();
		} while (stack[top + 1] != now);
    }
}

signed main() {
	scanf("%d%d%d%d", &n, &m, &S, &T);
	for (int i = 1, u, v; i <= m; ++i) {
		scanf("%d%d", &u, &v);
		xym.add(u, v);
		yzh.add(v, u);
		++du[u];
		U[i] = u, V[i] = v;
	}
	if (!check()) return puts("INF"), 0;
	tarjan(S);
	for (int i = 1; i <= scc_cnt; ++i) {
		int siz = scc[i].size();
		for (int j = 1; j <= siz; ++j) {
			memset(key[j], 0x00, sizeof (double) * (siz + 1));
			key[j][j] = 1;
			val[j] = scc[i][j - 1] != T;
		}
		for (const auto& u: scc[i]) if (u != T)
			for (int _ = xym.head[u], v; v = xym[_].to, _; _ = xym[_].nxt) {
				if (sccno[u] == sccno[v]) {
					key[whr[u]][whr[v]] -= 1.0 / du[u];
				} else {
					val[whr[u]] += 1.0 / du[u] * res[sccno[v]][whr[v]];
				}
			}
		guass<110, 110>(siz, siz, key, val, res[i]);
	}
	printf("%.3lf", res[sccno[S]][whr[S]]);
	return 0;
}

template <size_t N, size_t M>
int guass(int n, int m, double key[M][N], double val[M], double res[N]) {
	if (m < n) return -1;
	int nline = 1;
	for (int i = 1; i <= n; ++i) {
		int whr = nline;
		for (int j = nline + 1; j <= m; ++j)
			if (abs(key[j][i]) > abs(key[whr][i]))
				whr = j;
		if (abs(key[whr][i]) < eps) continue;
		swap(val[nline], val[whr]);
		for (int j = 1; j <= n; ++j) swap(key[nline][j], key[whr][j]);
		for (int j = 1; j <= m; ++j) if (j != nline) {
			double K = key[j][i] / key[nline][i];
			val[j] -= K * val[nline];
			for (int k = i; k <= n; ++k)
				key[j][k] -= key[nline][k] * K;
		}
		++nline;
	}
	if (nline == n + 1) {
		for (int i = 1; i <= n; ++i)
			res[i] = val[i] / key[i][i] + eps;
		return 0;
	}
	for (int i = nline; i <= m; ++i)
		if (abs(val[i]) > eps)
			return -2;
	for (int i = 1; i <= nline; ++i)
		res[i] = val[i] / key[i][i] + eps;
	return -1;
}
```

---

## 作者：Unnamed114514 (赞：0)

首先考虑 `INF`。

显然 $s$ 到不了 $t$ 或者 $s$ 能到到不了 $t$ 的点，答案就是 $\infty$。

我的实现方法是缩点之后记搜，$0$ 表示到不了，$1$ 表示能到，$dp_t=1$。然后如果 $u$ 的出点中 dp 有 $0$ 或 $u$ 没有出边，$dp_u=0$，否则 $dp_u=1$。

***

设 $f_u$ 为答案，那么有 $f_t=0$，求 $f_s$，可以列出如下方程：

$$f_u=1+\sum\limits_{(u,v)\in\mathbb E}\dfrac{f_v}{deg_u}$$

你说得对，但是直接高斯消元是 $O(n^3)$ 的，而 $n\le10^4$，只有 $60$。

注意到题目的特殊性质：保证 SCC 的大小不超过 $100$。

因此考虑的是缩点之后对每个 SCC 进行高斯消元 ，这也是 `INF` 为什么用缩点判的原因。

注意到缩点之后原图变成了 DAG，SCC 外的贡献都可以先求出来变成常数。可以考虑建反图之后拓补排序。

实际上，tarjan 得到的直接就是逆拓补序，按照 tarjan  的节点顺序递推即可。

设 SCC 大小为 $T$，时间复杂度 $O(\dfrac{n}{T}\times T^3)=O(nT^2)$，空间复杂度 $O(T^2)$。

[code](https://www.luogu.com.cn/record/158294610)

---


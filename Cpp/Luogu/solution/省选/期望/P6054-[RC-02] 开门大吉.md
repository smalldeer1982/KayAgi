# [RC-02] 开门大吉

## 题目描述

$n$ 位选手去参加节目“开门大吉”。共有 $m$ 套题，每套题包含 $p$ 个题目，第 $i$ 位选手答对第 $j$ 套题中第 $k$ 道的概率为 $f_{i,j,k}$。若某题答错则该选手的答题流程将直接结束。

若一位选手答对第 $i$ 题，会在已得到奖励的基础上，再得到 $c_i$ 元奖励。选手总是从第一道开始，按顺序答题的。

同时，为了防止过多的选手做同一套题，还有 $y$ 条形如“第 $i$ 位选手的套题编号必须至少比第 $j$ 位的大 $k$”的限制。

你需要给每一位选手分配一套题（不同选手可以相同），使得所有人的期望奖励和最小。

## 说明/提示

【样例解释】

这里只解释第二组数据。

一共只有两套题，而第二个人的套题编号大于第三个人，因此第二个人一定是选第二套，第三个人选第一套。

第二个人选第二套，期望支出：$0.2\times (1-0.5)\times 10+0.2\times 0.5 \times (1-0.3) \times 20+0.2\times 0.5 \times 0.3\times (1-0.6)  \times 30+0.2\times 0.5 \times 0.3\times 0.6  \times 50=3.66$。

其他人的计算方法类似。

【数据范围】

**本题捆绑测试。**

对于所有数据，$1\le n,m,p\le 80$，$0\le y\le 10^3$，$0\le f_{i,j,k} \le 1$，$0\le c_i\le 10^5$，$1 \le T\le 50$。保证每个测试点的输入数据大小小于 $10\text{MB}$。

Subtask 1（20 pts）：$n,m,p,y\le 7$；

Subtask 2（20 pts）：$T\le 6$，$y=0$；

Subtask 3（20 pts）：$n,m,p\le 30$，$y\le 200$；

Subtask 4（20 pts）：$T=1$；

Subtask 5（20 pts）：$T\le 5$。

## 样例 #1

### 输入

```
4
3 2 4 0
10 10 10 20
0.3 0.5 0.7 0.4
0.2 0.6 0.2 0.2
0.7 0.1 0.8 0.2
0.5 0.5 0.5 0.5
0.2 0.5 0.3 0.6
0.3 0.5 0.4 0.1
3 2 4 1
10 10 10 20
0.3 0.5 0.7 0.4
0.2 0.6 0.2 0.2
0.7 0.1 0.8 0.2
0.5 0.5 0.5 0.5
0.2 0.5 0.3 0.6
0.3 0.5 0.4 0.1
2 3 1
3 2 4 1
10 10 10 20
0.3 0.5 0.7 0.4
0.2 0.6 0.2 0.2
0.7 0.1 0.8 0.2
0.5 0.5 0.5 0.5
0.2 0.5 0.3 0.6
0.3 0.5 0.4 0.1
1 2 1
3 2 4 2
10 10 10 20
0.3 0.5 0.7 0.4
0.2 0.6 0.2 0.2
0.7 0.1 0.8 0.2
0.5 0.5 0.5 0.5
0.2 0.5 0.3 0.6
0.3 0.5 0.4 0.1
1 2 1
2 3 1```

### 输出

```
15.1460
18.5340
18.7560
-1```

# 题解

## 作者：wind_whisper (赞：39)

# $\text{Foreword}$ 
upd：图挂了，但懒得修，想看图可以去 [CSDN]看(https://blog.csdn.net/BUG_Creater_jie/article/details/122745566)

本题的大部分题解采用了一个连反向不限流边的做法，但这似乎并没有抓到问题的实质，而是对问题的一个间接的修正。  
本文配合图像对这个问题进行了重点讨论，希望管理员能给予通过。  
# $\text{Description}$
[P6054 开门大吉](https://www.luogu.com.cn/problem/P6054)
>$n$ 位选手去参加节目“开门大吉”。共有 $m$ 套题，每套题包含 $p$ 个题目，第 $i$ 位选手答对第 $j$ 套题中第 $k$ 道的概率为 $f_{i,j,k}$。  
若一位选手答对第 $i$ 题，会在已得到奖励的基础上，再得到 $c_i$ 元奖励。选手总是从第一道开始，按顺序答题的。  
同时，为了防止过多的选手做同一套题，还有 $y$ 条形如“第 $i$ 位选手的套题编号必须至少比第 $j$ 位的大 $k$”的限制。  
你需要给每一位选手分配一套题（不同选手可以相同），使得所有人的期望奖励和最小。

# $\text{Solution}$
[安利一下我的网络流博客。](https://blog.csdn.net/BUG_Creater_jie/article/details/122685276)  

首先，我们可以简单的算出 $i$ 选手选套题 $j$ 的期望价值 $v_{i,j}$。  
关键就在于如何表示限制。  
建出 $n$ 条长度为 $m+1$ 的链，设链上的点为 $p_{1...n,1..m+1}$，连边 $(S,p_{i,1},INF),(p_{i,m+1},T,INF),(p_{i,j},p_{i,j+1},v_{i,j})$。断掉 $(p_{i,j},p_{i,j+1},v_{i,j})$ 的边即表示令 $i$ 选手做 $j$ 号题。  
这样建图之后限制就容易表示了，设 $i$ 选手比 $j$ 选手题目编号至少大 $k$，就对于所有合法的下标 $x$，均连边 $(p_{j,x},p_{i,x+k},INF)$ 即可。  

但是这样是无法通过本题的。  
主流题解都说还需要加上 $(p_{i,j+1},p_{i,j},INF)$ 的边，以实现限制的传递性（或者说保证每条链只断一条边），但我认为这并不是问题的本质，这个连边方法并不是必须的，[实践结果](https://www.luogu.com.cn/record/68286741)也证明了这一点。  
我们来看看原来的做法到底为什么出错。  
原来的连边方式其实是很健全的，它本身已经有了传递性，如：
![](https://img-blog.csdnimg.cn/be66aedf9ece4419adb4906f4a5a2db1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAd2luZF9fd2hpc3Blcg==,size_20,color_FFFFFF,t_70,g_se,x_16)
红线和绿线限制已经可以进行传递，形成黄色的限制。  
那么为什么我们难以通过一些测试点呢？  
因为**我们的限制没有加全！**  
题解和我一开始的写法对于限制的加边一般都是写成类似下边的形式：

```cpp
for(int j=max(1,1-k);j<=m+1&&j+k<=m+1;j++) add(id[y][j],id[x][j+k],inf);
```
但正确的写法应该是：

```cpp
for(int j=max(1,1-k);j<=m+1;j++) add(id[y][j],id[x][min(j+k,m+1)],inf);
```
这两个具象一下就是两张图的差别：（图片可见文首链接）

注意到，在第一种加法中，后面的两个点没有被限制，成了“法外之地”，这也是为什么加完反向边可以把这个问题修正的原因。而在新的加边方式上，那两个点直接和点 $m+1$ 相连，由于点 $m+1$ 和 $T$ 连有 $INF$ 的边，这本质也就表明这两个点必然不能被选取，是符合事实的。  

即使可以通过加反向边的方式通过本题，从问题的本质来看也是不太优美的。因此，建议直接把加限制边的方式修改，而不是进行侧面的修正。
# $\text{Code}$

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned long long
#define debug(...) fprintf(stderr,__VA_ARGS__)
#define ok debug("OK\n")
inline ll read(){
	ll x(0),f(1);char c=getchar();
	while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
	while(isdigit(c)){x=(x<<1)+(x<<3)+c-'0';c=getchar();}
	return x*f;
}
const int N=2e5+100;
const int M=2e6+100;
const double inf=1e11;
const double eps=1e-6;

int n,m,num,y;
int flag;

int tot,s,t;
struct node{
	int to,nxt;
	double cap;
}p[M<<1];
int fi[N],cur[N],cnt;
inline void addline(int x,int y,double c){
	p[++cnt]=(node){y,fi[x],c};fi[x]=cnt;
}
inline void add(int x,int y,double c){
	//printf("%d->%d cap=%.2lf\n\n",x,y,c);
	addline(x,y,c);addline(y,x,0);
}
int bel[N];
queue<int>que;
int bfs(){
	fill(bel,bel+1+tot,0);
	bel[s]=1;que.push(s);
	while(!que.empty()){
		int now=que.front();que.pop();
		for(int i=cur[now]=fi[now];~i;i=p[i].nxt){
			int to=p[i].to;
			if(p[i].cap<eps||bel[to]) continue;
			bel[to]=bel[now]+1;
			que.push(to);
		}
	}
	return bel[t];
}
double dfs(int x,double lim){
	if(x==t||lim<eps) return lim;
	double res(0);
	for(int &i=cur[x];~i;i=p[i].nxt){
		int to=p[i].to;
		if(bel[to]!=bel[x]+1) continue;
		double add=dfs(to,min(lim,p[i].cap));
		res+=add;lim-=add;
		p[i].cap-=add;p[i^1].cap+=add;
		//printf("x=%d to=%d add=%lf\n",x,to,add);
		if(lim<eps) break;
	}
	if(res<eps) bel[x]=-1;
	return res;
}
void dinic(){
	double flow(0),tmp(0);
	while(bfs()){
		while((tmp=dfs(s,inf))>eps) flow+=tmp;
		if(flow>=inf){
			puts("-1");return;
		}
	}
	printf("%lf\n",flow);
	return;
}
int id[90][90];
int c[90];
double ans;
double f[90][90][90],pp[90][90][90],val[90][90];
void init(){
	ans=0;
	tot=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m+1;j++) id[i][j]=++tot;
	}
	s=++tot;t=++tot;
	memset(fi,-1,sizeof(fi));cnt=-1;
}
void calc(){
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			pp[i][j][0]=1;val[i][j]=0;
			for(int k=1;k<=num;k++) pp[i][j][k]=pp[i][j][k-1]*f[i][j][k];
			for(int k=1;k<=num;k++){
				pp[i][j][k]=pp[i][j][k]*(1-f[i][j][k+1]);
				val[i][j]+=pp[i][j][k]*c[k];
			}
			//printf("i=%d j=%d val=%lf\n",i,j,val[i][j]);
		}
	}
}

void work(){
	n=read();m=read();num=read();y=read();
	init();
	for(int i=1;i<=num;i++) c[i]=read()+c[i-1];
	for(int j=1;j<=m;j++){
		for(int i=1;i<=n;i++){
			for(int k=1;k<=num;k++) scanf("%lf",&f[i][j][k]);
		}
	}
	calc();
	for(int i=1;i<=n;i++){
		add(s,id[i][1],inf);
		add(id[i][m+1],t,inf);
		for(int j=1;j<=m;j++){
			add(id[i][j],id[i][j+1],val[i][j]);//add(id[i][j+1],id[i][j],inf);
		}
	}
	for(int i=1;i<=y;i++){
		int x=read(),y=read(),k=read();
		for(int j=max(1,1-k);j<=m+1;j++) add(id[y][j],id[x][min(j+k,m+1)],inf);
	}
	dinic();
	
	return;
}
signed main(){
	#ifndef ONLINE_JUDGE
	//freopen("a.in","r",stdin);
	//freopen("a.out","w",stdout);
	#endif
	int T=read();
	while(T--) work();
	return 0;
}
/*
1
3 2 4 1
10 10 10 20
0.3 0.5 0.7 0.4
0.2 0.6 0.2 0.2
0.7 0.1 0.8 0.2
0.5 0.5 0.5 0.5
0.2 0.5 0.3 0.6
0.3 0.5 0.4 0.1
2 3 1
*/
 
```



---

## 作者：Boeing (赞：19)

## 有图的详细解释和代替 $(i,j+1) - (i,j)$ 神秘连边的另一种解决方法

作为网络流萌新终于弄懂了，楼上都没有图，这里给放个图，并给出最令人费解的连边，$(i,j+1) - (i,j)$ 连 $\inf$ 边的样例解释和**另一种更简便的解决办法**。

### 1. 解释 $(i,j,k)$ 限制边的连法


------------


图中的每个点 $(i,j)$ 表示第 $i$ 个人做第 $j$ 套题的值，并且没有连接上面说的那种反边。

![](https://cdn.luogu.com.cn/upload/image_hosting/93qnk0gg.png)

我们找出其中一个单元来详细解释限制 $k$ 的连法。

![](https://cdn.luogu.com.cn/upload/image_hosting/ixxiyvqi.png)

在选择断边 $(2,3) - (2,4)$ 之后，我们发现图还是通过两个绿线相连，所以为了割开图需要在两条绿线的公共边再割掉一条边(为什么不能选择不共线的地方都断开，因为那样就不是最小割了，如果那样断的话 $(2,3) - (2,4)$ 就没有必要断开图也可以断开，你相当于做了别的选择)，也就达到了我们要求 $j$ 的选择比 $i$ 的选择大 $k$ 的要求。

注意：我们连接的 inf 边只是为了联通两个点，限制割边，而且割断它本身就是没有实际意义的，其本身不能被割掉，因为我们要求的是最小割，那显然只能割不为 inf 的边，如果其被割开，说明该图无解。

我们放到完整图上把断边模拟出来也一样。

![](https://cdn.luogu.com.cn/upload/image_hosting/4hk8cfyh.png)

注意：图的割指的是删除边使得从 $S$ 无法到达 $T$，而不是从 $S$ 到 $T$ 上没有任何边相连，所以断开 $(1,5)-(1,6)$ 也是合法的图的割。

### 2. 解释 $(i,j+1)-(i,j)$ 的 $\inf$ 边


------------

重点来到最后那个莫名其妙的连边，$(i,j+1)-(i,j)$ 的 $\inf$ 边，其实它是为了处理这种情况。

给出一个样例，数据来自于楼上的评论区@_Enthalpy。

![](https://cdn.luogu.com.cn/upload/image_hosting/h1bbn7z9.png)

m=5 ,限制 $(1,2,3)$ , $(2,3,3)$，显然是无解的，但是在我们构造的图里却可以通过删除 4 组边使其有小于 inf 的割。

其根本原因是因为，$(2,1), (2,2), (2,3)$ 这三个点因为太小，没有对应的 $(3,j)$ 与其连边，所以它本质上没有受到 $(2,3,3)$ 这组的限制。所以我们需要把这样的限制传递下去，所以在连上 $(i,j+1) - (i,j)$ 这样的边后，再看这张图。

![](https://cdn.luogu.com.cn/upload/image_hosting/vueduuqg.png)

发现刚才的割不起效果了，$S$ 和 $T$ 在新图里仍然可以通过这条绿线连接了，这样就把限制传递下去了。

### 3. 提供代替方法


------------


这里给出另外一种直接了当的方法，从本质解决问题，既然是有些点没有受到限制，我们就把限制给上去，可以发现 $(2,1), (2,2), (2,3), (3,4), (3,5)$ 这几个点，因为 $(2,3,3)$ 这组限制，无论何种方案，这些点始终是不合法的，因为没有对应的其他点和它们进行合法的匹配。

例如，如果选了 $(2,2)$，那么我起码要选择 $(3,-1)$ 才能满足那组限制，显然不合法。

**所以我们将这些不合法点 $(i,j)$ 的 $(i,j) - (i,j+1)$ 这条边，流量变为 $\inf$**，这条边的意义就是选择 $(i,j)$，但这种选择本身就是不合法的，所以直接断开也就是变成 $\inf$ 边，上图：

![](https://cdn.luogu.com.cn/upload/image_hosting/ytqi3vcy.png)


紫色的是限制 $(1,2,3)$ 造成的，绿色的是限制 $(2,3,3)$ 造成的。

因为这两组限制，我们将这些边的流量变为 $\inf$，这样对于一组限制 $(x,y,k)$，所有的 $(x,j)$ 和 $(y,j)$ 点都受到了该限制的效果，没有遗漏，问题也就完美解决了。

**一定要注意！**：$m = 5$，对于 $(1,2,-3)$ 这组限制，$(2,1)$ 是一个合法点，并不用变 $\inf$ 边，虽然没有对应的 $(1,j)$ 和它连边，但实际上只要 $j>=2$ 那么一个点 $(1,j)$ 就是和它合法配对的，而j显然大于 $-2$，所以 $(2,1)$ 这个点所对应的 $1$ 位置的点一定合法，它没有受到限制的原因是这组限制对于这个点没有意义。

同理，对于点 $(1,5)$ 同样也不受到组限制的约束，理由同上，由此可见，**对于 $k<0$ 的约束没有换 $\inf$ 边的必要，只有 $k>0$ 的才需要换边**。

附上代码

```cpp
#include<bits/stdc++.h>
#define maxn 85
#define maxd 200005
#define M(x) memset(x,0,sizeof(x));
struct edge{
	int t,next;
	double v;
} g[maxd<<3];
const double inf=100000007.0;
const double eps=1e-5;
double val[maxn][maxn],ans;
int head[maxd],c_head[maxd],dis[maxd],vis[maxd],tot=1,n,m,p,o,start,to,T,c[maxn];
std::queue<int> q;
int make(int x,int y){return x*(m+1)-y+1;}
void link(int x,int y,double z,double k=0)
{
	g[++tot]=edge{y,head[x],z};head[x]=tot;
	g[++tot]=edge{x,head[y],k};head[y]=tot;
}
int bfs(void)
{
	for(int i=0;i<=to;i++) dis[i]=0,c_head[i]=head[i];
	while(!q.empty()) q.pop();
	dis[start]=1;q.push(start);
	while(!q.empty())
	{
		int x=q.front();q.pop();
		for(int y,i=head[x];i;i=g[i].next)
		{
			y=g[i].t;
			if(dis[y]||g[i].v<eps) continue;
			dis[y]=dis[x]+1;
			q.push(y);
		}
	}
	return dis[to];
}
double dfs(int x,double w)
{
	if(x==to) {ans+=w;return w;}
	if(w==0) return 0;
	double sum=0;
	for(int y,i=c_head[x];i&&eps<w-sum;i=g[i].next)
	{
		c_head[x]=i;y=g[i].t;
		if(dis[y]!=dis[x]+1) continue;
		double t=dfs(y,std::min(w-sum,g[i].v));
		if(t>=inf) return -1;
		if(t) g[i].v-=t,g[i^1].v+=t,sum+=t;
	}
	return sum;
}
int main(void)
{
	scanf("%d",&T);
	while(T--)
	{
		M(val);M(head);M(c);M(vis);ans=0;tot=1;
		scanf("%d%d%d%d",&n,&m,&p,&o);
		start=make(n,0)+1;to=start+1;
		for(int x,i=1;i<=p;i++) scanf("%d",c+i);
		for(int j=1;j<=m;j++)
		{
			for(int i=1;i<=n;i++)
			{
				double sum=1,x;
				for(int k=1;k<=p;k++)
				{
					scanf("%lf",&x);sum*=x;
					val[i][j]+=sum*c[k];
				}
			}
		}
		for(int x,y,k,i=1;i<=o;i++)
		{
			scanf("%d%d%d",&x,&y,&k);
			for(int j=1;j<=m;j++)
				if(j+k>=1&&j+k<=m+1) link(make(y,j),make(x,j+k),inf);
				else if(j+k>m) vis[make(y,j)]=1;
			k=-k;if(k>=0) continue;
			for(int j=1;j<=m;j++)
				if(j+k<1) vis[make(x,j)]=1;
				else break;
		}
		for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) link(make(i,j),make(i,j+1),vis[make(i,j)]?inf:val[i][j]);
		for(int i=1;i<=n;i++) link(make(i,m+1),to,inf),link(start,make(i,1),inf);
		while(bfs()&&ans<inf) dfs(start,inf*2);
		if(ans>=inf) printf("-1\n");
		else printf("%lf\n",ans);
	}
} 
```


---

## 作者：When (赞：4)

### 算法
神仙期望+最小割题。

### 思路
**注意：** 开门大吉这个游戏需要答对前面的所有题目以后才能回答下一题！（也就是概率要累乘）

首先，我们很容易求得第 $i$ 位选手做第 $j$ 套题的期望得分，记为 $g(i,j)$。

接下来，考虑从最小割的角度来建图。

首先将“第 $i$ 位选手做第 $j$ 套题”这个事件作为一个点，记为 $(i,j)$。那么可以连 $(i,j)-(j,j+1)$ 流量为 $g(i,j)$ 的边，如果割掉了这条边，说明第 $i$ 位选手通过做 $j$ 套题得到了 $g(i,j)$ 分。为了使得每一个人都可以做题，还要连 $s-(i,1)$ 和 $(i,m+1),t$ 流量都为 $inf$。

然后考虑如何满足限制。如果要求 $i$ 比 $j$ 做的题大 $k$，那么可以连 $(j,x)-(i,x+l)(l\ge k)$ 流量为 $inf$ 的边（当然两端的点要合法），这样的话如果将 $(j,x)-(j,x+1)$ 割掉，那么一定要在 $\ge x+k$ 的地方割掉一条 $i$ 的边，不然图就任然会联通。

但是，仅根据以上方式建图并不能通过所有测试点，原因是限制并不能传递，也就是说，当你选择 $(j,x)$ 之后，可以通过选择 $(i,y)(y<x+l)$ 来使得图不连通，所以还需要连  $(i,j)-(i,j-1)$ 流量为 $inf$ 的边来传递限制。（注意：以上的 $i,j,x$ 含义并不相同）

至于判断无解，只需要在流量超过 $inf$ 的时候退出就行了。

### 参考代码
```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <queue>
#include <cmath>
#define LL long long
#define db double
#define eps 1e-10
#define inf 1e15

using namespace std;

inline LL read(){
    LL x = 0, f = 1; char c = getchar();
    while(c < '0' || c > '9'){if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9'){x = x * 10 + c - '0'; c = getchar();}
    return x * f;
}

const int maxn = 5e5 + 10, N = 85, INF = 0x3f3f3f3f;
int n,m,p,y,c[N];
int num = 1,head[maxn],s,t;
db g[N][N];
struct Edge{int then,to; db val;}e[maxn << 1];

void add(int u, int v, db val){
    e[++num] = (Edge){head[u], v, val}; head[u] = num;
    e[++num] = (Edge){head[v], u, 0}; head[v] = num;
}

int Get(int i, int j){return n * (j - 1) + i;}

int dep[maxn]; bool vis[maxn];
bool bfs(int st, int en){
    queue<int> q;
    memset(vis, 0, sizeof(vis));
    memset(dep, 0x3f, sizeof(dep));
    q.push(st), dep[st] = 0, vis[st] = 1;
    while(!q.empty()){
        int u = q.front();
        q.pop(), vis[u] = 0;
        for(int i = head[u]; i; i = e[i].then){
            int v = e[i].to;
            if(e[i].val > eps && dep[v] == INF){
                dep[v] = dep[u] + 1;
                if(!vis[v]) vis[v] = 1, q.push(v);
            }
        }
    }
    return (dep[en] != INF);
}

int cur[maxn];
db dfs(int u, db sum){
    if(u == t) return sum;
    db now = 0;
    for(int &i = cur[u]; i; i = e[i].then){
        int v = e[i].to;
        if(e[i].val > eps && dep[v] == dep[u] + 1){
            db a = dfs(v, min(e[i].val, sum - now));
            e[i].val -= a, e[i ^ 1].val += a, now += a;
            if(fabs(now - sum) < eps) return now;
        }
    }
    return now;
}

void Dinic(){
    db Maxflow = 0;
    while(bfs(s, t)){
        memcpy(cur, head, sizeof(head));
        Maxflow += dfs(s, inf);
        if(Maxflow > inf){
            printf("-1\n");
            return;
        }
    }
    printf("%.5lf\n", Maxflow);
}

void solve(){
    memset(g, 0, sizeof(g));
    memset(head, 0, sizeof(head));
    num = 1;
    n = read(), m = read(), p = read(), y = read();
    s = n * (m + 1) + 1, t = n * (m + 1) + 2;
    for(int i = 1; i <= p; ++ i) c[i] = read();
    for(int j = 1; j <= m; ++ j)
        for(int i = 1; i <= n; ++ i){
            db val = 1;
            for(int k = 1; k <= p; ++ k){
                db f; scanf("%lf", &f); val *= f;
                g[i][j] += c[k] * val;
            }
        }
    for(int i = 1; i <= n; ++ i){
        add(s, Get(i, 1), inf);
        add(Get(i, m + 1), t, inf);
        for(int j = 1; j <= m; ++ j){
            add(Get(i, j), Get(i, j + 1), g[i][j]);
            add(Get(i, j + 1), Get(i, j), inf);
        }
    }
    for(int cas = 1; cas <= y; ++ cas){
        int i = read(), j = read(), k = read();
        for(int x = 1; x <= m; ++ x)
            if(x + k >= 1 && x + k <= m + 1)
                add(Get(j, x), Get(i, x + k), inf);
    }
    Dinic();
}

int main(){
    int Cas = read();
    while(Cas--) solve();
    return 0;
}
```

---

## 作者：yyyx_ (赞：3)

本题解主要**警示后人**，如果你完全不懂，建议去楼上看其他大佬的题解。

本质与 [P3227 [HNOI2013] 切糕](https://www.luogu.com.cn/problem/P3227) 一致。

你考虑将选择哪套题目转化为网络流上的割边，令题目代价为边的流量，则最小割即为答案。

对于每条约束，连边 $(j,p),(i,p+k)$，权值为 $\infty$。

这样使得 $id_i-id_j<k$ 时不能仅割断 $id_i,id_j$ 两条边使得图不连通。容易证明多选一条边是不优的。

以下是作者整合和~~亲身经历~~的错误：

1. 题意：没说明若第 $i$ 题答错，直接结束答题。~~（怎么还没修啊）~~
2. 题意：是“大 $k$”，而不是“差大于 $k$”。
3. 如使用 `cout`，若不加 `std::fixed` 会用科学计数法输出。
4. `double` 自带的 #INF 相减的值为 NaN。
5. 用总流量判无解，而不是一次增广的流量。

6. 多测清空要一直到 $T$（网络流汇点）。

7. 自定义的 `Point(x,y)`，即二维点转点编号应如下（除非你不是用 $(i,m+1)$ 虚点来避免取不合法点的）：

```cpp
#define Point(x, y) ((x - 1) * 82 + y)
```

```cpp
// 错误示范
#define Point(x, y) ((x - 1) * 80 + y)
```

8. 建边不能只建距离为 $k$ 的，要将边缘长度不足 $k$ 的继续连边，因为他们同样不满足条件，具体可以看以下代码区别：

```cpp
// 正确的
for (int i = max(1, 1 - k); i <= m + 1; i++)
    add_edge(Point(y, i), Point(x, min(i + k, m + 1)), inf);
```

```cpp
// 错误的
for (int i = 1; i <= m + 1; i++)
    if (i + k <= m + 1 && i + k >= 1)
        add_edge(Point(y, i), Point(x, i + k), inf);
```

附代码。


```cpp
#include <bits/stdc++.h>
using namespace std;

template <typename T>
inline void read(T &x)
{
    x = 0;
    register char c = getchar();
    register short f = 1;
    while (c < '0' || c > '9')
    {
        if (c == '-')
            f = -1;
        c = getchar();
    }
    while (c >= '0' && c <= '9')
    {
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    x *= f;
}

template <typename T, typename... Args>
inline void read(T &x, Args &...temps)
{
    read(x), read(temps...);
}

const int N = 82;
typedef double ll;
const ll inf = 1e18;
const ll eps = 1e-9;

int S, T;
vector<int> tag[N * N * 4], dep, res;
vector<pair<int, ll>> g;
#define Point(x, y) ((x - 1) * 82 + y)

void add_edge(int x, int y, ll w)
{
    tag[x].emplace_back(g.size());
    g.emplace_back(y, w);
    tag[y].emplace_back(g.size());
    g.emplace_back(x, 0);
}

#define is0(x) (x < eps ? 1 : 0)

bool bfs()
{
    dep.assign(T + 1, 0);
    res.assign(T + 1, 0);
    queue<int> q;
    dep[S] = 1;
    q.emplace(S);
    while (!q.empty())
    {
        int x = q.front();
        q.pop();
        for (auto id : tag[x])
        {
            auto [y, w] = g[id];
            if (dep[y] || is0(w))
                continue;
            dep[y] = dep[x] + 1;
            if (y == T)
                return 1;
            q.emplace(y);
        }
    }
    return dep[T];
}

ll dfs(int x, ll flow)
{
    if (x == T)
        return flow;
    ll cnt = 0;
    for (int &i = res[x]; i < tag[x].size(); i++)
    {
        int id = tag[x][i];
        auto &[y, w] = g[id];
        if (dep[x] + 1 != dep[y] || is0(w))
            continue;
        ll fw = dfs(y, min(flow, w));
        if (fw)
        {
            cnt += fw;
            flow -= fw;
            w -= fw;
            g[id ^ 1].second += fw;
            if (!flow)
                break;
        }
    }
    return cnt;
}

int TwT, n, m, P, Q;
ll v[N][N];

ll dinic()
{
    ll ans = 0;
    while (bfs())
    {
        ans += dfs(S, inf);
        if (ans >= inf)
            return -1;
    }
    return ans;
}

void clear()
{
    for (int i = 0; i <= T; i++)
        tag[i].clear();
    g.clear();
}

signed main()
{
    read(TwT);
    while (TwT--)
    {
        read(n, m, P, Q);
        vector<int> c(P);
        for (auto &x : c)
            read(x);
        for (int j = 1; j <= m; j++)
            for (int i = 1; i <= n; i++)
            {
                v[i][j] = 0;
                ll x = 0, y = 1;
                for (int k = 0; k < P; k++)
                {
                    scanf("%lf", &x);
                    v[i][j] += (y *= x) * c[k];
                }
            }
        S = 0, T = Point(n, m + 1) + 1;
        clear();
        for (int i = 1; i <= n; i++)
        {
            add_edge(S, Point(i, 1), inf);
            add_edge(Point(i, m + 1), T, inf);
        }
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= m; j++)
                add_edge(Point(i, j), Point(i, j + 1), v[i][j]);
        for (int x, y, k; Q--;)
        {
            read(x, y, k);
            for (int i = max(1, 1 - k); i <= m + 1; i++)
                add_edge(Point(y, i), Point(x, min(i + k, m + 1)), inf);
        }
        auto ans = dinic();
        if (ans < 0)
            puts("-1");
        else
            printf("%.9lf\n", ans);
    }

    return 0;
}
```

---

## 作者：liangbowen (赞：3)

[blog](https:https://www.cnblogs.com/liangbowen/p/17968287)。网络流——最小割。

---

每个选手做某一套题的期望奖励固定，计算方式参考样例解释。这个假期望被去掉了。

发现是典型的「$m$ 种强制选一」问题。考虑每个人都建一条链，跑最小割，每条链必定割 $\ge1$ 条边，割哪条边就表示选哪套题。

![](https://cdn.luogu.com.cn/upload/image_hosting/klux150x.png)

对于大小关系的限制，例如 $(i,j,k)=(1,2,1)$，那么不能同时割 $\text{cut}_{1,x}$ 与 $\text{cut}_{2,y}$（$x-y\le1$）。限制这种割法仍能够流到汇点即可。

![](https://cdn.luogu.com.cn/upload/image_hosting/qf28mi9q.png)

不得不割掉 INF 边时无解，判最终流量即可。注意 Dinic 开 `double`，判一下浮点数误差，正常实现都可以......拿到 $80$ 分。

怎么会是呢？原来会存在一条链割掉多条边（一个人做几套题）的情况。**不需要像其他题解一样建反向边**，只需要为每条边加一个 $+\infty^*$，最后减掉 $n\times\infty^*$ 即可。

[code](https://www.luogu.com.cn/paste/p1ftqgkr)，时间复杂度即 Dinic 复杂度。


---

## 作者：feecle6418 (赞：3)

官方题解：https://www.luogu.com.cn/blog/feecle6418/rcoi2020-day-1-ti-xie 

这里提供的是 std。

```cpp
#include <bits/stdc++.h>
#define inf 1e10
using namespace std;
int n,m,p,cnt=1,h[20005],dis[20005],gap[20005],S,T,N,c[85],Y;
double f[85][85][85],cost[85][85];
struct Edge {
	int to,next;
	double flow;
} e[600005];
void Add_Edge(int x,int y,double z) {
	e[++cnt]=(Edge) {
		y,h[x],z
	};
	h[x]=cnt;
	e[++cnt]=(Edge) {
		x,h[y],0
	};
	h[y]=cnt;
}
double DFS(int now,double maxf,int s,int t) {
	if(now==t||maxf<1e-10)return maxf;
	double ret=0;
	for(int i=h[now]; i; i=e[i].next) {
		int y=e[i].to;
		if(!e[i].flow||dis[y]+1!=dis[now])continue;
		double dlt=DFS(y,min(maxf,e[i].flow),s,t);
		e[i].flow-=dlt,e[i^1].flow+=dlt;
		maxf-=dlt,ret+=dlt;
		if(dis[s]==N||maxf<1e-10)return ret;
	}
	if(!(--gap[dis[now]]))dis[s]=N;
	else gap[++dis[now]]++;
	return ret;
}
double SAP(int s,int t) {
	double ret=0;
	memset(gap,0,sizeof(gap));
	memset(dis,0,sizeof(dis));
	gap[0]=N;
	while(dis[s]<N){
		ret+=DFS(s,inf,s,t);
		if(ret>inf)return ret;
	}
	return ret;
}
int pos(int x,int y) {
	return (x-1)*(m+1)+y;
}
int main() {
//	freopen("1.in","r",stdin);
//	freopen("1.out","w",stdout);
	int Ttt;
	scanf("%d",&Ttt);
	while(Ttt--) {
		cnt=1;
		memset(h,0,sizeof(h)),memset(e,0,sizeof(e)),memset(cost,0,sizeof(cost));
		scanf("%d%d%d%d",&n,&m,&p,&Y);
		S=pos(n,m+1)+1,T=N=S+1;
		for(int i=1; i<=p; i++)scanf("%d",&c[i]);
		for(int j=1; j<=m; j++) {
			for(int i=1; i<=n; i++) {
				double gl=1;
				for(int k=1; k<=p; k++) {
					scanf("%lf",&f[i][j][k]);
					gl*=f[i][j][k];
					cost[i][j]+=gl*c[k];
				}
			}
		}
		for(int i=1; i<=n; i++) {
			Add_Edge(S,pos(i,1),inf);
			Add_Edge(pos(i,m+1),T,inf);
			for(int j=1; j<=m; j++) {
				Add_Edge(pos(i,j),pos(i,j+1),cost[i][j]);
				Add_Edge(pos(i,j+1),pos(i,j),inf);
			}
		}
		for(int i=1,x,y,k; i<=Y; i++) {
			scanf("%d%d%d",&x,&y,&k);
			for(int j=1; j<=m; j++){
				if(j+k>=1&&j+k<=m+1)Add_Edge(pos(y,j),pos(x,j+k),inf);
			}
		}
		double ans=SAP(S,T);
		if(ans<inf)printf("%.4lf\n",ans);
		else puts("-1");
	}
	return 0;
}
```

---

## 作者：gyyyyx (赞：2)

这是一道[切糕](https://www.luogu.com.cn/problem/P3227)模型的题。

我们可以采取**割边**的方式代表一个变量的**选择**。

我们对每个变量 $i$ 建立 $(i,j)\to(i,j+1)$ 的链，其中 $1\leq j\leq t_i$，并让 $(i,j)\to(i,j+1)$ 的容量为 $v_{i,j}$，割掉这条边代表 $x_i=j$。

接着连 $s\to (i,1)$ 以及 $(i,t_i+1)\to t$，容量无限。

那我们如何表示限制呢？

我们如果割了 $(b_i,j)\to(b_i,j+1)$，那么代表 $x_{b_i}=j$，则 $x_{a_i}\geq j+d_i$，也就是我们不能割 $(a_i,1)\to(a_i,2),(a_i,2)\to (a_i,3),\cdots,(a_i,j+d_i-1)\to(a_i,j+d_i)$。

那我们需要考虑的就是割了 $(b_i,j)\to(b_i,j+1)$ 之后，如何在不割 $(a_i,j+d_i)\to(a_i,j+d_i+1),\cdots,(a_i,t_{a_i})\to(a_i,t_{a_i}+1)$ 的情况下，让 $(a_i,1),(a_i,2),\cdots,(a_i,j+d_i)$ 一定可以由源点到达且到达汇点。

注意到 $(b_i,1)\to (b_i,2),\cdots,(b_i,j-1)\to(b_i,j)$ 是没有被割的，考虑连 $(b_i,j)\to(a_i,j+d_i)$，显然这样可以满足要求。

那么我们现在建图就很明了了：

1. $s\to (i,1)$，容量无限。
2. $(i,j)\to(i,j+1)$，容量为 $v_{i,j}$。
3. $(i,t_i+1)\to t$，容量无限。
4. $(b_i,j)\to(a_i,j+d_i)$，容量无限。

之后我们称第四类边为限制边。

建图之后就像这样：
![](https://cdn.luogu.com.cn/upload/image_hosting/jsqee7ue.png)
但是这样的建图会出现一个严重的问题：如何保证一个变量**只会取一个值**？也就是如何保证一条链**只会被割一条边**？

我们先来思考一下为什么会出现一条链上被割两条甚至更多边。

若不存在限制边，那么显然一条链上只可能割一条边，否则都不可能是最优的。

那么根据限制边的实际含义，我们可以猜想：如果一条链上被割两条边说明我们希望 $x_u,x_v,x_w$ 满足 $x_u\geq x_v+a,x_v\geq x_w+b$，但不满足 $x_u\geq x_w+a+b$，那么此时 $x_v$ 便需要两个取值，代表 $x_v$ 的链便可能被割两条边。

但是其实我们的建图方式的非常完备的，$(x_v,i)\to(x_u,i+a)$ 和 $(x_w,i)\to (x_v,i+b)$ 已经可以完全代替 $(x_wi)\to(x_u,i+a+b)$ 了。

那么到底是什么导致了无法完全限制呢？

等等……我们的建图方式真的完备吗？

来看看这张图：
![](https://cdn.luogu.com.cn/upload/image_hosting/8o4hmxci.png)
注意观察图上红色的边，从图上看，这两条边**只受到了来自下方的链的限制**，而它并**没有限制上方的链**。

但是！实际上如果割掉了红边，上方的链也会受到限制导致无解，只不过我们建图时没有表示出来而已。

如果我们这么割（蓝色代表边被割）：
![](https://cdn.luogu.com.cn/upload/image_hosting/qfsza8np.png)
则会在本身无解的问题上产生“增解”！

并且这种问题只会出现在存在 $d_i>0$ 的图中，这也就解释了为什么在原题中不用考虑这个情况，因为原题中不存在 $d_i>0$。

找到了问题的根源，那我们该如何解决呢？

主流的方式是这样的：连 $(i,j)\to(i,j-1)$ 容量无限的边，那么则会产生这样一类的流：

![](https://cdn.luogu.com.cn/upload/image_hosting/pweeevsh.png)

当然我更喜欢这样改善建图：

![](https://cdn.luogu.com.cn/upload/image_hosting/ukamgrly.png)

总之我们现在就能完全确定建图方式了：

1. $s\to (i,1)$，容量无限。
2. $(i,j)\to(i,j+1)$，容量为 $v_{i,j}$。
3. $(i,t_i+1)\to t$，容量无限。
4. $\forall 1\leq j\leq t_{b_i}$，连 $(b_i,j)\to(a_i,\min(j+d_i,t_{a_i}))$，容量无限。

代码：

```cpp
#include<bits/stdc++.h>
#define DB double
#define eps 1e-8
#define INF 1e18
#define N 10000
#define M 500000
using namespace std;
int _,n,m,p,y,S,T,id[85][85];
int c[85];DB es[85][85];
struct Edge{
	int nxt,to;DB flw;
	Edge(int a=0,int b=0,DB c=0)
	:nxt(a),to(b),flw(c){}
} e[M];
int head[N],cnt(1);
inline void AddEdge(int x,int y,DB f){
	e[++cnt]=Edge(head[x],y,f);head[x]=cnt;
	e[++cnt]=Edge(head[y],x,0);head[y]=cnt;
}
int dis[N],cur[N];
queue <int> q;
inline bool BFS(){
	memset(dis,0,sizeof(dis));
	queue <int> q;q.push(S);dis[S]=1;
	while(!q.empty()){
		int u(q.front());q.pop();cur[u]=head[u];
		for(int i(head[u]);i;i=e[i].nxt){
			int v(e[i].to);
			if(e[i].flw>eps&&!dis[v]){
				dis[v]=dis[u]+1;
				q.push(v);
			}
		}
	}
	return dis[T];
}
DB DFS(int u,DB limit){
	if(u==T||limit<eps) return limit;
	DB f(0);
	for(int i(cur[u]);i&&limit>eps;i=e[i].nxt){
		cur[u]=i;int v(e[i].to);
		if(e[i].flw&&dis[v]==dis[u]+1){
			DB t(DFS(v,min(limit,e[i].flw)));
			e[i].flw-=t;e[i^1].flw+=t;limit-=t;f+=t;
		}
	}
	if(f<eps) dis[u]=0;
	return f;
}
inline void Dinic(){
	DB flw(0),tmp;
	while(BFS()){
		while(tmp=DFS(S,INF))
			flw+=tmp;
		if(flw>=INF) return puts("-1"),void();
	}
	printf("%.6lf\n",flw);
}
int main(){
	scanf("%d",&_);
	while(_--){
		memset(head,0,sizeof(head));cnt=1;
		scanf("%d%d%d%d",&n,&m,&p,&y);S=n*(m+1)+1;T=S+1; 
		for(int i(1);i<=p;++i) scanf("%d",&c[i]);
		for(int i(1),idx(0);i<=n;++i)
			for(int j(1);j<=m+1;++j)
				id[i][j]=++idx;
		for(int j(1);j<=m;++j)
			for(int i(1);i<=n;++i){
				DB F(1),f;es[i][j]=0;
				for(int k(1);k<=p;++k){
					scanf("%lf",&f);
					es[i][j]+=(F*=f)*c[k];
				}
			}
		for(int i(1);i<=n;++i){
			AddEdge(S,id[i][1],INF);
			AddEdge(id[i][m+1],T,INF);
			for(int j(1);j<=m;++j)
				AddEdge(id[i][j],id[i][j+1],es[i][j]);
		}
		for(int i(1);i<=y;++i){
			int u,v,w;scanf("%d%d%d",&u,&v,&w);
			for(int j(max(1,1-w));j<=m+1;++j)
				AddEdge(id[v][j],id[u][min(j+w,m+1)],INF);
		}
		Dinic();
	}
	return 0;
}
```

---

## 作者：Charlie_ljk (赞：1)

# 写在前面

- [更好的阅读体验](https://www.cnblogs.com/Charlieljk/p/18709074)。

题面没有说清楚：当一道题打错时后面的题都不会再得分。

先提供一组 hack 数据：

```
2
3 2 4 2
10 10 10 20
0.3 0.5 0.7 0.4
0.2 0.6 0.2 0.2
0.7 0.1 0.8 0.2
0.5 0.5 0.5 0.5
0.2 0.5 0.3 0.6
0.3 0.5 0.4 0.1
1 2 1
2 3 1
9 3 1 1
36 
0.6 
0.7 
0.1 
0.3 
0.3 
0.9 
0.9 
0.2 
0.9 
0.1 
0.3 
0.9 
0.1 
0.7 
0.6 
0.3 
0.7 
0.8 
0.4 
0.5 
0.5 
0.5 
0.1 
0.5 
0.5 
0.3 
0.5 
3 5 1
```

正确输出：

```
-1
100.800000
```

此数据 hack 掉了以下两篇题解：

- https://www.luogu.com.cn/article/rtokwzol
- https://www.luogu.com.cn/article/l3dxtw40 

均为清空问题，未将 $f_{i,j,p+1}$ 赋为 $0$ 导致第二个结果不正确，更改后即可通过。

上面两篇题解讲的还是不错的，建议不必撤下，但是第一篇甚至是一楼，所以对拍的时候要小心（做题时拍了半天都对不上结果交上去过了），而以上题解均可通过猜测是因为数据中不存在后面的 $p$ 小于前面的 $p$ 的情况。

多倍经验：[P3227 [HNOI2013] 切糕](https://www.luogu.com.cn/problem/P3227)。

# 思路

一个选手必须且只能选择一套题，所以可以直接求出选手 $i$ 答第 $j$ 套题时的期望：

$$val_{i,j}=\sum_{k=1}^{p}(\prod_{h=1}^{k}f_{i,j,h})\times (1-f_{i,j,k+1})\times \sum_{h=1}^{k}c_h$$

考虑没有限制时，只需对于每个选手链接一条长度为 $m+1$ 的链跑最小割即可，具体的，连接 $s\xrightarrow{inf} (i,1),(i,m)\xrightarrow{val_{i,m}} t,(i,j)\xrightarrow[j\in [1,m)]{val_{i,j}} (i,j+1)$。

加入限制时，还需引入一个新的节点 $(i,m+1)$，于是变成了连接 $s\xrightarrow{inf} (i,1),(i,m+1)\xrightarrow{inf} t,(i,j)\xrightarrow[j\in\text{[1,m]}]{val_{i,j}} (i,j+1)$，后面讲为什么要这么做。

对于每一条限制，连接 $(j,h)\xrightarrow[h\in \text{[max(1,i-k),m]}]{inf}(i,\min(h+k,m+1))$ 这样一条无法割开的边，此时如果选择不符合规范时其依然可以从这天边流过去到达 $t$。

那么 $(i,m+1)$ 的作用就凸显出来了，我们不能让 $h+k>m$ 的成为法外狂徒，同时还避免了 $p=1$ 时的一些不必要的麻烦。

最后跑一遍最小割就好了。

# 一些细节

1. 首先这道题是多测，所以注意清空问题，不光是建图需要清空，还有「写在前面」中提到的 $f_{i,j,p+1}=0$ 的问题。

2. 注意 $k$ 可能是负数，所以对于限制建边 $h$ 不一定从 $1$ 开始。

3. 因为是浮点数，所以注意精度问题，要开 eps。

4. 对于判断无解，当流量 $\ge inf$ 时就是无解了。

# 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
#define mkp make_pair
using namespace std;
const int N=6510,M=2e5+10,inf=0x3f3f3f3f; const double eps=1e-8;
#ifdef __linux__
#define gc getchar_unlocked
#define pc putchar_unlocked
#else
#define gc _getchar_nolock
#define pc _putchar_nolock
#endif
inline bool blank(const char x) {return !(x^32)||!(x^10)||!(x^13)||!(x^9);}
template<typename Tp> inline void read(Tp &x) {x=0; register bool z=true; register char a=gc(); for(;!isdigit(a);a=gc()) if(a=='-') z=false; for(;isdigit(a);a=gc()) x=(x<<1)+(x<<3)+(a^48); x=(z?x:~x+1);}
inline void read(double &x) {x=0.0; register bool z=true; register double y=0.1; register char a=gc(); for(;!isdigit(a);a=gc()) if(a=='-') z=false; for(;isdigit(a);a=gc()) x=x*10+(a^48); if(a!='.') return x=z?x:-x,void(); for(a=gc();isdigit(a);a=gc(),y/=10) x+=y*(a^48); x=(z?x:-x);}
inline void read(char &x) {for(x=gc();blank(x)&&(x^-1);x=gc());}
inline void read(char *x) {register char a=gc(); for(;blank(a)&&(a^-1);a=gc()); for(;!blank(a)&&(a^-1);a=gc()) *x++=a; *x=0;}
inline void read(string &x) {x=""; register char a=gc(); for(;blank(a)&&(a^-1);a=gc()); for(;!blank(a)&&(a^-1);a=gc()) x+=a;}
template<typename T,typename ...Tp> inline void read(T &x,Tp &...y) {read(x),read(y...);}
template<typename Tp> inline void write(Tp x) {if(!x) return pc(48),void(); if(x<0) pc('-'),x=~x+1; register int len=0; register char tmp[64]; for(;x;x/=10) tmp[++len]=x%10+48; while(len) pc(tmp[len--]);}
inline void write(const double x) {register int a=6; register double b=x,c=b; if(b<0) pc('-'),b=-b,c=-c; register double y=5*powl(10,-a-1); b+=y,c+=y; register int len=0; register char tmp[64]; if(b<1) pc(48); else for(;b>=1;b/=10) tmp[++len]=floor(b)-floor(b/10)*10+48; while(len) pc(tmp[len--]); pc('.'); for(c*=10;a;a--,c*=10) pc(floor(c)-floor(c/10)*10+48);}
inline void write(const pair<int,double>x) {register int a=x.first; if(a<7) {register double b=x.second,c=b; if(b<0) pc('-'),b=-b,c=-c; register double y=5*powl(10,-a-1); b+=y,c+=y; register int len=0; register char tmp[64]; if(b<1) pc(48); else for(;b>=1;b/=10) tmp[++len]=floor(b)-floor(b/10)*10+48; while(len) pc(tmp[len--]); a&&(pc('.')); for(c*=10;a;a--,c*=10) pc(floor(c)-floor(c/10)*10+48);} else cout<<fixed<<setprecision(a)<<x.second;}
inline void write(const char x) {pc(x);}
inline void write(const bool x) {pc(x?49:48);}
inline void write(char *x) {fputs(x,stdout);}
inline void write(const char *x) {fputs(x,stdout);}
inline void write(const string &x) {fputs(x.c_str(),stdout);}
template<typename T,typename ...Tp> inline void write(T x,Tp ...y) {write(x),write(y...);}
int T,n,m,h,d,s,t,a[85],dep[N],now[N];
int tot=1,head[N],nxt[M],to[M]; double ans,f[85],p[85],w[M];
inline int id(int x,int y) {return (x-1)*(m+1)+y;}
inline void add(int x,int y,double z)
{
	nxt[++tot]=head[x],to[head[x]=tot]=y,w[tot]=z;
	nxt[++tot]=head[y],to[head[y]=tot]=x,w[tot]=0;
}
inline bool bfs()
{
	queue<int>q; memset(dep,0x3f,sizeof(dep));
	for(memcpy(now,head,sizeof(now)),q.push(s),dep[s]=0;!q.empty();)
	{
		int x=q.front(); q.pop();
		for(int i=head[x],y;y=to[i];i=nxt[i]) if(w[i]>eps&&dep[y]==inf)
		{dep[y]=dep[x]+1,q.push(y); if(y==t) return true;}
	} return false;
}
inline double dfs(int x,double sum)
{
	if(x==t||sum<eps) return sum; double sur,res=0;
	for(int &i=now[x],y;y=to[i];i=nxt[i]) if(w[i]>eps&&dep[y]==dep[x]+1)
	{
		if((sur=dfs(y,min(sum,w[i])))<eps) {dep[y]=inf; continue;}
		w[i]-=sur,w[i^1]+=sur,res+=sur; if((sum-=sur)<eps) break;
	} return res;
}
signed main()
{
	for(p[0]=1,read(T);T--;tot=1,memset(head,0,sizeof(head)))
	{
		read(n,m,h,d),t=(s=id(n,m+1)+1)+1,ans=0,f[h+1]=0;
		for(int i=1;i<=h;i++) read(a[i]),a[i]+=a[i-1];
		for(int i=1,j,k;i<=m;i++) for(j=1;j<=n;j++)
		{
			double x=0; for(k=1;k<=h;k++) read(f[k]),p[k]=p[k-1]*f[k];
			for(k=1;k<=h;k++) x+=p[k]*(1-f[k+1])*a[k];
			add(id(j,i),id(j,i+1),x);
		}
		for(int i=1;i<=n;i++) add(s,id(i,1),inf),add(id(i,m+1),t,inf);
		for(int i,j,k,o;d--;) for(read(i,j,k),o=max(1,1-k);o<=m;o++)
			add(id(j,o),id(i,min(o+k,m+1)),inf);
		while(bfs()&&inf-ans>eps) ans+=dfs(s,inf);
		inf-ans<eps?write("-1\n"):write(ans,'\n');
	}
}
```

---

## 作者：kabout (赞：1)

**这是一个偏理解性的个人题解**

直接开始分析

这题前置知识点：最小割以及最大流

最小割最经典的问题就是把一堆物品分到两个集合中，利用最小割等于最大流的知识点快速求出最小把物品分割成两类的费用。

这道题非常妙的是什么呢？把每个人选择的方式（n*m)种选择变成点，相同人不同套题横向连边，首先连成一个线（图中（1，1）和（1，2）是存在的选择套题方法，（1，3）是虚点）![图1](https://cdn.luogu.com.cn/upload/image_hosting/5zulfvf7.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

然后向源点和汇点连边，然后你会发现把这堆点如果分成两个集合就是相当于选了某个套题，很自然容量也会自己定义了，相邻(i,j)和(i,j+1)连接一条当前人做该套题期望值的容量但是最后要加个末尾点，如下图。

![图2](https://cdn.luogu.com.cn/upload/image_hosting/or1esf2x.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

这时候我们发现如果没有人之间的约束，如下图，答案就很简单，每条路上取个最小值就行了。
![图三](https://cdn.luogu.com.cn/upload/image_hosting/oqpjmh13.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

这时候我们考虑约束，假设上图，我们来个约束 1 2 1。说白了就是1必须得在2的后面选套题。你该如何做呢？先别慌，做最小割的题目如果你要表示某些点必须在一起或者不可分开你会怎么做？当然就是**产生一条容量为inf的边**。因为如果选了这条边作为最小割割边你就是走投无路没有可选择的其他边了。这就是这道题解题关键！

然后开始想如何设置？有了前面的提醒你会直觉把（2，j)连上（1，j+1）。为什么有这种直觉？因为连上后你会发现如果选了（1，j）或者左边的点，这条inf边还是会连通后面的点，你只能选后面开始断开产生最小割。

![图四](https://cdn.luogu.com.cn/upload/image_hosting/q4ns92gi.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

至此，最主要的部分就结束了。但是这样连边不能保证全对，为什么呢？你会发现这么连边上图2，2没有限制了，我们甚至可以1和2都选2套题达成最小割。这时候你会看到（1，3）点没有用，如果把（2，2）和（1，3）连接inf边会发生什么呢？只要选了（2，2），1号选手无论怎么段都不能产生最小割，因为（1，3）直接把前面点屏蔽掉了，（x，m+1)这些虚点直接连向汇点，而且连边大小是inf，这个性质让虚点可以承担这个角色。

所以补足方法自然就出来了，原本x+k如果大于m+1,就连向m+1。这样这些套题就是j不能选的。对了，别忘了这个k可以是负数，自己特殊处理一下，还有一点，无解的时候这个流很大，可能会超时，要特判中途退出。


为美好的世界献上丑陋的代码QAQ
```cpp
#include<bits/stdc++.h>
using namespace std;
#define M_P make_pair
#define fi first
#define se second
typedef long double ld;
typedef long long ll;
typedef unsigned long long ull;
#define PLL pair<ll,ll>
#define PIL pair<int,ll>
#define mm(a,b) memset(a,b,sizeof(a))
#define pf push_front
#define pb push_back
#define INF 0x3f3f3f3f3f3f3f3f
#define inf 70000000000
#define M1 998244353
#define M2 1000000007
#define TLE ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)
#define N 7000
#define eps 0.00000001
ll c[N],n,m,p,t,y;
ld f[N][N];
struct node{
	ll to,nex;
	ld w;
	node(ll _to=0,ld _w=0.0,ll _nex=0):to(_to),w(_w),nex(_nex){}
}edg[100*N];
ll dis[N],iter[N],S,T,head[N],cnt;
void add(ll u,ll v,ld w)
{
	
	edg[cnt].to=v,edg[cnt].w=w,edg[cnt].nex=head[u];head[u]=cnt++;
	edg[cnt].to=u,edg[cnt].w=0,edg[cnt].nex=head[v];head[v]=cnt++;//
}
void bfs(int s,int t)
{
	deque<int>que;
	mm(dis,-1);
	que.pb(s);
	dis[s]=0;
	while(que.size())
	{
		int now=que.front();
		que.pop_front();
		for(auto v=head[now];v!=-1;v=edg[v].nex)
		{
			ll to=edg[v].to;
			ld w=edg[v].w;
			if(dis[to]==-1&&w>eps)
			{
				dis[to]=dis[now]+1;
				if(to==t)return;
				que.pb(to);
			}
		}
	}
}
ld dfs(int u,int t,ld flow)
{
	if(u==t)
		return flow;
	for(auto &v=iter[u];v!=-1;v=edg[v].nex)
	{
		ll to=edg[v].to;
		ld w=edg[v].w;
		if(dis[to]==dis[u]+1&&w>eps)
		{
			ld d=dfs(to,t,min(flow,w));
			if(d>eps)
			{
				edg[v].w-=d;
				edg[v^1].w+=d;
				return d;
			}
		}	
	}
	return 0;
}
ld Dinic(int s,int t)
{
	ld ans=0;
	bfs(s,t);
	while(dis[t]!=-1)
	{
		ld d=0;
		for(int i=s;i<=t;i++)
			iter[i]=head[i];
		while((d=dfs(s,t,inf))>eps)
		{
			if(ans>inf)break;
			ans+=d;
		}
		if(ans>inf)break;
		bfs(s,t);//重新分层
	}
	return ans;
}
int main()
{
 	TLE;
 	cout<<fixed<<setprecision(4);
 	cin>>t;
 	while(t--)
 	{
 		mm(head,-1);
 		cnt=0;//清空这些就行了
		cin>>n>>m>>p>>y;
 		for(ll i=1;i<=p;i++)
 			cin>>c[i];
 		for(ll j=1;j<=m;j++)//枚举
 		{
 			
 			for(ll i=1;i<=n;i++)
 			{
 				ld P=1.0,sc=0,pi;
 				for(ll k=1;k<=p;k++)
 				{
 					cin>>pi;
 					P*=pi;
 					sc+=P*c[k];//算的是每个值提供贡献的概率乘上每个值的贡献
				}
				f[i][j]=sc;
			}
		}
		for(ll i=1;i<=n;i++)
		{
			add(i*(m+1),n*(m+1)+1,inf);//每一行的虚点连向汇点
			add(0,(i-1)*(m+1)+1,inf);//源点连向每一行的第一个点
		}
			
		for(ll i=1;i<=n;i++)
		{
			for(ll j=1;j<=m;j++)
			{
				ll now=(i-1)*(m+1)+j;
				add(now,now+1,f[i][j]);//相邻连边
			}
		}
		for(ll i=1,u,v,ki;i<=y;i++)
		{
			cin>>u>>v>>ki;
			for(ll j=1;j<=m;j++)//开始加限制
			{
				ll pre;
				if(ki<0)pre=max(1ll,j+ki);
				else pre=min(m+1,j+ki);
				add((v-1)*(m+1)+j,(u-1)*(m+1)+pre,inf);//加个inf就是不可断绝的关系
			}
		}
		ld ans=Dinic(0,n*(m+1)+1);
		if(ans<inf)cout<<ans<<'\n';//合法情况
		else cout<<-1<<'\n';
	}
 	return 0;
}
```

---

## 作者：FutaRimeWoawaSete (赞：1)

服了，被卡 eps 了……                   

考虑网络流上最小割解决，建立 $O(nm)$ 级别的点对量 $(i,j)$ 表示一个点 $i$ 选择第 $j$ 个方案，考虑以如下方式建图：               

下文中用三元组 $[a,b,c]$ 表示点 $a$ 向 $b$ 连一条容量为 $c$ 的边。

1. $[(i,j),(i,j + 1),c_{i,j}],[S , (i,1) , Inf],[(i , m + 1 , T , Inf)]$ 其中 $c_{i,j}$ 表示 $(i,j)$ 选择方案的价值。这样是为了有一个基本的“割”的框架，操作之后跑出的最小割就是每个人分配一套题所得的最小期望收益，同时注意需要建立虚点；         

2. 接下来考虑限制。$(z , z + k) \in [1 , m + 1],[(j , z) , (i , z + k) , Inf]$，由于我们建立的割模型在单独的一条纵列上编号连续，如此操作之后就可以保证如果你在 $(j,z)$ 上割了一条边，你至少需要在 $(j,z + k)$ 以后割一条边才能使得原图不连通。             

3. $[(i,j+1) , (i,j) , Inf]$，这个操作比较精妙（我还真没想到），因为你会发现只用上述两种建边约束这个问题是无法约束完全无解情况，所以我们连一个反向边，方便回溯。就好比说如果当前无解，那就是形如一个点 $(i,1)$ 走到了点 $(j,1+k)$ 后，$(j,1 + k)$ 前面还有点有 $2$ 形式下的限制连边，这样的情况是无解的，反向连边后就可以产生一条值为 Inf 的路径判断无解，用 Enthalpy 的话来说是一种限制的传递性，比较有意思的说法。

最后注意一下一些 eps 相关的东西，不要把 eps 开小，打漏了。          

数据多测。

```cpp
#include "bits/stdc++.h"
using namespace std;
const int Len = 81 * 81 + 5 , Inf = 1e9 + 1 , N = 5e5 + 5;
const double eps = 1e-4;
int n,m,p,y,c[Len],head[N],cnt = 1,dep[N],cur[N],s,t;
double ans,w[85][85];
struct node
{
	int next,to;double w;
}edge[Len << 5];
void add(int from,int to,double w)
{
	edge[++ cnt].to = to;
	edge[cnt].next = head[from];
	edge[cnt].w = w;
	head[from] = cnt;
}
int BFS()
{
	queue<int> q;
	for(int i = 1 ; i <= t ; i ++) dep[i] = 0;
	q.push(s);dep[s] = 1;cur[s] = head[s];
	while(!q.empty())
	{
		int p = q.front();
		q.pop();
		if(p == t) break;
		for(int e = head[p] ; e ; e = edge[e].next)
		{
			int to = edge[e].to;
			if(!dep[to] && edge[e].w > eps) 
			{
				dep[to] = dep[p] + 1;
				cur[to] = head[to];
				q.push(to);
			}
		}
	}
	return dep[t];
}
double dfs(int u,double In)
{
	if(u == t) return In;
	double Out = 0;
	for(int e = cur[u] ; e && In > eps ; e = edge[e].next)
	{
		cur[u] = e;
		int to = edge[e].to;
		if(dep[to] == dep[u] + 1 && edge[e].w > eps)
		{
			double res = dfs(to , min(In , edge[e].w));
			In -= res;
			Out += res;
			edge[e].w -= res;
			edge[e ^ 1].w += res;
			if(In <= eps) break;
		}
	}
	if(Out <= eps) dep[u] = 0;
	return Out;
}
double cc;
int X,Y,k;
int Calc(int x,int y){return (x - 1) * (m + 1) + y;}
int main()
{
	int T;scanf("%d",&T);
	while(T --)
	{
		
		scanf("%d %d %d %d",&n,&m,&p,&y);
		s = n * (m + 1) + 1 , t = s + 1;
		for(int i = 1 ; i <= p ; i ++) scanf("%d",&c[i]);
			for(int j = 1 ; j <= m ; j ++)
			for(int i = 1 ; i <= n ; i ++)
			{
				double ret = 1.0;
				w[i][j] = 0;
				for(int k = 1 ; k <= p ; k ++) 
				{
					scanf("%lf",&cc);
					ret = ret * cc;
					w[i][j] += ret * c[k];
				}
			}
		for(int i = 1 ; i <= n ; i ++)
		{
			add(s , Calc(i , 1) , Inf) , add(Calc(i , 1) , s , 0);
			add(Calc(i , m + 1) , t , Inf) , add(t , Calc(i , m + 1) , 0);
			for(int j = 1 ; j <= m ; j ++)
			{
				add(Calc(i , j) , Calc(i , j + 1) , w[i][j]) , add(Calc(i , j + 1) , Calc(i , j) , 0);
				add(Calc(i , j) , Calc(i , j + 1) , 0) , add(Calc(i , j + 1) , Calc(i , j) , Inf);
			}
		}
		while(y --)
		{
			scanf("%d %d %d",&X,&Y,&k);
			for(int i = 1 ; i <= m + 1 ; i ++) 
			{
				if(1 > i + k || i + k > m + 1) continue;
				add(Calc(Y , i) , Calc(X , i + k) , Inf) , add(Calc(X , i + k) , Calc(Y , i) , 0);
			}
		}
		while(BFS()) 
		{
			ans += dfs(s , Inf);
			if(ans >= Inf) break;
		}
		(ans >= Inf) ? puts("-1") : printf("%.5lf\n",ans);
		for(int i = 1 ; i <= t ; i ++) head[i] = 0;
		cnt = 1;ans = 0;
	}
	
	return 0;
}
```

---

## 作者：VenusM1nT (赞：1)

建模好（duliu）题，官方题解关于建模这块给的非常敷衍（虽然大家应该都看得懂），稍微讲一下【大雾】  
首先预处理 $a_{i,j}$ 为第 $i$ 个人做第 $j$ 套题的期望，这里有一个比较坑的点就是做题是 roguelike 机制的，要一道题做对了才能做下一题（这也是开门大吉这个节目的机制，但是没看过或者没考虑就可能会被坑），所以概率是要累乘的。  

此处用最大流不太好解释，用最小割就很好理解。  
来考虑怎么搞，把每个人拆成 $m+1$ 个点，可以得到 $m$ 条边，对应 $m$ 套题。假定 $(i,j)$ 为第 $i$ 个人的第 $j$ 个点  ，则
 1. $(i,j)\stackrel{a_{i,j}}{\to} (i,j+1)$  
 
  这一步没什么好说的，每个人选一套题，所以会优先割最小的一条，也就是取到最小期望。

 2. $(i,j+1)\stackrel{+\infty}{\to}(i,j)$
 
  因为要考虑限制，所以要给一个反悔的机会。（但不加除了 subtask 1 都过得去=-=，不太确定是不是这个功能）

 3. $\text{S}\stackrel{+\infty}{\to}(i,1)$，$(i,m+1)\stackrel{+\infty}{\to}\text{T}$
 
  经典连边，保证每人都能选到题。

 4. 考虑限制 $(i,j,k)$，$\forall\ x\in[1,m-k+1]$，$(j,x)\stackrel{+\infty}{\to}(i,x+k)$
 
  本题的核心，考虑这样连边是如何起效的，假定选择了 $(j,x)$ 这样的组合，那么 $(j,x)$ 的下一条边就会被割掉，此时 $(j,x)$ 这个点是连向 $(i,x+k)$ 的，代表 $(i,x+k)$ 被一条权值为 $+\infty$ 的边连通，略加思索就会发现，如果割这条 $+\infty$ 的边，那可以直接输出 $-1$ 然后下一组数据了；如果割 $(i,x+k)$ 这个点向上的边，不论割哪条都是没用的，因为 $(i,x+k)$ 这个点被连通了，因此只能考虑向下割，也就做到了题目中要求的编号大 $k$。  

此时全部边就被建完了，直接跑一遍 Dinic 就得到了答案，但不知道是不是笔者的 Dinic 太丑，需要加一个剪枝，也就是上文说到的，如果割 $+\infty$ 这条边那么直接输出 $-1$，就可以通过此题。
```cpp
#include<bits/stdc++.h>
#define N 800
#define M 200000
#define eps 1e-10
#define inf 1e18
#define reg register
#define inl inline
#define db double
using namespace std;
int cnt,fst[M+5],nxt[M+5],to[M+5],cur[M+5];
db w[M+5];
int n,m,p,q,c[N+5],dep[M+5],S,T;
db a[N+5][N+5];
inl void AddEdge(reg int u,reg int v,reg db c)
{
	to[++cnt]=v;
	nxt[cnt]=fst[u];
	fst[u]=cnt;
	w[cnt]=c;
}
inl bool Bfs()
{
	memset(dep,0,sizeof(dep));
	queue <int> q;
	q.push(S);
	dep[S]=1;
	while(!q.empty())
	{
		reg int u=q.front();
		q.pop();
		for(reg int i=fst[u];i;i=nxt[i])
		{
			reg int v=to[i];
			if(!dep[v] && w[i]>eps)
			{
				dep[v]=dep[u]+1;
				q.push(v);
			}
		}
	}
	return dep[T];
}
db Dfs(reg int u,reg db flow)
{
	if(u==T || flow<eps) return flow;
	reg db used=0;
	for(reg int &i=cur[u];i;i=nxt[i])
	{
		reg int v=to[i];
		if(dep[v]==dep[u]+1 && w[i]>eps)
		{
			reg db fl=Dfs(v,min(flow,w[i]));
			if(fl>eps)
			{
				used+=fl;
				flow-=fl;
				w[i]-=fl;
				w[i^1]+=fl;
				if(flow<eps) break;
			}
		}
	}
	return used;
}
inl db Dinic()
{
	reg db res=0;
	while(Bfs())
	{
		memcpy(cur,fst,sizeof(fst));
		res+=Dfs(S,inf);
		if(res>inf) break;
		//printf(" $ : %.2lf\n",res);
	}
	return res;
}
inl void Init()
{
	cnt=1;
	memset(fst,0,sizeof(fst));
	memset(w,0,sizeof(w));
	memset(a,0,sizeof(a));
}
int main()
{
	reg int Time;
	scanf("%d",&Time);
	while(Time--)
	{
		Init();
		scanf("%d %d %d %d",&n,&m,&p,&q);
		for(reg int i=1;i<=p;i++) scanf("%d",&c[i]);
		for(reg int i=1;i<=m;i++)//套题
		{
			for(reg int j=1;j<=n;j++)//选手
			{
				reg db tmp=1;
				for(reg int k=1;k<=p;k++)//题目
				{
					reg db x;
					scanf("%lf",&x);
					tmp*=x;
					a[j][i]+=1.0*c[k]*tmp;
					// a[ i ][ j ] 第 i 个人做第 j 套题
				}
			}
		}
		S=0;
		T=n*(m+1)+1;
		for(reg int i=1;i<=n;i++)//选手
		{
			reg int bas=(i-1)*(m+1);
			AddEdge(S,bas+1,inf); AddEdge(bas+1,S,0);
			AddEdge(bas+m+1,T,inf); AddEdge(T,bas+m+1,0);
			for(reg int j=1;j<=m;j++)//题目
			{
				AddEdge(bas+j,bas+j+1,a[i][j]); AddEdge(bas+j+1,bas+j,0);
				AddEdge(bas+j+1,bas+j,inf); AddEdge(bas+j,bas+j+1,0);
			}
		}
		for(reg int i=1;i<=q;i++)
		{
			reg int x,y,z;
			scanf("%d %d %d",&x,&y,&z);
			reg int basx=(x-1)*(m+1),basy=(y-1)*(m+1);
			for(reg int j=1;j<=m;j++)
			{
				if(j+z>=1 && j+z<=m+1)
				{
					AddEdge(basy+j,basx+j+z,inf); AddEdge(basx+j+z,basy+j,0);
				}
			}
		}
		reg db ans=Dinic();
		ans<inf?printf("%.5lf",ans):printf("-1");
		if(Time) puts("");
	}
	return 0;
}
```

---

## 作者：do_while_true (赞：1)

一套题里面的各个题是假的，可以处理出 $w_{i,j}$ 为第 $i$ 个人选第 $j$ 套题的期望得分。

对于每个人来讲，有 $m$ 种选择套题，只能选择一个套题，要求价值最小，于是想到一个最小割的经典建图：对于每个人，从 $S$ 到 $T$ 连一条长度为 $m$ 的链，边的流量依次为这个人选择第 $i$ 套题的期望得分。

考虑怎样描述限制，若割了 $j$ 的第 $l$ 条边，那么就不能割 $i$ 的前 $(j+k-1)$ 条边。

那么就从 $j$ 的第 $l$ 条边的起点，向 $i$ 的前 $(j+k-1)$ 条边的终点连一条 $+\infty$．

但是要注意到，限制和限制之间是有传递性的，假若有 $1$ 比 $2$ 大 $1$，$2$ 比 $3$ 大 $1$，那么还需要满足 $1$ 比 $3$ 大 $2$．

将一开始 $S$ 到 $T$ 的若干条长度为 $m$ 的链，连一条反向的流量为 $+\infty$ 的边，这样限制和限制组成的限制也被满足了。

**最小割 建图模型：每个位置 $n$ 选 $1$，求最小代价，$S$ 到 $T$ 连若干条长度为 $n$，流量依次为每种选择的代价，求最小割。**

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<queue>
#define pb emplace_back
#define mp std::make_pair
#define fi first
#define se second
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
typedef std::pair<int, int> pii;
typedef std::vector<int> vi;
const ll mod = 998244353;
ll Add(ll x, ll y) { return (x+y>=mod) ? (x+y-mod) : (x+y); }
ll Mul(ll x, ll y) { return x * y % mod; }
ll Mod(ll x) { return x < 0 ? (x + mod) : (x >= mod ? (x-mod) : x); }
ll cadd(ll &x, ll y) { return x = (x+y>=mod) ? (x+y-mod) : (x+y); }
ll cmul(ll &x, ll y) { return x = x * y % mod; }
template <typename T> T Max(T x, T y) { return x > y ? x : y; }
template<typename T, typename... T2> T Max(T x, T2 ...y) { return Max(x, y...); }
template <typename T> T Min(T x, T y) { return x < y ? x : y; }
template<typename T, typename... T2> T Min(T x, T2 ...y) { return Min(x, y...); }
template <typename T> T cmax(T &x, T y) { return x = x > y ? x : y; }
template <typename T> T cmin(T &x, T y) { return x = x < y ? x : y; }
template <typename T>
T &read(T &r) {
	r = 0; bool w = 0; char ch = getchar();
	while(ch < '0' || ch > '9') w = ch == '-' ? 1 : 0, ch = getchar();
	while(ch >= '0' && ch <= '9') r = r * 10 + (ch ^ 48), ch = getchar();
	return r = w ? -r : r;
}
template<typename T1, typename... T2>
void read(T1 &x, T2& ...y) { read(x); read(y...); }
const int N = 100010;
const int M = 500010;
const ll INF = 0x7fffffffffffffff;
const ld eps = 1e-10;
int n, m, p, y, c[N], pos[81][81];
ld f[81][81][81], w[81][81];
int tot, S, T, ent = 1, head[N], cur[N], dis[N];
struct Edge {
	int to, nxt;
	ld fl;
}e[M];
inline void add(int x, int y, ld z) {
	e[++ent].to = y; e[ent].fl = z; e[ent].nxt = head[x]; head[x] = ent;
	e[++ent].to = x; e[ent].fl = 0; e[ent].nxt = head[y]; head[y] = ent;
}
bool bfs() {
	for(int i = 1; i <= tot; ++i) dis[i] = -1, cur[i] = head[i];
	std::queue<int>q;
	q.push(S); dis[S] = 0;
	while(!q.empty()) {
		int x = q.front(); q.pop();
		for(int i = head[x]; i; i = e[i].nxt) {
			int v = e[i].to;
			if(dis[v] == -1 && e[i].fl > eps) {
				dis[v] = dis[x] + 1;
				q.push(v);
			}
		}
	}
	return dis[T] != -1;
}
bool qwqbfs() {
	for(int i = 1; i <= tot; ++i) dis[i] = -1;
	std::queue<int>q;
	q.push(S); dis[S] = 0;
	while(!q.empty()) {
		int x = q.front(); q.pop();
		for(int i = head[x]; i; i = e[i].nxt) {
			int v = e[i].to;
			if(dis[v] == -1 && e[i].fl == INF) {
				dis[v] = dis[x] + 1;
				q.push(v);
			}
		}
	}
	return dis[T] != -1;
}
ld dfs(int x, ld lim) {
	if(x == T) return lim;
	ld flow = 0;
	for(int i = cur[x]; i && flow < lim; i = e[i].nxt) {
		int v = e[i].to; cur[x] = i;
		if(dis[v] == dis[x] + 1 && e[i].fl > eps) {
			ld f = dfs(v, Min(e[i].fl, lim - flow));
			flow += f; e[i].fl -= f; e[i^1].fl += f;
		}
	}
	return flow;
}
ld dinic() {
	ld mxfl = 0;
	while(bfs())
		mxfl += dfs(S, INF);
	return mxfl;
}
void solve() { for(int i = 1; i <= tot; ++i) head[i] = 0; tot = 0; ent = 1;
	read(n, m, p, y);
	for(int i = 1; i <= p; ++i) read(c[i]);
	for(int j = 1; j <= m; ++j)
		for(int i = 1; i <= n; ++i)
			for(int k = 1; k <= p; ++k) {
				double qwq; scanf("%lf", &qwq);
				f[i][j][k] = qwq;
			}
	for(int i = 1; i <= n; ++i)
		for(int j = 1; j <= m; ++j) {
			ld t = 1; w[i][j] = 0;
			for(int k = 1; k <= p; ++k) {
				t *= f[i][j][k];
				w[i][j] += t * c[k];
			}
		}
	S = ++tot; T = ++tot;
	for(int i = 1; i <= n; ++i) {
		pos[i][0] = S;
		for(int j = 1; j <= m; ++j) {
			if(j < m) pos[i][j] = ++tot;
			else pos[i][j] = T;
			add(pos[i][j-1], pos[i][j], w[i][j]);
			add(pos[i][j], pos[i][j-1], INF);
		}
	}
	for(int o = 1; o <= y; ++o) {
		int i, j, k; read(i, j, k);
		for(int a = 1; a <= m; ++a)
			if(a-1+k >= 1 && a-1+k <= m)
				add(pos[j][a-1], pos[i][a-1+k], INF);
	}
	if(qwqbfs()) {
		puts("-1");
		return ;
	}
	double qwq = dinic();
	printf("%lf\n", qwq);
}
signed main() {
	int T; read(T);
	while(T--)
		solve();
	return 0;
}
```

---

## 作者：Phartial (赞：0)

首先我们可以简单求出第 $i$ 个人做第 $j$ 套题的期望收益 $v_{i,j}$。

如果没有约束条件，我们就可以贪心的对每个人选择期望收益最小的套题。

而为了将约束条件加进去，我们考虑使用网络流描述上面的贪心做法（本题使用 $\lang x,y,w\rang$ 表示一条 $x$ 到 $y$ 的流量限制为 $w$ 的有向边）：

- 对每个人 $i$，我们从源点到汇点建一条长度为 $m+2$ 的链，记 $(i,j)$ 表示第 $i$ 条链上的第 $j$ 个点（不含源点）；
- 对每个人 $i$，建边 $\lang S,(i,1),\infty\rang$；
- 对每个人 $i$ 和每套题 $j$，建边 $\lang(i,j),(i,j+1),v_{i,j}\rang$；
- 对每个人 $i$，建边 $\lang (i,m+1),T,\infty\rang$；

这样建图后我们跑最小割，不难发现每条链都会割掉恰好一条边，且正好对应着那个人选的那套题。

那么怎么表示约束呢？我们假设存在一个约束 $(i,j,k)$，那么这相当于是在说：如果第 $j$ 个人选的套题编号 $\ge d$，那么第 $i$ 个人选的套题编号就必须 $\ge d+k$。考虑连边 $\lang(j,d),(i,d+k),\infty\rang$，如果我们在第 $j$ 条链中选择割边 $\lang(j,d),(j,d+1)\rang$ 或更加后面的割边，那么就存在两条从源点到汇点的路径 $S\to(i,1)\to(i,2)\to\cdots\to(i,m+1)\to T$ 和 $S\to(j,1)\to(j,2)\to\cdots\to(j,d)\to(i,d+k)\to(i,d+k+1)\to\cdots\to(i,m+1)\to T$，为了在第 $i$ 条链中只割掉一条边使这两条路径都被割掉，我们就必须在 $(i,d+k)\to(i,d+k+1)\to\cdots\to(i,m+1)\to T$ 这条路径中选择一条边割掉，于是便限制了 第 $i$ 个人选的套题编号必须 $\ge d+k$。于是我们就有这样的建图方法：

- 对一个限制 $(i,j,k)$，对所有 $1\le d\le m+1-k$，连边 $\lang(j,d),(i,d+k),\infty\rang$。

注意到两组限制 $(i,j,k)$ 与 $(u,i,w)$ 可以推出新的限制 $(u,j,k+w)$，而在上面的建边中我们也正好可以通过 $\lang (j,d),(i,d+k),\infty\rang$ 和 $\lang (i,d+k),(u,d+k+w),\infty\rang$ 得到边 $\lang (j,d),(u,d+k+w),\infty\rang$……吗？

注意到如果 $k+w\ge m$ 但 $k<m,w<m$，限制 $(u,j,k+w)$ 实际上不可能被满足，所以此时无解。但在网络流建模中，因为不存在 $d$ 使得 $d+k\le m-w$，所以边 $\lang (i,d+k),(u,d+k+w),\infty\rang$ 根本不会被建出，导致限制无法正确传递，从而忽略限制 $(u,j,k+w)$。

解决这个问题的方法有许多种，这里给出最简单的一种方式：我们去掉 $d\le m+1-k$ 的限制，而在连边时将 $d+k$ 和 $m+1$ 取 $\min$ 即可（即，对一个限制 $(i,j,k)$，对所有 $1\le d\le m+1$，连边 $\lang(j,d),(i,\min(m+1,d+k)),\infty\rang$）。这样我们就可以正确传递限制了。

最后跑一遍最小割即可求出答案。

```cpp
#include <iomanip>
#include <iostream>
#include <vector>

using namespace std;

const int kN = 82, kY = 1e3 + 1;
const double kEps = 1e-6, kI = 1e9;

struct E {
  int y;
  double w;
} e[kN * (kY + kN) * 2];
int tt, n, m, pc, cc, ca[kN];
double pa[kN], va[kN][kN], ans;
int sp, ep, np, ne, d[kN * kN];
vector<int> ed[kN * kN];
vector<int>::iterator it[kN * kN];
int q[kN * kN], qh, qt;

int E(int i, int j) {
  return (i - 1) * (m + 1) + j;
}
void _A(int x, int y, double w) {
  e[++ne] = {y, w};
  ed[x].push_back(ne);
}
void A(int x, int y, double w) {
  _A(x, y, w), _A(y, x, 0);
}
void R(int x, int _d) {
  if (!d[x]) {
    d[x] = _d, q[++qt] = x;
  }
}
bool B() {
  qh = 1, qt = 0;
  fill_n(d + 1, np, 0);
  for (R(sp, 1); qh <= qt; ++qh) {
    int x = q[qh];
    if (x == ep) {
      return 1;
    }
    for (int i : ed[x]) {
      if (e[i].w > kEps) {
        R(e[i].y, d[x] + 1);
      }
    }
  }
  return d[ep];
}
double D(int x, double f) {
  if (f < kEps) {
    return 0;
  }
  if (x == ep) {
    return f;
  }
  double rf = 0;
  for (auto &i = it[x]; i != ed[x].end(); ++i) {
    double iv = 0;
    if (d[e[*i].y] == d[x] + 1 && (iv = D(e[*i].y, min(f - rf, e[*i].w))) > kEps) {
      rf += iv, e[*i].w -= iv, e[*i ^ 1].w += iv;
      if (abs(rf - f) < kEps) {
        break;
      }
    }
  }
  return rf;
}

int main() {
  ios_base::sync_with_stdio(0), cin.tie(0);
  for (cin >> tt; tt--;) {
    cin >> n >> m >> pc >> cc;
    for (int i = 1; i <= pc; ++i) {
      cin >> ca[i];
    }
    for (int i = 1; i <= m; ++i) {
      for (int j = 1; j <= n; ++j) {
        for (int k = 1; k <= pc; ++k) {
          cin >> pa[k];
        }
        va[j][i] = 0;
        double p = 1;
        int s = 0;
        for (int k = 1; k <= pc; ++k) {
          p *= pa[k], s += ca[k];
          va[j][i] += p * (1 - pa[k + 1]) * s;
        }
      }
    }
    sp = n * (m + 1) + 1, np = ep = n * (m + 1) + 2;
    ne = 1;
    for (int i = 1; i <= np; ++i) {
      ed[i].clear();
    }
    for (int i = 1; i <= n; ++i) {
      A(sp, E(i, 1), kI);
      for (int j = 1; j <= m; ++j) {
        A(E(i, j), E(i, j + 1), va[i][j]);
      }
      A(E(i, m + 1), ep, kI);
    }
    for (int i, j, k; cc--;) {
      cin >> i >> j >> k;
      for (int d = max(1, 1 - k); d <= m + 1; ++d) {
        A(E(j, d), E(i, min(m + 1, d + k)), kI);
      }
    }
    ans = 0;
    for (; B();) {
      for (int i = 1; i <= np; ++i) {
        it[i] = ed[i].begin();
      }
      ans += D(sp, kI);
    }
    if (ans >= kI) {
      cout << "-1\n";
    } else {
      cout << fixed << setprecision(4) << ans << '\n';
    }
  }
  return 0;
}
```


---

## 作者：Querainy (赞：0)

我不是很理解那个反向边在干啥啊！所以，一个简单的限制每条链只割一条边的方法是，直接给链上每条边边权加上 $\infty$，最后减去 $n\times \infty$。如果减完了仍然 $>\infty$ 那就无解。

因为和别的题解代码几乎没有区别，只放[提交记录](https://www.luogu.com.cn/record/107234548)。是改的 do_while_true 题解里的代码。注意 $\infty$ 开太大的话精度会炸。



---


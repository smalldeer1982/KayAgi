# 千年食谱颂

## 题目背景

$$\texttt{事在人    命在天}$$
$$\texttt{亘古滔滔转眼间}$$
$$\texttt{唯席上}$$
$$\texttt{千年丰盛永不变}$$

&emsp;&emsp;“阿绫，今天是我的第 $15$ 个 $15$ 岁生日呀！”  
&emsp;&emsp;“哦……阿绫今天回不了家嗷。”  
&emsp;&emsp;早晨九点，迷迷糊糊睁开双眼的小灰毛悄悄用手戳了戳自己的身旁，却只感受到枕头的淡淡的温暖。  
&emsp;&emsp;“明明是人家的生日嘛，又要加班……”把手机扔在一边，叠好被子，走近床边，垂着手轻轻拨开窗帘，刺眼的阳光轻易地冲散了另一个人的温度。  
&emsp;&emsp;“好无聊啊！”  
&emsp;&emsp;就这样熬到了晚上，却发现冰箱已经空空如也。要不……去美食节转转？  
&emsp;&emsp;今天正好是魔都一年一度的美食节，本来以为阿绫会陪自己，天依可是做好了无比详细的攻略。但现在，阿绫不在，计划也随之落空。穿一身清凉的休闲装，带上钱包，天依还是决定，不能在食物上辜负自己！  
&emsp;&emsp;天依的手才刚刚搭上门把手，轻轻一拉，便猛然打开，竟被恋人拥入怀中……  
&emsp;&emsp;星光，灯火，美食，还有……天依小小的舌头轻轻舔着蓝莓味的甜筒，一边悄悄打量着身旁的恋人。修长的身段优雅从容地迈着步子，头顶标志性的红色呆毛就像那希望的烛光闪烁，漫天灯火，在那暗红色的明眸里缓缓流动……阿绫转过身，目光撞上那双碧绿的眼眸。  
&emsp;&emsp;“天依，天依。想什么呢？”   
&emsp;&emsp;看着恋人害羞地撇过脸，耳根子却不争气地红了起来，阿绫又动起了坏心思。她慢慢靠近恋人的脸庞，轻轻嘬了一口粉嫩的嘴唇。  
&emsp;&emsp;“干嘛啦阿绫，这里那么多人……”嘴上这么说着，天依却又不自觉地凑向阿绫。阿绫牵起恋人的手。“走，带你把这儿吃个遍！”

## 题目描述

美食节上一共有 $n$ 个店铺，初始 ( 第 $0$ 时刻 ) 时天依都没有品尝过。天依的 flag 是将它们尽数品尝。所以**从第一个时刻起**，天依会在每一个时刻**等概率地选取 $n$ 个店铺中的一个品尝**。不过，由于食客众多，许多店铺会出现食材短缺的情况而不得不中途撤场。**当一个店铺撤场后，会有一个新的 ( 以前从未出现的 ) 店铺立即进场**，我们称其为一次**撤场事件**。阿绫知道所有撤场事件会在**相邻两个时刻间**发生，且每个店铺在每个时刻间撤场的概率都是 $p$。   

天依凑过毛茸茸的脑袋问阿绫：“期望在第几个时刻，在场的 $n$ 个店铺都被我品尝过呢？”

## 说明/提示

#### 数据范围
对于不同的测试点，我们约定如下数据规模及其性质：

|             测试点编号              | $n \leq$ | 特殊性质 1 | 特殊性质 2 |
| :---------------------------------: | :------: | :--------: | :--------: |
|           $1 \sim 2$            |  $500$   | $\sqrt{}$  |     $\times$      |
|  $3 \sim 8$   |  $500$   |     $\times$      |     $\times$      |
|         $9 \sim 11$          |  $3000$  |     $\times$      | $\sqrt{}$  |
| $12 \sim 25$ |  $3000$  |     $\times$      |     $\times$      |

**特殊性质 1**：$a=0$。

**特殊性质 2**：$a=1,b=2$。

对于 $100 \%$ 的数据，$1 \le n \le 3000,0 \le a<b<998244353$。   

------------

#### 题目背景 ( 续 )
&emsp;&emsp;阿绫注视着丝毫不顾忌吃相的天依，又好气又好笑。但看着包里黑卡的钱少了一个又一个 $0$ ，脸色越来越沉……  
&emsp;&emsp;“喂，阴阳头，再送张卡来！”只好冲着哥哥发怒气的阿绫挂掉电话，又挂上了一副温柔的笑颜。  
&emsp;&emsp;“阿绫，阿绫你也尝尝吧。”天依可算想起了没怎么吃的阿绫。  
&emsp;&emsp;“不急，晚上回家，还有大餐等着我呢。”阿绫冲天依笑着，邪魅地笑着。  
&emsp;&emsp;“唔，所以大餐是什么呢？”天依想不明白，但总觉得有些不安。   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“你还是老样子呢，天依。”

## 样例 #1

### 输入

```
2 1 2```

### 输出

```
5```

# 题解

## 作者：Rainybunny (赞：4)

# 题目大意

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;美食节上一共有$n$个店铺, 初始 ( 第$0$时刻 ) 时都没有品尝过. 现在从第$1$个时刻其每个时刻概率地选取$n$个店铺中的一个品尝. 此外, 在每个时刻间, 有一些店铺会撤场, 被一个新 ( 以前从未出现的 ) 店铺替代. 每个店铺在每个时刻间被替代的概率都是$p$.  求在场的$n$个店铺都被品尝过的期望时刻, 对$998244353$取模.  
&emsp;&emsp;$100pts$: $n\le3000$.

# 得分情况

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;预测: ytt赌一根棒棒糖, 这道题被切爆了. ( ytt $=\dots=$ Rainybunny )

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于 $a=0$ 的部分分, 因为比较简单就附带在小数据里了. 答案就是 $n\sum_{i=1}^n\frac{1}i$.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于 $a=1,b=2$ 的部分分, 其实我并没有思考专门的解法qwq.

# 分析

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~~真, T4劝退杀.~~  
&emsp;&emsp;前置知识: [数学期望(咕咕日报)](https://www.luogu.com.cn/blog/ShineEternal/mathematical-expectation).  
&emsp;&emsp;现在, 聪明的你一定能熟练地列出并求解期望方程了.  

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先, 定义$f(i)$表示在一个**时刻末尾** ( 已品尝店铺但未到替换阶段 ),  **在场有$i$个店铺被品尝过时, 到完成目标的期望用时**.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然$f(0)=f(1)+1$是所求答案, 边界为$f(n)=0$.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑转移, 无非两个关键要素:

- 新的**时刻间**已品尝但被替换的店铺个数.
- 新的**时刻**是否产生贡献 ( $i.e.$新时刻品尝的店铺是否以前就被品尝过了 ).

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们枚举$j\in[0,i]$家已品尝的店铺被替代, 这样的概率为: $\text{一种情况的概率}p^j(1-p)^{i-j}\times\text{方案数}{i\choose j}$.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在, 我们就只剩下了$i-j$家店铺品尝过. 接着考虑在新的时刻有没有品尝新店铺:

- 品尝新店铺, 概率为$\frac{n-i+j}{n}$, 从$f(i-j+1)$转移.
- 品尝旧店铺, 概率为$\frac{i-j}{n}$, 从$f(i-j)$转移.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总结一下, $f(i)$的转移为:
$$
f(i)=1+\sum_{j=0}^i{i\choose j}p^j(1-p)^{i-j}(\frac{n-i+j}{n}f(i-j+1)+\frac{i-j}{n}f(i-j))
$$

## $32pts$ 算法

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;转移方程似乎不能直接递推求解. 列出方程组, 高斯消元. $O(n^3)$.

## $100pts$ 算法

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;似乎状态数已经是线性的了, 很难优化. 我们来观察方程组的系数有何特点.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;列出下表, 若$f(i)$所在行, $f(j)$所在列为O, 则表示$f(i)$依赖于$f(j)$的值来计算. 否则即为不需要. 省略了常数项.

|          | $f(1)$ | $f(2)$ | $f(3)$ | $\dots$ | $f(n)$ |
| :------: | :----: | :----: | :----: | :-----: | :----: |
|  $f(1)$  |   O    |   O    |   X    |    X    |   X    |
|  $f(2)$  |   O    |   O    |   O    |    X    |   X    |
| $\dots$  |   O    |   O    |   O    |    O    |   X    |
| $f(n-1)$ |   O    |   O    |   O    |    O    |   O    |

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以发现, 以主对角线右一格为界限, 左边的系数不为$0$而右边的系数全为$0$.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在从上往下一行一行地看, $f(1)=af(1)+bf(2)+c$, 故$f(1)$可以用$k$倍$f(2)$加常数表示.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将$f(1)$用$f(2)$表示的结果代入$f(2)$~$f(n-1)$的系数中, 发现表格第一列全为X.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类似地, 现在$f(2)=af(2)+bf(3)+c$, 故$f(2)$可以用$k$倍$f(3)$加常数表示.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将$f(2)$用$f(3)$表示的结果代入$f(3)$~$f(n-1)$的系数中, 发现表格第二列全为X.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以此类推, 最终得到$f(n-1)=af(n-1)+bf(n)+c$. 由于有边界$f(n)=0$, $f(n-1)$被直接解出. 然后从下往上代回, 就解到$f(1)$了. 复杂度$O(n^2)$. 一些细节见代码.

# 参考代码

## $30pts$参考代码

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~~它比标程还长w.~~

```cpp
#include <cstdio>

#define Int register int

const int MAXN = 1000, MOD = 998244353;
int n, a, b, invn, pw[MAXN + 5] = { 1 }, rpw[MAXN + 5] = { 1 }, Comb[MAXN + 5][MAXN + 5];
int Coe[MAXN + 5][MAXN + 5], Val[MAXN + 5], E[MAXN + 5];

inline int qkpow ( int a, int b, const int p = MOD ) {
	int ret = 1;
	for ( ; b; a = 1LL * a * a % p, b >>= 1 ) ret = 1LL * ret * ( b & 1 ? a : 1 ) % p;
	return ret;
}

inline int Inv ( const int x ) { return qkpow ( x, MOD - 2 ); }

inline int C ( const int n, const int m ) { return n < m ? 0 : Comb[n][m]; }

inline void InitComb () {
	Comb[0][0] = 1;
	for ( Int i = 1; i <= n; ++ i ) {
		for ( Int j = 0; j <= i; ++ j ) {
			Comb[i][j] = ! j ? 1 : ( Comb[i - 1][j] + Comb[i - 1][j - 1] ) % MOD;
		}
	}
}

inline void Gauss ( const int n, int a[MAXN + 5][MAXN + 5], int* b ) {
	for ( Int i = 1; i <= n; ++ i ) {
		if ( ! a[i][i] ) {
			int p = i;
			for ( ; ! a[p][i]; ++ p );
			std :: swap ( a[i], a[p] ), std :: swap ( b[i], b[p] );
		}
		for ( Int j = i + 1, d; j <= n; ++ j ) {
			d = 1LL * a[j][i] * Inv ( a[i][i] ) % MOD;
			b[j] = ( b[j] - 1LL * d * b[i] % MOD + MOD ) % MOD;
			for ( Int k = i; k <= n; ++ k ) {
				a[j][k] = ( a[j][k] - 1LL * d * a[i][k] % MOD + MOD ) % MOD;
			}
		}
	}
	for ( Int i = n; i; -- i ) {
		for ( Int j = i + 1; j <= n; ++ j ) {
			b[i] = ( b[i] - 1LL * E[j] * a[i][j] % MOD + MOD ) % MOD;
		}
		E[i] = 1LL * b[i] * Inv ( a[i][i] ) % MOD;
	}
}

inline void Work () {
	scanf ( "%d %d %d", &n, &a, &b );
	pw[1] = 1LL * a * Inv ( b ) % MOD;
	rpw[1] = 1LL * ( b - a ) * Inv ( b ) % MOD;
	invn = Inv ( n );
	for ( Int i = 2; i <= n; ++ i ) pw[i] = 1LL * pw[i - 1] * pw[1] % MOD;
	for ( Int i = 2; i <= n; ++ i ) rpw[i] = 1LL * rpw[i - 1] * rpw[1] % MOD;
	InitComb ();
	for ( Int i = 1; i < n; ++ i ) {
		Val[i] = MOD - 1;
		Coe[i][i + 1] = 1LL * rpw[i] * ( n - i ) % MOD * invn % MOD;
		for ( Int j = 1; j <= i; ++ j ) {
			Coe[i][j] = ( 1LL * C ( i, i - j + 1 ) * pw[i - j + 1] % MOD * rpw[j - 1] % MOD * ( n - j + 1LL ) % MOD * invn % MOD
						+ 1LL * C ( i, i - j ) * pw[i - j] % MOD * rpw[j] % MOD * j % MOD * invn % MOD ) % MOD;
		}
		Coe[i][i] = ( Coe[i][i] - 1 + MOD ) % MOD;
	}
	Coe[n][n] = 1;
	Gauss ( n, Coe, Val );
	printf ( "%d\n", ( E[1] + 1 ) % MOD );
}

int main () {
	Work ();
	return 0;
}
```

## $100pts$ 参考代码

```cpp
#include <cstdio>

#define Int register int

const int MAXN = 3000, MOD = 998244353;
int n, a, b, invn, pw[MAXN + 5] = { 1 }, rpw[MAXN + 5] = { 1 }, Comb[MAXN + 5][MAXN + 5];
// pw储存p的幂次, rpw储存(1-p)的幂次, Comb预处理组合数.
int Coe[MAXN + 5][MAXN + 5], E[MAXN + 5];

inline int qkpow ( int a, int b, const int p = MOD ) {
	int ret = 1;
	for ( ; b; a = 1LL * a * a % p, b >>= 1 ) ret = 1LL * ret * ( b & 1 ? a : 1 ) % p;
	return ret;
}

inline int Inv ( const int x ) { return qkpow ( x, MOD - 2 ); }

inline int C ( const int n, const int m ) { return n < m ? 0 : Comb[n][m]; }

inline void InitComb () {
	Comb[0][0] = 1;
	for ( Int i = 1; i <= n; ++ i ) {
		for ( Int j = 0; j <= i; ++ j ) {
			Comb[i][j] = ! j ? 1 : ( Comb[i - 1][j] + Comb[i - 1][j - 1] ) % MOD;
		}
	}
}

inline void Work () {
	scanf ( "%d %d %d", &n, &a, &b );
	pw[1] = 1LL * a * Inv ( b ) % MOD;
	rpw[1] = 1LL * ( b - a ) * Inv ( b ) % MOD;
	invn = Inv ( n );
	for ( Int i = 2; i <= n; ++ i ) pw[i] = 1LL * pw[i - 1] * pw[1] % MOD;
	for ( Int i = 2; i <= n; ++ i ) rpw[i] = 1LL * rpw[i - 1] * rpw[1] % MOD;
	InitComb ();
/*
 * 下面按转移方程列出方程组.
 * f(i)=Coe[i][1]*f(1)+Coe[i][2]*f(2)+...+Coe[i][n]*f(n)+Coe[i][n+1].
 * */
	for ( Int i = 1; i < n; ++ i ) {
		Coe[i][n + 1] = 1;
		Coe[i][i + 1] = 1LL * rpw[i] * ( n - i ) % MOD * invn % MOD;
		for ( Int j = 1; j <= i; ++ j ) {
			// 不难发现对于j!=i+1, f(j)会对f(i)贡献两次. 稍稍转化一下式子就可以了.
			Coe[i][j] = ( 1LL * C ( i, i - j + 1 ) * pw[i - j + 1] % MOD * rpw[j - 1] % MOD * ( n - j + 1LL ) % MOD * invn % MOD
						+ 1LL * C ( i, i - j ) * pw[i - j] % MOD * rpw[j] % MOD * j % MOD * invn % MOD ) % MOD;
		}
	}
/*
 * 下面开始逐行代换.
 * */
	for ( Int i = 1; i < n; ++ i ) {
		int a = Coe[i][i], b = Coe[i][i + 1], c = Coe[i][n + 1];
		// f(i)=af(i)+bf(i+1)+c.
		int dv = Inv ( ( 1 + MOD - a ) % MOD ), k = 1LL * b * dv % MOD, d = 1LL * c * dv % MOD;
		// => f(i)=(b/(1-a))f(i+1)+c/(1-a).
		Coe[i][i] = 0, Coe[i][i + 1] = k, Coe[i][n + 1] = d;
		for ( Int j = i + 1; j < n; ++ j ) { // 代换f(i+1)到f(n-1)的所有f(i).
			Coe[j][i + 1] = ( Coe[j][i + 1] + 1LL * Coe[j][i] * k % MOD ) % MOD;
			Coe[j][n + 1] = ( Coe[j][n + 1] + 1LL * Coe[j][i] * d % MOD ) % MOD;
			Coe[j][i] = 0;
		}W
	}
/*
 * 代回求解.
 * */
	for ( Int i = n - 1; i; -- i ) {
		// 命名不太一样qwq, E[i]就是f(i).
		E[i] = ( 1LL * Coe[i][i + 1] * E[i + 1] % MOD + Coe[i][n + 1] ) % MOD;
	}
	printf ( "%d\n", ( E[1] + 1 ) % MOD ); // answer=f(0)=f(1)+1.
}

int main () {
	Work ();
	return 0;
}
```

---

## 作者：happy_zero (赞：3)

或许比较好想的做法？

敲 LaTeX 有点敲晕了，如有错误欢迎指出。

期望 dp 套路，设 $f_i$ 表示当前已经吃过了 $i$ 个不同的，到吃过 $n$ 个不同的期望还需要多久。

枚举前一时刻和这一时刻中撤场完只剩 $j$ 个已经吃过的进行转移：

$$f_i=1+\sum_{j=0}^i\dbinom{i}{j}p^{i-j}(1-p)^j(\frac{j}{n}f_j+\frac{n-j}{n}f_{j+1})$$

发现这个式子中需要 $f_{1\sim i+1}$，无法直接转移。

由于只多需要了一个 $f_{i+1}$，经典做法：设 $b_i=f_{i+1}-f_i$，那么 $f_t=f_0+\sum_{i=0}^{t-1}b_t$，原式化为：

$$f_0+\sum_{j=0}^{i-1}b_j=1+\sum_{j=0}^i\dbinom{i}{j}p^{i-j}(1-p)^j\left[\frac{j}{n}\sum_{k=0}^{j-1}(b_k+f_0)+\frac{n-j}{n}\sum_{k=0}^j(b_k+f_0)\right]$$

两边都有一个 $f_0$ 消掉（右边合并起来一共是一个 $f_0$），惊喜的发现式子中只剩 $b_{i\sim i}$ 了！

于是稍微整理一下即可得到 $b_i$ 的式子，还是比较好推的：

$$b_i=\dfrac{(\sum_{j=0}^{i-1}b_j)-1-\sum_{j=0}^i\dbinom{i}{j}p^{i-j}(1-p)^j\left[(\frac{j}{n}\sum_{k=0}^{j-1}b_k)+(\frac{n-j}{n}\sum_{k=0}^j[k\ne i]b_k)\right]}{(1-p)^i\times \frac{n-i}{n}}$$

转移的时候前缀和优化一下即可做到 $O(n^2)$。

别忘记了，最终求的是 $f_0$。知道 $f_n=f_0+\sum_{i}^{n-1}b_i=0$，因此 $f_0=-\sum_{i}^{n-1}b_i$。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int P = 998244353;
const int N = 3005;
int f[N], s[N], fac[N], inv[N];
int qpow(int a, int b = P - 2) {
	int res = 1;
	while (b) {
		if (b & 1) res = res * a % P;
		a = a * a % P, b >>= 1;
	}
	return res;
}
int C(int n, int m) {
	return fac[n] * inv[m] % P * inv[n - m] % P; 
}
signed main() {
	int n, a, b; cin >> n >> a >> b;
	int p = a * qpow(b) % P, in = qpow(n); fac[0] = 1;
	for (int i = 1; i <= n; i++) 
		fac[i] = fac[i - 1] * i % P;
	inv[n] = qpow(fac[n]);
	for (int i = n - 1; i >= 0; i--)
		inv[i] = inv[i + 1] * (i + 1) % P;
	s[0] = f[0] = P - 1; 
	for (int i = 1; i < n; i++) {
		int w = qpow((1 - p + P) % P, i) * (n - i) % P * in % P;
		for (int j = 0; j <= i; j++) {
			int w = C(i, j) * qpow(p, i - j) % P * qpow((1 - p + P) % P, j) % P; 
			(f[i] += j * in % P * s[j - 1] % P * w % P) %= P;
			(f[i] += (n - j) * in % P * s[j - (j == i)] % P * w % P) %= P;
		} 
		f[i] = (s[i - 1] - f[i] - 1 + P + P) * qpow(w) % P; 
		s[i] = (s[i - 1] + f[i]) % P;
	}
	cout << (P - s[n - 1]) % P << '\n';
	return 0;
}
```

---

## 作者：zJx_Lm (赞：3)

很脑洞的 $dp$ 题

首先我们令 $dp_i$ 表示从 $i-1$ 转移到 $i$ 的期望时间

即从在场的 $i-1$ 个已被吃转移到在场的 $i$ 个已被吃

考虑转移：

* 在上一时刻和该时刻的时间间隔内撤下的不包含已选的

这种情况的转移很简单,令 $p$ 为 $\frac{a}{b}$,则：

$$
dp_i+=(1-p)^{i-1} \left ( \frac{i-1}{n}(dp_i+1)+\frac{n-i+1}{n} \right )
$$

* 在上一时刻和该时刻的时间间隔内撤下的包含已选的

按 $dp$ 转移意转移即可，首先枚举选中了几个，然后考虑在该时刻选的是已选的还是未选的，即：
$$
dp_i+=\sum_{k=1}^{i-1}p^{k}(1-p)^{i-1-k}\binom{i-1}{k}\left ( 1+dp_i+\frac{i-1-k}{n}\sum_{j=i-1-k+1}^{i-1}dp_j+\frac{n-i+1+k}{n}\sum_{j=i-1-k+2}^{i-1}dp_j \right )
$$

第二个转移方程内的求和可以用前缀和优化，所以复杂度为常数较小的 $O(n^2)$

$Code$
```cpp
#include <bits/stdc++.h>
#define re register
#define int long long
#define ll long long
// #define lls long long
#define pir make_pair
#define fr first 
#define sc second
#define db double
using namespace std;
const int mol=998244353;
const int maxn=1e7+10;
const int INF=1e9+10;
inline int qpow(int a,int b) { int ans=1; while(b) { if(b&1) (ans*=a)%=mol; (a*=a)%=mol; b>>=1; } return ans; }
inline int read() {
    int s=0,w=1; char ch=getchar();
    while(ch<'0'||ch>'9') { if(ch=='-') w=-1; ch=getchar(); }
    while(ch>='0'&&ch<='9') { s=s*10+ch-'0'; ch=getchar(); }
    return s*w;
}

int n,a,b,invn,ye[maxn],no[maxn],dp[maxn],fac[maxn],inv[maxn],sum[maxn];
inline int getsum(int l,int r) { if(l>r) return 0; return (sum[r+1]-sum[l]+mol)%mol; }
inline int C(int n,int m) { return fac[n]*inv[m]%mol*inv[n-m]%mol; }
signed main(void) {
	n=read(); a=read(); b=read(); invn=qpow(n,mol-2); ye[1]=a*qpow(b,mol-2)%mol; no[1]=(1ll-ye[1]+mol)%mol;
 	ye[0]=no[0]=1; for(re int i=2;i<=n;i++) ye[i]=ye[i-1]*ye[1]%mol,no[i]=no[i-1]*no[1]%mol;
	fac[0]=1; for(re int i=1;i<=n;i++) fac[i]=fac[i-1]*i%mol;
	inv[n]=qpow(fac[n],mol-2); for(re int i=n;i>=1;i--) inv[i-1]=inv[i]*i%mol;
	for(re int i=1;i<=n;i++) {
		int s=0,xi=0;
		for(re int k=1;k<=i-1;k++) {
			(s+=ye[k]*no[i-1-k]%mol*C(i-1,k)%mol*((i-1-k)*invn%mol*getsum(i-1-k+1,i-1)%mol+(n-i+1+k)*invn%mol*getsum(i-1-k+2,i-1)%mol+1))%=mol;
			(xi+=ye[k]*no[i-1-k]%mol*C(i-1,k)%mol)%=mol;
		}
		(xi+=no[i-1]*(i-1)%mol*invn%mol)%=mol;
		(s+=no[i-1])%=mol;
		xi=(1-xi+mol)%mol;
		dp[i]=s*qpow(xi,mol-2)%mol;
		sum[i+1]=(sum[i]+dp[i])%mol;
	}
	printf("%lld\n",sum[n+1]);
}
```


---

## 作者：_abcd_ (赞：0)

令 $f_i$ 表示目前已经吃了 $i$ 家店，期望要在过多长时间才能吃玩，则

$$ f_i = \sum\limits_{j=0}^i \binom{i}{j} p^{i-j} (1-p)^j g_j $$
$$ g_i = \frac{i}{n} f_i + \frac{n-i}{n} f_{i+1} + 1 $$
$$ f_i = \sum\limits_{j=0}^i \binom{i}{j} p^{i-j} (1-p)^j (\frac{j}{n} f_j + \frac{n-j}{n} f_{j+1} + 1) $$
$$ n f_i = n + (1-p)^i (i f_i + (n-i) f_{i+1}) \sum\limits_{j=0}^{i-1} \binom{i}{j} p^{i-j} (1-p)^j (j f_j + (n-j) f_{j+1}) $$
$$ f_{i+1} = \frac{n f_i - n - (1-p)^i i f_i - \sum\limits_{j=0}^{i-1} \binom{i}{j} p^{i-j} (1-p)^j (j f_j + (n-j) f_{j+1})}{(1-p)^i (n-i)} $$

那么设 $f_i = k_i ans + b_i$，有 $k_0 = 1, b_0 = 0, f_n = k_n ans + b_n = 0 \to ans = -\frac{b_n}{k_n}$，因此直接递推 $k_i,b_i$，最后直接算出 $ans$ 即可。

---

### Code:
```cpp
#include<bits/stdc++.h>
#define ll long long
#define pn putchar('\n')
#define mclear(a) memset(a,0,sizeof a)
#define fls() fflush(stdout)
#define maxn 3005
#define mod 998244353
#define int ll
using namespace std;
int re()
{
    int x=0,t=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')t=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return t==1?x:-x;
}
int n,p;
int f[maxn],g[maxn];
int ksm(int x,int y)
{
    int ret=1;
    while(y)
    {
        if(y&1)ret=ret*x%mod;
        x=x*x%mod,y>>=1;
    }
    return ret;
}
namespace ZH
{
    int jc[maxn],inv[maxn];
    void zh_init()
    {
        jc[0]=1;
        for(int i=1;i<=n;i++)
            jc[i]=jc[i-1]*i%mod;
        inv[n]=ksm(jc[n],mod-2);
        for(int i=n;i;i--)
            inv[i-1]=inv[i]*i%mod;
    }
    int A(int x,int y)
    {
        if(x<y)return 0;
        return jc[x]*inv[x-y]%mod;
    }
    int C(int x,int y)
    {
        return A(x,y)*inv[y]%mod;
    }
}
using namespace ZH;
signed main()
{
    #ifndef ONLINE_JUDGE
    freopen("in.txt","r",stdin);
    #endif
    n=re(),p=re()*ksm(re(),mod-2)%mod;
    zh_init();
    f[0]=1;
    for(int i=0;i<n;i++)
    {
        f[i+1]=(n*f[i]-ksm(1-p,i)*i%mod*f[i])%mod;
        g[i+1]=(n*g[i]-n-ksm(1-p,i)*i%mod*g[i])%mod;
        for(int j=0;j<i;j++)
            f[i+1]=(f[i+1]-C(i,j)*ksm(p,i-j)%mod*ksm(1-p,j)%mod*(j*f[j]%mod+(n-j)*f[j+1]%mod))%mod;
        for(int j=0;j<i;j++)
            g[i+1]=(g[i+1]-C(i,j)*ksm(p,i-j)%mod*ksm(1-p,j)%mod*(j*g[j]%mod+(n-j)*g[j+1]%mod))%mod;
        f[i+1]=f[i+1]*ksm(ksm(1-p,i)*(n-i)%mod,mod-2)%mod;
        g[i+1]=g[i+1]*ksm(ksm(1-p,i)*(n-i)%mod,mod-2)%mod;
    }
    int ans=-g[n]*ksm(f[n],mod-2)%mod;
    if(ans<0)ans+=mod;
    printf("%lld",ans);
    return 0;
}
```

---


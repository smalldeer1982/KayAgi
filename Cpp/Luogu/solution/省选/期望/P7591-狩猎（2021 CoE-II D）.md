# 狩猎（2021 CoE-II D）

## 题目描述

母狮 $\text{Dina}$ 的领地里有固定的 $n$ 个狩猎点，第 $i$ 个狩猎点有 $p_i$ 的概率可以捕捉到猎物，$\text{Dina}$ 的巢穴和 $n$ 个狩猎点相互之间存在若干条直接连接的双向道路。

每天早晨，$\text{Dina}$ 从她的巢穴出发，随机选择一个与巢穴相邻的狩猎点 $u$ 进行一次捕猎，如果她未捕捉到猎物，她会随机选择一个与当前狩猎点 $u$ 相邻的其他狩猎点 $v$ 继续进行一次捕猎，如果在狩猎点 $v$ 仍未捕捉到猎物，$\text{Dina}$ 会按照前述过程继续捕猎。如果在某个狩猎点捕捉到了猎物，$\text{Dina}$ 会立即返回巢穴，结束捕猎。若当前狩猎点 $u$ 与巢穴相邻，而与其他狩猎点不相邻，$\text{Dina}$ 也会选择立即返回巢穴，然后从与巢穴相邻的狩猎点中，随机选择一个狩猎点继续上述捕猎过程。$\text{Dina}$ 在每个狩猎点只进行一次捕猎，然后离开，但后续可能还会回到该狩猎点再次进行捕猎。在本题环境下，如果地点 $u$ 和地点 $v$ 之间有一条直接连接的双向道路，称地点 $u$ 和地点 $v$ **相邻**，否则称地点 $u$ 和地点 $v$ **不相邻**。

令巢穴的编号为 $0$，$n$ 个狩猎点的编号从 $1$ 到 $n$，$\text{Dina}$ 从编号为 $u$ 的地点到达另外一个编号为 $v$ 的地点需要消耗 $h_{u,v}$ 体力和 $t_{u,v}$ 时间。在第 $i$ 个狩猎点每进行一次捕猎，$\text{Dina}$ 会消耗 $h_i$ 体力和 $t_i$ 时间。每当 $\text{Dina}$ 到达某个狩猎点并进行一次捕猎后，她会评估自己的体力消耗和时间花费，如果体力消耗已经达到（或超过）限值 $H$，她就选择立即返回巢穴结束捕猎。如果时间花费已经达到（或超过）限值 $T$，她也会选择立即返回巢穴结束捕猎。$\text{Dina}$ 只有在到达狩猎点并进行一次捕猎后才进行评估，在任何其他时刻均不会进行评估。如果当前位于巢穴，她会在到达巢穴时就进行评估，因为巢穴并无猎物可供捕捉。

需要注意，$\text{Dina}$ 在沿着两个地点间的双向道路移动的过程中并不会评估，因此可能会出现以下情形：到达某个狩猎点且尚未进行捕猎时，$\text{Dina}$ 已消耗的体力或者已花费的时间已经超过限值。在这种情形下，$\text{Dina}$ 仍然会进行一次捕猎，之后再进行评估。

当 $\text{Dina}$ 因为捕猎成功、体力消耗或时间花费达到（或超过）相应限值、当前狩猎点与其他狩猎点不相邻而返回巢穴时，她总会选择一条具有最少时间花费的路径。如果存在多条具有最少时间花费的路径返回巢穴，她会选择其中体力消耗最少的路径。$\text{Dina}$ 在返回巢穴的过程中不会进行捕猎。

将 $\text{Dina}$ 从巢穴出发，因满足以下三个条件之一：

- 捕猎成功
- 体力消耗达到（或超过）限值 $H$
- 时间花费达到（或超过）限值 $T$

返回到达巢穴并结束捕猎的过程称为一次狩猎。给出巢穴和狩猎点之间的道路、每条道路所需要消耗的体力和花费的时间、每个狩猎点进行一次捕猎能够捕获猎物的概率以及所需消耗的体力、花费的时间，试确定 $\text{Dina}$ 完成一次狩猎所消耗体力和花费时间的平均值。

## 说明/提示

**子任务测试采用捆绑方式计分。**

**样例说明**

输入 #1

![](https://cdn.luogu.com.cn/upload/image_hosting/62vbngdn.png)

该输入只包含一个狩猎点，从巢穴到狩猎点 $1$ 之间的道路需要消耗 $2$ 体力和 $3$ 时间，体力的限值为 $10$，时间的限值为 $20$，在狩猎点 $1$ 进行一次捕猎需要消耗 $1$ 体力和 $2$ 时间，在狩猎点 $1$ 捕获猎物的概率为 $1.00$，即一定会捕捉到猎物。容易知道，进行一次狩猎所消耗的体力和花费时间的平均值分别为 $5.0=(2+1+2) \times 100\%$ 和 $8.0=(3+2+3) \times 100\%$。

输入 #2

![](https://cdn.luogu.com.cn/upload/image_hosting/k4q1qkwr.png)

相较于第一组输入，新增了两个狩猎点，但只有狩猎点 $1$ 和狩猎点 $2$ 与巢穴有直接道路相连。三个狩猎点之间无直接道路相连，但狩猎点 $1$ 可以间接通过巢穴与狩猎点 $2$ 连通。从巢穴到狩猎点 $2$ 的道路需要消耗 $4$ 体力和 $5$ 时间，在狩猎点 $2$ 进行一次捕猎需要消耗 $2$ 体力和 $3$ 时间。在狩猎点 $1$ 捕获猎物的概率为 $1.00$，即一定会捕捉到猎物，因此 $\text{Dina}$ 会立即返回巢穴并结束狩猎。在狩猎点 $2$ 捕获猎物的概率为 $0.50$，即有 $50\%$ 的概率会捕捉到猎物，但由于狩猎点 $2$ 没有其他狩猎点与之直接连通，因此不管在狩猎点 $2$ 是否捕获到猎物，$\text{Dina}$ 都会选择立即返回巢穴，在返回巢穴时，已经消耗 $10$ 体力，根据题意，不管 $\text{Dina}$ 是否已经捕捉到了猎物，她都会结束狩猎。由于是随机选择，故在巢穴时选择狩猎点 $1$ 和 $2$ 进行狩猎的概率均为 $50\%$，根据计算可知，进行一次狩猎所消耗的体力和花费时间的平均值分别为 $7.5=(2+1+2) \times 50\%+(4+2+4) \times 50\%$ 和 $10.5=(3+2+3) \times 50\%+(5+3+5) \times 50\%$。

------------

**数据范围**

- Subtask $1$：$n=1$，$10$ 分。
- Subtask $2$：$1 \le n \le 20$，每个狩猎点和其他狩猎点均无直接道路相连，$20$ 分。
- Subtask $3$：无特殊限制，$70$ 分。

对于 $100\%$ 的数据，$1 \le n \le 200$，$1 \le h_i \le 10$，$1 \le t_i \le 10$，$0 \le p_i \le 1$，$1 \le m \le \text{min}(n (n+1) / 2$，$2000$)，$1 \le h_{u,v} \le 20$，$1 \le t_{u,v} \le 20$，$1 \le H \le 200$，$1 \le T \le 200$。

------------

**约定**

- 地点 $u$ 和地点 $v$ 之间至多有一条直接连接的双向道路，两个地点之间的直连双向道路不会重复给出。
- 忽略 $\text{Dina}$ 进行评估所需要的时间。
- 在输入中，表示概率 $p_i$ 的数值是一个具有两位小数的实数。

## 样例 #1

### 输入

```
1
1 2 1.00
1
0 1 2 3
10 20```

### 输出

```
5.0 8.0```

## 样例 #2

### 输入

```
3
1 2 1.00
2 3 0.50
3 4 0.70
2
0 1 2 3
0 2 4 5
10 20```

### 输出

```
7.5 10.5```

# 题解

## 作者：metaphysis (赞：7)

[题目链接](https://www.luogu.com.cn/problem/T169571?contestId=41599)

本题的底层模型是无向图上的概率动态规划。

每个状态有三个参数：当前所在顶点 $u$，已经消耗的体力 $h$，已经花费的时间 $t$。令 $hp[u][h][t]$ 表示在顶点 $u$，已经消耗的体力为 $h$，已经花费的时间为 $t$ 时消耗体力的期望值（即平均值），$elapsed[u][h][t]$ 表示在顶点 $u$，已经消耗的体力为 $h$，已经花费的时间为 $t$ 时花费时间的期望值（即平均值），根据题目给定的规则进行状态转移，所求即 $hp[0][0][0]$，$elapsed[0][0][0]$。读者可结合参考代码的注释进行理解。

参考代码：
```cpp
#include <bits/stdc++.h>

using namespace std;

const int INF = 0x7f7f7f7f;

// 表示无向图中边的数据结构，v 为邻接顶点的编号，h 为消耗的体力，t 为花费的时间
struct edge
{
    int v, h, t;
    edge (int v = 0, int h = 0, int t = 0): v(v), h(h), t(t) {}
    // 重载小于运算符以使用优先队列
    bool operator<(const edge &e) const { return t != e.t ? t > e.t : h > e.h; }
};

// p[i] 表示第 i 个狩猎点捕获猎物的概率，
// hp[i][j][k] 和 elapsed[i][j][k] 的意义如前所述
double p[210], hp[210][260][260], elapsed[210][260][260];

// visited 为标记数组，标记某个状态是否已经访问
int visited[210][260][260];
vector<edge> edges[210];

// dH[i] 表示从地点 i 回到巢穴的符合要求的路径所消耗的体力
// dT[i] 表示从地点 i 回到巢穴的符合要求的路径所花费的时间
// neighbours[i] 表示顶点 i 所邻接的狩猎点个数
// hi[i] 表示在第 i 个地点进行一次捕猎所消耗的体力
// ti[i] 表示在第 i 个地点进行一次捕猎所花费的时间
// 很明显，在巢穴无法进行捕猎，故 hi[0] = ti[0] = 0
int N, M, H, T, dH[210], dT[210], neighbours[210], hi[210], ti[210];

// u 为当前所在的顶点，h 为已经消耗的体力，t 为已经花费的时间
void dfs(int u, int h, int t)
{
    // 备忘以加快求解速度，否则会超时
    if (visited[u][h][t]) return;
    visited[u][h][t] = 1;
    hp[u][h][t] = elapsed[u][h][t] = 0;
    // 如果当前是狩猎点
    if (u)
    {
        // 有 p[u] 的概率在该狩猎点捕猎成功，直接返回巢穴结束狩猎
        hp[u][h][t] += p[u] * (h + dH[u]);
        elapsed[u][h][t] += p[u] * (t + dT[u]);

        // 若不成功，检查体力和时间是否超出限制，如果超出，直接选择返回巢穴
        if (h >= H || t >= T)
        {
            hp[u][h][t] += (1 - p[u]) * (h + dH[u]);
            elapsed[u][h][t] += (1 - p[u]) * (t + dT[u]);
            return;
        }

        // 当狩猎不成功且体力和和时间均未超出限制时，
        // 如果当前狩猎点与其他狩猎点无直连双向道路则
        // 返回巢穴，更新期望体力和时间，注意是转移到
        // 巢穴后再更新
        if (!neighbours[u])
        {
            dfs(0, h + dH[u], t + dT[u]);
            hp[u][h][t] += (1 - p[u]) * hp[0][h + dH[u]][t + dT[u]];
            elapsed[u][h][t] += (1 - p[u]) * elapsed[0][h + dH[u]][t + dT[u]];
        }
        // 当前狩猎点与其他狩猎点有直连双向道路，随机选择一个狩猎点进行状态转移
        else
        {
            double s = 1.0 / neighbours[u];
            for (auto e : edges[u])
            {
                // 确保是狩猎点而不是巢穴
                if (e.v)
                {
                    dfs(e.v, h + e.h + hi[e.v], t + e.t + ti[e.v]);
                    hp[u][h][t] += s * (1 - p[u]) * hp[e.v][h + e.h + hi[e.v]][t + e.t + ti[e.v]];
                    elapsed[u][h][t] += s * (1 - p[u]) * elapsed[e.v][h + e.h + hi[e.v]][t + e.t + ti[e.v]];
                }
            }
        }
    }
    // 当前位于巢穴
    else
    {
        // 体力或者时间超出限制
        if (h >= H || t >= T)
        {
            hp[u][h][t] = h + dH[u];
            elapsed[u][h][t] = t + dT[u];
            return;
        }
        // 如果有狩猎点与巢穴相邻，随机选择一个狩猎点进行状态转移
        if (neighbours[u])
        {
            double s = 1.0 / neighbours[u];
            for (auto e : edges[u])
            {
                dfs(e.v, h + e.h + hi[e.v], t + e.t + ti[e.v]);
                hp[u][h][t] += s * hp[e.v][h + e.h + hi[e.v]][t + e.t + ti[e.v]];
                elapsed[u][h][t] += s * elapsed[e.v][h + e.h + hi[e.v]][t + e.t + ti[e.v]];
            }
        }
    }
}

int main(int argc, char *argv[])
{
    cin.tie(0), cout.tie(0), ios::sync_with_stdio(false);

    cin >> N;
    for (int i = 1; i <= N; i++) cin >> hi[i] >> ti[i] >> p[i];
    for (int i = 0; i <= N; i++)
    {
        edges[i].clear();
        neighbours[i] = 0;
    }
    cin >> M;
    for (int i = 0, u, v, h, t; i < M; i++)
    {
        cin >> u >> v >> h >> t;
        edges[u].push_back(edge(v, h, t));
        edges[v].push_back(edge(u, h, t));
        // 确定每个顶点有多少个狩猎点与之相邻
        neighbours[u] += (v > 0);
        neighbours[v] += (u > 0);
    }
    cin >> H >> T;

    // 确定每个地点返回巢穴时具有最短时间的路径，
    // 如果有多条具有最短时间的路径，选择消耗体力
    // 最少的路径
    memset(dH, INF, sizeof dH);
    memset(dT, INF, sizeof dT);
    priority_queue<edge> q;
    dH[0] = dT[0] = 0;
    q.push(edge(0, 0, 0));
    while (!q.empty())
    {
        edge e1 = q.top();
        q.pop();
        if (dT[e1.v] < e1.t) continue;
        for (auto e2 : edges[e1.v])
        {
            if (dT[e2.v] > dT[e1.v] + e2.t || 
                (dT[e2.v] == dT[e1.v] + e2.t && dH[e2.v] > dH[e1.v] + e2.h))
            {
                dT[e2.v] = dT[e1.v] + e2.t;
                dH[e2.v] = dH[e1.v] + e2.h;
                q.push(edge(e2.v, dH[e2.v], dT[e2.v]));
            }
        }
    }

    // 递归加备忘确定期望值
    memset(visited, 0, sizeof(visited));               
    dfs(0, 0, 0);
    cout << fixed << setprecision(1) << hp[0][0][0] << ' ' << elapsed[0][0][0] << '\n';

    return 0;
}
```

---


# 「HOI R1」杂造选构

## 题目背景

小 $\iiint$ 跟这个烦人的构造没有任何关系。

## 题目描述

若一个序列 $a$ 满足以下要求：

- $a_i=-1$ 或 $a_i\in [1,n]$。
- 对于每个 $a_i\not=-1$，将 $a_i\to i$ 连边而形成的图不存在环。

则称这个序列是合法的。

现给定整数 $x$ 与序列 $a$，满足序列 $a$ 所有元素是 $[-1,n]$ 范围内的整数。请你将所有 $a_i=0$ 的位置替换成其他整数，使得 $\sum\limits ^{n} _{i=1} a_i = x$ 且 $a$ 是合法的。若不存在这样一种方案，则报告无解。

## 说明/提示

**本题开启捆绑测试。**

| Subtask | 分值 | $n \le$ | $x \le$ |特殊性质 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| #0 | $13$ | $15$ | $225$|无|
| #1 | $24$ | $10^3$ | $10^9$|无|
| #2 | $27$ | $10^5$ | $10^{18}$|有|
| #3 | $36$ | $10^5$ | $10^{18}$|无|

*特殊性质：保证 $\forall a_i =0$。

对于所有数据，满足 $1 \le n \le 10^5,-10^{18} \le x \le 10^{18}$。

***

**Special Judge 返回值对应表**

- `Accepted.` 答案正确。
- `Oops, your answer is wrong. 1` 答案为无解，选手代码输出有解。
- `Oops, your answer is wrong. 2` 选手输出的 $\sum a_i \not = x$。
- `Oops, your answer is wrong. 3` 选手输出中含有 $0$。
- `Oops, your answer is wrong. 4` 选手输出中含有环。
- `Oops, your answer is wrong. 5` 选手输出在填空的同时将输入的 $a_i \not=0$ 的位置改动了。

## 样例 #1

### 输入

```
6 -6
-1 -1 -1 0 0 0```

### 输出

```
-1 -1 -1 -1 -1 -1```

## 样例 #2

### 输入

```
6 14
0 1 4 0 1 4```

### 输出

```
-1 1 4 5 1 4```

## 样例 #3

### 输入

```
6 10
0 0 0 0 0 0```

### 输出

```
-1 -1 4 5 -1 4```

## 样例 #4

### 输入

```
6 6
1 1 0 0 0 0```

### 输出

```
Rick```

## 样例 #5

### 输入

```
6 40
0 0 0 0 0 0```

### 输出

```
Rick```

# 题解

## 作者：Register_int (赞：3)

放 B 纯粹是怕 A 放分讨会被骂。

首先判掉一些显然有/无解的情况，比如初始就有环或者 $x\le0$ 之类的。

本题关键在于一个交换操作。若一个空位填要填的数会导致成环，那么将其与其它空位交换即可消环。这个是好理解的，否则说明之前就存在环。

$\sum a_i$ 的下界就是全部都取 $-1$，考虑先这样填，将 $x\to x-\sum a_i$ 算出还需要加上的值，从下界开始往上构造。为了方便，先处理出求出 $rt_u$ 表示 $u$ 所在的有根树的根的编号。先将平凡的情况讨论掉：

- 若仅有一个位置为 $0$，直接硬填判。
- 否则，先判 $x<2$ 显然无解：
	- 若 $x\le n+1$，则存在用两个位置解决的方法：找一个 $-1$ 全填满，不合法的话换用第二个 $-1$ 填。可以证明是一定合法的。
   - 否则，如果仅有两个空位，那么直接暴力枚举这两个空位是什么。

此时有三个空位。如果 $rt_n$ 是待定的，那么将 $a_{rt_n}$ 设为最大的 $k$ 使得 $rt_k$ 也待定即可。这样是为了贪心地取到最大的总和。

取完后，剩余的每个空位最多有 $n+1$ 的贡献。排掉不够的情况，不妨设还差的部分为 $x'$，算出 $t=\left\lfloor\frac{x'}{n+1}\right\rfloor$ 与 $y=x'\bmod(n+1)$。继续对 $y$ 讨论：

- $y=0$。可以暴力填前 $t$ 个。
- $y=1$。如果只剩两个空位，那么稍加分析可以发现只有 $t=y=1$ 的情况，那么直接硬放，若不满足再和 $rt_n$ 交换。否则，以一个空位作为调整的自由元，填掉剩下两个，不满足就和第三个空位交换。
- $y>1$。这是平凡的，用一个空位硬放后再找一个空位交换即可。

所以这些情况都是有解的，时间复杂度 $O(n)$。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int MAXN = 1e6 + 10;

typedef long long ll;

int n, cnt, rt[MAXN]; ll x, a[MAXN];

bool l[MAXN]; vector<int> p, g[MAXN];

bool dfs(int u, int f) {
	cnt++, rt[u] = f;
	for (int v : g[u]) if (rt[v] || dfs(v, f)) return 1;
	return 0;
}

void solve() {
	int u, v, w, y, k; ll t;
	for (int i = 1; i <= n; i++) {
		if (!~a[i] && dfs(i, i)) { printf("Rick"); return; }
	}
	if (cnt < n) return puts("Rick"), void();
	if (!x) { for (int i = 1; i <= n; i++) printf("%lld ", a[i]); return ; }
	if (p.size() == 1) {
		u = p[0];
		a[u] += x;
		if (a[u] < 1 || a[u] > n || rt[a[u]] == u) return puts("Rick"), void();
	}
	else if (p.size() > 1) {
		if (x < 2) return puts("Rick"), void();
		if (x <= n + 1) {
			u = p[0], a[u] += x;
			if (rt[a[u]] == u) v = p[1], swap(a[u], a[v]);
		} else if (p.size() == 2) {
			u = p[0], v = p[1];
			for (a[u] = 1; a[u] <= n; a[u]++) {
				a[v] = x - a[u] - 2;
				if (a[v] > 0 && a[v] <= n && rt[a[u]] != u && rt[a[v]] != v
				&& (rt[a[u]] != v || rt[a[v]] != u)) break;
			}
			if (a[u] > n) return puts("Rick"), void();
		} else {
			k = rt[n];
			if (l[k]) {
				for (a[k] = n - 1; a[k] && l[rt[a[k]]]; a[k]--);
				if (!a[k]) a[k] = -1; x -= a[k] + 1;
				p.erase(lower_bound(p.begin(), p.end(), k));
			}
			if (x > (ll)(n + 1) * p.size()) return puts("Rick"), void();
			t = x / (n + 1), y = x % (n + 1);
			for (int i = 0; i < t; i++) a[p[i]] = n;
			if (y == 1) {
				if (p.size() == 2 && l[k] && a[k] == -1) p.push_back(k);
				if (p.size() == 2) {
					x += a[k] + 1, x -= n + 1, a[k] = -1;
					u = p[1], a[u] += x;
					if (rt[a[u]] == u) swap(a[k], a[u]);
				} else {
					u = p[0], a[u] = 1;
					v = p.back(), a[v] = n - 1;
					w = p[1];
					if (rt[a[u]] == u || rt[a[u]] == v && rt[a[v]] == u) swap(a[u], a[w]);
					if (rt[a[v]] == v) swap(a[v], a[w]);
				}
			} else if (y > 1) {
				u = p.back(), a[u] += y;
				if (rt[a[u]] == u) v = p[p.size() - 2], swap(a[u], a[v]);
			}
		}
	}
	for (int i = 1; i <= n; i++) printf("%lld ", a[i]);
}

int main() {
	scanf("%d%lld", &n, &x);
	for (int i = 1; i <= n; i++) {
		scanf("%lld", &a[i]);
		if (!a[i]) p.emplace_back(i), a[i] = -1, l[i] = 1;
		x -= a[i];
		if (a[i] > 0) g[a[i]].emplace_back(i);
	}
	solve();
	return 0;
}
```

---

## 作者：takanashi_mifuru (赞：1)

先用并查集判判开局无解的情况，顺手缩一下联通块，把可以拿去连接的点称为“自由点”，注意我们认为 $n$ 所在联通块的自由点不算自由点。

容易发现我们不好对着这个构造因为我们不知道要选什么，考虑对于每个点先顶到最小值也就是全部选 $-1$，再一步一步调整上去。

容易发现我们每一步调整成 $n$ 肯定是增长最快的，这个是限制最宽的，一直调整直到再调整就超过了，我们考虑对自由点的数量进行讨论：

1. 两个及以上自由点，考虑把要的那个数抽出来，然后让其中一个联通块连上他（必然有合法方案），剩下的直接按照原来的方法连就好了
2. 仅一个自由点，意味着最多两个联通块，一个联通块很好判断，两个联通块考虑枚举第一个联通块所连接的点，紧接着我们知道第二个联通块所连接的点，我们连完之后判矛盾就好了。（实际上数据太水了，考场数据这里懒得写直接提交可以直结过）
3. 没有自由点，最多一个联通块，直接判就好了。

上面仅对自由点进行了讨论，接下来我们对“要修改成什么”进行讨论。

1. 如果要修改成 $n$，那我现在本来就是 $n$，直接输出合法解。
2. 如果要修改成一个小于 $n$ 的正整数，那直接进入上述流程就好。
3. 如果要修改成 $0$ 的话，也就是我们想让两个联通块合出一个 $n$ 来，这个是好判断的，容易发现因为一个点最多被一个联通块 ban，所以你可以在 $O(1)$ 次暴力选择中得出答案（就是你随便选两个联通块，然后做自由点讨论中第二种情况做的事）（实际上数据太水了，这个不判也过了）。

---


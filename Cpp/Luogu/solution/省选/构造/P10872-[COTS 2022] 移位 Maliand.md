# [COTS 2022] 移位 Maliand

## 题目背景

译自 [Izborne Pripreme 2022 (Croatian IOI/CEOI Team Selection)](https://hsin.hr/pripreme2022/) D1T2。$\texttt{2s,0.5G}$。	

[SPJ link](https://www.luogu.com.cn/paste/9qlivbk0)。

## 题目描述


给定非负整数 $N,K,L$，试构造两个 $01$ 序列 $S,T$，满足：

- $S,T$ 的长度为 $N$；
- $S$ 中恰好有 $K$ 个 $1$，$T$ 中恰有 $L$ 个 $1$；
- $f(S,T)$ 是所有可能的 $f(S,T)$ 中最小的。

定义 $f(S,T)$ 为**任意**循环移位 $S,T$ 后，$\sum_{i=1}^{N} S_i\operatorname{and} T_i$  的最大值，其中 $\mathrm{and}$ 表示按位与运算。

请你构造出 $S,T$。

## 说明/提示


对于 $100\%$ 的数据，保证 $1\le N\le 5\times 10^5$，$0\le K,L\le N$。

| 子任务编号 | 分值 | 约束  |
|:-----:|:------:|:-------:|
| $1$  | $5$  | $1\le N\le 13$  |
| $2$  | $50$  | $1\le N\le 5\, 000$  |
| $3$  | $45$  | 无额外约束 |


【评分方式】

如果你回答对了 $F$，可以得到 $20\%$ 的分数；

在此基础下，如果你的 $S,T$ 满足条件，将获得剩下 $80\%$ 的分数。

如果只打算回答第一问，也要任意输出两个符合条件 $1,2$ 的 $01$ 序列，否则不保证能得到分数。




## 样例 #1

### 输入

```
6 4 3```

### 输出

```
2
011011
101010```

## 样例 #2

### 输入

```
5 2 0```

### 输出

```
0
01001
00000```

## 样例 #3

### 输入

```
10 7 6```

### 输出

```
5
1101100111
1110001101```

# 题解

## 作者：Rainbow_qwq (赞：8)

两个串之间 $1$ 匹配的次数总和为 $k\times l$，并且共有 $n$ 次匹配。

于是答案的下界为 $k\times l$ 个球放进 $n$ 个盒子，最小化最大的盒子中的 $1$ 个数，也就是 $\lceil \dfrac{k\times l}{n} \rceil$。

设 $ans = \lceil \dfrac{k\times l}{n} \rceil$，我们可以构造来达到这个上界：

- 对于第一个串，将前 $k$ 个位置变成 $1$。
- 对于第二个串，设这个串的前缀和数组为 $sum_i$。设 $sum_i = \min(\lfloor\dfrac{(i+1)\times ans}{k} \rfloor,l)$，然后差分即可。

---

## 作者：xiaoliebao1115 (赞：4)

见证每一道水紫的诞生。
## solve
### 最优解
在循环位移的条件下，每一个 $1$ 都可以跟另一个串的所有 $1$ 匹配，总数量显然为 $K\times L$，并且很显然位移后 $S$ 和 $T$ 的相对位置最多有 $n$ 种。

每一步位移之后原有的 $1$ 和 $1$ 的匹配一定会被拆散，去和新的匹配，所以说这 $n$ 种相对位置的每一种都是独立的，他们瓜分了 $K\times L$ 的总数量。

从贪心的角度讲，我们要让 $K\times L$ 给 $n$ 分配的均匀一些，所以说易得答案的最优解是 $\lceil \frac{K\times L}{n}\rceil$，类似于鸽巢原理吧。
### 构造
考虑如何构造最优解？对于串 $S$ 在不知道 $T$ 的情况下怎么排都是一样的，所以可以将前 $K$ 个位置直接设置为 $1$。

那么串 $T$ 如何构造呢？首先我们要弄清楚我们的目标是什么。因为可以循环位移，所以可以把串 $T$ 看作一个环，在这个环上每个长度为 $K$ 的区间和不能超过 $\lceil \frac{K\times L}{n}\rceil$。

那么我们只要在这个环上面填 $1$ 并且填的均匀就行了，要保证相邻的两次填 $1$ 操作不会被同一个区间覆盖。

具体的，假设串 $T$ 的下标是 $0$ 到 $n-1$，那么我们将从 $0$ 开始填，每次加 $k$，如果这个位置填过了那么就去填下一个位置，所以我们可以得到如下代码。
```cpp
string s(n,'0');
for(int i=0,j=0;i<l;i++,j=(j+k)%n){
 while(s[j]=='1') j=(j+1)%n;
  s[j]='1';
}
```
实际上这份代码的根本作用就是每次把每种区间的和都加 $1$，都加完了再从头开始继续加，显然满足保证相邻的两次填 $1$ 操作不会被同一个区间覆盖。

这样的话我们的最优解就被构造出来了。
## code
这里只贴主函数部分。

```cpp
n=read(),k=read(),l=read();
int qp=k*l;
int ans;
if(qp%n==0) ans=qp/n;
else ans=qp/n+1;
write(ans),putchar('\n');
for(int i=1;i<=n;i++) putchar((i<=k?1:0)+'0');
putchar('\n');
	if(k==0){
  	for(int i=1;i<=n;i++) putchar((i<=l?1:0)+'0');
  	putchar('\n');
  	return 0;
  }
string s(n,'0');
for(int i=0,j=0;i<l;i++,j=(j+k)%n){
  while(s[j]=='1') j=(j+1)%n;
  s[j]='1';
}
for(int i=0;i<n;i++) putchar(s[i]);
```
跑的飞快。

---

## 作者：xxgirlxx (赞：1)

好玩。

同一场的 [P10871](https://www.luogu.com.cn/problem/P10871) 和 [P10873](https://www.luogu.com.cn/problem/P10873) 也好玩，可以去看看。

经过大量的手玩可以发现一些性质。

可以发现可以定下 $S$ 中的 $K$ 个 $1$ 全部是连在一起的，然后题目就变成了在 $T$ 中分布 $L$ 个 $1$ 后使取连续的 $K$ 个中 $1$ 的个数的最大值最小。

这个东西一看就很鸽笼啊！共有 $L$ 个 $1$，每个 $1$ 会放进 $K$ 个区间中，然后总共有 $N$ 个区间。把共有 $L$ 个 $1$，每个 $1$ 会放进 $K$ 个区间中这两个条件合一下就可以发现相当于有 $K\times L$ 个 $1$（因为 $N\ge K,L$，所以最终的答案肯定 $\le K,L$，不会出现有一个 $1$ 的 $K$ 个区间中有重复的情况，因此放心乘起来，不会有影响），用上鸽笼就可以算出答案是 $\lceil\frac{K\times L}{N}\rceil$。

接下来考虑怎么构造，我们可以保证尽量多的两个 $1$ 之间的差距刚好是 $K-1$，这样的话就可以达成两个 $1$ 之间只能有一个的目的。因此我们可以从 $1$ 开始，每轮往后面跳 $K$ 个位置（就是从 $x$ 变成 $x+K$，大于 $N$ 了记得用 $\operatorname{mod}N$ 给它拉回来），直到跳回 $1$ 为止。

但是这样有可能用不完 $L$，然后我们就只能从 $2$ 开始再来一遍了。但是可以肯定的是，一个起点最多只会跳 $\operatorname{gcd}(N,K)$ 次，并且我们不会跳到重复的位置（因为每个起点之间互不影响，如果我们的起点到了第一个起点跳的第一个位置还没结束，那么就说明 $L>N$ 了，这是不合法的，题目也保证了 $L\le N$）。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k,l,num,s[5000010],t[5000010];
int main(){
	cin>>n>>k>>l;
	cout<<k*l/n+(k*l%n!=0)<<"\n";
	for(int i=1;i<=k;i++)s[i]=1;
	for(int i=0;l!=0;i++)for(int j=0;j<n/__gcd(k,n)&&l;j++,l--)t[(i+j*k)%n+1]++;
	for(int i=1;i<=n;i++)cout<<s[i];
	cout<<"\n";
	for(int i=1;i<=n;i++)cout<<t[i];
	return 0;
}
```

---

## 作者：I_am_Accepted (赞：1)

串长为 $n$，$S,T$ 中 $1$ 的个数分别为 $a,b$。

首先 $n$ 个循环移位总匹配数为 $ab$，根据鸽笼原理答案下界为 $c=\lceil\frac{ab}{n}\rceil$，尝试构造该下界。

先猜测出 $S$ 是一段连续的 $a$ 个 $1$。

考虑构造 $T$。若普通构造每 $a$ 个放 $c$ 个 $1$，这样长度需求是 $a\cdot\lceil\frac{b}{c}\rceil\nleq n$。

考虑整数拓展到实数，长度为 $n$ 的环，有一个长度为 $a$ 的左闭右开区间在上面移动，需要在环上找到 $b$ 个点使得该区间不论怎么平移最多只能覆盖 $c$ 个位置。

这样一种简单的构造是每隔 $\frac{a}{c}$ 放一个点直到放完为止，由于 $b\cdot\frac{a}{c}\le n$，所以一定合法。

由于 $\frac{a}{c}\ge 1$，由于区间实际上只能平移到坐标为整数的位置，将实数的点下取整到整数上即不会有重叠，又保持了合法性，$T$ 构造完毕。

---

## 作者：ZnPdCo (赞：0)

对于 $S$ 和 $T$，设 $T_i$ 表示将 $T$ 循环位移 $i$ 位形成的字符串，那么：

$$
\sum_{i=0}^{|T|-1} S\operatorname{and}T_i=KL
$$
这是因为 $S$ 中每个 $1$ 恰好对应 $T$ 的每一个 $1$。

那么，根据鸽巢原理，$\max_{i=0}^{|T|-1}S\operatorname{and}T$ 最小为 $\lceil\dfrac{KL}{N}\rceil$。

将 $S$ 构造为 $K$ 个 $1$ 和 $N-K$ 个 $0$。

那么相当于，$T$ 首位相接形成的 $01$ 环中不能有连续长度为 $K$ 的区间里 $1$ 的个数超过 $L$。

如果能放的位置是实数的话，肯定是每隔 $\dfrac{N}{L}$ 放一个 $1$ 最好。

但是我们发现 $L\le N$，所以 $\dfrac{N}{L}\ge 1$，直接把放的位置四舍五入即可，而且也不会重复。

---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/P10872)

**题目大意**

> 对于两个长度为 $n$ 的 01 串 $S,T$，定义 $f(S,T)$ 表示所有 $S,T$ 的循环同构串中，公共元素最多的一对。
>
> 给定 $S,T$ 中 $1$ 的个数 $x,y$，构造 $S,T$ 使 $S,T$ 最小。
>
> 数据范围：$n\le 5\times 10^5$。

**思路分析**

考虑 $S$ 中 $1$ 的位置 $s_0\sim s_{x-1}$，$T$ 中 $1$ 的位置 $t_0\sim t_{y-1}$。

容易发现偏移量为 $s_i-t_j$ 时，$s_i$ 和 $t_j$ 会产生 $1$ 的贡献。

那么我们就要求 $f_k=\sum [s_i-t_j=k]$ 尽可能平均。

很显然 $f_k$ 的最小值就是 $\left\lceil\dfrac{xy}n\right\rceil$，并且这是容易构造的：

- 取 $s_i=i$，$t_j=-xj\bmod n$，那么 $t_j$ 对 $f_k$ 的贡献就是 $f[xj,x(j+1))$ 区间 $+1$。

  容易证明这就是最平均的构造，如果 $y>\dfrac{n}{\gcd(n,x)}$，那么接着取 $t_j=-xj-1\bmod n\cdots $ 即可。

时间复杂度 $\mathcal O(n)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
using namespace std;
signed main() {
	ios::sync_with_stdio(false);
	int n,x,y;
	cin>>n>>x>>y;
	string s(n,'0'),t(n,'0');
	cout<<(1ll*x*y+n-1)/n<<"\n";
	for(int i=0;i<x;++i) s[i]='1';
	int z=__gcd(n,x);
	for(int i=0;y;++i) {
		int p=i;
		for(int k=0;k<n/z;++k) {
			++t[(n-p)%n],p=(p+x)%n;
			if(!--y) break;
		}
	}
	cout<<s<<"\n"<<t<<"\n";
	return 0;
}
```

---


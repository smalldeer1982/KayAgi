# 并非呃呃

## 题目背景

给你一张 $n$ 个点的简单无向图。

接下来有 $q$ 次操作，每次操作为添加一条边或删去一条边，请在每次操作后判断图中是否有四元环。

等等，题面放错了。

并非呃呃。

---
在「[呃呃 / ee](https://www.luogu.com.cn/problem/P12705)」一题中，如何构造数据成为了一个难题。

当初始边数过小时，可能会让一些 $O(m\sqrt m)$ 的做法得以通过，而初始边数过大时又随机不出一张无四元环的初始图。

给你一道呃呃，输出一组足够强力的数据。

## 题目描述

给你一个整数 $n$，有一集合 $U=\{1,2,\dots,n\}$。

你需要构造 $n$ 个集合 $S_{1,2,\dots ,n}$，满足条件：
- 对所有 $1\le i \le n$，$S_i\sube U$；
- 对所有 $1\le i<j\le n$，$|S_i\cap S_j|\le 1$。

为了不让暴力通过，你希望 $\displaystyle\sum_{i=1}^n|S_i|$ 尽量大。

## 说明/提示

### 数据规模与约定
为了衡量你的构造强度，你将会得到一个整数 $L$。

对于每个数据点，你需要构造出一组解使得 $\sum_{i=1}^n|S_i|\ge L$。

| 数据点编号 | $n=$ | $L=$ |
| :----------: | :----------: | :----------: |
| $1$ | $4$ | $8$ | $10$ |
| $2$ | $10$ | $23$ | $10$ |
| $3$ | $2333$ | $4666$ | $10$ |
| $4$ | $2333$ | $6996$ | $10$ |
| $5$ | $2333$ | $10^4$ | $10$ |
| $6$ | $2333$ | $2\times 10^4$ | $10$ |
| $7$ | $2333$ | $4\times 10^4$ | $10$ |
| $8$ | $2333$ | $6\times 10^4$ | $10$ |
| $9$ | $2333$ | $8\times 10^4$ | $10$ |
| $10$ | $2333$ | $10^5$ | $10$ |

对于所有数据，保证 $4\le n\le 2333$。

### 提示

构造一张左右部点数均为 $n$ 的二分图，对于所有 $1\le i,j\le n$，左侧点 $i$ 与右侧点 $j$ 之间有边当且仅当 $j\in S_i$。容易验证，此时构造出的图中无四元环。

## 样例 #1

### 输入

```
3 5```

### 输出

```
111
010
100```

# 题解

## 作者：KingGojianOfYue (赞：5)

难度可能有些虚高吧。

前两个数据点可以自己比较容易进行构造，所以直接考虑构造 $n=2333$，$L=10^5$ 的即可。

发现 $n^{\frac{3}{2}}\approx112687>10^5$，$1$ 的个数占比约为 $\frac{1}{\sqrt{n}}$。考虑将这个 $n\times n$ 的正方形分为 $n^{\frac{3}{2}}$ 个 $1\times\sqrt{n}$ 矩形，每个矩形中有且仅有 $1$ 个 $1$。我们将第 $i$ 个元素为 $1$ 的矩形看作 $i$。这样，我们就可以将问题转化为：构造 $n$ 个 $\sqrt{n}$ 元组 $(x_{i,1},x_{i,2},\dots,x_{i,\sqrt{n}})$，满足：

- 任意一个 $\sqrt{n}$ 元组的任意一个元素均为 $[1,\sqrt{n}]$ 中的整数；
- 最多存在某一个位置相同的元素取值相等。

然后构造就简单得多了：将块长设为 $47$（多的那部分不用管了，弄成 $0$ 即可），将其分为 $47$ 组，每组 $47$ 行，对于第 $i$ 组中的第 $k$ 行的第 $j$ 个矩形，将这个矩形中第 $(i\times j+k)\bmod 47$ 个数变为 $1$ 即可。共有 $47^3=103823$ 个 $1$ 符合题意。

代码：

```cpp
#include<bits/stdc++.h>
#define puts(x) printf(x);printf("\n")
using namespace std;
bitset<2500>e;
int n,L;
int main()
{
    scanf("%d%d",&n,&L);
	if(n==4){
		puts("1100");
		puts("1001");
		puts("0110");
		puts("0011");
		return 0;
	}else if(n==10){
		puts("0011000000");
		puts("0110000000");
		puts("1100000000");
		puts("1001000000");
		puts("1000110000");
		puts("0100011000");
		puts("1000001100");
		puts("0100000110");
		puts("1000000011");
		puts("0100100001");
		return 0;
	}
	for(int i=0;i<47;++i){
		for(int k=0;k<47;++k){
			for(int j=1;j<=2333;++j)e[j]=false;
			for(int j=0;j<47;++j){
				e[j*47+1+(i*j+k)%47]=true;
			}
			for(int j=1;j<=2333;++j){
				if(e[j]==true)putchar('1');
				else putchar('0');
			}
			putchar('\n');
		}
	}
	for(int i=47*47+1;i<=2333;++i){
		for(int j=0;j<2333;++j){
			putchar('0');
		}
		putchar('\n');
	}
	return 0;
}/*

*/
```

---

## 作者：2021CHD (赞：2)

## 题意

构造 $n\times n$ 的 $01$ 矩阵使得任意两行按位与的结果至多只有一个 $1$，要求其中至少有 $L$ 个 $1$。

- $n=4,L=8$ 或 $n=10,L=23$ 或 $n=2333,L\le10^5$。（对于样例有 $n=3,L=5$）

## 解法

观察数据范围，感觉题目需要我们构造出 $O(n\sqrt{n})$ 的解。

根据人类智慧，对于**质数** $p$，我们可以构造出 $p^2\times p^2$ 的有 $p^3$ 个 $1$ 的矩阵，具体方法如下：

- 对于前 $p$ 行，第 $i$ 行的第 $(i-1)p+1\sim ip$ 个位置是 $1$，其余位置是 $0$，每行有 $p$ 个 $1$。
- 对于后 $p(p-1)$ 行，第 $ip+j+1$ 行（$1\le i<p$，$0\le j<p$）的第 $kp+(k+j)i\bmod p+1$ 个位置是 $1$（其中整数 $k$ 满足 $0\le k<p$），其余位置是 $0$，每行有 $p$ 个 $1$。

正确性说明：显然前 $p$ 行之间是互相不交的，并且前 $p$ 行和后 $p(p-1)$ 行之间的交明显是 $1$。接下来考虑后 $p(p-1)$ 行之间的交集。

若第 $i_1p+j_1+1$ 行与第 $i_2p+j_2+1$ 行交于 $k_1p+l_1+1$ 与 $k_2p+l_2+1$ 的两个位置（$1\le i_1,i_2<p$，$0\le j_1,j_2,k_1,k_2,l_1,l_2<p$），则有 $(k_1+j_1)i_1\equiv(k_1+j_2)i_2\pmod p$ 且 $(k_2+j_1)i_1\equiv(k_2+j_2)i_2\pmod p$。由于显然 $k_1\not\equiv k_2\pmod p$，则可以解得 $i_1\equiv i_2\pmod p$，又由于 $i_1\not\equiv0\pmod p$，又可以解得 $j_1\equiv j_2\pmod p$，这就意味着 $(i_1,j_1)=(i_2,j_2)$，矛盾，于是后 $p(p-1)$ 行之间的交不超过 $1$。

这样矩阵有 $p^2$ 行，每行有 $p$ 个 $1$，总共就是 $p^3$ 个 $1$。对于一个 $n$，我们可以找到最大的质数 $p$ 使得 $p^2\le n$，然后构造一个 $p^2\times p^2$ 的矩阵，多出来的 $n-p^2$ 行和 $n-p^2$ 列直接填满 $0$ 即可。显然矩阵中 $1$ 的个数为 $O(n\sqrt{n})$ 的。

对于 $n=4$，有 $p=2$，则可以构造出 $\sum_{i=1}^n|S_i|=8$，满足测试点 $1$ 的条件。

对于 $n=10$，有 $p=3$，则可以构造出 $\sum_{i=1}^n|S_i|=27$，满足测试点 $2$ 的条件。

对于 $n=2333$，有 $p=47$，则可以构造出 $\sum_{i=1}^n|S_i|=103823$，满足测试点 $3\sim10$ 的条件。

于是无需进行更多的打表或常数优化。（只不过过不了样例，但是这不重要）

## 参考代码

这是我的 [AC 记录](https://www.luogu.com.cn/record/219644276)，其中代码如下：

```C++
#include<cstdio>
using namespace std;
int n,p,i,j,k,l; 
main()
{
	scanf("%d%*d",&n);
	for(i=2;i*i<=n;i++)
	{
		for(j=2;j*j<=i;j++)
		if(i%j==0)
		break;
		if(j*j<=i)
		continue;
		p=i;
	}
	for(i=1;i<=p;i++)
	{
		for(j=1;j<=p;j++)
		{
			for(k=1;k<=p;k++)
			if(j==i)
			printf("1");
			else
			printf("0");
		}
		for(j=p*p+1;j<=n;j++)
		printf("0");
		printf("\n");
	}
	for(i=1;i<p;i++)
	for(j=0;j<p;j++)
	{
		for(k=0;k<p;k++)
		{
			for(l=0;l<p;l++)
			if(l==(k+j)*i%p)
			printf("1");
			else
			printf("0");
		}
		for(k=p*p+1;k<=n;k++)
		printf("0");
		printf("\n");
	}
	for(i=p*p+1;i<=n;i++)
	{
		for(j=1;j<=n;j++)
		printf("0");
		printf("\n");
	}
}
```

---

## 作者：wukaichen888 (赞：1)

令 $K$ 为 $\le\sqrt n$ 的最大质数。

考虑构造 $K^2$ 行 $K^2$ 列的矩阵，将其分为 $K$ 行 $K$ 列个 $K$ 行 $K$ 列的大块，每个大块内每行每列恰好有 $1$ 个 $1$，总共 $K^3$ 个 $1$，满足题意。

第一列大块直接构造主对角线。

第 $i$ 行第 $j$ 列大块由第 $i$ 行第 $j-1$ 列大块向右循环移位 $i$ 格得到。

证明：对于 $x,y$ 行，假如处于同一行大块，直接无交。否则假定存在一个同为 $1$ 的位置 $z$，由于其不处于同一行大块，$z$ 向前后跳大块差分不为 $0$，又因为 $K$ 是质数，所以倍数不重。

甚至满足两两列交 $\le1$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll N=2400;
ll n,K;
bool vis[N][N];
signed main(){
	scanf("%lld",&n);
	if(n==4) return puts("1100\n0110\n0011\n1001"),0;
	if(n==10) K=3; if(n==2333) K=47;
	for(int d=0,x;d<K;d++)
		for(int i=0;i<K;i++)
			for(int j=1;j<=K;j++){
				x=(j+i*d-1)%K+1;
				vis[i*K+j][d*K+x]=1;
			}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++)
			printf("%d",(int)vis[i][j]);
		puts("");
	}
	return 0;
}
```

---

## 作者：fish_love_cat (赞：0)

怎么秒了 /jy

---

容易想到均摊贡献。

发现一行大概要放 $\sqrt n$ 个点。

考虑对序列分块，一个块里面放一个。

假设块长为 $d$。

---

于是想到如下构造：

将 $d$ 个序列分为一大组，然后每对于一个序列 $d$ 位分为一小组。

对于每一大组的每个第一小组，使其选择的点全部一致。

然后对于第 $k$ 大组的第 $i$ 个序列中的第 $j$ 个小组，我们选择第 $(k+i\times j) \bmod d$ 点。

---

尝试说明这样的构造是对的。

显然 $j$ 不同的点肯定不重合。

若 $i$ 相同 $k$ 不同，后半部分出现的偏移一定会导致整个序列不重合。

若 $k$ 相同 $i$ 不同，构造成立当且仅当找不到 $j$ 使得 $i_1\times j \equiv i_2\times j\pmod d$ 成立。

若 $i,k$ 均不同，构造成立当且仅当找不到两个 $j$ 使得 $i_1\times {j_1}-i_2\times {j_1} \equiv i_1\times {j_2}- i_2\times {j_2}\pmod d$ 成立。

这个式子可以改写成：

$$(i_1-i_2)\times {j_1} \equiv (i_1-i_2)\times {j_2}\pmod d$$

那就和前面一致了。

所以现在只需要找到一个 $d$ 使得对于 $a,b,c<d$ 不存在 $a\times b\equiv a\times c \pmod d$。

注意到当 $d$ 是质数时，易证这个命题一定成立。于是钦定 $d=47$，答案数量为 $d^3=103823$，非常正确。

做完了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n;
    cin>>n;
    if(n==4){// 小数据手搓验证规律
        cout<<"1100\n";
        cout<<"1001\n";
        cout<<"1010\n";
        cout<<"0011\n";
    }else if(n==10){
        cout<<"1001001000\n";
        cout<<"1000100100\n";
        cout<<"1000010010\n";
        cout<<"0101000100\n";
        cout<<"0100100010\n";
        cout<<"0100011000\n";
        cout<<"0011000010\n";
        cout<<"0010101000\n";
        cout<<"0010010100\n";
        cout<<"0000000001\n";
    }else{
        map<int,bool>mp[2405];
        for(int i=1;i<=47;i++){
            for(int j=1;j<=47;j++){
                mp[(i-1)*47+j][i]=1;
                for(int k=1,g=(i+j)%47+1;k<47;k++,g=(g+j)%47+1)
                    mp[(i-1)*47+j][k*47+g]=1;
            }
        }
        for(int i=1;i<=n;i++,cout<<"\n")
        for(int j=1;j<=n;j++)cout<<mp[i][j];
    }
}
```

---


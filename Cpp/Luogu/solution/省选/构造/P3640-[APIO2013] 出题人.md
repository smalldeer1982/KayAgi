# [APIO2013] 出题人

## 题目描述

当今世界上各类程序设计竞赛层出不穷。而设计一场好比赛绝非易事，比如给题目设计测试数据就是一项挑战。一组好的测试数据需要对不同的程序有区分度：满足所有要求的程序自然应该得到满分，而那些貌似正确的程序则会在某些特殊数据上出错。

在本题中，你在比赛中的角色反转啦！作为一名久经百战的程序员，你将帮助 Happy Programmer Contest 的命题委员会设计这次比赛的测试数据。本次比赛命题委员会选择了两个图论问题，分为 $8$ 个子任务。委员会写了一些貌似可以解决这些子任务的代码。在给任务设计数据的时候，命题委员会期望其中的一些源程序能够得到满分，而另外的一些则只能得到 $0$ 分或者少许的部分分。现在你将会获得这些源程序（C, C++, Pascal 版本）。对于每个子任务，你需要去产生一组数据 $X$ 使得它能将该任务给定的 $2$ 种源程序 $A$ 和 $B$ 区分开来。更具体地说，生成的数据必须满足如下两个条件:

输入 $X$ 对于源程序 $A$ 一定不会出现超出时间限制（TLE）的问题。

输入 $X$ 一定会导致源程序 $B$ 产生超出时间限制的问题。

此外,命题委员喜欢较小规模的测试数据，希望测试数据最好能够包含不超过 $T$ 个整数。

本题中只关心源程序 $A$ 和 $B$ 是否超时，不关心是否结果正确。

命题委员会选择了单源最短路（SSSP）以及一个被称之为神秘问题（Mystery）的两个图论问题来作为比赛的题目。我们将命题委员会完成的伪代码列在了附录中，而具体的 C、C++ 和 Pascal 源程序被我们放在了下发的文件当中。

### 子任务

参见下表。表中每一行描述了一个子任务。其中前六个子任务与单源最短路相关，子任务 7,8 与神秘问题相关。每个任务所占分数见下表。

 ![](https://cdn.luogu.com.cn/upload/pic/4428.png) 

对于每个子任务，你的程序给出的输入 $X$ 需要能够将源程序 $A$ 和 $B$ 区分开来，这有这样你才能够得到相应的分数。具体说来，你的分数将由输入 $X$ 中数的个数决定。假设 $X$ 中包含了 $F$ 个整数，子任务的满分为 $S,T$ 是该任务的目标大小，则该测试点的分数将由下式给出:

$$S \times \min\{T / F, 1\}$$

也就是说，如果你的测试数据 $X$ 中含有不超过 $T$ 个整数，则你将得到该任务的全部得分。

你需要把你的 $8$ 个测试数据命名为 `1.txt` ~ `8.txt`。对于每个子任务 $X$，评测系统将根据如下步骤来确定你将会得到多少分:

- 如果未提交数据，则不得分；
- 若数据不满足输入格式要求，则不得分；
- 对源程序 $A$ 运行输入，若发生超时现象，则不得分；
- 对源程序 $B$ 运行输入，若发生超时现象，则按照前文所述的公式给出该测试点的分数。

题目提供的所有源代码均会维护一个计数器来统计程序的操作次数。在源程序的运行过程中，当该计数器超过了 $10^6$ 次时，那么我们认为程序运行超时。

### 问题 1：单源最短路（SSSP）

给定一个带权有向图 $G$，以及 $G$ 中的两个节点 $s$ 与 $t$，令 $p(s, t)$ 为 $G$ 中从 $s$ 至 $t$ 的最短路长度。如果 $s$ 与 $t$ 不连通，则认为 $p(s, t)=10^9$。在本题中，输入为图 $G$ 以及 $Q$ 个询问 $(s_1, t_1), (s_2, t_2), \dots, (s_Q, t_Q)$ 。输出则是对这 $Q$ 个询问的相应输出 $p(s_1, t_1), p(s_2 , t_2), \cdots, p(s_Q, t_Q)$。


### 问题 2：神秘问题

给定一个包含 $V$ 个节点 $E$ 条边的无向图 $G$，要求将所有的节点进行编号（编号范围为 $[0, X-1]$），使得所有直接相连的节点均有不同的编号。找出符合题意的最小的 $X$。


## 说明/提示

**源代码见附件**。

### 附录：伪代码

接下来是我们提供的所有程序的伪代码；变量 counter 近似描述出了程序的运行时间。评测时将会使用这些伪代码的 C++ 版本来进行评测。


FloydWarshall

```cpp
// pre-condition: the graph is stored in an adjacency matrix M
counter = 0
for k = 0 to V-1
    for i = 0 to V-1
        for j = 0 to V-1
            increase counter by 1;
            M[i][j] = min(M[i][j], M[i][k] + M[k][j]);
for each query p(s,t)
    output M[s][t];
```

OptimizedBellmanFord

```cpp
// pre-condition: the graph is stored in an adjacency list L
counter = 0
for each query p(s,t);
    dist[s] = 0; // s is the source vertex
    loop V-1 times
        change = false;
        for each edge (u,v) in L
            increase counter by 1;
            if dist[u] + weight(u,v) < dist[v]
                dist[v] = dist[u] + weight(u,v);
                change = true;
        if change is false // this is the ’optimized’ Bellman Ford
            break from the outermost loop;
    output dist[t];
```

ModifiedDijkstra

```cpp
// pre-condition: the graph is stored in an adjacency list L
counter = 0;
for each query p(s,t)
    dist[s] = 0;
    pq.push(pair(0, s)); // pq is a priority queue
    while pq is not empty
        increase counter by 1;
        (d, u) = the top element of pq;
        remove the top element from pq;
        if (d == dist[u])
            for each edge (u,v) in L
                if (dist[u] + weight(u,v) ) < dist[v]
                    dist[v] = dist[u] + weight(u,v);
                    insert pair (dist[v], v) into the pq;
    output dist[t];
```

Gamble1

```cpp
Sets X = V;
labels vertex i in [0..V-1] with i;
Sets counter = 0; // will never get TLE
```
Gamble2

```cpp
Sets X = V;
labels vertex i in [0..V-1] with i;
Sets counter = 1000001; // force this to get TLE
```

RecursiveBacktracking

```cpp
This algorithm tries X from 2 to V one by one and stops at the first valid X.  
For each X, the backtracking routine label vertex 0 with 0, then for each vertex u that has been assigned a label, the backtracking routine tries to assign 
the smallest possible label up to label X-1 to its neighbor v, and backtracks if necessary.  
// Please check RecursiveBacktracking.cpp/pas to see 
// the exact lines where the iteration counter is increased by 1
```

感谢zhouyonglong修改spj


## 样例 #1

### 输入

```
3
2 1 4 2 1
0
1 1 2
2
0 1
1 0
//以上为问题1```

### 输出

```
3
1000000000
The value of counter is: 5```

## 样例 #2

### 输入

```
4 5
0 1
0 2
0 3
1 2
2 3
//以上为问题2```

### 输出

```
3
0 1 2 1
The value of counter is: 18```

# 题解

## 作者：虞皓翔 (赞：35)

这道提答嘛……最短路和染色问题，先看最短路的几种算法（不管正确性与否）

Floyd 算法：裸Floyd，复杂度恒定$\Theta(V^3)$，与询问无关，没什么好说的。

优化的 Bellman-ford 算法：就是一个不变化跳循环而已，来个负权照样复杂度$\Theta(QVE)$。

改进的 Dijkstra 算法：用了堆优化，不过遇到负权就GG了。




第1/3个点：干Floyd：

Floyd是恒定$\Theta(V^3)$的，所以这么说来101个点就干掉了。

数据最小的话，没有边，刚好101+1+1+2=105个数，OK！




第2/5个点：干Bellman-ford：

复杂度$\Theta(QVE)$，来个负权，再来一堆自环/重边，人肉二分保证数据不超过T，且让Bellman-ford刚刚超过一丁点，就可以了，

第2个点要Floyd过，$V=100$即可，第5个点要Dijkstra过，那么就

0号点到299号点连正权边，其它点搞一堆负环+自环+重边，Bellman-ford轻松干掉。




第4/6个点：干Dijkstra：

说了Dijkstra看到负权就GG，所以构造一堆0边诱惑他，然后再让他从右边的点进去，举个栗子：

![公式挂了](http://latex.codecogs.com/gif.latex?V=\{0,1,2,3,4\},E=\{(0,1,2),(1,2,-4),(2,3,1),(3,4,-2),(0,2,0),(2,4,0)\})

那么就先把它拐到4，发现路长为0，然后走2~3是最短的，拐到3，开始觉醒后，发现0~1再到2，路长为-2，再走2~3，傻傻地Dijkstra就被坑了，

这样多来几次就是指数级，卡卡常就可以了。




然后是染色问题：

Gamble1是恒过器，Gamble2是恒挂器，所以第7个点就是要算法T掉，第8个点就是要算法A掉。

第7个点来个完全图，那么多颜色估计染不到了。

第8个点——因为不能有重边——所以说，因为![公式还挂](http://latex.codecogs.com/gif.latex?V\geq71,E\geq1501)，所以就染2种颜色——蓝(男)色和绿(女)色。

那么每个蓝色点和绿色点连一条边，也就是说分成两组，同组之间不连边，异族之间连边，然后Recursive-Bactraking就过了。


---

## 作者：little_cindy (赞：15)

## [更好的阅读体验](https://www.cnblogs.com/little-cindy/articles/sol-P3640.html)

## 题意简述

提交答案题

你是一个出题人，有两个问题：

- $\text{SSSP}$：最短路

  点数不超过 $300$，边权的绝对值小于 $10^6$，总边数不超过 $5000$，询问不超过 $10$ 次

- $\text{Mystery}$：无向图染色

  点数小于 $1000$ 且大于 $70$，边数小于 $10^6$ 且大于 $1500$。

对于每个测试点：

给定源程序 $A$ 和源程序 $B$，需要造一组数据使得源程序 $A$ 能跑过而源程序 $B$ 不行且整数个数小于 $T$。

**一个程序是否能跑过一个问题不在意其答案是否正确，仅关心是否超时**

| 测试点编号 |  $T$   |       问题       |           源程序 $A$           |           源程序 $B$           |
| :--------: | :----: | :--------------: | :----------------------------: | :----------------------------: |
|    $1$     | $107$  |  $\text{SSSP}$   |   $\text{ModifiedDijkstra}$    |     $\text{FloydWarshall}$     |
|    $2$     | $2222$ |  $\text{SSSP}$   |     $\text{FloydWarshall}$     | $\text{OptimizedBellmanFord}$  |
|    $3$     | $105$  |  $\text{SSSP}$   | $\text{OptimizedBellmanFord}$  |     $\text{FloydWarshall}$     |
|    $4$     | $157$  |  $\text{SSSP}$   |     $\text{FloydWarshall}$     |   $\text{ModifiedDijkstra}$    |
|    $5$     | $1016$ |  $\text{SSSP}$   |   $\text{ModifiedDijkstra}$    | $\text{OptimizedBellmanFord}$  |
|    $6$     | $143$  |  $\text{SSSP}$   | $\text{OptimizedBellmanFord}$  |   $\text{ModifiedDijkstra}$    |
|    $7$     | $3004$ | $\text{Mystery}$ |        $\text{Gamble1}$        | $\text{RecursiveBacktracking}$ |
|    $8$     | $3004$ | $\text{Mystery}$ | $\text{RecursiveBacktracking}$ |        $\text{Gamble2}$        |

## 解法

首先我们明确一下每个代码算法及其时间复杂度：

|            代码名称            |         算法          |       时间复杂度       |
| :----------------------------: | :-------------------: | :--------------------: |
|     $\text{FloydWarshall}$     |    $\text{Floyd}$     |    $\Theta(V^3+Q)$     |
| $\text{OptimizedBellmanFord}$  | $\text{Bellman-Ford}$ |     $\Theta(VEQ)$      |
|   $\text{ModifiedDijkstra}$    |   $\text{Dijkstra}$   | $\Theta(QE+Q\log_2 E)$ |
|        $\text{Gamble1}$        |  $\text{never TLE}$   |      $\Theta(1)$       |
|        $\text{Gamble2}$        |  $\text{always TLE}$  |    $\Theta(\infty)$    |
| $\text{RecursiveBacktracking}$ |  $\text{Backtrack}$   |     懒得算，挺大的     |

**注意这里 $V$ 是点数，$E$ 是边数，$Q$ 是询问数**

### point 1

#### 目的

卡 $\text{Floyd}$

#### 做法

构造 $V=101$

显然因为要输出 $101$ 个点，至少就要 $101$ 个数。所以我们把每一个点的出度都描述为 $0$。

最后询问只需要一个，问题随你，这里使用 `0 99`

共计 $105$ 个数

#### code

**为了防止抄袭，所有代码均无 `print` 函数，望周知。**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxv=305,maxq=15;
int V,E,Q;
vector<pair<int,int>> G[maxv];
int s[maxq],t[maxq];
int main(){
    V=101;
    Q=1;
    for(int i=1;i<=Q;i++){
        s[i]=0;
        t[i]=99;
    }
    print();
    return 0;
}
```

### point 2

#### 目的

卡 $\text{Bellman-Ford}(\Theta(VEQ))$

且需要让 $\text{Floyd}(\Theta(V^3))$ 过

#### 做法

这个点其实看着难卡，实际上不难。

就是要让 $V$ 恰好为 $100$（让 $\text{Floyd}$ 过），便尽量多加，在 $10$ 次询问就行了（主要是询问上限为 $10$）

可以去 [oi-wiki](http://oi-wiki.com/graph/shortest-path/#bellman-ford) 上看一下这个算法的原理，就可以发现如果我们在一条链上狂加自环，这个算法就会被卡飞。

最后的询问要按照你建边的方向，否则卡不掉。

最后算一下边能放多少边：$E_{\max}=\frac{2222(T)-1(V)-100(出度)-1(Q)-2\times10(询问)}{2(点编号及权值)}-99(链)=951$

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxv=305,maxq=15;
int V,E,Q;
vector<pair<int,int>> G[maxv];
int s[maxq],t[maxq];
int main(){
    V=100;
    E=951;
    for(int i=0;i<V;i++){
        int k=min(E,10);
        E-=k;
        if(i!=0){
            G[i].push_back(make_pair(i-1,rand()%114514+114514));
        }
        for(int j=1;j<=k;j++){
            G[i].push_back(make_pair(i,rand()%114514+114514));
        }
    }
    Q=10;
    for(int i=1;i<=Q;i++){//由于我是反着建的链，所以输出99 0
        s[i]=99;
        t[i]=0;
    }
    print();
    return 0;
}
```

### point 3

同 point 1，这里不加赘述

### point 4

#### 目的

卡 $\text{Dijkstra}(\Theta(QE+Q\log_2 E))$

且需要让 $\text{Floyd}(\Theta(V^3))$ 过

#### 做法

不了解 $\text{Dijkstra}$ 的可以去 [oi-wiki](http://oi-wiki.com/graph/shortest-path/#dijkstra) 上看看。我们可以看到：

> 在稀疏图中，$m=\Theta(n)$，使用二叉堆实现的 Dijkstra 算法较 Bellman-Ford 算法具有较大的效率优势；而在稠密图中，$m=\Theta(n^2)$，这时候使用暴力做法较二叉堆实现更优。

但是这个题没有给我们建稠密图的机会，我们不能这么卡。

于是，我们只能从 $\text{Dijkstra}$ 松弛操作的漏洞来卡。

就如 [**Abzilurtahv**](https://www.luogu.com.cn/user/224991) 大佬所说的那样，只要构造出如下图的情况， $\text{Dijkstra}$ 就去世了。

![](https://cdn.luogu.com.cn/upload/image_hosting/g5xp43kh.png)

那么为什么？这里是很多题解没有说到的。

我们来简单的证明一下：

---

我们截取一个片段：
![](https://cdn.luogu.com.cn/upload/image_hosting/24vzheqm.png)

那么整个算法会按如下步骤进行：

| 当前点 |         当前操作         |    当前队列    |
| :----: | :----------------------: | :------------: |
|  $0$   | $pop(0),push(1),push(2)$ |   $\{2,1\}$    |
|  $2$   | $pop(2),push(3),push(4)$ |  $\{4,3,1\}$   |
|  $4$   | $pop(4),push(5),push(6)$ | $\{6,5,3,1\}$  |
|  $6$   |         $pop(6)$         |  $\{5,3,1\}$   |
|  $5$   |     $pop(5),push(6)$     |  $\{6,3,1\}$   |
|  $6$   |         $pop(6)$         |   $\{3,1\}$    |
|  $3$   |     $pop(3),push(4)$     |   $\{4,1\}$    |
|  $4$   | $pop(4),push(5),push(6)$ |  $\{6,5,1\}$   |
|  $6$   |         $pop(6)$         |   $\{5,1\}$    |
|  $5$   |     $pop(5),push(6)$     |   $\{6,1\}$    |
|  $6$   |         $pop(6)$         |    $\{1\}$     |
|  $1$   |     $pop(1),push(2)$     |    $\{2\}$     |
|  $2$   | $pop(2),push(3),push(4)$ |    $\{4\}$     |
|  $4$   | $pop(4),push(5),push(6)$ |   $\{6,5\}$    |
|  $6$   |         $pop(6)$         |    $\{5\}$     |
|  $5$   |     $pop(5),push(6)$     |    $\{6\}$     |
|  $6$   |         $pop(6)$         | $\text{empty}$ |

而发现节点 $V$ 外每一个节点都拥有这个性质，所以时间复杂度为 $\Theta(2^{\frac{V-1}{2}})$，忽略常数相当于 $\Theta(2^V)$。

证毕。

---

所以对于这道题，构造一组 $V=33,Q=10$ 的数据即可

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxv=305,maxq=15;
int V,E,Q;
vector<pair<int,int>> G[maxv];
int s[maxq],t[maxq];
int main(){
    V=33;
    int dis=200000;
    for(int i=0;i<V;i++){
        if(i==V-1){
            continue;
        }
        if(i&1){
            dis/=2;
            G[i].push_back(make_pair(i+1,-dis));
        }
        else{
            G[i].push_back(make_pair(i+1,-1));
            G[i].push_back(make_pair(i+2,-2));
        }
    }
    Q=10;
    for(int i=1;i<=Q;i++){
        s[i]=0;
        t[i]=32;
    }
    print();
    return 0;
}
```

### point 5

#### 目的

卡掉  $\text{Bellman-Ford}(\Theta(VEQ))$

且需要让 $\text{Dijkstra}(\Theta(QE+Q\log_2 E))$ 过

#### 做法

同 point 2，我们需要在一条链上狂加自环。

另外我们发现其实 $\text{Dijkstra}$ 的时间复杂度是不会受 $V$ 的影响的，然后我们就让 $V$ 尽量大，也就是 $V=300$，$Q$ 也设为 $10$。

简单计算发现 $E_{\max}=\frac{1016-1(V)-300(出度)-1(Q)-2\times10(询问)}{2}-299(链)=48$

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxv=305,maxq=15;
int V,E,Q;
vector<pair<int,int>> G[maxv];
int s[maxq],t[maxq];
int main(){
    V=300;
    E=48;
    for(int i=0;i<V;i++){
        int k=min(E,10);
        E-=k;
        if(i!=0){
            G[i].push_back(make_pair(i-1,rand()%114514+114514));
        }
        for(int j=1;j<=k;j++){
            G[i].push_back(make_pair(i,rand()%114514+114514));
        }
    }
    Q=10;
    for(int i=1;i<=Q;i++){
        s[i]=299;
        t[i]=0;
    }
    print();
    return 0;
}
```

### point 6 

同 point 4，只是 $Q$ 过大导致超出限制，$Q$ 改为 $6$ 即可。

### point 7

#### 目的

卡掉 $\text{Backtrack}$，让 $\text{Gamble1}$ 过。

#### 做法

首先明确一点，这个 $\text{Gamble1}$ 是个永远不会被卡掉的程序，所以你只需要管 $\text{Backtrack}$。

而你其实可以很显然的发现 $\text{Backtrack}$ 的时间复杂度大无比，所以可以直接随机一组数据。

点数是随意的，而 $E_{\max}=\frac{3004-1(V)-1(E)}{2}=1501$。

所以我们让 $V=999,E=1501$。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxv=1005;
int V,E;
bool G[maxv][maxv];
vector<pair<int,int>> e;
int main(){
    V=999;
    E=1501;
    for(int i=1;i<=E;i++){
        int x=rand()%V;
        int y=rand()%V;
        while(G[x][y]||G[y][x]||x==y){
            x=rand()%V;
            y=rand()%V;
        }
        G[x][y]=G[y][x]=1;
        e.push_back(make_pair(x,y));
    }
    reverse(e.begin(),e.end());
    print();
    return 0;
}
```

### point 8

#### 目的

卡掉 $\text{Gamble2}$ ，$\text{Backtrack}$ 让过。

#### 做法

首先明确以下， $\text{Gamble2}$ 是一个永远都过不去的算法，所以不用管。

而这个 $\text{Backtrack}$ 是暴力染色，所以我们良心一点，让它能够一遍染完。

所以我们再造数据的时候先提前染好色，这样就能过了。

注意这里 $V$ 不能过大，否则会把 $\text{Backtrack}$ 卡掉。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxv=1005;
int V,E;
int col[maxv];
bool G[maxv][maxv];
vector<pair<int,int>> e;
int main(){
    V=101;
    E=1501;
    for(int i=1;i<=V;i++){
        col[i]=rand()%2;
    }
    for(int i=1;i<=E;i++){
        int x=rand()%V;
        int y=rand()%V;
        while(col[x]==col[y]||G[x][y]||G[y][x]||x==y){
            x=rand()%V;
            y=rand()%V;
        }
        G[x][y]=G[y][x]=1;
        e.push_back(make_pair(x,y));
    }
    reverse(e.begin(),e.end());
    print();
    return 0;
}
```

---

完结撒花！

### 后记

这篇题解我是边写题边写的

一共提交 $26$ 次才获得 AC

下面是通过各个测试点的时间：

| 测试点编号 |              时间              | 失败次数 |
| :--------: | :----------------------------: | :------: |
|    $1$     | $\texttt{2022-07-27 10:22:54}$ |   $0$    |
|    $2$     | $\texttt{2022-07-27 11:16:21}$ |   $0$    |
|    $3$     | $\texttt{2022-07-27 11:14:03}$ |   $0$    |
|    $4$     | $\texttt{2022-07-27 12:25:53}$ |   $10$   |
|    $5$     | $\texttt{2022-07-27 14:12:41}$ |   $0$    |
|    $6$     | $\texttt{2022-07-27 14:18:34}$ |   $3$    |
|    $7$     | $\texttt{2022-07-27 14:37:29}$ |   $1$    |
|    $8$     | $\texttt{2022-07-27 14:51:48}$ |   $4$    |

历时共 $16134\text{s}$，合计 $268.9\text{min}$，相当于约 $4.18167\text{h}$。

全文共 $11664$ 个字。

码字不易，点个赞再走吧～

---

## 作者：Presentation_Emitter (赞：4)

~~AHC既视感~~

那么本题要求放过一种算法，然后卡掉~~SPFA和~~另一种算法。

## 算法分析

### SSSP

- Floyd：$\Theta(V^3)$
- BF：随机情况 $\Theta(kE)$（$k$ 为小常数），但是有负权就基本上`GG`了，$\Theta(VE)$
- ModifiedDijkstra：~~不知道为什么看着像SPFA~~，**正权图**飞快且稳定，负权`GG`

### Mystery（染色）

- Gamble1：~~骗分~~，稳过
- RecursiveBacktracking：暴力
- Gamble2：~~骗分+while(1)~~，稳定TLE

## 正文

- **Task 1**

送分，显然`Floyd`在 $V \gt 100$ 会T，构造一个 $V=101,E=0$ 的图即可。

注意 $\color{#ff0000}0 \lt \color{#000000}Q \le 10$，因此 $Q=1$，整数个数 $n=2+V+2E+2Q=105 \lt 107$

- **Task 2**

卡满`BF`需要确保每轮都有若干次松弛。

有一个不难想的思路，就是每轮让编号小的尽可能晚被松弛，也就是让编号大的松弛编号小的。具体为由 $0$ 向 $V-1$ 连一条边，$V-1$ 与 $1,2,3,...,V-2$ 逐一连边，然后整一条 $V-2 \to V-3 \to ... \to 1$ 的负权链。

这种思路在本地成功把`BF`卡了，但是由于`spj`的锅，提交后`WA`了。~~这好吗？这不好！~~

那么换种思路。此时看输入格式。

> 所有询问中的起点 $s_k$ 都不能**到达**任何一个负权圈。

这意味着可以构造出 $s_k$ 不能到达的负环，从而拉满。$V=100,E=1050,Q=10$ 即可

数据大概长这样：

```param
100
0
(99行，总之就是一堆负环)
10
0 99
0 32
0 44
0 85
0 3
(总之就是一堆源点是0的询问)
```

$n=2222=T$

- **Task 3**

同**Task 1**，$n=105=T$

- **Task 4**

那么毒瘤出题人在整最短路问题的时候往往要把`SPFA`卡了，同时把`SLF`优化也卡了。根据某篇文章，`SLF`在某些情况下可以被卡到指数级（~~所以这根本不叫优化~~）。受这个的启发，也许我们可以把优化方式相似的堆优化卡掉。

好了瞎扯结束，卡Dijkstra只需要让它在松弛一个点的时候把之前松弛过的点全部重新松弛即可。

首先用一些奇怪的东西将Dj引到一个奇怪的点上，像这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/o60hunns.png)

那么现在它被引到了 $V-1$ 处。显然 $V-1$ 的最短路被松弛成了 $0$。然后倒退到它上面的那个点，这时候就可以在边权上动点手脚，比如：

![](https://cdn.luogu.com.cn/upload/image_hosting/mm63k092.png)

那么它在 $V-3$ 处，松弛完了 $V-1$，然后开始松弛 $V-2$，松弛 $V-2$ 之后它又走到了 $V-1$，然后就……

![](https://cdn.luogu.com.cn/upload/image_hosting/1nj251sb.png)

多整点，然后这玩意就被卡了。随便定个数据规模，比如 $V=33,Q=10$。

- **Task 5**

同**Task 2**，$V=300,E=347$ 即可。

- **Task 6**

同**Task 4**，$Q=6$ 即可。

- **Task 7**

送分，完全图加点边即可。

注意范围，观察 $T$ 可得 $E=1501$，$n=2E+2$

- **Task 8**

送分，让每个点的度数尽可能少即可。

代码总长（包括注释）6877B，就不贴了。

---

## 作者：绝顶我为峰 (赞：3)

题答题好玩。![qq_emoji: cy](https://xn--9zr.tk/cy)

题意：给一些图论算法构造数据，每次放过一个卡掉一个，定义“卡掉”的标准是代码中的计数器自加超过 $10^6$ 次。只有你构造的数据中**整数**的个数小于一个给定值 $T$ 时才能获得满分。

---

## subtask 1(3pts)

放过 Dijkstra 卡掉 Floyd，$T=107$。

送温暖的。

观察两个代码，都是正常的写法。但我们注意到 Floyd 中计数器放在三层循环中，也就是其值就是点数的立方，那么 Floyd 最多只能跑 $\sqrt[3]{10^6}=100$ 的点，于是我们只要造一个 $101$ 个点的图就好了，为了满足 $T=107$ 的限制，图里一条边也没有。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,q;
int main()
{
    freopen("1.txt","w",stdout);
    n=101;
    cout<<n<<endl;
    for(int i=0;i<n;++i)
        cout<<0<<endl;
    q=1;
    cout<<q<<endl;
    cout<<"0 0"<<endl;
    return 0;
}
```

数据中一共有 $105$ 个整数。

---

## subtask 2(7pts)

放过 Floyd 卡掉 Bellman-Ford，$T=2222$。

根据 sub1 得出的结论，我们的点数不能多于 $100$。观察 Bellman-Ford 的实现，发现计数器每跑一轮就会增加 $\sum n_i$，由于代码在一轮下来没有松弛成功的情况下就会推出，所以我们要让它跑满 $V-1$ 轮。

考虑 Bellman-Ford 其实是一个顺推的过程，比如如果图是一条 $0\rightarrow V-1$ 的有向链，其实一轮就已经完成了松弛。

那么我们反过来，把图建成一条 $V-1\rightarrow0$ 的有向链，这样每次松弛会恰好成功一次，每次询问的时候起点设成 $V-1$ 就可以卡满。

询问尽量多，$Q=10$，这样会进行 $Q(V-1)\sum n_i=98010$ 次运算，远远不到 $10^6$。

其实这样构造数据中的整数只有 $320$ 个，浪费了很多资源。注意到其实题目没有要求是简单图，我们大可以把多出来的整数变成重边塞进去。

算一下 $\frac{2222-22-100}{100\times 2}=10.5$，每条边都可以变成十条重边。这样 $Q(V-1)\sum n_i=980100$，还差一点。

其实还是有点浪费，我们考虑利用刚才扔掉的 $0.5$ 条边。其实我们只要每两个点连出去 $21$ 条边就是合法的，那么我们直接分奇偶连 $10$ 和 $11$ 条重边，这样 $Q(V-1)\sum n_i=1039500$，刚刚好。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,q;
int main()
{
    freopen("2.txt","w",stdout);
    n=100;
    cout<<n<<endl<<11<<endl;
    for(int i=1;i<=11;++i)
        cout<<n-1<<" 1 ";
    cout<<endl;
    for(int i=1;i<n;++i)
    {
        if(i&1)
        {
            cout<<"10 ";
            for(int j=1;j<=10;++j)
                cout<<i-1<<" 1 ";
        }
        else
        {
            cout<<"11 ";
            for(int j=1;j<=11;++j)
                cout<<i-1<<" 1 ";
        }
        cout<<endl;
    }
    q=10;
    cout<<q<<endl;
    while(q--)
        cout<<n-1<<" 0"<<endl;
    return 0;
}
```

数据中一共有 $2222$ 个整数。

---

## subtask 3(8pts)

放过 Bellman-Ford 卡掉 Floyd，$T=105$。

你怎么又在送啊。

和 sub1 一模一样即可。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,q;
int main()
{
    freopen("3.txt","w",stdout);
    n=101;
    cout<<n<<endl;
    for(int i=0;i<n;++i)
        cout<<0<<endl;
    q=1;
    cout<<q<<endl<<"0 0"<<endl;
    return 0;
}
```

数据中一共有 $105$ 个整数。

---

## subtask 4(17pts)

放过 Floyd 卡掉 Dijkstra，$T=157$。

这个有点难度。

随了很多组数据，发现这个 Dijkstra 表现出色且稳定，数据规模还限制得这么小，真的能卡掉吗？

发现题目中限制的是边权的绝对值，也就是说可以有负权边，众所周知 Dijkstra 在有负权边的时候是可以卡成指数级别的，我们可以在这个上面做文章。

构造这种数据的核心在于造一个长链出来，先用小的正边权把 Dijkstra 骗到链尾，然后外挂很多点，点的入边是一个大的正权边，出边是一个绝对值比入边大的负权边，这样最短路实际上是走外挂点的那条，但是 Dijkstra 已经被链骗过去更新了一遍整个图了，所以它会重新松弛，多重复几次就变成指数级了，这样算一下其实 $T=157$ 还很松，这里构造的数据 $V=33,Q=10$。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,q;
int main()
{
    freopen("4.txt","w",stdout);
    n=33;
    cout<<n<<endl;
    for(int i=2;i<n;i+=2)
    {
        cout<<"2 "<<i-1<<" "<<(1<<(17-i/2-1))<<" "<<i<<" 0"<<endl;
        cout<<"1 "<<i<<" "<<-(1<<(17-i/2))<<" "<<endl;
    }
    cout<<0<<endl;
    q=10;
    cout<<q<<endl;
    while(q--)
        cout<<0<<" "<<n-1<<endl;
    return 0;
}
```

数据中一共有 $151$ 个整数。


---

## subtask 5(10pts)

放过 Dijkstra 卡掉 Bellman-Ford，$T=1016$。

用 sub2 的方法构造即可。$T$ 限制变紧的同时我们没有了 $V\leq 100$ 的限制，于是直接把点数开到最大，剩余的整数尽量造重边即可。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,q;
int main()
{
    freopen("5.txt","w",stdout);
    n=300;
    cout<<n<<endl<<0<<endl;
    for(int i=1;i<n;++i)
        if(i<=47)
            cout<<"2 "<<i-1<<" 1 "<<i-1<<" 1"<<endl;
        else
            cout<<"1 "<<i-1<<" 1"<<endl;
    q=10;
    cout<<q<<endl;
    while(q--)
        cout<<n-1<<" 0"<<endl;
    return 0;
}
```

数据中一共有 $1014$ 个整数（似乎还能再加一条重边，不过已经足够卡掉了）。

---

## subtask 6(19pts)

放过 Bellman-Ford 卡掉 Dijkstra，$T=143$。

还是考虑刚才的做法，但是我们用掉的整数刚好比 $143$ 多了一点。![qq_emoji: fn](https://xn--9zr.tk/fn)

运行一下 Dijkstra 跑一下刚才造的那组数据，发现其实在跑到第 $6$ 组询问的时候已经 $TLE$ 了，也就是说我们多了四组没用的询问。

删了他们，少了 $8$ 个整数，$151$ 刚好变成 $143$。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,q;
int main()
{
    freopen("6.txt","w",stdout);
    n=33;
    cout<<n<<endl;
    for(int i=2;i<n;i+=2)
    {
        cout<<"2 "<<i-1<<" "<<(1<<(18-i/2-1))<<" "<<i<<" 0"<<endl;
        cout<<"1 "<<i<<" "<<-(1<<(18-i/2))<<" "<<endl;
    }
    cout<<0<<endl;
    q=6;
    cout<<q<<endl;
    while(q--)
        cout<<0<<" "<<n-1<<endl;
    return 0;
}
```

数据中一共有 $143$ 个整数。

---

## subtask 7(11pts)

图染色，要求相邻点颜色不同，最小化颜色数，让你放过的算法是钦定能过的，卡掉暴力，$T=3004$。

别送了，别送了。

暴力的实现是从小到大暴力 check 答案，那我们让答案很大就好了。

完全图！我们来算一下，这个完全图最大可以有 $55$ 个点，然后我们只要连边即可，得到 $E=1485$……

慢着？题目里面说 $V>70,E>1500$？

那我们只能多来几个点补到 $71$，然后在他们之间连边把边数凑到 $1501$。

刚才完全图加上 $V$ 和 $E$ 一共用掉了 $2\times 1485+2=2972$ 个点，还剩 $32$ 个点，可以连 $16$ 条边。而我们刚好需要 $16$ 条边达到 $1501$，问题解决。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,m;
int main()
{
    freopen("7.txt","w",stdout);
    n=71,m=1501;
    cout<<n<<" "<<m<<endl;
    for(int i=1;i<55;++i)
        for(int j=i+1;j<=55;++j)
            cout<<i-1<<" "<<j-1<<endl;
    for(int i=55;i<n;++i)
        cout<<0<<" "<<i<<endl;
    return 0;
}
```

数据中一共有 $3004$ 个整数。

---

## subtask 8(25pts)

染色，放过暴力，让你卡掉的算法是钦定过不了的。

道理我都懂，这一下子送 $25$ 分是？

怎么放过这个暴力？把颜色数造得非常小即可。那我们点数开到最大 $V=999$，然后先来连成一个环，然后其实就是人类智慧，只要把边凑够，没有度数特别大的点就好了。我的做法是再来一轮，每次 $i-1$ 和 $2i-1$ 连边，这样最后还需要连 $5$ 条才能到 $1501$ 直接首尾相连即可。这样算一下一共 $2\times 1501+2=3004$，刚刚好。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,m;
int main()
{
    freopen("8.txt","w",stdout);
    n=999,m=1501;
    cout<<n<<" "<<m<<endl;
    for(int i=1;i<n;++i)
        cout<<i-1<<" "<<i<<endl;
    for(int i=2;i<<1<=n;++i)
        cout<<i-1<<" "<<(i<<1)-1<<endl;
    for(int i=0;i<5;++i)
        cout<<i<<" "<<n-1-i<<endl;
    return 0;
}
```

数据中一共有 $3004$ 个整数。

---

至此整个题目完结，这确实是一个非常有趣的题目，不同任务难易有梯度，唯一感觉不太好的地方是让我很期待的后两个 subtask 甚至比前面还要简单，大大低于我的预期。

---

## 作者：Little09 (赞：3)

一道有意思的题答构造题。题目是要你卡掉一个算法，给另一个算法过。前 6 个点是最短路的三种解法，后面 2 个点是一个染色问题。

------------

## 最短路部分

一些需要了解的东西：

- FloydWarshall 就是 $O(V^3)$，和边无关。

- ModifiedDijkstra 堆优化的 Dijkstra，正权图里 $O(Q*\log V*E)$，负权图可以卡。

- OptimizedBellmanFord $O(QVE)$，随机图跑的快。

然后就可以开始了。

### 一、卡掉 Floyd (Task1,3)

最简单的部分，可以直接令 $V=101,E=0$，Floyd 正好炸开。此时 $T=105$，正好满足限制。

```cpp
cout << "101" << endl;
for (int i=1;i<=101;i++) cout << "0" << endl;
cout << "1\n1 101\n";
```

### 二、卡掉 BellmanFord (Task2,5)

从这里本题正式开始。BellmanFord 可以用负环卡掉，或者是用自环和重边等。

- 给 Floyd 过(Task 2)

	即为 $n\le100$。卡掉 BellmanFord 我造了几组自环和重边，一条从 $99$ 到 $1$ 的大长链，然后调了半天，终于把这个点卡了。
    
    ```cpp
	cout << "100" << endl;
	int tot=1100;
	for (int i=0;i<100;i++) 
	{
		if (i!=0);
		else 
		{
			cout << "1 0 13\n";
			continue;
		}
		int u=min(tot,30)/2;
		cout << u+5 << " ";
		for (int j=1;j<=u;j++) cout << i << " " << rand()<<" ";
		if (tot>30) tot-=30;
		else tot=0;
		cout << i-1 << " " <<rand()-rand()<<" ";
		cout << i-1 << " " <<rand()-rand()<<" ";
		cout << i-1 << " " <<rand()-rand()<<" ";
		cout << i-1 << " " <<rand()-rand()<<" ";
		cout << i-1 << " " <<rand()-rand()<<" ";
		cout << endl;
	}
	cout << "10" << endl;
	for (int i=1;i<=10;i++) cout << "99 0\n";
	```
- 给 Dijkstra 过(Task 5)

	考虑负环。由于题目要求起点开始无负环，所以可以将起点终点从用偶数点连，奇数点做负数自环。稍微卡一下就行了。
    
    ```cpp
	cout << "300" << endl;
	for (int i=0;i<300;i++) 
	{
		if (i%2==0)
		{
			if (i==298) 
			{
				cout << "0" << endl;
				continue;
			}
			cout << "1 " << i+2 << " 1 " << endl; 
		}
		else
		{
			if (i>80) cout << "1 " << i << " -1 " << endl; 
			else cout << "2 " << i << " -1 " << i << " -1 "<< endl; 
		}
	}
	cout << "10" << endl;
	for (int i=1;i<=10;i++) cout << "0 298\n";
	```

### 三、卡掉 Dijkstra (Task4,6)

这里是最难的。我们知道 Dijkstra 在负权图上可能被卡掉。那么怎么卡呢？~~我去看了题解~~，这里给出一种构造方法。

![](https://cdn.luogu.com.cn/upload/image_hosting/4tdz62ol.png)

每个三角形是前一个三角形边权 $2$ 倍。构造若干个这样的三角形结构，这样傻傻的 dij 会已知沿着 $0$ 的边走到 $0$，然后往回走，这样就是指数级的。

然后给出 Task 4 的代码，Task 6 几乎一样，减少一下询问数即可。

```cpp
cout << "33" << endl;
int tot=1;
for (int i=0;i<33;i++) 
{
	if (i==0) 
	{
		cout << "0\n";
		continue;
	}
	if (i%2==0)
	{
		printf("2 %d %d %d %d\n",i-2,0,i-1,2*tot);
	}
	else printf("1 %d %d\n",i-1,-4*tot);
	if (i%2==0)
	{
		tot*=2;
	}
}
cout << "10" << endl;
for (int i=1;i<=10;i++) cout << "32 0\n";
```

最短路部分到此结束。

------------
## 染色问题部分

先观察三个代码。

- RecursiveBacktracking 爆搜。

- Gamble1 永远不会 TLE。

- Gamble2 永远都会 TLE。

所以两个问题就是要你卡掉爆搜和给爆搜过。这部分不难。

结合 $T$，你会发现边数是固定为 $1501$ 的。

### 一、卡掉 RecursiveBacktracking (Task7)

众所周知，爆搜随便卡。然后搞个随机图就可以了。这个代码好像不用给吧。

### 二、给 RecursiveBacktracking 过 (Task8)

因为边数固定，点数又不能小，考虑答案 $X=2$。然后这就是一个二分图，直接构造一个二分图就可以过了。这个代码好像也不用给吧。



------------

本题综合考察了对三个最短路的理解和掌握和图论知识，是个不错又奇怪的题。

我的做题记录：

![](https://cdn.luogu.com.cn/upload/image_hosting/cwyr0ug0.png)

---

## 作者：xryjr233 (赞：3)

突发奇想做一道非传统题。。。

只要发现这些算法的一些性质就好了:

#### SSSP:

FloydWarshall:稳定$O(V^3)$

ModifiedDijkstra:正权图跑得贼快,负权图可能会被卡掉

OptimizedBellmanFord:时间按复杂度取决于更新节点的顺序

#### Mystery(染色问题):

RecursiveBacktracking:时间复杂度很大程度上取决于答案的大小

## Task1

既然ModifiedDijkstra在正权图上跑得飞快,我们只需要构造正权图卡掉FloydWarshall即可。

由于FloydWarshall是稳定$V^3$的,只要出到$V>100$就行了,所有点的出边数量可以为0。

(允许的话甚至可以没有询问,但是本题要求$Q>0$)

code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n=101;
int main(){
	freopen("1.txt","w",stdout),printf("%d\n",n);
	for(int i=1;i<=n;++i)puts("0");
	puts("1\n1 1");
	return 0;
}
```

## Task2

由于FloydWarshall稳定$V^3$,我们考虑让$V=100$,这样FloydWarshall永远也不会被卡掉,又给我们卡OptimizedBellmanFord提供了最方便的条件。

发现OptimizedBellmanFord是$O(V^2E)$的,但是由于剪枝的存在,可能跑不满。

如何让它跑满呢?

发现它更新节点的顺序是从0到$V-1$,所以我们只需要建一条链,$V-1$为起点,0为终点就好了。

但是还不够,由于点数有限,导致链的长度有限,而且给定的$T$远远没用完。

那么把剩下的$T$建成重边就好了。

code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n=100,T=2222,Q=10,Num,RE,RN;
void print(int x){
	if(x!=n-1){
		printf("%d ",Num);
		for(int i=1;i<=Num;++i)printf("%d 1 ",x?x-1:n-1);//0与n-1之间的边并不会影响复杂度
		puts("");
	}else{
		printf("%d ",Num+RE);
		for(int i=1;i<=Num+RE;++i)printf("%d 1 ",x?x-1:n-1);
		puts("");
	}
}
int main(){
	freopen("2.txt","w",stdout);
	printf("%d\n",n),T-=1+n+1+(Q<<1),Num=(T>>1)/n,RE=(T>>1)-Num*n;
	for(int i=0;i<n;++i)print(i);
	printf("%d\n",Q);
	while(Q--)printf("%d 0\n",n-1);
	return 0;
}
```

## Task3

由于FloydWarshall稳定$V^3$,直接令$V>100$就可以直接卡掉,放OptimizedBellmanFord过也很简单,不连边就好了。

code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n=101;
int main(){
	freopen("3.txt","w",stdout);
	printf("%d\n",n);
	for(int i=1;i<=n;++i)puts("0");
	puts("1\n0 1");
	return 0;
}
```

## Task4

我们说过ModifiedDijkstra在负权图上可能被卡掉。

那么怎么建负权图呢?

建立如下图的结构就好了。

![Task4](https://i.ibb.co/hcnVfNq/Task4.png)

这样的话每次ModifiedDijkstra会先沿边权为0的边更新偶数编号的节点,然后**从小到大**更新奇数编号的节点,然后从奇数编号的节点更新偶数编号的节点,又重新开始更新偶数编号的节点,更新结束以后才又开始更新下一个奇数编号的节点,时间复杂度变为指数级别。

具体建立多少个点,进行几次询问呢?

先假设我们尽可能建点,建立$2x+1$个点,那么就需要建立$3x$条边。

得$1+(2x+1)+(2\times 3x)+1+2=157$

解释一下:1是输出$V$的数量,$2x+1$是输出$n_i$的数量,$3x$是输出边的数量,由于要用两个数字表示一条边所以要乘2,$1$是输出$Q$的数量,由于至少要有1个询问,所以2是输出询问的数量。

解得$x=19$,则$V=39$,显然不会把FloydWarshall卡掉。

但是我们发现这么写并不能让ModifiedDijkstra T掉,但是已经很接近了。

我们发现当我们减少两个点,建出的图就会少2个点3条边,也就少输出了8个数,可以让我们添加4次询问。

于是我们令$V=37,Q=5$,成功让ModifiedDijkstra T掉。

code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n=37,q=5,tt=1;
int main(){
	freopen("4.txt","w",stdout);
	printf("%d\n",n);
	puts("0");
	for(int i=1;i<n;++i)i&1?printf("1 %d %d\n",i-1,-tt<<1):(printf("2 %d 0 %d %d\n",i-2,i-1,tt),tt<<=1);
	printf("%d\n",q);
	for(int i=1;i<=q;++i)printf("%d 0\n",n-1);
	return 0;
}
```

## Task5

类似Task2,建正权边即可。

不过还没完,这次的$T$要小一些。

不过如果像我这么写也很方便,直接把Task2的代码中的$n$改成300,$T$改成1016即可。

code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n=300,T=1016,Q=10,Num,RE,RN;
void print(int x){
	if(x!=n-1){
		printf("%d ",Num);
		for(int i=1;i<=Num;++i)printf("%d 1 ",x?x-1:n-1);
		puts("");
	}else{
		printf("%d ",Num+RE);
		for(int i=1;i<=Num+RE;++i)printf("%d 1 ",x?x-1:n-1);
		puts("");
	}
}
int main(){
	freopen("5.txt","w",stdout);
	printf("%d\n",n),T-=1+n+1+(Q<<1),Num=(T>>1)/n,RE=(T>>1)-Num*n;
	for(int i=0;i<n;++i)print(i);
	printf("%d\n",Q);
	while(Q--)printf("%d 0\n",n-1);
	return 0;
}
```

## Task6

会了Task4的话这里也很简单了。

由于$T$减少了14,那么我们可以减少4个点(减少了16个输出的数字),相应地增加1个询问(增加了2个输出的数字)就好了。

并不用管OptimizedBellmanFord,绝对卡不掉的。

code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n=33,q=6,tt=1;
int main(){
	freopen("6.txt","w",stdout);
	printf("%d\n",n);
	puts("0");
	for(int i=1;i<n;++i)i&1?printf("1 %d %d\n",i-1,-tt<<1):(printf("2 %d 0 %d %d\n",i-2,i-1,tt),tt<<=1);
	printf("%d\n",q);
	for(int i=1;i<=q;++i)printf("%d 0\n",n-1);
	return 0;
}
```

## Task7

由于RecursiveBacktracking的时间复杂度与$X$的答案有很大关联,$X$变大的话时间复杂度就会骤然上升,所以相当于我们要构建一个$X$很大的图。

考虑构建完全图。

得$2+V(V-1)=3004$,2是输出$V,E$的数量,$V$个点的完全图有$\frac{V(V-1)}{2}$条边,需要用$V(V-1)$个数表示。

解得$\lfloor V\rfloor=55$。

但是数据要求$V>70$。

突然想到我们建完55个点的完全图以后,不是还有多余的$T$吗?

发现多余的$T$是32,可以建16条边,而16条边刚好将节点54到70连成一条链。

code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n=71,gr=55,E=1501;
int main(){
	freopen("7.txt","w",stdout);
	printf("%d %d\n",n,E);
	for(int i=0;i<gr;++i)for(int j=i+1;j<gr;++j)printf("%d %d\n",i,j);
	for(int i=gr;i<n;++i)printf("%d %d\n",i-1,i);
	return 0;
}
```

## Task8

同Task7,我们考虑建立$X$尽可能小的图。

发现$X$最小的图就是链,$X=2$。

然而我们尴尬地发现$V<1000,E>1500$,并不能建成链。

那怎么办?

我们令$V=999$,先连成一条链,再将剩余的边连在标号相差2的节点之间就好了。

这样建出的图$X=3$。

code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n=999,E=1501;
int main(){
	freopen("8.txt","w",stdout);
	printf("%d %d\n",n,E);
	for(int i=1;i<n;++i)printf("%d %d\n",i-1,i),--E;
	for(int i=0;i<n&&E;++i)printf("%d %d\n",i,i+2),--E;
	return 0;
}
```

---

## 作者：EXODUS (赞：1)

# Part 1：前言

由于本题洛谷的 spj 的正确性未知，所以截止此题解发布之日，此份代码只能在洛谷上获得 93 分，但在 uoj 上可以通过。如果你发现了我 Sub2 的正确性问题，请通过洛谷私信或其他方式告诉我我的问题；关于 spj 的问题，可以看我在讨论区的帖子。感激不尽/kt。

# Part 2：正文

那就一个 Subtask 一个 Subtask 的做吧。

## Subtask 1

让我们卡掉 Floyd，放过 Dijkstra，数字个数限制 $107$。

这个比较简单，Floyd 的复杂度是固定 $O(n^3)$ 的，因此考虑直接把 $n$ 拉满。构造一个由 $n$ 个孤立点构成的图，令 $n\ge 100$，然后随便做一次询问。这样的话数字个数是 $n+4$ 个。在我的构造中 $n=103$。

## Subtask 2

让我们卡掉 Bellman-Ford，放过 Floyd。数字个数限制 $2222$。

放过 Floyd 是简单的，我们只需要限制点数 $n\leq 100$ 即可。问题在于如何卡掉 Bellman-Ford。观察这个 Bellman-Ford 的增广过程，容易发现其复杂度是 $O(qkm)$ 的，其中 $k$ 为增广轮数，$m$ 为边数。然后我们试图把 $k$ 卡满。注意到 $k$ 的上界是 $n$，我们发现只需要让每一轮只有一个点被增广即可，注意到造一条长链即可。但是我们还需要把边数拉大，因此叠上重边即可。分析一下，我们的数字个数是 $2m+n+2q+2$ 的，那么我们的 $m$ 大概取到 $1000$ 上下，刚好卡掉 Bellman-Ford。

实际实现上取了 $n=100$，然后每个点向前连边成一条长链，并叠上重边。点的度数在 $[10,11]$ 中等概率随机。 

## Subtask 3

让我们卡掉 Floyd，放过 Bellman-Ford。数字个数限制 $105$。

和第一个包一样，唯一区别是少给了两个数。因此把 Subtask 1 中的构造的 $n$ 调成 $101$ 即可。

## Subtask 4

让我们卡掉 Dijkstra，放过 Floyd。数字个数限制 $157$。

最有难度的一集。

在正权图上显然不好卡，因此考虑负权边会对 Dijkstra 造成怎样的影响。考虑如果存在三个点 $u,v,w$，满足 $u$ 向 $v$ 连边权较大的正权边，$v$ 向 $w$ 连边权绝对值更大的负权边，$u$ 向 $w$ 连边权较小的正权边，则按照 Dijkstra 的贪心策略，当前增广到 $u$，会先增广经过 $w$ 的最短路，再增广 $v$。此时 $w$ 最短路改变，所以 $w$ 将会被重新增广。如果多套几个这种结构，则增广次数变为指数级。具体而言，我们设计这样的结构。

![](https://cdn.luogu.com.cn/upload/image_hosting/kr5trng8.png)

其中 $v$ 为一较小值，$base_i$ 为一组远大于 $v$ 的值。设上图三角结构的个数为 $c$，则 Dijkstra 的复杂度就会上升为 $O(2^c)$。

实际中的实现和我的描述略有差异。我令 $base_0$ 为 $2^{19}$，且 $base_i=\dfrac{base_{i-1}}{2}$。我对于每一组三角结构，构造正权边为 $base_i$，负权边为 $-base_{i-1}$。计算一下数字个数，应为 $2q+n+3\times\dfrac{n-1}{2}+2$ 量级。实际中取了 $n=33,q=10$。

## Subtask 5

让我们卡掉 Bellman-Ford，放过 Dijkstra。数字个数限制 $1016$。

拿过来 Subtask 2 的 gen。发现数据范围缩水了，考虑删掉一些边。注意到此时我们没有点数限制，而在点边不同阶的情况下多加点是优于多加边的。因此考虑把点数直接拉满到 $300$。然后造出链结构，发现这样以后 Bellman-Ford 已经几乎跑满，因此拿剩下的数字叠上重边即可。

在实际实现中，我先造了 Subtask 2 中所述的链结构，然后以 $\dfrac{1}{7}$ 的几率在一条边上叠上重边。

## Subtask 6

让我们卡掉 Dijkstra，放过 Bellman-Ford。数字个数限制 $143$。

构造和 Subtask 4 相同。但是我们发现这个数据范围缩水了。因此我将 $n$ 在 $[31,37]$ 中扰动了一下，发现在 $n$ 取 $33$，$q$ 取 $6$ 的时候数字个数恰为 $143$ 且卡掉了 Bellman-Ford。因此直接在 Subtask 4 的 gen 的基础上令 $q=6$ 即可。

## Subtask 7

让我们卡掉 RecursiveBacktracking ，放过 Gamble1。数字个数限制 $3004$。

不妨先介绍一下对应的问题和程序。问题是图染色，Gamble1 和 Gamble2 分别对应了一个永远不会挂和永远会挂的程序，而 RecursiveBacktracking 是通过搜索的方法得到图染色方案。注意到在这两个 Subtask 里边限制的很紧，我们必须恰好有 $1501$ 条边。

我们先来考虑什么时候 RecursiveBacktracking 是跑满的， 显然的，对于一个固定的 $X$，$X$ 无解的时候跑的最满。因此我们考虑造一个 $n$ 阶完全图。那么其在第 $n-1$ 轮的时候复杂度为 $(n-1)!$。然后再随便造一些孤立点在其间两两连边解决边数的限制即可。

实际中我造了一个 $n=55$ 阶的完全图。

## Subtask 8

让我们卡掉 Gamble2，放过 RecursiveBacktracking 。数字个数限制 $3004$。

根据上一个的经验，我们考虑尽可能减小答案，并试图让每个点在最小解对应的搜索中第一次填上的数就是合法方案。一个简单的想法是构造答案为 $2$，一种的构造是一条链，但是点数超过上界。因此考虑构造答案为 $3$。我的构造是首先构造一条边，使得在搜索中边的两端点颜色分别为 $0$ 和 $1$，然后以这个边为一边，大量构造类似于 Subtask 4 中的三角结构，这样在搜索中这些点都将直接被染成颜色 $2$，故可以很快得出答案。 这样每一个点会带来两条边，所以点数变为了 $\dfrac{m-1}{2}+2$。可以通过。

# Part 3：代码

## Subtask 1

```cpp
void solve(){
	int n=103,q=1;
	printf("%d\n",n);
	for(int i=1;i<=n;i++)printf("0\n");
	printf("%d\n",q);
	printf("%d %d\n",1,2);
	return;
}
```

## Subtask 2

```cpp
void solve(){
	mt19937 g(0);
	int n=100,q=10;
	printf("%d\n0\n",n);
	for(int i=1;i<n;i++){
		int lim=0;
		printf("%d ",lim=(10+(g()&1)));
		printf("%d %d ",i-1,1);
		for(int i=2;i<=lim;i++)printf("%d %d ",i-1,1);
		printf("\n");
	}
	printf("%d\n",q);
	for(int i=1;i<=q;i++)printf("%d %d\n",n-1,0);
	
	return;
}
```

## Subtask 3

```cpp
void solve(){
	int n=101,q=1;
	printf("%d\n",n);
	for(int i=1;i<=n;i++)printf("0\n");
	printf("%d\n",q);
	printf("%d %d\n",0,n-1);
	return;
}
```

## Subtask 4

```cpp
void solve(){
	int n=33,q=10;
	vector<vector<pair<int,int>>>edge(n);
	for(int i=0;i<n/2;i++)edge[i].eb(i+1,0);
	int base=(1<<19);
	for(int i=n/2+1;i<n;i++){
		edge[i-n/2-1].eb(i,base>>1);
		edge[i].eb(i-n/2,-base);
		base>>=1;
	}
	printf("%d\n",n);
	for(int i=0;i<n;i++){
		printf("%d ",(int)edge[i].size());
		for(auto [v,w]:edge[i])printf("%d %d ",v,w);
		printf("\n");
	}
	printf("%d\n",q);
	for(int i=1;i<=q;i++)printf("%d %d\n",0,n/2);
	return;
}
```

## Subtask 5

```cpp
void solve(){
	mt19937 g(0);
	int n=300,q=10;
	printf("%d\n0\n",n);
	for(int i=1;i<n;i++){
		int lim=0;
		printf("%d ",lim=(1+(g()%7==0)));
		printf("%d %d ",i-1,1);
		for(int i=2;i<=lim;i++)printf("%d %d ",i-1,1);
		printf("\n");
	}
	printf("%d\n",q);
	for(int i=1;i<=q;i++)printf("%d %d\n",n-1,0);
	
	return;
}
```

## Subtask 6

```cpp
void solve(){
	int n=33,q=6;
	vector<vector<pair<int,int>>>edge(n);
	for(int i=0;i<n/2;i++)edge[i].eb(i+1,0);
	int base=(1<<19);
	for(int i=n/2+1;i<n;i++){
		edge[i-n/2-1].eb(i,base>>1);
		edge[i].eb(i-n/2,-base);
		// printf("%d %d %d\n",i-n/2-1,i,base-(i-n/2));
		// printf("%d %d %d\n",i,i-n/2,-base);
		base>>=1;
	}
	printf("%d\n",n);
	for(int i=0;i<n;i++){
		printf("%d ",(int)edge[i].size());
		for(auto [v,w]:edge[i])printf("%d %d ",v,w);
		printf("\n");
	}
	printf("%d\n",q);
	for(int i=1;i<=q;i++)printf("%d %d\n",0,n/2);
	return;
}
```

## Subtask 7

```cpp
void solve(){
	n=71;
	vector<pair<int,int>>edge;
	for(int i=0;i<55;i++){
		for(int j=i+1;j<55;j++){
			edge.eb(i,j);
		}
	}
	uniform_int_distribution<int>rng(55,n-1);
	mt19937 g(0);
	
	while(edge.size()<1501){
		int u=rng(g),v=rng(g);
		while(u==v||vis[u][v])u=rng(g),v=rng(g);
		edge.eb(u,v);vis[u][v]=vis[v][u]=1;
	}
	printf("%d %d\n",n,(int)edge.size());
	for(auto [u,v]:edge)printf("%d %d\n",u,v);
	return;
}
```

## Subtask 8

```cpp
void solve(){
	vector<pair<int,int>>edge;
	int n=2;edge.eb(0,1);
	while((int)edge.size()!=1501){
		edge.eb(0,n),edge.eb(1,n);
		n++;
	}
	printf("%d %d\n",n,(int)edge.size());
	for(auto [u,v]:edge)printf("%d %d\n",u,v);
	
	return;
}
```

---

## 作者：白鲟 (赞：1)

## 前言
写不动其他题之后不小心看到一道非传统题。然后打算做一下长长干劲。发篇题解纪念一下。

其实不算很毒瘤。

## 题目分析 & 代码
本质上前六个点是单源最短路径，后两个点是染色。

### 1~6

Floyd 时间复杂度稳定为 $\operatorname{O}(V^3)$。

堆优化的 Dijkstra 在非负权中表现稳定为 $\operatorname{O}(E\log E)$，但按照题目的写法可以被负权边卡成指数级。

剪枝的 Bellman-Ford 时间复杂度仍为 $\operatorname{O}(VE)$。构造极端数据可以卡满。

1 与 3 要求卡 Floyd，根据题目要求，当 $V=101$ 时即可卡出 $10^6$。令边数为 $0$，询问数为 $1$，两组可用同样的数据卡掉。

```cpp
#include<cstdio>
using namespace std;
int main()
{
	freopen("1.txt","w",stdout);
	puts("101");
	for(int i=1;i<=101;++i)
		puts("0");
	puts("1\n0 100");
   return 0;
}
```
2 与 5 要求卡 Bellman-Ford。根据下发的文件可以发现松弛顺序按编号升序。那么构造的数据使得路径上的点编号降序即可。对于 $2$，将点数卡到 $100$ 放过 Floyd，并构造一条编号降序的链，再随意搭上非负自环并卡满边数和询问即可。对于 $5$，由于整数数量限制变小，对比 Dijkstra 与 Bellman-Ford 的时间复杂度可知应尽量卡满点数，然后如上构造一条链并将剩下的边构造为从起点无法到达的负自环使得 Bellman-Ford 无法剪枝，同时将询问卡满。

```cpp
#include<algorithm>
#include<cstdio>
using namespace std;
int main()
{
	freopen("2.txt","w",stdout);
	puts("100");
	for(int i=0;i<50;++i)
	{
		puts("10 ");
		for(int j=1;j<=10;++j) 
			printf("%d 1\n",max(0,i-1));
	}
	for(int i=50;i<100;++i)
	{
		puts("11 ");
		for(int j=1;j<=11;++j) 
			printf("%d 1\n",max(0,i-1));
	}	
	puts("10");
	for(int i=1;i<=10;++i)
		puts("99 0");
	return 0;
}
```

```cpp
#include<cstdio>
using namespace std;
int main()
{
	freopen("5.txt","w",stdout);
	puts("300");
	printf("45 ");
	for(int i=1;i<=45;++i)
		printf("0 -1 ");
	puts("");
	puts("0");
	for(int i=2;i<300;++i)
		printf("1 %d 1\n",i-1);
	puts("10");
	for(int i=1;i<=10;++i)
		printf("299 1\n");
	return 0;
}
```

这道题的难点在 4 和 6 的卡 Dijkstra。在这道题数据范围的限制下，非负权边 Dijkstra 无法卡到比剩余两个算法更劣。因此只能考虑负权。

根据 Dijkstra 的贪心策略，尝试引导 Dijkstra 走向非最优路径。设 $(u,v,w)$ 表示  $u$ 到 $v$ 长为 $w$ 的边，考虑边 $(1,3,0),(1,2,1),(2,3,-2)$，从 $1$ 到 $3$ 时，由于 Dijkstra 会优先走 $(1,3,0)$，$3$ 出队两次才会被更新为最短路。由此得到的启示是，嵌套这样的结构便能将其卡成指数级。

如何嵌套这样的结构才能让每个 $3$ 类点带来的更新次数影响严格翻倍呢？根据要求，应该让编号靠前的 $3$ 类点被更新的时刻更靠后，那么需要让更靠前的 $3$ 类点到 $1$ 的距离更靠后。按编号顺序，将每一条 $(1,2,x)$ 的边权 $x$ 依次缩小至上一条的 $\dfrac{1}{2}$，同时让 $(2,3,y)$ 的边权 $y$ 为对应 $x$ 的 $-2$ 倍，即为一种满足题意的构造。

两个点可以用同样的方式卡。

```cpp
#include<cstdio>
using namespace std;
int main()
{
	freopen("6.txt","w",stdout);
	puts("33");
	for(int i=0;i<32;i+=2)
		printf("2 %d 0 %d %d\n1 %d -%d\n",i+2,i+1,1<<((32-i)>>1),i+2,1<<(((32-i)>>1)+1));
	puts("0");
	puts("6");
	for(int i=0;i<6;++i)
		puts("0 32");
	return 0;
}
```

### 7~8
玄乎的“神秘算法”事实上只是染色。根据常识，普通染色随机图即可卡掉，而二分图染色匈牙利算法的时间复杂度为 $\operatorname{O}(V^3)$。

发现整数限制和数据范围卡得很死。边数只能是 $1501$。7 要求卡掉该程序，构造随机图即可；8 要求放过该程序，构造点数为 $100$ 的二分图即可。

比最短路简单多了……
```cpp
#include<cstdio>
#include<cstdlib>
#include<ctime>
using namespace std;
bool appeared[1001][1001];
int main()
{
	freopen("7.txt","w",stdout);
	srand(unsigned(time(0)));
	puts("999 1501");
	for(int i=0;i<1501;++i)
	{
		int x=rand()*rand()%999,y=rand()*rand()%999;
		while(appeared[x][y]||x==y)
		{
			x=rand()*rand()%999;
			y=rand()*rand()%999;
		}
		printf("%d %d\n",x,y);
		appeared[x][y]=appeared[y][x]=true;
	}	
	return 0;
}
```

```cpp
#include<cstdio>
#include<cstdlib>
#include<ctime>
using namespace std;
bool appeared[1001][1001];
int main()
{
	freopen("8.txt","w",stdout);
	puts("100 1501");
	for(int i=0;i<1501;++i)
	{
		int x=rand()*rand()%50,y=rand()*rand()%49+50;
		while(appeared[x][y]||x==y)
		{
			x=rand()*rand()%50;
			y=rand()*rand()%49+50;
		}
		printf("%d %d\n",x,y);
		appeared[x][y]=appeared[y][x]=true;
	}	
	return 0;
}
```

---

## 作者：rainbow_cat (赞：0)

### Test 1 & 3
这两个点很好做 Floyd 复杂度为 $O(V^3)$ 构造 $101$ 个点和 $1$ 个询问即可。
### Test 7
这种回溯算法应该会被完全图卡飞，往完全图上再挂些点凑满刚好 $1501$ 条边即可。
### Test 8
为了避免回溯，只构造两种颜色，也就是说二分图，$T=3004$ 所以 $E=1501$。
### Test 2 & 5
注意到优化的 BellmanFord 是只要没有变化就退出，为了让最短路每次都有变化，考虑负环，同时要避免源点在负环里面，这样就可以卡到 $O(QVE)$。
```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
	freopen("5.txt","w",stdout);
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cout<<300<<'\n';
	cout<<"1 1 -1\n1 2 -1\n1 0 -1\n";
	int st=4,ed=0;
	for(int i=3;i<=3;i++)
	{
		cout<<299<<' ';
		for(int j=0;j<300;j++)if(i!=j)cout<<j<<' '<<1<<' ';
		cout<<'\n';
	}
	for(int i=4;i<=40;i++)cout<<"1 4 1\n";
	for(int i=41;i<=299;i++)cout<<0<<'\n';
	cout<<10<<'\n';
	for(int i=1;i<=10;i++)cout<<99<<' '<<i<<'\n';
	return 0;
}
```
### Test 4 & 6
正边权是无法卡的，考虑负边权。   
这个算法不是堆优化 dijkstra，而是堆优化 spfa。  
具体的可以看这个博客：https://blog.csdn.net/Python13131313/article/details/143192182 。   
![](https://cdn.luogu.com.cn/upload/image_hosting/eory8k0z.png)   
这样构造即可，因为 SPFA 就会被骗去走更远的路而每次都要重复入堆，自然就变为指数级的了。   
这里 $V=33,Q=6$。
```cpp
#include<bits/stdc++.h>
using namespace std;
int cnt;
int main()
{
	freopen("6.txt","w",stdout);
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cout<<33<<'\n';
	for(int i=0;i<=30;i+=2)
	{
		if(i)cout<<2<<' '<<i-2<<' '<<0<<' '<<i-1<<' '<<1<<'\n';
		else cout<<0<<'\n';
		cout<<1<<' '<<i<<' '<<(-1<<++cnt)<<'\n';
	}
	cout<<2<<' '<<30<<' '<<0<<' '<<31<<' '<<1<<'\n';
	cout<<6<<'\n';
	for(int i=1;i<=6;i++)cout<<32<<' '<<0<<'\n';
	return 0;
}
```

---

## 作者：封禁用户 (赞：0)

# [题目链接](https://www.luogu.com.cn/problem/P3640)

# 题目大意

$8$ 个问题，每个问题给你两个程序，要让第一个程序跑过，第二个程序 TLE（运行次数超过 $10^6$）。

## 卡 Floyd（第 1、3 问）

由于 Floyd 是 $O(V^3)$ 的，直接把 $V$ 设为 $101$，整数个数正好够。

## 卡 BellmanFord（第 2、5 问）

这两个小问思路一样，但是参数不一样。

BellmanFord 经过过优化，所以为了跑满要使其有一个负环。

由于没有判断是否不是正无穷就直接更新，所以这样就会不停更新负环。

分成三部分：

第一部分，真正能访问到的区域（一个连通块）；

第二部分，小负环；

第三部分，一大堆零边。

然后卡一卡结点个数（手动二分一下，挺烦人的，不过应该列不等式组也行）。

## 卡 Dijkstra（第 4、6 问）

这个不好想，坑挺多的。

堆优化 Dijkstra（准确的来说这是堆优化 SPFA）在负权图上会被卡到指数级别。

怎么卡呢？

让它被骗的次数尽可能多。

可以让它每次先走进一个看似更近的路，结果搜完发现另一条路更近。

然后坑点就来了。

我一开始想这样干：

![图片挂了](https://cdn.luogu.com.cn/upload/image_hosting/ahyx2h24.png?x-oss-process=image/resize,m_lfit,h_340,w_450) 

然后发现 Dijkstra 居然没挂，并且轻松跑过。

弄了一会儿，终于搞出来了。

这里总结一下坑点：

1. 路径长度要是负数；

2. 不能所有短的地方都用 $-2$，要指数级别，比如 $-262144,-131072,-65536,\dots$。

原因：

因为一条路走了正确的后后面全部走错误的路径长度要比开始走错误后面全部走正确的要短。

解个不等式组就好了。

然后要手动计算一下，合理分配询问次数、点数等，卡得很死。

## 卡染色问题爆搜（第 7 问）

仔细看看程序，发现颜色个数从 $2$ 搜到 $V$，于是可以考虑尽可能使得程序搜的次数多。

怎么多呢？放个完全图，直接卡到指数级别。

## 让染色问题爆搜通过（第 8 问）

这一问很好想，直接放个二分图即可。

## AC 记录（为了跑得快使用了提交代码） [C 22ms](https://www.luogu.com.cn/record/116613449) [C++ 24ms](https://www.luogu.com.cn/record/116498943)

---

## 作者：Plozia (赞：0)

宣传博客->[link](https://blog.csdn.net/BWzhuzehao/article/details/117001679)

一道神仙图论题，很考验各位对最短路以及染色问题的理解。

首先说明 1 点，实质上神秘问题就是经典的染色问题。

---------

这里首先简要分析一下给出的几个代码的特色：

- FloydWarshall：稳定的 $O(V^3)$ 运行。下称 Floyd。
- OptimizedBellmanFord：加了优化的 Bellman-Ford，但是只要在每一轮松弛的时候有一个点的 $dis$ 被改变了就会被彻底卡成 $O(V^2E)$，于是负环可以派上用场。下称 Bellman-Ford/BF。
- ModifiedDijkstra：也有人说这是堆优化的 SPFA，这玩意在正权图上表现良好，但是只要我们构造一些奇怪的负权边就被卡掉了，更具体的分析见后文。下称 Dijkstra/dij。
- Gamble1：永远不会 TLE。
- Gamble2：永远会 TLE。
- RecursiveBacktracking：暴力染色的代码，这玩意及其容易卡。下称 RB。

---------

Subtask 1：放 Dijkstra，卡掉 Floyd，$T=107$。

Subtask 3：放 Bellman-Ford，卡掉 Floyd，$T=105$。

因为计数器大于 1000000 时就会 TLE，因此我们只需要构建一组有 101 个点，但是没有任何边的图就可以了。

询问只需要询问 1 组，随便哪两个点都行。

$T=1+101+1+2=105$，能够通过这两个点。

---------

Subtask 2：放 Floyd，卡掉 Bellman-Ford，$T=2222$。

Subtask 5：放 Dijkstra，卡掉 Bellmam-Ford，$T=1016$。

这两组数据需要卡掉 BF。

但是前面已经分析过，只需要来一个简单的负环，然后边数尽量大就好。

对于 Subtask 2：点数 $V=100$，然后搞一个负环，边数尽量大即可。

对于 Subtask 5：由于 dij 在负权图上容易被卡，因此我们需要一条 $0->1$ 的单向边，然后 $2,3,4$ 构成负环，剩下的所有点随便连边，边数尽量大就好。注意 $0,1$ 这两个点必须是单独构成一个连通块。

---------

Subtask 4：放 Floyd，卡掉 Dijkstra，$T=157$。

Subtask 6：放 Bellman-Ford，卡掉 Dijkstra，$T=143$。

本题最难的两个点，需要好好研究一下题目中的 dij 代码。

P.S. 如果你是非 C++ 党或者懒得研究代码，请直接跳到两份代码后面的分析。

首先一般的 Dijkstra 代码是这样的：（我写的一份）

```cpp
void dijkstra()
{
    memset(dis, 0x3f, sizeof(dis));
    memset(book, 0, sizeof(book));
    priority_queue <pri> q; q.push((pri){1, 0}); dis[1] = 0;
    while (!q.empty())
    {
        pri x = q.top(); q.pop();
        if (book[x.now]) continue ;
        book[x.now] = 1;
        for (int i = Head[x.now]; i; i = Edge[i].Next)
        {
            int u = Edge[i].to;
            if (dis[u] > dis[x.now] + Edge[i].val)
            {
                dis[u] = dis[x.now] + Edge[i].val;
                if (!book[u]) q.push((pri){u, dis[u]});
            }
        }
    }
}
```

题目给的是这样的：

```cpp
while (Q--) {
    scanf("%d %d", &s, &t);

    vector<int> dist(V, INF);
    dist[s] = 0;
    priority_queue< IntPair, vector<IntPair>, greater<IntPair> > pq;
    pq.push(IntPair(0, s));
    while (!pq.empty()) {
      counter++;
      if (counter > 1000000) {
        printf("TLE because iteration counter > 1000000\n");
        return 1;
      }

      IntPair front = pq.top(); pq.pop();
      d = front.first; u = front.second;
      if (d == dist[u]) {
        for (j = 0; j < (int)AdjList[u].size(); j++) {
          IntPair v = AdjList[u][j];
          if (dist[u] + v.second < dist[v.first]) {
            dist[v.first] = dist[u] + v.second;
            pq.push(IntPair(dist[v.first], v.first));
          }
        }
      }
    }

    printf("%d\n", dist[t]);
  }
```

大致特色是这样的：

- 题目给的代码是对于每一组询问都做一遍 Dijkstra。于是我们只需要构造 10 组相同询问，每组询问运行次数超过 100000 即可。
- 对比两份代码，会发现题目给的代码并没有 $book$ 数组。这将会导致答案正确，但是我们可以构造一些奇怪的东西卡掉它。
- 其实如果你对 SPFA ~~这个已死的算法~~足够精通的话，你还会发现实际上这个代码是优先队列优化的 SPFA（SLF 优化 SPFA）。而一个常识就是 SLF 优化 SPFA 是可以被卡成指数级别的，因此我们也可以尝试着将其卡成指数级别。

那么怎么卡呢？看下图：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210519193457344.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JXemh1emVoYW8=,size_16,color_FFFFFF,t_70)

我们从 0 开始找，走 $0 \to 2 \to 4$，走不了了，返回。

然后 $2 \to 3 \to 4$，发现能够更新最短路。

在更新完 $2,3,4$ 之后算法回退到 1，然后走 $0 \to 1 \to 2$，会发现能够更新 $2$ 的最短路。

然后又重复上面的过程，傻傻的 Dijkstra 就被我们卡掉了。

总结一下就是：

- 考虑构建一个形如上面的三元环 $V,V+1,V+2$，$V$ 向 $V+2$ 连一条边权为 0 的边，向 $V+1$ 连一条边权为 $dis$（$dis$ 很大），然后 $V+1$ 向 $V+2$ 连一条边权为 $-dis \times 2$ 的边。
- 然后构建 $V+3,V+4,V+5$，不过此时 $dis$ 需要除以 2。

这样做的原理就是在一个三元环中，$V$ 将会走到 $V+2$ 两次：$V \to V+2$，$V \to V+1 \to V+2$，而且只要 $V$ 被走到就会重复上述过程。

当然你也可以不这么构建，反正只要原理相同就可以了。

于是我们只要构建足够多的三元环，就可以顺利的将 Dijkstra 卡成指数级别。

Bellman-Ford 呢？

反正这玩意没有负环，BF 不是随便跑qwq

对于 Floyd，你根本没法构造点数大于 100 的图（$T$ 很小），而且你也没必要构造，只需要卡掉 Dijkstra 就好了~

这两个 Subtask 有两个需要注意的地方：

- 千万注意连边顺序，一定是先连 $V \to V+2$，再连 $V \to V+1 \to V+2$，否则 Dijkstra 会一次得出正确答案。
- 由于这两个 Subtask 的 $T$ 都非常小，因此一定要注意你一共输出了多少个整数，需要计算清楚。

---------

Subtask 7：卡掉 RecursiveBacktracking。

Subtask 8：放 RecursiveBacktracking。

暴力染色的代码太好卡了，只要构造一个近似完全图就可以将这玩意卡掉，随机都行。

~~前提：不是非酋。~~

放 RB 过也很简单，因为染色问题的暴力代码在二分图上表现良好，于是我们只需要构造一个二分图即可。

但是这两个 Subtask 有最小限制 $V \geq 71，E \geq 1501$。

计算一下：$1 + 1501 \times 2=3003$，要求只能有 3004 个整数。

看样子这个是要到极限了。

然而暴力染色代码复杂度在二分图上跟点数没有太大关系，而对于 Subtask 7 反正你是要卡掉它。

于是这两个点 $V=100$（对于 Subtask 8 可以更大），然后 $E=1501$。

Subtask 7 随便构造近似的完全图，Subtask 8 构造二分图即可。

---------

Summary：

这道题让我们见识到了~~毒瘤出题人卡你最短路的若干种方法~~各种最短路算法（Floyd，优化 Bellman-Ford，SLF 优化 SPFA）的优缺点，是一道非常好的图论题，可以加深对最短路的了解与掌握。

---

## 作者：tmpliyijiang (赞：0)

## 分析
由于题意，**不需要**关注算法的正确性，只有**运算次数**超过 $10^6$ 才算错误，所以首先分析题目给出的算法的时间复杂度及性质。

| 算法名称 | 时间复杂度 | 性质 |
| -----------: | -----------: | -----------: |
|  _FloydWarshell_  |严格 $O(V^3)$|$V\le100$ 时**必过**，$V>100$ 时**必挂** |
|  _ModifiedDijkstra_  |正权图：$O(E\log V)$ **负权图：指数级**|负权 GG
|  _OptimizedBellmanFord_  | 正权图：$O(QkE)$（其中 $k$ 为较小常数） **负权图：**$O(QVE)$
|  _RecursiveBacktracking_  | 暴力，较大 |  |
|  _Gamble1_  |$O(1)$| **恒过** |
|  _Gamble2_  |$O(\inf)$| **恒挂** |


## 解法

### Task 1: 
要过 Dijkstra，**卡 Floyd**。注意到它的性质，只要构造有 $101$ 个点的图 Floyd 必挂，题目要求 $T\le107$，最优时 $E=0,T=105$，符合要求。

### Task 2：
要过 Floyd，**卡 BellmanFord**。首先必然构造 $100$ 个点的图，再来一堆**重边、自环和链**，让 BellmanFord 刚好过一点就行了。

### Task 3:
要过 BellmanFord，卡 Floyd。解法同 **Task 1**。

### Task 4:
要过 Floyd，**卡 Dijkstra**。注意到 Dijkstra 在**负权图**上会被卡到**指数级别**。比如，从 $1$ 号点一链到底，所有边权都是 $0$，把 Dijkstra 引开，再构造出更优解，让它反复转圈，无法自拔，就能使它的时间复杂度退化到指数级，从而 TLE。

### Task 5:
要过 Dijkstra，**卡 BellmanFord**。与 **Task 2** 相似，构造一堆**重边、自环和链**，由于 $T$ 较小，可以直接**手玩**。

### Task 6:
要过 Dijkstra，**卡 BellmanFord**。解法同 **Task 4**。

### Task 7:
要**卡染色**。这个算法时间复杂度贼高，随机生成图就能过。

### Task 8:
要**过染色**。给每个点设置红和蓝两种颜色，同色不连边，异色连边即可。


---

## 作者：EgLund (赞：0)

感谢@chen_zhe大佬的题解让我会做这个题目了。
### Part 1 SSSP
#### Subtask 1
放掉堆优化Dij。

~~这不是放一放不就好了吗？~~

$T \le 107$，而且$N \ge 101$，所以$E_i = 0$。

随便来个询问即可。
#### Subtask 2
卡Bellman，放Floyd。

~~这不是搞一搞不就好了吗？~~

Bellman算法，一遇到负权边就废了，复杂度照样$O(VE)$。

所以搞一个一堆负权边+自环+重边，让Bellman微微T就行。
#### Subtask 3
放Bellman。

~~这不是粘一粘不就好了吗？~~

大眼观察，发现和Subtask 1一毛一样。
#### Subtask 4
骗过Dij，卡掉它。

~~这不是骗一骗不就好了吗？~~

和Bellman一样，Dij算法，一遇到负权边就废了，复杂度照样指数级别。

如何骗呢？那就让他误入歧途。

![](https://cdn.luogu.com.cn/upload/image_hosting/hs6ww4bk.png)

仔细看，Dij在0节点时，会先走0->1，到了1才发现0->2->1短，然后Dij就傻傻的被骗了。

所以我们多构造几个就行了。
#### Subtask 5
卡Bellman，放Dij。

~~这不是卡一卡不就好了吗？~~

因为有Dij，不能负权，只能自环+重边+误入歧途链。人肉调参。

#### Subtask 6
放Bellman。

~~这不是贴一贴不就好了吗？~~

大眼观察，发现和Subtask 4一毛一样。
### Part 2 Mystery
#### Subtask 7
卡暴搜。

~~这不是造一造不就好了吗？~~

瞎卡。

本人运气：不是非酋就行。
#### Subtask 8
放暴搜。

~~这不是改一改不就好了吗？~~

---


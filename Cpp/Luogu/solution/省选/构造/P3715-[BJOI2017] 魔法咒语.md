# [BJOI2017] 魔法咒语

## 题目描述

Chandra 是一个魔法天才。

从一岁时接受火之教会洗礼之后，Chandra 就显示出对火元素无与伦比的亲和力，轻而易举地学会种种晦涩难解的法术。这也多亏 Chandra 有着常人难以企及的语言天赋，让她能轻松流利地说出咒语中那些极其拗口的魔法词汇。

直到十四岁，开始学习威力强大的禁咒法术时，Chandra 才遇到了障碍。

根据火之魔法规则，禁咒的构成单位是 $N$ 个基本词汇。施法时只要凝聚精神力，说出一段用这些词语组成的长度恰好等于 $L$ 的语言，就能释放威力超乎想象的火法术。过去的魔法师们总结了几种表达起来最连贯的组合方式，方便施法者以最快语速完成法术。

但具有魔法和语言双重天才的 Chandra 不满足于这几种流传下来的禁咒，因为她可以毫无困难地说出普通人几乎不可能表达的禁咒语句。然而，在实际施法时，Chandra 发现有些自创禁咒念出后不但没有预期效果，反而会使自己的精神力迅速枯竭，十分难受。

这个问题令 Chandra 万分不解。她大量阅读典籍，到处走访魔法学者，并且不顾精神折磨一次又一次尝试新咒语，希望找出问题的答案。

很多年过去了，在一次远古遗迹探险中，Chandra 意外闯进了火之神艾利克斯的不知名神殿。根据岩土特征分析，神殿应该有上万年的历史，这是极其罕见的。Chandra 小心翼翼地四处探索，沿着魔力流动来到一间密室。她看见密室中央悬浮着一本书籍。在魔法保护下书籍状况完好。精通上古语言的 Chandra 读过此书，终于解开了多年的困惑。


禁咒法术之所以威力强大，是因为咒语借用了火之神艾利克斯的神力。这本书里记载了艾利克斯生平忌讳的 $M$ 个词语，比如情敌的名字、讨厌的植物等等。使用禁咒法术时，如果语言中含有任何忌讳词语，就会触怒神力而失效，施法者也一并遭受惩罚。

例如，若 `banana` 是唯一的忌讳词语，`an`、`ban`、`analysis` 是基本词汇，禁咒长度须是 $11$，则 `bananalysis` 是无效法术，`analysisban`、`anbanbanban` 是两个有效法术。注意：一个基本词汇在禁咒法术中可以出现零次、一次或多次；只要组成方式不同就认为是不同的禁咒法术，即使书写形式相同。

谜题破解，Chandra 心情大好。她决定计算一共有多少种有效的禁咒法术。

由于答案可能很大，你只需要输出答案模 $10 ^ 9 + 7$ 的结果。


## 说明/提示

【样例解释 1】

有效的禁咒法术共有 $14$ 种：`boom/bang/oo`，`oo/oo/oo/oo/oo`，`oo/oo/ooh/ooh`，`oo/ooh/oo/ooh`，`oo/ooh/ooh/oo`，`ooh/oo/oo/ooh`，`ooh/oo/ooh/oo`，`
ooh/ooh/boom`，`ooh/ooh/oo/oo`，`ooh/ooh/bang`，`ooh/bang/ooh`，`bang/oo/oo/oo`，`bang/ooh/ooh`，`bang/bang/oo`。

【样例解释 2】

有效的禁咒法术有 `a/ab`，`ab/a`，`aba` 共三种。注意，`ab/a` 和 `aba` 算成两种不同的禁咒法术。

【数据规模与约定】

本题一共有 $10$ 个测试点。

下表是每个测试点的数据规模和约定：

 ![](https://cdn.luogu.com.cn/upload/pic/5191.png) 

对于 $100\%$ 的数据，$1 \le N, M \le 50，1 \le L \le 10^8$，基本词汇的长度之和不超过 $100$，忌讳词语的长度之和不超过 $100$。保证基本词汇不重复，忌讳词语不重复。


## 样例 #1

### 输入

```
4 2 10
boom
oo
ooh
bang
ob
mo```

### 输出

```
14```

## 样例 #2

### 输入

```
3 1 3
a
ab
aba
aaa```

### 输出

```
3```

## 样例 #3

### 输入

```
3 1 14
ban
an
analysis
banana```

### 输出

```
15```

# 题解

## 作者：shadowice1984 (赞：17)

这种题目套路性还是蛮强的……

如果熟练了之后还是可以很快干掉它的

在做这道题之前可以先去做一发BZOJ1009(是这道题的弱化版)

~~(然而我连AC自动机都敲挂了……我怎么这么不熟练啊)~~

## 计数dp

嗯如果是计数问题还是字符串的话，如果你足够熟练会想到是在有限状态自动机上跑dp，然后完成我们的计数工作，因为dp是一个足够灵活的计数手段(但是比起数学方法来讲肯定就慢了不少)，可以解决许多有复杂限制的计数问题，比如这道题

~~(什么你不知道什么是有限状态自动机？科普一下好了)~~

### 确定性有限状态自动机 (DFA)

这里不想介绍标准定义了，实用一点的话我们可以定义一个DFA是这个东西：

1.有1个开始节点

2.有若干个终止节点

3.有一个转移函数，f(p,c)表示如果在p状态读入一个c字符会转移到哪个状态

或者我们可以采取更加粗暴的定义，一个DFA是一张图，有一个开始节点和若干个终止节点，点没有实际意义，一个边代表一个字符，而且所有点的出边数目都等于字符集大小(比如一般来讲每个点有26个出边)，我们输入一个字符串相当于在图上以开始节点为起点走出一条路径

定义一个字符串可以被DFA识别，当且仅当我们从开始节点出发，走出这个字符串，最后停在了终止节点上

### AC自动机拓展

严格来讲我们平时所使用的AC自动机都是AC自动机的弱化版(因为只配备了fail指针)，如果我们要让AC自动机真正成为一个自动机，那么我们需要强化这个自动机的功能，一般来讲我们称这个东西叫**trie图**(但是其实trie图就是一个DFA)

如何构建trie图我这里默认大家都会了……~~(不会出门左转你站膜板区，包教包会)~~

trie图的功能是，一个字符串可以被识别，当且仅当这个字符串是一堆模式串中的一个，如果这个字符串被输入之后状态不是开始状态也不是结束状态，那么这个串的一个后缀是某个模式串的前缀

做这道题的话性质1就够使了

我们开始考虑dp，当然首先我们先对所有的禁忌词汇建一个trie图，现在我们要构造一个长度为l的串使得这个串的任意一个前缀都不可以被trie图识别，然后对这个串计数

那么我们可以dp啊，设$dp_{i,j}$表示决策到了第i个字符，到达trie图上编号为j的节点的方案数

由于我们每次必须选择一个整单词，所以我们刷表枚举每一个可行的dp状态进行拓展，转移的时候枚举选哪一个单词，然后如果这个单词在跑的过程中都没有经过一个结束节点，那么我们就可以转移，否则不行，假设我们到达了p节点，那么
$dp_{i+len,p}+=dp_{i,j}$就可以了

然后我们发现这是一个$O(n^{3})$的优美算法，显然通过不了$l=10^{8}$的鬼畜数据，但是似乎有特殊性质，所有单词的长度小于2……

由于除了矩阵快速幂我们没有任何可以通过$10^{8}$的算法(根号算法和什么$O(n^{\frac{2}{3}})$估计和计数也没多大关系)，因此我们考虑构造矩阵加速dp

## 矩阵快速幂优化dp

 _这应该是一个比较传统的技巧了，熟练的话可以直接看下面的构造矩阵部分_ 
 
 
~~嗯这里默认你会矩阵乘法，不会的话去问度娘好了~~
 
我们观察一下矩阵乘法的式子(如果矩阵A乘矩阵B等于矩阵C,而且是两个方阵相乘)

## $C_{i,j}=\sum_{k=1}^{n}A_{i,k}B_{k,j}$

我们可以改写成这样的样式

```C

if(a[i][j]!=0)
{
	for(int k=1;k<=n;k++){c[i][k]+=a[i][j]*b[j][k]}
}

```

是不是非常像dp的状态转移方程?

如果我仅令矩阵的第1行有值的话，那么我们可以得到这样一段代码

```C
if(a[1][j]!=0)
{
	for(int k=1;k<=n;k++){c[1][k]+=a[1][j]*b[j][k]}
}

```

此时a,c均可以认为是1维数组，也就和平常滚动数组优化之后的dp数组无异

我们发现b矩阵其实是一个转移表格，$b_{i,j}$**是否为0代表着i状态是否不可以转移到j状态**，

所以我们发现如果处理出各个状态的转移关系并用矩阵存储，每乘一次相当于做了一次转移(也就是滚动数组中的i++)如果要转移n次就相当于计算b矩阵的n次幂再和初始条件相乘，但是i次幂是可以快速幂计算的因此复杂度被优化到了$O(k^{3}logn)$

上面说了这么多只是想说一句话，矩阵快速幂当中，转移矩阵的构造原则是：

**如果i可以转移到j那么**$b_{i,j}++$

但是我们发现这道题目十分的辣手，单词长度是2而不是1

这意味着我们没办法简单的把dp式子拿过来构造转移矩阵（如果是一个的话每次字符串长度+1因此可以直接枚举每个状态使用什么字母转移来连边，但是两个的话每次字符串长度+1和+2没法一起转移）

因此我们考虑在矩阵快速幂的经典应用——求Fibonacci数列第n项的时候，我们的一个矩阵里存了两个数，$f_{n}$和$f_{n+1}$为的就是每次可以愉快的递推

所以我们的矩阵里也可以不只放一个i啊，我们可以放两个i啊

具体来讲，假设我们现在是用转移矩阵做暴力乘法转移，那么我们被乘的那个1\*n的矩阵不再是1\*n了，而是1\*2n假设已经乘了p次，那么前半段表示$dp_{p-1}$那一行的值，后半段表示$dp_{p}$那一行的值，乘完之后我们希望前半段变成$dp_{p}$，后半段变成$dp_{p+1}$

那么我们可以像这样构造矩阵

tips：我们在处理转移关系的时候把列看成转移前，行看成转移后来连边，乘法操作相当于把这个dp数组转了90度，所以大概是这样~

![](https://cdn.luogu.com.cn/upload/pic/15924.png)


然后我们根据这个转移关系就可以矩阵快速幂求出答案啦~

这里有一个坑，结束节点的判定需要在trie图的构建中递推的计算，

$end_{p}=end_{p}||end_{failp}$，如果你不明不白的WA了多半是因为这个

~~(最后由于常数过大尴尬的T飞了~，开了unsigned long long 才过)~~

上代码~

```C
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
const int N=110;typedef unsigned long long ll;
int n;int m;int l;int siz;ll mod=1e9+7;ll tp[2*N][2*N];
struct mar//矩阵类 
{
    ll m[2*N][2*N];
    void operator *=(const mar& a)
    {
    	for(int i=1;i<=2*siz;i++){for(int j=1;j<=2*siz;j++){tp[i][j]=0;}}
        for(int i=1;i<=2*siz;i++)
        {
            for(int j=1;j<=2*siz;j++)
            {for(int k=1;k<=2*siz;k++){tp[i][j]=(tp[i][j]+m[i][k]*a.m[k][j])%mod;}}
        }
        for(int i=1;i<=2*siz;i++){for(int j=1;j<=2*siz;j++){m[i][j]=tp[i][j];}}
    }
}st,r,tr;
struct trie//trie图 
{
    int mp[N][30];int fil[N];bool ed[N];int cnt;queue <int> q;trie(){cnt=1;}
    inline int add(int p,int c){return mp[p][c]=(mp[p][c])?mp[p][c]:++cnt;}
    inline void end(int p){ed[p]=true;}
    inline void build()//建图函数 
    {
        for(int i=1;i<=26;i++)
        {if(mp[1][i]){q.push(mp[1][i]);fil[mp[1][i]]=1;}else {mp[1][i]=1;}}
        for(;!q.empty();q.pop())//bfs 
        {
            for(int p=q.front(),i=1;i<=26;i++)
            {
                if(mp[p][i])
				{
					q.push(mp[p][i]);fil[mp[p][i]]=mp[fil[p]][i];//连边 
					ed[mp[p][i]]=ed[mp[p][i]]||ed[fil[mp[p][i]]];//记得递推结束标记 
				}
                else {mp[p][i]=mp[fil[p]][i];}
            }
        }
    }
    inline void trv(int& p,int c){p=(ed[mp[p][c]])?-1:mp[p][c];}//转移函数 
}t;
char mde[N][N];int len[N];int dp[N][N];char rd[N];ll res;
int main()
{
    scanf("%d%d%d",&n,&m,&l);
    for(int i=1;i<=n;i++)
    {
        scanf("%s",mde[i]+1);//暴力计算len 
        for(len[i]=1;mde[i][len[i]+1]!='\0';len[i]++);
    }
    for(int i=1;i<=m;i++)
    {
        scanf("%s",rd+1);int p=1;
        for(int i=1;rd[i]!='\0';i++){p=t.add(p,rd[i]-'a'+1);}t.end(p);
    }t.build();siz=t.cnt;
    if(l<=100)//判下l 
    {
        dp[0][1]=1;
        for(int i=0;i<=l;i++)
        {
            for(int j=1;j<=siz;j++)
            {
                if(dp[i][j]==0){continue;}
                for(int k=1;k<=n;k++)
                {
                    if(i+len[k]>l){continue;}int p=j;//判一下转移是否合法 
                    for(int q=1;q<=len[k]&&p!=-1;q++){t.trv(p,mde[k][q]-'a'+1);}
                    if(p!=-1){dp[i+len[k]][p]=(dp[i+len[k]][p]+dp[i][j])%mod;}
                }
            }
        }
        for(int i=1;i<=siz;i++){res=(res+dp[l][i])%mod;}printf("%lld",res);
    }
    else 
    {
        st.m[1][siz+1]=1;//我们从第-1项和第0项开始dp 
        for(int i=1;i<=siz;i++){tr.m[siz+i][i]=1;}//左下方的单位矩阵 
        for(int i=1;i<=siz;i++)
        {
            for(int q=1;q<=n;q++)
            {
                if(len[q]!=1)continue;int p=i;if(t.ed[p])continue;//一步的矩阵 
                t.trv(p,mde[q][1]-'a'+1);if(p!=-1){tr.m[siz+i][siz+p]++;}
            }
        }
        for(int i=1;i<=siz;i++)
        {
            for(int q=1;q<=n;q++)
            {
                if(len[q]!=2)continue;int p=i;if(t.ed[p])continue;
                t.trv(p,mde[q][1]-'a'+1);if(p==-1)continue;//两步的矩阵 
                t.trv(p,mde[q][2]-'a'+1);if(p!=-1){tr.m[i][siz+p]++;}
            }
        }
        for(int i=1;i<=2*siz;i++){r.m[i][i]=1;}//单位元 
        for(int p=l;p;p>>=1,tr*=tr){if(p&1){r*=tr;}}st*=r;//矩阵快速幂 
		for(int i=1;i<=siz;i++){res=(res+st.m[1][siz+i])%mod;}//最后答案是在后边 
        printf("%lld",res); 
    }return 0;//拜拜程序~ 
}
```

















---

## 作者：oscar (赞：6)

北京省选题的日常就是对数据分类讨论。。。

题目瞪一两眼就能看出是道考AC自动机的题

先看前60%数据，发现没有什么特殊要求，且L比较小

直接考虑dp，对“忌讳词语”建一个AC自动机，然后搞出dp方程：

```cpp
if(tmp) dp[i+len[j]][tmp]=(dp[i][id]+dp[i+len[j]][tmp])%(1e9+7);
```
其中i为dp到第几个字符，

tmp为在AC自动机上的第id个点开始，匹配第j个基本词汇后到达的状态，若在匹配过程中遇到“忌讳词语”则不进行转移，

len[j]为第j个基本词汇的长度


最终答案为 $ \sum_{id}{dp[L][id]} mod 10^9+7 $


再考虑第7~8个点，基本词汇长度为1

发现L比较大，可以考虑矩阵快速幂

考虑自动机上每一个节点x，以及从这个节点开始匹配第i个基本词汇达到状态y

这说明从第x个状态长度增加1时可以转移到第y个状态，所以将转移矩阵的第x行第y列+1

这样就解决了


最后两个点基本词汇长度为2

我们只需要把矩阵扩大到原来的两倍，并且按之前的方法在上面标记一下长度为2的基本词汇可以转移到什么位置，然后将矩阵的左下部分设为单位矩阵，就可以解决剩下的数据了


还有一点小细节，矩阵快速幂写得不好可能会导致RE，原因玄学。。


~~下面的代码是考场代码，可能写得有点不优美，大家凑活着看吧。。~~

贴代码~~走人~~

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
struct node
{
    int id,end;
    node *next[26],*fail;
}*root,pool[30001];
int top;
string bas[55],ban[55];
int n,m,l,len[111],N;long long ans;
int dp[111][111];//[len][id]
const long long mod=1000000007ll;
struct matrix
{
    int siz;
    int mat[233][233];
#define int long long
    matrix(int x=0)
    {
        siz=N;
        for(int i=1;i<=siz;i++)
            for(int j=1;j<=siz;j++)
            {
                mat[i][j]=x*(int)(i==j);
            }
    }
    matrix operator=(const matrix& m)
    {
        siz=N;
        for(int i=1;i<=siz;i++)
        {
            for(int j=1;j<=siz;j++)
            {
                mat[i][j]=m.mat[i][j];
            }
        }
        return *this;
    }
    matrix operator=(const int x)
    {
        siz=N;
        for(int i=1;i<=siz;i++)
            for(int j=1;j<=siz;j++)
            {
                mat[i][j]=x*(int)(i==j);
            }
        return *this;
    }
    matrix operator*=(const matrix &m)
    {
        matrix tmp;
        for(int i=1;i<=siz;i++)
        {
            for(int j=1;j<=siz;j++)
            {
                long long o=0;
                for(int k=1;k<=siz;k++)
                {
                    o+=((long long)mat[i][k]*m.mat[k][j])%mod;
                }
                o%=mod;
                tmp.mat[i][j]=o;
            }
        }
        return *this=tmp;
    }
};
inline matrix fexp(matrix &x,int y)
{
    int bit=1<<30;
    matrix cur=1;
    while(bit)
    {
        cur*=cur;
        if(y&bit)cur*=x;
        bit>>=1;
    }
    return cur;
}
#undef int
void addword(string str)
{
    int len=str.length();
    node *tmp=root;
    for(int i=0;i<len;i++)
    {
        int cur=str[i]-'a';
        if(!tmp->next[cur])
        {
            tmp->next[cur]=&pool[++top];
            tmp->next[cur]->id=top;
        }
        tmp=tmp->next[cur];
    }
    tmp->end=1;
}
queue<node*> q;
void build()
{
    while(!q.empty())q.pop();
    q.push(root);
    while(!q.empty())
    {
        node *cur=q.front();q.pop();
        for(int i=0;i<26;i++)
        {
            node *nex=cur->next[i],*tmp=cur->fail;
            if(!nex)continue;
            while(tmp!=root&&!(tmp->next[i]))tmp=tmp->fail;
            if(cur==root||!(tmp->next[i]))
                nex->fail=tmp;
            else
                nex->fail=tmp->next[i];
            q.push(nex);
        }
    }
}
int match(string str,int len,int start)
{
    node *cur=&pool[start],*tmp;
    for(int i=0;i<len;i++)
    {
        int e=str[i]-'a';
        while(cur!=root&&!(cur->next[e]))cur=cur->fail;
        if(cur->next[e])
            cur=cur->next[e];
        tmp=cur;
        while(tmp!=root)
        {
            if(tmp->end)return 0;
            tmp=tmp->fail;
        }
    }
    return cur->id;
}
int main()
{
    char buf[110];
    root=&pool[++top];root->id=1;root->fail=root;
//#ifndef DDDDBUG
//    freopen("sorcery.in","r",stdin);
//    freopen("sorcery.out","w",stdout);
//#endif  //DDDDBUG
    scanf("%d%d%d",&n,&m,&l);
    for(int i=1;i<=n;i++)
    {
        scanf("%s",buf);
        bas[i]=buf;
        len[i]=bas[i].length();
    }
    for(int i=1;i<=m;i++)
    {
        scanf("%s",buf);
        ban[i]=buf;
        addword(ban[i]);
    }
    build();
    if(l<=100)
    {
        dp[0][1]=1;
        for(int i=0;i<l;i++)
        {
            for(int j=1;j<=n;j++)
            {
                if(i+len[j]<=l)
                    for(int id=1;id<=top;id++)
                    {
                        int tmp=match(bas[j],len[j],id);
                        if(tmp)
                            dp[i+len[j]][tmp]=(dp[i][id]+dp[i+len[j]][tmp])%mod;
                    }
            }
        }
        for(int id=1;id<=top;id++)
        {
            ans=(ans+dp[l][id])%mod;
        }
        printf("%lld\n",ans);
    }
    else
    {
        int notwo=1;
        N=2*top;
        matrix mult=0;
        for(int i=1;i<=top;i++)
        {
            mult.mat[i+top][i]=1;
        }
        for(int pos=1;pos<=top;pos++)
        {
            for(int i=1;i<=n;i++)
            {
                if(len[i]==1)
                {
                    int x=pos,y=match(bas[i],1,pos);
                    if(y)
                    {
                        mult.mat[x][y]++;
                        //mult.mat[x+top][y+top]++;//这里我第一次写挂了，去掉就能AC
                    }
                }
                else
                {
                    int x=pos,y=match(bas[i],2,pos);
                    if(y)
                        mult.mat[x][y+top]++;
                    notwo=0;
                }
            }
        }
        if(notwo)N>>=1;
        matrix tmp=fexp(mult,l);
        matrix orig=0;
        orig.mat[1][1]=1;
        orig*=tmp;
        for(int pos=1;pos<=top;pos++)
        {
            ans+=orig.mat[1][pos];
            ans%=mod;
        }
        printf("%lld\n",ans);
    }
    return 0;
}
```

---

## 作者：Hoks (赞：5)

## 前言
感觉，第一篇题解说的挺对的，这种题的确很套路。

这个题目就比较坑，就算会了正解也要分类讨论就很烦。

广告：[串串博客](https://www.luogu.com.cn/article/dv6dig1o)。

类似题目：

[P3502 [POI2010] CHO-Hamsters](https://www.luogu.com.cn/problem/P3502)。

[SP1676 GEN - Text Generator](https://www.luogu.com.cn/problem/SP1676)。

[CF696D Legen...](https://www.luogu.com.cn/problem/CF696D)。

（这三题个人认为难度单增，这题貌似最难？）
## 思路分析
简要题意：
> - 用给定的 $n$ 个字符串拼成长度为 $l$ 的串，且其中不出现另外给定的 $m$ 个字符串的方案数。
> - $n,m\le50,l\le10^8$。

发现是给定的 $m$ 个串不能出现即为多模匹配，考虑对于这 $m$ 个字符串建出 ACAM，给末尾打上标记，再在 fail 树建出来的时候传一下标记。

然后考虑怎么计算方案数。

由于是计数问题，且 $n,m$ 不大，直接考虑跑暴力 dp。

套路地设计 $dp_{i,j}$ 表示填了 $i$ 位，在 ACAM 上跑到状态 $j$ 时的方案数。

转移的时候考虑大力，尝试每个字符串往下转移。

具体的，对于字符串 $s_k$，尝试在 ACAM 上从 $j$ 状态开始跑，如果没有碰到过任何一个状态有标记，那么就返回最后的状态，否则就不能转移。

假设最后返回的状态为 $x$，那么转移方程式即为：
$$dp_{i+|s_k|,x}=dp_{i,j}$$

转移的时候记得累加一下和就行了。

最后的答案就是 $\sum\limits^{tot}_{i=1}dp_{l,n}$。

$tot$ 表示 ACAM 中的状态数，后面同。

理由也很简单，最后可能停留在 ACAM 上的任意一个点上。

这样就可以喜提 $60$ 了，强烈建议先去写了再看下面的篇章。

接着考虑怎么优化，套路的想到把 ACAM 上的一个状态看做一个点，把走 $1$ 步的方案数的邻接矩阵 $base$ 处理出来后 $base^l$ 表示走 $l$ 步的方案数。

那这样的话最后的答案就 $\sum\limits^{tot}_{i=1}res_{0,i},res=base^l$。

接着考虑怎么构造矩阵 $base$，发现题目中给定的 $n$ 个字符串长度可能为 $2$，考虑把矩阵长宽放大 $2$ 倍，等分为 $4$ 份原矩阵后。

其中左上角即为长度为 $1$ 的字符串转移矩阵，右上角即为长度为 $2$ 的字符串转移矩阵，左下角即为单位矩阵，而右下角为空。

这样拼接长度为 $2$ 的单词的状态就会转移到原矩阵中。

**P.S.：如果你的 ACAM 和我一样点是从 $0$ 开始编号的，记得在给矩阵赋初值的时候 $+1$，具体位置可以见代码中注释处。**

因为题目中没给矩阵快速幂的样例，所以这里提供一组数组：
```cpp
6 2 101
sy
xq
wq
ho
ks
f
syxqwq
hoks
610205411
```
## 代码
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=210,INF=0x3f3f3f3f3f3f3f3f,mod=1e9+7;
int n,m,l,le,ans,mx,len[N],dp[N][N];char s[N][N],t[N];
struct ACAM
{
	struct node{int nxt,ed,v[26];}t[N];int tot=0;
	inline void insert(char s[],int n)
	{
		int u=0;
		for(int i=1;i<=n;i++){if(!t[u].v[s[i]-'a']) t[u].v[s[i]-'a']=++tot;u=t[u].v[s[i]-'a'];}
		t[u].ed=1;
	}
	inline void build()
	{
		queue<int>q;
		for(int i=0;i<26;i++) if(t[0].v[i]) t[t[0].v[i]].nxt=0,q.push(t[0].v[i]);
		while(!q.empty())
		{
			int u=q.front();q.pop();t[u].ed|=t[t[u].nxt].ed;
			for(int i=0;i<26;i++)
				if(t[u].v[i]) t[t[u].v[i]].nxt=t[t[u].nxt].v[i],q.push(t[u].v[i]);
				else t[u].v[i]=t[t[u].nxt].v[i];
		}
	}
}ac;
struct Matrix
{
	int a[N][N];
	Matrix(){memset(a,0,sizeof a);}
};
namespace Fast_IO
{
    static char buf[1000000],*paa=buf,*pd=buf;
    #define getchar() paa==pd&&(pd=(paa=buf)+fread(buf,1,1000000,stdin),paa==pd)?EOF:*paa++
    inline int read()
    {
        int x(0),t(1);char fc(getchar());
        while(!isdigit(fc)&&fc!=-1){if(fc=='-') t=-1;fc=getchar();}
        while(isdigit(fc)&&fc!=-1) x=(x<<1)+(x<<3)+(fc^48),fc=getchar();
        if(fc==-1) exit(0);return x*t;
    }
    inline void print(int x)
    {
        if(x<0) putchar('-'),x=-x;
        if(x>9) print(x/10);
        putchar(x%10+'0');
    }
    inline bool chk(char c) { return !(c>='a'&&c<='z'); }
    inline bool ck(char c) { return c!='\n'&&c!='\r'&&c!=-1; }
    inline void rd(char s[],int&n)
    {
        s[++n]=getchar();
        while(chk(s[n])) s[n]=getchar();
        while(ck(s[n])) s[++n]=getchar();
        n--;
    }
}
using namespace Fast_IO;
Matrix mul(Matrix x,Matrix y)
{
	Matrix res;
	for(int i=0;i<=mx;i++)
		for(int j=0;j<=mx;j++)
			for(int k=0;k<=mx;k++)
			{
				res.a[i][j]+=x.a[i][k]*y.a[k][j];
				res.a[i][j]=res.a[i][j]>=mod?res.a[i][j]%mod:res.a[i][j];
			}
	return res;
}
inline Matrix ksm(Matrix x,int y)
{
	Matrix res;for(int i=0;i<=mx;i++) res.a[i][i]=1;
	while(y)
	{
		if(y&1) res=mul(res,x);
		x=mul(x,x);y>>=1;
	}
	return res;
}
int find(char s[],int n,int u)
{
	if(ac.t[u].ed) return -1;
	for(int i=1;i<=n;i++)
	{
		u=ac.t[u].v[s[i]-'a'];
		if(ac.t[u].ed) return -1;
	}return u;
}
signed main()
{
	n=read(),m=read(),l=read();
	for(int i=1;i<=n;i++) rd(s[i],len[i]);
	for(int i=1;i<=m;i++) le=0,rd(t,le),ac.insert(t,le);
	ac.build();
	if(l<=100)
	{
		dp[0][0]=1;
		for(int i=0;i<l;i++)
			for(int j=1;j<=n;j++)
				if(i+len[j]<=l)
					for(int k=0;k<=ac.tot;k++)
					{
						int t=find(s[j],len[j],k);
						if(t!=-1) dp[i+len[j]][t]=(dp[i][k]+dp[i+len[j]][t])%mod;
					}
		for(int k=0;k<=ac.tot;k++) ans=(ans+dp[l][k])%mod;
		print(ans);
	}
	else
	{
		Matrix base;mx=ac.tot;
		for(int i=0;i<=ac.tot;i++) base.a[i+ac.tot+1][i]=1;
		for(int x=0;x<=ac.tot;x++)
			for(int i=1;i<=n;i++)
				if(len[i]==1)
				{
					int y=find(s[i],1,x);
					if(y!=-1) base.a[x][y]++;
				}
				else
				{
					int y=find(s[i],2,x);
					if(y!=-1) base.a[x][y+ac.tot+1]++;mx=(ac.tot<<1)+1;
				}
		Matrix tt=ksm(base,l),t;memset(t.a,0,sizeof t.a);t.a[0][0]=1;t=mul(t,tt);
		for(int pos=0;pos<=ac.tot;pos++) ans=(ans+t.a[0][pos])%mod;
		print(ans);
	}
	return 0;
}
```

---

## 作者：Taduro (赞：4)



首先裸dp显而易见对吧，$f[i][j]$为第i为时在AC自动机第j个位置的答案，但这样你要枚举l个位置，所以只能解决前60%的数据。

观察后40%数据，发现$f[i][j]​$只能由f[i-1]或f[i-2]的答案，让矩阵乘法有了可乘之机，数据范围也在引导着我们写矩乘。在我的印象里，矩乘只能由f[i-1]、f[i]转移到f[i]、f[i+1]，对二维的dp没有什么办法。

但由于我们可以预处理出AC自动机上每个位置能否放不同的单词及放置后结尾的位置，设第i处放第j个单词后结尾的位置为$a[i][j]​$。

所以可以这样矩乘(AC自动机只有2个节点的时候为例)：

|             | $f[i][1]$ | $f[i][2]$ | $f[i+1][1]$                                                  | $f[i+1][2]$                                                  |
| ----------- | --------- | --------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| $f[i-1][1]$ | 0         | 0         | $\sum_{i}^{n} (a[1][i]=1\&\&len[i]=2)$                       | 左边意思是长度为2,且在第1个位置放置后合法且结尾在第1个位置的单词个数 |
| $f[i-1][2]$ | 0         | 0         | 同                                                           | 上                                                           |
| $f[i][1]$   | 1         | 0         | 右边意思是长度为1,且在第1个位置放置后合法且结尾在第2个位置的单词个数 | $\sum_{i}^n(a[1][i]=2\&\&len[i]=1)$                          |
| $f[i][2]$   | 0         | 1         | 同                                                           | 上                                                           |

所以如果AC自动机中有$num$个元素，那么矩阵就是$2num\times 2num$的，把矩阵分为四块。

分别为：$(1,1)$到$(num,num)$（左上角），$(1,num+1)$到$(num,2num)$（右上角），$(num+1,1)$到$(2num,num)$（左下角），$(num+1,num+1)$到$(2num,2num)$（右下角）。

左上角全是0，因为$f[i]$已经求出，左下角是单位矩阵，因为$f[i]=f[i]$，右边预处理好填进去即可。

```c++
#include<cstdio>
#include<cstring>
#include<iostream>
#define ll long long
#define mod 1000000007
using namespace std;
struct node{
	int cnt,ch[26],fail;
}t[1001];
struct Mat{
	ll d[201][201];
}h,e;
int num,tail,r[101],n;
int p,team[101],head,m;
ll f[101][101],ans;
char ch[101][101];
inline void insert(char *s){
	int u=1,l=strlen(s);
	for (int i=0; i<l; i++){
		int a=s[i]-'a';
		if (!t[u].ch[a]) t[u].ch[a]=++num;
		u=t[u].ch[a];
	}
	t[u].cnt=1;
}
inline void build(){
	head=tail=1; team[head]=1; t[1].fail=1;
	while (head<=tail){
		int x=team[head];
		// t[x].cnt|=t[t[x].fail].cnt;
		for (int i=0; i<26; i++){
			if (t[x].ch[i]){
				team[++tail]=t[x].ch[i];
				if (x==1){
					t[t[x].ch[i]].fail=1;
					continue;
				}
				t[t[x].ch[i]].fail=t[t[x].fail].ch[i];
				t[t[x].ch[i]].cnt|=t[t[t[x].fail].ch[i]].cnt;
			}
			else
				if (x==1) t[x].ch[i]=1;
				else t[x].ch[i]=t[t[x].fail].ch[i];
		}
		head++;
	}
}
inline int check(int x,int u){
	if (t[u].cnt) return -1;
	for (int i=0; i<r[x]; i++){
		int a=ch[x][i]-'a';	u=t[u].ch[a];
		if (t[u].cnt) return -1;
	}
	return u;
}
inline Mat mul(const Mat &a,const Mat &b){
	static Mat c;
	memset(c.d,0,sizeof(c.d));
	for (int k=1; k<=num*2; k++)
		for (int i=1; i<=num*2; i++){
			for (int j=1; j<=num*2; j++)
				c.d[i][j]=(c.d[i][j]%mod+a.d[i][k]*b.d[k][j]%mod)%mod;
	}
	return c;
}
inline Mat ksm(Mat a,ll b){
	Mat ret; memset(ret.d,0,sizeof(ret.d));
	for (int i=1; i<=num*2; i++) ret.d[i][i]=1;
	while (b){
		if (b&1) ret=mul(ret,a);
		a=mul(a,a); b>>=1;
	}
	return ret;
}
int main(){
	// freopen("0a.out","w",stdout);
	char s[101]; num=1;
	scanf("%d%d%d",&n,&m,&p);
	for (int i=1; i<=n; i++){
		scanf("%s",ch[i]);
		r[i]=strlen(ch[i]);
	}
	for (int i=1; i<=m; i++){
		scanf("%s",s);
		insert(s);
	}
	build();
if (p<=100){
	f[0][1]=1;
	for (int i=0; i<p; i++){
		for (int j=1; j<=num; j++){
			if (!f[i][j]) continue;
			for (int k=1; k<=n; k++){
				if (i+r[k]>p) continue;
				int v=check(k,j);
				if (v!=-1) f[i+r[k]][v]=(f[i+r[k]][v]+f[i][j])%mod;
			}
		}
	}
	for (int i=0; i<=num; i++) ans=(ans+f[p][i])%mod;
}
else{
	for (int i=1; i<=num; i++) h.d[i+num][i]=1;
	for (int i=1; i<=num; i++){
		for (int j=1; j<=n; j++){
			if (r[j]!=2) continue;
			int v=check(j,i);
			if (v!=-1) h.d[i][v+num]++;
		}
	}
	for (int i=1; i<=num; i++){
		for (int j=1; j<=n; j++){
			if (r[j]!=1) continue;
			// int v=i;
			// v=t[v].ch[ch[j][0]-'a'];
			// if (t[v].cnt) v=-1;
			int v=check(j,i);
			// printf("%d ",v);
			if (v!=-1) h.d[i+num][v+num]++;
		}
	}
	// for (int i=1; i<=num*2; i++){
	// 	for (int j=1; j<=num*2; j++)
	// 		printf("%lld ",h.d[i][j]);
	// 	puts("");
	// }
	h=ksm(h,p);
	Mat g; memset(g.d,0,sizeof(g.d));
	g.d[1][1+num]=1; g=mul(g,h);
	for(int i=1;i<=num;++i)
		ans=(ans+g.d[1][num+i])%mod;
	// for (int i=1; i<=num; i++) ans=(ans+h.d[num+1][i])%mod;
}
	printf("%lld\n",ans);
	return 0;
}
```



---

## 作者：MoYuFang (赞：3)

因为咒语中不能出现禁忌词，而判断咒语 $str$ 中是否出现禁忌词就类似于在 AC 自动机上匹配 $str$，所以容易想到要把所有禁忌词插入 AC 自动机。

对于每个禁忌词，把它在 Trie 树上对应的节点 $u$ 标记一下（$tag(u)$ 赋值为 $ \text{true}$），代表在 AC 自动机上匹配咒语时不能经过这些被标记的点。

插入完所有禁忌词后，对于每个节点 $u$，若 $tag(u)$ 等于 $ \text{true}$，那么 $u$ 在失配树上的子树上的所有点也需要标记，在失配树上用一次 dfs 就可以完成。

```cpp
void dfs(int u, bool tg){
	if (tag[u]) tg = true;
	else if (tg) tag[u] = true;
	for(int p = head[u]; p; p = nex[p]) dfs(to[p], tg);
}
```
题目涉及到计数，当然用 dp。

考虑决策和状态有哪些，决策很显然是选择哪个基本词汇 $str_j$ 添加到目前咒语的后面，所影响的状态是目前咒语在 AC 自动机上匹配所走到的节点 $u$ 和目前咒语的长度 $i$。

于是考虑这样设计状态转移方程，设 $f(u, i)$ 表示目前咒语走到的节点为 $u$且长度为 $i$ 时的方案数。

考虑如何转移，对于 $f(u, i)$，枚举每一个基本词汇 $str_j$，若 $str_j$ 能添加到目前咒语后面，则设 $v$ 为新咒语在 AC 自动机上匹配所走到的节点，那么做转移：

$f(v,i+len(j)) = f(v,i+len(j)) + f(u,i)$

```cpp
f[v][i + len[j]] += f[u][i]
```


其中 $len(j)$ 为 $str_j$ 的长度。

然后考虑如何判断咒语 $(u,i)$ 后面能否添加 $str_j$ 且如何找到新的 $v$，这一步显然可以提前预处理。

设 $tran(u,j)$ 表示咒语 $(u,i)$ 添加 $str_j$ 后所到达的新节点（注意 $tran(u,j)$ 与咒语长度 $i$ 无关）。

若 $tran(u,j) = 0$，代表不可添加 $str_j$，即若添加 $str_j$ 新咒语在 AC 自动机上匹配会走到 $tag$ 为 $\text{true}$ 的节点。

若 $tran(u,j) > 0$ 则 $v$ 就是 $tran(u,j)$。

那么转移方程变为：


当 $tran(u,j) > 0$ 和 $i+len(j) \leq L$ 时：

$f(tran(u,j),i+len(j)) = f(tran(u,j),i+len(j)) + f(u,i)$ 

```cpp
if (tran[u][j] > 0 && i + len[j] <= L)
	f[tran[u][j]][i + len[j]] += f[u][i]
```

预处理代码：

```cpp
int handle(re int u, re char *str){
	while(*str){
		u = nxt[u][(*str++)-'a'];
		if (tag[u]) return 0;
	}
	return u;
}

for(int u = 1; u <= ncnt; ++u){
	if (tag[u]) continue;
	for(int j = 1; j <= n; ++j)
      tran[u][i] = handle(u, str[j]);
}

```

代码中 ```ncnt``` 为 Trie 树的总节点数。

dp 程序：

```cpp
f[1][0] = 1;
for(int i = 0; i < L; ++i){
	for(int u = 1; u <= ncnt; ++u){
		if (!f[u][i]) continue;
		for(int j = 1; j <= n; ++j){
			if (tran[u][j] && i + len[j] <= L){
        		(f[tran[u][j]][i + len[j]] += f[u][i]) %= MOD;
			}
		}
	}
}
int ans = 0;
for(int u = 1; u <= ncnt; ++u){
	if (f[u][L]) (ans += f[u][L]) %= MOD;
}
```

到这里题目才解了一半，看看数据范围，发现还有 $40$ 分的数据是 $L \leq 10^8$ 规模的并且基本词汇长度 $\leq 2$，还要再写一个程序去搞剩下的 $40$ 分。

$L \leq 10^8$ 的 dp，矩阵快速幂优化没跑了。

这里用 $f_i$ 表示 $i$ 层的所有 $f(u,i)$。

当基本词汇长度不超过 $2$ 时，$i$ 层的 $f_i$ 只可能影响 $i+1$ 层的$f_{i+1}$ 和 $i+2$ 层的 $f_{i+2}$，$i$ 层的 $f_i$ 在转移后就不会再用到了，所以在 dp 时的每一阶段只用保存两层的 $f$，转移的过程相当于 $f_i,f_{i+1}$ $\rightarrow$ $f_{i+1},f_{i+2}$。

具体做法：

因为所有已标记的节点不会参与转移，首先先将它们排除掉，即先将所有未标记的节点 $u$ 收集起来，并用$1,2,...,icnt$ 给每个节点对应一个编号 $id(u)$，$icnt$ 为所有未标记的点的个数，并设 $ori(x)$ 表示编号 $x$ 所对应的节点。

然后用向量 $vec$，保存 $f_i$ 层与 $f_{i+1}$ 层，即：

$vec_x$ 表示$f(ori(x),i)$，$vec_{x+icnt}$ 表示 $f(ori(x),i+1)$。

然后考虑转移矩阵 $M$，大小为 $2icnt \times 2icnt$。

从 $1$ 到 $icnt$ 枚举编号 $x$，然后枚举 $tran(ori(x),j) > 0$ 的 $j$ 并设 $v$ 表示 $tran(ori(x),j)$：

若 $len(j) = 1$，则让 $M_{id(v),x}$ 加 $1$，意思是 $i$ 层的 $f(ori(x),i)$ 对 $i+1$ 层的 $f(v,i+1)$ 有贡献。

若 $len(j) = 2$，则让 $M_{id(v) + icnt,x}$ 加 $1$，意思是 $i$ 层的 $f(ori(x),i)$ 对 $i+2$ 层的 $f(v,i+2)$ 有贡献。

此外，原来 $f_i,f_{i+1}$ 阶段的 $f_{i+1}$ 要换位到 $f_{i+1},f_{i+2}$ 阶段中的 $f_{i+1}$，则让 $M_{x, x+icnt}$ 加 $1$。

代码：

```cpp
int v;
for(int u = 1; u <= ncnt; ++u) if (!tag[u]) ori[id[u] = ++icnt] = u;
matrix::n = 2*icnt;
for(int x = 1; x <= icnt; ++x){
	for(int j = 1; j <= n; ++j){
		if (!(v = tran[ori[x]][j])) continue;
		if (len[j] == 1)
        	++M.a[id[v]][x];
		else if (len[j] == 2)
        	++M.a[id[v] + icnt][x];
	}
	++M.a[x][x+icnt];
}
```

其中 ```matrix``` 是 ```struct```，```M``` 是 ```matrix``` 的实例，```M.a``` 就是转移矩阵 $M$，```M.a``` 中的值初始化为 ```0```。


搞好转移矩阵后就是矩阵快速幂了：

```cpp
for(M1 = M, --L; L; M.mul(M), L>>=1) if (L&1) M1.mul(M);
	
ll ans = 0;
for(int i = 1; i <= icnt; ++i) if (M1.a[i][1]) ans += M1.a[i][1];
```

```M1``` 是临时矩阵。

完整代码：

用了许多宏，所以下面的代码与上面的代码稍稍不同。


```cpp
#include <stdio.h>
#include <algorithm>
#include <string.h>
#include <iostream>
using namespace std;

#define re register
#define sf scanf
#define pf printf
#define nl() putchar('\n')
#define ms(x, val) memset(x, val, sizeof(x))
#define _for(i, a, b) for(re int (i) = (a); (i) < (b); ++(i))
#define _rfor(i, a, b) for(re int (i) = (a); (i) <= (b); ++(i))
#define _fev(p, u) for(re int (p) = head[(u)]; (p); (p) = nex[(p)])
#define ll long long
#define mmin(a, b) (((b) < (a)) ? (b) : (a))
#define mmax(a, b) (((b) > (a)) ? (b) : (a))
#define maxn 51
#define maxm 51
#define maxs 105
#define MOD 1000000007

char 
	str[maxm][maxs];

int n, m, L,

	//AC 自动机相关 
	ncnt = 1,
	nxt[maxs][26],
	fail[maxs],
	que[maxs],
	
	//失配树相关 
	ecnt = 0,
	head[maxs],
	to[2*maxs],
	nex[2*maxs], 
	
	//dp 用 
	len[maxm],
	tran[maxs][maxn];
	
bool tag[maxs];

void add_edge(int u, int v){ to[++ecnt] = v; nex[ecnt] = head[u]; head[u] = ecnt;}

//AC 自动机上插入禁忌词 
void ins(re char *str){
	re int u = 1, c;
	while(c = *str++){
		c -= 'a';
		if (!nxt[u][c]) nxt[u][c] = ++ncnt;
		u = nxt[u][c];
	}
	tag[u] = true;
}

//用于完成在失配树上的标记 
void dfs(int u, bool tg){
	if (tag[u]) tg = true;
	else if (tg) tag[u] = true;
	_fev(p, u) dfs(to[p], tg); //枚举 u 的子节点 to[p] 
}

//建 fail 和 dfs 
void build(){
	re int fro = 0, bac = 0, u, v;
	_for(i, 0, 26)
		if (v = nxt[1][i]) fail[que[bac++] = v] = 1, add_edge(1, v);
		else nxt[1][i] = 1;
	while(bac > fro){
		u = que[fro++];
		_for(i, 0, 26)
			if (v = nxt[u][i]) fail[que[bac++] = v] = nxt[fail[u]][i], add_edge(fail[v], v);
			else nxt[u][i] = nxt[fail[u]][i];
	}
	dfs(1, false);
}

//求 tran 用 
int handle(re int u, re char *str){
	while(*str){
		u = nxt[u][(*str++)-'a'];
		if (tag[u]) return 0;
	}
	return u;
}

//L <= 100时 
namespace S1{
	
	#define maxL 101
	#define add(x, y) if (((x) += (y)) >= MOD) (x) -= MOD;
	int	f[maxs][maxL];
	
	int main(){
		f[1][0] = 1;
		_for(i, 0, L){
			_rfor(u, 1, ncnt){
				if (!f[u][i]) continue;
				_rfor(j, 1, n){
					if (tran[u][j] && i + len[j] <= L){
						add(f[tran[u][j]][i + len[j]], f[u][i])
					}
				}
			}
		}
		re int ans = 0;
		_rfor(u, 1, ncnt){
			if (f[u][L]){ add(ans, f[u][L]); }
		}
		
		pf("%d\n", ans);
		return 0;
	}
	
	#undef add
	#undef maxL
}

// L > 100 时 
namespace S2{
	
	int icnt = 0,
		id[maxs],
		ori[maxs];	
	
	struct matrix{
		static int n;
		ll  a[2*maxs][2*maxs];
		matrix(){ ms(a, 0); }
		matrix &operator=(const matrix &t){
			_rfor(i, 1, n) _rfor(j, 1, n) a[i][j] = t.a[i][j];
			return *this;
		}
		void mul(matrix &t){
			matrix tmp;
			_rfor(i, 1, n) _rfor(k, 1, n) _rfor(j, 1, n)
				tmp.a[i][j] = (tmp.a[i][j] + a[i][k]*t.a[k][j])%MOD;
			*this = tmp;
		}
		
	} M, M1;
	
	int matrix::n = 0;
		
	int main(){
		re int v;
		_rfor(u, 1, ncnt) if (!tag[u]) ori[id[u] = ++icnt] = u;
		matrix::n = 2*icnt;
		_rfor(x, 1, icnt){
			_rfor(j, 1, n){
				if (!(v = tran[ori[x]][j])) continue;
				//if (!id[v]) pf("Wrong in id[v] == 0\n");
				if (len[j] == 1) ++M.a[id[v]][x];
				else if (len[j] == 2) ++M.a[id[v] + icnt][x];
				//else pf("Wrong in len[j] > 2\n");
			}
			++M.a[x][x+icnt];
		}
		
		for(M1 = M, --L; L; M.mul(M), L>>=1) if (L&1) M1.mul(M);
			
		re ll ans = 0;
		_rfor(i, 1, icnt) if (M1.a[i][1]) ans += M1.a[i][1];
		
		pf("%lld\n", ans % MOD);
		
		return 0;
	}
	
}

int main(){
	#ifndef ONLINE_JUDGE
	freopen("in.txt", "r", stdin);
	#endif
	
	sf("%d %d %d", &n, &m, &L);
	
	_rfor(i, 1, n){
		sf("%s", str[i]);
		len[i] = strlen(str[i]);
	}
	_rfor(i, 1, m){
		sf("%s", str[n+1]);
		ins(str[n+1]);
	}
	build();
	
	_rfor(u, 1, ncnt){
		if (tag[u]) continue;
		_rfor(j, 1, n)
			tran[u][j] = handle(u, str[j]);
	}
	
	if (L <= 100)return S1::main();
	else return S2::main();
	
	return 0;
}


```
























---

## 作者：Thomas0218 (赞：1)

## 分析
题目大意：给你一些单词，用这些单词拼出一个长为 $L$ 的大串，要求大串中不能出现一些另外给定的单词（禁忌词汇），问有多少种拼法，相同大串若由不同单词拼成算不同拼法。

观察数据，发现后 $4$ 组数据有特殊性质，而前面的数据 $L$ 不大，考虑这两类数据点分别处理。

## Subtask 1

对禁忌词汇建出 AC 自动机，然后设 $f_{i,j}$ 表示当前拼成的串 长度为 $i$，在 trie 图上节点编号为 $j$ 的节点上时的方案数。

我们暴力枚举后面拼的单词 $k$，然后检验在 trie 图上从 $j$ 号节点沿着单词 $k$ 走到达的节点 $to_{j,k}$ 是否为非法节点（禁忌词汇）。如果不是，则 $f_{i+len{k},to_{j,k}} += f_{i,j}$。

而 $to_{i,j}$ 可以预处理。总时间复杂度 $O(NL\sum{\lvert S\rvert})$。

```cpp
int DP() {
    f[0][0] = 1;
    for(int i = 0; i < l; i++) {
        for(int j = 0; j <= tot; j++) {
            for(int k = 1; k <= n; k++) {
                if(i + len[k] > l || to[j][k] == -1) continue ;
                (f[i+len[k]][to[j][k]] += f[i][j]) %= mod;
            }
        }
    }
    int ans = 0;
    for(int i = 0; i <= tot; i++) (ans += f[l][i]) %= mod;
    return ans;
}
```

`tot` 为字典树上节点数。

## Subtask 2

这一部分的基本单词长度不大于 $2$，也就是上述式子中的 $len_k\leq2$。此时我们可以使用矩阵加速递推。

我们将 $f_{i,0\sim tot}$ 和 $f_{i-1,0\sim tot}$ 全都塞到列向量里一起转移。如下图所示，矩阵大小应为 $2(tot+1)$。

![](https://cdn.luogu.com.cn/upload/image_hosting/su1mm9e6.png)

直接计算 $T^L$ 并乘上初始的列向量（$T$ 为转移矩阵）。时间复杂度 $O(tot^3\log L)$。

```cpp
int Sub2() {
    Matrix ans; ans.n = 2 * (tot + 1), ans.m = 2 * (tot + 1);
    memset(ans.a, 0, sizeof(ans.a));
    for(int i = 1; i <= tot + 1; i++) ans.a[i+tot+1][i] = 1;
    for(int i = 1; i <= tot + 1; i++) {
        for(int j = 1; j <= n; j++) {
            if(len[j] == 1) {
                int x = to[i-1][j];
                if(x != -1) ans.a[x+1][i]++;
            }
            else {
                int x = to[i-1][j];
                if(x != -1) ans.a[x+1][i+tot+1]++;
            }
        }
    }
    ans = qpow(ans, l); int ret = 0;
    for(int i = 1; i <= tot + 1; i++) (ret += ans.a[i][1]) %= mod;
    return ret;
}
```

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod = 1e9 + 7, N = 215;
struct Node { int ch[26], cnt, fail, ans, in; bool vis; } tr[N]; int tot; queue <int> q;
void Insert(string s) {
    int p = 0, n = s.size(); s = '@' + s;
    for(int i = 1; i <= n; i++) {
        int c = s[i] - 'a';
        if(!tr[p].ch[c]) tr[p].ch[c] = ++tot;
        p = tr[p].ch[c];
    }
    tr[p].vis = true;
}
void Build() {
    for(int c = 0; c < 26; c++) if(tr[0].ch[c]) q.push(tr[0].ch[c]);
    while(!q.empty()) {
        int u = q.front(); q.pop(); tr[u].vis |= tr[tr[u].fail].vis;
        for(int c = 0; c < 26; c++) {
            if(tr[u].ch[c]) {
                tr[tr[u].ch[c]].fail = tr[tr[u].fail].ch[c];
                tr[tr[tr[u].fail].ch[c]].in++;
                q.push(tr[u].ch[c]);
            }
            else tr[u].ch[c] = tr[tr[u].fail].ch[c];
        }
    }
}
string s[N]; int to[N][N], n, m, l, len[N], f[N][N];
void Init() {
    for(int i = 0; i <= tot; i++) {
        for(int j = 1; j <= n; j++) {
            int p = i;
            if(tr[i].vis) to[i][j] = -1;
            for(int k = 1; k <= len[j]; k++) {
                int c = s[j][k] - 'a'; p = tr[p].ch[c];
                if(tr[p].vis) to[i][j] = -1;
            }
            if(to[i][j] != -1) to[i][j] = p;
        }
    }
}
struct Matrix {
    int n, m, a[N][N];
    Matrix operator * (const Matrix &r) const {
        Matrix ret; ret.n = n, ret.m = r.m; memset(ret.a, 0, sizeof(ret.a));
        for(int i = 1; i <= n; i++)
            for(int j = 1; j <= r.m; j++)
                for(int k = 1; k <= m; k++)
                    (ret.a[i][j] += a[i][k] * 1ll * r.a[k][j] % mod) %= mod;
        return ret;
    }
} ;
Matrix qpow(Matrix a, int b) {
    Matrix ret; ret.n = a.n, ret.m = a.n; memset(ret.a, 0, sizeof(ret.a));
    for(int i = 1; i <= ret.n; i++) ret.a[i][i] = 1;
    while(b) {
        if(b&1) ret = ret * a;
        a = a * a; b >>= 1;
    }
    return ret;
}
int DP() {
    f[0][0] = 1;
    for(int i = 0; i < l; i++) {
        for(int j = 0; j <= tot; j++) {
            for(int k = 1; k <= n; k++) {
                if(i + len[k] > l || to[j][k] == -1) continue ;
                (f[i+len[k]][to[j][k]] += f[i][j]) %= mod;
            }
        }
    }
    int ans = 0;
    for(int i = 0; i <= tot; i++) (ans += f[l][i]) %= mod;
    return ans;
}
int Sub2() {
    Matrix ans; ans.n = 2 * (tot + 1), ans.m = 2 * (tot + 1);
    memset(ans.a, 0, sizeof(ans.a));
    for(int i = 1; i <= tot + 1; i++) ans.a[i+tot+1][i] = 1;
    for(int i = 1; i <= tot + 1; i++) {
        for(int j = 1; j <= n; j++) {
            if(len[j] == 1) {
                int x = to[i-1][j];
                if(x != -1) ans.a[x+1][i]++;
            }
            else {
                int x = to[i-1][j];
                if(x != -1) ans.a[x+1][i+tot+1]++;
            }
        }
    }
    ans = qpow(ans, l); int ret = 0;
    for(int i = 1; i <= tot + 1; i++) (ret += ans.a[i][1]) %= mod;
    return ret;
}
int main() {
    scanf("%d%d%d", &n, &m, &l);
    for(int i = 1; i <= n; i++) {
        cin >> s[i]; len[i] = s[i].size();
        s[i] = '@' + s[i];
    }
    for(int i = 1; i <= m; i++) { string t; cin >> t; Insert(t); }
    Build(); Init();
    if(l <= 100) printf("%d\n", DP());
    else printf("%d\n", Sub2());
    return 0;
}
```

---

## 作者：arrow_king (赞：1)

# 题意

给定 $n$ 个单词 $s_i$ 和 $m$ 个禁忌词语 $t_i$，求满足条件的长度为 $L$ 的字符串数量，使得它由单词连接而成且不包含任何一个禁忌词语。对 $10^9+7$ 取模。

$L\le 10^8$。

# 分析

可以发现题目分成两个部分：一部分是 $L\le100$，另一部分是 $L\le10^8$ 且单词长度最大为 $2$。

第一部分是经典的 AC 自动机上 dp。因为要保证禁忌词语不能被匹配，考虑将禁忌词语建成 AC 自动机。

接下来考虑如何 dp。设 $dp_{i,q}$ 表示当前匹配到第 $i$ 位且此时字符串在 AC 自动机上在 $q$ 状态。转移时枚举下一个单词接什么，将 $q$ 对此单词转移到状态 $q^\prime$。注意如果 $q$ 在转移过程中经过了 AC 自动机的匹配成功状态，那么这个单词是不能被接的。否则进行转移：

$$dp_{i+|s_j|,q^\prime}=dp_{i+|s_j|,q^\prime}+dp_{i,q}$$

表示从这个 dp 状态转移到下一个状态。初始时 $dp_{0,root}=1$，这里 $root$ 是 AC 自动机的根节点状态。答案显然是 $\sum dp_{L,q}$。

这样可以拿到 $60$ 分了，但是这个 dp 的时间复杂度是 $O(nL\cdot\sum|s_i|)$，肯定过不了 $L\le10^8$ 的点。

## 先试试再拿 20 分！

现在来尝试一下 $|s_i|=1$ 的点。

不妨设 AC 自动机的总状态数量为 $p$。考虑一个起始状态 $q$，其经过一个特定字符串的转移结果 $q^\prime$ 是一定的。也就是说可以在 dp 开始之前就求出每一个状态会对哪些状态造成贡献。

概括一下，就是我可以有一个方阵 $a_{q_1,q_2}$ 表示 $q_1$ 会对 $q_2$ 产生贡献。

这不是矩阵吗。

进一步，将每一次的 $dp$ 看做一个 $p$ 维的向量 $(dp_1,dp_2,\dots,dp_p)$，此时这个向量左乘这个矩阵的 $L$ 次幂即可得到最终的 $dp$ 向量。

## $|s_i|\le 2$ 怎么做？

这里注意到状态不只是一种情况了，因为跳长度为 $2$ 与长度为 $1$ 的字符串产生的贡献与对应的情况是不同的，而且此时还需要从上上次的状态上转移到这里。

那么开 $p\times p$ 的矩阵肯定不够用了。可以开 $2p\times2p$ 啊。

类似斐波那契数列的矩阵快速幂递推，构造转移矩阵 $M=\begin{bmatrix}A_{11}&A_{12}\\A_{21}&A_{22}\end{bmatrix}$，分别表示上一次或者上上次转移到这一次或者上一次的 dp 贡献情况，那么可以讨论：

- $A_{11}$ 显然全是 $0$，因为上一个状态转移到这一次的 dp 值已经求出了，无需也不可再求一遍。
- $A_{21}$ 显然为单位矩阵 $I$，因为这一部分的意义在于将上一次的贡献落下来。
- $A_{12},A_{22}$ 需要利用 AC 自动机来构造，方法很简单，只要 $q_1$ 能成功转移到 $q_2$ 就让 $a_{q_1,q_2}$ 加 $1$。

直接求出 $M$ 的 $L$ 次方即可。

一个小问题是构建 AC 自动机时要注意将所有 Fail 指向节点的 tag 全部收集上来否则会错。

# 代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
#include<string>
#include<queue>
using namespace std;
#define ll long long
#define il inline
#define mod 1000000007
il ll read() {
	ll x=0,f=1;char c=getchar();
	while(c<'0'||c>'9') {if(c=='-') {f=-1;} c=getchar();}
	while(c>='0'&&c<='9') {x=(x<<3)+(x<<1)+(c^48);c=getchar();}
	return x*f;
}
struct node {
	int ch[26],fail;
	bool tag;
};
struct Matrix {
	int n,a[201][201];
	Matrix(){}
	Matrix(int _n) {
		n=_n;
		for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) a[i][j]=0;
	}
	void operator =(Matrix A) {
		n=A.n;
		for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) a[i][j]=A.a[i][j];
	}
};
node trie[405];
int n,m,L,root,tot;
string ss[55];
char s[105];
il void insert() {
	if(!root) root=++tot;
	int u=root,l=strlen(s+1);
	for(int i=1;i<=l;i++) {
		if(!trie[u].ch[s[i]-'a']) trie[u].ch[s[i]-'a']=++tot;
		u=trie[u].ch[s[i]-'a'];
	}
	trie[u].tag=1;
}
il void build() {
	queue<int> q;
	for(int i=0;i<26;i++) {
		if(trie[root].ch[i]) {
			q.push(trie[root].ch[i]);
			trie[trie[root].ch[i]].fail=root;
		}
		else trie[root].ch[i]=root;
	}
	while(!q.empty()) {
		int u=q.front();
		q.pop();
		for(int i=0;i<26;i++) {
			if(trie[u].ch[i]) {
				trie[trie[u].ch[i]].fail=trie[trie[u].fail].ch[i];
				q.push(trie[u].ch[i]);
			}
			else trie[u].ch[i]=trie[trie[u].fail].ch[i];
			trie[trie[u].ch[i]].tag|=trie[trie[trie[u].ch[i]].fail].tag;
		}
	}
}
Matrix dp,mov,I,Ans,Ans2;
bool vis[105][105];
ll dp_tmp[105][105];
Matrix operator +(Matrix A,Matrix B) {
	Ans2.n=A.n;
	for(int i=1;i<=A.n;i++) for(int j=1;j<=A.n;j++) Ans2.a[i][j]=(A.a[i][j]+B.a[i][j])%mod;
	return Ans2;
}
Matrix operator *(Matrix A,Matrix B) {
	Ans2.n=A.n;
	for(int i=1;i<=A.n;i++) {
		for(int j=1;j<=A.n;j++) {
			Ans2.a[i][j]=0;
			for(int k=1;k<=A.n;k++) Ans2.a[i][j]=(Ans2.a[i][j]+1ll*A.a[i][k]*B.a[k][j])%mod;
		}
	}
	return Ans2;
}
il Matrix qpow(Matrix A,int b) {
	Ans=I;
	while(b) {
		if(b&1) Ans=Ans*A;
		A=A*A;
		b>>=1;
	}
	return Ans;
}
int main() {
	n=read(),m=read(),L=read();
	for(int i=1,x=0,y=0;i<=n;i++) cin>>ss[i];
	for(int i=1;i<=m;i++) {
		scanf("%s",s+1);
		insert();
	}
	build();
	if(L<=100) {
		vis[0][1]=1,dp_tmp[0][1]=1;
		for(int i=0;i<L;i++) {
			for(int j=1;j<=tot;j++) {
				if(!vis[i][j]) continue;
				for(int k=1;k<=n;k++) {
					if(i+ss[k].length()>L) continue;
					int jj=j,ok=1;
					for(int id=0;id<ss[k].length();id++) {
						jj=trie[jj].ch[ss[k][id]-'a'];
						if(trie[jj].tag) ok=0;
					}
					if(!ok) continue;
					vis[i+ss[k].length()][jj]=1;
					dp_tmp[i+ss[k].length()][jj]=(dp_tmp[i+ss[k].length()][jj]+dp_tmp[i][j])%mod;
				}
			}
		}
		ll ans=0;
		for(int i=1;i<=tot;i++) ans=(ans+dp_tmp[L][i])%mod;
		printf("%lld\n",ans);
	}
	else {
		I.n=2*tot;
		for(int i=1;i<=2*tot;i++) I.a[i][i]=1;
		for(int i=1;i<=tot;i++) {
			for(int j=1;j<=n;j++) {
				int ii=i,ok=trie[i].tag^1;
				for(int k=0;k<ss[j].length();k++) {
					ii=trie[ii].ch[ss[j][k]-'a'];
					if(trie[ii].tag) ok=0;
				}
				if(!ok) continue;
				mov.a[tot*(2-ss[j].length())+i][ii+tot]=(mov.a[tot*(2-ss[j].length())+i][ii+tot]+1)%mod;
			}
		}
		mov.n=2*tot;
		for(int i=1;i<=tot;i++) mov.a[i+tot][i]=1;
		dp.n=2*tot;
		dp.a[1][tot+1]=1;
		dp=dp*qpow(mov,L);
		ll ans=0;
		for(int i=tot+1;i<=2*tot;i++) ans=(ans+dp.a[1][i])%mod;
		printf("%lld\n",ans);
	}
	return 0;
}

```

---

## 作者：Z1qqurat (赞：1)

启发：发现一些奇怪的不好处理的数据范围时，可以观察数据特殊性质，考虑“测试点分治”；矩阵乘法优化 dp 有时不只是 $[f_i]$，如果转移牵扯到多个前项的话考虑把相关项都列到矩乘的向量里就可以丝滑转化。

本题可以看作是 AC 自动机上 dp 的模板题，主要思路就是将不可出现串放上自动机，然后记录当前串长、目前匹配到的自动机上结点等信息，暴力/矩阵乘法优化枚举转移即可。

首先如果不管 $L$ 的大小，那么很容易想出解法：把忌讳词汇放上 AC 自动机，然后在自动机上 dp，设 $f_{i,j}$ 表示目前串长为 $i$，串尾已经匹配到了自动机上点 $j$ 的位置，求方案数。直接暴力枚举下一个用的基础词汇，在 trie 图上跳这个词汇即可（注意要满足 $u$ 的 fail 树上到根链没有任何一个忌讳词汇结尾结点，这可以通过建出 fail 树再 dfs 做到），这个下一个会跳到的结点可以预处理，$g_{i,j}$ 表示从自动机上点 $i$ 开始跳单词 $j$ 之后会到自动机上哪个点，如果跳的过程中遇到任何一个不合法点，那么该 $g_{i,j}$ 无效，设为 $-1$。暴力转移 $f$ 可以做到 $\mathcal{O}(nL\sum|S_{basic}|)$。可以通过前 $60$ 分。

考虑后面的 $40$ 分，基础词汇长度 $\le2$。如果基础词汇长度恰好为 $1$，那么可以矩阵乘法简单转移。但其实 $\le2$ 也是一样的，类似于斐波那契数列的转移，我们将 $[f_i,f_i+1]$ 放在一起，写一个大的转移矩阵 $h$（提前取出有效点个数 $cnt$，减少状态数可以减小常数），将 $f_{i,1\sim cnt}\to 1\sim cnt,f_{i+1,1\sim cnt}\to cnt+1\sim 2cnt$：

1. 对于 $i\in[cnt+1,2cnt],j\in[cnt+1,2cnt]$，$h_{i,j}$ 表示填长度为 $1$ 词汇的转移。
2. 对于 $i\in[1,cnt],j\in[cnt+1,2cnt]$，$h_{i,j}$ 表示填长度为 $2$ 词汇的转移。
3. 对于 $i\in[cnt+1,2cnt],j\in[1,cnt]$，$h_{i,j}$ 表示原样保留 $f_i$，直接填一个单位矩阵即可。
4. 对于 $i\in[1,cnt],j\in[1,cnt]$，$h_{i,j}$ 本来表示填长度为 $1$ 词汇的转移，但是**为了防止与情况 $1$ 算重，直接留白**。

于是我们写出转移矩阵后，对 $[f_0,f_1]$ 赋初值：$f_{0,1}=1,f_1$ 暴力手动转移即可（这里 $f_{0,1}$ 对应的是第一个自动机上有效点，也就是 $0$）。然后转移 $l$ 次，答案在左半段。

代码不小心写长了……不过我觉得我写得比较清楚就是了。

```cpp
#include <bits/stdc++.h>
#define ALL(v) begin(v), end(v)
#define All(v, l, r) &v[l], &v[(r) + 1]
using i64 = int64_t;
using std::cin;
using std::cout;
constexpr int N = 55, M = 105;
constexpr i64 P = 1e9 + 7;

int n, m, l, tot;
std::array<std::string, N> s; //basic words
std::array<std::array<int, 26>, M> tr;
std::array<int, M> nxt;
std::array<bool, M> tag;
std::array<std::vector<int>, M> T;
std::array<std::array<int, N>, M> g;
std::array<std::array<i64, M>, M> f;

auto insert(std::string s) {
   auto n = (int)s.size(), u = 0;
   for (auto i = 0; i < n; ++i) {
      auto k = s[i] - 'a';
      if (!tr[u][k]) tr[u][k] = ++tot;
      u = tr[u][k];
   }
   tag[u] = 1; return ;
}

auto build_fail() {
   std::queue<int> q;
   for (auto i = 0; i < 26; ++i)
      if (tr[0][i]) q.emplace(tr[0][i]);
   
   while (!q.empty()) {
      auto u = q.front(); q.pop();
      for (auto i = 0; i < 26; ++i) {
         auto v = tr[u][i];
         if (v) nxt[v] = tr[nxt[u]][i], q.emplace(v);
         else tr[u][i] = tr[nxt[u]][i];
      }
   }

   for (auto i = 1; i <= tot; ++i)
      T[nxt[i]].emplace_back(i);
   return ;
}

auto dfs(int u) -> void {
   for (auto v : T[u])
      tag[v] |= tag[u], dfs(v);
   return ;
}

auto init_trans() {
   for (auto i = 0; i <= tot; ++i) {
      if (tag[i]) continue;
      for (auto j = 1; j <= n; ++j) {
         auto len = (int)s[j].size(), u = i;
         for (auto k = 0; k < len; ++k) {
         	if (tag[u]) {
         		u = -1; break;
				}
            u = tr[u][s[j][k] - 'a'];
         }
         if (u == -1) g[i][j] = -1;
         else g[i][j] = (tag[u] ? -1 : u);
      }
   }
   return ;
}

auto solve_small() { //l<=100
   f[0][0] = 1;
   for (auto i = 0; i < l; ++i) { //current length
      for (auto j = 0; j <= tot; ++j) { //current node on ACAM
         if (tag[j] || !f[i][j]) continue;
         for (auto k = 1; k <= n; ++k) { //next basic word
            auto v = g[j][k];
            if (v > -1 && !tag[v] && i + s[k].size() <= l)
               (f[i + s[k].size()][v] += f[i][j]) %= P;
         }
      }
   }
   auto ans = (i64)0;
   for (auto i = 0; i <= tot; ++i)
		if (!tag[i]) ans = (ans + f[l][i]) % P;
   cout << ans << "\n";
   return ;
}

int cnt;
std::array<int, M> id, pt;

struct Matrix {
   std::array<std::array<i64, M << 1>, M << 1> a;
   auto init() {
      for (auto &i : a) std::fill(ALL(i), 0);
   }
   auto init_I() {
      init();
      for (auto i = 1; i <= (cnt << 1); ++i) a[i][i] = 1;
   }
   Matrix operator* (const Matrix &y) const {
      Matrix z; z.init();
      for (auto k = 1; k <= (cnt << 1); ++k) {
         for (auto i = 1; i <= (cnt << 1); ++i) {
            for (auto j = 1; j <= (cnt << 1); ++j)
               (z.a[i][j] += a[i][k] * y.a[k][j] % P) %= P;
         }
      }
      return z;
   }
};
Matrix operator^ (Matrix x, int y) {
   Matrix ret; ret.init_I();
   for (; y; x = x * x, y >>= 1)
      if (y & 1) ret = ret * x;
   return ret;
}
Matrix h;

auto init_h() {
	std::fill(ALL(id), -1);
   for (auto i = 0; i <= tot; ++i)
      if (!tag[i]) pt[++cnt] = i, id[i] = cnt;
   for (auto i = 1; i <= cnt; ++i) {
      for (auto j = 1; j <= n; ++j) {
         auto k = g[pt[i]][j];
         if (k < 0) continue;
         if (s[j].size() == 1) h.a[i + cnt][id[k] + cnt]++;
         else h.a[i][id[k] + cnt]++;
      }
   }
   for (auto i = 1; i <= cnt; ++i) h.a[i + cnt][i] = 1;
   return ;
}

std::array<i64, M << 1> dp;

auto operator* (std::array<i64, M << 1> x, Matrix y) {
   std::array<i64, M << 1> z; std::fill(ALL(z), 0);
   for (auto i = 1; i <= (cnt << 1); ++i) { //column
      for (auto j = 1; j <= (cnt << 1); ++j) { //row
         (z[i] += x[j] * y.a[j][i] % P) % P;
      }
   }
   return z;
}

auto solve_big() {
   init_h();
   dp[1] = 1;
   for (auto i = 1; i <= n; ++i) {
      if (s[i].size() == 2) continue;
      auto u = tr[0][s[i][0] - 'a'];
      if (!tag[u]) dp[id[u] + cnt]++;
   }
   h = h ^ l, dp = dp * h;
   auto ans = (i64)0;
   for (auto i = 1; i <= cnt; ++i) ans = (ans + dp[i]) % P;
   cout << ans << "\n";
   return ;
}

auto main() -> int {
   std::ios::sync_with_stdio(false);
   cin.tie(nullptr), cout.tie(nullptr);

   cin >> n >> m >> l;
   for (auto i = 1; i <= n; ++i) cin >> s[i];
   for (auto i = 1; i <= m; ++i) {
      std::string t; cin >> t, insert(t);
   }
   build_fail(), dfs(0), init_trans();
   if (l <= 100) solve_small();
   else solve_big();
   return 0;
}

---

## 作者：Fengxiang008 (赞：1)

### 算法类型
**矩阵乘法 + AC 自动机**

### 具体分析：
首先是前 60 分，就是一个 `AC` 自动机上的套路 `dp`，设 $dp[i][j]$ 表示匹配出的长度为 $i$ 在自动机上位置为 $j$ 的方案数，转移的话就枚举下一个单词选择哪个放到自动机上一波匹配就好了

后面 40 分强行变成了另外一道题，$L$ 变成了  $10^8$，一看就是矩乘的复杂度了

但是单词的长度都非常小，于是转移 $dp_{i,j}$ 的时候只需要从 $dp_{i-1,x} $ 和 $dp_{i-2,x}$ 里转移，发现这非常像斐波那契的转移，于是提前在 `AC` 机上的每个位置都处理一下对应的转移之后矩乘就好了。

### 代码：      
```cpp
#include<bits/stdc++.h>
#define re register
#define LL long long
#define maxn 205
const LL mod=1e9+7;
char S[maxn];
int fail[maxn],flag[maxn],son[maxn][26];
char T[55][maxn],len[maxn];
int n,m,L,cnt;
inline void ins()
{
	scanf("%s",S+1);
	int len=strlen(S+1),now=0;
	for(re int i=1;i<=len;i++) 
	{if(!son[now][S[i]-'a']) son[now][S[i]-'a']=++cnt;now=son[now][S[i]-'a'];}
	flag[now]=1;
}
inline void Build()
{
	std::queue<int> q;
	for(re int i=0;i<26;i++) if(son[0][i]) q.push(son[0][i]);
	while(!q.empty())
	{
		int k=q.front();q.pop();
		flag[k]|=flag[fail[k]];
		for(re int i=0;i<26;i++)
		if(son[k][i]) fail[son[k][i]]=son[fail[k]][i],q.push(son[k][i]);
			else son[k][i]=son[fail[k]][i];
	}
}
namespace solve1
{
	int dp[maxn][maxn];
	inline int query(int x,int y)
	{
		int now=x;
		for(re int i=1;i<=len[y];i++)
		{
			if(flag[now]) return -1;
			now=son[now][T[y][i]-'a'];
		}
		if(flag[now]) return -1;
		return now;
	}
	inline void work()
	{
		dp[0][0]=1;
		for(re int i=0;i<L;i++)
			for(re int j=0;j<=cnt;j++)
				for(re int k=1;k<=n;k++)
				{
					if(i+len[k]>L) continue;
					if(!dp[i][j]) continue;
					int v=query(j,k);
					if(v==-1) continue;
					dp[i+len[k]][v]=(dp[i+len[k]][v]+dp[i][j])%mod;
				}
		int ans=0;
		for(re int i=0;i<=cnt;i++) ans=(ans+dp[L][i])%mod;
		printf("%d\n",ans);
	}
}
namespace solve2
{
	LL ans[maxn][maxn],a[maxn][maxn];
	int M;
	inline void did_a()
	{
		LL mid[maxn][maxn];
		for(re int i=0;i<=M;i++)
			for(re int j=0;j<=M;j++) mid[i][j]=a[i][j],a[i][j]=0;
		for(re int k=0;k<=M;k++)
			for(re int i=0;i<=M;i++)
				for(re int j=0;j<=M;j++)
					{a[i][j]+=((mid[i][k]*mid[k][j])%mod);if(a[i][j]>mod) a[i][j]%=mod;}
	}
	inline void did_ans()
	{
		LL mid[maxn][maxn];
		for(re int i=0;i<=M;i++)
			for(re int j=0;j<=M;j++) mid[i][j]=ans[i][j],ans[i][j]=0;
		for(re int k=0;k<=M;k++)
			for(re int i=0;i<=M;i++)
				for(re int j=0;j<=M;j++)
					{ans[i][j]+=((a[i][k]*mid[k][j])%mod);if(ans[i][j]>mod) ans[i][j]%=mod;}
	}
	inline void quick(int b){while(b) {if(b&1) did_ans();b>>=1;did_a();}}
	inline void work()
	{
		M=cnt+cnt+1;
		for(re int i=0;i<=cnt;i++)
		{
			if(flag[i]) continue;
			for(re int j=1;j<=n;j++)
			if(len[j]==1)
			{
				int v=son[i][T[j][1]-'a'];
				if(!flag[v]) a[v+cnt+1][i+cnt+1]++;
			}
			else if(len[j]==2)
			{
				int v=son[i][T[j][1]-'a'];
                int vv=son[v][T[j][2]-'a'];
                if(flag[v]||flag[vv]) continue;
                a[vv+cnt+1][i]++;
			}
		}
		for(re int j=cnt+1;j<=M;j++) a[j-cnt-1][j]++;
		for(re int i=0;i<=M;i++) ans[i][i]=1;
		quick(L);
		LL Ans=0;
		for(re int i=cnt+1;i<=M;i++) Ans=(ans[i][cnt+1]+Ans)%mod;
		printf("%lld\n",Ans);
	}
}
int main()
{
	scanf("%d%d%d",&n,&m,&L);
	for(re int i=1;i<=n;i++) scanf("%s",T[i]+1),len[i]=strlen(T[i]+1);
	for(re int i=1;i<=m;i++) ins();
	Build();
	if(L<=100) solve1::work();
		else solve2::work();
	return 0;
}
```


---

## 作者：KokiNiwa (赞：1)

# [BJOI 2017]魔法咒语

感觉写这题的时候快要崩了。。。最烦这种$dp$上套了一个矩阵的题目了，因为构造那个矩阵总觉得特别玄学，要构造好久，总是在两种写法之间徘徊，徘徊烦了就会不自觉地想别的。

但其实写多了还蛮套路的。

[题目链接](https://www.luogu.com.cn/problem/P3715)

## 题目叙述

现在给你$n$个基本词汇与$m$个不能出现的词汇，让你连成一句话，问一共有多少句这样的话。数据范围要特殊关注一下。

## 题解

首先分为两个部分

### sub task 1

简单的$ac$自动机上的$dp$问题。状态大概为$dp_{i,j}$为前$i$位，匹配到了$j$这个点，没匹配到任何一个单词的情况有多少种。由于单词是每次加一整串的，所以转移让前$i$位变为前$i+len$位。

### sub task 2

考虑到基础单词的长度最多为$2$，所以每次转移$dp_{i,j}$顶多转移到$dp_{i+2,j}$。看到后面的$L$范围那么大，所以矩阵快速幂。但由于一次可以添加一个字符，也可以添加两个，所以矩阵里要记录$dp_{i,j}$和$dp_{i+1.j}$两个东西的值。然后转一下即可。

## 代码

[code](https://www.luogu.com.cn/paste/ikd6ttjj)

莫名的长。

## 知识点
+ 注意观察部分分，可能并不存在一个算法能解决这个题（意思是两个算法拼在一起。。。分情况用）。

---

## 作者：船酱魔王 (赞：0)

# P3715 [BJOI2017] 魔法咒语 题解

## 题意回顾

对于长度为 $ L $ 的一句话，必须由 $ N $ 个构成词中的一些拼接而成（构成词**可以多次**出现），如果**拼接组成方式**不同但是内容一样算作不同。

有 $ M $ 个敏感词，如果敏感词在话中作为连续子段出现则这句话不合法。注意构成词之间不存在分隔，可以跨构成词触发敏感词。

求出合法话的数量对 $ 10^9+7 $ 取模。

$ 1 \le N,M \le 50 $，$ 1 \le L \le 10^8 $，构成词和敏感词总长度均不超过 $ 100 $，**对于 $ L>100 $ 的数据构成词长度不超过 $ 2 $。**

## 分析

模式串匹配的文本串计数问题考虑动态规划。

记 $ dp_{i,j} $ 表示由若干个**完整的构成词**组成的话长度为 $ i $，结尾匹配到 $ j $ 位置，且之前没有触发过敏感词的方案总数。

因为敏感词可能有多个所以我们对于敏感词建立 AC 自动机，标记所有敏感词结尾结点及 `fail` 指针直接或间接指向敏感词结尾结点的结点，处理出 $ i $ 位置后接上字符串 $ j $ 的新匹配位置 $ mat_{i,j} $，注意如果过程中触发敏感词及时判定。

考虑朴素 DP 转移，$ len_i $ 为 $ i $ 构成词长度，则有 $ dp_{i+len_i,mat_{j,k}}\leftarrow dp_{i,j} $，注意转移时判定 $ i+len_i<l $ 避免数组访问越界和状态合法性，可以拿到 $ 60 $ 分的好成绩。

$ l>100 $ 时构成串都很短，发现 $ dp_i $ 只和 $ dp_{i-1} $ 及 $ dp_{i-2} $ 有关，把 $ dp_i $ 与 $ dp_{i-1} $ 合成一个状态，状态转移形式可以矩阵快速幂优化，注意矩阵乘法常数（这里常数优化的小技巧是用 `long long` 存储，结尾再取模）即可拿到另外 $ 40 $ 分，本题通过。

## AC 代码

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <queue>
using namespace std;
const int N = 105;
const int mod = 1e9 + 7;
int n, m, l;
string s[N];
string mgc[N];
int tot = 0;
int nxt[N][26];
int fw[N];
queue<int> que;
int mat[N][N];
int ed[N];
int dp[N][N];
struct matrix {
    int num[N * 2][N * 2];
} zero;
matrix operator*(matrix p1, matrix p2) {
    matrix p3 = zero;
    for(int i = 1; i <= 200; i++) {
        for(int j = 1; j <= 200; j++) {
            long long tx = 0;
            for(int k = 1; k <= 200; k++) tx += (long long)p1.num[i][k] * p2.num[k][j] % mod;
            p3.num[i][j] = tx % mod;
        }
    }
    return p3;
}
int main() {
    cin >> n >> m >> l;
    for(int i = 1; i <= n; i++) cin >> s[i];
    for(int i = 1; i <= m; i++) {
        cin >> mgc[i];
        int now = 0;
        for(int j = 0; j < mgc[i].size(); j++) {
            if(nxt[now][mgc[i][j] - 'a'] == 0) nxt[now][mgc[i][j] - 'a'] = ++tot;
            now = nxt[now][mgc[i][j] - 'a'];
        }
        ed[now]++;
    }
    for(int i = 0; i < 26; i++) {
        if(nxt[0][i] != 0) que.push(nxt[0][i]);
    }
    int u;
    while(!que.empty()) {
        u = que.front();
        que.pop();
        for(int i = 0; i < 26; i++) {
            if(nxt[u][i] == 0) {
                nxt[u][i] = nxt[fw[u]][i];
            } else {
                fw[nxt[u][i]] = nxt[fw[u]][i];
                que.push(nxt[u][i]);
            }
        }
    }
    for(int i = 0; i < tot; i++) {
        ed[i] += ed[fw[i]];
    }
    for(int i = 0; i < tot; i++) {
        if(ed[i]) continue;
        for(int j = 1; j <= n; j++) {
            int now = i;
            for(int k = 0; k < s[j].size(); k++) {
                now = nxt[now][s[j][k] - 'a'];
                if(ed[now]) break;
            }
            mat[i][j] = now;
        }
    }
    if(l <= 100) {
        dp[0][0] = 1;
        for(int i = 0; i < l; i++) {
            for(int j = 0; j < tot; j++) {
                if(ed[j]) continue;
                for(int k = 1; k <= n; k++) {
                    if(i + s[k].size() > l) continue;
                    if(ed[mat[j][k]]) continue;
                    dp[i + s[k].size()][mat[j][k]] = (dp[i][j] + dp[i + s[k].size()][mat[j][k]]) % mod;
                }
            }
        }
        int ans = 0;
        for(int i = 0; i < tot; i++) {
            if(!ed[i]) ans = (ans + dp[l][i]) % mod;
        }
        cout << ans << endl;
        return 0;
    }
    matrix zy = zero;
    for(int i = 0; i < tot; i++) {
        if(ed[i]) continue;
        for(int k = 1; k <= n; k++) {
            if(ed[mat[i][k]]) continue;
            if(s[k].size() == 1) zy.num[i + 1][mat[i][k] + 1]++;
            else zy.num[i + 101][mat[i][k] + 1]++;
        }
    }
    for(int i = 0; i < tot; i++) {
        if(ed[i]) continue;
        zy.num[i + 1][i + 101]++;
    }
    matrix ans = zero;
    ans.num[1][1] = 1;
    while(l) {
        if(l & 1) ans = ans * zy;
        zy = zy * zy, l >>= 1;
    }
    int sum = 0;
    for(int i = 0; i < tot; i++) {
        if(!ed[i]) sum = (sum + ans.num[1][i + 1]) % mod;
    }
    cout << sum << endl;
    return 0;
}
```

---

## 作者：Imiya (赞：0)

先考虑 $L\le100$。建出所有忌讳词汇构成的 AC 自动机，考虑自动机上 dp。

设 $n$ 表示 AC 自动机中共有 $n+1$ 个点，编号从 $0$ 到 $n$。$f_{i,j}$ 表示决策到第 $i$ 个字符，到达 AC 自动机上的 $j$ 号点的方案数。

先预处理 $g(u,v,i)$ 表示第 $i$ 个基本词汇 $s_i$ 是否可以在 AC 自动机上从 $u$ 转移到 $v$ 转移且中途不经过非法状态。

$$f_{l,v}=\sum\limits_{u=0}^n\sum\limits_{i=1}^Ng(u,v,i)\times f_{l-\vert s_i\vert,u}$$

解决了前 6 个点。

然后考虑基本词汇长度不超过 $1$ 的情况，可以将去掉 $g$ 的第三维令 $g(u,v)$ 表示 AC 自动机上存在几个长度为 $1$ 的基本词汇可以在 AC 自动机上从 $u$ 转移到 $v$ 转移且中途不经过非法状态

$$f_{l,v}=\sum\limits_{u=0}^ng(u,v)\times f_{l-1,u}$$

但是 $L\le10^8$，考虑矩阵快速幂优化 dp。

$$
G=
\begin{bmatrix}
g(0,0)&g(0,1)&g(0,2)&\dots&g(0,n)\\
g(1,0)&g(1,1)&g(1,2)&\dots&g(1,n)\\
g(2,0)&g(2,1)&g(2,2)&\dots&g(2,n)\\
\vdots\\
g(n,0)&g(n,1)&g(n,2)&\dots&g(n,n)
\end{bmatrix}
$$
$$
\begin{bmatrix}
f_{i,0}&f_{i,1}&f_{i,2}&\dots&f_{i,n}
\end{bmatrix}
\times G
=
\begin{bmatrix}
f_{i+1,0}&f_{i+1,1}&f_{i+1,2}&\dots&f_{i+1,n}
\end{bmatrix}
$$
$$
\begin{bmatrix}
f_{0,0}&f_{0,1}&f_{0,2}&\dots&f_{0,n}
\end{bmatrix}
\times G^L
=
\begin{bmatrix}
f_{L,0}&f_{L,1}&f_{L,2}&\dots&f_{L,n}
\end{bmatrix}
$$

解决了第 7、8 点。

还剩下基本词汇不超过 $2$ 的情况。考虑将刚刚的 $g(u,v)$ 改写为 $g_1(u,v)$，再设一个 $g_2(u,v)$ 表示存在几个长度为 $2$ 的基本词汇可以从 $u$ 转移到 $v$ 转移且中途不经过非法状态。

$$f_{l,v}=\sum\limits_{u=0}^ng_1(u,v)\times f_{l-1,u}+g_2(u,v)\times f_{l-2,u}$$

同样矩阵快速幂优化。
$$
G=\begin{bmatrix}
g_1(0,0)&g_1(0,1)&\dots&g_1(0,n)&&1&0&\dots&0\\
g_1(1,0)&g_1(1,1)&\dots&g_1(1,n)&&0&1&\dots&0\\
\vdots&&&&&\vdots\\
g_1(n,0)&g_1(n,1)&\dots&g_1(n,n)&&0&0&\dots&1\\\\
g_2(0,0)&g_2(0,1)&\dots&g_2(0,n)&&0&0&\dots&0\\
g_2(1,0)&g_2(1,1)&\dots&g_2(1,n)&&0&0&\dots&0\\
\vdots&&&&&\vdots\\
g_2(n,0)&g_2(n,1)&\dots&g_2(n,n)&&0&0&\dots&0\\
\end{bmatrix}
$$
$$
\begin{bmatrix}
f_{i,0}&f_{i,1}&\dots&f_{i,n}&f_{i-1,0}&f_{i-1,1}&\dots&f_{i-1,n}
\end{bmatrix}
\times G
$$
$$
=
\begin{bmatrix}
f_{i+1,0}&f_{i+1,1}&\dots&f_{i+1,n}&f_{i,0}&f_{i,1}&\dots&f_{i,n}
\end{bmatrix}
$$

code
```cpp
#include<iostream>
#include<string>
#include<cstring>
using namespace std;
#define int long long
const int N=60,V=110,U=26,P=1e9+7;
inline int id(char c){return c-'a';}
int trie[V][U],ver,tag[V];
inline void insert(const string&s){
    int nd=0,len=s.size();
    for(int i=0;i<len;i++){
        if(!trie[nd][id(s[i])])trie[nd][id(s[i])]=++ver;
        nd=trie[nd][id(s[i])];
    }
    tag[nd]=1;
}
int q[V],front,back;
int fail[V];
void build(){
    for(int i=0;i<U;i++)if(trie[0][i])q[++back]=trie[0][i];
    while(front<back){
        int nd=q[++front];
        tag[nd]|=tag[fail[nd]];
        for(int i=0;i<U;i++){
            if(trie[nd][i])fail[trie[nd][i]]=trie[fail[nd]][i],q[++back]=trie[nd][i];
            else trie[nd][i]=trie[fail[nd]][i];
        }
    }
}
namespace p1{
    const int L=110;
    int g[V][V][N],f[L][V];
    int calc(int l,int v,string s[],int n){
        f[0][0]=1;
        for(int i=1;i<=l;i++){
            for(int j=0;j<=v;j++){
                for(int k=0;k<=v;k++){
                    for(int t=1;t<=n;t++){
                        if(i<s[t].size())continue;
                        f[i][j]=(f[i][j]+f[i-s[t].size()][k]*g[k][j][t])%P;
                    }
                }
            }
        }
        int ans=0;
        for(int i=0;i<=v;i++)ans=(ans+f[l][i])%P;
        return ans;
    }
}
namespace p2{
    struct matrix{
        int a[V<<1][V<<1];
        int n,m;
        inline matrix(int n_=0,int m_=0,bool unit=false){
            n=n_,m=m_;
            memset(a,0,sizeof(a));
            if(unit)for(int i=0;i<=n;i++)a[i][i]=1;
        }
        inline matrix operator*(const matrix&b)const&{
            matrix c(n,b.m);
            for(int i=0;i<=n;i++){
                for(int j=0;j<=b.m;j++){
                    for(int k=0;k<=m;k++)c.a[i][j]=(c.a[i][j]+a[i][k]*b.a[k][j]%P)%P;
                }
            }
            return c;
        }
    };
    matrix fpow(matrix a,int b){
        matrix c(a.n,a.m,true);
        for(;b;b>>=1,a=a*a)if(b&1)c=c*a;
        return c;
    }
    int g1[V][V],g2[V][V];
    int calc(int l,int v){
        matrix G(v<<1|1,v<<1|1);
        for(int i=0;i<=v;i++){
            for(int j=0;j<=v;j++){
                G.a[i][j]=g1[i][j];
                G.a[i+v+1][j]=g2[i][j];
            }
            G.a[i][i+v+1]=1;
        }
        matrix A(0,2*v+1);
        for(int i=0;i<=v;i++)A.a[0][i]=g1[0][i];
        A.a[0][v+1]=1;
        matrix B=A*fpow(G,l-1);
        int ans=0;
        for(int i=0;i<=v;i++)ans=(ans+B.a[0][i])%P;
        return ans;
    }
}
int n,m,L;
string s1[N],s2[N];
void init(){
    cin>>n>>m>>L;
    for(int i=1;i<=n;i++)cin>>s1[i];
    for(int i=1;i<=m;i++)cin>>s2[i],insert(s2[i]);
    build();
}
bool check(int u,int v,const string&s){
    int len=s.size();
    if(tag[u])return false; 
    for(int i=0;i<len;i++){
        u=trie[u][id(s[i])];
        if(tag[u])return false;
    }
    return u==v;
}
signed main(){
    // freopen("read.in","r",stdin);
    init();
    if(L<=100){
        for(int i=0;i<=ver;i++){
            for(int j=0;j<=ver;j++){
                for(int k=1;k<=n;k++){
                    p1::g[i][j][k]=check(i,j,s1[k]);
                }
            }
        }
        cout<<p1::calc(L,ver,s1,n);
    }
    else{
        for(int i=0;i<=ver;i++){
            for(int j=0;j<=ver;j++){
                for(int k=1;k<=n;k++){
                    if(s1[k].size()==1)p2::g1[i][j]+=check(i,j,s1[k]);
                    else p2::g2[i][j]+=check(i,j,s1[k]);
                }
            }
        }
        cout<<p2::calc(L,ver);
    }
    return 0;
}
```

---


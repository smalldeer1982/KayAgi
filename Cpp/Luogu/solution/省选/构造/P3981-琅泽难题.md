# 琅泽难题

## 题目背景

```cpp
万事万物总是那么巧妙，数学海洋令我无限徜徉，在那一瞬，我又发现了美。
```
真程海洋的伟大数学家**琅泽**响应真程海洋殿主的号召，参与了这次出题。

根据他的思考与推算，出了一道有意思的题目，以下是他给你们的话：


## 题目描述

这个题目的灵感来自于这组数据：

 ![](https://cdn.luogu.com.cn/upload/pic/9088.png) 

这组数据采用**描述法**的规律，在第$ n+1 $层从左到右描述第$ n $层的数据，描述规律如下：从左到右描述第$ n $层的数据，从第一个数据开始，每当碰到连续的$ a_1 $个$ b_1 $时，将$ a_1\,b_1 $作为新的两个数据写在第$ n+1 $层的最后（这个最后是接在最后一个数据后面，如果第$ n+1 $层本来没有数据，则此时的最后即为开头），**紧接着**再描述接下来连续的$ a_2 $个$ b_2 $（$ b_1\neq b_2 $），往后亦如此，直到所有数据被描述完毕，则此时第$ n+1 $层也构造完毕，此处的$ n $为正整数。

现在，我有一个新的想法了，给定一个**初始数据** $ Q $（初始数据在第一层，且第一层仅有一个数据——初始数据$ Q $），按照**类似于**上述规律的规律（描述法）构造一组数据，称为“琅泽阵”。我定义的规律为：在奇数层遵循$ A $规律，在偶数层遵循$ B $规律。具体表现如下图：

 ![](https://cdn.luogu.com.cn/upload/pic/9091.png) 

上图是当初始数据为$ 1 $时呈现的部分琅泽阵，至于是什么规律，就需要你去探究。

### 但是！！！

这还不是最终目的，我要考的是，在第$ i $层中，有多少个$ x $（我们定义初始数据所在的层数为第一层）？


## 说明/提示

### 样例一说明：

构建出来的琅泽阵（一小部分）为：

 ![](https://cdn.luogu.com.cn/upload/pic/10486.png) 

故第$ 2 $层中$ 2 $的数量为$ 1 $。

### 注意：

所有数据均为整数；

如果你毫无思路，你可以选择解决一些子问题；

以下是各个测试点中，输入数据的范围大小：

![](https://cdn.luogu.com.cn/upload/pic/10333.png)


## 样例 #1

### 输入

```
2 2 2```

### 输出

```
1```

## 样例 #2

### 输入

```
2 14 5```

### 输出

```
12```

# 题解

## 作者：the_Death (赞：3)

###### 这题是真的好，我是真的自己做不出来QAQ
--------------------

## P3981 琅泽难题

[Luogu](https://www.luogu.org/problem/P3981)

[或许会有更好的阅读体验](https://www.cnblogs.com/fallen-down/p/11794937.html)

#### 这在官方题解基础上，加上自己的一些理解所写，原题解见此题解最下方链接
------------
### 题目解答

首先，由图可知，$A$规律是对上一层每一个数字进行一次描述，$B$是对上一层数字所构成的连续区间进行描述。

- 例如，若有一层为(不一定合法)：1113115
- 若按照$A$规律对其进行描述，则就是：11111113111115->1个1(x3遍)+1个3+1个1(x2遍)+1个5。
- 如果按照$B$规律对其进行描述则为：31132115->3个1+1个3+2个1+1个5

然后寻找第$I$层中由几个$X$的规律了

首先我们假设初始数据为$a$，以此来构造矩阵：(为方便记录，每一行最左侧为层数)

1. a
2. 1 1
3. 1 1 1 a
4. 3 1 1 a
5. 1 3 1 1 1 1 1 a
6. 1 1 1 3 5 1 1 a
7. 1 1 1 1 1 1 1 3 1 5 1 1 1 1 1 a
8. 7 1 1 3 1 1 1 5 5 1 1 a
9. 1 7 1 1 1 1 1 1 1 3 1 1 1 1 1 1 1 5 1 5 1 1 1 1 1 a
10. 1 1 1 7 5 1 1 3 7 1 1 5 1 1 1 5 5 1 1 a

此时，我们不难发现，当$a$达到一个阈值的时候，不会在同一层出现第二个$a$。我们此时要尝试找到这个阈值。

由上图的数据可猜测，这个阈值就是$7$。然后我们来证明一下

在证明阈值为$7$之前，我们先阐述两条结论：
- 在$A$规律下，只会有$1$ $X$这样的数据，正确性显然
- 在$B$规律下，会有$1$ $X$， $X$ $Y$这样的数据，正确性显然

请大家牢记这两条正确性显然(尤其是第一条)的结论，这对于我们之后的证明有大用。然后我们开始证明

1. 这个琅琊阵中不会出现偶数(若$a$为偶数，则就只会出现一个偶数，即为$a$)
   - 考虑偶数出现的原因。
   - 首先由于琅琊阵的规律我们可知，只有在$B$规律下才可以出现偶数。那么我们假设在$A$规律下的那一层数据为：$a$个连续的$b$ 和 $n$个连续的$k$ 和 $c$个连续的$d$。我们要保证$a{\neq}k$且$k{\neq}c$。只有样才可以保证$B$在描述的时候，不会包含多余的数字。
     - 由于结论$1$，我们可知，$a=c=1$
     - 如果$k{\neq}1$的话，由于结论$1$，如果这个数字不是$1$的话，必然无法保证两两一致。所以$k=1$。
     - 如果$k=1$的话，保证$c$是偶数。那么后面的那个不同的数字为了不同，必然以$1$ $d$的形式出现，此时$c$就不是偶数
     - 如果$c$不是偶数，由以上观点可知$k=1$，且$1$的出现都是成双成对的，所以$c$必须是偶数
   - 由以上证明可知琅泽阵之中不存在偶数
2. 琅泽阵之中不存在大于$7$的数字(除了$a$本身)
   - 假设它之中出现了$9$，如果连除了$1，3，5，7$和偶数以外的数字的最小值都无法出现，那么更大的数字就不可能出现了，这个正确性请感性了解一下
   - 如果这之中出现了$9$，那它必然是在$B$层出现的。那么代表$A$层之中有连续的$9$个$1$。也就是说再上一个$B$层之中，有连续的$4$个$1$和$1$个非$1$数字。由于$B$是描述一个连续区间的，所以这$4$个$1$无论如何都无法凑出，所以琅泽阵之中不可能出现$9$
   - 其余数字以此类推。故可得结论：琅泽阵之中除$a$外，不可能出现大于$7$的数字
  
至此，琅琊阵之中会出现的数字的讨论结束了。然后我们对$3，5，7$分别寻找出现的规律
1. 当$a{\neq}3$且$a>1$的时候，整个琅琊阵只存在一个$3$
    > - 在第$3$行后，若出现新的$3$，则需满足在$A$规律中出现$3$个单独连续的$1$(即这M3个$1$左右两边都没有$1$)，那么在此又往上一次的$A$规律中必须有两个连续的非$1$数，然而这并不可能，因为在分的时候，若出现两个连续的$k$和$n$($k$，$n>1$)，则可能为 
    > - ①$k$个$n$，与该规律矛盾！
   > - ②$q$个$k$，$n$个$p$，又与之矛盾！故往后不可能再出现新的$3$。
   > - 而第四行出现的3是特殊情况，因为前两次的分恰好满足a单独存在，导致前一次出现连续三个1，而往后就没有了。
2. 对于$5，7$进行讨论
   - 我们可以通过打表的方式得到$5，7$的规律。由于$A$的规律仅是对$B$的一种逐个描述，不会在序列之中添加除了$1$以外的其余的数字，所以这里我们只看$B$规律
  
 |    | 4 | 6 | 8 | 10 | 12 | 14 | 16 | 18 | 20 |
 |:-: |:-:|:-:|:-:|:-: |:-: |:-: |:-: |:-: |:-: |
 |潜5 |1  | 1 | 2 | 3 | 5 | 8 | 13 | 21 | 34 |
 |5数量 | 0 | 1 | 2 | 4 | 7 | 12 | 20 | 33 | 54 |
|7数量 | 0 | 0 | 1 | 2 | 4 | 7 | 12 | 20 | 33 |
|潜7 | 1 | 1 | 2 | 3 | 5 | 8 | 13 | 21 | 34 |
   - 注：潜$5$表示下一次$B$规律要增加的$5$，潜$7$表示往后第二次$B$要增加的$7$

然后我们可以惊喜的发现这里有斐波那契数列！

> - 事实上，$5$是由上一次$B$规律中两个单独连续的$1$演变而来的，演变来之后随之又增加了两个单独连续的$1$，也就是上一次$B$规律带来了$1$个$5$并埋下了一个潜$5$。
> - 那为什么是斐波那契数列呢？我们又发现$7$是由上两次$B$规律中两个连续的不等数得来的。而第$4$行由于$3$在在前面，可以视为前面有一个与它不等的数，因此埋下了一个潜$7$，在下一次$B$规律中，$7$并没有马上出现，而是演变成了$3$个$1$，此时由上一层演变而来的$5$又与$3$靠在了一起，埋下一个潜$7$，那么该行就有一个潜$5$一个潜$7$。
> - 也就是说，每一个潜$5$都会带来$1$个潜$5$和$1$个潜$7$，而不难发现，每一个潜$7$又会给下两行带来一个潜$5$和潜$7$。那么我们知道第四行是$1$个潜$5$和$1$个潜$7$，第六行由第四行的潜$5$得到$1$个潜$5$和$1$个潜$7$，而第八行由第六行的潜$5$得$1$个潜$5$和$1$个潜$7$，再由第四行的潜$7$得到$1$个潜$5$和$1$个潜$7$ 。
 
 
> #### UPDATE:此处Latex炸了，故放上图片
![QAQ](https://cdn.luogu.com.cn/upload/image_hosting/xfsa3rtz.png)

 
 
 
这时我们回想斐波那契数列的原本的提出：刚出生的兔子，要再长一个月才可以生出兔子。而潜$7$的增长方式与之相同。




总结以上，我们可知：潜$5$和潜$7$在每一层上都是相等的。但是潜$5$对后面没有影响，每一个潜$7$对其后面的第二次的$B$规律有影响，即$F[N]=F[N-1]+F[N-2]$

我们设$2n$层的$5$的数量为$five[k](k=n)$,设斐波那契数列为$F[i]$,那么$2n$层对应的潜$5$或潜$7$数量就是$F[n]=F[k-1]$,故易得$five[k]=five[k-1]+F[k-2]$。(此处层数$/2$，仅仅是为了更好的编写程序，规律$A$不会改变非$1$数字的数目，所以不考虑$A$也是可以的)

所以最后第$k$的$5$数目的答案式是${five[k]={\sum_{i=1}^{k-2}(F[i])}}$。对于$7$来讲，$7$的数目与上一次相同规律的$5$的数目是一样的。


至此，琅琊阵的规律全部解释完毕


-----------


### 程序构造


斐波那契数列的$O(N)$公式大家都知道，但是由于实现太少，所以这样的方法肯定不对。我们可以进一步考虑奇数项和偶数项的求和公式，即为

$F[2n]=F[2n-1]+...+F[3]+F[1]$

$F[2n+1]-1=F[2n]+...+F[4]+F[2]$

但是仅仅依靠这两个公式，你还是会超时，你想到了还有一种公式，叫做二倍项公式

$F[2n]=F[n-1]F[n]+F[n+1]F[n]$

它可以化为

$F[2n]=F[n]^{2}+2F[n]F[n-1]$

$F[2n-1]=F[n]^{2}+F[n-1]^{2}$

运用这个公式，你就可以获得$AC$的好结果

----------

### code
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
long long k,l,r,t,ans,a,p,q;
const long long mod=20171111;
inline void solve(long long a){
    if(a==2) k=1,l=1;//k->F[n],l->F[n-1]
    else if(a%2==0)
        solve(a/2),t=k*k+2*k*l,//二次项公式
        l=k*k+l*l,k=t;//二次项公式
    else if(a%2==1)
        solve(a-1),t=k+l,l=k,k=t;//普通公式
    k%=mod,l%=mod;
}
int main(){
    scanf("%lld%lld%lld",&a,&q,&p);
    if(p==5||p==7){
        q-=4,q/=2;
        if(p==7) q-=1;
        if(q>0) if(q%2==1)
                solve(q+2),ans+=k-1,ans%=mod;
        else solve(q),ans+=k,solve(q+1),
                ans+=k-1,ans%=mod;
        if(a==5||a==7) ans++;
        if(q<=0) putchar('0');
        else printf("%lld",ans);
    }
    else if(p==3)
        if(a!=3) if(q>3)
        putchar('1');else putchar('0');
        else if(q>3)
            putchar('2');else putchar('1');
        else if(a==p) putchar('1');
        else putchar('0');
}
```
--------
最后，国际惯例，thankyou for your attention

[官方题解](https://pan.baidu.com/s/1c20HjzU#list/path=%2F)

---

## 作者：glassy (赞：3)

根据数据范围，直接开始找规律。。。

暴力程序：

```cpp
#include<bits/stdc++.h>
using namespace std;
int aa[100010],bb[100010],q,pos,key;
int main(void)
{
    freopen("out.txt","w",stdout);
    int *a=aa,*b=bb;
    int la=1,lb=0;
    scanf("%d%d",&q,&pos);
    a[1]=q;
    printf("%-8d%-8d%-8d%-8d%-8d%-8d\n",0,1,3,5,7,q);
    printf("%-8d%-8d%-8d%-8d%-8d%-8d\n",1,0,0,0,0,1);
    for(int i=2;i<=pos;i++){
        if(i%2==0){//合并 
            int last=1,data=a[1];
            for(int j=2;j<=la;j++){
                if(data==a[j])
                    last++;
                else{
                    b[++lb]=last;
                    b[++lb]=data;
                    data=a[j];
                    last=1;
                }
            }
            b[++lb]=last;
            b[++lb]=data;
            data=a[la];
            last=1;
        }else{//分离 
            for(int j=1;j<=la;j++){
                b[++lb]=1;
                b[++lb]=a[j];
            }
        }
        int vv[110];
        memset(vv,0,sizeof(vv));
        for(int j=1;j<=lb;j++)
            vv[b[j]]++;
        printf("%-8d%-8d%-8d%-8d%-8d%-8d\n",i,vv[1],vv[3],vv[5],vv[7],vv[q]);
        swap(a,b);
        la=lb;
        lb=0;
    }
    return 0;
}
``` 
可以发现，每行中只会出现1,3,5,7,Q这几个数

然后每行中这几个数出现的次数列出来(这里Q=2)

```cpp 
行      1       3       5       7       2       
1       0       0       0       0       1       
2       1       0       0       0       1       
3       3       0       0       0       1       
4       2       1       0       0       1       
5       6       1       0       0       1       
6       5       1       1       0       1       
7       13      1       1       0       1       
8       7       1       2       1       1       
9       19      1       2       1       1       
10      12      1       4       2       1       
11      32      1       4       2       1       
12      19      1       7       4       1       
13      51      1       7       4       1       
14      31      1       12      7       1       
15      83      1       12      7       1       
16      50      1       20      12      1       
17      134     1       20      12      1       
18      81      1       33      20      1       
19      217     1       33      20      1       
20      131     1       54      33      1       
21      351     1       54      33      1       
22      212     1       88      54      1       
23      568     1       88      54      1       
24      343     1       143     88      1       
25      919     1       143     88      1       
26      555     1       232     143     1       
27      1487    1       232     143     1       
28      898     1       376     232     1       
29      2406    1       376     232     1       
30      1453    1       609     376     1   
```
可以发现以下几个规律

```cpp
1. 3的一列从第4行开始都是1
2. 7的那一列等于5下移两位
3. 5那一列从6开始f[i]=f[i-2]+f[i-4]+1 (有点难发现)
4. Q那一行永远都是1，当Q是1,3,5,7时，在那一列+1就好。 
5. 1哪一行似乎毫无规律
```
然后我们看一看数据范围。

根本不会问"1"!!!!!!!!

于是，我们只需要解决5那一行就好了。

如果递推肯定会超时，因此需要借助矩阵乘法。

设一个A矩阵等于A[3]={f[i-2],f[i-4],1};

设计一个3\*3的矩阵，使得A\*F=B{f[i],f[i-2],1}

经计算

```cpp
F[3][3]={
    {1,1,0},
    {1,0,0},
    {1,0,1}
}
```
有了这些之后，发现答案就是$A*F^n$

而矩阵乘法是满足结合律，于是可以用快速幂

最后输出结果即可。

下面的代码小小地封装了一下。

```cpp 
#include<bits/stdc++.h>
using namespace std;
const long long Mod=20171111;
const long long pows[4][4]={{0,0,0,0},{0,1,1,0},{0,1,0,0},{0,1,0,1}};    //矩阵F 
const long long start[4][4]={{0,0,0,0},{0,1,0,1},{0,0,0,0},{0,0,0,0}};    //矩阵A 
const long long _01[4][4]={{0,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1}};    //矩阵的0次方 
class node{//矩阵类 
    public:
        long long arr[4][4];
        node(void){memset(arr,0,sizeof(arr));}
        node(const long long a[4][4]){                            //构造函数 
            for(register int i=1;i<=3;++i)
                for(register int j=1;j<=3;++j)
                    arr[i][j]=a[i][j];
        };
        friend node operator*(const node &x,const node &y){        //重载乘法运算 
            node c;
            for(register int i=1;i<=3;++i)
                for(register int j=1;j<=3;++j)
                    for(register int k=1;k<=3;++k)
                        c.arr[i][j]+=x.arr[i][k]*y.arr[k][j];
            return c;
        }
        node operator%(long long mod){                            //重载模运算 
            node c;
            for(register int i=1;i<=3;++i)
                for(register int j=1;j<=3;++j)
                    c.arr[i][j]=arr[i][j]%mod;
            return c;
        }
}task(pows),st(start);
const node zero(_01);
node pow(node a,long long b,long long mod){                        //精简的快速幂 
    if(b==0)
        return zero;//矩阵的0次方 
    if(b==1)
        return a;
    node t=pow(a,b>>1,mod);
    if((b&1)==1)
        return (((t*t)%mod)*a%mod);
    return t*t%mod;
}
int main(void)
{
    long long a,b,c;
    scanf("%lld%lld%lld",&a,&b,&c);
    b--;
    long long ans=(a==c);
    if(c==3)        //3那一列从3开始+1 
        ans+=(b>2);
    if(c==5){
        if(b==5)
            ans+=1;
        else if(b>=6)
            ans+=(st*pow(task,((b-5)>>1),Mod)).arr[1][1];
            //不能写成 pow(task,((b-5)>>1),Mod)*st 因为矩阵乘法不满足交换律 
    }if(c==7){
        if(b==7)
            ans+=1;
        else if(b>=8)
            ans+=(st*pow(task,((b-7)>>1),Mod)).arr[1][1];
    }
    printf("%lld",ans%Mod);
    return 0;
}
```
总时间复杂度$O(1)$~$O(logb)$


---

## 作者：Xuan_qwq (赞：1)

首先，我们可以发现规律 $A$ 就是在上一个序列的每个元素前面插入一个 `1`，规律 $B$ 则是对上一个序列进行一次描述。

总结出两条规律后，我们打表出部分琅泽阵（假设 $Q$ 不与任何一个元素相等）：
```
1 Q
1 1 1 Q
3 1 1 Q
1 3 1 1 1 1 1 Q
1 1 1 3 5 1 1 Q
1 1 1 1 1 1 1 3 1 5 1 1 1 1 1 Q
7 1 1 3 1 1 1 5 5 1 1 Q
1 7 1 1 1 1 1 3 1 1 1 1 1 1 1 5 1 5 1 1 1 1 1 Q
1 1 1 7 5 1 1 3 7 1 1 5 1 1 1 5 5 1 1 Q
1 1 1 1 1 1 1 7 1 5 1 1 1 1 1 3 1 7 1 1 1 1 1 5 1 1 1 1 1 1 1 5 1 5 1 1 1 1 1 Q
```
[打表所用代码](https://www.luogu.com.cn/paste/ai0qoi8k)。

容易发现除了末尾那个 $Q$ 以外，所有的元素都不超过 `7`。下面我们来证明这件事：
>首先，琅泽阵中除了 $Q$ 以外，不可能出现偶数。
>
>不妨设前 $a$ 行都没有出现偶数，现在考虑第 $a+1$ 行：
>- 如果 $a+1$ 是奇数，由于从偶数层到奇数层是在每个元素前插入了一个 `1`，所以不会产生数字奇偶性的变化，第 $a+1$ 行也不会出现偶数。
>
>- 如果 $a+1$ 是偶数，那么第 $a$ 行就是 $1,x_1,1,x_2,\dots,1,x_n$ 的形式，如果要出现连续偶数个相同的元素，只能是连续的 $1$。考虑一个区间 $[l,r]$，满足 $x_l,x_{l+1},\dots,x_{r}=1$ 且 $x_{l-1}\ne 1$，$x_{r+1}\ne 1$。那么生成的这一段序列就是 $1,x_{l-1},\underbrace{1,1,1,1,\dots,1,1}_{2\times (r-l+1)\text{个}1},1,x_{r+1}$。\
>  显然这一段 $1$ 的个数是奇数，所以第 $a+1$ 行也不会出现偶数。

>第二，琅泽阵里除了 $Q$，不会出现大于 $7$ 的奇数。
>
>如果要出现大于 $7$ 的树 $y$，考虑第一次出现 $y$ 的那一行，一定是偶数行从上一行经过了一次 $B$ 描述出现了 $y$。不妨设这一行为第 $a$ 行。
>- 根据上面的分析，$a-1$ 行中必定出现了连续的 $y$ 个 $1$。那么在 $a-2$ 行中就必定出现了连续的 $\frac{y-1}{2}$ 个 $1$。由于 $y>7$，所以 $\frac{y-1}{2}>3$，也就是至少出现连续的 $4$ 个 $1$。
>- 如果我们把这 $4$ 个 $1$ 按描述的方法配组，可能出现两种情况：$(1,1),(1,1)$ 或者 $(u,1),(1,1),(1,d)$。显然这两种情况都不可能存在，$(1,1),(1,1)$ 应该表示为 $(2,1)$，$(u,1),(1,1),(1,d)$ 应表示为 $(u+1,1),(1,d)$。
>- 所以不会出现 $y>7$ 的奇数，得证。

然后我们研究数字出现的规律。由于题目数据范围限定了 $Q,x>1$，所以不用考虑初始元素为 $1$ 的毒瘤东西。

#### 3 的个数
当 $Q\ne 3$ 时只有 1 个，当 $Q=3$ 时有 2 个。

证明：
>明显第一次出现 $3$ 是在第 $3$ 行。如果在这之后又出现了 $3$（设在第 $a$ 行），那么 $a$ 为偶数且必须要在 $a-1$ 行中出现一段只有 $3$ 个连续的 $1$ 的区间。也就是 $a-2$ 行要出现 $x_1,1,x_2(x_1,x_2\ne 1)$ 的形式，所以 $a-3$ 行需要 $x_1,x_2(x_1,x_2\ne 1)$ 的一段，这显然不可能。
>
>又可以注意到倒数第二个数永远是 $1$，所以当 $Q=3$ 时这个 $3$ 不会消失，证毕。

#### 5,7 的个数
我们把偶数行的数量打表打出来，如下：
|行|2|4|6|8|10|12|14|
|-|-|-|-|-|-|-|-|
|5|0|0|1|2|4|7|12|
|7|0|0|0|1|2|4|7|

我们发现这是斐波那契数列 -1！

为啥捏？
>一个在第 $a$ 行新增的 $5$，对应着 $a-1$ 行的一个 $x_1,1,1,1,1,1,x_2$，代表着 $a-2$ 行的 $1$ 个 $x_1,1,1,x_2$。而每生成一个 $5$，这一行就会有一个 $x_1,5,1,1,x_2$，然后在两行之后再生成一个 $5$。
>
>让我们再把这个东西推下去：
>$$x_1,5,1,1,x_2$$
>$$x_1,1,5,1,1,1,1,1,x_2$$
>$$x_1,1,1,1,5,5,1,1,x_2$$
>$$x_1,1,1,1,1,1,1,1,5,1,5,1,1,1,1,1,x_2$$
>$$x_1,7,1,1,5,1,1,1,5,5,1,1,x_2$$
>我们发现它又生成了一个 $7$，而 $7$ 的旁边还有两个连续的 $1$。因此每生成一个 $5$，它将在两行之后生成一个 $5$，在 $4$ 行之后生成一个 $7$。
>
>同样推下去，每生成一个 $7$，它将在两行之后生成一个 $5$，在 $4$ 行之后生成一个 $7$。
>
>把式子整理一下，就成了斐波那契数列的递推式。

然后就可以直接求式子了。可以用矩阵快速幂也可以用二倍项公式，都能通过此题。

这里用的是二倍项公式，即
$$f_{2n}=f_{n-1}f_{n}+f_{n}f_{n+1}$$

推一下就可以知道：
- $f_{2n}=f_{n}^2+2f_{n-1}f_{n}$。
- $f_{2n-1}=f_{2n}-f_{2n-2}=f_n^2+f_{n-1}^2$。

然后这题就做完了。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod=20171111;
int k,l,t;
void solve(int x){
	if(x==2){
		k=1,l=1;
		return;
	}
	if(x%2){
		solve(x-1);
		t=k+l;
		l=k;k=t;
	}
	else{
		solve(x/2);
		t=k*k+2*k*l;
		l=k*k+l*l,k=t;
	}
	k%=mod,l%=mod;
}
signed main(){
	int Q,i,x,ans=0;cin>>Q>>i>>x;
	if(x==5||x==7){
		i=(i-4)/2;
		if(i<=0){
			cout<<"0"<<endl;
			return 0;
		}
		if(x==7) i--;
		if(i%2==1){
			solve(i+2);
			ans=(ans+k-1)%mod;
		}
		else{
			solve(i);
			ans+=k;
			solve(i+1);
			ans=(ans+k-1)%mod;
		}
		if(Q==5||Q==7) ans++;//如果初始元素重复了要加回去 
		cout<<ans<<endl; 
	}
	else if(x==3){
		if(Q!=3){
			if(i>3) cout<<"1";
			else cout<<"0";
		}
		else if(i>3)cout<<"2";
		else cout<<"1";
	}
	else if(Q==x) cout<<"1";
	else cout<<"0";
	return 0;
}
```

---

## 作者：Presentation_Emitter (赞：1)

### 本题解涉及x=1的情况，而题目中并没有该类数据

### Update:2020.6.25 修正文章中的小错误（Fuhrer你个菜鸡）

首先我们要打一个简单的表（这里用了@glassy 大佬题解中的程序），它大概长[这样](https://www.luogu.com.cn/paste/33mdtll6)。

关于`3,5,7`的情况其他两篇题解已经讲得十分详细，于是我们来看看`1`的数量。

`0 1 3 2 6 5 13 7……`

初看毫无规律，但是由于奇数层与偶数层使用**不同**的规律进行描述，于是我们把它们单独列出来

`0 3 6 13 19 32 51……`

`1 2 5 7 12 19 31……`

去掉头几项后，它们满足**斐波那契数列**的形式。于是我们可以使用矩阵快速幂（见[本题](https://www.luogu.com.cn/problem/P1962)）

此外，事实上，设$fa(x),fb(x),fc(x),fd(x),fq(x)$分别为第$x$层中`1，3，5，7，q`的个数，则$fa(2n+1)=2fa(2n)+fb(2n)+fc(2n)+fd(2n)+fq(2n)$，因为奇数层的描述方式为在上一层的所有数据前面添加$1$

接下来我们再手打[一个表](https://www.luogu.com.cn/paste/7cu6tbga)，可以得知，奇数行的连续$k$个1会变为偶数行的`k 1`。根据奇数行的规律，易得在奇数行**没有连续的非1数**，所以

$fa(2n)=2[fa(2n-1)-3fb(2n)+3fb(2n-1)-5fc(2n)+5fc(2n-1)-7fd(2n)+7fd(2n-1)]+fb(2n)+fc(2n)+fd(2n)+fq(2n)$

则$fa(2n)=2fa(2n-1)+6fb(2n-1)+10fc(2n-1)+14fd(2n-1)+fq(2n-1)-5fb(2n)-9fc(2n)-13fd(2n)$

于是我们得到了这个程序：

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
using namespace std;
#define ll long long
#define ioi 20171111
#define debug_m(a) {cout<<a.p1<<' '<<a.p2<<endl;	for(ll i=1;i<=n;i++){for(ll j=1;j<=n;j++)cout<<a.value[i][j]<<' ';cout<<endl;}}
struct matrix
{
	ll p1,p2,value[5][5];
	matrix()
	{
		p1=p2=0;
		memset(value,0,sizeof(value));
	}
	matrix operator* (const matrix &a)const
	{//Multi {M*P}*{P*N}={M*N} ({a*b} is a Matrix of a*b)
		matrix ans;
		ans.p1=p1;
		ans.p2=a.p2;
		for(ll i=1;i<=p1;i++)//m
		{
			for(ll j=1;j<=a.p2;j++)//n
			{
				ans.value[i][j]=0;
				for(ll k=1;k<=p2;k++)//p
				{
					ans.value[i][j]+=value[i][k]*a.value[k][j]%ioi;
					ans.value[i][j]%=ioi;
				}
			}
		}
		return ans;		
	}
}zero;
ll Q,id,x;
void init1(matrix &ioiaki)
{
	for(ll i=1;i<=min(ioiaki.p1,ioiaki.p2);i++)ioiaki.value[i][i]=1;
}
matrix qpow(matrix I,ll ak)
{
	if(!ak)return zero;
	else if(!(ak^1))return I;
	else if(ak&1)return qpow(I*I,ak>>1)*I;
	return qpow(I*I,ak>>1);
}
ll slv(ll q,ll i,ll x)
{
	ll ans=0;
	if(x==1&&x!=q)
	{
		if(i==1)return 0;
		if(i==2)return 1;
		if(i==3)return 3;
		if(i==4)return 2;
		if(i==5)return 6;
		if(i==6)return 5;
		return (i&1?(slv(q,i-1,1)*2+slv(q,i-1,3)+slv(q,i-1,5)+slv(q,i-1,7)+1):(slv(q,i-1,1)*2+6*slv(q,i-1,3)+10*slv(q,i-1,5)+14*slv(q,i-1,7)+1-5*slv(q,i,3)-9*slv(q,i,5)-13*slv(q,i,7)))%ioi;
	}
	if(x==5)x+=2,i+=2;
	if((x==3&&i<=3)||(x==7&&i<=7)||(x!=3&&x!=7))return 0;
	if(x==3)return 1;
	i=(i-6)/2;
	matrix st,mid,res;
	st.p1=1,st.p2=mid.p1=mid.p2=3;
	st.value[1][1]=mid.value[1][1]=mid.value[3][2]=mid.value[1][3]=mid.value[2][3]=mid.value[3][3]=1;
	res=st*qpow(mid,i);
	ans+=res.value[1][3];
	return ans;
}
int main()
{
	zero.p1=zero.p2=3;
	init1(zero);
	cin>>Q>>id>>x;
	cout<<slv(Q,id,x)+(x==Q)<<endl;
	return 0;
}
```

当然，其实这个式子还能变形，但是咱不会~~（懒）~~，各位可以试试

---

## 作者：BDFZ_hym_AK_hym_ing (赞：0)

首先，这题的思路比较难想，所以我借鉴了[这篇题解](https://www.luogu.com.cn/article/2gclkchn)的暴力列举，在开头表示感谢。
### 题目解读：
给三个整数 $Q,i,x$。$Q$ 表示泽阵的初始数据，$i$ 表示行数，$x$ 表示在第 $i$ 行中需要求出数量的数。  
输出第 $i$ 行中 $x$ 的数量对 $20171111$ 取模的值。
### 思路分析：
#### 规律观察：
观察图表易得：  
$A$ 规律是将上一行每个数前都加上一个 $1$。  
$B$ 规律就是上文所讲的**描述法**（忘了的[回去](https://www.luogu.com.cn/problem/P3981)自己看）。 
#### 打表并观察：
先打表（令 $Q$ 不为 $1$）：  
```markdown
Q
1 Q
1 1 1 Q
3 1 1 Q
1 3 1 1 1 1 1 Q
1 1 1 3 5 1 1 Q
1 1 1 1 1 1 1 3 1 5 1 1 1 1 1 Q
7 1 1 3 1 1 1 5 5 1 1 Q
1 7 1 1 1 1 1 3 1 1 1 1 1 1 1 5 1 5 1 1 1 1 1 Q
1 1 1 7 5 1 1 3 7 1 1 5 1 1 1 5 5 1 1 Q
```
~~后面太长了，不打了。~~  
再次观察，注意到这里除 $Q$ 外皆为奇数且最大为 $7$。  
这个猜想是对的吗？
#### 证明猜想：
首先证明除 $Q$ 外皆为奇数。  
第一行：只有一个数 $Q$，所以除 $Q$ 外皆为奇数。  
第二行：$Q$ 的个数为 $1$，是奇数，所以除 $Q$ 外皆为奇数。  

第 $2\times n-1$（$n \ge 2$）行：因为第 $2\times n-2$ 行除 $Q$ 外都为奇数（证明在下一段），而在这些数的前面添加 $1$ 并不影响，所以除 $Q$ 外皆为奇数。  

第 $2\times n$（$n \ge 2$）行，因为第 $2\times n-1$ 行只添加了 $1$，并且除 $1$ 外的数将会被 $1$ 分隔开，所以其他数前面将会直接添加 $1$。  
而第 $2\times n-1$ 行的 $1$ 的个数应为第 $2\times n-2$ 行对应位置 $1$ 的数量乘 $2$（第 $2\times n-1$ 行使用规律 $A$，所以每个 $1$ 前会多出一个 $1$）再加 $1$（因为 $Q$ 不为 $1$，而 $Q$ 一定在行末，所以一串 $1$ 后面必有一个不为 $1$ 的数），而这个数量为奇数，所以这一行只会加入一些奇数，并删去一些 $1$，所以除 $Q$ 外皆为奇数。  

接下来证明除 $Q$ 外最大为 $7$。  
若存在奇数 $P$（$P \ne Q, P>7$）于琅泽阵中。   
因为奇数行只会增加 $1$，所以第一次出现 $P$ 必须在偶数行。  
若 $P$ 出现在 $2 \times n$ 行，则 $2 \times n-1$ 行有连续的 $P$ 个 $1$（除 $1$ 外的数会在奇数行被 $1$ 分隔开，不可能出现连续），而 $2 \times n-2$ 行有连续的 $\frac{P-1}{2}$ 个 $1$（证明可见上文）。  
因为 $2 \times n-2$ 为偶数，所以此行不可能出现 $3$ 个以上的相同数字，证明：  
若出现连续 $3$ 个以上的 $1$，则第 $2 \times n-3$ 行必出现连续的 $1$，根据描述法，这些 $1$ 应被合并，所以不会出现例如连续 $3$ 个以上的 $1$。  
例子：
```markdown
1 1
1 1 1 1（实际应为：2 1）
```
所以 $\frac{P-1}{2}\le 3$，解得 $P\le 7$，与假设 $P>7$ 矛盾，所以除 $Q$ 外最大为 $7$。
#### 打表答案：
除 $Q$ 外，其他奇数（$1,3,5,7$）的个数可以打表（这里借鉴[他的题解](https://www.luogu.com.cn/user/29372)中的数据，题解链接见开头）。

```markdown
行      1       3       5       7       Q       
1       0       0       0       0       1       
2       1       0       0       0       1       
3       3       0       0       0       1       
4       2       1       0       0       1       
5       6       1       0       0       1       
6       5       1       1       0       1       
7       13      1       1       0       1       
8       7       1       2       1       1       
9       19      1       2       1       1       
10      12      1       4       2       1       
11      32      1       4       2       1       
12      19      1       7       4       1       
13      51      1       7       4       1       
14      31      1       12      7       1       
15      83      1       12      7       1       
16      50      1       20      12      1       
17      134     1       20      12      1       
18      81      1       33      20      1       
19      217     1       33      20      1       
20      131     1       54      33      1       
21      351     1       54      33      1       
22      212     1       88      54      1       
23      568     1       88      54      1       
24      343     1       143     88      1       
25      919     1       143     88      1       
26      555     1       232     143     1       
27      1487    1       232     143     1       
28      898     1       376     232     1       
29      2406    1       376     232     1       
30      1453    1       609     376     1   
```
因为 $x$ 不为 $1$，所以 $1$ 的这列可以不观察（其实也有规律）。
所以直接分类讨论：  
$x=3$ 时：前三行为 $0$，其余为 $1$。  
$x=5$ 时：前五行为 $0$，其余遵循 $f_i=f_{i-2}+f_{i-4}$ 的规律。  
$x=7$ 时：前七行为 $0$，其余也遵循 $f_i=f_{i-2}+f_{i-4}$ 的规律。  
**注意加上 $x=Q$ 的情况！！！**
#### 计算答案：
当 $x=5$ 或 $x=7$ 时，答案有递推公式，且注意到 $i\le 10^{18}$，所以这里计算答案应用 $\log(i)$ 的算法，所以很容易想到矩阵乘法。
### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long mod=20171111;
long long Q,cs,x;
long long c[6][6];
long long f[6][6];
long long ls[6][6];
long long qpower(long long b){
	long long i,j,k;
	memset(c,0,sizeof(c));
	memset(f,0,sizeof(f));
	for(i=1;i<=5;i++)
	{
		c[i][i]=1;//初始矩阵
	}
	f[2][1]=1;//这块是定义矩阵
	f[4][1]=1;
	f[5][1]=1;
	f[1][2]=1;
	f[2][3]=1;
	f[3][4]=1;
	f[5][5]=1;
	while(b)
	{
		if(b&1)
		{
			for(i=1;i<=5;i++)
			{
				for(j=1;j<=5;j++)
				{
					ls[i][j]=0;
					for(k=1;k<=5;k++)
					{
						ls[i][j]+=(c[i][k]*f[k][j]%mod);
					}
				}
			}
			for(i=1;i<=5;i++)
			{
				for(j=1;j<=5;j++)
				{
					c[i][j]=(ls[i][j]%mod);
				}
			}
		}
		for(i=1;i<=5;i++)
		{
			for(j=1;j<=5;j++)
			{
				ls[i][j]=0;
				for(k=1;k<=5;k++)
				{
					ls[i][j]+=(f[i][k]*f[k][j]%mod);
				}
			}
		}
		for(i=1;i<=5;i++)
		{
			for(j=1;j<=5;j++)
			{
				f[i][j]=(ls[i][j]%mod);
			}
		}
		b>>=1;
	}
	return c[5][1];
}
int main(){

	ios::sync_with_stdio(false);
	cin.tie();
	cout.tie();
	cin>>Q>>cs>>x;
	if(x==3)
	{
		cout<<(cs>=4)+(Q==3);
		return 0;
	}
	if(x!=5&&x!=7)
	{
		cout<<(x==Q);
		return 0; 
	}
	if(cs<=x)
	{
		cout<<(x==Q);
		return 0;
	}
	cout<<((x==Q)+qpower(cs-x))%mod;

	return 0;
}
```

---

## 作者：zgy_123 (赞：0)

好题，真是好题！

个人评价：

- 思维难度：蓝
- 代码难度：黄到绿
- 代码长度：偏短

---

本题证明较复杂，在此不列出了，仅是对于打表更详细的讲解。

首先打出表，如下（不考虑 $Q$）：

```cpp
-       1       3       5       7
1       0       0       0       0     
2       1       0       0       0  
3       3       0       0       0
4       2       1       0       0
5       6       1       0       0
6       5       1       1       0
7       13      1       1       0
8       7       1       2       1
9       19      1       2       1
10      12      1       4       2
11      32      1       4       2
12      19      1       7       4
13      51      1       7       4
14      31      1       12      7
15      83      1       12      7
16      50      1       20      12
17      134     1       20      12
18      81      1       33      20
19      217     1       33      20
20      131     1       54      33
```

明显是按奇偶划分的，所以拆开奇偶。

```cpp
偶      1       3       5       7
4       2       1       0       0
6       5       1       1       0
8       7       1       2       1
10      12      1       4       2
12      19      1       7       4
14      31      1       12      7
16      50      1       20      12
18      81      1       33      20
20      131     1       54      33

奇      1       3       5       7
2       1       0       0       0  
3       3       0       0       0
5       6       1       0       0
7       13      1       1       0
9       19      1       2       1
11      32      1       4       2
13      51      1       7       4
15      83      1       12      7
17      134     1       20      12
19      217     1       33      20
```
这时规律就很明显了。

我们构造三组数列：

1. a 为斐波那契数列，前四项为：0，3，6，13；
1. b 为斐波那契数列，前三项为：1，2，5；
1. c 满足 $c_i=c_{i-1}+c_{i-2}+1$，前两项为：0，1。

则可以推出用矩阵快速幂求它们的方法：

- a,b 为斐波那契数列变形，转移矩阵与斐波那契数列相同；
- $\begin{pmatrix}c_i&c_{i-1}&1\end{pmatrix}\times\begin{pmatrix}1&1&0\\1&0&0\\1&0&1\end{pmatrix}=\begin{pmatrix}c_{i+1}&c_i&1\end{pmatrix}$

然后可以推出公式（不考虑 $Q$）：

|- |1 |3 |5 |7 |
|-:|-:|-:|-:|-:|
|奇|$a_{\frac{i-1}{2}+1}$|$\left\{\begin{matrix}0&i\le3\\1&i>3\end{matrix}\right.$|$\left\{\begin{matrix}0&i\le3\\c_{\frac{i}{2}-1}&i>3\end{matrix}\right.$|$\left\{\begin{matrix}0&i\le5\\c_{\frac{2}{i}-2}&i>5\end{matrix}\right.$|
|偶|$b_\frac{i}{2}$|$\left\{\begin{matrix}0&i\le3\\1&i>3\end{matrix}\right.$|$\left\{\begin{matrix}0&i\le3\\c_{\frac{i}{2}-1}&i>3\end{matrix}\right.$|$\left\{\begin{matrix}0&i\le5\\c_{\frac{2}{i}-2}&i>5\end{matrix}\right.$|

（ps：线在博客区没显示出来）

最后考虑 $Q$。

显然当 $x\ne Q$ 时才会对结果有影响，继续打表（不展示），发现如果 $Q\notin[1,3,5,7]$，则对答案的贡献始终为 $1$，而属于时贡献为 $\left\{\begin{matrix}0&i\le3\\1&i>3\end{matrix}\right.$。

最后可以写出代码：

```cpp
#include<bits/stdc++.h>
#define rep(a,l,r) for(int a=l;a<=r;a++)
#define ll long long
#define Mod 20171111
using namespace std;
struct node{
	ll a[15][15];
	int n,m;
	node(){memset(a,0,sizeof(a));}
};
node operator*(node x,node y){
	node c;
	int n=x.n,m=x.m,q=y.m;
	c.n=n,c.m=q;
	rep(i,1,n)rep(j,1,q)rep(k,1,m)
		c.a[i][j]=(c.a[i][j]+x.a[i][k]*y.a[k][j])%Mod;
	return c;
}
node qpow(node x,ll y){
	node c;
	c.n=c.m=x.n;
	rep(i,1,c.n)rep(j,1,c.m)
		c.a[i][j]=i==j?1:0;
	while(y){
		if(y&1) c=c*x;
		x=x*x,y>>=1;
	}
	return c;
}
int finda(ll x){
	if(x==1) return 0;
	if(x==2) return 3;
	node a,ans;
	a.n=a.m=2,ans.n=1,ans.m=2;
	ans.a[1][1]=13,ans.a[1][2]=6;
	a.a[1][1]=a.a[1][2]=a.a[2][1]=1;
	return (ans*qpow(a,x-3)).a[1][2];
}
int findb(ll x){
	if(x==1) return 1;
	node a,ans;
	a.n=a.m=2,ans.n=1,ans.m=2;
	ans.a[1][1]=5,ans.a[1][2]=2;
	a.a[1][1]=a.a[1][2]=a.a[2][1]=1;
	return (ans*qpow(a,x-2)).a[1][2];
}
int findc(ll x){
	node a,ans;
	a.n=a.m=3,ans.n=1,ans.m=3;
	ans.a[1][1]=ans.a[1][3]=1;
	a.a[1][1]=a.a[1][2]=a.a[2][1]=a.a[3][1]=a.a[3][3]=1;
	return (ans*qpow(a,x-1)).a[1][2];
}
int main(){
	ll q,i,x;
	cin>>q>>i>>x;
	int ans=0;
	if(i&1&&x==1) ans=finda(i/2+1);
	else if(x==1) ans=findb(i/2);
	if(x==3) ans=i<4?0:1;
	if(x==5) ans=i<4?0:findc(i/2-1);
	if(x==7) ans=i<6?0:findc(i/2-2);
	if(x==q) ans+=i<4?0:1;
	cout<<ans<<' ';
	return 0;
}
```

---


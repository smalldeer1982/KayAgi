# [SHOI2013] 超级跳马

## 题目描述

现有一个 $n$ 行 $m$ 列的棋盘，一只马欲从棋盘的左上角跳到右下角。每一步它向右跳奇数列，且跳到本行或相邻行。跳越期间，马不能离开棋盘。例如，当 $n = 3$，$m = 10$ 时，下图是一种可行的跳法。

![](https://cdn.luogu.com.cn/upload/pic/9367.png) 

试求跳法种数对 $30\,011$ 取模的结果。

## 说明/提示

- 对于 $10\%$ 的数据，$1 \leq n \leq 10$，$2 \leq m \leq 10$；
- 对于 $50\%$ 的数据，$1 \leq n \leq 10$，$2 ≤ m ≤ 10^5$；
- 对于 $80\%$ 的数据，$1 \leq n \leq 10$，$2 \leq m \leq 10^9$；
- 对于 $100\%$ 的数据，$1 \leq n \leq 50$，$2 \leq m \leq 10^9$。


## 样例 #1

### 输入

```
3 5```

### 输出

```
10```

# 题解

## 作者：vеctorwyx (赞：18)

### 矩阵优化DP

矩阵乘法~~几乎~~不会，我~~瞎扯~~证明了1个小时才差不多搞明白怎么弄。

1. $DP$
	
    设$\large dp_{i,j}$表示跳到第$i$行第$j$列的方案数。
    
    于是有了一个初步的状态转移方程（假设$i,j$都不会越界）：
    
    $\large dp_{i,j}=dp_{i-1,j-1}+dp_{i,j-1}+dp_{i+1,j-1}+dp_{i-1,j-3}+dp_{i-1,j-5}+...\ ...$
    
    很明显，它复杂度高，不方便求。
    
    然后~~手玩一下~~你就会发现后面那一大串（$dp_{i-1,j-3}+...\ ...$ 以及往后的）跟$dp_{i,j-2}$相等。
    
    证明：
    
    首先，奇数+偶数（2）=奇数，~~小学知识~~
    
    因为马每次只能横向跳奇数格，所以能一次性达到$(i\ ,\ j-2)$的点同时也能一次性达到$(i\ ,\ j)$，且没有其他点（出去第$j-2$列上的三个点）能到达$(i\ ,\ j)$。
    
    然后状态转移方程就变成了
    
    $\large dp_{i,j}=dp_{i-1,j-1}+dp_{i,j-1}+dp_{i+1,j-1}+dp_{i,j-2}$
    
    复杂度是$ O(nm)$的，T飞。
    
2. 矩阵优化：

	转移矩阵的大小与$n$有关。
    
    如果$n=3$，转移矩阵是这样哒：
    
    $\large\begin{Bmatrix}
		1  & 1 & 0 & 1 & 0 & 0\\
		1  & 1 & 1 & 0 & 1 & 0\\
		0  & 1 & 1 & 0 & 0 & 1\\
   	  1  & 0 & 0 & 0 & 0 & 0\\
   	  0  & 1 & 0 & 0 & 0 & 0\\
   	  0  & 0 & 1 & 0 & 0 & 0\\
		\end{Bmatrix}
 	  	\times 
  		\begin{Bmatrix}
		dp_{i,1} \\
		dp_{i,2} \\
		dp_{i,3} \\
   	  dp_{i-1,1} \\
   	  dp_{i-1,2} \\
   	  dp_{i-1,3} \\
		\end{Bmatrix} \ 
      = \ 
  		\begin{Bmatrix}
		dp_{i+1,1} \\
		dp_{i+1,2} \\
		dp_{i+1,3} \\
   	  dp_{i,1} \\
   	  dp_{i,2} \\
   	  dp_{i,3} \\
		\end{Bmatrix}   $
      
      然后矩阵快速幂求一下就好了。
        
3. 计算答案 
	
    你以为怎么着就结束了吗？
    
    其实，还有一个细节问题没有注意到：
    
    当$i=1,j=3$时，回归转移方程式：
    
    $\large dp_{1,3}=dp_{1,2}+dp_{1,2}+dp_{1,1}$
    
    然而这时候$dp_{1,1}$却并不是由前面的点转移过来的，而是特殊初值！！！
    
    也就是说对于$dp_{i,j}$，答案都恰好会多算$dp_{i,j-2}$（这里如果不明白可以自己手玩几组小数据）。
    
    综上所述，记录答案时，应该求$dp_{n,m}-dp_{n,m-2}$。
    
    当然也可以求$dp_{n,m-1}+dp_{n-1,m-1}$。
    
多说一句：为何看着各位大佬的矩阵初值都是对角线为1啊，光把$dp_{1,1}$初始化为1，计算答案时只用第一行不就行吗？~~虽然没多大区别~~

__对了，答案别忘了%30011。__

code（没写注释，~~个人认为~~上面写的比较详细了）：
    
```

#include<bits/stdc++.h> 
#define p 30011
using namespace std;
int read()
{
	int xsef = 0,yagx = 1;char cejt = getchar();
	while(cejt < '0'||cejt > '9'){if(cejt == '-')yagx = -1;cejt = getchar();}
	while(cejt >= '0'&&cejt <= '9'){xsef = (xsef << 1) + (xsef << 3) + cejt - '0';cejt = getchar();}
	return xsef * yagx;
}
int n,m;
struct node{
	int a[110][110];
	node(){
		memset(a, 0, sizeof(a));
	}
}b,c,d;
node operator * (node x, node y){
	node z;
	for(int i = 1;i <= n * 2;i++){
		for(int j = 1;j <= n * 2;j++){
			for(int k = 1;k <= n * 2;k++){
				z.a[i][j] = (z.a[i][j] + x.a[i][k] * y.a[k][j]) % p;
			}
		}
	}
	return z;
}
void build(){
	for(int i=1;i<=n;i++){
			if(i!=1)
				b.a[i][i-1]=1;
			b.a[i][i]=1;
			if(i!=n)
				b.a[i][i+1]=1;
		}
	for(int i=1;i<=n;i++){
		b.a[i][i+n]=1;
	}
	for(int i=1;i<=n;i++){
		b.a[i+n][i]=1;
	}
}
void ksm(){
	while(m){
		if(m&1)
			c=c*b;
		b=b*b;
		m>>=1;
	}
}
signed main(){
	n=read(),m=read();
	build();
	d = b;
	m-=2;
	for(int i=1;i<=n*2;i++)
		c.a[i][i]=1;
	ksm();
	int ans = -c.a[1][n+n];
	c=c*d;
	ans += c.a[1][n];
	printf("%d",ans + p % p);
	return 0;
}

```

---

## 作者：_Diu_ (赞：11)

[题目传送门](https://www.luogu.com.cn/problem/P3990)

~~这马跳得可真远~~

## dp

设 $f_{i,j}$ 表示从起点走到第 $i$ 行第 $j$ 列的方案数。

那么状态转移方程显然：

$f_{i,j}=f_{i-1,j-1}+f_{i,j-1}+f_{i+1,j-1}$

$+f_{i-1,j-3}+f_{i,j-3}+f_{i+1,j-3}$

$+\dots$

$+f_{i-1,j\%2+1}+f_{i,j\%2+1}+f_{i+1,j\%2+1}$

直接转移显然是不行的，时间空间都会炸。

## 前缀和

我们发现第 $j$ 列的转移要么和 $1,3,5,\dots$ 列有关，要么和 $2,4,6,\dots$ 有关

那我们可以维护一个前缀和。

设 $s_{i,j}=f_{i,j}+f_{i,j-2}+f_{i,j-4}+\dots+f_{i,j\%2}$

显然有：

$s_{i,j}=s_{i,j-2}+f_{i,j}$

那么状态转移方程就能够写成这样：

$f_{i,j}=s_{i-1,j-1}+s_{i,j-1}+s_{i+1,j-1}$

前缀和数组的转移就可以写成这样：

$s_{i,j}=s_{i-1,j-1}+s_{i,j-1}+s_{i+1,j-1}+s_{i,j-2}$

至此，我们已经可以在时间空间 $O(nm)$ 的限制下求出答案。

## 矩阵快速幂

我们发现，$s_{j}$ 的转移只和 $s_{j-1},s_{j-2}$ 有关，而 $n$ 的范围特别小，$m$ 的范围极大，所以考虑写矩阵快速幂。

$\begin{vmatrix}s_{1,j}\;\;\;\;&s_{2,j}\;\;\;\;&s_{3,j}&\;\dots\;\;\;&s_{n,j}&s_{1,j-1}&s_{2,j-1}&s_{3,j-1}&\dots&s_{n,j-1}\end{vmatrix}$ 

$\times$ 一个矩阵 $=$ 

$\begin{vmatrix}s_{1,j+1}&s_{2,j+1}&s_{3,j+1}&\dots&s_{n,j+1}&s_{1,j}\;\;\;\;&s_{2,j}\;\;\;\;&s_{3,j}&\;\dots\;\;\;&s_{n,j}\end{vmatrix}$

我们把状态转移方程放进去就好了：

这里以 $n=5$ 举例：

$\begin{vmatrix}1&1&0&0&0&1&0&0&0&0\\1&1&1&0&0&0&1&0&0&0\\0&1&1&1&0&0&0&1&0&0\\0&0&1&1&1&0&0&0&1&0\\0&0&0&1&1&0&0&0&0&1\\1&0&0&0&0&0&0&0&0&0\\0&1&0&0&0&0&0&0&0&0\\0&0&1&0&0&0&0&0&0&0\\0&0&0&1&0&0&0&0&0&0\\0&0&0&0&1&0&0&0&0&0\\ \end{vmatrix}$

构建出来的矩阵大概就是长这个样子的。

注意边界的判断，$m$ 比较小的时候要特判。

还有就是我们求出来的答案是前缀和，

$Ans=f_{n,m}=s_{n,m}-s_{n,m-2}$


## code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=110,p=30011;
int n,m;
struct Mat{
	int r,c;
	int mat[N][N];
	void clear(){
		memset(mat,0,sizeof(mat));
		r=c=0;
	}
	void init(int n){
		memset(mat,0,sizeof(mat));
		for(int i=1;i<=n;i++)mat[i][i]=1;
		r=c=n;
	}
};
Mat operator*(Mat a,Mat b){
	Mat c;
	c.clear();
	c.r=a.r,c.c=b.c;
	for(int l=1;l<=a.c;l++)
		for(int i=1;i<=a.r;i++)
			for(int j=1;j<=b.c;j++)
				c.mat[i][j]=(c.mat[i][j]+a.mat[i][l]*b.mat[l][j]%p)%p;
	return c;
}
Mat operator^(Mat a,int k){
    Mat c;
    c.init(a.r);
    for(;k;k>>=1,a=a*a)if(k&1)c=c*a;
    return c;
}
int query(int m,int n){
	if(m==0)return 0;
	Mat a,b;
	a.clear(),b.clear();
	a.r=a.c=b.c=2*n;
	b.r=1;
	b.mat[1][1]=1;
	for(int i=1;i<=n;i++){
		a.mat[i][i]=1;
		a.mat[i+n][i]=1;
		a.mat[i][i+n]=1;
		if(i!=1)a.mat[i-1][i]=1;
		if(i!=n)a.mat[i+1][i]=1;
	}
	int k=m-1;
	a=a^k;
	a=b*a;
	return a.mat[1][n];
}
signed main(){
	scanf("%lld%lld",&n,&m);
	printf("%lld\n",(query(m,n)-query(m-2,n)+p)%p);
}
```

其实上面构建矩阵的过程有点重复了，构建一次就可以了。

~~但是我懒得改了。~~

---

## 作者：zzqDeco (赞：11)

本题我想到一个不同于其他人的优化 dp 的做法

考虑我们将问题转化，看成一个下面的问题：

> 一共有 $s$ 的时间，可以用 $t$ 时间( $t$ 为奇数)移动到本行或者相邻行，问方案数

那么就可以想到奇数往往是一个特殊的限制条件，奇数时间的跳跃可以看作 $2\times x+1$ 的跳跃

也就是说，我们将每一个点分为3个点，分别是入点，奇数点，偶数点

我们 $2\times x$ 的跳跃可以看作在奇数点和偶数点组成的环上来回走，这也就变成了类似于求两个点经过 $k$ 条边到达的方案数，就直接套用矩阵乘法

下面用一张图来说明一下拆点过后的连边方式：

![](https://s1.ax1x.com/2020/08/21/dYGt9U.png)

(2a有一个自环我画不出来了)

下面是代码：

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

int n,m,t;

int mod=30011;

struct M
{
  int s[160][160],r,c;
  void clear()
  {
    for(int i=1;i<=151;i++) for(int j=1;j<=151;j++) s[i][j]=0;
  }
}ans,Ye;

M operator * (const M &x,const M &y)
{
  M now;
  now.clear();
  now.r=x.r;
  now.c=y.c;
  for(int i=1;i<=x.r;i++)
  {
    for(int k=1;k<=x.c;k++)
    {
      for(int j=1;j<=y.c;j++)
      {
        now.s[i][j]=(now.s[i][j]+x.s[i][k]*y.s[k][j]%mod)%mod;
      }
    }
  }
  return now;
}

M ksm(M a,int b)
{
  M ans=a;
  b--;
  while(b)
  {
    if(b&1) ans=ans*a;
    a=a*a;
    b>>=1;
  }
  return ans;
}

int main()
{
  scanf("%d%d",&n,&m);
  ans.clear();
  ans.r=1;
  ans.c=3*n;
  ans.s[1][1]=1;
  Ye.clear();
  Ye.r=3*n;
  Ye.c=3*n;
  for(int i=1;i<=n;i++)
  {
    Ye.s[3*i-2][3*i-1]=1;
    Ye.s[3*i-1][3*i]=1;
    Ye.s[3*i][3*i-1]=1;
    Ye.s[3*i-2][3*i-2]=1;
    Ye.s[3*i][3*i-2]=1;
    if(i!=n) Ye.s[3*i-2][3*(i+1)-2]=1;
    if(i!=1) Ye.s[3*i-2][3*(i-1)-2]=1;
    if(i!=n) Ye.s[3*i][3*(i+1)-2]=1;
    if(i!=1) Ye.s[3*i][3*(i-1)-2]=1;
  }
  ans=ans*ksm(Ye,m-1);
  printf("%d\n",ans.s[1][3*n-2]);
}
```



---

## 作者：UltiMadow (赞：11)

### 前言

题解中各位大佬的方法好像都有点烦诶

窝来一个（个人感觉）比较简单的方法

---
### 解法
依旧是考虑dp方程

依旧是设$f[i][j]$为跳到$(i,j)$的方案数

先考虑一次只能往右跳一格的情况

那么方程很简单
$$
f[i][j]=f[i-1][j-1]+f[i-1][j]+f[i-1][j+1]
$$
那么如何加上一次往右跳任意奇数格呢？

我们发现除去只能往右跳一格的情况外，所有可以一步跳到$(i,j)$的都可以一步跳到$(i-2,j)$，所有可以一步跳到$(i-2,j)$的都可以一步跳到$(i,j)$

于是，我们的方程就出来了：
$$
f[i][j]=f[i-1][j-1]+f[i-1][j]+f[i-1][j+1]+f[i-2][j]
$$
直接递推的复杂度$O(nm)$，显然不可以接受

于是我们可以采用矩阵优化

构造矩阵也很简单（以$n=4$为例）
$$
\left(
\begin{matrix}
1&1&0&0&1&0&0&0\\
1&1&1&0&0&1&0&0\\
0&1&1&1&0&0&1&0\\
0&0&1&1&0&0&0&1\\
1&0&0&0&0&0&0&0\\
0&1&0&0&0&0&0&0\\
0&0&1&0&0&0&0&0\\
0&0&0&1&0&0&0&0
\end{matrix}
\right)
\times
\left(
\begin{matrix}
f[i-1][1]\\
f[i-1][2]\\
f[i-1][3]\\
f[i-1][4]\\
f[i-2][1]\\
f[i-2][2]\\
f[i-2][3]\\
f[i-2][4]
\end{matrix}
\right)

=
\left(
\begin{matrix}
f[i][1]\\
f[i][2]\\
f[i][3]\\
f[i][4]\\
f[i-1][1]\\
f[i-1][2]\\
f[i-1][3]\\
f[i-1][4]
\end{matrix}
\right)
$$
接下来，矩阵快速幂就好了qwq
### 代码
```cpp
#include<bits/stdc++.h>
#define p 30011
#define int long long
using namespace std;
int n,m;
struct Node
{
	int a[110][110];
	Node(int x){memset(a,0,sizeof(a));};
}e(0),base(0);
Node operator * (Node x,Node y)
{
	Node ret(0);
	for(int i=1;i<=2*n;i++)
		for(int j=1;j<=2*n;j++)
			for(int k=1;k<=2*n;k++)
				ret.a[i][j]=(ret.a[i][j]+x.a[i][k]*y.a[k][j]+p)%p;
	return ret;
}
Node operator ^ (Node x,int y)
{
	Node ret(0);ret=e;
	while(y)
	{
		if(y%2==1)ret=ret*x;
		x=x*x;y>>=1;
	}
	return ret;
}
signed main()
{
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=2*n;i++)e.a[i][i]=1;
	for(int i=1;i<=n;i++)
		for(int j=max(i-1,1ll);j<=min(i+1,n);j++)
			base.a[i][j]=1;
	for(int i=1;i<=n;i++)base.a[i][i+n]=1;
	for(int i=1;i<=n;i++)base.a[i+n][i]=1;
	if(m==2)//一波特判（应该很好理解）
	{
		if(n==1||n==2)
		{
			printf("1\n");
			return 0;
		}
		printf("0\n");
		return 0;
	}
	if(m==3)
	{
		if(n==1||n==3)
		{
			printf("1\n");
			return 0;
		}
		if(n==2)
		{
			printf("2\n");
			return 0;
		}
		printf("0\n");
		return 0;
	}
	base=base^(m-2);
	if(n==1)printf("%lld",(base.a[2*n][1]+base.a[2*n][2])%p);
	else if(n==2)printf("%lld",(base.a[2*n][1]*2+base.a[2*n][2]*2+base.a[2*n][n+1]+base.a[2*n][n+2])%p);
	else printf("%lld",(base.a[2*n][1]*2+base.a[2*n][2]*2+base.a[2*n][3]+base.a[2*n][n+1]+base.a[2*n][n+2]+p)%p);
	return 0;//输出时也要特判（边界各位自己思考吧qwq，其实还是挺坑的）
}
```

---

## 作者：BlackPanda (赞：7)

*[题目传送门](https://www.luogu.com.cn/problem/P3990)*

[**洛谷博客 LaTex 会炸掉，可在云剪贴板阅读。**](https://www.luogu.com.cn/paste/tsa1qu1n)

---
## Description

给定 $n$ 行 $m$ 列的棋盘，求出从左上到右下的方案数。

每次向右跳奇数列，且只能跳到本行或相邻行，不得跳出棋盘。

---
## Solution

- 首先考虑 DP，状态设 $dp_{i,j}$ 为从左上跳到第 $i$ 行 $j$ 列的方案数。

根据题意可得转移方程：$dp_{i,j} = dp_{i+1,j-1}+dp_{i-1,j}+dp_{i-1,j-1}+\sum\limits_{k=1}^{\left\lfloor{j/2}\right\rfloor}{dp_{i-1,j-2\times k-1}}$。

转移时间复杂度 $\mathcal{O}(m^2n)$，考虑优化。

- 因为每次可以往右跳任意奇数列，所以能**一步**跳到 $(i,j)$ 的点也一定可以一步跳到 $(i,j-2)$。

原方程可以优化为 $dp_{i,j}=dp_{i+1,j-1}+dp_{i-1,j}+dp_{i-1,j-1}+dp_{i,j-2}$，时间复杂度 $\mathcal{O}(mn)$，依然无法通过本题。

- 观察方程可以发现转移方程中第 $i$ 行的状态只与第 $i-1$ 行和 $i-2$ 行有关，所以我们可以构造矩阵优化转移。

例如 $n=3$ 时，需要构造矩阵使得从
$\begin{Bmatrix}
dp_{i-1,1} \\
dp_{i-1,2} \\
dp_{i-1,3} \\
dp_{i-2,1} \\
dp_{i-2,2} \\
dp_{i-2,3}
\end{Bmatrix}$ 
转移至 
$\begin{Bmatrix}
dp_{i,1} \\
dp_{i,2} \\
dp_{i,3} \\
dp_{i-1,1} \\
dp_{i-1,2} \\
dp_{i-1,3}
\end{Bmatrix}$。

构造矩阵为：

$\begin{Bmatrix}
\ 1\ 1\ 0\ 1\ 0\ 0\  \\
\ 1\ 1\ 1\ 0\ 1\ 0\ \\
\ 0\ 1\ 1\ 0\ 0\ 1\ \\
\ 1\ 0\ 0\ 0\ 0\ 0\ \\
\ 0\ 1\ 0\ 0\ 0\ 0\ \\
\ 0\ 0\ 1\ 0\ 0\ 0
\end{Bmatrix}$ 
$\times$
$\begin{Bmatrix}
dp_{i-1,1} \\
dp_{i-1,2} \\
dp_{i-1,3} \\
dp_{i-2,1} \\
dp_{i-2,2} \\
dp_{i-2,3}
\end{Bmatrix}$ 
$=$
$\begin{Bmatrix}
dp_{i,1} \\
dp_{i,2} \\
dp_{i,3} \\
dp_{i-1,1} \\
dp_{i-1,2} \\
dp_{i-1,3}
\end{Bmatrix}$

初始化 $dp_{1,1}\gets 1,dp_{1,2}\gets 1$，然后矩阵快速幂转移即可。

---
## Code

```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long
const int MOD = 30011;

int n, m;

struct mat {
    int x, y;
    int a[105][105];
    mat() { memset(a, 0, sizeof a); }
};

mat operator*(mat A, mat B) {
    mat C;
    C.x = A.x;
    C.y = B.y;
    for (int i = 1; i <= A.x; i++)
        for (int j = 1; j <= B.y; j++)
            for (int k = 1; k <= A.y; k++)
                C.a[i][j] = (C.a[i][j] % MOD + A.a[i][k] * B.a[k][j] % MOD) % MOD;
    return C;
}

mat I, A, f;

mat qpow(mat x, int y) {
    mat ret = I;
    while (y) {
        if (y & 1) ret = ret * x;
        x = x * x;
        y >>= 1;
    }
    return ret;
}

void init() {
    cin >> n >> m;
    I.x = I.y = 2 * n;
    for (int i = 1; i <= 2 * n; i++)
        I.a[i][i] = 1;
    A.x = A.y = 2 * n;
    for (int i = 1; i <= n; i++)
        A.a[i][i] = A.a[i + n][i] = A.a[i][i + n] = 1;
    for (int i = 1; i <= n; i++)
        A.a[i][i + 1 <= n ? i + 1 : n] = A.a[i][i - 1 > 0 ? i - 1 : i] = 1;
    f.x = 1, f.y = 2 * n;
    f.a[1][1] = f.a[1][n > 1 ? 2 : 1] = 1;
}

void solve() {
    A = qpow(A, m - 2);
    f = f * A;
    cout << f.a[1][n] % MOD << "\n";
    return;
}

signed main() {
    init();
    solve();
    return 0;
}
```

---

## 作者：quantum11 (赞：5)

设 $f[i][j]$ 表示跳到 $(i,j)$ 的方案数，那么
$$f[i][j]=\sum_{k=1}^{\frac{i}{2}} f[i-2k+1][j-1]+f[i-2k+1][j]+f[i-2k+1][j+1]$$

维护与当前列相差为偶数和相差为奇数的的两个前缀和

前缀和的转移：
$s1[i+1][j]=s2[i][j]+s1[i][j-1]+s1[i][j]+s1[i][j+1],s2[i+1][j]=s1[i][j]$

发现可以用矩乘优化

最后两前缀相减

```
#include<bits/stdc++.h>
using namespace std;
const int mo=30011;int n,m;
struct M{
    int w[105][105];
    M(){memset(w,0,sizeof(w));}
    int *operator[](int a){return w[a];}
    M operator*(M &a){
        M c;for(int i=1;i<=n;++i) for(int j=1;j<=n;++j) for(int k=1;k<=n;++k)
        c[i][j]=(c[i][j]+w[i][k]*a[k][j])%mo;return c;
    }
}p,x,y;
M pow(M a,int b){
    M c;for(int i=1;i<=n;++i) c[i][i]=1;
    for(;b;b>>=1,a=a*a) if(b&1) c=c*a;return c;
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i) p[i][i]=p[i+n][i]=p[i][i+n]=1;
    for(int i=1;i<n;++i) p[i+1][i]=p[i][i+1]=1;n<<=1,x=pow(p,m-2),y=x*p;
    return !printf("%d",(y[1][n>>1]-x[1][n]+mo)%mo);
}
```

---

## 作者：bztMinamoto (赞：5)

[传送门](https://www.luogu.org/problemnew/show/P3990)

首先不难设$f[i][j]$表示跳到$(i,j)$的方案数，那么不难得到如下转移
$$f[i][j]=\sum\limits_{k=1}^{\frac n2}f[i-2k+1][j-1]+f[i-2k+1][j]+f[i-2k+1][j+1]$$
然后维护两个前缀和$s1,s2$，分别表示与当前列相差为偶数的前缀和以及与当前列相差为奇数的前缀和，那么可以这样转移
$$s1[i+1][j]=s2[i][j]+s1[i][j-1]+s1[i][j]+s1[i][j+1]$$
$$s2[i+1][j]=s1[i][j]$$
然而直接转移会T，我们考虑用矩阵乘法来优化。构造一个$1*2n$的矩阵表示答案，左边表示$f[i]$，右边表示$f[i-1]$，那么要构造一个$2n*2n$的转移矩阵满足乘上之后左边变为$f[i+1]$，右边为$f[i]$，那么大概是这么个东西（$n=5$的情况，图片网上偷的）

![](https://i.loli.net/2018/12/03/5c04b7a66d37f.png)
然后最后前缀和减一减就好了
```
//minamoto
#include<bits/stdc++.h>
#define R register int
#define fp(i,a,b) for(R i=a,T=b+1;i<T;++i)
#define fd(i,a,b) for(R i=a,T=b-1;i>T;--i)
using namespace std;
const int P=30011;
int n,m;
struct node{
    int a[105][105];
    node(){memset(a,0,sizeof(a));}
    int *operator [](const R &x){return a[x];}
    node operator *(node &b){
        node res;
        fp(i,1,n)fp(j,1,n)fp(k,1,n)
        res[i][j]=(res[i][j]+a[i][k]*b[k][j])%P;
        return res;
    }
}I,A,B;
node ksm(node x,R y){
    node res;fp(i,1,n)res[i][i]=1;
    for(;y;y>>=1,x=x*x)if(y&1)res=res*x;
    return res;
}
int main(){
//	freopen("testdata.in","r",stdin);
    scanf("%d%d",&n,&m);
    fp(i,1,n)I[i][i]=I[i+n][i]=I[i][i+n]=1;
    fp(i,1,n-1)I[i+1][i]=I[i][i+1]=1;
    n<<=1,A=ksm(I,m-2),B=A*I;
    printf("%d\n",(B[1][n>>1]-A[1][n]+P)%P);
    return 0;
}
```

---

## 作者：Shawk (赞：4)

希丰展，看[博客](https://www.cnblogs.com/Z8875/p/13510450.html)
* 这题题意很清楚了，DP也很容易想到，$f_{i,j}$ 表示到达第i列第j行的方案数，将起点方案数设为 1，每个点的方案数由可以过来的点转移，一看数据范围，n 就 50，m 最大 1e9 ，这几乎就可以想到是矩阵快速幂优化了，我们可以一步一步分析。

* 首先不难得出一个 $O(n^3)$ 的写法。（20pts）
```cpp
    f[1][1] = 1;
    for (int i = 2; i <= m; ++i)
        for (int j = 1; j <= n; ++j)
            for (int k = i - 1; k >= 1; k -= 2)
                f[i][j] = (f[i][j] + f[k][j-1] + f[k][j] + f[k][j+1]) % M;
```
* 注意到这只是求前面的和，限制条件也只有只能从奇数行转移，这样让 $f_{i,j}$ 记录上奇数行的和就能优化到 $O(n^2$。（50pts）

  * 这里的f数组要同时记录前缀和，所以最终答案是类似区间求和的形式：$f_{m,n} - f_{m-2,n}$

  * 为了方便最后矩阵的写法，又因为他是由倒数第二行最后两列转移过来，就直接输出 $f_{m-1,n}+f_{m-1,n-1}$ 
  
    ```cpp
    f[1][1] = 1;
    for (int i = 2; i < m; ++i)
        for (int j = 1; j <= n; ++j)
            f[i][j] = (f[i-1][j] + f[i-1][j-1] + f[i-1][j+1] + f[i-2][j]) % M;
    printf("%d\n", (f[m-1][n] + f[m-1][n-1]) % M);
    ```
* 发现第 i 列只由第 i-1 列和 i-2 列转移过来的，而且列数又那么大，考虑矩阵快速幂优化：
  * 可以类比斐波那契数列的写法，将 $f_{i.k}$和$f_{i-1,k}(k\in {1,...,n})$的状态压成一个 $1\times 2n$ 的矩阵，乘上一个转移矩阵，得到 $f_{i+1.k}$和$f_{i,k}(k\in {1,...,n})$的状态，转移矩阵根据上面第二个解法的转移方程构造，还是举 n=4 的例子

$$\begin{bmatrix}
f_{i,1} & f_{i,2} &f_{i,3} &f_{i,4} &f_{i-1,1} &f_{i-1,2} &f_{i-1,3} &f_{i-1,4}
\end{bmatrix}
\ast 
\begin{bmatrix}
1 & 1 &  0& 0 &  1& 0 &0  & 0\\ 
 1&  1& 1 &  0& 0 &1  & 0 &0 \\ 
0 & 1 &  1&  1& 0 & 0 & 1 & 0\\ 
0 & 0 & 1 & 1 &0  & 0 & 0 &1 \\ 
1 & 0 &0  & 0 & 0 &0  & 0 &0 \\ 
 0& 1 &  0&  0&  0& 0&  0& 0\\ 
 0&  0&  1&  0& 0 &  0&0&0 \\ 
 0& 0 &  0& 1 & 0 & 0 & 0 & 0
\end{bmatrix}

=
\begin{bmatrix}
f_{i+1,1} & f_{i+1,2} &f_{i+1,3} &f_{i+1,4} &f_{i,1} &f_{i,2} &f_{i,3} &f_{i,4}
\end{bmatrix}$$
~~这个式子有亿点长啊~~

转移矩阵：
$$\begin{bmatrix}
1 & 1 &  0& 0 &  1& 0 &0  & 0\\ 
 1&  1& 1 &  0& 0 &1  & 0 &0 \\ 
0 & 1 &  1&  1& 0 & 0 & 1 & 0\\ 
0 & 0 & 1 & 1 &0  & 0 & 0 &1 \\ 
1 & 0 &0  & 0 & 0 &0  & 0 &0 \\ 
 0& 1 &  0&  0&  0& 0&  0& 0\\ 
 0&  0&  1&  0& 0 &  0&0&0 \\ 
 0& 0 &  0& 1 & 0 & 0 & 0 & 0
\end{bmatrix}$$
初始矩阵
$$\begin{bmatrix}
1 & 1 & 0 & 0 & 1 & 0 & 0 & 0
\end{bmatrix}$$
* 需要注意的几点：
  1. 因为矩阵无法处理 $m\le 2$ 的情况，所以需要特判。只有 $f_{1,1},f_{1,2},f_{2,2}$值为1,其他情况都是0.
  1. 此解法只处理了 $n>1$ 的情况，对于 $n=1$ 的情况打表发现可以转换成斐波那契数列，而且此时转移矩阵与求斐波那契数列的转移矩阵也很想，也特判一下就好了。
* 接下来就是实现，具体看代码。

```cpp
#include <cstdio>
#include <cstring>
using namespace std;
const int N = 105, M = 30011;

int n, n2, m;
struct Matrix {
    int a[N][N];
    Matrix () {
        memset(a, 0, sizeof(a));
    }
    int *operator [] (const int &i) {
        return a[i];
    }//重载方括号运算符，写起来方便
    Matrix operator * (const Matrix &b) {
        Matrix c;
        for (int i = 1; i <= n2; ++i)
            for (int j = 1; j <= n2; ++j)
                for (int k = 1; k <= n2; ++k)
                    (c.a[i][j] += a[i][k] * b.a[k][j] % M) %= M;
        return c;
    }//重载乘号
    void Print() {
        for (int i = 1; i <= n2; ++i, puts(""))
            for (int j = 1; j <= n2; ++j)
                printf("%d ", a[i][j]);
        puts("");
    }//调试输出用
}a, b, c;

Matrix Pow(Matrix a, int k) {
    Matrix ans = a; k--;
    for (; k; k >>= 1, a = a * a)
        if (k & 1) ans = ans * a;
    return ans;
}//快速幂

int main() {
    scanf("%d%d", &n, &m);
    if (m <= 2) {
        if (n <= 2 && m <= n) puts("1");
        else puts("0");
        return 0;
    }//特判情况1
    n2 = n << 1;
    for (int i = 1; i <= n; ++i) {//构造转移矩阵
        a[i][i-1] = a[i][i] = a[i][i+n] = a[i+n][i] = 1;
        if (i != n) a[i][i+1] = 1;
    }
    b = Pow(a, m - 2);
    if (n == 1) return printf("%d\n", b[1][1]), 0;//特判情况2
    int s1 = (b[1][n2-1] + b[2][n2-1] + b[n+1][n2-1]) % M;
    int s2 = (b[1][n2] + b[2][n2] + b[n+1][n2]) % M;
    //根据初始矩阵和快速幂后的转移矩阵求得目标矩阵的有用值
    printf("%d\n", (s1 + s2) % M);
    //s1是f[m-1][n-1]，s2是f[m-1][n]，加起来就是答案
    return 0;
}
```

---

## 作者：ShwStone (赞：3)

## 思路分析

本篇题解要求一定线性代数基础。

用一个向量 $p_i \in \mathbb{N^n}$ 表示从 $(0,0)$ 到第 $i$ 列的各点的方案数。用一个矩阵 $D$ 来表示某一列对另一列的贡献： $p_j \leftarrow p_j + Dp_i$，其中 $j-i$ 为奇数。考虑到马只能上下跳一格，转移矩阵 $D$ 应该长这样（以 $n=4$ 为例）：

$$
\begin{bmatrix}
1 & 1 & 0 & 0\\
1 & 1 & 1 & 0\\
0 & 1 & 1 & 1\\
0 & 0 & 1 & 1\\
\end{bmatrix}
$$

用数学语言描述，就是主对角线以及其上下两条对角线为 $1$，其余为全 $0$。

另外，我们约定仅主对角线全 $1$ 的单位矩阵为 $I$。

根据上面的分析，我们可以写出向量形式的 dp 转移方程：

$$
p_i=\sum_{k=0}^{\lfloor\frac{i}{2}\rfloor}{Dp_{i-2k-1}}
=D\sum_{k=0}^{\lfloor\frac{i}{2}\rfloor}{p_{i-2k-1}}
$$

如何优化呢？容易想到根据 $i$ 的奇偶分别求和。用 $S_i$ 表示比 $i$，且与 $i$ 奇偶性相同的所有 $p_j$ 之和。则有：

$$
S_i=\sum_{k=0}^{\lfloor\frac{i+1}{2}\rfloor}{p_{i-2k}}
$$

现在，我们发现：

$$
\begin{aligned}
p_i&=DS_{i-1} \\
S_i&=S_{i-2}+p_j
\end{aligned}
$$

所以有：

$$
S_i=DS_{i-1}+S_{i-2}
$$

熟悉的感觉回来了！这玩意就是斐波那契数列的变形！直接上矩阵快速幂优化（没错，用矩阵优化向量转移）：

$$
\begin{bmatrix}
S_i\\
S_{i-1}
\end{bmatrix}

=

\begin{bmatrix}
D & I \\
I & 0
\end{bmatrix}

\begin{bmatrix}
S_{i-1}\\
S_{i-2}
\end{bmatrix}

=

\begin{bmatrix}
D & I \\
I & 0
\end{bmatrix} ^ {i-2}

\begin{bmatrix}
S_{2}\\
S_{1}
\end{bmatrix}
$$

虽然 $D$ 作为矩阵元素本身也是矩阵，但这并不影响优化。当然，矩阵乘法的性质告诉我们将 $D$ 和 $p$ 这类矩阵和向量展开成一个个的元素也不影响正确性，但是就显得很繁琐，就不在这里展开了。

## AC 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int mod = 30011;

int n, m;

vector<int> dp, zero;
vector<vector<int> > trans, ans;

vector<vector<int> > multi(const vector<vector<int> > &a, const vector<vector<int> > &b) {
    vector<vector<int> > res;
    res.resize(n * 2, zero);
    for (int i = 0; i < 2 * n; i++) {
        for (int j = 0; j < 2 * n; j++) {
            for (int k = 0; k < 2 * n; k++) {
                (res[i][j] += a[i][k] * b[k][j]) %= mod;
            }
        }
    }
    return res;
}

int main() {
    scanf("%d %d", &n, &m);
    m -= 2;
    zero.resize(n * 2, 0);

    dp = zero;
    dp[0] = dp[1] = dp[n] = 1;

    trans.resize(n * 2, zero);
    ans.resize(n * 2, zero);

    for (int i = 0; i < n; i++) {
        if (i - 1 >= 0) trans[i][i - 1] = 1;
        if (i + 1 < n) trans[i][i + 1] = 1;
        trans[i][i] = 1;
        trans[i][i + n] = 1;
        trans[i + n][i] = 1;

        ans[i][i] = ans[i + n][i + n] = 1;
    }

    while (m) {
        if (m & 1LL) ans = multi(ans, trans);
        trans = multi(trans, trans);
        m >>= 1;
    }
    //n - 1, n - 2
    int res = 0;
    for (int i = 0; i < n * 2; i++) {
        //注意 n==1 时候的细节
        if (n == 1) (res += ans[2 * n - 1][i]) %= mod;
        else (res += (ans[2 * n - 1][i] + ans[2 * n - 2][i]) * dp[i]) %= mod;    
    }
    printf("%d\n", res);
    return 0;
}
/*
展开后的矩阵：
1 1 0 0 1 0 0 0
1 1 1 0 0 1 0 0
0 1 1 1 0 0 1 0
0 0 1 1 0 0 0 1
1 0 0 0 0 0 0 0
0 1 0 0 0 0 0 0
0 0 1 0 0 0 0 0
0 0 0 1 0 0 0 0 
*/
```

---

## 作者：_Anchor (赞：3)

# 题意

[题目链接](https://www.luogu.com.cn/problem/P3990)

![](https://img2020.cnblogs.com/blog/2013965/202012/2013965-20201206181446603-2095763553.png)

# 分析

## DP部分

这题乍一看是个水题...

可以很快看出$DP$的做法

设$dp[i][j]$表示到了第$i$行第$j$列的方案数

那么$dp$转移方程很好写了：

$$
dp[i][j]=dp[i-1][j]+dp[i-1][j]+dp[i-1][j+1]+dp[i-2][j]
$$

可能唯一的难点在于这个第四项吧...我这里解释一下这个方程的含义

我们当这个位置可能由前一列的上一个，前一列的这个，前一列的下一个一步到达（因为限制就是每次只能移动一行或者不动）

同时我们考虑一步到达这个位置的其它点，容易发现这些点都是可以一步到达$(i-2,j)$的，所以我们把剩下的点的贡献相当于全部都算在了$(i-2,j)$上面，而没有剩下的点一定存在于前面三项加上的贡献当中

然后这个题的$O(nm)$算法就这样做出来了

## 矩阵快速幂

但是我们看到数据范围时才知这题并不简单...暗藏杀机...

$m\leq 10^9$ !!!

但是我们观察一下上面的$DP$转移方程，我们可以发现：对于每一列来说，当前这一项只会被前一项和前两项统计到

所以我们可以考虑 ~~状压~~ 矩阵快速幂优化$DP$

我们矩阵要记录的就是上一行和上两行的状态，共$100*100$

然后构造的状态转移矩阵就按照$DP$方程那样把初始矩阵赋一下值就可以了，最后答案也不难得出，见代码即可

时间复杂度$O(nlogm*(2n)^3)$，足以通过此题

# 代码

窝是看了[这位巨佬的博客](https://www.luogu.com.cn/blog/106024/solution-p3990)才学会的，如有雷同只是看了就感觉写的都一样了QWQ

```cpp
#include<bits/stdc++.h>
using namespace std;
template <typename T>
inline void read(T &x){
	x=0;char ch=getchar();bool f=false;
	while(!isdigit(ch)){if(ch=='-'){f=true;}ch=getchar();}
	while(isdigit(ch)){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	x=f?-x:x;
	return ;
}
template <typename T>
inline void write(T x){
	if(x<0) putchar('-'),x=-x;
	if(x>9) write(x/10);
	putchar(x%10^48);
	return ;
}
const int N=105,MOD=30011;
int n,m;
#define inc(a,b) (a+b>=MOD?a+b-MOD:a+b)
struct Matrix{
	int a[N][N];
	Matrix(){memset(a,0,sizeof(a));}
	Matrix operator *(Matrix B){
		Matrix C;
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				for(int k=1;k<=n;k++){
					C.a[i][j]=inc(C.a[i][j],a[i][k]*B.a[k][j]%MOD);
				}
			}
		}
		return C;
	}
};
Matrix QuickPow(Matrix A,int y){
	Matrix res;
	for(int i=1;i<=n;i++) res.a[i][i]=1;
	while(y){
		if(y&1) res=res*A;
		A=A*A;
		y>>=1;
	}
	return res;
}
Matrix base;
int ans1,ans2;
int main(){
	read(n),read(m);
	if(m<=2){
		if(n<=2&&m<=n) puts("1");
		else puts("0");
		return 0;
	}
	for(int i=1;i<=n;i++){
        base.a[i][i-1]=base.a[i][i]=base.a[i][i+n]=base.a[i+n][i]=1;
        if(i!=n)base.a[i][i+1]=1;
    }
    n<<=1;
    base=QuickPow(base,m-2);
    n>>=1;
    if(n==1){
    	write(base.a[1][1]);
    	return 0;
	}
	int n2=n<<1;
	ans1=(base.a[1][n2-1]+base.a[2][n2-1]+base.a[n+1][n2-1])%MOD,ans2=(base.a[1][n2]+base.a[2][n2]+base.a[n+1][n2])%MOD;
	write(inc(ans1,ans2)%MOD);
	return 0;
}
```

---

## 作者：Equfix (赞：2)

【算法一：~~暴力~~DP】

~~一看到这个题，就觉得是个DP题~~。

我们用 $f_{i,j}$ 表示马走到 $( i,j )$ 的方案数。

方程：$f_{k,i} = \sum_{i\not\equiv j \pmod{2},j < i}f_{k-1,j}+f_{k,j}+f_{k+1,j} $。

时间复杂度 $O(nm^{2})$ ，期望得分 $10$ 分。

【算法二：~~带优化的~~DP】

我们发现$f_{k,i-2}=\sum_{i\not\equiv j \pmod{2},j < i-2}f_{k-1,j}+f_{k,j}+f_{k+1,j}$。

所以DP式变为$f_{k,i} = f_{k-1,i-1}+f_{k,i-1}+f_{k+1,i-1}+f_{k,i-2} $。

时间复杂度 $O(nm)$,期望得分 $50$ 分。

【算法三：用矩阵快速幂优化】

我们发现 $f_{i}$ 只与 $f_{i-1}$ 和 $f_{i-2}$ 有关，

于是可以构造一个矩阵：（例子为 $n = 3$）

$\begin{bmatrix}
f_{1,i-1} &f_{2,i-1} &f_{3,i-1} &f_{1,i-2} &f_{2,i-2} &f_{3,i-2}
\end{bmatrix} \times \begin{bmatrix}
1  &1  &0  &1  &0  &0 \\
1  &1  &1  &0  &1  &0 \\
0  &1  &1  &0  &0  &1 \\
1  &0  &0  &0  &0  &0 \\
0  &1  &0  &0  &0  &0 \\
0  &0  &1  &0  &0  &0
\end{bmatrix} = \begin{bmatrix}
f_{1,i} &f_{2,i} &f_{3,i} &f_{1,i-1} &f_{2,i-1} &f_{3,i-1}
\end{bmatrix}
$
初始化 $f_{1,2}\gets 1,f_{2,2}\gets 1$,对中间矩阵进行 $m-2$ 次快速幂。

贴出代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=30011;
class mat{
    private:
        int n,m;
	
    public:
        unsigned long long int a[101][101];
        mat(int x,int y,bool flag=0){
            memset(a,0,sizeof(a));
            n=x;
            m=y;
            if(flag&&n==m)
                for(int i=1;i<=n;i++)
                    a[i][i]=1;
        }
        mat operator+(mat &b){
            if(b.n==n&&b.m==m){
                mat ans(n,m);
                for(int i=1;i<=n;i++)
                    for(int j=1;j<=n;j++)
                        ans.a[i][j]=b.a[i][j]+a[i][j],ans.a[i][j]%=mod;
                return ans;
            }
        }
        mat operator*(mat &b){//矩阵乘法
            if(b.n==m){
                mat ans(n,b.m);
                for(int i=1;i<=n;i++)
                    for(int j=1;j<=b.m;j++)
                        for(int k=1;k<=m;k++)
                            ans.a[i][j]=(ans.a[i][j]+(long long )a[i][k]*b.a[k][j]%mod)%mod;
                return ans;
            }
        }
        mat pw(unsigned long long int t){
            if(n==m){
                mat re(n,n,1);
                if(t==0)
                    return re;
                if(t%2)re=re*(*this);
                mat ans(n,n);
                ans=pw(t/2);
                re=re*ans*ans;
                return re;
            }
        }
        void display(){
            for(int i=1;i<=n;i++){
                for(int j=1;j<=m;j++)
                    printf("%d ",a[i][j]);
                printf("\n");
            }
        }
};
int main(){
    long long int n,m;
    cin>>n>>m;
    if(n==0){
        cout<<"0";
        return 0;
    }
    mat x(1,2*n);
    x.a[1][1]=x.a[1][2]=1;//初始化
    mat A(2*n,2*n);
    for(int i=1;i<=n;i++){
        A.a[i-1>0?i-1:i][i]=1;
        A.a[i][i]=1;
        A.a[i+1<=n?i+1:i][i]=1;
        A.a[i+n][i]=1;
    }
    for(int i=1;i<=n;i++){
        A.a[i][i+n]=1;
    }//中间矩阵的初始化
    A=A.pw(m-2);//快速幂
    x=x*A;
    cout<<x.a[1][n];
    return 0;
}
```

时间复杂度 $O(n^{3}log_{2}m)$,期望得分 $100$ 分，实际得分 $90$ 分。

**错在哪了？**

【正解：特判（~~不是特判测试点~~）】

~~WA掉第六个点的我好难受~~，

~~一通乱试后~~，我找到了一个特殊情况：

当 $n=1$ 时，如果~~草率地~~进行 `x.a[1][1]=x.a[1][2]=1;` 的话，会出现初始的情况错误：

$f_{1,2}=1,f_{1,1}=1$（我应该是 $0$ 啊）。

加上这一条特判，满分代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=30011;
class mat{
    private:
        int n,m;
	
    public:
        unsigned long long int a[101][101];
        mat(int x,int y,bool flag=0){
            memset(a,0,sizeof(a));
            n=x;
            m=y;
            if(flag&&n==m)
                for(int i=1;i<=n;i++)
                    a[i][i]=1;
        }
        mat operator+(mat &b){
            if(b.n==n&&b.m==m){
                mat ans(n,m);
                for(int i=1;i<=n;i++)
                    for(int j=1;j<=n;j++)
                        ans.a[i][j]=b.a[i][j]+a[i][j],ans.a[i][j]%=mod;
                return ans;
            }
        }
        mat operator*(mat &b){//矩阵乘法
            if(b.n==m){
                mat ans(n,b.m);
                for(int i=1;i<=n;i++)
                    for(int j=1;j<=b.m;j++)
                        for(int k=1;k<=m;k++)
                            ans.a[i][j]=(ans.a[i][j]+(long long )a[i][k]*b.a[k][j]%mod)%mod;
                return ans;
            }
        }
        mat pw(unsigned long long int t){
            if(n==m){
                mat re(n,n,1);
                if(t==0)
                    return re;
                if(t%2)re=re*(*this);
                mat ans(n,n);
                ans=pw(t/2);
                re=re*ans*ans;
                return re;
            }
        }
        void display(){
            for(int i=1;i<=n;i++){
                for(int j=1;j<=m;j++)
                    printf("%d ",a[i][j]);
                printf("\n");
            }
        }
};
int main(){
    long long int n,m;
    cin>>n>>m;
    if(n==0){
        cout<<"0";
        return 0;
    }
    mat x(1,2*n);
    x.a[1][1]=x.a[1][n>1?2:1]=1;//初始化
    mat A(2*n,2*n);
    for(int i=1;i<=n;i++){
        A.a[i-1>0?i-1:i][i]=1;
        A.a[i][i]=1;
        A.a[i+1<=n?i+1:i][i]=1;
        A.a[i+n][i]=1;
    }
    for(int i=1;i<=n;i++){
        A.a[i][i+n]=1;
    }//中间矩阵的初始化
    A=A.pw(m-2);//快速幂
    x=x*A;
    cout<<x.a[1][n];
    return 0;
}
```


【总结】

做题过程：普通DP$\to$ ~~一看就TLE~~$\to$ 优化DP$\to$ ~~继续TLE~~$\to$ 想到矩阵优化 $\to$ 没有特判Orz$\to$ 加上特判 $\to$AC。

---

## 作者：ButterflyDew (赞：1)

发现我的做法有点诡异...

思路：首先我们只考虑**从左边某一列的转移**，显然可以构造这样的一个转移矩阵

$$\begin{bmatrix}1&1&0&0&\cdots&0&0&0\\1&1&1 &0&\cdots&0&0&0\\0&1&1 &1&\cdots&0&0&0\\ \vdots&\vdots&\vdots&\vdots&\ddots&\vdots&\vdots&\vdots\\0&0&0&0&\cdots&1&1&1\\0&0&0&0&\cdots&0&1&1\end{bmatrix}$$

然后设这个转移矩阵为$T$，设第$i$列的答案矩阵为$A_i$

则$A_n=T*(A_{n-1}+A_{n-3}+A_{n-5}+\dots)$

$A_{n-2}=T*(A_{n-3}+A_{n-5}+A_{n-7}+\dots)$

那么有$A_n=T*A_{n-1}+A_{n-2}$，发现这是个递推，于是再次构造矩阵加速转移

$$\begin{bmatrix}T&I\\I&O\end{bmatrix}\begin{bmatrix}A_n\\A_{n-1}\end{bmatrix}=\begin{bmatrix}A_{n+1}\\A_{n}\end{bmatrix}$$

$T$是原转移矩阵，$I$是单位矩阵，$O$是0矩阵

然后大力搞就行了，复杂度$O(2^3n^3\log t)$

注意一点$A_3=TA_2$不符合递推式

------

**Code:**

```cpp
#include <cstdio>
#include <cstring>
const int mod=30011;
int n,m;
struct matrix1
{
    int dx[52][52];
    matrix1(){memset(dx,0,sizeof(dx));}
    matrix1 friend operator *(matrix1 n1,matrix1 n2)
    {
        matrix1 n3;
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                for(int k=1;k<=n;k++)
                    (n3.dx[i][j]+=n1.dx[i][k]*n2.dx[k][j])%=mod;
        return n3;
    }
    matrix1 friend operator +(matrix1 n1,matrix1 n2)
    {
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                (n1.dx[i][j]+=n2.dx[i][j])%=mod;
        return n1;
    }
};
struct matrix2
{
    matrix1 dx[3][3];
    matrix2(){matrix1();}
    matrix2 friend operator *(matrix2 n1,matrix2 n2)
    {
        matrix2 n3;
        for(int i=1;i<=2;i++)
            for(int j=1;j<=2;j++)
                for(int i1=1;i1<=n;i1++)
                    for(int j1=1;j1<=n;j1++)
                        n3.dx[i][j].dx[i1][j1]=0;
        for(int i=1;i<=2;i++)
            for(int j=1;j<=2;j++)
                for(int k=1;k<=2;k++)
                    n3.dx[i][j]=n3.dx[i][j]+n1.dx[i][k]*n2.dx[k][j];
        return n3;
    }
}S,T,F;
int main()
{
    scanf("%d%d",&n,&m);
    S.dx[1][1].dx[1][1]=S.dx[1][1].dx[2][1]=1;
    for(int i=1;i<=n;i++)
    {
        T.dx[1][2].dx[i][i]=T.dx[2][1].dx[i][i]=1;
        T.dx[1][1].dx[i][i]=T.dx[1][1].dx[i][i-1]=T.dx[1][1].dx[i][i+1]=1;
    }
    if(m==2) return printf("%d\n",S.dx[1][1].dx[n][1]),0;
    m-=3,F=T;
    while(m)
    {
        if(m&1) F=F*T;
        T=T*T;
        m>>=1;
    }
    S=F*S;
    printf("%d\n",S.dx[1][1].dx[n][1]);
    return 0;
}
```

---

## 作者：数学系 (赞：1)

这题矩阵快速幂......
先考虑动态规划：  
f[i][j]表示到达第i列第j列的方法数，
显然有：  

```
       i/2
f[i][j]=∑ f[i+1-2*k][j]+f[i+1-2*k][j+1]+f[i+1-2*k][j-1]
       k=1 
```

不过这样做的算法效率......有点低！  
搬运一种常见的做法，更好的帮助大家学习。   
设f1[i][j]为与当前列i相差奇数列的方法数的前缀和，  
设f2[i][j]为与当前列i相差偶数列的方法数的前缀和。  

根据上面可以推出：  
f2[i+1][j]=f1[i][j]+f2[i][j]+f2[i][j-1]+f2[i][j+1]  
f1[i+1][j]=f2[i][j]  
然后就可以用矩阵乘法做。
这个矩阵构造起来稍微费点力气，这里给出一个  
当n=4时：    

```
1 1 0 0  1 0 0 0  
1 1 1 0  0 1 0 0  
0 1 1 1  0 0 1 0  
0 0 1 1  0 0 0 1  
    
1 0 0 0  0 0 0 0  
0 1 0 0  0 0 0 0  
0 0 1 0  0 0 0 0  
0 0 0 1  0 0 0 0  
```
    
P.S.将计算偶数列与计算奇数列的矩阵拼接了起来，得到了一个边长为2n的矩阵。  
给出代码：    

```cpp
#include <iostream>
#include <cstring>

using namespace std;

const int maxn=1007;
const int mod=30011;

long long n,m;

long long A[maxn][maxn];
long long B[maxn][maxn];
long long C[maxn][maxn];
long long I[maxn][maxn]={};

void matrix(long long a[][maxn],long long b[][maxn])
{
	memset(A,0,sizeof(A));
	for(long long i=1;i<=n;i++)
	    for(long long j=1;j<=n;j++)
	        for(long long k=1;k<=n;k++)
	            A[i][j]=(A[i][j]+a[i][k]*b[k][j])%mod;
	for(long long i=1;i<=n;i++)
	    for(long long j=1;j<=n;j++)
	        a[i][j]=A[i][j];
}

void pow(long long a[][maxn],long long num)
{
	memset(A,0,sizeof(A));
	num--;
	for(long long i=1;i<=n;i++)
	    for(long long j=1;j<=n;j++)
	        B[i][j]=I[i][j];
	while(num)
	{
		if(num&1)
		    matrix(B,a);
		matrix(a,a);
		num=num>>1;
	}
}

int main()
{
	cin>>n>>m;
	for(long long i=1;i<=n;i++)
		I[i][i]=I[i+n][i]=I[i][i+n]=1;
	for(long long i=1;i<n;i++)
	    I[i+1][i]=I[i][i+1]=1;
	n=n<<1;
	for(long long i=1;i<=n;i++)
	    for(long long j=1;j<=n;j++)
	        C[i][j]=I[i][j];
	pow(I,m-2);
	/*
	for(long long i=1;i<=n;i++)
	{
	    for(long long j=1;j<=n;j++)
		    cout<<B[i][j]<<' ';
		cout<<endl;
	}
	*/
	matrix(C,B);
	cout<<(C[1][n>>1]-B[1][n]+mod)%mod<<endl; 
	return 0;
} 

```  
  
注意因为维护的是前缀和，还要相减一下。



---

## 作者：Φρανκ (赞：0)

题意：一枚棋子一步可以在竖直方向上移动至多一行并向右移动奇数步。求它从 $(1,1)$ 走到 $(n,m)$ 的方法数。

核心思想：矩阵优化 DP

解：

令 $f(i,j)$ 表示到达 $(i,j)$ 的方法数，则有 $f(i,j)=\Sigma_{p=i-1}^{i+1}\Sigma_{q=1}^{\lfloor\frac{j}{2}\rfloor}f(p,j-2q)$。注意到 $f(i,j-2)=\Sigma_{p=i-1}^{i+1}\Sigma_{q=1}^{\lfloor\frac{j}{2}\rfloor-1}f(p,j-2q)$，则有 $f(i,j)=f(i-1,j-1)+f(i,j-1)+f(i+1,j-1)+f(i,j-2)$。

以 $O(mn)$ 的复杂度无法通过本题，故构造矩阵 $A$ 使得 $[f(1,j),...f(m,j),f(1,j-1)...,f(m,j-1)]A=[f(1,j+1),...f(m,j+1),f(1,j)...,f(m,j)]$。可以发现对于给定的 $m$，$A$ 应该如下构造：左侧 $m$ 列中每列在转移式对应的位置有 $3\sim 4$ 个 $1$，右侧 $m$ 列中的第 $m+i$ 列有且仅有第 $i$ 行为 $1$。以 $m=4$ 为例：

$$   
\left[               
  \begin{array}{cccccccc}   
    1&1&0&0&1&0&0&0\\
    0&1&1&0&0&1&0&0\\
    0&1&1&1&0&0&1&0\\
    0&0&1&1&0&0&0&1\\
    1&0&0&0&0&0&0&0\\
    0&1&0&0&0&0&0&0\\
    0&0&1&0&0&0&0&0\\
    0&0&0&1&0&0&0&0\\
  \end{array}
\right]
$$

随后运用矩阵快速幂计算 $[1,0,...,0]M^{m-1}$ 的第 $1$ 行第 $m$ 列是似是而非的解，这是因为在计算中 $f(3,1)$ 由于转移式将 $\Sigma_{p=0}^{2}\Sigma_{q=1}^{-1}f(p,1-2q)=0$ 替换为 $f(1,1)=1$ 而多算了 $1$。有 $[1,0,...,0]M^2=[3,2,1,0,...0,1,0,...,0]$，故正确答案为 $[2,2,1,0,...0,1,0,...,0]M^{m-3}$ 的第 $1$ 行第 $m$ 列。注意对于行数或列数过小的矩阵要添加特判。

代码：
```
#include <bits/stdc++.h>
using namespace std;
struct mat
{
	long long a[101][101];
}a, u, res, bla;//初始矩阵，单位矩阵，结果矩阵，空白矩阵
const long long mod=30011;
long long n, m;
mat mu(mat x, mat y)
{
	mat r=bla;
	for(int i=1; i<=2*n; i++)
		for(int j=1; j<=2*n; j++)
			for(int k=1; k<=2*n; k++)
				r.a[i][j]=(r.a[i][j]+x.a[i][k]*y.a[k][j])%mod;
	return r;
}//矩阵乘（不初始化r会WA）
mat qp(mat x, long long y)
{
	if(y==0)
		return u;
	mat t=qp(x, y/2);
	if(y%2==0)
		return mu(t, t);
	else
		return mu(t, mu(t, x));
}//快速幂
int main()
{
	cin>>n>>m;
	for(int i=1; i<=2*n; i++)
		u.a[i][i]=1;
	for(int i=1; i<=n; i++)
	{
		a.a[i][i]=1;
		a.a[i][i+n]=1;
		a.a[i+n][i]=1;
	}
	for(int i=1; i<n; i++)
	{
		a.a[i][i+1]=1;
		a.a[i+1][i]=1;
	}//构造矩阵
	res=qp(a, m-3);//计算
//	for(int i=1; i<=2*n; i++)
//	{
//		for(int j=1; j<=2*n; j++)
//			cout<<res.a[i][j]<<" ";
//		cout<<endl;
//	}
	if(m==1)
		if(n==1)
			cout<<1;
		else
			cout<<0;
	else if(m==2)
		if(n<=2)
			cout<<1;
		else
			cout<<0;//短矩阵特判
	else if(n==1)
		cout<<(res.a[1][n]+res.a[n+1][n])%mod;
	else if(n==2)
		cout<<(2*res.a[1][n]+2*res.a[2][n]+res.a[n+1][n]+res.a[n+2][n])%mod;//窄矩阵特判
	else
		cout<<(2*res.a[1][n]+2*res.a[2][n]+res.a[3][n]+res.a[n+1][n]+res.a[n+2][n])%mod;//正常输出
	return 0;
}
```

---

## 作者：Gmt丶FFF (赞：0)

首先可以想到一个位置状态会从与自己相差不到一行，相差列为奇数的列转移过来，那么很明显对于每一行可以求奇数位置或是偶数位置的前缀和。

设 $f_{i,j}$ 为跳到第 $i$ 行第 $j$ 列的方案数，$g_{i,j}$ 代表第 $i$ 行第 $j$ 列的 $\sum_{k\ne j(\bmod 1)}f_{i,k}$，即同行与自己相差奇数列的前缀和。

那么可以写出转移方程。

$f_{i,j}=g_{i-1,j-1}+g_{i,j-1}+g_{i+1,j-1}$

$g_{i,j}=g_{i-2,j}+f_{i,j}$

这样就可以矩阵加速了，初始矩阵从上到下分别为 $f_{k,j}$，$g_{k,j}$ 和 $g_{k,j-1}(1\le k\le n)$。

剩下的转移矩阵在对应位置上加 $1$ 即可，对此操作如果有疑问可以多去复习下矩阵快速幂。

复杂度：$O(27n^3\times \log(m))$。

```
#include<iostream>
#include<cstdio>
using namespace std;
const int mod=30011;
const int N=105;
struct matrix
{
	int x,y,a[155][155];
	void init()
	{
		for(int i=1;i<=x;i++)for(int j=1;j<=y;j++)a[i][j]=0;
	}
};
matrix operator *(matrix fi,matrix se)
{
	matrix th;
	th.x=fi.x,th.y=se.y;
	th.init();
	for(int i=1;i<=fi.x;i++)
	{
		for(int j=1;j<=se.y;j++)
		{
			for(int k=1;k<=fi.y;k++)
			{
				th.a[i][j]+=fi.a[i][k]*se.a[k][j];
				th.a[i][j]%=mod;
			}
		}
	}
	return th;
}
matrix quick_pow(matrix x,int y)
{
	matrix num=x,sum;
	sum.x=sum.y=num.x;
	sum.init();
	for(int i=1;i<=sum.x;i++)sum.a[i][i]=1;
	while(y)
	{
		if(y&1)sum=sum*num;
		num=num*num;
		y>>=1;
	}
	return sum;
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	matrix x,y;
	x.x=x.y=3*n;
	x.init();
	y.x=3*n,y.y=1;
	y.init();
	y.a[1][1]=y.a[1+n][1]=1;
	for(int i=1;i<=n;i++)
	{
		int x1=i+n-1,x2=i+n,x3=i+n+1;
		if(x1>n&&x1<=2*n)x.a[i+n][x1]=x.a[i][x1]=1;
		if(x2>n&&x2<=2*n)x.a[i+n][x2]=x.a[i][x2]=1;
		if(x3>n&&x3<=2*n)x.a[i+n][x3]=x.a[i][x3]=1;
	}
	for(int i=n+1;i<=2*n;i++)x.a[i][i+n]=1;
	for(int i=2*n+1;i<=3*n;i++)x.a[i][i-n]=1;
	x=quick_pow(x,m-1);
	y=x*y;
	printf("%d",y.a[n][1]);
	return 0;
}
```


---

## 作者：Terac (赞：0)

[$\texttt{Link}$](https://www.luogu.com.cn/problem/P3990)  

显然有 DP 做法，$f(i,j)$ 表示走到第 $i$ 行第 $j$ 列的方案数量。  

有转移方程 
$$f(i,j)=f(i-1,j-1)+f(i,j-1)+f(i+1,j-1)+\sum\limits_{i=1}^{\left\lfloor{\frac{j}{2}}\right\rfloor}f(i-1,j-1-2i)+f(i,j-1-2i)+f(i+1,j-1-2i)$$  

这个转移方程转移复杂度太高，发现后面那个式子即为 $f(i,j-2)$。  

所以有更简洁的转移方程 
$$f(i,j)=f(i-1,j-1)+f(i,j-1)+f(i+1,j-1)+f(i,j-2)$$  

然后发现，数据范围 $n\le50,m\le10^9$，暴力转移 $O(nm)$，过高。

考虑用矩阵优化。  

矩阵中有上两列每行的状态。如 $n=3$ 时有转移矩阵  

$\begin{bmatrix}1&1&0&1&0&0\\1&1&1&0&1&0\\0&1&1&0&0&1\\1&0&0&0&0&0\\0&1&0&0&0&0\\0&0&1&0&0&0\end{bmatrix}\times\begin{bmatrix}f(1,i-1)\\f(2,i-1)\\f(3,i-1)\\f(1,i-2)\\f(2,i-2)\\f(3,i-2)\end{bmatrix}=\begin{bmatrix}f(1,i)\\f(2,i)\\f(3,i)\\f(1,i-1)\\f(2,i-1)\\f(3,i-1)\end{bmatrix}$

这个矩阵的构造，以 $f(2,i)$ 为例
$$f(2,i)=1\times f(1,i-1)+1\times f(2,i-1)+1\times f(3,i-1)+0\times f(1,i-2)+1\times f(2,i-2)+0\times f(3,i-2)$$

其对应的系数即为初始矩阵的第 $2$ 行。  

矩阵快速幂即可。

因为最初第一列不需要转移，所以将 $m\gets m-1$，并特判一下 $m=2$ 的情况，然后会发现，在 计算 $f(1,3)$ 时，会有从 $f(1,1)$ 来的转移，然而 $f(1,1)$ 并没有在其之前列的转移，导致多算了一次。所以到 $f(n,m)$ 时，多出的方案数，即为从 $(1,1)$ 到 $(n,m-2)$ 的方案数，即多出 $f(n,m-2)$，减去它即可。  

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e2 + 10, P = 30011;
int n, m;
struct Matrix {
	int a[N][N];
	Matrix() { memset(a, 0, sizeof(a)); }
	void init() {
		for(int i = 1; i <= (n << 1); i++) a[i][i] = 1;
	}
	friend Matrix operator * (Matrix a, Matrix b) {
		Matrix res;
		for(int i = 1; i <= (n << 1); i++)
			for(int j = 1; j <= (n << 1); j++)
				for(int k = 1; k <= (n << 1); k++)
					res.a[i][j] = (res.a[i][j] + a.a[i][k] * b.a[k][j]) % P;
		return res;		 
	}
} base;
Matrix qpow(Matrix a, int k) {
	Matrix res; res.init();
	for(; k; a = a * a, k >>= 1)
		if(k & 1) res = res * a;
	return res;
}
void build() {
	for(int i = 1; i <= n; i++)
		for(int j = max(i - 1, 1); j <= min(i + 1, n); j++)
			base.a[i][j] = 1;
	for(int i = 1; i <= n; i++)
		base.a[i][i + n] = base.a[i + n][i] = 1;
}
int main() {
	scanf("%d%d", &n, &m);
	if(m == 2) {
		if(n <= 2) printf("1");
		else printf("0");
		return 0;
	}
	build();
	m -= 2;//因为最后有一次单独算，所以m多减1
	Matrix ans = qpow(base, m);
	int s = ans.a[1][n << 1];
	ans = ans * base;
	int t = ans.a[1][n];
	printf("%d", (t - s + P) % P);
	return 0;
}
```


---


# [BJOI2018] 二进制

## 题目描述

pupil 发现对于一个十进制数，无论怎么将其的数字重新排列，均不影响其是不是$3$ 的倍数。他想研究对于二进制，是否也有类似的性质。

于是他生成了一个长为$n$ 的二进制串，希望你对于这个二进制串的一个子区间，能求出其有多少位置不同的连续子串，满足在重新排列后（可包含前导$0$）是一个$3$ 的倍数。

两个位置不同的子区间指开始位置不同或结束位置不同。

由于他想尝试尽量多的情况，他有时会修改串中的一个位置，并且会进行多次询问。

## 说明/提示

###样例解释

对于第一个询问，区间$[2,2]$ 只有数字$0$，是$3$ 的倍数，区间$[1,3]$ 可以重排成$011_{(2)} = 3_{(10)}$，是$3$ 的倍数，其他区间均不能重排成$3$ 的倍数。

对于第二个询问，全部三个区间均能重排成$3$ 的倍数（注意$00$ 也是合法的）。

###数据范围

对于$20\%$ 的数据，$1 \leq n,m \leq 100$。

对于$50\%$ 的数据，$1 \leq n,m \leq 5000$。

对于$100\%$ 的数据，$1 \leq n,m \leq 100000$，$l \leq r$。


## 样例 #1

### 输入

```
4
1 0 1 0
3
2 1 3
1 3
2 3 4```

### 输出

```
2
3```

# 题解

## 作者：JoshAlMan (赞：29)

~~是时候来一篇码风正常的题解了~~

[题目地址](https://www.luogu.com.cn/problem/P4428)

前置知识：线段树

# Description

给定一个长度为 $n$ 的 $01$ 串，$m$ 次操作：

* 将第 $i$ 个位置 $0/1$ 反转（$0$ 变成 $1$，$1$ 变成 $0$）
* 求区间 $[l, r]$ 之间有多少个连续子序列，满足重排以后是 $3$ 的倍数。

# Solution

## 子问题

先来解决一个子问题，什么样的序列重排是 $3$ 的倍数？

设 $s$ 为序列上 $1$ 的个数，序列长度为 $len$。将二进制下每位下的权列列举出来，分别是 $1, 2, 4, 8, 16, 32....$

换成 $\bmod 3$ 意义下的权：$1, 2, 1, 2, 1, 2, 1...$

可以观察出（或者随便证明一下 ）这是一个 $1, 2$ 循环的权值。设 $1$ 的权数量为 $a$，$2$ 的权数量为 $b$。

不难发现，当 $len$ 为偶数时，$a = b = \dfrac{len}{2}$；当 $len$ 为奇数时，$a = \dfrac{len + 1}{2}, b = \dfrac{len - 1}{2}$ 

假设我们权值为 $1$ 的位置上有 $x$ 个是 $1$，权值为 $2$ 的位置上有 $y$ 个是 $1$，要满足 $x + y = s$

充要条件就是：

$$3 | x + 2y \Leftrightarrow x+2y \equiv 0 \pmod 3\Leftrightarrow 3y+x-y \equiv 0 \pmod 3\Leftrightarrow x-y \equiv 0 \pmod 3 \Leftrightarrow x \equiv y \pmod 3$$

经过完这步转化，我们需要做的就是构造出一组合理的 $x, y$。使得 $x, y$ 能填到位置上（显然顺序已经无关）。

由于 $x \ge y, a \ge b$，不妨让 $x$ 取填到 $a$ 个位置上，$y$ 填到 $b$ 个位置上，即要满足 $0 \le x \le a, 0 \le y \le b$

因为 $s, a, b$ 是有限的，不难想到贪心情况下，$x, y$ 要尽量接近，这样容错率更大（比如 $x = y$ 的情况可以支持 $s = 0$，$x = y + 3$ 的情况势必 $s, x \ge 3$，$x = y + 6$ 的情况势必 $s, x \ge 6$。或者另外一种解释，任意 $x \equiv y \pmod 3$ 的情况都可以通过大的那一项 $-3$，小的那一项 $+3$，最终变为 $x = y + 3$ 或者是 $x = y$ 的形式，不妨手玩一下）

### 分类讨论

1. 我们考虑 $s$ 是偶数的情况下，显然取 $x = y$，即保持两个权贡献一样的拿，那么肯定是可以满足的。

2. 我们考虑 $s$ 是奇数的情况下，因为若 $x = y$，那么 $x + y = s$ 一定是奇数所以不能这么取。所以一定得是 $x = y + 3$ 的形式，这种情况下 $x = \dfrac{s + 3}{2}, y = \dfrac{s - 3}{2}$，在这种形式下， 取带入刚才的 $x, y$ 需要满足的区间式，讨论 $s$ 在何时合法：

   * 首先需要 $s > 1$，因为若 $s = 1$，那么 $y$ 显然就是负数了搞不出来。

   * $len$ 为偶数时：$s \le len - 3$。此时不合法的情况只有 $s = len - 1$。（因为 $s, len$ 的奇偶性已经确定了）
   * $len$ 为奇数时：$s \le len - 2$。此时不合法的情况只有 $s = len - 0$。（因为 $s, len$ 的奇偶性已经确定了）

至此，我们发现一个序列是否合法取决于它的长度 $len$ 奇偶性以及 $1$ 的数量 $s$。

### 补集思想

显然，符合要求的 $s$ 非常多，不好统计，也不好优化，反过来，考虑不合法数量：

* $s = 1$ 时
* $len$ 为偶数时，$s = len - 1$，即 $0$ 的个数是 $1$。 
* $len$ 为奇数时： $s = len - 0$。即 $0$ 的个数为 $0$。

然后发现后面两个条件可以合并，让合法性与 $len$ 无关，并且 $s = 1$ 和后面两个条件有一部分重叠，即 $s = 1$ 且 $0$ 的个数 $\le 1$ 时，所以再优化一下：

* $s = 1$ 且 $0$ 的个数 $\ge 2$ 时。
* $s$ 为奇数且 $0$ 的个数 $ < 2$ 时。

然后用总的方案减去不合法方案就可以求出合法方案了~

## 优化算法复杂度！

### 方向：线段树！

现在，问题变成了支持单点修改，然后 $O(1)$ 或者 $O(\log)$ 的时间在 $[l, r]$ 查询满足条件（上一步总结的）的连续子序列个数。

~~咋做咋做？我也不会~~

满足条件的连续子序列，可以看做是枚举左右端点，或者是二元计数。想想我们之前学过的算法啥能计算二元计数？相信你想到了，就是归并排序，他求解逆序对的原理就是说合并两个区间，然后把两个区间内各自选一个数，然后把贡献记录到答案上。

然后这题还要支持修改，~~通过看题解~~我们就非常直接的想到线段树，然后每次合并两个线段的时候，答案 $=$ 左边线段的答案 $+$ 右边线段的答案 $+$ 左端点在左边这条线段、右端点在右边这条线段的产生的合法连续子序列。

那么我们只要支持用常数时间复杂度计算合并两个线段对答案的贡献就行了！

### 怎么合并？

想象一下，你现在有了两个线段 $A:[l, mid]$ 和 $B:[mid + 1, r]$，合并后新的线段为 $C$，你如何算出跨越两条线段产生的答案贡献？换句话说你需要维护哪些信息？比较显然的是，跨越显然过 $mid$ 和 $mid + 1$。即这样的线段一定是 $A$ 的一个后缀和 $B$ 的一个前缀构成的，所以信息一定要设立前缀后缀的信息。

#### 对于第一种条件咋搞？

不妨把那个 $0$ 的个数 $\ge 2$ 这个坑爹的条件去掉，仅考虑计算 $s = 1$ 的贡献，后面减掉就行。

首先你需要分类讨论那个 $1$ 所在的位置，不妨设他在右边这条线段上，那么你需要记录 $[l, mid]$ 的后缀 $0$ 个数，以及 $B$ 线段的前缀满足只有一个 $1$ 的个数，然后两者的乘积就是答案。

然后再左边的话是对称的，就不赘述了。

综上你需要维护：

1. 每条线段的前缀 $0$ 个数 $L_0$ 以及 后缀 $0$ 个数 $R_0$
2. 前缀满足只有一个 $1$ 的个数 $L_1$，后缀满足只有一个 $1$ 的个数 $R_1$

$L_1, R_1$具体维护有很多细节，要讨论全（即后缀是原来的后缀，或者成为跨域两个的新后缀），还要记录一段的 $0, 1$ 总数 $C_0, C_1$。 $R_1$ 为例：

* $C.R_1 \gets B.R_1$ 即原来 $B$ 的后缀也是 $C$ 的后缀
* 讨论那个唯一的 $1$ 在 $A$，如果$B.C_0 = 0$，  $C.R_1 \gets A.R_1$
* 如果 $B$ 的全串只有 $1$ 个 $1$，即 $B.C_1 = 1$，那么跨越过来还可以搞几个 $0$：$C.R_1 \gets A.R_0$

#### 第二个条件

比较显然的是我们只关注 $1$ 的数量的奇偶性，以及 $0$ 的数量（而且只能为 $0/1$）。

设 $R_{i, j}$ 为线段后缀中满足 $0$ 的数量为 $i$，$1$ 的数量 $\bmod 2 = j$ 的数量。$L$ 统计前缀，对称地是类似的。

那么你枚举 $A.R_{a, b}, B.L_{c, d}$ 考虑能否产生贡献：

* 若 $a+c \le 1$ 且 $b + d$ 为奇数，那么则可以产生对答案有他们俩乘积的贡献。

维护这俩破玩意挺恶心的，以 $R$ 为例，要考虑跨域整个 $B$，左端点到 $A$ 的新后缀。：

* $C.R_{i, j} \gets B.R_{i, j}$
* $C.R_{i, j} \gets A.R_{i - B.C_0, j - B.C_1}$

#### 重复计算了咋办？

分类讨论一下：

1. 重复计算的 $s = 1$，$0$ 的个数为 $0$ 的情况，即只有一个 $'1'$ 的形式。这个好办，不会再合并的时候统计（因为合并长度至少 $\ge 2$，直接一开始的时候统计即可）。
2. 重复计算的 $s = 1$，$0$ 的个数为 $1$ 的情况。这种情况应该就是 $mid, mid + 1$ 两个位置成为 $01$ 或者 $10$ 的情况，特判一下减掉就行。

然后我们就解决了重复计算的麻烦。

## 时间复杂度 

$O(N\log_2N)$

## Tips

对于这种及其毒瘤的东西可以自己写个结构体啥的，这样把代码分治，这样不会写的很乱。

## Code

我相信这个码风一点都不毒瘤。。。。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

typedef long long LL;

const int N = 100005;

int n, m, w[N];

// 线段结构体
struct Seg{
	int L0, R0, L1, R1, C0, C1, R[2][2], L[2][2];
	LL res;
	// 数组清零啥的
	void init() {
		L0 = R0 = L1 = R1 = C0 = C1 = res = 0;
		memset(R, 0, sizeof R), memset(L, 0, sizeof L);
	}
	Seg(){}
	// 线段长度为 1，这个元素是 x 的时候的初始化
	Seg(int x){
		init();
		if (x) L1 = R1 = C1 = L[0][1] = R[0][1] = res = 1;
		else L0 = R0 = C0 = L[1][0] = R[1][0] = 1; 
	}
	// 合并两个区间，同时对 ans 产生贡献, mid 是线段 A 的右端点
	Seg(Seg A, Seg B, int mid) {
		init();
		C0 = A.C0 + B.C0, C1 = A.C1 + B.C1;
		L0 = A.L0 + (!A.C1 ? B.L0 : 0), R0 = B.R0 + (!B.C1 ? A.R0 : 0);
		L1 = A.L1 + (!A.C1 ? B.L1 : 0) + (A.C1 == 1 ? B.L0 : 0);
		R1 = B.R1 + (!B.C1 ? A.R1 : 0) + (B.C1 == 1 ? A.R0 : 0);
		for (int i = 0; i < 2; i++) {
			for (int j = 0; j < 2; j++) {
				L[i][j] = A.L[i][j] + (i >= A.C0 ? B.L[i - A.C0][j ^ (A.C1 & 1)] : 0);
				R[i][j] = B.R[i][j] + (i >= B.C0 ? A.R[i - B.C0][j ^ (B.C1 & 1)] : 0);
			}
		}
		res = A.res + B.res;
		// 条件 1
		res += (LL)A.R0 * B.L1 + (LL)A.R1 * B.L0;
		// 条件 2
		res += (LL)A.R[0][0] * (B.L[0][1] + B.L[1][1]) + (LL)A.R[0][1] * (B.L[0][0] + B.L[1][0]); 
		res += (LL)A.R[1][0] * B.L[0][1] + (LL)A.R[1][1] * B.L[0][0]; 
		// 减掉重复统计
		if (w[mid] + w[mid + 1] == 1) res--;
	}	
} v[N << 2];

void build(int p, int l, int r) {
	if (l == r) { v[p] = Seg(w[l]); return; }
	int mid = (l + r) >> 1;
	build(p << 1, l, mid);
	build(p << 1 | 1, mid + 1, r);
	v[p] = Seg(v[p << 1], v[p << 1 | 1], mid);
}

void change(int p, int l, int r, int x) {
	if (l == r) { v[p] = Seg(w[l]); return; }
	int mid = (l + r) >> 1;
	if (x <= mid) change(p << 1, l, mid, x);
	else change(p << 1 | 1, mid + 1, r, x);
	v[p] = Seg(v[p << 1], v[p << 1 | 1], mid);
}

Seg query(int p, int l, int r, int x, int y) {
	if (x <= l && r <= y) return v[p];
	int mid = (l + r) >> 1;
	if (y <= mid) return query(p << 1, l, mid, x, y);
	if (mid < x) return query(p << 1 | 1, mid + 1, r, x, y);
	return Seg(query(p << 1, l, mid, x, y), query(p << 1 | 1, mid + 1, r, x, y), mid);
}

int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", w + i);
	build(1, 1, n);
	scanf("%d", &m);
	while (m--) {
		int opt; scanf("%d", &opt);
		if (opt == 1) {
			int x; scanf("%d", &x);
			w[x] ^= 1, change(1, 1, n, x);
		} else {
			int l, r; scanf("%d%d", &l, &r);
			LL sum = (LL)(r - l + 1) * (r - l + 2) / 2; 
			printf("%lld\n", sum - query(1, 1, n, l, r).res);
		}
	}
	return 0;
}
```




---

## 作者：shadowice1984 (赞：22)

传说中的动态dp？反正极其毒瘤就是了

如果足够熟练的话应该可以轻松的通过本题，但是不熟练的话就需要肝一段时间了……

# 本题题解

首先让我们先来推一发结论……

题目中的意思是存在一种重排方案使得这个序列是3的倍数就计入答案当中

通过打表发现，2的奇数次方%3=2,2的偶数次方%3=1(根据费马小定理$2^2\%3=1$所以次幂一定循环)

对于重排的二进制数膜3我们可以认为是每一二进制位膜三之后加起来再膜3的结果

所以我们如果将这个二进制数的每一位%3，就会得到一堆余数，我们的目标是构造一种方案使得这个区间重排之后这些余数的和%3为0

因此我们大概需要一个类似于判定定理之类的东西来让我们快速的判定这个区间重新排列之后是否可以成为3的倍数

发现如果这个区间有偶数个1那么一定可以重新排列成3的倍数，因为我们可以在这个区间的所有奇数位上放置一半的1，所有偶数位置上放置另一半的1，然后1和2两两配对就可以凑出整数个3，因此%3=0

所以现在让我们把精力集中在这个区间存在着奇数个1的情况，发现我们如果这个区间有3个及以上的1的话，我们可以让奇数位置比偶数位置多3个3，此时大部分的1是1+2=3两两配对成3了，最后的3个2刚好凑成一个6，也可以被3整除，可以证明就算存在其他形式的构造方法，这种构造方式也一定可以构造出一个解，但是如果连这种构造方式都无解的话，其他的构造形式一定构造不出解来

但是我们发现这样会有一个非常致命的问题，我们的奇数位置至少要比偶数位置多3个才能完成构造

于是我们发现奇数个1+3个0的情况是可以构造成功的，奇数个1+2个0的情况依然可以构造成功(此时序列有奇数个元素，奇数位置本身就比偶数位置多一个，加上2个0刚好差出3个位置)

但是奇数个1+1个0的情况一定不行，因为此时序列之和已经%3=0，无论最后的0放在什么位置上都会使%3的结果变成非0

当然奇数个1+0个0的情况因为重排都是一个样所以没法构造了

简单分析下刚才的情况，我们发现一个区间可以被重排成3的倍数的条件相当繁琐，但是我们发现判断一个区间不可以被重排成3的倍数的判断条件相对简单，只需要满足下列三个条件中至少一个

1.有且仅有1个1

2.有奇数个1且有1个0

3.有奇数个1且有0个0

我们发现如果只是询问一次的话似乎可以dp求出来这个区间有多少个点对不符合条件,大概开上3维表示这个区间有没有1,1的奇偶性，0的数量，然后就可以大力转移了

此时我们发现有$10^5$组询问和修改我们是铁定凉凉的，此时有必要介绍一种被称之为动态dp的黑科技了……

## 动态dp

所谓动态dp就是带修改的dp

我们发现有些dp是一个点一个点更新的，这样做太慢了，我们有必要给它提个速

于是我们决定把这个dp搬到线段树上，然后我们就可以支持单点询问和区间修改了

如果你真的足够毒瘤的话可以链剖之后在树上以链分治的形式做dp，把dp搬到链剖之后的线段树上……这就已经不是毒瘤可以做出来的事情了当然这道题还是非常亲民的序列上的动态dp

那么我们具体来讲如何把dp搬到线段树上吧，我们都知道线段树的每一个节点代表着一个区间，因此我们可以在这个区间里做dp，实现方法如下

对于线段树的每一个节点，我们维护一个dp数组

## $Dp_{i,j,k,p}$

其中i的意义如下所示

$i=0$这个区间不包含该节点的左端点和右端点

$i=1$这个区间包含该节点的左端点，不包含右端点

$i=2$这个区间不包含该节点的左端点，包含右端点

$i=3$这个区间是该节点对应的区间(或者说既包含左端点又包含右端点)

j的意义表示这个区间有奇数个1或偶数个1，1表示奇数，0表示偶数

k的意义表是这个区间有0个1或者1个1

p的意义表示这个区间有0个0或者1个0

$Dp_{i,j,k,p}$的值表示满足$i,j,k,p$约束的区间有多少个

然后我们发现转移方程写起来将会十分蛋疼……基本不可写……

不可写就算了(参见\[六省联考2017摧毁树状图]),问题是我们冷静分析下这个数组的长度$4*2*2*2=32$常数大到天上去了基本过不掉，更别说你线段树还有2的基础常数……

因此我们需要尽量减少这个数组的长度，只要略微少点就行了

发现只有一个1的区间似乎和其他两个限制条件没啥关系，因此可以单独dp

所以我们发现可以把一棵线段树拆成两个线段树，分别dp

第一个线段树上存这样的dp数组

## $Dp_{i,j,k}$

其中i的定义和一开始的定义一样

j表示这个区间有奇数个1或者偶数个1

k表示这个区间有0个0或1个0

另一个线段树存这样的dp数组

## $Dp_{i,j}$

i的定义还是和开始的定义一样，

j表示这个区间有0个1或者1个1

然后我们再算一下dp数组的长度，会发现长度变成了

$4*2*2+4*2=26$常数减少了8不说，而且转移方程变好写了，基本在人写的代码和$Data Structure Master$写的代码难度之间了

然后让我们来推这个线段树上dp的转移方程好了

普通dp的式子是加一个点然后递推，而线段树上的式子就是merge左右两个儿子，然后dp

那么我们因为转移方程太过鬼畜了，我们可以分维考虑，考虑每一个dp维度转移时发生的变化

方便起见，我们设父亲节点为$p$，左儿子节点为$p1$，右儿子节点为$p2$

先考虑几个比较简单的转移

奇数个1+奇数个1=偶数个1

奇数个1+偶数个1=奇数个1

0个0+1个0=1个0

0个0+0个0=0个0

0个1+0个1=0个1

1个1+0个1=1个1

然后考虑非常复杂的i这一维的转移，看不懂的话自己画图吧

先解释一下，下面说的加法转移就是继承儿子里已有的区间，乘法转移就是两个儿子中的区间拼接成的区间

p的0型区间：

加法转移:儿子的0型区间以及p1的2型区间，p2的1型区间

乘法转移:p1的2型区间拼上一个p2的1型区间

p的1型区间：

加法转移:p1的3型区间以及p1的1型区间

乘法转移:p1的3型区间拼上p2的1型区间

p的2型区间

加法转移:p1的3型区间以及p2的2型区间

乘法转移:p1的2型区间拼上p2的3型区间

p的3型区间

加法转移:?不存在的！

乘法转移：p1的3型区间以及p2的3型区间

有了这些毒瘤的转移规则我们可以写出一个线段树的merge函数(有的人叫pushup或者update)，然后我们此时就可以完成单点修改和建树工作了……就是简单的一路merge上去应该就是普通线段树操作，应该还是非常好写的

问题是如何完成区间查询操作?

我们可以把0号点当成一个空区间，在线段树上跑区间拆分函数，如果当前区间和节点对应的区间是否重合，如果重合的话我们判断一下0号节点是否为空，如果为空的话就将这个节点的dp数组复制给0号节点，否则将0号节点的dp数组复制一份给4n+1号节点，然后merge(0,4n+1,p)即可，这样我们就一个一个的把这些区间merge成了一个区间，并存在了0号节点里

最后我们只需要提取0号节点的dp数组就是这个区间对应的dp数组了

做完了？

# 不，你重复计数了！

我们观察仅有1个1的区间既是“有且仅有一个1的区间”，也是"有奇数个1且有0个0的区间"，形如"10,01"的区间既是“有且仅有1个1的区间”，也是“有奇数个1且有1个0的区间”，因此这两个区间都被算了两边……问题开始变得辣手……

莫非我们要修改我们的算法，使他变得更加简单，更加优雅，更加具有一般性？

# 不，直接加上重复减的情况就行了

仅有一个1的区间就是区间中1的个数，直接使用树状数组就可以维护，形如“01,10”的区间的话，我们可以每个点记一个0/1的值，表示他和后一个点是否构成了形如"01,10"的区间，然后还是树状数组查一发区间和即可维护

修改的时候同时在两个线段树和两个树状数组上各改一遍

听起来这个算法的常数该大到天上去了，但是事实上跑的飞起，吸氧之后最慢的的点就跑了238ms……

然后看一看恶心至极的实现吧……，我写了150行，极其恶心就是了

上代码~

```C
#include<cstdio>
#include<algorithm>
using namespace std;const int N=1e5+10;typedef long long ll;
int n;int a[N];int mk;int m;
struct linetree1//这个线段树维护条件2,3
{
	ll v[4*N][4][2][2];
	inline void merge(int p,int p1,int p2)//非常恶心的merge函数
	{
		for(int i=0;i<=1;i++)for(int k=0;k<=1;k++)//加法转移们
		v[p][0][i][k]=v[p1][0][i][k]+v[p2][0][i][k]+v[p1][2][i][k]+v[p2][1][i][k];
		for(int i=0;i<=1;i++)for(int k=0;k<=1;k++)v[p][1][i][k]=v[p1][3][i][k]+v[p1][1][i][k];
		for(int i=0;i<=1;i++)for(int k=0;k<=1;k++)v[p][2][i][k]=v[p2][3][i][k]+v[p2][2][i][k];
		for(int i=0;i<=1;i++)for(int k=0;k<=1;k++)v[p][3][i][k]=0;
		for(int i=0;i<=1;i++)//乘法转移,这里for枚举p1,p2各选多少个0
			for(int j=0;i+j<=1;j++)//手动枚举了奇偶性的转移
				v[p][0][0][i+j]+=v[p1][2][0][i]*v[p2][1][0][j]+v[p1][2][1][i]*v[p2][1][1][j],
				v[p][0][1][i+j]+=v[p1][2][0][i]*v[p2][1][1][j]+v[p1][2][1][i]*v[p2][1][0][j],
				v[p][1][0][i+j]+=v[p1][3][0][i]*v[p2][1][0][j]+v[p1][3][1][i]*v[p2][1][1][j],
				v[p][1][1][i+j]+=v[p1][3][0][i]*v[p2][1][1][j]+v[p1][3][1][i]*v[p2][1][0][j],
				v[p][2][0][i+j]+=v[p1][2][0][i]*v[p2][3][0][j]+v[p1][2][1][i]*v[p2][3][1][j],
				v[p][2][1][i+j]+=v[p1][2][0][i]*v[p2][3][1][j]+v[p1][2][1][i]*v[p2][3][0][j],
				v[p][3][0][i+j]+=v[p1][3][0][i]*v[p2][3][0][j]+v[p1][3][1][i]*v[p2][3][1][j],
				v[p][3][1][i+j]+=v[p1][3][0][i]*v[p2][3][1][j]+v[p1][3][1][i]*v[p2][3][0][j];
	}
	inline void modify(int p,int l,int r,int pos)//和一般的线段树修改并没什么区别
	{
		if(r-l==1)//注意一开始只有3型区间有值
		{
			if(a[r]){v[p][3][1][0]=1;v[p][3][0][1]=0;}
			else {v[p][3][0][1]=1;v[p][3][1][0]=0;}return;
		}int mid=(l+r)/2;//判断向左向右走
		if(pos<=mid){modify(p<<1,l,mid,pos);}else {modify(p<<1|1,mid,r,pos);}
		merge(p,p<<1,p<<1|1);//merge一下
	}
	inline void query(int p,int l,int r,int dl,int dr)//拆分成log个区间然后从左至右顺次合并
	{
		if(dl==l&&dr==r)
		{
			if(mk==0)//空区间直接复制
			{
				for(int i=0;i<=3;i++)
					for(int j=0;j<=1;j++)
						for(int k=0;k<=1;k++)v[0][i][j][k]=v[p][i][j][k];mk=1;
			}else//否则复制一份给4n+1然后相当于merge自己和p
			{
				for(int i=0;i<=3;i++)
					for(int j=0;j<=1;j++)
						for(int k=0;k<=1;k++)v[4*n+1][i][j][k]=v[0][i][j][k];
				merge(0,4*n+1,p);
			}return;
		}int mid=(l+r)/2;//区间拆分
		if(dl<mid){query(p<<1,l,mid,dl,min(dr,mid));}
		if(mid<dr){query(p<<1|1,mid,r,max(dl,mid),dr);}
	}
	inline ll cquery(int l,int r)
	{
		for(int i=0;i<=3;i++)//记得清空0号节点
			for(int j=0;j<=1;j++)
				for(int k=0;k<=1;k++)v[0][i][j][k]=0;mk=0;
		query(1,0,n,l,r);ll ret=0;//统计奇数个1有0或1个0的区间数
		for(int i=0;i<=3;i++)ret+=v[0][i][1][0]+v[0][i][1][1];
		return ret;
	}
	inline void build(int p,int l,int r)//建树无脑merge就行了
	{
		if(r-l==1){if(a[r]){v[p][3][1][0]=1;}else {v[p][3][0][1]=1;}return;}
		int mid=(l+r)/2;build(p<<1,l,mid);build(p<<1|1,mid,r);merge(p,p<<1,p<<1|1);
	}
}lt1;
struct linetree2//第二棵线段树单独维护条件2,和第一个树写法差不多
{
	ll v[4*N][4][2];
	inline void merge(int p,int p1,int p2)//merge会比第一个树好写点
	{
		for(int i=0;i<=1;i++)v[p][0][i]=v[p1][0][i]+v[p2][0][i]+v[p1][2][i]+v[p2][1][i];
		for(int i=0;i<=1;i++)v[p][1][i]=v[p1][3][i]+v[p1][1][i];
		for(int i=0;i<=1;i++)v[p][2][i]=v[p2][3][i]+v[p2][2][i];
		for(int i=0;i<=1;i++)v[p][3][i]=0;
		for(int i=0;i<=1;i++)
			for(int j=0;i+j<=1;j++)
				v[p][0][i+j]+=v[p1][2][i]*v[p2][1][j],
				v[p][1][i+j]+=v[p1][3][i]*v[p2][1][j],
				v[p][2][i+j]+=v[p1][2][i]*v[p2][3][j],
				v[p][3][i+j]+=v[p1][3][i]*v[p2][3][j];
	}
	inline void modify(int p,int l,int r,int pos)//其他的函数基本一样了
	{
		if(r-l==1)
		{
			if(a[r]){v[p][3][1]=1;v[p][3][0]=0;}
			else {v[p][3][0]=1;v[p][3][1]=0;}return;
		}int mid=(l+r)/2;
		if(pos<=mid){modify(p<<1,l,mid,pos);}else {modify(p<<1|1,mid,r,pos);}
		merge(p,p<<1,p<<1|1);return;
	}
	inline void query(int p,int l,int r,int dl,int dr)
	{
		if(dl==l&&dr==r)
		{
			if(mk==0){for(int i=0;i<=3;i++)for(int j=0;j<=1;j++)v[0][i][j]=v[p][i][j];mk=1;}
			else
			{
				for(int i=0;i<=3;i++)for(int j=0;j<=1;j++)v[4*n+1][i][j]=v[0][i][j];
				merge(0,4*n+1,p);
			}return;
		}int mid=(l+r)/2;
		if(dl<mid){query(p<<1,l,mid,dl,min(dr,mid));}
		if(mid<dr){query(p<<1|1,mid,r,max(dl,mid),dr);}
	}
	inline ll cquery(int l,int r)
	{
		for(int i=0;i<=3;i++)for(int j=0;j<=1;j++)v[0][i][j]=0;mk=0;
		query(1,0,n,l,r);ll ret=0;
		for(int i=0;i<=3;i++)ret+=v[0][i][1];
		return ret;
	}
	inline void build(int p,int l,int r)
	{
		if(r-l==1){if(a[r]){v[p][3][1]=1;}else {v[p][3][0]=1;}return;}
		int mid=(l+r)/2;build(p<<1,l,mid);build(p<<1|1,mid,r);merge(p,p<<1,p<<1|1);
	}
}lt2;
struct treearray//树状数组维护需要特判的区间,这里封装了下
{
	int ta[N];
	inline void c(int x,int t){for(;x<=n;x+=x&(-x)){ta[x]+=t;}}
	inline int d(int x){int r=0;for(;x>0;x-=x&(-x)){r+=ta[x];}return r;}
	inline ll q(int l,int r){return d(r)-d(l);}
}tr1,tr2;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++){scanf("%d",&a[i]);}lt1.build(1,0,n);lt2.build(1,0,n);//建树,建树状数组
	for(int i=1;i<=n;i++){if(a[i]){tr1.c(i,1);}if(a[i]^a[i+1]&&i!=n){tr2.c(i,1);}}
	scanf("%d",&m);
	for(int i=1,t,l,r;i<=m;i++)
	{
		scanf("%d",&t);
		if(t==1)//然后在每一个数据结构上修改就行了
		{
			scanf("%d",&l);a[l]^=1;
			lt1.modify(1,0,n,l);lt2.modify(1,0,n,l);tr1.c(l,(a[l])?1:-1);
			if(l!=n){tr2.c(l,(a[l]^a[l+1])?1:-1);}
			if(l!=1){tr2.c(l-1,(a[l-1]^a[l])?1:-1);}
		}
		else
		{
			scanf("%d%d",&l,&r);ll len=r-l+1;//最后加上要特判的区间就行,注意边界条件,10,01的左端点只能到r-1
			printf("%lld\n",len*(len+1)/2-lt1.cquery(l-1,r)-lt2.cquery(l-1,r)+tr1.q(l-1,r)+tr2.q(l-1,r-1));
		}
	}return 0;//拜拜程序~
}

```





---

## 作者：yybyyb (赞：11)

二进制串在模$3$意义下，每一位代表的余数显然是$121212$这样子交替出现的。  
其实换种方法看，就是$1,-1,1,-1,...$  
如果询问一个二进制串能否被$3$整除，那么只需要考虑奇数位上的$1$的个数和偶数位上的$1$的个数就行了。  
如果可以重排，我们来考虑如何分配。  
首先对于一个长度为$len$的区间，模$3$余$1$的位有$[\frac{len+1}{2}]$个，余$-1$的有$[\frac{len}{2}]$个。假设要分配$k$个$1$。
凑成$3$的倍数的情况一定是$1,-1$两两配对，剩下较多的那个的数量是$3$的倍数。  
如果$k$是偶数那么一定可以两两配对。  
如果$k$是奇数的话，就只能$k-3$个$1$均匀分配给$-1,1$，剩下$3$个分配给$1$。   
那么需要满足$\frac{k+3}{2}\le [\frac{len+1}{2}]$，拆开后如果$len$是奇数则要满足$k\le len-2$，如果$len$是偶数则满足$k\le len-3$。  

那么这个条件再进一步就是，如果$0$的个数$\ge 3$，那么一定满足。  
如果$0$的个数为$2$，此时$len=k+2$ 为奇数，也满足。

所以不合法的情况就是

- 只有一个$1$的区间($k\lt 3$,且$k$为奇数就只有$1$)
- 出现了奇数个$1$，且$0$的个数为$0/1$。

因为要做到不重，所以第一个条件可以补充成“区间内只有$1$个$1$，  且$0$的个数不少于$2$个”。  
答案就可以用总的连续子序列的个数减去不合法的数量。  
可以用线段树维护不合法的连续子序列的数量。

考虑合并两个节点之后如何产生贡献， 
设$dl[0/1][0/1]$表示强制选择左端点的一段连续区间中，$0$的出现次数为$0/1$，$1$的出现次数的奇偶性为$0/1$的序列个数，$dr$同理。  
$fl[0/1/2]$表示强制经过左端点，$1$恰好出现了$1$次，且$0$的出现次数为$0,1,\ge 2$的序列个数。$fr$同理。  
再统计一下左右连续的$0$的个数，以及区间内$0/1$的个数。  

每次考虑跨过两段的不合法区间，统计答案即可。
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
#define ll long long
#define MAX 100100
#define lson (now<<1)
#define rson (now<<1|1)
inline int read()
{
	int x=0;bool t=false;char ch=getchar();
	while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
	if(ch=='-')t=true,ch=getchar();
	while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
	return t?-x:x;
}
int n,Q,a[MAX];
struct data
{
	ll dl[2][2],dr[2][2],fl[3],fr[3],l0,r0,s;
	int s0,s1;
	void init()
	{
		dl[0][0]=dr[0][0]=dl[0][1]=dr[0][1]=dl[1][0]=dr[1][0]=dl[1][1]=dr[1][1]=0;
		fl[0]=fr[0]=fl[1]=fr[1]=fl[2]=fr[2]=0;
		l0=r0=s0=s1=s=0;
	}
	data(){init();}
	void pre(int x)
	{
		init();
		if(x)dl[0][1]=dr[0][1]=s1=s=fl[0]=fr[0]=1;
		else dl[1][0]=dr[1][0]=s0=l0=r0=1;
	}
}t[MAX<<2];
data Merge(data A,data B)
{
	data c;c.init();
	for(int i=0;i<2;++i)
		for(int j=0;j<2;++j)
		{
			c.dl[i][j]+=A.dl[i][j];
			c.dr[i][j]+=B.dr[i][j];
			if(i>=A.s0)c.dl[i][j]+=B.dl[i-A.s0][j^(A.s1&1)];
			if(i>=B.s0)c.dr[i][j]+=A.dr[i-B.s0][j^(B.s1&1)];
		}
	for(int i=0;i<3;++i)
	{
		c.fl[i]+=A.fl[i];c.fr[i]+=B.fr[i];
		if(!A.s1)c.fl[min(2,i+A.s0)]+=B.fl[i];
		if(!B.s1)c.fr[min(2,i+B.s0)]+=A.fr[i];
	}
	if(A.s1==1&&B.l0)c.fl[min(2ll,A.s0+B.l0)]+=1,c.fl[2]+=B.l0-1;
	if(B.s1==1&&A.r0)c.fr[min(2ll,B.s0+A.r0)]+=1,c.fr[2]+=A.r0-1;
	c.l0=(A.s1==0)?A.l0+B.l0:A.l0;
	c.r0=(B.s1==0)?B.r0+A.r0:B.r0;
	c.s0=A.s0+B.s0;c.s1=A.s1+B.s1;

	c.s=A.s+B.s;
	c.s+=A.dr[0][0]*(B.dl[0][1]+B.dl[1][1]);
	c.s+=A.dr[0][1]*(B.dl[0][0]+B.dl[1][0]);
	c.s+=A.dr[1][0]*B.dl[0][1];
	c.s+=A.dr[1][1]*B.dl[0][0];
	if(B.l0)c.s+=B.l0*(A.fr[0]+A.fr[1]+A.fr[2])-A.fr[0];
	if(A.r0)c.s+=A.r0*(B.fl[0]+B.fl[1]+B.fl[2])-B.fl[0];
	return c;
}
void Build(int now,int l,int r)
{
	if(l==r){t[now].pre(a[l]);return;}
	int mid=(l+r)>>1;
	Build(lson,l,mid);Build(rson,mid+1,r);
	t[now]=Merge(t[lson],t[rson]);
}
void Modify(int now,int l,int r,int p)
{
	if(l==r){t[now].pre(a[l]);return;}
	int mid=(l+r)>>1;
	if(p<=mid)Modify(lson,l,mid,p);
	else Modify(rson,mid+1,r,p);
	t[now]=Merge(t[lson],t[rson]);
}
data Query(int now,int l,int r,int L,int R)
{
	if(L==l&&R==r)return t[now];
	int mid=(l+r)>>1;
	if(R<=mid)return Query(lson,l,mid,L,R);
	if(L>mid)return Query(rson,mid+1,r,L,R);
	return Merge(Query(lson,l,mid,L,mid),Query(rson,mid+1,r,mid+1,R));
}
int main()
{
	n=read();
	for(int i=1;i<=n;++i)a[i]=read();
	Build(1,1,n);
	Q=read();
	while(Q--)
	{
		int opt=read(),l=read(),r;
		if(opt==1)a[l]^=1,Modify(1,1,n,l);
		else r=read(),printf("%lld\n",1ll*(r-l+1)*(r-l+2)/2-Query(1,1,n,l,r).s);
	}
	return 0;
}
```

---

## 作者：FZzzz (赞：7)

考试时候场切了，机房神仙给了个原题链接，一看题解吓傻了，咋全是阴间线段树。

给个阳间 `set` 加树状数组做法。

首先偶数位相当于一奇数位相当于二，偶数和奇数的数量最多差三，合法的区间就等价于一的数量为偶数或者为大于一的奇数并且最少有两个零。其他题解都已经说得很清楚了。

然后考虑求不合法的区间，就是区间里有奇数个一并且零不超过两个，或者只有一个一的。

先考虑第一种的贡献。没有零的话就是每个连续的全一段一算贡献，有一个零的话就可以在这个零的地方计算贡献，贡献只和它前面后面第一个零有关。用一个 `set` 维护所有零的位置，树状数组维护贡献，为了方便把第一种全一段的贡献在后面第一个零的地方计算。查询的时候就是二分出区间里第一个和最后一个零，旁边单独算一下，中间可以直接用树状数组查询。

第二种贡献也差不多，可以在唯一的这个一的地方计算。但是我们要减掉同时满足两个限制的。

然后善用函数减少细节。考场代码可能比较丑，但是大概比其他题解要阳间一点。
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int readint(){
	int x=0;
	bool f=0;
	char c=getchar();
	while(!isdigit(c)&&c!='-') c=getchar();
	if(c=='-'){
		f=1;
		c=getchar();
	}
	while(isdigit(c)){
		x=x*10+c-'0';
		c=getchar();
	}
	return f?-x:x;
}
const int maxn=1e5+5;
int n,m;
bool a[maxn];
set<int> s0,s1;
inline int lowbit(int x){
	return x&-x;
}
typedef long long ll;
struct bit{
	ll c[maxn];
	void modify(int x,ll k){
		while(x<=n){
			c[x]+=k;
			x+=lowbit(x);
		}
	}
	ll query(int x){
		ll s=0;
		while(x){
			s+=c[x];
			x-=lowbit(x);
		}
		return s;
	}
}t0,t1;
ll f1(int l,int r){
	return 1ll*(l+1)/2*((r+2)/2)+1ll*(l+2)/2*((r+1)/2);
}
ll f2(int l){
	return 1ll*(l+1)/2*((l+2)/2);
}
void update0(int x,bool flag){
	int pre=*--s0.find(x),suc=*++s0.find(x);
	t0.modify(x,(f1(x-pre-1,suc-x-1)+f2(x-pre-1))*(flag?1:-1));
}
ll f3(int l,int r){
	return 1ll*(l+1)*(r+1)-1-(bool)l-(bool)r;
}
void update1(int x,bool flag){
	int pre=*--s1.find(x),suc=*++s1.find(x);
	t1.modify(x,f3(x-pre-1,suc-x-1)*(flag?1:-1));
}
int main(){
	freopen("bin.in","r",stdin);
	freopen("bin.out","w",stdout);
	n=readint();
	for(int i=1;i<=n;i++) a[i]=readint();
	s0.insert(0);
	s1.insert(0);
	for(int i=1;i<=n;i++)
		if(a[i]) s1.insert(i);
		else s0.insert(i);
	s0.insert(n+1);
	s1.insert(n+1);
	for(int i=1;i<=n;i++)
		if(a[i]) update1(i,1);
		else update0(i,1);
	m=readint();
	while(m--){
		int opt=readint();
		if(opt==1){
			int x=readint(),pre=*--s0.lower_bound(x),suc=*s0.upper_bound(x);
			if(pre) update0(pre,0);
			if(suc<=n) update0(suc,0);
			if(a[x]){
				s0.insert(x);
				update0(x,1);
			}
			else{
				update0(x,0);
				s0.erase(x);
			}
			if(pre) update0(pre,1);
			if(suc<=n) update0(suc,1);
			pre=*--s1.lower_bound(x);
			suc=*s1.upper_bound(x);
			if(pre) update1(pre,0);
			if(suc<=n) update1(suc,0);
			if(a[x]){
				update1(x,0);
				s1.erase(x);
			}
			else{
				s1.insert(x);
				update1(x,1);
			}
			if(pre) update1(pre,1);
			if(suc<=n) update1(suc,1);
			a[x]=!a[x];
		}
		else{
			int l,r;
			l=readint();
			r=readint();
			int fst=*s0.lower_bound(l),lst=*--s0.upper_bound(r);
			ll res=0;
			if(fst>r) res=f2(r-l+1);
			else if(fst==lst) res=f1(fst-l,r-fst)+f2(fst-l)+f2(r-fst);
			else{
				int suc=*++s0.find(fst),pre=*--s0.find(lst);
				res=t0.query(lst-1)-t0.query(fst)+f1(fst-l,suc-fst-1)+f1(lst-pre-1,r-lst)+f2(fst-l)+f2(lst-pre-1)+f2(r-lst);
			}
			fst=*s1.lower_bound(l);
			lst=*--s1.upper_bound(r);
			if(fst<=r){
				if(fst==lst) res+=f3(fst-l,r-fst);
				else{
					int suc=*++s1.find(fst),pre=*--s1.find(lst);
					res+=t1.query(lst-1)-t1.query(fst)+f3(fst-l,suc-fst-1)+f3(lst-pre-1,r-lst);
				}
			}
			printf("%lld\n",1ll*(r-l+1)*(r-l+2)/2-res);
		}
	}
	return 0;
}
```

---

## 作者：周子衡 (赞：7)

```
本题解讲解DDP的矩阵写法，并介绍了笔者从本题中学到的卡常技巧。
```

首先分析题意：怎么处理这个“任意排序后能否变成$3$的倍数”的问题？

根据小学奥数内容，我们知道，$x$进制下的数$a$模$x+1$的余数，等于$a$奇数位上的数字和与偶数位上的数字和的差模$x+1$的值（这里认为个位是第一位，从右往左位数递增）。事实上非常容易证明这一点：令$a=\sum_{i=0}b_ix^i$，则：

$a\equiv \sum_{i=0}b_ix^i$

$\text{ }\text{ }\equiv\sum_{i=0}b_i(-1)^i$

$\text{ }\text{ }\equiv \sum_{i=0}b_{2i}-\sum_{i=0}b_{2i+1}(\text{mod}\text{ }x+1)$

证毕。那么接下来考虑：什么样的数重排后能变成$3$的倍数？

首先，如果$1$的个数是偶数，那么显然可以：奇数位和偶数位放相同数量的$1$即可。

如果$1$有奇数个，怎么办呢？我们要尽量让奇偶位的差为$3$。首先我们发现：必须有至少$3$个$1$（因为很明显只有$1$个$1$是不行的）。同时，为了让这$3$个$1$都放在奇位上，至少要有$2$个$0$。可以验证，能排成$3$的倍数的充要条件是满足下列条件中的至少一个：

（1）有偶数个$1$；

（2）有至少$3$个$1$和至少$2$个$0$。

发现这样不太好统计，反面考虑：不能满足条件的必须是下列情况中的一个：

（1）只有一个$1$；

（2）有奇数个$1$，且$0$的个数不超过$1$个。

这两类之间有重叠，不妨运用容斥原理：反面的个数其实等于“只有一个$1$”的个数加上“有奇数个$1$，且$0$的个数不超过$1$个”的个数减去“只有一个$1$，$0$的个数不超过$1$个”的个数，把这个数从全部中排掉即可。

下面分三部分解决：

- “只有一个$1$，$0$的个数不超过$1$个”的个数：

这部分又细分为两类，比较容易维护：

（1）有$1$个$1$，没有$0$：就是区间里$1$的个数；

（2）有$1$个$1$，$1$个$0$：这里其实是一个长度为$2$的区间，维护相邻两个元素的关系即可。

- “只有一个$1$”的个数：

考虑$\text{DP}$。

令$g_{i,j}$表示以$i$结尾的串中恰有$j$个$1$的非空串数。很明显我们只需处理$j=0$或$j=1$的情况。

用$a_i$表示原序列。

（1）$a_i=0$：

此时易得$g_{i,0}=1+g_{i-1,0}$，$g_{i,1}=g_{i-1,1}$；

（2）$a_i=1$

此时易得$g_{i,0}=0$，$g_{i,1}=1+g_{i-1,0}$。

如果只是一次询问，那么我们顺序扫一遍足矣。但问题是：现在我们如何处理对于任意区间的询问？又如何处理修改？

想到：用矩阵进行维护！我们可以把$g_i$看作一个向量，在$i-1$和$i$之间作线性变换，这个变换又可以用矩阵描述，矩阵运算有结合律，可以用线段树维护区间矩阵乘积！

恭喜你，你掌握了动态$\text{DP}$（即$\text{DDP}$）的精髓。[这是模板题。](https://www.luogu.com.cn/problem/P4719)

发现其实我们最终的答案并非$g_{i,1}$，而是$\sum_{i=l}^rg_{i,1}$，我们不妨再维护一个量$sg_i$表示它。那么很明显$sg_i=sg_{i-1}+g_{i,1}$，然后分别代入上面的表达式，我们可以得出下面的矩阵关系式：

![](https://cdn.luogu.com.cn/upload/image_hosting/zgx3xnp9.png)

（因为不太会打$\text{LaTeX}$的矩阵，用了图片，请见谅）

这样就完成了！

- “有奇数个$1$”的个数：

这部分其实和第二部分差不多，不过要更复杂一些。

![](https://cdn.luogu.com.cn/upload/image_hosting/tsmq0bot.png)

好了，大功告成！

我们得出如下代码：

```cpp
#include<cstdio>
#include<cstring>

using namespace std;

int n=0,m=0;
int a[200000];

struct matrix
{
	int r,c;
	long long num[6][6];
	matrix(int rr=0,int cc=0):r(rr),c(cc){memset(num,0,sizeof(num));}
	matrix operator=(const matrix& a){this->r=a.r,this->c=a.c;memcpy(this->num,a.num,sizeof(a.num));return *this;}
};

matrix operator*(const matrix &a,const matrix& b)
{
	if(a.c!=b.r){return matrix();}
	matrix ans(a.r,b.c);
	for(int i=0;i<a.r;i++)
	{
		for(int j=0;j<b.c;j++)
		{
			for(int k=0;k<a.c;k++)
			{
				ans.num[i][j]+=a.num[i][k]*b.num[k][j];
			}
		}
	}
	return ans;
}

matrix f0(6,6),f1(6,6),g0(4,4),g1(4,4),fs(1,6),gs(1,4);
void init()
{
	f0.num[0][2]=f0.num[1][3]=f0.num[1][4]=f0.num[4][4]=f0.num[5][2]=f0.num[5][5]=1;
	f1.num[0][1]=f1.num[0][4]=f1.num[1][0]=f1.num[2][3]=f1.num[2][4]=f1.num[3][2]=f1.num[4][4]=f1.num[5][1]=f1.num[5][4]=f1.num[5][5]=1;
	g0.num[0][0]=g0.num[1][1]=g0.num[1][2]=g0.num[2][2]=g0.num[3][0]=g0.num[3][3]=1;
	g1.num[0][1]=g1.num[0][2]=g1.num[2][2]=g1.num[3][1]=g1.num[3][2]=g1.num[3][3]=1;
	fs.num[0][5]=1,gs.num[0][3]=1;
}

struct nd
{
	int l,r;matrix f,g;int sum1,sum2;
}t[400000];
void build(int l,int r,int k=1)
{
	t[k].l=l,t[k].r=r;
	if(l==r)
	{
		if(a[l]==0)t[k].f=f0,t[k].g=g0;else t[k].f=f1,t[k].g=g1;
		t[k].sum1=a[l];if(l<n&&(a[l]^a[l+1]))t[k].sum2=1;return;
	}
	int mid=(l+r)>>1;build(l,mid,k<<1),build(mid+1,r,k<<1|1);
	t[k].f=t[k<<1].f*t[k<<1|1].f,t[k].g=t[k<<1].g*t[k<<1|1].g;
	t[k].sum1=t[k<<1].sum1+t[k<<1|1].sum1,t[k].sum2=t[k<<1].sum2+t[k<<1|1].sum2;
}
void change(int pos,int k=1)
{
	if(t[k].l==t[k].r)
	{
		if(a[pos]==0)t[k].f=f0,t[k].g=g0;else t[k].f=f1,t[k].g=g1;
		t[k].sum1=a[pos];if(pos<n&&(a[pos]^a[pos+1]))t[k].sum2=1;else t[k].sum2=0;return;
	}
	int mid=(t[k].l+t[k].r)>>1;
	if(pos<=mid)change(pos,k<<1);else change(pos,k<<1|1);
	t[k].f=t[k<<1].f*t[k<<1|1].f,t[k].g=t[k<<1].g*t[k<<1|1].g;
	t[k].sum1=t[k<<1].sum1+t[k<<1|1].sum1,t[k].sum2=t[k<<1].sum2+t[k<<1|1].sum2;
}
matrix query_f(int l,int r,int k=1)
{
	if(l<=t[k].l&&t[k].r<=r)return t[k].f;
	int pos=(t[k].l+t[k].r)>>1;
	if(l>pos)return query_f(l,r,k<<1|1);
	if(r<=pos)return query_f(l,r,k<<1);
	return query_f(l,r,k<<1)*query_f(l,r,k<<1|1);
}
matrix query_g(int l,int r,int k=1)
{
	if(l<=t[k].l&&t[k].r<=r)return t[k].g;
	int pos=(t[k].l+t[k].r)>>1;
	if(l>pos)return query_g(l,r,k<<1|1);
	if(r<=pos)return query_g(l,r,k<<1);
	return query_g(l,r,k<<1)*query_g(l,r,k<<1|1);
}
int query_s1(int l,int r,int k=1)
{
	if(l>r)return 0;
	if(l<=t[k].l&&t[k].r<=r)return t[k].sum1;
	int pos=(t[k].l+t[k].r)>>1;
	if(l>pos)return query_s1(l,r,k<<1|1);
	if(r<=pos)return query_s1(l,r,k<<1);
	return query_s1(l,r,k<<1)+query_s1(l,r,k<<1|1);
}
int query_s2(int l,int r,int k=1)
{
	if(l>r)return 0;
	if(l<=t[k].l&&t[k].r<=r)return t[k].sum2;
	int pos=(t[k].l+t[k].r)>>1;
	if(l>pos)return query_s2(l,r,k<<1|1);
	if(r<=pos)return query_s2(l,r,k<<1);
	return query_s2(l,r,k<<1)+query_s2(l,r,k<<1|1);
}

void print_matrix(const matrix& a)
{
	for(int i=0;i<a.r;i++)
	{
		for(int j=0;j<a.c;j++)printf("%lld ",a.num[i][j]);
		puts("");
	}
}

int main()
{
	scanf("%d",&n);for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	init();
	build(1,n);
	/*matrix t=fs;
	for(int i=1;i<=n;i++)
	{
		if(a[i])t=t*f1;else t=t*f0;
		print_matrix(t);puts("");
	}*/
	scanf("%d",&m);int op=0,pos=0,l=0,r=0;
	while(m--)
	{
		scanf("%d",&op);
		if(op==1)
		{
			scanf("%d",&pos);
			a[pos]^=1;change(pos);if(pos>1)change(pos-1);
			//for(int i=1;i<=n;i++)printf("%d ",query_s2(i,i));puts("");
		}
		else
		{
			scanf("%d%d",&l,&r);
			long long len=r-l+1;
			long long ans0=len*(len+1)/2;
			long long ans1=(fs*query_f(l,r)).num[0][4];
			long long ans2=(gs*query_g(l,r)).num[0][2];
			long long ans3=query_s1(l,r)+query_s2(l,r-1);
			//printf("%lld %lld %lld %lld\n",ans0,ans1,ans2,ans3);
			printf("%lld\n",ans0-ans1-ans2+ans3);
		}
	}
	return 0;
}
```

在洛谷上交一发，[AC](https://www.luogu.com.cn/record/30018039)！

好了本题解到此……

进入最精彩的地方！（什么你以为它要结束了？）

如果你把上面这份代码往[LOJ](https://loj.ac/problem/2492)上交会发现它[TLE](https://loj.ac/submission/735635)得不要不要的……

怎么办？我们发现，可以优化常数！

**优化一**

欸你看看那个`change(pos-1)`，它又不用修改矩阵$f,g$的值，只是维护一下$sum2$，能不能省下这部分的事件？

能！加个标记！

```cpp
#include<cstdio>
#include<cstring>

using namespace std;

int n=0,m=0;
int a[200000];

struct matrix
{
	int r,c;
	long long num[6][6];
	matrix(int rr=0,int cc=0):r(rr),c(cc){memset(num,0,sizeof(num));}
	matrix operator=(const matrix& a){this->r=a.r,this->c=a.c;memcpy(this->num,a.num,sizeof(a.num));return *this;}
};

matrix operator*(const matrix &a,const matrix& b)
{
	if(a.c!=b.r){return matrix();}
	matrix ans(a.r,b.c);
	for(int i=0;i<a.r;i++)
	{
		for(int j=0;j<b.c;j++)
		{
			for(int k=0;k<a.c;k++)
			{
				ans.num[i][j]+=a.num[i][k]*b.num[k][j];
			}
		}
	}
	return ans;
}

matrix f0(6,6),f1(6,6),g0(4,4),g1(4,4),fs(1,6),gs(1,4);
void init()
{
	f0.num[0][2]=f0.num[1][3]=f0.num[1][4]=f0.num[4][4]=f0.num[5][2]=f0.num[5][5]=1;
	f1.num[0][1]=f1.num[0][4]=f1.num[1][0]=f1.num[2][3]=f1.num[2][4]=f1.num[3][2]=f1.num[4][4]=f1.num[5][1]=f1.num[5][4]=f1.num[5][5]=1;
	g0.num[0][0]=g0.num[1][1]=g0.num[1][2]=g0.num[2][2]=g0.num[3][0]=g0.num[3][3]=1;
	g1.num[0][1]=g1.num[0][2]=g1.num[2][2]=g1.num[3][1]=g1.num[3][2]=g1.num[3][3]=1;
	fs.num[0][5]=1,gs.num[0][3]=1;
}

struct nd
{
	int l,r;matrix f,g;int sum1,sum2;
}t[400000];
void build(int l,int r,int k=1)
{
	t[k].l=l,t[k].r=r;
	if(l==r)
	{
		if(a[l]==0)t[k].f=f0,t[k].g=g0;else t[k].f=f1,t[k].g=g1;
		t[k].sum1=a[l];if(l<n&&(a[l]^a[l+1]))t[k].sum2=1;return;
	}
	int mid=(l+r)>>1;build(l,mid,k<<1),build(mid+1,r,k<<1|1);
	t[k].f=t[k<<1].f*t[k<<1|1].f,t[k].g=t[k<<1].g*t[k<<1|1].g;
	t[k].sum1=t[k<<1].sum1+t[k<<1|1].sum1,t[k].sum2=t[k<<1].sum2+t[k<<1|1].sum2;
}
void change(int pos,bool fl,int k=1)
{
	if(t[k].l==t[k].r)
	{
		if(fl)
		{
			if(a[pos]==0)t[k].f=f0,t[k].g=g0;else t[k].f=f1,t[k].g=g1;
			t[k].sum1=a[pos];
		}
		if(pos<n&&(a[pos]^a[pos+1]))t[k].sum2=1;else t[k].sum2=0;return;
	}
	int mid=(t[k].l+t[k].r)>>1;
	if(pos<=mid)change(pos,fl,k<<1);else change(pos,fl,k<<1|1);
	if(fl)
	{
		t[k].f=t[k<<1].f*t[k<<1|1].f,t[k].g=t[k<<1].g*t[k<<1|1].g;
		t[k].sum1=t[k<<1].sum1+t[k<<1|1].sum1;
	}
	t[k].sum2=t[k<<1].sum2+t[k<<1|1].sum2;
}
matrix query_f(int l,int r,int k=1)
{
	if(l<=t[k].l&&t[k].r<=r)return t[k].f;
	int pos=(t[k].l+t[k].r)>>1;
	if(l>pos)return query_f(l,r,k<<1|1);
	if(r<=pos)return query_f(l,r,k<<1);
	return query_f(l,r,k<<1)*query_f(l,r,k<<1|1);
}
matrix query_g(int l,int r,int k=1)
{
	if(l<=t[k].l&&t[k].r<=r)return t[k].g;
	int pos=(t[k].l+t[k].r)>>1;
	if(l>pos)return query_g(l,r,k<<1|1);
	if(r<=pos)return query_g(l,r,k<<1);
	return query_g(l,r,k<<1)*query_g(l,r,k<<1|1);
}
int query_s1(int l,int r,int k=1)
{
	if(l>r)return 0;
	if(l<=t[k].l&&t[k].r<=r)return t[k].sum1;
	int pos=(t[k].l+t[k].r)>>1;
	if(l>pos)return query_s1(l,r,k<<1|1);
	if(r<=pos)return query_s1(l,r,k<<1);
	return query_s1(l,r,k<<1)+query_s1(l,r,k<<1|1);
}
int query_s2(int l,int r,int k=1)
{
	if(l>r)return 0;
	if(l<=t[k].l&&t[k].r<=r)return t[k].sum2;
	int pos=(t[k].l+t[k].r)>>1;
	if(l>pos)return query_s2(l,r,k<<1|1);
	if(r<=pos)return query_s2(l,r,k<<1);
	return query_s2(l,r,k<<1)+query_s2(l,r,k<<1|1);
}

void print_matrix(const matrix& a)
{
	for(int i=0;i<a.r;i++)
	{
		for(int j=0;j<a.c;j++)printf("%lld ",a.num[i][j]);
		puts("");
	}
}

int main()
{
	scanf("%d",&n);for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	init();
	build(1,n);
	scanf("%d",&m);int op=0,pos=0,l=0,r=0;
	while(m--)
	{
		scanf("%d",&op);
		if(op==1)
		{
			scanf("%d",&pos);
			a[pos]^=1;change(pos,true);if(pos>1)change(pos-1,false);
			//for(int i=1;i<=n;i++)printf("%d ",query_s2(i,i));puts("");
		}
		else
		{
			scanf("%d%d",&l,&r);
			long long len=r-l+1;
			long long ans0=len*(len+1)/2;
			long long ans1=(fs*query_f(l,r)).num[0][4];
			long long ans2=(gs*query_g(l,r)).num[0][2];
			long long ans3=query_s1(l,r)+query_s2(l,r-1);
			//printf("%lld %lld %lld %lld\n",ans0,ans1,ans2,ans3);
			printf("%lld\n",ans0-ans1-ans2+ans3);
		}
	}
	return 0;
}
```

欸过了LOJ上的题啦！

然后信誓旦旦往史上最卡常OJ [BZOJ](https://www.lydsy.com/JudgeOnline/problem.php?id=5294)上一交……

$\text{TLE}$！

怎么办？继续优化！

**优化二**

欸那个矩阵还是不要作为返回值了吧，在过程里乘不行吗？

可以！而且优化很大！

（考虑到篇幅，不贴出代码了，链接：[优化二](https://loj.ac/submission/735644) 可以看到最大点从$800\text{ms}$变到了$\text{700ms}$）

但还是过不了BZOJ……

**优化三**

欸那个矩阵一大堆零，乘的时候是不是可以再优化一下啊？

可以！

终于过题啦！下面是最终代码：

```cpp
#include<cstdio>
#include<cstring>

using namespace std;

int n=0,m=0;
int a[200000];

struct matrix
{
	int r,c;
	long long num[6][6];
	matrix(int rr=0,int cc=0):r(rr),c(cc){memset(num,0,sizeof(num));}
	matrix operator=(const matrix& a){this->r=a.r,this->c=a.c;memcpy(this->num,a.num,sizeof(a.num));return *this;}
};

matrix operator*(const matrix &a,const matrix& b)
{
	if(a.c!=b.r){return matrix();}
	matrix ans(a.r,b.c);
	for(int j=0;j<b.c;j++)
	{
		for(int k=0;k<a.c;k++)
		{
			if(b.num[k][j]==0)continue;
			for(int i=0;i<a.r;i++)
			{
				ans.num[i][j]+=a.num[i][k]*b.num[k][j];
			}
		}
	}
	return ans;
}

matrix f0(6,6),f1(6,6),g0(4,4),g1(4,4),fs(1,6),gs(1,4);
void init()
{
	f0.num[0][2]=f0.num[1][3]=f0.num[1][4]=f0.num[4][4]=f0.num[5][2]=f0.num[5][5]=1;
	f1.num[0][1]=f1.num[0][4]=f1.num[1][0]=f1.num[2][3]=f1.num[2][4]=f1.num[3][2]=f1.num[4][4]=f1.num[5][1]=f1.num[5][4]=f1.num[5][5]=1;
	g0.num[0][0]=g0.num[1][1]=g0.num[1][2]=g0.num[2][2]=g0.num[3][0]=g0.num[3][3]=1;
	g1.num[0][1]=g1.num[0][2]=g1.num[2][2]=g1.num[3][1]=g1.num[3][2]=g1.num[3][3]=1;
	fs.num[0][5]=1,gs.num[0][3]=1;
}

struct nd
{
	int l,r;matrix f,g;int sum1,sum2;
}t[400000];
void build(int l,int r,int k=1)
{
	t[k].l=l,t[k].r=r;
	if(l==r)
	{
		if(a[l]==0)t[k].f=f0,t[k].g=g0;else t[k].f=f1,t[k].g=g1;
		t[k].sum1=a[l];if(l<n&&(a[l]^a[l+1]))t[k].sum2=1;return;
	}
	int mid=(l+r)>>1;build(l,mid,k<<1),build(mid+1,r,k<<1|1);
	t[k].f=t[k<<1].f*t[k<<1|1].f,t[k].g=t[k<<1].g*t[k<<1|1].g;
	t[k].sum1=t[k<<1].sum1+t[k<<1|1].sum1,t[k].sum2=t[k<<1].sum2+t[k<<1|1].sum2;
}
void change(int pos,bool fl,int k=1)
{
	if(t[k].l==t[k].r)
	{
		if(fl)
		{
			if(a[pos]==0)t[k].f=f0,t[k].g=g0;else t[k].f=f1,t[k].g=g1;
			t[k].sum1=a[pos];
		}
		if(pos<n&&(a[pos]^a[pos+1]))t[k].sum2=1;else t[k].sum2=0;return;
	}
	int mid=(t[k].l+t[k].r)>>1;
	if(pos<=mid)change(pos,fl,k<<1);else change(pos,fl,k<<1|1);
	if(fl)
	{
		t[k].f=t[k<<1].f*t[k<<1|1].f,t[k].g=t[k<<1].g*t[k<<1|1].g;
		t[k].sum1=t[k<<1].sum1+t[k<<1|1].sum1;
	}
	t[k].sum2=t[k<<1].sum2+t[k<<1|1].sum2;
}
matrix fans,gans;
int query_s1(int l,int r,int k=1)
{
	if(l>r)return 0;
	if(l<=t[k].l&&t[k].r<=r)
	{
		fans=fans*t[k].f,gans=gans*t[k].g;
		return t[k].sum1;
	}
	int pos=(t[k].l+t[k].r)>>1;
	if(l>pos)return query_s1(l,r,k<<1|1);
	if(r<=pos)return query_s1(l,r,k<<1);
	return query_s1(l,r,k<<1)+query_s1(l,r,k<<1|1);
}
int query_s2(int l,int r,int k=1)
{
	if(l>r)return 0;
	if(l<=t[k].l&&t[k].r<=r)return t[k].sum2;
	int pos=(t[k].l+t[k].r)>>1;
	if(l>pos)return query_s2(l,r,k<<1|1);
	if(r<=pos)return query_s2(l,r,k<<1);
	return query_s2(l,r,k<<1)+query_s2(l,r,k<<1|1);
}

void print_matrix(const matrix& a)
{
	for(int i=0;i<a.r;i++)
	{
		for(int j=0;j<a.c;j++)printf("%lld ",a.num[i][j]);
		puts("");
	}
}

int main()
{
	scanf("%d",&n);for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	init();
	build(1,n);
	scanf("%d",&m);int op=0,pos=0,l=0,r=0;
	while(m--)
	{
		scanf("%d",&op);
		if(op==1)
		{
			scanf("%d",&pos);
			a[pos]^=1;change(pos,true);if(pos>1)change(pos-1,false);
			//for(int i=1;i<=n;i++)printf("%d ",query_s2(i,i));puts("");
		}
		else
		{
			scanf("%d%d",&l,&r);
			long long len=r-l+1;
			long long ans0=len*(len+1)/2;
			fans=fs,gans=gs;
			long long ans3=query_s1(l,r)+query_s2(l,r-1);
			long long ans1=fans.num[0][4],ans2=gans.num[0][2];
			//printf("%lld %lld %lld %lld\n",ans0,ans1,ans2,ans3);
			printf("%lld\n",ans0-ans1-ans2+ans3);
		}
	}
	return 0;
}
```

**总结**

希望大家从这篇题解里学到两种精神：

- 把问题往熟知的方向转化，化难为易；

- 不要放弃，勇于尝试各种可能。

加油，奥里给！

---

## 作者：dsidsi (赞：5)

# 「BJOI2018」二进制-树状树状+set+二进制

可以发现能被重组成$3$的数满足有偶数个$1$或者有奇数个$1$且$0,1$的个数$\geq 2$。

考虑用总数减去不合法的数量，即有奇数个$1$且$0$的个数$<2$或着只有一个$1$。

不合法的子串要么只有一个$0$要么只有一个$1$，所以用`std::set`维护每个$0,1$的前驱后继。一个单独的$0$对答案的贡献为跨过它的子串且只有一个$0$的方案数加上它右边一段$1$的方案数，一个$1$的贡献类似。

每次询问时，用树状数组维护中间的答案，对于第一个/倒数第一个$0/1$特殊处理，最后减去重复的部分(单独的$1$以及$01/10$)

```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
using namespace std;

typedef long long lint;
const int maxn = 100005;

int n, m, a[maxn];
set<int> s[2];
lint Sum[4][maxn], sr0[maxn], slr0[maxn], slr1[maxn];

inline int gi()
{
    char c = getchar();
    while (c < '0' || c > '9') c = getchar();
    int sum = 0;
    while ('0' <= c && c <= '9') sum = sum * 10 + c - 48, c = getchar();
    return sum;
}

inline lint calc_r0(int len)
{
    if (len & 1) return (lint)(len / 2 + 1) * (len / 2 + 1);
    else return (lint)(len / 2) * (len / 2 + 1);
}
inline lint calc_lr0(int len1, int len2) {return (lint)(len1 + 1) * (len2 + 1) / 2;}
inline lint calc_lr1(int len1, int len2) {return (lint)(len1 + 1) * (len2 + 1);}

inline void add(int Id, int x, int v) {for ( ; x <= n; x += (x & (-x))) Sum[Id][x] += v;}
inline int sum(int Id, int x) {int res = 0; for ( ; x; x -= (x & (-x))) res += Sum[Id][x]; return res;}

void calc0(int p)
{
    static int p1, p2;
    static set<int>::iterator it;
    
    add(0, p, -sr0[p] - slr0[p]);
    it = s[0].upper_bound(p); p2 = *it;
    --it; --it; p1 = *it;

    sr0[p] = calc_r0(p2 - p - 1);
    slr0[p] = calc_lr0(p - p1 - 1, p2 - p - 1);
    add(0, p, sr0[p] + slr0[p]);
}

void calc1(int p)
{
    static int p1, p2;
    static set<int>::iterator it;

    add(1, p, -slr1[p]);
    it = s[1].upper_bound(p); p2 = *it;
    --it; --it; p1 = *it;

    slr1[p] = calc_lr1(p - p1 - 1, p2 - p - 1);
    add(1, p, slr1[p]);
}

lint calc0(int l, int r)
{
    static int p1, p2, p3, p4;
    static lint ans;
    static set<int>::iterator it;

    it = s[0].lower_bound(l); p1 = *it;
    if (p1 > r) return calc_r0(r - l + 1);
    ++it; p2 = *it;
    if (p2 > r) return calc_lr0(p1 - l, r - p1) + calc_r0(p1 - l) + calc_r0(r - p1);
    
    it = s[0].upper_bound(r);
    --it; p4 = *it;
    --it; p3 = *it;
    
    ans = sum(0, p4 - 1) - sum(0, p1);
    ans += sr0[p1] + calc_r0(p1 - l) + calc_r0(r - p4) + calc_lr0(p1 - l, p2 - p1 - 1) + calc_lr0(p4 - p3 - 1, r - p4);
    return ans;
}

lint calc1(int l, int r)
{
    static int p1, p2, p3, p4;
    static lint ans;
    static set<int>::iterator it;

    it = s[1].lower_bound(l); p1 = *it;
    if (p1 > r) return 0;
    ++it; p2 = *it;
    if (p2 > r) return calc_lr1(p1 - l, r - p1);

    it = s[1].upper_bound(r);
    --it; p4 = *it;
    --it; p3 = *it;

    ans = sum(1, p4 - 1) - sum(1, p1);
    ans += calc_lr1(p1 - l, p2 - p1 - 1) + calc_lr1(p4 - p3 - 1, r - p4);
    return ans;
}

lint calc2(int l, int r) {return sum(2, r) - sum(2, l - 1);}
lint calc3(int l, int r) {return sum(3, r - 1) - sum(3, l - 1);}

int main()
{
    n = gi();
    
    s[0].insert(0); s[0].insert(n + 1);
    s[1].insert(0); s[1].insert(n + 1);
    
    for (int i = 1; i <= n; ++i) {
        a[i] = gi();
        s[a[i]].insert(i);
    }

    for (int i = 1; i <= n; ++i) {
        if (!a[i]) calc0(i);
        else calc1(i), add(2, i, 1);
        if (i != n && (a[i] ^ a[i + 1]))
            add(3, i, 1);
    }
    
    m = gi();
    int opt, x, y, p1, p2;
    set<int>::iterator it;
    while (m--) {
        opt = gi();
        if (opt == 1) {
            x = gi();

            if (a[x]) add(2, x, -1);
            else add(2, x, 1);
            if (x != 1) {
                if (a[x - 1] ^ a[x]) add(3, x - 1, -1);
                else add(3, x - 1, 1);
            }
            if (x != n) {
                if (a[x] ^ a[x + 1]) add(3, x, -1);
                else add(3, x, 1);
            }
            
            if (a[x] == 0) {
                add(0, x, -sr0[x] - slr0[x]);
                sr0[x] = slr0[x] = 0;
                
                s[0].erase(x);
                it = s[0].upper_bound(x); p2 = *it;
                --it; p1 = *it;
                if (p1 != 0) calc0(p1); if (p2 != n + 1) calc0(p2);
                
                s[1].insert(x);
                it = s[1].upper_bound(x); p2 = *it;
                --it; --it; p1 = *it;
                if (p1 != 0) calc1(p1); if (p2 != n + 1) calc1(p2);
                calc1(x);
            } else {
                add(1, x, -slr1[x]);
                slr1[x] = 0;

                s[1].erase(x);
                it = s[1].upper_bound(x); p2 = *it;
                --it; p1 = *it;
                if (p1 != 0) calc1(p1); if (p2 != n + 1) calc1(p2);

                s[0].insert(x);
                it = s[0].upper_bound(x); p2 = *it;
                --it; --it; p1 = *it;
                if (p1 != 0) calc0(p1); if (p2 != n + 1) calc0(p2);
                calc0(x);
            }

            a[x] ^= 1;
        } else {
            x = gi(); y = gi();
            printf("%lld\n", (lint)(y - x + 1) * (y - x + 2) / 2 - (calc0(x, y) + calc1(x, y) - calc2(x, y) - calc3(x, y)));
        }
    }

    return 0;
}
```

---

## 作者：_Fontainebleau_ (赞：3)

##  题意

- 给定一个长度为 $n$ 的二进制串，以及 $m$ 次操作。操作分两种：
   - 将第 $i$ 个位置取反。
   - 求区间 $[l,r]$ 内有多少个连续子序列，满足可以将其重排为 $3$ 的倍数。
- $1\le{n,m}\le10^5$。

## 做法

### $3$ 的倍数？

什么样的序列重排后可以是 $3$ 的倍数？

注意到 $2\equiv-1,2^2\equiv1\pmod{3}$，所以二进制下每一位 $\bmod{3}$ 的结果是：$1,-1;1,-1;1,-1;\cdots$。我们需要让两种位置上的 $1$ 的个数 $\bmod{3}$ 相同。
不妨设区间长 $l$，结果为 $1$ 的位置上 $1$ 的个数为 $x$，结果为 $-1$ 的位置上的 $1$ 的个数为 $y$，总共有 $k$ 个 $1$。则结果为 $1$ 的位置有 $\left\lfloor\dfrac{l+1}2\right\rfloor$ 个，结果为 $-1$ 的位置有 $\left\lfloor\dfrac{l}2\right\rfloor$ 个。

所以，问题转化为将 $x+y=k,x\equiv{y}\pmod{3}$ 的 $x$ 填到 $\left\lfloor\dfrac{l+1}2\right\rfloor$ 个空格中，$y$ 填到 $\left\lfloor\dfrac{l}2\right\rfloor$ 个空格中。由于 $x\equiv{y}\pmod3$，顺序不影响，且 $\left\lfloor\dfrac{l+1}2\right\rfloor\ge{\left\lfloor\dfrac{l}2\right\rfloor}$，所以不妨 $x\ge{y}$。

我们现在希望 $x,y$ 越近越好，因为这样对 $k$ 的要求会比较松。不妨设一个满足的 $x=y+3k,k\in\mathbb{Z}_{\ge0}$，每次修改 $x,y$ 的距离改变 $6$。若 $2\nmid{k}$，则可以化成 $x=y+3$；否则可化成 $x=y$。

### 怎么判断？

如果 $2\mid{k}$，$x=y=\dfrac{k}2$ 即可。

如果 $2\nmid{k}$，那么需要取 $x=y+3$，所以首先 $k\ge3$。其次，此时 $x=\dfrac{k+3}2\le\left\lfloor\dfrac{l+1}2\right\rfloor$。$2\mid{l}$ 时，需要 $l\ge{k+3}$；否则，$l\ge{k+2}$。

这好像情况挺多，有点难干啊，怎么办？正难则反，我们看不合法的情况：

- $k=1$。
- $2\mid{l}$ 时，$k=l-1$，换言之，有 $1$ 个 $0$。
- $2\nmid{l}$ 时，$k=l$，换言之，没有 $0$。

合并去重之后，就有：

- $k=1$ 且 $0$ 的个数 $\ge2$。
- $2\nmid{k}$ 且 $0$ 的个数 $<2$。

### 怎么计数？

我们需要单点修改，区间查询。可以考虑线段树。

考虑怎么维护合并节点的贡献？跨越区间，需要记录前缀后缀。

具体地，需要维护：前缀 $0$ 的个数 $l_0$，后缀 $0$ 的个数 $r_0$，只有一个 $1$ 的前缀的个数 $l_1$，只有一个 $1$ 的后缀的个数 $r_1$。

## 代码

具体过程看一下合并就好了，其他就不放了，因为是照着 $\text{\color{black}R\color{red}{emake}}$ 神仙的写的。

另外，写成结构体真的很有用！

```cpp
SMT(SMT L,SMT R,int mid)
{
	init();
	C0=L.C0+R.C0,C1=L.C1+R.C1;
	l0=L.l0+(!L.C1?R.l0:0),r0=R.r0+(!R.C1?L.r0:0);
	l1=L.l1+(!L.C1?R.l1:0)+(L.C1==1?R.l0:0),r1=R.r1+(!R.C1?L.r1:0)+(R.C1==1?L.r0:0);
	for(int i=0;i<2;i++)
		for(int j=0;j<2;j++)
			l[i][j]=L.l[i][j]+(i>=L.C0?R.l[i-L.C0][j^(L.C1&1)]:0),r[i][j]=R.r[i][j]+(i>=R.C0?L.r[i-R.C0][j^(R.C1&1)]:0);
	res=L.res+R.res;res+=1ll*L.r0*R.l1+1ll*L.r1*R.l0;
	res+=1ll*L.r[0][0]*(R.l[0][1]+R.l[1][1])+1ll*L.r[0][1]*(R.l[0][0]+R.l[1][0]); 
	res+=1ll*L.r[1][0]*R.l[0][1]+1ll*L.r[1][1]*R.l[0][0]; 
	if(a[mid]+a[mid+1]==1)	res--;
}
```

---

## 作者：lnzwz (赞：2)

首先，看到区间的子串，想到线段树区间合并。

考虑一个子问题：判断一个子串是否满足条件。

首先，二进制化为十进制的方法是对应位×位权。

可以发现，位权$mod3$的值是$1,2,1,2$交替。

设这个子串有x个1放在2上，y个放在1上，则应满足$(2x+y)mod3=0$，
即$x=y(mod3)$。

设该子串长度为len，有s个1。

那么，贪心的想，x和y相差0或3。

分情况讨论：
1. $len\%2=0$，$s\%2=0$。需要满足$s/2<=len/2$，显然可以。
2. $len\%2=0$，$s\%2=1$。即$x+y=s,x-y=3$，解得$x=(s+3)/2$。需要满足$(s+3)/2<=len/2$，即$s<=len-3$。
3. $len\%2=1$，$s\%2=0$。需要满足$s/2<=(len-1)/2$，显然可以。
4. $len\%2=1$，$s\%2=1$。同理，$x=(s+3)/2$。需要满足$(s+3)/2<=(len+1)/2$，即$s<=len-2$。

可以发现，s为偶数时一定可以。s为奇数时比较复杂，难以统计（因为即使len确定，满足要求的s有很多，无法进行区间合并）。

考虑容斥，求不合法的。

若不合法，则$s\%2=1$。

分两种情况讨论：
1. $len\%2=0$，即$s>=len-2$。因为$s\%2=1,s<=len$，所以$s=len-1$。
2. $len\%2=1$，即$s>=len-1$。因为$s\%2=1,s<=len$，所以$s=len$。

此外，若$s=1$，也不合法。把这部分减去，再加上$s=1$且$len<=2$的情况（被算了两次）。

时间复杂度：$O(mlogn)$，常数很大。

注意区间合并的细节。

### 代码：
```cpp
#include <stdio.h> 
#define ll long long 
struct SJd {
	ll s[2][2];
	SJd() {
		s[0][0] = s[0][1] = s[1][0] = s[1][1] = 0;
	}
};
SJd operator * (SJd a, SJd b) {
	SJd rt;
	for (int x = 0; x < 2; x++) {
		for (int y = 0; y < 2; y++) {
			int z = (x + y) % 2;
			rt.s[z][0] += a.s[x][0] * b.s[y][0];
			rt.s[z][1] += a.s[x][0] * b.s[y][1] + a.s[x][1] * b.s[y][0];
		}
	}
	return rt;
}
SJd operator + (SJd a, SJd b) {
	SJd rt;
	rt.s[0][0] = a.s[0][0] + b.s[0][0];
	rt.s[0][1] = a.s[0][1] + b.s[0][1];
	rt.s[1][0] = a.s[1][0] + b.s[1][0];
	rt.s[1][1] = a.s[1][1] + b.s[1][1];
	return rt;
}
SJd he[400010],zg[400010],zl[400010],zr[400010];
ll s0[400010],s1[400010],s2[400010];
bool h0[400010],h1[400010];
int sz[100010],l0[400010],l1[400010],r0[400010],r1[400010],su[400010],ma = 0,sl;
void fuz(int i, int j) {
	he[i]=he[j];zg[i]=zg[j];
	zl[i]=zl[j];zr[i]=zr[j];
	s0[i]=s0[j];s1[i]=s1[j];s2[i]=s2[j];
	h0[i]=h0[j];h1[i]=h1[j];
	l0[i]=l0[j];l1[i]=l1[j];
	r0[i]=r0[j];r1[i]=r1[j];
	su[i]=su[j];
}
void merge(int i, int cl, int cr, int m) {
	h0[i] = h0[cl] && h0[cr];
	h1[i] = (h1[cl] && h0[cr]) || (h0[cl] && h1[cr]);
	l0[i] = l0[cl];
	if (h0[cl]) l0[i] += l0[cr];
	r0[i] = r0[cr];
	if (h0[cr]) r0[i] += r0[cl];
	l1[i] = l1[cl];
	if (h0[cl]) l1[i] += l1[cr];
	if (h1[cl]) l1[i] += l0[cr];
	r1[i] = r1[cr];
	if (h0[cr]) r1[i] += r1[cl];
	if (h1[cr]) r1[i] += r0[cl];
	s0[i] = s0[cl] + s0[cr] + 1ll * r0[cl] * l0[cr];
	s1[i] = s1[cl] + s1[cr] + 1ll * r0[cl] * l1[cr] + 1ll * r1[cl] * l0[cr];
	s2[i] = s2[cl] + s2[cr] + (sz[m - 1] + sz[m] == 1);
	zg[i] = zg[cl] * zg[cr];
	zl[i] = zl[cl] + zg[cl] * zl[cr];
	zr[i] = zr[cr] + zg[cr] * zr[cl];
	he[i] = he[cl] + he[cr] + zr[cl] * zl[cr];
	su[i] = su[cl] + su[cr];
}
void pushup(int i, int l, int r) {
	int m = (l + r) >> 1;
	merge(i, i << 1, (i << 1) | 1, m);
}
void getddz(int i, int x) {
	l0[i] = r0[i] = s0[i] = h0[i] = (x == 0);
	l1[i] = r1[i] = s1[i] = h1[i] = (x == 1);
	he[i] = zg[i] = zl[i] = zr[i] = SJd();
	he[i].s[1][x ^ 1] += 1;
	zg[i].s[1][x ^ 1] += 1;
	zl[i].s[1][x ^ 1] += 1;
	zr[i].s[1][x ^ 1] += 1;
	su[i] = x;
	s2[i] = 0;
}
void jianshu(int i, int l, int r) {
	if (i > ma) ma = i;
	if (l + 1 == r) {
		getddz(i, sz[l]);
		return;
	}
	int m = (l + r) >> 1;
	jianshu(i << 1, l, m);
	jianshu((i << 1) | 1, m, r);
	pushup(i, l, r);
}
void xiugai(int i, int l, int r, int j) {
	if (l + 1 == r) {
		sz[l] ^= 1;
		getddz(i, sz[l]);
		return;
	}
	int m = (l + r) >> 1;
	if (j < m) xiugai(i << 1, l, m, j);
	else xiugai((i << 1) | 1, m, r, j);
	pushup(i, l, r);
}
void getans(int i, int l, int r, int L, int R) {
	if (R <= l || r <= L) return;
	if (L <= l && r <= R) {
		if (sl == ma) fuz(sl + 1, i);
		else merge(sl + 1, sl, i, l);
		sl += 1;
		return;
	}
	int m = (l + r) >> 1;
	getans(i << 1, l, m, L, R);
	getans((i << 1) | 1, m, r, L, R);
}
ll getans(int n, int l, int r) {
	int s = r - l + 1;
	ll zs = 1ll * s * (s + 1) / 2;
	sl = ma;
	getans(1, 1, n + 1, l, r + 1);
	zs -= (he[sl].s[0][1] + he[sl].s[1][0] + s1[sl]);
	zs += (su[sl] + s2[sl]);
	return zs;
}
int main() {
	int n,m;
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &sz[i]);
	scanf("%d", &m);
	jianshu(1, 1, n + 1);
	for (int i = 0; i < m; i++) {
		int lx;
		scanf("%d", &lx);
		if (lx == 1) {
			int a;
			scanf("%d", &a);
			xiugai(1, 1, n + 1, a);
		} else {
			int a,b;
			scanf("%d%d", &a, &b);
			printf("%lld\n", getans(n, a, b));
		}
	}
	return 0;
}
```


---

## 作者：lzytag (赞：1)

# 题解
[题目传送门](https://www.luogu.com.cn/problem/P4428)
## 题目描述
传送门都给你打好了，不会自己看？
## 做法
首先，我们来猜一下本题的算法。

 $n\le10^5$，那么算法复杂度一定是 $O(n\log n)$ 了

我们看到了区间的查询，单点的修改。

再加上 $O(n\log n)$ 的复杂度。

一定是线段树没跑了！

那么我们知道了线段树，如何线段树呢？

让我们回到题目。

## 数学的分析
$3$ 在二进制里的整除特征是什么？

我们知道 $3 = (11)_2$。

所以 $3$ 二进制的整除特征应该与十进制里的 $11$ 相似。

我们都知道 $11$ 的整除特征有两个。

第一个是把十进制数两位一断，得到很多个两位数。

再把所有两位数加起来，得到的数如果能被 $11$ 整除，那么原数也能被 $11$ 整除。

第二个则是把十进制数一位一断，奇数位减偶数位的差如果能被 $11$ 整除，则原数也能被 $11$ 整除。

用和十进制下相似的证法，可以得到这两个整出特征都适用于二进制里的 $(11)_2$。

但我们知道前者在计算时是以两位一断的，很显然不好利用。

所以我们用后者。

那我们想什么情况下一个二进制数重新排列后可以被 $3$ 整除。

+ 如果它有偶数个 $1$ 那么很显然它可以使奇数位和偶数位上的 $1$ 数量相等。

+ 当它有奇数个 $1$ 时，我们又要分类：

	+ 如果只有一个 $1$，那它是不可能被 $3$ 整除的。

	+ 如果有三个及以上的 $1$ 时再分类:
    
    	+ 如果有一或零个 $0$，我们仔细枚举一下 $0$ 在奇数位或偶数位，发现是不可能的。

      + 如果有三个及以上的 $0$，也易证他是可以被整除的

所以我们可以得到总结论了。

但从正面找“可以被整除的”还是有点难，所以我们“正难则反”，去找“不能被整除的”。

“不能被整除”的字串应满足下面两个条件之一：

+ 有且只有一个 $1$

+ 有奇数个 $1$ 且 $0$ 的个数小于等于 $1$

为防止算重，将第一个条件改为：

+ 有且只有一个 $1$，且 $0$ 的个数大于等于 $2$

然后我们就可以用线段树的节点存储它代表的这一个子串中的一系列值，并进行子串的合并了。

这个存法很多，在这里给出我的一个不太高明的存法。

定义如下：

``` cpp

struct Node{
	int l[2][3],r[2][3];
	//l(r)[x][y]代表从左(右)边开始有x个1和y个0的段数(y为2则代表0的个数>=2) 
	int dl[2][2],dr[2][2];
	//dl(dr)[x][y]代表从左(右)开始有2k+x(k为自然数)个1与y个0的段数 
	int cnt[2];
	//cnt[x]代表x的个数 
	ll ans;
	//ans代表段内的答案数 
	//这些全开ll会MLE,所以除ans全用int 
	Node()
	{
		memset(this,0,sizeof(Node));
	}
}tr[MaxN*4];
```
合并如下：
``` cpp
Node operator + (Node x,Node y)//好长，请自行忽略 
{
	Node res;
	//upd ans
	res.ans = x.ans + y.ans;
	res.ans += 1ll*y.l[1][2]*(x.r[0][0]+x.r[0][1]+x.r[0][2]) + 1ll*y.l[1][1]*(x.r[0][1]+x.r[0][2]) + 1ll*y.l[1][0]*x.r[0][2];
	res.ans += 1ll*y.l[0][2]*(x.r[1][0]+x.r[1][1]+x.r[1][2]) + 1ll*y.l[0][1]*(x.r[1][1]+x.r[1][2]) + 1ll*y.l[0][0]*x.r[1][2];
	res.ans += 1ll*x.dr[1][1]*y.dl[0][0] + 1ll*x.dr[1][0]*(y.dl[0][1] + y.dl[0][0]) + 1ll*x.dr[0][1]*y.dl[1][0] + 1ll*x.dr[0][0]*(y.dl[1][1]+y.dl[1][0]);
	//这一段代码是有点长，但试图优化的我被大常数卡爆了！ 
	//upd cnt
	res.cnt[1] = x.cnt[1] + y.cnt[1];
	res.cnt[0] = x.cnt[0] + y.cnt[0];
	//upd l r
	for(int i = 0;i <= 1;i++)
	{
		for(int j = 0;j <= 2;j++)
		{
			res.l[i][j] += x.l[i][j];
			res.r[i][j] += y.r[i][j];
			if(x.cnt[1] + i <= 1) res.l[x.cnt[1] + i][min(2,j+x.cnt[0])] += y.l[i][j];
			if(y.cnt[1] + i <= 1) res.r[y.cnt[1] + i][min(2,j+y.cnt[0])] += x.r[i][j];
		}
	}
	//upd dl dr
	for(int i=0;i<=1;i++)
	{
		for(int j=0;j<=1;j++)
		{
			res.dl[i][j] += x.dl[i][j];
			res.dr[i][j] += y.dr[i][j];
			if(x.cnt[0]+j <= 1)	res.dl[(x.cnt[1]+i)%2][x.cnt[0]+j] += y.dl[i][j];
			if(y.cnt[0]+j <= 1)	res.dr[(y.cnt[1]+i)%2][y.cnt[0]+j] += x.dr[i][j];
		}
	}
	return res;
}
```
全部代码如下：
``` cpp
#include<bits/stdc++.h>
using namespace std;
#define MaxN 1000005
typedef long long ll;
struct Node{
	int l[2][3],r[2][3];
	//l(r)[x][y]代表从左(右)边开始有x个1和y个0的段数(y为2则代表0的个数>=2) 
	int dl[2][2],dr[2][2];
	//dl(dr)[x][y]代表从左(右)开始有2k+x(k为自然数)个1与y个0的段数 
	int cnt[2];
	//cnt[x]代表x的个数 
	ll ans;
	//ans代表段内的答案数 
	//这些全开ll会MLE,所以除ans全用int 
	Node()
	{
		memset(this,0,sizeof(Node));
	}
}tr[MaxN*4];
int n,m;
Node operator + (Node x,Node y)//好长，请自行忽略 
{
	Node res;
	//upd ans
	res.ans = x.ans + y.ans;
	res.ans += 1ll*y.l[1][2]*(x.r[0][0]+x.r[0][1]+x.r[0][2]) + 1ll*y.l[1][1]*(x.r[0][1]+x.r[0][2]) + 1ll*y.l[1][0]*x.r[0][2];
	res.ans += 1ll*y.l[0][2]*(x.r[1][0]+x.r[1][1]+x.r[1][2]) + 1ll*y.l[0][1]*(x.r[1][1]+x.r[1][2]) + 1ll*y.l[0][0]*x.r[1][2];
	res.ans += 1ll*x.dr[1][1]*y.dl[0][0] + 1ll*x.dr[1][0]*(y.dl[0][1] + y.dl[0][0]) + 1ll*x.dr[0][1]*y.dl[1][0] + 1ll*x.dr[0][0]*(y.dl[1][1]+y.dl[1][0]);
	//这一段代码是有点长，但试图优化的我被大常数卡爆了！ 
	//upd cnt
	res.cnt[1] = x.cnt[1] + y.cnt[1];
	res.cnt[0] = x.cnt[0] + y.cnt[0];
	//upd l r
	for(int i = 0;i <= 1;i++)
	{
		for(int j = 0;j <= 2;j++)
		{
			res.l[i][j] += x.l[i][j];
			res.r[i][j] += y.r[i][j];
			if(x.cnt[1] + i <= 1) res.l[x.cnt[1] + i][min(2,j+x.cnt[0])] += y.l[i][j];
			if(y.cnt[1] + i <= 1) res.r[y.cnt[1] + i][min(2,j+y.cnt[0])] += x.r[i][j];
		}
	}
	//upd dl dr
	for(int i=0;i<=1;i++)
	{
		for(int j=0;j<=1;j++)
		{
			res.dl[i][j] += x.dl[i][j];
			res.dr[i][j] += y.dr[i][j];
			if(x.cnt[0]+j <= 1)	res.dl[(x.cnt[1]+i)%2][x.cnt[0]+j] += y.dl[i][j];
			if(y.cnt[0]+j <= 1)	res.dr[(y.cnt[1]+i)%2][y.cnt[0]+j] += x.dr[i][j];
		}
	}
	return res;
}

Node work(int x)
{
	Node res;
	res.l[x][x^1] = 1;
	res.r[x][x^1] = 1;
	res.dl[x][x^1] = 1;
	res.dr[x][x^1] = 1;
	res.cnt[x]++;
	if(x == 1) res.ans = 1;
	return res;
}

void build(int c,int l,int r)
{
	if(l==r)
	{
		int x;
		cin>>x;
		tr[c] = work(x);
		return ;
	}
	int mid = (l+r)/2;
	build(c*2,l,mid);
	build(c*2+1,mid+1,r);
	tr[c] = tr[c*2] + tr[c*2+1];
	return ;
}

void upd(int c,int l,int r,int ind)
{
	if(l==r)
	{
		if(tr[c].cnt[1] == 1) tr[c] = work(0);
		else tr[c] = work(1);
		return ;
	}
	int mid = (l+r)/2;
	if(mid < ind) upd(c*2+1,mid+1,r,ind);
	else upd(c*2,l,mid,ind);
	tr[c] = tr[c*2] + tr[c*2+1];
	return ;
}

Node query(int c,int l,int r,int x,int y)
{
	if(l == x && r == y) return tr[c];
	int mid = (l+r)/2;
	if(x > mid) return query(c*2+1,mid+1,r,x,y);
	else if(y <= mid) return query(c*2,l,mid,x,y);
	else return query(c*2,l,mid,x,mid) + query(c*2+1,mid+1,r,mid+1,y);
}

int main()
{
	cin>>n;
	build(1,1,n);
	cin>>m;
	while(m--)
	{
		int op,x,y;
		cin>>op;
		if(op == 1)
		{
			cin>>x;
			upd(1,1,n,x);
		}
		else
		{
			cin>>x>>y;
			int num = y-x+1;
			ll t = 1ll*num*(num+1)/2;
			cout<<t - query(1,1,n,x,y).ans<<endl;
		}
	}
	return 0;
}
```

---

## 作者：brimosta (赞：0)

# P4428 [BJOI2018]二进制题解

二进制位转十进制 $\bmod 3$ 后变成：$1\,2\,1\,2\,1\cdots$（从低到高）。

### 考虑什么样的子串满足条件：

$1$ 的个数为偶数，满足。

$1$ 的个数为奇数：
- 一个 $1$ 的时候肯定不行。
- 有多于 $1$ 个 $1$ 的情况：
  	- 没有 $0$ 时不可以（显然）。
   - 有一个 $0$ 的时候也不行，证明考虑调整，没有 $0$ 时是 $121···121$，设其和为 $3n+1$，添加一个 $0$ 后，会把前面的序列向前挪动一位，会使整个序列的和加一或者不变，即 $3n+1$ 或 $3n+2$ 不满足条件。
  - 有两个 $0$ 的时候可以，考虑三个 $1$ 的情况，可以构造如 $10101$ ，有更多 $1$ 的时候补在前面即可。
  - 有更多 $0$ 时补在前面即可。

### 发现满足条件的子串比较复杂（应该也能维护），于是看什么样的子串不符合要求：
- 有一个 $1$。
- 有奇数个 $1$ 且没有 $0$。
- 有奇数个 $1$ 且有一个 $0$。

### 然后就可以在线段树上维护一些信息来计算

一个长度为 $n$ 的序列共有 $n\times(n+1)\div2$ 个子序列。

对于线段树的一个区间，区间中不满足条件的个数 $=$ 左子 $+$ 右子 $+$ 横穿左右区间的部分。

思考如何计算横穿的答案。（这部分我们只考虑一侧，另一侧同理）

有一个 $1$：
- 左子后缀只有 $1$ 个 $1\times$ 右子前缀只有 $0$ 的个数。

有奇数个 $1$ 且没有 $0$：
- 左子后缀只有奇数个 $1$ 的个数 $\times$ 右子前缀只有偶数个 $1$ 的个数。

有奇数个 $1$ 且有一个 $0$：
- 左子后缀有奇数个 $1$ 加一个 $0$ 的个数 $\times$ 右子前缀只有偶数个 $1$ 的个数。
- 左子后缀只有奇数个 $1$ 的个数 $\times$ 右子前缀有偶数个 $1$ 加一个 $0$ 的个数。

于是我们需要维护的内容就是:

- 前后缀只有 $1$ 个 $1$ 的个数。
- 前后缀只有 $0$ 的个数。
- 前后缀只有奇数个 $1$ 的个数。
- 前后缀只有偶数个 $1$ 的个数。
- 前后缀有奇数个 $1$ 加 $1$ 个 $0$ 的个数。
- 前后缀有偶数个 $1$ 加 $1$ 个 $0$ 的个数。

整理简化一下变成：

- 前后缀形如 $0\cdots010\cdots0$ 的长度和后面 $0$ 的长度（两处的 $0$ 均可没有）。
- 前后缀连续的 $0$ 的长度。
- 前后缀连续的 $1$ 的个长度。
- 前后缀形如 $1\cdots101\cdots1$ 的长度和后面 $1$ 的长度（两处的 $1$ 均可没有）。

同时，为了方便转移，我们还需要记录整段中 $0$ 的个数和 $1$ 的个数。

线段树的转移：（以前缀为例）
- 前缀形如 $0\cdots010\cdots0$ 的长度和后面 $0$ 的长度：
	- 若左子没有 $1$，继承右子。
   - 若左子的这个长度=左子区间长度，则长度 $+=$ 右子前缀 $0$ 的长度。
   - 否则继承左子。
- 前缀连续的 $0$ 的长度：
	- 若左子的这个长度 $=$ 左子区间长度，则长度 $+=$ 右子前缀 $0$ 的长度。
   - 否则继承左子。
- 前缀连续的 $1$ 的个长度：
	- 若左子的这个长度 $=$ 左子区间长度，则长度 $+=$ 右子前缀 $1$ 的长度。
   - 否则继承左子。
- 前缀形如 $1\cdots101\cdots1$ 的长度和后面 $1$ 的长度：
	- 若左子没有 $0$，继承右子。
	- 若左子的这个长度 $=$ 左子区间长度，则长度 $+=$ 右子前缀 $1$ 的长度。
   - 否则继承左子。
   
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
inline ll read()
{
	ll x=0,f=1;char ch=getchar();
	while (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}
	while (isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
int n,a[N];
struct mat{
	int len;
	int cnt[2];
	int len010[2],len0100[2],len0[2],len1[2],len101[2],len1011[2];//0front 1back
	ll ans;
};
mat operator+(mat x,mat y)
{
	mat z;
	z.len = x.len + y.len;
	z.cnt[0] = x.cnt[0] + y.cnt[0];z.cnt[1] = x.cnt[1] + y.cnt[1];
	z.len0[0] = (x.len0[0]==x.len) ? (y.len0[0]+x.len) : (x.len0[0]);
	z.len1[0] = (x.len1[0]==x.len) ? (y.len1[0]+x.len) : (x.len1[0]);
	if(x.cnt[1] == 0) z.len010[0] = (y.len010[0]==0)?0:(x.len+y.len010[0]),z.len0100[0] = y.len0100[0];
	else if(x.len010[0] == x.len) z.len010[0] = x.len010[0]+y.len0[0],z.len0100[0] = x.len0100[0]+y.len0[0];
	else z.len010[0] = x.len010[0],z.len0100[0] = x.len0100[0];
	if(x.cnt[0] == 0) z.len101[0] = (y.len101[0]==0)?0:(x.len+y.len101[0]),z.len1011[0] = y.len1011[0];
	else if(x.len101[0] == x.len) z.len101[0] = x.len101[0]+y.len1[0],z.len1011[0] = x.len1011[0]+y.len1[0];
	else z.len101[0] = x.len101[0],z.len1011[0] = x.len1011[0];
	z.len0[1] = (y.len0[1]==y.len) ? (x.len0[1]+y.len) : (y.len0[1]);
	z.len1[1] = (y.len1[1]==y.len) ? (x.len1[1]+y.len) : (y.len1[1]);
	if(y.cnt[1] == 0) z.len010[1] = (x.len010[1]==0)?0:(y.len+x.len010[1]),z.len0100[1] = x.len0100[1];
	else if(y.len010[1] == y.len) z.len010[1] = y.len010[1]+x.len0[1],z.len0100[1] = y.len0100[1]+x.len0[1];
	else z.len010[1] = y.len010[1],z.len0100[1] = y.len0100[1];
	if(y.cnt[0] == 0) z.len101[1] = (x.len101[1]==0)?0:(y.len+x.len101[1]),z.len1011[1] = x.len1011[1];
	else if(y.len101[1] == y.len) z.len101[1] = y.len101[1]+x.len1[1],z.len1011[1] = y.len1011[1]+x.len1[1];
	else z.len101[1] = y.len101[1],z.len1011[1] = y.len1011[1];
	z.ans = x.ans + y.ans;
	if(z.len == 2)
	{
		if(z.cnt[1] == 1) z.ans++;
		return z;
	}
	z.ans += x.len0100[1]*y.len0[0];
	z.ans += y.len0100[0]*x.len0[1];
	int txx = (x.len101[1]-x.len1011[1])%2==0?x.len1011[1]/2:(x.len1011[1]-1)/2+(x.len101[1]==x.len1011[1]?0:1);
	int tyy = (y.len101[0]-y.len1011[0])%2==0?(y.len1011[0]-1)/2+(y.len101[0]==y.len1011[0]?0:1):y.len1011[0]/2;
	z.ans += ((x.len1[1]+1)/2+txx)*(y.len1[0]/2+tyy) - txx*tyy;
	if((x.len1[1]+1)/2 > 1) z.ans += ((x.len1[1]+1)/2-1)*(y.len0[0]>0);
	tyy = (y.len101[0]-y.len1011[0])%2==0?y.len1011[0]/2:(y.len1011[0]-1)/2+(y.len101[0]==y.len1011[0]?0:1);
	txx = (x.len101[1]-x.len1011[1])%2==0?(x.len1011[1]-1)/2+(x.len101[1]==x.len1011[1]?0:1):x.len1011[1]/2;
	z.ans += ((y.len1[0]+1)/2+tyy)*(x.len1[1]/2+txx) - txx*tyy;
	if((y.len1[0]+1)/2 > 1) z.ans += ((y.len1[0]+1)/2-1)*(x.len0[1]>0);
	return z;
}
mat getmat(int x)
{
	mat z;
	z.len = 1;z.cnt[x] = 1;z.cnt[x^1] = 0;
	if(x == 1) z.ans = 1;
	else z.ans = 0;
	if(x == 0)
	{
		z.len010[0] = z.len010[1] = z.len0100[0] = z.len0100[1] = 0;
		z.len0[0] = z.len0[1] = 1;z.len1[0] = z.len1[1] = 0;
		z.len101[0] = z.len101[1] = z.len1011[0] = z.len1011[1] = 1;
	}
	else
	{
		z.len010[0] = z.len010[1] = z.len0100[0] = z.len0100[1] = 1;
		z.len0[0] = z.len0[1] = 0;z.len1[0] = z.len1[1] = 1;
		z.len101[0] = z.len101[1] = z.len1011[0] = z.len1011[1] = 0;
	}
	return z;
}
struct node{
	int l,r,ls,rs;
	mat d;
	inline void pushup();
}nd[N*4];
int rt,ndcnt;
inline void node::pushup(){d=nd[ls].d+nd[rs].d;}
int build(int l,int r)
{
	int p = ++ndcnt;
	nd[p].l = l,nd[p].r = r;
	if(l == r)
	{
		nd[p].d = getmat(a[l]);
		return p;
	}
	int mid = l + r >> 1;
	nd[p].ls = build(l,mid),nd[p].rs = build(mid+1,r);
	nd[p].pushup();
	return p;
}
void update(int p,int plc)
{
	if(nd[p].l == nd[p].r)
	{
		a[plc] ^= 1;
		nd[p].d = getmat(a[plc]);
		return;
	}
	int mid = nd[p].l + nd[p].r >> 1;
	if(plc <= mid) update(nd[p].ls,plc);
	else update(nd[p].rs,plc);
	nd[p].pushup();
	return;
}
mat query(int p,int l,int r)
{
	if(nd[p].l == l && nd[p].r == r) return nd[p].d;
	int mid = nd[p].l + nd[p].r >> 1;
	if(r <= mid) return query(nd[p].ls,l,r);
	else if(l > mid) return query(nd[p].rs,l,r);
	else return query(nd[p].ls,l,mid)+query(nd[p].rs,mid+1,r);
}
int main()
{
	n = read();
	for(int i = 1;i <= n;i++) a[i] = read();
	rt = build(1,n);
	int m,op,l,r;
	m = read();
	while(m--)
	{
		op = read();l = read();
		if(op == 1) update(rt,l);
		else
		{
			r = read();
			ll len = r-l+1;
			printf("%lld\n",len*(len+1)/2-query(rt,l,r).ans);
		}
	}
	return 0;
}
```

---

## 作者：Sol1 (赞：0)

补一个 BJOI。

首先观察一下什么样的区间可以被排成 $3$ 的倍数。

考虑到第 $k$ 位的权值是 $2^k\equiv (-1)^k\pmod 3$，所以如果一段区间里面有偶数个 $1$ 就直接从最低位往上排 $1$ 就可以了。

如果有奇数个 $1$ 就不能直接对半开。

那就尽量对半开，比如有 $7$ 个 $1$ 和 $2$ 个 $0$，把 $7$ 拆成 $2+5$，构造为 $(101011111)_2=(351)_{10}$。

所以我们发现一个区间可以被重排为 $3$ 的倍数的条件是：**有偶数个 $1$，或者有奇数个 $1$ 的同时有多于 $\geq 3$ 个 $1$ 和 $\geq 2$ 个 $0$。**

那么为了满足条件，我们需要记下什么呢？

1. 需要记下 $1$ 的个数的奇偶性。
2. 需要记下 $0$ 的个数：$=0$，$=1$，或者 $\geq 2$。
3. 需要记下 $1$ 的个数：$=0$，$=1$，或者 $\geq 2$。

于是得到状态 $f_{0/1,0/1/2,0/1/2}$，每一维分别对应上面三条需要记下的信息。

为了支持动态维护，需要记所有前缀的 DP 状态和所有后缀的 DP 状态，再记下 $0$ 的数量和 $1$ 的数量（两个都记为了方便封装），以及整个区间的合法子区间数量。

维护过程大概是这样的：

Step 1，维护出 $0$ 和 $1$ 的数量。

```cpp
Node res;
for (int i = 0;i < 2;i++) res.sum[i] = sum[i] + b.sum[i];
```

Step 2，左侧节点的前缀和右侧节点的后缀合并上来不变，直接复制过来。

```cpp
for (int i = 0;i < 2;i++) {
	for (int j = 0;j < 3;j++) {
		for (int k = 0;k < 3;k++) {
			res.pre[i][j][k] = pre[i][j][k];
			res.suf[i][j][k] = b.suf[i][j][k];
		}
	}
}
```

Step 3，右侧节点的前缀和左侧节点的后缀合并上来分别要加上左侧节点和右侧节点的整体信息。

```cpp
for (int i = 0;i < 2;i++) {
    for (int j = 0;j < 3;j++) {
        for (int k = 0;k < 3;k++) res.pre[(i + sum[1]) & 1][Min(2, j + sum[0])][Min(2, k + sum[1])] += b.pre[i][j][k];
    }
}
for (int i = 0;i < 2;i++) {
    for (int j = 0;j < 3;j++) {
        for (int k = 0;k < 3;k++) res.suf[(i + b.sum[1]) & 1][Min(2, j + b.sum[0])][Min(2, k + b.sum[1])] += suf[i][j][k];
    }
}
```

Step 4，左侧节点的整体答案和右侧节点的整体答案贡献不变，直接合并上来。

```cpp
res.ans = ans + b.ans;
```

Step 5，考虑跨过中间点的区间的贡献，直接大力六重循环枚举可能的状态对 $(p,q,r)$ 和 $(x,y,z)$，当 $p+x\equiv 0\pmod 2$，或者 $p+x\equiv 1\pmod 2$， $q+y\geq 2$ 且 $r+z\geq 2$ 时可以产生贡献，贡献量就是两个状态的值相乘。

```cpp
for (int il = 0;il < 2;il++) {
    for (int jl = 0;jl < 3;jl++) {
        for (int kl = 0;kl < 3;kl++) {
            for (int ir = 0;ir < 2;ir++) {
                for (int jr = 0;jr < 3;jr++) {
                    for (int kr = 0;kr < 3;kr++) {
                        if ((il + ir & 1) == 0 || (jl + jr >= 2 && kl + kr >= 2)) res.ans += suf[il][jl][kl] * b.pre[ir][jr][kr];
                    }
                }
            }
        }
    }
}
```

这样把节点丢进线段树里面维护就可以了，复杂度 $O(n\log n)$ 带 $216$ 倍常数。

由于是黑题所以只给核心代码防抄。

```cpp
struct Node {
	long long sum[2], ans, pre[2][3][3], suf[2][3][3];
	Node() {}
	Node(bool x) {
		memset(sum, 0, sizeof(sum));
		sum[x]++;
		ans = !x;
		memset(pre, 0, sizeof(pre)); memset(suf, 0, sizeof(suf));
		if (x) pre[1][0][1] = suf[1][0][1] = 1;
		else pre[0][1][0] = suf[0][1][0] = 1;
	}
	Node operator + (const Node& b) const {
		Node res;
		for (int i = 0;i < 2;i++) res.sum[i] = sum[i] + b.sum[i];
		for (int i = 0;i < 2;i++) {
			for (int j = 0;j < 3;j++) {
				for (int k = 0;k < 3;k++) {
					res.pre[i][j][k] = pre[i][j][k];
					res.suf[i][j][k] = b.suf[i][j][k];
				}
			}
		}
		for (int i = 0;i < 2;i++) {
			for (int j = 0;j < 3;j++) {
				for (int k = 0;k < 3;k++) res.pre[(i + sum[1]) & 1][Min(2, j + sum[0])][Min(2, k + sum[1])] += b.pre[i][j][k];
			}
		}
		for (int i = 0;i < 2;i++) {
			for (int j = 0;j < 3;j++) {
				for (int k = 0;k < 3;k++) res.suf[(i + b.sum[1]) & 1][Min(2, j + b.sum[0])][Min(2, k + b.sum[1])] += suf[i][j][k];
			}
		}
		res.ans = ans + b.ans;
		for (int il = 0;il < 2;il++) {
			for (int jl = 0;jl < 3;jl++) {
				for (int kl = 0;kl < 3;kl++) {
					for (int ir = 0;ir < 2;ir++) {
						for (int jr = 0;jr < 3;jr++) {
							for (int kr = 0;kr < 3;kr++) {
								if ((il + ir & 1) == 0 || (jl + jr >= 2 && kl + kr >= 2)) res.ans += suf[il][jl][kl] * b.pre[ir][jr][kr];
							}
						}
					}
				}
			}
		}
		return res;
	}
};
struct Segtree {
	Node val[400005];
	inline void Build(int p, int pl, int pr, int *a) {
		if (pl == pr) {
			val[p] = Node(a[pl]);
			return;
		}
		int mid = pl + pr >> 1;
		Build(p << 1, pl, mid, a); Build(p << 1 | 1, mid + 1, pr, a);
		val[p] = val[p << 1] + val[p << 1 | 1];
	}
	inline void Modify(int p, int pl, int pr, int id, int v) {
		if (pl == pr) {
			val[p] = Node(v);
			return;
		}
		int mid = pl + pr >> 1;
		if (id <= mid) Modify(p << 1, pl, mid, id, v);
		else Modify(p << 1 | 1, mid + 1, pr, id, v);
		val[p] = val[p << 1] + val[p << 1 | 1];
	}
	inline Node Query(int p, int pl, int pr, int l, int r) {
		if (pl == l && pr == r) return val[p];
		int mid = pl + pr >> 1;
		if (mid >= r) return Query(p << 1, pl, mid, l, r);
		else if (mid + 1 <= l) return Query(p << 1 | 1, mid + 1, pr, l, r);
		else return Query(p << 1, pl, mid, l, mid) + Query(p << 1 | 1, mid + 1, pr, mid + 1, r);
	}
};
Segtree sgt;

int a[100005], n;

inline void Read() {
	n = qread();
	for (int i = 1;i <= n;i++) a[i] = qread();
}

inline void Solve() {
	sgt.Build(1, 1, n, a);
	int q = qread();
	while (q--) {
		int opt = qread();
		if (opt == 1) {
			int i = qread();
			a[i] ^= 1;
			sgt.Modify(1, 1, n, i, a[i]);
		} else {
			int l = qread(), r = qread();
			printf("%lld\n", sgt.Query(1, 1, n, l, r).ans);
		}
	}
}
```

---

## 作者：shuidi (赞：0)

首先先看题目求的是什么。

考虑每一个二进制位，$0$ 肯定对和没有什么贡献，那么考虑 $1$ 放在不同的位置对于和的贡献。

我们打一个表就不难康出来膜 $3$ 意义下， $1 <<0 = 1$，$1 <<1 = 2$，$1 <<3 = 1$，$1 <<4 = 2$。emmm果断发现两个 $1$ 膜 $3$ 就是 $0$。

但只判奇偶性并布星 QAQ。还存在另一种情况，即 $3$ 个膜 $3$ 为 $1$ 的数组起来膜 $3$ 就是 $0$。把这个约数再转化一下，我们就可以发现第二个约束，如果存在一段区间和为奇数，那么如果这一段里有超过 $2$ 个 $0$ 和 $1$，那么对于答案就有贡献。

我们考虑用线段树来维护这个区间，每次查询向上传一个结构体，每次分治到两个不同的区间重载运算符合并两个结构体。那么我们再思考需要维护哪些信息。首当其冲的，我们需要维护区间的答案。其次，区间有多少奇数，偶数区间段，为了合并，同时也需要维护以左端点、右端点为断电的奇数、偶数段的数量。第一个约束至此已经可以完全描述了。至于第二个约束，我们维护六个 $3 \times 3$的数组。每一个数组代表区间有 $0, 1, 2+$ 个 $0 / 1$ 的子段数量。那么同上一个约束一样，这六个数组分别是所有、左端、右端总和为奇偶的段数。

~~说起来很简单，这代码写死我了（还是太菜了哇QwQ）~~

那么上代码哇

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>

#define MAXN 100005
#define INF 0x3f3f3f3f
#define ri register int
#define chkmin(a, b) (a < b ? a : a = b)
#define chkmax(a, b) (a > b ? a : a = b)
#define debug(i) (cout << "BREAKPOINT No." << i << endl)
#define lchild cur -> lson
#define rchild cur -> rson

typedef long long ll;

using namespace std;

struct node
{
	ll a[3][3];  //0 1
	node operator + (const node &tmp) const
	{
		node res;
		memset(res.a, 0, sizeof(res.a));
		for(ri i = 0; i < 3; i++)
			for(ri j = 0; j < 3; j++)
				res.a[i][j] = a[i][j] + tmp.a[i][j];
		return res;
	}
};

struct sgt
{
	int l, r;
	ll val;           //Value of [l, r]
	ll lj, rj;        //Number of jishu
	ll lo, ro;        //Number of oushu
	bool fl;           //0 -> [l, r] has even 1s, 1 -> [l, r] has odd 1s
	int zero, one;
	node Lj, Rj;
	node Lo, Ro;
	sgt *lson, *rson;
}pool[MAXN << 1];

inline node add(node x, int z, int o)
{
	node res;
	memset(res.a, 0, sizeof(res.a));
	for(ri i = 0; i < 3; i++)
		for(ri j = 0; j < 3; j++)
			res.a[min(i + z, 2)][min(j + o, 2)] += x.a[i][j];
	return res;
}

inline ll cont(node J, node O)
{
	ll res = 0;
	for(ri i = 0; i < 3; i++)
		for(ri j = 0; j < 3; j++)
			for(ri k = 0; k < 3; k++)
				for(ri l = 0; l < 3; l++)
					if(i + k >= 2 && j + l >= 2)
						res += 1ll * J.a[i][j] * O.a[k][l];
//	cout << "res = " << res << endl;
	return res;
}

sgt operator + (const sgt &L, const sgt &R)
{
	sgt tmp;
	tmp.fl = L.fl ^ R.fl;
	tmp.lj = L.lj + (L.fl ? R.lo : R.lj);
	tmp.lo = L.lo + (L.fl ? R.lj : R.lo);
	tmp.rj = R.rj + (R.fl ? L.ro : L.rj);
	tmp.ro = R.ro + (R.fl ? L.rj : L.ro);
	tmp.val = L.val + R.val + L.ro * R.lo + L.rj * R.lj;
	tmp.Lj = L.Lj + (L.fl ? add(R.Lo, L.zero, L.one) : add(R.Lj, L.zero, L.one));
	tmp.Lo = L.Lo + (L.fl ? add(R.Lj, L.zero, L.one) : add(R.Lo, L.zero, L.one));
	tmp.Rj = R.Rj + (R.fl ? add(L.Ro, R.zero, R.one) : add(L.Rj, R.zero, R.one));
	tmp.Ro = R.Ro + (R.fl ? add(L.Rj, R.zero, R.one) : add(L.Ro, R.zero, R.one));
	tmp.zero = L.zero + R.zero, tmp.one = L.one + R.one;
	tmp.val += cont(L.Rj, R.Lo) + cont(R.Lj, L.Ro);
	return tmp;
}

int N, Q;
int tot = 0;
sgt *rt;
int a[MAXN];

namespace fast_IO
{
	#define gets getchar
/*	inline char gets()
	{
		static char buf[100000], *p1, *p2;
		return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1++;
	}*/

	inline int read_int()
	{
		register int ret = 0, f = 1; register char c = gets();
		while(c < '0' || c > '9') {if(c == '-') f = -1; c = gets();}
		while(c >= '0' && c <= '9') {ret = (ret << 1) + (ret << 3) + int(c - 48); c = gets();}
		return ret * f;
	}
	#undef gets
}using namespace fast_IO;

inline void push_up(sgt *cur)
{
	cur -> fl = lchild -> fl ^ rchild -> fl;
	cur -> lj = lchild -> lj + (lchild -> fl ? rchild -> lo : rchild -> lj);
	cur -> lo = lchild -> lo + (lchild -> fl ? rchild -> lj : rchild -> lo);
	cur -> rj = rchild -> rj + (rchild -> fl ? lchild -> ro : lchild -> rj);
	cur -> ro = rchild -> ro + (rchild -> fl ? lchild -> rj : lchild -> ro);
	cur -> val = lchild -> val + rchild -> val + lchild -> ro * rchild -> lo + lchild -> rj * rchild -> lj;
	cur -> Lj = lchild -> Lj + (lchild -> fl ? add(rchild -> Lo, lchild -> zero, lchild -> one) : add(rchild -> Lj, lchild -> zero, lchild -> one));
	cur -> Lo = lchild -> Lo + (lchild -> fl ? add(rchild -> Lj, lchild -> zero, lchild -> one) : add(rchild -> Lo, lchild -> zero, lchild -> one));
	cur -> Rj = rchild -> Rj + (rchild -> fl ? add(lchild -> Ro, rchild -> zero, rchild -> one) : add(lchild -> Rj, rchild -> zero, rchild -> one));
	cur -> Ro = rchild -> Ro + (rchild -> fl ? add(lchild -> Rj, rchild -> zero, rchild -> one) : add(lchild -> Ro, rchild -> zero, rchild -> one));
	cur -> zero = lchild -> zero + rchild -> zero, cur -> one = lchild -> one + rchild -> one;
	cur -> val += cont(lchild -> Rj, rchild -> Lo) + cont(rchild -> Lj, lchild -> Ro);
}

void build(sgt *cur, int left, int right)
{
	cur -> l = left, cur -> r = right;
	if(left == right)
	{
		cur -> one = cur -> fl = cur -> lj = cur -> rj = a[left];
		cur -> zero = cur -> val = cur -> lo = cur -> ro = a[left] ^ 1;
		if(a[left])
			cur -> Lj.a[0][1] = cur -> Rj.a[0][1] = 1;
		else
			cur -> Lo.a[1][0] = cur -> Ro.a[1][0] = 1;
		return;
	}
	int mid = (left + right) >> 1;
	lchild = &pool[tot++], rchild = &pool[tot++];
	build(lchild, left, mid), build(rchild, mid + 1, right);
	push_up(cur);
}

sgt query(sgt *cur, int left, int right)
{
	sgt res;
	if(cur -> l == left && cur -> r == right)
	{
		res.fl = cur -> fl, res.val = cur -> val;
		res.lj = cur -> lj, res.lo = cur -> lo;
		res.rj = cur -> rj, res.ro = cur -> ro;
		res.Lj = cur -> Lj, res.Lo = cur -> Lo;
		res.Rj = cur -> Rj, res.Ro = cur -> Ro;
		res.zero = cur -> zero, res.one = cur -> one;
		return res;
	}
	int mid = (cur -> l + cur -> r) >> 1;
	if(right <= mid)
		return query(lchild, left, right);
	if(left >= mid + 1)
		return query(rchild, left, right);
	return query(lchild, left, mid) + query(rchild, mid + 1, right);
}

void modify(sgt *cur, int pos)
{
	if(cur -> l == pos && cur -> r == pos)
	{
		memset(cur -> Lj.a, 0, sizeof(cur -> Lj.a));
		memset(cur -> Lo.a, 0, sizeof(cur -> Lo.a));
		memset(cur -> Rj.a, 0, sizeof(cur -> Rj.a));
		memset(cur -> Ro.a, 0, sizeof(cur -> Ro.a));
		if(cur -> val)
			cur -> Lj.a[0][1] = cur -> Rj.a[0][1] = 1;
		else
			cur -> Lo.a[1][0] = cur -> Ro.a[1][0] = 1;
		cur -> val ^= 1, cur -> fl ^= 1;
		cur -> lj ^= 1, cur -> lo ^= 1;
		cur -> rj ^= 1, cur -> ro ^= 1;
		cur -> zero ^= 1, cur -> one ^= 1;
		return;
	}
	int mid = (cur -> l + cur -> r) >> 1;
	if(pos <= mid)
		modify(lchild, pos);
	else
		modify(rchild, pos);
	push_up(cur);
}

inline void init()
{
	N = read_int();
	for(ri i = 1; i <= N; i++)
		a[i] = read_int();
	rt = &pool[tot++];
	build(rt, 1, N);
}

void print(sgt *cur)
{
	if(cur == NULL)
		return;
	cout << "l = " << cur -> l << " r = " << cur -> r;
	cout << " val = " << cur -> val << " fl = " << cur -> fl;
	cout << " lj = " << cur -> lj << " lo = " << cur -> lo;
	cout << " rj = " << cur -> rj << " ro = " << cur -> ro;
	cout << " 0s " << cur -> zero << " 1s " << cur -> one;
	cout << endl;
	print(lchild); print(rchild);
}

inline void ans()
{
	Q = read_int();
	ri opt, l, r, pos;
	while(Q--)
	{
//		print(rt);
		opt = read_int();
		if(opt == 1)
		{
			pos = read_int();
			modify(rt, pos);
		}
		else
		{
			l = read_int(), r = read_int();
			printf("%lld\n", query(rt, l, r).val);
		}
	}
}

int main()
{
	init();
	ans();
	return 0;
}
```

---

## 作者：I_am_Accepted (赞：0)

本题解有自信说此做法空间常数非常小。

### Analysis

我们先研究一个二进制数是否能重新排列后是个 $3$ 的倍数。

通过简单的数位拆分，得到该二进制数的条件，但是非常麻烦（便不展示），所以就有了**正难则反**的思想。

考虑哪些二进制数不能满足上述条件，发现满足以下三种之一即可（$cnt_{0/1}$ 表示二进制中 $0/1$ 的个数）：

1. $cnt_0\geqslant 2$ 且 $cnt_1=1$

2. $cnt_0=0$ 且 $cnt_1\equiv 1\pmod{2}$

3. $cnt_0=1$ 且 $cnt_1\equiv 1\pmod{2}$

发现这是一个**线段树**（单点修改，区间询问）题！

由于不满足条件的二进制数 $\min(cnt_0,cnt_1)\leqslant 1$，我们就可以轻松地线段树节点合并了。

每一个节点存：

* 区间 最/次 左/右 的 $0/1$ 的位置。

* 区间内的答案（不满足条件的二进制数）。

其实本题最核心的部分在于 `merge`，详情请见代码，有详细注释。

### Detail

最后用全集减去不满足的即可。

### Code

时间复杂度为 $O(km\log n)\quad k\approx 40$。

空间复杂度为 $O(kn\log n)\quad k\approx 4\times 10$(以 `int` 为单位，常数 $4$ 为线段树必须)。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define IOS ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)
#define For(i,j,k) for(register int i=j;i<=k;i++)
#define Rof(i,j,k) for(register int i=j;i>=k;i--)
	#define fir first
	#define sec second
	#define mkp make_pair
	#define pii pair<int,int>
#define N 100100
	#define mid ((l+r)>>1)
	#define ls (rt<<1)
	#define rs (rt<<1|1)
struct node{
	pii l[2];
	pii r[2];
	ll ans;
}t[4*N];
int n,q;
node upd(node x,node y,int l,int m,int r){//merge two nodes x:[l,m] and y:[m+1,r] 
	node res;
	res.ans=x.ans+y.ans;
	res.l[0]=x.l[0],res.l[1]=x.l[1];
	res.r[0]=y.r[0],res.r[1]=y.r[1];
	For(i,0,1){
		if(res.l[i].sec==m+1){
			if(res.l[i].fir==m+1) res.l[i]=y.l[i];
			else res.l[i].sec=y.l[i].fir;
		}
		if(res.r[i].sec==m){
			if(res.r[i].fir==m) res.r[i]=x.r[i];
			else res.r[i].sec=x.r[i].fir;
		}
	}
	ll tmp;//增加值 
	ll L=m-x.r[0].fir;
	ll R=y.l[0].fir-m-1;
	ll LL=max(0,x.r[0].fir-x.r[0].sec-1);
	ll RR=max(0,y.l[0].sec-y.l[0].fir-1);
	tmp=(L>>1)*((R+1)>>1)+((L+1)>>1)*(R>>1);//第 2 类，分 奇|偶 和 偶|奇 讨论 
	res.ans+=tmp;
	For(i,0,1){//第 3 类，分 奇|偶0偶 和  偶|偶0奇 和 偶|奇0偶 和  奇|奇0奇 讨论 
		if((i==0 && y.l[0].fir!=r+1) || (i==1 && x.r[0].fir!=l-1)){
			if(R&1) tmp=(L>>1)*((RR+2)>>1)+((L+1)>>1)*((RR+1)>>1);
			else	tmp=((L+1)>>1)*((RR+2)>>1)+(L>>1)*((RR+1)>>1);
		}else tmp=0;
		res.ans+=tmp;
		swap(L,R);//左右 swap，各计算一次 
		swap(LL,RR);
	}
	L=m-x.r[1].fir;
	R=y.l[1].fir-m-1;
	LL=max(0,x.r[1].fir-x.r[1].sec-1);
	RR=max(0,y.l[1].sec-y.l[1].fir-1);
	For(i,0,1){//第 1 类
		if((i==0 && x.r[1].fir!=l-1) || (i==1 && y.l[1].fir!=r+1)){
			tmp=(LL+1)*R;
			if(L==0 && R>0) tmp--;//排除与第 3 类重叠的情况 
		}else tmp=0;
		res.ans+=tmp;
		swap(L,R);//左右 swap，各计算一次 
		swap(LL,RR);
	}
	return res;
} 
void build(int rt,int l,int r){
	if(l==r){
		int x;
		cin>>x;//read and assign
		t[rt]={{mkp(l+1,l+1),mkp(l+1,l+1)},{mkp(l-1,l-1),mkp(l-1,l-1)},x};
		if(x==0)	t[rt].l[0].fir=t[rt].r[0].fir=l;
		else		t[rt].l[1].fir=t[rt].r[1].fir=l;
		return ;
	}
	build(ls,l,mid);
	build(rs,mid+1,r);
	t[rt]=upd(t[ls],t[rs],l,mid,r);
}
void rev(int rt,int l,int r,int id){//reverse a leaf
	if(l==r){
		t[rt].ans^=1;
		swap(t[rt].l[0],t[rt].l[1]);
		swap(t[rt].r[0],t[rt].r[1]);
		return ;
	}
	if(id<=mid) rev(ls,l,mid,id);
	else rev(rs,mid+1,r,id);
	t[rt]=upd(t[ls],t[rs],l,mid,r);
}
node que(int rt,int l,int r,int x,int y){//query
	if(l==x && r==y)
		return t[rt];
	if(y<=mid)
		return que(ls,l,mid,x,y);
	else if(x>mid)
		return que(rs,mid+1,r,x,y);
	else
		return upd(que(ls,l,mid,x,mid),que(rs,mid+1,r,mid+1,y),x,mid,y);
}
ll calc(int l,int r){//all 
	return (ll)(r-l+1)*(r-l+2)/2;
}
signed main(){
	IOS;
	cin>>n;
	build(1,1,n);
	cin>>q;
	int opt,x,y;
	while(q--){
		cin>>opt;
		if(opt==1){
			cin>>x;
			rev(1,1,n,x);
		}else{
			cin>>x>>y;
			cout<<calc(x,y)-que(1,1,n,x,y).ans<<endl;
		}
	}
    return 0;
}
```

---


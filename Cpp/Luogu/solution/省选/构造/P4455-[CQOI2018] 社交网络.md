# [CQOI2018] 社交网络

## 题目背景

当今社会，在社交网络上看朋友的消息已经成为许多人生活的一部分。通常，一个用户在社交网络上发布一条消息后，他的好友们也可以看见这条消息，并可能转发。转发的消息还可以继续被人转发，进而扩散到整个社交网络中。

## 题目描述

在一个实验性的小规模社交网络中我们发现，有时一条热门消息最终会被所有人转发。为了研究这一现象发生的过程，我们希望计算一条消息所有可能的转发途径有多少种。为了编程方便，我们将初始消息发送者编号为 $1$，其他用户编号依次递增。

该社交网络上的所有好友关系是已知的，也就是说对于 $a, b$ 两个用户，我们知道 $a$ 用户可以看到 $b$ 用户发送的消息。注意可能存在单向的好友关系，即 $a$ 能看到 $b$ 的消息，但 $b$ 不能看到 $a$ 的消息。

还有一个假设是，如果某用户看到他的多个好友转发了同一条消息，他只会选择从其中一个转发，最多转发一次消息。从不同好友的转发，被视为不同的情况。

如果用箭头表示好友关系，下图展示了某个社交网络中消息转发的所有可能情况。（初始消息是用户 $1$ 发送的，加粗箭头表示一次消息转发）

![](https://cdn.luogu.com.cn/upload/pic/17549.png)
![](https://cdn.luogu.com.cn/upload/pic/17550.png)
![](https://cdn.luogu.com.cn/upload/pic/17551.png)
![](https://cdn.luogu.com.cn/upload/pic/17552.png)
![](https://cdn.luogu.com.cn/upload/pic/17553.png)
![](https://cdn.luogu.com.cn/upload/pic/17554.png)

答案对 $10^4 + 7$ 取模。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \leq 10$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 250$，$1 \leq m \leq n \times (n - 1)$，$1 \leq a, b \leq n$。

## 样例 #1

### 输入

```
4
7
2 1
3 1
1 3
2 3
3 2
4 3
4 2
```

### 输出

```
6```

# 题解

## 作者：xiezhiyu (赞：11)

[题目链接](https://www.luogu.org/problemnew/show/P4455)

一句话题意：给定n个点m条有向边，求以1号点为根的树形图数量。


solution：构造有向图基尔霍夫矩阵，求出det(M[1][1])


------------

证明有向图的矩阵树定理：

思路和证明无向图的差不多，构造辅助矩阵。

构造两个矩阵A和B，每列代表一条边x->y。	
在A的一列中，第x行为-1，第y行为1，其余是0	
在B的一列中，第y行为1，其余为0

A就是按照边的方向定正负的无向图正常的辅助矩阵		
B我们把它叫做入度矩阵

这样A*B(T)是基尔霍夫矩阵C：	
Cij是A的第i行 点乘 B的第i行	
i=j时当且仅当边是x->i才有贡献，并且贡献都是1	
i!=j时只有i->j时才是-1，否则都是0	

设A'为A去掉第1行选n-1列，B'同理

考虑和无向图一样柯西比内，这样相当于选出了n-1条有向边	
现在我们考虑哪一些情况可以对最后答案产生贡献。		
考虑det(A')=0可以排除掉有环的情况(包括了两点间有两个方向的边)	
现在不考虑边的方向的话，剩下有可能做出贡献的是棵树	

我们先证 **a.当且仅当这是个树形图，且以1为根时det(B')!=0**	
再证 **b.符合这样的情况时det(A')det(B')=1**		
这样最后的答案就是以1为根的树形图计数了



------------
a.	
首先以i为根的树形图相当于i的入度为0，其他每个点入度为1	
现在B矩阵中有除1外的n-1个点，有n-1条边对应n-1个列向量，每个有一行为-1
- 如果1号点的入度>0，剩下只有n-2个不为0的数，而B'是个大小为n-1的方阵，行列式的每项需要n-1个数，故det(B')=0	

- 1号点的入度为0时，只有1号点可能成为树形图的根，只需要判断是否是树形图。剩下n-1个入度分配给n-1个点，如果不是每个点一个度数，抽屉原理有一个点p入度>=2，B矩阵中对应的两个列向量相同，det(B’)=0

**结论：当且仅当它是个以1为根的树形图时，det(A')det(B')!=0**		

b.	

法一：		

从叶子往上处理，考虑x->y->z	
把x->y的列向量*-1，（也就是第y行为1）	
加到y->z的列向量上，把它变成y=1,z=-1		
我们发现它把叶节点变成了跟A矩阵一样的形式，行列式的值并没有变		
然后一直这样处理直到A'=B',		
我们发现自己证出了det(A')=det(B')	
所以平方一下det(A')det(B')=1

法二：		

显然有det(B')=det(I)=1		
按照无向图的方法求det(A')，不需要改边的方向，那么显然det(A')=det(I)=1		
复述一下证明过程，从叶子到根处理形如x->y->z的边			
把x->y加到y->z上，变成x->y,x->z，此时det不变	
最后每条边会变成1->z,而第一行已经被删掉了		
剩下的是个单位矩阵，即det(A')=det(I)=1		

**结论：当它是个以1为根的树形图时，det(A')det(B')=1,否则=0**	

证明如果有不对的地方请联系我，谢谢~


---

## 作者：autoint (赞：8)

# 题解

UPD：以前写的太差了，重写。

求的其实就是有向图中以1为根的生成树数量。Matrix Tree定理裸题。

入度矩阵对应的外向树，出度矩阵对应着内向树（都是指向父亲的边的事是出度或者入度）无根树就是两条有向边都加上

有向树必须删掉根所在的那一行和一列，无根树可以任意

然后对于这n−1阶的矩阵求一个行列式就行了，也叫主子式

```cpp
#include<bits/stdc++.h>
using namespace std;

void read(int&x) {
	x=0;int w=1;char ch=getchar();
	for(; !isdigit(ch); ch=getchar())if(ch=='-') w=-w;
	for(; isdigit(ch); ch=getchar()) x=x*10+ch-'0';
	x*=w;
}

const int mod=1e4+7;
int fpow(int x,int k) {
	int ans=1;
	for(; k; k>>=1,x=x*x%mod)
		if(k&1) ans=ans*x%mod;
	return ans;
}

int A[255][255];
int gauss(int n) {
	int p=1;
	for(int i=1; i<n; i++) {
		int k=i;
		for(int j=i+1; j<=n; j++)
			if(A[j][i]>A[k][i]) k=j;
		if(k!=i) swap(A[k],A[i]),p*=-1;
		if(!A[i][i])
			return 0;
		int inv=fpow(A[i][i],mod-2);
		for(int j=i+1; j<=n; j++) {
			int coef=A[j][i]*inv%mod;
			for(int k=i; k<=n; k++) A[j][k]=(A[j][k]+mod-coef*A[i][k]%mod)%mod;
		}
	}
	if(p<0) p+=mod;
	for(int i=1; i<=n; i++) p=p*A[i][i]%mod;
	return p;
}
int main() {
	int n,m;
	read(n),read(m);
	for(int x,y; m--;) {
		read(x),read(y); // y->x
		--A[y-1][x-1],++A[x-1][x-1];
	}
	for(int i=0; i<n; i++)for(int j=0; j<n; j++)
		if(A[i][j]<0) A[i][j]+=mod;
	printf("%d\n",gauss(n-1));
	return 0;
}
```
# 快速求解行列式

求行列式的一般方法是把矩阵通过基础行变换或者列变换把矩阵消成一个上三角矩阵，然后对角线上的值相乘即可

具体的变换是

1. 行列交换，行列式不变 就是ai,j变成aj,i（但是一般用不上这个）

2. 行列式一行的因子可以提出 就是一行都除k,求完这个行列式后再乘上k

3. 两行互换，行列式反号

4. 将一行的倍数加到另一行上，行列式不变

好像写的话只需要34就够了


---

## 作者：Programming_Konjac (赞：2)

双倍经验。
# 前置知识
## 行列式求值
首先利用高斯消元，削成一个三角矩阵。

然后行列式的值就是对角线上的数字乘起来。
## 基尔霍夫矩阵求无向图生成树数量

- 对于一个含有 $n$ 个点的无向图 $G$。
- 我们定义度数矩阵 $D(G)$ 和定理邻接矩阵 $E(G)$ 为：

$
D(G)_{ij} = \begin{cases}
  0&i\ne j \\
  \texttt{和节点}\space i\space\texttt{有关的边权和}&i=j
\end{cases}
\\
E(G)_{ij} = \begin{cases}
  i,j \space \texttt{之间所有的边权和}&i\ne j \\
  0&i=j
\end{cases}
\\
$
若是无权图，边权视为 $1$。
$
\color{black}
\\
D(G)_{ij} = \begin{cases}
  0&i\ne j \\
  \texttt{节点} \space i\space  \texttt{的度数}&i=j
\end{cases}
\\
E(G)_{ij} = \begin{cases}
  i,j \space \texttt{之间的边数}&i\ne j \\
  0&i=j
\end{cases}
$
- 最后求 $L(G)=D(G)-E(G)$ 的 **$n-1$ 阶子矩阵行列式**。


## 基尔霍夫矩阵求有向图生成外向树（叶向）数量/权值和

$
D_{ij} = \begin{cases}
  0&i\ne j \\
  \texttt{连向} \space i \space \texttt{的边权和}&i=j
\end{cases}
\\
E(G)_{ij} = \begin{cases}
  \texttt{从} \space i \space \texttt{连向} \space j \space \texttt{的边权和}&i\ne j \\
  0&i=j
\end{cases}
\\
$
若是无权图，边权视为 $1$。
$
\\
D_{ij} = \begin{cases}
  0&i\ne j \\
  \texttt{点} \space i \space \texttt{的入度}&i=j
\end{cases}
\\
E(G)_{ij} = \begin{cases}
  \texttt{从} \space i\space  \texttt{连向} \space j \space \texttt{的边数}&i\ne j \\
  0&i=j
\end{cases}
$

最后求 $L(G,r)=D_{in}-E$ 求 $L(G,r)$ 的去掉**第 $r$ 行第 $r$ 列（$r$ 为根节点）的 $n-1$ 阶行列式**。

## 基尔霍夫矩阵求有向图生成内向树（根向）数量/权值和

$
D_{ij} = \begin{cases}
  0&i\ne j \\
  \texttt{从}\space i \space \texttt{出发的边权和}&i=j
\end{cases}
\\
E(G)_{ij} = \begin{cases}
  \texttt{从} \space i\space  \texttt{连向} \space j \space \texttt{的边权和}&i\ne j \\
  0&i=j
\end{cases}
\\
$
若是无权图，边权视为 $1$。
$
\\
D_{ij} = \begin{cases}
  0&i\ne j \\
  \texttt{点} \space i \space \texttt{的出度}&i=j
\end{cases}
\\
E(G)_{ij} = \begin{cases}
  \texttt{从}\space i\space \texttt{连向}\space j \space \texttt{的边数}&i\ne j \\
  0&i=j
\end{cases}
$

最后求 $L(G,r)=D_{out}-E$ 求 $L(G,r)$ 的去掉**第 $r$ 行第 $r$ 列（$r$ 为根节点）的 $n-1$ 阶行列式**。
# 思路
构造行列式矩阵，由于最后的行列式矩阵边长是 $n-1$ 的，所以优先进行 $n\leftarrow n-1$。

我们设一开始的矩阵为 $a$。

**因为 $n$ 减 $1$ 了，所以 $u,v$ 也要减 $1$**。

然后每次连边，因为是外向树，所以连一次就行。

记住！这题没有权值，那么权值为 $1$。并且用户 $a$ 可以看到用户 $b$ 发送的信息，所以要反向连边。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll mod=1e4+7;
const double eps=1e-8;
const int N=305;
ll qpow(ll a,ll b){
	ll ans=1;
	while(b){
		if(b&1) ans=ans*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return ans%mod;
}
ll inv(ll x){
	return qpow(x,mod-2);
}
int n,m,t;
ll a[N][N];
ll det(){
	ll ans=1;
	for(int i=1; i<=n; i++){
		int sid=-1;
		for(int j=i; j<=n; j++){
			if(abs(a[j][i])){
				sid=j;
				break;
			}
		}
		if(sid==-1) continue;
		if(sid!=i){
			for(int j=1; j<=n; j++){
				swap(a[sid][j],a[i][j]);
			}
			ans=-ans;
		}
		for(int j=i+1; j<=n; j++){
			ll t=a[j][i]*inv(a[i][i])%mod;
			for(int k=1; k<=n; k++){
				a[j][k]=(a[j][k]-a[i][k]*t%mod+mod)%mod;
			}
		}
	}
	for(int i=1; i<=n; i++) (ans*=a[i][i])%=mod;
	return (ans+mod)%mod;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	t=1;
	n--;
	while(m--){
		int u,v,w=1;
		cin>>u>>v;
		u--;
		v--;
		swap(u,v);
		(a[v][v]+=w)%=mod;
		(((a[v][u]-=w)%=mod)+=mod)%=mod;
		if(!t){
			swap(u,v);
			(a[v][v]+=w)%=mod;
			(((a[v][u]-=w)%=mod)+=mod)%=mod;
		}
	}
	cout<<det();
 	return 0;
}
```

---

## 作者：Prean (赞：1)

# 题意
给一颗有向图，求子外向树个数

一眼能看出是矩阵树板子吧。。。

code:
```cpp
#include<iostream>
#include<cstdio>
const int M=255,mod=10007;
int n,m,a[M][M];
inline int Del(const int&a,const int&b){
	return a-b<0?a-b+mod:a-b;
}
inline int pow(int a,int b=mod-2){
	int ans=1;
	for(;b;b>>=1,a=a*a%mod)if(b&1)ans=ans*a%mod;
	return ans;
}
inline int Gauss(){
	register int i,j,k,d,inv,ans=1;
	for(i=2;i<=n;++i){
		for(j=i+1;j<=n;++j){
			if(a[j][i]){
				std::swap(a[i],a[j]);ans=mod-ans;break;
			}
		}
		inv=pow(a[i][i]);
		for(j=i+1;j<=n;++j){
			d=a[j][i]*inv%mod;
			for(k=i;k<=n;++k)a[j][k]=Del(a[j][k],d*a[i][k]%mod);
		}
		ans=ans*a[i][i]%mod;
	}
	return ans;
}
signed main(){
	register int i,u,v;
	scanf("%d%d",&n,&m);
	for(i=1;i<=m;++i){
		scanf("%d%d",&u,&v);u^=v^=u^=v;
		if(++a[v][v]==mod)a[v][v]=0;
		if(!~--a[u][v])a[u][v]=mod-1;
	}
	printf("%d\n",Gauss());
}
```

---

## 作者：wxgwxg (赞：1)

以1为根的有向图生成树计数

做法：
对于一个有向图，我们构造如下 $A$ 矩阵：（其中 $ai$, $j$ 表示矩阵第 $i$ 行第 $j$ 列的元素）
对于 $i!=j$，$a_{ij}$, 为 $i$ 到 $j$ 的边数的相反数；
$a_{ii}$ 为 $i$ 的出度。
那么这个矩阵删去第 1 行第 1 列之后的行列式为以 1 号点为根的树形图的数量。
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
inline int read()
{
	int k=0,f=1;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) k=k*10+c-'0';return f*k;
}
const int mod=10007;
int n,m,a[255][255],w[255][255];
int ksm(int x,int k) {int as=1;for(;k;k>>=1,x=x*x%mod) if(k&1) as=as*x%mod;return as;}
int gauss()
{
	int now=1,as=1;
	for(int i=2;i<=n;i++)
	{
		int pos=i;
		for(;pos<=n;pos++) if(a[pos][i]) break;
		if(pos!=i)
		{
			now=-now;
			for(int j=2;j<=n;j++) swap(a[i][j],a[pos][j]);
		}
		if(!a[i][i]) return 0;as=as*a[i][i]%mod;
		int inv=ksm(a[i][i],mod-2);
		for(int j=i+1;j<=n;j++)
		{
			if(!a[j][i]) continue;
			int mul=a[j][i]*inv%mod;
			for(int k=2;k<=n;k++)
			a[j][k]=(a[j][k]-a[i][k]*mul)%mod;
		}
	}
	as=as*now;
	return (as%mod+mod)%mod;
}
int main()
{
	int b,c;
	n=read();m=read();
	for(int i=1;i<=m;i++)
	b=read(),c=read(),a[b][c]-=1,a[b][b]++;
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)
	if(a[i][j]<0) a[i][j]+=mod;
	cout<<gauss()<<endl;
	return 0;
}
```

---

## 作者：GeXiaoWei (赞：0)

# P4455 [CQOI2018] 社交网络
## 题意
求解以 $1$ 为根节点的有向图生成外向树数量。
## 前置知识
### 矩阵与行列式
设 $\det(A)$ 表示矩阵 $A$ 的行列式。

1、若矩阵 $A$、$D$ 是方阵，则方阵 $\begin{bmatrix}A&B\\0&D\end{bmatrix}$ 的行列式为 $\det(A)\times\det(D)$。其中 $B$ 为任意方阵，$0$ 为全 $0$ 方阵。

2、方阵的两行交换，则行列式变号。

3、用矩阵的一行减去另一行的倍数，行列式不变。

4、对于上三角形矩阵 $A$，则 $\det(A)$ 为矩阵 $A$ 对角线上元素之积。

想要求解 $\det(A)$，只需用 $2$、$3$ 性质将矩阵 $A$ 转为上三角形矩阵，再套用性质 $4$ 即可。

### 基尔霍夫矩阵生成外向树数量
$$\begin{aligned}
  D_{i,j} &= \begin{cases}
    0 & i\ne j\\
    \text{连向 }i\text{ 的边权和} & i=j
  \end{cases}
  \\
  A_{i,j}&=\begin{cases}
    \text{从 }i\text{ 连向}j\text{的边权和} &i\ne j\\
    0 & i=j
  \end{cases}
\end{aligned}$$
## 题目解析
构造行列式矩阵，由于最后的行列式矩阵边长是 $n-1$ 的，所以先将 $n$ 的值减 $1$。

因为 $n$ 减 $1$ 了，所以 $u,v$ 也要减 $1$。

然后每次连边，因为是有向图，所以连一次即可。

注意这题**没有权值**，要设权值为 $1$ 进行计算。
## 代码
```cpp
#include<bits/stdc++.h>
#define ll long long 
using namespace std;
const ll mod=1e4+7;
const int N=255;
ll qpow(ll a,ll b){
    ll ans=1;
    while(b){
        if(b&1)    ans=ans*a%mod;
        a=a*a%mod,b>>=1;
    }return ans%mod;
}ll inv(ll x){return qpow(x,mod-2);}
struct node{
    int u,v,w;
    node(int _u=0,int _v=0,int _w=0){u=_u,v=_v,w=_w;}
}edge[10005];
int n,m;
ll a[N][N];
ll det(){
    ll ans=1;
    for(int i=1;i<=n;i++){//枚举列
        int now=-1;
        for(int j=i;j<=n;j++){//枚举行
            if(a[j][i]){
                now=j;
                break;
            }
        }if(now==-1)    continue;
        if(now!=i){
            for(int j=1;j<=n;j++) swap(a[now][j],a[i][j]);
            ans=-ans;
        }ll ia=inv(a[i][i]);
        for(int j=i+1;j<=n;j++){//枚举行
            ll t=a[j][i]*ia%mod;
            for(int k=1;k<=n;k++) a[j][k]=(a[j][k]-a[i][k]*t%mod+mod)%mod;
        }
    }for(int i=1;i<=n;i++) (ans*=a[i][i])%=mod;
    return (ans+mod)%mod;
}int main(){
    scanf("%d%d",&n,&m);n--;
	while(m--){
		int u,v;
		scanf("%lld%lld",&u,&v);
		u--,v--;
		(a[u][u]+=1)%=mod;
		(a[u][v]-=1)%=mod;
	}printf("%lld",det());
    return 0;
}
```

---

## 作者：月下萤火 (赞：0)

### 题目大意：
 给定n个点m条边，求以1号点为根的树形图数量。
### 思路：
思路：矩阵树裸题，本题是外向树，所有按外向树的规则建图跑矩阵树定理即可。  
如果第8和第11个数据点WA了，可以考虑是不是高斯消元的部分写错了，这也是我在解题过程中所遇到的一些问题。  


### 建图：

删去指定根所在的行和列，求矩阵行列式即可。

代码：
```c
while(m--){
		scanf("%d%d",&x,&y);
		x--;y--;
		K[x][x]++;
		K[y][x]--;
}
```
注意x，y必须自减1，为的是保证树以1号点为根
高斯消元的部分不再赘述
  
### 代码：
```c
#include<iostream>
#include<cstring>

using namespace std;

typedef long long LL;

const int N=260;
const int mod=1e4+7;

int n,m;
LL K[N][N];

//逆元
inline LL qpow(LL x,LL n){
	LL ret=1;
	while(n){
		if(n&1)
		ret=1ll*ret*x%mod;
		x=1ll*x*x%mod;
		n>>=1;
	}
	return ret;
}

//行列式
inline LL gauss(){
	int ret=1;
	n--;//注意n的取值
	for(int i = 1 ; i <= n ; ++i){
        for(int j = i ; j <= n ; ++j)
            if(K[j][i]){
                swap(K[i] , K[j]);
                if(i != j)
                    ret = mod - ret;
                break;
            }
        int t = qpow(K[i][i] , mod - 2);
        for(int j = i + 1 ; j <= n ; ++j)
            if(K[j][i])
                for(int k = n ; k >= i ; --k)
                    K[j][k] = (K[j][k] - K[i][k] * t % mod * K[j][i] % mod + mod) % mod;
    }
	for(int i=1;i<=n;i++)
		ret=1ll*ret*K[i][i]%mod;
	return ret;
}

int main(){
	scanf("%d%d",&n,&m);
	int x,y;
	while(m--){
		scanf("%d%d",&x,&y);
		x--;y--;
		K[x][x]++;
		K[y][x]--;
	}
	cout<<gauss();
}
```
------------



---


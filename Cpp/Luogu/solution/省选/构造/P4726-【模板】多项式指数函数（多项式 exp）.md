# 【模板】多项式指数函数（多项式 exp）

## 题目描述

给出 $n-1$ 次多项式 $A(x)$，求一个 $\bmod{\:x^n}$ 下的多项式 $B(x)$，满足 $B(x) \equiv \text e^{A(x)}$。系数对 $998244353$ 取模。

## 说明/提示

对于 $100\%$ 的数据，$n \le 10^5$.

## 样例 #1

### 输入

```
6
0 927384623 817976920 427326948 149643566 610586717```

### 输出

```
1 927384623 878326372 3882 273455637 998233543```

# 题解

## 作者：bztMinamoto (赞：42)

orz这题太珂怕了……似乎都找不到几个板子参(lai)考(chao)……前置芝士又特别多……而且我写的时候牛顿迭代那里NTT数组长度写错了调了半天……然后各种地方多项式没清零又调了半天……可能是因为平时都抄板子的缘故没注意这问题……

前置芝士：多项式对数函数（[这里](https://www.cnblogs.com/bztMinamoto/p/9747968.html)），泰勒展开（可以看看[这里](https://www.zhihu.com/question/25627482)第一个回答，非常……生动形象），牛顿迭代法（[这里](http://blog.miskcoo.com/2015/06/polynomial-with-newton-method)）

### 泰勒展开

简单来说的话，就是要求一个函数$f(x)$某一点上的值，我们可以构造一个函数$g(x)$，那么对于$x$点的值，有$$f(x)\approx g(x)=g(0)+\frac{f^1(0)}{1!}x+\frac{f^2(0)}{2!}x^2+……+\frac{f^n(0)}{n!}x^n$$

其中$f^n(0)$表示对原函数图像上$0$这个点进行$n$阶求导

### 牛顿迭代

牛顿迭代可以用来求一个函数的零点，多项式牛顿迭代自然是用来求多项式的零点的，即对于一个函数$G(x)$，求满足条件$G(F(z)) \equiv 0 \pmod {z^n}$的多项式$F(z)$

miskcoo大佬是这么说的

![](https://i.loli.net/2018/10/07/5bb95f11da48a.png)

### 扯远了

然后现在就是要计算$$F(x)=e^{A(x)}$$

那么变形一下得$$\ln F(x)-A(x)=0$$

我们设$G(F(x))=\ln F(x)-A(x)$，那么就是要求这一个函数的零点。那么我们把$F(x)$看做变量，$A(x)$看做常数（我也不知道为什么能这样），对这个进行求导，得$G'(F(x))=\frac{1}{F(x)}$

那么代入上面牛顿迭代的公式得$$F(x)\equiv F_0(x)-\frac{G(F_0(x))}{G'(F_0(x))}\pmod{x^n}$$
$$F(x)\equiv F_0(x)(1-\ln F_0(x)+A(x))\pmod{x^n}$$

然后因为$A(0)=0$，所以$F(x)$的常数项为1

ps：这里的$F_0(x)$指的是在模$x^{n\over 2}$意义下的答案

然后左转把各种板子复制过来就好了
```
//minamoto
#include<iostream>
#include<cstdio>
#include<algorithm>
#define swap(x,y) (x^=y,y^=x,x^=y)
#define mul(x,y) (1ll*x*y%P)
#define add(x,y) (x+y>=P?x+y-P:x+y)
#define dec(x,y) (x-y<0?x-y+P:x-y)
using namespace std;
#define getc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
inline int read(){
    #define num ch-'0'
    char ch;bool flag=0;int res;
    while(!isdigit(ch=getc()))
    (ch=='-')&&(flag=true);
    for(res=num;isdigit(ch=getc());res=res*10+num);
    (flag)&&(res=-res);
    #undef num
    return res;
}
char sr[1<<21],z[20];int K=-1,Z;
inline void Ot(){fwrite(sr,1,K+1,stdout),K=-1;}
inline void print(int x){
    if(K>1<<20)Ot();if(x<0)sr[++K]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++K]=z[Z],--Z);sr[++K]=' ';
}
const int N=500005,P=998244353;
inline int ksm(int a,int b){
    int res=1;
    while(b){
        if(b&1) res=mul(res,a);
        a=mul(a,a),b>>=1;
    }
    return res;
}
int n,r[N],A[N],B[N],C[N],D[N],F[N],G[N],O[N],f[N],g[N],inv[N];
void init(int limit){
    for(int i=0,l=limit<<1;i<=l;++i) inv[i]=ksm(i,P-2);
}
void NTT(int *A,int type,int len){
    int limit=1,l=0;
    while(limit<len) limit<<=1,++l;
    for(int i=0;i<limit;++i)
    r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));
    for(int i=0;i<limit;++i)
    if(i<r[i]) swap(A[i],A[r[i]]);
    for(int mid=1;mid<limit;mid<<=1){
        int R=mid<<1,Wn=ksm(3,(P-1)/R);O[0]=1;
        for(int j=1;j<mid;++j) O[j]=mul(O[j-1],Wn);
        for(int j=0;j<limit;j+=R){
            for(int k=0;k<mid;++k){
                int x=A[j+k],y=mul(O[k],A[j+k+mid]);
                A[j+k]=add(x,y),A[j+k+mid]=dec(x,y);
            }
        }
    }
    if(type==-1){
        reverse(A+1,A+limit);
        for(int i=0,invl=inv[limit];i<limit;++i)
        A[i]=mul(A[i],invl);
    }
}
void Inv(int *a,int *b,int len){
    if(len==1) return (void)(b[0]=inv[a[0]]);
    Inv(a,b,len>>1);
    for(int i=0;i<len;++i) C[i]=a[i],D[i]=b[i];
    NTT(C,1,len<<1),NTT(D,1,len<<1);
    for(int i=0,l=(len<<1);i<l;++i) C[i]=mul(mul(C[i],D[i]),D[i]);
    NTT(C,-1,len<<1);
    for(int i=0;i<len;++i) b[i]=dec(add(b[i],b[i]),C[i]);
    for(int i=0,l=(len<<1);i<l;++i) C[i]=D[i]=0;
}
void Direv(int *A,int *B,int len){
    for(int i=1;i<len;++i) B[i-1]=mul(A[i],i);B[len-1]=0; 
}
void Inter(int *A,int *B,int len){
    for(int i=1;i<len;++i) B[i]=mul(A[i-1],inv[i]);B[0]=0; 
}
void Ln(int *a,int *b,int len){
    Direv(a,A,len),Inv(a,B,len);
    NTT(A,1,len<<1),NTT(B,1,len<<1);
    for(int i=0,l=len<<1;i<l;++i) A[i]=mul(A[i],B[i]);
    NTT(A,-1,len<<1),Inter(A,b,len<<1);
    for(int i=0,l=len<<1;i<l;++i) A[i]=B[i]=0;
}
void Exp(int *a,int *b,int len){
    if(len==1) return (void)(b[0]=1);
    Exp(a,b,len>>1),Ln(b,F,len);
    F[0]=dec(a[0]+1,F[0]);
    for(int i=1;i<len;++i) F[i]=dec(a[i],F[i]);
    NTT(F,1,len<<1),NTT(b,1,len<<1);
    for(int i=0,l=len<<1;i<l;++i) b[i]=mul(b[i],F[i]);
    NTT(b,-1,len<<1);
    for(int i=len,l=(len<<1);i<l;++i) b[i]=F[i]=0;
}
int main(){
//	freopen("testdata.in","r",stdin);
    n=read();
    for(int i=0;i<n;++i) f[i]=read();
    int len;for(len=1;len<=n;len<<=1);init(len);
    Exp(f,g,len);
    for(int i=0;i<n;++i) print(g[i]);
    Ot();
    return 0;
}
```

---

## 作者：wucstdio (赞：41)

## 题意

给定一个多项式$A(x)$，求一个多项式$B(x)$，满足

$$B(x)\equiv e^{A(x)}(\bmod{\:x^n}) $$

## 题解

默认大家都会多项式求逆和多项式求ln，不会的请左转[这里](https://www.luogu.org/problemnew/show/P4238)和[这里](https://www.luogu.org/problemnew/show/P4725)

### 预知识1：牛顿迭代

先看一道小问题：手算，如何对一个$10^9$大小的数$a$开方？

如果你二分，那么预计要二分30次左右，每一次要算一个5位数的平方。

于是牛顿法产生了。

我们本质上是要求$f(x)=x^2-a$精确到整数的零点。

假设我们已经求得了一个近似值$x_0$，那么我们只需要过$(x_0,f(x_0))$这个点作这个函数图像的切线，取切线与$x$轴的交点作为新的$x_0$。

丢一张图：

![](https://cdn.luogu.com.cn/upload/pic/55084.png)

可以看到，这样每次求切线，近似值会迅速逼近精确值，这样可以大大减少工作量。实践证明对$201723039$（我的考号，这是考数学的时候发生的一个真实的故事）开方初值取到$40000$只需要迭代四次就可以精确到整数。

假设我们要求一个函数$f(x)$的零点，初始近似值是$x_0$。

则切线方程为

$$y=f'(x_0)(x-x_0)+f(x_0)$$

（不会的好好看看高中数学选修2-2）

令$y=0$，得到$x=x_0-\dfrac{f(x_0)}{f'(x_0)}$。

放到多项式上也是同理的。

假设我们要求一个函数$G(x)$，满足$F(G(x))\equiv 0$。

利用上面的式子，我们可以每一次令

$$G(x)=G_0(x)-\dfrac{F(G_0(x))}{F'(G_0(x))}$$

这样它可以迅速逼近真实值。

本质上，迭代一次精度就可以翻倍。如果$F(G_0(x))\equiv 0(\bmod{\:x^{n\over 2}})$，那么$F(G(x))\equiv 0(\bmod{\:x^{n}})$，证明我也不会，只能感性理解。

于是我们可以每次将$n$除以$2$，递归进去做，然后用上面那个牛顿迭代的式子去做。

### 用牛顿迭代推多项式exp

$$B(x)\equiv e^{A(x)}(\bmod{\:x^n}) $$

$$\ln B(x)-A(x)\equiv 0(\bmod{\:x^n}) $$

所以我们只需要使得$F(G(x))=\ln G(x)-A(x)\equiv 0$。

$$\Big(F\big(G_0(x)\big)\Big)'=\dfrac{G_0'(x)}{G_0(x)}$$

（复合函数求导法则不能忘啊）

带入上面那个式子得到：

$$G(x)=G_0(x)-\dfrac{\ln G_0(x)-A(x)}{\dfrac{G_0'(x)}{G_0(x)}}=\dfrac{G_0(x)(1-\ln G_0(x)+A(x))}{G_0'(x)}$$

所以，我们只需要每次迭代做一遍多项式求逆，再做一遍多项式求ln，然后再做一遍多项式乘法，就可以得到答案。

时间复杂度为

$$T(n)=T\left(n\over 2\right)+O(n\log n)=O(n\log n)$$

没错，怎么牛顿迭代都是$O(n\log n)$！

下面是代码：

```
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#define ll long long
using namespace std;
const ll MOD=998244353,inv2=499122177;
int limit,l,r[400005];
ll ni[400005];
void calc_ni(int n)
{
	ni[1]=1;
	for(int i=2;i<=n;i++)
	  ni[i]=MOD-(MOD/i)*ni[MOD%i]%MOD;
}
ll quick_pow(ll x,ll a)
{
	ll ans=1;
	while(a)
	{
		if(a&1)ans=ans*x%MOD;
		x=x*x%MOD;
		a>>=1;
	}
	return ans;
}
void NTT(ll*A,int type)
{
	for(int i=0;i<limit;i++)
	  if(i<r[i])swap(A[i],A[r[i]]);
	for(int mid=1;mid<limit;mid<<=1)
	{
		ll Wn=type==1?quick_pow(3,(MOD-1)/(mid<<1)):quick_pow(3,MOD-1-(MOD-1)/(mid<<1));
		for(int R=mid<<1,j=0;j<limit;j+=R)
		{
			ll w=1;
			for(int k=0;k<mid;k++,w=w*Wn%MOD)
			{
				ll x=A[j+k],y=w*A[j+mid+k]%MOD;
				A[j+k]=(x+y)%MOD;
				A[j+mid+k]=(x-y+MOD)%MOD;
			}
		}
	}
	if(type==-1)
	{
		ll inv=quick_pow(limit,MOD-2);
		for(int i=0;i<limit;i++)A[i]=A[i]*inv%MOD;
	}
}
ll A[400005];
void Inv(ll*a,ll*b,int n)
{
	if(n==1)
	{
		b[0]=quick_pow(a[0],MOD-2);
		return;
	}
	Inv(a,b,(n+1)>>1);
	limit=1,l=0;
	while(limit<(n<<1))limit<<=1,l++;
	for(int i=0;i<limit;i++)
	  r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));
	for(int i=0;i<limit;i++)A[i]=i<n?a[i]:0;
	NTT(A,1);
	NTT(b,1);
	for(int i=0;i<limit;i++)
	  b[i]=b[i]*(2+MOD-A[i]*b[i]%MOD)%MOD;
	NTT(b,-1);
	for(int i=n;i<limit;i++)b[i]=0;
}
ll a2[400005];
void Ln(ll*a,ll*b,int n)
{
	for(int i=0;i<(n<<2);i++)b[i]=0;
	Inv(a,b,n);
	limit=1,l=0;
	while(limit<(n<<1))limit<<=1,l++;
	for(int i=0;i<limit;i++)
	  r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));
	for(int i=0;i<n-1;i++)a2[i]=a[i+1]*(i+1)%MOD;
	for(int i=n-1;i<limit;i++)a2[i]=0;
	NTT(a2,1);
	NTT(b,1);
	for(int i=0;i<limit;i++)
	  b[i]=b[i]*a2[i]%MOD;
	NTT(b,-1);
	for(int i=n-1;i>0;i--)
	  b[i]=b[i-1]*ni[i]%MOD;
	for(int i=n;i<limit;i++)b[i]=0;
	b[0]=0;
}
ll lnb[400005];
void Exp(ll*a,ll*b,int n)
{
	if(n==1)
	{
		b[0]=1;
		return;
	}
	Exp(a,b,(n+1)>>1);
	Ln(b,lnb,n);
	limit=1,l=0;
	while(limit<(n<<1))limit<<=1,l++;
	for(int i=0;i<limit;i++)
	  r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));
	for(int i=0;i<n;i++)lnb[i]=a[i]>=lnb[i]?a[i]-lnb[i]:a[i]-lnb[i]+MOD;
	for(int i=n;i<limit;i++)lnb[i]=b[i]=0;
	lnb[0]++;
	NTT(lnb,1);
	NTT(b,1);
	for(int i=0;i<limit;i++)b[i]=b[i]*lnb[i]%MOD;
	NTT(b,-1);
	for(int i=n;i<limit;i++)b[i]=0;
}
int n;
ll f[400005],g[400005];
int main()
{
	scanf("%d",&n);
	for(int i=0;i<n;i++)scanf("%lld",&f[i]);
	calc_ni(n);
	Exp(f,g,n);
	for(int i=0;i<n;i++)printf("%lld ",g[i]);
	printf("\n");
	return 0;
}
```

常数巨大，慎用

upd: BUG 修复

---

## 作者：Vocalise (赞：24)

$\text{upd 20.7.20}:$ 添加牛顿迭代的证明部分。

有一个结论：如果将多项式的方程进行牛顿迭代，每次的逼近位数会翻倍。换而言之：

如果方程形如

$$F(G(x))\equiv 0\pmod{x^n}$$

而已经得知

$$F(G_0(x))\equiv 0\pmod{x^{\lceil \frac n2\rceil}}$$

则经过一次牛顿迭代后可推知上式。

可以考虑通过如下方式证明。

将 $F(G(x))$ 在 $G_0(x)$ 处泰勒展开：

$$F(G(x))=\sum_{n=0}^{\infty}\frac{F^{(n)}(G_0(x))}{n!}(G(x)-G_0(x))^n\equiv 0\pmod{x^n}$$

根据 $G_0\equiv G\pmod{x^{\lceil\frac n2\rceil}}$，得到 $G_0^2\equiv G^2\pmod{x^n}$（迭代后已求的系数不会改变）

又有 $(a-b)^n\equiv a^n-b^n\pmod n$[参考文章](https://www.luogu.com.cn/blog/void-basic-learner/polygon-square-root-enhanced)，多项式即 $(F-G)^n\equiv F^n-G^n\pmod{x^n}$。

因此泰勒展开式第三项及以后的项都在 $\pmod{x^n}$ 下为 $0$。

$$ F(G_0(x))+F'(G_0(x))(G(x)-G_0(x))\equiv 0\pmod{x^n}$$

得到迭代公式：

$$G(x)\equiv G_0(x)-\frac{F(G_0(x))}{F'(G_0(x))}\pmod{x^n}$$

则可以尝试递归地应用到本题。

---

本题中求

$$G(x)\equiv e^{A(x)}\pmod{x^n}$$

即

$$\ln G(x)-A(x)\equiv 0\pmod{x^n}$$

就是这样一个方程。迭代的函数自然是

$$F(G(x))=\ln G(x) - A(x)$$

考虑边界情况下， $n=1$。题目中给出了 $a_0=0$，则有 $\ln g_0-0=0$，常数项赋为 $1$ 即可。

否则运用迭代公式。其中有 $F'(G(x))=1/G(x)$：

$$\begin{aligned}
G(x)&\equiv G_0(x)-\frac{\ln G_0(x)-A(x)}{\frac 1 {G_0(x)}}\pmod{x^n} \\
&\equiv G_0(x)-G_0(\ln G_0(x)-A(x))\pmod{x^n} \\
&\equiv G_0(x)(1-\ln G_0(x)+A(x))\pmod{x^n}
\end{aligned}$$

于是每次递归中求一遍 $\ln$，一遍加减，再一遍乘法，一共 $O(n\log n)$，总共也是 $O(n\log n)$ 的。

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <cmath>
#include <algorithm>

typedef long long ll;
const int MAXN = 400001;
const int p = 998244353;

inline int read() {
    int x = 0,f = 1; char ch = getchar();
    while(ch > '9' || ch < '0') { if(ch == '-') f = -1; ch = getchar(); }
    do x = x * 10 + ch - 48, ch = getchar(); while(ch >= '0' && ch <= '9');
    return x * f;
}

ll fastpow(ll a,int b) {
    ll res = 1; a %= p;
    while(b) {
        if(b & 1) res = res * a % p;
        a = a * a % p;
        b >>= 1;
    }
    return res;
}

int n,r[MAXN];
ll a[MAXN],b[MAXN],f[MAXN],g[MAXN];

void NTT(ll *a,int N) {
    for(int i = 0;i < N;i++) if(i < r[i]) std::swap(a[i],a[r[i]]);
    for(int n = 2, m = 1;n <= N;m = n, n <<= 1) {
        ll g1 = fastpow(3,(p - 1) / n),t1,t2;
        for(int l = 0;l < N;l += n) {
            ll g = 1;
            for(int i = l;i < l + m;i++) {
                t1 = a[i], t2 = g * a[i + m] % p;
                a[i] = (t1 + t2) % p;
                a[i + m] = (t1 + p - t2) % p;
                g = g * g1 % p;
            }
        }
    }
    return;
}

void INTT(ll *a,int N) {
    NTT(a,N);
    std::reverse(a + 1,a + N);
    ll invN = fastpow(N,p - 2);
    for(int i = 0;i < N;i++) a[i] = a[i] * invN % p;
    return;
}

void Dervt(ll *a,ll *b,int n) {
    for(int i = 0;i < n;i++) b[i] = a[i + 1] * (i + 1) % p;
    b[n - 1] = 0;
    return;
}

void Integ(ll *a,ll *b,int n) {
    for(int i = 0;i < n;i++) b[i + 1] = a[i] * fastpow(i + 1,p - 2) % p;
    b[0] = 0;
    return;
}

ll a1[MAXN];

void Inv(ll *a,ll *b,int n) {
    if(n == 1) return void(b[0] = fastpow(a[0],p - 2));
    Inv(a,b,(n + 1) >> 1);
    int N = 1, l = -1; while(N <= n << 1) N <<= 1, l++;
    for(int i = 1;i < N;i++) r[i] = (r[i >> 1] >> 1) | ((i & 1) << l);
    for(int i = 0;i < n;i++) a1[i] = a[i];
    for(int i = n;i < N;i++) a1[i] = 0;
    NTT(a1,N); NTT(b,N);
    for(int i = 0;i < N;i++) b[i] = ((b[i] << 1) % p + p - a1[i] * b[i] % p * b[i] % p) % p;
    INTT(b,N);
    for(int i = n;i < N;i++) b[i] = 0;
    return;
}

void Ln(ll *a,ll *b,int n) {
    memset(g,0,sizeof(g));
    Dervt(a,f,n); Inv(a,g,n);
    int N = 1, l = -1; while(N <= n << 1) N <<= 1, l++;
    for(int i = 1;i < N;i++) r[i] = (r[i >> 1] >> 1) | ((i & 1) << l);
    NTT(f,N); NTT(g,N);
    for(int i = 0;i < N;i++) f[i] = f[i] * g[i] % p;
    INTT(f,N); Integ(f,b,n);
    return;
}

ll lnb[MAXN];

void Exp(ll *a,ll *b,int n) {
    if(n == 1) return void(b[0] = 1);
    Exp(a,b,(n + 1) >> 1);
    Ln(b,lnb,n);
    int N = 1, l = -1; while(N <= n << 1) N <<= 1, l++;
    for(int i = 1;i < N;i++) r[i] = (r[i >> 1] >> 1) | ((i & 1) << l);
    for(int i = 0;i < n;i++) a1[i] = a[i];
    for(int i = n;i < N;i++) lnb[i] = a1[i] = 0;
    for(int i = 0;i < N;i++) a1[i] = ((a1[i] - lnb[i]) % p + p) % p;
    a1[0]++;
    NTT(b,N); NTT(a1,N);
    for(int i = 0;i < N;i++) b[i] = b[i] * a1[i] % p;
    INTT(b,N);
    for(int i = n;i < N;i++) b[i] = 0;
    return;
}

int main() {
    n = read();
    for(int i = 0;i < n;i++) a[i] = read();
    Exp(a,b,n);
    for(int i = 0;i < n;i++) std::printf("%lld ",b[i]);
    return 0;
}
```

---

## 作者：cosmicAC (赞：23)

发一个分治NTT的题解。如果想要看一个log的正解请参考其他dalao的代码。

题目要求的是$$B(x)=e^{A(x)}$$
两边同时求导得到$$B'(x)=A'(x)e^{A(x)}$$
即$$B'(x)=A'(x)B(x)$$
同时积分得到$$B(x)=\int{A'(x)B(x)}$$
又因为将$x=0$代入$A$和$B$中可以得到$B(0)=1$，可以以此为初始值进行分治FFT，每次把$A'$和$B$的卷积平移一项后加到$B$自身上。做多项式积分时第n项会产生$\frac{1}{n}$的常数，可以在递归边界时乘上去。

时间复杂度$O(n\log^2{n})$，但因为常数较小，实际上只比牛顿迭代慢一倍以内。

代码如下（我的NTT写法比较短）：
```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll lg=18,N=1<<lg,mod=998244353;
int n;
ll f[N],g[N],rev[N],w[N],c[N],d[N];
ll po(ll a,ll b){
    ll r=1;for(;b;b>>=1,(a*=a)%=mod)if(b&1)(r*=a)%=mod;
    return r;
}
void FFT(ll *a,int lg){
    for(int i=0;i<(1<<lg);i++)if(i<rev[i])swap(a[i],a[rev[i]]);
    for(int i=0;i<lg;i++)
        for(int j=0;j<(1<<lg);j++)if(j&1<<i){
            ll x=j^1<<i,l=a[x],r=a[j]*w[(j&(1<<i)-1)<<lg-1-i]%mod;
            a[x]=(l+r)%mod,a[j]=(l+mod-r)%mod;
        }
}
void work(int l,int r){ //此处是左闭右开区间[l,r)
    if(l+1==r){
        if(l)(f[l]*=po(l,mod-2))%=mod;else f[l]=1;
        return;
    }
    int mid=l+r>>1,_lg,n;
    work(l,mid);
    for(_lg=0;1<<_lg<r-l-1;_lg++);
    n=1<<_lg;
    for(int i=0;i<n;i++)
        c[i]=d[i]=0,w[i]=po(3,1ll*(mod-1)*i/n),
        rev[i]=rev[i/2]/2|(i&1)<<_lg-1;
    for(int i=0;i<mid-l;i++)c[i]=f[i+l];
    for(int i=0;i<r-l-1;i++)d[i]=g[i];
    FFT(c,_lg),FFT(d,_lg);
    for(int i=0;i<n;i++)(c[i]*=d[i])%=mod,w[i]=po(w[i],mod-2);
    FFT(c,_lg);
    for(int i=mid-1-l;i<r-l-1;i++)(f[i+l+1]+=c[i]*po(n,mod-2)%mod)%=mod;
    work(mid,r);
}
int main(){
    scanf("%d",&n);
    for(int i=0;i<n;i++)scanf("%lld",g+i);
    for(int i=1;i<n;i++)g[i-1]=g[i]*i%mod;g[n-1]=0;
    work(0,n);
    for(int i=0;i<n;i++)printf("%lld%c",f[i],i==n-1?'\n':' ');
    return 0;
}
```

---

## 作者：Gauss0320 (赞：14)

先从牛顿迭代讲起。

已知多项式函数$G(z)$，求多项式函数$F(x)$满足
$$G(F(x))\equiv0 \pmod{x^n}$$
考虑用迭代求解，假设我们已经求得$F_0(x)$满足
$$G(F_0(x))\equiv0\pmod{x^{\left\lceil\frac{n}{2}\right\rceil}}$$
将函数$G$在$z=F_0(x)$处进行泰勒展开
$$G(F(x))=\sum_{i=1}^{\infty}\frac{G^i(F_0(x))}{i!}(F(x)-F_0(x))^i$$
其中$G^i$为$G$的$i$阶导函数.

取前两项
$$G(F(x))\equiv G(F_0(x))+G'(F_0(x))(F(x)-F_0(x))\pmod{x^n}$$
考虑到$G(F(x))\equiv 0\pmod{x^n}$
$$F(x)\equiv F_0(x)-\frac{G(F_0(x))}{G'(F_0(x))}\pmod{x^n}$$
边界条件即$f[0]=1$，向上迭代即可.

回到本题，考虑到
$$B(x)\equiv e^{A(x)}\pmod{x^n}$$
即
$$\ln B(x)-A(x)\equiv0\pmod{x^n}$$
于是令
$$G(B(x))\equiv\ln B(x)-A(x)\pmod{x^n}$$
由于$A(x)$为常数
$$G'(B(x))=B^{-1}(x)$$
套牛顿迭代
$$B(x)\equiv B_0(x)(1-\ln B_0(x)+A(x))\pmod{x^n}$$
这就很好求了，代码如下
```cpp
#include <bits/stdc++.h>
#define re register

using namespace std;
typedef long long ll;
const int N = 1<<20;

int read() {
	int x = 0, f = 1; char c = getchar();
	while(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}
	while(c >= '0' && c <= '9') x = (x<<1) + (x<<3) + c - '0', c = getchar();
	return x * f;
}

inline void write(int a,char ed='\n')
{
    static short s[13],tp;
    if(!a){putchar('0'),putchar(ed);return;}
    for(tp=0;a;a/=10)s[++tp]=a%10;
    for(;tp;putchar(s[tp--]^48));
    putchar(ed);
}
namespace Polynomial
{
	const ll P = 998244353, g = 3, gi = 332748118;
	static int rev[N];
	int lim, bit;
	int add(int a, int b)
	{
		return (a += b) >= P ? a - P : a;
	}
	int qpow(int a, int b) 
	{
		int prod = 1;
		while(b)
		{
			if(b & 1) prod = (ll)prod * a % P;
			a = (ll)a * a % P;
			b >>= 1;
		}
		return (prod + P) % P;
	}
	void calrev() {
		for(re int i = 1; i < lim; ++i)
			rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (bit - 1));
	}
	void NTT(int *A, int inv) 
	{
		for(re int i = 0; i < lim; ++i)
			if(i < rev[i]) swap(A[i], A[rev[i]]);
		for(re int mid = 1; mid < lim; mid <<= 1) 
		{
			int tmp = qpow(inv == 1 ? g : gi, (P - 1) / (mid << 1));
			for(re int j = 0; j < lim; j += (mid << 1)) 
			{
				int omega = 1;
				for(re int k = 0; k < mid; ++k, omega = (ll)omega * tmp % P) 
				{
					int x = A[j + k], y = (ll)omega * A[j + k + mid] % P;
					A[j + k] = (x + y) % P;
					A[j + k + mid] = (ll)(x - y + P) % P;
				}
			}
		}
		if(inv == 1) return;
		int invn = qpow(lim, P - 2);
		for(re int i = 0; i < lim; ++i)
			A[i] = (ll)A[i] * invn % P;
	}
	static int x[N], y[N];
	void mul(int *a, int *b)
	{
		memset(x, 0, sizeof x);
		memset(y, 0, sizeof y);
		for(re int i = 0; i < (lim >> 1); ++i)
			x[i] = a[i], y[i] = b[i];
		NTT(x, 1), NTT(y, 1);
		for(re int i = 0; i < lim; ++i)
			x[i] = (ll)x[i] * y[i] % P;
		NTT(x, -1);
		for(re int i = 0; i < lim; ++i)
			a[i] = x[i];
	}
	static int c[2][N];
	void Inv(int *a, int n) 
	{
		int p = 0;
		memset(c, 0, sizeof c);
		c[0][0] = qpow(a[0], P - 2);
		lim = 2, bit = 1;
		while(lim <= (n << 1))
		{
			lim <<= 1, bit++;
			calrev();
			p ^= 1;
			memset(c[p], 0, sizeof c[p]);
			for(re int i = 0; i <= lim; ++i)
				c[p][i] = add(c[p^1][i], c[p^1][i]);
			mul(c[p^1], c[p^1]);
			mul(c[p^1], a);
			for(re int i = 0; i <= lim; ++i)
				c[p][i] = add(c[p][i], P - c[p^1][i]);
		}
		for(re int i = 0; i < lim; ++i)
			a[i] = c[p][i];
	}
	void derivative(int *a, int n)
	{
		for(re int i = 1; i <= n; ++i)
			a[i - 1] = (ll)a[i] * i % P;
		a[n] = 0;
	}
	void inter(int *a, int n)
	{
		for(re int i = n; i >= 1; --i)
			a[i] = (ll)a[i - 1] * qpow(i, P - 2) % P;
		a[0] = 0;
	}
	static int b[N], T[N], K[N];
	void ln(int *a, int n) 
	{
		memcpy(b, a, sizeof b);
		Inv(b, n), derivative(a, n);
		while(lim <= (n << 2)) lim <<= 1, bit++;
		calrev();
		mul(a, b);
		inter(a, n);
		for(re int i = n + 1; i <= lim; ++i)
			a[i] = 0;
	}
	void exp(int *a, int n)
	{
		int z, d;
		z = lim = 2, d = bit = 1;
		memset(K, 0, sizeof K);
		K[0] = 1;
		while(z <= (n<<1))
		{
			z <<= 1, d++;
			for(re int i = 0; i < (z>>1); ++i) 
				T[i] = K[i];
			ln(T, (z>>1) - 1);
			for(re int i = 0; i < (z>>1); ++i)
				T[i] = add(a[i] + (i == 0), P - T[i]);
			lim = z, bit = d;
			calrev();
			mul(K, T);
			for(re int i = z; i <= (z<<1); ++i)
				K[i] = T[i] = 0;
		}
		for(re int i = 0; i <= n; ++i)
			a[i] = K[i];
	}
}
using namespace Polynomial;
int n;
int F[N];
int main()
{
	n = read();
	for(re int i = 0; i < n; ++i)
		F[i] = read();
	exp(F, n);
	for(re int i = 0; i < n; ++i)
		write(F[i], ' ');
	return 0;
}
```


---

## 作者：zhiyangfan (赞：9)

## P4726 【模板】多项式指数函数（多项式 exp）
### 题意
给出 $n-1$ 次多项式 $A(z)$，求一个 $\bmod{\:z^n}$ 下的多项式 $B(z)$，满足 $B(z) \equiv \text e^{A(z)}$。系数对 $998244353$ 取模。($1\le n\le 10^5$)
### 题解
看到题解区一水的牛顿迭代求 $\exp$，唯一的半在线卷积求法的 $\LaTeX$ 还挂了，所以来水一篇半在线卷积求 $\exp$ 的解法。（ps. 个人觉得只要题上不用求 $\ln$，没必要费劲写那码量巨大的牛顿迭代 $\exp$，不如写码量小常数小的半在线卷积）

首先 $B(z)$ 存在，当且仅当 $[z^0]A(z)=0$，否则 $B(z)$ 常数项不收敛。接下来由于 $\exp$ 并不好处理，所以我们考虑求导：
$$B'(z)=\mathrm{e}^{A(z)}A'(z)$$
即
$$B'(z)=B(z)A'(z)$$
两边同时积分可以得到：
$$B(z)=\int B(z)A'(z)$$
即：
$$[z^n]B(z)=[z^n]\int B(z)A'(z)=\dfrac{1}{n}[z^{n-1}]B(z)A'(z)$$
现在这个形式就可以用半在线卷积求解了。首先给 $A(z)$ 求个导，设这个系数为 $g_i$，$B(z)$ 的系数为 $f_i$，则我们的式子为：
$$f_n=\dfrac{1}{n}\sum_{i=0}^{n-1}f_ig_{n-1-i}$$
然后利用这个式子，左半边对右半边做贡献，外层的常数可以在分治边乘上：
$$f_{l..mid}\times g_{0..r-l}\rightarrow f_{mid,r}$$
注意做贡献的时候要平移。别的就是板子了，时间复杂度 $\mathcal{O}(n\log ^2n)$，真的很好写。
```cpp
#include <cstdio>
#include <algorithm>
const int N = 1e6 + 10, mod = 998244353; typedef long long ll;
inline int ksm(int a, int b)
{
    int ret = 1;
    while (b)
    {
        if (b & 1) ret = (ll)ret * a % mod;
        a = (ll)a * a % mod; b >>= 1;
    }
    return ret;
}
int F[N], G[N], A[N], B[N], rev[N], lim, m, n;
inline void init(int n)
{
    lim = 1; m = 0; while (lim <= n) lim <<= 1, ++m;
    for (int i = 0; i < lim; ++i) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (m - 1));
}
inline void NTT(int* f, int len, int on)
{
    for (int i = 0; i < len; ++i) if (i < rev[i]) std::swap(f[i], f[rev[i]]);
    for (int h = 2; h <= len; h <<= 1)
    {
        int gn = ksm(3, (ll)(mod - 1) / h * on % (mod - 1));
        for (int j = 0; j < len; j += h)
            for (int k = j, g = 1; k < j + h / 2; ++k, g = (ll)g * gn % mod)
            {
                int u = f[k], t = (ll)g * f[k + h / 2] % mod;
                f[k] = (u + t) % mod; f[k + h / 2] = ((u - t) % mod + mod) % mod;
            }
    }
    if (on == mod - 2) for (int i = 0, inv = ksm(len, on); i < len; ++i) f[i] = (ll)f[i] * inv % mod;
}
void cdq(int l, int r)
{
    if (l + 1 == r) return F[l] = l ? (ll)F[l] * ksm(l, mod - 2) % mod : 1, void();
    int mid = (l + r) >> 1; cdq(l, mid); init(r - l);
    for (int i = 0; i < mid - l; ++i) A[i] = F[i + l];
    for (int i = 0; i < r - l - 1; ++i) B[i] = G[i];
    for (int i = mid - l; i < lim; ++i) A[i] = 0;
    for (int i = r - l; i < lim; ++i) B[i] = 0;
    NTT(A, lim, 1); NTT(B, lim, 1);
    for (int i = 0; i < lim; ++i) A[i] = (ll)A[i] * B[i] % mod;
    NTT(A, lim, mod - 2);
    for (int i = mid - l - 1; i < r - l - 1; ++i) (F[i + l + 1] += A[i]) %= mod;
    cdq(mid, r);
}
int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; ++i) scanf("%d", &G[i]);
    for (int i = 1; i < n; ++i) G[i - 1] = (ll)i * G[i] % mod;
    G[n - 1] = 0;
    cdq(0, n); for (int i = 0; i < n; ++i) printf("%d ", F[i]); 
    puts(""); return 0;
}
```

---

## 作者：VenusM1nT (赞：7)

本文收录于：[多项式算法学习笔记](https://venusnero.github.io/2019/03/19/poly_algorithm_note/)。

神仙方法……需要先学泰勒展开，然后借助泰勒展开学会牛顿迭代，然后才能做……

（Orz 隔壁的 bzt）

泰勒展开就不讲了，牛顿迭代可以见[这里](http://blog.miskcoo.com/2015/06/polynomial-with-newton-method)，反正最后可以得到：

$$F(z)\equiv F_0(z)-{G(F_0(z))\over G'(F_0(z))}\ (\text{mod}\ \ z^n)$$

所以我们考虑求 $G(x)$ 使 $G(x)=e^{F(x)}$，直接求显然是不现实的，那么我们因为刚刚学了对数函数，而对数和指数是逆运算，所以我们考虑把它转化成指数：

$$\ln G(x)-F(x)=0$$

出现了 $0$，那么我们刚刚学牛顿迭代，所以我们考虑用它来求零点，令 $f(G(x))=\ln G(x)-F(x)$，珂以把 $F(x)$ 看成常数项，所以求导出来是：$f'(G(x))={1\over G(x)}$，把这两个代进牛顿迭代的式子，珂以得到：

$$G(x)\equiv G_0(x)-{\ln G_0(x)-F(x) \over {1\over G_0(x)}} \ (\text{mod}\ \ x^n)$$

$$G(x)\equiv G_0(x)-(\ln G_0(x)-F(x) )\times G_0(x) \ (\text{mod}\ \ x^n)$$

$$G(x)\equiv G_0(x)(1-\ln G_0(x)+F(x)) \ (\text{mod}\ \ x^n)$$

依然递归求解即可。

（求 $\ln$ 的时候记得清空 a 数组……）

```cpp
void GetExp(int *f,int *g,int len)
{
    if(len==1)
    {
        g[0]=1;
        return;
    }
    GetExp(f,g,len+1>>1);
    lim=1;
    m=0;
    while(lim<(len<<1))
    {
        lim<<=1;
        m++;
    }
    for(int i=1;i<lim;i++) rev[i]=(rev[i>>1]>>1)|((i&1)<<(m-1));
    for(int i=0;i<(len<<1);i++) d[i]=e[i]=0;
    GetLn(g,d,len);
    for(int i=0;i<len;i++) e[i]=f[i];
    NTT(g,1);
    NTT(d,1);
    NTT(e,1);
    for(int i=0;i<lim;i++) g[i]=(1ll-d[i]+e[i]+Mod)*g[i]%Mod;
    NTT(g,-1);
    for(int i=len;i<lim;i++) g[i]=0;
}
```

---

## 作者：_HL_ (赞：6)

# 前言

关于怎么实现楼上的大佬们已经讲得很清楚了 只是蒻笔者在学习时遇到了许多困惑

一个最主要的问题：推到 $F(x)=F_0(x)-\dfrac{G(F(x))}{G'(F(x))}$ 时 这个 $G'(F(x))$ 是什么 

具体到 exp 的实现上为什么 $G(B(x))=\ln B(x)-A(x)$ 对 $G$ 求导之后没有 $A(x)$ 了？？

这个问题已有的题解区并没有很好的解答 并且清月大佬的题解似乎是有一些理解上的错误的（不是一个复合函数 否则不会求导之后没有$A(x)$ ） 

对笔者造成了一些理解上的误导 看到这篇 [博客](https://blog.csdn.net/qq_35950004/article/details/106469316) 的第一部分 才豁然开朗 

本文将对以上问题做以笔者理解的解答 当然本文也会完整介绍多项式牛顿迭代和exp的理解与实现

# 数域

首先明确一点 我们讨论的**数域** 这也是最迷惑的部分

我们是给定一个定多项式 求出一个新的多项式

形式化地 设 $S$ 为多项式数域 则我们需要完成的是 $G:S\rightarrow S$

即**我们的变量是一个多项式 所有确定的多项式都是常数**

$x$ 和 $x^2+x^3+x^4$ 都是常数

# 多项式牛顿迭代

考虑正常的牛顿迭代 是一种可以快速求出使 $f(a)=0$ 满足的 $a$ 的方法 

我们迁移到多项式域下 设 $X$ 为多项式变量 

注意：**$X$ 是一个多项式** 为了避免混淆 不写成 $f(x)$ 的形式

$G(X)\equiv0\pmod {x^n}$

设 $m=\lceil \dfrac{n}{2}\rceil$

由于牛顿迭代是通过递归倍增实现 假设现在我们已经求得了$X_0$ 使得$G(X_0)\equiv0\pmod{x^m}$

注意 现在 $X_0$ 已经为确定的多项式

我们在多项式域下做泰勒展开

$G(X)=\sum_{i=0}^{+\infty}\dfrac{G^{(i)}(X_0)}{i!}(X-X_0)^i$

这个式子可能引发以下疑问：

**一个 $S\rightarrow S$ 的函数的导函数是什么东西？该怎么求？**

由于求导公式是可以针对任意域的 所以我们可以按照求导的公式和运算法则直接求

而一个 $S\rightarrow S$ 的函数的导函数还是 $S\rightarrow S$ 的 

放在模 $x^n$ 意义下 

$G(X)=G(X_0)+G'(X_0)(X-X_0)\equiv0\pmod {x^n}$

再明确一下这里的取模 一个直接的意思就是保留多项式的前多少位 剩下的不要了

而为什么要取这个模呢？比如 $\ln X$ 一个多项式的对数 很抽象 实际的含义很难去叙述 但主要应用上基本上都是 $\ln$ 过去 $\exp$ 回来 起到一个加速的作用

而需要这个过程之后我们的多项式还是对的 至少是我们需要的那些部分是对的 所以需要进行取模 只保留近似的多项式的前一些项 

好 我们继续推逝子

$X\equiv X_0-\dfrac{G(X_0)}{G'(X_0)}\pmod{x^n}$

递推的式子有了 考虑边界

我们需要单独求出 $G(X)\equiv0\pmod{x}$ 的解 只要给定 $G$ 或通过转化 我们易于得出这一解

总结：

多项式牛顿迭代的适用条件

1. 对于确定多项式 $P$ 需要有 $\dfrac{G(P)}{G'(P)}$ 化简后易于求解或者 $G(P)$ 和 $G'(P)$ 都易于求解

2. $G(X)\equiv0\pmod{x}$ 的解 $X_c$（一个0次多项式） 易于求解

# 多项式 exp

 _这部分讲的比较简略 因为这部分其他题解已经讲得很清楚了_ 

以 $\exp$ 为例 给定 $A(x)$

求 $B(x)$ 使得 $B(x)\equiv e^{A(x)}\pmod{x^n}$

若令 $G(X)=X-e^A$ 则不满足使用条件 1

考虑取对数

$\ln B(x)\equiv A(x)\pmod{x^n}$

令 $G(X)=\ln X-A$ 

由于 $B=e^A$ 所以多项式常数项只能是 $1 $ 

故 $X_c=1$ 

递推式 $X=X_0-\dfrac{G(X_0)}{G'(X_0)}=X_0-\dfrac{\ln X_0-A}{\frac{1}{X_0}}=X_0(A+1-\ln X_0)$

然后就可做了 化成常见的多项式形式即是 $B(x)=B_0(x)(A(x)-\ln B_0(x)+1)\pmod{x^n}$

我写的代码常数不太好 比较懒 写的迭代版本

```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read(){int x=0;char c=getchar();while(c<'0'||c>'9')c=getchar();while(c<='9'&&c>='0')x=(x<<1)+(x<<3)+(c^48),c=getchar();return x;}
#define mod 998244353
#define g 3
#define ig 332748118
#define ll long long
inline int add(int x,int y){int res=x+y;return res<mod?res:res-mod;}
inline int mul(int x,int y){return (ll)x*y%mod;}
inline int qpow(int a,int b){int res=1;while(b){if(b&1)res=mul(res,a);a=mul(a,a),b>>=1;}return res;}
const int N=1e5+3;
struct poly
{
	int lth,f[N<<2];
	inline void init(int x){lth=ceil(log2(x));lth=1<<lth;}
	inline void clear(){memset(f,0,sizeof(f));}
	inline void fft(int len,bool tp)
	{
		if(!len)len=lth;
		for(int i=0,j=0;i<len;i++){if(i<j)swap(f[i],f[j]);for(int x=len>>1;(j^=x)<x;x>>=1);}
		for(int l=2;l<=len;l<<=1)
		{
			int wn=qpow(tp?ig:g,(mod-1)/l),d=l>>1;
			for(int k=0;k<len;k+=l)
			for(int i=0,w=1;i<d;i++,w=mul(w,wn))
			{
				int x=f[i+k],y=mul(f[i+k+d],w);
				f[i+k]=add(x,y),f[i+k+d]=add(x,mod-y);
			}
		}
		if(tp){int il=qpow(len,mod-2);for(int i=0;i<len;i++)f[i]=mul(f[i],il);}
	}
}a,b,c,tmp,tmp1;
inline void inv(const poly &a,poly &ia)
{
	int lenall=a.lth;tmp1.clear();
	ia.f[0]=qpow(a.f[0],mod-2);
	for(int l=2;l<=lenall;l<<=1)
	{
		int d=l<<1;
		for(int i=0;i<l;i++)tmp1.f[i]=a.f[i];
		ia.fft(d,0),tmp1.fft(d,0);
		for(int i=0;i<d;i++)ia.f[i]=mul(ia.f[i],add(2,mod-mul(tmp1.f[i],ia.f[i])));
		ia.fft(d,1);for(int i=l;i<d;i++)ia.f[i]=0;
	}
}
inline void ln(poly a,poly &b)
{
	inv(a,b);
	for(int i=1;i<a.lth;i++)a.f[i-1]=mul(a.f[i],i);
	a.f[a.lth-1]=0;a.lth=b.lth=a.lth<<1;
	a.fft(0,0),b.fft(0,0);
	for(int i=0;i<a.lth;i++)b.f[i]=mul(b.f[i],a.f[i]);
	b.fft(0,1);b.lth=a.lth>>1;
	for(int i=b.lth-1;~i;i--)b.f[i]=mul(b.f[i-1],qpow(i,mod-2));
	b.f[0]=0;for(int i=b.lth;i<a.lth;i++)b.f[i]=0;
}
inline void exp(const poly &a,poly &b)
{
	int lenall=a.lth;
	b.f[0]=1;tmp.clear();
	for(int l=2;l<=lenall;l<<=1)
	{
		int d=l<<1;b.lth=l;c.clear(),ln(b,c);
		for(int i=0;i<l;i++)tmp.f[i]=a.f[i];
		b.fft(d,0),c.fft(d,0),tmp.fft(d,0);
		for(int i=0;i<d;i++)b.f[i]=mul(b.f[i],add(tmp.f[i],add(1,mod-c.f[i])));
		b.fft(d,1);for(int i=l;i<d;i++)b.f[i]=0;
	}
}
signed main()
{
	int n=read();
	for(int i=0;i<n;i++)a.f[i]=read();
	a.init(n);exp(a,b);
	for(int i=0;i<n;i++)printf("%d ",b.f[i]);
	return 0;
}
```


---

## 作者：Spasmodic (赞：6)

[可能更好的阅读体验](https://www.luogu.com.cn/blog/happydef-blog/duo-xiang-shi-quan-jia-tong-xue-xi-bi-ji)

前置芝士：多项式求逆，多项式$\ln$，泰勒展开。

首先我们来了解一下多项式牛顿迭代：

若
$$G(F(x))\equiv 0\pmod {x^n}$$
$$G(F_0(x))\equiv 0\pmod {x^{\lceil\frac{n}{2}\rceil}}$$
则根据泰勒展开：
$$G(F)=G(F_0)+G'(F_0)(F-F_0)+G''(F_0)(F-F_0)^2+\cdots$$
因为
$$F\equiv F_0 \pmod {x^{\lceil\frac{n}{2}\rceil}}$$
所以
$$F^2\equiv F_0^2\pmod {x^n}$$
所以
$$0\equiv G(F)\equiv G(F_0)+G'(F_0)(F-F_0) \pmod {x^n}$$
$$F\equiv F_0-\frac{G(F_0)}{G'(F_0)}\pmod{x^n}$$
这就是牛顿迭代的式子啦，下面我们来用这个式子推一下$\exp$的做法
$$G(x)\equiv e^{F(x)}\pmod {x^n}$$
$$\ln G-F\equiv 0 \pmod {x^n}$$
设
$$y=\ln G-F$$
则
$$dy=d(\ln G-F)$$
$$dy=\frac{dG}{G}$$
$$\frac{dy}{dG}=\frac{1}{G}$$
设
$$\ln G_0-F\equiv 0 \pmod {x^{\lceil\frac{n}{2}\rceil}}$$
则根据牛顿迭代公式：
$$G\equiv G_0-\frac{\ln G_0-F}{\frac{1}{G_0}}\equiv G_0(1-\ln G_0+F)\pmod{x^n}$$
于是递归即可。

复杂度$T(n)=T(\frac{n}{2})+O(n\log n)$，根据主定理可知$T(n)=O(n\log n)$。

不过众所周知多项式$\exp$极其难调因此这里给出了我的核心代码实现：（常数巨大，勿抄）
```cpp
void getexp(ll*f,ll*g,ll len){
   if(len==1){g[0]=1;return;}
   getexp(f,g,len+1>>1);
   init(len<<1);
   for(ll i=0;i<(len<<1);i++)d[i]=e[i]=0;
   getln(g,d,len);
   for(ll i=0;i<len;i++)e[i]=f[i];
   NTT(g,lmt,1),NTT(d,lmt,1),NTT(e,lmt,1);
   for(ll i=0;i<lmt;i++)g[i]=(1-d[i]+e[i]+P)*g[i]%P;
   NTT(g,lmt,-1);
   for(ll i=len;i<lmt;i++)g[i]=0; 
   clear(d),clear(e);
}
```
下面是完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll; 
const ll N=100005*3;
ll n,f[N],g[N];
namespace Poly{
	const ll P=998244353,G=3;
	ll lmt,rev[N],a[N],b[N],c[N],d[N],e[N];
	inline ll qpow(ll a,ll k){
		ll ret=1;
		while(k){
			if(k&1)ret=ret*a%P;
			a=(a*a)%P;
			k>>=1;
		}
		return ret%P;
	}
	inline void init(ll n){
		lmt=1;ll t=0;
		while(lmt<n)lmt<<=1,t++;
		for(ll i=1;i<lmt;i++)rev[i]=(rev[i>>1]>>1)|(i&1)<<(t-1);
	}
	inline void NTT(ll *A,ll lmt,ll tp){
		for(ll i=0;i<lmt;i++)if(i<rev[i])swap(A[i],A[rev[i]]);
		for(ll m=1;m<lmt;m<<=1)
			for(ll j=0,Wn=qpow(G,(P-1)/(m<<1));j<lmt;j+=m<<1)
				for(ll k=0,w=1,x,y;k<m;k++,w=w*Wn%P)
					x=A[j+k],y=w*A[j+k+m]%P,A[j+k]=(x+y)%P,A[j+k+m]=(x-y+P)%P;
		if(tp==1)return;
		reverse(A+1,A+lmt);
		for(ll i=0,inv=qpow(lmt,P-2);i<=lmt;i++)A[i]=A[i]*inv%P;
	} 
	inline void mul(ll *f,ll *g,ll len){
		init(len);
		NTT(f,lmt,1);NTT(g,lmt,1);
		for(ll i=0;i<lmt;i++)f[i]=(f[i]*g[i])%P;
		NTT(f,lmt,-1);
	} 
	void getinv(ll*f,ll*g,ll len){
		if(len==1){g[0]=qpow(f[0],P-2);return;}
		getinv(f,g,len+1>>1);
		init(len<<1);
		for(ll i=0;i<len;i++)c[i]=f[i];
		for(ll i=len;i<lmt;i++)c[i]=0;
		NTT(c,lmt,1),NTT(g,lmt,1);
		for(ll i=0;i<lmt;i++)g[i]=(2LL-g[i]*c[i]%P+P)%P*g[i]%P;
		NTT(g,lmt,-1);
		for(ll i=len;i<lmt;i++)g[i]=0; 
	}
	void getdev(ll*f,ll*g,ll len){
		for(ll i=1;i<len;i++)g[i-1]=i*f[i]%P;
		g[len-1]=0;
	}
	void getinvdev(ll*f,ll*g,ll len){
		for(ll i=1;i<len;i++)g[i]=f[i-1]*qpow(i,P-2)%P;
		g[0]=0;
	}
	void getln(ll*f,ll*g,ll len){
		memset(a,0,sizeof(a));
		memset(b,0,sizeof(b));
		getdev(f,a,len);
		getinv(f,b,len);
		mul(a,b,len<<1);
		getinvdev(a,g,len);
	}
	void getexp(ll*f,ll*g,ll len){
		if(len==1){g[0]=1;return;}
		getexp(f,g,len+1>>1);
		init(len<<1);
		for(ll i=0;i<(len<<1);i++)d[i]=e[i]=0;
		getln(g,d,len);
		for(ll i=0;i<len;i++)e[i]=f[i];
	    NTT(g,lmt,1),NTT(d,lmt,1),NTT(e,lmt,1);
    	for(ll i=0;i<lmt;i++)g[i]=(1-d[i]+e[i]+P)*g[i]%P;
    	NTT(g,lmt,-1);
    	for(ll i=len;i<lmt;i++)g[i]=0; 
	}
}
using Poly::getexp;
int main(){
	scanf("%lld",&n);
	for(ll i=0;i<n;i++)scanf("%lld",&f[i]);
	getexp(f,g,n);
	for(ll i=0;i<n;i++)printf("%lld ",g[i]);
	return 0;
}
```

---

## 作者：gayh20 (赞：6)

我闲的没事写了一发任意模数 exp，，，

常数极大就是了。需要用 myy 论文里面的 $4$ 次 FFT 黑科技才能勉强卡时限 AC。

假如不会，推荐去任意模数 NTT 题解去学习。多项式 exp 的过程请去其他题解学习。

<https://www.luogu.com.cn/problem/T128649> 这里有一道模板题（窝真的是太闲了

代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<vector>
#include<complex>
using namespace std;
typedef complex<double> comp;
typedef long long ll;
const int B=32768;
int n,tr[550005],mod,f[550005]={1},g[550005],miu[550005],prime[550005],vst[550005];
comp wk[550005],a0[550005],a1[550005],b0[550005],b1[550005],p[550005],q[550005];
int Power(int x,int y,int mod) {
	int ret=1;
	while(y) {
		if(y&1)ret=1ll*ret*x%mod;
		x=1ll*x*x%mod,y>>=1;
	}
	return ret;
}
void GetTr(int l) {
	for(int i=0; i<l; i++)tr[i]=(tr[i>>1]>>1)|((i&1)?(l>>1):0);
}
void FFT(comp a[],int n,int flag){
	for(int i=0;i<n;i++)if(tr[i]<i)swap(a[i],a[tr[i]]);
	for(int i=1;i<n;i<<=1){
		for(int j=0;j<n;j+=(i<<1)){
			for(int k=0;k<i;k++){
				comp t;
				if(flag==1)t=a[i+j+k]*wk[262144/i*k];
				else t=a[i+j+k]/wk[262144/i*k];
				a[i+j+k]=a[j+k]-t,a[j+k]+=t;
			}
		}
	}
	if(flag==-1)for(int i=0;i<n;i++)a[i]/=n;
}
const comp I=comp(0,1);
void Mul(int a[],int b[],int l){
	for(int i=0;i<l;i++)a0[i]=comp(a[i]/B,a[i]%B),b0[i]=comp(b[i]/B,b[i]%B);
	FFT(a0,l,1);
	for(int i=0;i<l;i++)a1[i]=conj(a0[i?l-i:0]);
	for(int i=0;i<l;i++){
		comp p=a0[i],q=a1[i];
		a0[i]=(p+q)/2.0,a1[i]=I*(q-p)/2.0;
	}
	FFT(b0,l,1);
	for(int i=0;i<l;i++)b1[i]=conj(b0[i?l-i:0]);
	for(int i=0;i<l;i++){
		comp p=b0[i],q=b1[i];
		b0[i]=(p+q)/2.0,b1[i]=I*(q-p)/2.0;
	}
	for(int i=0;i<l;i++)p[i]=a0[i]*b0[i]+I*a1[i]*b0[i],q[i]=a0[i]*b1[i]+I*a1[i]*b1[i];
	FFT(p,l,-1),FFT(q,l,-1);
	for(int i=0;i<l;i++){
		ll a1b1=(ll)(p[i].real()+0.5),a3b3=(ll)(p[i].imag()+q[i].real()+0.5),a2b2=(ll)(q[i].imag()+0.5);
		a[i]=(a1b1%mod*B%mod*B+a3b3%mod*B+a2b2)%mod;
	}
}
void Calcinv(int a[],int b[],int l){
	if(l==1){
		b[0]=Power(a[0],mod-2,mod);
		return ;
	}
	Calcinv(a,b,(l+1)/2);
	int len=1;
	while(len<l*2)len<<=1;
	GetTr(len);
	static int tmp[550005]={0};
	memcpy(tmp,a,sizeof(int)*l);
	for(int i=l;i<len;i++)tmp[i]=0;
	Mul(tmp,b,len);
	Mul(tmp,b,len);
	for(int i=0;i<l;i++)b[i]=(2ll*b[i]-tmp[i]+mod)%mod;
}
void Calcln(int a[],int b[],int l){
	static int tmp[550005]={0};
	memcpy(tmp,a,sizeof(int)*l);
	for(int i=1;i<l;i++)tmp[i-1]=1ll*tmp[i]*i%mod;
	tmp[l-1]=0;
	Calcinv(a,b,l);
	int len=1;
	while(len<l*2)len<<=1;
	GetTr(len);
	for(int i=l;i<len;i++)tmp[i]=0;
	Mul(b,tmp,len);
	for(int i=l;i<len;i++)b[i]=0;
	for(int i=l-1;i>0;i--)b[i]=1ll*b[i-1]*Power(i,mod-2,mod)%mod;
	b[0]=0;
}
void Calcexp(int a[],int b[],int l){
	if(l==1){
		b[0]=1;
		return ;
	}
	static int tmp[400005]={0},ln[400005]={0};
	Calcexp(a,b,(l+1)/2);
	Calcln(b,ln,l);
	memcpy(tmp,a,sizeof(int)*l);
	int len=1;
	while(len<=l*1.5)len<<=1;
	GetTr(len);
	tmp[0]=(1-ln[0]+tmp[0]+mod)%mod;
	for(int i=1;i<len;i++)tmp[i]=(tmp[i]-ln[i]+mod)%mod;
	Mul(b,tmp,len);
	fill(b+l,b+len,0);
	fill(tmp,tmp+len,0);
	fill(ln,ln+len,0);
}
int main() {
	double pi=acos(-1);
	for(int i=1;i<262144;i++)wk[i]=exp(comp(0,pi/262144*i));
	scanf("%d",&n),wk[0]=1,mod=998244353;
	for(int i=0;i<n;i++)scanf("%d",&f[i]);
	Calcexp(f,g,n);
	for(int i=0;i<n;i++)printf("%d ",g[i]);
}
```

---

## 作者：Great_Influence (赞：5)

多项式$Exp$模板题。

想做这道题先要知道[多项式Ln](https://www.luogu.org/problemnew/show/P4725)怎么写。

你可以看看[这个](https://www.luogu.org/blog/user7035/duo-xiang-shi-zong-jie)。

设$G(x)\equiv e^{F(x)}\pmod{x^n}$，$G_1(x)\equiv e^{F(x)}\pmod{x^{\lceil\frac{n}{2}\rceil}}$


利用牛顿迭代公式可得

$$G=G_1(1-LnG_1+F)$$

倍增求即可。注意倍增用的变量不能重复。

代码:

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/priority_queue.hpp>
#define For(i,a,b) for(i=(a);i<=(b);++i)
#define Forward(i,a,b) for(i=(a);i>=(b);--i)
#define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
#define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
using namespace std;
inline void read(int &x)
{
    static const int BUFSIZE = 1048576;
    static char buf[BUFSIZE];
    static char *bufnow = buf;
    static char *bufmax = buf;
    if (bufnow == bufmax) {
        bufmax = buf + fread(buf, 1, BUFSIZE, stdin);
        bufnow = buf;
    }
    static int c;
    c = *bufnow++;
    for (;!isdigit(c);c = *bufnow++) {
            if (bufnow == bufmax) {
            bufmax = buf + fread(buf, 1, BUFSIZE, stdin);
            bufnow = buf;
        }
    }
    x = 0;
    for (;isdigit(c);c = *bufnow++) {
        x = (x << 1) + (x << 3) + c - 48;
        if (bufnow == bufmax) {
            bufmax = buf + fread(buf, 1, BUFSIZE, stdin);
            bufnow = buf;
        }
    }
}

inline void write(int a,char ed='\n')
{
    static short s[13],tp;
    if(!a){putchar('0'),putchar(ed);return;}
    for(tp=0;a;a/=10)s[++tp]=a%10;
    for(;tp;putchar(s[tp--]^48));
    putchar(ed);
}

void file(void){
    freopen("polynomial.in","r",stdin);
    freopen("polynomial.out","w",stdout);
}
const int MAXN=1<<22;

typedef long long ll;

namespace polynomial 
{
    static int mod=998244353,gen=3,g[21],rev[MAXN],Len;

    inline int ad(int a,int b){return (a+=b)>=mod?a-mod:a;}

    inline int power(int a,int b)
    {
        static int sum;
        for(sum=1;b;b>>=1,a=(ll)a*a%mod)if(b&1)
            sum=(ll)sum*a%mod;
        return sum;
    }

    inline void predone()
    {
        static int i,j;
        for(i=1,j=2;i<=20;++i,j<<=1)g[i]=power(gen,(mod-1)/j);
    }

    inline void calrev(int Len)
    {
        static int Logl;Logl=(int)floor(log(Len)/log(2)+0.3)-1;
        Rep(i,1,Len-1)rev[i]=(rev[i>>1]>>1)|((i&1)<<Logl);
    }

    inline void NTT(int X[],int typ)
    {
        Rep(i,1,Len-1)if(i<rev[i])swap(X[i],X[rev[i]]);
        static int i,j,k,kk,w,t,wn,r;
        for(k=2,kk=1,r=1;k<=Len;k<<=1,kk<<=1,++r)
        {
            wn=g[r];
            for(i=0;i<Len;i+=k)for(j=0,w=1;j<kk;++j,w=(ll)w*wn%mod)
            {
                t=(ll)w*X[i+j+kk]%mod;
                X[i+j+kk]=ad(X[i+j],mod-t);
                X[i+j]=ad(X[i+j],t);
            }
        }
        if(typ==-1)
        {
            reverse(X+1,X+Len);
            static int invn;invn=power(Len,mod-2);
            Rep(i,0,Len-1)X[i]=(ll)X[i]*invn%mod;
        }
    }

    static int x[MAXN],y[MAXN];
    inline void mul(int a[],int b[])
    {
        memset(x,0,sizeof x);memset(y,0,sizeof y);
        Rep(i,0,(Len>>1)-1)x[i]=a[i],y[i]=b[i];
        NTT(x,1);NTT(y,1);
        Rep(i,0,Len-1)x[i]=(ll)x[i]*y[i]%mod;
        NTT(x,-1);
        Rep(i,0,Len-1)a[i]=x[i];
    }
    
    static int c[2][MAXN];
    
    static int A[MAXN],B[MAXN];

    void Inv(int *a,int *b,int n)
    {
        if(n==1){b[0]=power(a[0],mod-2);return;}
        Inv(a,b,n>>1);
        Len=n<<1;
        calrev(Len);
        Rep(i,0,(Len>>1)-1)A[i]=a[i],B[i]=b[i];
        NTT(A,1);NTT(B,1);
        Rep(i,0,Len-1)B[i]=(ll)B[i]*B[i]%mod*A[i]%mod;
        NTT(B,-1);
        Rep(i,0,(Len>>1)-1)b[i]=ad(b[i],ad(b[i],mod-B[i]));
        Rep(i,0,Len)A[i]=B[i]=0;
    }
    
    inline void Direv(int *a,int n)
    {Rep(i,1,n)a[i-1]=(ll)a[i]*i%mod;a[n]=0;}
    
    inline void Inter(int *a,int n)
    {Repe(i,n,1)a[i]=(ll)a[i-1]*power(i,mod-2)%mod;a[0]=0;}

    static int X[MAXN];
    
    inline void Ln(int *a,int n)
    {
        Len=2;
        memset(X,0,sizeof X);
        while(Len<=n)Len<<=1;
        Inv(a,X,Len);
        Direv(a,n);
        while(Len<=(n<<2))Len<<=1;
        calrev(Len);
        mul(a,X);
        Inter(a,n);
        Rep(i,n+1,Len)a[i]=0;
    }

    static int T[MAXN],K[MAXN];

    inline void Exp(int *a,int n)
    {
        static int t,z;t=0;
        memset(K,0,sizeof K);K[0]=1;
        Len=z=2;
        while(z<=(n<<1))
        {
            z<<=1;t^=1;
            Rep(i,0,(z>>1)-1)T[i]=K[i];
            Ln(T,(z>>1)-1);
            Rep(i,0,(z>>1)-1)T[i]=ad(a[i]+(i==0),mod-T[i]);
            calrev(Len=z);
            mul(K,T);
            Rep(i,z,z<<1)K[i]=T[i]=0;
        }
        Rep(i,0,n)a[i]=K[i];
    }
}
using namespace polynomial;

static int n,F[MAXN];

int main(void){
//    file();
    predone();
    read(n);
    Rep(i,0,n-1)read(F[i]);
    Exp(F,n);
    Rep(i,0,n-1)write(F[i],' ');
//    cerr<<1.0*clock()/CLOCKS_PER_SEC<<endl;
    return 0;
}
```
~~(因为常数问题卡了下常，顺便一说递归式比非递归式要快)~~

---

## 作者：Illusory_dimes (赞：4)

### 题目大意
给定 $n-1$ 次多项式 $g(x)$ ，求多项式 $f(x)$ 满足：

$f(x)\equiv\exp^{g(x)}$ $(mod$ $x^n)$

系数对 $998244353$ 取模。

数据范围 $n\leq 10^5$ 。

### 前置芝士：
多项式 $\ln$ ，~~非常入门的~~求导，积分和恶俗的牛顿迭代。

第一个不会出门左拐，最后两个的话，这里只要：

求导公式 $\mathrm{d}$ $x^{a}=ax^{a-1}$ 。

求导法则 $\mathrm{d}$ $f[g(x)]=f^{'}[g(x)]\cdot g^{'}(x)$ 。

积分公式 $\int x^a=\frac{1}{a+1}x^{a+1}$ 。

牛顿迭代的话，珂以看看[我的文章](https://www.luogu.com.cn/blog/ngzzgzz/yi-ge-niu-dun-die-dai-hao-xiang-bi-jiao-neng-dong-di-li-xie)（虽然不咋地。。），大概了解一下原理就好

### solution
对于多项式刚刚杠到这题的我们来说， $\exp$ 实在有点陌生，但 $\ln$ 肯定已经见过了。

所以聪明的你一定注意到了 $\exp^{g(x)}$ 取 $\ln$ 后 $\Longrightarrow g(x)$ 。

漂亮，

$f(x)\equiv\exp^{g(x)}$ $(mod$ $x^n)$

两边同时取个 $\ln$ ：

$\ln_{}{f(x)}\equiv g(x)$ $(mod$ $x^n)$

设 $\varphi(f(x))=\ln_{}{f(x)}-g(x)\equiv0$ $(mod$ $x^n)$

用一下上面提到的牛顿迭代的公式

$f(x)\equiv f_0(x)-\Large\frac{\ln f_0(x)-g(x)}{\frac{1}{f_0(x)}}$

化简一下：

$f(x)\equiv f_0(x)\cdot(1+g(x)-\ln f_0(x))$

完了，

用一下 $\ln$ 的求法就行了

时间复杂度 $O(n\log_{2}{n})$ 。

人傻常熟大 wtcl 。。
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=4e5+10;
typedef ll arr[N];
const int mod=998244353;
const int inv3=332748118;
int n,inv,lim=1,fre,id[N];
arr f,g,ans,tmp,ln;
inline ll inc(ll x,ll y){return x+y>=mod?x+y-mod:x+y;}
inline ll dec(ll x,ll y){return x-y<0?x-y+mod:x-y;}
inline ll mul(ll x,ll y){return 1ll*x*y%mod;}
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*w;
}
inline int ksm(int a,int b)
{
	int tmp=1;
	while(b)
	{
		if(b&1)tmp=(1ll*tmp*a)%mod;
		b>>=1,a=(1ll*a*a)%mod;
	}
	return tmp;
}
inline void Never_Tell_TLE(ll* NTT,int sign)
{
	for(int i=0;i<=lim;++i)if(i<id[i])
	{
		ll NTt=NTT[i];
		NTT[i]=NTT[id[i]];
		NTT[id[i]]=NTt;
	}
	for(int mid=1;mid<lim;mid<<=1)
	{
		int Unit_root;
		if(sign==1)Unit_root=ksm(3,(mod-1)/(mid<<1));
		else Unit_root=ksm(inv3,(mod-1)/(mid<<1));
		for(int R=mid<<1,r=0;r<lim;r+=R)
		{
			int pw=1;
			for(int l=0;l<mid;++l,pw=(1ll*pw*Unit_root)%mod)
			{
				int butt=NTT[l+r],rfly=(1ll*pw*NTT[l+r+mid])%mod;
				NTT[l+r]=inc(butt,rfly);
				NTT[l+r+mid]=dec(butt,rfly);
			}
		}
	}
	if(sign==-1)
	{
		int inv_lim=ksm(lim,mod-2);
		for(int i=0;i<=lim;++i)NTT[i]=(1ll*NTT[i]*inv_lim)%mod;
	}
}
inline void Derivation(ll* F,ll* G,int nm)
{
	for(int i=1;i<nm;++i)
	G[i-1]=mul(1ll*i,F[i]);
	G[nm-1]=0;
}
inline void Inv(ll* F,ll* G,int nm)
{
	if(nm==1)
	{
		G[0]=ksm(F[0],mod-2);
		return;
	}
	Inv(F,G,(nm+1)>>1);
	lim=1,fre=0;
	for(;lim<(nm<<1);lim<<=1)++fre;
	for(int i=0;i<=lim;++i)id[i]=(id[i>>1]>>1)|((i&1)<<(fre-1));
	for(int i=0;i<nm;++i)ans[i]=F[i];
	for(int i=nm;i<=lim;++i)ans[i]=0;
	Never_Tell_TLE(ans,1),Never_Tell_TLE(G,1);
	for(int i=0;i<=lim;++i)G[i]=mul(inc(2ll,-mul(ans[i],G[i])+mod),G[i]);
	Never_Tell_TLE(G,-1);
	for(int i=nm;i<=lim;++i)G[i]=0;
}
inline void Mul(ll* F,ll* G,int nm)
{
	lim=1,fre=0;
	for(;lim<(nm<<1);lim<<=1)++fre;
	for(int i=0;i<=lim;++i)id[i]=(id[i>>1]>>1)|((i&1)<<(fre-1));
	int inv_lim=ksm(lim,mod-2);
	Never_Tell_TLE(G,1),Never_Tell_TLE(F,1);
	for(int i=0;i<=lim;++i)G[i]=mul(F[i],G[i]);
	Never_Tell_TLE(G,-1);
}
inline void Integral(ll* F,ll* G,int nm)
{
	for(int i=1;i<nm;++i)
	G[i]=mul(F[i-1],ksm(i,mod-2));
	G[0]=0;
}
inline void Ln(ll* F,ll* G,int nm)
{
	Inv(F,tmp,nm);
	for(int i=0;i<=lim;++i)ans[i]=0;
	Derivation(F,ans,nm);
	Mul(tmp,ans,nm);
	Integral(ans,G,nm);
	for(int i=0;i<=lim;++i)ans[i]=tmp[i]=0;
}
inline void solve(ll* F,ll* G,int nm)
{
	if(nm==1)
	{
		G[0]=1;
		return;
	}
	solve(F,G,(nm+1)>>1);
	lim=1,fre=0;
	for(;lim<(nm<<1);lim<<=1)++fre;
	for(int i=0;i<=lim;++i)id[i]=(id[i>>1]>>1)|((i&1)<<(fre-1));
	for(int i=0;i<=lim;++i)ln[i]=0;
	Ln(G,ln,nm);
	for(int i=0;i<nm;++i)ans[i]=F[i];
	for(int i=nm;i<=lim;++i)ans[i]=0;
	Never_Tell_TLE(ans,1),Never_Tell_TLE(G,1),Never_Tell_TLE(ln,1);
	for(int i=0;i<=lim;++i)G[i]=mul(inc(1ll,inc(ans[i],-ln[i]+mod)),G[i]);
	Never_Tell_TLE(G,-1);
	for(int i=nm;i<=lim;++i)G[i]=0;
}
int main()
{
	n=read();
	for(int i=0;i<n;++i)f[i]=read();
	solve(f,g,n);
	for(int i=0;i<n;++i)printf("%d ",g[i]);
	return 0;
}
```
只求能帮助到几个人罢。。

---

## 作者：ccviolett (赞：3)

前面已经有一个人给出了`任意模数多项式Exp`了，但是跑得比较慢，这里给出一份码风相对鲜明并且速度大概在 4s 左右的代码。

其实任意模数XXX 在面向对象封装好之后，都是很好写的，复用性很高。

不浪费版面，代码在[这里](https://www.luogu.com.cn/paste/vgqacuxr)

---

## 作者：ニヒル (赞：3)

这里有几个前置知识
#### 前置1、泰勒展开与麦克劳林级数
泰勒展开就是用多项式去近似表达一些比较烦的曲线，比如说$sin,cos,e^x$之类的曲线   
这些曲线有着优点，比如说他们可以无限求导  
$sin'(x)=cos(x),cos'(x)=-sin(x)$  
$sin''(x)=-sin(x),sin'''(x)=-cos(x),sin''''(x)=sin(x)$  
$cos''(x)=-cos(x),cos'''(x)=sin(x),cos''''(x)=cos(x)$  
$(e^x)'=e^x,(e^x)''=e^x......$  
我们要求近似，那么就要做到这两个函数尽可能一样  
什么叫一样？  
我们要求它要满足$f(x)=g(x)$、$f'(x)=g'(x)$、$f''(x)=g''(x)$……  
那么我们来看多项式长啥样吧  
假设$f(x)=a_0+a_1x+a_2x^2+......+a_nx^n$  
$g(x)=e^x$  
我们要满足  
$f(x)=g(x),a_1+2a_2+...na_n=e^x,2a_2+6a_3+...n(n-1)a_n=e^x......$  
嗯，自闭了，这样算下去算不出来的，我们直接求n阶导看看  
$n!a_n=e^x$   
我们令$x=0$，此时$a_n=\frac{1}{n!}$    
代入$\frac{(n-1)!}{2}a_{n-1}x^{n-1}+\frac{n!}{2}a_nx^n=e^x$  
则$a_{n-1}=\frac{1}{(n-1)!}$  
所以以此类推$a_i=\frac{1}{i!}$  
我们可以得出$g(x)=e^x$的近似多项式   
$f(x)=\sum_{i=0}^n\frac{x^i}{i!}$  
那么显然可以这个求n阶导的思路是普适的   
我们可以推广出一个通式  
$g(x)=1+\sum_{i=1}^{n}\frac{f^{(i)}(0)}{i!}x^i$  
这是泰勒展开的一个特殊形式(x=0)，也叫作麦克劳林级数 
真正的泰勒展开长这样  
$g(x)=f(x)+\sum_{i=1}^{n}\frac{f^{(i)}(x')}{i!}(x-x')^i$
再给出几个常见的麦克劳林级数  
![](https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D226/sign=79c147be10d5ad6eaef963e8b7ca39a3/eac4b74543a982266426575d8182b9014b90ebe1.jpg)  
  ![](https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D396/sign=57e085b615178a82ca3c79a9c002737f/562c11dfa9ec8a13b6e1289afc03918fa1ecc0d5.jpg)
    
![](https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D374/sign=6cc500b1f0edab6470724bc7c337af81/e824b899a9014c08a6cc56df017b02087af4f4d1.jpg)
![](https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D375/sign=f6079ce807f431adb8d2453e7e37ac0f/e1fe9925bc315c607018129586b1cb134954773e.jpg  )  
![](https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D487/sign=20e43ea4edcd7b89ed6c3b8b38254291/a8773912b31bb0510cfa8d463d7adab44bede086.jpg)   
$o()$是皮亚诺余项，反正就是$n+1->\infty$的部分

#### 前置2、牛顿迭代
普通牛顿迭代多用于求函数的零点，假设有一个函数$f(x)$，我们已经随便选了一个点x’  
显然根据泰勒展开，$f(x)=f(x')+f'(x')(x-x')+\frac{f''(x')(x-x')^2}{2}+...$  
emmm，这玩意不一定支持连续求导，而且非线性不好拆，我们就把前两个拿下来就行了  
$f(x)=f(x')+f'(x')(x-x')+o(2)$   
我们要找零点  
$f(x')+f(x')(x-x')=0$  
$x=x'-\frac{f(x)}{f'(x)}$  
因为泰勒展开是渐进的，所以肯定这个x会不断逼近正解  
  
多项式牛顿迭代面对的问题也差不多   
我们要求多项式复合函数的零点$g(f(x))\equiv0(mod x^n)$  
设$g(f(x'))\equiv0(modx^{\left[ \frac{n}{2}\right]})$  
我们对复合函数泰勒展开    
$g(f(x))=g(f(x'))+g'(f(x'))(f(x)-f(x'))+\frac{g''(f(x'))  (f(x)-f(x'))^2}{2!}+o(3)$  
来看一下这样子保留的精度   
首先根据泰勒展开的性质，我们搞出来的$f(x)$肯定比$f(x')$精度高    
所以$f(x)\equiv0(modx^{\left[ \frac{n}{2}\right]})$     
所以$(f(x)-f(x'))\equiv0(modx^{\left[ \frac{n}{2}\right]})$     
所以$(f(x)-f(x'))^2\equiv0(modx^n)$     
显然之后的更高次都是同理，对n项以内产生不了贡献，也就是我们可以用保留前两项的式子获得双倍的~~快乐~~精度   
也就是可以倍增了  
$g(f(x))=g(f(x'))+g'(f(x'))(f(x)-f(x'))\equiv0(modx^n)$
$f(x)=f(x')-\frac{g(f(x'))}{g'(f(x'))}$  

## 正文
前置知识讲完了，我们解决一下多项式exp  
$g(x)=e^{f(x)}$，两边求个ln  
$ln(g(x))=f(x)$  
$h(x)=ln(g(x))-f(x)=0$  
嘛，求零点的话牛顿迭代一下就可以了  
假设我们求出了$g(x')=e^{f(x)}(modx^{[\frac{n}{2}]})$  
我们来套公式    
$g(x)=g(x')-\frac{h(g(x'))}{h'(g(x'))}$  
$g(x)=g(x')-\frac{ln(g(x'))-f(x')}{\frac{1}{g(x')}}$    （因为h(x)随着g(x)变化，和f(x)无关？）  
$g(x)=g(x'){(1-ln(g(x'))+f(x'))}$  

根据这个式子就可以求exp了  
代码如下：
```cpp
#include<bits/stdc++.h>
#define mod 998244353
#define gg 3
using namespace std;

int r[400040],n;
long long inv[400040],tmp1[400040],tmp2[400040],tmp3[400040],ln[400040],f[400040],de[400040],in[400040],ex[400040]; 

long long kasumi(long long a,long long b)
{
    long long ans=1;
    while(b)
    {
        if(b&1) ans=ans*a%mod;
        a=a*a%mod;
        b>>=1; 
    }
    return ans;
}

void NTT(long long *a,int kd,int cnt)
{
    int lim=1<<cnt;
    for(int i=0;i<lim;i++)
    {
        if(i<r[i]) swap(a[i],a[r[i]]);
    }
    for(int mid=1;mid<lim;mid<<=1)
    {
        long long wn=kasumi(gg,(mod-1)/(mid<<1));
        if(kd) wn=kasumi(wn,mod-2);
        for(int i=0;i<lim;i+=(mid<<1))
        {
            long long w=1;
            for(int j=0;j<mid;j++,w=w*wn%mod)
            {
                long long x=a[i+j];
                long long y=a[i+j+mid]*w%mod;
                a[i+j]=(x+y)%mod;
                a[i+j+mid]=(x-y+mod)%mod;
            }
        }
    }
    if(kd)
    {
        long long invl=kasumi(lim,mod-2);
        for(int i=0;i<lim;i++)
        {
            a[i]=a[i]*invl%mod; 
        }
    }
}

void rev(int cnt)
{
    int lim=1<<cnt;
    for(int i=0;i<lim;i++)
    {
        r[i]=(r[i>>1]>>1)|((i&1)<<(cnt-1));
    }
}

void der(const long long *a,int cnt)
{
    int lim=1<<cnt;
    for(int i=0;i<lim;i++)
    {
        de[i]=a[i+1]*(i+1)%mod;
    } 
}

void inte(const long long *a,int cnt)
{
    int lim=1<<cnt;
    for(int i=lim-1;i>=1;i--)
    {
        in[i]=a[i-1]*kasumi(i,mod-2)%mod;
    }
}

void get_inv(const long long *a,int len)
{

    int cnt=0;
    for(int i=0;i<len;i++) tmp1[i]=tmp2[i]=inv[i]=0;
    inv[0]=kasumi(a[0],mod-2);
    int lim=1;
    while(lim<len)
    {
        cnt++;
        rev(cnt);
        lim<<=1;
        for(int i=0;i<lim>>1;i++)
        {
            tmp1[i]=inv[i];
            tmp2[i]=a[i];
        }
        NTT(tmp1,0,cnt);NTT(tmp2,0,cnt);
        for(int i=0;i<lim;i++)
        {
            tmp1[i]=(tmp1[i]*2ll%mod-tmp2[i]*tmp1[i]%mod*tmp1[i]%mod+mod)%mod;
        }
        NTT(tmp1,1,cnt);
        for(int i=0;i<lim>>1;i++)
        {
            inv[i]=tmp1[i];
        }
    }
}

void get_ln(const long long *a,int len)
{
    int lim=1,cnt=0;
    while(lim<len) lim<<=1,cnt++;
    get_inv(a,lim);
    der(a,cnt);
    NTT(inv,0,cnt); NTT(de,0,cnt);
    for(int i=0;i<lim;i++) ln[i]=inv[i]*de[i]%mod;
    NTT(ln,1,cnt);
    inte(ln,cnt);
}

void get_exp(const long long *a,int len)
{
    int cnt=1,lim=2;
    ex[0]=1;
    while(lim<len)
    {
        cnt++;
        lim<<=1;    
        get_ln(ex,lim);
        in[0]=0;
        in[0]=(in[0]-1+mod)%mod;
        for(int i=0;i<lim>>1;i++)
        {
            tmp1[i]=a[i];
            tmp2[i]=mod-in[i];
            tmp3[i]=ex[i];
        }
        for(int i=lim>>1;i<lim;i++) tmp1[i]=tmp2[i]=tmp3[i]=0;
        NTT(tmp3,0,cnt);NTT(tmp1,0,cnt);NTT(tmp2,0,cnt);
        for(int i=0;i<lim;i++)
        {   
            tmp3[i]=tmp3[i]*((tmp2[i]+tmp1[i])%mod)%mod;
        }
        NTT(tmp3,1,cnt);
        for(int i=0;i<lim>>1;i++)
        {
            ex[i]=tmp3[i];
        }
    }
}

int main()
{
    scanf("%d",&n);
    for(int i=0;i<n;i++)
    {
        scanf("%lld",&f[i]);
    } 
    get_exp(f,n*2);
    for(int i=0;i<n;i++) printf("%lld ",ex[i]);
}
```

话说这题为什么要卡常数啊……感觉时间很宽裕的说

---

## 作者：Convergent_Series (赞：2)

### 牛顿迭代

用于求解函数零点的近似值。

设函数 $f(x)$ 的零点近似值为 $x_0$，过点 $(x_0,f(x_0))$ 作 $f(x)$ 的切线，切线与 $x$ 轴交点的横坐标即为新的近似值。

切线解析式为 $y=f'(x_0)(x-x_0)+f(x_0)$，当 $y=0$ 时 $x=x_0-\dfrac{f(x_0)}{f'(x_0)}$。

同理，若要求满足 $G(F(x))=0$ 的多项式 $F(x)$，则 $F(x)=F_0(x)-\dfrac{G(F_0(x))}{G'(F_0(x))}$。

### 多项式 exp

$$F(x)\equiv e^{A(x)}\pmod{x^n}$$

两边求对数后移项得

$$\ln F(x)-A(x)\equiv 0\pmod{x^n}$$

令 $G(F(x))=\ln F(x)-A(x)$，求 $e^{A(x)}$ 即为求 $G(F(x))$ 的零点。

代入牛顿迭代的式子：

$$F(x)=F_0(x)-\dfrac{\ln F_0(x)-A(x)}{G'(F_0(x))}$$

将 $G(F(x))$ 中的 $F(x)$ 看作变量，$A(x)$ 看作常数，可得 $G'(F(x))=\dfrac{1}{F(x)}$，代入得

$$F(x)=F_0(x)(1-\ln F_0(x)+A(x))$$

因为每次迭代精度翻倍，所以令初始值 $F_0(x)=e^0=1$，倍增求解即可。

时间复杂度 $O(n\log n)$。

### 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define clr(f,n) memset(f,0,sizeof(int)*(n))
#define cpy(f,g,n) memcpy(f,g,sizeof(int)*(n))
#define bceil(n) (1<<(__lg(n-1)+1))
using namespace std;
int read(){
	int a=0;char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9') a=(a<<3)+(a<<1)+(ch^'0'),ch=getchar();
	return a;
} 
void write(int a){
	if(a>9) write(a/10); 
	putchar(a%10+'0');
}
const int MAXN=1e6+10,P=998244353,G=3,Gi=332748118,Img=86583718;
int l,r[MAXN],inv[MAXN],sav[MAXN<<1];
ll qpow(ll a,ll b=P-2){
	if(a==1) return 1;
	ll ans=1;
	while(b){if(b&1) ans=ans*a%P;a=a*a%P;b>>=1;}
	return ans;
}
void tpre(int lim){
    if(l==lim) return;l=lim;
    for(int i=0;i<lim;i++) r[i]=(r[i>>1]>>1)|((i&1)?lim>>1:0);
}
void px(int *A,int *B,int n){for(int i=0;i<n;i++) A[i]=1ll*A[i]*B[i]%P;} 
void NTT(int *A,int lim,int type){
	tpre(lim);
	static ull f[MAXN<<1],w[MAXN];w[0]=1;
	for(int i=0;i<lim;i++) f[i]=(((ll)P<<5)+A[r[i]])%P;
	for(int mid=1;mid<lim;mid<<=1){
		ull Wn=qpow(type+1?G:Gi,(P-1)/(mid+mid));
		for(int i=1;i<mid;i++)w[i]=w[i-1]*Wn%P;
		for(int j=0;j<lim;j+=mid+mid){
			for(int k=0;k<mid;k++){
				int x=w[k]*f[j|mid|k]%P;
				f[j|mid|k]=f[j|k]+P-x;
				f[j|k]+=x;
			}   
		}if(mid==(1<<10)){for(int i=0;i<lim;i++) f[i]%=P;}
	}if(type-1){
		ull inv=qpow(lim);
		for(int i=0;i<lim;i++) A[i]=f[i]%P*inv%P;
	}else for(int i=0;i<lim;i++) A[i]=f[i]%P;
}
void mul(int *A,int *B,int la,int lb){//乘法 
	int lim=bceil(la+la);
	cpy(sav,B,lim);clr(sav+la,lim-la);
    NTT(A,lim,1);NTT(sav,lim,1);
    px(A,sav,lim);NTT(A,lim,-1);
    clr(A+lb,lim-lb);clr(sav,lim);
} 
void invp(int *A,int lim){//逆元 
	int n=bceil(lim);
	static int w[MAXN<<1],r[MAXN<<1];
	w[0]=qpow(A[0]);
	for (int ln=2;ln<=n;ln<<=1){
		for(int i=0;i<(ln>>1);i++) r[i]=w[i];
		cpy(sav,A,ln);NTT(sav,ln,1);NTT(r,ln,1);px(r,sav,ln);
		NTT(r,ln,-1);clr(r,ln>>1);cpy(sav,w,ln);NTT(sav,ln,1);
	    NTT(r,ln,1);px(r,sav,ln);NTT(r,ln,-1);
	    for(int i=ln>>1;i<ln;i++) w[i]=(w[i]*2ll-r[i]+P)%P;
	}cpy(A,w,lim);clr(sav,n);clr(w,n);clr(r,n);
}
void dao(int *A,int lim){//导数 
	for(int i=1;i<lim;i++) A[i-1]=1ll*A[i]*i%P;
	A[lim-1]=0;
}
void inv_init(int lim){
	inv[1]=1;
	for(int i=2;i<=lim;i++) inv[i]=1ll*inv[P%i]*(P-P/i)%P;
}
void jifen(int *A,int lim){//积分 
	for(int i=lim;i;i--) A[i]=1ll*A[i-1]*inv[i]%P;
	A[0]=0;
}
void lnp(int *A,int lim){//ln 
	static int w[MAXN<<1];
	cpy(w,A,lim);
	invp(w,lim);dao(A,lim);
	mul(A,w,lim,lim);
	jifen(A,lim-1);
	clr(w,lim);
}
void exp(int *A,int lim){//exp
	static int s[MAXN<<1],s2[MAXN<<1];
	int n=bceil(lim);
	s2[0]=1;
	for(int ln=2;ln<=n;ln<<=1){
		cpy(s,s2,ln>>1);lnp(s,ln);
		for(int i=0;i<ln;i++) s[i]=(A[i]-s[i]+P)%P;
		s[0]=(s[0]+1)%P;
		mul(s2,s,ln,ln);
	}cpy(A,s2,lim);clr(s,n);clr(s2,n);
}
int n,a[MAXN];
int main(){
     n=read();
    inv_init(n);
    for(int i=0;i<n;i++) a[i]=read();
	exp(a,n);
    for(int i=0;i<n;i++){write(a[i]);putchar(' ');} 
    return 0;
}
```

---

## 作者：qwq自动机 (赞：2)

多项式指数函数（$\exp$）模板。

## 前置知识
[多项式 $\ln$](https://www.luogu.com.cn/problem/P4725)、[多项式乘法逆](https://www.luogu.com.cn/problem/P4238)、牛顿迭代。

这里也简要讲一讲这些。

### 1. 多项式 $\ln$

定义略。讲讲求法。

我们知道，$\ln x$ 的导数是 $\dfrac 1x$，即 $\dfrac{\text d}{\text dx}\ln x=\dfrac 1x$。

那么我们就可以由复合函数求导法则（$\dfrac{\text df}{\text dx}=\dfrac{\text df}{\text du}\cdot \dfrac{\text du}{\text dx}$）得到：

$\dfrac{\text d}{\text dx}\ln A(x)=\dfrac 1{A(x)}\cdot\dfrac{\text d}{\text dx}A(x)={A^\prime(x)}\cdot{A^{-1}(x)}$。

所以对于求 $\ln$，只需要一个求导、一个求逆、一个积分就好了。

### 2. 多项式乘法逆

一般使用倍增。这里直接给出倍增式（推导过程去模板题题解区，设 $F(x)\cdot G(x)\equiv1\pmod {\text{给定模数}}$）：

$$G(x)=2G^\ast(x)-F(x)\cdot {G^\ast}^2(x)$$

其中 $G^\ast(x)$ 为已经推出的式子前 $n$ 项，且 $G$ 的常数项为 $F$ 常数项的逆元。

### 3. 牛顿迭代

对于一个方程 $f(x)=0$，为了求得一个根，可以从一个初始点 $(x_0,f(x_0))$ 开始，每次作过这个点的切线，取切线与 $x$ 轴交点的 $x$ 为下一次迭代的 $x_0$，就可以不断逼近所求的根。那么我们就可以推导出迭代式：

$$x_{n+1}=x_n-\dfrac{f(x_n)}{f^\prime(x_n)}$$

这样从 $x_0$ 开始，经过一定次数的迭代就可以得到一个满足要求精度的根。这种方法就叫牛顿迭代。

同样的，对于多项式我们也可以进行这样的迭代。若要求解方程 $G(F(x))=0$，则有迭代式：

$$F_{n+1}(x)=F_n(x)-\dfrac{G(F(x))}{G^\prime(F(x))}$$

这样，我们从一个初值 $F_0(x)$ 开始，一次次迭代就能得到我们所需要的 $F(x)$。可以证明一次迭代后精度会翻倍，所以根据这条倍增即可。

## 多项式 $\exp$

### 推导：

我们知道，$\exp$ 和 $\ln$ 互为逆运算。设 $B(x)=\exp(A(x))=e^{A(x)}$，那么可以列出方程：

$$\ln B(x)-A(x)=0$$

令 $G(F(x))=\ln F(x)-A(x)$，那么我们可以根据牛顿迭代得出倍增式：

$$
\begin{array}{ll}
B_{n+1}(x)&=B_n(x)-\dfrac{G(B_n(x))}{G^\prime(B_n(x))}\\
&=B_n(x)-\dfrac{\ln B_n(x)-A(x)}{\dfrac 1{B_n(x)}}\\
&=B_n(x)\cdot(1-\ln B_n(x)+A(x))
\end{array}
$$

代入初值 $B_0(x)=e^{A_0}$（其中 $A_0$ 为 $A$ 的常数项）即可。由于题目保证 $A_0=0$，我们可以直接令 $B_0(x)=1$。当然，并不是说 $A_0\neq 0$ 就不存在 $\exp$，而是因为我们在模意义下不容易找到这么一个 $e^{A_0}$。

既然上面的初值和倍增式都确定了，就可以直接按照上面的倍增。左转右转把 $\ln$ 和 NTT/FFT 的模板扒过来就可以了。注意清零！

### 代码

这里给出 NTT 迭代的。

```cpp
#include <iostream>
#include <cstring>
const int MAXN = 100010;
const int MOD = 998244353, G = 3, InvG = 332748118; // 模数，原根，原根逆元
using ll = long long;
ll inv[MAXN << 2]; // 预处理逆元表
ll qpow(ll b, ll p = MOD - 2) // 快速幂
{
    ll ans = 1;
    while (p)
    {
        if (p & 1)
            (ans *= b) %= MOD;
        (b *= b) %= MOD;
        p >>= 1;
    }
    return ans;
}
void NTT(ll *f, int n, bool inv = false) // 迭代 NTT
{
    static int tr[MAXN << 2] = {0};
    for (int i = 0; i < n; i++)
        tr[i] = (tr[i >> 1] >> 1) | (i & 1 ? n >> 1 : 0);
    for (int i = 0; i < n; i++)
        if (i < tr[i])
            std::swap(f[i], f[tr[i]]);
    for (int l = 2; l <= n; l <<= 1)
    {
        ll root = qpow(inv ? InvG : G, (MOD - 1) / l);
        for (int k = 0; k < n; k += l)
        {
            ll cur = 1;
            for (int i = k; i < k + (l >> 1); i++)
            {
                ll qwq = f[i + (l >> 1)] * cur % MOD;
                f[i + (l >> 1)] = f[i] - qwq;
                if (f[i + (l >> 1)] < 0)
                    f[i + (l >> 1)] += MOD;
                f[i] += qwq;
                if (f[i] >= MOD)
                    f[i] -= MOD;
                (cur *= root) %= MOD;
            }
        }
    }
    if (inv)
    {
        ll invn = qpow(n);
        for (int i = 0; i < n; i++)
            (f[i] *= invn) %= MOD;
    }
}
void Inv(ll *f, ll *r, int n) // 多项式逆
{
    static ll tmp[MAXN << 2], tmpf[MAXN << 2];
    memset(tmp, 0, sizeof(tmp));
    memset(tmpf, 0, sizeof(tmpf));
    r[0] = qpow(f[0]);
    for (int l = 2; l <= n; l <<= 1)
    {
        for (int i = 0; i < l; i++)
            tmp[i] = r[i], tmpf[i] = f[i];
        for (int i = l; i < l << 1; i++)
            tmp[i] = tmpf[i] = 0;
        NTT(tmp, l << 1);
        NTT(tmpf, l << 1);
        for (int i = 0; i < l << 1; i++)
            tmp[i] = (2 - tmp[i] * tmpf[i] % MOD + MOD) % MOD * tmp[i] % MOD;
        NTT(tmp, l << 1, 1);
        for (int i = 0; i < l; i++)
            r[i] = tmp[i];
    }
}
void Directive(ll *f, int n) // 求导
{
    for (int i = 1; i < n; i++)
        f[i - 1] = f[i] * i % MOD;
    f[n - 1] = 0;
}
void Intergral(ll *f, int n) // 积分
{
    for (int i = n; i; i--)
        f[i] = f[i - 1] * inv[i] % MOD;
    f[0] = 0;
}
void Ln(ll *f, int n) // 多项式 ln
{
    static ll res[MAXN << 2];
    memset(res, 0, sizeof(res));
    Inv(f, res, n);
    Directive(f, n);
    NTT(f, n << 1);
    NTT(res, n << 1);
    for (int i = 0; i < n << 1; i++)
        (f[i] *= res[i]) %= MOD;
    NTT(f, n << 1, 1);
    Intergral(f, n << 1);
    for (int i = n; i < n << 1; i++)
        f[i] = 0; // 注意清零！
}
void pExp(ll *f, ll *res, int n) // exp
{
    static ll tmpf[MAXN << 2], tmpln[MAXN << 2], tmpr[MAXN << 2];
    res[0] = 1; // 直接令常数项为 1
    for (int l = 2; l <= n; l <<= 1)
    {
        for (int i = 0; i < l; i++)
            tmpf[i] = f[i], tmpln[i] = tmpr[i] = res[i];
        for (int i = l; i < l << 1; i++)
            tmpf[i] = tmpln[i] = tmpr[i] = 0;
        Ln(tmpln, l); // 求 ln。注意长度！（因为这个我卡了两天 w）
        NTT(tmpln, l << 1);
        NTT(tmpf, l << 1);
        NTT(tmpr, l << 1);
        // 倍增，B = B * (1 - ln(B) + A(x))
        for (int i = 0; i < l << 1; i++)
            (tmpr[i] *= (1 - tmpln[i] % MOD + MOD + tmpf[i] % MOD) % MOD) %= MOD; 
        NTT(tmpr, l << 1, true);
        for (int i = 0; i < l; i++)
            res[i] = tmpr[i];
        for (int i = l; i < l << 1; i++)
            res[i] = 0; // 注意清零！
    }
}
ll f[MAXN << 2], res[MAXN << 2];
int main()
{
    int n;
    std::cin >> n;
    for (int i = 0; i < n; i++)
        std::cin >> f[i];
    int lim = 1;
    while (lim < n)
        lim <<= 1;
    inv[1] = 1;
    for (int i = 2; i <= n; i++)
        inv[i] = MOD - ((MOD / i) * inv[MOD % i]) % MOD;
    pExp(f, res, lim);
    for (int i = 0; i < n; i++)
        std::cout << res[i] << " ";
    std::cout << std::endl; // 结尾换行好习惯（
    return 0;
}
```

1.6s，不算很快，但是也还能说得过去。

---


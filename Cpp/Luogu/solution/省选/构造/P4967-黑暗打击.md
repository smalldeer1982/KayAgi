# 黑暗打击

## 题目背景

注，此题和 CQOI 的鼹鼠不一样，请仔细看题！本题只是借用背景！

在茫茫宇宙中……

## 题目描述

有一群生物 ccj，他们在上次的星系中，发现了一群低等生物，于是想进行一波黑暗森林打击。这群低等生物即是 $\mathsf{Hilbert}$ 鼹鼠，生活在 $\mathsf{Hilbert}$ 星球，住在 $\mathsf{Hilbert}$ 曲线土壤内。  
这群生物决定用最傻的办法——灌水，来淹死他们。现在“高等”生物想知道，对于 $n$ 阶的 $\mathsf{Hilbert}$ 曲线，从上往下灌水，能淹没几个单位面积？

这是 $1 \sim 4$ 阶的 $\mathsf{Hilbert}$ 曲线：  

![](https://cdn.luogu.com.cn/upload/pic/28912.png)

$h_1$，如最左图所示，是一个缺上口的正方形，这个正方形的边长为 $1$。 从$h_2$ 开始，按照以下方法构造曲线 $h_i$： 将 $h_{i-1}$ 复制四份，按 $2\times2$ 摆放。  
把左上一份逆时针转 $90^{\circ }$，右上一份顺时针转 $90^{\circ }$，然后用三条单位线段将四分曲线按照左上-左下-右下-右上的顺序连接起来。如图所示，分别展示的是 $h_2$，$h_3$，$h_4$。加粗的线段是额外用于连接的线段。

灌水方式：

（显然这个是 $h_3$ 的灌水面积）绿色即为无法被灌到的地方，红色为可以灌到的地方，灰色为墙，所以答案是 $26$，即为样例1。

![](https://cdn.luogu.com.cn/upload/pic/40229.png)

一个方格有水当且仅当在它的上，左，右方格中有至少一个方格有水，最上面一层的空格都有水。

注，此题要求对 $9223372036854775783$ 取模

## 说明/提示

**样例解释：**

自己数一数嘛……

$n \le 10^{10000}$

详细范围参见“标程”

数据均为手动构造，请注意常数！

## 样例 #1

### 输入

```
3
```

### 输出

```
26
```

## 样例 #2

### 输入

```
4
```

### 输出

```
100
```

## 样例 #3

### 输入

```
12```

### 输出

```
2137408```

# 题解

## 作者：Hope2075 (赞：6)

下面的题解需要参考这张图

![](https://cdn.luogu.com.cn/upload/pic/42006.png)

（红色部分为有水的格子，最大的那个还没染色，可能有点小错误）

考虑推式子

如果只记录上一个的值a，会发现无法推出下一个式子

然后考虑记录其它信息

考虑把曲线横过来再灌水，（黄色部分）

这样能维护另一个序列b

然后发现可以根据a和b推出下一组a和b

$a_n=2a_{n-1}+2b_{n-1}+3\cdot 2^{n-1}-2$

$b_n=a_{n-1}+2b_{n-1}+2^{n-1}-1$


upd:时限改小，直接十进制矩阵快速幂过不了

于是我用了点~~奇技淫巧~~（

~~强行~~求通项公式

$a_n=2a_{n-1}+2b_{n-1}+3\cdot 2^{n-1}-2$

$b_n=a_{n-1}+2b_{n-1}+2^{n-1}-1$

直接相减，可以得到：

$a_n-b_n=a_{n-1}+2^{n}-1$

然后可以把$b_n$用$a_n$表示出来

$b_n=a_n-a_{n-1}-2^{n}+1$

也就是

$b_{n-1}=a_{n-1}-a_{n-2}-2^{n-1}+1$

代入以消掉$b_{n-1}$

$a_n=4a_{n-1}-2a_{n-2}+2^{n-1}$

然后变换一下

$a_n+2^n=4a_{n-1}+4\cdot 2^{n-1}-2a_{n-2}-2\cdot 2^{n-2}$

记$f_n=a_n+2^n$

则有

$f_n=4f_{n-1}-2f_{n-2}$

这时候也可以用矩阵快速幂求，但是还可以继续搞

可以用生成函数求出$f_n$，进而求出$a_n$

得到的结果：

$a_n=\frac{(2+\sqrt{2})^{n+1}}{4}+\frac{(2-\sqrt{2})^{n+1}}{4}-2^n$

这样，可以手写带$\sqrt{2}$的类来求

然而，还没有结束

如果能找到$\sqrt{2}$在模意义下的值，那么普通快速幂即可

但是这个值不一定存在

可以用欧拉判别式判断，用Cipolla算法求出值

关于这两个请自行查找资料学习

于是我就写了以下代码

```cpp
#include<iostream>
using namespace std;
#define u64 unsigned long long
const u64 M=9223372036854775783LL;
u64 mup(u64 a,u64 b){
    u64 ans=0;
    while(b){
    	if(b&1){
    		ans+=a;
    		if(ans>=M)ans-=M;
    	}
    	b>>=1;
    	a+=a;
    	if(a>=M)a-=M;
    }
    return ans;
}
u64 fpow(u64 a,u64 b){
	u64 ans=1;
    while(b){
    	if(b&1)ans=mup(ans,a);
    	b>>=1;
    	a=mup(a,a);
    }
    return ans;
}
bool check(u64 num){
	return fpow(num,(M-1)/2)==1;
}
const u64 N=4*4-2;
struct qwq{
	u64 q;
	u64 r;
};
qwq operator*(qwq a,qwq b){
	qwq ans;
	ans.q=mup(a.q,b.q)+mup(mup(a.r,N),b.r);
	if(ans.q>=M)ans.q-=M;
	ans.r=mup(a.q,b.r)+mup(a.r,b.q);
	if(ans.r>=M)ans.r-=M;
	return ans;
}
qwq fpow(qwq a,u64 n){
	qwq ans=(qwq){1,0};
    while(n){
    	if(n&1)ans=ans*a;
    	n>>=1;
    	a=a*a;
    }
    return ans;
}
qwq res;
int main(){
	cout<<check(4*4-2)<<endl;
	res=fpow((qwq){4,1},(M+1)/2);
	cout<<res.q<<" "<<M-res.q<<endl;
	cout<<fpow(res.q,2uLL)<<endl;
	cout<<fpow(M-res.q,2uLL)<<endl;
	cout<<fpow(4,M-2)<<endl;
}
//5534023222971858929
//3689348813882916854
```
最后发现$\sqrt{2}$有这个模数意义下的值，求出了这两个值，并捎带求出了4的逆元

于是就可以做了

根据费马定理，可以在输入的时候取模进行优化

最终代码：

```cpp
#include<cstdio>
#define u64 unsigned long long
const u64 M=9223372036854775783LL;
const u64 N1=5534023222971858929LL;
const u64 N2=3689348813882916854LL;
const u64 A=2305843009213693946LL;
u64 read(){
	u64 ans=0;
	u64 tmp;
	char c=getchar();
	while(c>='0'&&c<='9'){
		tmp=ans+ans;
		if(tmp>=M-1)tmp-=M-1;
		ans=tmp;
		tmp=tmp+tmp;
		if(tmp>=M-1)tmp-=M-1;
		tmp=tmp+tmp;
		if(tmp>=M-1)tmp-=M-1;
		ans=ans+tmp;
		if(ans>=M-1)ans-=M-1;
		ans=ans+c-'0';
		if(ans>=M-1)ans-=M-1;
		c=getchar();
	}
	return ans;
}
char res[25];
void write(u64 ans){
	if(ans==0){putchar('0');return;}
	int t=0;
	while(ans){res[t++]=ans%10+'0';ans/=10;}
	while(t--)putchar(res[t]);
}
u64 mup(u64 a,u64 b){
    u64 ans=0;
    while(b){
    	if(b&1){
    		ans+=a;
    		if(ans>=M)ans-=M;
    	}
    	b>>=1;
    	a+=a;
    	if(a>=M)a-=M;
    }
    return ans;
}
u64 fpow(u64 a,u64 b){
	u64 ans=1;
    while(b){
    	if(b&1)ans=mup(ans,a);
    	b>>=1;
    	a=mup(a,a);
    }
    return ans;
}
int main(){
	u64 num=read();
	u64 n1=mup(fpow(2+N1,num+1),A);
	u64 n2=mup(fpow(2+N2,num+1),A);
	u64 n3=M-fpow(2,num);
	u64 ans=n1;
	ans+=n2;
	if(ans>=M)ans-=M;
	ans+=n3;
	if(ans>=M)ans-=M;
	write(ans);
}
```

目前为止最优解，[24ms](https://www.luogu.org/recordnew/show/19823218)

---

## 作者：PrincessQi (赞：1)

设 $n$ 阶图形灌水面积为 $a_n$，$n$ 阶图形旋转 $90^\circ$ 的灌水面积为 $b_n$。

![](https://cdn.luogu.com.cn/upload/image_hosting/bmyzs1jv.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/uaoc4vds.png)

根据上图，则有 

$$a_n=2a_{n-1}+2b_{n-1}+2^n-1+2^{n-1}-1$$

$$b_n=a_{n-1}+2b_{n-1}+2^{n-1}-1$$

两式相减，得

$$a_n-b_n=a_{n-1}+2^n-1$$

稍微变形，得

$$a_{n-1}-a_{n-2}-2^{n-1}+1=b_{n-1}$$

带回原式，得

$$a_n=4a_{n-1}-2a_{n-2}+2^{n-1}$$

稍微变形，得

$$a_n+2^n=4(a_{n-1}+2^{n-1})-2(a_{n-2}+2^{n-2})$$

设 $f_n=a_n+2^n$，则有

$$f_n=4f_{n-1}-2f_{n-2}$$

Sol 1：

根据二阶线性递推序列通项公式，有

$$f_n=(\frac32-\sqrt2)(2-\sqrt2)^{n-1}+(\frac32+\sqrt2)(2+\sqrt2)^{n-1}$$

则 

$$a_n=(\frac32-\sqrt2)(2-\sqrt2)^{n-1}+(\frac32+\sqrt2)(2+\sqrt2)^{n-1}-2^n$$

利用 Cipolla 算法求出模意义下的 $\sqrt2$ 即可。

Sol 2：

事实上，看到 $f_n=4f_{n-1}-2f_{n-2}$，你就可以利用判别式 $p^2+4q$ 发现需要模意义下的 $\sqrt2$，而且，根据欧拉准则，$2$ 是题目给定的模数的二次剩余。

所以，根据费马小定理和二阶线性递推序列通项公式的形式不难得到

$$f_n=f_{n\mod(p-1)}$$

矩阵快速幂即可。

---

对于一个二阶线性递推序列，若判别式是二次剩余，则可以直接使用扩展欧拉定理+矩阵快速幂。

若判别式不是二次剩余，则参考 P4000。

---

## 作者：Purslane (赞：0)

# Solution

简单数学题。不过有一个很坑的地方——一个位置可以灌水当且仅当存在一条**从它到上方开阔地区的连通路径，满足深度严格不降，如图所示：**

![](https://s21.ax1x.com/2025/03/25/pEDkfMQ.png)

紫色是一个合法的路径，而蓝色并不是。

有以下的归纳结构，设答案为 $a_n$，把图形分成若干块（不妨设整体为 $n$ 阶 H 曲线）：

![](https://s21.ax1x.com/2025/03/25/pEDk0rd.png)

1. 紫色部分。显然他们都能被灌上水。而这部分总数为 $2^n+2^{n-1}-2$；
2. 下面两个小区域，发现他们能被灌上水（也就是存在合法路径）和小区块内存在合法路径是等价的，所以为 $2a_{n-1}$；
3. 上面两个小区域。发现这个有一点小复杂，因为记录了不太一样的东西（通过 $a$ 无法推出），所以设为 $b$，也就是 $2b_{n-1}$。

也就是

$$
a_n = 2^n+2^{n-1}-2 + 2a_{n-1}+2b_{n-1} (*)
$$

$b$ 的实际含义是，将图形逆时针旋转九十度之后，得到的图形，能从右边或者上边钻出来的个数（仍然通过合法路径连接）。

![](https://s21.ax1x.com/2025/03/25/pEDAAQe.png)

那么得到 $b_n$ 的递推式为：

$$
b_n = 2^{n-1}-1 + a_{n-1} + 2 b_{n-1} (**)
$$

二阶递推！如果你和我一样是文化课选手，应该很容易处理这个式子：

尝试在 $(*)$ 中凑出 $b_{n-1}-2b_{n-2}$ 的形式，也就是

$$
a_n - 2 a_{n-1} = 2 + 2 a_{n-1}-4a_{n-2} + 2b_{n-1} - 4b_{n-2}
$$

而 $b_{n-1}-2b_{n-2} = 2^{n-2} - 1 + a_{n-2}$，所以有

$$
a_n - 2 a_{n-1} = 2 + 2 a_{n-1} - 4a_{n-2} + 2^{n-1}-2 + 2a_{n-2}
$$

即

$$
a_n = 4 a_{n-1} - 2 a_{n-2} + 2^{n-1}
$$

再把后面那个东西消掉：

$$
2a_{n-1} = 8 a_{n-2} - 4 a_{n-3} + 2^{n-1}
$$

所以有

$$
a_n  = 6a_{n-1}-10 a_{n-2} + 4 a_{n-3}
$$

特征方程是 $x^3 - 6x^2 + 10x - 4 =0$，肉眼观察得到根：$2$、$2 \pm \sqrt 2$。

所以 $a_n = A 2^n + B (2 + \sqrt 2)^n + C(2-\sqrt 2)^n$。通过~~翻看题解~~解线性方程组得到

$$
a_n = \dfrac{(2+\sqrt 2)^{n+1} + (2 - \sqrt 2)^{n+1}}{4} - 2^n
$$

通过~~翻看题解~~ Cipolla 得知，$2$ 是模 $9223372036854775783$ 意义下的二次剩余，且一个二次剩余的值为 $5534023222971858929$。所以可以直接将 $n$ 对 $9223372036854775782$ 取模。

复杂度 $O(\log n)$。所以有人要说了，如果不存在二次剩余怎么办？可以扩域，并且能证明周期性仍然存在。

注意这个模数贴近 LONG_LONG_MAX，所以需要精细实现或者直接开 __int128。

```cpp
#include<bits/stdc++.h>
#define Int __int128
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const Int MOD=9223372036854775783,sq=5534023222971858929;
Int qpow(Int base,int p) {
	Int ans=1;
	while(p) {
		if(p%2) ans=ans*base%MOD;
		base=base*base%MOD,p/=2;	
	}
	return ans;
}
string S;
int n,ans;
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>S;
	for(auto ch:S) n=((Int)n*10+ch-'0')%(MOD-1);
	ans=((qpow(2+sq,n+1)+qpow(2-sq,n+1))%MOD*qpow(4,MOD-2)%MOD-qpow(2,n))%MOD;
	cout<<(int)((ans%MOD+MOD)%MOD);
	return 0;
}
```

---

## 作者：cforrest (赞：0)

提供一个好写且不费脑的能过的卡常做法。当然还是建议学习一下正解。

简单地分析题例给的图可以得到
$$\begin{aligned}
x_n&=2x_{n-1}+2y_{n-1}+3(2^{n-1}-1)+1,\\
y_n&=x_{n-1}+2y_{n-1}+(2^{n-1}-1).
\end{aligned}$$
故而设 
$$z_n=2^n-1$$
则有
$$
\left(\begin{matrix}x_n\\y_n\\z_n\end{matrix}\right)=\left(\begin{matrix}2&2&3\\1&2&1\\0&0&2\end{matrix}\right)\left(\begin{matrix}x_{n-1}\\y_{n-1}\\z_{n-1}\end{matrix}\right)+\left(\begin{matrix}1\\0\\1\end{matrix}\right).
$$
初始条件为
$$
\left(\begin{matrix}x_0\\y_0\\z_0\end{matrix}\right)=\left(\begin{matrix}0\\0\\0\end{matrix}\right).
$$
记这个线性变换为 
$$
T:\mathbb F_p^3\rightarrow\mathbb F_p^3,
$$
问题即求
$$
T^n({\bf 0})
$$
的第一个分量。这直接用快速幂求就好。观察到 $n$ 很大，写个大数类，能够完成判零、判奇偶性、减半，即可支持快速幂。

卡常： ```__int128_t``` + 循环展开。再吸口氧，就过了。（其实并没有卡，我本来就打算这么写）

```cpp
#include <iostream>
#include <fstream>
#include <algorithm>
#include <climits>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <utility>
#include <array>
#include <vector>
#include <deque>
#include <list>
#include <stack>
#include <queue>
#include <set>
#include <unordered_set>
#include <map>
#include <unordered_map>
#include <tuple>
#include <bitset>
#include <functional>
#include <numeric>
#include <stdio.h>
#include <random>
using namespace std;
#define fast_io ios::sync_with_stdio(false), cin.tie(nullptr)

constexpr unsigned long long M = 9223372036854775783;

struct Vector {
    unsigned long long vec[3];
    Vector operator+(const Vector& rhs) const {
        return {
            (vec[0]+rhs.vec[0])%M,
            (vec[1]+rhs.vec[1])%M,
            (vec[2]+rhs.vec[2])%M
        };
    }
};

struct Matrix {
    unsigned long long mat[9];
    Matrix operator*(const Matrix& rhs) const {
        return {
            (unsigned long long)(((__uint128_t)mat[0]*rhs.mat[0]+(__uint128_t)mat[1]*rhs.mat[3]+(__uint128_t)mat[2]*rhs.mat[6])%M),
            (unsigned long long)(((__uint128_t)mat[0]*rhs.mat[1]+(__uint128_t)mat[1]*rhs.mat[4]+(__uint128_t)mat[2]*rhs.mat[7])%M),
            (unsigned long long)(((__uint128_t)mat[0]*rhs.mat[2]+(__uint128_t)mat[1]*rhs.mat[5]+(__uint128_t)mat[2]*rhs.mat[8])%M),
            (unsigned long long)(((__uint128_t)mat[3]*rhs.mat[0]+(__uint128_t)mat[4]*rhs.mat[3]+(__uint128_t)mat[5]*rhs.mat[6])%M),
            (unsigned long long)(((__uint128_t)mat[3]*rhs.mat[1]+(__uint128_t)mat[4]*rhs.mat[4]+(__uint128_t)mat[5]*rhs.mat[7])%M),
            (unsigned long long)(((__uint128_t)mat[3]*rhs.mat[2]+(__uint128_t)mat[4]*rhs.mat[5]+(__uint128_t)mat[5]*rhs.mat[8])%M),
            (unsigned long long)(((__uint128_t)mat[6]*rhs.mat[0]+(__uint128_t)mat[7]*rhs.mat[3]+(__uint128_t)mat[8]*rhs.mat[6])%M),
            (unsigned long long)(((__uint128_t)mat[6]*rhs.mat[1]+(__uint128_t)mat[7]*rhs.mat[4]+(__uint128_t)mat[8]*rhs.mat[7])%M),
            (unsigned long long)(((__uint128_t)mat[6]*rhs.mat[2]+(__uint128_t)mat[7]*rhs.mat[5]+(__uint128_t)mat[8]*rhs.mat[8])%M)
        };  
    }
    Vector operator*(const Vector& rhs) const {
        return {
            (unsigned long long)(((__uint128_t)mat[0]*rhs.vec[0]+(__uint128_t)mat[1]*rhs.vec[1]+(__uint128_t)mat[2]*rhs.vec[2])%M),
            (unsigned long long)(((__uint128_t)mat[3]*rhs.vec[0]+(__uint128_t)mat[4]*rhs.vec[1]+(__uint128_t)mat[5]*rhs.vec[2])%M),
            (unsigned long long)(((__uint128_t)mat[6]*rhs.vec[0]+(__uint128_t)mat[7]*rhs.vec[1]+(__uint128_t)mat[8]*rhs.vec[2])%M)
        };
    }
};

struct Operator {
    Matrix A;
    Vector b;
    Operator operator*(const Operator& rhs) const {
        return { A*rhs.A, A*rhs.b+b };
    }
    unsigned long long eval() const {
        return b.vec[0];
    }
};

struct BigNum {
    int m, num[2510];
    BigNum(const string& s): m((s.size()-1)/4+1), num{} {
        int n = s.size();
        for (int i = 0; i<n; ++i) {
            num[(n-i-1)/4] *= 10;
            num[(n-i-1)/4] += s[i]-'0';
        }
    } 
    operator bool() const {
        return m;
    }
    bool is_odd() const {
        return num[0]&1;
    }
    void half() {
        for (int i = m-1, cr = 0; i>=0; --i) {
            num[i] += cr*10000;
            cr = num[i]&1;
            num[i] >>= 1;
        }
        if (!num[m-1]) --m;
    }
};

int main() {
#ifndef ONLINE_JUDGE
    freopen("data.in", "r", stdin);
#endif
    fast_io;
    string s; cin >> s;
    BigNum n(s);
    Operator res{
        (Matrix){ 1, 0, 0, 0, 1, 0, 0, 0, 1 },
        (Vector){ 0, 0, 0 }
    };
    Operator po{
        (Matrix){ 2, 2, 3, 1, 2, 1, 0, 0, 2 },
        (Vector){ 1, 0, 1 }
    };
    while (n) {
        if (n.is_odd()) res = res*po;
        po = po*po;
        n.half();
    }
    printf("%llu", res.eval());
    return 0;
}
```

最大点 70ms 擦线过。

---


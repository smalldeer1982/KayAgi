# 多项式三角函数

## 题目描述

给定一个 $n-1$ 次多项式 $A(x)$，求一个 $\bmod{\:x^n}$ 下的多项式 $F(x)$，满足 $F(x)\equiv\sin{A(x)}$ 或 $F(x)\equiv\cos{A(x)}$。

所有运算在 $\bmod\ 998244353$ 意义下进行。

## 说明/提示

对于 $100\%$ 的数据：$n\leq10^5$，$a_i\in[0,998244352]\cap\mathbb{Z}$。

前 $5$ 个点 $type=0$，后 $5$ 个点 $type=1$。

## 样例 #1

### 输入

```
8 0
0 4 2 6 1 5 3 7```

### 输出

```
0 4 2 332748113 998244338 931694687 998244320 72887640```

## 样例 #2

### 输入

```
8 1
0 4 2 6 1 5 3 7```

### 输出

```
1 0 998244345 998244345 665496220 332748123 44366450 133099314```

# 题解

## 作者：NaCly_Fish (赞：18)


大名鼎鼎的欧拉公式  
$$\text e^{\text ix}=\cos x+ \text i\sin x$$  
把这个式子稍微变形一下   
$$\text e^{-\text ix}=\cos x-\text i\sin x$$   
将这两个式子相加或相减一下，得到
$$2\cos x= \text e^{\text ix}+ \text e^{-\text ix}$$  
$$2\text i\sin x=\text e^{ix}-\text e^{-\text ix}$$  
然后我们移个项，并用 $F(x)$ 代换 $x$，就得出了结果  
$$\cos F(x)=\frac{\text e^{\text iF(x)}+\text e^{-\text iF(x)}}{2}$$  
$$\sin F(x)=\frac{\text e^{\text iF(x)}-\text e^{-\text iF(x)}}{2\text i}$$  
可是这里还有个虚数单位 $\text i$ 呢。。这怎么取模啊 QAQ  
别慌，我们冷静分析一下   
![](https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=305794224,558519052&fm=26&gp=0.jpg)  
虚数单位 $\text i$ 实际上就是 $\omega_4$，也就是 $g^{(p-1)/4}$，在模 $p$ 下就等于 $86583718$。

剩下的，就是套上一个[多项式指数函数](https://www.luogu.org/problemnew/show/P4726)的板子了。  
Code：  
```cpp
#pragma GCC optimize ("unroll-loops")
#pragma GCC optimize (2)
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#define N 262147
#define ll long long
#define reg register
#define p 998244353
#define add(x,y) (x+y>=p?x+y-p:x+y)
#define dec(x,y) (x<y?x-y+p:x-y)
using namespace std;

inline int power(int a,int t){
	int res = 1;
	while(t){
		if(t&1) res = (ll)res*a%p;
		a = (ll)a*a%p;
		t >>= 1; 
	}
	return res;
}

inline void read(int &x){
    x = 0;
    char c = getchar();
    while(c<'0'||c>'9') c = getchar();
    while(c>='0'&&c<='9'){
        x = (x<<3)+(x<<1)+(c^48);
        c = getchar();
    }
}

void print(int x){
    if(x>9) print(x/10);
    putchar(x%10+'0');
}

int rev[N],rt[N],inv[N],inv2[N];
int siz;

void init(int n){
    int w,lim = 1;
    while(lim<=n) lim <<= 1,++siz;
    for(reg int i=1;i!=lim;++i) rev[i] = (rev[i>>1]>>1)|((i&1)<<(siz-1));
    inv2[1] = inv[1] = rt[lim>>1] = 1;
    w = power(114514,(p-1)>>siz); //114514 也是 998244353 的原根
    for(reg int i=(lim>>1)+1;i!=lim;++i) rt[i] = (ll)rt[i-1]*w%p;
    for(reg int i=(lim>>1)-1;i;--i) rt[i] = rt[i<<1];
    for(reg int i=2;i<=n;++i) inv[i] = (ll)(p-p/i)*inv[p%i]%p;
    for(reg int i=1;i<=siz;++i) inv2[1<<i] = p-((p-1)>>i);
}

inline int getlen(int n){
    return 1<<(32-__builtin_clz(n));
}

inline void NTT(int *f,int type,int lim){
    if(type==-1) reverse(f+1,f+lim);
    static unsigned long long a[N];
    reg int x,shift = siz-__builtin_ctz(lim);
    for(reg int i=0;i!=lim;++i) a[rev[i]>>shift] = f[i];
    for(reg int mid=1;mid!=lim;mid<<=1)
    for(reg int j=0;j!=lim;j+=(mid<<1))
    for(reg int k=0;k!=mid;++k){
        x = a[j|k|mid]*rt[mid|k]%p;
        a[j|k|mid] = a[j|k]-x+p;
        a[j|k] += x;
    } 
    for(reg int i=0;i!=lim;++i) f[i] = a[i]%p;
    if(type==1) return;
    x = inv2[lim];
    for(reg int i=0;i!=lim;++i) f[i] = (ll)f[i]*x%p;
}

inline void inverse(const int *f,int n,int *R){
    static int g[N],h[N],s[30];
    memset(g,0,getlen(n<<1)<<2);
    int lim = 1,top = 0;
    while(n){
        s[++top] = n;
        n >>= 1;
    }
    g[0] = power(f[0],p-2);
    while(top--){
        n = s[top+1];
        while(lim<=(n<<1)) lim <<= 1;
        memcpy(h,f,(n+1)<<2);
        memset(h+n+1,0,(lim-n)<<2);
        NTT(g,1,lim),NTT(h,1,lim);
        for(reg int i=0;i!=lim;++i) g[i] = g[i]*(2-(ll)g[i]*h[i]%p+p)%p;
        NTT(g,-1,lim);
        memset(g+n+1,0,(lim-n)<<2);
    }
    memcpy(R,g,(n+1)<<2);
}

inline void log(int *f,int n){
    static int g[N];
    int lim = getlen(n<<1);
    inverse(f,n,g);
    memset(g+n+1,0,(lim-n)<<2);
    for(reg int i=0;i!=n;++i) f[i] = (ll)f[i+1]*(i+1)%p;
    f[n] = 0;
    NTT(f,1,lim),NTT(g,1,lim);
    for(reg int i=0;i!=lim;++i) f[i] = (ll)f[i]*g[i]%p;
    NTT(f,-1,lim);
    for(reg int i=n;i;--i) f[i] = (ll)f[i-1]*inv[i]%p;
    f[0] = 0;
    memset(f+n+1,0,(lim-n)<<2);
}

inline void exp(const int *f,int n,int *R){
    static int g[N],h[N],s[30];
    int lim = 1,top = 0;
    memset(g,0,getlen(n<<1)<<2);
    while(n){
        s[++top] = n;
        n >>= 1;
    }
    g[0] = 1;
    while(top--){
        n = s[top+1];
        while(lim<=(n<<1)) lim <<= 1;
        memcpy(h,g,(n+1)<<2);
        memset(h+n+1,0,(lim-n)<<2);
        log(g,n);
        for(reg int i=0;i<=n;++i) g[i] = dec(f[i],g[i]);
        g[0] = add(g[0],1);
        NTT(g,1,lim),NTT(h,1,lim);
        for(reg int i=0;i!=lim;++i) g[i] = (ll)g[i]*h[i]%p;
        NTT(g,-1,lim);
        memset(g+n+1,0,(lim-n)<<2);
    }
    memcpy(R,g,(n+1)<<2);
}

#define img 86583718

inline void cos(const int *f,int n,int *R){
    static int g[N],h[N];
    for(reg int i=0;i<=n;++i) g[i] = (ll)f[i]*img%p;
    exp(g,n,g);
    inverse(g,n,h);
    for(reg int i=0;i<=n;++i) R[i] = 499122177ll*(g[i]+h[i])%p;
    
}

inline void sin(const int *f,int n,int *R){
    static int g[N],h[N];
    for(reg int i=0;i<=n;++i) g[i] = (ll)f[i]*img%p;
    exp(g,n,g);
    inverse(g,n,h);
    int x = power(img<<1,p-2);
    for(reg int i=0;i<=n;++i) R[i] = (ll)x*(g[i]-h[i]+p)%p;
}

#undef img;

int F[N];
int n,tp;

int main(){
    read(n),read(tp);
    init(n<<1|1);
    for(reg int i=0;i!=n;++i) read(F[i]);
    if(tp==0) sin(F,n-1,F);
    else cos(F,n-1,F);
    for(reg int i=0;i!=n;++i) print(F[i]),putchar(' ');
	return 0;	
}
```


---

## 作者：密期望 (赞：16)

# 想要写代码请先学会[多项式指数函数](https://www.luogu.org/problemnew/show/P4726)(必备前置条件)

### 算法原理:欧拉公式(非必备)

想要弄清楚原理请先了解导数(事实上只需要看得懂怎么**表示**导数就可以了，我把要用到的导数公式都写完了)

不想弄清楚原理或已知道欧拉公式但不知道怎么写代码的（我觉得知道欧拉公式的应该都是复制粘贴以前的代码，然后改一改就秒过了，所以应该不会有这种人来看题解），可以直接跳到结论部分。核心代码极其简单，有了必备前置条件后秒出代码。

**泰勒公式(根据函数$f:\mathbb{R^n} \to \mathbb{R^m}$在$x$处的变化情况近似确定出$f(x+h)$的取值)**

以下内容不区分**泰勒公式，泰勒多项式，泰勒级数**

$f:\mathbb{R^n} \to \mathbb{R^m}$的泰勒公式(用不着，摆出来好看的)

$f(x+h)-f(x)=\sum_{k=1}\dfrac{1}{k!}(h^1\partial_1+h^2\partial_2+...+h^m\partial_m)^kf(x)+R(x)$

**$f:\mathbb{R} \to \mathbb{R}$的泰勒公式**(这里的$x$取上方的$x+h$，$x_0$取上方的$x$,再把$f(x_0)$移过去)

$f(x)=\sum_{k=0}^{n}{\dfrac{f^{(k)}(x_0)}{k!}(x-x_0)^k}+R(x)$

其中$f^{(k)}(x)=\dfrac{d^kf}{dx^k}(x)$表示$f(x)$的$k$阶导函数

即

$f^{(0)}(x)=f(x)$

$f^{(k+1)}(x)=\dfrac{df^{(k)}}{dx}(x)$

这就是我们需要的，你可以把它看做一个凭空捏出来的公式，然后**强行用$R(x)$补上差距**

它有一个显然而美妙的性质：若$\lim_{n \to +\infty} R(x)=0$，则$f(x)=\sum_{k=0}^{+\infty}{\dfrac{f^{(k)}(x_0)}{k!}(x-x_0)^k}$


**$R(x)$为一与$f$和$n$相关的函数，称为余项。** 可证$n \to +\infty$时$e^x,sin(x),cos(x)$的余项$R(x) \to 0$(注意并不是所有函数的都满足$\lim_{n \to +\infty} R(x)=0$，但很巧合的是初等函数类中的函数大多都有这个性质),关于此部分的证明涉及**中值定理**和**极限收敛的判定方法**,较为复杂,故**略过**，详细证明可参见各个版本的《数学分析》或《高等数学》等**有关微积分的书籍**。此公式非常经典，只要是涉及微积分的书应该都会有。高中数学教材《选修2-2》不算关于微积分的书籍，只能叫微积分的科普(虽然我不会做题，但我还是理不直，气也壮地歧视它)。

**又因为三角函数和指数函数的导数**

$\dfrac{dsin(x)}{dx}=cos(x)$

$\dfrac{dcos(x)}{dx}=-sin(x)$

$\dfrac{de^x}{dx}=e^x$

出现周期性，且都在$x_0=0$处有定义，便于计算（$e^0=1,sin(0)=0,cos(0)=1$）

**于是顺理成章地取$x_0=0$，可得三角函数和指数函数的泰勒展开:**

$e^x=\sum_{k=0}^{+\infty}{\dfrac{x^k}{k!}}=1+x+\dfrac{x^2}{2!}+\dfrac{x^3}{3!}+...$(如果要练习使用泰勒公式，那这是最简单的一个)

$sin(x)=\sum_{k=0}^{+\infty}{(-1)^{k}\dfrac{x^{2k+1}}{(2k+1)!}}=x-\dfrac{x^3}{3!}+\dfrac{x^5}{5!}-...$(注意周期$sin(0)=0,cos(0)=1,-sin(0)=0,-cos(0)=-1$)

$cos(x)=\sum_{k=0}^{+\infty}{(-1)^{k}\dfrac{x^{2k}}{2k!}}=1-\dfrac{x^2}{2!}+\dfrac{x^4}{4!}-...$(注意周期$cos(0)=1,-sin(0)=0,-cos(0)=-1,sin(0)=0$)

这三个式子长得特别像，所以我们可以瞎搞一通

(你问我什么叫不像？ $(1+x)^{\alpha}=\sum_{k=0}^{+\infty}{\dfrac{{\alpha}({\alpha}-1)...({\alpha}-(k-1))}{k!}x^k}
=1+{\alpha}x+\dfrac{{\alpha}({\alpha}-1)}{2}x^{2}+\dfrac{{\alpha}({\alpha}-1)({\alpha}-2)}{6}x^3+...$，明白了吧)

**如果存在一个数i满足以下关系式**

$i^2=-1$

$i^3=-i$

$i^4=1$

**那么**

$e^{ix}=1+ix+\dfrac{i^2x^2}{2!}+\dfrac{i^3x^3}{3!}+\dfrac{i^4x^4}{4!}+\dfrac{i^5x^5}{5!}+...$

$e^{ix}=1+ix-\dfrac{x^2}{2!}-i\dfrac{x^3}{3!}+\dfrac{x^4}{4!}+i\dfrac{x^5}{5!}-...$

$e^{ix}=(1-\dfrac{x^2}{2!}+\dfrac{x^4}{4!}-...)+i(x-\dfrac{x^3}{3!}+\dfrac{x^5}{5!}-...)$

于是我们得到了欧拉公式

# $e^{ix}=cos(x)+isin(x)$

将$-x$代入可得

$e^{-ix}=cos(-x)+isin(-x)=cos(x)-isin(x)$

**视$e^{ix},e^{-ix},i$为已知量，解出$sin(x),cos(x)即可$**

# 结论:

### $sin(x)=\dfrac{e^{ix}-e^{-ix}}{2i}$

### $cos(x)=\dfrac{e^{ix}+e^{-ix}}{2}$

**在模意义下取$i=g^{\frac{p-1}{4}}$,$g$为$P$的原根**

在$x \in \mathbb{C}$时我们的代码实际上求得了$sin(A(x)),cos(A(x))$的泰勒多项式的前$n$项(我没有去验证$x_0$的取值,$x_0$不同往往会得到不同的泰勒多项式)，所以多项式三角函数并不是意义不明的。而且大多数情况下泰勒多项式有着极高的收敛速度和精度。(丢人的反例$\dfrac{\pi}{4}=1-\dfrac{1}{3}+\dfrac{1}{5}-...$收敛速度极慢,取个1000项精度不如3.14159)

**以下为核心代码**

```
const int G=3;
const int P=998244353;
polymerization sin(const polymerization &a){
	ll i=pow(G,(P-1)/4);
	polymerization x(a*i);
	return (exp(x)-exp(-x))*pow(2*i%P,P-2);
}
polymerization cos(const polymerization &a){
	ll i=pow(G,(P-1)/4);
	polymerization x(a*i);
	return (exp(x)+exp(-x))*pow(2,P-2);
}
```

**换为以下代码则取模或复数通吃**
```
template < typename T >
polymerization sin(const polymerization &a,T i){
	polymerization x(a*i);
	return (exp(x)-exp(-x))*inverse(2*i);
}
template < typename T >
polymerization cos(const polymerization &a,T i){
	polymerization x(a*i);
	return (exp(x)+exp(-x))*inverse(2);
}
```

[完整代码(洛谷云剪贴板)](https://www.luogu.org/paste/0pa5bfhz)

---

## 作者：Gauss0320 (赞：1)

首先证明一下欧拉公式
$$e^{i\theta}=\cos\theta+i\sin\theta$$
由麦克劳林展开式，我们有
$$e^{x}=\sum_{n=0}^{\infty}\frac{x^n}{n!}$$
指数乘上虚数单位$i$
$$e^{ix}=\sum_{n=0}^{\infty}\frac{(ix)^n}{n!}=\sum_{n=0}^{\infty}(i)^n\frac{x^n}{n!}$$
我们把与$i$有关的放一边，与$i$无关的放一边
$$e^{ix}=\sum_{n=0}^{\infty}\frac{(-1)^nx^{2n}}{(2n)!}+i\sum_{n=0}^{\infty}\frac{(-1)^nx^{2n+1}}{(2n+1)!}$$
发现两边和式正是$\cos$与$\sin$的展开形式，于是有
$$e^{ix}=\cos x+i\sin x\ \ \ \ (1)$$
开始我们的推导
$$e^{i(-x)}=\cos (-x)+i\sin(-x)=\cos x-i\sin\ \ \ (2)$$
$(1)+(2)$，我们有
$$e^{ix}+e^{-ix}=2\cos x$$
$$\cos x=\frac{e^{ix}+e^{-ix}}{2}$$
同理可得
$$\sin x=\frac{e^{ix}-e^{-ix}}{2i}$$
将我们的多项式带入，可得
$$\cos A(x)=\frac{\exp(iA(x))+\exp(-iA(x))}{2}$$
$$\sin A(x)=\frac{\exp(iA(x))-\exp(-iA(x))}{2i}$$
考虑到
$$i^2\equiv -1\pmod{998244353}$$
于是
$$i^2\equiv 998244352\pmod{998244353}$$
做一遍二次剩余，就可以将虚数单位去掉了

代码如下
```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>
typedef long long ll;
const int P = 998244353, N = 262145, g3 = (P + 1) / 3;
const int img = 86583718;
using namespace std;
int n, type, a[N], b[N];

int pow(int a,int b)
{
	int r = 1;
	while(b)
	{
		if(b & 1) r = (ll)r * a % P;
		a = (ll)a * a % P;
		b >>= 1;
	}
	return r;
}
namespace poly
{
    int rev[N];
	void NTT(int *A, int n, int inv) 
	{
		for(int i = 0; i < n; ++i)
			if(i < rev[i]) swap(A[i], A[rev[i]]);
		for(int mid = 1; mid < n; mid <<= 1) 
		{
			int tmp = pow(inv == 1 ? 3 : g3, (P - 1) / (mid << 1));
			for(int j = 0; j < n; j += (mid << 1)) 
			{
				int omega = 1;
				for(int k = 0; k < mid; ++k, omega = (ll)omega * tmp % P) 
				{
					int x = A[j + k], y = (ll)omega * A[j + k + mid] % P;
					A[j + k] = (x + y) % P;
					A[j + k + mid] = (ll)(x - y + P) % P;
				}
			}
		}
		if(inv == 1) return;
		int invn = pow(n, P - 2);
		for(int i = 0; i < n; ++i)
			A[i] = (ll)A[i] * invn % P;
	}
    void Inv(int *a, int *b, int n) 
	{
		static int B[N], A[N];
		b[0] = pow(a[0], P - 2);
		int len, lim;
		for(len = 1; len < (n << 1); len <<= 1)
		{
			lim = len << 1;
			for(int i = 0; i < len; i++)
				A[i] = a[i], B[i] = b[i];
			for(int i = 0; i < lim; i++)
				rev[i] = (rev[i >> 1] >> 1) | ((i & 1) ? len : 0);
			NTT(A, lim, 1), NTT(B, lim, 1);
			for(int i = 0; i < lim; i++)
				b[i] = ((2LL - 1LL * A[i] * B[i] % P) * B[i] % P + P) % P;
			NTT(b, lim, -1);
			for(int i = len; i < lim; i++)
				b[i] = 0;
		}
		for(int i = 0; i < len; i++) 
			A[i] = B[i] = 0;
		for(int i = n; i < len; i++)
			b[i] = 0;
	}
    void derivative(int *a, int *b, int n)
	{
        b[n - 1] = 0;
        for(int i = 1; i < n; ++i)
        	b[i - 1] = (ll)a[i] * i % P;
    }
    void inter(int *a, int *b, int n)
	{
        *b = 0;
        for(int i = n - 1; i >= 0; --i)
			b[i + 1] = a[i] * (ll)pow(i + 1, P - 2) % P;
    }
    void ln(int *a, int *b, int n)
	{
        static int F[N];
        derivative(a, F, n);
		Inv(a, b, n);
        int lim = 1;
        while(lim < (n << 1)) lim <<= 1;
        for(int i = 1; i < lim; i++)
        	rev[i] = (rev[i >> 1] >> 1) | ((i & 1) ? (lim >> 1) : 0);
        for(int i = n; i < lim; ++i)
			b[i] = F[i] = 0;
        NTT(F, lim, 1), NTT(b, lim, 1);
        for(int i = 0; i < lim; ++i)
			F[i] = (ll)b[i] * F[i] % P;
        NTT(F, lim, 0);
        inter(F, b, n);
        for(int i = n; i < lim; ++i)
			b[i] = 0;
    }
    void exp(int *a, int *F, int n)
	{
        if(n == 1)
			*F = 1;
		else
		{
            exp(a, F, n + 1 >> 1);
            static int F0[N], A[N];
            for(int i = 0; i <= (n << 1); ++i)
				F0[i] = 0, A[i] = a[i];
            ln(F, F0, n);
            int lim = 1;
            while(lim < (n << 1)) lim <<= 1;
            for(int i = 1; i < lim; i++)
            	rev[i] = (rev[i >> 1] >> 1) | ((i & 1) ? (lim >> 1) : 0);
            for(int i = n; i < lim; ++i)
				A[i] = 0;
            NTT(A, lim, 1), NTT(F0, lim, 1), NTT(F, lim, 1);
            for(int i = 0; i < lim; ++i)
				F[i] = F[i] * (A[i] + 1LL - F0[i] + P) % P;
            NTT(F, lim, 0);
            for(int i = n; i < lim; ++i)
				F[i] = 0;
        }
    }
    void cos(int *a, int *b, int n)
    {
    	static int K[N], A[N], B[N];
    	for(int i = 0; i < n; i++)
    		K[i] = (ll)a[i] * img % P;
    	exp(K, A, n);
    	Inv(A, B, n);
    	for(int i = 0; i < n; i++)
    		A[i] = (ll)(A[i] + B[i]) % P;
    	int inv = pow(2, P - 2);
    	for(int i = 0; i < n; i++)
    		b[i] = (ll)A[i] * inv % P;
	}
	void sin(int *a, int *b, int n)
	{
		static int K[N], A[N], B[N];
		for(int i = 0; i < n; i++)
			K[i] = (ll)a[i] * img % P;
		exp(K, A, n);
		Inv(A, B, n);
		for(int i = 0; i < n; i++)
			A[i] = (ll)(A[i] - B[i] + P) % P;
		int inv = pow(img << 1, P - 2);
		for(int i = 0; i < n; i++)
			b[i] = (ll)A[i] * inv % P;
	}
}
using namespace poly;
int main()
{
	scanf("%d %d", &n, &type);
	for(int i = 0; i < n; i++)
		scanf("%d", a + i);
	if(type == 0) sin(a, b, n);
	else cos(a, b, n);
	for(int i = 0; i < n; i++)
		printf("%d ", b[i]);
    return 0;
}
```


---

## 作者：Prean (赞：1)

~~这可能是我见过最水的多项式题了QAQ~~

首先我们有欧拉公式：
$$ e^{ix} = \cos(x) + i\sin(x) $$
变一下，把$ i $变成$ -i $：
$$ e^{-ix} = \cos(x) - i\sin(x) $$
相加&相减得：
$$ e^{ix} + e^{-ix} = 2\cos(x) $$
$$ e^{ix} - e^{-ix} = 2i\sin(x) $$
移项：
$$ \sin(x) = \frac {e^{ix} - e^{-ix}} {2i} $$
$$ \cos(x) = \frac {e^{ix} + e^{-ix}} {2} $$
恩然后我们就能写出代码了QAQ：
```cpp
#include<cstring>
#include<cstdio>
#define clr(f,len) memset(f,0,(len)<<3)
#define cpy(f,g,len) memcpy(f,g,(len)<<3)
typedef long long ll;
const ll mod=998244353ll,M=5e5+5;
ll n,m,flag,G=3,invG=332748118ll,f[M],inv[M];
void swap(ll&a,ll&b){
	a^=b^=a^=b;
}
ll pow(ll a,ll b=mod-2){
	ll ans=1;for(;b;b>>=1,a=a*a%mod)if(b&1)ans=ans*a%mod;
	return ans;
}
void px(ll*f,ll*g,int len){
	for(int i=0;i<len;++i)f[i]=f[i]*g[i]%mod;
}
void dao(ll*f,int n){
	for(int i=1;i<n;++i)f[i-1]=f[i]*i%mod;
	f[n-1]=0;
}
void jifen(ll*f,int n){
	for(int i=n;i;--i)f[i]=f[i-1]*inv[i]%mod;
	f[0]=0;
}
void NTT(ll*f,bool flag,int n){
	static int fl,t[M];
	int i,k,p,len;ll w,w1;
	if(n!=fl){
		for(i=0;i<n;++i)t[i]=t[i>>1]>>1|(i&1?n>>1:0);
		fl=n;
	}
	for(i=0;i<n;++i)if(i<t[i])swap(f[i],f[t[i]]);
	for(p=2;p<=n;p<<=1){
		len=p>>1;w1=pow(flag?G:invG,(mod-1)/p);
		for(k=0;k<n;k+=p){
			w=1;
			for(i=k;i<k+len;++i){
				ll t=f[i+len]*w%mod;
				if((f[i+len]=f[i]-t)<0)f[i+len]+=mod;
				if((f[i]=f[i]+t)>mod)f[i]-=mod;
				w=w*w1%mod;
			}
		}
	}
	if(flag)return;
	ll invn=pow(n);
	for(i=0;i<n;++i)f[i]=f[i]*invn%mod;
}
void times(ll* f, ll* g, int l1, int l2) {
    static ll sav[M];
    int n;
    for(n=1;n<=(l1+l2);n<<=1);
    cpy(sav,g, l2);clr(f+l1,n-l1);clr(sav+l2,n-l2);
    NTT(f,1,n);NTT(sav,1,n);
    px(f,sav,n);NTT(f,0,n);
	clr(sav,n);
}
void invp(ll*f,int m){
	static ll b1[M],b2[M],b3[M];
	int i,n,len;
	for(n=1;n<m;n<<=1);b1[0]=pow(f[0]);
	for(len=2;len<=n;len<<=1){
		for(i=0;i<(len>>1);++i)b3[i]=(b1[i]<<1)%mod;
		cpy(b2,f,len);
		NTT(b1,1,len<<1);px(b1,b1,len<<1);
		NTT(b2,1,len<<1);px(b1,b2,len<<1);
		NTT(b1,0,len<<1);clr(b1+len,len);
		for(i=0;i<len;++i)b1[i]=(b3[i]-b1[i]+mod)%mod;
	}
	cpy(f,b1,m);clr(b1,n+n);clr(b2,n+n);clr(b3,n+n);
}
void lnp(ll*f,int m){
	static ll g[M];int n;
	for(n=1;n<m;n<<=1);
	cpy(g,f,m);
	invp(g,m);dao(f,m);
	NTT(f,1,n<<1);NTT(g,1,n<<1);
	px(f,g,n<<1);NTT(f,0,n<<1);
	jifen(f,m-1);
	clr(g,n+n);
}
void exp(ll*f,int m){
	static ll b1[M],b2[M];int n,i,len;
	for(n=1;n<m;n<<=1);b1[0]=1;
	for(len=2;len<=n;len<<=1){
		cpy(b2,b1,len>>1);clr(b2+len/2,len/2);lnp(b2,len);
		for(i=0;i<len;++i)b2[i]=(f[i]-b2[i]+mod)%mod;
		b2[0]=(b2[0]+1)%mod;
		times(b1,b2,len/2,len);
	}
	cpy(f,b1,m);clr(b1,n+n);clr(b2,n+n);
}
void sinp(ll*f,int m){
    static ll buf[M];
    int i;
    ll I=pow(G,mod-1>>2),inv2I=pow(I*2);
    for(i=0;i<m;++i){
        f[i]=f[i]*I%mod;
        buf[i]=mod-f[i];
    }
    exp(f,m);exp(buf,m);
    for(i=0;i<m;++i)f[i]=(f[i]-buf[i]+mod)%mod*inv2I%mod;
    clr(buf,m);
}
void cosp(ll*f,int m){
    static ll buf[M];
    int i;
    ll I=pow(G,mod-1>>2),inv2=pow(2);
    for(i=0;i<m;++i){
        f[i]=f[i]*I%mod;
        buf[i]=mod-f[i];
    }
    exp(f,m);exp(buf,m);
    for(i=0;i<m;++i)f[i]=(f[i]+buf[i])%mod*inv2%mod;
    clr(buf,m);
}
signed main(){
    int i;inv[1]=1;
    scanf("%d%d",&n,&flag);
    for(i=2;i<=n;++i)inv[i]=(mod-mod/i)*inv[mod%i]%mod;
    for(i=0;i<n;++i)scanf("%lld",f+i);
    if(flag==0)sinp(f,n);
    if(flag==1)cosp(f,n);
    for(i=0;i<n;++i)printf("%lld ",f[i]);
}
```

---

## 作者：KAMIYA_KINA (赞：0)

## Tag

生成函数？多项式。

## Description

给出 $F(x)$，求出 $G(x)\equiv \cos F(x)\pmod{x^n}$ 或者 $G(x)\equiv \sin F(x)\pmod{x^n}$.

$\texttt{data range:} 1\leq n \leq 10^5$.

## Solution

由于我们知道欧拉公式有很好的定义，这个定义在生成函数上同样成立，那么套入欧拉公式就很好解决这一个问题了，我们知道：

$$
e^{ix}=\cos x + i\sin x
$$

根据我们~~小学二年级~~学习的三角函数诱导公式可以得出：

$$
e^{-ix}=\cos x - i\sin x
$$

那么直接加减消元就可以得到：

$$
\begin{aligned}
\cos x&=\dfrac{e^{ix}+e^{-ix}}{2}\\
\sin x&=\dfrac{e^{ix}-e^{-ix}}{2i}
\end{aligned}
$$

所以我们可以直接解决这个问题了。$i$ 的值在 $\bmod 998244353$ 下可以等于 $86583718$ 或者 $911660635$，然后就做完了，时间复杂度 $O(n\lg n)$。

## Code

这里只给出关键代码的实现方式。

```cpp
const int I = 911660635;//或者 86583718 也可以

poly COS(poly F) {//这里 poly 是一个 vector<int>
    int n = F.size();
    FOR(i, 0, n - 1) F[i] = F[i] * I % mod;
    poly G = EXP(F), H = INV(G); int inv = (mod + 1) >> 1;
    FOR(i, 0, n - 1) F[i] = inv * (G[i] + H[i]) % mod;
    return F;
}

poly SIN(poly F) {
    int n = F.size();
    FOR(i, 0, n - 1) F[i] = F[i] * I % mod;
    poly G = EXP(F), H = INV(G); int inv = ksm(2 * I % mod, mod - 2);
    FOR(i, 0, n - 1) F[i] = inv * (G[i] - H[i] + mod) % mod;
    return F;
}
```



## 参考资料

[我的博客](https://www.luogu.com.cn/blog/juruo-4721/yi-suo-bei-wang).



---

## 作者：feicheng (赞：0)

## $\mathtt{Description}$

给定 $\deg = n$ 的多项式 $f$ 和 $\text{type}$，求一个多项式 $g$ 使得

$$
g\equiv \sin f \pmod {998244353}\quad(\text{type}=0)
$$
$$
g\equiv \cos f \pmod {998244353}\quad(\text{type}=1)
$$

$\mathtt{restrictions:}1\leq n \le10^5,a_i\in[0,998244353)\cap \mathbb{N}$

## $\mathtt{Solution}$

奇怪的多项式模板增加了！

### $\mathtt{Pre\;Knowledge}$

- 多项式 $\exp$
- 欧拉公式

### $\mathtt{Main\;Body}$

我们知道欧拉公式 
$$
e^{ix} = \cos x+ i\sin x
$$

有
$$
e^{-ix} = \cos x -i\sin x
$$

故
$$
\cos x=\dfrac {e^{ix}+e^{-ix}} {2}
$$
$$
\sin x = \dfrac{e^{ix}-e^{-ix}}{2i}
$$
又有

$$i\equiv86583718\pmod{998244353}$$
所以只需要一个多项式 $\exp$ 就可以了。
## $\mathtt{Code}$

```cpp
  inline auto Cos(vector <int> f) {
    const int len = f.size() ;
    for (int i = 0; i < len; ++i) f[i] = 1ll * f[i] * I % mod ;
    auto g = Exp(f),h = Inv(g) ;
    for (int i = 0; i < len; ++i) g[i] = 1ll * I2 * (g[i] + h[i]) % mod ;
    return g ;  
  }

  inline auto Sin(vector <int> f) {
    const int len = f.size() ;
    for (int i = 0; i < len; ++i) f[i] = 1ll * f[i] * I % mod ;
    auto g = Exp(f),h = Inv(g) ;
    const int x = ksm(I << 1) ;
    for (int i = 0; i < len; ++i) g[i] = 1ll * x * (g[i] - h[i] + mod) % mod ;
    return g ;
  }
```

---

## 作者：Spasmodic (赞：0)

[可能更好的体验](https://www.luogu.com.cn/blog/happydef-blog/duo-xiang-shi-quan-jia-tong-xue-xi-bi-ji)

~~这题咋不是模板。~~

前置芝士：多项式$\exp$，多项式求逆。

我们有

$$\begin{cases}e^{ix}=\cos x+i\sin x\\e^{-ix}=\cos x-i\sin x \end{cases}$$

解得
$$\begin{cases}\cos x=\frac{e^{ix}+e^{-ix}}{2}\\\sin x=\frac{e^{ix}-e^{-ix}}{2i} \end{cases}$$
但是有个$i$，怎么办？

没关系，注意到
$$\left(\frac{-1}{P}\right)=(-1)^\frac{P-1}{2}=1$$
所以存在$i_0\in \mathbb Z_P$，使得$i_0^2\equiv -1\pmod P$，用这个替代$i$。

比如对于本题来说，可以取$i_0=86583718$

于是
$$\begin{cases}\cos F=\frac{e^{i_0F}+e^{-i_0F}}{2}\\\sin F=\frac{e^{i_0F}-e^{-i_0F}}{2i_0} \end{cases}$$

over。

总复杂度$O(n\log n)$。

Q：如果 $P$ 不是固定的怎么做？

A：暴力枚举 $i$ 即可，当然也可以用Cipolla算法。

代码：
```cpp
void sin(ll*f,ll*g,ll len){
   for(ll i=0;i<len;i++)x[i]=img*f[i]%P;
   getexp(x,X,len),getinv(X,Y,len);
   for(ll i=0;i<len;i++)g[i]=(X[i]-Y[i]+P)%P*qpow(img<<1,P-2)%P;
   clear(x),clear(X),clear(Y);
}
void cos(ll*f,ll*g,ll len){
   for(ll i=0;i<len;i++)x[i]=img*f[i]%P;
   getexp(x,X,len),getinv(X,Y,len);
   for(ll i=0;i<len;i++)g[i]=(X[i]+Y[i])%P*inv[2]%P;
   clear(x),clear(X),clear(Y);
} 
```
完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll; 
const ll N=100005*3;
ll n,tp,f[N],g[N];
namespace Poly{
	const ll P=998244353,G=3,img=86583718;
	ll lmt,rev[N],a[N],b[N],c[N],d[N],e[N],x[N],y[N],X[N],Y[N];
	inline ll qpow(ll a,ll k){
		ll ret=1;
		while(k){
			if(k&1)ret=ret*a%P;
			a=(a*a)%P;
			k>>=1;
		}
		return ret%P;
	}
	inline void init(ll n){
		lmt=1;ll t=0;
		while(lmt<n)lmt<<=1,t++;
		for(ll i=1;i<lmt;i++)rev[i]=(rev[i>>1]>>1)|(i&1)<<(t-1);
	}
	inline void NTT(ll *A,ll lmt,ll tp){
		for(ll i=0;i<lmt;i++)if(i<rev[i])swap(A[i],A[rev[i]]);
		for(ll m=1;m<lmt;m<<=1)
			for(ll j=0,Wn=qpow(G,(P-1)/(m<<1));j<lmt;j+=m<<1)
				for(ll k=0,w=1,x,y;k<m;k++,w=w*Wn%P)
					x=A[j+k],y=w*A[j+k+m]%P,A[j+k]=(x+y)%P,A[j+k+m]=(x-y+P)%P;
		if(tp==1)return;
		reverse(A+1,A+lmt);
		for(ll i=0,inv=qpow(lmt,P-2);i<=lmt;i++)A[i]=A[i]*inv%P;
	} 
	void getinv(ll*f,ll*g,ll len){
		if(len==1){g[0]=qpow(f[0],P-2);return;}
		getinv(f,g,len+1>>1);
		init(len<<1);
		for(ll i=0;i<len;i++)c[i]=f[i];
		for(ll i=len;i<lmt;i++)c[i]=0;
		NTT(c,lmt,1),NTT(g,lmt,1);
		for(ll i=0;i<lmt;i++)g[i]=(2LL-g[i]*c[i]%P+P)%P*g[i]%P;
		NTT(g,lmt,-1);
		for(ll i=len;i<lmt;i++)g[i]=0; 
	}
	void getdev(ll*f,ll*g,ll len){
		for(ll i=1;i<len;i++)g[i-1]=i*f[i]%P;
		g[len-1]=0;
	}
	void getinvdev(ll*f,ll*g,ll len){
		for(ll i=1;i<len;i++)g[i]=f[i-1]*qpow(i,P-2)%P;
		g[0]=0;
	}
	void getln(ll*f,ll*g,ll len){
		memset(a,0,sizeof(a));
		memset(b,0,sizeof(b));
		getdev(f,a,len);
		getinv(f,b,len);
		init(len<<1);
		NTT(a,lmt,1),NTT(b,lmt,1);
		for(ll i=0;i<lmt;i++)a[i]=a[i]*b[i]%P;
		NTT(a,lmt,-1);
		getinvdev(a,g,len);
	}
	void getexp(ll*f,ll*g,ll len){
		if(len==1){g[0]=1;return;}
		getexp(f,g,len+1>>1);
		init(len<<1);
		for(ll i=0;i<(len<<1);i++)d[i]=e[i]=0;
		getln(g,d,len);
		for(ll i=0;i<len;i++)e[i]=f[i];
	    NTT(g,lmt,1),NTT(d,lmt,1),NTT(e,lmt,1);
    	for(ll i=0;i<lmt;i++)g[i]=(1-d[i]+e[i]+P)*g[i]%P;
    	NTT(g,lmt,-1);
    	for(ll i=len;i<lmt;i++)g[i]=0; 
	}
	void sin(ll*f,ll*g,ll len){
		for(ll i=0;i<len;i++)x[i]=img*f[i]%P;
		getexp(x,X,len),getinv(X,Y,len);
		for(ll i=0,inv=qpow(img<<1,P-2);i<len;i++)g[i]=(X[i]-Y[i]+P)%P*inv%P;
	}
	void cos(ll*f,ll*g,ll len){
		for(ll i=0;i<len;i++)x[i]=img*f[i]%P;
		getexp(x,X,len),getinv(X,Y,len);
		for(ll i=0,inv=qpow(2,P-2);i<n;i++)g[i]=(X[i]+Y[i])%P*inv%P;
	} 
}
using Poly::sin;
using Poly::cos;
int main(){
	scanf("%lld%lld",&n,&tp);
	for(ll i=0;i<n;i++)scanf("%lld",&f[i]);
	if(tp==0)sin(f,g,n);
	else cos(f,g,n);
	for(ll i=0;i<n;i++)printf("%lld ",g[i]);
	return 0;
}
```

---


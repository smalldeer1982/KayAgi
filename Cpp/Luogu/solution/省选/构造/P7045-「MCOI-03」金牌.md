# 「MCOI-03」金牌

## 题目背景

**这是一道交互题**。

书虫有很多块金牌！

## 题目描述

书虫正在整理他的 $n$ 块金牌，他发现所有金牌都是有磁性的！形式地说，每块金牌属于一种磁极，**磁极有很多种**。两块相邻的金牌磁极相同则相互排斥，不同则相互吸引。

书虫不知道每块金牌的磁极，他只能通过把两块金牌靠近的方式得知它们是相同磁极还是不同磁极。换句话说，你可以进行不超过 $Q$ 次交互，每次向交互库询问两个数 $x,y$，交互库会返回第 $x$ 块金牌和第 $y$ 块金牌是排斥还是吸引。金牌从 $0$ 到 $n-1$ 编号。

书虫希望把他的金牌排成一个排列，满足任意两块相邻的金牌都相吸引，请你帮他排出 **任意一个** 合法的排列，或者告诉他无解。

### 交互格式

**本题包含多组数据**。输入的第一行包含一个整数 $T$, 代表数据组数。

对于每一组数据，第一行读入两个整数 $n,Q$，代表金牌的数量和交互次数上限。

如果你需要向交互库发起询问，请向标准输出中输出一行以空格隔开的两个整数 $x,y$ 并 **清空缓冲区**。关于如何清空缓冲区，在下面的提示中有说明。接下来，从标准输入中读入一个整数 $ret$。如果 $ret=1$ 表示第 $x$ 块金牌和第 $y$ 块金牌吸引，如果 $ret=0$ 表示它们排斥。

如果你已经确定无解，请输出一行一个整数 $-1$ 并 **清空缓冲区**。然后本组数据结束，你应该接下来处理下一组数据。

如果你已经确定有解，请先输出一行一个整数 $n$，接下来一行输出 **任意一组** 合法的金牌排列，并 **清空缓冲区**。然后本组数据结束，你应该接下来处理下一组数据。

$T$ 组数据处理完之后你应该立即结束程序，多余的输出可能导致 RE。

## 说明/提示

### 样例 1 解释

样例中有两组数据。对于第一组数据，共有三块金牌，通过三次交互得知，它们的磁极都互不相同，那么任意一种排列都是正确的。

对于第二组数据，两块金牌的磁极相同，所以无解。

### 数据规模与约定

**本题使用捆绑测试**，数据范围如下表：

| 测试点编号 | $Q=$ | 特殊性质 | 得分 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $\frac{n(n-1)}{2}$ | $n\ge 4$ | $10$ |
| $2$ | $2n-2$ | 一种磁极最多只有 $2$ 块金牌 | $20$ |
| $3$ | $2n-2$ | 磁极的种类不超过 $3$ 种 | $20$ |
| $4$ | $3n$ | 无 | $20$ |
| $5$ | $2n-2$ | 无 | $30$ |

对于全部数据，$2\le n\le5\times10^4$，$1\le T\le 5\times 10^4$，$\sum Q\le 10^5$。

### 提示

你可以使用如下语句来清空缓冲区：

- 对于 C/C++：```fflush(stdout);```
- 对于 C++：```std::cout << std::flush;```
- 对于 Java：```System.out.flush();```
- 对于 Python：```stdout.flush();```
- 对于 Pascal：```flush(output);```
- 对于其他语言，请自行查阅对应语言的帮助文档。
- 特别的，对于 C++ 语言，在输出换行时使用 ```std::endl ``` 而不是 ```'\n'```，也可以自动刷新缓冲区。

## 样例 #1

### 输入

```
2
3 100

1

1

1


2 100

0```

### 输出

```


0 1

0 2

1 2

3
0 1 2

0 1

-1```

# 题解

## 作者：stoorz (赞：9)

有一个很直接的想法是我们枚举每一块金牌 $i$，将前 $i$ 块中剩余的金牌扔到队列里。如果第 $i$ 块金牌和队列里的金牌不一致，那么就将这两块金牌都加入答案序列，否则将 $i$ 压入队列中。

那么最后有若干个多出来的互相排斥的金牌在队列中，我们就枚举答案序列，如果相邻两项均与在队列中的金牌吸引，那么就在它们之间插入一块金牌。

如果最终队列里还有金牌，那么该情况就无解。因为上述操作保证了相邻两个中一定有一块金牌和队列中金牌互相排斥，所以任何情况下这种金牌都无法全部插入答案中。

由于我们最开始将 $0$ 直接加入到答案序列中，所以最多会有 $2(n-1)=2n-2$ 次交互。
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=100010;
int Q,n,m,ret,ans[N];
queue<int> q;

void prework()
{
	while (q.size()) q.pop();
	m=1; ans[1]=0;
}

int main()
{
	scanf("%d",&Q);
	while (Q--)
	{
		scanf("%d%d",&n,&m);
		prework();
		for (int i=1;i<n;i++)
			if (!q.size())  //将能插入的金牌插入到答案序列，否则扔到队列里
			{
				printf("%d %d\n",i,ans[m]);
				fflush(stdout);
				scanf("%d",&ret);
				if (ret) ans[++m]=i;
					else q.push(i);
			}
			else
			{
				printf("%d %d\n",i,q.front());
				fflush(stdout);
				scanf("%d",&ret);
				if (ret) ans[++m]=i,ans[++m]=q.front(),q.pop();
					else q.push(i);
			}
		for (int i=2*m;i>=1;i-=2)
			ans[i]=ans[i/2],ans[i-1]=-1;  //将两个金牌中隔出一个空位
		if (q.size())
		{
			bool last=1;
			for (int i=2;i<=2*m;i+=2)  //枚举并判断是否有两个金牌间还可以再次插入
			{
				printf("%d %d\n",q.front(),ans[i]);
				fflush(stdout);
				scanf("%d",&ret);
				if (ret && last) ans[i-1]=q.front(),q.pop();
				if (!q.size()) break;
				last=ret;
			}
		}
		if (q.size()) printf("-1\n");
		else
		{
			printf("%d\n",n);
			for (int i=1;i<=2*m;i++)
				if (ans[i]!=-1) printf("%d ",ans[i]);
			printf("\n");
		}
		fflush(stdout);
	}
	return 0;
}
```

---

## 作者：Owen_codeisking (赞：8)

交互好题！前排膜拜出题人。

首先有个经典算法：若序列中存在一个数出现次数 $>\lfloor \frac n2\rfloor$，那么执行下列算法即可找到这个数：

- $i=1,count=1,value=a_1$
- $i\leftarrow i+1$。若 $value=a_i$，令 $count=count+1$。否则，令 $count=count-1$。
- 若 $count=0$，令 $count=1,value=a_i$。
- 重复执行操作 $2,3$ 直到 $i=N$。

（正确性容易证明？）

对于一般序列，可以发现执行这个算法后，$value$ 是唯一有可能出现次数 $>\lfloor \frac n2\rfloor$ 的数。

那么这个经典算法又和这题有什么关系呢？

若存在一个数出现次数 $>\lfloor \frac n2\rfloor$，那么一定无解。

那么，可以先用 $n-1$ 次询问找出 $value$，再用 $n-1$ 次询问得到 $value$ 的出现次数。

什么？你说了这么多只能判个无解？就这就这？

~~怎么可能就这~~

我们发现，当这个算法 $count=0$ 时，实际能得到两个序列 $A,B$，满足 $A$ 所有元素相同，$B$ 所有元素与 $A$ 不同，且 $|A|=|B|$。

若原来的 $value=V$，更新过后是 $V'$，那么我们可以构造序列  $C'=C+\{V,B_1,V,B_2,...,V,V'\}$。

重复上述过程，我们最后会得到序列 $A,B,C$，同时 $|A|>|B|$。那么再次执行类似这个过程，会得到序列 $A$ 和空序列 $B$。那么我们要将序列 $A$ 中的元素插入序列 $C$。

因为构造出来序列 $C$ 相邻的数不同，所以这个序列有一个很强的性质：保证 $A$ 能插入的位置数量最多。

（正确性容易证明？）

那么，我们先用 $n-1$ 次询问找出 $value$，再用 $n-1$ 次询问序列 $C$ 中每个元素是否等于 $value$，即可在 $Q=2n-2$ 次询问内解决问题。

~~感觉用 vector 模拟代码有些长~~

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=50005;
int n,q,x[maxn],sta[maxn],top;
vector<int> a,b,res;
inline int query(int x,int y)
{
	printf("%d %d\n",x,y);
	fflush(stdout);
	int res;
	scanf("%d",&res);
	return res;
}
inline void end()
{
	puts("-1");
	fflush(stdout);
}
inline void solve()
{
	a.clear(),b.clear(),res.clear();
	scanf("%d%d",&n,&q);
	a.push_back(0);
	int lst=0,val=1;
	for(int i=1;i<n;i++)
		if(!query(lst,i)) val++,a.push_back(i);
		else
		{
			val--,b.push_back(i);
			if(val==0)
			{
				b.pop_back();
				for(int i=0;!a.empty() || !b.empty();i++)
					if(!(i&1)) res.push_back(a.back()),a.pop_back();
					else res.push_back(b.back()),b.pop_back();
				lst=i,val=1,a.push_back(i);
			}
		}
	while(!a.empty() && !b.empty())
		res.push_back(a.back()),res.push_back(b.back()),a.pop_back(),b.pop_back();
	if(res.empty()) { end(); return; }
	int sz=(int)res.size();
	for(int i=0;i<sz;i++) x[i]=query(res[i],a.back());
	int ans=x[0]+x[sz-1];
	for(int i=0;i<sz-1;i++) ans+=(x[i] && x[i+1]);
	if(ans<(int)a.size()) { end(); return; }
	top=0;
	if(!a.empty() && x[0])
		sta[top++]=a.back(),a.pop_back();
	for(int i=0;i<sz-1;i++)
	{
		sta[top++]=res[i];
		if(!a.empty() && x[i] && x[i+1])
			sta[top++]=a.back(),a.pop_back();
	}
	sta[top++]=res[sz-1];
	if(!a.empty() && x[sz-1])
		sta[top++]=a.back(),a.pop_back();
	printf("%d\n",top);
	for(int i=0;i<top;i++)
		printf("%d%c",sta[i],i==top-1?'\n':' ');
	fflush(stdout);
}
int main()
{
	int T;
	scanf("%d",&T);
	while(T--) solve();
	return 0;
}
```

---

## 作者：_ReClouds_ (赞：7)

首先来介绍一种奇妙的算法：**摩尔投票法**。它能够在 $\mathcal{O}(1)$ 的空间内求出一个长度为 $n$ 的序列中出现次数**大于** $\lfloor\frac{n}{2}\rfloor$ 的数。

算法流程如下：

1.   记录变量 $\operatorname{answer} = a_1$，$\operatorname{count} = 1$，然后跳至第 $2$ 步；
2.   从第 $2$ 个数开始扫描，当前扫描到第 $i$ 个数 $a_i$；
3.   如果 $\operatorname{answer} = a_i$，进行操作 $\operatorname{count} \leftarrow \operatorname{count} + 1$，否则进行操作 $\operatorname{count} \leftarrow \operatorname{count} - 1$；
4.   如果 $\operatorname{count} = 0$，令 $\operatorname{answer} = a_i$，$\operatorname{count} = 1$；
5.   如果 $i = n$，退出算法，此时 $\operatorname{answer}$ 即为答案；否则，扫描下一个数。

证明应该很简单吧。不过，看到它的人无不感叹其思想之巧妙。

而这个算法又和这道题有什么关系呢？往下看。

------

接下来，我们思考这样一件事情：无解的情况是什么？

答案是：存在一种磁极，属于这种磁极的金牌个数**大于** $\lceil\frac{n}{2}\rceil$。证明应该比较显然，这里就不展开讨论了。

（对于这一点，似乎大部分题解都写错了，要么写的是“大于 $\lfloor\frac{n}{2}\rfloor$”，要么写的是“超过 $n$ 的一半”，这里给这些写错了的题解纠个错。）

但是，我们如何判定无解情况呢？事实上，得出每一对金牌的磁极关系几乎是不可能的。

这个时候，上面的摩尔投票法的思想就派上用场了。

-   $\operatorname{Init}$：

我们先把 $0$ 放入答案序列。

同时，我们维护好一个队列，这个队列应该满足这样一个条件：**队列中的所有金牌磁极相同**。

-   $\operatorname{Step~1}$：

接下来，我们一个个枚举金牌。

对于枚举到的金牌 $m_i$ 究竟何去何从，我们分两种情况讨论：

1.   此时队列为空。我们先看 $m_i$ 的磁极和**答案序列尾部金牌**的磁极是否相吸。如果是，我们直接将其加入答案序列；否则，我们将其插入队列。
2.   此时队列不为空。我们先看 $m_i$ 的磁极和**队列中金牌**的磁极是否相吸。如果是，我们也直接将其加入答案，**同时将队列中的一个金牌取出并加入答案序列**；否则，我们同样将其插入队列。

第 $2$ 步可能需要一点证明：

显然同时加入的这两个金牌是相吸的，因此只需要考虑 $m_i$ 和答案序列尾部金牌 $m_t$ 的磁极是否相吸。

（值得注意的是，这里不能先加入队列中的金牌，因为可以证明其可能和答案序列尾部金牌的磁极相斥。）

我们分两种情况讨论 $m_t$ **加入时的情况**：

1.   加入 $m_t$ 时队列为空。

那么加入 $m_t$ 后队列也应当为空。

而由于加入 $m_i$ 时队列不为空，说明在 $m_t$ 加入后到 $m_i$ 加入前，加入了一些和 $m_t$ 相同磁极的金牌，直到 $m_i$ 出现才停止，这就说明了 $m_t$ 和 $m_i$ 的磁极是不相同的，即它们相吸。

2.   加入 $m_t$ 时队列不为空。

此时 $m_t$ 一定是队列中的金牌。

假设加入 $m_t$ 后队列为空，那么回到了上一种情况。

否则，加入 $m_i$ 说明 $m_i$ 的磁极和队列中的磁极相吸，所以加入也是合法的。

得证。

- $\operatorname{Step~2}$：

此时队列中存在若干个**磁性相同**的金牌。

那么，我们直接枚举答案序列的每一个空隙。

如果空隙**左右两侧**的金牌磁极都与队列中的金牌磁极相吸，那么插入即可。

如果最终队列不为空，说明存在存金牌个数**大于** $\lceil\frac{n}{2}\rceil$ 的磁极（**没有足够的缝隙可以插入**），此时无解。

算法，结束！

在 $\operatorname{Step~1}$ 中，交互次数为 $n - 1$；在 $\operatorname{Step~2}$ 中，交互次数小于等于 $n - 1$。

总交互次数小于等于 $2\cdot(n - 1)$，所以这个构造方案是合法的。

可以发现，**这个算法几乎和摩尔投票法的流程一一对应**。看到这里，相信你也会深感其思想之巧妙吧！

最后，贴上代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cassert>
#include<queue>

#define MAXN 100005

using namespace std;

int t, n, m, res, len, ans[MAXN];
queue<int> q;

inline void Init()
{
    while(!q.empty()) q.pop();
    return ans[len = 1] = 0, void();
}

int main()
{
    scanf("%d", &t);
    while(t--)
    {
        scanf("%d%d", &n, &m);
        Init();
        for(register int i = 1; i < n; i++)
        {
            if(q.empty())
            {
                printf("%d %d\n", ans[len], i);
                fflush(stdout);
                scanf("%d", &res);
                if(res) ans[++len] = i;
                else q.push(i);
            }
            else
            {
                printf("%d %d\n", q.front(), i);
                fflush(stdout);
                scanf("%d", &res);
                if(res) ans[++len] = i, ans[++len] = q.front(), q.pop();
                else q.push(i);
            }
        }
        for(register int i = len * 2; i >= 2; i -= 2) ans[i] = ans[i >> 1], ans[i - 1] = -1;
        if(!q.empty())
        {
            bool Lastres = 1;
            for(register int i = 2; i <= len * 2; i += 2)
            {
                printf("%d %d\n", q.front(), ans[i]);
                fflush(stdout);
                scanf("%d", &res);
                if(res && Lastres) ans[i - 1] = q.front(), q.pop();
                if(q.empty()) break;
                Lastres = res;
            }
        }
        if(!q.empty()) printf("-1\n");
        else
        {
            printf("%d\n", n);
            for(register int i = 1; i <= len * 2; i++) if(ans[i] != -1) printf("%d ", ans[i]);
            putchar('\n');
        }
        fflush(stdout);
    }
    return 0;
}
```

---

## 作者：Demoe (赞：3)

### [题目传送门](https://www.luogu.com.cn/problem/P7045)

## 题意

- 交互题。

- 有 $n$ 个磁石，对于每组 $n$，可以询问 $q$ 次。

- 每次可询问两个磁石磁性是否相同。

- 构造一个数列，使得任两个连续磁石磁性都不同。

## Sol

~~哇 为啥放学了后只有 $10$ min 月赛就结束了啊~~

~~为啥 D 比 C 简单啊~~

~~交互+构造诶~~

考虑无解情况。

可知仅当某种磁性的磁石超过一半时，无解。

考虑求众数的算法。

用一个东西存下一群数。

如果新的数与存的数不同则拿出一个组成一对数对。

如果相同就再扔进去。

考虑到这样可以构造一组满足条件的数列。

对于那个容器没空的时候，容易发现可以通过保证数对的顺序相同来构造数列。

当容器里的数变了，考虑多使用一次询问，判断两端是否能接上，然后再返回上面即可。

最后将容器里剩的数尝试插入数列即可。

询问次数显然不超过 $2(q-1)$。（似乎不到/yiw）

```cpp
// wish to get better qwq
#include<bits/stdc++.h>
using namespace std;
const int N=5e4+5;
int t,n,q,ans[N],fl,qwq,cnt,c;
stack<int> qaq;pair<int,int> kk[N];
inline void wr(int op){
	if(op==-1){
		cout<<-1<<endl;return ;
	}
	cout<<n<<endl;
	int nw=0;
	for(int i=0;i<cnt;i++){
		if(nw<c&&kk[nw].second==i) cout<<kk[nw].first<<' ',nw++;
		cout<<ans[i]<<' ';
	}
	if(nw<c) cout<<kk[nw].first<<' ';
	cout<<endl;
}
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	ios::sync_with_stdio(0);
	cin>>t;
	while(t--){
		cin>>n>>q;c=cnt=qwq=fl=0;
		while(!qaq.empty()) qaq.pop();
		for(int i=0;i<n;i++){
			if(qaq.empty()){
				qaq.push(i);fl=1;continue;
			}
			cout<<qaq.top()<<' '<<i<<endl;
			int op;cin>>op;
			if(op==0){
				qaq.push(i);continue;
			}
			int nw=qaq.top();qaq.pop();
			if(fl){
				if(!cnt){
					ans[cnt|qwq]=nw;ans[cnt|(qwq^1)]=i;cnt+=2;
					continue;
				}
				cout<<nw<<' '<<ans[cnt-1]<<endl;
				cin>>op;fl=0;qwq=op^1;
				ans[cnt|qwq]=nw;ans[cnt|(qwq^1)]=i;cnt+=2;
				continue;
			}
			ans[cnt|qwq]=nw;ans[cnt|(qwq^1)]=i;cnt+=2;
		}
		int op,awa=1;
		for(int i=0;i<cnt&&!qaq.empty();){
			if(awa){
				cout<<qaq.top()<<' '<<ans[i]<<endl;
				cin>>op;
				if(op){
					kk[c]=make_pair(qaq.top(),i);c++;qaq.pop();
					awa=1;i++;continue;
				}
				i+=2;awa=0;continue;
			}
			cout<<qaq.top()<<' '<<ans[i]<<endl;
			cin>>op;
			if(!op){
				i+=2;awa=0;continue;
			}
			cout<<qaq.top()<<' '<<ans[i-1]<<endl;
			cin>>op;
			if(!op){
				i++;awa=1;continue;
			}
			kk[c]=make_pair(qaq.top(),i);c++;qaq.pop();
			i++;awa=1;
		}
		if(!qaq.empty()){
			cout<<qaq.top()<<' '<<ans[cnt-1]<<endl;
			cin>>op;
			if(op==1){
				kk[c]=make_pair(qaq.top(),cnt);c++;qaq.pop();
			}
		}
		if(!qaq.empty()) wr(-1);
		else wr(0);
	}
	return 0;
}
```

---

## 作者：gyh20 (赞：3)

赛时莫名水过，过来发个题解。

我们考虑维护一个答案序列（可用 vector 实现）。

首先将 $0$ 加入 vector。

但我们发现这东西不好直接维护，我们在维护一个 vector 表示暂时不能插入的数，可以发现这些数的颜色一定相同。

之后对于 $1\sim n-1$ 的每一个 $i$，将 $i$ 与答案序列的最后一个数比较，此时分类讨论。

$1.$可以放，将 $i$ 插在末尾，此时一定可以将之前没有放的一个放在 $i$ 之后（这个东西一定和 $i$ 前一个数颜色相同所以和 $i$ 不同）

$2.$不能放，此时枚举放在哪个位置，一个较优的方案是两个两个跳，直到颜色不同为止，此时为了偷懒 vector 暴力 insert，如果插不进去就只有丢入另一个 vector。

居然这样能过 $q=3n$？

再加了一个并查集合并颜色相同项，减少一些询问，就过了？

具体不是很会证为什么是对的，但是对于 $n=9$ 的所有情况好像都能跑过。

时间是 $O(n^2)$ 的（vector insert），但明显可以用链表优化到 $O(n)$。

```cpp
#include<cstdio>
#include<algorithm>
#include<vector>
#include<cstring>
#define re register
#define ll long long
using namespace std;
inline int read(){
	re int t=0;re char v=getchar();
	while(v<'0')v=getchar();
	while(v>='0')t=(t<<3)+(t<<1)+v-48,v=getchar();
	return t;
}
int t,n,fa[50002];
vector<int>ans,tmp;
inline int root(re int x){return x==fa[x]?x:fa[x]=root(fa[x]);}
inline void merge(re int x,re int y){
	if((x=root(x))==(y=root(y)))return;
	fa[x]=y;
}
int main(){
	t=read();
	while(t--){
		n=read();
		for(re int i=0;i<n;++i)fa[i]=i;
		re int kk=read();
		ans.clear();
		ans.push_back(0);
		tmp.clear();
		re int tot=0;
		for(re int i=1;i<n;++i){
			printf("%d %d\n",ans[ans.size()-1],i);++tot;
			fflush(stdout);
			re int x=read();
			if(x==1){
				ans.push_back(i);
				if(!tmp.empty())ans.push_back(tmp[tmp.size()-1]),tmp.pop_back();
			}
			else{
				merge(ans[ans.size()-1],i);
				if(ans.size()==1)tmp.push_back(i);
				else{
					if(ans.size()==2)ans.insert(ans.begin(),i);
					else{
						if(root(ans[0])^root(i)){
						printf("%d %d\n",ans[0],i);
						fflush(stdout);
						if(read()==1){
							ans.insert(ans.begin(),i);
							continue;
						}
						else merge(ans[0],i);
						}
						re int tmpp=ans.size()-3,ia=0;
						while(tmpp>0){
							if(root(ans[tmpp])^root(i)){
							printf("%d %d\n",ans[tmpp],i);++tot;
							fflush(stdout);
							if(read()==1){
								ans.insert(ans.begin()+tmpp+1,i);
								ia=1;
								break;
							}
							else{
								merge(ans[tmpp],i);
								tmpp-=2;
							}
							}
							else tmpp-=2;
						}
						if(!ia)tmp.push_back(i);
					}
				}
			}
		}
		if(ans.size()==n){
			printf("%d\n",n);
			for(re int i=0;i<n;++i)printf("%d ",ans[i]);
			puts("");
		}
		else puts("-1");
		fflush(stdout);
	}
}
```



---

## 作者：Miss_dijkstra (赞：2)

思路大致就是luogu月赛讲评的思路

维护一个盒子，这个盒子能装一种磁性的金牌无数个

对每一个金牌依次询问是否和盒子内金牌磁性相同，如果盒子为空或者和盒子里的金牌磁极一样就放进序列里去，否则就取出盒子里一个金牌，把它和现在这个金牌一起甩到一个序列里去，最后这样我们就能得到一个全是同一磁性金牌的盒子，和一个合法序列，最后在对合法序列每两个相邻的金牌进行询问，看他们是否和盒子里金牌磁性相吸，如果都像吸就在他们之间插入一个盒子里的金牌，最后都插完了，盒子里金牌还有剩的话就无解

但是有个坑点不然你的正解可能就是零分

### 就是对于一个合法序列它的最前和最后是可以插入金牌的需要特判
### 金牌编号是零到n-1 ，输出前 "请先输出一行一个整数 n" 因为这个小问题卡了半天

最后放代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5*1e4+10;
int t,n,q,op,pn,flag,apn;
int a[N],ans[N];
stack <int> s;
int main()
{
    scanf("%d",&t);
    while(t--)
    {
        memset(a,0,sizeof(a));
        memset(ans,0,sizeof(ans));
        pn=0;apn=0;flag=0;
        while(!s.empty()) s.pop();
        cin>>n>>q;
        s.push(0);
        for(int i=1;i<n;i++)
        {
            if(s.empty())
            {
                s.push(i);
                if(pn==0)
                    flag=0;
                else
                {
                    cout<<s.top()<<" "<<a[pn]<<endl;
                    cin>>op;
                    if(op==1)
                        flag=0;
                    else
                        flag=1;
                 //盒子里的磁性改变的时候，我们需要重新判断一下盒子里金牌对序列的吸引还是排斥
                    
                }
                continue;
            }
            cout<<s.top()<<" "<<i<<endl;
            cin>>op;
            if(op==1)
            {
                if(flag==1)
                {
                    a[++pn]=i;
                    a[++pn]=s.top();
                    s.pop();
                }
                else
                {
                    a[++pn]=s.top();
                    a[++pn]=i;
                    s.pop();
                }
            }
            else
                s.push(i);
        }
       //puts("fuck");
        int pre=-1;
        for(int i=1;i<=pn;i++)
        {
            if(!s.empty())
            {
                cout<<s.top()<<" "<<a[i]<<endl;
                cin>>op;
                if((op==1&&pre==1)||(op==1&&pre==-1))//判断序列前能不能插
                {
                    ans[++apn]=s.top();
                    s.pop();
                }
            }
            ans[++apn]=a[i];
            pre=op;
        }
        if(!s.empty())//判断序列后能不能插
        {
            if(op==1)
            {
                ans[++apn]=s.top();
                s.pop();
            }
        }
        if(!s.empty())
        {
            cout<<-1<<endl;
            continue;
        }
        cout<<apn<<endl;
        for(int i=1;i<=apn;i++)
        {
            if(i==apn)
                cout<<ans[i]<<endl;
            else
                cout<<ans[i]<<" ";
        }
    }
    return 0;
}

```


---

## 作者：断清秋 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P7045)

构造题和交互题，共同特点是我都不会。

前置知识：[摩尔投票法](https://www.luogu.com.cn/blog/DreamNOI2022/post-ti-xie-p2397-yyy-loves-maths-vi-mode)

嗯，了解了摩尔投票法之后再来看这个题。

首先直观的想法是维护一个答案序列，再维护一个队列代表暂时放不进去的金牌。

开始时把第 $0$ 块金牌直接扔进答案序列。

然后枚举金牌，如果队列中没有剩余的金牌，那就把当前金牌跟答案序列的末尾询问一下，能放就放，放不了就扔进队列。

如果队列中有剩余的金牌，那就把当前金牌跟队列中队头金牌询问一下，如果能放就两个都放进去（先放当前金牌再放队头金牌）

然后这样最多会交互 $n-1$ 次。

然后我们会剩下一个答案序列和一个队列。根据摩尔投票法可知，队列中剩下的必然全是同一磁极的金牌（众数）。

然后考虑插空，枚举答案序列中所有空位，看看是否能放进去一块金牌，能放就放。（注意最左边和最右边只需要考虑一次就行了）

如果枚举空位过程中，队列中金牌都放完了，那就结束循环。（否则会 RE）

枚举完所有空位后如果还有剩余，就无解（全插空都放不下）

否则输出答案即可。

枚举空位之前最多有 $n-1$ 块金牌，因此最多有 $n-1$ 个空位，于是最多交互 $n-1$ 次。

于是一共最多交互 $2n-2$ 次。

这样复杂度是 $O( \sum Q)$ 的，就过了。

PS：感觉 $2n-2$ 应该不是此题的复杂度下界……

代码：

```cpp
#include<bits/stdc++.h>
#include<iostream>
#define ll long long
#define back return 
#define ri register int 
using namespace std;
ll read()
{
	ll x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=x*10+ch-'0';
		ch=getchar();
	}
	back x*f;
}
int t,n,m,a[50005],b[50005]; 
queue<int> q;
int main()
{
	t=read();
	while(t--)
	{
		int r=1;
		while(!q.empty())
			q.pop();
		for(ri i=1;i<=2*n;i++)
			a[i]=0,b[i]=0;
		n=read(),m=read();
		for(ri i=1;i<n;i++)
		{
			if(q.empty())
			{
				cout<<a[r]<<" "<<i<<"\n";
				fflush(stdout);
				int ret=read();
				if(ret)
					a[++r]=i;
				else
					q.push(i);
			}
			else
			{
				cout<<i<<" "<<q.front()<<"\n";
				fflush(stdout);
				int ret=read();
				if(ret)
					a[++r]=i,a[++r]=q.front(),q.pop();
				else
					q.push(i);
			}
		}
		for(ri i=1;i<=r;i++)
			b[i*2]=a[i],b[i*2-1]=-1;
		if(!q.empty())
		{
			int last=1;
			for(ri i=2;i<=2*r&&!q.empty();i+=2)
			{
				cout<<b[i]<<" "<<q.front()<<"\n";
				fflush(stdout);
				int ret=read();
				if(last&&ret)
					b[i-1]=q.front(),q.pop();
				last=ret;
			}
		}
		if(!q.empty())
		{
			cout<<-1<<"\n";
			fflush(stdout);
			continue;
		}
		cout<<n<<"\n";
		for(ri i=1;i<=2*r;i++)
			if(b[i]!=-1)
				cout<<b[i]<<" ";
		cout<<"\n";
		fflush(stdout);	
	}
    back 0;
}
```

---


# [JDWOI-2] 01 串

## 题目背景

小 K 和小 M 写了一个 01 串。

## 题目描述

小 K 和小 M 写了一个 01 串 $S$，串的**结尾**包含 2 个连在一起的空格（用 `.` 表示）。

小 M 定义一个 01 串是美观的，当且仅当串中没有逆序对，即没有 1 出现在 0 的前面。

为了满足小 M 的上述要求，小 K 决定对这个 01 串进行一些修改。每一次修改，小 K 可以选择串中两个连续的非空格字符，并把他们移动到空格的位置，并且不改变相对位置。这样，被移动的字符处会变成空格，而原来的空格会被这两个字符填起来。

小 K 为了尽快让字符串变美观，希望在 $10000$ 步以内完成。现在，请求出需要用多少步使得 01 串变美观，并输出方案。如果无法使串美观，或者步数必须超过 $10000$ ，请输出 `-1`。

**注：你并不需要最小化修改步数，并且最终空格的位置随便。**

## 说明/提示

**本题采用 Special Judge 和子任务评测。**

【样例解释 1】  

$\texttt{1100..} \rightarrow \texttt{..0011}$

【样例解释 2】  

可以发现无论如何移动都无法实现小 M 要求的 01 串。

【数据范围和子任务分数】  

Subtask1(20pts)：$3 \leq |S| \leq 10$；  
Subtask2(30pts)：$3 \leq |S| \leq 100$；  
Subtask3(50pts)：$3 \leq |S| \leq 2000$。

## 样例 #1

### 输入

```
1100..```

### 输出

```
1
1 5
```

## 样例 #2

### 输入

```
0101..```

### 输出

```
-1```

# 题解

## 作者：RegisterFault (赞：2)

提供一个高级一点的乱搞。

首先发现我们可以利用题目的操作实现这样一个东西：对于 $u < v - 1$，可以做到交换 $s_u, s_v$，同时交换 $s_{u +1}, s_{v +1}$。实现这个交换只需要花费三步。

做法很简单。首先把 $u, u + 1$ 挪到空位上，把 $v, v +1$ 挪到原来 $u, u +1$ 所在的位置上（这里现在是空位）。最后在把 $u, u + 1$ 挪到空位。

具体的，假设现在有串 `123456__`。需要交换 $(1, 2)$ 和 $(5, 6)$。首先把 $(1, 2)$ 同时挪到最后，变成 `__345612`。然后把 $(5, 6)$ 挪到空位，变成 `5634__12`。最后把 $(1, 2)$ 挪回去，变成 `563412__`。

从前往后构造。我们构造目标序列 $t = \texttt{0000...1111...}$。对于 $a_i \ne t_i$ 的位置，我们暴力找到后面的位置 $j$ 满足 $a_j = t_i$，然后交换一下 $i$ 和 $j$。

由于上述构造中空位的位置不变，因此实现起来非常简单。然后你发现你被卡了。当然这是一个假贪心，很容易被卡掉。

**接下来是本文精华**。我们随机一个排列 $p$，先构造方案使得 $a \rightarrow p$，再构造排列使得 $p \rightarrow t$。由于交换的代价为 $3$，而一个序列变换成另一个序列需要的步数最多为 $3n$，所以这个做法步数是 $6n$ 级别的。**由于排列是随机的**，答案远远小于这个量级。

对着这个做法卡个五十次就过了。注意 $n \le 10$ 可能被出题人刻意卡了，需要爆搜一下。

下面是没写爆搜的代码。

```cpp
const int N = 2010;
int a[N], tmp[N], t[N], n, m;
char s[N];
vector<pair<int, int>> path;
void Swap(int u, int v) {
	swap(a[u], a[v]); swap(a[u + 1], a[v + 1]);
	path.push_back({u, m + 1});
	path.push_back({v, u});
	path.push_back({m + 1, v});
}
void Construct() {
	int s0 = 0, s1 = 0;
	memcpy(tmp, a, sizeof tmp);
	rep(i, 1, m) a[i] == 0 ? s0 ++ : s1 ++ ;
	rep(i, 1, s0) t[i] = 0; rep(i, s0 + 1, m) t[i] = 1;
	random_shuffle(t + 1, t + m + 1); path.clear();
	rep(i, 1, m) if (a[i] != t[i]) {
		bool flg = 0;
		rep(j, i + 2, m - 1) if (a[j] == t[i]) {
			flg = 1; Swap(i, j); break;
		} if (!flg) { memcpy(a, tmp, sizeof a); return; }
	}
	rep(i, 1, s0) t[i] = 0; rep(i, s0 + 1, m) t[i] = 1;
	rep(i, 1, m) if (a[i] != t[i]) {
		bool flg = 0;
		rep(j, i + 2, m - 1) if (a[j] == t[i]) {
			flg = 1; Swap(i, j); break;
		} if (!flg) { memcpy(a, tmp, sizeof a); return; }
	}
	printf("%d\n", (int)path.size());
	for (auto i : path) printf("%d %d\n", i.first, i.second);
	exit(0);
}
int main() {
	srand(998244353);
	scanf("%s", s + 1); n = strlen(s + 1);
	m = n - 2; rep(i, 1, m) a[i] = s[i] - '0';
	rep(i, 1, 100) Construct(); puts("-1");
}
```

---

## 作者：xyf007 (赞：2)

出题人的官方题解

实际上这题的核心在于将绝大多数操作转换为一种操作：每次将一个 1 移到后面。  
我们考虑一个普遍情况 $\texttt{**1*..111}$（$\texttt{**}$ 表示任意数字）。过程如下：  
$\texttt{**1*..111} \rightarrow \texttt{*..**1111} \rightarrow \texttt{***..1111}$。  
$|S|$ 很小的时候（如样例二）可能会不可行，如果分类讨论的话情况较多，所以应该写一个暴力搜索的程序（  
还有普通情况下最后几步的特判，具体见代码实现。
```cpp
#include <algorithm>
#include <cstring>
#include <iomanip>
#include <iostream>
#include <numeric>
#include <unordered_set>
#include <vector>
std::size_t n;
int a[2010];
std::string s;
std::unordered_set<std::string> st;
std::vector<std::pair<int, int>> v;
bool Check(const std::string &s) {
  int lst = 0;
  for (std::size_t i = 0; i < s.size(); i++) {
    if (s.at(i) == '.') continue;
    if (s.at(i) - '0' < lst) return false;
    lst = s.at(i) - '0';
  }
  return true;
}
void Dfs(std::string &s) {
  if (Check(s)) {
    for (auto &&i : v) std::cout << i.first + 1 << ' ' << i.second + 1 << '\n';
    std::exit(0);
  }
  std::size_t p = 0;
  for (std::size_t i = 0; i < s.size(); i++)
    if (s.at(i) == '.') {
      p = i;
      break;
    }
  for (std::size_t i = 0; i < s.size() - 1; i++)
    if (i != p - 1 && i != p && i != p + 1) {
      std::swap(s.at(i), s.at(p));
      std::swap(s.at(i + 1), s.at(p + 1));
      v.emplace_back(i, p);
      if (!st.count(s)) {
        st.emplace(s);
        Dfs(s);
      }
      std::swap(s.at(i), s.at(p));
      std::swap(s.at(i + 1), s.at(p + 1));
      v.pop_back();
    }
}
void Brute() {
  Dfs(s);
  std::cout << -1;
}
void Move(std::size_t f, std::size_t t) {
  a[t] = a[f];
  a[t + 1] = a[f + 1];
  a[f] = a[f + 1] = -1;
  std::cout << f << ' ' << t << '\n';
  // for (std::size_t i = 1; i <= n; i++) {
  //   if (a[i] == -1) {
  //     std::cerr << '.';
  //   } else {
  //     std::cerr << a[i];
  //   }
  // }
  // std::cerr << '\n';
}
int main(int argc, char const *argv[]) {
  std::ios_base::sync_with_stdio(false);
  std::cin.tie(nullptr);
  std::cout.tie(nullptr);
  std::cin >> s;
  n = s.size();
  if (n <= 10) {
    Brute();
    return 0;
  }
  for (std::size_t i = 1; i <= n - 2; i++) a[i] = s.at(i - 1) - '0';
  a[n - 1] = a[n] = -1;
  std::size_t p = n - 1, now = n - 2, np;
  while (p > 4 && now > 1) {
    if (a[now] != 1) {
      now--;
      continue;
    }
    Move(now - 1, p);
    np = now - 1;
    if (now - 1 == p - 2) {
      Move(now - 3, now - 1);
      np = now - 3;
    }
    Move(p - 1, np);
    p--;
  }
  if (a[1] <= a[2] && a[2] <= a[3]) return 0;
  if (a[2] == 1) {
    Move(1, p);
    return 0;
  }
  if (a[3])
    if (p == 4) {
      Move(2, p);
      Move(p + 2, 2);
      Move(1, p + 2);
      Move(p, 1);
      return 0;
    } else {
      Move(2, p);
      Move(--p, 2);
    }
  if (p >= n - 2) {
    Move(3, p);
    Move(1, 3);
    Move(p, 1);
    Move(2, p);
  } else if (p == 4) {
    Move(2, p);
    Move(p + 2, 2);
    Move(1, p + 2);
    Move(p, 1);
  } else {
    Move(p - 2, p);
    Move(1, p - 2);
    Move(p, 1);
    Move(p - 3, p);
  }
  return 0;
}
```

---

## 作者：Exp10re (赞：1)

一道细节相当多的构造题。

之前有一篇题解说这道题难度只有绿。别信他。

开题的时候我还在纳闷为什么通过率不到百分之五，交了十几发之后终于领教了。

## 解题思路

主要的思路很简单，但是细节还是要看代码。

考虑通过大量的操作使得所有 $1$ 都在两个点右边，其他不能立刻确定的放在两个点左边。

那么我们对于一个位于两个点左边的 $1$（假设其位置为 $i$），考虑进行如下操作将它放到右边。

- $\texttt{???1??..11}$ 将 $[i-1,i]$ 移动到两个点的位置（记为 $k$）。
- $\texttt{???..??111}$ 将 $[2,3]$ 移动到 $[i-1,i]$。
- $\texttt{?????..111}$ 将 $[k-1,k]$ （即原先两个点的位置往前一位）移动到 $[2,3]$。
- 使 $k\leftarrow k-1$。

注意到这种方法适用于所有 $i\in [5,k-1]$ 的 $a_i=1$ 的情况。

那么接下来就是特判时间了。

- $|S|\gt 7$ 时一定有解，否则需要枚举手推所有情况。（或者 DFS）
- 很多时候 $a_1=1$ 会不太好解决，因此考虑通过预处理使得在进行操作前 $a_1=0$。
- 以上方法**仅**适用于所有 $i\in [5,k-1]$ 的 $a_i=1$ 的情况，因此对于 $i\leq 4$ 考虑特判。

代码细节部分见下，省略了特判 1 和特判 3，完整代码见[剪贴板](https://www.luogu.com.cn/paste/49kovzb3)。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const long long MAXN=10040;
long long a[MAXN],ans,ansset[MAXN][2],n,tag;
char s[MAXN];
long long abs_(long long x)
{
	return x<0?-x:x;
}
void move(long long x,long long y)
{
	if(abs_(x-y)<=1)
	{
		return;
	}
	long long i;
	ans++;
	ansset[ans][0]=x;
	ansset[ans][1]=y;
	a[y]=a[x];
	a[y+1]=a[x+1];
	a[x]=-1;
	a[x+1]=-1;
	return;
}
void spj();
void spj2();
int main()
{
	long long i,j;
	long long flag0=0,flag1=0;
	scanf("%s",s+1);
	n=strlen(s+1);
	tag=n+1;
	for(i=1;i<=n;i++)
	{
		if(s[i]=='1')
		{
			a[i]=1;
			flag1=1;
		}
		else if(s[i]=='0')
		{
			a[i]=0;
			flag0=1;
		}
		else
		{
			a[i]=-1;
		}
	}
	if(n<=6)
	{
		spj();
		return 0;
	}
	if(!(flag1&&flag0))
	{
		printf("0");
		return 0;
	}
	if(a[1]==1)
	{
		for(i=1;i<=n;i++)
		{
			if(a[i]==0)
			{
				break;
			}
		}
		if(i==n-3)
		{
			printf("2\n1 %lld\n%lld 1",n-1,n-3);
			return 0;
		}
		else if(i==n-2)
		{
			printf("2\n1 %lld\n%lld 1",n-1,n-2);
			return 0;
		}
		else if(i==2)
		{
			move(3,n-1);
			move(1,3);
			move(4,1);
			move(n-1,4);
		}
		else
		{
			move(1,n-1);
			move(i,1);
			move(n-1,i);// To make a_1=0.
		}
	}
	for(i=n;i>=5;i--)
	{
		while(a[i]==1)// while
		{
			move(i-1,tag-2);
			move(2,i-1);
			tag--;
			move(tag-2,2);
		}
	}
	spj2();
	printf("%lld\n",ans);
	for(i=1;i<=ans;i++)
	{
		printf("%lld %lld\n",ansset[i][0],ansset[i][1]);
	}
	return 0;
}
```

---

## 作者：Semsue (赞：0)

感觉没有这么困难，顶多是个绿题，尤其是常数卡得这么不死的情况下。

以防万一小的情况直接跑暴力。

我们考虑不断把1挪到最后，假设当前串长这样 `??1??..1111` 那么进行操作 `?..???11111` $\to$ `????..11111` 即可。

最后有一种情况需要特判断，即 `100000..11111` 这样的，解决方法也很简单，把某个 `11` 换到最前面去即可。

还有一些小细节的处理可以参考代码。

```cpp
#include <bits/stdc++.h>
std :: string s;
int n;
std :: map<std :: string, int> mp;
std :: vector<std :: pair<int, int>> ans;
void move(int i, int j) {
	if (i == j) return;
	std :: swap(s[i - 1], s[j - 1]);
	std :: swap(s[i], s[j]);
	ans.emplace_back(i, j);
//	std :: cout << s << "\n";
}
void undo() {
	int i = ans.back().first, j = ans.back().second;
	std :: swap(s[i - 1], s[j - 1]);
	std :: swap(s[i], s[j]);
	ans.pop_back();
}
void dfs() {
	if (mp.find(s) != mp.end()) return;
	if (ans.size() > 10000) return;
	mp[s] = 1;
	bool ok = true, flg = false;
	for (int i = 0; i < n; i++) {
		if (s[i] == '1') flg = true;
		if (s[i] == '0' && flg == true) ok = false;
	}
	if (ok) {
		printf("%d\n", (int)ans.size());
		for (auto x : ans) printf("%d %d\n", x.first, x.second);
		exit(0);
	}
	int p = 0;
	for (int i = n - 1; ~i; i--) {
		if (s[i] == '.') {
			p = i;
			break;
		}
	}
	for (int i = 1; i < p - 1; i++) {
		move(i, p);
		dfs();
		undo();
	}
	for (int i = p + 2; i < n; i++) {
		move(i, p);
		dfs();
		undo();
	}
}
std :: mt19937 rnd(time(0));
int main() {
	std :: cin >> s;
	n = s.length();
	if (n <= 10) {
		dfs();
		puts("-1");
		return 0;
	}
	int j;
	for (j = n - 1; j >= 4; ) {
		bool flg = false;
//		printf("%d\n", j);
		for (int i = j - 2; i; i--) {
			if (s[i] == '1') {
				move(i, j);
				if (i < j - 2) move(j - 1, i);
				else {
					if (i >= 3) {
						move(1, i);
						move(j - 1, 1);
					} else {
						if (s[0] != '0') {
							move(n - 1, i);
							move(1, n - 1);
							move(j - 1, 1);
						}
					}
				}
				j--;
				flg = true;
				break;
			}
		}
		if (!flg) break;
	}
	if (s[0] != '0') {
		if (j == 3) {
			move(1, j);
			move(j + 1, 1);
		} else {
			move(2, j);
			move(j + 2, 2);
			move(1, j + 2);
			move(j, 1);
			move(2, j);
		}
		
	}
	printf("%d\n", (int)ans.size());
	for (auto x : ans) printf("%d %d\n", x.first, x.second);
	return 0;
}

```

---


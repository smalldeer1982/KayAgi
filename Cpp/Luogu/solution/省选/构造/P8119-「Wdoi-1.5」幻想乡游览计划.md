# 「Wdoi-1.5」幻想乡游览计划

## 题目背景

（此为背景，可以跳过）

自从姬虫百百世开挖了妖怪之山山顶的虹龙洞后，一成不变的幻想乡又多了可以探索的地方。充满心机的、监视着幻想乡一切动静的八云紫自然需要对其内部了如指掌，以此来掌握对幻想乡的绝对控制权。作为八云紫的式神的八云蓝，则奉命探索这块区域。随行的还有八云蓝的式神，橙。

虹龙洞开采的目的是为了获取其中的龙珠，而龙珠分布在虹龙洞内的各个角落。为了能够滴水不漏地得到更多的龙珠，百百世挖出了纵横交错的矿道，连接着各处的龙珠采集点。矿道之间相互交错，构成了一张层层叠叠的网。八云蓝和橙的任务则是分别到达过虹龙洞内所有的龙珠采集点，采集足够多的信息，以完成八云紫对虹龙洞彻底的监控目标。

然而，身处于黑暗的洞穴内，诺大的虹龙洞的环境十分险恶。极度缺氧的环境使得探索虹龙洞并不是一件容易的事情，因此八云蓝与橙不可能在虹龙洞内探索过长的时间。所幸的是，八云蓝可以联系到八云紫；而拥有操控境界能力的紫，则可以利用隙间交换蓝和橙的位置。

八云紫已经私通菅牧典从大天狗那里得到了虹龙洞的内部结构图。为了尽量减少在虹龙洞内滞留的时间，八云一家需要设计出一套可行的方案。

## 题目描述

虹龙洞内可以抽象成一张有 $n$ 个点和 $m$ 条的无向连通图，图可能有自环和重边。

紫会用隙间的能力，将蓝和橙传送到虹龙洞的某一结点上。此处使用隙间所花费的时间忽略不计。输出格式中的 $S$ 即代表初始传送到的结点。

接下来橙和蓝将会分别进行移动。每单位时间，蓝或者橙可以移动到与她们所在结点**直接相连**的结点上，或者紫使用隙间能力交换蓝和橙的位置。请注意：在这一单位时间内**只有一个人（蓝或者橙或者紫）可以行动**，并且此处的交换操作也是花费时间的。

现在，八云蓝请你构造出一个方案，使得橙和蓝**各自都**能经过虹龙洞的每个结点至少 $1$ 次，并且最后**都**回到一开始所在的结点 $S$ 以结束此次游览。在「输出格式」中蓝说明了构造方案的格式，你只要按格式输出构造方案告诉蓝就行了。

## 说明/提示

### 样例解释

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|}\hline
\textbf{操作次数} & \textbf{蓝的位置} &\textbf{橙的位置} \cr\hline
0 & 1 & 1 \cr\hline
1 & 2 & 1 \cr\hline
2 & 2 & 3 \cr\hline
3 & 3 & 2 \cr\hline
4 & 1 & 2 \cr\hline
5 & 1 & 1 \cr\hline
\end{array}
$$

### 判分方式

**本题使用 Special Judge。**

对于每组数据，若你输出的方案不合法（含不合法的移动操作，或者蓝或橙没有经过每个结点至少 $1$ 次，或者最后蓝和橙没有在 $S$ 点），你的分数为零分。否则你的分数将这样计算：

- 当 $k \leq 4\cdot n$ 时，你将获得该测试点 $20\%$ 的分数；
- 当 $k \leq 3\cdot n$ 时，你将获得该测试点 $40\%$ 的分数；
- 当 $k \le \lfloor\frac{11}{4} \cdot n\rfloor$ 时，你将获得该测试点 $70\%$ 的分数；
- 当 $k \le \lfloor\frac{8}{3} \cdot n\rfloor$ 时，你将获得该测试点所有的分数。

### 数据范围

**本题采用捆绑测试，且仅有一个 subtask，总成绩取各测试点最低分。**

对于 $100\%$ 的数据，$3\leq n,m \leq 5\times 10^5$。

### 校验器

为了方便选手测试，在附件中我们下发了 `checker.cpp` 文件，选手可以编译该程序，并使用它校验自己的输出文件。但请注意它与最终评测时所使用的校验器并不完全一致。你也不需要关心其代码的具体内容。

编译命令为：`g++ checker.cpp −o checker -std=c++14`。

checker 的使用方式为：`./checker <inputfile> <outputfile>`，参数依次表示输入文件与你的输出文件。

若你输出的数字大小范围不合法，则校验器会给出相应提示。若你的输出数字大小范围正确，但方案错误，则校验器会给出简要的错误信息：

1. `A x`，表示进行到第 $x$ 个操作时不合法。
2. `B x`，表示操作执行完毕后蓝/橙没有经过每个节点至少一次，其中 $x=0$ 表示蓝，$x=1$ 表示橙。
3. `C x`，表示操作执行完毕后蓝/橙没有回到 $S$ 点。其中 $x=0$ 表示蓝，$x=1$ 表示橙。
4. `Illeagl Output`，表示你输出了错误的操作。

若你的方案正确，校验器会给出 `OK`。

保证在输入正确、方案合法的情况下 checker 的运行时间小于 1s。

## 样例 #1

### 输入

```
3 3
1 2
2 3
1 3```

### 输出

```
1 5
Ran 2
Chen 3
Swap
Ran 1
Chen 1```

# 题解

## 作者：Lynkcat (赞：3)

第一次做出月赛1C，写个题解纪念一下，虽然这个1C可能相比较于别的1C简单了不少。

首先 $20$ 分做法非常好想，只要模拟两遍普通树上 dfs 的过程即可，这样子做复杂度是 $O(4n)$ 的。

我们发现了问题，因为在这个做法中实际上根本没用交换操作。不难想到一种做法，在 dfs 的时候，一个走，一个留在根，每走一个不是回溯的步，就交换一下，复杂度 $O(3n)$ 。可以拿到 $40$ 分。

进一步思考我们又发现，这个做法的缺点是，交换操作带来的价值太小，如果两个人在不同的两个点 $x,y$ 并且在 $x$ 处的人没到过 $y$，在 $y$ 处的人没到过 $x$，交换操作实际上会带来 $2$ 的收益，上面这个做法带来的收益只有 $1$。

进一步思考，我们发现两个人可以分开走各自的，然后每走到一个新点，就交换一下。

这样子做复杂度是 $O(2n+\max($第一个人走的点数$,$第二个人走的点数$))$。设第一个人走的点数为 $x$，另一个人为 $y$。容易发现我们把重心作为根的话可以做到让 $\min(x,y)\times 2\leq \max(x,y)$。所以最终复杂度最坏达到 $\frac{8}{3}n$ 。

[代码写的很怪，就只贴个链接了。](https://www.luogu.com.cn/paste/4vo09ew3)

---

## 作者：C1942huangjiaxu (赞：1)

显然连通图为树时限制是最强的，只要考虑树的情况。

先考虑 $3n$ 次操作，固定一个人在根节点，另一个人遍历整棵树，当一个节点的子树都遍历完时，如果根节点的人没有到过这个节点，就交换 $2$ 个人，这个可以根据儿子个数的奇偶性判断。

代码大概长这样：

```cpp
void solve(int x,int y,vector<int>&t,int &s){
	t.push_back(x);
	int ct=0;
	for(auto v:g[x])if(v!=y){
		solve(v,x,t,s);
		ct^=1,t.push_back(x);
	}
	if(!ct)++s,t.push_back(0);
}
```

发现因为固定了一个人在根节点，那么每次交换只能有 $1$ 的贡献，考虑让 $2$ 个人同时移动，这样每次交换可能有 $2$ 的贡献。

考虑将根节点的子树分成 $2$ 个集合 $S1,S2$，集合大小是子树大小之和，那么总操作次数就是 $\max(|S1|,|S2|)+2n$。

我们只要找到一种划分方式，使 $\max(|S1|,|S2|)\le \frac {2}{3}n$ 就行了。

首先不能有大小超过 $\frac{2}{3}n$ 的子树，我们取重心为根即可满足这个条件。

然后我们将所有子树按 $sz$ 从大到小排序，每次把当前最大的子树加入较小的集合中，这样就能满足条件。

证明考虑反证法，假设这样不满足条件，设 $|S2|\gt \frac{2}{3}n$，那么有 $|S1|\lt \frac{1}{3}n，|S2|-|S1|\gt \frac {1}{3}n$，说明我们最后往 $|S2|$ 中加入了一棵 $sz\gt \frac{1}{3}n$ 的子树，但因为我们是从大到小加入，所以这棵子树应该要先于 $S1$ 中的子树被加入，矛盾。

代码其实不难写：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+5;
int n,m,sz[N],s1,s2,rt;
bool vis[N];
vector<int>e[N],g[N],t1,t2;
vector<pair<int,int> >op;
bool cmp(int x,int y){
	return sz[x]>sz[y];
}
void dfs(int x){
	vis[x]=true,sz[x]=1;
	int mx=0;
	for(auto v:e[x])if(!vis[v]){
		g[x].push_back(v),g[v].push_back(x);
		dfs(v);
		sz[x]+=sz[v];
		mx=max(mx,sz[v]);
	}
	mx=max(mx,n-sz[x]);
	if(mx<=n/2)rt=x;
}
void solve(int x,int y,vector<int>&t,int &s){
	t.push_back(x);
	int ct=0;
	for(auto v:g[x])if(v!=y){
		solve(v,x,t,s);
		ct^=1,t.push_back(x);
	}
	if(!ct)++s,t.push_back(0);
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1,x,y;i<=m;++i){
		scanf("%d%d",&x,&y);
		e[x].push_back(y),e[y].push_back(x);
	}
	dfs(1);
	sort(g[rt].begin(),g[rt].end(),cmp);
	for(auto v:g[rt]){
		if(s1<=s2)solve(v,rt,t1,s1),t1.push_back(rt);
		else solve(v,rt,t2,s2),t2.push_back(rt);
	}
	while(s1<s2)++s1,t1.push_back(0);
	while(s2<s1)++s2,t2.push_back(0);
	int i=0,j=0,ct=0;
	while(i<t1.size()||j<t2.size()){
		while(i<t1.size()&&t1[i]!=0)op.emplace_back(ct,t1[i++]);
		while(j<t2.size()&&t2[j]!=0)op.emplace_back(ct^1,t2[j++]);
		if(i==t1.size())break;
		op.emplace_back(-1,-1),ct^=1;
		++i,++j;
	}
	printf("%d %d\n",rt,op.size());
	for(auto [x,y]:op){
		if(x==-1)puts("Swap");
		else if(x)printf("Chen %d\n",y);
		else printf("Ran %d\n",y);
	}
	return 0;
}
```

---


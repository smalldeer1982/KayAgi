# 似曾相识燕归来

## 题目背景

春雨将过，忽而燕鸣轻唤，唤起春波荡漾。春波荡漾，漾起去年的回忆。回忆生香，香满檐下。檐下燕巢残旧，不禁落泪，抬头望归来之燕，心中一动，却是旧时相识……

## 题目描述

$n$ 只燕在夕阳中飞过。按从前到后的顺序，第 $i$ 只燕的大小为 $p_i$，且 $p$ 是一个长度为 $n$ 的排列。

现在可以进行**至多 $L$ 次**如下操作：

- 选定三个整数 $i,j,k$ 满足 $1\le i<j<k\le n$，如果 $p_i>p_k$，交换第 $i,j$ 只燕；否则交换第 $j,k$ 只燕。

为了使队形整齐，我们希望燕是从前到后升序排列的，即 $\forall 1\le i\le n$ 都有 $p_i=i$。

问是否可以达成目标。若可以，请构造一组符合要求的操作。

## 说明/提示

**【提示】**

一个长度为 $n$ 的排列是一个满足 $1$ 到 $n$ 中的所有正整数恰好出现 $1$ 次的数组。例如，$[3,1,2]$ 是一个长度为 $3$ 的排列，而 $[5,5,1,2,3]$ 不是一个排列。

**【样例 1 解释】**

- 第一次操作中，$i=1,j=3,k=4$，由于 $p_1>p_4$，我们交换 $p_1,p_3$，此时 $p=[1,2,4,3]$；
- 第二次操作中，$i=2,j=3,k=4$，由于 $p_2<p_4$，我们交换 $p_3,p_4$，此时 $p=[1,2,3,4]$。

**【数据规模与约定】**

**本题采用捆绑测试。**

-  Subtask 1（5 points）：$n\le 3$。
-  Subtask 2（5 points）：$n\le 4$。
-  Subtask 3（5 points）：$T\le 50$，$n\le 8$。
-  Subtask 4（10 points）：$n\le 8$。
-  Subtask 5（25 points）：$L=n+2$。
-  Subtask 6（25 points）：$L=n+1$。
-  Subtask 7（25 points）：无特殊限制。

对于 $100\%$ 的数据，$1\le T\le 10^5$，$1\le n,\sum n\le 2\times 10^6$，$n\le L\le n+2$，$p$ 为一个 $1\sim n$ 的排列。

## 样例 #1

### 输入

```
1
4 4
4 2 1 3```

### 输出

```
2
1 3 4
2 3 4```

# 题解

## 作者：Ecrade_ (赞：9)

一个重要的观察：将 $1$ 调整到首位之后，其余元素可以任意交换位置。

令 $q$ 为 $p$ 的逆，记 $f(p)$ 为 $p$ 的置换环个数。

一个经典的结论：对于一个 $1\sim n$ 的排列 $p$，一次操作可以交换其中任意两个数的位置，则至少需要 $n−f(p)$ 次操作才能将 $p$ 升序排列，因为每次交换最多使 $f(p)$ 减少 $1$。一种可行的交换方案是，从小到大枚举 $i$，若 $p_i\neq i$，则交换 $p_i$ 和 $p_{q_i}$。

接下来考虑如何在将 $1$ 用尽量少的操作次数调整到首位的同时，使 $f(p)$ 尽量大。

下面默认第 $(i+1)$ 个 Case 不包含第 $1\sim i$ 个 Case。

### Case 1： $n\le 3$

特判即可。

### Case 2： $q_1=n$

容易发现这种情况下我们无法移动 $1$ 的位置，故输出 `-1`。

### Case 3： $q_1=1$

容易发现这种情况下我们可以利用 $1$ 交换排列中除了 $1$ 的任意两个数，故此时交换的最少次数为 $n-f(p)\le n$。

### Case 4： $\exists \ q_1<i\le n,p_i<p_1$

进行一次 $(1,q_1,i)$ 的操作即可转换为 Case 3，容易发现总最少操作次数仍为 $n-f(p)\le n$。

### Case 5： $p_1\ge 3$

由于 $1$ 右边的数均比 $p_1$ 大，故 $1$ 左边一定存在一个 $i\ (2\le i<q_1)$ 使得 $p_i<p_1$，进行一次 $(1,i,n)$ 的操作即可转换为  Case 4。由于两次操作后 $p_1=1$，故操作次数 $\le 2+(n-2)=n$。

### Case 6： $p_1=2,p_2=1,p_i=i\ (3\le i\le n)$

此种情况下的最少操作次数为 $5$ 次，一种可行的方案为 $(1,2,3),(1,2,3),(1,2,4),(1,3,4),(1,2,4)$。注意此时若 $n=L=4$ 需输出 `-1`。

### Case 7： $p_1=2,p_2=1$

找到一个 $i\ (3\le i<n)$ 满足 $p_i>p_{i+1}$，则我们可以进行 $(1,2,i),(1,2,i),(1,i,i+1)$ 三次操作使得 $p_1=1,p_2=2$，故操作次数 $\le 3+(n-3)=n$。

### Case 8：$p_1=2$

若 $q_n=2$，进行 $(1,2,q_1),(1,q_1,n)$ 两次操作，否则进行 $(1,2,q_n),(1,2,q_1),(1,q_1,n)$ 三次操作，由于至多三次操作后 $p_1=1,p_2=2$，故操作次数 $\le 3+(n-3)=n$。

时间复杂度为 $O(\sum n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,l,cnt,p[2000009],q[2000009];
struct st{int x,y,z;}ans[2000009];
inline int read(){
	int s = 0,w = 1;
	char ch = getchar();
	while (ch > '9' || ch < '0'){ if (ch == '-') w = -1; ch = getchar();}
	while (ch <= '9' && ch >= '0') s = (s << 1) + (s << 3) + (ch ^ 48),ch = getchar();
	return s * w;
}
void print(){
	if (cnt > l){puts("-1"); return;}
	printf("%d\n",cnt);
	for (int i = 1;i <= cnt;i += 1){
		printf("%d %d %d\n",ans[i].x,ans[i].y,ans[i].z);
	}
}
void add(int x,int y,int z){
	if (p[x] > p[z]) swap(p[x],p[y]),swap(q[p[x]],q[p[y]]);
	else swap(p[y],p[z]),swap(q[p[y]],q[p[z]]);
	ans[++ cnt] = (st){x,y,z};
}
void swapsort(){
	for (int i = 1;i <= n;i += 1) if (q[i] != i) add(1,min(i,q[i]),max(i,q[i]));
}
void work(){
	if (n == 1) return;
	if (q[1] == n){cnt = 1e9; return;}
	if (n == 2) return;
	if (q[1] == 1){swapsort(); return;}
	if (n == 3){
		if (p[1] == 2) cnt = 1e9;
		else add(1,2,3),add(1,2,3);
		return;
	}
	int pos = q[1];
	for (int i = pos + 1;i <= n;i += 1) if (p[i] < p[1]){
		add(1,pos,i),swapsort();
		return;
	}
	if (p[1] >= 3){
		for (int i = 2;i < pos;i += 1) if (p[i] < p[1]){
			add(1,i,n),add(1,pos,n),swapsort();
			return;
		}
		return;
	}
	if (p[2] == 1){
		for (int i = 3;i < n;i += 1) if (p[i] > p[i + 1]){
			add(1,2,i),add(1,2,i),add(1,i,i + 1),swapsort();
			return;
		}
		add(1,2,3),add(1,2,3),add(1,2,4),add(1,3,4),add(1,2,4);
		return;
	}
	if (q[n] > 2) add(1,2,q[n]);
	add(1,2,pos),add(1,pos,n),swapsort();
}
int main(){
	t = read();
	while (t --){
		n = read(),l = read(),cnt = 0;
		for (int i = 1;i <= n;i += 1) p[i] = read();
		for (int i = 1;i <= n;i += 1) q[p[i]] = i;
		work(),print();
	}
	return 0;
}
```


---

## 作者：Warriors_Cat (赞：4)

[洛谷题面传送门](https://www.luogu.com.cn/problem/P9347)。

题意：

* 给定 $n, L$ 和一个长为 $n$ 的排列 $p_i$。
* 每次操作为选一组 $1 \le i < j < k \le n$，将 $p_i$ 与 $p_k$ 中较大的数与 $p_j$ 交换。
* 问是否能在 $L$ 次操作内把原排列变为恒等排列。
* 多组数据。$\sum n \le 2\times 10^6$，$n \le L \le n+2$。

思路简单的大力分类讨论题。

---

Solution：

$n= 1, 2, 3$ 时可以特判掉，下设 $n \ge 4$。对 $1 \le i \le n$，用 $q_i$ 表示 $i$ 在第几项。当 $p_n = 1$ 时显然无解。下考虑 $p_n \neq 1$ 的情况。

题目约束了 $n \le L \le n+2$，这引导我们去思考：怎样的排列可以在 $n$ 步之内变为恒等排列？我们不妨先解决这个问题。

注意到一个显然的事实：**当 $p_1 = 1$ 时，后面 $n-1$ 项可以任意交换**。因此我们希望在 $2$ 步之内把 $1$ 操作到第 $1$ 项。

我们称 $p_1 = 1$ 的排列为“好排列”。设 $q_1 = j$，若 $\exists\ j< k\le n$ 使得 $p_1 > p_k$，则操作 $(1, j, k)$ 可得到好排列；若 $\forall \  j< k \le n, p_1 \le p_k$，当 $p_1 \ge 3$ 时，$1<q_2<j$，则依次操作 $(1, q_2, n)$ 和 $(1, j, n)$ 可得到好排列。故我们仅需考虑 $p_1 = 2$ 的情况。

发现 $p_1 = 2$ 的情况比较棘手，因此我们希望通过较少的操作让 $2$ 移到其它项，同时让 $p_1$ 尽可能大，最简单的想法就是让 $2$ 和 $n$ 可以交换。若 $q_n<q_1$，则依次操作 $(1, q_n, q_1)$ 和 $(1, q_1, n)$ 即可；若 $q_n > q_1$，当 $p_2 \neq 1$ 时依次操作 $(1, 2, q_n)$，$(1, 2, q_1)$ 和 $(1, q_1, n)$ 即可。这里看似用了 $3$ 步，实则在操作后有 $p_2 = 2$，为之后的变换节省了 $1$ 步，所以这也是可行的。故我们仅需考虑 $p_2 = 1$ 的情况。

此时排列为 $\{2, 1, p_3, \dots, p_n\}$，进一步我们希望把 $1$ 移到非第二项，从而化归为上一种情况。为此，我们找最大的下标 $t$ 使得 $p_t \neq t$，若 $t \neq 2$，则依次操作 $(1, 2, q_t)$，$(1, 2, q_1)$ 和 $(1, q_1, t)$ 即可；若 $t = 2$，则这个排列已经唯一确定：$\{2, 1, 3, 4, \dots, n\}$，此时依次操作 $(1, 3, n)$，$(1, 2, 3)$，$(1, 2, 3)$，$(1, 3, n)$，排列变为 $\{1, 2, n, 4, \dots, n - 1, 3\}$。我们惊奇地发现再操作 $1$ 次 $(1, 3, n)$ 后即可得到恒等排列。故当 $n \ge 5$ 时这种排列时有解的。

最后只剩下了 $n = 4$ 时 $\{2, 1, 3, 4\}$ 这个排列，手动枚举（或者敲一个简单的 bfs）就发现至少需要 $5$ 步才能变成恒等排列。

over. 

---

Code：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <vector>
#include <queue>
#include <map>
#include <set>
using namespace std;
#define rep(i, x, y) for(int i = x; i <= y; ++i)
inline int read(){
    int x = 0, f = 1; char ch = getchar();
    while(ch < '0' || ch > '9'){ if(ch == '-') f = -1; ch = getchar(); }
    while(ch >= '0' && ch <= '9'){ x = x * 10 + (ch ^ 48); ch = getchar(); }
    return x * f;
}
const int N = 2000010;
int n, m, p[N], q[N], a[N], b[N], c[N], cnt;
inline void swap(int &x, int &y){ x ^= y ^= x ^= y; }
inline void add(int x, int y, int z){
	a[++cnt] = x; b[cnt] = y; c[cnt] = z;
	if(p[x] > p[z]) q[p[x]] = y, q[p[y]] = x, swap(p[x], p[y]);
	else q[p[y]] = z, q[p[z]] = y, swap(p[y], p[z]);
}
inline void work(){
	if(p[1] == 1 && p[2] == 2 && p[3] == 3){ puts("0"); }
	if(p[1] == 1 && p[2] == 3 && p[3] == 2){ puts("1"); puts("1 2 3"); }
	if(p[1] == 2 && p[2] == 1 && p[3] == 3){ puts("-1"); }
	if(p[1] == 2 && p[2] == 3 && p[3] == 1){ puts("-1"); }
	if(p[1] == 3 && p[2] == 1 && p[3] == 2){ puts("2"); puts("1 2 3"); puts("1 2 3"); }
	if(p[1] == 3 && p[2] == 2 && p[3] == 1){ puts("-1"); }
}
inline void mian(){
	n = read(); m = read();
	rep(i, 1, n) p[i] = read(), q[p[i]] = i;
	if(n == 1){ puts("0"); return; }
	if(n == 2){ if(p[1] == 1) puts("0"); else puts("-1"); return; }
	if(n == 3){ work(); return; }
	if(q[1] == n){ puts("-1"); return; }
	if(p[1] == n) add(1, q[1], n);
	else if(p[1] != 1 && p[1] != 2){
		bool flag = 0;
		rep(i, q[1] + 1, n){
			if(p[1] > p[i]){
				flag = 1;
				add(1, q[1], i);
				break;
			}
		}
		if(!flag) add(1, q[2], n), add(1, q[1], q[2]);
	}
	else if(p[1] != 1){
		if(q[1] != 2){			
			if(q[n] > q[1]) add(1, 2, q[n]);
			add(1, q[n], q[1]); add(1, q[1], n);
		}
		else{
			int k = n; while(p[k] == k) --k;
			if(k != 2) add(1, 2, q[k]), add(1, 2, q[1]), add(1, q[1], k);
			else add(1, 3, n), add(1, 2, 3), add(1, 2, 3), add(1, 3, n);
		}
	}
	for(int x = 2; x <= n; ++x){ if(p[x] == x) continue; add(1, x, q[x]); }
	if(cnt <= m){
		printf("%d\n", cnt);
		rep(i, 1, cnt) printf("%d %d %d\n", a[i], b[i], c[i]);
	}
	else puts("-1");
	rep(i, 1, cnt) a[i] = b[i] = c[i] = 0; cnt = 0;
	return;
}
int main(){ int qwq = read(); while(qwq--) mian(); return 0; }
```


---

## 作者：RainWetPeopleStart (赞：0)

## 题解

某机构原题场 T2，赛时判错了 $p_1=2$，$p_2=1$ 的 case 导致没有场切，只得了 $n\le 4$ 和 $L\ge n+1$ 得分，~~菜死了~~。

分 $n\le 3$ 和 $n\ge 4$ 讨论。

### $n\le 3$

对 $n=1,2$ 直接做即可。

对 $n=3$，发现合法操作只有 $(1,2,3)$ 枚举做几次直接模拟即可。

### $n\ge 4$

首先，先考虑 $p_1=1$ 的情况如何做。

对于一个元素 $i$，设当前其出现的位置为 $c_i$，若 $c_i\neq i$，则做操作 $(1,i,c_i)$  即可将元素 $i$ 归位。

从小到大枚举 $i$，并依次归位即可。

设 $k$ 个元素满足 $p_i=i$，则此时我们最多需要 $\max(0,n-k-1)$ 次操作去完成排序。（因为最后一次操作会将两个元素归位）

令 $f(k)=\max(0,n-k-1)$。

考虑如何把 $1$ 挪到最左边。

如果 $c_1=n$，无解。因为想换出去需要 $p_k=1$，此时 $p_i>p_k$，则交换的是 $i,j$ ，故无解。

如果 $c_1=1$ 不用考虑。

如果存在 $j$ 满足 $j>c_i\wedge p_1>p_j$ 则做一次 $(1,c_1,j)$ 即可，操作次数小于 $1+f(1)\le n$。

否则，推广一下，若存在 $j_1,j_2$  满足 $j_1<c_1\wedge j_2>c_1\wedge p_{j_1}>p_{j_2}$，考虑把 $j_1$ 换到位置 $1$ 再沿用上面做法，发现做 $(1,j_1,c_1)$ 即可，操作数小于 $1+1+f(1)\le n$。

否则，$c_1$ 左边是 $[2,c_1]$ 的排列，右边是 $[c_1+1,n]$ 的排列。先 $(1,c_{c_1},c_1)$ 将 $c_1$ 换到最左边，再找到一个在 $[2,c_1]$ 范围的元素，把它换到右边（做 $(1,2,n)$）即可，这样沿用上面做法即可，发现 $c_1$ 会被换到位置 $c_1$ 故操作数小于 $1+1+1+f(2)\le n$。

发现还要判一种情况（上述方案在此失效），$p_1=2,p_2=1$。

若此时对 $i\in [3,n]$ 有 $p_i=i$，写个搜发现至少要做 $5$ 次操作，则 $n=L=4$ 时输出 $-1$ 其他直接输出即可。

否则，从左往右扫，找到第一个不满足 $p_i=i$ 的元素（$p_i>i$），做 $(1,2,i)$ 把 $p_1$ 换走，做 $(1,2,i)$  把 $p_i$ 换到第 $1$ 个，这时，一定有 $j\in[i+1,n]$ 满足 $p_j=i$，沿用上面做法即可。发现 $2$ 会被换到第 $2$ 个位置，故操作数小于 $1+1+1+f(2)\le n$。

## 代码


```cpp
#include<bits/stdc++.h>
#define pii pair<int,int>
#define mk make_pair
#define fi first
#define se second
using namespace std;
const int N=2e6+10;
int n;
int p[N];int L;
bool ok=0;
bool chk(){
    for(int i=1;i<=n;i++) if(p[i]!=i) return 0;return 1;
}int op[N][3];
int t[N];
int opt=0;
void add(int x,int y,int z){
    ++opt;op[opt][0]=x,op[opt][1]=y,op[opt][2]=z;
    if(p[x]>p[z]) swap(p[x],p[y]);
    else swap(p[y],p[z]);
}
void m1(){
    int ps=0;for(int i=1;i<=n;i++) if(p[i]==1) ps=i;
    pii mn=mk(0x3f3f3f3f,0);
    for(int i=ps+1;i<=n;i++) mn=min(mn,mk(p[i],i));
    if(p[1]>mn.fi){
        add(1,ps,mn.se);
    }else{
        pii mx=mk(0,0);
        for(int i=1;i<=ps-1;i++) mx=max(mx,mk(p[i],i));
        if(mx.fi<mn.fi){
            if(p[1]==2&&p[2]==1){
                int fla=0;
                int fl=1;
                for(int i=3;i<n;i++){
                    if(p[i]!=i){
                        fla=i;break;
                    }
                }for(int i=3;i<=n;i++){
                    if(p[i]!=i) fl=0;
                }
                if(fla!=0&&fl==0){
                    int vl=p[fla];
                    add(1,2,fla);add(1,2,fla);
                    int tmp=0;
                    for(int i=fla+1;i<=n;i++){
                        if(p[i]<vl){
                            tmp=i;break;
                        }
                    }assert(fla!=n);
                    add(1,fla,tmp);
                }else{
                    add(1,2,3);add(1,2,4);add(1,2,3);add(1,3,4);
                }
            }
            else{
                if(p[1]==2){
                    int pos=0;
                    for(int i=1;i<=ps-1;i++) if(p[i]==ps) pos=i;
                    add(1,pos,ps);
                }
                for(int i=1;i<=ps-1;i++){
                    if(p[i]<p[1]){
                        add(1,i,n);break;
                    }
                }
            }
        }else{
            bool fla=0;int pos=0;
            for(int i=1;i<=ps-1;i++) if(p[i]==ps) fla=1,pos=i;
            if(fla){
                add(1,pos,ps);
            }else{
                for(int i=1;i<=n;i++){
                    t[i]=0;
                }for(int i=ps+1;i<=n;i++) t[p[i]]=i;
                for(int i=1;i<=ps-1;i++){
                    if(fla) break;
                    if(p[i]<p[1]&&t[i]!=0){
                        fla=1;
                        add(1,i,t[i]);
                    }
                }if(!fla) add(1,mx.se,ps);
            }
        }for(int i=ps+1;i<=n;i++){
            if(p[i]<p[1]){
                add(1,ps,i);break;
            }
        }
    }
}
bool work(){//n-2
    opt=0;
    if(p[n]==1) return 0;
    int mn=n+1,mx=0;
    if(p[1]!=1) m1();
    for(int i=1;i<=n;i++) t[i]=0;
    for(int i=1;i<=n;i++) t[p[i]]=i;
    for(int i=2;i<=n;i++){
        if(t[i]==i) continue;
        swap(t[p[i]],t[i]);
        add(1,i,t[p[i]]);
    }
    if(opt>L) return 0;
    if(!chk()) return 0;
    return 1;
}bool work3(){
    opt=0;
    if(chk()) return 1;
    for(int i=1;i<=L;i++){
        add(1,2,3);
        if(chk()) return 1;
    }return 0;
}
void slv(){
    cin>>n>>L;
    for(int i=1;i<=n;i++) cin>>p[i];
    if(n<=3){
        if(n==3){
            if(work3()){
                cout<<opt<<'\n';
                for(int i=1;i<=opt;i++){
                    for(int j=0;j<=2;j++) cout<<op[i][j]<<' ';
                    cout<<'\n';
                }
            }else{
                cout<<-1<<'\n';
            }
        }else{
            opt=0;
            if(chk()) cout<<0<<'\n';
            else cout<<-1<<'\n';
        }
        return ;
    }
    if(work()){
        cout<<opt<<'\n';
        for(int i=1;i<=opt;i++){
            for(int j=0;j<=2;j++) cout<<op[i][j]<<' ';
            cout<<'\n';
        }
        
    }else{
        cout<<-1<<'\n';
    }
}
int main(){
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int t;cin>>t;while(t--) slv();
    cout.flush();cout.flush();
}
```

---


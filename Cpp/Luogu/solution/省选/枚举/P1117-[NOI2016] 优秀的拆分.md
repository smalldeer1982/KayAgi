# [NOI2016] 优秀的拆分

## 题目描述

如果一个字符串可以被拆分为 $\text{AABB}$ 的形式，其中 $\text{A}$ 和 $\text{B}$ 是任意**非空**字符串，则我们称该字符串的这种拆分是优秀的。  
例如，对于字符串 $ \texttt{aabaabaa} $ ，如果令 $\text{A}=\texttt{aab}$，$\text{B}=\texttt{a}$，我们就找到了这个字符串拆分成 $\text{AABB}$ 的一种方式。

一个字符串可能没有优秀的拆分，也可能存在不止一种优秀的拆分。  
比如我们令 $\text{A}=\texttt{a}$，$\text{B}=\texttt{baa}$，也可以用 $\text{AABB}$ 表示出上述字符串；但是，字符串 $\texttt{abaabaa}$ 就没有优秀的拆分。

现在给出一个长度为 $n$ 的字符串 $S$，我们需要求出，在它所有子串的所有拆分方式中，优秀拆分的总个数。这里的子串是指字符串中连续的一段。

以下事项需要注意：

1. 出现在不同位置的相同子串，我们认为是不同的子串，它们的优秀拆分均会被记入答案。
2. 在一个拆分中，允许出现 $\text{A}=\text{B}$。例如 $\texttt{cccc}$ 存在拆分 $\text{A}=\text{B}=\texttt{c}$。
3. 字符串本身也是它的一个子串。

## 说明/提示

### 样例解释

我们用 $S[i, j]$ 表示字符串 $S$ 第 $i$ 个字符到第 $j$ 个字符的子串（从 $1$ 开始计数）。

第一组数据中，共有三个子串存在优秀的拆分：  
$S[1,4]=\texttt{aabb}$，优秀的拆分为 $\text{A}=\texttt{a}$，$\text{B}=\texttt{b}$；  
$S[3,6]=\texttt{bbbb}$，优秀的拆分为 $\text{A}=\texttt{b}$，$\text{B}=\texttt{b}$；  
$S[1,6]=\texttt{aabbbb}$，优秀的拆分为 $\text{A}=\texttt{a}$，$\text{B}=\texttt{bb}$。  
而剩下的子串不存在优秀的拆分，所以第一组数据的答案是 $3$。

第二组数据中，有两类，总共四个子串存在优秀的拆分：  
对于子串 $S[1,4]=S[2,5]=S[3,6]=\texttt{cccc}$，它们优秀的拆分相同，均为 $\text{A}=\texttt{c}$，$\text{B}=\texttt{c}$，但由于这些子串位置不同，因此要计算三次；  
对于子串 $S[1,6]=\texttt{cccccc}$，它优秀的拆分有两种：$\text{A}=\texttt{c}$，$\text{B}=\texttt{cc}$ 和 $\text{A}=\texttt{cc}$，$\text{B}=\texttt{c}$，它们是相同子串的不同拆分，也都要计入答案。  
所以第二组数据的答案是 $3+2=5$。

第三组数据中，$S[1,8]$ 和 $S[4,11]$ 各有两种优秀的拆分，其中 $S[1,8]$ 是问题描述中的例子，所以答案是 $2+2=4$。

第四组数据中，$S[1,4]$，$S[6,11]$，$S[7,12]$，$S[2,11]$，$S[1,8]$ 各有一种优秀的拆分，$S[3,14]$ 有两种优秀的拆分，所以答案是 $5+2=7$。

### 数据范围

对于全部的测试点，保证 $1 \leq T \leq 10$。以下对数据的限制均是对于单组输入数据而言的，也就是说同一个测试点下的 $T$ 组数据均满足限制条件。

我们假定 $n$ 为字符串 $S$ 的长度，每个测试点的详细数据范围见下表：

| 测试点编号   | $n \leq$  | 特殊性质           |
| ------------ | --------- | ------------------ |
| $1 \sim 2$   | $300$     | $S$ 中所有字符相同 |
| $3 \sim 4$   | $2\,000$  | $S$ 中所有字符相同 |
| $5 \sim 6$   | $10$      |                    |
| $7 \sim 8$   | $20$      |                    |
| $9 \sim 10$  | $30$      |                    |
| $11 \sim 12$ | $50$      |                    |
| $13 \sim 14$ | $100$     |                    |
| $15$         | $200$     |                    |
| $16$         | $300$     |                    |
| $17$         | $500$     |                    |
| $18$         | $1\,000$  |                    |
| $19$         | $2\,000$  |                    |
| $20$         | $30\,000$ |                    |

## 样例 #1

### 输入

```
4
aabbbb
cccccc
aabaabaabaa
bbaabaababaaba
```

### 输出

```
3
5
4
7
```

# 题解

## 作者：Gypsophila (赞：169)

### Description 
求对每一个连续字串将它切割成形如 AABB 的形式的方案数之和
### Solution
显然 AABB 是由两个 AA 串拼起来的

考虑维护两个数组 a[i] 和 b[i] ，其中 a[i] 表示以 $i$ 结尾有多少个 AA 串，b[i] 表示以 $i$ 开头有多少个 AA 串

最后答案就是 $\sum \limits _{i=1}^{n-1}a[i]b[i+1]$ （就是两个串拼起来）

如何求 a[i] 和 b[i] 呢？

首先有一个非常显然的 n^2 哈希做法（对于每一个 $i$ 用 $j$ 扫一遍用哈希判断有几个 AA 串），有 95 分！

如何拿到最后的 5 分呢？考虑枚举一个 Len ，然后对于每个点求出他是否是一个 2 * Len 的 AA 串的开头 / 结尾。

我们每隔 Len 放一个点，这样每一个 长度为 2 * Len 的 AA 串都至少会经过两个相邻的点。

所以再转换为每两个相邻的点会对 a, b 产生多少贡献。

先求出这对相邻点所代表的前缀的最长公共后缀 LCS 和 所代表的后缀的最长公共前缀 LCP

如果 LCP + LCS < Len 就下面这种情况：

![](https://i.loli.net/2018/12/08/5c0b394224f12.png)

其中两个红线是关键点（相距为 Len），蓝线是LCS，绿线是LCP，LCP+LCS < Len

则有 
![](https://i.loli.net/2018/12/08/5c0b3a430c933.png)

这条紫线就是第一个可能满足条件的 AA 串

但此时我们会发现下图

![](https://i.loli.net/2018/12/08/5c0b3aa4cbd94.png)

其中两个红色荧光笔的部分在 AA 串中是对应的，但他们至少有一个位置并不相同 （不然LCP可以再长）

所以此时不会有任意一个长度为 2 * Len 的 AA 串满足条件。

如果 LCP + LCS >= Len 就有下面这种情况

![](https://i.loli.net/2018/12/08/5c0b3bb7dd8da.png)

此时中间必然就没有空隙。可以发现：

![](https://i.loli.net/2018/12/08/5c0b3c8bcaa8c.png)

粉色的是第一个 AA 串，可以发现它是可以分成两个相同的 A 串的（可以理解成中间没有缝隙了所以就没有不一样的了）

然后这个 AA 串可以一直往后滑动，每滑动一个位置都可以形成一个新的 AA 串知道 AA 串的后端点滑动到最右边的绿色端点。也就是滑动到棕色 AA 串

此时可以发现，每一个存在于红色荧光部分的点都可以作为一个新的 AA 串的开头

同理，每一个再绿色荧光笔的点可以作为一个新的 AA 串的结尾。

于是就将红色荧光笔的区间的 b 加上 1，绿色的 a 加上 1，就大功告成。

如何实现这个过程呢？复杂度是什么呢？

1. 枚举 Len ，每隔 Len 设置关键点：这个的复杂度是调和级数 $O(n \log n)$
2. 求 后缀LCP，前缀LCS：使用后缀数组 + st 表 做到 O(1) 查询
3.  区间加上 1 ： 差分维护就可以了。

至此，此题完结

### Code

[看代码戳这里](https://www.cnblogs.com/acfunction/p/10087144.html)

---

## 作者：何俞均 (赞：41)

广告：食用[$blog$](https://www.cnblogs.com/heyujun/p/10360053.html)体验更佳

考虑一个形如$AABB$的串是由两个形如$AA$的串拼起来的

那么我们设

$f[i]$:以位置$i$为结尾的形如$AA$串的个数

$g[i]$:以位置$i$为开头的形如$AA$串的个数
$$\therefore Ans=\sum_{i=1}^nf[i]*g[i+1]$$
题目的难点转化为求$f,g$。

但是，其实我们只要$O(n^2)$暴力求一下就有$95pts$了，

所以我们接下来考虑最后的$5pts$怎么拿：

我们枚举$A$的长度$len$

将所有位置为$len$的倍数的点设为关键点，

则如果一个$AA$满足要求

这个$AA$必过两个关键点，

那么我们要算的就是相邻两个关键点对答案的贡献：

记相邻两个关键点为$i,j$那么$j=i+len$

记$Lcp=lcp(suf(i), suf(j)),Lcs=lcs(pre(i-1),pre(j-1))$

那么，如果$Lcp+Lcs<len$，则不能构成$AA$

为什么呢？

相当于这样一种情况：
$$\underbrace{.......i-1}_{Lcs}\;\overbrace{\underbrace{i........}_{Lcp}\;....\underbrace{.......j-1}_{Lcs}}^{len}\;\underbrace{j........}_{Lcp}$$
这样子是不合法的。

反之，中间两段的$Lcp,Lcs$会有交，而我们这个$A$串的终点落在中间长度为$Lcp+Lcs-len+1$的交上都是可以的

因为这样的话平移一下可以保证紧跟着出现一个不重叠的$A$串

又因为串$A$起点和终点分别出现的位置是一段区间，所以直接分别在$f,g$上差分即可

复杂度是调和级数$O(nlogn)$。

具体细节看代码：

```cpp
#include <iostream> 
#include <cstdio> 
#include <cstdlib> 
#include <cstring> 
#include <cmath> 
#include <algorithm> 
#include <map> 
using namespace std; 
inline int gi() { 
    register int data = 0, w = 1; 
    register char ch = 0; 
    while (!isdigit(ch) && ch != '-') ch = getchar(); 
    if (ch == '-') w = -1, ch = getchar(); 
    while (isdigit(ch)) data = 10 * data + ch - '0', ch = getchar(); 
    return w * data; 
} 
const int MAX_N = 3e4 + 5;
char a[MAX_N]; 
int N, lg[MAX_N], f[MAX_N], g[MAX_N]; 
struct SuffixArray { 
	int sa[MAX_N], rnk[MAX_N], lcp[MAX_N]; 
	void buildSA() { 
        #define cmp(i, j, k) (y[i] == y[j] && y[i + k] == y[j + k]) 
		static int x[MAX_N], y[MAX_N], bln[MAX_N];
		memset(sa, 0, sizeof(sa)); 
		memset(rnk, 0, sizeof(rnk)); 
		memset(lcp, 0, sizeof(lcp)); 
		memset(x, 0, sizeof(x)); 
		memset(y, 0, sizeof(y)); 
		memset(bln, 0, sizeof(bln));
		int M = 122; 
		for (int i = 1; i <= N; i++) bln[x[i] = a[i]]++; 
		for (int i = 1; i <= M; i++) bln[i] += bln[i - 1]; 
		for (int i = N; i >= 1; i--) sa[bln[x[i]]--] = i; 
		for (int k = 1; k <= N; k <<= 1) { 
			int p = 0; 
			for (int i = 0; i <= M; i++) y[i] = 0; 
			for (int i = N - k + 1; i <= N; i++) y[++p] = i; 
			for (int i = 1; i <= N; i++) if (sa[i] > k) y[++p] = sa[i] - k;
			for (int i = 0; i <= M; i++) bln[i] = 0; 
			for (int i = 1; i <= N; i++) bln[x[y[i]]]++; 
			for (int i = 1; i <= M; i++) bln[i] += bln[i - 1]; 
			for (int i = N; i >= 1; i--) sa[bln[x[y[i]]]--] = y[i]; 
			swap(x, y); x[sa[1]] = p = 1;
			for (int i = 2; i <= N; i++) x[sa[i]] = cmp(sa[i], sa[i - 1], k) ? p : ++p;
			if (p >= N) break;
			M = p; 
		} 
		for (int i = 1; i <= N; i++) rnk[sa[i]] = i; 
		for (int i = 1, j = 0; i <= N; i++) {
			if (j) j--; 
			while (a[i + j] == a[sa[rnk[i] - 1] + j]) ++j; 
			lcp[rnk[i]] = j; 
		} 
	} 
	int st[16][MAX_N]; 
	void buildST() { 
		memset(st, 63, sizeof(st)); 
		for (int i = 1; i <= N; i++) st[0][i] = lcp[i]; 
		for (int i = 1; i <= 15; i++)
			for (int j = 1; j <= N; j++)
				st[i][j] = min(st[i - 1][j], st[i - 1][j + (1 << (i - 1))]); 
	} 
	int query(int l, int r) { 
		int _l = l, _r = r; 
		l = min(rnk[_l], rnk[_r]) + 1, r = max(rnk[_l], rnk[_r]);
		int t = lg[r - l + 1]; 
		return min(st[t][l], st[t][r - (1 << t) + 1]); 
	} 
} A, B; 
void Sol() {
	scanf("%s", a + 1); N = strlen(a + 1); 
	A.buildSA(), A.buildST(); 
	reverse(&a[1], &a[N + 1]); 
	B.buildSA(), B.buildST(); 
	memset(f, 0, sizeof(f)); 
	memset(g, 0, sizeof(g)); 
	for (int Len = 1; Len <= N / 2; Len++) { 
		for (int i = Len, j = i + Len; j <= N; i += Len, j += Len) { 
			int Lcp = min(A.query(i, j), Len), Lcs = min(B.query(N - i + 2, N - j + 2), Len - 1); 
			int t = Lcp + Lcs - Len + 1; 
			if (Lcp + Lcs >= Len) {
				g[i - Lcs]++, g[i - Lcs + t]--; 
				f[j + Lcp - t]++, f[j + Lcp]--; 
			} 
		} 
	} 
	for (int i = 1; i <= N; i++) f[i] += f[i - 1], g[i] += g[i - 1]; 
	long long ans = 0; 
	for (int i = 1; i < N; i++) ans += 1ll * f[i] * g[i + 1]; 
	printf("%lld\n", ans); 
} 
int main () { 
#ifndef ONLINE_JUDGE 
    freopen("cpp.in", "r", stdin); 
#endif 
	for (int i = 2; i <= 30000; i++) lg[i] = lg[i >> 1] + 1; 
	int T; scanf("%d", &T);
	while (T--) Sol(); 
	return 0; 
} 
```

---

## 作者：George1123 (赞：32)

[$\Huge\color{#a76699}\texttt{My Cnblogs}$](https://www.cnblogs.com/Wendigo/p/12930804.html)

---
> [NOI2016 优秀的拆分](https://www.luogu.com.cn/problem/P1117)

> $T$ 组测试数据。求字符串 $s$ 的所有子串拆成 $AABB$ 形式的方案总和。

> 数据范围：$1\le T\le 10$，$1\le n\le 3\cdot 10^4$。

---
这道题太神了，能一次做出这题的人往往是人形自走题库。真的全是套路！

---
令 $n=|s|$，$f_i$ 表示有几个以 $s_i$ **结尾**的 $AA$ 串，$g_i$ 表示有几个以 $s_i$ **开头**的 $BB$ 串。

$$\therefore ans=\sum_{i=1}^{n-1}f_i\cdot g_{i+1}$$

然后只需求 $f_i,g_i$。

套路地**为 $s$ 以及 $s$ 的反串建后缀数组并为 $height$ 数组装上 $st$ 表**。

于是就可以 $\Theta(1)$ 求**任意两个前缀的最长公共后缀**和**任意两个后缀的最长公共前缀**了。

---
**这时候求 $f_i$ 的 $\Theta(n^2)$ 的做法（$g_i$ 同）：**

枚举 $A$ 串长度 $w$，然后枚举 $s$ 中的下标 $l,r(r-l=w)$。

如果**两个后缀的最长公共前缀**$\ge w$，则 $f_{r+w-1}++$。

如下图，三条黄线间的两个串组成 $AA$ 串。

![1117a.jpg](https://i.loli.net/2020/05/21/nDOjgRtQyZPo3Nd.jpg)

**考虑一种套路优化（$g_i$ 同）：**

枚举了 $w$ 以后任何相距 $w$ 的下标是对应的。

所以可以在 $w$ 倍数的下标**设断点**，此时一个 $A$ 串至少要经过 $1$ 个断点。

枚举相邻两个断点 $l$ 和 $r$，求出它们的**前缀最长公共后缀长度 $lcs$** 和**后缀最长公共前缀长度 $lcp$** 之和 $len$：

表示**经过两个断点**且开头距离 $w$ 的最长公共子串。

如果 $len<w$，说明没有**同时经过这两个断点**的 $AA$ 串。

否则，$f_{r+lcp-(lcp+lcs-1)\to r+lcp-1}++$。

如下图，即**两条紫线**以及之间的子串为 $AA$ 串：

![1117b.jpg](https://i.loli.net/2020/05/21/SkZ9nzMcyLfWRIs.jpg)

$f_i,g_i$ 需要**区间加**，可以**差分**处理。

---
**时间复杂度 $\Theta(T\cdot n\log n)$。**

---
小蒟蒻讲不清楚，放代码吧：

```cpp
#include <bits/stdc++.h>
using namespace std;

//Start
typedef long long ll;
typedef double db;
#define mp(a,b) make_pair(a,b)
#define x first
#define y second
#define b(a) a.begin()
#define e(a) a.end()
#define sz(a) int((a).size())
#define pb(a) push_back(a)
const int inf=0x3f3f3f3f;
const ll INF=0x3f3f3f3f3f3f3f3f;

//Data
const int N=3e4;
int n,f[N+7],g[N+7];

//SuffixArray
struct SuffixArray{
	char s[N+7];
	int m,c[N+7],tp[N+7],rk[N+7],sa[N+7];
	int h[N+7],st[N+7][20];
	void csort(){
		for(int i=0;i<=m;i++) c[i]=0;
		for(int i=1;i<=n;i++) c[rk[i]]++;
		for(int i=1;i<=m;i++) c[i]+=c[i-1];
		for(int i=n;i>=1;i--) sa[c[rk[tp[i]]]--]=tp[i];
	}
	void build(){
		memset(c,0,sizeof c);
		memset(tp,0,sizeof tp);
		memset(rk,0,sizeof rk);
		memset(sa,0,sizeof sa);
		memset(h,0,sizeof h);
		memset(st,0,sizeof st);
		for(int i=1;i<=n;i++) rk[i]=s[i],tp[i]=i;
		m=128,csort();
		for(int w=1,p=1,i;p<n;w<<=1,m=p){
			for(p=0,i=n-w+1;i<=n;i++) tp[++p]=i;
			for(i=1;i<=n;i++)if(sa[i]>w) tp[++p]=sa[i]-w;
			csort(),swap(rk,tp),rk[sa[1]]=p=1;
			for(i=2;i<=n;rk[sa[i]]=p,i++)
				if(tp[sa[i]]!=tp[sa[i-1]]||tp[sa[i]+w]!=tp[sa[i-1]+w]) p++;
		}
		for(int i=1,j,k=0;i<=n;h[rk[i++]]=k)
			for(k=k?k-1:k,j=sa[rk[i]-1];s[i+k]==s[j+k];k++);
		for(int i=1;i<=n;i++) st[i][0]=h[i];
		for(int w=1;w<=18;w++)
			for(int i=1;i+(1<<w)-1<=n;i++)
				st[i][w]=min(st[i][w-1],st[i+(1<<(w-1))][w-1]);
	}
	int Lcp(int a,int b){
		int l=rk[a],r=rk[b];
		if(l>r) swap(l,r); l++;
		int k=log2(r-l+1);
		return min(st[l][k],st[r-(1<<k)+1][k]);
	}
}a,b;

//KonnyWen
void KonnyWen(){
	memset(f,0,sizeof f);
	memset(g,0,sizeof g);
	scanf("%s",&a.s[1]),n=strlen(&a.s[1]);
	for(int i=1;i<=n;i++) b.s[i]=a.s[n+1-i];
	a.build(),b.build();
	for(int i=1;i<=n;i++) f[i]=g[i]=0;
	for(int w=1;w<=(n>>1);w++)
		for(int i=w;i<=n;i+=w){
			int l=i,r=i+w;
			int lcp=min(w,a.Lcp(l,r));
			int lcs=min(w-1,b.Lcp(n-(l-1)+1,n-(r-1)+1));
			if(lcp+lcs>=w){
				int cov=lcp+lcs-w+1;
				f[r+lcp-cov]++,f[r+lcp]--;
				g[l-lcs]++,g[l-lcs+cov]--;
			}
		}
	for(int i=1;i<=n;i++) f[i]+=f[i-1],g[i]+=g[i-1];
	ll ans=0;
	for(int i=1;i<n;i++) ans+=f[i]*g[i+1];
	printf("%lld\n",ans);
}

//Main
int main(){
	int t; scanf("%d",&t);
	while(t--) KonnyWen();
	return 0;
}
```
---
**祝大家学习愉快！**

---

## 作者：bztMinamoto (赞：24)

    听说大佬们都是用SA做的	
	
    然而SA的时间复杂度的确很优秀，缺点就是看不太懂……
  
　　然后发现一位大佬用哈希华丽的过了此题，而且讲的特别清楚->[这里](https://www.cnblogs.com/ljh2000-jump/p/6370364.html)
  
　　我们只要考虑以每一个点结尾的$AA$串的个数$u[i]$和以每一个点开头的AA串的个数$v[i]$，答案就是$\sum _{i=1}^{n-1} u[i]*v[i+1]$
  
　　那么考虑如何求出$u$和$v$呢
  
　　我们考虑一下，枚举串$A$的长度$len$，然后每隔$len$个单位设置一个关键点。不难发现，每一个长度为$len*2$的$AA$串，必定经过两个关键点
  
　　然后考虑，只要求出相邻两个关键点往前的$LCS$和往后的$LCP$，如果$LCS+LCP>=len$，就表明存在长度为$len$的$AA$串。而且不难发现，所有经过这两个关键点的长度为$len$的$AA$串，肯定是连续的！所以我们可以找到这个区间，然后用前缀和差分，就可以避免区间修改了
  
　　说了这么多，到底怎么求$LCS$和$LCP$呢？（大佬：SA+ST表不是随便过的么）嗯，没错，二分。我们二分它们的长度，然后用哈希判断是否相等。这样虽然时间复杂度比起ST表多了个$log$，但起码更看得懂……
  
　　时间复杂度是枚举$len$的调和级数，加上二分，为$O(nlog^2n)$
  
　　ps:话说我也不明白调和级数是个什么玩意儿，只要知道枚举的复杂度是$\sum _{i=1}^n \frac{n}{i} =O(nlogn)$就行了……
  
　　pps:管那么多干嘛能A不就行了么……话说这题明明纯哈希暴力就有95……某大佬讲课的时候还以这题为例嘲笑NOI近几年的出题水平（逃）
```
//minamoto
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#define ll long long
using namespace std;
#define getc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
inline int read(){
    #define num ch-'0'
    char ch;bool flag=0;int res;
    while(!isdigit(ch=getc()))
    (ch=='-')&&(flag=true);
    for(res=num;isdigit(ch=getc());res=res*10+num);
    (flag)&&(res=-res);
    #undef num
    return res;
}
char sr[1<<21],z[20];int C=-1,Z;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
inline void print(ll x){
    if(C>1<<20)Ot();if(x<0)sr[++C]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]='\n';
}
const int N=30005,mod=3e7+7;
char s[N];int n;
ll hash[N],mo[N],u[N],v[N],ans;
inline ll gethash(int l,int r){
	ll now=hash[l]-hash[r]*mo[r-l];
	now%=mod,now+=mod,now%=mod;
	return now;
}
int main(){
	int T=read();mo[0]=1;for(int i=1;i<=30000;++i) mo[i]=mo[i-1]*31%mod;
	while(T--){
		n=0;char ch;
		while((ch=getc())!='\n') s[++n]=ch;
		memset(u,0,sizeof(u)),memset(v,0,sizeof(v));
		hash[n+1]=0;
		for(int i=n;i;--i) (hash[i]=hash[i+1]*31+s[i]-'a'+1)%=mod;
		for(int L=1;L*2<=n;++L){
			for(int i=L<<1;i<=n;i+=L){
				if(s[i]!=s[i-L]) continue;
				int l=1,r=L,last=i-L,pos=0;
				//二分查找lcp和lcs 
				while(l<=r){
					int mid=l+r>>1;
					if(gethash(last-mid+1,last+1)==gethash(i-mid+1,i+1)) pos=mid,l=mid+1;
					else r=mid-1;
				}
				int head=i-pos+1;
				l=1,r=L,pos=0;
				while(l<=r){
					int mid=l+r>>1;
					if(gethash(last,last+mid)==gethash(i,i+mid)) pos=mid,l=mid+1;
					else r=mid-1;
				}
				int tail=i+pos-1;
				head=max(head+L-1,i);//防止越过两块 
				tail=min(tail,i+L-1);//防止跑到后面的块 
				if(head<=tail){
					++u[head-2*L+1],--u[tail+1-2*L+1];
					++v[head],--v[tail+1];
					//为了差分
					//因为head-2*L+1到tail-2*L+1开头的AA串增加的
					//以他们的答案都可以++
					//然后以head到tail结尾的AA串也++ 
				}
			}
		}
		ans=0;
		for(int i=1;i<=n;++i) u[i]+=u[i-1],v[i]+=v[i-1];
		for(int i=1;i<n;++i) ans+=v[i]*u[i+1];
		print(ans);
	}
	Ot();
	return 0;
}
```

---

## 作者：λᴉʍ (赞：22)

# luogu1117 [NOI2016]优秀的拆分


---


https://www.luogu.org/problemnew/show/P1117

后缀数组我忘了。


此题哈希可解决95分（= =）


设$l_i$表示以i结尾的形如"AA"串的个数，$r_i$表示以i+1开头的形如"AA"串的个数。


则答案为 $\sum l_i r_i$


先$O(n)$hash预处理，然后$O(n^2)$处理出$l,r$数组


最后5分靠**肮脏的**打表


单哈希快，双哈希稳


这里只放双哈希


```cpp
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<cctype>
#include<cstring>
using namespace std;
#define il inline
#define vd void
#define rg register
#define sta static
il int gi(){
    int x=0,f=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();
    return x*f;
}
const int maxn=30001;
char S[maxn];
unsigned int ba[maxn],ha[maxn];
long long Ba[maxn],Ha[maxn];
il pair<unsigned int,long long>Hash(int l,int r){
    return make_pair(
        ba[maxn-r]*(ha[r]-ha[l-1]),
        Ba[maxn-r]*(Ha[r]-Ha[l-1]+1000000009)%1000000009
    );
}
int ll[maxn],rr[maxn];
int main(){
    int T=gi(),n;
    ba[0]=1;for(rg int i=1;i<maxn;++i)ba[i]=ba[i-1]*16943;
    Ba[0]=1;for(rg int i=1;i<maxn;++i)Ba[i]=Ba[i-1]*19260817%1000000009;
    while(T--){
        scanf("%s",S+1),n=strlen(S+1);
        if(n>2000){printf("563349754956\n161455324997\n76621205738\n70150901846\n40842068960\n6056659\n2820346\n3357795\n2628223\n10884");return 0;}
        for(rg int i=1;i<=n;++i)ha[i]=ha[i-1]+S[i]*ba[i];
        for(rg int i=1;i<=n;++i)Ha[i]=(Ha[i-1]+S[i]*Ba[i]%1000000009)%1000000009;
        for(rg int i=1;i<=n;++i){
            ll[i]=rr[i]=0;
            for(rg int j=i>>1;j;--j)if(Hash(i-j+1,i)==Hash(i-(j<<1)+1,i-j))++ll[i];
            for(rg int j=(n-i)>>1;j;--j)if(Hash(i+1,i+j)==Hash(i+j+1,i+(j<<1)))++rr[i];
        }
        rg long long ans=0;
        for(rg int i=1;i<=n;++i)ans+=ll[i]*rr[i];
        printf("%lld\n",ans);
    }
    return 0;
}
```

---

## 作者：big_news (赞：15)

提供一个使用 runs 的做法，时间复杂度 $O(n\log n)$。

这个做法完全不需要 SA 预处理 LCP，用到的最高妙的算法就是二分哈希，但是时间复杂度依然是优秀的一个 $\log$。lg 上用时最慢的点用了 40ms，其它都是 2~3ms，看上去做一次询问 1e6 根本不成问题。

前置知识：[Lyndon 分解](https://www.luogu.com.cn/problem/P6114)

Lyndon 分解网上资料很多，这部分不在赘述，只补充一部分定义。

- 周期（Period）：称 $l$ 是串 $s$ 的周期，当且仅当 $\forall i\in[1,|S|-l],\text{s.t. } s[i]=s[i+l]$。

- runs：称三元组 $r=(i,j,p)$ 是 $s$ 的 run，当且仅当 $s[i:j]$ 的最小周期为 $p$，且 $2p\le j-i+1$，且 $s[i:j]$ 是极长的一段最小周期为 $p$ 的串。

- Lyndon 串：设 $<_\iota$ 是比较运算符，其中 $\iota=0/1$，分别对应两种相反的比较，这里令 $<_0\Leftrightarrow<,<_1\Leftrightarrow >$。我们称 $s$ 是关于 $<_\iota$ 的 Lyndon 串，当且仅当 $\forall i\in [2,|s|], s<_\iota s[i:|s|]$。

- Lyndon 分解：称 $a_1a_2...a_n=s$ 是 $s$ 关于 $<_\iota$ 的 Lyndon 分解，当且仅当所有 $a_i$ 均是关于 $<_\iota$ 的 Lyndon 串，且 $a_i\not<_\iota a_{i+1}$。可以证明，一个串的 Lyndon 分解存在且唯一。

- Lyndon Root：称 $\lambda=s[i_\lambda:j_\lambda]$ 是一个 run $r=(i,j,p)$ 关于 $<_\iota$ 的 Lyndon Root，当且仅当 $[i_\lambda:j_\lambda]\subseteq [i,j]$，且 $\lambda$ 是一个 Lyndon 串。

考虑如何求出一个串的所有 run。

我们把串 Lyndon 分解，然后枚举一个 $i$，设 $ed[i]$ 是这一段 Lyndon 分解的边界，那么以 $i$ 开头的 Lyndon 子串的右端点不会超过 $ed[i]$，一段 Lyndon Root 也必然是 $s[i:ed[i]]$ 的子串。

我们可以二分哈希找到包含 $s[i:ed[i]]$ 的极长循环子串 $s[l:r]$，如果这段子串合法（满足 runs 的定义），那么就找到了一个 run。显然一个 $s[l:r]$ 可能被统计多次，我们应当取周期最小的那一次。

如果对 $\iota=0/1$ 均做一遍这样的操作，就可以得到所有的 run。

然后考虑计算“以某个位置结尾的平方串的数量”和“以某个位置开头的平方串的数量”，显然一个平方串会自然地对应一个 run 的子串。

The Runs Theorem 指出，一个串的 run 的数量不超过串长，那么我们接下来只要枚举一个 run，然后枚举最小周期的倍数 $l$。因为 run 满足它是极长的一段，那么在这一段里面每个长为 $l$ 的子串肯定都是一个平方串，我们直接在这一段里面差分即可。

可以证明，这一部分的复杂度不超过 $O(n\log n)$。因此总复杂度 $O(n\log n)$，代码复杂度极低。

参考实现：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define pb push_back
#define LL long long
const int CN = 3e4 + 10;
const int P = 191011109;
const int B = 39; int pB[CN];
int read(){
    int s = 0, ne = 1; char c = getchar();
    for(;c < '0' || c > '9';c = getchar()) if(c == '-') ne = -1;
    for(;c >= '0' && c <= '9';c = getchar()) s = (s << 1) + (s << 3) + c - '0';
    return s * ne;
}
int add(int x, int y) {return x + y >= P ? x + y - P : x + y;}
int ha[CN];
int get(int l, int r) {return add(ha[r], P - (1ll * ha[l - 1] * pB[r - l + 1] % P));}
int T, n; char ch[CN]; 
int LCP(int l1, int r1, int l2, int r2){
    if(ch[l1] != ch[l2]) return 0;
    int l = 1, r = min(r1 - l1 + 1, r2 - l2 + 1);
    while(l < r){
        int mid = (l + r + 1) >> 1;
        if(get(l1, l1 + mid - 1) == get(l2, l2 + mid - 1)) l = mid;
        else r = mid - 1;
    }
    return l;
}
int LCS(int l1, int r1, int l2, int r2){
    if(ch[r1] != ch[r2]) return 0;
    int l = 1, r = min(r1 - l1 + 1, r2 - l2 + 1);
    while(l < r){
        int mid = (l + r + 1) >> 1;
        if(get(r1 - mid + 1, r1) == get(r2 - mid + 1, r2)) l = mid;
        else r = mid - 1;
    }
    return l;
}
bool le(int l1, int r1, int l2, int r2){
    if(l1 == l2) return r1 < r2;
    int l = LCP(l1, r1, l2, r2);
    if(l1 + l > r1 || l2 + l > r2) return r1 - l1 < r2 - l2;
    return ch[l1 + l] < ch[l2 + l];
}
class PAIR{
  public: int l, r, p;
    bool operator < (const PAIR &o) const{
        return l ^ o.l ? l < o.l : (r ^ o.r ? p < o.p : r < o.r);
    }
    bool operator == (const PAIR &o) const{
        return l == o.l && r == o.r;
    } 
} ;
PAIR mp(int a, int b, int c) {PAIR o; o.l = a, o.r = b, o.p = c; return o;}
vector<PAIR> runs; int stk[CN], ed[CN], top;
void lyndon(){
    top = 0;
    for(int i = n; i; i--){
        stk[++top] = i;
        while(top > 1 && le(i, stk[top], stk[top] + 1, stk[top - 1])) top--;
        ed[i] = stk[top];
    }
    for(int i = 1; i <= n; i++){
        int j = ed[i], lcs = LCS(1, i - 1, 1, j), lcp = LCP(i, n, j + 1, n), l, r;
        l = i - lcs, r = j + lcp;
        if((r - l + 1) / (j - i + 1) > 1) runs.pb(mp(l, r, j - i + 1));
    }
}
int f[CN], g[CN];
int main()
{
    // freopen("_in.in", "r", stdin);
    n = 3e4, pB[0] = 1;
    for(int i = 1; i <= n; i++) pB[i] = 1ll * pB[i - 1] * B % P;
    T = read();
    while(T--){
        scanf("%s", ch + 1), n = strlen(ch + 1);
        for(int i = 1; i <= n; i++) ha[i] = add(1ll * B * ha[i - 1] % P, ch[i] - 'a');
        runs.clear();
        lyndon();
        for(int i = 1; i <= n; i++) ch[i] = 'a' + 'z' - ch[i];
        lyndon();
        sort(runs.begin(), runs.end());
        int len = unique(runs.begin(), runs.end()) - runs.begin();
        for(int i = 0; i < len; i++){
            int l = runs[i].l, r = runs[i].r, p = runs[i].p;
            for(int L = p + p; L <= r - l + 1; L += p + p){
                g[l]++, g[r - L + 2]--;
                f[l + L - 1]++, f[r + 1]--;
            }
        }
        for(int i = 1; i <= n; i++) f[i] += f[i - 1], g[i] += g[i - 1];
        LL ans = 0;
        for(int i = 1; i < n; i++) ans += 1ll * f[i] * g[i + 1];
        printf("%lld\n", ans);
        for(int i = 0; i <= n + 1; i++) f[i] = g[i] = 0;
    }
    return 0;
}
```

---

## 作者：Macesuted (赞：14)

[P1117](https://www.luogu.com.cn/problem/P1117)

跟这道题很像:[CF319D](https://www.luogu.com.cn/problem/CF319D)（这也是黑色的）

# 分析

这是一道后缀SA+ST的题目，但是~~众所周知~~字符串哈希是一种异常优秀的算法，所以我们使用字符串哈希解决这一道问题。在这道题中字符串哈希相比于SA的方法虽然慢了一个$O(logn)$，但是依旧在复杂度可承受范围内。

在这道题中我们需要求出拆分为AABB形态的方案数量。而我们发现AABB形态就是由两个AA状态的字符串连接形成。

如果我们设$A_i$表示以i位结尾的AA串数量，以$B_i$表示以i位开头的AA串数量。则很显然若我们将第i位及以前的部分放一个AA串，在第i+1及以后放一个AA串，他们就可以连在一起成为一个AABB串，所以当前状态对答案的贡献即为$A_i * B_i$。

如果我们可以求解出$A$和$B$，则答案即为：

$$\sum\limits_{i=1}^{n-1}A_i*B_{i+1}$$

现在的问题就是如何求解出A数组与B数组。

如果我们在字符串上每隔$len$设置一个观察点，相邻观察点的最长公共前缀（LCP）与最长公共后缀（LCS）加起来构成的字符串即为经过两点上的最长相同串，并且若$LCP+LCS>=len$，说明它们相交。若相交有重叠部分，则我们可以通过平移得到多个可行的摆放方案，可以缩短两个区间的尾部，也可以缩短两个区间的头部以使他们不重合（详见代码）。

至于如何求LCP和LCS，当然可以用SA，不过我们这里还是采用字符串哈希，毕竟它写起来十分简易。

# 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

const int mod = 1e9 + 7;
const int maxn = 30005;

int a[maxn], b[maxn];
long long w[maxn], p[maxn];
char s[maxn];

inline int get(int l, int r)
{ //计算字符串中l~r段的哈希值
	return ((w[r] - w[l - 1] * p[r - l + 1]) % mod + mod) % mod;
}

int n, now;

int lcp(int x, int y) //求最长前缀
{
	int l = 0, r = now;
	while (l < r)
	{
		int mid = l + r + 1 >> 1;
		if (get(x - mid + 1, x) == get(y - mid + 1, y))
			l = mid;
		else
			r = mid - 1;
	}
	return l;
}

int lcs(int x, int y) //求最长后缀
{
	int l = 0, r = n - y + 1;
	while (l < r)
	{
		int mid = l + r + 1 >> 1;
		if (get(x, x + mid - 1) == get(y, y + mid - 1))
			l = mid;
		else
			r = mid - 1;
	}
	return l;
}

int main()
{
	int T;
	scanf("%d", &T);
	while (T--)
	{
		memset(a, 0, sizeof(a));
		memset(b, 0, sizeof(b));
		scanf("%s", s + 1);
		n = strlen(s + 1);
		p[0] = 1;
		for (int i = 1; i <= n; i++)
		{ //字符串哈希
			p[i] = p[i - 1] * 31 % mod;
			w[i] = (w[i - 1] * 31 + s[i] - 'a') % mod;
		}
		for (int len = 1; len <= n; len++)
		{							   //从小到大枚举删除区间的长度
			int j = len, k = len << 1; //两个观察点
			now = len;
			while (k <= n)
			{
				int LCP = lcp(j, k), LCS = lcs(j, k);
				int hd = max(k - LCP + len, k), tl = min(k + LCS - 1, k + len - 1); //两个块的尾位置
				if (hd <= tl)
				{
					a[hd]++, a[tl + 1]--;						  //两个尾部之间的空间
					b[hd - len * 2 + 1]++, b[tl - len * 2 + 2]--; //两个头部之间的空间
				}
				j += len, k += len; //转移到下一个观察点
			}
		}
		for (int i = 1; i <= n; i++)
			a[i] += a[i - 1], b[i] += b[i - 1];
		long long answer = 0;
		for (int i = 1; i < n; i++)
			answer += a[i] * b[i + 1];
		printf("%lld\n", answer);
	}
	return 0;
}
```

---

## 作者：2014吕泽龙 (赞：12)

这道题不管采用Hash，后缀数组还是自动机，网上大部分的题解都采用了关键点+调和级数这个操作。本蒟蒻想不到关键点这个操作，所以采用的是一种较为繁琐的$O(nlog^2)$做法。

首先肯定将问题转化成对于每个$i$求以$i$为边界的$AA$结构个数，当然前缀后缀分别求一遍，以下默认是前缀。

考虑形式化这个问题，对于某个前缀$i$，求所有的前缀$j(j<i)$,使得$i,j$的最长公共后缀的长度大于$j-i$，也就是$|\{j|j<i,i-j\le |Lcs(S_{1,j},S_{1,i})|\}|$

对于后缀前缀的问题，我们一般将他们放到后缀自动机的$parent$树上考虑，由于后缀自动机的$parent$树相当于是将每个前缀逆序插入$Trie$，所以某两个前缀的$Lcs$对应的就是他们$parent$树上的$Lca$。

所以转化成树上给若干个关键点（对应的是字符串的前缀），对于每个$x$,求$\{y|mx_x-mx_y\le mx_{lca(x,y)}\}$。

考虑采用树上启发式合并，对于每个节点建立一颗动态开点线段树，我们让父亲继承重儿子的线段树，把其他子树中的线段树的节点暴力插入合并。

插入某个节点的时候，考虑线段树内的节点对其的贡献，和它对线段树内节点的贡献。前者用一个区间询问即可，否则在线段树上打标记，但这个线段树要被拆开的时候再把暴力标记推下去贡献到答案上即可。

每个节点插入的之后其所在线段树大小翻倍，所以之多插入$log$次，总复杂度$O(nlog^2)$

[代码请转到原blog食用](https://blog.csdn.net/lvzelong2014/article/details/89048132)


---

## 作者：yyyuuu (赞：8)

看了一圈题解没有后缀自动机的题解，不过毕竟后缀自动机后缀数组一家人，这里和大家分享后缀自动机的做法。

思路是一样的，处理出有多少个AA串以i开头，记做f[i],有多少个AA串以i结尾，记做g[i]，那么ans就是所有的g[i]f[i+1]

以下用pre(i)表示以i结尾的前缀，suffix(i)表示以i开头的后缀。

怎么去求g与f数组呢，考虑AA的拼接，设它的接点是第二个A开始的位置。设一个A的长度为L，那么对于一个长度为L的区间[i,j]来说，设pre(i-1)与pre(j-1)的最长公共后缀长度为x suffix(i)与suffix(j)的最长公共前缀长度为y，那么[j-x,i+y+1]都能作为接点(注意[i-x,i+y-1] 与 [j-x,j+y-1]是相同的子串

为了不统计重，区间[i,j]只统计接点在[i,j]范围内的AA串，所以x与L取min，y与L-1取min。

现在问题的步骤便出来了：
1.枚举一个A的长度L。

2.枚举i=KL,j=i+L,统计接点在区间[i,j]中的AA串对于f与g的贡献：

3.查询x与y，定义如上所示。
      
4.如果x+y<L,接不上，没有贡献。
      
5.否则每个[i-x,i-x+(x+y-L)]区间内的点都能作为AA串的左端点，当然，其右端点为[j+y-1-(x+y-L),j+y-1]，建议画图理解。发现每个区间对于f与g的贡献相当于一个区间加1，所以差分点修改。
      
6.最后统计前缀和即可求出f与g数组。ans=所有g[i]f[i+1] 

那么问题的关键是:怎么求前缀的最长公共后缀?后缀数组可以，当然后缀自动机也行，记录下插入第i个点时的np节点位置tag[i],那么pre(i)与pre(j)的最长公共前缀即为mx(Rg集合的max)[lca(tag[i],tag[j])](parent树上的)

后缀的最长公共前缀?倒着再建一个自动机，这上面的前缀的最长公共后缀即为原串的后缀的最长公共前缀。

下面是代码，有变量名与讲解时不一样
```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <iostream>
using namespace std ; 

struct SAM {
	int sn[60005][26] , fa[60005] , mx[60005] , tag[60005] , las , lzw ;
	int tot , dep[60005] , des[60005] , nxt[60005] , hd[60005] , f[60005][18] ; 
	void insert ( int x , int id ) 
	{
		int np = ++lzw , nd = las ; mx[np] = mx[las] + 1 ; las = np ; tag[id] = np ; 
		while ( nd != -1 && !sn[nd][x] ) sn[nd][x] = np , nd = fa[nd] ;
		if ( nd == -1 ) { fa[np] = 0 ; return ; }
		int q = sn[nd][x] ; 
		if ( mx[q] == mx[nd] + 1 ) { fa[np] = q ; return ; } 
		int nq = ++lzw ; 
		for ( int i = 0 ; i < 26 ; i++ ) sn[nq][i] = sn[q][i] ; 
		fa[nq] = fa[q] ; mx[nq] = mx[nd] + 1 ; 
		fa[q] = fa[np] = nq ; 
		while ( nd != -1 && sn[nd][x] == q ) sn[nd][x] = nq , nd = fa[nd] ;       
	}
	void getway ( int x , int y ) 
	{
		tot++ ; des[tot] = y ; nxt[tot] = hd[x] ; hd[x] = tot ; 
	}
	void dfs ( int u ) 
	{
		for ( int k = hd[u] ; k ; k = nxt[k] ) { dep[des[k]] = dep[u] + 1 ; dfs ( des[k] ) ; } 
	}
	void init ( ) 
	{
		for ( int i = 1 ; i <= lzw ; i++ ) { f[i][0] = fa[i] ; getway ( fa[i] , i ) ; } ; 
		for ( int k = 1 ; k <= 17 ; k++ ) 
		    for ( int i = 1 ; i <= lzw ; i++ ) 
		        f[i][k] = f[f[i][k-1]][k-1] ; 
		dfs ( 0 ) ; 
	}
	int query ( int u , int v ) 
	{
		u = tag[u] , v = tag[v] ; 
		if ( dep[u] < dep[v] ) swap ( u , v ) ; 
		while ( dep[u] > dep[v] ) { int ij = 0 ; while ( dep[f[u][ij+1]] >= dep[v] ) ij++ ; u = f[u][ij] ; }
		while ( u != v ) { int ij = 0 ; while ( f[u][ij+1] != f[v][ij+1] ) ij++ ; u = f[u][ij] ; v = f[v][ij] ; } 
		return mx[u] ;
	} 
} samp , saml , zero ; 

char cp[30005] ; 
int T ; 
int chf1[30005] , chf2[30005] ;  
int main ( ) 
{
	scanf ( "%d" , &T ) ; 
	zero.fa[0] = -1 ; 
	while ( T-- ) 
	{
		scanf ( "%s" , cp ) ; 
		int l = strlen ( cp ) ; 
		memset ( chf1 , 0 , sizeof ( chf1 ) ) ; 
		memset ( chf2 , 0 , sizeof ( chf2 ) ) ; 
		samp = zero ; saml = zero ; 
		for ( int i = 0 ; i < l ; i++ ) samp.insert ( cp[i] - 'a' , i + 1 ) ;
		for ( int i = l ; i >= 1 ; i-- ) saml.insert ( cp[i-1] - 'a' , i ) ;  
		samp.init ( ) ; saml.init ( ) ;
		for ( int len = 1 ; 2 * len <= l ; len ++ ) 
		{
			for ( int i = len ; i + len - 1 <= l ; i += len )
			{
				int j = i + len , hm = 0 , qm = 0 ; 
				if ( j <= l ) hm = min ( saml.query ( i , j ) , len ) ; // 保证AA的两个A 的分界节点在i，j之间 
				if ( i > 1 ) qm = min ( samp.query ( i - 1 , j - 1 ) , len - 1 ) ;
				if ( qm + hm >= len ) 
				{
					chf1[j+hm]-- ; chf1[j+hm-1-(qm+hm-len)]++ ;
					chf2[i-qm]++ ; chf2[i-qm+1+(qm+hm-len)]-- ;  
				} 
			}
		} 
		for ( int i = 1 ; i <= l ; i++ ) chf1[i] += chf1[i-1] , chf2[i] += chf2[i-1] ; 
		long long ans = 0 ; 
		for ( int i = 2 ; i <= l ; i++ ) ans += 1ll * chf1[i-1] * chf2[i] ; 
		cout << ans << '\n' ; 
	}
}
```

---

## 作者：Jμdge (赞：6)

初学后缀自动机的同学就别来做这道思维题了

推荐做这些题：

[SPOJ#7258 SUBLEX"Lexicographical Substring Search"]()

[BZOJ#2555 Substring]()

[SPOJ#8222 NSUBSTR"Substrings"]()

[SPOJ#1812 LCS2"Longest Common Substrings II"]()

[BZOJ#3998 弦论]()

 
（上面没有链接的，自己 $search$ 吧）

# problem

给一个字符串，求它所有子串的优秀拆分数

# noteskey


思路和楼上大佬是一样的，就是考虑找到以 i 开头、结尾的 $AA(BB)$ 数量 $pre[i], suf[i]$

然后答案加上所有的 $\sum pre[i-1]·suf[i]$ 就好了




# solve

考虑如何处理出 pre 和 suf 数组

我们考虑枚举长度，然后得到间隔为 $len $的两个端点 $i = k·len ,~~ j=i+len$ ，找到他们的 LCP （长度为 x） 和 LCS （长度为 y ），对于$ [j-x,i+y+1]$  这一段可以做断点的区间整体 +1 ，但是这样可能要用线段树维护？那么我们差分转移就好了，反正中间过程没有询问的

然后 SAM 是可以求 LCS 的，那么 LCP 的话只要建个反串在上面跑就好了



(其实 hash 可以更加轻松的解决掉这些处理的问题，emmm 做这题的话如果不是为了练 SAM 还是写 hash 比较好...)


# code

```cpp
//by Judge
#include<map>
#include<cstdio>
#include<cstring>
#include<iostream>
#define ll long long
#define fp(i,a,b) for(int i=(a),I=(b)+1;i<I;++i)
#define fd(i,a,b) for(int i=(a),I=(b)-1;i>I;--i)
#define go(G,u) for(int i=G.head[u],v=G.e[i].to;i;v=G.e[i=G.e[i].nxt].to)
using namespace std;
const int M=6e4+3;
typedef int arr[M];
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline int Min(int a,int b){return a<b?a:b;}
inline void reads(string& s){ char c=getchar();
	for(;!isalpha(c);c=getchar());
	for(;isalpha(c);c=getchar()) s+=c;
} char sr[1<<21],z[20]; int CCF=-1,Z;
inline void Ot(){fwrite(sr,1,CCF+1,stdout),CCF=-1;}
inline void print(ll x,char chr='\n'){ if(CCF>1<<20) Ot();
	for(;z[++Z]=x%10+48,x/=10;); for(;sr[++CCF]=z[Z],--Z;); sr[++CCF]=chr;
} int n; arr res1,res2; string s;
struct SAM{ arr c,sa,fa,len,tag;
	arr f,son,top,siz,dep;
	int cnt,las; map<char,int> to[M];
	struct Gr{ int pat,head[M];
		struct Edge{ int to,nxt; }e[M<<1];
		inline void add(int u,int v){
			e[++pat]={v,head[u]},head[u]=pat;
			e[++pat]={u,head[v]},head[v]=pat;
		}
	}G;
	inline void insert(char c,int id){ int p=las;
		int np=++cnt; las=np,tag[id]=np,len[np]=len[p]+1;
		for(;p&&!to[p][c];p=fa[p]) to[p][c]=np;
		if(!p) fa[np]=1;
		else{ int q=to[p][c];
			if(len[q]==len[p]+1) fa[np]=q;
			else{ int nq=++cnt;
				len[nq]=len[p]+1,to[nq]=to[q];
				fa[nq]=fa[q],fa[q]=fa[np]=nq;
				for(;p&&to[p][c]==q;p=fa[p]) to[p][c]=nq;
			}
		}
	}
	void dfs(int u,int fa){ siz[u]=1;
		go(G,u) if(v^fa) dep[v]=dep[u]+1,f[v]=u,dfs(v,u),
			siz[u]+=siz[v],son[u]=siz[v]>siz[son[u]]?v:son[u];
	}
	void dfs(int u){ if(!top[u]) top[u]=u;
		if(son[u]) top[son[u]]=top[u],dfs(son[u]);
		go(G,u) if(v^f[u]&&v^son[u]) dfs(v);
	}
	inline void init(){
		fp(i,1,cnt) f[i]=fa[i],G.add(f[i],i);
		dfs(1,0),dfs(1);
	}
	inline int query(int u,int v){ u=tag[u],v=tag[v];
		for(;top[u]^top[v];u=f[top[u]])
			if(dep[top[u]]<dep[top[v]]) swap(u,v);
		return len[dep[u]<dep[v]?u:v];
	}
}samp,saml,zero;
int main(){ int T; cin>>T,zero.cnt=zero.las=1;
	fp(kkk,1,T){ s.clear(),reads(s),n=s.length();
		memset(res1,0,n+3<<3);
		memset(res2,0,n+3<<3);
		samp=zero,saml=zero;
		fp(i,0,n-1) samp.insert(s[i],i+1);
		fd(i,n-1,0) saml.insert(s[i],i+1);
		samp.init(),saml.init();
		fp(len,1,n>>1) for(int i=len;i+len-1<=n;i+=len){
			int j=i+len,hm=0,qm=0;
			if(j<=n) hm=Min(saml.query(i,j),len);
			if(i>1) qm=Min(samp.query(i-1,j-1),len-1);
			if(qm+hm<len) continue;
			--res1[j+hm],++res1[j+hm-1-(qm+hm-len)],
			++res2[i-qm],--res2[i-qm+1+(qm+hm-len)];
		}
		fp(i,1,n) res1[i]+=res1[i-1],res2[i]+=res2[i-1];
		ll ans=0; fp(i,2,n) ans+=1ll*res1[i-1]*res2[i]; print(ans);
	} return Ot(),0;
} 
```






---

## 作者：校门外的树 (赞：6)

**我们设f[i]f[i]为以ii结尾的AAAA串个数，g[i]g[i]为以ii开头的AAAA串个数
则 
**ans=∑i=1nf[i]∗g[i+1]**

**ans=∑i=1nf[i]∗g[i+1]**

**考虑怎样求ff和gg，我们可以枚举AAAA串的一半lenlen，然后每隔lenlen设一个断点，那么一个长度为len2*len的AAAA必过两个断点。这两个断点ii，jj的前缀的lsplsp和这两个位置的后缀的lcplcp加起来为lenlen，则存在一个这样的AAAA串；如果大于，则存在多个这样的串，而每个串可以取lsplsp和lcplcp的一部分，使得最终长度为lenlen。这个直接后缀数组搞掉即可。**

code：
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
#define LL long long

const int maxn=2e5+7;

using namespace std;

int T,n;
int c[maxn],x[maxn],y[maxn];
LL f[maxn],g[maxn],ans;

struct suffix_array{
    char s[maxn];
    int rank[maxn],sa[maxn];
    int h[maxn][15];
    void getsa()
    {
        memset(rank,0,sizeof(rank));
        memset(sa,0,sizeof(sa));
        memset(h,0,sizeof(h));
        memset(c,0,sizeof(c));
        memset(x,0,sizeof(x));
        memset(y,0,sizeof(y));
        int m=1000;
        for (int i=1;i<=m;i++) c[i]=0;
        for (int i=1;i<=n;i++) x[i]=s[i];
        for (int i=1;i<=n;i++) c[x[i]]++;
        for (int i=1;i<=m;i++) c[i]+=c[i-1];
        for (int i=n;i>0;i--) sa[c[x[i]]--]=i;
        for (int k=1;k<=n;k<<=1)
        {
            int num=0;
            for (int i=n-k+1;i<=n;i++) y[++num]=i;
            for (int i=1;i<=n;i++) if (sa[i]>k) y[++num]=sa[i]-k;
            for (int i=1;i<=m;i++) c[i]=0;
            for (int i=1;i<=n;i++) c[x[i]]++;
            for (int i=1;i<=m;i++) c[i]+=c[i-1];
            for (int i=n;i>0;i--) sa[c[x[y[i]]]--]=y[i],y[i]=0;
            swap(x,y);
            num=1;
            x[sa[1]]=1;
            for (int i=2;i<=n;i++)
            {
                if ((y[sa[i]]!=y[sa[i-1]]) || (y[sa[i]+k]!=y[sa[i-1]+k]))
                {
                    x[sa[i]]=++num;
                }
                else x[sa[i]]=num;
            }
            if (num>=n) break;
            m=num;
        }
        for (int i=1;i<=n;i++) rank[i]=x[i];
    }
    void getheight()
    {
        int k=0;
        for (int i=1;i<=n;i++)
        {
            if (k) k--;
            int j=sa[rank[i]-1];
            while ((i+k<=n) && (j+k<=n) && (s[i+k]==s[j+k])) k++;
            h[rank[i]][0]=k;
        }
        int c=1;
        for (int j=1;j<15;j++)
        {
            for (int i=1;i<=n;i++)
            {
                h[i][j]=min(h[i][j-1],h[i+c][j-1]);
            }
            c<<=1;
        }
    }
    int lcp(int x,int y)
    {
        x=rank[x],y=rank[y];
        if (x>y) swap(x,y);
        x++;
        int k=trunc(log(y-x+1.5)/log(2));
        return min(h[x][k],h[y-(1<<k)+1][k]);
    }
}A,B;

int main()
{
    scanf("%d",&T);
    while (T--)
    {   
        memset(f,0,sizeof(f));
        memset(g,0,sizeof(g));
        scanf("%s",A.s+1);
        n=strlen(A.s+1);        
        for (int i=1;i<=n;i++) B.s[n-i+1]=A.s[i];       
        A.getsa(),A.getheight();
        B.getsa(),B.getheight();                                    
        for (int len=1;len<=n/2;len++)
        {
            for (int i=len,j=i+len;j<=n;i+=len,j+=len)
            {
                int x=min(A.lcp(i+1,j+1),len-1),y=min(B.lcp(n-i+1,n-j+1),len);
                int t=x+y-len+1;
                if (t>0)
                {
                    g[i-y+1]++,g[i-y+1+t]--;
                    f[j+x+1-t]++,f[j+x+1]--;
                }
            }
        }                               
        for (int i=1;i<=n;i++) f[i]+=f[i-1],g[i]+=g[i-1];
        ans=0;                              
        for (int i=1;i<=n;i++) ans+=f[i]*g[i+1];
        printf("%lld\n",ans);
    }
} 
```


---

## 作者：Seauy (赞：4)

这里即将介绍一个两只log很难写的分治法……

尽量写得详细吧……顺便理清我的思路

现在开始吧。

# 1. 解题思路

[跳转题面](https://www.luogu.com.cn/problem/P1117)

如果我们能求出对于每个位置 $i$ 有多少个 $AA$ 以 $i$ 结尾（用 $f_i$ 表示），有多少个 $BB$ 以 $i$ 开头（用 $g_i$ 表示），那么答案就为

$$ \sum_{i=1}^{n-1} f_ig_{i+1} $$

很显然求 $g$ 跟求 $f$ 是对称的，我们先来研究怎么求 $g$。

对于一个 $BB$，设 $i$ 为第一个 $B$ 的开头位置，$j$ 为第二个 $B$ 的开头位置（$i<j$），它们应当满足

$$ j-i\leq LCP(i,j) $$

其中 $LCP(a,b)$ 指的是以 $a,b$ 开头的后缀的最长公共前缀长度。

那么 $LCP$ 怎么搞啊？很自然想到后缀数组（不会的戳[这](https://www.luogu.com.cn/problem/P3809)，这里就不赘述了），设 $loc_i$ 为后缀排序后位置 $i$ 在原字符串中的位置，$lcp_i$ 为后缀排序后后缀 $i$ 与 $i+1$ 的 $LCP(loc_i,loc_{i+1})$。

那么

$$ g_{loc_i}=\sum_{j=1}^{i-1} [1 \leq loc_j-loc_i\leq \min_{k=j}^{i-1} lcp_k] + \sum_{j=i+1}^{n} [1\leq loc_j-loc_i\leq \min_{k=i}^{j-1} lcp_k] $$

$$ =\sum_{j=1}^{i-1} [loc_j-loc_i \leq \min_{k=j}^{i-1} lcp_k] + \sum_{j=i+1}^n [loc_j-loc_i \leq \min_{k=i}^{j-1} lcp_k] - loc_i +1 $$

（建议静静想想怎么来的，看不懂可以随时问我）

为啥要 $-loc_i+1$ 呢……因为如果 $loc_j<loc_i$ 的话应该是不做贡献的，这样的 $j$ 有 $loc_i-1$ 个（$loc_j-loc_i$ 为负数就一定会不满足 $1 \leq loc_j-loc_i$），因此要减掉。

可是剩下的东西还是很头疼啊，怎么办呢。

发现有 $\min$ 运算，考虑对整个序列（从这里往后“序列”指的是后缀排序好后的数组）分治，计算 $[L,R]$ 时取 $mid=\lfloor \frac{L+R}{2} \rfloor $，$[L,mid]$ 称为左半部分，$[mid+1,R]$ 称为右半部分。

我们做 $lcp$ 数组在左半部分的后缀最小值，在右半部分的前缀最小值数组 $minn_i$。

也就是当 $i \in [L,mid]$ 时

$$ minn_i=\min_{j=i}^{mid} lcp_j = \min(lcp_i,minn_{i+1}) $$

当 $ i \in [mid+1,R]$ 时

$$ minn_i=\min_{j=mid}^{R-1} lcp_{j}=\min(lcp_{i-1},minn_{i-1}) $$

先考虑右半部分对左半部分的贡献，对于每个 $i\in [L,mid]$，能与之构成 $BB$ 的 $j\in [mid+1,R]$ 满足

$$ loc_j-loc_i \leq \min(minn_i,minn_j) $$

现在 $\min$ 里的东西只有两个选择了！这个时候做些分类讨论就不怎么麻烦了吧。我们发现当 $i\leq mid$ 时，$minn_i$ 随 $i$ 的增大而增大；当 $i\geq mid+1$ 时，$minn_i$ 随 $i$ 的增大而减小。

我们从 $mid$ 到 $L$ 一个个枚举出 $i$，对于每个 $i$ 求出 $pos$ 满足

$$ \forall j\in[mid+1,pos],minn_i \leq minn_j $$

$$ \forall j\in[pos+1,R],minn_i>minn_j $$

根据 $minn$ 的增减性可以证明出对于每个 $i$ 有且仅有一个这样的 $pos$，且进一步，当 $i$ 减小时，$pos$ 会随之增大。这样求出所有 $pos$ 就是均摊 $O(n)$ 的了。

接下来看怎么统计合法 $j$ 的个数。

当 $ j\in [mid+1,pos] $ 时，满足 $loc_j-loc_i\leq minn_i$，也就是 $loc_i + minn_i\geq loc_j $。

当 $j\in[pos+1,R]$ 时，满足 $loc_j-loc_i \leq minn_j$，也就是 $loc_i \geq loc_j - minn_j$。

惊人地发现经过一番折腾，$i,j$ 终于分离了，$\min$ 也消失了有木有！这个时候蠢蠢欲动的树状数组终于派上用场了，移动 $pos$ 的同时维护树状数组（用两个或者做两次都行），统计的时候查询值域上 $loc_i$ 或 $loc_i + minn_i$ 的前缀点数就行了。

其实这种套路早在去年就已经被大量发现了……与分治法相提并论的还有数据结构扫描的做法，两种做法各有优劣，也不是每道题两者皆适用的，详情可以看看我以前写的[博客](https://www.luogu.com.cn/blog/JHN021/tao-lu-ou-jian-ti-shi-gong-zhong-post)。

树状数组开多大呢……$ loc_i\in [1,n] , minn_i\in [0,n] , loc_i-minn_i \in [1-n,n]$ 因此 $j\in[pos+1,R]$ 时不等式改写为 $loc_i +n \geq loc_j - minn_j +n$ 范围是完美的 $[1,2n]$。

别忘了一大堆东西：

1. 还要计算左半部分对右半部分的贡献，做法类似。

2. 还要把整个字符串翻转一遍再做一次求出 $f$，做法类似。

3. 开 long long。

4. SA 别写炸了。

5. 求出 $f_i,g_i$ 了之后别忘了减去 $ i-1 $。

由于有分治和树状数组，时间就是 $O(Tn\log^2 n)$ 的了，空间 $O(n)$。

# 2. 代码

咕咕咕

~~一把抓起鸽子炖了~~

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;

const int MAXN=3e4;

int n,A[MAXN+5];
ll f[MAXN+5],g[MAXN+5],ans,lcp[MAXN+5];

//哈希
const ll Base=2333,MOD=1e9+7; 
ll pre[MAXN+5],B[MAXN+5];
ll Hash(int L,int R) {return (pre[R]-(pre[L-1]*B[R-L+1])%MOD+MOD)%MOD;}

//树状数组
struct BIT
{
	int New,Edit[2*MAXN+5];//这里范围待商榷
	ll sum[2*MAXN+5];
	int lowbit(int x) {return x&-x;}
	void Clean() {++New;} 
	void ud(int x)
	{
		if(New>Edit[x])
		{
			Edit[x]=New;
			sum[x]=0;
		}
	}
	void Plus(int x,ll v)
	{
		for(;x<=2*n;x+=lowbit(x))
		{
			ud(x);
			sum[x]+=v;
		}
	}
	ll Ask(int x)
	{
		ll cnt=0;
		for(;x>0;x-=lowbit(x))
		{
			ud(x);
			cnt+=sum[x];
		}
		return cnt;
	}
}mapn[2];

int SA[MAXN+5];
int LCP(int a,int b)
{
	int L=0,R=min(n-a+1,n-b+1);
	for(int mid;L<=R;)
	{
		mid=(L+R)>>1;
		if(Hash(a,a+mid-1)==Hash(b,b+mid-1)) L=mid+1;
		else R=mid-1;
	}
	return R;
}
bool cmp(int a,int b)
{
	int cnt=LCP(a,b);
	return A[a+cnt]<A[b+cnt];
}
void Sort()
{
	sort(SA+1,SA+n+1,cmp);
	//printf("SA: ");for(int i=1;i<=n;i++) printf("%d ",SA[i]);printf("\n");
	for(int i=1;i<n;i++) lcp[i]=LCP(SA[i],SA[i+1]);
	//printf("lcp: ");for(int i=1;i<n;i++) printf("%lld ",lcp[i]);printf("\n");
}

ll minn[MAXN+5];
void Solve(int L,int R)
{
	if(L==R) return;
	int mid=(L+R)>>1;
	Solve(L,mid),Solve(mid+1,R);
	
	minn[mid]=lcp[mid];
	for(int i=mid-1;i>=L;i--) minn[i]=min(lcp[i  ],minn[i+1]);
	for(int i=mid+1;i<=R;i++) minn[i]=min(lcp[i-1],minn[i-1]);
	
	mapn[0].Clean(),mapn[1].Clean();
	for(int i=mid+1;i<=R;i++) mapn[1].Plus(SA[i]-minn[i]+n,1);
	for(int i=mid,pos=mid;i>=L;i--)
	{
		while(pos<R)
			if(minn[i]<=minn[pos+1])
			{
				++pos;
				mapn[0].Plus(SA[pos],1);
				mapn[1].Plus(SA[pos]-minn[pos]+n,-1);
			}
			else break;
		f[SA[i]]+=mapn[0].Ask(SA[i]+minn[i])+mapn[1].Ask(SA[i]+n);
	}
	
	mapn[0].Clean(),mapn[1].Clean();
	for(int i=L;i<=mid;i++) mapn[1].Plus(SA[i]-minn[i]+n,1);
	for(int i=mid+1,pos=mid+1;i<=R;i++)
	{
		while(pos>L)
			if(minn[i]<=minn[pos-1])
			{
				--pos;
				mapn[0].Plus(SA[pos],1);
				mapn[1].Plus(SA[pos]-minn[pos]+n,-1);
			}
			else break;
		f[SA[i]]+=mapn[0].Ask(SA[i]+minn[i])+mapn[1].Ask(SA[i]+n);
	}
}

void Work()
{
	for(int i=1;i<=n;i++)
	{
		pre[i]=((pre[i-1]*Base)%MOD+A[i])%MOD;
		f[i]=0;
		SA[i]=i;
	}
	Sort();
	Solve(1,n);
	for(int i=1;i<=n;i++) f[i]-=i-1;
	//printf("f: ");for(int i=1;i<=n;i++) printf("%lld ",f[i]);printf("\n");
}

int main()
{
	//freopen("Last.in","r",stdin);
	//freopen("MyAns.txt","w",stdout); 
	B[0]=1;
	for(int i=1;i<=MAXN;i++) B[i]=(B[i-1]*Base)%MOD;
	int T;
	scanf("%d\n",&T);
	while(T--)
	{
		n=0;
		for(char s;1;)
		{
			s=getchar();
			if(s=='\n') break;
			A[++n]=s-'a'+1;
		}
		A[n+1]=0;
		//printf("first work\n");
		//for(int i=1;i<=n;i++) printf("%d ",A[i]);printf("\n");
		Work();
		for(int i=1;i<=n;i++) g[i]=f[i];
		for(int i=1;2*i<=n;i++) swap(A[i],A[n-i+1]);
		//printf("second work\n");
		//for(int i=1;i<=n;i++) printf("%d ",A[i]);printf("\n");
		Work();
		ans=0;
		for(int i=2;i<=n;i++) ans+=f[i]*g[n-i+2];
		printf("%lld\n",ans);
	}
	return 0;
}
```


---

## 作者：devout (赞：3)

在收藏里躺了四个月的题（

我们可以把问题转化为，求以 $i$ 开始的和以 $i$ 结尾的 $\texttt{AA}$ 串的个数，然后利用乘法原理可以求出答案

显然可以想到一个 $\mathcal O(n^2)$ 的哈希做法

然后你就得到了95分的好成绩

如何得到剩下的五分呢？

~~套取数据~~

我们可以考虑枚举 $\texttt{AA}$ 串的长度 $len$

我们往字符串中的每个 $i\times len$ 标记为关键点，那么每个 $\texttt{A}$ 中肯定有一个关键点。

枚举相邻的两个关键点 $x,y$，求出他们的 $lcp$ 和 $lcs$

因为 $lcp$ 和 $lcs$ 有一个点是重复的，所以如果 $lcp+lcs-1 <len$ 时，一定不存在跨过这个关键点的长度为 $len$ 的一个 $\texttt{A}$ 串

否则，对于 $i\in(x-lcs,x-lcs+1+(lcp+lcs-len)]$，一定存在以 $i$ 开头的 $\texttt{A}$ 长度为 $len$ 的 $\texttt{AA}$ 串，同理，对于末尾的一部分，我们也有以他们为结尾的满足条件的 $\texttt{AA}$ 串

这样的话，利用 SA 计算 lcp，lcs 的复杂度为 $\mathcal O(n\log n)$，枚举关键点的复杂度为调和级数 $\mathcal O(n\ln n)$，总复杂度为 $\mathcal O(n\log n)$

代码还挺好写的小清新字符串题（

```cpp
#include <bits/stdc++.h>
using namespace std;

# define Rep(i,a,b) for(int i=a;i<=b;i++)
# define _Rep(i,a,b) for(int i=a;i>=b;i--)
# define RepG(i,u) for(int i=head[u];~i;i=e[i].next)

typedef long long ll;

const int N=3e4+5;

template<typename T> void read(T &x){
   x=0;int f=1;
   char c=getchar();
   for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
   for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+c-'0';
    x*=f;
}

int t,n;
int l[N],r[N];
int box[N];
ll ans;

struct Suffix_Array{
	int m;
	char s[N];
	int sa[N],rk[N],tp[N];
	int height[N];
	int st[N][17],lg[N];
	void init(){
		memset(sa,0,sizeof(sa));
		memset(rk,0,sizeof(rk));
		memset(height,0,sizeof(height));	
		memset(st,0x3f,sizeof(st));
	}
	void RadixSort(){
		Rep(i,1,m)box[i]=0;
		Rep(i,1,n)box[rk[i]]++;
		Rep(i,1,m)box[i]+=box[i-1];
		_Rep(i,n,1)sa[box[rk[tp[i]]]--]=tp[i];
	}
	void SA(){
		m=26;
		Rep(i,1,n)rk[i]=s[i]-'a',tp[i]=i;
		RadixSort();
		for(int k=1,t=0;t<n;k<<=1,m=t){
			t=0;
			_Rep(i,n,n-k+1)tp[++t]=i;
			Rep(i,1,n)if(sa[i]>k)tp[++t]=sa[i]-k;
			RadixSort();
			swap(rk,tp);
			rk[sa[1]]=t=1;
			Rep(i,2,n)
				rk[sa[i]]=tp[sa[i]]==tp[sa[i-1]]&&(sa[i]+k<=n&&sa[i-1]+k<=n&&tp[sa[i]+k]==tp[sa[i-1]+k])?t:++t;
		}
		Rep(i,1,n)rk[sa[i]]=i;
		int k=0;
		Rep(i,1,n){
			if(rk[i]==1)continue;
			if(k)k--;
			int j=sa[rk[i]-1];
			while(i+k<=n&&j+k<=n&&s[i+k]==s[j+k])k++;
			height[rk[i]]=k;	
		}
		lg[1]=0;
		Rep(i,2,n)lg[i]=lg[i>>1]+1;
		_Rep(i,n,1){
			st[i][0]=height[i];
			Rep(j,1,16){
				if(i+(1<<j-1)>n)break;
				st[i][j]=min(st[i][j-1],st[i+(1<<j-1)][j-1]);	
			}
		}
	}
	int LCP(int x,int y){
		int l=rk[x],r=rk[y];
		if(l>r)swap(l,r);
		l++;
		int k=lg[r-l+1];
		return min(st[l][k],st[r-(1<<k)+1][k]);	
	}
}sa1,sa2;

int main()
{
	read(t);
	while(t--){
		memset(l,0,sizeof(l));
		memset(r,0,sizeof(r));
		sa1.init(),sa2.init();
		ans=0;
		scanf("%s",sa1.s+1);
		n=strlen(sa1.s+1);
		Rep(i,1,n)sa2.s[n-i+1]=sa1.s[i];
		sa1.SA();
		sa2.SA();
		Rep(len,1,n)
			for(int j=1;(j+1)*len<=n;j++){
				int x=j*len,y=(j+1)*len;
				int lcp=sa1.LCP(x,y),lcs=sa2.LCP(n-x+1,n-y+1);
				lcp=min(lcp,len),lcs=min(lcs,len);
				if(lcp+lcs<=len)continue;
				l[y+lcp-(lcp+lcs-len)]++,l[y+lcp]--;
				r[x-lcs+1]++,r[x-lcs+1+(lcp+lcs-len)]--;
			}
		Rep(i,1,n)l[i]+=l[i-1],r[i]+=r[i-1];
		Rep(i,1,n)ans+=1ll*l[i-1]*r[i];
		printf("%lld\n",ans);
	}
	return 0;
}
```


---

## 作者：panjoel (赞：3)

这题貌似是少有的后缀自动机不能解决而后缀数组能解决的题目之一了。

此题做法：后缀数组 + 调和级数。

我们发现问题其实就是找到所有形如 AA 的串（即前后两半相同的串），把它所在的左、右端点位置上计数器 + 1 即可。

首先正反串都建一个后缀数组，这样方便操作。

接下来，我们不妨枚举 A 的长度 len，然后把字符串按照 len 划分成若干块，然后我们需要处理左端点在每一块中的形如 AA 的子串，假设我们当前处理的位置是 i（见下图）。

![](https://images2015.cnblogs.com/blog/822137/201706/822137-20170625175717913-961577607.png)

注意这张图中，我们当前位置为 i，处理开头在最左边那个块中的形如 AA 的子串。（块与块之间的分隔符是长竖线，以下“形如 AA 的子串”均简称为“AA 子串”）

令 L1 = LCP(i, i+len)（LCP 为最长公共前缀，LCS 为最长公共后缀），那么存在 AA 子串的充分必要条件是 LCS(i+len-1, i-1) > 0 且 LCS(i+len-1, i-1) + L1 >= len（否则红色区域就会有不同的字符，那么显然不可能存在 AA 子串）。那么接下来的问题就好办了，令 L2 = LCS(i+L1-len-1, i+L1-1)，不难发现区间 [ i+L1-len-L2, i+L1-len ] 中的位置都是长度为 len 的 AA 子串的左端点（至于右端点在哪，请读者思考）。（然而这里并不用线段树实现区间加，可以直接打离线标记）

```cpp
#include<bits/stdc++.h>
#define LL long long
LL in() {
    char ch; LL x = 0, f = 1;
    while(!isdigit(ch = getchar()))(ch == '-') && (f = -f);
    for(x = ch ^ 48; isdigit(ch = getchar()); x = (x << 1) + (x << 3) + (ch ^ 48));
    return x * f;
}
const int maxn = 5e4 + 10;
int lg[maxn];
struct SA {
    char s[maxn];
    int rk[maxn], sa[maxn], c[maxn], x[maxn], y[maxn], h[maxn], n, m, st[maxn][20];
    void init() {
        memset(x, 0, sizeof x);
        memset(y, 0, sizeof y);
        memset(h, 0, sizeof h);
        memset(st, 0, sizeof st);
        memset(sa, 0, sizeof sa);
        memset(rk, 0, sizeof rk);
        memset(c, 0, sizeof c);
        for(int i = 1; i <= n; i++) x[i] = y[i] = h[i] = st[i][0] = sa[i] = rk[i] = 0;
        for(int i = 1; i <= m; i++) c[i] = 0;
        for(int i = 1; i <= n; i++) c[x[i] = s[i]]++;
        for(int i = 1; i <= m; i++) c[i] += c[i - 1];
        for(int i = n; i >= 1; i--) sa[c[x[i]]--] = i;
        for(int k = 1; k <= n; k <<= 1) {
            int num = 0;
            for(int i = n - k + 1; i <= n; i++) y[++num] = i;
            for(int i = 1; i <= n; i++) if(sa[i] > k) y[++num] = sa[i] - k;
            for(int i = 1; i <= m; i++) c[i] = 0;
            for(int i = 1; i <= n; i++) c[x[i]]++;
            for(int i = 1; i <= m; i++) c[i] += c[i - 1];
            for(int i = n; i >= 1; i--) sa[c[x[y[i]]]--] = y[i], y[i] = 0;
            std::swap(x, y);
            x[sa[1]] = 1, num = 1;
            for(int i = 2; i <= n; i++) x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] && y[sa[i] + k] == y[sa[i - 1] + k])? num : ++num;
            if(num == n) break;
            m = num;
        }
        for(int i = 1; i <= n; i++) rk[i] = x[i];
        int H = 0;
        for(int i = 1; i <= n; i++) {
            if(rk[i] == 1) continue;
            if(H) H--;
            int j = sa[rk[i] - 1];
            while(i + H <= n && j + H <= n && s[i + H] == s[j + H]) H++;
            h[rk[i]] = H;
        }
        for(int i = 1; i <= n; i++) st[i][0] = h[i];
        for(int j = 1; j <= 18; j++)
            for(int i = 1; i + (1 << j) - 1 <= n; i++)
                st[i][j] = std::min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);
    }
    int LCP(int x, int y) {
        x = rk[x], y = rk[y];
        if(x > y) std::swap(x, y);
        x++;
        int l = lg[y - x + 1];
        return std::min(st[x][l], st[y - (1 << l) + 1][l]);
    }
    void ins(char *s, int len) {
        n = len, m = 122;
        for(int i = 1; i <= n; i++) this->s[i] = s[i];
    }
}A, B;
LL pre[maxn], nxt[maxn];
char s[maxn];
int main() {
    lg[0] = -1;
    for(int i = 1; i < maxn; i++) lg[i] = lg[i >> 1] + 1;
    for(int T = in(); T --> 0;) {
        scanf("%s", s + 1);
        int n = strlen(s + 1);
        A.ins(s, n);
        std::reverse(s + 1, s + n + 1);
        B.ins(s, n);
        A.init(), B.init();
        memset(pre, 0, sizeof pre), memset(nxt, 0, sizeof nxt);
        for(int L = 1; L <= n >> 1; L++)
            for(int i = 1; i + L <= n; i += L) {
                int j = i + L;
                int xx = A.LCP(i, j), yy = B.LCP(n - i + 1, n - j + 1);
                xx = std::min(xx, L), yy = std::min(yy, L);
                if(xx + yy < L + 1) continue;
                int nowlen = xx + yy - L - 1;
                nxt[i - yy + 1]++, nxt[i - yy + nowlen + 2]--;
                pre[j + xx - nowlen - 1]++, pre[j + xx]--;
            }
        for(int i = 1; i <= n; i++) pre[i] += pre[i - 1], nxt[i] += nxt[i - 1];
        LL ans = 0;
        for(int i = 1; i < n; i++) ans += pre[i] * nxt[i + 1];
        printf("%lld\n", ans);
    }
    return 0;
}
```


---

## 作者：tommymio (赞：2)

形如 $\mathrm{AABB}$ 的串显然是可以枚举一个分界点 $i$，记以 $i$ 结尾的 $\mathrm{AA}$ 串方案数为 $f_i$，以 $i+1$ 开头的 $\mathrm{BB}$ 串方案数为 $g_i$，则所求为 $\sum f_i\times g_{i+1}$。
  
如何求 $f_i,g_i$ 呢？对原串和反串建 $\mathrm{SAM}$ 后，我并没有想到之前题解提到的调和级数，而是想到了 $\mathrm{SAM}$ 的 $\mathrm{Parent \ Tree}$。在不考虑空间复杂度的情况下，我们有一个看上去很可做的做法：对于树上每一个点 $x$ 求出其 $\mathrm{endpos}$ 集合，那么我们只需要考虑 $\mathrm{endpos}$ 集合中所有二元组 $(p,q)$，满足 $\mathrm{minLen}_x\leq|p-q|\leq \mathrm{maxLen}_x$ 即可。这部分统计是个经典问题，可以线性求解。
  
通过归并合并 $\mathrm{endpos}$ 集合，保证每个点的 $\mathrm{endpos}$ 集合内有序，我们就可以 $O(\sum f_i)$ 求解此问题，其中 $f(i)$ 为子树 $i$ 的叶子节点数，但这显然是会被循环串或者 $\texttt{abbbbb...b}$ 这种数据卡到自闭。~~就算这样 $95$ 分你还是可以拿满~~
  
为什么要显式表示出 $\mathrm{endpos}$ 集合呢？直接 $\mathrm{dsu \ on \ tree}$，使用线段树维护重儿子贡献即可，最劣情况下仍可以做到 $O(|S| \log^2 |S|)$，不管怎么说还是被 $\mathrm{SA}$ 的 $O(|S| \log |S|)$ 吊打了，哭哭。
  
本算法的时间复杂度瓶颈在于树上统计 $\mathrm{minLen}_x\leq |p-q|\leq \mathrm{maxLen}_x(p,q\in \mathrm{endpos}_x)$。

这里仅贴上最劣 $O(|S|^2)$ 的代码，因为咱不想写 $O(|S| \log^2 |S|)$ 的代码（逃 

如果树上统计那个东西有了更优秀的做法，咱会回来把这个坑填上的 ×

```cpp
/* stuff you should look for
	* int overflow, array bounds, uppercase/lowercase
	* special cases (n=1?)
	* do sth. instead of nothing and stay organized
	* WRITE STUFF DOWN
	* DON'T GET STUCK ON ONE APPROACH
*/
#include<cstdio>
#include<map>
#include<vector>
#include<cstring>
typedef long long ll;
typedef std::map<int,int> mint;
typedef std::vector<int> vint;
char s[100005];
ll res1[60005],res2[60005];
inline int read() {
	register int x=0,f=1;register char s=getchar();
	while(s>'9'||s<'0') {if(s=='-') f=-1;s=getchar();}
	while(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();}
	return x*f; 
}
struct node {
	int len,link;
	std::map<int,int> trans;
};
struct SuffixACM {
	int tot,lst;
	std::vector<int> rev_link[60005];
	std::vector<int> endpos[60005];
	node t[60005];
	inline void init() {
		tot=lst=0; t[0].link=-1; 
	} 
	inline void extend(int pos,int c) {
		int p=lst,cur=++tot; endpos[cur].push_back(pos);//EP[cur]=pos;
		t[cur].len=t[lst].len+1;
		while(p!=-1&&!t[p].trans.count(c)) {
			t[p].trans[c]=cur;
			p=t[p].link;
		}
		if(p==-1) t[cur].link=0;
		else {
			int q=t[p].trans[c];
			if(t[p].len+1==t[q].len) t[cur].link=q;
			else {
				int cln=++tot;
				t[cln]=t[q];
				t[cln].len=t[p].len+1;
				while(p!=-1&&t[p].trans[c]==q) {
					t[p].trans[c]=cln;
					p=t[p].link;
				}
				t[cur].link=t[q].link=cln;
			} 
		}
		lst=cur;
	}
	inline void show() {
		for(register int i=0;i<=tot;++i) {
			for(mint::iterator it=t[i].trans.begin();it!=t[i].trans.end();++it) {
				printf("%d %d %d\n",i,it->second,it->first);
			}
		}
		for(register int i=0;i<=tot;++i) printf("link=%d %d\n",t[i].link,i);
		for(register int i=0;i<=tot;++i) {
			printf("i=%d { ",i);
			for(register int j=0;j<endpos[i].size();++j) {
				printf("%d ",endpos[i][j]);
			}
			printf("}\n");
		}
//		for(register int i=0;i<=tot;++i) printf("%d\n",t[i].len);
	}
	inline void merge(vint &op1,vint &op2) {
		if(!op1.size()) {op1=op2; op2.clear(); return;}
		vint tmp; 
		int len1=op1.size(),len2=op2.size();
		int p1=0,p2=0;
		for(register int i=0;i<len1+len2;++i) {
			if((p1<len1&&op1[p1]<op2[p2])||(p2>=len2)) {tmp.push_back(op1[p1]);++p1;}
			else {tmp.push_back(op2[p2]);++p2;}
		}
		op1=tmp;
//		op2.clear();
		vint().swap(op2);
	}
	inline void dfs(int x,ll *des) {
		for(size_t i=0;i<rev_link[x].size();++i) {
			int y=rev_link[x][i];
			dfs(y,des); merge(endpos[x],endpos[y]);
		}
		if(x) {
			int L=t[t[x].link].len+1,R=t[x].len;
//			int len=endpos[x].size(),ptt=len-1,cur;
//			for(register int i=len-1;i>=0;--i) {
//				cur=endpos[x][i];
//				while(ptt>i&&endpos[x][ptt]-cur>R) --ptt;
//				des[cur]+=ptt-i; 
//			}
//			ptt=len-1;
//			//x<=R - x<=L-1
//			for(register int i=len-1;i>=0;--i) {
//				cur=endpos[x][i];
//				while(ptt>i&&endpos[x][ptt]-cur>L-1) --ptt;
//				des[cur]-=ptt-i; 
//			}
			int len=endpos[x].size(),ptt=0,cur;
			for(register int i=0;i<len;++i) {
				cur=endpos[x][i];
				while(ptt<i&&cur-endpos[x][ptt]>R) ++ptt;
				des[cur]+=i-ptt;
			}
			ptt=0;
			for(register int i=0;i<len;++i) {
				cur=endpos[x][i];
				while(ptt<i&&cur-endpos[x][ptt]>L-1) ++ptt;
				des[cur]-=i-ptt;
			}
		}
	} 
	inline void main(ll *des) {
		for(register int i=1;i<=tot;++i) rev_link[t[i].link].push_back(i);
		dfs(0,des);
	}
	inline void clear() {
//		endpos[0].clear();
		vint().swap(endpos[0]);
		for(register int i=0;i<=tot;++i) { 
			t[i].trans.clear();
			t[i].link=0;
			rev_link[i].clear();
//			endpos[i].clear();
		}
	}
}SAM1,SAM2; 
int main() {
	freopen("P1117_13.in","r",stdin);
	int T=read();
	while(T--) {
		scanf("%s",s+1);
		int n=strlen(s+1);
//		printf("%d\n",n);
		SAM1.init(); SAM2.init();
		for(register int i=1;i<=n;++i) SAM1.extend(i,s[i]-'a');
		for(register int i=1;i<=n;++i) SAM2.extend(i,s[n-i+1]-'a');
		for(register int i=1;i<=n;++i) res1[i]=res2[i]=0;
//		printf("ERR\n");
		SAM1.main(res1); SAM2.main(res2);
//		SAM1.show();
//		printf("ERR\n");
		ll ans=0;	
		for(register int i=1;i<=n;++i) {
			ans+=res1[i]*res2[n-i];
		}
		printf("%lld\n",ans);
		SAM1.clear(); SAM2.clear();
	}
	return 0;
}

```
  


---

## 作者：duyi (赞：2)

# /se/se/se ↓


[超超超超超超超超超爽的阅读体验](https://www.cnblogs.com/dysyn1314/p/13336660.html)

## 题解 LOJ2083 「NOI2016」优秀的拆分

[题目链接](https://loj.ac/problem/2083)

> 约定：$\text{suf}(i)$表示以$i$开头的后缀（$s[i\dots n]$），$\text{pre}(i)$表示以$i$结尾的前缀（$s[1\dots i]$），$\text{lcp}(s_1,s_2)$表示两个串的最长公共前缀，$\text{lcs}(s_1,s_2)$表示两个串的最长公共后缀。

设$f[i]$表示以$i$为结尾的，$\text{AA}$式的子串数量。$g[i]$表示以$i$为开头的，$\text{BB}$式的子串数量。我们可以枚举$\text{AA}$与$\text{BB}$的分界点，然后求出答案，也就是说，答案等于：
$$
\sum_{i=1}^{n-1}f[i]\cdot g[i+1]
$$
对每个$i$，都求一遍$f$和$g$。利用哈希或后缀数组判断子串相等。时间复杂度$O(n^2)$，期望得$95$分。

继续优化。$f$, $g$是类似的，以求$f$为例。考虑枚举$\text{A}$的长度$\text{len}$。我们把$1\dots n$中所有是$\text{len}$的倍数的点，标为“关键点”。发现一个$\text{AA}$式的子串，必定跨过**恰好**$2$个关键点！

考虑一组相邻的关键点$i,j$ （显然，$j=i+\text{len}$），计算跨过$i,j$的$\text{AA}$的数量。设$x=\text{lcp}(\text{suf}(i),\text{suf}(j))$，$y=\text{lcs}(\text{pre}(i-1),\text{pre}(j-1))$。如果$x+y<\text{len}$，显然跨过$i,j$的$\text{AA}$数量为$0$。否则，中间的两段$x$, $y$会有一个交，第一个$\text{A}$的终点，只要落在这段交上都是可行的，所以会有$x+y-\text{len}+1$个跨过$i,j$的$\text{AA}$，并且它们的结尾位置，是一段连续的区间，所以对这段区间的$f$值$+1$即可，可以用差分实现。

预处理后缀数组后，求$\text{lcp}$, $\text{lcs}$可以$O(1)$实现。因为关键点的总数是调和级数的，所以总时间复杂度$O(n\log n)$。

参考代码：

```cpp
//problem:LOJ2083
#include <bits/stdc++.h>
using namespace std;

#define pb push_back
#define mk make_pair
#define lob lower_bound
#define upb upper_bound
#define fi first
#define se second
#define SZ(x) ((int)(x).size())

typedef unsigned int uint;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pii;

template<typename T>inline void ckmax(T& x,T y){x=(y>x?y:x);}
template<typename T>inline void ckmin(T& x,T y){x=(y<x?y:x);}

const int MAXN=3e4;
const int LOG_MAXN=15;
int n;
char s[MAXN+5];
struct SuffixArray{
	int n,m,x[MAXN+5],y[MAXN+5],c[MAXN+5],sa[MAXN+5];
	int rk[MAXN+5],ht[MAXN+5],st[MAXN+5][LOG_MAXN+5];
	int _log2[MAXN+5];
	void clear(){
		for(int i=1;i<=max(n,(int)'z');++i)c[i]=0;
		for(int i=1;i<=n;++i)y[i]=0;
	}
	void init(){
		_log2[0]=-1;
		for(int i=1;i<=MAXN;++i)_log2[i]=_log2[i>>1]+1;
	}
	void build(char* s,int _n){
		n=_n;
		m='z';
		for(int i=1;i<=n;++i)c[x[i]=s[i]]++;
		for(int i=1;i<=m;++i)c[i]+=c[i-1];
		for(int i=n;i>=1;--i)sa[c[x[i]]--]=i;
		for(int k=1;k<=n;k<<=1){
			int num=0;
			for(int i=n-k+1;i<=n;++i)y[++num]=i;
			for(int i=1;i<=n;++i)if(sa[i]>k)y[++num]=sa[i]-k;
			for(int i=1;i<=m;++i)c[i]=0;
			for(int i=1;i<=n;++i)c[x[i]]++;
			for(int i=1;i<=m;++i)c[i]+=c[i-1];
			for(int i=n;i>=1;--i)sa[c[x[y[i]]]--]=y[i];
			
			for(int i=1;i<=n;++i)swap(x[i],y[i]);
			x[sa[1]]=1;num=1;
			for(int i=2;i<=n;++i)
				x[sa[i]]=((y[sa[i]]==y[sa[i-1]] && y[sa[i]+k]==y[sa[i-1]+k])?num:++num);
			if(num==n)break;
			m=num;
		}
		for(int i=1;i<=n;++i)rk[sa[i]]=i;
		//for(int i=1;i<=n;++i)cout<<rk[i]<<" ";cout<<endl;
		int k=0;
		for(int i=1;i<=n;++i){
			if(rk[i]==1)continue;
			if(k)--k;
			int j=sa[rk[i]-1];
			while(i+k<=n && j+k<=n && s[i+k]==s[j+k])
				++k;
			ht[rk[i]]=k;
		}
		for(int i=1;i<=n;++i)st[i][0]=ht[i];
		for(int j=1;j<=LOG_MAXN;++j){
			for(int i=1;i+(1<<(j-1))<=n;++i){
				st[i][j]=min(st[i][j-1],st[i+(1<<(j-1))][j-1]);
			}
		}
	}
	int rmq(int l,int r){
		int k=_log2[r-l+1];
		return min(st[l][k],st[r-(1<<k)+1][k]);
	}
	int get_lcp(int i,int j){
		if(i==j)
			return n-i+1;
		i=rk[i]; j=rk[j];
		if(i>j)swap(i,j);
		assert(i<j);
		return rmq(i+1,j);
	}
	SuffixArray(){}
};

SuffixArray SA,SA_rev;

int f[MAXN+5],g[MAXN+5];

void solve_case(){
	SA.clear();
	SA_rev.clear();
	cin>>(s+1); n=strlen(s+1);
	SA.build(s,n);
	reverse(s+1,s+n+1);
	SA_rev.build(s,n);
	
	for(int i=1;i<=n;++i)f[i]=g[i]=0;
	
	int maxlen=(n-2)/2;
	for(int len=1;len<=maxlen;++len){
		for(int k=1;(k+1)*len<=n;++k){
			int i=k*len;
			int j=(k+1)*len;
			
			int lcp=SA.get_lcp(i,j);
			int lcs=(i==1?0:SA_rev.get_lcp(n-(i-1)+1,n-(j-1)+1));
			
			if(!lcp)continue;
			
			int l=j-min(lcs,len-1)+len-1;
			int r=min(n,j+min(lcp,len)-1);
			if(l<=r){
				f[l]++;f[r+1]--;
			}
			l=max(1,i-min(lcs,len-1));
			r=i+min(lcp,len)-1-len+1;
			if(l<=r){
				g[l]++;g[r+1]--;
			}
		}
	}
	for(int i=1;i<=n;++i)f[i]+=f[i-1],g[i]+=g[i-1];
	f[n+1]=g[n+1]=0;
	ll ans=0;
	for(int i=1;i<=n-2;++i)
		ans+=(ll)f[i]*g[i+1];
	cout<<ans<<endl;
}
int main() {
	SA.init();
	SA_rev.init();
	int T;cin>>T;while(T--){
		solve_case();
	}
	return 0;
}
```



---

## 作者：封禁用户 (赞：1)

　这道题有点难想到正解。

　　枚举长度i，然后把字符串拆分成许多连续的长度为i的子串，通过比较LCS与LCP得出一段的答案，这里发现答案是区间加法，考虑用线段树很可能超时，这里用的是差分，看程序很好理解。还有一个地方要注意：更新答案时可能会重复计算，只需要确保每次枚举都只在一段限定的区间更新，就不会出现重叠。
```cpp
  1 #include <iostream>
  2 #include <cstring>
  3 #include <cstdio>
  4 using namespace std;
  5 const int N=120010;
  6 struct SAM{
  7     char s[N];
  8     int fa[N],pos[N],sa[N],rank[N];
  9     int son[N][26],end[N],rht[N],lcp[N];
 10     int ch[N][26],len[N],id[N],tot;
 11     int od[N],wv[N],lst,cnt;
 12     int mm[N],Min[N][25];
 13     void Init(){
 14         memset(s,0,sizeof(s)); 
 15         memset(ch,0,sizeof(ch));
 16         memset(end,0,sizeof(end));
 17         memset(son,0,sizeof(son));
 18         memset(pos,0,sizeof(pos));
 19         lst=cnt=1;tot=0;
 20     }
 21 
 22     void Insert(int c){
 23         int p=lst,np=lst=++cnt;end[lst]=1;
 24         id[len[np]=len[p]+1]=np;rht[np]=1;
 25         while(p&&!ch[p][c])ch[p][c]=np,p=fa[p];
 26         if(!p)fa[np]=1;
 27         else{
 28             int q=ch[p][c],nq;
 29             if(len[q]==len[p]+1)fa[np]=q;
 30             else{
 31                 len[nq=++cnt]=len[p]+1;
 32                 fa[nq]=fa[q];fa[q]=fa[np]=nq;
 33                 memcpy(ch[nq],ch[q],sizeof(ch[q]));
 34                 while(ch[p][c]==q)ch[p][c]=nq,p=fa[p];
 35             }
 36         }
 37     }
 38 
 39     void Get_Right(){
 40         for(int i=1;i<=cnt;i++)wv[len[i]]++;
 41         for(int i=1;i<=cnt;i++)wv[i]+=wv[i-1];
 42         for(int i=1;i<=cnt;i++)od[wv[len[i]]--]=i;
 43         for(int i=cnt;i>=1;i--)rht[fa[od[i]]]+=rht[od[i]];
 44     }
 45 
 46     void Build_Tree(){
 47         int l=strlen(s+1);
 48         for(int i=l;i>=1;i--)Insert(s[i]-'a');
 49         for(int i=l;i>=1;i--)
 50             for(int x=id[i],p=l+1;x&&!pos[x];x=fa[x])
 51                 p-=len[x]-len[fa[x]],pos[x]=p;
 52         for(int x=2;x<=cnt;x++)son[fa[x]][s[pos[x]]-'a']=x;    
 53     }
 54 
 55     void DFS(int x,int l){
 56         if(end[x])sa[rank[l-len[x]+1]=++tot]=l-len[x]+1;
 57         for(int i=0;i<26;i++)if(son[x][i])DFS(son[x][i],l);
 58     }
 59 
 60     void Build_SA(){
 61         int l=strlen(s+1),k=0;DFS(1,l);
 62         for(int i=1,j;i<=l;lcp[rank[i++]]=k)
 63             for(k?k--:k,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);
 64         mm[0]=-1;
 65         for(int i=1;i<=l;i++){
 66             mm[i]=(i&(i-1))?mm[i-1]:mm[i-1]+1;
 67             Min[i][0]=lcp[i];
 68         }
 69         for(int k=1;k<=mm[l];k++)
 70             for(int i=1;i+(1<<k-1)<=l;i++)
 71                 Min[i][k]=min(Min[i][k-1],Min[i+(1<<(k-1))][k-1]);
 72     }
 73     
 74     int LCP(int x,int y){
 75         if(x>y)swap(x,y);x+=1;int k=mm[y-x+1];
 76         int ret=min(Min[x][k],Min[y-(1<<k)+1][k]);
 77         return ret; 
 78     }
 79 }A,B;
 80 
 81 int ln,T,f[N],g[N];char s[N];
 82 int Get_LCP(int x,int y){return A.LCP(A.rank[x],A.rank[y]);}
 83 int Get_LCS(int x,int y){return B.LCP(B.rank[ln-x+1],B.rank[ln-y+1]);} 
 84 
 85 int main(){
 86     freopen("excellent.in","r",stdin);
 87     freopen("excellent.out","w",stdout);
 88     scanf("%d",&T);
 89     while(T--){
 90         A.Init();B.Init();
 91         scanf("%s",s+1);ln=strlen(s+1);
 92         for(int i=1;i<=ln;i++){A.s[i]=s[i];B.s[i]=s[ln-i+1];}
 93         A.Build_Tree();A.Build_SA();
 94         B.Build_Tree();B.Build_SA();
 95         for(int i=1;i<=ln;i++)f[i]=g[i]=0;
 96         
 97         for(int i=1,l,r,x;i+i<=ln;i++)
 98             for(int j=i;(x=j+i)<=ln;j+=i)if(s[j]==s[x]){
 99                 l=x-Get_LCS(j,x)+1;r=x+Get_LCP(j,x)-1;
100                 l=max(l+i-1,x);r=min(r,x+i-1);
101                 if(l>r)continue;
102                 f[l]++,f[r+1]--;
103                    g[l-i-i+1]++,g[r+1-i-i+1]--;
104             }
105         long long ans=0;
106         for(int i=1;i<=ln;i++)f[i]+=f[i-1],g[i]+=g[i-1];
107         for(int i=1;i<ln;i++)ans+=f[i]*g[i+1];
108         printf("%lld\n",ans);
109     }
110     return 0;
111 }
 

　　看在我这么努力的份上，管理员麻烦通过吧。

---

## 作者：Ryan_ (赞：1)

**（解题思路：后缀数组+差分）**


如果能够预处理出

suf[i] 以i结尾的形式为AA的子串个数

pre[i] 以i开头的形式为AA的子串个数

ans= ∑ suf[i]*pre[i+1]

这两个数组的求法，类似bzoj 2119、3238

枚举|A|的长度len，将序列每len个分一块，取每块内第一个元素作为关键点

每个合法的AA恰好占据两个关键点

枚举每一个关键点i，取j=i+len

计算[i,n]和[j,n]的lcp，[1,i]和[1,j]的lcs（通过原串和反串的后缀数组）

假设以i为基准，lcp向后匹配的最远点为r，lcs向前匹配的最远点为l

令cnt=r-l+1 - len + 1

那么AA的开头可以是[l，r]内任意长度为len的子串,这种子串有cnt个，即pre[l,l+cnt-1] 都会加一个贡献

假设以j为基准，lcp向后匹配的最远点为r，lcs向前匹配的最远点为l

令cnt=r-l+1 - len + 1

那么AA的结尾可以是[l，r]内任意长度为len的子串,这种子串有cnt个，即pre[r,r-cnt+1] 都会加一个贡献

利用差分累计贡献

注意：

用后缀数组，有多组数据时，除了统计数量用的v数组要清零，rank数组也要清零


后面+k 使rank 使用超过n的rank，超过n的rank存储的时上一组数据的rank



AC代码：
```
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>

#define N 30002

using namespace std;

int n;
char s[N];

int pre[N],suf[N];

int Log[N];

struct SA
{
    int a[N];
    int sa[2][N],rk[2][N];
    int v[N];
    int p,q;
    int k;
    int height[N];
    int st[N][15];

    void mul(int *sa,int *rk,int *SA,int *RK)
    {
        for(int i=1;i<=n;++i) v[rk[sa[i]]]=i;
        for(int i=n;i;--i) if(sa[i]>k) SA[v[rk[sa[i]-k]]--]=sa[i]-k;
        for(int i=n-k+1;i<=n;++i) SA[v[rk[i]]--]=i;
        for(int i=1;i<=n;++i) RK[SA[i]]=RK[SA[i-1]]+(rk[SA[i]]!=rk[SA[i-1]] || rk[SA[i]+k]!=rk[SA[i-1]+k]);
    }

    void pre_sa()
    {
        p=0; q=1;
        memset(v,0,sizeof(v));
        memset(rk,0,sizeof(rk));
        for(int i=1;i<=n;++i) v[a[i]]++;
        for(int i=1;i<=26;++i) v[i]+=v[i-1];
        for(int i=1;i<=n;++i) sa[p][v[a[i]]--]=i;
        for(int i=1;i<=n;++i) rk[p][sa[p][i]]=rk[p][sa[p][i-1]]+(a[sa[p][i]]!=a[sa[p][i-1]]);
        for(k=1;k<n;k<<=1,swap(p,q)) mul(sa[p],rk[p],sa[q],rk[q]);
    }

    void pre_height()
    {
        int j,k=0;
        for(int i=1;i<=n;++i)
        {
            j=sa[p][rk[p][i]-1];
            while(a[i+k]==a[j+k]) k++;
            height[rk[p][i]]=k;
            if(k) k--;
        }
    }    

    void pre_st()
    {
        memset(st,0,sizeof(st));
        for(int i=2;i<=n;++i) st[i][0]=height[i];
        for(int j=1,k=1;j<=14;++j,k<<=1)
            for(int i=2;i+k*2-1<=n;++i)
                st[i][j]=min(st[i][j-1],st[i+k][j-1]);
    }

    void pre()
    {
        pre_sa();
        pre_height();
        pre_st();
    }

    int get(int i,int j)
    {
        i=rk[p][i]; j=rk[p][j];
        if(i>j) swap(i,j);
        i++;
        int l=Log[j-i+1];
        return min(st[i][l],st[j-(1<<l)+1][l]);    
    }    
};
SA SA1,SA2;

void solve()
{
    memset(pre,0,sizeof(pre));
    memset(suf,0,sizeof(suf));
    int j;
    int lcp,lcs;
    int cnt=0;
    for(int len=1;len<n;++len)
    {
         for(int i=len;i+len<=n;i+=len)
        {
            j=i+len;
            lcp=SA1.get(i,j);
            if(lcp>len) lcp=len;
            lcs=SA2.get(n-i+1,n-j+1);
            if(lcs>len) lcs=len;
            if(lcp+lcs-1>=len)
            {
                suf[j+len-lcs]++;
                suf[j+lcp]--;
                pre[i-lcs+1]++;
                pre[i+lcp-len+1]--;
            }
        }
    }
    for(int i=2;i<=n;++i) pre[i]+=pre[i-1],suf[i]+=suf[i-1];
    long long ans=0;
    for(int i=2;i<=n-2;++i) ans+=1LL*suf[i]*pre[i+1];
    cout<<ans<<'\n';
}

int main()
{
    //freopen("testdata.in","r",stdin); 
    //freopen("__.txt","w",stdout);
    int T;
    scanf("%d",&T);
    for(int i=2;i<N;++i) Log[i]=Log[i>>1]+1;
    while(T--)
    {
        scanf("%s",s+1);
        n=strlen(s+1);
        for(int i=1;i<=n;++i) SA1.a[i]=s[i]-'a'+1;
        memcpy(SA2.a,SA1.a,sizeof(SA2.a));
        reverse(SA2.a+1,SA2.a+n+1);
        SA1.a[n+1]=SA2.a[n+1]=0;
        SA1.pre();
        SA2.pre();
        solve();
    }
}
```


---

## 作者：hzoi_mafia (赞：1)

博客地址：<http://www.cnblogs.com/hzoi-mafia/p/7587221.html>


显然我们不用处理什么AABB，只需要去处理所有AA形式，再去统计答案即可


设pre[i]表示以i这个字符开头的AA型子串的数目


设nxt[i]表示以i这个字符结尾的AA型子串的数目


则答案ans=∑

n−1
i=1
pre[i+1]×nxt[i]


所以问题就转化成了求AA型的子串


我们可以枚举找的AA型子串长度的一半，去判断lcp与lcs


枚举i=k∗len,j=i+len


设x=lcp(suffix(i),suffix(j)),y=lcs(pre(i−1),pre(j−1))


若x+y⩾len,那么我们就找到了x+y−len+1个长度为2×len的AA串


差分一下就GG了


###c++
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
#define mem(x) memset((x),0,sizeof((x)))
struct SA{
    char s[60005];
    int n,m;
    int t1[60005],t2[60005],t3[60005],buc[60005];
    int sa[60005],Rank[60005],height[60005],mn[60005][20];
    SA(){}
    inline void clear(){
        m=130;
        mem(t1),mem(t2),mem(t3),mem(buc),mem(sa),mem(Rank),mem(height),mem(mn);
    }
    inline void init(){
        scanf("%s",s+1);
        n=strlen(s+1);
    }
    inline void Suffix(){
        int i,j,k(0),p(0),*x(t1),*y(t2),*t;
        for(i=0;i<=m;++i)buc[i]=0;
        for(i=1;i<=n;++i)++buc[x[i]=s[i]];
        for(i=1;i<=m;++i)buc[i]+=buc[i-1];
        for(i=n;i>=1;--i)sa[buc[x[i]]--]=i;
        for(j=1;p<n;j<<=1,m=p){
            for(p=0,i=n-j+1;i<=n;++i)y[++p]=i;
            for(i=1;i<=n;++i)
                if(sa[i]>j)
                    y[++p]=sa[i]-j;
            for(i=0;i<=m;++i)buc[i]=0;
            for(i=1;i<=n;++i)t3[i]=x[y[i]];
            for(i=1;i<=n;++i)++buc[t3[i]];
            for(i=1;i<=m;++i)buc[i]+=buc[i-1];
            for(i=n;i>=1;--i)sa[buc[t3[i]]--]=y[i];
            for(t=x,x=y,y=t,x[sa[1]]=1,p=1,i=2;i<=n;++i)
                x[sa[i]]=((y[sa[i]]==y[sa[i-1]])&&(y[sa[i]+j]==y[sa[i-1]+j]))?p:++p;
        }
        for(i=1;i<=n;++i)Rank[sa[i]]=i;
        for(i=1;i<=n;height[Rank[i++]]=k)
            for(k?--k:0,j=sa[Rank[i]-1];s[i+k]==s[j+k];++k);
    }
    inline void ST(){
        for(int i=1;i<=n;++i)mn[i][0]=height[i];
        for(int i=1;(1<<i)<=n;++i)
            for(int j=1;j+(1<<i)-1<=n;++j)
                mn[j][i]=min(mn[j][i-1],mn[j+(1<<i-1)][i-1]);
    }
    inline int lcp(int x,int y){
        if(y>n)return 0;
        x=Rank[x],y=Rank[y];
        if(x>y)swap(x,y);
        ++x;
        int k(0),len(y-x+1);
        while((1<<k)<=len)++k;
        --k;
        return min(mn[x][k],mn[y-(1<<k)+1][k]);
    }
    inline void work(){
        Suffix();
        ST();
    }
}a,b;
inline void inv(){
    b.n=a.n;
    for(int i=1;i<=a.n;++i)
        b.s[i]=a.s[a.n-i+1];
}
typedef long long L;
L ans;
L cnt1[30005],cnt2[30005];
inline void doit(){
    ans=0;
    mem(cnt1),mem(cnt2);
    int edge(a.n>>1);
    for(int l=1;l<=edge;++l)
        for(int i=l,j=l<<1;j<=a.n;i+=l,j+=l){
            int x(min(a.lcp(i,j),l));
            int y(min(b.lcp(a.n-(i-1)+1,a.n-(j-1)+1),l-1));
            int tmp(x+y-l+1);
            if(x+y>=l){
                ++cnt1[i-y];--cnt1[i-y+tmp];
                ++cnt2[j+x-tmp];--cnt2[j+x];
            }
        }
    for(int i=1;i<=a.n;++i)
        cnt1[i]+=cnt1[i-1],cnt2[i]+=cnt2[i-1];
    for(int i=1;i<=a.n;++i)
        ans+=cnt1[i+1]*cnt2[i];
    printf("%lld\n",ans);
}
int main(){
    int T;
    scanf("%d",&T);
    while(T--){
        a.clear(),b.clear();
        a.init();
        a.work();
        inv();
        b.work();
        doit();
    }
}
```
###

---

## 作者：kouylan (赞：0)

显然，AABB 是由两个形如 AA 的串拼成的。设 $a_i,b_i$ 分别表示以 $i$ 为结尾和起点的 AA 串的个数，答案显然是 $\sum{a_i\times b_{i+1}}$。所以关键问题就是求出 $a,b$ 两个数组。

我们可以枚举单个 A 的长度 $l$，以 $l$ 为间距设置一些关键点。因为单个 A 长 $l$，所以 AA 串长 $2\times l$，必定会跨过两个相邻的关键点，假设两个相邻关键点为 $i,j$。我们可以求出 $lcp(i,j)$ 和 $lcs(i-1,j-1)$，显然用 SA 正反个跑一遍即可。

如果跨关键点 $i,j$ 的 AA 串存在，那必须 $lcp+lcs\geq l$。并且 $lcp$ 和 $lcs$ 会有一段交，第一个 A 的结尾可以取在这个交上的任意位置。所以说，对应个数加一的是一段区间，我们就可以用差分求出 AA 的个数了。

下面是 AC 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long

int Q,n,k,ans,a[30005],b[30005];
char str[30005];
int sa1[30005],ht1[30005],rk1[30005],rk3[30005],mn1[30005][20];
int sa2[30005],ht2[30005],rk2[30005],mn2[30005][20];

bool cmp1(int i,int j)
{
	if(rk1[i]!=rk1[j])
		return rk1[i]<rk1[j];
	int ri=(i+k<=n ? rk1[i+k] : -1);
	int rj=(j+k<=n ? rk1[j+k] : -1);
	return ri<rj;
}

void getsa1(int n,char *str)
{
	for(int i=1;i<=n;i++)
		sa1[i] = i, rk1[i] = str[i];
	for(k=1;k<=n;k*=2)
	{
		sort(sa1+1,sa1+1+n,cmp1);
		rk3[sa1[1]] = 1;
		for(int i=2;i<=n;i++)
			rk3[sa1[i]] = rk3[sa1[i-1]]+cmp1(sa1[i-1],sa1[i]);
		for(int i=1;i<=n;i++)
			rk1[i] = rk3[i];
	}
}

void getht1(int n,char *str)
{
	for(int i=1;i<=n;i++)
		rk1[sa1[i]] = i;
	int h=0;
	ht1[1] = 0;
	for(int i=1;i<=n;i++)
	{
		int j=sa1[rk1[i]-1];
		if(h>0)
			h--;
		for(;j+h<=n&&i+h<=n;h++)
			if(str[j+h]!=str[i+h])
				break;
		ht1[rk1[i]] = h;
	}
}

int getlcp1(int x,int y)
{
	if(x==y)
		return n-x+1;
	x = rk1[x], y = rk1[y];
	if(x>y)
		swap(x,y);
	int k=log2(y-x);
	return min(mn1[x+1][k],mn1[y-(1<<k)+1][k]);
}

bool cmp2(int i,int j)
{
	if(rk2[i]!=rk2[j])
		return rk2[i]<rk2[j];
	int ri=(i+k<=n ? rk2[i+k] : -1);
	int rj=(j+k<=n ? rk2[j+k] : -1);
	return ri<rj;
}

void getsa2(int n,char *str)
{
	for(int i=1;i<=n;i++)
		sa2[i] = i, rk2[i] = str[i];
	for(k=1;k<=n;k*=2)
	{
		sort(sa2+1,sa2+1+n,cmp2);
		rk3[sa2[1]] = 1;
		for(int i=2;i<=n;i++)
			rk3[sa2[i]] = rk3[sa2[i-1]]+cmp2(sa2[i-1],sa2[i]);
		for(int i=1;i<=n;i++)
			rk2[i] = rk3[i];
	}
}

void getht2(int n,char *str)
{
	for(int i=1;i<=n;i++)
		rk2[sa2[i]] = i;
	int h=0;
	ht2[1] = 0;
	for(int i=1;i<=n;i++)
	{
		int j=sa2[rk2[i]-1];
		if(h>0)
			h--;
		for(;j+h<=n&&i+h<=n;h++)
			if(str[j+h]!=str[i+h])
				break;
		ht2[rk2[i]] = h;
	}
}

int getlcp2(int x,int y)
{
	if(x==y)
		return n-x+1;
	x = rk2[x], y = rk2[y];
	if(x>y)
		swap(x,y);
	int k=log2(y-x);
	return min(mn2[x+1][k],mn2[y-(1<<k)+1][k]);
}

signed main()
{
	cin>>Q;
	while(Q--)
	{
		memset(a,0,sizeof(a)), memset(b,0,sizeof(b));
		scanf("%s",str+1);
		n = strlen(str+1);
		getsa1(n,str), getht1(n,str);
		for(int i=1;i<=n;i++)
			mn1[i][0] = ht1[i];
		for(int j=1;j<20;j++)
			for(int i=1;i+(1<<j-1)<=n;i++)
				mn1[i][j] = min(mn1[i][j-1],mn1[i+(1<<j-1)][j-1]);
		reverse(str+1,str+1+n);
		getsa2(n,str), getht2(n,str);
		for(int i=1;i<=n;i++)
			mn2[i][0] = ht2[i];
		for(int j=1;j<20;j++)
			for(int i=1;i+(1<<j-1)<=n;i++)
				mn2[i][j] = min(mn2[i][j-1],mn2[i+(1<<j-1)][j-1]);
		for(int l=1;l<=n;l++)
			for(int i=l;i+l<=n;i+=l)
			{
				int j=i+l;
				int lcp=getlcp1(i,j),lcs=(i==1 ? 0 : getlcp2(n-(i-1)+1,n-(j-1)+1));
				if(lcp+lcs<l)
					continue;
				int s=lcp+lcs-l+1,lef=0,rht=0;
				lef = j-min(lcs,l-1)+l-1;
				rht = min(j+min(lcp,l)-1,n);
				if(lef<=rht)
					a[lef]++, a[rht+1]--;
				lef = max(i-min(lcs,l-1),1ll);
				rht = i+min(lcp,l)-1-l+1;
				if(lef<=rht)
					b[lef]++, b[rht+1]--;
			}
		ans = 0;
		for(int i=1;i<=n;i++)
			a[i] += a[i-1], b[i] += b[i-1];
		for(int i=1;i<=n-2;i++)
			ans += a[i]*b[i+1];
		cout<<ans<<endl;
	}
	
	return 0;
}
```

祝大家 AC 愉快！

---

## 作者：tzc_wk (赞：0)

[题面传送门](https://www.luogu.com.cn/problem/P1117)

神仙 SA %%%

考虑设 $a_i$ 为以位置 $i$ 开头的 AA 型字符串的个数，再设 $b_i$ 为以位置 $i$ 结尾的 AA 型字符串的个数，那么答案应为 $\sum\limits_{i=2}^{n}a_ib_{i-1}$

现在的问题就是怎样求 $a_i$ 和 $b_i$。我们考虑枚举 AA 型字符串中 $A$ 的长度 $l$。每隔 $l$ 格放一个关键点，即，在位置 $l,2l,3l,\dots$ 放关键点。显然，一个长度为 $2l$ 的 AA 型字符串应当经过恰好两个关键点。

考虑相邻的两个关键点 $i,j$，显然 $j=i+l$，我们计算经过这两个关键点的 AA 型字符串的个数。设 $LCP$ 为以 $i,j$ 开头的后缀的 LCP 的长度，$LCS$ 为以 $i,j$ 开头的前缀的 LCS 的长度。如果 $LCP+LCS>l$ 就有字符串经过它们，个数为 $LCP+LCS-l$，否则没有字符串。差分一下即可求得 $a,b$。至于怎样求 $LCP$ 和 $LCS$，正反各后缀数组一遍即可。

时间复杂度 $\mathcal O(n+\dfrac{n}{2}+\dfrac{n}{3}+\dots)=\mathcal O(n\log n)$

```cpp
#include <bits/stdc++.h>
using namespace std;
#define fi first
#define se second
#define fz(i,a,b) for(int i=a;i<=b;i++)
#define fd(i,a,b) for(int i=a;i>=b;i--)
#define ffe(it,v) for(__typeof(v.begin()) it=v.begin();it!=v.end();it++)
#define fill0(a) memset(a,0,sizeof(a))
#define fill1(a) memset(a,-1,sizeof(a))
#define fillbig(a) memset(a,63,sizeof(a))
#define pb push_back
#define ppb pop_back
#define mp make_pair
template<typename T1,typename T2> void chkmin(T1 &x,T2 y){if(x>y) x=y;}
template<typename T1,typename T2> void chkmax(T1 &x,T2 y){if(x<y) x=y;}
typedef pair<int,int> pii;
typedef long long ll;
template<typename T> void read(T &x){
	x=0;char c=getchar();T neg=1;
	while(!isdigit(c)){if(c=='-') neg=-1;c=getchar();}
	while(isdigit(c)) x=x*10+c-'0',c=getchar();
	x*=neg;
}
const int MAXN=3e4;
const int LOG_N=15;
int n;
struct solver{
	char s[MAXN+5];
	pii x[MAXN+5];
	int buc[MAXN+5],rk[MAXN+5],sa[MAXN+5],seq[MAXN+5],ht[MAXN+5];
	int st[MAXN+5][LOG_N+2];
	void init(){
		memset(s,0,sizeof(s));memset(buc,0,sizeof(buc));memset(sa,0,sizeof(sa));
		memset(seq,0,sizeof(seq));memset(ht,0,sizeof(ht));memset(st,0,sizeof(st));
		fill(x,x+MAXN+1,mp(0,0));
	}
	void getsa(){
		int vmax=122,gr=0;
		for(int i=1;i<=n;i++) buc[s[i]]++;
		for(int i=1;i<=vmax;i++) buc[i]+=buc[i-1];
		for(int i=n;i;i--) sa[buc[s[i]]--]=i;
		for(int i=1;i<=n;i++){
			if(s[sa[i]]!=s[sa[i-1]]) gr++;
			rk[sa[i]]=gr;
		} vmax=gr;
		for(int k=1;k<=n;k<<=1){
			for(int i=1;i<=n;i++){
				if(i+k<=n) x[i]=mp(rk[i],rk[i+k]);
				else x[i]=mp(rk[i],0);
			} memset(buc,0,sizeof(buc));int num=0;
			for(int i=n-k+1;i<=n;i++) seq[++num]=i;
			for(int i=1;i<=n;i++) if(sa[i]>k) seq[++num]=sa[i]-k;
			for(int i=1;i<=n;i++) buc[x[i].fi]++;
			for(int i=1;i<=vmax;i++) buc[i]+=buc[i-1];
			for(int i=n;i;i--) sa[buc[x[seq[i]].fi]--]=seq[i];
			gr=0;for(int i=1;i<=n;i++){
				if(x[sa[i]]!=x[sa[i-1]]) gr++;
				rk[sa[i]]=gr;
			} vmax=gr;if(vmax==n) break;
		}
	}
	void getht(){
		int k=1;
		for(int i=1;i<=n;i++){
			if(rk[i]==1) continue;
			if(k) k--;
			int j=sa[rk[i]-1];
			while(i+k<=n&&j+k<=n&&s[i+k]==s[j+k]) k++;
			ht[rk[i]]=k;
		}
	}
	void buildst(){
		for(int i=2;i<=n;i++) st[i][0]=ht[i];
		for(int i=1;i<=LOG_N;i++) for(int j=2;j+(1<<i)-1<=n;j++)
			st[j][i]=min(st[j][i-1],st[j+(1<<(i-1))][i-1]);
	}
	int query(int x,int y){
		x=rk[x];y=rk[y];if(x>y) swap(x,y);x++;
		int k=log2(y-x+1);return min(st[x][k],st[y-(1<<k)+1][k]);
	}
} s[2];
int da[MAXN+5],db[MAXN+5],a[MAXN+5],b[MAXN+5];
void init(){
	memset(da,0,sizeof(da));memset(db,0,sizeof(db));
	memset(a,0,sizeof(a));memset(b,0,sizeof(b));
} 
void solve(){
	scanf("%s",s[0].s+1);n=strlen(s[0].s+1);
	for(int i=1;i<=n;i++) s[1].s[n-i+1]=s[0].s[i];
	for(int i=0;i<2;i++) s[i].getsa(),s[i].getht(),s[i].buildst();
	for(int l=1;l<=n;l++){
		for(int j=l;j+l<=n;j+=l){
			int lcp=s[0].query(j,j+l);
			int lcs=s[1].query(n-j+1,n-j-l+1);
			lcs=min(lcs,l);lcp=min(lcp,l); 
//			printf("%d %d %d %d\n",l,j,lcp,lcs);
			if(lcp+lcs-1>=l){
				int len=lcp+lcs-l;
				da[j-lcs+1]++;da[j-lcs+len+1]--;
				db[j-lcs+2*l]++;db[j-lcs+len+2*l]--;
			}
		}
	}
	for(int i=1;i<=n;i++) a[i]=a[i-1]+da[i],b[i]=b[i-1]+db[i];
//	for(int i=1;i<=n;i++) printf("%d%c",a[i],(i==n)?'\n':' ');
//	for(int i=1;i<=n;i++) printf("%d%c",b[i],(i==n)?'\n':' ');
	ll ans=0;for(int i=1;i<n;i++) ans+=1ll*b[i]*a[i+1];
	printf("%lld\n",ans);
	s[0].init();s[1].init();init();
}
int main(){
	int qu;scanf("%d",&qu);
	while(qu--) solve();
	return 0;
}
```



---


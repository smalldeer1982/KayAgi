# 杠杆数

## 题目描述

如果把一个数的某一位当成支点，且左边的数字到这个点的力矩和等于右边的数字到这个点的力矩和，那么这个数就可以被叫成杠杆数。

比如 $4139$ 就是杠杆数，把 $3$ 当成支点，我们有这样的等式：$4\times 2+1\times 1=9\times 1$。

给定区间 $[x,y]$，求出在 $[x,y]$ 中有几个杠杆数。

## 说明/提示

### 数据范围及约定

- 对于 $40\%$ 的数据，$x \le y \le x+10^5$；
- 对于 $100\%$ 的数据，$1 \le x \le y \le 10^{18}$。

## 样例 #1

### 输入

```
7604 24324```

### 输出

```
897```

# 题解

## 作者：SNiFe (赞：22)

#此题是数位DP，没学过数位DP的，这可以是一道很经典的入门题目

**1.** 本题是一道数位DP，首先我们可以只考虑设计算法求[1,x]这个区间内符合条件的数的个数即可。因为[x,y]这个区间内的个数实际上是[1,y]区间内的个数减去[1,x-1]区间内的个数。（注意要把0特殊出来考虑）

**2.**之后我们可以枚举支点的位置，对于每个满足条件的数，它所对应的支点是唯一的，原因是如果将支点右移，左边减去右边的差将严格单调增加。state表示力矩和（支点左边加支点右边），所以当state<0时，当前这个数不满足以i为支点成为杠杆数的情况，返回0。但当state==0时并不能就ans++了，因为当前枚举的位置可能还没枚举完。

**3.**枚举好支点，问题就转化为：求[1,x]中，以第i位为支点的杠杆数的个数。

==》 我们就可以用数位DP解决此问题。

注意：注意当力矩为负时，就要返回，否则会出现下标为负。

（数位DP可以从后往前推，也可以用记忆化搜索。我比较喜欢记忆化搜索，比较有套路。）

#代码附上：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define LL long long
using namespace std;
const int N=20;
int a[N];//储存每一位的大小 
LL dp[N][N][2500],l,r;//dp[i][j][k]表示考虑i位数字，支点为j，力矩和为k 
LL dfs(int pos,int point,int state,bool limit)//pos是几位数字；ponit是支点；state是力矩；limit表示当前这一位有无大小限制，防止枚举超过上限 
{
    if(pos==0)return state==0;//判断是否合法 
    if(state<0)return 0;//当前力矩为负
    if(!limit&&dp[pos][point][state]!=-1)return dp[pos][point][state];
    int up=limit?a[pos]:9;//数位上限 
    LL tmp=0;
    for(int i=0;i<=up;i++)tmp+=dfs(pos-1,point,state+i*(pos-point),limit&&(i==up));
    if(!limit)dp[pos][point][state]=tmp;
    return tmp;
}
LL solve(LL x)
{
    int len=0;
    while(x)
    {
        a[++len]=x%10;
        x/=10;
    }
    LL ans=0;
    for(int i=1;i<=len;i++)ans+=dfs(len,i,0,1);
    return ans-len+1;//每次dfs都会重复搜索到00000……的情况这里减去重复数 
}
int main()
{
    scanf("%lld %lld",&l,&r);
    memset(dp,-1,sizeof(dp));
    printf("%lld",solve(r)-solve(l-1));
    return 0;
}
```

---

## 作者：xuanxuan001 (赞：12)

这题没看题解自己想了一个做法，发现和题解不太一样，于是就发了这篇题解。

题解都要枚举支点，但我不用，我直接求出支点然后判断是否是整点。

正文
-
我们设这个数是 $\overline{a_0 a_1 a_2 \dots a_n}$，那么如果支点在 $a_x$ 上，两边力的差值（右边力减左边力，下同） $\sum\limits_{i=0}^n a_i \times (i - x)$，所以每将支点往右移一位，力的差值就会减少 $\sum\limits_{i=0}^n a_i$。而 $x = 0$ 时的值为 $\sum\limits_{i=0}^n a_i \times i$，所以支点的位数就是

$$
\dfrac{\sum\limits_{i=0}^n a_i \times i}{\sum\limits_{i=0}^n a_i}
$$

然后只要判断这个数是否为整数即可，即下面是否整除上面。

然后就只需要一个数位 DP 即可，状态就是位数和上面两个值。

计算发现两个值最大是都是 18 个 9，由此算出状态一的上限是 1377，二的是 162。DP 完之后将所有状态枚举一遍，将其中整除的状态的值求和即可。

~~虽然最后算起来我的状态数是题解的大约 5 倍，但是呢，至少是另一种思路~~

好吧，然后就没的说了。

代码
-
```cpp
#include<cstdio>
#include<stack>
#define Ty ll
#define FOR(i,a,b) for(Ty i=a;i<=b;i++)
#define fOR(i,a,b) for(Ty i=a;i<b;i++)
#define ROF(i,a,b) for(Ty i=a;i>=b;i--)
#define rOF(i,a,b) for(Ty i=a;i>b;i--)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
Ty _abs(Ty a){return a<0?-a:a;}
Ty maxn(Ty a,Ty b){return a>b?a:b;}
Ty minn(Ty a,Ty b){return a<b?a:b;}
Ty qr(){
	char ch=getchar();Ty x=1,s=0;
	while(ch<'0'||ch>'9'){if(ch=='-')x=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}
	return x*s;
}Ty l,r,dp[1380][165],s1,s2;//用了滚动数组，因为下一位选 0 时两个值都不变，刚好适合滚动 
Ty js(Ty a){
	s1=s2=0;Ty ans=0;stack<Ty>s;
	fOR(i,0,1380)fOR(j,0,165)dp[i][j]=0;
	while(a){s.push(a%10);a/=10;}//从高到低处理数位 
	for(Ty x=0;s.size();x++){
		ROF(i,1379,0)ROF(j,164,0)fOR(k,1,10){
			if(i+x*k>1379||j+k>164)continue;
			dp[i+x*k][j+k]+=dp[i][j];//数组内是前面的数位已经比上限小的，这次数位可以任选 
		}fOR(k,0,s.top())dp[s1+x*k][s2+k]++;//目前前面与上限相同的有限制 
		s1+=x*s.top();s2+=s.top();s.pop();
	}fOR(i,0,1380)fOR(j,1,165)if(i%j==0)ans+=dp[i][j];
	//这个函数只统计了小于 a 的杠杆数，所以调用时是 l 和 r+1 
	return ans;
}
int main(){
	l=qr();r=qr();
	printf("%lld",js(r+1)-js(l));
	return 0;
}
```

---

## 作者：TainityAnle (赞：7)

**题目大意：**

- 定义一个数是平衡的，当且仅当把他开成杠杆，存在一个支点使它平衡。

- 例如 $4139$，当 $3$ 作为支点时，左边力矩是 $4\times2+1\times1=9$，右边力矩是 $9\times1=9$，所以 $4139$ 是平衡数。
- 询问 $[L, R]$ 中有多少个平衡数。

- $0\le L\le R\le10^{18}$。

**解题思路：**

- 把问题转化为小于等于 $N$ 的数有几个符合状态。

---
- 考虑如何设计状态。

- 一个数只会有一个支点。
- 因此我们枚举支点位置去统计答案。

---
- 直接存左边力矩和减去右边力矩和，最后判断是否为 $0$ 即可。

- 四维 DP，状态设置为 $f_{less,dep,cur,sum}$。
- 表示当前枚举到了第 $dep$ 位，左右力矩和差为 $sum$。
- 假设枚举的支点位置是 $cur$，那么在 $dep$ 位填上 $i$ 就会对 $sum$ 产生 $i\times(dep-cur)$ 的贡献。

然后就完了，有一点很重要，不开 long long 见祖宗。

**AC Code**（和楼下大佬们有相似之处，但不一样）：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long f[2][20][20][1600],x,y,a[20];
long long dp(int less,int dep,int cur,int sum) {
	if(!dep) return sum==0;
	if(sum<0) return 0;
	if(~f[less][dep][cur][sum]) return f[less][dep][cur][sum];
	int ed=less?9:a[dep];
	long long ans=0;
	for(int i=0; i<=ed; i++) ans+=dp((less||(i<ed)),dep-1,cur,sum+i*(dep-cur));
	return f[less][dep][cur][sum]=ans;
}
long long asd(long long n) {
	if(n<0) return 0;
	if(n==0) return 1;
	a[0]=0;
	while(n) a[++a[0]]=n%10,n/=10;
	long long ans=0;
	memset(f,-1,sizeof f);
	for(int i=1; i<=a[0]; i++) ans+=dp(0,a[0],i,0);
	return ans-a[0]+1;
}
int main() {
	cin>>x>>y;
	cout<<asd(y)-asd(x-1);
	return 0;
}
```

---

## 作者：漠寒 (赞：3)

## 分析

看到题的第一反应，存储前面 n 位的值乘坐标，然后暴力检查，然而时间复杂度虽是可的，但没有正确性，我们发现对于同一个值，可能有多种可能性，比如第一位为三，第二位为一和第一位为三，第二位为二以此种方法计算出的值是相同的，但很明显他们对应的方案不一样。

因此我们需要考虑一种对于一个计算出的值，我们能百分之百保证它的 dp 中存的方案数是正确的，所以我们考虑确定支点的位置，可以发现在你确定了支点之后，无论你怎么弄前面的 n 位，后面的方案数一定是确定的，做个类比，你之前的不确定支点位置的情况下，左右移动端点会影响方案数，但在确定了支点后这种情况就避免掉了，所以对于一个数，我们枚举第一位到最后一位作为支点，在数位 dp 过程中，力矩加值为该位乘上支点下标减去该位置下标，小于零时排除掉，所以我们 pos 从一开始，这样就可以先为正值，后面变为负值时就可以放心排除了。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int dp[20][2500],tot,sw[25],a,b,qz[20],ss[20];

int dfs(int pos,int zd,int lim,int he){//位置，支点，上限，力矩和 
	if(pos==tot+1)return he==0;
	if(he<0)return 0;
	if(!lim&&dp[pos][he]!=-1)return dp[pos][he];
	int sum=0,mx=lim?sw[tot-pos+1]:9;
	for(int i=0;i<=mx;i++){
		sum+=dfs(pos+1,zd,lim&&(i==mx),he+i*(zd-pos));
	}
	if(!lim)return dp[pos][he]=sum;
	return sum;
}

int search(int x){
	if(x==0)return 1;
	tot=0;
	while(x){
		sw[++tot]=x%10;
		x/=10;
	}
	memset(dp,-1,sizeof(dp));
	int sum=0;
	for(int i=1;i<=tot;i++){//枚举支点 
		memset(dp,-1,sizeof(dp));
		sum+=dfs(1,i,1,0);
	}
	return sum-tot+1;
}

signed main()
{
	cin>>a>>b;
	cout<<search(b)-search(a-1);//前缀思想 
	return 0;
}

```


---

## 作者：Boxxxxxx (赞：3)

[博客](https://blog.csdn.net/qq_43804974/article/details/104533930)

这题解是做一个额外的补充说明，补充些在其他题解里面没有的其他东西。

首先是之所以可以数位dp并且不会算错的原因是，对于每一个数字，如果这个数字是杠杆数，那么他的支点有且只有一个，如果一个数字有多个支点，那么数位dp去枚举支点就会算重复，算多。

另外全部人都是在说数位dp然后枚举支点，对R和L-1分别做一次dp，但是可以有个小优化就是，我们要明确一个东西，dp数组存的是那些没有被限制的的有用数字是数量，也就是对于任意数都适用。

那么我们可以发现在枚举支点位置的时候，枚举位置1，对于R和L-1都分别去dfs了一次，但是实际上所做的效果是一样的，因为对于没有被限制的数字他的数量是不会变的，所以我们可以把两个数字一起来算，每一次枚举支点都可以一次性统计。
```cpp
int solve(int x,int y) {//L, R
	memset(dp, -127, sizeof(dp));
	int pos1 = 0,pos2 = 0;
	while (x) {
		num[1][pos1++] = x % 10;
		x /= 10;
	}
	while (y) {
		num[2][pos2++] = y % 10;
		y /= 10;
	}
	int ans1 = 0,ans2 = 0;
	for (int i = 0; i < 17; i++) {
		ans2 += dfs(pos2 - 1, true, 0, i, 0, 2);
		ans1 += dfs(pos1 - 1, true, 0, i, 0, 1);
	}
	return ans2 - ans1;
}
```
这是我是solve函数，枚举所有的支点位置，然后一起统计就可以了，这样就可以充分的利用之前跑出一遍所获得的贡献，在一个另外的点就是，你还可以在开一个维度，那个维度代表的就是你现在枚举的是哪个支点，就是空间换时间，你就可以不用每次枚举支点的时候都来一次memset。

---

## 作者：AcerMo (赞：3)

~~搜索大法好~~
### 记忆化搜索
区间求符合条件的数的个数，不出意外应该是记搜大法好了2333。

我们枚举平衡点，然后最后判断两侧数是否相等就行了

#### 我们定义dfs(int p,int w,int s,bool j,bool z)
分别表示第p位，平衡点在第w位，当前和为s，是否有数位限制，是否有前导零

然后我们就可以大力搜索了，s的更新是s+(p-w)*i发现平衡点两侧的p-w符号不同，然后剪枝，当s<0时，return 0，因为以后不可能加成非负数
#### 总的来说比楼下的多一个判掉前导零

### 代码
```cpp
//By AcerMo
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define lli long long int
using namespace std;
lli lim[20],f[20][20][3050];
inline lli dfs(int p,int w,int s,bool j,bool z)
{
	if (!p) return (z==0&&s==0);
	if (s<0) return 0;
	if (!j&&f[p][w][s]!=-1) return f[p][w][s];
	int emm=j?lim[p]:9;lli ans=0;
	for (int i=0;i<=emm;i++)
	ans+=dfs(p-1,w,s+i*(p-w),j&&(i==emm),z&&(i==0));
	if (!j&&!z) f[p][w][s]=ans;
	return ans;
}
inline lli slove(lli x)
{
	int len=0;
	while (x) lim[++len]=x%10,x/=10;
	memset(f,-1,sizeof(f));
	lli ans=0;
	for (int i=1;i<=len;i++) 
	ans+=dfs(len,i,0,1,1);
	return ans;
}
signed main()
{
	lli l,r;cin>>l>>r;	
	cout<<slove(r)-slove(l-1);
	return 0;
}	
```

---

## 作者：xiangshengtao (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P1831)

一道数位DP题，但是要说简单，那不得不提提我们的记忆化搜索了。

## 思路
普通的数位DP用记忆化搜索做只需要跑 $1$ 遍，而这道题你得跑很多遍（因为你不知道支点），然后我们开始列举一下我们程序中的变量：

$w$：位数，列举已经做到第几位。

$zd$：枚举的支点。

$st$：判断有没有超范围。

$p0$：排除前导零。

$sum$：题目中有提到，就是到支点的力矩和。

接下来，就是这道题的核心——记忆化搜索：

首先，我们要求出范围数中的各个数位上的数，为接下来的比较大小打好基础。然后，做 $w$（总位数）次，用来枚举支点，记忆化搜索里枚举这当前位的数字，然后如果构造的数字会超过范围数，那么直接退出，不然就加入总数，最后因为我们无法直接求 $x \sim y$ 之间的杠杆数，那么我们可以 $y$ 以内的杠杆数减去 $x-1$ 以内的杠杆数。

## 注意
记忆化搜索一定要看看数组的内存，看看会不会炸。

## 程序
```cpp
#include<bits/stdc++.h>
#define int long long//1e18，不开long long直接废掉
using namespace std;
int x,y,a[20],f[20][20][2][2][3210];
int dfs(int w,int zd,int st,int p0,int sum){
	if (w==0) return !p0&&sum==0;//w个做完了，判断
	if (f[w][zd][st][p0][sum]!=-1) return f[w][zd][st][p0][sum];//记忆化
	int i,ans=0;
	for (i=0;i<=9;i++)
		if (st==1&&i>a[w]) break;
		else ans+=dfs(w-1,zd,st&&i==a[w],p0&&i==0,sum+(zd-w)*i);
	return f[w][zd][st][p0][sum]=ans;//记忆化
}
int qiu(int x){
	int w=0,i,ans=0;
	while (x>0) a[++w]=x%10,x=x/10;
	memset(f,-1,sizeof(f));
	for (i=1;i<=w;i++) ans=ans+dfs(w,i,1,1,0);//枚举支点
	return ans; 
}
signed main(){
	scanf("%lld%lld",&x,&y);
	printf("%lld\n",qiu(y)-qiu(x-1));
	return 0;
}
```


---

## 作者：Sweetie_Liu (赞：0)

## 免责声明，个人见解，不喜勿喷
话说数位DP,它是个非常又套路的东西，除了神仙题呢...

我们发现我们这个支点是无法处理的东西，所以枚举，之后我们就按题目要求去进行Dp就行啦，注意细节，**不判Sum<0的同学要记得平移数组啊**，而且要把数组开够呢~~

我知道你们会说我水，所以放个安利链接，这几道题可先做了，再回来开这个就比较显然啦····

[My Blog](https://www.luogu.org/blog/lemonYge/shuo-wei-dp-xue-xi-bi-ji)

***记得开longlong（凶***

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <vector>
#include <map>
#include <queue>
using namespace std;
typedef long long ll;
const int MAXN = 11;
int shu[11];
ll dp[20][3500];
ll dfs(int len,int ziiidan,int Sum,int shangxian){
	if(len<=0)return Sum==0;
	if(Sum<0)return 0;
	if(!shangxian&&dp[len][Sum]!=-1)return dp[len][Sum];
	ll cnt = 0;int Maxx = shangxian?shu[len]:9;
	for(int i=0;i<=Maxx;i++){
		cnt += dfs(len-1,ziiidan,Sum+i*(len-ziiidan),shangxian&&(i==shu[len]));
	}
	return shangxian?cnt:dp[len][Sum] = cnt;
}
ll Solve(ll x){
	memset(shu,0,sizeof(shu));
	int k = 0;
	while(x){
		shu[++k] = x%10;
		x/= 10;
	}
	ll ans = 0;
	for(int i=1;i<=k;i++){
		memset(dp,-1,sizeof(dp));
		ans += dfs(k,i,0,1);
	}
	return ans-k+1;
}
ll x,y;
int main(){
	cin>>x>>y;
	cout<<Solve(y)-Solve(x-1);
	return 0;
}
```

---

## 作者：斗神_君莫笑 (赞：0)

状压dp的经典模板题  
建议初学者阅读[洛谷日报](https://www.luogu.org/blog/virus2017/shuweidp)，这个写的是真的好  
数位dp的套路大致相当，题刷多了就知道了  
本题只需要枚举支点的位置，判断两端是否平衡  
详细内容参见代码   
```cpp
#include<bits/stdc++.h>
using namespace std;
long long f[20][20][2010],a[20];
long long dfs(int deep,int point,int sum,int limit){
	if(deep==0)return sum==0;//搜索结束，返回是否平衡 
	if(sum<0)return 0;//另一侧超重，及时推退出 
	if(!limit&&f[deep][point][sum]!=-1)return f[deep][point][sum];//没有限制并且搜索过,直接返回 
	int maxx;
	if(limit)maxx=a[deep];
	else maxx=9;//为本次搜索最大范围赋初值 
	long long ans=0;
	for(int i=0;i<=maxx;++i)
		ans+=dfs(deep-1,point,sum+(deep-point)*i,limit&&(i==maxx));
		//搜索下一个点,(深度-1,枚举的支点,两端力矩差,是否需要限制) 
	if(!limit)f[deep][point][sum]=ans;//没有限制就存储答案 
	return ans;
}
long long solve(long long x){
	memset(a,0,sizeof(a));
	int cnt=0;
	while(x)
		a[++cnt]=x%10,x/=10;//分离数位 
	long long ans=0;
	for(int i=1;i<=cnt;++i)
		ans+=dfs(cnt,i,0,1);
		//为什么开始limit是1?因为只有这样搜索时才能传递limit标记 
		//依次枚举支点位置 
	return ans-cnt+1;//减去重复为0的情况 
    //注意这里每一次搜索都会出000…0000,需要排除
}
int main(){
	long long l,r;
	scanf("%lld%lld",&l,&r);
	memset(f,-1,sizeof(f));
	printf("%lld",solve(r)-solve(l-1));//作差，经典方法 
	return 0;
}
```


---

## 作者：litc (赞：0)

本题是一道数位统计题，首先我们可以只考虑设计算法求[1,x]这个区间内符合条件的数的个数即可。因为[x,y]这个区间内的个数实际上是[1,y]区间内的个数减去[1,x-1]区间内的个数。（注意要把0特殊出来考虑）

之后我们可以枚举支点的位置，对于每个满足条件的数，它所对应的支点是唯一的，原因是如果将支点右移，左边减去右边的差将严格单调增加。

枚举好支点，问题就转化为：求[1,x]中，以第k位为杠杆的杠杆数的个数。

我们就可以用DP解决此问题。用f[i][j][k]表示考虑到第i位，左边权值减右边权值差为j的情况个数。

k=0或k=1，分别表示枚举到当前位数时，数比x小或等于x。分情况讨论累加。

DP可以从后往前推，也可以用记忆化搜索。


---


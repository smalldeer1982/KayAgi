# [SDOI2009] 学校食堂

## 题目描述

小 F 的学校在城市的一个偏僻角落，所有学生都只好在学校吃饭。学校有一个食堂，虽然简陋，但食堂大厨总能做出让同学们满意的菜肴。当然，不同的人口味也不一定相同，但每个人的口味都可以用一个非负整数表示。 由于人手不够，食堂每次只能为一个人做菜。做每道菜所需的时间是和前一道菜有关的，若前一道菜的对应的口味是 $a$，这一道为 $b$，则做这道菜所需的时间为 $(a\operatorname{or}b)-(a\operatorname{and}b)$，而做第一道菜是不需要计算时间的。其中，$\operatorname{or}$ 和 $\operatorname{and}$ 表示整数逐位或运算及逐位与运算，C 语言中对应的运算符为 `|` 和 `&`。


学生数目相对于这个学校还是比较多的，吃饭做菜往往就会花去不少时间。因此，学校食堂偶尔会不按照大家的排队顺序做菜，以缩短总的进餐时间。

虽然同学们能够理解学校食堂的这种做法，不过每个同学还是有一定容忍度的。也就是说，队伍中的第 $i$ 个同学，最多允许紧跟他身后的 $B_i$ 个人先拿到饭菜。一旦在此之后的任意同学比当前同学先拿到饭，当前同学将会十分愤怒。因此，食堂做菜还得照顾到同学们的情绪。 现在，小 F 想知道在满足所有人的容忍度这一前提下，自己的学校食堂做完这些菜最少需要多少时间。


## 说明/提示

对于第一组数据：

同学 1 允许同学 2 或同学 3 在他之前拿到菜；同学 2 允许同学 3 在他之前拿到菜；同学 3 比较小气，他必须比他后面的同学先拿菜。

一种最优的方案是按同学 3、同学 2、同学 1、同学 4、同学 5 做菜，每道菜所需的时间分别是 0、8、1、6 及 1。


**数据规模和约定**

- 对于 $30\%$ 的数据，满足 $1 \le N \le 20$。

- 对于 $ 100\% $ 的数据，满足 $1 \le N \le 1000,0 \le T_i \le 1000,0 \le B_i \le 7，1 \le C \le 5$。

- 存在 $30\%$ 的数据，满足 $0 \le B_i \le 1$。

- 存在 $65\%$ 的数据，满足 $0 \le B_i \le 5$。

- 存在 $45\%$ 的数据，满足 $0 \le T_i \le 130$。


## 样例 #1

### 输入

```
2
5
5 2
4 1
12 0
3 3
2 2
2
5 0
4 0```

### 输出

```
16
1
```

# 题解

## 作者：xyz32768 (赞：162)

状压$DP$。

设$f[i][j][k]$表示第$1$个人到第$i-1$个人已经打完饭，第$i$个人以及后面$7$个人是否打饭的状态为$j$，当前最后一个打饭的人的编号为$i+k$（$k$的范围为$-8$到$7$，所以用数组存时要加上$8$），那么转移为：

当$j&1$为真，就表示第$i$个人已经打完饭，$i$之后的$7$个人中，还没打饭的人就再也不会插入到第$i$个人前面了。所以这时候可以转移到$f[i+1][j>>1][k-1]$，即$f[i+1][j>>1][k-1]=min(f[i+1][j>>1][k-1],f[i][j][k])$，不需要累积时间（因为在$j&1$为真的情况下，$f[i][j][k]$和$f[i+1][j>>1][k-1]$的意义是一样的）。

而为什么意义是一样的呢？因为可以看出，最后一个打饭的人的编号为$(i+1)+(k-1)=i+k$，和$f[i][j][k]$表示的一样。而第$i$个人也打完了饭，所以满足「第$1$个人到第$i$个人已经打完饭」这个条件。而$j>>1$就是说$i$之后的第$1$个人就是$i+1$之后的第$0$个人（就是$i+1$本人），$i$之后的第$2$个人就是$i+1$之后的第$1$个人，$i$之后的第$3$个人就是$i+1$之后的第$2$个人，…。这样就可以看出意义一样了。

当$j&1$为假时，是没办法转移到$f[i+1]$的（因为$i+1$之前的人还有$i$没有打完饭）。但是这时候可以把$i$以及$i$之后的$7$个人中选出一个人打饭，也就是枚举$h$从$0$到$7$，$f[i][j|(1<<h)][h]=min(f[i][j|(1<<h)][h],f[i][j][k]+time(i+k,i+h))$，其中$time(i,j)$表示如果上一个人编号为$i$，当前的人编号为$j$，那么做编号为$j$的人的菜需要的时间。
当然，这个转移需要考虑到忍耐度的问题。这样，在$i$和$i$之后的$7$个人，不是每一个还未打饭的人都可以先打饭的。因为编号在他之前的所有未打饭的人的忍耐度必须能忍受这个人在他们之前打饭。所以，在这里用了一个变量$r$来统计了一下，表示到目前为止的未打饭的人的忍受范围（注意，不是忍耐度，忍受范围是指能忍受在其之前打饭的最大**位置**）的最小值，对于任何一个人，如果$i+h>r$，就表示他无法满足编号在他之前的所有人的忍受范围，就不要考虑这个人了。代码实现如下：

```cpp
lir = INF;
for (h = 0; h <= 7; h++) if (!((j >> h) & 1)) {
    if (i + h > lir) break;
    chkmin(lir, i + h + B[i + h]);
    chkmin(f[i][j | (1 << h)][h + 8], f[i][j][k + 8] +
    (i + k ? (T[i + k] ^ T[i + h]) : 0));
}
```
其中$lir$为上面提到的统计变量$r$，$chkmin(a,b)$为如果$b<a$则把$a$赋为$b$。

最后答案即为$min(f[n+1][0][k],-8<=k<=0)$。

完整代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
const int N = 1005, INF = 0x3f3f3f3f;
int n, T[N], B[N], f[N][1 << 8][20];
void chkmin(int &a, int b) {a = min(a, b);}
void work() {
    int i, j, k, h, lir;
    n = read(); for (i = 1; i <= n; i++)
        T[i] = read(), B[i] = read();
    memset(f, INF, sizeof(f)); f[1][0][7] = 0;
    for (i = 1; i <= n; i++) for (j = 0; j < (1 << 8); j++)
    for (k = -8; k <= 7; k++) if (f[i][j][k + 8] != INF) {
        if (j & 1) chkmin(f[i + 1][j >> 1][k + 7], f[i][j][k + 8]);
        else {
            lir = INF;
            for (h = 0; h <= 7; h++) if (!((j >> h) & 1)) {
                if (i + h > lir) break;
                chkmin(lir, i + h + B[i + h]);
                chkmin(f[i][j | (1 << h)][h + 8], f[i][j][k + 8] +
                (i + k ? (T[i + k] ^ T[i + h]) : 0));
            }
        }
    }
    int res = INF; for (k = 0; k <= 8; k++)
        res = min(res, f[n + 1][0][k]);
    printf("%d\n", res);
}
int main() {
    int T = read();
    while (T--) work();
    return 0;
}
```

---

## 作者：_LAUV_ (赞：67)

一个人既和前面的人有关系，又和后面的人有关系，真是没法转移了。。。

但是总归是有办法的

我们开一个数组 :
## f[i][st][k]

表示此时考虑到第 i 个人，从第i个人开始（包括他自己）后面七个人的吃饭状态是st（1表示吃了，0表示没吃），前一个吃饭的人与i的距离为k（因而k的范围就是 [-8,7]对吧^.^）所用时间的最小值。

所以此时的第i个人不一定吃了哦。


------------


思考下面两种情况：

一. 

此时枚举到的i，已经吃过了（st里i对应的位置就为1），那么后面的人不管按什么顺序吃，i都不会生气。所以这时可以直接更新i+1的状态


  ```cpp
f[i+1][st>>1][k-1]=min(f[i+1][st>>1][k-1],f[i][st][k])； 
```   

（向后移一个人，st要右移，前一个吃完的人离i+1的距离变成k-1）





二. 

此时枚举到的i，还没有吃饭 ，那么他最多只能忍受后面B[i]个人比他先吃到饭，所以这时候就可以枚举从i开始后面的人谁先吃饭了。

所以此时用lx来枚举后面的人（0<=lx<=7）
 ```cpp
f[i][ st|tw[lx] ] [lx]=min(f[i][st][k]+Time(i+k,i+lx),f[i][ st|tw[lx] ][lx])；
```
不过还要注意后面的人的B[i+lx]的值是不一样的，我们要开一个变量rx来记录最右能枚举到的lx，并随时更新rx（不然会有很多人生气的！），当lx>rx时，适时的break就可以了。



------------


下面是两句玩笑话：

（i同学：“你们爱咋咋，反正我已经吃完了，i+1同学，我可以直接更新你的状态了。”）

（i同学：“我还没吃饭！我后面B[i]个人后的人谁敢先吃饭，我就让你WA”）


------------


最后的答案当然就存在 f[n][1][k]里啦 （-8<=k<=0）

B[i]最多只会有7，而n也才1000，复杂度是很优秀的呢。


求资瓷～ 也可以在博客里食用哦 [——>戳这里](https://www.cnblogs.com/HLAUV/p/9912437.html)

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>

#define For(i,a,b) for(register int i=a;i<=b;++i)
#define Re register
#define inf 0x7f7f7f
#define Nm(i) i+8
#define Pn putchar('\n')

using namespace std;
const int N=1e3+10,ST=(1<<8)+10;
int f[N][ST][20];
int n,m,T[N],B[N],tw[20],nf;

inline void read(int &v){
	v=0;
	char c=getchar();
	while(c<'0'||c>'9')c=getchar();
	while(c>='0'&&c<='9')v=v*10+c-'0',c=getchar();
}
void write(int x){
	if(x>9)write(x/10);
	int xx=x%10;
	putchar(xx+'0');
}
int TM(int x,int y){
	if(x==0)return 0;
	return T[x]^T[y];
}

int main(){
	//freopen("dining.in","r",stdin);
	//freopen("dining.out","w",stdout);
	int Tx; read(Tx);
	For(i,0,10)tw[i]=1<<i;
	while(Tx--){
		read(n);
		For(i,1,n) read(T[i]),read(B[i]);
		
		memset(f,inf,sizeof(f));
		nf=f[0][0][0];
		T[0]=B[0]=0;
		
		f[1][0][Nm(-1)]=0;
		For(i,1,n) For(st,0,tw[8]-1) For(k,-8,7){
			int Fx=f[i][st][Nm(k)];
			if(Fx==nf)continue;
			//cout<<Fx<<endl;
			if(st&1){
				f[i+1][st>>1][Nm(k-1)]=min(f[i+1][st>>1][Nm(k-1)],Fx);
			}else{
				int mxR=nf;
				For(lx,0,7){
					if(st&tw[lx])continue;
					if(i+lx>mxR)break;
					mxR=min(mxR,i+lx+B[i+lx]);
					
					f[i][ st|tw[lx] ][ Nm(lx) ] =min( f[i][ st|tw[lx] ][ Nm(lx) ],Fx+TM(i+k,i+lx) );
					
				}
			}
		}
		int fn=nf;
		For(i,-8,0)fn=min(fn,f[n][1][Nm(i)]);
		write(fn); Pn;
	}
	//fclose(stdin); fclose(stdout);
	return 0;
	
}

```





---

## 作者：CYJian (赞：26)

这道题的话。。

首先先解决掉题面上的一个神奇的问题:

$(A_i\ or\ A_{i+1})-(A_i\ and\ A_{i+1})\ =\ A_i\ xor\ A_{i+1}$

这个很显然吧。

接着讲一讲方法。

方法在看完数据范围的时候就能够猜个八九不离十了吧——状压DP。毕竟忍耐度$S_i\leqslant7$。

既然这样，那么我们就可以设置状态为$f[i][j][k]$，表示考虑第$i$个人的时候，包括他(她)自己的$8$个人有没有打到饭的状态$j$，且当前最后一个打到饭的人是第$i+k$的时候所花费的最少的时间。

那么怎么转移呢？

首先我们发现，如果当前$j\&1==1$，那么这时候的$f[i][j][k]$等价于$f[i+1][j>>1][k-1]$。因为这个时候第i个人已经打完饭了，直接转移到第$i+1$个人也是可以的。

其次，如果我们考虑枚举一个$l\in \{l\ |\ j\ \&\ (1<<l)==0\}$，用$i+l$表示在$i+k$之后打饭的人，在考虑一下第$i+l$个人有没有突破前面没打到饭的人的忍耐度。如果没有，那么我们就可以用当前的$f[i][j][k]$转移一下:

$f[i][j\ |\ (1<<l)][l]=min(f[i][j\ |\ (1<<l)][l],\ f[i][j][k]+(A_{i+k}\ xor\ A_{i+l}))$

按照这样转移下去，最后的答案就是:

$min(f[n][j][k])$

这样就可以A掉这个题了。

---

## 作者：slothfulxtx (赞：15)

这是数据范围

对于30%的数据，满足1 ≤ N ≤ 20。

对于100%的数据，满足1 ≤ N ≤ 1,000，0 ≤ Ti ≤ 1,000，[color=red]0 ≤ Bi ≤ 7[/color]，1 ≤ C ≤ 5。

存在30%的数据，满足0 ≤ Bi ≤ 1。

存在65%的数据，满足0 ≤ Bi ≤ 5。

存在45%的数据，满足0 ≤ Ti ≤ 130。

所以说，这些同学们的气量才是两点，由于bi很小，所以说我们的边界情况就很明显了，所以说我们猜测这道题是不是一个状压dp，答案是肯定的。

如何确定我们的动态转移方程呢？

1.显然动态转移方程中一定含有i，即已经处理了前i-1个，正在处理i时的情况（循环更新的就不要计较了）

2.边界情况是吃没吃饭，所以既然是状态压缩，有一维变量表示i及i后7个人吃没吃饭

3.由于做菜时间与前一个拿到饭菜的人有关，还有一维变量存储的是上一个拿到饭菜的人相对于目前i的位置，根据数据范围，这一维的范围是-8~7

综上所述，我们可以猜到动态转移方程了

f[i,j,k]：前i-1个人已经吃完了，j:i及后面7个人吃饭情况，k:最后一个吃饭的人是i+k

若j=(*******1)(2进制下)说明i已经吃了，那么f[i+1,j shr 1,k-1]:=min(f[i+1,j shr 1,k-1],f[i,j,k])注意：i->i+1时，最后一个吃饭的人的相对位置也发生变化，吃饭情况为整体向后移一位

若j=(*******0)i没吃，i~i+7随便找一个没吃且合适的人，更新

```delphi

program p2157;
var
  f:array[1..1005,0..255,-8..7]of longint;
    co,an:array[1..1005]of longint;
    t2:array[0..7]of longint;
    i,j,k,l,r,ans,cc,ccc,inf,n:longint;
function cal(x,y:longint):longint;
begin
  if x=0 then exit(0)
      else exit(co[x]xor co[y]);
end;
function min(x,y:longint):longint;
begin
  if x>y then exit(y) else exit(x);
end;
begin
 
    readln(ccc);
    t2[0]:=1;
    for i:=1 to 7 do t2[i]:=t2[i-1]*2;
    for cc:=1 to ccc do begin
      readln(n);
        for i:=1 to n do readln(co[i],an[i]);
        fillchar(f,sizeof(f),$7f);
        inf:=f[1,0,-1];
        f[1,0,-1]:=0;
        for i:=1 to n do
          for j:=0 to 255 do
              for k:=-8 to 7 do
                  if f[i,j,k]<inf then begin
                    if (j and 1<>0) then
                          f[i+1,j shr 1,k-1]:=min(f[i+1,j shr 1,k-1],f[i,j,k])
                        else begin
                          r:=inf;
                            for l:=0 to 7 do
                            if j and t2[l]=0 then begin
                                if i+l>r then break;
                                  r:=min(r,i+l+an[i+l]);
                                f[i,j+t2[l],l]:=min(f[i,j+t2[l],l],f[i,j,k]+cal(i+k,i+l));
                              end;
                        end;
                    end;
        ans:=maxlongint;
        for i:=-8 to -1 do
          ans:=min(ans,f[n+1,0,i]);
        writeln(ans);
  end;
end.

```

---

## 作者：傅思维666 (赞：14)


## 题解：

[博客食用口味更佳](https://www.cnblogs.com/fusiwei/p/11808370.html)

~~2019.11.6模拟赛T1 爆蛋场~~

因为蒟蒻对状压不是很熟悉，所以一开始根本没往那边想，发现可以暴力生成全排列看看合不合法。然后持续更新答案。预计30$pts$~~但是写挂了~~

那么讲一下这个正解。（因为蒟蒻才学状压，所以很多地方都有初学者的痕迹，请大佬们海涵）

一开始迟迟无法理解这道题为啥能用$DP$，因为这道题对于每一个人来讲，他什么时候打饭既和他前面的人有关（能不能容忍他打饭），也跟后面的人有关（他能不能容忍他们打饭）。在我的印象中，这就叫后效性，是不符合$DP$的条件的。

~~所以需要用状态压缩解决~~

是的，状态压缩就是把状态化成二进制数存进数组中，然后保证当前状态下转移时是无后效性的。（多么妙啊）

那么我们考虑**状态**的设计思路：

首先，这个东西是一定要与枚举到的人有关的，所以开一维存当前枚举到哪个人。

其次，因为这个东西的转移边界是容忍后面的人吃没吃饭。那么就会有一维存状态：表示$i$和$i$后面$7$个人到底吃没吃饭。

最后，因为这个转移还和前面的人能不能忍你先吃饭有关。所以还需要开一维维护这个关系，存储上一个打饭的人到当前这个人的相对距离。

综上，设置：

$dp[i][st][k]$为：当第$1$到第$i-1$个人全部吃完饭后，$i$后$7$个人（把$i$也算上）吃没吃饭，$i$前面吃饭的人和$i$之间相对距离为$k$时的最小价值。（设$0$为没吃过，$1$为吃过）

那么答案就应该是$\min\{dp[n+1][0][k]\}\quad (k\in[0,8])$。这里的$k$的取值是因为数组不能开负数，所以把整个$k$的区间从$[-8,0]$挪到$[0,8]$了。

然后我们考虑怎么去转移。

（**注意：**这里的状态（是以十进制存储的）拆成二进制（有8位）后，最后面那位表示的不是最后的那个人，恰恰相反，是第一个人（即当前的那个$i$））

可以想到的是，对于每一个人，状态转移首先需要看这个人到底吃没吃，那么我们分两种情况讨论：

第一种：这个$i$已经吃了。这种情况下，$st\&1$应该为真。那么就可以直接去推下一个人，转移方程为：
$$
dp[i+1][j>>1][k+7]=\min(dp[i+1][j>>1][k+7],dp[i][j][k+8]);
$$
第二种：这个$i$还没有吃。这种情况下，是没有办法转移到$i+1$的，因为我们的状态设置的是前面的人都已经打完饭了（以排除后效性）。所以我们就要枚举状态来选择后面的7个人（当然包括自己）谁先打饭。

但是，这里需要细考虑一下：不是后面的7个人中的所有人都是可以打饭的。就比如后面的第$7$个人，如果后面的第一个人的忍耐度很小，一点都不能容忍自己后面的人先打，那么这个第$7$人就是选不了的。（没办法摊上暴躁同学就这样）

所以我们还需要在枚举的同时判断是否合法。

开一个变量$limit$储存目前可行的最大范围，随着枚举的继续，这个范围要么不动，要么缩小。所以如果当前枚举到的人超过了这个范围，那么他之后的所有人也都超出了这个范围，直接$break$掉就好。

这个时候的转移方程是：
$$
dp[i][j|(1<<h)][h+8]=\min(dp[i][j|(1<<h)][h+8],dp[i][j][k+8]+val[now])
$$
其中$val[now]$表示做这道菜的需要的时间。

（这里还有个性质：a|b-a&b==a^b）

所以就得出了完整的思路。

以及完整的代码：

```cpp
#include<stdio.h>
#include<string.h>
#define INF 0x3f3f3f3f
#define min(a,b) a<b?a:b
int n,ans,limit;
int t[1010],b[1010];
int dp[1010][1<<8][20];
//dp[i][st][k]表示当前为i人、其后状态为st、
//前一个吃饭的人离i距离为k时需要的最少时间。
//即上一个吃饭的人为i+k-8
char *p1,*p2,buf[100000];
#define nc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++)
int read()
{
    int x=0,f=1;
    char ch=nc();
    while(ch<48){if(ch=='-')f=-1;ch=nc();}
    while(ch>47)    x=(((x<<2)+x)<<1)+ch-48,ch=nc();
    return x*f;
}
int main()
{
    int T;
    T=read();
    while(T--)
    {
        n=read();
        for(int i=1;i<=n;i++)
            t[i]=read(),b[i]=read();
        memset(dp,INF,sizeof(dp));
        dp[1][0][7]=0;
        for(int i=1;i<=n;i++)
            for(int j=0;j<(1<<8);j++)
                for(int k=-8;k<=7;k++)
                    if(dp[i][j][k+8]!=INF)
                    {
                        if(j&1)
                            dp[i+1][j>>1][k+7]=min(dp[i+1][j>>1][k+7],dp[i][j][k+8]);
                        else
                        {
                            limit=INF;
                            for(int h=0;h<=7;h++)
                                if(!((j>>h)&1))
                                {
                                    if(i+h>limit)
                                        break;
                                    limit=min(limit,i+h+b[i+h]);
                                    dp[i][j|(1<<h)][h+8]=min(dp[i][j|(1<<h)][h+8],dp[i][j][k+8]+(i+k?(t[i+k]^t[i+h]):0));
                                }
                        }
                    }
        ans=INF;
        for(int k=0;k<=8;k++)
            ans=min(ans,dp[n+1][0][k]);
        printf("%d\n",ans);
    }
    return 0;
}
```




---

## 作者：Coros_Trusds (赞：5)

好神仙的状压/fad

同年同省的省选题里还有一道偏简单的状压 $\rm dp$，大家也可以去做做 $\texttt{P2167~Bill}$ 的挑战。

# 题目大意
 
小 $\rm F$ 的学校在城市的一个偏僻角落，所有学生都只好在学校吃饭。学校有一个食堂，虽然简陋，但食堂大厨总能做出让同学们满意的菜肴。当然，不同的人口味也不一定相同，但每个人的口味都可以用一个非负整数表示。 

由于人手不够，食堂每次只能为一个人做菜。做每道菜所需的时间是和前一道菜有关的，若前一道菜的对应的口味是 $a$，这一道为 $b$，则做这道菜所需的时间为 $(a\operatorname{or}b)-(a\operatorname{and}b)$，而做第一道菜是不需要计算时间的。队伍中的第 $i$ 个同学的口味为 $t_i$。

学生数目相对于这个学校还是比较多的，吃饭做菜往往就会花去不少时间。因此，学校食堂偶尔会不按照大家的排队顺序做菜，以缩短总的进餐时间。

虽然同学们能够理解学校食堂的这种做法，不过每个同学还是有一定容忍度的。也就是说，队伍中的第 $i$ 个同学，最多允许紧跟他身后的 $b_i$ 个人先拿到饭菜。一旦在此之后的任意同学比当前同学先拿到饭，当前同学将会十分愤怒。因此，食堂做菜还得照顾到同学们的情绪。 

现在，小 $\rm F$ 想知道在满足所有人的容忍度这一前提下，自己的学校食堂做完这些菜最少需要多少时间。

$1\le n\le 1000$，$0\le t_i\le 1000$，$0\le b_i\le 7$。

# 题目分析

首先我们可以手玩得到一个这道题中没啥用的性质：$(a\operatorname{or}b)-(a\operatorname{and}b)=a\operatorname{xor}b$。

贪心不行，顺序和每一次的人选非常难搞，也没有什么优秀的性质；$\rm dp$ 貌似也是不行的，因为当前状态会由后面状态决定从而导致后效性。看来没法了。。。

所以就可以状压。

数据范围的 $b_i\le 7$，所以我们可以把当前人选 $i$ 和后面的 $7$ 个人吃没吃饭的状态压缩成 $j$（状态的顺序是从右往左，即最右边那一位是 $i$ 的状态），转移过程中要计算贡献，再加一维 $k$ 来表示 $p-i$ 的值，$p$ 是指按打**到**饭的顺序来说第 $i$ 个人的前一个人的位置。所以，$k$ 的范围是 $[-8,7]$。为什么是 $-8$ 呢？因为状态可能会出现 $(11\dots 1)_2$ 这种情况，$(11111111)_2$ 中就会直接转移到 $i+8$ 了。所以最小值是 $i-(i+8)=-8$。

因此我们就有了思路：令 $dp[i][j][k]$ 表示前面 $i-1$ 个人已经打完饭了，$i$ 和 $i$ 后面的七个人的打饭状态是 $j$，按打**到**饭的顺序来说第 $i$ 个人的前一个人的位置是 $i+k$ 时所需的最少时间。

初始化 $dp[1][0][-1]=0$。

显然有两种情况：

+ $i$ 打饭了（也就是 $j\operatorname{and}1=1$）：

此时状态转移方程为 $dp[i+1][j>>1][k-1]=\min\{dp[i+1][j>>1][k-1],dp[i][j][k]\}$。

$k-1$ 是因为下一个人的差值就是 $p-(i+1)=p-i-1=k-1$。

+ $i$ 没打饭：

考虑枚举一个 $v$，满足 $j\operatorname{and}(1<<v)=0$，也就是枚举一个还没有打饭的人，对它转移：

$dp[i][j\operatorname{or}(1<<v)][v]=\min\{dp[i][j\operatorname{or}(1<<v)][v],dp[i][j][k]+(t_{i+k}\operatorname{xor}t_{i+v})\}$

对于 $i+v$ 来说，$i$ 就是它的前一个数，所以距离为 $v$。

C++ 中数组不能有负数，所以整体加上偏移量 $\Delta=8$。

# 代码

最近开始用 $\texttt{CP-Editor}$ 了qwq。

```cpp
// Problem: P2157 [SDOI2009]学校食堂
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P2157
// Memory Limit: 125 MB
// Time Limit: 800 ms
// Date:2022-05-21 07:58
// 
// Powered by CP Editor (https://cpeditor.org)

#include <iostream>
#include <cstdio>
#include <climits>//need "INT_MAX","INT_MIN"
#include <cstring>//need "memset"
#include <numeric>
#include <algorithm>
#define enter putchar(10)
#define debug(c,que) std::cerr << #c << " = " << c << que
#define cek(c) puts(c)
#define blow(arr,st,ed,w) for(register int i = (st);i <= (ed); ++ i) std::cout << arr[i] << w;
#define speed_up() std::ios::sync_with_stdio(false),std::cin.tie(0),std::cout.tie(0)
#define mst(a,k) memset(a,k,sizeof(a))
#define stop return(0)
const int mod = 1e9 + 7;
inline int MOD(int x) {
	if(x < 0) x += mod;
	return x % mod;
}
namespace Newstd {
	inline int read() {
		int ret = 0,f = 0;char ch = getchar();
		while (!isdigit(ch)) {
			if(ch == '-') f = 1;
			ch = getchar();
		}
		while (isdigit(ch)) {
			ret = (ret << 3) + (ret << 1) + ch - 48;
			ch = getchar();
		}
		return f ? -ret : ret;
	}
	inline void write(int x) {
		if(x < 0) {
			putchar('-');
			x = -x;
		}
		if(x > 9) write(x / 10);
		putchar(x % 10 + '0');
	}
}
using namespace Newstd;

const int INF = 0x3f3f3f3f;
const int delta = 8;
const int N = 1005,M = 8;
int val[N],polite[N],dp[N][1 << M][M + delta];
int T,n;
inline void init() {
	mst(dp,0x3f),mst(val,0);
}
inline int calc(int a,int b) {
	if (a <= 0) return 0;
	return val[a] ^ val[b];
}
inline void solve() {
	n = read();
	for (register int i = 1;i <= n; ++ i) {
		val[i] = read(),polite[i] = read();
	}
	dp[1][0][-1 + delta] = 0;
	for (register int i = 1;i <= n; ++ i) {
		for (register int j = 0;j < (1 << 8); ++ j) {
			for (register int k = -8;k <= 7; ++ k) {
				if (dp[i][j][k + delta] == INF) continue;
				if (j & 1) {
					dp[i + 1][j >> 1][k - 1 + delta] = std::min(dp[i + 1][j >> 1][k - 1 + delta],dp[i][j][k + delta]);
				} else {
					int lim = INF;
					for (register int v = 0;v <= 7; ++ v) {
						if ((j & (1 << v)) == 0) {
							if (i + v > lim) break;
							lim = std::min(lim,i + v + polite[i + v]);
							dp[i][j | (1 << v)][v + delta] = std::min(dp[i][j | (1 << v)][v + delta],dp[i][j][k + delta] + calc(i + k,i + v));
						}
					}
				}
			}
		}
	}
	int ans = INF;
	for (register int i = -8;i <= 0; ++ i) {
		ans = std::min(ans,dp[n + 1][0][i + delta]);
	}
	printf("%d\n",ans);
}
int main(void) {
	T = read();
	while (T --) {
		init();
		solve();
	}
	
	return 0;
}
```

---

## 作者：tobie (赞：4)

看到其他题解都发状压 dp，让我来点不一样的

注意到题目中 $B_i$ 极小，所以考虑对于该同学身后 $B_i$ 个人拿到饭的情况进行状态压缩。

考虑到逆着推状态的话，dp 方程式比较复杂，我们不妨使用记忆化搜索模拟取餐过程。

记 `dfs(now,last,zt)` 为“当前考虑到第 `now` 个同学，上一个打饭的编号为 `now+last`，且该同学身后（包括该同学本人）的打餐情况为 `zt` ”。

那么当我们考虑到某个同学而言，只有三种情况：

1. 这个同学已经打餐完毕，直接跳过。

2. 这个同学~~慈悲为怀~~，让他身后的同学先打餐。

3. 这个同学现在打餐

对于这三种情况分别考虑即可。

代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N=1024;
int n,t[N],b[N];
int dp[N][20][280];
int dfs(int now,int last,int zt)//注意，这里的zt中，第0位二进制位记录的是编号为now同学的打饭情况，他身后的同学由第1位二进制位开始记录
{
	if(now==n)return (zt&1)?0:t[now]^t[now+last];//最后一位同学
	if(zt&1) return dfs(now+1,last-1,zt>>1);//该同学打过饭了
	int ans=dp[now][last+8][zt];
	if(ans!=-1) return ans;
	else ans=998244353;
	int bnow=b[now];
	for(int i=1;i<=b[now];i++)
	if(!(zt&(1<<i))) bnow=min(bnow,b[now+i]+i);//计算在当前状态下，从他开始，最多可以让身后的多少个人先打餐
	for(int i=1;i<=bnow;i++)
	if(!(zt&(1<<i)))
	ans=min(ans,(last==0?0:(t[now+last]^t[now+i]))+dfs(now,i,zt^(1<<i)));//让身后的人先打餐
	ans=min(ans,(last==0?0:(t[now+last]^t[now]))+dfs(now+1,-1,zt>>1));//自己打餐
//	cout<<now<<" "<<last<<" "<<zt<<"->"<<ans<<" answer"<<endl;
	return dp[now][last+8][zt]=ans;//进行记忆化搜索
}
signed main()
{
	int T;
	scanf("%d",&T);
	while(T--)
	{
		memset(dp,-1,sizeof(dp));//记得清空dp数组！
		memset(t,0,sizeof(t));
		memset(b,0,sizeof(b));
		scanf("%d",&n);
		for(int i=1;i<=n;i++) scanf("%d%d",&t[i],&b[i]),b[i]=min(b[i],n-i);
		printf("%d\n",dfs(1,0,0));
	}
	return 0;
}
/*
1
3
10 2
6 0
1 0
*/
```

---

## 作者：YPZ_979 (赞：4)

数据中忍受度Bi<=7,可以往状态压缩上面想想;只要知道当前处理的位置以及当前位置的情况,就可以表示整个状态;因为忍受度最多不超过7个,所以在i点后面第8个人是肯定不能先打饭的,所以状态只要存储 8个人;那么设dp[i][S][k]表示i之前(1~i-1)的所有人已经打完饭,i以及i往后七个人中的状态为S,k表示目前为止最后一个打饭的人离i的相对位置,(k=p-i);

考虑转移:如果i这个人打了饭,那么状态就可以转移到dp(i+1,S>>1,k-1) ,S>>1:第i+8个人肯定没有打饭,所以状态7号位为0,0号位为原来的1号位......;k-1 : 上一个打饭的是p,p-i=k,所以到i+1时就便成了p-(i+1)=k-1;

如果i这个人没有打饭,那么就枚举[i,i+7]没打饭的人,设让第i+l位打饭(0<=l<=7) ,则状态转移到 dp(i,S|(1<<l),l);

推荐blog : <http://www.cnblogs.com/ypz999/p/7196409.html>

  ```cpp
#include<algorithm>
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cmath>
#include<map>
#include"set"
#include"queue"
#include"vector"
#include"iomanip"
#include"cstring"
#define inf 1<<29
#define ll long long
#define re register
#define il inline
#define rep(i,a,b) for(register int i=a;i<=b;++i)
#define file(a) freopen(a".in","r",stdin),freopen(a".out","w",stdout);
#define f(i,j,k) dp[i][j][k+8]
using namespace std;
int dp[1002][1<<8][17];
int t[1002],B[1002],n;
int w[10];
inline int gi() {
  re int res=0,f=1;re char ch=getchar();
  while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
  if(ch=='-') f=-1,ch=getchar();
  while(ch>='0'&&ch<='9') res=res*10+ch-'0',ch=getchar();
  return res*f;
}
il int cal(int i,int j) {
  if(!i) return 0;
  return t[i]^t[j];
}
int main(){
  file("Y");
  w[0]=1;
  rep(i,1,8) w[i]=w[i-1]<<1;
  re int T=gi();
  while(T--) {
    n=gi();
    rep(i,1,n) t[i]=gi(),B[i]=gi();
    rep(i,0,n+1)
      for(re int j=0;j<w[8];++j)
        rep(k,-8,7)
          f(i,j,k)=inf;
    f(1,0,-1)=0;
    for(re int i=1;i<=n;++i)
      for(re int S=0;S<w[8];++S)
    for(re int k=-8;k<=7;++k)
      if(f(i,S,k)<inf) {
        if(S&1) f(i+1,S>>1,k-1) = min(f(i+1,S>>1,k-1),f(i,S,k));
        else {
          re int r=inf;
          for(re int l=0;l<=7;++l)
        if((S&w[l])==0){
          if(i+l>r) break;
          r=min(r,i+l+B[i+l]);
          f(i,S|w[l],l) = min(f(i,S|w[l],l),f(i,S,k)+cal(i+k,i+l));
        }
        }
      }
    re int ans=inf;
    for(re int k=-8;k<=0;++k)
      ans=min(ans,f(n+1,0,k));
    cout<<ans<<endl;
  }
  return 0;
}
```
 

---

## 作者：Code_星云 (赞：3)

思考到该题要用 DP 。

但是对于每个学生，他对答案的贡献与他后面连续几个学生有关（不是有那个容忍度嘛），那这就不满足 DP 的无后效性了（当前求解的子问题不受后续阶段的影响）。但由于 $B_i$ 非常小，所以考虑到用状压维护 $i$ 后面几个学生的买饭状态。

对于每个学生 $i$，影响其答案的还有上一个人 $j$，故我们还要加 上个人 这个状态。但又由于 $B_i$ 很小，而 $n$ 可能很大，若维护 $j$ 的编号，便会超空间，所以我们维护 $k$ 表示上个人与现在这个学生的距离差。$j$ 可能在 $i$ 前面，但是最多中间隔 $7$ 个人（$B_i$ 的最大限度），而 $j$ 也可能在 $i$ 后面，最多是 $i$ 后面的第七个（间隔六个），所以 $k$ 的范围 $-8\le k \le 7$。

综上，我们设计 DP 状态 ：

$dp[i][j][k]$ 表示编号在 $[1,i-1]$ 内的学生都买完了饭，$i$ 和其后面 $7$ 个人买饭的状态为 $j$ ，上个买饭的人与 $i$ 的距离（上个人的编号减去 $i$ 的编号）为 $k$ 时的最少时间。

其次，考虑转移。其实大部分的状压 DP 用刷表法更好，那我们也逝逝吧。

1. $i$ 已经买完饭了  
  此时有 $dp[i+1][j>>1][k-1]=\min(dp[i+1][j>>1][k-1],dp[i][j][k])$。这两个状态时等价的。首先要说明，$i$ 买没买饭在 $j$ 的二进制表示下是在第一位的（是从右往左数!）。所以将 $j$ 右移一位，$i$ 的状态就会被消掉。$k$ 就很好理解了，若 $i$ 的上一个人的编号比其小，则 $k<0$ ，$i+1$ 后, $k$ 明显要更小（绝对值更大）。另则同理。
  
2. $i$ 还没买饭。
  由于我们设计的状态要求，$[1,i-1]$ 都要买完了饭，所以此时不可以转移到 $i+1$ 。 那我们只好枚举先让 $i$ 及其后面 $7$ 个人中谁先买饭。这里要注意的是，我们要考虑到后面的人都能容忍的编号最大买饭者 $mx$。所以我们在枚举的过程中，对于每个人（编号为 $x$），每次求一下 $\min(mx,x+B_x)$ 。转移式 ：$dp[i][j|(1<<m)][m]=\min(dp[i][j|(1<<m)][m],dp[i][j][k]+cost(i+k,i+m))$ 。

然后有一个不那么有用的结论：
$(a\ or\ b) - (a\ and\ b)=(a\ xor\ b)$  
证明：将 $a$、$b$ 抽象为两个集合，$(a\ or\ b)$ 即为其并集，$(a\ and\ b)$则是交集，相减就是一个有一个没有的，化为二进制就是 $(a\ xor\ b)$

最后要注意的是，由于我们用的是刷表法，答案应该是在 $n+1$ 这一维里的。另外，$k$ 可能是负数，所以表示要集体加 $10$(当然大于等于 $8$ 的数都可以)。  

复杂度约为（最内层枚举谁先买饭极小，可视为常数） $O(2^{8}nΔk)$，$Δk=15$

代码：
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
typedef long long ll;
const ll inf=1e18;
ll T,n,t[1005],b[1005],dp[1005][1<<8][30],ans;
ll cost(ll x,ll y){return (!x)?0:(t[x]^t[y]);}
int main(){
	scanf("%lld",&T);
	while(T--){
		scanf("%lld",&n); ans=inf;
		for(int i=1;i<=n;i++) scanf("%lld%lld",&t[i],&b[i]);
		memset(dp,0x3f,sizeof dp); dp[1][0][-1+10]=0;
		ll maxn=(1<<8)-1;
		for(int i=1;i<=n;i++)
		  for(int j=0;j<=maxn;j++)
			for(int k=-8;k<=7;k++){
			  if(dp[i][j][k+10]==0x3f3f3f3f) continue; 
			  if(j&1) dp[i+1][j>>1][k-1+10]=min(dp[i+1][j>>1][k-1+10],dp[i][j][k+10]);
			  else{
			  	ll mx=inf;
				for(int m=0;m<=7;m++){
				  if((1<<m)&j) continue; //已经买过饭了 
				  if(i+m>mx) break; //剪枝，这里都忍受不了了，后面还可以吗 
				  mx=min(mx,m+i+b[m+i]);
				  dp[i][j|(1<<m)][m+10]=min(dp[i][j|(1<<m)][m+10],dp[i][j][k+10]+cost(i+k,i+m));
				}	
			  }
            }
		for(int k=-8;k<=0;k++) ans=min(ans,dp[n+1][0][k+10]);
		printf("%lld\n",ans);
	}
	return 0;
}
```


---

## 作者：muller (赞：3)

直接状压即可

维护一个有没有那道饭的集合

所以我们可以用-8~7

来算接下来的后继转移状态

于是我们就可以直接算出答案

用正确的转移方式加一下即可

代码：

```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f
#define N 1005
using namespace std;
int t[N],b[N],f[N][N][20];
void work(){
	int n,res=INF;scanf("%d",&n);
	for (int i=1;i<=n;i++)scanf("%d%d",&t[i],&b[i]);
	memset(f,INF,sizeof(f));f[1][0][7]=0;
	for (int i=1;i<=n;i++)
		for (int j=0;j<(1<<8);j++)
			for (int k=-8;k<=7;k++)
				if (f[i][j][k+8]!=INF){
					if (j&1)f[i+1][j>>1][k+7]=min(f[i+1][j>>1][k+7],f[i][j][k+8]);
					else{
						int li=INF;
						for (int h=0;h<=7;h++)
							if (!((j>>h)&1)){
								if (i+h>li)break;
								li=min(li,i+h+b[i+h]);
								f[i][j|(1<<h)][h+8]=min(f[i][j|(1<<h)][h+8],f[i][j][k+8]+(i+k ? (t[i+k]^t[i+h]) : 0));
							}
					}
				}
	for (int i=0;i<9;i++)res=min(res,f[n+1][0][i]);
	printf("%d\n",res);
}
int main(){
	int T;scanf("%d",&T);
	while (T--)work();
	return 0;
}

```


---

## 作者：JoaoFelix (赞：2)

这题刚开始不会做...

想了半天的2^15的状压，结果发现无法优化...

后来看了几篇题解发现特别妙，参考了几篇其他的题解！

首先我们正常的思路会想的是我们选到第i个，然后前7个和后7个的状态，发现好像不太可做。

我们引申一下思路：

其他题解的办法是我们不是考虑选到第i个，改变一下dp的状态，我们考虑如果前i-1个
全部都选完了，接着转移我们只能选后7个才是有效的状态，其他肯定都不能选，这样可以让我们的转移优化，时空俱佳

我们记录状态是第i个的后0-8个的状态，同时要记录一个last，可以发现实际上是没有15个状态的，只有last要记录15个，为什么这样呢？

是因为我们两次相邻的选择之间不会相差太多。

这题的启发是：

1：首先我们可以尽可能地优化状态，比如把选到第几个个转化为选了几个

2：这样的好处是我们当且仅当第i个选了以后再向i+1转移，其他都是i和i直接的转移，比较方便，可以减少我们写题的细节！

代码：
```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int N=1e3+5,Inf=1e9;
int n,a[N],b[N],dp[N][1<<8][20];
int main(){
	int T;scanf("%d",&T);
	while(T--){
		scanf("%d",&n);
		for(int i=1;i<=n;i++)scanf("%d%d",&a[i],&b[i]);
		for(int i=0;i<N;i++)for(int j=0;j<(1<<8);j++)for(int k=0;k<20;k++)dp[i][j][k]=Inf;
		dp[1][0][7]=0;
		for(int i=1;i<=n;i++)for(int j=0;j<(1<<8);j++)for(int k=-8;k<=7;k++)if(dp[i][j][k+8]!=Inf){
			if(j&1)dp[i+1][j>>1][k+7]=min(dp[i+1][j>>1][k+7],dp[i][j][k+8]);
			else{
				int lim=Inf;
				for(int l=0;l<8;l++)if(!(j&(1<<l))){
					if(i+l>lim)break;
					lim=min(lim,i+l+b[i+l]);
					dp[i][j|(1<<l)][l+8]=min(dp[i][j|(1<<l)][l+8],dp[i][j][k+8]+(i+k?(a[i+k]^a[i+l]):0));
				}
			}
		}
		int ans=Inf;
		for(int i=0;i<=8;i++)ans=min(ans,dp[n+1][0][i]);
		printf("%d\n",ans);
	}
	return 0;
}

```


---

## 作者：OIer_ACMer (赞：1)

~~大哥，能简单一点吗？~~

------------
## 警钟敲烂：
这道题在初始化 $dp$ 数组时千万不要傻不拉几地直接 memset 大法，因为那样会让你 TLE 好几个点，将 ```sizeof(dp)``` 改为 ```(sizeof dp[0]) * (n + 2)``` 就可以过了。

------------
## 题意（主要是我自己都看了半天）：
$n$ 个人按顺序排队，每个人有一个服务时间 $t$，忍耐度 $b$，允许排在他后面的 $b$ 个人进行插队~~真没素质~~。

第一个人的实际时间为 $0$，其他人的时间为 $t$ 异或前一个被服务的人的 $t$，问总服务时间的最小值。

------------
## 大致思路：
这道题不难看出是一道经典的状压 DP 题，由于状压 DP 的特征是一般运用在集合问题里，这道题由于问的是最小时间，就要**一种方案**，每一个方案就是一个集合，因此也不难想到状压 DP 上去。

我们定义 $dp[i][j][k]$ 是第 $i$ 个人，状态为 $j$（就是**状压 DP 的二进制序列转换为十进制的结果**），前一个服务的人为 $k$ 号人的最小值。这时，那些想要拿满分的同志们肯定会隐隐不安：啊？$n$ **可是小于等于 $1000$ 的呀**，这么开不直接 MLE 一片？！不慌，因为 $b_i$ 最大只有 $7$，所以 $j$ 只需要表示 $i$ 及后面 $7$ 个人的状态即可。但别高兴的太早，我们要注意一个点：前一个服务的人可能是 $i-8$ 到 $i+7$（前面第 $8$ 个人让前面 $1$ 至 $7$ 个人先服务）。

这一次，我们的下一步不再是直接推状态转移方程，而是要先预处理第一个人耗时为 $0$ 的饭~~不然一片 WA 你自己单独欣赏去吧~~。好，那我们进入下一步推转移方程了，吗？不不不，我们还要思考一个很重要的问题：**这种状态能否出现**？由于我们的限制条件是**一个人只能允许他身后的 $b_i$ 个人拿到饭**。所以在遍历**人进行服务的时候，我们要注意维护可以服务的范围。**

然而，我们很容易就会发现，对于一个状态，**不需要判断是否合理（有的人没被服务但是忍耐度之外的人被服务）**，因为我们在选择人进行服务的时候，一定会考虑到这一点。所以，只要 $dp$ 值不是 $inf$，就合理。 

同时，我们在做遍历可行位置这步预处理的时候，我们有可以发现一个剪枝：到了第 $i$ 个人的时候，假设有一个状态已经服务了 $i$ 时，可以不管了。因为当前继续的所有操作在 $i+1$ 时都会再次进行（说白了就是有人已经照顾到你了）。

最后，我们从第一个位置一直枚举到最后一个可行位置（之前已经被照顾到的位置我们已经在“遍历可行位置”这一步时已经处理完了），至于状态转移方程，笔者在这里不多赘述（说实话这也十分好推）。

------------
## 代码如下：

```c++
#include <bits/stdc++.h>
using namespace std;
inline int read()
{
    register int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
        {
            f = -1;
        }
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
int T;
int n;
int t[1009], b[1009];
int dp[1009][330][22];
int maxb;
inline int id(int i, int idx)
{
    return i + maxb - idx;
}
int main()
{
    T = read();
    while (T--)
    {
        n = read();
        memset(dp, 0x3f, (sizeof dp[0]) * (n + 2));
        maxb = 0;
        for (int i = 1; i <= n; i++)
        {
            t[i] = read();
            b[i] = read();
            maxb = max(maxb, b[i]);
        }
        maxb++;
        maxb = min(maxb, n);
        int maxsta = (1 << maxb) - 1;
        int last = maxb - b[1];
        for (int i = maxb; i >= last; i--)
        {
            if (id(1, i) > n)
            {
                break;
            }
            dp[1][1 << i - 1][i] = 0;
            last = max(last, i - b[id(1, i)]);
        }
        for (int i = 1; i <= n; i++)
        {
            int cmp = (1 << maxb - b[i] - 1) - 1;
            for (int sta = 0; sta <= maxsta; sta++)
            {
                bool f = 0;
                for (int j = 2 * maxb; j >= 1; j--)
                {
                    if (dp[i][sta][j] < 0x3f3f3f3f)
                    {
                        f = 1;
                    }
                }
                if (!f)
                {
                    continue;
                }
                if (sta & (1 << maxb - 1))
                {
                    continue;
                }
                last = maxb - b[i];
                for (int j = maxb; j >= last; j--)
                {
                    if (id(i, j) > n)
                    {
                        break;
                    }
                    if (!(sta & (1 << j - 1)))
                    {
                        for (int k = 2 * maxb + 1; k >= 1; k--)
                        {
                            if (k > maxb || (sta & (1 << k - 1)))
                            {
                                dp[i][sta | (1 << j - 1)][j] = min(dp[i][sta | (1 << j - 1)][j], dp[i][sta][k] + (t[id(i, k)] ^ t[id(i, j)]));
                            }
                        }
                        last = max(last, j - b[id(i, j)]);
                    }
                }
            }
            for (int sta = 0; sta <= maxsta; sta++)
            {
                if (sta & (1 << maxb - 1))
                {
                    for (int j = 2 * maxb + 1; j >= 1; j--)
                    {
                        if (dp[i][sta][j] < 0x3f3f3f3f)
                        {
                            dp[i + 1][(sta << 1) & maxsta][j + 1] = min(dp[i + 1][(sta << 1) & maxsta][j + 1], dp[i][sta][j]);
                        }
                    }
                }
            }
        }
        int ans = 0x3f3f3f3f;
        for (int j = 2 * maxb + 1; j >= 1; j--)
        {
            ans = min(ans, dp[n][1 << maxb - 1][j]);
        }
        cout << ans << endl;
    }
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/122266872)

---

## 作者：精神小火 (赞：1)

我的这个方法比较奇怪，我是用队列来实现转移的。

首先分析一下题目性质。如果$x$是打完饭的人当中**排队最靠后的**，那么1到x-8这些人肯定都打完饭了。定义状态$f_{i,j,k}$表示标号最大的打到饭的是$i$（有点拗口），最后一个打饭的是$i-k$，$k$的范围是0到7，$i-1$到$i-7$的状态是$j$，需要的最少的时间。

这种状态定义没有后效性（想想为什么），只是不好确定转移的顺序。核心操作来了，其实说白了就是bfs，我们可以用队列存状态，每次取队首向外一层一层的扩展。这种方法还附带剪枝的功能，跑的飞快。

代码实现比较繁琐，注意要把不合法的状态及时排除掉。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> pii;
#define forg(i,x) for(int i=first[x];i;i=nxt[i])
#define uu unsigned
#define fi first
#define se second
#define od(x) ((x)&1)
#define ev(x) (od(x)^1)
#define mi2(x) (1<<(x))
#define gw(x,j) ((x)>>(j)&1)
//取出二进制数的某一位
#define fre(x) freopen(#x".in","r",stdin),freopen(#x".out","w",stdout)

const int inf=0x3f3f3f3f;
int n,t[1003],b[1003],dp[1003][8][1<<7],lim;
int nn;
struct dul{
	int a,b,c;
}q[2000003];
inline bool vad1(int i,int zi,int k){
	//if(b[i-k]<k)return 0;
	for(int ii=k+1;ii<=7;++ii)if(!gw(zi,ii-1)&&b[i-ii]<ii-k)return 0;
	return 1;
}
inline bool vad2(int i,int zi,int k){
	if(i+k>n)return 0;
	for(int ii=1;ii<=7;++ii)if(!gw(zi,ii-1)&&b[i-ii]<k+ii)return 0;
	for(int ii=1;ii<k;++ii)if(b[i+ii]<k-ii)return 0;
	return 1;
}
inline void pr2(int zi){for(int k=1;k<=7;++k)printf("%d",gw(zi,k-1));}

int main(){
	lim=(1<<7)-1;
    int cases;scanf("%d",&cases);while(cases--){
    	scanf("%d",&n);for(int i=1;i<=n;++i)scanf("%d%d",t+i,b+i);
    	memset(dp,0x3f,sizeof(dp));
    	int qh=1,qt=0;
    	q[++qt]=(dul){0,0,lim},dp[0][0][lim]=0;
    	
    	
    	while(qh<=qt){
    		int i=q[qh].a,j=q[qh].b,zi=q[qh].c;++qh;
    		for(int k=1;k<=7;++k)if(!gw(zi,k-1)&&vad1(i,zi,k)){
    			int &f=dp[i][k][zi|mi2(k-1)];
    			if(f==inf)q[++qt]=(dul){i,k,zi|mi2(k-1)};
    			f=min(f,i==0?0:dp[i][j][zi]+(t[i-j]^t[i-k]));
    		}
    		for(int k=1;k<=7;++k)if(vad2(i,zi,k)){
    			int zz=(zi<<k)|mi2(k-1);zz&=lim;
    			int &f=dp[i+k][0][zz];
    			if(f==inf)q[++qt]=(dul){i+k,0,zz};
    			f=min(f,i==0?0:dp[i][j][zi]+(t[i-j]^t[i+k]));
    		}
    	}
    	int ans=inf;
    	for(int k=0;k<=7;++k)ans=min(ans,dp[n][k][lim]);
    	printf("%d\n",ans);
    }
    return 0;
}


```

---

## 作者：king_more (赞：0)

看到数据 n <= 1000 很快就想到是状态压缩（虽然我想了很久）

先是三个量，题目要求的，首先第一个是和 i 有关，所以第一维为 i 表示 前 i - 1个人已经盛完了饭，然后一个人的最大忍耐度为 7，我们发现 7 这个量很少，所以第二维可以直接设成 j 表示 i 以及后面七个人的盛饭情况，1 为盛过，0 为没有盛过，再看第三个条件，与上一个盛饭的人有关，所以第三维设成 k，表示上一个盛饭的人和第 i 个人的距离，可以轻松推断出来，k 的 范围为-8 到 7，因为数组不支持负数下标，所以在每次用到 k 的时候，都使第三维加上 8，保证第三维为正数。

设f[ i ][ j ][ k ]表示第 i - 1 个人已经盛完了饭，i 以及后面 7 个人的盛饭情况为 j，上一个盛饭的人和 i 的距离为 k。

首先如果当前f[ i ][ j ][ k ] == inf 就没有更新的必要了

有两种情况

第一种是 j & 1 == 1 表示第 i 个人已经盛完饭了，这时候可以直接更新 f[i + 1][j >> 1][k - 1 + 8]

第二种是 j & 1 == 0 表示第 i 个人没盛完饭，这个时候可以枚举 j 个状态中，为 0 的，就可以把这位更新为 1，更新

这时候还要更新一个lir表示当前最后忍耐度，每次更新最小值


最后的答案是 f[n + 1][ 0 ][ k ] (-8 < k <= 0) 的最小值

上代码
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const int M = 1000;
const int Inf = 0x7ffff;
int t[M + 5],b[M + 5];
int f[M + 5][(1 << 8) + 5][16];
int main(){
	int case_test;
	scanf("%d",&case_test);
	while(case_test --){
		int n;
		memset(t,0,sizeof(t));
		memset(b,0,sizeof(b));
		memset(f,137 / 3,sizeof(f));
		scanf("%d",&n);
		f[1][0][7] = 0;
		for(int i = 1;i <= n;i ++){
			scanf("%d%d",&t[i],&b[i]);
		}
		for(int i = 1;i <= n;i ++){
			for(int j = 0;j < (1 << 8);j ++){
				for(int k = -8;k <= 7;k ++){
					if(f[i][j][k + 8] >= 5000000) continue;
					if(j & 1){
						f[i + 1][j >> 1][k + 7] = min(f[i + 1][j >> 1][k + 7],f[i][j][k + 8]);
					}
					else{
						int lir = Inf;
						for(int h = 0;h <= 7;h ++){
							if(! ((j >> h) & 1)){
								if(i + h > lir) break;
								lir = min(lir,i + h + b[i + h]);
								f[i][j | (1 << h)][h + 8] = min(f[i][j | (1 << h)][h + 8],f[i][j][k + 8] + (i + k ? (t[i + k] ^ t[i + h]) : 0));
							}
						}
					}
				}
			}
		}
		int minn = Inf;
		for(int i = -8;i <= 0;i ++){
			minn = min(minn,f[n + 1][0][i + 8]);
		}
		printf("%d\n",minn);
	}
	return 0;
}
```


---

## 作者：GoldenPotato137 (赞：0)

[戳我获得更好的阅读效果qwq](https://www.goldenpotato.cn/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/luogu-p2157sdoi2009%E5%AD%A6%E6%A0%A1%E9%A3%9F%E5%A0%82/)

---
# Solution
这是一道状压妙题。

.

首先，因为后面的东西能提到前面来做，导致了严重的后效性。为了消除这个后效性，考虑用状压来处理这个问题。

我们可以发现最多的提前量很小，只有7，考虑这样设：

设$f[i][j][k]$表示$[1,i-1]$已经完成了，从$i$开始往后7个的完成状态为$j$，上一个完成的相对$i-1$的位置为k。

转移比较正常：我们枚举一下下一个选哪一个，如果$[i,x]$会被新完成，就进到下$x$位。

我们这里的枚举要非常小心：这里枚举下一个能不能选有一个重要的限制：一路过来，一定要检查当前要选的这个能否提到没有选过的前面。

.

就酱，我们及就可以~~在理论上~~ AC这道题啦(*´ﾟ∀ﾟ｀)ﾉ 

~~当然，我们很有可能因为众多的细节调个半天~~

---
# Code
**本题细节较多，具体细节请看代码**
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
long long read()
{
	long long x=0,f=1; char c=getchar();
	while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
	while(isdigit(c)){x=x*10+c-'0';c=getchar();}
	return x*f;
}
const int N=1000+10;
const int M=(1<<8)+50;
const int K=20;
int f[N][M][K],a[N],b[N];
int n,m;
inline int real(int x,int k)
{
	return x+k-8;
}
inline int w(int x,int y)
{
	if(x==0) return 0;//要专门特判第一个转移
	return a[x]^a[y];
}
int main()
{
	//freopen("2157.in","r",stdin);
	//freopen("2157.out","w",stdout);
	//freopen("err.out","w",stderr);
	
	int T=read();
	for(;T>0;T--)
	{
		memset(f,0x3f,sizeof f);
		
		n=read();
		for(int i=1;i<=n;i++)
			a[i]=read(),b[i]=read();
		
		m=1<<8;
		b[0]=0x3f3f3f3f;
		f[1][0][8]=0;
		for(int i=1;i<=n;i++)
			for(int j=0;j<m;j++)
				for(int k=0;k<=16;k++)
					if(real(i-1,k)>=0)
					{
						//cerr<<i-1<<" "<<j<<" "<<k-8<<" :"<<f[i][j][k]<<endl;
						int t=b[i];
						for(int o=1;o<=1+t and i-1+o<=n;o++)
						{
							if((j>>(o-1))%2==1) continue;//这个已经选过了
							t=min(t,o-1+b[i-1+o]);//限制能取到的最大范围
							int tmp=j+(1<<(o-1)),py=0;
							while(tmp%2==1) tmp/=2,py++;//计算进位
							/*if(f[i+py][tmp][8+o-py]>f[i][j][k]+w(real(i-1,k),i-1+o))
								cerr<<i+py-1<<" "<<tmp<<" "<<o-py<<" "<<f[i][j][k]+w(real(i-1,k),i-1+o)<<endl;*/
							f[i+py][tmp][8+o-py]=min(f[i+py][tmp][8+o-py],f[i][j][k]+w(real(i-1,k),i-1+o));
						}
						//cerr<<endl;
					}
					
		int ans=0x3f3f3f3f;
		for(int i=0;i<=16;i++)
			ans=min(ans,f[n+1][0][i]);
		printf("%d\n",ans);
	}
	return 0;
}

```


---

## 作者：chenjunhao (赞：0)

国庆noip集训做到了生成树计数那道毒瘤题才知道状压还可以这么毒瘤qwq，停课最后冲刺第一天做到了这题，由于本人比较蒟蒻（qwq），看了各种题解终于搞懂

首先看到b[i]<=7 很明显会想到状压，可是这个状压的dp方程我也是第一次见啊qwq。这玩意肯定于i有关，然后每次更新的结果又与上次选的值有关，可这最后一维真的好难想啊qwq。

dp[i][j][k]，i表示1-i-1个人已经搞好了，j表示从i开始7个人的选与不选的状态，k表示上一次选的人的相对位置（因为直接如果存位置会炸），然后这里k可能会取负值，所以可以宏定义一个到dp数组的映射

如果j&1为真，说明当前第i个人选了，就可以直接转移到dp[i+1][j>>1][k-1](k-1是因为相对位置变了都懂的）

如果j&1不为真，那就枚举下一个选的位置，转移到dp[i][j|(1<<l)][l]+cal(i+k,i+l)（还有一个就是a|b-a&b居然等于a^b!!!惊了）
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<queue>
#define f(i,j,k) dp[i][j][k+8]
using namespace std;
#define N 1005
int dp[N][1<<8][20];
#define inf 0x3fffffff
int n;
int tim[N];
int b[N];
int bit[20];
int cal(int i,int j)
{
	if(!i) return 0;
	return (tim[i]|tim[j])-(tim[i]&tim[j]);
}
int main()
{
	int t;
	scanf("%d",&t);
	bit[0]=1; 
	for(int i=1;i<=10;i++) bit[i]=bit[i-1]<<1;
	while(t--)
	{
		scanf("%d",&n);
		for(int i=1;i<=n;i++)
		{
			scanf("%d%d",&tim[i],&b[i]);
		}
		for(int i=1;i<=n+1;i++)
		{
			for(int j=0;j<bit[8];j++)
			{
				for(int k=-8;k<=7;k++)
				{
					f(i,j,k)=inf;
				}
			}
		}
		f(1,0,-1)=0;
		for(int i=1;i<=n;i++)
		{
			for(int j=0;j<bit[8];j++)
			{
				for(int k=-8;k<=7;k++)
				{
					if(f(i,j,k)<inf){
						if(j&1)
						{
							f(i+1,j>>1,k-1)=min(f(i+1,j>>1,k-1),f(i,j,k));
						}
						else
						{
							int r=inf;
							for(int l=0;l<=7;l++)
							{
								if((j&bit[l])==0)
								{
									if(i+l>r) break;
									r=min(r,i+l+b[i+l]);
									f(i,j^bit[l],l)=min(f(i,j^bit[l],l),f(i,j,k)+cal(i+k,i+l));
								}
							}
						}
					}
				}
			}
		}
		int ans=inf;
		for(int k=-8;k<=-1;k++)
		{
			ans=min(ans,f(n+1,0,k));
		}
		printf("%d\n",ans);
	}
    return 0;
}

```

---

## 作者：wzj423 (赞：0)

注意几个事情：

1.状压的时候要同时考虑多个元素的限制

2.边界情况，比如说考虑限制时的各个加1减1

3.偏移过的值和没有偏移过的相对转化

4.其实题目就是做一个 xor

    f[i][S][k+13] 表示当前队列最前的人是i,
    以i作为第0人开始一直到第B[i]个人的集合为S,
    上一个打饭的人是以第i个人计算向后k个人
    因为k有小于0的情况因而加上了一个13的偏移量

    f[i][S][k+13] -> 选取不是当前队首的人l打饭 -> f[i][S|bin[l]][l+13]
    f[i][S][k+13] -> 选取是当前队首的人打饭  ->   f[i+t][S'][13-t]
    S'可以通过如下方法处理到：
            S|=1 while(S&1) S>>=1,++t//一直到当前队首的人没有打饭为止

```cpp
#include <bits/stdc++.h>

using namespace std;
//defs==============================
int bin[2000];
int _T,N,T[1010],B[1010];
int f[1010][300][30];
/*
    f[i][S][k+13] 表示当前队列最前的人是i,以i作为第0人开始一直到第B[i]个人的集合为S,上一个打饭的人是以第i个人计算向后k个
    为了-1的情况因而加上了一个13的偏移量

    f[i][S][k+13] -> 选取不是当前队首的人l打饭 -> f[i][S|bin[l]][l+13]
    f[i][S][k+13] -> 选取是当前队首的人打饭  ->   f[i+t][S'][13-t]
            S|=1 while(S&1) S>>=1,++t
*/
void pb(int x) {
    bitset<5> B(x);
    cout<<B;
}
void update(int &x,int y) {
    if(y<x) x=y;
}
void display(int i,int j,int k) {
    printf("f[%d][",i);pb(j);printf("][%d]=%d\n",k-13,f[i][j][k]);
}
bool OK(int pos,int S,int ins) {
    int up=min(B[pos],N-pos);
    for(int i=0;i<ins;++i) {
        if(bin[i]&S) continue;//打过饭的人不用考虑限制
up=min(B[pos+i],N-pos-i);
//printf("lim%d=%d\n",i,up);        
        if(up+i<ins) return false;

    }
    return true;
}
void init();
void do_dp() {
    //cout<<OK(2,2,3)<<endl;
    memset(f,0x3f,sizeof f);
    f[1][0][12]=0;
    for(int i=1;i<=N;++i) {
        int up=bin[min(B[i]+1,N-i+1)];
        for(int j=0;j<up;++j) {
            if(j&1) continue;
            for(int k=1;k<=B[i]+13 && i+k-13<=N;++k) {//上一次打饭的人不是队头(k已经加上了13的偏移量)
                if(f[i][j][k]>1e9) continue;  
                if(k==13) continue;//跳过队头(队头还没有打过饭)
                if(k>=13 && !(bin[k-13]&j)) continue;
               // display(i,j,k);
                for(int l=1;l<=B[i];++l) {//选不是队头的人转移(l没有加13偏移)
                    if(bin[l]&j) continue;
                    if(!OK(i,j,l)) continue;
                    int cost=(i+k-13!=0)? (T[i+k-13]^T[i+l]):0;
                    update(f[i][j|bin[l]][l+13],f[i][j][k]+ cost );
                   //printf("\tto:");display(i,j|bin[l],l+13);
                }
                //选是队头的人转移
                int cost=(i+k-13!=0)? (T[i+k-13]^T[i]):0;
                int S=j|1,ni=i,nk=13;
                while(S&1) S>>=1,++ni,--nk;
                update(f[ni][S][nk],f[i][j][k]+cost);
                    //printf("\tto:");display(ni,S,nk);                
            }             
        }
    }
    int ans=1e9+10;
    for(int i=0;i<28;++i) {
        ans=min(f[N+1][0][i],ans);
    }
    printf("%d\n",ans);
}
//main===============================
int main() {
    //freopen("gen.in","r",stdin);
    //freopen("my.out","w",stdout);
    bin[0]=1;
    for(int i=1;i<2000;++i) bin[i]=bin[i-1]*2;
    scanf("%d",&_T);
    while(_T--) {
        init();
        do_dp();
    }
    return 0;
}

void init() {
    scanf("%d",&N);
    for(int i=1;i<=N;++i) scanf("%d%d",T+i,B+i);
}
```

---


# [SDOI2008] 山贼集团

## 题目描述

某山贼集团在绿荫村拥有强大的势力。整个绿荫村由 $n$ 个连通的小村落组成，并且保证对于每两个小村落有且仅有一条简单路径相连。将小村落从 $1$ 至 $n$ 编号，山贼集团的总部设在编号为 $1$ 的小村落中。

山贼集团除了老大坐镇总部以外，其他的 $p$ 个部门希望在村落的其他地方（洛谷注：其实也包括总部）建立分部。$p$ 个分部可以在同一个小村落中建设，也可以分别建设在不同的小村落中，在不同的村落建设不同的分部需要花费不同的费用。

每个分部到总部的路径称为这个部门的管辖范围，于是这 $p$ 个分部的管辖范围可能重叠，或者完全相同。当多个分部管辖同一个村落时，他们之间可能发生矛盾，从而损失一部分利益，也可能相互合作，从而获取一部分利益。

请注意，如果相同的分部同时管辖多个村落，那么对于每个村落，都会计算一次收益损失/获取。

现在请你编写一个程序，确定 $p$ 个分部的位置，使得山贼集团能够获得最大的收益。

## 说明/提示

#### 样例输入输出 1 解释

在 $2$ 号节点建立 $1$ 号分部，花费为 $1$，则分部集合 $\{1\}$ 可以管辖 $1, 2$ 两个节点，根据第一条信息，该集合每管辖一个节点会产生 $3$ 的收益，因此总共产生了 $2 \times 3 = 6$ 的收益，减去建立分部的花费，最大的收益为 $6 - 1 = 5$。可以证明不存在更优的方案。

#### 数据规模与约定

对于 $40\%$ 的数据，保证 $1 \leq p \leq 6$。

对于 $100\%$ 的数据，保证：

- $1 \leq p \leq 12$，$1 \leq n \leq 100$。
- $1 \leq s,t \leq n$，$1 \leq a_{i, j} \leq 10^8$。
- $1 \leq t \leq 2^p$，$1 \leq |v| \leq 10^8$，$1 \leq c \leq p$，$1 \leq x_i \leq p$ 且 $x_i$ 互不相同。
- 答案的绝对值不超过 $10^8$。

## 样例 #1

### 输入

```
2 1
1 2
2 
1
1
3 1 1```

### 输出

```
5```

# 题解

## 作者：独秀平川 (赞：13)

其实不用多叉树转二叉树，只需要跑一遍正常的树上背包就行了。树上背包的模板，详见P1273有线电视网。

我们先预处理出val[ ]数组，val[i]代表一个节点同时被且仅被i的二进制数中是1的位的分部占领得到的收益，如i=11，二进制为1011，表示被1,2,4号分部占领的收益。

dp[i][j]为第i号村庄的子树（包括i村），内部有j状态的分部（状态的意义同val）的最大价值，初始状态为j状态的分部都建立在i村的代价。

dp[i][j]=所有以i的儿子为根的子树，包含分部状态一共为j的最大值+i号村庄对答案的贡献（即val[j]，子树中所有村庄都占领了i村）。

```cpp
#include <iostream>
#include <algorithm>
#include <string.h>
#include <stdio.h>
#include <math.h>
using namespace std;
typedef long long LL;
const int MAX=110;
struct edge
{
    int to,nxt;
}e[MAX*2];
int head[MAX],tot;
int n,m;
int val[4100];//4100是状态数
void addedge(int fr,int to)
{
    e[++tot].to=to;
    e[tot].nxt=head[fr];
    head[fr]=tot;
}
void addtwo(int fr,int to){addedge(fr,to);addedge(to,fr);}
int dp[MAX][4100];
void initdp()
{
    int cost[MAX][13];
    for(int i=1;i<=n;i++)
    {
        for(int j=0;j<m;j++)
        {
            scanf("%d",&cost[i][j]);
        }
        dp[i][0]=0;
        for(int j=1;j<(1<<m);j++)
        {
            int lowbit=j&(-j);
            int lowid=(log(lowbit)+0.001)/log(2);
            dp[i][j]=dp[i][j^lowbit]-cost[i][lowid];//初始化dp
        }
    }
}
void calval(int x)
{
    for(int i=1;i<=x;i++)
    {
        int v,cnt,s=0;
        scanf("%d%d",&v,&cnt);
        for(int j=1;j<=cnt;j++)//输入互相影响的村庄
        {
            int mem;
            scanf("%d",&mem);
            s|=(1<<(mem-1));//状压存储
        }
        //所有包含s的集合的val都被影响
        int maxm=(1<<m)-1;val[s]+=v;
        int tmp=s^maxm;
        for(int j=tmp;j;j=(j-1)&tmp)//枚举子集的好方法
        {
            val[(s|j)]+=v;
        }
    }
}
void dfs(int now,int fa)
{
    for(int i=head[now];i!=-1;i=e[i].nxt)//枚举儿子
    {
        int son=e[i].to;
        if(son!=fa)
        {
            dfs(son,now);
            for(int j=(1<<m)-1;j;j--)
            {
                for(int k=j;k;k=(k-1)&j)
                {
                    dp[now][j]=max(dp[now][j],dp[now][j^k]+dp[son][k]);
                    //dp[now][j]：不选此子树，dp[now][j^k]+dp[son][k]：选此子树
                }
            }
        }
    }
    for(int i=(1<<m)-1;i;i--)
    {
        dp[now][i]+=val[i];//加now的贡献
    }
}
void init()
{
    memset(head,-1,sizeof(head));tot=-1;
    memset(val,0,sizeof(val));
}
int main()
{
    cin>>n>>m;
    init();
    for(int i=1;i<n;i++)
    {
        int fr,to;
        scanf("%d%d",&fr,&to);
        addtwo(fr,to);
    }
    initdp();
    int t;scanf("%d",&t);
    calval(t);
    dfs(1,0);
    cout<<dp[1][(1<<m)-1]<<endl;
    return 0;
}

```

---

## 作者：xtx1092515503 (赞：7)

这里介绍一种又快又短的可爱代码。

首先，我们预处理一个数组 $g_i$，表示 $i$ 集合中的分部如果同时可以管某个点，这个点带来的贡献。这个可以通过一个**高维前缀和**在 $O(p2^p)$ 时间内简单求出。

然后，我们开始DP。设 $f[x,i]$ 表示节点 $x$ 如果被 $i$ 中集合管，此时的最大收益。初始值就是 $i$ 集合中的分部开在 $x$ 的费用。这个可以通过简单地 $O(2^p)$ 地一遍DP即可预处理出来。

然后开始树上背包。明显这里应该使用 $O(3^p)$ 的子集枚举拼凑出原数组；为了节省时空消耗，采取倒序DP的方式，就不用另开辅助数组了。

最后统计额外消耗。枚举 $i$，令 $f[x,i]$ 增加 $g_i$ 即可。此部分 $O(2^p)$ 解决。

总复杂度 $O(p2^p+n2^p+n3^p+n2^p)=O(n3^p)$。

代码（883B）：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int n,m,q,lim;
ll f[110][1<<12],g[1<<12];
vector<int>v[110];
void dfs(int x,int fa){
	for(int i=0;i<lim;i++)f[x][i]=f[x][i^(i&-i)]+f[x][i&-i];
	for(auto y:v[x]){
		if(y==fa)continue;
		dfs(y,x);
		for(int i=lim-1;i;i--)for(int j=i;j;j=(j-1)&i)f[x][i]=max(f[x][i],f[x][i^j]+f[y][j]);
	}
	for(int i=0;i<lim;i++)f[x][i]+=g[i];
}
int main(){
	scanf("%d%d",&n,&m),lim=1<<m;
	for(int i=1,x,y;i<n;i++)scanf("%d%d",&x,&y),v[x].push_back(y),v[y].push_back(x);
	for(int i=1;i<=n;i++)for(int j=0,x;j<m;j++)scanf("%d",&x),f[i][1<<j]=-x;
	scanf("%d",&q);
	for(int i=1,x,y,z,w;i<=q;i++){
		scanf("%d%d",&x,&y),w=0;
		while(y--)scanf("%d",&z),w|=(1<<(z-1));
		g[w]+=x;
	}
	for(int i=0;i<m;i++)for(int j=0;j<lim;j++)if(j&(1<<i))g[j]+=g[j^(1<<i)];
	dfs(1,0);
	printf("%lld\n",f[1][lim-1]);
	return 0;
}
```

---

## 作者：S_S_H (赞：5)

### UPDATE1:

我是智障吗，还学人家换底...cmath有log2(n)直接以2为底...



------------


## 恶心的树形背包+状压。。。

和 独秀平川 大佬的思路基本差不多，但这里给出详细说明。

分析一下，这个题其实可以分两个子问题：

1.如何处理管辖范围相同。

#### 这里还需要注意一点，冲突是每一个村落都会产生的总利益或损失，即每次树形合并时都要算一下。

2.如何安排分部，使总价值最大

第一个问题：由于数据范围,(1<=p<=12),可以预处理出一个状压val数组，

val[ S ]表示如果S集合中的所有元素（对同一小村落同时收取保护费）会产生的总

利益或损失，这只需要在读入数据时处理一下即可。

第二个问题：树形DP

考虑如果i节点已有子树状态S1，新加入以son为根子树状态为S2

那么dp[ i ][ S1|S2 ] = max ( dp[ i ][ S1 ] + dp[ son ][ S2 ] ) + val[ S1|S2 ]

而dp[ i ][ S1 ]自然就可以从之前的状态中推出来......树形DP完成！！！

代码实现部分：

处理DP数组部分：不得不说暴力处理我真的弱爆了......

#### ~~自己的暴力TLE代码吸氧过就不上传了~~

独秀平川 大佬换底公式优秀！！！

```cpp
for(int i=1;i<=n;i++){
        for(int j=0;j<m;j++)
            scanf("%d",&cost[j]);
        dp[i][0]=0;
        for(int j=1;j<(1<<m);j++){
            int lowbit=j&(-j);
            int lowid=(log(lowbit)+0.001)/log(2);
            dp[i][j]=dp[i][j^lowbit]-cost[lowid];
        }
    }
```


什么意思呢？cost[ i ][ j ]表示在第i个村落建立第j个分部所需要的损失

一维数组也是可以的，因为与第i没有关系，数据大时可以压维......

lowid表示lowbit表示的分部编号。

这里说明一下：计算机log(x)默认以自然对数e为底

利用[换底公式](https://baike.baidu.com/item/%E6%8D%A2%E5%BA%95%E5%85%AC%E5%BC%8F)我们知道lowid = 以2为底lowbit对数（不懂lowbit点这里[lowbit](https://blog.csdn.net/qq853674765/article/details/70050306))

那么枚举状态，取每一个状态的lowbit然后转移即可

说一下为什么要用lowbit(不会的同学可以跳过)：

对于一个状态7 = 111，它的代价 = -cost[ i ][ 0 ] -cost[ i ][ 1 ] -cost[ i ][ 2 ]

所以其实怎么枚举都是一样的（可以暴力），但如果取lowbit的话，就能保证转移

的状态一定取过，而且代码简洁。

譬如11111 可以由11110和11101...转移，但lowbit快（反正最后结果一样）

处理val数组部分：

```cpp
while(t--){
        int v,cnt,s=0;
        scanf("%d%d",&v,&cnt);
        for(int j=1;j<=cnt;j++){
            int flag;
            scanf("%d",&flag);
            s|=1<<(flag-1);
        }
        int maxm=(1<<m)-1,tmp=s^maxm;val[s]+=v;
        for(int j=tmp;j;j=(j-1)&tmp)//枚举子集
            val[s|j]+=v;
    }
```
最后得到的s是产生影响的集合，那么所有以它为子集的集合都会加上这个贡献

处理方法就是枚举s对于(1<<m)-1的补集，和s或在一起就好了

代码：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
const int maxn=(1<<12);
struct edge{
    int to,next;
}e[220];
int head[110],etot,n,m,t,val[maxn],dp[110][maxn],cost[20];
void add(int u,int v){
    e[++etot].to=v;
    e[etot].next=head[u];
    head[u]=etot;
}
void dfs(int now,int fa){
    for(int i=head[now];i;i=e[i].next){
        int son=e[i].to;
        if(son!=fa){
            dfs(son,now);
            for(int j=(1<<m)-1;j;j--)
                for(int k=j;k;k=(k-1)&j)
                    dp[now][j]=max(dp[now][j],dp[now][j^k]+dp[son][k]);//选或不选
        }
    }
    for(int i=(1<<m)-1;i;i--)
        dp[now][i]+=val[i];
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n-1;i++){
        int u,v;
        scanf("%d%d",&u,&v);
        add(u,v);add(v,u);
    }
    for(int i=1;i<=n;i++){
        for(int j=0;j<m;j++)
            scanf("%d",&cost[j]);
        dp[i][0]=0;
        for(int j=1;j<(1<<m);j++){
            int lowbit=j&(-j);
            int lowid=(log(lowbit)+0.001)/log(2);
            dp[i][j]=dp[i][j^lowbit]-cost[lowid];
        }
    }
	scanf("%d",&t);
    while(t--){
        int v,cnt,s=0;
        scanf("%d%d",&v,&cnt);
        for(int j=1;j<=cnt;j++){
            int flag;
            scanf("%d",&flag);
            s|=1<<(flag-1);
        }
        int maxm=(1<<m)-1,tmp=s^maxm;val[s]+=v;
        for(int j=tmp;j;j=(j-1)&tmp)
            val[s|j]+=v;
    }
    dfs(1,0);//额0纯粹瞎选父节点
    printf("%d",dp[1][(1<<m)-1]);
    return 0;
}
```

## 祝大家CSP NOI XXXOI RP++! ! !

---

## 作者：_AyachiNene (赞：2)

高维前缀和优化树上背包。
# 思路：
一看数据范围就能发现肯定是要状压的。不妨设状态 $f_{u,s}$ 表示以 $i$ 为根的子树中，选出的分部集合 $s$ 时，最大的收益。转移比较好想，容易发现就是一个树上背包，考虑合并两个点的过程，设两个点的状态为 $f_{u,s1}$ 和 $f_{u,s2}$，现在要把 $v$ 合并到 $u$ 上，首先有一个显然的条件，$s1\cap s2=\emptyset$，因为一个点管辖的点是从根到它路径上的点，如果一个点不在另一个点的子树内，是无法对这个点产生贡献的，所以合并时新增加的贡献就是 $sum_{s1\cup s2}$，因为这个集合一定会经过这个点，$sum_s$ 为 $s$ 的所有子集的权值和，一个集合的权值就是这个集合一起管辖某个点时的贡献，用高维前缀和即可。那么转移方程显然：
$$
f_{u,s1\cup s2=\max(f_{u,s1}+f_{u,s2})+sum_{s1\cup s2}}
$$
直接转移就有 $40pts$，要用一些小技巧优化。根据经验，这种树上背包一般都可以通过一些均摊来降低复杂度，由于两个集合交起来为空集，考虑直接枚举补集，复杂度就是 $O(n3^p)$。其他题解都没有讲复杂度是怎么来的，个人感觉没有这么显然，这里证明一下。先考虑枚举的一的个数，假设枚了 $i$ 个 $1$，那么这几个 $1$ 的所有情况就为 $C_p^i$，剩下还有 $p-i$ 个一，位置已经确定就有 $2^{p-i}$。那么总的复杂度为：
$$
\sum\limits_{i=0}^p C_p^i2^{p-i}
$$
加上一个系数：
$$
\sum\limits_{i=0}^p C_p^i 1^i  2^{p-i}
$$
二项式定理，最后复杂度就为 $O(3^p)$，转移 $n$ 次，$O(n3^p)$。

# Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
namespace IO
{
	char buff[1<<21],*p1=buff,*p2=buff;
	char getch(){return p1==p2&&(p2=((p1=buff)+fread(buff,1,1<<21,stdin)),p1==p2)?EOF:*p1++;}
	template<typename T>void read(T &x){char ch=getch();int fl=1;x=0;while(ch>'9'||ch<'0'){if(ch=='-')fl=-1;ch=getch();}while(ch<='9'&&ch>='0'){x=x*10+ch-48;ch=getch();}x*=fl;}
	template<typename T>void read_s(T &x){char ch=getch();while(ch<'a'||ch>'z')ch=getch();while(ch>='a'&&ch<='z'){x+=ch;ch=getch();}}
	template<typename T,typename ...Args>void read(T &x,Args& ...args){read(x);read(args...);}
	char obuf[1<<21],*p3=obuf;
	void putch(char ch) {if(p3-obuf<(1<<21))*p3++=ch;else fwrite(obuf,p3-obuf,1,stdout),p3=obuf,*p3++=ch;}
	char ch[100];
	template<typename T>void write(T x) {if(!x)return putch('0');if(x<0)putch('-'),x*=-1;int top=0;while(x)ch[++top]=x%10+48,x/=10;while(top)putch(ch[top]),top--;}
	template<typename T,typename ...Args>void write(T x,Args ...args) {write(x);write(args...);}
	void flush(){fwrite(obuf,p3-obuf,1,stdout);}
}
using namespace IO;
struct node
{
	int nxt,to;
}e[114514];
int head[114514],cnt_edge;
void add_edge(int u,int v)
{
	e[++cnt_edge].to=v;
	e[cnt_edge].nxt=head[u];
	head[u]=cnt_edge;
}
int n,p,t;
int sum[1<<15];
int a[114][114];
int f[114][1<<15];
int g[1<<15];
void dfs(int u,int fa)
{
	f[u][0]=0;
	for(int i=0;i<(1<<p);i++) 
		for(int j=0;j<p;j++) 
			if(i&(1<<j)) f[u][i]+=-a[u][j+1];
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].to;
		if(v==fa) continue;
		dfs(v,u);
		for(int s=0;s<(1<<p);s++) g[s]=f[u][s];
		for(int s=0;s<(1<<p);s++) //u
			for(int ss=(s^((1<<p)-1));;ss=(ss-1)&(s^((1<<p)-1)))//v
			{
				g[s^ss]=max(g[s^ss],f[u][s]+f[v][ss]);
				if(!ss) break;
			}
		for(int s=0;s<(1<<p);s++) f[u][s]=g[s];
	}
	for(int i=0;i<(1<<p);i++) f[u][i]+=sum[i];
}
int main()
{
	read(n,p);
	for(int i=1;i<n;i++)
	{
		int u,v;
		read(u,v);
		add_edge(u,v);add_edge(v,u);
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=p;j++) read(a[i][j]);
	read(t);
	for(int i=1;i<=t;i++)
	{
		int w,c;
		read(w,c);
		int sub=0;
		for(int j=1;j<=c;j++)
		{
			int x;
			read(x);
			sub|=(1<<(x-1));
		}
		sum[sub]+=w;
	}
	for(int i=0;i<p;i++)
		for(int j=0;j<(1<<p);j++)
			if(j&(1<<i)) sum[j]+=sum[j^(1<<i)];
	dfs(1,0);
	write(f[1][(1<<p)-1]);
	flush();
}
```

---

## 作者：Fzrcy (赞：1)

看到 $p\le 12$，考虑状态压缩，设 $f_{x,v}$ 表示在以 $x$ 为根的子树中，驻扎的分部子集为 $v$ 的最大收益，$v_S$ 表示若一个村落被分部子集为 $S$ 同时管辖时带来的贡献，$vv_{x,S}$ 表示驻扎在 $x$ 的分部子集为 $S$ 的费用。

有：
$$
f_{x,S}=\max_{W,T\in S,W\cup T=S,W\cap T=\empty}(-vv_{x,T}+\max_{s_1\dots s_k\in W}(\sum_{i=1}^{k}f_{v_i,s_i}))
$$
其中 $k$ 为 $x$ 的儿子节点数，$v_i$ 为 $x$ 的第 $i$ 个儿子，$s_i$ 表示驻扎在以 $v_i$ 为根的子树中的分部子集，满足 $\cup_{i=1}^{k}s_i=W$，$s_i\cap s_j=\empty(i\ne j)$。

代码实现略有不同，请读者注意。

```cpp
#include <bits/stdc++.h>
using namespace std;

using ll = long long;

const int N=101, M=12, K=(1<<12)+111;

int h[N], nt[N<<1], to[N<<1], cnt;
ll v[K], f[N][K];
int n, m, t, p, all;

void debug(){
    for(int i=1; i<=n; i++){
        for(int j=0; j<=all; j++)
            printf("%d ", f[i][j]);
        printf("\n");
    }
}

void link(int u, int v){
    nt[++cnt]=h[u], h[u]=cnt, to[cnt]=v;
    nt[++cnt]=h[v], h[v]=cnt, to[cnt]=u;
}

void dp(int u, int fa){
    for(int i=h[u]; i; i=nt[i]){
        int v=to[i]; if(v==fa)continue; dp(v, u);
        for(int j=all; j; j--) for(int k=j; k; k=(k-1)&j)
            f[u][j]=max(f[u][j], f[u][j^k]+f[v][k]);
    }
    for(int i=1; i<=all; i++) f[u][i]+=v[i];
}

int main(){
    scanf("%d %d", &n, &p), all=(1<<p)-1;

    for(int i=1, x, y; i<n; i++)
        scanf("%d %d", &x, &y), link(x, y);

    for(int i=1; i<=n; i++){
        static ll C[M];
        for(int j=1; j<=p; j++)
            scanf("%lld", &C[j]);
        for(int j=1; j<=all; j++){
            int x=(j&(-j)), Bit=log2(x)+1.00001;
//            printf("%d %d\n", x, Bit);
            f[i][j]=f[i][j^x]-C[Bit];
        }
    }

//    debug();

    scanf("%d", &t);
    for(int i=1; i<=t; i++){
        static ll val, c, s;
        scanf("%lld %lld", &val, &c), s=0;
        for(int j=1, p; j<=c; j++)
            scanf("%d", &p), s|=(1<<p-1);
        ll j=s;
        while(j<=all) v[j]+=val, j=(j+1)|s;
    }

    dp(1, 0);
    printf("%lld\n", f[1][all]);

    return 0;
}
```



---

## 作者：Enzymii (赞：1)

P.S. 建议luogu引入从本机导入md文件的功能....


本文也发布在了[本蒟蒻的blog上...](http://blog.csdn.net/enzymii/article/details/78946021)

~~上面还有各种各样的吐槽...~~


数据范围$p<=12$一眼状压...

我们可以用12位二进制表示一个集合...

这样定义状态$f_{x,s}$为第$i$个节点上安排集合$s$的状态...

这样的话$s$就是每个儿子和安排在该点的集合们的并集...

但是很多个儿子差集就不好取了, 考虑多叉树转二叉树...

然而似乎传统的\*左儿子右兄弟\*是不行的... 我们考虑另一种转化方式..


比如我们有一棵这样的树:

![这里写图片描述](http://img.blog.csdn.net/20180101163127021?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRW56eW1paQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

转成一棵抉择方案等价的树是这样的:

![这里写图片描述](http://img.blog.csdn.net/20180101163731765?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRW56eW1paQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

这里我们对于有多个子树的节点, 建立**虚拟节点**(注意:虚拟节点是不能安排集合的)

如果有好多子树就继续递归下去(比如如果1有2 3 4 5四个子树, 那么就在10的右儿子挂一个12, 然后把4 5分别放在12的左右儿子.

由于有些点不能放集合, 我们定义$g_{x,s}$表示在以$x$为根的子树中不在$x$节点安排集合时的最大价值.

这样我们就可以根据二叉树写出状态转移方程:

$$
f\_{x,s}=\left\{\begin{matrix}

max\{g\_{x,k}-cost\_{s-k}\}+val\_s (k\subseteq s),\; x<=n\\

\\
g\_{x,s},\; x>n

\end{matrix}\right.\\

g\_{x,s}=max\{f\_{l,k}+f\_{r,s-k}\}(k\subseteq s)

$$
luogu好像不资瓷多行的laTex公式是么←\_←

于是就崩了???

你萌自己想办法根据laTex代码看公式吧(要不就去我blog看咯~(又是一波广告...))


根据这个状态转移方程推就行了...

不过好像是有些卡时间的...

我们可以预处理出某个集合的费用$cost$和价值$val$

然后枚举子集是有技巧的:


```cpp
for(int k=s;k;k=(k-1)&s){
  
}
```

这样会快一点... 大约能把复杂度从$4^n$降到$3^n$左右...

不过要记得特殊处理空集(因为这样枚举的$k$不会到0)

就做完了...


代码:


```cpp
#include <cstdio>
#include <cstdio>
#include <cstring>
#define ri register int
const int N=204,P=4100,I=-1061109568;
int f[N][P],g[N][P],du[N>>1];
int w[N][13],val[P],Val[P],cost[N][P];
int ch[2][N],n,nn,p,t; bool vis[N];
int a,b,s;
inline int gi(int a=0,char c=0){
    for(;c<48||c>57;c=getchar());
    for(;c>47&&c<58;c=getchar())a=a*10+c-48;return a;
}
inline int gn(int a=0,char c=0,int f=1){
    for(;(c<48||c>57)&&c!='-';c=getchar());if(c=='-')f=-1,c=getchar();
    for(;c>47&&c<58;c=getchar()) a=a*10+c-'0'; return a*f;
}
inline int max(const int &a,const int &b){return a>b?a:b;}
inline int min(const int &a,const int &b){return a<b?a:b;}
struct edge{
    int to,next;
}e[N]; int v[N>>1],tot;
inline void buildedge(const int &x,const int &y){
    e[++tot].to=y; e[tot].next=v[x]; v[x]=tot; ++du[x];
    e[++tot].to=x; e[tot].next=v[y]; v[y]=tot; ++du[y];
}
void dfs1(int x){
    int now=x; vis[x]=1;
    for(ri i=v[x];i;i=e[i].next){int y=e[i].to;
        if(!vis[y]){
            if(!ch[0][now]) ch[0][now]=y;        
            else if(du[x]==1) ch[1][now]=y;
            else ch[1][now]=++nn,now=nn,ch[0][now]=y;
            --du[y];--du[x]; dfs1(y);
        }
    }
}
int G(int x,int zt);
int F(int x,int zt){
    if(f[x][zt]>I) return f[x][zt];
    if(x>n) return G(x,zt);
    f[x][zt]=Val[zt]-cost[x][zt];
    for(ri z=zt;z;z=(z-1)&zt)
        f[x][zt]=max(f[x][zt],G(x,z)-cost[x][zt^z]+Val[zt]);
    return f[x][zt];
}
int G(int x,int zt){
    if(!ch[0][x]&&!ch[1][x]) return I;
    if(g[x][zt]>I) return g[x][zt];
    if(!ch[1][x])
        g[x][zt]=F(ch[0][x],zt);
    else if(!ch[0][x])
        g[x][zt]=F(ch[1][x],zt);
    else{
        for(ri z=zt;z;z=(z-1)&zt)
            g[x][zt]=max(g[x][zt],F(ch[0][x],z)+F(ch[1][x],zt^z));
        g[x][zt]=max(g[x][zt],F(ch[1][x],0)+F(ch[1][x],zt));
    }
    return g[x][zt];
}
int main(){
    nn=n=gi(); p=gi();
    memset(f,192,sizeof(f));
    memset(g,192,sizeof(g));
    for(ri i=1;i<n;++i){
        a=gi(),b=gi();
        buildedge(a,b);
    }
    for(ri i=1;i<=n;++i)
        for(ri j=1;j<=p;++j)
            w[i][j]=gi();
    t=gn();
    for(ri i=1;i<=t;++i){
        a=gn(),b=gi(),s=0;
        for(ri j=0;j<b;++j)
            s|=(1<<(gn()-1));
        val[s]+=a;
    } dfs1(1);
    for(ri i=0;i<1<<p;++i){
        for(ri j=i;j;j=(j-1)&i)
            Val[i]+=val[j];
        for(ri j=1;j<=n;++j)
            for(ri k=1;k<=p;++k)
                if(i&(1<<(k-1)))
                    cost[j][i]+=w[j][k];
    }
    printf("%d\n",F(1,(1<<p)-1));
}
```

---

## 作者：freoepn (赞：0)

可以先预处理出一个点的所有被管辖方案能带来的代价，然后考虑树上背包，设 $dp _ {i,j}$ 表示第 $i$ 个点的子树中有且仅有 $j$ 的二进制表示中的分部，从下往上枚举子树分部情况转移即可。


```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, k;
vector<int> v[105];
int cost[105][105];
const int kMaxN = (1 << 12);
pair<int, int> q[kMaxN];
int sum[kMaxN];
int dp[105][kMaxN];
void dfs(int x, int y) {
  for (int i = 0; i < v[x].size(); i++) {
    if (v[x][i] != y) {
      dfs(v[x][i], x);
      for (int j = (1<< m)-1;j;j--) {
        for (int k = j; k; k = (k - 1) & j) {
          dp[x][j] = max(dp[x][j], dp[v[x][i]][k] + dp[x][j ^ k]);
        }
      }
    }
  }
  for (int i = 0; i < kMaxN; i++) {
    dp[x][i] += sum[i];
  }
}
signed main() {
  cin >> n >> m;
  for (int i = 1; i < n; i++) {
    int x, y;
    cin >> x >> y;
    v[x].push_back(y);
    v[y].push_back(x);
  }
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
      cin >> cost[i][j];
    }
  }
  cin >> k;
  for (int i = 1; i <= k; i++) {
    int x, y, num = 0;
    cin >> x >> y;
    for (int j = 1; j <= y; j++) {
      int z;
      cin >> z;
      num += (1 << (z - 1));
    }
    q[i] = make_pair(x, num);
  }
  for (int i = 0; i < kMaxN; i++) {
    for (int j = 1; j <= n; j++) {
      for (int k = 1; k <= m; k++) {
        if (i & (1 << (k - 1))) dp[j][i] -= cost[j][k];
      }
    }
    for (int j = 1; j <= k; j++) {
      if ((i | q[j].second) == i) {
        sum[i] += q[j].first;
      }
    }
  }
  dfs(1, 0);
  cout << dp[1][(1 << m)-1];
}
```

---

## 作者：liugh_ (赞：0)

## [[SDOI2008] 山贼集团](https://www.luogu.com.cn/problem/P2465)

> 给定一 $n$ 个点的无向树，有 $p$ 间房子，每间房子建在每一个点上都有单独的花费（为负），可以将多间房子建在同一个点上。一间房子的影响集合包含其到根的简单路径上的所有点。有 $Q$ 条信息每条给出 $v$ 和一些房间的编号，含义为若这些房子影响集合交的大小为 $x$，则额外造成 $vx$ 的花费（可正可负）。求建造所有房子能取得的最大花费。
>
> $n\le 100$，$p\le 12$，$Q\le 2^p$。

背包问题，而此题需要解决影响集合交造成的影响，注意到 $p$ 很小，考虑将状压和背包相结合。设 $f(u,s)$ 为 $u$ 子树内，建造房子集合为 $s$，的最大花费。为方便转移，对于每一个 $s$，我们先预处理出 $s$ 中所有点共同影响到某一个点时造成的额外花费 $ext_s$。

考虑转移。对于当前的 $u$ 子树和正在合并的 $v$ 子树，原子树中贡献不变，再加上对 $u$ 的贡献 $ext_s$，容易想到有
$$
f'(u,s)=\max_{s_0\subset s}\{f(u,s_0)+f(v,s\setminus s_0)+ext_s\}
$$
**但是，实现中直接这么做是不对的。**

仔细观察，对于 $u$ 的所有子树，每次合并时都会加上一个 $ext_s$，但实际上只会造成一个 $ext_s$ 的贡献！

于是，我们选择在所有转移完成后再加上 $ext_s$，这样保证了 $ext_s$ 只会被加一遍。具体地，
```cpp
for(int e=eh[u];e;e=eg[e].pre){
    ...
    for(int s=0;s<(1<<p);s++)
        for(int sv=s;sv;sv=(sv-1)&s)
            f[u][s]=max(f[u][s],g[s^sv]+f[v][sv]);
}
for(int s=0;s<(1<<p);s++)f[u][s]+=ext[s];
```
初始化，对于 $f(u,s)$，加上 $s$ 中房子建在 $u$ 的花费即可。统计答案，显然有 $ans=f(1,2^p-1)$。时间复杂度 $O(n3^p)$。

关于时间复杂度为什么有一个 $3^p$ 而不是 $4^p$，我们枚举 $s_0\subset s$ 时每次令 $s_0\gets (s_0-1) \operatorname{and} s$，这样就能跳过所有的 $s_0\not\subset s$，于是枚举的时间复杂度就是 $O(\sum_{i=0}^p \binom{p}{i}\cdot 2^i)=O(\sum_{i=0}^p \binom{p}{i}\cdot 2^i\cdot 1^{p-i})=O(3^p)$。

```cpp
#include<iostream>
#ifdef ONLINE_JUDGE
#define getchar() (p_==q_&&(q_=(p_=b_)+fread(b_,1,s_,stdin),p_==q_)?-1:*p_++)
#define putchar(x_) ((r_-o_<s_)?(*r_++=x_):(flush(),r_=o_,*r_++=x_))
#endif
#define inline inline __attribute__((__always_inline__))
#define flush() fwrite(o_,r_-o_,1,stdout),fflush(stdout)
using namespace std;constexpr int s_=1<<20;char b_[s_],o_[s_],*p_=b_,*q_=b_,*r_=o_;template<class T>inline bool fr(T&x_){x_=0;char c_=0,f_=0;do{if(c_=='-')f_=1;if((c_=getchar())==-1)return 0;}while(c_<48||c_>57);do {x_=x_*10+c_-48;if((c_=getchar())==-1)break;}while(c_>47&&c_<58);if(f_)x_=-x_;return 1;}template<class T>inline void fw(T x_){char d_[40],l_=-1;if(x_<0)x_=-x_,putchar('-');do d_[++l_]=x_%10+48;while(x_/=10);do putchar(d_[l_]);while(~--l_);}

#define i64 long long
constexpr int maxn=100+5;

int n,p;
int a[maxn][maxn];
i64 ext[1<<12];

struct _eg{int pre,v;}eg[maxn*2];int ei=1,eh[maxn];
inline void ea(int u,int v){eg[++ei]={eh[u],v};eh[u]=ei;}

#define lb(x) ((x)&-(x))
i64 f[maxn][1<<12];
void dfs(int u,int lst){
    for(int s=0;s<(1<<p);s++)
        for(int t=s;t;t-=lb(t))
            f[u][s]-=a[u][__lg(lb(t))+1];
    for(int e=eh[u];e;e=eg[e].pre){
        int v=eg[e].v;if(v==lst)continue;
        dfs(v,u);
        static int g[1<<12];copy(f[u],f[u]+(1<<p),g);
        for(int s=0;s<(1<<p);s++)
            for(int sv=s;sv;sv=(sv-1)&s)
                f[u][s]=max(f[u][s],g[s^sv]+f[v][sv]);
                // 不能作g[s^sv]+f[v][sv]+ext[s]，同时初始化部分不应f[u][s]+=ext[s]
                // 否则每次合并时都会加上一个 $ext_s$，但实际上只会造成一个 $ext_s$ 的贡献！
                // 于是选择在所有转移完成后加上ext[s]
                /*
                    hack:
                    3 2
                    1 2
                    1 3
                    1 5 
                    3 3 
                    3 5 
                    1
                    -4 1 1 
                    ans:
                    -8
                */
    }
    for(int s=0;s<(1<<p);s++)f[u][s]+=ext[s];
}

signed main(){
    // ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    // freopen("1.in","r",stdin);
    // freopen("1.out","w",stdout);
    
    fr(n),fr(p);
    for(int i=2,u,v;i<=n;i++)fr(u),fr(v),ea(u,v),ea(v,u);
    for(int i=1;i<=n;i++)for(int j=1;j<=p;j++)fr(a[i][j]);
    int Q;fr(Q);while(Q--){
        int v,c,t=0;fr(v),fr(c);
        while(c--){int x;fr(x);t|=1<<(x-1);}
        ext[t]+=v; // 下面的循环中s>0，取不到ext[t]的情况，于是在此需要加上
        for(int lgh=((1<<p)-1)^t,s=lgh;s;s=(s-1)&lgh)ext[s|t]+=v;
    }
    dfs(1,0);
    fw(f[1][(1<<p)-1]);
    exit((flush(),0));
}
```

---

## 作者：daniEl_lElE (赞：0)

首先计算出每个点新建一个部门集合 $S$ 时需要的花费以及包含部门集合 $S$ 时带来的收益。

考虑 $dp_{i,S}$ 表示看到 $i$ 点的子树，包含 $S$ 部门集合的最大收益。转移可以 $3^p$ 合并各个子树，$3^p$ 添加部门。

总复杂度 $O(n3^p)$。

```cpp
#include <bits/stdc++.h>
#define int long long
#define lowbit(i) (i&(-i))
#define add(i,j) ((i+j>=mod)?i+j-mod:i+j)
using namespace std;
int dp[105][5005];
int f[5005],val[105][15];
vector<int> vc[5005];
int pr[5005],tmpv[5005],p,to[5005];
void dfs(int now,int fa){
	dp[now][0]=0;
	for(auto v:vc[now]){
		if(v==fa) continue;
		dfs(v,now);
		for(int j=0;j<(1<<p);j++) to[j]=-1e18;
		for(int j=0;j<(1<<p);j++){
			for(int i=j;;i=(i-1)&j){
				to[j]=max(to[j],dp[now][i]+dp[v][i^j]);
				if(!i) break;
			}
		}
		for(int j=0;j<(1<<p);j++) dp[now][j]=to[j];
	}
	for(int i=0;i<(1<<p);i++){
		tmpv[i]=0;
		for(int j=1;j<=p;j++) tmpv[i]+=((i>>(j-1))&1)*val[now][j];
	}
	for(int j=0;j<(1<<p);j++) to[j]=-1e18;
	for(int j=0;j<(1<<p);j++){
		for(int i=j;;i=(i-1)&j){
			to[j]=max(to[j],dp[now][i]-tmpv[i^j]);
			if(!i) break;
		}
	}
	for(int j=0;j<(1<<p);j++) dp[now][j]=to[j]+pr[j];
}
signed main(){
	int n; cin>>n>>p;
	for(int i=1;i<=n;i++) for(int j=0;j<(1<<p);j++) dp[i][j]=-1e18;
	for(int i=1;i<n;i++){
		int u,v; cin>>u>>v;
		vc[u].push_back(v);
		vc[v].push_back(u);
	}
	for(int i=1;i<=n;i++) for(int j=1;j<=p;j++) cin>>val[i][j];
	int t; cin>>t;
	while(t--){
		int g,v; cin>>g>>v; int sta=0;
		while(v--){
			int c; cin>>c;
			sta|=(1<<(c-1));
		}
		pr[sta]+=g;
	}
	for(int i=1;i<=p;i++) for(int j=0;j<(1<<p);j++) if((j>>(i-1))&1) pr[j]+=pr[j^(1<<(i-1))];
	dfs(1,0);
	cout<<dp[1][(1<<p)-1];
	return 0;
}
```

---


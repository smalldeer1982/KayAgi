# [SDOI2010] 粟粟的书架

## 题目描述

幸福幼儿园 B29 班的粟粟是一个聪明机灵、乖巧可爱的小朋友，她的爱好是画画和读书，尤其喜欢 Thomas H. Cormen 的文章。粟粟家中有一个 $R$ 行 $C$ 列的巨型书架，书架的每一个位置都摆有一本书，上数第 $i$ 行、左数第 $j$ 列摆放的书有 $P_{i,j}$ 页厚。

粟粟每天除了读书之外，还有一件必不可少的工作就是摘苹果，她每天必须摘取一个指定的苹果。粟粟家果树上的苹果有的高、有的低，但无论如何凭粟粟自己的个头都难以摘到。不过她发现，如果在脚下放上几本书，就可以够着苹果；她同时注意到，对于第 $i$ 天指定的那个苹果，只要她脚下放置书的总页数之和不低于 $H_i$，就一定能够摘到。

由于书架内的书过多，父母担心粟粟一天内就把所有书看完而耽误了上幼儿园，于是每天只允许粟粟在一个特定区域内拿书。这个区域是一个矩形，第 $i$ 天给定区域的左上角是上数第$x1_i$ 行的左数第 $y1_i$ 本书，右下角是上数第 $x2_i$ 行的左数第 $y2_i$ 本书。换句话说，粟粟在这一天，只能在这 $(x2_i－x1_i＋1)\times(y2_i－y1_i＋1)$ 本书中挑选若干本垫在脚下，摘取苹果。

粟粟每次取书时都能及时放回原位，并且她的书架不会再撤下书目或换上新书，摘苹果的任务会一直持续 $M$ 天。给出每本书籍的页数和每天的区域限制及采摘要求，请你告诉粟粟，她每天至少拿取多少本书，就可以摘到当天指定的苹果。


## 说明/提示

对于 $10\%$ 的数据，满足 $R, C\le10$。

对于 $20\%$ 的数据，满足 $R, C\le 40$。

对于 $50\%$ 的数据，满足 $R, C\le 200$，$M\le 2\times 10^5$。

另有 $50\%$ 的数据，满足 $R＝1$，$C\le 5\times 10^5$，$M\le 2\times 10^4$。

对于 $100\%$ 的数据，满足 $1\le P_{i,j}\le 1000$，$1\le H_i\le 2\times 10^9$。


## 样例 #1

### 输入

```
5 5 7
14 15 9 26 53
58 9 7 9 32
38 46 26 43 38
32 7 9 50 28
8 41 9 7 17
1 2 5 3 139
3 1 5 5 399
3 3 4 5 91
4 1 4 1 33
1 3 5 4 185
3 3 4 3 23
3 1 3 3 108```

### 输出

```
6
15
2
Poor QLW
9
1
3```

## 样例 #2

### 输入

```
1 10 7
14 15 9 26 53 58 9 7 9 32
1 2 1 9 170
1 2 1 9 171
1 5 1 7 115
1 1 1 10 228
1 4 1 4 45704571
1 1 1 1 1
1 7 1 8 16```

### 输出

```
6
7
3
10
Poor QLW
1
2```

# 题解

## 作者：凌幽 (赞：46)

应该算是一道二合一的题吧

观察数据范围

前50%的R,C均小于等于200,求给定矩阵中至少要取几个数加起来可以大于给定的值

可以搞一搞前缀和,二分最小值,变成一个判定性问题

value[i][j][k] 从(1,1)到(i,j)的矩阵中数值>=k的数的总和

num[i][j][k] 从(1,1)到(i,j)的矩阵中数值>=k的数的个数

后50%的R=1,C<=5\*10^5,求给定序列中至少要取几个数加起来可以大于给定的值

依旧是二分最小值,可以用主席树维护

AC代码

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
#define re register
#define no printf("Poor QLW\n")
int n,m,t; // n hang m lie t tian
int a1,b1,a2,b2,h;
int page[202][202];
int value[202][202][1002];
int num[202][202][1002];
inline int get_value(int a1,int b1,int a2,int b2,int k){
    return value[a2][b2][k]-value[a1-1][b2][k]+value[a1-1][b1-1][k]-value[a2][b1-1][k];
}
inline int get_num(int a1,int b1,int a2,int b2,int k){
    return num[a2][b2][k]-num[a1-1][b2][k]+num[a1-1][b1-1][k]-num[a2][b1-1][k];
}
inline void work1(){
    re int maxn=0;
    for(re int i=1;i<=n;++i)
        for(re int j=1;j<=m;++j){
            scanf("%d",&page[i][j]);
            if(page[i][j]>maxn) maxn=page[i][j];
        }
    for(re int k=0;k<=maxn;++k) // 前缀和,容斥原理
        for(re int i=1;i<=n;++i)
            for(re int j=1;j<=m;++j){
                value[i][j][k]=value[i-1][j][k]+value[i][j-1][k]-value[i-1][j-1][k]+(page[i][j]>=k?page[i][j]:0);
                num[i][j][k]=num[i-1][j][k]+num[i][j-1][k]-num[i-1][j-1][k]+(page[i][j]>=k?1:0);
                // value[i][j][k] 从(1,1)到(i,j)的矩阵中数值>=k的数的总和
                // num[i][j][k] 从(1,1)到(i,j)的矩阵中数值>=k的数的个数
        }
    while(t--){
        scanf("%d%d%d%d%d",&a1,&b1,&a2,&b2,&h);
        if(get_value(a1,b1,a2,b2,0)<h) {no;continue;}
        re int l=0,r=maxn+1,ans=-1;
        while(l+1<r){
            re int mid=l+r>>1;
            if(get_value(a1,b1,a2,b2,mid)>=h) l=mid,ans=mid;
            else r=mid;
        }
        if(ans==-1) no;
        else printf("%d\n",get_num(a1,b1,a2,b2,ans)-(get_value(a1,b1,a2,b2,ans)-h)/ans);
    }    
}
#define N 5500002
int L[N],R[N],size[N],sum[N],root[N],cnt;
inline void update(int A,int &B,int l,int r,int x){
    B=++cnt;
    size[B]=size[A]+1;
    sum[B]=sum[A]+x;
    re int mid=l+r>>1;
    if(l==r) return;
    if(x<=mid) update(L[A],L[B],l,mid,x),R[B]=R[A];
    else update(R[A],R[B],mid+1,r,x),L[B]=L[A];        
}
inline int query(int A,int B,int l,int r,int k){
    re int ans=0;
    while(l<r){
        re int mid=l+r>>1;
        re int lch=sum[R[B]]-sum[R[A]];
        if(lch<k) ans+=size[R[B]]-size[R[A]],k-=lch,r=mid,B=L[B],A=L[A];
        else l=mid+1,B=R[B],A=R[A];
    }
    ans+=(k+l-1)/l;
    return ans;
}
inline void work2(){
    for(re int i=1;i<=m;++i){
        re int a; scanf("%d",&a);
        update(root[i-1],root[i],1,1000,a);
    }
    while(t--){
        scanf("%d%d%d%d%d",&a1,&b1,&a2,&b2,&h);
        if(sum[root[b2]]-sum[root[b1-1]]<h) {no;continue;}
        printf("%d\n",query(root[b1-1],root[b2],1,1000,h));
    }    
}
inline int dy(){
    scanf("%d%d%d",&n,&m,&t);
    if(n==1) work2();
    else work1();
    return 0;
}
int QAQ = dy();
int main(){;}
```

---

## 作者：anterior (赞：16)

昨天交了队友主席树，他开始写这道题，然后今天问我（因为我写过这道题），但是我已经忘记这道题的写法了！ 然后我开始想，和前面的题解不同的是，我认为这道题前后两部分可以一起写，对于后一半R = 1的情况实际上就是一个裸主席树题，先判右边的sum够不够k，够就进入右子树，不够就进入左子树。 而对于前一半，我注意到了每本书的页数只有1000，那就直接开200颗主席树啊！ 然后我看了下题解，好像没有这种写法，我就一边担心一边写。 我算出来的时间复杂度是M R log10， 大概在4个亿左右，主席树常数也很大，但是最后还是过了，令人惊讶



```c
#include<bits/stdc++.h>

using namespace std;

const int maxn = 1010;
struct T
{
    int l, r;
    int siz;
    int sum;
} tree[maxn * 40 * 200];
int r, c, m, cnt;
int lx, ly, rx, ry, k;
int rt[500010];
int ls[210], rs[210];
void build(int l, int r, int &tr)
{
    tr = ++ cnt;
    if(l == r)
        return;
    int mid = (l + r) >> 1;
    build(l, mid, tree[tr].l);
    build(mid + 1, r, tree[tr].r);
}
void update(int l, int r, int last, int &now, int key)
{
    now = ++ cnt;
    tree[now] = tree[last];
    tree[now].siz ++, tree[now].sum += key;
    if(l == r)
        return;
    int mid = (l + r) >> 1;
    if(key <= mid)
        update(l, mid, tree[last].l, tree[now].l, key);
    else
        update(mid + 1, r, tree[last].r, tree[now].r, key);
}
int query(int l, int r, int key, int he)
{
    if(l == r)
    {
        if(key <= 0)
            return he;
        int temp;
        if(key % l == 0)
            temp = key / l;
        else
            temp = key / l + 1;
        he += temp;
        return he;
    }
    int sum = 0, ssiz = 0;
    for(int i = lx; i <= rx; i ++)
    {
        sum += tree[tree[rs[i]].r].sum - tree[tree[ls[i]].r].sum;
        ssiz += tree[tree[rs[i]].r].siz - tree[tree[ls[i]].r].siz;
    }
    int mid = (l + r) >> 1;
    if(sum >= key)
    {
        for(int i = lx; i <= rx; i ++)
        {
            rs[i] = tree[rs[i]].r;
            ls[i] = tree[ls[i]].r;
        }
        return query(mid + 1, r, key, he);
    }
    else
    {
        for(int i = lx; i <= rx; i ++)
        {
            rs[i] = tree[rs[i]].l;
            ls[i] = tree[ls[i]].l;
        }
        return query(l, mid, key - sum, he + ssiz);
    }
}
int main()
{
    scanf("%d %d %d", &r, &c, &m);
    build(1, 1000, rt[0]);
    int temp;
    for(int i = 1; i <= r; i ++)
    {
        for(int j = 1; j <= c; j ++)
        {
            scanf("%d", &temp);
            if(j == 1)
                update(1, 1000, rt[0], rt[(i - 1) * c + j], temp);
            else
                update(1, 1000, rt[(i - 1) * c + j - 1], rt[(i - 1) * c + j], temp);
        }
    }
    while(m --)
    {
        scanf("%d %d %d %d %d", &lx, &ly, &rx, &ry, &k);
        int sum = 0;
        for(int i = lx; i <= rx; i ++)
        {
            if(ly == 1)
                sum += tree[rt[(i - 1) * c + ry]].sum;
            else
                sum += tree[rt[(i - 1) * c + ry]].sum - tree[rt[(i - 1) * c + ly - 1]].sum;
        }
        if(sum < k)
        {
            //cout << "!!!" << " " << sum << endl;
            printf("Poor QLW\n");
        }
        else
        {
            for(int i = lx; i <= rx; i ++)
            {
                if(ly == 1)
                {
                    rs[i] = rt[(i - 1) * c + ry];
                    ls[i] = rt[0];
                }
                else
                {
                    rs[i] = rt[(i - 1) * c + ry];
                    ls[i] = rt[(i - 1) * c + ly - 1];
                }

            }
            printf("%d\n", query(1, 1000, k, 0));
        }
    }
    return 0;
}

```

---

## 作者：Cherry0525 (赞：8)

虽然是主席树的专题，但是想想好像用前缀和都可以搞过去。
对于R,C<=200的情况，S[i][j][k]表示以(i,j)为右下角的矩阵中值为k的有几个，对于每次询问，从最大的数开始尝试，知道高度大于等于。
当R==1时，每隔十个数处理一次。sum[1][i]表示前十个数中值为i的有几个，sum[2][i]表示前二十个数中值为i的有几个，一次类推。对于每次询问与第一种情况一样贪心处理，然后处理边界即可。预处理的复杂度O(1000*(C/10)),每次询问O(1000*10),总复杂度O(1000*(C/10)+10000*M)

```
// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;
int S[202][202][1005],t[202][202],a[202][1005];
int sum[50005][1002],c[500005];
int main()
{
    int n,m,Q;
    scanf("%d%d%d",&n,&m,&Q);
    if(n==1)
    {
        for(int i=1;i<=m;i++)
        {
            scanf("%d",&c[i]);
            if(i%10==0)
            {
                int len=i/10;
                for(int j=1;j<=1000;j++) sum[len][j]=sum[len-1][j];
                for(int j=i;j>10*(len-1);j--) sum[len][c[j]]++;
            }
        }
        while(Q--)
        {
            int x1,y1,x2,y2,h;
            scanf("%d%d%d%d%d",&x1,&y1,&x2,&y2,&h);
            int ans=0;
            for(int i=1000;i>0;i--)
            {
                int s=sum[y2/10][i]-sum[y1/10][i];
                for(int j=y2/10*10+1;j<=y2;j++) if(c[j]==i) s++;
                for(int j=y1/10*10+1;j<y1;j++) if(c[j]==i) s--;
                if(y1%10==0&&i==c[y1]) s++;
                if(i*s<=h)
                {
                    h-=i*s;
                    ans+=s;
                }
                else
                {
                    ans+=(h+i-1)/i;
                    h=0;
                }
                if(h==0) break;
            }
            if(h>0) printf("Poor QLW\n");
            else printf("%d\n",ans);
        }
    }
    else
    {
        for(int i=1;i<=n;i++)
            for(int j=1;j<=m;j++)
            scanf("%d",&t[i][j]);
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=m;j++)
            {
                for(int k=1;k<=1000;k++)
                {
                    if(t[i][j]==k) a[j][k]=a[j-1][k]+1;
                    else a[j][k]=a[j-1][k];
                    S[i][j][k]=S[i-1][j][k]+a[j][k];
                }
            }
        }
        while(Q--)
        {
            int x1,y1,x2,y2,h;
            scanf("%d%d%d%d%d",&x1,&y1,&x2,&y2,&h);
            int ans=0;
            for(int i=1000;i>0;i--)
            {
                int s=S[x2][y2][i]-S[x2][y1-1][i]-S[x1-1][y2][i]+S[x1-1][y1-1][i];
                if(i*s<=h)
                {
                    h-=i*s;
                    ans+=s;
                }
                else
                {
                    ans+=(h+i-1)/i;
                    h=0;
                }
                if(h==0) break;
            }
            if(h>0) printf("Poor QLW\n");
            else printf("%d\n",ans);
        }
    }
    return 0;
}


```

---

## 作者：qwaszx (赞：8)

蒟蒻用了一天的时间刚刚搞明白主席树

首先orz楼下dalao

## 主席树数组一定要开到1e7以上！！！

首先这个题要分成两部分做

对于$R,C\leq200$的部分使用二分+前缀和

具体方法是维护两个数组$f1[i][j][k]$和$f2[i][j][k]$分别表示$(1,1)$到$(i,j)$的大于等于$k$的数的和与个数

递推和查询直接按照二维前缀和做就好了

查询的时候二分一个$k$，看矩形内大于等于$k$的数的和是否大于等于$h$，求出来最大的$k$即可

注意一个细节，可能二分出来的这个$k$存在多个，那么需要减去多出来得$k$，具体方法是再查一遍大于等于$k$的数的和，减去$h$，再除以$k$就是多出来的$k$的个数了

剩下的$50\%$其实完全一样，只不过是把查询换成了主席树

想一想区间$k$小的查询方法，可以类比出这里的查询

计算出右子树的和(当然是差分之后的)，如果和大于等于$h$说明答案在右子树，反之在左子树，此时答案要加上右子树的$size$(也是差分之后的),h要减去右子树的和

最后查询到叶子节点的时候返回$h$除以当前权值的上取整

复杂度$O(n\log n)$

当然还有一种方法就是按照前$50\%$的思路做，用主席树算出大于等于$h$的数的和与个数，复杂度$O(n\log^2n)$

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
struct ZXS
{
    int lc,rc,sum,size;
}a[10000000];
int nodecnt,root[10000000],n,m,w[233][233],q,ww[600000],f1[233][233][1050],f2[233][233][1050];
int getin()
{
    int x=0;char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9')x=x*10+ch-48,ch=getchar();
    return x;
}
int wt[30];
void putout(int x)
{
    if(!x){putchar('0');return;}
    int l=0;
    while(x)wt[++l]=x%10,x/=10;
    while(l)putchar(wt[l--]+48);
}
void build(int &rot,int lt,int rt)
{
    rot=++nodecnt;
    if(lt==rt)return;
    int mid=(lt+rt)>>1;
    build(a[rot].lc,lt,mid),build(a[rot].rc,mid+1,rt);
}
int update(int rot,int lt,int rt,int w)
{
    int o=++nodecnt;
    a[o]=a[rot],a[o].size=a[rot].size+1,a[o].sum=a[rot].sum+w;
    if(lt==rt)return o;
    int mid=(lt+rt)>>1;
    if(w<=mid)a[o].lc=update(a[o].lc,lt,mid,w);
    else a[o].rc=update(a[o].rc,mid+1,rt,w);
    return o;
}
int query(int lt,int rt,int lq,int rq,int w)
{
    if(lt==rt)return (w+lt-1)/lt;
    int mid=(lt+rt)>>1,t=a[a[rq].rc].sum-a[a[lq].rc].sum;
    if(w<=t)return query(mid+1,rt,a[lq].rc,a[rq].rc,w);
    else return a[a[rq].rc].size-a[a[lq].rc].size+query(lt,mid,a[lq].lc,a[rq].lc,w-t);
}
void work1()
{
    int maxw=-1e9-7;
    for(int i=1;i<=m;i++)ww[i]=getin(),maxw=max(ww[i],maxw);
    build(root[0],1,m);
    for(int i=1;i<=m;i++)root[i]=update(root[i-1],1,maxw,ww[i]);
    for(int i=1;i<=q;i++)
    {
        int y1,y2,h;y1=getin(),y1=root[getin()-1],y2=getin(),y2=root[getin()],h=getin();
        if(a[y2].sum-a[y1].sum<h){puts("Poor QLW");continue;}
        putout(query(1,maxw,y1,y2,h)),putchar(10);
    }
}
int getsum(int x1,int y1,int x2,int y2,int k,int f)
{
    if(f==1)return f1[x2][y2][k]-f1[x2][y1-1][k]-f1[x1-1][y2][k]+f1[x1-1][y1-1][k];
    else return f2[x2][y2][k]-f2[x2][y1-1][k]-f2[x1-1][y2][k]+f2[x1-1][y1-1][k];
}
void work2()
{
    int maxw=-1e9-7;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            w[i][j]=getin(),maxw=max(maxw,w[i][j]);
    for(int k=1;k<=maxw;k++)
        for(int i=1;i<=n;i++)
            for(int j=1;j<=m;j++)
            {
                f1[i][j][k]=f1[i-1][j][k]+f1[i][j-1][k]-f1[i-1][j-1][k]+(w[i][j]>=k)*w[i][j];
                f2[i][j][k]=f2[i-1][j][k]+f2[i][j-1][k]-f2[i-1][j-1][k]+(w[i][j]>=k);
            }
    for(int i=1;i<=q;i++)
    {
        int x1=getin(),y1=getin(),x2=getin(),y2=getin(),h=getin();
        if(getsum(x1,y1,x2,y2,1,1)<h){puts("Poor QLW");continue;}
        int l=1,r=maxw,mid;
        while(l<r)
        {
            mid=(l+r+1)>>1;
            if(getsum(x1,y1,x2,y2,mid,1)>=h)l=mid;
            else r=mid-1;
        }
        putout(getsum(x1,y1,x2,y2,l,2)-(getsum(x1,y1,x2,y2,l,1)-h)/l),putchar(10);
    }		
}
int main()
{
    n=getin(),m=getin(),q=getin();
    if(n==1)work1();
    else work2();
}
```

---

## 作者：Fuyuki (赞：6)

~~~来自用了半个冬眠营狂打树套树的某蒟蒻深深的怨念~~~

相信大家对这道题的第一反应是线段树套主席树，但是注意到题目中的一个条件：任意P(I,j)小于等于1000，这给了我们另一个想法。

一个朴素的想法是将询问的矩形内所有元素塞进一个数组里快排，但是由于元素值较小，完全可以将矩形内所有元素塞进桶内桶排。当然这样会T到飞起，但是注意到桶内信息是可减的，所以可以想到做一个前缀和，s[i][j][k]表示以(1,1),(I,j)围成的矩形内k元素的出现次数。然后像普通的二维前缀和一样O(p)得出询问矩形内的桶排结果。

预处理复杂度O(nmp),询问复杂度是O(p),总复杂度O((nm+q)p),空间复杂度O(nmp)。

这个算法可以通过50%的数据,即n,m<=200。

对于另外50%的数据，依旧考虑桶排的思想，但是空间复杂度和预处理复杂度完全无法接受。本着绝对不打线段树的思想，考虑分块的做法。

进行分块前缀和，然后边角塞桶统计，这样就可以把空间压到O(sqrt(m)p)。同时，一次询问的复杂度也是O(sqrt(m)p)，加上预处理的O(sqrt(m)p)，总复杂度是O(sqrt(m)pq)。

我不知道卡常大神们怎么样，反正我这个复杂度没卡过去，但是同样基于分块的思想，可以想到一种更优秀的做法：莫队。

一次询问到另一次询问间就不断修改桶内信息即可，再奇偶分块什么卡卡常就过了，复杂度是O(sqrt(m)m+qp),因为询问只有20000次，所以复杂度完全可以接受。

正解就是将这两个50分拼起来。

```cpp
#include<cmath>
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
char _buf[100010],*_op(_buf),*_ed(_buf);
#define re register 
#define FOR(i,a,b) for(re int i=a;i<=b;i++)
#define ROF(i,a,b) for(re int i=a;i>=b;i--)
#define gc _op==_ed&&(_op=_buf,_ed=fread(_buf,1,100000,stdin)+_buf,_op==_ed)?EOF:*_op++
int read(){
	int _s=0,_f=1;
	char _ch=gc;
	while(_ch<'0'||_ch>'9')_f=(_ch=='-')?-1:1,_ch=gc;
	while(_ch>='0'&&_ch<='9')_s=_s*10+_ch-48,_ch=gc;
	return _s*_f;
}
const int N=201,M=5e5+1,INF=1000,Q=2e4+1;
int n,m,q;
namespace Mo{//莫队算法
	int a[M],S,t[INF+1],ans[Q];
	struct query{
		int l,r,sum,pos,id;
		void input(){read(),l=read(),read(),r=read(),sum=read();}
		void init(int p){pos=l/S,id=p;}
	}c[Q];
	bool cmp(query x,query y){
		return x.pos!=y.pos?x.pos<y.pos:x.r<y.r^(x.pos&1);//奇偶卡常数
	}
	void input(){
		FOR(i,1,m)a[i]=read();
		FOR(i,1,q)c[i].input();
	}
	void init(){
		S=pow(m,0.54);
		FOR(i,1,q)c[i].init(i);
		sort(c+1,c+1+q,cmp);
	}
	void work(){
		int l=1,r=0;
		FOR(i,1,q){
			while(l>c[i].l)t[a[--l]]++;
			while(r<c[i].r)t[a[++r]]++;
			while(l<c[i].l)t[a[l++]]--;
			while(r>c[i].r)t[a[r--]]--;
			int out=0,sum=c[i].sum;
			for(int j=INF;j&&sum;j--)//贪心选点
				if(sum>t[j]*j)out+=t[j],sum-=t[j]*j;
				else out+=sum/j+(sum%j!=0),sum=0;
			if(sum>0)ans[c[i].id]=-1;
			else ans[c[i].id]=out;
		}
	}
	void output(){
		FOR(i,1,q)
			if(ans[i]>0)cout<<ans[i]<<'\n';
			else puts("Poor QLW");
	}
	void Main(){
		input();
		init();
		work();
		output();
	}
}
namespace pre{
	int s[N][N][INF+1];
	int a[INF+1],x;
	void input(){
		FOR(i,1,n)FOR(j,1,m)x=read(),s[i][j][x]=1;
	}
	void init(){
		FOR(i,1,n)FOR(j,1,m)FOR(k,1,INF)//前缀和
			s[i][j][k]+=s[i-1][j][k]+s[i][j-1][k]-s[i-1][j-1][k];
	}
	void work(){
		int lx,ly,rx,ry,sum,out=0;
		while(q--){
			lx=read()-1,ly=read()-1;
			rx=read(),ry=read();
			sum=read(),out=0;
			for(int i=INF;i&&sum;i--){//同上贪心
				x=s[rx][ry][i]-s[lx][ry][i]-s[rx][ly][i]+s[lx][ly][i];
				if(sum>x*i)out+=x,sum-=x*i;
				else out+=sum/i+(sum%i!=0),sum=0;
			}
			if(sum>0)puts("Poor QLW");
			else cout<<out<<'\n';
		}
	}
	void Main(){
		input();
		init();
		work();
	}
}
int main(){
	n=read(),m=read(),q=read();
	if(n==1)Mo::Main();
	else pre::Main();
	return 0;
}
```
代码看着比较长，但是各个部分非常简单，理解了桶排贪心的过程就非常容易了。


---

## 作者：温词 (赞：6)

### 为了更好的查看体验，可以进入https://www.cnblogs.com/wenci/p/10158661.html我的博客进行查看
#### 题面见https://www.luogu.org/problemnew/show/P2468

#### 然后这道题属于合二为一题，看一眼数据范围就能发现

#### 首先我们先考虑50分，二维前缀和维护一下（反正我不记得公式，手推了半天）

#### tot[i][j][k]表示矩阵（1,1）到（i，j）中数值大等于k的总和

#### num[i][j][k]表示矩阵（1,1）到（i，j）中数值大等于k的个数

#### 那么做法也就显而易见了，二分k的值进行check

#### 最后注意一个小问题，就是有可能一个k值有多个点，而我不需要全选就能满足条件，这个可以自行理解一下

#### 后百分之五十，一开始口胡了一个一维前缀和的做法，貌似是两个log，然而我在学可持久化数据结构，不能偷懒

#### 思考了一下，开一棵权值线段树，把它变成主席树，根x代表插入了第x个数后的情况

#### 然后建树，更新都是裸的操作

#### 关于查询我的想法我写在了代码里，想不通的可以看一下
```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;
inline int read(){
    int w=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        w=(w<<3)+(w<<1)+ch-48;
        ch=getchar();
    }
    return w*f;
}
int n,m,q,a[210][210],tot[210][210][1010],num[210][210][1010],ans,cnt,root[5000010],b[5000010];
int get_sum(int x1,int y1,int x2,int y2,int k,int f)
{
    if(f==1)return tot[x2][y2][k]-tot[x2][y1-1][k]-tot[x1-1][y2][k]+tot[x1-1][y1-1][k];
    else return num[x2][y2][k]-num[x2][y1-1][k]-num[x1-1][y2][k]+num[x1-1][y1-1][k];
}
inline void work2(){//二维前缀和大力维护，口胡了一下写在上面了，就不多解释了，着重看主席树 
    int i,j,k,maxx=0;
    for(i=1;i<=n;i++){
        for(j=1;j<=m;j++){
            a[i][j]=read();maxx=max(maxx,a[i][j]);
        }
    }
    for(k=0;k<=maxx;k++){
        for(i=1;i<=n;i++){
            for(j=1;j<=m;j++){
                tot[i][j][k]=tot[i-1][j][k]+tot[i][j-1][k]-tot[i-1][j-1][k]+(a[i][j]>=k)*a[i][j];
                num[i][j][k]=num[i-1][j][k]+num[i][j-1][k]-num[i-1][j-1][k]+(a[i][j]>=k);
            }
        }
    }
    while(q--){
        int x1,y1,x2,y2,h;
        x1=read();y1=read();x2=read();y2=read();h=read();
        if(get_sum(x1,y1,x2,y2,0,1)<h) puts("Poor QLW");
        else{
            int l=0,r=maxx+1;ans=-1;
            while(l<=r){
                int mid=(l+r)>>1;
                if(get_sum(x1,y1,x2,y2,mid,1)>=h){
                    ans=mid;l=mid+1;
                }
                else r=mid-1;
            }
            printf("%d\n",get_sum(x1,y1,x2,y2,ans,2)-(get_sum(x1,y1,x2,y2,ans,1)-h)/ans);
        }
    }
}
struct Node{
    int ls,rs,sum,size;
}st[50000010];
inline int build(int l,int r){
    int pos=cnt++;
    if(l==r) return pos;
    int mid=(l+r)>>1;
    st[pos].ls=build(l,mid);
    st[pos].rs=build(mid+1,r);
    return pos;
}//常规建树 
inline int update(int tim,int l,int r,int x){//tim表示历史版本，l,r为范围，x为我当前插入的数 
    int pos=cnt++;
    st[pos]=st[tim];st[pos].size++;st[pos].sum+=x;//这个节点的size+1,sum+=x 
    if(l==r) return pos;//到叶子了，大力返回就好 
    int mid=(l+r)>>1;
    if(x<=mid) st[pos].ls=update(st[tim].ls,l,mid,x);
    else st[pos].rs=update(st[tim].rs,mid+1,r,x);
    return pos;
}
inline int query(int l,int r,int fir,int sec,int w){//具体解释见下方 
    if(l==r) return (w-1)/l+1;//可能不会整除，就这么处理一下就好了 
    int mid=(l+r)>>1;int x=st[st[sec].rs].sum-st[st[fir].rs].sum;
    if(w<=x) return query(mid+1,r,st[fir].rs,st[sec].rs,w);
    else return st[st[sec].rs].size-st[st[fir].rs].size+query(l,mid,st[fir].ls,st[sec].ls,w-x);
}
/*
这棵主席树是基于权值线段树的，权值的范围只有1k 
主席树维护了历史版本的权值线段树上的size和sum 
然后关于建树和更新都没什么新意
查询这个我一开始不能很好的理解，那么我现在稍微解释一下我的思路
首先l,r,fir,sec,w分别表示区间，版本号，还需要多少值
然后大多数题查询的时候都是向左子树查一下，比一下大小
这里查右子树是因为这是一棵权值线段树，我们希望尽量少地选点，也就意味着选的数要尽可能大
那么能选右子树（也就是值更大的点），当然选大的啊
如果右子树总和够，就往右子树走，不够的话，算上右子树，往左子树走 
*/
inline void work1()
{
    int maxw=-1e9-7;
    for(int i=1;i<=m;i++) b[i]=read(),maxw=max(b[i],maxw);
    root[0]=build(1,maxw+10);
    for(int i=1;i<=m;i++) root[i]=update(root[i-1],1,maxw,b[i]);
    for(int i=1;i<=q;i++)
    {
        int y1,y2,h;y1=read(),y1=root[read()-1],y2=read(),y2=root[read()],h=read();
        if(st[y2].sum-st[y1].sum<h){puts("Poor QLW");continue;}
        printf("%d\n",query(1,maxw,y1,y2,h));
    }
}
int main(){
    n=read();m=read();q=read();
    if(n!=1){//合二为一辣鸡题 
        work2();
    }
    else work1();
    return 0;
}
```

---

## 作者：AbioAg (赞：5)

这里是一篇整体二分乱草主席树的题解，有效防止 MLE，且只多了一只 log，理论适用于比主席树更大的数据范围。

比较明显的是本题只需找到一个位置 $k$，使得区间前 $k$ 大的数前缀和大于等于 $H_i$，关于矩阵中区间第 $k$ 大/小系列问题，考虑使用整体二分。

与板子 [P1527](https://www.luogu.com.cn/problem/P1527) 相同的手法，由大到小逐个加入矩阵中的数，要记录的是区间和与区间排名，使用二维树状数组单点加，区间查，是 trivial 的。

对于整体二分结果，区间和已达到目标的扔到左边，未达到的减去左边的影响，达到的扔到右边，同时答案把左边部分的排名贡献加上，要注意最后输出答案还需要加上自己的一个贡献。

关于判定无解，直接无脑先全加入，然后判断还没达到的就是无解即可。

另外空间需要准备两种情况的空间，导致要写双份代码，评价为芜马。

[code](https://www.luogu.com.cn/paste/sgl6r42x)

---

## 作者：Ireliaღ (赞：4)

~~模拟赛，本来奔着最多70写的，结果A了~~

## 解题思路

- 看到鬼畜的数据点分布，我们可以猜到这道题是两道题捏到一起的(

- 对于后$50\%$，是一维数据。~~考虑把$1e3$的值域看做常数~~，我们可以使用莫队，维护一个范围是$1000$的桶，每次统计答案时暴力从$1000$往回扫，复杂度$m \sqrt n + m \times \text{最大1000的“常数”}$

- 对于前$50\%$，考虑到范围是$200 \times 200$，~~继续把$1e3$的值域看做常数~~，开$1000$的桶存数，暴力扫一遍给定长方形，然后从$1000$往回扫桶，复杂度$m n^2 + m \times \text{最大1000的“常数”}$

## 代码

```cpp
// luogu-judger-enable-o2
// luogu-judger-enable-o2
#include <iostream>
#include <algorithm>
#include <cmath>
#include <cstring>

using std::sort;
using std::min;
using std::max;
typedef long long LL;

int n, m;

void Init() {
    std::cin >> n >> m;
}

namespace Solution1{
    const int MAXN = 5e5 + 5;
    const int MAXNUM = 1e3 + 5;
    const int MAXQ = 2e4 + 5;

    int cnt[MAXNUM], a[MAXN], len;
    LL ans[MAXQ];
    int q;
    LL sum;

    struct Query{
        int l, r, id;
        LL h;
    }qs[MAXQ];

    int Comp(const Query &a, const Query &b) {
        if (a.l / len != b.l / len) return a.l < b.l;
        if (a.l / len % 2 == 1) return a.r < b.r;
        else return a.r > b.r;
    }

    void Add(int x) {
        cnt[x]++;
        sum += x;
    }

    void Del(int x) {
        cnt[x]--;
        sum -= x;
    }

    void Work() {
        std::cin >> q;
        for (int i = 1; i <= m; i++) std::cin >> a[i];
        int tmp;
        for (int i = 1; i <= q; i++) {
            std::cin >> tmp >> qs[i].l >> tmp >> qs[i].r >> qs[i].h;
            qs[i].id = i;
        }
        len = sqrt(m);
        sort(qs + 1, qs + q + 1, Comp);
        int nl = 1, nr = 0;
        for (int i = 1; i <= q; i++) {
            int l = qs[i].l, r = qs[i].r, id = qs[i].id;
            // std::cerr << l << " " << r << " " << id << "\n";
            LL h = qs[i].h;
            while (nl < l) {
                Del(a[nl]);
                nl++;
            }
            while (nl > l) {
                nl--;
                Add(a[nl]);
            }
            while (nr < r) {
                nr++;
                Add(a[nr]);
            }
            while (nr > r) {
                Del(a[nr]);
                nr--;
            }
            // std::cerr << "###" << "\n";
            // std::cerr << l << " " << r << " " << "\n";
            // for (int i = 1; i <= 1000; i++) std::cerr << cnt[i] << " ";
            // std::cerr << "###" << "\n";
            if (sum < h) {
                ans[id] = -1;
                continue;
            }
            for (int j = 1000; j; j--) {
                if (cnt[j] == 0) continue;
                if (1LL * j * cnt[j] < h) {
                    h -= 1LL * j * cnt[j];
                    ans[id] += cnt[j];
                } else {
                    // std::cerr << "*";
                    LL tmp;
                    if (h % j == 0) tmp = h / j;
                    else tmp = h / j + 1;
                    // std::cerr << tmp;
                    ans[id] += tmp;
                    // std::cerr << ans[id];
                    break;
                }
            }
        }
        for (int i = 1; i <= q; i++) {
            if (ans[i] == -1) std::cout << "Poor QLW" << "\n";
            else std::cout << ans[i] << "\n";
        }
    }
}

namespace Solution2{
    const int MAXN = 205;
    const int MAXNUM = 1e3 + 5;

    int q;
    int cnt[MAXNUM];
    int a[MAXN][MAXN];

    void Work() {
        std::cin >> q;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                std::cin >> a[i][j];
            }
        }
        int xl, xr, yl, yr;
        LL h;
        for (int i = 1; i <= q; i++) {
            std::cin >> xl >> yl >> xr >> yr >> h;
            LL ans = 0, sum = 0;
            memset(cnt, 0, sizeof(cnt));
            for (int j = xl; j <= xr; j++) {
                for (int k = yl; k <= yr; k++) {
                    cnt[a[j][k]]++;
                    sum += a[j][k];
                }
            }
            if (sum < h) {
                std::cout << "Poor QLW" << "\n";
                continue;
            }
            for (int j = 1000; j; j--) {
                if (cnt[j] == 0) continue;
                if (1LL * j * cnt[j] < h) {
                    h -= 1LL * j * cnt[j];
                    ans += cnt[j];
                } else {
                    LL tmp;
                    if (h % j == 0) tmp = h / j;
                    else tmp = h / j + 1;
                    ans += tmp;
                    break;
                }
            }
            std::cout << ans << "\n";
        }
    }
}

int main() {
    Init();
    if (n == 1) Solution1::Work();
    else Solution2::Work();
    return 0;
}
```

---

## 作者：modfisher (赞：2)

随手写了个代码，发现题解区没一个长一样的，于是我写了这篇题解。

## 思路
头一次见这种恶心数据范围，居然还分两半。开始我也以为要写两份代码，但我懒，只想写一份。所以我选择一棵主席树搞定。

对于一个矩阵，我们可以把它拉直，即一行一行平铺成一段序列，这样就解决了矩阵不好处理的问题。然后在这段序列上用主席树维护权值出现次数。

但是，这样询问的区域也被拆成了若干段，怎么办呢？

发现 $R\leq 200$ 恒成立，所以询问区域至多被拆成 $200$ 段，那就一段一段统计呗。

利用权值线段树的可加减性，每一次在主席树上二分时，只需要用 $R$ 棵代表询问区域右界的主席树减去 $R$ 棵代表询问区域左界的主席树即可得到询问区域的所有元素出现次数。

对于二分查找目标，发现肯定是尽可能选大的元素，这样才能做到选出来的元素最少。对于当前递归到的某一节点，如果其右儿子大小大于等于 $h$，就继续往右儿子走；如果小于，就累加右儿子中元素个数，往左儿子走，并把 $h$ 减去右儿子大小。当当前结点为叶结点时，判断其大小是否比 $h$ 大，如果大的话就拿出尽可能少的个数来满足 $h$，否则返回 $-1$，即无解。

就这样完事啦！时间复杂度 $O(MR\log \max\{P_{i,j}\})$，过得去。~~主要是不用分两种情况做。~~

## 代码
```cpp
#include <bits/stdc++.h>
#define ll long long

using namespace std;

const int maxn = 5e5 + 5, maxv = 1005;

struct node{
	int lc, rc, sum, sum2;
}t[maxv + maxn * 40];
int tot = 0, ver[maxn];
int a[maxn], L[maxn], R[maxn], k = 0;

void up(int x){
	t[x].sum = t[t[x].lc].sum + t[t[x].rc].sum;
	t[x].sum2 = t[t[x].lc].sum2 + t[t[x].rc].sum2;
}
int build(int l, int r){
	int x = ++ tot;
	if(l == r) return x;
	int mid = l + r >> 1;
	t[x].lc = build(l, mid);
	t[x].rc = build(mid + 1, r);
	return x;
}
int clone(int x){
	t[++ tot] = t[x];
	return tot;
}
int update(int x, int l, int r, int id, int k){
	x = clone(x);
	if(l == id && r == id){
		t[x].sum += k;
		t[x].sum2 += l * k;
		return x;
	}
	int mid = l + r >> 1;
	if(id <= mid) t[x].lc = update(t[x].lc, l, mid, id, k);
	else t[x].rc = update(t[x].rc, mid + 1, r, id, k);
	up(x);
	return x;
}
int query(int l, int r, int h){
	if(l == r){
		int res = 0;
		for(int i = 1; i <= k; i ++) res += t[R[i]].sum - t[L[i]].sum;
		int nd = h ? (h - 1) / l + 1 : 0;
		if(nd > res) return -1;
		return nd;
	}
	int res = 0, res2 = 0;
	for(int i = 1; i <= k; i ++){
		res += t[t[R[i]].rc].sum - t[t[L[i]].rc].sum, res2 += t[t[R[i]].rc].sum2 - t[t[L[i]].rc].sum2;
	}
	int mid = l + r >> 1;
	if(res2 >= h){
		for(int i = 1; i <= k; i ++){
			L[i] = t[L[i]].rc;
			R[i] = t[R[i]].rc;
		}
		return query(mid + 1, r, h);
	}else{
		for(int i = 1; i <= k; i ++){
			L[i] = t[L[i]].lc;
			R[i] = t[R[i]].lc;
		}
		int ls = query(l, mid, h - res2);
		if(ls == -1) return -1;
		return ls + res;
	}
}

int main(){
	int r, c, q;
	scanf("%d %d %d", &r, &c, &q);
	int mxv = 0;
	for(int i = 1; i <= r * c; i ++){
		scanf("%d", &a[i]);
		mxv = max(mxv, a[i]);
	}
	ver[0] = build(1, mxv);
	for(int i = 1; i <= r * c; i ++){
		ver[i] = update(ver[i - 1], 1, mxv, a[i], 1);
	}
	while(q --){
		int x1, y1, x2, y2, h;
		scanf("%d %d %d %d %d", &x1, &y1, &x2, &y2, &h);
		k = x2 - x1 + 1;
		for(int i = 1; i <= k; i ++){
			L[i] = ver[(x1 + i - 2) * c + y1 - 1];
			R[i] = ver[(x1 + i - 2) * c + y2];
		}
		int res = query(1, mxv, h);
		if(res != -1) printf("%d\n", res);
		else printf("Poor QLW\n");
	}
	return 0;
}
```


---

## 作者：steven7 (赞：2)

看了这道题的其他题解，本蒟蒻发现大部分都是将其分成两道题二分加主席树做的，本蒟蒻便来分享一波自己的蒟蒻做法--**用主席树维护二维矩阵的信息**。

这道题全程用主席树，不过要分情况讨论，对于r=1的情况，直接上裸的主席树，对于r=200，c=200的情况我们用主席树来维护矩阵(0,0)到(x,y)的信息，它由(x-1,y)到(0,0)的信息加上(x,0)到(x,y)的信息得到。代码如下
```cpp
for(register int i=1;i<=r;i++)
for(register int j=1;j<=c;j++)
{
	build(1,tot,root[i-1][j],root[i][j],m[i][j],tmp[m[i][j]]);
	int tt=root[i][j];
	for(register int t=1;t<j;t++) 
	build(1,tot,tt,root[i][j],m[i][t],tmp[m[i][t]]),qu[++cnt]=tt,tt=root[i][j];
}
```
而对于查询，则像二维前缀和一样；
```cpp
inline int ask(int l,int r,int a,int b,int c,int d,int v)
{
	if(l==r) 
	{
		int t=tr[a].size+tr[b].size-tr[c].size-tr[d].size;
		while((int)(t-1)*tmp[l]>=v) t--;
		return t;
	}
	int mid=(l+r)>>1,siz=tr[tr[a].ls].size+tr[tr[b].ls].size-tr[tr[c].ls].size-tr[tr[d].ls].size;
	int k=tr[tr[a].ls].sum+tr[tr[b].ls].sum-tr[tr[c].ls].sum-tr[tr[d].ls].sum;
	if(k>=v)    return ask(l,mid,tr[a].ls,tr[b].ls,tr[c].ls,tr[d].ls,v);
	else return ask(mid+1,r,tr[a].rs,tr[b].rs,tr[c].rs,tr[d].rs,v-k)+siz;
}
```
**然而！**这样写是过不了这道题的；

对于构建主席树的过程中，我们不停的更新root[x][y],导致大量节点只是一个过程量，空间被大量浪费，所需空间在这道题的极限情况下高达600+MB;

接下来，蒟蒻将展示代码(带注释)，该问题的解决办法。
```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
using namespace std;
const int N = 3e7;

template<typename T>
inline void read(T &a)
{
	T f=1;a=0;char s=getchar();
	while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}
	while(s<='9'&&s>='0'){a=a*10+s-'0';s=getchar();}
	a*=f;
}

struct node
{
	int ls,size,rs,sum;
}tr[N];

int root[201][201],tcnt,rt[500001],tot;//因数据范围不同，分别用root[x][y],rt[x]来记录两种情况下的树根 
int m[201][201],mt[500001],tmp[500001];//m,mt同上记录数据，tmp离散化数组 
int qu; 

inline void build(int l,int r,int x,int &y,int k,int v)//k,为离散化后的值，v为离散化之前的值 
{
	if(qu)	y=qu,qu=0;//qu记录无用节点，循环利用 
	else 	y=++tcnt;
	tr[y]=tr[x];tr[y].sum+=v,tr[y].size+=1;
	if(l==r) return;
	int mid=(l+r)>>1;
	if(k<=mid) build(l,mid,tr[x].ls,tr[y].ls,k,v);
	else     build(mid+1,r,tr[x].rs,tr[y].rs,k,v);
}

inline int ask(int l,int r,int a,int b,int c,int d,int v)
{
	if(l==r) 
	{
		int t=tr[a].size+tr[b].size-tr[c].size-tr[d].size;//一个值可能有多个，我们并不是全部都需要 
		while((int)(t-1)*tmp[l]>=v) t--;
		return t;
	}
	int mid=(l+r)>>1,ss=tr[tr[a].ls].size+tr[tr[b].ls].size-tr[tr[c].ls].size-tr[tr[d].ls].size;
	int k=tr[tr[a].ls].sum+tr[tr[b].ls].sum-tr[tr[c].ls].sum-tr[tr[d].ls].sum;
	if(k>=v)    return ask(l,mid,tr[a].ls,tr[b].ls,tr[c].ls,tr[d].ls,v);
	else return ask(mid+1,r,tr[a].rs,tr[b].rs,tr[c].rs,tr[d].rs,v-k)+ss;
}

int r,c,q;
int a,b,x,y;
int v;

int main()
{
	read(r),read(c),read(q);
	for(register int i=1;i<=r;i++)for(register int j=1;j<=c;j++)
	if(r==1) read(mt[j]),tmp[++tot]=mt[j];
	else     read(m[i][j]),tmp[++tot]=m[i][j];
	sort(tmp+1,tmp+1+tot,greater<int>());//从大到小排序 
	tot=unique(tmp+1,tmp+1+tot)-tmp-1;
	if(r==1)//分类讨论 
	{
		for(register int i=1;i<=c;i++) mt[i]=lower_bound(tmp+1,tmp+1+tot,mt[i],greater<int>())-tmp;
		for(register int i=1;i<=c;i++) build(1,tot,rt[i-1],rt[i],mt[i],tmp[mt[i]]);
		for(register int i=1;i<=q;i++)
		{
			read(y),read(x),read(b),read(a),read(v);
			if(v>(tr[rt[a]].sum-tr[rt[x-1]].sum)) printf("Poor QLW\n");
			else printf("%d\n",ask(1,tot,rt[a],0,rt[x-1],0,v));
		}
	}
	else
	{
		for(register int i=1;i<=r;i++)for(register int j=1;j<=c;j++) m[i][j]=lower_bound(tmp+1,tmp+1+tot,m[i][j],greater<int>())-tmp;
		for(register int i=1;i<=r;i++)for(register int j=1;j<=c;j++)
		{ 
			if(j>=i)//root[i][j]无论从root[i-1][j]更新出来，还是从root[i][j-1]都是一样的，但是一个需重建i个节点，另一个需要重建j个节点。我们根据情况来判断那种情况更省空间 
			{
				build(1,tot,root[i][j-1],root[i][j],m[i][j],tmp[m[i][j]]);
				int tt=root[i][j]; 
				for(register int t=1;t<i;t++) 
				build(1,tot,tt,root[i][j],m[t][j],tmp[m[t][j]]),qu=tt,tt=root[i][j];
			}
			else
			{
				build(1,tot,root[i-1][j],root[i][j],m[i][j],tmp[m[i][j]]);
				int tt=root[i][j];
				for(register int t=1;t<j;t++) 
				build(1,tot,tt,root[i][j],m[i][t],tmp[m[i][t]]),qu=tt,tt=root[i][j];
			}
		}
		for(register int i=1;i<=q;i++)
		{
			read(x),read(y),read(a),read(b),read(v);
			if(v>(tr[root[a][b]].sum+tr[root[x-1][y-1]].sum-tr[root[a][y-1]].sum-tr[root[x-1][b]].sum)) printf("Poor QLW\n");
			else printf("%d\n",ask(1,tot,root[x-1][y-1],root[a][b],root[a][y-1],root[x-1][b],v));
		}
	}
	return 0;
}
```
好了，题解到此结束。结束撒花！！

---

## 作者：asuldb (赞：1)

第一问的做法好像不太一样

首先第二问非常简单，直接在主席树上二分就好了，单次查询的复杂度$O(logn)$

第一问并没有想到有二分这种神仙操作，依旧用的是主席树

我们可以对矩阵建出主席树，也就是像二维前缀和那样的主席树

但是众所周知我们写二维前缀和的时候是这么写的

```cpp
	pre[x][y]+=pre[x-1][y]+pre[x][y-1]-pre[x-1][y-1]

```

我们发现这个样子我们根本没有办法优秀的建出主席树，因为这个样子还需要容斥

我们可以按照高维前缀和的思路来处理

```cpp
for(re int i=1;i<=n;i++)
		for(re int j=1;j<=m;j++) c[i][j]+=c[i][j-1];  
for(re int i=1;i<=n;i++)
		for(re int j=1;j<=m;j++) c[i][j]+=c[i-1][j];
```

也就是我们可以直接按照上面的方式来处理，所一我们每次需要的只有像一个主席树里添加一个点和把两个主席树合并的操作了

添加一个点是常规操作，合并两个主席树自然是需要线段树合并了

~~不过这里启发式合并好像更能保证复杂度的样子~~

单次查询像第二问一样就可以了，就是拎出四棵主席树来差分就好了

尽管现在预处理变得有些慢，但是现在单次查询的复杂度还是非常优秀的$O(log(nm))=O(logn+logm)$

这个题值域范围非常小，于是可以直接用二维前缀和进行二分，好像也是非常优秀的$O(log(\text{值域范围}))$

于是这个方法被吊打了

还是放上代码吧

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#define re register
#define maxn 500005
#define LL long long
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
inline int read()
{
	char c=getchar();
	int x=0;
	while(c<'0'||c>'9') c=getchar();
	while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+c-48,c=getchar();
	return x;
}
int n,m,Q;
namespace solve1
{
	int rt[201][201];
	int a[201][201],b[201*201],c[201][201];
	int l[201*201*801],r[201*201*801],d[201*201*801],sum[201*201*801];
	int sz,cnt;
	inline int find(int x)
	{
		int l=1,r=sz;
		while(l<=r)
		{
			int mid=l+r>>1;
			if(b[mid]==x) return mid;
			if(b[mid]<x) l=mid+1;
				else r=mid-1;
		}
		return 0;
	}
	int change(int pre,int pos,int val,int x,int y)
	{
		int root=++cnt;
		d[root]=d[pre]+1,sum[root]=sum[pre]+val;
		if(x==y) return root;
		l[root]=l[pre],r[root]=r[pre];
		int mid=x+y>>1;
		if(pos<=mid) l[root]=change(l[pre],pos,val,x,mid);
			else r[root]=change(r[pre],pos,val,mid+1,y);
		return root;
	}
	int merge(int a,int b,int x,int y)
	{
		if(!a) return b;if(!b) return a;
		int root=++cnt;
		if(x==y) 
		{
			sum[root]=sum[a]+sum[b];
			d[root]=d[a]+d[b];
			return root;
		}
		int mid=x+y>>1;
		l[root]=merge(l[a],l[b],x,mid),r[root]=merge(r[a],r[b],mid+1,y);
		d[root]=d[l[root]]+d[r[root]],sum[root]=sum[l[root]]+sum[r[root]];
		return root;
	}
	int query(int p1,int p2,int p3,int p4,int x,int y,int k)
	{
		if(x==y) 
		{
			int t=-b[x];
			if(k%t==0) return k/t;
			return k/t+1;
		}
		int now=sum[l[p1]]+sum[l[p2]]-sum[l[p3]]-sum[l[p4]];
		int mid=x+y>>1;
		if(now<k) return query(r[p1],r[p2],r[p3],r[p4],mid+1,y,k-now)+d[l[p1]]+d[l[p2]]-d[l[p3]]-d[l[p4]];
		return query(l[p1],l[p2],l[p3],l[p4],x,mid,k);
	}
	inline void solve()
	{
		for(re int i=1;i<=n;i++)
			for(re int j=1;j<=m;j++) a[i][j]=c[i][j]=read(),a[i][j]=-1*a[i][j],b[++sz]=a[i][j];
		std::sort(b+1,b+sz+1);
		sz=std::unique(b+1,b+sz+1)-b-1;
		for(re int i=1;i<=n;i++)
			for(re int j=1;j<=m;j++) a[i][j]=find(a[i][j]);
		for(re int i=1;i<=n;i++)
			for(re int j=1;j<=m;j++) rt[i][j]=change(rt[i][j-1],a[i][j],c[i][j],1,sz);
		for(re int i=1;i<=n;i++)
			for(re int j=1;j<=m;j++) rt[i][j]=merge(rt[i-1][j],rt[i][j],1,sz);
		for(re int i=1;i<=n;i++)
			for(re int j=1;j<=m;j++) c[i][j]+=c[i][j-1];  
		for(re int i=1;i<=n;i++)
			for(re int j=1;j<=m;j++) c[i][j]+=c[i-1][j];
		int sx,sy,dx,dy,K;
		while(Q--)
		{
			sx=read(),sy=read(),dx=read(),dy=read(),K=read();
			if(c[dx][dy]+c[sx-1][sy-1]-c[dx][sy-1]-c[sx-1][dy]<K) puts("Poor QLW");
			else printf("%d\n",query(rt[dx][dy],rt[sx-1][sy-1],rt[dx][sy-1],rt[sx-1][dy],1,sz,K));
		}
	}
}
namespace solve2
{
	int rt[maxn];
	int l[maxn*40],r[maxn*40],d[maxn*40],sum[maxn*40];
	int a[maxn],b[maxn],c[maxn];
	int sz,cnt;
	inline int find(int x)
	{
		int l=1,r=sz;
		while(l<=r)
		{
			int mid=l+r>>1;
			if(b[mid]==x) return mid;
			if(b[mid]<x) l=mid+1;
				else r=mid-1;
		}
		return 0;
	}
	int change(int pre,int pos,int val,int x,int y)
	{
		int root=++cnt;
		d[root]=d[pre]+1,sum[root]=sum[pre]+val;
		if(x==y) return root;
		l[root]=l[pre],r[root]=r[pre];
		int mid=x+y>>1;
		if(pos<=mid) l[root]=change(l[pre],pos,val,x,mid);
			else r[root]=change(r[pre],pos,val,mid+1,y);
		return root;
	}
	int query(int p1,int p2,int x,int y,int k)
	{
		if(x==y) 
		{
			int t=-b[x];
			if(k%t==0) return k/t;
			return k/t+1;
		}
		int now=sum[l[p1]]-sum[l[p2]];
		int mid=x+y>>1;
		if(now<k) return query(r[p1],r[p2],mid+1,y,k-now)+d[l[p1]]-d[l[p2]];
		return query(l[p1],l[p2],x,mid,k);
	}
	inline void solve()
	{
		std::swap(n,m);
		for(re int i=1;i<=n;i++) a[i]=-1*read(),b[++sz]=a[i],c[i]=-1*a[i];
		std::sort(b+1,b+sz+1);
		sz=std::unique(b+1,b+sz+1)-b-1;
		for(re int i=1;i<=n;i++) a[i]=find(a[i]);
		for(re int i=1;i<=n;i++) rt[i]=change(rt[i-1],a[i],c[i],1,sz);
		for(re int i=1;i<=n;i++) c[i]+=c[i-1];
		int o,x,y,K;
		while(Q--)
		{
			o=read(),x=read(),o=read(),y=read(),K=read();
			if(c[y]-c[x-1]<K) puts("Poor QLW");
			else printf("%d\n",query(rt[y],rt[x-1],1,sz,K));
		}
	}
}
int main()
{
	n=read(),m=read(),Q=read();
	if(n<=200&m<=200) solve1::solve();
		else solve2::solve();
	return 0;
}
```

---

## 作者：xukuan (赞：0)

先看数据范围：

对于50%的数据，满足$R,C \leq 200,M \leq 200000$

另有50%的数据，满足$R=1,C \leq 500000,M \leq 20000$

对于100%的数据，满足$1 \leq P_{i,j} \leq 1000,1 \leq H_i \leq 2000000000$

这其实是一道二合一的题

# Q1:

数据范围：$R,C \leq 200,M \leq 200000,1 \leq P_{i,j} \leq 1000,1 \leq H_i \leq 2000000000$

注意到一个很奇怪的地方：$1 \leq P_{i,j} \leq 1000$

用$sum_{i,j,k}$表示从$(1,1)$到$(i,j)$的矩阵中数值$=k$的数的个数

转移时从大到小枚举，用前缀和算出每个数的个数。

时间复杂度$O(1000nm)$，卡常可过

# Q2：

数据范围：$R=1,C \leq 500000,M \leq 20000,1 \leq P_{i,j} \leq 1000,1 \leq H_i \leq 2000000000$

考虑二分最小值,可以用主席树维护区间。具体方式：我们先计算右子树的和，如果右子树上的点$ \geq h$，我们就进入右子树，否则$h-=\sum rson$并且进入左子树。当$l=r$时，$ans+=[\frac{h+l-1}{l}]$并结束

时间复杂度：$O(10m log_2 m)$，那个10是二分的时间复杂度，稳稳的过

代码（std1解Q1，std2解Q2）：
```cpp
#include<bits/stdc++.h>
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;

ll n,m,T;

inline ll read(){
    ll x=0,tmp=1;
    char ch=getchar();
    while(!isdigit(ch)){
        if(ch=='-') tmp=-1;
        ch=getchar();
    }
    while(isdigit(ch)){
        x=(x<<3)+(x<<1)+(ch^48);
        ch=getchar();
    }
    return tmp*x;
}

inline void write(ll x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    ll y=10,len=1;
    while(y<=x){
        y=(y<<3)+(y<<1);
        len++;
    }
    while(len--){
        y/=10;
        putchar(x/y+48);
        x%=y;
    }
}

namespace std1{
    const ll N=210,V=1010;
    ll sum[N][N][V],f[V];
    int main(){
        for(ll i=1; i<=n; i++){
            for(ll j=1; j<=m; j++){
                ll x=read();
                for(ll k=1; k<=1000; k++) sum[i][j][k]=sum[i-1][j][k]+sum[i][j-1][k]-sum[i-1][j-1][k];
                sum[i][j][x]++;
            }
        }
        while(T--){
            ll x1=read(),Y1=read(),x2=read(),y2=read(),val=read(),tot=0,ans=0;
            for(ll i=1; i<=1000; i++) f[i]=sum[x2][y2][i]-sum[x1-1][y2][i]-sum[x2][Y1-1][i]+sum[x1-1][Y1-1][i];
            for(ll i=1000; i>=1&&tot<val; i--){
                ll x=min(f[i],(val-tot)/i);
                f[i]-=x; ans+=x; tot+=i*x;
                if(f[i]>0&&tot<val){
                    f[i]--;
                    ans++;
                    tot+=i;
                }
            }
            if(tot>=val) write(ans);
            else printf("Poor QLW");
            putchar('\n');
        }
        return 0;
    }
}

namespace std2{
    const ll N=500010;
    ll cnt,root[N];
    struct SegmentTree{
        ll lson,rson,sum,size;
    }tree[N<<5];
    ll update(ll pre,ll l,ll r,ll val){
        ll p=++cnt;
        tree[p]=tree[pre];
        tree[p].sum+=val; tree[p].size++;
        if(l==r) return p;
        ll mid=(l+r)>>1;
        if(val<=mid) tree[p].lson=update(tree[pre].lson,l,mid,val);
        if(val>mid) tree[p].rson=update(tree[pre].rson,mid+1,r,val);
        return p;
    }
    ll query(ll x,ll y,ll l,ll r,ll rank){
        ll ans=0;
        while(l<r){
            ll mid=(l+r)>>1,k=tree[tree[y].rson].sum-tree[tree[x].rson].sum;
            if(k<rank){
                ans+=tree[tree[y].rson].size-tree[tree[x].rson].size;
                rank-=k; r=mid;
                y=tree[y].lson;
                x=tree[x].lson;
            }
            else{
                l=mid+1;
                x=tree[x].rson;
                y=tree[y].rson;
            }
        }
        ans+=(rank+l-1)/l;
        return ans;
    }
    int main(){
        for(ll i=1; i<=m; i++) root[i]=update(root[i-1],1,1000,read());
        while(T--){
            ll a=read(),b=read(),c=read(),d=read(),val=read();
            if(tree[root[d]].sum-tree[root[b-1]].sum<val) printf("Poor QLW");
            else write(query(root[b-1],root[d],1,1000,val));
            putchar('\n');
        }
        return 0;
    }   
}

int main(){
    n=read(); m=read(); T=read();
    if(n!=1) std1::main();
    else std2::main();
    return 0;
}
```

---

## 作者：joe19025 (赞：0)

## Solution

### 概述

这题是个二合一的题，唯一的共同点就是都要二分，一个是主席树，另一个是二维前缀和。

分析一波数据，50% R=1就是序列问题，这个可以用主席树，至于另外50%，就用二维前缀和。

### Part 1 主席树

这个很好想，属于主席树大套路，依旧每次从前向后建，每次添加一个数，只不过这次要维护两个量，一个是个数，一个是和，但属于基本线段树操作，提高组必会。

接下来二分答案，利用主席树来验证。方法就是用前面的减去后面的，求区间前k大的和，主席树模版稍微加强点。

#### 注意

因为一个数的位置可能有多个相同的数，求前k大的和时切记不要直接return sum，而return k乘v才对。

#### 复杂度

$$
Mlog(R)log(1000)
$$



### Part 2 二维前缀和

这个稍微有些不好想。

#### 变量



$$
f[i][j][k]为(1,1)到(i,j)中大于k的数的个数
$$



$$
g[i][j][k]为(1,1)到(i,j)中大于k的数的和
$$



接下来就二分就行了，二分最小的数ans

#### 注意

同样的问题，多的sum怎么办，就做差然后除法减掉

#### 复杂度

$$
Mlog(1000)
$$



## Code

```c++
#include <cstring>
#include <cstdlib>
#include <algorithm>
#include <cstdio>
#define MAXN 500005
using namespace std;

struct tree{
    int l,r;
    tree *lson,*rson;
    int cnt,sum;
}pool[MAXN*20],*rt[MAXN];

int tot=0;

tree *build(int l,int r)
{
    tree* now=&pool[tot++];
    now->l=l;now->r=r;
    if(l==r)
        return now;
    int mid=(l+r)>>1;
    now->lson=build(l,mid);
    now->rson=build(mid+1,r);
    return now;
}

tree *update(tree *node,int v)
{
    tree *now=&pool[tot++];
    now->l=node->l;now->r=node->r;
    if(node->l==node->r)
    {
        now->sum=node->sum+v;
        now->cnt=node->cnt+1;
        return now;
    }
    if(v<=node->lson->r)
    {
        now->rson=node->rson;
        now->lson=update(node->lson,v);
    }
    else
    {
        now->lson=node->lson;
        now->rson=update(node->rson,v);
    }
    now->sum=now->lson->sum+now->rson->sum;
    now->cnt=now->lson->cnt+now->rson->cnt;
    return now;
}

int query(tree *node1,tree *node2,int k)
{
    if(node1->l==node1->r)
        return k*node1->l;
    if(node2->rson->cnt-node1->rson->cnt>=k)
        return query(node1->rson,node2->rson,k);
    else
        return node2->rson->sum-node1->rson->sum+query(node1->lson,node2->lson,k-(node2->rson->cnt-node1->rson->cnt));
}

int R,C,M;
int f[205][205][1005],g[205][205][1005];//f for count g for sum

int main()
{
    scanf("%d%d%d",&R,&C,&M);
    if(R==1)
    {
        int a[MAXN];
        for(int i=1;i<=C;i++)
            scanf("%d",&a[i]);
        rt[0]=build(1,1000);
        for(int i=1;i<=C;i++)
            rt[i]=update(rt[i-1],a[i]);
        for(int i=1;i<=M;i++)
        {
            int x,a,y,b,h;
            scanf("%d%d%d%d%d",&x,&a,&y,&b,&h);
            int l=1,r=b-a+1;
            int ans=0x3f3f3f3f;
            while(l<=r)
            {
                int mid=(l+r)>>1;
                if(query(rt[a-1],rt[b],mid)>=h)
                {
                    ans=mid;
                    //printf("%d ",ans);
                    r=mid-1;
                }
                else
                {
                    l=mid+1;
                }
            }
            if(ans!=0x3f3f3f3f)
            printf("%d\n",ans);
            else printf("Poor QLW\n");
        }
        exit(0);
    }
    else
    {
        int a[205][205];
        for(int i=1;i<=R;i++)
            for(int j=1;j<=C;j++)
                scanf("%d",&a[i][j]);
        
        memset(f,0,sizeof(f));
        memset(g,0,sizeof(g));
        for(int k=0;k<=1000;k++)
        {
            for(int i=1;i<=R;i++)
            {
                for(int j=1;j<=C;j++)
                {
                    f[i][j][k]=f[i-1][j][k]+f[i][j-1][k]-f[i-1][j-1][k];
                    g[i][j][k]=g[i-1][j][k]+g[i][j-1][k]-g[i-1][j-1][k];
                    if(a[i][j]>=k)
                        f[i][j][k]+=1,g[i][j][k]+=a[i][j];
                }
            }
        }

        

        for(int i=1;i<=M;i++)
        {
            int x1,y1,x2,y2,h;
            scanf("%d%d%d%d%d",&x1,&y1,&x2,&y2,&h);
            int l=0,r=1000,ans=-1;
            while(l<=r)
            {
                int mid=(l+r)>>1;
                if(g[x2][y2][mid]-g[x2][y1-1][mid]-g[x1-1][y2][mid]+g[x1-1][y1-1][mid]>=h)ans=mid,l=mid+1;
                else r=mid-1;
            }
            if(ans==-1)printf("Poor QLW\n");
            else
                printf("%d\n",f[x2][y2][ans]-f[x1-1][y2][ans]-f[x2][y1-1][ans]+f[x1-1][y1-1][ans]-(g[x2][y2][ans]-g[x2][y1-1][ans]-g[x1-1][y2][ans]+g[x1-1][y1-1][ans]-h)/ans);
            
        }
        exit(0);
    }
    
    return 0;
}
```



---


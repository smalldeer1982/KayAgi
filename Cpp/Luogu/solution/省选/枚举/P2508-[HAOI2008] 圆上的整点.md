# [HAOI2008] 圆上的整点

## 题目描述

求一个给定的圆$(x^2+y^2=r^2)$，在圆周上有多少个点的坐标是整数。


## 说明/提示

$r\leq 2000 000 000$


## 样例 #1

### 输入

```
4```

### 输出

```
4```

# 题解

## 作者：emptysetvvvv (赞：159)

### 背景

> 深夜，一位退役 OIer 正坐在电脑前恰着零食喝着快乐水逛着B站。

>突然，emptyset 发现了一则[十分通俗易懂并且相当有趣的双语科普视频](https://www.bilibili.com/video/av12131743/)。

>emptyset 总记得见过这问题，迅速打开洛咕一看，我靠，何止是见过，明晃晃赤裸裸的“历史分数 20”惨不兮兮的挂在那里。吓得 emptyset 赶紧打开记事本码了起来。

>emptyset 想着自己退役了也没给洛咕有什么贡献，于是就打算写一篇通（垃）俗（圾）易（难）懂（读）的题解。

### 思路

#### PART I

假如我们在研究这样一类问题：**以原点为圆心，以 $\sqrt N$ 为半径的圆上有多少个整点**。

我们转化下，其实就是：**有多少个整数对 $(a,b)$ 满足 $a^2+b^2=N$**。

然而，研究二元关系总是不方便的，我们可以将二维平面看做全体复数。

> 如果你没学过复数，可以先这样理解，平面直角坐标系上的点 $(a,b)$ 对应复数 $a+bi$，其中 $i$ 是虚数单位，满足 $i^2=-1$。

> 特别的，如果虚数 $a+bi$ 中 $a,b$ 均为整数，我们又称其为**高斯整数**。

注意到 $a^2+b^2=N$ 等价于 $(a+bi)(a-bi)=N$，因此，问题又可以转化为：**有多少个高斯整数 $z$ 满足其本身与其共轭复数 $\overline{z}$ 的乘积是 $N$**。

>$z=a+bi$ 的共轭复数 $\overline{z}=a-bi$。

-----

#### PART II

既然谈到了高斯整数相乘为 $N$，我们应该康康**一个数 $N$ 如何在高斯整数上分解**。

我们都知道，一个数 $N$ 在整数范围内有唯一分解式，即表达为若干个因子的乘积，而其中每个因子都不能再分，这些因子也就是我们说的素数。

当然，你给其中一个因子乘以 $-1$，给另一个因子也乘以 $-1$（$-1\times -1=1$），这样的分解式依然成立。

在高斯整数范围内，一个整数 $N$ 也可以表达为若干个复数因子的乘积，而其中每个因子在高斯整数上不能再分，这些因子也就是**高斯素数**。

> e.g. 整数 $5=(2+i)(2-i)$，而 $2+i$ 等就不能再分了，也就是说 $2+i$ 这样的就是高斯素数。

当然，这一回，你不但可以给其中一个因子乘以 $-1$，给另一个因子乘以 $-1$，你还可以给其中一个乘以 $i$，另一个乘以 $-i$（$i\times -i=1$），这样分解式依然成立。

> e.g. $5=(2+i)(2-i)$

> $=(-2-i)(-2+i)$	//注：一个因子乘以$-1$，另一个因子乘以$-1$

> $=(2i-1)(-2i-1)$	//注：一个因子乘以 $i$，另一个因子乘以$-i$

所以，想要一个数在高斯整数上分解，我们考虑先将 $N$ 分解为若干个素数的乘积，再将其中的非高斯素数进一步分解。

------

#### PART III

那么我怎么知道**一个素数是不是高斯素数呢**？

我们可以借助费马平方和定理。

> 费马平方和定理：奇素数 $p$ 可以表示为两个正整数的平方和，当且仅当 $p$ 是 $4k+1$ 型的。并且在不考虑两个正整数顺序的情况下，这个表示方法唯一。

> 证明留作习题，读者自证~~亦不难~~有点难，当然，其实是有相当初等的证法的。

通过该定理我们得知，

$4k+3$ 型的素数是高斯素数，因此，以 $\sqrt3,\sqrt7,\sqrt{11}\cdots$为半径的圆上没有整点；

$4k+1$ 型的素数可以恰好被分解成一对共轭复数的乘积，因此，以$\sqrt5,\sqrt{13},\sqrt{17}\cdots$为半径的圆上有整点（实际上观察可知恰好是 $8$ 个整点，原因后文再讲）；

而剩下一个素数 $2$ 则比较特殊，她的确可以分解成一对共轭复数 $(1+i)(1-i)$，有趣的是这两个复数除了共轭，他们的夹角还恰好为 $90\degree$。

--------

#### PART IV

如果用 $p$ 表示 $4k+1$ 型素数，$q$ 表示 $4k+3$ 素数（即高斯素数），那么我们可以将 $N$ 表示为这样的形式：

$$\large N=2^n\prod_{q_i=4k+3}q_i^{m_i}\prod_{p_j=4k+1}p_j^{k_j}$$

其中，每一个 $p_i$ 是可以分解为一对共轭复数的。

现在我们的目的是求将 $N$ 表示为一对共轭复数的乘积有多少种方法，那么分别讨论每一种素数：

- $4k+1$ 型素数 $p_j$ 的贡献

对于每一个 $p_j$，可以分解成 $z_j$ 和 $\overline{z_j}$，

我们可以将 $z_j$ 分配给 $N$ 的第一个因子，将 $\overline{z_j}$ 分配给 $N$ 的第二个因子（这样才能保证 $N$ 的两个因子是共轭的），

也可以将 $\overline{z_j}$ 分配给第一个因子，将 $z_j$ 分配给第二个因子。

也就是说，每一个 $p_j$ 可以有 $2$ 种分配方式。

更进一步的，对于 $p_j^{k_j}$，我们可以给第一个因子分配 $0$ 个 $z_j$、$1$ 个 $z_j\cdots$一直到 $k_j$ 个 $z_j$。

**也就是说，每一个 $p_j^{k_j}$ 可以有 $k_j+1$ 种分配方式。**

- $4k+3$ 型素数即高斯素数 $q_i$ 的贡献

> 在此之前，相信大家都知道如果一个复数没有虚部，那么该复数的共轭复数就是他本身，因为若 $z=a+0i$，$\overline z=a-0i=z$。

对于 $q_i^{m_i}$，我们想要把他分成共轭的两个因子的乘积，有多少种方案呢？

显然，如果 $2\mid m_i$，那么我们给每个因子分配 $m_i/2$ 个 $q_i$，两个因子相等，自然也就共轭了，分配方案数为 $1$。

如果 $2\nmid m_i$，哦，完蛋，因为你怎么分也不能把 $q_i^{m_i}$ 分成一对共轭复数的乘积，方案数为 $0$。

**也就是说，$m_i$ 是偶数没什么影响，只要有一个 $m_i$ 是奇数，那么方案数立即归零，这个圆上没有整点。**

- 素数 $2$ 的贡献

在讨论 $2$ 的问题前，请先注意一个问题：

> 正如前文所说，对于将 $N$ 表示为 $z\cdot\overline{z}$ 的每一种方案，$N$ 还可以表示为 $-z\cdot-\overline{z}$、$iz\cdot -i\overline{z}$、$-iz\cdot i\overline{z}$。

>也就是说，最终的方案数是要乘以 $4$ 的。

>对应到几何关系上，等于说每得到一个圆上的整点，还可以将它绕原点旋转 $90\degree,180\degree,270\degree$，转完的点还是在圆上的，这是乘以 $4$ 的等价解释。

现在再来看，我们说过，每一个 $2$ 虽然可以表示为 $(1+i)(1-i)$，看似提供了 $2$ 种分配方案（前者给第一个因子 或 前者给第二个因子 这两种），但是由于 $(1+i)$ 与 $(1-i)$ 的夹角是 $90\degree$，如果考虑 $2$ 的贡献会与之后的 “乘以 $4$” 计重，所以不应该考虑 $2$ 的贡献。


> 举个例子，半径为 $\sqrt5$ 的圆上有多少个整点，半径为 $\sqrt{10},\sqrt{20},\sqrt{40}$ 的圆上就有多少个整点。

**也就是说，因为最终方案数要乘以 $4$，所以 $2^n$ 不应该产生任何影响。**

------------

#### PART V

好了，现在我们可以看这道题了，在本题中，$N=r^2$，$r$ 是给定的。

假设分解 $r$ 得到

$$r=2^n\prod_{q_i=4k+3}q_i^{m_i}\prod_{p_j=4k+1}p_j^{k_j}$$

那么

$$N=2^{2n}\prod_{q_i=4k+3}q_i^{2m_i}\prod_{p_j=4k+1}p_j^{2k_j}$$

我们很高兴的看到，$N$ 的每一个高斯素数因子 $q_i$ 的指数 $2m_i$ 都是偶数，不用担心归零了，他们不会产生任何影响。

更进一步的，方案数只与 $2k_j$ 有关。

上文提到，每一个 $p_j^{k_j}$ 可以有 $k_j+1$ 种分配方式，那么每一个 $p_j^{2k_j}$ 可以有 $2k_j+1$ 种分配方式。

再考虑上乘以 $4$，得到圆上的整点数为

$$4\prod_{p_j=4k+1}(2k_j+1)$$

复杂度为分解素因数 $\Theta(\sqrt r)$。

### 代码

```cpp
#include <cstdio>
int r;
long long ans = 1;
int main() {
	scanf("%d", &r);
	for(int i = 2, cnt; i*i <= r; ++i)
		if(!(r % i)) {
			cnt = 0;
			do r /= i, ++cnt; while(!(r % i));
			if(i%4 == 1) ans *= cnt<<1|1;
		}
	if(r != 1 and r%4 == 1) ans *= 3;
	printf("%lld\n", ans<<2);
}
```

### p.s

> 好了好了这可能是最后一次在洛咕灌水了，算是最后一件与 OI 有关的事情吧，溜了溜了。

---

## 作者：icy (赞：68)

https://www.bilibili.com/video/av12131743/

看到这个视频突然想到了这个题

感触极大。

先说复杂度O（·分解质因数·）

运用了较难的数学：高斯素数，相关的知识：复平面、复共轭、积性函数等

就如同up说的，将r做质因数分解，质因子分为三类：2.高斯素数.其他数

良心视频，希望大家有所收获。

虽然这个题是将π与素数的关系，不过前95%对咱们这个题用处极大。

补楼下的图

 ![](https://cdn.luogu.com.cn/upload/pic/1697.png) 

![](https://cdn.luogu.com.cn/upload/pic/1698.png)


---

## 作者：Nemlit (赞：51)

题目的所求可以转化为:
$y^2=r^2-x^2$（其中r,x,y均为整数）

即$y^2=(r-x)(r+x)$（其中$r,x,y$均为整数）

不妨设$(r-x)=d*u$-------① $(r+x)=d*v$-------②（其中$gcd(u,v)=1$）

则有$y^2=d^2*u*v$，因为$u,v$互质所以$u,v$一定是完全平方数，所以再设$u=s^2,v=t^2$

则有$y^2=d^2*s^2*v^2$，即$y=d*s*v$

②-①得$x=\frac{ t^2-s^2 }{2}*d$

②+①得$2*r=(t^2+s^2)*d$

然后枚举$2*r$的约数$d$，枚举算出$s$，算出对应$t$，若$gcd(t,s)=1$且$s,t$为整数，带入求出$x,y$，若符合题意答案就加二（$x,y$满足交换律）

最后的答案为$(ans+1)*4$，($+1$是因为坐标轴上有一点，$*4$是因为4个象限) 

注意：小心乘法运算时爆longlong

代码如下：

```
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define re register
il int read()
{
    re int x=0,f=1;re char c=getchar();
    while(c<'0'||c>'9') {if(c=='-') f=-1;c=getchar();}
    while(c>='0'&&c<='9') x=x*10+c-48,c=getchar();
    return x*f;
}
il int gcd(int a,int b)
{
	if(!b) return a;
	return gcd(b,a%b);
}
int r,ans;
il void work(int d)
{
	for(re int s=1;s*s<=r/d;++s)
	{
		int t=sqrt(r/d-s*s);
		if(gcd(s,t)==1&&s*s+t*t==r/d)
		{
			int x=(s*s-t*t)/2*d;
			int y=d*s*t;
			if(x>0&&y>0&&x*x+y*y==(r/2)*(r/2)) ans+=2;
		}
	}
}
signed main()
{
	r=read()*2;
	for(re int i=1;i*i<=r;++i)
	{
		if(r%i==0)
		{
			work(i);
			if(i*i!=r) work(r/i);
		}
	}
	printf("%lld",(1+ans)*4);
	return 0;
}
```

---

## 作者：xyz32768 (赞：16)

为了考虑方便，把问题视为以下模型：

对于任意的$1\leq x<r$，求出满足$r^2-x^2$是完全平方数的$x$的个数，并把结果加$1$（坐标轴上的整点）再乘$4$（$4$个象限）。

求$x$的个数仍然是暴力统计，但是此题可以利用$r^2-x^2$是完全平方数的**必要条件**，缩小枚举范围。

怎样求出这个必要条件呢？首先，把$r^2-x^2$化为$(r+x)(r-x)$。

思考$ab$为完全平方数的条件。可以看出，如果$ab$是完全平方数，那么$\frac{a}{\gcd(a,b)}*\frac{b}{\gcd(a,b)}$一定也是完全平方数，反过来也一样（因为$\gcd(a,b)^2$是完全平方数）。此时设$u=\frac{a}{\gcd(a,b)},v=\frac{b}{\gcd(a,b)}$，那么$u$和$v$一定互质。容易推出$ab$为完全平方数当且仅当$u,v$都是完全平方数。

再看$\gcd(r+x,r-x)$的取值。容易得出，$\gcd(r+x,r-x)=\gcd(r-x,2x)$。设$d=\gcd(r-x,2x)$。

当$d|x$时，则有$\gcd(r-x,2x)=\gcd(r-x,x)=\gcd(r,x)$，此时$d$可以取$r$的任意约数。

否则有$\gcd(r-x,2x)=2\gcd(r-x,x)=2\gcd(r,x)$，此时$d$可以取$r$的任意约数的两倍。

从上面推出，$d=\gcd(r+x,r-x)$的取值范围为$r$的每一个约数和每一个约数的两倍（注意去重）。

考虑枚举$d$，则可以用「$\frac{r-x}{d}$的值为完全平方数」作为必要条件进行计算。由于$\frac{r-x}{d}$只能是完全平方数，所以对于每一个$d$，只要枚举$\frac{r}{d}$以内的所有完全平方数，就可以求出对应的$x$值并进行判断了，但要注意：

1、必须要有$1\leq x<r$才能统计。

2、为避免重复，必须判断是否$\gcd(r+x,r-x)=d$。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e4 + 5;
int r, tot; ll Ans, a[N];
ll gcd(ll a, ll b) {return b ? gcd(b, a % b) : a;}
int main() {
    int i, d, S, j, cc = 0; cin >> r; S = sqrt(r);
    for (i = 1; i <= S; i++)
        if (r % i == 0) {
            a[++cc] = i; a[++cc] = 2ll * i;
            if (r / i != i) a[++cc] = r / i,
                a[++cc] = 2ll * (r / i);
        }
    sort(a + 1, a + cc + 1); tot = unique(a + 1, a + cc + 1) - a - 1;
    for (j = 1; j <= tot; j++) {
        d = a[j]; for (i = 1; 1ll * i * i * d <= r; i++) {
            int x = r - i * i * d; if (x <= 0 || x >= r) continue;
            if (gcd(1ll * r + x, 1ll * r - x) != d) continue;
            ll w = 1ll * r * r - 1ll * x * x;
            ll s = sqrt(w); if (s * s == w) Ans++;
        }
    }
    cout << (Ans + 1) * 4 << endl;
    return 0;
}
```

---

## 作者：VenusM1nT (赞：13)

首先我依然要推一下这个视频：[$->Click\ Here<-$](https://www.bilibili.com/video/av12131743/)

当初看不懂这个视频，现在依然看不大懂……但还是懂一点了……

我这里就只说说结论了……

（按视频的内容，我们要把$R$转换成$\sqrt{R^2}$来看，这样）

**[FBI WARNING] 下方及其混乱 纯属个人理解 并不严谨**

---
## 前置芝士（瞎讲）

首先我们知道，一个平面直角坐标系是看成全体**复数**的集合的，$(x,y)$就可以用$x+yi\ \ (i=\sqrt{-1})$表示。

举个栗子，比如$(3,4)$这个点，在复数平面上就是$3+4i$。

其次，我们知道，一个整点如果在圆上，要满足的是$x^2+y^2=r^2$，比如$3^2+4^2=5^2$。

我们将$3^2+4^2=25$这个式子进行因式分解，会发现$3^2+4^2=(3+4i)(3-4i)$，$(3-4i)$就称为$(3+4i)$的“复共轭”（即实数部相等 复数部为相反数的两个复数）。

重要的来了，此时我们会发现，有一些素数，它们的平方可以被因式分解成**一个复数**和**这个复数的复共轭**的乘积，如 $5^2=25=(3+4i)(3-4i)$，$13^2=169=(5+12i)(5-12i)$，经过找规律，我们可以发现这些素数 $mod\ 4=1$，而且以它们为半径的圆总是经过$(1+4)\times 4=20$个点，这些素数就是我们解题的关键了。

事实上素数可以分为三种：$2$、**“高斯素数”**和其他素数，高斯素数的特征就是$mod\ 4=3$，而高斯素数的定义是**无法被分解成两个复数的乘积的数**。对于一个素数来说，这意味着什么呢？很明显，它的平方无法用两个数的平方和表示，也就是说以它为半径的圆除去坐标轴外没有任何一个整点。

---
## 解题方法

对于这题，我们先将$R$分解质因数：

$$R=\prod_{i=1}^{n} p_i^{k_i}\ \ p_i\in Prime$$

然后答案就等于：

$$ans=(\prod_{i=1}^{n}k_i\times 2+1\ \ p_i\in \{x\ |\ x\ mod\ 4=1 \ \ x\in Prime\})\times 4$$

解释一下为什么，如果一个质因数对答案有贡献，首先它得是$mod\ 4=1$的素数，即非$2$、非“高斯素数”，然后因为我们是把$R$当成$\sqrt{R^2}$来看的，在分解时每个$k_i$会被分解成$k_i\times 2$，然后最后加上的$1$代表着坐标轴上的点，这是一个象限的点的总和，所以最后将它乘上$4$即可

于是这道题的解法就呼之欲出了，当然，为了节省空间，防止$MLE$和$TLE$，我们在筛的时候只筛到了$\sqrt R$，这时我们要防止一种事情的发生，也就是说$R$可能等于一个素数$\times 2$或者它本身就是一个素数（因为这样它的质因数才能大于$\sqrt R$），所以最后判一下$R$是否为$1$，不是的话再判断它是否为高斯素数，如果仍不是，则需要将答案乘上$(1\times 2+1)$（因为此时的$ki$只可能为$1$）。

（非常混乱 凑合着看吧 感觉$Bug$应该挺多的）

见代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int r,n,pri[100005],tot;
ll ans=1;
bool isp[500005];
int main()
{
	scanf("%d",&r);
	n=sqrt(r);
	for(int i=2;i<=n;i++)
	{
		if(!isp[i]) pri[++tot]=i;
		for(int j=1;j<=tot && i*pri[j]<=n;j++)
		{
			isp[i*pri[j]]=1;
			if(!(i%pri[j])) break;
		}
	}
	for(int i=1;i<=tot;i++)
	{
		int sum=0;
		while(!(r%pri[i]))
		{
			sum++;
			r/=pri[i];
		}
		if(pri[i]%4==1) ans*=sum*2+1;
	}
	if(r>1 && r%4==1) ans*=3;
	printf("%lld\n",ans*4);
	return 0;
}
```

---

## 作者：Yexuaj (赞：12)

### 说在前面

某神奇的网站在普及组的练习赛中考了一道类似的题，所以就找到了这道题目（话说为什么会考这个难度的题啊喂）。

------------
先思考暴力的解法

从1到$r$直接枚举,显然超时。

由于这里 $a^2+b^2=r^2$ 中的 $a,b,r$不一定是互质的，而一组勾股数 $a,b,c$ 除以他们的因数 $p$依然是一组勾股数。所以这里可以寻找互质的勾股数而减少枚举次数

## 先考虑$a,b,c$均为正整数的情况

这里不妨设有两个整数 $m,n$ ,使得
$$a=m^2-n^2$$
$$b=2mn$$
$$c=m^2+n^2$$
这里的$a,b,c$满足$(a,b,c)=1$并且$c$为$r$的因子。当然此时构造出来的$a,b,c$满足$a^2+b^2=c^2$

通过推导，我们可以得到以下使得$a,b,c$是勾股数的$m,n$应该满足的关系：
$$m>n$$
$$(m,n)=1$$
并且此时$m,n$需要异奇偶。

那么就可以用代码实现

```cpp
for(long long n=1; n*n<c; ++n) {
	long long m_2=x-n*n;//这里通过枚举n去寻找m，x是r的某个因数
	if(!check(m_2))continue;//检查m_2是否是完全平方数（代码见文末）
	long long m=(long long)sqrt(m_2);
	if(m<=n)break;
	if(gcd(m,n)==1&&m%2!=n%2) {
		cnt+=1;
	}
}

```
如果这里把n的起点设置为0，则之后不用考虑坐标轴上的点,但是仍然需要加特判，答案的输出方式也不同。

## 从正整数扩展到所有点


而刚才的查找中，因为$a$和$b$可以倒置，所以最后的cnt要先乘2处理

而又因为坐标系有4个象限，所以最后又要乘4.

再加上4就是答案了（坐标轴上的四个点一定是满足条件的。）

```cpp
#include<bits/stdc++.h>
using namespace std;
long long c;
int cnt,ans;
long long lmt;

bool check(long long s){
	long long tmp=sqrt(s);
	return tmp*tmp==s;
}

long long gcd(long long x,long long y){//寻找最大公因数
	if(y==0)return x;
	else return gcd(y,x%y);
}

void find(long long x,long long b){//b为倍数，似乎可以删去
	for(long long n=1;n*n<c;++n){
		long long m_2=x-n*n;
		if(!check(m_2))continue;
		long long m=(long long)sqrt(m_2);
		if(m<=n)break;
		if(gcd(m,n)==1&&m%2!=n%2)
			++cnt;
	}
}

int main(){
	scanf("%lld",&c);
	for(long long i=1;i*i<=c;++i){//这里枚举c的因子
		if(c%i==0){
			if(i*i!=c)find(i,c/i);//防止i*i=c时做两次相同查找影响答案
			find(c/i,i);
		}
	}
	cout<<cnt*8+4;
}
```



---

## 作者：_OJF_ (赞：12)

我竟然没想到我的第一篇题解是个紫题！

~~要是所有紫题都是这个难度就好了~~

[来B站学数学](https://www.bilibili.com/video/av12131743/)（请先看此视频）虽然求的不是此结论，但对此题非常有用

[一堆~~没用的~~截屏](https://www.luogu.com.cn/paste/ag94gb2p)

先说一说本题的思路

首先是高斯质数：

我们都知道唯一分解定理，例如$2250 = 2 \times 3^2 \times 5^3$

但有一种特殊的数叫做高斯质数，我们来看$2$，它能分解为$(1 + i)(1 - i)$，或者说它能分解为$1 ^ 2 + 1 ^ 2$，同理，$5$能分解成$2 ^ 2 + 1 ^ 2$,所以它能分解成$(2 + i)(2 - i)$，$2$和$5$都不是高斯质数。

但$3$就不同了，$3 = a ^ 2 + b ^ 2$ 没有整数解，所以它是高斯质数。还有刚才分解出来的$(1 + i)$，$(1 - i)$，$(2 + i)$，$(2 - i)$等除了乘$i$，$-i$或$-1$以外没有以上的分解方式，它们也是高斯质数。

在视频里说的是关于$r ^ 2$的分解，但在这里$r$是正整数，所以在视频中有没有解的情况，而这里没有。

视频中还解释了为什么每个非高斯质数也不是$2$的相同的质因子能为乘积提供个数$+ 1$

视频中还解释了为什么质因子$2$虽不是高斯质数但不能为乘积提供任何变化以及为什么要$\times 4$。

以半径为5做例

![5（1）](https://cdn.luogu.com.cn/upload/image_hosting/b45ne2tx.png)

![5（2）](https://cdn.luogu.com.cn/upload/image_hosting/b45ne2tx.png)

最后$cnt$变量还需要乘$2$再加$1$,这个不用说明，现在上代码吧：

```cpp
#include<bits/stdc++.h>
using namespace std;
bool isp(long long a)//判断质数，不用多说
{
    for(int i = 2;i <= sqrt(a) + 0.1;i++)
        if(a % i == 0)
            return false;
    return true;
}
int n, ans = 4, cnt;//ans = 4省去乘$4$这一步，cnt可以使用很多次，n就是 $r$
int main()
{
    cin>>n;
    while(n % 2 == 0)
    {
        n /= 2;
    }//根据视频所说，把质因子2全去了
    int q = sqrt(n) + 0.1;//这样就只会剩下一个质数或者1了，还不会TLE，岂不美哉？
    for(int i = 3;i <= 2 * q;i += 2)
    {
        cnt = 0;
        if(i % 4 == 3)//直接判断高斯质数
        {
            while(n % i == 0)
            {
                n /= i;
            }
        } else {
            while(n % i == 0)
            {
                n /= i;
                cnt++;
            }
            ans *= cnt * 2 + 1;//注意视频里是平方后的结论，所以先*2，再+1
        }
    }
    if(n != 1)//可能会留下一个质因子，判断其是否是高斯质数
    {
    	if(n % 4 == 1) 
    	{
    		ans *= 3;//乘上1*2+1
		}
	}
    cout<<ans;
    return 0;
}
```
这篇题解就到这里了，希望管理员给过！

---

## 作者：幽云蓝 (赞：7)

[https://www.bilibili.com/video/av12131743](https://www.bilibili.com/video/av12131743)

建议先看完上面的视频QWQ

由视频可知，对于一个半径为$\sqrt{R}$的圆，计算它整点数的方式为：对于$R$的因数$a_i$，如果$a_i$模4值为1，将$ans$加上1；如果$a_i$模4值为3，将$ans$加上-1；如果$a_i$模4值为2或0，将$ans$加上0。在对$R$所有因数都进行过这一过程后，因为有四种变化方式，所以答案为$ans\times4$。

所以就得到了一种方式：大力枚举所给的$r$的所有因数，在根据$r$的因数推出$r^2$的因数，因为$r=\sqrt{r^2}$，所以就成功得出计算结果。

至于如何从$r$的所有因数推出$r^2$的因数，将$r$所有因数两两相乘，经过$map$去重后即为$r^2$的所有因数。

~~因为数据水，所以我过了。~~

代码：
```cpp
#include <bits/stdc++.h>
#define Mashu cout << "UUZ ate it." << endl
#define RE register int
#define ll long long
using namespace std;

vector< long long > QAQ;
map< int, int > mp;

long long kai(long long x){
	if (x % 2 == 0) return 0;
	else if (x % 4 == 1) return 1;
	else return -1;
}

void fenjie(long long x){
	for (long long i = 1; i <= sqrt(x); i++){
		if (x % i == 0){
			if (x == i * i){
				QAQ.push_back(i);
			}
			else{
				QAQ.push_back(i);
				QAQ.push_back(x / i);
			}
		}	
	}
}

long long jisuan(long long x){
	long long ans = 0;
	for (int i = 0; i < QAQ.size(); i++){
		for (int j = i; j < QAQ.size(); j++){
			if (mp.find(QAQ[i] * QAQ[j]) == mp.end()){
				mp.insert(make_pair(QAQ[i] * QAQ[j], 1));
				ans += kai(QAQ[i] * QAQ[j]);
			}
		}
	}
	return ans * 4;
}

int main(){
	long long x;
	cin >> x;
	fenjie(x);
	cout << jisuan(x) << endl;
	return 0;
	Mashu;
}
```


---

## 作者：tommymio (赞：7)

一句话题意，求：
$$
\sum_{x,y\in Z}[x^2+y^2=R^2]
$$
其中 $R$ 是整数常数。

形象化的描述，就是求以原点为圆心，半径为 $R$ 的圆上的整数点（~~并没有什么用~~

分析一下问题：$R$ 是常数，所以 $R^2$ 也是常数，不妨令常数 $Q=R^2$。那么就是求下式的值：
$$
\sum_{x,y\in Z}[x^2+y^2=Q]
$$
突然的，我们就有这样的一个思路，$x^2+y^2$ 是复数 $x+yi$ 或 $x-yi$ 的一个模。而这个模和复数 $x+yi$ 及其共轭复数的乘积的值是相等的，于是上式便可以写作：
$$
\sum_{x,y\in Z}[(x+yi)(x-yi)=Q]
$$
这里引进一个概念，对于 $x,y\in Z$ 的复数 $x+yi$ ，称之为高斯整数$\text{(Guassian Integer)}$。高斯整数也有唯一分解定理，在部分性质上同整数域。

那么，现在问题转化为 $Q$ **可以被分解为多少组高斯整数和其共轭复数的积。**前面提到，高斯整数也有唯一分解定理，自然可以想到将 $Q$ 分解成一些不可被分解的高斯整数的积。而这些高斯整数，我们就称其为高斯素数，高斯素数在高斯整数的定义下是不可再分解的，可以借助整数域下的素数来很好的理解这一定义。

如何判断一个高斯整数是高斯素数呢？

这里需要引入 **高斯素数判断定理**：高斯整数 $x+yi$ 中，实部或虚部等于零，另一个部的绝对值是一个 $4n+3$ 的整数，则这个数是一个高斯素数。可以得到若一个数是高斯素数，则它的共轭复数一定也是高斯素数。

根据 **高斯素数判断定理** 判断那些是质数的数，然后将 $Q$ 质因数分解（在高斯整数意义下），将质因数分解后的数分为两类，使得这两类数满足：在第一类数中的数，在第二类数中一定存在一个数与之共轭，并计算第一类数的本质不同乘积数，就是上式的值。

等等，我们是否遗漏了什么？直接对一个高斯整数进行质因数分解，难道是很容易完成的事么？很明显并不是。我们更加希望，能够不使用计算机内的复数运算，得到本质不同的乘积数，因为这样能够大大加快运算效率。为了完成这一点，该怎么做呢？

这里需要引入一个定理：费马二平方和定理。定理的内容是：

- 若奇质数 $k$ 能够被表示为两个整数 $a,b$ 的平方和，当且仅当 $k=4n+1,n\in Z$。

想一想，复数 $x+yi$ 的模和复数 $x+yi$ 与其共轭复数的积，值是不是一样的？于是可以知道，像 $k=4n+1$ 这样的质数，一定可以被分解成一组高斯素数和其共轭复数的积。而 $4n+3$ 则必然是高斯素数。

那么，我们可以根据这组结论，将任意一个高斯整数分解成一组高斯素数的乘积。并且发现，之前提到的第一类数本质不同积的数目，可以用类似整数域下因数个数的公式计算。这样，整个求解过程中，就不再涉及复数运算，使得效率显著提升。

另外，需要注意在分解时乘上 $1,-1,-i,i$ 对答案的影响。

```cpp
#include<cstdio>
typedef long long ll;
inline int read() {
    register int x=0,f=1;register char s=getchar();
    while(s>'9'||s<'0') {if(s=='-') f=-1;s=getchar();}
    while(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();}
    return x*f;
}
inline void DivideByPrime(int n) {
    ll ans=4;
    for(register int i=2;i*i<=n;++i) {
        if(n%i) continue;
        int cnt=0;
        while(n%i==0) ++cnt,n/=i;
        if(i%4==1) {ans*=(2ll*cnt+1);}
    }
    if(n>1&&n%4==1) {ans*=3;}
    printf("%lld\n",ans);
}
signed main() {
    int n=read();
    DivideByPrime(n);
    return 0;
}
```

---

## 作者：Mys_C_K (赞：5)

并看不懂楼下都是怎么做的，感觉好麻烦啊P^Q

正解是先把n中的2除掉，然后分解质因数，不妨记

n=p1^a1\*p2^a2...\*pk^ak

那么n^2=p1^2a1\*p2^2a2...\*pk^2ak，并初始化ans=1

根据一些显而易见的数论知识，若pi%4=3那么由于n^2指数是偶数所以对答案没有贡献。

否则pi%4=1，ans\*=(2ai+1)即可。最后ans\*=4即可。

注意特判n是质数的情况。

代码：

```cpp
    #include<iostream>
    #include<cstring>
    #include<cstdio>
    #include<algorithm>
    using namespace std;
    int main()
    {
        int n,ans=4;scanf("%d",&n);
        while((n&1)^1) n>>=1;
        int x=1;while(x*x<=n) x++;
        for(int i=2;i<=x;i++)
            if(n%i==0)
            {
                int c=0;while(n%i==0) c+=2,n/=i;
                if(i%4==1) ans*=(c+1);
            }
        if(n>1&&n%4==1) ans*=3;
        printf("%d\n",ans);return 0;
}
```

---

## 作者：一只书虫仔 (赞：4)

[P2508 [HAOI2008]圆上的整点](https://www.luogu.com.cn/problem/P2508)

### Description

给定一个半径为 $r$ 的圆，求在圆周上坐标为正数的点的个数。

### Find

这题好迷啊，我们画几张图试试（图片懒得挂了，可以去 [desmos](https://www.desmos.com/calculator) 玩玩）

- $r=1$

$ans = 4$

- $r=2$

$ans = 4$

- $r=3$

$ans = 4$

- $r=4$

$ans = 4$

- $r=5$

$ans=12$

- $r=6$

$ans=4$

我们会发现，毫无规律，大小也不按照 $r$ 的大小排 ~~wtnl~~

然后一看这标签，没有计算几何，诶

说明我们要推柿子了

### Solution 1

推长~长~的柿子

$$\begin{aligned}x^2+y^2&=r^2\\y^2&=r^2-x^2\\y^2&=(r+x)(r-x)\\y^2&=(\gcd(r-x,r+x))^2\cdot \dfrac{r-x}{\gcd(r-x,r+x)}\cdot\dfrac{r+x}{\gcd(r-x,r+x)}\end{aligned}$$
然后我们易得 $\dfrac{r-x}{\gcd(r-x,r+x)},\dfrac{r+x}{\gcd(r-x,r+x)}$ 这两个数为完全平方数（$y^2$ 和 $(\gcd(r-x,r+x))^2$ 都是完全平方数，所以 $\dfrac{r-x}{\gcd(r-x,r+x)}\cdot\dfrac{r+x}{\gcd(r-x,r+x)}$ 就是完全平方数，又因为这两个数的 $\gcd$ 是 $1$，所以这两个数分别为完全平方数）    
然后可以推出这两个数分别等于 $\dfrac{r-x}{\gcd(r-x,r+x)},\dfrac{r+x}{\gcd(r-x,r+x)}$   
两个数的和就为 $\dfrac{2r}{\gcd(r-x,r+x)}$，我们就得知 $\gcd(r-x,r+x)$ 为 $2r$ 的约数

然后我们就可以开始枚举约数了（枚举 $\sqrt{\dfrac{r-x}{\gcd(r-x,r+x)}}$ 在 $\left[1,\sqrt{\dfrac{r}{\gcd(r-x,r+x)}}\right]$ 的值，然后推导过去 $\dfrac{r-x}{\gcd(r-x,r+x)},\dfrac{r+x}{\gcd(r-x,r+x)}$ 即可）

最后，我们就可以得到代码啦！

```cpp
#include <bits/stdc++.h>

using namespace std;

long long gcd (long long a, long long b) {return b == 0 ? a : gcd(b, a % b);}

int main () {
	long long r;
	scanf("%lld", &r);
	r *= 2;
	long long ans = 0;
	for (long long i = 1; i * i <= r; i++) {
		if (r % i > 0) 
			continue;
		for (long long j = 1; j * j <= (i >> 1); j++) {
			long long tmp = 1ll * trunc(sqrt(i - (j * j))); // trunc 是小数去尾函数 —— Description By Shuchong
			if (j * j + tmp * tmp != i)
				continue;
			if ((gcd(j * j, tmp * tmp) == 1) && (j != tmp))
				ans++;
		}
		if (r / i != i) {
			for (long long j = 1; j * j <= 1ll * (i >> 1); j++) {
				long long tmp = 1ll * trunc(sqrt((r / i) - (j * j))); // trunc 是小数去尾函数 —— Description By Shuchong
				if (j * j + tmp * tmp != (r / i))
					continue;
				if ((gcd(j * j, tmp * tmp) == 1) && (j != tmp))
					ans++;
			}
		}
	}
	printf("%lld", 4 * (ans + 1));
	return 0;
}

```

别忘了是 $4$ 个坐标系和 $4$ 段轴，最后要加 $1$ 和 乘 $4$ 哦 ~

期望得分：$50$ 分   
提交记录：[Link](https://www.luogu.com.cn/record/34225827)

### Solution 2

老是 $50$ 分我也很痛苦，Qiuly 巨佬跟我说让我看看 3B1B 的 [Video](https://www.bilibili.com/video/av12131743/) 然后就可以找出做法了

以下为视频内容，故用 `>` 框起来 

> 将 $r$ 质因数分解为

> $$r=p_1^{a_1}\times p_2^{a_2}\times\cdots\times p_k^{a_k}$$

> 当 $p_i=4n+1$ 时，$ans$ 会乘上 $2k_1+1$

所以，我们直接把 $r$ 分解个质因数即可 ~

代码如下：

```cpp
#include <bits/stdc++.h>

using namespace std;

int a[1000086];

int main () {
	int r;
    scanf("%d", &r);
    int cnt = 0;
    for (int i = 2; i <= sqrt(r); i++) {
		if (!a[i]) 
			a[++cnt] = i;
		for (int j = 1; j <= cnt; j++){
			if (a[j] * i > sqrt(r))
				break;
			a[a[j] * i] = 1;
			if (i % a[j] == 0)
				break;
		}
	}
    int ans = 1;
	for (int i = 1; i <= cnt; i++) {
		int tmp = 0;
		while (r % a[i] == 0) {
			tmp++;
			r /= a[i];
		}
		if ((a[i] - 1) % 4 == 0)
			ans *= (2 * tmp + 1);
	}
	if (r != 1 && (r - 1) % 4 == 0)
		ans *= 3;
	printf("%d", 4 * ans);
    return 0;
}
```

期望得分：$100$ 分   
提交记录：[Link](https://www.luogu.com.cn/record/34228198)

---

参考资料：

Solution 1：Wolfycz 大佬的 [博客](https://www.cnblogs.com/Wolfycz/p/10003263.html)   
Solution 2：3B1B 的 [Video](https://www.bilibili.com/video/av12131743/)

---

## 作者：s_r_f (赞：3)

做完了[「2019 集训队互测 Day 1」整点计数](https://loj.ac/problem/3069) 之后再来看这道题，

发现~~这题的$n$比国集互测的$n$还小,而且国集互测求的是$f(x)^k$的前缀和~~

~~所以写个~~$Min$_$25$~~筛,这题就能过了~~

好了不胡扯了。

容易发现，答案一定是$4$的倍数，因为把一个点旋转$90/180/270$度之后它还在这个圆上。

那么考虑先求出一个象限里的$ans($令$f(x) = $这个$ans)$,然后乘以$4$,就是本题的答案了。

$xyx$神仙在论文里面证明了$f(x)$是一个积性函数，~~然而这题只要求$f()$的一个点值~~：

令$x^2 = p_1^{k_1} p_2^{k_2} p_3^{k_3}...p_m^{k_m}$ ,其中$p_1,...,p_m$都是质数，那么

$$ f(x) = \prod (1 + [p_i ≡ 1 (mod 4)] * k_i). $$

证明大概是说，首先它是一个积性函数，

然后分解质因数之后 质数 $2$ 和 $4k+3$ 型质数对答案毫无影响,

$4k+1$型质数就要让$ans$乘上$(1 + k_i)$.

具体证明和高斯整数$/$高斯质数的内容有关，可以参考$xyx$的候选队论文。

**注意**：这里的$k_i$**是$x^2$分解之后的结果**，所以分解质因数时别忘了把指数乘上$2$

那么，这道题的核心就说完了，如果~~想要写~~$Min$_$25$~~我也不拦你~~，但是这题只要分解质因数就好啦！

代码： 

```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read(){
    int x = 0,f = 1; char c = getchar();
    while (c != EOF && !isdigit(c)) {if (c == '-') f = -1;c = getchar();}
    while (isdigit(c)) {x = x * 10 + c - '0';c = getchar();}
    return x * f;
}
inline void write(int x){
    if (x < 0) putchar('-'),x = -x;
    if (x > 9) write(x/10); putchar(x%10+'0');
}
inline void writeln(int x){ write(x),putchar('\n'); }
int n,ans,cnt;
int main(){
    int i;
    n = read(),ans = 4;
    while (!(n&1)) n>>=1; //除去2
    for (i = 3; i * i <= n; ++i)
        if (!(n%i)){
            cnt = 0;
            while (!(n%i)) ++cnt,n /= i;
            if ((i&3)==1) ans *= cnt * 2 + 1;  //指数乘2再+1
        }
    if (n > 1 && (n&3) == 1) ans *= 3;
    writeln(ans);
    return 0;
}
```

---

## 作者：Guess00 (赞：2)

~~这是一道数学题~~

高斯曾证明过这么一个东西$:$
> 设正整数$n=2^{a_0}p_1^{a_1}…p_s^{a_s}q_1^{b_1}…q_t^{b_t},$其中$p_1,…,p_s,q_1…q_t$是不同的质数$,p_i≡1\pmod{4}(1\leq i\leq s),q_j≡3\pmod{4}(1\leq j\leq t),$而$a_0,…a_s,b_1,…,b_t$是非负整数$.$则当$b_1,…,b_t$至少有一个为奇数时$,f(n)=0.$而当$b_1,…,b_t$都是偶数时$,f(n)=4(a_1+1)(a_2+1)…(a_s+1).$

上述定理中$f(n)$函数表示方程$x^2+y^2=n$的正整数解个数$($证明过程略$,$太复杂$).$于是我们可以运用此定理$,$将题目中的$r$分解质因数$,$由于是$x^2+y^2=r^2,$所以$b_1…b_t$肯定都为偶数$,$答案为$4(2a_1+1)(2a_2+1)…(2a_s+1)$

$Pollard\_Rho,$复杂度是$\Theta(n^\frac{1}{4})(\text{就算r是1e+18都能过})$

$\mathbb{CODE:}$
```cpp
#include <bits/stdc++.h>
#define int long long
const int pri[]={2,3,5,7,11,13,17,23,29};
using std::vector;
using std::sort;
int n,i,j,cnt,ans=1;
vector<int> v;
inline void read(int &x)
{
    short negative=1;
    x=0;
    char c=getchar();
    while(c<'0' || c>'9')
    {
        if(c=='-')
            negative=-1;
        c=getchar();
    }
    while(c>='0' && c<='9')
        x=(x<<3)+(x<<1)+(c^48),c=getchar();
    x*=negative;
}
inline void print(int x)
{
    if (x<0)
        putchar('-'),x=-x;
    if(x>9)
        print(x/10);
    putchar(x%10+'0');
}
inline int gcd(int a,int b){return b==0?a:gcd(b,a%b);}
inline int ksc(int x,int y,int mod)
{
    return (x*y-(long long)((long double)x/mod*y)*mod+mod)%mod;
}
inline int ksm(int a,int b,int m)
{
    int ans=1;
    a%=m;
    while(b)
    {
        if(b&1)
            ans=ksc(a,ans,m);
        b/=2;
        a=ksc(a,a,m);
    }
    ans%=m;
    return ans;
}
inline bool MR(int x,int p)
{
    if(ksm(x,p-1,p)!=1)
        return false;
    int k=p-1;
    while(!(k&1))
    {
        k>>=1;
        int t=ksm(x,k,p);
        if(t!=1 && t!=p-1)
            return false;
        if(t==p-1)  
            return true;
    }
    return true;
}
inline bool Miller_Rabin(int p)
{
    if (p==1 || p==2152302898747)
        return false;
    for (int i=0;i<9;i++)
        if (p==pri[i])
            return true;
        else
            if (p%pri[i]==0 || (!MR(pri[i],p)))
                return false;
    return true;
}
inline int Pollard_Rho(int n,int c)
{
    int i=0,k=2,x=rand()%(n-1)+1,y=x;
    while(true)
    {
        i++;
		x=(x*x%n+c)%n;
        int d=gcd((y-x+n)%n,n);
        if(d!=1 && d!=n)
			return d;
        if(x==y)
			return n;
        if(i==k)
			y=x,k<<=1;
    }
}
inline void find(int x,int c)
{
    if(x==1)
		return;
    if(Miller_Rabin(x))
	{
		v.push_back(x);
		return;
	}
    int p=x;
	while(p>=x)
		p=Pollard_Rho(p,c--);
    find(p,c);
	find(x/p,c);
}
//MR,Miller_Rabin,Pollard_Rho,find函数是用来高效分解质因数的,存在一个vector中 
//看不懂可以去看另一个代码,或者去P4718学习Pollard_Rho 
signed main(void)
{
	read(n);
	find(n,200);
	sort(v.begin(),v.end());
	for (i=0;i<v.size();i++)
	{
		j=i,cnt=1;
        while (i<v.size()-1 && v[j]==v[i+1])  //找相等质因数的个数 
			i++,cnt++;
        if (v[j]%4==1)    //如果mod4=1,更新答案 
			ans*=(cnt*2+1);
	}
	print(ans*4);   //输出 
	return 0;
}
```

正常分解是$\Theta(n^\frac{1}{2})$

$\mathbb{CODE:}$
```cpp
#include <bits/stdc++.h>
#define int long long
int n,i,cnt,ans=1;   //ans初始赋为1,因为与坐标轴上有4个整点 
inline void read(int &x)  //快读 
{
	short negative=1;
    x=0;
    char c=getchar();
    while(c<'0' || c>'9')
    {
    	if(c=='-')
			negative=-1;
		c=getchar();
	}
    while(c>='0' && c<='9')
        x=(x<<3)+(x<<1)+(c^48),c=getchar();
    x*=negative;
}
inline void print(int x)    //快输 
{
    if (x<0)
        putchar('-'),x=-x;
    if (x>9)
        print(x/10);
    putchar(x%10+'0');
}
signed main(void)
{
	read(n);
	for (i=2;i<=ceil(sqrt(n));i++)   //因式分解,O(sqrt(n)) 
		if (!(n%i))
		{
			if (i%4==1)      //如果i是个模4等于1的质数
			{
				cnt=0;
				while (!(n%i))
					cnt++,n/=i;    //计算指数 
				ans*=(2*cnt+1);    //更新答案 
			}
			while (!(n%i))    //把多余的除掉 
				n/=i;
		}
	if (n!=1 && n%4==1)    //如果n是个模4等于1的质数 
		ans*=3;
	print(4*ans);       //记得乘4 
	return 0;
} 
```

---

## 作者：Jayun (赞：2)

# 题目大意：

求一个给定的圆 $(x^2+y^2=r^2)$，在圆周上有多少个点的坐标是整数。

# 正文：

**声明：** 此方法概括（转）自 3b1b 的[视频](https://www.bilibili.com/video/av12131743/)。

如果我们直接照着题目给出的勾股定理枚举，最优解的时间复杂度似乎就只有 $O(r)$，可 $r$ 达到二十亿，这方法觉得行不通。

> 数学里比较常见的是，当你看到和二维平面有关的问题时，就把这个平面看成全体复数的集合，再看问题或许会有意外收获
> ——3blue1brown

up主给我的启示很有用。当在半径是 $5$ 的圆周上，有一个整点的坐标是 $(x,y)$，那么将二维平面转换成复平面，那个整点也跟着转换成一个复数 $Z=x+yi$。

![图1](https://s1.ax1x.com/2020/07/19/UWcDfg.png)

（图中 $Z=3+4i$）

那么半径 $\begin{aligned}r & = \overrightarrow{AB} \\ & = \sqrt{x^2+y^2} \\ & = (x+yi)(x-yi)\end{aligned}$。这样问题就可以转为分解质因数。

而所有满足这样的整数就是高斯整数。问题就是求有多少个高斯整数能满足其自身与其复共轭的积是圆的半径。我们可以通过分解质因数的方式求出高斯整数的数目。如质数 $5$，它能分解成一个高斯整数 $(2+i)$。但只有模四余一的质数才会对答案有贡献，如质数 $7$，不能分解质数。

# 代码：

```cpp
int main()
{
	scanf ("%lld", &r);
	prime(100000);
	for (int i = 1; i <= cnt; i++)
	{
		int num = 0;
		for (; r % pri[i] == 0;r/=pri[i],num++);
		if (pri[i] % 4 == 1) ans *= num * 2 + 1ll;  //每个质数的贡献，乘2是因为视频里是根号r，这里是r，质因数翻倍
	}
	if(r > 1 && r % 4 == 1)ans *= 3;  //当半径模四余一的特例
	printf("%lld", ans * 4ll); //复数及其复共轭皆可乘虚数i，一共四种
	return 0;
}
```


---

## 作者：azihmst (赞：2)

https://www.bilibili.com/video/av12131743/

在做这道题却毫无头绪的可以看看，但不过看完就不需要看我的题解了。

构建平面直角坐标系。

依照圆的特性，圆心到圆周长上的一点的距离相等。

那么，对于圆上的任意一点（a,b）a^2+b^2=r^2;

就转化成了分解平方和的问题。

举个例子

------------
5^2=5^2+0^2=3^2+4^2=4^2+3^2;

事实上，共有4*3=12种点满足条件。


------------
那么现在，显然数据范围n<=2000 000 000过大。

最好把数据简化一下。


------------
还是5的这个例子。

如果是10^2的话

显然，有三个。

那么可以看出：

2对奇数没有影响，


------------
那么接下来我们要解决的，只有其他质数的问题了。

分解一下：

3，无

5,2

7，无

11，无

13,2


------------
对于除以4余1的质数来说，其数量=指数+1

对于除以4余3的质数来说，其数量与指数数量有关，若为奇数，总数为0，else，不变。


------------
算法=质因数分解


------------
求审核通过


---

## 作者：liaohaoping (赞：2)

表示是自己打表找规律水过的（大神请无视）。

规律1：若n为质数，那么模4等于1的整点个数为12，不为1的整点个数为4

规律2：若n不为质数，p为n的质因数之一，且满足n%(p^i)=0的i取最大值。如果半径为p的整点个数为4，则半径为n/(p^i)的整点个数与半径为n的整点个数相同，如果半径为p的整点个数为12（p为质数，由规律1可见，只有4与12的情况），则半径为n的整点个数是半径为n/(p^i)的整点个数的i·2-1倍。

找到规律之后，做法也很明确了，若n为质数，答案可直接得出，若不为质数，答案可通过求半径为其质因数之一的整点个数间接得出，很明显是递归。

但是，瞄了一眼数据范围很明显会超时，怎么办呢？

拨了一下计算器，sqrt(2000000000)≈44721，由于要求质因数（为了省时间，我们找的是最小的质因数），前44721的利用频率较大，所以对于n<=50000可用记忆化搜索，另外在一开始提前用线性筛筛出前50000的质数即可。

```cpp
#include <cstdio>
#include <cmath>
#include <cstring>
using namespace std;
int max,pr,prime[50010],f[50010];
bool v[20000100];
inline int read()
{
    int x=0,w=0;char ch=getchar();
    while(ch<'0'||ch>'9')w|=ch=='-',ch=getchar();
    while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return w?-x:x;
}
inline void write(int x)
{
    if(x<0)putchar('-'),x=-x;
    if(x>9)write(x/10);
    putchar(x%10+48);
}
inline void getprime()
{
    register int i,j;
    for(i=2;pr<=max;++i)
    {
        if(v[i])prime[++pr]=i;
        for(j=1;j<=pr&&i*prime[j]<=20000000;++j)
        {
            v[i*prime[j]]=0;
            if(!(i%prime[j]))break;
        }
    }
}
inline int findpr(int x)
{
    int p=x;
    for(register int i=1;i<=pr&&prime[i]<x;++i)
    {
        if(!(x%prime[i])){p=prime[i];break;}
    }
    return p;
}
inline int getans(int x)
{
    if(x<=50000&&f[x])return f[x];
    int p=findpr(x);
    if(p==x)
    {
        if(((x>>1)&1)||x==2){if(x<=50000)f[x]=4;return 4;}
        if(x<=50000)f[x]=12;return 12;
    }
    else
    {
        int o=getans(p);register int pp,i;
        for(pp=p,i=1;!(x%pp);pp*=p,i+=2);
        pp/=p;int q=getans(x/pp);
        if(o==4){if(x<=50000)f[x]=q;return q;}
        else{if(x<=50000)f[x]=q*i;return q*i;}
    }
}
int main()
{
    memset(v,1,sizeof(v));
    int n=read();
    max=sqrt(n);getprime();
    f[1]=4;write(getans(n));
    return 0;
}
```

---

## 作者：hanzhongtlx (赞：1)

## [可能更好的阅读体验](https://www.cnblogs.com/tlx-blog/p/13202781.html)

题目链接：这个咋做？[P2508 [HAOI2008]圆上的整点](https://www.luogu.com.cn/problem/P2508)    

看过一次视频：[Link](https://www.bilibili.com/video/av12131743/)  

然而人老了，就忘了，今天复习了一下，记一下，防止再忘一次。   

还有，别问我原理是啥。

$ps:$ 一下说的所有“圆”都指圆心为原点的圆。

## $Part.1$   
质因数分解，每个数都有一个唯一分解式，这是数论的基础。  

$$n=\prod\limits p_i^{k_i}$$    

我们把实数分解推广到复数系。   

高斯整数：实部与虚部都是整数的负数 ($a+bi,a,b\in Z$)  

举个栗子：   

$$25=(3+4i)(3-4i)$$   

就是对 $25$ 在负数系中分解的一种情况。   
对应在坐标平面，半径为 $25$ 的圆上就有 $(3,4),(3,-4)$ 这两个点。   

如何找到所有的分解呢？  

我们先把圆的半径 $\sqrt{n}$ 进行实数内的质因数分解。  

我们以 $\sqrt{25}=5$ 为例。  

$$25=5×5$$  

然后把 $5$ 分解。  

分解式要注意同一个素数只用一种分解方法。

$$25=5×5=(1+2i)(1-2i)(1+2i)(1-2i)$$      

这是我们把 $25$ 的四个复因子分为两组，并且使得两组中都共轭的一一对应。   

我们假设左面那一组为主导组，主导组不同的就定义为不同的分配方法。

我们于是乎就有三种分配方法：  

$1.\{1+2i,1+2i\}\&\{1-2i,1-2i\}$  
$2.\{1+2i,1-2i\}\&\{1-2i,1+2i\}$  
$3.\{1-2i,1-2i\}\&\{1+2i,1+2i\}$   

我们可以尝试计算每一种方法中两组的积，所得的负数互为共轭复数。   

比如第一组中两组乘积分解为 $-3+4i,-3-4i$。 
  
这时候，我们发现 $(-3,4)$ 和 $(-3,-4)$ 正是半径为 $\sqrt{25}$ 的圆上的整点坐标。   

不过我们只取主导组中的，因为之后可能会重复计算......

这时候我们只找到了圆上的三个整点（主导组）。  

但是复数系上的分解不是唯一的。   

比如 $5=(2+i)(2-i),5=(-1+2i)(-1-2i),(-2+i)(-2-i)$  

这些都是由其中一对乘上  $-1,i,-i$ 而得到的。   
每一组又能得到三个整点，这时候我们就输完了，即半径为 $\sqrt{25}$ 的圆上有 $4×3=12$ 个整点。  

或者说有 $12$ 个整数数对 $(a,b)$ 满足 $a^2+b^2=25$。  

## $Part.2$ 
当你兴冲冲的去尝试半径为 $\sqrt{15}$ 的圆上有几个整点时，你发现 $3$ 怎么分解啊？  

答案是没法分解。  

这也就意味着并没有分配方式满足两组一一对应共轭，也就是说没有整点在半径为 $\sqrt{15}$ 的圆上。
 
我们再尝试 $\sqrt{10}=2×5$。   

显然， $2$ 的一种分配方解是 $(1+i)(1-i)$  
那样会不会增加一种分配方式呢？  

答案是否定的，因为 $(1+i)$ 与 $1-i$ 本身就存在着乘 $i$ 的关系，所以将 $(1+i)$ 和 $(1-i)$ 换位再乘上 $4$ 会增加数目，所以只有和 $5$ 分配方式数相同的数目即为 $4$。  

这个地方不懂了要手玩啊。   

当然在 $3$ 的次数为偶数时，可以将次数的一半分配到两个不同的组，同时调换位置也不能改变最后乘出来的结果，所以答案为剩余部分的方案数。  

也就是说 $\sqrt{N}=2^{100}×3^{93}×7$ 的整点数为 $0$,而 $\sqrt{N}=2^{100}×3^{92}×7$ 的整点数为 $8$ 种。   

经过探究，我们发现（~~并没有发现，其实是结论~~）对于一个素数，当他为 $\bmod 4=3$ 的数时，不能分解为两个虚数。  

当他 $\bmod 4=1$ 时，可以分解为不被乘 $-1,i,-i$ 干扰的两个虚数。  

当他为 $2$ 时，会被干扰，对答案无贡献。   

我们容易发现规律：  

对于一个数 $N$ ,把他的质因子分为三组 $S_1,S_2,S_3$，分别对应上面那两种情况，最后的答案 
$$ans=(\prod_{p_i\in S_1}1[2|k_i])(\prod_{p_i \in S_2} (k_i+1))(\prod_{p_i\in S3}1)=(\prod_{p_i\in S_1}1[2|k_i])(\prod_{p_i \in S_2} (k_i+1))$$  

这玩意已经能 $\mathcal O(\sqrt{N})$ 了。  

核心代码：  

```
ll ans=1ll;
ll cnt=0;
ll lst=0;

ll work(ll n)
{
	for(int i=2;1ll*i*i<=n;i++)
	{
		if(n%i==0)
		{
			if(lst)
			{
				if(lst%4==3&&cnt%2==1) return 0;
				else if(lst%4==1) ans=ans*(cnt+1);
			}
			lst=i,cnt=1ll,n/=i;
			while(n%i==0) cnt++,n/=i; 
		}
	}
	if(lst)
	{
		if(lst%4==3&&cnt%2==1) return 0;
		else if(lst%4==1) ans=ans*(cnt+1);
	}
	if(n!=1)
	{
		if(n%4==3) return 0;
		else if(n%4==1) ans*=2;
	}
	return ans;
}
```

## $Part.3$  
能不能更深呢？   

我们记录一个函数 $\chi(n)$。  

定义：  
$$\chi(x)=\begin{cases}1&x\bmod4=1\\-1&x\bmod 4=3\\0&x\bmod 2=0\end{cases}$$
 
他是个完全积性函数
 
那么: 

$$ans=4\prod\sum_{j=0}^{k_i}\chi(p_i^j)$$    

当 $p_i=2$ 的时候后，除了 $\chi(2^0)=1$,其他都是 $0$。  
加起来还是 $1$，就没有贡献。  

当 $p_i=4n+3$ 时，次数为偶和为 $1$,否则为 $0$ 。  
以后可能会证......  

当 $p_i=4n+1$ 时，为 $k_i+1$  

由于 $p_i^j$ 不同的组合得到其所有因数，又因为这个函数是完全积性函数，我们得到：  

$$ans=4\sum\limits_{d|n} \chi(d)$$  

这个东西也是 $\mathcal O(\sqrt{N})$ 的。  

核心代码：
```
ll ans=0;

inline int chi(ll x){if(x%2==0) return 0;else return (x%4==1)?1:-1;}

ll work(ll n)
{
	for(int i=1;1ll*i*i<=n;i++)
	{
		if(n%i==0&&1ll*i*i!=n) ans=ans+1ll*chi(i)+1ll*chi(n/i);
		else if(n%i==0) ans=ans+1ll*chi(i);
	}
	return ans;
}
```

这个东西一跑就是上限，所以过不了，只有 $20\;pts$。

那么半径为 $\sqrt{N}$ 的圆中有多少整点呢？   

当然是：   

$$4\sum\limits_{i=1}^n\sum_{d|i}\chi(d)+1$$  

最后加的是圆点，他不过任何一个圆但是在大圆之内。  

按反演的套路化简：  

$$\begin{aligned} 4\sum\limits_{i=1}^n\sum_{d|i}\chi(d)+1&=4\sum_{d=1}^n\chi(d)\left\lfloor\dfrac{n}{d}\right\rfloor+1 \end{aligned}$$  

由于 $\chi(d)$ 很有规律，所以这个也可以 $O(\sqrt{N})$ 算。   

## $Part.4$  

我们考虑一个圆中的整点个数大概是：  

$$\pi R^2$$  

当 $n$ 够大的时候，我们可以将 $\left\lfloor\dfrac{n}{d}\right\rfloor$ 看为 $\dfrac{n}{d}$,同时 $+1$ 可以省去。  

那么：  

$$4\sum\limits_{i=1}^{n}\chi(i)\dfrac{n}{i}=\pi R^2$$  

同时这里的 $n$ 不就是 $R^2$ 吗？  
即：  

$$4R^2\sum\limits_{i=1}^{R^2}\chi(i)\dfrac{1}{i}=\pi R^2$$  

我们手玩一下发现后面这个东西不就是：  

$$4R^2(\dfrac{1}{1}-\dfrac{1}{3}+\dfrac{1}{5}-\dfrac{1}{7}+......)$$  

整理一下得到：  

$$\sum\limits_{i}^{\infty}\dfrac{(-1)^{i+1}}{2i-1}=\dfrac{\pi}{4}$$

---

## 作者：Yyxxxxx (赞：1)

同各位大佬一样，安利一下。

# [3Blue1Brown的视频](https://www.bilibili.com/video/av12131743/)
### 题意
- 已经很明朗了。
- 求在平面直角坐标系中，原点为圆心，$R$为半径的圆上的格点数量。
- 格点：坐标都为整数的点。

------------
接下来我就按视频思路梳理一下。

### 探索
我们可以先在图上画出半径为$\sqrt{r}$，的圆，并求出这些圆上的格点数量$Q$。

$r:0,1,2,3,4,5,6,7,8,9,10$  
$Q:1,4,4,0,4,8,0,0,4,4,8$

~~假~~结论：$Q$是$4$的倍数。


------------
详细观察一下$R=5$,即$r=25$的情况

![](https://cdn.luogu.com.cn/upload/image_hosting/jdvyqy9t.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

我们会发现，$12$个格点分别为：   
$(3,4),(4,3),(-3,4),(4,-3),(-4,3),(3,-4),(-3,-4),(-4,-3),(5,0),(0,5),(0,-5),(-5,0)$     

#### 平面坐标系转复平面

如题，把平面向量转为复平面；每个点都代表一个复数。   
[（百度百科-复数）](https://baike.baidu.com/item/%E5%A4%8D%E6%95%B0/254365?fr=aladdin)   
那么$(3,4)$就代表复数：$3+4i$   
那么我们会发现其**复共轭**（用$-i$替换原数中的$i$）：$3-4i$和它的乘积即为：

$(3+4i)(3-4i)=3^2-(4i)^2=9-(-1)\times16=25=r$ 

经过计算，发现每个点都满足与其共轭根相乘得$r$。且这一结论可以推广到全部。  
即模相乘，幅角相加。其模相等，为$\sqrt{r}$。 幅角相加得零。易证。  
而这些点满足：$\forall r,a,b;r,a,b\in{\mathbb{Z}},(a+bi)(a-bi)=r$
那么我们称点$a+bi$为**高斯整数**。

且对于每个$4n+1,n\in \mathbb{Z}$都可以分解为两个高斯整数的积，对于每个$4n+3,n\in\mathbb{Z}$都不能分解，因为他们自己就是高斯整数。


------------
由于**算数基本定理**，我们可以对于一个整数分解为唯一形式。

$n=\prod\limits_{i=1}^np_i^{k_i}$,$p_i$是素数。

同样的我们也可以把一个数分解为若干个**高斯素数**相乘。如：
$$25=(2-i)^2(2+i)^2$$

这样子匹配下来（记住，一对共轭根只能分别在两边）：
$$25=(2-i)(2-i)\times(2+i)(2+i)=(3-4i)(3+4i)$$
$$25=(2+i)(2+i)\times(2-i)(2-i)=(3+4i)(3-4i)$$
$$25=(2+i)(2-i)\times(2+i)(2-i)=5\cdot5$$

在原先的情况下，我们可以通过乘上$-1$来得到不同结果。  
同样的我们也可以通过乘上$i,-1,-i$来得到不同结果。如：
$$25=(-1+2i)(2-i)\times(-1-2i)(2+i)=(-4+3i)(-4-3i)$$
这也就是为什么我们当时得出$Q$都是4的倍数这一结论。



------------
#### 如果是$r=375$呢？   
$375=3* 5^3=3(2-i)(2+i)(2-i)(2+i)(2-i)(2+i)$
$3$落单了！！！，而且$3$还是高斯整数，那么该圆不过任一格点。    
我们如果把一个整数$N$质因数分解为如下形式。
$$N=3^3\cdot 5^4\cdot 13^3$$

这里的高斯整数$3$指数是奇数，那么该圆就不能过格点。  
但如果是这样：

$$N=3^4\cdot 5^4\cdot 13^3$$

$5^4$可以分解为$4$对，总共有$5$种分法。  
$13^3$可以分解为$3$对，总共有$4$种分法。  
$3^4$不能分解，只有$1$种分法

所以$Q=5\times4\times1=20$可别忘了刚刚的四种情况。故
$$Q\ne20,Q=20\times4=80$$

#### 如果是$10$呢?

$10=2\cdot5=(1+i)(2-i)\times(1-i)(2-i)$  
$10=2\cdot5=(1-i)(2-i)\times(1+i)(2-i)$  
这步与接下来的乘$-i$  
$10=2\cdot 5=(1+i)(-i)(2-i)\times(1-i)(i)(2-i)=(1-i)(2-i)\times(1+i)(2-i)$   
重复了！！！    
可以得出结论：对于因子$2^k$对结果是没有影响的


------------
### 解法
那么对于本题，我们可以讲半径$R$看作$\sqrt{R^2}$，即$r=R^2$。  
这个时候如果把$R$质因数分解后
$$R=\prod\limits_{i=1}^np_i^{k_i}$$
若有像$3$一样的高斯整数，那就不用考虑高斯整数，也不用考虑偶数，于是只要考虑$mod 4==1$的质因数就行了。
$$Ans=4\cdot\prod\limits_{i=1}^n(2\cdot k_i+1),k_i\%4==1$$

比如$R=325,r=105625$

$R=5^2\cdot13^1,r=5^{2\times2}\cdot13^{1\times2},Ans=4(2\times2+1)(1\times2+1)$

为了跑得快，我们只想把质数枚举至$\sqrt{R}$。  
但是如果这是个质数或是质数的偶数被，那就不会被筛到。  
而此时的分解为$R=p_i^1$，那么$Ans=Ans\times(2\times1+1)$

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int pri[100005],cnt;
bool used[500005];
int main()
{
    int r;
    long long ans=1;
    scanf("%d",&r);
    int n=sqrt(r);
	for(int i=2;i<=n;i++)//欧拉筛素数
	{
		if(!used[i]) pri[++cnt]=i;
		for(int j=1;j<=cnt&&i*pri[j]<=n;j++)
		{
			used[i*pri[j]]=1;
			if(!(i%pri[j])) break;
		}
	}
    for(int i=1;i<=cnt;i++)//质因数分解
    {
        int sum=0;
        while(r%pri[i]==0)
        {
            sum++;
            r/=pri[i];
        }
        if(pri[i]%4==1)ans*=(sum*2+1);//要满足pi%4==1才能贡献答案
    }
    if(r>1&&r%4==1)ans*=3;//特例
    printf("%lld",ans*4);//别忘了乘四
    system("pause");
    return 0;
}
```
### 后话
视频的后面也提供了一些，可以算是思考吧。

新定义函数$\chi(x)$

$$\chi(x)=\begin{cases}
1&x=4n+1,n\in{\mathbb{Z}}\\
-1&x=4n+3,n\in{\mathbb{Z}}\\
0&x=2n,n\in\mathbb{Z}
\end{cases}$$

这是一个积性函数，~~但是我并不会证明~~。

举个例子，如果一个数$N=2^2\cdot3^4\cdot5^3$

$$Ans=4(1)(1)(3+1)=16$$
$Ans=4[(\chi(1)+\chi(2^1)+\chi(2^2))+(\chi(1)+\chi(3^1)+\chi(3^2)+\chi(3^3)+\chi(3^4))+(\chi(1)+\chi(5^1)+\chi(5^2)+\chi(5^3))]$
$=4(1+0+0)(1-1+1-1+1)(1+1+1+1)=16$

这种方法也能算出来。

**这种方法可以看出什么？**

  把$45$用这种方法拆开看看：
  
  $45=3^2\cdot5^1$
  
  $Ans=4(\chi(1)+\chi(3^1)+\chi(3^2))(\chi(1)+\chi(5^1))$  
  $Ans=4(\chi(1)\chi(1)+\chi(1)\chi(3)+\chi(1)\chi(5)+\chi(3)\chi(3)+\chi(3)\chi(5)+\chi(9)\chi(5))$
  
 因为这是一个积性函数，那我们就：
 
 $Ans=4(\chi(1)+\chi(3)+\chi(5)+\chi(9)+\chi(15)+\chi(45))$
 
 里面的自变量取值，刚好就是$45$的所有因数。
 
 ### 神奇吗？
  
  
  
  
  
  
  
  
  
  
















---

## 作者：xryjr233 (赞：1)

首先要看懂[这个视频](https://www.bilibili.com/video/av12131743/)

然后这题已经做完了。

要求半径为$r$的圆上的整点数量,就是求半径为$\sqrt{r^2}$的圆上的整点数量。

设$r=\prod_{i=1}^n p_i^{k_i}(p_i\in Prime)$

则$r^2=\prod_{i=1}^n p_i^{2k_i}(p_i\in Prime)$

根据视频内容,我们知道当$p_i=4n+1(n\in \mathbb{N^+})$时,答案会乘上$2k_i+1$;否则不会产生任何贡献(由于$2k_i$是偶数,所以即使$4n+3$型素数也不会影响答案)。

对$n$分解质因数即可。

时间复杂度$O(\sqrt{n})$。

code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,p[100010],sz,tot,ans=1;
int main(){
	freopen("1041.in","r",stdin);
	freopen("1041.out","w",stdout);
	scanf("%lld",&n);
	m=sqrt(n);
	for(int i=2;i<=m;i++){//小于等于sqrt(n)的线性筛
		if(!p[i])p[++sz]=i;
		for(int j=1;j<=sz;j++){
			if(p[j]*i>m)break;
			p[p[j]*i]=1;
			if(i%p[j]==0)break;
		}
	}
	for(int i=1,tot=0;i<=sz;tot=0,i++){
		while(n%p[i]==0)tot++,n/=p[i];
		if((p[i]-1)%4==0)ans*=2*tot+1;
	}
	if(n!=1&&(n-1)%4==0)ans*=3;//大于sqrt(n)的质因子最多只有一个
	printf("%d",4*ans);
	return 0;
}
```

---

## 作者：Fading (赞：1)

这个推导过程比较无脑套路，不过比较详细就是了。

推了$20min$，码了$10min$，调了$1h……$

第一反应是解方程，就是求$x^2+y^2=r^2$的正整数解，答案就是$\text{解数}\times 4+4$。

然后~~惯性思维~~就想到了数学里勾股方程的解法（雾

$$x^2+y^2=r^2$$

设 
$$\text{}r^2=(m+n)^2,x^2=(m-n)^2,y^2=4mn(m>n)$$

感性理解一下吧$……$加起来正好等的

$$∴y=\sqrt{4mn}=2\sqrt{mn}$$

$m,n$不好搞，我们把它们搞成互质的。

设
$$\text{}gcd(m,n)=d,m=Md,n=Nd,gcd(M,N)=1$$

$$∴y=2d\sqrt{MN}$$

$$∵gcd(M,N)=1$$

$$∴\text{M、N为完全平方数}$$
设

$$\text{}M=m'^2,N=n'^2$$

$$r=m+n=d(n'^2+m'^2)$$

$$x=m-n=d(m'^2-n'^2)$$

$$y=2dm'n'$$

好像什么都没有呀$……$其实我们观察$r=m+n=d(n'^2+m'^2),$就可以发现$d|r,$

然后就可以枚举$r$的约数$d$了，这样$n'^2+m'^2$也知道了，就是$\frac rd$

我们再暴力枚举$n'^2$，就可以算出$m'^2$了。

~~由于我们是搞电脑的，~~我们可以判断$m'$是否是整数，然后就可以判断$n'$是否合法，再判断$gcd(m',n')$是否为一，这道题好像就做完了$!$

真的吗？？？

当然你需要判重！！！

我调试了很久，后来一气之下写了一个哈希函数，用$map$判重$……$

所以我觉得这篇题解仅供参考~~打就算了~~

对了你问复杂度？$O(\sum_{d|r}^{}\sqrt{d}log{n})$吧。~~能过就行~~

下面放上我千疮百孔的代码：

```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll ans,r;
ll gcd(ll a,ll b){
    return b?gcd(b,a%b):a;
}
map<ll,ll> qwq;
inline void solve(ll d){
    int N=r/d;
    //cout<<N<<endl;
    for (int i=1;(ll)i*i<N;i++){
        ll j=N-i*i,sqr=sqrt(j);
        if (sqr*sqr==j&&gcd(i*i,j)==1&&i*i!=j){//判断可不可行
            ll x=d*(i*i-j),y=2*d*(i*sqr);
            if (i*i<j) swap(x,y),y=y*-1;
            if (qwq[x*1000000000+y]) continue;//哈希判重
            ans++; qwq[x*1000000000+y]=1;// qwq[y*1000000000+x]=1;
        }
    }
}
int main(){
    cin>>r;
    for (ll i=1;i*i<=r;i++){//枚举约数
        if (r%i) continue;
        if ((ll)i*i==r) solve(i);
        else solve(i),solve(r/i); 
    }
    cout<<4*ans+4<<endl;
}
```

---

## 作者：queuDU (赞：1)

从hzwer上提炼（其实和搬运没什么区别）了题解

没有B站的那个优，不过A是没问题的

设点(X,Y)在圆上，按照勾股可知：

X^2+Y^2=R^2

Y^2=(R+X)(R-X)

Y=sqrt((R+X)(R-X))

令d=gcd((R+X),(R-X)),A=(R-X)/d,B=(R+X)/d

可知gcd(A,B)=1

代回，得Y^2=d^2\*A\*B

知A\*B为完全平方数 由上两行可得出结论 A,B均为完全平方数

设A=a^2,B=b^2

a^2=(R-X)/d,b^2=(R+X)/d

两式相加，可知 a^2+b^2=2R/d 故d为2R一约数

而d的数量则由2R的质因数确定


枚举步骤：

预设a<b


d:[1,sqrt(2R)]

情况1:d=2R/d  a:[1,sqrt(2R/2d)](由a<b推出) 算出对应b 计入ans条件：a!=b且a,b互质

情况2:d=d     a:[1,sqrt(d/2)]  (由a<b推出) 算出对应b 计入ans条件：a!=b且a,b互质


···




```cpp
#include <iostream>
#include <cmath>
using namespace std;
long long r,ans;
long long sqrta,sqrtb,sqrtc;
bool isprime(int a,int b)
{
    if(a%b==0)
    {
        if(b==1)
            return true;
        return false;
    }
    return isprime(b,a%b);
}
bool judge(int a,int b)
{
    if(a==b)
        return false;
    return isprime(a,b);
}
int main()
{
    int b;
    scanf("%lld",&r);
    sqrta=(long long)sqrt(r*2+0.0);
    for(int d=1;d<=sqrta;d++)
    {
        if((2*r)%d!=0)
            continue;
        sqrtb=(long long)sqrt((2*r+0.0)/(2*d));
        sqrtc=(long long)sqrt(d/2+0.0);
        for(int a=1;a<=sqrtb;a++)
        {
            b=(int)sqrt((2*r/d)-(a*a)+0.0);
            if(sqrt((2*r/d)-(a*a)+0.0)==b+0.0 && judge(a,b))
                ans++;
        }
        if(d!=(2*r)/d)
            for(int a=1;a<=sqrtc;a++)
            {
                b=(int)sqrt(d-(a*a)+0.0);
                if(sqrt(d-(a*a)+0.0)==b+0.0 && judge(a,b))
                    ans++;
            }
    }
    printf("%lld\n",ans*4+4);
    return 0;
}
```
···

就因为A了这道题被隔壁的n位神犇嘲讽了不知道多少次。。。伤心


---

## 作者：Infiltrator (赞：0)



# 勾股数组
假设我们已经求得$x^2+y^2=r^2$的所有正整数解$ans$  

那么我们很容易就可以发现每个象限都有到远点距离等于正整数解的这么多点  

再算上坐标轴上一定会存在的4个点,那么答案就是$ans*4+4$  

现在考虑如何快速求出$x^2+y^2=r^2$的所有正整数解  

这时我们引入勾股方程的概念  

勾股方程即形如$a^2+b^2=c^2$的方程  

本题中已知$c^2$的值  

一个事实是勾股方程的所有正整数解都可以被表示为下图的形式

$$1.1:a=\frac{d*(u^2-v^2)}{2},b=d*u*v,c=\frac{d*(u^2+v^2)}{2}(gcd(u,v)=1)$$  

也就是说每个勾股数组都可以由下面的式子同时乘一个数变换过来  

$$1.2:a=\frac{u^2-v^2}{2},b=u*v,c=\frac{u^2+v^2}{2}(gcd(u,v)=1)$$  

这是为什么呢，考虑所有的勾股方程的整数解都是一个勾股数组，那么肯定可以被表示成如下的形式  

$$1.3:a=u^2-v^2,b=4*u*v,c=u^2+v^2$$  

所以假如式子$1.2$中的$a,b,c$的$gcd=1$，那么我们就可以用它不重不漏的表示出所有的勾股数组  

证明左转[洛谷日报-勾股数组](https://www.luogu.org/blog/lhc/TheStoryOfPythagoreanTriples)  

既然$1.1$可以不重不漏的表示出所有的解，那么我们就可以枚举$d$求出答案  

具体步骤如下：

>首先枚举$d\mid2*r$,那么$u^2+v^2=2*r/d$  
>接下来枚举$u$,验证$u$是否合法(如果存在$u^2+v^2=2*r/d$并且$gcd(u,v)=1$则合法)，如果合法答案加一  

# CODE  
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
using namespace std;
#define ll long long
ll ans=0,r;
ll gcd(ll a,ll b)
{
    return !b?a:gcd(b,a%b);
}
bool check(ll u,ll V)
{
    int v=(ll)(sqrt(V));
    if(V==v*v)return gcd(u,v)==1;
    return 0;
}
ll calc(ll x)
{
    ll tmp=0;
    for(ll u=1;u*u*2<x;u++)
        tmp+=check(u,x-u*u);
    return tmp;
}
int main()
{
    scanf("%lld",&r);
    for(ll d=1;d*d<=2*r;d++)
        if(2*r%d==0)
            ans+=calc(2*r/d)+(d*d==2*r?0:calc(d));
    printf("%lld\n",ans*4+4);
    return 0;
}
```

---

## 作者：Owen_codeisking (赞：0)

看到其他题解有些含糊……我来发一篇好了

$assume\ x>0,y>0$

$x^2+y^2=r^2$

$y^2=(r-x)(r+x)$

设 $r-x=ud,r+x=vd,(u,v)=1$

$y^2=d^2uv$

那么 $u,v$ 一定是完全平方数

设 $u=s^2,v=t^2,(s,t)=1$

$2r=(u+v)d\Longrightarrow (s^2+t^2)d$

$x=\frac{t^2-s^2}{2}d$

$y=dst$

然后就枚举 $2r$ 的质因数，对于每个质因数 $O(\sqrt{n})$ 枚举乘上 $O(\log n)$ 求 $gcd$，时间复杂度约为 $O(\sum_{d|n}\sqrt{d}\log r)$

$Code\ Below:$

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll r,ans;

int main()
{
    scanf("%lld",&r);
    register ll i,d,s,t,x,y;
    for(i=1;i*i<=2*r;i++){
    	if(2*r%i==0){
    		d=i;
    		for(s=1;s*s<=2*r/d;s++){
    			t=sqrt(2*r/d-s*s);
    			if(s*s+t*t==2*r/d&&__gcd(s,t)==1){//s,t必须互质
    				x=(t*t-s*s)/2*d;y=d*s*t;
    				if(x>0&&y>0&&x*x+y*y==r*r) ans+=2;//x,y可以互换
				}
			}
			if(i*i!=r){
				d=2*r/i;
				for(s=1;s*s<=2*r/d;s++){
					t=sqrt(2*r/d-s*s);
					if(s*s+t*t==2*r/d&&__gcd(s,t)==1){
						x=(t*t-s*s)/2*d;y=d*s*t;
						if(x>0&&y>0&&x*x+y*y==r*r) ans+=2;
					}
				}
			}
		}
	}
	printf("%lld\n",(ans+1)*4);
    return 0;
}
```

---

## 作者：jamespaul (赞：0)

【分析】：


样例图示：



[ pic=1697]

首先,最暴力的算法显而易见：枚举x轴上的每个点，带入圆的方程，检查是否算出的值是否为整点，这样的枚举量为2\*N，显然过不了全点。


然后想数学方法。





[ pic=1698]

有了上面的推理，那么实现的方法为：


枚举d∈[1,sqrt(2R)]，然后根据上述推理可知：必先判d是否为2R的一约数。


此时d为2R的约数有两种情况：d=d或d=2R/d。


第一种情况：d=2R/d。枚举a∈[1,sqrt(2R/2d)] <由2\*a\*a < 2\*R/d转变来>，算出对应的b=sqrt(2R/d-a^2)，检查是否此时的A,B满足：A≠B且A,B互质 <根据上面的推理可知必需满足此条件>，若是就将答案加1


第二种情况：d=d。枚举a∈[1,sqrt(d/2)] <由2\*a\*a < d转变来>，算出对应的b=sqrt(d-a^2)，检查是否此时的A,B满足：A≠B且A,B互质 <根据上面的推理可知必需满足此条件>，若是就将答案加1


因为这样只算出了第一象限的情况<上面枚举时均是从1开始枚举>，根据圆的对称性，其他象限的整点数与第一象限中的整点数相同，最后，在象限轴上的4个整点未算，加上即可，那么最后答案为ans=4\*第一象限整点数+4


【时间复杂度分析】：


枚举d：O(sqrt(2R)),然后两次枚举a：O(sqrt(d/2))+O(sqrt(R/d))，求最大公约数：O(logN)


---


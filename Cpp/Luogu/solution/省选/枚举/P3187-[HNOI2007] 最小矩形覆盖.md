# [HNOI2007] 最小矩形覆盖

## 题目描述

给定一些点的坐标，求能够覆盖所有点的最小面积的矩形，输出所求矩形的面积和四个顶点坐标。

## 说明/提示

$3 \le n \le 50000$，坐标范围 $\in [0,10]$。保证覆盖所有点所需要的最小矩形面积至少是 $0.1$。

如果你的矩形面积为 $S'$，正确答案为 $S$，那么当 $\frac{|S'-S|}{\max\{1,S\}}<10^{-4}$，且所有点满足在矩形内或者到矩形的距离 $<10^{-4}$ 时，你的答案会被判定为正确（你可以忽略这段话，简而言之你的答案只要不是有特别大的精度误差就可以通过）。

感谢 @intruder 提供题目简述


## 样例 #1

### 输入

```
6
1.0 3.00000
1 4.00000
2.0000 1
3 0.0000
3.00000 6
6.0 3.0```

### 输出

```
18.00000
3.00000 0.00000
6.00000 3.00000
3.00000 6.00000
0.00000 3.00000```

# 题解

## 作者：E_huan (赞：18)


补充重要性质的证明，以及给出目前最优解第一的代码实现（完全没有刻意卡常）（带注释）。

------------

大部分内容题解区已有题解已经讲的十分清楚了，但是没有对于“最优情况下至少有一条矩形边与凸包的边重合”的证明，我在写这道题的时候感到比较困惑且题解区没有给出证明，解决这个困惑后决定发题解补充：

首先矩形的边必定与凸包的点相交，否则可以将边向凸包平移调整直到与第一个凸包上的点相交，仍然满足所有点都在矩形内且答案变小。将凸包落在矩形对边的点连接（如下图），后续见下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/zbbhwe0d.png)


发现自己的代码目前是最优解第一，所以放一下代码实现以供参考（有注释）：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100010;
const double eps=1e-10;
int n;
inline bool same(double x,double y) { return fabs(x-y)<eps;}
struct Point {
    double x,y;
    inline bool operator<(const Point &t)const {
        if(!same(x,t.x)) return x<t.x;
        return y<t.y;
    }
    inline Point operator+(const Point &t)const {return {x+t.x,y+t.y};}
    inline Point operator-(const Point &t)const {return {x-t.x,y-t.y};} 
    inline Point operator*(const double &t)const {return {x*t,y*t};}//数乘
    inline double operator*(const Point &t)const {return x*t.y-y*t.x;} //叉积 
    inline double operator^(const Point &t)const {return x*t.x+y*t.y;} //点积  
}p[N],tmp[N];
struct Line {  Point s,v;};//点向式结构体
inline Point inter(Line l1,Line l2) {
    Point t1=l1.s+l1.v;
    double s1=l2.v*(l1.s-l2.s);
    double s2=(t1-l2.s)*l2.v;
    double t=s1/(s1+s2);
    return l1.s+l1.v*t;
} //求直线交点
double ans=1e18;
Point a[4]; //答案矩形4个顶点
inline Point get(Point p) {
    p.x=(fabs(p.x)<eps)?0:p.x;
    p.y=(fabs(p.y)<eps)?0:p.y;
    return p;
} //=0可能会输出0/-0 所以要判
inline void update(Line l1,Line l2,Line l3,Line l4) {
    Point b[4]={inter(l1,l2),inter(l2,l3),inter(l3,l4),inter(l4,l1)};
    double now=fabs(b[0]*b[1]+b[1]*b[2]+b[2]*b[3]+b[3]*b[0])/2;
    if(ans>now) {
        ans=now;
        for(int i=0;i<4;i++) a[i]=get(b[i]);
    }
} // 求4条直线围成的4边形面积 更新答案 注意直线顺序
inline Point rotate(Point p) { return {-p.y,p.x};} // 把p旋转90度
inline void getline(Line l1,Point p2,Point p3,Point p4) {
    Point _v=rotate(l1.v);
    Line l2={p2,_v},l3={p3,l1.v},l4={p4,_v};
    update(l1,l2,l3,l4);
} //确定一条直线和另外3个点 求出围成矩形的4条直线并更新答案
int stk[N],top;
void tb() {
    sort(p+1,p+n+1);
    for(int i=1;i<=n;i++) {
        while(top>1&&((p[i]-p[stk[top-1]])*(p[stk[top]]-p[stk[top-1]]))<eps) top--;
        stk[++top]=i;
    }
    int limit=top;
    for(int i=n;i>=1;i--) {
        while(top>limit&&((p[i]-p[stk[top-1]])*(p[stk[top]]-p[stk[top-1]]))<eps) top--;
        stk[++top]=i;
    }
    for(int i=1;i<=top;i++) tmp[i]=p[stk[i]];
    for(int i=1;i<=top;i++) p[i]=tmp[i];
    n=top-1;
}
inline double val(Point a,Point b,Point c) {
    return fabs((a-b)*(a-c));
} //三角形面积
void work() {
    for(int i=1,j=2,x=2,y=2;i<=n;i++) { //i x j y
        while(val(p[i],p[i+1],p[j])<val(p[i],p[i+1],p[j%n+1])) j=j%n+1;
        y=max(y,j);
        while(x!=j&&((p[i+1]-p[i])^(p[x+1]-p[x]))>-eps) x=x%n+1; //>=0 (锐角/直角) <=> >-eps
        while(y!=i&&((p[i+1]-p[i])^(p[y+1]-p[y]))<eps) y=y%n+1;
        getline(Line{p[i],p[i+1]-p[i]},p[x],p[j],p[y]);
    }
}
int main() {
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%lf%lf",&p[i].x,&p[i].y);
    tb();
    work();
    printf("%.5lf\n",ans);
    reverse(a,a+4);// a 本身是顺时针的
    int pos=0;
    for(int i=1;i<4;i++)
        if(a[pos].y>a[i].y)
            pos=i;
    for(int i=pos;i<4;i++) printf("%.5lf %.5lf\n",a[i].x,a[i].y);
    for(int i=0;i<pos;i++) printf("%.5lf %.5lf\n",a[i].x,a[i].y);
    return 0;
}
```

---

## 作者：mrclr (赞：18)

这道题我从昨天晚上5点做到今天下午3点半……差点就疯了。

真是一道计算几何好题呀！？

刚开始我以为矩形与坐标轴平行，感觉省选题竟然这么水。但是看完样例后发现我错了……

首先都知道要求凸包。写代码的时候一定要非常谨慎。对于重合或共线的点都要从栈中弹去，否则在后面的求矩形面积的时候会除以$0$，然后就会想我一样$gg$了快$2$个点。

然后，凭直觉能知道矩形的一个边一定和凸包的一条边平行。那么就能想到用旋转卡壳维护矩形的另外三个最值点（不是顶点），即矩形最上点，最右点，最左点。

求最上点，和旋转卡壳板子一样，用叉积求面积就行了。

求最右点，用点积。对于当前直线$AB$和旋转到的点$Ci$，如果$\overrightarrow{AB} * \overrightarrow{C _ i C_{i + 1}} > 0$，就接着往下旋转。

求最左点，和最右点同理。只不过判断条件是$< 0$。而且他的旋转方向和上面相反，所以我又倒着跑了一遍旋转卡壳。

接下来说怎么求面积。
![](https://img2018.cnblogs.com/blog/1284378/201811/1284378-20181122165019575-2113861608.png)

看这个图就好了。

首先矩形的宽很好求，就是$\Delta ABC$以$AB$为底边的高。用叉积求一遍面积然后除以底边长完事。

然后求矩形的底边长。我是把他分成了三部分：令$a$表示$AB$的长度，$b$表示$\overrightarrow{BD}$在$\overrightarrow{AB}$上的投影，$c$表示$\overrightarrow{AE}$在$\overrightarrow{AB}$上的投影，则底边长$l = |a| + |b| + |c|$。

所以面积求完了啦！

最后是怎么求矩形的四个顶点。

沿用上面的字母。

思路是从右下点$G$开始逆时针一次求。

$G = B + \overrightarrow{AB} * \frac{|\overrightarrow{BG}|}{|\overrightarrow{AB}|}$。

接下来求$H$。原来我是这么求的：$H = G + \overrightarrow{GD} * \frac{|\overrightarrow{GH}|}{|\overrightarrow{GD}|}$。

但是会有$G, D$重合的情况。所以就换了种求法，把$\overrightarrow{AB}$顺时针旋转$90$度得到$\overrightarrow{BA'}$，然后$H = G + \overrightarrow{BA'} * (- \frac{|\overrightarrow{GH}|}{|\overrightarrow{BA'}|})$，其中${|\overrightarrow{GH}|}$就是矩形的高，上一问已经求过。

对于$I, G$同理，都是向量旋转加伸长缩短，这里就不讲了。

好像就做完了……

感觉写了一天的题也不怎么难。还是自己菜啊……

需要注意的是这题卡精度，$eps$开到$1e-10$我才过。然后如果$|a| < 1e-5$，直接输出$0.00000$，否则可能会输出$-0.00000$……
```c++
#include<cstdio>
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<cctype>
#include<vector>
#include<stack>
#include<queue>
using namespace std;
#define enter puts("") 
#define space putchar(' ')
#define Mem(a, x) memset(a, x, sizeof(a))
#define rg register
typedef long long ll;
typedef double db;
const int INF = 0x3f3f3f3f;
const db eps = 1e-10;
const int maxn = 5e4 + 5;
inline ll read()
{
  ll ans = 0;
  char ch = getchar(), last = ' ';
  while(!isdigit(ch)) last = ch, ch = getchar();
  while(isdigit(ch)) ans = (ans << 1) + (ans << 3) + ch - '0', ch = getchar();
  if(last == '-') ans = -ans;
  return ans;
}
inline void write(ll x)
{
  if(x < 0) x = -x, putchar('-');
  if(x >= 10) write(x / 10);
  putchar(x % 10 + '0');
}

int n;
struct Point
{
  db x, y; int id;     //id跟题目无关,是为了方便调试用的
  Point operator - (const Point& oth)const
  {
    return (Point){x - oth.x, y - oth.y, 0};
  }
  Point operator + (const Point& oth)const
  {
    return (Point){x + oth.x, y + oth.y, 0};
  }
  db operator * (const Point& oth)const
  {
    return x * oth.y - oth.x * y;
  }
  db operator ^ (const Point& oth)const  //这是点积,不是位运算……
  {
    return x * oth.x + y * oth.y;
  }
  Point operator * (db d)
  {
    return (Point){x * d, y * d, 0};
  }
  friend inline db dis(const Point& A)
  {
    return A.x * A.x + A.y * A.y;
  }
  friend inline Point rot(const Point& A)    //顺时针旋转90度
  {
    return (Point){A.y, -A.x};
  }
}p[maxn], S;

bool cmp(Point& A, Point& B)
{
  db s = (A - S) * (B - S);
  if(fabs(s) > eps) return s > eps;
  return dis(A - S) < dis(B - S) - eps;
}
int st[maxn], top = 0;
void Graham()
{
  int id = 1;
  for(int i = 2; i <= n; ++i)
    if(p[i].x < p[id].x - eps || (fabs(p[i].x - p[id].x) < eps && p[i].y < p[id].y - eps)) id = i;
  if(id != 1) swap(p[id].x, p[1].x), swap(p[id].y, p[1].y), swap(p[id].id, p[1].id);
  S.x = p[1].x, S.y = p[1].y;
  sort(p + 2, p + n + 1, cmp);
  st[++top] = 1;
  for(int i = 2; i <= n; ++i)
    {
      while(top > 1 && (p[st[top]] - p[st[top - 1]]) * (p[i] - p[st[top - 1]]) < eps) top--;
      st[++top] = i;
    }
}

struct Rec
{
  Point R, U, L;
}r[maxn];
db area(Point A, Point B, Point C)
{
  return (B - A) * (C - A);
}
db pho(Point A, Point B, Point C, Point D)
{
  return (B - A) ^ (D - C);
}
inline int nxt(int x)
{
  if(++x > top) x = 1;
  return x;
}
void rota1()
{
  for(int i = 1, j = 3, k = 2; i <= top; ++i)
    {
      while(nxt(j) != i && area(p[st[i]], p[st[i + 1]], p[st[j]]) < area(p[st[i]], p[st[i + 1]], p[st[nxt(j)]]) - eps) j = nxt(j);
      r[i].U = p[st[j]];
      while(nxt(k) != i && pho(p[st[i]],  p[st[i + 1]], p[st[k]], p[st[nxt(k)]]) > eps) k = nxt(k);
      r[i].R = p[st[k]];
    }
}
inline int pre(int x)
{
  x--;
  if(!x) x = top;
  return x;
}
void rota2()   //单独维护最左点
{
  for(int i = top, j = top; i; --i)
    {
      while(pre(j) != i + 1 && pho(p[st[i]], p[st[i + 1]], p[st[j]], p[st[pre(j)]]) < eps) j = pre(j);
      r[i].L = p[st[j]];
    }
}

Point Ans[5];

int main()
{
  n = read();
  for(int i = 1; i <= n; ++i) scanf("%lf%lf", &p[i].x, &p[i].y);
  for(int i = 1; i <= n; ++i) p[i].id = i;
  Graham(); st[top + 1] = st[1];
  rota1(); rota2();
  db ans = (db)INF * (db)INF;
  for(int i = 1; i <= top; ++i)
    {
      //printf("Line:%d %d R:%d U:%d L:%d\n", p[st[i]].id, p[st[i + 1]].id, r[i].R.id, r[i].U.id, r[i].L.id);
      Point AB = p[st[i + 1]] - p[st[i]];
      db a = sqrt(dis(AB));
      db b = (AB ^ (r[i].L - p[st[i]])) / a, c = (AB ^ (r[i].R - p[st[i + 1]])) / a;
      b = fabs(b), c = fabs(c);
      db l = a + b + c;
      db h = AB * (r[i].U - p[st[i]]) / a;
      h = fabs(h);
      db s = l * h;
      //printf("**%.3lf %.3lf %.3lf %.3lf %.3lf", a, b, c, l, h);
      //printf("@%.3Lf\n", s);
      if(s < ans - eps)
	{
	  ans = s;
	  Ans[0] = p[st[i + 1]] + AB * (c / a);
	  Ans[1] = Ans[0] + rot(AB) * (-h / a);
	  Ans[2] = Ans[1] + rot(Ans[1] - Ans[0]) * (-l / h);
	  Ans[3] = Ans[2] + rot(Ans[2] - Ans[1]) * (-h / l);
	  /*Ans[1] = Ans[0] + (r[i].R - Ans[0]) * (h / dis(Ans[0] - r[i].R));  //这就是我原来的写法，点重合会$gg$
	  Ans[2] = Ans[1] + (r[i].U - Ans[1]) * (l / dis(r[i].U - Ans[1]));
	  Ans[3] = Ans[2] + (r[i].L - Ans[2]) * (h / dis(r[i].L - Ans[2]));*/
	}
    }
  printf("%.5lf\n", ans);
  int id = 0;
  for(int i = 1; i < 4; ++i)
    if(Ans[i].y < Ans[id].y - eps || (fabs(Ans[i].y - Ans[id].y) < eps && Ans[i].x < Ans[id].x - eps)) id = i;
  for(int i = 0; i < 4; ++i)
    {
      db x = Ans[(id + i) % 4].x, y = Ans[(id + i) % 4].y;
      if(fabs(x) < 1e-5) x = 0;
      if(fabs(y) < 1e-5) y = 0;
      printf("%.5lf %.5lf\n", x, y);
    }
  return 0;
}
```

---

## 作者：WaReTle (赞：14)

## 几乎没有细节的写法

前置知识：凸包，旋转卡壳的思想，向量运算。

求完凸包后，我们需要对于凸包的每条边，找出满足下面条件的矩形的长和宽。

* 以这条边所在直线的一部分为一边
* 包含这个凸包的所有点
* 面积最小

答案即为这些矩形中面积最小的一个。

关于上面部分的详细解释可以看其他题解。

下图是一个例子。显然矩形的三边与凸包“相切”。

![](https://cdn.luogu.com.cn/upload/image_hosting/8wd604g5.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)

设凸包上的点按逆时针排序后的序列为 $p$。

为了方便起见，当前正在考虑的边画成水平。

![](https://cdn.luogu.com.cn/upload/image_hosting/4ur5g06h.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)

我们要分别求出最右、最上、最左的点。设它们分别为 $i,j,k$。先使用旋转卡壳的思想维护 $i$。

如图，容易发现如果 $\overrightarrow{a}\cdot\overrightarrow{p_ip_{i+1}}>0$ 则 $i$ 应移动。

我们发现这里只用到了 $\overrightarrow{a}$ 的方向。**我们不在意它的模或者起点**。因此，将它逆时针旋转 $90\degree$ （$(x,y)\rightarrow(-y,x)$）后我们可以用**完全相同**的方法维护 $j$。$k$ 同理。这显然可以封装为一个函数。

接下来的代码难度主要在于求出矩形的长宽以及四个角的坐标。仍以上图为例。我们需要求出 $QH$ 的长度。

容易发现，$\overrightarrow{QB}\cdot\overrightarrow{QP}=QP\cdot QH$。由此易得  $QH$ 的长度，从而算出矩形的右下角坐标。左下角同理。矩形的长就易于计算了。

矩形的宽更容易计算。我们可以计算出 $C$ 到直线 $QP$ 的距离。$\operatorname{dis}(C,QP)=\frac{|\overrightarrow{CQ}\times\overrightarrow{CP}|}{|\overrightarrow{a}|}$。

**重要注意点**：$i,j,k$ 的初始值均为 $1$，初始时 $k$ 逆时针移会变劣，因此需要先将 $i$ 和 $j$ 移好，将 $j$ 赋值给 $k$ 再移动 $k$。

代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
int n,st[50005],tp;
bool used[50005];
struct vec{double x,y;}a[50005],b[50005];
inline int nxt(int i){return i==n-1?1:i+1;}
double operator*(vec a,vec b){return a.x*b.x+a.y*b.y;}//点积 
double operator%(vec a,vec b){return a.x*b.y-a.y*b.x;}//叉积 
vec operator-(vec a,vec b){return {a.x-b.x,a.y-b.y};}
bool operator<(const vec&a,const vec&b){return a.x<b.x||a.x==b.x&&a.y<b.y;}
void rot(vec&a){swap(a.x,a.y),a.x=-a.x;}//将向量a逆时针旋转90° 
double sqr(double x){return x*x;}
double dis(vec a,vec b){return sqrt(sqr((a-b).x)+sqr((a-b).y));}
double mo(vec a){return sqrt(sqr(a.x)+sqr(a.y));}//模
struct ansv{double a;vec p[4];}ans;//答案结构体
void mov(vec x,int&i){while((a[nxt(i)]-a[i])*x>=0)i=nxt(i);}//将i移动到x方向上最远的点，注意竖直向上也要动
void print(double x,char c){if(abs(x)<1e-6)x=0;printf("%.5lf%c",x,c);}//特判-0.00000
void print(vec a){print(a.x,' '),print(a.y,'\n');}
vec mov(vec s,vec d,double di)//从s沿d方向移动di后点的坐标 
{
	double tmp=di/mo(d);
	return {s.x+tmp*d.x,s.y+tmp*d.y};
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
		scanf("%lf%lf",&b[i].x,&b[i].y);
	sort(b+1,b+n+1);
	st[tp=1]=1;
	for(int i=2;i<=n;++i)
	{
		while(tp>1&&(b[st[tp]]-b[st[tp-1]])%(b[i]-b[st[tp]])<=0)
			used[st[tp--]]=0;
		used[st[++tp]=i]=1;
	}
	int t=tp;
	for(int i=n-1;i;--i)
	{
		if(used[i])continue;
		while(tp>t&&(b[st[tp]]-b[st[tp-1]])%(b[i]-b[st[tp]])<=0)
			used[st[tp--]]=0;
		used[st[++tp]=i]=1;
	}
	n=tp;
	for(int i=1;i<=n;++i)
		a[i]=b[st[i]];
    //以上为凸包板子
    //---------------------------------------------------------------
    //以下为求解矩形
	int p1=1,p2=1,p3=1;
	ans.a=1e18;
	vec tmp=a[2]-a[1];
	mov(tmp,p1),p2=p1,rot(tmp);
	mov(tmp,p2),p3=p2,rot(tmp);
	mov(tmp,p3);//注意
	for(int i=1;i<n;++i)
	{
		tmp=a[i+1]-a[i];//tmp为a向量
		mov(tmp,p1);//移动右边
		rot(tmp);//将tmp逆时针旋转90°
		mov(tmp,p2);//移动上边
		rot(tmp);
		mov(tmp,p3);//移动左边
		tmp=a[i+1]-a[i];
		double h,w=-mo(tmp);
		h=fabs((a[p2]-a[i])%(a[p2]-a[i+1]))/dis(a[i],a[i+1]);
		w+=(a[p1]-a[i])*tmp/mo(tmp);
		w+=(a[i+1]-a[p3])*tmp/mo(tmp);
        //这里w的计算方法是(QH)+(左边类似于QH的东西)-(|a|)
		if(h*w<ans.a)
		{
			ans.a=h*w;
            //这里对于四个顶点的计算方法是从Q出发逆时针移动一圈
            //注意代码里写了2个不同的mov
			ans.p[0]=mov(a[i],tmp,(a[p1]-a[i])*tmp/mo(tmp)),rot(tmp);
			ans.p[1]=mov(ans.p[0],tmp,h),rot(tmp);
			ans.p[2]=mov(ans.p[1],tmp,w),rot(tmp);
			ans.p[3]=mov(ans.p[2],tmp,h);
		}
	}
    //以下为繁琐的输出
	pair<double,double>T={1e18,1e18};
	int mnp=0;
	for(int i=0;i<4;++i)
		if(make_pair(ans.p[i].y,ans.p[i].x)<T)
			T=make_pair(ans.p[i].y,ans.p[i].x),mnp=i;
	print(ans.a,'\n');
	for(int i=0;i<4;++i)print(ans.p[(mnp+i)%4]);
	return 0;
}
```

更新：如果所有点的横坐标都相同这个方法会死循环。这题没有这样的数据，但是这种情况应该特判（或者直接坐标系随机旋转）。代码就不写了。

更新：为什么粗体会炸啊？

---

## 作者：CLer (赞：7)

下午看了一眼旋转卡壳，然后跟着zfj做了这题，看了广大题解才知道大家最小矩形覆盖为了保证所有点按照逆时针排序都是用了向量逐渐从si->si+1左边的点开始绕一圈。

这里的做法是先根据旋转卡壳记录下最小矩形左端q、上端r、右端p以及底部的线段，然后使用了两直线交点跟直线旋转90度作垂线求出两端点所在垂线，最后暴力求交点，这样就有了矩形下端两点，然后再过上端点r作底线平行线，瞎暴力，最后套了一下凸包的极角排序，然后找到开始的点，kungbin巨巨的板子真香

献上丑陋很多函数没有用到的代码
```c
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <string>
#include <cstring>
#include <vector>

using namespace std;

const int maxp = 50000 + 10;
const double eps = 1e-8;
const double PI = acos(-1.0);

int sgn(double x) {
    if (fabs(x) <= eps) return 0;
    if (x > 0) return 1;
    return -1;
}

struct Point 
{
    double x, y;
    Point(){}
    Point(double _x, double _y):x(_x), y(_y){}
    void input()
    {
        scanf("%lf%lf", &x, &y);
    }
    void output()
    {
        if (sgn(x) == 0)
            printf("0.00000");
        else
            printf("%.5lf", x);
        if (sgn(y) == 0)
            printf(" 0.00000");
        else
            printf(" %.5lf", y);
        puts("");
    }
    Point operator = (Point tmp) {
        this->x = tmp.x;
        this->y = tmp.y;
        return *this;
    }
    friend Point operator - (Point a, Point b)
    {
        Point res;
        res.x = a.x - b.x;
        res.y = a.y - b.y;
        return res;
    }
    friend Point operator + (Point a, Point b)
    {
        return Point(a.x + b.x, a.y + b.y);
    }
    bool operator < (Point b) const {
        return sgn(x-b.x)==0?sgn(y-b.y)<0:x<b.x;
    }
    Point operator * (const double k)
    {
        return Point(k*x, k*y);
    }
    double operator * (const Point a)
    {
        return (this->x * a.x + this->y * a.y);
    }
    double operator ^ (const Point a)
    {
        return this->x * a.y - this->y * a.x;
    }
    Point operator / (const double k)
    {
        return Point(x/k, y/k);
    }
    bool operator == (Point b) const {
        return sgn(x-b.x)==0&&sgn(y-b.y)==0;
    }
    void init(double _x, double _y)
    {
        x = _x;
        y = _y;
    }
    friend double dis(Point a, Point b) 
    {
        double dx = a.x-b.x;
        double dy = a.y-b.y;
        return sqrt(dx*dx+dy*dy);
    }
    double rad(Point a, Point b)
    {
        Point p = *this;
        return fabs(atan2(fabs((a-p)^(b-p)), (a-p)*(b-p)));
    }
    double len2()
    {
        return x * x + y * y;
    }
    Point rotleft()
    {
        return Point(-y, x);
    }
};

struct Line
{
    Point s, e;
    void adjust() {
        if (e < s) swap(s, e);
    }
    Line(){}
    Line (Point _s, Point _e)
    {
        s = _s;
        e = _e;
        adjust();
    }
    bool operator == (Line v) {
        return (s == v.s) && (e == v.e);
    }
    double length() {
        return dis(s, e);
    }
    int relation(Point p) {
        int c = sgn((p-s) ^ (e-s));
        if (c < 0) return 1;
        else if ( c > 0 ) return 2;
        return 3;
    }
    bool pointonseg(Point p) {
        return sgn((p - s) ^ (e - s)) == 0 && sgn((p - s) * (p - e)) <= 0;
    }
    bool parallel(Line v) {
        return sgn((e - s) ^ (v.e - v.s)) == 0;
    }
    friend Point crosspoint(Line u, Line v)
    {
        double a1 = (v.e - v.s) ^ (u.s - v.s);
        double a2 = (v.e - v.s) ^ (u.e - v.s);
        return Point((u.s.x * a2 - u.e.x * a1) / (a2 - a1), (u.s.y * a2 - u.e.y * a1) / (a2 - a1));
    }
};
int stk1[maxp * 2];
struct Polygon
{
    int n;
    Point p[maxp];
    Line l[maxp];
    void input(int _n)
    {
        n = _n;
        for (int i = 0; i < n; i ++ ) p[i].input();
    }
    void add(Point q)
    {
        p[n++] = q;
    }
    void getline()
    {
        for (int i = 0; i < n; i ++ )
        {
            l[i] = Line(p[i], p[(i+1)%n]);
        }
    }
    struct cmp
    {
        Point p;
        cmp(const Point &p0){p=p0;}
        bool operator () (const Point &aa, const Point &bb)
        {
            Point a = aa, b = bb;
            int d = sgn((a-p)^(b-p));
            if (d == 0)
            {
                return sgn(dis(a, p) - dis(b, p)) < 0;
            }
            return d > 0;
        }
    };
    void norm() 
    {
        Point mi = p[0];
        for (int i = 1; i < n; i ++ )mi = min(mi, p[i]);
        sort(p, p + n, cmp(mi));
    }
    void getconvec(Polygon &convex) 
    {
        sort(p, p + n);
        convex.n = n;
        for (int i = 0; i < min(2, n); i ++ )
            convex.p[i] = p[i];
        if (convex.n == 2 && convex.p[0] == convex.p[1]) n--;
        if (n <= 2) return;
        int &top = convex.n;
        top = 1;
        for (int i = 2; i < n; i ++ )
        {
            while (top - 1 >= 0 && sgn((convex.p[top] - p[i]) ^ (convex.p[top - 1] - p[i])) >= 0)
                top--;
            convex.p[++top] = p[i];
        }
        int lim = top;
        convex.p[++top] = p[n-2];
        for (int i = n-3; i >= 0; i -- )
        {
            while (top - 1 >= lim && sgn((convex.p[top] - p[i]) ^ (convex.p[top - 1] - p[i])) >= 0)
                top--;
            convex.p[++top] = p[i];
        }
        if (convex.n == 2 && convex.p[0] == convex.p[1]) n--;
        convex.norm();
    }
};
double cross(Point A, Point B, Point C) {
    return (B - A) ^ (C - A);
}
double dot(Point A, Point B, Point C) {
    return (B - A) * (C - A);
}

double minRectangleCover(Polygon conv, int &rr, int &pp, int &qq, int &ii) {
    if (conv.n < 3) return 0.0;
    int n = conv.n;
    conv.p[n] = conv.p[0];
    double ans = -1;
    int r = 1, p = 1, q;
    for (int i = 0; i < n; i ++ ) {
        while (sgn(cross(conv.p[i], conv.p[i + 1], conv.p[r + 1]) - cross(conv.p[i], conv.p[i + 1], conv.p[r])) >= 0)
            r = (r + 1) % n;
        while (sgn(dot(conv.p[i], conv.p[i + 1], conv.p[p + 1]) - dot(conv.p[i], conv.p[i + 1], conv.p[p])) >= 0)
            p = (p + 1) % n;
        if (i == 0) q = p;
        while (sgn(dot(conv.p[i], conv.p[i + 1], conv.p[q + 1]) - dot(conv.p[i], conv.p[i + 1], conv.p[q])) <= 0)
            q = (q + 1) % n;
        double d = (conv.p[i] - conv.p[i + 1]).len2();
        double tmp = cross(conv.p[i], conv.p[i + 1], conv.p[r]) * 
        (dot(conv.p[i], conv.p[i + 1], conv.p[p]) - dot(conv.p[i], conv.p[i + 1], conv.p[q])) / d;
        if (ans < 0 || ans > tmp) {
            ans = tmp;
            rr = r;
            pp = p;
            qq = q;
            ii = i;
        }
    }
    return ans;
}

int main ()
{
    int n;
    scanf("%d", &n);
    Polygon poly;
    poly.input(n);
    Polygon conv;
    poly.getconvec(conv);
    int cnt = conv.n;
    int r, p, q, i;
    double res = minRectangleCover(conv, r, p, q, i);
    printf("%.5lf\n", res);

    Line line1(conv.p[i], conv.p[i + 1]);
    Point tmp = line1.e - line1.s;
    Line line2(conv.p[r], conv.p[r] + tmp);
    tmp = tmp.rotleft();
    Line line3(conv.p[p], conv.p[p] + tmp);
    Line line4(conv.p[q], conv.p[q] + tmp);
    Point ans[4];
    ans[0] = crosspoint(line1, line3);
    ans[1] = crosspoint(line1, line4);
    ans[2] = crosspoint(line2, line3);
    ans[3] = crosspoint(line2, line4);
    poly.n = 4;
    for (int i = 0; i < 4; i ++ )
        poly.p[i] = ans[i];
    poly.getconvec(conv);
    int fir = 0;
    for (int i = 0; i < 4; i ++ ){   
        if (conv.p[fir].y > conv.p[i].y){
            fir = i;
        }
        else if (conv.p[fir].y == conv.p[i].y && conv.p[fir].x > conv.p[i].x)
            fir = i;
    }
    for (int i = 0; i < 4; i ++ ){
        conv.p[(fir + i)%4].output();
    }
    return 0;
}
```


---

## 作者：fatesrl (赞：3)

本题解主要对求矩形的点做了优化，更好理解一点,也更直接。

前置知识：点到直线的投影，凸包，旋转卡壳。

求解旋转卡壳，这里不再赘述，其他题解有详细解释，这里图片展示了利用投影求矩形四点。

![](https://cdn.luogu.com.cn/upload/image_hosting/4kvu4vp8.png)

具体代码（有详细注释）：

```cpp
#include <bits/stdc++.h>
using namespace std;
const double eps=1e-10;
const int M=1e5+10;
int sgn(double a){ //误差 
	if(fabs(a)<eps) return 0;
	return a>0?1:-1;
}

struct point{//点的定义 ，点和向量未做区分 
	double x,y;
	point(){}
	point(double x,double y):x(x),y(y){}
	point operator+(point b){ return point(x+b.x,y+b.y);}
	point operator-(point b){ return point(x-b.x,y-b.y);}
	point operator*(double k){ return point(x*k,y*k);}
	point operator/(double k){ return point(x/k,y/k);}
	bool operator==(point b){return sgn(x-b.x)==0&&sgn(y-b.y)==0;}
    double operator*(const point &t)const {return x*t.y-y*t.x;} //叉积 
    double operator^(const point &t)const {return x*t.x+y*t.y;} //点积  
	bool operator<(point b){
		return sgn(x-b.x)<0||sgn(x-b.x)==0&&sgn(y-b.y)<0;
	}
};
 
double len2(point a){return (a^a);}//向量长度平方 
 
struct line{//直线的定义 ，直线和线段未做区分 
	point p1,p2;//p1->p2
	line(){}
	line(point p1,point p2):p1(p1),p2(p2){}//两点表示,或者可以变化为点向式 

};

point point_line_proj(point p,line v){//点往直线作垂线的交点 
	double k=(v.p2-v.p1)^(p-v.p1)/len2(v.p2-v.p1);
	return v.p1+(v.p2-v.p1)*k;
}


int convex_hull(point *p,int n,point *ch){//凸包 (逆时针)
	n=unique(p,p+n)-p;
	sort(p,p+n);
	int v=0;
	for(int i=0;i<n;i++){
		while(v>1&&sgn((ch[v-1]-ch[v-2])*(p[i]-ch[v-2]))<=0) v--;
		ch[v++]=p[i];
	}
	int j=v;
	for(int i=n-1;i>=0;i--){
		while(v>j&&sgn((ch[v-1]-ch[v-2])*(p[i]-ch[v-2]))<=0) v--;
		ch[v++]=p[i];
	}
	if(n>1) v--;
	return v;
}


double ans=-1;
point a,la,ra;
line d;
void get_minest(point *ch,int t){
	int j=2,l=1,r=1;
	double t1,t2,t3;
	for(int i=0;i<t;i++){//i,i+1为矩形底 ,设长度为d 
		while(fabs((ch[(i+1)%t]-ch[i])*(ch[j]-ch[i]))<fabs((ch[(i+1)%t]-ch[i])*(ch[(j+1)%t]-ch[i]))) j=(j+1)%t;//矩形上端 
		while(sgn(((ch[i+1]-ch[i])^(ch[r+1]-ch[i]))-((ch[i+1]-ch[i])^(ch[r]-ch[i])))>0) r=(r+1)%t;//矩形右端(相对于矩形底) 
		l=max(l,j);// l必须比j大 ，既在逆时针方向上的下一个点 
		while(sgn(((ch[i+1]-ch[i])^(ch[l+1]-ch[i]))-((ch[i+1]-ch[i])^(ch[l]-ch[i])))<0) l=(l+1)%t;//矩形左端 
		
		t1=fabs((ch[i]-ch[i+1])*(ch[j]-ch[i+1]));//h*d 
		t2=fabs((ch[i+1]-ch[i])^(ch[r]-ch[i]))+fabs((ch[i+1]-ch[i])^(ch[l]-ch[i]));//l1*d+l2*d 
		t3=len2(ch[i+1]-ch[i]);//d*d 
		
		double ins=t1*t2/t3;//s= (l1+l2)*h 
		if(ans<0||ans>ins){
			ans=ins;
			d=line(ch[i],ch[i+1]);
			a=ch[j];
			la=ch[l];
			ra=ch[r];
		} 
	}
}
double f(double a){
	if(fabs(a)<eps) return 0;
	return a;
}
void output(){
	cout<<fixed<<setprecision(6)<<ans<<'\n';
	point pt[5];//方向保持l->r即可保证逆时针,因为此代码求的凸包方向就是逆时针 
	pt[0]=point_line_proj(la,d);//左下(相对于直线d) 
	pt[1]=point_line_proj(ra,d);//右下	
	line de=line(a,a+d.p1-d.p2);//上端点所过直线,且和底边平行 
	pt[2]=point_line_proj(ra,de);//右上	
	pt[3]=point_line_proj(la,de);//左上 
	
	for(int i=0;i<4;i++){
		cout<<fixed<<setprecision(6)<<f(pt[i].x)<<' '<<fixed<<setprecision(6)<<f(pt[i].y)<<'\n';
	}
}
void solve(){
	
	int n;
	point a[50005],ch[50005];
	cin>>n;
	for(int i=0;i<n;i++) cin>>a[i].x>>a[i].y;
	int v=convex_hull(a,n,ch);	
	get_minest(ch,v);
	output();	
	
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	int ins=1;
	//cin>>ins;
	while(ins--) solve();
	return 0;
}
```

---

## 作者：kkxhh (赞：1)

首先求出凸壳，然后枚举每条边，求出以这条边为基准，最上，最左和最右的点

最上面的点是满足决策单调性的，可以直接维护一个指针 $O(n)$ 求出，但是左边和右边的指针似乎并不满足单调性，于是只能每次都查找一遍

按理来说要达到正确的复杂度 $O(nlogn)$，求左右的点应该得用三分，但是我偷懒试了下直接暴力求竟然直接就过了。。。而且花的时间也不长。。。

于是就有了下面的代码，总复杂度 $O(n^{2})$，但是在没有经过特殊构造的数据下似乎常数极小

```cpp
#include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;

typedef struct vec{
    double x,y;
    vec() {}
    vec(double _x,double _y):x(_x),y(_y) {}
    vec operator + (vec a) {return vec(x+a.x,y+a.y);}
    vec operator - (vec a) {return vec(x-a.x,y-a.y);}
    vec operator * (double a) {return vec(x*a,y*a);}//乘一个常数
    double operator * (vec a) {return x*a.y-y*a.x;}//叉积
    double operator ^ (vec a) {return x*a.x+y*a.y;}//点积
}vec;

const double eps=1e-8,Pi=acos(-1);
vec p[50010],rec[5];
double mina=1e20;
int n,s[50010],siz,downtag;

bool cmp(vec a,vec b) {return (fabs(a.x-b.x)<eps)?a.y<b.y:a.x<b.x;}

double length (vec a) {return sqrt(a.x*a.x+a.y*a.y);}

vec rotate(vec a,double theta) {return vec(a.x*cos(theta)-a.y*sin(theta),a.x*sin(theta)+a.y*cos(theta));}

void print(vec a) {printf("%.5f %.5f\n",(fabs(a.x)<eps?0.00000:a.x),(fabs(a.y)<eps?0.00000:a.y));}

int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%lf%lf",&p[i].x,&p[i].y);
    sort(p+1,p+1+n,cmp);
    s[++siz]=1; s[++siz]=2;
    for(int i=3;i<=n;i++){
        while(siz>=2 && ((p[s[siz]]-p[s[siz-1]])*(p[i]-p[s[siz]])<0 || fabs((p[s[siz]]-p[s[siz-1]])*(p[i]-p[s[siz]]))<eps)) siz--;
        s[++siz]=i;
    }
    downtag=siz; s[++siz]=n-1;
    for(int i=n-2;i>=1;i--){
        while(siz-downtag>=1 && ((p[s[siz]]-p[s[siz-1]])*(p[i]-p[s[siz]])<0 || fabs((p[s[siz]]-p[s[siz-1]])*(p[i]-p[s[siz]]))<eps)) siz--;
        s[++siz]=i;
    }
    s[0]=s[siz-1]; //按照我的写法，1~siz-1才是真正凸壳上的点，0和siz是用来防止越界的
    for(int i=1,k=2,l,r;i<siz;i++){
        while(((p[s[i]]-p[s[k]])*(p[s[i+1]]-p[s[k]]))<((p[s[i]]-p[s[k+1]])*(p[s[i+1]]-p[s[k+1]]))) k=(k==siz-1)?1:k+1;
        r=(i+1==siz)?1:i+1; l=i; //重置l,r指针，等下暴力向两边查找
        while(((p[s[i+1]]-p[s[i]])^(p[s[r]]-p[s[i]]))<((p[s[i+1]]-p[s[i]])^(p[s[r+1]]-p[s[i]]))) r=(r==siz-1)?1:r+1;
        while(((p[s[i]]-p[s[i+1]])^(p[s[l]]-p[s[i+1]]))<((p[s[i]]-p[s[i+1]])^(p[s[l-1]]-p[s[i+1]]))) l=(l==1)?siz-1:l-1;
        double l1=length(p[s[i+1]]-p[s[i]]),l2=((p[s[i+1]]-p[s[i]])^(p[s[r]]-p[s[i+1]]))/l1,l3=((p[s[i]]-p[s[i+1]])^(p[s[l]]-p[s[i]]))/l1,l4=(p[s[i+1]]-p[s[i]])*(p[s[k]]-p[s[i]])/l1;
        if((l1+l2+l3)*l4<mina){
            mina=(l1+l2+l3)*l4;
            rec[1]=p[s[i+1]]+(p[s[i]]-p[s[i+1]])*(l3/l1+1); rec[2]=p[s[i]]+(p[s[i+1]]-p[s[i]])*(l2/l1+1);
            rec[3]=rec[2]+rotate(p[s[i+1]]-p[s[i]],Pi/2)*(l4/l1); rec[4]=rec[1]+rotate(p[s[i+1]]-p[s[i]],Pi/2)*(l4/l1);
        }
    }
    printf("%.5f\n",mina);
    int s=1;
    for(int i=2;i<=4;i++) if((rec[i].y<rec[s].y) || (fabs(rec[i].y-rec[s].y)<eps && rec[i].x<rec[s].x)) s=i;
    //找到左下角的点
    for(int i=1;i<=4;i++) {print(rec[s]); s=(s==4)?1:s+1;}
    return 0;
}
```

---


# [HNOI2009] 梦幻布丁

## 题目描述

$n$ 个布丁摆成一行，进行 $m$ 次操作。每次将某个颜色的布丁全部变成另一种颜色的，然后再询问当前一共有多少段颜色。

例如，颜色分别为 $1,2,2,1$ 的四个布丁一共有 $3$ 段颜色.

## 说明/提示

### 样例 1 解释
初始时布丁颜色依次为 $1, 2, 2, 1$，三段颜色分别为 $[1, 1], [2, 3], [4, 4]$。  
一次操作后，布丁的颜色变为 $1, 1, 1, 1$，只有 $[1, 4]$ 一段颜色。

### 数据规模与约定

对于全部的测试点，保证 $1 \leq n, m \leq 10^5$，$1 \leq a_i ,x, y \leq 10^6$。

### 提示

请注意，**不保证**颜色的编号不大于 $n$，也**不保证** $x \neq y$，$m$ **不是**颜色的编号上限。

## 样例 #1

### 输入

```
4 3
1 2 2 1
2
1 2 1
2
```

### 输出

```
3
1```

# 题解

## 作者：Siyuan (赞：70)

[$$\Large\texttt{My Blog}$$](https://hydingsy.github.io/)

---

> 题目链接：[BZOJ 1483](https://www.lydsy.com/JudgeOnline/problem.php?id=1483)

有 $n$ 个布丁摆成一行，每个布丁都有一个颜色 $a_i$，进行 $m$ 次操作。操作共有 $2$ 种：

- 将颜色为 $x$ 的布丁全部变成颜色 $y$ 的布丁。
- 询问当前一共有多少段颜色（例如颜色分别为 $1,2,2,1$ 的 $4$ 个布丁一共有 $3$ 段颜色）。

数据范围：$1\leqslant n,m\leqslant 10^5$，$0<a_i,x,y<10^6$

------

## Solution

我们可以把每种颜色的布丁集合想象成是一个队列。那么就有若干个长度总和为 $n$ 的队列，每次操作需要合并 $x$ 和 $y$。如果我们暴力合并，那么合并一次复杂度最坏为 $O(n)$。

但是有个叫做**启发式合并**的东西！它的本质很简单：每次把短的合并到长的上面，那么合并一次的复杂度为 $O(|短的队列|)$。这样看上去貌似没有什么差别嘛 QAQ，接下来我们分析一下均摊复杂度。

考虑用贡献法来分析。我们令两个集合的分别为 $A$ 和 $B$，且 $|A|<|B|$，那么我们把 $A$ 暴力加入到 $B$ 中。那么 $A$ 中的元素所在的集合大小变成 $|A|+|B|$，也就是说至少变成了原来的两倍。所以每个元素至多被加入 $\log n$ 次，总的复杂度为 $O(n\log n)$。

对于这道题目，我们先求出原序列的答案，对于每一种颜色都用类似**链表**的数据结构串起来，并记录下尾节点。每次修改，都根据启发式合并的方法来暴力合并，然后处理一下此次合并对答案的影响（显然答案是不增的）。

但是如果我们把 $1$ 染成 $2$ 并且 $|S_1|>|S_2|$，那么我们应该把 $2$ 接到 $1$ 的后面。这样会有一个问题：本次修改后这个链的颜色是 $1$（颜色为 $2$ 的链被删除了），如果接下来修改颜色 $2$（显然这是合法的），会使得找不到颜色 $2$ 而只能找到颜色 $1$ 了。所以我们需要使用一个 $f$ 数组，表示当我们要寻找颜色 $x$ 时，实际上需要寻找颜色为 $f[x]$ 的链。如果遇到上面这种情况就要交换交换 $f[x]$ 和 $f[y]$。

**时间复杂度**：$O(n\log n)$

------

## Code

```cpp
#include <iostream>
#include <cstdio>

const int N=1e5+5,M=1e6+5;
int n,m,c[N],sz[M],st[M],f[M],hd[M],nxt[N],ans;

void merge(int x,int y) {
    for(int i=hd[x];i;i=nxt[i]) ans-=(c[i-1]==y)+(c[i+1]==y);
    for(int i=hd[x];i;i=nxt[i]) c[i]=y;
    nxt[st[x]]=hd[y],hd[y]=hd[x],sz[y]+=sz[x];
    hd[x]=st[x]=sz[x]=0;
}
int main() {
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i) {
        scanf("%d",&c[i]),f[c[i]]=c[i];
        ans+=c[i]!=c[i-1];
        if(!hd[c[i]]) st[c[i]]=i;
        ++sz[c[i]],nxt[i]=hd[c[i]],hd[c[i]]=i;
    }
    while(m--) {
        int opt;
        scanf("%d",&opt);
        if(opt==2) printf("%d\n",ans);
        else {
            int x,y;
            scanf("%d%d",&x,&y);
            if(x==y) continue;
            if(sz[f[x]]>sz[f[y]]) std::swap(f[x],f[y]);
            if(!sz[f[x]]) continue;
            merge(f[x],f[y]);
        }
    }
    return 0;
}
```



---

## 作者：_Chris° (赞：30)

### 前置芝士
   
#    线段树合并

刚学线段树合并于是找到了这道题,但是题解竟然没有一篇线段树的？~~能写线段树为什么要写平衡树呢~~

很明显我们对每一种颜色建立一颗线段树,每颗线段树里维护这个颜色所有的位置信息(当然是动态开点啦)

考虑合并两种颜色,就用线段树合并把x的线段树合并在y上,然后再向上更新答案

那么怎么向上更新答案呢

我们记录这个区间**存在的**最左边和最右边的位置,如果左儿子的右边位置
与右儿子的左边位置是相邻的,那么就要减1

时间复杂度和空间复杂度都是O(nlogn)

还有一些细节见代码吧

## Code
```c
#include<bits/stdc++.h>
#define N 100010
#define mid ((L+R)>>1)
using namespace std;
int n,m,k,Ans,rt[N*10];//颜色有1e6要开大一点 
int ls[N*32],rs[N*32],lv[N*32],rv[N*32],sum[N*32];//最左边位置,右边位置,区间颜色段 
void update(int t)
{
	lv[t] = lv[ls[t]]?lv[ls[t]]:lv[rs[t]];//因为是动态开点所以左右儿子可能为0要判一下 
	rv[t] = rv[rs[t]]?rv[rs[t]]:rv[ls[t]];
	sum[t] = sum[ls[t]]+sum[rs[t]]-(rv[ls[t]]+1 == lv[rs[t]]);//如果左右儿子位置相邻减1 
}
void Change(int &t,int L,int R,int x)
{
	if(!t) t = ++k;	
	if(L == R) {lv[t] = rv[t] = x,sum[t] = 1; return;}
	if(x <= mid) Change(ls[t],L,mid,x);
	else Change(rs[t],mid+1,R,x);
	update(t);
}
void Merge(int &x,int &y,int L,int R)//线段树合并板子 
{
	if(!x || !y) {x += y; return ;}
	if(L == R) {lv[x] = rv[x] = L,sum[x] = 1; return;}
	Merge(ls[x],ls[y],L,mid);
	Merge(rs[x],rs[y],mid+1,R);
	update(x);
}
int main()
{
	int op,x,y;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) 
	{
		scanf("%d",&x);
		Ans -= sum[rt[x]];
		Change(rt[x],1,n,i);
		Ans += sum[rt[x]];	
	}
	for(int i=1;i<=m;i++)
	{
		scanf("%d",&op);
		if(op == 1)
		{
			scanf("%d%d",&x,&y);
			if(x == y) continue;
			Ans -= (sum[rt[x]]+sum[rt[y]]);
			Merge(rt[y],rt[x],1,n);
			rt[x] = 0;  //注意清空颜色为x的线段树 
			Ans += sum[rt[y]];	
		}else printf("%d\n",Ans);
	}
	return 0;
}
```


---

## 作者：qwaszx (赞：20)

如果没有修改，那么直接扫一遍，看有多少个位置满足$color[i]\neq color[i-1]$即可.

有了修改，那么我们就考虑**暴力修改**

如果要把颜色$x$都变成$y$，那么我们先把所有颜色是$x$的位置找到，然后把它们变成$y$，同时更新答案.这个找位置的过程可以直接用链表做，对每个颜色开一个链表，更新答案的时候看这个位置两边有没有$y$，有就答案$--$，最后把两个链表合并.

然后我们发现把$x$变成$y$和把$y$变成$x$对答案没什么区别，只是对后面的修改有关系.这样我们每次找一个更短的更新答案.为了处理对修改的影响，开一个数组$f[x]$表示颜色$x$所在的链表的颜色即可.

复杂度看起来就是个暴力，但是注意每次合并至少会把一个颜色的规模翻倍，所以每个点最多被处理$O(\log n)$次,总共$O(n\log n)$.

即启发式合并.

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N=1500000;
int ans[N],size[N],tmp[N],fst[N],nxt[N],f[N],s,n,m,a[N];
void debug(){cout<<233<<endl;}
void merge(int &x,int &y)
{
	if(size[x]>size[y])swap(x,y);//交换
	if(!size[x]||x==y)return;
	for(int i=fst[x];i!=-1;i=nxt[i])
		s-=(a[i-1]==y)+(a[i+1]==y);//更新答案
	for(int i=fst[x];i!=-1;i=nxt[i])
	{
		a[i]=y;//修改
		if(nxt[i]==-1){nxt[i]=fst[y],fst[y]=fst[x];break;}//合并
	}
	size[y]+=size[x],size[x]=0,fst[x]=-1;//合并
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<N;i++)fst[i]=-1,f[i]=i;
	for(int i=1;i<=n;i++)
	{
		scanf("%d",a+i);int x=a[i];
		nxt[i]=fst[x],fst[x]=i,size[x]++;//前向星
		if(nxt[i]!=i-1)s++;
	}
	for(int i=1;i<=m;i++)
	{
		int opt,x,y;
		scanf("%d",&opt);
		if(opt==2)printf("%d\n",s);
		else scanf("%d%d",&x,&y),merge(f[x],f[y]);
	}
}
```

---

## 作者：λᴉʍ (赞：17)

set启发式合并，代码巨短

首先对每个元素维护一个set，变颜色相当于合并一个颜色的set到另一个颜色里去

注意到段数$=1+\sum_{i=1}^{n-1}[A_i!=A_{i+1}]$，所以维护一下当前的段数，容易看出段数不会减少，当两个相邻的数变成了一样的，以后就都会一样了，段数永久$-1$

但是暴力合并复杂度不对，所以启发式合并

启发式合并其实就是一个暴力，原理就是把小的合并到大的，每次合并的复杂度只和小的那部分大小有关

这样的话一个元素每被当作小的集合合并一次，所在的集合大小至少$\times 2$，也就是说只会被合并$\log_2n$次

注意一下set直接交换是$O(n)$的，所以要用指针交换。

```cpp
#include<bits/stdc++.h>
#define il inline
#define vd void
typedef long long ll;
il int gi(){
	int x=0,f=1;
	char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(isdigit(ch))x=x*10+ch-'0',ch=getchar();
	return x*f;
}
int A[100010];
std::set<int> *q[1000010];
int main(){
	int n=gi(),m=gi(),res=0,opt,x,y;
	for(int i=1;i<=1000000;++i)q[i]=new std::set<int>;
	for(int i=1;i<=n;++i)A[i]=gi(),res+=A[i]!=A[i-1],q[A[i]]->insert(i);
	while(m--){
		opt=gi();
		if(opt==2)printf("%d\n",res);
		else{
			x=gi(),y=gi();if(x==y)continue;
			if(q[x]->size()>q[y]->size())std::swap(q[x],q[y]);
			for(auto i:*q[x])res-=q[y]->count(i-1)+q[y]->count(i+1);
			for(auto i:*q[x])q[y]->insert(i);
			q[x]->clear();
		}
	}
	return 0;
}
```

---

## 作者：kczno1 (赞：9)

这题可以用平衡树维护每种颜色的所有位置，合并时用启发式合并，

判断一下有没有i和i-1,i+1变成同色来更新当前ans。

但是还有更好的做法。

我们只用维护每个点的颜色，在启发式合并时看一下i-1,i+1的颜色即可。

当x合并到y里，这是没问题的。

但如果y合并到x里，这和将颜色x改为颜色y是相反的。怎么办呢？

我们可以直接把这个操作改为把颜色y改为颜色x，只要把后面操作出现的x,y替换一下，这就是等价的。

```cpp
#include<cstdio>
#include<algorithm>
using std::swap;

const int N=100010,A=1000100;
int n,m,i,a[N],dy[A],ans;
int t[A],s[A],next[N];

void merge(int &x,int &y)
{
    if(x==y) return ;
    if(s[x]>s[y]) swap(x,y);
    
    for(i=t[x];i;i=next[i])
    {
       ans-=(a[i-1]==y)+(a[i+1]==y);
       if(!next[i]) { next[i]=t[y];t[y]=t[x];break; }
    }
    for(i=t[x];i;i=next[i]) a[i]=y;
    t[x]=0;
    
    s[y]+=s[x];s[x]=0;
}

int main()
{
    freopen("1.in","r",stdin);freopen("1.out","w",stdout);
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;++i) {scanf("%d",a+i);next[i]=t[a[i]];t[a[i]]=i;++s[a[i]];}
    ans=1;
    for(i=2;i<=n;++i) if(a[i]!=a[i-1]) ++ans;
    for(i=1;i<=1000000;++i) dy[i]=i;
    
    while(m--)
    {
        int type,x,y;
        scanf("%d",&type);
        if(type==2)printf("%d\n",ans);
        else {scanf("%d%d",&x,&y);merge(dy[x],dy[y]);}
    }
}
```

---

## 作者：attack (赞：8)

楼上已经提到本题可以用平衡树求解了

用N个平衡树维护这N个颜色出现的位置

就本题而言，完全可以用一个set水过

每次合并的时候暴力合并就可以

注意当读入的颜色相同的时候直接跳出

```cpp
    #include<iostream>
    #include<cstdio>
    #include<cstring>
    #include<ctime>
    #include<cstdlib>
    #include<algorithm>
    #include<set>
    using namespace std;
    #define ls T[now].ch[0]
    #define rs T[now].ch[1]
    const int MAXN=1e6+10;
    inline char nc()
    {
        static char buf[MAXN],*p1=buf,*p2=buf;
        return p1==p2&&(p2=(p1=buf)+fread(buf,1,MAXN,stdin),p1==p2)?EOF:*p1++;
    }
    inline int read()
    {
        char c=nc();int x=0,f=1;
        while(c<'0'||c>'9'){if(c=='-')f=-1;c=nc();}
        while(c>='0'&&c<='9'){x=x*10+c-'0',c=nc();}
        return x*f;
    }
    set<int>s[MAXN];
    int a[MAXN],f[MAXN],ans;
    void unionn(int x,int y)
    {
        for(set<int>::iterator i=s[x].begin();i!=s[x].end();i++)
        {
            if(a[*i-1]==y)  ans--;
            if(a[*i+1]==y)    ans--;
            s[y].insert(*i);
        }
        for(set<int>::iterator i=s[x].begin();i!=s[x].end();i++)
            a[*i]=y;
        s[x].clear();
    }
    int main()
    {
        #ifdef WIN32
        freopen("a.in","r",stdin);
        #else
        #endif
        int n=read(),m=read();
        for(int i=1;i<=n;i++)
        {
            a[i]=read();
            if(a[i]!=a[i-1]) ans++;
            f[a[i]]=a[i];
            s[a[i]].insert(i);
        }
        while(m--)
        {
            int opt=read();
            if(opt==2)    { printf("%d\n",ans);continue;}
            int a=read(),b=read();
            if(a==b)    continue;
            if(s[f[a]].size()>s[f[b]].size())    swap(f[a],f[b]);
            unionn(f[a],f[b]);
        }
        return 0;
}
```

---

## 作者：一扶苏一 (赞：6)

## 【线段树合并】P3201 [HNOI2009]梦幻布丁

### Analysis

看到这类不可逆的合并操作，容易想到用线段树合并解决。

对每个颜色开一个（动态开点）线段树，对于颜色为 $c$ 的线段树上的区间 $[l, r]$，维护三个信息：原序列区间 $[l, r]$ 内的颜色段数 $v$，左端点处是否是该颜色 $lc$，右端点处是否是该颜色 $rc$。合并时采用与[这道题](https://www.luogu.com.cn/problem/P6492)类似的合并方式。将颜色段数 $v$ 相加，如果左孩子的右端点和右孩子的左端点都有有颜色，那么中间可以拼成一段，将段数减掉 $1$。其余信息直接继承即可。

维护全局答案 $ans$，在把一个颜色 $x$ 改成另一个颜色 $y$ 时，先将答案减掉颜色 $x$ 和 $y$ 的段数和，然后对两个颜色做线段树合并，最后把答案加上合并后的 $y$ 段数和，再将 $x$ 改为空指针即可。记得当 $x = y$ 时要直接跳过。

### Code

```cpp
namespace Fusu {

const int maxn = 1000005;

struct Node *nul;

struct Node {
  Node *ls, *rs;
  int l, r, lc, rc, v;

  Node() {}
  Node(const int L, const int R) : l(L), r(R) {
    ls = nul; rs = nul;
    lc = rc = v = 0;
  }

  inline void pushup() {
    v = ls->v + rs->v - (ls->rc && rs->lc);
    lc = ls->lc; rc = rs->rc;
  }
};
Node *rot[maxn], NUL;

int n, m, ans;
int a[maxn];

Node* merge(Node *u, Node *v);
void upd(Node *const u, const int p);

void Main() {
  nul = &NUL;
  qr(n); qr(m);
  qra(a + 1, n);
  for (auto &u : rot) u = nul;
  for (int i = 1; i <= n; ++i) {
    int x = a[i];
    upd(rot[x] != nul ? rot[x] : rot[x] = new Node(1, n), i);
  }
  for (auto u : rot) ans += u->v;
  for (int o, x, y; m; --m) {
    qr(o);
    if (o == 1) {
      qr(x); qr(y);
      if (x == y) continue;
      ans -= rot[y]->v + rot[x]->v;
      rot[y] = merge(rot[y], rot[x]);
      rot[x] = nul;
      ans += rot[y]->v;
    } else {
      qw(ans, '\n');
    }
  }
}

Node* merge(Node *u, Node *v) {
  if (u == nul) return v;
  if (v == nul) return u;
  if (u->l == u->r) {
    u->lc = u->rc = u->v = 1;
  } else {
    u->ls = merge(u->ls, v->ls);
    u->rs = merge(u->rs, v->rs);
    u->pushup();
  }
  return u;
}

void upd(Node *const u, const int p) {
  if (u->l == u->r) {
    u->lc = u->rc = u->v = 1;
    return;
  }
  int mid = (u->l + u->r) >> 1;
  if (mid >= p) {
    upd(u->ls != nul ? u->ls : u->ls = new Node(u->l, mid), p);
  } else {
    upd(u->rs != nul ? u->rs : u->rs = new Node(mid + 1, u->r), p);
  }
  u->pushup();
}

} // namespace Fusu
```



---

## 作者：Epworth (赞：5)

这是一道模拟题，用$Vector$~~瞎搞~~一下就可以$AC$了。

$num[i]$记录每个布丁的颜色。

$pos[i]$记录颜色为$i$的布丁的位置。

因为颜色的范围很小，我们甚至不需要离散$QwQ$。

依次模拟颜色变换的过程，并更新答案。

将下标为$i$的颜色$X$变为$Y$后：

若$num[i-1]=num[i+1]$

​	①$X$与左右颜色相同，$Y$与左右颜色不同 变化后段数$+2$

​	②$X$与左右颜色不同，$Y$与左右颜色相同 变化后段数$-2$

若$num[i-1] \neq num[i+1]$

​	①$X$与左右颜色不同，$Y$与左右颜色之一不同 变化后段数$-1$

​	②$X$与左右颜色之一不同，$Y$与左右颜色相同 变化后段数$+1$

注意更新$num$和$pos$数组。

## 代码

```cpp
#include<bits/stdc++.h>
#define maxn 1000005
using namespace std;
int n,m,ans;
int num[maxn];
vector<int> pos[maxn];
int main(){
	scanf("%d%d",&n,&m);
	memset(num,0x3f,sizeof(num));
	for(int i=1;i<=n;i++){
		scanf("%d",&num[i]);
		pos[num[i]].push_back(i);
		if(num[i]-num[i-1]) ans++;
	}
	int opt;
	int x,y;
	for(int i=1;i<=m;i++){
		scanf("%d",&opt);
		if(opt==1){
			scanf("%d%d",&x,&y);
			if(x==y) continue;
			for(int i=0;i<pos[x].size();i++){
				int xx=pos[x][i];
				if(num[xx-1]==num[xx+1]){
					if(x==num[xx-1]&&y!=num[xx-1]) ans+=2; 
					if(x!=num[xx-1]&&y==num[xx-1]) ans-=2;
				} 
				else{
					if(x!=num[xx-1]&&x!=num[xx+1]&&(y!=num[xx-1]||y!=num[xx+1])) ans--;
					if((x!=num[xx-1]||x!=num[xx+1])&&y!=num[xx-1]&&y!=num[xx+1]) ans++;
				}
				num[xx]=y;
				pos[y].push_back(xx);
			}
			pos[x].clear();
		}
		else printf("%d\n",ans);
	}
	return 0;
}

```



---

## 作者：jzqjzq (赞：4)

就是链表（也可以用队列，我听人家说的）合并，引用hzwer一些话:

1：将两个队列合并，有若干队列，总长度为n，直接合并，最坏O(N)，

2：启发式合并呢？

每次我们把短的合并到长的上面去，O(短的长度)

咋看之下没有多大区别，

下面让我们看看均摊的情况：

1：每次O(N)

2：每次合并后，队列长度一定大于等于原来短的长度的两倍。

这样相当于每次合并都会让短的长度扩大一倍以上，

最多扩大logN次，所以总复杂度O(NlogN)，每次O(logN)。

然后对于此题

我们先求出原序列的答案

每一种颜色搞一条链把该色结点串起来，记录下链条尾结点

把一种颜色的染成另一种，很简单把它合并过去，然后处理下对于答案的影响

但是。。。

比如把1染成2，但是s[1]>s[2]，这时我们应该将2合并到1的链后面，但是会遇到一个麻烦的问题，就是这个链头是接1下的，也就是说以后找颜色2，发现没有颜色2只有颜色1。。。

于是我们应该开一个数组f，表示我们寻找一种颜色时，实际应该找哪个颜色下的链，遇到上面那种情况要交换f[1]和f[2]

详见http://hzwer.com/2858.html

代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
using namespace std;
int a[100007],jzq[1000007],head[1000007],next[100007],sum[1000007],rp[1000007];
int main()
{
    int n,m,ans=0;scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);jzq[a[i]]=a[i];
        if(a[i]!=a[i-1])ans++;
        if(head[a[i]]==0)rp[a[i]]=i;
        sum[a[i]]++;next[i]=head[a[i]];head[a[i]]=i;
    }
    for(int i=1;i<=m;i++){
        int p;scanf("%d",&p);if(p==2)cout<<ans<<endl;
        else{
            int x,y;scanf("%d%d",&x,&y);
            if(x==y)continue;
            if(sum[jzq[x]]>sum[jzq[y]])swap(jzq[x],jzq[y]);
            if(sum[jzq[x]]==0)continue;
            sum[jzq[y]]+=sum[jzq[x]];sum[jzq[x]]==0;
            int j=head[jzq[x]];
            while(j>0){
                if(a[j+1]==jzq[y])ans--;
                if(a[j-1]==jzq[y])ans--;
                j=next[j];
            }
            j=head[jzq[x]];
            while(j>0){
                a[j]=jzq[y];
                j=next[j];
            }
            next[rp[jzq[x]]]=head[jzq[y]];head[jzq[y]]=head[jzq[x]];sum[jzq[y]]+=sum[jzq[x]];
            head[jzq[x]]=rp[jzq[x]]=sum[jzq[x]]=0;
        }
    }
    return 0;
}
```

---

## 作者：torque (赞：3)

## 题意

给你n个数，m个操作，每个操作可以是：

1.询问1~n有多少段数（相邻且相等的数视作同一段）

2.对于给定的一对x、y，将所有值为x的数改为y

## 思路

这可以说是一种叫做**启发式合并**的数据结构

它是个什么东西呢？

你现在有很多个集合，你有时合并两个集合，有时又进行某些查询

我们知道n个数分入若干个集合，为了方便，这里我就用STL中的set来进行存储

如果我们要合并两个集合怎么办呢？

为了使得时间复杂度尽量小，我们就选择将元素个数小的集合中的元素暴力加入另一个集合

估算一下时间复杂度

由于合并后的集合大小大于等于合并的两个集合中的元素个数较小的集合元素个数的2倍（有点绕）

那么这个值扩大$logn$次就到了n（上限），而两个集合中元素最多的一个最多有$\frac{n}{2}$个元素，忽略常数的话

时间复杂度$O(nlogn)$

那么段数的问题怎么解决呢？

假设一开始段数为ans

我们发现段数只会由于颜色改变后引起的合并而进行改变，并且只减不增

如果我们定义集合$S_i$，集合里的元素表示值为i的所有元素的位置（数组下标）

如果我们要合并$S_i$与$S_j$且$\left|S_i\right|<\left|S_j\right|$

按照上面的规律，就将$S_i$中的所有元素添加到$S_j$中去

添加的过程中我们就要明白$\forall x\in S_i$，

如果$color_{x-1}=color_x$会引起段数合并，ans--

当$color_{x+1}=color_x$时同上，ans--

那么每次询问是回答ans即可

PERFECT！

## 代码
```cpp
#include <set>
#include <cstdio>
#include <cstdlib>
#define N 1000001
#define int long long
#define rnt register int
using namespace std;
set <int> t[N];
int n,m,ans,op,x,y,c[N,fa[N];
signed main(){
	scanf("%lld%lld",&n,&m);
	for(rnt i=1;i<=n;i=-~i){
		scanf("%lld",&c[i]);
		fa[c[i]]=c[i];
		t[c[i]].insert(i);
		if(c[i]!=c[i-1]) ans=-~ans;
	}
	for(rnt i=1;i<=m;i=-~i){
		scanf("%lld",&op);
		if(op==2) printf("%lld\n",ans);
		else{
			scanf("%lld%lld",&x,&y);
			if(x==y) continue;
			if((int)t[fa[x]].size()>(int)t[fa[y]].size())
				fa[x]^=fa[y]^=fa[x]^=fa[y];
			x=fa[x],y=fa[y];
			for(set<int>::iterator i=t[x.begin();i!=t[x].end();++i){
				if(c[*i-1]==y) --ans;
				if(c[*i+1]==y) --ans;
				t[y].insert(*i);
			}
			for(set<int>::iterator i=t[x].begin();i!=t[x].end();++i) c[*i]=y;
			t[x].clear();
		}
	}
	return 0;
}
```

## 提示

当时我这么打时，并不知道要用fa，结果全WA

我看着dalao们的代码，沉思良久，终于明白了fa的作用

我在这里就给不明白的童鞋讲一讲

当你把x改为y时，本来y的都在$S_y$中，但是可能$|S_y|>|S_x|$，为了时间，我们把y都丢进了$S_x$，

下次我们再修改y时，再找$S_y$，却发现他已经空了~~开盖有奖~~

所以$fa_i$是用于存储值为i的数位置存在了$S_{fa_i}$集合中，所以合并时也不要忘记了修改$fa_i$

![](https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2921431843,3149119026&fm=26&gp=0.jpg)

---

## 作者：吾王美如画 (赞：3)

# 唔姆
~~被这题毒瘤了一下午。。。~~

------------
由于我是直接从[P3224 [HNOI2012]永无乡](https://www.luogu.org/problemnew/show/P3224)过来的，所以习惯性地按合并的思路想，看没人这么写，我就来写一篇。~~（实际上是一时半会没想清楚）~~

------------
- 首先，我们对于每一个**颜色**建立一颗平衡树（我用的是treap哒），每当有颜色改动时，我们就把对应颜色的平衡树上的所以节点全部转移到另一个树上。

- 但这个方法一看就太暴力了。于是我们用启发式合并（永无乡那题也是），就是把节点小的树转移到节点多的树。这个楼下楼上都讲得比我好，我就不说了。但如果本来是要把a树转移到b树，可我们因为a.size>b.size所以把b树转移到a树来了，这就会导致后面的转移出问题。所以我们用f数组，表示每个颜色实际上对应的树。当我们在上面那个情况时，就要交换f[a]和f[b]。

- 然后在每个节点上，我们多记录一个left和right，表示这个节点所记录的区间的范围。在加入新节点时，如果现在有两个节点a，b。a.left-1==b.right||a.right+1==b.left就说明它们是连在一起的，那么就可以合起来，同时修改left和right。

- 那么接下来问题就简单了，先在输入时记录初始状态下一共有多少段颜色，显然这个答案不管怎么操作都不会增加的。当我们在转移节点时，只需在目标平衡树查找前驱和后缀就行了。如果前驱的right+1等于现在的left或者后缀的left-1等于现在的right。我们都可以把ans--。

- 最后有一点就是，在递归一棵树转移节点时，一定是要**先递归下一层**，等回来时再转移。因为有一些区间并没有完全合并，所以先转移的话会导致答案偏小。（我就是因为这个拿了半天50分）

- （还有一点，虽然n,m小于100000，但是Ai,x,y<1,000,000，也就意味着实际要建1，000，000棵平衡树）

- ~~还有一点~~当a==b时，也就是交换同一种颜色时，要直接continue，不然容易gg

```cpp
// luogu-judger-enable-o2
#include<cstdio>
#include<iostream>
#include<ctime>
#include<queue>
#include<string>
#include<cstring>
#include<cmath>
#define MAXN 1400100
#define INF 10000000
using namespace std;
int sum,R[MAXN];
int n,m;
int col[MAXN];
int f[MAXN];
int ans=0;
struct node{
       int son[2];
       int num;
       int size;
       int left;
       int rd;
       int right;
}tree[MAXN];
void up(int now){
     tree[now].size=tree[tree[now].son[0]].size+tree[tree[now].son[1]].size+tree[now].num;
}
void rotate(int &now,int d){
     int to=tree[now].son[!d];
     tree[now].son[!d]=tree[to].son[d];
     tree[to].son[d]=now;
     up(now);
     up(to);
     now=to;
}
void change(int &now,int x,int y){
     if (now<=1000100){now=++sum;tree[now].size=tree[now].num=y-x+1;tree[now].left=x;tree[now].right=y;tree[now].rd=rand();return;}
     else if(tree[now].left==x){tree[now].num++;tree[now].size++;return;}
     else if(tree[now].right==x-1){tree[now].num++;tree[now].size++;tree[now].right=y;return;}
     else if(tree[now].left==y+1){tree[now].num++;tree[now].size++;tree[now].left=x;return;};
     int tmp=(x>tree[now].left);
     change(tree[now].son[tmp],x,y);
     if (tree[now].rd>tree[tree[now].son[tmp]].rd)rotate(now,!tmp);
     up(now);
}
int pre(int now,int x){
    if (!now) return 0;
    int a;
    if (tree[now].left>=x)return pre(tree[now].son[0],x);
    else {
         a=pre(tree[now].son[1],x);
         if (tree[now].left>tree[a].left||!a)return now;
            else return a;
    }
}
int suc(int now,int x){
    if (!now) return 0;
    int a;
    if (tree[now].left<=x)return suc(tree[now].son[1],x);
    else {
         a=suc(tree[now].son[0],x);
         if (tree[now].left<tree[a].left||!a)return now;
            else return a;
    }
}
void dfs(int now,int &to){
     if (now<=1000100)return;
     int p=pre(to,tree[now].left);
     int s=suc(to,tree[now].left);
     if (tree[p].right+1==tree[now].left&&p)ans--;
     if (tree[s].left-1==tree[now].right&&s)ans--; 
     dfs(tree[now].son[0],to);
     dfs(tree[now].son[1],to);
     change(to,tree[now].left,tree[now].right);
}
int main(){
    cin>>n>>m;
    sum=1000100;
    memset(col,0,sizeof(col));
    for(int i=1;i<=n;i++){
            scanf("%d",&col[i]);
    }
    memset(tree,0,sizeof(tree));
    for(int i=1;i<=1000000;i++){
            R[i]=i;
            f[i]=i;
    }
    for(int i=1;i<=n;i++){
            change(R[col[i]],i,i);
            if (col[i]!=col[i+1])ans++;
    }
    for(int i=1;i<=m;i++){
            int a,b,c;
            scanf("%d",&a);
            if (a==1){
               scanf("%d%d",&b,&c);
               if (f[b]==f[c]) continue;
               if (tree[R[f[b]]].size<tree[R[f[c]]].size){dfs(R[f[b]],R[f[c]]);R[f[b]]=f[b];}
               else {dfs(R[f[c]],R[f[b]]);R[f[c]]=f[c];f[c]+=f[b];f[b]=f[c]-f[b];f[c]=f[c]-f[b];};
            }
            else printf("%d\n",ans);
    }
    return 0;
}

```

---

## 作者：a2956331800 (赞：2)

## 一个奇怪的思路
```cpp
map<pair<int,int>,list> mp;//list是手写链表支持两个链表连接 
```
想法就是对每个相邻的点建一条边，根据边两侧的点的颜色把边扔进map+链表，每次把$x$改成$y$时只要遍历对应的链表即可找到所有变成**相邻的同色点对**的**相邻的不同色点对**，同时要把所有连接$x$的边并到$y$里（map上upper_bound+连接链表）

完了？

~~完了~~

若干坑点：边要建两条（无向边）；一个颜色被改变后要把原本颜色的链表**删空**（因为可能有1 1 2 1 1 3这种情况，不删就会把1的边加到3上，但这时已经没有1了）；删边也要两条都删

（边是用pair表示的）

代码：~~（好像是写过的最简洁的题解了）~~
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<vector>
#include<map>
using namespace std;

int n,m,i,a[100005],ans,opt,x,y;

char Getchar()
{
	return getchar();
	static const int len=10000000;
	static char space[len],*p=space,*t=space;
	if(p==t)
	  t=space+fread(p=space,sizeof(char),len,stdin);
	return *(p++);
}
char rc;int flag;
void read(int &x)
{
	x=0;rc=Getchar();flag=1;
	while(rc<'0'||rc>'9')
	  flag=(rc=='-'?-1:1),rc=Getchar();
	while(rc>='0'&&rc<='9')
	  x=x*10+rc-'0',rc=Getchar();
	x*=flag;
}

struct node
{
	int x;
	node *next;
	node(int num=0)
	{
		x=num;next=NULL;
	}
};
struct list
{
	node *head,*end;
	void push_back(int x)
	{
		if(head==NULL)
		  head=new node(x),end=head;
		else end->next=new node(x),end=end->next;
	}
	void link(list x)
	{
		if(x.head==NULL)
		  return;
		if(head==NULL)
		  head=x.head,end=x.end;
		else end->next=x.head,end=x.end;
	}
};
list l;

map<pair<int,int>,list> mp;//listÊÇÊÖÐ´Á´±íÖ§³ÖÁ½¸öÁ´±íÁ¬½Ó 
map<pair<int,int>,list> ::iterator it,nit;

int f[100005];
int find(int x)
{
	return f[x]==x?x:f[x]=find(f[x]);
}

inline void del(map<pair<int,int>,list> ::iterator x)
{
	mp.erase(make_pair(x->first.second,x->first.first));
	mp.erase(x);
}

int main()
{
	read(n);read(m);ans=n;
	for(i=1;i<=n;i++)
	  read(a[i]),f[i]=i;
	for(i=2;i<=n;i++)
	  if(a[i]==a[i-1])
	    f[i]=find(f[i-1]),ans--;
	  else mp[make_pair(min(a[i],a[i-1]),max(a[i],a[i-1]))].push_back(i-1),mp[make_pair(max(a[i],a[i-1]),min(a[i],a[i-1]))].push_back(i-1);
	for(i=1;i<=m;i++)
	{
		read(opt);
		if(opt==1)
		{
			read(x);read(y);
			if(x==y)
			  continue;
			l=mp[make_pair(x,y)];
			for(node *now=l.head;now!=NULL;now=now->next)
			  if(find(now->x)!=find(now->x+1))
				ans--,f[find(now->x)]=find(now->x+1);
			it=mp.upper_bound(make_pair(x,0));
			for(;it->first.first==x&&it!=mp.end();nit=it++,del(nit))
			  if(y!=it->first.second)
			  	mp[make_pair(min(y,it->first.second),max(y,it->first.second))].link(it->second),
				  mp[make_pair(max(y,it->first.second),min(y,it->first.second))].link(it->second);
		}
		if(opt==2)
		  printf("%d\n",ans);
	}
	return 0;
}
```

---

## 作者：joe19025 (赞：1)

## 思路
###  技能储备
1 treap

2 并查集

3 启发式合并


#### 启发式合并
~~前面两个不会我也没有什么办法~~

启发式合并其实很简单，就是把少的往多的上面合

### 大体思路
建n个treap维护每一个颜色，里面记录每一个出现的位置下标。

合并暴力合并，把一个treap里的全部加到另一个treap里，小的往大的加。在加的同时维护一个并查集，记录是否颜色和i-1,i+1相同（具体做法就是找前驱和后继），相同就合并。

### ~~小细节~~
~~1 一定要判断x==y！相等就退出，别问我怎么知道的……~~

~~2 内存池开大点，否则会RE~~



------------

## Code
```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#define MAXN 100005
using namespace std;

//treap
struct treap{
    int v;
    int r;
    int s;
    treap *ch[2];
    void maintain()
    {
        s=1;
        if(ch[0])s+=ch[0]->s;
        if(ch[1])s+=ch[1]->s;
    }
    int cmp(int k)
    {
        if(v==k)return -1;
        return k<v?0:1;
    }
}pool[MAXN*40];
int tot=0;
void rotate(treap *&o,int d)
{
    treap *k=o->ch[d^1];
    o->ch[d^1]=k->ch[d];
    k->ch[d]=o;
    o->maintain();
    k->maintain();
    o=k;
}
void insert(treap *&o,int k)
{
    if(o==NULL)
    {
        o=&pool[tot++];
        o->v=k;
        o->r=rand();
        o->s=1;
        o->ch[0]=o->ch[1]=NULL;
        return;
    }
    int d=o->cmp(k);
    if(d==-1)return;
    insert(o->ch[d],k);
    if(o->ch[d]->r>o->r)rotate(o,d^1);
    o->maintain();
}
void remove(treap *&o,int k)
{
    int d=o->cmp(k);
    if(d==-1)
    {
        if(o->ch[0]==NULL)o=o->ch[1];
        else if(o->ch[1]==NULL)o=o->ch[0];
        else
        {
            int d2=o->ch[0]->r > o->ch[1]->r ? 1 : 0;
            rotate(o,d2);
            remove(o->ch[d2],k);
        }
    }
    else
        remove(o->ch[d],k);
    if(o)
        o->maintain();
}
int getpre(treap *o,int k)
{
    int ans=0;
    while(o)
    {
        if(o->v<k)ans=o->v,o=o->ch[1];
        else
            o=o->ch[0];
    }
    return ans;
}
int getsuc(treap *o,int k)
{
    int ans=0;
    while(o)
    {
        if(o->v>k)ans=o->v,o=o->ch[0];
        else
            o=o->ch[1];
    }
    return ans;
}

//unionset
int p[MAXN];
int find(int x)
{
    return p[x]==x?x:p[x]=find(p[x]);
}
int cnt;
void uni(int x,int y)
{
    if(find(x)!=find(y))
    {
        p[find(x)]=find(y);
        cnt--;
    }
}
int n,m;
void move(treap *&o,treap *&k)
{
    if(o==NULL)return;
    if(k==NULL)swap(o,k);
    else
    {
        if(o->s>k->s)
            swap(o,k);
        while(o!=NULL)
        {
            int z=getsuc(o,0);
            remove(o,z);
            if(z>1 && getpre(k,z)==z-1)
                uni(z,z-1);
            if(z<n && getsuc(k,z)==z+1)
                uni(z,z+1);
            insert(k,z);
        }
    }
}

int main()
{
    //initalization
    treap *root[1000005];
    for(int i=1;i<=1000005;i++)
        root[i]=NULL;
    
    //build
    scanf("%d%d",&n,&m);
    cnt=n;
        for(int i=1;i<=n;i++)p[i]=i;
    for(int i=1;i<=n;i++)
    {
        int cur;
        scanf("%d",&cur);
        if(i>1 && getpre(root[cur],i)==i-1)
            uni(i,i-1);
        insert(root[cur],i);
    }
    
    for(int i=1;i<=m;i++)
    {
        int op;
        scanf("%d",&op);
        if(op==2)
        {
            printf("%d\n",cnt);
        }
        else
        {
            int x,y;
            scanf("%d%d",&x,&y);
            if(x==y)
                continue;
            move(root[x],root[y]);
        }
    }
    return 0;
}


```

---

## 作者：keep_ (赞：0)

# 洛谷P3201 [HNOI2009] 梦幻布丁(链式存储+启发式合并)

针对本题，个人认为第一篇题解写的比较清楚了，在此对其中的fa数组进

行一些补充说明

具体解释写在代码里

```c++
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int maxn=1e3;
inline int read(){
	int ret=0;
	int f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')
			f=-f;
		ch=getchar();
	}
	while(ch<='9'&&ch>='0'){
		ret=ret*10+(ch^'0');
		ch=getchar();
	}
	return f*ret;
}
int n,m;
int c[maxn];
int head[maxn];
int nex[maxn];
int fa[maxn];
int sz[maxn];
int st[maxn];
int ans;
int x,xx,y,yy;
void add(int a,int b){
	for(int i=head[a];i;i=nex[i]){
		ans-=(c[i-1]==b)+(c[i+1]==b);
	}
	for(int i=head[a];i;i=nex[i]){
		c[i]=b;
	}
	nex[st[a]]=head[b];
	head[b]=head[a];
	sz[b]+=sz[a];
	st[a]=sz[x]=head[a]=0;
	return ;
}
int main(){
		n=read();
		m=read();
		for(int i=1;i<=n;i++){
			c[i]=read();
			ans+=(c[i]!=c[i-1]);
			fa[c[i]]=c[i];
			/*为什么我们要设置fa数组？
假设有1，2两种颜色，显然将2全变为1和将1全变为2对答案的贡献是同样的我们考虑到对时间复杂度的优化
所以对合并采取的是启发式合并，因此我们会将该颜色布丁个数较小的颜色染成较大的颜色
这时就引出了一个问题，假设存在1,2两种颜色，1颜色的布丁数量小于2，这时我们把2染成1，启发式合并导致我们实际把1染成2，假设下一个操作要对1进行，但我们已经把1变成2了，很明显是无法继续的.
这时我们便需要用到fa数组了,我们把fa数组初始化为每种颜色的编号，当每次启发式合并的合并顺序和当前所给不同时，我们便交换两种颜色的fa数组，我们让fa[1]=2,fa[2]=1这样每次对1，2，操作对fa进行操作。便可以避免出现上述情况。			
			*/
			if(!head[c[i]])
				st[c[i]]=i;
			sz[c[i]]++;
			nex[i]=head[c[i]];
			head[c[i]]=i;
		}
		int q;
		for(int i=1;i<=m;i++){
			q=read();
			if(q==2){
				cout<<ans<<endl;
			}
			else{
				x=read();
				y=read();
				if(fa[x]==fa[y]){
					continue;
				}
				if(sz[fa[x]]>sz[fa[y]]){
					swap(fa[x],fa[y]);//这一步交换非常重要。
				}
				if(!sz[fa[x]])
					continue;
				add(fa[x],fa[y]);				
			}
		}
	return 0;
}
```

---


# [HNOI2013] 消毒

## 题目描述


最近在生物实验室工作的小 T 遇到了大麻烦。 由于实验室最近升级的缘故，他的分格实验皿是一个长方体，其尺寸为 $a\times b\times c$。为了实验的方便，它被划分为 $a\times b\times c$ 个单位立方体区域，每个单位立方体尺寸为 $1\times 1\times 1$，并用 $(i,j,k)$ 标识一个单位立方体。这个实验皿已经很久没有人用了。现在，小 T 被导师要求将其中一些单位立方体区域进行消毒操作（每个区域可以被重复消毒）。

而由于严格的实验要求，他被要求使用一种特定的 F 试剂来进行消毒。 这种 F 试剂特别奇怪，每次对尺寸为 $x\times y\times z$ 的长方体区域（它由 $x\times y\times z$ 个单位立方体组成）进行消毒时，只需要使用 $\min(x,y,z)$ 单位的 F 试剂。F 试剂的价格不菲，这可难倒了小 T。

现在请你告诉他，最少要用多少单位的 F 试剂。

## 说明/提示

#### 样例 1 解释
对于区域 $(1,1,3)-(2,2,4)$ 和 $(1,1,1)-(4,4,1)$ 消毒，分别花费 $2$ 个单位和 $1$ 个单位的 F 试剂。

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1\le a,b,c\le 5\times 10^3$，$abc\le 5\times 10^3$，且 $1\le D\le 3$。


## 样例 #1

### 输入

```
1
4  4 4
1  0 1 1
0  0 1 1
0  0 0 0
0  0 0 0
0  0 1 1
1  0 1 1
0  0 0 0
0  0 0 0
0  0 0 0
0  0 0 0
1  0 0 0
0  0 0 0
0  0 0 0
0  0 0 0
0  0 0 0
1  0 0 0```

### 输出

```
3```

# 题解

## 作者：poorpool (赞：40)

**前置技能：poj3041**


-----

如果是二维平面有一些方块，这些方块被染了黑色，你每次可以选择 $(x,y)$ 的区域染成白色，代价是 $\min(x,y)$，问你付出的最小代价

![fig1](http://images2017.cnblogs.com/blog/1277233/201801/1277233-20180119111451443-2114357869.png)

显然我们不会这么染

![fig2](http://images2017.cnblogs.com/blog/1277233/201801/1277233-20180119111514021-339786142.png)

因为这样我们的代价是 $\min(x,y)$，为了研究的方便我们假设 $x$ 比 $y$ 小，那我们就相当于染 $x$ 次 $1 \times y$ 的区域，因此一次染一片总是不如一次染一条的。下面这么染就很好

![fig3](http://images2017.cnblogs.com/blog/1277233/201801/1277233-20180119111759881-409408222.png)

所以我们建立二分图，对于每个黑色块 $(x,y)$，我们将其处于第一部的 $x$ 与处于第二部的 $y$ 连接，求一个最小点覆盖。二分图中最小点覆盖=最大匹配，就得到了答案。

![fig4](http://images2017.cnblogs.com/blog/1277233/201801/1277233-20180119112710099-418777145.png)


-----

回到本题，题目中扩展到了三维空间，我们也有类似的想法。然而我们并不会三分图匹配这种东西……

观察到 $abc \leq 5000$，反证法可以轻易地证出 $a,b,c$ 中有一个 $\leq \sqrt[3]{5000} \approx 17.1$，为了研究方便我们钦定是 $a \leq \sqrt[3]{5000}$，这样就暴力枚举 $1\ldots a$ 中的某一层是直接削掉还是一会儿再处理（只有这两种情况，别的都不好，想一想为什么）。

对于没有被直接削掉的层，我们把它们剥离出来，然后**拍扁**成二维平面上的问题求解。


-----
代码。跑得不是很快，借鉴了一下网上的代码

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
using namespace std;
int T, hea[5005], cnt, a, b, c, minn, sx[4][5005], uu, ans, lnk[5005], qaq;
bool isn[5005], qwq[25], vis[5005];
struct Edge{
    int too, nxt;
}edge[5005];
void add_edge(int fro, int too){
    edge[++cnt].nxt = hea[fro];
    edge[cnt].too = too;
    hea[fro] = cnt;
}
bool dfs(int x){
    for(int i=hea[x]; i; i=edge[i].nxt){
        int t=edge[i].too;
        if(!vis[t]){
            vis[t] = true;
            if(!lnk[t] || dfs(lnk[t])){
                lnk[t] = x;
                return true;
            }
        }
    }
    return false;
}
void work(int x){
    for(int i=1; i<=b; i++)    hea[i] = 0;
    cnt = 0;
    for(int i=1; i<=c; i++)    lnk[i] = 0;
    int tmp=0;
    for(int i=0; i<a; i++){
        if(x&(1<<i))    qwq[i+1] = false, tmp++;
        else    qwq[i+1] = true;
    }
    for(int i=1; i<=qaq; i++)
        if(qwq[sx[1][i]])
            add_edge(sx[2][i], sx[3][i]);
    for(int i=1; i<=b; i++){
        for(int j=1; j<=c; j++)    vis[j] = false;
        if(dfs(i))    tmp++;
    }
    ans = min(tmp, ans);
}
int main(){
    cin>>T;
    while(T--){
        qaq = 0;
        ans = 0x3f3f3f3f;
        scanf("%d %d %d", &a, &b, &c);
        minn = min(a, min(b, c));
        for(int i=1; i<=a; i++)
            for(int j=1; j<=b; j++)
                for(int k=1; k<=c; k++){
                    scanf("%d", &uu);
                    if(!uu)    continue;
                    sx[1][++qaq] = i;
                    sx[2][qaq] = j;
                    sx[3][qaq] = k;
                }
        if(minn==b)    swap(a, b), swap(sx[1], sx[2]);
        else if(minn==c)    swap(a, c), swap(sx[1], sx[3]);
        for(int i=0; i<(1<<a); i++)
            work(i);
        printf("%d\n", ans);
    }
    return 0;
}
```

---

## 作者：xyz32768 (赞：8)

先考虑一个平面上的问题：

平面上有$n$个点，消除一个$x*y$的矩形里的所有点需要用$min(x,y)$的代价，求消除所有点的最小代价。

在这里，我们可以发现，在这里用$min(x,y)$条竖线或横线就可以覆盖一个$x*y$的矩形。这样就变成了二分图最小点覆盖的裸题，套模板即可。


回到问题。同样也可以将问题理解为以下模型：

空间内有$n$个点，每一次操作可以消除一个面上所有的点，求消除所有点的最少操作次数。

但是这是三维的，所以不能简单地求最小点覆盖。怎么做呢？

看到题目中有$a*b*c<=5000$，也就意味着$a,b,c$中至少有一个不大于$17$。所以就先暴搜对应的轴上的不大于$17$个面是否被操作（对应的面上的所有点被消除），然后求最小点覆盖来更新答案。

同时注意：此题时限卡得较紧，请注意一些常数优化。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
const int N = 5005, E = 23, INF = 0x3f3f3f3f;
int n, D[5], pos, ecnt, nxt[N], adj[N], go[N], val[N], my[N],
X[N][5], Ans, cnt, vis[N], times;
bool sel[E];
void add_edge(int u, int v, int w) {
    nxt[++ecnt] = adj[u]; adj[u] = ecnt; go[ecnt] = v; val[ecnt] = w;
}
bool dfs(int u) {
    for (int e = adj[u], v; e; e = nxt[e])
        if (!sel[val[e]] && vis[v = go[e]] < times) {
            vis[v] = times;
            if (!my[v] || dfs(my[v])) {
                my[v] = u;
                return 1;
            }
        }
    return 0;
}
int solve(int tt) {
    int i, j, ans = 0;
    for (i = 1; i <= cnt; i++) my[i] = 0;
    for (i = 1; i <= cnt; i++) {
        times++;
        if (dfs(i)) ans++;
        if (tt + ans >= Ans) return tt + ans;
    }
    return tt + ans;
}
void Dfs(int dep, int tt) {
    if (dep > D[pos]) return (void) (Ans = min(Ans, solve(tt)));
    sel[dep] = 1; Dfs(dep + 1, tt + 1);
    sel[dep] = 0; Dfs(dep + 1, tt);
}
void work() {
    int i, j, k, x; n = 0; Ans = INF; cnt = 0;
    pos = 1; D[1] = read(); D[2] = read(); D[3] = read();
    if (D[2] < D[pos]) pos = 2; if (D[3] < D[pos]) pos = 3;
    for (i = 1; i <= 3; i++) if (i != pos) cnt = max(cnt, D[i]);
    for (i = 1; i <= D[1]; i++) for (j = 1; j <= D[2]; j++)
    for (k = 1; k <= D[3]; k++) {
        x = read(); if (x) X[++n][1] = i, X[n][2] = j, X[n][3] = k;
    }
    ecnt = 0; for (i = 1; i <= cnt; i++) adj[i] = 0;
    for (i = 1; i <= n; i++) {
        if (pos == 1) add_edge(X[i][2], X[i][3], X[i][1]);
        else if (pos == 2) add_edge(X[i][1], X[i][3], X[i][2]);
        else add_edge(X[i][1], X[i][2], X[i][3]);
    }
    printf("%d\n", (Dfs(1, 0), Ans));
}
int main() {
    int T = read();
    while (T--) work();
    return 0;
}
```

---

## 作者：Yanami_Anna (赞：6)

首先因为我们清空一个长方体区域只取长宽高三个参数中的最小值，所以我们考虑把这个最小值做到最小，然后别的值做到最大，也就是说我们一次剖开一层所有点然后全部清空肯定是最优的。

我们考虑这个问题的二维版本，也就是在一个平面上有一些点，一次可以消一行或一列，问你最少消多少次可以全消完。

这个问题非常的经典，你考虑一个点如果要被消掉，肯定是他的行或者是他的列来踩他一脚，那就行列连边然后跑一手二分图最小点覆盖就做完了。

现在来到三维版本，仍然是一个点，要被三个维度踩，你说我连个三元环然后最小点覆盖行不，显然是不行的因为这个是 NP。

那我们怎么挑战 NP 问题呢？实际上，我们考虑整个大长方体的长宽高的乘积是在 $5\times 10^3$ 以内，那最小的那个维度有多大？最大也就是 $17$ 了，再大一点就比 $5\times 10^3$ 还要大了。

这个数据范围启发我们直接暴力枚举最小的维度的每一层是踩还是不踩，然后把剩下的点拍扁成二维的我们熟悉的问题就能解决掉他了。

我们考虑分析时间复杂度的上界，很明显当 $a=b=c=17$ 的时候能够取到上界，如果你跑匈牙利算出来应该是很难跑过一秒，跑迪尼茨的话上界算出来应该是 $2\times 10^8$ 的，也要猛卡才能通过。

---

## 作者：是个汉子 (赞：4)

[洛谷传送门](https://www.luogu.com.cn/problem/P3231)

### Solution

##### 先考虑二维

对于一个点 $(x,y)$ ，要么是在第 $x$ 列被消毒，要么是在第 $y$ 列被消毒，考虑二分图匹配，左边是列，右边是行，求最小点覆盖即可。

##### 回到三维

显然三分图匹配是不可的，所以要看看别的东西。

题目中给了 $abc\leq 5000$ ，也就是 $\min\{a,b,c\}\leq \sqrt[3] {5000}\approx 17$ ，所以可以枚举最小的一维，判断是将一层全部消掉还是留下，然后再将剩下的拍成一个二维平面（或者说，将枚举的那一位坐标去掉），按上面二维方法求解即可。

### Code

```c++
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
struct lsqy{
	int next,to;
}q[5010];
int a,b,c,ys[5101];
int dir[4][5101],tot; 
int match[5001],vis[5100],head[5101],cnt;
int ans=2147483644;
void add(int x,int y)
{
	q[++cnt].next=head[x];
	head[x]=cnt;
	q[cnt].to=y;
}
bool dfs(int u)
{
	for(int i=head[u];i;i=q[i].next)
	{
		int v=q[i].to;
		if(!vis[v])
		{
			vis[v]=1;
			if(dfs(match[v])||!match[v])
			{
				match[v]=u;
				return 1;
			}
		}
	}
	return 0;
}
void work(int s)
{
	for(int i=1;i<=b;++i)
	  head[i]=0;
	for(int j=1;j<=c;++j)
	  match[j]=0;
	cnt=0;
	int con=0;
	//memset(ys,0,sizeof(ys));
    for(int i=1;i<=a;++i)
	  if((1<<(i-1))&s) ys[i]=0,con++;
	    else ys[i]=1;
    for(int i=1;i<=tot;++i)
      if(ys[dir[1][i]])
        add(dir[2][i],dir[3][i]);
    for(int i=1;i<=b;++i)
    {
      for(int j=1;j<=c;++j)
        vis[j]=0;
      //memset(vis,0,sizeof(vis));
	  if(dfs(i)) con++;   
	}
	ans=min(ans,con); 
} 
int main()
{
	int T_T,minn;
	scanf("%d",&T_T);
	while(T_T--)
	{
		tot=0;
		minn=ans=2147483644;
		scanf("%d%d%d",&a,&b,&c);
		minn=min(a,min(b,c));
		for(int i=1;i<=a;++i)
		  for(int j=1;j<=b;++j)
		    for(int k=1;k<=c;++k)
		      {
		      	int x;
		      	scanf("%d",&x);
		      	if(!x) continue;
		      	tot++;
				dir[1][tot]=i;
		      	dir[2][tot]=j;
		      	dir[3][tot]=k;
			  }
		  if(minn=b) swap(b,a),swap(dir[1],dir[2]);
		    else if(minn=c)  swap(c,a),swap(dir[1],dir[3]);
		for(int i=0;i<=(1<<a)-1;++i)
		  work(i);
		printf("%d\n",ans);
	}
	
 } 
```

感谢[bored](https://www.luogu.com.cn/user/230202)的精彩代码

---

## 作者：muller (赞：4)

这题好像没有网络流题解，补一发！

好像比较毒瘤，就是把它排到一个平面上，~~状态压缩~~

就这样，就完事了，然后做一下二分图匹配，顺带模拟一下那些取，与不取

不会的可以百度百科...

记得初始一个值的时候要care

不要memset吧！（。。。。。。）

好像会tle qwq qwq

当然我也没试过！反证有点代码难度qwq
code:
```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
#define fi first
#define se second
#define mp make_pair
using namespace std;
typedef pair <int, int> P;
const int N = 5005, M = 80005, INF = 1e9;
int fir[N], cur[N], to[M], nxt[M], len[M], inv[M], depth[N], q[N], rec[4][N];
int a, b, c, ss, tt, l, r, mn, ans, size, ecnt, tot;
bool p[N], vis[N]; P e[N];
template <class T> void cmax(T &x, T y) {x = max(x, y);}
template <class T> void cmin(T &x, T y) {x = min(x, y);}
template <class T> void rd(T &x) {
    char c = getchar(); int f = 1; x = 0;
    for (; !isdigit(c); c = getchar()) if (c == '-') f = -1;
    for (; isdigit(c); c = getchar()) x = x * 10 + c - '0';
    x *= f;
}
void ae(int u, int v, int w) {
    to[++ecnt] = v; nxt[ecnt] = fir[u]; len[ecnt] = w; inv[ecnt] = ecnt + 1; fir[u] = ecnt;
    to[++ecnt] = u; nxt[ecnt] = fir[v]; len[ecnt] = 0; inv[ecnt] = ecnt - 1; fir[v] = ecnt;
}
bool make_level() {
    int i; for (i = ss; i <= tt; ++i) cur[i] = fir[i];
    vis[q[l = r = 1] = ss] = true, depth[ss] = 1;
    while (l <= r) {
        int u = q[l++];
        for (i = fir[u]; i; i = nxt[i]) {
            int v = to[i], w = len[i];
            if (!vis[v] && w) vis[q[++r] = v] = true, depth[v] = depth[u] + 1;
        }
    }
    bool flag = vis[tt];
    for (i = 1; i <= r; ++i) vis[q[i]] = false; 
    return flag;
}
int dinic(int u, int lim) {
    if (u == tt) return lim;
    int i, ret = 0;
    for (i = cur[u]; i; i = nxt[i]) {
        int v = to[i], w = len[i];
        if (depth[v] == depth[u] + 1 && w) {
            int tmp = dinic(v, min(w, lim));
            len[i] -= tmp; len[inv[i]] += tmp;
            lim -= tmp; ret += tmp;
            if (!lim) {cur[u] = i; return ret;}
        }
    }
    cur[u] = 0; return ret;
}
void work(int x) {
    int i, mx, res; size = res = mx = 0;
    for (i = 0; i < a; ++i)
        if (x & (1 << i)) p[i + 1] = false, ++res;
        else p[i + 1] = true;
    for (i = 1; i <= tot; ++i)
        if (p[rec[1][i]]) e[++size] = mp(rec[2][i], rec[3][i]);
    for (i = 1; i <= size; ++i) cmax(mx, e[i].fi), cmax(mx, e[i].se);
    ss = 0, tt = mx << 1 | 1; memset(fir, ecnt = 0, sizeof(fir));
    for (i = 1; i <= mx; ++i) ae(ss, i, 1), ae(i + mx, tt, 1);
    for (i = 1; i <= size; ++i)	ae(e[i].fi, e[i].se + mx, 1);
    while (make_level()) res += dinic(ss, INF);
    cmin(ans, res);
}
void solve() {
    int i, j, k;
    tot = 0, ans = INF; rd(a); rd(b); rd(c); mn = min(min(a, b), c);
    for (i = 1; i <= a; ++i)
        for (j = 1; j <= b; ++j)
            for (k = 1; k <= c; ++k) {
                int x; rd(x);
                if (!x) continue;
                rec[1][++tot] = i, rec[2][tot] = j, rec[3][tot] = k;
            }
    if (mn == b) swap(a, b), swap(rec[1], rec[2]);
    else if (mn == c) swap(a, c), swap(rec[1], rec[3]);
    for (i = 0; i < (1 << a); ++i) work(i);
    printf("%d\n", ans);
}
int main() {
    int T; rd(T);
    while (T--) solve();
    return 0;
}

```

---

## 作者：凑个热闹吖 (赞：1)

### [[HNOI2013]消毒](https://www.luogu.com.cn/problem/P3231)

我的这种写法应该是目前的最优解~~（虽然好像也没快多少）~~。

![](https://cdn.luogu.com.cn/upload/image_hosting/f0gab2ll.png)

这道题貌似不能用 Dinic，用 Dinic 每次枚举好像都要重新建图，最后导致时间复杂度到了 $O(2^{17}abc)$，题解好多用 Dinic 的理论时间复杂度都应该是不对的，数据还是水了。

用匈牙利算法的时候设置一个边权，再利用边权判断这条边是否连通的话就不用重新建图。

[参考题解](https://www.luogu.com.cn/blog/user29936/solution-p3231)

# Solution

不妨令 $a \leq b \leq c$，且将 $a$ 看作长方体的高。

先考虑二维平面 $b \times c$，很显然每次我们使用 $1 \times b$ 或者 $1 \times c$ 的矩形覆盖必然是最优的，这样就变成了一道二分图最小点覆盖问题。

对于平面上的每一个点 $(x , y)$，我们将左边的 $x$ 连向右边的 $y$，这样每一条边就代表一个点，然后跑一遍二分图最小点覆盖即可。

举个例子，有如下的点。

```
（1号点）   （1，3）
（2号点）   （2，3）
（3号点）   （1，2）
（4号点）   （3，1）
（5号点）   （1，1）
```

最后建出来的二分图应该是这样的。

![](https://cdn.luogu.com.cn/upload/image_hosting/0a1r503p.png)

跑一遍二分图最小点覆盖，如果选了左边的 $i$ 号点，也就意味着用 $1 \times c$ 的矩形将 $i$ 这一行全部覆盖掉。右边同理。最后跑出来的就是这清理一个平面需要的花费。

回到三维，由于 $abc \leq 5000$，所以 $a \leq 17$。我们可以二进制枚举这一层是否直接用 $1 \times b \times c$ 花费为 $1$ 的长方体直接将这一层清理干净。对于不直接清理干净的那些层，把它拍扁成二维，然后用上面讲的处理二维的方法进行处理。

为什么可以拍扁成二维一起清理？显然我们可以用 $a \times b \times 1$ 或者 $a \times 1 \times c$ 的长方体进行覆盖，也就是即使两个需要清理的点不在同一层，但如果它们在同一行或者同一列，我们同时处理掉它们的花费还是为 $1$。

这样这道题就可以解决了。

开头讲的，用 Dinic 的话每次都要重新建图，理论上时间复杂度应该不能过。用匈牙利算法，连边的时候边权设为这个点所在的层的编号，这样我们求二分图最小点覆盖的时候就可以根据这条边的边权判断这条边存不存在（也就是这条边所代表的点有没有被直接清理掉）。

# Code

```cpp
#include<bits/stdc++.h>
#define rep(i , m , n) for(register int i = m; i <= n; i++)

using namespace std;
const int INF = 0x3f3f3f3f;
int read(){
	int x = 0 , f = 1;
	char c = getchar();
	while(c < '0' || c > '9')f = (c == '-') ? -1 : 1 , c = getchar();
	while(c >= '0' && c <= '9')x = (x << 3) + (x << 1) + (c ^ 48) , c = getchar();
	return x * f;
}
struct Edge{
	int v , w , nex;
}e[5005];
int h[5005];
int tot = 0;
void Add(int u , int v , int w){
	++tot;
	e[tot].v = v , e[tot].w = w;
	e[tot].nex = h[u] , h[u] = tot;
}
int a , b , c;
int n;
int p[5005][4];
int sl[5005];
int vis[5005] , pai[5005];
int times = 1;
bool Match(int u){
	for(int i = h[u]; i; i = e[i].nex){
		int v = e[i].v , w = e[i].w;
		if(sl[w] || vis[v] == times)continue;  //sl[w]用于判断这个点是否被直接清理 
		vis[v] = times;
		if(!pai[v] || Match(pai[v])){
			pai[v] = u;
			return 1;
		}
	}
	return 0;
}
int calc(){
	rep(i , 1 , max(a , max(b , c)))pai[i] = 0;  //初始化，用memset会超时 
	int cnt = 0;
	rep(i , 1 , max(a , max(b , c))){
		times++; //对vis用memset清零会超时，所以用times累计避免初始化 
		if(Match(i))cnt++;
	}
	return cnt;
}
int main(){
	int Q = read();
	while(Q--){
		memset(h , 0 , sizeof h);
		memset(vis , 0 , sizeof vis);
		tot = 0;
		int ans = INF;
		n = 0;
		a = read() , b = read() , c = read();
		int Min = min(a , min(b , c)) , pos = (Min == a) ? 1 : ((Min == b) ? 2 : 3); //将a,b,c中最小的看作高，以免二进制枚举超时 
		rep(i , 1 , a) rep(j , 1 , b) rep(k , 1 , c){
			int x = read();
			if(x)p[++n][1] = i , p[n][2] = j , p[n][3] = k;
		}
		if(pos == 1)rep(i , 1 , n)Add(p[i][2] , p[i][3] , p[i][1]);  //连边，并将边权设为所在层的编号 
		if(pos == 2)rep(i , 1 , n)Add(p[i][1] , p[i][3] , p[i][2]);
		if(pos == 3)rep(i , 1 , n)Add(p[i][1] , p[i][2] , p[i][3]);
		for(int d = 0; d <= (1 << Min) - 1; d++){  //枚举那些层直接清理掉 
			int tmp = 0;
			rep(i , 0 , Min - 1)  //处理出那些层被直接清理掉 
				if(d & (1 << i))sl[i + 1] = 1 , tmp++;
				else			sl[i + 1] = 0;
			int temp = tmp + calc();
			ans = min(ans , temp);
		}
		printf("%d\n" , ans);
	}
	return 0;
} 
```


---

## 作者：Fzrcy (赞：1)

明显的，每次清洗用 $1\times x\times y$ 是最优的，考虑反证：若最优解用 F 试剂清洗了大小为 $x\times y\times z$ 的长方体（$x\le y\le z$）,也可以拆分为 $x$ 个大小为 $1\times y\times z$ 的长方体，代价不变。

因为 $abc\le 5\times 10^3$，所以 $\min(a,b,c)\le 17$，考虑将最小的一维暴力枚举将其变成二维平边问题，每一次操作将其中一行或一列清洗干净，代价为一，换个说法，就是选择尽量少的行和列，使得每个要清洗的点被至少覆盖依次，即二分图最小覆盖问题，直接建立行与列的二分图，跑最大匹配即可。

```cpp
#include <bits/stdc++.h>
#define rep(i, aa, bb) for(int i=(aa); i<=(bb); i++)
using namespace std;

struct Node{int x, y, z;};

const int N=2e4+11;
int aa, bb, cc, ncnt;
Node a[N];
int match[N], vis[N], tim;
int h[N], nt[N<<1], to[N<<1], cnt;

void link(int u, int v){
    nt[++cnt]=h[u], h[u]=cnt, to[cnt]=v;
}

bool dfs(int u){
    for(int i=h[u]; i; i=nt[i]){
        int v=to[i];
        if(vis[v]==tim) continue;
        vis[v]=tim;
        if(!match[v]||dfs(match[v])){
            match[v]=u; return true;
        }
    }
    return false;
}

int solve(int Do){
    rep(i, 1, cc) match[i]=0; rep(i, 1, bb) h[i]=0; cnt=0; int ans=0;

    rep(i, 1, ncnt)if((Do&(1<<(a[i].x-1)))==0)link(a[i].y, a[i].z);

    rep(i, 1, bb) tim++, ans+=dfs(i);

    rep(i, 1, aa) ans+=(((Do)>>(i-1))&1);

    return ans;
}

int solution(){
    scanf("%d %d %d", &aa, &bb, &cc);
//    printf("%d %d %d\n", aa, bb, cc);
    ncnt=0;
    rep(i, 1, aa) rep(j, 1, bb) rep(k, 1, cc){
        static int x; scanf("%d", &x);
        if(x==1) a[++ncnt]={i, j, k};
    }

    int mn=min(aa, min(bb, cc));
    if(mn==bb) {swap(aa, bb); rep(i, 1, ncnt) swap(a[i].y, a[i].x);}
    else
    if(mn==cc) {swap(aa, cc); rep(i, 1, ncnt) swap(a[i].y, a[i].x);}

    int ans=0x3f3f3f3f;
    for(int i=0, j=(1<<aa)-1; i<=j; i++) ans=min(ans, solve(i));

    printf("%d\n", ans);

    return 0;
}

int main(){
    int T;
    scanf("%d", &T);
    while(T--)
        solution();
    return 0;
}
```

---

## 作者：Z1qqurat (赞：0)

假定 $x \le y \le z$。首先不难发现，因为使用 $x \times y \times z$ 体积时只需要使用 $\min(x, y, z)$ 单位的试剂，所以我们可以每次使用一区域的试剂时，使 $x = 1$，那么 $y$ 和 $z$ 就可以取无限大。所以我们对于每个需要被清洁的立方体 $(i, j, k)$，都是三种方案：从三维坐标系上 $x$ 轴，$y$ 轴，$z$ 轴三种方向覆盖，三分图匹配问题。

但是三分图匹配咱没法做，考虑选定一维枚举其状态，然后其余的就只剩下两维，跑二分图最小点覆盖即可。就是说，在 $a \times b \times c$ 的大立方体中，假设 $c \le b \le a$，那么我们有 $c$ 个位置可以摆放 $a \times b \times 1$ 的区域。然后我们 $2 ^ c$ 次方枚举这 $c$ 个区域是否被摆放，已经被这种 $a \times b \times 1$ 区域覆盖的立方体不管，剩下的立方体就只有两种覆盖的方式了，可以简单二分图最小点覆盖。$\min(a, b, c) \le 17$，然后后面二分图建图匹配的实现稍微精细一些即可。

有一些实现细节：

* 输入 $a \times b \times c$ 的立方体的信息，但是只给出 $a \times b \times c \le 5000$ 这没法存啊。所以我们用一个结构体数组储存有需要清洁的立方体的信息即可。
* 为了方便实现，我们使 $c = \min(a, b, c)$，那么如果 $\min(a, b, c) = a$ 的时候我们就把结构体数组里面存储的 $x$ 和 $z$ 互换即可。$\min(a, b, c) = a$ 同理。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <vector>
#include <set>
#define ll long long
#define pii pair<int, int>
using namespace std;
const int N = 5e3 + 5, M = 30;
int a, b, c, t, match[N], vis[N], m, ans = 11451419, n;
bool chs[M];
vector <int> G[N];
struct node{
    int x, y, z;
}mat[N];

bool Hungary(int u, int tim) {
    for (int i = 0; i < G[u].size(); ++i) {
        int v = G[u][i];
        if(vis[v] == tim) continue;
        vis[v] = tim;
        if(!match[v] || Hungary(match[v], tim)) {
            match[v] = u;
            return 1;
        }
    }
    return 0;
}

void build(int stat) {
    int cnt = 0;
    memset(chs, 0, sizeof(chs));
    for (int i = 1; i <= c; ++i) {
        int j = stat % 2; stat /= 2;
        chs[i] = j; cnt += j;
    }
    for (int i = 0; i <= a * b; ++i) {
        G[i].clear(); match[i] = vis[i] = 0;
    }
    for (int i = 1; i <= n; ++i) {
        if(chs[mat[i].z]) continue;
        G[mat[i].x].push_back(mat[i].y);
    }
    for (int i = 1; i <= a; ++i) {
        cnt += Hungary(i, i);
    }
    ans = min(ans, cnt);
    return ;
}

void solve() {
    scanf("%d %d %d", &a, &b, &c);
    n = 0, ans = 11451419;
    for (int i = 1; i <= a; ++i) {
        for (int j = 1; j <= b; ++j) {
            for (int k = 1; k <= c; ++k) {
                bool bl; cin >> bl;
                if(bl) {
                    n++;
                    mat[n].x = i, mat[n].y = j, mat[n].z = k;
                }
            }
        }
    }
    int mn = min(a, min(b, c));
    if(mn == a) {
        swap(a, c);
        for (int i = 1; i <= n; ++i) swap(mat[i].x, mat[i].z);
    }
    else if(mn == b) {
        swap(b, c);
        for (int i = 1; i <= n; ++i) swap(mat[i].y, mat[i].z);
    }
    for (int i = 0; i < (1 << c); ++i) {
        build(i);
    }
    printf("%d\n", ans);
    return ;
}

int main() {
    scanf("%d", &t);
    while(t--) solve();
    return 0;
}
```



---

## 作者：Coros_Trusds (赞：0)

# 题目大意

最近在生物实验室工作的小 $\textbf T$ 遇到了大麻烦。 由于实验室最近升级的缘故，他的分格实验皿是一个长方体，其尺寸为 $a\times b\times c$。为了实验的方便，它被划分为 $a\times b\times c$ 个单位立方体区域，每个单位立方体尺寸为 $1\times 1\times 1$，并用 $(i,j,k)$ 标识一个单位立方体。这个实验皿已经很久没有人用了。现在，小 $\textbf T$ 被导师要求将其中一些单位立方体区域进行消毒操作（每个区域可以被重复消毒）。

而由于严格的实验要求，他被要求使用一种特定的 $\textbf F$ 试剂来进行消毒。 这种 F 试剂特别奇怪，每次对尺寸为 $x\times y\times z$ 的长方体区域（它由 $x\times y\times z$ 个单位立方体组成）进行消毒时，只需要使用 $\min(x,y,z)$ 单位的 $\textbf F$ 试剂。$\textbf F$ 试剂的价格不菲，这可难倒了小 $\textbf T$。

现在请你告诉他，最少要用多少单位的 $\textbf F$ 试剂。

$1\le a,b,c\le 5\times 10^3,a\times b\times c\le 5\times 10^3$。

# 题目分析

当这是个二维平面时，我们一定是一条一条地染的，因为一条一条地染可是使得 $\min\{x,y\}=1$。所以我们的问题转换成了：

给定一个二维平面，其中有一些特殊位置，选最少的几行或几列把这些位置覆盖住。这就是一个最小点覆盖问题，我们把行拆成左部点，列拆成右部点，特殊位置的行、列坐标连边，最后跑最小点覆盖即可。

但这里是三维平面。

注意到 $1\le a,b,c\le 5\times 10^3,a\times b\times c\le 5\times 10^3$，所以一定有 $1\le \min\{a,b,c\}\le 17$。所以我们可以通过状压枚举 $\min$ 这一维的状态（$1$ 表示直接切掉，$0$ 表示暂时留着）。剩下的我们用二向箔把它干扁看成二维平面跑最小点覆盖即可。

# 代码

```cpp
// Problem: P3231 [HNOI2013]消毒
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P3231
// Memory Limit: 125 MB
// Time Limit: 1000 ms
// Date:2022-06-10 21:17
// 
// Powered by CP Editor (https://cpeditor.org)

#include <iostream>
#include <cstdio>
#include <climits>//need "INT_MAX","INT_MIN"
#include <cstring>//need "memset"
#include <numeric>
#include <algorithm>
#include <cmath>
#define enter putchar(10)
#define debug(c,que) std::cerr << #c << " = " << c << que
#define cek(c) puts(c)
#define blow(arr,st,ed,w) for(register int i = (st);i <= (ed); ++ i) std::cout << arr[i] << w;
#define speed_up() std::ios::sync_with_stdio(false),std::cin.tie(0),std::cout.tie(0)
#define mst(a,k) memset(a,k,sizeof(a))
#define stop return(0)
const int mod = 1e9 + 7;
inline int MOD(int x) {
	if(x < 0) x += mod;
	return x % mod;
}
namespace Newstd {
	char buf[1 << 21],*p1 = buf,*p2 = buf;
	inline int getc() {
		return p1 == p2 && (p2 = (p1 = buf) + fread(buf,1,1 << 21,stdin),p1 == p2) ? EOF : *p1 ++;
	}
	#define getchar getc
	inline int read() {
		int ret = 0,f = 0;char ch = getchar();
		while (!isdigit(ch)) {
			if(ch == '-') f = 1;
			ch = getchar();
		}
		while (isdigit(ch)) {
			ret = (ret << 3) + (ret << 1) + ch - 48;
			ch = getchar();
		}
		return f ? -ret : ret;
	}
	inline double double_read() {
		long long ret = 0,w = 1,aft = 0,dot = 0,num = 0;
		char ch = getchar();
		while (!isdigit(ch)) {
			if (ch == '-') w = -1;
			ch = getchar();
		}
		while (isdigit(ch) || ch == '.') {
			if (ch == '.') {
				dot = 1;
			} else if (dot == 0) {
				ret = (ret << 3) + (ret << 1) + ch - 48;
			} else {
				aft = (aft << 3) + (aft << 1) + ch - '0';
				num ++;
			}
			ch = getchar();
		}
		return (pow(0.1,num) * aft + ret) * w;
	}
	inline void write(int x) {
		if(x < 0) {
			putchar('-');
			x = -x;
		}
		if(x > 9) write(x / 10);
		putchar(x % 10 + '0');
	}
}
using namespace Newstd;

const int INF = 0x3f3f3f3f;
const int N = 5005,M = 18;
struct Graph {
	int v,nxt;
} gra[N];
int head[N],vis[N],mat[N],maps[3][N];
bool exist[M];
int T,a,b,c,siz,idx,nowidx,ans;
inline void add(int u,int v) {
	gra[++ idx] = (Graph){v,head[u]},head[u] = idx;
}
inline void init() {
	siz = 0,ans = INF;
}
inline bool dfs(int now) {
	for (register int i = head[now];i;i = gra[i].nxt) {
		int v = gra[i].v;
		if (vis[v] != nowidx) {
			vis[v] = nowidx;
			if (!mat[v] || dfs(mat[v])) {
				mat[v] = now;
				return true;
			}
		}
	}
	return false;
}
inline void hungary(int x) {
	for (register int i = 1;i <= c; ++ i) vis[i] = mat[i] = 0;
	for (register int i = 1;i <= idx; ++ i) gra[i] = (Graph){0,0};
	for (register int i = 1;i <= b; ++ i) head[i] = 0;
	idx = nowidx = 0;
	int num = 0;
	for (register int i = 0;i < a; ++ i) {
		if (x & (1 << i)) {
			exist[i + 1] = false;
			num ++;
		} else {
			exist[i + 1] = true;
		}
	}
	for (register int i = 1;i <= siz; ++ i) {
		if (exist[maps[0][i]]) {
			add(maps[1][i],maps[2][i]);
		}
	}
	for (register int i = 1;i <= b; ++ i) {
		nowidx ++;
		if (dfs(i)) num ++;
	}
	ans = std::min(ans,num);
}
inline void solve() {
	a = read(),b = read(),c = read();
	for (register int i = 1;i <= a; ++ i) {
		for (register int j = 1;j <= b; ++ j) {
			for (register int k = 1;k <= c; ++ k) {
				int x = read();
				if (!x) continue;
				maps[0][++ siz] = i,maps[1][siz] = j,maps[2][siz] = k;
			}
		}
	}
	int minn = std::min(a,std::min(b,c));
	if (minn == b) {
		std::swap(a,b),std::swap(maps[0],maps[1]);
	} else if (minn == c) {
		std::swap(a,c),std::swap(maps[0],maps[2]);
	}
	for (register int i = 0;i < (1 << a); ++ i) hungary(i);
	printf("%d\n",ans);
}
int main(void) {
	T = read();
	while (T --) {
		init();
		solve();
	}
	
	return 0;
}
```

---

## 作者：Ryan_ (赞：0)

如果只有两维，那就是二分图最小点覆盖

现在是三维，但是a*b*c<=5000，说明最小的那一维不会超过17

将最小的那一维作为正方形的高

然后枚举要消哪些层，剩下的层看成一层 做最小点覆盖

注意卡常


```
#include<cstdio>
#include<cstring>
#include<iostream>

using namespace std;

#define N 5001

struct node
{
    int i,j,k;
}e[N];

bool have[18];

int front[N],to[N],nxt[N],tot;7

int match[N];
int tim,vis[N];

void read(int &x)
{
    x=0; char c=getchar();
    while(!isdigit(c)) c=getchar();
    while(isdigit(c)) { x=x*10+c-'0'; c=getchar(); }
}

bool go(int u)
{
    int v;
    for(int i=front[u];i;i=nxt[i])
    {
        v=to[i];
        if(vis[v]!=tim)
        {
            vis[v]=tim;
            if(!match[v] || go(match[v])) 
            {
                match[v]=u;
                return true;
            }
        }
    }
    return false;
}

int count(int x)
{
    int sum=0;
    while(x) sum+=x&1,x>>=1;
    return sum;
}

void add(int u,int v)
{
    to[++tot]=v; nxt[tot]=front[u]; front[u]=tot;
}

int main()
{
    int T,a,b,c;
    int ty,x;
    int S,cnt; bool tag;
    int ans,now;
    read(T);
    while(T--)
    {
        read(a); read(b); read(c);
        if(a<=b && a<=c) ty=1;
        else if(b<=a && b<=c) ty=2;
        else ty=3;
        memset(have,false,sizeof(have));
        cnt=0;
        for(int i=1;i<=a;++i)
            for(int j=1;j<=b;++j)
                for(int k=1;k<=c;++k)
                {
                    read(x);
                    if(!x) continue;
                    cnt++;
                    if(ty==1) e[cnt].i=i,e[cnt].j=j,e[cnt].k=k;
                    if(ty==2) e[cnt].i=j,e[cnt].j=i,e[cnt].k=k;
                    if(ty==3) e[cnt].i=k,e[cnt].j=i,e[cnt].k=j;
                    have[e[cnt].i]=true;
                }
        if(ty==2) swap(a,b);
        else if(ty==3) swap(b,c),swap(a,b);
        ans=a;
        S=1<<a;
        for(int s=0;s<S;++s)
        {
            tag=true;
            for(int i=1;i<=a && tag;++i)
                if(1<<i-1&s && !have[i]) tag=false;
            if(!tag) continue;
            now=count(s);
            tot=0;
            memset(front,0,sizeof(*front)*(b+1));
            for(int i=1;i<=cnt;++i)
                if(!(1<<e[i].i-1&s)) add(e[i].j,e[i].k);
            memset(match,0,sizeof(*match)*(c+1));
            for(int i=1;i<=b;++i)
            {
                tim++;
                if(go(i)) now++;
                if(now>=ans) break;
            }
            ans=ans<=now ? ans : now;
        }
        printf("%d\n",ans);
    }
}
```


---

## 作者：STrAduts (赞：0)

弱化一下，先考虑在二维上解决问题。

题目就转化为：有 $n$ 个点 $(i, j)$ 需要被覆盖，而我们每次可以选一行或一列去覆盖，求覆盖所有点的最少选择次数。

如果我们对于每一个 $(i, j)$，我们把第 $i$ 行和第 $j$ 列连边，显然能构成一张二分图。

图中每一条边就是一个需求，而每选择一个点就能解决掉所有与之相连的需求，答案就是解决所有需求最少需要选择的点数。这就是二分图上的最小点覆盖问题。

答案即为最大匹配数。

现在加入三维。因为 $a, b, c \leq 5 \times 10 ^ 3$，所以 $\min \{a, b, c\} \leq 13$。

那么我们可以考虑用最多 $2^{13}$ 的时间去枚举其中一维的选择，即枚举这一维上我们选择哪几条基准线先直接覆盖。

那么剩下的就是之前的二维做法了。注意每次枚举的时候应该枚举最小的那一位，这样才能保证复杂度。

二分图最大匹配使用匈牙利算法，在接近完全图的图中性能相比于 Dinic 会较好。

```cpp
#include <cstdio>

int Abs(int x) { return x < 0 ? -x : x; }
int Max(int x, int y) { return x > y ? x : y; }
int Min(int x, int y) { return x < y ? x : y; }

int read() {
    int x = 0, k = 1;
    char s = getchar();
    while(s < '0' || s > '9') {
        if(s == '-')
            k = -1;
        s = getchar();
    } 
    while('0' <= s && s <= '9') {
        x = (x << 3) + (x << 1) + (s ^ 48);
        s = getchar();
    }
    return x * k;
}

void write(int x) {
    if(x < 0) {
        x = -x;
        putchar('-');
    }
    if(x > 9)
        write(x / 10);
    putchar(x % 10 + '0');
}

void print(int x, char s) {
    write(x);
    putchar(s);
}

const int MAXN = 5e3 + 5;
const int MAXM = 2e5 + 5;
const int MAXL = 5e3 + 5;
const int INF = 2147483647;

    struct edge {
        int v, w, nxt;
        edge() {}
        edge(int V, int W, int Nxt) {
            v = V, w = W, nxt = Nxt;
        }
    } e[MAXM << 1];
    int head[MAXN], n, m, cnt;
    void Add_Edge(int u, int v, int w) { 
        e[cnt] = edge(v, w, head[u]);
        head[u] = cnt++;
    }
    bool Chose[MAXM << 1];
    int Mat[MAXN], Tim[MAXN], tot;

    void init(int N, int M) {
        for(int i = 0; i <= cnt; i++)  
            Chose[i] = false;
        n = N, m = M;
        for(int i = 1; i <= n; i++) 
            head[i] = -1, Tim[i] = 0, Mat[i] = 0;
        cnt = 0, tot = 0;
    }

    bool dfs(int u) {
        if (Tim[u] == tot)
            return false;        
        Tim[u] = tot;
        for (int i = head[u], v; ~i; i = e[i].nxt) {
            if(Chose[e[i].w])
                continue;
            v = e[i].v;
            if (!Mat[v] || dfs(Mat[v])) {
                Mat[v] = u;
                return true;
            }
        }
        return false;
    }

    int calc() {
        int ans = 0;
        for (int i = 1; i <= m; i++)
            Mat[i] = 0;
        for (int i = 1; i <= n; i++)
            Tim[i] = 0;
        for (int i = n; i >= 1; i--) {
            tot++;
            ans += dfs(i);
        }
        return ans;
    }    

bool vis[MAXN];
int q[MAXN], pos[5], len = 0, ans = INF, tot2 = 0, S, T;

void dfs2(int p) {
    if(p > pos[1]) {
        ans = Min(ans, calc() + tot2);
        return ;
    }
    Chose[p] = true;
    tot2++;
    dfs2(p + 1);
    Chose[p] = false;    
    tot2--;
    dfs2(p + 1);
}

int main() {
    int t = read();
    while(t--) {
        for(int i = 1; i <= 3; i++) 
            pos[i] = read();
        if(pos[1] > pos[2])
            pos[1] ^= pos[2] ^= pos[1] ^= pos[2];
        if(pos[2] > pos[3])
            pos[2] ^= pos[3] ^= pos[2] ^= pos[3];
        if(pos[1] > pos[2])
            pos[1] ^= pos[2] ^= pos[1] ^= pos[2];
        init(pos[2], pos[3]);
        len = 0, ans = INF, tot = 0;
        for(int i = 1, j, k, p; i <= pos[1]; i++) 
            for(j = 1; j <= pos[2]; j++)
                for(k = 1; k <= pos[3]; k++) {
                    p = (i - 1) * pos[2] * pos[3] + (j - 1) * pos[3] + k;
                    q[p] = read();
                    if(q[p]) 
                        Add_Edge(j, k, i);                       
                }      
        dfs2(1);
        print(ans, '\n');
    }
    return 0;
}
```

---


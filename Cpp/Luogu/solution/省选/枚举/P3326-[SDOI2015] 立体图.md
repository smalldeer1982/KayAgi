# [SDOI2015] 立体图

## 题目描述

小渊是个聪明的孩子，他经常会给周围的小朋友们讲些自己认为有趣的内容。最近，他准备给小朋友们讲解彩色水平光源照射下的立体图，并请你帮他在平面上画出来。

小渊有一块面积为m\*n的矩形区域，上面有m\*n个边长为1的格子，每个格子上堆了一些同样大小的积木（积木的长宽高都是1）。

为了方便阐述，我们假设这块区域是坐北朝南的，下面我们给出一个例子。

![](https://cdn.luogu.com.cn/upload/pic/22187.png)

小渊想请你打印出这些格子的立体图。我们定义每个积木为如下格式，并且不会做任何翻转旋转，只会严格以这一种形式摆放（左侧是应该打印出来的图样，右侧为对应每一个位置符号的十进制ASCII，其中ASCII为32的符号为空

![](https://cdn.luogu.com.cn/upload/pic/22188.png)

在良好的光学环境下，小渊将T束平行光同时照射在这些积木上。这些平行光首先满足一定是红绿蓝三基色之一，其次入射角度满足：与x轴y轴的夹角度数均为45的倍数；且与z轴正方向的夹角或为45度，或为0度，或为315度。

具体来说，我们最多会考虑9个方向的不同平行光，它们的入射方向可以被描述为：   西北方45度仰角  正北方45度仰角  东北方45度仰角   正西方45度仰角  垂直从上入射光  正东方45度仰角   西南方45度仰角  正南方45度仰角  东南方45度仰角对于每一个单位积木来说，可以打印出来的三个表面被分为12个小三角形，如下图所示（下图中用符号0,1,2,。。

![](https://cdn.luogu.com.cn/upload/pic/22189.png)

红绿蓝三基色分别用字母RGB来表示。而二次叠加后的三种颜色青黄紫，分别用CYP来表示。对于三次叠加后的颜色，也就是白色，用W来表示。



## 说明/提示

 
![](https://cdn.luogu.com.cn/upload/pic/22190.png)

对于15%的数据，1<=n,m<=100,没有入射光。

对于40%的数据，1<=n,m<=100,入射光只有一束，且入射方向一定是东南方。

对于100%的数据，1<=n,m<=100，每一个位置堆放的积木总数不超过100,入射光颜色可能是RGB中的任何一种颜色，最多可以有9束入射光。


## 样例 #1

### 输入

```
2 2
2 1
1 1
R**
***
**G
```

### 输出

```
        +-------+
       /Y\YYYY'/|
      /YY.*'YY/G|
     /.YYYY\Y/G/|
    +-------+G.G|
    |\GGGGG/|\:G|
    |G\GGG/G|G*G|
    |GG\G/GG|G:\|
    |GGGXGGG|G'G+-------+
    |GG/G\GG|/G/G\YYYY'/|
    |G/GGG\G|G/GG.*'YY/G|
    |/GGGGG\|/.GGGG\Y/G/|
    +-------+-------+G.G|
   /Y\GGGG'/G\GGGG'/|\:G|
  /YY.*'GG/GG.*'GG/G|G*G|
 /.YYYY\G/.GGGG\G/G/|G:\|
+-------+-------+G.G|G'G+
|\GGGGG/|\GGGGG/|\:G|/G/
|G\GGG/G|G\GGG/G|G*G|G/
|GG\G/GG|GG\G/GG|G:\|/
|GGGXGGG|GGGXGGG|G'G+
|GG/G\GG|GG/G\GG|/G/
|G/GGG\G|G/GGG\G|G/
|/GGGGG\|/GGGGG\|/
+-------+-------+
```

## 样例 #2

### 输入

```
3 4
1 1 2 1
1 2 1 2
2 1 2 1
**B
***
R*G
```

### 输出

```
                            +-------+
                           /W\WWWW'/|
                          /WW.*'WW/C|
                         /.WWWW\W/C/|
                +-------+-------+-------+
               /W\WWWW'/|\YYYYY/W\WWWW'/|
              /WW.*'WW/C|G\YYY/WW.*'WW/C|
             /.WWWW\W/C/|GG\Y/.WWWW\W/C/|
    +-------+-------+-------+-------+C.C|---+
   /W\WWWW'/|\YYYYY/W\WWWW'/|\YYYYY/|\:C|C'/|
  /WW.*'WW/C|G\YYY/WW.*'WW/C|G\YYY/Y|C*C|C/C|
 /.WWWW\W/C/|GG\Y/.WWWW\W/C/|GG\Y/YY|C:\|/C/|
+-------+C.G|GGG+-------+C.G|GGGXYYY|C'C+C.C|
|\YYYYY/|\:G|GG/|\YYYYY/|\:G|GG/G\YY|/C/|\:C|
|Y\YYY/Y|C*G|G/K|Y\YYY/Y|C*G|G/GGG\Y|C/C|C*C|
|YY\Y/YY|C:\|/KK|YY\Y/YY|C:\|/GGGGG\|/C/|C:\|
|YYYXYYY|C'G+---|YYYXYYY|C'G+-------+C.C|C'C+
|YY/Y\YY|/G/G\KK|YY/Y\YY|/G/G\GGGG'/|\:C|/C/
|Y/YYY\Y|G/GG.*'|Y/YYY\Y|G/GG.*'WW/C|C*C|C/
|/YYYYY\|/.YYYY\|/YYYYY\|/.WWWW\W/C/|C:\|/
+-------+-------+-------+-------+C.C|C'C+
|\YYYYY/|\YYYYY/|\YYYYY/|\YYYYY/|\:C|/C/
|Y\YYY/Y|Y\YYY/Y|Y\YYY/Y|Y\YYY/Y|C*C|C/
|YY\Y/YY|YY\Y/YY|YY\Y/YY|YY\Y/YY|C:\|/
|YYYXYYY|YYYXYYY|YYYXYYY|YYYXYYY|C'C+
|YY/Y\YY|YY/Y\YY|YY/Y\YY|YY/Y\YY|/C/
|Y/YYY\Y|Y/YYY\Y|Y/YYY\Y|Y/YYY\Y|C/
|/YYYYY\|/YYYYY\|/YYYYY\|/YYYYY\|/
+-------+-------+-------+-------+```

# 题解

## 作者：daifucong (赞：42)

这是一道~~简单的~~模拟题。

据说可以将三维平面上的投影转化到二维平面上的问题做。

然而我太弱了，只会分类讨论。

我们发现只要处理每个小立方体的顶面，前面，右面的颜色就可以了。~~废话~~

令$cnt[i][j]$表示输入数据从上到下第$i$行，从左到右第$j$列的立方体个数。

对于顶面的颜色，我们对每束光线分类讨论：

1. 对于方向竖直向下的光线，我们直接把光线加上去即可。
2. 对于从左射来的光线，如果存在一个$h>0$，使得$cnt[x][y-h]-cnt[x][y]\geqslant h$，则这束光线不能照到位于$(x,y)$的最上面的小立方体的顶面的任何一部分。其它类似的光线同理。
3. 对于从右下方向射来的光线：

 如果存在一个$h>0$，使得$cnt[x+h][y+h]-cnt[x][y]\geqslant h$，则这束光线不能照到位于$(x,y)$的最上面的小立方体的顶面的任何一部分。
 
 如果存在一个$h>0$，使得$cnt[x+h][y+h-1]-cnt[x][y]\geqslant h$，则这束光线不能照到位于$(x,y)$的最上面的小立方体的顶面的左边部分和下边部分。
 
 如果存在一个$h>0$，使得$cnt[x+h-1][y+h]-cnt[x][y]\geqslant h$，则这束光线不能照到位于$(x,y)$的最上面的小立方体的顶面的右边部分和上边部分。
 
 其它类似的光线同理。
 
对于右面的颜色，我们还是对每束光线分类讨论，但是只要讨论$3$束光线：

  令这个小立方体的高度为$Height$。

1. 对于从正右方向射来的光线，如果存在一个$h>0$，使得$cnt[x][y+h]-Height\geqslant h$，则这束光线不能找到这个立方体的右边。

2. 对于从右下方向射来的光线：

  如果存在一个$h>0$，使得$cnt[x+h-1][y+h]-Height\geqslant h-1$，则这个小立方体的整个右面不能被这束光照到。

  如果存在一个$h>0$，使得$cnt[x+h][y+h]-Height\geqslant h$，则这个小立方体的整个右面不能被这束光照到。
  
  如果存在一个$h\geqslant 0$，使得$cnt[x+h+1][y+h+1]-Height\geqslant h$，则这个小立方体右面的左边部分和下边部分不能被这束光照到。
  
3. 对于从右上方向射来的光线，处理方法和从右下方向射来的光线类似。

对于前面的颜色，处理方法和右面的颜色类似。

至于输出的话其实就是这道题[P1058](https://www.luogu.org/problemnew/show/P1058)。

上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
char base[20][20]={"",
"\0    +-------+",
"\0   /4\\1111\'/|",
"\0  /44.*\'22/1|",
"\0 /.3333\\2/1/|",
"\0+-------+1.2|",
"\0|\\11111/|\\:2|",
"\0|4\\111/2|4*2|",
"\0|44\\1/22|4:\\|",
"\0|444X222|4\'3+",
"\0|44/3\\22|/3/ ",
"\0|4/333\\2|3/  ",
"\0|/33333\\|/   ",
"\0+-------+    "};
const int baseh=13;
char ans[5001][5001];int cnt[101][101];int n,m;int ansh,answ;
char getcube[20][20];
inline void setit(int startx,int starty){for(int i=13,x=startx;i>=1;i--,x--) for(int j=1,y=starty;j<=13;j++,y++) if(getcube[i][j]!=' ') ans[x][y]=getcube[i][j];}
struct Col
{
	bool R,B,G;Col(){R=B=G=0;}Col(char c){R=B=G=0;if(c=='R')R=1;if(c=='B') B=1;if(c=='G')G=1;}
	inline char getcol()
	{
		if(R==0&&B==0&&G==0) return 'K';if(R==0&&B==0&&G==1) return 'G';
		if(R==0&&B==1&&G==0) return 'B';if(R==0&&B==1&&G==1) return 'C';
		if(R==1&&B==0&&G==0) return 'R';if(R==1&&B==0&&G==1) return 'Y';
		if(R==1&&B==1&&G==0) return 'P';if(R==1&&B==1&&G==1) return 'W';
		assert(0);return '\0';
	}
};
inline Col operator +(const Col &a,const Col &b){Col res;res.R=a.R||b.R;res.B=a.B||b.B;res.G=a.G||b.G;return res;}
inline void Add(Col &a,char c){a=a+Col(c);}
//个人认为这样定义可以方便处理颜色重叠的问题
char light[4][4];
struct Block
{
	Col Ul,Ur,Uf,Ub;
	Col Fu,Fd,Fl,Fr;
	Col Ru,Rd,Rf,Rb;
	inline void Getcube()
	{
		for(int i=1;i<=baseh;i++) for(int j=1;j<=baseh;j++)
		{
			getcube[i][j]=base[i][j];
			if(i>=6&&j<=9)
			{
				if(base[i][j]=='1') getcube[i][j]=Fu.getcol();
				if(base[i][j]=='2') getcube[i][j]=Fr.getcol();
				if(base[i][j]=='3') getcube[i][j]=Fd.getcol();
				if(base[i][j]=='4') getcube[i][j]=Fl.getcol();
			}
			if(i>=5&&j>9)
			{
				if(base[i][j]=='1') getcube[i][j]=Ru.getcol();
				if(base[i][j]=='2') getcube[i][j]=Rb.getcol();
				if(base[i][j]=='3') getcube[i][j]=Rd.getcol();
				if(base[i][j]=='4') getcube[i][j]=Rf.getcol();
			}
			if(i<5)
			{
				if(base[i][j]=='1') getcube[i][j]=Ub.getcol();
				if(base[i][j]=='2') getcube[i][j]=Ur.getcol();
				if(base[i][j]=='3') getcube[i][j]=Uf.getcol();
				if(base[i][j]=='4') getcube[i][j]=Ul.getcol();
			}
		}
		getcube[3][12]=Ru.getcol();
		getcube[4][11]=Ru.getcol();
	}//将这个立方体的实际输出放到getcube[][]字符数组中
}a[101][101][101];
inline void SolveUpColor()
{
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++)
	{
		int high=cnt[i][j];
		a[i][j][high].Ub=a[i][j][high].Uf=a[i][j][high].Ul=a[i][j][high].Ur=Col(light[2][2]);
		//light from up
		bool flag1=1,flag2=1;//flag1:left front,flag2:right back
		int curx=i-1,cury=j-1,curcnt=1;
		while(curx&&cury&&flag1){if(cnt[curx][cury]-cnt[i][j]>=curcnt) flag1=flag2=0;curx--;cury--;curcnt++;}
		curx=i;cury=j-1;curcnt=1;
		while(flag1&&curx&&cury){if(cnt[curx][cury]-cnt[i][j]>=curcnt) flag1=0;curx--;cury--;curcnt++;}
		curx=i-1;cury=j;curcnt=1;
		while(flag2&&curx&&cury){if(cnt[curx][cury]-cnt[i][j]>=curcnt) flag2=0;curx--;cury--;curcnt++;}
		if(flag1) Add(a[i][j][high].Ul,light[1][1]),Add(a[i][j][high].Uf,light[1][1]);
		if(flag2) Add(a[i][j][high].Ub,light[1][1]),Add(a[i][j][high].Ur,light[1][1]);
		//light from left back
		flag1=1;curx=i-1;cury=j;curcnt=1;
		while(flag1&&curx){if(cnt[curx][cury]-cnt[i][j]>=curcnt) flag1=0;curx--;curcnt++;}
		if(flag1)
		{
			Add(a[i][j][high].Ul,light[1][2]),Add(a[i][j][high].Uf,light[1][2]);
			Add(a[i][j][high].Ub,light[1][2]),Add(a[i][j][high].Ur,light[1][2]);
		}
		//light from back
		flag1=flag2=1;curx=i-1,cury=j+1;curcnt=1;//flag1:left back,flag2:right front
		while(flag1&&curx&&cury<=m){if(cnt[curx][cury]-cnt[i][j]>=curcnt) flag1=flag2=0;curx--;cury++;curcnt++;}
		curx=i-1,cury=j;curcnt=1;
		while(flag1&&curx&&cury<=m){if(cnt[curx][cury]-cnt[i][j]>=curcnt) flag1=0;curx--;cury++;curcnt++;}
		curx=i;cury=j+1;curcnt=1;
		while(flag2&&curx&&cury<=m){if(cnt[curx][cury]-cnt[i][j]>=curcnt) flag2=0;curx--;cury++;curcnt++;}
		if(flag1) Add(a[i][j][high].Ul,light[1][3]),Add(a[i][j][high].Ub,light[1][3]);
		if(flag2) Add(a[i][j][high].Uf,light[1][3]),Add(a[i][j][high].Ur,light[1][3]);
		//light from right back
		flag1=1;curx=i;cury=j-1;curcnt=1;
		while(flag1&&cury){if(cnt[curx][cury]-cnt[i][j]>=curcnt) flag1=0;cury--;curcnt++;}
		if(flag1)
		{
			Add(a[i][j][high].Ul,light[2][1]),Add(a[i][j][high].Uf,light[2][1]);
			Add(a[i][j][high].Ub,light[2][1]),Add(a[i][j][high].Ur,light[2][1]);
		}
		//light from left
		flag1=1;curx=i;cury=j+1;curcnt=1;
		while(flag1&&cury<=m){if(cnt[curx][cury]-cnt[i][j]>=curcnt) flag1=0;cury++;curcnt++;}
		if(flag1)
		{
			Add(a[i][j][high].Ul,light[2][3]),Add(a[i][j][high].Uf,light[2][3]);
			Add(a[i][j][high].Ub,light[2][3]),Add(a[i][j][high].Ur,light[2][3]);
		}
		//light from right
		flag1=flag2=1;curx=i+1;cury=j-1;curcnt=1;//flag1:left back,flag2:right front
		while(flag1&&curx<=n&&cury){if(cnt[curx][cury]-cnt[i][j]>=curcnt) flag1=flag2=0;curx++;cury--;curcnt++;}
		curx=i;cury=j-1;curcnt=1;
		while(flag1&&curx<=n&&cury){if(cnt[curx][cury]-cnt[i][j]>=curcnt) flag1=0;curx++;cury--;curcnt++;}
		curx=i+1;cury=j;curcnt=1;
		while(flag2&&curx<=n&&cury){if(cnt[curx][cury]-cnt[i][j]>=curcnt) flag2=0;curx++;cury--;curcnt++;}
		if(flag1) Add(a[i][j][high].Ul,light[3][1]),Add(a[i][j][high].Ub,light[3][1]);
		if(flag2) Add(a[i][j][high].Uf,light[3][1]),Add(a[i][j][high].Ur,light[3][1]);
		//light from left front
		flag1=1;curx=i+1;cury=j;curcnt=1;
		while(flag1&&curx<=n){if(cnt[curx][cury]-cnt[i][j]>=curcnt) flag1=0;curx++;curcnt++;}
		if(flag1)
		{
			Add(a[i][j][high].Ul,light[3][2]),Add(a[i][j][high].Uf,light[3][2]);
			Add(a[i][j][high].Ub,light[3][2]),Add(a[i][j][high].Ur,light[3][2]);
		}
		//light from front
		flag1=flag2=1;curx=i+1;cury=j+1;curcnt=1;//flag1:left front,flag2:right back
		while(flag1&&curx<=n&&cury<=m){if(cnt[curx][cury]-cnt[i][j]>=curcnt) flag1=flag2=0;curx++;cury++;curcnt++;}
		curx=i+1;cury=j;curcnt=1;
		while(flag1&&curx<=n&&cury<=m){if(cnt[curx][cury]-cnt[i][j]>=curcnt) flag1=0;curx++;cury++;curcnt++;}
		curx=i;cury=j+1;curcnt=1;
		while(flag2&&curx<=n&&cury<=m){if(cnt[curx][cury]-cnt[i][j]>=curcnt) flag2=0;curx++;cury++;curcnt++;}
		if(flag1) Add(a[i][j][high].Ul,light[3][3]),Add(a[i][j][high].Uf,light[3][3]);
		if(flag2) Add(a[i][j][high].Ur,light[3][3]),Add(a[i][j][high].Ub,light[3][3]);
		//light from right front
	}
}//处理顶面的颜色
inline void SolveRightColor()
{
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) for(int high=1;high<=cnt[i][j];high++)
	{
		if(j<m&&cnt[i][j+1]>=cnt[i][j]) continue;
		int flag1,flag2;int curx,cury,curhigh;
		flag1=1;curx=i;cury=j+1;curhigh=high;
		while(flag1&&cury<=m){if(cnt[curx][cury]>=curhigh) flag1=0;cury++;curhigh++;}
		if(flag1)
		{
			Add(a[i][j][high].Rb,light[2][3]);Add(a[i][j][high].Rd,light[2][3]);
			Add(a[i][j][high].Rf,light[2][3]);Add(a[i][j][high].Ru,light[2][3]);
		}
		//light from right
		flag1=flag2=1;curx=i+1;cury=j+2;curhigh=high+1;//flag1:up back,flag2:front down
		while(flag1&&curx<=n&&cury<=m){if(cnt[curx][cury]>=curhigh) flag1=flag2=0;curx++;cury++;curhigh++;}
		curx=i+1;cury=j+1;curhigh=high+1;
		while(flag1&&curx<=n&&cury<=m){if(cnt[curx][cury]>=curhigh) flag1=flag2=0;curx++;cury++;curhigh++;}
		curx=i+1;cury=j+1;curhigh=high;
		while(flag2&&curx<=n&&cury<=m){if(cnt[curx][cury]>=curhigh) flag2=0;curx++;cury++;curhigh++;}
		if(flag1) Add(a[i][j][high].Ru,light[3][3]),Add(a[i][j][high].Rb,light[3][3]);
		if(flag2) Add(a[i][j][high].Rf,light[3][3]),Add(a[i][j][high].Rd,light[3][3]);
		//light from right front
		flag1=flag2=1;curx=i-1;cury=j+2;curhigh=high+1;//flag1:up front,flag2:down back
		while(flag1&&curx&&cury<=m){if(cnt[curx][cury]>=curhigh) flag1=flag2=0;curx--;cury++;curhigh++;}
		curx=i-1;cury=j+1;curhigh=high+1;
		while(flag1&&curx&&cury<=m){if(cnt[curx][cury]>=curhigh) flag1=flag2=0;curx--;cury++;curhigh++;}
		curx=i-1;cury=j+1;curhigh=high;
		while(flag2&&curx&&cury<=m){if(cnt[curx][cury]>=curhigh) flag2=0;curx--;cury++;curhigh++;}
		if(flag1) Add(a[i][j][high].Ru,light[1][3]),Add(a[i][j][high].Rf,light[1][3]);
		if(flag2) Add(a[i][j][high].Rd,light[1][3]),Add(a[i][j][high].Rb,light[1][3]);
		//light from right back
	}
}//处理右面的颜色
inline void SolveFrontColor(){
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) for(int high=1;high<=cnt[i][j];high++)
	{
		if(i<n&&cnt[i+1][j]>=cnt[i][j]) continue;
		int flag1,flag2,curx,cury,curhigh;
		flag1=1;curx=i+2;cury=j;curhigh=high+1;
		while(flag1&&curx<=n){if(cnt[curx][cury]>=curhigh) flag1=0;curx++;curhigh++;}
		if(flag1)
		{
			Add(a[i][j][high].Fd,light[3][2]);Add(a[i][j][high].Fl,light[3][2]);
			Add(a[i][j][high].Fr,light[3][2]);Add(a[i][j][high].Fu,light[3][2]);
		}
		//light from front
		flag1=flag2=1;curx=i+1;cury=j+1;curhigh=high+1;//flag1:left up,flag2:right down
		while(flag1&&curx<=n&&cury<=m){if(cnt[curx][cury]>=curhigh) flag1=flag2=0;curx++;cury++;curhigh++;}
		curx=i+2;cury=j+1;curhigh=high+1;
		while(flag1&&curx<=n&&cury<=m){if(cnt[curx][cury]>=curhigh) flag1=flag2=0;curx++;cury++;curhigh++;}
		curx=i+1;cury=j+1;curhigh=high;
		while(flag2&&curx<=n&&cury<=m){if(cnt[curx][cury]>=curhigh) flag2=0;curx++;cury++;curhigh++;}
		if(flag1) Add(a[i][j][high].Fl,light[3][3]),Add(a[i][j][high].Fu,light[3][3]);
		if(flag2) Add(a[i][j][high].Fr,light[3][3]),Add(a[i][j][high].Fd,light[3][3]);
		//light from right front
		flag1=flag2=1;curx=i+1;cury=j-1;curhigh=high+1;//flag1:right up,flag2:left down
		while(flag1&&curx<=n&&cury){if(cnt[curx][cury]>=curhigh) flag1=flag2=0;curx++;cury--;curhigh++;}
		curx=i+2;cury=j-1;curhigh=high+1;
		while(flag1&&curx<=n&&cury){if(cnt[curx][cury]>=curhigh) flag1=flag2=0;curx++;cury--;curhigh++;}
		curx=i+1;cury=j-1;curhigh=high;
		while(flag2&&curx<=n&&cury){if(cnt[curx][cury]>=curhigh) flag2=0;curx++;cury--;curhigh++;}
		if(flag1) Add(a[i][j][high].Fr,light[3][1]),Add(a[i][j][high].Fu,light[3][1]);
		if(flag2) Add(a[i][j][high].Fl,light[3][1]),Add(a[i][j][high].Fd,light[3][1]);
		//light from left front
	}
}//处理前面的颜色
inline void print()
{
	ansh=0;answ=1+m*8+n*4;
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) ansh=max(ansh,1+4*(n-i+1)+8*cnt[i][j]);
	for(int i=1;i<=ansh;i++) for(int j=1;j<=answ;j++) ans[i][j]=' ';
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) for(int k=1;k<=cnt[i][j];k++)
	{
		int getx=ansh-4*(n-i)-8*(k-1),gety=1+(j-1)*8+(n-i)*4;
		a[i][j][k].Getcube();
		setit(getx,gety);
	}
	for(int i=1;i<=ansh;i++)
	{
		for(int j=1;j<=answ;j++) putchar(ans[i][j]);
		putchar('\n');
	}
}//输出不解释了
inline void init()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) scanf("%d",&cnt[i][j]);
	for(int i=1;i<=3;i++) for(int j=1;j<=3;j++) cin>>light[i][j];
}
int main()
{
	init();
	SolveUpColor();
	SolveRightColor();
	SolveFrontColor();
	print();
	return 0;
}
```

本题在省选当中出现，还是比较可做的，毕竟省选有$5$个小时。

~~反正ZJOI考场上遇到这题我就头铁刚~~

---

## 作者：11Dimensions (赞：29)

题目的数据范围很小，因此只需模拟即可。对于一个方向的平行光，可以将每个立方体投影到一个垂直于光线方向的平面上，然后处理立方体在平面上的覆盖情况，进而计算出立方体表面的每个部分上每种颜色的光照情况。而立方体在平面上的投影可以方便的用坐标变换来表示。


以从右前方入射的光线为例，如果我们从后向前，从左向右，从下向上建立三维直角坐标系的话，则变换

$$(x,y,z)\to(x-z,y-z)$$

可以视为将立方体投影到与该方向光线垂直的一个平面的一个变换。而位于 $(u,v)$ 的立方体的投影最多会被六个其它投影所遮挡：

$$
\begin{array}{c}
(u-1,v)\quad(u-1,v-1)\quad(u,v-1)\\
(u+1,v)\quad(u+1,v+1)\quad(u,v+1)
\end{array}
$$
只需逐个判断并记录遮挡状况即可。


对每个立方体计算出光照情况后，只需将立方体从后向前，从左向右，从下向上的逐个输出到一个虚拟画布上，再将答案从画布输出即可。


---

## 作者：Acc_Robin (赞：20)

## 「SDOI2015」立体图 题解

>  小模拟，写篇题解 ~~造福后人~~ 记录一下。

>  因为我不喜欢很长的代码，所以我用投影法做的这题，**代码仅有 3.14k**，是目前最短的了。

> Mouther：为什么画的图那么丑？
>
> Acc：你问 Ubuntu 去。

> Mouther：Mouther 是什么意思？
>
> Acc：嘴子。

## 题解

### 建立坐标系

这题里三维坐标系很别扭，要从后向前、从左往右、自下而上建立，画出来就是

![](https://cdn.luogu.com.cn/upload/image_hosting/lrpee18f.png)

### 投影

简单来讲，投影就是把三维坐标系拍扁到一个与视角垂直的平面上，也即对坐标的某种变换，都是类似于 $(x,y,z)\to (u,v)$​​​ ，其中 $u,v$​ 是关于 $x,y,z$​ 的**线性组合**。

> Mouther：为什么是线性组合？
>
> Acc：亲，光线是不能拐弯的。

> Mouther：若两个点 $(x_1,y_1,z_1),(x_2,y_2,z_2)$ 在变换后分别对应 $(u_1,v_1),(u_2,v_2)$ ，但 $u_1=u_2,v_1=v_2$ ，那么谁才应该占据这个位置？
>
> Acc：通过常识判断，我们需要让“离视角更近”的那个点去占据，所以我们要按照从远到近的顺序依次执行变换，新来的点直接**覆盖**之前的点，这样就能保证变换后坐标相同的点一定是由最晚（离视角最近）的点占据。

> Mouther：平面直角坐标系的原点、正方向如何选择？
>
> Acc：为了尽量简化，我们直接选择原坐标系的原点、$x$​ 轴和$y$​ 轴分别作为新坐标系的原点、$x$​ 轴以及$y$​​ 轴。

我们先从最简单的视角开始：

#### 正上方

很简单，$(x,y,z)\to (x,y)$。

 #### 正南方 $45°$ 仰角（前方）

在这个视角下，你看到的坐标系长这个样子：

![](https://cdn.luogu.com.cn/upload/image_hosting/foy3q7zt.png)

黑色的 $OXYZ$ 是三维坐标系，红色的 $\color{red}{OUV}$是需要投影的二维坐标系。他们的原点重合，这里错开是为了区分。

那么注意到 $y$ 这一维与其它维度无关，即 $v=y$ 。而观察到 $x$ 越大、$z$ 越小会导致 $u$ 越大，得出 $u=x-z$​​。

> Mouther：为什么系数是 $1$ 和 $-1$？
>
> Acc：事实上只要保证 $x$ 的系数与 $z$ 的系数比例是 $1:-1$ 就行。

现在对于一个投影到新坐标系上的立方体 $(u,v)$ 来说，它可能被另一个立方体 $(u',v')$ 覆盖（完全遮挡）、遮挡住上面 或者 遮挡住正面。

- 被覆盖：$(u',v')=(u,v)$ 
- 被遮挡上面：$(u',v')=(u-1,v)$
- 被遮挡正面：$(u',v')=(u+1,v)$

同理，我们能轻松得到剩余三个正方向的变换以及遮挡关系（省略覆盖的情况）。

#### 正北方 $45°$ 仰角（后方）

$(x,y,z)\to (x+z,y)$

- 被遮挡上面：$(u',v')=(u+1,v)$

> Mouther：为什么没有讨论被遮挡后面的情况？
>
> Acc：在输出时，我们只需要正面、上面和右面的信息就够了，其它的面不需要处理，在之后也都只讨论这三个面。

#### 正西方 $45°$ 仰角（左方）

$(x,y,z)\to (x,y+z)$​

- 被遮挡上面：$(u',v')=(u,v+1)$

#### 正东方 $45°$ 仰角（右方）

$(x,y,z)\to (x,y-z)$

- 被遮挡上面：$(u',v')=(u,v-1)$
- 被遮挡右面：$(u',v')=(u,v+1)$

好了，剩下四个麻烦的方向，我们先讨论最直观的

#### 东南方 $45°$ 仰角（右前方）

坐标系：

![](https://cdn.luogu.com.cn/upload/image_hosting/t06ql5f1.png)

现在有一个可爱的蓝色方块位于 $(x,y,z),\color{red}{(u,v)}$​（选定那个红色的点作为这个方块的基准点）。

发现随着 $z$ 的增大，$u$ 和 $v$​ ​​都会减小，于是得到此视角下的变换： $(x,y,z)\to (x-z,y-z)$。

- 被遮挡正面

![](https://cdn.luogu.com.cn/upload/image_hosting/526uw97z.png)

此刻黄色方块遮挡住了蓝色方块的正面，它位于新坐标系的 $(u+1,v)$（沿着橙色箭头的方向就是 $u$ 的正方向）​。

- 被遮挡右面

与上一种情况基本同理，得到 $(u',v')=(u,v+1)$。

- 被遮挡上面

![](https://cdn.luogu.com.cn/upload/image_hosting/jl9x6yuj.png)

橙色箭头是 $U$​ 轴负方向，紫色箭头是 $V$​​​ 轴负方向，得到 $(u',v')=(u-1,v-1)$。

然后就是几种不完全遮挡，因此我们把正方体的一个面拆分成四部分，分别标号 $0,1,2,3$：

![](https://cdn.luogu.com.cn/upload/image_hosting/75v4725y.png)

- 遮挡上面 $23$，遮挡右面 $23$

![](https://cdn.luogu.com.cn/upload/image_hosting/4000isf5.png)

$(u',v')=(u-1,v)$

- 遮挡上面 $01$，正面 $12$

![](https://cdn.luogu.com.cn/upload/image_hosting/0a5cpzg6.png)

$(u',v')=(u,v-1)$

- 遮挡正面 $03$，右面 $12$

![](https://cdn.luogu.com.cn/upload/image_hosting/tfx20zfs.png)

$(u',v')=(u+1,v+1)$

好了，这一个视角已经讨论完了，你是不是已经麻了呢？

同理，我们可以慢慢讨论剩下三个视角，相信你可以，这里就不赘述了。

### 实现

> Mouther：九个方向你要一个一个去敲吗？
>
> Acc：NO，我们有脑子。

#### 颜色类 `col`

首先，各种颜色的覆盖关系很难用普通的运算来处理，因此这里选择位运算（状压）。

那么颜色相加就可以用或运算来解决，而去掉一种颜色可以通过与非，代码中实现了重载运算符 `+`（颜色结合）、`-`（去掉某种颜色）。

#### 方块类 `cub`

每个方块需要处理三个面，每个面被分成四部分，通过一个 $3\times 4$ 的 `col` 数组就行。

`void pt(int d,col x)`表示从 $d$ 这个方向去掉 $x$ 这种颜色。

`+=` 是将两个方块每个面分别相加。

`void pnt(int x,int y,int z)` 的作用是将结果输出到画布上。

#### 投影类 `Ray`

就是一个平面，每个位置记录这里是由原图中那个方块投影而来。

为了能够访问负数下标，我使用指针进行了平移。

#### 代码简化

从这九种情况的讨论中，聪明的小伙伴（就是你）一定发现了一些规律：

对于变换 $(x,y,z)\to (x+k_1 z,y+k_2z),(k_1,k_2\in\{-1,1\})$​ ，$k_1,k_2$ 可不是随便选的，具体来讲是这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/5fe951ms.png)

每个格子表示一个方位的视角。

> Mouther：这个规律有什么用呢？
>
> Acc：简化代码，九个情况的分类讨论一个循环解决。

同时注意到，对变换 $(x,y,z)\to (x+k_1 z,y+k_2z),(k_1,k_2\in\{-1,1\})$，遮挡 $(u,v)$ 上面的方块就是 $(u+k_1,v+k_2)$​，右面。正面也有类似结论。​

#### 输出

很简单，就像那个 NOIP 题一样，按顺序输出到画布上即可。

#### 告示

事实上实现的细节很多很多，这里不一一列举，如果你真的下定决心要写这道题，相信它们难不住你。

## 代码

你们就想看这个

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace Acc{
	const int N=109,M=209;
	char val[]="KRGYBPCW";
	char o[15][15]={R"(    +-------+)",R"(   /a\bbbb'/|)",R"(  /aa.*'cc/j|)",R"( /.````\c/j/|)",R"(+-------+j.k|)",R"(|\fffff/|\:k|)",R"(|e\fff/g|i*k|)",R"(|ee\f/gg|i:\|)",R"(|eeeXggg|i'h+)",R"(|ee/d\gg|/h/ )",R"(|e/ddd\g|h/  )",R"(|/ddddd\|/   )",R"(+-------+    )"};
	struct col{
		int x;
		col(){x=0;}
		col(char c){x=1<<(c=='R'?0:(c=='G'?1:2));}
		col(int r,int g,int b){x=r<<0|g<<1|b<<2;}
		inline void operator+=(const col&_){x|=_.x;}
		inline void operator-=(const col&_){x&=~_.x;}
	}cur;
	char Xr[3][4],ans[1250][1250];
	int n,m,G[N][N],L,T;
	inline void dn(int&x,int y){x=x>y?y:x;}
	inline void up(int&x,int y){x=x<y?y:x;}
	struct cub{
		col c[3][4];
		cub(col x=col()){for(int i=0;i<3;++i)for(int j=0;j<4;++j)c[i][j]=x;}
		inline void pt(int d,col x=cur){for(int i=0;i<4;++i)c[d][i]-=x;}
		inline void pt(int d,int a,int b,col x=cur){c[d][a]-=cur,c[d][b]-=x;}
		inline void operator+=(const cub&_){for(int i=0;i<3;++i)for(int j=0;j<4;++j)c[i][j]+=_.c[i][j];}
		void pnt(int x,int y,int z){
			y=4*x+8*y,up(L,x=4*x+8*z+12);
			int t,i,j;
			for(i=0;i<13;++i)for(j=0;j<13;++j)if(o[i][j]>95&&o[i][j]<108)
				t=(o[i][j]>>2)&3,ans[x-i][y+j]=val[c[t][o[i][j]&3].x];
			else if(o[i][j]!=' ')ans[x-i][y+j]=o[i][j];
		}
	}a[N][N][N],b[N][N][N],now;
	struct Ray{
		int x,y,z;
		Ray(){x=y=z=-1;}
		Ray(int a,int b,int c):x(a),y(b),z(c){}
		inline int operator~(){return ~x;}
	}f[M*2][M*2],*g[M*2],**mp;
	void work(){
		int i,j,k,H1=INT_MAX,H2=-H1,W1,W2,dx,dy,u,v,s1,t1,s2,t2,x,y,di,dj;
		for(i=0;i<M*2;++i)g[i]=f[i]+M;
		for(mp=g+M,cin>>n>>m,i=0;i<n;++i)for(j=0;j<m;++j)cin>>G[i][j];
		for(i=0;i<3;++i)cin>>Xr[i];
		for(u=0;u<3;++u)for(v=0;v<3;++v)if(Xr[u][v]!=42){
			dx=u?(u==1?0:-1):1,dy=v?(v==1?0:-1):1,di=dx?dx:1,dj=dy?dy:1;
			W2=H2=-(H1=W1=INT_MAX),s1=s2=0,t1=n,t2=m,now=cub(cur=col(Xr[u][v]));
			if(~dx)now.pt(1);if(~dy)now.pt(2);
			if(dx<0)s1=n-1,t1=-1;if(dy<0)s2=m-1,t2=-1;
			for(i=s1;i!=t1;i+=di)for(j=s2;j!=t2;j+=dj)for(k=G[i][j]-1;~k;--k){
				if(~mp[x=i+k*dx][y=j+k*dy])continue;
				cub&p=b[i][j][k];p=now;
				if(~mp[x+dx][y+dy])p.pt(0);
				if(dx==-1 && ~mp[x+1][y])p.pt(1);
				if(dy==-1 && ~mp[x][y+1])p.pt(2);
				mp[x][y]=Ray(i,j,k),dn(H1,x),up(H2,x),dn(W1,y),up(W2,y);
				if(dx==-1 && dy==1){
					if(~mp[x-1][y])p.pt(0,1,2);
					if(~mp[x][y+1])p.pt(0,0,3),p.pt(1,2,3);
					if(~mp[x+1][y-1])p.pt(1,0,1);
				}else if(dx==1 && dy==-1){
					if(~mp[x][y-1])p.pt(0,1,2);
					if(~mp[x+1][y])p.pt(0,0,3),p.pt(2,1,2);
					if(~mp[x-1][y+1])p.pt(2,0,3);
				}else if(dx==1 && dy==1){
					if(~mp[x+1][y])p.pt(0,0,1);
					if(~mp[x][y+1])p.pt(0,2,3);
				}else if(dx==-1 && dy==-1){
					if(~mp[x-1][y])p.pt(0,2,3),p.pt(2,2,3);
					if(~mp[x][y-1])p.pt(0,0,1),p.pt(1,0,1);
					if(~mp[x+1][y+1])p.pt(1,0,3),p.pt(2,0,1);
				}
				a[i][j][k]+=b[i][j][k];
			}
			for(i=H1;i<=H2;++i)for(j=W1;j<=W2;++j)if(~mp[i][j])mp[i][j]=Ray();
		}
		T=4*n+8*m;
		for(i=0;i<n;++i)for(j=0;j<m;++j)for(k=0;k<G[i][j];++k)a[i][j][k].pnt(n-i-1,j,k);
		for(i=L;~i;--i,putchar(10)){
			for(k=T;~k;--k)if(ans[i][k])break;
			for(j=0;j<=k;++j)putchar(ans[i][j]?ans[i][j]:32);
		}
	}
}
int main(){return Acc::work(),0;}
```

---

## 作者：ZioushCioushYioush (赞：11)

# 立体图 题解

比较考代码能力或思维能力的模拟题。

但阅读这篇题解不需要思维能力，只需要一点点代码能力。

**分类讨论**九条光线。我们发现只需要考虑其照到顶面、前面与右面的情况。

同时发现，模拟光线**能否从某个方块的部分射出**更加方便。

可以建出如下的坐标系。

![image1](https://cdn.luogu.com.cn/upload/image_hosting/ufp0xqx1.png)

设当前处理的是处于 $(i,j)$ 的 $height_{i,j}$ 个方块，只要满足 $\forall (x,y,h)\in P,\ 2\cdot height_{x,y}-height_{i,j}<h$，就说明光线能照到当前面。其中 $P$ 表示若无障碍物，光线能够通过的整点。

使用程序模拟时，可以反向判断。将上述不等式改为 $height_{x,y}-height_{i,j}\ge \Delta h$，或 $height_{x,y}\ge h$，此时将 `flag` 置为 `false`，退出循环即可。本程序代码混乱但有序。混乱体现在上述两个不等式混用，有序表现在混用却不混乱。

### 光线模拟

- 对于垂直光线，无需判断，直接将颜色加到顶面。

- 对于正向光线，
  - 处理顶面光照时，只需要处理光线能否找到 $cube_{i,j,k},k=height_{i,j}$ 这个方块的顶面。（以下使用 F 代替前，B 代替后，L 代替左，R 代替右，$h$ 代替 $\Delta h$）

    $P_{F1}=\{ (i+h,j,k+h)\ |\ (i+h)\in[1,n]\}$
    
    $P_{B1}=\{ (i-h,j,k+h)\ |\ (i-h)\in[1,n]\}$
    
    $P_{L1}=\{ (i,j-h,k+h)\ |\ (j-h)\in[1,m]\}$
    
    $P_{R1}=\{ (i,j+h,k+h)\ |\ (j+h)\in[1,m]\}$

  - 处理前面光照时，发现不只要处理最顶上的那一个方块。要处理这一溜方块。设当前处理 $cube_{i,j,k}$ 这个方块的前面，则

    $P_{F2}=\{ (i+1+h,j,k+h)\ |\ (i+1+h)\in[1,n]\}$

  - 处理右面光照的方法与前面光照相似。不赘述。

  下面不会给出 $P$ 的表达式。以下**起点**表示 $h=0$ 时光线的二维坐标。

- 对于斜向光线，
  - 斜向光线需要一定的空间想象力。但可以通过看样例得出结论。
  
  - 举个例子，想要处理从左后方照射到顶面的光线，就需要分情况讨论。根据样例 1，发现因 $cube_{1,1,2}$ 的遮挡将 $cube_{1,1,1}$ 的顶面**分成两部分**——**左下**面和**右上**面。于是要在处理当前位置光线能否射出的同时，还得处理两部分的光线能否射出。光线起点为：
    
	$S_{LB}\in\{(i,j-1),(i-1,j),(i-1,j-1)\},\Delta h=1$

  - 若是照射到前面的光线，我们举左前方光线的例子。可以发现若左上面不被照射到，那么右下面也不会被照射到。所以可以分**三步**进行，前两步检查整个面的光线能否射出，第三步检查右下面的光线能否射出。起点分别为 $(i+1,j-1),(i+2,j-1),(i+1,j-1)$。前两步 $h=k+1$，最后一步 $h=k$。
  
  - 其他光线类推。

同时要注意，因为要实现九条光线，实现的过程肯定会有大段的相似代码，复制粘贴时一定要修改。我就因为有一个地方没有改，调了好久 qwq。

### 颜色处理

```cpp
class int8{
public:
	using int8_t=signed char;
	int8_t val;
	int8(int val=0):val((int8_t)val){}
};
int8 CTB(char color){/*Char to Binary*/
	switch(color){
		case (Black): return 0b000;
		case (Blue):  return 0b001;
		case (Green): return 0b010;
		case (Cyan):  return 0b011;
		case (Red):   return 0b100;
		case (Pink):  return 0b101;
		case (Yellow):return 0b110;
		case (White): return 0b111;
		default:      return 0b000;
	}
}
char BTC(int8 binary){/*Binary to Char*/
	switch(binary.val){
		case (0b000): return Black;
		case (0b001): return Blue;
		case (0b010): return Green;
		case (0b011): return Cyan;
		case (0b100): return Red;
		case (0b101): return Pink;
		case (0b110): return Yellow;
		case (0b111): return White;
		default:      return Black;
	}
}
class Color{
	int8 binary;
public:
	explicit Color(int8 binary=0):binary(binary){}
	char Char(){return change::BTC(binary);}
	void operator+=(const Color &t){
		this->binary=this->binary.val|t.binary.val;
	}
};
```

我定义了两个类。`int8` 表示八位二进制整数，当然也是为了与 `char` 区分。`Color` 表示颜色。重载的 `+=` 运算符可以很方便的上色。

什么，你问我 `Black,Blue` 哪来的？当然是自定义的枚举类型。

```cpp
enum ColorEnum{
	Blue='B',
	Green='G',
	Red='R',
	Pink='P',
	Cyan='C',
	Yellow='Y',
	Black='K',
	White='W',
};
```

### 输出

首先建立答案数组和缓存数组。答案数组是整个输出的缓存，缓存数组是当前方块的缓存，通过一个刷新缓存的函数存到答案数组中。

其中答案数组的大小为 $(8m+4n)\times(\max(8height_{i,j}+4(n-i+1))),\ i\in[1,n],\ j\in[1,m]$。

我建立了 12 个存储小三角形的坐标的数组。每次上色时，遍历这些数组，在对应位置上色即可。

注意在更新答案时，应保持**从后到前，从左到右，从下到上**的顺序，这样可以直接使用缓存数组**覆盖**答案数组。

当然缓存数组中的空格是不能覆盖到答案数组的！

根据题意，要去除尾空格和末尾换行。可以从后往前遍历得到第一个非空格，将这个非空格的后一位置为 `\0` 再输出。对于末尾空行，当当前输出的行数等于答案数组行数时，就不输出换行。

我的代码大量使用面向对象的技术。写的比较长，也就 870 行，19KB 左右。

[完整代码](https://www.luogu.com.cn/paste/g8foj21e)

---

## 作者：FrankSteven (赞：8)

### [P3326 [SDOI2015] 立体图](https://www.luogu.com.cn/problem/P3326)
### 简要题意
给定一个网格内正方体堆叠图的俯瞰图，一个九宫格表示不同方向平行光的颜色，建立右手坐标系 $\left\{\bold i,\bold j,\bold k\right\}$，中间为方向 $\left(0,0,-1\right)$ 的光，四周方向为 $\left(m,n,-1\right)\ m,n\in \left\{0,-1\right\}\ m\ne n$，四角方向为 $\left(m,n,-1\right)\ m,n\in \left\{1,-1\right\}$。颜色初始给定“RGB”或者没有光“*”，混合符合光学，用“RGBCPYWK”表示。
### 思路分析和做法参考
光的混合符合二进制或的原则，所以可以对光进行编码，用一个三位二进制数来表示一种光。

分别计算每一个三角形区域的颜色，再绘制到画布上就可以完成。

现来分析光线对三角形区域颜色的影响，给定的光可以分为正交 $45°$ 的光和竖直向下的光。后者处理起来容易，只需要将所有顶面都预设为其颜色即可，然后考虑前者。

此处读者可以暂停阅读并拿出纸笔思考每一种光对于每一个三角形区域在什么情况下三角形区域不会点亮，观察规律。

这里提出我的做法：

观察相对位置的正方体高度会阻挡光线照射相应区域的最低相对高度有如下三类：
   
   I型：
   |     |     |  3  |  3  |
   |-----|-----|-----|-----|
   |     |**2**|**2**|     |
   |**1**|**1**|     |     |
   |  *  |     |     |     |

   
   II型：
   |     |     |  3  |  4  |
   |-----|-----|-----|-----|
   |     |**2**|**3**|     |
   |**1**|**2**|     |     |
   |  *  |     |     |     |
   
   III型：
   |*|1|2|3|4|
   |-|-|-|-|-|

读者容易看出规律，接下来就是表示和找定义。

我将字符画按如下字母标识：

```cpp
const string Cube[] = {
	R"(    +-------+)",
	R"(   /d\aaaa'/|)",
	R"(  /dd.*'bb/e|)",
	R"( /.cccc\b/e/|)",
	R"(+-------+e.f|)",
	R"(|\iiiii/|\:f|)",
	R"(|l\iii/j|h*f|)",
	R"(|ll\i/jj|h:\|)",
	R"(|lllXjjj|h'g+)",
	R"(|ll/k\jj|/g/ )",
	R"(|l/kkk\j|g/  )",
	R"(|/kkkkk\|/   )",
	R"(+-------+    )"
};
```
按照时钟方向标志斜向光方向

如上图分类中 I 和 II 型为一点钟方向，而如下图则为两点钟方向，III 型示例为三点钟方向：

   I型（二点钟）：
   |     |     |     |  3  |
   |-----|-----|-----|-----|
   |     |     |**2**|**3**|
   |     |**1**|**2**|     |
   |  *  |**1**|     |     |

   
   II型 （二点钟）：
   |     |     |     |  4  |
   |-----|-----|-----|-----|
   |     |     |**3**|**3**|
   |     |**2**|**2**|     |
   |  *  |**1**|     |     |

有些侧面的部分还需要按照上述光线模板下移一格，故我在表格中用如“-1I2”表示下移一格，两点钟方向 I 型。

将射线如下编码：

|1|2|3|
|-|-|-|
|**4**|**5**|**6**|
|**7**|**8**|**9**|

上表：

||a|b|c|d|e|f|g|h|i|j|k|l|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|**1**|0I11|0I11|0I11|0I11|/|/|/|/|/|/|/|/|
|**2**|0III12|0III12|0III12|0III12|/|/|/|/|/|/|/|/|
|**3**|0I1|0I2|0I2|0I1|0II2|-1I2|-1I2|0II2|/|/|/|/|
|**4**|0III9|0III9|0III9|0III9|/|/|/|/|/|/|/|/|
|**5**|/|/|/|/|/|/|/|/|/|/|/|/|
|**6**|0III3|0III3|0III3|0III3|-1III3|-1III3|-1III3|-1III3|/|/|/|/|
|**7**|0I8|0I7|0I7|0I8|/|/|/|/|0II7|0II7|-1I7|-1I7|
|**8**|0III6|0III6|0III6|0III6|/|/|/|/|-1III6|-1III6|-1III6|-1III6|
|**9**|0I4|0I4|0I5|0I5|0II4|0II4|-1I4|-1I4|0II5|-1I5|-1I5|0II5|

然后由此表编码即可完成此题

### 代码示例
```cpp
#include <bits/stdc++.h>
using namespace std;

const string ColorSign = "KBGCRPYW";
struct color : bitset<3> {
	color() { bitset(0); }
	char sign() { return ColorSign[to_ulong()]; }
};

bitset<3> getCol(char c) {
	switch (c) {
		case 'R': return bitset<3>(0b100);
		case 'G': return bitset<3>(0b010);
		case 'B': return bitset<3>(0b001);
	}
	return bitset<3>(0b000);
}

struct canvas : vector<string> {
	int x, y, z;
	canvas(int _x, int _y, int _z) : x(_x), y(_y), z(_z) {
		resize(z*8+x*4+1, string(y*8+x*4+1, ' '));
	}
};

const string Cube[] = {
	R"(    +-------+)",
	R"(   /d\aaaa'/|)",
	R"(  /dd.*'bb/e|)",
	R"( /.cccc\b/e/|)",
	R"(+-------+e.f|)",
	R"(|\iiiii/|\:f|)",
	R"(|l\iii/j|h*f|)",
	R"(|ll\i/jj|h:\|)",
	R"(|lllXjjj|h'g+)",
	R"(|ll/k\jj|/g/ )",
	R"(|l/kkk\j|g/  )",
	R"(|/kkkkk\|/   )",
	R"(+-------+    )"
};

struct block {
	int x, y, z;
	vector<color> col;
	block(int _x, int _y, int _z) : x(_x), y(_y), z(_z), col(12, color()) {}
	void print(canvas &mat) {
		for(int i = 0; i < 13; ++i)
			for(int j = 0; j < 13; ++j) {
				if(Cube[i][j] == ' ') continue;
				if(Cube[i][j] == 'X' || !isalpha(Cube[i][j]))
					mat[mat.z*8-z*8+x*4-8+i][mat.x*4+y*8-x*4-4+j] = Cube[i][j];
				else mat[mat.z*8-z*8+x*4-8+i][mat.x*4+y*8-x*4-4+j] = col[Cube[i][j]-'a'].sign();
			}
	}
};

template <typename T>
using mat = vector<vector<T>>;

struct Laser {
	int ty, dir;
};

const int Direction[12][2] = {
	{-1, 1}, {-1, 1}, { 0, 1},
	{ 1, 1}, { 1, 1}, { 1, 0},
	{ 1,-1}, { 1,-1}, { 0,-1},
	{-1,-1}, {-1,-1}, {-1, 0}
};

bool CheckSight(const mat<int> &a,
				size_t x, size_t y, int z, Laser l) {
	if(l.ty == 0) return 0;
	int m = (l.ty == 2) * -1;
	int k = 1 - (l.dir & 1);
	auto [i, j] = Direction[l.dir - 1];
	int x_ = x + k * -1 * i, y_ = y + (k - 1) * j, z_ = z + m;
	for(x += i, y += j, z++;
		x >= 0 && x < a.size() &&
		y >= 0 && y < a[0].size();
		x += i, y += j, z++) {
		if(a[x][y] >= z) return 0;
	}
	if(l.dir % 3 == 0) return 1;
	x = x_, y = y_, z = z_;
	for(x += i, y += j, z++;
		x >= 0 && x < a.size() &&
		y >= 0 && y < a[0].size();
		x += i, y += j, z++) {
		if(a[x][y] >= z) return 0;
	}
	return 1;
}

const int LaserTypes[9][12][3] = {
	{
		{ 0, 1,11}, { 0, 1,11}, { 0, 1,10}, { 0, 1,10},
		{ 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0},
		{ 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0},
	},
	{
		{ 0, 1,12}, { 0, 1,12}, { 0, 1,12}, { 0, 1,12},
		{ 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0},
		{ 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0},
	},
	{
		{ 0, 1, 1}, { 0, 1, 2}, { 0, 1, 2}, { 0, 1, 1},
		{ 0, 2, 2}, {-1, 1, 2}, {-1, 1, 2}, { 0, 2, 2},
		{ 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0},
	},
	{
		{ 0, 1, 9}, { 0, 1, 9}, { 0, 1, 9}, { 0, 1, 9},
		{ 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0},
		{ 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0},
	},
	{
		{ 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0},
		{ 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0},
		{ 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0},
	},
	{
		{ 0, 1, 3}, { 0, 1, 3}, { 0, 1, 3}, { 0, 1, 3},
		{-1, 1, 3}, {-1, 1, 3}, {-1, 1, 3}, {-1, 1, 3},
		{ 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0},
	},
	{
		{ 0, 1, 8}, { 0, 1, 7}, { 0, 1, 7}, { 0, 1, 8},
		{ 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0},
		{ 0, 2, 7}, { 0, 2, 7}, {-1, 1, 7}, {-1, 1, 7},
	},
	{
		{ 0, 1, 6}, { 0, 1, 6}, { 0, 1, 6}, { 0, 1, 6},
		{ 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0},
		{-1, 1, 6}, {-1, 1, 6}, {-1, 1, 6}, {-1, 1, 6},
	},
	{
		{ 0, 1, 4}, { 0, 1, 4}, { 0, 1, 5}, { 0, 1, 5},
		{ 0, 2, 4}, { 0, 2, 4}, {-1, 1, 4}, {-1, 1, 4},
		{ 0, 2, 5}, {-1, 1, 5}, {-1, 1, 5}, { 0, 2, 5},
	}
};
int main() {
	int X, Y, Z = 0;
	cin >> X >> Y;
	mat<int> arr(X,vector<int>(Y));
	vector<char> L(9);
	for(auto &r : arr)
		for(auto &_ : r) {
			cin >> _;
			Z = max(_,Z);
			_--;
		}
	for(auto &_ : L) cin >> _;
	canvas c(X, Y, Z);
	for(int z = 0; z < Z; ++z) 
		for(int x = 0; x < X; ++x) 
			for(int y = 0; y < Y; ++y) 
				if(arr[x][y] - z >= 0) {
					block tmp{x, y, z};
					for(int d = 0; d < 4; ++d)
						tmp.col[d] |= getCol(L[4]);
					for(int l = 0; l < 9; ++l)
						for(int d = 0; d < 12; ++d)
							if(CheckSight(arr, x, y,
								z + LaserTypes[l][d][0],
								{LaserTypes[l][d][1],
									LaserTypes[l][d][2]}))
								tmp.col[d] |= getCol(L[l]);
					tmp.print(c);
				}
	bool INITIAL = 0;
	for(auto s : c)
		if(!INITIAL) {
			if(*max_element(s.begin(),s.end()) == ' ') continue;
			INITIAL = 1;
			cout << s << "\n";
		} else cout << s << "\n";
	return 0;
}
```

#### 代码解读
```cpp
const string ColorSign = "KBGCRPYW";
struct color : bitset<3> {
	color() { bitset(0); }
	char sign() { return ColorSign[to_ulong()]; }
};

bitset<3> getCol(char c) {
	switch (c) {
		case 'R': return bitset<3>(0b100);
		case 'G': return bitset<3>(0b010);
		case 'B': return bitset<3>(0b001);
	}
	return bitset<3>(0b000);
}
```
这部分是关于颜色的逻辑，我继承了 `std::bitset<>` 类，可以方便地完成按位或运算。

```cpp
struct canvas : vector<string> {
	int x, y, z;
	canvas(int _x, int _y, int _z) : x(_x), y(_y), z(_z) {
		resize(z*8+x*4+1, string(y*8+x*4+1, ' '));
	}
};

const string Cube[] = {
	R"(    +-------+)",
	R"(   /d\aaaa'/|)",
	R"(  /dd.*'bb/e|)",
	R"( /.cccc\b/e/|)",
	R"(+-------+e.f|)",
	R"(|\iiiii/|\:f|)",
	R"(|l\iii/j|h*f|)",
	R"(|ll\i/jj|h:\|)",
	R"(|lllXjjj|h'g+)",
	R"(|ll/k\jj|/g/ )",
	R"(|l/kkk\j|g/  )",
	R"(|/kkkkk\|/   )",
	R"(+-------+    )"
};

struct block {
	int x, y, z;
	vector<color> col;
	block(int _x, int _y, int _z) : x(_x), y(_y), z(_z), col(12, color()) {}
	void print(canvas &mat) {
		for(int i = 0; i < 13; ++i)
			for(int j = 0; j < 13; ++j) {
				if(Cube[i][j] == ' ') continue;
				if(Cube[i][j] == 'X' || !isalpha(Cube[i][j]))
					mat[mat.z*8-z*8+x*4-8+i][mat.x*4+y*8-x*4-4+j] = Cube[i][j];
				else mat[mat.z*8-z*8+x*4-8+i][mat.x*4+y*8-x*4-4+j] = col[Cube[i][j]-'a'].sign();
			}
	}
};
```
这是画布和小立方体的绘制部分，定义了颜色数组完成各个面的绘制，并处理坐标转换，便于后续编写。

```cpp
template <typename T>
using mat = vector<vector<T>>;

struct Laser {
	int ty, dir;
};
```
这是一些简单的定义，便于后续传参。

```cpp
const int Direction[12][2] = {
	{-1, 1}, {-1, 1}, { 0, 1},
	{ 1, 1}, { 1, 1}, { 1, 0},
	{ 1,-1}, { 1,-1}, { 0,-1},
	{-1,-1}, {-1,-1}, {-1, 0}
};

bool CheckSight(const mat<int> &a,
				size_t x, size_t y, int z, Laser l) {
	if(l.ty == 0) return 0;
	int m = (l.ty == 2) * -1;
	int k = 1 - (l.dir & 1);
	auto [i, j] = Direction[l.dir - 1];
	int x_ = x + k * -1 * i, y_ = y + (k - 1) * j, z_ = z + m;
	for(x += i, y += j, z++;
		x >= 0 && x < a.size() &&
		y >= 0 && y < a[0].size();
		x += i, y += j, z++) {
		if(a[x][y] >= z) return 0;
	}
	if(l.dir % 3 == 0) return 1;
	x = x_, y = y_, z = z_;
	for(x += i, y += j, z++;
		x >= 0 && x < a.size() &&
		y >= 0 && y < a[0].size();
		x += i, y += j, z++) {
		if(a[x][y] >= z) return 0;
	}
	return 1;
}
```
这是检查被照亮的代码，我在编写的时候将 III 型归入了 I 然后再判断的，不过不影响直观，读者可以自行进一步改进代码。

```cpp
const int LaserTypes[9][12][3] = {
	{
		{ 0, 1,11}, { 0, 1,11}, { 0, 1,10}, { 0, 1,10},
		{ 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0},
		{ 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0},
	},
	{
		{ 0, 1,12}, { 0, 1,12}, { 0, 1,12}, { 0, 1,12},
		{ 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0},
		{ 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0},
	},
	{
		{ 0, 1, 1}, { 0, 1, 2}, { 0, 1, 2}, { 0, 1, 1},
		{ 0, 2, 2}, {-1, 1, 2}, {-1, 1, 2}, { 0, 2, 2},
		{ 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0},
	},
	{
		{ 0, 1, 9}, { 0, 1, 9}, { 0, 1, 9}, { 0, 1, 9},
		{ 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0},
		{ 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0},
	},
	{
		{ 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0},
		{ 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0},
		{ 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0},
	},
	{
		{ 0, 1, 3}, { 0, 1, 3}, { 0, 1, 3}, { 0, 1, 3},
		{-1, 1, 3}, {-1, 1, 3}, {-1, 1, 3}, {-1, 1, 3},
		{ 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0},
	},
	{
		{ 0, 1, 8}, { 0, 1, 7}, { 0, 1, 7}, { 0, 1, 8},
		{ 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0},
		{ 0, 2, 7}, { 0, 2, 7}, {-1, 1, 7}, {-1, 1, 7},
	},
	{
		{ 0, 1, 6}, { 0, 1, 6}, { 0, 1, 6}, { 0, 1, 6},
		{ 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0}, { 0, 0, 0},
		{-1, 1, 6}, {-1, 1, 6}, {-1, 1, 6}, {-1, 1, 6},
	},
	{
		{ 0, 1, 4}, { 0, 1, 4}, { 0, 1, 5}, { 0, 1, 5},
		{ 0, 2, 4}, { 0, 2, 4}, {-1, 1, 4}, {-1, 1, 4},
		{ 0, 2, 5}, {-1, 1, 5}, {-1, 1, 5}, { 0, 2, 5},
	}
};
int main() {
	int X, Y, Z = 0;
	cin >> X >> Y;
	mat<int> arr(X,vector<int>(Y));
	vector<char> L(9);
	for(auto &r : arr)
		for(auto &_ : r) {
			cin >> _;
			Z = max(_,Z);
			_--;
		}
	for(auto &_ : L) cin >> _;
	canvas c(X, Y, Z);
	for(int z = 0; z < Z; ++z) 
		for(int x = 0; x < X; ++x) 
			for(int y = 0; y < Y; ++y) 
				if(arr[x][y] - z >= 0) {
					block tmp{x, y, z};
					for(int d = 0; d < 4; ++d)
						tmp.col[d] |= getCol(L[4]);
					for(int l = 0; l < 9; ++l)
						for(int d = 0; d < 12; ++d)
							if(CheckSight(arr, x, y,
								z + LaserTypes[l][d][0],
								{LaserTypes[l][d][1],
									LaserTypes[l][d][2]}))
								tmp.col[d] |= getCol(L[l]);
					tmp.print(c);
				}
	bool INITIAL = 0;
	for(auto s : c)
		if(!INITIAL) {
			if(*max_element(s.begin(),s.end()) == ' ') continue;
			INITIAL = 1;
			cout << s << "\n";
		} else cout << s << "\n";
	return 0;
}
```
上述表格和主要的绘制逻辑。

由于笔者能力有限，代码尽力做到简洁清晰简明了，如有不妥当处请留下评论，笔者非常乐意起到抛砖引玉的作用。不过感兴趣的读者如果不满足于现有示例代码的运行效率，可以尝试优化，减少重复类型的枚举判断可以大幅度优化时间常数。这里已经足够通过此题，且考虑到只是作为一个思路的提示，就不作修改了。

---

## 作者：henryhu2006 (赞：5)

### 题意

给定一个 $m\times n$ 的平面，每个格子上有 $h_{i.j}$ 个正方体叠在一起。

有九个具有竖直分量的光线，颜色为三原色的共 $8$ 种组合，要求输出立体图（从东南方向观察）。

$n,m,\max{h_{i,j}}\le100$。

### 约定
1. 规定坐标轴为常用的三维坐标画法，以南为 $x$ 正方向，东为 $y$ 正方向，上为 $z$ 正方向。

![](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.puchedu.cn%2Fuploads%2F1%2F26%2F122280533%2F1641185377.jpg&refer=http%3A%2F%2Fimg.puchedu.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1662592780&t=92bce04a0c5b5236d6f35638e99df16a)

2. 规定 $x$ 行 $y$ 列，从下往上第 $z$ 的格子中心坐标为 $(x,y,z)$，棱长为 $1$。

3. 规定 $12$ 个三角形按照顶 ($0\sim 3$)、前（$4\sim7$）、右（$8\sim11$）进行编号。在同一面上，则分别头顶向北、上、上观察，依次按照上左右下排列。以下用 $a\sim l$ 表示 $12$ 个三角形的位置。

```
    +-------+
   /b\aaaa'/|
  /bb.*'cc/i|
 /.dddd\c/i/|
+-------+i.k|
|\eeeee/|\:k|
|f\eee/g|j*k|
|ff\e/gg|j:\|
|fffXggg|j'l+
|ff/h\gg|/l/ 
|f/hhh\g|l/  
|/hhhhh\|/   
+-------+    
```
### 计算颜色
为避免大规模耗脑的分类讨论，考虑使用原始的算法。对于每个三角形，向九个方向分别发出射线，只需判断是否被正方体遮挡即可。

由于三角形发射比较麻烦，因此只取其中一个点（本文取面中心到边的线段的中点）。接着向指定方向每次走一小步，判断处在的位置是否包含在一个正方体中。容易发现，在之前的约定下，只需对每个坐标值进行四舍五入即可（不考虑边界）。

步长（坐标轴分量），不能太大，否则会直接穿透正方体；不能太小，否则效率过低。本文步长取 $0.125$。

对于和平面平行的光线方向，建议直接进行特判，因为难以统一化处理。

颜色叠加使用 $3$ 位二进制，分别对应是否含有 $\text{\color{red}R\color{green}G\color{blue}B}$。本文的颜色编号（$0\sim 7$）分别对应 $\text{K\color{red}R\color{green}G\color{dddd00}Y\color{blue}B\color{pink}P\color{lightblue}C\color{white}W}$。$\leftarrow$ 这里还有一个白色。使用或运算即可叠加颜色。

### 如何输出
可以发现，如果 $(m,1,1)$ 的方块**左前下顶点**位于 $(L,0)$（$L$ 为常数，以输出大小决定），对于 $(x,y,z)$ 的方块，它的**左前下顶点**位于 $(L-4m-4x+8z-8,8y-8+4m-4x)$。按照从远到近的顺序，根据上面那个示意图，输出时去掉开头空行。

### 优化
如果对每个立方体都进行“光线追踪”，那么效率过低，复杂度是 $\mathcal O(n^4)$ 的，浮点运算常数大，无法通过。

此时可以从近到远渲染。如果远的物体所占的格子已经被全部渲染（被完全遮挡），那么可以直接跳过它的颜色计算，此时三角形数量可以降到 $\mathcal O(n^2)$，复杂度降到 $\mathcal O(n^3)$。

### 代码
上面示意图输入时，需要将 `\` 替换成其它没有出现过的字符。

长度仅 $2392$ 字节（不含注释），远短于绝大多数代码。可以参考注释理解。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=105,M=2005;
const int drx[4]={-1,0,0,1},dry[4]={0,-1,1,0}; 

string bs[13]={
"    +-------+",
"   /b]aaaa'/|",
"  /bb.*'cc/i|",
" /.dddd]c/i/|",
"+-------+i.k|",
"|]eeeee/|]:k|",
"|f]eee/g|j*k|",
"|ff]e/gg|j:]|",
"|fffXggg|j'l+",
"|ff/h]gg|/l/ ",
"|f/hhh]g|l/  ",
"|/hhhhh]|/   ",
"+-------+    "
}; // ] 字符：如上文
int m,n,h,hei[N][N],nc[128];
char lc[3][5],ans[M][M];
string cn="KRGYBPCW";
bool ext[N][N][N];
bool check(int x,int y,int z,int s,int dx,int dy){
	--dx,--dy; int dz=1;
	double nx,ny,nz;
	if(s<4 &&s>=0) nz=z+0.5,nx=x+0.25*drx[s&3],ny=y+0.25*dry[s&3];
	if(s<8 &&s>=4) nx=x+0.5,ny=y+0.25*dry[s&3],nz=z-0.25*drx[s&3];
	if(s<12&&s>=8) ny=y+0.5,nx=x-0.25*dry[s&3],nz=z-0.25*drx[s&3];
	// 计算起始坐标
	if(s<8&&s>=4&&!dx&&dy) return 0;
	if(s>=8&&dx&&!dy) return 0;
	if(s>=4&&!dx&&!dy) return 0;
	// 光线擦过平面特判
	double tx=dx*0.125,ty=dy*0.125,tz=dz*0.125;
	nx+=tx,ny+=ty,nz+=tz;
	while(nx>0&&ny>0&&nz>0&&nx<m+1&&ny<n+1&&nz<h+1){
		if(ext[(int)(nx+0.5)][(int)(ny+0.5)][(int)(nz+0.5)]) return 0;
		nx+=tx,ny+=ty,nz+=tz;
	} // "光线追踪"
	return 1;
}
void print(int x,int y,int *s){
	for(int i=0;i<13;++i)
	for(int j=0;j<13;++j){
		if(ans[x-12+i][y+j]) continue;
		if(bs[i][j]==']') ans[x-12+i][y+j]='\\'; // 反斜杠替换
		else if(isalpha(bs[i][j])&&bs[i][j]!='X') ans[x-12+i][y+j]=cn[s[bs[i][j]-'a']]; // 面编号
		else if(bs[i][j]!=' ') ans[x-12+i][y+j]=bs[i][j];
	}
}
int main(){
	cin>>m>>n;
	for(int i=1;i<=m;++i)
		for(int j=1;j<=n;++j){
			scanf("%d",&hei[i][j]),h=max(h,hei[i][j]);
			for(int k=1;k<=hei[i][j];++k) ext[i][j][k]=1;
		}
	for(int i:{0,1,2}) scanf("%s",lc[i]);
	for(int i=0;i<8;++i) nc[cn[i]]=i;
	for(int i=m,sx,sy,col[12];i;--i)
	for(int j=n;j;--j)
	for(int k=hei[i][j];k;--k){
		sx=(k-1)*8+(m-i)*4,sx=M-1-sx,sy=(j-1)*8+(m-i)*4;
		memset(col,0,sizeof(col)); bool und=1;
		for(int w1=0;w1<13&&und;++w1)
		for(int w2=0;w2<13&&und;++w2)
			if(!ans[sx-12+w1][sy+w2]) und=0;
		if(und) continue; // 完全覆盖直接跳过
		for(int s=0;s<12;++s)
		for(int w1:{0,1,2}) for(int w2:{0,1,2}){
			if(lc[w1][w2]=='*') continue;
			if(check(i,j,k,s,w1,w2)) col[s]|=nc[lc[w1][w2]];
		} // 颜色叠加
		print(sx,sy,col);
	}
	for(int i=0;i<M;++i){
		bool fd=0;
		for(int j=0;j<M;++j)
			if(ans[i][j]){fd=1; break;}
		if(!fd) continue;
		int j=M-1;
		while(!ans[i][j]) --j; // 去除空行
		for(int k=0;k<=j;++k) putchar(ans[i][k]?ans[i][k]:' ');
		puts("");
	}
	return 0;
} 
```

---

## 作者：0x3F (赞：4)

本文讲解做题的思路，而不是实现方法。

需要做的事情有三个：

1. 输入。

这没什么好说的。

2. 投影处理。

求出每一个小立方体的 12 个小三角形的颜色。

3. 渲染输出。

和[这题](https://www.luogu.com.cn/problem/P1058)类似，按顺序打印出来，让前面的自然覆盖后面的。

其中投影处理是最难的。尝试分类讨论。

投影有九个方向，分为三类。

1. 投影方向为正上方。

2. 投影方向为东，南，西，北。

3. 投影方向为东南，东北，西南，西北。

第一个最简单：最上面的立方体的顶面有光。

代码如下：

```cpp
for (int i = 1; i <= n; i++) {
	for (int j = 1; j <= m; j++) {
		if (h[i][j]) {
			for (int k = 1; k <= 4; k++) {
				c[i][j][h[i][j]][k] |= l[1][1];
			}
		}
	} 
}
```


第二个：可以用横平竖直的直线将光分为 $m$ 或 $n$ 束，分开考虑。

以正南方的光线为例，代码如下：

```cpp
for (int i = 1; i <= m; i++) {
	for (int j = n, t = 0; j >= 1; j--, t--) {
		if (h[j][i] >= t) {
			if (h[j][i]) {
				for (int k = 1; k <= 4; k++) {
					c[j][i][h[j][i]][k] |= l[2][1];
				}
				for (int d = t+1; d <= h[j][i]; d++) {
					for (int k = 5; k <= 8; k++) {
						c[j][i][d][k] |= l[2][1];
					}
				}
			}
			t = h[j][i] + 1;
		}
	}
}
```

第三个，也是最复杂的一个。可以用倾斜的直线将光分为 $m+n$ 束，分开考虑。

以东南方的光线为例，代码如下：

```cpp
for (int p = 1; p <= m; p++) {
	for (int i = n, j = p, s = 0, t = 0;;) {
		if (h[i][j] >= t) {
			if (h[i][j]) {
				for (int k = 3; k <= 4; k++) {
					c[i][j][h[i][j]][k] |= l[2][2];
				}
			}
			for (int d = t+1; d <= h[i][j]; d++) {
				for (int k = 5; k <= 8; k++) {
					c[i][j][d][k] |= l[2][2];
				}
			}
			if (s != t) {
				for (int k = 5; k <= 8; k += 3) {
					c[i][j][t][k] |= l[2][2];
				}
			}
			t = h[i][j] + 1;
			s = h[i][j];
		}
		t--;
		j--;
		if (j < 1) break;
		if (h[i][j] >= s) {
			if (h[i][j]) {
				for (int k = 1; k <= 2; k++) {
					c[i][j][h[i][j]][k] |= l[2][2];
				}
			}
			for (int d = s+1; d <= h[i][j]; d++) {
				for (int k = 9; k <= 12; k++) {
					c[i][j][d][k] |= l[2][2];
				}
			}
			if (s != t) {
				for (int k = 9; k <= 10; k++) {
					c[i][j][s][k] |= l[2][2];
				}
			}
			s = h[i][j] + 1;
			t = h[i][j];
		}
		s--;
		i--;
		if (i < 1) break;
	}
}
for (int p = 1; p <= n; p++) {
	for (int i = p, j = m, s = 0, t = 0;;) {
		if (h[i][j] >= s) {
			if (h[i][j]) {
				for (int k = 1; k <= 2; k++) {
					c[i][j][h[i][j]][k] |= l[2][2];
				}
			}
			for (int d = s+1; d <= h[i][j]; d++) {
				for (int k = 9; k <= 12; k++) {
					c[i][j][d][k] |= l[2][2];
				}
			}
			if (s != t) {
				for (int k = 9; k <= 10; k++) {
					c[i][j][s][k] |= l[2][2];
				}
			}
			s = h[i][j] + 1;
			t = h[i][j];
		}
		s--;
		i--;
		if (i < 1) break;
		if (h[i][j] >= t) { 
			if (h[i][j]) {
				for (int k = 3; k <= 4; k++) {
					c[i][j][h[i][j]][k] |= l[2][2];
				}
			}
			for (int d = t+1; d <= h[i][j]; d++) {
				for (int k = 5; k <= 8; k++) {
					c[i][j][d][k] |= l[2][2];
				}
			}
			if (s != t) {
				for (int k = 5; k <= 8; k += 3) {
					c[i][j][t][k] |= l[2][2];
				}
			}
			t = h[i][j] + 1;
			s = h[i][j];
		}
		t--;
		j--;
		if (j < 1) break;
	}
}
```

最后给一个总代码，尽管有些长，影响观感。

```cpp
#include <cstdio>
const char lit[10] = {42, 82, 71, 66};
const char col[10] = {75, 82, 71, 89, 66, 80, 67, 87};
const char base[15][15] =
{{43, 45, 45, 45, 45, 45, 45, 45, 43},
{124, 47, 7, 7, 7, 7, 7, 92, 124, 47},
{124, 8, 47, 7, 7, 7, 92, 6, 124, 11, 47},
{124, 8, 8, 47, 7, 92, 6, 6, 124, 47, 11, 47},
{124, 8, 8, 8, 88, 6, 6, 6, 124, 12, 39, 11, 43},
{124, 8, 8, 92, 5, 47, 6, 6, 124, 12, 58, 92, 124},
{124, 8, 92, 5, 5, 5, 47, 6, 124, 12, 42, 10, 124},
{124, 92, 5, 5, 5, 5, 5, 47, 124, 92, 58, 10, 124},
{43, 45, 45, 45, 45, 45, 45, 45, 43, 9, 46, 10, 124},
{0, 47, 46, 3, 3, 3, 3, 92, 2, 47, 9, 47, 124},
{0, 0, 47, 4, 4, 46, 42, 39, 2, 2, 47, 9, 124},
{0, 0, 0, 47, 4, 92, 1, 1, 1, 1, 39, 47, 124},
{0, 0, 0, 0, 43, 45, 45, 45, 45, 45, 45, 45, 43}};
const int Xy = 8;
const int Yx = 4;
const int Yy = 4;
const int Zx = 8;
const int height = 12;
const int width[15] = {8, 9, 10, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12};
char canvas[1500][1500];
int canvasheight, canvaswidth[1500];
int canvasleft = -1, canvasdown = -1;
char lighting[5][5];
int n, m, h[105][105];
int l[5][5];
int c[105][105][105][14];
int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			scanf("%d", h[i] + j);
		}
	}
	for (int i = 0; i <= 2; i++) {
		scanf("%s", lighting[i]);
	}
	for (int i = 0; i <= 2; i++) {
		for (int j = 0; j <= 2; j++) {
			for (int k = 0; k <= 3; k++) {
				if (lighting[i][j] == lit[k]) l[i][j] = k;
			}
			if (l[i][j]) l[i][j] = (1 << (l[i][j] - 1));
		}
	}
	for (int p = 1; p <= m; p++) {
		for (int i = 1, j = p, s = 0, t = 0;;) {
			if (h[i][j] >= t) {
				if (h[i][j]) {
					for (int k = 1; k <= 2; k++) {
						c[i][j][h[i][j]][k] |= l[0][0];
					}
				}
				t = h[i][j] + 1;
				s = h[i][j];
			}
			t--;
			j++;
			if (j > n) break;	
			if (h[i][j] >= s) {
				if (h[i][j]) {
					for (int k = 3; k <= 4; k++) {
						c[i][j][h[i][j]][k] |= l[0][0];
					}
				}
				s = h[i][j] + 1;
				t = h[i][j];
			}
			s--;
			i++;
			if (i > m) break;
		}
	}
	for (int p = 1; p <= n; p++) {
		for (int i = p, j = 1, s = 0, t = 0;;) {
			if (h[i][j] >= s) {
				if (h[i][j]) {
					for (int k = 3; k <= 4; k++) {
						c[i][j][h[i][j]][k] |= l[0][0];
					}
				}
				s = h[i][j] + 1;
				t = h[i][j];
			}
			s--;
			i++;
			if (i > m) break;
			if (h[i][j] >= t) {
				if (h[i][j]) {
					for (int k = 1; k <= 2; k++) {
						c[i][j][h[i][j]][k] |= l[0][0];
					}
				}
				t = h[i][j] + 1;
				s = h[i][j];
			}
			t--;
			j++;
			if (j > n) break;
		}
	}
	for (int i = 1; i <= m; i++) {
		for (int j = 1, t = 0; j <= n; j++, t--) {
			if (h[j][i] >= t) {
				if (h[j][i]) {
					for (int k = 1; k <= 4; k++) {
						c[j][i][h[j][i]][k] |= l[0][1];
					}
				}
				t = h[j][i] + 1;
			}
		}
	}
	for (int p = 1; p <= m; p++) {
		for (int i = 1, j = p, s = 0, t = 0;;) {
			if (h[i][j] >= t) {
				if (h[i][j]) {
					for (int k = 1; k <= 4; k += 3) {
						c[i][j][h[i][j]][k] |= l[0][2];
					}
				}
				t = h[i][j] + 1;
				s = h[i][j];
			}
			t--;
			j--;
			if (j < 1) break;
			if (h[i][j] >= s) {
				if (h[i][j]) {
					for (int k = 2; k <= 3; k++) {
						c[i][j][h[i][j]][k] |= l[0][2];
					}
				}
				for (int d = s+1; d <= h[i][j]; d++) {
					for (int k = 9; k <= 12; k++) {
						c[i][j][d][k] |= l[0][2];
					}
				}
				if (s != t) {
					for (int k = 9; k <= 12; k += 3) {
						c[i][j][s][k] |= l[0][2];
					}
				}
				s = h[i][j] + 1;
				t = h[i][j];
			}
			s--;
			i++;
			if (i > n) break;
		}
	}
	for (int p = 1; p <= n; p++) {
		for (int i = p, j = m, s = 0, t = 0;;) {
			if (h[i][j] >= s) {
				if (h[i][j]) {
					for (int k = 2; k <= 3; k++) {
						c[i][j][h[i][j]][k] |= l[0][2];
					}
					for (int d = s+1; d <= h[i][j]; d++) {
						for (int k = 9; k <= 12; k++) {
							c[i][j][d][k] |= l[0][2];
						}
					}
					if (s != t) {
						for (int k = 9; k <= 12; k += 3) {
							c[i][j][s][k] |= l[0][2];
						}
					}
				}
				s = h[i][j] + 1;
				t = h[i][j];
			}
			s--;
			i++;
			if (i > n) break;
			if (h[i][j] >= t) {
				if (h[i][j]) {
					for (int k = 1; k <= 4; k += 3) {
						c[i][j][h[i][j]][k] |= l[0][2];
					}
				}
				t = h[i][j] + 1;
				s = h[i][j];
			}
			t--;
			j--;
			if (j < 1) break;
		}
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1, t = 0; j <= m; j++, t--) {
			if (h[i][j] >= t) {
				if (h[i][j]) {
					for (int k = 1; k <= 4; k++) {
						c[i][j][h[i][j]][k] |= l[1][0];
					}
				}
				t = h[i][j] + 1;
			}
		}
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			if (h[i][j]) {
				for (int k = 1; k <= 4; k++) {
					c[i][j][h[i][j]][k] |= l[1][1];
				}
			}
		} 
	}
	for (int i = 1; i <= n; i++) {
		for (int j = m, t = 0; j >= 1; j--, t--) {
			if (h[i][j] >= t) {
				if (h[i][j]) {
					for (int k = 1; k <= 4; k++) {
						c[i][j][h[i][j]][k] |= l[1][2];
					}
					for (int d = t+1; d <= h[i][j]; d++) {
						for (int k = 9; k <= 12; k++) {
							c[i][j][d][k] |= l[1][2];
						}
					}
				}
				t = h[i][j] + 1;
			}
		}
	}
	for (int p = 1; p <= m; p++) {
		for (int i = n, j = p, s = 0, t = 0;;) {
			if (h[i][j] >= t) {
				if (h[i][j]) {
					for (int k = 2; k <= 3; k++) {
						c[i][j][h[i][j]][k] |= l[2][0];
					}
				}
				for (int d = t+1; d <= h[i][j]; d++) {
					for (int k = 5; k <= 8; k++) {
						c[i][j][d][k] |= l[2][0];
					}
				}
				if (s != t) {
					for (int k = 5; k <= 6; k++) {
						c[i][j][t][k] |= l[2][0];
					}
				}
				t = h[i][j] + 1;
				s = h[i][j];
			}
			t--;
			j++;
			if (j > m) break;
			if (h[i][j] >= s) {
				if (h[i][j]) {
					for (int k = 1; k <= 4; k += 3) {
						c[i][j][h[i][j]][k] |= l[2][0];
					}
				}
				s = h[i][j] + 1;
				t = h[i][j];
			}
			s--;
			i--;
			if (i < 1) break;
		}
	}
	for (int p = 1; p <= n; p++) {
		for (int i = p, j = 1, s = 0, t = 0;;) {
			if (h[i][j] >= s) {
				if (h[i][j]) {
					for (int k = 1; k <= 4; k += 3) {
						c[i][j][h[i][j]][k] |= l[2][0];
					}
				}
				s = h[i][j] + 1;
				t = h[i][j];
			}
			s--;
			i--;
			if (i < 1) break;
			if (h[i][j] >= t) {
				if (h[i][j]) {
					for (int k = 2; k <= 3; k++) {
						c[i][j][h[i][j]][k] |= l[2][0];
					}
				}
				for (int d = t+1; d <= h[i][j]; d++) {
					for (int k = 5; k <= 8; k++) {
						c[i][j][d][k] |= l[2][0];
					}
				}
				if (s != t) {
					for (int k = 5; k <= 6; k++) {
						c[i][j][t][k] |= l[2][0];
					}
				}
				t = h[i][j] + 1;
				s = h[i][j];
			}
			t--;
			j++;
			if (j > m) break;
		}
	}
	for (int i = 1; i <= m; i++) {
		for (int j = n, t = 0; j >= 1; j--, t--) {
			if (h[j][i] >= t) {
				if (h[j][i]) {
					for (int k = 1; k <= 4; k++) {
						c[j][i][h[j][i]][k] |= l[2][1];
					}
					for (int d = t+1; d <= h[j][i]; d++) {
						for (int k = 5; k <= 8; k++) {
							c[j][i][d][k] |= l[2][1];
						}
					}
				}
				t = h[j][i] + 1;
			}
		}
	}
	for (int p = 1; p <= m; p++) {
		for (int i = n, j = p, s = 0, t = 0;;) {
			if (h[i][j] >= t) {
				if (h[i][j]) {
					for (int k = 3; k <= 4; k++) {
						c[i][j][h[i][j]][k] |= l[2][2];
					}
				}
				for (int d = t+1; d <= h[i][j]; d++) {
					for (int k = 5; k <= 8; k++) {
						c[i][j][d][k] |= l[2][2];
					}
				}
				if (s != t) {
					for (int k = 5; k <= 8; k += 3) {
						c[i][j][t][k] |= l[2][2];
					}
				}
				t = h[i][j] + 1;
				s = h[i][j];
			}
			t--;
			j--;
			if (j < 1) break;
			if (h[i][j] >= s) {
				if (h[i][j]) {
					for (int k = 1; k <= 2; k++) {
						c[i][j][h[i][j]][k] |= l[2][2];
					}
				}
				for (int d = s+1; d <= h[i][j]; d++) {
					for (int k = 9; k <= 12; k++) {
						c[i][j][d][k] |= l[2][2];
					}
				}
				if (s != t) {
					for (int k = 9; k <= 10; k++) {
						c[i][j][s][k] |= l[2][2];
					}
				}
				s = h[i][j] + 1;
				t = h[i][j];
			}
			s--;
			i--;
			if (i < 1) break;
		}
	}
	for (int p = 1; p <= n; p++) {
		for (int i = p, j = m, s = 0, t = 0;;) {
			if (h[i][j] >= s) {
				if (h[i][j]) {
					for (int k = 1; k <= 2; k++) {
						c[i][j][h[i][j]][k] |= l[2][2];
					}
				}
				for (int d = s+1; d <= h[i][j]; d++) {
					for (int k = 9; k <= 12; k++) {
						c[i][j][d][k] |= l[2][2];
					}
				}
				if (s != t) {
					for (int k = 9; k <= 10; k++) {
						c[i][j][s][k] |= l[2][2];
					}
				}
				s = h[i][j] + 1;
				t = h[i][j];
			}
			s--;
			i--;
			if (i < 1) break;
			if (h[i][j] >= t) {
				if (h[i][j]) {
					for (int k = 3; k <= 4; k++) {
						c[i][j][h[i][j]][k] |= l[2][2];
					}
				}
				for (int d = t+1; d <= h[i][j]; d++) {
					for (int k = 5; k <= 8; k++) {
						c[i][j][d][k] |= l[2][2];
					}
				}
				if (s != t) {
					for (int k = 5; k <= 8; k += 3) {
						c[i][j][t][k] |= l[2][2];
					}
				}
				t = h[i][j] + 1;
				s = h[i][j];
			}
			t--;
			j--;
			if (j < 1) break;
		}
	}
	for (int i = 0; i <= 1499; i++) {
		for (int j = 0; j <= 1499; j++) {
			canvas[i][j] = 32;
		}
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			for (int k = 1; k <= h[i][j]; k++) {
				int x = (n - i) * Yx + (k - 1) * Zx;
				int y = (j - 1) * Xy + (n - i) * Yy;
				if (canvasleft == -1 || canvasleft > y) canvasleft = y;
				if (canvasdown == -1 || canvasdown > x) canvasdown = x;
				if (x + height > canvasheight) canvasheight = x + height;
				for (int a = 0; a <= height; a++) {
					if (y + width[a] > canvaswidth[x + a]) canvaswidth[x + a] = y + width[a];
					for (int b = 0; b <= width[a]; b++) {
						if (base[a][b] >= 1 && base[a][b] <= 12) {
							canvas[x + a][y + b] = col[c[i][j][k][base[a][b]]];
						} else if (base[a][b]) {
							canvas[x + a][y + b] = base[a][b];
						}
					}
				}
			}
		}
	}
	for (int i = canvasheight; i >= canvasdown; i--) {
		for (int j = canvasleft; j <= canvaswidth[i]; j++) {
			putchar(canvas[i][j]);
		}
		if (i) putchar(10);
	}
	return 0;
}
```


---

## 作者：123asdf123 (赞：3)

我第一道真正 AC 的黑题

# 输出立方体
> 对于15%的数据，1<=n,m<=100,没有入射光。

类似 [P1058 [NOIP2008 普及组] 立体图](https://www.luogu.com.cn/problem/P1058)，先定义正方体，**记得把 \\ 写成 \\\\，不然是转义字符** ，再定义画图函数，找该输出的坐标画上去就行了。

输出的高度：（以下 $high[x][y]$ 均表示 $x$ 行 $y$ 列的方块数）
$$\max_{x\in [1,n]\cap y \in [1,m]}{(n-x)*4+5+high[x][y]*8}$$
后面的方块一排后退 $4$ 格高，上面宽 $5$ 格，叠着的方块每个高 $8$ 格。


输出的宽度：
$$\max_{x\in [1,n]\cap y \in [1,m]}{y*8+5+(n-x)*4}$$
堆在一起的方块每个宽 $8$ 格，侧面宽 $5$ 格，后面的方块一排后退 $4$ 格宽。

15pts code：
```cpp
#include<bits/stdc++.h>
using namespace std;
string cube[16]={"",//立方体
"     +-------+",
"    /K\\KKKK'/|",
"   /KK.*'KK/K|",
"  /.KKKK\\K/K/|",
" +-------+K.K|",
" |\\KKKKK/|\\:K|",
" |K\\KKK/K|K*K|",
" |KK\\K/KK|K:\\|",
" |KKKXKKK|K'K+",
" |KK/K\\KK|/K/ ",
" |K/KKK\\K|K/  ",
" |/KKKKK\\|/   ",
" +-------+    "
};
char a[1603][1303],light[6][6];//输出的图和储存输入光线的数组
int high[103][103];//立方体高度
void draw(int x,int y){
	for(int i=1;i<=13;i++)
		for(int j=1;j<=13;j++)
			if(cube[i][j]!=' ')//如果是立方体内
				a[x+i-1][y+j-1]=cube[i][j];//覆盖
}
int main(){
	memset(a,' ',sizeof(a));//全初始化为空格
	int n,m,h=0,w=0,pos;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			scanf("%d",&high[i][j]);
			h=max(h,(n-i)*4+5+high[i][j]*8);//计算输出高度
			w=max(w,j*8+5+(n-i)*4);//计算输出宽度
		}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			for(int k=1;k<=high[i][j];k++)
				draw(h-((n-i)*4+5+k*8)+1,(j-1)*8+5+(n-i-1)*4);//画到相应的位置，因为按顺序来画，所以刚好可以覆盖被挡住的
	scanf("\n%c%c%c\n%c%c%c\n%c%c%c",&light[1][1],&light[1][2],&light[1][3],&light[2][1],&light[2][2],&light[2][3],&light[3][1],&light[3][2],&light[3][3]);//输入光线位置，但这里不处理
	for(int i=1;i<=h;i++){
		pos=w;
		while(pos>=1&&a[i][pos]==' ')
			pos--;
		for(int j=1;j<=pos;j++)
			printf("%c",a[i][j]);
		if(i!=h)
			printf("\n");
	}
	return 0;
}
```
# 光线
先定义如何叠加颜色（十分原始，懒得改了）。
```cpp
void addcolorr(int x,int y){//叠加红色
	if(a[x][y]=='K')
		a[x][y]='R';
	if(a[x][y]=='G')
		a[x][y]='Y';
	if(a[x][y]=='B')
		a[x][y]='P';
	if(a[x][y]=='C')
		a[x][y]='W';
}
void addcolorg(int x,int y){//叠加绿色
	if(a[x][y]=='K')
		a[x][y]='G';
	if(a[x][y]=='R')
		a[x][y]='Y';
	if(a[x][y]=='B')
		a[x][y]='C';
	if(a[x][y]=='P')
		a[x][y]='W';
}
void addcolorb(int x,int y){//叠加蓝色
	if(a[x][y]=='K')
		a[x][y]='B';
	if(a[x][y]=='R')
		a[x][y]='P';
	if(a[x][y]=='G')
		a[x][y]='C';
	if(a[x][y]=='Y')
		a[x][y]='W';
}
void addcolor(int x,int y,char c){//合并，方便调用
	if(c=='R')
		addcolorr(x,y);
	if(c=='G')
		addcolorg(x,y);
	if(c=='B')
		addcolorb(x,y);
}
```
根据样例，可以看出，正方体要输出最多可以分为 12 个块（3 个面，一个面 4 个部分），此处面叫做 $way$，块叫 $block$：
```cpp
string way[16]={"",
"     000000000",
"    0202222000",
"   02200022030",
"  002222020300",
" 0000000003030",
" 0011111000030",
" 0101110103030",
" 0110101103000",
" 0111011103030",
" 011010110030 ",
" 01011101030  ",
" 0011111000   ",
" 000000000    "
};
string block[16]={"",
"     000000000",
"    0201111000",
"   02200044010",
"  003333040100",
" 0000000001040",
" 0011111000040",
" 0201110402040",
" 0220104402000",
" 0222044402030",
" 022030440030 ",
" 02033304030  ",
" 0033333000   ",
" 000000000    "
};
```
（$0$ 代表不属于任何一个块，但存在。）

因此需要改一下 draw 函数：
```cpp
struct face{
	int way,block,x,y,h;//记录某个位置属于第x行y列h格高way面block块
/*
way:
    +-------+
   /2\2222'/|
  /22.*'22/3|
 /.2222\2/3/|
+-------+3.3|
|\11111/|\:3|
|1\111/1|3*3|
|11\1/11|3:\|
|111X111|3'3+
|11/1\11|/3/
|1/111\1|3/
|/11111\|/
+-------+
block:
    +-------+
   /2\1111'/|
  /22.*'44/1|
 /.3333\4/1/|
+-------+1.4|
|\11111/|\:4|
|2\111/4|2*4|
|22\1/44|2:\|
|222X444|2'3+
|22/3\44|/3/
|2/333\4|3/
|/33333\|/
+-------+
*/
}type[1603][1303];
```
```cpp
void draw(int x,int y,int rx,int ry,int rh){
	for(int i=1;i<=13;i++)
		for(int j=1;j<=13;j++){
			if(cube[i][j]!=' '){
				a[x+i-1][y+j-1]=cube[i][j];
				type[x+i-1][y+j-1]={way[i][j]-'0',block[i][j]-'0',rx,ry,rh};//增加的话
			}
		}
}
```

再记录 $x$ 行 $y$ 列 $h$ 格高的立方体在输出图的数组上有哪些点：
```cpp
vector<pair<int,int>>v[103][103][103];
```
```cpp
for(int i=1;i<=h;i++)
		for(int j=1;j<=w;j++)
			v[type[i][j].x][type[i][j].y][type[i][j].h].push_back(make_pair(i,j));//反过去统计就行了
```
## 正中间
最简单，不会发生任何遮挡，直接判断 $way$ 是否等于 $2$。
```cpp
/*                                    
***                                   
*X*                                   
***                                   
*/                                    
for(int i=1;i<=h;i++)                 
	for(int j=1;j<=w;j++)             
		if(type[i][j].way==2)         
			addcolor(i,j,light[2][2]);
```
## 上 / 下 / 左 / 右方
**（以下都以右方的光线为例）**

比较麻烦，如图：（蓝色是目标物，红色是遮挡物）

![挂了](https://asdf123asdf123asdf123.github.io/image-host/立体图图片/cover.png)

假设 $x$ 行 $y+1$ 列 $h$ 及以下的立方体都被挡住了，那么 $x$ 行 $y$ 列最高的被完全挡住的就是第 $\max(h-1,high[x][y+1]-1)$ 个。

**但这还不对！**

![挂了](https://asdf123asdf123asdf123.github.io/image-host/立体图图片/coverside.png)

如果 $x$ 行 $y+1$ 列完全挡了 $h$ 个，那么$x$ 行 $y$ 列第 $h$ 个虽然不完全被挡，但右方对应的面不被更新。

不同方向要更新的面：
- 上：上。
- 下：上、前。
- 左：上。
- 右：上、右。

some code：
```cpp
/*
*X*
***
***
*/
for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
		for(int k=1;k<=high[i][j];k++){
			pre[i][j]=max(pre[i-1][j]-1,high[i][j]);//pre数组用于记录遮挡几个（但我还包括了它本身，我认为方便一点）
			if(pre[i-1][j]-1>=k)
				continue;
			for(int kk=0;kk<v[i][j][k].size();kk++){
				int xx=v[i][j][k][kk].first,yy=v[i][j][k][kk].second;
				if(type[xx][yy].way==2)
					addcolor(xx,yy,light[1][2]);
			}
		}
/*
***
X**
***
*/
for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
		for(int k=1;k<=high[i][j];k++){
			pre[i][j]=max(pre[i][j-1]-1,high[i][j]);
			if(pre[i][j-1]-1>=k)
				continue;
			for(int kk=0;kk<v[i][j][k].size();kk++){
				int xx=v[i][j][k][kk].first,yy=v[i][j][k][kk].second;
				if(type[xx][yy].way==2)
					addcolor(xx,yy,light[2][1]);
			}
		}

/*
***
**X
***
*/
for(int i=n;i>=1;i--)//注意枚举顺序！
	for(int j=m;j>=1;j--)
		for(int k=1;k<=high[i][j];k++){
			pre[i][j]=max(pre[i][j+1]-1,high[i][j]);
			if(pre[i][j+1]-1>=k)
				continue;
			for(int kk=0;kk<v[i][j][k].size();kk++){
				int xx=v[i][j][k][kk].first,yy=v[i][j][k][kk].second;
				if(type[xx][yy].way==3&&pre[i][j+1]>=k)//挡住了面就也跳过
					continue;
				if(type[xx][yy].way!=1)
					addcolor(xx,yy,light[2][3]);
			}
		}
/*
***
***
*X*
*/
for(int i=n;i>=1;i--)//注意枚举顺序！
	for(int j=m;j>=1;j--)
		for(int k=1;k<=high[i][j];k++){
			pre[i][j]=max(pre[i+1][j]-1,high[i][j]);
			if(pre[i+1][j]-1>=k)
				continue;
			for(int kk=0;kk<v[i][j][k].size();kk++){
				int xx=v[i][j][k][kk].first,yy=v[i][j][k][kk].second;
				if(type[xx][yy].way==1&&pre[i+1][j]>=k)
					continue;
				if(type[xx][yy].way!=3)
					addcolor(xx,yy,light[3][2]);
			}
		}
```
## 四面八方
> 对于40%的数据，1<=n,m<=100,入射光只有一束，且入射方向一定是东南方。

结果东南方是最难的……

直接上图上代码吧，不好解释：（感谢 3D one 在线像素模式）

| 图 | 类型 |
| :-----------: | :-----------: |
| ![挂了](https://asdf123asdf123asdf123.github.io/image-host/立体图图片/over.png) | 1. 完全遮挡。 |
| ![挂了](https://asdf123asdf123asdf123.github.io/image-host/立体图图片/hoverside.png) | 2. 两边挡一些。 |
| ![挂了](https://asdf123asdf123asdf123.github.io/image-host/立体图图片/hoverlside.png) | 3. 挡完前面。 |
| ![挂了](https://asdf123asdf123asdf123.github.io/image-host/立体图图片/overlside.png) | 4. 不仅挡完前面，还挡上面。 |
| ![挂了](https://asdf123asdf123asdf123.github.io/image-host/立体图图片/hoverrside.png) | 5. 挡完右面。 |
| ![挂了](https://asdf123asdf123asdf123.github.io/image-host/立体图图片/overrside.png) | 6. 不仅挡完右面，还挡上面。 |
code：
```cpp
/*
***
***
**X
*/
for(int i=n;i>=1;i--)//注意枚举顺序！
	for(int j=m;j>=1;j--)
		for(int k=1;k<=high[i][j];k++){
			pre[i][j]=max(pre[i+1][j+1]-1,high[i][j]);//注意直接像对角线一样转移
			if(pre[i+1][j+1]-1>=k)//图1
				continue;
			set<pair<int,int>>rule;//加进去的表示被挡的
			if(pre[i+1][j+1]>=k){//图2
				rule.insert(make_pair(1,3));
				rule.insert(make_pair(1,4));
				rule.insert(make_pair(3,2));
				rule.insert(make_pair(3,3));
			}
			if(pre[i+1][j]-1>=k){//图4
				rule.insert(make_pair(2,2));
				rule.insert(make_pair(2,3));
			}
			if(pre[i][j+1]-1>=k){//图6
				rule.insert(make_pair(2,1));
				rule.insert(make_pair(2,4));
			}
			if(pre[i+1][j]>=k){//图3
				rule.insert(make_pair(1,1));
				rule.insert(make_pair(1,2));
				rule.insert(make_pair(1,3));
				rule.insert(make_pair(1,4));
			}
			if(pre[i][j+1]>=k){//图5
				rule.insert(make_pair(3,1));
				rule.insert(make_pair(3,2));
				rule.insert(make_pair(3,3));
				rule.insert(make_pair(3,4));
			}
			for(int kk=0;kk<v[i][j][k].size();kk++){
				int xx=v[i][j][k][kk].first,yy=v[i][j][k][kk].second;
				pair<int,int>pp=make_pair(type[xx][yy].way,type[xx][yy].block);
				if(rule.find(pp)==rule.end())//如果没被挡
					addcolor(xx,yy,light[3][3]);
			}
		}
```
其它的要简单一点：
- 右下（东南方）：上、前、右。
- 左下：上、前。
- 右上：上、右。
- 左上：上。

~~乱猜~~认真思考一下就可以想出其它方向的代码：
```cpp
/*
X**
***
***
*/
for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
		for(int k=1;k<=high[i][j];k++){
			pre[i][j]=max(pre[i-1][j-1]-1,high[i][j]);
			if(pre[i-1][j-1]-1>=k)
				continue;
			set<pair<int,int>>rule;
			rule.insert(make_pair(1,1));
			rule.insert(make_pair(1,2));
			rule.insert(make_pair(1,3));
			rule.insert(make_pair(1,4));
			rule.insert(make_pair(3,1));
			rule.insert(make_pair(3,2));
			rule.insert(make_pair(3,3));
			rule.insert(make_pair(3,4));
			if(pre[i-1][j]-1>=k){
				rule.insert(make_pair(2,1));
				rule.insert(make_pair(2,4));
			}
			if(pre[i][j-1]-1>=k){
				rule.insert(make_pair(2,2));
				rule.insert(make_pair(2,3));
			}
			for(int kk=0;kk<v[i][j][k].size();kk++){
				int xx=v[i][j][k][kk].first,yy=v[i][j][k][kk].second;
				pair<int,int>pp=make_pair(type[xx][yy].way,type[xx][yy].block);
				if(rule.find(pp)==rule.end())
					addcolor(xx,yy,light[1][1]);
			}
		}
/*
**X
***
***
*/
for(int i=1;i<=n;i++)//注意枚举顺序！
	for(int j=m;j>=1;j--)
		for(int k=1;k<=high[i][j];k++){
			pre[i][j]=max(pre[i-1][j+1]-1,high[i][j]);
			if(pre[i-1][j+1]-1>=k)
				continue;
			set<pair<int,int>>rule;
			rule.insert(make_pair(1,1));
			rule.insert(make_pair(1,2));
			rule.insert(make_pair(1,3));
			rule.insert(make_pair(1,4));
			if(pre[i-1][j+1]>=k){
				rule.insert(make_pair(3,3));
				rule.insert(make_pair(3,4));
			}
			if(pre[i-1][j]-1>=k){
				rule.insert(make_pair(2,1));
				rule.insert(make_pair(2,2));
			}
			if(pre[i][j+1]-1>=k){
				rule.insert(make_pair(2,3));
				rule.insert(make_pair(2,4));
			}
			if(pre[i][j+1]>=k){
				rule.insert(make_pair(3,1));
				rule.insert(make_pair(3,2));
				rule.insert(make_pair(3,3));
				rule.insert(make_pair(3,4));
			}
			for(int kk=0;kk<v[i][j][k].size();kk++){
				int xx=v[i][j][k][kk].first,yy=v[i][j][k][kk].second;
				pair<int,int>pp=make_pair(type[xx][yy].way,type[xx][yy].block);
				if(rule.find(pp)==rule.end())
					addcolor(xx,yy,light[1][3]);
			}
		}
/*
***
***
X**
*/
for(int i=n;i>=1;i--)
	for(int j=1;j<=m;j++)
		for(int k=1;k<=high[i][j];k++){
			pre[i][j]=max(pre[i+1][j-1]-1,high[i][j]);
			if(pre[i+1][j-1]-1>=k)
				continue;
			set<pair<int,int>>rule;
			rule.insert(make_pair(3,1));
			rule.insert(make_pair(3,2));
			rule.insert(make_pair(3,3));
			rule.insert(make_pair(3,4));
			if(pre[i+1][j-1]>=k){
				rule.insert(make_pair(1,2));
				rule.insert(make_pair(1,3));
			}
			if(pre[i+1][j]-1>=k){
				rule.insert(make_pair(2,3));
				rule.insert(make_pair(2,4));
			}
			if(pre[i][j-1]-1>=k){
				rule.insert(make_pair(2,1));
				rule.insert(make_pair(2,2));
			}
			if(pre[i+1][j]>=k){
				rule.insert(make_pair(1,1));
				rule.insert(make_pair(1,2));
				rule.insert(make_pair(1,3));
				rule.insert(make_pair(1,4));
			}
			for(int kk=0;kk<v[i][j][k].size();kk++){
				int xx=v[i][j][k][kk].first,yy=v[i][j][k][kk].second;
				pair<int,int>pp=make_pair(type[xx][yy].way,type[xx][yy].block);
				if(rule.find(pp)==rule.end())
					addcolor(xx,yy,light[3][1]);
			}
		}
```
# 完整[代码](https://www.luogu.com.cn/paste/ynr0xtoi)
本来还需优化的，但反正开 O2 也能过，就算了。

有少量注释（做题时打的，不然我自己都搞不清楚）。

---


# [ZJOI2014] 消棋子

## 题目描述

消棋子是一个有趣的游戏。游戏在一个 $r \times c$ 的棋盘上进行。棋盘的每个格子，要么是空，要么是一种颜色的棋子。同一种颜色的棋子恰好有两个。

每一轮，玩家可以选择一个空格子 $(x, y)$，并选择上下左右四个方向中的两个方向，如果在这两个方向上均存在有棋子的格子，而且沿着这两个方向上第一个遇到的棋子颜色相同，那么，我们将这两个棋子拿走，并称之为合法的操作。否则称这个操作不合法，游戏不会处理这个操作。游戏的目的是消除尽量多的棋子。

给出这样一个游戏和一个人的玩法。你需要： 
1. 指出此人能消去多少棋子。 
1. 输出能消去最多棋子数量。

## 说明/提示

对于所有数据，$1\leq r,c,n \leq 10^5$，数据保证答案的操作数 $0\leq k \leq 10^6$。

## 样例 #1

### 输入

```
4 4
4
1 1 1 4
1 2 3 4
1 3 3 2
4 1 2 3
6
2 3 U R
2 1 D R
2 2 L R
2 4 L D
3 1 L R
3 3 L U```

### 输出

```
2 4```

# 题解

## 作者：mulberror (赞：7)

$$\href{http://blog.chhokmah.cn/index.php/archives/45/}{\Large\texttt{My blog}}$$

---
## 题目概括
给定$R\times C$的棋盘，$n$种颜色的棋子，每种棋子只有两颗并且都在棋盘上。  
棋盘的每个格子最多有一颗棋子。  
每次操作确定$(x,y)$和两个方向（保证$(x,y)$为空格子），向两个方向遇到的第一个颜色如果相同就删去。  
请你解决以下两个问题：  
* 给定你$k$个操作，让你求出能够删去颜色的个数。  
* 最多能删去多少颜色，并给出方案。  

**给定数据保证操作合法，选手请保证给出方案亦合法**  


## 思路要点
大致思路为用$set$维护行和列  
第一问直接模拟即可  
第二问，我们考虑一个贪心，因为删去颜色后只能使以后的答案更优，所以贪心策略就是能删就删  
用队列维护当前删去颜色，考虑从删去扩展到其他颜色。  
通过观察样例会发现，在两个格子所在的$2$行和$2$列所遇到的第一个颜色我们能够更新，所以$check$后合法的弹入队列。  
至于输出方案，**洛谷中不需要输出方案**，就在更新的时候一并记录即可。  
对于每一个点删除后更新的次数为$8$次，所以总的复杂度为$\mathcal O(nlog_2n+klog_2n)$  

## 代码
```cpp
// 洛谷中不需要输出方案的标程
// 方案记录在ans中
#include <bits/stdc++.h>

using namespace std;

template <class T>
void read(T& x) {
  x = 0; char ch = 0; int f = 1;
  for (; !isdigit(ch); ch = getchar()) if (ch == '-') f = -1;
  for (; isdigit(ch); ch = getchar()) x = x * 10 + (ch ^ 48);
  x *= f;
}

template <class T>
void write(T x) {
  if (x < 0) putchar('-'), x = -x;
  if (x > 9) write(x / 10);
  putchar(x % 10 + 48);
}

template <class T>
void writeln(T x) {
  write(x), puts("");
}

const int N = 1e5 + 5;
const char dir[] = "UDLR";

set< pair<int, int> > A[N], B[N];
int R, C, n;
int a[N], b[N], c[N], d[N];
bool vis[N];
set< pair<int, int> >::iterator it;
vector< pair< pair<int, int>, pair<char, char> > > ans;

bool move(int x, int y, char d) {
  if (d == 'D') {
    it = B[y].lower_bound(make_pair(x + 1, 0));
    return it != B[y].end(); 
  } else if (d == 'U') {
    it = B[y].lower_bound(make_pair(x, 0));
    if (it == B[y].begin()) return 0;
    else return it--, 1;
  } else if (d == 'L') {
    it = A[x].lower_bound(make_pair(y, 0));
    if (it == A[x].begin()) return 0;
    else return it--, 1;
  } else {
    it = A[x].lower_bound(make_pair(y + 1, 0));
    return it != A[x].end();
  }
  return 0;
}

bool check(int x, int y) {
  set< pair<int, int> >::iterator it = A[x].lower_bound(make_pair(y, 0));
  return (*it).first == y;
}

void del(int j) {
  A[a[j]].erase(make_pair(b[j], j)), B[b[j]].erase(make_pair(a[j], j));
  A[c[j]].erase(make_pair(d[j], j)), B[d[j]].erase(make_pair(c[j], j));
}

void solve1() {
  int m; read(m);
  int ans = 0;
  for (int i = 1; i <= m; i++) {
    int x, y; read(x), read(y);
    if (check(x, y)) continue;
    char dir1[5], dir2[5]; scanf("%s %s", dir1, dir2);
    if (!move(x, y, dir1[0])) continue; 
    set< pair<int, int> >::iterator it1 = it; 
    if (!move(x, y, dir2[0])) continue;
    set< pair<int, int> >::iterator it2 = it;
    if ((*it1).second == (*it2).second) {
      ans++;
      vis[(*it1).second] = 1;
      del((*it1).second);
    }
  }
  write(ans), putchar(' ');
  for (int i = 1; i <= n; i++) 
    if (vis[i]) {
      A[a[i]].insert(make_pair(b[i], i)), A[c[i]].insert(make_pair(d[i], i));
      B[b[i]].insert(make_pair(a[i], i)), B[d[i]].insert(make_pair(c[i], i));
      vis[i] = 0;
    }
}

bool update(int i) { // i is color
  int X1 = a[i], Y1 = b[i], X2 = c[i], Y2 = d[i], cnt = 0;
  if (X1 == X2) {
    if (Y1 > Y2) swap(Y1, Y2);
    if (Y1 + 1 == Y2) return 0;
    move(4, 1, 'R');
    if (move(X1, Y1, 'R')) {
      if ((*it).second == i) {
        del(i);
        ans.push_back(make_pair(make_pair(X1, Y1 + 1), make_pair('L', 'R')));
        return 1;
      }
    }
    return 0;
  }
  if (Y1 == Y2) {
    if (X1 > X2) swap(X1, X2);
    if (X1 + 1 == X2) return 0;
    if (move(X1, Y1, 'D')) 
      if ((*it).second == i) {
        del(i);
        ans.push_back(make_pair(make_pair(X1 + 1, Y1), make_pair('U', 'D')));
        return 1;
      }
    return 0;
  }
  char opt[6];
  if (!check(X2, Y1)) {
    for (int j = 0; j < 4; j++) 
      if (move(X2, Y1, dir[j])) 
        if ((*it).second == i) opt[++cnt] = dir[j];
    if (cnt >= 2) {
      ans.push_back(make_pair(make_pair(X2, Y1), make_pair(opt[1], opt[2])));
      del(i);
      return 1;
    }
  }
  cnt = 0; 
  if (!check(X1, Y2)) {
    for (int j = 0; j < 4; j++) 
      if (move(X1, Y2, dir[j])) 
        if ((*it).second == i) opt[++cnt] = dir[j];
    if (cnt >= 2) {
      ans.push_back(make_pair(make_pair(X1, Y2), make_pair(opt[1], opt[2])));
      del(i);
      return 1;
    }
  }
  return 0;
}

void solve2() {
  ans.clear();
  queue<int> q; 
  for (int i = 1; i <= n; i++) 
    if (update(i)) q.push(i), vis[i] = 1;
  while (!q.empty()) {
    int k = q.front();
    q.pop();
    int color[10];
    int t = 0;
    for (int i = 0; i < 4; i++) {
      if (move(a[k], b[k], dir[i])) 
        color[++t] = (*it).second;
      if (move(c[k], d[k], dir[i])) 
        color[++t] = (*it).second;
    }
    for (int i = 1; i <= t; i++) {
      if (!vis[color[i]] && update(color[i])) {
        q.push(color[i]);
        vis[color[i]] = 1;
        del(color[i]);
      }
    }
  }
  writeln(ans.size());
}

int main() {
#ifdef chhokmah
  freopen("eliminate1.in", "r", stdin);
#endif
  read(R), read(C), read(n);
  for (int i = 1; i <= n; i++) {
    read(a[i]), read(b[i]), read(c[i]), read(d[i]);
    A[a[i]].insert(make_pair(b[i], i)), A[c[i]].insert(make_pair(d[i], i));
    B[b[i]].insert(make_pair(a[i], i)), B[d[i]].insert(make_pair(c[i], i));
    vis[i] = 0;
  }
  solve1();
  solve2();
  return 0; 
}
```

---

## 作者：hellolin (赞：2)

# P3341 [ZJOI2014] 消棋子 题解

建议前往 [note.hellolin.cf](https://note.hellolin.cf/solutions/p3341/) 获得更好的阅读体验！

模拟赛考了这道小模拟，挺有意思的，来写一发题解。~~（不过模拟赛写的太屎了~~

开两个 `set` 维护行列。对于第一问直接模拟，第二问直接贪心即可。下面是代码讲解。

## 前置

为了方便，封装坐标和操作两个类。声明一些必要变量和读入函数。

``` cpp
constexpr int N = 1e5 + 5;
int row, column, n, m, answer;
struct coordinate {
    pair<int, int> a, b, c, d;
    // 表示一种颜色中，两个棋子的位置：
    // (a.first, b.first) 和 (c.first, d.first)。
    // .second 存储颜色编号。
};
struct operation {
    pair<int, int> x;
    pair<char, char> d;
};
coordinate coor[N];
operation cont[N];
vector<operation> result;

void init() {
    read(row, column, n);
    for (int i = 1; i <= n; ++i) {
        auto &[a, b, c, d] = coor[i];
        read(a.first, b.first, c.first, d.first);
        a.second = b.second = c.second = d.second = i;
    }
    read(m);
    for (int i = 1; i <= m; ++i) {
        auto &[x, d] = cont[i];
        read(x.first, x.second, d.first, d.second);
    }
}
```

初始化函数。策略是用两个 `set` 维护行列。

后面会使用 `lower_bound` 和 `upper_bound`。为了方便，我们在 `set` 中顺便处理边界，将边界的颜色标记为 $0$。

``` cpp
set<pair<int, int>> row_set[N], column_set[N];

void reset() {
    for (int i = 0; i <= row; ++i) {
        row_set[i].clear();
        row_set[i].insert({0, 0});
        row_set[i].insert({N, 0});
    }
    for (int i = 0; i <= column; ++i) {
        column_set[i].clear();
        column_set[i].insert({0, 0});
        column_set[i].insert({N, 0});
    }
    for (int i = 1; i <= n; ++i) {
        auto &[a, b, c, d] = coor[i];
        row_set[a.first].insert(b);
        row_set[c.first].insert(d);
        column_set[b.first].insert(a);
        column_set[d.first].insert(c);
    }
}
```

`get` 工具函数，获取坐标 $(x, y)$ 向方向 $d$ 遇到的第一个棋子坐标。

``` cpp
pair<int, int> get(char d, int x, int y) {
    switch (d) {
    case 'U':
        return *--column_set[y].lower_bound({x, 0});
    case 'D':
        return *column_set[y].upper_bound({x, N});
    case 'L':
        return *--row_set[x].lower_bound({y, 0});
    case 'R':
        return *row_set[x].upper_bound({y, N});
    };
    return {-1, -1};
}
```

`erase` 工具函数，删除坐标 $(x, y)$ 向方向 $d$ 遇到的第一个棋子坐标。

``` cpp
void erase(char d, int x, int y) {
    auto r = get(d, x, y);
    if (d == 'U' || d == 'D') {
        column_set[y].erase(r);
        row_set[r.first].erase({y, r.second});
    } else {
        row_set[x].erase(r);
        column_set[r.first].erase({x, r.second});
    }
}
```

`insert` 工具函数，注意这个函数不是插入棋子的，而是插入 **移除 $p$ 颜色的棋子** 这一操作的。

这里会用到一个队列，每当有棋子消掉我们就把他的颜色入队，后面统计答案要用到。

``` cpp
// 所有方向组合（不考虑顺序）
vector<pair<char, char>> directions{{'U', 'D'}, {'L', 'R'}, {'U', 'L'}, {'U', 'R'}, {'D', 'L'}, {'D', 'R'}};
queue<int> q;
bool exi[N];

void insert(int p) {
    auto add = [&](int p, int x, int y) {
        if (row_set[x].lower_bound({y, 0})->first == y) return;

        pair<int, int> fx, fy;
        for (auto &[a, b] : directions) {
            fx = get(a, x, y);
            fy = get(b, x, y);
            if (fx.second && fx.second == fy.second && fy.second == p && !exi[p]) {
                exi[p] = true;
                q.push(p);
                erase(a, x, y);
                erase(b, x, y);
                result.push_back({{x, y}, {a, b}});
                return;
            }
        }
    };

    auto &[a, b, c, d] = coor[p];
    if (a.first == c.first) {
        add(p, a.first, (b.first + d.first) / 2);
        return;
    }
    if (b.first == d.first) {
        add(p, (a.first + c.first) / 2, b.first);
        return;
    }
    add(p, a.first, d.first);
    add(p, c.first, b.first);
}
```

## 询问 1

利用前面的工具函数直接模拟即可。

``` cpp
void solve_1() {
    pair<int, int> fx = {0, 0}, fy = {0, 0};
    for (int i = 1; i <= m; ++i) {
        auto &[x, d] = cont[i];
        if (row_set[x.first].lower_bound({x.second, 0})->first == x.second) continue;
        fx = get(d.first, x.first, x.second);
        fy = get(d.second, x.first, x.second);
        if (fx.second && fx.second == fy.second) {
            ++answer;
            erase(d.first, x.first, x.second);
            erase(d.second, x.first, x.second);
        }
    }
    // writeln(answer);
    // 洛谷上的输出格式略有不同
    write(answer, ' ');
}
```

## 询问 2

利用前面 `insert` 工具函数，直接删除每个颜色。

但是，这样操作可能会影响到行列中其他棋子。还记得之前的队列吗？现在派上用场了。

``` cpp
vector<char> single_directions{'U', 'D', 'L', 'R'};

void solve_2() {
    auto chk = [&](int x, int y) {
        pair<int, int> f;
        for (auto &d : single_directions) {
            f = get(d, x, y);
            if (f.second)
                ins(f.second);
        }
    };
    result.clear();
    for (int i = 1; i <= n; ++i) { // 先删除每种颜色
        insert(i);
    }
    while (q.size()) { // 再通过队列检查被影响的棋子
        int i = q.front();
        q.pop();
        auto &[a, b, c, d] = coor[i];
        chk(a.first, b.first);
        chk(c.first, d.first);
    }
    writeln(result.size());
    // 洛谷上的输出格式略有不同
    // for (auto &[x, d] : result) {
    //     writeln(x.first, ' ', x.second, ' ', d.first, ' ', d.second);
    // }
}
```

## 完整代码

这里只展示了核心代码。

注意这题洛谷不需要输出方案，而在 Loj 上需要。

``` cpp
namespace chess {
constexpr int N = 1e5 + 5;
int row, column, n, m, answer;
queue<int> q;
struct coordinate {
    pair<int, int> a, b, c, d;
} coor[N];
struct operation {
    pair<int, int> x;
    pair<char, char> d;
} cont[N];
vector<operation> result;
set<pair<int, int>> row_set[N], column_set[N];
bool exi[N]; 
// UD, LR, UL, UR, DL, DR
vector<pair<char, char>> directions{{'U', 'D'}, {'L', 'R'}, {'U', 'L'}, {'U', 'R'}, {'D', 'L'}, {'D', 'R'}};
vector<char> single_directions{'U', 'D', 'L', 'R'};

void init() {
    read(row, column, n);
    for (int i = 1; i <= n; ++i) {
        auto &[a, b, c, d] = coor[i];
        read(a.first, b.first, c.first, d.first);
        a.second = b.second = c.second = d.second = i;
    }
    read(m);
    for (int i = 1; i <= m; ++i) {
        auto &[x, d] = cont[i];
        read(x.first, x.second, d.first, d.second);
    }
}
void reset() {
    for (int i = 0; i <= row; ++i) {
        row_set[i].clear();
        row_set[i].insert({0, 0});
        row_set[i].insert({N, 0});
    }
    for (int i = 0; i <= column; ++i) {
        column_set[i].clear();
        column_set[i].insert({0, 0});
        column_set[i].insert({N, 0});
    }
    for (int i = 1; i <= n; ++i) {
        auto &[a, b, c, d] = coor[i];
        row_set[a.first].insert(b);
        row_set[c.first].insert(d);
        column_set[b.first].insert(a);
        column_set[d.first].insert(c);
    }
}
pair<int, int> get(char d, int x, int y) {
    switch (d) {
    case 'U':
        return *--column_set[y].lower_bound({x, 0});
    case 'D':
        return *column_set[y].upper_bound({x, N});
    case 'L':
        return *--row_set[x].lower_bound({y, 0});
    case 'R':
        return *row_set[x].upper_bound({y, N});
    };
    return {-1, -1};
}
void erase(char d, int x, int y) {
    auto r = get(d, x, y);
    if (d == 'U' || d == 'D') {
        column_set[y].erase(r);
        row_set[r.first].erase({y, r.second});
    } else {
        row_set[x].erase(r);
        column_set[r.first].erase({x, r.second});
    }
}
void insert(int p) {
    auto add = [&](int p, int x, int y) {
        if (row_set[x].lower_bound({y, 0})->first == y) return;

        pair<int, int> fx, fy;
        for (auto &[a, b] : directions) {
            fx = get(a, x, y);
            fy = get(b, x, y);
            if (fx.second && fx.second == fy.second && fy.second == p && !exi[p]) {
                exi[p] = true;
                q.push(p);
                erase(a, x, y);
                erase(b, x, y);
                result.push_back({{x, y}, {a, b}});
                return;
            }
        }
    };

    auto &[a, b, c, d] = coor[p];
    if (a.first == c.first) {
        add(p, a.first, (b.first + d.first) / 2);
        return;
    }
    if (b.first == d.first) {
        add(p, (a.first + c.first) / 2, b.first);
        return;
    }
    add(p, a.first, d.first);
    add(p, c.first, b.first);
}

void solve_1() {
    pair<int, int> fx = {0, 0}, fy = {0, 0};
    for (int i = 1; i <= m; ++i) {
        auto &[x, d] = cont[i];
        if (row_set[x.first].lower_bound({x.second, 0})->first == x.second) continue;
        fx = get(d.first, x.first, x.second);
        fy = get(d.second, x.first, x.second);
        if (fx.second && fx.second == fy.second) {
            ++answer;
            erase(d.first, x.first, x.second);
            erase(d.second, x.first, x.second);
        }
    }
    // writeln(answer);
    write(answer, ' ');
}
void solve_2() {
    auto chk = [&](int x, int y) {
        pair<int, int> f;
        for (auto &d : single_directions) {
            f = get(d, x, y);
            if (f.second)
                insert(f.second);
        }
    };
    result.clear();
    for (int i = 1; i <= n; ++i) {
        insert(i);
    }
    while (q.size()) {
        int i = q.front();
        q.pop();
        auto &[a, b, c, d] = coor[i];
        chk(a.first, b.first);
        chk(c.first, d.first);
    }
    writeln(result.size());
    // for (auto &[x, d] : result) {
    //     writeln(x.first, ' ', x.second, ' ', d.first, ' ', d.second);
    // }
}
void main() {
    init();
    reset();
    solve_1();
    reset();
    solve_2();
}
} // namespace chess
```


---

## 作者：不知名用户 (赞：1)

### 题意

$r\times c$ 的棋盘上有 $n$ 种不同颜色的棋子，每种棋子两个。每次操作可以选择一个无棋子的点和两个方向，如果往两个方向走都碰到棋子且碰到的第一颗棋子相同，那么就将两个棋子消去。

给出某人的操作序列，求这个人消去了多少棋子。还需要求最多消去多少棋子。（输出问颜色数要除以 2）

### 做法

考虑第一问怎么模拟。每行每列用 `set` 维护对应棋子的坐标和编号。查询的时候做个 `lower_bound` 之类的，此处不赘述。为了避免选到非空节点，可以在查询坐标和棋子坐标相同时返回 0。

对于第二问，先考虑这样一个问题：判断一个棋子是否能被消去。分两种情况：

1. 在同一行或者同一列。用 `set` 检查两个点之间是否有点。具体地，设不同坐标为 $x1,x2(x1<x2)$，只需判断 `.upper_bound(x1)` 是否对应 $x2$。还要判 $x1+1<x2$ **否则相邻的无法消除**。

2. 不在同一行统一列，设坐标为 $ax,ay,bx,by$，检查 $(ax,by),(bx,ay)$ 相应方向是否有障碍即可。

每次删去两个棋子后一定会导致更多的棋子可以删去，但是只可能是两个棋子四个方向碰到的第一个棋子。

时间复杂度 $O((n+m)\log n)$ 瓶颈在 `set`，可以用并查集实现找左边/右边第一个，时间复杂度 $O((n+m)\alpha(n))$。

### 代码

细节有亿点多。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int out[N], xa[N], ya[N], xb[N], yb[N];
struct dsu
{
	set<pair<int,int> >S;
	int getl(int x)
	{
		auto it = S.upper_bound({x,1000000000});
		if(it==S.begin()) return 0;
		it--;
		if(it->first==x) return 0;
		return it -> second;
	}
	int getr(int x)
	{
		auto it = S.lower_bound({x,0});
		if(it==S.end()) return 0;
		if(it->first==x) return 0;
		return it -> second;
	}
	void del(int x)
	{
		auto it = S.lower_bound({x,0});
		S.erase(it);
	}
}x[N],y[N];

struct node{int x,y,id;}p[N*2];

int get(int X, int Y, char c)
{
	if(c=='U') return y[Y].getl(X);
	if(c=='D') return y[Y].getr(X);
	if(c=='L') return x[X].getl(Y);
	if(c=='R') return x[X].getr(Y);
	return 0;
}

void del(int X, int Y){y[Y].del(X),x[X].del(Y);}

queue<int>q;

bool check(int col)
{
	if(!col||out[col]) return 0;
	if(xa[col]==xb[col]&&x[xa[col]].getr(min(ya[col],yb[col])+1)==col) return 1;
	if(ya[col]==yb[col]&&y[ya[col]].getr(min(xa[col],xb[col])+1)==col) return 1;
	int ax = xa[col], ay = ya[col], bx = xb[col], by = yb[col];
	if(ax>bx) swap(ax,bx), swap(ay,by);
	if(ay<by)
	{
		if(get(ax,by,'L')==col&&get(ax,by,'D')==col) return 1;
		if(get(bx,ay,'U')==col&&get(bx,ay,'R')==col) return 1;
	}
	else
	{
		if(get(ax,by,'D')==col&&get(ax,by,'R')==col) return 1;
		if(get(bx,ay,'L')==col&&get(bx,ay,'U')==col) return 1;
	}
	return 0;
}

int main()
{
	int r, c, n, m, i, ans = 0;
	scanf("%d%d%d", &r, &c, &n);
	for(i=1;i<=n;i++) scanf("%d%d%d%d", &p[i*2-1].x, &p[i*2-1].y, &p[i*2].x, &p[i*2].y), p[i*2-1].id = p[i*2].id = i;
	for(i=1;i<=n;i++) xa[i] = p[i*2-1].x, ya[i] = p[i*2-1].y, xb[i] = p[i*2].x, yb[i] = p[i*2].y;
	for(i=1;i<=n*2;i++) x[p[i].x].S.insert({p[i].y,p[i].id}), y[p[i].y].S.insert({p[i].x,p[i].id});
	scanf("%d", &m);
	while(m--)
	{
		int x, y;
		char op1[10], op2[10];
		scanf("%d%d%s%s", &x, &y, op1, op2);
		if(*op1==*op2) continue;
		int id1, id2;
		id1 = get(x,y,*op1), id2 = get(x,y,*op2);
		if(id1&&id1==id2) out[id1] = 1, del(xa[id1],ya[id1]), del(xb[id1],yb[id1]), ans++;
	}
	printf("%d ", ans);
	for(i=1;i<=n;i++) if(!out[i]&&check(i)) out[i] = 1, q.push(i);
	while(!q.empty())
	{
		int d = q.front();q.pop();
		ans++;
		vector<int>x;
		del(xa[d],ya[d]), del(xb[d],yb[d]);
		x.clear();
		x.emplace_back(get(xa[d],ya[d],'U'));
		x.emplace_back(get(xa[d],ya[d],'D'));
		x.emplace_back(get(xa[d],ya[d],'L'));
		x.emplace_back(get(xa[d],ya[d],'R'));
		x.emplace_back(get(xb[d],yb[d],'U'));
		x.emplace_back(get(xb[d],yb[d],'D'));
		x.emplace_back(get(xb[d],yb[d],'L'));
		x.emplace_back(get(xb[d],yb[d],'R'));
		for(auto i:x) if(i&&!out[i]&&check(i)) out[i] = 1, q.push(i);
	}
	printf("%d", ans);
	return 0;
}
```

---

## 作者：xs_siqi (赞：1)

7k 邀您来爽（放到 loj 格式化一下变 11k 了）。猪国杀也才 6k 啊。

可能是因为我的实现比较垃圾的原因吧。我看到很多实现都是 4k 左右的。

首先对于第一问，我们考虑使用两个 `multiset` 维护坐标和颜色两维，对于一次询问，我们考虑直接在上面二分然后找到它对应方向上的第一个点，我们就能判断它们的颜色是否相同了。

难点主要在第二问。

我们称能消除两个相同颜色的坐标为关键点。

```
x o o
o o o
o o x
```
`x` 表示棋子，其他表示空位。此时的关键点就是 $(1,3)$ 与 $(3,1)$。

这个时候你可能认为关键点必然存在“一对”。但是有这样的情况：

```
x o o o x
```

这个时候，中间的一段区间都是关键点。

我们考虑把关键点分成三类，第一类是形如“一对”出现的，第二类是形如在同一行的区间的，第三类是形如在同一列的区间的。

对于第二类和第三类的维护其实很简单，怎么维护都可以。主要是考虑第一类要怎么维护。

我们考虑一个拓扑的拓展顺序。我们先拿关键点以及关键点到颜色相同的点的路径没有其他棋子的点放到队列里，然后按照拓扑排序的顺序拓展即可。

考虑我们是如何拓扑的。我们考虑把要删除的点放到队列里，然后考虑删除一个点会产生什么影响。

删除一个点，会使得它左边的关键点往右拓展，右边往左，上面往下，下面往上。这种结构我们显然可以想到，我们对于从左向右，从上到下分别维护一个链表，然后每次只要把有影响的点重新算一遍是否能被消除即可。

洛谷上是不用记方案的，但是记方案也很简单，在删点的时候顺便记一下就好了。

```cpp
#include<set>
#include<map>
#include<vector>
#include<cstdio>
#include<iostream>
#include<algorithm>
#define pb push_back
using namespace std;
const int maxn=5e5+5;
int r,c,n,m,cnt;
char s1[5],s2[5];
struct sortx{
	int x,y,col;
	friend bool operator < (sortx x,sortx y){
		return x.x<y.x;
	}
	sortx(){}
	sortx(int _x,int _y,int _col):
		x(_x),y(_y),col(_col){}
};
struct sorty{
	int x,y,col;
	friend bool operator < (sorty x,sorty y){
		return x.y<y.y;
	}
	sorty(){}
	sorty(int _x,int _y,int _col):
		x(_x),y(_y),col(_col){}
};
struct node{
	int x,y,col;
	node(){}
	node(int _x,int _y,int _col):
		x(_x),y(_y),col(_col){}
};

struct wi{
	int x,y;
	friend bool operator < (wi x,wi y){
		return x.x==y.x?x.y<y.y:x.x<y.x;
	}
	wi(){}
	wi(int _x,int _y):
		x(_x),y(_y){};
};
struct upinfo{
	int type,myid;
	int H,S;
	int l,r,id;
	int x,y,uidH,uidS;
}a[maxn*2];
int lstH[maxn],nxtH[maxn],lstS[maxn],nxtS[maxn],tot=1,TS[maxn],TH[maxn],qq[maxn*5],ans[maxn][2],q[maxn*5],cmt;
char ree[maxn][2];
map<wi,int> G,r1,r2;
map<int,wi> P;
bool vis[maxn*2],viss[maxn*2];
vector<sortx>a1[maxn];
vector<sorty>a2[maxn];

multiset<sortx>sx[maxn];
multiset<sorty>sy[maxn];
node Lfind(int x,int y){
	sorty k(x,y,0);
	auto r=sy[x].lower_bound(k);
	if(r->y>y)r--;
	node p;
	if(r->y==y)p=(node){0,0,0};
	else p=(node){r->x,r->y,r->col};
	return p;
} 
node Rfind(int x,int y){
	sorty k(x,y,0);
	auto r=sy[x].lower_bound(k);
	if(r->y<y)r--;
	node p;
	if(r->y==y)p=(node){0,0,0};
	else p=(node){r->x,r->y,r->col};
	return p;
} 
node Ufind(int x,int y){
	sortx k(x,y,0);
	auto r=sx[y].lower_bound(k);
	if(r->x>x)r--;
	node p;
	if(r->x==x)p=(node){0,0,0};
	else p=(node){r->x,r->y,r->col};
	return p;
} 
node Dfind(int x,int y){
	sortx k(x,y,0);
	auto r=sx[y].lower_bound(k);
	if(r->x<x)r--;
	node p;
	if(r->x==x)p=(node){0,0,0};
	else p=(node){r->x,r->y,r->col};
	return p;
}
void del(node x){
	sortx x1(x.x,x.y,x.col);
	sorty x2(x.x,x.y,x.col);
	sx[x.y].erase(x1);sy[x.x].erase(x2);
}
int h=1,t=0;
void add(int tt){
	for(int p=1;p<=tt;p++){
		int i=qq[p];
		if(a[i].type==1){
			if((a[i].H>a[lstH[i]].y&&a[i].H<a[i].y)||((a[i].H<a[nxtH[i]].y||!nxtH[i])&&a[i].y<a[i].H))TH[a[i].uidH]=1;
			if((a[i].S>a[lstS[i]].x&&a[i].S<a[i].x)||((a[i].S<a[nxtS[i]].x||!nxtS[i])&&a[i].x<a[i].S))TS[a[i].uidS]=1;
			if(((TH[a[i].uidH]&&TS[a[i].uidH])||(TH[a[i].uidS]&&TS[a[i].uidS]))&&!viss[a[i].uidH]&&!viss[a[i].uidS]){
				viss[a[i].uidH]=viss[a[i].uidS]=1;
				if((TH[a[i].uidH]&&TS[a[i].uidH])){
					ans[++cmt][0]=P[a[i].uidH].x;
					ans[cmt][1]=P[a[i].uidH].y;
					ree[cmt][0]=P[a[i].uidH].y<a[i].y?'R':'L';
					ree[cmt][1]=P[a[i].uidH].x<a[i^1].x?'D':'U';
				}
				else{
					ans[++cmt][0]=P[a[i].uidS].x;
					ans[cmt][1]=P[a[i].uidS].y;
					ree[cmt][0]=P[a[i].uidS].x<a[i].x?'D':'U';
					ree[cmt][1]=P[a[i].uidS].y<a[i^1].y?'R':'L';				
				}
				if(!vis[i])q[++t]=i,vis[i]=1;
				if(!vis[i^1])q[++t]=i^1,vis[i^1]=1;
			}
		}
		if(a[i].type==2){
			if(a[i].l>a[i].r||a[i].l>r)continue;
			if(a[nxtS[i]].x>a[i].r&&a[lstS[i]].x<a[i].l&&!r1[(wi){a[i].l,a[i].y}]){
				r1[(wi){a[i].l,a[i].y}]=1;
				ans[++cmt][0]=a[i].l;
				ans[cmt][1]=a[i].y;
				ree[cmt][0]='U',ree[cmt][1]='D';
				if(!vis[i])q[++t]=i,vis[i]=1;
				if(!vis[i^1])q[++t]=i^1,vis[i^1]=1;
				
			}
		}
		if(a[i].type==3){
			if(a[i].l>a[i].r||a[i].l>c)continue;
			if(a[nxtH[i]].y>a[i].r&&a[lstH[i]].y<a[i].l&&!r2[(wi){a[i].x,a[i].l}]){
				r2[(wi){a[i].x,a[i].l}]=1;
				ans[++cmt][0]=a[i].x;
				ans[cmt][1]=a[i].l;
				ree[cmt][0]='L',ree[cmt][1]='R';
				if(!vis[i])q[++t]=i,vis[i]=1;
				if(!vis[i^1])q[++t]=i^1,vis[i^1]=1;
			}			
		}
	}
}
int main(){
//	freopen("eliminate.in","r",stdin);
//	freopen("eliminate.out","w",stdout);
	scanf("%d%d%d",&r,&c,&n);
	sortx infx1(-1000000000,-1000000000,0),infx2(1000000000,1000000000,0);
	sorty infy1(-1000000000,-1000000000,0),infy2(1000000000,1000000000,0);
	for(int i=1;i<=r;i++)sy[i].insert(infy1),sy[i].insert(infy2);
	for(int i=1;i<=c;i++)sx[i].insert(infx1),sx[i].insert(infx2);
	for(int px1,px2,py1,py2,i=1;i<=n;i++){
		scanf("%d%d%d%d",&px1,&py1,&px2,&py2);
		wi p1(px1,py1),p2(px2,py2);
		G[p1]=2*i,G[p2]=2*i+1;
		a[2*i].x=px1,a[2*i].y=py1;
		a[2*i+1].x=px2,a[2*i+1].y=py2;
		if(px1==px2){
			a[2*i].type=3,a[2*i].l=min(py1,py2)+1,a[2*i].r=max(py1,py2)-1;
			a[2*i+1].type=3,a[2*i+1].l=min(py1,py2)+1,a[2*i+1].r=max(py1,py2)-1;
		}
		else if(py1==py2){
			a[2*i].type=2,a[2*i].l=min(px1,px2)+1,a[2*i].r=max(px1,px2)-1;
			a[2*i+1].type=2,a[2*i+1].l=min(px1,px2)+1,a[2*i+1].r=max(px1,px2)-1;
		}
		else{
			wi nx1(px1,py2),nx2(px2,py1);
			++tot;P[tot]=nx1;
			a[2*i].type=1,a[2*i].H=py2,a[2*i].S=px2,a[2*i].uidH=tot,a[2*i].uidS=tot+1;
			++tot;P[tot]=nx2;
			a[2*i+1].type=1,a[2*i+1].H=py1,a[2*i+1].S=px1,a[2*i+1].uidH=tot,a[2*i+1].uidS=tot-1;			
		}
		sortx nx1(px1,py1,i);
		sortx nx2(px2,py2,i);
		sorty nx3(px1,py1,i);
		sorty nx4(px2,py2,i);
		a1[py1].pb(nx1),a1[py2].pb(nx2),a2[px1].pb(nx3),a2[px2].pb(nx4);
		sx[py1].insert(nx1),sx[py2].insert(nx2);
		sy[px1].insert(nx3),sy[px2].insert(nx4);
	}
	for(int i=1;i<=r;i++){
		sort(a2[i].begin(),a2[i].end());
		if(a2[i].empty())continue;
		for(int j=0;j<a2[i].size()-1;j++){
			wi nx1(a2[i][j].x,a2[i][j].y),nx2(a2[i][j+1].x,a2[i][j+1].y);
			nxtH[G[nx1]]=G[nx2];
		}
		for(int j=1;j<a2[i].size();j++){
			wi nx1(a2[i][j].x,a2[i][j].y),nx2(a2[i][j-1].x,a2[i][j-1].y);
			lstH[G[nx1]]=G[nx2];
		}			
	}
	for(int i=1;i<=c;i++){
		sort(a1[i].begin(),a1[i].end());
		if(a1[i].empty())continue;
		for(int j=0;j<a1[i].size()-1;j++){
			wi nx1(a1[i][j].x,a1[i][j].y),nx2(a1[i][j+1].x,a1[i][j+1].y);
			nxtS[G[nx1]]=G[nx2];
		}
		for(int j=1;j<a1[i].size();j++){
			wi nx1(a1[i][j].x,a1[i][j].y),nx2(a1[i][j-1].x,a1[i][j-1].y);
			lstS[G[nx1]]=G[nx2];
		}			
	}
	scanf("%d",&m);
	while(m--){
		int x,y;
		scanf("%d%d",&x,&y);
		scanf("%s%s",s1,s2);
		node tx1,tx2;
		if(s1[0]=='L')tx1=Lfind(x,y);
		if(s1[0]=='R')tx1=Rfind(x,y);
		if(s1[0]=='U')tx1=Ufind(x,y);
		if(s1[0]=='D')tx1=Dfind(x,y);
		if(s2[0]=='L')tx2=Lfind(x,y);
		if(s2[0]=='R')tx2=Rfind(x,y);
		if(s2[0]=='U')tx2=Ufind(x,y);
		if(s2[0]=='D')tx2=Dfind(x,y);
		if(tx1.col==tx2.col&&tx1.col)del(tx1),del(tx2),cnt++;
	}
	printf("%d ",cnt);
	int t1=0;
	for(int i=2;i<=2*n+1;i++)qq[++t1]=i;
	add(t1);
	while(h<=t){
		int u=q[h++];
		t1=0;
		nxtH[lstH[u]]=nxtH[u];
		nxtS[lstS[u]]=nxtS[u];
		lstH[nxtH[u]]=lstH[u];
		lstS[nxtS[u]]=lstS[u];
		if(nxtH[u])qq[++t1]=nxtH[u];
		if(nxtS[u])qq[++t1]=nxtS[u];
		if(lstH[u])qq[++t1]=lstH[u];
		if(lstS[u])qq[++t1]=lstS[u];
		add(t1);
	}
	printf("%d\n",cmt);
	for(int i=1;i<=cmt;i++)
//		printf("%d %d %c %c\n",ans[i][0],ans[i][1],ree[i][0],ree[i][1]);	
	return 0;
}
```


---

## 作者：liaiyang (赞：1)

第一问直接模拟。

第二问我们处理出来能被删掉的颜色，再用能被删掉的颜色拓展下去，队列维护。

我们用 set 维护每一行和每一列。

认为 $r,c,n$ 同阶，时间复杂度 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
// #pragma GCC optimize(1)
// #pragma GCC optimize(2)
// #pragma GCC optimize(3,"Ofast")
#define int long long
#define y0 Y0
#define y1 Y1
#define debug(...) fprintf(stderr,__VA_ARGS__)
#define min(a,b) (a<b?a:b) 
#define max(a,b) (a>b?a:b)
#define P pair<int,int>
#define x first
#define y second
#define modd(x) (((x)%mod+mod)%mod) 
#define rd read()
#define lowbit(x) ((x)&(-x))
#define abs(x) ((x)<0?-(x):(x))
#define submod(x,y,mod) (((x-=y)<0)&&(x+=mod))
#define addmod(x,y,mod) (((x+=y)>=mod)&&(x-=mod))
mt19937 rnd(time(0));
// char buf[1<<23],*p1=buf,*p2=buf,obuf[1<<23],*O=obuf;
// #define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
inline int read(int u=0, char c=getchar(), bool f=false){
    for(;!isdigit(c);c=getchar()) f|=c=='-';
    for(;isdigit(c);c=getchar()) u=(u<<1)+(u<<3)+(c^'0');
    return f?-u:u;
}
inline void wt(int x){
    if(x<0) x=-x,putchar('-');
    if(x>9) wt(x/10);
    putchar((x%10)^'0');
}
inline void wt(int x,char k){wt(x),putchar(k);}
// const int inf=~0U>>1,linf=~0ULL>>1;
const int mod=998244353,g=3,gi=332748118;
const int N=1e5+10;
int r,c,n,a_[N],b_[N],c_[N],d_[N],ans1;
bool vis[N];
set<P>xs[N],ys[N];
set<P>::iterator it;
string s="LRUD";
vector<pair<pair<int,int>,pair<char,char> > >ans;
void del(P pos,int col){
    xs[pos.x].erase({pos.y,col}),ys[pos.y].erase({pos.x,col});
}
void insert(P pos,int col){
    xs[pos.x].insert({pos.y,col}),ys[pos.y].insert({pos.x,col});
}
void clear(){
    for(int i=1;i<=r;i++) xs[i].clear();
    for(int i=1;i<=c;i++) ys[i].clear();
}
void input(){
    r=rd,c=rd,n=rd;
    for(int i=1;i<=n;i++) a_[i]=rd,b_[i]=rd,c_[i]=rd,d_[i]=rd;
}
void reset(){
    clear();
    for(int i=1;i<=n;i++){
        insert({a_[i],b_[i]},i);
        insert({c_[i],d_[i]},i);
    }
}
bool check_1(int x,int y){
    it=xs[x].lower_bound({y,0});
    if(it==xs[x].end()) return 0;
    return (*it).x==y;
}
P getpos(int x,int y,char op){
    if(check_1(x,y)) return {0,0};
    if(op=='R'){
        it=xs[x].lower_bound({y,0});
        if(it==xs[x].end()) return {0,0};
        return {x,(*it).x};
    }
    if(op=='L'){
        it=xs[x].lower_bound({y,0});
        if(it==xs[x].begin()) return {0,0};
        return {x,(*--it).x};
    }
    if(op=='D'){
        it=ys[y].lower_bound({x,0});
        if(it==ys[y].end()) return {0,0};
        return {(*it).x,y};
    }
    if(op=='U'){
        it=ys[y].lower_bound({x,0});
        if(it==ys[y].begin()) return {0,0};
        return {(*--it).x,y};
    }
    return {0,0};
}
void move(int x,int y,char op1,char op2){
    P lpos=getpos(x,y,op1);
    if(!lpos.x) return ;
    int col1=(*it).y;
    P rpos=getpos(x,y,op2);
    if(!rpos.x) return ;
    int col2=(*it).y;
    if(col1!=col2) return ;
    ans1++;
    del(lpos,col1),del(rpos,col1);
}
void solve1(){
    int m=rd;
    while(m--){
        int x,y;
        char op1,op2;
        cin>>x>>y>>op1>>op2;
        move(x,y,op1,op2);
    }
    wt(ans1,'\n');
}
bool check(int col){
    int x1=a_[col],y1=b_[col],x2=c_[col],y2=d_[col];
    if(x1==x2){
        if(y1>y2) swap(y1,y2);
        if(y1+1==y2) return 0;
        P pos=getpos(x1,y1+1,'R');
        if(pos.x&&(*it).y==col){
            del({x1,y1},col),del({x2,y2},col);
            ans.push_back({{x1,y1+1},{'L','R'}});
            return 1;
        }
        return 0;
    }
    if(y1==y2){
        if(x1>x2) swap(x1,x2);
        if(x1+1==x2) return 0;
        P pos=getpos(x1+1,y1,'D');
        if(pos.x&&(*it).y==col){
            del({x1,y1},col),del({x2,y2},col);
            ans.push_back({{x1+1,y1},{'U','D'}});
            return 1;
        }
        return 0;
    }
    char opt[10];
    int cnt=0;
    if(!check_1(x2,y1)){
        for(char op:s){
            P pos=getpos(x2,y1,op);
            if(pos.x&&(*it).y==col) opt[++cnt]=op;
        }
        if(cnt==2){
            del({x1,y1},col),del({x2,y2},col);
            ans.push_back({{x2,y1},{opt[1],opt[2]}});
            return 1;             
        }  
    }cnt=0;
    if(!check_1(x1,y2)){
        for(char op:s){
            P pos=getpos(x1,y2,op);
            if(pos.x&&(*it).y==col) opt[++cnt]=op;
        }
        if(cnt==2){
            del({x1,y1},col),del({x2,y2},col);
            ans.push_back({{x1,y2},{opt[1],opt[2]}});
            return 1;             
        }  
    }
    return 0;
}
void solve2(){
    queue<int>q;
    for(int i=1;i<=n;i++) if(check(i)) q.push(i),vis[i]=1;
    while(!q.empty()){
        int u=q.front();
        q.pop();
        int col[10],cnt=0,x1=a_[u],y1=b_[u],x2=c_[u],y2=d_[u];
        for(char op:s){
            P pos=getpos(x1,y1,op);
            if(pos.x) col[++cnt]=(*it).y;
            pos=getpos(x2,y2,op);
            if(pos.x) col[++cnt]=(*it).y;
        }
        for(int i=1;i<=cnt;i++) if(!vis[col[i]]&&check(col[i])) q.push(col[i]),vis[col[i]]=1;
    }
    wt(ans.size(),'\n');
    for(auto i:ans) wt(i.x.x,' '),wt(i.x.y,' '),putchar(i.y.x),putchar(' '),putchar(i.y.y),putchar('\n');
}
main(){
//freopen("eliminate.in","r",stdin);
//freopen("eliminate.out","w",stdout);
    input();
    reset();
    solve1();
    reset();
    solve2();
    return 0;
}
```

---

## 作者：maka_baka (赞：0)

在一个棋盘上，每个格子要么是空，要么是一种颜色的棋子。同一种颜色的棋子恰好有两个。每一轮玩家选择一个空格子和“上下左右”四个方向中的两个方向。如果在这两个方向上
- 存在有棋子的格子
- 沿着这两个方向上第一个遇到的棋子颜色相同

那么可以将这两个棋子拿走。如果不满足就忽略这个操作。给出这样一个棋盘上棋子的布局和一个人每轮的选择。
1. 指出此人能消去多少棋子。 
1. 输出能消去最多棋子数量。

棋盘宽度和颜色数量不超过 $10^5$。

## 做法
用 `std::set` 维护每行、列的棋子，可以直接模拟这个人的操作。对于最多消去数量，可以用 BFS 完成。每轮取出将要消去的 $2$ 个同颜色棋子，把它们消去。并且对于 $2$ 个棋子的每一个，判断它四个方向上的第一个棋子（如果存在）能不能消掉。

这个贪心是最优的，因为任意一对可消去的棋子，在拿走棋盘上任意数量的棋子它们一定还能消去。

## 实现
变量：
- $n$：$颜色个数 = 棋子数 / 2$。
- $(a, b, c, d)_i$：颜色为 $i$ 的 $2$ 颗棋子坐标。
- $\{\mathrm{px}\}_x\ \{\mathrm{py}\}_y$：每 $x/y$ 相同的存在同一个 `set` 里。
- $\mathrm{St}$：`std::set` 的元素类型，维护位置和颜色。
- $(\mathrm{qu}, \mathrm{hd}, \mathrm{tl})$：BFS 维护将要移除的棋子颜色。
- $\mathrm{ip}_i$：记录颜色 $i$ 的棋子还在不在棋盘上。

我用 $2$ 位二进制数表示一个方向。
- 低位表示这个方向上变化的坐标，$0$ 对应 $x$，$1$ 对应 $y$。
- 高位坐标增减方向，$0$ 减 $1$ 增。
- `int otb(char) / dtb(int, int)` 把表示方向的字符 / 坐标变化量转化成方向编码。

为了减少重复的代码，设计下面的函数。
- `init()` 把不在棋盘上的棋子摆到棋盘上。
- `int get(x, y, w)` 搜索从 $(x,y)$ 开始，$w$ 方向上的第一颗棋子的颜色。如果这个位置有棋子或这个方向上没有棋子，返回非法标记 `-1`。
- `int tryrm(x, y, w1, w2)` 从 $(x,y)$ 开始，选择 $w_1$、$w_2$ 两个方向上能不能消去同颜色的棋子。如果可以返回棋子颜色，不可以就返回非法标记 `-1`。
- `remove(i)` 把颜色是 $i$ 的 $2$ 颗棋子从棋盘上拿走。返回值不使用。
- `bool tryrmpos(x, y, i)` 判断选择 $(x,y)$ 的格子能不能删去颜色是 $i$ 的 $2$ 颗棋子。
- `bool couldrm(i)` 判断颜色是 $i$ 的 $2$ 颗棋子能不能删。
- `check(x, y)` BFS 时取出一个颜色的 $2$ 颗棋子，分别调用这个函数扩展搜索。

可能在实现时遇到的问题：[提示后人](https://www.luogu.com.cn/discuss/1034318)。

## AC Code
```cpp
#include <set>
#include <iostream>
#include <cassert>
const int N = 1e5 + 5;

struct St {
  int pos, coo;
  St(int a, int b): pos(a), coo(b) {}
  bool operator<(const St &o) const {
    return pos < o.pos;
  }
};
using It = std::set<St>::iterator;

int n, m, cnt, x1[N], y1[N], x2[N], y2[N],
    hd, tl, qu[N*8];
std::set<St> px[N], py[N];
bool ip[N];

void init() {
  for (int i=0; i<n; i++) if (!ip[i]) {
    px[x1[i]].emplace(y1[i], i);
    px[x2[i]].emplace(y2[i], i);
    py[y1[i]].emplace(x1[i], i);
    py[y2[i]].emplace(x2[i], i);
    ip[i] = true;
  }
}

int otb(char o) {
  if (o == 'U') return 0b00;
  if (o == 'D') return 0b10;
  if (o == 'L') return 0b01;
  if (o == 'R') return 0b11;
  return assert(0), -1;
}

int dtb(int dx, int dy) {
  assert((!dx && dy) || (!dy && dx));
  if (dy) return (dy < 0 ? 0b01 : 0b11);
  return         (dx < 0 ? 0b00 : 0b10);
}

int get(int x, int y, int w) {
  int i; std::set<St> *pl;
  if (w&1) i = y, pl = px + x;
  else     i = x, pl = py + y;

  It it = pl->lower_bound({i, 0});
  if (it != pl->end() && it->pos == i) return -1;
  if (w&2) return (it == pl->end() ? -1 : it->coo);
  return (it == pl->begin() ? -1 : (--it)->coo);
}

int tryrm(int x, int y, int w1, int w2) {
  int c1 = get(x, y, w1), c2 = get(x, y, w2);
  return (~c1 && ~c2 && c1 == c2 ? c1 : -1);
}

bool remove(int i) {
  px[x1[i]].erase({y1[i], 0});
  px[x2[i]].erase({y2[i], 0});
  py[y1[i]].erase({x1[i], 0});
  py[y2[i]].erase({x2[i], 0});
  return ip[i] = false, cnt++;
}

bool tryrmpos(int x, int y, int i) {
  return tryrm(x, y, dtb(x1[i]-x, y1[i]-y),
      dtb(x2[i]-x, y2[i]-y)) == i;
}

bool couldrm(int i) {
  if (x1[i] == x2[i]) {
    int y = (y1[i] + y2[i])/2;
    return y!=y1[i] && y!=y2[i] &&
      tryrmpos(x1[i], y, i);
  }

  if (y1[i] == y2[i]) {
    int x = (x1[i] + x2[i])/2;
    return x!=x1[i] && x!=x2[i] &&
      tryrmpos(x, y1[i], i);
  }

  return tryrmpos(x1[i], y2[i], i)
    || tryrmpos(x2[i], y1[i], i);
}

void check(int x, int y) {
  for (int w=0; w<4; w++) {
    int i = get(x, y, w);
    if (~i && couldrm(i)) qu[tl++] = i;
  }
}

int main() {
  std::cin >> n >> n >> n;
  for (int i=0; i<n; i++)
    std::cin >> x1[i] >> y1[i]
      >> x2[i] >> y2[i];

  init(), std::cin >> m;
  while (m--) {
    int x, y, c; char o1, o2;
    std::cin >> x >> y >> o1 >> o2;
    c = tryrm(x, y, otb(o1), otb(o2));
    ~c && remove(c);
  }
  std::cout << cnt << ' ';

  init(), cnt = 0;
  for (int i=0; i<n; i++)
    if (couldrm(i)) qu[tl++] = i;

  while (hd < tl) {
    int i = qu[hd++];
    if (ip[i]) remove(i);
    else continue;
    check(x1[i], y1[i]);
    check(x2[i], y2[i]);
  }
  std::cout << cnt << '\n';
}
```

---

## 作者：WilliamFranklin (赞：0)

一道大模拟，打了两个小时。。。

这道题是模拟赛的题，但是模拟赛上那道题还需要输出如何消得最多的方案。相当于是这题得小加强版吧。这里就先按照模拟赛上的讲，因为除了输出方案，其他的地方都是一样的，洛谷上也过了。


### 主要思路

我们可以一步一步的解决这道题。

首先考虑第一部分：这个人能够消掉多少棋子。

者部分就直接用 `set` 维护行和列的信息，小分讨一下，判下边界，过于简单，不细讲了。

具体代码如下（有些臭长，这里为了方便，用 `pair` 表示坐标）：

```cpp
  cin >> R >> C;
  cin >> n;
  For(i, 1, n) cin >> a[i] >> b[i] >> c[i] >> d[i];
  For(i, 1, n) {
      st[a[i]].insert(mp(b[i], i));
      st1[b[i]].insert(mp(a[i], i));
      st[c[i]].insert(mp(d[i], i));
      st1[d[i]].insert(mp(c[i], i));
      hv.insert(mp(a[i], b[i]));
      hv.insert(mp(c[i], d[i]));
  }
  cin >> m;
  For(i, 1, m) cin >> x[i] >> y[i] >> op1[i] >> op2[i];
  int cnt = 0;
  For(i, 1, m) {
      if (op1[i] == op2[i]) continue;
      if (hv.find(mp(x[i], y[i])) != hv.end()) continue;
      set<pair<int, int> >::iterator it, it1;
      if (op1[i] == 'U') {
          it = st1[y[i]].lower_bound(mp(x[i], 0));
          if (it == st1[y[i]].begin()) continue;
          it--;
      }
      if (op1[i] == 'D') {
          it = st1[y[i]].upper_bound(mp(x[i], 0));
          if (it == st1[y[i]].end()) continue; 
      }
      if (op1[i] == 'L') {
          it = st[x[i]].lower_bound(mp(y[i], 0));
          if (it == st[x[i]].begin()) continue;
          it--;
      }
      if (op1[i] == 'R') {
          it = st[x[i]].upper_bound(mp(y[i], 0));
          if (it == st[x[i]].end()) continue;
      }
      if (op2[i] == 'U') {
          it1 = st1[y[i]].lower_bound(mp(x[i], 0));
          if (it1 == st1[y[i]].begin()) continue;
          it1--;
      }
      if (op2[i] == 'D') {
          it1 = st1[y[i]].upper_bound(mp(x[i], 0));
          if (it1 == st1[y[i]].end()) continue; 
      }
      if (op2[i] == 'L') {
          it1 = st[x[i]].lower_bound(mp(y[i], 0));
          if (it1 == st[x[i]].begin()) continue;
          it1--;
      }
      if (op2[i] == 'R') {
          it1 = st[x[i]].upper_bound(mp(y[i], 0));
          if (it1 == st[x[i]].end()) continue;
      }
      if ((*it).y == (*it1).y) {
          cnt += 2;
          auto d = *it, d1 = *it1;
          if (op1[i] == 'U' || op1[i] == 'D') {
              st1[y[i]].erase(d);
              st[d.x].erase(mp(y[i], d.y));
              hv.erase(mp(d.x, y[i]));
          }
          if (op1[i] == 'L' || op1[i] == 'R') {
              st[x[i]].erase(d);
              st1[d.x].erase(mp(x[i], d.y));
              hv.erase(mp(x[i], d.x));
          }
          if (op2[i] == 'U' || op2[i] == 'D') {
              st1[y[i]].erase(d1);
              st[d1.x].erase(mp(y[i], d1.y));
              hv.erase(mp(d1.x, y[i]));
          }
          if (op2[i] == 'L' || op2[i] == 'R') {
              st[x[i]].erase(d1);
              st1[d1.x].erase(mp(x[i], d1.y));
              hv.erase(mp(x[i], d1.x));
          }
      }
   }
   cout << cnt / 2 << ' ';
```

那么这题重点就在于如何求最多消多少棋子。

首先，暴力的想，我们每一轮都从 $1$ 到 $n$ 枚举一下 $i$，看看 $i$ 这个颜色的棋子能不能消。直到消没了，就退出。

直觉上想，这样肯定是会 $T$ 的。那么我们再优化一下。

我们先从 $1$ 到 $n$ 枚举当前颜色 $i$，如果可消，就消，并且看一看前面那些颜色 $j\left(j<i\right)$，现在又是否可消了，但这个消是一个连环过程，我们每一次都扫一遍这个时间复杂度是很高的，那么我们就考虑如何每一次看到某个颜色可以消，就尽量一次性消掉较多的棋子呢？

我们考虑这么一种情况，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/dvbzfnm9.png)

红色节点表示我们现在要消的棋子，绿色表示的两个棋子之间无棋子阻碍的可相互到达的路径。

那么很容易就能想到的是，受影响的，可能有这几个蓝点。因为红点消完后，绿点与红点都是空的，并且按照前面规定，这些蓝点一定是不能在之前消光的，那么现在就有可能了。所以我们就只需要 `dfs` 遍历并重复上述过程。

但是这样并不能一次性消完当前所有能消的，因为如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/0oeghqwt.png)

当红点消完后，我们发现紫点也可以消（因为蓝点代表的格子上不一定有棋子），但我们就只看了蓝点代表的格子，但是因为这个题是 $5$ 秒时限，所以可以卡时枚举一下，具体看代码（当然如果想看最正规的解法的话，可以说，我会尽力而为的）。

### AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define x first
#define y second
#define mp(Tx, Ty) make_pair(Tx, Ty)
#define For(Ti, Ta, Tb) for(auto Ti = (Ta); Ti <= (Tb); Ti++)
#define Dec(Ti, Ta, Tb) for(auto Ti = (Ta); Ti >= (Tb); Ti--)
#define debug(...) fprintf(stderr, __VA_ARGS__)
#define range(Tx) begin(Tx),end(Tx)
const int N = 1e5 + 5;
int R, C;
int n, m;
int a[N], b[N], c[N], d[N];
int x[N], y[N];
char op1[N], op2[N];
set<pair<int, int> > st[N];
set<pair<int, int> > st1[N];
set<pair<int, int> > hv;
set<int> h[N];
set<int> l[N];
map<pair<int, int>, pair<int, int> > mp;
map<pair<int, int>, int> mp1;
vector<pair<int, pair<int, pair<char, char> > > > ans;
bool check(int x, int y, int x_1, int y_1, int x_2, int y_2) {
	set<int>::iterator it;
	bool f = 1;
	if (y_1 < y_2) {
		if (y == y_1) {
			it = h[x].lower_bound(y);
			if ((*it) != y_2) f = 0;
			it = l[y].upper_bound(x);
			it--;
			if ((*it) != x_1) f = 0;
		}
		if (x == x_1) {
			it = l[y].lower_bound(x);
			if ((*it) != x_2) f = 0;
			it = h[x].upper_bound(y);
			it--;
			if ((*it) != y_1) f = 0;
		}
	} else {
		if (x == x_1) {
			it = h[x].lower_bound(y);
			if ((*it) != y_1) f = 0;
			it = l[y].lower_bound(x);
			if ((*it) != x_2) f = 0;
		} else {
			it = h[x].upper_bound(y);
			it--;
			if ((*it) != y_2) f = 0;
			it = l[y].upper_bound(x);
			it--;
			if ((*it) != x_1) f = 0;
		}
	}
	return f;
}
void draw(int x_1, int y_1, int x_2, int y_2, int tot) {
	if (x_1 > x_2) {
		swap(x_1, x_2);
		swap(y_1, y_2);
	}
	int jx1 = x_1, jy1 = y_2, jx2 = x_2, jy2 = y_1;
	char opx1, opy1, opx2, opy2;
	if (y_2 > y_1) opx1 = 'L', opy1 = 'D', opx2 = 'U', opy2 = 'R';
	if (y_2 < y_1) opx1 = 'D', opy1 = 'R', opx2 = 'U', opy2 = 'L';
	set<int>::iterator it;
	set<pair<int, int> > G;
	if (x_1 == x_2) {
		if (abs(y_1 - y_2) == 1) return;
		it = h[x_1].lower_bound(y_2);
		auto it1 = it;
		auto it2 = it;
		it1++;
		it2--;
		bool f = 0;
		if (it1 != h[x_1].end() && (*it1) == y_1) f = 1;
		if (it != h[x_1].begin() && (*it2) == y_1) f = 1;
		if (!f) return;
		if (f) {
			hv.erase(mp(x_1, y_1));
			hv.erase(mp(x_2, y_2));
			ans.push_back(mp(x_1, mp(min(y_1, y_2) + 1, mp('L', 'R'))));
		}
		G.insert(mp(x_1 - 1, y_1));
		G.insert(mp(x_1, y_1 - 1));
		G.insert(mp(x_1 + 1, y_1));
		G.insert(mp(x_2 - 1, y_2));
		G.insert(mp(x_2, y_2 + 1));
		G.insert(mp(x_2 + 1, y_2)); 
	} else if (y_1 == y_2) {
		if (abs(x_1 - x_2) == 1) return;
		it = l[y_1].lower_bound(x_2);
		auto it1 = it;
		auto it2 = it;
		it1++;
		it2--;
		bool f = 0;
		if (it1 != l[y_1].end() && (*it1) == x_1) f = 1;
		if (it != l[y_1].begin() && (*it2) == x_1) f = 1;
		if (!f) return;
		if (f) {
			hv.erase(mp(x_1, y_1));
			hv.erase(mp(x_2, y_2));
			ans.push_back(mp(min(x_1, x_2) + 1, mp(y_1, mp('U', 'D'))));
		}
		G.insert(mp(x_1, y_1 - 1));
		G.insert(mp(x_1, y_1 + 1));
		G.insert(mp(x_1 - 1, y_1));
		G.insert(mp(x_2, y_2 - 1));
		G.insert(mp(x_2, y_2 + 1));
		G.insert(mp(x_2 + 1, y_2));
	} else {
		int f = 0;
		if (check(jx1, jy1, x_1, y_1, x_2, y_2)) {
			if (y_1 < y_2) {
				G.insert(mp(x_1, y_1 - 1));
				G.insert(mp(x_1 - 1, y_1));
				G.insert(mp(x_1 + 1, y_1));
				G.insert(mp(x_2, y_2 - 1));
				G.insert(mp(x_2, y_2 + 1));
				G.insert(mp(x_2 + 1, y_2));
			} else {
				G.insert(mp(x_1, y_1 + 1));
				G.insert(mp(x_1 - 1, y_1));
				G.insert(mp(x_1 + 1, y_1));
				G.insert(mp(x_2, y_2 - 1));
				G.insert(mp(x_2, y_2 + 1));
				G.insert(mp(x_2 + 1, y_2));
			}
			f = 1;
		}
		if (check(jx2, jy2, x_1, y_1, x_2, y_2)) {
			if (y_1 < y_2) {
				G.insert(mp(x_1 - 1, y_1));
				G.insert(mp(x_1, y_1 - 1));
				G.insert(mp(x_1, y_1 + 1));
				G.insert(mp(x_2, y_2 + 1));
				G.insert(mp(x_2 + 1, y_2));
				G.insert(mp(x_2 - 1, y_2));
			} else {
				G.insert(mp(x_1, y_1 - 1));
				G.insert(mp(x_1, y_1 + 1));
				G.insert(mp(x_1 - 1, y_1));
				G.insert(mp(x_2, y_2 - 1));
				G.insert(mp(x_2 + 1, y_2));
				G.insert(mp(x_2 - 1, y_2));
			}
			f = 2;
		}
		if (f == 1) ans.push_back(mp(jx1, mp(jy1, mp(opx1, opy1))));
		if (f == 2) ans.push_back(mp(jx2, mp(jy2, mp(opx2, opy2))));
		if (!f) return; 
		hv.erase(mp(x_1, y_1));
		hv.erase(mp(x_2, y_2));
	}
	h[x_1].erase(y_1);
	h[x_2].erase(y_2);
	l[y_1].erase(x_1);
	l[y_2].erase(x_2);
	for (auto i : G) {
		if (hv.find(mp(i.x, i.y)) != hv.end() && mp1[mp(i.x, i.y)] < tot) {
			auto d = mp[mp(i.x, i.y)];
			//cout << i.x << ' ' << i.y << '\n';
			draw(i.x, i.y, d.x, d.y, tot);
		}
	}
}
int main() {
	cin.tie(nullptr)->sync_with_stdio(false);
	//assert(freopen("eliminate.in", "r", stdin));
	//assert(freopen("eliminate.out", "w", stdout));
	int n, m;
	cin >> R >> C;
	cin >> n;
	For(i, 1, n) cin >> a[i] >> b[i] >> c[i] >> d[i];
	For(i, 1, n) {
		st[a[i]].insert(mp(b[i], i));
		st1[b[i]].insert(mp(a[i], i));
		st[c[i]].insert(mp(d[i], i));
		st1[d[i]].insert(mp(c[i], i));
		hv.insert(mp(a[i], b[i]));
		hv.insert(mp(c[i], d[i]));
	}
	cin >> m;
	For(i, 1, m) cin >> x[i] >> y[i] >> op1[i] >> op2[i];
	int cnt = 0;
	For(i, 1, m) {
		if (op1[i] == op2[i]) continue;
		if (hv.find(mp(x[i], y[i])) != hv.end()) continue;
		set<pair<int, int> >::iterator it, it1;
		if (op1[i] == 'U') {
			it = st1[y[i]].lower_bound(mp(x[i], 0));
			if (it == st1[y[i]].begin()) continue;
			it--;
		}
		if (op1[i] == 'D') {
			it = st1[y[i]].upper_bound(mp(x[i], 0));
			if (it == st1[y[i]].end()) continue; 
		}
		if (op1[i] == 'L') {
			it = st[x[i]].lower_bound(mp(y[i], 0));
			if (it == st[x[i]].begin()) continue;
			it--;
		}
		if (op1[i] == 'R') {
			it = st[x[i]].upper_bound(mp(y[i], 0));
			if (it == st[x[i]].end()) continue;
		}
		if (op2[i] == 'U') {
			it1 = st1[y[i]].lower_bound(mp(x[i], 0));
			if (it1 == st1[y[i]].begin()) continue;
			it1--;
		}
		if (op2[i] == 'D') {
			it1 = st1[y[i]].upper_bound(mp(x[i], 0));
			if (it1 == st1[y[i]].end()) continue; 
		}
		if (op2[i] == 'L') {
			it1 = st[x[i]].lower_bound(mp(y[i], 0));
			if (it1 == st[x[i]].begin()) continue;
			it1--;
		}
		if (op2[i] == 'R') {
			it1 = st[x[i]].upper_bound(mp(y[i], 0));
			if (it1 == st[x[i]].end()) continue;
		}
		if ((*it).y == (*it1).y) {
			cnt += 2;
			auto d = *it, d1 = *it1;
			if (op1[i] == 'U' || op1[i] == 'D') {
				st1[y[i]].erase(d);
				st[d.x].erase(mp(y[i], d.y));
				hv.erase(mp(d.x, y[i]));
			}
			if (op1[i] == 'L' || op1[i] == 'R') {
				st[x[i]].erase(d);
				st1[d.x].erase(mp(x[i], d.y));
				hv.erase(mp(x[i], d.x));
			}
			if (op2[i] == 'U' || op2[i] == 'D') {
				st1[y[i]].erase(d1);
				st[d1.x].erase(mp(y[i], d1.y));
				hv.erase(mp(d1.x, y[i]));
			}
			if (op2[i] == 'L' || op2[i] == 'R') {
				st[x[i]].erase(d1);
				st1[d1.x].erase(mp(x[i], d1.y));
				hv.erase(mp(x[i], d1.x));
			}
		}
	}
	cout << cnt / 2 << ' ';
	hv.clear();
	for (int i = 1; i <= n; i++) {
		h[a[i]].insert(b[i]);
		h[c[i]].insert(d[i]);
		l[b[i]].insert(a[i]);
		l[d[i]].insert(c[i]);
		mp[mp(a[i], b[i])] = mp(c[i], d[i]);
		mp[mp(c[i], d[i])] = mp(a[i], b[i]);
		mp1[mp(a[i], b[i])] = mp1[mp(c[i], d[i])] = i;
		hv.insert(mp(a[i], b[i])), hv.insert(mp(c[i], d[i]));
	}
	while ((double)clock() / CLOCKS_PER_SEC <= 4.6) {
		for (int i = 1; i <= n; i++) {
			if (hv.find(mp(a[i], b[i])) != hv.end()) {
				draw(a[i], b[i], c[i], d[i], i);
			}
		}
	}
	cout << ans.size() << '\n';
//	for (auto i : ans) { // 这里是输出方案 ~~恶心的模拟赛~~ 
//		cout << i.x << ' ' << i.y.x << ' ' << i.y.y.x << ' ' << i.y.y.y << '\n';
//	}
	return 0;
}

```

### 谢谢观看

---


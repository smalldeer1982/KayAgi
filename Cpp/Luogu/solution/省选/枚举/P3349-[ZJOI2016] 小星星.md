# [ZJOI2016] 小星星

## 题目描述

小 Y 是一个心灵手巧的女孩子，她喜欢手工制作一些小饰品。她有 $n$ 颗小星星，用 $m$ 条彩色的细线串了起来，每条细线连着两颗小星星。

有一天她发现，她的饰品被破坏了，很多细线都被拆掉了。这个饰品只剩下了 $n-1$ 条细线，但通过这些细线，这颗小星星还是被串在一起，也就是这些小星星通过这些细线形成了树。小 Y 找到了这个饰品的设计图纸，她想知道现在饰品中的小星星对应着原来图纸上的哪些小星星。如果现在饰品中两颗小星星有细线相连，那么要求对应的小星星原来的图纸上也有细线相连。小 Y 想知道有多少种可能的对应方式。

只有你告诉了她正确的答案，她才会把小饰品做为礼物送给你呢。


## 说明/提示

对于 $100\%$ 的数据，$n\leq 17$，$m\leq \frac 12n(n-1)$。

## 样例 #1

### 输入

```
4 3
1 2
1 3
1 4
4 1
4 2
4 3```

### 输出

```
6```

# 题解

## 作者：xyz32768 (赞：69)

将问题抽象化：

一个$n$个节点的树，和一个$n$个节点的图，要求给树上的每个节点编号，使得编号是一个$1$到$n$的排列，并且要满足树上任意一条边$(u,v)$，图中一定要有边$(x_u,x_v)$（$x_u$表示点$u$的编号），求方案数。

暴力的做法是定义状态$f[i][j][S]$表示节点$i$编号为$j$，$i$的子树内的编号集合为$S$的方案数。

但是这样的瓶颈在于枚举子集，复杂度是$O(n^3\times 3^n)$的，显然TLE。

Q：为什么要记录$S$这一维？

A：要求中有「编号是一个$1$到$n$的排列」。

尝试把「编号是一个$1$到$n$的排列」这一条件去掉，就不用记录$S$了。

这样只需要定义$f[i][j]$为在$i$的子树内，点$i$的编号为$j$的方案数。

而这时候会出现重复编号，怎么办呢？

容斥！

先$2^n$枚举$\{1,2,...,n\}$的一个子集$S$，强制规定树上每个点的编号必须是$S$的子集，然后每次$O(n^3)$一次DP，总方案数为：

$(|S|=n$的方案数$)-(|S|=n-1$的方案数$)+(|S|=n-2$的方案数$)-...$

复杂度降到$O(n^3\times 2^n)$，在UOJ上需要进行一定的常数优化。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
	int res = 0; bool bo = 0; char c;
	while (((c = getchar()) < '0' || c > '9') && c != '-');
	if (c == '-') bo = 1; else res = c - 48;
	while ((c = getchar()) >= '0' && c <= '9')
		res = (res << 3) + (res << 1) + (c - 48);
	return bo ? ~res + 1 : res;
}
typedef long long ll;
const int N = 20, M = 40;
int n, m, ecnt, nxt[M], adj[N], go[M], tot, whi[N];
bool g[N][N], vis[N]; ll f[N][N], ans;
inline void add_edge(const int &u, const int &v) {
	nxt[++ecnt] = adj[u]; adj[u] = ecnt; go[ecnt] = v;
	nxt[++ecnt] = adj[v]; adj[v] = ecnt; go[ecnt] = u;
}
inline void dfs(const int &u, const int &fu) {
	int i, j; for (int e = adj[u], v; e; e = nxt[e]) {
		if ((v = go[e]) == fu) continue; dfs(v, u);
	}
	for (i = 1; i <= tot; i++) {
		int x = whi[i]; f[u][x] = 1;
		for (int e = adj[u], v; e; e = nxt[e]) {
			if ((v = go[e]) == fu) continue; ll sum = 0;
			for (j = 1; j <= tot; j++) {
				int y = whi[j]; if (!g[x][y]) continue; sum += f[v][y];
			}
			f[u][x] *= sum;
		}
	}
}
inline void solve() {
	int i; tot = 0; for (i = 1; i <= n; i++) if (vis[i]) whi[++tot] = i;
	dfs(1, 0); for (i = 1; i <= tot; i++)
		if (n - tot & 1) ans -= f[1][whi[i]]; else ans += f[1][whi[i]];
}
inline void Dfs(const int &dep) {
	if (dep == n + 1) return solve();
	vis[dep] = 0; Dfs(dep + 1);
	vis[dep] = 1; Dfs(dep + 1);
}
int main() {
	int i, x, y; n = read(); m = read();
	for (i = 1; i <= m; i++) x = read(), y = read(), g[x][y] = g[y][x] = 1;
	for (i = 1; i < n; i++) x = read(), y = read(), add_edge(x, y);
	Dfs(1); cout << ans << endl; return 0;
}
```

---

## 作者：辰星凌 (赞：61)

# **【题解】小星星 [ZJOI2016] [P3349]**

[$\mathcal{My}\ \mathcal{Blog}$](https://www.cnblogs.com/Xing-Ling/p/13373094.html)

传送门：[小星星 $\text{[ZJOI2016] [P3349]}$](https://www.luogu.com.cn/problem/P3349)

## **【题目描述】**

给出 $n$ 个点的一张无向图 $(V,E)$ 和一颗树，现需要给每个点 $i$ 安排一个映射 $a_i$，满足对于树上任意边 $(x,y)$，均有边 $(a_x,a_y)\in E$。要求 $a$ 为一个排列（即不存在两个点的映射相同），求方案数。

## **【分析】**

> 组合意义天地灭，代数推导保平安。 —— tiger0133

大家似乎都是直接硬找的容斥系数，这里提供一个不需要费脑子的子集反演做法（最终柿子是一样的）。

先考虑最 $\text{naive}$ 的暴力状压：设 $dp(x,j,S)$ 表示点 $x$ 映射为 $j$、$x$ 子树内所有点已经使用了 $S$ 作为映射 的方案数（$S$ 为一个二进制数）。

$dp$ 数组第一、三维的作用显然，第二维 $j$ 是为了方便判断是否有连边。

转移需要枚举 $S$ 的子集，复杂度 $O(n^33^n)$，用多项式科技优化子集卷积可以做到 $O(n^42^n)$，显然还是过不了。

复杂度瓶颈在于枚举子集，必须把这个东西去掉。

优化子集 $dp$ 显然要上容斥，不过这里我们采用另一个思路：子集反演。

搞反演的第一步是设计两个状态，且需满足其中一个可以方便求得、另一个可以方便得出答案、两者之间存在关系式。

设计状态用类似二项式反演的套路去思考，如果实在想不出来就一个一个枚举限制条件，逐个检验是否可行。

本题的关键限制在于：任意两点的映射不能相同。当存在这一限制时无论怎么设都不好搞，所以设状态时需要把这个限制去掉。

$f(S)$： $n$ 个点的映射**恰好**使用了 $S$ 中的所有点（无需满足 $a$ 为排列）。

$g(S)$： $n$ 个点的映射**至多**只能够使用 $S$ 中的点（无需满足 $a$ 为排列）。

易知：  
$$g(S)=\sum_{T\subseteq S}f(T)$$

由子集反演可得：  
$$f(S)=\sum_{T\subseteq S}(-1)^{|S|-|T|}g(T)$$

> **注意**：  
在做二项式反演时，我们所说的“至多”和“至少”都是假的，真正含义为：钦定某一部分满足某条件，其余部分随意。因此 $f,g$ 的关系式中会存在一个二项式系数（一个 $f(i)$ 会被 $g(x)$ 统计多次，当状态只有一维时，这个次数为 $C_{i}^{x}$ 或者 $C_{x}^{i}$）。  
但这里子集反演定义的“至多”是真货，每个 $f(T)$ 只会被 $g(S)$ 统计一次，因此 $g(S)$ 直接就等于 $\sum_{T\subseteq S}f(T)$，不会带有奇怪的系数。

回到这道题，最终答案为 $f(V)$，其中 $V$ 为全集（即 $2^{n}-1$）。

> Q：为什喵？前面做定义时不是说的**不一定满足** $a$ 为排列吗？  
A: 由于全集 $V$ 中的 $n$ 个点全都被作为映射使用了，而一个点只能映射一个，所以 $f(V)$ 统计的方案中每个点的映射必定两两不同。

那么最后的问题就是 在不涉及 $f$ 的情况下快速计算 $g(S)$ 了。

修改一下前面的暴力状压：

用 $dp(x,j,S)$ 表示点 $x$ 映射为 $j$、$x$ 子树内所有点至多只能使用 $S$ 中的点作为映射值 的方案数（无需满足映射两两不同）。

转移为：  
$$dp(x,j,S)=\prod\limits_{to\in\{son(x)\}}\left(\sum\limits_{k\subseteq S,(j,k)\in E}dp(to,k,S)\right)$$

可得 $g(S)=\sum_{j\subseteq S}dp(rt,j,S)$，其中 $rt$ 为树的根。

时间复杂度为：$O(n^32^n)$，要凭信仰卡常....

## **【Code】**

```cpp
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<cmath>
#define LL long long
#define Re register int
using namespace std;
const int N=18,M=131072+3;
int n,m,x,y,o,V,v[N],cnt[M],head[N],A[N][N];LL ans,g[M],dp[N][N];
struct QAQ{int to,next;}a[N<<1];
inline void add(Re x,Re y){a[++o].to=y,a[o].next=head[x],head[x]=o;}
inline void in(Re &x){
    int f=0;x=0;char ch=getchar();
    while(ch<'0'||ch>'9')f|=ch=='-',ch=getchar();
    while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    x=f?-x:x;
}
inline void dfs(Re x,Re fa,Re S){
    for(Re i=1;i<=v[0];++i)dp[x][i]=1;
    for(Re i=head[x],to;i;i=a[i].next)
        if((to=a[i].to)!=fa){
            dfs(to,x,S);
            for(Re j=1;j<=v[0];++j){
                LL tmp=0;
                for(Re k=1;k<=v[0];++k)if(A[v[j]][v[k]])tmp+=dp[to][k];
                dp[x][j]*=tmp;
            }
        }
}
int main(){
//    freopen("123.txt","r",stdin);
    in(n),in(m),V=(1<<n)-1;
    if(n==1){puts("1");return 0;}
    while(m--)in(x),in(y),A[x][y]=A[y][x]=1;
    m=n-1;
    while(m--)in(x),in(y),add(x,y),add(y,x);
    for(Re s=0;s<=V;++s){
        cnt[s]=cnt[s>>1]+(s&1),v[0]=0;
        for(Re i=1;i<=n;++i)if(s&(1<<i-1))v[++v[0]]=i;
        dfs(1,0,s);LL g=0;
        for(Re i=1;i<=v[0];++i)g+=dp[1][i];
        ans+=(n-cnt[s]&1)?-g:g;
    }
    printf("%lld\n",ans);
}
```

完结洒花花~

...等等，还没完！

这题神奇地没有让取模！

虽然答案的最大值 $n!$ 没有爆 $\text{long long}$，但 $\max(g(V))=n^n$ 爆了啊。

emm....手写高精多半会 $\text{TLE}$ ....就酱吧awa  
（据说用 $\text{long long}$ 和 $\text{int128}$ 算出来的结果是一样的）


---

## 作者：C20203030 (赞：25)

## 一、题目
[点此看题](https://www.luogu.org/problem/P3349)


## 二、解法

**0x01 暴力**

不多说，直接刚全排，然后再暴力检查，$O(完全过不了)$。

**0x02 dp**

考虑用壮压$dp$对暴力优化，设$dp[i][j][s]$为树上$i$节点映射到图上$j$节点，$i$的子树（含$i$本身）映射到图上，状压成二进制$s$的方案数，用树形$dp$的方式思考，则能写出下列代码（有注释!）：


```cpp
#include <cstdio>
#include <vector>
using namespace std;
const int MAXN = (1<<17);
int read()
{
	int x=0,flag=1;char c;
	while((c=getchar())<'0' || c>'9') if(c=='-') flag=-1;
	while(c>='0' && c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return x*flag;
}
int n,m,tot,f[18],siz[18];
long long ans,dp[18][18][MAXN];
vector<int> ve[18],sit[18];
struct edge
{
	int v,next;
}e[40];
void dfs(int u,int fa)
{
	siz[u]=1;
	for(int i=1;i<=n;i++) dp[u][i][(1<<i-1)]=1;
	for(int i=f[u];i;i=e[i].next)
	{
		int v=e[i].v;
		if(v==fa) continue;
		dfs(v,u);
		//看成合并子树的过程，也就是把子树v加入 
		for(int id=1;id<=n;id++)
		{//每举u映射在图上的节点编号 
			for(int j=0;j<sit[siz[u]].size();j++)
			{
				int S=sit[siz[u]][j];
				if(!(S&(1<<id-1))) continue;//枚举的集合必须包含id 
				for(int l=0;l<ve[id].size();l++)//只能取跟id在图上相连的编号 
				{
					int vid=ve[id][l];
					if(S&(1<<vid-1)) continue;//枚举的集合不能包含vid，因为我们是加入子树 
					for(int k=0;k<sit[siz[v]].size();k++)
					{
						int vS=sit[siz[v]][k];
						if(S&vS || !(vS&(1<<vid-1))) continue;//原集合和加入的集合必须不交， 加入集合要包含vid 
						dp[u][id][S|vS]+=dp[u][id][S]*dp[v][vid][vS];//乘法原理 
					}
				}
			}
		}
		siz[u]+=siz[v];//现在已合并子树的大小 
	}
}
int main()
{
	n=read();m=read();
	for(int i=1;i<=m;i++)
	{
		int u=read(),v=read();
		ve[u].push_back(v);
		ve[v].push_back(u);
	}
	for(int i=2;i<=n;i++)
	{
		int u=read(),v=read();
		e[++tot]=edge{v,f[u]},f[u]=tot;
		e[++tot]=edge{u,f[v]},f[v]=tot;//前向星 
	}
	for(int i=0;i<(1<<n);i++)
	{
		int x=0;
		for(int j=0;j<n;j++)
			if(i&(1<<j))
				x++;
		sit[x].push_back(i);//预处理出长度为x的每一个s(树dp要用) 
	}
	dfs(1,0);
	for(int i=1;i<=n;i++)
	{
		ans+=dp[1][i][(1<<n)-1];//统计1映射到i的全集 
	}
	printf("%lld\n",ans);
}
```

**0x03  容斥**

上面的方法其实还是比较好了，只不过数据太大，被卡成了暴力。

发现时间主要消耗在集合的枚举上，如果去掉集合的枚举，答案会偏大（因为集合会映射重），对于这种问题我们考虑容斥，那我们怎么容斥呢？

由于我们有重复的映射是从数上映射到图上的，我们考虑让树上的映射重复，已达到去重的效果，我们可以先规定一个图上可用的集合，树形$dp$时只能映射到集合中的编号，这样我们就找出了重复时的情况。答案即为$规定全集-规定不选1个+规定不选2个...$。


口胡了这么久，多多少少还是（~~没~~ ）收获吧，贴上我要吸氧的代码。:)


```cpp
#include <cstdio>
#include <vector>
#include <cstring>
#define LL long long
using namespace std;
int read()
{
	int x=0,flag=1;char c;
	while((c=getchar())<'0' || c>'9') if(c=='-') flag=-1;
	while(c>='0' && c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return x*flag;
}
int n,m,tot,f[18],exi[18];
LL dp[18][18],ans;
vector<int> ve[18];
struct edge
{
	int v,next;
}e[40];
void dfs(int u,int fa)
{
	for(int i=1;i<=n;i++) dp[u][i]=1;
	for(int i=f[u];i;i=e[i].next)
	{
		int v=e[i].v;
		if(v==fa) continue;
		dfs(v,u);
		for(int j=1;j<=n;j++)
		{
			long long s=0;
			for(int l=0;l<ve[j].size();l++)
			{
				int k=ve[j][l];
				s+=dp[v][k]*(exi[j]&exi[k]);
			}
			dp[u][j]*=s;
		} 
	}
}
int main()
{
	n=read();m=read();
	for(int i=1;i<=m;i++)
	{
		int u=read(),v=read();
		ve[u].push_back(v);
		ve[v].push_back(u);
	}
	for(int i=2;i<=n;i++)
	{
		int u=read(),v=read();
		e[++tot]=edge{v,f[u]},f[u]=tot;
		e[++tot]=edge{u,f[v]},f[v]=tot;
	}
	for(int i=0;i<(1<<n);i++)
	{
		int x=n;
		memset(dp,0,sizeof dp);
		memset(exi,0,sizeof exi);
		for(int j=1;j<=n;j++)
			if(i&(1<<j-1))
				exi[j]=1,x--;
		dfs(1,0);
		for(int j=1;j<=n;j++)
		{
			ans+=dp[1][j]*(x%2?-1:1);
		}
	}
	printf("%lld\n",ans);
}
```


---

## 作者：wind_whisper (赞：22)

# 前言
看题解区各位大佬都是用的神仙的容斥 dp ，可是本蒟蒻根本想不到啊... qwq  
我写的时候用的是一种和本题大部分做法都不同的思路，虽然时间复杂度并没有正解优越，但是思考起来和代码实现都变得更加简单.  
（第一次发题解，希望管理员通过！ OvO ）

# 解析
直接考虑朴素 dp .  
$dp_{i,s,j}$ 表示 $i$ 的子树内，已经被对应的节点状态为 $s$ ，$i$ 对应的节点是 $j$ 的对应方案数.  
当 $x$ 的子树内又纳入了一个新儿子的时候，就可以枚举**交集为 $0$ 的 $u$ 和 $v$ ,以及两个集合中有连边的 $p$ 和 $q$ ,** 进行转移：  
$$ dp_{x,u|v,q}+=dp_{son,u,p}\times dp_{x,v,q}  $$
然而这么搞，即使加上枚举子集的优化，也是会 T 飞的.  
仔细想想，这里有很多的 dp 本身显然会是不合法的，我们进行了太多无用的转移.  
考虑如何优化.  
记 $siz_i$ 为 $i$ 的子树大小.  
显然，如果 $u$ 的二进制表示的1的个数不等于 $siz_{son}$ ，那么 $dp_{son,u,...}$ 必然是不合法的，没有必要从那里进行转移，我们只需要**枚举二进制表示下1的个数等于 $siz_{son}$ 的 $u$ 进行转移即可**.  
同理，若 $x$ 在**加入 $son$ 前**的子树大小为 $siz_x$ ，我们也只需要枚举二进制表示下 $1$ 的个数等于 $siz_x$ 的 $v$ 进行转移即可.  
和[有线电视网（树上背包）](https://www.luogu.com.cn/problem/P1273)的实现过程有异曲同工之妙.  

最后的答案就是：
$$\sum\limits_{i=1}^ndp_{1,2^n-1,i}$$
具体实现上，为了后面枚举的方便，我们可以预处理出来二进制表示下 $1$ 的个数为 $k$ 的数有哪些.  


于是，仅仅加入了这么一个小清新且简单易懂的优化之后，你发现你已经切掉了这道紫题.

本人的代码完全没有卡过常，不吸氧会T一个点，吸氧后可以通过.  
~~但是现在CSP NOIP都有氧气了，吸氧又有什么关系呢.~~  
~~毕竟这个方法可比容斥好像多了啊!~~  
代码写起来也很舒适，不伤肝.
# 代码
（有注释哦！）
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define il inline
const int N=2e5+100;
const double eps=1e-6;
ll read(){
  ll x=0,f=1;char c=getchar();
  while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
  while(isdigit(c)){x=(x<<1)+(x<<3)+c-'0';c=getchar();}
  return x*f;
}
int n,m;
struct node{
  int to,nxt;
}p[38];
int fi[N],cnt;
inline void addline(int x,int y){
  p[++cnt]=(node){y,fi[x]};fi[x]=cnt;
  return;
}
int st[18][N],num[18],mi[18];
int siz[18];
ll dp[18][N][18];
bool vis[18][18];
void dfs(int x,int f){
  siz[x]=1;
  for(int i=0;i<n;i++) dp[x][mi[i]][i+1]=1;//一开始x对应任何一个节点的方案数都为1
  for(int i=fi[x];~i;i=p[i].nxt){
    int to=p[i].to;
    if(to==f) continue;
    dfs(to,x);
    int a=siz[x],b=siz[to];
    for(int j=1;j<=num[a];j++){//枚举二进制下有siz[x]个1的状态
      int u=st[a][j];
      for(int k=1;k<=num[b];k++){//枚举二进制下有siz[son]个1的状态
	int v=st[b][k];
	if(u&v) continue;//如果有交集，不能产生贡献
	for(int p=1;p<=n;p++){
	  if(!dp[to][v][p]) continue;//如果dp[to][v][p]=0,必然不会再转移产生贡献
	  if((v&mi[p-1])==0) continue;//枚举的p必须是v集合内的元素
	  for(int q=1;q<=n;q++){
	    if(!vis[p][q]) continue;//p和q之间必须有连边
	    if((u&mi[q-1])==0) continue;//枚举的q必须是u集合内的元素
	    dp[x][u|v][q]+=dp[to][v][p]*dp[x][u][q];
	  }
	}
      }
    }
    siz[x]+=siz[to];
  }
  return;
}
inline int calc(int x){
  int res=0;
  while(x){
    res+=x&1;x>>=1;
  }
  return res;
}
int main(){
#ifndef ONLINE_JUDGE
  freopen("a.in","r",stdin);
  freopen("a.out","w",stdout);
  #endif
  memset(fi,-1,sizeof(fi));cnt=-1;
  n=read();m=read();
  for(int i=1;i<=m;i++){
    int x=read(),y=read();
    vis[x][y]=vis[y][x]=1;
  }
  for(int i=1;i<n;i++){
    int x=read(),y=read();
    addline(x,y);addline(y,x);
  }
  mi[0]=1;
  for(int i=1;i<=n;i++) mi[i]=mi[i-1]<<1;
  for(int i=0;i<mi[n];i++){//预处理二进制下有k个1的数有哪些
    int o=calc(i);
    st[o][++num[o]]=i;
  }
  dfs(1,0);
  ll res=0;
  for(int i=1;i<=n;i++){//统计答案
    res+=dp[1][mi[n]-1][i];
  }
  printf("%lld\n",res);
  return 0;
}
/*

*/


```
(这么简单的做法不点个赞再走吗 awa )



---

## 作者：RenaMoe (赞：16)

本题解配合我的 [容斥原理学习笔记](https://renamoe.gitee.io/2021/04/08/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/) 食用更佳。

> 给出一张图 $G$ 和一棵树 $T$，点数都为 $n$，求有多少个长为 $n$ 的排列 $\{a_i\}$，满足若存在 $\langle u,v\rangle \in T$ 则一定有 $\langle a_u,a_v\rangle \in G$。
>
> $n\le 17$。

题意转化一下，就是给树上每一个点分配一个编号，并且相邻的点有编号的限制，要求最后编号无重复。

其实一开始不太容易想到要容斥，不妨先考虑暴力状压 DP。设 $f(u,i,S)$ 表示 $u$ 点编号为 $i$，且以 $u$ 为根的子树的编号集合为 $S$，的方案数。转移就是对几个不相交的集合的合并。显然这样复杂度是爆炸的，但是已经没有优化的余地了。

这时候容斥的作用就显现了，我们可以先放宽限制来降低复杂度，然后容斥来得到最终答案。我们可以瞅准转移时“集合不相交”的限制，但是去掉了这个限制的话，编号会重复，编号集合的大小小于 $n$。

这时候有容斥的味道了。我们发现要求的是编号集合大小**等于** $n$，而现在只能得到编号集合大小**小于等于** $n$ 的方案数。于是构造若干个限制：枚举编号集合 $S$，钦定整棵树的编号集合为 $S$ 的子集。$\mathcal O(n^3)$ DP 一下可以得到 $s(S)$ 表示整棵树编号集合为 $S$ 的子集的方案数。

上套路，设大小为 $n$ 的编号集合为 $U$，对于一个编号集合恰好为 $S$ 的方案，正确的贡献应该为 $[S=U]$，得到容斥系数计算式

$$
\sum_{T\supseteq S}f(T)=[S=U]
$$

识别为集合形式，子集反演可以得到容斥系数

$$
\begin{aligned}
f(S)&=\sum_{T\supseteq S}(-1)^{|T|-|S|}[T=U]\\
&=(-1)^{n-|S|}
\end{aligned}
$$

最后答案就是 $\sum_{S\subseteq U}s(S)f(T)$。

于是我们得到了 $\mathcal O(n^32^n)$ 的做法，实际上跑的飞快。


```cpp
typedef long long LL;

const int N = 20;
const int M = (1 << 17) + 5;

int n, m;
LL ans;
int g[N][N], popcnt[M];
LL f[N][N];
vector<int> e[N], lst;

void dp(int u, int fa) {
	for (auto v: e[u]) {
		if (v == fa) continue;
		dp(v, u);
	}
	for (auto i: lst) {
		f[u][i] = 1;
		for (auto v: e[u]) {
			if (v == fa) continue;
			LL sum = 0;
			for (auto j: lst) {
				if (!g[i][j]) continue;
				sum += f[v][j];
			}
			f[u][i] *= sum;
		}
	}
}

inline void clear() {
	if (lst.empty()) return;
	for (int i = 1; i <= n; ++i)
		for (auto j: lst)
			f[i][j] = 0;
	lst.clear();
}

inline void main() {
	cin >> n >> m;
	for (int i = 1; i <= m; ++i) {
		int u, v;
		cin >> u >> v;
		g[u][v] = g[v][u] = 1;
	}
	for (int i = 1; i < n; ++i) {
		int u, v;
		cin >> u >> v;
		e[u].push_back(v);
		e[v].push_back(u);
	}
	int lim = 1 << n;
	for (int i = 0; i < lim; ++i) popcnt[i] = popcnt[i >> 1] + (i & 1);
	for (int s = 0; s < lim; ++s) {
		clear();
		for (int i = 1; i <= n; ++i)
			if (s & (1 << (i - 1))) lst.push_back(i);
		dp(1, 0);
		LL sum = 0;
		for (auto i: lst) sum += f[1][i];
		ans += sum * (((n - popcnt[s]) & 1) ? -1 : 1);
	}
	cout << ans << '\n';
}
```


---

## 作者：_lbw_ (赞：15)

已有的题解都为较为基础的容斥算法，这种容斥的正确性实际上并不显然。

在此，给出一种基于 $\textsf{FWT}$ 的做法。

设计 $f_{i,j,S}$ 表示 $i$ 的子树里，点 $i$ 对应点为 $j$，子树值域为 $S$ 的方案数，转移是子集卷积的形式。

对于子集卷积，我们可以使用占位多项式在复杂度多乘一个 $n$ 的代价上转化为异或卷积。

但实际上并不需要占位多项式，考虑直接进行异或卷积的过程。

容易发现我们最后求的是 $f_S$，而每一个树上的点最多提供一个数，若在异或时存在一位抵消，则最后求出的 $|S|<n$。

于是我们证明了直接异或卷积的正确性。

接下来将转移写出，便有一个 $\mathcal{O}(n^32^n)$ 的 $\textsf{FWT}$ 做法。笔者对这种做法进行实现再经历数次卡常后发现并不可过。

这种做法似乎已经没有优化空间了，让我们看一下代码：

```cpp
IV dfs(ll u,ll F){
	for(ll v:g[u])if(v^F)dfs(v,u);
	F(pu,1,n){
		f[u][pu][1<<pu-1]=1;FWT(f[u][pu]);//third line
		for(ll v:g[u])if(v^F){
			mem(tmp,0);
			F(pv,1,n)if(vis[pu][pv])F(j,0,S)tmp[j]+=f[v][pv][j];
			FWT(tmp);F(i,0,S)f[u][pu][i]=f[u][pu][i]*tmp[i];//first line 
		}
		IFWT(f[u][pu]);//second line
	}
}
```

我们发现 `first line` 标记处的一次 $\textsf{FWT}$  可以拆分为对 $f_{v,pv}$ 的 $\textsf{FWT}$ 之和，而 $f_{v,pv}$ 此处的值已经在 `second line` 处进行了一次 $\textsf{IFWT}$ 。

于是我们想到记录每个点的 $\textsf{FWT}$ 形式，在根处进行一次 $\textsf{FWT}$。

但我们和还有一个问题没有解决，在 `third line` 处的一行 $\textsf{FWT}$。

我们回归 $\textsf{FWT}$ 的定义式，$[z^A]\textsf{FWT}(F)=\sum\limits_{B\subseteq S}(-1)^{\textsf{popcount}(A\&B)}[z^B]F$，而此处 $F$ 只有一个位置有值，暴力即可。

我们在一系列的优化后，尽管复杂度不变，但具有更加优美的形式，且不需要用到 $\textsf{FWT}$。

因此常数有显著的下降，笔者实现后发现可以通过此题。

```cpp
const int maxn = 20;
const int maxS = (1<<17);
ll n,S,f[maxn][maxn][maxS];bool vis[maxn][maxn];
vector<ll>g[maxn];IV add(ll u,ll v){g[u].push_back(v);}
ll tmp[maxS];IV print(ll S){F(i,0,n-1)putchar((S>>i&1)+'0');}ll tot;
IV dfs(ll u,ll F){
	for(ll v:g[u])if(v^F)dfs(v,u);
	F(pu,1,n){
		F(k,0,S)f[u][pu][k]=(__builtin_popcount((1<<pu-1)&k)&1)?-1:1;
		for(ll v:g[u])if(v^F){
			mem(tmp,0);
			F(pv,1,n)if(vis[pu][pv])F(j,0,S)tmp[j]+=f[v][pv][j];
			F(i,0,S)f[u][pu][i]=f[u][pu][i]*tmp[i];
		}
	}
}
int main(){
	n=read();S=(1<<n)-1;ll m=read();
	while(m--){ll x=read(),y=read();vis[x][y]=vis[y][x]=1;}
	F(i,1,n-1){ll x=read(),y=read();add(x,y);add(y,x);}dfs(1,0);ll ans=0;
	F(i,1,n){ll tmp=0;F(j,0,S)tmp+=f[1][i][j]*((__builtin_popcount(S&j)&1)?-1:1);ans+=tmp/(S+1);}
	return cout<<ans,0;
}
```

闲话：这里的 FWT 可能实际上严谨的证明了容斥的正确性？









---

## 作者：one_cell (赞：6)

# 题意

给定一棵$n$个点的树$T$，和一张$n$个点$m$条边的图$S$，求有多少种点之间的对应关系的方案使得$T$为$S$的一个子图(等价于$T$中的每条边在某种点的对应关系下在$S$中都存在)
$$n\leq 17$$
$\;$
# Solution
## 暴力

一种朴素的想法就是暴力的枚举每一种对应方式：

如下是$n=3$的情况，箭头左边是树中的每个点，右边对应的是图中的每个点

1->1, 2->2, 3->3

1->1, 2->3, 3->2

1->2, 2->3, 3->1

1->2, 2->1, 3->3

1->3, 2->1, 3->2

1->3, 2->2, 3->1

然后我们对每种情况我们再用$O(n)$的时间去判断树中的每条边是否在图中都存在即可

时间复杂度:$O(n!\times n)$

## 子集枚举DP
我们由题中得出$T$是一棵树，而其实如果$T$是一张图，用上面的暴力算法也是可做的，所以我们要思考如何利用树的特殊性质来挖掘隐含的细节

我们发现，题中的最大难点并不是处理$T$是$S$的子图这个限制条件，而是去计算点之间的对应关系，使得方案数**不重不漏**

所以我们得到了一个思路：在树$T$上进行树形DP

首先是设计状态

第一维：$i$，当然存的是以$i$为根的子树的信息

第二维：$j$，由于子树与外界之间还有限制条件，即：根节点$i$与其父亲在DP中在图中分别对应的点会有边的限制条件，所以$j$表示的是$i$在图中的对应点

第三维：$k$，由于树上的每个点只能**唯一**对应图中的点，所以如果只有前两维状态，我并不能知道目前这棵子树中每个点已经对应到了图中的哪些点，所以就可能导致我们会算重，即：树上的某几个点对应到了图中的同一个点上，所以$k$是表示我们目前选的点集，用一个压缩后的二进制数来表示

综上所述：$f_{i,j,k}$表示以$i$为根的子树，其中$i$对应的是图中的编号为$j$的点，且子树中已经选了集合为$k$的点，满足这棵子树是$T$中把集合为$k$的点在其中的对应点挑出来所对应的图的子图

呃，可能有点长，读者可以仔细地多读几遍再消化理解。

那么对于子图也就是边的这个限制条件，我们只需在DP的过程中判断$i$与它的每个儿子在图中是否有边即可。

因此状态转移方程也易得出：

$$f_{i,j,k}=\prod_{v\in son_u} \sum_{p\in Edge_{p,j}} \sum_{q\in k} f_{v,p,q}$$  

时间复杂度：$O(n^3\times 3^n)$  
$\;$
## 容斥原理优化
我们发现，上面的DP限制时间的主要因素是我们枚举了$k$，也就是我们目前选的点集。

这样导致时间暴增。

我们考虑如何去优化这个东西。

而仔细分析即可发现枚举$k$是为了防止算重，那我们不妨可以大胆的扔掉$k$，直接进行DP。

而这样的时间复杂度只有$O(n^3)$

但这样显然是错的。

所以我们考虑如何去减掉重复的情况。

我们发现，因为多个点对应图中的一个点。那么图中一定存在若干个点没有与树中的点对应

于是这个东西就可以容斥了：我们在图中枚举与树中对应的点有哪些，记为点集$A$，容斥系数显然为$(-1)^{n-|A|}$

则我们就可以通过这种方式，在DP时只需选我们枚举的点集进行状态转移即可。
时间复杂度：$O(n^3 \times 2^n)$
$\;$
## Code

    #include <bits/stdc++.h>
    const int N = 20;
    #define LL long long
    int n, m, mp[N][N], c[N], len;
    LL res, f[N][N];
    std::vector<int> G[N];
    void Dfs(int u, int fa)
    {
        for(int i=1;i<=len;i++) f[u][c[i]] = 1;
        for(int i=0;i<G[u].size();i++)
        {
            int v = G[u][i];
            if(v == fa) continue;
            Dfs(v, u);
            for(int j=1;j<=len;j++)
            {
                LL now = 0;
                for(int k=1;k<=len;k++)
                {
                    if(mp[c[j]][c[k]]) now += f[v][c[k]];
                }
                f[u][c[j]] *= now;
            }	
        }
    }
    int main()
    {
        scanf("%d%d", &n, &m);
        for(int i=1;i<=m;i++)
        {
            int u, v;
            scanf("%d%d", &u, &v);
            mp[u][v] = mp[v][u] = 1;
        }
        for(int i=1;i<n;i++)
        {
            int u, v;
            scanf("%d%d", &u, &v);
            G[u].push_back(v); G[v].push_back(u);
        }
        for(int S=1;S<(1<<n);S++)
        {
            memset(f, 0, sizeof(f));
            len = 0; int cnt = 0;
            for(int i=0;i<n;i++)
            {
                if(S >> i & 1) c[++len] = i + 1, cnt ++;
            }
            Dfs(1, 0);
            LL t;
            if((n - cnt) & 1) t = -1;
            else t = 1;
            for(int i=1;i<=len;i++) res += t * f[1][c[i]];
        }
        printf("%lld", res);
        return 0;
    } 

---

## 作者：kczno1 (赞：6)

我们要求的是树中点的对应的集合恰好为n个点的方案数，

如果要dp，我们必须记录对应的集合，

考虑x从儿子y转移时，一个点要么在x的集合中，要么在y的集合中，要么两个不在，

时间是O(3^n)的。

而通过容斥，可以将问题转化为求对应集合<=某i个点的方案数，

这样dp时就只用记录当前点对应了哪个点，就是O(2^n\*n^3)。

怎么容斥？

比如我们一开始求出来了<=n个点的，这样大小恰好为n的已经加了，

但有可能存在实际上个数是<n的，我们就把<=n-1个的都减掉，

这样把恰好n-1个点的都减了，但这样每个<=n-2个的就会被减两次，多减了一次，所以我们再加上去，

类似这样，直到集合大小<=1的时候，我们不会再算重了。


---

## 作者：Peter_Z (赞：4)

博客内食用更佳：[蒟蒻の博客](https://blog.csdn.net/The_OIer/article/details/100585941)

题目链接：[传送门](https://www.luogu.org/problem/P3349)

题目大意：

给出一个图，给出一棵树，你需要把树上的点映射到图上，两个点不能映射到同一个点。

要求若两个点在树上有一条边连着，那么映射到的点在原图上也要有一条边，求方案数。

考虑dp。

如果直接按照两个点不能映射到同一个点的限制来做，发现子状态比较难设计（$O(3^n*n)$珂以做，但是会爆）

因此先考虑珂以有两个点映射到同一个点的情况qwq

设$dp[i][j]$表示以$i$为根，且$i$对应原图中的$j$的方案数。

$O(n^3)$转移：

初始化：$dp[x][i]=1$，因为若$x$的子树中只有$x$，那么$x$珂以对应到原图任意一个点。

对于dfs遍历到的节点$x$和$x$的孩子$v$，枚举$x$映射到的点$j$和$v$映射到的点$k$。

若$j$和$k$在原图中连了边，那么把$dp[v][k]$加到$sum$中，最后根据乘法原理，让$dp[x][j]$乘上$sum$。

然后发现这样子dp出来的结果有重复qwq，两个点珂以映射到同一个点

比如有3个点，1映射到2，2映射到2，3映射到1。

观察发现，这种情况就有一个点（3）没有被映射到qwq

所以减去这种有一个点没有映射到的情况就珂以了。

……

…………

………………

真的是介个样子吗？

考虑有两个点没被映射到的情况：

还是举3个点的例子，1映射到2，2映射到2，3也映射到2。

发现这样在1没有映射到的时候会减掉一次，3没有映射到的时候也会减掉一次，所以再加回来就珂以了。

因此用容斥，如果有奇数个点没有映射到，就减掉，偶数个点没有映射到就加上qwq

时间复杂度$O(2^nn^3)$

### ~~毒瘤~~代码
```cpp
#include<stdio.h>
#include<cstring>
#include<algorithm>
#include<vector>
#define re register int
#define rl register ll
using namespace std;
typedef long long ll;
int read() {
	re x=0,f=1;
	char ch=getchar();
	while(ch<'0' || ch>'9') {
		if(ch=='-')	f=-1;
		ch=getchar();
	}
	while(ch>='0' && ch<='9') {
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	return x*f;
}
inline void write(const int x) {
	if(x>9)	write(x/10);
	putchar(x%10+'0');
}
const int Size=18;
const int MaxE=145;
int n,m,cnt,head[Size];
struct Edge {
	int v,next;
} w[MaxE<<1];
void AddEdge(int u,int v) {
	w[++cnt].v=v;
	w[cnt].next=head[u];
	head[u]=cnt;
}
bool G[Size][Size],del[Size];
ll dp[Size][Size];		//以i为根，且i对应原图中的j号点的方案数 
void dfs(int x,int fa) {
	for(re i=1; i<=n; i++) {
		dp[x][i]=1;
	}
	for(int i=head[x]; i; i=w[i].next) {
		int nxt=w[i].v;
		if(nxt!=fa) {
			dfs(nxt,x);
			for(re j=1; j<=n; j++) {
				if(del[j])	continue;
				ll sum=0;
				for(re k=1; k<=n; k++) {
					if(del[k] || !G[j][k])	continue;
					sum+=dp[nxt][k];
				}
				dp[x][j]*=sum;
			}
		}
	}
}
inline void oper(re x) {
	memset(del,0,sizeof(del));
	re cnt=1;
	while(x) {
		if(x&1)	del[cnt]=true;
		x>>=1;
		cnt++;
	}
}
int main() {
	n=read();
	m=read();
	for(re i=1; i<=m; i++) {
		int u=read();
		int v=read();
		G[u][v]=G[v][u]=true;
	}
	for(re i=1; i<n; i++) {
		int u=read();
		int v=read();
		AddEdge(u,v);
		AddEdge(v,u);
	}
	ll ans=0;
	for(re i=0; i<(1<<n); i++) {
		oper(i);
		dfs(1,0);
		ll sum=0;
		for(re j=1; j<=n; j++) {
			sum+=dp[1][j];
		}
		if(__builtin_popcount(i)&1) {
			ans-=sum;
		} else {
			ans+=sum;
		}
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：yzhang (赞：2)

[原题传送门](https://www.luogu.org/problem/P3349)

[更好的阅读](https://www.cnblogs.com/yzhang-rp-inf/p/11262435.html)

我们考虑设$dp_{i,j}$表示树上的点$i$在图上对应的点为$j$时$i$和子树对应在图上的方案数

$dp_{u_i}=\prod_{v \in u.son} dp_{v,j}*w[i][j]$（w[i][j]表示在图中$i$和$j$是否连通）

这个dp的复杂度是$O(n^3)$，但是会发现它会多算答案，因为这个算法有可能会将多个树上的点对应到一个图上的点

我们珂以二进制枚举，枚举哪些图上的点参与dp，按照容斥原理加减，这样就珂以算出答案，复杂度为$O(2^n n^3)$

```cpp
#include <bits/stdc++.h>
#define ll long long
#define N 20
#define getchar nc
using namespace std;
inline char nc(){
    static char buf[100000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
inline int read()
{
    register int x=0,f=1;register char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return x*f;
}
inline void write(register ll x)
{
    if(!x)putchar('0');if(x<0)x=-x,putchar('-');
    static int sta[20];register int tot=0;
    while(x)sta[tot++]=x%10,x/=10;
    while(tot)putchar(sta[--tot]+48);
}
struct edge{
    int to,next;
}e[N<<1];
int head[N],cnt=0;
inline void add(register int u,register int v)
{
    e[++cnt]=(edge){v,head[u]};
    head[u]=cnt;
}
int n,m,w[N][N],ban[N],vis[N];
ll f[N][N],ans;
inline void dfs(register int x)
{
    vis[x]=1;
    for(register int i=1;i<=n;++i)
        f[x][i]=1;
    for(register int i=head[x];i;i=e[i].next)
    {
        int v=e[i].to;
        if(vis[v])
            continue;
        dfs(v);
        for(register int j=1;j<=n;++j)
        {
            ll sum=0;
            for(register int k=1;k<=n;++k)
                sum+=f[v][k]*(w[k][j]&ban[k]&ban[j]);
            f[x][j]*=sum;
        }
    }
}
int main()
{
    n=read(),m=read();
    for(register int i=1;i<=m;++i)
    {
        int u=read(),v=read();
        w[u][v]=w[v][u]=1;
    }
    for(register int i=1;i<n;++i)
    {
        int u=read(),v=read();
        add(u,v),add(v,u);
    }
    for(register int k=1,siz;k<=(1<<n)-1;++k)
    {
        siz=n;
        for(register int i=1;i<=n;++i)
            ban[i]=0;
        for(register int i=1,p=k;p;p>>=1,++i)
            ban[i]=p&1,siz-=p&1;
        for(register int i=1;i<=n;++i)
            vis[i]=0;
        dfs(1);
        ll cnt=0;
        for(register int i=1;i<=n;++i)
            cnt+=f[1][i];
        if(siz%2)
            ans-=cnt;
        else
            ans+=cnt;
    }
    write(ans);
	return 0;
}
```

---

## 作者：conprour (赞：1)

# 题解
## 设计 DP
看到数据范围还有题目里面玄学的对应关系，可以想到状压，用一维表示已被对应的节点状态。

考虑对于每一个转移的父子点对 $u,v$，由于转移的条件就是有连边，所以 $u,v$ 对应的点在原图中一定有连边，转移的时候把 $u$ 当前子树和 $v$ 子树的状态合并（也就是逻辑或），就可以顺利转移。

因此，设计 $dp(u,stat,p)$ 表示 $u$ 节点对应的节点是 $p$，$u$ 子树内对应状态为 $stat$。

## 优化 DP

可以用**容斥**优化，但是比较难，而且其他题解已经写的很好了。

这里介绍一种不需要容斥的做法。

* 最简单的想法，基于 DP 本身的状态，每个子树对应的状态里 $1$ 的个数一定等于子树大小，预处理出来可以省去大量枚举。

* 其次，枚举子树的时候类比树形背包，每次转移完 DP 之后再 ``siz[u]+=siz[v]``。

* 基本就这些，还可以有一点点无聊的优化，比如在 DP 值为 $0$ 的时候直接跳出循环。

吸氧能够卡过，最大点约 $850ms$。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int INF = 0x3f3f3f3f,N = 20;
inline ll read()
{
	ll ret=0;char ch=' ',c=getchar();
	while(!(c>='0'&&c<='9')) ch=c,c=getchar();
	while(c>='0'&&c<='9') ret=(ret<<1)+(ret<<3)+c-'0',c=getchar();
	return ch=='-'?-ret:ret;
}
int n,m,head[N],ecnt=-1;
bool mp[N][N];
inline void init_edge(){memset(head,-1,sizeof(head)),ecnt=-1;}
struct edge
{
	int nxt,to;	
}a[N<<1];
inline void add_edge(int x,int y)
{
	a[++ecnt]=(edge){head[x],y};
	head[x]=ecnt;
}
ll dp[N][1<<18][N],siz[N];
int num[N][1<<18],cnt[N];
void dfs(int u,int fa)
{
	siz[u]=1;
	for(int i=1;i<=n;i++) dp[u][1<<(i-1)][i]=1LL;
	//初始化，u对应任何一个点方案都为1
	for(int i=head[u];~i;i=a[i].nxt)
	{
		int v=a[i].to;
		if(v==fa) continue; 
		dfs(v,u);
		for(int j=1;j<=cnt[siz[u]];j++)	
			for(int k=1;k<=cnt[siz[v]];k++)
			{
				int stat1=num[siz[u]][j];
				int stat2=num[siz[v]][k];
				if(stat1&stat2) continue;
				for(int p=1;p<=n;p++)
					if((1<<(p-1))&stat2)
					{
						if(!dp[v][stat2][p]) continue;
						for(int q=1;q<=n;q++)
						{
							if(mp[q][p]&& ((1<<(q-1))&stat1) )
							dp[u][stat1|stat2][q]+=dp[u][stat1][q]*dp[v][stat2][p];
						}
					}
			}
		siz[u]+=siz[v];
	}
}
int main()
{
	init_edge();
	n=read(),m=read();
	for(int i=1;i<=m;i++)	
	{
		int u=read(),v=read();
		mp[u][v]=mp[v][u]=1;
	}
	for(int i=1;i<n;i++)	
	{
		int u=read(),v=read();
		add_edge(u,v),add_edge(v,u);
	}
	for(int i=0;i<1<<n;i++)	
	{
		int tcnt=0;
		for(int j=1;j<=n;j++)	
			if((1<<(j-1))&i) tcnt++;
		num[tcnt][++cnt[tcnt]]=i;
	}
	dfs(1,-1);
	ll ans=0ll;
	for(int i=1;i<=n;i++)		
		ans+=dp[1][(1<<n)-1][i];
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：wsyhb (赞：1)

## 题意简述

给定一个 $n$ 个点，$m$ 条边的无向图 $G$ 和一棵 $n$ 个点的树 $T$，求有多少个长度为 $n$ 的排列 $p$，使得 $\forall (u,v) \in T$，$(p_u,p_v) \in G$。

**数据范围**：$1 \le n \le 17$，$0 \le m \le \dfrac{n(n-1)}{2}$。

## 题解

### 状压 DP

看到 $n \le 17$，容易想到**状压 DP**。

设 $f(x,k,S)$ 表示 $p_x=k$ 且 $\{p_y \mid y \in sub_x \}=S$ 的方案数，其中 $sub_x$ 表示 $x$ 的子树。（说人话：$p_x$ 为 $k$ 且 $x$ 子树中的点对应的 $p$ 组成集合 $S$）

$k$ 用于判断 $x$ 和它的父亲、儿子之间的边是否满足题意，$S$ 用于保证 $p$ 中 $1,2,\cdots,n$ 每个数只出现至多一次。

答案即为 $\sum_{k=1}^{n}f(\mathit{root},k,\{1,2,\cdots,n\})$，其中 $\mathit{root}$ 表示树根。

此算法时间复杂度为 $O(n^3 3^n)$，显然无法通过此题。

考虑把 $S$ 这一维去掉。由于此时求得的 $f$ 中包含 $p$ 中多次出现同一个数的情况，于是使用**子集反演**。

### 子集反演

设 $F(S)$ 表示 $p$ 中只出现 $S$ 集合中的数的方案数（至多），$G(S)$ 表示 $p$ 中只出现 $S$ 集合中的数且 $S$ 集合中的数均出现的方案数（恰好），则有：

$$F(S)=\sum_{T \subset S}G(T)$$

列出**初始恒等式**（这是反演的套路）：

$$G(S)=\sum_{T \subset S}G(T)[S=T]$$

由非空集合的奇子集和偶子集个数相等（空集只有一个偶子集）可知：

$$\sum_{T \subset S}(-1)^{|T|}=[S=\varnothing]$$

将其代入前述式子（$S=T$ 等价于 $S \setminus T=\varnothing$）：

$$G(S)=\sum_{T \subset S}G(T)\sum_{R \subset S \setminus T}(-1)^{|R|}$$

交换求和符号并代入 $F$ 的定义式：

$$G(S)=\sum_{R \subset S }(-1)^{|R|}\sum_{T \subset S \setminus R}G(T)=\sum_{R \subset S }(-1)^{|R|}F(S \setminus R)$$

换元，即：

$$G(S)=\sum_{T \subset S}(-1)^{|S|-|T|}F(T)$$

P.S. 请注意子集反演与二项式反演的区别：子集反演的函数自变量是集合；**二项式反演**的函数自变量是非负整数，即**单个因变量包含了某一固定大小的子集的所有情况，因此要乘上二项式系数**。

------------

对于固定的 $S$，我们可以通过前述树形 DP （去掉集合那一维）在 $O(n^3)$ 的时间复杂度内计算 $F(S)$，于是我们可以在 $O(2^n n^3)$ 的时间复杂度内计算本题答案，即 $G(\{1,2,\cdots,n\})$。

注意：本题的答案显然不会超过 $17! < 4 \times 10^{14}$，但 $F$ 的最大值可达 $17^{17} > 8 \times 10^{20}$，于是应使用 `unsigned long long` 存储计算中的值。（因为答案 $\in [0,2^{64}-1]$，而使用 `unsigned long long` 相当于模 $2^{64}$）

## 代码

``` cpp
#include<bits/stdc++.h>
using namespace std;
const int max_n=17+5;
int End[max_n<<1],Last[max_n],Next[max_n<<1],e;
inline void add_edge(int x,int y)
{
	End[++e]=y,Next[e]=Last[x],Last[x]=e;
	End[++e]=x,Next[e]=Last[y],Last[y]=e;
}
const int max_m=17*8+5;
int End1[max_m<<1],Last1[max_n],Next1[max_m<<1],e1;
inline void add_edge1(int x,int y)
{
	End1[++e1]=y,Next1[e1]=Last1[x],Last1[x]=e1;
	End1[++e1]=x,Next1[e1]=Last1[y],Last1[y]=e1;
}
bool Map[max_n][max_n];
int S[max_n],tot;
unsigned long long dp[max_n][max_n];
void dfs(int x,int fa)
{
	for(int i=1;i<=tot;++i)
		dp[x][i]=1;
	for(int i=Last[x];i;i=Next[i])
	{
		int y=End[i];
		if(y!=fa)
		{
			dfs(y,x);
			for(int j=1;j<=tot;++j)
			{
				unsigned long long sum=0;
				for(int k=Last1[j];k;k=Next1[k])
					sum+=dp[y][End1[k]];
				dp[x][j]*=sum;
			}
		}
	}
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;++i)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		Map[u][v]=Map[v][u]=true;
	}
	for(int i=1;i<=n-1;++i)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		add_edge(u,v);
	}
	int mx=(1<<n)-1;
	unsigned long long ans=0;
	for(int s=1;s<=mx;++s)
	{
		tot=0;
		for(int i=0;i<n;++i)
		{
			if(s>>i&1)
				S[++tot]=i+1;
		}
		e1=0;
		for(int i=1;i<=tot;++i)
			Last1[i]=0;
		for(int i=1;i<=tot;++i)
			for(int j=i+1;j<=tot;++j)
			{
				if(Map[S[i]][S[j]])
					add_edge1(i,j);
			}
		dfs(1,0);
		unsigned long long sum=0;
		for(int i=1;i<=tot;++i)
			sum+=dp[1][i];
		if((n^tot)&1)
			ans-=sum;
		else
			ans+=sum;
	}
	printf("%llu\n",ans);
	return 0;
}
```

---

## 作者：Vocanda (赞：0)

## 题目
[题目链接](https://www.luogu.com.cn/problem/P3349)

## 分析
首先考虑朴素状压。我们要求的答案是这棵树有多少中在图上的节点标号映射方案，所以我们设 $f[i][j][S]$ 表示将 $i$ 节点映射为 $j$ 节点，其子树内的点使用的映射集合为 $S$ 的方案数，答案显然就是 $\sum^{n}_{i=1}f[1][i][U]$ ，表示 $1$ 映射为 $i$ ，且子树映射为全集的方案数。转移的时候注意一下包含与不包含关系的判断就行了。

## Code 20pts
```cpp
#include<bits/stdc++.h>
using namespace std;
const int L = 1 << 20;
char buffer[L],*S,*T;
#define gc (S == T && (T = (S = buffer) + fread(buffer,1,L,stdin),S == T) ? EOF : *S++)
inline int read(){
	int s = 0,f = 1;char ch = gc;
	for(;!isdigit(ch);ch = gc)if(ch == '-')f = -1;
	for(;isdigit(ch);ch = gc)s = s * 10 + ch - '0';
	return s * f;
}
#define rint register int
#define rll register long long
#define ll long long
const int maxn = 18;
ll ans,f[maxn][maxn][1<<maxn];
struct Node{
	int v,next;
}e[maxn<<2];
vector<int>g[maxn],vec[maxn];
int head[maxn],tot;
int n,m;
int siz[maxn];
inline void Add(rint x,rint y){
	e[++tot].v = y;
	e[tot].next = head[x];
	head[x] = tot;
}
inline void dfs(rint x,rint fa){
	siz[x] = 1;
	for(rint i = 1;i <= n;++i)f[x][i][1<<(i-1)] = 1;
	for(rint i = head[x];i;i = e[i].next){
		rint v = e[i].v;
		if(v == fa)continue;
		dfs(v,x);
		for(rint id = 1;id <= n;++id){//枚举当前点映射为哪个标号
			rint size = g[siz[x]].size();
			for(rint j = 0;j < size;++j){//枚举当前大小的所有状态
				rint S = g[siz[x]][j];
				if(!(S & (1 << (id - 1))))continue;//如果该状态不包括映射的标号就直接不管
				rint siz2 = vec[id].size();
				for(rint l = 0;l < siz2;++l){//找当前映射的标号连的边
					rint idx = vec[id][l];
					if(S & (1 << (idx - 1)))continue;//如果该状态包含了子树中的边就不选。
					rint siz3 = g[siz[v]].size();
					for(rint k = 0;k < siz3;++k){//枚举大小为子树大小的所有状态
						rint T = g[siz[v]][k];
						if(S & T || !(T & (1 << (idx - 1))))continue;//当前集合和子树集合的状态不能有交，不然可能算重，且子树集合要包含子树所枚举的那个映射
						f[x][id][S | T] += f[x][id][S] * f[v][idx][T];//乘法原理计算
					}
				}
			}
		}
		siz[x] += siz[v];
	}
}
int main(){
	n = read(),m = read();
	for(rint i = 1;i <= m;++i){
		rint x = read(),y = read();
		vec[x].push_back(y);
		vec[y].push_back(x);
	}
	for(rint i = 1;i < n;++i){
		rint x = read(),y = read();
		Add(x,y);
		Add(y,x);
	}
	rint mx = (1 << n) - 1;
	for(rint i = 0;i <= mx;++i){
		rint cnt = 0;
		for(rint j = 0;j < n;++j){
			if(i & (1 << j))cnt++;
		}
		g[cnt].push_back(i);//计算每个个数下都有哪些状态。
	}
	dfs(1,0);
	for(rint i = 1;i <= n;++i){
		ans += f[1][i][mx];
	}
	printf("%lld\n",ans);
	return 0;
}
```
显然这个暴力不可用 ~~(因为数组开太大MLE了)~~ ，开小点应该还能过一些点。
## Continue
我们继续考虑对这个暴力状压进行优化。本题的关键点就在于要求映射集合不能有重复的，那么我们直接去除这个限制。钦定有且仅有集合 $S$ 能够出现在映射中。所以我们可以设 $f(S)$ 为所有点映射恰好是集合 $S$ 的情况。$g(S)$ 为所有点映射最多为 $S$ 的情况，那么我们就可以得到如下式子：
$$g(S) = \sum_{T\subseteq S}f(T)$$
证明：显然。$T$ 是 $S$ 的子集，所以 $g(S)$ 为 $S$ 集合使用不一定全的情况，所以就等于所有子集使用完全的情况求和。

然后利用子集反演，得到：
$$f(S)=\sum_{T\subseteq S}(-1)^{|S|-|T|}\times g(T)$$

答案就是 $f(全集)$ 。

然后我们对上边的状压进行修改，用于求出 $g(S)$ ，重新定义 $f[i][j][S]$ 为 $i$ 映射为 $j$ ，使用集合最大为 $S$ 的方案，其转移就可以这样：
$$f[x][j][S]=\prod _{v\subseteq \{son\{x\}\}} (\sum_{T\subseteq S ,(x,v)\subseteq E}f[v][T][S])$$

最终得到
$$g(S)=\sum _{j\subseteq S} f[1][j][S]$$

在这里由于状态不会瞎变，所以我们改为枚举所有状态，然后把第三维压掉就行了。

然后开始乱七八糟根据一堆式子求个和就行了。代码卡卡常，跑过毫无压力。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int L = 1 << 20;
char buffer[L],*S,*T;
#define gc (S == T && (T = (S = buffer) + fread(buffer,1,L,stdin),S == T) ? EOF : *S++)
#define rint register int
#define rll register long long
#define reg register
#define ll long long
#define read() ({\
	rint s = 0,f = 1;reg char ch = gc;\
	for(;!isdigit(ch);ch = gc)if(ch == '-')f = -1;\
	for(;isdigit(ch);ch = gc)s = s * 10 + ch - '0';\
	s * f;\
})
const int maxn = 18;
ll ans,f[maxn][maxn];//压掉状态那一维，因为枚举状态即可。
struct Node{
	int v,next;
}e[maxn<<2];
int head[maxn],tot;
int n,m;
int vec[maxn][maxn];
int jl[maxn],cnt[1<<maxn];
inline void Add(rint x,rint y){
	e[++tot].v = y;
	e[tot].next = head[x];
	head[x] = tot;
}
inline void dfs(rint x,rint fa){
	for(rint i = 1;i <= jl[0];++i)f[x][jl[i]] = 1;//初始化
	for(rint i = head[x];i;i = e[i].next){
		rint v = e[i].v;
		if(v == fa)continue;
		dfs(v,x);//递归回溯
		for(rint j = 1;j <= jl[0];++j){//枚举集合元素
			rll tmp = 0;
			for(rint k = 1;k <= jl[0];++k){//同上
				if(vec[jl[j]][jl[k]])tmp += f[v][jl[k]];//两点之间有边就加上贡献
			}
			f[x][jl[j]] *= tmp;//乘法原理计算总贡献
		}
	}
}
int main(){
	n = read(),m = read();
	for(rint i = 1;i <= m;++i){//记录原图中相连的边
		rint x = read(),y = read();
		vec[x][y] = vec[y][x] = 1;
	}
	for(rint i = 1;i < n;++i){
		rint x = read(),y = read();
		Add(x,y);
		Add(y,x);
	}
	rint mx = (1 << n) - 1;//全集
	for(rint i = 0;i <= mx;++i){//枚举状态
		cnt[i] = cnt[i>>1] + (i & 1);//计算当前状态的元素个数
		jl[0] = 0;rll tmp = 0;
		for(rint j = 1;j <= n;++j)if(i & (1 << (j - 1)))jl[++jl[0]] = j;//记录集合元素个数以及元素
		dfs(1,0);
		for(rint j = 1;j <= jl[0];++j)tmp += f[1][jl[j]];//求和
		ans += ((n - cnt[i]) & 1) ? -tmp : tmp;//根据子集反演的式子求和
	}
	printf("%lld\n",ans);
	return 0;
}

```

---

## 作者：Sym_Je (赞：0)

# [ZJOI2016]小星星   
## 题目大意  
给你一棵树问你把他插入一个图上的方案数 。   

## $solution$   
首先我们肯定会先思考状压 $dp$ ,$dp[i][j][k]$ 为树上的 $j$ 映射到图上的 $i$，目前的状态为 $k$ ,因为我们不知道每个点的位置，所以似乎不是很好搞 。 我们一算复杂度也会炸的呀，所以我们思考一下，有没有方法可以忽略掉每个点映射到图的位置 ， 如果我们忽略掉点的位置，会发生什么呢，呢么显然会有一堆点聚在一个点上面 ，呢么我们想呢么我们只要把两个点重合的减去就好啦 ，因为可能会有两个点重合，所以我们算出只用 $n-1$ 个点的算出来，然后减去，之后我们发现，这样我们有一些方案显然会被减两次，所以我么还要加上 $n-2$ 的 ，$emmm$, 很显然咯，容斥一下就好啦 。   

* $code$  

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll maxn=50;
ll f[maxn][maxn],ma[maxn][maxn]; 
ll n,m;
ll head[maxn],num;
struct Le
{
	ll nt,to;
}edge[maxn];
ll ans,tot,z[maxn];
void add(ll f,ll t){
	edge[++num].nt=head[f];
	edge[num].to=t;
	head[f]=num;
}

void get(ll u,ll fa) {
	for(ll i=1;i<=tot;++i) f[u][z[i]]=1;
	for(ll i=head[u];i;i=edge[i].nt) {
		ll v=edge[i].to;
		if(v==fa) continue ;
		get(v,u);
		for(ll i=1;i<=tot;++i) {
			ll sum=0;
			for(ll j=1;j<=tot;++j) {
				if(ma[z[i]][z[j]]) {
					sum+=f[v][z[j]];
				}
			}
			f[u][z[i]]*=sum;
		}
	}
}

void dfs(ll x,ll sl) {
	if(x>n) {
		get(1,-1);
		ll sum=0;
		for(ll i=1;i<=tot;++i) sum+=f[1][z[i]];
		if((n-sl)%2) ans-=sum;
		else ans+=sum;
		return ;
	}
	z[++tot]=x;
	dfs(x+1,sl+1);
	--tot;
	dfs(x+1,sl);
}
int main() {
	scanf("%lld%lld",&n,&m);
	//for(ll i=1;i<=n;++i) ma[i][i]=1;
	for(ll i=1;i<=m;++i) {
		ll x,y;
		scanf("%lld%lld",&x,&y);
		ma[x][y]=ma[y][x]=1;
	} 
	for(ll i=1;i<n;++i) {
		ll x,y;
		scanf("%lld%lld",&x,&y);
		add(x,y);add(y,x);
	} 
	dfs(1,0);
	cout<<ans<<"\n";
	return 0;
}

```

---


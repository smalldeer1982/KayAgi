# [APIO2008] DNA

## 题目描述

分析如DNA序列这样的生命科学数据是计算机的一个有趣应用。从生物学的角度上说，DNA是一种由腺嘌呤、胞嘧啶、鸟嘌呤和胸腺嘧啶这四种核苷酸组成的链式结构。这四种核苷酸分别用大写字母A、C、G、T表示。这样，一条DNA单链可以被表示为一个只含以上四种字符的字符串。我们将这样的字符串称作一个DNA序列。

有时生物学家可能无法确定一条DNA单链中的某些核苷酸。在这种情况下，字符N将被用来表示一个不确定的核苷酸。换句话说，N可以用来表示A、C、G、T中的任何一个字符。我们称包含一个或者多个N的DNA序列为未完成序列；反之，就称作完成序列。如果一个完成序列可以通过将一个未完成序列中的个N任意替换成A、C、G、T得到的话，就称完成序列适合这个未完成序列。举例来说，ACCCT适合ACNNT，但是AGGAT不适合。

研究者们常按照如下方式排序四种核苷酸：A优先于C，C优先于G，G优先于T。如果一个DNA序列中的个核苷酸都与其右边的相同或者优先，就将其归类为范式-1。举例来说，AACCGT是范式-1，但是AACGTC不是。

一般来说，一个DNA序列属于范式-j(j>1)，只要它属于范式-(j-1)或者是一个范式-(j-1)和一个范式-1的连接。举例来说，AACCC、ACACC和ACACA都是范式-3，但GCACAC和ACACACA不是。

同样，研究者们按照字典序对DNA序列进行排序。按照这个定义，最小的属于范式-3的DNA序列是AAAAA，最大的是TTTTT。这里是另外一个例子，考虑未完成序列ACANNCNNG。那么前7个适合这个未完成序列的DNA序列是：
```
ACAAACAAG
ACAAACACG
ACAAACAGG
ACAAACCAG
ACAAACCCG
ACAAACCGG
ACAAACCTG
```

## 样例 #1

### 输入

```
9 3 5 
ACANNCNNG```

### 输出

```
ACAAACCCG```

## 样例 #2

### 输入

```
5 4 10 
ACANN```

### 输出

```
ACAGC ```

# 题解

## 作者：huayucaiji (赞：9)

## 前言

APIO 08的好题，代码量不大，思维量有一些。

## 解法

这种题其实套路明显，就是先预处理一些数据，最后再扫一遍求出答案。有点像二进制从高位开始一点一点逼近的感觉。

一开始，将字符串转化为数字表示。

我们可以用 DP 来求出范式$-j$ 的个数。由题意，范式$-(j-1)$ 也是范式$-j$，为了统计方便，我们先令范式$-(j-1)$ 不是范式$-j$，最后前缀和合并即可。

我们令 $f_{i,j,x}$ 为考虑到第 $i$ 位，这一位是 $x$ 的范式$-j$ 个数。易得转移方程：

$$f_{i,j,x}=\sum\limits_{y=1}^4 f_{i+1,j-(x>y),y}$$

如果这一位是确定的字符，那么 $x$ 就是一个定值。

求完前缀和后，我们按照前面所说的方法求解答案即可。

## 代码

有点丑（毕竟循环层数有点多）。

看了其他大佬的代码发现其实可以把代码中部分循环合并，优化常数和代码行数。但是本人较菜，觉得写这种思路清晰的代码比较好。

毕竟，你完全没必要在简单问题上耍杂技。

~~除非在女同学面前。~~

```cpp
//Don't act like a loser.
//This code is written by huayucaiji
//You can only use the code for studying or finding mistakes
//Or,you'll be punished by Sakyamuni!!!
#include<bits/stdc++.h>
#define int long long
using namespace std;

int read() {
	char ch=getchar();
	int f=1,x=0;
	while(ch<'0'||ch>'9') {
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') {
		x=x*10+ch-'0';
		ch=getchar();
	}
	return f*x;
}

const int MAXN=5e4+10; 

int n,k,r;
int f[MAXN][11][5],a[MAXN];

char trans(int x) {
	if(x==1) return 'A';
	if(x==2) return 'C';
	if(x==3) return 'G';
	return 'T';
}

signed main() {
	cin>>n>>k>>r;
	for(int i=1;i<=n;i++) {
		char c;
		cin>>c;
		if(c=='A') a[i]=1;
		else if(c=='C') a[i]=2;
		else if(c=='G') a[i]=3;
		else if(c=='T') a[i]=4;
		else a[i]=0;
	}
	
	if(!a[n]) {
		for(int i=1;i<=4;i++) {
			f[n][1][i]=1;
		}
	}
	else {
		f[n][1][a[n]]=1;
	}
	
	for(int i=n-1;i;i--) {
		if(a[i]) {
			for(int j=1;j<=k;j++) {
				for(int y=1;y<=4;y++) {
					f[i][j][a[i]]+=f[i+1][j-(a[i]>y)][y];
				}
			}
		}
		else {
			for(int x=1;x<=4;x++) {
				for(int j=1;j<=k;j++) {
					for(int y=1;y<=4;y++) {
						f[i][j][x]+=f[i+1][j-(x>y)][y];
					}
				}
			}
		}
	}
	
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=k;j++) {
			for(int x=1;x<=4;x++) {
				f[i][j][x]+=f[i][j-1][x];
			}
		}
	}
	
	for(int i=1,last=0;i<=n;i++) {
		if(a[i]) {
			printf("%c",trans(a[i]));
			k-=(a[i]<last);
			last=a[i];
		}
		else {
			int x;
			for(x=1;x<=4&&r>f[i][k-(x<last)][x];x++) {
				r-=f[i][k-(x<last)][x];
			}
			printf("%c",trans(x));
			k-=(x<last);
			last=x;
		}
	}
	puts("");
	return 0;
}

```

---

## 作者：ysner (赞：3)

[更好的阅读体验](https://zybuluo.com/ysner/note/1158123)

我们要求出第$r$种方案，莫过于看其前面什么时候有$r-1$种方案。

于是，我们要求出每种情况的方案数。

设$dp[s][m][n]$表示第$i-n$个字母中，已分$m$段，第$i$个字母为s（$s\in\{A,C,G,T\}$)字母的序号 的方案数。

状态转移方程易得：(其中$las$是下一个字母）

$dp[j][k][i]+=dp[l][k-(j>las)][i+1]$

为了下面运算方便，要对$dp[s][m][n]$求前缀和$sum[s][m][n]=\sum_{i=1}^s dp[i][m][n]$

然后就可以从前往后推了，若碰到的字母已知，看是否影响段数就可以了；

如果碰到的字母未知，枚举$s=1...4$的情况，如$r>dp[s][m][n]$，说明第$r$个还在当前枚举字母情况的后面，继续枚举；否则，这一位就应该填当前枚举到的字母。
```
#include<iostream>
#include<cmath>
#include<cstring>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#define ll long long
#define re register
#define il inline
#define fp(i,a,b) for(re int i=a;i<=b;i++)
#define fq(i,a,b) for(re int i=a;i>=b;i--)
using namespace std;
const int N=1e5+100;
char s[N];
int m,k,a[N];
ll r,n,dp[5][15][N],sum[5][15][N];
il ll gi()
{
  re ll x=0,t=1;
  re char ch=getchar();
  while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
  if(ch=='-') t=-1,ch=getchar();
  while(ch>='0'&&ch<='9') x=x*10+ch-48,ch=getchar();
  return x*t;
}
il void wri(re int x)
{
  if(x<0) putchar('-'),x=-x;
  if(x>9) wri(x/10);
  putchar(x%10+'0');
}
int main()
{
  n=gi();m=gi();r=gi();
  scanf("%s",s+1);
  fp(i,1,n)
    if(s[i]=='A') a[i]=1;else if(s[i]=='C') a[i]=2;else if(s[i]=='G') a[i]=3;else if(s[i]=='T') a[i]=4;
  if(a[n]) dp[a[n]][1][n]=1;
  else fp(i,1,4) dp[i][1][n]=1;
  fq(i,n-1,1)
    fp(j,1,4)
    if(!a[i]||a[i]==j)
      fp(k,1,m)
    fp(l,1,4)
    dp[j][k][i]+=dp[l][k-(j>l)][i+1];
  fp(i,1,4)
    fp(j,1,n)
    fp(k,1,m)
    sum[i][k][j]=sum[i][k-1][j]+dp[i][k][j];
  re int las=0;
  fp(i,1,n)
    if(a[i])
      {
    if(a[i]<las) --m;
    las=a[i];
    putchar(s[i]);
      }
    else
      {
    re int j;
    for(j=1;j<=4&&r>sum[j][m-(j<las)][i];j++) r-=sum[j][m-(j<las)][i];
    if(j==1) putchar('A');if(j==2) putchar('C');if(j==3) putchar('G');if(j==4) putchar('T');
    if(j<las) --m;
    las=j;
      }
  puts("");
  return 0;
}
```
  [1]: https://www.luogu.org/problemnew/show/P3624

---


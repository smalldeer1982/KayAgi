# [APIO2014] 序列分割

## 题目描述

你正在玩一个关于长度为 $n$ 的非负整数序列的游戏。这个游戏中你需要把序列分成 $k + 1$ 个非空的块。为了得到 $k + 1$ 块，你需要重复下面的操作 $k$ 次：

选择一个有超过一个元素的块（初始时你只有一块，即整个序列）

选择两个相邻元素把这个块从中间分开，得到两个非空的块。

每次操作后你将获得那两个新产生的块的元素和的乘积的分数。你想要最大化最后的总得分。


## 说明/提示

你可以通过下面这些操作获得 $108$ 分：

初始时你有一块 $(4, 1, 3, 4, 0, 2, 3)$。在第 $1$ 个元素后面分开，获得 $4 \times (1 + 3 + 4 + 0 + 2 + 3) = 52$ 分。

你现在有两块 $(4), (1, 3, 4, 0, 2, 3)$。在第 $3$ 个元素后面分开，获得 $(1 + 3) \times (4 + 0 + 2 + 3) = 36$ 分。

你现在有三块 $(4), (1, 3), (4, 0, 2, 3)$。在第 $5$ 个元素后面分开，获得 $(4 + 0) \times (2 + 3) = 20$ 分。

所以，经过这些操作后你可以获得四块 $(4), (1, 3), (4, 0), (2, 3)$ 并获得 $52 + 36 + 20 = 108$ 分。

限制与约定

第一个子任务共 11 分，满足 $1 \leq k < n \leq 10$。

第二个子任务共 11 分，满足 $1 \leq k < n \leq 50$。

第三个子任务共 11 分，满足 $1 \leq k < n \leq 200$。

第四个子任务共 17 分，满足 $2 \leq n \leq 1000, 1 \leq k \leq \min\{n - 1, 200\}$。

第五个子任务共 21 分，满足 $2 \leq n \leq 10000, 1 \leq k \leq \min\{n - 1, 200\}$。

第六个子任务共 29 分，满足 $2 \leq n \leq 100000, 1 \leq k \leq \min\{n - 1, 200\}$。

感谢@larryzhong  提供的加强数据


## 样例 #1

### 输入

```
7 3
4 1 3 4 0 2 3```

### 输出

```
108
1 3 5```

# 题解

## 作者：hongzy (赞：57)

首先，这题**答案与切的顺序无关**

证明很好证，考虑将一块$abc$分为$a,b,c$三块

方法一：先分成$a,bc$。答案为$a (b + c) + bc = ab + ac + bc$

方法二：先分成$ab,c$。答案为$c (a + b) + ab = ab + ac + bc$

答案相同。

然后考虑$dp$方程：若$s[x]=\sum_{i=1}^x a[i]$，令$f[i][j]$表示前$i$个数分$j$次的最大得分

$f[i][j]=min_{0\leq l<i}(f[l][j - 1] + s[l] * (s[i] - s[l]))$

需要滚动数组存，以下用$f[i]$表示$f[i][j-1]$（前驱状态）

然后考虑当$i$选$j$转移优于$l$时：（以下默认$j < l$）

$$f[j] + s[j]s[i] - s[j]^2 > f[l] + s[l]s[i] - s[l]^2$$

$$f[j] - s[j]^2 - (f[l] - s[l]^2) > (s[l]- s[j])s[i]$$

$$\frac{f[j] - s[j]^2 - (f[l] - s[l]^2)}{- s[j] -(-s[l])} > s[i]$$

把每个点看做$P_i(-s[i],f[i]-s[i]^2)$，那么单调队列维护一个点集，斜率递增

这些点形成了一个在第三象限的下凸包

操作：

队头更新：若$slope(q[head], q[head + 1]) \leq s[i]$则出队（显然）

队尾更新：若$slope(q[back - 1], q[back]) \geq slope(q[back], i)$则出队

**队尾操作的证明**（也就是**对凸包的证明**）：

考虑$q[back]$可不可能做队头。若满足刚刚上方的条件，则：

若$slope(q[back],q[back-1]) \leq s[i]$使得$q[back]$成了队首

这时候当前的$slope$比刚刚的还要小，因此将继续出队，$q[back]$无法做队头。

斜率递增，故是一个凸包

还有一个细节：注意可能会出现$a[i]=0$，导致存在$s[i] = s[j]$，因此计算斜率应注意横坐标相同的情况，斜率为$-\infty$.

```cpp
#include <algorithm>
#include <cstring>
#include <cstdio>
using namespace std;

typedef long long LL;

const int N = 1e5 + 10;

int n, k, fa[205][N];
LL s[N], f[N], g[N];

double slope(int a, int b) {
	LL x1 = - s[a], y1 = g[a] - s[a] * s[a];
	LL x2 = - s[b], y2 = g[b] - s[b] * s[b];
	if(x1 == x2) return -1e18;
	return (y2 - y1) / (double) (x2 - x1);
}

int main() {
	scanf("%d%d", &n, &k);
	for(int i = 1; i <= n; i ++) {
		scanf("%lld", s + i);
		s[i] += s[i - 1];
	}
	static int q[N], hd, bk;
	for(int t = 1; t <= k; t ++) {
		for(int i = 1; i <= n; i ++) g[i] = f[i]; 
		hd = bk = 0;
		for(int i = 1; i <= n; i ++) {
			for(; bk - hd >= 2 && slope(q[hd], q[hd + 1]) <= s[i]; hd ++) ;
			f[i] = 0;
			if(hd < bk) {
				int & j = q[hd]; fa[t][i] = j;
				f[i] = g[j] + s[j] * (s[i] - s[j]);
			}
			for(; bk - hd >= 2 && slope(q[bk - 1], q[bk - 2]) >= slope(i, q[bk - 1]); bk --) ;
			q[bk ++] = i;
		}
	}
	printf("%lld\n", f[n]);
	for(int x = fa[k][n]; k; x = fa[-- k][x])
		printf("%d ", x);
	return 0;
}
```

> upd: 感谢@chennengkuan 指出定义的小错误

---

## 作者：Siyuan (赞：46)

[$$\Large\texttt{My Blog}$$](https://hydingsy.github.io/articles/problem-APIO-2014-Split-the-Sequence/)

---

## Description

> 题目链接：[Luogu 3648](https://www.luogu.org/problemnew/show/P3648)

你正在玩一个关于长度为 $n$ 的非负整数序列 $a_i$ 的游戏。这个游戏中你需要把序列分成 $k+1$ 个非空的块。为了得到 $k+1$ 块，你需要重复下面的操作 $k$ 次：

1. 选择一个有超过一个元素的块（初始时你只有一块，即整个序列）
2. 选择两个相邻元素把这个块从中间分开，得到两个非空的块。

每次操作后你将获得那两个新产生的块的元素和的乘积的分数。你想要最大化最后的总得分。

数据范围：$2\le n\le 10^5$，$1\le k\le \min(n-1,200)$，$0\le a_i\le 10^4$

------

## Solution

我们首先证明**答案和分割顺序无关**。

如果我们有长度为 $3$ 的序列 $x,y,z$ 将其分为 $3$ 部分，有如下两种分割方法：

1. 先在 $x$ 后面分割，答案为 $x(y+z)+yz$ 即为 $xy+yz+zx$。
2. 先在 $y$ 后面分割，答案为 $(x+y)z+xy$ 即为 $xy+yz+zx$。

然后这个结论可以扩展到任意长度的序列（分析一下贡献），证明完毕 QAQ

那么我们定义 $F_{i,j}$ 表示前 $i$ 个数进行 $j$ 次切割的最大得分。我们记 $a_i$ 的前缀和为 $s_i$，那么转移方程为：
$$F_{i,k}=\max\{F_{j,k-1}+s_j(s_i-s_j)\}\quad (0\le j<i)$$
为了方便表述，我们记 $F_{i,k}$ 为 $f_i$，$F_{j,k-1}$ 为 $g_j$，相当于把 $F$ 的第二维滚动掉了。

那么方程为：
$$f_i=\max\{g_j+s_j(s_i-s_j)\}\quad (0\le j<i)$$
感觉是一个很显然的可以**斜率优化**的式子！

我们任取 $j,k$ 满足 $0\le k<j<i$ 且 $j$ 比 $k$ **更优**，那么有如下不等式：

$$g_j+s_j(s_i-s_j)\ge g_k+s_k(s_i-s_k)$$
$$\frac{(g_j-{s_j}^2)-(g_k-{s_k}^2)}{s_k-s_j}\le s_i$$

维护一个**下凸壳**然后斜率优化即可。

**注意**：本题中 $a_i$ 是**非负整数**，所以 $s_k-s_j$ 可能等于 $0$。这种情况需要特判，$\text{slope}$ 需要返回 $-\text{INF}$。

**时间复杂度**：$O(nk)$（貌似还可以凸优化？带权二分？）

------

## Code

```cpp
#include <cstdio>
#include <cstring>

const int N=1e5+5,M=205;
int n,k,a[N],q[N],pre[N][M];
long long s[N],f[N],g[N];

double slope(int i,int j) {
	if(s[i]==s[j]) return -1e18;
	return 1.0*((g[i]-s[i]*s[i])-(g[j]-s[j]*s[j]))/(s[j]-s[i]);
}
int main() {
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;++i) scanf("%d",&a[i]),s[i]=s[i-1]+a[i];
	for(int j=1;j<=k;++j) {
		int l=1,r=0;
		q[++r]=0;
		for(int i=1;i<=n;++i) {
			while(l<r&&slope(q[l],q[l+1])<=s[i]) ++l;
			f[i]=g[q[l]]+s[q[l]]*(s[i]-s[q[l]]);
			pre[i][j]=q[l];
			while(l<r&&slope(q[r-1],q[r])>=slope(q[r],i)) --r;
			q[++r]=i;
		}
		memcpy(g,f,sizeof(f));
	}
	printf("%lld\n",f[n]);
	for(int x=n,i=k;i>=1;--i) x=pre[x][i],printf("%d%c",x," \n"[i==1]);
	return 0;
}
```



---

## 作者：学委 (赞：26)

对于一类 DP 形如 $f[i] = \min_{L_i \le j \le R_i}(f[j] + sum(i, j))$，斜率优化可以维护 DP 中的最佳继承。

这题也许是一道很好的斜率优化入门题。

### 状态简化

切的顺序可以自定，似乎状态很复杂。

尽可能简化状态。看看有没有这样一个结论：**切的位置可以完全决定获得的分数**（即与顺序无关）。

怎么验证？从**每个元素获得的系数**来考虑（即“我到底与哪些数字相乘了”）。

___

假设打算这样分割（圆圈序号表示分割的位置）：

8 7　*①*　6 3 **17**　*②*　20 14 15　*③*　0 2 3

可以考虑数字 17 与谁相乘：

* 不管按什么顺序切割，与块内的元素从来不会相乘。

* 那么和右边那个 2 相乘过吗？在**首次和 2 分离**的时候（不管先切 *②* 还是 *③*）相乘了，此后**两者无法再次“分离”，一定不会再次相乘。**

 跟其它**块外元素**也一样，分离肯定要分，但只分离一次。

___

不管切的顺序如何，对于某个块内的单个元素，它：

* 与**块内的元素**肯定不会相乘；

* 与**其它块内的任何一个元素**肯定相乘恰好一次。

所以，**切的位置决定获得的分数，什么顺序都一样**。

下面都是状态都是**假定从前往后分割**，比较方便。

现在甚至可以用 $dp[i][t]$ 表示在前 $i$ 个数中切了 $t$ 刀（为了方便继承，定最后一个切割位置为 $i$）能获得的最高分数。比较直观的继承方式是枚举上一个切割位置，然后切 $i$ 获得此次分数。

```cpp
for (int i = 1; i <= n; ++i)
  for (int t = 1; t <= k; ++t) {
    // 现在求 dp[i][t]
    
    for (int j = 1; j <= i - 1; ++j) // 选择哪个位置作为“上一个分割位置”？这是决策
      if (dp[j][t - 1] + // 该切割位置的已得分数
         (sum[i] - sum[j]) * (sum[n] - sum[i]);// 这是本次切割的分数，用前缀和很方便地表示出左右两块
  }
```

这样能求出答案，但是超时。我觉得继承大概要 $O(1)$，怎么维护最优决策？

### 斜率优化

现在眼前有两个选择：**继承 $j1$** 或**继承 $j2 (j1 < j2)$**。

如果 $j1$ 优于 $j2$，即：

$$ dp[j1] + (sum[i] - sum[j1]) * (sum[n] - sum[i]) > dp[j2] + (sum[i] - sum[j2]) * (sum[n] - sum[i]) $$

*暂时省略 dp 数组的第二维*

移项：

$$ (sum[n] - sum[i]) * (sum[j2] - sum[j1]) > dp[j2] - dp[j1] $$

再移项，同时注意符号，$sum[j2] - sum[j1]$ 肯定非负（可能为 $0$，需另加考虑）。

$$ \frac{dp[j2] - dp[j1]}{sum[j2] - sum[j1]} < sum[n] - sum[i] $$

**对于 $i$ 来说**，$j1$ 和 $j2$ 只要满足这个不等式就说明决策 $j1$ 优于 $j2$。

现在施加可视化魔法。在坐标系上，以 $sum[j]$ 为横坐标，$dp[j]$ 为纵坐标，把每个决策表示为**点**。

![](https://mant.ink/Picture/Solution/APIO2014/01.png)

*这里有 4 个备选决策。注意，sum[] 和 dp[] 都是单调不减的。*

现在不等式左边可以视为 **$j1$、$j2$ 连线的斜率**；而 $j1$ 优于 $j2$ 的**条件**是斜率足够小（小于“$i$ 的某个常数”）。

观察。$j2$ 看起来像是“下沉点”，即它有一个糟糕的特征：斜率 $k(j1, j2) < k(j2, j3)$；**如果 $j2$ 优于 $j3$，那么由上面的条件可知，$j1$ 一定优于 $j2$，所以它不可能成为最佳决策。** 我们删掉下沉点 $j2$，留下的点之间，斜率单调递减。

 ![](https://mant.ink/Picture/Solution/APIO2014/02.png)

* 现在备选决策之间，相邻点斜率单调递减。可能是 7　6　4　3.5　1　0.9。

* 再回顾一下“更优”的条件：**斜率足够小**。

二分查找到第一个小于 $sum[n] - sum[i]$ 的斜率。由于决策之间的斜率是递减的，保证**前面的决策都没它好，它比后面的决策都好**。

可以用单调队列代替二分查找：

- 注意到 “$i$ 的常数”（即 $sum[n] - sum[i]$） 是单调递减的。

- 计算 $dp[i][t]$ 的步骤：对 “已切 $t - 1$ 刀”备选决策队列进行筛选，从前往后删掉斜率太大的，直到队首斜率小于 $sum[n] - sum[i]$，队首就是对于 $i$ 最优的。

	因为随着 $i$ 的上升，筛选只会越来越严格，所以不必管之前就被筛掉的决策，于是单调队列可以维护。
    
- 算出 $dp[i][t]$ 后，更新 $t$ 的决策队列，从后往前删掉下沉点，再加入 $dp[i][t]$。

注意：

* 对于第二维的每个 $t$（已切的刀数）维护一个单调队列。

* 继承了 $t - 1$ 的最优策略以后，更新 $t$ 的备选决策。

* 序列元素只是非负，因此可能会有横坐标相同的点。处理方法可见代码。

* 可以直接记录决策。

* 最后寻找答案，需要看看最后一刀切在哪里是最优的。
   
```cpp
#include <cstdio>
#include <cctype>
typedef long long LL;

const int N = 100010;

int n, k, q[N][210], l[210], r[210], d[210], pre[N][210];
LL a[N], sum[N], dp[N][210];
inline double K(int t, int j1, int j2) {
  if (sum[j1] == sum[j2])
    return 1e18;// 赋极大值，入队时会把横坐标相同的点排挤掉 
  return (double)(dp[j2][t] - dp[j1][t]) /
    (sum[j2] - sum[j1]);
}

int main() {
  scanf("%d %d", &n, &k);
  for (int i = 1; i <= n; ++i)
    scanf("%lld", &a[i]), sum[i] = sum[i - 1] + a[i];
  
  for (int t = 0; t <= k; ++t)
    q[l[t] = r[t] = 1][t] = 0; // 该层的单调队列 
  
  for (int i = 1; i <= n; ++i) {
    double k_top = sum[n] - sum[i]; // 考官的要求
    
    for (int t = k; t >= 1; --t) { // 倒序枚举楼层，防止自己“选择自己作为上一个分割点”。其实正序也不会错，因为该选择太差
      
      while (l[t - 1] <= r[t - 1] - 1) {
        int j1 = q[l[t - 1]][t - 1], j2 = q[l[t - 1] + 1][t - 1];
        double k = K(t - 1, j1, j2);
        if (k > k_top)
          ++l[t - 1];
        else
          break;
      }
      
      int v = q[l[t - 1]][t - 1];// 决策 
      dp[i][t] = dp[v][t - 1] +
        (sum[n] - sum[i]) * (sum[i] - sum[v]);
      
      pre[i][t] = v;
      
      // 添加新的决策（入队），注意第二维不同了 
      while (r[t] >= l[t] + 1) {
        double k2 = K(t, q[r[t]][t], i),
          k1 = K(t, q[r[t] - 1][t], q[r[t]][t]);
        if (k1 < k2)
          --r[t];
        else
          break;
      }
      q[++r[t]][t] = i;
    }
  }
  

  {
    int t = k, i = 0; LL ans = 0;
    for (int j = 1; j <= n; ++j) // 枚举最后一刀
      if (dp[j][k] > ans)
        ans = dp[j][k], i = j;
    
    printf("%lld\n", ans);
    
    while (t) {
      d[t] = i;
      i = pre[i][t--];
    }
    
    for (int j = 1; j <= k; ++j)
      printf("%d", d[j]), putchar((j == k) ? ('\n') : (' '));
  }
  return 0;
}
```

---

## 作者：Rayment (赞：16)

# Solution

**如果你还不知道斜率优化，安利一篇不错的[blog](http://blog.csdn.net/force_chl/article/details/79096609)(from chlience dalao)**


首先对于一个数列，若要将其分为三段，总和分别是a,b,c。有两种分法：

$a(b+c)+bc=ab+ac+bc$

$(a+b)c+ab=ab+ac+bc$

经过推广，可以发现切的顺序对于结果没有影响。

既然如此，我们就可以方便地定义状态f[p][i]表示在前 i 之中切 p 刀的答案，则有

$f[p][i]=\max_{j<i}{(f[p-1][j]+sum[j]\times(sum[i]-sum[j]))}$

至于当前方案的贡献为 $sum[j] \times (sum[i]-sum[j])$ 的原因，因为顺序对答案不影响，对于现在dp到i时，可以认为在还未进行dp的 [i+1,n] 的范围是已经切好了的，而之前dp出的最优方案是以后才切的，即从后往前切。不妨假令 j 为这 [1,i] 中的第一刀，那么这一刀对答案的贡献即为$sum[j]\times(sum[i]-sum[j])$。

这个朴素DP的时间复杂度为$O(n^2k)$，空间复杂度为$O(nk)$。空间时间都炸了，妥妥的。


容易想到每一次的状态转移只与上一次有关，那么用滚动数组压成两维即可。

其次，方程中有前缀和，而数列为非负整数，那么前缀和是单调递增，容易想到斜率优化。**为了方便表达，现在省去 f 数组的第一维，大家可以默认为下方公式中的 f 数组指上一次dp的状态，即 f[p-1]。**

令现在有 j,k 两个位置，满足j>k，我们不妨假设选择 k 要优于选择 j 。

那么需要满足

$f[j]+sum[j]* (sum[i]-sum[j]) \leq f[k]+sum[k] * (sum[i]-sum[k])$

$\Rightarrow sum[i] \leq \frac{f[k]-sum[k]^2-f[j]+sum[j]^2}{sum[j]-sum[k]}$

然后由此算斜率优化。但是有一个坑点，就是数列为非负整数，因此有可能会出现$sum[j]-sum[k]=0$，而除以一个0就RE/WA了！而对于这种情况，可以知道不管在不在这个地方切开对答案应该没有影响，所以特判一下，return一个极小/大值。

#Unsolved Problem

本蒟蒻并没有想到如何对记录路径的to数组进行压维，对于空间的优化不尽如人意。**如果有dalao有什么好方法的话请指出啊** QAQ

# Code
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
typedef long long ll;
const int maxn=100010;
int n,k,x,r,h,t,to[210][maxn],q[maxn];
ll sum[maxn],f[2][maxn];
inline ll pow(ll a){return a*a;}
inline double slope(int j,int k)
{
    if(sum[j]==sum[k]) return -1e18;
    return (f[r&1^1][k]-pow(sum[k])-f[r&1^1][j]+pow(sum[j]))*1.0/(sum[j]-sum[k]);
}
int main()
{
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++)scanf("%d",&x),sum[i]=sum[i-1]+x;
    for(r=1;r<=k;r++)
    {
        h=t=0;
        for(int i=1;i<=n;i++)
        {
            while(h<t&&slope(q[h],q[h+1])<=sum[i]) h++;
            f[r&1][i]=f[r&1^1][q[h]]+sum[q[h]]*(sum[i]-sum[q[h]]);
            to[r][i]=q[h];
            while(h<t&&slope(q[t-1],q[t])>=slope(q[t],i)) t--;
            q[++t]=i;
        }
    }
    printf("%lld\n",f[k&1][n]);
    for(int i=k,u=n;i>=1;i--)
    {
        u=to[i][u];
        printf("%d ",u);
    }
    return 0;
}
```

---

## 作者：aiyougege (赞：6)

### Solution
#### 算法
容易发现产生的得分只和切的位置有关和切的顺序无关.

设$f(i,j)$表示前$i$个数切$j$刀产生的最大得分,$s_i=\sum_{i=1}^ia_i$(即前缀和).
那么切$j$刀可以看成是**第一刀**在第$l$个位置切一刀, 那么第$l+1\sim i$个数和前$l$个数产生了$(s_i-s_l)s_l$的得分, **然后再对前$l$个数进行划分**, 那么这样切的总得分就是$f(l,j-1)+(s_i-s_l)s_l$.

那么可以得到转移方程
$$f(i,j)=\max f(k,j-1)+(s_{i}-s_k)s_k$$
若$$f(k)+s_{k}^2-s_is_k>f(l)+s_l^2-s_is_l$$
$$(s_l-s_k)s_i>s_l^2-s_k^2+f(l)-f(k)$$
$$s_i>\frac{s_l^2-s_k^2+f(l)-f(k)}{s_l-s_k}$$
可以用斜率优化进行优化, 优化后dp的复杂度为$O(nk)$.
推荐斜率优化一道题[玩具装箱](https://www.luogu.org/problemnew/show/P3195).
#### 实现
因为开二维数组所需空间过大, 又因为每次都是从$f(i,j-1)$转移到$f(k,j)$.所以可以用滚动数组优化.

这里我开了两个一维数组$ff[],gg[]$,然后用两个指针$f=ff,g=gg$.
转移完一维时直接 **交换$f,g$** 即可.既方便又好用.
#### Code
```c++
#include<iostream>
#include<cstring>
#include<cstdio>
#define N 100005
#define int long long
using namespace std;

int n,k;
int q[N],h,t;
int fa[N][205];
int s[N],ff[N],gg[N];
long double pq(int b,int a,int *f){
    if(s[a]==s[b])return -1e9;
    return (s[b]*s[b]-s[a]*s[a]-f[b]+f[a])/(1.0*(s[b]-s[a]));
}
main(){
    int tr;
    scanf("%lld%lld",&n,&k);
    for(int i=1;i<=n;++i){
        scanf("%lld",&tr);
        s[i]=s[i-1]+tr;
    }
    int *f,*g;
    f=ff,g=gg;
    for(int j=1;j<=k;++j){
        h=t=0;
        for(int i=1;i<=n;++i){
            while(h<t&&pq(q[h],q[h+1],g)<=s[i])++h;
            f[i]=g[q[h]]+(s[i]-s[q[h]])*s[q[h]];
            fa[i][j]=q[h];
            while(h<t&&pq(q[t],i,g)<=pq(q[t-1],q[t],g))--t;
            q[++t]=i;
        }
        swap(f,g);
    }
    printf("%lld\n",g[n]);
    int q=fa[n][k],p=k;
    while(p){
        printf("%d ",q);
        q=fa[q][--p];
    }
    return 0;
}
```

---

## 作者：罗旅洲 (赞：6)

/\*
50分的暴力: 复杂度: O(kn^2)

首先要发现一个性质: 只要选定了切的位置,不论什么顺序切,答案都是一样

例如: 把序列切两次,每段的和分为 x1 x2 x3,

先在1,2间切的得分: x1\*(x2+x3)+x2\*x3 = x1\*x2+x1\*x3+x2\*x3

先在1,3间切的得分: x3\*(x1+x2)+x1\*x2 = x1\*x3+x1\*x2+x1\*x2

所以就可以

用dp(i,j) 表示前j个数切i次的总得分,sum是前缀和

dp(i,j) = max(dp(i-1, k) + (sum(j)-sum(k))\*sum(k));

k是枚举<j的区间里的一个切点

\*/
    
    
```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<iostream>
using namespace std;
const int maxx=1e5+5;
#define For(i,a,b) for(register int i=(a);i<=(b);++i)
#define Rep(i,a,b) for(register int i=(a);i>=(b);--i)
#define LL long long
int read(){
    char x=getchar(); int u=0;
    while(!isdigit(x)) x=getchar();
    while(isdigit(x)) u=(u<<3)+(u<<1)+(x^48), x=getchar();
    return u;
}
LL sum[maxx],dp[201][maxx],to[201][maxx],n,k;
int main(){
#ifndef ONLINE_JUDGE
    freopen("a.in","r",stdin);
    freopen("a.out","w",stdout);
#endif
    n=read(); k=read();
    For(i,1,n)
        sum[i]=sum[i-1]+read();
    For(i,1,n)
        For(j,1,i-1)
            For(p,1,k)
                if(dp[p][i]<=dp[p-1][j]+sum[j]*(sum[i]-sum[j])){
                    dp[p][i]=dp[p-1][j]+sum[j]*(sum[i]-sum[j]);
                    to[p][i]=j;
                }
    printf("%lld\n",dp[k][n]);
    int i=n;
    Rep(j,k,1){
        i=to[j][i];
        printf("%d ",i);
    }
    return 0;
}
```
/\*
100分:

在50分的暴力基础上,因为原式大概为

     dp(i)=max(dp(k) + sum(i) \* sum(k) - sum(k)^2);

可以斜率优化

假设 j<k 即可以从k转移

sum(i) > [ sum(j)^2-sum(k)^2 + dp(k) - dp(j) ] / (sum(j) -sum(k);

输出方案时,只需要记录每次由谁转移

洛谷上只开了128M,uoj上开了256M,所以洛谷上会MLE

幸好dp(i,j) =max(dp(i-1, k) +sum(...))

每次只由上一层转移过来,所以可以开滚动数组

\*/
```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<iostream>
using namespace std;
const int maxx=1e5+1;
#define For(i,a,b) for(register int i=(a);i<=(b);++i)
#define Rep(i,a,b) for(register int i=(a);i>=(b);--i)
#define LL long long
#define sqr(x) ((x)*(x))
int read(){
    char x=getchar(); int u=0;
    while(!isdigit(x)) x=getchar();
    while(isdigit(x)) u=(u<<3)+(u<<1)+(x^48), x=getchar();
    return u;
}
LL sum[maxx],dp[2][maxx],n,k,p;
int to[201][maxx];
int q[maxx],l,r;
bool type=0;
double slope(int x,int y){            // 斜率
    if(sum[x]==sum[y]) return -1e18;
    return (double)(sqr(sum[x]) - sqr(sum[y])-dp[type^1][x] + dp[type^1][y]) / (double) (sum[x]-sum[y]);
}
int main(){
#ifndef ONLINE_JUDGE
    freopen("a.in","r",stdin);
    freopen("a.out","w",stdout);
#endif
    n=read(); k=read();
    For(i,1,n)
        sum[i]=sum[i-1]+read();
    for(p=1; p<=k; ++p){
        l=r=0; type^=1;
        For(i,1,n){
            while(l<r && slope(q[l],q[l+1]) <= sum[i]) ++l;
            dp[type][i]=dp[type^1][q[l]]+sum[q[l]]*(sum[i]-sum[q[l]]);
            to[p][i]=q[l];
            while(l<r && slope(q[r-1],q[r]) >= slope(q[r],i)) --r;
            q[++r]=i;
        }
    }
    printf("%lld\n",dp[type][n]);
    int i=n;
    Rep(j,k,1){
        i=to[j][i];
        printf("%d ",i);
    }
    return 0;
}
```

---

## 作者：_Sein (赞：4)

## 题面描述
[传送门](https://www.luogu.org/problemnew/show/P3648)

## 思路
## 对于同一种分割方式，顺序不会影响最终结果。
分析样例$(4,1,3,4,0,2,3)$，

如果先切$5$,则$(4+1+3+4+0)*(2+3)=60$

再切$3$,则$(4+1+3)*(4+0)=32$

最后切$1$,则$4*(1+3)=16$

结果$60+32+16=108$

通过~~玄学研究~~观察，我们发现最后分成块的元素:

1. 一定不会与同块的元素**相乘**对答案产生贡献
(因为只有分块时，才会进行操作，对答案产生贡献)
3. 会与其他块的**所有**元素进行**相乘且仅乘一次**，对答案产生贡献


那么我们就可以判断:

对于同一种分割方式，顺序不会影响最终结果.

## 因此仅有切的位置会影响结果

所以这是我们可以推出状态转移方程

设$s$为$a$的前缀和

$$F_{i,p+1}=\max(F_{j,p}+s_j*(s_i-s_j))$$

正好符合

1. 一定不会与同块的元素**相乘**对答案产生贡献
(因为只有分块时，才会进行操作，对答案产生贡献)
3. 会与其他块的**所有**元素进行**相乘且仅乘一次**，对答案产生贡献

## 决策单调性

设

$$F_{k,p}+s_k*(s_i-s_k)\ge F_{j,p}+s_j*(s_i-s_j)(j<k<i)$$




在未来状态$t$下，

证明:

$$F_{k,p}+s_k*(s_t-s_k)\ge F_{j,p}+s_j*(s_t-s_j)$$

 由于$s_t=s_i+val$，
 
$$F_{k,p}+s_k*(s_i+val-s_k)\ge F_{j,p}+s_j*(s_i+val-s_j)$$

只需证明:

$$s_k*val\ge s_j*val$$

由于$val>0,s_k\ge s_j$

证毕。

注意，为了保证单调性，我们要避免$s_k== s_j$，避免出锅

## 踢队头
$$F_{k,p}+s_k*(s_i-s_k)\ge F_{j,p}+s_j*(s_i-s_j)(j<k<i)$$
 
$$F_{k,p}+s_k*(s_i-s_k)\ge F_{j,p}+s_j*(s_i-s_j)$$

$$F_{j,p}-F_{k,p}-{s_j}^2+{s_k}^2\le s_i*(s_k-s_j)$$

由于$s_k-s_j>0$，

$$calc(j,k)=\frac{F_{j,p}-F_{k,p}-{s_j}^2+{s_k}^2}{s_k-s_j}\le s_i$$

当$calc(j,k)\le s_i$时，$k$优于$j$.

因此当$$calc(q_{head},q_{head+1})\le s_i$$

$head+1$优于$head$。

由于$s_i$随$i$增大而增大，那么$calc(q_{head},q_{head+1})$随$head$增大而增大，才符合$head$为最优解，因此斜率是不断递增的，要维护一个下凸壳。

## 踢队尾

根据斜率是不断递增的，仅当

$$calc(q_{tail},i)\ge calc(q_{tail-1},q_{tail})$$

斜率才满足不断递增。

故当

$$calc(q_{tail},i)\le calc(q_{tail-1},q_{tail})$$

删去队尾。

## AC code
```cpp
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<cstdlib>
#include<cmath>
#include<cstring>
#define ll long long 
#define gc getchar()
using namespace std;
const int N=1e5+10;
inline void qr(ll &x)
{
	x=0;int f=1;char c=gc;
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=gc;}
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=gc;}
	x*=f;
}
inline void qw(ll x)
{
	if(x<0)x=-x,putchar('-');
	if(x/10)qw(x/10);
	putchar(x%10+48);
}
ll f[N],g[N],s[N];
int q[N],l,r,pre[N][210];
inline double calc(int j,int k)
{
	if(s[k]==s[j]) return -1e18;
	return (double)(g[j]-g[k]-s[j]*s[j]+s[k]*s[k])/(s[k]-s[j]);
}
int main()
{
	int n,k;scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)
	{	
		qr(s[i]);s[i]+=s[i-1];
	}
	int tot=0;
	for(int i=1;i<=k;i++)
	{
		l=1;r=1;q[1]=0;memcpy(g,f,sizeof(g));
		for(int j=1;j<=n;j++)
		{
			while(l<r&&calc(q[l],q[l+1])<=(double)s[j])++l;
			f[j]=g[q[l]]+s[q[l]]*(s[j]-s[q[l]]);
			pre[j][i]=q[l];
			while(l<r&&calc(j,q[r])<=calc(q[r-1],q[r]))--r;
			q[++r]=j;
		}
	}
	qw(f[n]);puts("");
	int j=n,i=k;
	while(pre[j][i])printf("%d ",pre[j][i]),j=pre[j][i],--i;
	return 0;
}
```

---

## 作者：foreverlasting (赞：2)

我怀疑我蠢爆了。

估计也就只有我这种蒟蒻都已经发现了斜率优化的式子，然后RE好几遍才发现应该用滚动数组。

于是就开始切这道题了。

首先是dp式。

这题的dp式应该还是比较好想到的，首先会轻松发现切的顺序与最终值无关，所以得出最终值只与切的位置有关。

（稍微解释一下为什么与切的顺序无关，比如x1,x2,x3这个序列，只有两种切法，第一种是(x1+x2)*x3+x1*x2,第二种是(x2+x3)*x1+x2*x3，拆掉后就是一样的。）

既然只有切的位置有关，那么dp[i][j]也就能表示成前j个数切i刀所得的值。于是dp式就轻而易取地得出了

dp[i][j]=max{dp[i-1][k]+sum[k]*(sum[j]-sum[k])}

其中k<j

首先，我们会发现空间上显然能优化。由于第i个阶段只与第i-1个阶段有关，滚动数组走一波就行了。

然后一交代码，就发现了超时4个点。在冥思苦想时，突然就想到斜率优化（主要是看到j应该在一组状态应该要保持不动），按照斜率优化的正常套路，假设k状态比k’状态更优，两式一作差，然后把一样的sum[j]提出来，就发现了

sum[j]>=((sum[k]*sum[k]-dp[k])-(sum[k']*sum[k']-dp[k']))/(sum[k]-sum[k'])

~~接下来就很轻松啦！队列维护一下斜率，就轻松AC了。~~（不知道斜率优化的请看https://www.luogu.org/blog/league/solution-p3195）

其实这题还没完，这个小细节卡了我半小时：

如果sum[k]=sum[k']，斜率不就没有了吗？

所以呢，
```
#include<bits/stdc++.h>
using namespace std;
#define res register LL
#define LL long long
#define inf 0x3f3f3f3f
inline LL read(){
    LL s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
    return s*w;
}
const LL K=300+10;
const LL N=1e5+10; 
LL dp[2][N],sum[N];
LL way[K][N],q[N];
inline double slope(LL x,LL y,LL l){
	if(sum[x]==sum[y])return -1e18;
	return ((sum[x]*sum[x]-dp[l&1^1][x])-(sum[y]*sum[y]-dp[l&1^1][y]))/(1.0*(sum[x]-sum[y]));
}
int main(){ 
	LL n=read(),k=read();
	for(res i=1;i<=n;i++)
		sum[i]=sum[i-1]+read();
	for(res i=1;i<=k;i++){
		LL head=0,tail=0;
		for(res j=1;j<=n;j++){
		while(head<tail&&slope(q[head],q[head+1],i)<=sum[j])head++;
        LL t=q[head];
        dp[i&1][j]=dp[i&1^1][q[head]]+sum[q[head]]*(sum[j]-sum[q[head]]);
        way[i][j]=q[head];
        while(head<tail&&slope(q[tail],j,i)<=slope(q[tail-1],q[tail],i))tail--;
        q[++tail]=j;
        }
	}
    printf("%lld\n",dp[k&1][n]);
    LL nn=n;
    for(res i=k;i>=1;i--){
    	nn=way[i][nn];
        printf("%lld ",nn);
    }
	return 0;
}
```

---

## 作者：ljk123 (赞：1)

# 序列分割题解
看上去是区间$DP$题，实则不然：

毕竟区间$DP$ $O(n^3)$的复杂度难以优化，

那么，我们是不是可以想到，

每一块的贡献是否与切割顺序无关？

证明一下：

假设区间$[l_{1},r_{3}]$,被分割为$[l_{1},r_{1}],[l_{2},r_{2}],[l_{3},r_{3}]$，

我们算一算$[l_{1},r_{1}]$的贡献,

先分割$r_{1},l_{2}$，再分割$r_{2},l_{3}$,只有一次贡献,
为:
$(sum[r_{1}]-sum[l_{1}-1])*(sum[r_{3}]-sum[r_{1}])$

先分割$r_{2},l_{3}$，再分割$r_{1},l_{2}$,有两次贡献,为:$(sum[r_{1}]-sum[l_{1}-1])*[(sum[r_{3}]-sum[r_{2}])+(sum[r_{2}]-sum[r_{1}])]=(sum[r_{1}]-sum[l_{1}-1])*(sum[r_{3}]-sum[r_{1}])$

也可以感性理解一下，

每种情况都可视为将$[l,r]$后面的$[r+1,n]$从右至左分成k段,

其贡献为:
$(sum[r]-sum[l-1])*\sum_{i=1}^{k}(sum[r_{i}]-sum[r_{i-1}])=(sum[r]-sum[l-1])*(sum[n]-sum[r])$

我们就可以用费用前移算出贡献了。

所以,暴力线性DP方程为：$f[i][j]=f[i-1][k]+(sum[j]-sum[k])*(sum[n]-sum[j])$

拆括号,移项:
$f[i-1][k]=sum[k]*(sum[n]-sum[j])+f[i][j]-(sum[n]-sum[j])*sum[j]$

$\bullet y=f[i-1][k]$

$\bullet k=sum[n]-sum[j]$

$\bullet x=sum[k]$

$\bullet b=f[i][j]-(sum[n]-sum[j])*sum[j]$

由于k递减但大于0,x递增,求最大值,我们可以维护这样的凸壳：

![解释](https://img2018.cnblogs.com/blog/1655789/201908/1655789-20190822192547390-21439279.png)
接下来就是斜率优化的板子了。
代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=100006,K=206;
int o=1,n,k,head=1,tail=1,pre[K][N];
ll t,f[K][N],sum[N];
struct point{ll x,y; int p;}tmp,q[N];
bool check(point u,point v,int z){return v.y-u.y>=(sum[n]-sum[z])*(v.x-u.x);}
bool check2(point u,point v,point z){return (v.y-u.y)*(z.x-v.x)<=(z.y-v.y)*(v.x-u.x);}
inline int read(){
   int T=0,F=1; char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-') F=-1; ch=getchar();}
   while(ch>='0'&&ch<='9') T=(T<<3)+(T<<1)+(ch-48),ch=getchar();
   return F*T;
}
void dfs(int u,int v){
     if(!u) return;
     dfs(u-1,pre[u][v]);
     if(v!=n) printf("%d ",v);
}
int main(){
   n=read(),k=read(),++k;
   for(int i=1;i<=n;++i) t=read(),sum[i]=sum[i-1]+t;
   for(int j=1;j<=k;++j){
       q[1].x=q[1].y=q[1].p=0,head=tail=1;
       for(int i=1;i<=n;++i){
           while(head<tail&&check(q[head],q[head+1],i)) ++head;
           pre[j][i]=q[head].p,f[j][i]=q[head].y+(sum[n]-sum[i])*(sum[i]-q[head].x),tmp.x=sum[i],tmp.y=f[j-1][i],tmp.p=i;
           while(head<tail&&check2(q[tail-1],q[tail],tmp)) --tail;
           q[++tail]=tmp;
      }
   }
   printf("%lld\n",f[k][n]);
   dfs(k,n);
   return 0;
} 
```

---

## 作者：1saunoya (赞：1)

[$myblog$](https://www.cnblogs.com/Isaunoya/p/11658409.html)


毒瘤题……少了一个判断检查了$40min$

看到题目 首先有个 $O(n^2k)$ 的 DP 做法

就是

设 $sum(x)$ = $\sum_{i=1}^{x}a_i$ 

 $f_{i,j}$=$max${$f_{i-1,k} + sum(k) * (sum(j) - sum(k))$}

这样直接预处理出$sum_x=\sum_{i=1}^{x}$ 即前缀和 然后 $O(n^2k)$ 就可以做出来了

考虑斜率优化

假设 $x$ 优于 $y$

那么 

$f_{i-1,x}+sum_x*(sum_j-sum_x) > f_{i-1.y}+sum_y*(sum_j-sum_y)$

展开得到

$f_{i-1,x}+sum_x*sum_j-sum_x^2 > f_{i-1,y} + sum_y*sum_j - sum_y^2$

移项得到

$(sum_x-sum_y)*sum_j > f_{i-1,y}-sum_y^2-f_{i-1,x}+sum_x^2$

化简得到

$sum_j > \frac{f_{i-1,y}-sum_y^2-f_{i-1,x}+sum_x^2}{sum_x-sum_y}$

设 $S(x)=sum_x^2-f_{i-1,x}$

$sum_j>\frac{S(x)-S(y)}{sum_x-sum_y}$

愉快的开始斜率优化…

但是需要特判$sum_x==sum_y$的情况

```cpp
// Isaunoya
#include<bits/stdc++.h>
using namespace std ;
#define int long long
#define fi first
#define se second
#define pb push_back
inline int read() {
  register int x = 0 , f = 1 ;
  register char c = getchar() ;
  for( ; ! isdigit(c) ; c = getchar()) if(c == '-') f = -1 ;
  for( ; isdigit(c) ; c = getchar()) x = (x << 1) + (x << 3) + (c & 15) ;
  return x * f ;
}
template < typename T > inline bool cmax(T & x , T y) {
	return x < y ? (x = y) , 1 : 0 ;
}
template < typename T > inline bool cmin(T & x , T y) {
	return x > y ? (x = y) , 1 : 0 ;
}
inline int QP(int x , int y , int Mod){ int ans = 1 ;
  for( ; y ; y >>= 1 , x = (x * x) % Mod)
    if(y & 1) ans = (ans * x) % Mod ;
  return ans ;
}

int n , k ;
const int N = 1e5 + 10 ;
const int M = 205 ;
int sum[N] , pre[M][N] ;
int q[N] ;
int f[N] , g[N] ;
inline int S(int x) {
  return (sum[x] * sum[x] - g[x]) ;
}
inline double slope(int x , int y) {
  if(sum[x] == sum[y]) return -1e18 ;
  return 1.0 * (S(x) - S(y)) / (sum[x] - sum[y]) ;
}
signed main() {
  n = read() ; k = read() ;
  for(register int i = 1 ; i <= n ; i ++) sum[i] = sum[i - 1] + read() ;
  memset(f , 0 , sizeof(f)) ; memset(g , 0 , sizeof(g)) ;
  for(register int i = 1 ; i <= k ; i ++) {
    int h = 1 , t = 0 ;
    q[++ t] = 0 ;
    for(register int j = 1 ; j <= n ; j ++) {
      while(h < t && slope(q[h] , q[h + 1]) <= sum[j]) ++ h ;
      f[j] = g[q[h]] + sum[q[h]] * (sum[j] - sum[q[h]]) ;
      pre[i][j] = q[h] ;
      while(h < t && slope(q[t - 1] , q[t]) >= slope(q[t] , j)) -- t ;
      q[++ t] = j ;
    }
    memcpy(g , f , sizeof(f)) ;
  } printf("%lld\n" , f[n]) ;
  for(register int i = n ; k ; -- k)
    printf("%lld " , i = pre[k][i]) ;
	return 0 ;
}

```

---

## 作者：bzy369258147 (赞：1)

另一种斜率优化(式子不太一样)

显然，我是蒟蒻，所以不知道怎么记贡献，所以我选择每一次**直接记录答案**

对于每一次从j转移到i增加的答案为 $(sum[n] - sum[i])(sum[i] - sum[j])$

这十分的直观(按题意模拟),所以我不想解释。

于是可以斜率优化：

$-\frac{dp[j]-dp[k]}{sump[j] - sump[k]}>=sum[i] - sum[n]$

由于推式子的过程只用到了初一数学，我也不再赘述

然后就可以套路DP了,

由于蒟蒻我不会滚动数组等骚操作，于是就有了一下这些很烂的代码，

```cpp
#include<bits/stdc++.h>
using namespace std;

long long line[100005];
long long dp  [100005][205];

int j;

long double Y(int now){ return dp[now][j];}
long double X(int now){ return line[now] ;}
long double K(int x,int y){ if(X(x) == X(y))return -1e18;return - ( Y(x) - Y(y) ) * 1.0 / ( X(x) - X(y) ) ;}

int head[305];
int tail[305];
int Q  [305][100005];
int pre[100005][305];
int main(){
	int n,k;cin >> n >> k;
	for(int i = 1;i <= n;i ++)cin >> line[i],line[i] += line[i - 1];
	for(int i = 1;i <= n;i ++){
		for(j = 0;j < k;j ++){
			while( head[j] < tail[j] and K( Q[j][head[j]],Q[j][head[j] + 1]) <= line[i] - line[n] )head[j] ++;
			int ft = Q[j][head[j]];
			dp [i][j + 1] = dp[ft][j] + (line[n] - line[i])*(line[i] - line[ft]);
			pre[i][j + 1] = ft;
			while( head[j] < tail[j] and K( Q[j][tail[j]-1],Q[j][tail[j]]) >= K( Q[j][tail[j]],i ) )tail[j] --;
			Q[j][++tail[j]] = i;
		}
	}
	long long ans = 0,t = 0;
	for(int i = 1;i <= n;i ++){if( dp[i][k] > ans )ans = dp[i][k],t = i; }
	cout << ans << "\n";
	stack<int>A;
	for(int i = k;i >= 1;i --){
		A.push(t);
		t = pre[t][i];
	}
	while(!A.empty())cout << A.top() << " ",A.pop();
	return 0;
}
```

###Tips:
 - 记得开long long
 - 记得开long double
 - ~~记得开$O_2$~~


---

## 作者：Christopher_Yan (赞：1)

[博客](http://39.106.169.220)食用效果更佳。
#### 题目描述
你正在玩一个关于长度为 $n$ 的非负整数序列的游戏。这个游戏中你需要把序列分成$k+1$ 个非空的块。为了得到 $k + 1$ 块，你需要重复下面的操作 $k$ 次：
选择一个有超过一个元素的块（初始时你只有一块，即整个序列）
选择两个相邻元素把这个块从中间分开，得到两个非空的块。
每次操作后你将获得那两个新产生的块的元素和的乘积的分数。你想要最大化最后的总得分。

#### 解题思路
首先我们要发现的一点就是选好断点后，断开的顺序是不影响答案的。
于是暴力转移方程比较简单：
`dp[i][k]=min{dp[j][k-1]+sum[j]*(sum[i]-sum[j])}`
写下转移方程就会发现这是一道比较模板的斜率优化。

#### AC代码
```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cctype>
using namespace std;
#define int long long
typedef long long llt;

const int N=2e5+10;
int n,k,head,tail,a[N],Q[N],pre[N][300];
llt s[N],f[N],g[N];

inline void read(int&x){
	int k=1;x=0;char c=getchar();
	while(!isdigit(c)) if(c=='-')c=getchar(),k=-1;else c=getchar();
	while(isdigit(c)) x=(x<<3)+(x<<1)+(c^48),c=getchar();x*=k;
}
inline long double Slope(int a,int b){
	if(s[a]==s[b]) return -1e18;
	return 1.0*((g[a]-s[a]*s[a])-(g[b]-s[b]*s[b]))/(s[b]-s[a]);
}
signed main(){
	read(n),read(k);
	for(int i=1;i<=n;++i) read(a[i]),s[i]=s[i-1]+a[i];
	for(int j=1;j<=k;++j){
		head=1,tail=1,Q[1]=0;
		for(int i=1;i<=n;++i){
			while(head<tail&&Slope(Q[head],Q[head+1])<=s[i]) ++head;
			f[i]=g[Q[head]]+s[Q[head]]*(s[i]-s[Q[head]]);
			while(head<tail&&Slope(Q[tail-1],Q[tail])>=Slope(Q[tail],i)) --tail;
			pre[i][j]=Q[head],Q[++tail]=i;
		}
		memcpy(g,f,sizeof(f));
	}
	printf("%lld\n",f[n]);
	for(int x=n,i=k;i>=1;--i) 
		x=pre[x][i],printf("%d ",x);
	return 0;
}
```

---

## 作者：_sry (赞：0)


其实可以发现我们选择切的顺序可以颠换。

所以我们可以设$dp(i,j)$表示为前$i$个共切$j$的最大得分，然后$dp(i,j)=max(dp(i-1,z)+s[z] \times (s[i]-s[z])),s[i]=\sum_{i=1}^i  a_i$。

然后发现这是个斜率优化的式子，但是斜率只有一项，且为-$dp(i,j)$，所以我们虽然是要去维护上凸壳但其实事实上维护下凸壳。然后就基本斜率优化操作了。
```
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#define int long long
using namespace std;
inline int read(){
    int f=1,ans=0;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){ans=ans*10+c-'0';c=getchar();}
    return f*ans;
}
const int N=100011;
const int K=211;
int f[K][N],n,k,s[N],last[K][N],que[N],dp[N],g[N],X[N],Y[N];
signed main(){
//    freopen("10.in","r",stdin);
    n=read(),k=read();
    for(int i=1;i<=n;i++) s[i]=s[i-1]+read();
    for(int p=1;p<=k;p++){
        int l,r;l=r=1;que[1]=0;
        for(int i=1;i<=n;i++) g[i]=f[p-1][i];
        Y[0]=s[0]*s[0]-g[0],X[0]=s[0];
        for(int i=1;i<=n;i++){
            while(l<r&&(Y[que[l+1]]-Y[que[l]])<=s[i]*(X[que[l+1]]-X[que[l]])) l++;
            f[p][i]=f[p-1][que[l]]+s[que[l]]*(s[i]-s[que[l]]);
            last[p][i]=que[l];
            X[i]=s[i],Y[i]=s[i]*s[i]-g[i];
            while(l<r&&(Y[que[r]]-Y[que[r-1]])*(X[i]-X[que[r]])>=(Y[i]-Y[que[r]])*(X[que[r]]-X[que[r-1]])) r--;
            que[++r]=i;
        }
    }
    int r=n;
    printf("%lld\n",f[k][n]); 
    for(int i=k;i>=1;i--){
        printf("%d ",last[i][r]);
        r=last[i][r];
    }
}
```

---

## 作者：cold_cold (赞：0)

 [安利一波博客](https://www.cnblogs.com/cold-cold/p/10125401.html)

此题我看到第一眼的想法是

区间DP，复杂度大约O(n^4)

但是我在推样例的时候发现了一个重要的性质

最后的结果只与切的位置有关而与切的顺序无关

将状态设计为f[i][j]表示前i个数，切j刀，第j刀切在i处所最得到的最大的分


由此我们可以推出DP式子：
```cpp 
f[i][k+1]=f[j][k]+sum[j]*(sum[i]-sum[j]);
```

但这样的复杂度仍然不对

看到式子的形状，我们似乎可以采用斜率优化

```cpp
f[j][k]-sum[j]*sum[j]=f[i][k+1]-sum[i]*sum[j];
```

这里我们要注意两个点在同一个横坐标的情况

另外我们只用开一个队列Q

因为虽然转移得到的截距为k+1的，但是点(x,y)都是k的

实现如下：

```cpp
#include <algorithm>
#include <iostream>
#include <cmath>
#include <cstring>
#include <map>
#include <string>
#include <vector>
#include <queue>
#include <stack>
#include <cstdio>
#include <cstdlib>
using namespace std;
typedef long long ll;
inline ll read()
{
    register ll p(1),a(0);register char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
    if(ch=='-') p=-1,ch=getchar();
    while(ch>='0'&&ch<='9') a=a*10+ch-48,ch=getchar();
    return a*p;
}
//f[i][k]=f[j][k-1]+sum[j]*(sum[i]-sum[j]);
//f[j][k-1]-sum[j]*sum[j]=f[i][k]-sum[i]*sum[j];
const ll N=100100,M=210,INF=0x3f3f3f3f;
ll n,kk,f[N][M],to[N][M],sum[N],Q[N],head=0,tail=0;
inline long double getx(int x){return sum[x];}
inline long double gety(int x,int now){return f[x][now]-sum[x]*sum[x];}
inline long double che(int x,int y,int now)
{return getx(y)==getx(x)?-INF:(gety(y,now)-gety(x,now))/(getx(x)-getx(y));}
inline void pri(int xx,int yy){if(xx)pri(to[xx][yy],yy-1),printf("%lld ",xx);}
int main()
{
    freopen("input","r",stdin);
    freopen("output","w",stdout);
    n=read(),kk=read();
    for(register int i=1;i<=n;i++) sum[i]=sum[i-1]+read();
    for(register int k=1;k<=kk;k++,head=tail=0)
        for(register int i=1,j;i<=n;i++)
            {
                while(head<tail&&che(Q[head],Q[head+1],k)<=sum[i]) ++head;
                j=Q[head];f[i][k+1]=f[j][k]+sum[j]*(sum[i]-sum[j]);
                to[i][k+1]=j;
                while(head<tail&&che(Q[tail-1],Q[tail],k)>=che(Q[tail],i,k)) --tail;
                Q[++tail]=i;
            }
    printf("%lld\n",f[n][kk+1]);
    pri(to[n][kk+1],kk);
    return 0;
}
/*

*/

```

---

## 作者：Bosun (赞：0)

这道题其实很简单，毕竟给了你一个友善的样例。。。。。。

我们可以自定义一个划分顺序，对于每个f[i],就是每次先将划去最后几个数（设划分点为p），他们产生的贡献等于(s[i]-s[p])*s[p],就可以转移到上一步的j了

具体来说，f[i][k]=max(f[j][k-1]+(s[i]-s[j])*s[j])

等等，这里有个k怎么办呀。定睛一看，k只与k-1有关，可以缩掉一维。

再定睛一看，这题k非常小，于是可以暴力枚举k，然后将上一次的f[i]记为g[i].

经过一堆~~繁琐~~的化简之后，柿子变成了这个东西：f[i]-s[i]s[j]=g[j]-s[j]^2

将f[i]当做截距，欲使截距最大，那么斜率递减，维护上凸壳，即将-s[i]当做斜率

完结撒花!（注意一下斜率不存在的时候，slope函数返回-1e8）

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100001;
typedef long long ll;
int n,k;
ll f[N],s[N],g[N];
inline ll X(int u){
	return s[u];
}
inline ll Y(int u){
	return g[u]-s[u]*s[u];
}
inline double slope(int u,int v){
	if(s[u]==s[v])return -1e8;//attention!!!
	return 1.0*((1.0*(Y(u)-Y(v)))/(1.0*(X(u)-X(v))));
}
int q[N],lst[N][201],a[N],cnt;
int main(){
	register int i;
	cin>>n>>k;
	for(i=1;i<=n;++i)scanf("%lld",&s[i]),s[i]+=s[i-1];
	for(int tim=1;tim<=k;++tim){
		int h=1,t=1;
		memset(q,0,sizeof(q));
		for(i=1;i<=n;++i){
			while(h<t&&slope(q[h],q[h+1])>=-s[i])h++;
			f[i]=g[q[h]]+s[q[h]]*(s[i]-s[q[h]]);
			lst[i][tim]=q[h];//记录路径
			while(h<t&&slope(q[t],q[t-1])<=slope(q[t-1],i))t--;
			q[++t]=i;
		}
		for(i=1;i<=n;++i)g[i]=f[i];
	}
	cout<<f[n]<<endl;
	int p=n;
	while(p){
		a[++cnt]=p;
		p=lst[p][k];
		k--;
	}
	for(i=cnt;i>=2;i--)printf("%d ",a[i]);
	return 0;
}
```


---

## 作者：ModestCoder_ (赞：0)

斜率优化

可以证明得分与分割顺序无关（然而我不会）

令$s_i=\sum_{j=1}^{i}a_j$

得到一个很显然的暴力dp

$dp_{i,j}表示到第i个数，分割了j次$

$dp_{i,j}=max(dp_{k,j-1}+s_k(s_i-s_k))$

上套路

存在两个决策$x,y(x<y)$，若y更优，必然满足

$dp_{x,j-1}+s_x(s_i-s_x)<=dp_{y,j-1}+s_y(s_i-s_y)$

整理得

$\frac{dp_{x,j-1}-s_x^2-dp_{y.j-1}+s_y^2}{s_y-s_x}<=s_i$

单调队列维护斜率递增的下凸壳即可

空间上还存在着一些问题，发现第二维可以滚动

至于打印方案，只能记录一个二维的pre数组了

有一个坑点就是此题的$s_i$并不是递增的，而是不下降的，所以可能出现分母为0的情况，此时返回-oo

Code：

```cpp
#include <bits/stdc++.h>
#define maxn 100010
#define LL long long
using namespace std;
int n, m, Pre[maxn][210], q[maxn];
LL s[maxn], dp[maxn][2];

inline int read(){
	int s = 0, w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
	return s * w;
}

double slope(int opt, int x, int y){ return s[x] == s[y] ? -1e18 : 1.0 * (dp[x][opt] - s[x] * s[x] - dp[y][opt] + s[y] * s[y]) / (s[y] - s[x]); }

int main(){
	n = read(), m = read();
	for (int i = 1; i <= n; ++i) s[i] = read() + s[i - 1];
	for (int j = 1; j <= m; ++j){
		int now = j & 1, pre = now ^ 1, h = 0, t = 0;
		for (int i = 1; i <= n; ++i){
			while (h < t && slope(pre, q[h], q[h + 1]) <= s[i]) ++h;
			dp[i][now] = dp[q[h]][pre] + s[q[h]] * (s[i] - s[q[h]]);
			Pre[i][j] = q[h];
			while (h < t && slope(pre, q[t - 1], q[t]) >= slope(pre, q[t], i)) --t;
			q[++t] = i;
		}
	}
	printf("%lld\n", dp[n][m & 1]);
	while (m) printf("%d ", Pre[n][m]), n = Pre[n][m], --m;
	return 0;
}
```


---

## 作者：FlyInTheSky (赞：0)

 [$$ \Large \texttt{My Blog} $$](http://blog.flyinthesky.win/bzoj3675/)

------------



引理：
> 最终答案和分割顺序无关。

证明：若分了$3$块，设为$a_1,a_2,a_3$

则
$$a_1 a_2 + (a_1+a_2)a_3 = a_2 a_3 + (a_2 + a_3)a_1$$
所以两者等价，并且容易扩展到更多块的情况。并且答案是$a$两两相乘的和(或者是$a_1 + (a_1+a_2)a_3 + (a_1+a_2+a_3)a_4 +\dots + (a_1+a_2+ \dots + a_{k-1})a_k$)

那么设$dp(k,i)$为前$i$个分了$k$次的最大值。根据上面的式子，可以有DP方程
$$dp(k,i)=\max\{dp(k-1, j)+s(j) \cdot (s(i) - s(j))\}$$
其中$s(i)$为前缀和。
显然可以斜率优化。


```c++
#include<cstdio> 
#include<cstring>
#include<algorithm>
#include<iostream>
#include<cmath>
#include<map>
#include<vector>
#define ms(i, j) memset(i, j, sizeof i)
#define LL long long
#define db long double
#define fir first
#define sec second
#define mp make_pair
using namespace std;

namespace flyinthesky {

	const LL MAXN = 100000 + 5;
	
	LL n, K, a[MAXN], s[MAXN], dp[205][MAXN], pre[205][MAXN];
	LL q[MAXN], l, r;
	vector<LL > vec;
	
	LL getx(LL j) {return s[j];}
	LL gety(LL j, LL k) {return dp[k - 1][j] - s[j] * s[j];}
	db getsl(LL a, LL b, LL k) {
		if (getx(a) == getx(b)) return -1e18;
		return 1.0 * (gety(a, k) - gety(b, k)) / (getx(a) - getx(b));
	}
	
    void clean() {
    	ms(pre, 0), ms(s, 0), ms(dp, 0);
	}
    int solve() {

    	clean();
    	cin >> n >> K;
    	
    	for (LL i = 1; i <= n; ++i) scanf("%lld", &a[i]), s[i] = a[i] + s[i - 1];

		for (LL k = 1; k <= K; ++k) {
			l = 1, r = 1, q[1] = 0;
			for (LL i = 1; i <= n; ++i) {
				while (l < r && getsl(q[l], q[l + 1], k) >= -s[i]) ++l;
				dp[k][i] = dp[k - 1][q[l]] + s[q[l]] * (s[i] - s[q[l]]);
				pre[k][i] = q[l];
				while (l < r && getsl(q[r - 1], q[r], k) <= getsl(q[r], i, k)) --r;
				q[++r] = i;
			}
		}
		
		printf("%lld\n", dp[K][n]);
		LL cur = n, tms = K;
		while (cur != 0) {
			vec.push_back(cur);
			cur = pre[tms][cur], --tms;
		}
		sort(vec.begin(), vec.end());
		for (LL i = 0; i < (LL)vec.size() - 1; ++i) printf("%lld ", vec[i]);

        return 0;
    }
}
int main() {
    flyinthesky::solve();
    return 0;
}
```

---


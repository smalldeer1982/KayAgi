# 小清新数学题

## 题目背景

**本题时限 3s**

友情提示：https://www.luogu.com.cn/problem/P3601


## 题目描述

题目还是简单一点好。


我们定义莫比乌斯函数 $\mu(x)$，如果 $x$ 的每个素因子只出现一次，有 $p$ 个素因子，那么 $\mu(x)=(-1)^p$，否则 $\mu(x)=0$。


这题要求你求出 $\sum_{i=l}^r \mu(i)$。


## 说明/提示

对于 $10\%$ 的数据，$l,r \leq 10^6$。

对于 $30\%$ 的数据，$l,r \leq 10^{12}$。

对于 $100\%$ 的数据，$1 \leq l \leq r \leq 10^{18}$，$r-l \leq 10^5$。


## 样例 #1

### 输入

```
1 233```

### 输出

```
-1```

## 样例 #2

### 输入

```
99999999999899999 99999999999999999```

### 输出

```
421```

# 题解

## 作者：qwaszx (赞：5)

这题好毒瘤啊...果然是zzq...

首先要去切了[这道题](https://www.luogu.org/problemnew/show/P3601)来学会区间筛积性函数

然后你发现这题$r\leq 10^{18}$....处理$\sqrt{r}$个素数是行不通的.

但是我们注意一点，$\mu$函数可以认为是只和素数的个数有关的，所以我们只拿$10^6$个数去筛.假设$i$已经除去了所有$1e6$以下的质因子，那么$i$只有三种情况:

$\begin{cases}i=pq\\i=p\\i=p^2\end{cases}(p,q\in prime,p\neq q)$

对于第一种情况，多了两个质因子，$\mu$不变；对于第二种情况$\mu$取负；对于第三种情况$\mu=0$.

如何去判断呢?$i=p^2$只需要判断$\left\lfloor\sqrt{i}\right\rfloor^2=i$；$i=p$需要使用$Miller-Rabin$素性测试；剩下的就是$i=pq$的情况了.

$Miller-Rabin$的时候因为模数是$long\ long$的所以需要特殊处理乘法

首先龟速乘根本跑不动(快速幂+龟速乘是两个$\log$的)，所以

```cpp
long long mul(long long a,long long b,long long m)
{
	return (a*b-(long long)((long double)a/m*b)*m+m)%m;
}
```

原理baidu吧QAQ

这里因为数据水而使用了简化版的$Miller-Rabin$(只测$2$和$3$，不二次探测)

注释中有正常的$Miller-Rabin$

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
long long fac[2000000],l,r;
int mu[2000000],prime[2000000],p[2000005],cnt;
long long sqr(long long x){return x*x;}
void make(int n)//打表1e6的素数
{
	p[0]=p[1]=1;
	for(int i=2;i<=n;i++)
	{
		if(!p[i])prime[++cnt]=i;
		for(int j=1;j<=cnt&&i*prime[j]<=n;j++)
		{
			p[i*prime[j]]=1;
			if(i%prime[j]==0)break;
		}
	}
}
long long mul(long long a,long long b,long long m)
{
	return (a*b-(long long)((long double)a/m*b)*m+m)%m;
}
long long qpower(long long a,long long b,long long m)
{
	long long ans=1;
	for(;b;b>>=1,a=mul(a,a,m))if(b&1)ans=mul(ans,a,m);
	return ans;
}
/*
bool Miller_Rabin(long long x,long long p)//真的MillerRabin，底下要选取12个素数 
{
	long long pd=qpower(p,x-1,x),s=x^1;
	while(pd==1&&!(s&1))s>>=1,pd=qpower(p,s,x);
	return pd==1||pd==(x^1);
}
*/
bool Miller_Rabin(long long x,long long p){return qpower(p,x-1,x)==1;}
bool judge(long long n)
{
	for(int i=1;i<=2;i++)if(!Miller_Rabin(n,prime[i]))return 0;
	return 1;
}
int main()
{
	scanf("%lld%lld",&l,&r);
	for(long long i=l;i<=r;i++)fac[i-l]=i,mu[i-l]=1;
	make(1000000);
	for(int i=1;i<=cnt&&prime[i]<=r;i++)
	{
		int t=prime[i];
		for(long long j=((l-1)/t+1)*t;j<=r;j+=t)
		{
			int k=0;
			while(fac[j-l]%t==0)++k,fac[j-l]/=t;
			if(k>1)mu[j-l]=0;else mu[j-l]=-mu[j-l];//区间筛
		}
	}
	long long ans=0;
	for(long long i=l;i<=r;i++)
	{	
		if(fac[i-l]!=1)
		{
			long long t=fac[i-l];
			if(sqr((long long)sqrt(t))==t)mu[i-l]=0;
			else if(judge(t))mu[i-l]=-mu[i-l];//多一个质因子
		}
		ans+=mu[i-l];
	}
	cout<<ans<<endl;
}
```

同理大概也可以筛$\sigma$...毒瘤...

---

## 作者：dtcxzyw (赞：4)

居然有人来问我这道题怎么做。。。才发现我切了9个月还是没人写题解。。。那我写一篇吧。

------------

看到这是一道区间求和问题，我的本能反应是考虑求莫比乌斯函数前缀和之差。但是令人感到奇怪的是$r-l\leq 10^5$，可以想到直接暴力计算$x\in[l,r]$的$\mu(x)$。

如何计算$\mu(x)$呢？一般使用线性筛预处理前$n$个整数的
$\mu(x)$值，同理可以考虑先线性筛出一些质数，然后对区间
进行埃拉托斯特尼筛法筛出答案，最后前缀和即可。

至于如何筛出答案。。。枚举每个质数$p$的倍数，然后按照定义计算$mu[x]$的值。这部分我就不细讲了，具体实现看文末代码。

常规埃氏筛法需要筛出$\sqrt{r}$内的所有质数，但是最大规模为$10^9$的线性筛所需的时间仍然是不可令人接受的。我们考虑减小线性筛的规模到$k$会发生什么事：若我们同时维护每个整数去除$k$以内的素数后剩余的因子$fac[x]$，可以发现有3种情况：

- $fac[x]=1$，表示$x$已经被筛完了，此时的$mu[x]$就是答案。

- $fac[x]=\displaystyle \prod_{i=1}^c{{p_i}^{q_i}}$，这部分不好处理。但是我们可以通过调整$k$的大小来限制子情况数。因为$r\leq 10^{18}$，若令$k=10^6$，则可以发现该情况仅剩三个子情况：


1. $fac[x]=p$，$mu[x]$取反；

2. $fac[x]=pq$，$mu[x]$不变；

3. $fac[x]=p^2$，$mu[x]$置0；

证明：因为筛法保证了此时的$fac[x]$为多个$p>10^6$之积，且$fac[x]\leq 10^{18}$，所以$fac[x]$最多为两个素数之积。

首先使用$sqrt$区分出情况3（如果怕有精度误差可以二分），然后使用素性判断算法区分情况1与情况2（这里的数据比较水，我当时偷懒只用了费马定理+__int128，最好使用Miller-Rabin素性判断算法）。

------------

代码如下：

对于规模较小的数据可以令线性筛规模为$\sqrt{r}$，
减少不必要的计算。

```cpp
#include <cstdio>
#include <cmath>
#include <cstring>
#include <algorithm>
typedef long long Int64;
const Int64 size=100100,psiz=1000100;
Int64 bsiz,prime[psiz/10],mu[size],fac[size],pcnt=0;
bool flag[psiz]={};
void pre(Int64 siz){
    bsiz=std::min(psiz-1,static_cast<Int64>(sqrt(siz)));
    for(Int64 i=2;i<=bsiz;++i){
        if(!flag[i])prime[++pcnt]=i;
        for(Int64 j=1;j<=pcnt && prime[j]*i<=bsiz;++j){
            flag[i*prime[j]]=true;
            if(i%prime[j]==0)break;
        }
    }
}
typedef __int128 Int128;
Int64 powm(Int128 a,Int64 k,Int128 mod){
    Int128 res=1;
    while(k){
        if(k&1)res=res*a%mod;
        k>>=1,a=a*a%mod;
    }
    return res;
}
bool isPrime(Int64 x){
    return powm(2,x-1,x)==1 && powm(3,x-1,x)==1;
}
int main(){
    Int64 l,r;
    scanf("%lld%lld",&l,&r);
    pre(r);
    Int64 len=r-l;
    for(int i=0;i<=len;++i)
    	mu[i]=1,fac[i]=i+l;
    for(int i=1;i<=pcnt;++i){
    	Int64 x=l/prime[i]*prime[i];
    	if(x==l)x-=prime[i];
    	while((x+=prime[i])<=r){
    		fac[x-l]/=prime[i];
    		mu[x-l]=-mu[x-l];
    		while(fac[x-l]%prime[i]==0)
    			fac[x-l]/=prime[i],mu[x-l]=0;
    	}
    }
    for(int i=0;i<=len;++i)
    	if(fac[i]!=1){
    		Int64 sq=sqrt(fac[i]);
    		if(sq*sq==fac[i])mu[i]=0;
    		else if(isPrime(fac[i]))mu[i]=-mu[i];
    	}
    Int64 ans=0;
    for(int i=0;i<=len;++i)
        ans+=mu[i];
    printf("%lld\n",ans);
    return 0;
}
```


---

## 作者：Leasier (赞：2)

~~虽然我平常都不喜欢在题解里喷出题人，但我还是想说：zzq 大毒瘤！~~

本题解省略部分分做法以及代码。

前置芝士：[Miller-Rabin 算法](https://blog.csdn.net/forever_dreams/article/details/82314237)

这道题卡掉了~~我最爱的~~ Pollard-Rho 算法。

由于莫比乌斯函数的特殊性，考虑预处理出 $10^6$ 以内的质数，用其筛除 $[l, r]$ 内的数。对于每一个余下的质因数之积 $x$，有以下 $4$ 种情况：

1. $x = 1$，此时 $\mu(x) = 1$；
2. $x$ 为质数，此时 $\mu(x) = -1$；
3. $x$ 为两个互异质数之积，此时 $\mu(x) = 1$；
4. $x$ 为非 $1$ 的完全平方数，此时 $\mu(x) = 0$。

特判 $x = 1$，然后用 sqrt 函数判断 $x$ 是否为完全平方数，最后用 Miller-Rabin 判断 $x$ 是否为质数即可。时间复杂度为 $O((r - l) \log^2 r + N)$。

~~顺便说一句：本题数据过弱，Miller-Rabin 只选取 $2$ 个底数也可 AC~~

代码：
```cpp
#include <stdio.h>
#include <math.h>

typedef long long ll;
typedef __int128 lll;

const int N = 2, M = 1e6 + 7;
int test_prime[N + 7] = {0, 2, 3}, prime[M], mu_list[M];
ll last_factor[M];
bool p[M];

inline int init1(){
	int cnt = 0;
	p[0] = p[1] = true;
	for (register int i = 2; i < M; i++){
		if (!p[i]) prime[++cnt] = i;
		for (register int j = 1; j <= cnt && i * prime[j] < M; j++){
			p[i * prime[j]] = true;
			if (i % prime[j] == 0) break;
		}
	}
	return cnt;
}

inline ll max(ll a, ll b){
	return a > b ? a : b;
}

inline void init2(ll l, ll r, int cnt){
	ll t = r - l;
	for (register ll i = 0; i <= t; i++){
		last_factor[i] = i + l;
		mu_list[i] = 1;
	}
	for (register int i = 1; i <= cnt && (ll)prime[i] * prime[i] <= r; i++){
		for (register ll j = (ll)max((l + prime[i] - 1) / prime[i], 2) * prime[i]; j <= r; j += prime[i]){
			int k = 0;
			ll x = j - l;
			while (last_factor[x] % prime[i] == 0){
				last_factor[x] /= prime[i];
				k++;
			}
			if (k == 1){
				mu_list[x] = -mu_list[x];
			} else {
				mu_list[x] = 0;
			}
		}
	}
}

inline ll quick_pow(ll x, ll p, ll mod){
	ll ans = 1;
	while (p){
		if (p & 1) ans = (lll)ans * x % mod;
		x = (lll)x * x % mod;
		p >>= 1;
	}
	return ans;
}

inline bool miller_rabin(ll n, ll k){
	ll nd = n - 1, m = nd;
	while (m){
		ll x = quick_pow(k, m, n);
		if (x != 1 && x != nd) return false;
		if ((m & 1) == 1 || x == nd) return true;
		m >>= 1;
	}
	return true;
}

inline bool is_prime(ll n){
	if (n < 2) return false;
	for (register int i = 1; i <= N; i++){
		if (n == test_prime[i]) return true;
		if (!miller_rabin(n, test_prime[i])) return false;
	}
	return true;
}

inline ll sqr(ll n){
	return n * n;
}

inline int mu(ll n){
	if (sqr(sqrt(n)) == n) return n == 1 ? 1 : 0;
	return is_prime(n) ? -1 : 1;
}

int main(){
	int ans = 0;
	ll l, r, t;
	scanf("%lld %lld", &l, &r);
	t = r - l;
	init2(l, r, init1());
	for (register ll i = 0; i <= t; i++){
		ans += mu(last_factor[i]) * mu_list[i];
	}
	printf("%d", ans);
	return 0;
}
```

---

## 作者：墨舞灵纯 (赞：2)

>前言：这题题解太少了叭……？窝码风好康窝来写题解！

观察数据范围发现虽然$l,r$非常大，但是$r-l$很小，所以考虑暴力算$r-l$这一段的。

考虑$\mu(x)$的最基本定义式：

$$\mu(x)=\left\{\begin{aligned} 1 \qquad \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ x=1 \\ (-1)^k \qquad  x=p_1p_2\dots p_k \\ 0 \qquad \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ else  \end{aligned}\right.$$

也就是说$\mu(x)$只和因子个数有关。

因为$l,r\leq 10^{18}$，$\sqrt n$筛因子不太行，而如果写pollard_rho那么要对每个数都做一次，复杂度也无法承受。所以考虑预处理$n^\frac{1}{3}$以内的因子，因为$n$除完$n^\frac{1}{3}$内的因子之后最多只会剩下两个因子。考虑筛出$10^6$以内的质数，然后去除，除的时候顺便筛$\mu$。发现剩下的只有这三种情况：
$$
left(x)=\left\{\begin{aligned}p^2 \qquad \ \ \ \ \ \ \ \   \Rightarrow\mu(x)=0 \\   pp'\  \qquad  
\Rightarrow\mu(x)=\mu(x)\\ p  \qquad \  \Rightarrow\mu(x) =-\mu(x)\\\end{aligned}\right.
$$

为什么只会有这三种情况呢？因为$x$必然只有$\gt 10^6$的因子，而$x\leq 10^{18} $ ，所以最多只有两个因子。

判断$x=p^2$直接sqrt，判断$x \in prime$直接用Millar_Rabin，这两个都判断过了第二种情况就是剩下的。

所以只要筛$10^6$以内的质数，然后暴力枚举$x\in [l,r]$判一下再统计就ok了。


$\color{#66bbf4}{Code : }$

```cpp
#include <cstdio>
#include <cmath>
#define it register int
#define ct const int
#define il inline
using namespace std;
typedef long long ll;
#define rll register ll
#define cll const ll
const int N = 1000005;
int p[N], cnt, mu[N], ans;
bool isp[N];
ll l, r, lft[N];
namespace MR {
	const int p[] = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47 };
	il ll mul(cll a, cll b, cll p) {return (a * b - (unsigned long long)((long double)a / p * b + 1e-7) * p + p) % p;}
	il ll ksm(rll x, rll L, cll p) { rll ans = 1; while (L) L& 1 ? ans = mul(ans, x, p) : 0, x = mul(x, x, p), L >>= 1; return ans; }
	il bool isp(cll n) {
		for (it i = 0; i < 14; ++i) if (!(n % p[i])) return n == p[i];
		rll r = n - 1;it pw = 0;
		while (!(r & 1)) r >>= 1, ++pw;
		for (it i = 0, j; i < 14; ++i) {
			rll x = ksm(p[i], r, n), y;
			for (j = 1; j <= pw && x > 1; ++j) {
				y = mul(x, x, n);
				if (y == 1 && x != n - 1) return 0;
				x = y;
			}
			if (x ! = 1) return 0;
		}
		return 1;
	}
} 
il void Pre() {
    it i, j, x;
    for (i = 2; i < N; ++i) {
        if (!isp[i]) p[++cnt] = i;
        for (j = 1; (x = p[j] * i) < N && j < = cnt; ++j) {
            isp[x] = 1;
            if (!(i % p[j])) break;
        }
    }
}
int main() {
    scanf("%lld%lld", &l, &r), Pre(); it i, x, y;
    for (i = r - l, x = 0; x <= i; ++x) lft[x] = x + l, mu[x] = 1;
    for (i = 1; i <= cnt && p[i] <= r; ++i)
        for (rll j = ((l - 1) / p[i] + 1) * p[i]; j <= r; j += p[i]) {
            x = j - l, y = 0;
            while (!(lft[x] % p[i])) lft[x] /= p[i], ++y;
            mu[x] = (y > 1 ? 0 : -mu[x]);
        }
    for (i = r - l, x = 0; x <= i; ++x)
        lft[x] > 1 ? y = (int)sqrt(lft[x]) , mu[x] = (y * y == lft[x] ? 0 : (MR::isp(lft[x]) ? -mu[x] : mu[x])) : 0, ans += mu[x];
    printf("%d", ans);
    return 0;
}


---

## 作者：Mirasycle (赞：1)

典题，怎么还有题解贡献空间。

从 [P5285 [十二省联考 2019] 骗分过样例 ](https://www.luogu.com.cn/problem/P5285)的 2u 部分双倍经验过来的。

我们考虑用线性筛求出 $10^6$ 以内的所有函数值，以及所有质数。

对于超过 $10^6$ 部分的数，我们可以考虑把他们所有小于等于 $10^6$ 的质因子都除掉，同时动态维护莫比乌斯函数值。做法就是类似于 [UVA10140 Prime Distance](https://www.luogu.com.cn/problem/UVA10140) 类似于埃氏筛用每个质数在大区间范围内标记。

那么这些大数要么剩下一个大质数，要么是一个完全平方数，要么由两个质数相乘得到。

  对于第一种情况用 Miller-Rabin 判断之后直接 $\times (-1)$ 即可，对于第二种情况赋 $0$，对于第三种情况就是 $\times (-1)^2$ 也就是不变。


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef __int128 Int;
const int B=1e6;
const int maxn=1e6+10;
int vis[maxn],mu[maxn],p[maxn];
int b[maxn],cnt=0,ans=0; ll a[maxn];
int A[4]={2,3,61};
ll qpow(ll x,ll k,ull mod){
	ll res=1;
	for(;k;k>>=1){
		if(k&1) res=(Int)res*x%mod;
		x=(Int)x*x%mod;
	}
	return res;
}
bool Miller(ll n){
	if(n<=2||n%2==0) return (n==2);
	if(n==3||n==61) return 1;
	ll r=n-1,d=0; int T=3;
	while((r&1)^1) r>>=1,d++;
	while(T--){
		ll a=A[T],v=qpow(a,r,n);
		if(v==1) continue;
		for(int i=0;i<=d;i++){
			if(i==d) return 0;
			if(v==n-1) break;
			v=(Int)v*v%n;
		}
	}
	return 1;
}
void init(){
	mu[1]=1; memset(vis,0,sizeof(vis));
	for(int i=2;i<=B;i++){
		if(!vis[i]){ p[++cnt]=i; mu[i]=-1; }
		for(int j=1;j<=cnt&&i<=B/p[j];j++){
			vis[i*p[j]]=1;
			if(i%p[j]==0) break;
			mu[i*p[j]]=-mu[i];
		}
	}
}
bool chk(ll x){ ll z=sqrt(x); return (z*z==x); }
int main(){
	ll l,r,deta; cin>>l>>r; init();
	for(ll j=l;j<=min(r,(ll)B);j++) ans+=mu[j];
	if(r<=B){ cout<<ans; return 0; }
	l=max(l,(ll)B+1); deta=l-1;
	for(ll i=l;i<=r;i++) a[i-deta]=i,b[i-deta]=1;
	for(int i=1;i<=cnt;i++){
		int z=p[i];
		for(ll v=1ll*((l-1)/z+1)*z;v<=r;v+=z){
			a[v-deta]/=z;
			if(a[v-deta]%z==0) b[v-deta]=0; 
			b[v-deta]*=-1;
		}
	}
	for(ll i=l;i<=r;i++){
		if(a[i-deta]==1){ ans+=(b[i-deta]); continue; }
		if(Miller(a[i-deta])) ans-=b[i-deta];
		else if(!chk(a[i-deta]))  ans+=b[i-deta];
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Purslane (赞：1)

# Solution

区间筛积性函数板子题。

数据范围显然不支持我们使用筛子。但是要充分利用 $r-l \le 10^5$ 的特性。

具体而言，如果我们预处理了 $10^6$ 以内的质数，就可以模仿埃氏筛，把范围内的数的因子给除掉。

那么剩下的质因子都 $>10^6$，在值域内只有 $p$、$pq$、$p^2$ 三种可能。

前者可以用 Miller-Rabin 判断，后者可以开根号判断，中间的就是剩余情况，但是具体 $pq$ 是多少并不重要——根据积性函数的性质，不影响 $\mu$ 的取值。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1000000+10,P[10]={0,2,3,5,7,11,13,17,19,23};
int n,l,r,flg[MAXN],mu[MAXN],rst[MAXN];
vector<int> pr;
void init(int mx) {
	ffor(i,2,mx) {
		if(!flg[i]) pr.push_back(i);
		for(auto v:pr) {
			if(i*v>mx) break ;
			flg[i*v]=1;
			if(i%v==0) break ;
		}
	}
	return ;
}
int qpow(__int128 base,int p,int mod) {
	__int128 ans=1;
	while(p) {
		if(p&1) ans=ans*base%mod;
		base=base*base%mod,p>>=1;	
	}
	return ans;
}
int check(int v,int mod) {
	int p=mod-1;
	if(qpow(v,p,mod)!=1) return 0;
	while(p%2==0) {
		p/=2;
		int tval=qpow(v,p,mod);
		if(tval!=1&&tval!=mod-1) return 0;
		if(tval==mod-1) break ;
	}
	return 1;
}
int miller_rabin(int u) {
	ffor(j,1,9) if(P[j]==u) return 1;
	ffor(j,1,9) if(!check(P[j],u)) return 0;
	return 1;
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>l>>r;
	init(1000000);
	ffor(i,1,r-l+1) mu[i]=1,rst[i]=i+l-1;
	for(auto v:pr) {
		int L=(l/v+!!(l%v))*v,R=r/v*v;
		for(int i=L;i<=R;i+=v) {
			if((i/v)%v==0) mu[i-l+1]=0;
			else mu[i-l+1]=-mu[i-l+1];
			while(rst[i-l+1]%v==0) rst[i-l+1]/=v;	
		}
	}
	ffor(i,1,r-l+1) if(rst[i]!=1) {
		if(miller_rabin(rst[i])) mu[i]=-mu[i];
		else {
			int sq=sqrt(rst[i]);
			while((sq+1)*(sq+1)<=rst[i]) sq++;
			while((sq-1)*(sq-1)>=rst[i]) sq--;
			if(sq*sq==rst[i]&&miller_rabin(sq)) mu[i]=0;
		}
	}
	int ans=0;
	ffor(i,1,r-l+1) ans+=mu[i];
	cout<<ans;
	return 0;
}
```

---

## 作者：Fzrcy (赞：1)

明显的，杜教筛是无法通过的。因为 $r-l \leq 10^5$，所以考虑暴力筛出莫比乌斯函数值。

套路的，对于 $x\in[L,R]$ 其质数大于 $10^6$ 的质数的个数小于 $2$，考虑筛去所有小于 $10^6$ 的质数。假设剩下的数为 $x’$，一共有三种情况：是质数，是一个大质数的平方，是两个不同的大质数的积。

对于第一种情况用 Miller-Rabin 判断即可，第二种情况直接开方判断即可，若前两种情况均为假则一定是第三种情况。

在筛的过程中计算莫比乌斯函数值即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define LL long long
class ks{
    public:
        ll ksc(ll a,ll b,ll mod)
        {
            ll c=(long double)a/mod*b;
            ll res=(unsigned long long)a*b-(unsigned long long)c*mod;
            return (res+mod)%mod;
        }
        LL ksm(LL x, LL y, LL p){
            LL cur=1;
            for(; y; y>>=1,x=ksc(x,x,p))
                if(y&1)cur=ksc(cur,x,p);
            return cur;
        }
};

mt19937 rnd(time(0));

class millerrabin{
    private:
        ks test;
    public:
        bool miller(LL S){
            if(S<=2||S%2==0)return S==2;
            LL ci=0,U=S-1;
            while(U%2==0)U>>=1,ci++;
            for(LL kase=1; kase<=10; kase++){
                LL a=rand()%(S-1)+1,now=test.ksm(a,U,S),nxt;
                for(LL i=1; i<=ci; i++){
                    nxt=test.ksc(now,now,S);
                    if(nxt==1&&now!=1&&now!=S-1)return false;
                    now=nxt;
                }
                if(now!=1)return false;
            }
            return true;
        }
}mr;

const int N=1e6+11;
int mu[N], vis[N], pr[N], pc;
void sieve(int tot=1000000){
    mu[1]=1;
    for(int i(2); i<=tot; i++){
        if(!vis[i]) pr[++pc]=i, mu[i]=-1;
        for(int j=1; j<=pc&&1ll*pr[j]*i<=tot; j++){
            vis[i*pr[j]]=1, mu[i*pr[j]]=-mu[i];
            if(i%pr[j]==0){mu[i*pr[j]]=0; break;}
        }
    }
}
ll a[N], Mu[N];
int main(){
	srand(time(0));
	ll L, R, len;
	cin>>L>>R;
    len=R-L+1;
    sieve();
    if(R<=1000000){
        ll ans=0;
        for(ll i=L; i<=R; i++)
            ans+=mu[i];
        cout<<ans<<'\n';
        return 0;
    }
    for(int i=0; i<len; i++) a[i]=L+i, Mu[i]=1;
    for(ll i=1; i<=pc; i++){
        ll x=pr[i];
        for(ll j=(x-L%x)%x; j<len; j+=x){
            ll c=0;
            while(a[j]%x==0)a[j]/=x, c++;
            if(c>1) Mu[j]=0;
            if(c==1) Mu[j]=-Mu[j];
        }
    }
    for(int i=0; i<len; i++){
        if(a[i]==1) continue;
        if(mr.miller(a[i])){Mu[i]=-Mu[i];}
        else{
            ll sqr=sqrt(a[i]);
            if(sqr*sqr==a[i]) Mu[i]=0;
        }
    }
    ll ans=0;
    for(ll i=0; i<len; i++)ans+=Mu[i];
    cout<<ans<<'\n';
    return 0;
}
```



---

## 作者：Kreado (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P3653)。

首先问一下出题人拿的什么造的数据，费马大定理都能过。。。

#### 思路

这道题直接筛或求是很难做的，有 $r\le10^{18}$，考虑先筛 $10^6$ 以内的素数，令 `fac[x]` 表示 $x$ 筛出 $10^6$ 以内的质因子之后得到的数，那么有 $3$ 种情况。

$$fac_x=\begin{cases}pq&(p,q\in \mathbb{P})\\p^2&(p\not=1)\\p&(p\in\mathbb{P})\end{cases}$$

那么 $\mu$ 就很好求了，对于第一种情况 $\mu(x)=1$，第二种情况 $\mu(x)=0$，第三种情况 $\mu(x)=-1$。这里使用 Miller_Rabin 素数检测判断素数。

那么接下来只用枚举 $i\in[l,r]$ 即可。

#### CoDe

```cpp
#include <bits/stdc++.h>
#define ll long long
#define Auto map<ll,ll>::iterator
#define lll __int128
using namespace std;
const ll Maxn=1e6+7,inf=0x3f3f3f3f;
map<ll,ll>S;
namespace Math{
    inline ll mul(ll a,ll b,ll p){
        a%=p,b%=p;
        ll c=a*b-(ll)((long double)a*b/p+0.5)*p;
        return c<0?c+p:c;
    }
    inline ll ksm(ll a,ll b,ll Mod)
    {ll z=1;while(b){if(b&1)z=(lll)z*a%Mod;a=(lll)a*a%Mod;b>>=1;}return z;}
    inline ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}
    inline ll qread(void){
        ll x=0,f=1;char ch;
        while((ch=getchar())<'0'||ch>'9') if(ch=='-') f=-1;x=(ch^48);
        while((ch=getchar())>='0'&&ch<='9') x=(x<<1)+(x<<3)+(ch^48);
        return x*f;
    }
}
using namespace Math;
namespace Miller_Rabin{
    ll Test[11]={0,2,7,41,61};
    inline bool Prime(ll X){
        if(X<2) return false;
        ll k=0,t=X-1;
        while(1^(t&1)) t>>=1,++k;
        for(ll i=1;i<=4;i++){
            if(X==Test[i]) return true;
            ll A=ksm(Test[i],t,X),Next=A;
            for(ll j=1;j<=k;j++){
                Next=mul(A,A,X);
                if(Next==1&&A!=1&&A!=X-1) return false;
                A=Next;
            }
            if(Next!=1) return false;
        }
        return true;
    }
}
using namespace Miller_Rabin;
ll l,r,ans,prime[Maxn],cnt,fac[Maxn];
int mu[Maxn];
bool isprime[Maxn];
inline void init(ll n){
    isprime[1]=isprime[0]=1;
    for(ll i=2;i<=n;i++){
        if(!isprime[i]) prime[++cnt]=i;
        for(ll j=1;j<=cnt&&prime[j]*i<=n;j++){
            isprime[i*prime[j]]=1;
            if(!(i%prime[j])) break;
        }
    }
}
int main(){
    init(1e6);
    l=qread(),r=qread();
    for(ll i=l;i<=r;i++) mu[i-l]=1,fac[i-l]=i;
    for(ll i=1;i<=cnt&&prime[i]<=r;i++){
        ll t=prime[i];
        for(ll j=((l-1)/t+1)*t;j<=r;j+=t){
            ll k=0;
            while(fac[j-l]%t==0) ++k,fac[j-l]/=t;
            if(k>1) mu[j-l]=0;
			else mu[j-l]=-mu[j-l];
        }
    }
    for(ll i=l;i<=r;i++){  
        if(fac[i-l]!=1){
            ll t=fac[i-l];
            if((ll)sqrt(t)*(ll)sqrt(t)==t) mu[i-l]=0;
            else if(Prime(t)) mu[i-l]=-mu[i-l];
        }
        ans+=mu[i-l];
    }
    printf("%lld",ans);
    return 0;
}
```

其实一开始我是拿 Pollard-rho 算的，结果 TLE 了。

---


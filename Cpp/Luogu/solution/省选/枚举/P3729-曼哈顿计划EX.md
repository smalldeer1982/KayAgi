# 曼哈顿计划EX

## 题目背景

- 曼哈顿计划EX， The X Makes It Sound Cool

- 艾登黑进了dedsec的系统以后，发现核弹发射已经进入了倒计时，他必须停止核弹的发射进程。

![](https://cdn.luogu.com.cn/upload/pic/5120.png)


## 题目描述

- 艾登拥有一个计算机网络，每一台计算机都至少有着Intel Xeon E50 v40 + 40路GTX10800Titan的恐怖配置，并由无线网络直接或间接连接，这可以用一个无向连通图来表示。但是他的计算机网络有一个问题——不够安全，dedsec可能会攻击他的网络，切断一些无线连接，从而导致整个计算机网络不连通。为了避免这种情况，艾登决定从这些计算机中挑出一些计算机作为计算节点，其他计算机作为信息的中转站，进行停止核弹发射进程的任务。虽然台台都是顶配，但是艾登的计算机也会有从山寨厂买回的配件和原装正版配件的差别——每台电脑的工作能力是不同的，记为$ w_{i}$。现在艾登想知道，对于一个工作能力的要求，整个网络的安全系数最大是多少？


- 设给出的图为$G = (V , E)$，其中$V$ = $V_{1}$（计算节点） + $V_{2}$（中转节点）

- 我们定义安全系数k为：最大的k，使得任意两点$u,v\in V_{1}$都至少有k条互不相交的u到v的链（互不相交定义为：没有重复的边，可以重复有重复的点）

- 我们定义整个图的工作能力$W = \sum_{v \in V_{1}}{w_{v}}$


## 说明/提示

 ![](https://cdn.luogu.com.cn/upload/pic/5114.png) 

## 样例解释

- 对于询问1，选择任何一台计算机作为计算节点都是一个合法答案

- 对于询问2，至少要选择3台计算机，任选三个都是合法方案。选出的三个点构成三角形，对于任意两个点都有两种相互到达的方法（在三角形上顺时针和逆时针走），所以答案是2

- 对于询问3，选择所有的计算机都不足以满足任务


## 数据规模

- 对于30%的数据，n<=20，保证 $qn^{4}$ 不大于1e8

- 对于100%的数据，n<=550,m<=3000,q<=2017,询问以及$w_{i}$均不超过$10^{6}$

- 所有数字均为正整数


## 样例 #1

### 输入

```
4 5 3
1 1 1 1
1 2
1 3
2 3
1 4
2 4
1
3
5```

### 输出

```
nan
2
Nuclear launch detected```

# 题解

## 作者：Marser (赞：6)

前置知识：[最小割树](https://www.luogu.com.cn/problem/P4897)。没有这东西不知道怎么写这道题。  
### 题意
给定一张无向图，每个点有点权。每次给定一个 $x$，询问当限制选出的点集权值和 $\ge x$ 时最大的整数 $k$，满足点集内任意两点间均有至少 $k$ 条不相交路径。
### 题解
首先，我们可以将“两点间有至少 $k$ 条不相交路径”转化为“以两点为源、汇，最大流量不小于 $k$ ”。运用最大流最小割定理转化为“两点间最小割不小于 $k$ ”，我们就自然地联想到最小割树。  
首先跑一遍最小割树，记录下所有树边，将它们按边权从大到小排序，同时将所有询问按 $x$ 值从小到大排序。用带权并查集维护每个点所在联通块的点权和，依次加入每一条边，并更新单个连通块的点权和最大值 $cur$。每次加完边，我们可以将所有满足 $x \le cur$ 且未被处理的询问的答案更新为当前边的权值。注意特殊处理输出```nan```的情况。  
主要的复杂度瓶颈在求最小割树的过程，相信自己能过就好了。  
感觉是道不错的最小割树练习题。
### 代码
```cpp
#include<bits/stdc++.h>
#define reg register
typedef long long ll;
using namespace std;
const int MN=555;
const int MM=12005;
const int MQ=2020;
const int inf=0x3f3f3f3f;
int to[MM],nxt[MM],c[MM],flow[MM],h[MN],cnt;
inline void ins(int s,int t,int w,int f){
	to[cnt]=t;nxt[cnt]=h[s];c[cnt]=w;
	flow[cnt]=f;h[s]=cnt++;
}
int n,m;
namespace Flow{
	int S,T,iter[MN],level[MN],que[MN];
	bool bfs(){
		memset(level,-1,sizeof(level));
		reg int he=0,ta=0;
		que[ta++]=S;level[S]=0;
		while(he<ta){
			reg int v=que[he++];
			for(reg int i=h[v];~i;i=nxt[i])
				if((c[i]-flow[i])&&level[to[i]]<0)
					level[to[i]]=level[v]+1,que[ta++]=to[i];
		}
		return ~level[T];
	}
	int dfs(int st,int f){
		if(st==T)return f;
		reg int used=0,w;
		for(reg int& i=iter[st];~i;i=nxt[i])
			if((c[i]-flow[i])&&level[to[i]]>level[st]){
				w=dfs(to[i],min(f-used,c[i]-flow[i]));
				if(!w)continue;
				flow[i^1]-=w;flow[i]+=w;used+=w;
				if(f==used)return f;
			}
		return used;
	}
	int Dinic(int ss,int tt){
		S=ss;T=tt;reg int res=0,f;
		for(reg int i=0;i<cnt;i++)
			flow[i]=(~i&1)*c[i];
		while(bfs()){
			memcpy(iter,h,sizeof(h));
			while(f=dfs(S,inf))res+=f;
		}
		return res;
	}
}
int node[MN],t1[MN],t2[MN],col[MN],idx;
void paint(int st){
	col[st]=idx;
	for(reg int i=h[st];i;i=nxt[i])
		if((c[i]-flow[i])&&col[to[i]]<idx)paint(to[i]);
}
struct edge{int s,t,w;}es[MN];
struct data{int x,id;}ask[MQ];
int q,ecnt,wei[MN],par[MN],ans[MQ];
void solve(int l,int r){
	if(l==r)return;
	reg int val=Flow::Dinic(node[l],node[l+1]);
	idx++;paint(node[l]);
	es[++ecnt]=(edge){node[l],node[l+1],val};
	reg int cnt1=0,cnt2=0;
	for(reg int i=l;i<=r;i++){
		if(col[node[i]]==idx)t1[++cnt1]=node[i];
		if(col[node[i]]!=idx)t2[++cnt2]=node[i];
	}
	for(reg int i=1;i<=cnt1;i++)node[i+l-1]=t1[i];
	for(reg int i=1;i<=cnt2;i++)node[i+l+cnt1-1]=t2[i];
	solve(l,l+cnt1-1);solve(l+cnt1,r);
}
inline int find(int x){return par[x]==x?x:par[x]=find(par[x]);}
int main(){
	scanf("%d%d%d",&n,&m,&q);
	memset(h,-1,sizeof(h));
	for(reg int i=1;i<=n;i++)scanf("%d",wei+i);
	for(reg int i=1,s,t;i<=m;i++){
		scanf("%d%d",&s,&t);
		ins(s,t,1,0);ins(t,s,1,1);
		ins(t,s,1,0);ins(s,t,1,1);
	}
	for(reg int i=1;i<=n;i++)node[i]=i;
	solve(1,n);
	for(reg int i=1;i<=q;i++)scanf("%d",&ask[i].x),ask[i].id=i;
	sort(es+1,es+n,[](edge a,edge b){
		return a.w>b.w;
	});
	sort(ask+1,ask+1+q,[](data a,data b){
		return a.x<b.x;
	});
	reg int Ans=0,cur=1;
	for(reg int i=1;i<=n;i++)par[i]=i,Ans=max(Ans,wei[i]);
	memset(ans,0x3f,sizeof(ans));
	for(;cur<=q&&ask[cur].x<=Ans;cur++)ans[ask[cur].id]=0;
	for(reg int i=1,s,t;i<n;i++){
		s=find(es[i].s);t=find(es[i].t);
		par[t]=s;Ans=max(Ans,wei[s]+=wei[t]);
		for(;cur<=q&&ask[cur].x<=Ans;cur++)
			ans[ask[cur].id]=es[i].w;
	}
	for(reg int i=1;i<=q;i++){
		if(ans[i]==inf)puts("Nuclear launch detected");
		else if(ans[i]==0)puts("nan");
		else printf("%d\n",ans[i]);
	}
	return 0;
}
```

---

## 作者：xkcdjerry (赞：0)

前置知识：[最小割树](https://www.luogu.com.cn/problem/P4897)  

先考虑单次询问怎么做：  
要求 $u$ 到 $v$ 有 $k$ 条不共边路径等效于 $u$ 到 $v$ 有 $k$ 条增广路，即 $u$ 到 $v$ 最大流不小于 $k$。  
又因为最大流等于最小割有 $u$ 和 $v$ 的最小割不小于 $k$，所以 $u$ 和 $v$ 在最小割树上的路径经过的边权均不小于 $k$。  
所以把边按权值从大到小加入，直到当前最大的连通块点权和大于等于要求的工作能力即可。

暴力做的话复杂度为 $O(n^3m+nq \alpha(n))$ 可通过，代码略。

由上述算法易得，工作能力增加时最大安全系数单调不增。所以可以对询问的工作能力离线后从小到大排序，再用一个指针维护目前插入到的边从大往小跳即可 $O(q \log q+n \alpha(n))$ 完成询问部分。

注意特判一个点就能满足工作能力和所有点全部插入也不满足工作能力的的情况。

code：

```c++
#include <cstdio>
#include <vector>
#include <algorithm>
#define M 90010
#define N 3010
int n,m,Q,head[N],cur=2;
struct edge{int v,w,nxt;}e[M],bak[M];
int dep[N];
inline int min(int x,int y) {return x<y?x:y;}
void ins(int u,int v,int w)
{
	e[cur]={v,w,head[u]}; head[u]=cur++;
	e[cur]={u,w,head[v]}; head[v]=cur++;
}
bool bfs(int s,int t)
{
	static int q[N];  for(int i=1;i<=n;i++) dep[i]=0;
	dep[s]=1; q[0]=s; for(int i=0,p=1,x;i<p;i++)
		for(int j=head[x=q[i]];j;j=e[j].nxt) if(e[j].w&&!dep[e[j].v]) dep[e[j].v]=dep[x]+1, q[p++]=e[j].v;
	return dep[t];
}
int dfs(int s,int t,int flow)
{
	if(s==t||!flow) return flow;
	int ans=0; for(int i=head[s],tmp;i;i=e[i].nxt) if(dep[e[i].v]==dep[s]+1)
		tmp=dfs(e[i].v,t,min(flow,e[i].w)), e[i].w-=tmp, e[i^1].w+=tmp, flow-=tmp, ans+=tmp;
	if(!ans) dep[s]=-1;
	return ans;
}
int a[N]; std::vector<edge> g[N];
void build(int l,int r)
{
	if(l>=r) return;
	int flow=0;
	for(int i=0;i<cur;i++) e[i]=bak[i];
	while(bfs(a[l],a[r])) flow+=dfs(a[l],a[r],0x3f3f3f3f);
	g[a[l]].push_back({a[r],flow,-1});
	g[a[r]].push_back({a[l],flow,-1});
	int p=l; for(int i=l;i<r;i++) if(dep[a[i]]) {int t=a[i];a[i]=a[p];a[p]=t;p++;}
	build(l,p-1); build(p,r);
}
void work() {for(int i=1;i<=n;i++) a[i]=i; for(int i=0;i<cur;i++) bak[i]=e[i]; build(1,n);}
int tmp[N*2],f[N*N];
void split(int u,int fa,int v) {tmp[u]=v; for(auto i:g[u]) if(i.v!=fa) split(i.v,u,min(v,i.w));}
struct query
{
	int x,i;
	bool operator<(query b) {return x<b.x;}
}q[M];
int fa[N],sz[N],mx;
struct bruh
{
	int u,v,w;
	bool operator<(bruh b) {return w>b.w;}
}T[N];
int ans[M];
int find(int x) {return fa[x]==x?x:fa[x]=find(fa[x]);}
void merge(int u,int v) {u=find(u),v=find(v); if(u!=v) {sz[u]+=sz[v]; fa[v]=u; if(sz[u]>mx) mx=sz[u];}}
int main()
{
	//在原图上的部分：建出最小割树
	scanf("%d%d%d",&n,&m,&Q);
	for(int i=1;i<=n;i++) {scanf("%d",sz+i); if(sz[i]>mx) mx=sz[i];}
	for(int i=1;i<=n;i++) fa[i]=i;
	for(int i=0,u,v;i<m;i++) scanf("%d%d",&u,&v),ins(u,v,1);
	work();
	//在最小割树上的部分
	for(int i=0;i<Q;i++) scanf("%d",&q[i].x),q[i].i=i;
	m=0; for(int i=1;i<=n;i++) for(auto j:g[i]) if(j.v<i) T[m++]=bruh{i,j.v,j.w};
	std::sort(T,T+m); std::sort(q,q+Q); int p=0,tmp=0x3f3f3f3f;
	for(int i=0;i<Q;i++)
	{
		while(p<m&&mx<q[i].x) tmp=T[p].w, merge(T[p].u,T[p].v), p++;
		ans[q[i].i]= q[i].x<=mx?tmp:-1;
	}
	for(int i=0;i<Q;i++)
	{
		if(ans[i]==0x3f3f3f3f) puts("nan");
		else if(ans[i]==-1) puts("Nuclear launch detected");
		else printf("%d\n",ans[i]);
	}
}
```

---


# [六省联考 2017] 分手是祝愿

## 题目描述

> Zeit und Raum trennen dich und mich.
时空将你我分开。

B 君在玩一个游戏，这个游戏由 $n$ 个灯和 $n$ 个开关组成，给定这 $n$ 个灯的初始状态，下标为从 $1$ 到 $n$ 的正整数。

每个灯有两个状态亮和灭，我们用 $1$ 来表示这个灯是亮的，用 $0$ 表示这个灯是灭的，游戏的目标是使所有灯都灭掉。

但是当操作第 $i$ 个开关时，所有编号为 $i$ 的约数（包括 $1$ 和 $i$）的灯的状态都会被改变，即从亮变成灭，或者是从灭变成亮。

B 君发现这个游戏很难，于是想到了这样的一个策略，每次等概率随机操作一个开关，直到所有灯都灭掉。

这个策略需要的操作次数很多，B 君想到这样的一个优化。如果当前局面，可以通过操作小于等于 $k$ 个开关使所有灯都灭掉，那么他将不再随机，直接选择操作次数最小的操作方法（这个策略显然小于等于 $k$ 步）操作这些开关。

B 君想知道按照这个策略（也就是先随机操作，最后小于等于 $k$ 步，使用操作次数最小的操作方法）的操作次数的期望。

这个期望可能很大，但是 B 君发现这个期望乘以 $n$ 的阶乘一定是整数，所以他只需要知道这个整数对 $100003$ 取模之后的结果。


## 说明/提示

对于 $0\%$ 的测试点，和样例一模一样；  
对于另外 $30\%$ 的测试点，$n \leq 10$；  
对于另外 $20\%$ 的测试点，$n \leq 100$；  
对于另外 $30\%$ 的测试点，$n \leq 1000$；  
对于 $100\%$ 的测试点，$1 \leq n \leq 100000, 0 \leq k \leq n$；  
对于以上每部分测试点，均有一半的数据满足 $k = n$。


## 样例 #1

### 输入

```
4 0
0 0 1 1
```

### 输出

```
512```

## 样例 #2

### 输入

```
5 0
1 0 1 1 1```

### 输出

```
5120```

# 题解

## 作者：justin_cao (赞：101)

这道$dp$题感觉也挺神的。。我们考虑每个点按多次都可以归化成按或不按两种状态，而且很显然可以发现，每个按键都不可能被其他按键的组合键替代，于是我们实际上可以从大到小扫一遍，碰到亮的就按一遍，这样的话我们就可以找到所有必须要按的键，实际上就相当于除开这些键按了其他的键就还要必须按一个相同的键给按回来，这样我们就可以$dp$了。我们设$f[i]$表示从$i$个需要按的键到$i-1$个需要按的键的期望操作次数，这个转移方程是这样的：
$$f[i]=\frac{i}{n}+\frac{n-i}{n}\times(f[i]+f[i+1]+1)$$
这个的意思实际上是，有$\frac{i}{n}$的概率可以按到正确的键位，有另外$\frac{n-i}{n}$的概率是错误的位置，所以在之后的操作中需要将这个按键按回来，所以就多了一个需要按的键，按回来$i$之后还是需要$f[i]$的操作次数到$i-1$，这样就解释完了。。。

然后我们就可以把上面那个式子简化一下：
$$f[i]=\frac{n+(n-i)\times f[i+1]}{i}$$
然后求出这个东西之后，我们先比较一下必须按的按键个数（设为$cnt$）和$k$，如果还要小，就肯定是前者作为答案。不然我们就直接把$f[cnt]+f[cnt-1]+....+f[k+1]$作为答案即可，就相当于是从$cnt$到$k$的期望操作次数，然后，**记得要加个$k$!!!**，然后就乘上$n$的阶乘即可。

下面是代码
```cpp
// luogu-judger-enable-o2
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#define maxn 100010
#define mod 100003
using namespace std;
typedef long long ll;
ll read()
{
    ll x=0,f=1;
    char ch=getchar();
    while(ch-'0'<0||ch-'0'>9){if(ch=='-') f=-1;ch=getchar();}
    while(ch-'0'>=0&&ch-'0'<=9){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int n,k;
int a[maxn];
int cnt=0;
ll f[maxn];
ll quick_pow(ll x,ll p)
{
    ll an=1;
    ll po=x;
    while(p)
    {
        if(p%2)  an=(an*po)%mod;
        po=(po*po)%mod;
        p/=2;   
    }
    return an;
}
int main()
{
    n=read();k=read();
    for(int i=1;i<=n;i++)   a[i]=read();
    for(int i=n;i>=1;i--)
    {
        if(a[i])
        {
            cnt++;
            for(int j=1;j*j<=i;j++)
            {
                if(i%j==0)
                {
                    a[j]^=1;
                    if(j*j!=i)  a[i/j]^=1;
                }
            }
        }
    }
    f[n+1]=0;
    for(int i=n;i>=1;i--)
    {
        ll tmp=(ll)(n-i)*f[i+1]%mod;
        tmp=(tmp+(ll)n)%mod;
        tmp=tmp*quick_pow(i,mod-2)%mod;
        f[i]=tmp;
    }
    ll tmp=0;
    if(cnt<=k)   tmp=cnt;
    else{
        for(int i=cnt;i>k;i--)  tmp=(tmp+f[i])%mod;
        tmp=(tmp+k)%mod;
    }
    for(int i=1;i<=n;i++)  tmp=(tmp*(ll)i)%mod;
    printf("%lld\n",tmp);
    return 0;
}
```

---

## 作者：wine (赞：36)

一道不错的概率题，"相逢是问候"太神了,考试时没敢嗑这题。


先考虑关灯的最少次数，一个开关按两次和没按一样，从大到小有亮的就灭掉，它的约数可以$n*\sqrt{n}$枚举，更快的做法是枚举约数i，找它的倍数i,i\*2,i\*3...,复杂度$n/1+n/2+n/3+...=n*log(n)$,这样就有80分了(\*￣︶￣)


考虑期望，设f[i]表示从有i个正确选择变为有i-1个正确选择的期望操作次数,$f[i]=\dfrac{i}{n}+(1-\dfrac{i}{n})*(1+f[i+1]+f[i])$

(n个开关，i个正确，其他n-i个会增加一个错误，需f[n+1]+f[n]次操作变到i-1)

移项$ f[i]=1+\dfrac{(1*n-i)*(f[i+1]+1)}{i}$,

f[n] = 1,把f累加一下就可以。

不要忘了乘$n!$


```cpp
#include <iostream>
#include <cstdio>
#include <vector>

using namespace std;
typedef long long LL;
 
inline void read(int &x) {
    static char c; bool flag = 0;
    while((c=getchar())<'0'||c>'9') flag |= (c=='-');
    x=c-'0';while((c=getchar())>='0'&&c<='9') x = x*10+c-'0';
    flag?x=-x:x;
}

typedef long long LL;

const int p = 100003;
int n,k,b[101000];
LL f[101000],inv[101000];
vector<int> g[101000];

void work() {
    LL ans = 0,tp = 0;
    for (int i = 1; i <= n; i++)
     for (int j = i; j <= n; j += i)
       g[j].push_back(i);         
    for (int i = n; i >= 1; i--) 
     if (b[i]) {
         for (int j = 0; j < g[i].size(); j++) b[g[i][j]] ^= 1; 
         tp++;
     }
    if (tp <= k) ans = tp; 
    else {
       f[n] = 1;
       for (int i = n-1; i > 1; i--) f[i] = (1LL+(1LL*n-i)*(f[i+1]+1)*inv[i])%p;
       for (int i = tp; i > k; i--) ans = (ans+f[i])%p;
       ans = (ans+k)%p; 
    }
    for (int i = 1; i <= n; i++) ans = (ans*i)%p; 
    printf("%lld",ans);
}

int main() {
    read(n); read(k);
    for (int i = 1; i <= n; i++) read(b[i]);
    inv[1] = 1;
    for (int i = 2; i <= n; i++) inv[i] = ((p-p/i)*inv[p%i])%p;
    work();
    return 0;
}
```


---

## 作者：Dreamunk (赞：23)

略有订正，求管理员通过。

---

不知道什么时候过的题，今天看到有同学在做，觉得有必要写一写题解。

[题目](https://www.luogu.org/problem/P3750)

题意：有一个长度为 $n$ 的 $01$ 串，下标编号 $1$ 到 $n$。对位置 $p$ 操作一次可以使所有编号为 $p$ 的约数的位置 $0$ 变 $1$，$1$ 变 $0$。目标是使所有位置变成 $0$。B 君先随机操作若干次，等到当前局面可以在 $k$ 次操作以内达成目标时就使用最优策略，达成目标后结束操作。求期望操作次数。

容易证明，一种最优的操作策略是每次操作最右边的为 $1$ 的位置，直到达成目标。而且操作的先后顺序并不重要。

设 $f_i$ 表示当前最优策略需要 $i$ 步，从当前局面达到目标的期望步数。

则

$$
f_i=
\begin{cases}
i(i\le k)\\
\frac{i}{n}f_{i-1}+\frac{n-i}{n}f_{i+1}+1(i > k)
\end{cases}
$$

暴力高斯消元复杂度爆炸。

设 $f_i=f_{i-1}+b_{i}$，那么我们发现 $b_i$是好求的。

$f_i=\frac{i}{n}f_{i-1}+\frac{n-i}{n}f_{i+1}+1$

代入得 $f_i=\frac{i}{n}(f_i-b_i)+\frac{n-i}{n}(f_{i}+b_{i+1})+1$

整理得到 $b_i=\frac{(n-i)b_{i+1}+n}{i}$

边界条件 $b_n=1$

做完了。

以下代码时间复杂度为 $O(n^{1.5})$。如果使用一些数论技巧来优化，可以做到 $O(n\log n)$。

```cpp
#include<cstdio>
const int N=1e5+1,M=1e5+3;
int n,m,c,a[N],inv[M],f[N],b[N];
inline int F(int n){return n?1ll*F(n-1)*n%M:1;}
int main(){
	int t;
	inv[1]=1;
	for(int i=2;i<M;i++)inv[i]=1ll*inv[M%i]*(M-M/i)%M;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)scanf("%d",a+i);
	for(int i=n,j;i;i--)if(a[i]){
	  for(j=1;j*j<i;j++)
		if(i%j==0)a[j]^=1,a[i/j]^=1;
	  if(j*j==i)a[j]^=1;
	  c++;
	}
	if(m==n||m==n-1)return 0*printf("%lld",1ll*F(n)*c%M);
	for(int i=0;i<=m;i++)f[i]=i;
	b[n]=1;
	for(int i=n-1;i>m;i--)
	  b[i]=(1ll*(n-i)*b[i+1]+n)%M*inv[i]%M;
	for(int i=m+1;i<=n;i++)f[i]=(f[i-1]+b[i])%M;
	return 0*printf("%lld",1ll*F(n)*f[c]%M);
}
```

---

## 作者：attack (赞：17)

对于每个灯来说，操作两次的结果与不操作相同的

因此我们可以预处理出初始局面需要的操作次数

约数的话直接$O(nlogn)$vector暴力求

这样的话最暴力的想法就是从大的向小的依次枚举，实际这就是最优策略

用$dp[i]$表示对于$n$盏灯，从需要按$i$次能全部熄灭到按$i-1$次能全部熄灭的期望

考虑这一次的情况

有$\frac{i}{n}$的概率按到需要按的灯，此时的期望为$\frac{i}{n}*1$

有$\frac{n-i}{n}$的概率按到不需要按的灯，此时的期望为$\frac{n-i}{n}*(dp[i]+dp[i+1]+1)$

那么$dp[i]=\frac{i}{n}+\frac{n-i}{n}*(dp[i]+dp[i+1]+1)$

化简一下

$dp[i]=\frac{n}{i}+\frac{(n-i)dp[i+1]}{i}$

这样就可以线性递推了

注意推的时候从$n$推就可以，因为最优状态下需要的操作次数一定小于等于$n$

答案为$n!\sum_{i=1}^{need}$

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
#define int long long 
using namespace std;
const int MAXN=1e6+10;
const int mod=100003;
//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,MAXN,stdin),p1==p2)?EOF:*p1++)
//int buf[1<<20],*p1=buf,*p2=buf;
inline int read()
{
	char c=getchar();int x=0,f=1;
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
	return x*f;
}
int N,k;
int a[MAXN];
vector<int>Yue[MAXN];
int need;
int dp[MAXN],inv[MAXN];
main()
{
	#ifdef WIN32
	freopen("a.in","r",stdin);
	#endif
	N=read();k=read();
	inv[1]=1;
	for(int i=2;i<=N;i++) inv[i] = ((-(mod/i)*inv[mod%i]%mod)+mod)%mod;
	for(int i=1;i<=N;i++) a[i]=read();
	for(int i=1;i<=N;i++)
		for(int j=i;j<=N;j+=i)
			Yue[j].push_back(i);
	for(int i=N;i>=1;i--)
		if(a[i])
		{
			for(int j=0;j<Yue[i].size();j++)
				a[Yue[i][j]]^=1;
			need++;
		}
	dp[N]=1;
	for(int i=N-1;i>k;i--) dp[i]=(N+(N-i)*dp[i+1])*inv[i]%mod;
	for(int i=k;i>=1;i--) dp[i]=1;
	int ans=0;
	for(int i=1;i<=need;i++) ans=(ans+dp[i])%mod;
	for(int i=1;i<=N;i++) ans=(ans*i)%mod;
	printf("%lld",ans);
	return 0;
} 
```

---

## 作者：Rainy_chen (赞：14)

在Flandre\_495的题解通过后这题应该就已经有五篇题解了。所以我也不太想说这题的具体思路，其他题解说的已经很明白了。

~~Flandre\_495说的rainy就是我~~

这里我们来考虑一些比较特殊的事情：

我们如何证明一个局面的最优解是从后往前扫一遍能关就关？

实际上我们只能知道从后往前扫一遍必然是一个合法的解法，也就是说它是一个可行解，但我们想要证明它是唯一解。

我们可以认为一个合法的解法是一个可重集合$S$，其包含的所有数即为此解法需要按下的所有按钮的位置，也就是所有的操作。

例如对于$\{1,0,1\}$，有$S=\{3\}$。

定义为可重集合是因为$S=\{1,1,3\}$同样也是上述局面的一个解。

我们发现实际上一个操作重复两次就相当于这两次操作没有进行，因为它会使同样的几个位置上的数$\text{xor~1~xor~1}$,相当于不变。所以我们不认为这样的两个解法是不同的。  

考虑一个解法的实质，其代表了一个$n$维的向量，其中每一维都在01中取值，而这个解法就是将原局面的每一个数异或上这个向量中的对应维的那个数。

很明显我们可以对任何一个解法构造这样一个向量，并且每一个解法能解决的局面是唯一的，于是我们知道解法的集合$A$和局面的集合$B$的有映射$f:A\to B$。

接下来我们想证明的其实是这个映射是单射。

我们已经知道任何一个解法只能对应一个局面，并且解法的数量($2^n$)和局面的数量($2^n$)是相同的，于是如果我们能证明其为满射，就能知道它是一个单射。

我们先假设其为满射，证明其为单射。使用反证法，假设其不为单射。

那么就一定存在两个不同的解法集合对应了同一个局面，此时必然会出现局面没有被对应到，于是此时映射不是一个满射，与条件矛盾，所以其为单射。

之后我们发现对于任意一个局面，按照如上所述的构造方法一定能构造出一个解法，于是可以知道其为满射。于是其为单射。（当然它也是双射）

换句话而言，对于任何一个局面，其解法是唯一的，而我们做的任何操作都相当于向这个这个局面的解法追加了一个操作。   

而解决一个局面的唯一方法就是进行数次追加后将这个集合变为空集，这基于上面对映射为单射的证明。

如果我们进行的操作是解法中的某个操作，那么解法中的这个操作会和我们进行的这个操作抵消，使得解法的集合的大小变为$k-1$，此时即代表我们从需要$k$次操作的状态转移到了需要$k-1$次操作的状态。

如果我们进行的操作不属于这个解法中的操作，那么这个解法在添加这个操作后就变成了一个有$k+1$个元素的集合，而实际上上面这两个情况都是只和局面所需操作数有关的，所以我们就可以将局面所需操作数作为状态进行dp而不必关心具体局面。

---

## 作者：jiazhaopeng (赞：13)

**做法:模拟高斯消元**

~~为什么没几篇模拟高斯消元的题解啊？这不是最容易想到的吗？~~

首先根据部分分提示，我们可以先想怎样操作次数最少。比较明显的是，**我们每次选择最后一个亮着的灯是最优的**，因为选择第 $i$ 号灯能影响到的只有小于等于 $i$ 的灯，而不影响后面的灯。因此，如果不去操作最后一个亮着的灯的话，以后去前面操作不会再让其灭掉。

依照这种方法，我们可以得到一个最优的操作序列，并且可以对这个序列以任意顺序进行操作。

然后再考虑随机操作。我们发现随便对一个灯进行操作，要么恰好符合我们的期望，提前帮我们搞定一步；要么操作了其它的点，我们的最少操作次数又多了一。

根据套路，我们设 $f[i]$ 表示“最少需要 $i$ 步”的状态，到结束的期望次数，并且有式子:

$$f[t] = t, t <= k$$

$$f[i] = 1 + \frac{i}{n}f[i-1] + \frac{n-i}{n}f[i+1],t>k$$

发现无法递推，不过高斯消元足以通过前一半的数据。我们考虑对高斯消元进行优化。我们发现矩阵大概长这个样子：

$$\begin{bmatrix}
 1 &  &  &  &  &  &  &  &  &  & 1\\
  & 1 &  &  &  &  &  &  &  &  & 2\\
  &  & ... &  &  &  &  &  &  &  & \\
  &  &  & 1 &  &  &  &  &  &  & k\\
  &  &  & -\frac{k+1}{n}  & 1 & -\frac{n-k-1}{n}  &  &  &  &  & 1\\
  &  &  &  & -\frac{k+2}{n} & 1 & -\frac{n-k-2}{n} &  &  &  & 1\\
  &  &  &  &  & -\frac{k+3}{n} & 1 & -\frac{n-k-3}{n} &  &  & 1\\
  &  &  &  &  &  & ... & ... & ... &  & \\
  &  &  &  &  &  &  & -\frac{n-1}{n}  & 1 & -\frac{1}{n}  & 1\\
  &  &  &  &  &  &  &  & -\frac{n}{n}  & 1 &1
\end{bmatrix}$$

只有一条对角线，自然可以 $O(n)$ 高斯消元求（避过那些那零减来减去的步骤就好)。不过空间开不下 $n^2$ 数组，需要手动模拟（详见代码）。

复杂度：$O(nlogn)$（瓶颈在求逆元）

不过，这题比较恶心的一点是，模数只有 $1e5$ 大小，很容易加加减减出现 $0$，使得我们无法求逆元，这时需要交换相邻两行，对其进行特殊处理（详见代码）。如果模数开到 $1e9$ 那么大就基本没有这个问题了。

$Code:$

```cpp
#define N 101000
typedef long long ll;
template <typename T> inline void read(T &x) {
	x = 0; char c = getchar(); bool flag = false;
	while (!isdigit(c)) { if (c == '-')	flag = true; c = getchar(); }
	while (isdigit(c)) { x = (x << 1) + (x << 3) + (c ^ 48); c = getchar(); }
	if (flag)	x = -x;
}
using namespace std;
const int P = 100003;
inline ll quickpow(ll x, int k) {
	ll res = 1;
	while (k) {
		if (k & 1)	res = res * x % P;
		x = x * x % P;
		k >>= 1;
	}
	return res;
}
int n, K;
int state[N];
ll f[N], h[N][4];
bool tag[N];
inline void work() {
	for (register int i = 1; i <= K; ++i)	f[i] = i;
	h[K][1] = 1, h[K][3] = K;
	for (register int i = K + 1; i <= n; ++i) {
		h[i][0] = -i, h[i][1] = n, h[i][2] = i - n, h[i][3] = n;
	}
	for (register int i = K + 1; i <= n; ++i) {
		ll t = h[i][0];
		h[i][0] = 0; h[i][1] = (h[i][1] - t * h[i - 1][2]) % P;
		h[i][3] = (h[i][3] - t * h[i - 1][3]) % P;
		
		if (h[i][1]) {
			t = quickpow(h[i][1], P - 2);
			h[i][2] = h[i][2] * t % P; h[i][3] = h[i][3] * t % P;
			h[i][1] = 1;
		} else {//不存在逆元
			t = quickpow(h[i][2], P - 2);
			h[i][2] = 1, h[i][3] = h[i][3] * t % P;
			t = h[i + 1][1];
			h[i + 1][1] = 0, h[i + 1][3] = (h[i + 1][3] - t * h[i][3]) % P;//消去下面一行的中间的那个数
			tag[i + 1] = true;
			swap(h[i][2], h[i][1]);//“偏移”数组
			swap(h[i], h[i + 1]);//交换两行
		}
	}
	for (register int i = n - 1; i > K; --i) {
		if (!tag[i]) {
			ll t = h[i][2];
			h[i][2] = 0; h[i][3] = (h[i][3] - t * h[i + 1][3]) % P;
		} else {//对无逆元情况的特殊处理
			ll t = h[i - 1][2];
			h[i - 1][2] = 0, h[i - 1][3] = (h[i - 1][3] - t * h[i + 1][3]) % P;
			t = quickpow(h[i - 1][0], P - 2);
			h[i - 1][3] = h[i - 1][3] * t % P;
			swap(h[i - 1][1], h[i - 1][0]);
			--i;
		}
	}
	for (register int i = K + 1; i <= n; ++i)	f[i] = h[i][3];
}


vector<int> vec[N];
inline void get_ans() {
	for (register int i = 1; i <= n; ++i)
		for (register int j = i; j <= n; j += i)
			vec[j].push_back(i);//计算操作序列
	int nw = 0;
	for (register int i = n; i; --i) {
		if (state[i]) {
			for (register unsigned int j = 0; j < vec[i].size(); ++j) {
				state[vec[i][j]] ^= 1;//计算状态的最少操作次数
			}
			++nw;
		}
	}
	ll res = 1;
	for (register int i = 1; i <= n; ++i)	res = res * i % P;
	printf("%lld\n", ((res * f[nw] % P) + P) % P);
}

int main() {
	read(n), read(K);
	for (register int i = 1; i <= n; ++i)	read(state[i]);
	work();
	get_ans();
	return 0;
}
```

---

## 作者：oisdoaiu (赞：12)


# 50分部分分入手

~~其实有80分~~

首先考虑$k=n$的部分分

- 倒着扫，遇到有$1$的位置就操作一下

正确性：

- 一个点不会被操作$2$次以上，因为$2$次操作相当于没操作

- 操作$i$不会影响到比$i$大的数
- 所以从后往前扫，若遇到$1$不操作，那么前面的操作也不会改变这个$1$，所以必须操作

# 正解

首先若最小步数小于等于$k$，直接输出$ans\cdot n!$就好了

问题在于最小步数大于$k$的情况

容易发现上面那个操作序列是固定的

用一个$01$序列表示每个点需不需要操作（例子：$101100$表示$1,3,4$需要被操作）

然后容易发现最优的操作次数即为这个序列中$1$的个数，也就是说和序列长什么样子无关，只关心有多少个$1$

所以考虑设$f[i]$表示序列中有$i$个$1$的期望操作次数

- 如果乱选选到了$0$，$1$的个数会多一个
- 如果乱选选到了$1$，$1$的个数会少一个
- 所以有：$f[i]=\frac inf[i-1]+\frac{n-i}nf[i+1]+1$

然后是玄学推式子

- 注意到$f[n]=f[n-1]+1$，我们把它作为边界条件
- $f[n-1]=\frac{n-1}n f[n-2]+\frac1n f[n]+1$
- 将第一个式子带入
- $f[n-1]=\frac{n-1}n f[n-2]+\frac1n f[n-1]+\frac{n+1}n$
- 移项后处理一下系数得到：
- $f[n-1]=f[n-2]+\frac{n+1}{n-1}$

发现这个东西长成这个样子$f[n]=f[n-1]+$常数，$f[n-1]=f[n-2]$+常数

然后大胆猜想~~不需要求证~~，加的这个常数(设为$g[i]$)可以递推出来

- $f[i-1]=\frac{i-1}n f[i-2]+\frac{n-i+1}n f[i]+1$
- 因为我们猜想$f[i]=f[i-1]+g[i]$，将它带入
- $f[i-1]=\frac{i-1}n f[i-2]+\frac{n-i+1}n f[i-1]+\frac{n-i+1}ng[i]+1$
- 移项后处理一下系数：
- $f[i-1]=f[i-2]+\frac{n-i+1}{i-1}g[i]+\frac n{i-1}$
- 所以有：$g[i-1]=\frac{(n-i+1)g[i]+n}{i-1}$
- 换个样子：$g[i]=\frac{(n-i)g[i+1]+n}i$

然后$g[i]$就可以倒着递推出来了

接着$f[i]$也可以正着递推出来
# dp式子总结


- $f[k]=k$
- $f[i]=f[i-1]+g[i]$
- $g[n]=1$
- $g[i]=\frac{(n-i)g[i+1]+n}i$
- $ans=f[min\_step]\cdot n!$（$min\_step$指的是原序列最小操作次数）



---

## 作者：CuriousCat (赞：8)

sb 选手的sb做法

看到题

我们把每个格子看成向量，约数的对应位数是1，n个变量n个异或方程，好像只有2^n方个状态啊

emmm

nE(i)=i*E(i-1)+(n-i)*E(i+1))+n;

手算下样例
emmmm

为啥我算了4遍4个数

~~不管了第四遍是512~~

高斯消元一发

蛤95了？（大雾）

这个高斯消元很特殊啊是不是可以O(n)消啊

```
#include <bits/stdc++.h>
#define pb push_back
#define cmin(a, b) (a > b ? a = b : a)
#define cmax(a, b) (a < b ? a = b : a)
#define lop(i, s, t) for(int i = s;i < (t);++i)
#define rep(i, s, t) for(int i = s;i <= (t);++i)
#define dec(i, s, t) for(int i = s;i >= (t);--i)
using namespace std;

#define Pr(f,...) printf(f, ##__VA_ARGS__), fflush(stdout)

typedef long long ll; 

const int N = 3e5 + 50, M = 1005;
const ll P = 100003; 

int n, qk, q, sp[N], s[N], pri[N], pn;

void gao() {
	dec(i, n, 1) {
		if (s[i]) {
			for (int j = 1;j * j <= i;++j) {
				if (i % j == 0) {
					s[j] ^= 1;
					if (i / j != j) s[i / j] ^= 1;
				}
			}
			++q;
		}
	}
}

//E[i] = a * E[i-1] + b
ll E[N],inv[P], a[N], b[N];

int main(int argc,char *argv[]){
#ifndef ONLINE_JUDGE
    freopen("dat.in","r",stdin); 
    freopen("my.out","w",stdout); 
#endif
	scanf("%d%d", &n, &qk); 
	rep(i, 1, n) scanf("%d", s + i); 
	gao(); 
	rep(i, 0, qk) {
		E[i] = i;
	}
	inv[1] = 1;
	rep(i, 2, P - 1) {
		inv[i] = (P - P / i) * inv[P % i] % P;
	}
	//E(n) = E(n - 1) + 1
	a[n] = 1, b[n] = 1;
	dec(i, n - 1, qk + 1) {
		//n*E(i)=i*E(i-1)+(n-i)*E(i+1)+n
		//n*E(i)=i*E(i-1)+(n-i)*(a[i+1]*E(i)+b[i+1])+n
		//(n-(n-i)*a[i+1])*E(i)=i*E(i-1)+(n-i)*b[i+1]+n
		ll x=n-(n-i)*a[i+1]%P;
		x=(x%P+P)%P;
		x=inv[x];
		a[i]=i*x%P;
		b[i]=(n-i)*b[i+1]+n;
		b[i]=b[i]%P*x%P;
	}
	rep(i,qk+1,n){
		E[i]=(a[i]*E[i-1]+b[i])%P;
	}
	ll res = E[q];
	rep(i, 1, n) res = res * i % P;
	printf("%lld\n", res);
    return 0; 
}

```

---

## 作者：Flandre_495 (赞：7)

我很少做概率期望题，这题是某Rainy大佬推荐过来的。。

我期望菜的一pi啊，确实是一道不错的期望题，所以A掉之后写篇题解纪念一下


表示做完题才知道为啥答案乘上$n!$是整数。。。因为期望转移的分母都是1~n的数。

____________

#### 我推dp的方式与其他题解都不相同，但式子最后是一样的，~~但我觉得我的思路更好懂。。。~~

这题一开始一点思路都没有，然后听了机房某Rainy大佬的讲解，仿佛~~感悟了人生~~。

50分：正解总是从部分分来的嘛，而这50分的数据$k=n,$ 显然是想让你明白最优解怎么来的了~，稍微想一想，发现贪心可行，因为亮着最大编号的灯，肯定得用它自己的开关灭掉，用更大的就会有新的灯亮了。所以从n扫到1，哪个灯亮着就动哪个开关，算出来现在最少需要的次数。

100分：在最少步数大于k时，我们随机开关，到了k，就直接+k即为答案，我们发现如果随机着来的话，我们没必要知道状态如何，我们只需要知道此状态最少需要几步。

当我们随机开一个开关没有选中正确的开关时，我们的最少步数又需要多一步。而我们如果选对其中之一，我们的最少步数肯定要少一步，所以我们令$f[i]$表示从最少需要$i$个开关的状态，随机到最少$i-1$个开关的状态时期望的操作次数。

既然我们至少需要$i$个开关，那么这$i$个开关很显然顺序随意，而且不重复，所以我们随机一次有$\frac{i}n$的概率选对$i$个开关之一，即直接跳转到下一步$i-1$。

但我们肯定会选错对吧~


我们把它期望走错的步数算好，再加1，就是走到$i-1$的期望步数。那么它期望走错一次，要加上往回走的1步，再加上从$i+1$回到$i$的期望次数，即$f[i+1]$。我们期望走$\frac{n}i$次到下一层，那我们就期望走错$\frac{n}i-1 = \frac{n-i}i$次。

于是我们有了方程： $f[i] = \frac{n-i}i(f[i+1]+1) + 1$。

最后统计答案即为从 $f[$原始状态的最少步数$]$ 加到$f[k]$，然后记得$+k$,最后记得$*n!$。搞定！

code：
```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#define QWQ cout<<"QwQ"<<endl;
#define ll long long 
#include<vector>
#include<queue>
#include<stack>
#include<map>
using namespace std;
const ll N=101010;
const ll qwq=303030;
const ll inf=0x3f3f3f3f;
const ll mp=100003;
ll n;
ll a[N];
ll k;
ll now;
ll ans;
ll f[N],inv[N];

inline ll read() {
	ll sum = 0, ff = 1; char c = getchar();
	while(c<'0' || c>'9') { if(c=='-') ff = -1; c = getchar(); }
	while(c>='0'&&c<='9') { sum = sum * 10 + c - '0'; c = getchar(); }
	return sum * ff;
}

int main() {
	n = read(); k = read();
	for(ll i=1;i<=n;i++) a[i] = read();
	inv[1] = 1; for(ll i=2;i<=n;i++) inv[i]=( (mp-mp/i) * inv[mp%i] )%mp;
	for(ll i=n;i>=1;i--) {
		if(!a[i]) continue; now++;
		for(ll j=1;j<=sqrt(i);j++) {
			if(i%j==0) {
				a[j] ^= 1;
				if(i/j!=j)
				a[i/j] ^= 1;
			}
		}
	}
	f[n] = 1;
	for(ll i=n-1;i>k;i--)
	f[i] = (n-i) * (f[i+1]+1) %mp * inv[i] %mp + 1;
	for(ll i=k+1;i<=now;i++) ans = (ans+f[i]) % mp;
	for(ll i=n-1;i>=1;i--) n = (n*i) % mp;
	printf("%lld",(ans+min(k,now))*n%mp);
	return 0;
}


```


---

## 作者：Tyher (赞：6)

### 首先考虑最优策略怎么做：

- 从大往小贪心显然是正确的，因为最大的数不会被小数影响，所以先消除最大的，再依次往小的消除。
- 现在的问题就在于快速枚举一个数的约数，这个可以先枚举一个数的倍数，然后加在对应数的$vector$里面，最后只要查找就可以了。
- 这个复杂度是调和级数，为$nlogn$。

### 考虑随机怎么做。
- 我们发现当前局面是什么对随机都是没有影响的，就是不管你这个局面是什么样，如果他的最优策略是$n$步，那么他就和其他$n$步的局面没有区别。
- 因为操作的策略是唯一确定的，所以我们不需要考虑局面究竟是什么样子，只需要知道这个局面的步数就行了。
- 设$f_i$表示到第$i$步，转移到$i-1$步的期望步数是多少，有:
#### $$f_i=1+\frac {n-i}{n}*(f_{i+1}+f_i)$$
- 如果操作在最优的$i$步中，就可以了，否则还要回到这一步，再走到上一步。
- 因为操作顺序是不影响答案的，所以我们认为只要在这$i$步里面，都是满足要求的步骤，否则就是不合法的步骤。
- 化简一下
#### $$f_i=(n+(n-i)*f_{i+1})*inv(i)$$
- 线性求逆元后递推即可，注意$f_n=1$。

---

## 作者：封禁用户 (赞：2)

~~我这个小菜鸡来水题解，完全是因为没有看到和我一样解dp的人QAQ~~

#### $50\%$ 的数据
对于 $k=n$ 的数据，我们只需要求出，最少要操作多少次，能够关上所有的灯。

注意到 $n$ 号灯只能用开关 $n$ 控制，所以开关 $n$ 是否要操作是固定的。此时，对于 $n-1$ 号灯来说，前面的开关都无法调整，所以开关 $n-1$ 是否要操作也唯一固定。对于 $n-2,n-3,\dots,1$ 都是一样的。

调和级数 $\mathcal O(\sum_{i=1}^{n}\lfloor\frac{n}{i}\rfloor)=\mathcal O(n\log n)$ ，所以复杂度有保障。

#### $100\%$ 的数据
从上面的分析来看，最优操作方案是唯一的。所以，如果我们按了本就该按的开关，最优方案就可以少按一次；反之，最优方案就要多按一次开关。所以，__转移只跟最优方案需要按开关的次数有关__。

于是，我们可以设计出一个 $dp$ ，用 $f(x)$ 表示最优方案需要按 $x$ 次按钮时，期望操作次数。很简单可以写出

$$f(x)=\frac{x}{n}\cdot f(x-1)+\frac{n-x}{n}\cdot f(x+1)+1$$

$$\Rightarrow\;(n-x)\cdot f(x+1)=n\cdot f(x)-x\cdot f(x-1)-n$$

这个式子只对 $x\in(k,n]$ 有效，所以不能把 $x=k$ 直接代入求值。但是我们可以解方程！

不妨设

$$f(x)=a_x\cdot f(k+1)+b_x$$

根据 $dp$ 方程式，$a_{x+1}$ 可以由 $a_{x-1},a_x$ 推出，$b$ 类似。边界也很好写，

$$\begin{cases}a_k=0\\b_k=f(k)\end{cases},\;\begin{cases}a_{k+1}=1\\b_{k+1}=0\end{cases}$$

最后一路推到 $a_{n+1},b_{n+1}$ ，拿到这个式子

$$(n-n)\cdot f(n+1)=a_{n+1}\cdot f(k+1)+b_{n+1} = 0$$

$$\Rightarrow\;f(k+1)=\frac{-b_{n+1}}{a_{n+1}}$$

如果 $a_{n+1}=0$ 呢？不会的。下证 $\forall i\in[k,n),a_{i}<a_{i+1}$ 。

利用数学归纳法。$0=a_k<a_{k+1}=1$ 。而在 $i\in(k,n),a_{i-1}<a_i$ 时，我们有

$$a_{i+1}=na_i-ia_{i-1}=a_i+(n-i-1)a_i+i(a_i-a_{i-1})>a_i$$

所以 $a_{n-1}<a_n$ ，由是则 $a_{n+1}=n(a_n-a_{n-1})>0$ ，故可行。

~~话说为什么我想不到题解里面那些简单的做法啊 TAT~~

# 代码
这个模数 $10^5+3$ 有几个好处：

- 是一个小质数，逆元均存在。
- 略大于 $n$ ，不会出现恰好除以该模数的情况。

```cpp
#include <cstdio>
#include <iostream>
#include <vector>
using namespace std;
typedef long long int_;
inline int readint(){
	int a = 0; char c = getchar(), f = 1;
	for(; c<'0'||c>'9'; c=getchar())
		if(c == '-') f = -f;
	for(; '0'<=c&&c<='9'; c=getchar())
		a = (a<<3)+(a<<1)+(c^48);
	return a*f;
}

const int zxy = 100003;
int inv[zxy], a[zxy], n, dp[zxy];
vector< int > son[zxy];

int main(){
	inv[0] = inv[1] = 1; n = readint();
	for(int i=2; i<zxy; ++i)
		inv[i] = (0ll+zxy-zxy/i)
			*inv[zxy%i]%zxy;
	int k = readint();
	// dp[i] = 1+i*dp[i-1]/n+(n-i)*dp[i+1]/n
	// (n-i)*dp[i+1] = n*dp[i]-n-i*dp[i-1]
	for(int i=0; i<=k; ++i) dp[i] = i;
	int_ a0 = 0, b0 = k, a1 = 1, b1 = 0;
	for(int i=k+1; i<=n; ++i){
		// dp[i-1] = a0*dp[k+1]+b0
		// dp[ i ] = a1*dp[k+1]+b1
		int_ a2 = (n*a1-i*a0)%zxy;
		int_ b2 = (n*b1-n-i*b0)%zxy;
		a2 = (a2*inv[n-i]%zxy+zxy)%zxy;
		b2 = (b2*inv[n-i]%zxy+zxy)%zxy;
		a0 = a1, b0 = b1; // 向前移动
		a1 = a2, b1 = b2; // 向前移动
	}
	dp[k+1] = (zxy-b1)*inv[a1]%zxy;
	for(int i=k+1; i<n; ++i){
		int &t = dp[i+1] = (1ll*n*dp[i]
			-n-1ll*i*dp[i-1])%zxy;
		t = (0ll+t+zxy)*inv[n-i]%zxy;
	}
	for(int i=1; i<=n; ++i)
		a[i] = readint();
	for(int i=1; i<=n; ++i)
		for(int j=1; j<=n/i; ++j)
			son[i*j].push_back(i);
	int cnt = 0;
	for(int i=n; i>=1; --i){
		cnt += a[i];
		for(auto j : son[i])
			a[j] ^= a[i];
	}
	int ans = dp[cnt];
	for(int i=1; i<=n; ++i)
		ans = 1ll*ans*i%zxy;
	printf("%d\n",ans);
	return 0;
}
```



---

## 作者：小塘空明 (赞：1)

~~这道历史遗留问题终于解决了~~

可以发现每盏灯最多只会开一次。

因为每次开灯影响的都是它的约数，所以它影响的范围严格小于它。

题目叫我们求最小操作次数，这是个比较经典的贪心模型。从大往小扫，如果有一盏灯开着，就把它关掉，并对它的约数集合进行操作，累计次数cnt。

当cnt小于k时，cnt就是答案。

否则，此时有cnt个正确操作，我们考虑把cnt减到k的期望。

设f[i]表示有i个正确选择，将正确选择减到i-1的期望。

f[i]=i/n+(1-(i/n))*(1+f[i+1]+f[i])

i/n可能正确操作，不正确操作时除了本次操作外，还要期望进行f[i],f[i+1]次操作。

预处理下逆元即可。

```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<string>
#include<cstring>
#include<cmath>
#include<vector>
using namespace std;
typedef long long ll;
const ll size=1e5+10,p=1e5+3;
ll n,ans,k,cnt,a[size],inv[size],f[size];vector<ll> g[size];
inline ll read(){
	ll x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
	return x*f;
}
int main(){
	n=read();k=read();inv[1]=1;
	for(ll i=1;i<=n;i++) a[i]=read();
	for(ll i=2;i<=n;i++) inv[i]=((p-p/i)*inv[p%i])%p;
	for(ll i=1;i<=n;i++){
		for(ll j=i;j<=n;j+=i) g[j].push_back(i);
	}
	for(ll i=n;i>=1;i--){
		if(a[i]){
			cnt++;
			for(ll j=0;j<g[i].size();j++){
				a[g[i][j]]^=1;
			}
		}
	}
	if(cnt<=k) ans=cnt;
	else{
		f[n]=1;
		for(ll i=n-1;i>=1;i--) f[i]=(n+(n-i)*f[i+1])*inv[i]%p;
		for(ll i=cnt;i>k;i--) ans=(ans+f[i])%p;
		ans=(ans+k)%p;
	}
	for(ll i=1;i<=n;i++) ans=(ans*i)%p;
	printf("%lld\n",ans);
	return 0;
}
```


---


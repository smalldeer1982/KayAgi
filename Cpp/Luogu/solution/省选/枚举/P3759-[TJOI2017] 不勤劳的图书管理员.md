# [TJOI2017] 不勤劳的图书管理员

## 题目描述

加里敦大学有个帝国图书馆，小豆是图书馆阅览室的一个书籍管理员。

他的任务是把书排成有序的，所以无序的书让他产生厌烦。

两本乱序的书会让小豆产生这两本书页数的和的厌烦度。

现在有 $n$ 本被打乱顺序的书，在接下来 $m$ 天中每天都会因为读者的阅览导致书籍顺序改变位置。

因为小豆被要求在接下来的 $m$ 天中至少要整理一次图书。

小豆想知道，如果他前 $i$ 天不去整理，第 $i$ 天他的厌烦度是多少，这样他好选择厌烦度最小的那天去整理。

## 说明/提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，$1\le a_i,x_j,y_j\le n \le 5\times 10^3$，$1\le m\le 5\times 10^3$， $1\le v_i\le10^5$。
- 对于 $100\%$ 的数据，$1\le a_i,x_j,y_j\le n\le 5\times 10^4$，$1\le m\le 5\times 10^4$，$1\le v_i\le 10^5$。

## 样例 #1

### 输入

```
5 5
1 1
2 2
3 3
4 4
5 5
1 5
1 5
2 4
5 3
1 3```

### 输出

```
42
0
18
28
48```

# 题解

## 作者：AubRain (赞：73)

大家好，我用$O(n^2)$**暴力**过了这道题，特地来分享一波卡常技巧。不喜请轻喷。


首先看到数据范围只有$5W$，而且时间居然开了$5s$，这是我们暴力的前提。

这里默认大家都理解了这道题的意思，然后就是我的一些经验了。

1、++i 比 i++ 要快。

2、语句数量要尽量少，能压成一句话就要压。

3、能不用$ long\;long $就别用，只有在需要的地方开。

4、$while$ 循环速度要比 $for$ 循环速度快好多。

5、**尽量不要取模!!**，先估算一下时机，到快要爆$long\;long$ 的时候再取模！（会快很多）

6、别忘了打开各种优化开关。以下是模板。

```cpp
%:pragma GCC optimize(3)
%:pragma GCC optimize("Ofast")
%:pragma GCC optimize("inline")
%:pragma GCC optimize("-fgcse")
%:pragma GCC optimize("-fgcse-lm")
%:pragma GCC optimize("-fipa-sra")
%:pragma GCC optimize("-ftree-pre")
%:pragma GCC optimize("-ftree-vrp")
%:pragma GCC optimize("-fpeephole2")
%:pragma GCC optimize("-ffast-math")
%:pragma GCC optimize("-fsched-spec")
%:pragma GCC optimize("unroll-loops")
%:pragma GCC optimize("-falign-jumps")
%:pragma GCC optimize("-falign-loops")
%:pragma GCC optimize("-falign-labels")
%:pragma GCC optimize("-fdevirtualize")
%:pragma GCC optimize("-fcaller-saves")
%:pragma GCC optimize("-fcrossjumping")
%:pragma GCC optimize("-fthread-jumps")
%:pragma GCC optimize("-funroll-loops")
%:pragma GCC optimize("-fwhole-program")
%:pragma GCC optimize("-freorder-blocks")
%:pragma GCC optimize("-fschedule-insns")
%:pragma GCC optimize("inline-functions")
%:pragma GCC optimize("-ftree-tail-merge")
%:pragma GCC optimize("-fschedule-insns2")
%:pragma GCC optimize("-fstrict-aliasing")
%:pragma GCC optimize("-fstrict-overflow")
%:pragma GCC optimize("-falign-functions")
%:pragma GCC optimize("-fcse-skip-blocks")
%:pragma GCC optimize("-fcse-follow-jumps")
%:pragma GCC optimize("-fsched-interblock")
%:pragma GCC optimize("-fpartial-inlining")
%:pragma GCC optimize("no-stack-protector")
%:pragma GCC optimize("-freorder-functions")
%:pragma GCC optimize("-findirect-inlining")
%:pragma GCC optimize("-fhoist-adjacent-loads")
%:pragma GCC optimize("-frerun-cse-after-loop")
%:pragma GCC optimize("inline-small-functions")
%:pragma GCC optimize("-finline-small-functions")
%:pragma GCC optimize("-ftree-switch-conversion")
%:pragma GCC optimize("-foptimize-sibling-calls")
%:pragma GCC optimize("-fexpensive-optimizations")
%:pragma GCC optimize("-funsafe-loop-optimizations")
%:pragma GCC optimize("inline-functions-called-once")
%:pragma GCC optimize("-fdelete-null-pointer-checks")
```
当你把上面的优化都用到之后，你的程序就可以轻松 $AC$ 这道题了。最慢一个点只跑了 $4s$。

```cpp
#include<bits/stdc++.h>
#define N 50001
using namespace std;

inline void rd(int &X){
    X=0;char ch=0;
    while(!isdigit(ch))ch=getchar();
    while( isdigit(ch))X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
}

int n,m,p=1e9+7,i;
long long l1,r1,ans;
int f[N],g[N],x[N],y[N],l,r;

inline void add(int x,int y){
    for(;x;x-=x&-x) f[x]+=y,g[x]++;
}
inline void ask(int x){
    for(l1=r1=0;x<=n;x+=x&-x) l1+=f[x],r1+=g[x];
}
signed main()
{
    rd(n);rd(m);
    for(i=1;i<=n;++i) rd(x[i]),rd(y[i]),ask(x[i]),add(x[i],y[i]),ans+=l1+r1*y[i];
    while(m--)
    {
          rd(l);rd(r); if(l>r) swap(l,r); i=l+1;
          while(i<r)
          {
              if(x[i]>x[l]) ans+=y[i]+y[l];
              if(x[i]<x[r]) ans+=y[i]+y[r];
              if(x[i]<x[l]) ans-=y[i]+y[l];
              if(x[i]>x[r]) ans-=y[i]+y[r];
              ++i;
          }
          if(x[l]>x[r]) ans-=y[l]+y[r];
          if(x[l]<x[r]) ans+=y[l]+y[r];
          swap(x[l],x[r]);swap(y[l],y[r]);
          printf("%lld\n",ans=(ans%p+p)%p);
        }
}
```
**后记：**

暴力过数据结构题，你并不会收获什么，~~只能获得成就感~~。所以有时候还是需要自己手敲代码的，这片题解仅供大家娱乐和参考。

不过，反正快乐就行了呗（逃~

---

## 作者：p_b_p_b (赞：14)

裸的动态逆序对,但维护的东西有两个，一个是书页数，一个是书数

一开始写了线段树套平衡树，T掉了，于是改为二维线段树,外层区间,内层权值（书的优先级）

对某一本书统计厌烦度时只需ans+=给它作出贡献的书的总页数+(给它作出贡献的书的个数*自己的页数)；

若两本书的位置是x、y（x<y），则交换它们时1~（x-1）和（y+1）~n的书可以不予考虑

代码里有注释

```cpp
// P3759 [TJOI2017]不勤劳的图书管理员
//二维线段树 
#include<bits/stdc++.h>
#define Pli pair<ll,int>
#define mp make_pair
#define fir first
#define sec second
using namespace std;
typedef long long ll;
const ll sz=50050,N=sz*256,mod=1e9+7,RNK=51000;
void Plus(Pli &x,Pli y){x.fir+=y.fir;x.sec+=y.sec;}
/**************************内层线段树**************************/
//权值线段树，书本优先级为权值 
ll size[N];//书页数 
int ch[N][2],cnt[N],tot;//儿子节点，书数，动态开点计数 
queue<int>rec;//垃圾回收 
#define lson ch[k][0],l,mid
#define rson ch[k][1],mid+1,r
void destroy(int &k){size[k]=cnt[k]=ch[k][0]=ch[k][1]=0;rec.push(k);k=0;}
int newnode()
{
    if (rec.empty()) return ++tot;
    int ret=rec.front();
    rec.pop();
    return ret;
}
void add(int &k,int l,int r,int pos,ll x,int y)//于pos处插入x页书，y本书，可以为负 
{
    if (!k) k=newnode();
    size[k]+=x;cnt[k]+=y;
    size[k]=(size[k]+mod)%mod;
    if (l==r)
    {
    	if (!cnt[k]) destroy(k);
    	return;
    }
    int mid=(l+r)>>1;
    if (pos<=mid) add(lson,pos,x,y);
    else add(rson,pos,x,y);
    if (!cnt[k]) destroy(k);
}
Pli Query(int k,int l,int r,int x,int y)//x~y区间书页数、书数 
{
    if (!k) return mp(0ll,0ll);
    if (x<=l&&r<=y) return mp(size[k],cnt[k]);
    int mid=(l+r)>>1;
    Pli ret;
    ret.fir=0ll;ret.sec=0;
    if (x<=mid) Plus(ret,Query(lson,x,y));
    if (y>mid) Plus(ret,Query(rson,x,y));
    return ret;
}
#undef lson
#undef rson
/*************************外层线段树***************************/ 
#define lson k<<1,l,mid
#define rson k<<1|1,mid+1,r
int root[N];
void insert(int k,int l,int r,int pos,int x,int sum)
{
    add(root[k],1,RNK,x,sum,1);
    if (l==r) return;
    int mid=(l+r)>>1;
    if (pos<=mid) insert(lson,pos,x,sum);
    else insert(rson,pos,x,sum);
}
void del(int k,int l,int r,int pos,int x,int sum)
{
    add(root[k],1,RNK,x,-sum,-1);//负数，即删除 
    if (l==r) return;
    int mid=(l+r)>>1;
    if (pos<=mid) del(lson,pos,x,sum);
    else del(rson,pos,x,sum);
}
Pli Ask(int k,int l,int r,int x,int y,int L,int R)
//x~y(位置区间)内L~R(权值区间)的书页数、书数  
{
    if (x<=l&&r<=y) return Query(root[k],1,RNK,L,R);
    int mid=(l+r)>>1;
    Pli ret;
    ret.fir=0ll;ret.sec=0;
    if (x<=mid) Plus(ret,Ask(lson,x,y,L,R));
    if (y>mid) Plus(ret,Ask(rson,x,y,L,R));
    ret.fir%=mod;
    return ret;
}
#undef lson
#undef rson
/************************************************************/ 
int a[sz],n,m;
ll sum[sz],ans;
//a[i] i位置上的书的优先级
//sum[i] i位置上的书的书页数 
ll read()
{
    register ll ret=0;
    register char ch=getchar();
    while (ch>'9'||ch<'0') ch=getchar();
    while (ch<='9'&&ch>='0') ret=(ret<<1)+(ret<<3)+(ch^48),ch=getchar();
    return ret;
}
int main()
{
 	register int i,x,y;
 	n=read();m=read();
 	for (i=1;i<=n;i++) a[i]=read(),sum[i]=read()%mod;
 	for (i=1;i<=n;i++) insert(1,1,n,i,a[i],sum[i]);
 	for (i=1;i<=n;i++)
 	{
 		Pli cur=Ask(1,1,n,i+1,n,1,a[i]);
 		ans+=sum[i]*cur.sec+cur.fir;
 		ans%=mod;
 	}
    while(m--)
    {
        x=read(),y=read();
        if(x>y) swap(x,y);
        if(x==y){printf("%lld\n",ans);continue;}//并没有交换 
        int L=a[x],R=a[y],cnt,mn=min(L,R),mx=max(L,R);
        ll size;
        Pli cur;
        
        //x~y(位置)中权值大于mn而小于mx的书会产生贡献 
        cur=Ask(1,1,n,x,y,mn+1,mx-1);
        size=cur.fir,cnt=cur.sec;
        ans+=(mn==L?1:-1)*(2*size%mod+(ll)(cnt+1)*(sum[x]+sum[y])%mod)%mod;
        ans%=mod;
        
        //x~y(位置)中权值小于mn的书会产生贡献 
        cur=Ask(1,1,n,x,y,1,mn-1);
        cnt=cur.sec;
        (ans+=(ll)cnt*(sum[y]-sum[x])%mod)%=mod;
        
        //x~y(位置)中权值大于mx的书会产生贡献 
        cur=Ask(1,1,n,x,y,mx+1,n);
        cnt=cur.sec;
        (ans+=(ll)cnt*(sum[x]-sum[y])%mod)%=mod;
        
        if(ans<0) ans+=mod;
        
 		del(1,1,n,x,a[x],sum[x]);del(1,1,n,y,a[y],sum[y]);//删掉原来的 
 		insert(1,1,n,x,a[y],sum[y]);insert(1,1,n,y,a[x],sum[x]);//加上新的 
        swap(a[x],a[y]);swap(sum[x],sum[y]);//换 
        
        printf("%lld\n",ans);
    }
}
```

我好菜啊，这题竟然调了3天qwq

---

## 作者：KiDDOwithTopTree (赞：10)

题目在这：[传送门](https://www.luogu.com.cn/problem/P3759)。

不得不说这一题坑点有很多，实在难调。

### 做法：树状数组套主席树（树状数组套动态开点值域线段树）。

~~不知道是不是我语文不好，感觉这题像个语文题……~~

~~为了避免有像我一样语文不好的 dalao~~，我们还是要讲一下题意：

给你一个数列，第 i 个数的优先级为 $a_i$，权值为 $v_i$，让你求出以优先级 $a_i$ 为基准的逆序对数量，并且 ans 要加上每一对逆序对 x，y 的两个数的权值 $v_x$ 和 $v_y$，求出每一次交换 x 和 y 后 ans 的值。

~~是不是更不懂了。~~

然后，开始思考思路：

首先，看到求逆序对、交换两个数，我想到的便是[这题](https://www.luogu.com.cn/problem/P3157)。

当 x 交换到 y 处后，区间 $[1,x-1]$ 与 $a_x$ 的逆序对**不会改变**，区间 $[y+1,n]$ 与 $a_x$ 的逆序对也**不会改变**，但是区间 $[x+1,y-1]$ 与 $a_x$ 的逆序对**会改变**，因为进行交换 x 和 y 后这段区间原来与 $a_x$ 逆序对变成了顺序对，原来与 $a_x$ 的顺序对变成了逆序对。而 y 则同理。如果想做类似这种题目而不需要维护权值 $v_i$，可以去看看[这题](https://www.luogu.com.cn/problem/P1975)。

当然，我们还没有判断 x 与 y 的关系：如果交换前 $a_x>a_y$，即原来 $a_x$ 与 $a_y$ 是逆序对，那么交换后 ans 则要减去这对逆序对的贡献，反之则加上。

大概思路讲完后，我们来盘点一下**坑点**：

1.  $x_j$ 会大于 $y_j$ ，这时我们需要交换 $x_j$ 和 $y_j$ 再进行操作。
2. 做了 $\bmod$ 运算后再减数可能会减成负数，这时我们需要在输出前把 ans 加上 $\bmod$ 再输出。
3. 不知道是不是我的代码问题，此题卡空间……虽是动态开点的，但还是过不去。这时我们需要进行**垃圾回收**来节省一些空间。
4. 在我的写法中，需要特判 $x_j=y_j$ 的情况。~~我也不知道为什么，反正加上我就对了。~~

可能有些 dalao 会问什么是垃圾回收，我这里给出一个**较为感性**的回答：

因为线段树会删除节点，但是节点删除之后可能之后都没用了（操作不会调用到这个节点），所以我们可以开一个栈，存放没用的节点编号，新建节点时先判断栈中有没有没用的节点，如果有就用栈顶的编号，再弹出栈顶，否则就新开一个节点。

这里给出我的代码（带注释）：

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
using namespace std;
const int N=5e4+10,mod=1e9+7;
struct segment_tree{
	int lson,rson;
	long long sum;
	int val;
};
segment_tree hjt[400*N];
int root[N],p[N],v[N],sta[N];//sta就是垃圾回收的栈 
int tmp[2][20];
int n,m,tot,top;
inline int lowbit(int x){
	return x&-x;
}
void hjt_ins(int &now,int l,int r,int pos,int val){
	if(!now)
		now=top?sta[top--]:++tot;//垃圾回收 
	hjt[now].val++;
	hjt[now].sum=(hjt[now].sum+val)%mod;
	if(l==r)
		return ;
	int mid=l+r>>1;
	if(pos<=mid)
		hjt_ins(hjt[now].lson,l,mid,pos,val);
	else
		hjt_ins(hjt[now].rson,mid+1,r,pos,val);
}
void hjt_del(int &now,int l,int r,int pos,int val){
	if(!now)
		now=top?sta[top--]:++tot;//垃圾回收 
	hjt[now].val--;
	hjt[now].sum=(hjt[now].sum-val)%mod;
	if(l==r)
		return ;
	int mid=l+r>>1;
	if(pos<=mid)
		hjt_del(hjt[now].lson,l,mid,pos,val);
	else
		hjt_del(hjt[now].rson,mid+1,r,pos,val);
	if(!hjt[now].val)//判断是否要扔进栈里 
		sta[++top]=now,now=0;
}
long long hjt_query1(int l,int r,int pos,int val){ 
	if(l==r)
		return 0;
	long long key=0,sum=0;
	for(int i=1;i<=tmp[0][0];i++)
		key=(key+hjt[hjt[tmp[0][i]].rson].val)%mod;
	for(int i=1;i<=tmp[1][0];i++)
		key=(key-hjt[hjt[tmp[1][i]].rson].val)%mod;
	for(int i=1;i<=tmp[0][0];i++)
		sum=(sum+hjt[hjt[tmp[0][i]].rson].sum)%mod;
	for(int i=1;i<=tmp[1][0];i++)
		sum=(sum-hjt[hjt[tmp[1][i]].rson].sum)%mod;
	int mid=l+r>>1;
	if(pos<=mid){
		for(int i=1;i<=tmp[0][0];i++)
			tmp[0][i]=hjt[tmp[0][i]].lson;
		for(int i=1;i<=tmp[1][0];i++)
			tmp[1][i]=hjt[tmp[1][i]].lson;
		return (key*val%mod+sum+hjt_query1(l,mid,pos,val))%mod;
	}
	else{
		for(int i=1;i<=tmp[0][0];i++)
			tmp[0][i]=hjt[tmp[0][i]].rson;
		for(int i=1;i<=tmp[1][0];i++)
			tmp[1][i]=hjt[tmp[1][i]].rson;
		return hjt_query1(mid+1,r,pos,val);
	}
}
int hjt_query2(int l,int r,int pos,int val){
	if(l==r)
		return 0;
	long long key=0,sum=0;
	for(int i=1;i<=tmp[0][0];i++)
		key=(key+hjt[hjt[tmp[0][i]].lson].val)%mod;
	for(int i=1;i<=tmp[1][0];i++)
		key=(key-hjt[hjt[tmp[1][i]].lson].val)%mod;
	for(int i=1;i<=tmp[0][0];i++)
		sum=(sum+hjt[hjt[tmp[0][i]].lson].sum)%mod;
	for(int i=1;i<=tmp[1][0];i++)
		sum=(sum-hjt[hjt[tmp[1][i]].lson].sum)%mod;
	int mid=l+r>>1;
	if(pos<=mid){
		for(int i=1;i<=tmp[0][0];i++)
			tmp[0][i]=hjt[tmp[0][i]].lson;
		for(int i=1;i<=tmp[1][0];i++)
			tmp[1][i]=hjt[tmp[1][i]].lson;
		return hjt_query2(l,mid,pos,val);
	}
	else{
		for(int i=1;i<=tmp[0][0];i++)
			tmp[0][i]=hjt[tmp[0][i]].rson;
		for(int i=1;i<=tmp[1][0];i++)
			tmp[1][i]=hjt[tmp[1][i]].rson;
		return (key*val%mod+sum+hjt_query2(mid+1,r,pos,val))%mod;
	}
}
void bit_ins(int now,int pos,int val){
	for(int i=now;i<=n;i+=lowbit(i))
		hjt_ins(root[i],1,n,pos,val);
}
void bit_del(int now,int pos,int val){
	for(int i=now;i<=n;i+=lowbit(i))
		hjt_del(root[i],1,n,pos,val);
}
long long bit_query1(int l,int r,int pos,int val){
//查询l~r中所有优先级>pos与val的贡献和 
	if(l>r)//特判 
		return 0;
	for(int i=0;i<20;i++)
		tmp[0][i]=tmp[1][i]=0;
	for(int i=r;i;i-=lowbit(i))
		tmp[0][++tmp[0][0]]=root[i];
	for(int i=l-1;i;i-=lowbit(i))
		tmp[1][++tmp[1][0]]=root[i];
	return hjt_query1(1,n,pos,val);
}
long long bit_query2(int l,int r,int pos,int val){
//查询l~r中所有优先级Kpos与val的贡献和 
	if(l>r)//特判 
		return 0;
	for(int i=0;i<20;i++)
		tmp[0][i]=tmp[1][i]=0;
	for(int i=r;i;i-=lowbit(i))
		tmp[0][++tmp[0][0]]=root[i];
	for(int i=l-1;i;i-=lowbit(i))
		tmp[1][++tmp[1][0]]=root[i];
	return hjt_query2(1,n,pos,val);
}
int main(){
	cin>>n>>m;
	long long ans=0;
	for(int i=1;i<=n;i++){
		cin>>p[i]>>v[i];
		bit_ins(i,p[i],v[i]);//插入节点 
		ans+=bit_query1(1,i-1,p[i],v[i]);//加上新增的逆序对 
		ans%=mod;
	}
	int x,y;
	for(int i=1;i<=m;i++){
		cin>>x>>y;
		if(x>y)//特判x>y的情况 
			swap(x,y);
		if(x==y)//特判x=y的情况 
			goto s;//goto用法，表示跳到s处，但是最好不要用 
		ans-=bit_query2(x+1,y-1,p[x],v[x]);//减去原来的逆序对 
		ans%=mod;
		ans+=bit_query1(x+1,y-1,p[x],v[x]);//加上新增的逆序对 
		ans%=mod;
		ans-=bit_query1(x+1,y-1,p[y],v[y]);//减去原来的逆序对 
		ans%=mod;
		ans+=bit_query2(x+1,y-1,p[y],v[y]);//加上新增的逆序对 
		ans%=mod;
		if(p[x]>p[y])//原来p[x]与p[y]是逆序对 
			ans-=v[x]+v[y];//减去贡献 
		else//原来p[x]与p[y]不是逆序对 
			ans+=v[x]+v[y];//加上贡献 
		ans%=mod;
		bit_del(x,p[x],v[x]);//在x处删除x 
		bit_del(y,p[y],v[y]);//在y处删除y 
		bit_ins(x,p[y],v[y]);//在x处插入y 
		bit_ins(y,p[x],v[x]);//在y处插入x 
		swap(p[x],p[y]);
		swap(v[x],v[y]);
		//以上步骤完成x与y的交换 
		s://goto就跳到这里 
		if(ans<0)//特判ans减成负数的情况 
			ans+=mod;
		cout<<ans<<'\n';
	}
}
```

---

## 作者：I_AM_HelloWord (赞：9)

先膜楼下Dalao，手打树套树。


一开始想练一练码树套树的能力，写了个线段树套sbt，发现有些删除操作的标记更新好麻烦。


于是再看看数据$n<=50000$,于是用暴力分块+二分水过去了。

分块就很暴力了哈。


先建$Block$个块，把每个位置的书都塞进块里，然后把块内按书的编号排个序，然后维护一个前缀和。


至于初始状态，用树状数组计算一下带权逆序对就好了。


对于修改操作，实际上每次修改的$x_i,x_j$两个位置的书的顺序，只会对区间$[x_i,x_j]$内的逆序对的贡献产生影响，于是我们暴力重新计算这个区间内的贡献。


我们实际上是在处理$[x_i+1,x_j-1]$这个区间。

暴力枚举两端不是整个块的，

若对于某个$k$，有$x_i>x_k$，那么我们将上一次计算出的$ans-=v_i+v_k$，因为$x_i$与$x_j$交换了位置，所以这对逆序对就没有贡献了。同理，若对于某个$k$,有$x_i<x_k$,则$ans+=v_i+v_k$。对于$x_j$的贡献影响则反之。


然后暴力枚举中间的完整的块，在块中二分找到最大的编号小于$x_i$的那个位置，前缀和就是在这个块中标号小于$x_i$的所有的书的$val$值的和。与上面类似，我们的$ans$需要减去在这个块中，标号小于$x_i$的书的$val$和，然后再加上编号大于$x_i$的书的$val$和。同时减去这个块中编号小于$x_i$的书的个数乘以$v_i$，再加上这个块中标号大于$x_i$的书的个数乘以$v_i$。


注意到其实我们二分出了上面的那个位置，那么这整个块的和减去该位置的前缀和就是编号大于$x_i$的书的$val$和。整个块的大小减去该位置就是编号大于$x_i$的书的个数。


那么如果令$len=en-st+1,rank=binarysearch(st,en,x_i)-st$,$temp=sum[rank]$

则根据上述，应有


$ans+=(len-rank-rank)*v_i+sum[len]-temp-temp$


这里有一点不太好理解，这里的$len-rank$就是大于$x_i$的书的个数，再$-rank$就是小于$x_i$的书的个数，然后把上面说的加减过程合并了一下就得到这个式子了。


对于$x_j$同理即可。


然后注意一下特判整个块内的编号都大于$x_i$就好了。


最后还有如果$x_i<x_j$,那么$ans+=v_i+v_j$,反之则减。


计算完新解后，直接交换一下$i,j$然后暴力重构$i,j$所在的块就好了。


参考代码：


```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#define rint register int
using namespace std;
typedef long long ll;
const int mod=1e9+7;
const int N=1e5+5;
int n,m,block;
struct Answer{
    int u;
    ll v;
    Answer(int u=0,ll v=0):u(u),v(v){}
    inline bool operator < (const Answer &rhs) const {
        return u<rhs.u;
    }
}a[N],b[N];
int st[N],bl[N];
ll c2[N],c1[N];
inline int read(){
    int x=0,f=1;char ch=getchar();
    while (ch<'0' || ch>'9'){if (ch=='-')f=-1;ch=getchar();}
    while ('0'<=ch && ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return x*f;
}
inline int find(int k,int ql,int qr){
    rint l=ql,r=qr;
    if (b[ql].u>k) return ql-1;
    while (l<r){
        rint mid=(l+r+1)>>1;
        if (b[mid].u<=k) l=mid;
        else r=mid-1;
    }
    return l;
}
inline void build(int x){
    for (rint i=st[x];i<st[x+1];++i)
        b[i]=a[i];
    sort(b+st[x],b+st[x+1]);
    for (rint i=st[x]+1;i<st[x+1];++i)
        (b[i].v+=b[i-1].v)%=mod;
}
inline void add(int x,ll y){
    for (rint i=x;i<=N-4;i+=i&(-i))
        (c1[i]+=y)%=mod,
        ++c2[i];
}
inline ll getsum(int x,ll y){
    ll ret=0,sz=0;
    for (rint i=x;i;i-=i&(-i))
        (ret+=c1[i])%=mod,
        sz+=c2[i];
    return (ret+sz*y)%mod;    
}    
int main(){
    n=read(),m=read();
    rint block=floor(sqrt(n)/2);
    for (rint i=1;i<=n;++i)
        a[i].u=read(),a[i].v=read();
    for (rint i=1;i<=n;++i,bl[i]=bl[i-1])
        if (i%block==1) st[++bl[i]]=i;
    bl[n+1]=bl[n]+1;
    st[bl[n+1]]=n+1;
    for (rint i=1;i<=bl[n];++i)
        build(i);
    ll ans=0;
    for (rint i=n;i>=1;--i){
        (ans+=getsum(a[i].u,a[i].v))%=mod;
        add(a[i].u,a[i].v);
    }
    for (rint i=1;i<=m;++i){
        rint x=read(),y=read();
        if (x>y)swap(x,y);
        rint fx=bl[x],fy=bl[y];
        ll tt=0;
        if (x!=y){
            if (a[x].u<a[y].u) tt=a[x].v+a[y].v;
                else tt=-a[x].v-a[y].v;
        }
        if (fx==fy){
            for (rint i=x+1;i<y;++i){
                if (a[i].u>a[x].u) tt+=a[i].v+a[x].v;
                if (a[i].u<a[y].u) tt+=a[y].v+a[i].v;
                //--//    
                if (a[i].u<a[x].u) tt-=a[i].v+a[x].v;
                if (a[i].u>a[y].u) tt-=a[y].v+a[i].v;
                tt%=mod;
            }
        }else{
            for (rint i=x+1;i<st[fx+1];++i){
                if (a[i].u>a[x].u) tt+=a[i].v+a[x].v;
                if (a[i].u<a[y].u) tt+=a[y].v+a[i].v;
                //--//    
                if (a[i].u<a[x].u) tt-=a[i].v+a[x].v;
                if (a[i].u>a[y].u) tt-=a[y].v+a[i].v;
                tt%=mod;
            }
            for (rint i=st[fy];i<y;++i){
                if (a[i].u>a[x].u) tt+=a[i].v+a[x].v;
                if (a[i].u<a[y].u) tt+=a[y].v+a[i].v;
                //--//    
                if (a[i].u<a[x].u) tt-=a[i].v+a[x].v;
                if (a[i].u>a[y].u) tt-=a[y].v+a[i].v;
                tt%=mod;
            }
            for (rint i=fx+1;i<fy;++i){
                rint len=st[i+1]-st[i];
                rint k=find(a[x].u,st[i],st[i+1]-1);
                ll t1=0;rint rk;
                if (k>=st[i]) t1=b[k].v,rk=k-st[i]+1;
                    else t1=0,rk=0;
                tt+=(len-rk-rk)*a[x].v%mod+b[st[i+1]-1].v-t1-t1;
                tt%=mod;
                //--//
                k=find(a[y].u,st[i],st[i+1]-1);
                if (k>=st[i]) t1=b[k].v,rk=k-st[i]+1;
                    else t1=0,rk=0;
                tt-=(len-rk-rk)*a[y].v%mod+b[st[i+1]-1].v-t1-t1;
                tt%=mod;
            }
        }
        ans=((ans+tt)%mod+mod)%mod;
        swap(a[x],a[y]);
        build(fx);
        build(fy);
        printf("%lld\n",ans);
    }
    return 0;
}
```

---

## 作者：yizhiming (赞：8)

前言，目前最优解，大约两秒就过了。

[Link](https://www.luogu.com.cn/problem/P3759)

## 题面大意

给定一个长为 $n$ 的排列，每个数有对应的价值，$m$ 次交换序列中两个元素，问每次交换完之后全局贡献。

若两个数是逆序对，则会提供这两个数价值和的贡献。

其实建议大家去看看讨论区的题意。

$1\leq n,m\leq 5\times 10^4$。

## 题目分析

众所周知，这种交换两个数求逆序对的，当前修改区间的左右两边不会有影响，只需要知道查询区间中间部分与左右端点的大小关系即可。

现在比较麻烦的是如何处理价值？

其实如果有人看过我这篇[博客](https://www.luogu.com.cn/blog/yizhiming/ti-xie-p3157-cqoi2011-dong-tai-ni-xu-dui-post)，大概就比较好想了，没看过也没关系，我在这里重说一遍。

设 $pre_{i,j}$ 表示前 $i$ 个序列块中，值域在块 $j$ 的数的价值和。

$cnt_{i,j}$ 表示前 $i$ 个序列块中，值域在块 $j$ 的数的个数。

注意是要将值域和序列都分块。由于是单点修改（交换两个和插入），所以前缀和数组可以直接 $\sqrt{n}$ 扫一遍所有的块更新前缀和数组。

有了前缀和数组，我们就可以在查询值域整块的时候 $O(1)$ 计算出当前整序列块，值域整块的答案。

利用一个优美的性质，$a$ 是排列，所以对于零散值域块的数，当前所在的位置是唯一确定的，所以我们记录若 $a_x = i$，则 $id_i = x$，有了这个数组，就可以查询零散值域块，是否在整序列块内。

所以我们修改的时候，暴力根号修改两个数组，查询的时候枚举零散序列块，对于整序列块，分成整值域块和零散值域块统计即可。

时间复杂度 $O(n\sqrt{n})$，空间复杂度 $O(n)$。

不知道为什么这道题跑得比 cdq 快，上面那道就被吊打。

作者文笔不太好，但想推广一下分块做法，望海涵。

## Code

交换的时候要考虑左右端点相互是否成为逆序对，同时注意把当前左右端点的贡献先删掉在查询，最后交换完之后再修改前缀和数组。

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <queue>
#define int long long
using namespace std;
int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
const int N = 5e4+5;
const int Sn = 400;
int Mod = 1e9+7;
int a[N],v[N],bel[N],L[N],R[N],id[N];
int pre[Sn][Sn],cnt[Sn][Sn];
int ask1(int l,int r,int val,int w){
	int res = 0;
	for(int i=l;i<=r;i++){
		res+=(a[i]>val)*(w+v[i]);
	} 
	return res;
}
int ask2(int l,int r,int val,int w){
	int res = 0;
	for(int i=l;i<=r;i++){
		res+=((a[i]<val)&&(a[i]!=0))*(w+v[i]);
	}
	return res;
}
int n,m,res;
int qmax(int l,int r,int val,int w){
	if(l>r){
		return 0;
	}
	int num = 0;
	if(bel[l]==bel[r]){
		num = ask1(l,r,val,w);
	}else{
		num+=ask1(l,R[bel[l]],val,w);
		num+=ask1(L[bel[r]],r,val,w);
		int lx = bel[l],rx = bel[r]-1;
		for(int i=bel[val]+1;i<=bel[n];i++){
			num+=pre[rx][i]-pre[lx][i];
			num+=(cnt[rx][i]-cnt[lx][i])*w;
		}
		for(int i=val+1;i<=R[bel[val]];i++){
			num+=((id[i]>=L[lx+1])&&(id[i]<=R[rx]))*(w+v[id[i]]);
		}
	}
	return num;
}
int qmin(int l,int r,int val,int w){
	if(l>r){
		return 0;
	}
	int num = 0;
	if(bel[l]==bel[r]){
		num = ask2(l,r,val,w);
	}else{
		num+=ask2(l,R[bel[l]],val,w);
		num+=ask2(L[bel[r]],r,val,w);
		int lx = bel[l],rx = bel[r]-1;
		for(int i=1;i<bel[val];i++){
			num+=pre[rx][i]-pre[lx][i];
			num+=(cnt[rx][i]-cnt[lx][i])*w;
		}
		for(int i=L[bel[val]];i<val;i++){
			num+=((id[i]>=L[lx+1])&&(id[i]<=R[rx]))*(w+v[id[i]]);
		}
	}
	return num;
}
void ins(int id,int val,int w){
	res+=qmax(1,id-1,val,w);
	res+=qmin(id+1,n,val,w);
	for(int i=bel[id];i<=bel[n];i++){
		pre[i][bel[val]]+=w;
		cnt[i][bel[val]]++;
	}
}
void add(int id,int x){
	int val = a[id];
	int w = v[id];
	for(int i=bel[id];i<=bel[n];i++){
		pre[i][bel[val]]+=w*x;
		cnt[i][bel[val]]+=x;
	}
}
void Swap(int x,int y){
	if(x==y){
		return;
	}
	if(x>y){
		swap(x,y);
	}
	add(x,-1);add(y,-1);
	int c = a[x],d = a[y];
	if(c>d){
		res-=v[x]+v[y];
	}else{
		res+=v[x]+v[y];
	}
	id[a[x]] = 0;id[a[y]] = 0;
	a[x] = 0;a[y] = 0;
	res-=qmin(x+1,y-1,c,v[x]);
	res-=qmax(x+1,y-1,d,v[y]);
	res+=qmax(x+1,y-1,c,v[x]);
	res+=qmin(x+1,y-1,d,v[y]);
	a[x] = c;a[y] = d;
	id[a[x]] = x;id[a[y]] = y;
	swap(id[a[x]],id[a[y]]);
	swap(a[x],a[y]);
	swap(v[x],v[y]); 
	add(x,1);add(y,1);
}
signed main(){
	n = read();m = read();
	int siz = sqrt(n);
	for(int i=1;i<=n;i++){
		bel[i] = (i-1)/siz+1;
		if(!L[bel[i]]){
			L[bel[i]] = i;
		}
		R[bel[i]] = i;
	}
	for(int i=1;i<=n;i++){
		a[i] = read();v[i] = read();
		id[a[i]] = i;
		ins(i,a[i],v[i]);
	}
	int x,y;
	while(m--){
		x = read();y = read();
		Swap(x,y);
		cout<<res%Mod<<"\n";
	}
	return 0;
}
```

感觉这种单点修改的分块，大家基本都不怎么写 $O(n\sqrt{n})$ 的。

---

## 作者：青君 (赞：6)

## 做法：树状数组套动态开点权值线段树。
虽然有篇题解已经写了这个了，但我这篇会讲得更详细~~且代码更短~~。
## 题目分析
- 设数组 $a$ 表示优先级（题面中的位置），$b$ 表示权值（题面中的页数）。
- 考虑 $swap(l,r)$ 后答案的变化。
- 发现会改变的点对只有三种：（1）以 $l$ 为左端点，$i\in[l+1,r-1]$ 为右端点；（2）以 $i\in[l+1,r-1]$ 为左端点，$r$ 为右端点；（3）以 $l$ 为左端点，$r$ 为右端点。
- （3）可以直接特判，而（1）和（2）是对称的，下面只考虑（1）。
- 对于 $i\in[l+1,r-1]$，如果 $a[l]< a[i]$，那么是顺序对变逆序对，$ans \gets ans+b[l]+b[i]$；如果 $a[l]> a[i]$，那么是逆序对变顺序对，$ans \gets ans-(b[l]+b[i])$。
- 对这些贡献求和，得到一个形式化的公式
$$ans \gets ans+\sum_{l+1\le i\le r-1,a_l<a_i}a[l]+a[i]-\sum_{l+1\le i\le r-1,a_l>a_i}a[l]+a[i]$$
- 要算这个式子，我们需要支持（1）查询区间内某个值域中 数的和及数的个数；（2）单点修改。至此终于可以请出我们的树状数组套动态开点权值线段树了！
## 具体做法
- 普通的树状数组存的是数，我们只要把数换成动态开点权值线段树就可以了，其它操作完全一样。
- 相当于树状数组套在外面做区间索引，内层的动态开点权值线段树做值域索引。
- 可以这样做的原因是我们维护的信息具有可减性。
- ~~为什么具体做法这么短呢，因为真的一句话就说完了。~~
## 代码
### 别忘了取模！！！
```cpp
#include<bits/stdc++.h>
#define pk push_back
#define mk make_pair 
using namespace std;
typedef long long LL;
const int N=5e4+5,M=200,mod=1e9+7;
#define tl ls[id]
#define tr rs[id]
#define mid (l+r>>1) 
#define lson tl,l,mid
#define rson tr,mid+1,r
int tot,sz[N*M],ls[N*M],rs[N*M],s[N*M];
void update(int &id,int l,int r,int p,int v,int fg){
	if(!id) id=++tot;
	if(l==r) return sz[id]+=fg,s[id]+=fg*v,void();
	p<=mid?update(lson,p,v,fg):update(rson,p,v,fg);
	sz[id]=sz[tl]+sz[tr];s[id]=(s[tl]+s[tr])%mod;
}
int qsz,qs;
void query(int id,int l,int r,int ll,int rr,int fg){
	if(ll<=l&&r<=rr) return qsz+=fg*sz[id],(qs+=fg*s[id])%=mod,void();
	if(rr<=mid) query(lson,ll,rr,fg);
	else if(ll>mid) query(rson,ll,rr,fg);
	else query(lson,ll,rr,fg),query(rson,ll,rr,fg); 
} 
int n,m,a[N],b[N],rt[N];LL ans;
void add(int x,int fg){
	int p=a[x],v=b[x];
	for(;x<=n;x+=x&-x) update(rt[x],1,n,p,v,fg);
}
void ask(int l,int r,int ll,int rr){
	qsz=qs=0;
	if(l>r||ll>rr) return ;
	for(;r;r-=r&-r) query(rt[r],1,n,ll,rr,1);
	--l;if(l) for(;l;l-=l&-l) query(rt[l],1,n,ll,rr,-1);
}
int f(int x){
	return (qs+1ll*qsz*b[x]%mod)%mod;
}
int main(){
	ios::sync_with_stdio(false);
	cin>>n>>m;
	for(int i=1;i<=n;++i){
		cin>>a[i]>>b[i],add(i,1);
		ask(1,i-1,a[i]+1,n);
		ans+=f(i);ans%=mod;
	}
	while(m--){
		int l,r;cin>>l>>r;
		if(l>r) swap(l,r);
		if(l!=r){
			ask(l+1,r-1,1,a[l]-1);ans-=f(l);ans%=mod;
			ask(l+1,r-1,a[l]+1,n);ans+=f(l);ans%=mod;
			ask(l+1,r-1,1,a[r]-1);ans+=f(r);ans%=mod;
			ask(l+1,r-1,a[r]+1,n);ans-=f(r);ans%=mod;
			a[l]>a[r]?ans-=b[l]+b[r]:ans+=b[l]+b[r];ans%=mod;
			add(l,-1),add(r,-1);
			swap(a[l],a[r]),swap(b[l],b[r]);
			add(l,1),add(r,1);
		} 
		if(ans<0) ans+=mod;
		cout<<ans<<endl;
	}
	return 0;
} 
```


---

## 作者：夏色祭 (赞：6)

先膜一波楼下的两个大佬。

~~tutututu大佬准集训队~~

其实只要写个BIT套动态开点权值线段树就可以了~~比线段树套平衡树要短和快很多~~。写法和动态逆序对很像，感觉也没什么好说的，直接上代码。

```
//by zykykyk
#include<cstdio>
#include<ctime>
#include<iostream>
#include<algorithm>
#include<cmath>
#include<string>
#define rg register
#define il inline
#define vd void
#define ll long long
#define mod 1000000007
#define N 50010
#define For(i,x,y) for (rg int i=(x);i<=(y);i++)
#define Dow(i,x,y) for (rg int i=(x);i>=(y);i--)
#define cross(i,k) for (rg int i=first[k];i;i=last[i])
using namespace std;
il ll max(ll x,ll y){return x>y?x:y;}
il ll min(ll x,ll y){return x<y?x:y;}
il ll read(){
    ll x=0;int ch=getchar(),f=1;
    while (!isdigit(ch)&&(ch!='-')&&(ch!=EOF)) ch=getchar();
    if (ch=='-'){f=-1;ch=getchar();}
    while (isdigit(ch)){x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
    return x*f;
}
int n,m,l,r,a[N],b[N],c[N],Cnt[N];
ll ans;
il int lowbit(int x){return x&(-x);}
il vd Add(int x,int y){
	for (;x<=n;x+=lowbit(x)) c[x]+=y,Cnt[x]++;
}
il ll Sum_v(int x){
	ll sum=0;
	for (;x;x-=lowbit(x)) sum+=c[x];return sum;
}
il ll Sum_cnt(int x){
	ll sum=0;
	for (;x;x-=lowbit(x)) sum+=Cnt[x];return sum;
}
int tot,rt[N],cnt[N*256],lson[N*256],rson[N*256];
ll v[N*256];
il vd insert(int &u,int l,int r,int ql,int k,int K){
	if (!u) u=++tot;v[u]+=k;cnt[u]+=K;
	if (l==r) return;int mid=l+r>>1;
	if (ql<=mid) insert(lson[u],l,mid,ql,k,K);
		else insert(rson[u],mid+1,r,ql,k,K);
}
il vd Add(int x,int ql,int k,int K){
	for (;x<=n;x+=lowbit(x)) insert(rt[x],1,n,ql,k,K);
}
il int query_v(int u,int l,int r,int ql,int qr){
	if (!u) return 0;
	if (l>=ql&&r<=qr) return v[u];int mid=l+r>>1;
	if (qr<=mid) return query_v(lson[u],l,mid,ql,qr);
	else if (ql>mid) return query_v(rson[u],mid+1,r,ql,qr);
	else return query_v(lson[u],l,mid,ql,qr)+query_v(rson[u],mid+1,r,ql,qr);
}
il int query_cnt(int u,int l,int r,int ql,int qr){
	if (!u) return 0;
	if (l>=ql&&r<=qr) return cnt[u];int mid=l+r>>1;
	if (qr<=mid) return query_cnt(lson[u],l,mid,ql,qr);
	else if (ql>mid) return query_cnt(rson[u],mid+1,r,ql,qr);
	else return query_cnt(lson[u],l,mid,ql,qr)+query_cnt(rson[u],mid+1,r,ql,qr);
}
il ll Query_v(int l,int r,int ql,int qr){
	if (l>r||ql>qr) return 0;
	ll sum=0;
	for (;r;r-=lowbit(r)) sum+=query_v(rt[r],1,n,ql,qr);l--;
	for (;l;l-=lowbit(l)) sum-=query_v(rt[l],1,n,ql,qr);return sum;
}
il ll Query_cnt(int l,int r,int ql,int qr){
	if (l>r||ql>qr) return 0;
	ll sum=0;
	for (;r;r-=lowbit(r)) sum+=query_cnt(rt[r],1,n,ql,qr);l--;
	for (;l;l-=lowbit(l)) sum-=query_cnt(rt[l],1,n,ql,qr);return sum;
}
il vd Dec(ll &x,ll y){
	while (x<y) x+=mod;x-=y;
}
int main(){
	freopen("data.in","r",stdin);
	freopen("m.out","w",stdout);
	n=read(),m=read();
	For(i,1,n) a[i]=read(),b[i]=read();
	Dow(i,n,1) Add(a[i],b[i]),(ans+=Sum_v(a[i]-1)+Sum_cnt(a[i]-1)*b[i])%=mod;
	For(i,1,n) Add(i,a[i],b[i],1);
	For(i,1,m){
		l=read(),r=read();
		if (l>r) swap(l,r);
		if (l==r){printf("%lld\n",ans);continue;}
		(ans+=Query_v(l+1,r-1,1,a[r]-1))%=mod;
		(ans+=Query_cnt(l+1,r-1,1,a[r]-1)*b[r])%=mod;
		Dec(ans,Query_v(l+1,r-1,a[r]+1,n));
		Dec(ans,Query_cnt(l+1,r-1,a[r]+1,n)*b[r]);
		(ans+=Query_v(l+1,r-1,a[l]+1,n))%=mod;
		(ans+=Query_cnt(l+1,r-1,a[l]+1,n)*b[l])%=mod;
		Dec(ans,Query_v(l+1,r-1,1,a[l]-1));
		Dec(ans,Query_cnt(l+1,r-1,1,a[l]-1)*b[l]);
		if (a[l]>a[r]) Dec(ans,b[l]+b[r]);
			else (ans+=b[l]+b[r])%=mod;
		Add(l,a[l],-b[l],-1),Add(l,a[r],b[r],1);
		Add(r,a[r],-b[r],-1),Add(r,a[l],b[l],1);
		swap(a[l],a[r]),swap(b[l],b[r]);
		printf("%lld\n",ans);
	}
}
```

---

## 作者：吾王美如画 (赞：5)

# 唔姆
------------
快两年没写题解了。前几天看群友讨论这题的CDQ做法，再看自己两年前就用树套树写了这题（虽然只有20分），而且这题也没有CDQ的题解，于是怒敲一发CDQ，结果最优解了，故作此题解

------------
### 正文

- 首先是题意，~~出题人和我之间总有一个人语文不及格。~~ 这题的意思是给你一个序列 $a[i]$ 以及每个位置所对应的权值 $v[i]$ ，求序列的每对逆序对的**权值和**，且支持交换对应位置的 $a[i]$ 与 $v[i]$ 。
- 接着便是解法了，其实这题和 [P3157 [CQOI2011]动态逆序对](https://www.luogu.com.cn/problem/P3157) 极其类似，有兴趣可以去康康。
- 回到正题，从CDQ的基本思想出发，我们的限制分别是“时间” “位置”和 “键值”（姑且叫这个罢，反正就是$a[i]$），我们考虑把每个操作都拆成这三个限制构成的点，比如原始数组，时间为 $0$ ，位置为下标。

- 而后续的交换操作，例如第 $i$ 次操作交换了 $x$ 和 $y$ ，那么我们应该把这个操作拆成四个操作：
	1. $i$ 时刻，在 $x$ 位置，有一个 键值为 $a[x]$ 权值为 $-v[x]$ 的点
	2. $i$ 时刻，在 $x$ 位置，有一个 键值为 $a[y]$ 权值为 $v[y]$ 的点
	3. $i$ 时刻，在 $y$ 位置，有一个 键值为 $a[x]$ 权值为 $v[x]$ 的点
	4. $i$ 时刻，在 $y$ 位置，有一个 键值为 $a[y]$ 权值为 $-v[y]$ 的点
   
   可以看出，加入负权点，就可以去掉之前的点的贡献了。
- 最后，还就那经典CDQ操作，查询有多少个点（正权点数$-$负权点数）的时间在该点之前，位置在该点前且键值比该点大或位置在该点后且键值比该点小，以及这些点的权值和。把其贡献统计到对应的操作中，即为这次操作对答案的贡献，输出时做个前缀和就行了。

# Code：

```cpp
#include <bits/stdc++.h>
#define MAXN 1000000
#define MOD 1000000007
#define int long long
using namespace std;

int n,m;

struct data{
	int x,y,z,id,tp;
}v[MAXN],tr[MAXN];
inline int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}

int a[MAXN],b[MAXN];
int ord[MAXN],ans[MAXN];

bool cmp1(data x,data y){
	if (x.id==y.id){
		if (x.x==y.x)
			return x.y<y.y;
		else 
			return x.x<y.x;
	}
	else 
		return x.id<y.id;
}

bool cmp2(int x,int y){
	if (v[x].x==v[y].x){
		if (v[x].y==v[y].y)
			return x<y;
		else return v[x].y<v[y].y;
	}
	else return v[x].x<v[y].x;
} 

inline int lb(int x){
	return x&(-x);
}

void upd(int pos,int x,int y){
	for(int i=pos;i<=n;i+=lb(i))
		tr[i].z=((tr[i].z+x)%MOD+MOD)%MOD,tr[i].tp+=y;
}

data ask(int pos){
	data res;
	res.z=res.tp=0;
	if (!pos)
		return res;
	for(int i=pos;i;i-=lb(i))
		res.z=(res.z+tr[i].z)%MOD,res.tp+=tr[i].tp;
	res.z=(res.z+MOD)%MOD;
	return res;
}
void solve(int l,int r){//CDQ本体
	if(l>=r)return;
	int mid=(l+r)>>1;
	solve(l,mid);
	solve(mid+1,r);
	int cnt=0;
	for(int i=l;i<=r;i++)
		ord[++cnt]=i;
	sort(ord+1,ord+1+cnt,cmp2);//偷懒直接用的sort，归并应该更快
    
	for(int i=1;i<=cnt;i++){//顺序做一遍，统计位置小但键值大的点的贡献
		int x=ord[i];
		if (x<=mid)
			upd(n-v[x].y+1,v[x].z*v[x].tp,v[x].tp);
		else {
			data tmp=ask(n-v[x].y);
			ans[v[x].id]+=v[x].tp*(tmp.tp*v[x].z+tmp.z)%MOD;ans[v[x].id]%=MOD;
		}
	}
	for(int i=1;i<=cnt;i++){
		int x=ord[i];
		if (x<=mid)
			upd(n-v[x].y+1,-v[x].z*v[x].tp,-v[x].tp);
	}
	
	for(int i=cnt;i;i--){//倒叙再做一遍
		int x=ord[i];
		if (x<=mid)
			upd(v[x].y,v[x].z*v[x].tp,v[x].tp);
		else {
			data tmp=ask(v[x].y-1);
			ans[v[x].id]+=v[x].tp*(tmp.tp*v[x].z+tmp.z)%MOD;ans[v[x].id]%=MOD;
		}
	}
	for(int i=1;i<=cnt;i++){
		int x=ord[i];
		if (x<=mid)
			upd(v[x].y,-v[x].z*v[x].tp,-v[x].tp);
	}
	
	
}

signed main(){
	n=read(),m=read();
	int tot=0;
	for(int i=1;i<=n;i++)
		v[++tot].x=i,a[i]=v[tot].y=read(),b[i]=v[tot].z=read(),v[tot].id=0,v[tot].tp=1;
	for(int i=1;i<=m;i++){
		int x=read(),y=read();
		v[++tot].x=x,v[tot].y=a[x],v[tot].z=b[x],v[tot].id=i,v[tot].tp=-1;
		v[++tot].x=y,v[tot].y=a[y],v[tot].z=b[y],v[tot].id=i,v[tot].tp=-1;
		
		swap(a[x],a[y]);swap(b[x],b[y]);
		v[++tot].x=x,v[tot].y=a[x],v[tot].z=b[x],v[tot].id=i,v[tot].tp=1;
		v[++tot].x=y,v[tot].y=a[y],v[tot].z=b[y],v[tot].id=i,v[tot].tp=1;
	}
	sort(v+1,v+1+tot,cmp1);
	solve(1,tot);
	for(int i=1;i<=m;i++){
		ans[i]=((ans[i-1]+ans[i])%MOD+MOD)%MOD;
		printf("%lld\n",ans[i]);
	}
	return 0;
}

```


------------

唔，就是这样啦。细节可能还是有点~~或者是我太菜了~~，有问题可以直接私信我

---

## 作者：Sol1 (赞：4)

貌似还没有 BIT 套 Fhq 的题解？

那我来一发。

问题为带交换全局带权逆序对。

我们来分析每次交换一对数 $(l,r)$ 的贡献。首先，区间 $[1,l-1]$ 和 $[r+1,n]$ 内的数一定不会产生贡献，因为每一个点的贡献实际上是从左边/右边的 **集合** 里面计算出来的，这两个区间对应的都是集合里面的交换，因为集合的无序性，所以无贡献。

$l,r$ 之间的贡献可以直接计算。

对于 $l,r$ 对 $[l+1,r-1]$ 内的贡献，我们发现这个问题的本质就是查询一段区间之内有多少个数比一个给定的值大或小。

这是一个带修改的二维偏序问题，使用树套树维护，复杂度为 $O((m+n)\log^2 n)$。

但是即使这个题的时限已经放宽到了 5s 还是比较卡常~~还不是因为树套树常数太大。~~

有一个卡常技巧，因为 Fhq-Treap 的 split/merge 操作速度很慢，所以通过一次查询出多个值来减少 split/merge 的调用次数，可以将 TLE 的代码优化到 4s。

然后……就没啥好说的了。看代码吧。

```cpp
#include <iostream>
#include <cmath>
#include <cstring>
#include <cstdio>
using namespace std;

#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1 << 21], *p1 = buf, *p2 = buf;

inline int qread() {
	register char c = getchar();
	register int x = 0, f = 1;
	while (c < '0' || c > '9') {
		if (c == '-') f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + c - 48;
		c = getchar();
	}
	return x * f;
}

inline int Abs(const int& x) {return (x > 0 ? x : -x);}
inline int Max(const int& x, const int& y) {return (x > y ? x : y);}
inline int Min(const int& x, const int& y) {return (x < y ? x : y);}

const int mod = 1000000007;
int n, a[100005], v[100005], ans = 0, m;

#define GetSize(p) (p ? p->siz : 0)
#define GetSum(p) (p ? p->sum : 0)
struct Node {
	int val, rnd, siz, k, sum;
	Node *l, *r;
	Node() {
		val = rnd = siz = k = sum = 0;
		l = r = NULL;
	}
	inline void Update() {
		siz = GetSize(l) + GetSize(r) + 1;
		sum = ((GetSum(l) + GetSum(r)) % mod + k) % mod;
	}
};
struct Result {
	int suml, sumr, sizel, sizer;
	Result() {}
	Result(int suml, int sumr, int sizel, int sizer) : suml(suml), sumr(sumr), sizel(sizel), sizer(sizer) {}
	inline Result operator + (const Result& b) const {
		return Result((suml + b.suml) % mod, (sumr + b.sumr) % mod, (sizel + b.sizel) % mod, (sizer + b.sizer) % mod);
	}
};
Node nd[4000005];
int top;
struct Fhqtreap {
	Node *_root;
	inline Node* New(int val, int k) {
		Node *p = &nd[++top];
		p->val = val;
		p->sum = p->k = k;
		p->rnd = rand();
		p->siz = 1;
		return p;
	}
	inline void split(Node *p, int spk, Node *&lt, Node *&rt) {
		if (!p) {
			lt = rt = NULL;
			return;
		}
		if (p->val <= spk) {
			lt = p;
			split(p->r, spk, p->r, rt);
		} else {
			rt = p;
			split(p->l, spk, lt, p->l);
		}
		p->Update();
	}
	inline Node* merge(Node *lt, Node *rt) {
		if (!lt) return rt;
		if (!rt) return lt;
		if (lt->rnd < rt->rnd) {
			lt->r = merge(lt->r, rt);
			lt->Update();
			return lt;
		} else {
			rt->l = merge(lt, rt->l);
			rt->Update();
			return rt;
		}
	}
	inline void Ins(int val, int k) {
		Node *p1, *p2;
		split(_root, val, p1, p2);
		_root = merge(merge(p1, New(val, k)), p2);
	}
	inline void Del(int val) {
		Node *p1, *p2, *p3;
		split(_root, val - 1, p1, p2);
		split(p2, val, p2, p3);
		p2 = merge(p2->l, p2->r);
		_root = merge(merge(p1, p2), p3);
	}
	inline Result Query(int val) {
		Node *p1, *p2, *p3;
		split(_root, val - 1, p1, p2);
		split(p2, val, p2, p3);
		Result res(GetSum(p1), GetSum(p3), GetSize(p1), GetSize(p3));
		_root = merge(merge(p1, p2), p3);
		return res;
	}
	inline int SumLess(int val) {
		Node *p1, *p2;
		split(_root, val - 1, p1, p2);
		register int ans = GetSum(p1);
		_root = merge(p1, p2);
		return ans;
	}
	inline int SumMore(int val) {
		Node *p1, *p2;
		split(_root, val, p1, p2);
		register int ans = GetSum(p2);
		_root = merge(p1, p2);
		return ans;
	}
	inline int SizeLess(int val) {
		Node *p1, *p2;
		split(_root, val - 1, p1, p2);
		register int ans = GetSize(p1);
		_root = merge(p1, p2);
		return ans;
	}
	inline int SizeMore(int val) {
		Node *p1, *p2;
		split(_root, val, p1, p2);
		register int ans = GetSize(p2);
		_root = merge(p1, p2);
		return ans;
	}
};
struct BIT {
	Fhqtreap tr[100005];
	inline int Lowbit(int x) {
		return x & -x;
	}
	inline void Add(int i, int x, int y) {
		for (register int j = i;j <= n;j += Lowbit(j)) tr[j].Ins(x, y);
	}
	inline void Del(int i, int x) {
		for (register int j = i;j <= n;j += Lowbit(j)) tr[j].Del(x);
	}
	inline Result Query(int i, int x) {
		Result ans(0, 0, 0, 0);
		for (register int j = i;j >= 1;j -= Lowbit(j)) ans = ans + tr[j].Query(x);
		return ans;
	}
	inline int QueryLess(int i, int x) {
		register int ans = 0;
		for (register int j = i;j >= 1;j -= Lowbit(j)) ans = (ans + tr[j].SumLess(x)) % mod;
		return ans;
	}
	inline int QueryMore(int i, int x) {
		register int ans = 0;
		for (register int j = i;j >= 1;j -= Lowbit(j)) ans = (ans + tr[j].SumMore(x)) % mod;
		return ans;
	}
	inline int SizeLess(int i, int x) {
		register int ans = 0;
		for (register int j = i;j >= 1;j -= Lowbit(j)) ans = (ans + tr[j].SizeLess(x)) % mod;
		return ans;
	}
	inline int SizeMore(int i, int x) {
		register int ans = 0;
		for (register int j = i;j >= 1;j -= Lowbit(j)) ans = (ans + tr[j].SizeMore(x)) % mod;
		return ans;
	}
};
BIT tr;

inline void Read() {
	n = qread(); m = qread();
	for (register int i = 1;i <= n;i++) {
		a[i] = qread(); v[i] = qread();
		ans = (ans + tr.QueryMore(i, a[i])) % mod;
		ans = (ans + (long long)tr.SizeMore(i, a[i]) * (long long)v[i] % mod) % mod;
		tr.Add(i, a[i], v[i]);
	}
}

inline void Solve() {
	//printf("%d\n", ans);
	while (m--) {
		register int l = qread(), r = qread();
		if (l == r) {
			printf("%d\n", ans);
			continue;
		}
		if (l > r) swap(l, r);
		if (l < r - 1) {
			Result res1 = tr.Query(r - 1, a[r]), res2 = tr.Query(r - 1, a[l]), res3 = tr.Query(l, a[r]), res4 = tr.Query(l, a[l]);
			ans = ((((ans - res1.sumr) % mod + mod) % mod + res3.sumr)) % mod;
			ans = ((ans - (long long)(res1.sizer - res3.sizer) * (long long)v[r] % (long long)mod) % mod + mod) % mod;
			ans = (((ans + res2.sumr) % mod - res4.sumr) % mod + mod) % mod;
			ans = (ans + (long long)(res2.sizer - res4.sizer) * (long long)v[l] % (long long)mod) % mod;
			ans = ((((ans - res2.suml) % mod + mod) % mod + res4.suml)) % mod;
			ans = ((ans - (long long)(res2.sizel - res4.sizel) * (long long)v[l] % (long long)mod) % mod + mod) % mod;
			ans = (((ans + res1.suml) % mod - res3.suml) % mod + mod) % mod;
			ans = (ans + (long long)(res1.sizel - res3.sizel) * (long long)v[r] % (long long)mod) % mod;
		}
		tr.Del(l, a[l]);
		tr.Del(r, a[r]);
		tr.Add(l, a[r], v[r]);
		tr.Add(r, a[l], v[l]);
		if (a[l] > a[r]) ans -= v[l] + v[r];
		else if (a[l] < a[r]) ans += v[l] + v[r];
		ans = (ans % mod + mod) % mod;
		swap(a[l], a[r]);
		swap(v[l], v[r]);
		printf("%d\n", ans);
	}
}

int main() {
	Read();
	Solve();
	#ifndef ONLINE_JUDGE
	while (1);
	#endif
	return 0;
}
```

---

## 作者：Cekavis (赞：3)

无法参考网上的众多题解.

只看到过分块+BIT的题解,但是本题解是树套树

题目可以转化为

1.区间询问关键字<x的元素个数,和这些元素的v之和

2.单点修改


显然可以树套树维护

外层区间线段树,内层treap,treap维护子树size和v的和就可以了


抱歉,代码没注释

```cpp
#include<cstdio>
#include<algorithm>
#include<ctype.h>
#include<string.h>
using namespace std;
#define ll long long
#define rt register int
#define reep(i,x,y) for(rt i=(x);i<(y);++i)
#define per(i,x,y) for(rt i=(x);i>=(y);--i)
#define rep(i,x,y) for(rt i=(x);i<=(y);++i)
#define travel(i,x) for(rt i=h[x];i;i=pre[i])
namespace fast_IO {
    inline char read() {
//        return getchar();
        static const int IN_LEN = 1000000;
        static char buf[IN_LEN], *s, *t;
        if (s == t) {
            t = (s = buf) + fread(buf, 1, IN_LEN, stdin);
            if (s == t) return -1;
        }
        return *s++;
    }
    template<class T>
    inline void read(T &x) {
        static bool iosig;
        static char c;
        for (iosig = false, c = read(); !isdigit(c); c = read()) {
            if (c == '-') iosig = true;
            if (c == -1) return;
        }
        for (x = 0; isdigit(c); c = read())
            x = ((x + (x << 2)) << 1) + (c ^ '0');
        if (iosig) x = -x;
    }
    const int OUT_LEN = 10000000;
    char obuf[OUT_LEN], *ooh = obuf;
    inline void print(char c) {
        if (ooh == obuf + OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh = obuf;
        *ooh++ = c;
    }
    template<class T>
    inline void print(T x) {
        static int buf[30], cnt;
        if (x == 0) {
            print('0');
        }
        else {
            if (x < 0) print('-'), x = -x;
            for (cnt = 0; x; x /= 10) buf[++cnt] = x % 10 + 48;
            while (cnt) print((char)buf[cnt--]);
        }
    }
    inline void flush() {
        fwrite(obuf, 1, ooh - obuf, stdout);
    }
}
using namespace fast_IO;
const int N = 50005, Size = N * 60, P = 1000000007;
int n, m, L, R, s1[N], root[N << 2];
ll ans, s2[N];
#define pr pair<int,ll>
inline pr operator +(const pr &lhs, const pr &rhs) {
    return make_pair(lhs.first + rhs.first, lhs.second + rhs.second);
}
struct st {
    int val, sec;
    inline st() { val = sec = 0; }
    inline st(int v, int s) { val = v, sec = s; }
    inline bool operator <(const st &rhs) const { return val < rhs.val || val == rhs.val && sec < rhs.sec; }
    inline bool operator ==(const st &rhs) const { return val == rhs.val && sec == rhs.sec; }
    inline bool operator >(const st &rhs) const { return val > rhs.val || val == rhs.val && sec > rhs.sec; }
}b[N];
namespace treap {
    int tot;
    struct node {
        int lson, rson, size, p;
        ll ssec;
        st val;
    }a[Size];
    inline void update(int x) {
        a[x].size = a[a[x].lson].size + a[a[x].rson].size + 1;
        a[x].ssec = a[a[x].lson].ssec + a[a[x].rson].ssec + a[x].val.sec;
    }
    inline void lrotate(int &x) {
        int tmp = a[x].rson;
        a[x].rson = a[tmp].lson, a[tmp].lson = x;
        update(x), update(tmp);
        x = tmp;
    }
    inline void rrotate(int &x) {
        int tmp = a[x].lson;
        a[x].lson = a[tmp].rson, a[tmp].rson = x;
        update(x), update(tmp);
        x = tmp;
    }
    void ins(int &x, st y) {
        if (!x) {
            x = ++tot;
            a[x].val = y;
            a[x].p = rand();
        }
        else if (y > a[x].val) {
            ins(a[x].rson, y);
            if (a[a[x].rson].p > a[x].p) lrotate(x);
        }
        else {
            ins(a[x].lson, y);
            if (a[a[x].lson].p > a[x].p) rrotate(x);
        }
        update(x);
    }
    void del(int &x, st y) {
        if (!x) return;
        if (y > a[x].val) del(a[x].rson, y);
        else if (y < a[x].val) del(a[x].lson, y);
        else if (!a[x].lson || !a[x].rson) x = a[x].rson|a[x].rson;
        else if (a[a[x].lson].p > a[a[x].rson].p) {
            rrotate(x);
            del(a[x].rson, y);
        }
        else {
            lrotate(x);
            del(a[x].lson, y);
        }
        if (x) update(x);
    }
    pr Rank(int x, st y) {
        if (!x) return make_pair(0, 0ll);
        if (y < a[x].val) return Rank(a[x].lson, y);
        else {
            pr tmp = Rank(a[x].rson, y);
            return tmp + make_pair(a[a[x].lson].size + 1, a[a[x].lson].ssec + a[x].val.sec);
        }
    }
};
template<class T> inline void modify(T *f, int x, int y) {
    for (; x <= n; x += x&-x) f[x] += y;
}
template<class T> inline T sum(T *f, int x) {
    T ass = 0;
    for (; x; x ^= x&-x) ass += f[x];
    return ass;
}
inline void calc_start() {
    per(i, n, 1) {
        ans += (ll)sum(s1, b[i].val)*b[i].sec + sum(s2, b[i].val);
        modify(s1, b[i].val, 1), modify(s2, b[i].val, b[i].sec);
    }
}
void build(int l, int r, int t) {
    rep(i, l, r) treap::ins(root[t], b[i]);
    if (l != r) {
        int mid = l + r >> 1, k = t << 1;
        build(l, mid, k), build(mid + 1, r, k | 1);
    }
}
pr query(int l, int r, int t, const st &k) {
//    printf("query:%d %d %d %d\n", l, r, k.val, treap::a[root[t]].ssec);
    if (L <= l && r <= R) return treap::Rank(root[t], k);
    int mid = l + r >> 1;
    pr ass = make_pair(0, 0ll);
    if (L <= mid) ass = ass + query(l, mid, t << 1, k);
    if (R > mid) ass = ass + query(mid + 1, r, t << 1 | 1, k);
    return ass;
}
void change(int l, int r, int t, int pos, int ppos) {
    if(l>=L || r<=R) treap::del(root[t], b[pos]), treap::ins(root[t], b[ppos]);
    if (l != r) {
        int mid = l + r >> 1;
        if (pos <= mid) change(l, mid, t << 1, pos, ppos);
        else change(mid + 1, r, t << 1 | 1, pos, ppos);
    }
}
int main() {
    read(n), read(m);
    rep(i, 1, n) read(b[i].val), read(b[i].sec);
    calc_start();
    build(1, n, 1);
    //printf("------------------%d\n", treap::Rank(root[1], st(2, 2)).second);
    memset(s2, 0, sizeof s2);
    rep(i, 1, n) modify(s2, i, b[i].sec);
//    printf("[%lld]", ans);
    while (m--) {
        static int x, y;
        read(x), read(y);
        if(x==y){
            print(ans%P), print('\n');
            continue;
        }
        if (x > y) swap(x, y);
        L = x + 1, R = y - 1;
        if (L <= R) {
            pr tmp = query(1, n, 1, b[x]);
            ans += (ll)(R - L + 1 - tmp.first - tmp.first)*b[x].sec + sum(s2, R) - sum(s2, L - 1) - tmp.second - tmp.second;
//            printf(">>>%d %lld     ans=%lld\n", tmp.first, tmp.second, ans);
            tmp = query(1, n, 1, b[y]);
            ans -= (ll)(R - L + 1 - tmp.first - tmp.first)*b[y].sec + sum(s2, R) - sum(s2, L - 1) - tmp.second - tmp.second;
//            printf(">>>%d %lld     ans=%lld\n", tmp.first, tmp.second, ans);
        }
        if (b[x].val < b[y].val) ans += b[x].sec + b[y].sec; else ans -= b[x].sec + b[y].sec;
        modify(s2, x, b[y].sec - b[x].sec), modify(s2, y, b[x].sec - b[y].sec);
        change(1, n, 1, x, y), change(1, n, 1, y, x);
        swap(b[x], b[y]);
        print(ans%P), print('\n');
    }
    return flush(), 0;
}
```

---

## 作者：Genius_Z (赞：2)

[$\Large\color{violet}Blog$](http://geiz-revive.github.io/)

这题的题面真的有毒，题意非常不清楚，让人怀疑自己的语文水平…

要求的逆序对是关于$a_i$的…

之后我们要求的就是以书本的编号为位置维度，以$a_i$为逆序对的权值维度，然后再带上权就行了，带权的操作比较好想，同时维护权值和(以下的权值指$v_i$)与个数，贡献就是权值和 $+$（个数 $\times$ 当前计算的点的权值）。

之后上树状数组套主席树的板子，这题就完了，因为读错题调了整整两个下午

$\Large Code:$

```cpp
#pragma region revive
#include <set>
#include <map>
#include <cmath>
#include <queue>
#include <stack>
#include <bitset>
#include <cstdio>
#include <vector>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <iostream>
#include <algorithm>
#include <unordered_map>
#define inl inline
#define re register int
#define fa(x) t[x].fa
#define son(x,y) t[x].child[y]
#define ls(x) t[x].child[0]
#define rs(x) t[x].child[1]
#define ll long long
const int inf = 0x3f3f3f3f;
#define lowbit(x) ((x) & (-x))
using namespace std;
#ifndef _DEBUG
#define getchar() (*(IOB.in.p++))
#define putchar(c) (*(IOB.out.p++)=(c))
#define io_eof() (IOB.in.p>=IOB.in.pend)
struct IOBUF { struct { char buff[1 << 26], *p, *pend; }in; struct { char buff[1 << 26], *p; }out; IOBUF() { in.p = in.buff; out.p = out.buff; in.pend = in.buff + fread(in.buff, 1, 1 << 26, stdin); }~IOBUF() { fwrite(out.buff, 1, out.p - out.buff, stdout); } }IOB;
#endif
template<typename IO>
inl void write(IO x) {
	if (x == 0) return (void)putchar('0');
	if (x < 0)putchar('-'), x = -x;
	static char buf[30];
	char* p = buf;
	while (x) {
		*(p++) = x % 10 + '0';
		x /= 10;
	}
	while (p > buf)putchar(*(--p));
}
inl void writestr(const char *s) { while (*s != 0)putchar(*(s++)); }
template<typename IO>inl void writeln(IO x) { write(x), putchar('\n'); }
template<typename IO>inl void writesp(IO x) { write(x), putchar(' '); }
inl int readstr(char *s) {
	char *begin = s, c = getchar();
	while (c < 33 || c>127) {
		c = getchar();
	}
	while (c >= 33 && c <= 127) {
		*(s++) = c;
		c = getchar();
	}
	*s = 0;
	return s - begin;
}
template<typename IO>
inl IO read() {
	IO x = 0;
	register bool w = 0;
	register char c = getchar();
	while (c > '9' || c < '0') {
		if (c == '-') w = 1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + (c ^ 48);
		c = getchar();
	}
	return w ? -x : x;
}
#pragma endregion
#undef ls
#undef rs
#define ls(x) t[x].l
#define rs(x) t[x].r
const int mod = 1e9 + 7;
int root[1000001], cnt, pos[1000001], a[1000001], tmpl[51], tmpr[51], cntl, cntr, n;
struct node {
	int l, r, cnt;
	ll w;
}t[20000001];
inl void maintain(int x) {
	t[x].w = (t[ls(x)].w + t[rs(x)].w) % mod;
	t[x].cnt = t[ls(x)].cnt + t[rs(x)].cnt;
}
inl void change(int &k, int l, int r, int p, int w, int op) {
	if (!k)k = ++cnt;
	if (l == r)return (void)(t[k].w = ((t[k].w + w) % mod + mod) % mod, t[k].cnt += op);
	re mid = l + r >> 1;
	if (p <= mid)change(ls(k), l, mid, p, w, op);
	else change(rs(k), mid + 1, r, p, w, op);
	maintain(k);
}
inl int query(int l, int r, int x, int w, bool op) {
	cntl = cntr = 0;
	for (re i = l - 1; i; i -= lowbit(i)) tmpl[++cntl] = root[i];
	for (re i = r; i; i -= lowbit(i))tmpr[++cntr] = root[i];
	l = 1, r = n;
	re mid; ll ans = 0;
	while (l != r) {
		mid = l + r >> 1;
		if (x <= mid) {
			if (op) {
				for (re i = 1; i <= cntl; i++)ans -= (t[rs(tmpl[i])].w + t[rs(tmpl[i])].cnt*w) % mod;
				for (re i = 1; i <= cntr; i++)ans += (t[rs(tmpr[i])].w + t[rs(tmpr[i])].cnt*w) % mod;
			}
			for (re i = 1; i <= cntl; i++)tmpl[i] = ls(tmpl[i]);
			for (re i = 1; i <= cntr; i++)tmpr[i] = ls(tmpr[i]);
			r = mid;
		}
		else {
			if (!op) {
				for (re i = 1; i <= cntl; i++)ans -= (t[ls(tmpl[i])].w + t[ls(tmpl[i])].cnt*w) % mod;
				for (re i = 1; i <= cntr; i++)ans += (t[ls(tmpr[i])].w + t[ls(tmpr[i])].cnt*w) % mod;
			}
			for (re i = 1; i <= cntl; i++)tmpl[i] = rs(tmpl[i]);
			for (re i = 1; i <= cntr; i++)tmpr[i] = rs(tmpr[i]);
			l = mid + 1;
		}
	}
	return (ans%mod + mod) % mod;
}
signed main() {
	n = read<int>();
	re m = read<int>(), x, y, f, g;
	ll ans = 0;
	for (re i = 1; i <= n; i++) {
		pos[i] = read<int>(), a[i] = read<int>();
		ans += query(1, i - 1, pos[i], a[i], 1);
		for (re j = i; j <= n; j += lowbit(j)) change(root[j], 1, n, pos[i], a[i], 1);
	}
	ans = (ans%mod + mod) % mod;
	while (m--) {
		x = read<int>(), y = read<int>(), f = x, g = y, x = pos[x], y = pos[y];
		if (x == y) {
			writeln(ans);
			continue;
		}
		ans -= query(1, f - 1, x, a[f], 1) + query(f + 1, n, x, a[f], 0);
		ans -= query(1, g - 1, y, a[g], 1) + query(g + 1, n, y, a[g], 0);
		for (re i = f; i <= n; i += lowbit(i))change(root[i], 1, n, x, -a[f], -1);
		for (re i = g; i <= n; i += lowbit(i))change(root[i], 1, n, y, -a[g], -1);
		swap(pos[f], pos[g]), swap(x, y), swap(a[f], a[g]);
		for (re i = f; i <= n; i += lowbit(i))change(root[i], 1, n, x, a[f], 1);
		for (re i = g; i <= n; i += lowbit(i))change(root[i], 1, n, y, a[g], 1);
		ans += query(1, f - 1, x, a[f], 1) + query(f + 1, n, x, a[f], 0);
		ans += query(1, g - 1, y, a[g], 1) + query(g + 1, n, y, a[g], 0);
		ans -= ((f > g && x < y) || (f < g && x > y))*(a[f] + a[g]);
		ans += ((f > g && x > y) || (f < g && x < y))*(a[f] + a[g]);
		ans = (ans%mod + mod) % mod;
		writeln(ans);
	}
}
```



---

## 作者：AC_love (赞：1)

出题人语文不好，题面写的很抽象，这道题的形式化题意大概是：

给定 $a_i, v_i$，每次操作给出 $x, y$，交换 $a_x, a_y$ 和 $v_x, v_y$，要求动态维护：

$$\sum_{i = 1}^n\sum_{j = i +1}^n [a_i > a_j](v_i + v_j)$$

一句话概括大概是：维护动态序列的带权逆序对。

能做这个东西的很多，题解区已经有了树套树，cdq 分治，分块等做法。但还没有一篇 KD-Tree 的题解，所以简单说一下这道题 KDT 怎么做。

首先把问题转化为二维数点。把每本书抽象成一个点 $(i, a_i)$，其中 $i$ 是这本书当前的位置，$a_i$ 是这本书应该在哪个位置。

考虑交换操作其实等价于两次删除操作和两次插入操作。KDT 不好删点，因此把删除操作转化为把某个点权值设成 $0$ 的修改操作。这俩都是 KDT 的基础操作，不再赘述。

考虑如何在操作之后维护答案。

我们发现：交换 $x, y(x < y)$ 位置上的点时，不会对 $x$ 前面和 $y$ 后面的点产生贡献，因此只需要询问 $[x, y]$ 这个区间内产生了多少贡献即可。

对于 $x$ 位置上的数，换到 $y$ 位置上时，产生的贡献为：

$$\sum_{i = x}^y[a_i > a_x](v_i + v_x) - \sum_{i = x}^y[a_i < a_x](v_i + v_x)$$

发现两个 $\sum$ 都可以拆成一次矩阵查询，直接在 KDT 上查询即可。

$y$ 的做法与 $x$ 同理。

每次交换时，先做两次修改操作删除原来的点，再做四次插入操作维护答案，最后再做两次插入操作插入新的点即可。

操作很多，常数不小，能 AC，但跑得还是有点慢的。

一种常数上优化是先离线记录下来所有点的位置，然后直接建树。这样树高是非常平衡的，并且用修改操作代替了插入操作，省去了重构树的时间。

即便如此跑得肯定还是不如小常数的 cdq 和分块快，但应该会比大部分树套树都更快一些。

顺便再说一个很简单的 $O(n \sqrt n \log n)$ 做法：分块，每个块内开两个树状数组（一个前缀树状数组和一个后缀树状数组）。插入删除操作相当在树状数组里加减 $1$，维护答案时，中间部分散块暴力，整块直接在树状数组上查询前后缀即可。

这个做法复杂度很劣，能过这道题纯粹是因为数据范围小而且时限开得大，没啥意义，不建议学习。

---

## 作者：xukuan (赞：1)

我们发现，**存在乱序的书则必然存在逆序对，而厌烦度统计就是逆序对的权值和**

那么这就是一道裸的动态逆序对的题了。

不会动态逆序对的可以参考\[CQOI2011\]动态逆序对

另外，我的动态逆序对用了线段树套主席树（树状数组不会打了。。。）

代码（请开启火车头使用）

```cpp
#include<bits/stdc++.h>
#include<iostream>
#include<cstdio>
#define ll long long
#define pLL pair<ll,ll>
using namespace std;

const ll N=50010,mod=1000000007;
ll n,m,ans,cnt,a[N],sum[N];

inline ll read(){
	ll x=0,tmp=1;
	char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-') tmp=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
	return tmp*x;
}

inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	ll y=10,len=1;
	while(y<=x){
		y=(y<<3)+(y<<1);
		len++;
	}
	while(len--){
		y/=10;
		putchar(x/y+48);
		x%=y;
	}
}

inline void add(pLL &x,pLL y){
	x.first+=y.first;
	x.second+=y.second;
}

namespace Segment{//线段树
	ll root[N<<8];
	struct SegmentTree{
		ll lson,rson,size,val;
	}tree[N<<8];
	queue<ll> trush;
	inline void Delete(ll &p){
		tree[p].size=tree[p].val=tree[p].lson=tree[p].rson=0;
		trush.push(p); p=0;
	}
	
	inline ll New(){
	    if(trush.empty()) return ++cnt;
	    ll ans=trush.front(); trush.pop();
	    return ans;
	}
	
	void Insert(ll &p,ll l,ll r,ll pos,ll x,ll y){
	    if(!p) p=New();
	    tree[p].size=(tree[p].size+mod+x)%mod; tree[p].val+=y;
	    if(l==r){
	        if(!tree[p].val) Delete(p);
	        return;
	    }
	    ll mid=(l+r)>>1;
	    if(pos<=mid) Insert(tree[p].lson,l,mid,pos,x,y);
	    if(pos>mid) Insert(tree[p].rson,mid+1,r,pos,x,y);
	    if(!tree[p].val) Delete(p);
	}
	
	pLL query(ll p,ll l,ll r,ll x,ll y){
	    if(!p) return make_pair(0,0);
	    if(x<=l&&r<=y) return make_pair(tree[p].size,tree[p].val);
	    ll mid=(l+r)>>1;
	    pLL ans=make_pair(0,0);
	    if(x<=mid) add(ans,query(tree[p].lson,l,mid,x,y));
	    if(y>mid) add(ans,query(tree[p].rson,mid+1,r,x,y));
	    return ans;
	}
}

namespace treap{//主席树
	void Insert(ll p,ll l,ll r,ll pos,ll x,ll sum){
	    Segment::Insert(Segment::root[p],1,N,x,sum,1);
	    if(l==r) return;
	    ll mid=(l+r)>>1;
	    if(pos<=mid) Insert(p<<1,l,mid,pos,x,sum);
	    if(pos>mid) Insert(p<<1|1,mid+1,r,pos,x,sum);
	}
	
	void Delete(ll p,ll l,ll r,ll pos,ll x,ll sum){
	    Segment::Insert(Segment::root[p],1,N,x,-sum,-1);
	    if(l==r) return;
	    ll mid=(l+r)>>1;
	    if(pos<=mid) Delete(p<<1,l,mid,pos,x,sum);
	    if(pos>mid) Delete(p<<1|1,mid+1,r,pos,x,sum);
	}
	
	pLL query(ll p,ll l,ll r,ll x,ll y,ll L,ll R){
	    if(x<=l&&r<=y) return Segment::query(Segment::root[p],1,N,L,R);
	    if(x<=l&&r<=y) return Segment::query(Segment::root[p],1,N,L,R);
	    ll mid=(l+r)>>1;
	    pLL ans=make_pair(0,0);
	    if(x<=mid) add(ans,query(p<<1,l,mid,x,y,L,R));
	    if(y>mid) add(ans,query(p<<1|1,mid+1,r,x,y,L,R));
	    ans.first%=mod;
	    return ans;
	}	
}

int main(){
    n=read(); m=read();
    for(ll i=1; i<=n; i++){
    	a[i]=read(); sum[i]=read()%mod;
    	treap::Insert(1,1,n,i,a[i],sum[i]);
	}
    for(ll i=1; i<=n; i++){
        pLL cur=treap::query(1,1,n,i+1,n,1,a[i]);
        ans=(ans+sum[i]*cur.second+cur.first)%mod;
    }
    while(m--){
        ll x=read(),y=read();
        if(x>y) swap(x,y);
        if(x==y){
			write(ans); putchar('\n');
			continue;
		}
        ll L=a[x],R=a[y],mn=min(L,R),mx=max(L,R);
        pLL cur=treap::query(1,1,n,x,y,mn+1,mx-1);
        ans=(ans+(mn==L?1:-1)*(2*cur.first+(cur.second+1)*(sum[x]+sum[y])))%mod;
        ans=(ans+treap::query(1,1,n,x,y,1,mn-1).second*(sum[y]-sum[x]))%mod;
        ans=(ans+treap::query(1,1,n,x,y,mx+1,n).second*(sum[x]-sum[y]))%mod;
        while(ans<0) ans+=mod;
        treap::Delete(1,1,n,x,a[x],sum[x]); treap::Delete(1,1,n,y,a[y],sum[y]);
        treap::Insert(1,1,n,x,a[y],sum[y]); treap::Insert(1,1,n,y,a[x],sum[x]);
        swap(a[x],a[y]); swap(sum[x],sum[y]);
        write(ans); putchar('\n');
    }
    return 0;
}
```

---

## 作者：lgswdn_SA (赞：0)

**大家好，我非常喜欢trie**，所以贡献一份 trie 来实现的带修主席树。trie 相比于权值线段树主要优点在于对于一些题目不用离散化，还有自带非递归动态开点。

---

动态带权逆序对（？），和动态逆序对没啥区别。原本一个数的贡献是 $1$，现在贡献变成了 $y_i$ 罢了。怎么改呢？我们维护一个 sz，记录页数和，然后再维护一个 cnt，记录个数。那么带权逆序对即为 $\sum sz+\sum cnt\times y_i$，一路上统计一下即可。

每次 query 要传入 ```y```，然后是 ```ans+=(sz+cnt*y)``` 而不是 ```ans+=sz``` 即可。还有一些需要注意的细节，比如不保证 $x_j\le y_j$，所以需要特判一下。

（卡了空间，代码不大好看）


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=5e5+9;

struct TRIE {
	int ch[N*18][2],cnt[N*18],root[N*18]; int tot; 
	ll sz[N*18];
	void ins(int val,int rt,int k,int u=0) {
		if(!root[rt]) root[rt]=++tot;
		u=root[rt], sz[u]+=k, cnt[u]++;
		for(int h=17;h>=0;h--) {
			bool p=val&(1ll<<h);
			if(!ch[u][p]) ch[u][p]=++tot;
			u=ch[u][p]; sz[u]+=k; cnt[u]++;
		}
	}
	void del(int val,int rt,int k,int u=0) {
		u=root[rt]; sz[u]-=k; cnt[u]--;
		for(int h=17;h>=0;h--) {
			bool p=val&(1ll<<h);
			if(!ch[u][p]) return;
			u=ch[u][p]; sz[u]-=k; cnt[u]--;
		}
	}
	ll rank_small(int val,vector<int>c1,vector<int>c2,int z,ll ans=0) {
		int len1=c1.size(); 
		for(int i=0;i<len1;i++) {
			for(int h=17;h>=0;h--) {
				bool p=val&(1ll<<h);
				if(p&&ch[c1[i]][0]) ans-=sz[ch[c1[i]][0]],ans-=1ll*z*cnt[ch[c1[i]][0]];
				c1[i]=ch[c1[i]][p];
				if(!c1[i]) break;
			}
		}
		int len2=c2.size();
		for(int i=0;i<len2;i++) {
			for(int h=17;h>=0;h--) {
				bool p=val&(1ll<<h);
				if(p&&ch[c2[i]][0]) ans+=sz[ch[c2[i]][0]],ans+=1ll*z*cnt[ch[c2[i]][0]];
				c2[i]=ch[c2[i]][p];
				if(!c2[i]) break;
			}
		}
		return ans;
	}
	ll rank_large(int val,vector<int>c1,vector<int>c2,int z,ll ans=0) {
		int len1=c1.size();
		for(ll i=0;i<len1;i++) {
			for(ll h=17;h>=0;h--) {
				bool p=val&(1ll<<h);
				if((!p)&&ch[c1[i]][1]) ans-=sz[ch[c1[i]][1]],ans-=1ll*z*cnt[ch[c1[i]][1]];
				c1[i]=ch[c1[i]][p];
				if(!c1[i]) break;
			}
		}
		int len2=c2.size();
		for(int i=0;i<len2;i++) {
			for(int h=17;h>=0;h--) {
				bool p=val&(1ll<<h);
				if((!p)&&ch[c2[i]][1]) ans+=sz[ch[c2[i]][1]],ans+=1ll*z*cnt[ch[c2[i]][1]];
				c2[i]=ch[c2[i]][p];
				if(!c2[i]) break;
			}
		}
		return ans;
	}
}tr;

int n,m,a[N],b[N];

#define lb(i) (i&(-i))
void add(ll x,ll a,ll k) {for(;x<=n;x+=lb(x)) tr.ins(a,x,k);}
void rem(ll x,ll a,ll k) {for(;x<=n;x+=lb(x)) tr.del(a,x,k);}
ll query_small(int x,int y,int k,int z) {
	if(x>y) return 0; vector<int>c1,c2;
	for(int j=x-1;j>=1;j-=lb(j)) c1.push_back(tr.root[j]);
	for(int j=y;j>=1;j-=lb(j)) c2.push_back(tr.root[j]);
	return tr.rank_small(k,c1,c2,z);
}
ll query_large(int x,int y,int k,int z) {
	if(x>y) return 0; vector<int>c1,c2;
	for(ll j=x-1;j>=1;j-=lb(j)) c1.push_back(tr.root[j]);
	for(ll j=y;j>=1;j-=lb(j)) c2.push_back(tr.root[j]);
	return tr.rank_large(k,c1,c2,z);
}

signed main() {
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%d%d",&a[i],&b[i]), add(i,a[i],b[i]);
	ll ans=0;
	for(int i=1;i<=n;i++) ans+=query_small(i+1,n,a[i],b[i]); 
	for(int i=1,x,y;i<=m;i++) {
		scanf("%d%d",&x,&y);
		if(x>y) swap(x,y);
		if(x==y) {printf("%lld\n",ans);continue;}
		if(x+1!=y) {
			ans-=query_large(1,y-1,a[y],b[y])-query_large(1,x,a[y],b[y]),
			ans-=query_small(1,y-1,a[x],b[x])-query_small(1,x,a[x],b[x]),
			ans+=query_small(1,y-1,a[y],b[y])-query_small(1,x,a[y],b[y]),
			ans+=query_large(1,y-1,a[x],b[x])-query_large(1,x,a[x],b[x]);
		}
		ans+=(a[x]<a[y]? b[x]+b[y] : -b[x]-b[y]);
		ans=(ans%1000000007+1000000007)%1000000007;
		printf("%lld\n",ans);
		rem(x,a[x],b[x]), rem(y,a[y],b[y]), add(x,a[y],b[y]), add(y,a[x],b[x]),
		swap(a[x],a[y]), swap(b[x],b[y]);
	}
	return 0;
}
```

---

## 作者：seajupiter (赞：0)

# 算法： 树状数组套splay

发现此题还没有BIT套平衡树写法的题解（其实是我还不会大佬用的分块等……），本篇文章在此介绍一下这种奇葩又稍慢的写法

第一步，弄清题意。
- **题意给出的书初始状态是按给出顺序（即编号）排列，而非按a[i]排列**
- **交换操作是交换当前排列顺序下的第x本和第y本，而非编号为x和编号为y！**

第二步，理清思路。

交换第x和y两本书后，只对x~y区间内的逆序对产生影响。

如果只看逆序对数量，把x调到y的贡献为：x+1~y-1内比x大的个数-x+1~y-1内比x小的个数，y调到x同理也可以推出

但题目要求的是所有逆序对的两本书的厚度和，于是让splay同时维护个数和权值和就可以了

为了简化查询，我只写了splay查询区间内比v小的答案，而比v大的答案可以分别用总数减去比v小的答案得出，其中总的权值和就是一个单点修改区间查询的问题，可以再开一个辅助BIT维护

最后，注意答案取模过程中的细节，以及splay空间不仅要考虑初始大小，还要考虑后续修改带来的开销

以下是代码，代码中有少量注释，以防笔者码风过于奇葩，导致亲爱的读者们无法理解

------------

```cpp
#include<bits/stdc++.h>
#define ll long long
#define lb(x) (x&(-x))
#define mid ((l)+(r)>>(1))
#define pil pair<int,long long>
#define mkp make_pair
#define fst first
#define snd second
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
using namespace std;
void read(int &x)
{
	char c=getchar();x=0;
	while(!isdigit(c))c=getchar();
	while(isdigit(c))x=x*10+c-'0',c=getchar();
}
void read(ll &x)
{
	char c=getchar();x=0;
	while(!isdigit(c))c=getchar();
	while(isdigit(c))x=x*10+c-'0',c=getchar();
}
const int N=50005;
const ll mod=1e9+7;
int n,m;
ll tot;
//书结构体，v表示排名，w表示页数
struct book{
	int v;ll w;
	bool operator<(const book &a)const{return v<a.v;}
}bks[N]; 
//辅助树状数组，pre1和pre2用于预处理，bit用于之后的区间查询 
struct BIT
{
	ll sum[N];
	void add(int x,int v){for(;x<=n;x+=lb(x))sum[x]+=v;}
	ll ask(int x){ll ans=0;for(;x;x-=lb(x))ans=(ans+sum[x])%mod;return ans;}
}bit,pre1,pre2;
//预处理出初始值 
void prepro()
{
	for(int i=n;i;i--)
	{
		tot=(tot+pre1.ask(bks[i].v-1)+pre2.ask(bks[i].v-1)*bks[i].w)%mod;
		pre1.add(bks[i].v,bks[i].w);
		pre2.add(bks[i].v,1);
	}
}
//pair<int,long long>为查询返回的答案，第一维是个数，第二维是权值和 
pil operator+(pil a,pil b){return mkp((a.fst+b.fst)%mod,(a.snd+b.snd)%mod);}
pil operator-(pil a,pil b){return mkp(((a.fst-b.fst)%mod+mod)%mod,((a.snd-b.snd)%mod+mod)%mod);}
//内层splay 
struct splay_forest
{
	//cnt[x]表示以x为根的子树大小，val[x]表示x节点初始位置排名 
	int rt[N],totsz,val[N<<5],f[N<<5],s[N<<5][2],cnt[N<<5];
	//w[x]表示x节点所代表书的页数，sz[x]表示以x为根的子树内w[x]的和 
	ll w[N<<5],sz[N<<5];
	void clear(int &x){val[x]=f[x]=s[x][0]=s[x][1]=w[x]=sz[x]=cnt[x]=0;x=0;}
	bool pdson(int x){return s[f[x]][1]==x;}
	void update(int x){sz[x]=sz[s[x][0]]+sz[s[x][1]]+w[x];cnt[x]=cnt[s[x][0]]+cnt[s[x][1]]+1;}
	void build(int &x,int fa,book *a,int l,int r)
	{
		x=++totsz;
		f[x]=fa;
		val[x]=a[mid].v;
		w[x]=a[mid].w;
		if(l<mid)build(s[x][0],x,a,l,mid-1);
		if(r>mid)build(s[x][1],x,a,mid+1,r);
		update(x);
	}
	void rotate(int x)
	{
		int fa=f[x],gfa=f[fa],d=pdson(x);
		s[fa][d]=s[x][d^1];f[s[x][d^1]]=fa;
		s[x][d^1]=fa;f[fa]=x;
		f[x]=gfa;
		if(gfa)s[gfa][fa==s[gfa][1]]=x;
		update(fa);update(x);
	}
	void splay(int id,int x)
	{
		for(int fa;(fa=f[x])!=0;rotate(x))
			if(f[fa])rotate((pdson(fa)==pdson(x)?fa:x));
		rt[id]=x;
	}
	int find(int id,int v)
	{
		int now=rt[id];
		while(now)
		{
			if(val[now]==v)break;
			now=s[now][v>val[now]];
		}
		splay(id,now);
		return now;
	}
	int pre(int id)
	{
		int now=s[rt[id]][0];
		while(s[now][1])now=s[now][1];
		return now;
	}
	int nxt(int id)
	{
		int now=s[rt[id]][1];
		while(s[now][0])now=s[now][0];
		return now;
	}
	void insert(int id,int vl,ll wt)
	{
		if(!rt[id])
		{
			rt[id]=++totsz;
			val[rt[id]]=vl;
			w[rt[id]]=wt;
			update(rt[id]);
			return;
		}
		int now=rt[id],fa=0;
		while(1)
		{
			fa=now;now=s[now][vl>val[now]];
			if(!now)
			{
				now=++totsz;
				f[now]=fa;
				s[fa][vl>val[fa]]=now;
				val[now]=vl;
				w[now]=wt;
				update(now);
				break;
			}
		}
		if(totsz>=(N<<5))exit(0);
		splay(id,now);
	}
	void erase(int id,int v)
	{
		int x=find(id,v);
		if(!s[x][0]&&!s[x][1])return clear(rt[id]);
		if(!s[x][0]||!s[x][1])
		{
			rt[id]=s[x][0]?s[x][0]:s[x][1];
			f[rt[id]]=0;
			return clear(x);
		}
		int prex=pre(id);
		splay(id,prex);
		s[prex][1]=s[x][1];f[s[x][1]]=prex;
		clear(x);
		update(rt[id]);
	}
	pil query(int id,int v)
	{
		int now=rt[id];pil ans=mkp(0,0);
		while(now)
		{
			if(v<val[now])now=s[now][0];
			else if(v==val[now])return ans+mkp(cnt[s[now][0]],sz[s[now][0]]);
			else ans=ans+mkp(cnt[s[now][0]]+1,sz[s[now][0]]+w[now]),now=s[now][1];
		}
		return ans;
	}
}tr;
int pos[N],od[N];
book cur[N];
//外层树状数组 
void build()
{
	for(int i=1;i<=n;i++)
	{
		for(int j=i-lb(i)+1;j<=i;j++)cur[j]=bks[j];
		sort(cur+i-lb(i)+1,cur+i+1);
		tr.build(tr.rt[i],0,cur,i-lb(i)+1,i);
	}
}
void exchange(int qx,int qy)
{
	if(qx==qy)return;
	if(pos[qx]>pos[qy])swap(qx,qy);
	bit.add(pos[qx],bks[qy].w-bks[qx].w);
	bit.add(pos[qy],bks[qx].w-bks[qy].w);
	for(int i=pos[qx];i<pos[qy];i+=lb(i))
	{
		tr.erase(i,bks[qx].v);
		tr.insert(i,bks[qy].v,bks[qy].w);
	}
	for(int i=pos[qy];i<=n;i+=lb(i))if(i-lb(i)>=pos[qx])
	{
		tr.erase(i,bks[qy].v);
		tr.insert(i,bks[qx].v,bks[qx].w);
	}
	swap(pos[qx],pos[qy]);
}
//前缀查询 
pil ask(int x,int v)
{
	pil ans;
	for(;x;x-=lb(x))ans=ans+tr.query(x,v);
	return ans;
}
//区间查询 
ll query(int qx,int qy)
{
	if(qx==qy)return 0;
	if(pos[qx]>pos[qy])swap(qx,qy);
	if(pos[qy]-pos[qx]==1)
		return bks[qx].v<bks[qy].v?bks[qx].w+bks[qy].w:mod-bks[qx].w-bks[qy].w;
	ll sum=bit.ask(pos[qy]-1)-bit.ask(pos[qx]);
	int len=pos[qy]-pos[qx]-1;
	pil ansy=ask(pos[qy]-1,bks[qy].v)-ask(pos[qx],bks[qy].v);
	pil ansx=ask(pos[qy]-1,bks[qx].v)-ask(pos[qx],bks[qx].v);
	ll ans=sum-2*ansx.snd%mod+(len-2*ansx.fst)*bks[qx].w%mod;
	ans+=2*ansy.snd%mod-sum+(2*ansy.fst-len)*bks[qy].w%mod;
	if(bks[qx].v<bks[qy].v)ans+=bks[qx].w+bks[qy].w;
	else ans-=bks[qx].w+bks[qy].w;
	ans=(ans%mod+mod)%mod;
	return ans;
}
int ax,ay;
int main(){
	read(n);read(m);
	for(int i=1;i<=n;i++)read(bks[i].v),read(bks[i].w);
	prepro();
	for(int i=1;i<=n;i++)pos[i]=i,od[i]=i;
	build();
	for(int i=1;i<=n;i++)bit.add(pos[i],bks[i].w);
	for(int i=1;i<=m;i++)
	{
		read(ax);read(ay);
		tot=(tot+query(od[ax],od[ay]))%mod;
		printf("%d\n",tot);
		exchange(od[ax],od[ay]);
		swap(od[ax],od[ay]);
	}
	return 0;
}
```
----------------

此代码可能因为常数巨大，手动吸了臭氧才过

因此，仅在这里提供一种新的思路，旨在展示对于同一道树套树，可以有很多种解决方案，希望读者们以后在做题过程中也要放开思路，不过有能力的话最后要选择最优的方案解决


---


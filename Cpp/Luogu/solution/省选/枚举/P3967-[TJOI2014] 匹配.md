# [TJOI2014] 匹配

## 题目描述

有 $N$ 个单身的男孩和 $N$ 个单身女孩，男孩 $i$ 和女孩 $j$ 在一起得到的幸福值为 $H_{i,j}$。

一个匹配即对这 $N$ 个男孩女孩的安排：每个男孩恰好有一个女朋友，每个女孩恰好有一个男朋友。

一个匹配的幸福值即这 $N$ 对男女朋友的幸福值的和。

经典的问题是计算幸福值最大的匹配，即完美匹配。然而完美匹配有时候并不唯一，你需要计算对于所有的完美匹配，其交集是什么。

## 说明/提示

- 对于 $30\%$ 的数据，$N \leq 30$；
- 对于 $100\%$ 的数据，$1\leq N \leq 80$，$0\leq H_{i,j}\leq 5\times10^3$。

## 样例 #1

### 输入

```
3
1 1 1
2 1 1
1 1 1```

### 输出

```
4
2 1```

# 题解

## 作者：雨季 (赞：11)

# 题解
题意很明确  
### 第一问
$\quad \ \ $求带权二分图的最佳完美匹配，然而并不会写带权匹配╮(╯▽╰)╭，于是写了最大费用最大流。   
建图：$\ \ \ \ $超级源 $\ \ \ \ \ \to \ \ \ \ \ $ 男生$(i)$ $\qquad\ $容量为1，费用为0  
$\ \ \ \ $ $\qquad\ $男生$(i)$ $ \ \ \ \ \to\  $ 女生$(j+n)\ $容量为1，费用为幸福值  
$\quad\ \ \ \ $女生$(j+n)$$$\ \ \ \to\ \ \ \ \ $超级汇$\qquad\ \ \ \ $容量为1，费用为0
### 第二问
$\quad \ \ $求出所有完美匹配中都有的边  
$\quad \ \ $通过第一问，我们知道了一个完美匹配的方案，以及完美匹配下的最大幸福值。  
$\quad \ \ $那么我们可以枚举这个完美匹配中的每一条边，将它删掉，再次跑完美匹配，如果这次的最大费用比没有删掉它之前的答案小了，那么说明这条边一定在完美匹配中   
**注：如果写费用流的话，删边时记的将这条边对应的反向边一起删掉，不然的话你大概会死循环。。。**
# 代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
#define N 500

int n,S,T;
bool in[N][N];
bool check[N*N];

inline int read() {
	int tmp=0,w=1;
	char ch=0;
	while(!isdigit(ch)) {if(ch=='-') w=-1;ch=getchar();}
	while(isdigit(ch)) tmp=(tmp<<1)+(tmp<<3)+ch-'0',ch=getchar();
	return tmp*w;
}

struct node {
	int u,v,c,f,nex;
}e[N*N],ee[N*N];
int tot=1,h[N],use[N];
void add(int u,int v,int c,int f) {
	e[++tot].u=u,e[tot].v=v,e[tot].c=c,e[tot].f= f,e[tot].nex=h[u],h[u]=tot;
	e[++tot].u=v,e[tot].v=u,e[tot].c=0,e[tot].f=-f,e[tot].nex=h[v],h[v]=tot;
}

int dis[N];
bool vis[N];
bool donot[N*N];
deque<int>q;
bool spfa() {
	for(int i=S;i<=T;++i) dis[i]=-1e9,vis[i]=0;
	q.push_back(T);
	dis[T]=0;
	int x,xx;
	while(!q.empty()) {
		x=q.front();
		q.pop_front();
		vis[x]=0;
		for(int i=h[x];i;i=e[i].nex) {
			xx=e[i].v;
			if(donot[i]) continue;
			if(e[i^1].c&&dis[xx]<dis[x]-e[i].f) {
				dis[xx]=dis[x]-e[i].f;
				if(!vis[xx]) {
					vis[xx]=1;
					if(q.empty()||dis[xx]<dis[q.front()]) q.push_back(xx);
					else q.push_front(xx);
				}
			}
		}
	}
	return dis[S]>-1e9;
}
bool mark[N];
int dfs(int x,int want) {
	mark[x]=1;
	if(x==T||!want) return want;
	int f=0,get=0,xx=0;
	for(int i=use[x];i;i=e[i].nex) {
		if(donot[i]) continue;
		xx=e[i].v;
		if(e[i].c&&!mark[xx]&&dis[xx]==dis[x]-e[i].f) {
			f=dfs(xx,min(want,e[i].c));
			if(!f) continue;
			e[i].c-=f;
			e[i^1].c+=f;
			get+=f;
			want-=f;
			use[x]=i;
			if(!want) break;
		}
	}
	return get;
}

int mfmc() {
	int res=0;
	while(spfa()) {
		mark[T]=1;
		while(mark[T]) {
			for(int i=S;i<=T;++i) use[i]=h[i],mark[i]=0;
			res+=dis[S]*dfs(S,1e9);
		}
	}
	return res;
}

int main()
{
	scanf("%d",&n);
	S=0,T=n+n+1;
	int x;
	for(int i=1;i<=n;++i) {
		for(int j=1;j<=n;++j) {
			x=read();
			add(i,j+n,1,x);
		} 
	}
	int cut=tot;
	for(int i=1;i<=n;++i) add(S,i,1,0),add(i+n,T,1,0);
	memcpy(ee,e,sizeof(e));
	int ans=mfmc();
	for(int i=2;i<=cut;i+=2) if(!e[i].c) check[i]=1;
	printf("%d\n",ans);
	for(int i=2;i<=cut;i+=2) {
		if(check[i]) {
			donot[i]=1,donot[i^1]=1;
			memcpy(e,ee,sizeof(ee));	
			x=mfmc();
			if(x<ans) in[e[i].u][e[i].v]=1;
			donot[i]=0,donot[i^1]=0;
		}
	}
	for(int i=1;i<=n;++i) {
		for(int j=1;j<=n;++j) {
			if(in[i][j+n]) printf("%d %d\n",i,j);
		}
	}
	return 0;
}
```

---

## 作者：louhao088 (赞：5)

KM 板题，

具体就是用匈牙利算法找增广路，然后匹配。由于题目保证一定有完美匹配，固只要去匹配即可。

与传统深搜不一样，这里我们用广搜。

我们按 $x$ 一个元素一个元素去匹配。每次匹配清空 $vis$ 数组（记录一个 $y$ 有没有被匹配过）。

根据某定理，当一个匹配两点的顶标之和与两点的价值一致，就能后最大匹配，固我们每次贪心找差值最小的点与变小的点记录下来。对于一个 $y$ 与该 $x$ 匹配值变小，我们就更改匹配。对于最小值我们每次更改顶标，使其与两点价值更接近，可以证明，如果有最大匹配，这样总能得到解。

把两两加和得到答案输出即可。

对于第二问，将边按照 $x$ 排序，~~最开始因为这个错了好多次~~。

每次对于一对匹配判断是不是必要的。

一对匹配是必要的 $\iff$ 把这对匹配删除后，最大匹配会变小。

我们只要暴力删除每一对匹配，判断是否变小即可，变小就输出

每次 KM 复杂度 $n^3$ ,共进行$n$次固总复杂度 $n^4$ 。


------------


```cpp
#include<bits/stdc++.h>
using namespace std;
//static char buf[1000000],*p1=buf,*p2=buf;
//#define getchar() p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++
#define re register
const int maxn=505;
inline int read()
{
	char ch=getchar();bool f=0;int x=0;
	for(;!isdigit(ch);ch=getchar())if(ch=='-')f=1;
	for(;isdigit(ch);ch=getchar())x=(x<<1)+(x<<3)+(ch^48);
	if(f==1)x=-x;return x;
}
void print(int x)
{
    if(x<0) putchar('-'),x=-x;
    if(x>9) print(x/10);
    putchar(x%10+'0');
}
int n,m,vis[maxn],dx[maxn],dy[maxn],Min[maxn],num,mat[maxn],pre[maxn],d[maxn][maxn],ans;
void match(int x)
{
	int y=0,num,id;
	memset(pre,0,sizeof pre);mat[y]=x;memset(Min,0x3f,sizeof Min);
	while(1)
	{
		x=mat[y];vis[y]=1;num=0x3f3f3f3f;
		for(int i=1;i<=n;i++)
		{
			if(vis[i])continue;
			if(Min[i]>dx[x]+dy[i]-d[x][i])
				Min[i]=dx[x]+dy[i]-d[x][i],pre[i]=y;
			if(Min[i]<num)num=Min[i],id=i;
		}
		for(int i=0;i<=n;i++)
		{
			if(vis[i])dx[mat[i]]-=num,dy[i]+=num;
			else Min[i]-=num;
		}y=id;if(mat[y]==-1)break;
	}
	while(y)mat[y]=mat[pre[y]],y=pre[y];
}
int KM()
{
	memset(dx,0,sizeof dx),memset(dy,0,sizeof dy),memset(mat,-1,sizeof mat);
	for(int i=1;i<=n;i++)
		memset(vis,0,sizeof vis),match(i);
	int res=0;
	for(int i=1;i<=n;i++)if(mat[i]!=-1)res=res+d[mat[i]][i];//,cout<<d[mat[i]][i]<<endl;
	return res;
}
bool check(int x,int y)
{
	int g=d[x][y];d[x][y]=-1e8;
	int res=KM();d[x][y]=g;
	if(res==ans)return false;
	return true;
}
struct node
{
	int l,r;
}q[maxn];
bool cmp(node a,node b){return a.l<b.l;
}
signed main()
{
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	n=read();//cout<<"A";
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			d[i][j]=read();
	ans=KM();
	cout<<ans<<endl;
	for(int i=1;i<=n;i++)q[i].l=mat[i],q[i].r=i;
	sort(q+1,q+n+1,cmp);
	for(int i=1;i<=n;i++)if(check(q[i].l,q[i].r))cout<<q[i].l<<" "<<q[i].r<<endl;
	return 0;
}


```
（本人代码是学着大佬写的，可能有些相似，请多体谅）


---

## 作者：Mortis_Vampire (赞：4)

KM 算法是一种用来求解带权二分图匹配的算法。

相较于费用流，KM 一般在稠密图上有着更快的速度，并且更好写。

但是它有很大的局限性：二分图的最大匹配必须为完备匹配。

而这题正好满足这个条件，为何不用 KM 呢？

### 思路
对于第一问，直接跑一遍 KM 就可以了。

对于第二问，我们分 n 次暴力断掉在第一问中找到的匹配边，跑 n 遍 KM ，若结果变小，那么这条断掉的边一定必须选。

然后就是注意排序，要按原匹配边的顺序进行排序。

dfs 写法的 KM 算法面对随机数据时，时间复杂度为 $O(n^3)$ ，面对特殊构造的数据是 $O(n^4)$。

好在这题数据不~~毒瘤~~，dfs 写法总时间复杂度应该是 $O(n^4)$ 左右，可以过。

```cpp
//KM算法基本的思想是构造出一个存在完备匹配的相等子图
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define inf 1<<30//最大值
using namespace std;
inline int rd() {//快读
	register int x=0,f=1;
	register char c=getchar();
	while(c<'0'||c>'9') {
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c<='9'&&c>='0')
		x=(x<<3)+(x<<1)+c-48,c=getchar();
	return x*f;
}
int n,w[105][105];//n和边权
int la[105],lb[105];//顶标
bool va[105],vb[105];//左右访问标记
int match[105];
int delta,upd[105];
struct node {
	int x,y;
}tmatch[105];
bool cmp(const node &a,const node &b)
{
	return a.x<b.x;
}
bool dfs(int x) {//匈牙利算法
	va[x]=1;
	for(int y=1; y<=n; y++)
		if(!vb[y])
			if(la[x]+lb[y]==w[x][y]) {
				vb[y]=1;
				if(!match[y]||dfs(match[y])) {
					match[y]=x;
					return true;
				}
			} else upd[y]=min(upd[y],la[x]+lb[y]-w[x][y]);
	return false;
}
int KM() {//KM算法
	memset(match,0,sizeof(match));//初始化
	for(int i=1; i<=n; i++) {
		la[i]=-inf;
		lb[i]=0;
		for(int j=1; j<=n; j++)
			la[i]=max(la[i],w[i][j]);
	}
	for(int i=1; i<=n; i++)//构造符合条件的相等子图
		while(true) {
			memset(va,0,sizeof(va));//清空访问数组
			memset(vb,0,sizeof(vb));
			for(int j=1; j<=n; j++)upd[j]=inf;
			if(dfs(i))break;
			delta=1<<30;
			for(int j=1; j<=n; j++)
				if(!vb[j])delta=min(delta,upd[j]);
			for(int j=1; j<=n; j++) {//修改顶标
				if(va[j])la[j]-=delta;
				if(vb[j])lb[j]+=delta;
			}
		}
	int ans=0;
	for(int i=1; i<=n; i++)//得到答案
		ans+=w[match[i]][i];
	return ans;
}
int main() {
	scanf("%d",&n);
	for(int i=1; i<=n; i++)
		for(int j=1; j<=n; j++)
			scanf("%d",&w[i][j]);
    int tans=KM();
	printf("%d\n",tans);
    for(int i=1;i<=n;i++)
    tmatch[i].x=match[i],tmatch[i].y=i;
    sort(tmatch+1,tmatch+1+n,cmp);//排序
	for(int i=1; i<=n; i++)
        {
            int t=w[tmatch[i].x][tmatch[i].y];
            w[tmatch[i].x][tmatch[i].y]=-inf;
            if(KM()<tans)printf("%d %d\n",tmatch[i].x,tmatch[i].y);
            w[tmatch[i].x][tmatch[i].y]=t;
        }
	return 0;
}
```


---

## 作者：Khassar (赞：4)

我觉得费用流的那篇题解已经把题意说清楚了，所以我就特来贡献一下二分图最佳完美匹配的KM写法。  

具体理论一些的东西你们可以去看我在$P4014$写的题解，里面说的比较多这里就不在写了。

要特别注意的是虽然我用的是$n^3$优化过的KM（我那篇题解里用的是$n^4$的，我会在代码里用注释简单说一下$n^3$优化，其实就是加了个松弛量slack），但还是在加上$n^2$枚举删边后华丽丽地TLE了3个点。  
所以需要在枚举时判一下这条边有没有可能成为答案（具体看代码吧）

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdlib>
#include<string>
#include<queue>
#include<map>
#include<vector>
#include<ctime>

#define ll long long
#define R register
#define IL inline
#define Rf(a,b,c) for(R int (a)=(b);(a)<=(c);++(a))
#define Tf(a,b,c) for(R int (a)=(b);(a)>=(c);--(a))
#define MP make_pair
#define PA pair<int,int>
#define MES(a,b) memset((a),(b),sizeof((a)))
#define MEC(a,b) memcpy((a),(b),sizeof((b)))
#define D double

using namespace std;

const int N=105;

int n,m,lx[N],ly[N],link[N],w[N][N],sl[N],sum,Ans,Link[N];
bool S[N],T[N];

IL int read() {
	int x=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x*=10;x+=(ch-'0');ch=getchar();}
	return x*f;
}
IL void write(int x) {
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}

bool dfs(int x) {//二分图匹配过程
	S[x]=true;
	Rf(i,1,n) 
		if(lx[x]+ly[i]==w[x][i]) {
			if(!T[i]) {
				T[i]=true;
				if(!link[i]||dfs(link[i])) {
					link[i]=x;
					return true;
				}
			}
		}
		else {//用不能进入相等子图的边更新一下松弛量sl
			sl[i]=min(sl[i],lx[x]+ly[i]-w[x][i]);
		}
	return false;
}

IL void update() {
	R int a=1e9;
	Rf(j,1,n) if(!T[j]) //在松弛量中找，而不是再n^2枚举，优化在此
		a=min(a,sl[j]); 
	Rf(i,1,n) {
		if(S[i]) lx[i]-=a;
		if(T[i]) ly[i]+=a;
		sl[i]-=a;
	}
}

IL void KM() {
	Rf(i,1,n) {
		link[i]=lx[i]=ly[i]=0;
		Rf(j,1,n) lx[i]=max(lx[i],w[i][j]);
	}
	Rf(i,1,n) while(true) {
		Rf(j,1,n) {
			S[j]=T[j]=false;sl[j]=1e9;
		}
		if(dfs(i)) break;
		else update();
	}
} 


signed main()
{
	n=read();
	Rf(i,1,n) Rf(j,1,n) w[i][j]=read();
	KM();
	Rf(i,1,n) sum+=lx[i]+ly[i];
	write(sum);putchar('\n');
	Ans=sum;MEC(Link,link);//先记录一个最佳完美匹配
	Rf(k,1,n) Rf(j,1,n) {//枚举删边
		if(w[k][j]<w[Link[j]][j]) continue;
   //如果这条边比j在一个最佳完美匹配中匹配的边的边权要小，那么这条边一定不会在任意一个最佳完美匹配中，就没必要尝试删它。
		R int tmp=w[k][j];
		w[k][j]=-1e7;
		sum=0;
		KM();
		Rf(i,1,n) sum+=lx[i]+ly[i];
		w[k][j]=tmp;
		if(sum!=Ans) {
			printf("%d %d\n",k,j);
		}
	}
	
	return 0;
}
```
啦啦啦，KM跑得飞快

---

## 作者：住在隔壁小莘 (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P3967)

### 题意分析：

看到这个题面，很容易想到是求二分图最大权完美匹配。

建图的话用邻接矩阵或者链式前向星都很容易，以及求最大权也很简单。
但难就难在第二个操作。

第二个操作的内容： **经典的问题是计算幸福值最大的匹配，即完美匹配。然而完美匹配有时候并不唯一，你需要计算对于所有的完美匹配，其交集是什么。**

运用 KM 或者 Dinic 都很容易求得完美匹配的幸福数，但是题目中可能出现多种完美匹配，用题目中的样例来举例。

```
3
1 1 1
2 1 1
1 1 1

```
1. $1 \rightarrow 2 \quad 2 \rightarrow 1 \quad 3 \rightarrow 1$
2. $1 \rightarrow 3 \quad 2 \rightarrow 1 \quad 3 \rightarrow 1$
3. $1 \rightarrow 2 \quad 2 \rightarrow 1 \quad 3 \rightarrow 2$
4. $1 \rightarrow 3 \quad 2 \rightarrow 1 \quad 3 \rightarrow 2$


对于样例，会有以上四种完美匹配，那么题目中的交集是什么呢？

就是第二个男同学选择第一个女同学，因为只有这样才能是幸福之最大的匹配。

也就是样例输出的：
```
最大幸福值： 4
交集：       2 1
```
所以这个题目中所谓的交集，**就是为了构成最大幸福值所必须选择的一些搭配** 。

所以我们可以明显的发现一个性质：如果这些搭配中有一个会不选，那么最大幸福值就会变小。

但是还有一个方面需要大家注意，举个例子：

```
3
1 1 1
2 2 1
1 1 1
```

那么这个时候的交集是什么呢？

你会发现它 **没有交集** ，因为它没有必须选的，那你可以有疑问，那个第二个男生与第一个女生或者第二个女生所产生的幸福值一样啊，那不得两个选一个，这不肯定有交集了吗？

不要忘了在数学上集合的定义是：**设 $A$ ， $B$ 是两个集合，由所有属于集合 $A$ 且属于集合 $B$ 的元素所组成的集合，叫做集合 $A$ 与集合 $B$ 的交集** 。

所以得是构成每个最大幸福值所必选的，每个最大幸福值都需要这一些搭配的才是交集。

所以运用所必须的搭配一定会影响最大幸福值这一性质，我们就可以解决题目啦。

至此，题目理解结束。

代码：
```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<map>
#include<queue>
#define int long long
using namespace std;
struct node{
	int x,y;
}p[1010];
bool cmp(node a,node b){
	return a.x<b.x;
}
const int INF=0x3f3f3f3f3f;
const int N=550;
int n,m,match[N],pri[N];//数组定义看文末
bool vis2[N];
long long fav[N][N],val1[N],val2[N],sla[N];

void bfs(int k){//正常的BFS求二分图最大权完美匹配啦
	int x,y=0,z=0;
	memset(pri,0,sizeof(pri));
	memset(sla,INF,sizeof(sla));
 	match[0]=k;
	do{
		int d=INF;
		x=match[y];
		vis2[y]=true;
		for(int i=1;i<=n;i++){
			if(vis2[i]){
				continue;
			}
			if(sla[i]>val1[x]+val2[i]-fav[x][i]){
				sla[i]=val1[x]+val2[i]-fav[x][i];
				pri[i]=y;
			}
			if(sla[i]<d){
				d=sla[i];
				z=i;
			}
		}
		for(int i=0;i<=n;i++){
			if(vis2[i]){
				val1[match[i]]-=d;val2[i]+=d;
			}else{
				sla[i]-=d;
			}
		}
		y=z;
	}while(match[y]);
	while(y){
		match[y]=match[pri[y]];
		y=pri[y];
	}
}
int KM(){
	memset(match,0,sizeof(match));
	memset(val1,0,sizeof(val1));
	memset(val2,0,sizeof(val2));
	for(int i=1;i<=n;i++){
		memset(vis2,false,sizeof(vis2));
		bfs(i);
	}
	int res=0;
	for(int i=1;i<=n;i++){
		res+=fav[match[i]][i];
	}
	return res;
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>fav[i][j];
		}
	}
	int ans=KM();
	cout<<ans<<endl;
	for(int i=1;i<=n;i++){
		p[i].x=match[i],p[i].y=i;
	}
	sort(p+1,p+n+1,cmp);
	for(int i =1;i<=n;i++){
		int k=fav[p[i].x][p[i].y];
		fav[p[i].x][p[i].y]=-INF;//断开某一条边
		if(KM()<ans){//重新跑一次KM，判断最大值是否有变化
			cout<<p[i].x<<" "<<p[i].y<<endl;
		} 
		fav[p[i].x][p[i].y]=k;
	}
}
/*
设置最大期望值
利用匈牙利算法找增广路
找到增广路，匹配成功，退出
找不到，最小程度降低男生期望，提升女生期望
继续回到(2)开始重复
*/

/*val1[N]/val2[N]分别记录U集与V集点的点权（匹配期望值）

vis1[N]/vis2[N]分别记录每次寻找增广路过程中U集与V集点的访问情况

match[N]记录最终V集内点匹配到的在U集内点的编号

slack[N]记录匹配过程中，U集内任意点能够选择V集内任意点作为匹配对象所需要降低val（期望值）的最小值
*/

```
感谢阅读！


---

## 作者：龙翔凤翥 (赞：2)

### solution：
先考虑第一问，求最大幸福值，显然是二分图带权最大匹模板。直接用**KM**算法。那么如何解决最大匹配后二分图的交集呢？

1. 首先，我是这样想的：如果存在多个最大二分图带权匹配，那么对于处于交集中的男朋友他连向女朋友的那一条边一定是独一无二的，不然他就能够选择另一条权值一样的边连向另一个女朋友，这样就不在交集中了。显然这个想法是片面的，但是跟正解搭上边了。
2. 对于一对在交集中的男女朋友，虽然最大匹配有多个，但这一对男女朋友是会变的，说明这一对男女朋友在匹配中始终是最优解，那么如果把这一对男女朋友的边权值改为0，那么最大匹配的权值和一定会变。在看数据范围N<=80,N^4的复杂度能够接受。所以我们便想到先KM一遍算出最大匹配值，再对每一个男朋友询问他跟哪一个女朋友牵红线，将这条边权改为0，（不必对每一条边都修改，应为那些边不都是最优的边），看最后的最大匹配值是否变小，若不变，则这对男女朋友不在交集中，反之，则在。
3. ****细节注意****： 见代码。
### code：
```
#include<bits/stdc++.h>
using namespace std;
#define RN register int 
inline int read()
{
	int k=1,x=0;
	char ch;
	ch=getchar();
	while(ch<'0'||ch>'9'&&ch!='-')
		ch=getchar();
	while(ch=='-')
		k=-1,ch=getchar();
	while(ch>='0'&&ch<='9')
		x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
	return x*k;
}
int n;
int la[500],lb[500],va[500],vb[500];
int match[500],match2[500],w[100][100],data;
int sum=-1;
struct P{
	int l;
	int r;
}h[500];
inline int cmp(P x,P y)
{
	return x.l<y.l;
}
inline bool dfs(int x)
{
	va[x]=1;
	for(RN  y=1;y<=n;y++)
	{
		if(!vb[y])
			if(la[x]+lb[y]-w[x][y]==0)
			{
				vb[y]=1;
				if(!match[y]||dfs(match[y]))
				{
					match[y]=x;
					return true;		
				}			
			}
			else data=min(data,la[x]+lb[y]-w[x][y]);
	}
	return false;
}
inline int km()//用来求修改之前的匹配最大权值，即第一问答案。
{
	for(RN i=1;i<=n;i++)
	{
		la[i]=-(1<<30);
		lb[i]=0;
		for(RN j=1;j<=n;j++)
			la[i]=max(la[i],w[i][j]);
	}
	for(RN k=1;k<=n;k++)
	{
		while(233)
		{
			memset(va,0,sizeof(va));
			memset(vb,0,sizeof(vb));
			data=1<<30;
			if(dfs(k))
				break;
		/*	for(RN j=1;j<=n;j++)
				if(!vb[j])
					data=min(data,la[k]+lb[j]-w[k][j]);*/
			for(RN i=1;i<=n;i++)
			{
				if(va[i])
					la[i]-=data;
				if(vb[i])
					lb[i]+=data;
			}
		}
	}
	int ans=0;
	for(RN i=1;i<=n;i++)
		ans+=w[match[i]][i];
	return ans;
}
inline bool dfs2(int x)
{
	va[x]=1;
	for(RN y=1;y<=n;y++)
	{
		if(!vb[y])
			if(la[x]+lb[y]-w[x][y]==0)
			{
				vb[y]=1;
				if(!match2[y]||dfs2(match2[y]))
				{
					match2[y]=x;
					return true;		
				}	
			}
			else
			data=min(data,la[x]+lb[y]-w[x][y]);
	}
	return false;
}
inline int km2()//处理修改后的匹配最大值。
{
	for(RN i=1;i<=n;i++)
	{
		la[i]=-(1<<30);
		lb[i]=0;
		for(RN j=1;j<=n;j++)
			la[i]=max(la[i],w[i][j]);
	}
	for(RN k=1;k<=n;k++)
	{
		while(233)
		{
			memset(va,0,sizeof(va));
			memset(vb,0,sizeof(vb));
			data=1<<30;
			if(dfs2(k))
				break;
		/*	for(RN j=1;j<=n;j++)
				if(!vb[j])
					data=min(data,la[k]+lb[j]-w[k][j]);
			*/for(RN i=1;i<=n;i++)
			{
				if(va[i])
					la[i]-=data;
				if(vb[i])
					lb[i]+=data;
			}
		}
	}
	int ans2=0;
	for(RN i=1;i<=n;i++)
		ans2+=w[match2[i]][i];
	return ans2;
}
int main()
{
//	freopen("1.out","r",stdin);
//	freopen("ans.out","w",stdout);
	n=read();
	for(RN i=1;i<=n;i++)
		for(RN j=1;j<=n;j++)
			w[i][j]=read();
	//for(RN i=1;i<=5000;i++)
	//	h[i].val=0;
	int sum=km();
	cout<<sum<<endl;
	int tot=0;
	for(RN i=1;i<=n;i++)
	{
		int tmp=w[match[i]][i];//修改这个男朋友到女朋友的边权值
		w[match[i]][i]=0;
		memset(match2,0,sizeof(match2));//注意匹配对象要清零
		if(km2()<sum)//修改后发现答案变小了，说明这对男女在交集中
			h[++tot].r=i,h[tot].l=match[i];
		w[match[i]][i]=tmp;
	}
	sort(h+1,h+tot+1,cmp);
	for(RN i=1;i<=tot;i++)
		cout<<h[i].l<<" "<<h[i].r<<endl;
	return 0;
}

---

## 作者：冷笑叹秋萧 (赞：1)

## 题意
有 $n$ 个男生和 $n$ 个女生，男生 $i$ 和女生 $j$ 配对的幸福值是 $H _{i,j}$，求将所有男生和所有女生配对后幸福值之和的最大值，并且求出有哪几对男女在幸福值之和最大的情况下必须配对，按照男生的编号从小到大输出。
## Solution
看到匹配，很自然地会想到网络流，又因为这里的贡献是不相等的，所以我们可以用流量来限制配对，用费用来计算贡献。

具体连边方式如下，灰常地简单：
- 原点连向男生，流量为 1，费用为 0。
- 男生连向女生，流量为 1，费用为 $h[i][j]$。
- 女生连向汇点，流量为 1，费用为 0。

又因为题目要求总贡献最大，所以我们可以把边权取反，然后跑一遍最小费用最大流，再将答案取反。

然后求必须配对的也很简单，我们记录一下在第一遍费用流的时候有哪些男女生之间边被流过了，然后每次删掉其中一条再跑一遍费用流看看还等不等于最大贡献即可。证明显然。
## CODE
```cpp
#include<bits/stdc++.h>
#define N 105
#define INF 0x3f3f3f3f
using namespace std;
struct G {
	int nxt, to, w, c;
}e[N * N * 10], ee[N * N * 10];
int n, S, T, cnt, ans1, ans, lst[N * N], last[N * N], d[N * N * N], cost[N * N], flow[N * N], head[N * N], num[N][3];
bool bz[N * N];
void add(int u, int v, int w, int c) {
	ee[++cnt].to = v; ee[cnt].w = w; ee[cnt].c = c; ee[cnt].nxt = head[u]; head[u] = cnt;
}
bool spfa(int k1, int k2)
{
	for (int i = S; i <= T; ++i)
		bz[i] = 0, flow[i] = INF, cost[i] = INF;
	int h = 0, t = 1; d[S] = 1; bz[S] = 1; cost[S] = 0; lst[T] = -1;
	for (; h < t; ) {
		int u = d[++h]; bz[u] = 0;
		for (int i = head[u]; ~i; i = e[i].nxt) {
			if (i == k1 || i == k2) continue; int v = e[i].to;
			if (e[i].w && cost[v] > cost[u] + e[i].c) {
				cost[v] = cost[u] + e[i].c; lst[v] = u; last[v] = i; flow[v] = min(flow[u], e[i].w);
				if (!bz[v]) d[++t] = v, bz[v] = 1;
			}
		}
	} return lst[T] != -1;	
}//SPFA求费用流
void mxf(int k1, int k2)
{
	for (; spfa(k1, k2); ) {
		int now = T; ans1 += flow[T] * cost[T];
		for (; now != S; ) e[last[now]].w -= flow[n], e[last[now] ^ 1].w += flow[n], now = lst[now];
	}
}
int main() {
	freopen("match.in", "r", stdin); freopen("match.out", "w", stdout);
	scanf("%d", &n); S = 0; T = n * 2 + 1; cnt = -1;
	for (int i = S; i <= T; ++i) head[i] = -1;
	for (int i = 1; i <= n; ++i)
		add(S, i, 1, 0), add(i, S, 0, 0), add(i + n, T, 1, 0), add(T, i + n, 0, 0);
	for (int i = 1; i <= n; ++i)
		for (int x, j = 1; j <= n; ++j) {
			scanf("%d", &x); add(i, j + n, 1, -x); add(j + n, i, 0, x);
		}
	for (int i = 0; i <= cnt; ++i) e[i] = ee[i];
	mxf(INF, INF); ans = -ans1; printf("%d\n", ans); int tot = 0;
	for (int u = 1; u <= n; ++u) {
		for (int i = head[u]; ~i; i = e[i].nxt) {
			if (e[i].to > n && e[i].to <= n * 2 && !e[i].w) {
				num[++tot][0] = i; num[tot][1] = u; num[tot][2] = e[i].to - n;
			}
		}
	}//统计哪条边被流过了
	for (int i = 1; i <= tot; ++i) {
		for (int k = 0; k <= cnt; ++k) e[k] = ee[k];
		ans1 = 0; mxf(num[i][0], num[i][0] + 1);
		if (-ans1 != ans) printf("%d %d\n", num[i][1], num[i][2]);
	}
	return 0;
} 
```


---

## 作者：ZaireEmery (赞：1)

这题第一问很显然是 KM 的模板题，我们考虑如何解决第二问。

做法：先求出任意一组最大权完美匹配，然后对于匹配里的一条边，如果删去这条边后的最大权完美匹配和原来相同，那么显然这条边不是必须要选的。否则这条边一定是要选的，因为不选这条边会使结果变得更劣。最后输出所有必须选的边即可。

时间复杂度：一共运行 $O(n)$ 次 KM，一次 KM 的时间复杂度为 $O(n^3)$，所以总时间复杂度为 $O(n^4)$。

**PS：这题数据比较弱，$O(n^5)$ 的 dfs 做法可以通过。**

代码:

```cpp
#include<bits/stdc++.h>
#define int long long
#define N 90
using namespace std;
int n,ans;
int e[N][N],id[N][N],lx[N],ly[N],slack[N],px[N],py[N],prv[N],u[N*N],v[N*N],w[N*N],p[N];
bool vx[N],vy[N];
queue<int> q;
void match(int x){
	int tmp;
	while(x){
		tmp=px[prv[x]];
		px[prv[x]]=x;
		py[x]=prv[x];
		x=tmp;
	}
}
void bfs(int x){
	memset(vx,0,sizeof(vx));
	memset(vy,0,sizeof(vy));
	memset(slack,63,sizeof(slack));
	while(!q.empty())q.pop();
	q.push(x);
	while(1){
		while(!q.empty()){
			int u=q.front();
			q.pop();
			vx[u]=1;
			for(int i=1;i<=n;++i)
				if(!vy[i]){
					if(lx[u]+ly[i]-e[u][i]<slack[i]){
						slack[i]=lx[u]+ly[i]-e[u][i];
						prv[i]=u;
						if(slack[i]==0){
							vy[i]=1;
							if(!py[i]){
								match(i);
								return;
							}else q.push(py[i]);
						}
					}
				}
		}
		int d=1e18;
		for(int i=1;i<=n;++i)
			if(!vy[i]) d=min(d,slack[i]);
		for(int i=1;i<=n;++i){
			if(vx[i])lx[i]-=d;
			if(vy[i])ly[i]+=d;
			else slack[i]-=d;
		}
		for(int i=1;i<=n;++i)
			if(!vy[i]){
				if(slack[i]==0){
					vy[i]=1;
					if(!py[i]){
						match(i);
						return;
					}else q.push(py[i]);
				}
			}
	}
}
int KM(){
	memset(prv,0,sizeof(prv));
	memset(lx,0,sizeof(lx));
	memset(ly,0,sizeof(ly));
	memset(px,0,sizeof(px));
	memset(py,0,sizeof(py));
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++) lx[i]=max(lx[i],e[i][j]);
	for(int i=1;i<=n;i++) bfs(i);
	int ans=0;
	for(int i=1;i<=n;i++) ans+=e[py[i]][i];
	return ans;
}
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++) 
		for(int j=1;j<=n;j++) scanf("%lld",&e[i][j]);
	int ans=KM();
	printf("%lld\n",ans);
	for(int i=1;i<=n;i++) p[i]=px[i];
	for(int i=1;i<=n;i++){
		int tmp=e[i][p[i]];
		e[i][p[i]]=-1e18;
		if(KM()!=ans) printf("%lld %lld\n",i,p[i]);
		e[i][p[i]]=tmp;
	}
	return 0;
}
```


---

## 作者：7KByte (赞：1)

写篇题解造福社会。

第一问求带权二分图的最大匹配。

模板题，直接跑``KM算法``或者``费用流``。

简述一下费用流做法：我们用节点$i$表示男生$i$，用节点$n+i$表示女生$i$，然后从节点$i$向节点$n+j$连一条容量为$1$，费用为$H_{i,j}$的边。建立超级源点和超级汇点，原点向男生连边，女生向汇点连边。最后跑最大费用最大流，总的花费即为第一问的答案。


第二位求最大费用最大流的必经边。

一个比较套路的判断必经边的做法是：将该边删除，重新跑费用流，如果答案发生改变，说明该边是必经边。

但如果我们直接枚举每条边删除再跑费用流，并不能再规定时间内跑完。经过观察我们发现，跑第一问的费用流时，一共只有$n$条男生到女生的边有流量。所以其他的男生到女生的边显然不可能为必经边。

所以我们只用枚举删除这$n$条有流量的边即可

最后贴代码

```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define N 200
#define M 20005
using namespace std;
int n,m,s,t,h[N],tot=1,l[N][N],cutx,cuty;
struct edge{
	int to,nxt,cap,val;
}e[M<<1],ee[M<<1];
void add(int x,int y,int z,int cost){
	e[++tot].nxt=h[x];h[x]=tot;e[tot].to=y;e[tot].cap=z;e[tot].val=cost;ee[tot]=e[tot];
	e[++tot].nxt=h[y];h[y]=tot;e[tot].to=x;e[tot].cap=0;e[tot].val=-cost;ee[tot]=e[tot];
}
queue<int>q;
int v[N],d[N],pre[N],flow[N];
bool spfa(){
	memset(v,0,sizeof(v));
	memset(d,0xcf,sizeof(d));
	memset(pre,0,sizeof(pre));
	memset(flow,0,sizeof(flow));
	while(!q.empty())q.pop();
	q.push(s);v[s]=1;flow[s]=0x7fffffff;d[s]=0;
	while(!q.empty()){
		int x=q.front();q.pop();
		v[x]=0;
		for(int i=h[x];i;i=e[i].nxt)if(i^cutx&&i^cuty)if(e[i].cap&&d[x]+e[i].val>d[e[i].to]){
			d[e[i].to]=d[x]+e[i].val,flow[e[i].to]=min(flow[x],e[i].cap),pre[e[i].to]=i;
			if(!v[e[i].to])q.push(e[i].to),v[e[i].to]=1;
		}
	}
	//cout<<d[t]<<endl;
	if(d[t]^0xcfcfcfcf)return true;
	return false;
}
int sum,ans;
void updata(){
	int now=t;
	sum+=flow[now];
	ans+=flow[now]*d[now];
	while(now){
		e[pre[now]].cap-=flow[t];
		e[pre[now]^1].cap+=flow[t];
		now=e[pre[now]^1].to;
	}
}
signed main(){
	scanf("%d",&n);
	s=n+n+1;t=s+1;
	rep(i,1,n)rep(j,1,n){
		int x;scanf("%d",&x);
		add(i,n+j,1,x);
		l[i][j]=tot;
	}
	rep(i,1,n)add(s,i,1,0),add(n+i,t,1,0);
	while(spfa())updata();
	int last;
	printf("%d\n",last=ans);
	rep(i,1,n)rep(j,1,n)if(!e[l[i][j]].cap)l[i][j]=0;
	rep(i,1,n)rep(j,1,n){
		if(!l[i][j])continue;
		cutx=l[i][j];
		cuty=l[i][j]^1;
		sum=0;ans=0;
		rep(r,1,tot)e[r]=ee[r];
		while(spfa())updata();
		//cout<<i<<" "<<j<<" "<<l[i][j]<<" "<<sum<<" "<<ans<<endl;
		if(ans<last){printf("%d %d\n",i,j);break;}
	}
	return 0;
}
```

---

## 作者：Foreverxxx (赞：0)

### 前言

对于涉及到二分图最大权完美匹配的题，我们一共有两种思路：费用流以及 KM 算法。不过我们得明确一个事实，在稠密二分图中，KM 算法的运行效率要优于费用流，并且 KM 的代码相较于费用流要更加的好写。

所以本题中，本人使用的是 KM 算法。

### 思路

对于第一个问题，只需要跑一遍二分图最大权完美匹配就行了。

对于第二个问题，暴力的思路是枚举每一条边，看删除之后是否会让完美匹配的值变小，如果变小了则进行输出。
时间复杂度达到了 $O(n^5)$，显然爆掉。

经过~~简单的~~思考，我们发现，其实只需要枚举最开始的 $n$ 个匹配就行了，因为只有更改了这 $n$ 条边中的某一条边，完美匹配的值才有可能被更改。

于是算上 KM 算法的时间复杂度 $O(n^3)$，总的时间复杂度是 $O(n^4)$，可以过掉此题。

### 一些细节

1. 第二问要求以 $i$ 的递增顺序输出，所以我们需要将第一次匹配的边进行排序后再进行枚举。

2. KM 算法在正常情况下的时间复杂度为 $O(n^3)$，不过有一些构造的数据可以将算法时间复杂度卡到 $O(n^4)$，此时需要使用 BFS 版本的 KM 算法，不过一般都不会卡，因为这基本上毫无意义。

Code
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int sss=0;
	char chh=getchar();
	while(chh<'0'||chh>'9') chh=getchar();
	while(chh>='0'&&chh<='9'){
		sss=sss*10+chh-'0';
		chh=getchar();
	}
	return sss;
}
int n;
int edge[85][85];
bool visx[85],visy[85];
int lx[85],ly[85];
int matched[85],slack[85];
struct node{
	int x,y;
}e[85];
bool cmp(const node& x,const node& y){
	return x.x<y.x;
}
bool find(int now){
	visx[now]=true;
	for(register int i=1;i<=n;i++){
		if(!visy[i]){
			if(lx[now]+ly[i]-edge[now][i]==0){
				visy[i]=true;
				if(!matched[i]||find(matched[i])){
					matched[i]=now;
					return true;
				}
			}
			else slack[i]=min(slack[i],lx[now]+ly[i]-edge[now][i]);
		}
	}
	return false;
}
int KM(){
	memset(matched,0,sizeof matched);
	for(register int i=1;i<=n;i++){
		lx[i]=-0x3f,ly[i]=0;
		for(register int j=1;j<=n;j++){
			lx[i]=max(lx[i],edge[i][j]);
		}
	}
	for(register int i=1;i<=n;i++){
		while(true){
			memset(visx,false,sizeof visx);
			memset(visy,false,sizeof visy);
			memset(slack,0x3f,sizeof slack);
			if(find(i)) break;
			int delta=1e9;
			for(register int j=1;j<=n;j++){
				if(!visy[j]) delta=min(delta,slack[j]);
			}
			for(register int j=1;j<=n;j++){
				if(visx[j]) lx[j]-=delta;
				if(visy[j]) ly[j]+=delta;
			}
		}
	}
	int ans=0;
	for(register int i=1;i<=n;i++)
		ans+=edge[matched[i]][i];
	return ans;
}
int main(){
	n=read();
	for(register int i=1;i<=n;i++){
		for(register int j=1;j<=n;j++){
			edge[i][j]=read();
		}
	}
	int ans=KM();
	printf("%d\n",ans);
	for(register int i=1;i<=n;i++){
		e[i].x=matched[i],e[i].y=i;
	}
	sort(e+1,e+n+1,cmp);//no spj 
	for(register int i=1;i<=n;i++){
		int tmp=edge[e[i].x][e[i].y];
		edge[e[i].x][e[i].y]=0;
		if(KM()<ans) printf("%d %d\n",e[i].x,e[i].y);
		edge[e[i].x][e[i].y]=tmp;
	}
	return 0;
}
```

---


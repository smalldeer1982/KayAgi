# 小 Y 和地铁

## 题目描述

小 Y 是一个爱好旅行的 OIer。一天，她来到了一个新的城市。由于不熟悉那里的交通系统，她选择了坐地铁。

她发现每条地铁线路可以看成平面上的一条曲线，不同线路的交点处一定会设有换乘站 。通过调查得知，没有线路是环线，也没有线路与自身相交。任意两条不同的线路只会在若干个点上相交，没有重合的部分，且没有三线共点的情况。即，如图所示的情况都是不存在的：

 ![](https://cdn.luogu.com.cn/upload/pic/12055.png) 

小 Y 坐着地铁 $0$ 号线，路上依次经过了 $n$ 个换乘站。她记下了每个换乘站可以换乘的线路编号，发现每条线路与她所乘坐的线路最多只有 $2$ 个换乘站。现在小 Y 想知道，除掉她经过的换乘站以外，这个城市里最少有几个换乘站。只有你告诉她正确的答案，她才会答应下次带你去玩呢。


## 说明/提示

【样例 1 解释】

对于样例的前两组数据，一种可能的最优答案如下图所示。

 ![](https://cdn.luogu.com.cn/upload/pic/12053.png) 

【子任务】

一共有 $50$ 个测试点，每个测试点 $2$ 分。你只有在答案完全正确时才能得到该测试点的全部分数，否则不得分。

对于所有测试点，以及对于样例， $1 \leq T \leq 100$, $1 \leq n \leq 44$。对于每个测试点， $n$ 的范围如下表：

![](https://cdn.luogu.com.cn/upload/pic/12054.png)


## 样例 #1

### 输入

```
4 4
1 2 1 2
8
1 2 3 4 1 2 3 4
5
5 4 3 3 5
8
1 2 3 4 1 3 2 4```

### 输出

```
0 
0 
0 
1```

# 题解

## 作者：zhylj (赞：39)

想要更好的阅读体验？前往我的博客：[https://www.cnblogs.com/zhylj/p/9525885.html](https://www.cnblogs.com/zhylj/p/9525885.html)

首先，我们考虑最暴力的方法：

对于每组换乘站，有$8$种情况：

![](https://cdn.luogu.com.cn/upload/pic/15690.png)
![](https://cdn.luogu.com.cn/upload/pic/15691.png)
![](https://cdn.luogu.com.cn/upload/pic/15692.png)
![](https://cdn.luogu.com.cn/upload/pic/15693.png)
![](https://cdn.luogu.com.cn/upload/pic/15694.png)
![](https://cdn.luogu.com.cn/upload/pic/15695.png)
![](https://cdn.luogu.com.cn/upload/pic/15696.png)
![](https://cdn.luogu.com.cn/upload/pic/15697.png)

考虑我们对每组换乘站进行枚举，再加上$O(n)$的暴力找交点数，时间复杂度为$O(n8^{\left(\frac{n}{2}\right)})$，面对$n\le 44$的数据，显然会$\rm TLE$。

期望得分$\rm 10$。

考虑寻找这$8$种情况有没有重复。

我们发现，对于前两种，放到一起，会是这样的：

![](https://cdn.luogu.com.cn/upload/pic/15698.png)

对于这种情况，由于这两条线产生了一个完全包住0号线的环，我们发现对于每一个其他的线，要么不和这两条线产生交点，要么对这两条线每条都产生一个交点。

故，每个点不需要枚举左右，只需要枚举上下即可，时间复杂度$O(4^{(\frac{n}{2})}\times n)$  
情况还剩下：  
![](https://cdn.luogu.com.cn/upload/pic/15690.png)
![](https://cdn.luogu.com.cn/upload/pic/15695.png)
![](https://cdn.luogu.com.cn/upload/pic/15692.png)
![](https://cdn.luogu.com.cn/upload/pic/15697.png)

再考虑，能不能继续减少情况数。

于是我们考虑把前两幅图的放在一起。

![](https://cdn.luogu.com.cn/upload/pic/15700.png)

这张图也构成了环，但是这个环并没有能把0号线包住，但是这个环把0号线右边的所有点包住了，也就是在第一个红点右边的所有点是不会受到这两个的选择的影响的。

然后再来看第一个红点左边的情况，如果你是按左端点从左往右搜索的，你会发现到这步的时候红点左边已经搜索完了，即在左边会进出环的点已经全部决定了，而又因为不会对右边造成影响，所以我们可以贪心地取这两条环产生交点的最小值。

同理，剩下的也可以这样处理。

时间复杂度$O(n2^{\left(\frac{n}{2}\right)})$。

期望得分$\rm 80$分。

搜索的时间复杂度看上去已经很优了，所以我们考虑能不能优化找交点的时间复杂度。

考虑我们从左往搜索，用$a.l,a.r$表示$a$线路的左端点右端点，若只考虑同向，因为$a.l \lt a.r,\;b.l \lt b.r,\; a.l \lt b.l$则有三种情况：

$$1)\quad a.l\lt b.l\lt b.r \lt a.r$$

$$2)\quad a.l\lt a.r\lt b.l \lt b.r$$

$$3)\quad a.l\lt b.l \lt a.r \lt b.r$$

显然，只有情况$3$是相交的。

![](https://cdn.luogu.com.cn/upload/pic/30154.png)

我们发现只有$b.l\lt a.r\lt b.r$我们才需要统计。

是不是很熟悉？你可以使用树状数组来进行统计。

每个右端点标记$1$，然后求$[b.l,b.r]$的和即可。

对于朝向问题，显然左端点的朝向不影响，右端点只有同向才会相交，可以自行画图，这边不作演示。

至于代码，由于写的时候比较早，太丑就不放出来了。

时间复杂度$O(2^{\left(\frac{n}{2}\right)}\log n)$，可以$\rm AC$。

有问题请留言。

---

## 作者：irris (赞：13)

## Preface

**如果搜到的答案不低于当前的最优答案，一定要进行剪枝！！！不剪枝跑 $\boldsymbol{T = 100}$ 只能沦为暴力同分！！！**

## Solution

+ 首先对于每组地铁站，有 $8$ 种换乘情况。标注一遍：

![](https://cdn.luogu.com.cn/upload/image_hosting/zlwtla3l.png)

+ 直接爆搜（$\mathcal O(n8^{\frac{n}{2}})$）在 $n \leq 44$ 的情况下不现实。考虑优化状态，具体地，我们可以先把 ①② 两个连线方式合并起来看：

![](https://cdn.luogu.com.cn/upload/image_hosting/u8h5dm7h.png)

+ 同理可以发现 ③④、⑦⑧ 产生的贡献在无论何时都是一样的，那么我们不妨丢掉 ④⑦ 考虑。现在状态数变成了 $4$ 个，爆搜已经可以获得比较可观的分数了（$\mathcal O(n4^{\frac{n}{2}})$）。考虑继续优化，但是我们已经无法再合并状态了。
+ 我们在搜索的时候将所有换乘站连线按照 $L$ 排序，那么你会发现搜到一对站点时，对它产生交点贡献的只会和前面的换乘站的 $R$ 有关系（这同样是因为我们在先前丢掉了 ④⑦ 而非 ③⑧）。
+ 更具体地，根据在 $0$ 号线的「上方」的 $R$ 和「下方」的 $R$，我们可以把贡献分为两个部分。容易发现在剩下来的四种状态中，①⑧ 的贡献都是「上方」的 $R$ 增加 $1$，而 ③⑥ 反之。
+ 所以这样我们就把每次的抉择变成了两个：对「上方」的 $R$ 贡献还是「下方」的 $R$ 贡献。而对上方贡献时，新增的交点个数可以贪心地选择 ①⑧ 中较小的一个；下方同理。目前时间复杂度 $\mathcal O(n2^{\frac{n}{2}})$。
+ 考虑如何优化贡献的计算：不难发现计算时产生交点的 $R$ 是一段连续的区间，具体地：
> + 选择 ① 时，一个 $R$ 贡献当且仅当：它在「上方」，它的 $R$ 在当前区间 $[l, r]$ 内（开闭区间是无所谓的，毕竟每个位置上只会有一个换乘站）。
> + 选择 ⑧ 时，一个 $R$ 贡献当且仅当：它在「上方」，它的 $R$ 在当前区间 $[r, \inf)$ 内，或它在「下方」，它的 $R$ 在当前区间 $[l, \inf)$ 内。
> + 选择 ③ 时，一个 $R$ 贡献当且仅当：它在「下方」，它的 $R$ 在当前区间 $[l, r]$ 内。
> + 选择 ⑥ 时，一个 $R$ 贡献当且仅当：它在「上方」，它的 $R$ 在当前区间 $[l, \inf)$ 内，或它在「下方」，它的 $R$ 在当前区间 $[r, \inf)$ 内。
+ 找每种贡献明显可以使用树状数组优化。时间复杂度 $\mathcal O(2^{\frac{n}{2}}\log n)$（但是一定要加上开头所述的优化！！！1）。


### Code 

+ $8$ 个状态爆搜：没有写过。
+ $4$ 个状态爆搜（交上去不是 TLE 而是 WA 36 pts，贡献可能算错了吧 /ll 我大为震撼）：

```cpp
#define MAXN 45
int lst[MAXN], status[MAXN];

struct Metro {
	int l, r;
	Metro () {}
	Metro (int L, int R) : l(L), r(R) {}
	const bool operator < (const Metro& k) const {
		return l < k.l;
	}
};

std::vector<Metro> lines;

// status = 0
//      -----------
//      |         |
// =====*=========*=====
//
//
// status = 1
//      -------------------
//      |                 |
// =====*=========*=====  |
//                |       |
//                ---------
// status = 2
//
//
// =====*=========*=====  
//      |         |       
//      -----------
// status = 3
//                ---------
//                |       |
// =====*=========*=====  |
//      |                 |
//      -------------------

int ans = 0x3f3f3f3f;
void dfs(int u = 0, int sum = 0) {
	if (sum >= ans) return;
	if (u == lines.size()) { ans = sum; return; }
	int up0 = 0, down1 = 0, down2 = 0, up3 = 0;
	for (int i = 0; i < u; ++i) {
		if (status[i] == 0) {
			up0 += lines[i].r < lines[u].r && lines[i].r > lines[u].l;
			down1 += lines[i].r > lines[u].l;
			up3 += lines[i].r > lines[u].r;
		} else if (status[i] == 1) {
		    down1 += lines[i].r > lines[u].r;
		    down2 += lines[i].r < lines[u].r && lines[i].r > lines[u].l;
			up3 += 1;
		} else if (status[i] == 2) {
		    down1 += lines[i].r > lines[u].r;
		    down2 += lines[i].r < lines[u].r && lines[i].r > lines[u].l;
			up3 += lines[i].r > lines[u].l;
		} else /*status[i] == 3*/ {
			up0 += lines[i].r < lines[u].r && lines[i].r > lines[u].l;
			down1 += 1;
			up3 += lines[i].r > lines[u].r;
		}
	}
	if (up0 < up3) 
		status[u] = 0, dfs(u + 1, sum + up0);
	else status[u] = 3, dfs(u + 1, sum + up3);
	if (down1 < down2) 
		status[u] = 1, dfs(u + 1, sum + down1);
	else status[u] = 2, dfs(u + 1, sum + down2);
}
int main() {
	int T = read<int>();
	while (T--) {
		int N = read<int>();
		for (int i = 1; i <= N; ++i) {
			int a = read<int>();
			if (lst[a]) lines.push_back(Metro(lst[a], i));
			lst[a] = i;
		}
		std::sort(lines.begin(), lines.end());
		dfs(0); print<int>(ans, '\n');
		memset(lst, 0, sizeof(lst));
		lines.clear(), ans = 0x3f3f3f3f;
	}
	return 0;
}
```

+ 树状数组满分做法，随便卡了点常数，其他部分都一样就不放了：

```cpp
int t0[MAXN], t1[MAXN], Z = 45, ans = 0x3f3f3f3f;
void add0(int x, int v) { while (x <= Z) t0[x] += v, x += x & (-x); }
void add1(int x, int v) { while (x <= Z) t1[x] += v, x += x & (-x); }
int query0(int x) { int ans = 0; while (x) ans += t0[x], x -= x & (-x); return ans; }
int query1(int x) { int ans = 0; while (x) ans += t1[x], x -= x & (-x); return ans; }
void dfs(int u = 0, int sum = 0) {
	if (sum >= ans) return;
	if (u == lines.size()) { ans = std::min(ans, sum); return; }
	int l = lines[u].l, r = lines[u].r, pr0 = query0(r), pr1 = query1(r), pr2 = u - pr0 - pr1;
	pr0 -= query0(l), pr1 -= query1(l);
//	choose :
//	0 -> pr0
//	1 -> pr0 + pr2
//	2 -> pr1
//	3 -> pr1 + pr2
//	printf("%s%d %d %d %d %d\n", std::string(u * 4, ' ').c_str(), u, pr0, pr1, pr2, pr3);
//	printf("%s%d %d\n", std::string(u * 4, ' ').c_str(), std::min(pr0, pr1 + pr2), std::min(pr1, pr0 + pr3));
	add0(r, 1);
	dfs(u + 1, sum + std::min(pr0, pr1 + pr2));
	add0(r, -1), add1(r, 1);
	dfs(u + 1, sum + std::min(pr1, pr0 + pr2));
	add1(r, -1);
//	printf("%s%d\n", std::string(u * 4, ' ').c_str(), ans);
}
```

---

## 作者：meiqwq (赞：6)

我的博客：http://www.cnblogs.com/david--lj/p/8535949.html
题意：一条线段，给定n个点(n<=44)其中每个点可能对应另外一个点。如果一个点有对应点，那么就要用曲线连接这两个点。这些曲线会有许多交点（不存在3线共点）求交点最少个数。

对于数据范围，我们可以发现是二进制暴搜，但是，为了剪枝，还是写dfs

我们发现，对于两个点，有6中连线方式:

复杂度：O(6^(n/2)) 咕咕咕

我们发现，如果把2，3画在一起，他们一定是一个圆环，且包住了整条线段，假如有一条新的线段，我们发现，那条线段要么和2，3都没交点，要么都有交点。也就是说对于两个点，用2还是用3对答案的贡献都是一样的。同理4，5也一样.

这样只用考虑4中情况了：复杂度：O(4^(n/2))还是咕咕咕

然后怎么优化？有的大佬用模拟退火（%%%%%%%%%%%）但我并不会模拟退火。

我们试着将1和2画在一起，我们发现，又是一个环，但这个环有点特殊，对在这两个点左边的点右侧的线段影响相同（在将所有线段排序后进行dfs）但左侧的点对于1或2的答案贡献是不同的。

thus，我们只需在dfs时，计算1，2的产生的答案贡献哪个更少，就用那个4，6同理。
代码中用树状数组优化
复杂度：O(2^(n/2))正常

代码：

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
#define maxn 50
int lowbit(int x){return x&-x;} 
struct treearr{
    int c[maxn],siz;
    void init(int p){int i;for(i=1;i<=p;++i)c[i]=0;siz=p;}
    void add(int x,int d){while(x<=siz){c[x]+=d;x+=lowbit(x);}}
    int sum(int x){int res=0;while(x){res+=c[x];x-=lowbit(x);}return res;}
    int query(int l,int r){return sum(r)-sum(l-1);}
};
treearr up,down;
int n,a[maxn],pos,l[maxn],r[maxn],ans;
void dfs(int st,int sum){
    if(st>pos){
        ans=min(ans,sum);return;
    }
    if(sum>ans)return;
    int i;
    int a1=min(up.query(l[st],r[st]),down.query(l[st],n)+up.query(r[st],n));
    up.add(r[st],1);dfs(st+1,sum+a1);up.add(r[st],-1);
    int a2=min(down.query(l[st],r[st]),up.query(l[st],n)+down.query(r[st],n));
    down.add(r[st],1);dfs(st+1,sum+a2);down.add(r[st],-1);
}
int main(){
    int T;scanf("%d",&T);
    while(T--){
        int i,j;scanf("%d",&n);ans=1<<30;
        for(i=1;i<=n;++i)scanf("%d",&a[i]);
        pos=0;
        for(i=1;i<=n;++i)
            for(j=i+2;j<=n;++j)if(a[i]==a[j])
            {
                l[++pos]=i,r[pos]=j;break;
            }
        up.init(n);down.init(n);
        dfs(1,0);
        printf("%d\n",ans);
    }
}
```

---

## 作者：不存在之人 (赞：3)

显然，我们可以得到这样的性质：

1. 只出现一次的数字对答案没有影响。
2. 相邻数字相同对答案没有影响。

另一个性质是，下面这两张图是等价的：
![](https://i.loli.net/2018/12/30/5c28d2cc354bd.png)
![](https://i.loli.net/2018/12/30/5c28d2cd8ef4a.png)

我们发现两条路线等价当且仅当左右两端点向下或向上方向都一致。 

证明：如果以转换站为纵分界，我们可以将图分为$2*3$的$6$的个区域。两个图被切开后，不连通的区域和相连通的区域是相同的（以线路分隔不同的区域），所以对答案的影响也是相同的。

忽略所有只有一个交点的转站，剩下的按左端点排序然后 $dfs$，维护一下当前右端点朝上和朝下连出去的接头的信息，用个树状数组维护就好了。

---------------------
像上面那种拐弯的情况，就可以理解为走到头再回来。
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=105,inf=0x7fffffff;
int n,a[N],cnt=0,ans=0;
int l[N],r[N];
struct SZSZ
{
    int c[N];
    inline void add(int x,int v) {for(;x<=n;x+=x& -x) c[x]+=v;}
    inline int sum(int x) {int ans=0;for(;x;x-=x&-x) ans+=c[x];return ans;}
    inline int query(int l,int r) {return (l>r)?0:sum(r)-sum(l-1);}
}up,down;
void dfs(int now,int nowans)
{
    if (nowans>=ans) return ;
    if (now>cnt) {ans=nowans;return ;}
    up.add(r[now],1);
    dfs(now+1,nowans+min(up.query(l[now],r[now]-1),down.query(l[now],n)+up.query(r[now]+1,n)));
    up.add(r[now],-1);
    down.add(r[now],1);
    dfs(now+1,nowans+min(down.query(l[now],r[now]-1),up.query(l[now],n)+down.query(r[now]+1,n)));
    down.add(r[now],-1);
}
int main()
{
    int T;
    scanf("%d",&T);
    while (T--)
	{
        ans=inf;cnt=0;
        scanf("%d",&n);
        for (int i=1;i<=n;i++) scanf("%d",&a[i]);
        for (int i=1;i<=n;i++)
            for (int j=i+2;j<=n;j++)
                if (a[i]==a[j]) l[++cnt]=i,r[cnt]=j;
        dfs(1,0);
        printf("%d\n",ans);
    } 
    return 0;
}
```

---

## 作者：你的洛 (赞：2)

闲来无事写篇题解

### [题面传送门](https://www.luogu.com.cn/problem/P4005)

## 简要题意

一条线段上有 $n$ 个点成对连接，求所连的线最小交点数。

## 思路

看到题目中 $n \le 44$ 自然想到最终复杂度大约在 $O (2 ^ \frac{n}{2})$ 左右。
经过思考不难发现不论如何两地铁站之间有且只有以下八种方式进行连接：
![](https://cdn.luogu.com.cn/upload/image_hosting/gqgvld7i.png)

显然可以暴搜解决，搜索复杂度为 $O(8 ^ \frac{n}{2})$，每次搜索结束还需要 $O(n)$ 统计答案，还有一个复杂度为 $O(n ^ 2)$ 的预处理，不足以通过此题。

考虑优化，由下图可知左侧与右侧方案拼在一起便是绕线段一圈，与其他方案组合时是等效的，时间复杂度优化至 $O(4 ^ \frac{n}{2})$：
![](https://cdn.luogu.com.cn/upload/image_hosting/7fnktpry.png)

但是它仍无法通过本题，复杂度瓶颈依然在于搜索，思考统计答案的过程，是由左向右扫的，故如果此状态并不会对左侧产生影响，我们就可以将它们剪去：
![](https://cdn.luogu.com.cn/upload/image_hosting/2z7lrm09.png)

在转移时只需要四选二即可，此时复杂度已经优化至 $O(n \cdot 2 ^ \frac{n}{2})$ 经过计算可以发现极限数据依然会超时。

所以我们拿出树状数组来统计答案，即可通过本题。

## code

```cpp
#include <iostream>
#include <cstring>
using namespace std;
const int N = 50;
int n, m = 0x7fffffff, a[N], state[N], l[N], r[N], tot;
struct BIT
{
	int tr[N], siz;
	inline void init(int s) {memset(tr, 0, sizeof(tr)); siz = s;}
	inline int lowbit(int x) {return x & -x;}
	inline void add(int x, int y) {while(x <= siz) tr[x] += y, x += lowbit(x);}
	inline int query(int x) {int ret = 0; while(x) ret += tr[x], x -= lowbit(x); return ret;}
	inline int query_(int x, int y) {return query(y) - query(x - 1);}
}u, d;
inline void dfs(int st, int sum = 0)
{
	if(sum > m) return;
	if(st > tot)
	{
		m = min(m, sum);
		return;
	}
	int a = min(u.query_(l[st], r[st]), d.query_(l[st], n) + u.query_(r[st], n));
	u.add(r[st], 1);
	dfs(st + 1, sum + a);
	u.add(r[st], -1);
	int b = min(d.query_(l[st], r[st]), u.query_(l[st], n) + d.query_(r[st], n));
	d.add(r[st], 1);
	dfs(st + 1, sum + b);
	d.add(r[st], -1);
}
inline void solve()
{
	cin >> n;
	tot = 0;
	for(int i = 1; i <= n; ++i)
		cin >> a[i], state[i] = 1;
	for(int i = 1; i <= n; ++i) for(int j = i + 1; j <= n; ++j) if(a[i] == a[j])
	{
		l[++tot] = i, r[tot] = j;
		break;
	}
	u.init(n);
	d.init(n);
	m = 0x7fffffff;
	dfs(1);
	cout << m << endl;
}
signed main ()
{
#ifndef ONLINE_JUDGE
    freopen ("test.in", "r", stdin);
    freopen ("test.out", "w", stdout);
#endif
	ios::sync_with_stdio (0);
	int T;
	cin >> T;
	while(T--)
		solve();
	return 0;
}
```

---

## 作者：honglan0301 (赞：2)

## 题目分析
原题链接：[P4005](https://www.luogu.com.cn/problem/P4005  )

标签里提到了模拟退火，但题解里好像都是树状数组……下面我们尝试来用模拟退火做这道题。  

首先我们可以忽略掉与 $0$ 号线只有一个交点的线路，因为我们可以让它足够短从而不与其它任何线路相交。  

于是只剩下了与 $0$ 号线有两个交点的线路，我们首先想到枚举每一条线的形状，这总共有八种。但仔细想想，能够首尾相接并包围整个 $0$ 号线的一对形状一定是等价的，因为任意一条其它的地铁线路要么和它们都没有交点，要么都有一个交点。于是简化后就只剩下了以下四种不同的情况（当然，选另外四种也是没问题的）：  

![](https://cdn.luogu.com.cn/upload/image_hosting/0vem8668.png)

那么我们找出任两条线段的位置关系和形状关系对它们交点个数的影响，然后就可以通过枚举实现 $O(n^2)$ 的计算答案。并且由于模拟退火每次只改变一条线的状态，于是中途只需计算这条线路上交点数量的变化情况，实现 $O(n)$ 的判断新解，足够通过本题。  

注意，由于我们判断交点需要知道两条线的位置关系，所以在给线段编号时不妨给左端点更靠左的线段赋更小的编号，这样能省去一些麻烦。   

之后多调调参，再多交几遍就能 AC 了。  

## 代码
```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <stdlib.h>
#include <ctime>
#include <cmath>
#include <cstdio>
using namespace std;
int t,n,a[45],sum[45],zt[45],b[45],cnt,ansnow,ans;
struct dt
{
	int l;
	int r;
	int tag;
}dt[25];
bool checka(int tag1,int tag2)//这两个判断可以根据题解里的图想一想 
{
	if(tag1==1||tag1==4)
	{
		if(tag2==1||tag2==3)
		{
			return 1;
		}
	}
	else if(tag1==2||tag1==3)
	{
		if(tag2==2||tag2==4)
		{
			return 1;
		}
	}
	return 0;
}
bool checkb(int tag1,int tag2)//其实这两个check有些多余了（
{
	if(tag2==3||tag2==4)
	{
		return 1;
	}
	return 0;
}
bool check(int x,int y)//此时已经默认了x的左端点比y的左端点更靠左
{
	if(dt[x].r<dt[y].l)
	{
		return 0;
	}
	else if(dt[x].r<dt[y].r)
	{
		return checka(dt[x].tag,dt[y].tag);
	}
	else if(dt[y].r<dt[x].r)
	{
		return checkb(dt[x].tag,dt[y].tag);
	}
}
int calf()//计算初始答案 
{
	int nsum=0;
	for(int i=1;i<=cnt;i++)
	{
		for(int j=i+1;j<=cnt;j++)
		{
			nsum+=check(i,j);
		}
	}
	return nsum; 
}
int calc(int num,int tg)//每次退火计算新答案 
{
	int nsum=ansnow;
	for(int i=1;i<num;i++)
	{
		nsum-=check(i,num);
	}
	for(int i=num+1;i<=cnt;i++)
	{
		nsum-=check(num,i);
	}
	dt[num].tag=tg;
	for(int i=1;i<num;i++)
	{
		nsum+=check(i,num);
	}
	for(int i=num+1;i<=cnt;i++)
	{
		nsum+=check(num,i);
	}
	ans=min(ans,nsum);
	ansnow=nsum;
	return nsum;
}
int getrd(int l,int r)
{
	return l+rand()%(r-l+1);
}
void SA()
{
	double maxt=50,mint=1e-2;//温度可以设得低一些（
	for(double nowt=maxt;nowt>=mint;nowt*=0.99919)
	{
		int xx=getrd(1,cnt);
		int type=getrd(1,4);
		if(type==dt[xx].tag)
		{
			continue;
		}
		int lasttype=dt[xx].tag;
		int anslast=ansnow;
		int delt=calc(xx,type)-anslast;
		if(exp(-delt/nowt)*RAND_MAX<rand())//已经在calc里更新过答案了，只要判断是否接受新解即可 
		{
			int qqqq=calc(xx,lasttype);
		}
	}
}
int main()
{
	srand(time(0));
	cin>>t;
	while(t--)
	{
		cin>>n;
		memset(sum,0,sizeof(sum));
		memset(zt,0,sizeof(zt));
		cnt=0;
		for(int i=1;i<=n;i++)
		{
			cin>>a[i];
			sum[a[i]]++;
		}
		for(int i=1;i<=n;i++)//去掉无用线段，给线段重标号 
		{
			if(sum[a[i]]==2)
			{
				if(!zt[a[i]])
				{
					cnt++;
					dt[cnt].l=i;
					b[a[i]]=cnt;
					zt[a[i]]=1;
				}
				else
				{
					dt[b[a[i]]].r=i;
				}
			}
		}
		if(cnt==0)
		{
			cout<<"0"<<endl;
			continue;
		}
		ans=100000000;
		for(int i=1;i<=10;i++) 
		{
			for(int i=1;i<=cnt;i++)//初值可以随机 
			{
				dt[i].tag=getrd(1,4);
			}
			ansnow=calf();
			SA();
		}
		cout<<ans<<endl;
	}
}
```

---

## 作者：云浅知处 (赞：1)

地铁线路一共有以下八种情况：（借用<https://www.luogu.com.cn/article/xlzuqwsb>的图）

![](https://cdn.luogu.com.cn/upload/image_hosting/bvryawpp.png)

我们需要最小化所有曲线之间两两的交点个数之和。这里两个曲线之间的交点个数其实不一定是定值，比如我们可以故意扭一下多出来两个交点（如下图），但这种过去的情况显然不优，而且改成正常走也不会更差，因此所有的曲线之间两两的交点个数都能同时取到最小值。

![](https://cdn.luogu.com.cn/upload/image_hosting/kyhyns0r.png)

首先可以发现 2 一定不如 1：对于所有的形状以及区间的排列方式，与 $1$ 的交点数一定不超过与 $2$ 的交点数。注意不一定相等，通过枚举得到，唯一的反例形如：

![](https://cdn.luogu.com.cn/upload/image_hosting/txe4vesg.png)

> 图中绿线只和红线相交，不和蓝线相交。但不存在只和蓝线相交，不和红线相交的曲线。

因此，存在一种最优方案不使用 2 号曲线；同理也存在最优解不用 5 号曲线。

接下来再考虑 3,4 两种曲线，我们证明：对于一个同时存在 3,4 两种曲线的方案，我们同时把所有 4 换成 3，此时方案一定不会变差。这里，我们并不能说「对任意的区间端点排列顺序以及另一种曲线 $x$，两个端点 $i,j$ 用 3,4 曲线连接时和曲线 $x$ 的交点数相同」，反例如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/9u6hx082.png)

> 图中的绿线分别只和蓝线、红线相交。不过通过枚举发现，这是唯二的两边交点数不同的情况。

对于第一种情况，由于我们是同时把 4 换成 3，因子绿线也会跟着换过去，交点数仍然是 $0$；对于第二种情况，把图中红线换成蓝线后交点数从 $2$ 减小至 $0$。因此把所有 4 换成 3 一定不劣。同理，7 换成 8 也一定不劣。

综上我们证明了存在一种最优解只使用以下四种曲线：（图源<https://www.luogu.com.cn/article/5bg3cfct>）

![](https://cdn.luogu.com.cn/upload/image_hosting/u2ailzvq.png)

现在直接枚举可以得到 $O(n4^{n/2})$ 做法，考虑优化。我们把所有点对按照左端点排序，可以发现如果钦定 $l_i<l_j$，那么 $i$ 和别的曲线的交点可以看成在 $r_i$ 位置的一个向上或向下无限延伸的射线和其他曲线的交点，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/xpluysed.png)

> 图中并没有画全所有情况，但可以发现所有情况都是满足条件的。

同理剩下的状态也可以等效为这样的一条向上或向下的竖线。于是本质不同的状态就只有 $O(2^{n/2})$ 种，我们从前往后搜索，同时用数据结构优化求交点个数，时间复杂度就是 $O(2^{n/2}\log n)$，可以通过。

下面的实现的是 $O(n2^{n/2})$ 的代码。

```cpp
#include<bits/stdc++.h>

#define ll long long
#define mk make_pair
#define fi first
#define se second

using namespace std;

inline int read(){
	int x=0,f=1;char c=getchar();
	for(;(c<'0'||c>'9');c=getchar()){if(c=='-')f=-1;}
	for(;(c>='0'&&c<='9');c=getchar())x=x*10+(c&15);
	return x*f;
}

template<typename T>void cmax(T &x,T v){x=max(x,v);}
template<typename T>void cmin(T &x,T v){x=min(x,v);}

const int N=55;
int n,a[N],L[N],R[N];
vector<int>cols;

int chk_sc(int l,int r,int x,int s,int t,int y){
	if(x>y)swap(x,y),swap(l,s),swap(r,t);
	if(x==0&&y==0)return (l<=s&&r>=s&&r<=t)||(s<=l&&l<=t&&r>=t);
	if(x==0&&y==1)return 0;
	if(x==0&&y==2)return l<=t&&t<=r;
	if(x==0&&y==3)return l<=s&&s<=r;
	if(x==1&&y==1)return (l<=s&&r>=s&&r<=t)||(s<=l&&l<=t&&r>=t);
	if(x==1&&y==2)return l<=s&&s<=r;
	if(x==1&&y==3)return l<=t&&t<=r;
	if(x==2&&y==2)return (l<=s)==(t<=r);
	if(x==2&&y==3)return 1-(r<=s||t<=l);
	if(x==3&&y==3)return (l<=s)==(t<=r);
	return -1;
}

int now=0,ans=1e9,tp[N];
void dfs(int nw){
	if(now>=ans)return ;
	if(nw==cols.size())return cmin(ans,now);
	int i=cols[nw];
	vector<int>cnt(4);
	for(int _=0;_<nw;_++){
		int j=cols[_];
		for(int c=0;c<=3;c++)cnt[c]+=chk_sc(L[i],R[i],c,L[j],R[j],tp[j]);
	}
	
	if(cnt[0]<cnt[2])tp[i]=0,now+=cnt[0],dfs(nw+1),tp[i]=-1,now-=cnt[0];
	else tp[i]=2,now+=cnt[2],dfs(nw+1),tp[i]=-1,now-=cnt[2];
	if(cnt[1]<cnt[3])tp[i]=1,now+=cnt[1],dfs(nw+1),tp[i]=-1,now-=cnt[1];
	else tp[i]=3,now+=cnt[3],dfs(nw+1),tp[i]=-1,now-=cnt[3];
}

void solve(){
	n=read();
	for(int i=1;i<=n;i++){
		a[i]=read();
		if(!L[a[i]])L[a[i]]=i;
		else R[a[i]]=i,cols.emplace_back(a[i]);
	}

	sort(cols.begin(),cols.end(),[&](int i,int j){return L[i]<L[j];});

	ans=1e9,dfs(0);
	cout<<ans<<endl;

	vector<int>().swap(cols);
	for(int i=1;i<=n;i++)L[i]=R[i]=0;
}

signed main(void){

	int tt=read();while(tt--)solve();

	return 0;
}
```

---

## 作者：Steven_lzx (赞：1)

# Reference

在 [我的博客](https://www.cnblogs.com/2020gyk080/articles/luogu_P4005.html) 里食用更佳。

前置知识：

1. 树状数组：可参考我写的 [这篇文章](https://www.luogu.com.cn/blog/470638/shujujiegou-shuzhuangshuzu) 。

2. 大法师 DFS。

# Problem & Solution

简化版题意：给定 $n$ （ $n < 45$ ）个点，其中每个点可能对应另外一个点。如果一个点有对应点，那么就要用曲线连接这两个点。这些曲线会有许多交点（不存在环、三线共点、交叉但没有交点这三种情况），求交点最少个数。

根据数据范围可以看出是二进制暴力搜索，看题解里 dalao 都用的是模拟退火云云，但是我不会，所以······

大法师 DFS + 剪枝！~

## 优化们

首先，不难发现，两个点最多有 6 种连线方式，时间复杂度 $O(6^{n/2})$ 。

将它们分别编号 1 ~ 6。

我们发现，如果把 2 、 3 画在一起，他们一定是一个圆环，且包住了整条线段。假如有一条新的线段，则那条线段要么和 2、3 都没交点，要么都有交点。也就是说对于两个点， 2、 3 对答案的贡献都是一样的。

同理，4 、 5 也一样。

这样就变成了 4 种。

其次，我们再试着将 1 和 2 画在一起，又形成了一个环，该环对在这两个点左边的点右侧的线段影响相同（所以我们在将所有线段排序后进行 DFS ）。

虽然左侧的点对于 1 或 2 的答案贡献是不同的，但我们只需在 DFS 时，计算 1、2 的贡献哪个更少，4、6 同理。

再次，在前两个优化的基础上加入树状数组，复杂度 $O(2^{n/2})$ 。

# Code
```cpp
//P4005 小 Y 和地铁
#include<bits/stdc++.h>
namespace TREEARR//树状数组模板
{
	inline int lowbit(int x)
	{
		return x&-x;
	}
	struct Treearr
	{
		int c[1000005],siz;
		void init(int p)//初始化
		{
			for(int i=1;i<=p;i++)
			{
				this->c[i]=0;
			}
			this->siz=p;
			return;
		}
		void add(int x,int d)//修改
		{
			while(x<=siz)
			{
				this->c[x]+=d;
				x+=lowbit(x);
			}
			return;
		}
		int sum(int x)//单点查询
		{
			int res=0;
			while(x)
			{
				res+=this->c[x];
				x-=lowbit(x);
			}
			return res;
		}
		int query(int l,int r)//区间查询
		{
			return this->sum(r)-this->sum(l-1);
		}
	};
}
using namespace std;
int t,n,a[45],pos,l[45],r[45],ans;
TREEARR::Treearr up,down;
void work_dfs(int st,int sum)//DFS
{
	int a1,a2;
	if(st>pos)//找到可行解
	{
		ans=min(ans,sum);//取最小值
		return;
	}
	if(sum>ans)//一处小剪枝，当sum>ans时，即使有可行解也找不到比ans更优的，所以直接返回
	{
		return;
	}
	a1=min(up.query(l[st],r[st]),down.query(l[st],n)+up.query(r[st],n));//第一种情况
    up.add(r[st],1);
	work_dfs(st+1,sum+a1);
	up.add(r[st],-1);
    a2=min(down.query(l[st],r[st]),up.query(l[st],n)+down.query(r[st],n));//第二种情况
    down.add(r[st],1);
	work_dfs(st+1,sum+a2);
	down.add(r[st],-1);
	return;
}
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d",&n);
		ans=1<<30;//注意每次的初始化
		for(int j=1;j<=n;j++)
		{
			scanf("%d",a+j);
		}
		pos=0;
		for(int j=1;j<=n;j++)
		{
			for(int k=j+2;k<=n;k++)
			{
				if(a[k]==a[j])
				{
					l[++pos]=j;
					r[pos]=k;
					break;
				}
			}
		}
		up.init(n);
		down.init(n);
		work_dfs(1,0);
		printf("%d\n",ans);
	}
	return 0;
}
```

---

## 作者：UncleSam_Died (赞：0)

### 解题思路

一眼丁真，模拟退火，那么具体怎么做呢，先来看看我们已经知道的结论：

1. 因为每条线路与所乘坐的线路最多只有两个换乘点，因此可以知道，这些线路可以看作若干条曲线线段，由此，我们可以把题意转化一下：

   - 已知有 $n$ 条曲线与一条直线相交，这些曲线和直线没有重合的部分且交点处只有两条线，不存在封闭曲线，求这些曲线之间的交点的最小值。

   由此可得，我们可以先把这 $n$ 个点处理一下，得到剩下的 $m$ 个点，这 $m$ 个点中，每个点均出现了两次（也就是说删除只出现了一次的点）。

2. 我们可以推出，所有的曲线共有 $6$ 种状态：

   - 全部位于线段下方；

   - 全部位于线段上放；

   - 从线段左端点到当前曲线左端点位于线段**下**方，从左端点到当前曲线右端点位于线段**上**方，可以看做将当前曲线分成了从线段左端点到曲线左端点的一条位于线段**下**方曲线和从左端点到曲线右端点的一条位于线段**上**方的曲线，如图：
   ![](https://cdn.luogu.com.cn/upload/image_hosting/bdraub6t.png)

   - 从线段左端点到当前曲线左端点位于线段**上**方，从左端点到当前曲线右端点位于线段**下**方，可以看做将当前曲线分成了从线段左端点到曲线左端点的一条位于线段**上**方曲线和从左端点到曲线右端点的一条位于线段**下**方的曲线，如图：
   ![](https://cdn.luogu.com.cn/upload/image_hosting/qu9nqmar.png)

   - 从线段右端点到当前曲线右端点位于线段**下**方，从右端点到当前曲线的右端点位于线段**上**方，可以看做将当前曲线分成了从线段右端点到曲线右端点的一条位于线段**下**方曲线和从右端点到曲线左端点的一条位于线段**上**方的曲线，如图：
   ![](https://cdn.luogu.com.cn/upload/image_hosting/r64sd5w7.png)

   - 从线段右端点到当前曲线右端点位于线段**上**方，从右端点到当前曲线的右端点位于线段**下**方，可以看做将当前曲线分成了从线段右端点到曲线右端点的一条位于线段**上**方曲线和从右端点到曲线左端点的一条位于线段**下**方的曲线，如图：
   ![](https://cdn.luogu.com.cn/upload/image_hosting/8uhyffnl.png)

3. 两条曲线 $x$ 和 $y$ 有交点，当且仅当 $x.first<y.first<x.second<y.second$ 或 $y.first<x.first<y.second<x.second$ 且 $x$ 和 $y$ 位于同一方向。

做法如下：

1. 考虑维护一个关于曲线的集合，每一条曲线的表示如下：

   - `stu`：表示当前曲线的状态；

   - `cnt`：表示当前的曲线可以拆分为几条曲线，值为 $1$ 或 $2$；

   - `line[]`：表示当前曲线是由那几条曲线组合成的，其中，`line` 为一个 pair 类型的数组，最多可以存放两个元素，`line` 的 `first` 值表示曲线的左端点，`second` 表示曲线的右端点。

2.  考虑预处理出每条曲线最开始的状态，然后每次随机修改一条曲线的状态，不难发现，单次修改第 $i$ 条线段对于交点个数的影响为 $\displaystyle \Delta=\sum_{j=1}^{m} D(i_{lst},j)-\sum_{j=1}^{m} D(i_{now},j)$，其中 $\Delta$ 表示交点减少的数量，$D(i,j)$ 表示第 $i$ 条曲线和第 $j$ 条曲线交点的数量，$i_{lst}$ 表示修改前的第 $i$ 条曲线 $i_{now}$ 表示修改后的第 $i$ 条曲线，那么我们新的答案 $nowans=lstans-\Delta$，如果是最优解，直接更新答案，否则以一定概率接受，如果没有接受，那么需要改回第 $i$ 条曲线，消除随机修改的影响。

### 时间复杂度分析

我们预处理答案是 $O(n^2)$ 的，而单次修改答案的时间复杂度不会超过 $O(2n)$，那么总时间复杂度即为 $\displaystyle O\left(C\times 2n\log_{\Delta T} \frac{T_0}{T_e}\right)$，其中 $\Delta_T$ 为降温系数，$T_0$ 为初温，$T_e$ 为末温，$C$ 为模拟退火的次数，时间复杂度是能过的。当然了，本题肯定是有更优的更新方法的，~~可惜这里空白太小写不下~~。



---

## 作者：Ouaoan (赞：0)

也许是从自己的ppt上转载的？

[更好的阅读体验](https://blog.csdn.net/rabbit_ZAR/article/details/85100195)

---

**样例解释**

![](https://i.loli.net/2018/12/19/5c19ffe0390ac.png)


---

**简单的想法**

只和0号线有1个交点的线路可以不用考虑，因为可以把它的长度看做无限短。

如果有一条线路左右端点间没有另外一条线的端点，那么这条线可以直接删除。这样操作至没有可以删除的线为止。

这样子样例3就可以不用考虑任何的线路直接输出0了……

---

**一条线和0号线的位置关系**

![](https://i.loli.net/2018/12/19/5c19ffdf4bb21.png)

dfs。

枚举每条线和0号线的位置关系+暴力找交点。

时间复杂度O(𝑛·8^(𝑛/2))，大概只能得10分左右

---

**考虑优化状态数**——

![](https://i.loli.net/2018/12/19/5c19ffe152c7e.png)

可以看出，另一条线要么不经过这两条线，要么同时经过这两条线。

状态由8种变为4种

![](https://i.loli.net/2018/12/19/5c19ffe5574ef.png)

复杂度O(𝑛·4^(𝑛/2))，大概可以得 16分左右

---

**再来考虑优化状态数**——

![](https://i.loli.net/2018/12/19/5c19ffe421037.png)


这个似乎并不能满足其它的线同时经过，或同时不经过这两条线啊？

![](https://i.loli.net/2018/12/19/5c19ffde6bee0.png)

对于每条线的左端点从小到大排序，且在dfs中从小到大的考虑每一条线。

所以只用考虑左端点在当前线后面的线，不会出现上述情况。

![](https://i.loli.net/2018/12/19/5c19ffe648f3f.png)

现在可以看做只有两种状态了。

每种状态的虚线、实线两种情况 可以贪心的选择一种和前面的线交点最少的。

复杂度O(𝑛·2^(𝑛/2))，人品好的话可以得90分？

---

**优化找交点**

考虑加入一条线会对一段区间造成影响，即后面有端点含于这段区间的线有可能会与这条线相交，可以尝试使用可以维护区间操作的数据结构优化。

使用树状数组优化！

每加入一条线，就把它覆盖的区间值+1。更新交点数时只需要加上它的左右端点上的值之差就可以了。

复杂度 O(2^(𝑛/2) 𝑙𝑜𝑔2^𝑛)，注意下常数就可以过了

---

**代码**

```cpp
#include<bits/stdc++.h>
using namespace std;

#define maxn 44
#define read(x) scanf("%d",&x)

#define lowbit(x) (x&-x)

#define query(x,y,L,R) min(qryx(x,y,L,R),qryy(x,y,L,R))
#define qryx(x,y,L,R) (x.Query(R)-x.Query(L-1))
#define qryy(x,y,L,R) (x.Query(n)-x.Query(R-1)+y.Query(n)-y.Query(L-1))

int n;
int a[maxn+5];
int ans;

struct Pair{
	int x,y;
	Pair(){}
	Pair(int xx,int yy) {
		x=xx,y=yy;
	}
	bool operator < (const Pair& oth) const {
		return x<oth.x||(x==oth.x&&y<oth.y);
	}
};

vector<Pair> vec;

struct bst{
	int sum[maxn+5];
	bst(){}
	void add(int x,int d) {
		while(x<=n) {sum[x]+=d,x+=lowbit(x);}
	}
	int Query(int x) {
		int s=0;
		while(x>0) {s+=sum[x],x-=lowbit(x);}
		return s;
	}
};

bst bstup,bstdown;

void init() {
	n=0,ans=1e9,vec.clear();
	memset(bstup.sum,0,sizeof(bstup.sum));
	memset(bstdown.sum,0,sizeof(bstdown.sum));
}

void readin() {
	int nn;
	read(nn);
	
	int x[maxn+5];
	map<int,int> mp;
	for(int i=1;i<=nn;i++) {
		read(x[i]);
		if(mp.count(x[i])) mp[x[i]]++;
		else mp[x[i]]=1;
	}
	
	int use[maxn+5]={0},cnt=0;
	for(int i=1;i<=nn;i++) {
		if(mp[x[i]]<=1) continue;
		if(use[x[i]]&&use[x[i]]==a[n]) {n--;continue;}
		a[++n]=use[x[i]]?use[x[i]]:(use[x[i]]=++cnt);
	}
	
	for(int i=1;i<=n;i++) {
		for(int j=i+1;j<=n;j++) {
			if(a[i]==a[j]) vec.push_back(Pair(i,j));
		}
	}
	sort(vec.begin(),vec.end());
}

void dfs(int x,int s) {
	if(x==vec.size()) {
		ans=min(ans,s);
		return ;
	}
	if(s>=ans) return ;
	int s1=query(bstup,bstdown,vec[x].x,vec[x].y);
	bstup.add(vec[x].y,1);
	dfs(x+1,s+s1);
	bstup.add(vec[x].y,-1);
	
	int s2=query(bstdown,bstup,vec[x].x,vec[x].y);
	bstdown.add(vec[x].y,1);
	dfs(x+1,s+s2);
	bstdown.add(vec[x].y,-1);
}

int main() {
	int T;
	read(T);
	while(T--) {
		init();
		readin();
		dfs(0,0);
		printf("%d\n",ans);
	}
	return 0;
}
```


---

## 作者：Slient_QwQ (赞：0)

## Main Meaning

有 $n$ 个点，每个点有编号，编号相同的两个点可以相连接，问最小的交点个数。

## Solution

观察到 $n \le 44$，可以想到 dfs。

先保存同编号的两个站点位置，最好分先后，若是这个编号的站点只有一个，那么可以直接忽略。

那么这些站点的连线方式有这些：

![](https://cdn.luogu.com.cn/upload/image_hosting/z69ihdtl.png?x-oss-process=image/resize,m_lfit,w_550)
![](https://cdn.luogu.com.cn/upload/image_hosting/k1lyvvax.png?x-oss-process=image/resize,m_lfit,w_550)
![](https://cdn.luogu.com.cn/upload/image_hosting/e6uk151e.png?x-oss-process=image/resize,m_lfit,w_550)
![](https://cdn.luogu.com.cn/upload/image_hosting/09icso3d.png?x-oss-process=image/resize,m_lfit,w_550)
![](https://cdn.luogu.com.cn/upload/image_hosting/cj2yba5o.png?x-oss-process=image/resize,m_lfit,w_550)
![](https://cdn.luogu.com.cn/upload/image_hosting/ag1plaby.png?x-oss-process=image/resize,m_lfit,w_550)
![](https://cdn.luogu.com.cn/upload/image_hosting/k9ods4nx.png?x-oss-process=image/resize,m_lfit,w_550)
![](https://cdn.luogu.com.cn/upload/image_hosting/qbxxpozk.png?x-oss-process=image/resize,m_lfit,w_550)

dfs 时间复杂度为 $O(8 ^ \frac{n}{2})$，明显不能通过此题。

但是很明显，我们可以图1和图2情况忽略（因为有一段包含了整个线段，明显不是最优）。

同时，还有图3图4与图7图8效果是相同的，忽略其中的两个。

这样，从原来的8种变为4种，时间复杂度为 $O(4 ^ \frac{n}{2})$，仍不能通过。

那怎么办？我们可以用树状数组维护区间的线段个数，选择时判断选择哪一种进行。分为两种，我将剩下四种将图4图5分为一组，图3图6分为一组，分别取最优，每一组各跑一次 dfs。

时间复杂度为 $O((2 \log n) ^ \frac{n}{2})$，不能通过，但是加上一个最优性剪枝即可通过。

[Code](https://www.luogu.com.cn/paste/sciqta9t)

---


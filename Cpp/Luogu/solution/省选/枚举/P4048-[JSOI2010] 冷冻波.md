# [JSOI2010] 冷冻波

## 题目描述

WJJ喜欢“魔兽争霸”这个游戏。在游戏中，巫妖是一种强大的英雄，它的技能Frozen Nova每次可以杀死一个小精灵。我们认为，巫妖和小精灵都可以看成是平面上的点。

当巫妖和小精灵之间的直线距离不超过R，且巫妖看到小精灵的视线没有被树木阻挡（也就是说，巫妖和小精灵的连线与任何树木都没有公共点）的话，巫妖就可以瞬间杀灭一个小精灵。

在森林里有N个巫妖，每个巫妖释放Frozen Nova之后，都需要等待一段时间，才能再次施放。不同的巫妖有不同的等待时间和施法范围，但相同的是，每次施放都可以杀死一个小精灵。

现在巫妖的头目想知道，若从0时刻开始计算，至少需要花费多少时间，可以杀死所有的小精灵？


## 样例 #1

### 输入

```
2 3 1
-100 0 100 3
100 0 100 5
-100 -10
100 10
110 11
5 5 10```

### 输出

```
5```

# 题解

## 作者：Gmt丶FFF (赞：13)

首先很好想到我们应该预处理出来每一个巫妖王能攻击到的精灵。

那么这就是一个几何题。

对于每一组精灵与巫妖王，设巫妖王坐标为 $(x_1,y_1)$，精灵坐标为 $(x_2,y_2)$。不考虑树的影响，若巫妖王要看到精灵，那么得满足：

$(x_1-x_2)^2+(y_1-y_2)^2\le r^2$

用勾股定理或是两点间距离公式可以推出。

那么现在有了树的影响，对于每一棵树，我们都得计算它是否会遮挡视野。

如果一棵树会遮挡视野，当且仅当树经过了精灵与巫妖王的连线。

可以利用解析式求解。

精灵与巫妖王的连线斜率为：$k_1=\frac{y_1-y_2}{x_1-x_2}$。

代入直线解析式 $y=k_1x+b_1$ 得截距。

$$\begin{aligned}
&y=\frac{y_1-y_2}{x_1-x_2}x+b_1\\

&b_1=y-\frac{y_1-y_2}{x_1-x_2}x
\end{aligned}$$

得到解析式后要求树是否会挡路，那么就要求树到这儿的最短距离，即垂线段长度，这里依然用的解析法。

垂线段斜率：$k_2=-\frac{1}{k_1}$

垂线段截距：

$$\begin{aligned}
&y=k_2x+b_2\\

&b_2=y-k_2x\\

&b_2=y+\frac{x}{k_1}\\

&b_2=y+\frac{x}{\frac{y_1-y_2}{x_1-x_2}}\\

&b_2=y+\frac{x\times(x_1-x_2)}{y_1-y_2}
\end{aligned}$$

最后解交点坐标 $(x_3,y_3)$：

$$\begin{aligned}
&k_1x_3+b_1=k_2x_3+b_2\\
&(k_1-k_2)x_3=b_2-b_1\\
&x_3=\frac{b_2-b_1}{k_1-k_2}\\
&y_3=k_1x_3+b_1\\
&y_3=k_1\times \frac{b_2-b_1}{k_1-k_2}+b_1
\end{aligned}$$
如果树会挡路当且仅当交点在线段上，且交点距离树的距离小于半径 $r_2$。

若交点在线段上，那么 $x_3\ge\min(x_1,x_2)$ 且 $x_3\le\max(x_1,x_2)$

若距离小于半径，设树的坐标为 $(x_4,y_4)$。

那么 $\sqrt{(x_4-x_3)^2+(y_4-y_3)^2}<r_2$

由于此时坐标为浮点数，可以利用开方解决。

预处理做完后，就开始求时间花费了。

如果抛开冷却不谈，而是求本题有无解，仅仅是问对于每一个精灵是否能有一个巫妖王与之匹配。

如果再限制每个巫妖王施法次数，就是一个最大流问题。

连接源点与每一个巫妖王，边权是该巫妖王可攻击次数。再连接每一个巫妖王与可以攻击到的精灵，边权赋为 $1$，因为一个巫妖王只能攻击一次相同的精灵。最后连接每个精灵与汇点，边权为 $1$，因为每个精灵只能死一次。最后跑最大流即可得出是否有解。

现在有了冷却时间，实际上在一定时间 $time$ 内第 $i$ 个巫妖王可攻击次数为 $time\div t_i+1$。

而本题答案满足单调性，所以可以二分时答案，找到每个巫妖王的攻击次数，每一次跑一个最大流，就可以得到答案了。

约等于二分图匹配所以复杂度为 $O((n+m)\times\sqrt {n+m})$。

预处理复杂度为 $O(nmk)$。

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<cmath>
#include<queue>
#include<cstring>
using namespace std;
const int N=505;
int n,m,k,num[N],dep[N],vis[N];
struct node
{
	int to,data;
};
vector<node>t[N];
vector<int>p[N];
struct wyw
{
	int x,y,r,t;
}a[N];
struct xjl
{
	int x,y;
}b[N];
struct tree
{
	int x,y,r;
}c[N];
inline int tabs(int x)
{
	return x>0?x:-x;
}
bool bfs()
{
	memset(dep,0,sizeof(dep));
	queue<int>q;
	q.push(0);
	dep[0]=1;
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		int len=t[x].size();
		for(int i=0;i<len;i++)
		{
			if(t[x][i].data&&!dep[t[x][i].to])dep[t[x][i].to]=dep[x]+1,q.push(t[x][i].to);
		}
	}
	if(dep[n+m+1])return true;
	return false;
}
int dfs(int x,int num)
{
	if(x==n+m+1)return num;
	if(vis[x])return 0;
	vis[x]=1;
	int len=t[x].size();
	for(int i=0;i<len;i++)
	{
		if(t[x][i].data&&dep[t[x][i].to]==dep[x]+1)
		{
			int res=dfs(t[x][i].to,min(num,t[x][i].data));
			if(res)
			{
				t[x][i].data-=res;
				t[t[x][i].to][p[x][i]].data+=res;
				return res;
			}
		}
	}
	return 0;
}
int main()
{
	//freopen("cold.in","r",stdin);
	//freopen("cold.out","w",stdout);
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=n;i++)scanf("%d%d%d%d",&a[i].x,&a[i].y,&a[i].r,&a[i].t),num[i]=-a[i].t;
	for(int i=1;i<=m;i++)scanf("%d%d",&b[i].x,&b[i].y);
	for(int i=1;i<=k;i++)scanf("%d%d%d",&c[i].x,&c[i].y,&c[i].r);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if((a[i].x-b[j].x)*(a[i].x-b[j].x)+(a[i].y-b[j].y)*(a[i].y-b[j].y)>a[i].r*a[i].r)continue;
			bool flag=1;
			for(int q=1;q<=k;q++)
			{
				double xielv=1.0*(a[i].y-b[j].y)/(1.0*(a[i].x-b[j].x));
				if(a[i].x==b[j].x)xielv=1e-15;
				double jieju=a[i].y-1.0*a[i].x*xielv;
				double xl=-1.0/xielv;
				double jj=c[q].y-1.0*c[q].x*xl;
				double xx=(jj-jieju)/(xielv-xl);
				double yy=xx*xielv+jieju;
				if(xx+1e-5>min(a[i].x,b[j].x)&&xx-1e-5<max(a[i].x,b[j].x)&&sqrt((xx-c[q].x)*(xx-c[q].x)+(yy-c[q].y)*(yy-c[q].y))-1e-5<c[q].r)flag=0;
			}
			if(flag)
			{
				t[i].push_back((node){j+n,1}),t[j+n].push_back((node){i,0});
				p[i].push_back(t[j+n].size()-1),p[j+n].push_back(t[i].size()-1);
			}
		}
		t[i].push_back((node){0,0});
		p[0].push_back(t[i].size()-1);
	}
	for(int i=1;i<=m;i++)
	{
		t[i+n].push_back((node){1+n+m,1}),t[1+n+m].push_back((node){i,0});
		p[n+m+1].push_back(t[i+n].size()-1),p[i+n].push_back(t[n+m+1].size()-1);
	}
	for(int i=1;i<=n;i++)p[i].push_back(0);
	int l=0,r=1e9;
	while(l<r)
	{
		int mid=(l+r)>>1;
		t[0].clear();
		for(int i=1;i<=n;i++)
		{
			t[0].push_back((node){i,mid/a[i].t+1});
			p[i][p[i].size()-1]=t[0].size()-1;
		}
		for(int i=1;i<=n+m;i++)
		{
			int len=t[i].size();
			for(int j=0;j<len;j++)
			{
				if(i<t[i][j].to)t[i][j].data=1;
				else t[i][j].data=0;
			}
		}
		int ans=0;
		while(bfs())
		{
			memset(vis,0,sizeof(vis));
			int sum=dfs(0,1e9);
			while(sum)
			{
				ans+=sum;
				memset(vis,0,sizeof(vis));
				sum=dfs(0,1e9);
			}
		}
		if(ans==m)r=mid;
		else l=mid+1;
	}
	int mid=l;
	t[0].clear();
	for(int i=1;i<=n;i++)
	{
		t[0].push_back((node){i,mid/a[i].t+1});
		p[i][p[i].size()-1]=t[0].size()-1;
	}
	for(int i=1;i<=n+m;i++)
	{
		int len=t[i].size();
		for(int j=0;j<len;j++)
		{
			if(i<t[i][j].to)t[i][j].data=1;
			else t[i][j].data=0;
		}
	}
	int ans=0;
	while(bfs())
	{
		memset(vis,0,sizeof(vis));
		int sum=dfs(0,1e9);
		while(sum)
		{
			ans+=sum;
			memset(vis,0,sizeof(vis));
			sum=dfs(0,1e9);
			
		}
	}
	if(ans!=m)printf("-1");
	else printf("%d",l);
	return 0;
}
```


---

## 作者：_LAUV_ (赞：4)

容易想到可以使用图论模型来跑网络流对吧。

每个巫妖到他可以打到的小精灵连一条流量为1的边，小精灵向汇点T连流量为1的边，表示每只小精灵可以被杀一次。

前面从源点到污妖的边的流量采用二分每次来修改，二分最小的时间，那连向每只巫妖边的流量就是 mid/t+1 

t是这只巫妖的时间间隔，+1 是因为零时刻也可以发射一发冷冻波。

接下来就是计算几何判断巫妖是否能打到小精灵的部分，我用了一个比较不一样的方法。

![](https://cdn.luogu.com.cn/upload/pic/51137.png)

由于是线段，只是求圆心到直线距离来判断肯定是不够的

于是用点积来判断园是否在这个线段正上方或正下方（灰色线内），如果在外面，ptbt * atbt 会小于0

```cpp
bool myTop(Ln l,P pt){
	double x1,x2;
	x1=(l.at-l.bt)*(pt-l.bt);
	x2=(l.bt-l.at)*(pt-l.at);
	if(x1*x2<0)return 0;
	else return 1;
}
```


如果是第二种情况，这条线段是无论如何也不会交到圆（树）的。因为小精灵不会再树内部，所以可以保证圆的半径不会大到与线段相交。

如果圆在线段上方，算一下点到直线距离再判断即可

代码~（怕RE 数组开的有点大）
（网络流用Dinic加当前弧优化）

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>

#define For(i,a,b) for(register int i=a;i<=b;++i)
#define Dwn(i,a,b) for(register int i=a;i>=b;--i)
#define Re register

using namespace std;

const int N=1000,M=1e5+10;

int head[N],nxt[M*2],v[M*2],w[M*2],wx[M*2],cnt=1,ed[N],cur[N];
int n,m,k,S,T;
struct P{double x,y,r; int t;}tr[N],sp[N],ms[N];
struct Ln{P at,bt; double K,B;};
bool kil[N];

inline void read(double &v){
	v=0; bool fg=0;
	char c=getchar(); if(c=='-')fg=1;
	while(c<'0'||c>'9'){c=getchar();if(c=='-')fg=1;}
	while(c>='0'&&c<='9'){v=v*10+c-'0',c=getchar(); if(c=='-')fg=1;}
	if(fg)v=-v;
}
inline void read(int &v){
	v=0; bool fg=0;
	char c=getchar(); if(c=='-')fg=1;
	while(c<'0'||c>'9'){c=getchar();if(c=='-')fg=1;}
	while(c>='0'&&c<='9'){v=v*10+c-'0',c=getchar(); if(c=='-')fg=1;}
	if(fg)v=-v;
}

P operator -(P a,P b){
	P t; t.x=a.x-b.x; t.y=a.y-b.y; return t;
}
int operator *(P a ,P b){
	return a.x*b.x+a.y*b.y;
}
void add(int ux,int vx,int wx){
	cnt++; 
	nxt[cnt]=head[ux]; head[ux]=cnt; v[cnt]=vx; w[cnt]=wx;
	cnt++;
	nxt[cnt]=head[vx]; head[vx]=cnt; v[cnt]=ux; w[cnt]=0;
}
bool myTop(Ln l,P pt){
	double x1,x2;
	x1=(l.at-l.bt)*(pt-l.bt);
	x2=(l.bt-l.at)*(pt-l.at);
	if(x1*x2<0)return 0;
	else return 1;
}
double getK(P a,P b){
	if(a.x==b.x)return 2147483600;
	return (b.y-a.y)/(b.x-a.x);
}
double Dis(P a,P b){
	return sqrt( (a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y) );
}
double DisL(Ln l,P pt){
	double top,bot;
	double x=pt.x,y=pt.y;
	if(l.K==2147483600){
		return fabs(pt.x-l.B);
	}
	top=fabs( l.K*x-y+l.B );
	bot=sqrt(l.K*l.K+1);
	return top/bot;
}
bool OK(Ln l){
	For(i,1,k){
		if(!myTop(l,tr[i]))continue;
		double d=DisL(l,tr[i]);
		if(d<=tr[i].r)return 0;	
	}
	return 1;
}
int q[N*10],dep[N];
bool BFS(){
	int f,r;
	f=r=0;
	memset(dep,0,sizeof(dep));
	q[++r]=S; dep[S]=1;
	while(f!=r){
		int u=q[++f];
		for(Re int i=head[u];i;i=nxt[i]){
			int vv=v[i];
			if(w[i]<=0||dep[vv])continue;
			dep[vv]=dep[u]+1;
			q[++r]=vv;
		}
	} 
	if(!dep[T])return 0;
	else return 1;
}
int DFS(int x,int dist){
	if(x==T)return dist;
	for(Re int &i=cur[x];i;i=nxt[i]){
		int vv=v[i];
		if(dep[vv]==dep[x]+1&&w[i]>0){
			int di=DFS(vv,min(dist,w[i]));
			if(di){
				w[i]-=di;
				w[i^1]+=di;
				return di;
			}
		}
	}
	return 0;
}
int Dinic(){
	int ans=0,di;
	while(BFS()){ 
		memcpy(cur,head,sizeof(cur));
		do{
		    di=DFS(S,2147483600);
		    ans+=di;
		}while(di);
	}
	return ans;
}
int main(){ 
	read(n); read(m); read(k);
	S=0; T=m+n+1;
	For(i,1,n)read(ms[i].x),read(ms[i].y),read(ms[i].r),read(ms[i].t);
	For(i,1,m)read(sp[i].x),read(sp[i].y);
	For(i,1,k)read(tr[i].x),read(tr[i].y),read(tr[i].r);
	
	For(i,1,n) add(S,i,0),ed[i]=cnt^1;
	For(i,1,m) add(i+n,T,1);
	For(i,1,n) For(j,1,m){
		Ln l;
		l.at=ms[i]; l.bt=sp[j];
		double d=Dis(l.at,l.bt); 
		if(d>ms[i].r)continue;
		l.K=getK(l.at,l.bt);
		if(l.K==2147483600)l.B=ms[i].x;
		else l.B=ms[i].y-l.K*ms[i].x;
		if(OK(l))add(i,j+n,1),kil[j]=1;
	}
	memcpy(wx,w,sizeof(wx));
	bool fail=0;
	For(i,1,m) if(!kil[i])fail=1;
	if(fail){
		cout<<-1<<endl;
		return 0;
	}
	int l=0,r=8000000,mid,fn=0;
	while(l<=r){
		mid=(l+r)>>1;
		memcpy(w,wx,sizeof(w));
		For(i,1,n){
			if(mid==0)w[ed[i]]=1;
			else w[ed[i]]=mid/ms[i].t+1;
		}
		int as=Dinic();
		if(as>=m)fn=mid,r=mid-1;
		else l=mid+1;
	}
	cout<<fn<<endl;
	return 0;
}
```



---

## 作者：elijahqi (赞：4)

http://blog.csdn.net/elijahqi/article/details/78970321

辣鸡蒟蒻的原blog qwq

http://www.elijahqi.win/2018/01/04/bzoj-1822-jsoi2010frozen-nova-%e5%86%b7%e5%86%bb%e6%b3%a2/

Description

WJJ喜欢“魔兽争霸”这个游戏。在游戏中，巫妖是一种强大的英雄，它的技能Frozen Nova每次可以杀死一个小精灵。我们认为，巫妖和小精灵都可以看成是平面上的点。 当巫妖和小精灵之间的直线距离不超过R，且巫妖看到小精灵的视线没有被树木阻挡（也就是说，巫妖和小精灵的连线与任何树木都没有公共点）的话，巫妖就可以瞬间杀灭一个小精灵。 在森林里有N个巫妖，每个巫妖释放Frozen Nova之后，都需要等待一段时间，才能再次施放。不同的巫妖有不同的等待时间和施法范围，但相同的是，每次施放都可以杀死一个小精灵。 现在巫妖的头目想知道，若从0时刻开始计算，至少需要花费多少时间，可以杀死所有的小精灵？

Input
输入文件第一行包含三个整数N、M、K(N,M,K<=200)，分别代表巫妖的数量、小精灵的数量和树木的数量。 接下来N行，每行包含四个整数x, y, r, t，分别代表了每个巫妖的坐标、攻击范围和施法间隔（单位为秒）。 再接下来M行，每行两个整数x, y，分别代表了每个小精灵的坐标。 再接下来K行，每行三个整数x, y, r，分别代表了每个树木的坐标。 输入数据中所有坐标范围绝对值不超过10000，半径和施法间隔不超过20000。

Output
输出一行，为消灭所有小精灵的最短时间（以秒计算）。如果永远无法消灭所有的小精灵，则输出-1。

Sample Input

2 3 1

-100 0 100 3


100 0 100 5


-100 -10


100 10

110 11

5 5 10

Sample Output

5
HINT

Source
JSOI2010第二轮Contest1

此题好题orz

蒟蒻我好菜啊

题意：给定n个巫妖 m个小精灵 每个巫妖每次可以干掉一个小精灵每个巫妖攻击之后有个冷却时间 然后询问最少的时间能够干掉全部的小精灵 那么好 把巫妖放在左边小精灵放在右边 可以感觉出来 因为每个小精灵只可以被干掉一次 所以每个小精灵向汇点连1的边 然后 每个巫妖 能干掉几个小精灵 我去二分一下即可 然后如果这个巫妖可以干掉这些小精灵 那么就他们之间连一条边  至于这个二分 有点意思 还是再次跪膜icefox 我大概想了很久没有想到 还是去膜了他的blog 就是我可以直接枚举我最长的那个人需要花费多少时间然后 每条边容量就是这个(最长时间/冷却时间)+1(因为0s的时候也可以攻击） 另外这个如何去判断巫妖能否攻击小精灵 相当于是他们之间不能有树木那就是看一个圆到线段是否有交点 解析几何我哪会啊orz 然后怎么搞 不能简单的使用点到直线距离公式 因为这是个线段啊

点到直线距离公式：练练latex(划去

$dis=\frac{\left | A*x0+B*y0+C\right|}{\sqrt{A^{2}+B^{2}}}$
这个直线是一般式  x0 y0就是树木的坐标 那么画个图可以知道我求一下点到直线的距离 然后再求一下点到线段每个端点的距离 去线段端点之间最长的距离作为斜边  然后 点到直线的距离为直角边 勾股定理求下另一个直角边 如果另一个直角边比线段距离长那么说明点到线段的最短距离是两端选一个最小的否则就是这个点到之间的距离 然后把这个距离和树木的半径比较一下 如果半径更大说明这个树挡住了精灵和巫妖

注意 有可能存在没有小精灵被干掉的情况提前预判




```cpp
#include<cmath>
#include<queue>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define inf 0x3f3f3f3f
#define N 440
using namespace std;
inline char gc(){
    static char now[1<<16],*S,*T;
    if (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if (T==S) return EOF;}
    return *S++;
}
inline int read(){
    int x=0,f=1;char ch=gc();
    while(ch<'0'||ch>'9') {if (ch=='-') f=-1;ch=gc();}
    while(ch<='9'&&ch>='0'){x=x*10+ch-'0';ch=gc();}
    return x*f;
}
int h[N],level[N],cur[N],T,t[N],num=1,st,n,m,in[N];
struct node{
    int x,y,z,next;
}data[88000];
inline void insert1(int x,int y,int z){
    data[++num].y=y;data[num].z=z;data[num].next=h[x];h[x]=num;data[num].x=x;
    data[++num].y=x;data[num].z=0;data[num].next=h[y];h[y]=num;data[num].x=y;
}
inline bool bfs(){
    memset(level,0,sizeof(level));queue<int>q;level[0]=1;q.push(0);
    while(!q.empty()){
        int x=q.front();q.pop();
        for (int i=h[x];i;i=data[i].next){
            int y=data[i].y,z=data[i].z;
            if (level[y]||!z) continue;level[y]=level[x]+1;q.push(y);if (y==T) return 1;
        }
    }return 0;
}
inline int dfs(int x,int s){
    if (x==T) return s;int ss=s,t=h[x];
    for (int i=cur[x];i;i=data[i].next){
        int y=data[i].y,z=data[i].z;
        if (level[x]+1==level[y]&&z){
            int xx=dfs(y,min(s,z));if(!xx) level[y]=0;t=i;
            s-=xx;data[i].z-=xx;data[i^1].z+=xx;if (!s) {cur[x]=i;return ss;}
        }
    }cur[x]=t;return ss-s;
}
inline double calc1(int x,int y,int x1,int y1){
    return sqrt((x-x1)*(x-x1)+(y-y1)*(y-y1));
}
inline double calc(int x1,int y1,int x2,int y2,int x3,int y3){
    double A=(double)(y1-y2)/(x1-x2);double B=-1;double C=y2-double(y1-y2)/(x1-x2)*x2;
    double dis3=fabs(A*x3+B*y3+C)/(sqrt(A*A+B*B));return dis3;
}
inline bool check(int mid){
    for (int i=2;i<st;++i) if (i&1) data[i].z=0;else data[i].z=1;
    for (int i=st;i<=num;++i){
        int now=i-st+1;now>>=1;now+=1;
        if (i&1) data[i].z=0;else data[i].z=mid/t[now]+1;
    }int ans=0;while(bfs()) memcpy(cur,h,sizeof(h)),ans+=dfs(0,inf);
    if (ans!=m) return 0;else return 1;
}
int x[N],y[N],xx1[N],yy1[N],x2[N],y2[N],r[N],r2[N],k;
int main(){
    freopen("bzoj1822.in","r",stdin);
    n=read();m=read();k=read();int max1=0;T=n+m+1;
    for (int i=1;i<=n;++i) x[i]=read(),y[i]=read(),r[i]=read(),t[i]=read(),max1=max(max1,t[i]);
    for (int i=1;i<=m;++i) xx1[i]=read(),yy1[i]=read();
    for (int i=1;i<=k;++i) x2[i]=read(),y2[i]=read(),r2[i]=read();
    for (int i=1;i<=n;++i){
        for (int j=1;j<=m;++j){
            bool flag=1;double dis=calc1(x[i],y[i],xx1[j],yy1[j]);
            if (dis>r[i]) continue;
            for (int z=1;z<=k;++z){
                double dis3=calc(x[i],y[i],xx1[j],yy1[j],x2[z],y2[z]);
                double dis1=calc1(x[i],y[i],x2[z],y2[z]),dis2=calc1(xx1[j],yy1[j],x2[z],y2[z]);
                if (dis1<dis2) swap(dis1,dis2);double dis4=sqrt(dis1*dis1-dis3*dis3);double min1=0;
                if (dis4<dis) min1=dis3;else min1=dis2;
                if (min1<=r2[z]) {flag=0;break;}
            }
            if (flag) insert1(i,n+j,1),++in[j];
        }
    }int l=0,r=m*max1;
    for (int i=1;i<=m;++i) if (!in[i]){puts("-1");return 0;}
    for (int i=1;i<=m;++i) insert1(n+i,T,1);st=num+1;
    for (int i=1;i<=n;++i) insert1(0,i,1);
    //for (int i=2;i<=num;++i) printf("%d %d %d\n",data[i].x,data[i].y,data[i].z);
    while(l<=r){
        int mid=l+r>>1;
        if (check(mid)) r=mid-1;else l=mid+1;
    }printf("%d",l);
    return 0;
}
```

---

## 作者：tzc_wk (赞：3)

计算几何+网络流

安利个人 [blog](https://www.luogu.com.cn/blog/et2006/wang-lao-liu-hao-ti-ti-xie-hui-zong)

首先，值得肯定的一点是，我们需要预处理出哪些女巫可以消灭哪些精灵：只要它们之间的距离小于等于女巫的施法半径，并且没有一个树木经过它们之间的线段。不难发现，如果两点之间的线段不经过圆 $O$，那么 $O$ 到这条线段上任意点的距离的最小值不超过圆的半径。

![](https://cdn.luogu.com.cn/upload/image_hosting/emsjdm66.png)

画个图理解一下，假设 $O$ 到线段两端点 $A,B$ 的距离分别为 $dist_1,dist_2$，到线段所在直线的距离 $|OC|=dist_0$，根据点到直线距离公式 $dist=\frac{|Ax_0+By_0+C|}{\sqrt{A^2+B^2} }$，可以求出。根据勾股定理可以求出 $AC,BC$ 的长。如果 $AC+BC=AB$，那么 $C$ 在线段 $AB$ 上，最短距离就是 $OC$，否则最短距离就是 $OA,OB$ 的最小值。

预处理处理出来了，接下来就是网络流的部分了。发现满足可二分性。假设二分出的时间为 $x$，那么一个施法间隔为 $t$ 的女巫最多可以杀死 $\lfloor \frac{x}{t} \rfloor +1$ 个精灵。这样一来思路就出来了，用女巫和精灵建一个二分图，对于每个女巫 $i$，建边 $(S,i,\lfloor \frac{x}{t} \rfloor +1)$，表示每个女巫最多杀死 $\lfloor \frac{x}{t} \rfloor +1$ 个精灵。对于每个精灵 $j$，连边 $(i,T,1)$，表示每个精灵最多被杀死一次，判断跑出来最大流是否等于 $m$ 即可。

```cpp
/*
数据不清空，爆零两行泪。
多测不读完，爆零两行泪。
边界不特判，爆零两行泪。
贪心不证明，爆零两行泪。
D P 顺序错，爆零两行泪。
大小少等号，爆零两行泪。
变量不统一，爆零两行泪。
越界不判断，爆零两行泪。
调试不注释，爆零两行泪。
溢出不 l l，爆零两行泪。
*/
#include <bits/stdc++.h>
using namespace std;
#define fi			first
#define se			second
#define fz(i,a,b)	for(int i=a;i<=b;i++)
#define fd(i,a,b)	for(int i=a;i>=b;i--)
#define foreach(it,v) for(__typeof(v.begin()) it=v.begin();it!=v.end();it++)
#define put(x)		putchar(x)
#define eoln        put('\n')
#define space		put(' ')
#define y1			y_chenxiaoyan_1
#define y0			y_chenxiaoyan_0
inline int read(){
	int x=0,neg=1;char c=getchar();
	while(!isdigit(c)){
		if(c=='-')	neg=-1;
		c=getchar();
	}
	while(isdigit(c))	x=x*10+c-'0',c=getchar();
	return x*neg;
}
inline void print(int x){
	if(x<0){
		putchar('-');
		print(abs(x));
		return;
	}
	if(x<=9)	putchar(x+'0');
	else{
		print(x/10);
		putchar(x%10+'0');
	}
}
inline int qpow(int x,int e,int _MOD){
	int ans=1;
	while(e){
		if(e&1)	ans=ans*x%_MOD;
		x=x*x%_MOD;
		e>>=1;
	}
	return ans;
}
int head[20005];
struct edge{
	int to,nxt,cap;
} e[3000005];
int ecnt=1;
inline void addedge(int u,int v,int f){
	e[++ecnt].to=v;e[ecnt].cap=f;e[ecnt].nxt=head[u];head[u]=ecnt;
}
int dep[20005];
inline bool bfs(int s,int t){
	queue<int> q;
	memset(dep,-1,sizeof(dep));
	q.push(s);dep[s]=0;
	while(!q.empty()){
		int cur=q.front();q.pop();
		for(int i=head[cur];i;i=e[i].nxt){
			int to=e[i].to;
			if(dep[to]==-1&&e[i].cap){
				dep[to]=dep[cur]+1;
				q.push(to);
			}
		}
	}
	if(dep[t]!=-1)	return 1;
	return 0;
}
inline int dfs(int x,int t,int f){
	if(x==t)	return f;
	int ret=0;
	for(int i=head[x];i;i=e[i].nxt){
		int y=e[i].to;
		if(dep[y]==dep[x]+1&&e[i].cap){
			int w=dfs(y,t,min(f-ret,e[i].cap));
			e[i].cap-=w;
			e[i^1].cap+=w;
			ret+=w;
			if(ret==f)	return f;
		}
	}
	if(ret==0)	dep[x]=-1;
	return ret;
}
inline int Dinic(int s,int t){
	int tot=0;
	while(bfs(s,t))	tot+=dfs(s,t,0x3f3f3f3f);
	return tot;
}
int n=read(),m=read(),k=read();
struct witch{
	int x,y,r,t;
} a[205];
struct elf{
	int x,y;
} b[205];
struct obstacle{
	int x,y,r;
} c[205];
struct line{
	double a,b,c;//ax+by+c=0
};
bool can[205][205];
inline double dist(int x1,int y1,int x2,int y2){
	return 1.0*sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
}
inline line Line(int x1,int y1,int x2,int y2){
	if(x1==x2)	return {1,0,-x1};
	else		return {-1.0*(y1-y2)/(x1-x2),1,0-(-1.0*(y1-y2)/(x1-x2)*x1+y1)};
}
inline double dist_line(line l,int x0,int y0){
	return 1.0*abs(x0*l.a+y0*l.b+l.c)/sqrt(l.a*l.a+l.b*l.b);
}
inline bool check(int mid){
	ecnt=1;memset(head,0,sizeof(head));
	fz(i,1,n)	fz(j,1,m)	if(can[i][j])	addedge(i,j+n,1),addedge(j+n,i,0);
	fz(i,1,n)	addedge(0,i,mid/a[i].t+1),addedge(i,0,0);
	fz(i,1,m)	addedge(i+n,500,1),addedge(500,i+n,0);
	return Dinic(0,500)==m;
}
signed main(){
	fz(i,1,n)	a[i].x=read(),a[i].y=read(),a[i].r=read(),a[i].t=read();
	fz(i,1,m)	b[i].x=read(),b[i].y=read();
	fz(i,1,k)	c[i].x=read(),c[i].y=read(),c[i].r=read();
	fz(i,1,n){
		fz(j,1,m){
			if(dist(a[i].x,a[i].y,b[j].x,b[j].y)>a[i].r)	continue;
			line s=Line(a[i].x,a[i].y,b[j].x,b[j].y);
			bool flag=1;
			fz(l,1,k){
				double dist0=dist_line(s,c[l].x,c[l].y);
				double dist1=dist(c[l].x,c[l].y,a[i].x,a[i].y);
				double dist2=dist(c[l].x,c[l].y,b[j].x,b[j].y);
				double dist3=sqrt(dist1*dist1-dist0*dist0);
				double dist4=sqrt(dist2*dist2-dist0*dist0);
				double dis=dist(a[i].x,a[i].y,b[j].x,b[j].y);
				if(dist3+dist4>dis+1e-6)	dist0=min(dist1,dist2);
				if(dist0<c[l].r)	flag=0;
			}
			can[i][j]=flag;
		}
	}
	int l=0,r=1<<25,ans=-1;
	while(l<=r){
		int mid=(l+r)>>1;
		if(check(mid))	ans=mid,r=mid-1;
		else			l=mid+1;
	}
	print(ans);eoln;
	return 0;
}
```

---

## 作者：DiruiXiao (赞：3)

## [P4048 [JSOI2010]冷冻波](https://www.luogu.com.cn/problem/P4048)

**【前置知识】**

网络流、Dinic 算法、圆和直线的方程以及点到直线的距离公式。

**【题意简述】**

~~**毒瘤题qwq**~~

给定 $N$ 个点，每个点的影响半径为 $R_i$，每间隔 $cd_i$ 的时间能够在影响 $1$ 个点，再给定 $M$ 个点，$K$ 个障碍物，每个障碍物的半径为 $r_i$，$N$ 不能经过障碍物影响 $M$ 中的点 。询问最小影响每一个点的时间，若有属于 $M$ 的点无法被影响，则输出 $-1$。

**【解题思路】**

首先考虑预处理出所有 $N$ 能够到达（影响）的 $M$ 中的点。这里可以处理出 $-1$ 的情况。

假设我们不对于 $N$ 的时间做限制，而是限制每个 $N$ 的最大影响次数。可以考虑转换为图论问题，首先新建两个超级源点编号分别为 $S=0$ 和 $T=550$ 。因为每个 $M$ 点最多只会被连一次，考虑转化为类似二分图匹配的问题。对于 $N_i$ 能够攻击到的 $M_j$ 连一条权重为 $1$ 的有向边，对于每个 $N_i$ 能够攻击 $A_i$ 次，从 $S$ 连一条权重为 $A_i$ 的边，最后，对于每一个 $M_i$  连一条指向 $T$ 的权重为 $1$ 的边。求解问题是只需要跑一遍网络流，统计 $T$ 点的最大流量，如果 $flow(T) > M$ 则证明方案可行。

求解出以上问题，最后发现询问的时间 $t$ 是具有单调性的，而每一个 $N$ 的攻击次数则是等于 $\left\lfloor\dfrac{t}{cd_i}\right\rfloor+1$ （因为 $t = 0$ 的时候也能攻击）。考虑二分答案，每次枚举一个 $t$，在用网络流求解。

接下来回到预处理能够到达的 $m$，发现 $N$、$M$、$K$ 都很小，考虑暴力枚举第 $N_i$ 个点影响第 $M_j$ 个点时，是否会被第 $K_p$ 个障碍物给挡住。

已知直线的一般式为：$Ax+By+C=0$，现已知 $(a,b)$，$(c,d)$，求过该两点的直线一般式：

因为斜率 $k=\dfrac{b-d}{a-c}$，而一般式可以化为 $y=-\frac{C}{B}-\frac{A}{B}x$ 。

则有 $\dfrac{b-d}{a-c}=-\dfrac{A}{B}$。

设 $g = \gcd(a-c, b-d)$。

显然 $A = \dfrac{b - d}{g}$，$B=-\dfrac{a-c}{g}$，对于 $C$ 只需将 $a$，$b$，$A$，$B$ 带入方程式求得即可。

但是要注意特判垂直和水平的情况:

对于垂直，$A=1$，$B=0$，$C=a$。

对于水平，$A=0$，$B=1$，$C=b$。

为方便表示，设 $x_1= x_{N_i}, y_1 = y_{N_i}$，$x2 = x_{M_j}$，$y_2=y_{M_j}$，$x_t=x_{M_p},y_t=y_{M_p}$。

对于判断圆与直线有无交点，设线段端点为 $P$、$Q$，圆心为 $O$，圆到 $PQ$ 所在直线的最短距离的垂点为 $R$。只要满足 $\sqrt{OA^2-OC^2}+\sqrt{OB^2-OC^2}>AB$ 的话，那就没有交点。

而 $OC$ 可以使用点到直线的距离公式 $dis = \dfrac{|Ax+By+C|}{\sqrt{A^2+B^2}}$ 计算，其余线段可以使用勾股定理计算。

最后再判断 $AB$ 是否大于 $N_i$ 的影响距离即可。

预处理出可到达点后，只需对于每个可能的时间重新建边，跑网络流即可。

**【AC代码】**

```cpp
#include<cmath>
#include<cstdio>
#include<iostream>
#include<cstring>
#include<queue>
#define inf 2100483647
#define MAXN 555
const double eps = 1e-8;
using namespace std;
/*------------ 计算几何 ------------*/
int xw[MAXN], yw[MAXN], xt[MAXN], yt[MAXN], xf[MAXN], yf[MAXN], rw[MAXN], rt[MAXN], cd[MAXN], N, M, K;
// xw、yw，xt、yt，xf、yf 分别记录了巫妖、树和小精灵的坐标
// rw 记录巫妖的攻击半径，rt 表示树的半径, cd 记录了巫妖的攻击间隔 
// 记录能否被攻击 
bool avi[MAXN][MAXN], fnd[MAXN];
struct Line{ int A, B, C; }; // 直线的一般式 
bool operator == (const Line &a, const Line &b) { return (a.A == b.A && a.B == b.B && a.C == b.C); } // 判断是否是同一直线 
inline int gcd(int a, int b) { while (a^=b^=a^=b%=a); return b; } // 位运算版 GCD 
inline Line makeLine(int x1, int y1, int x2, int y2) {
	if (x1 == x2) {
		Line l; l.A = 1, l.B = 0, l.C = -x1;
		return l;
	} else if (y1 == y2) {
		Line l; l.A = 0, l.B = 1, l.C = -y1;
		return l;
	}
	int dx = (x1 - x2), dy = (y1 - y2), A, B, C;
	int GCD = gcd(dx, dy);
	A = dy / GCD, B = -dx / GCD;
	C = -(A * x1 + B * y1);
	Line l; l.A = A, l.B = B, l.C = C;
	return l;
}
/*------------ 建边 ------------*/
struct Edge{
	int v, nex, w;
} edge[MAXN * MAXN * 2];
int ecnt, head[MAXN], dep[MAXN], S = 0, T = 500;
inline void addEdge(int u, int v, int w) {
	edge[++ecnt].v = v;
	edge[ecnt].nex = head[u];
	edge[ecnt].w = w;
	head[u] = ecnt;
}

/*------------ Dinic ---------*/

queue<int> q;
inline bool BFS() {
	memset(dep, 0, sizeof(dep));
	while (!q.empty()) q.pop();
	q.push(S);
	dep[S] = 1;
	while (!q.empty()) {
		int F = q.front();
		q.pop();
		for (int i = head[F]; i; i = edge[i].nex) {
			int v = edge[i].v;
			if (dep[v] == 0 && edge[i].w) {
				dep[v] = dep[F] + 1;
				q.push(v);
			}
		}
	}
	if (dep[T] != 0) return true;
	return false;
}

inline int dfs(int u/*当前节点*/, int cur_flow/*当前流量*/) {
	if (u == T) return cur_flow; //到达汇点
	for (int i = head[u]; i; i = edge[i].nex) {
		int v = edge[i].v;
		// 不排除反边
		if (dep[v] == dep[u] + 1 && edge[i].w != 0) { // 满足残量不为零且分层图
			int new_flow = dfs(v, min(cur_flow, edge[i].w));//增广
			if (new_flow > 0) {// 增广成功
				edge[i].w -= new_flow; // 正向边 --
				edge[i ^ 1].w += new_flow; // 反向边 ++
				return new_flow;
			} else {
				dep[v] = 2147483647;
			}
		}
	}
	return 0; // 无增广路
}

int Dinic() {
	int ans = 0;
	while (BFS()) {
		int flow;
		while (flow = dfs(S, inf)) ans += flow;
	}
	return ans;
}

int main() {
	scanf("%d %d %d", &N, &M, &K);
	for (int i = 1; i <= N; ++i) scanf("%d %d %d %d", xw + i, yw + i, rw + i, cd + i);
	for (int i = 1; i <= M; ++i) scanf("%d %d", xf + i, yf + i);
	for (int i = 1; i <= K; ++i) scanf("%d %d %d", xt + i, yt + i, rt + i);
	int cnt = 0;
	for (int i = 1; i <= N; ++i) {
		for (int j = 1; j <= M; ++j) {
			bool flag = 1;
			int x1 = xw[i], y1 = yw[i], x2 = xf[j], y2 = yf[j]; 
			double d = sqrt(1.0 * (x1 - x2) * (x1 - x2) + 1.0 * (y1 - y2) * (y1 - y2));
			if (d > rw[i]) continue;
			Line l = makeLine(x1, y1, x2, y2);
			double A = 1.0 * l.A, B = 1.0 * l.B, C = 1.0 * l.C;
			for (int p = 1; p <= K; ++p) { // 枚举可能经过的树 
				double R = (double)rt[p];
				int tx = xt[p], ty = yt[p];
				double d0 = fabs(1.0 * A * tx + 1.0 * B * ty + C) / sqrt(1.0 * A * A + B * B);
				double d1 = sqrt(1.0 * (x2 - tx) * (x2 - tx) + (y2 - ty) * (y2 - ty) * 1.0), d2 = sqrt(1.0 * (x1 - tx) * (x1 - tx) + 1.0 * (y1 - ty) * (y1 - ty) * 1.0);
				double d3 = sqrt(d1 * d1 - d0 * d0), d4 = sqrt(d2 * d2 - d0 * d0);
				if (d3 + d4 - d > eps) d0 = min(d1, d2);
				if (d0 < R) flag = 0;
			}
			avi[i][j] = flag;
		}
	}
	long long Stime = 0, Etime = 1 << 25, mid, ans = -1;
	while (Stime <= Etime) {
		mid = (Stime + Etime) / 2;
		ecnt = 1;
		memset(head, 0, sizeof(head));
		for (int i = 1; i <= N; ++i) {
			for (int j = 1; j <= M; ++j) {
				if (avi[i][j]) {
					addEdge(i, j + N, 1);
					addEdge(j + N, i, 0);
				}
			}
		}
		for (int i = 1; i <= N; ++i) {
			addEdge(0, i, mid / cd[i] + 1);
			addEdge(i, 0, 0);
		}
		for (int i = 1; i <= M; ++i) {
			addEdge(i + N, T, 1);
			addEdge(T, i + N, 0);
		}
		if (Dinic() == M) {
			Etime = mid - 1, ans = mid;
		} else {
			Stime = mid + 1;
		}
	}
	printf("%d\n", ans);
	return 0;
}

```



---

## 作者：Dispwnl (赞：2)

其实这题。。。除了计算几何有点恶心还是挺水的~~那我还WA那么多次~~

首先一眼就看出这是二分流量最大流判断答案

然后处理巫妖和精灵的关系

由于树木有一个半径，所以要计算点到直线的距离

还有一点要注意，精灵可能在巫妖和树之间，所以计算前要判断一下精灵和树离巫妖的远近~~我的判断好像有漏洞但是水过了~~

判断出来就很水啦

二分时间，处理每个巫妖最多能发几次技能，注意0s时也能发一次

最大流开始打错了+数组开小了。。。RE WA了一片~~可真是菜鸡啊~~

幸亏代码效率不错，暂时第5

代码：
```
# include<iostream>
# include<cstring>
# include<cstdio>
# include<cmath>
# include<queue>
using namespace std;
const int MAX=501,MAXN=1e5+1,inf=1e8;
struct p{
	int x,y,dis;
}c[MAXN];
struct q{
	double x,y,l,ti;
}s[MAX];
struct o{
	double x,y;
}s1[MAX];
struct u{
	double x,y,r;
}s2[MAX];
int n,m,t,k,num=2;
double maxn;
int d[MAX],h[MAX];
int kill[MAX][MAX];
bool use[MAX];
int read()
{
	int x=0,f=1;
	char ch=getchar();
	for(;!isdigit(ch);f=(ch=='-')?-1:1,ch=getchar());
	for(;isdigit(ch);x=x*10+ch-48,ch=getchar());
	return x*f;
}
bool bfs()
{
	queue<int> qu;
	qu.push(0);
	memset(d,0,sizeof(d));
	d[0]=1;
	while(!qu.empty())
	{
		int tt=qu.front();
		qu.pop();
		for(int i=h[tt];i;i=c[i].x)
		  if(c[i].dis&&!d[c[i].y])
		  {
		  	d[c[i].y]=d[tt]+1;
		  	qu.push(c[i].y);
		  }
	}
	return d[t];
}
int dfs(int x,int dix)
{
	if(x==t||!dix) return dix;
	int sum=0;
	for(int i=h[x];i;i=c[i].x)
	  if(d[c[i].y]==d[x]+1&&c[i].dis)
	  {
	  	int dis=dfs(c[i].y,min(c[i].dis,dix));
	  	if(dis)
	  	{
	  		sum+=dis;
	  		dix-=dis;
	  		c[i].dis-=dis;
	  		c[i^1].dis+=dis;
	  		if(!dix) break;
		}
	  }
	if(!sum) d[x]=-1;
	return sum;
}
int dinic()
{
	int tot=0;
	while(bfs()) tot+=dfs(0,inf);
	return tot;
}
void add(int x,int y,int dis)
{
	c[num]=(p){h[y],x,0},h[y]=num++;
	c[num]=(p){h[x],y,dis},h[x]=num++;
}
bool ss(int x,int y)
{
	return (s[x].x-s1[y].x)*(s[x].x-s1[y].x)+(s[x].y-s1[y].y)*(s[x].y-s1[y].y)<=s[x].l*s[x].l;
}
double S(int x,int y)
{
	if(s[x].x!=s1[y].x)
	return (s[x].y-s1[y].y)/(s[x].x-s1[y].x);
}
bool sss(int x,int y,int z)
{
	if(s[x].y<s1[y].y&&s2[z].y>=s[x].y&&s2[z].y-s2[z].r<=s1[y].y) return 1;
	if(s[x].y>=s1[y].y&&s2[z].y<=s[x].y&&s2[z].y+s2[z].r>=s1[y].y) return 1;
	return 0;
}
bool look(int mid)
{
	num=2;
	memset(h,0,sizeof(h));
	for(int i=1;i<=m;++i)
	  add(i+n,t,1);
	for(int i=1;i<=n;++i)
	  for(int j=1;j<=kill[i][0];++j)
	    add(i,kill[i][j]+n,1);
	for(int i=1;i<=n;++i)
	  {
	  	int tim=mid/s[i].ti+1;
	  	add(0,i,tim);
	  }
	if(dinic()==m) return 1;
	return 0;
}
int main()
{
	int sum=0;
	n=read(),m=read(),k=read();
	t=n+m+5;
	for(int i=1;i<=n;++i)
	  {
	  	s[i].x=read(),s[i].y=read(),s[i].l=read(),s[i].ti=read();
	  	maxn=max(maxn,s[i].ti);
	  }
	for(int i=1;i<=m;++i)
	  s1[i].x=read(),s1[i].y=read();
	for(int i=1;i<=k;++i)
	  s2[i].x=read(),s2[i].y=read(),s2[i].r=read();
	for(int i=1;i<=n;++i)
	  {
	  	for(int j=1;j<=m;++j)
	  	  if(ss(i,j))
	  	  {
	  	  	if(s[i].x==s1[j].x)
	  	  	{
	  	  		bool fl=0;
	  	  		for(int l=1;l<=k;++l)
	  	  		  if(sss(i,j,l)&&s2[l].x+s2[l].r>=s[i].x&&s2[l].x-s2[l].r<=s[i].x)
	  	  		  {
	  	  		  	fl=1;
	  	  		  	break;
				  }
				if(!fl)
				{
					kill[i][++kill[i][0]]=j;
					if(!use[j]) use[j]=1,++sum;
				}
			}
			else
			{
				double K=S(i,j),B=s[i].y-s[i].x*K;
				bool fl=0;
				for(int l=1;l<=k;++l)
				  if(sss(i,j,l))
				  {
				  	double s=(K*s2[l].x-s2[l].y+B)/sqrt(K*K+1);
				  	if(s<0) s=-s;
				  	if(s<=s2[l].r)
				  	{
				  		fl=1;
				  		break;
					}
				  }
				if(!fl)
				{
					kill[i][++kill[i][0]]=j;
					if(!use[j]) use[j]=1,++sum;
				}
			}
		  }
	  }
	if(sum!=m)
	{
		printf("-1");
		return 0;
	}
	int l=0,r=maxn*m,ans=-1;
	while(l<=r)
	{
		int mid=(l+r>>1);
		if(look(mid)) ans=mid,r=mid-1;
		else l=mid+1;
	}
	printf("%d",ans);
	return 0;
}
```


---

## 作者：破忆 (赞：2)

## 【题意】

有若干巫妖、精灵和树。

巫妖每隔一定时间可以杀死其攻击范围内的一个精灵，但二者连线不能穿过树。

求杀死所有精灵所需的最小时间。

## 【分析】

### 判断每对巫妖和精灵能否攻击

枚举精灵 $S(x_1,y_1)$ 、巫妖 $L(x_2,y_2)$ 和树 $T(x_3,y_3)$。

精灵必须在巫妖攻击范围内。

精灵和巫妖连线的直线方程 $Ax+By+C=0$ 。

$A=x_1-x_2,B=y_2-y_1,C=x_1y_2-x_2y_1$

计算树到直线的距离 $\frac{|Ax_3+By_3+C|}{\sqrt{A^2+B^2}}$ ，判断是否相离/相切。

相交的情况有两种，有交时 $\angle TSL$ 与 $\angle TLS$ 均为锐角，余弦定理判断即可。

### 计算所需的最短时间

时间越长，巫妖的攻击次数越多，越有可能杀死所有精灵。

满足二分性。

### 判断是否能杀完

显然可以建立一个最大流模型。

源点向巫妖连边，容量为其可杀死的精灵数。

巫妖向可攻击的精灵连边，容量为1。

精灵向汇点连边，容量为1。

流入汇点的流量等于精灵数时有解。

## 【算法】

计算几何+二分+网络流

## 【代码】

```cpp
#include<bits/stdc++.h>
#define DB double
using namespace std;
const int maxn=205,maxt=maxn*2,maxe=maxn*maxn*2,INF=1<<30;
int n,m,k;
int read(){
	int ret=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
struct data{
	DB x,y,r,t;
}A[maxn],B[maxn],C[maxn];
DB sqr(DB x){return x*x;}
DB dis(data x,data y){
	return sqr(x.x-y.x)+sqr(x.y-y.y);
}
DB Dis(DB a,DB b,DB c,DB x,DB y){
	return abs(a*x+b*y+c)/sqrt(sqr(a)+sqr(b));
}
bool fcos(DB a,DB b,DB c){
	return sqr(a)+sqr(b)-sqr(c)>0; 
}
struct Dinic{
    int S,T;
    struct edge{
        int to,nxt,f;
    }e[maxe];
    int tot,lnk[maxt];
    void add_e(int x,int y,int f){
        e[++tot]=(edge){y,lnk[x],f};
        lnk[x]=tot;
    }
    void ADD(int x,int y,int f){
        add_e(x,y,f),add_e(y,x,0);
    }
    int que[maxt],cur[maxt],dep[maxt];
    bool BFS(){
        int hed=0,til=1;
        for(int i=1;i<=T;i++) cur[i]=lnk[i],dep[i]=INF;
        que[1]=S,dep[S]=0;
        while(hed!=til){
            int x=que[++hed];
            for(int j=lnk[x];j;j=e[j].nxt){
                int y=e[j].to;
                if(dep[y]==INF&&e[j].f){
                    dep[y]=dep[x]+1;
                    que[++til]=y;
                }
            }
        }
        return dep[T]!=INF;
    }
    int DFS(int x,int limit){
        if(!limit||x==T) return limit;
        int flow=0,f;
        for(int j=cur[x];j;j=e[j].nxt){
            cur[x]=j;
            int y=e[j].to;
            if(dep[y]==dep[x]+1&&(f=DFS(y,min(limit,e[j].f)))){
                e[j].f-=f;
                e[j^1].f+=f;
                flow+=f;
                limit-=f;
            }
            if(!limit) return flow;
        }
        return flow;
    }
    int calc(){
        int ans=0;
        while(BFS()) ans+=DFS(S,INF);
        return ans;
    }
}D;
struct edge{
	int to,nxt;
}e[maxe];
int tot,lnk[maxn];
void add_e(int x,int y){
	e[++tot]=(edge){y,lnk[x]};
	lnk[x]=tot;
}
bool check(int x){
	D.S=n+m+1,D.T=D.S+1,D.tot=1; 
	memset(D.lnk,0,sizeof D.lnk);
	for(int i=1;i<=n;i++) D.ADD(D.S,i,x/A[i].t+1);
	for(int j=1;j<=m;j++) D.ADD(j+n,D.T,1);
	for(int i=1;i<=n;i++)
		for(int j=lnk[i];j;j=e[j].nxt) D.ADD(i,e[j].to,1);
	return D.calc()==m;
}
int main(){
	freopen("P4048.in","r",stdin);
	freopen("P4048.out","w",stdout);
	n=read(),m=read(),k=read();
	for(int i=1;i<=n;i++) A[i].x=read(),A[i].y=read(),A[i].r=read(),A[i].t=read();
	for(int i=1;i<=m;i++) B[i].x=read(),B[i].y=read();
	for(int i=1;i<=k;i++) C[i].x=read(),C[i].y=read(),C[i].r=read();
	for(int i=1;i<=m;i++){
		for(int j=1;j<=n;j++)
			if(dis(B[i],A[j])<=sqr(A[j].r)){
				bool flg=0;
				DB a=A[j].y-B[i].y,b=-(A[j].x-B[i].x),c=A[j].x*B[i].y+A[j].y*B[i].x;
				for(int t=1;t<=k;t++){
					if(dis(B[i],C[t])<=sqr(C[t].r)){
						printf("-1\n");
						return 0;
					}
					DB x=C[t].x,y=C[t].y,r=C[t].r;
					if(Dis(a,b,c,x,y)>=r) continue;
					DB o=dis(C[t],A[j]),p=dis(C[t],B[i]),q=dis(A[j],B[i]);
					if(fcos(o,q,p)&&fcos(p,q,o)){flg=1;break;}
				}
				if(!flg) add_e(j,i+n);
			}
	}
	int L=0,R=1e9,mid,res=-1;
	while(L<=R){
		mid=(R-L>>1)+L;
		if(check(mid)) res=mid,R=mid-1;
		else L=mid+1;
	}
	printf("%d\n",res);
	return 0;
}
```


---

## 作者：SuBtitle (赞：1)

#### 题目链接

[P4048 冷冻波](https://www.luogu.com.cn/problem/P4048)

## 分析

- 首先将每个巫妖与他能攻击到的精灵建边，一个精灵能被攻击到，需要满足：

  - 巫妖与精灵间的距离在巫妖的攻击范围内。

    $$(x_{p_1}-x_{p_2})^2+(y_{p_1}-y_{p_2})^2 \le {r_{p_1}}^2$$

  - 巫妖与精灵间没有树木阻挡，可以暴力枚举每一棵树，求它到巫妖-精灵这条直线的距离 $dis$，如果 $dis \le r_{p_3}$，则不会阻挡，时间复杂度 $O(n^3)$。 

    求 $dis$ 过程中，可以先求出直线的一般式：

    $$A\times x+B\times y+C=0$$

    再运用点到直线的距离公式：

    $$dis=\frac{A\times x_{p_3}+B\times y_{p_3}+C}{\sqrt{A^2+B^2}}$$

- 建图后，我们再设立一个源点 $s$ 和结点 $e$，将所有巫妖都与 $s$ 连边，将所有精灵都与 $e$ 连边，且将巫妖与精灵、精灵到 $e$ 的边权置为 $1$，此时只要明确了 $s$ 到巫妖的边权，问题就变成了求 $s$ 到 $e$ 的最大流。

  - 当每次给定每个巫妖的最大攻击次数 $x$ 时，相当于 $s$ 到巫妖的边权为 $x$，此时问题解决。
  - 对于时间而言，显而易见的，当超过某个时间节点后，所有精灵一定可以被攻击，当低于某个时间节点时，一定有精灵无法被攻击。
  - 于是考虑二分最终的时间 $time$，将 $t$ 到巫妖的边权置为 $\lfloor time \div t_{p_1} \rfloor +1$，再跑最大流，找到最小的符合条件的 $time$。

## 细节与补充

- 有精灵不能被攻击到，只可能是在建边的过程中，一个精灵无法被任何巫妖攻击到。

## 代码

```c++
#include<iostream>
#include<cstdio>
#include<cmath>
#include<queue>
#include<cstring>
using namespace std;

long long n,m,q,tot=1,head[410],dep[410],first[410],s=401,t=402,ww[90010];
bool cango[210];
queue<long long>dl;

struct wuyao
{
	long long x,y,r,t,id;
}p1[210];

struct jingling
{
	long long x,y;
}p2[210];

struct tree
{
	long long x,y,r;
}p3[210];

struct Edge
{
	long long u,v,w,nex;
}E[90010];

void AddEdge(long long u,long long v,long long w)
{
	++tot;
	E[tot].u=u;
	E[tot].v=v;
	E[tot].w=w;
	E[tot].nex=head[u];
	head[u]=tot;
}

bool bfs()							//bfs分层
{
	while(!dl.empty())
		dl.pop();
	memset(dep,0,sizeof(dep));
	memcpy(first,head,sizeof(first));
	dep[s]=1;
	dl.push(s);
	long long now;
	while(!dl.empty())
	{
		now=dl.front(),dl.pop();
		for(long long i=head[now];i;i=E[i].nex)
		{
			long long v=E[i].v;
			if(dep[v]||ww[i]<=0) continue;
			dep[v]=dep[now]+1;
			dl.push(v);
		}
	}
	if(dep[t]) return 1;
	return 0;
}

long long dfs(long long x,long long md)			//dfs找增广路
{
	if(x==t) return md;
	for(long long &i=first[x];i;i=E[i].nex)
	{
		long long v=E[i].v;
		if(dep[v]!=dep[x]+1||ww[i]<=0) continue;
		long long d=dfs(v,min(md,ww[i]));
		if(d)
		{
			ww[i]-=d;
			ww[i^1]+=d;
			return d;
		}
	}
	return 0;
}

long long dinic()					//最大流(dinic)
{
	long long ret=0;
	for(long long i=2;i<=tot;++i)
		ww[i]=E[i].w;
	while(bfs())
	{
		long long d=dfs(s,1<<30);
		while(d)
		{
			ret+=d;
			d=dfs(s,1<<30);
		}
	}
	return ret;
}

int main()
{
	scanf("%lld%lld%lld",&n,&m,&q);
	for(long long i=1;i<=n;++i)
		scanf("%lld%lld%lld%lld",&p1[i].x,&p1[i].y,&p1[i].r,&p1[i].t);
	for(long long i=1;i<=m;++i)
		scanf("%lld%lld",&p2[i].x,&p2[i].y);
	for(long long i=1;i<=q;++i)
		scanf("%lld%lld%lld",&p3[i].x,&p3[i].y,&p3[i].r);
	double A,B,C,slope,b,dis,tmp;
	for(long long i=1;i<=n;++i)				//建边
	{
		for(long long j=1;j<=m;++j)
		{
			if((p1[i].x-p2[j].x)*(p1[i].x-p2[j].x)+(p1[i].y-p2[j].y)*(p1[i].y-p2[j].y)>p1[i].r*p1[i].r)
				continue;
			slope=(double)(p1[i].y-p2[j].y)/(double)(p1[i].x-p2[j].x);
			b=p1[i].y-p1[i].x*slope;
			B=1,A=-slope,C=-b;
			tmp=sqrt(A*A+B*B);
			bool f=1;
			for(long long k=1;k<=q;++k)
			{
				dis=(A*p3[k].x+B*p3[k].y+C)/tmp;
				if(dis<0) dis=-dis;
				if(dis-p3[k].r<=0)
				{
					f=0;
					break;
				}
			}
			if(f)
			{
				cango[j]=1;
				AddEdge(i,j+n,1);
				AddEdge(j+n,i,0);
			}
		}
	}
	for(long long i=1;i<=m;++i)				//有精灵不能打到
		if(!cango[i])
		{
			puts("-1");
			return 0;
		}
	for(long long i=1;i<=n;++i)				//源点和结点
	{
		AddEdge(s,i,0);
		AddEdge(i,s,0);
	}
	for(long long i=1;i<=m;++i)
	{
		AddEdge(i+n,t,1);
		AddEdge(t,i+n,0);
	}
	long long l=0,r=4000000,mid;
	while(l<r)							//二分time
	{
		mid=l+r>>1;
		for(long long i=head[s];i;i=E[i].nex)
		{
			long long v=E[i].v;
			E[i].w=mid/p1[v].t+1;
		}
		long long ans=dinic();
		if(ans==m)
			r=mid;
		else
			l=mid+1;
	}
	printf("%lld",r);
	return 0;
}
```



---

## 作者：watasky (赞：1)

# 暴力枚举 + 计算几何 + 二分 + 网络流

### 暴力枚举

先枚举判断每个精灵都能被谁杀死，用二维数组存状态，
遇到不能被杀死的精灵就输出 -1 结束。

---
### 几何
判断过程中先看有没有树：

##### 没树
就直接判断巫妖能不能攻击到精灵。



##### 有树 
用点到直线距离算出距离和垂足，判断垂足在不在巫妖和精灵之间；如果不在 就直接判断巫妖能不能攻击到精灵；如果在 比较树的半径和距离；

---

### 二分
在0~最短的杀死所有精灵的时间内，杀死精灵数随时间单调递增，则可以二分最短的杀死所有精灵的时间。

---

### 网络流检验
符合最大流的流量守恒和容量限定，求最多杀死的精灵数的最大流。

建图：源点到巫妖建边，容量为可杀死精灵数；精灵到汇点建边，容量为 1；巫妖到可杀死的精灵建边，容量为 1；

建完图之后，跑一遍 dinic 检验答案。



----
代码
--

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
#define ll long long
const int N=10010,M=200010,inf=1e8;
inline int read()
{
	int x=0;bool t=false;char ch=getchar();
	while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
	if(ch=='-')t=true,ch=getchar();
	while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
	return t?-x:x;
}
int n,m,k,S,T;
int q[N],h[N],e[M],f[M],ne[M],cur[N],d[N],idx;
bool kill[600][600];

struct node
{
    double x,y,r,t;
}lich[N],wisp[M],tree[N];

void add(int a,int b,int c)
{
    e[idx]=b,f[idx]=c,ne[idx]=h[a],h[a]=idx++;
    e[idx]=a,f[idx]=0,ne[idx]=h[b],h[b]=idx++;
}

bool bfs()
{
    int tt=0,hh=0;
    memset(d,-1,sizeof d);
    q[0]=S,d[S]=0,cur[S]=h[S];
    while(hh<=tt)
    {
        int t=q[hh++];
        for(int i=h[t];~i;i=ne[i])
        {
            int ver=e[i];
            if(d[ver]==-1&&f[i])
            {
                d[ver]=d[t]+1;
                cur[ver]=h[ver];
                if(ver==T) return true;
                q[++tt]=ver;
            }
        }
    }
    return false;
}
int find(int u,int limit)
{
    if(u==T) return limit;
    int flow=0;
    for(int i=cur[u];~i&&flow<limit;i=ne[i])
    {
        cur[u]=i;
        int ver=e[i];
        if(d[ver]==d[u]+1&&f[i])
        {
            int t=find(ver,min(limit-flow,f[i]));
            if(!t) d[ver]=-1;
            f[i]-=t,f[i^1]+=t,flow+=t;
        }
    }
    return flow;
}
int dinic()
{
    int ans=0,t;
    while(bfs()) ans+=find(S,inf);
    return ans;
}
bool check(int mid)
{
    memset(h,-1,sizeof h);
    S=0;idx=0;T=n+m+1;
    for(int i=1;i<=n;i++)
    {
        add(S,i,mid/lich[i].t+1);//源点到巫妖建边，容量为可杀死的精灵数 
    }
    for(int i=1;i<=m;i++)
    {
        add(i+n,T,1);//精灵到汇点建边，容量为 1
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            if(kill[i][j])
            {
                add(i,j+n,1);//巫妖到可杀死的精灵建边，容量为1
            }
        }
    }
   
    return dinic()>=m;
}

bool pd(node a,node b,node c,bool ok)
{
    if(ok)//没树 
    {
        if(a.r*a.r<(a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)) return false;// 直接判断能不能攻击到 
	else true;
    }
    else//有树 
    {
	if(a.r*a.r<(a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)) return false; //先判断能不能攻击到 
        ll A=b.y-a.y,
           B=a.x-b.x,
           C=b.x*a.y-a.x*b.y;
        if(c.r&&(A*c.x+B*c.y+C)*(A*c.x+B*c.y+C)>=(A*A+B*B)*c.r*c.r) return true;//如果能攻击到再判断树会不会挡住 
        else
        {
            int xi=(B*B*c.x-A*B*c.y-A*C),yi=(-A*B*c.x+A*A*c.y-B*C)/(A*A+B*B),temp=(A*A+B*B);//处理树到直线的垂点不在巫妖和精灵之间 
            if((a.y<yi&&yi<b.y)||(b.y<yi&&yi<a.y)) return false;
            else return true;
        }
    }
    
}
int main()
{
    n=read(),m=read(),k=read();
    for(int i=1;i<=n;i++)
    {
        lich[i].x=read(),lich[i].y=read(),lich[i].r=read(),lich[i].t=read();
    }
    for(int i=1;i<=m;i++)
    {
        wisp[i].x=read(),wisp[i].y=read();
    }
    for(int i=1;i<=k;i++)
    {
        tree[i].x=read(),tree[i].y=read(),tree[i].r=read();
    }
        
    for(int i=1;i<=n;i++)//暴力枚举存储攻击关系 
    {
        for(int j=1;j<=m;j++)
        {
            bool flag=true,ok=0;
            int g;
            if(k==0) g=0,ok=1;
            else g=1;
                
            for(;g<=k;g++)
            {
                if(!pd(lich[i],wisp[j],tree[g],ok))
                {
                    flag=false;
                    break;
                }
            }
            kill[i][j]=flag;
        }
    }
      
  
       
    for(int i=1;i<=m;i++)//如果有精灵死不了就输出-1 
    {
	bool flag=false;
	for(int j=1;j<=n;j++)
	{
	    if(kill[j][i]) flag=true;
	}
	if(!flag)
        {
            puts("-1");return 0;
        }
    }
      
    int L=0,R=1e9,mid,res=-1;//二分最短的杀死所有精灵的时间 
    while(L<R)
    {
        mid=(L+R)>>1;
        if(check(mid)) R=mid;
	else L=mid+1;
    }
    printf("%d\n",R); 
    
    return 0;
}
```




---

## 作者：genshy (赞：1)

因为求的是最小的时间，考虑二分答案。

我们现在时间确定了，那么每个巫师能打死的小精灵的数量也是确定的。

考虑用网络流求解。

从源点向巫师连一条容量为巫师能打死的小精灵的数量，从每个巫师向他能打到的小精灵连一条容量为 $1$ 的边。

再由每个小精灵向汇点连一条容量为 $1$ 的边。

这样跑出来的最大流，就是我们最多能打死的精灵的数量。

现在想想，怎么求每个巫师能打死那个精灵。 $n^3$ 暴力枚举一下。

因为每棵树的范围是一个圆，所以就相当于问你这个圆是否和巫师和小精灵的连线有交。

可以求出圆心到这条线段的最小距离，在和半径比较即可。

此外，还应该判断小精灵是否在巫师的攻击范围内，即点是否在圆内。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cmath>
#include<cstring>
using namespace std;
const double eps = 1e-8;
const int inf = 1e7+10;
const int N = 2010;
int n,m,k,u,v,s,t,res,tot = 1;
int head[N],dep[N],tim[N],r[N],R[N];
bool used[N][N];
struct node
{
	int to,net,w;
}e[100010];
struct point
{
	int x,y;
	point(){}
	point(int a,int b){x = a, y = b;}
}c[N],p[N],tr[N];
typedef point Vector;
point operator + (point a,point b){return point(a.x+b.x,a.y+b.y);}
point operator - (point a,point b){return point(a.x-b.x,a.y-b.y);}
point operator * (point a,double k){return point(a.x*k,a.y*k);}
double Dot(point a,point b){return a.x*b.x+a.y*b.y;}
double Cro(point a,point b){return a.x*b.y-a.y*b.x;}
double dis(point a,point b){return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}
double dis_PS(point p,point A,point B)
{
	if(Dot(p-A,B-A) < 0) return dis(p,A);
	if(Dot(p-B,A-B) < 0) return dis(p,B);
	return abs(Cro(A-p,B-p))/dis(A,B);
}
void add(int x,int y,int w)
{
	e[++tot].to = y;
	e[tot].w = w;
	e[tot].net = head[x];
	head[x] = tot;
}
bool bfs()
{
	queue<int> q;
	for(int i = 0; i <= t; i++) dep[i] = 0;
	q.push(s); dep[s] = 1;
	while(!q.empty())
	{
		int x = q.front(); q.pop();
		for(int i = head[x]; i; i = e[i].net)
		{
			int to = e[i].to;
			if(e[i].w && !dep[to])
			{
				dep[to] = dep[x] + 1;
				q.push(to);
				if(to == t) return 1;
			}
		}
	}
	return 0;
}
int dinic(int x,int flow)
{
	if(x == t || !flow) return flow;
	int rest = flow, val = 0;
	for(int i = head[x]; i && rest; i = e[i].net)
	{
		int to = e[i].to;
		if(!e[i].w || dep[to] != dep[x] + 1) continue;
		val = dinic(to,min(rest,e[i].w));
		if(val == 0) dep[to] = 0;
		e[i].w -= val; e[i^1].w += val; rest -= val;
	}
	return flow - rest;
}
bool judge(int mid)
{
	s = 0, t = n+m+1, tot = 1, res = 0;
	memset(head,0,sizeof(head));
	for(int i = 1; i <= n; i++) add(s,i,(mid/tim[i])+1), add(i,s,0);
	for(int i = 1; i <= m; i++) add(i+n,t,1), add(t,i+n,0);
	for(int i = 1; i <= n; i++)
	{
		for(int j = 1; j <= m; j++)
		{
			if(used[i][j]) add(i,j+n,1), add(j+n,i,0);
		}
	}
	int flow = 0;
	while(bfs())
	{
		while(flow = dinic(s,inf)) res += flow;
	}
	return res >= m;
}
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	for(int i = 1; i <= n; i++) scanf("%d%d%d%d",&c[i].x,&c[i].y,&r[i],&tim[i]);
	for(int i = 1; i <= m; i++) scanf("%d%d",&p[i].x,&p[i].y);
	for(int i = 1; i <= k; i++) scanf("%d%d%d",&tr[i].x,&tr[i].y,&R[i]);
	for(int i = 1; i <= n; i++)
	{
		for(int j = 1; j <= m; j++)
		{
			int flag = 0;
			double tmp = dis(c[i],p[j]);
			if(tmp > r[i]) continue;
			for(int l = 1; l <= k; l++) 
			{
				double tmp = dis_PS(tr[l],c[i],p[j]);
				if(tmp <= R[l]) flag = 1;
			}
			if(flag == 0) used[i][j] = 1;
		}
	}
	int L = 0, R = 500000, ans = -1;
	while(L <= R)
	{
		int mid = (L + R)>>1;
		if(judge(mid)) 
		{
			R = mid - 1;
			ans = mid;
		}
		else L = mid + 1;
	}
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：AIskeleton (赞：0)

[博客园查看](https://www.cnblogs.com/AIskeleton/p/16445370.html)

> [P4048 冷冻波](https://www.luogu.com.cn/problem/P4048)

> 给定 $n$ 个巫妖，$m$ 个精灵，$k$ 棵树。
> 三者都可看做二维平面上的点，由坐标表示。
> 第 $i$ 棵树的半径为 $R_i$。
> 第 $i$ 个巫妖每隔时间 $t_i$ 可以杀死半径 $r_i$ 内的一个精灵，且**两者的连线不穿过任意一棵树**。
> 求杀死所有精灵最短时间，无解输出 $-1$。

> $n,m,k \le 300,\left\vert x_i \right\vert,\left\vert y_i \right\vert \le 10^4,r_i,R_i \le 2\times 10^4$

首先看到**最短时间**，可以想到**二分答案**。

然后判断每对巫妖和精灵之间能否攻击。
树可以抽象成圆。
- 两点之间距离需小于巫妖攻击半径。

直接求出两点距离比较即可。
- 两点连成的线段要和所有树相离。

求线段到每个圆心的距离，用计算几何解决。

如果距离大于半径就说明线段与圆相离。

如果存在精灵不能被任何一个巫妖攻击到就是无解。


最后是网络流部分，设当前时间为 $x$。

源点向每个巫妖连容量为 $\left\lfloor \dfrac{x}{t_i} \right\rfloor+1$ 的边（$+1$ 是因为时刻 $0$ 可以攻击）。

每个精灵向汇点连容量为 $1$ 的边。

每个巫妖向其能攻击到的每个精灵连容量为 $1$ 的边。

跑网络流，满流则说明能全部杀死。

时间复杂度：$O \left(n^3+\log_2 (t_i\times n)\, \text{网络流} \right)$。

```cpp
#include <bits/stdc++.h>
#define dd double
using namespace std;
const int N=2e4,INF=2e9;
struct d{dd x,y;d(dd X=0,dd Y=0){x=X;y=Y;}}w[N],j[N],s[N];
struct line{d a,b;};
dd dj(d a,d b){return a.x*b.x+a.y*b.y;}dd cj(d a,d b){return a.x*b.y-a.y*b.x;}
d operator+(d a,d b){return d(a.x+b.x,a.y+b.y);}d operator-(d a,d b){return d(a.x-b.x,a.y-b.y);}
dd len(d a,d b){return sqrt(dj(a-b,a-b));}
dd dis(line l,d p){
	if(dj(l.a-p,l.b-p)>0)
		return min(len(l.a,p),len(l.b,p));
	return abs(cj(p-l.a,l.b-l.a)/len(l.a,l.b));
}int n,m,k,st,ed,l,r=INF-1000,mid,ans=INF,mp[1001][1001];
struct E{int v,w,nt;}e[N<<1];
int fir[N],c=1,rw[N],rt[N],tim[N];int cur[N],d[N];queue <int>q;
void init(){memset(e,0,sizeof(e));memset(fir,0,sizeof(fir));c=1;}
void I(int u,int v,int w){
	e[++c]=(E){v,w,fir[u]};fir[u]=c;
	e[++c]=(E){u,0,fir[v]};fir[v]=c;
}bool bfs(){
	for(int i=0;i<=ed;i++)d[i]=0,cur[i]=fir[i];q.push(st);d[st]=1;while(!q.empty()){
		int u=q.front(),V;q.pop();for(int i=fir[u];i;i=e[i].nt)if(!d[V=e[i].v]&&e[i].w)d[V]=d[u]+1,q.push(V);
	}return d[ed];
}int dfs(int u,int fl){
	if(u==ed)return fl;int ans=0,V,re;
	for(int i=cur[u];i;i=e[i].nt){
		cur[u]=i;if(d[V=e[i].v]==d[u]+1&&e[i].w){
			re=dfs(V,min(fl,e[i].w));e[i].w-=re,e[i^1].w+=re;fl-=re,ans+=re;if(!fl)break;}
	}if(!ans)d[u]=0;return ans;
}int dinic(){int ans=0;while(bfs())ans+=dfs(st,INF);return ans;}
bool judge(int x,int y){
	if(len(w[x],j[y])>rw[x]) return 0;bool flag=1;
	for(int i=1;i<=k;i++)
		if(dis((line){w[x],j[y]},s[i])<rt[i]) flag=0;
	return flag;
}bool check(int x){
	init();
	for(int i=1;i<=n;i++)	I(st,i,x/tim[i]+1);
	for(int i=1;i<=m;i++)	I(i+n,ed,1);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			if(mp[i][j]) I(i,j+n,1);
	return dinic()==m;
}int main(){
	freopen("test.in","r",stdin);cin>>n>>m>>k;ed=n+m+1;
	for(int i=1;i<=n;i++) cin>>w[i].x>>w[i].y>>rw[i]>>tim[i];
	for(int i=1;i<=m;i++) cin>>j[i].x>>j[i].y;
	for(int i=1;i<=k;i++) cin>>s[i].x>>s[i].y>>rt[i];
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			d[j]=(mp[i][j]=judge(i,j))?1:d[j];
	for(int i=1;i<=m;i++)
		if(!d[i]){puts("-1");return 0;}
	while(l<=r){
		mid=l+r>>1;
		if(check(mid)) r=mid-1,ans=mid;
		else l=mid+1;
	}cout<<ans;return 0;
}
```

---

## 作者：shiroi (赞：0)

观察题目发现可以进行网络流构图，巫妖连源点，小精灵连汇点，可以杀的就连一条容量为1的边。  

之后我们只需要二分需要的时间，然后跑最大流为算出的攻击次数即可。

判断能不能杀的时候，本质就是判断线段与圆是否有交点。我们可以利用计算几何求线段到圆心的距离，如果这个距离小于半径那么线段和圆就有交点了。  

需要注意的细节比较多，具体实现可以看代码。

```cpp
#include <bits/stdc++.h>
using namespace std;

inline int read()
{
	int x=0; int f=1; char ch=getchar();
	while(!isdigit(ch)) {if(ch=='-')f=-1; ch=getchar();}
	while(isdigit(ch)) {x=x*10+ch-'0'; ch=getchar();}
	return x*f;
}


const int MAXN = 5005;
const int INF = 0x3f3f3f3f;
struct Point {int x,y;};
struct Line {Point a,b;};
struct Edge {int to,cap,rev;};
std::vector <Edge> G[MAXN*10];
int d[MAXN],r[MAXN],tim[MAXN],iter[MAXN];
int tr[MAXN],dep[MAXN],h[MAXN],q[MAXN];
int mp[MAXN][MAXN],cur[MAXN],gap[MAXN];
Point w[MAXN],t[MAXN],s[MAXN];
int ans,n,m,k,cnt,ed;

inline void addedge(int u,int v,int w)
{
	G[u].push_back(Edge{v,w,G[v].size()});
	G[v].push_back(Edge{u,0,G[u].size()-1});
}


inline Point operator - (Point a,Point b)
{Point t; t.x=a.x-b.x; t.y=a.y-b.y; return t;}

inline double operator * (Point a,Point b)
{return a.x*b.y-a.y*b.x;}

inline double dot(Point a,Point b)
{return a.x*b.x+a.y*b.y;}

inline double dis(Point a,Point b)
{return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}

inline double dis(Line l,Point p)
{
	if(dot(l.a-p,l.b-p)>0)
		return min(dis(l.a,p),dis(l.b,p));
	return abs((p-l.a)*(l.b-l.a)/dis(l.a,l.b));
}

inline bool jud(int x,int y)
{
	if(dis(w[x],s[y])>r[x]) return 0;
	for(int i=1; i<=k; i++)
		if(dis((Line) {w[x],s[y]},t[i])<tr[i]) return 0;
	return 1;
}

inline void build(int x)
{
	cnt=1; ed=n+m+1;
	for(int i=0; i<MAXN; i++)
		G[i].clear();
	for(int i=1; i<=n; i++)
		addedge(0,i,x/tim[i]+1);
	for(int i=1; i<=m; i++)
		addedge(i+n,ed,1);
	for(int i=1; i<=n; i++)
		for(int j=1; j<=m; j++)
			if(mp[i][j]) addedge(i,j+n,1);
}

inline void bfs(int s)
{
	memset(dep,-1,sizeof(dep));
	queue<int> q; dep[s]=0; q.push(s);
	while(!q.empty())
	{
		int x=q.front(); q.pop();
		for (int i=0; i<G[x].size(); i++)
		{
			Edge &e=G[x][i];
			if(e.cap>0 && dep[e.to]<0)
			{
				dep[e.to]=dep[x]+1;
				q.push(e.to);
			}
		}
	}
}

int dfs(int x,int t,int f)
{
	if(x==t) return f;
	for (int &i=iter[x]; i<G[x].size(); i++)
	{
		Edge &e=G[x][i];
		if(e.cap>0 && dep[e.to]>dep[x])
		{
			int d=dfs(e.to,t,min(f,e.cap));
			if(d>0)
			{
				e.cap-=d; G[e.to][e.rev].cap+=d;
				return d;
			}
		}
	}
	return 0;
}

inline int dinic(int s,int t)
{
	int res,flow=0;
	while(true)
	{
		bfs(s);
		if(dep[t]<0) return flow;
		memset(iter,0,sizeof(iter));
		while((res=dfs(s,t,INF))>0) flow+=res;
	}
}

int main(int argc, char const *argv[])
{
	int mx=0; n=read(); m=read(); k=read();
	for(int i=1; i<=n; i++)
	{
		w[i].x=read(),w[i].y=read(),r[i]=read();
		tim[i]=read(),mx=max(mx,tim[i]);
	}
	for(int i=1; i<=m; i++)
		s[i].x=read(),s[i].y=read();
	for(int i=1; i<=k; i++)
		t[i].x=read(),t[i].y=read(),tr[i]=read();
	for(int i=1; i<=n; i++)
		for(int j=1; j<=m; j++)
		{
			mp[i][j]=jud(i,j);
			if(mp[i][j]) d[j]=1;
		}
	for(int i=1; i<=m; i++)
		if(!d[i]) {puts("-1"); return 0;}
	int l=0,r=m*mx,mid;
	while(l<=r)
	{
		mid=(l+r)>>1; build(mid);
		if(dinic(0,ed)==m) r=mid-1;
		else l=mid+1;
	}
	printf("%d\n",l);
	return 0;
}
```

---


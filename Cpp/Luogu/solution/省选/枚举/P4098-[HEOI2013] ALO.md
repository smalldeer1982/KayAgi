# [HEOI2013] ALO

## 题目描述

Welcome to ALO (Arithmetic and Logistic Online）。这是一个 VR MMORPG，如名字所见，到处充满了数学的谜题。

现在你拥有 $n$ 颗宝石，第 $i$ 颗宝石有一个能量密度，记为 $a_i$，这些宝石的能量密度**两两不同**。现在你可以选取**连续**的一些宝石（必须多于一个）进行融合，设他们的能量密度为 $a_i,a_{i+1},\cdots,a_j$，则融合而成的宝石的能量密度为这些宝石中能量密度的次大值与其他任意一颗宝石的能量密度按位异或的值的最大值。即，假设该段宝石能量密度次大值为 $k$，则生成的宝石的能量密度为 $\max\{k\oplus a_p\mid a_p\ne k, i\le p\le j\}$。

现在你需要知道你怎么选取需要融合的宝石，才能使生成的宝石能量密度最大。

## 说明/提示

### 样例解释

选择区间 $[1,5]$，最大值为 $7\oplus 9 = 14$。

### 数据规模与约定

- 对于 $20\%$ 的数据有 $n\le 100$；
- 对于 $50\%$ 的数据有 $n\le 2000$；
- 对于 $100\%$ 的数据有 $1\le n\le 50000$，$0\le a_i\le 10^9$。

2023.4.28：添加两组 hack 数据，不计分。

## 样例 #1

### 输入

```
5 
9 2 1 4 7```

### 输出

```
14```

# 题解

## 作者：Youngsc (赞：24)

[Youngsc](https://youngscc.github.io/)

** %% 楼下大佬暴力水过 **  
** 身为蒟蒻的我暴力写挂了，就码了一发可持久化权值字典树 **  
** 可持久化权值字典树和可持久化的权值线段树非常类似，会写主席树就能码出来可持久化trie **  
** 我们枚举每一个值作为次大值的情况 **  
** 不妨设当前数字左边第一个比它大的下标为$l_1$,第二个比它大的记作$l_2$ **  
** 同理设当前数字右边第一个比它大的下标为$r_1$,第二个比它大的记作$r_2$ **  
** 那么对于一个数字来说，它能作为次大值的区间有很多，但我们只取两个区间 **
** 分别是$[l_1+1,R_2-1]$和$[l_2+1,R_1-1]$，其他的区间都是这两个区间的子集**  
** 要处理这个的话我们可以借助链表，将元素按照从小到大的顺序依次删除 **  
** 每次删除之前当前位置左右一共四个元素就是上述的四个元素 **  
** 当然，如果一个元素左边没有比他大的或者右边没有比他 大的就需要特判 **  
** 然后就在区间内的trie上贪心的从高位到低位取反 **  

```cpp
# include <bits/stdc++.h>
# define R register
# define N 50010
# define inf 2000101900

using namespace std;

int n,a[N],t[N*35],ch[N*35][2],ans,pre[N],nxt[N],rt[N],cnt;

pair <int,int> b[N];

template <typename T> inline void in(R T &a){
    R char c = getchar();R T x=0,f=1;
    while(!isdigit(c)) {if(c == '-') f=-1; c=getchar();}
    while(isdigit(c)) x=(x<<1)+(x<<3)+c-'0',c = getchar();
    a=x*f;
}

template <typename T> inline void maxx(R T& a,const T b){a<b ? a=b:0;}
template <typename T> inline void minn(R T& a,const T b){a>b ? a=b:0;}

inline void insert(R int x,R int pos){
    R int now = rt[pos] = ++cnt,las = rt[pos-1];
    t[now] = t[las]+1;
    for (R int i=30; i>=0; --i)
    {
        R int tag = x>>i&1;
        ch[now][tag^1] = ch[las][tag^1];
        ch[now][tag] = ++cnt;
        now = ch[now][tag];
        las = ch[las][tag];
        t[now] = t[las]+1;
    }
}

inline int qury(R int sum,R int l,R int r){
	l--;
    R int now = rt[l],las = rt[r],ret=0;
    for (R int i=30; i>=0; --i)
    {
        R int tag = sum>>i&1;
        if (t[ch[las][tag^1]]-t[ch[now][tag^1]])
        {
            ret ^= (1<<i);
            now = ch[now][tag^1];
            las = ch[las][tag^1];
        }
        else
        {
            now = ch[now][tag];
            las = ch[las][tag];
        }
    }
    return ret;
}

int main(){
    in(n);
    R int fir=0,las=n+1;
    pre[las] = n,nxt[fir] = 1;
    a[fir] = a[las] = inf;
    for (R int i=1; i<=n; ++i) pre[i] = i-1,nxt[i] = i+1,in(a[i]),b[i] = make_pair(a[i],i),insert(a[i],i);
    sort(b+1,b+n+1);\\按从小到大排序
    for (R int i=1; i<=n; ++i)
    {
        R int x = b[i].second;
        R int l = pre[x],r = nxt[x];\\取当前位置的左右两个值
        nxt[l] = r,pre[r] = l;\\删除
        if (l != fir) maxx(ans,qury(a[x],pre[l]+1,r-1)); \\如果左边有更大的
        if (r != las) maxx(ans,qury(a[x],l+1,nxt[r]-1)); \\如果右边有更小的
    }
    printf("%d",ans);
}

```


---

## 作者：Irisss_ (赞：11)

蒟蒻来发一个很简单，很好理解的做法。

$\mathtt{Algorithm}$：

- ST 表 + 二分 + 可持久化 Trie。

$\mathtt{Solution}$：

- 首先，思考 $a_i$ 会在哪些区间作为次大值。设 $l_1$ 表示 $i$ 左边第一个比 $a_i$ 大的数的下标（没有就是 $0$），设 $l_2$ 表示 $i$ 左边第二个比 $a_i$ 大的数的下标（没有就是 $0$）。$r_1$（没有就是 $n+1$）表示 $i$ 右边第一个比 $a_i$ 大的数的小标，$r_2$（没有就是 $n+1$）同理。

- 显然，$a_i$ 就只有在 $[l_1+1,r_2-1]$ 或 $[l_2+1,r_1-1]$ 时是次大值。这时，我们就可以在 Trie 上贪心地求出最大值。

- 而对于 $l_1$ 和 $l_2$ 的求法，我们可以二分。更具体地，首先我们二分出 $l_1$ 的位置，再在此基础上二分出 $l_2$ 的位置，$r_1$ 和 $r_2$ 同理。

$\mathtt{Code}$：

- 代码看着有点冗杂，但其实那四个二分是一个意思。

----------

```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxN = 1e5 + 5;
const int maxM = 31 * maxN;

int n, a[maxN], f[maxN][24], Log[maxN];

namespace trie {
    int ch[maxM][2], tot, mask[maxM], rt[maxN];

    void insert(int idx, int old, int k) {
        mask[k] = idx;
        for (int i = 30; i > -1; --i) {
            int x = a[idx] >> i & 1;
            if (old) ch[k][x ^ 1] = ch[old][x ^ 1];
            ch[k][x] = ++tot;
            mask[tot] = idx;
            k = ch[k][x], old = ch[old][x];
        }
    }

    int query(int l, int r, int val) {
        int res = 0, u = rt[r];
        for (int i = 30; i > -1; --i) {
            int x = val >> i & 1;
            res <<= 1;
            if (mask[ch[u][x ^ 1]] >= l) res |= x ^ 1, u = ch[u][x ^ 1];
            else res |= x, u = ch[u][x];
        }
        return val ^ res;
    }
}
using namespace trie;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n;
    rt[0] = ++tot;
    mask[0] = -1;
    insert(0, 0, rt[0]);
    int overallMax = 0;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        overallMax = max(overallMax, a[i]);
        f[i][0] = a[i];
        rt[i] = ++tot;
        insert(i, rt[i - 1], rt[i]);
    }
    for (int i = 2; i <= n; ++i) Log[i] = Log[i >> 1] + 1;
    for (int j = 1; j <= Log[n]; ++j)
        for (int i = 1; i + (1 << j) - 1 <= n; ++i)
            f[i][j] = max(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);
    auto get = [&](int l, int r) {
        int len = Log[r - l + 1];
        return max(f[l][len], f[r - (1 << len) + 1][len]);
    };
    int ans = 0;
    for (int i = 1; i <= n; ++i) {
        if (a[i] == overallMax) continue;
        int l, r;
        int l1 = 0, l2 = 0, r1 = n + 1, r2 = n + 1;
        // find the first in left
        l = 1, r = i - 1;
        while (l <= r) {
            int mid = (l + r) >> 1;
            if (get(mid, i - 1) > a[i]) l1 = mid, l = mid + 1;
            else r = mid - 1;
        }
        l = 1, r = l1 - 1;
        while (l <= r) {
            int mid = (l + r) >> 1;
            if (get(mid, l1 - 1) > a[i]) l2 = mid, l = mid + 1;
            else r = mid - 1;
        }
        l = i + 1, r = n;
        while (l <= r) {
            int mid = (l + r) >> 1;
            if (get(i + 1, mid) > a[i]) r1 = mid, r = mid - 1;
            else l = mid + 1;
        }
        l = r1 + 1, r = n;
        while (l <= r) {
            int mid = (l + r) >> 1;
            if (get(r1 + 1, mid) > a[i]) r2 = mid, r = mid - 1;
            else l = mid + 1;
        }
        /*
         * one : l2 + 1 ~ r1 - 1
         * two : l1 + 1 ~ r2 - 1
         */
        // one :
        l = l2 + 1, r = r1 - 1;
        ans = max(ans, query(l, r, a[i]));
        // two :
        l = l1 + 1, r = r2 - 1;
        ans = max(ans, query(l, r, a[i]));
    }
    cout << ans;

    return 0;
}
```

---

## 作者：lhm_ (赞：8)

考虑原序列中的每一个值作为构成最终答案的那个次大值，那么其所在的合法区间最大时，其对答案的贡献最大。

一个值作为最大值时有两个合法的最大区间，一个是左边第二个比其大的位置和右边第一个比其大的位置构成的区间，另一个是左边第一个比其大的位置和右边第二个比其大的位置构成的区间，这两个区间都是开区间。确定区间可以从小到大排序，用双向链表一个一个删除即可。

然后就将问题简化了，现在要解决给定一个值，求给定区间与其的异或最大值，可以对原序列建可持久化$Trie$，查询时直接在$Trie$上贪心就行。

实现细节看代码吧。

$code:$

```cpp
#include<bits/stdc++.h>
#define maxn 3000010
using namespace std;
template<typename T> inline void read(T &x)
{
    x=0;char c=getchar();bool flag=false;
    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    if(flag)x=-x;
}
int n,tot,ans;
int a[maxn],p[maxn],pre[maxn],nxt[maxn];
int rt[maxn],t[maxn][2],cnt[maxn];
bool cmp(const int &x,const int &y)
{
    return a[x]<a[y];
}
void insert(int x,int k,int &p)
{
    cnt[++tot]=cnt[p],t[tot][0]=t[p][0],t[tot][1]=t[p][1];
    p=tot,cnt[p]++;
    if(k==-1) return;
    insert(x,k-1,t[p][(x>>k)&1]);
}
int query(int ql,int qr,int k,int x)
{
    if(k==-1) return 0;
    int ch=((x>>k)&1)^1;
    if(cnt[t[qr][ch]]-cnt[t[ql][ch]])
        return query(t[ql][ch],t[qr][ch],k-1,x)|(1<<k);
    else return query(t[ql][ch^1],t[qr][ch^1],k-1,x);
}
int main()
{
    read(n);
    for(int i=1;i<=n;++i) pre[i]=i-1,nxt[i]=i+1,p[i]=i;
    for(int i=1;i<=n;++i)
        read(a[i]),rt[i]=rt[i-1],insert(a[i],30,rt[i]);
    sort(p+1,p+n+1,cmp);
    for(int i=1;i<=n;++i)
    {
        int l=pre[p[i]],r=nxt[p[i]];
        nxt[l]=r,pre[r]=l;
        if(l) ans=max(ans,query(rt[pre[l]],rt[r-1],30,a[p[i]]));
        if(r!=n+1) ans=max(ans,query(rt[l],rt[nxt[r]-1],30,a[p[i]]));
    }
    printf("%d\n",ans);
    return 0;
}
```


---

## 作者：Alex_Wei (赞：7)

#### [P4098 [HEOI2013] ALO](https://www.luogu.com.cn/problem/P4098)

对于每个 **非最大值** 元素 $a_i$，考虑求出其两侧第二个大于 $a_i$ 的位置 $l_i, r_i$，则 $[l_i + 1, r_i - 1]$ 和 $a_i$ 均产生贡献：$[l_i + 1, i]$ 和 $[i, r_i - 1]$ 的次大值均为 $a_i$。特别地，若 $l_i$ 不存在则为 $0$，因为 $a_i$ 不是最大值，所以总存在 $[1, x]$ 使得 $a_i$ 为次大值。同理，若 $r_i$ 不存在则为 $n + 1$。求 $a_i$ 和一段区间内所有数异或值最大值用可持久化 01 Trie 即可。

$l_i$ 和 $r_i$ 的求法：排序后用双向链表维护当前剩余的位置，或者用单调栈：不妨设要求 $l_i$，先求大于当前元素的前驱位置，然后将所有位置按照前驱位置为第一关键字，元素值为第二关键字排序，扫描过程中将前一个位置的前驱到当前位置的前驱的前一个元素加入单调栈，然后用当前位置的值更新单调栈（即弹出小于当前元素的栈顶，但不加入当前元素），则栈顶位置即 $l_i$。读者可自行思考其正确性（证明思路：前驱元素大于当前元素）。

时间复杂度 $\mathcal{O}(n\log V)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using ull = unsigned long long;

bool Mbe;
constexpr int N = 5e4 + 5;
constexpr int K = N << 5;
int n, mx, ans, a[N], id[N], p[N];
int node, R[N], son[K][2], val[K];
void modify(int pre, int &x, int v, int dep) {
  val[x = ++node] = val[pre] + 1;
  son[x][0] = son[pre][0], son[x][1] = son[pre][1];
  if(!dep) return;
  int bit = v >> --dep & 1;
  modify(son[pre][bit], son[x][bit], v, dep);
}
int query(int v, int x, int y, int dep) {
  if(!dep) return 0;
  int bit = v >> --dep & 1;
  if(val[son[y][bit ^ 1]] - val[son[x][bit ^ 1]])
    return (1 << dep) + query(v, son[x][bit ^ 1], son[y][bit ^ 1], dep);
  return query(v, son[x][bit], son[y][bit], dep);
}
void solve() {
  memset(son, 0, node + 2 << 3);
  memset(val, 0, node + 2 << 2);
  node = 0;
  for(int i = 1; i <= n; i++) modify(R[i - 1], R[i], a[i], 30);
  static int stc[N], top; top = 0;
  for(int i = 1; i <= n; i++) {
    while(top && a[stc[top]] < a[i]) top--;
    id[i] = stc[top], stc[++top] = p[i] = i;
  }
  sort(p + 1, p + n + 1, [&](int x, int y) {
    return id[x] != id[y] ? id[x] < id[y] : a[x] < a[y];
  });
  top = 0;
  for(int i = 1; i <= n; i++) {
    for(int j = max(1, id[p[i - 1]]); j < id[p[i]]; j++) {
      while(top && a[stc[top]] < a[j]) top--;
      stc[++top] = j;
    }
    while(top && a[stc[top]] < a[p[i]]) top--;
    if(a[p[i]] != mx) ans = max(ans, query(a[p[i]], R[stc[top]], R[p[i]], 30));
  }
}

bool Med;
int main() {
  fprintf(stderr, "%.3lf MB\n", (&Mbe - &Med) / 1048576.0);
  #ifdef ALEX_WEI
    FILE* IN = freopen("1.in", "r", stdin); 
    FILE* OUT = freopen("1.out", "w", stdout);
  #endif
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  cin >> n;
  for(int i = 1; i <= n; i++) cin >> a[i], mx = max(mx, a[i]);
  solve(), reverse(a + 1, a + n + 1), solve();
  cout << ans << "\n";
  cerr << 1e3 * clock() / CLOCKS_PER_SEC << " ms\n";
  return 0;
}
/*
g++ a.cpp -o a -std=c++14 -O2 -DALEX_WEI
*/
```

---

## 作者：Pine (赞：5)

# 可持久化trie树
求区间异或最大值用trie树 ~~（显然）~~

将a建立可持久化trie树

枚举次大值$a_i$，次大值为$a_i$的区间为[$a_i$的前驱的前驱+1,$a_i$的后继的后继-1]。

查询前驱后继用set维护即可

# 代码
```
#include <bits/stdc++.h>
#define eps 1e-12
#define R register
#define INF (1<<30)
#define LINF (1ll<<60)
#define MM(x, y) memset(x, y, sizeof x)
#define Fo(i, x, y) for(R int i=x; i<=y; ++i)
#define Ro(i, x, y) for(R int i=x; i>=y; --i)
using namespace std;
template<typename T> inline T Max(R T x, R T y) {return x > y ? x : y;}
template<typename T> inline T Min(R T x, R T y) {return x < y ? x : y;}
template<typename T> inline void in(R T &x)
{
	static int ch; static bool flag;
	for(flag=false, ch=getchar(); ch<'0'||ch>'9'; ch=getchar()) flag |= ch=='-';
	for(x=0; ch>='0'&&ch<='9'; ch=getchar()) x = (x<<1) + (x<<3) + ch - '0';
	x = flag ? -x : x;
}
/*********************************Samle***********************************/
set<int> s;
int n, a[50005], b[50005], ans;
struct node{
	node *c[2];
	int size;
	node(node *C = 0) {size=0; c[0]=c[1]=C;}
}*root[50005], *Null;
inline bool cmp(R int x, R int y) {return a[x] > a[y];}

inline node *insert(R node *x, R int val, R int d)
{
	node *y = new node(Null);
	*y = *x; y->size++;
	if(d < 0) return y;
	R int p = (val>>d)&1;
	y->c[p] = insert(x->c[p], val, d-1);
	return y;
}
inline int query(R node *A, R node *B, R int val, R int d)
{
	if(d < 0) return 0;
	R int v = (val >> d) & 1;
	if(A->c[!v]->size > B->c[!v]->size) return query(A->c[!v], B->c[!v], val, d-1) + (1<<d);
	else return query(A->c[v], B->c[v], val, d-1);
}
int main()
{
	Null = new node(); Null->c[0] = Null->c[1] = Null;
	root[0] = Null;
	in(n); 
	Fo(i, 1, n)
	{
		in(a[i]); b[i] = i;
		root[i] = insert(root[i-1], a[i], 30);
	} sort(b+1, b+n+1, cmp);
	s.insert(-1); s.insert(-2); s.insert(b[1]); s.insert(n+1); s.insert(n+2);
	Fo(i, 2, n)
	{
		R int l = Max(1, *--(--s.lower_bound(b[i]))+1);
		R int r = Min(n, *++(s.upper_bound(b[i]))-1);
		if(l > r) continue; s.insert(b[i]);
		ans = Max(ans, query(root[r], root[l-1], a[b[i]], 30));
	}
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：lingfunny (赞：3)

1. 一方面，次大值很棘手，最先考虑。
2. 另一方面，对于一段区间内的 $a_p(p\in[l,r])$，如果要找它们和 $k$ 异或起来的最大值是好找的。从最高位到最低位建 Trie，在树上贪心即可。因为是一段区间，需要可持久化 Trie。

不难想到枚举次大值，然后在 $a_k$ 可作为次大值的区间内在可持久化 Trie 上找。

关于枚举次大值，可以见我的[这篇题解](https://280800.blog.luogu.org/solution-cf1691d)。

> 记 $\mathrm{minL}$ 和 $\mathrm{maxR}$ 为 $a_k$ 向左向右第一个比它大的 $a_p$ 的 $p$。

> 可以考虑把这 $n$ 个数用链表将相邻的两个数连在一起，然后从小到大枚举最大值，每次枚举完一个值，就把这个值删去，更新链表。

> 这样每个数在链表上的左右的数就是第一个大于它的值了，因为比它小都删掉了，换句话说它们直接确定了 $\mathrm{minL}-1$ 和 $\mathrm{maxR}+1$。


```cpp
// Problem: P4098 [HEOI2013]ALO
// From: Luogu
// URL: https://www.luogu.com.cn/problem/P4098
// Time: 2022-06-30 17:01
// Author: lingfunny

#include <bits/stdc++.h>
#define LL long long
using namespace std;
const int mxn = 5.5e4+10, mxd = 30;

int n, a[mxn], rt[mxn], sz[mxn*mxd], ch[2][mxn*mxd], tot, b[mxn], L[mxn], R[mxn], ans;

void ins(int o, int &u, const int& w, int d = mxd - 1) {
	if(!u) u = ++tot;
	if(d < 0) return ++sz[u], void();
	const int f = (w >> d) & 1;
	ins(ch[f][o], ch[f][u], w, d - 1);
	ch[f^1][u] = ch[f^1][o];
	sz[u] = sz[ch[0][u]] + sz[ch[1][u]];
}

int ask(int l, int r, const int& w, int d = mxd - 1) {
	if(d < 0) return 0;
	const int f = ((w >> d) & 1) ^ 1;
	return sz[ch[f][r]] > sz[ch[f][l]] ? ask(ch[f][l], ch[f][r], w, d - 1) | (1 << d) : ask(ch[f^1][l], ch[f^1][r], w, d - 1);
}

signed main() {
	scanf("%d", &n);
	for(int i = 1; i <= n; ++i) scanf("%d", a+i), ins(rt[i-1], rt[i], a[i]),
	b[i] = i, L[i] = i - 1, R[i] = i + 1; R[n+1] = n + 1;
	sort(b+1, b+n+1, [&](int x, int y) { return a[x] < a[y]; });
	for(int i = 1; i < n; ++i) {
		int l = L[b[i]], r = R[b[i]];
		R[l] = r, L[r] = l;
		ans = max(ans, ask(rt[L[l]], rt[r-1], a[b[i]]));
		ans = max(ans, ask(rt[l], rt[R[r]-1], a[b[i]]));
	}
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：caidzh (赞：2)

蒟蒻第一次自己想出可持久化数据结构的题，写篇题解。

其实不是什么难题辣！

### $Sol.1$ 暴力枚举

复杂度爆炸，算了不讲了

### $Sol.2$ 考虑枚举$k$

一个数想要成为答案中的$k$，它必须满足是这个区间的次大值

如果搞出了这个区间，只要用可持久化$trie$就可以完成任务了

现在考虑怎么搞出这个次大值为$k$的区间：

可以这样想：这个区间到底怎样才最优呢？

当然是越长越优啊！越长就有更多的选择，且这个区间一定包含了含最优值的小的区间

现在考虑从$k$这个点向外扩展，扩展的越远越好。

设$L_1$与$L_2$是离这个点第一近与第二近的比它大的点，$R$类似

根据这个想到了什么，链表维护啊！

求出了$L$与$R$后，考虑怎么用这些变量凑出这个最优的区间：经过一通乱搞与论证后，我们得到这两个区间：$(L_2[i],R[i])$与$(L[i],R_2[i])$（两端取不到）

实际上我们是把四个区间化为这两个区间的，因为区间之间有包含关系，可以自己推一下

于是这题就做完了
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
#include<map>
#define INF 2147483647
#define LLINF 9223372036854775807
#define LL long long
#define xyx AKIOI
#define Dilute AKIOI
#define Chtholly_Tree AKIOI
#define time_interspace AKIOI
using namespace std;
int inline read(){
    int num=0,neg=1;char c=getchar();
    while(!isdigit(c)){if(c=='-')neg=-1;c=getchar();}
    while(isdigit(c)){num=(num<<3)+(num<<1)+c-'0';c=getchar();}
    return num*neg;
}
map<int,int>m;
int n,a[50010],b[50010],l[50010],r[50010],ans,flag;
int L[50010],R[50010],L2[50010],R2[50010];
void Pre(){
	for(int i=1;i<=n;i++){
		int id=m[b[i]];if(i==n)flag=id;
		L[id]=l[id];L2[id]=l[l[id]];R[id]=r[id];R2[id]=r[r[id]];
		r[l[id]]=r[id];l[r[id]]=l[id];
	}
}
int rt[50010],ch[50010*32][2],num[50010*32],cnt;
void insert(int now,int pre,int x){
	for(int i=30;i>=0;i--){
		int k=(x>>i)&1;
		ch[now][!k]=ch[pre][!k];ch[now][k]=++cnt;
		num[ch[now][k]]=num[ch[pre][k]]+1;now=ch[now][k];pre=ch[pre][k];
	}
}
int Query(int l,int r,int x){
	int ans=0;
	for(int i=30;i>=0;i--){
		int k=(x>>i)&1;
		if(num[ch[r][!k]]>num[ch[l][!k]])ans+=(1<<i),l=ch[l][!k],r=ch[r][!k];
		else l=ch[l][k],r=ch[r][k];
	}return ans;
}
int main()
{
	n=read();r[n+1]=n+1;
	for(int i=1;i<=n;i++)b[i]=a[i]=read(),m[a[i]]=i,l[i]=i-1,r[i]=i+1;
	sort(b+1,b+n+1);Pre();
	rt[0]=++cnt;insert(rt[0],0,0);
	for(int i=1;i<=n;i++){rt[i]=++cnt;insert(rt[i],rt[i-1],a[i]);}
	for(int i=1;i<=n;i++){
		//求L2[i]+1->R[i]-1与L[i]+1->R2[i]-1的极值 
		if(i==flag)continue;
		int nowl=L2[i]+1,nowr=R[i]-1,x=a[i];
		if(nowl-1<0)nowl=1;
		ans=max(ans,Query(rt[nowl-1],rt[nowr],x));
		nowl=L[i]+1,nowr=R2[i]-1,x=a[i];
		if(nowl-1<0)nowl=1;
		ans=max(ans,Query(rt[nowl-1],rt[nowr],x));
	}cout<<ans;
	return 0;
}
```


---

## 作者：MiRaciss (赞：1)

对于每一个数，我们先考虑它可以和哪些数异或。

令 $L_i$ 为第 $i$ 个数左边第一个比它大的数的下标，$R_i$ 为第 $i$ 个数右边第一个比它大的数的下标。

设当前这个数为 $i$，那么以它为次大值的区间有 $\left[ L_{L_i}+1,R_i -1 \right]$ 和 $\left[ L_i+1,R_{R_i} -1\right]$。


那么如何找出来我们要的 $L$ 和 $R$ 呢？ 考虑用链表连接整个区间，从小到大的查找每一个数的 $L$ 和 $R$，也就是 前驱 和 后驱，并在结束时将当前的点丢出链表。因为排序，所以这样处理的复杂度是 $O(n\log n)$ 的。

对于每一个区间，我们可以把所有的 $a$ 放进一颗字典树上，然后在字典树上查找所有的 $a$ 与 $a_i$ 异或的最大值。

因为区间始终是在 $\left[ 1,n \right]$ 里面的，所以可以考虑可持久化，于是每次查询的复杂度就降成了 $O(\log n)$。

### 代码

```cpp

#include<bits/stdc++.h>
using namespace std;

int n,m,ans=0;;
int a[6000005],tot=0;
int root[20000005];

struct Trie{
	int t[80000005][2],cnt=0;
	int sum[80000005];
	void Change_Tree(int l,int &r,int val){
		r=++cnt,sum[r]=sum[l]+1;
		int x=l,y=r;
		for(int i=30;i>=0;i--){
			int op=((val>>i)&1);
			t[y][!op]=t[x][!op];
			t[y][op]=++cnt,sum[t[y][op]]=sum[t[x][op]]+1;
			x=t[x][op],y=t[y][op];
		}
	}
	int Find_Tree(int x,int y,int val){
//		printf("Fuck:%d %d %d\n",x,y,val);
		if(x>y) return 0;
		int ans=0;
		for(int i=30;i>=0;i--){
			int op=((val>>i)&1);
			if(sum[t[y][!op]]-sum[t[x][!op]]>0) ans+=(1<<i),op=(!op);
			x=t[x][op],y=t[y][op];
		}
		return ans;
	}
}T;

int lsh[500005];
int val[500005];
int pre[500005],nxt[500005];
int ll[500005],rr[500005];

struct qwq{
	int val,id;
}t[500005];
bool cmp(qwq x,qwq y){
	return x.val<y.val;
}
int L[500005],R[500005];

void Print(){
	printf("-----------------------------\n");
	for(int i=1;i<=n;i++) printf("%d:%d %d\n",i,pre[i],nxt[i]);
	printf("-----------------------------\n");
}

int main(){
	cin>>n;for(int i=1;i<=n;i++) scanf("%d",&a[i]),t[i].val=a[i],t[i].id=i,pre[i]=i-1,nxt[i]=i+1,T.Change_Tree(root[i-1],root[i],a[i]);
	pre[n+1]=n,nxt[0]=1;
	sort(t+1,t+n+1,cmp);
	for(int i=1;i<=n;i++){
		int id=t[i].id;
		L[id]=pre[id],R[id]=nxt[id];
		pre[R[id]]=L[id],nxt[L[id]]=R[id];
		ll[id]=pre[L[id]],rr[id]=nxt[R[id]];
//		printf("%d:%d %d %d %d\n",id,L[id],R[id],ll[id],rr[id]); 
//		Print();
	}
	for(int i=1;i<=n;i++){
		int l=L[i],r=R[i];
		int pr=ll[i],nx=rr[i];
//		printf("%d:%d %d %d %d %d\n",i,l,r,pr,nx,a[i]);
		if(l) ans=max(ans,T.Find_Tree(root[pr],root[r-1],a[i]));//,printf("qwq!\n");
		if(r!=n+1) ans=max(ans,T.Find_Tree(root[l],root[nx-1],a[i]));//,printf("QWQ!\n");
	}
	printf("%d\n",ans);
	return 0;
}
```



---

## 作者：creation_hy (赞：1)

## 题意

给定一个序列，求一个最优区间，设 $mex$ 为区间次大值，使 $\max_{i=l}^r\{mex\oplus a_i\}$ 最大。

## 思路

前置知识：可持久化 Trie。如果不会可以先做一下 [模版](https://www.luogu.com.cn/problem/P4735)。

首先考虑，对于一个 $a_i$ 来说，什么情况下 $a_i$ 能成为区间次大值。

很显然这个区间只包含一个比它大的数 ~~（这不是废话吗）~~。

即，如果 $lr$ 表示 $[1,i-1]$ 中最后一个比它大的数的编号，$ll$ 表示 $[1,lr-1]$ 中最后一个比它大的数，$rl$ 表示 $[i+1,n]$ 中第一个比它大的数，$rr$ 表示 $[rl+1,n]$ 中第一个比它大的数，那么满足 $a_i$ 为次大值的最大的两个区间分别是：

$[ll+1,rl-1]$（最大值 $lr$）

$[lr+1,rr-1]$（最大值 $rl$）

这个东西很好维护，拿一个链表就行。~~当然你要拿线段树我也不拦你~~

具体实现：

初始化链表：$pre[i]=i-1,next[i]=i+1$。

然后把 $a[]$ 从小到大排序，设 $id$ 为它原来的位置，此时 $pre[id]$ 即为 $lr$，$next[id]$ 即为 $rl$。$ll$ 怎么算？直接 $pre[pre[id]]$ 就行啦（

当然算完之后要把这个数在链表上删掉。

接下来，恭喜你已经找出了区间边界和次大值，下一步是求解答案。

观察这个式子：

$\max_{i=l}^r\{mex\oplus a_i\}$

是不是很熟悉……

一眼可持久化 Trie。

~~如果你不熟悉的话说明你还没做模版。~~

然后拿可持久化 Trie 板子跑一边就行了。

提一个细节（坑了我好久）：可持久化 Trie 查询是从 $l-1$ 到 $r$ 的。。。所以 `query()` 应该是 $[ll,rl-1]$。。。

不然你的样例会输出 $6$。

可能是因为我太菜了还不熟悉可持久化 Trie 吧 /kk

## 代码

内含注释。

~~已删去文明部分~~

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5e4 + 5;
int n, pre[N], nxt[N], a[N], id[N];
int t[N * 35][2], val[N * 35], root[N], tot;
inline void insert(int x, int last, int k)
{
    for (int i = 30; i >= 0; i--)
    {
        val[x] = val[last] + 1;
        bool p = k >> i & 1;
        if (!t[x][p])
            t[x][p] = ++tot;
        t[x][p ^ 1] = t[last][p ^ 1];
        x = t[x][p], last = t[last][p];
    }
    val[x] = val[last] + 1;
}
inline int query(int x, int y, int k)
{
    int res = 0;
    for (int i = 30; i >= 0; i--)
    {
        bool p = k >> i & 1;
        if (val[t[x][p ^ 1]] != val[t[y][p ^ 1]])
        {
            res += 1 << i;
            x = t[x][p ^ 1], y = t[y][p ^ 1];
        }
        else
            x = t[x][p], y = t[y][p];
    }
    return res;
}
inline bool cmp(int x, int y)
{
    return a[x] < a[y];
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
        root[i] = ++tot;
        insert(root[i], root[i - 1], a[i]);
        pre[i] = i - 1, nxt[i] = i + 1; // init list
        id[i] = i;
    }
    sort(id + 1, id + 1 + n, cmp); // sort by value
    int ans = 0;
    for (int i = 1; i <= n; i++)
    {
        int l = pre[id[i]], r = nxt[id[i]]; // lr, rl
        if (l)
            ans = max(ans, query(root[pre[l]], root[r - 1], a[id[i]]));
        if (r <= n)
            ans = max(ans, query(root[l], root[nxt[r] - 1], a[id[i]]));
        nxt[l] = r, pre[r] = l; // delete
    }
    cout << ans;
    return 0;
}
```

---

## 作者：7KByte (赞：1)

其实是个好题  

首先我们考虑枚举区间，肯定不能直接枚举左右边界，因为那样会严重超时  
我们考虑枚举次小值k的位置，然后借助双向链表求出它可能对应的两个区间，即先按照权值从小到大排序，然后依次在链表中获取它的前驱和后继，即对应的区间，然后将该节点在链表里删除（~~感觉描述不清楚，看楼上~~）  
然后即使求区间最大异或和（很熟悉对不对？），没错，就是这道题[**最大异或和**](https://www.luogu.org/problemnew/show/P4735)，我们借助可持久化trie即可求出最后的答案  


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[50005],prev[50005],next[50005],root[50005],top=0;
int l[200005],r[200005],to[200005],trie[200005*32][2],latest[5000005];
struct sor{
	int data;
	int where;
}s[50005];
bool cmp(sor x,sor y){
	return x.data<y.data;
}
void insert(int val,int i,int now,int com,int F){
	if(F<0){
		latest[now]=i;return;
	}
	int x=val&(1<<(F))?1:0;
	trie[now][x^1]=trie[com][x^1];
	trie[now][x]=++top;
	insert(val,i,trie[now][x],trie[com][x],F-1);
	latest[now]=max(latest[trie[now][0]],latest[trie[now][1]]);
}
int ask(int Min,int now,int val,int F){
	if(F<0)return latest[now];
	int x=val&(1<<(F))?1:0;
	if(latest[trie[now][x^1]]>=Min)return ask(Min,trie[now][x^1],val,F-1);
	else return ask(Min,trie[now][x],val,F-1);
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	    scanf("%d",&a[i]),prev[i]=i-1,next[i]=i+1,
		s[i].data=a[i],s[i].where=i;
	sort(s+1,s+n+1,cmp);int tot=0;
	for(int i=1;i<=n;i++){
		int x=s[i].where;
		if(prev[x]){
			l[++tot]=prev[prev[x]]+1;
			r[tot]=next[x]-1;to[tot]=x;
		}
		if(next[x]<=n){
			l[++tot]=prev[x]+1;
			r[tot]=next[next[x]]-1;to[tot]=x;
		}
		next[prev[x]]=next[x];
		prev[next[x]]=prev[x];
	}
	latest[0]=-1;root[0]=++top;
	insert(0,0,top,0,31);
	for(int i=1;i<=n;i++)
	  root[i]=++top,insert(a[i],i,root[i],root[i-1],31);
	int ans=0;
	for(int i=1;i<=tot;i++){
		//cout<<l[i]<<" "<<r[i]<<" "<<to[i]<<endl;
		ans=max(ans,a[ask(l[i],root[r[i]],a[to[i]],31)]^a[to[i]]);
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：MuYC (赞：0)

#### [HEOI 2013] ALO：

#### 题意:

给定一个长度为 $n$ 的正整数序列 $a$，序列中的数**两两不相同**，定义区间 $[l,r]$ 的价值为：

+ 假设区间 $[l,r]$ 内的第二大的值是 $k$， 那么 $k$ 与区间 $[l,r]$ 中任意一个数异或得到最大值即是区间 $[l,r]$ 的价值。

你现在要找出一个区间 $[l,r](1 \leq l< r \leq n)$ 使得这个区间的价值是所有区间中最大的，输出最大价值。

#### 做法：

前置知识：线段树 + 可持久化 `trie` + 单调栈

Orz 神仙们都会链表，菜鸡只能写线段树维护。

+ 定义 $Lef_i$ 表示 $a_i$ 左边第一个大于 $a_i$ 的数的位置。
+ 定义 $Rig_i$ 表示 $a_i$ 右边第一个大于 $a_i$ 的数的位置。

考虑先找到每个数**可以作为次大值的区间范围**，然后用可持久化 `tire​` 处理就完事了。

那么实际上一个数 $a_i$ 能够作为次大值的范围即 $[L' + 1, R'-1]$ ，其中 $L'$ 表示 $a_i$ 左边**第二个**比 $a_i$ 大的数的位置， $R'$ 表示 $a_i$ 右边**第二个**比 $a_i$ 大的数的位置，读者可以画图，虽然会有两个可行的区间，但是两个区间并起来就是这个区间了。

首先预处理出 $Lef_i$ 和 $Rig_i$，找 $Lef_i$ 以及 $Rig_i$ 的过程是比较套路的单调栈维护，不讲了。

我们先考虑找出 $L'$ ，$R'$ 其实同理，于是在这里只讲求 $L'$ 的做法。随后定义一个 $vector$ 数组 $q$。

接着 `q[lef[i]].push_back(i);` 就先把每个点放在其 $Lef_i$ 上。

接下来我们从左到右（如果是处理 $R'$ 就从右到左）扫整个数组 $a$(离散化后的)，假设当前扫到了 $a_j$ ，那么假设 `q[j].size() != 0` 那么我们就要处理 `q[j]` 中的内容。假设 `q[j][k] = c` ，那么我们查询目前大于 $a[c]$ 的第一个数的位置即是原本在 $a[c]$ 左边第二个比它大的数的位置，线段树维护这个第一个比它大的位置即可(用不了单调栈了，因为你一个点会有多个询问)，这个不难理解。

对于 $R'$ 的处理也是一样的处理。 

接着用套可持久化 `trie` 维护一下即可。如果还不会可持久化 `trie` 可以先去 [OIWIKI](https://oi-wiki.org/ds/persistent-trie/) 上面学习一下。

接着给出几个**注意事项** :

+ 数组空间要开够，不然容易 $Wa$ 成 $50pts$
+ 特判当前元素是不是整个序列的最大值，如果是的话，按照上述方法求出来其可以作为次大值的区间范围是 $[1,n]$ ，但是这显然是不行的，要特判一下。
+ 记得离散化。

#### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define mid ((T[x].l + T[x].r) >> 1)
#define ls (x << 1)
#define rs (x << 1 | 1)
inline int read() {
	int x = 0, flag = 1;
	char ch = getchar();
	for( ; ch > '9' || ch < '0' ; ch = getchar()) if(ch == '-') flag = -1;
	for( ; ch >= '0' && ch <= '9' ; ch = getchar()) x = (x << 3) + (x << 1) + ch - '0';
	return x * flag;
}
const int MAXN = 1e5 + 50;
int n, A[MAXN], Lef[MAXN], Rig[MAXN], Val[MAXN], Mx, Sc;
int tack[MAXN], top = 0, rt[MAXN];
queue <int> q[MAXN];
struct Lis {
	int val, id;
} S[MAXN];
bool cmp(Lis a, Lis b) { return a.val < b.val; }
struct SegmentTree {
	int l, r, S, tag;
} T[MAXN << 2];
namespace trie { // 可持久化 trie
	int Son[MAXN * 31][2], Num[MAXN * 31], cnt = 0;

	int insert(int now, int val) {
		int s = ++ cnt, cur = s;
		for(int i = 30 ; i >= 0 ; i --) {
			int t = ((val >> i) & 1);
			Num[cur] = Num[now] + 1;
			Son[cur][t ^ 1] = Son[now][t ^ 1], Son[cur][t] = ++cnt;
			now = Son[now][t], cur = Son[cur][t];
		} Num[cur] = Num[now] + 1;
		return s;
	}

	int Get(int x, int l, int r) {
		int ans = 0;
		for(int i = 30 ; i >= 0 ; i --) {
			int t = ((x >> i) & 1);
			if(Num[Son[r][t ^ 1]] - Num[Son[l][t ^ 1]]) {
				ans += (1 << i);
				r = Son[r][t ^ 1], l = Son[l][t ^ 1];
			}
			else r = Son[r][t], l = Son[l][t];
		}
		return ans;
	}

} ;
void build(int x, int l, int r) {
	T[x].l = l, T[x].r = r, T[x].S = T[x].tag = 0;
	if(l == r) return ;
	build(ls, l, mid), build(rs, mid + 1, r);
	return ;
}
void ad(int x, int k) { T[x].S = k, T[x].tag = k; return ; }
void pushdown(int x) { if(T[x].tag) ad(ls, T[x].tag), ad(rs, T[x].tag), T[x].tag = 0; return ;}
void change(int x, int l, int r, int k) { // 区间覆盖
	if(l > r) return ;
	if(T[x].l >= l && T[x].r <= r) { ad(x, k); return ;}
	pushdown(x);
	if(l <= mid) change(ls, l, r, k);
	if(r  > mid) change(rs, l, r, k);
	return ;
}
int Get(int x, int pos) { 
	if(T[x].l == pos && T[x].r == pos) return T[x].S;
	pushdown(x);
	return pos <= mid ? Get(ls, pos) : Get(rs, pos);
}

int main() {
	n = read();
	for(int i = 1 ; i <= n ; i ++) Val[i] = read(), Lef[i] = 1, Rig[i] = n;
	for(int i = 1 ; i <= n ; i ++) S[i].val = Val[i], S[i].id = i;
	sort(S + 1, S + 1 + n, cmp);
	for(int i = 1 ; i <= n ; i ++) A[S[i].id] = i;// 离散化
	top = 0, tack[++ top] = 1;
	for(int i = 2 ; i <= n ; i ++) { // 单调栈求 Rig[i]
		while(top >= 1 && A[tack[top]] < A[i]) Rig[tack[top]] = i, top --;
		tack[++ top] = i;
	}
	top = 0, tack[++ top] = n;
	for(int i = n - 1 ; i >= 1 ; i --) { // 单调栈求 Lef[i]
		while(top >= 1 && A[tack[top]] < A[i]) Lef[tack[top]] = i, top --;
		tack[++ top] = i;
	}
	build(1, 1, n);
	for(int i = 1 ; i <= n ; i ++) q[Lef[i]].push(i); //处理左边界
	for(int i = 1 ; i <= n ; i ++) {
		while(!q[i].empty()) Lef[q[i].front()] = Get(1, A[q[i].front()]) + 1, q[i].pop();
		change(1, 1, A[i] - 1, i); // 修改
	}
	build(1, 1, n);
	for(int i = 1 ; i <= n ; i ++) q[Rig[i]].push(i);
	for(int i = n ; i >= 1 ; i --) { 
		while(!q[i].empty()) Rig[q[i].front()] = Get(1, A[q[i].front()]) - 1, q[i].pop();
		change(1, 1, A[i] - 1, i);
	}
	for(int i = 1 ; i <= n ; i ++) if(Rig[i] == -1) Rig[i] = n;
	int Ans = 0;rt[0] = trie::insert(0, 0);
	for(int i = 1 ; i <= n ; i ++) rt[i] = trie::insert(rt[i - 1], Val[i]); 
	for(int i = 1 ; i <= n ; i ++) {
		if(A[i] == n) continue;
		Ans = max(Ans, trie::Get(Val[i], rt[Lef[i] - 1], rt[Rig[i]]));
	} cout << Ans;
	return 0;
}
```



---


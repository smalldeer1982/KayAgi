# [HEOI2015] 公约数数列

## 题目描述

设计一个数据结构. 给定一个正整数数列 $a_0, a_1, \cdots, a_{n - 1}$，你需要支持以下两种操作：


1. $\text{\texttt{MODIFY} \textit{id} \textit{x}}$：将 $a_{id}$ 修改为 $x$；
2. $\text{\texttt{QUERY} \textit{x}}$：求最小的整数 $p \ (0 \le p < n)$，使得 $\gcd(a_0, a_1, \cdots, a_p) \times  \operatorname{xor}(a_0, a_1, \cdots, a_p) = x$。其中 $\operatorname{xor}(a_0, a_1, \cdots, a_p)$ 代表 $a_0, a_1, \cdots, a_p$ 的异或和，$\gcd$ 表示最大公约数。


## 说明/提示

### 数据范围及约定

- 对于 $30\%$ 的数据，$n\le10^4$，$q\le 1000$。
- 对于 $100\%$ 的数据，$n\le10^5$，$q\le 10000$，$1\le a_i\le 10^9$，询问操作中 $x \le 10^{18}$，修改操作中 $0\le id<n$，$1\le x\le 10^9$。

## 样例 #1

### 输入

```
10
1353600 5821200 10752000 1670400 3729600 6844320 12544000 117600 59400 640
10
MODIFY 7 20321280
QUERY 162343680
QUERY 1832232960000
MODIFY 0 92160
QUERY 1234567
QUERY 3989856000
QUERY 833018560
MODIFY 3 8600
MODIFY 5 5306112
QUERY 148900352```

### 输出

```
6
0
no
2
8
8```

# 题解

## 作者：mrsrz (赞：9)

## 解题思路：

分块。

不同的前缀$\gcd$有$O(\log a)$个，每次变化至少缩小到原来的一半。

设块大小为$S$，我们需要维护的信息有：每个块的块内$\gcd$，每个位置作为结尾的前缀异或和。

考虑修改一个数，我们转化为对一个数异或上另一个数$x$，则这个数及其之后的数的前缀异或和都会异或上$x$，块内暴力修改，区间打tag即可。

用set把前缀异或和存起来。单次修改复杂度$O(S\log n+\frac{n}{S})$。

考虑查询，我们从左往右扫描每个块，维护当前前缀$\gcd$。

若和一个新的块$\gcd$后，其值改变，则说明这个块内有前缀$\gcd$不同的位置。直接暴力扫描整块即可。如果没改变，则其前缀$\gcd$都相同，直接在set上二分即可。

由于块内暴力还要求$\gcd$，共有$O(\log a)$个这样的块。单次查询复杂度$O(S\log^2 a+\frac{n\log S}{S})$。

## Code：
```cpp
#include<cstdio>
#include<algorithm>
#include<set>
const int N=100005,siz=318;
#define gcd std::__gcd
#define bel(x)((x-1)/siz+1)
#define mp std::make_pair
typedef long long LL;
int n,m,K,a[N],xp[N];
LL qry;
struct BLOCK{
	int val[320],L,R,len,Gcd,Xor[320],tag;
	std::set<std::pair<int,int>>s;
	void re(){
		Gcd=val[1];
		for(int i=2;i<=len;++i)Gcd=gcd(Gcd,val[i]);
	}
	void build(int l,int r){
		L=l,R=r,len=r-l+1;
		for(int i=l;i<=r;++i)val[i-l+1]=a[i],Xor[i-l+1]=xp[i],s.insert(mp(xp[i],i-l+1));
		re();
	}
	void modify(int pos,int dlt){
		pos=pos-L+1;
		for(int i=pos;i<=len;++i){
			s.erase(mp(Xor[i],i));
			s.insert(mp(Xor[i]^=dlt,i));
		}
		val[pos]^=dlt;
		re();
	}
	void get(int gg,int&ans){
		for(int i=1;i<=len;++i){
			gg=gcd(gg,val[i]);
			if((LL)gg*(Xor[i]^tag)==qry){
				ans=L+i-1;
				return;
			}
		}
	}
	void find(int gg,int&ans){
		if(qry%gg!=0)return;
		auto it=s.lower_bound(mp((qry/gg)^tag,0));
		if(it==s.end()||(it->first^tag)!=(qry/gg))return;
		ans=it->second+L-1;
	}
}b[320];
int main(){
	scanf("%d",&n);
	K=bel(n);
	for(int i=0;i<n;++i)scanf("%d",a+i),xp[i]=xp[i-1]^a[i];
	for(int i=1;i<K;++i)b[i].build((i-1)*siz,i*siz-1);
	b[K].build((K-1)*siz,n-1);
	for(scanf("%d",&m);m--;){
		char opt[12];
		scanf("%s",opt);
		if(*opt=='M'){
			int pos,x;
			scanf("%d%d",&pos,&x);
			const int dlt=a[pos]^x;a[pos]=x;
			for(int i=bel(pos)+1;i<=K;++i)b[i].tag^=dlt;
			b[bel(pos)].modify(pos,dlt);
		}else{
			scanf("%lld",&qry);
			int Gcd=0,ans=666666;
			for(int i=1;i<=K&&ans==666666;++i){
				int lst=Gcd;
				Gcd=gcd(Gcd,b[i].Gcd);
				if(Gcd!=lst)b[i].get(lst,ans);else
				b[i].find(Gcd,ans);
			}
			if(ans==666666)puts("no");else
			printf("%d\n",ans);
		}
	}
	return 0;
}
```

---

## 作者：斯德哥尔摩 (赞：5)

[P4108 [HEOI2015]公约数数列](https://www.luogu.org/problemnew/show/P4108)

趁没有题解赶紧抢一发一血。。。

本来想用线段树维护一下，然后发现我好像需要$3$个$\log_2n$，这是要爆炸的节奏啊。。。

所以我们拿出了分块。

一开始我还在想，$GCD$和$XOR$有什么联系，然后发现，这不需要联系啊。。。

首先，$GCD$有个还算不错的性质：

对于一列数组，从左往右取前缀$gcd$，不同的值最多只有$\log_2n$种。

并且每次值如果改变，那么前缀$gcd$的值至少除以二。

对于每个块，维护下列信息：

块内数据$xor$和，块内$gcd$，块的头尾两个数的前缀$gcd$，块内每个数以块左端点为头的前缀$xor$和。

对于第四类信息，还需要用某种方法，使得支持在$\log_2n$的时间内询问是否存在一个数。

修改的时候，修改位置所在块暴力重构，后面的块更新第三类信息即可。

查询的时候，如果某个块的第三类信息相等，说明这个块内前缀$gcd$都不变，有没有解查表就知道了。

这个表怎么搞呢？

假设暴力扫描，如果前面的块所取到的前缀$gcd$为$lastgcd$，$xor$为$lastxor$。

若$gcd(lastgcd,Gcd[r[i]])==lastgcd$，则说明这个块内所有的数取$gcd$后都是$lastgcd$，那么$xor[j]=(\frac{x}{lastgcd}\quad xor \quad lastxor)$。

然后在另一个排好序的数组中二分查找就可以了。

否则，这个块内暴力访问看一下是否有解，因为不同的$gcd$值不超过$\log_2n$种，所以暴力访问次数并不多。

所以复杂度就是$O(n\sqrt n\log_2n)$

[有空就到本蒟蒻的博客里喝喝茶哦！](https://www.cnblogs.com/Yangrui-Blog/p/9538578.html)

附代码：
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cmath>
#define MAXN 100010
using namespace std;
int n,m,block;
int colour[MAXN],Left[MAXN],Right[MAXN];
long long val[MAXN],gcd_sum[MAXN],xor_sum[MAXN];
struct node{
	long long x;
	int id;
	friend bool operator <(const node &p,const node &q){
		if(p.x==q.x)return p.id<q.id;
		return p.x<q.x;
	}
}a[MAXN];
inline long long read(){
	long long date=0,w=1;char c=0;
	while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
	while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
	return date*w;
}
long long gcd(long long x,long long y){
	if(!y)return x;
	return gcd(y,x%y);
}
int half_find(int l,int r,long long x){
	int mid,ans=l;
	while(l<=r){
		mid=l+r>>1;
		if(a[mid].x>=x){ans=mid;r=mid-1;}
		else l=mid+1;
	}
	return ans;
}
void build(int x){
	gcd_sum[Left[x]]=xor_sum[Left[x]]=val[Left[x]];
	a[Left[x]]=(node){val[Left[x]],Left[x]};
	for(int i=Left[x]+1;i<=Right[x];i++){
		gcd_sum[i]=gcd(gcd_sum[i-1],val[i]);
		xor_sum[i]=xor_sum[i-1]^val[i];
		a[i]=(node){xor_sum[i],i};
	}
	sort(a+Left[x],a+Right[x]+1);
}
int solve(long long x){
	int ans=-1;
	long long Gcd=val[1],Xor=0;
	for(int i=1;i<=colour[n]&&ans==-1;i++){
		if(gcd(Gcd,gcd_sum[Right[i]])==Gcd){
			if(x%Gcd==0){
				long long k=(x/Gcd)^Xor;
				int pos=half_find(Left[i],Right[i],k);
				if(a[pos].x==k){
					ans=a[pos].id;
					break;
				}
			}
			Gcd=gcd(Gcd,gcd_sum[Right[i]]);Xor^=xor_sum[Right[i]];
		}
		else{
			for(int j=Left[i];j<=Right[i];j++){
				Gcd=gcd(Gcd,val[j]);Xor^=val[j];
				if(Gcd*Xor==x){
					ans=j;
					break;
				}
			}
			if(ans!=-1)break;
		}
	}
	return ans;
}
void work(){
	char ch[10];
	long long x,y;
	while(m--){
		scanf("%s",ch);x=read();
		if(ch[0]=='M'){
			x++;y=read();
			val[x]=y;
			build(colour[x]);
		}
		else{
			int s=solve(x);
			if(s==-1)printf("no\n");
			else printf("%d\n",s-1);
		}
	}
}
void init(){
	n=read();
	block=(int)sqrt(n);
	for(int i=1;i<=n;i++){
		colour[i]=(i-1)/block+1;
		if(!Left[colour[i]])Left[colour[i]]=i;
		Right[colour[i]]=i;
		val[i]=read();
	}
	for(int i=1;i<=colour[n];i++)build(i);
	m=read();
}
int main(){
	init();
	work();
    return 0;
}

```

---

## 作者：rui_er (赞：4)

2023.6.21：题解已过审，但是发现有一处复杂度计算错误，修改后重新提交。

看到这种奇怪的操作，首先想到分块。

以下记值域为 $w$，块长为 $B$。

前缀 $\gcd$ 显然单调不增，而且后一个必须是前一个的因数，如果变化至少要减半。因此，我们知道，共有 $\mathcal O(\log w)$ 个不同的前缀 $\gcd$。我们可以接受对这些块暴力，只需要对前缀 $\gcd$ 都相同的块能快速求答案即可。

有以上思路做铺垫，容易想到设 $\operatorname{l}(x)$ 为第 $x$ 块的左端点（含），$\operatorname{r}(x)$ 为第 $x$ 块的右端点（含），$\operatorname{pos}(i)$ 为第 $i$ 个数所在块，$\operatorname{bgcd}(x)$ 为第 $x$ 块的 $\gcd$，$\operatorname{bxor}(i)$ 表示区间 $[\operatorname{l}(\operatorname{pos}(i)),i]$ 的异或和。同时，我们对每个块维护一个 map $\operatorname{bfirst}$，表示这个块内每个值作为 $\operatorname{bxor}$ 第一次出现的位置。

对于查询 $x$ 操作，从前往后扫描每个块，维护当前 $\gcd$ 和异或和。利用 $\operatorname{bgcd}$ 容易判断这个块内前缀 $\gcd$ 是否发生变化。如果发生变化，我们暴力整个块检查；如果未发生变化，即求 $\operatorname{bfirst}(\frac{x}{g}\oplus s)$，其中 $g,s$ 为此前所有块的 $\gcd$ 和异或和。暴力检查的块数为 $\mathcal O(\log w)$，这部分复杂度 $\mathcal O(B\log w)^\dagger$；其他块的复杂度为 $\mathcal O(\frac{n}{B}\log B)$。

对于单点修改操作，暴力改所在块即可。复杂度 $\mathcal O(B\log B)$。

取 $B=\sqrt{n}$，总复杂度 $\mathcal O(n\log n+q\sqrt{n}\log w)$。

$^\dagger$ 这就是开头处提到的复杂度计算错误。原本我认为调用了 $\mathcal O(q\sqrt{n}\log w)$ 次 $\gcd$ 函数（见代码），复杂度应为 $\mathcal O(q\sqrt{n}\log^2w)$。但是事实上只有 $\mathcal O(q\log w)$ 次调用不为 $\gcd(x,x)$ 的形式，因为前缀 $\gcd$ 只变化 $\mathcal O(\log w)$ 次。而我们注意到，$\gcd(x,x)$ 的复杂度为 $\mathcal O(1)$。事实上，考虑辗转相除法的过程，$\gcd(x,y)$ 的复杂度为 $\mathcal O(\log\frac{\max\{x,y\}}{\gcd(x,y)})$。因此，总复杂度为 $\mathcal O(q\sqrt{n}\log w)$。

```cpp
//By: OIer rui_er
#include <bits/stdc++.h>
#define rep(x,y,z) for(ll x=(y);x<=(z);x++)
#define per(x,y,z) for(ll x=(y);x>=(z);x--)
#define debug(format...) fprintf(stderr, format)
#define fileIO(s) do{freopen(s".in","r",stdin);freopen(s".out","w",stdout);}while(false)
using namespace std;
typedef long long ll;

mt19937 rnd(std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::system_clock::now().time_since_epoch()).count());
ll randint(ll L, ll R) {
    uniform_int_distribution<ll> dist(L, R);
    return dist(rnd);
}

template<typename T> void chkmin(T& x, T y) {if(x > y) x = y;}
template<typename T> void chkmax(T& x, T y) {if(x < y) x = y;}

const ll N = 1e5+5, BS = 505;

ll n, a[N], q, L[BS], R[BS], pos[N], B, tot, bgcd[BS], bxor[N];
map<ll, ll> bfirst[BS];

void init() {
    B = sqrt(n);
    chkmin(B, n);
    chkmax(B, 1LL);
    while(++tot) {
        L[tot] = R[tot-1] + 1;
        R[tot] = min(tot*B, n);
        rep(i, L[tot], R[tot]) {
            pos[i] = tot;
            bgcd[tot] = __gcd(bgcd[tot], a[i]);
            bxor[i] = (i == L[tot] ? 0 : bxor[i-1]) ^ a[i];
            if(!bfirst[tot].count(bxor[i])) bfirst[tot][bxor[i]] = i;
        }
        if(R[tot] == n) break;
    }
}

void modify(ll p, ll k) {
    a[p] = k;
    bgcd[pos[p]] = 0;
    map<ll, ll>().swap(bfirst[pos[p]]);
    rep(i, L[pos[p]], R[pos[p]]) {
        bgcd[pos[p]] = __gcd(bgcd[pos[p]], a[i]);
        bxor[i] = (i == L[pos[p]] ? 0 : bxor[i-1]) ^ a[i];
        if(!bfirst[pos[p]].count(bxor[i])) bfirst[pos[p]][bxor[i]] = i;
    }
}

ll query(ll x) {
    ll gcd = 0, now = 0;
    rep(i, 1, tot) {
        if(gcd != __gcd(gcd, bgcd[i])) {
            rep(j, L[i], R[i]) {
                gcd = __gcd(gcd, a[j]);
                now ^= a[j];
                if(gcd * now == x) return j;
            }
        }
        else {
            if(x % gcd == 0 && bfirst[i].count((x/gcd)^now)) return bfirst[i][(x/gcd)^now];
            now ^= bxor[R[i]];
        }
    }
    return -1;
}

int main() {
    scanf("%lld", &n);
    rep(i, 1, n) scanf("%lld", &a[i]);
    init();
    for(scanf("%lld", &q); q; q--) {
        char op[8];
        scanf("%s", op);
        if(op[0] == 'M') {
            ll p, k;
            scanf("%lld%lld", &p, &k);
            modify(p+1, k);
        }
        else {
            ll x;
            scanf("%lld", &x);
            ll ans = query(x);
            if(ans == -1) puts("no");
            else printf("%lld\n", ans-1);
        }
    }
    return 0;
}
```

---

## 作者：wjyyy (赞：4)

感觉需要推导的东西还是比较多的。但是以后要记着看到奇怪的（？）数据范围时要想到分块。

这个题有一定的特点，就是两个表达式都是前缀形式。对于 $\gcd$ 而言，它一定是递减的，而且不同的数值最多只有 $O(\log a_i)$ 个，因为每次至少会变为原来的 $\frac 12$。因此**产生变化的**位置是可以考虑枚举的。

注意到询问是 $10000$ 的，不是很大。我们对原区间进行 $O(\sqrt n)$ 分块。

因为要找的是最小的，所以应该从前往后枚举。对于 $\gcd$ 整块不变的那些块，我们只需要找到其中是否存在**异或前缀和**恰好为 $x/\gcd$ 的。这一询问可以用 `std::map` 来解决。

当涉及单点修改时，我们只需要对当前块中的 `map` 进行修改就可以了。

实际上 `map` 中存的是当前块中的异或前缀和，由于我们每次查询都是从前往后查，可以积累一定的信息。因此不必也不能维护全局前缀和，不然修改时影响的范围太大。

不过分块的细节挺多的，包括边界一类的。还要注意复杂度，不能把 `gcd()` 函数当 $O(1)$ 的操作用啊啊啊啊啊啊…= =

时间复杂度 $O(n\log a_i+q\sqrt n\log a_i)$。

## Code：

```cpp
#include<cstdio>
#include<cstring>
#include<map>
#include<cmath>
#define inf 2147438647
using std::map;
int gcd(int x,int y)
{
    while(y)
    {
        int t=y;
        y=x%y;
        x=t;
    }
    return x;
}
map<int,int> f[400];
int a[400][400],g[400][400];
int G[400],sum[400];
int main()
{
    int n,m,u;
    scanf("%d",&n);
    int b=sqrt(n),tmp=0;
    for(int i=1;i<=n;++i)
    {
        int x=(i-1)/b,y=(i-1)%b+1;
        scanf("%d",&a[x][y]);
        tmp^=a[x][y];
        g[x][y]=gcd(a[x][y],g[x][y-1]);
        G[x]=g[x][y];
        if(f[x].find(tmp)==f[x].end())
            f[x][tmp]=y;
        if(x!=i/b)
        {
            sum[x]=tmp;
            g[x+1][0]=G[x];
            tmp=0;
        }
    }
    scanf("%d",&m);
    char op[100];
    int tot=ceil((double)n/b)-1;
    while(m--)
    {
        scanf("%s",op);
        if(op[0]=='M')
        {
            scanf("%d",&u);
            ++u;
            int x=(u-1)/b,y=(u-1)%b+1;
            scanf("%d",&a[x][y]);
            f[x].clear();
            tmp=0;
            g[x][0]=x?G[x-1]:0;
            for(int j=1;j<=b;++j)
            {
                tmp^=a[x][j];
                if(f[x].find(tmp)==f[x].end())
                    f[x][tmp]=j;
                g[x][j]=gcd(a[x][j],g[x][j-1]);
                G[x]=g[x][j];
            }
            sum[x]=tmp;
        }
        else
        {
            long long k;
            scanf("%lld",&k);
            int flag=0;
            tmp=0;
            int gtmp=a[0][1];
            for(int i=0;i<=tot;++i)
            {
                if(!i||G[i]!=G[i-1])//暴力
                {
                    for(int j=1;j<=b;++j)
                    {
                        tmp^=a[i][j];
                        gtmp=g[i][j];
                        if((long long)tmp*gtmp==k)
                        {
                            flag=1;
                            printf("%d\n",i*b+j-1);
                            break;
                        }
                    }
                    if(flag)
                        break;
                }
                else
                {
                    gtmp=G[i];
                    if(k%gtmp==0&&k/gtmp<inf&&f[i].find(k/gtmp^tmp)!=f[i].end())
                    {
                        printf("%d\n",i*b+f[i][k/gtmp^tmp]-1);
                        flag=1;
                        break;
                    }
                    tmp^=sum[i];
                }
            }
            if(flag)
                continue;
            puts("no");
        }
    }
    return 0;
}
```



---

## 作者：_LPF_ (赞：3)

提供一种不用大分块的小清新、大常数算法。

[「HEOI2015」公约数数列](https://www.luogu.com.cn/problem/P4108)

> 给定序列，支持两个操作：
>
> - 单点修改。
> - 求满足 $\gcd(a_1,a_2,\cdots,a_p)\times \operatorname{xor}(a_1,a_2,\cdots,a_p)=x$ 的最小的 $p$。

首先应当有敏感性，本质不同前缀 $\gcd$ 只有 $\log V$ 段，这意味着可以直接枚举每段处理。

每次修改的时候，对段的重构只需利用轻量级的线段树就可以做到 $O(\log ^2 n)$，并非本算法的重点。

至此，问题变为每次询问最小的满足 $a_i=x/\gcd(a_l,\cdots,a_r),i\in[l,r]$ 的 $i$，其中 $a_i$ 表示 $i$ 的前缀异或和。

这看上去比较棘手，如果没有修改，一个 `set<pair<int, int>>` 可以胜任。其实如果有修改也不难。

可以记录修改的点，每次影响到它开始的后缀的 “前缀异或值”，每次询问时，原序列被这些点分割成了若干段。

每次直接分段询问，但段数多了又会影响询问复杂度。

于是设置阈值，这些点数量超过后就直接重构，即可保证复杂度。简单分析一下：

- 询问复杂度：$O(q(B+\log V)\log n)$。
- 修改复杂度：$O(q(\frac{n}{B}\log n+log^2n))$。

当 $B=\sqrt n$ 时取到最优，大概和大分块的 $O(n\sqrt n\log n)$ 平起平坐。

```cpp
#include<bits/stdc++.h>
typedef long long LL;
#define rep(i, a, b) for(int i = (a); i <= (b); i ++)
#define per(i, a, b) for(int i = (a); i >= (b); i --)
#define Ede(i, u) for(int i = head[u]; i; i = e[i].nxt)
using namespace std;

LL read() {
	LL x = 0, f = 1; char c = getchar();
	while(c < '0' || c > '9') f = (c == '-') ? - 1 : 1, c = getchar();
	while(c >= '0' && c <= '9') x = x * 10 + c - 48, c = getchar();
	return x * f;
}

typedef pair<int, int> PII;
#define fi first
#define se second
#define mp make_pair

const int N = 1e5 + 10;
const int inf = 0x7fffffff;
int n, q, B, a[N];

int dat[N << 2];

int Gcd(int a, int b) {while(b) {int c = a; a = b, b = c % b;} return a;}

void Upd(int p) {dat[p] = Gcd(dat[p << 1], dat[p << 1 | 1]);}

void Bui(int p, int l, int r) {
	if(l == r) {dat[p] = a[l]; return;}
	int mid = (l + r) >> 1;
	Bui(p << 1, l, mid), Bui(p << 1 | 1, mid + 1, r);
	Upd(p);
}

void Moi(int p, int l, int r, int k, int v) {
	if(l == r) {dat[p] = v; return;}
	int mid = (l + r) >> 1;
	if(k <= mid) Moi(p << 1, l, mid, k, v);
	else Moi(p << 1 | 1, mid + 1, r, k, v);
	Upd(p);
}

int Que(int p, int l, int r, int k) {
	if(r <= k) return dat[p];
	int mid = (l + r) >> 1;
	if(k <= mid) return Que(p << 1, l, mid, k);
	return Gcd(dat[p << 1], Que(p << 1 | 1, mid + 1, r, k));
}

int Ask(int p, int l, int r, int v) {
	if(l == r) return (dat[p] % v == 0) ? l : 0;
	int mid = (l + r) >> 1;
	if(dat[p << 1] % v == 0)
		return max(mid, Ask(p << 1 | 1, mid + 1, r, v));
	else
		return Ask(p << 1, l, mid, v);
}

int t, lt[N], rt[N], vt[N];

void Divide(int s) {
	int las = t, p = 1;
	t = 0;
	while(p <= las && rt[p] < s - 1) t ++, p ++;
	
	while(true) {
		if(rt[t] == n) break;
		int cur = rt[t] + 1;
		int val = Que(1, 1, n, cur);
		int nxt = Ask(1, 1, n, val);
		t ++, lt[t] = cur, rt[t] = nxt, vt[t] = val;
	}
}

int tot; PII arc[N];
set<PII> st;

void Remake() {
	st.clear(), tot = 0;
	int pre = 0;
	rep(i, 1, n)
		pre ^= a[i], st.insert(mp(pre, i));
}

void Modify(int x, int v) {
	v = a[x] ^ v;
	a[x] ^= v;

	if(! tot) {
		arc[tot = 1] = mp(x, v);
		return;
	}

	int cur = lower_bound(arc + 1, arc + tot + 1, mp(x, 0)) - arc;
	if(cur <= tot && arc[cur].fi == x) arc[cur].se ^= v;
	else {
		per(i, tot, cur) arc[i + 1] = arc[i];
		arc[cur] = mp(x, v), tot ++;
	}
	
	if(tot > B) {Remake();}
}

int Query(int l, int r, LL x, int g, int pre) {
	if(r < l || x % g != 0) return n + 1;	
	LL v = (x / g) ^ (LL) pre;
	if(v > inf) return n + 1;

	auto it = st.lower_bound(mp(v, l));
	if(it == st.end()) return n + 1;
	if((it -> fi) != v || (it -> se) > r) return n + 1;
	return (it -> se);
}

int main() {
	n = read();
	rep(i, 1, n) a[i] = read();
	
	Bui(1, 1, n);
	Divide(1), Remake();
	
	B = (int) sqrt(n);
	
	q = read();
	while(q --) {
		char opt[10]; scanf("%s", opt);
		if(opt[0] == 'M') {
			int x = read() + 1, v = read();
			Moi(1, 1, n, x, v);
			Divide(x);
			Modify(x, v);
		}
		else {
			LL x = read();
			int p = 1, pre = 0, ans = n + 1;
			rep(i, 1, t) {
				int lc = lt[i], rc = 0;
				while(p <= tot && arc[p].fi <= rt[i]) {
					rc = arc[p].fi - 1;
					ans = min(ans, Query(lc, rc, x, vt[i], pre));
					if(ans <= n) break;

					pre ^= arc[p].se, lc = arc[p].fi;
					p ++;
				}
				if(ans <= n) break;
				if(rc < rt[i])
					rc = rt[i], ans = min(ans, Query(lc, rc, x, vt[i], pre));
				if(ans <= n) break;
			}
			if(ans == n + 1) puts("no");
			else printf("%d\n", ans - 1);
		}
	}
	return 0;
}
```

---

## 作者：ComplexPlanck (赞：2)

喜闻乐见的大分块。

注意，此题解所有的下标从1开始，从而不同于题面的描述，注意下标问题。

---

考虑块长为$\,B\,$，那么总共有$\,\dfrac{N}{B}\,$个块。

对于每个块，我们维护两个值：$\,xos\,$即该块所有元素的异或和，$\,gcs\,$表示该块所有元素的最大公约数。

额外地，我们还需要开一个 `std::map`$\,xomap\,$，$\,xomap[x]\,$用来记录该块内部前缀异或和为$\,x\,$的最小编号（形式化地，也就是对于$\,S=\{i|\operatorname{xor}_{j=1}^{i}A_j=x\}\,$来说$\,\min_{r\in S}r\,$的值，其中$\,A_k\,$表示该块内第$\,k\,$个元素）。

首先考虑修改操作，由于是单点修改，而且我们的信息只涉及块内，而不涉及块外，所以直接对所在块暴力重构即可（即重新更新一遍$\,xos,gcs,xomap\,$）。

时间复杂度$\,\mathcal{O}(B\log W)\,$，其中$\,W\,$是元素值域上界。

然后考虑询问操作，容易发现的两点是：

$\,1.\,$前缀最大公约数序列是单调不升的。

$\,2.\,$假设原序列中第一个元素为$\,U\,$，那么~~由于最小的非$\,1\,$正整数是$\,2\,$~~，所以询问过程中涉及的不同的前缀最大公约数至多只有$\,\log_2 U\,$个，所以我们应该考虑那些不改变前缀最大公约数的块，因为这样的块才是占大多数的。

所以我们不妨用两个临时变量$\,xotemp\,$和$\,gcdtemp\,$来记录询问过程中的前缀异或和以及前缀最大公约数。

$\,(1)\,$对于那些不改变前缀最大公约数的块，我们只需要找出在块内是否存在一个位置$\,k\,$，使得

$$(xotemp\operatorname{xor}\operatorname{xor}_{i=1}^{k}A_i)\times gcdtemp=x$$

因为$\,xotemp\,$是之前所有块的前缀异或和，异或上$\,\operatorname{xor}_{i=1}^{k}A_i\,$就是以$\,A_k\,$结尾的前缀异或和了。又因为这是个不改变前缀最大公约数的块，所以以$\,A_k\,$结尾的前缀最大公约数和前面所有块的前缀最大公约数一样，就是$\,gcdtemp\,$。

显然存在这个位置$\,k\,$的充要条件是

$$\begin{aligned}&gcdtemp|x&(1)\\&\exists k,\,\text{s.t.}\,\operatorname{xor}_{i=1}^{k}A_i=xotemp\operatorname{xor}\left(\dfrac{x}{gcdtemp}\right)&(2)\end{aligned}$$

其中$\,\text{s.t.}\,$表示使得其满足$\,\cdots\,$，很显然式子左边就是我们之前用$\,xomap\,$维护的值，直接查询即可。

时间复杂度是$\,\mathcal{O}(\log W)\,$，另外注意正确维护$\,xotemp\,$和$\,gcdtemp\,$两个值

对于那些改变前缀最大公约数的块，由于数量稀少（至多只有$\,\log_2 W\,$块），直接暴力遍历即可。

这$\,log_2 W$块的暴力遍历部分的时间复杂度是$\,\mathcal{O}(\log_2 W\times B\log W)\,$

因此总的询问时间复杂度就是$\,\mathcal{O}(Q(B\log^{2}W+(\dfrac{N}{B}-\log W)\log W))\,$

理论上询问应在$\,B=\dfrac{\sqrt{N}}{\log W}\,$时最小，但由于修改操作以及常数问题，$\,B=\dfrac{\sqrt{N}}{2}\,$时更快。

参考代码如下：
```c++
#include <bits/stdc++.h>
typedef long long ll;

namespace io
{
    void read(int &x)
    {
        x = 0; int f = 1; char ch = getchar();
        while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();}
        while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
        x *= f; return;
    }
    void read(char &x)
    {
        char ch = getchar();
        while (!isalpha(ch)) ch = getchar();
        x = ch; return;
    }
    void read(ll &x)
    {
        x = 0; int f = 1; char ch = getchar();
        while (!isdigit(ch)) {if(ch == '-') f = -1; ch = getchar();}
        while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
        x *= f; return;
    }
}
namespace maths
{
    ll GCD(ll x, ll y)
    {
        return y ? GCD(y, x % y) : x;
    }
}
namespace problems
{
    using std::map;
    using std::min;
    using io::read;
    using maths::GCD;

    const int N = 300010, K = sqrt(N) / 2 + 1;
    const int INF = 1e9 + 1;
    int n, q;
    int p, plen;
    struct BLOCK
    {
        map<int, int> xomap;
        int a[K];
        int gcs, xos, len;

        void clear(void)
        {
            xomap.clear();
            xos = 0;
            return;
        }
    }blk[N / K + 10];

    int main()
    {
        read(n), plen = sqrt(n) / 2, p = (n - 1) / plen + 1;
        for (int i = 1; i <= p; i ++)
        {
            blk[i].clear();
            blk[i].len = (i == p) ? ((n - 1) % (plen) + 1) : plen;
      
            for (int j = 1; j <= blk[i].len; j ++)
            {
                read(blk[i].a[j]);
                if (j == 1) blk[i].gcs = 0;
                    blk[i].gcs = GCD(blk[i].a[j], blk[i].gcs);
                blk[i].xos xor_eq blk[i].a[j];
                if (blk[i].xomap.find(blk[i].xos) == blk[i].xomap.end())
                      blk[i].xomap[blk[i].xos] = j;
            }
        }
  
        read(q);
        char op; ll inpx, inpy;
        for (int i = 1; i <= q; i ++)
        {
            read(op);
            if (op == 'M')
            {
                read(inpx), read(inpy), inpx ++;
                int posx = (inpx - 1) / plen + 1, posy = (inpx - 1) % plen + 1;
                blk[posx].clear();

                blk[posx].a[posy] = inpy;
                blk[posx].gcs = 0;
                for (int j = 1; j <= blk[posx].len; j ++)
                {
                    blk[posx].xos xor_eq blk[posx].a[j];
                    if (blk[posx].xomap.find(blk[posx].xos) == blk[posx].xomap.end())
                        blk[posx].xomap[blk[posx].xos] = j;
                    blk[posx].gcs = GCD(blk[posx].gcs, blk[posx].a[j]);
                }
            }
            else if (op == 'Q')
            {
                read(inpx);

                bool flag = false;
                ll xotemp = 0, gcdtemp = 0, ans;

                for (int j = 1; j <= p; j ++)
                {
                    ll co_g = gcdtemp;
                    ll testg = GCD(gcdtemp, blk[j].gcs);
                    if (j != 1 && testg == co_g)
                    {
                        gcdtemp = GCD(co_g, blk[j].gcs);
                        if (inpx % gcdtemp == 0 && blk[j].xomap.find((inpx / gcdtemp) xor xotemp) != blk[j].xomap.end())
                        {
                            flag = true;
                            ans = (j - 1) * plen + blk[j].xomap[(inpx / gcdtemp) xor xotemp];
                        }
                        xotemp xor_eq blk[j].xos;  
                    }
                    else
                    {
                        for (int k = 1; k <= blk[j].len; k ++)
                        {
                            xotemp xor_eq blk[j].a[k];
                            gcdtemp = GCD(gcdtemp, blk[j].a[k]);
                            if (xotemp * gcdtemp == inpx)
                            {
                                flag = true;
                                ans = (j - 1) * plen + k;
                                break;
                            }
                        }
                    }
                    if (flag) break;
                }
                if (flag)
                    printf("%lld\n", ans - 1);
                else
                    puts("no");
            }
        }
        return 0;
    }
}

int main()
{
    problems::main();

    return 0;
}
```



---

## 作者：血色黄昏 (赞：2)

写一篇不用结构体存块的题解造福后人。

看到要维护奇奇怪怪东西还带修的数据结构首先想到分块。

我们需要维护的信息是块内 $gcd$  ,整个块修改时被异或上了哪个数，每个元素块内异或前缀和。异或前缀和用 $set$ 存。

对于每个修改操作，我们对散块暴力重构，由于 $a$ $xor$ $b=c$ 等价于$c$ $xor$ $b=a$ ，所以对于整块打上一个 $a_i$ $xor$ $x$ 的异或标记，表示整块要异或这样一个数。

对于询问，我们也是散块暴力统计，整块分两种情况统计，如果整块取 $gcd$ 后改变了值，那么直接暴力统计，因为这样的块的个数是对数级别的。如果 $gcd$ 不变，那么 $set.find(val)$ 即可。时间复杂度为 $O(n\sqrt{n}log_2n)$ ，可以通过本题。

注意坑点：我们统计的是区间 $gcd$ 和 $xor$ ，所以在处理到这个块的第一个数是要特判而不是直接 $gcd$ 或 $xor$ 前一个数，每次暴力操作记得把 $tag$ 和 $set$ 顺带重构清零，避免奇怪错误。

还有就是题目下标从零开始，别搞错了。

代码如下，有不懂的可以问我。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ls(i) (i - 1) * sq + 1
#define rs(i) min(i * sq, n)
using namespace std;
inline int read()
{
	register int x=0;register char ch=getchar();
	while(ch<48)ch=getchar();
	while(ch>=48)x=x*10+(ch^48),ch=getchar();
	return x;
}
int n, m, gsum[100010], xsum[100010], block[100010], sq;
int tag[100010];
set<int>s[1001];
int a[100010];
int gcd(int a, int b){return b == 0 ? a : gcd(b, a % b);}
void brush(int i)//暴力重构一个块
{
	if(tag[i])
    {
        for(int j = ls(i);j <= rs(i);j ++)(xsum[j] ^= tag[i]);
        tag[i] = 0;
    }
	s[i].clear();
	gsum[ls(i)] = a[ls(i)];
	s[i].insert(xsum[ls(i)]);
	for(int j = ls(i) + 1;j <= rs(i);j ++)
	{
		gsum[j] = gcd(gsum[j - 1], a[j]);
		s[i].insert(xsum[j]);
	}
}
void update(int pos, int val)每次更新
{
	int w = (a[pos] ^ val);//打标记异或什么值
	a[pos] = val;
	for(int i = pos;i <= rs(block[pos]);i ++)xsum[i] ^= w;
    brush(block[pos]);
	for(int i = block[pos] + 1;i <= block[n];i ++)tag[i] ^= w;
    int qwq = 0;
    for(int i = 1;i <= 9;i ++)qwq ^= a[i];
}
int FFind(int i, int val){return s[i].find(val) != s[i].end();}//set直接查找logn级别
int Find(int i, int val){for(int j = ls(i);j <= rs(i);j ++)if(xsum[j] == val)return j;}//直接暴力找
int brushed(int i, int g, int val)//gcd改变时的重构
{
	brush(i);
	for(int j = ls(i);j <= rs(i);j ++)
	{
		g = gcd(g, a[j]);
        if(g * xsum[j] == val)return j;
	}
	return 0;
}
int query(int x)
{
	int gc = gsum[rs(1)], g = gsum[rs(1)];
    int ans = brushed(1, a[1], x);//1要特判
    if(ans)return ans;
	for(int i = 2;i <= block[n];i ++)
	{
		gc = gcd(g, gsum[rs(i)]);
		if(gc == g)//分情况讨论
		{
			if(x % g != 0)continue;
         int w = x / g;
			if(FFind(i, w ^ tag[i]))
			{
				return Find(i, w ^ tag[i]);
			}
		}
		else
		{
			ans = brushed(i, g, x);
			if(ans)return ans;
		}
		g = gc;
	}
	return 0;
}
signed main()
{
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	sq = sqrt(n);
	xsum[0] = 0;
	for(int i = 1;i <= n;i ++)
	{
		cin>>a[i];
		xsum[i] = xsum[i - 1] ^ a[i];
		block[i] = (i - 1) / sq + 1;
	}
	tag[block[n] + 1] = 0;
	for(int i = 1;i <= block[n];i ++)//先预处理原序列
	{
		s[i].clear();
		tag[i] = 0;
		gsum[ls(i)] = a[ls(i)];
		s[i].insert(xsum[ls(i)]);
		for(int j = ls(i) + 1;j <= rs(i);j ++)
		{
			gsum[j] = gcd(gsum[j - 1], a[j]);
			s[i].insert(xsum[j]);
		}
	}
	cin>>m;
	for(int i = 1;i <= m;i ++)
	{
		string op;
		cin>>op;
		if(op == "MODIFY")//修改
		{
			int x, y;
			cin>>x>>y;
			x ++;
			update(x, y);
		}
		if(op == "QUERY")
		{
			int x;
			cin>>x;
			x = query(x);
			if(x)cout<<x - 1<<'\n';//从0开始要-1
			else cout<<"no\n";
		}
	}
	return 0;
}
```


---

## 作者：pomelo_nene (赞：2)

分块。

首先查看询问。我们要求最小的 $p$，使得 $\gcd(a_0,a_1,\dots,a_p) \times \operatorname{xor}(a_0,a_1,\dots,a_p)=x$（其中 $\operatorname{xor}$ 为异或和）。下面我们从 $1$ 开始标号。

首先能够得到 $\gcd$ 的一些性质。

1. $\gcd(\gcd(a_1,a_2,\dots,a_n),\gcd(b_1,b_2,\dots,b_m))=\gcd(a_1,a_2,\dots,a_n,b_1,b_2,\dots,b_m)$，所以两个块之间的 $\gcd$ 可以合并；   
2. $\gcd(a_1,a_2,\dots,a_p) \geq \gcd(a_1,a_2,\dots,a_{p+1})$，即新加入一个数的 $\gcd$ 一定小于等于之前的 $\gcd$；   
3. 对于前缀 $\gcd$，每次发生改变，至少变到原来的 $\dfrac{1}{2}$，即取值最多有 $O(\log a_i)$ 个。

好了有了这两个性质我们就有想法了。维护下面四个东西：

- 块内 $\operatorname{xor}$ 和；   
- 块内 $\gcd$；   
- 对于每个位置，求出这个位置作为结尾的前缀异或和；   
- 每一块头尾两个数的前缀 $\gcd$。（这个可以直接通过第二个东西求出来）。

对于修改，我们直接修改掉原来的元素，然后因为这个修改不会影响其他块，所以对于这个块我们暴力重构，时间复杂度 $O(\sqrt n)$。

对于查询，如果说这一块头尾两个数的前缀 $\gcd$ 是相等的，说明这块内没有发生变化，所以可以直接在排好序的块内二分查找查询是否有解就行了。

否则，暴力查询，遍历块内是否有解。因为不同的 $\gcd$ 值最多有 $O(\log a_i)$ 个，所以时间复杂度 $O(\sqrt n \log ^2 n)$。

总时间复杂度 $O(q\sqrt n \log ^2n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
struct block{
	LL val,pos;
	block(){val=pos=0;}
	block(LL V,LL P){val=V,pos=P;}
	bool operator < (block another) const {return (val<another.val) || (val==another.val && pos<another.pos);}
}s[100005];
LL gcd(LL a,LL b){return !b?a:gcd(b,a%b);}
LL n,a[100005],q,p,l[400],r[400],pos[100005],g[100005],x[100005];
void replace(LL t)
{
	g[l[t]]=x[l[t]]=a[l[t]];
	s[l[t]]=block(a[l[t]],l[t]);
	for(LL i=l[t]+1;i<=r[t];++i)
	{
		g[i]=gcd(g[i-1],a[i]);
		x[i]=x[i-1]^a[i];
		s[i]=block(x[i],i);
	}
	sort(s+l[t],s+r[t]+1);
}
LL binarysearch(LL l,LL r,LL val)
{
	LL ans=l;
	while(l<=r)
	{
		LL mid=(l+r)>>1;
		if(s[mid].val>=val)	ans=mid,r=mid-1;
		else	l=mid+1;
	}
	return ans;
}
LL query(LL u)
{
	LL ans=114514;
	LL gd=a[1],xo=0;
	for(LL i=1;i<=pos[n] && ans==114514;++i)
	{
		if(gcd(gd,g[r[i]])==gd)
		{
			if(u%gd==0)
			{
				LL p=(u/gd)^xo;
				LL pos=binarysearch(l[i],r[i],p);
				if(s[pos].val==p)	ans=s[pos].pos;
			}
			gd=gcd(gd,g[r[i]]);
			xo^=x[r[i]];
		}
		else
		{
			for(LL j=l[i];j<=r[i];++j)
			{
				gd=gcd(gd,a[j]);
				xo^=a[j];
				if(gd*xo==u)
				{
					ans=j;
					break;
				}
			}
		}
	}
	return ans;
}
int main(){
	scanf("%lld",&n);
	p=sqrt(n);
	for(LL i=1;i<=n;++i)
	{
		scanf("%lld",&a[i]);
		pos[i]=(i-1)/p+1;
		if(!l[pos[i]])	l[pos[i]]=i;
		r[pos[i]]=i;
	}
	for(LL i=1;i<=pos[n];++i)	replace(i);
	LL q;
	scanf("%lld",&q);
	while(q-->0)
	{
		char o[8];
		scanf("%s",o);
		if(o[0]=='M')
		{
			LL where,val;
			scanf("%lld %lld",&where,&val);
			++where;
			a[where]=val;
			replace(pos[where]);
		}
		else
		{
			LL val;
			scanf("%lld",&val);
			LL output=query(val);
			if(output==114514)	puts("no");
			else	printf("%lld\n",output-1);
		}
	}
	return 0;
}
```

---

## 作者：libra9z (赞：1)

~~**这是luogu一道为数不多的分块好题目，好评！**~~

### [原题描述](https://www.luogu.org/problemnew/show/P4108)


## 思路：

这题显然用分块。
 ~~（我一开始想到了傻逼的线段树TLE的解法，太蒻了）~~
我们珂以在每一块中维护下面内容：
1. 每一块内部的xor和
1. 每一块内$gcd$
1. 每个位置作为结尾的前缀异或和
1. 每一块头尾两个数的前缀$gcd$

### 修改：

修改位置所在块内部暴力重构，后面的块更新每一块头尾两个数的前缀$gcd$的信息即珂。

### 查询：

考虑查询，我们从左到右扫描每个块，维护当前前缀$gcd$。
若和一个新的块进行$gcd$操作后，其值改变，则说明这个块内有前缀$gcd$不同的位置，直接暴力扫描整块即珂。
如果不改变，则其前缀$gcd$都相同，直接在一个排好序的数组里面二分答案即珂。

### 时间复杂度：
$O(n\sqrt n\log_2n)$


#### 最后贴上蒟蒻的~~又丑又长~~的代码：


```cpp
#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>

#define Maxn 100005

int n, q, block;
int belong[Maxn]; // 每一个点所在的块
int L[Maxn], R[Maxn]; // 每一块的左端点和右端点
long long val[Maxn];
long long gcdp[Maxn]; // 每一块前缀GCD
long long xorp[Maxn]; // 每一块前缀异或和
char op[6];

struct node {
	long long val;
	int id;
} a[Maxn]; // 数组排序之后的结果 (val,pos)
int cmp(const void *A, const void *B) {
	struct node P = *(struct node*)A, Q = *(struct node*)B;
	if (P.val ^ Q.val) return P.val - Q.val;
	else return P.id - Q.id;
} // 用qsort排序的比较函数，按照val从小到大排序

#ifdef __cplusplus
extern "C" {
#endif
__attribute__((always_inline)) __inline__
long long gcd(long long x, long long y) {
	while (y) {
		long long z = x % y;
		x = y, y = z;
	} return x;
} // 最大公约数，没啥珂说的
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
void build(int i) {
	gcdp[L[i]] = xorp[L[i]] = val[L[i]];
	a[L[i]].val = val[L[i]], a[L[i]].id = L[i];
	for (int j = L[i] + 1; j <= R[i]; ++ j) {
		gcdp[j] = gcd(gcdp[j - 1], val[j]);
		xorp[j] = xorp[j - 1] ^ val[j];
		a[j].val = xorp[j], a[j].id = j;
	} qsort(a + L[i], R[i] - L[i] + 1, sizeof(a[0]), cmp); // 每一块之内排序，为了后面二分
} // 建立每一块
#ifdef __cplusplus
}
#endif

int main() {
	scanf("%d", &n);
	block = (int)sqrt(n);
	for (int i = 1; i <= n; ++ i) {
		scanf("%lld", val + i);
		belong[i] = (i - 1) / block + 1;
		if (!L[belong[i]]) L[belong[i]] = i;
		R[belong[i]] = i;
	} scanf("%d", &q);
	for (int i = 1; i <= belong[n]; build(i ++)); // 预处理
	while (q --) {
		scanf("%s", op);
		if (op[0] == 'M') {
			long long x, y;
			scanf("%lld %lld", &x, &y);
			++ x; val[x] = y;
			build(belong[x]); // 暴力重构
		}
		else {
			long long x; int ans = -1;
			scanf("%lld", &x);
			long long G = val[1], X = 0; // 
			for (int i = 1; i <= belong[n] && !~ans; ++ i)
				if (gcd(G, gcdp[R[i]]) == G) { // 没有改变
					if (!(x % G)) {
						long long k = x / G ^ X;
						int low = L[i], high = R[i], pos = low;
						while (low <= high) {
							int mid = low + high >> 1;
							if (a[mid].val >= k)
								pos = mid, high = mid - 1;
							else low = mid + 1;
						} // 二分位置
						if (a[pos].val == k) {
							ans = a[pos].id;
							break;
						}
					}
					G = gcd(G, gcdp[R[i]]);
					X ^= xorp[R[i]];
				}
				else { // 改变
					for (int j = L[i]; j <= R[i]; ++ j) {
						G = gcd(G, val[j]);
						X ^= val[j];
						if (G * X == x) {
							ans = j;
							break;
						}
					} // 暴力扫描整块
					if (~ans) break;
				}
			if (!~ans) puts("no");
			else printf("%d\n", ans - 1);
		}
	}
	return 0;
}
```

---

## 作者：听取MLE声一片 (赞：0)

注意：使用 `define int long long` 会使代码变慢很多，卡常时请去掉。

复杂度分析中认为 $n,q$ 同阶。

首先异或这东西就很神秘，作为按位操作就和 $\gcd$ 以及乘法格格不入，所以只能从 $\gcd$ 下手。


可以发现前缀 $\gcd$ 的值一共只会变化 $\log V$ 次，这是因为如果 $\gcd$ 值改变那么至少需要除以二。

这改变的次数就把序列划分成 $\log V$ 段，我们需要对这些段进行查询。

考虑分块，设块长为 $B$。每块分别维护开头和结尾的前缀 $\gcd$，并把块内前缀异或和扔进 set 里。

修改时直接暴力修改重构即可，卡常的话可以从修改位置开始重构，修改时间复杂度为 $O(qB\log B)$。

考虑查询，从头到尾枚举每个块，记录当前块之前所有数的异或和以及 $\gcd$。

如果一个块的开头结尾的前缀 $\gcd$ 相同，那么说明块内的 $\gcd$ 值都没有变化，块内需要的前缀异或和是固定的，直接在 set 中查询即可，时间复杂度为 $O(\frac{qn\log B}{B})$。

如果一个块的开头结尾的前缀 $\gcd$ 不相同，直接从块首开始暴力跑。因为 $\gcd$ 最多只会改变 $\log V$ 次，所以这样的块最多只有 $\log V$ 个。又因为如果 $\min(x,y)=\gcd (x,y)$ 只需要 $O(1)$ 就可以求出结果，所以时间复杂度为 $O(qB\log V)$。

平衡一下，发现 $B=\sqrt n$ 时最优，总时间复杂度为 $O(n\sqrt n \log V)$。

代码自带大常数。

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<algorithm>
#include<queue>
#include<stack>
#include<vector>
#include<map>
#include<set>
#include<bitset>
#include<ctime>
#define pii pair<int,int>
#define mkp make_pair
#define fi first
#define se second 
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
const int N=1e5+10;
const int M=1310;
const int inf=2e9;
int n,m,B,t,a[N];
int L[N],R[N],pos[N],b[M],c[N];
set<pii>st[M];
void build(int p,int fl=1){
	int l=L[p],r=R[p];
	if(fl)st[p].clear();
	b[p]=c[l]=a[l];
	for(int i=l;i<=r;i++){
		b[p]=__gcd(b[p],a[i]);
		if(i>l)c[i]=c[i-1]^a[i];
		if(fl)st[p].insert(mkp(c[i],i));
	}
	if(fl)st[p].insert(mkp(inf,0));
}
void update(int x,int k){
	int p=pos[x];
	for(int i=x;i<=R[pos[x]];i++){
		st[p].erase(mkp(c[i],i));
		st[p].insert(mkp(c[i]^a[x]^k,i));
	} 
	a[x]=k;
	build(p,0);
}
int query(long long k){
	int x=a[1],y=0;
	for(int i=1;i<=t;i++){
		if(x==b[i]){
			if(k%x==0){
				int w=(k/x)^y;
				pii u=*st[i].lower_bound(mkp(w,0));
				if(u.fi==w)
					return u.se;
			}
			y^=c[R[i]];
		}
		else{
			int l=L[i],r=R[i];
			for(int j=l;j<=r;j++){
				if(a[j]%x!=0)
					x=__gcd(a[j],x);
				y^=a[j];
				if(1ll*x*y==k)return j;
			}
		}
	}
	return 0;
}
int main()
{
	n=read();
	for(int i=1;i<=n;i++)
		a[i]=read();
	B=300;
	t=n/B;
	for(int i=1;i<=t;i++){
		L[i]=R[i-1]+1;
		R[i]=R[i-1]+B; 
	}
	if(R[t]<n){
		t++;
		L[t]=R[t-1]+1; 
		R[t]=n;
	}
	for(int i=1;i<=t;i++){
		for(int j=L[i];j<=R[i];j++)
			pos[j]=i;
		build(i);
	}
	m=read();
	while(m--){
		char opt[20];
		scanf("%s",opt);
		if(opt[0]=='M'){
			int x=read()+1,k=read();
			update(x,k);
		}
		if(opt[0]=='Q'){
			long long k=0;
			scanf("%lld",&k);
			int res=query(k)-1;
			if(res==-1)puts("no");
			else{
				printf("%d",res);
				putchar('\n');
			}
		}
	}
	return 0;
}
```

---

## 作者：FutaRimeWoawaSete (赞：0)

分块，考虑对于前缀 gcd 具有单调不增且将至多分出相同值段 $\log V$ 段的优秀性质，我们直接对于每次查询 $\log V$ 段里面，每段是否有一个前缀异或值为定值的位置即可。

维护每段的异或和，每段的 gcd，一个 hash 表维护段内前缀值对应的位置，视实现可以将非块内的前缀信息扰动出去，只维护块内信息，在实际查询时加上前缀信息即可。

由于修改是单点改，所以直接重构块信息就好了。

时间复杂度 $O(n \sqrt n \log n)$，个人使用的 map 实现，代码的复杂度是 $O(n \sqrt n \log^2 n)$。 

```cpp
/*
考虑找到 log 段复合就好了。
分块，对每块都维护一下就直接根号 log 了 
*/
#include "bits/stdc++.h"
using namespace std;
const int Len = 1e5 + 5 , SIZE = 325;
#define ll long long
#define ls(p) p << 1
#define rs(p) p << 1 | 1
int gcd(int a,int b)
{
	if(!b) return a;
	return gcd(b , a % b);
}
int a[Len],n,m,Gcd[SIZE],Xor[SIZE],pos[Len],L[SIZE],R[SIZE],t;
int sum[Len << 2];
void push_up(int x){sum[x] = (sum[ls(x)] ^ sum[rs(x)]);}
void build(int p,int l,int r)
{
	if(l == r){sum[p] = a[l];return;}
	int mid = (l + r) >> 1;
	build(ls(p) , l , mid);
	build(rs(p) , mid + 1 , r);
	push_up(p);
}
void update(int p,int l,int r,int idx)
{
	if(l == r){sum[p] = a[l];return;}
	int mid = (l + r) >> 1;
	if(idx <= mid) update(ls(p) , l , mid , idx);
	else update(rs(p) , mid + 1 , r , idx);
	push_up(p);
}
int qry(int p,int l,int r,int nl,int nr)
{
	if(nl > nr) return 0;
	if(nl <= l && nr >= r) return sum[p];
	int mid = (l + r) >> 1 , res = 0;
	if(nl <= mid) res ^= qry(ls(p) , l , mid , nl , nr);
	if(nr > mid) res ^= qry(rs(p) , mid + 1 , r , nl , nr);
	return res;
}
map<ll,int> mp[SIZE];
inline int Fg(int x,int y)
{
	if(!x || !y) return x + y;
	return gcd(x , y);
}
void resize(int x)
{
	int G = 0 , X = 0;
	mp[x].clear();
	for(int i = L[x] ; i <= R[x] ; i ++) 
	{
		G = Fg(G , a[i]) , X ^= a[i];
		if(!mp[x][X]) mp[x][X] = i;
	}
	Gcd[x] = G , Xor[x] = X;
}
struct Node
{
	int x,w;
	Node(){x = w = 0;}
	Node(int X,int W){x = X , w = W;}
}stk[105];
int len;
void inget(int G,int id)
{
	int rG = G;
	for(int i = L[id] ; i <= R[id] ; i ++)
	{
		rG = G;
		G = Fg(G , a[i]);
		if(rG != G) stk[++ len] = Node(i , G);
	}
}
void get()
{
	len = 0;int G = 0 , rG = 0;
	for(int i = 1 ; i <= t ; i ++) 
	{
		rG = G;
		G = Fg(G , Gcd[i]);
		if(rG != G) inget(rG , i);
	}
}
inline int find(int l,int r,ll ndx)
{
	//printf("%d %d %lld\n",l,r,ndx);
	int LL = pos[l] , RR = pos[r];
	ll X = qry(1 , 1 , n , 1 , l - 1);
	//if(l == 7 && r == 8) printf("%lld\n",X);
	for(int i = l ; i <= R[LL] ; i ++)
	{
		X ^= a[i];
		if(X == ndx) return i;
	}
	for(int i = LL + 1 ; i <= RR - 1 ; i ++)
	{
		if(mp[i][X ^ ndx]) return mp[i][X ^ ndx];
		X ^= Xor[i];
	}
	for(int i = L[RR] ; i <= r ; i ++)
	{
		X ^= a[i];
		if(X == ndx) return i;
	}
	return -1;
}
char s[125];
int main()
{
	scanf("%d",&n);
	for(int i = 1 ; i <= n ; i ++) 
	{
		scanf("%d",&a[i]);
		update(1 , 1 , n , i);
	}
	t = sqrt(n);
	for(int i = 1 ; i <= t ; i ++) 
	{
		L[i] = (i - 1) * t + 1;
		R[i] = i * t;
	} 
	if(R[t] < n) R[t] = n;
	for(int i = 1 ; i <= t ; i ++)	
	{
		for(int j = L[i] ; j <= R[i] ; j ++) pos[j] = i;
		resize(i);
	}
	scanf("%d",&m);
	for(int i = 1 ; i <= m ; i ++)
	{
		scanf("%s",s + 1);
		if(s[1] == 'M') 
		{
			int id,x;scanf("%d %d",&id,&x);
			id ++;
			a[id] = x;
			resize(pos[id]);
			update(1 , 1 , n , id);
		}
		else 
		{
			ll x;scanf("%lld",&x);
			get();int pp = -1;
			stk[len + 1].x = n + 1;
			for(int j = 1 ; j <= len ; j ++) 
			{
				if(x % stk[j].w) continue;
				pp = find(stk[j].x , stk[j + 1].x - 1 , x / stk[j].w);
				if(pp != -1) break;
			}
			if(pp == -1) printf("no\n");
			else printf("%d\n",pp - 1);
		}
	}
 	return 0;
}
```

---


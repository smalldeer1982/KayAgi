# [WC2005] 友好的生物

## 题目描述

$W$ 星球是一个和地球一样气候适宜、物种聚集的星球。经过多年的研究，外星生物学家们已经发现了数万种生物，而且这个数字还在不断增大。

$W$ 星球上的生物很有趣，有些生物之间很友好，朝夕相伴，形影不离；但有些却很敌对，一见面就难免发生战斗。为了能够更好地了解它们之间的友好程度，外星生物学家希望进行一些量化的计算。他们发现，两种生物之间的友好程度和它们的 $K$ 种属性有关，暂且将它们编号为属性 $1$、属性 $2$、……、属性 $K$，这些属性都是可以进行量化的。外星生物学家研究发现，如果前 $K-1$ 种属性的差别越大，这两种生物就越友好；但是属性 $K$ 与众不同，这种属性差别越小的两种生物越友好。

因此他们猜想是不是可以用这样一个公式量化两种生物之间的友好程度：$Friendliness=(\sum_{i=1}^{k-1} C_id_i)-C_Kd_K$

其中 $C_i$ 是非负常数，$d_i$ 是属性 $i$ 的差别。如果知道了每种生物的各种属性，利用上述公式就很容易算出它们之间的友好程度了。现在，外星生物学家们想问一问：在目前发现的这些生物当中，关系最友好的那对生物是哪一对呢？它们之间的友好程度是多少？


## 说明/提示

【样例说明】

生物 $3$ 和 $5$ 之间的友好程度为 $1\times |0-(-10)|+2\times |5-(-11)|-3\times |9-7|=36$。

【约定】

- $2 \leq N \leq 100,000$

- $2 \leq K \leq 5$

- $0 \leq C_i \leq 100$。

- 每种生物的各项属性值不小于$-10000$ 且不大于 $10000$。

- 最大的友好程度一定大于 $0$。


## 样例 #1

### 输入

```
5 3
1 2 3
-5 3 2
-2 3 0
0 5 9
3 4 -1
-10 -11 7```

### 输出

```
3 5
36```

# 题解

## 作者：λᴉʍ (赞：4)


首先可以发现$C$是没有用的，可以乘进所有的权值里面做

考虑没有最后一维的限制，那么两个生物的友好值就是

$\sum_{i=1}^k|a_i-b_i|$

这个绝对值就很麻烦了。

但是可以换个思路想，既然是绝对值那么一定$\geq 0$，所以两个生物的友好值是

$\max\left(\sum_{i=1}^k(a_i-b_i)(-1)^{c_i}\right)$

其中$c$取遍所有的01数组。正确性是显然的，因为其他的都没有答案大。

那么这道题$k\leq 5$，不考虑最后一维就是$k=4$。

上面的式子分开来考虑：

$\max\left(\sum_{i=1}^ka_i(-1)^{c_i}+\sum_{i=1}^kb_i(-1)^{c_i+1}\right)$

那么思路就很清晰了，对每个$c$记$\max\left(\sum_{i=1}^kw_i(-1)^{c_i}\right)$（记为$Max_c$）以及取这个最大值的生物，

答案就是$\max_{c_i+d_i=1}(Max_c+Max_d)$

但是还有最后一维的限制，所以把生物按照最后一维排序，依次先和Max更新答案，再更新Max。在更新$Max$的时候减去最后一维更新，更新答案的时候加上最后一维

```cpp
#include<bits/stdc++.h>
#define il inline
#define vd void
typedef long long ll;
il int gi(){
    int x=0,f=1;
    char ch=getchar();
    while(!isdigit(ch)){
        if(ch=='-')f=-1;
        ch=getchar();
    }
    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();
    return x*f;
}
struct yyb{int a[4],b,i;}s[100010];
int S[100010][1<<4];
il bool operator<(const yyb&a,const yyb&b){return a.b<b.b;}
int Mx[1<<4],f[1<<4],C[6];
int main(){
    int n=gi(),k=gi(),U=(1<<4)-1;
    for(int i=0;i<k;++i)C[i]=gi();
    for(int i=1;i<=n;++i){
        for(int j=0;j<k-1;++j)s[i].a[j]=gi()*C[j];
        for(int j=k-1;j<4;++j)s[i].a[j]=0;
        s[i].b=gi()*C[k-1];
        s[i].i=i;
    }
    k=4;
    std::sort(s+1,s+n+1);
    for(int i=1;i<=n;++i)
        for(int j=0;j<1<<k;++j)
            for(int l=0;l<k;++l)
                if((1<<l)&j)S[i][j]+=s[i].a[l];
                else S[i][j]-=s[i].a[l];
    for(int i=0;i<1<<k;++i)Mx[i]=S[1][i]+s[1].b,f[i]=s[1].i;
    int ans=-1e9,a=0,b=0;
#define chkans(t,_a,_b) {if((t)>ans)ans=(t),a=(_a),b=(_b);}
    for(int i=2;i<=n;++i){
        for(int j=0;j<1<<k;++j)chkans(Mx[U^j]+S[i][j]-s[i].b,s[i].i,f[U^j]);
        for(int j=0;j<1<<k;++j)if(Mx[j]<S[i][j]+s[i].b)Mx[j]=S[i][j]+s[i].b,f[j]=s[i].i;
    }
    printf("%d %d\n%d\n",a,b,ans);
    return 0;
}
```

---

## 作者：Maniac丶坚果 (赞：4)

/*本文根据陈启峰论文结合个人理解所作*/

【解析】

使用”约束 放宽”条件的算法。

首先不难看到一个很显眼的条件$ k \leq 5$,提示我们去拆分这个绝对值。

为了方便，以下均令$ k = 5$. 

将所有常数乘进去后，本来对于动物i,j，友好程度是这样的：

$|a_{i,1} - a_{j,1}| + |a_{i,2} - a_{j,2}| + |a_{i,3} - a_{j,3}| + |a_{i,4} - a_{j,4}| - |a_{i,5} - a_{j,5}|$

去掉绝对值以后，可以看成是图中的10个数（两组数）各带五个符号。

于是可以看成是对于每个$i$,给他的五个数取一组正负号SIGN（总共32种），在计算的时候和另一个符号全部取反的$i'$来进行求和。这一步显然可以用二进制位相关的操作瞎搞。

但由于绝对值的限制，我们需要满足$\forall  1 <= l <= k, a_{i,l} - a_{j,l} >=0.$

这个苛刻的限制似乎可以用$2^k$棵线段树来维护，但我太弱，并没有进行过尝试...

**到这里，就是“约束 放宽”条件法起作用的时候了。不过个人认为，这只是一种帮助你想到此题题眼的思想，请不要对这个名称过于纠结**

注意到答案就是我们要维护的这个$ a_{i,l} - a_{j,l}$所构成的。 而在题目中，在$l \neq k$的时候，这个值都是越大越好，只有$l = k$的时候是越小越好。

所以就是基于这一点，引发我们思考：能不能把条件放宽成只要$a_{i,k} - a_{j,k}\geq 0$ 就可以了呢？

**这一步理解可能很困难。 我先打个不恰当比方： 考一次试，想方设法取得好成绩，却又有一些规矩来限制着我们， 而其中有的规矩不是硬性规定（比如做题速度要怎么样，要花多少时间检查等等一些来自自己、前辈的经验），遵守他们本身就是为了让你做得更高效；有的规矩则可能是硬性的（比如不能作弊），不遵守比遵守就做这件事来说可能会导致你低效但你必须这么做。 在这个时候，我们要选出最会考试的学生，只需要在不能作弊的基础上关注成绩即可，因为那些成绩不理想的人往往更可能没有这些经验、在做题速度、检查时间这些方面把握的更不好。对于这个题，也是这个道理。**

瞎扯了这么多，我们来看看来自原文的科学证明（有改动）：

下面我们用$F_{i,BN}$来表示符号取BN的时候第i种动物的值。

【定理】对于任意的$a,b \in R,BN$，都有$|a - b| >= a - b$  &&$ |a - b| >= b - a$

【推论】对于任意的$a,b \in [1,n], BN \in [0, 2^k - 1]$ ,满足原性质的可以表示成
$(\sum_{i=1}^{K-1} |A_{a,i} - A_{b,i}|) - |A_{a,k} - A_{b,k}| $ 
满足新性质的可以表示成

$(\sum_{i=1}^{K-1} ±(A_{a,i} - A_{b,i}) - |A_{a,k} - A_{b,k}| $ 。那么显然满足原性质的那些数>= 满足新性质的那些数。

所以设满足两个性质的结果集分别为$S1，S2$，其中最大值为$MAX1，MAX2$，那么一定有$MAX1 >= MAX2$.

但是注意！ 因为显然原性质严格比新性质苛刻（即原性质包含新性质）

所以有$S1 \subset S2$.

所以显然$MAX1 <= MAX2$

综上， $MAX1 = MAX2$.

所以，我们就成功的实现了“放宽”。

**个人认为，原论文中所讲到的“约制”与“放宽”中，“放宽”这一操作相对来说更加新颖，而“约制”则可以认为是从一些无章的事物中规约出性质，没听说过这个算法也会这么做。**

接下来的做法就建议自己想一想在看下去了：

首先枚举符号；
因为只要让$a_{i,k} - a_{j,k}\geq 0$满足，我们不妨让a数组先按照k从小到大排一个序使得每一个后面元素的k都大于前面元素的k，然后维护一个最小值；每遍历一个，先用他的值减去当前的最小值和答案比大小，再用它更新一下最小值即可。

所以总复杂度是$O(n2^k)$的。

代码：

```
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int INF = 0x3f3f3f3f;
const int maxn = 100010;
inline int read()
{
    int x = 0, f = 1;
    char ch = 0;
    while (!isdigit(ch)) {ch = getchar(); if (ch == '-') f = -1;}
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    return x * f;
}
int c[maxn], n, k, ans;
struct node
{
    int a[6],id;
}a[maxn];
bool cmp(node a,node b) {return a.a[k] < b.a[k];};
inline int calculate(int sign, int x)
{
    int ans = 0;
    for(int i = 0; i < k - 1; i++) ans += (sign & (1 << i)) ?a[x].a[i + 1] :  - a[x].a[i + 1];
    ans -= a[x].a[k]; return ans;
}
int main()
{
    n = read(); k = read();
    for(int i = 1; i <= k; i++) c[i] = read();
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= k; j++)
        a[i].a[j] = read(), a[i].a[j] *= c[j];
    for (int i = 1; i <= n; ++i) a[i].id = i;
    sort(a + 1, a + n + 1, cmp);
    int ans1,ans2;
    for(int i = 0; i < (1 << k - 1); i++)
    {
        int minn = INF;int minid;
        for(int j = 1; j <= n; j++)
        {
            int now = calculate(i, j);
            ans = max(now - minn, ans); if (ans == now - minn) ans1 = a[j].id,ans2 = minid;
            minn = min(now, minn);if (minn == now) minid = a[j].id;
        }
    }
    printf("%d %d\n",min(ans1,ans2),max(ans1,ans2));
    printf("%d\n",ans);
    return 0;
}
```


---

## 作者：蒟蒻丁 (赞：3)

[洛谷地址](https://www.luogu.com.cn/problem/P4131)  
[更好体验](https://www.cnblogs.com/caijiLYC/p/14424220.html)  
和[shortcut](https://www.cnblogs.com/caijiLYC/p/14384106.html)挺类似的，正解大概能想到一半，先不考虑第 $k$ 位的问题，看一看前 $k-1$ 位  
对于那个奇怪的 $C$ ，先把他乘到 $d$ 里面，就可以不考虑了  
然后是绝对值  
联想一下shortcut那题，一个绝对值有两种拆法 $|d_i-d_j|=d_i-d_j$ 或 $|d_i-d_j|=d_j-d_i$   
那么有没有可能一个错误的拆法出现在了最优解中呢，这是不可能的  
若两者都为正数这两种拆法互为相反数，除非都是零，否则会有一个负数，那么最优解肯定不会选择负数那个，也就不会选择不合法的那个  
扩展到整数也是一样，最优解一定是合法的  
所以我们只要简单地用状压枚举每个绝对值的拆法，打擂台出 $j$ 就好  
然后考虑一下第 $k$ 位，看了一下其他人的解法，挺神奇的  
但是第 $k$ 位并不能直接加入爆枚中去（反正我没想到方法，取负是错误的，因为爆枚中可能会把它重新取负回来）  
所以考虑单调性，如果按照第 $k$ 位升序排序，那么 $d_{i,k}-d_{j,k}$ 就一定是正得了，这样就好贪心很多  
具体可以参考代码
```c++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll long long
using namespace std;
ll n,m,k,a[100001],d[7],sum[100001],ans2,ans1,ans,t1,t2,minn;

struct place {
	ll a[101],id;
	bool operator <(const place&tmp )const {
		return a[m]<tmp.a[m];
	}
}A[1097890];

int main(){
	scanf("%lld%lld",&n,&m);
	for(ll i=1;i<=m;i++){
		scanf("%lld",&a[i]);
	}
	for(ll i=1;i<=n;i++){
		for(ll j=1;j<=m;j++){
			scanf("%lld",&A[i].a[j]);
			A[i].id=i;
			A[i].a[j]*=a[j];
		}
	}
	sort(1+A,1+A+n);
	for(ll s=0;s<=(1<<(m-1));s++){
		ans1=1e10;
		for(ll j=0;j<m-1;j++){
			if(s&(1<<j))d[j+1]=1;
			else d[j+1]=-1;
		}
		for(ll i=1;i<=n;i++){
			ll tmp=0;
			for(ll j=1;j<m;j++){
				tmp+=d[j]*A[i].a[j];
			}
			tmp-=A[i].a[m];
			ans=max(ans,tmp-ans1);
			if(ans==tmp-ans1)t1=A[i].id,t2=minn;
			ans1=min(tmp,ans1);
			if(ans1==tmp)minn=A[i].id;
		}
	}
	cout<<t1<<' '<<t2<<endl<<ans;
}
```

---

## 作者：ZnPdCo (赞：1)

题目大意，给定 $C_i$ 和 $w_{i,j}$，求给出一对 $x,y$ 使得 $(\sum_{i=1}^{k-1} C_i| w_{x,i}-w_{y,i}|)-C_k| w_{x,k}-w_{y,k}|$ 最大。

首先 $C_i | w_i-w_j|=| C_iw_i-C_iw_j|$，发现 $C$ 可以乘进所有的属性 $w_{i,j}$ 中做，结果是不会变的。为了方便，下面的 $w_{i,j}$ 都是乘了 $C$ 的。

发现如果加上绝对值很难想，可以先去掉绝对值试试看：求一对 $x,y$ 使得 $(\sum_{i=1}^{k-1} w_{x,i}-w_{y,i})-(w_{x,k}-w_{y,k})=(\sum_{i=1}^{k-1} w_{x,i}) +(\sum_{i=1}^{k-1}-w_{y,i})-w_{x,k}+w_{y,k}$ 最大。

于是我们想到一个解法，使用 $f_y$ 表示前 $y$ 个中最大的 $(\sum_{i=1}^{k-1}-w_{y,i})+w_{y,k}$。枚举第 $x$ 个生物，答案就是 $(\sum_{i=1}^{k-1}+w_{x,i})-w_{x,k}+\max(f_{x-1})$，即可 $O(n)$ 维护。

再次简化，我们可以把权值为 $-1$ 的属性 $k$ 先去掉。由于题目加上了绝对值，我们可以考虑暴力维护正负情况，如 $\sum_{i=1}^{k-1} (w_{x,i}-w_{y,i})(-1)^s$。我们只需要枚举每一位的 $s$。显然如果 $s$ 正确，答案必为最大值。

仿照上面的解法，拆开有 $\sum_{i=1}^{k-1} w_{x,i}(-1)^s+\sum_{i=1}^{k-1} w_{y,i}(-1)^{s-1}$。使用 $f_{y,s}$ 表示前 $y$ 个中正负情况为 $s$ 的最大的 $\sum_{i=1}^{k-1} w_{y,i}(-1)^{s}$，第 $x$ 位的答案显然为 $\max((\sum_{i=1}^{k-1} w_{x,i}(-1)^{s})+f_{x-1,\neg s})$，然后答案即可 $O(n2^k)$ 维护。

回到原题目，由于属性 $k$ 要乘以 $-1$，枚举正负情况**不满足**如果 $s$ 正确则答案为最大值的推论。

我们可以按照属性 $k$ 从小到大排序，那么后面的属性一定大于前面的属性 $k$。

原式子变为了 $(\sum_{i=1}^{k-1} | w_{x,i}-w_{y,i}|)-w_{x,k}+w_{y,k}$，我们维护 $f_{y,s}$ 表示前 $y$ 个中正负情况为 $s$ 的最大的 $\sum_{i=1}^{k-1} w_{y,i}(-1)^{s}+w_{y,k}$，第 $x$ 位的答案显然为 $\max((\sum_{i=1}^{k-1} w_{x,i}(-1)^{s})-w_{x,k}+f_{x-1,\neg s})$，答案即可 $O(n2^k)$ 维护。

```c++
#include <cstdio>
#include <algorithm>
#define N 100010
#define K 10
#define ll long long
using namespace std;
ll n, k, ans = -1e15, pos1, pos2;
ll c[N];
struct node {
	ll a[K], pos;
} d[N];
// 前i个状态 +dk 
struct node2 {
	ll val, pos;
} f[N][1<<5];
bool cmp(node x, node y) {
	return x.a[k] < y.a[k];
}
ll fun(ll x) {
	ll res = 0;
	for(ll i = 0; i < k-1; i++) {
		if((x & (1<<(i))) == 0) res |= (1<<i);
	}
	return res;
}
int main() {
	scanf("%lld %lld", &n, &k);
	for(ll i = 1; i <= k; i++) {
		scanf("%lld", &c[i]);
	}
	for(ll i = 1; i <= n; i++) {
		d[i].pos = i;
		for(ll j = 1; j <= k; j++) {
			scanf("%lld", &d[i].a[j]);
			d[i].a[j] *= c[j];
		}
	}
	for(ll s = 0; s < (1 << (k-1)); s++) {
		f[0][s].val = -1e15;
	}
	
	sort(d+1, d+1+n, cmp);
	
	
	for(ll i = 1; i <= n; i++) {
		for(ll s = 0; s < (1 << (k-1)); s++) {
			f[i][s] = f[i-1][s];
			ll sum = 0;
			for(ll j = 1; j < k; j++) {
				if(s & (1<<(j-1))) sum += d[i].a[j];
				else sum -= d[i].a[j];
			}
			if(sum + d[i].a[k] > f[i][s].val) {
				f[i][s].val = sum + d[i].a[k];
				f[i][s].pos = d[i].pos;
			}
			if(i != 1 && sum - d[i].a[k] + f[i-1][fun(s)].val > ans) {
				ans = sum - d[i].a[k] + f[i-1][fun(s)].val;
				pos1 = f[i-1][fun(s)].pos;
				pos2 = d[i].pos;
			}
		}
	}
	printf("%lld %lld\n%lld", pos1, pos2, ans);
} 
```



---

## 作者：cold_cold (赞：0)

 [安利一波博客](https://www.cnblogs.com/cold-cold/p/10145141.html)

这题算是毒瘤吧，看到这个题我除了O(n^2)想不到别的方法

后来尝试使用平方的方式乱搞，但是给出了反例

在看了[国家集训队ysy的解题](https://files-cdn.cnblogs.com/files/cold-cold/《友好的生物》解题报告.pdf)报告后方才明白

思路是一种放宽的思路

我们枚举每个差值的符号，在其中枚举最大值，就可以有效去除绝对值

最后按照第k位从小到大排序，来枚举

从小到大进行扫描，每次用当前的值减去他前缀的最小值即可

但是在我看了部分题解后，我发现大家没有写什么要排序

而我就正好卡在这了，我太弱了

按照第k位从小到大排序，是为了后面的数第k种属性大于前面的

这样减出来第k个属性的差值一定是负值，满足条件

实现如下：

```cpp
#include <algorithm>
#include <iostream>
#include <cmath>
#include <cstring>
#include <map>
#include <string>
#include <vector>
#include <queue>
#include <stack>
#include <cstdio>
#include <cstdlib>
using namespace std;
typedef long long ll;
inline ll read()
{
    register ll p(1),a(0);register char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
    if(ch=='-') p=-1,ch=getchar();
    while(ch>='0'&&ch<='9') a=a*10+ch-48,ch=getchar();
    return a*p;
}
const int N=100100;
int n,k,c[10],minn,num,ans,minid,t1,t2;
struct node
{
    int a[10],xu;
    bool operator < (const node &xx)const
    {
        return a[k]<xx.a[k];
    }
}po[N];
int main()
{
    // freopen("input","r",stdin);
    // freopen("output","w",stdout);
    n=read(),k=read();
    for(int i=1;i<=k;i++) c[i]=read();
    for(int i=1;i<=n;i++) for(int j=1;j<=k;j++) po[i].a[j]=read()*c[j],po[i].xu=i;
    sort(po+1,po+1+n);
    for(int i=(1<<(k-1))-1;i>=0;i--)
    {
        minn=0x3f3f3f3f;
        for(int j=1;j<=n;j++)
        {
        	num=0;
            for(int l=k-1;l>=1;l--) num+=(i&(1<<(l-1)))?-po[j].a[l]:po[j].a[l];
            num-=po[j].a[k];
            ans=max(ans,num-minn); if(ans==num-minn) t1=minid,t2=po[j].xu;
            minn=min(minn,num);if(minn==num) minid=po[j].xu;
        }
    }
    printf("%d %d\n%d",t1,t2,ans);
    return 0;
}
/*

*/

```


---


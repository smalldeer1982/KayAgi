# 万径人踪灭

## 题目背景

保先生是个好司机，总是开车带学生们上山玩。但是保先生去年开了最后一趟车后，由于一些奇奇怪怪的原因转行了。半年间，再也没有从这条路上山的人了。

当 VFleaKing 再次来到这座山玩的时候，发现已经没有往日的来来往往的游人了。算了，过去保先生还在的时候，来山上玩的人，也不全是来欣赏山上的风景的。

## 题目描述

如果机房马上要关门了，或者你急着要走，请直接跳到第六个自然段。

VFleaKing 注意到了这条上山下山的土路，有些地方能欣赏到美景，有些地方则不能。把上山的道路每 $10$ cm 分为一小段，则对于每一小段，用 `a` 表示能欣赏到美景，用 `b` 表示不能欣赏到美景，就能得到一个只含 `a`、`b` 的字符串 $s$。当然由于下山和上山是一条路，所以下山的道路的字符串就是将上山的道路的字符串反过来。

设上山字符串长度为 $n$，每个字符依次为 $s_1, s_2 .…, s_n$。在上山和下山的路上，VFleaKing 会选择某些小段查看旁边的景色，其他时间低头走路。即 VFleaKing 会选择 $k$ 个小段 $x_1, x_2 …x_k$，且 $k >0$，$1\le x_1<x_2<…<x_k\le n$，VFleaKing 上山和下山的过程中会在这些地方查看景色。

![](https://cdn.luogu.com.cn/upload/image_hosting/t9qpo3f9.png)

VFleaKing 希望，上山下山时看到的美景的情况相同。也就是说，VFleaKing 上山时是否看到了美景的情况是： $s_{x_1},s_{x_2},\cdots,s_{x_k}$ 记为字符序列 $T_1$，下山时是否看到了美景的情况是：$s_{x_k},s_{x_{k-1}},\cdots,s_{x_1}$ 记为字符序列 $T_2$。VFleaKing 希望 $T_1=T_2$。

VFleaKing 还希望，上山下山时查看景色的间隔相等。也就是说，上山时查看景色的间隔为：$x_2-x_1,x_3-x_2,x_k-x_{k-1}$，记为数列 $P_1$。下山时查看景色的间隔为：$x_k-x_{k-1},x_{k-1}-x_{k-2},…,x_2-x_1$，记为数列 $P_2$。VFleaKing 希望 $P_1=P_2$。

VFleaKing 觉得，如果第一次查看景色和最后一次查看景色这段时间里，没有一次低头看路他就会摔倒。也就是说，如果对于所有 $1\le i\le k$ 都有$x_i=x_1+i- 1$，VFleaKing 就会摔倒，VFleaKing不希望发生这样的情况。

就是要在一个只含 `a`、`b` 的字符串中选取一个子序列，使得:

1. 位置和字符都关于某条对称轴对称。
2. 不能是连续的一段。

以 $s = \texttt{"abaaaaabbabbabaa"}$ 为例。如果我们用符号 $[a_1, a_2,…,a_k]$ 表示一个序列，那么 $[1,4]$ 就是一个合法的序列 $x$，$[5,8,10,12,15]$ 也是，$[4,5,8,9,10,11,12,15,16]$ 也是。但是 $[1,2]$ 不满足 VFleaKing 第一个希望和第三个希望，所以不是。$[1,2,4]$ 不满足第二个希望，所以不是。$[9,10,11]$ 不满足第三个希望，所以不是。

![](https://cdn.luogu.com.cn/upload/image_hosting/6849dqla.png)

给你字符串 $s$，现在 VFleaKing 想知道，有多少个合法的 $x$。答案可能很大，VFleaKing 想知道对 $1000000007$ 取模的值。

## 说明/提示

## 样例解释

### 样例解释 1

$14$ 个方案分别是：

- $[1,3]$，$[1,4]$，$[2,5]$，$[1,6]$，$[3,6]$，$[4,6]$，$[1,7]$，$[3,7]$，$[4,7]$；
- $[1,4,7]$，$[3,5,7]$；
- $[1,3,4,6]$，$[1,2,5,6]$，$[3,4,6,7]$。

### 样例解释 2

我已经想到了一个绝妙的解释，可惜方案太多，写不下了。

### 样例解释 3

我已经想到了一个绝妙的解释，可惜方案太多，写不下了。

## 数据范围

- 其中 $10\%$ 的数据，字符串仅包含字母 `a` 或字母 `b`。
- 另有 $20\%$ 的数据，$n\le 1000$。
- 另有 $20\%$ 的数据，要么 `a` 的个数不超过 $10$，要么 `a` 的个数不超过 $10$。
- 另有 $10\%$ 的数据，$n\le 10000$。
- 对于 $100\%$ 的数据，$n \le 100000$。

## 来源

- 2013 湖北互测 week1
- bzoj 3160
- 信息学奥赛之数学一本通
- stong9070 整理



## 样例 #1

### 输入

```
abaabaa```

### 输出

```
14```

## 样例 #2

### 输入

```
aaabbbaaa```

### 输出

```
44```

## 样例 #3

### 输入

```
aaaaaaaa```

### 输出

```
53```

# 题解

## 作者：Orion545 (赞：11)

# 广告

### [蒟蒻のblog](http://www.cnblogs.com/dedicatus545/p/8831978.html)

# 正文

首先我们明确一个想法：答案等于“位置对称的回文子序列数”-“回文子串数”，而后面的回文子串数可以通过$manacher$做出来

所以我们的问题转化为：求“位置对称的会文字序列个数”

我们考虑以字符串$S$的第$i$个字符$S_i$作为一个子序列的对称中心

那么当$S_{i-j}=S_{i+j}\left(1\leq j\leq i-1\right)$时，我们的答案就加一种选择

如果对于$S_i$，有$x$个这样的相等字符对，那么最终以第$i$个位置为中心的答案就是$2^{x+1}-1$

为什么呢？

因为算上对称中心本身，一共有$x+1$组可以选或者不选的字符，除去全都不选的一种就是答案

然而这是i为某个特定字符的情况，或者说i为整数的情况，但是i还有在两个字符中间的情况，此时答案就是$2^x-1$，因为没有中间的自己那个字符

接下来，我们考虑如何计算每个位置上这样的字符组数量

我们构建两个多项式$A$与$B$，令$A$的所有原串中为'a'的位置系数为1，'b'系数为零，$B$则反过来

然后用$A$自乘，得到的新多项式的第i位的值，就是对称中心为第$\frac i2$的，两个字符都是'a'的字符组数，$B$同理

最后我们把$A$和$B$的每一位系数加起来，减去((i&1)^1)（代表对称中心是否在某个字符上），求2的次幂再减去1，最后减去manacher求出的回文子串数目就可以了

Code：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#define ll long long
using namespace std;
const ll MOD=1e9+7;
struct complex{
    double x,y;
    complex(double xx=0,double yy=0){x=xx;y=yy;}
    complex operator +(const complex &b){return complex(x+b.x,y+b.y);}
    complex operator -(const complex &b){return complex(x-b.x,y-b.y);}
    complex operator *(const complex &b){return complex(x*b.x-y*b.y,x*b.y+y*b.x);}
}A[400010],B[400010];
const double pi=acos(-1.0);
ll n,m,limit=1,cnt=0,r[400010];
void fft(complex *a,double type){
    ll i,j,k,mid;complex x,y,w,wn;
    for(i=0;i<limit;i++) if(i<r[i]) swap(a[i],a[r[i]]);
    for(mid=1;mid<limit;mid<<=1){
        wn=complex(cos(pi/mid),type*sin(pi/mid));
        for(j=0;j<limit;j+=(mid<<1)){
            w=complex(1,0);
            for(k=0;k<mid;k++,w=w*wn){
                x=a[j+k];y=w*a[j+k+mid];
                a[j+k]=x+y;a[j+k+mid]=x-y;
            }
        }
    }
}
ll s[100010],ans[200010],x[200010],p[200010],sum;char ss[100010];
void manacher(){
    ll maxn=-1,id,mx=0,i;
    for(i=1;i<=(n<<1)+1;i++){
        if(i<mx) p[i]=min(p[2*id-i],mx-i);
        else p[i]=1;
        while(x[i-p[i]]==x[i+p[i]]) p[i]++;
        if(mx<i+p[i]){
            mx=p[i]+i;id=i;
        }
    }
}
ll qpow(ll x,ll y){
    ll re=1;
    while(y){
        if(y&1) re=re*x%MOD;
        x=x*x%MOD;y>>=1;
    }
    return re;
}
int main(){
    ll i;
    scanf("%s",ss);n=strlen(ss);
    for(i=0;i<n;i++) s[i+1]=(ss[i]=='a');
    for(i=1;i<=(n<<1)+1;i++){
        if(i%2) x[i]=2;
        else x[i]=s[i>>1];
    }x[0]=-1,x[(n+1)<<1]=-2;
    
    while(limit<=(n<<1)) limit<<=1,cnt++;
    for(i=0;i<limit;i++) r[i]=((r[i>>1]>>1)|((i&1)<<(cnt-1)));
    
    for(i=1;i<=n;i++) A[i].x=B[i].x=s[i];
    fft(A,1);fft(B,1);
    for(i=0;i<=limit;i++) A[i]=A[i]*B[i];
    fft(A,-1);
    for(i=1;i<=(n<<1)+1;i++) ans[i]+=((ll)(A[i].x/limit+0.5)-((i&1)^1));
    
    memset(A,0,sizeof(A));memset(B,0,sizeof(B));
    for(i=1;i<=n;i++) A[i].x=B[i].x=(s[i]^1);
    fft(A,1);fft(B,1);
    for(i=0;i<=limit;i++) A[i]=A[i]*B[i];
    fft(A,-1);
    for(i=1;i<=(n<<1)+1;i++) ans[i]+=((ll)(A[i].x/limit+0.5)-((i&1)^1));
    for(i=1;i<=(n<<1)+1;i++) ans[i]=((ans[i]+((i&1)^1))>>1)+((i&1)^1);
    
    for(i=1;i<=(n<<1)+1;i++) ans[i]=qpow(2,ans[i])-1,ans[i]%=MOD;
    
    manacher();
    
    for(i=1;i<=(n<<1)+1;i++) ans[i]-=(p[i]>>1),ans[i]%=MOD;
    for(i=1;i<=(n<<1)+1;i++) sum+=ans[i],sum%=MOD;
    printf("%lld",sum);
}
```

---

## 作者：VenusM1nT (赞：8)

$\textbf{FFT}$ + $\textbf{Manacher}$.  
看题目发现直接求题目要求的 **位置关于某根轴对称的不连续回文子序列** 并不好求，考虑先求出 **位置关于某根轴对称的回文子序列**，然后再减去 **回文串** 的数量即题目要求的答案。**回文串** 可以用 $\textbf{Manacher}$ 轻松求出，问题就可以转换为 **位置关于某根轴对称的回文子序列** 怎么求。  
对每个位置进行考虑，令
$$f_i=\sum_{j=0}^i[s_j=s_{i\times 2-j}]$$
那么由二项式定理可以知道第 $i$ 个位置的答案是 $2^{f_i}-1$，但 $f_i$ 要怎么求呢？考虑一个性质，即 $1\times 1=1$，$1\times 0=0\times 1=0\times 0=0$，由于字符串中只有 `a,b`，可以令 $g_i=[s_i=$ `a` $]$，$h_i=[s_i=$ `b` $]$，则上式可以转化成卷积的形式，即：
$$f=g* g+h* h$$
然后就可以轻松解决了。
```cpp
#include<bits/stdc++.h>
#define MAXN 400005
#define reg register
#define inl inline
#define int long long
#define db double
using namespace std;
const int Mod=1e9+7,Gi=3;
const db Pi=acos(-1.0);
int n,lim=1,m,rev[MAXN],h[MAXN],s[MAXN],pos[MAXN],ans;
char ch[MAXN];
struct Complex
{
	db x,y;
	friend Complex operator + (const Complex &a,const Complex &b)
	{
		return ((Complex){a.x+b.x,a.y+b.y});
	}
	friend Complex operator - (const Complex &a,const Complex &b)
	{
		return ((Complex){a.x-b.x,a.y-b.y});
	}
	friend Complex operator * (const Complex &a,const Complex &b)
	{
		return ((Complex){a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x});
	}
}f[MAXN],g[MAXN];
inl int Pow(reg int x,reg int y)
{
	reg int res=1;
	for(;y;y>>=1,x=x*x%Mod) if(y&1) res=res*x%Mod;
	return res;
}
inl void FFT(reg Complex *A,reg int opt)
{
	for(reg int i=0;i<lim;i++) if(i<rev[i]) swap(A[i],A[rev[i]]);
	for(reg int mid=1;mid<lim;mid<<=1)
	{
		reg Complex Wn=((Complex){cos(Pi/(db)mid),(db)opt*sin(Pi/(db)mid)});
		for(reg int j=0;j<lim;j+=(mid<<1))
		{
			reg Complex W=((Complex){1,0});
			for(reg int k=0;k<mid;k++,W=W*Wn)
			{
				reg Complex x=A[j+k],y=W*A[j+k+mid];
				A[j+k]=x+y;
				A[j+k+mid]=x-y;
			}
		}
	}
	if(opt==1) return;
	for(reg int i=0;i<lim;i++) A[i].x=(int)(A[i].x/(db)lim+0.5);
}
inl int Manacher()
{
	reg int tot=0,pre=0,maxn=0,res=0;
	s[tot]='#';
	for(reg int i=0;i<n;i++)
	{
		s[++tot]=ch[i];
		s[++tot]='#';
	}
	for(reg int i=0;i<tot;i++)
	{
		reg int j=pre*2-i;
		if(i<maxn)
		{
			if(maxn-i>pos[j]) pos[i]=pos[j];
			else pos[i]=maxn-i;
		}
		else pos[i]=1;
		while(s[i+pos[i]]==s[i-pos[i]] && i>=pos[i]) pos[i]++;
		if(i+pos[i]>maxn)
		{
			maxn=i+pos[i];
			pre=i;
		}
	}
	for(reg int i=0;i<tot;i++) res=(res+(pos[i]>>1))%Mod;
	return res;
}
signed main()
{
	scanf("%s",ch);
	n=strlen(ch);
	while(lim<=((n+1)<<1))
	{
		lim<<=1;
		m++;
	}
	for(reg int i=0;i<=lim;i++) rev[i]=((rev[i>>1]>>1)|((i&1)<<(m-1)));
	for(reg int i=0;i<n;i++) if(ch[i]=='a') f[i].x=g[i].x=1.0;
	FFT(f,1); FFT(g,1);
	for(reg int i=0;i<lim;i++) f[i]=f[i]*g[i];
	FFT(f,-1);
	for(reg int i=0;i<lim;i++) h[i]=(h[i]+(int)f[i].x)%Mod;
	memset(f,0,sizeof(f));
	memset(g,0,sizeof(g));
	for(reg int i=0;i<n;i++) if(ch[i]=='b') f[i].x=g[i].x=1.0;
	FFT(f,1); FFT(g,1);
	for(reg int i=0;i<lim;i++) f[i]=f[i]*g[i];
	FFT(f,-1);
	for(reg int i=0;i<lim;i++) h[i]=(h[i]+(int)f[i].x)%Mod;
	for(reg int i=0;i<lim;i++) ans=(ans+Pow(2,(h[i]+1)>>1)-1)%Mod;
	ans=(ans-Manacher()+Mod)%Mod;
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：xixike (赞：6)

[更好的阅读体验](https://www.cnblogs.com/xixike/p/15631268.html)

## Description

> [Luogu传送门](https://www.luogu.com.cn/problem/P4199)

## Solution

~~好名字。~~

~~像我这种懒狗肯定是直接看简化版题意啊！~~

题意让我们求**不连续**的回文子序列个数，我们发现并不是很好求，所以转换一下思路，求：
$$
回文子序列个数（可连续）- 回文子串个数
$$
回文子串个数很容易求出来，就是 $manacher$ 板子，下面我们来考虑如何求出回文子序列个数。

设点 $id$ 为一个子序列的对称中心，若 $S_{i - j} = S_{i + j}$ ，我们的答案就会多一种选择，假设对于对称中心 $i$ 有 $f_i = x$ 种选择，那么：

1. $i$ 是一个字符，答案就是 $2^{x + 1} - 1$。包括对称中心 $i$ 在内有 $x + 1$ 对选或不选的字符，所以一共有 $2^{x + 1}$ 种情况，减去空集的 1 种情况就是答案。
2. $i$ 在两个字符中间，答案就是 $2^x - 1$，即不能包括对称中心。

通过上面的讨论可以发现这个对称中心在两个字符中间，所以我们按照 $manacher$ 的做法把原字符串翻倍，这样一来这个中心就一定是整点了。

那么这个 $f_i$ 如何求呢？

构造出生成函数：
$$
F(x) = \sum\limits_{i = 0}^{|s| - 1}a_ix^i
$$
然后令 $F(x)$ 自己卷自己，即 $F(x)^2$， 这一步用 NTT 或 FFT 都行。

不难发现，$F(x)^2$ 中 $x^i$ 的系数就是在原字符串中关于 $\frac{i}{2}$ 对称的字符对的个数。

又观察到输入的字符串中只有  `a` 和 `b` ，而且这两个字符之间没有关联，所以分开考虑：

1. 对于 `a`，若 $S_i = a$，那么 $A_i = 1$，反之 $A_i = 0$。
2. 对于 `b` 同理，若 $S_i = b$，那么 $B_i = 1$，反之 $B_i = 0$。

得出 $A$ 和 $B$ 之后我们就可以计算 $f_i$ 啦。

$$
f_i = A^2 + B^2
$$

最后统计一下答案就完啦。

## Code

我这里用的 NTT 做的，需要两个模数，注意写的时候不要弄混了 QwQ

```cpp
#include <bits/stdc++.h>
#define ll long long
#define cl const ll

using namespace std;

namespace IO{
    inline ll read(){
        ll x = 0;
        char ch = getchar();
        while(!isdigit(ch)) ch = getchar();
        while(isdigit(ch)) x = (x << 3) + (x << 1) + ch - '0', ch = getchar();
        return x;
    }

    template <typename T> inline void write(T x){
        if(x > 9) write(x / 10);
        putchar(x % 10 + '0');
    }
}
using namespace IO;

const ll N = 3e5 + 10;
const ll mod = 998244353, Mod = 1e9 + 7;
const ll G = 3, Gi = 332748118;
ll n, m, ans1, ans2;
ll a[N], b[N], c[N], d[N], rev[N];
int p[N];
char s[N], t[N];

namespace NTT{
    ll lim, len;

    inline ll qpow(ll a, ll b, ll mod){
        ll res = 1;
        while(b){
            if(b & 1) res = res * a % mod;
            a = a * a % mod, b >>= 1;
        }
        return res;
    }

    inline void get_rev(cl n){
        lim = 1, len = 0;
        while(lim < n) lim <<= 1, ++len;
        for(int i = 0; i < lim; ++i) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (len - 1));
    }

    inline void ntt(ll A[], cl lim, cl type){
        for(int i = 0; i < lim; ++i)
            if(i < rev[i]) swap(A[i], A[rev[i]]);
        for(int mid = 1; mid < lim; mid <<= 1){
            ll Wn = qpow(type == 1 ? G : Gi, (mod - 1) / (mid << 1), mod);
            for(int i = 0; i < lim; i += (mid << 1)){
                ll w = 1;
                for(int j = 0; j < mid; ++j, w = w * Wn % mod){
                    ll x = A[i + j], y = w * A[i + j + mid] % mod;
                    A[i + j] = (x + y) % mod;
                    A[i + j + mid] = (x - y + mod) % mod;
                }
            }
        }
        if(type == 1) return;
        ll inv = qpow(lim, mod - 2, mod);
        for(int i = 0; i < lim; ++i) A[i] = A[i] * inv % mod;
    }

    inline void Mul(cl n, cl m, ll a[], ll b[]){
        get_rev(n + m);
        ntt(a, lim, 1), ntt(b, lim, 1);
        for(int i = 0; i < lim; ++i) a[i] = a[i] * b[i] % mod;
        ntt(a, lim, -1);
    }
}
using namespace NTT;

inline void manacher(){
    n = strlen(t + 1);
    s[0] = '#', s[(n << 1) + 1] = '*';
    for(int i = 1; i <= n; ++i)
        s[(i << 1) - 1] = '*', s[i << 1] = t[i];
    m = (n << 1) + 1;
    int mx = 0, id = 0;
    for(int i = 1; i <= m; ++i){
        if(i < mx) p[i] = min(mx - i, p[(id << 1) - i]);
        else p[i] = 1;
        while(i - p[i] >= 1 && i + p[i] <= m && s[i - p[i]] == s[i + p[i]]) ++p[i];
        if(i + p[i] > mx) id = i, mx = i + p[i];
    }
    for(int i = 1; i <= (n << 1) + 1; ++i) ans1 = (ans1 + (p[i] >> 1)) % Mod;
}

inline void solve(){
    for(int i = 1; i <= n; ++i){
        if(t[i] == 'a') a[i - 1] = c[i - 1] = 1;
        else b[i - 1] = d[i - 1] = 1;
    }
    Mul(n, n, a, c), Mul(n, n, b, d);
    for(int i = 0; i <= (n << 1); ++i) c[i] = (a[i] + b[i]) % mod;
    for(int i = 0; i <= (n << 1) - 2; ++i){
        if(i & 1) ans2 = (ans2 + qpow(2, (c[i] >> 1), Mod) - 1 + Mod) % Mod;
        else ans2 = (ans2 + qpow(2, (c[i] >> 1) + 1, Mod) - 1 + Mod) % Mod;
    }
    write((ans2 - ans1 + Mod) % Mod), puts("");
}

int main(){
    scanf("%s", t + 1);
    manacher();
    solve();
    return 0;
}
```

$$
\_EOF\_
$$


---

## 作者：Gypsophila (赞：6)

### Description

给定一个字符串由 'a' 或 'b' 组成。求有多少个子序列满足字母和坐标都关于一条对称轴对称并且不是连续的

字符串长度 $=n \leq 10^5$

### Solution

默认字符串为 $S$ 从 $0$ 开始标号。 

答案等于所有的满足字母和坐标都关于一条对称轴对称的子序列数量 - 连续的满足这个性质的子序列数量

后面这个可以直接用 **manacher算法** 直接求出，只需要考虑前面怎么求

考虑怎么算出关于第 $i$ 个**位置**对称的子序列个数。设有 $k$ 组 $(x, y)$ 使得 $x + y = 2 i$ 且 $x, y \not= i$ 且 $S_x = S_y$ ，那么方案数就是 $2^{k+1}-1$ （k 组和 $i$ 这个位置选不选减去都不选的一种情况）

考虑怎么算出关于第 $i$ 到第 $i+1$ 个位置中间这个空隙（可以认为是 $i + \frac{1}{2}$）对称的子序列的个数。设有 $k$ 组 $(x,y)$ 满足 $S_x = S_y$ 且 $x+y = 2(i+\frac{1}{2}) = 2i + 1$ ，那么方案数就是 $2^k - 1$（和上面不一样的原因是自己这个位置不是整数不能被选所以不用考虑）

令 $ f_i = \sum\limits_{x+y=i} [S_x=S_y] $ ，那么 $f_i$ 和这个 $k$ 的关系是什么呢？

这里要想清楚。当 $i$ 是偶数的时候，$[S_{\frac{i}{2}}=S_{\frac{i}{2}}]$ 其实也被算了进去，所以应该是 $f_i = 2k + 1$；而 $i$ 是奇数的时候就没有这个问题，直接就是 $f_i = 2k$；综合一下其实就是 $k = \lfloor \frac{f_i}{2} \rfloor$

然后就是怎么求 $f_i$ 的问题了。这是一个卷积的形式，又显然字母之间是独立的。那么对于每一个字母 $x$，令 $g_i = [S_i = x]$，那么 $f$ 就是由两个 $g$ 卷积得到的。所以最后 f 就是对于两个字母分别做一遍卷积加起来就行。

具体的，这道题的做法是：
1. 拿到字符串，跑 manacher 得到 s1 
2. 令 $f_i = [S_i = a]$，将 $f * f$ 加到多项式 $h$ 中
3. 令 $g_i = [S_i = b]$，将 $g * g$ 加到多项式 $h$ 中
4. 答案就相当于 $ \sum\limits_{i=0}^{2n -  2} (2^{\lfloor\frac{h_i}{2}\rfloor + [2|i]}-1)$ （可能有点复杂不过综合上面来看是显然的）

对于卷积，我用的是 NTT (FFT 我也写了，慢了 4 倍嘿嘿)

时间复杂度 $O(n \log n)$

### Code 

[看代码戳这里](https://acfunction.github.io/2019/02/28/BZOJ3160/#Code)


---

## 作者：cyffff (赞：4)

[$\text{Link}$](https://www.luogu.com.cn/problem/P4199)
## 题意
给一个长度为 $n$ 的，字符集为 $2$ 的字符串 $s$，求满足以下三个条件的字符串 $t$ 的数量。

- $t\in\text{subsequences}(s)$；
- $t\notin\text{substrings}(s)$；
- $t$ 在 $s$ 中的位置、字符沿某对称中心对称。

其中 $n\le 10^5$。
## 思路
首先求出满足 $1,3$ 条件的 $t$ 的数量减去不满足 $2$ 条件的 $t$ 的数量即可，后者可以 $\text{Manacher}$ 或者 $\text{PAM}$ 解决，不是本题重点，故只讨论前者。

我们可以考虑转换思路，枚举对称中心计算答案之和。

令 $f_i$ 表示以 $i$ 为对称中心时对称的字母个数，则
$$f_i=\sum_{j=1}^i[s_j=s_{2i-j}]$$
容易得知，对于这 $f_i$ 对数中每对都可选或不选，但不能全部不选，所以 $i$ 处的的答案为 $2^{f_i}-1$。

当 $g_i=[s_i=c]$ 时，$s_i=s_j=c$ 当且仅当 $g_i=g_j=1$，即 $g_i\times g_j=1$。

那么枚举 $c$，构造多项式 $F$，其中 $F_i=[s_i=c]$，那么可以直接计算 $F^2$ 计入答案即可。实现时需要注意判断对称中心是在原字符串上还是插入的字符上。

时间复杂度 $O(n\log n)$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
namespace IO{//by cyffff
	//here was something
}
const int N=4e5+10,mod=1e9+7;
char str[N],input[N];
int p[N],ans[N],n,sum;
inline void getc(char *a,char *b,int n){
	int len=0;
	b[len++]='~';
	b[len++]='|';
	for(int i=1;i<=n;i++){
		b[len++]=a[i];
		b[len++]='|';
	}
	b[n*2+2]=0;
	len--;
}
inline int qpow(int x,int y){
	int res=1;
	while(y){
		if(y&1) res=1ll*res*x%mod;
		x=1ll*x*x%mod;
		y>>=1;
	}
	return res;
} 
#define ld double
const ld pi=acos(-1);
struct comp{
	ld x,y;
	comp(ld a=0,ld b=0){x=a,y=b;}
	comp neg(){ return comp(x,-y); }
	friend comp operator+(const comp &a,const comp &b){ return comp(a.x+b.x,a.y+b.y); }
	friend comp operator-(const comp &a,const comp &b){ return comp(a.x-b.x,a.y-b.y); }
	friend comp operator*(const comp &a,const comp &b){ return comp(a.x*b.x-a.y*b.y,a.y*b.x+a.x*b.y); }
};
int rev[N],lim;
inline int add(int x,int y){ return x+y>=mod?x+y-mod:x+y; }
inline int dec(int x,int y){ return x>=y?x-y:x-y+mod; }
inline void init(int n,int mode=1){
	if(mode){
		int l=0;
		for(lim=1;lim<=n;lim<<=1)l++;
		for(int i=0;i<lim;i++){
			rev[i]=(rev[i>>1]>>1)|((i&1)<<l-1);
		}
	}else{
		for(lim=1;lim<=n;lim<<=1);
	}
}
inline void FFT(comp *a,int lim,int tpe){
	for(int i=0;i<lim;i++)
		if(i<rev[i])
			swap(a[i],a[rev[i]]);
	for(int i=1;i<lim;i<<=1){
		comp wn(cos(pi/i),tpe*sin(pi/i));
		for(int j=0;j<lim;j+=(i<<1)){
			comp w(1);
			for(int k=0;k<i;k++,w=w*wn){
				comp t=a[i+j+k]*w;
				a[i+j+k]=a[j+k]-t;
				a[j+k]=a[j+k]+t;
			}
		}
	}
		
	if(tpe==-1){
		double p=1./lim;
		for(int i=0;i<lim;i++)
			a[i].x*=p,a[i].y*=p;
	}
}
comp A[N];
int main(){
	n=readstr(input);
	getc(input,str,n);
	for(int i=1,r=0,mid=0;i<=n*2+1;i++){
		if(i<r)
			p[i]=min(p[(mid<<1)-i],r-i);
		while(str[i-p[i]]==str[i+p[i]])
			p[i]++;
		if(i+p[i]>r)
			r=i+p[i],mid=i;
	}
	init(n<<1);
	for(int i=1;i<=n;i++)
		A[i].x=input[i]=='a';
	FFT(A,lim,1);
	for(int i=0;i<lim;i++)
		A[i]=A[i]*A[i];
	FFT(A,lim,-1);
	for(int i=1;i<=n*2+1;i++)
		ans[i]+=(int(A[i].x+0.5)-(i%2==0));
	for(int i=0;i<lim;i++)
		A[i].x=A[i].y=0;
	for(int i=1;i<=n;i++)
		A[i].x=input[i]=='b';
	FFT(A,lim,1);
	for(int i=0;i<lim;i++)
		A[i]=A[i]*A[i];
	FFT(A,lim,-1);
	for(int i=1;i<=n*2+1;i++)
		ans[i]+=(int(A[i].x+0.5)-(i%2==0));
	for(int i=1;i<=n*2+1;i++)
		ans[i]=((ans[i]+(i%2==0))>>1)+(i%2==0);
	for(int i=1;i<=n*2+1;i++)
		ans[i]=qpow(2,ans[i])-1;
	for(int i=1;i<=n*2+1;i++)
		ans[i]-=p[i]>>1;
	for(int i=1;i<=n*2+1;i++)
		sum=(sum+ans[i])%mod;
	printf("%d\n",sum);
	return 0;
}
```
再见 qwq~

---

## 作者：APJifengc (赞：3)

# 题目大意

给定一个只包括 $a$ 和 $b$ 的字符串，求满足以下条件的子序列的数量：

1. 位置和字符都关于某条轴对称。
2. 不是连续的一段。

# 题解

首先，如果某个子序列是连续的一段，那么它其实就是原字符串的一个子回文串。我们可以使用 **Manacher** 算法首先计算出所有的回文串数量，最后再减去即可。这样我们就去除了第二条限制。

考虑第一条限制：假如我们关于某条轴有 $a$ 对字符对称，那么实际能组成的子序列就有 $2^a-1$ 种。（每对字符可以选可以不选，并且要减去空序列）

那么如何快速计算关于某条轴对称的字符对数呢？发现字符集为 $2$，那么我们可以直接对每个字符单独考虑：

设 $d_i$ 为第 $i$ 个位置是否为 $a$，如果我们假设对称轴为 $k$（$k$ 可以为一个分母为 $2$ 的分数，即对称轴在两个字符中间），那么以 $k$ 为对称轴的字符对数就是：

$$\sum_{\frac{i+j}{2}=k}d_id_j$$

发现这个东西比较像卷积的形式。这个分数看起来很不爽，但是可以考虑我们在进行 Manacher 的时候，已经对字符串进行了补位，这样我们可以设 $k$ 为补位后的字符串的对称轴，这样我们实际要求的答案就是：

$$\sum_{k=1}^{2n+1}\sum_{i+j=k}d_id_j$$

化为卷积的形式：

$$\sum_{k=1}^{2n+1}\sum_{i=1}^kd_id_{k-i}$$

使用 FFT 或者 NTT 进行优化即可。

注意这个式子会将不在同一位置的两个字母重复计算一次，但是在同一位置的字母只会计算一次，所以我们要除以 $2$ 并向上取整（向上取整的原因是在计算回文串时已经计算了一个字母的数量了，如果这里向下取整就会少计算一个字母的数量，算出来的结果就会多减一些数。）

字符为 $b$ 的情况是一样的，最后将 $a$ 和 $b$ 的数量都加起来一起除以 $2$ 向上取整就是关于这个对称轴对称的字符对数。

最后减去回文串的数量就可以了。

复杂度 $O(n\log n)$。

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 400105;
int n;
char ch[MAXN];
char ch2[MAXN];
int r[MAXN];
void manacher() {
    for (int i = 1, m = 0, c; i <= 2 * n + 1; i++) {
        r[i] = i > m ? 1 : min(m - i, r[2 * c - i]);
        while (ch2[i + r[i]] == ch2[i - r[i]]) r[i]++;
        if (i + r[i] > m) {
            m = i + r[i];
            c = i;
        }
    }
}
const int P = 998244353, G = 3, P2 = 1000000007;
int qpow(int a, int b, int P = ::P) {
    int ans = 1;
    while (b) {
        if (b & 1) ans = 1ll * ans * a % P;
        a = 1ll * a * a % P;
        b >>= 1;
    }
    return ans;
}
const int GI = qpow(G, P - 2);
int R[MAXN];
struct Polynomial {
    vector<int> a;
    int len;
    int& operator[](int b) { return a[b]; }
    Polynomial(int len = 0) : len(len) { a.resize(len + 1); }
    void set(int len) { this->len = len, a.resize(len + 1); }
    void ntt(int limit, bool rev) {
        set(limit);
        for (int i = 0; i < limit; i++) if (i < R[i]) swap(a[i], a[R[i]]);
        for (int mid = 1; mid < limit; mid <<= 1) {
            int step = qpow(rev ? GI : G, (P - 1) / (mid << 1));
            for (int l = 0; l < limit; l += (mid << 1)) {
                int w = 1;
                for (int i = 0; i < mid; i++, w = 1ll * w * step % P) {
                    int x = a[l + i], y = 1ll * w * a[l + i + mid] % P;
                    a[l + i] = (x + y) % P, a[l + i + mid] = (x - y + P) % P;
                }
            }
        }
        if (rev) {
            int nrev = qpow(limit, P - 2);
            for (int i = 0; i < limit; i++) a[i] = 1ll * a[i] * nrev % P;
        }
    }
    Polynomial operator*(Polynomial b) {
        Polynomial a = *this, c; int n = a.len + b.len;
        int limit = 1; while (limit <= n) limit <<= 1; c.set(limit);
        for (int i = 0; i < limit; i++) 
            R[i] = (R[i >> 1] >> 1) | ((i & 1) * limit >> 1);
        a.ntt(limit, false), b.ntt(limit, false);
        for (int i = 0; i < limit; i++) c[i] = 1ll * a[i] * b[i] % P;
        c.ntt(limit, true);
        c.set(n);
        return c;
    }
    void print() {
        for (int i : a) printf("%d ", i);
        printf("\n");
    }
}a, b;
long long ans = 0;
int main() {
    scanf("%s", ch + 1);
    n = strlen(ch + 1);
    ch2[0] = '?';
    for (int i = 1; i <= 2 * n + 1; i++) ch2[i] = (i & 1) ? '#' : ch[i >> 1];
    manacher();
    a.set(n), b.set(n);
    for (int i = 1; i <= n; i++) {
        if (ch[i] == 'a') {
            a[i]++;
        } else {
            b[i]++;
        }
    }
    a = a * a, b = b * b;
    for (int i = 1; i <= 2 * n + 1; i++) 
        ans = (1ll * ans + qpow(2, ((a[i] + b[i] + 1) / 2), P2) - r[i] / 2 - 1 + P2) % P2;
    printf("%lld\n", ans);
    return 0;
}
```

---

## 作者：Kelin (赞：3)

### 题意

给定一个由$a$和$b$构成的字符串,求不连续回文子序列的个数

---
### 题解

不连续回文子序列数=回文子序列数-回文子串数

后面的可以直接用$PAM$求出来

~~(我才不会说因为$Manacher$能干的$PAM$都能干,所以弃掉了$Manacher$)~~

考虑回文子序列数怎么求

如果$s_i=s_j$那么这两个字符就关于$\frac{i+j}2$对称

考虑$(s_i,s_j)$选不选就对$\frac{i+j}2$有$\times2$的贡献

所以可以设$f_{\frac{i+j}2}=$左右两边有多少对$(s_i,s_j)$满足$s_i=s_j$

去掉左右的限制$f_{\frac{i+j}2}=\sum\frac{[s_i=s_j]}2$

下标里面有$\frac12$很讨嫌,而且对称中心还可能是小数

所以直接设$f_{i+j}=\sum\frac{[s_i=s_j]}2$

上面看起来是一个卷积的形式,考虑把等于变成乘法

$$\Rightarrow f_{i+j}=\lceil\frac{\sum_c\sum[s_i=c]*[s_j=c]}2\rceil=\lceil\frac{\sum_cS_c^2(x)}2\rceil$$

所以就可以枚举字符集,然后用做$|c|+1$遍$FFT$算$f_i$

因为$FFT$里如果两个字符位置相同$(s_i=s_i)$是不会被算两遍的,所以要向上取整

然后$\lceil\frac x2\rceil=\lfloor\frac{x+1}2\rfloor$

然后全集$Sum=\sum_{i=1}^{2n}2^{f_i}-1$(非空子集)
```
#include<bits/stdc++.h>
#define fp(i,a,b) for(register int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(register int i=a,I=b-1;i>I;--i)
#define go(u) for(register int i=fi[u],v=e[i].to;i;v=e[i=e[i].nx].to)
#define file(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
template<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}
template<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}
using namespace std;
const int N=1e5+5,M=1<<18,P=1e9+7;
inline int pls(int a,int b){return a+=b,a>=P?a-P:a;}
inline int sub(int a,int b){return a-=b,a<0?a+P:a;}
struct PAM{
    int n,T,las;char s[N];
    struct node{int fail,len,cnt,ch[26];}a[N];
    inline void init(){las=n=0;T=a[0].fail=1;s[0]=a[1].len=-1;}
    inline int gf(int x){while(s[n-a[x].len-1]^s[n])x=a[x].fail;return x;}
    inline void ins(int v){
        s[++n]=v;las=gf(las);
        if(!a[las].ch[v]){
            a[++T]={a[gf(a[las].fail)].ch[v],a[las].len+2};
            a[las].ch[v]=T;
        }++a[las=a[las].ch[v]].cnt;
    }
    inline int calc(){
        int tp=0;
        fd(i,T,2)a[a[i].fail].cnt=pls(a[a[i].fail].cnt,a[i].cnt),tp=pls(tp,a[i].cnt);
        return tp;
    }
}p;
int n,K,ans,pw[M],R[M];char s[N];
struct cp{
    double x,y;
    inline cp operator+(const cp&b){return(cp){x+b.x,y+b.y};}
    inline cp operator-(const cp&b){return(cp){x-b.x,y-b.y};}
    inline cp operator*(const cp&b){return(cp){x*b.x-y*b.y,x*b.y+y*b.x};}
}a[M],b[M],w[M];
const double pi=acos(-1),eps=0.1;
inline void fft(cp*const a,const int tp){
    fp(i,0,K-1)if(i>R[i])swap(a[i],a[R[i]]);
    for(int i=2;i<=K;i<<=1){
        int d=i>>1;cp e=cp{cos(pi/d),tp*sin(pi/d)},o;
        for(int j=d;j>=0;j-=2)w[j]=w[j>>1];
        for(int j=1;j<=d;j+=2)w[j]=w[j-1]*e;
        for(cp*x=a;x!=a+K;x+=i)fp(k,0,d-1)
            o=x[k+d]*w[k],x[k+d]=x[k]-o,x[k]=x[k]+o;
    }
}
int main(){
    #ifndef ONLINE_JUDGE
        file("s");
    #endif
    scanf("%s",s);n=strlen(s);p.init();
	w[0]={1};K=1;while(K<n<<1)K<<=1;pw[0]=1;
	fp(i,1,K-1)pw[i]=pls(pw[i-1],pw[i-1]);
	fp(i,0,n-1)s[i]=='a'?a[i].x=1:b[i].x=1;
	for(int i=0,j=0;i<K;++i){R[i]=j;for(int l=K>>1;(j^=l)<l;l>>=1);}
    fft(a,1),fft(b,1);fp(i,0,K-1)a[i]=a[i]*a[i]+b[i]*b[i];fft(a,-1);
    fp(i,0,K-1)ans=pls(ans,pw[(int(a[i].x/K+eps)+1)>>1]-1);
    fp(i,0,n-1)p.ins(s[i]-'a');
    printf("%d",sub(ans,p.calc()));
return 0;
}
```

---

## 作者：pomelo_nene (赞：2)

放一个可以优化到只用 $2$ 次 FFT 的做法。

显然考虑枚举对称轴。那么计算对称轴两边相同字符的数量 $c$，每一个字符存在选和不选两种，不能不选，那么方案数就是 $2^c-1$。注意到选出来的字符串不可以是单个回文串，所以还要用 Manacher 减去回文串数量。

那怎么计算每个对称轴两边相同字符的数量呢？我们将 $a$ 看作 $1$，$b$ 看作 $-1$，然后做加法卷积。如果两个相同的字符匹配了，那么贡献为 $1$；否则两数相乘，结果为 $-1$。我们可以通过小学教的解方程算出对称轴两边相同字符的数量，计算答案即可。

当然我自己写的有点问题，所以是 $4$ 次 FFT……当然如果不会三次变两次可以去看板子题。

嗯我还是贴一个代码吧……

```cpp
Poly SelfMul(Poly f)
{
	LL len=len(f)*2-1;
	LL lim=1;
	while(lim<len)	lim<<=1;
	Poly ret;
	ret.resize(lim);
	f.resize(lim);
	makeRev(lim);
	FFT(f,1);
	for(LL i=0;i<lim;++i)	ret[i]=f[i]*f[i];
	FFT(ret,0);
	for(LL i=0;i<lim;++i)	ret[i].x=ret[i].x/lim,ret[i].y=ret[i].y/lim;
	ret.resize(len);
	return ret;
}
Poly f,g;
char s[100005],t[200005];
LL n,a[100005];
LL slp[200005],pls[200005];
LL manacher()
{
	static LL p[200005];
	t[0]='#';
	LL st=0;
	for(LL i=1;i<=n;++i)	t[++st]='|',t[++st]=s[i-1];
	t[++st]='|';
	LL ans=0;
	for(LL i=1,r=0,d=0;i<=st;++i)
	{
		if(i<=r)	p[i]=min(p[2*d-i],r-i+1);
		while(t[i-p[i]]==t[i+p[i]])	++p[i];
		if(p[i]+i-1>r)	r=p[i]+i-1,d=i;
		if(t[i]=='|')	ans+=(p[i]-1)/2;
		else	ans+=(p[i]+1)/2;
	}
	return ans;
}
int main(){
	scanf("%s",s);
	n=strlen(s);
	for(LL i=0;i<n;++i)	f.push_back(Complex(s[i]=='a'?1:-1,s[i]=='a'?1:-1)),g.push_back(Complex(s[i]=='a'?1:-1,s[i]=='a'?1:-1));
	reverse(g.begin(),g.end());
	f=SelfMul(f),g=SelfMul(g);
	for(LL i=0;i<2*n-1;++i)	slp[i]=LL(round(f[i].y/2)),pls[i]=LL(round(g[i].y/2));
	LL ans=0;
	for(LL i=0;i<n;++i)
	{
		{
		LL x=slp[i];
		LL st=i+1;
		LL mtc=(st-(st-x)/2)/2;
		if(i&1)	ans+=QuickPow(2,mtc)-1;
		else	ans+=QuickPow(2,mtc+1)-1;
		}
		if(i!=n-1)
		{
		LL x=pls[i];
		LL st=i+1;
		LL mtc=(st-(st-x)/2)/2;
		if(i&1)	ans+=QuickPow(2,mtc)-1;
		else	ans+=QuickPow(2,mtc+1)-1;
		}
	}
	ans-=manacher();
	ans%=MOD;
	ans+=MOD;
	ans%=MOD;
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：zac2010 (赞：1)

考虑容斥：拿满足条件 $1$ 的方案数减去满足条件 $1$ 但不满足条件 $2$ 的方案数就是答案。

满足条件 $1$ 但不满足条件 $2$ 的方案可以用 $\text{Manacher}$ 算法 $O(n)$ 计算。

对于满足条件 $1$ 的总方案数，我们记 $c_i$ 表示以 $i$ 位置为对称轴时，满足条件的位置对的数量（即两个位置上的字符相同，且 $i$ 位置是它们的对称轴），那么显而易见，答案就是 $\sum (2^{f_i}-1)$。

所以现在的问题就是 $c_i$ 怎么求。我们枚举每一种字符并设其为 $ch$，之后将序列中对应位置字符为 $ch$ 的位置标为 $1$，将新数列与其翻转后的数列加法卷积一下就可以得到只考虑某种字符的 $c'$ 数组。而最终的 $c$ 数组也就是各个 $c'$ 数组的加和。

```cpp
#include <bits/stdc++.h>
namespace Poly{
    constexpr int N = 2.7e5 + 10;
    constexpr double Pi = acos(-1);
    int n, m, p[N];
    std::complex<double> f[N], g[N];
    void FFT(int n, std::complex<double> *c, int x = 1){
        for(int i = 0; i < n; ++i) if(i < p[i]) std::swap(c[i], c[p[i]]);
        for(int b = 2, k = 1; b <= n; b <<= 1, k <<= 1){
            std::complex<double> t(cos(2 * Pi / b), sin(2 * Pi / b) * x), w(1, 0);
            for(int i = 0; i < n; i += b, w = 1){
                for(int j = 0; j < k; ++j, w *= t){
                    c[i + j] += c[i + j + k] * w;
                    c[i + j + k] = c[i + j] - c[i + j + k] * w - c[i + j + k] * w;
                }
            }
        }
    }
    std::vector<double> Convolution(const auto &a, const auto &b){
        if(!a.size() || !b.size()) return std::vector<double>();
        n = a.size(), m = b.size();
        int l = 1 << (int)ceil(log2(n + m - 1));
        for(int i = 0; i < l; ++i){
            f[i] = i < n? a[i] : 0, g[i] = i < m? b[i] : 0;
            p[i] = (p[i >> 1] >> 1) | (i & 1? l >> 1 : 0);
        }
        n += m - 1, FFT(l, f), FFT(l, g);
        for(int i = 0; i < l; ++i) f[i] *= g[i];
        FFT(l, f, -1); std::vector<double> ret;
        for(int i = 0; i < n; ++i)
            ret.emplace_back(f[i].real() / l);
        return ret;
    }
}
namespace String{
    constexpr int N = 1e5 + 10;
    char s[N << 1]; int n, p[N << 1];
    long long Manacher(char a[]){
        int la = strlen(a);
        s[n = 0] = '$', s[++n] = '#';
        for(int i = 0; i < la; ++i) s[++n] = a[i], s[++n] = '#';
        s[n + 1] = '%';
        int m = 0, r = 0; long long ans = 0;
        for(int i = 1; i <= n; ++i){
            p[i] = (i <= r? std::min(p[m * 2 - i], r - i + 1) : 1);
            while(s[i - p[i]] == s[i + p[i]]) ++p[i];
            if(i + p[i] - 1 > r) m = i, r = i + p[i] - 1;
            ans += (p[i] >> 1);
        }
        return ans;
    }
}
#define FL(i, a, b) for(int i = (a); i <= (b); ++i)
#define FR(i, a, b) for(int i = (a); i >= (b); --i)
using Poly::Convolution;
using String::Manacher;
constexpr int N = 1e5 + 10, p = 1e9 + 7;
int n, m, pw[N], a[N << 1], ans;
char str[N]; std::vector<int> v;
int main(){
    scanf("%s", str);
    n = strlen(str), pw[0] = 1;
    FL(i, 1, n) pw[i] = (pw[i - 1] << 1) % p;
    auto C = [](int x){
        v.resize(n);
        FL(i, 0, n - 1) v[i] = (str[i] - 'a') ^ x;
        auto t = Convolution(v, v);
        FL(i, 0, (n - 1) * 2) a[i] += (int)round(t[i]);
    };
    C(0), C(1);
    FL(i, 0, (n - 1) * 2){
        ans = (ans + pw[(a[i] + 1) >> 1] - 1) % p;
    }
    printf("%lld\n", ((ans - Manacher(str)) % p + p) % p);
    return 0;
}
```


---

## 作者：Rubyonly (赞：1)

## 思路

我们设对于一个中心 $mid$，其左右有 $x$ 个能够匹配的字符对（当这个中心是一个字符时，也包括这个字符），那么这个中心所作的贡献就是 $2^x-1$，即这 $x$ 个字符对分别选不选，再减去一个不选的情况。

---

然后，考虑怎么求对于每个位置的 $x$？

暴力很好想，直接 $\Theta(n)$ 扫一遍，统计一下。

我们看一下进行多项式乘法时的操作：

![](https://images.cnblogs.com/cnblogs_com/Rubyonly233/1900929/o_201215093816ll.png)

$$a_0\times b_2,a_1\times b_1,a_2\times b_0$$

如果将这两个多项式看成我们原来的字符串，最后我们通过一些计算出来的 $c_2$ 不就是以第2个字符为中心的 $x$ 吗。

但是，怎么进行计算呢？

我们发现题目中还有一个很特殊的性质：

* 字符串中只包含a、b两个字符。

不妨将a、b两个字符分别换成1、0。

利用 $1\times 1= 1, 1\times 0 = 0 \times 1 = 0 \times 0 = 0$ 的性质，我们可以将两边都是a匹配和两边都是b匹配的贡献分开来求。

所以，我们只需将字符串转化成 $a=1,b=0$ 和 $a=0,b=1$ 的多项式，分别自乘即可。

---

但是题目中还有一个限制，不能够是连续的回文串，所以最后只需跑一遍 $manacher$，减去即可。

## 代码

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <cmath>

typedef long long ll;

using namespace std;

const int maxn = 4e5 + 50, INF = 0x3f3f3f3f, mod = 1e9 + 7;
const double pi = acos (- 1.0);

inline int read () {
	register int x = 0, w = 1;
	register char ch = getchar ();
	for (; ch < '0' || ch > '9'; ch = getchar ()) if (ch == '-') w = -1;
	for (; ch >= '0' && ch <= '9'; ch = getchar ()) x = x * 10 + ch - '0';
	return x * w;
}

inline void write (register int x) {
	if (x / 10) write (x / 10);
	putchar (x % 10 + '0');
}

char str[maxn], tmp[maxn];
int n, ans, bit, len = 1, rev[maxn];
int p[maxn], base[maxn];

struct Complex {
	double x, y;
	Complex () { x = y = 0; }
	Complex (register double a, register double b) { x = a, y = b; }
	inline Complex operator + (const Complex &a) const { return Complex (x + a.x, y + a.y); }
	inline Complex operator - (const Complex &a) const { return Complex (x - a.x, y - a.y); }
	inline Complex operator * (const Complex &a) const { return Complex (x * a.y + y * a.x, y * a.y - x * a.x); }
} a[maxn], b[maxn];

inline void FFT (register int len, register Complex * a, register int opt) {
	for (register int i = 0; i < len; i ++) if (i < rev[i]) swap (a[i], a[rev[i]]);
	for (register int d = 1; d < len; d <<= 1) {
		register Complex w1 = Complex (opt * sin (pi / d), cos (pi / d));
		for (register int i = 0; i < len; i += d << 1) {
			register Complex w = Complex (0, 1);
			for (register int j = 0; j < d; j ++, w = w * w1) {
				register Complex x = a[i + j], y = w * a[i + j + d];
				a[i + j] = x + y, a[i + j + d] = x - y;
			}
		}
	}
}

inline void Init () {
	base[0] = 1;
	for (register int i = 1; i <= 5e4; i ++) base[i] = 2ll * base[i - 1] % mod;
}

inline void manacher () {
	n >>= 1, tmp[0] = '$', tmp[1] = '#';
	for (register int i = 0; i <= n; i ++) tmp[i * 2 + 2] = str[i], tmp[i * 2 + 3] = '#';
	n = 2 * n + 3;
	register int center = -1, R = -1;
	for (register int i = 0; i <= n; i ++) {
		if (R > i) p[i] = min (p[2 * center - i], R - i);
		else p[i] = 1;
		while (tmp[i - p[i]] == tmp[i + p[i]]) p[i] ++;
		if (p[i] + i > R) R = p[i] + i, center = i;
	}
	for (register int i = 2; i <= n; i ++) ans = ((ans - (p[i] >> 1)) % mod + mod) % mod;
}

int main () {
	scanf ("%s", str), n = strlen (str) - 1, Init ();
	for (register int i = 0; i <= n; i ++) a[i].y = str[i] == 'a';
	for (register int i = 0; i <= n; i ++) b[i].y = str[i] == 'b';
	while (len <= n << 1) len <<= 1, bit ++;
	for (register int i = 1; i < len; i ++) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << bit - 1);
	FFT (len, a, 1), FFT (len, b, 1), n <<= 1;
	for (register int i = 0; i < len; i ++) a[i] = a[i] * a[i], b[i] = b[i] * b[i];
	FFT (len, a, -1), FFT (len, b, -1);
	for (register int i = 0; i <= n; i ++) a[i].y = (int) (0.5 + a[i].y / len), b[i].y = (int) (0.5 + b[i].y / len);
	for (register int i = 0; i <= n; i ++) ans = (ans + base[(int) (a[i].y / 2 + b[i].y / 2 + (i % 2 == 0))] - 1) % mod;
	manacher (), printf ("%d\n", ans);
	return 0;
}
```

---

## 作者：devout (赞：1)

我们可以把问题转化成关于“某一位置对称的子序列数”-“回文子串数”

对于第二问，就是一个马拉车，这里不再过多赘述

考虑对于`a`和`b`分开处理

我们构造一个多项式

$$F(x)=\sum_{i=0}^{|s|-1}a_ix^i$$

其中$a_i=[s_i==$`a`$]$

那么我们考虑$F^2(x)$的$x^i$项的系数其实就是关于$\frac{i}{2}$位置对称字符对的个数

考虑如果关于某个位置对称的字符对的个数是$x$，那么我们在这一位的贡献显然是$2^x-1$

考虑$x$的计算，当对称轴在某一个字符的位置上时，我们发现左右的部分每一对会对系数造成$2$的贡献，但是对称轴上的字符只会造成$1$的贡献，因此这里需要单独判断

对于`b`的情况，同样处理就可以了

多项式乘法可以用$\text{FFT/NTT}$来优化

Q：取模怎么FFT呢？

A：我们发现最后的系数一定是很小的，取模只是在求$2^x-1$的时候需要取得，所以这道题也可以写FFT

```cpp
#include <bits/stdc++.h>
using namespace std;

# define Rep(i,a,b) for(int i=a;i<=b;i++)
# define _Rep(i,a,b) for(int i=a;i>=b;i--)
# define RepG(i,u) for(int i=head[u];~i;i=e[i].next)

typedef long long ll;

const int N=5e5+5;
const double pi=acos(-1.0);
const int mod=1e9+7;

template<typename T> void read(T &x){
   x=0;int f=1;
   char c=getchar();
   for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
   for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+c-'0';
    x*=f;
}

int n;
char s[N],t[N];
int pos[N],sum[N];
int hw[N];
int ans;

struct cp{
	double real,imag;
	cp(double a=0.0,double b=0.0){real=a,imag=b;}	
}a[N],c[N];

cp operator + (cp a,cp b){return cp(a.real+b.real,a.imag+b.imag);}
cp operator - (cp a,cp b){return cp(a.real-b.real,a.imag-b.imag);}
cp operator * (cp a,cp b){return cp(a.real*b.real-a.imag*b.imag,a.real*b.imag+a.imag*b.real);}

int Qpow(int base,int ind){
	int res=1;
	while(ind){
		if(ind&1)res=1ll*res*base%mod;
		base=1ll*base*base%mod;
		ind>>=1;
	}
	return res;
}

void fft(int limit,cp *a,int opt){
	for(int i=0;i<limit;i++)c[i]=a[pos[i]];
	for(int i=0;i<limit;i++)a[i]=c[i];
	for(int i=1;i<limit;i<<=1){
		int len=i<<1;
		cp z0(cos(pi/i),opt*sin(pi/i));
		for(int j=0;j<limit;j+=len){
			cp z(1.0,0.0);
			for(int k=0;k<i;k++,z=z*z0){
				cp x=a[j+k],y=z*a[j+k+i];
				c[j+k]=x+y;
				c[j+k+i]=x-y;
			}
		}
		for(int j=0;j<limit;j++)a[j]=c[j];
	}
}

void manacher(){
	int maxright=0,mid;
	Rep(i,1,n){
		if(i<maxright)hw[i]=min(hw[(mid<<1)-i],mid+hw[mid]-i);
		else hw[i]=1;
		for(;t[i-hw[i]]==t[i+hw[i]];hw[i]++);
		if(hw[i]+i>maxright){
			maxright=hw[i]+i;
			mid=i;	
		}
	}
}

int main()
{
	scanf("%s",s);
	n=strlen(s);
	int limit=1;
	while(limit<=2*n)limit<<=1;
	for(int i=1;i<limit;i<<=1)for(int j=0;j<i;j++)pos[i+j]=pos[j]+limit/i/2;
	
	for(int i=0;i<limit;i++)a[i]=cp(s[i]=='a'?1.0:0.0,0.0);
	fft(limit,a,1);
	for(int i=0;i<limit;i++)a[i]=a[i]*a[i];
	fft(limit,a,-1);
	for(int i=0;i<limit;i++)sum[i]+=(int)(a[i].real/limit+0.5);
	
	for(int i=0;i<limit;i++)a[i]=cp(s[i]=='b'?1.0:0.0,0.0);
	fft(limit,a,1);
	for(int i=0;i<limit;i++)a[i]=a[i]*a[i];
	fft(limit,a,-1);
	for(int i=0;i<limit;i++)sum[i]+=(int)(a[i].real/limit+0.5);
	
	for(int i=0;i<limit;i++)if(sum[i]&1)sum[i]++;
	for(int i=0;i<limit;i++)sum[i]>>=1;
	for(int i=0;i<2*n;i++)ans+=Qpow(2,sum[i])-1,ans%=mod;
	
	int tot=0;
	t[0]='#';
	for(int i=0;i<n;i++){
		t[++tot]='#';
		t[++tot]=s[i];	
	}
	t[++tot]='#';
	n=tot;
	manacher();
	
	Rep(i,1,n)if(hw[i]>1)ans=(ans-(((hw[i]-2)>>1)+1)+mod)%mod;
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：Ryan_ (赞：1)

不连续的回文串数量=所有的回文序列数量-连续的回文子串

连续的回文子串：

manacher 得到的以i为中心的连续回文串数量=以i为中心的最长回文半径长度

所有的回文序列：

将a看做1，b看做0，自己跟自己做一遍fft

得到的a[i]就是以i/2为中心的由a构成的最长回文序列长度

将a看做0，b看做1，自己跟自己做一遍fft

得到的b[i]就是以i/2为中心的由b构成的最长回文序列长度

因为可以不连续，所以每一对以i为中心的对称位置要么同时选，要么同时不选

所以以i为中心的回文序列数量=2^（f[i]/2  [上取整]）-1


```
#include<cmath>
#include<cstdio>
#include<cstring>
#include<algorithm>

using namespace std;

const int N=(1<<18)+2;

const double pi=acos(-1);

const int mod=1e9+7;

char s[N];
int n;

struct Complex
{
    double x,y;
    Complex(double x_=0,double y_=0):x(x_),y(y_){}
    Complex operator + (Complex P)
    {
        return Complex(x+P.x,y+P.y);
    }
    Complex operator - (Complex P)
    {
        return Complex(x-P.x,y-P.y);
    }
    Complex operator * (Complex P)
    {
        return Complex(x*P.x-y*P.y,x*P.y+y*P.x);
    }
};
typedef Complex E;

E a[N],b[N];
int rev[N];
int f[N];

char t[N];
int p[N];

int Pow(int a,int b)
{
    int res=1;
    for(;b;b>>=1,a=1LL*a*a%mod)
        if(b&1) res=1LL*res*a%mod;
    return res;
}

void fft(E *a,int len,int tag)
{
    for(int i=0;i<len;++i)
        if(i<rev[i]) swap(a[i],a[rev[i]]);
    for(int i=1;i<len;i<<=1)
    {
        E wn(cos(pi/i),tag*sin(pi/i));
        for(int p=i<<1,j=0;j<len;j+=p)
        {
            E w(1,0);
            for(int k=0;k<i;++k,w=w*wn)
            {
                E x=a[j+k],y=a[j+k+i]*w;
                a[j+k]=x+y; a[j+k+i]=x-y;
            }
        }
    }
    if(tag==-1)
    {
        for(int i=0;i<len;++i) a[i].x=(a[i].x+0.5)/len;
    }
}

int solve_all()
{
    for(int i=0;i<n;++i) 
        if(s[i]=='a') a[i].x+=1; else b[i].x=1;
    int num=n*2-1,len=1,bit=0;
    while(len<num) len<<=1,bit++;
    for(int i=0;i<len;++i) rev[i]=(rev[i>>1]>>1)|((i&1)<<bit-1);
    fft(a,len,1); 
    for(int i=0;i<len;++i) a[i]=a[i]*a[i];
    fft(a,len,-1);
    fft(b,len,1);
    for(int i=0;i<len;++i) b[i]=b[i]*b[i];
    fft(b,len,-1);
    for(int i=0;i<len;++i) f[i]=a[i].x+b[i].x;
    int sum=0;
    for(int i=0;i<len;++i) 
    {
        sum+=Pow(2,f[i]+1>>1)-1;
        sum-=sum>=mod ? mod : 0;
    }
    return sum;
}

void manacher(int m)
{
    int id=0,pos=0,x=0;
    for(int i=1;i<=m;++i)
    {
        if(pos>i) x=min(p[id*2-i],pos-i);
        else x=1;
        while(t[i-x]==t[i+x]) x++;
        if(i+x>pos) pos=i+x,id=i;
        p[i]=x;
    }
}

int solve_continuous()
{
    int m=0;
    t[m]='!';
    for(int i=0;i<n;++i)
    {
        t[++m]='#';
        t[++m]=s[i];
    }
    t[++m]='#';
    t[m+1]='@';
    manacher(m);
    int sum=0;
    for(int i=1;i<=m;++i)
    {
        sum+=p[i]>>1;
        sum-=sum>=mod ? mod : 0;
    }
    return sum;
}

int main()
{
    scanf("%s",s);
    n=strlen(s);
    int t1=solve_all();
    int t2=solve_continuous();
    printf("%d",(t1-t2+mod)%mod);
}
```


---

## 作者：trsins (赞：0)

- $\text{P4199}$ 万径人踪灭

   - 算法：$\text{FFT,manacher}$
   
### 题目：

在一个只包含 $a,b$ 的字符串中选择一个序列，使得

1. 位置和字符都关于某条对称轴对称。

2. 不能是连续的一段。

求有多少个满足要求的序列，答案对 $1e9+7$ 取模。

$n\le 10^5$

### 题解：

upd：修改了部分内容。

首先枚举对称轴，假设我们以 $k$ 为对称轴。

设 $p_k$ 为满足 $i<j,a_i=a_j$ 并且 $i,j$ 关于 $k$ 对称的 $(i,j)$ 的个数。

那么对于这 $p_k$ 个 $(i,j)$，$a_i$ 与 $a_j$ 要么同时选（因为对称所以必定满足），要么同时不选，共 $2^{p_k}$ 种方案。扣掉空集，共 $2^{p_k}-1$ 种。

$$\therefore ans=\sum\limits_{k=0}^{n}2^{p_k}-1$$

注意一下这里 $k$ 可以为 $\dfrac{t}{2}(t\in \mathbb{N})$，因为对称轴可以为两个字符中间（比如 $1,8$ 就关于 $4.5$ 对称，也就是 $4,5$ 的中间对称）

这里有个关于位置对称的性质：

>$i,j$ 关于 $p$ 对称当且仅当 $i+j=2x$。

我们可以根据这个转移。

现在位置对称了，还要满足字符对称。

记字符 $a$ 为 $1$，字符 $b$ 为 $0$。

那么可以发现当两字符相等时仅可能为 $1+1=2(aa)$ 或 $0+0=0(bb)$。而对于 $1+0=1(ab)$ 的情况则需要排除。

由于 $aa$ 和 $bb$ 的情况的数值中间相差了 $ab$，难以判断是否对称。

这里有个很好用的东西：平方。

平方可以消去数值的负号。

所以我们可以将 $aa,bb,ab$ 所代表的数值各消去 $1$ ，那么变为 $1,-1,0$；此时再将它们都平方，那么对称的即变为 $1$，不对称的还是 $0$，很好地满足了我们的要求。


$$\therefore p_{k}=\sum\limits_{i+j=2k}(a_i+a_j-1)^2$$


非常显然的卷积，$\text{FFT}$ 一卷即可。

但题目中还说“位置不能连续”，说明要扣掉连续的回文子串的个数。

对于回文的对称的子串显然，用 manacher 一弄就好了。


---

## 作者：Demoe (赞：0)

### [题目传送门](https://www.luogu.com.cn/problem/P4199)

## 题意简述

- 给定只包含 $\texttt{a b}$ 两种字符的字符串。

- 求有多少个**子序列**满足字母和坐标都关于某点对称，且**不是子串**。 

## SOL

$n \le 1e5$ 那就差不多是 $O(nlogn)$ 了qwq。

去除回文子串可以直接 $\mathcal{manacher}$ 。

```cpp
void manacher(){
	ll maxn=-1,id,mm=0;
	for(ll i=1;i<=(n<<1)+1;i++){
		if(i>=mm) p[i]=1;
		else p[i]=min(p[2*id-i],mm-i);
		while(x[i-p[i]]==x[i+p[i]]) p[i]++;
		if(mm<i+p[i]) mm=p[i]+i,id=i;
	}
}
```

那我们就解决了部分了qwq。

接下来我们只需解决回文**子序列**啦qwq。

那么我们考虑对于**每个位置**对称的子序列。

对于 $str_i$ ，若有 $a_i$ 个 $str_{i-j}=str_{i+j}(1 \le j < i)$ ，则对答案贡献有 $2^{a_i+1}-1$。

这个就很好解释qwq。（反正你们都会下面就简单点qaq）

包括 $str_i$ ， 共有 $a_i+1$ 个可选项。

每个有选或不选**两种状态**，则共 $2^{a_i+1}$ 种状态。

**不可全不选**，那么就是 $2^{a_i+1}-1$ 啦qwq。

那么我们只需快速处理 $str_{i-j}=str_{i+j}(1 \le j < i)$ 啦。

这个可看出能**多项式**搞定qwq。

我们建两个多项式 $F$ $G$。

对 $F$ ，对第 $i$ 位若 $str_i=\texttt{a}$ ，系数为 $1$ ，否则为 $0$。

对 $G$ ，对第 $i$ 位若 $str_i=\texttt{b}$ ，系数为 $1$ ，否则为 $0$。

$F$ $G$ 自乘，则可得到新多项式每项系数qwq。

我们把两项加起来。

对新系数 $b_i$ ，意义为对 $str_{\frac{i}{2}}$ 位，有 $b_i$ 组关于其对称（当然，**包括了自己**qwq）。

但 $\dfrac{i}{2}$ 不一定为整数，那我们就对奇偶处理下即可qwq。

最后手打快速幂即可qwq。

```cpp
/*
***
还要继续努力
成为一名烤咕学家哦
***
*/
#include<bits/stdc++.h>
#define pi 3.141592653589793
using namespace std;
typedef long long ll;
const ll N=4e5+5,mod=1e9+7;
ll n,m,rev[N],t,lim=1,l=-1,s[N],ans[N],x[N],p[N],sum;
char str[N];
struct pol{
	double x,y;
	pol(double x=0,double y=0):x(x),y(y){}
	inline pol operator + (const pol b) const{return pol(x+b.x,y+b.y);}
	inline pol operator - (const pol b) const{return pol(x-b.x,y-b.y);}
	inline pol operator * (const pol b) const{
		pol res;
		res.x=x*b.x-y*b.y;
		res.y=x*b.y+y*b.x;
		return res;
	}
}F[N],G[N];
template <typename T> void rd(T &x){
	ll fl=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') fl=-fl;
	for(;isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+c-'0';
	x*=fl;
}
void wr(ll x){
	if(x<0) x=-x,putchar('-');
	if(x<10) putchar(x+'0');
	if(x>9) wr(x/10),putchar(x%10+'0');
}
inline void FFT(pol *a,ll op,ll lim){
	for(ll i=1;i<=lim;i++){
		if(i>=rev[i]) continue;
		swap(a[i],a[rev[i]]);
	}
	pol rt,w,x,y;
	for(ll mid=1;mid<lim;mid<<=1){
		ll r=mid<<1;
		rt=pol(cos(pi/mid),op*sin(pi/mid));
		for(ll j=0;j<lim;j+=r){
			w=pol(1,0);
			for(ll k=0;k<mid;k++){
				x=a[j|k];y=w*a[j|k|mid];
				a[j|k]=x+y;a[j|k|mid]=x-y;
				w=w*rt;
			}
		}
	}
	if(op==1) return;
	for(ll i=0;i<=lim;i++) a[i].x=a[i].x/lim,a[i].y=a[i].y/lim;
}
void manacher(){
	ll maxn=-1,id,mm=0;
	for(ll i=1;i<=(n<<1)+1;i++){
		if(i>=mm) p[i]=1;
		else p[i]=min(p[2*id-i],mm-i);
		while(x[i-p[i]]==x[i+p[i]]) p[i]++;
		if(mm<i+p[i]) mm=p[i]+i,id=i;
	}
}
ll pw(ll x,ll y){
	ll sum=1;
	while(y){
		if(y&1) sum=sum*x%mod;
		x=x*x%mod;y>>=1;
	}
	return sum%mod;
}
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	scanf("%s",str);n=strlen(str);
	for(ll i=0;i<n;i++) s[i+1]=(str[i]=='a');
	for(ll i=1;i<=(n<<1)+1;i++)
		if(i&1) x[i]=2;
		else x[i]=s[i>>1];
	x[0]=-1,x[(n+1)<<1]=-2;
	while(lim<=(n<<1)) lim<<=1,l++;
	for(ll i=1;i<=lim;i++) rev[i]=(rev[i>>1]>>1)|((i&1)<<l);
	for(ll i=1;i<=n;i++) F[i].x=F[i].y=s[i],G[i].x=G[i].y=(s[i]^1);
	FFT(F,1,lim);FFT(G,1,lim);
	for(ll i=0;i<=lim;i++) F[i]=F[i]*F[i],G[i]=G[i]*G[i];
	FFT(F,-1,lim);FFT(G,-1,lim);
	for(ll i=1;i<=(n<<1)+1;i++) ans[i]+=((ll)(F[i].y/2+0.5)-((i&1)^1))+((ll)(G[i].y/2+0.5)-((i&1)^1));
	for(ll i=1;i<=(n<<1)+1;i++) ans[i]=((ans[i]+((i&1)^1))>>1)+((i&1)^1);
	for(ll i=1;i<=(n<<1)+1;i++) ans[i]=(pw(2,ans[i])+mod-1)%mod;
	manacher();
	for(ll i=1;i<=(n<<1)+1;i++) ans[i]=(ans[i]-(p[i]>>1))%mod;
	for(ll i=1;i<=(n<<1)+1;i++) sum=(sum+ans[i])%mod;
	wr(sum);puts("");
	return 0;
}
```

$\mathcal{manacher}$ 时间复杂度 $O(n)$ 空间复杂度 $O(n)$ ~~线性好评~~

$\mathcal{FFT}$ 时间复杂度 $O(nlogn)$ 空间复杂度 $O(n)$

总时间复杂度 $O(nlogn)$ 空间复杂度 $O(n)$

宁切了qwq

---


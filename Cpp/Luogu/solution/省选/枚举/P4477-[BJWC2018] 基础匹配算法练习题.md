# [BJWC2018] 基础匹配算法练习题

## 题目描述

小 S 最近学会了二分图匈牙利匹配算法。

现在二分图的 X 部有 $N$ 个数字 $A_i$，Y 部有 $K$ 个数字 $C_i$。

已知如果 $A_i + C_j \le  Z$，那么 $A_i$ 和 $C_j$ 之间就有一条边，求二分图（X，E，Y）的最大匹配数。

小 S 是初学者，所以她想做多做一些练习来巩固知识。于是她找到了一个长度为 $M$ 的正整数数组 $B$，每次她会在 $B$ 数组中抽取一段连续的区间 $[L_i,R_i]$，把区间 $[L_i,R_i]$ 的所有数字作为二分图 Y 部的 $K$ 个数字 $C_i$，然后重新求一次二分图最大匹配数。

小 S 打算一共做 $Q$ 次练习，但是她不知道每次计算出的答案对不对，你能帮帮她吗？

## 说明/提示

测试数据编号|$N$|$M$|$Q$
:-:|:-:|:-:|:-:
$1 \sim 4$|$\le 50$|$\le 50$|$\le 50$
$5 \sim 10$|$\le 2501$|$\le 2501$|$\le 2501$
$11\sim 14$|$\le 152501$|$\le 45678$|$\le 45678$
$15 ,16$|$\le 152501$|$\le 50$|$\le 52501$
$17 \sim 20$|$\le 152501$|$\le 52501$|$\le 52501$

对于 $100\%$ 的数据，$1 \le A_i,B_i,Z \le 10^9$，$1 \le L_i \le R_i \le Q$。

保证数据有一定梯度。

## 样例 #1

### 输入

```
4 10 8
1 2 4 6
6 3 6 2 8 4 9 10 6 8
4
1 4
2 5
5 6
1 6```

### 输出

```
4
3
1
4```

# 题解

## 作者：D_F_S (赞：9)

	一篇使用 莫队+单点修改线段树 解决的题解
    
## Solution：

因为是多次区间询问，考虑使用莫队。

又因为是匹配，只与权值有关，不妨先将 $A$ 排序。

对于 $B_i$，它所能匹配到的数构成 $A$ 的一个前缀。只要这个前缀中还有一个数未匹配，就可将它与 $B_i$ 匹配。

这样就有了一个莫队增删时用线段树维护最大匹配数量的思路：

线段树以 $1\sim N$ 为下标，区间内维护三个信息：$size$、$sum$、$ans$ 分别表示 区间大小、区间内数的数量，区间内最大匹配数量。

当 $C$ 中新增一个数 $B_i$ 时，用二分找出它能匹配到的最大 $A_i$ 的位置，如果当前位置还未被匹配（即 $ans=0$），则当前位置 $sum$ 与 $ans$ 都 $+1$，否则只有 $sum+1$。删数时的操作类似，当 $sum$ 减至 $0$ 时 $ans-1$。

关于区间合并，$sum$ 直接相加即可，而对于 $ans$，首先也将左右区间的 $ans$ 相加，然需考虑右区间的 $B$ 与左区间的 $A$ 匹配，贡献为 $min(\text{左区间剩余 }A \text{ 的个数},\text{右区间多余 }B \text{ 的个数})$。

对于每个 $B_i$，我们都能保证它与所对应的 $A$ 的前缀中的每个数尝试了匹配，且会优先与最靠近限度的数匹配，因此能保证匹配数最大。

至此，便可统计出最大匹配数，时间复杂度为 $O(M\sqrt{M}\log n)$。


## Code:
```cpp
#include<bits/stdc++.h>
#define inl inline
#define L (p<<1)
#define R (L|1)
#define mid ((l+r)>>1)
using namespace std;
const int N=152505,M=52505;
struct node {int l,r,id; }as[M];
struct node1 {int si,su,an; }tr[N*4];	// 区间大小，区间内所有数的数量，区间内匹配上的数的数量 
int n,m,sqm,Z,Q,ans[M],a[N],b[M],bl[M];
inl bool operator <(node a,node b)
{
	if(bl[a.l]!=bl[b.l]) return a.l<b.l;
	return (bl[a.l]&1)?a.r>b.r:a.r<b.r;		// 奇偶优化 
}
inl int Read()
{
	int s=0; char c;
	while(!isdigit(c=getchar()));
	for(;isdigit(c);c=getchar()) s=s*10+c-'0'; return s;
}
inl void Write(int x)
{
	int cnt=0,s[10]; do s[++cnt]=x%10; while(x/=10);
	while(cnt--) putchar(s[cnt+1]+'0');
}
inl void Pushup(int p)
{
	tr[p].su=tr[L].su+tr[R].su;
	tr[p].an=tr[L].an+tr[R].an;
	tr[p].an+=min(max(tr[L].si-tr[L].an,0),tr[R].su-tr[R].an);
		// max(tr[L].si-tr[L].an,0) 为左区间剩余个数，tr[R].su-tr[R].an 为右区间多余个数 
}
inl void Build(int p,int l,int r)
{
	tr[p].si=r-l+1; if(l==r) return;
	Build(L,l,mid); Build(R,mid+1,r);
}
inl void Modify(int p,int l,int r,int va,int fl)
{
	if(l==r)
	{
		if(Z-va<a[l]) return;	// 无法匹配，此时 l=r=1
		if(tr[p].su==0) tr[p].an=1;
		tr[p].su+=fl;
		if(tr[p].su==0) tr[p].an=0;
		return;
	}
	Z-va<a[mid+1]?Modify(L,l,mid,va,fl):Modify(R,mid+1,r,va,fl);
	Pushup(p);
}
int main()
{
	n=Read(); m=Read(); Z=Read(); sqm=sqrt(m);
	for(int i=1;i<=n;++i) a[i]=Read();
	for(int i=1;i<=m;++i) b[i]=Read(), bl[i]=i/sqm;
	sort(a+1,a+n+1); Build(1,1,n);
	
	Q=Read();
	for(int i=1;i<=Q;++i) as[i]=(node){Read(),Read(),i};
	sort(as+1,as+Q+1);
	for(int i=1,l=1,r=0;i<=Q;++i)
	{
		while(l>as[i].l) Modify(1,1,n,b[--l],1);
		while(r<as[i].r) Modify(1,1,n,b[++r],1);
		while(l<as[i].l) Modify(1,1,n,b[l++],-1);
		while(r>as[i].r) Modify(1,1,n,b[r--],-1);
		ans[as[i].id]=tr[1].an;
	}
	for(int i=1;i<=Q;++i) Write(ans[i]), putchar('\n');
	return 0;
}
```


---

## 作者：xkai (赞：9)

## 主要算法

回滚莫队+并查集按秩合并。

## 做法

首先对 $a$ 排序，然后求出数组 $bb$ ， $bb_{i}$ 表示 $b_{i}$ 能匹配的最大的 $a$ 中的数的下标。

题目要求匹配数最多，我们不难得出一个基于贪心的做法：对于 $b$ 中的每个数，在 $a$ 中没有被选择的数里面选择一个能够匹配的并且下标最大的数进行匹配。

对于寻找匹配的过程，我们可以使用并查集实现。如果 $a_{i}$ 被选择过，就合并 $a_{i}$ 与 $a_{i-1}$ 所在的集合。这样对于 $b_{i}$ ，它的匹配就是 $bb_{i}$ 所在集合中的最小数（如果无法匹配则结果是 $0$ ）。

然后因为询问有多组，可以套上一个莫队。因为并查集无法进行删除操作，但可以支持撤销，所以用按秩合并的并查集和回滚莫队。

复杂度 $O(m \sqrt{m} \log m)$ ，因为并查集常数小，实际上跑得飞快。

https://www.luogu.com.cn/record/67866628 （吸了氧后最慢的点也就 $200ms$ ）

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=160000,M=60000;
int n,m,z,q,sqn,bl[N];
int a[N],b[N],bb[N],ans[M];
struct Ques{
	int l,r,ind;
}qs[M];
bool cmp(const Ques&x,const Ques&y){
	if(bl[x.l]^bl[y.l])return x.l<y.l;
	return x.r<y.r;
}
int fa[N],siz[N],LL[N],oldLL[N];
int stk[N],top;
int get(int x){
	return fa[x]>-1?get(fa[x]):x;
}
void merge(int x,int y){
	int r1=get(x),r2=get(y);
	if(r1!=r2){
		if(siz[r1]>siz[r2])swap(r1,r2);
		fa[r1]=r2,siz[r2]+=siz[r1];
		oldLL[r1]=LL[r2];LL[r2]=min(LL[r2],LL[r1]);
		stk[++top]=r1;
	}
}
void go_back(int x){
	while(top>x){
		siz[fa[stk[top]]]-=siz[stk[top]];
		LL[fa[stk[top]]]=oldLL[stk[top]];
		fa[stk[top--]]=-1;
	}
}
int solve(int l,int r){
	int res=0;
	for(int i=l;i<=r;i++)
		if(bb[i]){
			int lst=get(bb[i]);
			if(LL[lst]){
				merge(lst,LL[lst]-1);
				res++;
			}
		}
	return res;
}
inline int read()
{
	int f=1,x=0;
	char c=getchar();
	while(c<'0'||c>'9')c=='-'?f=-f,c=getchar():c=getchar();
	while(c>='0'&&c<='9')x=x*10+(c^48),c=getchar();
	return x*f;
}
int main(){
	n=read(),m=read(),z=read();sqn=sqrt(m);
	for(int i=1;i<=n;i++)a[i]=read();
	for(int i=1;i<=m;i++)b[i]=read();
	sort(a+1,a+1+n);
	for(int i=1;i<=m;i++){
		bb[i]=upper_bound(a+1,a+1+n,z-b[i])-a-1;
		bl[i]=(i-1)/sqn+1;
	}
	q=read();
	for(int i=1;i<=q;i++)qs[i].l=read(),qs[i].r=read(),qs[i].ind=i;
	sort(qs+1,qs+1+q,cmp);
	for(int i=0;i<=n;i++)siz[i]=1,fa[i]=-1,LL[i]=i;
	for(int i=1;i<=q;){
		while(i<=q&&bl[qs[i].l]==bl[qs[i].r]){
			ans[qs[i].ind]=solve(qs[i].l,qs[i].r);
			go_back(0);
			++i;
		}
		if(i>q)break;
		int num=bl[qs[i].l],l=sqn*num+1,r=l-1,res=0;
		while(bl[qs[i].l]==num){
			res+=solve(r+1,qs[i].r);r=qs[i].r;
			int nowtop=top;
			int tmp=solve(qs[i].l,l-1);go_back(nowtop);
			ans[qs[i].ind]=res+tmp;
			++i;
		}
		go_back(0);
	}
	for(int i=1;i<=q;i++)printf("%d\n",ans[i]);
}
```


---

## 作者：foryou_ (赞：2)

只有询问无修改，于是考虑莫队维护 $b_i$。

容易发现对于每个 $b_i$，它可以匹配的 $a_i$ 总是一个从 $1$ 开始的连续区间。采用贪心的思想，我们对于每个 $b_i$，我们尽量选择最大的那个 $a_i$，称其为它的「最佳位置」。

对于这种连续区间，我们考虑使用线段树维护之。维护三个信息：

- 答案 $ans$；

- $a_i$ 区间大小 $asiz$；

- 匹配成功的 $b_i$ 区间大小 $bsiz$。

具体而言：

- 增加：尽可能地向右子树寻找 $a_i$ 以使得 $a_i$ 最大化，若最后匹配得了且是「最佳位置」，那么令 $ans+1$，$bsiz+1$；

- 删除：最后若 $b_i$ 先前有匹配，则令 $ans-1$，$bsiz-1$。

`pushup` 时：

- $bsiz$ 可以直接加；

- $ans$ 不仅要加上左右子树，还有可能右子树闲置的 $b_i$ 与左子树闲置的 $a_i$ 进行匹配。

综上，本题是莫队与线段树的结合，其中莫队为整体框架，线段树处理寻找匹配与计算贡献的问题，并且让我们学会了只有询问考虑莫队、以及连续区间问题考虑线段树的技巧。时间复杂度 $O(Q \sqrt{m} \log n)$，[代码](https://www.luogu.com.cn/paste/h6eq8u0y)，需要快读。

---

## 作者：1saunoya (赞：2)

~~题目意思比较难描述，但是易懂…~~

我们考虑到这是一个匹配问题，转换一下。

由于题目说了是 $a_i + c_j \leq z$ ， $i$ 和 $j$ 有一条边，那么发现 $a_i$ 不变，我们就可以给 $a_i$ 排序，然后因为数值是有单调性的，如果 $a_i + c_j \leq z$ ，那么 $a_k(1 \leq k\leq i)+ c_j \leq z$。

那么我们想一个这个问题的转化: 给你 $n$ 个位置 $m$ 个物品，每个位置仅仅能放一个物品，第 $i$ 个物品有一个限制，只能放到 $[1,p_i]$ 里面，求最多能放多少个物品。

容易证明，如果用 **不基于排序** 的做法做出这个转化版问题，就可以带上莫队做出这个原问题。


我们想，假设你能放 $k$ 个物品，采用最优策略。

那么你 $p_i$ 一定是选前 $k$ 大的，依次放到 $1…k$。

第 $k$ 大的放在位置 $1$，那么显然 $p_k \geq 1$

第 $k-1$ 大的放在位置 $2$，那么 $p_{k-1}\geq 2$

……

第 $k + x - 1$ 大的物品放在位置 $x$ ，那么 $p_{k+x-1}\geq x$

也就是说 $p_x + x - 1 \geq k$

而 $x$ 指的是区间第 $x$ 大，就是有多少个数比他要大，而你可以通过线段树，对于每个 $p_i$ ，区间加 $[1,p_i]$

由于 $k$ 要满足所有条件，所以要取最小值。

[code](https://www.cnblogs.com/Isaunoya/p/12459233.html)

---

## 作者：xubaichuan (赞：1)

> ——欸？为什么我的 set 它 T 了 ？  
——试试线段树，超级简单的……

### 题解：P4477 [BJWC2018] 基础匹配算法练习题

前置知识：普通莫队、单点修改+单点查询线段树、二分 ~~（这个应该是人都会）~~。

题目给定一个长度为 $N$ 的序列 $A$ 和长度为 $M$ 的序列 $B$ 以及 $Q$ 个询问：求对于区间 $[L,R]$，点对 $(i,j)$ 满足 $i \in [1,N],j \in [L,R],A_i+B_j \le Z$ 的最大数量，其中 $Z$ 为给定常量，同一个 $i$ 只能出现一次，同一个 $j$ 也只能出现一次。

看到“区间”，就可以考虑使用莫队解决这道题，那么怎么实现 add 和 del 呢？可以想到将 $A$ 从小到大排序，二分地预处理 $mx_j$ 表示最大的 $i$ 使 $A_i+B_j \le Z$，并维护线段树 $suma$、$sumb$ 分别表示区间 $[l,r]$ 内未匹配的 $A$ 的数量和 $mx$ 值在区间 $[l,r]$ 内的未匹配的 $B$ 的数量。

对于加入的 $idx$，我们先检查 $mx_{idx}$ 是否已经被匹配，若其没被匹配，即 $suma[mx_{idx},mx_{idx}]=1$，贪心地将 $mx_{idx}$ 和 $idx$ 匹配，将 $suma[mx_{idx},mx_{idx}]$ 减 $1$ 变为 $0$；若其已匹配，即 $suma[mx_{idx},mx_{idx}]=0$，则将 $sumb[mx_{idx},mx_{idx}]$ 加 $1$。

对于删除 $idx$，我们先检查还有没有其它的 $k$ 满足 $mx_k = mx_{idx}$，若没有，即 $sumb[mx_{idx},mx_{idx}] = 0$，那么根据之前 $\textup{add}$ 中的贪心逻辑，$mx_{idx}$ 肯定和 $idx$ 匹配了，故应该将 $suma[mx_{idx},mx_{idx}]$ 加 $1$ 变为 $1$；若有，即 $sumb[mx_{idx},mx_{idx}] \neq 0$，直接将 $sumb[mx_{idx},mx_{idx}]$ 减 $1$ 即可（不论 $mx_{idx}$ 是否与 $idx$ 匹配，因为 $mx_{idx}$ 与 $idx$、$k$ 匹配是等价的）。

如何计算答案呢？——将 $suma$ 与 $sumb$ 合并。

很容易想到直接将 $suma[ls]$ 与 $suma[rs]$ 相加，$sumb[ls]$ 与 $sumb[rs]$ 相加，但这样做漏掉了一种可能：$ls$ 中的 $A$ 与 $rs$ 中的 $B$ 匹配！回顾之前的定义，$sumb$ 是 $mx$ 值在区间 $[l,r]$ 内的未匹配的 $B$ 的数量。既然 $i$ 的 $mx$ 值在 $rs$ 中，那么 $B_i$ 一定可以和 $rs$ 前的 $A$ 匹配，故它也可以和 $ls$ 中的 $A$ 匹配，而匹配的数量显然是 $\min\{suma[ls],sumb[rs]\}$。

最后，整个区间内的未匹配的 $B$ 的数量就是 $sumb[1]$，答案便是 $R-L+1-sumb[1]$。

不过，这个算法还有个坑，可能加入的 $idx$ 与任何一个 $A$ 都无法匹配，这种情况下，我们需要维护一个 $cnt$ 变量，用来表示这种情况的出现次数，每当 $B_{idx}+A_1>Z$ 时，将 $cnt$ 加 $1$。删除时同理，将加 $1$ 改为减 $1$ 即可。

That's all。接下来就是代码环节了：

```cpp
#include <bits/stdc++.h>

using namespace std;

const int MAX_N = 2e5 + 50;

int N, M, Z, Q, A[MAX_N], B[MAX_N];
int suma[MAX_N << 2], sumb[MAX_N << 2];

#define ls(cur) cur << 1
#define rs(cur) cur << 1 | 1

void pushup(int cur) {
	int tmp = min(suma[ls(cur)], sumb[rs(cur)]);
	suma[cur] = suma[ls(cur)] + suma[rs(cur)] - tmp;
	sumb[cur] = sumb[ls(cur)] + sumb[rs(cur)] - tmp;
}

void tree_add(int* tr, int cur, int l, int r, int idx, int val) {
	if (l == r) {
		tr[cur] += val;
		return ;
	}
	int mid = l + r >> 1;
	if (idx <= mid)
		tree_add(tr, ls(cur), l, mid, idx, val);
	else
		tree_add(tr, rs(cur), mid + 1, r, idx, val);
	pushup(cur);
}

int tree_query(int* tr, int cur, int l, int r, int idx) {
	if (l == r)
		return tr[cur];
	int mid = l + r >> 1;
	if (idx <= mid)
		return tree_query(tr, ls(cur), l, mid, idx);
	else
		return tree_query(tr, rs(cur), mid + 1, r, idx);
}

int pos[MAX_N], ans[MAX_N], mx[MAX_N], cnt;
struct Query {
	int l, r, id;
	bool operator < (const Query& q) const {
		if (pos[l] != pos[q.l])
			return pos[l] < pos[q.l];
		return (pos[l] & 1) ? r < q.r : r > q.r;
	}
} q[MAX_N];

void add(int idx) {
	if (B[idx] + A[1] > Z) {
		cnt++;
		return ;
	}
	if (tree_query(suma, 1, 1, N, mx[idx]) == 1)
		tree_add(suma, 1, 1, N, mx[idx], -1);
	else
		tree_add(sumb, 1, 1, N, mx[idx], 1);
}

void del(int idx) {
	if (B[idx] + A[1] > Z) {
		cnt--;
		return ;
	}
	if (tree_query(sumb, 1, 1, N, mx[idx]) == 0)
		tree_add(suma, 1, 1, N, mx[idx], 1);
	else
		tree_add(sumb, 1, 1, N, mx[idx], -1);
}

void mo_algo() {
	const int size = sqrt(M);
	for (int i = 1; i <= M; i++)
		pos[i] = i / size + 1;
	sort(q + 1, q + Q + 1);
	int l = 1, r = 0;
	for (int i = 1; i <= Q; i++) {
		int ql = q[i].l, qr = q[i].r;
		while (l > ql) add(--l);
		while (r < qr) add(++r);
		while (l < ql) del(l++);
		while (r > qr) del(r--);
		ans[q[i].id] = r - l + 1 - cnt - max(sumb[1], 0);
	}
}

int main() {
	cin >> N >> M >> Z;
	for (int i = 1; i <= N; i++) {
		cin >> A[i];
		tree_add(suma, 1, 1, N, i, 1);
	}
	sort(A + 1, A + N + 1);
	for (int i = 1; i <= M; i++) {
		cin >> B[i];
		mx[i] = upper_bound(A + 1, A + N + 1, Z - B[i]) - A - 1;
	}
	cin >> Q;
	for (int i = 1; i <= Q; i++) {
		q[i].id = i;
		cin >> q[i].l >> q[i].r;
	}
	mo_algo();
	for (int i = 1; i <= Q; i++)
		cout << ans[i] << '\n';
    return 0;
}
```

（好像什么都没讲，又好像什么都讲了，算了，就这样了……

---

## 作者：CQ_Bab (赞：1)

# 前言
我怎么不知道 set 没线段树快呀。
# 思路
我们先将 $a$ 序列排序然后我们发现一个数能匹配的位置一定是一个前缀所以考虑一个很简单的贪心每一个数如果能选一定选能匹配的区间中最靠后的一个没选的，因为有区间询问所以考虑莫队，发现对于加数很好处理但是删数不太好处理（因为要涉及到调整）那么考虑回滚莫队，我们发现只需要将莫队的加数沿用过来即可。

具体来说就是对于加入的一个数 $a_i$ 算出他能匹配的最远位置 $x$ 然后取 $1\sim x$ 中找出最后一个未被选的将 $a_i$ 与那个位置匹配即可，但是因为回滚莫队的左半边是暴力做的为了不影响右边的取值所以考虑先将右边匹配完然后再匹配左边的，注意在做完之后要将左边的撤回，这个东西用 set 不难做到，但是我们的 set 底层逻辑是平衡树所以常数巨大，然后你会发现将 set 改成线段树就过了（在暴力的地方不用改还是可以用 set）。
# 代码
细节看代码吧。
```cpp
#include <bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
#include <ext/rope>
using namespace __gnu_pbds;
using namespace std;
#define fs complex<double>
#define pi acos(-1)
#define pb push_back
#define rep(i,x,y) for(register int i=x;i<=y;++i)
#define rep1(i,x,y) for(register int i=x;i>=y;--i)
#define fire signed
#define il inline
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
template<class T> il void in(T &x) {
    x = 0; char ch = getchar();
    while (ch < '0' || ch > '9') {ch = getchar(); }
    while (ch >= '0' && ch <= '9') { x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar(); }
}
int T=1;
int n,m,z;
const int N=2e5+10;
int a[N],b[N];
int len;
multiset<int>s1;//值,剩的 
vector<pair<int,int>>v[N];
int arr[N],p[N],ans[N],res,pp[N];
#define bl(x) ((x-1)/len+1)
int ll[N];
struct node{
	int l,r;
	int cnt;
}tr[N<<2];
il void up(int x) {
	tr[x].cnt=tr[x<<1].cnt+tr[x<<1|1].cnt;
}
il void build(int u,int l,int r) {
	tr[u]={l,r};
	if(l==r) return;
	int mid=l+r>>1;
	build(u<<1,l,mid);
	build(u<<1|1,mid+1,r);
}
il void modify(int u,int x,int k) {
	if(tr[u].l==tr[u].r) {
		tr[u].cnt+=k;
		return;
	}
	int mid=tr[u].l+tr[u].r>>1;
	if(mid>=x) modify(u<<1,x,k);
	if(mid<x) modify(u<<1|1,x,k);
	up(u);
}
il int Ans(int u,int x) {
	if(tr[u].l>x) return -1;
	if(tr[u].cnt==tr[u].r-tr[u].l+1) return -1;
	if(tr[u].l==tr[u].r) return tr[u].l;
	int sum=Ans(u<<1|1,x);
	if(sum!=-1) return sum;
	return Ans(u<<1,x);
}
void solve() {
	in(n),in(m),in(z);
	int tot=0;
	rep(i,1,n) {
		int x;
		in(x);
		if(x<=z) {
			a[++tot]=x;
			arr[tot]=a[i];
		}
	}
	n=tot;
	len=sqrt(m);
	sort(arr+1,arr+1+n);
	int mm=unique(arr+1,arr+1+n)-arr-1;
	rep(i,1,n) a[i]=lower_bound(arr+1,arr+1+mm,a[i])-arr,s1.insert(a[i]);
	sort(a+1,a+1+n);
	rep(i,1,m) {
		in(b[i]);
		int k=z-b[i];
		p[i]=upper_bound(arr+1,arr+1+mm,k)-arr-1;
	}
	int qc;
	in(qc);
	rep(i,1,qc) {
		int l,r;
		in(l),in(r);;
		v[bl(l)].pb({r,i});
		ll[i]=l;
	}
	rep(i,1,bl(m)) sort(v[i].begin(),v[i].end());
	rep(i,1,bl(m)) {
		int R=min(m,i*len);
		res=0;
		vector<int>vv;
		build(1,1,n);
		rep(j,1,m) pp[j]=0;
		for(auto to:v[i]) {
			int r=to.first,id=to.second,l=ll[id];
			if(r-l+1<=len) {
				int res1=0;
				vector<int>pl;
				rep(j,l,r) {
					int kk=p[j];
					if(!s1.size()) {
						break;
					}
					auto it=s1.upper_bound(kk);
					if(it!=s1.begin()){
						it--;
						pp[j]=(*it);
						pl.pb(j);
						s1.erase(it);
						++res1;
					}
				}
				ans[id]=res1;
				for(auto to:pl) {
					s1.insert(pp[to]);
					pp[to]=0;
				}
			}else {
				while(R<r) {
					int x=R+1;
					R++;
					int rr=p[x];
					int kk=Ans(1,rr);
					if(~kk){
						modify(1,kk,1);
						pp[x]=kk;
						++res;
					}
				}
				int pl=0;
				vector<int>ve;
				rep(x,l,min(m,i*len)) {
					int rr=p[x];
					int kk=Ans(1,rr);
					if(~kk){
						ve.pb(x);
						modify(1,kk,1);
						pp[x]=kk;
						++pl;
					}
				}
				ans[id]=res+pl;
				for(auto tt:ve) modify(1,pp[tt],-1),pp[tt]=0;
			}
		}
	}
	rep(i,1,qc) printf("%d\n",ans[i]);
}
fire main() {
	while(T--) {
		solve();
	}
	return false;
}
```

---

## 作者：Super_Cube (赞：1)

# Solution

先回顾一下二分图最大匹配的求解方法。

考虑 ~~网络流~~ 匈牙利算法，是贪心的能多匹配一个就去匹配。

那么对于此题的每一个 $B_i$，我们希望找到最大的满足条件的 $A_i$，这样才不会浪费。

所以先对 $A$ 排序，然后二分找到最靠后满足的位置 $p_i$，因为越前面越珍惜。

接下来对于 $\forall i \in [L,R]$，从 $p_i$ 开始向前找第一个能满足匹配的点进行匹配。过程可以用并查集优化。

套上莫队，但并查集只支持合并，不支持分裂，所以使用回滚莫队来避免这个问题。在移动指针时记录操作和对应的修改，撤销时改回来。

记得去掉路径压缩，使用按秩合并。

---

## 作者：大眼仔Happy (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P4477)

最近在学习莫队，于是就来刷一点题来练练手。

然后就瞪了[别人的题解](https://www.luogu.com.cn/article/a4iot2hz)瞪了很久都不是很懂为什么，所以就替这篇题解写一些 ~~解释~~ 自己的理解吧。

首先这种区间问题还是离线我们可以想到莫队，然后就是令 $A_i\gets Z-A_i$，就变成了 $B_i\le A_i$。

假设选择出来的集合为 $\{C_k\}$，现在我们试着配对。设 $f_i$ 表示集合 $\{C_k\}$ 中小于等于 $A_i$ 的数量，那么对于前 $i$ 个数来说，$\{C_k\}$ **至少**有 $i-f_i$ 个无法配对（注意这个东西不能为负数，虽然没有 Hack），所以我们应该对于所有的 $i$ 取一个 $\max$。所以我们只需要用一个线段树维护一下这个东西即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=152505,M=52505;
int inline read()
{
	int num=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){num=(num<<3)+(num<<1)+(ch^48);ch=getchar();}
	return num*f;
}
int n,m,Z,q,res,L=1,R,siz;
int bel[M],a[N],pos[M],b[M],ans[M],t[N<<2],tag[N<<2];
struct data{int l,r,id;}d[M];
bool operator <(const data &A,const data &B){return bel[A.l]==bel[B.l]?(bel[A.l]&1?A.r<B.r:A.r>B.r):A.l<B.l;}
#define ls (k<<1)
#define rs (k<<1|1)
#define mid (l+r>>1)
void build(int k,int l,int r)
{
	if(l==r)return t[k]=l,void();
	build(ls,l,mid);build(rs,mid+1,r);
	t[k]=max(t[ls],t[rs]);
}
void LT(int k,int v){t[k]+=v;tag[k]+=v;}
void upd(int k,int l,int r,int ql,int qr,int v)
{
	if(ql>qr)return;
	if(ql<=l&&r<=qr)return LT(k,v);
	if(tag[k])LT(ls,tag[k]),LT(rs,tag[k]),tag[k]=0;
	if(ql<=mid)upd(ls,l,mid,ql,qr,v);
	if(qr>mid)upd(rs,mid+1,r,ql,qr,v);
	t[k]=max(t[ls],t[rs]);
}
void add(int x){upd(1,1,n,pos[x],n,-1);}
void del(int x){upd(1,1,n,pos[x],n,1);}
int main(){
	n=read();m=read();Z=read();
	for(int i=1;i<=n;i++)a[i]=Z-read();
	sort(a+1,a+1+n);build(1,1,n);
	for(int i=1;i<=m;i++)pos[i]=lower_bound(a+1,a+1+n,b[i]=read())-a;
	q=read();
	for(int i=1;i<=q;i++)d[i]=(data){read(),read(),i};
	siz=ceil(m/sqrt(q));
	for(int i=1;i<=m;i++)bel[i]=(i-1)/siz+1;
	sort(d+1,d+1+q);
	for(int i=1;i<=q;i++)
	{
		while(L>d[i].l)add(--L);
		while(R<d[i].r)add(++R);
		while(L<d[i].l)del(L++);
		while(R>d[i].r)del(R--);
		ans[d[i].id]=n-max(0,t[1]);
	}
	for(int i=1;i<=q;i++)printf("%d\n",ans[i]);
	return 0;
}
```

---

## 作者：creation_hy (赞：1)

~~再水一篇题解~~

水题。询问形式容易联想到莫队，让 $A_i$ 变为 $Z-a_i$ 后，要求变为 $B_i\le A_i$。

容易想到容斥。将 $A$ 排序后，设 $f_i$ 表示有多少个 $B_i$ 小于等于 $A_i$，由于 $A_i$ 单调，答案即为匹配的最大空缺，即 $n-\max(i-f_i)$。

然后就很简单了，设 $pos_i$ 表示第一个大于等于 $B_i$ 的 $A_i$，则插入数字相当于把对于 $i\in[pos,n]$ 的 $i-f_i$ 全部减一，删除为全部加一。

用线段树维护就行了。

时间复杂度 $O(q\sqrt m \log n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 6e4 + 5;
const int M = 7e5 + 5;
int n, m, q, lim, a[M], b[N], pos[N], sq, num[N], ans[N];
struct Query
{
    int l, r, id;
    inline bool operator<(const Query &t) const
    {
        return num[l] == num[t.l] ? r < t.r : l < t.l;
    }
} qy[N];
struct SegTree
{
    int tag[M], mx[M];
    inline int ls(int p) { return p << 1; }
    inline int rs(int p) { return p << 1 | 1; }
    inline void push_up(int p) { mx[p] = max(mx[ls(p)], mx[rs(p)]); }
    inline void push_down(int p)
    {
        if (tag[p])
        {
            tag[ls(p)] += tag[p], tag[rs(p)] += tag[p];
            mx[ls(p)] += tag[p], mx[rs(p)] += tag[p];
            tag[p] = 0;
        }
    }
    inline void build(int p, int l, int r)
    {
        if (l == r)
        {
            mx[p] = l;
            return;
        }
        int mid = l + r >> 1;
        build(ls(p), l, mid);
        build(rs(p), mid + 1, r);
        push_up(p);
    }
    inline void update(int p, int l, int r, int dl, int dr, int k)
    {
        if (dl > dr)
            return;
        if (dl <= l && r <= dr)
        {
            mx[p] += k, tag[p] += k;
            return;
        }
        push_down(p);
        int mid = l + r >> 1;
        if (dl <= mid)
            update(ls(p), l, mid, dl, dr, k);
        if (mid < dr)
            update(rs(p), mid + 1, r, dl, dr, k);
        push_up(p);
    }
} seg;
inline void add(int x) { seg.update(1, 1, n, pos[x], n, -1); }
inline void del(int x) { seg.update(1, 1, n, pos[x], n, 1); }
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m >> lim, sq = sqrt(m);
    for (int i = 1; i <= n; i++)
        cin >> a[i], a[i] = lim - a[i];
    sort(a + 1, a + 1 + n);
    for (int i = 1; i <= m; i++)
    {
        cin >> b[i], num[i] = (i - 1) / sq + 1;
        pos[i] = lower_bound(a + 1, a + 1 + n, b[i]) - a;
    }
    cin >> q;
    for (int i = 1; i <= q; i++)
        cin >> qy[i].l >> qy[i].r, qy[i].id = i;
    sort(qy + 1, qy + 1 + q);
    seg.build(1, 1, n);
    for (int i = 1, l = 1, r = 0; i <= q; i++)
    {
        while (l > qy[i].l)
            add(--l);
        while (r < qy[i].r)
            add(++r);
        while (l < qy[i].l)
            del(l++);
        while (r > qy[i].r)
            del(r--);
        ans[qy[i].id] = max(0, n - seg.mx[1]);
    }
    for (int i = 1; i <= q; i++)
        cout << ans[i] << '\n';
    return 0;
}
```

---

## 作者：C3H5ClO (赞：0)

蒟蒻的主席树+回滚莫队辣鸡做法

首先，把A数组排序，这没什么疑问。

贪心的想，$C_i$能匹配A数组的区间是$[1,x]$，其中$x=max\{k|a_k+c_i<=Z\}$，那么我们肯定要匹配A中没用过的编号最大的元素。

如果只考虑区间伸长，那么可以考虑给A数组建个线段树，就可以方便的找到$[1,x]$中没用过的编号最大的元素。因此考虑回滚莫队。回滚莫队需要快速返回原来状态，那么用主席树代替线段树。

---


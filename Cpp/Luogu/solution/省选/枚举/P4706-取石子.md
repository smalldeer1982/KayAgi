# 取石子

## 题目描述

现在 Yopilla 和 yww 要开始玩游戏！

他们在一条直线上标记了 $n$ 个点，从左往右依次标号为 $1, 2, ..., n$ 。然后在每个点上放置一些棋子，其中第 $i$ 个点放置了 $a_i$ 个棋子。接下来，从 Yopilla 开始操作，双方轮流操作，谁不能操作谁输。每次的操作是：当前操作方选定一个有棋子的点 $x$ ，然后选择至少一个点 $x$ 上的棋子，然后把这些棋子全都移动到点 $x / prime$ 上，其中 $prime$ 是一个质数，且 $prime \mid x$ 。

Yopilla 最初一次操作的策略是随机的：随机找到一个有棋子的点 $x$ ，随机选择正整数个棋子 $y$ ，随机转移到一个能转移到的点 $z$ 。所有棋子可以看作是一样的，换句话说：两种操作不同，当且仅当三元组 $(x, y, z)$ 不同。之后双方都按照最优策略来操作。

Yopilla 想要预测，他能够获胜的概率是多少，答案对 $998244353$ 取模。

## 说明/提示

样例解释：

$1$ 号点有 $3$ 个棋子，$2$ 号点有 $1$ 个棋子，$3$ 号点有 $2$ 个棋子。第一次操作的时候，能进行的有三种可能：将 $2$ 号点的 $1$ 个棋子移到 $1$ 号点，将 $3$ 号点的 $1$ 个棋子移到 $1$ 号点，将 $3$ 号点的 $2$ 个棋子移到一号点。而其中只有一种情况能使得 Yopilla 有必胜策略。所以答案为
$$\frac{1}{3} \equiv 332748118 \pmod {998244353}$$

对于 $20 \%$ 的数据，只有一个石子。

对于 $100 \%$ 的数据，$1 \le n \le {10} ^ 6, 0 \le a_i \le {10} ^ 9$ ，保证至少有一个不在一号点的石子。

## 样例 #1

### 输入

```
3
3 1 2```

### 输出

```
332748118```

# 题解

## 作者：Roger_DTZ (赞：8)

　　我们发现，对于每一个数，如果以其幂指数之和为下标来将它们重新排列成一个数组，这个问题就变成了[阶梯$Nim$问题](https://www.cnblogs.com/RogerDTZ/p/9439540.html)。一次操作，相当于将一个数移动到其左边。不能移动者输。

　　事实上我们不需要实现这个重排操作。我们只需要知道每个数重排后是否在奇位置即可。

　　记输入数列为$a$，我们统计出所有处于奇位置的数$x$的$a_x$的异或和$sum$。

　　我们要统计Yopilla一开始的随机操作一共有多少种可能、以及总共有多少种可能，使得操作后局面的先手必败。前者很好计算，就是$\sum_x a_x*b_x$，其中$b_x$表示$x$这个数的不同质因子个数。

　　后者如何计算呢？对操作分类：（1）移动奇位置的数至偶位置、（2）移动偶位置的数至奇位置。

　　我们枚举所有奇位置的数。假设对该位置$i$操作后，总异或和$sum$等于0，即操作后先手必败，则$a_i$应该由$a_i$变成$target=sum\; \text{xor}\; a_i$，

　　如果原值比目标值大，那么显然（1）容易满足，选出$a_i-target$个数，并将它们通过任意一个质因子移动到偶位置，一共有$b_i$种合法情况。
  
　　如果原值与目标值相等，则什么也做不了，一改就不满足要求，不作为合法情况考虑。
  
　　若原值小于目标值，则考虑（2），枚举所有能转移到$i$的偶位置$j=i*p$（其中$p$是枚举的质数），如果$a_j \ge target-a_i$，那么合法情况就多了一种，因为$j$可以选$target-a_i$个数通过唯一一种方式——除去$p$——来到达$i$。

　　那么概率也就很好计算了。

---

## 作者：cyffff (赞：7)

[$\text{Link}$](https://www.luogu.com.cn/problem/P4706)
## 题意
有 $n$ 堆棋子，第 $i$ 堆有 $a_i$ 个棋子，定义一次操作为选择第 $i$ 堆棋子中任意个棋子转移到第 $j$ 堆中。其中 $j$ 是 $i$ 的质因数。

两人轮流操作，不能操作者输。若先手第一步随机操作一步，问先手获胜的概率。对 $998244353$ 取模。

$1\le n\le 10^6,0\le a_i\le 10^9$。
## 思路
前置知识：阶梯 $\text{Nim}$ 博弈

描述：有 $n$ 堆棋子，第 $i$ 堆有 $a_i$ 个棋子，定义一次操作为选择第 $i$ 堆棋子中任意个棋子转移到第 $i-1$ 堆中。两人轮流操作，不能操作者输。求先手是否有必胜策略。

可以得到，此时的 $\text{SG}$ 函数 $f(x)=a_1\text{ xor }a_3\text{ xor }a_5\text{ xor }\cdots\text{ xor } a_{n-[2|n]}$，此处不多作介绍，可以参考[这份讲解](https://www.cnblogs.com/RogerDTZ/p/9439540.html)。
****
设 $x$ 的标准分解式为 $\prod_{i=1}^k p_i^{q_i}$，定义 $s_x=k,c_x=\sum_{i=1}^kq_i$。这个可以线性筛出来。

我们发现，如果以 $c_i$ 的奇偶性分层连边，则问题转化为在奇偶层之间移动棋子的阶梯 $\text{Nim}$ 博弈。

首先我们知道先手第一步走的方式有 $\sum_{i=1}^n s_ia_i$ 种。

然后来判断有多少种合法方法。

枚举奇层的所有 $i$，若操作后 $f(x)$ 变为 $0$，则先手能胜利，则定义 $need=f(x)\text{ xor } a_i$，则 $a_i$ 变为 $need$ 后 $f(x)$ 变为 $0$。

然后对于 $need$ 和 $a_i$ 的大小分类讨论。

- $need=a_i$，此时 $f(x)=0$，若对 $a_i$ 做出改动，则 $f(x)$ 定不等于 $0$，故此类无贡献；
- $need<a_i$，考虑将 $i$ 处的 $a_i-need$ 颗棋子转移至偶层，则对答案作出 $s_i$ 的贡献；
- $need>a_i$，考虑枚举 $ip=j$，将偶层 $j$ 处的 $need-a_i$ 颗棋子转移至奇层 $i$ 处，则对答案作出 $\sum_{j=ip}[a_j\ge need-a_i]$ 的贡献。

最后除一下得出概率就行了！

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
namespace IO{//by cyffff
	
}
const int N=1e6+10,mod=998244353;
int n,a[N],rnd,sol;
bitset<N>p;
int pri[N],cnt,sum[N];
bool odd[N];
/*
sum->质因数个数
odd->指数和是否为奇 
*/
inline int qpow(int x,int y){
	int res=1;
	while(y){
		if(y&1) res=1ll*res*x%mod;
		x=1ll*x*x%mod;
		y>>=1; 
	}
	return res;
}
inline void sieve(int n){
	p[1]=1;
	for(int i=2;i<=n;i++){
		if(!p[i]){
			pri[++cnt]=i;
			sum[i]=odd[i]=1;
		}
		for(int j=1;j<=cnt&&i*pri[j]<=n;j++){
			p[i*pri[j]]=1;
			odd[i*pri[j]]=odd[i]^1;
			if(i%pri[j]==0) { sum[i*pri[j]]=sum[i]; break; }
			sum[i*pri[j]]=sum[i]+1;
		}
	}
}
int SG;
int main(){
	n=read();
	sieve(n);
	for(int i=1;i<=n;i++){
		a[i]=read();
		if(odd[i]) SG^=a[i];
		rnd=(rnd+1ll*a[i]*sum[i])%mod;
	}
	for(int i=1;i<=n;i++){
		if(odd[i]){
			int need=SG^a[i];
			if(need==a[i]) continue;
			if(need<a[i]) sol=(sol+sum[i])%mod;
			else{
				for(int j=1;j<=cnt&&pri[j]*i<=n;j++){
					if(a[i*pri[j]]>=need-a[i]) sol++;
				}
				sol-=sol>=mod?mod:0;
			}
		}
	}
	write(1ll*sol*qpow(rnd,mod-2)%mod);
	flush();
}
```
再见 qwq~

---


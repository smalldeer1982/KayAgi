# 萨塔尼亚的一生之敌

## 题目背景

“Trick or treat！”

万圣节到了，薇奈特、萨塔尼亚和菈菲尔敲开了珈百璃的门，但果然不出所料，珈百璃在打网游，真是颓废啊。

“干嘛，烦死了”珈百璃一脸嫌弃地看着她们

“珈百璃，好歹也出来玩玩嘛，天天待在家里打游戏，会烂掉的”薇奈特抢先说道

“哈？我每天都出去玩啊，去买泡面的时候顺路在家楼下逛了一圈啊”

“这只能算是去小卖部吧，根本不算是出去玩吧”

“对啊，而且万圣节到了，我们一起出去要糖果吃呀”

“哈？你几岁了？还玩这么无聊的游戏”

“不会啊，我觉得很有趣啊”三人异口同声

“真是的，好吧好吧，就陪你们玩玩”

于是珈百璃随着他们三个出去要糖果吃了

“那么，先去谁家呢？”

“我有提议！！”萨塔尼亚激动地抢着说

于是，她们一行人来到了某人家。

“咚咚咚”过了一会，门开了，走出来的，是一个光头吴克

“Trick or treat！”萨塔尼亚开心地叫倒。面前站的，就是她们的班主任。但是，除了萨塔尼亚在开心的要糖果，其他三个人早已经吓得瑟瑟发抖了

“呃。。班。。班主任。。。？老。。老师，这是有误会的。。。”薇奈特颤抖地说道

“哪有什么误会啊？班主任，Trick or treat！哦~再不给糖，就把你画成鬼~”萨塔尼亚依旧天不怕地不怕

“喂。。。”薇奈特微微后退了一步

但令人惊讶的是，老师居然进房间，拿了一袋礼品出来，其中包括萨塔尼亚最喜欢的限量版菠萝包

“啊！！！是限量版的！！！太好了！！！”当萨塔尼亚刚要伸手去拿菠萝包时，天使的走狗杀了出来，一把抢走了菠萝包。

“喂！！那是我的！！你给我回来”萨塔尼亚生气地望着天使的走狗，宣誓自己一定要抢回来

萨塔尼亚势力和天使的走狗势力占领着不同的区域，每个天使的走狗占领的区域都会有一个菠萝包，萨塔尼亚想抢回这些菠萝包，你能帮助她吗？


## 题目描述

详情是这样的，在萨塔尼亚强大的立场下，这个世界被分成了若干区域，有一些区域有连边。为了能够抢回菠萝包，萨亚尼亚将这些区域再分成了若干领域，使得每个领域由一些区域组成，萨塔尼亚占领了一些领域，并以这些领域为基础向走狗发起进攻。为了成功夺回所有菠萝包，萨塔尼亚决定让这些自己占领的领域满足以下性质

1、    为了能够及时支援友军，在自己占领的领域中，每两个存在于不同领域的两个点都要有连边

2、    为了能够灵活的进攻，自己的任意一个领域中的任意一个点和走狗占领的任意一个领域中的任意一个点都要有连边

当然走狗也不是吃干饭的，它为了羞辱萨塔尼亚，也选择了一些领域，这些领域满足的性质和萨塔尼亚选择的领域满足的性质一样，且走狗的领域和萨塔尼亚的领域互补

萨塔尼亚觉得，只要将领域分的越分散，胜利的几率就越大，于是想分尽可能多的领域，请问最多能分多少领域？每个领域有多少个区域组成？

\*特殊的，一个人可能占领不到任何一个领域，即占领的领域数量为0。如果你能告诉萨塔尼亚答案，萨塔尼亚就会占领最大的领域向走狗发起进攻，并最终失败。


## 说明/提示

样例解释：最多分成两个领域，区域1、3为一个领域，区域2为一个领域

请结合样例仔细读题！

对于40%的数据，n≤10^3，m≤5\*10^5

对于100%的数据，n≤10^5，m≤2\*10^6


## 样例 #1

### 输入

```
3 2
1 2
2 3
```

### 输出

```
2
1 2
```

# 题解

## 作者：smzzl (赞：17)

这题怎么就黑了（我这么菜怎么会做得出来黑题呢）

这题怎么做呢？其实主要是要细细读一下那两个性质

对于1，每个自己不同的领域的点之间都要有边

对于2，自己的领域的每一个点要和对面的每一个领域的每一个点要有边

认真看着两个条件是不是会发现如果对面拿了一个领域，那么这个领域作为自己的领域也是满足条件的

#### 所以不要给走狗留领域

好了现在问题就是怎么分配这个领域了

显然对于两个联通块，若他们之间没有边，则要划分到同一个领域去

所以怎么划分领域？

对于每一个点A它必定属于一个领域，那么我们以这个点进行扩展，我们要这个领域尽量多，因此我们维护一个队列表示和当前枚举的A在不在一个领域内。对于这个A点沿着他的出边拓展，所有被A访问到的点都是允许不和A在同一个领域，所以偶没有被A访问到的点必定和A在同一个领域，这里我们就用一个桶来维护，每次将其++，把这些没有被访问到的点进入队列.然后我们要用一个limit维护这个领域大小，遍历这个桶，将遍历到的点如果他的桶的值小于limit，那么说明这个点不能被这个领域的所有点到达，因此他要属于这个领域，按照这个方法维护即可。具体细节见代码注释。

时间复杂度为O(m+nk),k为领域数量，m为边数

极端情况退化n^2?

不会的，因为此题m不大，因此可以知道k不会很大，这个时间复杂度能够通过此题。若有更优秀的做法欢迎指出。

### ~~（路过点个赞呀）~~



code：
```
#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;

struct note{
    int seq,val,act;
}que[4000008];
int n,m,l,maxp;
int x[4000008],y[4000008],_last[4000008],_next[4000008];
int vis[4000008],cnt[4000008],fa[4000008],tp[4000006];

inline void edge(int u,int v){
    l++; x[l]=u; y[l]=v; _next[l]=_last[u]; _last[u]=l;
}
inline int _max(int a1,int a2){if (a1<a2) return a2; else return a1;}
bool cmp(int a1,int a2){return a1<a2;}

inline void dividing(int);

int main()
{
    scanf("%d%d",&n,&m);
    for (register int i=1;i<=n;i++) _last[i]=-1;
    for (register int i=1;i<=m;i++){
        int u,v;
        scanf("%d%d",&u,&v);
        edge(u,v),edge(v,u);
    }
    for (register int i=1;i<=n;i++)
        if (!vis[i]) dividing(i);
    printf("%d\n",maxp);
    sort(cnt+1,cnt+1+maxp,cmp);
    for (register int i=1;i<=maxp;i++) printf("%d ",cnt[i]);
}

inline void dividing(int pos)
{
    
    for (register int i=1;i<=n;i++) fa[i]=i,tp[i]=vis[i];
    register int limit=0,lef=1,rig=n,res=n,deep=n,spp=1;
    for (register int i=1;i<=n;i++) que[i].seq=i,que[i].val=0;//inti
    while (res && lef<=deep && deep<=10*n)
      if (que[lef].val<limit || spp)//若为第一个或者这个点的桶值没有到达limit
        {
            pos=que[lef].seq; lef++; 
            if (vis[pos]) continue; 
            vis[pos]=1;
            for (register int j=_last[pos];j!=-1;j=_next[j]){
            	int tar=y[j];
            	while (fa[tar]!=0 && fa[tar]!=tar) tar=fa[tar];
                que[tar].val++;
            }
            limit++;
            res--; spp=0;
        }else {
            if (que[lef].val==999999999) {lef++; continue;}
            rig++;
            fa[que[lef].seq]=rig;
            que[rig]=que[lef];
            que[lef].val=999999999;
            lef++;
			deep++;//遍历出边，更新最大deep（因为有下面的移动操作，不能到n就停
            //这个点到目前为止成立并不代表完全成立，要将他移动到队列末尾，fa数组维护他的新位置。
        }
    maxp++;
    for (register int i=1;i<=n;i++) 
        if (tp[i]!=vis[i]) cnt[maxp]++;//统计答案
}
}
```
（直接复制抄袭会ce)
（bug不影响阅读）
（这是重发的之前那个有一点bug）

---

## 作者：mayike (赞：3)

### [题目传送门](https://www.luogu.com.cn/problem/P4833)

[双倍经验](https://www.luogu.com.cn/problem/P3452)

# 题意

简化来说就是将开始没连边的区域分在一起，一定的。连边也可以分一起，随情况而定。想办法让连在一起的区域块总数最多。

# 思路

直接 bfs 将没连边的放一起，直接按此模拟，再加些优化就过了

对于每个点，没有连边的一定要在一个块。

若有电话，分两种：

一：直接连接，对于每个点，先标记，不连。

二：间接的，因为没有连边的一定要在一个块，所以一定连(标记早已取消了，具体见代码)。

情况二的延申： 若点 A 和点 B 没连边，点 B 和点 C 没连边，但点 A 和点 C 有连边，三点也是要连的，证明很简单吧？

上代码吧！

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+1;
int n,m,vis[N],cv[N],ans[N],last[N],Nxt[N],sum;
vector<int>e[N];
void da(int x){
	Nxt[last[x]]=Nxt[x];
	last[Nxt[x]]=last[x];
}//链的删减
void bfs(int u){
	vis[u]=1;
	da(u);//这个很容易漏
	ans[++sum]=1;//新建块
	queue<int>q;
	q.push(u);
	while(!q.empty()){
		int x=q.front();
		q.pop();
		for(int v:e[x])if(!vis[v])cv[v]=1;//有连边先标记，不要直接连
		for(int i=Nxt[0];i;i=Nxt[i]){//加个链来优化
			if(!cv[i]){
				ans[sum]++;//每个块个数加一
				vis[i]=1;//整体标记
				q.push(i);//存点
				da(i);//存了就删掉
			}else cv[i]=0;//取消标记，对于 ABC 的情况，得以解决
		}
	}
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<n;i++){
	    last[i+1]=i;
	    Nxt[i]=i+1;
	}Nxt[0]=1;
	for(int i=1;i<=m;i++){
		int x,y;
		scanf("%d%d",&x,&y);
		e[x].push_back(y);
		e[y].push_back(x);
	}for(int i=1;i<=n;i++)
		if(!vis[i])bfs_up++(i);//判断整体标记没有
	printf("%d\n",sum);
	sort(ans+1,ans+sum+1);
	for(int i=1;i<=sum;i++)printf("%d ",ans[i]);//输出
	return 0;
}
```
~~点个免费的????再走吧~~

---

## 作者：Unnamed114514 (赞：0)

## 题意转化

求一个图的补图的连通块数量及每个连通块大小。

## 如何求解连通块？

显然，如果我们建好了图，我们可以直接 dfs。

难点就是怎么建图。

## 如何建图？

### $O(n^2)$

显然，我们可以用邻接矩阵存图，然后暴力跑每两个点间是否在原图存在边，如果不存在，加上即可。

枚举每个点对，时间复杂度显然 $O(n^2)$，考虑优化。

### $O(n\log n)$

考虑我们加了一条边 $(u,v)$ 后，补图会发生什么变化。

每个点 $i$，我们可以考虑存储它的所有的需要再补图中建边的点的区间，初始时显然 $[1,n]$。

然后，我们从 $u$ 向 $v$ 加边，就相当于从 $u$ 中找到能覆盖到 $v$ 的区间 $[l,r]$，此时 $v$ 不需要在补图中建边，那么这个区间就分裂成 $[l,v-1]$ 和 $[v+1,r]$。

容易发现，我们每次加一条边，就会多一个区间，那么区间就是 $O(n+m)$ 个。

问题就可以转化成 $n+m$ 个区间，每次从一个点向一个区间中的所有点连边，最后判断连通性。

那么就可以打线段树优化建图，时间空间都是 $O(m\log n)$，注意此时我们只需要建一棵线段树就行了。

## 后记

[双倍经验](https://www.luogu.com.cn/problem/P3452)

不过这道题第五个点会 MLE，但是我们运用随机化贪心，很显然，边数多了之后很多点都在同一个连通块。于是我们可以设立一个阈值，在边数多于它的时候就直接求解答案，亲测 $10^7$ 可过。

---

## 作者：Resurgammm (赞：0)

> 给定一张 $n$ 个点 $m$ 条边的图，求补图的连通块个数以及各个连通块的大小

有个 $\text{naive}$ 的想法就是直接暴力建出补图然后去跑，但是这样边数是 $n^2$ 级别的，显然会 $\text{T}$。

发现只需要知道每个连通块的信息，所以可以考虑建出生成树。

考虑 $\text{BFS}$ 树，枚举一个没有被标记过的点 $u$ 标记它并把它加入到队列，先把它在 **原图** 直接相邻的点标记，然后将它在 **补图** 上相邻且没有被标记过的点 $v$ 标记并放入队列。

可以直接用链表直接维护出来这个 $v$。

这样每个点在链表中只会被遍历一遍，且这么做枚举仅涉及到树边，而对 $u$ 枚举在原图上相邻的点也只等于枚举原图上的边的复杂度，所以总复杂度是 $O(n+m)$ 的。

[双倍经验](https://www.luogu.com.cn/problem/P3452)

$\texttt{Code:}$

```cpp
#include <bits/stdc++.h>
#define ll long long 
#define ull unsigned long long
#define fir first
#define sec second
using namespace std;
namespace IO{
	#define File(x,y) freopen(#x,"r",stdin),freopen(#y,"w",stdout);
	#define fill(a,b,c,d) memset(a,b,sizeof(c)*(d+1))
	#define copy(a,b,c,d) memcpy(a,b,sizeof(c)*(d+1))
	#define fillall(x,y) memset(x,y,sizeof(x))
	#define copyall(x,y) memcpy(x,y,sizeof(x))
	inline int read(){
		int w=0,f=1; char ch=getchar();
		while(ch<'0'||ch>'9'){if(ch=='-') f=-1; ch=getchar();}
		while(ch>='0'&&ch<='9'){w=(w<<1)+(w<<3)+(ch^48); ch=getchar();}
		return w*f;
	}
}
using namespace IO;
namespace CL{

	const int maxn=1e5+5,maxm=2e6+5;

	int n,m,top;
	int stk[maxn];
	bool vis[maxn],org[maxn];
	queue<int> q;
	namespace Graph{
		int head[maxn],id;
		struct e{int v,next;}edge[maxm<<1];
		inline void add(int u,int v){
			edge[++id]=(e){v,head[u]};
			head[u]=id;
		}
	}using namespace Graph;
	namespace list{
		int pre[maxn],nxt[maxn];
		inline void init(){
			nxt[0]=1;
			for(int i=1;i<n;i++) pre[i+1]=i,nxt[i]=i+1;
		}
		inline void del(int x){pre[nxt[x]]=pre[x],nxt[pre[x]]=nxt[x];}
	}using namespace list;

	inline int main(){
		n=read(),m=read();
		for(int i=1;i<=m;i++){
			int x=read(),y=read();
			add(x,y),add(y,x);
		}
		init();
		for(int i=1;i<=n;i++) if(!vis[i]){
			vis[i]=1,stk[++top]=1;
			del(i),q.push(i);
			while(!q.empty()){
				int u=q.front(); q.pop();
				for(int j=head[u];j;j=edge[j].next){
					int v=edge[j].v;
					if(!vis[v]) org[v]=1;
				}
				for(int j=nxt[0];j;j=nxt[j]){
					if(!org[j]){
						vis[j]=1,stk[top]++;
						del(j),q.push(j);
					}
					else org[j]=0;
				}
			}
		}
		sort(stk+1,stk+1+top);
		printf("%d\n",top);
		for(int i=1;i<=top;i++) printf("%d ",stk[i]); puts("");
		return 0;
	}
}
signed main(){return CL::main();}
```

---

## 作者：斜揽残箫 (赞：0)

## Description

给你一个 $n$ 个点 $m$ 条边的图，让你求出这个图的补图的联通块的个数和每个联通块的大小。

## Solution

首先，搞清楚题意以后我们可以把补图的边全部建出来，之后再求联通块的个数和大小。

但是很明显，建立补图的空间复杂度是 $n ^ 2$ 级别的，所以如果把补图的边全部建出来只能过 $1 \leq n \leq 10 ^ 3$ 的分。

所以我们不能建立补图，要换一种方式，考虑直接使用原图来进行联通块的个数统计。

可以枚举每一个没有被 $\text{vis}$ 标记过的点，加入队列，说明之前这个点没有被遍历到，之后从这个点开始枚举它能到达的点，把这些点 $\text{col}$ 标记一下，说明在原图上面能够到达，也就是说明在补图上不能够到达，之后枚举每一个点，如果没被标记 $\text{col}$ 和 $\text{vis}$，就把这个点加入队列。

可以看出，这样做使得空间复杂度大大降低，但是时间复杂度变高了，变为了 $O(n ^ 2)$ 级别。

我们如何加快寻找没被标记过的点的位置呢，我们可以使用链表来解决这个问题，如果一个点已经被寻找过了，就把这个点删除，因为这个点不可能出现在别的联通块里面，并且这个点已经被这个联通块标记过了，也不需要再标记一次，这个点不会对后面产生任何贡献，所以链表里面只会存着没有用到过的点。

于是，这个问题的时间复杂度就降为了 $O(n + m)$，可以通过本题。

主要看代码吧，笔者的语文实在差劲。

## Code

```
#include <cstdio>
#include <cmath>
#include <iostream>
#include <cstring>
#include <algorithm>
#include <queue> 
using namespace std;
const int Maxk = 2e6 + 10;
int nex[Maxk],pre[Maxk];
struct Node {
  int nex_,to_;
}e[Maxk << 1];
int n,m,cnt;
bool vis[Maxk];
int head[Maxk];
int ans[Maxk],ret,col[Maxk];
queue <int> qp;
inline int read()
{
	int s = 0, f = 0;char ch = getchar();
	while (!isdigit(ch)) f |= ch == '-', ch = getchar();
	while (isdigit(ch)) s = s * 10 + (ch ^ 48), ch = getchar();
	return f ? -s : s;
}
inline void Add_edge(int from,int to)
{
  e[++ cnt].to_ = to;
  e[cnt].nex_ = head[from];
  head[from] = cnt;
}
inline void Del(int x)
{
  nex[pre[x]] = nex[x];//链表删除
  pre[nex[x]] = pre[x];
}
signed main()
{
  n = read(),m = read();
  for(int i = 1;i <= n;i ++) nex[i] = i + 1,pre[i] = i - 1;//链表初始化
  for(int i = 1;i <= m;i ++) {
    int x = read(),y = read();
    Add_edge(x,y),Add_edge(y,x); //原图连边
  }
  nex[n] = 0,pre[0] = 1;
  for(int i = 1;i <= n;i ++) {
    if(vis[i]) continue;//如果这个点已经找过了，跳过
    vis[i] = true;
    ans[++ ret] = 1;//新的联通块，因为每次队列里面都是一个联通块，我们按照连通块进行寻找
    qp.push(i);//队列加入这个点
    Del(i);//已经没有用了，删除
    while(!qp.empty()) {
      int x = qp.front();
      qp.pop();
      for(int j = head[x];j;j = e[j].nex_) {
        int y = e[j].to_;
        if(!vis[y]) col[y] = 1;//原图上面能够到达的点，并且没有被访问过，打上标记，补图不能访问。
      }
      for(int j = nex[0];j;j = nex[j]) {//枚举链表
        if(!col[j]) {//如果这个点补图能够访问到
          vis[j] = true;
          ans[ret] ++;//联通块里面的点数目 ++
          Del(j);
          qp.push(j);
        }
        else col[j] = 0;//否则清空 col 数组，为下一次寻找准备。
      }
    }
  }
  sort(ans + 1,ans + ret + 1);//第一个找到的不一定是最大的，先排序。
  cout << ret << endl;
  for(int i = 1;i <= ret;i ++) cout << ans[i] << " ";
  cout << endl;
  return 0; 
}
```

---


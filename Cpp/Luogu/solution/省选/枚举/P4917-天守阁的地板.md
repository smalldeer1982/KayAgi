# 天守阁的地板

## 题目背景

在下克上异变中，博丽灵梦为了找到异变的源头，一路打到了天守阁。  

异变主谋鬼人正邪为了迎击，将天守阁反复颠倒过来，而年久失修的天守阁也因此掉下了很多块地板。    

异变结束后，恢复了正常大小的小碗回到了天守阁，想要修复这里的地板，她需要知道自己要采购的地板数量(一个惊人的数字)，于是，她找到了精通 $\text{OI}$ 的你来帮忙。   


## 题目描述

为了使万宝槌能发挥出全部魔力，小碗会将买来的地板铺满一个**任意**边长的正方形(地板有图案，因此**不允许旋转**，当然，地板也**不允许重叠**)来达到最大共鸣。  

在每一次购买中，小碗只能买到一种规格为 $a*b$ 的地板，为了省钱，她会在满足能摆成正方形的前提下购买尽可能少的地板。  
  
现在，她想知道对于每一对 $a,b(1≤a,b≤n)$ ，她最少需要购买的地板数量。当然，由于输出可能很大，你只需要输出所有答案的乘积对 `19260817` 取模后的结果即可。    

## 说明/提示

#### 样例解释:  

对于`n=1`，$(a,b)$ 仅有 $(1,1)$ 一种情况，只需要一块 $1 * 1$ 的地板即可构成边长为1的正方形,答案为 $1$  

对于`n=2`，$(a,b)$ 有 $(1,1),(1,2),(2,1),(2,2)$ 四种情况，分别需要 $1,2,2,1$ 块地板以拼成正方形，答案为 $1*2*2*1=4$  

进一步解释：  

当只能买到 $1*1$ 的地板时，只需要一块(本身就是正方形)  

当只能买到 $1*2$ 的地板时，需要两块(两块拼在一起组成 $2*2$ 的正方形)  
  
#### 数据范围：

对于 $30\%$ 的数据，$1 \le T \le 100,1 \le n \le 100$  

对于 $60\%$ 的数据，$1 \le T \le 300,1 \le n \le 3*10^4$   

对于 $100\%$ 的数据，$1 \le T \le 1000,1 \le n \le 10^6$    

## 样例 #1

### 输入

```
4
1
2
3
100```

### 输出

```
1
4
1296
18996121```

# 题解

## 作者：jszjinshengzhi (赞：9)

# Luogu P4917 天守阁的地板

题意：给定$n$，求用$a\times b(1\le a,b\le n)$的木板铺出一个最小的正方形所消耗木板的数量。为了避免高精，只用求范围内所有的$a,b$对应的答案的积（答案对~~长者生日~~19260817）。

数据范围：多组数据，$T\le1000,n\le1000000$

分析：对于$a\times b$的木板，能铺成的最小正方形的边长为$lcm(a,b)$，所用木板数即为$\frac{lcm(a,b)^2}{a\cdot b}$

所以 $Ans=\prod_{a=1}^n\prod_{b=1}^n\frac{lcm(a,b)^2}{a\cdot b}$

接下来就是暴力推柿子了。

看着$lcm$就特别不爽，于是把它换成$gcd$。

注意到$lcm(a,b)=\frac{a\cdot b}{gcd(a,b)}$，代入，有$Ans=\prod_{a=1}^n\prod_{b=1}^n\frac{a\cdot b}{gcd(a,b)^2}$

直接把分数化开来推想想都觉得很麻烦，而分子部分只有$a,b$两个字母，求积就是个阶乘的$2n$次幂，分母$gcd$又有很多现成的套路，看着多舒服，干脆直接把分子分母拆开来算。

分子$=(n!)^{2\cdot n}$

分母$=\prod_{a=1}^n\prod_{b=1}^ngcd(a,b)^2=(\prod_{d=1}^nd^{\sum_{a=1}^{\lfloor\frac nd\rfloor}\sum_{b=1}^{\lfloor\frac nd\rfloor}gcd(a,b)==1})^2\qquad$（枚举$gcd$）

$=\prod_{d=1}^nd^{4\cdot\sum_{i=1}^{\lfloor\frac nd\rfloor}\varphi(i)-2}=(n!)^{-2}\cdot\prod_{d=1}^nd^{4\cdot\sum_{i=1}^{\lfloor\frac nd\rfloor}\varphi(i)}$

分母中的$n!$提到分子，就可以开始开心的整除分块了，只需$O(n)$预处理筛出$\varphi$的前缀和、阶乘、逆元即可。

复杂度：$O(T\cdot\sqrt n)$

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define p 19260817

inline ll fpow(ll a,ll b){
	ll ret=1;
	for(;b;ret*=((b&1)?a:1),ret%=p,a=a*a%p,b>>=1);
	return ret;
}

#define maxn 1000005
ll phi[maxn],fac[maxn];
ll cnt,prime[maxn];
inline void init(){
	phi[1]=1;
	for(ll i=2;i<maxn;++i){
		if(!phi[i]){
			phi[i]=i-1;
			prime[++cnt]=i;
		}
		for(ll j=1;j<=cnt&&prime[j]*i<maxn;++j){
			if(i%prime[j]==0){
				phi[i*prime[j]]=phi[i]*prime[j];
				break;
			}
			phi[i*prime[j]]=phi[i]*phi[prime[j]];
		}
	}
	fac[0]=1;
	for(ll i=1;i<maxn;++i){
		phi[i]=(phi[i]+phi[i-1])%(p-1);//！！！这里模的是p-1，因为phi出现在指数中！！！ 
		fac[i]=fac[i-1]*i%p;
	}
}

int T;
ll n,ans;
int main(){
	init();
	scanf("%d",&T);
	while(T--){
		scanf("%lld",&n);
		ans=1;
		for(ll l=1,r;l<=n;l=r+1){
			r=n/(n/l);
			ans=ans*fpow(fac[r]*fpow(fac[l-1],p-2)%p,phi[n/l])%p;
		}
		printf("%lld\n",fpow(fac[n],2*n+2)*fpow(ans,p-5)%p);//这里的fpow(ans,p-5)表示ans^4的逆元
	}
	return 0;
}
```



---

## 作者：nekko (赞：7)

由题意得，对于一个元方块$(a,b)$，它能构成的最小正方形为$(\mathbb{lcm}(a,b),\mathbb{lcm}(a,b))$

也就是说要求

$$ \begin{aligned} \prod_{i=1}^{n} \prod_{j=1}^{n}\frac{\mathbb{lcm}^2(i,j)}{ij} = &\prod_{i=1}^{n} \prod_{j=1}^{n}\frac{(ij)^2}{ij \cdot \gcd^2(i,j)} \\ = &\prod_{i=1}^{n} \prod_{j=1}^{n}\frac{ij}{\gcd^2(i,j)} \\ = &\frac{\prod_{i=1}^{n}\prod_{j=1}^{n}ij}{(\prod_{i=1}^{n}\prod_{j=1}^{n}\gcd(i,j))^2} \\ = &\frac{\prod_{i=1}^{n}i^n\prod_{j=1}^{n}j}{(\prod_{i=1}^{n}\prod_{j=1}^{n}\gcd(i,j))^2} \\ = &\frac{\prod_{i=1}^{n}i^nn!}{(\prod_{i=1}^{n}\prod_{j=1}^{n}\gcd(i,j))^2} \\ = &\frac{(n!)^n(\prod_{i=1}^{n}i)^n}{(\prod_{i=1}^{n}\prod_{j=1}^{n}\gcd(i,j))^2} \\ = &\frac{(n!)^n(n!)^n}{(\prod_{i=1}^{n}\prod_{j=1}^{n}\gcd(i,j))^2} \\ = &\frac{(n!)^{2n}}{(\prod_{i=1}^{n}\prod_{j=1}^{n}\gcd(i,j))^2} \\ \end{aligned} $$

于是只需要求

$$ \begin{aligned} \prod_{i=1}^{n}\prod_{j=1}^{n}\gcd(i,j) = &\prod_{d=1}^{n}d^{\sum_{i=1}^{n}\sum_{j=1}^{n}[\gcd(i,j)=d]} \\ = &\prod_{d=1}^{n}d^{\sum_{i=1}^{\lfloor \frac{n}{d} \rfloor}\sum_{j=1}^{\lfloor \frac{n}{d} \rfloor}[\gcd(i,j)=1]} \\ = &\prod_{d=1}^{n}d^{\sum_{i=1}^{\lfloor \frac{n}{d} \rfloor}\sum_{j=1}^{\lfloor \frac{n}{d} \rfloor}\sum_{t \mid \gcd(i,j)} \mu(t)} \\ = &\prod_{d=1}^{n}d^{\sum_{t=1}^{\lfloor \frac{n}{d} \rfloor}\mu(t) (\lfloor \frac{n}{dt} \rfloor)^2} \\ = &\prod_{d=1}^{n}d^{f(\lfloor \frac{n}{d} \rfloor)} \end{aligned} $$

其中$f(x)=\sum_{i=1}^{x} \mu(i) (\lfloor \frac{x}{i} \rfloor)^2$

不妨枚举$i$，然后枚举$i$的倍数$ki$，考虑它在$[(k-1)i,ki)$中的贡献，首先对于$\forall x \in [(k-1)i,ki)$，所有的$\lfloor \frac{x}{i} \rfloor$都是相同的

于是只需要在$[(k-1)i,ki)$中区间加上$\mu(i)(k-1)^2$，这个过程可以直接差分后前缀和实现

~~于是就十分暴力又鬼畜的做完了这道题~~

时间复杂度：$O(n \log n+T\sqrt n\log n)$

---

``` cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 10, mod = 19260817, pm1 = mod - 1;
typedef long long ll;

ll fac[N], invfac[N], f[N], mu[N];

int pri[N], tot, vis[N];

ll pw(ll a, ll b) {
    ll r = 1;
    a %= mod;
    for( ; b ; b >>= 1, a = a * a % mod)
        if(b & 1)
            r = r * a % mod;
    return r;
}

namespace getf {
    const int mod = pm1;
    void sol() {
        const int n = 1e6;
        for(int i = 1 ; i <= n ; ++ i) {
        	// [1, i): all 0
            for(int j = 1 ; j * i <= n ; ++ j) {
                // [j * i, (j + 1) * i)
                int l = j * i, r = min((j + 1) * i - 1, n);
                ll v = mu[i] * j * j % mod;
                f[l] += v, f[r + 1] -= v;
                f[l] %= mod, f[r + 1] %= mod;
            }
        }
        for(int i = 1 ; i <= n ; ++ i) {
        	f[i] = (f[i] + f[i - 1]) % mod;
        	if(f[i] < 0) f[i] += mod;
        }
    }
}

void init() {
    const int n = 1e6;
    fac[0] = 1; for(int i = 1 ; i <= n ; ++ i) fac[i] = fac[i - 1] * i % mod;
    invfac[n] = pw(fac[n], mod - 2), invfac[0] = 1;
    for(int i = n - 1 ; i ; -- i) invfac[i] = fac[i + 1] * (i + 1) % mod;

    mu[1] = 1;
    for(int i = 2 ; i <= n ; ++ i) {
        if(!vis[i]) pri[++ tot] = i, mu[i] = -1;
        for(int j = 1 ; j <= tot && i * pri[j] <= n ; ++ j) {
            vis[i * pri[j]] = 1;
            if(i % pri[j]) mu[i * pri[j]] = -mu[i];
            else break;
        }
    }

    getf :: sol();
}

ll get(int n) {
    ll res = 1;
    for(int i = 1, j ; i <= n ; i = j + 1) {
        j = n / (n / i);
        res = res * pw(fac[j] * pw(fac[i - 1], mod - 2) % mod, f[n / i]) % mod;
    }
    return res;
}

ll sol() {
    int n; scanf("%d", &n);
    ll ans = pw(fac[n], 2 * n) * pw(pw(get(n), 2), mod - 2) % mod;
    return (ans % mod + mod) % mod;
}

int main() {
    init();
    int T; scanf("%d", &T);
    while(T --) printf("%lld\n", sol());
}
```



---

## 作者：x_angelkawaii_x (赞：4)

先考虑单个询问的情况,可以得到如下结论:  
用$a*b $规格的地板摆成的正方形的边长最小是$lcm(a,b)$(木板不允许旋转),所以需要最小的木板数量是$\frac{lcm(a,b)}{a}*\frac{lcm(a,b)}{b}$  

问题中说要把所有可能的$(a,b)$的答案求乘积,那么问题就转换成了求$$\Pi_{i=1}^{n}\Pi_{j=1}^{n}\frac{lcm(i,j)^2}{i*j}$$  

首先你必须知道  

$$lcm(i,j)*gcd(i,j)=i*j$$(唯一分解后易证)  

因此  
$$\Pi_{i=1}^{n}\Pi_{j=1}^{n}\frac{lcm(i,j)^2}{i*j}=\Pi_{i=1}^{n}\Pi_{j=1}^{n}\frac{i*j}{gcd(i,j)^2}$$  

先考虑分子:  
$$\Pi_{i=1}^{n}\Pi_{j=1}^{n}i*j=(1^{2n}*2^{2n}*...*n^{2n})=(n!)^{2n}$$  

所以可以先$O(n)$预处理出阶乘$fac(i)$,用快速幂$O(logn)$算出分子  

接下来考虑分母  

为了方便,可以先求出$$\Pi_{i=1}^{n}\Pi_{j=1}^{n}gcd(i,j)$$  
再平方

考虑枚举$d$,那么我们求出对于每个$d$有多少对$(i,j)$满足$gcd(i,j)=d$再套用快速幂即可  

显然,$i,j$都是$d$的倍数是必要条件,所以设$i=k_1d,j=k_2d(k1,k2≤\lfloor \frac{n}{d} \rfloor)$    
那么当且仅当$gcd(k1,k2)=1$即$k1,k2$互质时符合$gcd(i,j)=d$的条件(否则$gcd$可以扩大为$d*gcd(k1,k2)$)   
不妨令 $k1>k2$,那么符合条件的点对数 为每个在范围内的$k1$,小于它且与它互质的数的个数的和(即$\sumφ$),所以真正的答案就是  
$$(\sum_{k1=1}^{\lfloor \frac{n}{d} \rfloor} φ(k1))*2-1$$  

对$φ$求出前缀和$sum$  

所以$$\Pi_{i=1}^{n}\Pi_{j=1}^{n}gcd(i,j)=\Pi_{d=1}^{n}d^{sum(\lfloor \frac{n}{d} \rfloor)*2-1}$$  

好了,到现在复杂度为$O(n+Tnlogn)$,可以拿到$60$分的好成绩(雾)  

最后一个优化:  
不难发现,$\lfloor \frac{n}{d} \rfloor$的取值只有$2\sqrt{n}$种,那么可以把$\lfloor \frac{n}{d} \rfloor$相等的所有$d$放在一起处理  

假设某一段从$i$到$j$的所有数的这个值都等于$x$,那么这一段的乘积就等于
$$\Pi_{p=i}^{j}p^{sum(x)*2-1}=i^{sum(x)*2-1}*(i+1)^{sum(x)*2-1}*...*j^{sum(x)*2-1}=(i*(i+1)*...*j)^{sum(x)*2-1}$$  

那么先预处理出$1-19260817$的逆元$inv(i)$,这一段的答案就是$(fac(j)*inv(fac(i-1)))^{sum(x)*2-1}$  

这样处理后的最终复杂度是$O(n+T\sqrt{n}log(n))$,可以愉快的通过此题  

$AC code$(主要部分)  

```cpp

#define LL long long
const int mod=19260817;
LL ans;
LL quickpow(LL a,LL k)
{
    if(!k)return 1;
    LL res=quickpow(a,k>>1);
    res=(res*res)%mod;
    if(k&1)res=(res*a)%mod;
    return res;
}
void pre()
{
    phi[1]=1;
    for(LL i=2;i<maxn;++i)
    {
        if(!notprime[i])prime[++cnt]=i,phi[i]=i-1;
        for(LL j=1;j<=cnt&&prime[j]*i<maxn;++j)
        {
            notprime[prime[j]*i]=1;
            if(i%prime[j])phi[prime[j]*i]=phi[i]*(prime[j]-1);
            else
            {
                phi[prime[j]*i]=phi[i]*prime[j];
                break;
            }
        }
    }
    for(int i=1;i<maxn;++i)phi[i]=phi[i-1]+phi[i];
    fac[0]=1;
    for(int i=1;i<maxn;++i)fac[i]=((LL)fac[i-1]*i)%mod;
    inv[0]=inv[1]=1;
    for(int i=2;i<mod;++i)inv[i]=(((-(LL)(mod/i)*(LL)(inv[mod%i]))%mod)+mod)%mod;
}
int T;
int main()
{
    pre();
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d",&n);
        ans=quickpow(fac[n],2*n);
        LL ans2=1;
        for(LL i=1,L;i<=n;i=L+1)
        {
            LL p=2*phi[n/i]-1;
            L=n/(n/i);
            ans2=(ans2*quickpow((fac[L]*(LL)inv[fac[i-1]])%mod,p))%mod;
        }
        ans2=(ans2*ans2)%mod;
        printf("%lld\n",(ans*(LL)inv[ans2])%mod);
    }
}

```

---

## 作者：zhiyangfan (赞：2)

## P4917 天守阁的地板
upd. 在最后把不用 $\varphi$ 而是用常规莫反处理指数的做法加上了，并为之前所说的无法处理道歉Orz
### 题意
$T$ 次询问，每次给出 $n$，求下式：
$$\prod_{a=1}^n\prod_{b=1}^n\dfrac{\operatorname{lcm}^2(a,b)}{ab}$$
对 $19,260,817$ 取模的值。($1\le T\le10^3,1\le n\le 10^6$)
### 题解
看到 $\rm lcm$，先不管三七二十一拆成 $\gcd$：
$$\prod_{i=1}^n\prod_{j=1}^n\dfrac{ij}{\gcd^2(i,j)}$$
发现分子好处理，分母看起来也能处理，但合在一起就有点恶心了，所以我们考虑分子分母分开处理：
$$\dfrac{\prod_{i=1}^n\prod_{j=1}^nij}{\prod_{i=1}^n\prod_{j=1}^n\gcd^2(i,j)}=\dfrac{(n!)^{2n}}{(\prod_{i=1}^n\prod_{j=1}^n\gcd(i,j))^2}$$
现在的问题就集中到了这个式子：
$$\prod_{i=1}^n\prod_{j=1}^n\gcd(i,j)$$
这个玩意还是有套路的，枚举 $\gcd$，就能把 $\prod$ 变成 $\sum$ 啦：
$$\prod_{d=1}^nd^{\sum_{i=1}^n\sum_{j=1}^n[\gcd(i,j)=d]}$$
那就剩处理上面那个看起来非常非常套路的指数了，但如果您按照莫反的套路处理的话，会得到：
$$\sum_{p=1}^{\lfloor\frac{n}{d}\rfloor}\mu(p)\left\lfloor\dfrac{n}{dp}\right\rfloor^2$$
非常遗憾，这样并没有办法通过简单的整除分块继续优化了，所以我们先把式子拉回到刚刚同时消掉 $d$ 的时候：
$$\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{d}\rfloor}[\gcd(i,j)=1]$$
既然莫反走不通，看看能不能走某些积性函数的定义。互质，可以想到 $\varphi$，但这个式子并没有 $\varphi$ 的影子，不过如果原式子是这样就有了：
$$\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^i[\gcd(i,j)=1]=\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\varphi(i)$$
而这个式子跟原式子区别不大，简单算一下就有：
$$\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{d}\rfloor}[\gcd(i,j)=1]=2\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\varphi(i)-1$$
好像就可以了，套回原式子看看？：
$$\dfrac{(n!)^{2n}}{(\prod_{d=1}^nd^{2\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\varphi(i)-1})^2}$$
把那个 $-1$ 提到分子，再把分母的平方扔出来，最后再整体提个平方：
$$\dfrac{(n!)^{2n+2}}{(\prod_{d=1}^nd^{\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\varphi(i)})^4}=\left(\dfrac{(n!)^{n+1}}{(\prod_{d=1}^nd^{\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\varphi(i)})^2}\right)^2$$
结束了，预处理阶乘和 $\varphi$ 的前缀和，分母可以数论分块求出来，求完之后套式子就完事了。注意求 $\varphi$ 前缀和的时候，因为这玩意是在指数上的，不能对 $mod$ 取模，要对 $mod-1$ 取模。时间复杂度 $\mathcal{O}(n+T\sqrt{n})$。
```cpp
#include <cstdio>
const int N = 1e6 + 10, mod = 19260817; typedef long long ll;
int p[N], vis[N], phi[N], sum[N], fac[N], ifac[N], tp;
inline int ksm(int a, int b)
{
	int ret = 1;
	while (b)
	{
		if (b & 1) ret = 1ll * ret * a % mod;
		a = 1ll * a * a % mod; b >>= 1;
	}
	return ret;
}
inline void getP(int n)
{
	fac[0] = ifac[0] = vis[1] = phi[1] = 1;
	for (int i = 2; i <= n; ++i)
	{
		if (!vis[i]) p[++tp] = i, phi[i] = i - 1;
		for (int j = 1; j <= tp && i * p[j] <= n; ++j)
		{
			vis[i * p[j]] = 1;
			if (i % p[j] == 0) { phi[i * p[j]] = 1ll * phi[i] * p[j] % (mod - 1); break; }
			phi[i * p[j]] = 1ll * phi[i] * phi[p[j]] % (mod - 1);
		}
	}
	for (int i = 1; i <= n; ++i)
	{
		sum[i] = (sum[i - 1] + phi[i]) % (mod - 1);
		fac[i] = 1ll * fac[i - 1] * i % mod;
	}
	ifac[n] = ksm(fac[n], mod - 2);
	for (int i = n - 1; i >= 1; --i) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % mod;
}
int main()
{
	int T; scanf("%d", &T); getP(N - 1);
	while (T--)
	{
		int n, ans = 1; scanf("%d", &n);
		for (int l = 1, r; l <= n; l = r + 1)
		{
			r = (n / (n / l));
			ans = 1ll * ans * ksm(1ll * fac[r] % mod * ifac[l - 1] % mod, sum[n / l]) % mod;
		}
		ans = 1ll * ksm(1ll * ans * ans % mod, mod - 2) * ksm(fac[n], n + 1) % mod;
		ans = 1ll * ans * ans % mod; printf("%d\n", ans);
	}
	return 0;
}
```
不过，刚刚莫反的套路真的行不通吗？我们把式子再写一遍：
$$\prod_{d=1}^nd^{\sum_{p=1}^{\lfloor\frac{n}{d}\rfloor}\mu(p)\lfloor\frac{n}{dp}\rfloor^2}$$
改为枚举 $t=dp$：
$$\prod_{t=1}^n\left(\prod_{d|t}d^{\mu(\frac{t}{d})}\right)^{{\lfloor\frac{n}{t}\rfloor}^2}$$
里面可以像狄利克雷卷积一样 $\mathcal{O}(n\log n)$ 预处理，外面整除分块就好。总时间复杂度 $\mathcal{O}(n\log n+T\sqrt{n})$，比上面的做法预处理慢了点。

---

## 作者：Yajnun (赞：2)

### 补充O(nlogn)求1~n内所有点gcd(i,j)的连积的方法（蒟蒻瞎搞了一整个下午竟然搞出来了）
#### 对每个a，用gcd[a]记录从除a以外的gcd(a,i)的连积，即可递推求出gcd(i,j)的连积
#### 已知gcd[n]，考虑如何转移到gcd[k·n](k为质数）
1. 令gcd[k·n]=gcd[n]·k^(n-1),将gcd[n]中每个i扩大k倍

2. 令n=t·k^a1(t,k互质)，认为n·k被以t为长度分成了n·k/t个区间，除去编号为k的倍数的点已被记录，因为t,k互质，其余的区间与n·k的最大公约数的连积均为gcd[t]·t,这样的区间有n·k/t-n/t个，即令gcd[k·n]=(gcd[t]·t)^(n·(k-1)/t)

3. 利用线性筛素数及一系列预处理，即可以O(nlogn+T)的时间复杂度完成此题



```

主要代码：
int mod(int a,int b){while(a%b==0)a/=b;return a;}
ll ksm(ll a,ll b){ll ans=1;while(b){if(b&1)ans*=a;a*=a;b>>=1;}return ans;}

for(int i=1;i<=n;i++)gcd[i]=1;
for(int i=2;i<=n;i++)
	{
	if(!v[i])prime[++le]=i;
	for(int j=1;j<=le&&prime[j]*i<=maxn;j++)
		{v[prime[j]*i]=1;
        int k=mod(i,prime[j]);
		gcd[prime[j]*i]=gcd[i]*ksm(prime[j],i-1)*ksm(gcd[k]*k,(prime[j]-1)*i/k);
	if(i%prime[j]==0)break;
	}}
	for(int i=2;i<=n;i++)gcd[i]*=gcd[i]*gcd[i-1]*i;
```











---

## 作者：wdgm4 (赞：1)

# 前言

主要是我看好像题解区里对于分母如何取模（以及为什么）讲得不是很清楚~~可能是我太飞舞了~~。

# 正文

首先分析题意，明显可以发现的是，如果想使最后摆成一个正方形，且用的地板最小，那这个正方形的边长就是 $\operatorname{lcm}(a,b)$，那地板的数量就是 $\frac{\operatorname{lcm}(a,b)}{a}\times \frac{\operatorname{lcm}(a,b)}{b}$。

现在开始推柿子。

求：

$$\prod\limits_{i=1}^n\prod\limits_{j=1}^n\frac{\operatorname{lcm}^2(i,j)}{ij} \bmod19260817$$

首先知道 $\operatorname{lcm}(a,b)=\frac{ab}{\gcd(a,b)}$。

$$\prod\limits_{i=1}^n\prod\limits_{j=1}^n\frac{ij}{\gcd^2(i,j)}\bmod19260817$$

$$\frac{\prod\limits_{i=1}^n\prod\limits_{j=1}^nij}{(\prod\limits_{i=1}^n\prod\limits_{j=1}^n\gcd(i,j))^2}\bmod 19260817$$

先看分子。

$$\prod\limits_{i=1}^n\prod\limits_{j=1}^nij$$

$$\prod\limits_{i=1}^ni^nn!$$

$$(n!)^n(n!)^n$$

$$(n!)^{2n}$$

因为这是分子，所以计算时直接对 $19260817$ 取模就行了。

再看分母。

$$\prod\limits_{i=1}^n\prod\limits_{j=1}^n\gcd(i,j)$$

（那个平方等最后直接乘就行了）

$$\prod\limits_{i=1}^n\prod\limits_{j=1}^n\sum\limits_{d=1}^nd[\gcd(i,j)=d]$$

显然，对于任一个 $i$ 和 $j$，$\gcd(i,j)$ 有唯一确定的值，且 $[...]$ 里东西如果为假就为 $0$，所以就用的是求和。

$$\prod\limits_{d=1}^n\prod\limits_{i=1}^n\prod\limits_{j=1}^nd[\gcd(\frac{i}{d},\frac{j}{d})=1][d|i][d|j]$$

$$\prod\limits_{d=1}^n\prod\limits_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\prod\limits_{j=1}^{\left\lfloor\frac{n}{d}\right\rfloor}d[\gcd(i,j)=1]$$

为方便，设 $m=\left\lfloor\frac{n}{d}\right\rfloor$。

$$\prod\limits_{d=1}^nd^{\sum\limits_{i=1}^m\sum\limits_{j=1}^m[\gcd(i,j)=1]}$$

只看指数。

$$\sum\limits_{i=1}^m\sum\limits_{j=1}^m[\gcd(i,j)]$$

可以发现这和[仪仗队](https://www.luogu.com.cn/problem/P2158)里的柿子一模一样，但我还是小推一下。

$$2\times\sum\limits_{i=1}^m\sum\limits_{j=1}^i[\gcd(i,j)=1]-1$$

$$2\times\sum\limits_{i=1}^m\varphi(i)-1$$

再看：

$$d^{2\times\sum\limits_{i=1}^m\varphi(i)-1} \bmod 19260817$$

知道 $a^{p-1} \equiv 1\pmod p$（$p$ 为质数且 $\gcd(a,p)=1$）（费马小定理）。

相当于当我们求 $2\times\sum\limits_{i=1}^n\varphi(i)-1$ 时，我们可以将其对 $19260816$（$19260817-1$）取余，这样我们提前求的时候就不怕爆 `long long` 了。QWQ

所以我们要求的就变成了:

$$\prod\limits_{d=1}^nd^{f(\left\lfloor\frac{n}{d}\right\rfloor)} \bmod 19260817$$

（$f(x)=2\times\sum\limits_{i=1}^x\varphi(i)-1$）

如果暴力求，时间复杂度会爆炸，所以考虑优化。显然可以用数论分块优化，对于枚举的 $\left\lfloor\frac{n}{d}\right\rfloor$，它的贡献为 $(\frac{r!}{(l-1)!})^{f(\left\lfloor\frac{n}{d}\right\rfloor)}$，所以可以再套一个快速幂即可。

再往回看，现在整体的柿子就变成了：

$$\frac{(n!)^{2n}}{(\prod\limits_{d=1}^nd^{f(\left\lfloor\frac{n}{d}\right\rfloor)})^2} \bmod 19260817$$

所以分别求出分子和分母，记得将分母变成平方并转成逆元即可。

# 代码

```cpp
#include<bits/stdc++.h>
#define XD 114514
#define MAXN 1000010
#define ll long long
using namespace std;
const int mod=19260817;
const int mod2=19260816;//mod-1
int t,n,ans,ans1,ans2;
int fac[MAXN],phi[MAXN],num[MAXN];
//num 为欧拉函数前缀和，fac 为阶乘
vector<int> prm;
bool vis[MAXN];
void sieve(){
	phi[1]=num[1]=1;
	for(int i=2;i<=1e6;i++){
		if(!vis[i]) prm.push_back(i),phi[i]=i-1;
		num[i]=(num[i-1]+phi[i])%mod2;
		for(auto j:prm){
			if(i*j>1e6) break;
			vis[i*j]=true;
			if(i%j==0){
				phi[i*j]=phi[i]*j;break;
			}
			phi[i*j]=phi[i]*phi[j];
		}
	}
	fac[0]=1;
	for(int i=1;i<=1e6;i++) fac[i]=1ll*fac[i-1]*i%mod;
}
int power(int x,int y){//快速幂
	int nem=1;
	while(y){
		if(y&1) nem=1ll*nem*x%mod;
		x=1ll*x*x%mod;y>>=1;
	}
	return nem;
}
int inv(int x){//求逆元
	if(x==0 or x==1) return 1;
	return power(x,mod-2)%mod;
}
void calc(){//数论分块
	int r;ans2=1;
	for(int l=1;l<=n;l=r+1){
		r=n/(n/l);
		ans2=1ll*ans2*power(1ll*fac[r]*inv(fac[l-1])%mod,(2ll*num[n/l]-1)%mod2)%mod;
	}
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	sieve();
	cin>>t;
	while(t--){
		cin>>n;
		ans1=power(fac[n],2*n);
		calc();
		ans2=1ll*ans2*ans2%mod;
		ans=1ll*ans1*inv(ans2)%mod;
		cout<<ans<<"\n";
	}
	return 0;
}
```


---

## 作者：MarchKid_Joe (赞：1)

# [天守阁的地板](https://www.luogu.com.cn/problem/P4917)

## 前言

题解区全是 $\varphi$ 反演，这里提供一个 $\mu$ 反演，整除分块套整除分块，时间复杂度 $O(T\times n^{\frac{3}{4}})$。

## 证明

乘法的好处就是随便分裂，首先将式子拆为两部分：

$$
\displaystyle\prod_{i=1}^{n}\displaystyle\prod_{j=1}^{n}ij\times\displaystyle\prod_{i=1}^{n}\displaystyle\prod_{j=1}^{n}gcd(i,j)^{-2}
$$

先考虑第一部分：

$$
\begin{aligned}
\displaystyle\prod_{i=1}^{n}\displaystyle\prod_{j=1}^{n}ij
&=\displaystyle\prod_{i=1}^{n}i^n\times n!\\
&=(\displaystyle\prod_{i=1}^{n}i)^n\times\displaystyle\prod_{i=1}^{n}n!\\
&=n!^n\times n!^n\\
&=n!^{2n}
\end{aligned}
$$

再考虑第二部分：

$$
\begin{aligned}
\displaystyle\prod_{i=1}^{n}\displaystyle\prod_{j=1}^{n}\gcd(i,j)
&=\displaystyle\prod_{d=1}^{n}d^{\sum_{i=1}^{n}\sum_{j=1}^{n}[\gcd(i,j)=d]}\\
&=\displaystyle\prod_{i=1}^{n}d^{\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{d}\rfloor}[\gcd(i,j)=1]}
\end{aligned}
$$

设为 $f(n)={\displaystyle\sum_{i=1}^{n}\displaystyle\sum_{j=1}^{n}[\gcd(i,j)=1]}$，套路反演：

$$
\begin{aligned}
\displaystyle\sum_{i=1}^{n}\displaystyle\sum_{j=1}^{n}[\gcd(i,j)=1]
&=\displaystyle\sum_{i=1}^{n}\displaystyle\sum_{j=1}^{n}\displaystyle\sum_{d\mid \gcd(i,j)}\mu(d)\\
&=\displaystyle\sum_{d=1}^{n}\mu(d){\lfloor\frac{n}{d}\rfloor}^2
\end{aligned}
$$

$f$ 函数对 $n$ 数论分块就行了。

原式变为：

$$
\displaystyle\prod_{d=1}^{n}d^{f(\lfloor\frac{n}{d}\rfloor)}
$$

然后直接预处理阶乘然后对 $d$ 数论分块就行了。

最后答案就是：

$$
\frac{n!^{2n}}{(\prod_{d=1}^{n}d^{f(\lfloor\frac{n}{d}\rfloor)})^2}
$$

结束了。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace calc
{
    #define ll long long
    const int N = 1e6 + 5;
    const int MOD=19260817;
    inline int Add(int x,int y){return x+y>=MOD?x+y-MOD:x+y;}
    inline int Red(int x,int y){return x<y?x-y+MOD:x-y;}
    inline int Mul(int x,int y){return (ll)x*y%MOD;}
    template <typename TP,typename...Etc>inline int Add(TP n,TP m,Etc ...etcs){return Add(Add(n,m),etcs...);}
    template <typename TP,typename...Etc>inline int Red(TP n,TP m,Etc ...etcs){return Red(Red(n,m),etcs...);}
    template <typename TP,typename...Etc>inline int Mul(TP n,TP m,Etc ...etcs){return Mul(Mul(n,m),etcs...);}
    inline int Ksm(int x,ll y,int ans=1){while(y>0){if(y&1) ans=Mul(ans,x);x=Mul(x,x);y>>=1;}return ans;}
    inline int Inv(int x){return Ksm(x,MOD-2);}
}
using namespace calc;
vector<int> p;
bitset<N> vis;
int mu[N];
int sum[N];
int fac[N], inv[N];
int n;
inline void Euler(int n)
{
    mu[1] = 1;
    for (int i = 2; i <= n; i++)
    {
        if (!vis[i])
        {
            mu[i] = -1;
            p.emplace_back(i);
        }
        for (int j : p)
        {
            if (i * j > n)
                break;
            vis[i * j] = 1;
            if (i % j == 0)
                break;
            mu[i * j] = -mu[i];
        }
    }
}
inline void Initial(int n)
{
    for (int i = 1; i <= n; i++)
        sum[i] = sum[i - 1] + mu[i];
    fac[0] = inv[0] = 1;
    for (int i = 1; i <= n; i++)
        fac[i] = Mul(fac[i - 1], i);
    inv[n] = Inv(fac[n]); --n;
    for (int i = n; i >= 1; i--)
        inv[i] = Mul(inv[i + 1], i + 1);
}
ll rem[N];
inline ll f(int n)
{
    if (rem[n]) return rem[n];
    ll ans = 0;
    for (int l = 1, r; l <= n; l = r + 1)
    {
        r = n / (n / l);
        ans += (ll)(sum[r] - sum[l - 1]) * (n / l) * (n / l);
    }
    return rem[n] = ans;
}
signed main()
{
    int T;
    cin >> T;
    Euler(1e6);
    Initial(1e6);
    while (T --> 0)
    {
        int ans = 1;
        cin >> n;
        for (int l = 1, r; l <= n; l = r + 1)
        {
            r = n / (n / l);
            ans = Mul(ans, Ksm(Mul(fac[r], inv[l - 1]), f(n / l)));
        }
        cout << Mul(Ksm(fac[n], n * 2), Inv(Mul(ans, ans))) << '\n';
    }
    return 0;
}
```

---

## 作者：pomelo_nene (赞：1)

## P4917 天守阁的地板

求：

$$∏_{i=1}^N∏_{j=1}^N \dfrac{\operatorname{lcm}(i,j)}{\gcd(i,j)}$$

多组询问。

$$\prod_{i=1}^N\prod_{j-1}^N \dfrac{ij}{\gcd(i,j)^2}$$

$$\prod_{i=1}^N \prod_{j=1}^N ij \times \dfrac{1}{\gcd(i,j)^2}$$

$$\prod_{i=1}^N\prod_{j=1}^{N} ij \times \prod_{i=1}^N\prod_{j=1}^{N} \dfrac{1}{\gcd(i,j)^2}$$

左边一式显然等于 $(n!)^{2n}$。

考虑计算右边一式：

$$(\prod_{d=1}^N d^{\sum_{i=1}^N \sum_{j=1}^N[\gcd(i,j)=d]})^{-2}$$

可见指数是仪仗队，原式化为：

$$(n!)^{2n} \times (\prod_{d=1}^Nd^{2\times \sum_{i=1}^{\lfloor \frac{n}{d}\rfloor} \varphi(i)-1})^{-2}$$

$\sum_{i=1}^{\lfloor \frac{n}{d} \rfloor}\varphi(i)$ 和 $n!$ 可以在线性筛 $O(n)$ 中求得。因为 $\lfloor \dfrac{n}{d}\rfloor \leq 2\sqrt n$，所以我们可以在这里进行优化，时间复杂度 $O(T \sqrt n \log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef __int128 LL;
char buf[1<<21],*p1=buf,*p2=buf;
#define getchar() (p1==p2 && (p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
LL read()
{
	LL x=0,f=1;
	char c=getchar();
	while(c<'0' || c>'9')
	{
		if(c=='-')	f=-1;
		c=getchar();
	}
	while(c>='0' && c<='9')	x=(x<<1)+(x<<3)+(c^'0'),c=getchar();
	return x*f;
}
void write(LL x)
{
	if(x<0)	putchar('-'),x=-x;
	if(x>9)	write(x/10);
	putchar(x%10+'0');
}
const LL MOD=19260817;
LL T,phi[1000005],fac[1000005],prime[1000005],cnt;
bool vis[1000005];
LL exgcd(LL a,LL b,LL &x,LL &y)
{
	if(!b)
	{
		x=1,y=0;
		return a;
	}
	LL gcd=exgcd(b,a%b,x,y);
	LL t=x;
	x=y;
	y=t-a/b*y;
	return gcd;
}
LL inv(LL p)
{
	if(!p || p==1)	return 1;
	LL x,y;
	exgcd(p,MOD,x,y);
	return (x%MOD+MOD)%MOD;
}
LL QuickPow(LL a,LL x)
{
	LL ans=1,base=a;
	while(x)
	{
		if(x&1)	ans*=base,ans%=MOD;
		base*=base;
		base%=MOD;
		x>>=1;
	}
	return ans;
}
void shai(LL upper)
{
	fac[0]=fac[1]=phi[1]=1;
	for(LL i=2;i<=upper;++i)
	{
		fac[i]=fac[i-1]*i%MOD;
		if(!vis[i])	prime[++cnt]=i,phi[i]=i-1;
		for(LL j=1;j<=cnt && i*prime[j]<=upper;++j)
		{
			vis[i*prime[j]]=true;
			if(i%prime[j])	phi[i*prime[j]]=phi[i]*phi[prime[j]]%MOD;
			else
			{
				phi[i*prime[j]]=phi[i]*prime[j]%MOD;
				break;
			}
		}
	}
	for(LL i=2;i<=upper;++i)	phi[i]+=phi[i-1],phi[i]%=(MOD-1);
}
int main(){	
	shai(1000000);
	T=read();
	while(T-->0)
	{
		LL n=read();
		LL p=QuickPow(fac[n],2*n);
		LL ans=1;
		for(LL l=1,r;l<=n;l=r+1)
		{
			r=n/(n/l);
			LL gx=2*phi[n/l]-1;
			LL base=(fac[r]*inv(fac[l-1]))%MOD;
			ans*=QuickPow(base,gx);
			ans%=MOD;
		}
		write(p*inv(ans)%MOD*inv(ans)%MOD);
		puts("");
	}
	return 0;
}
```

$\ $

---

## 作者：qwaszx (赞：1)

神仙 Yajnun 写的题解有点令人谔谔，我来写一个好懂的.

化式子部分请看其他题解.

现在需要在 $O(n\log n)$ 的时间内对于 $1\leq x\leq n$ 求出

$$g(x)=\prod_{i=1}^x\prod_{j=1}^x \gcd(i,j)$$

那么显然有

$$
g(x)=g(x-1)\cdot x\left(\prod_{j=1}^{x-1}\gcd(j,x)\right)^2
$$

于是我们转而求出

$$
f(n)=\prod_{i=1}^{n-1}\gcd(i,n)
$$

虽然这个东西显然并不积性，我们还是来考虑线筛，需要用 $f(n)$ 转移到 $f(pn)$，其中 $p$ 是 $pn$ 的最小质因子.设 $n=tp^e$，其中 $\gcd(t,p)=1$，即  $t$ 是 $n$ 除掉所有因子 $p$ 得到的结果.

首先计算所有 $p|i$  的答案，那么显然是

$$
\prod_{i=1}^{n-1}\gcd(pi,pn)=p^{n-1}f(n)
$$

接下来考虑 $p\not| i$ 的部分，由于 $\gcd(i,p)=1$ 所以我们有 $\gcd(i,pn)=\gcd(i,t)$，那么需要求的就是

$$
\begin{aligned}
&\prod_{i=1}^{pn}\gcd(i,t)^{[i\bmod p\neq 0]}\\
=&\prod_{k=0}^{pn/t-1}\prod_{r=1}^t\gcd(kt+r,t)^{[(kt+r)\bmod p\neq 0]}\\
=&\prod_{r=1}^t\gcd(r,t)^{\sum_{k=0}^{np/t-1}[(kt+r)\bmod p\neq 0]}
\end{aligned}
$$

现在来考察

$$
\sum_{k=0}^{np/t-1}[(kt+r)\bmod p\neq 0]
$$

一个经典结论(具体数学4.8的开头)是 $0,t\bmod p,2t\bmod p,\cdots ,(p-1)t$ 这些数是 $0,1,2,\cdots p-1$ 的一个排列，那么加上一个 $r$ 之后相当于对这个排列进行移位. 于是对于每一个 $r$ 我们都有 $(kt+r)\bmod p(0\leq k<\frac{np}{t})$ 得到的是 $0,1,\cdots ,p-1$ 的 $\dfrac{n}{t}$ 份复制，每份复制里都有 $p-1$ 个数与 $p$ 互质，于是我们得到

$$
\sum_{k=0}^{np/t-1}[(kt+r)\bmod p\neq 0]=\frac{n(p-1)}{t}
$$

于是上面那个式子就是

$$
\prod_{r=1}^t\gcd(r,t)^{n(p-1)/t}=(tf(t))^{n(p-1)/t}
$$

这样就可以转移了.瓶颈在于快速幂的 $\log$，感觉上是可以处理一些东西做到 $\log\log$ 的，但是我不会.

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N=1000005,mod=19260817;
int f[N],p[N],prime[N],res[N],fac[N],cnt,n,T;
int qpower(int a,int b){int ans=1;for(;b;b>>=1,a=1ll*a*a%mod)if(b&1)ans=1ll*ans*a%mod;return ans;}
void make(int n)
{
    f[1]=1;
    for(int i=2;i<=n;i++)
    {
        if(!p[i])prime[++cnt]=i,f[i]=1,res[i]=1;
        for(int j=1;j<=cnt&&i*prime[j]<=n;j++)
        {
            int x=i*prime[j];p[x]=1;
            if(i%prime[j])res[x]=i;else res[x]=res[i];
            int t=res[x];
            f[x]=1ll*f[i]*qpower(prime[j],i-1)%mod*qpower(1ll*f[t]*t%mod,i/t*(prime[j]-1))%mod;
            if(i%prime[j]==0)break;
        }
    }
    for(int i=2;i<=n;i++)f[i]=1ll*f[i]*f[i]%mod*f[i-1]%mod*i%mod;
    fac[1]=1;for(int i=2;i<=n;i++)fac[i]=1ll*fac[i-1]*i%mod;
    for(int i=1;i<=n;i++)fac[i]=qpower(fac[i],i);
}
int sqr(int x){return 1ll*x*x%mod;}
int main()
{
    make(1000000);
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d",&n);
        printf("%d\n",sqr(1ll*fac[n]*qpower(f[n],mod-2)%mod));
    }
}
```

---

## 作者：Starrydream (赞：1)


# Luogu P4917 天守阁的地板

## 题目描述

为了使万宝槌能发挥出全部魔力,小碗会将买来的地板铺满一个任意边长的正方形(地板有图案,因此不允许旋转,当然,地板不允许重叠)来达到最大共鸣

现在,她能够买到规格为a*ba∗b的地板,为了省钱,她会购买尽可能数量少的地板

现在,她想知道对于每一对a,b(1≤a,b≤n)a,b(1≤a,b≤n),她最少需要购买的地板数量

由于输出可能很大,所以你只需要输出所有答案的乘积即可,为了避免高精度,小碗很良心的让你将答案对19260817取模

## 输入输出格式

输入格式：

第一行一个整数T,表示数据组数
下面T行,每行一个整数n

输出格式：

共TT行,每行一个整数,表示取模后的答案



## 输入输出样例

输入样例#1：

```
4
1
2
3
100
```

输出样例#1：

```
1
4
1296
18996121
```





![img](Images/34374.png)

## 题解

这真是一道好题。

简述题意，对于任意小于n的x*y矩形，将它密铺成正方形所用的最小数量为v，求所有v的和。

显然变成一个正方形，边长得相等，设最小q个在x的方向，t个在y的方向，所用个数为t * q
$$
\frac{x}{y} = \frac{t}{q}
$$
显然当x,y约分至互质的情况时t * q最小

因此我们所求的就是
$$
\prod_{i=1}^{n}\prod_{j=1}^{n}\frac{ij}{gcd(i,j)^2}
$$
由题目数据可知，我们要么On求出1~n的所有答案O1查询，要么对于每次查询是一个线性复杂度以下的算法。

首先看分子的处理
$$
\prod_{i=1}^{n}\prod_{j=1}^{n}ij
$$

$$
\prod_{i=1}^{n}i(\prod_{j=1}^{n}j)
$$

这就是
$$
(n!)^{2}
$$
那么我们该考虑分母的积该如何算了 , 算出来后乘上逆元即可。
$$
\prod_{i=1}^{n}\prod_{j=1}^{n}gcd(i,j)^2
$$
我们可以最后平方
$$
(\prod_{i=1}^{n}\prod_{j=1}^{n}gcd(i,j))^2
$$
我们可以用常用的数论技巧来优化
$$
\prod_{i=1}^{n}\prod_{j=1}^{n}gcd(i,j)
$$

$$
\prod_{k=1}^{n}k^{\sum_{i=1}^{n}\sum_{j=1}^{n}[gcd(i,j)==k]}
$$

对于
$$
\sum_{i=1}^{n}\sum_{j=1}^{n}[gcd(i,j)==k]
$$

$$
\sum_{i=1}^{n/k}\sum_{j=1}^{n/k}[gcd(i,j)==1]
$$



这就是
$$
2\sum_{i=1}^{n/k}\varphi(i)-1
$$


因此每次询问的答案的**分母**就是
$$
\prod_{k=1}^{n}k^{2\sum\limits_{i=1}^{n/k}\varphi(i)-1}
$$
最后的答案是
$$
\frac{(n!)^{2}}{(\prod_{k=1}^{n}k^{2\sum\limits_{i=1}^{n/k}\varphi(i)-1})^2}
$$
显然欧拉函数作为积性函数可以线性筛，并且只需要一次即可，然后从指数幂的特点来看再用前缀和来优化欧拉函数求和，这样复杂度是
$$
O(n+Tnlogn)
$$
这样做期望得分60

我们可以对分子的k做一个简单的根号优化

有一个著名的结论，对于
$$
(n/d)
$$
的取值不超过
$$
2\sqrt{n}
$$
个，这个就不证明了挺麻烦的，进阶指南上有。

那么我们可以对于k的指数幂一样的项一起处理，这样时间复杂度就是
$$
O(n+2T\sqrt{n}logn)
$$

Code:

```c++
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <iostream>
#define mod 19260817
#define ll long long
#define maxn 1000005
ll n , T , phi[maxn] , prime[maxn/8] , fac[maxn] , cnt;
bool inprime[maxn];
inline void euler(ll n)
{
    phi[1] = 1;
    for(ll i = 2 ; i <= n ; ++i)
    {
        if(!inprime[i]) phi[i] = i - 1 , prime[++cnt] = i;
        for(int j = 1 ; j <= cnt && i * prime[j] <= n ; ++j)
        {
            inprime[i*prime[j]] = true;
            if(!(i%prime[j])) phi[i*prime[j]] = prime[j] * phi[i];
            else phi[i*prime[j]] = phi[i] * phi[prime[j]];
            if(!(i%prime[j])) break;
        }
    }
    for(int i = 1 ; i <= n ; ++i)
        phi[i] += phi[i-1] ;
}
ll exgcd(ll a , ll b , ll& x , ll& y)
{
    if(!b)
    {
        x = 1 , y = 0;
        return a;
    }
    ll g = exgcd(b , a % b , y , x);
    y -= a/b * x;
    return g;
}
ll inv(ll k)
{
    if(!k || k == 1) return 1;
    ll x , y;
    ll g = exgcd(k,mod,x,y);
    x = (x % mod + mod) % mod;
    return x;
}
inline void pre(ll n)
{
    fac[0] = fac[1] = 1;
    for(int i = 2 ; i <= n ; ++i)
        fac[i] = fac[i-1] * i % mod;
}
inline ll pow(ll x , ll y)
{
    ll ans = 1 , base = x;
    while(y)
    {
        if(y&1) ans = ans * base % mod;
        base = base % mod * base % mod;
        y /= 2;
    }
    return ans;
}
void solve(ll n)
{
    ll ans = pow(fac[n] , 2 * n);
    ll frac = 1;
    ll gx = 0;
    for(int i = 1 ; i <= n ; i = gx + 1)
    {
        gx = n/(n/i);
        // puts("OK");
        ll pw = 2 * phi[n/i] - 1;
        ll base = (fac[gx] % mod * inv(fac[i-1])) % mod ;
        frac = frac * pow(base , pw) % mod;
    }
    printf("%lld\n",ans * inv(frac) % mod * inv(frac) % mod);
}
int main()
{
    scanf("%lld",&T);
    euler(1000000);
    pre(1000000);//the fac
    while(T--)
    {
        scanf("%lld",&n);
        solve(n);
    }
}

```


---

## 作者：1saunoya (赞：0)

$\prod_i \prod_j \frac{i\times j}{\gcd(i,j)^2} $。

注意到 $\prod_i \prod_j i \times j= (n!)^{2\times n}$。

然后我们算一下 $\prod_i \prod_j \gcd(i,j) $ 即可。

先枚举一下 $\prod_d \prod_i^{n/d} \prod_j^{n/d}[\gcd(i,j)==1]?d:1$。

$\large \prod_{d}^{\sum_{i}^{n/d} \sum_{j}^{n/d}[\gcd(i,j)==1]}$

提出来指数。

$\sum_{i}^{n/d} \sum_{j}^{n/d}[\gcd(i,j)==1]$

$\sum_{d|x}\mu_d = [x==1]$。

$\sum_{i}^{n/d} \sum_{j}^{n/d}\sum_{k|\gcd(i,j)}\mu_k$。

$\sum_{k}\mu_k \frac{n}{dk} \times \frac{n}{dk}$。

$\large \prod_{d}^{\sum_{k}\mu_k \frac{n}{dk} \times \frac{n}{dk}}$。


发现好像需要 $T \times n \log n$。（好像有人写了这个卷一下然后搞搞的做法但是我并不太会）

换一种想法。

$\sum_{i}^{n/d} \sum_{j}^{n/d}[\gcd(i,j)==1]$

$2\times \sum_i^{n/d} \varphi_i-1$。

于是变成了

$\large \prod_d^{2\times \sum_i^{n/d} \varphi_i-1}$。


然后就做完了，整合一下是

$(n!)^{2\times n} \times \frac{1}{(\large \prod_d^{2\times \sum_i^{n/d} \varphi_i-1})^2}$。

发现指数可以整除分块于是做完了。

---

## 作者：ELLIAS (赞：0)

## 补充60分方法
### NULL
正解by YSJ大佬:

https://www.luogu.org/blog/BakaCirno/tian-shou-ge-di-di-ban-ti-xie
### EINS
本蒟蒻验题时的做法:
题目意思是求lcm的连积,也就是${i * j}$的连积除以${gcd(i, j)}$的连积.${i * j}$的连积可以很快求出.对于${gcd(i, j)}$的连积,可以逆向求出${1-n}$每个数作为${gcd}$会出现多少次,这样可以使用快速幂求出${gcd}$的连积,这样就可以得到60分.
### ZWEI
主要代码如下:
```cpp
for (Re long long i = n; i > 1; -- i)
{
	dp[i] = (n / i) * (n / i);
	for (Re long long j = i << 1; j <= n; j += i) dp[i] -= dp[j];
	tans = tans * poww (i * i % modn, dp[i]) % modn;
}

for (Re long long i = n; i; -- i) ans = ans * poww (i, tmp) % modn;

writelen (ans * poww (tans, modn - 2) % modn);
```

---


# 礼物

## 题目背景

由于你出色的完成了前面两道题目，善良的 __stdcall 决定给你一个小礼物，给拼搏在 AK 这套题之路上的你，一个有力的援助。

## 题目描述

__stdcall 决定给你 $n$ 个礼物，每个礼物有一个魔力值 $a_i$。

这些礼物的魔力值都是独一无二的，两两互不相同。这些礼物都有着神奇的魔力，如果两个礼物 $i, j$ 的魔力值满足 $a_i \operatorname{bitand} a_j \ge \min(a_i, a_j)$，那么这两个礼物的魔力将会相互抵消，因此它们不能放在一个箱子里。

这里的 $\operatorname{bitand}$ 表示按位与运算，如果你对这一运算不够了解，请参考：<https://baike.baidu.com/item/%E6%8C%89%E4%BD%8D%E4%B8%8E/9601818>。

作为发礼物苦力的 ljt12138 的箱子并不多，不过幸运的是，每个箱子都足够大。现在他请求你帮助他合理分配，用**尽可能少**的箱子装下所有礼物。换言之，使得每个礼物都被恰好装入一个箱子中，且同一个箱子中的礼物魔力不会相互抵消。如果有多种合法的方案，你只需要给出**任意一种**。

ljt12138 十分善良，如果你只能求出所需要的箱子数，也可以获得该测试点 $60\%$ 的分数，关于这一点，请参考下面的提示与说明。

## 说明/提示

### 附加样例

你可以在  <https://pan.baidu.com/s/1A8_ZA4yXXi5y6771x9JKUw> 下载附加样例。

### 关于输出方案

- 如果你在第一行输出了 $0$，而正确回答了最小所需的箱子数，将获得测试点 $60\%$ 的分数。
- 如果你在第一行输出了 $1$，正确回答了最小所需的箱子数，但没有给出正确的方案，也将获得该测试点 $60\%$ 的分数。
- 如果你没有正确回答最小所需的箱子数，将不会获得该测试点的分数。
- 请选手注意，如果你未按照上述格式输出答案，将无法获得任何分数。

数据 $n, k$ 的关系由下面的表格给出：

|数据编号| $n$ | $k$ |
|:----:|:----:|:----:|
|$1$|$5$|$3$|
|$2$|$6$|$3$|
|$3$|$7$|$10$|
|$4$|$8$|$10$|
|$5$|$16$|$7$|
|$6$|$17$|$8$|
|$7$|$17$|$9$|
|$8$|$17$|$20$|
|$9$|$2\times 10^3$|$17$|
|$10$|$2.5\times 10^3$|$18$|
|$11$|$3\times 10^3$|$19$|
|$12$|$3\times 10^3$|$20$|
|$13$|$2.5\times 10^4$|$15$|
|$14$|$2.5\times 10^4$|$15$|
|$15$|$5\times 10^4$|$16$|
|$16$|$5\times 10^4$|$16$|
|$17$|$2.5\times 10^5$|$18$|
|$18$|$5\times 10^5$|$19$|
|$19$|$10^6$|$20$|
|$20$|$10^6$|$20$|

## 样例 #1

### 输入

```
5 3
0 4 7 1 6 
```

### 输出

```
1
4
1 0
2 1 4
1 6
1 7 ```

# 题解

## 作者：Huami360 (赞：23)

其实呢这题没必要搞的那么复杂。无需建图跑拓扑排序。

仍然是官方题解满分做法的思路，只不过我们把连边改成$DP$。

设$f[i]$表示以$i$这个值结尾的最长链的长度

则有

$$f[i]=\max f[i\text{二进制表示下少一个}1]+v[i]$$

$v[i]$表示数列里是否存在这个数，是则为$1$。

然后怎么实现少一个$1$呢。

只需要定义一个$j=i$，每次$i\ xor\ (j\&-j),j=j\ xor\ j\&-j$

$j\&-j$即$lowbit$运算，取出二进制表示下最后一个$1$，

$i\ xor\ (j\&-j)$就是删掉$i$中$j$的最后一位，同时$j$每次删去一位，我们就能实现每次删去$i$中的一个$1$了。

去掉快读后代码其实很短，不开氧气跑$484ms$
```cpp
#include <cstdio>
#include <vector>
#define re register
const int MAXN = 2000010;
namespace IO{
    int xjc; char ch;
    inline int read(){
        xjc = 0; ch = getchar();
        while(ch < '0' || ch > '9') ch = getchar();
        while(ch >= '0' && ch <= '9'){ xjc = xjc * 10 + ch - '0'; ch = getchar(); }
        return xjc;
    }
}using namespace IO;
inline int max(int a, int b){
    return a > b ? a : b;
}
int f[MAXN], v[MAXN], n, k;
std::vector <int> g[30];
int main(){
    n = read(); k = read();
    for(re int i = 1; i <= n; ++i) v[read()] = 1;
    int Max = (1 << k) - 1;
    for(re int i = 0; i <= Max; ++i){
       for(re int j = i; j; j ^= j & -j) f[i] = max(f[i], f[i ^ (j & -j)]);
       if(v[i]) g[++f[i]].push_back(i);
    }
    printf("1\n%d\n", f[Max]);
    for(int i = 1; i <= f[Max]; ++i){
       printf("%d ", g[i].size());
       for(std::vector <int> :: iterator it = g[i].begin(); it != g[i].end(); ++it) printf("%d ", *it);
       putchar('\n');
    }
    return 0;
}

```

---

## 作者：__stdcall (赞：17)

# Gift Solution

标签（空格分隔）： 题解

---

一句话题解：偏序集最小反链覆盖等于最长链，优化建图。

## 20pt做法

注意到前四个测试点中，$n, k$都很小。那么只要暴力枚举每个点的编号就好了，复杂度$O(n^n)$。

## 40pt做法

前八个测试点都满足$n\le 17$，很容易考虑到状态压缩的动态规划。首先暴力枚举所有礼物的每个子集，判断是否存在两个元素违反条件，求出所有可行的子集，这一步的复杂度是$O(2^n\times n^2)$的。然后考虑dp，设$dp[S]$表示集合$S$所需的最少盒子，则有：

$$dp[S] = \min_{U\in S, U\ is\ good} dp[S-U]+1$$

这一步的复杂度是$O(3^n)$，总复杂度是$O(3^n+2^n\times n^2)$，可以通过前八个测试点。

## 60pt做法(1)

考虑式子的意义：$A\& B \ge min(A, B)$，稍有经验的选手可以一眼看出，如果将$A,B$看作集合，这个式子的意义是两个集合的交要不小于其中一个集合。那么这意味这其中一个集合是另一个集合的子集。对于一个箱子，事实上就是要求代表的集合两两互不包含。

考虑集合包含关系是一个偏序关系。不妨当$A\subseteq B$的时候从$A$向$B$连边，构成一个有向无环图。由于同一个箱子内的集合两两不能包含，不妨考虑这个DAG上最长的链。设其长度为$L$。那么这个链上的元素必然都被放到不同的箱子里，因此答案$Ans\ge L$。

对DAG最简单的算法就是拓扑排序，考虑拓扑排序的过程——每次将没有入度的点删掉。显然，所有没有入度的点之间两两互不包含。那么我们只要每次取出所有没有入度的点放进一个箱子，经过$L$次就可以将整个图取完。因此答案$Ans=L$。

那么我们用$O(n^2)$的复杂度暴力的建出这个图，然后跑一个拓扑排序。与经典的拓扑排序不同的是，每次应当将队列中所有的点都取出作为一个子集。由于拓扑排序的复杂度是线性的，时间复杂度是$O(n^2)$。

用这个做法容易证明，答案至多是$k+1$。因为最长链所代表的集合每次至少增加一个元素。

## 60pt做法(2)

这是一个在验题的时候偶然发现的做法：将所有元素从小到大排序，每次新增一个集合，暴力判断每个未被分配的元素能否加入当前集合。容易发现，这个做法和上面的做法本质上是相同的。事实上，这个做法的复杂度是$O(kn^2)$，也可以通过60分的部分。

## 80pt做法(1)

考虑60pt做法(1)，容易发现这个建图实在太暴力了。由于元素两两不同，事实上，对于每个礼物魔力值所代表的集合枚举子集，也可以建出图。这样做的复杂度是$O(3^k)$的，可以得到$80-85$分。

## 80pt做法(2)

考虑60pt做法(2)，这个做法仍然可以用枚举子集的技巧优化，复杂度是$O(k3^k)$

## 不知道多少分做法

考虑上面的80pt做法(2)，这个题对应的情景和$CTSC2018\ Gift$对应的情景很像。如果用那个题的分块技巧，可能可以得到更高的分数。

## 满分做法

考虑进一步优化建图：这次我们将边的数量限制在$O(nk)$。考虑从每一个魔力值对应的集合，只连向多一个元素到达的集合，例如从$0000$连向$1000, 0100, 0010, 0001$四个位置。这样图的结构仍然是对的。但很多节点都是无用的了。那么只需要在原来的算法上做一些改动——对于有用点，仍然像以前一样每次将所有的点取出作为一个子集；对于无用点，直接扔进另一个队列，并不断的将这个队列清空即可。这样做最后的复杂度就是$O(nk)$的了，这个问题得到了完美的解决。

## 关于spj

出题人能想到最好的spj复杂度是$O(nk^2)$的...如果有更好的想法欢迎来找出题人讨论2333

---

## 作者：chenzida (赞：7)

前言：这个题是老师留的。。。感觉挺难的，没有想到会将没有出现过的数也要开一个数组去转移

题目大意：有 $n$ 个物品，分成尽量少的组，使得没有一组中有两个数二进制 $1$ 的位置完全包含。比如 $6$ 和 $5$，也就是 $(110)_2$ 和 $(101)_2$ 就不存在二进制位包含。但是如果是 $6$ 和 $4$，也就是 $(110)_2$ 和 $(100)_2$ 就是完全包含的关系。

题目解析：我们分成求出答案和输出方案两部分说。

求出答案：

有一个 $O(n^2)$ 算法：

$dp[i]$ 表示第 $i$ 个数要放在第几组中，转移就是
$$dp[i]=\max(dp[j])+1\ \ \ (1\leq j<i,a[j] in\ \ a[i])$$

其中 $j\ \ in\ \ i$ 表示在二进制下，$j$ 上是 $1$ 的位完全被 $i$ 上是 $1$ 的位置包含，而具体的话就是题目大意中的那个例子。

这样的话 $O(n^2)$ 是不能通过此题的。

但是我们发现这题的值域是比较小的，我们考虑 $O(\text{值域})$ 的做法。

$O((n+2^k)k)$ 的做法：

因为要和值域有关系，我们的 $dp$ 状态就不能是之前那个了，必须要体现数 $i$，所以 $dp$ 方程的含义就是 $dp[i]$ 表示第 $i$ 个数要被放在第几组中，但是有没有发现一个问题？如果 $i$ 不在给定的 $n$ 个数里面怎么办呢？所以我们的含义是 $dp[i]$ 表示**如果数 $i$ 在这 $n$ 个数里面**，它应该被放在第几组。这个转移就很容易了。
$$dp[i]=\max(dp[j])+v[i]\ \ \ (1\leq j<i,j\ \ \ in \ \ \ i)$$
其中 $j\ \ in\ \ i$ 的意思同上，这样是 $O(2^{2k})$，很明显不能这么做。但是有一点，$i$ 去掉一位肯定比 $i$ 去掉两甚至更多位要更优，所以我们可以只枚举 $i$ 去掉一位的情况。
$$dp[i]=\max(dp[j])+v[i]\ \ \ (1\leq j<i,j=(i\ \ xor\ \ (2^p)))$$
这样就可以过了。

输出方案：

$dp$ 数组都求出来了，那答案的输出就很容易了，那第 $i$ 组所包含的元素就是所有 $dp$ 值等于 $i$ 的数。这样我们直接有一个邻接表存就好了。

代码：
```
#include<bits/stdc++.h>
using namespace std;
const int NR=1e6+10;
const int MR=(1<<20|1);
int n,k;
int a[NR],v[MR];
int dp[MR];
int to[NR],nxt[NR];
int head[NR];
int tot=1;
void add(int x,int y)
{
	to[tot]=y;
	nxt[tot]=head[x];
	head[x]=tot++;
}
int lowbit(int x){return x&-x;}
int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return x*f;
}
int main()
{
	n=read(),k=read();
	for(int i=1;i<=n;i++) a[i]=read(),v[a[i]]++;
	for(int i=0;i<(1<<k);i++)
	{
		for(int j=i;j;j^=lowbit(j))
		{
			int p=i^lowbit(j);
			dp[i]=max(dp[i],dp[p]);
		}
		dp[i]+=v[i];
		if(v[i]) add(dp[i],i);
	}
	printf("1\n%d\n",dp[(1<<k)-1]);
	for(int x=1;head[x];x++)
	{
		int cnt=0;
		for(int i=head[x];i;i=nxt[i])cnt++;
		printf("%d ",cnt);
		for(int i=head[x];i;i=nxt[i])
			printf("%d ",to[i]);
		puts("");
	}
	return 0;
}

```


---

## 作者：chengni (赞：5)

大佬说的很清楚了，给大佬配一波代码，有点丑，请见谅

首先这道题的题意是如果 $a_i$ 是 $a_j$ 的子集，那么连一条单向边，然后拓扑跑最长链

$60$ 做法是 $n^2$ 判断连边，代码如下

```cpp
	for(int i=1;i<=n;i++){
        for(int j=i+1;j<=n;j++){
            if((a[i]&a[j])==a[i]) {
                add(i,j);
                ru[j]++;
            }
            if((a[i]&a[j])==a[j]){
                add(j,i);
                ru[i]++;
            }
        }
    }
```
这样做时间的瓶颈在建边的 $n^2$ 上，我们会有很多无用的判断，考虑优化建边

就像大佬说的，我们可以从 $0$ 开始，连向多一个元素到达的情况，这样建边复杂度会优化很多

我们标记为礼物的点，其他的无用点不会增加链的长度

然后从 $0$ 跑拓扑排序就可以了

很丑的代码如下

```cpp
	int n=read(),k=read();
	for(int i=1;i<=n;i++){
		a[i]=read();
		v[a[i]]=1;//标记下出现过，因为元素不同，可以这样做
	}
	q.push(0);//从0开始连边
	int s=0;
	while(q.size()){
		int x=q.front();q.pop();
		for(int i=0;i<k;i++){
			if(((x>>i)&1)==0){//连边
				int y=x|(1<<i);
				add(x,y);
				ru[y]++;
				if(f[y]==1) continue;
				q.push(y);
				f[y]=1;
			}
		}
	}
	q.push(0);//从0开始拓扑排序
	while(q.size()){
		int x=q.front();q.pop();
		p[x]=p[x]+v[x];
		if(v[x]==1){//这个点是有贡献的
			s++;
			t[s].id=x;
			t[s].p=p[x];
		}
		ans=max(ans,p[x]);
		if(v[x]==1){
			cnt[p[x]]++;
		}
		for(int i=head[x];i;i=nxt[i]){
			int y=to[i];
			ru[y]--;
			p[y]=max(p[y],p[x]);
			if(ru[y]==0) q.push(y);
		}
	}
	cout<<1<<endl;
	cout<<ans<<endl;
	sort(t+1,t+n+1,cmp);//按照格式输出
	for(int i=1;i<=n;i++){
		if(t[i].p!=t[i-1].p){
			printf("%d ",cnt[t[i].p]);
		}
		printf("%d ",t[i].id);
		if(t[i].p!=t[i+1].p) puts("");
	}
```









---

## 作者：Cuxhin (赞：5)

# P4934 礼物 初学者向拓扑排序题解

## 前言

本题被罗永军老师塞进了《算法竞赛》中拓扑排序一节的课后练习题。鉴于题解在拓扑排序这块的解释不够详细清晰，本人站在前人的肩膀上概括总结，希望初学拓扑排序的 OIer 能快速地理解此题并加深对拓扑排序的理解。

## 前置知识

### 拓扑排序

引用《算法竞赛》的原句。

> 把事情看作图的点，把先后关系看作有向边，问题转化为图中一个有先后关系的排序，这就是拓扑排序。

拓扑排序有 DFS 和 BFS 两种实现方式，其中 BFS（广度优先搜索）的实现流程大致如下：

1. 找到所有入度为 $0$ 的节点，放入队列作为起点。
2. 弹出队首，队首所有邻居点的入度减一，入度为 $0$ 的邻居入队。
3. 重复第二步，直至队列为空。

如果队列已空但是还有点未入队，就存在环，拓扑排序无解。

### 位运算

1.  **<<** 二进制整体左移。`(6<<1)=12 (110)->(1100)` 末尾补了一位 $0$，可以理解为乘以二的多次方。
2.  **>>** 二进制整体右移。`(6<<1)=3 (110)->(11)` 去掉了末尾最后一位，可以理解为除以二的多次方。
3. **&** 按位与。按二进制的每一位进行与 （and）的操作。

   `6(110)&4(100)=4(100) 13(1101)&11(1011)=9(1001)`
5. **|** 按位或。按二进制的每一位进行或 （or）的操作。

   `6(110)&4(100)=6(110) 13(1101)&11(1011)=15(1111)`

本题要用到的大致就这四个，初此之外还有异或、取反等。

使用位运算的组合，我们可以便捷地对二进制数进行一些操作。

1. 确定 n 第 $x+1$ 位表示的是 1 还是 0 `(n>>x)&1`
2. 找到将 n 第 $x+1$ 位改为 1 后的值 `(n|(1<<x))`。

---

此外，还有队列（queue）的使用、邻接表存储图、结构体排序的前置知识，此处不赘述。

## 解题

有了位运算的前置知识，题意就很好理解了。

将 $n$ 个数分成多个集合，每个集合中的数两两 **不满足** 按位与后的值等于二者中最小值，此为分类的约束条件。求集合最少的情况。

约束条件如下：
$$
a_i \operatorname{bitand} a_j \ge \min(a_i, a_j
 )
$$
若要化简约束条件，我们可以自己找几组数看看。

| a      | b      | a&b    |
| ------ | ------ | ------ |
| 5(101) | 6(110) | 4(100) |
| 6(110) | 4(100) | 4(100) |
| 2(010) | 7(111) | 2(010) |

根据这个表格，我们可以发现。

将 $a$ 所有值为 $1$ 的位数记录成一个集合，$b$ 所有值为 $1$ 的位数记录成一个集合。如果 $a$ 的集合包含 $b$ 的集合 或者 $b$ 的集合包含 $a$ 的集合，那么就会达成约束条件，达成约束条件的值我们分成多个盒子装。

然后我们就能建一个 **有向无环图** 了。有向边表示的是集合的包含关系。根据样例画图。
![](https://cdn.luogu.com.cn/upload/image_hosting/ny430w90.png)

相同层数的值可以放在一个盒子里，拓扑排序处理后，就能得出最少盒子和每个盒子放的什么数了。

接下来就是优化建图，按正常思路，我们需要将盒子内所有的值两两比较确定边，这样的时间复杂度比较大，且是乱序，我们考虑优化，**优化的重点放在将乱序的建边转化为有序的建边。**

注意到题目还给了个 $k$，表示所有值的上限到 $2^k$ 。如果考虑上在范围内但是又不是需要放进盒子的值，我们就可以从 $0$ 开始，按拓扑排序的结构，每次多连一个位的 $1$，建出图，建成这样的图满足拓扑排序顺序，可以分成若干层，同时，每一层的值放在同一盒子都不会冲突，但是不同层之间就存在了集合的包含关系，就不能放在同一盒子里了。
![](https://cdn.luogu.com.cn/upload/image_hosting/qozmuc6y.png)

但是，如果我们这样建图，就会多出很多不是我们需要放入盒子的值，这些值不需要考虑答案，但是对于需要放入盒子的值的状态转移很重要。对此，如果有一层里面有一个值需要放入盒子，那么这一层就需要一个盒子，往下一层推。如果这一层没有任何值需要放入盒子，就可以将上一层需要的盒子扔入下一层。

据此，我们可以列一个类似动态规划的式子来进行每一层需要盒子的转移，在转移的过程中，下标 $i$ 还可以用于存储盒子里面放了什么值。
$$
f[i]=\max f[上一层：i\text{在二进制表示下其中一位1变0}]+v[i]
$$

> $f[i]$ 表示存到值 $i$ 需要几个盒子，$v[i]$ 表示这个值是否需要放入 box 中。

然后我们判断值是否需要放入盒子，在转移状态的时候开个结构体数组记录即可。最后按需要盒子从小到大排，进行输出。

按拓扑排序的顺序建树，利用前置知识位运算中的公式。

```cpp
/*Build_Edge*/
q.push(0);//初始入队为0(二进制表示：000...(k个0))
while(!q.empty()){//队列非空
    int u=q.front();q.pop();//取队头并弹出
    for(int i=0;i<k;++i){//k位遍历
        if(((u>>i)&1)==0){//如果第i+1位为0
            int v=u|(1<<i);//将第i+1位赋为1后的值
            edge[u].push_back(v);//邻接表存边
            ++in[v];//入度修改
            if(!vis[v]) q.push(v),vis[v]=1;//如果这个数是第一次出现就入队
        }
    }
}
```

然后我们按拓扑排序的顺序遍历图中每一个数，如果是需要放盒子的就记录，并进行需要盒子的状态转移。

```cpp
/*TopoSort*/
q.push(0);//初始入队0
while(!q.empty()){//队列非空
    int u=q.front();q.pop();//取队头并弹出
    if(wanted[u]==1){//如果是要入盒子的值
        ++need_box[u];//存这个值需要多少个盒子。
        ans[++cnt]={u,need_box[u]};//存储值和值放的盒子
        ++num_in_box[need_box[u]];//盒子里面值的总数修改(放了多少个值)
    }
    maxbox=max(maxbox,need_box[u]);//盒子总数判断
    for(int v:edge[u]){//遍历邻居
        --in[v];//邻居入度修改
        need_box[v]=max(need_box[v],need_box[u]);//找到存到这个值需要多少个盒子
        if(!in[v]) q.push(v);//入度为 0 的入队
    }
}
```

最后按盒子的顺序输出。

```cpp
/*print*/
sort(ans+1,ans+1+n);//按盒子的顺序
cout<<"1\n"<<maxbox<<'\n';//表明你拿满分的决心和最少要多少盒子
for(int i=1;i<=n;i++){
    //如果前一个用的盒子与这一个的不同了，说明新开了盒子。重新输出盒子内有几个数。
    if(ans[i].p!=ans[i-1].p) cout<<num_in_box[ans[i].p]<<" ";
    cout<<ans[i].id<<" ";//输出值
    if(ans[i].p!=ans[i+1].p) cout<<'\n';//新开盒子换行
}
```







## 代码与注意事项

在码字的时候有几个注意点。

1. 注意数组范围，有些数组的下标就是值本身，需要开到 $2^k$。

2. 注意运算的优先度。位运算的优先度很低，多用括号。

   > 例如
   ，如果写成 ((u>>i)&1==0)，系统就会识别成     ((u>>i)&(1==0))，即 false。

自认为码风很好，应该能理解。

```cpp
//Cuxhin、初心 
#include<bits/stdc++.h>
const int N=1e6+10;
const int M=(1<<20)+10;
using namespace std;
int n,k,cnt,a[N];
struct Node{
	int id,p;
	friend bool operator<(Node x,Node y){
		return x.p<y.p;
	}
}ans[N];
//分别对应盒子数量，每个盒子里面多少个数，到下标i需要多少个盒子，入度，建图时是否遍历过，是否要放入盒子。
int maxbox,num_in_box[M],need_box[M],in[M],vis[M],wanted[M];
vector<int> edge[M];
queue<int> q;
signed main(){
	/*Init*/
    //解绑加快读入速度
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i],wanted[a[i]]=1;
	}	
	/*Build_Edge*/
	q.push(0);
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0;i<k;++i){
			if(((u>>i)&1)==0){
				int v=u|(1<<i);
				edge[u].push_back(v);
				++in[v];
				if(!vis[v]) q.push(v),vis[v]=1;
			}
		}
	}
	/*TopoSort*/
	q.push(0);
	while(!q.empty()){
		int u=q.front();q.pop();
		if(wanted[u]==1){
			++need_box[u];
			ans[++cnt]={u,need_box[u]};
			++num_in_box[need_box[u]];
		}
		maxbox=max(maxbox,need_box[u]);
		for(int v:edge[u]){
			--in[v];
			need_box[v]=max(need_box[v],need_box[u]);
			if(!in[v]) q.push(v);
		}
	}
	/*print*/
	sort(ans+1,ans+1+n);
	cout<<"1\n"<<maxbox<<'\n';
	for(int i=1;i<=n;i++){
		if(ans[i].p!=ans[i-1].p) cout<<num_in_box[ans[i].p]<<" ";
		cout<<ans[i].id<<" ";
		if(ans[i].p!=ans[i+1].p) cout<<'\n';
	}
	return 0;
}
```

---

题解就到这里了，感谢观看。如有错漏和批评欢迎提出。

---

## 作者：Zechariah (赞：5)

一个很~~暴力~~神奇的做法  
题意就是把一些数字分组，使得这些数字在二进制下的集合没有包含关系  
例如 3(11)包含2(10)，他们就不能分在一组  
我们可以从小到大枚举所有的集合，对于枚举的每一个集合，删除其中的一个“1”，得到一个子集，那么该集合一定不能与该子集分到一组  
这里需要用到一些位运算~~骚操作~~  
```cpp
j &= j - 1
```
这是删除j最右边（最靠近最低位）的1  
```cpp
i ^ j & -j 其中j为i的子集
```
这里要注意，&的优先级比较大，所以是i^(j&-j)，j&-j的含义是保留最右边的1，其余位全为0，这样的话就能从i中删除一个“1”。  
枚举的时候从小到大，就能保证枚举的子集在之前已经分好了组  
另外，只有输入给出的数字是需要另外开新的一组来存储的，所以统计答案的时候需要判断一下，具体看代码  

```cpp
#include <cstdio>
#include <vector>
const int N = 1 << 20;
inline int read()
{
	register int num = 0;
	register char ch;
	register bool flag = false;
	while ((ch = getchar()) == ' ' || ch == '\n' || ch == '\r');
	if (ch == '-')flag = true; else num = ch ^ 48;
	while ((ch = getchar()) != ' '&&ch != '\n'&&ch != '\r'&&~ch)
		num = num * 10 + (ch ^ 48);
	if (flag)return -num; return num;
}
int which[N];
bool flag[N];
int ans[21][N];

int main()
{
	register int n = read(), k = 1 << read();
	for (register int i = 1; i <= n; ++i)flag[read()] = true;
	for (register int i = 0; i ^ k; ++i)//从小到大枚举所有集合
	{
		for (register int j = i; j; j &= j - 1)
			if (which[i] < which[i^j&-j])which[i] = which[i^j&-j];//从集合i中删除一个“1”，然后把i暂时分到这些子集中组号最大的一个
		if (flag[i])++which[i], ans[which[i]][++ans[which[i]][0]] = i;//如果i在序列中，就不能分到当前组了，于是就分到下一组
	}
	printf("1\n%d", which[k - 1]);//k - 1包含所有的集合，所以k - 1分的组（暂时分的，没有分到下一组）就是最大的组号，也就是总的分组数
	for (register int i = 1; i <= which[k - 1]; ++i)
	{
		printf("\n%d", ans[i][0]);
		for (register int j = 1; j <= ans[i][0]; ++j)
			printf(" %d", ans[i][j]);
	}
	return 0;
}
```

---

## 作者：离散小波变换° (赞：1)

## 题解

注意到 $a\operatorname{bitand} b\le a$ 且 $a\operatorname{bitand} b\le b$。如果我们把 $a,b$ 视作对应二进制里面 $1$ 所在的下标的集合（比如 $13=1101_{(2)}$ 可看作集合 $\{0,2,3\}$），那么题设条件等价于 $a \subseteq b$ 或者 $b\subseteq a$。容易发现当且仅当 $a=b$ 时同时满足 $a\subseteq b$ 与 $b\subseteq a$，那么先把相同值的元素合并在一起。那么不能放在一起的 $a,b$ 之间的关系只能是 $a\subsetneq b$ 或者 $b\subsetneq a$。

- 这样的关系具有传递性：$a\subsetneq b,b\subsetneq c$，则 $a \subsetneq c$；
- 这样的关系不会形成环，这是因为若 $a \subsetneq b$ 则有 $|a|<|b|$，如果成环就会出现 $|a|<|a|$ 的矛盾。

如果我们把这种关系建成图（从 $a$ 向 $b$ 连边），那么这必定是一个有向无环图。考察一条从 $a$ 到 $b$ 的路径，那么这条路径上任何两个元素都不能放在同一个盒子里，故答案不会小于最长路的长度。最后给出的构造方法证明了最少盒子数量就是最长路的长度。有向无环图的最长路容易使用 dp 计算得出。但是注意到我们已经将相同的元素缩成了一个点，所以最长路的定义应该为**这条路径上的点权之和**。下面考虑怎么建立这个有向无环图。

我们发现如果暴力地枚举 $a,b$ 连边，不光枚举点对的时间复杂度会超时，最后建出来的图的规模也有可能是 $\mathcal O(n^2)$ 级别（考察一些形如 $01111,10111,11011,11101,11110$ 的元素作为 $b$，那么对于像 $10000,01000,00100,00010,00001$ 的 $a$，它会和一堆 $b$ 连边，图的规模就能达到 $\mathcal O(n^2)$）。

然而因为我们只需要计算图的最长边，考察一些传统的技巧（比如可以类比线段树优化建图，用数量较少的点来将一堆边简化），容易想到（可能也没那么容易），我们将 $a$ 连向一些虚拟点，同时将这些虚拟点再往别的点去连，总归要满足 $a$ 通过虚拟点+实际存在的点能够到达的点肯定都是 $a$ 的超集。

解决方案到这里应该已经呼之欲出了。若 $a\neq a\operatorname{bitor} 2^i$，就将 $a$ 与 $a\operatorname{bitor} 2^i$ 连边。这里的 $a$ 既可以是个实际存在的点，也可以是个虚拟点。这样连边之后每个点能够到达的位置仍然是它的超集。对于虚拟点，将它的点权赋值为 $0$ 就好了。

下面是构造的事情。假设点 $a$（点权记为 $w$）连向的所有节点中，这些节点放进的编号最大的箱子的编号是 $x$，那么就往 $x+1,x+2,x+3,\cdots,x+w$ 号箱子里放元素 $a$ 即可。可以发现这个 $x$ 的值总是与计算最长路用的那个 dp 数组的值相同，所以可以保证不会用多余的箱子。

总时间复杂度为 $\mathcal O(k2^k+n)$。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l, r, i) for(int i = l, END##i = r;i <= END##i;++ i)
#define dn(r, l, i) for(int i = r, END##i = l;i >= END##i;-- i)
using namespace std;
typedef long long i64;
const int INF = 2147483647;
const int MAXN= (1 << 20) + 3;
const int MAXM=  20 + 3;
vector <int> V[MAXN];
int H[MAXN], A[MAXN], I[MAXN];
int n, k, ans;
int qread(){
    int w = 1, c, ret;
    while((c = getchar()) >  '9' || c <  '0') w = (c == '-' ? -1 : 1); ret = c - '0';
    while((c = getchar()) >= '0' && c <= '9') ret = ret * 10 + c - '0';
    return ret * w;
}
int main(){
    n = qread(), k = qread();
    up(1, n, i){
        int a = qread(); ++ H[a];
    }
    dn((1 << k) - 1, 0, i){
        up(0, k - 1, j) if((i & 1 << j) == 0){
            A[i] = max(A[i], A[i | 1 << j]);
            I[i] = max(I[i], I[i | 1 << j]);
        }
        up(1, H[i], j){
            V[I[i] + j].push_back(i);
        }
        I[i] += H[i];
        A[i] += H[i];
        ans = max(ans, A[i]);
    }
    puts("1");
    printf("%d\n", ans);
    up(1, ans, i){
        printf("%d ", V[i].size());
        for(auto &x : V[i])
            printf("%d ", x);
        puts("");
    }
    return 0;
}
```

---

## 作者：Mrkn_chenyx12 (赞：0)

## 解题思路

首先我们可以发现，假设 $a>b$，那么 $a \operatorname{bitand} b \ge \min(a, b)$ 当且仅当 $a\operatorname{bitand}b=b$。显然地，如果 $a=\sum_{i\in S}2^i$，那么 $a$ 就不能与 $b=\sum_{i\in T}2^i$ 存在于同一个箱子，其中 $T$ 是 $S$ 的子集。

考虑拓扑排序，每个数字 $u$ 向所有比它小且不能与它共存的数字 $v$ 连边，并且置 $ans_v\gets\max(ans_v,ans_u+1)$，其中 $ans_x$ 表示数字 $x$ 放在哪一个箱子中。

但是这样每个数字连出边的量级是 $2^{\operatorname{popcount}x}$ 的，显然在后面几组数据中不可行。于是考虑每个数字只向二进制下只比它少一位 $1$ 且不能与它共存的数字连边，无论目标数字是否存在，可以证明那些被忽略的边必然会被间接连接。这样每个数字连出边的量级只有 $\operatorname{popcount} x$，可以通过。

另外，注意使用这种方式连边需要为 $1\ldots2^k-1$ 中的每一个数字而不仅仅是输入的数字连边。拓扑排序时，如果 $u$ 不属于输入，则应该更新 $ans_v$ 为 $\max(ans_v,ans_u)$，而不是 $\max(ans_v,ans_u+1)$。

# 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, k, a[1000024], r[1050024], in[1050024], msv[1050024];
int ev[22000024], ex[22000024], es[1050024], ecnt;
vector<int> ans[24];

void add(int u, int v) {
    ev[++ecnt] = v;
    ex[ecnt] = es[u];
    es[u] = ecnt;
    in[v]++;
}

#define lowbit(x) ((x) & -(x))

int main() {
    scanf("%d %d", &n, &k);
    for (int i = 1; i <= n; i++) {
        scanf("%d", a + i);
        r[a[i]] = i;
    }
    sort(a + 1, a + n + 1);
    for (int i = 0; i < (1 << k); i++) {
        int tmp = i;
        while (tmp) {
            int x = lowbit(tmp);
            add(i, i - x);
            tmp -= x;
        }
    }
    queue<int> q;
    q.push((1 << k) - 1);
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        int t = r[u];
        if (t) ans[msv[u] + 1].push_back(u);
        for (int i = es[u]; i; i = ex[i]) {
            int v = ev[i];
            if (t) msv[v] = max(msv[v], msv[u] + 1);
            else msv[v] = max(msv[v], msv[u]);
            if (!--in[v]) q.push(v);
        }
    }
    int x = 1;
    for (; ans[x].size(); x++);
    x--;
    printf("1\n%d\n", x);
    for (int i = 1; i <= x; i++) {
        printf("%d", ans[i].size());
        for (auto u : ans[i]) {
            printf(" %d", u);
        }
        puts("");
    }
    return 0;
}
```

---


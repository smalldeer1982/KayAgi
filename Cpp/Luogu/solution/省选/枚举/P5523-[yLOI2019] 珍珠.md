# [yLOI2019] 珍珠

## 题目背景

> 别叹息太多告别，至少相遇很真切。  
> 摇曳着盛放枯竭，时间从未停歇。  
> 天涯浪迹的白雪，念念不忘山川蝴蝶。  
> 听说有人孤负黑夜，偏要点亮人间的月。

——银临《珍珠》

## 题目描述

扶苏给了你一个放珍珠的小匣子，这个匣子在左右两端都可以无限制的加入珍珠，珍珠在匣子里会排成一列，每次在左端加入珍珠，这个珍珠会被加入到这个珍珠序列的最左侧，在右端加入则会被加入到珍珠序列的最右侧。初始时，匣子是空的。

这些珍珠要么是黑色的，要么是白色的，为了方便起见，我们将白色看作 $0$，黑色看作 $1$。

在人鱼的世界中，定义颜色 $A$ **组合** 颜色 $B$ 为 $A\operatorname{nand}B$，读作 $A$ 与非 $B$。

定义 $A \operatorname{nand} B = \operatorname{not} (A \operatorname{and}B)$ ，其中 $\operatorname{and}$ 运算代表二进制与运算，$\operatorname{not}$ 运算代表二进制非运算。

定义位置 $x$ 到位置 $y$ 的组合和为：

从 $x$ 开始向 $y$ ，第一个颜色组合第二个颜色的结果组合第三个颜色，得到的结果组合第四个颜色……一直组合到位置 $y$ 的颜色的结果。特别的，$x = y$ 时，组合和为该颜色。

形式化的，设 $C_{x, y}$ 为序列 $A$ 从 $x$ 到 $y$ 的组合和，则
$$C_{x, y} = \begin{cases} C_{x, y - 1} \operatorname{nand} A_y & x < y \\  C_{x, y + 1} \operatorname{nand} A_y & x > y \\ A_x &x = y \end{cases}$$

例如，给定序列 $1, 1, 0, 0$，从 $2$ 到 $4$ 的组合和为 

$$(1 \operatorname{nand} 0) \operatorname{nand} 0 = 1 \operatorname{nand} 0 = 1$$

从 $3$ 到 $1$ 的组合和为

$$(0 \operatorname{nand} 1) \operatorname{nand} 1 = 1 \operatorname{nand} 1 = 0$$

从 $2$ 到 $2$ 的组合和为

$$1$$

扶苏会在匣子的两边加入一些珍珠，或者给定一个位置 $p$，询问你从左向右数第 $1$ 个位置到从左向右数第 $p$ 个位置的组合和，或者从右向左数第 $1$ 个位置到从右向左数第 $p$ 个位置的组合和。

## 说明/提示

#### 样例输入输出 1 解释

第一次操作，$x=0,y=1,z=0$，在匣子右端插入一个 $0$，那么匣子里的珍珠序列为 $\{0\}$

第二次操作，$x = 1,y = 0,z = 1$，查询从左向右数第一个数到第一个数的组合和，答案是 $0$。

第三次操作，$x = 0,y = 1,z = 1$，在匣子右端插入一个 $1$，匣子里的珍珠序列为 $\{0,~1\}$

第四次操作，$x = 1,y = 0,z = 1$，查询从左向右数第一个数到第一个数的组合和，答案是 $0$。

第五次操作，$x = 0,y = 0,z = 0$，在匣子左侧插入一个 $0$，那么匣子里的珍珠序列为 $\{0,~0,~1\}$

第六次操作，$x = 0,y = 1,z = 1$，在匣子右侧插入一个 $1$，那么匣子的珍珠序列为 $\{0,~0,~1,~1\}$

没有任何一次查询的结果满足【输出格式】中提到的任意一种情况，于是输出 ``0 0 0 0``。

---

#### 数据规模与约定

**本题采用多测试点捆绑测试，共有 $7$ 个子任务**。

- Subtask 1（5 points）：$n = m = 0$。
- Subtask 2（15 points）：$n = 1001$。
- Subtask 3（15 points）：$n = 10^5 + 2$。
- Subtask 4（10 points）：$n = 10^7 + 3$，对于所有 $x = 0$ 的操作，保证 $z = 1$。
- Subtask 5（10 points）：$n = 10^7 + 4$，对于所有 $x = 0$ 的操作，保证 $z = 0$。
- Subtask 6（15 points）：$n = 10^7 + 5$，$m = 0$。
- Subtask 7（30 points）：$n = 10^7 + 6$。

对于全部的测试点，保证 $0 \leq n \leq 10^7 + 6$，$0 \leq m \leq \min(n, 10^6)$，$x, y \in \{0, 1\}$，且对于所有 $x = 0$ 的操作，保证  $z \in \{0, 1\}$，若设 $k$ 为在任一查询时匣子里的珍珠个数，则保证对于 $x = 1$ 的操作，$1 \leq z \leq k$，匣子为空时不会有查询操作。

---

#### 提示与说明

- 请注意常数因子对程序效率造成的影响。
- $n$ 的末位数字可以帮助你快速的判断测试点所属的子任务。
- 由于涉及到非操作，与非运算可能不具备一些常见位运算的运算律，请格外注意。
- std 使用 C++ 语言，保证时限是 std 用时的 1.5 倍以上，**但是不保证其他语言能够通过本题**。
- 对于 C++ 选手，如果你直接复制上面的生成器，保证生成器运行总时间不超过 300ms。

## 样例 #1

### 输入

```
6
233 666 250 0```

### 输出

```
0 0 0 0```

# 题解

## 作者：一扶苏一 (赞：9)

# D [yLOI2019] 珍珠

## Background

别叹息太多告别，至少相遇很真切。

摇曳着盛放枯竭，时间从未停歇。

天涯浪迹的白雪，念念不忘山川蝴蝶。

听说有人孤负黑夜，偏要点亮人间的月。

——银临《珍珠》


## Description

给定一个 ``deque``，要求支持 ``push_back`` 和 ``push_front`` 操作，并且查询前缀与非和以及后缀与非和。

deque中只会有 $0$ 或 $1$，一共有 $n$ 次操作，其中有 $m$ 次操作给定，剩下的操作随机。

## Limitations

![img](https://cdn.luogu.com.cn/upload/pic/71767.png)

## Solution

~~这是一道通过输入格式来防AK的题目~~

下面的做法只考虑前缀与非和，因为后缀的做法与前缀完全相同。

子任务 $0$：

没有操作，输出四个 $0$ 即可。期望得分 $5~pts$

子任务 $1$：

暴力模拟，每次从前面插入的时候后面的元素暴力移位，暴力查询与非和即可。时间复杂度 $O(n^2)$，期望得分 $15~pts$

子任务 $2$：

考虑用线段树来维护每个区间的与非和，但是这样产生了一个问题，两个区间的与非和是无法合并的，因为与非运算没有交换律和结合律。

但是我们注意到事实上对于某个区间，序列的首部到区间左端点之前所有元素的与非和只可能是 $0$ 或 $1$，因此线段树每个节点维护两个信息：当该区间之前所有元素的与非和是 $0$ 时与非上该区间的值，以及当该区间之前元素与非和是 $1$ 时与非上该区间的值，然后即可 $O(1)$ 转移。

时间复杂度 $O(n \log n)$，期望得分 $15 ~pts$

子任务 $3$：

插入的元素全部是 $1$。

考虑一堆连续 $1$ 的前缀与非和序列，一定形如 $101010101\dots$

证明上，考虑第一个位置一定是 $1$，然后 $1~\text{nand}~1~=~0$ ，$0~\text{nand}~1~=~1$，因此序列中 $0$ 和 $1$ 一定是循环出现的。

因此一个询问的答案一定是 $y~\&~1$。时间复杂度 $O(n)$，期望得分 $10~pts$

子任务 $4$：

插入的元素全部是 $0$。

考虑一堆 $0$ 的前缀与非和序列，一定形如 $011111111111 \dots$

用与子任务 $3$ 类似的办法即可解决。时间复杂度 $O(n)$，期望得分 $10~pts$

子任务 $5$：

考虑一个显而易见的事实，$0$ 与非任何数都得 $1$。

因此考虑一次查询如果与非和的最后一项是 $0$，则直接返回 $1$ 即可。

同时对于最后一项是 $1$ 的操作，只需要看这一项向前一共有连续的几个 $1$，由于前面那一项是 $0$，所以一段 $011111$ 的序列的与非和一定是 $1010101010\dots$，而与 $0$ 前面的项完全无关。

当然需要特判查询的 $0$ 是序列第一个元素，以及查询的 $1$ 前面没有 $0$ 的情况。

那么问题就变成了对于每个位置维护它前面第一个 $0$ 的位置。

由于 $m = 0$ ，序列中的元素是完全随机的，因此连续 $0/1$ 段的长度期望都是常数级的，因此暴力找即可，期望时间复杂度 $O(n)$，期望得分 $15~pts$

子任务 $6$：

考虑在序列不随机时怎么对每个数维护它前面第一个 $0$ 的位置。

事实上，在每插入一个 $0$ 时，都暴力修改这个 $0$ 的有元素的一侧的连续 $1$ 的信息即可。

例如，在序列左侧插入一个 $0$，则暴力修改 $0$ 右侧连续 $1$ 的左侧最近的 $0$ 的位置为该位置即可。在序列右侧插入同理。

考虑时间复杂度：每个为 $1$ 的元素都只会在左侧最近和右侧最近的 $0$ 插入的时候被修改信息，因此每个元素都只会被修改 $O(1)$ 次信息，即每次均摊修改 $O(1)$ 个信息，总的修改次数为 $O(n)$，因此总时间复杂度 $O(n)$，期望得分 $30~pts$。




```cpp
#include <cstdio>
#ifdef ONLINE_JUDGE
#define freopen(a, b, c)
#endif

typedef long long int ll;

namespace OPT {
  char buf[120];
}

template <typename T>
inline void qw(T x, const char aft, const bool pt) {
  if (x < 0) {x = -x, putchar('-');}
  int top=0;
  do {OPT::buf[++top] = static_cast<char>(x % 10 + '0');} while (x /= 10);
  while (top) putchar(OPT::buf[top--]);
  if (pt) putchar(aft);
}

namespace Maker {

typedef unsigned int uit;

bool __sp;
uit __x, __y, __z;
int __type, __k, __m;

const int L = 1 << 21;
char buf[L], *front=buf, *end=buf;
char GetChar() {
  if (front == end) {
    end = buf + fread(front = buf, 1, L, stdin);
    if (front == end) return -1;
  }
  return *(front++);
}

template <typename T>
inline void qr(T &x) {
  char ch = GetChar(), lst = ' ';
  while ((ch > '9') || (ch < '0')) lst = ch, ch = GetChar();
  while ((ch >= '0') && (ch <= '9')) x = (x << 1) + (x << 3) + (ch ^ 48), ch = GetChar();
  if (lst == '-') x = -x;
}

template <typename T>
inline void Begin(const T &x) {
  __type = x % 10;
  qr(__x); qr(__y); qr(__z); qr(__m);
  __sp = (__type == 3) || (__type == 4); __type &= 1;
}

inline uit __Next_Integer() {
  __x ^= __y << (__z & 31);
  __y ^= __z >> (__x & 31);
  __z ^= __x << (__y & 31);
  __x ^= __x >> 5; __y ^= __y << 13; __z ^= __z >> 6;
  return __x;
}

inline uit Rand() { return __Next_Integer(); }

template <typename Tx, typename Ty, typename Tz>
inline void Get_Nextline(Tx &x, Ty &y, Tz &z) {
  if (__m) {
    --__m;
    x = 0; y = 0; z = 0;
    qr(x); qr(y); qr(z);
    if (x == 0) ++__k;
  } else {
    x = Rand() & 1; y = Rand() & 1;
    if (__k == 0) { x = 0; }
    if (x == 0) {
      ++__k;
      if (__sp) {
        z = __type;
      } else {
        z = Rand() & 1;
      }
    } else {
      int dk = __k >> 1;
      if (dk == 0) {
        z = 1;
      } else {
        z = Rand() % dk + dk;
      }
    }
  }
}

}

const int maxn = 10000009;

struct Ask {
  int x, y, z;

  inline void init() { Maker::Get_Nextline(x, y, z); ++x; ++y;}
};
Ask ask[maxn];

struct M {
  int v, lp, rp;
};
M MU[maxn];

int n, lpos = 1, ans, answ, answe, answer;

int main() {
  scanf("%d", &n);
  fprintf(stderr, "QAQIN\n") ;
  Maker::Begin(n);
  for (int i = 1; i <= n; ++i) {
    ask[i].init();
    if ((ask[i].x == 1) && (ask[i].y == 1)) ++lpos;
  }
  int rpos = lpos - 1;
  for (int i = 1; i <= n; ++i) {
    if (ask[i].x == 1) {
      if (ask[i].y == 1) {
        M &m = MU[--lpos];
        if ((m.v = ask[i].z) == 1) {
          m.rp = MU[lpos + 1].rp;
        } else {
          m.rp = m.lp = lpos;
          for (int j = lpos + 1; MU[j].v == 1; ++j) {
            MU[j].lp = lpos;
          }
        }
      } else {
        M &m = MU[++rpos];
        if ((m.v = ask[i].z) == 1) {
          m.lp = MU[rpos - 1].lp;
        } else {
          m.rp = m.lp = rpos;
          for (int j = rpos - 1; MU[j].v == 1; --j) {
            MU[j].rp = rpos;
          }
        }
      }
    } else {
      int _ans = 0;
      int p = ask[i].y == 1 ? lpos + ask[i].z - 1 : rpos - ask[i].z + 1;
      if (MU[p].v == 0) {
        _ans = ask[i].z != 1;
      } else {
        if (ask[i].y == 1) {
          int k = MU[p].lp;
          if (k == 0) {
            _ans = ask[i].z & 1;
          } else if (k == lpos) {
            _ans = (ask[i].z - 1) & 1;
          } else {
            _ans = (p - k + 1) & 1;
          }
        } else {
          int k = MU[p].rp;
          if (k == 0) {
            _ans = (ask[i].z) & 1;
          } else if (k == rpos) {
            _ans = (ask[i].z - 1) & 1;
          } else {
            _ans = (k - p + 1) & 1;
          }
        }
      }
      if (_ans) {
        ++ans;
        if (!(i & 1)) {
          ++answe;
        }
      } else {
        if (i & 1) {
          ++answ;
        }
        if (!(i & 1023)) {
          ++answer;
        }
      }
    }
  }
  printf("%d %d %d %d\n", ans, answ, answe, answer);
  return 0;
}

```

## appreciation

感谢@[Burnside](https://www.luogu.org/space/show?uid=64500) 神仙帮助进行题解的校对工作

---

## 作者：huangzirui (赞：7)

题意：

[原题题面](https://www.luogu.com.cn/problem/P5523)

定义运算 $\text{nand}$ （ **非与** ）为：

$$A\ \text{nand}\ B = \text{not}(A\ \text{and}\ B)$$

即：

nand | 0| 1
:-: | :-: | :-:|
**0** | 1 | 1
**1** | 1 | 0

现在给你一个序列 $A$，要你支持以下操作：

1. 从序列的左边或右边插入一个非 $0$ 即 $1$ 的数。

2. 从序列的左边或右边开始，查询连续 $x$ 个数的 **非与** 值

操作数 $\leq 10^7+6$

（吐槽：原题输入格式太 duliu 了）

---

首先找一下 $\text{nand}$ 操作有什么性质。

发现 $0\ \text{nand}$ 任何一个数都是 $1$ 。

这意味着无论有多少个数做这个运算，只要运算的过程中有 $0$ ，那么不论前面有什么东西，**到这个位置统统都变成 $1$** ，所以答案只和 $0$ 后面的有关。（**这意味着答案只和最后的 $0$ 有关**）

那么假如我们从右往左查询，我们只需要找到查询到的最后一个数，再从这个节点往前找到一个 $0$ ，最后计算从这个 $0$ 到最后一个数的答案即可。

比如：

$A = 1,0,1,0,1,1,1,1,0$

我现在想从左往右查询 $8$ 个数，那么查询到的最后一个数就是第八个数。第八个数左边的第一个 $0$ 在第四个位置。然后从第四个位置向右 **非与** 即可。

又因为这样子计算相当于计算 $1\ \text{nand}\ 1\ \text{nand}\  \dots\ \text{nand}\ 1$ 。这个表达式的值显然可以 $O(1)$ 计算。

所以原问题就转化成求一个位置上向左和向右的第一个 $0$ 的位置。又因为这道题插入的方式很奇特，这个东西可以从上一个数递推过来（也可以从新加入的数推过来）。具体的说：

**设第 $i$ 个位置向左第一个 $0$ 的位置为 $L_i$ ，向右第一个位置是 $R_i$**

当我们从左边加了一个 $0$ ，那就可以把这个 $0$ 右边所有连续的 $1$ 的 $L$ 数组都设成这个位置。又因为每个 $0$ 最多被一个 $1$ 查找到，均摊复杂度是 $O($ 长度 $)$ 的。

当我们从左边加了一个 $1$ ，$R_i$ 可以直接从 $R_{i+1}$ 处得到。

然后算法大概分析完了。

这道题细节相当多，比如 $0\ \text{nand}$ 一个数答案肯定是 $1$ ，但是它单独一个数时就是 $0$ ，因此要特判一开始就是 $0$ 的情况。

代码主体部分不长，~~输入部分占了一半，果然是输入格式防 AK 题~~。

```
#include <bits/stdc++.h>
using namespace std;

//#define ONLINE_JUDGE

namespace Maker {

typedef unsigned int uit;

bool __sp;
uit __x, __y, __z;
int __type, __k, __m;

const int L = 1 << 21;
char buf[L], *front=buf, *end=buf;
char GetChar() {
  if (front == end) {
    end = buf + fread(front = buf, 1, L, stdin);
    if (front == end) return -1;
  }
  return *(front++);
}

template <typename T>
inline void qr(T &x) {
  char ch = GetChar(), lst = ' ';
  while ((ch > '9') || (ch < '0')) lst = ch, ch = GetChar();
  while ((ch >= '0') && (ch <= '9')) x = (x << 1) + (x << 3) + (ch ^ 48), ch = GetChar();
  if (lst == '-') x = -x;
}

template <typename T>
inline void Begin(const T &x) {
  __type = x % 10;
  qr(__x); qr(__y); qr(__z); qr(__m);
  __sp = (__type == 3) || (__type == 4); __type &= 1;
}

inline uit __Next_Integer() {
  __x ^= __y << (__z & 31);
  __y ^= __z >> (__x & 31);
  __z ^= __x << (__y & 31);
  __x ^= __x >> 5; __y ^= __y << 13; __z ^= __z >> 6;
  return __x;
}

inline uit Rand() { return __Next_Integer(); }

template <typename Tx, typename Ty, typename Tz>
inline void Get_Nextline(Tx &x, Ty &y, Tz &z) {
  if (__m) {
    --__m;
    x = 0; y = 0; z = 0;
    qr(x); qr(y); qr(z);
    if (x == 0) ++__k;
  } else {
    x = Rand() & 1; y = Rand() & 1;
    if (__k == 0) { x = 0; }
    if (x == 0) {
      ++__k;
      if (__sp) {
        z = __type;
      } else {
        z = Rand() & 1;
      }
    } else {
      int dk = __k >> 1;
      if (dk == 0) {
        z = 1;
      } else {
        z = Rand() % dk + dk;
      }
    }
  }
}

}

const int maxn=3e7+10;

int Left[maxn],Right[maxn];
int nowL=15000001,nowR=15000000;
int i,j,k,n,m;
int ans1,ans2,ans3,ans4;

int main() {
#ifndef ONLINE_JUDGE
	freopen("P5523.in", "r", stdin);
	freopen("P5523.out", "w", stdout);
#endif
	scanf("%d", &n);
	Maker::Begin(n);
	memset(Left,-1,sizeof(Left));
	memset(Right,-1,sizeof(Right));
	int id=0;
	for (int x,y,z;n;--n){
		++id;
		int ans=-1;
		Maker::Get_Nextline(x, y, z);
		if(x==0 && y==0 && z==1){
			nowL--;
			Left[nowL]=-1;
			Right[nowL]=Right[nowL+1]; 
		}if(x==0 && y==0 && z==0){
			nowL--;
			Left[nowL]=nowL;
			Right[nowL]=nowL;
			for(i=nowL+1;i<=nowR;i++){
				if(Left[i]!=-1)break;
				Left[i]=nowL;
			}
		}
		if(x==0 && y==1 && z==1){
			nowR++;
			Right[nowR]=-1;
			Left[nowR]=Left[nowR-1]; 
		}if(x==0 && y==1 && z==0){
			nowR++;
			Right[nowR]=nowR;
			Left[nowR]=nowR;
			for(i=nowR-1;i>=nowL;i--){
				if(Right[i]!=-1)break;
				Right[i]=nowR;
			}
		}
		int Z=-1;
		if(x==1 && y==0){
			z=z+nowL-1;
			Z=Left[z];
			if(z==nowL){
				if(Left[z]==-1)ans=1;
				else ans=0;
			}else{
				if(Z==nowL)Z--;
				if(Z==-1)Z=nowL;
				if((z-Z)%2==0)ans=1;
				else ans=0;
			}
		}
		if(x==1 && y==1){
			z=nowR-z+1;
			Z=Right[z];
			if(z==nowR){
				if(Right[z]==-1)ans=1;
				else ans=0;
			}else{
				if(Z==nowR)Z++;
				if(Z==-1)Z=nowR;
				if((Z-z)%2==0)ans=1;
				else ans=0;
			}
		}
		if(ans==1)ans1++;
		if(ans==0 && id%2==1)ans2++;
		if(ans==1 && id%2==0)ans3++;
		if(ans==0 && id%1024==0)ans4++;
//		cout<<x<<' '<<y<<' '<<ans<<endl;
//		cout<<x<<' '<<y<<' '<<z<<' '<<Z<<' '<<nowL<<' '<<nowR<<" ans="<<ans<<endl;
//		for(i=nowL;i<=nowR;i++)cout<<Left[i]<<' ';cout<<endl;
//		for(i=nowL;i<=nowR;i++)cout<<Right[i]<<' ';cout<<endl<<endl;
	}cout<<ans1<<' '<<ans2<<' '<<ans3<<' '<<ans4<<endl;
	return 0;
}
```

---

## 作者：llingy (赞：2)


[可能更好的阅读体验](https://llingy.ml/posts/1261641707/)

>别叹息太多告别，至少相遇很真切。
>摇曳着盛放枯竭，时间从未停歇。
>天涯浪迹的白雪，念念不忘山川蝴蝶。
>听说有人孤负黑夜，偏要点亮人间的月。

## 简要题意

定义运算 $a \operatorname{nand} b$ 为 $\operatorname{not}(a \operatorname{and} b)$，$\operatorname{and}$ 指按位与，$\operatorname{not}$ 指按位取反。你需要动态维护一个数列，支持在前端插入，后端插入，询问一段前缀或后缀的 $\operatorname{nand}$ 和，保证在任意时刻数列中只有 $0$ 和 $1$。

## 思路

此处仅介绍前缀的做法，后缀与前缀维护方式相同。

$\operatorname{nand}$ 的运算表：

| $\bf{nand}$ | $\bf{0}$ | $\bf{1}$ |
| :---------: | :------: | :------: |
|     $0$     |   $1$    |   $1$    |
|     $1$     |   $1$    |   $0$    |

容易发现，当参与运算的两个数字中只要有 $0$ 那么运算结果必为 $1$。所以当询问的前缀最后一个数字为 $0$ 时，必然结果为 $1$。而如果是 $1$，由于任意一段以 $0$ 结尾的前缀的 $\operatorname{nand}$ 和必为 $1$。则只需计算在这个数字前面离这个数字最近的一个 $0$ 到这个数字的 $\operatorname{nand}$ 和。这是一段全 $1$ 段。全 $1$ 段的运算结果与 $1$ 的个数奇偶性相关。考虑对于每个 $1$ 维护 $dis_i$ 表示第 $i$ 个位置距前面最近一个 $0$ 的距离，初始时 $dis_i$ 为 $-1$ 表示前面没有 $0$。

往后插入一个数的时候，当这个数为 $1$ 时更新 $dis$。设插入的位置为 $i$，检查前面一个数，如果前面为 $0$，$dis_i$ 赋为 $1$。否则按照 $dis_{i-1}$ 更新 $dis_i$。

往前插入一个数的时候，这个数为 $1$ 时直接把 $dis_1$ 赋为 $-1$，若为 $0$，则向后遍历每个值为 $1$ 并且 $dis$ 为 $-1$ 的位置，更新这些位置的 $dis$ 值。每个数字最多被离其最近的前面的 $0$ 更新一次，均摊时间复杂度 $O(1)$。

注意特判 $0$ 在第一个数时的情况，没有进行 $\operatorname{nand}$ 运算，值为 $0$。

设有 $n$ 次操作，时间复杂度为 $O(n)$。

## Code
合理使用封装可以简化代码。此份代码省略题面提供的数据生成器。
```cpp
#include<cstdio>
#include<iostream>
namespace lly
{
ㅤㅤusing namespace std;
ㅤㅤconstexpr int N=1e7+11;
ㅤㅤstruct deque
ㅤㅤ{
ㅤㅤㅤㅤint a[N<<1],dis[N<<1],p1=N,p2=N;
ㅤㅤㅤㅤinline void push_back(int x)
ㅤㅤㅤㅤ{
ㅤㅤㅤㅤㅤㅤ++x;
ㅤㅤㅤㅤㅤㅤa[++p2]=x;
ㅤㅤㅤㅤㅤㅤif(a[p2]==1)return;
ㅤㅤㅤㅤㅤㅤif(a[p2-1]==2)dis[p2]=((dis[p2-1]==-1)?-1:(dis[p2-1]+1));
ㅤㅤㅤㅤㅤㅤelse dis[p2]=(p2==p1+1?-1:0);
ㅤㅤㅤㅤ}
ㅤㅤㅤㅤinline void push_front(int x)
ㅤㅤㅤㅤ{
ㅤㅤㅤㅤㅤㅤ++x;
ㅤㅤㅤㅤㅤㅤa[p1--]=x;
ㅤㅤㅤㅤㅤㅤif(a[p1+1]==1) for(int i=p1+2;i<=p2&&a[i]==2;i++)dis[i]=i-p1-2;
ㅤㅤㅤㅤㅤㅤelse dis[p1+1]=-1;
ㅤㅤㅤㅤ}
ㅤㅤㅤㅤinline int query(int x)
ㅤㅤㅤㅤ{
ㅤㅤㅤㅤㅤㅤif(a[p1+x]==1) return x!=1;
ㅤㅤㅤㅤㅤㅤif(dis[p1+x]==-1) return x&1;
ㅤㅤㅤㅤㅤㅤif(dis[p1+x]==x-2) return (dis[p1+x]&1)^1;
ㅤㅤㅤㅤㅤㅤreturn dis[p1+x]&1;
ㅤㅤㅤㅤ}
ㅤㅤ}o,r;
ㅤㅤnamespace collect
ㅤㅤ{
ㅤㅤㅤㅤint s1=0,s2=0,s3=0,s4=0;
ㅤㅤㅤㅤinline void put(int id,int x)
ㅤㅤㅤㅤ{
ㅤㅤㅤㅤㅤㅤif(x)++s1;
ㅤㅤㅤㅤㅤㅤif((id&1)&&!x)++s2;
ㅤㅤㅤㅤㅤㅤif(!(id&1)&&x)++s3;
ㅤㅤㅤㅤㅤㅤif(!(id&1023)&&!x)++s4;
ㅤㅤㅤㅤ}
ㅤㅤㅤㅤinline void out(){cout<<s1<<" "<<s2<<" "<<s3<<" "<<s4<<"\n";}
ㅤㅤ}
ㅤㅤinline void work()
ㅤㅤ{
ㅤㅤㅤㅤint n;scanf("%d",&n);
ㅤㅤㅤㅤMaker::Begin(n);
ㅤㅤㅤㅤfor(int i=1;i<=n;i++)
ㅤㅤㅤㅤ{
ㅤㅤㅤㅤㅤㅤint x,y,z;Maker::Get_Nextline(x,y,z);
ㅤㅤㅤㅤㅤㅤif(x==0)
ㅤㅤㅤㅤㅤㅤ{
ㅤㅤㅤㅤㅤㅤㅤㅤif(y==0) o.push_front(z),r.push_back(z);
ㅤㅤㅤㅤㅤㅤㅤㅤelse o.push_back(z),r.push_front(z);
ㅤㅤㅤㅤㅤㅤ}
ㅤㅤㅤㅤㅤㅤelse
ㅤㅤㅤㅤㅤㅤ{
ㅤㅤㅤㅤㅤㅤㅤㅤint ans;
ㅤㅤㅤㅤㅤㅤㅤㅤif(y==0) ans=o.query(z);
ㅤㅤㅤㅤㅤㅤㅤㅤelse ans=r.query(z);
ㅤㅤㅤㅤㅤㅤㅤㅤcollect::put(i,ans);
ㅤㅤㅤㅤㅤㅤ}
ㅤㅤㅤㅤ}
ㅤㅤㅤㅤcollect::out();
ㅤㅤ}
}
int main()
{
ㅤㅤ#ifdef llydebug
ㅤㅤfreopen(".in","r",stdin);
ㅤㅤ#endif
ㅤㅤlly::work();
ㅤㅤreturn 0;
}
```

---

## 作者：StudyingFather (赞：1)

与非运算并不满足结合律，因此我最初的想法是利用德摩根律化简所求表达式，再考虑用数据结构维护信息。后面发现并无收获，最终放弃。

我们先观察与非运算的真值表：

| $a$ | $b$ | $\mathit{out}$ |
| :-----------: | :-----------: | :-----------: |
| $0$ | $0$ | $1$ |
| $0$ | $1$ | $1$ |
| $1$ | $0$ | $1$ |
| $1$ | $1$ | $0$ |

容易发现，与非运算的输出结果为 $1$，当且仅当输入的两个值中，存在一个 $0$。

利用这一结论，题目所求的表达式就可以大大化简了：我们找到一个值为 $0$ 的变量，则在它之前的部分的表达式的值与这个 $0$ 进行与非运算，输出一定是 $1$（这里有个例外，稍后再提）。

我们通过这个方法化简表达式，最后可以得到若干个 $1$ 参与运算的与非表达式。这个表达式是容易求值的：若表达式含有奇数个 $1$，值为 $1$；若表达式含有偶数个 $1$，值为 $0$。

现在我们需要维护序列中 $0$ 的信息。注意到，为了使式子化为最简，我们每次需要找到距离表达式末端最近的那个 $0$，考虑维护这个信息。

这里以前缀为例，后缀同理不再展开。

对于前缀的情况，我们对于每个变量，需要找到其左边的第一个 $0$。我们只需要在每从左端插入一个新的 $0$ 时，将这个 $0$ 和上一个 $0$ 之间的 $1$（以及新插入的 $0$）的信息更新为指向新插入的 $0$ 即可。

因为只有两端插入操作，上面的维护信息操作每个位置最多被修改一次，时间复杂度是 $O(n)$ 的。

最后说一下前面提到的例外：虽然与非运算里有 $0$ 作为输入数时，输出值为 $1$，但单独的一个 $0$ 出现时，因为它没有参与与非运算，还需要将其作为 $0$ 看待。

感觉自己的实现挺丑，调试的时候有点烧脑。

```cpp
// Problem: P5523 [yLOI2019] 珍珠
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P5523
// Memory Limit: 500 MB
// Time Limit: 2000 ms
//
// Powered by CP Editor (https://cpeditor.org)

// --模板部分略去--

const int maxn = 10000000;
// 实现的时候考虑将左端插入的部分和右端插入的部分分开处理。
int lh[maxn + 5], rh[maxn + 5];
int lhl[maxn + 5], rhl[maxn + 5];
int lhr[maxn + 5], rhr[maxn + 5];
int ltop = maxn, rtop = 1;

void insert(int y, int z) {
  if (y == 0) {
    lh[ltop] = z;
    if (z == 0) {
      lhl[ltop] = ltop;
      for (int i = ltop + 1; lh[i] && i <= maxn; i++) lhl[i] = ltop;
      lhr[ltop] = ltop;
    } else
      lhr[ltop] = lhr[ltop + 1];
    ltop--;
  } else {
    rh[rtop] = z;
    if (z == 0) {
      rhr[rtop] = rtop;
      for (int i = rtop - 1; rh[i] && i > 0; i--) rhr[i] = rtop;
      rhl[rtop] = rtop;
    } else
      rhl[rtop] = rhl[rtop - 1];
    rtop++;
  }
}
int query(int y, int z) {
  if (y == 0) {
    if (ltop + z <= maxn) {
      int pos = ltop + z;
      if (lhl[pos] == -1)
        return z % 2;
      else {
        int npos = lhl[pos];
        return (pos - npos + (npos != ltop + 1)) % 2;
      }
    } else {
      int pos = (ltop + z) - maxn;
      if (rhl[pos] == -1) {
        if (lhl[maxn] == -1)
          return z % 2;
        else {
          int npos = lhl[maxn];
          return (ltop + z - npos + (npos != ltop + 1)) % 2;
        }
      } else {
        int npos = rhl[pos];
        return (pos - npos + (npos != 1 || ltop != maxn)) % 2;
      }
    }
  } else {
    if (rtop - z > 0) {
      int pos = rtop - z;
      if (rhr[pos] == -1)
        return z % 2;
      else {
        int npos = rhr[pos];
        return (npos - pos + (npos != rtop - 1)) % 2;
      }
    } else {
      int pos = maxn + (rtop - z);
      if (lhr[pos] == -1) {
        if (rhr[1] == -1)
          return z % 2;
        else {
          int npos = rhr[1];
          return (maxn - pos + 1 + npos - (npos == rtop - 1)) % 2;
        }
      } else {
        int npos = lhr[pos];
        return (npos - pos + (npos != maxn || rtop != 1)) % 2;
      }
    }
  }
}
int main() {
  int n;
  scanf("%d", &n);
  Maker::Begin(n);
  memset(lhl, -1, sizeof(lhl));
  memset(lhr, -1, sizeof(lhr));
  memset(rhl, -1, sizeof(rhl));
  memset(rhr, -1, sizeof(rhr));
  int res1 = 0, res2 = 0, res3 = 0, res4 = 0;
  int cnt = 0;
  for (int k = 1; k <= n; k++) {
    int x, y, z;
    Maker::Get_Nextline(x, y, z);
    if (x == 0)
      insert(y, z);
    else {
      cnt++;
      int res = query(y, z);
      res1 += (res == 1);
      res2 += (k % 2 == 1 && res == 0);
      res3 += (k % 2 == 0 && res == 1);
      res4 += (k % 1024 == 0 && res == 0);
    }
  }
  printf("%d %d %d %d\n", res1, res2, res3, res4);
  return 0;
}
```

---


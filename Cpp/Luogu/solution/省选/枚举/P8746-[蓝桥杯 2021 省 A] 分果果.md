# [蓝桥杯 2021 省 A] 分果果

## 题目描述

小蓝要在自己的生日宴会上将 $n$ 包糖果分给 $m$ 个小朋友。每包糖果都要分出去，每个小朋友至少要分一包，也可以分多包。

小蓝已经提前将糖果准备好了，为了在宴会当天能把糖果分得更平均一些，小蓝要先计算好分配方案。

小蓝将糖果从 $1$ 到 $n$ 编号, 第 $i$ 包糖果重 $w_{i}$ 。小朋友从 $1$ 到 $m$ 编号。每个小朋友只能分到编号连续的糖果。小蓝想了很久没想出合适的分配方案使得每个小朋友分到的糖果差不多重。因此需要你帮他一起想办法。为了更好的分配糖果，他可以再买一些糖果，让某一些编号的糖果有两份。当某个编号的糖果有两份时，一个小朋友最多只能分其中的一份。

请找一个方案，使得小朋友分到的糖果的最大重量和最小重量的差最小，请输出这个差。

例如，小蓝现在有 5 包糖果, 重量分别为 $6,1,2,7,9$，如果小蓝要分给两个小朋友，则他可以将所有糖果再买一份，两个小朋友都分到 $1$ 至 $5$ 包糖果，重量都是 $25$, 差为 $0$。

再如，小蓝现在有 $5$ 包糖果, 重量分别为 $6,1,2,7,9$，如果小蓝要分给三个小朋友，则他可以将第 $3$ 包糖果再买一份，第一个小朋友分 $1$ 至 $3$ 包，第二个小朋友分 $3$ 至 $4$ 包，第三个小朋友分第 $5$ 包，每个小朋友分到的重量都是 $9$，差为 $0$。

再如, 小蓝现在有 5 包糖果, 重量分别为 $6,1,2,7,9$, 如果小蓝要分给四个小朋友，则他可以将第 $3$ 包和第 $5$ 包糖果再买一份, 仍然可以每个小朋友分到的重量都是 $9$，差为 $0$。

再如, 小蓝现在有 $5$ 包糖果, 重量分别为 $6,1,2,7,9$, 如果小蓝要分给五个小朋友, 则他可以将第 $4$ 包和第 $5$ 包糖果再买一份, 第一个小朋友分第 $1$ 至 $2$ 包重量为 $7$ , 第二个小朋友分第 $3$ 至 $4$ 包重量为 $9$, 第三个小朋友分第 $4$ 包重 量为 $7$, 第四个和第五个小朋友都分第 $5$ 包重量为 $9$。差为 $2$。

## 说明/提示

对于 $30 \%$ 的评测用例, $1 \leq n \leq 10,1 \leq m \leq 10,1 \leq w_{i} \leq 10$;

对于 $60 \%$ 的评测用例, $1 \leq n \leq 30,1 \leq m \leq 20,1 \leq w_{i} \leq 30$;

对于所有评测用例, $1 \leq n \leq 100,1 \leq m \leq 50,1 \leq w_{i} \leq 100$ 。在评测数据 中, $w_{i}$ 随机生成, 在某个区间均匀分布。

蓝桥杯 2021 第一轮省赛 A 组 J 题。

## 样例 #1

### 输入

```
5 2
6 1 2 7 9```

### 输出

```
0```

## 样例 #2

### 输入

```
5 5
6 1 2 7 9```

### 输出

```
2```

# 题解

## 作者：Natsuzora (赞：10)

# 题目描述
小蓝要在自己的生日宴会上将 $n$ 包糖果分给 $m$ 个小朋友。每包糖果都要分出去，每个小朋友至少要分一包，也可以分多包。

小蓝已经提前将糖果准备好了，为了在宴会当天能把糖果分得更平均一些，小蓝要先计算好分配方案。 小蓝将糖果从 $1$ 到 $n$ 编号，第 $i$ 包糖果重 $w_i$。小朋友从 $1$ 到 $m$ 编号。每个小朋友只能分到编号连续的糖果。小蓝想了很久没想出合适的分配方案使得每个小朋友分到的糖果差不多重。因此需要你帮他一起想办法。为了更好的分配糖果，他可以再买一些糖果，让某一些编号的糖果有两份。当某个编号的糖果有两份时，一个小朋友最多只能分其中的一份。

请找一个方案，使得小朋友分到的糖果的最大重量和最小重量的差最小，请输出这个差。
# 评测用例规模与约定
对于所有评测用例，$1 \leq n \leq 100$，$1 \leq m \leq 50$，$1 \leq w_i \leq 100$。在评测数据中，$w_i$ 随机生成，在某个区间均匀分布。
# 题解
考虑 $DP$。

大概可以列出这五个维度：分出的区间个数，最后一个用了一颗糖的位置，最后一个用了两颗糖的位置，区间和的最小值，区间和的最大值。

考虑把其中一维拿出来作为 $DP$ 维护的值，这一维必须满足的条件是满足越大越优或者越小越优的单调性。

只有最小值和最大值满足单调性。此时很关键的一点，我们发现最小值有上界 $\frac {2\cdot sum}{m}$，使得时间复杂度有显著的优化，而最小值有一个不太重要的下界，因此我们枚举最小值，把最大值作为 $DP$ 维护的值。

## 设计 $DP$ 转移
令 $sum=\sum w_i$，规划 $DP$：$f_{i,j,k}$ 表示前 $i$ 个区间，最后一个用了一颗糖的位置在 $j$，最后一个用了两颗糖的位置在 $k$（在 $k$ 之前也行），最大值最小是多少。考虑 $3$ 种转移：
+ $f_{i,j,k}\leftarrow f_{i,j,k-1}$ 

+ 第 $i$ 个人用了上一次的 $j+1$ 开始的一段，这种转移是 $f_{i,j,k}\leftarrow \max(f_{i-1,j',k},s_j-s_{j'})$ 

+ 第 $i$ 个人用了上一次的 $k+1$ 开始的一段，这种转移有两类： 

  + $f_{i,j,k}\leftarrow \max(f_{i-1,j,k'},s_k-s_{k'})$，要求 $j\ge k,k'$，意思是放在第二段，还没有超出原来第一段的范围。
    然而这种转移（区间互相包含）一定不优。
	
  + $f_{i,j,k}\leftarrow \max_{}(f_{i-1,k,j'},s_k-s_{j'})$，要求是 $j'\le k\le j$ 
    转移是 $O(n)$ 的，注意转移合法的要求是新的一段和 $\ge mi$ 
### 区间包含不优证明
为什么区间互相包含一定不优？我们可以从调整的角度来想这个问题。首先构思一个大区间，一个小区间，还有一个区间位于小区间的右边，但与大区间存在一部分重叠，称这个区间为右区间。

第一个结论：小区间和右区间之间不应该存在间隔。很显然小区间右端点调整到右区间的左边会更优。

而当小区间和右区间之间没有间隔后，我们就可以把大区间的右端点调整为小区间的右端点，显然这样大区间的和会更接近于小区间的和，使得结果更优。

如果没有右区间，同理我们可以将小区间的右端点调整到大区间的右端点。

考虑这样做的复杂度，实际上是 $O(\frac {2\cdot sum}{m}×n^3m)=O(sum\cdot n^3)$。

### 优化
+ 对于第三类转移，不难发现 $f_{i,j,k}$ 是随着 $k$ 增加而单减的，那么选取尽量靠后的转移点一定最优。

+ 对于第二类转移，考虑单调栈优化。具体地说，由于 $s_j-s_{j'}$ 是随 $j'$ 增加而单调递减的，我们需要的是 $min\{s_j-s_{j'},f_{i-1,j',k}\}$ 最小，那么当 $s_j-s_{j'}$ 变大时，若 $f_{i-1,j',k}$ 也变大，那么这样的点 $j'$ 可以舍弃，符合单调栈的原则。而我们发现，随着 $j$ 的增加，$s_j-s_{j'}$ 的图像是向上平移的，这将会导致最佳转移点的右移；而 $f$ 的图像只能被“往下压”，在其长度不变短的情况下，也会导致最佳转移点的右移。因此我们维护这个最佳转移点即可，值得注意的是最佳转移点可能是相邻的两点。
# Code

有点卡时，在洛谷上开 $O_2$ 才能过。

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;
const int M = 51, N = 101;

int n, m, w[N], f[M][N][N], st[N], ans = 0x7fffffff;

int main(){
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; i++){
        scanf("%d", &w[i]);
        w[i] += w[i - 1];
    }
    for(int minw = 1; minw <= 2 * w[n] / m; minw++){
        memset(f, 0x7f, sizeof(f));
        f[0][0][0] = minw;
        for(int i = 1; i <= m; i++) {
            for(int j = 0; j <= n; j++){
                *st = 0;
                int p = 0, pst = 1;
                for(int k = j; k <= n; k++){
                    if(j > 0) f[i][j][k] = f[i][j - 1][k];
                    while(w[k] - w[p] >= minw){
                        if(p >= j){
                            while(*st && f[i - 1][j][p] <= f[i - 1][j][st[*st]])
                                (*st)--;
                            st[++*st] = p;
                        }
                        p++;
                    }
                    if(*st){
                        pst = min(pst, *st);
                        while(pst < *st && f[i - 1][j][st[pst + 1]] < w[k] - w[st[pst + 1]])
                            pst++;
                        while(pst > 1 && f[i - 1][j][st[pst]] > w[k] - w[st[pst]])
                            pst--;
                        f[i][j][k] = min(f[i][j][k], max(f[i - 1][j][st[pst]], w[k] - w[st[pst]]));
                        if(pst < *st)
                            f[i][j][k] = min(f[i][j][k], max(f[i - 1][j][st[pst + 1]], w[k] - w[st[pst + 1]]));
                    }
                    int pp = min(p - 1, j);
                    if(pp >= 0)
                        f[i][j][k] = min(f[i][j][k], max(f[i - 1][pp][j], w[k] - w[pp]));
                }
            }
        }
        ans = min(ans, f[m][n][n] - minw);
    }
    printf("%d", ans);
    return 0;
}
```

---

## 作者：wgyhm (赞：0)

在[模拟赛](https://wgyhm.top/2023/07/07/7-5-%E6%A8%A1%E6%8B%9F%E8%B5%9B/)中做到的。

## Description

P8746 [蓝桥杯 2021 省 A] 分果果。

## Solution

外面枚举最小值 $minn$，考虑求最大值。

一个显然的性质是任意两个人取糖果的区间不包含。考虑两个区间 $l1<l2<r2<r1$，如果换为 $[l1,r2],[l2,r1]$ 这样的极差显然更小。

令 $f_{i,j,k}$ 表示，第 $i$ 个区间，上一个取一颗糖果的位置为 $j$，上一个取两颗糖果的位置为 $k,j\ge k$，最小为 $f_{i,j,k}$。

* 两颗糖果的位置不取，$f_{i,j,k}\leftarrow f_{i,j,k-1}$，这也说明 $f_{i,j,k}$ 关于 $k$ 单调递减。
* 在 $t\le k$ 取，$f_{i,j,k}\leftarrow \max(f_{i-1,k,t},s_j-s_t)$，把 $\max$ 中的两项当作两个关于 $t$ 的函数，可以发现两者都关于 $t$ 递减。所以取 $t$ 最大的即可。**但是注意要满足 $s_j-s_t\ge minn$**。
* 在 $k+1\le t\le j$ 之间取。这在**之后**会在第二种情况算到，所以可以**不需要转移**。因为转移两次的一定小于等于转移一次。如果转移两次的继续取，等到大于转移一次的位置，转移一次的位置就成了转移两次的。

这样只需要一个指针维护即可。$dp$ 的复杂度为 $O(n^2\times m)$。

外面枚举的**最小值**复杂度是 $O(\dfrac{sum}{m})$，具体的，枚举的上界是 $\dfrac{2nw}{m}$。

总的复杂度就是 $O(n^3w)$。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int m,n,w[105],base;
int f[55][105][105];
int stac[106],tot,ans=1e9; 
inline void solve(int minn) {
	int i,j,k,pp,p;
	memset(f,0x3f,sizeof(f));
	f[0][0][0]=minn;
	for (i=1;i<=m;i++) {
		for (k=0;k<=n;k++) {
			p=tot=0;
			for (j=k;j<=n;j++) {
				if (k>0) f[i][j][k]=min(f[i][j][k],f[i][j][k-1]);
				while (w[j]-w[p]>=minn) p++;
				if ((pp=min(p-1,k))>=0) f[i][j][k]=min(f[i][j][k],max(f[i-1][k][pp],w[j]-w[pp]));
			}
		}
	}
	ans=min(ans,f[m][n][n]-minn);
}
signed main(void){
  	freopen("candy.in","r",stdin);
  	freopen("candy.out","w",stdout);
	int i;
	cin>>n>>m;
	for (i=1;i<=n;i++) cin>>w[i],w[i]+=w[i-1];
	base=w[n]*2/m;
	for (i=1;i<=base;i++) solve(i);
	printf("%d",ans);
	return 0;
}
```

---


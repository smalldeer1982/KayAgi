# [科大国创杯初中组 2023] 石子

## 题目描述

小可可面前有 $n$ 堆石子，第 $i$ 堆石子有 $a_i$ 个石子。小可可想要在开始选择一堆石子，然后从它开始，每次合并这堆石子左边的那堆石子或者右边的那堆石子。合并两堆石子个数为 $x, y$ 的石子堆需要花 $x + y$ 的力气，并且会合并成一堆 $x + y$ 个石子的石子堆。

小可可想花费最小的力气从最初选择的那堆石子开始，将所有石子都合并完。小可可想知道，如果他选择编号在 $[l, r]$ 里面的每一堆石子作为最初的石子，那么他将 $n$ 堆石子合并成一堆花的最小力气是多少。

小可可不想太为难你，所以他保证所有的 $a_i$ 是随机的。

## 说明/提示

### 样例 1 解释

对于第 $1$ 堆石子作为初始的石子堆，最优（也是唯一）的合并策略是先合并第 $2$ 堆，再合并第 $3$ 堆，随后合并第 $4$ 堆，花费力气为 $25$；

对于第 $2$ 堆石子作为初始的石子堆，最优的合并策略是先合并第 $3$ 堆，再合并第 $4$ 堆，随后合并第 $1$ 堆，花费力气为 $19$；

对于第 $3$ 堆石子作为初始的石子堆，最优的合并策略是先合并第 $2$ 堆，再合并第 $4$ 堆，随后合并第 $1$ 堆，花费力气为 $19$；

对于第 $4$ 堆石子作为初始的石子堆，最优（也是唯一）的合并策略是先合并第 $3$ 堆，再合并第 $2$ 堆，随后合并第 $1$ 堆，花费力气为 $19$。

### 数据规模与约定

对于 $20 \%$ 的数据，满足 $n \leq 10$；

对于 $40 \%$ 的数据，满足 $n \leq 300$；

对于 $60 \%$ 的数据，满足 $n \leq 5000$；

对于另外 $20 \%$ 的数据，满足 $n \leq 10^5, r - l + 1 \leq 50$；

对于 $100 \%$ 的数据，有 $1 \leq l \leq r \leq n \leq 10^5, 1 \leq a_i \leq 10^8$。保证 $a_i$ 随机。随机方式为：先选择一个所有 $a_i$ 的上界 $v$，对于每个 $a_i$，它在 $[1, v]$ 中的所有整数中等概率随机选取一个。

## 样例 #1

### 输入

```
4 1 4
5 1 3 1```

### 输出

```
25 19 19 19```

# 题解

## 作者：huangleyi0129 (赞：2)

$O(n^2)$ 的区间 DP 是显然的，但似乎是场上的最高分。

DP 是没有前途的，我们贪心地考虑该问题。

设起点为 $x$，先考虑一种特殊情况，即 $x$ 左边单调递减，右边单调递增。

此时显然可以直接贪心选较小的，很好做，故考虑将原问题转化至此情况。

将一个区间的点抽象成块，考虑调整左右两个块的顺序会如何。

令 $\Delta ans=len_2S_1-len_1S_2\le 0$，即 $\overline{a_1}=\frac{S_1}{len_1}\le\frac{S_2}{len_2}=\overline{a_2}$。

即一般地，先处理平均值较小的块。

所以，以 $i$ 启的向右的块一定延申至 $j$，使得 $\overline{a}$ 最小（向左同理），计算的时间复杂度为均摊 $O(n)$。

这样，我们就有了一个单点 $O(n)$ 的做法。

由于数据随机，所以做法其实是单点 $O(\log n)$，总 $O(n\log n)$ 的。

如果不随机，我们发现答案只与 $x$ 两边块的状态（如 $len$，$S$，$\sum ia_i$，etc. ）与它们平均值的顺序有关，离散化后扔进 DS （如线段树）里即可，移动时修改。

贴一下保证随机的代码（目前最优解）：


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=100005;
int a[N],f[N],g[N],n,l,r;
ll s[N],s2[N];
ll S(const int l,const int r)
{
	return s[r]-s[l-1];
}
ll cost(const int x,const int dir,const int t)
{
	int r=dir?g[x]:f[x];
	if(dir==1)
		return (t+x)*S(x,r)-(s2[r]-s2[x-1]);
	else
		return (t-x)*S(r,x)+s2[x]-s2[r-1];
}
void init()
{
	int x;
	f[1]=1;
	for(int i=2;i<=n;++i)
	{
		f[i]=i,x=i-1;
		while(x>0&&(i-f[i]+1)*S(f[x],x)<=(x+1-f[x])*S(f[i],i))
			f[i]=f[x],x=f[x]-1;
	}
	g[n]=n;
	for(int i=n-1;i>=1;--i)
	{
		g[i]=i,x=i+1;
		while(x<=n&&(g[i]-i+1)*S(x,g[x])<=(g[x]-x+1)*S(i,g[i]))
			g[i]=g[x],x=g[x]+1;
	}
}
void solve(const int s)
{
	int l=s-1,r=s+1,t=n-1;
	long long ans=(ll)(n-1)*a[s];
	while(l>0&&r<=n)
	{
		if(S(f[l],l)*(g[r]-r+1)<=S(r,g[r])*(l-f[l]+1))
			ans+=cost(l,0,t),t-=(l-f[l]+1),l=f[l]-1;
		else
			ans+=cost(r,1,t),t-=(g[r]-r+1),r=g[r]+1;
	}
	while(l>0)
		ans+=cost(l,0,t),t-=(l-f[l]+1),l=f[l]-1;
	while(r<=n)
		ans+=cost(r,1,t),t-=(g[r]-r+1),r=g[r]+1;
	cout<<ans<<' ';
}
int main()
{
	ios::sync_with_stdio(0),cin.tie(0);
	cin>>n>>l>>r;
	for(int i=1;i<=n;++i)
		cin>>a[i],s[i]=s[i-1]+a[i],s2[i]=s2[i-1]+1LL*a[i]*i;
	init();
	for(int i=l;i<=r;++i)
		solve(i);
	return 0;
}
```

---

## 作者：Purslane (赞：2)

# Solution

还是写个题解吧。

假设我们从 $pos$ 开始往两边扩展。相当于：给定序列 $A = \{a_{pos-1},a_{pos-2},\cdots\}$ 和 $B = \{a_{pos+1},a_{pos+2},\cdots\}$，将 $A$ 和 $B$ **归并成序列 $C$**，并最小化 $\sum_{i=1}^{n-1} (n-i) C_i$。

很容易想到 $O(n^2)$ 的区间 DP（事实上这是当时本题的全省最高分），不多赘述了。

考虑基础的调整。如果 $C_i > C_{i+1}$ 且 $C_i$ 与 $C_{i+1}$ 初始并不在同一个序列中，那么可以将他们交换。

因此考察 $C$ 的中最大值，假设它原来在 $A$ 中，为 $A_p$。那么 $A_p$ 和 $A_{p+1}$ 在 $C$ 中**一定是相邻的**，否则可以将他们中间夹的 $B$ 全部调整到 $A_p$ 的前面。可以将这两个数直接合并起来，当做一整“块”。特别地，如果最小值在末尾可以直接将其忽略，然后考虑次大值，以此类推。

而两个块之间交换位置，发现将**平均值更小的块放在前面一定更优**。不断执行这两个流程，直到所有块的平均值都是递增的。

所以我们只需要将 $A$ 和 $B$ 通过某种操作变为平均值上升的块，就可以直接归并排序起来。而 $A$ 和 $B$ 的变化是独立的。

事实上我们不需要考虑最大值。只要有一个块比它后面那个块的平均值要小，就可以直接将他们俩合并起来。因为一个块如果和前面的一个人合并，一定会让它的平均值增大；那么总有一个时刻当前块会变为最大值和后面的合并。也就是说，我们可以增量的处理 $A$ 和 $B$ 操作后的结果。

考虑使用单调栈。具体的，我们最开始将每个数当做一个独立的块。然后不断地和栈顶合并，直到满足平均值递增。

对于本题来说，由于数据随机，可以保证 $A$ 和 $B$ 的单调栈并不大，直接存下来然后对 $l$ 到 $r$ 每个位置做一次归并即可。

实际上数据不随机也能做。因为单调栈总的变化是线性的，所以你可以从左到右维护 $A$ 的单调栈，并且把 $B$ 的单调栈的变化记录下来，然后使用线段树维护归并后的结果。

不管咋做复杂度都是单 $\log$ 的。

代码是我初三的时候写的，就不放出来了。想要的在本题解下评论。

---


# [NOI2009] 诗人小G

## 题目描述

小 G 是一个出色的诗人，经常作诗自娱自乐。但是，他一直被一件事情所困扰，那就是诗的排版问题。

一首诗包含了若干个句子，对于一些连续的短句，可以将它们用空格隔开并放在一行中，注意一行中可以放的句子数目是没有限制的。小 G 给每首诗定义了一个行标准长度（行的长度为一行中符号的总个数），他希望排版后每行的长度都和行标准长度相差不远。显然排版时，不应改变原有的句子顺序，并且小 G 不允许把一个句子分在两行或者更多的行内。在满足上面两个条件的情况下，小 G 对于排版中的每行定义了一个不协调度, 为这行的实际长度与行标准长度差值绝对值的 $P$ 次方，而一个排版的不协调度为所有行不协调度的总和。

小 G 最近又作了几首诗，现在请你对这首诗进行排版，使得排版后的诗尽量协调（即不协调度尽量小），并把排版的结果告诉他。


## 说明/提示

#### 样例输入输出 1 解释

前两组输入数据中每行的实际长度均为 $6$，后两组输入数据每行的实际长度均为 $4$。一个排版方案中每行相邻两个句子之间的空格也算在这行的长度中（可参见样例中第二组数据）。每行末尾没有空格。

#### 数据规模与约定

| 测试点 | $T$ | $N$ | $L$ | $P$ |
| - | - | - | - | - |
| $1$ | $\le 10$ | $\le18$ | $\le 100$ | $\le5$ |
| $2$ | $\le 10$ | $\le 2\times 10^3$ |  $\le 6\times 10^4$| $\le10$ |
| $3$ | $\le 10$ | $\le 2\times 10^3$ |  $\le 6\times 10^4$| $\le10$ |
| $4$ | $\le 5$ | $\le 10^5$ | $\le 200$ | $\le10$ |
| $5$ | $\le 5$ | $\le 10^5$ | $\le 200$ | $\le10$ |
| $6$ | $\le 5$ | $\le 10^5$ | $\le 3\times 10^6$ | $2$ |
| $7$ | $\le 5$ | $\le 10^5$ | $\le 3\times 10^6$ | $2$ |
| $8$ | $\le 5$ | $\le 10^5$ | $\le 3\times 10^6$ | $\le10$ |
| $9$ | $\le 5$ | $\le 10^5$ | $\le 3\times 10^6$ | $\le10$ |
| $10$ | $\le 5$ | $\le 10^5$ | $\le 3\times 10^6$ | $\le10$ |

所有句子的长度不超过 $30$ 。

## 样例 #1

### 输入

```
4
4 9 3
brysj,
hhrhl.
yqqlm,
gsycl.
4 9 2
brysj,
hhrhl.
yqqlm,
gsycl.
1 1005 6
poet
1 1004 6
poet
```

### 输出

```
108
brysj,
hhrhl.
yqqlm,
gsycl.
--------------------
32
brysj, hhrhl.
yqqlm, gsycl.
--------------------
Too hard to arrange
--------------------
1000000000000000000
poet
--------------------
```

# 题解

## 作者：FlashHu (赞：125)

### 闲话

看完[洛谷larryzhong巨佬的题解](https://www.luogu.org/problemnew/solution/P1912)，蒟蒻一脸懵逼

如果哪年NOI（~~放心我这样的蒟蒻是去不了的~~）又来个决策单调性优化DP，那蒟蒻是不是会看都看不出来直接爆$0$？！

还是要想点办法，不失一般性也能快捷地判定决策单调。

## 对于判定决策单调的分析

再补一句决策单调性的概念：状态转移方程形如$f_i=\min/\max_{j=1}^{i-1} g_j+w_{i,j}$，且记$f_i$的最优决策点为$p_i$（也就是$f_i$从$g_{p_i}+w_{i,p_i}$处转移最优）若满足$p_i\le p_{i+1}$，则该方程满足决策单调性。（摘自蒟蒻的[DP优化总结](https://www.cnblogs.com/flashhu/p/9480669.html)）

显然每个决策$j$可以用一个关于$i$的函数$f_j(i)$表示。

函数的一个重要思想：数形结合！

光靠脑子想不到规律，只好先举一些~~用语言难以描述~~的反例。我们的函数不能这样

![](https://cdn.luogu.com.cn/upload/pic/30050.png)![](https://cdn.luogu.com.cn/upload/pic/30052.png)

看到这里Dalao们有没有一点想法呢？蒟蒻反正想到了一点——两个函数必须只有一个交点！在这一点之前一个函数更优，而之后就被永远取代了。

感觉满足条件的函数其实很少，分类讨论一下（如有误欢迎Dalao指教）

### 直线

显然上面的基本要求都满足。不过要是函数是直线的话都可以用斜率优化搞了（$k_1x+b_1\ge k_2x+b_2,x\ge\frac{b_2-b_1}{k_1-k_2}$）。

### 不是直线

为了避免图1的尴尬情况，可能需要**所有决策函数之间可以通过平移相互变换**（形如$f_j(x)=f_k(x-a)+b$）。

为了避免图2的尴尬情况，可能需要**函数的导函数在各自的定义域内单调递增/递减**（注意是导函数不是原函数）。

接着，根据蒟蒻肝过的几个题，好像还有一条规律——

如果导函数递增、求最大值（[柠檬](https://www.lydsy.com/JudgeOnline/problem.php?id=4709)），或者导函数递减、求最小值，要用单调栈。

如果导函数递增、求最小值（本题），或者导函数递减、求最大值（[Lightning Conductor](https://www.cnblogs.com/flashhu/p/9488184.html)），要用单调队列。

### 复杂的函数

蒟蒻见过这一道（[Yet another minimization problem](https://www.cnblogs.com/flashhu/p/9495839.html)）

感觉可以看成对于每一种数都有一个函数$\frac{(c_i-c_j)(c_i-c_j+1)}{2}$，单看这一个是满足决策单调性的（$c_i\ge c_j$，定义域内的导函数是递增的）。

那么总函数就可以写成$f_j(i)=g_j+\sum\frac{(c_i-c_j)(c_i-c_j+1)}{2}$，怎么看也不像是不满足决策单调性的。

## 本题的思路

那么就可以回归本题了。

设$len_i$为第$i$句的长度，$s_i=i+\sum\limits_{j=1}^i len_j$（加上$i$是默认一句话后面有空格）

设$f_i$为选前$i$句的最小代价，我们枚举当前这一行填入最后面的多少个句子，注意行末没有空格，长度要$-1$，那么有方程

$$f_i=\min\limits_{j=0}^{i-1}\{f_j+|s_i-s_j-1-L|^P\}$$

容易发现后面这一坨决策函数是关于直线$x=s_j+1+L$对称的。把它去绝对值，变成两段，显然左边一段和右边一段的导函数都是递增的，左边恒$<0$，右边恒$>0$。又因为这函数是连续的，所以当然整个函数的导函数也单调递增咯！

用队列维护决策二分栈的过程不再赘述，总结里也有。时间复杂度$O(Tn\log n)$

看到Dalao们都记录了一个三元组，可蒟蒻还是觉得没啥必要啊。。。只要保存队列中相邻两个元素的临界值$k$就好了吧。

一个写法技巧：

二分决策$x,y(x<y)$的临界值的时候，左端点设成$x$就好了，没必要设成$1$（难怪蒟蒻之前写Lightning Conductor跑得有点慢）

三个坑点：

不管是转移还是输出，都要去掉行末的空格（怪蒟蒻看题不清）

当答案大于$10^{18}$的时候开longlong也炸了，所以要用实数以牺牲精度的代价换来更大的值域。然而double真的WA了。于是要开long double。

cmath的pow太慢了容易TLE，要手写快速幂。

```cpp
#include<cstdio>
#include<cmath>
#include<cstring>
#define RG register
#define R RG int
#define G c=getchar()
#define Calc(i,j) f[j]+qpow(abs(s[i]-s[j]-L))//计算函数值
using namespace std;
typedef long double LD;//开long double
const int N=1e5+9;
int n,L,P,s[N],q[N],k[N],pr[N];
LD f[N];
char str[N][33];
inline int in(){
    RG char G;
    while(c<'-')G;
    R x=c&15;G;
    while(c>'-')x*=10,x+=c&15,G;
    return x;
}
inline LD qpow(RG LD b){//自己写快速幂
    RG LD a=1;
    for(R k=P;k;k>>=1,b*=b)
        if(k&1)a*=b;
    return a;
}
inline int bound(R x,R y){//二分临界值
    R l=x,r=n+1,m;//左端点设为x减小常数
    while(l<r){
        m=(l+r)>>1;
        Calc(m,x)>=Calc(m,y)?r=m:l=m+1;
    }
    return l;
}
int main(){
    R T=in(),i,h,t;
    while(T--){
        n=in();L=in()+1;P=in();//把L处理了一下
        for(i=1;i<=n;++i){
            if(scanf("%s",str[i]));
            s[i]=s[i-1]+strlen(str[i])+1;//记前缀和
        }
        for(q[i=h=t=1]=0;i<=n;++i){
            while(h<t&&k[h]<=i)++h;
            f[i]=Calc(i,q[h]);pr[i]=q[h];//记录转移位置方便输出方案
            while(h<t&&k[t-1]>=bound(q[t],i))--t;
            k[t]=bound(q[t],i);q[++t]=i;
        }
        if(f[n]>1e18)puts("Too hard to arrange");
        else{
            printf("%.0Lf\n",f[n]);
            for(q[t=0]=i=n;i;q[++t]=i=pr[i]);
            for(;t;--t){
                for(i=q[t]+1;i<q[t-1];++i)
                    printf("%s ",str[i]);
                puts(str[i]);//行末不要搞空格
            }
        }
        puts("--------------------");
    }
    return 0;
}
```

---

## 作者：Fading (赞：34)

没有证明怎么行？我来发一个...

------------


很显然的 dp 方程：

$$f_i=\min(f_j+|\text{sum}_i-\text{sum}_j+i-j-1-L|^P)$$

其中
$$\text{sum}_x=\sum_{i=1}^xa_i$$

如果这个状态转移方程是**决策单调**的，那么可以直接上单调队列。

但是怎么证明呢？

我们只需证明函数$G_j(i)=|\text{sum}_i+i-(\text{sum}_j+j)-(1+L)|^P$满足四边形不等式。

$$\Leftrightarrow\ G_j(i+1)+G_{j+1}(i)\geq G_{j}(i)+G_{j+1}(i+1)$$

尝试把左右两边统一化，简化式子，表示$G_{j},G_{j+1}$

设

$$u=\text{sum}_i+i-(\text{sum}_j+j)-(1+L),v=\text{sum}_i+i-(\text{sum}_j+a[j]+j+1)-(1+L)$$

则

$$\Leftrightarrow |u+1+a_{i+1}|^P+|v|^P\geq |u|^P+|v+1+a_{i+1}|^P$$

$$\Leftrightarrow |v|^P-|v+a_{i+1}+1|^P\geq |u|^P-|u+a_{i+1}+1|^P$$

$$\because\ u>v$$

所以原问题等价于证明$h(x)=|x|^P-|x+z|^P(z\in [0,\infty))$非严格单调递减。

注意到有绝对值，我们分类讨论。

### 当$x\in[0,\infty):$

$$h(x)=x^P-(x+z)^P$$

$$h'(x)=Px^{P-1}-P(x+z)^{P-1}$$

$$=Px^{P-1}-P\sum_{i=0}^{P-1}C_{P-1}^ix^{P-i-1}z^i$$

$$=-P\sum_{i=1}^{P-1}C_{P-1}^ix^{P-i-1}z^i$$

由于$z\geq 0,x\in[0,\infty),\therefore h'(x)\leq0,\text{Q.E.D.}$ 

### 当$x\in(-\infty,0),P\equiv0\pmod 2:$

$$h(x)=x^P-(x+z)^P$$

证明过程同第一种情况，此处省略。

### 当$x\in[-z,0),P\equiv1\pmod 2:$

$$h(x)=-x^P-(x+z)^P$$

$$h'(x)=-Px^{P-1}-P(x+z)^{P-1}$$

由于$x^{P-1}$恒大于$0$，$\therefore h'(x)\leq0,\text{Q.E.D.}$

### 当$x\in(-\infty,-z),P\equiv1\pmod 2:$

$$h(x)=-x^P+(x+z)^P$$

$$h'(x)=-Px^{P-1}+P(x+z)^{P-1}$$

$$h'(x)=-P(x^{P-1}-(x+z)^{P-1})$$

显然$x^{P-1}>(x+z)^{P-1}$，因为这是一个偶函数。

所以$h'(x)\leq 0,\text{Q.E.D.}$

#### 因此，原函数满足四边形不等式，得证。

那么直接上单调队列即可。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ljc 998244353
using namespace std;
#ifdef Fading
#define gc getchar
#endif
#ifndef Fading
inline char gc(){
    static char now[1<<16],*S,*T;
    if (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if (T==S) return EOF;}
    return *S++;
}
#endif
inline ll read(){
    register ll x=0,f=1;char ch=gc();
    while (!isdigit(ch)){if(ch=='-')f=-1;ch=gc();}
    while (isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=gc();}
    return (f==1)?x:-x;
}
long double dp[500201];
ll L,P,n,ans[500021],a[500201],sum[500201],dl[500201],hd,ta;
inline long double fast_pow(long double a,ll b){
	long double t=1;
	while (b){
		if (b&1LL) t=t*a;
		b>>=1LL;a=a*a;
	}
	return t;
}
inline long double calc(int i,int x){
	return dp[i]+fast_pow(abs(sum[x]-sum[i]+x-i-1-L),P);
}
inline int get(int a,int b){
	if (calc(a,n)<calc(b,n)) return n+1;
    int lb=b,rb=n,ans=-1;
    while (lb<=rb){
        int mid=(lb+rb)>>1;
        if (calc(b,mid)<=calc(a,mid)) ans=mid,rb=mid-1;
        else lb=mid+1;
    }
    return ans;
}
int sta[100202],T;
char s[102002][32];
signed main(){
	ios::sync_with_stdio(0);
	cin>>T;
	while (T--){
		cin>>n>>L>>P;
		for (int i=1;i<=n;i++){
			cin>>s[i];a[i]=strlen(s[i]);sum[i]=sum[i-1]+a[i];
			ans[i]=0;dp[i]=1e19;
		}
		hd=1,ta=1;
		for (int i=1;i<=n;i++){
			while (hd<ta&&get(dl[hd],dl[hd+1])<=i) hd++;
			ans[i]=dl[hd];dp[i]=calc(dl[hd],i);
			while (hd<ta&&get(dl[ta-1],dl[ta])>=get(dl[ta],i)) ta--;
			dl[++ta]=i;
		}
		if (dp[n]>1e18){
			puts("Too hard to arrange");
		}else{
			printf("%lld\n",(long long)dp[n]);
			int top=0;
			for (int tmp=n;tmp;tmp=ans[tmp]) sta[++top]=tmp;
			sta[++top]=0;
			for (int i=top;i>1;i--){
				for (int j=sta[i]+1;j<sta[i-1];j++){
					printf("%s ",s[j]);
				}
				printf("%s",s[sta[i-1]]); 
				printf("\n");
			}
		}
		puts("--------------------");
	}
    return 0;
}
```

---

## 作者：ww3113306 (赞：29)

第一次写这种二分来优化决策单调性的问题。。。。
调了好久，，，各种细节问题

显然有DP方程：

f[i]=min(f[j] + qpow(abs(sum[i] - sum[j] - L - 1)));

其中f[i]代表到了第i个句子的最小答案

qpow用于处理^p

sum为前缀和

（同时为了处理句子之间的空格问题，我们在统计前缀和的时候就默认在句子后面加一个空格，

然后在计算的时候，由于每一行只有最后一个不用加空格，直接减掉这个多加的空格即可获得正确长度）

首先我们可以打表发现是满足决策单调性的，

即决策是一段一段的

比如这种:

11122224446666

但下面这两种则不满足决策单调性:

11144442222666

11112424

同时这样的决策单调性是很特殊的，即一开始可能是这样的

11111111111111

加入2后：

11122222222222

加入4后：

11122224444444

也就是说就算最终取值是11122224446666，

在中间不断插入的过程中，也是一整段的

因此满足可二分性，

所以我们可以二分来找每个决策管理的区间（即可以转移到的区间）

但是有如下细节需要注意：

**1，区间可能被完整覆盖**

举个栗子，

如果当前状态是

111111111111114

现在加入一个5，那么下一个状态完全有可能是:

111111155555555

因此为了处理这样的情况，我们在二分之前先将会被完整覆盖的区间pop掉

即在插入5前弹出4，

同时这里又要**注意**，这个pop的处理必须在二分之前，

因为在二分过程中，我们需要一个决策来起到check的作用，而这个决策应该是当前插入的x最后应该被放入的那个区间的决策。

这样说可能不太清楚，还是举个栗子

比如当前状态：

111111112222223333

假设下一个状态是

111111112224444444

那么我们二分过程中作为判断依据的那决策就应该是2，

why？

因为观察到3号决策已经被完整的覆盖了，那么我们要对3之前的状态进行check的时候，由于3号不够优（也有可能是受到只能向后转移的限制），我们不能使用3号来check，

但是直接使用2号决策来check，然后在后面2222223333中二分也是不妥的，

因为在3333时，2号并不是最优，

所以为了应对这种情况，

我们先直接判断3333中的第一个3所对应的DP状态，如果插入的x更加优，

那么就代表这个区间是可以被完整的覆盖的，因此我们pop掉这个区间，

依次pop直到不满足条件为止，

这个时候我们就只需要在222222中二分了，于是用2号决策来check就很顺理成章了

**2，新插入的x可能什么区间都覆盖不了，**

也就是说新插入的x可能并不能更新状态，于是我们在二分前做一次特判，

判断当前区间的最后一个是否可以被覆盖,

如果不能，那么这个x无法更新状态，

所以直接continue


---------------以上为计算答案过程--------------


----------------以下为输出部分----------------

因为要输出方案，因此我们在转移时用last数组来记录i是从哪个决策转移而来

又因为不能打乱顺序，所以我们用Next数组来反向记录last数组

比如last中记录的可能是

0 <--- 2 <--- 4

即4由2转移而来，2由转移0而来

那么我们Next数组中记录的就是

0 ---> 2 ---> 4

所以我们从1开始输出，

每当我们到达Next[now]时就输出换行

即输出

1 2 

3 4

其实也就是相当于存下了每一行是由哪一句话结尾的，

然后依次输出

最后注意ans可能很大，而且要与1e18比较，所以long long 不够用。

要用 long double

下面是代码（中间有调试输出）

```cpp
#include<bits/stdc++.h>
using namespace std;
#define R register int
#define AC 100100
#define LL long long
#define LD long double
#define ACway 101000
#define inf 1000000000000000000LL
int t,L,p,n;
int s[AC],last[AC],l[AC],r[AC];//对应决策的管理区间
int q[AC],head,tail;//存下当前是哪个决策
int Next[AC];//对last进行相反操作,以便输出
LD f[AC];
LL sum[AC];
char ss[ACway][45];
//bool flag;
/*为什么我感觉就是一个普通DP+决策单调性 ---> 二分,,,,这个不比斜率优化容易理解么？*/
inline LD qpow(LD x)//error!!!x也要用LD！！！
{
	LD ans=1;
//	printf("x : %lld\n",(LL)(x + 0.5));
	int have=p;
	while(have)
	{
		if(have & 1) ans*=x;
		x*=x;
		have>>=1;
	//	if(ans > inf || x > inf) flag=true; 
	}
//	printf("ans : %lld\n",(LL)(ans + 0.5));
	return ans;
}


inline void pre()
{
	scanf("%d%d%d",&n,&L,&p);
	for(R i=1;i<=n;i++)
	{
		scanf("%s",ss[i]+1);
		s[i]=strlen(ss[i]+1) + 1;//加上后面的空格
		sum[i]=sum[i-1] + s[i];//求出前缀和
	}	
}

inline LD count(int x,int j)//j --- > x
{
	return f[j] + qpow(abs(sum[x] - sum[j] - L - 1));
}

void half(int x)//二分查找
{
	int now=q[tail],ll=l[now],rr=n,mid;//因为可能可以覆盖多个区间
	while(ll < rr)
	{
		mid=(ll + rr) >> 1;
		if(count(mid,x) < count(mid,now)) rr=mid;//如果更优就往左缩短
		else ll=mid + 1;//不然就向右寻找
	}
//	while(l[q[tail]] >= ll) --tail;//去掉整个都被包含的区间
	r[q[tail]]=ll-1;
	q[++tail]=x,l[x]=ll,r[x]=n;
	/*for(R i=head;i<=tail;i++)
	{
		for(R j=l[q[i]];j<=r[q[i]];j++)
			printf("%d",q[i]);
	}
	cout << endl;*/
}

inline void getans()
{
	head=1,tail=1;
	q[1]=0,l[0]=1,r[0]=n;
	for(R i=1;i<=n;i++)
	{
		while(r[q[head]] < i) ++head;//如果当前队首已经取不到了
		int now=q[head];
		//f[i]=f[now] + qpow(abs(sum[i] - sum[now] - L - 1));
		f[i]=count(i,now);//error ??? 用函数的话会爆了会自动转换为inf?
		//error!!!是后者转移到前者，所以是now ---> i,要填count(i,now),而不是count(now,i);
	//	printf("???%d\n",now);
		last[i]=now;
		if(count(n,q[tail]) < count(n,i)) continue;//如果最后一个都不够优，那就不二分了
		while(count(l[q[tail]],q[tail]) > count(l[q[tail]],i)) --tail;//如果当前可以覆盖前面的整个区间
		half(i);//注意上面的while要在调用half之前修改，这样取到的now才是正确的
	}
}

inline void write()
{
	//if(f[n] > inf || flag) puts("Too hard to arrange");
	if(f[n] > inf) puts("Too hard to arrange");
	else
	{
		printf("%lld\n",(LL)(f[n] + 0.5));//注意精度误差
		for(R i=n ; i ; i=last[i])	Next[last[i]]=i;
		int now=0;
		for(R i=1;i<=n;i++)
		{
			now=Next[now];//now先跳了吧
			int be=now;//先只到这行结尾，因为for还要加的
			for(R j=i; j < be ;j++) printf("%s ",ss[j] + 1);
			printf("%s\n",ss[be] + 1);
			i=be;//最后再赋i,因为for中还要用到当前i
		}
	}
	puts("--------------------");
}

inline void check()
{
	for(R i=1;i<=n;i++)
	{
		if(r[i] > l[i]) 
			for(R j=l[i];j<=r[i];j++) printf("%d",i);
	}
	printf("\n");
	for(R i=1;i<=n;i++) printf("!!!%lld\n",(LL)(f[i] + 0.5));
	cout << endl << endl;
}

inline void work()
{
	while(t--)
	{
		//flag=false;
		pre();
		getans();
	//	check();
		write();
	}
}

int main()
{
	freopen("in.in","r",stdin);
	scanf("%d",&t);
	work();
	fclose(stdin);
	return 0;
}
```



---

## 作者：AThousandSuns (赞：19)

**upd on 2023.9.2** 经评论区 @bingxin 提醒代码过不了样例，发现是添加注释时多删了如下一行导致的：

```cpp
if(calc(i,n)>calc(q[r],n)) continue;
```

这会导致状态 $i$ 在完全不优于目前队尾的情况下（可以发现 $i$ 无法成为任何一个位置的最优决策），进行错误的决策替换。

另外一种修改方法如评论区 @20200131wyz 所提（此处为未认真对待每一条评论深感愧疚），将二分边界改为 $n+1$，这也起到了判断 $i$ 究竟是否优于队尾的作用。修改后的版本采用这种方法。

另外再修改了一下排版以及部分概念。

---

什么是决策单调性优化 dp？

形如 $dp_i=\min/\max(dp_j+f(j,i))$ 这类的式子，令 $t_i$ 为使得 $dp_i$ 取到 $\min/\max$ 的 $j$，（其实 $t_i$ 就叫最优决策）若 $t_i$ 具有单调性，则这个 dp 式子就满足决策单调性。

具体如何判断？

令 $f_j(i)$ 为用 $j$ 转移时 $dp_i$ 的值（即 $dp_j+f(j,i)$）。

若对于任意 $j_1<j_2$，$f_{j_1}(i)$ 和 $f_{j_2}(i)$ 的函数图像至多有一个交点，在这个交点之前是 $f_{j_1}(i)$ 更小，在这个交点后是 $f_{j_2}(i)$ 更小，那么这个问题就满足决策单调性。

因为交点之前的 $i$ 的决策都是 $j_1$，交点后的决策都是 $j_2$。正好满足决策单调性。

（其实如果反之，在交点前都是 $j_2$ 更优而交点后都是 $j_1$ 更优，是一种不同的决策单调性问题，因与本题无关此处略去。）

---
决策单调性的优化方法大致有决策栈，决策队列和分治。这题就是用决策队列优化。

决策队列具体是这样做的：

队列维护决策三元组 $(p,l,r)$ 表示目前看来 $t_l,t_{l+1}\dots t_r$ 都是 $p$。一般来说一开始队列里只有三元组 $(0,1,n)$。

每次计算 $dp_i$ 时，就先把队列中无用的三元组弹出（$r<i$），并把新的队首的 $l$ 设为 $i$。此时 $i$ 在队首，所以 $i$ 的决策就是队首的 $p$。用 $dp_p$ 更新 $dp_i$。

接下来从队尾开始扫，如果用 $i$ 来更新队尾的 $l$ 比队尾的 $p$ 更新队尾的 $l$ 更优，说明队尾的决策应该比 $p$ 更大（因为我们从小到大枚举 $i$），那么根据决策单调性，整个三元组中的决策都比 $p$ 大。于是便可以弹出队尾。

到最后用 $i$ 来更新队尾的 $l$ 没有队尾的 $p$ 更新队尾的 $l$ 优。那么我们就要找出决策变为 $i$ 的分界点。由于决策具有单调性，我们可以二分。二分边界就是队尾三元组的 $l$ 和 $n$（为什么不是 $r$？因为可能这整个三元组都满足原来的决策，此时二分却会把最后一个元素拆走）。

二分出分界点 $x$ 后，队尾三元组的 $r$ 应改为 $x-1$（之后的决策都要变）。队尾再新加入一个三元组 $(i,x,n)$，表示 $x$ 到 $n$ 的决策都可以改为更优的 $i$。

至此算法结束。

因为每一个 $i$ 都会至多添加一个三元组，对一个三元组进行二分，又因为一个三元组至多被删除一次，所以复杂度为 $O(n\log n)$。

---
回到原题。

$dp_i$ 表示前 $i$ 句都已经放好时的最小值。

$s_i$ 表示前 $i$ 句话的总长度 $+i$（因为相邻句子要加空格）

$$dp_i=\min_{1\le j<i}(dp_j+|s_i-s_j-l-1|^p)$$

来解释一下这个式子。将第 $j+1$ 句到第 $i$ 句放一行，长度为 $s_i-s_j-1$ （行末不需要空格）根据题意，不协调度要新加 $|s_i-s_j-1-l|^p$。

现在看这一堆东西。发现正好满足决策单调性。（自己动手画个图吧，应该不难理解）

那么就可以上决策队列了。时间复杂度 $O(Tn\log n)$。具体见代码。

坑点：

- 虽然题目说了答案大于 $10^{18}$ 就输出 `Too hard too arrange`，但是 dp 途中就超了怎么办？只能用上 `long double` 了。
- `cmath` 里的 `pow` 太慢，自己手写快速幂。

上代码：（~~详细~~注释）
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef long double ld;
const int maxn=111111;
#define FOR(i,a,b) for(int i=(a);i<=(b);i++)
#define ROF(i,a,b) for(int i=(a);i>=(b);i--)
#define MEM(x,v) memset(x,v,sizeof(x))
inline int read(){
    char ch=getchar();int x=0,f=0;
    while(ch<'0' || ch>'9') f|=ch=='-',ch=getchar();
    while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();
    return f?-x:x;
}
int t,n,l,p,trans[maxn],ans[maxn],al,q[maxn],h,r,lft[maxn],rig[maxn];
ld pre[maxn],dp[maxn];
char s[maxn][33];
inline ld qpow(ld a,int b){	//手写快速幂
    ld ans=1;
    for(;b;b>>=1,a*=a) if(b&1) ans*=a;
    return ans;
}
inline ld calc(int x,int y){	//从x转移到y
    return dp[x]+qpow(abs(pre[y]-pre[x]-l-1),p);
}
int main(){
    t=read();
    while(t--){
        MEM(dp,0);MEM(s,0);MEM(trans,0);MEM(lft,0);MEM(rig,0);MEM(pre,0);
        n=read();l=read();p=read();
        FOR(i,1,n) scanf("%s",s[i]+1),pre[i]=pre[i-1]+strlen(s[i]+1)+1;	//pre就是长度的前缀和
        q[h=r=1]=0;lft[0]=1;rig[0]=n;
        //实际代码实现时，不需要真的把一个三元struct放进队列，只要把决策编号放进去
        //lft[i]和rig[i]表示以i为决策的区间，表示成上文中的三元组就是(i,lft[i],rig[i])
        FOR(i,1,n){
            while(h<=r && rig[q[h]]<i) h++;	//弹出无用三元组
            dp[i]=calc(q[h],i);	//用队首决策转移
            trans[i]=q[h];
            while(h<=r && calc(i,lft[q[r]])<=calc(q[r],lft[q[r]])) r--;
            //i比目前队尾决策优，队尾需要替换
            int lll=lft[q[r]],rrr=n+1;	//二分
            while(lll<rrr){
                int mid=(lll+rrr)>>1;
                if(calc(i,mid)<=calc(q[r],mid)) rrr=mid;	//i更优，说不定可以往前继续找
                else lll=mid+1;	//i不优，分界点一定在后面
            }
            if(lll>n) continue;	//i完全没有用，不管
            rig[q[r]]=lll-1;	//原来的决策只能管到rig-1，后面的归i管
            q[++r]=i;
            lft[i]=lll;rig[i]=n;	//新的三元组
        }
        if(dp[n]>1e18) puts("Too hard to arrange");
        else{
            printf("%lld\n",ll(dp[n]));
            al=0;
            for(int i=n;i;i=trans[i]) ans[++al]=i;	//沿着转移路线输出
            int cur=al,tmp=0;
            FOR(i,1,n){
                if(tmp) putchar(' ');	//注意要不要加空格
                printf("%s",s[i]+1);
                if(i==ans[cur]) putchar('\n'),cur--,tmp=0;
                else tmp++;
            }
        }
        puts("--------------------");
    }
}
```

---

## 作者：Infiltrator (赞：14)

dp真是好玩呢，有好多有趣且优美的优化。   
# 四边形不等式优化  
首先，什么是四边形不等式？  
一句话来概括，就是：**相交小于包含**   
一维二维的满足四边形不等式的dp式子都具有决策单调性，都可以被优化
~~二维的太复杂了,我只写一维的好了~~  
令$w(x,y)$是定义在整数集合上的二元函数，对于$a<=b<=c<=d$,有$w(a,c)+w(b,d)<=w(a,d)+w(b,c)$，则称此函数满足四边形不等式。    
但是在dp的时候，这种式子不常出现，对于两个确定的i和j，如何确定该函数满足四边形不等式呢？  
有如下的定理:对于$a<b$，有$w(a,b+1)+w(a+1,b)>=w(a+1,b+1)+w(a,b)$成立，则此函数满足四边形不等式。  
证明如下：
> 对于$a<c$,有$w(a,c+1)+w(a+1,c)>=w(a,c)+w(a+1,c+1)$   
> 对于$a+1<c$，有$w(a+1,c+1)+w(a+2,c)>=w(a+1,c)+w(a+2,c+1)$  
> 两式相加，得到$w(a,c+1)+w(a+2,c)>=w(a,c)+w(a+2,c+1)$  
> 以此类推，对任意的$a<=b<=c$，有$w(a,c+1)+w(b,c)>=w(a,c)+w(b,c+1)$  
> 同理，对于任意的$a<=b<=c<=d$,有$w(a,d)+w(b,c)>=w(a,c)+w(b,d)$  
>$Q.E.D.$  

那么，四边形不等式如何优化dp呢？对于一维的dp，我们可以将形如$dp[i]=min_{i=0}^j(dp[j]+w(i,j))$的式子优化，因为它具有决策单调性，于是我们用一个单调队列来维护每个i的最优更新的j，就可以在$O(nlogn)$的复杂度内求解问题。  

我们来看一下为什么具有决策单调性  
>令$p[i]$表示对于点$i$的最优决策点  
>那么任选$0<=j<i$，$j$更新$i$一定比$p[i]$更新$i$更劣  
>所以得到式子1:$dp[p[i]]+w(p[i],i)<=dp[j]+w(j,i)$  
>接着我们任选$i+1<=q<+n$，因为函数$w$满足四边形不等式，所以我们得到  
>式子2:$w(j,q)+w(p[i],i)>=w(p[i],q)+w(j,i)$  
>对式子2移项，得:$w(p[i],q)-w(p[i],i)<=w(j,q)-w(j,i)$  
>与式子1相加，得:$dp[p[i]]+w(p[i],q)<=dp[j]+w(j,q)$  
>也就是说，以$p[i]$为决策点来转移$q$比以$j$为决策点转移$q$更优  
>所以对于$p[i]$之前的所有决策点都不如$p[i]$来转移$i$之后的点更优，即决策单调性  
>$Q.E.D$

那么我们怎么来维护这些决策点呢？用一个单调队列维护即可,单调队列里面用结构体存储决策点  
存储决策点的位置,决策点可以优化的点的区间的左端点，右端点。  
每次加入一个新的决策点的时候若新加的决策点比一整个决策点可以优化的区间都优秀，就直接将这个决策点出队  
如果比这个决策点可以优化的区间都劣，就将当前的决策点扔到单调队列的队尾  
否则在这个决策点的可优化区间里二分一个点，使得这个点之前都是这个决策点优化更优，这个点之后都是新加进去的决策点更优，改变队尾结构体里记录的值，将当前的决策点入队即可。  

## NOI2009诗人小G
>题目描述
>小G是一个出色的诗人，经常作诗自娱自乐。但是，他一直被一件事情所困扰，那就是诗的排版问题。

>一首诗包含了若干个句子，对于一些连续的短句，可以将它们用空格隔开并放在一行中，注意一行中可以放的句子数目是没有限制的。小G给每首诗定义了一个行标准长度（行的长度为一行中符号的总个数），他希望排版后每行的长度都和行标准长度相差不远。显然排版时，不应改变原有的句子顺序，并且小G不允许把一个句子分在两行或者更多的行内。在满足上面两个条件的情况下，小G对于排版中的每行定义了一个不协调度, 为这行的实际长度与行标准长度差值绝对值的P次方，而一个排版的不协调度为所有行不协调度的总和。

>小G最近又作了几首诗，现在请你对这首诗进行排版，使得排版后的诗尽量协调（即不协调度尽量小），并把排版的结果告诉他。

>输入格式  
输入文件中的第一行为一个整数T，表示诗的数量。

>接下来为T首诗，这里一首诗即为一组测试数据。每组测试数据中的第一行为三个由空格分隔的正整数N，L，P，其中：N表示这首诗句子的数目，L表示这首诗的行标准长度，P的含义见问题描述。

>从第二行开始，每行为一个句子，句子由英文字母、数字、标点符号等符号组成（ASCII码33～127，但不包含'-'）。

>输出格式  
于每组测试数据，若最小的不协调度不超过10^18，则第一行为一个数，表示不协调度。接下来若干行，表示你排版之后的诗。注意：在同一行的相邻两个句子之间需要用一个空格分开。

>如果有多个可行解，它们的不协调度都是最小值，则输出任意一个解均可。若最小的不协调度超过10^18，则输出“Too hard to arrange”（不含引号）。每组测试数据结束后输出“--------------------”（不含引号），共20个“-”，“-”的ASCII码为45，请勿输出多余的空行或者空格。

显然令dp[i]表示前i句诗的最小不协调值，sum[i]为前i句诗的前缀和长度  
有状态转移方程:$dp[i]=min_{i=0}^jabs(sum[i]-sum[j]+i-j-1-L)^p$  
我们如果证明这个式子可以用四边形不等式优化，就可以O(nlogn)求出答案  
设$w(i,j)=abs(sum[i]-sum[j]+i-j-1-L)^p$  
那么如果$w(a,b+1)+w(a+1,b)>=w(a+1,b+1)+w(a,b)$，就可以说明它满足四边形不等式  
那么只需证明$w(a+1,b)-w(a+1,b+1)>=w(a,b)-w(a,b+1)$即可  
令$b1=sum[b]+b-sum[a]-a-l-1,b2=sum[b]+b-sum[a]-a-1-l-1$
只需证明$abs(b2)^p-abs(b2+(a[i+1]+1))^p>=abs(b1)^p-abs(b1+(a[i+1]+1))^p$即可  
易得，$b2>b1$,那么只需证明对于任意的常数c,函数$y=abs(x)^p-abs(x+c)^p$单调递减  
~~我太菜了不会证明emmmm，引用算法竞赛进阶指南~~
>当p为奇数，x为负数  
>原函数为y=-x^p-(x+c)^p，求导，发现y'<=0，所以单调递减  
>其他情况大力分类讨论  
## CODE  
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
#define ll long long
const double eps=1e-8;
long double ksm(long double a,ll b)
{
	long double tmp=1;
	while(b)
	{
		if(b&1)tmp=tmp*a;
		a=a*a;
		b>>=1;
	}
	return tmp;
}
int n,head,tail,ans[200050];
string stt[200050];
ll sum[200050],p,l;
long double f[200050];
struct node
{
	int j,l,r;
}q[5000050];
long double abss(ll x)
{
	return x<0?-x:x;
}
long double zhi(int j,int i)
{
	return ksm(abss((sum[i]-sum[j])+(i-j-1)-l),p);
}
void print(int n)
{
	if(!n)return;
	int t=ans[n];print(t);
	for(int i=t+1;i<=n;i++)
	{
		cout<<stt[i];
		if(i!=n)putchar(' ');
	}
	printf("\n");
}
int query(int l,int r,int i,int j)
{
	int mid;++r;
	while(l<r)
	{
		mid=(l+r)>>1;
		if(f[j]+zhi(j,mid)>f[i]+zhi(i,mid))l=mid+1;
		else r=mid;
	} 
	return l;
}
int main()
{
	int kkk;
	scanf("%d",&kkk);
	while(kkk--)
	{
		memset(ans,0,sizeof(ans));
		head=1;tail=0;
		scanf("%d%d%d",&n,&l,&p);
		for(int i=1;i<=n;i++)cin>>stt[i],sum[i]=sum[i-1]+stt[i].size();
		f[0]=0;
		for(int i=1;i<=n;i++)
		{
			while(head<=tail && f[i-1]+zhi(i-1,q[tail].l)<=f[q[tail].j]+zhi(q[tail].j,q[tail].l))tail--;
			if(head<=tail)
			{
				int pos=query(q[tail].l,q[tail].r,q[tail].j,i-1);
				if(pos<=n)q[tail].r=pos-1,q[++tail]=(node){i-1,pos,n};
			}
			else q[++tail]=(node){i-1,i,n};
			while(head<=tail && q[head].r<i)++head;
			if(head<=tail)q[head].l=i;
			int pos=q[head].j;
			f[i]=f[pos]+zhi(pos,i),ans[i]=pos;
		}
		if(f[n]-1e18>eps)printf("Too hard to arrange\n");
		else 
		{
			printf("%lld\n",(ll)(f[n]));
			print(n);
		}
		printf("--------------------");
		if(kkk)printf("\n");
	}
	return 0;
}
```

---

## 作者：chaojidouding (赞：11)

没拿到一血很不开心，那就拿个题解的一血吧


首先这个题朴素的dp不难，dp[i] 表示 前i个句子组成的文章组成的不协调值的最小值，w[i]是句子长度的前缀和(每个句子加上一个空格)，转移是：

dp[i] = dp[j]+abs(w[j]-w[i-1]-l-1)^n;

考虑如何优化

可以发现，这个转移具有决策单调性(打表或者瞪眼法)

什么是决策单调性（大家可以百度：浅析1D1D动态规划的优化）

一开始对于1-n状态最优决策是

000000000000000000000000

加入1状态以后，最优决策可能就变成了

000001111111111111111111

然后加入2

000001111111112222222222

所以我们可以维护一个单调队列，每个点记录的是该状态（0,1,2）是最优决策的区间，每次加数的时候，先判断与该状态的左端点哪个更优，如果该状态更有，就pop掉（把队列里的该点全部抛弃），否则在该点对应的区间里二分查找分界点，把位于分界点右边的换成新的决策。

本题要输出方案，用一个g[i]记录转移到该状态的决策

这样就ok了

注意：

1、本题数据要小于1e18，我们应该用long double我们不能if f[i]>1e18 then f[i]=1e18,原因是(1)中间的可能会超过1e18，而结果不一定会(2)比较决策哪个优时，同时都是1e18，无法比较哪个更优，其实如果都用long double是能比较出来的

2、输出方案时每一长句话之后不要加空格，否则会错。

附上丑陋的代码

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<vector>
#include<algorithm>
#include<cmath>
using namespace std;
long double f[101010];
int g[101010],nxt[101010],q[101010],w[101010];
int p,l;
char a[101010][35];
struct Node
{
    int l,r;
}pp[101010];
long double ksm(int w,int x)
{
    long double ans=1;
    int i;
    for(i=1;i<=x;i++)
        ans*=w;
    return ans;
}
long double jisuan(int x,int i)
{
    long double ans;
    ans=f[x]+ksm(abs(w[i]-w[x]-1-l),p);
    return ans;
}
int main()
{
    int T,h,t,i,tmp,len,n,right,left,mid;
    scanf("%d",&T);
    while(T--)
    {
        memset(f,0,sizeof(f));
        memset(g,0,sizeof(g));
        memset(nxt,0,sizeof(nxt));
        memset(a,0,sizeof(a));
        memset(w,0,sizeof(w));
        memset(q,0,sizeof(q));
        memset(pp,0,sizeof(pp));
        scanf("%d%d%d",&n,&l,&p);
        w[0]=0;
        for(i=1;i<=n;i++)
        {
            scanf("%s",a[i]+1);
            len=strlen(a[i]+1);
            w[i]=w[i-1]+len+1;
        }
        h=0,t=1,q[h]=0;
        pp[0].l=1,pp[0].r=n;
        for(i=1;i<=n;i++)
        {
            while(h<t-1&&i>pp[q[h]].r)//队首比较 
                h++;
            f[i]=f[q[h]]+ksm(abs(w[i]-w[q[h]]-1-l),p);
            pp[q[h]].l++;
            g[i]=q[h];
            while(h<t-1&&jisuan(q[t-1],pp[q[t-1]].l)>jisuan(i,pp[q[t-1]].l))//队尾比较 
            {
                t--;
                pp[q[t]].l=0;
                pp[q[t]].r=0;
                q[t]=0;
            }
            left=pp[q[t-1]].l,right=pp[q[t-1]].r;//二分查找 
            while(left<=right)
            {
                mid=(left+right)/2;
                if(jisuan(i,mid)<=jisuan(q[t-1],mid))
                    right=mid-1;
                else
                    left=mid+1;
            }
            if(left<=n)
            {
                pp[q[t-1]].r=left-1;
                q[t++]=i;
                pp[i].l=left;
                pp[i].r=n;
            }
        }
        if(f[n]>1000000000000000000)
            printf("Too hard to arrange\n");
        else
        {
            printf("%lld\n",(long long)f[n]);
			tmp=n;
			while(tmp!=0)
			{
			  nxt[g[tmp]]=tmp;
			  tmp=g[tmp];
			}
			while(tmp!=n)
			{
			  
			  	for(i=tmp+1;i<=nxt[tmp];i++)
			  	{
			      	printf("%s",a[i]+1);
			      	if(i!=nxt[tmp])
			      		printf(" ");
			  	}
			  	printf("\n");
			  	tmp=nxt[tmp];
			}
        }
        printf("--------------------\n");
    }
    return 0;
}

```

---

## 作者：洛水·锦依卫 (赞：7)

[In My blog](https://www.cnblogs.com/luoshuitianyi/p/10386710.html)
# Mentality

我们发现数据范围不小不大，正好是 $nlog$ 到 $nlog^2$ 级别的。

先记录一个前缀和 $q$ ，$q[i]$ 表示句子 $1-i$ 的长度总和，注意加上空格的长度。

首先观察到一个很显然的一维 $dp$ ，$f[i]$ 代表选到了第 $i$ 个句子并且在此换行的最小不协调度，设 $w(i,j)=abs(q[i]-q[j]-L-1)^P$ ，那么我们可以得到这样一个 $n^2$ 的 $dp$ ：
$$
f[i]=Min_{j<i}(f[j]+w(i,j))
$$
这确确实实是很简单的，但是很显然，复杂度过不了关。

那么考虑如何优化：

众所周知，$dp$ 分为三个部分，枚举状态×枚举决策点×状态转移=时间复杂度。

我们考虑一一下手。

对于枚举状态的部分，由于必须顺着推过去，所以 $O(n)$ 还是跑不了。

对于枚举决策点的部分，我们发现这个式子异常眼熟，一看就符合决策单调性的应用式。

对于状态转移的部分，$O(1)$ 不能再优化了。

那么我们考虑如何利用决策单调性来优化这道题目。首先，对于一维 $dp$ ，设 $g[i]$ 为状态 $i$ 的最优决策点，它的决策单调性的显著特征自然是：$g[i-1]\le g[i]$  ，那么我们考虑利用这种决策单调性来做题。

我们利用队列记录下每个决策点 $que$ ，并记录其对应下一个决策点左区间 $L$ 。之所以这样做，是因为对于每个决策点，它对于每个区间的优劣性是不同的，所以它必定只会对一个区间最优。

但是这题之所以满足决策单调性，就是因为对于决策点而言，决策点位置的递增也意味着对应区间的递增，也就是说对于最右边的一段区间某个位置至位置 $n$ ，最优决策点必定是最新的决策点。

对于这一点，我们可以有如下证明：

- 首先我们回到问题，我们已经选出了一些句子分好了行，在当前行我们还未换行。
- 不考虑下一行，那么如果还有句子加上当前的句子的长度小于标准长度，则一定要选，若长度之和大于标准长度，则只需要考虑选与不选。
- 所以，对于当前行的决策，我们只会浮动在两个左右的决策点之间，因为 $w$ 函数的指数性递增决定了我们选择的单调性。
- 所以对于越往后的区间，它的最优决策点就越往后，因为 $w$ 函数过大会造成 $dp$ 的变劣。

那么我们的 $dp$ 就分为了如下几个过程，设当前 $dp[i]$ 正被更新：

- 1、找到对应 $i$ 的决策点区间，如果队首不符合就 $head++$ ，直到当前队首决策点的对应区间包括 $i$ 。
- 2、$f[i]=f[que[head]]+work(que[head],i)$ ，通过队首的决策点来转移。
- 3、通过二分寻找出最左边的，以队尾决策点为决策点不如以 $i$ 为决策点更优的位置，由于单调变优性，从这个位置往右的 $dp$ 都满足以 $i$ 为决策点是目前最优的。如果这个最左边的位置要小于队尾决策点对应的左区间，那么说明对于这个决策点对应的所有转移都不如 $i$ 更优，所以弹出队尾，我们继续判断新的队尾与 $i$ 的决策。
- 4、当队尾的弹出停止的时候，我们二分出的位置往右的 $dp$ 都以 $i$ 决策最优，那么把当前队尾的决策区间右端点改为这个位置，$q[++tail]=i$ 将 $i$ 入队，且 $i$ 的对应区间右端点为 $n$ 。

不过需要注意，我们应用 $long\ double$ 存下 $dp$ 值，因为如果 $dp$ 值大于 $1e18$ 就不能用 $long\ long$ 存了，但是用 $long\ double$ 还是可以比较大小。科学计数法好。

完成！

# Code

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
int head,tail,T,n,len,P,q[100001],g[100001],L[100001],que[100001];
char s[100002][31];
long double f[100001];
long double ksm(long double x)
{
	int base=P;
	long double a=1;
	while(base)
	{
		if(base&1)
			a=a*x;
		x=x*x;
		base>>=1;
	}
	return a;
}//快速幂
long double work(int i,int j){return f[j]+ksm((long double)abs(q[i]-q[j]-1-len));}//计算以 j 为决策点 i 将得到的状态转移值
int find(int x,int y)
{
	int l=x,r=n+1;
	while(l<r)
	{
		int mid=(l+r)>>1;
		work(mid,x)>=work(mid,y)?r=mid:l=mid+1;
	}
	return l;
}//查找 i 的最左最优决策位置
int main()
{
	cin>>T;
	while(T--)
	{
		cin>>n>>len>>P;
		for(int i=1;i<=n;i++)
		{
			q[i]=0;
			scanf("%s",s[i]);
			q[i]=strlen(s[i])+q[i-1]+1;//单词长度前缀和
		}
		que[head=tail=1]=0;//初始化决策点队列
		for(int i=1;i<=n;i++)
		{
			while(head<tail&&L[head]<=i)//先找到对应区间包含 i 的位置，L 记录的是下一个决策区间的左端点
				head++;
			g[i]=que[head];
			f[i]=work(i,g[i]);//更新 dp 值
			while(head<tail&&L[tail-1]>=find(que[tail],i))//进行队尾判断
				tail--;
			L[tail]=find(que[tail],i);//更新队尾区间
			que[++tail]=i;//决策点入队
		}
		if(f[n]>1e18)
			puts("Too hard to arrange");
		else
		{
			printf("%lld\n",(long long)f[n]);
			int top=0;
			for(int i=n;i;i=g[i])
				q[++top]=g[i];
			q[0]=n;
			while(top--)
			{
				int L=q[top+1]+1,R=q[top];
				for(int i=L;i<R;i++)
					printf("%s ",s[i]);
				puts(s[R]);//行末不能有空格
			}
		}
		puts("--------------------");
	}
	cout<<endl;
}
```

---

## 作者：ModestCoder_ (赞：6)

令$sum_i$表示第一个短语到第$i$个短语组成的句子长度

$sum_i=i-1+\sum_{j=1}^{i}strlen(s_j)$

轻松得到一个暴力$dp$:$dp_i=min(dp_j+(sum_i-sum_j-L-1)^P)$

令$w(i,j)=(sum_i-sum_j-L-1)^P$

则$dp_i=min(dp_j+w(i,j))$，发现存在决策单调性

然后就是决策单调性的做法

 - 单调队列维护，记录决策、临界值，这边临界值的意义是第一个下一个决策比这一个决策优的整点
 - 队首决策是相对于当前状态最优的决策，更新
 - 二分找到当前决策和前面的临界值，更新单调队列

Code：

```cpp
#include <bits/stdc++.h>
#define maxn 100010
using namespace std;
char s[maxn][31];
long double dp[maxn];
int h, t, n, L, P, q[maxn], pre[maxn], k[maxn], sum[maxn];

inline int read(){
	int s = 0, w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48) ;
	return s * w;
} 

long double ksm(long double n, int k){
	if (!k) return 1.0;
	long double sum = ksm(n, k >> 1);
	sum *= sum;
	if (k & 1) sum *= n;
	return sum;
}

long double calc(int i, int j){ return dp[j] + ksm((long double)abs(sum[i] - sum[j] - L - 1), P); }

int find(int j, int i){
	int l = j, r = n + 1, sum = 0;
	while (l <= r){
		int mid = (l + r) >> 1;
		if (calc(mid, j) >= calc(mid, i)) r = mid - 1; else l = mid + 1;
	}
	return l;
}

int main(){
	int M = read();
	while (M--){
		n = read(), L = read(), P = read();
		for (int i = 1; i <= n; ++i) scanf("%s", s[i]), sum[i] = strlen(s[i]) + sum[i - 1] + 1;
		q[h = t = 1] = 0;
		for (int i = 1; i <= n; ++i){
			while (h < t && k[h] <= i) ++h;
			pre[i] = q[h], dp[i] = calc(i, q[h]);
			while (h < t && k[t - 1] >= find(q[t], i)) --t;
			k[t] = find(q[t], i);
			q[++t] = i;
		}
		if (dp[n] > 1e18) puts("Too hard to arrange"); else{
			printf("%lld\n", (long long)dp[n]);
			int cnt = 0;
			for (int i = n; i; i = pre[i]) q[++cnt] = pre[i]; q[0] = n;
			while (cnt--){
				for (int i = q[cnt + 1] + 1; i < q[cnt]; ++i) printf("%s ", s[i]);
				printf("%s\n", s[q[cnt]]);
			}
		}
		puts("--------------------");
	}
	return 0;
}
```


---

## 作者：Utsuji_risshū (赞：5)

n个数划分若干段，给定$L$,$p$，每段代价为$|sum_i-sum_j-1-L|^p$，求总代价最小。

正常的dp决策单调性优化题目。$f[i]$表示最小代价。然后有个正常的dp方程。

$f[i]=min \{ f[j]+|sum_i-sum_j-1-L|^p \} $

然后观察发现带高次项，不好斜率优化或单调队列，考虑有没有决策单调性。本来是可以打表证明的，然后拍一下。~~题解没人证单调性，于是我来瞎证一波，有错别怪我。~~

证明：

已知$f[j]+|sum_i-sum_j-1-L|^p < f[j']+|sum_i-sum_{j'}-1-L|^p$

要证$f[j]+|sum_i-sum_j-L|^p < f[j']+|sum_i-sum_{j'}-L|^p$     $(j'<j)$(就是$i$加了$1$)

即证 $|sum_i-sum_{j'}-1-L|^p+|sum_i-sum_j-L|^p < |sum_i-sum_j-1-L|^p+|sum_i-sum_{j'}-L|^p$

即$|sum_i-sum_{j'}-1-L|^p-|sum_i-sum_{j'}-L|^p < |sum_i-sum_j-1-L|^p-|sum_i-sum_j-L|^p$

然后把其看成关于j的函数，或者就把$S_i-S_j-L$看成$x$简便一些，$j$增大，$S_j$增大，$x$总的减小。下面看单调性。可能证的**不太严谨**，有问题还望指教。

$f(x)=|x-1|^p-|x|^p$  (p为大于2正整数)

①$p$为偶数,则$f(x)=(x-1)^p-x^p$

$f'(x)=p(x-1)^{p-1}-px^{p-1}$

$x>=1$时显然小于$0$，此段单调减

$0<=x<1$时$p(x-1)^{p-1}<px^{p-1}$即$p(x-1)^{p-1}-px^{p-1}<0$，此段单调减

$x<0$时也有上述关系。

又因为$x∈R$内函数值是连续（就是几个转折点值在左右边两个范围内算出来的f都一样的）的，所以整个是一直单调减的。

②$p$为奇数,$p-1$为偶,则

$x>=1$时$f'(x)=p(x-1)^{p-1}-px^{p-1}<0$单调减

$0<=x<1$时$f(x)=(1-x)^p-x^p$,则$f'(x)=-p(x-1)^{p-1}-px^{p-1}<0$因为偶数次方必定大于0嘛

$x<0$时$f(x)=(1-x)^p+x^p$ ，$f'(x)=-p(x-1)^{p-1}+px^{p-1}$

$∵x-1<x<0$

$∴(x-1)^{p-1}>x^{p-1}$

$∴f'(x)=-p(x-1)^{p-1}+px^{p-1}<0$

$综上，p为奇或偶都有导数小于0，f随x单调减，j增大，S_j增大,x减小，f必然增大，则原不等式得证。$

$所以满足决策单调性。$

$证毕。$

好像有漏洞？算了不管了。希望各位能指出或完善证明，因为我其实根本就不会求导。**~~而且我的数学差的要死，全班倒数。~~**

然后随便套套决策单调性模板就行啦，这个可以去看以及膜上下楼的比我强了几百万倍的julao。

注意一下要用long double范围大，不然long long会爆。注意不用刻意考虑和判断会不会爆，正常用long double虽然牺牲精度但毕竟还是总体大于$10^{18}$的。
```cpp
#include<bits/stdc++.h>
#define dbg(x) cerr<<#x<<"="<<x<<endl
using namespace std;
typedef long double ll;
typedef double db;
template<typename T>inline char MIN(T&A,T B){return A>B?A=B,1:0;}
template<typename T>inline char MAX(T&A,T B){return A<B?A=B,1:0;}
template<typename T>inline T _min(T A,T B){return A<B?A:B;}
template<typename T>inline T _max(T A,T B){return A>B?A:B;}
template<typename T>inline T read(T&x){
    x=0;int f=0;char c;while(!isdigit(c=getchar()))if(c=='-')f=1;
    while(isdigit(c))x=x*10+(c&15),c=getchar();return f?x=-x:x;
}
inline ll fpow(ll x,int p){ll ret=1;for(;p;p>>=1,x=x*x)if(p&1)ret=ret*x;return ret;}
inline int Abs(int x){return x>0?x:-x;}
const int N=100000+7;ll INF=1e18;
struct thxORZ{
    int l,r,pos;
    thxORZ(int l0=0,int r0=0,int pos0=0):l(l0),r(r0),pos(pos0){}
}q[N];
char s[N][32];
ll f[N],lim;
int sum[N],pre[N];
int T,L,p,n,l,r;
inline ll calc(int j,int i){return f[j]+fpow(Abs(sum[i]-sum[j]-1-L),p);}
inline int find_pos(int L,int R,int j,int i){
    int mid;
    while(L<R){
        mid=L+R>>1;
        if(calc(j,mid)>=calc(i,mid))R=mid;
        else L=mid+1;
    }
    return R;
}
inline void dp(){
    q[l=r=1]=thxORZ(1,n,0);
    for(register int i=1;i<=n;++i){
        f[i]=calc(q[l].pos,i);pre[i]=q[l].pos;//dbg(i),dbg(f[i]),dbg(sum[i]);
        if(i==q[l].r)++l;else ++q[l].l;
        if(f[i]>INF)continue;//小优化：当前状态如果已经无效就不要更新决策表了。
        while(l<=r&&calc(q[r].pos,q[r].l)>=calc(i,q[r].l))--r;
        if(r<l)q[r=l]=thxORZ(i+1,n,i);
        else{
            int k;if(calc(q[r].pos,q[r].r)<=calc(i,q[r].r))k=q[r].r+1;
            else k=find_pos(q[r].l,q[r].r,q[r].pos,i);//dbg(i),dbg(k);
            if(k<=n)q[r].r=k-1,q[++r]=thxORZ(k,n,i);
        }
    }
}
inline void print(int x,int y){
    if(x)print(pre[x],x);
    for(register int i=x+1;i<=y;++i)printf("%s",s[i]),i==y?putchar('\n'):putchar(' ');
}

int main(){//freopen("test.in","r",stdin);freopen("tmp.out","w",stdout);
    read(T);while(T--){
    	read(n),read(L),read(p);lim=(ll)ceil(pow(1e18,1.0/(db)p));
    	for(register int i=1;i<=n;++i)scanf("%s",s[i]),sum[i]=sum[i-1]+strlen(s[i])+1;
    	dp();if(f[n]>INF)printf("Too hard to arrange\n");
    	else printf("%lld\n",(long long)f[n]),print(pre[n],n);
        printf("--------------------\n");
    }
    return 0;
}
```

---

## 作者：mulberror (赞：4)

$$\href{http://blog.chhokmah.cn/index.php/archives/74/}{\Large\texttt{My blog}}$$

---
## 题目概括
将给定数列$A$划分成若干段，再给定$X$和$P$。

我们定义每一段$(i,j)$的权值为

$$(\sum_{k=i}^j A_k+j-i-X)^P$$

一个数列的权值为其每一段权值的和。

寻找到一个方案使得数列的权值最小。

数据范围：$n\leq 10^5, X\leq 3\times 10^6,P\leq 10$


## 思路要点
暴力 $DP$，显然是 $O(n^2)$ 的，所以考虑用单调性优化转移。

根据高中必修五的知识，可以发现每一段的权值，满足**外大于里，包含大于交叉**。

所以根据四边形不等式优化可知，这些决策点是单调不减的，而且所有的决策点都满足在其最优决策区间内，越往后越劣。

考虑用单调队列来维护决策点，和他们的最优决策区间$[l,r]$。

遍历到$i$时，在队头弹出$l<i$的元素，再更新答案。

然后弹出队尾元素在$l$比$i$劣的元素，直至$i$变劣。

找到第一个和$i$有重复区间的队尾元素，然后在当前区间内二分出两个元素的优劣边界。

**注意！如果$i$元素比队列中所有元素都劣，那么就不需要加入队列，否则会出现奇怪问题。（这个问题令笔者不解）**

## 代码
```cpp
/*
 * @Author: chhokmah 
 * @Date: 2020-03-22 16:20:53 
 * @Last Modified by:   chhokmah 
 * @Last Modified time: 2020-03-22 16:20:53 
 */
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int N = 1e5 + 5;

struct Node {
  int i, l, r;

  Node() { 
    i = l = r = 0;
  }

  Node(int x, int y, int z) {
    i = x, l = y, r = z;
  }
} q[N];

char s[N][35];
int n, L, P;
int a[N], g[N];
long double sum[N], f[N];

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);
  int t;
  cin >> t;
  auto pw = [](long double x, int y) {
    long double res = 1;
    while (y) {
      if (y & 1) {
        res = res * x;
      }
      y >>= 1, x *= x;
    }
    return res;
  };
  while (t--) {
    cin >> n >> L >> P;
    for (int i = 1; i <= n; i++) {
      cin >> s[i];
      a[i] = strlen(s[i]);
    }
    for (int i = 1; i <= n; i++) {
      sum[i] = sum[i - 1] + a[i];
    }
    auto calc = [&](int l, int r) {
      return f[l] + pw(fabs(sum[r] - sum[l] + r - l - 1 - L), P);
    };
    int head = 1, tail = 1;
    q[tail] = Node(0, 1, n);
    for (int i = 1; i <= n; i++) {
      while (head < tail && q[head].r < i) {
        head++;
      }
      f[i] = calc(g[i] = q[head].i, i);
      while (head <= tail && calc(q[tail].i, q[tail].l) >= calc(i, q[tail].l)) {
        tail--;
      }
      if (head > tail) {
        q[++tail] = Node(i, i + 1, n);
      } else {
        int lw = q[tail].l, hg = q[tail].r, res = q[tail].r + 1;
        while (lw <= hg) {
          int mid = (lw + hg) >> 1;
          if (calc(q[tail].i, mid) < calc(i, mid)) {
            lw = mid + 1;
          } else {
            res = mid;
            hg = mid - 1;
          }
        }
        q[tail].r = res - 1;
        if (res <= n) {
          q[++tail] = Node(i, res, n);
        }
      }
    }
    if (f[n] > 1e18) {
      cout << "Too hard to arrange" << '\n';
    } else {
      cout << (long long)f[n] << '\n';
      vector<int> pt; 
      pt.clear();
      int it = n;
      while (it) {
        pt.emplace_back(it);
        it = g[it];
      }
      pt.emplace_back(0);
      reverse(pt.begin(), pt.end());
      for (int i = 0; i < (int)pt.size() - 1; i++) {
        for (int j = pt[i] + 1; j <= pt[i + 1]; j++) {
          cout << s[j] << " \n"[j == pt[i + 1]];
        }
      }
    }
    cout << "--------------------";
    if (t != 0) {
      cout << '\n';
    }
  }
  return 0; 
}
```

## 后言
- 考虑了 $DP$，如果时间复杂度比较劣，那么考虑决策点是否有**单调性或者其他特殊性质**，可以通过打表或者其他方法得出规律。就比如说 $JOISC \;2020 \;Day1$ 中 $DP$ 的决策点就有明显的连续性。  

- 四边形不等式优化的条件是**外大于里，包含大于相交**。

- 用单调队列优化 $DP$ 时一定要关注**边界问题**。

---

## 作者：Zechariah (赞：4)

解法其他大佬说的都很清楚了...重点就是一个结论：决策区间是单调的  
有这个结论，我们每算出一个dp值，就可以去更新决策区间  
维护决策区间的方法有很多，我是用一个队列来维护，每次将当前决策与旧的决策比较，可能有以下几种情况:  
1. 旧决策完全不如新决策，即旧决策的左端点选新决策更优  
2. 旧决策有一部分不如新决策
3. 新决策完全不如旧决策

对于第一种情况，直接把旧决策对应区间合并到新决策上，然后继续更新。  
对于第二种情况，考虑到上面说的单调性，可以在旧决策对应区间上二分，找出一个转折点，把右半部分合并到新决策上，此时已经不可能继续更新了。  
对于第三种情况，直接停止更新。  
复杂度嘛...考虑到每个决策最多被加入一次，最多被删除一次，每次更新最多进行一次二分，再算上快速幂的复杂度，总复杂度应该是$O(T*n*log^2(n))$
```cpp
#include <bits/stdc++.h>
#define lowbit(x) (x & -x)
#define jh(x, y) x ^= y ^=x ^= y
#define loc(x, y) (x - 1) * m + y
#define rg register
#define inl inline
#define PI 3.141592654
typedef long long ll;
typedef long double ld;
const int N = 1e5 + 5, mod = 1e9 + 7;
const ld lim = 1e18;
using namespace std;
namespace fast_IO {
    inl ll read() {
        rg char c;
        rg ll x = 0;
        rg bool flag = false;
        while ((c = getchar()) == ' ' || c == '\n' || c == '\r');
        if (c == EOF)return c; if (c == '-')flag = true; else x = c ^ 48;
        while ((c = getchar()) != ' ' && c != '\n' && c != '\r'&&~c)
            x = (x << 1) + (x << 3) + (c ^ 48);
        if (flag)return -x; return x;
    }
    inl int sread(char *s) {
        rg char c;
        rg int len = 0;
        while ((c = getchar()) == ' ' || c == '\n' || c == '\r');
        s[len++] = c;
        while ((c = getchar()) != ' ' && c != '\n' && c != '\r'&&~c)
            s[len++] = c;
        s[len] = 0;
        return len;
    }
    inl ll max(rg ll a, rg ll b) { if (a > b)return a; return b; }
    inl ll min(rg ll a, rg ll b) { if (a < b)return a; return b; }
    void write(rg ll x) { if (x < 0)putchar('-'), x = -x; if (x >= 10)write(x / 10); putchar(x % 10 ^ 48); }
}
ld dp2[N], sum2[N];
ll dp[N], sum[N], l, p;
int L[N], R[N], q[N], n, from[N], head, tail;
char s[N][31];
inl ll ksm(rg ll a, rg ll b) {
    rg ll ans = 1;
    for (; b; b >>= 1) {
        if (b & 1) ans *= a;
        a *= a;
    }
    return ans;
}
inl ld ksm2(rg ld a, rg ll b) {
    rg ld ans = 1;
    for (; b; b >>= 1) {
        if (b & 1) ans *= a;
        a *= a;
    }
    return ans;
}
inl ld ldabs(rg ld x) { return x < 0 ? -x : x; }
inl ll getdis(rg int x, rg int y) { return ksm(llabs(sum[x] - sum[y] + x - y - 1 - l), p); }
inl ld getdis2(rg int x, rg int y) { return ksm2(ldabs(sum2[x] - sum2[y] + x - y - 1 - l), p); }
inl void update(rg int x) {
    if (dp2[q[head]] + getdis2(L[q[head]], q[head]) < dp2[x] + getdis2(L[q[head]], x)) {
        rg int l = L[q[head]], r = R[q[head]];
        while (l <= r) {
            rg int mid = l + r >> 1;
            rg ld dis1 = getdis2(mid, q[head]), dis2 = getdis2(mid, x);
            if (dp2[q[head]] + dis1 < dp2[x] + dis2)l = mid + 1;
            else r = mid - 1;
        }
        if (l > n)return;
        if (!R[x])R[x] = R[q[head]]; L[x] = l; R[q[head]] = r;
        return;
    }
    R[x] = n; L[x] = L[q[head]]; --head; if (head >= tail)update(x);
}
void print(rg int x, rg int fa) {
    if (x)print(from[x], x), putchar('\n');
    for (rg int i = x + 1; i <= fa; ++i)
        printf(s[i]), i == fa ? 0 : putchar(' ');
}

int main(void) {
    rg int T = fast_IO::read();
    while (T--) {
        memset(L, 0, sizeof(L)); memset(R, 0, sizeof(R));
        memset(from, 0, sizeof(from)); memset(dp, 0, sizeof(dp));
        memset(dp2, 0, sizeof(dp2));
        n = fast_IO::read(); l = fast_IO::read(), p = fast_IO::read();
        for (rg int i = 1; i <= n; ++i)
            sum2[i] = sum[i] = fast_IO::sread(s[i]);
        for (rg int i = 1; i <= n; ++i)sum[i] += sum[i - 1], sum2[i] += sum2[i - 1];
        head = 0, tail = 1;
        dp2[1] = ksm2(ldabs(sum2[1] - l), p);
        dp[1] = ksm(llabs(sum[1] - l), p); q[head = 1] = 0;
        L[0] = 2; R[0] = n; update(1); if (R[1])q[++head] = 1;
        for (rg int i = 2; i <= n; ++i) {
            from[i] = q[tail];
            dp[i] = dp[from[i]] + getdis(i, q[tail]);
            dp2[i] = dp2[from[i]] + getdis2(i, q[tail]);
            ++L[q[tail]]; if (L[q[tail]] > R[q[tail]]) ++tail; update(i); if (R[i])q[++head] = i;
        }
        if (dp2[n] > lim) puts("Too hard to arrange");
        else fast_IO::write(dp[n]), putchar('\n'), print(n, 0);
        printf("--------------------");
        if (T)putchar('\n');
    }
    return 0;
}

```


---

## 作者：Hanghang (赞：4)

介绍一种简单无脑的做法。

摘自[我的博客](https://www.cnblogs.com/Hanghang007/p/17722117.html)

首先你需要会李超线段树。

注意到李超线段树中有一个函数 `Ans`（看模板）是用来计算函数在一个点的取值。

我们如果将我们要求的函数（非直线）的解析式带入，就解决了问题。

把 $|s_i-s_j-1-len|^p$ 看成函数，套李超线段树。

问题在这个函数的值会非常大，但我们又需要比大小，所以只能请出 ```long double``` 来解决。

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef __int128 ll;
typedef long double ld;
typedef pair<ll,ll> pll;
#define fi first
#define se second 
const ll N=3e6+3,INF=(ll)1e18;
ll n,Len,P,rt,sum[N],sta[N];
pll f[N];
string str[N];
ll read()
{
    ll x=0,f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    return x*f;
}
void write(ll X)
{
    if(X<0){putchar('-');X=~(X-1);}int s[20],o=0;
    while(X){s[++o]=X%10;X/=10;}
    if(!o)s[++o]=0;while(o)putchar(s[o--]+'0');
    putchar('\n');
}
struct LCT
{
    ll tot=0;
    struct Tree{ll lc,rc,id;}tr[N];
    ll Abs(ll x){return x>=0?x:-x;}
    ld Ksm(ld x,ll y){ld s=1;for(ll i=1;i<=y;i<<=1,x=x*x)if(y&i)s=s*x;return s;}
    ld Ans(ll id,ll x){return f[id].fi+Ksm(Abs(x-sum[id]-1-Len),P);}
    ll Res(ll id,ll x){return min((ld)INF+1,Ans(id,x));}
    #define ls (tr[p].lc)
    #define rs (tr[p].rc)
    #define mi ((l+r)>>1)
    void Upd(ll &p,ll l,ll r,ll u)
    {
        if(!p){p=++tot;tr[p].id=u;return;}
        ll &v=tr[p].id;
        if(Ans(u,mi)<Ans(v,mi))swap(u,v);
        if(Ans(u,l)<Ans(v,l))Upd(ls,l,mi,u);
        if(Ans(u,r)<Ans(v,r))Upd(rs,mi+1,r,u);
    }
    pll Ask(ll p,ll l,ll r,ll d)
    {
        if(!p)return {INF+1,0};
        pll ans={Res(tr[p].id,d),tr[p].id};
        if(l==r)return ans;
        return min(ans,d<=mi?Ask(ls,l,mi,d):Ask(rs,mi+1,r,d));
    }
    void Clear()
    {
        for(int i=1;i<=tot;i++)tr[i].lc=tr[i].rc=tr[i].id=0;
        tot=rt=0;
    }
}T;
void Solve()
{
    n=read();Len=read();P=read();T.Clear();
    for(int i=1;i<=n;i++)cin>>str[i],sum[i]=sum[i-1]+str[i].size();
    for(int i=1;i<=n;i++)sum[i]+=i;
    T.Upd(rt,0,sum[n],0);
    for(int i=1;i<=n;i++)f[i]=T.Ask(rt,0,sum[n],sum[i]),T.Upd(rt,0,sum[n],i);
    if(f[n].fi>INF)cout<<"Too hard to arrange"<<endl;
    else
    {
        write(f[n].fi);ll top=0,x=n;
        while(x)sta[++top]=x,x=f[x].se;
        sta[++top]=0;
        for(int i=top;i>1;i--)
        {
            for(int j=sta[i]+1;j<sta[i-1];j++)cout<<str[j]<<" ";
            cout<<str[sta[i-1]]<<endl;
        }
    }
    cout<<"--------------------"<<endl;
}
int main()
{
    ll T;T=read();
    while(T--)Solve();
}
```

---

## 作者：fdfdf (赞：2)

设$f[i]$表示将前$i$个短句进行排版的最小代价,那么

$$f[i]=min_{j=0}^{i-1}\{f[j]+w_{j+1,i}\}$$

其中$w_{l,r}$表示将$[l,r]$内的短句排在一行所用代价,

设$a[i]$表示第$i$个短句的长度,则有

$$w_{l,r}=(|\sum_{i=l}^ra_i+r-l-L|)^P$$

这里给出一种证明决策单调性的较为容易理解的方法。

我们知道决策单调性即对于两个决策$i<j$存在一个分界点$k$,$\le k$时$i$更优,$>k$时$j$更优。

那么对于两个位置$k<l$,可以认为是$w_{i,k}-w_{j,k}\le w_{i,l}-w_{j,l}$,因为当$w_{i,k}\ge w_{j,k}$时由上式可以推出$w_{i,l}\ge w_{j,l}$。

这个命题等价于$w_{i,j}-w_{i+1,j}\le w_{i,j+1}-w_{i+1,j+1}$,用不等式的连续性证明是很容易的。

这个式子即$w_{i,j}+w_{i+1,j+1}\le w_{i,j+1}+w_{i+1,j}$,即我们口中的四边形不等式。

所以**证明决策单调性等价于证明四边形不等式。**

这里的方法借鉴了国家集训队2017年论文《浅谈决策单调性动态规划的线性解法》。

回到原问题,那么我们需要证明的四边形不等式可以转化为

$$(|x+y-L|)^P+(|y+z-L|)^P\le (|x+y+z-L|)^P+(|y-L|)^P$$

其中$x,y,z>0$。

令$a=y,b=x+y,c=y+z,d=x+y+z$,
可以知道$a\le b,c$且$b,c\le d$,不妨设$b\le c$。

那么我们可以根据$L$的取值进行讨论,如图所示:

![](https://cdn.luogu.com.cn/upload/pic/55805.png)

四个绝对值可以转化为四个距离$La,Lb,Lc,Ld$,不等式变为$Lb^P+Lc^P\le La^P+Ld^P$。

- $L\in (-\infty,a)$/$L\in (d,\infty)$

去掉绝对值再对次幂展开后的每一项进行比较即可。

另一种情况由对称性可得。

- $L\in (a,\frac{a+b}{2})$/$L\in (\frac{c+d}{2},d)$

此时可以把$a$沿$L$翻折折到$a'$,转化为第一种情况。

- $L\in (\frac{a+b}{2},\frac{c+d}{2})$

此时$Lb\le La,Lc\le Ld$。

那么我们证明了这题决策单调性的正确性。

因为数据范围不是很大,套用普通的决策二分栈做法即可。

```cpp
#include<bits/stdc++.h>
#define FL "a"
using namespace std;
typedef long long ll;
typedef long double dd;
const int N=1e5+10;
const dd INF=1e18;
inline ll read(){
  ll d=0,w=1;char ch=getchar();
  while(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();
  if(ch=='-')w=-1,ch=getchar();
  while(ch<='9'&&ch>='0')d=d*10+ch-48,ch=getchar();
  return d*w;
}
inline void file(){
  freopen(FL".in","r",stdin);
  freopen(FL".out","w",stdout);
}

inline dd poww(dd a,int b){
  dd res=1;if(!a||!res)return 0;
  for(;b;b>>=1){
    if(b&1)res*=a;
    a*=a;
  }
  return res;
}

string s[N];int a[N],n,L,P;
inline dd qry(int l,int r){return poww(abs(a[r]-a[l-1]+r-l-L),P);}

inline void init(){  
  n=read();L=read();P=read();
  for(int i=1;i<=n;i++)
    cin>>s[i],a[i]=s[i].length()+a[i-1];
}

dd f[N];int c[N],p[N],tp,pre[N];
inline void print(int l,int r){
  for(int i=l;i<r;i++)
    cout<<s[i]<<' ';
  cout<<s[r]<<endl;
}
void search(int i){
  if(!i)return;
  search(pre[i]);
  print(pre[i]+1,i);
}
inline int divide(int i,int j){
  int l=j+1,r=n+1,mid;
  while(l<r){
    mid=(l+r)>>1;
    f[i]+qry(i+1,mid)>=f[j]+qry(j+1,mid)?
      r=mid:l=mid+1;
  }
  return l;
}
inline void solve(){
  tp=1;c[tp]=0;p[tp]=n;
  for(int i=1,pos;i<=n;i++){
    pre[i]=c[lower_bound(p+1,p+tp+1,i)-p];
    f[i]=f[pre[i]]+qry(pre[i]+1,i);
    if(divide(c[tp],i)>n)continue;
    else{
      while(tp){
	pos=divide(c[tp],i);
	if(pos-1<=p[tp-1])tp--;
	else{p[tp]=pos-1;break;}
      }
      c[++tp]=i;p[tp]=n;
    }
  }
  if(f[n]>INF){puts("Too hard to arrange\n--------------------");return;}
  printf("%.Lf\n",f[n]);
  search(n);
  puts("--------------------");
}

int main()
{
  int T=read();
  while(T--){
    init();
    solve();
  }
  return 0;
}

```

---


# [SDOI2011] 消耗战

## 题目描述

在一场战争中，战场由 $n$ 个岛屿和 $n-1$ 个桥梁组成，保证每两个岛屿间有且仅有一条路径可达。现在，我军已经侦查到敌军的总部在编号为 $1$ 的岛屿，而且他们已经没有足够多的能源维系战斗，我军胜利在望。已知在其他 $k$ 个岛屿上有丰富能源，为了防止敌军获取能源，我军的任务是炸毁一些桥梁，使得敌军不能到达任何能源丰富的岛屿。由于不同桥梁的材质和结构不同，所以炸毁不同的桥梁有不同的代价，我军希望在满足目标的同时使得总代价最小。  

侦查部门还发现，敌军有一台神秘机器。即使我军切断所有能源之后，他们也可以用那台机器。机器产生的效果不仅仅会修复所有我军炸毁的桥梁，而且会重新随机资源分布（但可以保证的是，资源不会分布到 $1$ 号岛屿上）。不过侦查部门还发现了这台机器只能够使用 $m$ 次，所以我们只需要把每次任务完成即可。  

## 说明/提示

#### 数据规模与约定

- 对于 $10\%$ 的数据，$n\leq 10, m\leq 5$ 。  
- 对于 $20\%$ 的数据，$n\leq 100, m\leq 100, 1\leq k_i\leq 10$ 。  
- 对于 $40\%$ 的数据，$n\leq 1000, 1\leq k_i\leq 15$ 。  
- 对于 $100\%$ 的数据，$2\leq n \leq 2.5\times 10^5, 1\leq m\leq 5\times 10^5, \sum k_i \leq 5\times 10^5, 1\leq k_i< n, h_i\neq 1, 1\leq u,v\leq n, 1\leq w\leq 10^5$ 。  

## 样例 #1

### 输入

```
10
1 5 13
1 9 6
2 1 19
2 4 8
2 3 91
5 6 8
7 5 4
7 8 31
10 7 9
3
2 10 6
4 5 7 8 3
3 9 4 6
```

### 输出

```
12
32
22
```

# 题解

## 作者：Rhodoks (赞：264)

新学虚树，写篇文章仔细地回顾一下吧。。。这玩意花了挺长时间的。

### 什么是虚树

虚树常常被使用在树形$dp$中，就比如这题。当一次询问仅仅涉及到整颗树中少量结点时，为每次询问都对整棵树进行$dp$在时间上是不可接受的。此时，我们建立一颗仅仅包含部分关键结点的虚树，将非关键点构成的链简化成边或是剪去，在虚树上进行$dp$。

虚树包含所有的询问点及它们之间的$lca$。显然虚树的叶子节点必然是询问点，因此对于某次含有$k$个点的询问，虚树最多有$k$个叶子结点，从而整颗虚树最多只有$2k-1$个结点（这会在虚树变成二叉树形态时达到）。




### 建立虚树之前
我们需要：

预处理出原树的$dfs$序以及$dp$可能用到的一些其他东西。

高效的在线$LCA$算法，单次询问$O(logn)$的倍增和树剖，$O(1)$的$RMQ-ST$皆可。

将询问点按$dfs$序排序。

### 如何建立虚树

最右链是虚树构建的一条分界线，表明其左侧部分的虚树已经完成构建。我们使用栈$stak$来维护所谓的最右链，$top$为栈顶位置。值得注意的是，最右链上的边并没有被加入虚树，这是因为在接下来的过程中随时会有某个$lca$插到最右链中。

初始无条件将第一个询问点加入栈$stak$中。

将接下来的所有询问点顺次加入，假设该询问点为$now$，$lc$为该点和栈顶点的最近公共祖先即$lc=lca(stak[top],now)$。

由于$lc$是$stak[top]$的祖先，$lc$必然在我们维护的最右链上。

考虑$lc$和$stak[top]$及栈中第二个元素$stak[top-1]$的关系。

#### 情况一

$lc=stak[top]$，也就是说，$now$在$stak[top]$的子树中

![](https://cdn.luogu.com.cn/upload/pic/52299.png)

这时候，我们只需把$now$入栈，即把它加到最右链的末端即可。

### 情况二
$lc$在$stak[top]$和$stak[top-1]$之间。

![](https://cdn.luogu.com.cn/upload/pic/52300.png)

显然，此时最右链的末端从$stak[top-1]->stak[top]$变成了$stak[top-1]->lc->stak[top]$，我们需要做的，首先是把边$lc-stak[top]$加入虚树，然后，把$stak[top]$出栈，把$lc$和$now$入栈。

### 情况三
$lc=stak[top-1]$。

![](https://cdn.luogu.com.cn/upload/pic/52301.png)

这种情况和第二种情况大同小异，唯一的区别就是$lc$不用入栈了。


### 情况四
此时有$dep[lc]<dep[stak[top-1]]$。$lc$已经不在$stak[top-1]$的子树中了，甚至也未必在$stak[top-2],stak[top-3]......$的子树中。


![](https://cdn.luogu.com.cn/upload/pic/52404.png)

以图中为例，最右链从$stak[top-3]->stak[top-2]->stak[top-1]->stak[top]$变成了$stak[top-3]->lc->now$。我们需要循环依次将最右链的末端剪下，将被剪下的边加入虚树，直到不再是情况四。

就上图而言，循环会持续两轮，将$stak[top],stak[top-1]$依次出栈，并且把边$stak[top-1]-stak[top],stak[top-2]-stak[top-1]$加入虚树中。随后通过情况二完成构建。

#

当最后一个询问点加入之后，再将最右链加入虚树，即可完成构建。

### 一些问题
1. 如果栈$stak$中仅仅有一个元素，此时$stak[top-1]$是否会出问题？

对于栈$stak$，我们从$1$开始储存。那么在这种情况下，$stak[top-1]=0$，并且$dep[0]=0$。此时$dep[lc]<dep[stak[top-1]]$恒成立。也就是说，$stak[0]$扮演了深度最小的哨兵，确保了程序只会进入情况一和二。

2. 如何在一次询问结束后清空虚树？

不能直接对图进行清空，否则复杂度会退化到$O(n)$的复杂度，这是我们无法承受的。在$dfs$的过程中每当访问完一个结点就进行清空即可。

### 回到本题
以样例的询问二为例（如下图）

![](https://cdn.luogu.com.cn/upload/pic/52297.png)

建立虚树是长这个样子的
![](https://cdn.luogu.com.cn/upload/pic/52380.png)

在本题中，建立有向树即可。我们预处理出$minv[pos]$代表从$1$到$pos$路径上最小的边权。如果$pos$是询问点，那么切断$pos$及其子树上询问点的最小代价$dp(pos)=minv[pos]$，否则，最小代价$dp(pos)=min(minv[pos],\sum dp(to))$（其中$to$是$pos$的儿子）。值得注意的是，即使$pos$是询问点，按道理用不到$dp(to)$的值，但仍旧需要对其儿子进行$dfs$，因为清空虚树需要对整个虚树进行遍历。

还有答案会爆$int$，所以不仅数组要开$LL$，初始化的$INF$也有必要开得足够大。我一开始直接拿$0x3f3f3f3f$结果$WA$了最后一个点。。。。

最后就是蒟蒻~~码风清奇常数巨大命名混乱~~的代码了

```cpp
#include <bits/stdc++.h>
#define INL inline
#define REG register
#define DB double
#define LDB long double
#define ULL unsigned long long
#define LL long long

#define RPT(i,x,y) for (REG int i=x;i<y;i++)
#define DRPT(i,x,y) for (REG int i=x;i>y;i--)
#define MST(a,b) memset(a,b,sizeof(a))

#define MAXN 500500
#define MAXM 10000
#define MOD 998244353
#define INF 0x3f3f3f3f
#define LLINF 0x3f3f3f3f3f3f3f3f 
#define EPS 1e-5

#define _ 0
using namespace std;

int dfn[MAXN];
int dep[MAXN];
int fa[MAXN][25];
LL minv[MAXN];
int m[MAXN];
int lst[MAXN];
bool query[MAXN];
int n,q;
int num;
int top;
int dfscnt=1;

int stak[MAXN];

struct EDGE
{
	int to,next;
	LL val;
}edge[MAXN<<1],edge1[MAXN<<1]; 

int head[MAXN];//初始图存储 
int cnt=1;
INL void add(int x,int y,LL v)
{
	edge[cnt].next=head[x];
	edge[cnt].to=y;
	edge[cnt].val=v;
	head[x]=cnt++;
}

int head1[MAXN];//虚树存储 
int cnt1=1;
INL void add1(int x,int y)
{
	edge1[cnt1].next=head1[x];
	edge1[cnt1].to=y;
	head1[x]=cnt1++;
}

void dfs(int pos)
{
	int k;
	for (k=0;fa[pos][k];k++)
		fa[pos][k+1]=fa[fa[pos][k]][k];
	m[pos]=k;
	dfn[pos]=dfscnt++;
	for (int i=head[pos];i;i=edge[i].next)
	{
		REG int to=edge[i].to;
		if (!dfn[to])
		{
			dep[to]=dep[pos]+1;
			minv[to]=min(minv[pos],edge[i].val);
			fa[to][0]=pos;
			dfs(to);
		}
	}
}

LL dfs1(int pos) //dp
{
	LL sum=0;
	LL tem;
	for (int i=head1[pos];i;i=edge1[i].next)
	{
		int to=edge1[i].to;
		sum+=dfs1(to);
	}
	if (query[pos])
		tem=minv[pos];
	else
		tem=min(minv[pos],sum);
	query[pos]=false; //清空虚树 
	head1[pos]=0;
	return tem;
}

int lca(int x,int y) //倍增LCA 
{
	if (dep[x]<dep[y])
		swap(x,y);
	DRPT(i,m[x],-1)
		if (dep[fa[x][i]]>=dep[y])
			x=fa[x][i];
	if (x==y)
		return x;
	DRPT(i,m[x],-1)
		if (fa[x][i]!=fa[y][i])
		{
			x=fa[x][i];
			y=fa[y][i];
		}
	return fa[x][0];
} 

bool cmp(int x1,int x2)
{
	return dfn[x1]<dfn[x2];
}

int main()
{
	minv[1]=LLINF;
	cin>>n;
	int x,y;
	LL v;
	RPT(i,0,n-1)
	{
		scanf("%d%d%lld",&x,&y,&v);
		add(x,y,v);
		add(y,x,v);
	}
	dfs(1);
	cin>>q;
	while (q--)
	{
		cin>>num;
		RPT(i,1,num+1)
		{
			scanf("%d",&lst[i]);
			query[lst[i]]=true;
		}
		sort(lst+1,lst+num+1,cmp);
		stak[top=1]=lst[1];
		RPT(i,2,num+1)
		{
			int now=lst[i];
			int lc=lca(now,stak[top]);
			while (1)
				if (dep[lc]>=dep[stak[top-1]])
				{
					if (lc!=stak[top]) //不满足该条件为情况一 
					{
						add1(lc,stak[top]);
						if (lc!=stak[top-1]) //情况二 
							stak[top]=lc;
						else //情况三 
							top--;
					}
					break;
				}
				else //情况四
				{
					add1(stak[top-1],stak[top]);  
					top--;
				}
			stak[++top]=now; //最后统一把now压进栈中 
		}
		while (--top)
			add1(stak[top],stak[top+1]); //将最右链放进虚树 
		cout<<dfs1(stak[1])<<endl;
		cnt1=1;
	}
	return ~~(0^_^0);
}

```

第一次写那么长的题解，~~以上内容均为口胡~~。由于自己实在是太蒟蒻了，错误缺漏之处在所难免，如有发现烦请各位大佬们指正。

---

## 作者：shadowice1984 (赞：115)

### 虚树
作为虚树的经典例题，拿这道题介绍一下虚树是什么好了~

#### dfs原理

不知道大家发现一件事了没有，我们关于"树"的所有信息，绝大部分是通过dfs处理出来的，但是我们发现一件事，dfs其实在底层实现上，并不是大家脑海中想象的dfs。

当你的程序编译出来之后，你觉得你在跑dfs，但是计算机并不这么想，因为你甚至没有建树，实际上只有邻接表而已，树？不存在的，而你以为你在这个树上进行了所谓的"深度优先搜索"，而计算机并不这么认为，它只是按一定的指令对一个栈进行了反复的push和pop，期间做一些事罢了(应该都知道递归函数的实现过程隐性的开了一个栈吧……)

水了这么多，其实只是想说两件事，第一，我们做dfs可以了解树的信息，而且了解的很充分，第二，我们可以在不建树的情况下做dfs，只要我们掌握了可以模拟dfs的信息即可，也就是说，在跑dfs的过程中，我们究竟对开出来的栈进行了什么操作

#### 虚树的构建

emm大家应该都知道这道题是个树形dp吧。首先让我们先来写个暴力

令sum\[i]表示切断i的子树中所有询问点的最小代价之和，并且你不能直接切掉i，再令mi\[i]表示i到1号点的路径中最小的边权，那么我们可以得到这样一个转移方程

sum\[i]=sigma(min(mi\[v],sum\[v]) (v∈i.son)

意义就是我们枚举i的所有子树，为了切断这个子树v，要不然就直接断了v，一了百了，或者可以切断v中的所有询问点。答案就是sum\[1]

然后我们可以简单粗暴的跑一边dfs，dp得出答案，复杂度O(N^2)，40pts get√

但是呢，我们发现更新i仅和v有关，跟i一点关系没有……，这意味这我们可以跳过若干个无用的节点，将一个直路径压缩为一条边(这里指一个点到自己的直系祖先的路径)。但是如何区别有用和没用的节点呢？显然所有询问点全部有用，1号点也有用，但是光这些是不行的，可能不存在祖先关系，因此还要加一些别的点

然后诸位dalao经过研究发现，如果我们把询问点按dfs序排序，相邻的点求一个lca，询问点+这些lca就可以保证对于任意一个集合中的点，存在且仅有一条仅包含两个集合点的**直**路径，(1号点除外)

那么我们可以把这种关系认为是父子关系，举个栗子

![](https://cdn.luogu.com.cn/upload/pic/14884.png)

图中的红点是询问点，绿点是lca，蓝色的路径表示边，于是我们就从黑树中抽出了一只树同时保留了关于红点的全部信息

也就是说，对于这道题，我们可以建出这样的树，然后再这种树上跑dfs，就可以达到同样的树形dp效果

等等……要求dfs？但是前面说过dfs并不依赖于树，也就是说，我们可以不建树同时dfs，但是这要求我们掌握一个东西，即什么时候压栈，什么时候弹栈。再说的直白一点，我们需要欧拉序

##### 欧拉序

什么是欧拉序，正常的dfs序仅在入栈的时候计算一次，而欧拉序，不仅在入栈的时候计算一次，还在出栈的时候计算一次，也就是说一个点有两次出现机会压栈为+，弹栈为-，欧拉序记录了dfs的**全部信息**，只要有了这个树的欧拉序，就算没有树，给我们一个栈，照样可以在树上跑dfs

### 本体题解

其实话已经说了一半了，我们发现，抽出来的那只树，它的欧拉序大小关系和原来的树的欧拉序是一样的，所以只需要把所有点的复制一个弹出点，然后把压栈点和弹栈点按原来树上的欧拉序排一波序，就是新树中的点按欧拉序排序的结果，然后欧拉序我们有了，直接不建树跑dfs即可，树形dp同暴力

注意这个算法复杂度不是Nlogsigma(K)因为我们是对一些小的数据排序，比合起来排一个大序的复杂度要小，另外你要真的觉得lca复杂度不行可以TARJAN，但是倍增常数真的小，可以过。

上代码~

```C
#include<cstdio>
#include<algorithm>
#include<vector>
#include<stack>
using namespace std;
typedef long long ll;//开longlong 
const int N=250010;
struct data{int v;int nxt;ll val;}edge[2*N];
int alist[N];int cnt;int n;
inline void add(int u,int v,ll val)
{edge[++cnt].v=v;edge[cnt].nxt=alist[u];alist[u]=cnt;edge[cnt].val=val;}
int dfu;int dfin[N];int dfou[N];int fa[22][N];ll mi[N];int dep[N]; 
inline void dfs(int x)//处理倍增和欧拉序 
{
	dfin[x]=++dfu;
	for(int i=1;fa[i-1][x];i++){fa[i][x]=fa[i-1][fa[i-1][x]];}
	int nxt=alist[x];
	while(nxt)
	{
		int v=edge[nxt].v;ll val=edge[nxt].val;
		if(dfin[v]==0)
		{dep[v]=dep[x]+1;mi[v]=min(mi[x],val);fa[0][v]=x;dfs(v);}
		nxt=edge[nxt].nxt;
	}dfou[x]=++dfu;return;
}
inline int lca(int u,int v)//板子倍增，不会自行问度娘 
{
	if(dep[u]<dep[v])swap(u,v);int del=dep[u]-dep[v];
	for(int i=0;del;del>>=1,i++){if(del&1){u=fa[i][u];}}if(u==v){return u;}
	for(int i=20;i>=0;i--){if(fa[i][u]!=fa[i][v]){u=fa[i][u];v=fa[i][v];}}
	return fa[0][v];
}int tr[4*N];stack <int> s;int m;bool book[N];ll sum[N];//用来还原dfs的栈 
inline bool cmp(int x,int y)//按欧拉序排序 
{int k1=(x>0)?dfin[x]:dfou[-x];int k2=(y>0)?dfin[y]:dfou[-y];return k1<k2;}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<n;i++)
	{
		int u;int v;int val;scanf("%d%d%d",&u,&v,&val);
		add(u,v,val);add(v,u,val);
	}mi[1]=0x7f7f7f7f;dfs(1);scanf("%d",&m);
	for(int i=1;i<=m;i++)
	{
		int cot;scanf("%d",&cot);
		for(int j=1;j<=cot;j++)
		{scanf("%d",&tr[j]);book[tr[j]]=true;sum[tr[j]]=mi[tr[j]];}//先处理关键点 
		sort(tr+1,tr+cot+1,cmp);//按dfs序排序 
		for(int j=1;j<cot;j++)//处理lca 
		{int lc=lca(tr[j],tr[j+1]);if(!book[lc]){tr[++cot]=lc;book[lc]=true;}}
		int nc=cot;for(int j=1;j<=nc;j++){tr[++cot]=-tr[j];}//复制一个-的弹栈点 
		if(!book[1]){tr[++cot]=1;tr[++cot]=-1;}sort(tr+1,tr+cot+1,cmp);//强行加入1号 
		for(int j=1;j<=cot;j++)
		{
			if(tr[j]>0){s.push(tr[j]);}//模拟dfs 
			else
			{
				int now=s.top();s.pop();//pop掉之后剩下的栈顶就是父亲 
				if(now!=1){int fa=s.top();sum[fa]+=min(sum[now],mi[now]);}
				else {printf("%lld\n",sum[1]);}//这里特判一下1 
				sum[now]=0;book[now]=false;//pop完之后记得清空 
			}
		}
	}return 0;//拜拜程序~ 
}
```




---

## 作者：StudyingFather (赞：49)

一道虚树的练手题。

首先显然有如下做法：

设 $f_i$ 表示以 $i$ 号点为根的子树，$i$ 的子节点中所有关键点均不与 $i$ 号点相连花费的最低成本。则所求答案为 $f_1$。

对于 $i$ 号点的每个子节点 $son$，有两种情况：

- 当前子节点 $son$ 是关键点，则连接 $i$ 与 $son$ 的边一定要切断。$f_i=f_i+w(i,son)$。
- 当前子节点 $son$ 不是关键点，则可以选择切断以 $son$ 为根的子树内所有关键点与 $son$ 的联系，或者直接切断连接 $i$ 和 $son$ 的边。$f_i=f_i+\min(w(i,son),f_{son})$。

一次询问的时间复杂度为 $O(n)$，总时间复杂度为 $O(nq)$。

注意到如下两个事实：

1. 所有询问中关键点的总数与 $n$ 同阶。
2. 很多非关键点是没有必要的（比如一个子树内一个关键点都没有，那这个子树内的所有点都不会对答案有贡献）。

我们考虑压缩这棵树，只保留对于 DP 计算有用的节点。

现在要解决两个问题：怎么压缩？哪些节点该保留？

为了确保答案正确，我们压缩时应该确保**树的形态不变**。具体来说，是祖先-后代的关系不变。

在此前提下，我们要让保留的节点数尽可能少。

毫无悬念，所有的关键点应该保留。同时，为了能确定树的形态（即所有节点间的祖先-后代关系），我们应该保留所有关键点两两之间的最近公共祖先。

下一个问题是，如何建树？

如果直接枚举所有关键点对，计算两两之间的最近公共祖先，时间复杂度显然无法接受。

一种想法是将所有关键点先按 DFS 序排序，按顺序一个一个加到树里。刚开始树上只有 $1$ 号点。

接下来，我们用一个栈维护在树上一条链上的所有点。这个栈内的所有点满足其 DFS 序单调递增。

我们每次准备将一个关键点加入栈中时，求一下当前栈顶点和要加入的关键点的最近公共祖先 $p$。

1. 如果栈顶就是 $p$，则可以知道我们加入的关键点和栈中的点在一条链上，直接将关键点加入栈中即可。
2. 如果栈顶不是 $p$，则需要将栈中的一些点弹出来，使得新加入的点和栈里的点在一条链上。具体来说，我们需要不停地将栈顶弹出，直到要插入的点的 DFS 序小于栈顶下面的点的 DFS 序。接下来分两种情况：
  - 如果此时栈顶是 $p$，直接将关键点插入栈；
  - 如果此时栈顶不是 $p$（显然这时候 $p$ 的 DFS 序比栈顶大），说明 $p$ 不在链上，将栈顶弹出，插入 $p$ 和关键点。

弹栈的时候顺带把边连接一下，树就建好啦。在新的树上跑原来的 DP 就可以了。

经过这样的操作，我们各次建树时的节点数之和将会控制在 $O(n)$ 的级别，可以通过本题。

```cpp
// Problem : P2495 [SDOI2011]消耗战
// Contest : Luogu
// URL : https://www.luogu.com.cn/problem/P2495
// Memory Limit : 500 MB
// Time Limit : 2000 ms
// Powered by CP Editor (https://github.com/cpeditor/cpeditor)

#include <cstring>
#include <iostream>
#include <set>
#include <algorithm>
using namespace std;
struct graph
{
 struct edge
 {
  int v,w,next;
 }e[1000005];
 int head[500005],ch,cnt;
 void addedge(int u,int v,int w)
 {
  e[++cnt].v=v;
  e[cnt].w=w;
  e[cnt].next=head[u];
  head[u]=cnt;
 }
}t1,t2;
int fa[500005][25],mind[500005][25],dis[500005],dep[500005],dfn[500005],cnt;
int a[500005];
long long f[500005];
int sta[500005];
int d;
set<int> s;
bool cmp(int x,int y)
{
 return dfn[x]<dfn[y];
}
void dfs1(int u,int f)
{
 dfn[u]=++cnt;
 dep[u]=dep[f]+1;
 fa[u][0]=f;
 for(int i=1;i<=20;i++)
 {
  fa[u][i]=fa[fa[u][i-1]][i-1];
  mind[u][i]=min(mind[u][i-1],mind[fa[u][i-1]][i-1]);
 }
 for(int i=t1.head[u];i;i=t1.e[i].next)
 {
  int v=t1.e[i].v,w=t1.e[i].w;
  if(v!=f)
  {
   dis[v]=dis[u]+w;
   mind[v][0]=w;
   dfs1(v,u);
  }
 }
}
void dfs2(int u)
{
 f[u]=0;
 for(int i=t2.head[u];i;i=t2.e[i].next)
 {
  int v=t2.e[i].v,w=t2.e[i].w;
  dfs2(v);
  if(s.count(v))f[u]+=w;
  else f[u]+=min(f[v],1ll*w);
 }
 return;
}
int getlca(int x,int y)
{
 d=1<<30;
 if(dep[x]>dep[y])swap(x,y);
 for(int i=20;i>=0;i--)
  if(dep[y]-(1<<i)>=dep[x])
  {
   d=min(d,mind[y][i]);
   y=fa[y][i];
  }
 if(x==y)return x;
 for(int i=20;i>=0;i--)
  if(fa[x][i]!=fa[y][i])
  {
   d=min(d,min(mind[x][i],mind[y][i]));
   x=fa[x][i],y=fa[y][i];
  }
 return fa[x][0];
}
int main()
{
 ios::sync_with_stdio(false);
 int n;
 cin>>n;
 for(int i=1;i<n;i++)
 {
  int u,v,w;
  cin>>u>>v>>w;
  t1.addedge(u,v,w);
  t1.addedge(v,u,w);
 }
 dfs1(1,1);
 int q;
 cin>>q;
 while(q--)
 {
  s.clear();
  int k;
  cin>>k;
  for(int i=1;i<=k;i++)
  {
   cin>>a[i];
   s.insert(a[i]);
  }
  sort(a+1,a+k+1,cmp);
  sta[1]=1;
  int top=1;
  t2.head[1]=0;
  for(int i=1;i<=k;i++)
  {
   int lca=getlca(a[i],sta[top]);
   if(lca!=sta[top])//新加的点和原来在栈里的点不在一条链上
   {
    while(dfn[lca]<dfn[sta[top-1]])
    {
     int u=sta[top-1],v=sta[top];
     getlca(u,v);
     t2.addedge(u,v,d);
     top--;
    }
    if(dfn[lca]>dfn[sta[top-1]])//lca 未入栈
    {
     getlca(lca,sta[top]);
     t2.head[lca]=0;
     t2.addedge(lca,sta[top],d);
     top--;
     sta[++top]=lca;
    }
    else
    {
     int u=sta[top-1],v=sta[top];
     getlca(u,v);
     t2.addedge(u,v,d);
     top--;
    }
   }
   t2.head[a[i]]=0;
   sta[++top]=a[i];
  }
  while(top>1)//最后记得把栈里的点也连上边
  {
   int u=sta[top-1],v=sta[top];
   getlca(u,v);
   t2.addedge(u,v,d);
   top--;
  }
  dfs2(1);
  cout<<f[1]<<endl;
 }
 return 0;
}
```

---

## 作者：Nemlit (赞：42)

[原文地址](https://www.cnblogs.com/bcoier/p/10416804.html)

题意：给定一棵树，割断每一条边都有代价，每次询问会给定一些点，求用最少的代价使所有给定点都和1号节点不连通

## 暴力$DP$

我们先考虑暴力怎么做

设$dp[u]$为以$u$为根的子树中，割掉所有给定点的最小代价

转移的时候要分两种情况：

1.若u不是给定点，则$dp[u] = min(u$到根节点的所有边的最小边长，割掉所有含有给定点的子树)

$ps:$上述给定子树不一定与u直接相连

2.若u是给定点，显然他必须与1号点分离，所以$dp[u]=u$到根节点的所有边的最小边长

复杂度$O(nm)$，显然对于$m>=1$这种数据是过不了的

下面给出暴力DP代码（吸氧之后有50分）：
```
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define re register
#define debug printf("Now is Line : %d\n",__LINE__)
#define file(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
//#define int long long
#define inf 1234567890
#define mod 1000000007
il int read()
{
    re int x = 0, f = 1; re char c = getchar();
    while(c < '0' || c > '9') { if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - 48, c = getchar();
    return x * f;
}
#define maxn 2333//我也不知道问什么数组开大会从RE 50分->TLE 20分
struct edge
{
    int v, w, next;
}e[maxn << 1];
int n, m, head[maxn], cnt, is[maxn], dp[maxn];
il void add(int u, int v, int w)
{
    e[++ cnt] = (edge){v, w, head[u]};
    head[u] = cnt;
}
il void dfs(int u, int fr)
{
    int temp = 0;
    for(re int i = head[u]; i; i = e[i].next)
    {
        int v = e[i].v;
        if(v == fr) continue;
        if(is[v]) {temp += e[i].w; continue;}
        dp[v] = min(dp[u], e[i].w);
        dfs(v, u);
        temp += dp[v];
    }
    dp[u] = min(dp[u], temp);
}
int main()
{
    //file(a);
    n = read();
    for(re int i = 1; i < n; ++ i)
    {
        int u = read(), v = read(), w = read();
        add(u, v, w), add(v, u, w);
    }
    int T = read();
    while(T --)
    {
        memset(is, 0, sizeof(is));
        m = read(), dp[1] = inf;
        for(re int i = 1; i <= m; ++ i) is[read()] = 1;
        dfs(1, 0);
        printf("%d\n", dp[1]);
    }
    return 0;
}
```

那么剩下五十分我们要怎么得呢？

我们发现$\sum k[i]$是~~非常~~小的，那我们是不是可以在k上做文(luan)章（gao)呢？

我们发现，有很多点在树上我们是没有用到的，所以我们可以考虑重构一棵新的树，这棵树就叫做————虚树

## 虚树优化$DP$

虚树的思想是只保留有用的点（在这道题目里面显然是标记点和lca），然后重新构建一棵树，从而使节点大大减少，优化复杂度

那么我们要怎么构建虚树呢？

首先对于每一棵树，我们都可以用dfs序表示出来，所以对于每一次询问，我们把所有的标记点按照dfs序排序，然后压进一个栈中，然后连边即可

### 具体方法：

我们先对所有标记点按照$dfs$序排序，并依次入栈

我们考虑入栈操作：

假设我们现在要加入的元素为x，第二个元素为y，栈顶为$s$，$l = lca(x, s)$

因为我们是按$dfs$加入，所以$dfn[s]<dfn[x],dfn[l]<dfn[x]$

如果l=s，也就是说s是x的祖先，那么s到1号点显然有边需要割掉，所以x对答案并不产生影响，直接忽略

所以x，s肯定在l的两边（$dfn[l]<dfn[x]$）

然后我们进行分类讨论

$if(dfn[y] > dfn[l])$ 则说明y在l与x之间，连边$y -> x$，并将x弹出

$if(dfn[y] < dfn[l])$ 则说明l在x与y之间，所以连边$l -> x$，并且令x出栈，l入栈

$if(dfn[y] = dfn[l])$ 则说明y=l，连边 $l -> x$

建树完成以后，每一个节点都是有用点，即满足暴力DP中的含有给定点的子树，所以每一条边都是可以割掉的，直接转移即可

时间复杂度$O(klogk)$

代码如下
```
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define re register
#define debug printf("Now is Line : %d\n",__LINE__)
#define file(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
#define int long long
#define inf 123456789000000000
#define mod 1000000007
il int read()
{
    re int x = 0, f = 1; re char c = getchar();
    while(c < '0' || c > '9') { if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - 48, c = getchar();
    return x * f;
}
#define maxn 250005
struct edge
{
	int v, w, next;
}e[maxn << 1];
int n, m, head[maxn], cnt, is[maxn], mi[maxn], dfn[maxn], col, t;
int size[maxn], fa[maxn], top[maxn], son[maxn], dep[maxn], s[maxn];
vector<int>v[maxn];
il void add(int u, int v, int w)
{
	e[++ cnt] = (edge){v, w, head[u]};
	head[u] = cnt;
}
il bool cmp(int a, int b){return dfn[a] < dfn[b];}
il void dfs1(int u, int fr)
{
	size[u] = 1, fa[u] = fr, dep[u] = dep[fr] + 1;
	for(re int i = head[u]; i; i = e[i].next)
	{
		int v = e[i].v;
		if(v == fr) continue;
		mi[v] = min(mi[u], e[i].w);
		dfs1(v, u), size[u] += size[v];
		if(size[son[u]] < size[v]) son[u] = v;
	}
}
il void dfs2(int u, int fr)
{
	top[u] = fr, dfn[u] = ++ col;
	if(!son[u]) return;
	dfs2(son[u], fr);
	for(re int i = head[u]; i; i = e[i].next)
	{
		int v = e[i].v;
		if(v != fa[u] && v != son[u]) dfs2(v, v);
	}
}
il int lca(int a, int b)
{
	while(top[a] != top[b]) dep[top[a]] > dep[top[b]] ? a = fa[top[a]] : b = fa[top[b]];
	return dep[a] < dep[b] ? a : b;
}
il void push(int x)
{
	if(t == 1) {s[++ t] = x;return;}
	int l = lca(x, s[t]);
	if(l == s[t]) return;
	while(t > 1 && dfn[s[t - 1]] >= dfn[l]) v[s[t - 1]].push_back(s[t]), --t;
	if(s[t] != l) v[l].push_back(s[t]), s[t] = l;
	s[++ t] = x;
}
il int dp(int u)
{
	if(v[u].size() == 0) return mi[u];
	int temp = 0;
	for(re int i = 0; i < v[u].size(); ++ i) temp += dp(v[u][i]);
	v[u].clear();
	return min(mi[u], temp);
}
signed main()
{
	file(a);
	n = read();
	for(re int i = 1; i < n; ++ i)
	{
		int u = read(), v = read(), w = read();
		add(u, v, w), add(v, u, w);
	}
	mi[1] = inf, dfs1(1, 0), dfs2(1, 1);
	int T = read();
	while(T --)
	{
		m = read();
		for(re int i = 1; i <= m; ++ i) is[i] = read();
		sort(is + 1, is + m + 1, cmp);
		s[t = 1] = 1;
		for(re int i = 1; i <= m; ++ i) push(is[i]);
		while(t > 0) v[s[t - 1]].push_back(s[t]), --t;
		printf("%lld\n", dp(1));
	}
	return 0;
}
```

---

## 作者：ACalgorithm (赞：21)

	这题不是很难，裸裸的一道虚树处理树形DP的题：
    首先：考虑裸DP，f[i]表示将i子树内所有点处理掉所需的最小代价
    	  用一个辅助数组mn[i]表示i到根路径上的最小边权，那么转移就很	  	    显而易见了吧：    
```cpp
      mn[v]=min(mn[u],(ll)edge[i].w);
      for(register int i=0;i<v[x].size();i++){
          ans+=pr(v[x][i]);
      }
      return f[x]=min(ans,mn[x]);
```
		  然而，暴力肯定是不行的啊，毕竟是每次询问O(n)，不就炸的飞起
          那么考虑优化，总点数那么小，肯定有什么办法利用这个的。
          我们考虑一下DP过程，是不是会遍历到所有lca到需求点路径上的点
          那么是不是可以路径压缩一下？
          我们将一棵树压缩成只有需求点和其lca的树（其实就是虚树）
          我们再考虑如果这样会有多少个点，我们将其按dfs序排序，那么相
          邻点的lca一定比较远点的lca深，也就是更接近那两个点那么新加
          入一个点，最多也就会新加入一个lca,所以总共最多就2*k个点，DP
          随便过。
          
          建树具体过程见代码：
```cpp
#pragma g++ opitmize(3)
#include<vector>
#include<bits/stdc++.h>
#define rep(i,a,b) for(register int i=a;i<=b;i++)
#define per(i,b,a) for(register int i=b;i>=a;i--)
typedef long long ll;
using namespace std;
int n,tot,m,dfn[250010],t,a[500010],_top,s[250010];
ll mn[250010];
namespace T{
	int head[250010],fa[250010],top[250010],d[250010],sz[250010],son[250010],k;
	struct node{
		int to,nt,w;
	} edge[500010];
	inline void add(int u,int v,int w){
		edge[++k].nt=head[u];head[u]=k;
		edge[k].to=v;edge[k].w=w;
	}
	inline void dfs1(int u,int f){
		fa[u]=f;sz[u]=1;d[u]=d[f]+1;
		for(register int i=head[u];i;i=edge[i].nt){
			int v=edge[i].to;
			if(v==f) continue;
			mn[v]=min(mn[u],(ll)edge[i].w);
			dfs1(v,u);sz[u]+=sz[v];
			if(!son[u]||sz[v]>sz[son[u]]) son[u]=v;
		}
	}
	inline void dfs2(int u,int tp){
		top[u]=tp;dfn[u]=++tot;
		if(!son[u]) return ; dfs2(son[u],tp);
		for(register int i=head[u];i;i=edge[i].nt){
			int v=edge[i].to;
			if(v==fa[u]||v==son[u]) continue;
			dfs2(v,v);
		}
	}
	inline int LCA(int x,int y){
		while(top[x]!=top[y]){
			if(d[top[x]]<d[top[y]]) x^=y^=x^=y;
			x=fa[top[x]];
		}
		return d[x]>d[y]?y:x;
	}
}
using namespace T;
namespace FT{
	vector<int> v[250010];
	inline void add(int x,int y){
		v[x].push_back(y);
	}
	inline void ins(int x) {
	    if(_top == 1) {s[++_top] = x; return ;}
	    int lca = T::LCA(x, s[_top]);
	    if(lca == s[_top]) return ;
	    while(_top > 1 && dfn[s[_top - 1]] >= dfn[lca]) add(s[_top - 1], s[_top]), _top--;
	    if(lca != s[_top]) add(lca, s[_top]), s[_top] = lca;
	    s[++_top] = x;
	}
	inline ll pr(int x){
		if(v[x].size()==0) return mn[x];
		ll ans=0;
		for(register int i=0;i<v[x].size();i++){
			ans+=pr(v[x][i]);
		}
		v[x].clear();
		return min(ans,mn[x]);
	}
	inline bool cmp(int a,int b){
		return dfn[a]<dfn[b];
	}
}
using namespace FT;
int main(){
	scanf("%d",&n);
	memset(mn,0x3f,sizeof(mn));
	int u,v,w;
	rep(i,1,n-1) scanf("%d%d%d",&u,&v,&w),T::add(u,v,w),T::add(v,u,w);
	T::dfs1(1,0);T::dfs2(1,1);
	int x,y;
	scanf("%d",&m);
	while(m--) {
        int K;scanf("%d",&K);
        for(int i = 1; i <= K; i++) scanf("%d",&a[i]);
        sort(a + 1, a + K + 1, FT::cmp);
        s[_top = 1] = 1;
        for(int i = 1; i <= K; i++) FT::ins(a[i]);
        while(_top > 0)  FT::add(s[_top - 1], s[_top]), _top--;
        printf("%lld\n",FT::pr(1)); 
    }
    return 0;
}

```

------------

	**update:**
    还是说一下建树过程吧（**栈中维护的是一条链**）：
```cpp
	inline void ins(int x) {
	    if(_top == 1) {s[++_top] = x; return ;}
	    int lca = T::LCA(x, s[_top]);
	    if(lca == s[_top]) return ;
	    while(_top > 1 && dfn[s[_top - 1]] >= dfn[lca]) add(s[_top - 1], s[_top]), _top--;
	    if(lca != s[_top]) add(lca, s[_top]), s[_top] = lca;
	    s[++_top] = x;
	}
```
    	首先，每插入一个点，如果栈顶元素是他所在链上的点，那么就可
        以不加这个点，这个画画图就知道了；
        然后，如果你新加入了一个点，且栈顶元素的dfn比lca的dfn大那么
        说明栈顶元素在所在子树已经构建完了（如果没有，即x的子树中还
        有一个未加入的点y，但是dfn[y]<dfn[p]，即应先访问y），弹出那
        棵子树；
        弹完后，如果栈顶的点不等于lca，那么说明他在lca上面，这时就
        需要加入lca了。
        最后的时候，你栈里还有一条链，不要忘了连边。
        （画画图模拟模拟吧，应该就懂了）

------------

	如果仍然看不懂的话，就借鉴借鉴dalao博客吧：
    毕竟我也不一定能讲清楚，dalao博客还是说得挺容易懂的
[dalao博客](https://www.cnblogs.com/zwfymqz/p/9175152.html)

------------

	话说我竟然一次就A了，自己都难以置信，祝你们一遍AC吧，懂了话，还
    是挺好写的

---

## 作者：tth37 (赞：16)

这是一篇虚树入门题解。

考虑题目中 $m=1$ 的情况。树上动规，定义状态 $f[u]$ 表示切断节点 $u$ 与该子树内所有关键点的路径，最小总代价。状态转移方程如下：
$$
f[u]=w(u,v)\ \ (h[v]=1)
$$

$$
f[u]=\min(w(u,v),f[v])\ \ (h[v]=0)
$$

动态规划部分不再赘述。该算法复杂度为 $O(n)$ 。

考虑题目中 $m\not= 1$ 的情况。如果对于每一次查询，都进行一次 $O(n)$ 复杂度的遍历显然无法接受。观察到题目中 $\Sigma{k}$ 的取值不大，可以考虑针对没个询问，**舍弃树上的一些非关键点，仅保留一棵包含原树上部分节点的虚树**，并在**虚树**上进行动态规划。

那么，在虚树上应该保留原树上的哪些点呢？

首先，每次讯问中给出的 $k$ 个关键点（资源丰富的岛屿）显然应该包含在虚树中。其次，任意两个关键点的最近公共祖先也应该包含在虚树中；因为在本题中，切断一条边可以同时切断根节点与多个关键点间的路径，最近公共祖先的存在为动态规划提供了这种状态转移。最后为了方便，我们可以将 $1$ 号节点（即根节点）也加入到虚树中。

构造虚树的方法很多，在这里介绍一种用**栈**建树的算法流程。

令 $1$ 号节点为虚树的根。

将所有关键点按照其在原树中的 dfs 序升序排序。假设当前正在处理的关键点为 $u$ 。

维护一个栈，使得栈底到栈顶的元素依次为虚树上**从根节点到节点 $u$ 的一条链**。

这里为什么要维护一个栈呢？

![1.jpg](https://i.loli.net/2019/08/30/qTkLb1Wca4yvwJ9.jpg)

如图：在处理完 $3$ 号关键点后，虚树中只有 $1$ 、 $3$ 两个节点，栈中的元素依次为 $1$ 、 $3$ 。但是这条链是不完整的，可以观察到在处理 $4$ 号关键点时，还需要将 $2$ 号节点添加到虚树中。利用栈的性质，我们可以动态维护一条虚树上的链，并在必要的时候添加节点。

回到刚才的叙述，当前正在处理关键点 $u$ 。根据栈的定义，上一个处理的关键点一定为 $stack.top()$ 。

由于进行过排序，即节点 $u$  的 dfs 序大于上一个关键点的 dfs 序，因此节点 $u$ 要么是上一个关键点的后代，要么与其没有祖先-后代的关系。

显然，如果节点 $u$ 是 $stack.top()$ 的后代，那么只需将节点 $u$ 入栈即可，因为 $u$ 在虚树中，一定是上一个关键点的儿子。

但是如果节点 $u$ 与 $stack.top()$ 没有祖先-后代的关系，那么此时的讨论将比较复杂。

可以结合上图观察，假设当前正在处理 $4$ 号关键点。我们可以首先将栈顶弹出，因为 $stack.top()$ 一定不在根节点到节点 $u$ 的链上。此时，栈中剩余的元素只有 $1$ 。然而， $3$ 与 $4$ 的最近公共祖先 $2$ 号节点还不在栈中；因此我们需要把 $2$ 号节点入栈，并将**刚刚弹出的节点与新的栈顶**在虚树中连边。处理结束后，将 $4$ 入栈。

接下来处理 $5$ 号关键点，此时栈中的元素依次为 $1$ 、$2$ 、$4$ 。首先将栈顶弹出，但由于我们接下来需要维护的链为 $1->5$ ，栈中仍然有节点 $2$ ，因此我们需要将 $2$ 和刚刚弹出的节点 $4$ 连边，并且重复以上操作。将新的栈顶 $2$ 弹出后，栈中只剩下节点 $1$ 。这时发现 $1$ 号节点恰好为 $5$ 与上一次处理的关键点 $4$ 的最近公共祖先，因此将 $1$ 与 $2$ 连边后，弹栈可以中止了。处理结束后，将 $5$ 入栈。

此时我们已经处理完了所有关键点，但是栈中的元素间还没有连边。将栈中的节点依次连边后，虚树的构建就完成了。

伪代码如下：

```
将关键点按照 dfs 序排序
stack.push(1)
for u = 1 ~ k: // 假设当前正在处理节点 u
	lca = Lca(u, stack.top())
	while stack.top() != lca:
		tmp = stack.top()
		stack.pop()
		if dfn[stack.top()] < dfn[lca]
			stack.push(lca)
		AddEdge(stack.top(), tmp)
	stack.push(u)
while stack.top() != 1:
	tmp = stack.top()
	stack.pop()
	AddEdge(stack.top(), tmp)
```

可以证明，对于本题，虚树上的边权一定对应原树上两节点之间边权的最小值。证明不再赘述。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
struct Edge {int v;ll w;Edge(int a, ll b) {v = a, w = b;}};
struct Key {int u, dfn;}keys[250005];
int keys_cnt;
inline bool cmp(Key a, Key b) {
    return a.dfn < b.dfn;
}
int N, M;
vector<Edge> G[250005], VT[250005];
int f[250005][19], g[250005][19], dep[250005];
ll d[250005];
bool h[250005];
int dfn[250005], dfn_idx;
int lg[250005];

void dfs(int u, int fa, ll w) {
    dep[u] = dep[fa] + 1;
    dfn[u] = ++dfn_idx;
    f[u][0] = fa, g[u][0] = w;
    for (int i = 1; i <= 18; ++i)
        f[u][i] = f[f[u][i - 1]][i - 1],
        g[u][i] = min(g[f[u][i - 1]][i - 1], g[u][i - 1]);
    for (vector<Edge>::iterator it = G[u].begin(); it != G[u].end(); it++) {
        int v = it -> v;
        ll w = it -> w;
        if (v == fa) continue;
        dfs(v, u, w);
    }
}

void dp(int u) {
    for (vector<Edge>::iterator it = VT[u].begin(); it != VT[u].end(); it++) {
        int v = it -> v;
        ll w = it -> w;
        dp(v);
        if (h[v]) d[u] += w;
        else d[u] += min(w, d[v]);
        h[v] = 0; d[v] = 0;
    }
    VT[u].clear();
}

inline int Lca(int u, int v) {
    if (dep[u] < dep[v]) swap(u, v);
    while (dep[u] > dep[v]) {
        u = f[u][lg[dep[u] - dep[v]]];
    }
    if (u == v) return u;
    for (int i = lg[dep[u]]; i >= 0; --i)
        if (f[u][i] != f[v][i])
            u = f[u][i], v = f[v][i];
    return f[u][0];
}

inline int query(int u, int v) {
    int ans = 0x3f3f3f3f;
    while (dep[u] > dep[v]) {
        ans = min(ans, g[u][lg[dep[u] - dep[v]]]);
        u = f[u][lg[dep[u] - dep[v]]];
    }
    return ans;
}

inline void AddEdge(int u, int v) {
    int w = query(v, u);
    VT[u].push_back(Edge(v, w));
}

int main() {
    for (register int i = 2; i <= 250000; ++i)
        lg[i] = lg[i >> 1] + 1;
    memset(g, 0x3f, sizeof(g));
    scanf("%d", &N);
    for (register int i = 1; i < N; ++i) {
        int u, v;
        ll w;
        scanf("%d%d%lld", &u, &v, &w);
        G[u].push_back(Edge(v, w));
        G[v].push_back(Edge(u, w));
    }
    dfs(1, 0, 0);
    scanf("%d", &M);
    while (M--) {
        int k;
        keys_cnt = 0;
        scanf("%d", &k);
        for (register int i = 1; i <= k; ++i) {
            scanf("%d", &keys[++keys_cnt].u);
            h[keys[keys_cnt].u] = 1;
            keys[keys_cnt].dfn = dfn[keys[keys_cnt].u];
        }
        stack<int> s;
        sort(keys + 1, keys + keys_cnt + 1);
        s.push(1);
        for (register int i = 1; i <= keys_cnt; ++i) {
            int u = keys[i].u;
            int lca = Lca(u, s.top());
            while (s.top() != lca) {
                int tmp = s.top(); s.pop();
                if (dfn[s.top()] < dfn[lca])
                    s.push(lca);
                AddEdge(s.top(), tmp);
            }
            s.push(u);
        }
        while (s.top() != 1) {
            int tmp = s.top(); s.pop();
            AddEdge(s.top(), tmp);
        }
        dp(1);
        printf("%lld\n", d[1]);
        d[1] = 0;
    }
    return 0;
}
```



---

## 作者：Fuyuki (赞：10)

~~虚树的题为什么要用虚树做？~~

假如只有一次询问，考虑如何 dp 。

设 $f_u$ 表示将子树 $u$ 内的所有关键点到 $u$ 的路径切断的最小代价，那么转移为 $f_u=\sum_{v}\min(f_v,w(u,v))$，即选择是否断掉儿子 $v$ 到 $u$ 的这条边。特别的，如果 $u$ 本身是关键点，那么 $f_u=\inf$ ，因为不可能通过断边消除 $u\rightarrow u$ 的这条路径。

以 1 为根开始做的话，答案就是$f_1$。

可以发现，这个 dp 的过程非常简洁，由几个简单的操作组成：求和，取 $\min$。

这两个操作都可以在线段树上进行维护，让线段树上第 $i$ 个叶子表示第 $i$ 次询问的 dp 值，那么取 $\min$ 就是全局取 $\min$，求和就是线段树合并的时候对应位置相加。

那么写一个线段树合并就可以通过这道题了，复杂度为$O(n+mlogm)$，跑起来比想象中慢，但是思维量和代码量都比虚树少上不少。

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
#define lc t[p].ls
#define rc t[p].rs
#define I inline int
#define V inline void
#define lson lc,L,mid
#define rson rc,mid+1,R
#define ll long long int
#define root(x) rt[x],1,m
#define FOR(i,a,b) for(int i=a;i<=b;i++)
#define REP(u,e) for(int i=e##h[u],v;v=e[i].t,i;i=e[i].n)
#define add(x,y,w,e) e[++tot]=(edge){y,e##h[x],w},e##h[x]=tot
const int N=5e5+1;
int n,m,tot,eh[N],qh[N],rt[N];
struct edge{int t,n,w;}e[N],q[N];
struct ele{
	int ls,rs;ll v;
	V upd(ll x){if(v>x)v=x;}
}t[N<<5];
V input(){
	scanf("%d",&n);int x,y,w;
	FOR(i,2,n)scanf("%d%d%d",&x,&y,&w),add(x,y,w,e),add(y,x,w,e);
	scanf("%d",&m),tot=w=0;
	FOR(i,1,m)for(scanf("%d",&n);n--;)scanf("%d",&x),add(x,i,w,q);
}
V ins(int&p,int L,int R,int x){
	if(x<L||x>R)return;
	if(!p)t[p=++tot].v=1ll<<40;
	if(L==R)return;int mid=L+R>>1;
	ins(lson,x),ins(rson,x);
}
V solve(int p){t[lc].upd(t[p].v),t[rc].upd(t[p].v),t[p].v=1ll<<40;}
I merge(int x,int y){
	if(!x||!y)return x|y;
	if(!t[x].ls&&!t[x].rs)return t[x].v+=t[y].v,x;
	solve(x),solve(y);
	t[x].ls=merge(t[x].ls,t[y].ls);
	t[x].rs=merge(t[x].rs,t[y].rs);
	return x;
}
V dfs(int u,int fa){
	REP(u,q)ins(rt[u],1,m,v);
	REP(u,e)if(v^fa)
		dfs(v,u),t[rt[v]].upd(e[i].w),rt[u]=merge(rt[u],rt[v]);
}
V output(int p,int L,int R){
	if(L==R)return void(cout<<t[p].v<<'\n');
	int mid=L+R>>1;solve(p),output(lson),output(rson);
}
V work(){tot=0,dfs(1,0),output(rt[1],1,m);}
int main(){
	input();
	work();
	return 0;
}
```

---

## 作者：ez_lcw (赞：9)

这题的dp思想还是比较容易想的，关键是如何保证时间复杂度，这时就用到了虚树的技巧。

## 1.虚树是什么？（虚树的性质）

不妨设现在询问给出了$k$个点，我们命名这些节点为关键节点。

那么在我的建边方式中，虚树就是：

1. 仅包括这些关键节点、它们两两之间的$lca$以及原树的根的一棵有向树。
2. 但仍然保持原树的形态和祖先关系。即若关键节点$a$在原树中是关键节点$b$的祖先，则在虚树中，$a$仍是$b$的祖先。（这里的祖先包括父亲）

故只要我们按这个方法建出虚树，就会有：$\text{虚树的点数}<=2\times k$。不太严谨的证明：我们将其按$dfn$排序，那么相邻点的$lca$一定比较远点的$lca$深，也就是更接近那两个点。那么这样最多也就会新加入一个$lca$,所以总共最多就$2\times k$个点。

## 2.怎么建虚树？

我们先将原树的$dfn$预处理出来，然后我们把所有的关键节点按$dfn$序排序。排完序后按顺序一个一个插入（接下来讲的$insert()$函数）。

同时我们也需要维护一个$stack$，初始只有一个点$root$（$1$号节点），$top=1$。

这个栈用来维护什么呢？不妨设我们现在$insert(u)$。那么我们把$insert(u)$函数执行完后，需要保证这个栈的栈顶是$u$，然后维护的是**原树中**从根到栈顶（$u$）路径上需要加入虚树的节点，或者也可以理解为**虚树中**从根到栈顶（u）的路径上的点，所以若把这个栈中的点依次两两连起边来，便是一条链，但是现在还未连边。而且我们需要保证除了栈中的点之间的连边之外，已经$insert$的点之间的连边都已连好了。

不妨设我们现在要$insert(u)$，那么我们先求出$lca(u,st[top])$，然后我们设原来的栈长什么样：
$stack=\{1,...,st[k-1],st[k],...,st[top]\}$。

然后我们找到$lca$在这条链中的位置，即$deep[st[k-1]]<deep[lca]\leqslant deep[st[k]]$，那么$st[k]$、$st[k+1]$...$st[top]$必然是$lca$的子/孙（因为$lca$是$st[top]$和$u$的祖先）。

那么我们考虑新建出来的栈长什么样：$stack=\{1,...,st[k-1],lca,u\}$。

所以我们需要$lca$、$st[k]$、$st[k+1]$、…、$st[top]$连起来并弹出栈。

然后再将$lca$和$u$入栈。

最后$insert$完所有点后，我们将栈中剩下的点连起来并清空栈。

为什么要按$dfn$排序？因为按$dfn$排序后，对于相邻的两个关键节点$a$、$b$，$lca(a,b)$一定比$a$和其它点的$lca$深度深，这样能保证建的点和边不重不漏。

然后看代码：

```cpp
void insert(int u)
{
    if(top==1)//特判top=1
    {
        if(st[top]!=u)st[++top]=u;//特判u=1
        return;
    }
    int lca=LCA(u,st[top]);
    for(;top>1&&dfn[st[top-1]]>=dfn[lca];top--)//建边，因为stack中存的是一条链，所以dfn[st[top-1]]>=dfn[lca]其实和deep[st[top-1]]>=deep[lca]是等价的
        add_edge(st[top-1],st[top]);
    //做完上面这段循环后，能保证dfn[st[top-1]]<dfn[lca]<=dfn[st[top]]
    if(st[top]!=lca)//判断一下，防止自环
    {
        add_edge(lca,st[top]);
        st[top]=lca;
    }
    st[++top]=u;
}
```

不理解？来看图模拟一下：

![在这里插入图片描述](https://img-blog.csdnimg.cn/2019113011293844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2V6X2xjdw==,size_16,color_FFFFFF,t_70)

不妨设现在$k=5$，关键节点为$4$、$7$、$9$、$10$、$13$（已标红），$stack=\{1\}$。

然后我们要先$insert(4)$，发现$top=1$，于是$stack=\{1,4\}$。

然后$insert(7)$，发现$lca(7,4)=1$，于是建边$(1,4)$，$stack=\{1,7\}$。

然后$insert(9)$，发现$lca(7,9)=6$，于是建边$(6,7)$，$stack=\{1,6,9\}$。

然后$insert(10)$，发现$lca(9,10)=9$，于是$stack=\{1,6,9,10\}$。

然后$insert(13)$，发现$lca(10,13)=8$，于是建边$(9,10)$、$(8,9)$，$stack=\{1,6,8,13\}$。

最后将栈清空：建边$(8,13)$、$(6,8)$、$(1,6)$，$stack=\{\}$。

所以建出来的虚树长这个样：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191130113626729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2V6X2xjdw==,size_16,color_FFFFFF,t_70)

~~现在应该理解了吧~~

然后我们可以做一点小优化：若关键节点$a$是关键节点$b$的祖先，那么显然只要让$a$和根断掉，$b$就绝对会和根断掉，所以我们可以忽略$b$。

## 3.怎么dp？

不妨设$minn[u]$为原树中从根节点到$u$路径上的边权最小值，$dp[u]$为把以$u$根节点的子树中的所有关键节点都与根节点切断的最小代价。

那么要么是在$u$的子树中就切断，或者自己切断：

$$dp[u]=min(\sum_{v=son[u]}dp[v],minn[u])$$

那么直接树形$dp$就好了。

代码如下：

```cpp
#include<bits/stdc++.h>
 
#define LN 18
#define N 250010
#define ll long long
#define INF 0x7fffffffffffffff
 
using namespace std;
 
struct Tree
{
    int cnt,head[N],nxt[N<<1],to[N<<1],w[N<<1];
    void init()
    {
        cnt=0;
        memset(head,0,sizeof(head));
    }
    void adde(int u,int v,int c=0)
    {
        to[++cnt]=v;
        w[cnt]=c;
        nxt[cnt]=head[u];
        head[u]=cnt;
    }
}e1,e2;
 
int n,m,idx;
int top,st[N];
int a[N];
int d[N],dfn[N],fa[N][LN];
ll minn[N],dp[N];
 
void dfs(int u)
{
    dfn[u]=++idx;
    for(int i=1;i<=17;i++)
        fa[u][i]=fa[fa[u][i-1]][i-1];
    for(int i=e1.head[u];i;i=e1.nxt[i])
    {
        int v=e1.to[i];
        if(v!=fa[u][0])
        {
            fa[v][0]=u;
            d[v]=d[u]+1;
            minn[v]=min(minn[u],(ll)e1.w[i]);
            dfs(v);
        }
    }
}
 
int LCA(int a,int b)
{
    if(d[a]<d[b])swap(a,b);
    for(int i=17;i>=0;i--)
        if(d[fa[a][i]]>=d[b])
            a=fa[a][i];
    if(a==b)
        return a;
    for(int i=17;i>=0;i--)
        if(fa[a][i]!=fa[b][i])
            a=fa[a][i],b=fa[b][i];
    return fa[a][0];
}
 
bool cmp(int a,int b)
{
    return dfn[a]<dfn[b];
}
 
void insert(int u)
{
    if(top==1)
    {
        if(u!=1)st[++top]=u;
        return;
    }
    int lca=LCA(u,st[top]);
    if(lca==st[top])
        return;
    for(;top>1&&dfn[st[top-1]]>=dfn[lca];top--)
        e2.adde(st[top-1],st[top]);
    if(st[top]!=lca)
    {
        e2.adde(lca,st[top]);
        st[top]=lca;
    }
    st[++top]=u;
}
 
void dfs2(int u)
{
    if(!e2.head[u])
    {
        dp[u]=minn[u];
        return;
    }
    dp[u]=0ll;
    for(int i=e2.head[u];i;i=e2.nxt[i])
    {
        int v=e2.to[i];
        dfs2(v);
        dp[u]+=dp[v];
    }
    dp[u]=min(dp[u],minn[u]);
    e2.head[u]=0;
}
 
int main()
{
    scanf("%d",&n);
    for(int i=1;i<n;i++)
    {
        int u,v,w;
        scanf("%d%d%d",&u,&v,&w);
        e1.adde(u,v,w),e1.adde(v,u,w);
    }
    d[1]=1,minn[1]=INF;
    dfs(1);
    scanf("%d",&m);
    while(m--)
    {
        int k;
        scanf("%d",&k);
        for(int i=1;i<=k;i++)
            scanf("%d",&a[i]);
        sort(a+1,a+k+1,cmp);
        e2.cnt=0;
        st[top=1]=1;
        for(int i=1;i<=k;i++)
            insert(a[i]);
        for(;top>1;top--)
            e2.adde(st[top-1],st[top]);
        dfs2(1);
        printf("%lld\n",dp[1]);
    }
    return 0;
}
```

---

## 作者：xyz32768 (赞：9)

看到题目的条件，容易想到是一道树形DP题，设$f[u]$为让$u$不能到达$u$的子树内（不包括$u$）的任意关键点（能源丰富的岛屿）的最小代价。如果$u$是叶子节点，那么$f[u]=0$。

转移就是枚举子节点$v$，设$val(u,v)$为边$(u,v)$的权值，则转移为：

如果$v$是关键点，那么$f[u]+=val(u,v)$。

否则$f[u]+=\min(val(u,v),f[v])$。

考虑到询问次数较大，但给出关键点的总数很少，因此可以构建出一个**虚树**。注意把$1$号节点加入关键点。

如果对虚树不了解，可参考神犇zzq的博客：https://www.cnblogs.com/zzqsblog/p/5560645.html

构建完虚树后，就可以在虚树上DP了。注意虚树上一条边的边权为原树上这两点的路径上边权的最小值。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
typedef long long ll;
const int N = 25e4 + 5, LogN = 23, INF = 0x3f3f3f3f;
int n, m, ecnt, nxt[N << 1], adj[N], go[N << 1], val[N << 1], dep[N], dfn[N],
times, top, stk[N], fa[N][LogN], mv[N][LogN], vir[N], vn, par[N], vi[N], tm,
yy[N]; ll ans[N]; bool isvir[N];
void add_edge(int u, int v, int w) {
    nxt[++ecnt] = adj[u]; adj[u] = ecnt; go[ecnt] = v; val[ecnt] = w;
    nxt[++ecnt] = adj[v]; adj[v] = ecnt; go[ecnt] = u; val[ecnt] = w;
}
void dfs(int u, int fu) {
    int i; fa[u][0] = fu; dep[u] = dep[fu] + 1;
    for (i = 0; i <= 19; i++)
        fa[u][i + 1] = fa[fa[u][i]][i],
        mv[u][i + 1] = min(mv[u][i], mv[fa[u][i]][i]);
    dfn[u] = ++times;
    for (int e = adj[u], v; e; e = nxt[e])
        if ((v = go[e]) != fu)
            mv[v][0] = val[e], dfs(v, u);
}
int lca(int u, int v) {
    int i; if (dep[u] < dep[v]) swap(u, v);
    for (i = 20; i >= 0; i--) {
        if (dep[fa[u][i]] >= dep[v]) u = fa[u][i];
        if (u == v) return u;
    }
    for (i = 20; i >= 0; i--)
        if (fa[u][i] != fa[v][i])
            u = fa[u][i], v = fa[v][i];
    return fa[u][0];
}
int dis(int u, int v) {
    int i, ans = INF;
    for (i = 20; i >= 0; i--) {
        if (dep[fa[u][i]] >= dep[v])
            ans = min(ans, mv[u][i]), u = fa[u][i];
        if (u == v) return ans;
    }
    return ans;
}
bool comp(int u, int v) {
    return dfn[u] < dfn[v];
}
void build() {
    int i, tmp = vn; top = 0;
    sort(vir + 1, vir + vn + 1, comp);
    for (i = 1; i <= tmp; i++) {
        int u = vir[i];
        if (!top) {
            par[u] = 0;
            stk[++top] = u;
            continue;
        }
        int w = lca(stk[top], u);
        while (dep[stk[top]] > dep[w]) {
            if (dep[stk[top - 1]] < dep[w]) par[stk[top]] = w;
            top--;
        }
        if (w != stk[top]) {
            vir[++vn] = w;
            par[w] = stk[top];
            stk[++top] = w;
        }
        par[u] = w; stk[++top] = u;
    }
    sort(vir + 1, vir + vn + 1, comp);
}
void DP() {
    int i; for (i = 1; i <= vn; i++) ans[vir[i]] = 0;
    for (i = vn; i >= 2; i--) {
        int u = vir[i];
        if (isvir[u]) ans[par[u]] += 1ll * vi[u];
        else ans[par[u]] += min(1ll * vi[u], ans[u]);
    }
}
ll solve() {
    int i; for (i = 2; i <= vn; i++)
        vi[vir[i]] = dis(vir[i], par[vir[i]]);
    return DP(), ans[1];
}
int main() {
    int i, x, y, z; n = read();
    for (i = 1; i < n; i++) {
        x = read(); y = read(); z = read();
        add_edge(x, y, z);
    }
    dfs(1, 0); m = read(); while (m--) {
        vn = read() + 1; vir[1] = 1; tm = vn - 1;
        for (i = 2; i <= vn; i++) vir[i] = yy[i - 1] = read(),
            isvir[vir[i]] = 1; build();
        printf("%lld\n", solve());
        for (i = 1; i <= tm; i++) isvir[yy[i]] = 0;
    }
    return 0;
}
```

---

## 作者：wzj423 (赞：9)

### 说在前面的话
其实这道题作为虚树的入门题有很多坑点，主要是由于这道题的dp有一些特殊的性质，使得许多julao在正常的虚树构建过程之外删改了一些（似乎是奇怪的优化？）像我这种渣渣当然只会把虚树完整地建出来再暴力dp啊，轻轻松松倒数rank1呢。
### 为什么要建虚树？
似乎大家都知道了
### 怎么建虚树？
#### 原理：利用栈和树的关系，结合dfs序还原出一棵树来
#### 实现：
##### 1. 清空图

```cpp
New.clear();
这里New是虚树所在的图结构体的名字，清除时不能暴力memset，否则复杂度会退化
```
##### 2.读入&预处理
```cpp
for(int i=1;i<=K;++i) {
    scanf("%d",seq+i);
    New.import[seq[i]]=true;
    //标记哪些点真正重要（是题目里要切断的点）
}
    sort(seq+1,seq+K+1,cmp);   //按照dfs序排序
    top=0;清空栈
    stk[++top]=1;   //因为1号根节点肯定要插入，所以预先插入
```
##### 3.用栈建出虚树
预先说明：
	G是原图，在原图G上求LCA，G.minval(u,v)表示u到v的路径上的最小值。
    因为虚树上两点的边权一定是原图路径上的最小值（在这道题目里）
```cpp
for(int i=1;i<=K;++i) {
    int now=seq[i],f=G.lca(now,stk[top]);
    /*
    现在dfs栈里面存储了一条dfs链，
    下一个节点可能延续了这一条链，也有可能跳出这条链再造新链，
    对于链上点之间边的连接要等到跳出这条链时再进行，以防出现不该有的分叉。
    另注，这里加的是单向边，注意加边按u->v顺序
    另外，这样的加边过程还有疏漏，所以要对于自环、和零节点有关的边要特判掉
    */
    while(true) {
        if(G.depth[f]>=G.depth[stk[top-1]]) {
        //这是最为关键的一个判断，也就是当一条链要“拐弯”到另一条链上的操作
        //链上接续的是一种特殊情况（拐弯到自己）
        //之前提到的加边过程的疏漏是为了简化这里的代码（不，是因为我菜）
            New.addEdge(f,stk[top],G.minval(f,stk[top]));
            //现在有这样的情况
            /*
            	stk[top-1]
                 /
                f
               / \
              /  now
              stk[top]
            */
            /*
            	那么，我们要先建出f->stk[top]的那条边，
                再回撤到stk[top-1]->f->now的那条链上
                注意可能有以下情况
            	
                f==stk[top-1]
               / \
              /  now
              stk[top]
              	所以要特判
            */
            --top;
            if(stk[top]!=f) stk[++top]=f;
            break;
    	}
    New.addEdge(stk[top-1],stk[top],G.minval(stk[top-1],stk[top]));--top;
    /*
    这一行代码的作用是回退，
    也就是说，当上面的判断不成立，新加入的元素不能直接加在dfs链的末尾时，
    就要不断回退，同时建出这一条链上边。
    */
    }
    if(stk[top]!=now) stk[++top]=now;
    //将新元素加入dfs链的末尾
}
while(--top) New.addEdge(stk[top],stk[top+1],G.minval(stk[top],stk[top+1]));
//处理最后栈中的那一条dfs链
```
### 这样，虚树就建完了！
```cpp
#include <bits/stdc++.h>
#define ll long long
const int MAXN=3e5;
const ll INF=1e17;
using namespace std;
//defs================================================
int N,M,K;

//edge================================================
struct edge {
	int ed,nxt,vv;
};
struct _Graph{
	bool _dbg;
    int head[MAXN],Ecnt;
	edge E[MAXN*3];
	int fa[MAXN][20],depth[MAXN],dfn[MAXN],dfsid;
	ll minv[MAXN][20],edf[MAXN];//父边
	int import[MAXN];//是否重要
    map<int,int> inseq;//虚树上点的合集
    ll f[MAXN];
	_Graph() {
        memset(minv,0x3f,sizeof minv);
        depth[1]=1;
        edf[1]=INF;
	}
    void addEdge(int st,int ed,int vv) {
    	if(st==ed||!st||!ed) return;
    	if(_dbg) {
			printf("add %d->%d vv=%d\n",st,ed,vv);
    	}
    	++inseq[st],++inseq[ed];
		E[++Ecnt].ed=ed,E[Ecnt].nxt=head[st],head[st]=Ecnt;
		E[Ecnt].vv=vv;
    }

	void dfs(int st) {
		dfn[st]=++dfsid;
		for(int i=1;i<=20;++i) {
			if(fa[ fa[st][i-1] ][i-1]) {
				fa[st][i]=fa[ fa[st][i-1] ][i-1];
				minv[st][i]=min(minv[st][i-1],minv[ fa[st][i-1] ][i-1]);
			}
		}
        for(int i=head[st];i;i=E[i].nxt) {
			int ed=E[i].ed,vv=E[i].vv;
			if(ed!=fa[st][0]) {
                fa[ed][0]=st;depth[ed]=depth[st]+1;
                edf[ed]=minv[ed][0]=vv;
                dfs(ed);
			}
        }
	}
	int lca(int x,int y) {
		if(depth[x]<depth[y]) swap(x,y);
		for(int i=19;i>=0;--i) if(depth[fa[x][i]]>=depth[y]) x=fa[x][i];
		for(int i=19;i>=0;--i) if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];
		if(x==y) return x;
		else    return fa[x][0];
	}
	ll minval(int x,int y) {
        ll ret=INF;
		if(depth[x]<depth[y]) swap(x,y);
		for(int i=19;i>=0;--i)
			if(depth[fa[x][i]]>=depth[y]) {
				ret=min(ret,minv[x][i]);
				x=fa[x][i];
		}
		for(int i=19;i>=0;--i)
			if(fa[x][i]!=fa[y][i]) {
				ret=min(ret,minv[x][i]);
				ret=min(ret,minv[y][i]);
				x=fa[x][i],y=fa[y][i];
			}
		if(x!=y) {
            ret=min(ret,minv[x][0]),ret=min(ret,minv[y][0]);
		}
		return ret;
	}
	void clear() {
        Ecnt=0;
        map<int,int>::iterator it=inseq.begin();
        for(;it!=inseq.end();++it) {
			int t=it->first;
			head[t]=f[t]=import[t]=0;
			edf[t]=INF;
			//printf("erased %d\n",t);
        }
        inseq.clear();
	}
    ll dp(int x=1) {
    	//printf("dp in %d\n",x);
        if(import[x]) {
			//printf("%d ret=%d\n",x,edf[x]);
			return edf[x];
		}
        ll sum=0;
        for(int i=head[x];i;i=E[i].nxt) {
			int ed=E[i].ed,vv=E[i].vv;
			edf[ed]=vv;
            sum+=dp(ed);
        }
        //printf("%d ret=%d\n",x,min(edf[x],sum));
        return min((ll)edf[x],sum);
    }
}G,New;
//virtual tree=========================================
int stk[MAXN],top;
int seq[MAXN];
bool cmp(int x,int y) {
    return G.dfn[x]<G.dfn[y];
}
//main================================================
int main() {
	//New._dbg=true;
	freopen("E:/lydsy/2286/6.in","r",stdin);
	freopen("E:/lydsy/2286/my.out","w",stdout);

	scanf("%d",&N);
    for(int i=1;i<N;++i) {
		int x,y,v;
		scanf("%d%d%d",&x,&y,&v);
		G.addEdge(x,y,v),G.addEdge(y,x,v);
    }
    G.dfs(1);
	scanf("%d",&M);
	while(M--) {
		New.clear();
        scanf("%d",&K);
        for(int i=1;i<=K;++i) {
			scanf("%d",seq+i);
			New.import[seq[i]]=true;
        }
        sort(seq+1,seq+K+1,cmp);
        top=0;
        stk[++top]=1;
        for(int i=1;i<=K;++i) {
            int now=seq[i],f=G.lca(now,stk[top]);
            while(true) {
				if(G.depth[f]>=G.depth[stk[top-1]]) {
                    New.addEdge(f,stk[top],G.minval(f,stk[top]));
                    --top;
                    if(stk[top]!=f) stk[++top]=f;
                    break;
				}
                New.addEdge(stk[top-1],stk[top],G.minval(stk[top-1],stk[top]));--top;
            }
            if(stk[top]!=now) stk[++top]=now;
        }
        while(--top) New.addEdge(stk[top],stk[top+1],G.minval(stk[top],stk[top+1]));
        cout<<New.dp(1)<<endl;
	}
	return 0;
}

```

---

## 作者：zhenglier (赞：8)

#虚树dp

虚树的主要思想：

- 不遍历没用的的节点以及没用的子树，从而使复杂度降低到$\sum\limits k$(k为询问的节点的总数)。

所以怎么办：

- 只把询问节点和其LCA放入询问的数组中。
## 1、建虚树

```cpp
q.clear();
int m;
scanf("%d",&m);
for(int i=1;i<=m;++i){
    int x;
    scanf("%d",&x);
    v[x]=1;
    q.push_back(x);
}
sort(q.begin(),q.end(),cmp);
for(int i=0;i<m-1;++i){
    q.push_back(LCA(q[i],q[i+1]));
}
q.push_back(1);
sort(q.begin(),q.end());
q.erase(unique(q.begin(),q.end()),q.end());
sort(q.begin(),q.end(),cmp);
```

q是一个vector，我们开始先对所有节点按欧拉序（即**深度优先搜索是访问的顺序**）排序，然后对每两个相邻的节点将LCA放入q中（**可知这样一定会将所有有效节点放入q中**）。然后一波去重，再按欧拉序排序即可。

~~如果你还不会LCA的话请到[这里](https://www.luogu.org/problemnew/show/P3379)~~

## 2.遍历虚树

然后我们得到了一个遍历表，向深度优先搜索一样搜一遍即可。

这里要注意每个节点x只有当他下一个节点y是他的子节点时（即$dfn[x]+size[x]>=dfn[y]$时，其中$dfn$为欧拉序，$size$为子树大小）才访问下一个节点，并用下一个点的信息更新当前节点。

对于两点间的最短树边，我们可以用倍增来寻找（当然也可以用st表$O(1)$求，但这题并不要求）。

```cpp
long long getmin(int x,int lca){
    int ret=1e18;
    for(int i=t-1;~i;--i){
        if(dep[x]-(1<<i)>=dep[lca]){
            ret=min(ret,c[x][i]);
            x=fa[x][i];
	}
    }
    return ret;
}

```

## 3.树型DP

对于每个节点，如果他一定要被割掉，则当前点的最小花费为**当前点到父亲节点的最小树边**，否则为**所有子节点的最小花费和**和**当前点到父亲节点的最小树边**的最小值。

```cpp
void dfs1(){
	int x=q[it];
	long long ret=0;
	while(1){
		if(it+1==q.size())break;
	    if(dfn[q[it+1]]<=dfn[x]+sz[x]-1){
	         int y=q[++it];
	         if(v[y]==1){
	         	 dfs1();
			     dp[y]=getmin(y,x);
			 }
	         else dp[y]=1e18,dfs1(),dp[y]=min(dp[y],getmin(y,x));
			 ret+=dp[y];
		}else break;
	}
	if(ret)dp[x]=min(dp[x],ret);
}
```

代码中的it为当前访问到的节点在q中的编号

然后就可以写出代码了,需要注意一些初始化的细节：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=600010,t=20;
int n;
int tot,bian[N<<1],nxt[N<<1],zhi[N<<1],head[N];
void add(int x,int y,int z){
    tot++,bian[tot]=y,zhi[tot]=z,nxt[tot]=head[x],head[x]=tot;
}
int dfn[N],cnt;
int fa[N][t],c[N][t],dep[N],sz[N];
vector<int>q;
bool cmp(int x,int y){
    return dfn[x]<dfn[y];
}
void dfs(int x,int f){
	sz[x]=1;
    dfn[x]=++cnt;
    dep[x]=dep[f]+1;
    fa[x][0]=f;
    for(int i=1;i<t;++i){
        fa[x][i]=fa[fa[x][i-1]][i-1];
        c[x][i]=min(c[x][i-1],c[fa[x][i-1]][i-1]);
	}
	for(int i=head[x];i;i=nxt[i]){
	    int y=bian[i];
	    if(y==f)continue;
	    c[y][0]=zhi[i];
	    dfs(y,x);
	    sz[x]+=sz[y];
	}
}
int LCA(int x,int y){
    if(dep[x]<dep[y])swap(x,y);
    for(int i=t-1;~i;--i){
        if(dep[x]-(1<<i)>=dep[y]){
            x=fa[x][i];
		}
	}
	if(x==y)return x;
	for(int i=t-1;~i;--i){
	    if(fa[x][i]!=fa[y][i]){
	    	x=fa[x][i],y=fa[y][i];
		}
	}
	return fa[x][0];
}
long long getmin(int x,int lca){
    int ret=1e18;
    for(int i=t-1;~i;--i){
        if(dep[x]-(1<<i)>=dep[lca]){
            ret=min(ret,c[x][i]);
            x=fa[x][i];
		}
	}
	return ret;
}
#define IT vector<int>::iterator
long long dp[N];
int it,v[N];
void dfs1(){
	int x=q[it];
	long long ret=0;
	while(1){
		if(it+1==q.size())break;
	    if(dfn[q[it+1]]<=dfn[x]+sz[x]-1){
	         int y=q[++it];
	         if(v[y]==1){
	         	 dfs1();
			     dp[y]=getmin(y,x);
			 }
	         else dp[y]=1e18,dfs1(),dp[y]=min(dp[y],getmin(y,x));
			 ret+=dp[y];
		}else break;
	}
	if(ret)dp[x]=min(dp[x],ret);
}
int main(){
	dfn[0]=1e9;
    cin>>n;
    for(int i=1;i<n;++i){
        int x,y,z;
        scanf("%d%d%d",&x,&y,&z);
        add(x,y,z);
        add(y,x,z);
	}
	dfs(1,0);
	int T;
	cin>>T;
	while(T--){
		q.clear();
		int m;
		scanf("%d",&m);
		for(int i=1;i<=m;++i){
		    int x;
		    scanf("%d",&x);
		    v[x]=1;
		    q.push_back(x);
		}
		sort(q.begin(),q.end(),cmp);
		for(int i=0;i<m-1;++i){
		    q.push_back(LCA(q[i],q[i+1]));
		}
		q.push_back(1);
		sort(q.begin(),q.end());
		q.erase(unique(q.begin(),q.end()),q.end());
		sort(q.begin(),q.end(),cmp);
		m=q.size();it=0;
		dp[q[0]]=1e18;
		dfs1();
		for(int i=0;i<m;++i){
		    v[q[i]]=0;
		}
		printf("%lld\n",dp[*q.begin()]);
	}
}
```


---

## 作者：kczno1 (赞：7)

新学虚树。

先看看对单个询问怎么做。

有个很巧妙的做法，预处理出根到每个点的路径上的min边权w[i]。

dp[i]表示以i为根的答案，只有两种情况:1 w[i] 2 dp[儿子]的和

（当然，还要考虑i是不是选中点等，自己思考吧）

这题询问很多，显然每次询问我们必须用跟k相关的时间解决，而不能跟n相关。

所以我们要建一个虚树，只包含那k个点和他们的lca。直接在这棵树上dp即可。

怎么建虚树?

首先把点按dfs序排序，从小到大插入。

之后一直用栈维护最后的一条树链，每加入一个点now，求出now和最后一个点pre的lca。

如果lca就是pre，那么将now入栈，退出。

否则lca就是pre的爸爸，那么如果lca是倒数第二个点fx的儿子，将pre出栈，lca和now入栈，退出。

否则将pre出栈，lca作为pre递归处理。

(在此过程中要建边，自己思考)

（此代码在bzoj上拿了rank1,并超过rank2 500ms）

upd:今天突然想到，如果离线读进来每组询问的点，由于dfn序的值域是1-n的，我们可以把点按dfs序先插到值域的数组里，记录所属询问编号。

之后再遍历一遍把他们插回询问里。这样排序时间就从O(NlogN)变成O(N)了。

我们也可以离线用tarjan将求lca的时间优化到O(N)。

那么我们就可以O(n)建虚树了。这题也就可以O(N)了。

然而我加了第一个排序的优化后反而变慢了。。应该是数据问题吧。。(而且我还发现我的rank1没了)

```cpp
#include<bits/stdc++.h>
using namespace std;

#define ch_top 20000000
char ch[ch_top],*now_r=ch;
void read(int &x)
{
    while (*now_r<48) ++now_r;
    for (x=*now_r-48;*++now_r>=48;)
     x=(x<<1)+(x<<3)+*now_r-48;
}

#define ll long long 
ll min(ll &x,ll &y) 
{
 return x<y?x:y;
}
void chmin(int &x,int y)
{
    if (x>y) x=y;
}
#define N 250100
int n,x,y,w;
int t[N];
struct edge
{
    int to,w,next;
}l[N<<1];int e;
void add_e(int x,int y,int w) 
{
  l[++e]={y,w,t[x]};t[x]=e;
}
void _add(int x,int y) 
{
 l[y].next=t[x];t[x]=y;
}

struct tree
{
    int f,deep,sz,top,c;
    int dfn,w;//dfs序；到根的min边权 
}T[N];

void dfs(int x,int deep,int f,int w)
{
    T[x].sz=1;T[x].deep=deep;T[x].f=f;T[x].w=w;
    ++deep;
    int i,y,c=0;
    for (i=t[x];i;i=l[i].next)
    if ((y=l[i].to)!=f)
    {
        dfs(y,deep,x,min(w,l[i].w));
        T[x].sz+=T[y].sz;
        if (T[y].sz>T[c].sz) c=y;
    }
    T[x].c=c;
}

int i,j,len;

int tot;
void dfs2(int x,int top)
{
    T[x].dfn=++tot;
    T[x].top=top;
    int c=T[x].c;
    if (!c) return;
    dfs2(c,top);

    int i,y;
    for (i=t[x];i;i=l[i].next)
    if ((y=l[i].to)!=T[x].f&&y!=c)
     dfs2(y,y);
}

int q[N],k;
bool dfn_xiao(int x,int y)
{
    return T[x].dfn<T[y].dfn;
}

int fx,fy;
int get_lca(int x,int y)
{
    fx=T[x].top;fy=T[y].top;
    while (fx!=fy)
    if (T[fx].deep>T[fy].deep) {x=T[fx].f;fx=T[x].top;}
    else {y=T[fy].f;fy=T[y].top;}
    return T[x].deep<T[y].deep?x:y;
}

int st[N],top,pre,lca;
int have[N],num;
void push(int now)
{
    pre=st[top];
    if (pre==1) {st[++top]=now;return;}

    lca=get_lca(now,pre);if (lca==pre) return ;//剪枝
    while (lca!=pre)
    {
        fx=st[--top];
        if (T[fx].dfn<T[lca].dfn) 
        {
         _add(lca,pre);
         st[++top]=lca;
         break;
        }
        _add(fx,pre);
        pre=fx; 
    }
    st[++top]=now;
} 

ll dp(int x)
{
    if (!t[x]) return T[x].w;

    ll ans=0;
    for (int i=t[x];i;i=l[i].next) 
     ans+=dp(i);
    t[x]=0;

    return min(ans,(ll)T[x].w);
}

int main()
{ freopen("1.in","r",stdin);freopen("1.out","w",stdout);
    fread(ch,1,ch_top,stdin);
    int n;
    read(n);
    for (i=1;i<n;++i)
    {
        read(x);read(y);read(w);
        add_e(x,y,w); add_e(y,x,w);
    }

    dfs(1,0,0,1<<30);
    dfs2(1,1);

    for (i=1;i<=n;++i) t[i]=0;
    int m;ll ans;
    read(m);
    while (m--)
    {
        read(k);
        for (i=1;i<=k;++i) read(q[i]);
        sort(q+1,q+k+1,dfn_xiao);

        st[top=1]=1;
        for (i=1;i<=k;++i) 
         push(q[i]);

        while (--top) _add(st[top],st[top+1]);

        ans=0;
        for (int i=t[1];i;i=l[i].next) 
          ans+=dp(i);
        t[1]=0;
        printf("%lld\n",ans);
    }
}
```

---

## 作者：妩媚的ak萝莉 (赞：4)

例：[luogu2495](https://www.luogu.org/problem/P2495)

虚树是一种把树上无用信息浓缩的想法，类似于前缀和？？一般用于只与部分点有关的树状dp，具体可以参见例题，我只需树上的询问点的它们的lca来做dp即可，可以证明每个询问点最多生成一个lca，于是复杂度不就小了

证明复杂度很简单，如果有一个点与前面的点$y$，$z$都生成了新的lca，记为$ly$,$lz$,那么$lca(y,z)$等于$ly$，$lz$中深度较小的一个，假设不成立，于是可证一棵虚树的大小最大只有关键点数量的两倍

------------

下面到最重要的地方了：**怎么构建虚树**：

构建虚树，即是把一些指定点和它们的lca从原树中抽出来。

先把关键点按dfs序排个序，然后我们就可以感性理解了：

维护一个栈，其中是所有子树中还可能产生新点的点，使从栈顶到栈底的深度是递减的（其实就是栈顶元素到根的，当前已加入虚树的点的一条链），一开始先把根丢进去。

记当前要加的关键点为$now$，栈顶为$x$，他们的$lca$为$lc$,如果$dep_{lc}=dep_{x}$，压now入栈结束，**因为我不知到now子树中还有没有新点**

如果$dep_{lc}<dep_{x}$,我就知道$x$的子树中不可能有任何新点了（别忘了关键点是按dfs序排过序），但我想知道栈里其他元素是不是也不可能了，很简单我先取出第二个栈中点$y$，一样如果$dep_{lc}<dep_{y}$,那y的子树里也不可能有新点了,那我就把x和y连起来没有任何问题，然后用y代替x继续此过程，**在过程中**：

如果出现$dep_{lc}=dep_y$即就是$lc=y$，x子树不可能y还有可能，但新点不会出现在x至y中的点（不然lca就不是lc了），那x连y，弹出x压进now，**因为不知道now子树中还有没有新点**，结束；

如果出现$dep_{lc}=dep_y$，我们先把lc加入虚树，然后连边lc与x（与前一种一样的道理），弹出x，压入now，**因为不知道now子树中还有没有新点**

做完以后别忘把栈里元素依次连接

构建过程有点抽象，一定要注意反复强调的黑体，为什么要把元素压入，为什么要弹出，这样才能理解，代码还有解释

------------

例题的树上dp方程我就直接给了（$dp[i]$表示处理完i的子树，即使i自身为关键点也不计入$dp[i]$）：

1. $dp[fa]+=len(fa,son)$ (son为关键点)
2. $dp[fa]+=min(dp[son],len(fa,son))$ (son不是关键点)

做的时候要小心不要触及原树大小的复杂度，不然。。就白做了

代码算我恢复以来打的最长的了。。。

## 例题代码：
```cpp
#include <iostream>
#include <stdio.h>
#include <algorithm>
#include <vector>
#include <string.h>
#include <stack>
using namespace std;
#define lowbit(x) (x&-x)
typedef pair<int,int> pii;
typedef long long ll;
const int N=3e5+50;
int n,m,now,dfncnt,ki;
vector<pii > gg[N],xs[N];
int dep[N],req[N],dfn[N],fa[N][20];
ll dis[N],dp[N];
bool xu[N];
stack<int> ss;
vector<int> xuf;

void dfs(int now,int pre){
	for(int a=1;a<=18;a++)
		fa[now][a]=fa[fa[now][a-1]][a-1];
	dfn[now]=++dfncnt;
	int sz=gg[now].size();
	for(int i=0;i<sz;i++)
	{
		int nex=gg[now][i].first;
		ll len=gg[now][i].second;
		if(nex==pre) continue;
		dep[nex]=dep[now]+1;
		dis[nex]=min(dis[now],len);
		fa[nex][0]=now;
		dfs(nex,now);
	}
}

int lca(int x,int y)
{
	if(dep[y]>dep[x]) swap(x,y);
	for(int a=18;a>=0;a--)
		if(dep[fa[x][a]]>=dep[y])
			x=fa[x][a];
	if(x==y) return x;
	for(int a=18;a>=0;a--)
		if(fa[x][a]!=fa[y][a]){
			x=fa[x][a];
			y=fa[y][a];
		}
	return fa[x][0];
}

bool cmp(int a,int b){
	return dfn[a]<dfn[b];
}

void addedge(int x,int y){
	if(dep[x]>dep[y]) swap(x,y);
	xs[x].push_back(make_pair(y,dis[y]));
	xs[y].push_back(make_pair(x,dis[y]));
}

void buildxs()
{
	xuf.push_back(1);
	ss.push(1);
	for(int id=1;id<=ki;id++)
	{
		int now=req[id],x=ss.top(),lc=lca(x,now);
		xuf.push_back(now);
		ss.pop();
		if(dep[lc]==dep[x]){
			ss.push(x);
			ss.push(now);
			continue;
		}//x子树未处理完，压进去处理now子树
		while(!ss.empty())//x子树已处理完，问链栈中还有没有已处理完的，如有，则连接前一个元素，更新x
		{
			int y=ss.top();
			if(dep[y]<=dep[lc]) {
				if(dep[lc]!=dep[y]){
					ss.push(lc);
					xuf.push_back(lc);
				}//如没有，则判断如果lca！=x，就压进栈里
				break;
			}
			ss.pop();
			addedge(x,y);
			x=y;
		}
		ss.push(now);
		addedge(x,lc);//结算x
	}
	if(!ss.empty())
	{
		int x=ss.top();
		ss.pop();
		while(!ss.empty())
		{
			int y=ss.top();
			ss.pop();
			addedge(x,y);
			x=y;
		}
	}
}

void Outxs(){
	for(int i=1;i<=n;i++)
	{
		int sz=xs[i].size();
		if(sz)
		cout<<i<<": ";
		for(int j=0;j<sz;j++)
		{
			cout<<xs[i][j].first<<" ";
		}
		if(sz)
		cout<<endl;
	}
}

void Init(){
	int sz=xuf.size();
	for(int i=0;i<sz;i++)
		dp[xuf[i]]=0,xs[xuf[i]].clear();
	xuf.clear();
}

void Dp(int now,int pre)
{
	int sz=xs[now].size();
	if(sz==1 && pre!=-1) return;
	for(int i=0;i<sz;i++)
	{
		int nex=xs[now][i].first;
		ll len=xs[now][i].second;
		if(nex==pre) continue;
		Dp(nex,now);
		if(xu[nex]) dp[now]+=len;
		else dp[now]+=min(len,dp[nex]);
	}
}

int main()
{
	scanf("%d",&n);
	for(int i=1;i<n;i++){
		int ui,vi,wi;
		scanf("%d%d%d",&ui,&vi,&wi);
		gg[ui].push_back(make_pair(vi,wi));
		gg[vi].push_back(make_pair(ui,wi));
	}
	scanf("%d",&m);
	dep[1]=1;
	dis[1]=99999999;
	dfs(1,-1);
	while(m--)
	{
		scanf("%d",&ki);
		for(int i=1;i<=ki;i++)
			scanf("%d",&req[i]);
		sort(req+1,req+1+ki,cmp);
		for(int id=1;id<=ki;id++) xu[req[id]]=1;
		buildxs();
		Dp(1,-1);
		printf("%lld\n",dp[1]);
		Init();
		for(int id=1;id<=ki;id++) xu[req[id]]=0;
	}
	return 0;
}
```


---

## 作者：ZlycerQan (赞：4)

/\*

    luogu P2495 [SDOI2011]消耗战

虚树+树形dp


首先对原图构建出虚树


在建图的时候处理出最小值

转移即可


小技巧

在dp的过程中可以顺便把边表清空

将边结构体封装可方便的建多张图

\*/
```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>

#define INF 1e17

const int BUF = 10000010;
char Buf[BUF], *buf = Buf;

void read (int &now)
{
    for (now = 0; !isdigit (*buf); ++ buf);
    for (; isdigit (*buf); now = now * 10 + *buf - '0', ++ buf);
}

#define Max 1000010

struct Edge
{
    int to, next, w; 
    Edge (int _x, int _y, int _z) : to (_x), next (_y), w (_z) {}
    Edge () {}
};

int N, M;
long long value[Max];
int dfn[Max], Count;
struct Graph
{
    Edge e[Max << 1];
    int C;
    Graph () { C = 0;}

    int list[Max];
    inline void Clear ()
    {
        C = 0;
    }
    inline void Add_Edge (int from, int to, int dis)
    {
        if (from == to) return ;
        e[++ C].to = to;
        e[C].next = list[from];
        list[from] = C;
        e[C].w = dis; 
    }
    inline void Add_Edge (int from, int to)
    {
        if (from == to) return ;
        e[++ C].to = to;
        e[C].next = list[from];
        list[from] = C;
    }
};

inline void swap (int &x, int &y)
{
    int now = x;
    x = y;
    y = now;
}

inline long long min (int x, long long y)
{
    return x < y ? x : y;
}

class Tree_Chain_Get
{
    private : 
        Graph G;
        int  size[Max], chain[Max], father[Max], son[Max];

    public :

        int deep[Max];

        void Dfs_1 (int now, int Father)
        {
            size[now] = 1;
            father[now] = Father;
            dfn[now] = ++ Count;
            deep[now] = deep[Father] + 1;
            for (int i = G.list[now]; i; i = G.e[i].next)
                if (G.e[i].to != Father)
                {
                    value[G.e[i].to] = min (G.e[i].w, value[now]); 
                    Dfs_1 (G.e[i].to, now);
                    size[now] += size[G.e[i].to];
                    if (size[son[now]] < size[G.e[i].to])
                       son[now] = G.e[i].to; 
                }
        }       
        
        void Dfs_2 (int now, int point)
        {
           chain[now] = point;
           if (son[now])
              Dfs_2 (son[now], point);
           else return ;
           for (int i = G.list[now]; i; i = G.e[i].next)
              if (G.e[i].to != son[now] && G.e[i].to != father[now])
                 Dfs_2 (G.e[i].to, G.e[i].to);
        }
        
        int Get_Lca (int x, int y)
        {
            for (; chain[x] != chain[y]; )
            {
                if (deep[chain[x]] < deep[chain[y]])
                    swap (x, y);
                x = father[chain[x]];
            }
            return deep[x] < deep[y] ? x : y;
        }
        
        inline void Insert_edges (const int L)
        {
            for (int i = 1, x, y, z; i <= L; ++ i)
            {
                read (x), read (y), read (z);
                G.Add_Edge (x, y, z);
                G.Add_Edge (y, x, z);
            }
            value[1] = INF;
            deep[1] = 0;
            Dfs_1 (1, 0);
            Dfs_2 (1, 1);
        }
};
Tree_Chain_Get Lca;

inline bool Comp (const int &x, const int &y)
{
    return dfn[x] < dfn[y];
}

class Virtual_Tree
{
    private : Graph T; int Stack[Max], top;
            long long dp[Max];
            int queue[Max];

    public :

        Virtual_Tree () {top = 0;}

        void Build_Tree ()
        {
            int M;
            read (M);
            for (int i = 1; i <= M; ++ i)
                read (queue[i]);
            std :: sort (queue + 1, queue + 1 + M, Comp);
            int cur = 0;
            queue[++ cur] = queue[1];
            for (int i = 2; i <= M; ++ i)
                if (Lca.Get_Lca (queue[i], queue[cur]) != queue[cur])
                    queue[++ cur] = queue[i];
            int top = 0;
            Stack[++ top] = 1;
            int __lca;
            T.Clear ();
            for (int i = 1; i <= cur; ++ i)
            {
                __lca = Lca.Get_Lca (Stack[top], queue[i]);
                for (; ; )
                {
                    if (Lca.deep[Stack[top - 1]] <= Lca.deep[__lca])
                    {
                        T.Add_Edge (__lca, Stack[top]);
                        -- top;
                        if (Stack[top] != __lca)
                            Stack[++ top] = __lca;
                        break;
                    }
                    T.Add_Edge (Stack[top - 1], Stack[top]);
                    -- top;
                }
                if (Stack[top] != queue[i])
                    Stack[++ top] = queue[i];
            }
            top --;
            for (; top; -- top)
                T.Add_Edge (Stack[top], Stack[top + 1]);
            Dp (1);
            printf ("%lld\n", dp[1]);
        }
               

        void Dp (int now)
        {
            long long res = 0; dp[now] = value[now];
            for (int i = T.list[now]; i; i = T.e[i].next)
            {
                Dp (T.e[i].to);
                res += dp[T.e[i].to];
            }
            T.list[now] = 0;
            if (!res)
                dp[now] = value[now];
            else if (res < dp[now])
                dp[now] = res;
        }

        void Doing (const int &K)
        {
            for (int i = 1; i <= K; ++ i)
                Build_Tree ();
        }
};

Virtual_Tree V_T;

int Main ()
{
    fread (buf, 1, BUF, stdin);
    read (N);

    Lca.Insert_edges (N - 1);
    int K;
    read (K);
    V_T.Doing (K);

    return 0;
}
int ZlycerQan = Main ();
int main (int argc, char *argv[]){;}
```

---

## 作者：Prean (赞：3)

声明：这是给练习虚树的人写的题解，不是给学习虚树的人写的题解qwq
# 题目大意
给一棵树，有边权，求让所有指定点都与 $ 1 $ 号节点不联通的最小代价，多次询问。

首先我们先想想假如是单次询问该怎么做。

很简单的树形 $ \rm DP $：

$
dp[u]=\sum_{v \in \text {u son}}
\begin{Bmatrix}
val \text{（vis[v] = true）}\\
\min(dp[v],val)
\end{Bmatrix}
$

~~因为不会写 $ \LaTeX $ 就这么将就看吧。。。~~

其中 $ val $ 是边权， $ vis[u] $ 表示 $ u $ 是否为指定的点。

显然每次复杂度是 $ O(n) $，总复杂度是 $ O(nm) $。

但是每一次并不需要所有的点，只需要一些特定的点就行了，于是有了虚树，也就是只有指定的点和一些重要的点（如 $ \rm LCA $）。

构建虚树就不说了，因为这是给来练习虚树而不是学习虚树的人写的题解qwq

这样就可以构建虚树来做这道题了，复杂度 $ O(n+(\sum k)log(\sum k)) $

自己踩过一个坑，就是每一次递归子树结束后因为 $ dp $ 值大于边权就直接返回，导致其他子树没有清空 $ head $ 数组。。。

代码：
```cpp
#include<algorithm>
#include<cstdio>
const int M=250005;
struct Edge{
    int to,val;
    Edge*nx;
}e[M<<1],*h[M],*cnt=e;
int n,q,m,tot,dis,d[M],id[M],log[M],f[M][20],len[M][20];
int top,a[M],stk[M];bool vis[M];
inline int min(const int a,const int b){
    return a>b?b:a;
}
inline bool cmp(const int u,const int v){
    return id[u]<id[v];
}
void init(int u){
    id[u]=++tot;
    d[u]=d[f[u][0]]+1;
    for(int i=1;(1<<i)<=d[u];++i){
        f[u][i]=f[f[u][i-1]][i-1];
        len[u][i]=min(len[u][i-1],len[f[u][i-1]][i-1]);
    }
    for(Edge*E=h[u];E;E=E->nx){
        int v=E->to;
        if(d[v])continue;
        f[v][0]=u;len[v][0]=E->val;
        init(v);
    }
    h[u]=NULL;
}
inline int LCA(int u,int v){
    dis=0x7fffffff;
    if(d[u]<d[v])u^=v^=u^=v;
    while(d[u]!=d[v]){
        int l=log[d[u]-d[v]];
        dis=min(dis,len[u][l]);
        u=f[u][l];
    }
    if(u==v)return u;
    for(int i=log[d[u]];i>=0;--i){
        if(f[u][i]!=f[v][i]){
            dis=min(dis,min(len[u][i],len[v][i]));
            u=f[u][i];v=f[v][i];
        }
    }
    return f[u][0];
}
long long DFS(int u,long long val){
    long long dp=0;
    for(Edge*E=h[u];E;E=E->nx){
        int v=E->to;
        dp+=min(E->val,DFS(v,E->val));
    }
    return h[u]=NULL,vis[u]?val:dp;
}
inline void Add(int u,int v,int val=0){
    if(!val)LCA(u,v),val=dis;
    *cnt=(Edge){v,val,h[u]};h[u]=cnt++;
}
inline void Insert(int u){
    if(!top)return void(stk[++top]=u);
    int v=LCA(stk[top],u);
    for(;top>1&&d[v]<d[stk[top-1]];--top)Add(stk[top-1],stk[top]);
    if(d[stk[top]]>d[v])Add(v,stk[top--]);
    if(!top||stk[top]!=v)stk[++top]=v;
    if(stk[top]!=u)stk[++top]=u;
}
signed main(){
    int i,x,y,z;
    scanf("%d",&n);log[0]=-1;
    for(i=1;i<=n;++i)log[i]=log[i>>1]+1;
    for(i=1;i<n;++i){ 
        scanf("%d%d%d",&x,&y,&z);
        Add(x,y,z);Add(y,x,z);
    }
    init(1);
    scanf("%d",&q);
    while(q--){
        cnt=e;top=0;
        scanf("%d",&m);
        for(i=1;i<=m;++i)scanf("%d",a+i),vis[a[i]]=true;
        std::sort(a+1,a+m+1,cmp);
        m=std::unique(a+1,a+m+1)-a-1;
        stk[++top]=1;
        for(i=1;i<=m;++i)Insert(a[i]);
        while(--top)Add(stk[top],stk[top+1]);
        printf("%lld\n",DFS(1,0x7fffffffffffffff));
        for(i=1;i<=m;++i)vis[a[i]]=false;
    }
}
```

---

## 作者：山水一程_ (赞：2)

```cpp
#include <iostream>
#include <cstdlib>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <ctime>
#include <vector>
#include <queue>
#include <map>
#include <set>
#ifdef WIN32
#define OT "%I64d"
#else
#define OT "%lld"
#endif
using namespace std;
typedef long long LL;
const int MAXN = 250011;
LL inf;//inf不能开小了
int n,m,ecnt,tot,id[MAXN],k;
int first[MAXN],next[MAXN*2],to[MAXN*2],w[MAXN*2];
LL val[MAXN];//这个点到根上的最小边权
int jump[MAXN][19],deep[MAXN];
int que[MAXN],top,Stack[MAXN];
int head[MAXN];
LL f[MAXN];

inline int getint() {
	int w=0,q=0;
	char c=getchar();
	while((c<'0' || c>'9') && c!='-') c=getchar();
	if (c=='-')  q=1, c=getchar();
	while (c>='0' && c<='9') w=w*10+c-'0', c=getchar();
	return q ? -w : w;
}

struct edge {
	int to,next;
} e[MAXN];

inline LL min(LL x,LL y) {
	if(x<y) return x;
	return y;
}

inline void dfs(int x,int fa) {
	jump[x][0]=fa;
	id[x]=++ecnt;//作出dfs序
	for(int i=1; i<=18; i++) jump[x][i]=jump[jump[x][i-1]][i-1];
	for(int i=first[x]; i; i=next[i]) {
		int v=to[i];
		if(v==fa) continue;
		val[v]=min(w[i],val[x]);
		deep[v]=deep[x]+1;
		dfs(v,x);
	}
}

inline bool cmp(int a,int b) {
	return id[a]<id[b];
}

inline int lca(int x,int y) {
	if(deep[x]<deep[y]) swap(x,y);
	int t=0;
	while((1<<t) <= deep[x]) t++;
	t--;
	for(int i=t; i>=0; i--) if(deep[x]-(1<<i)>=deep[y]) x=jump[x][i];
	if(x==y) return y;
	for(int i=t; i>=0; i--) if(jump[x][i]!=jump[y][i]) {
			x=jump[x][i];
			y=jump[y][i];
		}
	return jump[x][0];
}

inline void link(int x,int y) {
	if(x==y) return ;
	e[++ecnt].next=head[x];
	head[x]=ecnt;
	e[ecnt].to=y;
}

inline void dp(int x) {
	LL lin=0;
	f[x]=val[x];
	for(int i=head[x]; i; i=e[i].next) {
		dp(e[i].to);
		lin+=f[e[i].to];
	}
	head[x]=0;//退出的时候顺便清空
	if(!lin) f[x]=val[x];
	else if(lin<f[x]) f[x]=lin;
}

inline void solve() { //断绝到根结点1的路径
	m=getint();
	for(int i=1; i<=m; i++) que[i]=getint();
	sort(que+1,que+m+1,cmp);//按dfs序排序
	tot=0;
	que[++tot]=que[1];
	for(int i=2; i<=m; i++) if(lca(que[i],que[tot])!=que[tot]) que[++tot]=que[i]; //应该是和tot比较
	//在下面的肯定不用计算，只要切断上部的即可
	top=0;
	Stack[++top]=1;
	int grand;//最近公共祖先
	ecnt=0;
	for(int i=1; i<=tot; i++) { //分类讨论
		grand=lca(Stack[top],que[i]);
		while(1) {
			if(deep[Stack[top-1]]<=deep[grand]) {//分别处在两个子树，grand深度更大！！！
				link(grand,Stack[top]);
				top--;
				if(Stack[top]!=grand) Stack[++top]=grand;
				break;
			}
			link(Stack[top-1],Stack[top]);
			top--;
		}
		if(Stack[top]!=que[i]) Stack[++top]=que[i];//在同一子树
	}
	top--;
	while(top) link(Stack[top],Stack[top+1]),top--;//剩余的记得连上
	dp(1);
	printf(OT"\n",f[1]);
}

inline void work() {
	n=getint();
	int x,y,z;
	inf=1;
	for(int i=1; i<=60; i++) inf*=2;
	for(int i=1; i<n; i++) {
		x=getint();
		y=getint();
		z=getint();
		next[++ecnt]=first[x];
		first[x]=ecnt;
		to[ecnt]=y;
		w[ecnt]=z;
		next[++ecnt]=first[y];
		first[y]=ecnt;
		to[ecnt]=x;
		w[ecnt]=z;
	}
	val[1]=inf;
	ecnt=0;
	deep[1]=0;
	dfs(1,0);
	k=getint();
	for(int i=1; i<=k; i++) solve();
}

int main() {
	work();
	return 0;
}
```


---

## 作者：FriedrichC (赞：1)

# P2495 [SDOI2011] 消耗战 题解
[题目传送门](https://www.luogu.com.cn/problem/P2495)

本蒟蒻第一篇题解。

本题为虚树的模板题。
看题解区的大佬都是用手写栈的方式来实现虚树，下面提供一种使用 STL 中的 stack 实现虚树建立的形式。并且以尽量通俗易懂的方式讲解虚树的建立过程。
## 	什么是虚树
简单来说，对于一棵无根树，它的连通子图就是一棵虚树。

我们可能会碰到一类问题，问题的答案只与给定的树上的某些关键节点有关，这时候我们就需要使用虚树，仅仅维护部分关键节点，使得处理一次问题的时间复杂度下降。

那么实际上，我们通常希望建立包含关键点的**最小的**一棵虚树。
## 	怎样建立虚树
为了使得我们的虚树最小，我们就要忽略掉关键点之间的若干非关键点，但也至少要满足建立树的基本形态这一条件。

基于这样一种需求，我们不难想到寻找 $lca$ 作为关键节点之间的连接点。

并且，为了在建立虚树的过程中有序地处理节点，我们先进行一次 dfs 得到每一个节点的 dfs 序。于此同时进行一些预处理的工作。
## 	虚树的实现工具
具体来说，我们需要一个栈来维护点的队列，栈的意义是很重要的：点在栈中，说明它与它**之前的点**具有**直接的父子关系**。具体来说，前面的点是后面节点的父节点。

然后，对所有关键点按 dfs 序从小到大进行排序，就可以开始有序地处理这些关键点了。
## 	具体实现过程
首先，取出一个关键点记为 $now$，将其与栈顶元素求一个 $lca$。

如果 $lca$ 小于栈顶元素的 dfs 序，一直弹栈，直至栈顶元素 dfs 序**不小于**它。

这个过程中，会有两个加边操作：

第一，弹栈过程中，不断将**弹出元素**与栈顶元素连边。

第二，弹栈结束时(此时栈顶元素 dfs 序不小于 $lca$)，将 $lca$ 与**刚刚弹出的元素**加边。

解释一下这个操作模式：

为什么要弹栈？因为我们试图把 $lca$ 加入队列，而此时 $lca$ 的 dfs 序更小，
还记得栈的意义吗，这就表明这个 $lca$ 是栈顶元素的**父节点**，本来应该是把它插到栈顶元素**前面**的。

因此，我们不断弹栈，以便让 $lca$ 到达合适的位置。这期间，当然要不停加边，因为**本来**栈中的元素就建立了父子关系，既然要把它们弹出，就必须得加边来维护它们的关系。

弹栈结束时的加边也是同理，当 $lca$ 入栈时，它的子节点已经弹出了，得把二者加边才行。

讲完了小于的情况，其他的就很好理解了，因为我们会发现其余的情况本质上**都是弹栈结束后**出现的情况：

如果等于，说明 $lca$ 已经在栈中，不加入 $lca$。

如果大于，说明栈顶元素就是 $lca$ 的父节点，直接入栈就可以满足栈中的父子关系（当然也要如前文所述，把它与刚刚弹出的元素连边）。

**最后别忘了让 $now$ 入栈**。

重复上述操作，直至处理完所有关键点。

最后不断弹栈，同样的，相邻的点建立父子边，直至栈只留下最后一个元素，虚树就建好了。

接下来就可以以最后留下的元素为根进行 dp。
### 	小结
综上所述，这样一个建树的过程和每次加边的原则，其实说白了，就是**始终保持**栈中前后元素的父子关系成立，如果不成立，我们就要通过弹栈等操作使其成立。
## 	一些细节
假如我们默认 dfs 从$1$开始，那么在初始的栈中我们通常习惯将$1$加入栈，使初始的栈不为空。

这样做可以使得栈**永不为空**（因为$1$的 dfs 序最小），防止在处理栈中元素过程中因为栈为空导致一些操作成为未定义的**非法操作**。

需要注意的是，这样的话最后弹栈时剩下的最后一个元素就是$1$了，可以从$1$开始进行 dp。

然后再提一提手写栈与 STL 的 stack 在实现虚树上的差异：

仔细观察我们的具体建立过程，可以发现我们的加边操作需要维护两个变量，即**刚弹出的元素和栈顶元素**，如果使用 stack，那么需要两个变量，先维护前者，弹栈之后再维护后者。

而手写栈可以直接维护 $sta[top]$ 和 $sta[top-1]$ 就更为快捷简便。但是对于手写栈不熟悉的同学~~比如本蒟蒻~~，使用 stack 来实现则更为直观。

## 	在本题的应用
回到本题，我们之所以要应用虚树，是因为所要解决的问题只与能源丰富的岛屿有关，而与其他岛屿无关，并且岛屿之间的关系满足树形连接，因此我们可以把能源丰富的岛屿当做我们的关键点，用虚树来维护。

炸毁桥梁就相当于在虚树上将关键点割掉。

为了得到最小代价，我们需要在虚树上进行树形 dp 求解。对于每一次使用机器，重新维护一棵虚树即可。

我们可以在第一轮 dfs 中求出每一个点的 $minn$ 值，这个值表示割去这个点所需要的最小代价。

对于一个点 $u$，设它的子节点为 $v$，有 $minn(v)=\min(minn(u),w(u,v))$ 

$minn$ 值相当于从根到某个点的路径上的最小边权。

那么，我们有状态转移方程：
$$
dp(u) =
\begin{cases}
minn(u), & \text{如果 $u$ 是关键点} \\
\min(minn(u),\sum\limits_{v\in Son(u)} dp(v)), & \text{如果 $u$ 不是关键点}
\end{cases}
$$
## 	附上代码
```cpp
#include<bits/stdc++.h>
#define int long long
#define LINF LLONG_MAX
#define maxn 500000+10
using namespace std;
int n,m;
struct line{int to,pre,w;};
line b[2*maxn],b1[2*maxn];
int head[maxn],t,head1[maxn],t1;
int dfn[maxn],f[maxn],d[maxn],anc[maxn][33],maxlog,cnt,minn[maxn];
int a[maxn];
set<int>s;//用于标记点是否是关键点，也可以用标记数组 
stack<int>q;
inline bool cmp(const int &x,const int &y){return dfn[x]<dfn[y];}
void ad(int x,int y,int z)
{
	t++;
	b[t].to=y;
	b[t].w=z;
	b[t].pre=head[x];
	head[x]=t;
}

//加虚树边 
void ad1(int x,int y)
{
	t1++;
	b1[t1].to=y;
	b1[t1].pre=head1[x];
	head1[x]=t1;
}


void dfs(int u,int fa)
{
	dfn[u]=++cnt;
	f[u]=fa;
	d[u]=d[fa]+1;
	anc[u][0]=fa;
	for(int i=1;i<=maxlog;++i) 
	if(anc[u][i-1]!=-1)
	anc[u][i]=anc[anc[u][i-1]][i-1];
	for(int i=head[u];i;i=b[i].pre)
	{
		int v=b[i].to;
		if(v!=fa)
		{
			minn[v]=min(minn[u],b[i].w);
			dfs(v,u);
		}
	}
}


int dp(int u)
{
	int temp=0,sum=0;
	for(int i=head1[u];i;i=b1[i].pre)
	{
		int v=b1[i].to;
		sum+=dp(v);
	}
	if(s.find(u)!=s.end())temp=minn[u];
	else temp=min(minn[u],sum);
	head1[u]=0;//回溯时顺便将虚树清空 
	return temp;
}

//倍增求lca 
int getlca(int x,int y)
{
	if(d[x]<d[y])swap(x,y);
	for(int i=maxlog;i>=0;--i)
	if(d[anc[x][i]]>=d[y]) x=anc[x][i];
	if(x==y)return x;
	for(int i=maxlog;i>=0;i--)
	{
		if(anc[x][i]!=anc[y][i])
		{
			x=anc[x][i];
			y=anc[y][i];
		}
	}
	return anc[x][0];
}


signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	memset(anc,-1,sizeof(anc));
	maxlog=(int)(log(maxn)/log(2));
	minn[1]=LINF;
	cin>>n;
	for(int i=1;i<=n-1;++i)
	{
		int x,y,z;
		cin>>x>>y>>z;
		ad(x,y,z);
		ad(y,x,z);
	}
	dfs(1,0);
	cin>>m;
	while(m--)
	{
		s.clear();
		int k;
		cin>>k;
		t1=0;
		for(int i=1;i<=k;++i)cin>>a[i],s.insert(a[i]);
		sort(a+1,a+1+k,cmp);
		q.push(1);
		int u,v;
		for(int i=1;i<=k;++i)
		{
			if (a[i]==1) continue;
			int now=a[i];
			int lca=getlca(now,q.top());
			int u,v;//这里v用来存储刚弹出的元素，u用来存储栈顶元素 
			if (lca!=q.top()){
				v=q.top(); q.pop();
				while(dfn[lca]<dfn[q.top()])
				{
					u=q.top(); ad1(u,v);
					v=q.top(); q.pop();
				}
				if (lca!=q.top()){
					ad1(lca,v); q.push(lca);
				}
				else ad1(lca,v);
			}
			q.push(now);
		}
		while(1)
		{
			v=q.top(); q.pop();
			if(q.empty())break;//由于在这一步break，可以证明最后一个元素被存在了u里 
			u=q.top();
			ad1(u,v);
		}
		cout<<dp(u)<<endl;
		//cout<<u<<endl; 
		//for(int i=head1[u];i;i=b1[i].pre)cout<<b1[i].to<<" ";
		//while(!q.empty())cout<<q.top()<<" ",q.pop();
	}
	return 0;
}
```


---

## 作者：bxd1998 (赞：1)


看到大家定义状态都基本一致，本题解提供一个状态定义不同的方法。

# 知识点：虚树

## 1 解决的问题

- 对于$T$次询问，每次询问的关键点的数目为$k$，且$\sum k\le 1e6$, 如果每次询问都遍历所有的点，则会时间复杂度达到$O(TN)$，往往不能承受，虚树把时间复杂度降为$O(\sum k)$或者$O(\sum k \log( k))$

## 2 虚树的性质

- 虚树组成：保留根节点，所有的关键点和关键点的$LCA$, 其他节点删掉。
- 如果关键节点有$k$个，那么虚树的节点不会超过$2\times k$
  - 每次新加入一个点，最多只会增加一个$LCA$,
  - 设有两个点$x,y$，现在加入节点$z$,我们$lca1=LCA(x,z), lca2=LCA(y,z)$
    - 若$dep[lca1]>dep[lca2]$，那么$LCA(x,y)=lca2$
    - 若$dep[lca1]<dep[lca2]$，那么$LCA(x,y)=lca1$
    - 若$dep[lca1]=dep[lca2]$，那么$LCA(x,y)=lca1=lca2$
    - 故最多只会增加1个$LCA$, 最多只有$2k$个节点 

## 3 虚树的构建

- 如果栈为空,或者栈中只有一个元素,那么显然应该$stk[top++]=u,$
- 取$lca=LCA(u,stk[top - 1])$,如果$lca=stk[top - 1]$,则说明$u$点应该接着$stk[top - 1]$点延长当前的树链, 做操作$stk[top++] = u$
- 如果$lca\not = stk[top]$,则说明$u$与$stk[top - 1] $分属$lca$的两颗不同的子树, 且包含$stk[top  -1]$的这颗子树应该已经构建完成了,我们需要做的是:将$lca$的包含$stk[top - 1]$子树的那部分退栈,并将这部分建边形成虚树.如果$lca$不在栈(树链)中,那么要把$lca$也加入栈中,保证虚树的结构不出现问题,随后将$u$加入栈中,以表延长树链.

## 4 题目分析
* 如果每次询问都对n个点进行dp，则会造成复杂度爆炸，看到条件$\sum k \le 5e5$, 所以采用虚树
* 其他题解定义的状态为$dp(x)$表示以$x$为根的子树内，关键节点和点1断开的最小代价，本题解定义的状态$dp(x)$表示，以$x$为根的子树内，关键节点和点$x$断开的最小代价
* 定义$D$为关键节点的集合，状态转移方程：
$$
dp(x) = \sum_{j \in son(x)} l(x, j)
$$
$$
l(x, j) = \left\{
\begin{matrix}
Edge(x,j), x\in D\\
min(Edge(x,j), dp(j))), x \not \in D
\end{matrix}
\right.
$$
* 关键再去如何求这个$Edge(x,j)$，由于在虚树构建的过程中，会进行缩边，我们取$Edge(x,j)$为从$x$到$j$的路径上边的最小值，这里采用树上倍增维护最小值, $Edge(x,j) = Enquiry(x, j)$
  ```cpp
  int Enquiry(int u, int pa){
      int ret = INF;
      int deltaDep = Dep[u] - Dep[pa];
      for(int i = 0; i <= MAXH; ++i){
          if((1 << i)&deltaDep){
              ret = min(ret, valMin[u][i]);
              //cout << u <<" ... " << i << valMin[u][i] << endl;
              u = Pa[u][i];
          }
      }
      return ret;
  }
  ```
* 完整代码：
  ```cpp
  #include <cstdio>
    #include <cmath>
    #include <cstring>
    #include <iostream>
    #include <algorithm>
    using namespace std;
    const int MAXN = 250005;
    const int MAXE = 2500005;
    const int INF = 0x3f3f3f3f;
    int MAXH = 0;
    struct Arcnode {
      int u, v, w;
      int next;
    }Arcs[MAXE];
    int Head[2][MAXN], aTop = -1;
    int myStack[MAXN], sTop = 0;
    int Mark[MAXN], QNode[MAXN];
    int Dep[MAXN], Pa[MAXN][20], valMin[MAXN][20], Dfn[MAXN], Idx = 0;
    void Init() { 
        memset(Head, -1, sizeof(Head));
        aTop = -1; 
        return;
    }
    void Insert(int u, int v, int w, int flag = 0) {
      Arcs[++aTop].u = u; Arcs[aTop].v = v; Arcs[aTop].w = w; Arcs[aTop].next = Head[flag][u]; Head[flag][u] = aTop;
      Arcs[++aTop].u = v; Arcs[aTop].v = u; Arcs[aTop].w = w; Arcs[aTop].next = Head[flag][v]; Head[flag][v] = aTop;
      return;
    }
    void Dfs(int u, int pa, int dep) {
      Dfn[u] = ++Idx;
        Pa[u][0] = pa;
      Dep[u] = dep;
      for (int i = Head[0][u]; ~i; i = Arcs[i].next) {
          if (Arcs[i].v != pa) {
                valMin[Arcs[i].v][0] = Arcs[i].w;
                Dfs(Arcs[i].v, u, dep + 1);
            }
      }
      return;
    }

    int Lca(int u, int v) {
      if (Dep[u] < Dep[v])  swap(u, v);
      int deltaDep = Dep[u] - Dep[v];
      for (int i = 0; i <= MAXH; i++) {
          if ((1 << i) & deltaDep) {
              u = Pa[u][i];
          }
      }
      if (u == v) { return u; }
      else {
          for (int i = MAXH; i >= 0; --i) {
              if (Pa[u][i] != Pa[v][i]) {
                  u = Pa[u][i];
                  v = Pa[v][i];
              }
          }
      }
      return Pa[u][0];
    }
    bool Comp(int u, int v)
    {
        return Dfn[u] < Dfn[v];
    }
    int Enquiry(int u, int pa){
      int ret = INF;
      int deltaDep = Dep[u] - Dep[pa];
      for(int i = 0; i <= MAXH; ++i){
          if((1 << i)&deltaDep){
              ret = min(ret, valMin[u][i]);
                //cout << u <<" ... " << i << valMin[u][i] << endl;
                u = Pa[u][i];
          }
      }
        return ret;
    }

    void VirInsert(int u)
    {
        //cout << "?" << u << endl;
        if(sTop == 1){
            myStack[sTop ++] = u;
            return;
        }
        //cout << "??" << endl;
        int lca = Lca(u, myStack[sTop - 1]);
        //cout << u << " , " << myStack[sTop - 1] << " = " << lca << endl;
        if(lca == myStack[sTop - 1]){
            myStack[sTop ++] = u;
            return;
        }
        //cout << "???" << endl;
        while(sTop > 1 && Dfn[lca] <= Dfn[myStack[sTop - 2]]){
            //cout << myStack[sTop - 2] << " * " << myStack[sTop - 1] << " = " << Enquiry(myStack[sTop - 1], myStack[sTop - 2]) << endl;
            Insert(myStack[sTop - 2], myStack[sTop - 1], Enquiry(myStack[sTop - 1], myStack[sTop - 2]), 1);
            --sTop;
        }
        if(lca != myStack[sTop - 1]){
            //cout << lca << " * " << myStack[sTop - 1] << " = " << Enquiry(myStack[sTop - 1], lca) << endl;
            Insert(lca, myStack[sTop - 1], Enquiry(myStack[sTop - 1], lca), 1);
            myStack[sTop - 1] = lca;
        }
        myStack[sTop ++] = u;
        return;
    }

    long long TreeDp(int u, int pa)
    {
        //cout << "!! " << u << endl;
        long long ret = 0;
        for(int i = Head[1][u]; ~i; i = Arcs[i].next){
            int v = Arcs[i].v;
            if(v != pa){
                if(Mark[v]){
                    ret += (long long)(Arcs[i].w);
                }
                else{
                    ret += min((long long)(Arcs[i].w), TreeDp(v, u));
                }
            }
        }

        return ret;
    }

    void RemoveHead(int u, int pa)
    {
        for(int i = Head[1][u]; ~i; i = Arcs[i].next){
            int v = Arcs[i].v;
            if(v != pa){
                RemoveHead(v, u);
            }
        }
        Head[1][u] = -1;
        return;
    }
    int main() {
      int N, M;
      scanf("%d", &N);
        Init();
      MAXH = log(N) / log(2) + 1;
      for (int i = 1; i < N; i++) {
            //cout << i << "#" << endl;
          int u, v, w;
          scanf("%d%d%d", &u, &v, &w);
          Insert(u, v, w);
      }
      Dfs(1, 0, 0);
        Pa[1][0] = 0;
        valMin[1][0] = INF;
      for (int i = 1; i <= MAXH; i++) {
            for (int j = 1; j <= N; j++) {
              Pa[j][i] = Pa[Pa[j][i - 1]][i - 1];
                valMin[j][i] = min(valMin[j][i - 1], valMin[Pa[j][i - 1]][i - 1]);
          }
      }
        scanf("%d", &M);
        for(int i = 1; i <= M; ++i){
            //cout << i << "*" << endl;
            int num;
            scanf("%d", &num);
            for(int j = 0; j < num; ++j){
                scanf("%d", &QNode[j]);
                //cout << QNode[j] << " ";
                Mark[QNode[j]] = 1;
            }
            //cout << endl;
            sort(QNode, QNode + num, Comp);
            sTop = 0;
            myStack[sTop ++] = 1;
            for(int j = 0; j < num; ++j){
                VirInsert(QNode[j]);
            }
            while(sTop > 1) {
                //cout << myStack[sTop - 2] << " * " << myStack[sTop - 1] << " = " << Enquiry(myStack[sTop - 1], myStack[sTop - 2]) << endl;
                Insert(myStack[sTop - 2], myStack[sTop - 1], Enquiry(myStack[sTop - 1], myStack[sTop - 2]), 1);
                sTop--;
            }
            printf("%lld\n", TreeDp(1, 0));
            RemoveHead(1, 0);
            for(int j = 0; j < num; ++j){
                Mark[QNode[j]] = 0;
            }
        }
      return 0;
    }
  ```


## Reference：
https://blog.csdn.net/weixin_37517391/article/details/82744605
https://blog.csdn.net/ouqingliang/article/details/81669281


---

## 作者：_sry (赞：0)


题目大意

若有一颗带边权的树，且每次询问$k$个节点，问$k$个节点均不与1号节点相连的最小边权。

试题分析

考虑暴力$dp$,设$dp_i$为处理好i的子树的最小边权，我们定义$val_i$为从$i$到根的最小边权，则$dp_i=min(\sum dp_v,val_i)$。

但是发现其实有一些节点是没有用的，有用的其实是$lca$。并且发现$\sum k_i  \leq 5\times 10^5$，所以就可以将树进行简化。

所以就有一个算法诞生了，虚树。我们用欧拉序建出一颗只包含有用节点的树，然后再暴力$dp$就行。
```
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<stack>
#define int long long
#include<climits>
using namespace std;
inline int read(){
    int f=1,ans=0;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){ans=ans*10+c-'0';c=getchar();}
    return f*ans;
}
const int N=500001;
struct node{
    int u,v,w,nex;
}x[N<<1];
int val[N],head[N],n,fa[N][21],deep[N],num,in[N],out[N],cnt,q;
void dfs(int f,int fath,int W){
    val[f]=min(val[fath],W);
    deep[f]=deep[fath]+1,in[f]=++num;
    fa[f][0]=fath;
    for(int i=1;(1<<i)<=deep[f];i++) fa[f][i]=fa[fa[f][i-1]][i-1];
    for(int i=head[f];i!=-1;i=x[i].nex){
        if(x[i].v==fath) continue;
        dfs(x[i].v,f,x[i].w);
    }
    out[f]=++num;
}
void add(int u,int v,int w){
    x[cnt].u=u,x[cnt].v=v,x[cnt].w=w,x[cnt].nex=head[u],head[u]=cnt++;
}
int book[N],sta[N];
bool cmp(int x,int y){
    int s1,s2;
    if(x>0) s1=in[x];else s1=out[-x];
    if(y>0) s2=in[y];else s2=out[-y];
    return s1<s2;
}
int lca(int u,int v){
    if(deep[u]<deep[v]) swap(u,v);
    for(int i=20;i>=0;i--)
        if(deep[u]-(1<<i)>=deep[v]) u=fa[u][i];
    if(u==v) return u;
    for(int i=20;i>=0;i--){
        if(fa[u][i]==fa[v][i]) continue;
        u=fa[u][i],v=fa[v][i];
    }return fa[u][0];
}
stack<int> s;
int dp[N];
signed main(){
    memset(head,-1,sizeof(head));
    n=read();val[0]=LLONG_MAX;
    for(int i=1;i<n;i++){
        int u=read(),v=read(),w=read();
        add(u,v,w),add(v,u,w);
    }q=read();
    dfs(1,0,LLONG_MAX);
    while(q--){
         int st=read();
         for(int i=1;i<=st;i++) sta[i]=read(),book[sta[i]]=1,dp[sta[i]]=val[sta[i]];
         sort(sta+1,sta+st+1,cmp);
         for(int i=1;i<st;i++){
             int Lca=lca(sta[i],sta[i+1]);
             if(!book[Lca]){book[Lca]=1;sta[++st]=Lca;}
         }
         int Now=st;
         for(int i=1;i<=Now;i++) sta[++st]=-sta[i];
         if(!book[1]) sta[++st]=1,sta[++st]=-1;
         sort(sta+1,sta+st+1,cmp);
         for(int i=1;i<=st;i++){
             if(sta[i]>0) s.push(sta[i]);
             else{
                 int f=s.top();s.pop();
                 if(f!=1){int fath=s.top();dp[fath]+=min(dp[f],val[f]);}
                 else{printf("%lld\n",dp[1]);}
                 dp[f]=book[f]=0;
             }
        }
    }
}
```

---

## 作者：lightup37 (赞：0)

本题是虚树的入门级练习题, 就讲一下虚树...?

### 题意

给定一颗树, m 次询问, 可以割断一些边, 每次询问给出$c_i$个关键点$d_{i, 1}, d_{i, 2}, \cdots d_{i, c_i}$, 求割断一些边的最小代价, 使得割断这些边后 1 号节点不与任何关键点相连.

### 解法

建立虚树并且在其上 DP. 令$c_i$表示$i$到根路径上的最小边权, 特别的, $c_1 = -\infty$. 设$f_i$表示虚树上割断$i$节点子树中所有关键点的最小代价, 有$f_i = \min\{\sum\limits_{j \in son(i)} f_j, c_i\}$

大多数神仙写虚树时都是建树的, 这里可以利用 SI 神仙的一种思路: 求出欧拉序. 我们求出欧拉序之后很明显可以直接用一个栈模拟 dfs 的过程. 我们可以把所有关键点和 dfs 序相邻的节点的 lca 维护出来. 那么很明显原树上的欧拉序大小关系在新树上还是有用的, 因此我们排一遍序就可以排出每个节点欧拉序的大小关系了就可以知道如何入栈弹栈了. 判断一个点的子节点是否已经全部被遍历了可以用欧拉序.

本题有多组询问, 很明显直接清空数组是会爆的. 这里提供一种不一样的方法(可能只用我这样的菜鸡清空数组的时候会想了 /kk): 使用时间戳. 每次要改数组的时候看时间戳相不相同来判断是不是使用以前的值, 具体可以看代码里的注释.

代码:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define f(i,x,y) for(int i=x,i##end=y;i<=i##end;++i)
#define d(i,x,y) for(int i=x,i##end=y;i>=i##end;--i)
#define ri register int
#define ll long long
#define int long long
#define il inline
#define _ 500005
namespace imt {
	int head[_], ver[_], Next[_], edge[_], tot, cnt;
	int dep[_], val[_], mn[_], in[_], out[_], fa[_][21], n, x, y, z;
	void add(int u, int v, int w) {
		ver[++tot]=v, edge[tot]=w, Next[tot]=head[u], head[u]=tot;
	} 
	void dfs(int u, int f) {
		in[u]=++cnt; fa[u][0]=f; dep[u]=dep[f]+1;
		for(int i=head[u], v, w; i; i=Next[i]) {
			v=ver[i]; w=edge[i];
			if(v==f) continue;
			mn[v]=min(mn[u], w); dfs(v, u);
		}
		out[u]=++cnt;
	}
	int lca(int x, int y) {
		if(dep[x]<dep[y]) swap(x, y);
		d(i,20,0) if(dep[fa[x][i]]>=dep[y]) x=fa[x][i];
		if(x==y) return x;
		d(i,20,0) if(fa[x][i]!=fa[y][i]) x=fa[x][i], y=fa[y][i];
		return fa[x][0];
	}
	void init() {
		scanf("%lld", &n);
		f(i,1,n-1) {
			scanf("%lld%lld%lld", &x, &y, &z);
			add(x, y, z); add(y, x, z);
		}
		mn[1] = (1LL)<<(60LL); dfs(1, 0);
		f(t,1,20) f(i,1,n) fa[i][t]=fa[fa[i][t-1]][t-1];
		print();
	} /*倍增板子, 没什么好说的*/
	stack<int> stk; // 用来模拟 dfs
	int cmp(int x, int y) {
		return ((x>0)?in[x]:out[-x])<((y>0)?in[y]:out[-y]);
	} // 用来给虚树上的欧拉序排序
	typedef pair<long long, int> arr;
	arr f[_], tag[_];
	long long gv(arr x, int tim) {
		return x.second==tim?x.first:0;
	} // 如果这个数的时间戳等于现在的时间戳就用现在的权值, 否则用 0
	void addval(arr& x, int v, int tim) {
		if(x.second!=tim) x.first=0, x.second=tim;
		x.first += v;
	} // 如果这个数的时间戳等于现在的时间戳就直接修改, 否则先清空再改时间戳
	void solve(int len, int dot[], int tim) {
		f(i,1,len) {tag[dot[i]]=make_pair(1, tim); f[dot[i]]=make_pair(mn[dot[i]], tim);}
		sort(dot+1, dot+1+len, cmp);
		f(i,1,len-1) {
			int r=lca(dot[i], dot[i+1]);
			if(!gv(tag[r], tim)) {dot[++len]=r; tag[r]=make_pair(1, tim);}
		}
		if(!gv(tag[1], tim)) {dot[++len]=1; tag[1]=make_pair(1, tim);} // 求出虚树中的节点
		f(i,1,len) dot[++len]=-dot[i]; sort(dot+1, dot+1+len, cmp); // 求出虚树中每个节点的欧拉序
		while(stk.size()) stk.pop();
		f(i,1,len) {
			if(dot[i]>0) stk.push(dot[i]);
			else {
				int p=stk.top(); stk.pop();
				if(p!=1) {
					addval(f[stk.top()], gv(f[p], tim), tim); // DP 转移
					if(dot[i+1]==-stk.top()) f[stk.top()].first = min(f[stk.top()].first, mn[stk.top()]); // 如果这个节点的父亲下一个将会被弹出 (就是已经遍历完了它的所有子节点)
				}
				else printf("%lld\n", gv(f[1], tim));
			}
		}
	}
} ;
int m, l, qwq[_];
signed main() {
	imt::init();
	scanf("%lld", &m);
	while(m--) {
		scanf("%lld", &l); f(i,1,l) scanf("%lld", &qwq[i]);
		imt::solve(l, qwq, m); // 直接用此时的 m 当时间戳就可以了
	}
	return 0;
}
/*
10
1 5 13
1 9 6
2 1 19
2 4 8
2 3 91
5 6 8
7 5 4
7 8 31
10 7 9
3
2 10 6
4 5 7 8 3
3 9 4 6
*/
```

---


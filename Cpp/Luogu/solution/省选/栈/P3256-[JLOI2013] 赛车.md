# [JLOI2013] 赛车

## 题目描述

这里有一辆赛车比赛正在进行，赛场上一共有 $n$ 辆车，分别称为个 $g_1,g_2,...,g_n$。赛道是一条无限长的直线。最初，$g_i$ 位于距离起跑线前进 $k_i$ 的位置。比赛开始后，车辆 $g_i$ 将会以 $v_i$ 单位每秒的恒定速度行驶。在这个比赛过程中，如果一辆赛车曾经处于领跑位置的话（即没有其他的赛车跑在他的前面），这辆赛车最后就可以得奖，而且比赛过程中不用担心相撞的问题。现在给出所有赛车的起始位置和速度，你的任务就是算出那些赛车将会得奖。


## 说明/提示

#### 数据范围与约定

- 对于 $100\%$ 的数据，$1 \le n \le 10^4$，$0 \le k_i \le 10^9$，$0 \le v_i \le 10^9$。

## 样例 #1

### 输入

```
4
1 1 0 0
15 16 10 20```

### 输出

```
3
1 2 4```

# 题解

## 作者：tylon2006 (赞：17)

# 单调栈

时间复杂度为O(nlogn)，比半平面交常数小。

~~我才不会说是因为我懒得写半平面交~~

## 题解

~~如果一个人比你小，还比你强，你就肯定打不过他了~~

- 如果一辆车比你快(跟你一样快)，还比你出发点前，你就肯定追不上它了。

  即如果a.k>b.k&&a.v>=b.v，则a追不上b，拿不到第一。
  
  **若有a为新加入的车，b为stk[top]，c为stk[top-1]，a追上b的时间小于b追上c的时间，则b不可能拿到第一，可以出栈**(自行思考原因)。
  
- 如果一辆车跟你一样快，还跟你出发点一样，你就跟它并驾齐驱了(~~废话~~)。

  **这使得a和b可能并列第一**。

- 如果一辆车比你慢，比你出发点前，你就有可能追上它了。

  但这并不代表你就可以拿到第一，可能有比你速度快的在你前面或你后面的比你速度快的在你追上之前超你车。

- 如果一辆车比你快，比你出发点后，你就有可能被它追上了。

  这导致你可能在拿到第一之前被超车。

考虑这四种情况，就可以愉快地使用单调栈解题了。

把所有的车按v从小到大排序，v相同的按k从小到大排序。

然后每次加入一个车，再将栈中不可能拿第一的车出栈，最后该车入栈。

算完输出一下栈里车的编号就好啦qwq~

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int stk[10010],top,n;
struct data{
    int k,v,id;
}a[10010];
bool cmp(data x,data y){
    if(x.v==y.v) return x.k<y.k;
    return x.v<y.v;
}
bool cmp1(int x,int y){
    return a[x].id<a[y].id;
}
double tim(data a,data b){//计算追及时间
	if(a.v==b.v) return 2e9;//防止除0 虽然似乎没有这样的数据
	return double(a.k-b.k)/(b.v-a.v);
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++) a[i].id=i;
    for(int i=1;i<=n;i++)
    scanf("%d",&a[i].k);
    for(int i=1;i<=n;i++)
    scanf("%d",&a[i].v);
    sort(a+1,a+n+1,cmp);
    stk[++top]=1;
    for(int i=2;i<=n;i++){
        while(top&&((a[i].k>a[stk[top]].k)||(top>1&&tim(a[stk[top]],a[i])<tim(a[stk[top-1]],a[stk[top]]))/*||(a[i].v==a[stk[top]].v&&a[i].k>a[stk[top]].k)*/)) top--;//注释部分然并卵
        stk[++top]=i;
    }
    printf("%d\n",top);
    sort(stk+1,stk+top+1,cmp1);
    for(int i=1;i<=top;i++)
    printf("%d ",a[stk[i]].id);
}
```


---

## 作者：Starria的脑残粉 (赞：9)

其实这题就是个简单的半平面交。。

强制只能在第一象限

做题的时候突然傻掉了

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,d,z[1000000];
bool flag[1000000];
struct lsg{int x,y,z;}a[1000000];
bool cmp(lsg x,lsg y){return x.x<y.x||x.x==y.x&&x.y<y.y;}
bool cmp1(int x,int y){return a[x].z<a[y].z;}
double pd1(int x,int y){//两直线交点
        double xx=double(a[x].y-a[y].y)/(a[y].x-a[x].x);
        return xx;
    }
bool pd(int x,int y,int z){//判断y是否完全被x和z覆盖
        double xx=pd1(x,y);
        double yy=pd1(x,z);
        return xx>yy;
    }
int main(){
    ios::sync_with_stdio(false);
    cin>>n;for (int i=1;i<=n;i++)cin>>a[i].y,a[i].z=i;
    for (int i=1;i<=n;i++)cin>>a[i].x;
    sort(a+1,a+1+n,cmp);for (int i=1;i<=n;i++){
        while(d>=1&&pd1(z[d],i)<0)d--;
        while(d>=2&&pd(z[d-1],z[d],i))d--;
        z[++d]=i;
    }sort(z+1,z+1+d,cmp1);cout<<d<<endl;
    for (int i=1;i<=d;i++)cout<<a[z[i]].z<<' ';
}
```

---

## 作者：WangHansen (赞：6)

# P3256 赛车
## 单调栈
本人认为的性价比最高的解题算法。

时间快，易于理解。
### 单调栈基本原理
如果有一个解比在栈顶的解更优，那么就让栈顶出栈，然后继续比较下去，直到比不下去为止，再将该解入栈。
## 解题思路
乍一看，我们发现，在两辆车中有这几种情况需要讨论：
- 起点相同，速度不同；
- 起点不同，速度相同；
- 起点不同，速度不同。

但无论是以上哪一种情况，我们都能用同一种方法解决：
![](https://cdn.luogu.com.cn/upload/image_hosting/6imiay86.png)
三种颜色代表三辆不同的车。
很明显，**红色代表的车在超越蓝色代表的车而获得领先前，就已经被黄色车超车了**，所以它无法领奖。
依照该结论，我们可以得到以下代码：

```cpp
double time(car a,car b)//计算超车时间。因为时间可能是小数所以返回值是double类型。
{
	return (a.k - b.k) * 1. / (b.v - a.v);
}
int main()
{
    for (int i = 1;i <= n;i++)//枚举每一辆车。
	{
        while (!sta.empty() && time(c[i],sta.top()) < sta.top().t)//控制出栈。
        {
        	c[i].t = time(c[i],sta.top());//更新获得领先的时间。
        	sta.pop();
		}
		if (sta.empty())//特判。
		{
			c[i].t = 0;
		}
        sta.push(c[i]);//入栈。
	}
```
**但很可惜，这是错的，** [就像这样](https://www.luogu.com.cn/record/199319309)。

因为这段代码无法解决一种情况：**起点相同，速度相同**。

在这段代码中处理该情况，time 函数会进行一个除以零的操作；如果这两辆车都能领奖的话，程序只会输出他们中的其中一个。

其实解决这个代码的问题只需要给 time 函数特判，并给完全相同的辆车之中选一个代表去参赛，判断代表能不能领奖就行了。

# 奉上 AC 代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
struct car
{
	int k,v,id;//起点，速度，编号。
	double t;//获得领先的时间。
}c[10005],c2[10005];//定义数组，c 为参与排序的数组，c2 为原数组对照。
int n;
car ans[10005];
stack <car> sta;
vector <int> win[10005];//用于绑定完全相同的两辆车的数组。
double time(car a,car b)//计算 a 车超越 b 车的时间，时间可能是小数所以用double。
{
	if (a.v == b.v && a.k == b.k)//如果两辆车完全相同。
	{
		return b.t;
	}
	return (a.k - b.k) * 1. / (b.v - a.v);//计算速度。
}
bool cmp1(car a,car b)
{
	if(a.v == b.v) return a.k > b.k;//如果两车速度相同就让起点靠前的车排前面。
	return a.v < b.v;
}
bool cmp2(car a,car b)
{
	return a.id < b.id;//因为栈中的车辆的原始顺序可能不一，所以以编号再排一次。
}
int main()
{
	cin >> n;
	for (int i = 1;i <= n;i++)
	{
		int x;
		cin >> x;
		c[i].k = x,c[i].id = i;
		win[i].push_back(i);//最开始每辆车与自己绑定。
		c2[i].k = x,c2[i].id = i;
	}
	for (int i = 1;i <= n;i++)
	{
		int x;
		cin >> x;
		c[i].v = x;
		c2[i].v = x;
	}
	sort(c + 1,c + n + 1,cmp1);
	for (int i = 1;i <= n;i++)
	{
		if(sta.size())
		{
			if (c[i].v == sta.top().v)
	        {	
	        	if(c[i].k == sta.top().k)
	        		win[sta.top().id].push_back(c[i].id);//如果两车完全相同则将两车绑定，因为经过排序后两辆相同的车一定会被排到一起，所以无需写在循环中。
	        	continue;
			}
		}
        while (!sta.empty() && time(c[i],sta.top()) < sta.top().t)//控制出栈。
        {
        	sta.pop();
		}
		if (sta.empty())//特判，如果栈为空则说明该车在一开始就获得了领先。
		{
			c[i].t = 0;
		}
		else
		{
			c[i].t = time(c[i],sta.top());//否则该车获得领先的时间就是它超越栈顶车的时间。
		}
		sta.push(c[i]);
	}
	int cnt = sta.size();
	int cnt2 = 0;
	for (int i = 1;i <= cnt;i++)
	{
		for (auto j : win[sta.top().id])
		{
			ans[++cnt2] = c2[j];//将每辆与栈中车辆绑定的车加入答案中。
		}
		sta.pop();
	}
	sort(ans + 1,ans + cnt2 + 1,cmp2);
	cout << cnt2 << endl;
	for (int i = 1;i <= cnt2;i++)
	{
		cout << ans[i].id << ' ';//按序输出。
	}
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/200463547)

欢迎大家指出不足。

点个赞呗。

---

## 作者：longdie (赞：5)

## [JLOI2013]赛车  

折磨水的题居然是紫题。  

题解里面的半平面交和单调栈我都没有想到（虽然我好像都会），但是观察到这道题的数据范围是一个非常尴尬的 $1e4$，是不是可以考虑 $n^2$ 暴力解决掉。  

这里想给出 $n^2$ 暴力的做法，我们分情况考虑，先计算出它超越初始位置在它前面的所有车所用的最长时间 $T_1$，然后我们判断它后面的车超越它的最短时间 $T_2$，很显然吧，只有当 $T_1 >= T_2$ 的时候，这个车是满足题目条件的，我们把它加入到答案里，然后这道题就做完了。 

但是 $1e4 * 1e4$ 的复杂度再加上浮点数运算也就是luogu这种比较快的评测机可以过了，所以我们可以再优化一下，发现我们只用每次计算只在这个车前面的车，而不用去计算它后面的车，这样复杂度就被优化了一倍，然后就可以过了。 

然后先给出代码：  

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e4 + 5;
inline int read(int s = 0, char ch = getchar()) {
	while(!isdigit(ch)) { ch = getchar(); }
	while(isdigit(ch)) { s = s*10 + ch - '0', ch = getchar(); }
	return s;
}
struct node { double d, v, ti; int id; } a[N];
inline bool cmp(node a, node b) { return a.d > b.d; }
int n, vis[N], tot;
int main() {
	n = read(); double mx = 0;
	for(register int i = 1; i <= n; ++i) a[i].d = read(), a[i].id = i, mx = max(mx, a[i].d);
	for(register int i = 1; i <= n; ++i) a[i].v = read();
	sort(a + 1, a + n + 1, cmp);
	for(register int i = 1; i <= n; ++i) {
		for(register int j = 1; j < i; ++j) {
			if(a[j].v >= a[i].v) { 
				if(a[j].v == a[i].v && a[i].d == a[j].d) continue;
				if(a[i].d == mx && a[i].d == a[j].d) continue;
				vis[a[i].id] = 1, a[i].ti = 99999999999999; 
			}
			else {
				double now = (a[j].d - a[i].d) / (a[i].v - a[j].v);
				a[i].ti = max(a[i].ti, now);
				if(now < a[j].ti) { vis[a[j].id] = 1; } 
			}
		}
	}
	for(register int i = 1; i <= n; ++i) 
		if(!vis[i]) ++tot;
	printf("%d\n", tot);
	for(register int i = 1; i <= n; ++i) 
		if(!vis[i]) printf("%d ", i);
	return 0;
}
```  

虽然用暴力写过一道题感觉确实很爽，但是我们至少也要学会正解的思路。

其实上面的暴力就相当于 $n^2$ 求半平面交的过程，我们可以建一个 时间—位移 的函数图像，发现只有在某一个时刻在最上面的车是满足题目条件的，这样我们就可以用半平面交来解决这个问题了（其实关键在于正确的找到横纵坐标的意义）。 

那么这道题就被你愉快的用 $n^2$ 暴力水过了。 

---

## 作者：Piwry (赞：5)

这 1e9 的值域真的搞炸我了（（（

## 解析

设 $x$ 为比赛开始的时间，可以用一条平面直线表示赛车离起点的距离。

可以发现只有在**第一象限**中曾有的一段线段（点也算）在 “最上面” 的直线才有可能拿奖（如果有多条直线的线段**重叠**，全都算做答案），作一下图：

![赛车](https://cdn.luogu.com.cn/upload/image_hosting/s3wr7w5i.png)

发现这个东西很像求一个半平面交（~~确切的定义我也不知...~~ 话说好多半平面交题目都是看起来形似就可以做了），于是就可以拉进去跑一跑左半平面交，最后统计剩下的直线；第一象限的限制可以扔几条直线**充当坐标轴**进去，不过由于所有直线的极角都至少大于等于 $x$ 轴的直线，因此只需加 $y$ 轴的直线就可以了。

另外题目不保证直线不重复，做之前需要判断记录下（这里我用了 `stl::map`）。

最后就是最大的精度问题了。看一下题目的值域，发现达到了**可怕的** 1e9，这意味着单单是求交点坐标就有可能**跨度超过 1e18**；加上实现时甚至需要判断判断两个点坐标是否**相等**（不单单是判大小关系），因此 `eps` （~~应该都叫同一个名字吧...~~ 最小精度差）需要开得非常小，例如 1e-18。

不过由于实现方式的差异，这样也还是有可能被卡（比如我）；因此可以考虑把 `eps` 直接干脆开到 $0$。但注意**排序直线时的极角的 “精度跨度” 是比 判断交点是否相同的 “精度跨度” 要小的**。因此可以考虑用解析式对直线排序，或者选用更宽松的 `eps`。（如果程序某几个部分的 “精度跨度” 相差非常大的话，一个办法是可以考虑选用没有精度误差的方法处理一部分，另一个办法就是选用不同的 `eps`）

## CODE

（关于精度的几处问题我都用注译标识了）

```cpp
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <map>
#include <vector>
#include <cstring>
using std::sort;
using std::pair;
using std::map;
using std::vector;
using std::max;
typedef pair<int, int> pad;

/*------------------------------Computational geometry------------------------------*/

const double pi =acos(-1);
double eps =0;

struct vect{
	double x, y;
	vect(){}
	vect(double xx, double yy):x(xx), y(yy){}
	vect operator + (vect v){ return vect(x+v.x, y+v.y); }
	vect operator - (vect v){ return vect(x-v.x, y-v.y); }
	vect operator * (double mu){ return vect(mu*x, mu*y); }
	double operator / (vect v){ return x*v.y-y*v.x; }/*叉积*/
};

struct line{
	vect u, v;
	double angle;
	int id, k, vvv;
	line(){}
	line(vect uu, vect vv, int idd):u(uu), v(vv), id(idd){ angle =atan2(vv.y-uu.y, vv.x-uu.x); }
};

inline bool gtr(double a, double b){ return (a-b > eps); }

/*注意这两种判断相等的办法是不同的：注译的那种本质是在比较二进制位，过于严格*/
inline bool eq(double a, double b){ return (a-b < eps && a-b > -eps); }

//inline bool eq(double a, double b){ return a == b; }

inline bool onright(line f, vect w){ return (gtr((w-f.u)/(f.v-f.u), 0)); }

vect getIntersection(line f, line g){
	double w =((g.u-f.u)/(f.u-f.v))/((f.u-f.v)/(g.u-g.v));
	return g.u+(g.u-g.v)*w;
}

//int cmp(line A, line B){
//	if(eq(A.angle, B.angle)) return onright(B, A.u);/*有向直线最左的在最后面，会被保留*/
//	else return (gtr(B.angle, A.angle));
//}

/*改用解析式比较，实现的功能和上面注译的那个一致*/
bool cmp(line A, line B){
	if(A.vvv != B.vvv) return A.vvv < B.vvv;
	else return A.k < B.k;
}

/*由于这些直线的极角都在第一象限，且保证有交，因此一些代码块可以省略*/
inline pad getHPI(line ls[], int totl, line hull[]){
	sort(ls, ls+totl, cmp);
	int l =0, r =0;
	for(int i =0; i < totl; ++i){
		while(i < totl-1 && eq(ls[i].angle, ls[i+1].angle)) ++i;
		while(r-l > 1 && onright(ls[i], getIntersection(hull[r-1], hull[r-2]))) --r;
//		if(r > 0 && eq(ls[i].angle-hull[r-1].angle, pi)) return pad(0, 0);/*判方向相反的平行*/
		hull[r++] =ls[i];
	}
//	while(r-l > 1){
//		if(onright(hull[r-1], getIntersection(hull[l], hull[l+1]))) ++l;
//		else if(onright(hull[l], getIntersection(hull[r-1], hull[r-2]))) --r;
//		else break;
//	}
//	if(r-l < 3) return pad(0, 0);/*无交*/ 
//	else return pad(l, r);
	return pad(l, r);
}

/*------------------------------Main------------------------------*/

const int MAXN =1e4+50;

line ls[MAXN], hull[MAXN];
int k[MAXN], v[MAXN], ans[MAXN], tota, tot, id[MAXN];
bool isans[MAXN], unused[MAXN];
vector<int> car[MAXN];
map<pad, int> Cars;

inline int read(){
	int x =0; bool f =0; char c =getchar();
	while(c < '0' || c > '9') (c == '-') ? f =1, c =getchar() : c =getchar();
	while(c >= '0' && c <= '9') x = (x<<3) + (x<<1) + (48^c), c =getchar();
	return (f) ? -x : x;
}

int main(){
	int n =read();
	for(int i =0; i < n; ++i) k[i] =read();
	for(int i =0; i < n; ++i) v[i] =read();
	for(int i =0; i < n; ++i){
		/*用 map 判重*/
		if(Cars.count(pad(k[i], v[i]))){
			map<pad, int>::iterator it =Cars.find(pad(k[i], v[i]));
			car[it->second].push_back(i);/*把相同的直线塞到同一个序号的空间里*/
			unused[i] =1;
		}
		else{
			Cars.insert(pair<pad, int>(pad(k[i], v[i]), tot));
			car[tot].push_back(i);
			id[i] =tot;/*重分配序号*/
			tot++;
		}
	}
	int totl =0;
	for(int i =0; i < n; ++i)
		if(!unused[i])
			ls[totl++] =line(vect(0, k[i]), vect(1, v[i]+k[i]), id[i]),
			ls[totl-1].k =k[i], ls[totl-1].vvv =v[i];
	ls[totl++] =line(vect(0, 1), vect(0, 0), -1),
	ls[totl-1].k =0, ls[totl-1].vvv =0;
	pad h =getHPI(ls, totl, hull);
	for(int i =h.first; i < h.second; ++i) if(hull[i].id != -1) isans[hull[i].id] =1;
	for(int i =0; i < tot; ++i){
		if(isans[i])
			for(int j =0; j < (int)car[i].size(); ++j) ans[tota++] =car[i][j]+1;
	}
	sort(ans, ans+tota);
	printf("%d\n", tota);
	for(int i =0; i < tota; ++i) printf("%d ", ans[i]);
}
```


---

## 作者：西卡洛斯 (赞：3)

这是一篇 **单调栈** 的题解。~~半平面交是啥，不会。~~

首先把所有的车按照 $v$ 排序，这样就不存在后面车追不上前面车的情况。

维护一个单调栈，存储所有可能的领跑者。讨论每一辆车，如果栈顶车的 $v$ 和 $k$ 都小于当前车，直接将栈顶车弹出。

如果当前车在某个时间超过栈顶车，且这个时间小于栈顶车超过栈中第二辆车的时间，说明栈顶车也不会成为领跑者，弹出。

最终栈中车辆就是所有的领跑者。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
const int N=1e4+10;
struct Node{int k,v,id;}a[N];
int n,top,stk[N];
bool cmp1(Node a,Node b) {return a.v==b.v?a.k<b.k:a.v<b.v;}
bool cmp2(int x,int y)   {return a[x].id<a[y].id;}
double  t(Node a,Node b) {return double(a.k-b.k)/(b.v-a.v);}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++) a[i].id=i,scanf("%d",&a[i].k);
	for(int i=1;i<=n;i++) scanf("%d",&a[i].v);
	sort(a+1,a+n+1,cmp1);
	stk[++top]=1;
 	for(int i=2;i<=n;i++)
	{
    	while(top&&((a[i].k>a[stk[top]].k)||
			 (t(a[stk[top]],a[i])<t(a[stk[top-1]],a[stk[top]]))))
			 top--;
    	stk[++top]=i;
 	}
	printf("%d\n",top);
 	sort(stk+1,stk+top+1,cmp2);
 	for(int i=1;i<=top;i++)
 		printf("%d ",a[stk[i]].id);
	return 0;
}
```


---

## 作者：GavinZheng (赞：3)

其实。。。这道题n方暴力就可以了啊。。。。。先枚举第一个点，然后枚举所有点。维护一个l和r分别代表能在那个时间段领先。然后动态刷新即可。当r<l时那这辆车就不计入答案。反之则计入答案。
```cpp
/**************************************************************
    Problem: 3190
    User: GavinZheng
    Language: C++
    Result: Accepted
    Time:3340 ms
    Memory:2776 kb
****************************************************************/
 
#include<cstdio>
#include<algorithm>
#define maxn 100005
using namespace std;
double v[maxn];
double lo[maxn];
int ans[maxn];
int tot=0;
int main(){
    int n;scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%lf",&lo[i]);
    for(int i=1;i<=n;i++) scanf("%lf",&v[i]);
    for(register int i=1;i<=n;i++){
        double l=0,r=1000005000;bool win=1;
        for(register int h=1;h<=n;h++){
            if(v[h]>v[i]) r=min(r,((lo[i]-lo[h])/(v[h]-v[i])));
            if(v[h]==v[i]&&lo[h]>lo[i]){
                win=0;
                break;
            }
            //v[h]<v[i]
            if((v[h]<v[i])&&(lo[h]>lo[i])) l=max(l,((lo[h]-lo[i])/(v[i]-v[h])));
            if(r<l) {win=0;break;}
        }
        if(win) ans[++tot]=i; 
    }
    printf("%d\n",tot);
    for(int i=1;i<=tot;i++){
        printf("%d ",ans[i]);
    }
    return 0;
}

```

---

## 作者：genshy (赞：2)

### 题意描述：

有 $n$ 辆汽车，每辆汽车有初始位置 $k$ 和速度 $v$ 。问你有多少车能在某一时刻跑在所有车的前面。

### solution

我们把每辆车的位置关于时间的函数直线画出来，发现一辆车某一时刻能跑在所有车的前面，当且仅当他的函数直线是这几个一次函数交区域的一条边。

具体的证明，我不太会，反正结论猜对就ok了。

注意一下：每条直线的定义域是 $(0,\infty)$, 所以我们只能在第一象限内做半平面交，一开始把四条边界直线加进去就好了。

然后我们就可以愉快的套半平面交的板子了。

就这样了，一道紫题就被我们水过去了？？？

你太 naive 了！

首先，这道题的值域为 $(0,1e9)$ 这意味着我们求直线交点的时候可能会爆 $10^{18}$, 所以 $lim$ 的上限要设大一点。

第二点：为了避免被卡精度，我们的 $eps$ 要设的尽量小一些，尽量使用 $long$ $double$。

第三点也是最重要的一点：有的车的函数直线可能完全相同，但我们做半平面交只会取一条直线，导致我们的答案出错（不少同学 WA 90 分可能就是这个原因）。

但好在这道题的数据范围只有 $1e4$, 所以我们完全可以到最后在扫一遍，看有没有少算的。

然后就没有什么注意的了，保证自己的板子没问题就行（自己一开始板子写错了，交了好几次才发现，淦）.


```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
#define double long double
const int N = 1e5+10;
const long long lim = 1e18+10;//lim设大点，eps设小点
const double eps = 1e-18;
int n,m,cnt,num,l,r,ans[N];
double k[N],w[N];
struct point
{
	double x,y;
	point(){}
	point(double a,double b){x = a, y = b;}
}sta[N];
typedef point Vector;
struct line
{
	int id;
	point x,y;
	double ang;
	line(){}
	line(point a,point b,int i)
	{
		x = a; y = b; id = i;
		ang = atan2(b.x-a.x,b.y-a.y);
	}
}q[N],L[N];
int dcmp(double x)
{
	if(fabs(x) < eps) return 0;
	return x > 0 ? 1 : -1;
}
point operator + (point a,point b){return point(a.x+b.x,a.y+b.y);}
point operator - (point a,point b){return point(a.x-b.x,a.y-b.y);}
point operator * (point a,double k){return point(a.x*k,a.y*k);}
double Dot(point a,point b){return a.x*b.x+a.y*b.y;}
double Cro(point a,point b){return a.x*b.y-a.y*b.x;}
double dis(point a,point b){return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}
bool OnRight(point p,line a){return dcmp(Cro(p-a.x,a.y-a.x)-eps) >= 0;}
point Root_LL(line a,line b)//两直线的交点
{
	Vector v = a.y-a.x, u = b.y-b.x, w = a.x-b.x;
	double t = Cro(w,u)/Cro(u,v);
	return a.x + v * t;
}
bool comp(line a,line b)
{
	if(dcmp(a.ang-b.ang) == 0) return OnRight(b.x,a);
	return a.ang < b.ang;
}
int HPI()//半平面交板子
{
	l = 1, r = 1; q[1] = L[1];
	for(int i = 2; i <= cnt; i++)
	{
		if(dcmp(L[i].ang-L[i-1].ang) == 0) continue;
		while(l < r && OnRight(sta[r-1],L[i])) r--;
		while(l < r && OnRight(sta[l],L[i])) l++;
		q[++r] = L[i];
		if(l < r) sta[r-1] = Root_LL(q[r],q[r-1]);
	}
	while(l < r && OnRight(sta[r-1],q[l])) r--;
	while(l < r && OnRight(sta[l],q[r])) l++;
	sta[r] = Root_LL(q[l],q[r]);
	if(r-l+1 == 2) return 0;
	return r-l+1;
}
int main()
{
	scanf("%d",&n);
	for(int i = 1; i <= n; i++) cin>>w[i];
	for(int i = 1; i <= n; i++) cin>>k[i];
	point a = point(0,0); point b = point(lim,0);
	point c = point(lim,lim); point d = point(0,lim);
	L[++cnt] = line(a,b,0); L[++cnt] = line(b,c,0);//四条边界直线
	L[++cnt] = line(c,d,0); L[++cnt] = line(d,a,0);
	for(int i = 1; i <= n; i++) 
	{
		point a = point(0,w[i]); point b = point(1,k[i]+w[i]); 
		L[++cnt] = line(a,b,i);
	}
	sort(L+1,L+cnt+1,comp);
	m = HPI();
	for(int i = 1; i <= m; i++)//最后扫一遍，看有没有漏算的
	{
		for(int j = 1; j <= n; j++)
		{
			if(w[j] == w[q[i].id] && k[j] == k[q[i].id]) ans[++num] = j;
		}
	}
	sort(ans+1,ans+num+1);
	printf("%d\n",num);
	for(int i = 1; i <= num; i++) printf("%d ",ans[i]);
	printf("\n");
	return 0;
}
```




---

## 作者：2017gdgzoi999 (赞：2)

**粗体部分是需要注意的坑点**

这一题除了半平面交，还有一种（更加暴力）的方法：解不等式。

假设一辆车初始位置为$a$，速度为$v$，则这辆车第$k$时间所在的位置为$kv+a$，是一个整式。

那么可以用不等式，判断某个车（$g_i$）在那个时间段的位置**大于等于**（注意题面）另外一辆车（$g_j$）的时间段。即$kv_j+a_j \leq kv_i+a_i$。**注意**$\bold i$**不等于**$\bold j$**。**

那么，把所有$j$对应的不等式的解取交集，**得到的结果再和区间**$[0, INF)$**取交集（时间不能为负）。**（不就是不等式组吗）

![](https://cdn.luogu.com.cn/upload/pic/62588.png)

如果最后的结果非空集，那么这辆车拿奖稳了。

用$pair$存储闭区间。

### 变量部分

```cpp
const int MAXN = 10010; //赛车个数
const double INF=1e+60; //无穷大

struct node { //定义一个整式
    double x, a;
} p[MAXN];
bool flag[MAXN]; //标记得奖的赛车
```

没啥坑点（除了不看数据范围的）。

### 解不等式与交集部分

```cpp
pair<double,double> solve(node a, node b) { //[first,second]
    double x1=a.x, x2=b.x, a1=a.a, a2=b.a; //k*x1+a1>=k*x2+a2
    double xx=x1-x2, aa=a2-a1; //k*xx>=aa（移项）
    //printf("$%lfk+%lf,%lfk+%lf $%lfk>=%lf\n", a.x, a.a, b.x, b.a, xx, aa);
    /*系数化为1*/
    if (xx==0.0) { //aa<=0（xx=0，转化）
        if (aa<=0.0) return make_pair(-INF,INF); //(全体实数)
        else return make_pair(1.0,0.0); //(无解)
    }
    else if (xx>0.0) return make_pair(aa/xx,INF); //k>=aa/xx（xx>0，不变号）
    else return make_pair(-INF, aa/xx); //k<=aa/xx （xx<0，变号）
}
pair<double,double> calc(pair<double,double> a, pair<double,double> b) { // 取交集
    return make_pair(max(a.first,b.first),min(a.second,b.second));
}
```

**解不等式系数化为1时注意系数$=0$,$>0$,$<0$的情况，初中数学经常错的变符号。**

### 主函数

```cpp
int main() {
    int n; scanf("%d", &n);
    for (int i=1; i<=n; ++i) scanf("%lf", &p[i].a); //输入(没啥好说的)
    for (int i=1; i<=n; ++i) scanf("%lf", &p[i].x);
    int cnt = 0;
    for (int i=1; i<=n; ++i) {
        pair<double,double> res = make_pair(0.0,INF); //不等式组解集
        for (int j=1; j<=n; ++j) { //枚举其它的车
            if (i==j) continue;
            res = calc(res,solve(p[i],p[j])); //解不等式,取交集
            if (res.first>res.second) break; //无解直接退出
        }
        if (res.first<=res.second) { //有解,标记
            ++cnt; flag[i]=true;
        }
    }
    printf("%d\n", cnt);
    for (int i=1; i<=n; ++i) {
        if (flag[i]) printf("%d ", i);
    }
    return 0;
}
```

### 完整代码（624ms, 900KB）

```cpp
// luogu-judger-enable-o2
#include <iostream>
#include <cstdio>
#include <algorithm>

using namespace std;
const int MAXN = 10010;
const double INF=1e+60;

struct node {
    double x, a;
} p[MAXN];
bool flag[MAXN];

pair<double,double> solve(node a, node b) { //[first,second]
    double x1=a.x, x2=b.x, a1=a.a, a2=b.a; //k*x1+a1>=k*x2+a2
    double xx=x1-x2, aa=a2-a1; //k*xx>=aa
    //printf("$%lfk+%lf,%lfk+%lf $%lfk>=%lf\n", a.x, a.a, b.x, b.a, xx, aa);
    if (xx==0.0) { //aa<=0
        if (aa<=0.0) return make_pair(-INF,INF);
        else return make_pair(1.0,0.0);
    }
    else if (xx>0.0) return make_pair(aa/xx,INF); //k>=aa/xx
    else return make_pair(-INF, aa/xx); //k<=aa/xx
}
pair<double,double> calc(pair<double,double> a, pair<double,double> b) {
    return make_pair(max(a.first,b.first),min(a.second,b.second));
}
int main() {
    int n; scanf("%d", &n);
    for (int i=1; i<=n; ++i) scanf("%lf", &p[i].a);
    for (int i=1; i<=n; ++i) scanf("%lf", &p[i].x);
    int cnt = 0;
    for (int i=1; i<=n; ++i) {
        pair<double,double> res = make_pair(0.0,INF);
        for (int j=1; j<=n; ++j) {
            if (i==j) continue;
            res = calc(res,solve(p[i],p[j]));
            if (res.first>res.second) break;
        }
        if (res.first<=res.second) {
            ++cnt; flag[i]=true;
        }
    }
    printf("%d\n", cnt);
    for (int i=1; i<=n; ++i) {
        if (flag[i]) printf("%d ", i);
    }
    return 0;
}
```

---

## 作者：OIer_Tan (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P3256)

## 思路

一看啊，这题很板啊，每个车的位置可以直接转成一个一次函数。

再看看，诶，只要出现在最上方过就行，那不就是 [	[HNOI2008] 水平可见直线](https://www.luogu.com.cn/problem/P3194) 了吗。

然后可以发现因为只考虑第一象限的部分，所以可以加一条 $y=0$ 的直线，或者直接特判。以及有可能会有直线共线，这个随便乱搞一下就行了。

## 代码

```cpp
#include <bits/stdc++.h>

#ifndef CRT
#define endl '\n'
#endif

using namespace std ;

typedef long long ll ;
typedef unsigned long long ull ;
typedef long double ld ;

const ll N = 50005 ;

struct node
{
	ll a , b , i ;
	friend bool operator < ( const node & a , const node & b )
	{
		if ( a.a != b.a )
		{
			return a.a < b.a ;
		}
		return a.b < b.b ;
	}
} l [N] ;

ll n ;

struct point 
{
	ld x , y ;
	explicit point ( const ld & a = 0 , const ld & b = 0 ) : x ( a ) , y ( b ) {}
} p1 [N] , p2 [N] ;

ld slope ( ll a , ll b )
{
	if ( l [a].a == l [b].a )
	{
		return 1e18 ;
	}
	return 1.0l * ( l [a].b - l [b].b ) / ( l [b].a - l [a].a ) ;
}

ll stk [N] , top = 0 ;

ll ans [N] ;

ld k [N] , v [N] ;

int main ()
{
#if not defined ( CRCC ) and not defined ( ONLINE_JUDGE )
	freopen ( ".in" , "r" , stdin ) ;
	freopen ( ".out" , "w" , stdout ) ;
#endif
	ios::sync_with_stdio ( 0 ) ;
	cin.tie ( 0 ) ;
	cout.tie ( 0 ) ;
	cin >> n ;
	for ( ll i = 1 ; i <= n ; i ++ )
	{
		cin >> k [i] ;
	}
	for ( ll i = 1 ; i <= n ; i ++ )
	{
		cin >> v [i] ;
	}
	for ( ll i = 1 ; i <= n ; i ++ )
	{
		l [i].b = k [i] ;
		l [i].a = v [i] ;
		l [i].i = i ;
	}
	// l [n + 1] = { 0 , 0 , n + 1 } ;
	sort ( l + 1 , l + 1 + n ) ;
	stk [++ top] = 1 ;
	for ( ll i = 2 ; i <= n ; i ++ )
	{
		while ( top && 
			( ( l [i].b > l [stk [top]].b ) || 
			( top > 1 && slope ( stk [top] , i ) < slope ( stk [top - 1] , stk [top] ) ) ) ) 
		{
			top -- ;
		}
		stk [++ top] = i ;
	}
	cerr << top << endl ;
	for ( ll i = 1 ; i <= top ; i ++ )
	{
		ans [i] = l [stk [i]].i ;
	}
	// for ( ll i = 1 ; i <= top ; i ++ )
	// {
	// 	if ( ans [i] == n + 1 )
	// 	{
	// 		swap ( ans [i] , ans [top] ) ;
	// 		top -- ;
	// 	}
	// }
	sort ( ans , ans + top + 1 ) ;
	cout << top << endl ;
	for ( ll i = 1 ; i <= top ; i ++ )
	{
		cout << ans [i] << " " ;
	}
	return 0 ;
}
```

---

## 作者：Kaenbyou_Rin (赞：1)

### 看标签可以得知这是一道半平面交的题。


------------
   我们先考虑如何建模。
  
  以时间 $t$ 为横轴，距离 $s$ 为纵轴，设某人的初始位置在 $A$ 点，从 $A$ 点出发画一条直线。他在某个时间段 $Δt$ 内经过距离 $Δs$ ，两者的比值是直线的斜率，其物理意义正好是速度，他在某时刻 $t$ 的位置就是他在这条直线上的纵坐标 $s$ 。这条直线代表了他的运动轨迹。运动轨迹始终位于第一象限。
  
图 $(a)$ 中的两条直线是两个人 $A$ 和 $B$ 的运动轨迹，交叉点 $k$ 是 $b$ 追上 $A$ 的点。

![](https://cdn.luogu.com.cn/upload/image_hosting/zuu8zhox.png)

如果有 $n$ 个人，那么就有 $n$ 条直线在第一象限，见图 $(b)$ 。相交的点就是追上的点，但追上后不一定排第一。只有凸面上的点才是题目要求的排名第一的点。另外，由于这些直线的半平面交不是一个完整的多边形，可以加上两个半平面  $E$ 和 $F$ ，形成闭合的凸多边形，其中 $E$ 是 $y$ 值无穷大的向左的水平线， $F$ 是反向的 $y$ 轴，图中蓝色的部分是半平面交形成的凸多边形，凸多边形的顶点数量去掉两个点（想想为什么），就是题目求的获奖赛车个数。

![](https://cdn.luogu.com.cn/upload/image_hosting/hpoqi4t0.png)

部分代码:
```
vector<Point> HPI(vector<Line>L){//求半平面交，返回凸多边形
	int n=L.size();
	sort(L.begin(),L.end());//将所有半平面按照极角排序
	int first,last;//指向双端队列的第一个和最后一个元素
	vector<Point> p(n);//两个相邻半平面的交点
	vector<Line> q(n);//双端队列
	vector<Point> ans;//半平面交形成的凸包
	q[first=last=0]=L[0];
	for(int i=1;i<n;i++){
		while(first<last&&!OnLeft(L[i],p[last-1])) last--;//情况一：删除尾部的半平面
		while(first<last&&!OnLeft(L[i],p[first])) first++;//情况二：删除首部的半平面
		q[++last]=L[i];//将当前半平面加入双端队列的尾部
		if(fabs(Cross(q[last].v,q[last-1].v))<eps){
			last--;
			if(OnLeft(q[last],L[i].p)) q[last]=L[i];
		}//极角相同的保留左边（想想为什么）
		if(first<last) p[last-1]=Cross_point(q[last-1],q[last]);//计算队列尾部的半平面交点
	} 
	while(first<last&&!OnLeft(q[first],p[last-1])) last--;
	if(last-first<=1) return ans;//空集
	p[last]=Cross_point(q[last],q[first]);//计算队列首尾部的半平面交点
	for(int i=first;i<=last;i++) ans.push_back(p[i]);//复制
	return ans;//返回凸多边形
}
```



------------
但是，真的要这么麻烦吗？

#### 我们观察数据范围， $1e4$ 的数据完全可以考虑暴力。

将初始位置从大到小排序，用结构体存被追上的时间，考虑在后面的赛车有没有可能追上他即可，如果有，将这部车的 $vis$ 数组标记为 $true$ ，最后统计 &true& 的个数并输出即可。（记得稍微卡下常，加个快读什么的。）

### The end~


---

## 作者：Yaha (赞：1)

### 半平面交

我们根据每个人的速度和起始位置，能够画出其 $S \text{-}t$ 图象，容易想到，若将所有直线放在一个图中，最上面的那个轮廓中有哪些直线，这些直线所对应的人就能成为最终答案。在草稿纸上画一下就理解了。

这些直线加上 $x$ 轴和 $y$ 轴，求一遍半平面交，然后处理出所有在半平面交轮廓上的直线，这些直线对应的人就是答案。

具体可以看看代码

```cpp
#include<bits/stdc++.h>
#define LD long double
#define x first
#define y second

using namespace std;

typedef pair<int,int> PII;
typedef pair<LD,LD> PDD;//点
const int amou=1e4+90;
const LD eps=1e-18;

struct Line{
	PDD st,ed;//起点和终点
	vector<int> id;//这条直线所对应的所有运动员
}line[amou];
int cnt;//直线条数
int q[amou],ans[amou],ki[amou],vi[amou];

PDD operator-(PDD a,PDD b){
	return {a.x-b.x,a.y-b.y};
}

int dcmp(LD a,LD b){
	if(fabs(a-b)<eps) return 0;
	if(a<b) return -1;
	return 1;
}

LD get_angle(Line a){//求角度
	return atan2(a.ed.y-a.st.y,a.ed.x-a.st.x);
}

LD cross(PDD a,PDD b){//叉乘，即求面积
	return a.x*b.y-a.y*b.x;
}

LD area(PDD a,PDD b,PDD c){//面积
	return cross(b-a,c-a);
}

bool cmp(Line a,Line b){//如果角度一样，保留左边那条。按角度大小将直线排序
	LD A=get_angle(a),B=get_angle(b);
	if(!dcmp(A,B)) return area(a.st,a.ed,b.ed)<0;
	return A<B;
}

PDD get_line_intersection_point(PDD s1,PDD t1,PDD s2,PDD t2){//求两直线交点
	PDD u=s1-s2;
	LD t=cross(t2,u)/cross(t1,t2);
	return {s1.x+t1.x*t,s1.y+t1.y*t};
}

PDD get_line_intersection_line(Line a,Line b){//求两直线交点
	return get_line_intersection_point(a.st,a.ed-a.st,b.st,b.ed-b.st);
}

bool on_right(Line a,Line b,Line c){//a是否在bc交点的右边
	PDD p=get_line_intersection_line(b,c);
	return area(a.st,a.ed,p)<0;
}

void half_plane_intersection(){
	sort(line+1,line+cnt+1,cmp);
	int head=0,tail=-1;
	for(int i=1;i<=cnt;i++)
	{
		if(i>1&&!dcmp(get_angle(line[i]),get_angle(line[i-1]))) continue;//如果角度一样就不用处理了
		while(head+1<=tail&&on_right(line[i],line[q[tail]],line[q[tail-1]])) tail--;//如果交点在i右边，那该被舍去，建议画图
		while(head+1<=tail&&on_right(line[i],line[q[head]],line[q[head+1]])) head++;
		q[++tail]=i;
	}
	while(head+1<=tail&&on_right(line[q[head]],line[q[tail]],line[q[tail-1]])) tail--;//一定更新队头队尾
	while(head+1<=tail&&on_right(line[q[tail]],line[q[head]],line[q[head+1]])) head++;

	int t=0;
	for(int i=head;i<=tail;i++)
		for(int j=0;j<line[q[i]].id.size();j++)
			ans[++t]=line[q[i]].id[j];
	sort(ans+1,ans+t+1);
	printf("%d\n",t);
	for(int i=1;i<=t;i++) printf("%d ",ans[i]);
}

int main(){
	map<PII,vector<int> > tp;
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&ki[i]);
	for(int i=1;i<=n;i++) scanf("%d",&vi[i]);
	for(int i=1;i<=n;i++)
		tp[{ki[i],vi[i]}].push_back(i);//将重合的都加到那条直线所对应的人的集合里
		
	line[++cnt]={{0,10000},{0,0}};//因为是保留左边部分，为了保证在第一象限，加一条这样的直线
	line[++cnt]={{0,0},{10000,0}};//同上
	for(map<PII,vector<int> >::iterator it=tp.begin();it!=tp.end();it++)
	{
		PII temp=it->first;
		vector<int> V=it->second;
		line[++cnt]={{0,temp.x},{1,temp.x+temp.y},V};//可以任取这条直线的两个点
	}

	half_plane_intersection();
	return 0;
}
```


---

## 作者：小小小朋友 (赞：0)

## 题目描述

给出n个直线，求有多少个能够在某个时刻最高。

很明显是一个单调栈的题目……不应该评到紫的。

## 思路

这道题本意显然不是让你写平方暴力的……但是这个题的的数据过于水了，很多有一些问题的代码都能通过。据我旁边的同学说，他把大部分题解测了一下，发现有很多问题。

[稍微强一点的](https://www.luogu.com.cn/problem/U185429)

我们按照距离从大到小排序，挨个入栈，显然距离和速度都比栈顶小的没有用了。

其次我们看当前栈顶元素超过栈中第二个元素的时间。

如果说当前要插入的这个元素和栈顶相遇（或者理解为超过栈顶）要早于这个时间，那么可以发现栈顶元素是永无出头之日的，可以出栈。

我们可以写分数来避免精度问题（当然好像不写问题也不大）

还要注意特判掉两个元素完全相同，这个时候我们把刚才的元素再入栈就行了。

有些细节可以看代码。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n;
struct frac{//分数
    int x,y;
    void yf(){
        if(x==0||y==0) return;
        int p=__gcd(x,y);
        x/=p;y/=p;
    }
    frac(int a,int b){x=a;y=b;yf();}
    frac(){x=0;y=1;}
    bool operator<(const frac &b)const{
        return x*b.y<y*b.x;
    }
};
struct node{
    int id,x,y;
    frac t;
    bool operator<(const node &b)const{
        if(x==b.x) return y<b.y;
        return x>b.x;
    }
};
node a[1000005];
deque<node> v;
signed main(){
    ios::sync_with_stdio(0);
    cin>>n;
    for(int i=0;i<n;i++){cin>>a[i].x;a[i].id=i;}
    for(int i=0;i<n;i++){cin>>a[i].y;}
    sort(a,a+n);
    a[0].t=frac(0,1);
    v.push_back(a[0]);
    for(int i=1;i<n;i++){
        if(!v.empty()&&a[i].x==v.back().x&&a[i].y==v.back().y){//判掉完全相同
            v.push_back((node){a[i].id,a[i].x,a[i].y,v.back().t});
            continue;
        }
        if(!v.empty()&&a[i].y<=v.back().y) continue;//判掉打不过
        while(!v.empty()&&frac(v.back().x-a[i].x,a[i].y-v.back().y)<v.back().t){//把永无出头之日的栈顶删掉
            v.pop_back();
        }
        v.push_back((node){a[i].id,a[i].x,a[i].y,frac(v.back().x-a[i].x,a[i].y-v.back().y)});//入栈，记录下与栈顶的元素相遇时间用于比较
    }
    cout<<v.size()<<endl;
    vector<int> ans;
    while(!v.empty()){
        ans.push_back(v.front().id+1);
        v.pop_front();
    }
    sort(ans.begin(),ans.end());
    for(int i=0;i<ans.size();i++) cout<<ans[i]<<' ';
    return 0;
}
```

---

## 作者：EricWay1024 (赞：0)

# 半平面交 + 枚举边界拐点

思路和现有的题解都有些差别，所以稍微写一下。

第$i$辆赛车在$t$时的路程是$x_i(t)=v_i t + x_{0i}$，每辆赛车的$x-t$图是一条直线。在同一坐标系画出所有赛车的$x-t$图，则在任意时刻$t$，领先的赛车就是高度最高的那条直线。对于所有$t$，$\max_{i} x_i(t)$构成一条折线。不难发现这条折线就是$x_i(t) \ge v_i t + x_{0i}$的半平面交的边界。

观察到这里就意识到半平面交是可以做的了。我们需要求的是在所有在某个时刻领先的赛车，其实就是对这条折线的形状作出了贡献的所有的直线。第一种情况，这自然包括在某个区间上成为了折线的直线，这对应的是某辆赛车在某个时间段保持领先。但还需要注意第二种情况，可能某辆赛车只在某个时间点（无限短暂地）保持领先，我们也认为它符合条件（正如样例提供的）。事实上第二种情况包含了第一种情况，因此这促使我们考虑折线上的所有拐点。**对于所有直线，如果折线的某个拐点出现在这条直线上，那么这条直线对应的赛车就符合获奖条件。**

考虑一下时间复杂度。尽管最坏情况拐点数量会几乎等于直线数量，理论时间复杂度是$O(n^2)$。但除非是非常特殊的数据，拐点数量都远小于直线的数量，所以这种做法实测比纯$O(n^2)$算法快不少。

精度问题：无脑开`long double`，`inf`取`1e50`，`eps`取`1e-10`可过。

```cpp

#include <bits/stdc++.h>
using namespace std;
#define rep(i,from,to) for(register int i=(int)(from);i<=(int)(to);++i)
#define rev(i,from,to) for(register int i=(int)(from);i>=(int)(to);--i)
#define For(i,to) for(register int i=0;i<(int)(to);++i)
typedef long long ll;
#define double long double
inline ll read(){
    ll x=0; ll sign=1; char c=getchar();
    while(c>'9' || c<'0') {if (c=='-') sign=-1;c=getchar();}
    while(c>='0' && c<='9'){x=(x<<3)+(x<<1)+c-'0';c=getchar();}
    return x*sign;
}

const double eps=1e-10;
#define inf 1e50 
#define N 11234

int dcmp(double x) {
    if (fabs(x) < eps) return 0;
    else return x < 0 ? -1 : 1;
}
struct Point {
    double x, y;
    Point(double x=0, double y=0):x(x), y(y) { }
};
typedef Point Vector;
Vector operator+ (Vector A, Vector B) { return Vector(A.x+B.x, A.y+B.y); }
Vector operator- (Vector A, Vector B) { return Vector(A.x-B.x, A.y-B.y); }
Vector operator* (Vector A, double p) { return Vector(A.x*p, A.y*p); }
Vector operator/ (Vector A, double p) { return Vector(A.x/p, A.y/p); }
bool operator< (const Point &a, const Point &b) {
    return a.x<b.x || (a.x==b.x && a.y<b.y);
}
bool operator== (const Point &a, const Point &b) {
    return a.x==b.x && a.y==b.y;
}
double Cross(const Vector &A, const Vector &B) {
    return A.x*B.y - A.y*B.x;
}
double Dot(const Vector &A, const Vector &B){
    return A.x*B.x+A.y*B.y;
}
double Length(const Vector &A) {
    return sqrt(Dot(A, A));
}

struct Line {
    Point P;
    Vector v;
    double ang;
    int index;
    Line() {}
    Line(Point P, Vector v, int index):P(P), v(v), index(index) { ang = atan2(v.y, v.x); }
    bool operator< (const Line &L) const  {
        return ang < L.ang;
    }
    double value(double x) {
        return P.y + (x - P.x) * v.y / v.x;
    }
};
bool OnLeft(Line L, Point p) {
    return Cross(L.v, p-L.P) > 0;
}
Point GetIntersection(Line a, Line b) {
    Vector u = a.P-b.P;
    double t = Cross(b.v, u) / Cross(a.v, b.v);
    return a.P+(a.v*t);
}

void HalfplaneIntersection(vector<Line> &L, vector<Point> &ret) {
    sort(L.begin(), L.end());
    Point *p = new Point[N];
    Line *q = new Line[N];
    int first, last;
    q[first=last=0] = L[0];
    for(int i = 1; i < L.size(); i++) {
        while(first < last && !OnLeft(L[i], p[last-1])) --last;
        while(first < last && !OnLeft(L[i], p[first])) ++first;
        q[++last] = L[i];
        if (!dcmp(Cross(q[last].v, q[last-1].v))) {
            --last;
            if(OnLeft(q[last], L[i].P)) q[last] = L[i];
        }
        if (first < last) p[last-1] = GetIntersection(q[last-1], q[last]);
    }
    while(first < last && !OnLeft(q[first], p[last-1])) --last;
    if (last - first <= 1) return;
    p[last] = GetIntersection(q[last], q[first]);
    for(int i = first; i <= last; i++) {
        if (p[i].y >= inf) continue;
        ret.push_back(p[i]);
    }
}

double b[N], k[N];
vector<Point> ret;
vector<int> ans;
vector<Line> L;

int main() {
    int n = read();
    rep(i, 1, n) cin >> b[i];
    rep(i, 1, n) {
        cin >> k[i];
        Line l = Line(Point(0, b[i]), Vector(1, k[i]), i);
        L.push_back(l);
    }
    L.push_back(Line(Point(0, 0), Vector(0, -1), 0));
    L.push_back(Line(Point(0, 0), Vector(1, 0), 0));
    L.push_back(Line(Point(inf, 0), Vector(0, 1), 0));
    L.push_back(Line(Point(0, inf), Vector(-1, 0), 0));

    HalfplaneIntersection(L, ret);

    for(auto l : L) {
        if (l.index == 0) continue;
        for(auto p : ret) {
            if (!dcmp(l.value(p.x) - p.y)) {
                ans.push_back(l.index);
                break;
            }
        }
    }
    sort(ans.begin(), ans.end());
    cout << ans.size() << endl;
    For(i, ans.size()) {
        if (i) cout << " ";
        cout << ans[i];
    }
    cout << endl;

    return 0;
}
```

---


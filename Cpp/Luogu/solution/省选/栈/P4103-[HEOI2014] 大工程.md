# [HEOI2014] 大工程

## 题目描述

国家有一个大工程，要给一个非常大的交通网络里建一些新的通道。

我们这个国家位置非常特殊，可以看成是一个单位边权的树，城市位于顶点上。

在 $2$ 个国家 $a,b$ 之间建一条新通道需要的代价为树上 $a,b$ 的最短路径的长度。

现在国家有很多个计划，每个计划都是这样，我们选中了 $k$ 个点，然后在它们两两之间 新建 $\dbinom{k}{2}$ 条新通道。

现在对于每个计划，我们想知道： 
1. 这些新通道的代价和。
2. 这些新通道中代价最小的是多少。
3. 这些新通道中代价最大的是多少。

## 说明/提示

对于 $100\%$ 的数据，$1\le n\le 10^6,1\le q\le 5\times 10^4,\sum k\le 2\times n$。

每个测试点的具体限制见下表：

| 测试点编号 | $n$ | 特殊性质 |
| :-----------: | :-----------: | :-----------: |
| $1\sim 2$ | $\le 10^4$ |  |
|$3\sim 5$  | $\le 10^5$ | 树的形态是链 |
| $6\sim 7$ | $\le 10^5$ |  |
| $8\sim 10$ | $\le 10^6$ |  |

## 样例 #1

### 输入

```
10 
2 1 
3 2 
4 1 
5 2 
6 4 
7 5 
8 6 
9 7 
10 9 
5 
2 
5 4 
2
10 4 
2 
5 2 
2
6 1 
2 
6 1```

### 输出

```
3 3 3 
6 6 6 
1 1 1 
2 2 2 
2 2 2```

# 题解

## 作者：CrTsIr400 (赞：41)

提供一种全新的虚树构造方法。

以往的虚树构建都是使用这样的方法：

+ 把所有关键点按照 dfs 序排序，并且对相邻的两个点求出 LCA；
+ 然后动态加入节点，维护一条动态的链。
+ 这个过程可以使用单调栈维护从根节点到它的链。

但是，还不够简洁，也不够直观。

先前的做法已经利用了一个性质：

+ 按照 dfs 序，排序之后，相邻的两个关键点的 LCA 一定不重不漏地覆盖了虚树上面的所有点。

那么不妨把**虚树上的所有点**求出来，再按照 dfs 序排序。

此时我们会发现如果按照 dfs 序，从小到大地枚举**虚树上的点**，可以发现当前点（设之为 $x$）和后面的点（设之为 $y$）的路径上，经过的节点的 dfs 序有两种情况：

+ 如果 $y$ 是 $x$ 的后代，那么走过节点的 dfs 序会毫无例外地递增。因为这是一段往下走的旅程。

+ 如果 $y$ 不是 $x$ 的后代，那么必然存在一段往上走、再往下走的旅程，设他们的 LCA 为 $z$，那么从 $x$ 到 $z$ 的过程中，dfs 序递减；而从 $z$ 到 $y$ 的过程之中，dfs 序递增。

通过分析这种情况，我们找到了一种虚树的构造方法：

+ 对所有关键点 dfs 序排序，并且相邻求出 LCA，将 LCA 和关键点都存储在一个数组里；
+ 将这个数组排序并且去重，目的是为了求出虚树上不重复的点按照 dfs 序排序的情况；
+ 在虚树点数组里对相邻的两个点（设 dfs 序较小的节点标号为 $x$，较大的节点编号为 $y$ ）那么连接 LCA 和点 $y$ 。
+ 然后虚树的构造过程就结束了！时间复杂度 $O(m\log m)$ ，其中 $m$ 为虚树点数。

那么证明为什么 dfs 序相邻的节点两两枚举，求得 LCA ，就能构建虚树了呢？

首先发现一个性质，$y$ 是 $x$ 往后第一个 dfn 序的节点，根据上文所提到的性质，dfn 序自 LCA 以来递增。

因为我们知道从 LCA 节点到 $y$ 的过程之中，点的 dfs 序在不断增大。

如果 LCA 和 $y$ 之间有节点 $p$ 的话，那么 $p$ 的 dfs 序必然小于 $y$ 的 dfs 序，而这显然是不符合排序顺序的。

所以，$y$ 和 LCA 之间没有重复的节点。

会不会有遗漏呢？我们发现按照这个构造流程，除了 dfs 序处于第一个的节点，其他都有连向它的边，所以正好构造一棵虚树。

虚树构建部分，具体的代码实现：（来自 OI-wiki ，另外 OI-wiki 那部分也是我补充的）

```cpp
int dfn[maxn];
bool valid[maxn];
int h[maxn], m, a[maxn], len;  // 存储关键点
bool cmp(int x, int y) {
  return dfn[x] < dfn[y];  // 按照 dfn 序排序
}
void build_virtual_tree() {
  sort(h + 1, h + m + 1, cmp);  // 把关键点按照 dfn 序排序
  for (int i = 1; i < m; ++i) {
    a[++len] = h[i];
    a[++len] = lca(h[i], h[i + 1]);  // 插入 lca
  }
  a[++len] = h[m];
  sort(a + 1, a + len + 1, cmp);  // 把所有虚树上的点按照 dfn 序排序
  len = unique(a + 1, a + len + 1) - a - 1;  // 去重
  for (int i = 1, lc; i < len; ++i) {
    lc = lca(a[i], a[i + 1]);
    conn(lc, a[i + 1]);  // 连边，如有边权 就是 distance(lc,a[i+1])
  }
}
```

---

我之前只知道虚树能够解决怎样的问题，但是没有接触过虚树的构造方法，凭借 dfn 序的性质和画图分析，想出来了这种神奇的方法。

一开始我也不敢相信这是对的，于是在实验了数题之后，得出了结论；经过不断地思考，最后推导出来了它的正确性证明。

希望同学们能够大胆猜想，小心证明！


---

## 作者：shadowice1984 (赞：28)

不知到大家知不知道一个姿势叫“虚树”
### 虚树的构建
 _（这里的构建虚树法较之网上的更为简单粗暴，如果想看优雅一点的，自行百度好了）_
 
 先说啥叫虚树，虚树，并不是不存在的树，相反，他是一个大树的一部分，凭借一个虚树，我们可以得知整体的部分信息。如果类比于序列，虚树和大树相当于，子序列和序列，而子树和大树相当于子区间和区间。
 
 好了还是讲这道题吧，我们发现一个有趣的事实sigma k是O(n)的
 如果对于每一次询问做一个树形dp，复杂度过高而无法承受，所以我们要想一个办法，把每一次树形dp的复杂度降到O(k)级别，这样总复杂度降至O(n)
也就是说，我们要从原来的树上“抽取”一只树，在这个树上面跑树形dp。
 
 然后这里就有一个虚树的构建方法了，我们把询问点按照大树上的dfs序排序
 ，之后每个相邻点求一遍lca，对于这些lca和询问点构成的点集，如果我们把树上路径看作边，路径长度看作边权，那么这些点事实上构成了一棵树，而且我们发现这个树上还可以跑树形dp，而对于这道题，维护的信息在带权树上都是可以实现的。
 
 下面是dp做法，
 
 我们设sum\[i]表示以i为根的子树中所有询问点到i的路径长度之和
 
 设siz\[i]表示以i为根的子树中询问点的个数。
 
 min\[i]表示以i为根的子树中询问点到i的最短路径
 
 max\[i]表示以i为根的子树中询问点到i的最长路径
 
 那么我们发现这个是可以向上递推的，我们在这只**虚树上dfs**，遍历点u的所有出边的时候，我们要考虑u的所有儿子形成的类似于v1-u-v2的路径，换言之，我们dp出来的是树上路径的一半，然后通过dfs枚举lca把dp出来的路径接起来
 
 先说min和max吧
 
 我们发现，遍历u的出边时，如果更新u的dp值更新到一半，假设要更新vi这个儿子那么此时min\[u]的值是min\[v1]\~min\[vi-1]的最小值，所以我们可以用min\[vi]+min\[u]更新一发答案，最大值同理的可以如此更新
 
 然后说比较辣手的sum
 
 可能需要一点数学证明
 
 假设点v1,v2的父亲都是u
 有一个以v1为根的子树，里边询问点q1,q2,……qi到u的路径长度记为
 a1,a2……ai，又有一个以v2为根的子树，里边询问点p1,p2……pi到u的路径长度记为b1,b2……bi，
 那么v1中的询问点到v2中询问点的路径长度之和就是
 
 sigma(sigma(ai+bj) \[j∈1~siz\[v2]] ) \[i∈1~siz\[v1]]
 
 =(sum\[v1]+dis(v1,u))\*siz\[v2]+(sum\[v2]+dis(v2,u))\*siz\[v1]
 
 就是v1里的每一条路径被统计了siz\[v2]次，v2中的每一条路径被统计了siz\[v1]次
 
那么我们现在有了一个合并sum\[v1]，sum\[v2]的公式，现在我们要合并u的所有儿子v1,v2,……vi

我们还是考虑dp到了一半的时候，我们现在要更新vi这个儿子，那么sum\[u]其实是sum\[v1]~sum\[vi-1]的和，siz\[u]其实是siz\[v1]~siz\[vi-1]的和，那么我们的v1要和前面的每一个孩子合并一次，利用乘法分配率可得：

答案+=siz\[u]\*(sum\[vi]+dis(vi,u))+siz\[vi]\*sum\[u]

好了现在sum也可以更新了

现在是最后的问题，如何在虚树上dfs？,总不能n^2枚举每个点连边吧，另外空间存储也会很烦，如果你去网上搜索的话，你会发现他们维护了一个什么最右链，像扫描线一样把整只虚树扫了一遍，起到了dfs的效果(蒟蒻表示不会QAQ)

所以这里给大家介绍一个暴力的方法：回想一下dfs的时候，计算机到底干了什么，其实是开了一个栈，按照给定的指令不停pushpop对吧，那么如果我们不知道树的结构，但是却知道dfs的时候什么时候push和pop什么点，再给我们一个栈，我们就可以在不知道树的真实结构的情况下dfs。

这里安利一个叫欧拉序的好东西，普通的dfs序只记录入栈时间，但是欧拉序同时记录入栈和出栈时间，入栈为+，出栈为-，事实上，我们只要手里有欧拉序就可以dfs，我们发现，虚树和原树的dfs相对次序是完全一样的，因此，我们先把询问点dfs序排序一遍，之后求出lca，最后把整个点集按照欧拉序排序(记得一个点加两次)，我们就得到了虚树的欧拉序，开个栈暴力dfs一一边即可，也就是说，虚树的本质，就是每次在原树上进行部分的dfs

(复杂度NlogN？第一如果你不嫌麻烦可以基数排序+TARJAN离线lca，第二如果你用的是快排+倍增lca的话一堆nlogn加起来比总共的nlogn会小很多，第三就算卡你4s的时限也是随便过)

上代码~

```C
#include<cstdio>
#include<algorithm>
#include<vector>
#include<stack>
using namespace std;
typedef long long ll;
const int N=1000010;
int n;int m;
struct data{int v;int nxt;}edge[2*N];
int alist[N];int cnt;
inline void add(int u,int v){edge[++cnt].v=v;edge[cnt].nxt=alist[u];alist[u]=cnt;}
int dfin[N];int dfou[N];int dfu;int fa[22][N];bool book[N];ll dep[N];
void dfs(int x)
{
    for(int i=0;fa[i][x];i++){fa[i+1][x]=fa[i][fa[i][x]];}//倍增预处理 
    dfin[x]=++dfu;book[x]=true;int nxt=alist[x];//记录入栈顺序 
    while(nxt)
    {
        int v=edge[nxt].v;
        if(!book[v]){dep[v]=dep[x]+1;fa[0][v]=x;dfs(v);}
        nxt=edge[nxt].nxt;
    }dfou[x]=++dfu;return;//记录出栈顺序 
}
inline int lca(int x,int y)//倍增求lca 
{
    if(dep[x]<dep[y])swap(x,y);int del=dep[x]-dep[y];
    for(int i=0;del;del>>=1,i++){if(del&1)x=fa[i][x];}if(x==y){return x;}
    for(int i=21;i>=0;i--){if(fa[i][x]!=fa[i][y]){x=fa[i][x],y=fa[i][y];}}
    return fa[0][x];
}
inline bool cmp(int x,int y)//按欧拉序排序的比较函数 
{
    int key1=(x>0)?dfin[x]:dfou[-x];
    int key2=(y>0)?dfin[y]:dfou[-y];
    return key1<key2;
}
int tp[4*N];ll sum[N];ll siz[N];ll mi[N];ll ma[N];bool vis[N];
ll tot[N];stack <int> s;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<n;i++){int u;int v;scanf("%d%d",&u,&v);add(u,v);add(v,u);}
    dfs(1);//先预处理 
    scanf("%d",&m);
    for(int i=1;i<=n;i++){mi[i]=0x7f7f7f7f7f;}
    for(int i=1;i<=m;i++)
    {
        ll ans1=0;ll ans2=0x7f7f7f7f7f;ll ans3=0;
        int k;scanf("%d",&k);int cnt=k;
        for(int i=1;i<=k;i++)
        {scanf("%d",&tp[i]);mi[tp[i]]=0;siz[tp[i]]=1;vis[tp[i]]=true;}//处理dp的边界条件 
        sort(tp+1,tp+k+1,cmp);tp[++cnt]=-tp[1];//这里先按dfs序排一波 
        for(int i=2;i<=k;i++)
        {
            int lc=lca(tp[i],tp[i-1]);tp[++cnt]=-tp[i];//计算lca，每一个点正负各插一遍 
            if(!vis[lc]){tp[++cnt]=lc;tp[++cnt]=-lc;vis[lc]=true;}
        }
        sort(tp+1,tp+cnt+1,cmp);//强行求出欧拉序 
        for(int i=1;i<=cnt;i++)
        {
            if(tp[i]>0){s.push(tp[i]);continue;}//无脑入栈 
            if(tp[i]<0)
            {
                int now=s.top();s.pop();//出栈的话，这个点和当前栈顶肯定是父子关系，开始dp 
                if(!s.empty())//特判下pop根的情况 
                {
                    int to=s.top();ll dis=(dep[now]-dep[to]);//计算dis 
                    sum[now]+=siz[now]*dis;//所有路径拔高 
                    ans1+=siz[to]*sum[now]+siz[now]*sum[to];//更新答案 
                    siz[to]+=siz[now];sum[to]+=sum[now];//更新sum 
                    mi[now]+=dis;ans2=min(ans2,mi[to]+mi[now]);mi[to]=min(mi[to],mi[now]);//更新min 
                    ma[now]+=dis;ans3=max(ans3,ma[to]+ma[now]);ma[to]=max(ma[to],ma[now]);//更新max 
                }
                siz[now]=0;sum[now]=0;mi[now]=0x7f7f7f7f7f;ma[now]=0;vis[now]=false;//出栈的时候记得清空信息 
            }
        }
        printf("%lld %lld %lld\n",ans1,ans2,ans3);//输出答案 
    }return 0;//拜拜程序~ 
}
```





 
 


---

## 作者：MikukuOvO (赞：23)

首先将虚树建出来，然后我们分别考虑三个问题。

求和：

我们定义$g[u]$表示以$u$为根的子树中所有关键点到$u$的距离和。

我们按照顺序考虑$u$的每一颗子树，这样我们只需要统计不同子树中关键点的贡献即可，不难得到：

$$tot+=(g[u]+siz[u]\times l)\times siz[v]+g[v]\times siz[u]$$

$siz[u]$表示以$u$为根的子树中关键点的个数。

最大值&最小值：

定义$mx[u]/mn[u]$表示以$u$为根的子树中到$u$最远/最近的关键点的距离，按照上面类似的方法更新答案即可。

```cpp
const int N=1e6+5;

int n,m,k,cnt,id,top;
int dep[N],f[N][21],dfn[N],head[N],siz[N],h[N],stk[N];
ll g[N],mn[N],mx[N];
ll tot,mnans,mxans;
bool tag[N];
struct edge
{
	int to,nxt;
};
edge e[N<<1];

void add(int x,int y)
{
	e[++cnt].to=y;
	e[cnt].nxt=head[x];
	head[x]=cnt;
}
void link(int x,int y)
{
	add(x,y),add(y,x);
}
void dfs(int x,int fa,int d)
{
	dep[x]=d,f[x][0]=fa,dfn[x]=++id;
	for(int i=1;i<=20;++i) f[x][i]=f[f[x][i-1]][i-1];
	for(int i=head[x];i;i=e[i].nxt)
	{
		int v=e[i].to;
		if(v==fa) continue;
		dfs(v,x,d+1);
	}
}
int lca(int x,int y)
{
	if(dep[x]<dep[y]) swap(x,y);
	for(int i=20;i>=0;--i) if(dep[f[x][i]]>=dep[y]) x=f[x][i];
	if(x==y) return x;
	for(int i=20;i>=0;--i) if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];
	return f[x][0];
}
void dp(int x)
{
	siz[x]=tag[x],g[x]=0;
	if(tag[x]) mx[x]=mn[x]=0;
	else mn[x]=INF,mx[x]=-INF;
	for(int i=head[x];i;i=e[i].nxt)
	{
		int v=e[i].to;
		dp(v);
		ll l=dep[v]-dep[x];
		tot+=(g[x]+siz[x]*l)*siz[v]+g[v]*siz[x];
		siz[x]+=siz[v],g[x]+=g[v]+l*siz[v];
		mnans=min(mnans,mn[x]+mn[v]+l),mxans=max(mxans,mx[x]+mx[v]+l);
		mn[x]=min(mn[x],mn[v]+l),mx[x]=max(mx[x],mx[v]+l);
	}
}
int main()
{
	fio();
	gi(n);
	for(int i=1,x,y;i<=n-1;++i) gi(x,y),link(x,y);
	dfs(1,0,1);
	gi(m);
	while(m--)
	{
		gi(k);
		for(int i=1;i<=k;++i) gi(h[i]),tag[h[i]]=true;
		sort(h+1,h+k+1,[](int x,int y){
			return dfn[x]<dfn[y];
		});
		stk[top=1]=1,cnt=0,head[1]=0;
		for(int i=1;i<=k;++i)
		{
			if(h[i]!=1)
			{
				int l=lca(h[i],stk[top]);
				if(l!=stk[top])
				{
					while(dfn[l]<dfn[stk[top-1]]) add(stk[top-1],stk[top]),--top;
					if(dfn[l]!=dfn[stk[top-1]]) head[l]=0,add(l,stk[top]),stk[top]=l;
					else add(l,stk[top--]);
				}
				head[h[i]]=0,stk[++top]=h[i];
			}
		}
		for(int i=1;i<top;++i) add(stk[i],stk[i+1]);
		tot=0,mnans=INF,mxans=-INF;
		dp(1);
		print(tot),pc(' '),print(mnans),pc(' '),print(mxans),pc(10);
		for(int i=1;i<=k;++i) tag[h[i]]=false;
	}
	end();
}
```

---

## 作者：hzlqwq (赞：18)

[题目链接](https://www.luogu.com.cn/problem/P4103)

这题有个弱化版是 ABC359G，笔者没学过虚树，在赛时用[树上启发式合并（dsu on tree）](https://oi-wiki.org/graph/dsu-on-tree/)过了，后来发现这题也能这样做，于是写了本篇题解做分享。

---

首先，我们可以把操作离线下来，挂到每个点上，问题就变成了每个点有一些属性，总属性数量是 $O(n)$ 的，然后求每种属性的所有点的两两距离之和、最大值和最小值。

路径统计考虑枚举 lca。枚举到 $u$ 作为 lca 时，我们逐个遍历它的子树，先利用桶内信息计算当前子树的贡献，再把当前子树的信息添加到桶内。最后别忘了统计 $u$ 和子树内其他点对答案的贡献。

具体地，我们用 $sd_i$ 存储属性为 $i$ 的点的深度之和，$mxd_i$ 存储最大深度，$mnd_i$ 存储最小深度，$cnt_i$ 存储节点个数。那么假设现在枚举 $u$ 为 lca，统计到了点 $j$ 的属性 $i$，则对距离和的贡献为 $sd_i+cnt_i(dep_j-2dep_u)$，对最大距离的贡献为 $mxd_i+dep_j-2dep_u$，对最小距离的贡献为 $mnd_i+dep_j-2dep_u$。

加入一个点时也类似，根据定义更新信息即可。

暴力做是 $O(n^2)$ 的，加上 dsu on tree 就是 $O(n\log n)$ 的了。

具体地，因为一个子树的计算量是点数 $+$ 每个点的属性个数总和，我们根据这个计算量，求出每个点的重儿子，再 dsu on tree 就对了。

总时间复杂度 $O(q+n\log n)$。跑的蛮快的。

> 删除一个子树的信息时，要把涉及到的信息直接初始化掉，不然最大最小值没法处理。

```cpp
#include <iostream>
#include <vector>

using namespace std;

const int N = 1e6 + 5;

int n, q, sz[N], son[N], dep[N];
vector<int> e[N], qry[N];
int mn[N], mx[N], mxd[N], mnd[N], cnt[N];
long long sum[N], sd[N];

void dfs(int u, int fa) // 找出重儿子，预处理深度
{
    sz[u] = 1 + qry[u].size(), dep[u] = dep[fa] + 1;
    for (auto j : e[u])
        if (j ^ fa)
        {
            dfs(j, u), sz[u] += sz[j];
            if (sz[j] > sz[son[u]])
                son[u] = j;
        }
}

void add(int u, int fa) // 添加子树信息
{
    for (auto i : qry[u])
        mxd[i] = max(mxd[i], dep[u]), mnd[i] = min(mnd[i], dep[u]), sd[i] += dep[u], cnt[i]++;
    for (auto j : e[u])
        if (j ^ fa)
            add(j, u);
}

void del(int u, int fa) // 清除子树信息
{
    for (auto i : qry[u])
        mxd[i] = -1e9, mnd[i] = 1e9, sd[i] = cnt[i] = 0; // 直接初始化掉
    for (auto j : e[u])
        if (j ^ fa)
            del(j, u);
}

void cal(int u, int fa, int lca) // 计算子树贡献
{
    for (auto i : qry[u])
        sum[i] += sd[i] + cnt[i] * (dep[u] - 2ll * lca), mx[i] = max(mx[i], mxd[i] + dep[u] - 2 * lca),
                                                         mn[i] = min(mn[i], mnd[i] + dep[u] - 2 * lca);
    for (auto j : e[u])
        if (j ^ fa)
            cal(j, u, lca);
}

void dsu(int u, int fa) // 树上启发式合并
{
    for (auto j : e[u])
        if (j ^ fa && j ^ son[u])
            dsu(j, u), del(j, u);
    if (son[u])
        dsu(son[u], u);
    for (auto j : e[u])
        if (j ^ fa && j ^ son[u])
            cal(j, u, dep[u]), add(j, u);
    for (auto i : qry[u])
        sum[i] += sd[i] - 1ll * cnt[i] * dep[u], mx[i] = max(mx[i], mxd[i] - dep[u]),
                                                 mn[i] = min(mn[i], mnd[i] - dep[u]);
    for (auto i : qry[u])
        mxd[i] = max(mxd[i], dep[u]), mnd[i] = min(mnd[i], dep[u]), sd[i] += dep[u], cnt[i]++;
}

int main()
{
    ios::sync_with_stdio(0), cin.tie(0);
    cin >> n;
    for (int i = 1, a, b; i < n; i++)
        cin >> a >> b, e[a].push_back(b), e[b].push_back(a);
    cin >> q;
    for (int i = 1, k, p; i <= q; i++)
    {
        cin >> k, mn[i] = mnd[i] = 1e9, mx[i] = mxd[i] = -1e9; // 记得初始化
        while (k--)
            cin >> p, qry[p].push_back(i);
    }
    dfs(1, 0), dsu(1, 0);
    for (int i = 1; i <= q; i++)
        cout << sum[i] << " " << mn[i] << " " << mx[i] << "\n";
    return 0;
}
```

---

## 作者：何俞均 (赞：17)

广告：食用[$blog$](https://www.cnblogs.com/heyujun/p/10360235.html)体验更佳

先建虚树，下面所有讨论均是在虚树上的。

对于第一问：直接统计所有树边对答案的贡献即可。

对于第$2,3$问：记$f[x]$表示在$x$的子树内离$x$距离最远的关键点的距离，$g[x]$表示在$x$的子树内离$x$距离最近的关键点的距离。

具体更新以$f[x]$为例：

访问到$v\in son_x$，

如果以前访问过的点中有关键点，则有$f[x]=max(f[x],f[v]+dis(u,v)+f[x])$，

每次还要向上传递，即$f[x]=max(f[x],f[v]+dis(u,v))$。

代码

```cpp
#include <iostream> 
#include <cstdio> 
#include <cstdlib> 
#include <cstring> 
#include <cmath> 
#include <algorithm> 
using namespace std; 
inline int gi() { 
    register int data = 0, w = 1; 
    register char ch = 0; 
    while (!isdigit(ch) && ch != '-') ch = getchar(); 
    if (ch == '-') w = -1, ch = getchar(); 
    while (isdigit(ch)) data = 10 * data + ch - '0', ch = getchar(); 
    return w * data; 
} 
const int MAX_N = 1e6 + 5; 
struct Graph { int to, next; } e[MAX_N << 2];
int fir1[MAX_N], fir2[MAX_N], e_cnt;
void clearGraph() {
	memset(fir1, -1, sizeof(fir1)); 
	memset(fir2, -1, sizeof(fir2)); 
} 
void Add_Edge(int *fir, int u, int v) { 
	e[e_cnt] = (Graph){v, fir[u]}; 
	fir[u] = e_cnt++; 
}
namespace Tree { 
	int fa[MAX_N], dep[MAX_N], size[MAX_N], top[MAX_N], son[MAX_N], dfn[MAX_N], tim; 
	void dfs1(int x) {
		dfn[x] = ++tim; 
	    size[x] = 1, dep[x] = dep[fa[x]] + 1; 
		for (int i = fir1[x]; ~i; i = e[i].next) {
			int v = e[i].to; if (v == fa[x]) continue; 
			fa[v] = x; dfs1(v); size[x] += size[v]; 
			if (size[v] > size[son[x]]) son[x] = v; 
		} 
	} 
	void dfs2(int x, int tp) {
		top[x] = tp; 
	    if (son[x]) dfs2(son[x], tp); 
		for (int i = fir1[x]; ~i; i = e[i].next) {
			int v = e[i].to; if (v == fa[x] || v == son[x]) continue; 
			dfs2(v, v); 
		} 
	} 
	int LCA(int x, int y) { 
		while (top[x] != top[y]) { 
			if (dep[top[x]] < dep[top[y]]) swap(x, y); 
			x = fa[top[x]]; 
		} 
		return dep[x] < dep[y] ? x : y; 
	} 
} 
using Tree::LCA; using Tree::dfn; using Tree::dep; 
int N, M, K, a[MAX_N];
bool key[MAX_N];
int f[MAX_N], g[MAX_N], s[MAX_N]; 
bool cmp(int i, int j) { return dfn[i] < dfn[j]; } 
void build() { 
	static int stk[MAX_N], top; 
	sort(&a[1], &a[K + 1], cmp); 
	stk[top = 1] = 1; fir2[1] = -1;
	e_cnt = 0; 
	for (int i = 1; i <= K; i++) {
		key[a[i]] = 1; 
		if (a[i] == 1) continue; 
		int lca = LCA(stk[top], a[i]); 
		if (lca != stk[top]) { 
			while (dfn[lca] < dfn[stk[top - 1]]) { 
				int u = stk[top], v = stk[top - 1]; 
				Add_Edge(fir2, u, v), Add_Edge(fir2, v, u); 
				--top; 
			} 
			if (dfn[lca] > dfn[stk[top - 1]]) { 
				fir2[lca] = -1; int u = stk[top], v = lca; 
				Add_Edge(fir2, u, v), Add_Edge(fir2, v, u); 
				stk[top] = lca; 
			}
			else { 
				int u = lca, v = stk[top--]; 
				Add_Edge(fir2, u, v), Add_Edge(fir2, v, u); 
			} 
		}
		fir2[a[i]] = -1, stk[++top] = a[i]; 
	} 
	for (int i = 1; i < top; i++) {
		int u = stk[i], v = stk[i + 1]; 
		Add_Edge(fir2, u, v), Add_Edge(fir2, v, u); 
	} 
} 
long long ans1;
int ans2, ans3; 
void Dp(int x, int fa) { 
	s[x] = key[x], f[x] = 0, g[x] = (key[x] ? 0 : 1e9); 
	for (int i = fir2[x]; ~i; i = e[i].next) { 
		int v = e[i].to; if (v == fa) continue; 
		Dp(v, x); 
	} 
	for (int i = fir2[x]; ~i; i = e[i].next) { 
		int v = e[i].to, w = dep[v] - dep[x]; 
		if (v == fa) continue; 
		ans1 += 1ll * (K - s[v]) * s[v] * w; 
		if (s[x] > 0) { 
			ans2 = min(ans2, g[x] + w + g[v]); 
			ans3 = max(ans3, f[x] + w + f[v]); 
		} 
		g[x] = min(g[x], g[v] + w); 
	    f[x] = max(f[x], f[v] + w);
		s[x] += s[v]; 
	} 
	key[x] = 0; 
} 
int main () {
#ifndef ONLINE_JUDGE 
    freopen("cpp.in", "r", stdin); 
#endif
	clearGraph(); 
	N = gi(); 
	for (int i = 1; i < N; i++) { 
		int u = gi(), v = gi(); 
		Add_Edge(fir1, u, v), Add_Edge(fir1, v, u); 
	}
	Tree::dfs1(1), Tree::dfs2(1, 1); 
	M = gi(); 
	while (M--) { 
		ans1 = 0, ans2 = 1e9, ans3 = 0; 
		K = gi(); for (int i = 1; i <= K; i++) a[i] = gi(); 
		build(); 
		Dp(1, 0); 
		printf("%lld %d %d\n", ans1, ans2, ans3); 
	} 
	return 0; 
} 
```

---

## 作者：localhost (赞：5)

先来考虑普通的**树型dp**怎么做

设$SZ_x$表示$x$的子树中有多少个查询点,$d_x$表示$x$的深度

1. 这些新通道的代价和

    考虑每条边要被统计多少次: 

    假设$y$是$x$的某个子节点,$x\leftrightarrow y$会被统计$(k-SZ_y)\times SZ_y$次,

    (起点可以是$y$的子树中任一查询点,终点可以是$y$子树外的任一查询点,这样的话路径必然经过$x\leftrightarrow y$)

    那么贡献是$(d_y-d_x)\times (k-SZ_y)\times SZ_y$

2. 这些新通道中代价最小/大的是多少

    有点类似树型dp求树的直径

    $x$的子树中最长的路径是: 子树中深度最大的查询点的深度+子树中深度次大的查询点的深度(若$x$是查询点则包括$x\leftrightarrow x$,深度为$0$)

    最短路径和上面的求法类似
   
套上**虚树**就可以解决这道题了

如果不懂的话就看代码咯

```cpp
#include<bits/stdc++.h>
#pragma GCC optimize(3)
#define il __inline__ __attribute__ ((always_inline))
typedef long long ll;
#define ll long long
#define rg register
#define For(i,x,y) for(int i(x);i<=y;++i)
#define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)
il int MAX(int x,int y){return x>y?x:y;}
il int MIN(int x,int y){return x<y?x:y;}
namespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x/=10;while(t--)pt(a[t]+'0');}}using namespace IO;
const int N=1000011,inf=1000000007;
int n,k,cnt=0,head[N];
struct edge{int to,nxt;}e[N<<1];
il void add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}
int siz[N],top[N],f[N],d[N],dfn[N],sz=0;
void dfs(int x){
    siz[x]=1;dfn[x]=++sz;
    fl(i,x)if(to!=f[x]){
        f[to]=x;
        d[to]=d[x]+1;
        dfs(to);
        siz[x]+=siz[to];
    }
}
void bt(int x,int tp){
    top[x]=tp;int k=0;
    fl(i,x)if(to!=f[x]&&siz[to]>siz[k])k=to;
    if(k)bt(k,tp);
    fl(i,x)if(!top[to])bt(to,to);
}
il int lca(int x,int y){
    while(top[x]!=top[y])
        d[top[x]]>d[top[y]]?x=f[top[x]]:y=f[top[y]];
    return d[x]<d[y]?x:y;
}
int a[N],st[N],tp,SZ[N],mx_d[N],mi_d[N],a1,a2;
ll ans;
bool v[N];
il bool cmp(int x,int y){return dfn[x]<dfn[y];}
void dp(int x){
    if(v[x])SZ[x]=1,mx_d[x]=d[x],mi_d[x]=d[x];
    else    SZ[x]=0,mx_d[x]=-inf,mi_d[x]=inf;
    int p1=-inf,p2=-inf,q1=inf,q2=inf;
    fl(i,x){
        dp(to);

        mx_d[x]=MAX(mx_d[x],mx_d[to]);
        if(mx_d[to]>=p1)p2=p1,p1=mx_d[to];
        else p2=MAX(p2,mx_d[to]);

        mi_d[x]=MIN(mi_d[x],mi_d[to]);
        if(mi_d[to]<=q1)q2=q1,q1=mi_d[to];
        else q2=MIN(q2,mi_d[to]);

        ans+=1ll*(k-SZ[to])*SZ[to]*(d[to]-d[x]);
        SZ[x]+=SZ[to];
    }
    a1=MIN(a1,q1+q2-2*d[x]);
    if(v[x])a1=MIN(a1,q1-d[x]);

    a2=MAX(a2,p1+p2-2*d[x]);
    if(v[x])a2=MAX(a2,p1-d[x]);
    head[x]=0;
}
int main(){
    in(n);
    int q,x,y,t;
    For(i,1,n-1)in(x),in(y),add(x,y),add(y,x);
    d[1]=1;dfs(1);bt(1,1);
    cnt=0;memset(head,0,sizeof head);
    in(q);
    while(q--){
        in(k);
        For(i,1,k)in(a[i]),v[a[i]]=1;
        std::sort(a+1,a+k+1,cmp);
        cnt=0;st[tp=1]=1;
        For(i,1,k){//构建虚树
            x=a[i];t=lca(x,st[tp]);
            while(d[t]<d[st[tp]]){
                if(d[t]>=d[st[tp-1]]){
                    add(t,st[tp--]);
                    if(t!=st[tp])st[++tp]=t;
                    break;
                }
                add(st[tp-1],st[tp]),--tp;
            }
            if(st[tp]!=x)st[++tp]=x;
        }
        while(tp>1)add(st[tp-1],st[tp]),--tp;
        ans=0;a1=inf,a2=0;
        dp(1);
        out(ans),pt(' '),out(a1),pt(' '),out(a2),pt('\n');
        For(i,1,k)v[a[i]]=0;
    }
    flush();
}
```

---

## 作者：tth37 (赞：3)

本题用到了一些点分治的思想。

考虑 $q=1$ 的情况。一种朴素的做法是：枚举当前节点的所有子节点，并计算子树间关键点形成的路径、更新答案。但是本题与一般点分治题目略有不同，我们可以通过预处理子树信息来优化点分治过程。

稍加观察可以发现，只需预处理每个子树中树根到关键点的最小距离、最大距离，以及子树中关键点的个数、所有关键点到树根的距离总和即可完成点分治全部过程，时间复杂度 $O(n)$ 。

对于 $q\not=1$  的情况，观察到 $\Sigma{k}$ 与 $n$ 同阶，可以对每次查询建立一棵虚树，在虚树上点分治即可。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1000005;
typedef long long ll;
struct Edge {int v, w; Edge(int a, int b) {v = a, w = b;}};
struct Key {int u, dfn;}keys[MAXN];
bool cmp(Key a, Key b) {return a.dfn < b.dfn;}
vector<Edge> G[MAXN], VT[MAXN];
int N, Q, K;
int f[MAXN][21], dep[MAXN], dfn[MAXN], dfn_idx;
int lg[MAXN];
bool h[MAXN];
ll g[MAXN];
int m[MAXN], n[MAXN];
int c[MAXN];
ll ans1;
int ans2, ans3;

inline void dfs0(int u, int fa) {
    dfn[u] = ++dfn_idx;
    dep[u] = dep[fa] + 1;
    f[u][0] = fa;
    for (int i = 1; i <= lg[dep[u]]; ++i)
        f[u][i] = f[f[u][i - 1]][i - 1];
    for (vector<Edge>::iterator it = G[u].begin(); it != G[u].end(); it++) {
        int v = it -> v;
        if (v == fa) continue;
        dfs0(v, u);
    }
}

void dfs1(int u) {
    g[u] = 0;
    c[u] = h[u];
    m[u] = 0x3f3f3f3f;
    n[u] = -0x3f3f3f3f;
    if (h[u]) m[u] = n[u] = 0;
    for (vector<Edge>::iterator it = VT[u].begin(); it != VT[u].end(); it++) {
        int v = it -> v, w = it -> w;
        dfs1(v);
        c[u] += c[v];
        g[u] += g[v] + 1ll * w * c[v];
        m[u] = min(m[u], w + m[v]);
        n[u] = max(n[u], w + n[v]);
    }
}

void dfs2(int u) {
    ll sum = 0;
    int cnt = h[u];
    int minn = 0x3f3f3f3f, maxx = -0x3f3f3f3f;
    if (h[u]) minn = maxx = 0;
    for (vector<Edge>::iterator it = VT[u].begin(); it != VT[u].end(); it++) {
        int v = it -> v, w = it -> w;
        ans1 += 1ll * sum * c[v] + 1ll * w * cnt * c[v] + 1ll * g[v] * cnt;
        ans2 = min(ans2, minn + w + m[v]);
        ans3 = max(ans3, maxx + w + n[v]);
        sum += g[v] + 1ll * c[v] * w;
        cnt += c[v];
        minn = min(minn, w + m[v]);
        maxx = max(maxx, w + n[v]);
        dfs2(v);
    }
    h[u] = 0;
    VT[u].clear();
}

inline int Lca(int u, int v) {
    if (dep[u] < dep[v]) swap(u, v);
    while (dep[u] > dep[v]) u = f[u][lg[dep[u] - dep[v]]];
    if (u == v) return u;
    for (int i = lg[dep[u]]; i >= 0; --i) {
        if (f[u][i] != f[v][i]) u = f[u][i], v = f[v][i];
    }
    return f[u][0];
}

int main() {
    for (register int i = 2; i <= 1000000; ++i)
        lg[i] = lg[i >> 1] + 1;
    scanf("%d", &N);
    for (register int i = 1; i < N; ++i) {
        int u, v;
        scanf("%d%d", &u, &v);
        G[u].push_back(Edge(v, 1));
        G[v].push_back(Edge(u, 1));
    }
    dfs0(1, 0);
    scanf("%d", &Q);
    while (Q--) {
        scanf("%d", &K);
        for (register int i = 1; i <= K; ++i) {
            int u;
            scanf("%d", &u);
            h[u] = 1;
            keys[i].u = u, keys[i].dfn = dfn[u];
        }
        sort(keys + 1, keys + K + 1, cmp);
        stack<int> s;
        s.push(1);
        for (register int i = 1; i <= K; ++i) {
            int u = keys[i].u;
            if (u == 1) continue;
            int lca = Lca(u, s.top());
            while (s.top() != lca) {
                int tmp = s.top(); s.pop();
                if (dfn[s.top()] < lca) s.push(lca);
                VT[s.top()].push_back(Edge(tmp, dep[tmp] - dep[s.top()]));
            }
            s.push(u);
        }
        while (s.top() != 1) {
            int tmp = s.top(); s.pop();
            VT[s.top()].push_back(Edge(tmp, dep[tmp] - dep[s.top()]));
        }
        dfs1(1);
        ans1 = ans3 = 0;
        ans2 = 0x3f3f3f3f;
        dfs2(1);
        printf("%lld %d %d\n", ans1, ans2, ans3);
    }
    return 0;
}
```



---

## 作者：gorokokoro (赞：3)

由于笔者比较蠢想不到 $\text{DFS}$ 两次，因此用了一个很暴力的做法……

先构建出虚树，然后就相当于问树上所有黑点之间路径权值和

点对问题考虑点分治，然后就可以做了

每次暴力维护当前和，结点数，$\min/\max$ 即可

复杂度也是 $\mathrm O(n\log n)$

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <climits>
#include <vector>
#include <utility>
#define N 1000020
#define M 20
using namespace std;

extern int l[N];
extern int k, a[N];
extern bool b[N], u[N];

extern int GetLCA(int, int);
extern int Distance(int, int);

namespace Virtual
{
    vector<pair<int, int> > e[N];
    vector<int> c, s;

    bool Compare(int a, int b)
    {
        return l[a] < l[b];
    }

    void AddEdge(int u, int v)
    {
        int w;

        w = Distance(u, v);
        e[u].push_back(make_pair(v, w));
        e[v].push_back(make_pair(u, w));
        c.push_back(u);
        c.push_back(v);
        // printf("%d <-> %d : %d\n", u + 1, v + 1, w);

        return;
    }

    void InitVirtual(void)
    {
        int i, t, p, q;

        for(i = 0; i < (signed)c.size(); i ++)
        {
            u[c.at(i)] = false;
            e[c.at(i)].clear();
        }
        c.clear();

        sort(a, a + k, Compare);
        for(i = 0; i < k; i ++)
        {
            if(!s.empty())
            {
                t = GetLCA(a[i], s.back());
                if(t != s.back())
                    while(s.size() > 1)
                    {
                        p = s.back();
                        s.pop_back();
                        q = s.back();

                        if(l[q] < l[t])
                        {
                            AddEdge(p, t);
                            s.push_back(t);
                            break;
                        }
                        AddEdge(p, q);

                        if(l[q] == l[t])
                            break;
                    }
            }
            s.push_back(a[i]);
        }

        while(!s.empty())
        {
            p = s.back();
            s.pop_back();
            if(!s.empty())
                AddEdge(p, s.back());
        }

        return;
    }
}

namespace G
{
    using Virtual::e;

    int f[N], g[N];
    vector<int> v;

    void DFS(int x, int p, bool *u)
    {
        int i;

        // printf("VIS %d\n", x+1);
        v.push_back(x);
        for(i = g[x] = 0, f[x] = 1; i < (signed)e[x].size(); i ++)
            if(e[x].at(i).first != p && !u[e[x].at(i).first])
            {
                DFS(e[x].at(i).first, x, u);
                f[x] += f[e[x].at(i).first];
                g[x] = max(g[x], f[e[x].at(i).first]);
            }

        return;
    }

    int G(int x, bool *u)
    {
        int i, o;

        v.clear();
        DFS(x, x, u);
        for(i = 1, o = v.at(0); i < (signed)v.size(); i ++)
            if(max(g[o], (signed)v.size() - f[o]) > max(g[v.at(i)], (signed)v.size() - f[v.at(i)]))
                o = v.at(i);

        return o;
    }
}

namespace Divide
{
    using Virtual::e;

    long long o[3], v[3];
    int c;

    void Query(int x, int p, int d)
    {
        int i;

        if(b[x])
        {
            o[0] += (long long)d * c + v[0];
            o[1] = min(o[1], d + v[1]);
            o[2] = max(o[2], d + v[2]);
        }

        for(i = 0; i < (signed)e[x].size(); i ++)
            if(!u[e[x].at(i).first] && e[x].at(i).first != p)
                Query(e[x].at(i).first, x, d + e[x].at(i).second);

        return;
    }

    void Update(int x, int p, int d)
    {
        int i;

        if(b[x])
        {
            v[0] += d;
            c ++;
            v[1] = min(v[1], (long long)d);
            v[2] = max(v[2], (long long)d);
        }

        for(i = 0; i < (signed)e[x].size(); i ++)
            if(!u[e[x].at(i).first] && e[x].at(i).first != p)
                Update(e[x].at(i).first, x, d + e[x].at(i).second);

        return;
    }

    void DFS(int x)
    {
        int i;

        x = G::G(x, u);
        u[x] = true;
        // printf("G %d\n", x+1);

        v[0] = c = 0;
        v[1] = INT_MAX;
        v[2] = INT_MIN;
        if(b[x])
        {
            c = 1;
            v[1] = v[2] = 0;
        }

        for(i = 0; i < (signed)e[x].size(); i ++)
            if(!u[e[x].at(i).first])
            {
                Query (e[x].at(i).first, x, e[x].at(i).second);
                Update(e[x].at(i).first, x, e[x].at(i).second);
            }

        for(i = 0; i < (signed)e[x].size(); i ++)
            if(!u[e[x].at(i).first])
                DFS(e[x].at(i).first);

        return;
    }
}

vector<int> e[N];
int f[M][N], d[N], l[N];
int k, a[N];
bool b[N], u[N];

int Scan(void)
{
    int c, s;

    for(s = 0; (c = getchar()) < '0' || c > '9'; )
        ;
    do
        s = s * 10 + c - 48;
    while((c = getchar()) >= '0' && c <= '9');

    return s;
}

void InitLCA(int x, int p)
{
    static int k;
    int i;

    l[x] = k ++;
    for(i = 1, f[0][x] = p; i < M; i ++)
        f[i][x] = f[i - 1][f[i - 1][x]];

    for(i = 0; i < (signed)e[x].size(); i ++)
        if(e[x].at(i) != p)
        {
            d[e[x].at(i)] = d[x] + 1;
            InitLCA(e[x].at(i), x);
        }

    return;
}

int GetLCA(int u, int v)
{
    int i, t;

    if(d[u] < d[v])
        swap(u, v);
    t = d[u] - d[v];

    for(i = 0; i < M; i ++)
        if(t & (1 << i))
            u = f[i][u];
    if(u == v)
        return u;

    for(i = M - 1; i > -1; i --)
        if(f[i][u] != f[i][v])
        {
            u = f[i][u];
            v = f[i][v];
        }

    return f[0][u];
}

inline int Distance(int u, int v)
{
    return d[u] + d[v] - d[GetLCA(u, v)] * 2;
}

int main(void)
{
    int n, m, u, v;
    int i;

    n = Scan();
    for(i = 1; i < n; i ++)
    {
        u = Scan() - 1;
        v = Scan() - 1;
        e[u].push_back(v);
        e[v].push_back(u);
    }
    InitLCA(0, 0);
    // while(1){cin>>u>>v;cout<<GetLCA(u-1,v-1)+1<<' '<<Distance(u-1,v-1)<<endl;}

    m = Scan();
    while(m --)
    {
        k = Scan();
        for(i = 0; i < k; i ++)
            b[a[i] = Scan() - 1] = true;
        if(!b[0])
            a[k ++] = 0;

        Virtual::InitVirtual();
        // puts("OK");
        // for(i=0;i<Virtual::c.size();i++)cout<<Virtual::c[i]+1<<' ';cout<<endl;
        Divide::o[0] = 0;
        Divide::o[1] = INT_MAX;
        Divide::o[2] = INT_MIN;
        Divide::DFS(Virtual::c.at(0));

        printf("%lld %lld %lld\n", Divide::o[0], Divide::o[1], Divide::o[2]);
        for(i = 0; i < k; i ++)
            b[a[i]] = false;
    }

    return 0;
}

```

---

## 作者：zsaskk (赞：2)

[虚树入门](https://www.luogu.com.cn/blog/SSerxhs/qian-tan-xu-shu)

为什么放这位神仙的日报呢？

~~因为我是看他的日报学的~~


------------


虚树的核心~~似乎~~就是建出一个**每个点都有用的**（虚）树，并在上面进行处理。

这里说的“有用”分为两种，一种是题目中钦定的点，另一种是为了防止我们的钦定点变为“散兵游勇”而增加的必要的联结点。

![一张图](https://cdn.luogu.com.cn/upload/image_hosting/1njajbod.png)

这张~~左右两边不太协调的~~图中，底层的标记点是我们的钦定点，而上层的标记点就是对应的联结点。

这样我们建成的虚树就长这样：
![我谔谔](https://cdn.luogu.com.cn/upload/image_hosting/m2rmrgoa.png)

~~例子是不是太简单了~~


------------

构建虚树时，我们开一个$stack$维护根节点到栈顶的虚树上的路径，当加入的点是栈顶的子树内的点时压栈，令$anc$为要加入的点与此时的栈顶的$lca$，否则不断弹栈并连边，直到栈顶为$anc$或可以加入$anc$,即$anc$在栈顶的子树内。

然后跑$dp$就好了。

------------

对于求和，我们在$dp$完一个子树后，处理其与$fa$的其它子树内节点能形成多少路径并计算即可，然后将该子树所有钦定点到根节点距离累加到$fa$的和数组里。

求最小值，如果当前点是钦定点，不断寻找子树中$dep$最高的点即可，否则每$dp$完一个子树，取出该子树中最高的钦定点与$fa$的其它子树中最高的钦定点更新答案。

最大值就直接用最小值的方法，只不过维护$dep$最深的点即可。

~~然而我居然因为数组越界调了两天没看出来?~~


------------

```
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define reg register
#define chk_digit(c) (c>='0'&&c<='9')
inline int read() {
	reg int x=0,f=1;reg char c=getchar();
	while(!chk_digit(c)) { if(c=='-') f=-1;c=getchar(); }
	while(chk_digit(c)) x=x*10+c-'0',c=getchar();
	return x*f;
} 
#define inf (1ll<<60)
#define mymax(x,y) (x>=y?x:y)
#define mymin(x,y) (x>=y?y:x)
#define maxsize 2000010
int a[maxsize],dep[maxsize],num[maxsize],stop,stac[maxsize],dis[maxsize],vist,dfn[maxsize],h[maxsize],cnt,top[maxsize],siz[maxsize],son[maxsize],fa[maxsize],st[maxsize],n,m,q,f[maxsize][4],ans,ans1,ans2=inf;
struct node{ int y,next; }edg[maxsize<<1];
inline bool cmp(int x,int y) { return dfn[x]<dfn[y]; }
inline void add(int x,int y) { edg[++cnt].next=h[x],edg[cnt].y=y,h[x]=cnt; }
inline void dfs1(int x,int fat) {
	siz[x]=1;
	for(reg int i=h[x];i;i=edg[i].next) {
		int y=edg[i].y;if(y==fat) continue;
		dis[y]=dis[x]+1,dep[y]=dep[fa[y]=x]+1,dfs1(y,x),siz[x]+=siz[y];
		if(siz[son[x]]<siz[y]) son[x]=y;
	} 
} 
inline void dfs2(int x) {
	dfn[x]=++vist;
	if(!son[x]) return;
	top[son[x]]=top[x],dfs2(son[x]);
	for(reg int i=h[x];i;i=edg[i].next) {
		int y=edg[i].y;if(y==fa[x]||y==son[x]) continue;
		dfs2(top[y]=y);
	}
}
inline int lca(int x,int y) {
	while(top[x]^top[y]) {
		if(dep[top[x]]>dep[top[y]]) x=fa[top[x]];
		else y=fa[top[y]];
	}
	if(dep[x]<dep[y]) return x;return y;
}
inline void ins(int x) {
	if(!stop) { stac[stop=1]=x;return; }
	int anc=lca(stac[stop],x);
	while(stop&&dep[anc]<dep[stac[stop-1]]) add(stac[stop-1],stac[stop]),--stop;//弹栈连边 
	if(dep[anc]<dep[stac[stop]]) add(anc,stac[stop]),--stop;//弹栈连边 
	if(!stop||stac[stop]!=anc) stac[++stop]=anc;
	stac[++stop]=x;
}
//以上为虚树建立板子
inline void dp(int x) {
	f[x][0]/*最远*/=0,f[x][1]/*最近*/=inf,f[x][2]=0/*sum*/,num[x]=0;
	int maxn=0,tmp=0,tmp1=inf;
	if(siz[x]) num[x]=1,maxn=dis[x],f[x][2]=dis[x];
	for(reg int i=h[x];i;i=edg[i].next) {
		int y=edg[i].y;if(y==fa[x]) continue;
		dp(y),ans+=(f[x][2]*num[y]-dis[x]*num[y]*num[x]*2+f[y][2]*num[x])/*注意这个柿子的写（chi）法*/;
		if(maxn||siz[x]) tmp=mymax(maxn+f[y][0]-2*dis[x],tmp);
		maxn=mymax(maxn,f[y][0]),f[x][0]=mymax(f[x][0],f[y][0]),f[x][2]+=f[y][2],num[x]+=num[y],f[x][1]=mymin(f[x][1],f[y][1]);
		ans2=mymin(tmp1+f[y][1]-2*dis[x],ans2),tmp1=mymin(tmp1,f[y][1]); 
	}
	if(siz[x]) ans2=mymin(f[x][1]-dis[x],ans2),f[x][0]=mymax(f[x][0],dis[x]),f[x][1]=mymin(f[x][1],dis[x]);
	ans1=mymax(ans1,tmp),h[x]=siz[x]=0/*清空数组*/;
}
signed main() {
	n=read();
	for(reg int i=1;i<n;++i) {
		int x=read(),y=read();
		add(x,y),add(y,x);
	}
	dfs1(dep[1]=1,dis[1]=0),dfs2(top[1]=1),memset(h,0,sizeof(h)),memset(siz,0,sizeof(siz)),q=read();
	for(reg int i=1;i<=q;++i) {
		int x=1;m=read();
		for(reg int i=1;i<=m;++i) a[i]=read(),siz[a[i]]=1;
		if(!x) { while(m) siz[a[m]]=0,--m;continue; }
		ans=0,sort(a+1,a+m+1,cmp);
		if(a[1]!=1) stac[stop=1]=1;
		for(reg int i=1;i<=m;++i) ins(a[i]);
		if(stop) while(--stop) add(stac[stop],stac[stop+1]);
		dp(1),siz[1]=vist=0,printf("%lld %lld %lld\n",ans,ans2,ans1),ans=ans1=0,ans2=inf; 
	}
}
```


---

## 作者：_ctz (赞：2)

[安利$blog$](https://ctz45562.github.io/2019/08/03/洛谷-P4103-HEOI2014-大工程)

[传送门](https://www.luogu.org/problem/P4103)

先把虚树造出来。统计所有路径的最值和权值和。。。点分治！

成功被数据范围拦了下来。。。~~（刚学点分治和虚树的我表示两样能一块练多好）~~

考虑$DP$，最大值类似于树的直径，只不过两端点必须为关键点。

设$ma(i)$为以点$i$到其子树中的关键点的最长路径长度。若$i$为关键点，$ma(i)$初值为$0$，否则为$-inf$，然后和树的直径一样$DP$即可。最小值类似。

对于权值和，记$siz(i)$为点$i$的子树中关键点的个数（包括$i$），$len(i)$为点$i$到其子树中所有关键点的路径权值之和。

显然，$siz(i)=\sum\limits_{edge(i,j)}siz(j)$，$len(i)=\sum\limits_{edge(i,j)}len(j)+siz(j)*length(edge(i,j))$。

对答案的贡献即$\sum\limits_{edge(i,j)}siz(i)*[len(j)+siz(j)*length(edge(i,j))]+siz(j)*len(i)$，注意此处的$siz(i)$和$len(i)$是统计到$j$时的值。

其实还有更简单的方法，直接统计每条边被经过的次数乘上边长，即$length(edge(i,j))*siz(j)*(k-siz(j))$

复杂度$O(\sum k\log n+\sum k)$，$\log n$是小常数树剖$lca$。

代码：

``` cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <vector>

#define maxn 1000005
#define inf 0x3f3f3f3f

using namespace std;

inline int read(){
	int x=0,y=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return y?-x:x;
}
struct edge{
	int pre,to,l;
};
namespace origin{
	int h[maxn],seg[maxn],top[maxn],son[maxn],fa[maxn],deep[maxn],siz[maxn],num,all;
	edge e[maxn<<1];
	inline void add(int from,int to){
		e[++num].pre=h[from],h[from]=num,e[num].to=to;
	}
	void dfs1(int node=1){
		siz[node]=1;
		int x;
		for(register int i=h[node];i;i=e[i].pre){
			x=e[i].to;
			if(!siz[x]){
				fa[x]=node,deep[x]=deep[node]+1;
				dfs1(x),siz[node]+=siz[x];
				if(siz[x]>siz[son[node]])son[node]=x;
			}
		}
	}
	void dfs2(int node=1){
		seg[node]=++all;
		if(son[node]){
			top[son[node]]=top[node],dfs2(son[node]);
			int x;
			for(register int i=h[node];i;i=e[i].pre){
				x=e[i].to;
				if(!seg[x])top[x]=x,dfs2(x);
			}
		}
	}
	int lca(int x,int y){
		while(top[x]!=top[y])deep[top[x]]<deep[top[y]]?y=fa[top[y]]:x=fa[top[x]];
		return deep[x]<deep[y]?x:y;
	}
}
namespace virt{
	int ma[maxn],mi[maxn],h[maxn],siz[maxn],num,ans2,ans3;
	long long len[maxn],ans1;
	bool vis[maxn];
	vector<int>p;
	edge e[maxn<<1];
	inline void add(int from,int to){
		int l=abs(origin::deep[from]-origin::deep[to]);
		e[++num].pre=h[from],h[from]=num,e[num].to=to,e[num].l=l;
		e[++num].pre=h[to],h[to]=num,e[num].to=from,e[num].l=l;
	}
	struct Monostack{
		int sta[maxn],top;
		void clear(){
			for(register int i=2;i<=top;++i)add(sta[i],sta[i-1]);
			top=0;
		}
		void push(int x){
			sta[++top]=x;
		}
		void check(int x){
			if(x==1)return;
			int l=origin::lca(x,sta[top]);
			h[x]=0;
			if(l!=sta[top]){
				while(origin::seg[l]<origin::seg[sta[top-1]])add(sta[top],sta[top-1]),--top;
				--top;
				if(l!=sta[top])h[l]=0,add(sta[top+1],l),push(l);
				else add(sta[top+1],l);
			}
			push(x);
		}
	}s;
	inline bool cmp(int x,int y){
		return origin::seg[x]<origin::seg[y];
	}
	void build(){
		h[1]=0,s.push(1);
		for(vector<int>::iterator iter=p.begin();iter!=p.end();++iter)s.check(*iter);
		s.clear();
	}
	void dfs(int node=1,int f=0){
		siz[node]=vis[node],len[node]=0,mi[node]=vis[node]?0:inf,ma[node]=vis[node]?0:-inf;
		int x;
		long long l;
		for(register int i=h[node];i;i=e[i].pre){
			x=e[i].to;
			if(x==f)continue;
			dfs(x,node);
			l=len[x]+1ll*e[i].l*siz[x];
			ans1+=siz[node]*l+siz[x]*len[node];
			siz[node]+=siz[x],len[node]+=l;
			ans2=min(ans2,mi[node]+mi[x]+e[i].l);
			ans3=max(ans3,ma[node]+ma[x]+e[i].l);
			mi[node]=min(mi[node],mi[x]+e[i].l);
			ma[node]=max(ma[node],ma[x]+e[i].l);
		}	
	}
	void solve(){
		p.clear(),num=ans1=ans3=0,ans2=inf;
		int n=read(),x;
		for(register int i=1;i<=n;++i)p.push_back(x=read()),vis[x]=1;
		sort(p.begin(),p.end(),cmp);
		build(),dfs();
		printf("%lld %d %d\n",ans1,ans2,ans3);
		for(vector<int>::iterator iter=p.begin();iter!=p.end();++iter)vis[*iter]=0;
	}
}
int main(){
	int n=read(),x,y;
	for(register int i=1;i<n;++i)x=read(),y=read(),origin::add(x,y),origin::add(y,x);
	origin::dfs1(),origin::dfs2();
	n=read();
	while(n--)virt::solve();
}

```



---

## 作者：rhjoi (赞：1)

 _虚树板题一道。。。_ 

 _个人觉得这题比 “消耗战”更适合练板子（树形dp更为简单）_ 
 
 
说正解。

注意到$\sum |p|\le2e6$，这提示我们建一颗虚树。

建好后，2和3问就是求一个树上最短路，最长路，不再赘述。

简单说一下1，我们对于每一条边统计有多少点对经过它。
具体的，树形dp的时候算出，即为$siz[son]*(tot-siz[son)$。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define sf scanf
#define ri register int
#define in red()
#define gc getchar()
#define ll long long
#define cs const
inline int red(){
	int num=0,f=1;char c=gc;
	for(;!isdigit(c);c=gc)if(c=='-')f=-1;
	for(;isdigit(c);c=gc)num=(num<<1)+(num<<3)+(c^48);
	return num*f;
}
cs int N=1e6+10;
cs ll inf=1e14;
int head[N],to[N<<1],nxt[N<<1],cnt=0,dep[N],n,m,dfn[N],tot;
inline void adde(int u,int v){
	nxt[++cnt]=head[u];head[u]=cnt;to[cnt]=v;
	nxt[++cnt]=head[v];head[v]=cnt;to[cnt]=u;
}
namespace SP{
	int siz[N],fa[N],top[N],son[N];
	inline void dfs1(int u){
		dep[u]=dep[fa[u]]+1;
		dfn[u]=++tot;
		siz[u]=1;
		for(ri i=head[u];i;i=nxt[i]){
			int v=to[i];
			if(v^fa[u]){
				fa[v]=u;
				dfs1(v);
				siz[u]+=siz[v];
				if(siz[v]>siz[son[u]])son[u]=v;
			}
		}
	}
	inline void ddfs1(int u,int f){
		top[u]=f;
		if(son[u])ddfs1(son[u],f);
		for(ri i=head[u];i;i=nxt[i]){
			int v=to[i];
			if(v^fa[u]&&v^son[u])ddfs1(v,v);
		}
	}
	inline int lca(int x,int y){
		while(top[x]^top[y]){
			if(dep[top[x]]<dep[top[y]])swap(x,y);
			x=fa[top[x]];
		}
		return dep[x]<dep[y] ? x : y;
	}
	inline void init(){
		dfs1(1);ddfs1(1,1);
	}
}
using SP::lca;
using SP::init;
inline bool cmp(cs int &a,cs int &b){return dfn[a]<dfn[b];}
typedef pair<int,int> pi;
#define fi first
#define se second
vector<pi> g[N];
inline void link(int x,int y){g[x].push_back(pi(y,dep[y]-dep[x]));}
ll maxn,siz[N],mx[N],mn[N],ans1,ans2,ans3;
bool vis[N];
//vis标记打上，清掉 
void dfs2(int u,int fa){
	if(vis[u])mx[u]=mn[u]=0,siz[u]=1;
	else mx[u]=-inf,mn[u]=inf,siz[u]=0;
	for(ri i=g[u].size()-1;i>=0;--i){
		int v=g[u][i].fi;
		if(v==fa)continue;
		dfs2(v,u);
		siz[u]+=siz[v];
		ans1+=siz[v]*(maxn-siz[v])*g[u][i].se;
		ans2=min(ans2,mn[u]+g[u][i].se+mn[v]);
		mn[u]=min(mn[u],g[u][i].se+mn[v]);
		ans3=max(ans3,mx[u]+g[u][i].se+mx[v]);
		mx[u]=max(mx[u],g[u][i].se+mx[v]);
	}
	g[u].clear();
}
inline void work(vector<int> &f){
	vector<int> stk;stk.clear();
	sort(f.begin(),f.end(),cmp);
	for(ri i=0,up=f.size();i<up;++i){
		if(!stk.size()){stk.push_back(f[i]);continue;}
		int L=lca(*stk.rbegin(),f[i]);
		while(stk.size()>1&&dfn[*(--(--stk.end()))]>=dfn[L])link(*(--(--stk.end())),*stk.rbegin()),stk.pop_back();
		if((*stk.rbegin())^L)link(L,*stk.rbegin()),stk.pop_back(),stk.push_back(L);
		stk.push_back(f[i]);
	}	
	while(stk.size()>1)link(*(--(--stk.end())),*stk.rbegin()),stk.pop_back();
	maxn=f.size();
	ans1=0;ans2=inf;ans3=-inf;
	dfs2(*stk.begin(),0);
	cout<<ans1<<' '<<ans2<<' '<<ans3<<'\n';
	
}
vector<int> cot;
signed main(){
//	freopen("data.in","r",stdin);
	n=in;
	for(ri i=1;i<n;++i)adde(in,in);
	init();
	m=in;
	while(m--){
		cot.clear();
		int k=in;
		for(ri i=1;i<=k;++i)cot.push_back(in),vis[cot[i-1]]=1;
		work(cot);
		for(ri i=1;i<=k;++i)vis[cot[i-1]]=0;
	}

	return 0;
}

```




---

## 作者：GKxx (赞：1)

虚树dp

对每次询问首先肯定是建虚树然后dp。建虚树的过程可以参考网上的教程和这里的模板（因为我感觉我还没法解释得太清楚，所以最好还是不要瞎讲）

为了之后的dp方便，建虚树的时候可以强行把1号点加进去，但是如果给出的关键点里已经有1号点就不能重复加，不然会有重边，本题重边会对dp造成影响。

虚树的树边权值为原树中两点距离，不能当1做

然后是dp。这题是比较显然的子树dp

$d[x]$表示以$x$为根的子树中，各关键点到$x$的距离之和

$size[x]$表示以$x$为根的子树中关键点的数量

$f[x]$表示以$x$为根的子树中关键点到$x$的距离最小值，$g[x]$表示最大值

另外$ans_1, ans_2, ans_3$依次表示答案（距离和，最小值，最大值）

考虑我们树形dp在dfs的时候其实是一个不断遇到新的子树的过程，换句话说是一个不断合并两棵子树的过程。于是可以把图画成这样

![](https://cdn.luogu.com.cn/upload/pic/37353.png)

可以先用两棵树的情况更新答案，然后再将$v$子树的信息合并到$x$上去：

```cpp
if (size[x] > 0) {
    ans1 += size[x] * size[v] * w + size[v] * d[x] + size[x] * d[v];
    chkMin(ans2, f[x] + w + f[v]);
    chkMax(ans3, g[x] + w + g[v]);
}
d[x] += d[v] + size[v] * w;
chkMin(f[x], w + f[v]);
chkMax(g[x], w + g[v]);
size[x] += size[v];
```

注意$size[x] > 0$这个条件。如果当前$x$侧还没有任何关键点，就说明此时的$f[x],g[x]$是没有意义的值，用它们更新答案可能会出错，具体取决于个人的代码实现。

最后，在虚树dp的dfs过程退出的时候要顺手把head清零，如果每次$O(n)$地清空head数组就白忙活了。

```cpp
#include <cctype>
#include <cstdio>
#include <climits>
#include <algorithm>

template <typename T> inline void read(T& t) {
    int f = 0, c = getchar(); t = 0;
    while (!isdigit(c)) f |= c == '-', c = getchar();
    while (isdigit(c)) t = t * 10 + c - 48, c = getchar();
    if (f) t = -t;
}
template <typename T> inline bool chkMin(T& x, const T& y) { return y < x ? (x = y, true) : false; }
template <typename T> inline bool chkMax(T& x, const T& y) { return x < y ? (x = y, true) : false; }
#ifdef WIN32
#define LLIO "%I64d"
#else
#define LLIO "%lld"
#endif	// WIN32 long long
#define rep(I, A, B) for (int I = (A); I <= (B); ++I)
#define rrep(I, A, B) for (int I = (A); I >= (B); --I)
#define erep(I, X) for (int I = head[X]; I; I = next[I])

const int maxn = 1e6 + 207;
const long long inf = 1e14;
struct Graph {
    int v[maxn << 1], w[maxn << 1], head[maxn], next[maxn << 1];
    int tot;
    void ae(int x, int y, int z = 0) {
        v[++tot] = y; w[tot] = z; next[tot] = head[x]; head[x] = tot;
        v[++tot] = x; w[tot] = z; next[tot] = head[y]; head[y] = tot;
    }
};
Graph T, V;
int dep[maxn], anc[30][maxn], dfn[maxn];
long long d[maxn], size[maxn], f[maxn], g[maxn], ans1, ans2, ans3;
int n, m, xys;

inline bool cmp(int x, int y) { return dfn[x] < dfn[y]; }
void dfs1(int x) {
    dep[x] = dep[anc[0][x]] + 1; dfn[x] = ++xys;
    rep(i, 1, 22) anc[i][x] = anc[i - 1][anc[i - 1][x]];
    for (int i = T.head[x]; i; i = T.next[i])
        if (T.v[i] != anc[0][x]) {
            anc[0][T.v[i]] = x;
            dfs1(T.v[i]);
        }
}
inline int getlca(int x, int y) {
    if (x == y) return x;
    if (dep[x] < dep[y]) std::swap(x, y);
    rrep(i, 22, 0) if (dep[anc[i][x]] >= dep[y]) x = anc[i][x];
    if (x == y) return x;
    rrep(i, 22, 0) if (anc[i][x] != anc[i][y]) x = anc[i][x], y = anc[i][y];
    return anc[0][x];
}
inline int getDist(int x, int y) {
    return dep[x] < dep[y] ? dep[y] - dep[x] : dep[x] - dep[y];
}
int st[maxn], top;
bool key[maxn];
inline void insert(int x) {
    if (!top) { st[++top] = x; return; }
    int lca = getlca(st[top], x);
    while (dep[st[top - 1]] > dep[lca] && top > 1) {
        V.ae(st[top - 1], st[top], getDist(st[top - 1], st[top]));
        --top;
    }
    if (dep[lca] < dep[st[top]]) {
        V.ae(lca, st[top], getDist(lca, st[top]));
        --top;
    }
    if (!top || dep[st[top]] < dep[lca]) st[++top] = lca;
    st[++top] = x;
}
inline void buildVirtual(int *S, int k) {
    std::sort(S + 1, S + k + 1, cmp);
    V.tot = 0;
    if (S[1] != 1) st[top = 1] = 1;
    else st[top = 0] = 0;
    rep(i, 1, k) insert(S[i]), key[S[i]] = 1;
    while (top > 1) V.ae(st[top], st[top - 1], getDist(st[top], st[top - 1])), --top;
}
void dfs2(int x, int fa) {
    size[x] = key[x]; d[x] = g[x] = 0; f[x] = key[x] ? 0 : inf;
    for (int i = V.head[x]; i; i = V.next[i]) {
        int v = V.v[i], w = V.w[i];
        if (v != fa) {
            dfs2(v, x);
            if (size[x] > 0) {
                ans1 += size[x] * size[v] * w + size[v] * d[x] + size[x] * d[v];
                chkMin(ans2, f[x] + w + f[v]);
                chkMax(ans3, g[x] + w + g[v]);
            }
            d[x] += d[v] + size[v] * w;
            chkMin(f[x], w + f[v]);
            chkMax(g[x], w + g[v]);
            size[x] += size[v];
        }
    }
    V.head[x] = key[x] = 0;
}

int main() {
    read(n);
    T.tot = V.tot = 0;
    rep(i, 1, n) T.head[i] = V.head[i] = 0;
    rep(i, 1, n - 1) {
        int x, y; read(x); read(y); T.ae(x, y);
    }
    dfs1(1);
    read(m);
    rep(i, 1, m) {
        int k; read(k);
        int *S = new int[k + 10];
        rep(j, 1, k) read(S[j]);
        buildVirtual(S, k);
        ans1 = 0; ans2 = inf; ans3 = 0;
        dfs2(1, 0);
        printf(LLIO " " LLIO " " LLIO "\n", ans1, ans2, ans3);
        delete[] S;
    }
    return 0;
}
```

---

## 作者：ccviolett (赞：0)


> 一句话题意：给出一棵单位边权的树和若干关键点，求出每两个关键点间的距离之和以及距离最大、最小值。


虚树模板题中的一员，有着赤裸裸的提示——关键点数量之和不超过 XXX。

原树上的边权都为 1，建虚树的时候可以利用深度差来算出虚树上的边权，下面过程考虑再虚树上如何进行。

每两个关键点之间的距离之和考虑分别计算每一条边的贡献，一条边会被经过的次数，根据乘法原理，会等于一端子树中关键点个数乘上另一端子树中关键点个数。记得开 long long。

最大值也很好算，我一开始用的是类似于树的直径的方法，搜一遍找到最远的点，再从最远的点搜一遍找到最长的边，但其实是可以 DP 去做的，这个后面说。

最小值倒是困扰了一下子，发现没有办法像求最大值一样搜两遍之类的考虑到所有边。发现其实最小值肯定是相邻两个关键点之间的距离，没有必要经过一个点，那么其实可以对于每一个点，如果这个点是关键点，就用到子树中最近的一个关键点的距离更新答案；如果这个点不是关键点，考虑用这个点中转，用到最近和次近的两个关键点来更新答案即可。

反过来想一想，最大值其实也可以这样做，用最大值和次大值更新即可。

跑得挺慢的，看别人都是一个 DFS 求出了所有的东西，代码简洁常熟小。相比之下，我的这种做法就显得不那么优雅了。

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long var;

const int N = 1100006;
const int INF = 0x3f3f3f3f;

int n, k, a[N];
int top, fi[N], ne[N << 1], to[N << 1];
var co[N << 1];
int T, dfn[N], fa[N], deep[N], maxson[N], linetop[N];
var size[N];
int cnt, sta[N];
bool mark[N];
int dist[N];

var read();
void add(int u, int v, int w);
void getInfo(int t);
void getLink(int t);
int lca(int x, int y);
void solve();
void build();
void dpinit(int t, int f);
var dpsum(int t, int f);
var dpmin(int t, int f);
void dpmin(int t, int f, int s, int &x, int &ms);
var dpmax();
void dpmax(int t, int f, int s, int &x, int &ms);
void dpclean(int t, int f);

int main() {
  n = read();
  for (int i = 2; i <= n; ++i) add(read(), read(), 0);
  getInfo(1), getLink(1);
  for (int i = 1; i <= n; ++i) fi[i] = 0;
  int q = read();
  while (q--) solve();
  return 0;
}

var read() {
  var a = 0, c = getchar(), s = 0;
  while (!isdigit(c)) s |= c == '-', c = getchar();
  while (isdigit(c)) a = a * 10 + c - 48, c = getchar();
  return s ? -a : a;
}


void add(int u, int v, int w) {
  ne[++top] = fi[u], fi[u] = top, to[top] = v, co[top] = w;
  ne[++top] = fi[v], fi[v] = top, to[top] = u, co[top] = w;
}

void getInfo(int t) {
  dfn[t] = ++T;
  size[t] = 1;
  deep[t] = deep[fa[t]] + 1;
  for (int i = fi[t]; i; i = ne[i]) {
    if (to[i] == fa[t]) continue;
    fa[to[i]] = t;
    getInfo(to[i]);
    size[t] += size[to[i]];
    if (size[to[i]] > size[maxson[t]]) maxson[t] = to[i];
  }
}

void getLink(int t) {
  if (t == maxson[fa[t]])
    linetop[t] = linetop[fa[t]];
  else
    linetop[t] = t;
  if (maxson[t]) getLink(maxson[t]);
  for (int i = fi[t]; i; i = ne[i]) {
    if (to[i] == fa[t] || to[i] == maxson[t]) continue;
    getLink(to[i]);
  }
}

int lca(int x, int y) {
  while (linetop[x] != linetop[y]) {
    if (deep[linetop[x]] < deep[linetop[y]]) swap(x, y);
    x = fa[linetop[x]];
  }
  if (deep[x] > deep[y]) swap(x, y);
  return x;
}

void solve() {
  k = read();
  for (int i = 1; i <= k; ++i) a[i] = read();
  for (int i = 1; i <= k; ++i) mark[a[i]] = true;
  build();
  dpinit(1, 1);
  printf("%lld %lld %lld\n", dpsum(1, 1), dpmin(1, 1), dpmax());
  dpclean(1, 1);
  for (int i = 1; i <= k; ++i) mark[a[i]] = false;
}

void build() {
  sort(a + 1, a + k + 1, [=](int x, int y) { return dfn[x] < dfn[y]; });
  top = 0;
  sta[cnt = 1] = 1;
  for (int i = 1; i <= k; ++i) {
    int x = a[i], p = lca(sta[cnt], x);
    while (deep[p] < deep[sta[cnt]]) {
      if (deep[p] >= deep[sta[cnt - 1]]) {
        add(p, sta[cnt], deep[sta[cnt]] - deep[p]);
        if (sta[--cnt] != p) sta[++cnt] = p;
        break;
      }
      add(sta[cnt], sta[cnt - 1], deep[sta[cnt]] - deep[sta[cnt - 1]]), cnt--;
    }
    if (sta[cnt] != x) sta[++cnt] = x;
  }
  while (cnt - 1) {
    add(sta[cnt], sta[cnt - 1], deep[sta[cnt]] - deep[sta[cnt - 1]]), cnt--;
  }
}

void dpinit(int t, int f) {
  size[t] = mark[t];
  for (int i = fi[t]; i; i = ne[i]) {
    if (to[i] == f) continue;
    dpinit(to[i], t);
    size[t] += size[to[i]];
  }
}

var dpsum(int t, int f) {
  var sum = 0;
  for (int i = fi[t]; i; i = ne[i]) {
    if (to[i] == f) continue;
    sum += size[to[i]] * (size[1] - size[to[i]]) * co[i] + dpsum(to[i], t);
  }
  return sum;
}

var dpmin(int t, int f) {
  var res = INF, vmin = INF, vmjn = INF;
  for (int i = fi[t]; i; i = ne[i]) {
    if (to[i] == f) continue;
    res = min(res, dpmin(to[i], t));
    if (dist[to[i]] + co[i] < vmin) vmjn = vmin, vmin = dist[to[i]] + co[i];
    else if (dist[to[i]] + co[i] < vmjn) vmjn = dist[to[i]] + co[i];
  }
  if (mark[t]) {
    dist[t] = 0;
    return min(res, vmin);
  }
  dist[t] = vmin;
  return min(res, vmin + vmjn);
}

var dpmax() {
  int x = 0, ms = 0;
  dpmax(1, 1, 0, x, ms);
  ms = 0;
  dpmax(x, x, 0, x, ms);
  return ms;
}

void dpmax(int t, int f, int s, int &x, int &ms) {
  if (mark[t] && s > ms) ms = s, x = t;
  for (int i = fi[t]; i; i = ne[i]) {
    if (to[i] == f) continue;
    dpmax(to[i], t, s + co[i], x, ms);
  }
}

void dpclean(int t, int f) {
  for (int i = fi[t]; i; i = ne[i]) {
    if (to[i] == f) continue;
    dpclean(to[i], t);
  }
  fi[t] = 0;
}
```

---

## 作者：ddwqwq (赞：0)

突然发现我三个子任务的做法和大佬们都不一样，于是发个题解。  
对于每个询问，首先建立虚树，边权为两个结点在原树上的距离。  
对于询问最远距离，我们可以发现一个性质，虚树上直径的两个端点一定都是关键结点，这个可以用数学归纳法对已经加入的关键结点数进行归纳，从而证明。于是直接找出直径就好了。  
对于最近距离，我们通过两遍dp，找出距离虚树上每个结点最近和次近的关键结点。对于每个关键结点，距离它最近的非本身关键结点显然就是距离它次近的关键结点。我们需要进行两次dp，一次统计子树中的结点。另一次考虑父结点的影响。  
对于总距离，我们对每一条边的贡献分别讨论。设该边一侧共有k个关键结点，总共有tot个关键结点，则该边一共被经过了
$k(tot-k)$次。dfs时开一个全局变量记录即可。 
下面是代码：
```
#include <iostream>
#include <stdio.h>
#include <queue>
#include <cstring>
#include <math.h>
#include <algorithm>

const long long INF = 1000000005;
const long long MAXN = 1000005;
const long long MAXM = 1000005;

long long max(long long x, long long y)
{
    return x > y ? x : y;
}
long long min(long long x, long long y)
{
    return x < y ? x : y;
}

struct node {
    long long to;
    long long w;
    node *next;
};
void addnode(node *&head, long long to, long long w)
{
    node *p = new node;
    p->to = to;
    p->w = w;
    p->next = head;
    head = p;
}
void del(node *&head)
{
    while (head)
    {
        node *p = head;
        head = p->next;
        delete p;
    }
}

long long N, M;
node *edge[MAXN];
long long size[MAXN], son[MAXN], fa[MAXN], deep[MAXN];
long long top[MAXN], rank[MAXN], id[MAXN];

void dfs1(long long v)
{
    size[v] = 1;
    deep[v] = deep[fa[v]] + 1;
    for (node *p = edge[v]; p; p = p->next)
    {
        if (p->to == fa[v])
            continue;
        fa[p->to] = v;
        dfs1(p->to);
        size[v] += size[p->to];
        if (size[p->to] > size[son[v]])
            son[v] = p->to;
    }
}

long long dfs_clock;
void dfs2(long long v, long long t)
{
    dfs_clock++;
    rank[v] = dfs_clock;
    id[dfs_clock] = v;
    top[v] = t;

    if (son[v])
        dfs2(son[v], t);
    for (node *p = edge[v]; p; p = p->next)
        if (p->to != fa[v] && p->to != son[v])
            dfs2(p->to, p->to);
}

long long LCA(long long x, long long y)
{
    if (top[x] == top[y])
        return deep[x] < deep[y] ? x : y;
    if (deep[top[x]] > deep[top[y]])
        return LCA(fa[top[x]], y);
    return LCA(x, fa[top[y]]);
}

long long query(long long x, long long anc)
{
    if (top[x] == top[anc])
        return deep[x] - deep[anc] + 1;
    return deep[x] - deep[top[x]] + 1 + query(fa[top[x]], anc);
}
long long dis(long long x, long long y)//x 到 y 的结点数量 
{
    long long lca = LCA(x, y);
    return query(x, lca) + query(y, lca) - 1;
}

long long key[MAXN], cnt;
bool mark[MAXN];
long long S[MAXN], t, tmp[MAXN], tt;
node *e[MAXN];

long long SUM, num[MAXN], near[MAXN][2];

void pushup(long long v, long long to)
{
    if (near[to][0] != near[v][0] && near[to][0] != near[v][1] && near[to][0])
    {
        if (!near[v][0] || dis(near[to][0], v) < dis(near[v][0], v))
        {
            near[v][1] = near[v][0];
            near[v][0] = near[to][0];
        }
        else if (!near[v][1] || dis(near[to][0], v) < dis(near[v][1], v))
            near[v][1] = near[to][0];
    }
    if (near[to][1] != near[v][0] && near[to][1] != near[v][1] && near[to][1])
        if (!near[v][1] || dis(near[to][1], v) < dis(near[v][1], v))
            near[v][1] = near[to][1];
}

void dfs3(long long v, long long fa)
{
    num[v] = mark[v];
    near[v][0] = near[v][1] = 0;
    if (mark[v])
        near[v][0] = v;
    for (node *p = e[v]; p; p = p->next)
    {
        if (p->to == fa)
            continue;
        dfs3(p->to, v);
        num[v] += num[p->to];
        pushup(v, p->to);
        SUM += p->w*num[p->to] * (cnt - num[p->to]);
    }
}

void dfs4(long long v, long long fa)
{
    if (fa)
        pushup(v, fa);
    for (node *p = e[v]; p; p = p->next)
        if (p->to != fa)
            dfs4(p->to, v);
}

long long mxd, mxid, dep[MAXN];
void dfs5(long long v, long long fa)
{
    for (node *p = e[v]; p; p = p->next)
    {
        if (p->to == fa)
            continue;
        dep[p->to] = dep[v] + p->w;
        dfs5(p->to, v);
    }
    if (dep[v] > mxd)
    {
        mxd = dep[v];
        mxid = v;
    }
}
long long getd(long long root)
{
    mxd = dep[root] = 0;
    dfs5(root, 0);
    mxd = dep[mxid] = 0;
    dfs5(mxid, 0);
    return mxd;
}

void solve()
{
    SUM = 0;
    dfs3(S[0], 0);
    dfs4(S[0], 0);
    long long mx = getd(S[0]), mn = INF;
    for (long long i = 1; i <= cnt; i++)
        mn = min(mn, dis(key[i], near[key[i]][1]) - 1);
    printf("%lld %lld %lld\n", SUM, mn, mx);
}

bool cmp(const long long a, const long long b)
{
    return rank[a] < rank[b];
}

void add_edge(long long x, long long y, long long w)
{
    addnode(e[x], y, w);
    addnode(e[y], x, w);
}

void build()
{
    std::sort(key + 1, key + cnt + 1, cmp);

    t = tt = 0;
    S[t++] = key[1];
    for (long long i = 2; i <= cnt; i++)
    {
        long long x = key[i];
        long long lca = LCA(x, S[t - 1]);
        tmp[tt++] = lca;
        if (S[t - 1] == lca)
            S[t++] = x;
        else
        {
            while (t >= 2 && deep[S[t - 2]] >= deep[lca])
            {
                add_edge(S[t - 1], S[t - 2], dis(S[t - 1], S[t - 2]) - 1);
                t--;
            }
            if (S[t - 1] != lca)
            {
                add_edge(S[t - 1], lca, dis(S[t - 1], lca) - 1);
                S[t - 1] = lca;
            }
            S[t++] = x;
        }
    }
    while (t >= 2)
    {
        add_edge(S[t - 1], S[t - 2], dis(S[t - 1], S[t - 2]) - 1);
        t--;
    }

    for (long long i = 1; i <= cnt; i++)
        mark[key[i]] = true;
}

void clear()
{
    for (long long i = 1; i <= cnt; i++)
    {
        mark[key[i]] = false;
        del(e[key[i]]);
    }
    for (long long i = 0; i < tt; i++)
        del(e[tmp[i]]);
}

void init()
{
    long long i, u, v;
    
    scanf("%lld", &N);
    for (i = 1; i < N; i++)
    {
        scanf("%lld %lld", &u, &v);
        addnode(edge[u], v, 1);
        addnode(edge[v], u, 1);
    }
    scanf("%lld", &M);

    dfs1(1);
    dfs2(1, 1);
}

int main()
{
    long long i, j;
    
    init();

    for (i = 1; i <= M; i++)
    {
        scanf("%lld", &cnt);
        for (j = 1; j <= cnt; j++)
            scanf("%lld", &key[j]);
        build();
        solve();
        clear();
    }

    //system("pause");
    return 0;
}
```

---


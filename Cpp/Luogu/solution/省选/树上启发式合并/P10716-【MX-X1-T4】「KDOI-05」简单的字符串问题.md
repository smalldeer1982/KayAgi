# 【MX-X1-T4】「KDOI-05」简单的字符串问题

## 题目背景

原题链接：<https://oier.team/problems/X1D>。

## 题目描述

你有一个字符串 $S$。$q$ 个询问，每次给出 $(i,k)$，求有多少个非空字符串 $A$，使得存在可空字符串 $B_1,B_2,\dots,B_{k-1}$ 满足：

$$S[1,i]=AB_1AB_2A\dots AB_{k-1}A$$

其中 $S[1,i]$ 表示 $S$ 的长度为 $i$ 的前缀。

## 说明/提示

**【样例解释 \#1】**

对于第一次询问 $(5,3)$，可以取 $A=\texttt{a}$，$B_1=\varepsilon$，$B_2=\texttt{ba}$，其中 $\varepsilon$ 表示空串。可以证明有且仅有一个合法的 $A$。

**【数据范围】**

**本题采用捆绑测试。**

| 子任务编号 | 分值 | $n,q\leq$ | 特殊性质 |
|:--:|:--:|:--:|:--:|
| $1$ | $5$ | $500$ | 无 |
| $2$ | $10$ | $5000$ | 无 |
| $3$ | $10$ | $2\times10^5$ | $S$ 中字符从 $\tt a,b$ 中随机生成 |
| $4$ | $20$ | $2\times10^5$ | 每个询问的 $k$ 相同 |
| $5$ | $20$ | $5\times10^4$ | 无 |
| $6$ | $35$ | $2\times10^5$ | 无 |

对于 $100\%$ 的数据：$1\leq k\leq i\leq n\leq 2\times 10^5$，$1\leq q\leq 2\times 10^5$，$s$ 仅包含小写字母。

## 样例 #1

### 输入

```
10
aabaacaaaa
5
5 3
5 2
6 1
10 4
10 5```

### 输出

```
1
2
1
2
1```

## 样例 #2

### 输入

```
10
bababababa
10
6 1
6 2
6 3
6 4
6 5
10 2
10 3
9 4
5 5
4 2```

### 输出

```
1
1
1
0
0
2
1
1
0
1
```

# 题解

## 作者：EuphoricStar (赞：11)

一个 $A$ 合法的充要条件为：

- $A$ 为 $S_{1 \sim i}$ 的一个 border；
- $A$ 在 $S_{1 \sim i}$ 中不重叠地出现 $\ge k$ 次。

建出失配树后，发现合法的 $A$ 在树上组成一条某个点 $u$ 到根的链，且 $u$ 为 $i$ 的祖先。因此我们若知道 $u$，答案就是 $dep_u$。

考虑倍增求出 $u$。相当于要 check 这样一个问题：

- $S_{1 \sim u}$ 的第 $k$ 次不重叠出现位置是否 $\le i$。

考虑预处理出每个前缀 $S_{1 \sim u}$ 对应的串在整个串中的不重叠出现位置。相当于每次找到一个位置后面第一个后缀，使得它与整个串的 LCP 长度 $\ge u$，然后跳到它。跳的步数最多是 $\sum\limits_{i = 1}^n \frac{n}{i} = O(n \log n)$ 所以可以暴力跳。

一个后缀与整个串的 LCP 长度可以想到 Z 函数。用并查集维护链表的 trick，从小到大枚举 $u$，处理完 $u$ 后把 $z_p = u$ 的所有位置 $p$ 删了，使得处理到 $u$ 时，并查集中 $z_p \ge u$ 的位置为代表元。这样即可 $O(\alpha(n))$ 求出一个位置后面第一个 $p$ 使得 $z_p \ge u$ 的 $p$。

注意特判 $k = 1$。

总时间复杂度 $O(q \log n + n \alpha(n) \log n)$。

```cpp
#include <bits/stdc++.h>
#define pb emplace_back
#define fst first
#define scd second
#define mkp make_pair
#define mems(a, x) memset((a), (x), sizeof(a))

using namespace std;
typedef long long ll;
typedef double db;
typedef unsigned long long ull;
typedef long double ldb;
typedef pair<ll, ll> pii;

const int maxn = 200100;
const int logn = 20;

int n, m, fail[maxn], dep[maxn], z[maxn], st[logn][maxn], f[logn][maxn], fa[maxn];
char s[maxn];
vector<int> vc[maxn], cv[maxn];

int find(int x) {
	return fa[x] == x ? x : fa[x] = find(fa[x]);
}

void solve() {
	scanf("%d%s%d", &n, s + 1, &m);
	for (int i = 2, j = 0; i <= n; ++i) {
		while (j && s[i] != s[j + 1]) {
			j = fail[j];
		}
		j += (s[i] == s[j + 1]);
		fail[i] = j;
	}
	for (int i = 1; i <= n; ++i) {
		f[0][i] = fail[i];
		dep[i] = dep[fail[i]] + 1;
	}
	for (int j = 1; j <= 19; ++j) {
		for (int i = 1; i <= n; ++i) {
			f[j][i] = f[j - 1][f[j - 1][i]];
		}
	}
	z[1] = n;
	for (int i = 2, l = 0, r = 0; i <= n; ++i) {
		if (i <= r) {
			z[i] = min(z[i - l + 1], r - i + 1);
		}
		while (i + z[i] <= n && s[z[i] + 1] == s[i + z[i]]) {
			++z[i];
		}
		if (i + z[i] - 1 > r) {
			l = i;
			r = i + z[i] - 1;
		}
	}
	for (int i = 1; i <= n; ++i) {
		cv[z[i]].pb(i);
		fa[i] = (z[i] ? i : i + 1);
	}
	fa[n + 1] = n + 1;
	for (int i = 1; i <= n; ++i) {
		vc[i].pb(i);
		int p = i;
		while (p + i <= n) {
			int q = find(p + 1);
			if (q == n + 1) {
				break;
			}
			p = q + i - 1;
			vc[i].pb(p);
		}
		for (int j : cv[i]) {
			fa[j] = j + 1;
		}
	}
	while (m--) {
		int x, y;
		scanf("%d%d", &x, &y);
		if (y == 1) {
			puts("1");
			continue;
		}
		int t = x;
		for (int i = 19; ~i; --i) {
			if (f[i][x] && ((int)vc[f[i][x]].size() < y || vc[f[i][x]][y - 1] > t)) {
				x = f[i][x];
			}
		}
		x = f[0][x];
		printf("%d\n", dep[x]);
	}
}

int main() {
	int T = 1;
	// scanf("%d", &T);
	while (T--) {
		solve();
	}
	return 0;
}

```

---

## 作者：未来姚班zyl (赞：6)

## 题目大意

题目描述已经很形式化了。

## 题目分析

查询 $(i,k)$ 的意思是对于前缀 $i$，有多少个它的 border 满足可以在前缀 $i$ 中不相交地出现 $k$ 次，且第一次是以前缀出现，第 $k$ 次是以后缀出现。

考虑一个简单的贪心，对于每一个前缀 $j$，每次尽量往前找它出现的位置，设在这样贪心的前提下前缀 $j$ 第 $t$ 次出现的位置的结尾为 $p_{j,t}$，则前缀 $j$ 对查询 $(i,k)$ 贡献 $1$ 当且仅当：

- 前缀 $j$ 是前缀 $i$ 的 border。
- $p_{j,t}\le i$。

先讲讲怎么求 $p_{j,t}$。建立失配树（fail 树），显然前缀 $j$ 在整个串中出现位置的结尾的集合就是 $j$ 在失配树上的子树，每次 lower_bound 即可，子树内 lower_bound 可以在 dfn 序上主席树二分，单次 $O(\log n)$。而总次数是调和级数 $O(n\ln n)$，所以可以 $O(n\log n\ln n)$ 求出所有的 $p_{j,t}$。

然后我们现在可以 $O(1)$ 判断 $j$ 对询问 $(i,k)$ 是否产生贡献了。

然后就是失配树的模板了，前缀 $i$ 的 border 的集合就是失配树上 $i$ 到根上的路径，第一个条件具有可二分性，故离线下来直接在失配树上 dfs 加二分即可。总复杂度 $O(n\log n\ln n)$ 。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define L xd[x].l
#define R xd[x].r
#define mid (l+r>>1)
#define lc L,l,mid
#define rc R,mid+1,r
#define OK Ll<=l&&r<=Rr
#define Root 1,1,n+1
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define per(x,y,z) for(int x=(y);x>=(z);x--)
#define repn(x) rep(x,1,n)
#define repm(x) rep(x,1,m)
#define pb push_back
#define e(x) for(int i=h[x],y=to[i];i;i=nxt[i],y=to[i])
#define E(x) for(auto y:p[x])
#define Pi pair<int,int>
#define ui unsigned ll
inline int read(){int s=0,w=1;char c=getchar();while(c<48||c>57) {if(c=='-') w=-1;c=getchar();}while(c>=48&&c<=57)s=(s<<1)+(s<<3)+c-48,c=getchar();return s*w;}
inline void pf(int x){if(x<0) putchar('-'),x=-x;if(x>9)pf(x/10);putchar(x%10+48);}
using namespace std;
const int N=2e5+5,M=4e6+5,inf=(1LL<<31)-1,mod=1e9+7;
const ll llf=1e18;
inline void add(int &a,int b){((a+=b)>=mod) and (a-=mod);}
inline int Add(int a,int b){return add(a,b),a;}
inline int mul(int a,int b){return 1LL*a*b%mod;}
inline void Mul(int &a,int b){a=mul(a,b);}
inline void red(int &a,int b){add(a,mod-b);}
inline int Red(int a,int b){return red(a,b),a;}
inline int qp(int a,int b){if(!b)return 1;int c=qp(a,b>>1);Mul(c,c);if(b&1)Mul(c,a);return c;}
inline int INV(int x){return qp(x,mod-2);}
int h[N],to[N<<1],nxt[N<<1],cnt,n,m,p[N];
string s;
inline void add_(int a,int b){
	to[++cnt]=b,nxt[cnt]=h[a],h[a]=cnt;	
}
inline void build_fail(){
	p[1]=0;
	for(int j=2;j<=n;){
		int now=p[j-1];
		while(now&&s[now+1]!=s[j])now=p[now];
		while(s[now+1]==s[j])p[j]=++now,j++;
		if(now==0)p[j++]=0;
	}
	repn(i)add_(p[i],i);
}
int out[N],dfn[N],Id[N],Time,siz[N];
vector<Pi>q[N];
vector<int>pp[N];
inline void dfs(int x){
	dfn[x]=++Time,Id[Time]=x,siz[x]=1;
	e(x)dfs(y),siz[x]+=siz[y];
}
struct seg{
	int l,r,w;
}xd[M];
int tot,root[N];
inline void modify(int x,int l,int r,int p){
	xd[x].w++;
	if(l==r)return;
	p<=mid?(xd[++tot]=xd[L],L=tot,modify(lc,p)):(xd[++tot]=xd[R],R=tot,modify(rc,p));
}
inline int query(int X,int x,int l,int r,int Ll,int Rr){//查询总和 
	if(Ll>Rr)return 0;
	if(OK)return xd[x].w-xd[X].w;
	if(Rr<=mid)return query(xd[X].l,lc,Ll,Rr);
	if(Ll>mid)return query(xd[X].r,rc,Ll,Rr);
	return query(xd[X].l,lc,Ll,Rr)+query(xd[X].r,rc,Ll,Rr);
}
inline int getk(int X,int x,int l,int r,int k){//第 k 大 
	if(k<=0)return n+1;
	if(l==r)return xd[x].w?l:n+1;
	int rw=xd[R].w-xd[xd[X].r].w;
	if(rw>=k)return getk(xd[X].r,rc,k);
	return getk(xd[X].l,lc,k-rw);
}
inline void solve(int x){
	pp[x].pb(x);
	int nw=x+x,l=dfn[x],r=dfn[x]+siz[x]-1;
	while(nw<=n){
		int w=query(root[l-1],root[r],1,n,nw,n);
		if(!w)break;
		nw=getk(root[l-1],root[r],1,n,w);
		if(nw!=n+1)pp[x].pb(nw),nw+=x;
	}
}
int st[N],tp;
inline int get(int x,int k){
	if((int)pp[x].size()<k)return n+1;
	return pp[x][k-1];
}
inline void Dfs(int x){
	for(auto y:q[x]){
		int l=1,r=tp,ans=0;
		while(l<=r)if(get(st[mid],y.first)<=x)ans=mid,l=mid+1;
		else r=mid-1;
		out[y.second]=ans;
	}
	if(x)st[++tp]=x;
	e(x)Dfs(y);
	if(x)tp--;
} 
inline void Main(){
	n=read(),cin>>s,s='#'+s,build_fail();
	m=read();
	dfs(0);
	rep(i,1,n+1)xd[++tot]=xd[root[i-1]],root[i]=tot,modify(tot,1,n,Id[i]);
	repn(i)solve(i);
	repm(i){
		int x=read(),k=read();
		if(k==1)out[i]=1;
		else q[x].pb({k,i});
	}
	Dfs(0);
	repm(i)cout <<out[i]<<'\n';
}
signed main(){
	int T=1;
	while(T--)Main();
	return 0;
}	
```

---

## 作者：min_inf (赞：5)

先判掉 $k=1$。

注意到 $A$ 一定是 $S[1,i]$ 的一个 border。建出 border 树，满足条件的 $A$ 一定是 $i$ 的一个祖先到根的链。

考虑对于一个是 border 的串 $A$，从前往后贪心找最前面的不和上一个串重合的串，$A$ 满足要求即为前 $k$ 个串都在 $i$ 前（把最后一个串替换成以 $i$ 结尾的即可），注意到贪的次数是 $O(\sum\frac n i)=O(n\log n)$ 的。

可以用 `set` 启发式合并维护每个前缀的 endpos 集合，倍增查询，时间复杂度 $O(n\log^2n+q\log n)$。

---

## 作者：_Ch1F4N_ (赞：3)

刻画一下合法的 $A$。

首先 $A$ 是 $S[1,i]$ 的一个 border。

然后 $A$ 应该在前缀 $[1,i]$ 中不重复地出现 $k$ 次。

考虑从第二个限制入手，你发现 $A$ 是原序列一个前缀，而一个前缀 $S[1,j]$ 至多不重复地出现 $\frac{n}{j}$ 次。

不妨记 $dp_{i,j}$ 表示前缀 $S[1,i]$ 第一次满足其不重复地出现 $j$ 次的位置，根据上面的分析状态总量是 $O(n \log n)$ 的，查询就是找 $i$ 在 fail 树上的祖先中所有满足 $dp_{x,k} \leq i$ 的祖先。

注意到假若串 $A$ 可以满足条件的话，$A$ 的任意 border 一定也满足条件，因此满足条件的祖先一定是 $i$ 到根上链的上半段，假若能处理出所有 $dp_{i,j}$ 就可以通过树上倍增把这段找出来。

处理 $dp_{i,j}$ 可以考虑在 fail 树上 dfs，对于每个点 $u$ 维护其子树内所有点代表的前缀，这些前缀就是这个点 $u$ 代表的前缀所有出现位置的结束位置构成的集合，你可以考虑 set 启发式合并来维护这个集合，处理 $dp$ 数组时由于 $dp$ 数组状态总量是 $O(n \log n)$ 的所以直接暴力找后继处理即可做到 $O(n \log^2 n + q \log n)$。


```cpp
#include<bits/stdc++.h>
using namespace std;
//#define int long long
//#define lowbit(x) (x&(-x))
//#define bp push_back
//#define sz size
//#define cl clear
const int maxn = 2e5+114;
int n,q;
char c[maxn];
int nxt[maxn];
vector<int> E[maxn];
set<int> S[maxn];
vector<int> dp[maxn];
int fa[maxn][20];
int dep[maxn];
void dfs(int u){
	S[u].insert(u);
	for(int v:E[u]){
		dep[v]=dep[u]+1;
		fa[v][0]=u;
		for(int i=1;i<19;i++) fa[v][i]=fa[fa[v][i-1]][i-1];
		dfs(v);
		if(S[v].size()>S[u].size()) swap(S[u],S[v]);
		for(int x:S[v]) S[u].insert(x);
	}
	if(u==0) return ;
	dp[u].push_back(0);
	dp[u].push_back(u);
	int st=u+u;
	while(S[u].lower_bound(st)!=S[u].end()){
		dp[u].push_back((*S[u].lower_bound(st)));
		st=dp[u].back()+u;
	}
}
int answer[maxn];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>c[i];
	for(int i=2;i<=n;i++){
		int z=nxt[i-1];
		while(c[z+1]!=c[i]&&z!=0) z=nxt[z];
		if(c[z+1]==c[i]) z++;
		nxt[i]=z;
	}
	for(int i=1;i<=n;i++) E[nxt[i]].push_back(i);
	dfs(0);
	cin>>q;
	for(int i=1;i<=q;i++){
		int l,k;
		cin>>l>>k;
		if(k==1) cout<<1<<'\n';
		else{
			int u=l;
			for(int i=19;i>=0;i--){
				if(fa[u][i]!=0&&((dp[fa[u][i]].size()-1<k)||(dp[fa[u][i]][k]>l))) u=fa[u][i];
			}
			cout<<dep[fa[u][0]]<<'\n';			
		}
	}
	return 0;
}
/*
10
aabaacaaaa
1
10 5
*/
```

---

## 作者：xieziheng (赞：3)

我好像做的有点麻烦。

首先注意到 $A$ 是 $S[1,i]$ 的 $\text{border}$，那么考虑先建出失配树。

然后发现若 $A$ 满足条件，则 $A$ 的 $\text{border}$ 也满足条件。那么所有的 $A$ 对应失配树上从根到 $i$ 的链的前一部分，二分或者倍增就转成判定可行性问题。

考虑建出后缀数组，然后从大到小扫 $A$ 的长度 $l$，维护出所有和 $S$ 的最长公共前缀长度 $\geq l$ 的位置对应后缀数组上的区间。

那么通过枚举 $A$ 出现的次数，每次找到下一个不和这个重叠以 $A$ 为前缀的后缀，然后记录位置。那么对于位置 $A=S[1,x]$ 和询问 $i,k$，合法当且仅当 $p_{x,k}\leq i$，$p_{x,k}$ 表示 $A$ 在前缀不重叠的出现 $k$ 次最后那个位置的最小下标。

然后考虑如何维护，发现就是两个操作：

- 向集合中加入一个元素 $u$。

- 查询集合中第一个大于等于 $v$ 的元素 $x$ 的值。

可以树状数组倍增。

这样就做完了，复杂度 $\mathcal{O}(n\log^2 n +q \log n)$。

```cpp
#include <bits/stdc++.h>
#define il inline
#define pii pair<int,int>
#define fi first
#define se second
using namespace std;
typedef unsigned long long ll;
const int N=2e5+5;const ll mul=131;
int n,m,ans[N];char s[N];int sa[N],rk[N],height[N];ll h[N],pw[N];pii a[N];
il ll get(int l,int r){return h[r]-h[l-1]*pw[r-l+1];}
il bool cmp(int x,int y){
    int l=0,r=min(n-x+1,n-y+1),mid,ret=0;
    while(l<=r){
        mid=(l+r)>>1;
        if(get(x,x+mid-1)==get(y,y+mid-1)) ret=mid,l=mid+1;
        else r=mid-1;
    }
    return s[x+ret]<s[y+ret];
}
int t[N];
il void add(int x,int v){while(x<=n) t[x]+=v,x+=(x&-x);}
il int get(int x){int ret=0;while(x) ret+=t[x],x-=(x&-x);return ret;}
il int jump(int v){
    int x=0;
    for(int i=18;i>=0;--i) if(x+(1<<i)<=n && t[x+(1<<i)]<=v) x+=(1<<i),v-=t[x];
    return x+1;
}
vector<pii> e[N];
vector<int> g[N];
vector<int> f[N];
int de[N],nxt[N],fa[N][20];
void dfs(int x){
    if(x) fa[x][0]=nxt[x];else fa[x][0]=-1;
    for(int i=1;i<=18;++i) fa[x][i]=fa[fa[x][i-1]][i-1];
    for(int y:g[x]) de[y]=de[x]+1,dfs(y);
}
int mi[N],p;
il int ck(int x,int r,int k){
    return !x || (f[x].size()>k && f[x][k] && f[x][k]<=r);
}
int x,y,z,u,v,w,l,r,mid,ret;
int main(){
    scanf("%d%s",&n,s+1);
    for(int i=2,j=0;i<=n;++i){
        while(j && s[i]!=s[j+1]) j=nxt[j];
        if(s[i]==s[j+1]) ++j;
        nxt[i]=j,g[nxt[i]].push_back(i);
    }g[0].push_back(1);
    dfs(0);
    scanf("%d",&m);
    for(int i=1;i<=m;++i) scanf("%d%d",&a[i].fi,&a[i].se),e[a[i].se].push_back({a[i].fi,i});
    pw[0]=1ull;
    for(int i=1;i<=n;++i) pw[i]=pw[i-1]*mul,h[i]=h[i-1]*mul+s[i],sa[i]=i;
    stable_sort(sa+1,sa+1+n,cmp);
    for(int i=1;i<=n;++i) rk[sa[i]]=i;
    for(int i=1,k=0;i<=n;++i){
        if(!rk[i]) continue;
        if(k) --k;
        while(s[i+k]==s[sa[rk[i]-1]+k]) ++k;
        height[rk[i]-1]=k;
    }
    p=rk[1],mi[p-1]=height[p-1],mi[p+1]=height[p],mi[p]=n;
    for(int i=p-2;i>=1;--i) mi[i]=min(mi[i+1],height[i]);
    for(int i=p+2;i<=n;++i) mi[i]=min(mi[i-1],height[i-1]);
    l=r=p,add(1,1);
    for(int i=n;i;--i){
        while(l>1 && mi[l-1]>=i) add(sa[--l],1);
        while(r<n && mi[r+1]>=i) add(sa[++r],1);
        x=i;
        f[i].resize(n/i+1);
        for(int j=2;i*j<=n;++j){
            y=jump(get(x)),x=y+i-1;
            if(x>n) break;
            f[i][j]=x;
        }
    }
    for(int i=1;i<=m;++i){
        if(a[i].se==1) ans[i]=1;
        else{
            l=0,r=de[a[i].fi]-1,ret=0,x=a[i].fi;
            for(int j=18;j>=0;--j)
                if(fa[x][j]!=-1 && de[x]>=(1<<j) && !ck(fa[x][j],a[i].fi,a[i].se)) x=fa[x][j];
            ans[i]=de[x]-1;
        }
        printf("%d\n",ans[i]);
    }
    return 0;
}
```

---

## 作者：gcx12012 (赞：1)

### 前言
本题解并非最优解和标准解，且码量较大，但是思路有一定启发性。
### Solution
一道比较酷的蓝/紫串串题。

根据题意，我们得出串 $A$ 一定是串 $S$ 的某个前缀，因此我们可以先枚举 $A$。

然后考虑优先匹配最近的与串 $A$ 相等的子串。

由此我们可以得出 $S[1,i]=AB_1A B_2A\ldots AB_{k-1}A$ 的充要条件：

- 串 $S$ 中贪心匹配 $k$ 个 $A$ 的最后位置 $r\leq i$。

- $S[1,i]$ 的某个真前缀 $P$ 与相同串长的真后缀 $Q$ 相等且无交。

第二个条件可以用 KMP 处理。

对于第一个条件，我们可以先预处理每一个以位置为 $i$ 开始的后缀与整个串的最长公共前缀，然后再预处理每个串长 $|A|=i$ 时已经匹配 $k$ 个串的最后位置 $r$。匹配我用哈希+二分+ST 表写的，时间复杂度是 $O(n \log^2 n)$。

五哈希几乎卡不掉，但是常数有点大。

全部处理完以后我们考虑查询。

当 $k=1$ 时，显然只有 $S[1,i]$ 它本身符合条件。

对于其它情况，我们可以枚举 $|A|$，判断当前串长匹配 $k$ 个串时最后位置与查询位置 $i$ 的关系。

但是这样时间复杂度会爆，因为不一定每一对前后缀都能符合条件二。

我们考虑 KMP 中 nxt 数组的定义，将每一个 $i$ 与 $nxt_i$ 连边它是一棵树，于是我们只需要不断往前跳 nxt 数组计算贡献就能保证正确性。

这样的话能跑过去 $5\times 10^4$。

但是仍然不能切题，因为当 $S=\texttt{aaaaaaa}\ldots $ 时我们所跳的 nxt 链就会很长，时间复杂度就会退化到 $O(n)$。

考虑一个性质，假设两个都在 $nxt$ 树上的不同前缀的串长为 $i,j$，我们钦定 $i<j$，那么当串长为 $j$ 的那个串对答案有贡献时，串长为 $i$ 的串对答案也一定有贡献。

所以我们考虑倍增优化即可，这样的时间复杂度为 $O(n \log n)$。

加上前面的预处理可以过，但是常数较大，需要一定的优化。
### Code
```cpp
#include<bits/stdc++.h>
#include<cmath>
#define ll long long
#define lll __int128
#define ull unsigned long long
#define N 200010
#define For(i,a,b) for(ll i=a;i<=b;i++)
#define Rof(i,a,b) for(ll i=a;i>=b;i--)
#define ls x<<1
#define rs x<<1|1
#define lson ls,l,mid
#define rson rs,mid+1,r 
#define pb push_back
#define mk make_pair
#define pque priority_queue
#define pii pair<int,int>

using namespace std;
//bool st;
const ll B=333;
ll mod[5]={1000000007,1000000001,998244353,500000007,200000019},hsh[5][N],mi[5][N];
char s[N];
int n,q;
int mx[N],nxt[N][20],st[N][20];
bool ed;

ll read(){
	ll x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
ll get_hsh(int l,int r,int op){
	return (hsh[op][r]-hsh[op][l-1]*mi[op][r-l+1]%mod[op]+mod[op])%mod[op];
}
vector<int >p[N];
int qry(int l,int r){
	int k=log2(r-l+1);
	return max(st[l][k],st[r-(1<<k)+1][k]);
}

int main()
{
    //fprintf(stderr,"%d",(&ed-&st)/1024/1024);
    //freopen("match.in","r",stdin);
    //freopen("match.out","w",stdout);
    n=read();
    For(i,0,4) mi[i][0]=1;
    for(int i=1;i<=n;i++){
    	cin>>s[i];
    	For(j,0,4){
    		hsh[j][i]=(hsh[j][i-1]*B+(ll)s[i])%mod[j];
    		mi[j][i]=mi[j][i-1]*B%mod[j];
		}
	}
	int now=0;
	For(i,2,n){
		while(now && s[now+1]!=s[i]) now=nxt[now][0];
		if(s[now+1]==s[i]) now++;
		nxt[i][0]=now;
	}
	//For(i,1,n) cout<<nxt[i]<<' ';
	//cout<<endl;
	For(i,2,n){
		int l=1,r=min(n-i+1,i-1);
		while(l<=r){
			int mid=(l+r)>>1;
			int is=1;
			For(j,0,4){
				if(get_hsh(1,mid,j)!=get_hsh(i,i+mid-1,j)){
					is=0;
					break;
				}
			}
			if(!is) r=mid-1;
			else mx[i]=mid,l=mid+1;
		}
	}
	//For(i,2,n) cout<<mx[i]<<' ';
	//cout<<endl;
	for(int i=1;i<=n;i++) st[i][0]=mx[i];
	For(j,1,19){
		for(int i=1;i+(1<<j)-1<=n;i++){
			st[i][j]=max(st[i][j-1],st[i+(1<<(j-1))][j-1]);
		}
	}
	for(int i=1;i<=n;i++){
		p[i].pb(0);
		p[i].pb(i);
		int now=i+1;
		while(now<=n){
			int l=now,r=n-i+1,pos=n+1;
			while(l<=r){
				int mid=(l+r)>>1;
				if(qry(now,mid)>=i) pos=mid,r=mid-1;
				else l=mid+1;
			} 
			if(pos+i-1<=n) p[i].pb(pos+i-1);
			now=pos+i;
		} 
	}
	/*
	For(i,1,n){
		for(int v:p[i]){
			if(v) cout<<v<<' ';
		}
		cout<<endl;
	}
	*/
	for(int j=1;j<=19;j++){
		for(int i=1;i<=n;i++){
			nxt[i][j]=nxt[nxt[i][j-1]][j-1];
		}
	}
	q=read();
	while(q--){
		int x=read(),y=read();
		if(y==1){
			printf("1\n");
			continue;
		}
		int ans=0,i=nxt[x][0];
		if((int)p[i].size()>=y+1){
			if(p[i][y]<=x) ans++;
		}
		for(int j=19;j>=0;j--){
			if(!nxt[i][j]) continue;
			if((int)p[nxt[i][j]].size()>=y+1){
				if(p[nxt[i][j]][y]<=x) int nowp=0;
				else i=nxt[i][j];
			}else i=nxt[i][j];
		}
		if(i && nxt[i][0]) i=nxt[i][0],ans++;
		for(int j=19;j>=0;j--){
			if(nxt[i][j]) ans+=(1<<j),i=nxt[i][j];
		}
		printf("%d\n",ans);
	}
	return 0;
}
/*

*/
```

---

## 作者：是青白呀 (赞：1)

首先 $A$ 是 $S[1,i]$ 的 border。其次，假设 $A_1$ 在某次询问中合法，且 $A_2$ 是 $A_1$ 的一个 border，则 $A_2$ 一定也合法。因此，考虑对 $S$ 建立失配树，可行的 $A$ 一定是从根节点开始的一条链（但根节点是空串，不能计入答案）。

对于每个询问，不难想到倍增找到最长的合法串。问题转为如何快速判断一个串 $C$ 是否合法。一个串合法等价于它要在 $S[1,i]$ 中不重叠地出现 $k$ 次。不难发现若长度为 $x$ 的前缀合法，则长度大于 $x$ 的所有前缀均合法。因此我们设 $dp_{C,i}$ 表示满足 $C$ 不重叠地出现了 $i$ 次的最短合法串，首先有 $dp_{C,1}=|C|$，然后不妨贪心地写出转移方程：$dp_{C,i}=\min\{x|x\in \operatorname{subtree}_{|C|},x\geq dp_{C,i-1}+|C|\}$。暴力可以做到 $O(n^2)$。

不难注意到串 $|C|$ 的有效 dp 值不超过 $\frac{n}{|C|}$ 个，因此 dp 值的个数约为 $n\log n$ 个，是支持我们暴力求出的。我们用 set 维护每个点的子树中的点的编号集合，启发式合并即可，查询时直接在 set 上 lower_bound 即可。

最终回答询问可以直接树上倍增，每次判断跳到的点 $x$ 是否满足 $dp_{x,k}\leq i$ 即可。总复杂度 $O(n\log^2n+q\log n)$。

```cpp
#include<bits/stdc++.h>
#define rep(i,j,k) for(int i=j;i<=k;i++)
#define repp(i,j,k) for(int i=j;i>=k;i--)
#define ls(x) x*2
#define rs(x) x*2+1
#define lowbit(x) x&(-x)
#define pii pair<int,int>
#define mp make_pair
#define fir first
#define sec second
#define qingbai 666
using namespace std;
typedef long long ll;
const int N=2e5+5,M=3e5+5,mo=1e9+7,inf=1e9+7,bs=19491001;
const double eps=1e-8;
inline void read(int &p){
	int x=0,w=1;
	char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	p=x*w;
}
int n;
char s[N];
int kmp[N];//i长前缀的border长度（fa） 
int q;
int fa[N][20],dep[N];
vector<int>e[N];
set<int>st[N];
vector<int>val[N];
void dfs(int x,int f){
	fa[x][0]=f;
	if(f>=0)dep[x]=dep[f]+1;
	rep(i,1,17){
		if(fa[x][i-1]>=0)fa[x][i]=fa[fa[x][i-1]][i-1];
		else fa[x][i]=-1;
	}
	st[x].insert(x);
	for(auto j:e[x]){
		dfs(j,x);
		if(st[x].size()<st[j].size())swap(st[x],st[j]);//启发式合并求得子节点序列 
		for(auto k:st[j])
		    st[x].insert(k);
	}
	if(!x)return;
	val[x].push_back(x);
	int nwp=x;
	while(1){//每个点跳一次，长度至少增加 x，总的跳跃次数是调和级数，故总共2log. 
		set<int>::iterator it=st[x].lower_bound(x+nwp);
		if(it==st[x].end())break;
		nwp=*it,val[x].push_back(nwp);
	}
}
int main(){
	read(n);
	scanf("%s",s+1);
	for(int i=2,j=1;i<=n;i++){//j:待匹配的位置 
		while(j!=1&&s[i]!=s[j])
		    j=kmp[j-1]+1;
		if(s[i]==s[j])j++;
		kmp[i]=j-1;
	}
	rep(i,1,n)
	    e[kmp[i]].push_back(i);
	dfs(0,-1);
	read(q);
	while(q--){
		int x,k;
		read(x),read(k);
		if(k==1){
			puts("1");
			continue;
		}
		int nwp=x;
		repp(i,17,0){
			int nxtv=fa[nwp][i];
			if(nxtv<=0)continue;
			if(val[nxtv].size()<k)nwp=nxtv;
			else if(val[nxtv][k-1]>x)nwp=nxtv;
		}	
		printf("%d\n",dep[nwp]-1);
	}
	return 0;
}
```

---

## 作者：AbsMatt (赞：0)

### [题目传送器](https://www.luogu.com.cn/problem/P10716)

### [更爽的阅读体验](https://yaohaoyou.github.io/post/p10716-solution/)

## 做法 

前面的部分都和其他题解一样，先建出失配树，将问题转化成寻找有多少个点 $u(u>0)$ 满足在 $u$ 的子树中编号跳 $k-1$ 次后到达的节点 $p$ 满足 $p\le i$。

先使用启发式合并动态维护 $u$ 子树内的每个节点构成的集合，然后在这个集合中暴力跳，并储存 $dp_{u,i}$ 表示 $u$ 跳 $i$ 步后到达的节点。因为每次会从 $p$ 跳到至少为 $p+u$ 的节点，所以复杂度为 $\mathcal O(n+\frac n2+\frac n3+\dots)=\mathcal O(n\times \ln n)$。

接下来的处理询问。对于询问 $(x,k)$ 即求有多少个 $x$ 的祖先 $u$ 满足 $dp_{u,k-1}\le x$。

将询问离线下来，跑 dfs 的时候模拟栈就能直接记录从当前点到跟的路径上的信息，开 $n$ 个数据结构，第 $i$ 个维护当前链上的节点跳 $i$ 步后到达的节点的集合，需要支持增删，求排名。这里使用平衡树，应该也可以使用主席树。

总复杂度为 $O((n+q)\times \ln n \times \log_2n)$。

[AC Code](https://www.luogu.com.cn/paste/hkdq4nl6)

---

## 作者：DerrickLo (赞：0)

显然合法的 $A$ 需要满足 $A$ 是 $S[1,i]$ 的 border，并且 $A$ 在 $S[1,i]$ 中的不重叠出现次数要 $\ge k$。

那么考虑建出失配树，设 $A=S[1,j]$，那么 $j$ 一定是 $i$ 的祖先。显然如果 $S[1,j]$ 可行，那么 $S[1,fa_j]$ 也可行，所以我们只需要找到深度最大的满足条件的 $j$ 。

我们先对每个 $i$ 预处理出 $i$ 在整个串里的不重叠出现位置的集合 $s_i$。我们可以先通过树上启发式合并维护一个 set 表示以 $i$ 为根的子树里的点所构成的集合，然后求 $s_i$ 可以直接每次在 set 里 lower_bound 找到下一个合法的点。

然后对于每次询问直接倍增就可以了。

时间复杂度 $\mathcal O((n+q)\log^2n)$。

```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
int n,p[200005],j,sz[200005],son[200005],dep[200005],id[200005],nw[200005],cnt,f[200005][25],g[200005][25],q,u,k;
string s;
vector<int>ve[200005],ve2[200005];
set<int>st;
void add(int u,int op){
	if(op==1)st.insert(u);
	else st.erase(st.find(u));
}
void dfs1(int u){
	sz[u]=1,id[u]=++cnt,nw[id[u]]=u;
	for(int v:ve[u]){
		dep[v]=dep[u]+1;
		dfs1(v),sz[u]+=sz[v];
		if(!son[u]||sz[v]>sz[son[u]])son[u]=v;
	}
}
void dfs2(int u,int x){
	for(int v:ve[u]){
		if(v==son[u])continue;
		dfs2(v,1);
	}
	if(son[u])dfs2(son[u],0);
	for(int v:ve[u]){
		if(v==son[u])continue;
		for(int i=id[v];i<id[v]+sz[v];i++)add(nw[i],1);
	}
	add(u,1);
	if(u){
		int now=u;
		while(now<=n){
			ve2[u].emplace_back(now);
			if(*st.rbegin()<now+u)break;
			now=*st.lower_bound(now+u);
		}
	}
	if(x){
		for(int i=id[u];i<id[u]+sz[u];i++)add(nw[i],-1);
	}
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>s,s=" "+s;
	for(int i=2;i<=n;i++){
		while(j&&s[j+1]!=s[i])j=p[j];
		if(s[j+1]==s[i])j++,p[i]=j;
	}
	for(int i=1;i<=n;i++)ve[p[i]].emplace_back(i),f[i][0]=p[i];
	dfs1(0),dfs2(0,1);
	for(int i=1;i<=20;i++)for(int j=1;j<=n;j++)f[j][i]=f[f[j][i-1]][i-1];
	cin>>q;
	while(q--){
		cin>>u>>k;
		int now=u;
		for(int i=20;~i;i--)if(f[now][i]){
			int x=upper_bound(ve2[f[now][i]].begin(),ve2[f[now][i]].end(),u)-ve2[f[now][i]].begin();
			if(x<k)now=f[now][i];
		}
		if(k==1)cout<<1<<"\n";
		else cout<<dep[now]-1<<"\n";
	}
	return 0;
}
```

---

## 作者：Reunite (赞：0)

大水题。

先把 $k=1$ 判掉，显然可能的 $A$ 是 $S_{[1,i]}$ 的 border，且随长度有合法性单调性，可以倍增 $nxt_i$ 数组来快速找到合法分界点，现在的问题转化为快速判定 $S$ 的一段前缀是否能在 $[1,i]$ 不交地出现 $k$ 次。

不交出现问题可以直接每次找贪心最近的一段来做，因为不交，所以总段数是调和级数的。存在经典的 SAM 上对右端点的结束位置倍增做法，但这种水题显然不需要，注意到我们找的都是 $S$ 的前缀，那直接先求出所有位置的 $lcp_i$，$len$ 从小往大维护所有长度为 $len$ 的前缀的出现位置，达到 $lcp_x+1$ 的时候把 $x$ 删去，然后就只需要查后缀即可。直接 set 就行。

回到刚才的判定，一个更简单的刻画是判断 $S$ 的一段前缀最近不交出现 $k$ 次的位置是否 $\le i$，只需要一个 vector $O(1)$ 查就行了。

时间复杂度 $O(n\log^2 n+q\log n)$，空间复杂度$O(n\ln n)$。

---

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <set>
#define ll unsigned long long
using namespace std;

int n,q;
ll hs[200005];
ll bin[200005];
char c[200005];
int dep[200005];
int nxt[200005];
int fa[20][200005];
vector <int> g[200005];
vector <int> h[200005];
set <int> st;

inline void in(int &n){
	n=0;
	char c=getchar();
	while(c<'0' || c>'9') c=getchar();
	while(c>='0'&&c<='9') n=n*10+c-'0',c=getchar();
	return ;
}

inline ll get(int l,int r){return hs[r]-hs[l-1]*bin[r-l+1];}

inline int ask(int k,int x){
	if((int)h[k].size()<x) return 1e9;
	return h[k][x-1];
}

int main(){
	// freopen("qwq.in","r",stdin);
	in(n);
	scanf("%s",c+1);
	bin[0]=1;
	for(int i=1;i<=n;i++) bin[i]=bin[i-1]*131,hs[i]=hs[i-1]*131+c[i];
	for(int i=1;i<=n;i++){
		if(c[i]!=c[1]) continue;
		int l=1,r=n-i+1,mid,pos=0;
		while(l<=r){
			mid=(l+r)>>1;
			if(get(i,i+mid-1)==hs[mid]) pos=mid,l=mid+1;
			else r=mid-1;
		}
		st.insert(i);
		g[pos+1].emplace_back(i);
	}
	for(int i=1;i<=n;i++){
		for(int v:g[i]) st.erase(v);
		int pos=1;
		while(1){
			auto it=st.lower_bound(pos);
			if(it==st.end()) break;
			pos=*it+i-1;
			h[i].emplace_back(pos);
			pos++;
		}
	}
	int j=0;
	dep[1]=1;
	for(int i=2;i<=n;i++){
		while(c[j+1]!=c[i]&&j) j=nxt[j];
		if(c[j+1]==c[i]) j++;
		nxt[i]=j;
		dep[i]=dep[j]+1;
		fa[0][i]=nxt[i];
	}
	nxt[1]=1;
	for(int j=1;j<=18;j++)
		for(int i=1;i<=n;i++) fa[j][i]=fa[j-1][fa[j-1][i]];
	in(q);
	while(q--){
		int k,x;
		in(k),in(x);
		if(x==1){puts("1");continue;}
		if(!dep[k]){puts("0");continue;}
		int u=k;
		for(int i=18;i>=0;i--){
			if(!fa[i][u]) continue;
			int v=fa[i][u];
			if(ask(v,x)>k) u=v;
		}
		printf("%d\n",dep[u]-1);
	}

	return 0;
}
```

---

## 作者：int08 (赞：0)

## 前言
作为一道串串题，我会认为这道题目的创新点是调和级数。（虽然估计也不少见了，可能是我见识短浅了吧）
# Solution

假设对于完整的 $S$（暂时不考虑前缀），某个子串 $A$ 是符合条件的答案，观察可得，由于 $A$ 在 $S$ 开头结尾都出现了一次，说明 $A$ 是 $S$ 的一个 border。

而不重叠地出现 $k$ 次的条件则是使用贪心的方案，每次寻找不重叠且满足条件中最靠前的一个。

考虑到符合条件的 $A$ 只能是 $S$ 的 $n$ 个前缀，设 $f_{i,j}$ 表示长为 $i$ 的前缀第 $j$ 次**不重叠**出现的最靠前位置，这个状态数是调和级数，居然是 $n\ln n$ 的。

第一层枚举前缀长度，也就是说我们只要控制寻找下一个满足条件的位置的速度尽量快，就可以较快预处理这个玩意了。

### 较快查找下一个

我不懂各位为什么都用 KMP……照理来说这种限制开头位置（而不是结尾）的问题更近似于 LCP 啊……

现在出现两个选择：Z 函数、后缀数组，但是由于我们不需要求任意两个后缀的 LCP，而是只需要查询某个后缀和开头的 LCP，故使用前者即可。

现在假设枚举的 $|A|=i$ 找到下一个满足条件的位置，也就是求 $z_x\ge i$ 的集合中关于某个数的后继，显然可以使用主席树，不过由于查询是有顺序的，从大到小枚举，一轮一轮加入 `set` 找后继，或者从小到大枚举，使用并查集模拟链表删除和找后继，前两者复杂度 $n\log^2n$，最后一个复杂度更优秀。

那么现在预处理的部分结束后，我们就可以 $O(1)$ 判断某串 $A$ 能否成为 $(i,k)$ 询问的答案了，但是这仍然不够。

### 树上倍增

因为对于某个前缀，只有所有 border 可能成为答案，所以建立出失配树，只需要检测失配树上该点的所有祖先。

但是我们又发现一旦某个串能作为答案了，它的所有 border 都是它的子串，也是合法答案，体现到失配树上就是从询问走到跟，前面一部分不符合条件，后面一部分全部符合条件，具有单调性。

显然可以使用树上倍增跳出分界点，然后分界点的深度就是答案。

细节有一点点多，不过代码意外地不长。

## AC Code
```cpp
#include<bits/stdc++.h>
#define N 208555
using namespace std;
int n,m,l,r,i,j,z[N],fail[N],q;
string s;
vector<int> p[N],zs[N],e[N];
set<int> ava;
int d[N],f[N][20];
void dfs(int u)
{
	for(int i=1;(1<<i)<=d[u];i++) f[u][i]=f[f[u][i-1]][i-1];
	for(auto v:e[u])
	{
		d[v]=d[u]+1;f[v][0]=u;
		dfs(v);
	}
}
int ask(int x,int k)
{
	int xx=x;
	if(k==1) return 1;
	for(i=19;i>=0;i--)
	{
		int v=f[x][i];
		if(v&&(p[v].size()<k||p[v][k-1]>=xx)) x=v; 
	}
	return d[x]-1;
}
signed main()
{
	cin>>n>>s>>q;
	for(i=1;i<s.length();i++)
	{
		if(i>r)
		{
			for(j=i;j<s.length()&&s[j]==s[j-i];j++);
			z[i]=j-i;
			if(z[i]) l=i,r=j-1;
		}
		else
		{
			if(z[i-l]+i<=r) z[i]=z[i-l];
			else
			{
				for(j=r;j<s.length()&&s[j]==s[j-i];j++);
				z[i]=j-i;
				l=i,r=j-1;
			}
		}
		zs[z[i]].push_back(i);
		int f=fail[i-1];
		while(s[i]!=s[f]&&f>0) f=fail[f-1];
		if(s[i]==s[f]) fail[i]=f+1;
		e[fail[i]].push_back(i+1);
	}
	e[0].push_back(1);
	for(i=n;i>=1;i--)
	{
		p[i].push_back(i-1);
		for(auto x:zs[i]) ava.insert(x);
		while(ava.upper_bound(*(--p[i].end()))!=ava.end()) p[i].push_back(*ava.upper_bound(*(--p[i].end()))+i-1);
	}
	dfs(0);
	while(q--)
	{
		cin>>l>>r;
		cout<<ask(l,r)<<endl;
	}
	return 0;
}
```
# The End.

---

## 作者：tzl_Dedicatus545 (赞：0)

怎么没有小清新 SA 题解/cf

$S$ 出现在 $i$ 的充要条件是 $lcp(S,i)\geq i$。

先倍增找到满足条件的串 $S$ 所有可能的出现位置的 `rank` 之后，我们的目的就是在区间 $[l,r]$ 查询后面第一个 $S$，这个直接在可持久化线段树上二分即可。

求出来每个串第 $k$ 次出现位置的最小值之后，在 border 树上二分祖先即可，这样可以省去一个空间的 $\log$。

空间 $O(n\log n)$

---


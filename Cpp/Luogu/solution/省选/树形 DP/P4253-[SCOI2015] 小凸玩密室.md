# [SCOI2015] 小凸玩密室

## 题目描述

小凸和小方相约玩密室逃脱，这个密室是一棵有 $n$ 个节点的完全二叉树，每个节点有一个灯泡。点亮所有灯泡即可逃出密室。每个灯泡有个权值 $a_i$，每条边也有个权值 $b_i$。点亮第一个灯泡不需要花费，之后每点亮一个新的灯泡 $v$ 的花费，等于上一个被点亮的灯泡 $u$ 到这个点 $v$ 的距离 $D_{u,v}$，乘以这个点的权值 $a_v$。在点灯的过程中，要保证任意时刻所有被点亮的灯泡必须连通，在点亮一个灯泡后必须先点亮其子树所有灯泡才能点亮其他灯泡。请告诉他们，逃出密室的最少花费是多少。

## 说明/提示

对于 $10$% 的数据， $1 \leq n \leq 10$

对于 $20$% 的数据， $1 \leq n \leq 20$

对于 $30$% 的数据， $1 \leq n \leq 2000$

对于 $100$% 的数据， $1 \leq n \leq 2 \times 10^5, 1 \leq a_i, b_i \leq 10^5$

## 样例 #1

### 输入

```
3
5 1 2
2 1
```

### 输出

```
5```

# 题解

## 作者：Mihari (赞：32)

# T 「SCOI2015」小凸玩密室
## 题目
[点这里](https://loj.ac/problem/2009)
## 考场思路
题目读错了，导致我暴力都打不出来...

其实题目要求的是一定要将某一棵子树全部扫完再去扫其他的子树。

而不是左边扫一下，右边扫一下...

## 正解

首先，这里补充一个数据范围 ~~（考试的时候也有）~~ 
___
对于 $10\%$ 的数据，$1≤n≤10$；

另有 $10\%$ 的数据， $1≤n≤20$ ；

另有 $10\%$ 的数据， $1≤n≤2000$ ；

另有 $20\%$ 的数据， $1≤n≤20000$ ；

对于 $100\%$ 的数据， $1≤n≤2\times 10^5$ ， $1≤A_i≤10^5$ ， $1≤B_i≤10^5$ 。
___
再次引用这句话 ~~虽然是我自己编的~~ 

>所谓信息竞赛，其实就是面向数据编程

其实，根据数据范围，一步一步想出算法并优化其实也是一个解题的好方法。
___
### `子方案 1 (10pts)`
首先，看前 $10\%$ 的数据，这个地方我们可以怎么做呢？

这样的暴力其实很简单，用 $O(n!)$ 枚举我们访问的顺序。

再判断这个顺序是否合法，最后计算花费即可。
___
### `子方案 2 (20pts)`
但是很明显，对于 $10pts$ 的算法，是过不了第二个 $10pts$ 的数据点的。

怎么进行优化？

注意到子方案 $1$ 中有这样的操作：

随意枚举顺序，再判断是否合法。

这样做让我们用很多时间枚举了很多不合法的访问顺序。

那么我们是否可以让我们枚举的序列本来就合法，只需直接去算花费？

这是肯定可以的，时间复杂度 $O(2^n)$，因为我们要分左、右儿子去构造访问顺序。

这样，时间复杂度应该是 $O(n2^n\cdot nlog^n_2)$。
___
### `子方案 3 (50pts)`
对于子方案 $2$ 的优化显然是很好的，但是这都基于 `暴力` 这一思想，接下来我们需要转换思路。

考虑我们是怎么点亮一个子树的。

对于一个子树，它的根是 $u$，左儿子是 $lc$，右儿子是 $rc$。

假若我们先访问左子树，先不管它是怎么访问的。

那么，我们在左子树里面的访问顺序是否对后面的状态有影响？

是有的，证明如下： ~~本人数学不好，没有严格数学书写顺序~~ 

假设我们在左子树里面的访问顺序中的某一种是以 $x$ 结尾。

很显然这个 $x$ 有很多个。

而当我们从左子树到右子树去的时候，先要访问右子树的树根，即 $rc$。

那么这个花费显然是 $dis(x,rc)*A[rc]$。

而又因为这个 $x$ 有很多个，那么很显然。不同的 $x$ 是会有不同的花费。

因而左子树里面的访问顺序是对后面的状态有影响。

而且很显然，对后面状态有影响的只有最后访问的那个点在哪里。

所以，我们就可以定义状态 $f[u][x]$ 为访问完以 $u$ 为根的子树（不包含 $u$）且结尾在 $x$ 时的最小花费。

那么，就可以分类进行状转：

 - 当 $x$ 在左子树上时，$f[u][y]=min\{dis(u,lc)\times A[lc]+f[lc][x]+dis(x,rc)\times A[rc]+f[rx][y]\}$
 - 当 $x$ 在右子树上时，$f[u][y]=min\{dis(u,rc)\times A[rc]+f[rc][x]+dis(x,lc)\times A[lc]+f[lc][y]\}$

很显然，状转中 $x、y$ 都是需要循环枚举的，因而这个状转大概是 $O(n^2)$ 的复杂度。

所以总复杂度是 $O(n^3)$。

但其实这样的计算是不准确的，准确复杂度应该是 $\sum\frac{n^2}{2^{x+2}}$。

这个复杂度是通过**分层计算**得出。

不难看出，这个复杂度可得到 $50pts$ 的高分。
___

### `子方法 4 (正解)`
我们发现，对于子方法三，其实已经快要过掉这道题了。

但是哪里的时间复杂度较高呢？

毋庸置疑的，状转的 $O(n^2)$ 其实已经非常高了。

怎么减下来？肯定是要针对其状转简化。

观察状转：
 - 当 $x$ 在左子树上时，$f[u][y]=min\{dis(u,lc)\times A[lc]+f[lc][x]+dis(x,rc)\times A[rc]+f[rx][y]\}$
 - 当 $x$ 在右子树上时，$f[u][y]=min\{dis(u,rc)\times A[rc]+f[rc][x]+dis(x,lc)\times A[lc]+f[lc][y]\}$

我们先考虑其中一个状转，另一个其实是对应的。

拿第一个算式来说

$$f[u][y]=min\{dis(u,lc)\times A[lc]+f[lc][x]+dis(x,rc)\times A[rc]+f[rx][y]\}$$
考虑将其分解：

对于 $dis(x,rc)$ ，其实不难看出

$$dis(x,rx)=dis(x,u)+dis(u,rc)$$
而这里面，只有 $dis(x,u)$ 是改变的。

那么我们只需将 $dis(x,u)$ 也存入状态中，就可以同时考虑它的最小值了。

所以，访问一边的最小花费就是

$$ans2=f[lc][x]+dis(u,rc)\times A[rc]+[dis(u,x)+dis(u,rc)]\times A[rc]$$

最后的花费，就是 $ans2+f[lc][x]$ 了。

最后，根据这个 $x$ 到底在左边还是在右边进行分类转移即可。

但是，这就是最后的答案了吗？

**肯定不是，题目并未要求我们必须从 $1$ 开始**。

所以，定义另一个状态 $t[i][j]$：访问完 $i$ 的子树，结尾在 $j$ 时的最小花费。

那么这个怎么转移呢？

~~这里可以自行思考了~~ 

如果还是想不出来，看看代码吧，看看代码总有好处的

`std version`

```cpp
#include<bits/stdc++.h>
#define mz 1000000007
using namespace std;

long long inf=mz*1LL*mz;
long long dep[200005];
int n,a[200005],b[200005];
vector <long long> dp[200005],dis[200005],dpp[200005];

void dfs(int x)
{
    dep[x]=dep[x/2]+b[x];//计算伪深度, 方便计算距离
    if(x*2<=n)//有左儿子
    {
        dfs(x*2);//先访问左儿子
        int t=dp[x*2].size();//得到左儿子的叶子共有多少个
        if(x*2+1<=n)//如果有右儿子
        {
            dfs(x*2+1);//访问右儿子
            long long ans1=inf,ans2=inf,ansp1=inf,ansp2=inf;
            //分别是 f, t
            for(int i=0;i<dp[x].size();i++)
            {
                if(i<t)//如果这个点是左子树上的点
                {

                    ans1=min(ans1,dp[x*2][i]+1LL*b[x*2]*a[x*2]+(dis[x][i]+b[x*2+1])*a[x*2+1]);
                    ansp1=min(ansp1,dpp[x*2][i]+dis[x][i]*a[x]+1LL*b[x*2+1]*a[x*2+1]);
                }
                else//当这个点是右子树上的点
                {
                    ans2=min(ans2,dp[x*2+1][i-t]+1LL*b[x*2+1]*a[x*2+1]+(dis[x][i]+b[x*2])*a[x*2]);
                    ansp2=min(ansp2,dpp[x*2+1][i-t]+dis[x][i]*a[x]+1LL*b[x*2]*a[x*2]);
                }
            }
            for(int i=0;i<dp[x].size();i++)
            {
                if(i<t)//如果它是左儿子
                {
                    dp[x][i]=ans2+dp[x*2][i];
                    dpp[x][i]=min(dp[x][i],ansp2+dp[x*2][i]);
                }
                else//是右儿子
                {
                    dp[x][i]=ans1+dp[x*2+1][i-t];
                    dpp[x][i]=min(dp[x][i],ansp1+dp[x*2+1][i-t]);
                }
            }
        }
        else//没有右儿子
        {
            for(int i=x;i>=1;i=i/2)
            {
                dp[i].push_back(0);
                dpp[i].push_back(0);
                dis[i].push_back(dep[x]-dep[i]);
            }
            dp[x][0]=1LL*b[x*2]*a[x*2];
            dpp[x][0]=inf;
            dp[x][1]=inf;
            dpp[x][1]=1LL*b[x*2]*a[x];
        }
    }
    else//没有后辈
    {
        for(int i=x;i>=1;i=i/2)
        {
            dp[i].push_back(0);
            dpp[i].push_back(0);
            dis[i].push_back(dep[x]-dep[i]);
        }
    }
}

int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    for(int i=2;i<=n;i++)
        scanf("%d",&b[i]);
    dfs(1);
    long long ans=inf;
    for(int i=0;i<dp[1].size();i++)
        ans=min(ans,dpp[1][i]);
    printf("%lld\n",ans);
    return 0;
}
```


---

## 作者：Captain_Paul (赞：25)

神奇的树形dp系列

先看一下题目给出的条件：

1、完全二叉树

2、任意时刻点亮的灯泡必须连通

3、点亮一个灯泡后必须先点亮其子树

那么点亮灯泡的过程就类似这样：

点亮灯泡k,点亮它的一个子树，再点亮它另外的子树，

然后回到k的父节点，点亮fa之后再点亮fa的其他子树……

所以对于一个节点u，有这样两种情况:

u还没有被点亮，则下一个被点亮的一定是它的儿子

u是叶子节点，在下一个被点亮的一定是它的某一级祖先，或者是它某一级祖先的儿子

我们定义dp数组f和g

f[i][j]表示点亮i之后回到i的第j个祖先的最小花费

g[i][j]表示点亮i之后回到i的第j个祖先的另一个儿子的最小花费

然后从下到上，由儿子的状态转移到父亲的状态

注意讨论当前节点的儿子个数。

最后统计答案时，根据点亮的过程累加即可。

ps:由于这是一棵完全二叉树，所以可以不用递归的方式dfs

直接预处理出每个节点的儿子和它到各级祖先的距离，用循环转移即可。

此题数据贼大，所以最终答案ans的初值一定要开大！

丑陋的代码：

```cpp
#include<cstdio>
#include<cstring>
#include<cctype>
#include<algorithm>
#define reg register
using namespace std;
typedef long long ll;
const int N=2e5+5;
int n,num,w[N],fa[N],ls[N],rs[N];
ll f[N][20];//f表示i是亮的，回到i的第j个祖先的最小花费
ll g[N][20];//g表示i是亮的，回到i的第j个祖先的另一个儿子的最小花费 
ll dis[N][20];//dis表示从i到i的第j个祖先的距离 
ll ans=1e17;
inline int read()
{
	int x=0,w=1;
	char c=getchar();
	while (!isdigit(c)&&c!='-') c=getchar();
	if (c=='-') c=getchar(),w=-1;
	while (isdigit(c))
	{
		x=(x<<1)+(x<<3)+c-'0';
		c=getchar();
	}
	return x*w;
}
inline int brother(int k,int x)//k的第x个祖先的另一个儿子 
{
	return (k>>(x-1))^1;
}
inline ll getans()
{
	for (reg int k=n;k>=1;k--)
	{
		if (!ls[k])//k为叶子节点
		  for (reg int i=1;k>>(i-1);i++)
		    g[k][i]=(dis[k][i]+dis[brother(k,i)][1])*w[brother(k,i)];
		else if (!rs[k])//k只有左儿子
		  for (reg int i=1;k>>(i-1);i++)
		    g[k][i]=dis[ls[k]][1]*w[ls[k]]+g[ls[k]][i+1];
		else//k有两个儿子
		  for (reg int i=1;k>>(i-1);i++)
		    g[k][i]=min(dis[ls[k]][1]*w[ls[k]]+g[ls[k]][1]+g[rs[k]][i+1],dis[rs[k]][1]*w[rs[k]]+g[rs[k]][1]+g[ls[k]][i+1]);
	}
	for (reg int k=n;k>=1;k--)
	{
		if(!ls[k])
		  for (reg int i=1;k>>(i-1);i++)
		    f[k][i]=dis[k][i]*w[k>>i];
		else if (!rs[k])
		  for (reg int i=1;k>>(i-1);i++)
		    f[k][i]=f[ls[k]][i+1]+dis[ls[k]][1]*w[ls[k]];
		else
		  for (reg int i=1;k>>(i-1);i++)
		    f[k][i]=min(dis[ls[k]][1]*w[ls[k]]+g[ls[k]][1]+f[rs[k]][i+1],dis[rs[k]][1]*w[rs[k]]+g[rs[k]][1]+f[ls[k]][i+1]);
	}
	for (reg int k=1;k<=n;k++)
	{
		reg ll sum=f[k][1];
		for (reg int i=1,fa=k>>1;fa;++i,fa>>=1)
		{
			reg int bro=brother(k,i);
			if (bro>n) sum+=dis[fa][1]*w[fa>>1];
			else sum+=dis[bro][1]*w[bro]+f[bro][2];
		}
		ans=min(ans,sum);
	}
	return ans;
} 
int main()
{
	n=read();
	for (reg int i=1;i<=n;w[i++]=read());
	for (reg int i=2;i<=n;i++) dis[i][1]=(ll)read();
	for (reg int i=1;i<=(n>>1)+1;i++)//完全二叉树 
	{
		if ((i<<1)<=n) ls[i]=(i<<1);
		else break;
		if ((i<<1|1)<=n) rs[i]=(i<<1|1);
	}
	for (reg int i=2;i<=18;i++)
	  for (reg int k=n;k>>i;k--)
	    dis[k][i]=dis[k][i-1]+dis[k>>(i-1)][1];
	printf("%lld\n",getans());
	return 0;
}
```

---

## 作者：nofind (赞：17)

题意:https://www.luogu.org/problem/P4253

神仙树形DP题

观察遍历顺序:

1.先点亮这个点

2.在儿子中选一个点递归,点亮这个儿子的子树(最后一个必定是一个叶子)

3.返回这个点

4.递归另一个儿子

5.向上回溯

考虑如果n比较小就是常见的树形DP,转移枚举是从兄弟节点的哪个叶子转移即可

既然无法枚举叶子结点,不妨倒推,对叶子节点处理转移到哪里的花费,之后倒推回根节点,对于结点x,枚举先递归左子树还是右子树,处理完x的子树后,x下一步有两种选择：

1.回溯到x的某个祖先

2.回溯到x的某个祖先的另一个儿子(子树中不包含x的那一个)

$f[i][j][0/1]$表示处理完$i$的子树后,下一个转移到$i$的$j$级祖先(0)/$j$级祖先的另一个儿子(1)

定义$dis[i][j]$表示$i$到$i$的$j$级祖先的距离,$fa(i,j)$表示$i$的$j$级祖先是谁,$brother(i,j)$表示$i$的$j$级祖先的另一个儿子

对于结点x:

x是叶子结点

$f[x][i][0]=dis[x][i]*a[fa(x,i)]$

$f[x][i][1]=(dis[x][i]+dis[brother(x,i)][1])*a[brother(x,i)]$

对于叶子结点直接处理它到下一个点的距离*点权

x不是叶子结点:

定义$ls(p)$表示$p$的左儿子,$rs(p)$表示$p$的右儿子

<1>x有左儿子无右儿子:

$f[x][i][0]=f[ls(x)][i+1][0]+dis[ls(x)][1]*a[ls(x)]$

$f[x][i][1]=f[ls(x)][i+1][1]+dis[ls(x)][1]*a[ls(x)]$

只有左儿子自然只能从左儿子转移,代价要加上从x到ls(x)的代价

<2>x有左右儿子:

在先走左儿子还是先走右儿子中取min

$f[x][i][0]=min(f[ls(x)][1][1]+f[rs(x)][i+1][0]+dis[ls(x)][1]*a[ls(x)],f[rs(x)][1][1]+f[ls(x)][i+1][0]+dis[rs(x)][1]*a[rs(x)]);$


$f[x][i][1]=min(f[ls(x)][1][1]+f[rs(x)][i+1][1]+dis[ls(x)][1]*a[ls(x)],f[rs(x)][1][1]+f[ls(x)][i+1][1]+dis[rs(x)][1]*a[rs(x)]);$

求答案就是枚举起点向上跳,有兄弟就把兄弟加上

code:
```
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define fa(i,j) ((1<<(j-1)<=i)?(i>>j):-1)
#define ls(p)(p<<1)
#define rs(p)(p<<1|1)
#define brother(i,j)((i>>(j-1))^1)
const int maxn=2*1e5+10;
int n,cnt,ans;
int a[maxn],ls[maxn],rs[maxn];
int dis[maxn][20],f[maxn][20][2];
inline int check(int i,int j){return 1<<(j-1)<=i?i>>j:-1;}
inline void solve()
{
	for(int i=n;i;i--)
	{
		for(int j=1;~fa(i,j);j++)
		{
			f[i][j][0]=f[i][j][1]=0x3f3f3f3f3f3f3f3f; 
			if((i<<1)>n)f[i][j][0]=dis[i][j]*a[fa(i,j)],f[i][j][1]=(dis[i][j]+dis[brother(i,j)][1])*a[brother(i,j)];
			else if((i<<1|1)>n)
				f[i][j][0]=f[ls(i)][j+1][0]+dis[ls(i)][1]*a[ls(i)],f[i][j][1]=f[ls(i)][j+1][1]+dis[ls(i)][1]*a[ls(i)];
			else
			{
				f[i][j][0]=min(f[i][j][0],f[ls(i)][1][1]+f[rs(i)][j+1][0]+dis[ls(i)][1]*a[ls(i)]);
				f[i][j][0]=min(f[i][j][0],f[rs(i)][1][1]+f[ls(i)][j+1][0]+dis[rs(i)][1]*a[rs(i)]);
				f[i][j][1]=min(f[i][j][1],f[ls(i)][1][1]+f[rs(i)][j+1][1]+dis[ls(i)][1]*a[ls(i)]);
				f[i][j][1]=min(f[i][j][1],f[rs(i)][1][1]+f[ls(i)][j+1][1]+dis[rs(i)][1]*a[rs(i)]);
			} 
		}
	}
	ans=0x3f3f3f3f3f3f3f3f;
	for(int s=1;s<=n;s++)
	{
		int tmp=f[s][1][0];
		for(int i=fa(s,1),last=s;~i;i=fa(i,1),last=fa(last,1))
		{
			if(brother(last,1)<=n)tmp+=dis[brother(last,1)][1]*a[brother(last,1)]+f[brother(last,1)][2][0];
			else tmp+=dis[i][1]*a[fa(i,1)];
		}
		ans=min(ans,tmp);
	}
	printf("%lld",ans);
}
signed main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
	dis[1][1]=0;
	for(int i=2;i<=n;i++)
	{
		scanf("%lld",&dis[i][1]);
		for(int j=2;~fa(i,j);j++)dis[i][j]=dis[fa(i,1)][j-1]+dis[i][1];
	}
	solve();
	return 0;
}
```



---

## 作者：_Sein (赞：9)

这道题实在太苟了。

因为不知道$dist(u,v)$的$u$从子树的哪个位置来，但确定一定是**某一个叶子节点**。

还要处理是哪个子树先进行，好烦啊。。。

那就预处理一下叶子结点吧，有状态$f_{i,j,0}$表示从$i$号叶子结点返回到它的第$j$个祖先(未点灯)的费用。

这个不难处理$f_{i,j,0}=dist(i,p_{i,j})*a_{p_{i,j}}$

从一个子树中出来，进到另一个子树的情况把它简化成两个叶子结点之间的转移。

有$f_{i,j,1}$表示从$i$号叶子结点返回到它的第$j$个祖先(未点灯)的另一个儿子的费用

这个也不难，所以不写了。

好了，现在有两棵子树$ls,rs$，根节点$i$。

根据$DP$的思想，现在已经处理好了$ls,rs$的状态。

如果根节点要返回到第$j$个祖先，那么返回的起点就一定来自于左子树，或者右子树的某一个叶子结点。

根据之前的预处理，就可以联想到根节点的状态如何定义与转移。

$f_{i,j,0}$表示已经处理好了以$i$为根的子树，且返回到它的第$j$个祖先的费用

$f_{i,j,1}$同理，具体方程见代码。

**但是**，

这道题还有一个坑点，并没确定哪个是第一个点亮的。

所以还需要进行一些操作。

```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<cmath>
#define ll long long
#define gc getchar()
#define eps 1e-8
using namespace std;
const int N=2e5+5,mod=20170408;
template<class o>
inline void qr(o &x)
{
	x=0;char c=gc;int f=1;
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=gc;}
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=gc;}
	x*=f;
}
template<class o>
void qw(o x)
{
	if(x<0)putchar('-'),x=-x;
	if(x/10)qw(x/10);
	putchar(x%10+48);
}
ll f[N][19][2],d[N][19],b[N],a[N];int Log[N];int n;
void dp()
{
	for(int i=n;i;i--)
		for(int j=1;j<=Log[i];j++)
		{
			int w=(i>>(j-1))^1;
			if((i<<1)>n)
			{
				f[i][j][0]=d[i][j]*a[i>>j];
				f[i][j][1]=(d[i][j]+d[w][1])*a[w];
			}
			else if(((i<<1)|1)>n)
			{
				int ls=i<<1;
				f[i][j][0]=f[ls][j+1][0]+d[ls][1]*a[ls];
				f[i][j][1]=f[ls][j+1][1]+d[ls][1]*a[ls];//要下去到ls，也要算上。 
			}
			else
			{
				int ls=i<<1,rs=i<<1|1;
				f[i][j][0]=min(f[ls][j+1][0]+f[rs][1][1]+d[rs][1]*a[rs],f[rs][j+1][0]+f[ls][1][1]+d[ls][1]*a[ls]);
				f[i][j][1]=min(f[ls][j+1][1]+f[rs][1][1]+d[rs][1]*a[rs],f[rs][j+1][1]+f[ls][1][1]+d[ls][1]*a[ls]);
			}
		}
	ll ans=0x3f3f3f3f3f3f3f3f;
	for(int i=1;i<=n;i++)
	{
		ll tmp=f[i][1][0];int t=1;
		for(int x=i>>1,lst=i;t<=Log[i];lst=x,x=x>>1)
		{
			int w=lst^1;++t;
			if(w<=n)tmp+=d[w][1]*a[w]+f[w][2][0];//如果有，那就继承。 
			else tmp+=d[x][1]*a[x>>1];//如果没有，让x上去，因为x是最后点亮那个 
		}
		ans=min(tmp,ans);
	}
	qw(ans);puts("");
}
int main()
{
	qr(n);
	for(int i=1;i<=n;i++)Log[i]=Log[i>>1]+1;
	for(int i=1;i<=n;i++)qr(a[i]);
	for(int i=2;i<=n;i++)qr(b[i]);
	for(int i=2;i<=n;i++)
		for(int j=1;j<Log[i];j++)
			d[i][j]=d[i>>1][j-1]+b[i];
	dp();
	return 0;
}
```

---

## 作者：妩媚的ak萝莉 (赞：7)

[loj](https://loj.ac/problem/2009)
[Luogu](https://www.luogu.org/problem/P4253)
[bzoj](https://www.lydsy.com/JudgeOnline/problem.php?id=4446)

## 题解:
本题有要求：要连续，还要先走完子树，还最多只有$O(log n)$层（完全二叉树），容易想到这样的思路：dp预处理出走完子树的代价，然后暴力枚举每个点，暴力向上走顺便$O(1)$处理子树，可是发现点亮每一个点的代价与上一次点亮的点有关，为了消除后效性，需要在dp数组里记录下一个要点亮的点，如直接记录，$O(n^2)$时空复杂度均爆，但不难发现下一个要点亮的点要么是该点的祖先，要么是该点祖先的另一个儿子，一个点最多$O(log n)$个祖先，于是此题解决了；

注：~~此题细节较多，做好心理准备~~

## 代码：
```cpp
#include <iostream>
#include <stdio.h>
#include <vector>
using namespace std;
typedef long long ll;
const int N=2e5+50;
struct Node{
	int t,w;
};
int n,ca[N],whi[N][20][2],son[N][2],sont[N],fa[N],Root;
ll ai[N],dis[N],dp[N][20][2],val[N],ans=9223372036854775807ll,ans1;
vector<Node> gg[N];

void addegde(int u,int v,int w){
	gg[u].push_back((Node){v,w});
	gg[v].push_back((Node){u,w});
}

inline int _Sonn(int now){
	int nex=fa[now];
	if(son[nex][0]==now) return son[nex][1];
	return son[nex][0];
}

void dfs_pre(int now){
	if(now!=Root){
		whi[now][ca[now]][0]=now;
		whi[now][ca[now]][1]=_Sonn(now);
		for(int a=1;a<ca[now];a++){
			whi[now][a][0]=whi[fa[now]][a][0];
			whi[now][a][1]=whi[fa[now]][a][1];
		}
	}
	int siz=gg[now].size(),tot=-1;
	for(int i=0;i<siz;i++)
	{
		int nex=gg[now][i].t;
		if(nex==fa[now]) continue;
		son[now][++tot]=nex;
		fa[nex]=now;
		ca[nex]=ca[now]+1;
		dis[nex]=dis[now]+((ll)gg[now][i].w);
	}
	sont[now]=tot+1;
	for(int i=0;i<sont[now];i++){
		dfs_pre(son[now][i]);
	}
}

inline ll cal(int now,int a,int fir,int ord){
	ll kai=(dis[son[now][fir]]-dis[now])*ai[son[now][fir]];
	if(sont[now]==1 && a>0) return kai+dp[son[now][fir]][a][ord];
	if(sont[now]==1 && a<0) return kai;
	if(a<0) return kai+dp[son[now][fir]][ca[son[now][fir]]][1]+val[son[now][!fir]];
	return kai+dp[son[now][fir]][ca[son[now][fir]]][1]+dp[son[now][!fir]][a][ord];
}

void dfs(int now)
{
	if(sont[now]==0){
		for(int a=1;a<=ca[now];a++){
			int a0=whi[now][a][0],a1=whi[now][a][1],ap0=whi[now][a-1][0];
			dp[now][a][0]=(dis[now]-dis[a0])*ai[a0];
			if(a!=1) dp[now][a][1]=(dis[a1]+dis[now]-2ll*dis[ap0])*ai[a1];
		}
		return;
	}
	for(int i=0;i<sont[now];i++)
		dfs(son[now][i]);
	for(int a=1;a<=ca[now];a++){
		if(sont[now]==1){
			dp[now][a][0]=cal(now,a,0,0);
			if(a!=1) dp[now][a][1]=cal(now,a,0,1);
		}
		else
		{
			dp[now][a][0]=min(cal(now,a,0,0),cal(now,a,1,0));
			if(a!=1) dp[now][a][1]=min(cal(now,a,0,1),cal(now,a,1,1));
		}
	}
	if(sont[now]==1) val[now]=cal(now,-1,0,-1);
	else val[now]=min(cal(now,-1,0,-1),cal(now,-1,1,-1));
	return;
}

```

---

## 作者：crashed (赞：4)

# Update
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;感谢@tommy0103的指正，已更新代码。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意$n=4$的特判，有单链的走法并不代表$f$和$g$求出来的走法不是最优的。  
# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.org/problem/P4253)看题目。  
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$n\le20$的数据，应该都会吧：直接$2^n$枚举合法方案即可。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面考虑正紧解法：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们先把问题给简化一下，先规定，每次出发的起点都是$1$。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑从$u$开始出发，我们必须先走完左子树/右子树；然后，我们必然从左边/右边的一个叶节点往上走，跨过$u$之后走到右子树/左子树里面继续去关灯。可以发现，这样只有根和停下来的那个叶节点会影响答案，所以可以这样设计状态：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$f(u,i)$：从$u$节点出发，关完子树中的灯，停在了$i$叶节点上面的最小时间。   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设$leaf(u)$为$u$结点的子树中的叶子的集合，则不难发现如下转移：  
$$f(u,i)=\begin{cases}\min_{j\in leaf(2u+1)}\{D_{u,2u+1}A_{2u+1}+f(2u+1,j)+D_{j,2u}A_{2u}+f(2u,i)\}&i\in leaf(2u)\\\min_{j\in{leaf(2u)}}\{D_{u,2u}A_{2u}+f(2u,j)+D_{j,2u+1}A_{2u+1}+f(2u+1,i)\}&i\in leaf(2u+1)\end{cases}$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设$s_u$表示$u$到根节点的距离，$c(u,0/1)$表示$u$到左子树/右子树的边的长度。以先左后右的顺序遍历子树为例，则还可以得到：　  
$$f(u,i)=\min_{j\in leaf(2u)}\{D_{u,2u}A_{2u}+f(2u,j)+D_{j,2u+1}A_{2u+1}+f(2u+1,i)\}$$  
$$\Rightarrow f(u,i)=\min_{j\in leaf(2u)}\{c(u,0)A_{2u}+f(2u,j)+(s_j-s_u+c(u,1))A_{2u+1}+f(2u+1,i)\}$$  
$$\Rightarrow f(u,i)=\min_{j\in leaf(2u)}\{f(2u,j)+s_jA_{2u+1}\}+c(u,0)A_{2u}+(c(u,1)-s_u)A_{2u+1}+f(2u+1,i)$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以在转移之前预处理出$\min_{j\in leaf(2u)}\{f(2u,j)+s_jA_{2u+1}\}$，然后转移就变成$O(1)$的了。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先右后左的情况是一样的。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在考虑原来的题目——不一定从$1$出发！  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再设一个状态：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$g(u,i)$：从$u$开始，在$u$的子树内不以$u$作为第一个点出发，将$u$的子树内的灯关完的最小时间。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有了上面的经验，这时的转移也就不难了：　　　
$$g(u,i)=\begin{cases}\min_{j\in leaf(2u+1)}\{\min\{f(2u+1,j),g(2u+1,j)\}+D_{j,u}A_u+c(u,0)A_{2u}+f(2u,i)\}&i\in leaf(2u)\\\min_{j\in leaf(2u)}\{\min\{f(2u,j),g(2u,j)\}+D_{j,u}A_u+c(u,1)A_{2u+1}+f(2u+1,i)\}&i\in leaf(2u+1)\end{cases}$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同样可以按照$f$的方法来优化转移。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样是......$O(n^2)$？！  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实并不是！我们可以发现，$f(u)$和$g(u)$里面的状态只会对应到自己的子树里面叶子上面去，所以从全局来看，每一层上面的节点总共都只会覆盖一次所有的叶子，而完全二叉树的高度为$\log_2n+1$，所以空间和时间的开销理论是$O(n\log_2n)$的。用$vector$来存$f$和$g$，遍历到叶子的时候就给它的父亲都插入一个新的节点，给自己占位子。转移的时候就可以对应起来了。这样空间就变成了$O(n\log_2n)$；时间的话，经过优化的转移是$O(1)$的，所以也是$O(n\log_2n)$。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要注意的是，当$n=4$的时候，会出现长度为$2$的链，需要特判！也就是多考虑一种情况——从链一端开始走，是否可以得到更优的解。  
# 代码
```cpp
#include <cstdio>
#include <vector>
using namespace std;

typedef long long LL;

const LL INF = 0x3f3f3f3f3f3f3f3f;
const int MAXN = 2e5 + 5, INf = 0x3f3f3f3f;

template<typename _T>
void read( _T &x )
{
    x = 0;char s = getchar();int f = 1;
    while( s < '0' || '9' < s ){ if( s == '-' ) f = -1; s = getchar(); }
    while( '0' <= s && s <= '9' ){ x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar(); }
    x *= f;
}

template<typename _T>
void write( _T x )
{
    if( x < 0 ){ x = -x, putchar( '-' ); }
    if( 9 < x ){ write( x / 10 ); }
    putchar( x % 10 + '0' );
}

template<typename _T>
_T MIN( const _T a, const _T b )
{
    return a < b ? a : b;
}

vector<LL> f[MAXN], g[MAXN], d[MAXN];

LL s[MAXN];
int w[MAXN][2];
int A[MAXN], siz[MAXN];
int lg2, N, cnt;

void DFS( const int u )
{
    if( u << 1 > N ) 
    {
        siz[u] = 1;
        f[u].push_back( 0 ), g[u].push_back( 0 );
        for( int i = u >> 1 ; i ; i >>= 1 ) f[i].push_back( INF ), g[i].push_back( INF ), d[i].push_back( s[u] ), siz[i] ++;
        return ; 
    }
    s[u << 1] = s[u] + w[u][0], DFS( u << 1 );
    int mid = siz[u << 1];
    if( ( u << 1 | 1 ) > N )
    {
        for( int i = 0 ; i < siz[u] ; i ++ ) 
            f[u][i] = f[u << 1][i] + 1ll * w[u][0] * A[u << 1],
            g[u][i] = MIN( g[u << 1][i], f[u << 1][i] ) + 1ll * ( d[u][i] - s[u] ) * A[u];
        return ;
    }
    s[u << 1 | 1] = s[u] + w[u][1], DFS( u << 1 | 1 );
    LL fs1 = INF, fs2 = INF, gs1 = INF, gs2 = INF;
    for( int i = 0 ; i < siz[u] ; i ++ )
    {
        if( i < mid )
            fs1 = MIN( fs1, f[u << 1][i] + 1ll * d[u][i] * A[u << 1 | 1] ),
            gs1 = MIN( gs1, MIN( g[u << 1][i], f[u << 1][i] ) + 1ll * ( d[u][i] - s[u] ) * A[u] );
        else
            fs2 = MIN( fs2, f[u << 1 | 1][i - mid] + 1ll * d[u][i] * A[u << 1] ),
            gs2 = MIN( gs2, MIN( g[u << 1 | 1][i - mid], f[u << 1 | 1][i - mid] ) + 1ll * ( d[u][i] - s[u] ) * A[u] );
    }
    for( int i = 0 ; i < siz[u] ; i ++ )
    {
        if( i < mid )
            f[u][i] = 1ll * w[u][1] * A[u << 1 | 1] + fs2 + 1ll * ( w[u][0] - s[u] ) * A[u << 1] + f[u << 1][i],
            g[u][i] = gs2 + 1ll * w[u][0] * A[u << 1] + f[u << 1][i];
        else
            f[u][i] = 1ll * w[u][0] * A[u << 1] + fs1 + 1ll * ( w[u][1] - s[u] ) * A[u << 1 | 1] + f[u << 1 | 1][i - mid],
            g[u][i] = gs1 + 1ll * w[u][1] * A[u << 1 | 1] + f[u << 1 | 1][i - mid];
    }
}

int main()
{
    read( N );
    for( int i = 1 ; i <= N ; i ++ ) read( A[i] );
    for( int i = 2 ; i <= N ; i ++ ) read( w[i >> 1][i & 1] );
    DFS( 1 );
    LL res = INF;
    for( int i = 0 ; i < siz[1] ; i ++ )
        res = MIN( res, MIN( f[1][i], g[1][i] ) );
    if( N == 4 ) 
		res = MIN( res, 1ll * w[2][0] * A[2] + 1ll * w[1][0] * A[1] + 1ll * w[1][1] * A[3] ),
		res = MIN( res, 1ll * w[2][0] * A[4] + 1ll * w[1][0] * A[2] + 1ll * w[1][1] * A[1] );
        //n=4的特判
    write( res ), putchar( '\n' );
    return 0;
}
```

---


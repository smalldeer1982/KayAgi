# [COCI 2014/2015 #1] Kamp

## 题目描述

一颗树 $n$ 个点，$n-1$ 条边，经过每条边都要花费一定的时间，任意两个点都是联通的。

有 $K$ 个人（分布在 $K$ 个不同的点）要集中到一个点举行聚会。

聚会结束后需要一辆车从举行聚会的这点出发，把这 $K$ 个人分别送回去。

请你回答，对于 $i=1 \sim n$ ，如果在第 $i$ 个点举行聚会，司机最少需要多少时间把 $K$ 个人都送回家。

## 说明/提示

#### 数据规模与约定

- 对于 $50\%$ 的数据，保证 $n\le 2\times 10^3$。
- 对于 $100\%$ 的数据， $1 \le k \le n \leq 5\times 10^5$，$1 \le x,y \le n$，$1 \le z \le 10^8$ 。

## 样例 #1

### 输入

```
7 2
1 2 4
1 3 1
2 5 1
2 4 2
4 7 3
4 6 2
3
7```

### 输出

```
11
15
10
13
16
15
10```

## 样例 #2

### 输入

```
5 2
2 5 1
2 4 1
1 2 2
1 3 2
4
5
```

### 输出

```
5
3
7
2
2
```

# 题解

## 作者：UltiMadow (赞：92)

感觉楼上两篇题解写的都不是很清楚，窝来详细地解释一下

首先，第一眼，这是一道换根dp

接下来我们就要看两次dfs要处理什么

#### The first dfs
~~按照换根dp的老套路~~，我们要处理子树里的信息

我们令 $g_u$ 为以 $u$ 为根的子树中从 $u$ 开始把所有家在这个子树内的人送回家**并回到 $u$ 节点**的最短路程

再令 $sz_u$ 为家在以 $u$ 为根的子树中的人数

显然，我们珂以得到 $g_u=\sum g_v+2\times w_{u\rightarrow v}$ 其中 $v$ 为 $u$ 的子节点，且 $sz_v\neq 0$

其中 $w$ 为边权

刚做这道题的我天真地以为这就是第一次 dfs 需要处理的东西，当我写完之后测样例时，发现挂掉了，所以，我们还需要处理一些东西

我们手算了一遍样例，发现我们的车可以送完人了之后不返回开始点；也就是说再我们这么算回到起始点的树值之后还要减去一个最长链的长度

这里的最长链就表示离一个点最远的人的家

那么我们令 $len_u$ 为从 $u$ 开始的最长链，$id_u$ 为从 $u$ 开始的最长链所经过的第一个节点（也就是 $u$ 的一个子节点或者 $u$ 的父亲节点），$slen_u$ 为从 $u$ 开始的次长链

次长链是干啥的待会再说

当然了，第一次dfs我们还是只处理子树内的最长链，次长链

先放第一次dfs的代码：
```cpp
void dfs(int u,int fa)
{
	if(pos[u])sz[u]=1;
	for(int i=Head[u];i;i=Edge[i].next)
	{
		int v=Edge[i].to,w=Edge[i].val;
		if(v==fa)continue;
		dfs(v,u);
		if(sz[v])//当v的子树中有人才更新
		{
			g[u]+=g[v]+2*w;
			int now=len[v]+w;
			if(now>=len[u])slen[u]=len[u],len[u]=now,id[u]=v;//最长链
			else if(now>slen[u])slen[u]=now;//次长链
		}
		sz[u]+=sz[v];
	}
}
```
#### the second dfs
第二次dfs我们就要处理全局的事情了qwq

令 $f_u$ 为对于整棵树从 $u$ 开始送人**最后回到 $u$ 的最短距离**

接下来我们就要开始分类了qwq

1、当以 $u$ 为根的子树中没有人的家，即 $sz_u=0$ 时，我们发现 $f_v=f_u+2\times w_{u\rightarrow v}$ ，很好理解，不多说了（画画图就好了  
2、当除了以 $u$ 为根的子树其他地方没有人的家，即 $K-sz_u=0$ 时（$K$ 即题面中的 $K$），可以发现 $f_v=g_v$  
3、其他情况，即 $sz_u\neq 0$ 且 $K-sz_u\neq 0$ 时，发现 $f_v=f_u$

那么，更新完 $f$ 之后，我们就要考虑如何更新最长链和次长链了

这也是本题最烦的地方了

依旧分类讨论，依旧是上面三类（这里编号就代表上面的情况）

1、这种情况可以发现 $len_v=len_u+w_{u\rightarrow v}$，很简单  
2、这种情况很容易发现完全没有必要更新  
3、最烦的情况来了，这种情况下我们还要分类讨论  
1）当 $len_u+w\ge len_v$ 且 $id_u\neq v$ 时，说明 $u$ 的最长链可以更新 $v$ 的最长链，那么直接更新即可  
2）当 $len_u+w\ge len_v$ 且 $id_u= v$ 时，说明虽然 $u$ 的最长链的长度可以更新 $v$，但是若更新了这就不是一条链了，所以也不可以来更新  
3）当 $slen_u+w\ge len_v$ 时，说明 $u$ 的次长链可以用来更新 $v$ 的最长链，直接更新即可  
4）当 $len_u+w\ge slen_v$ 且 $id_u\neq v$ 时，说明 $u$ 的最长链可以更新 $v$ 的次长链，直接更新即可  
5）当 $len_u+w\ge slen_v$ 且 $id_u= v$ 时，这时与2）同理，不可以更新  
6）当 $slen_u+w\ge slen_v$ 时，说明 $u$ 的次长链可以更新 $v$ 的次长链，直接更新即可

到这里，第二次dfs就做完了

贴个代码：
```cpp
void dp(int u,int fa)
{
	for(int i=Head[u];i;i=Edge[i].next)
	{
		int v=Edge[i].to,w=Edge[i].val;
		if(v==fa)continue;
		if(!sz[v])f[v]=f[u]+2*w,len[v]=len[u]+w;//对应1
		else if(K-sz[v])//对应3
		{
			f[v]=f[u];
			if(id[u]!=v&&len[v]<len[u]+w)//对应1）
				slen[v]=len[v],len[v]=len[u]+w,id[v]=u;
			else if(len[v]<slen[u]+w)//对应3）
				slen[v]=len[v],len[v]=slen[u]+w,id[v]=1;
			else if(slen[v]<len[u]+w&&id[u]!=v)//对应4）
				slen[v]=len[u]+w;
			else if(slen[v]<slen[u]+w)//对应6）
				slen[v]=slen[u]+w;
		}
		else f[v]=g[v];//对应2
		dp(v,u);
	}
}
```
接下来，这题就可以愉快的AC啦，记得开long long就行啦

完整的无注释代码：
```cpp
#include<bits/stdc++.h>
#define MAXN 500010
#define int long long
using namespace std;
int n,K;
struct Node{int to,next,val;}Edge[MAXN<<1];
int Head[MAXN],cnt_Edge;
void Add_Edge(int u,int v,int w){Edge[++cnt_Edge]={v,Head[u],w};Head[u]=cnt_Edge;}
int pos[MAXN];
int sz[MAXN],g[MAXN],f[MAXN];
int len[MAXN],id[MAXN],slen[MAXN];
void dfs(int u,int fa)
{
	if(pos[u])sz[u]=1;
	for(int i=Head[u];i;i=Edge[i].next)
	{
		int v=Edge[i].to,w=Edge[i].val;
		if(v==fa)continue;
		dfs(v,u);
		if(sz[v])
		{
			g[u]+=g[v]+2*w;
			int now=len[v]+w;
			if(now>=len[u])slen[u]=len[u],len[u]=now,id[u]=v;
			else if(now>slen[u])slen[u]=now;
		}
		sz[u]+=sz[v];
	}
}
void dp(int u,int fa)
{
	for(int i=Head[u];i;i=Edge[i].next)
	{
		int v=Edge[i].to,w=Edge[i].val;
		if(v==fa)continue;
		if(!sz[v])f[v]=f[u]+2*w,len[v]=len[u]+w;
		else if(K-sz[v])
		{
			f[v]=f[u];
			if(id[u]!=v&&len[v]<len[u]+w)
				slen[v]=len[v],len[v]=len[u]+w,id[v]=u;
			else if(len[v]<slen[u]+w)
				slen[v]=len[v],len[v]=slen[u]+w,id[v]=1;
			else if(slen[v]<len[u]+w&&id[u]!=v)
				slen[v]=len[u]+w;
			else if(slen[v]<slen[u]+w)
				slen[v]=slen[u]+w;
		}
		else f[v]=g[v];
		dp(v,u);
	}
}
signed main()
{
	scanf("%lld%lld",&n,&K);
	for(int i=1;i<n;i++)
	{
		int u,v,w;scanf("%lld%lld%lld",&u,&v,&w);
		Add_Edge(u,v,w);Add_Edge(v,u,w);
	}
	for(int i=1;i<=K;i++){int x;scanf("%lld",&x);pos[x]=1;}
	dfs(1,0);f[1]=g[1];dp(1,0);
	for(int i=1;i<=n;i++)printf("%lld\n",f[i]-len[i]);
	return 0;
}
```

---

## 作者：奇米 (赞：34)

# 题解 - $\mathrm{P6419}$

## 题目意思

* [题目传送门](https://www.luogu.com.cn/problem/P6419)

## $\mathrm{Sol}$

* 因为要求每个点为根的答案，显然会想到**换根$DP$**（虽然不一定

* 我们首先先申明几个变量：

	* $f_u$表示把$u$子树内的任务做完并且回到$u$点的花费
    
    * $g_u$表示$u$子树外的花费
    
    * $dis_{u,0/1}$表示$u$子树内的最长链/次长链
    
    * $up_u$表示$u$子树外的最长链
    

* 那么对于每个点的贡献$ans_i=f_i+g_i-\max(up_i,dis_{i,0})$。这个如何理解：就是子树内的要加子树外的也要加，我们可以选择一个位置$v$为结束点，此刻我们就不用回溯至子树根节点了。按照贪心我们选择对答案贡献最大的点。

* $f_u$很好求，即$f_u=\sum_{v∈u}f_v+(2\times w_{u,v})$。这个就不多讲了。

* $g_v$稍微想想可以理解即$g_v=g_u+(f_u-f_v)$ 这个如何理解：就是这个$g_v$包含了$u$外的子树（这个贡献即为$g_u$）以及同属于$u$子树但不为$v$的另外子树（这个贡献即为$f_u-f_v$）

* $up_v$分两种情况：一种为其父节点$u$的最长链上的点，以及不为最长链上的点。这个也很好转移

* $dis_{u,0/1}$在预处理中就可以处理好。

* 以及要考虑一种情况即$v∈u$没有关键点，那么$g_v$要加上$2\times w_{u,v}$

* 时间复杂度$O(n)$

## $\mathrm{Code}$

```cpp
#include <bits/stdc++.h>
#define For(i,a,b) for ( int i=(a);i<=(b);i++ )
#define Dow(i,b,a) for ( int i=(b);i>=(a);i-- )
#define GO(i,x) for ( int i=head[x];i;i=e[i].nex )
#define mem(x,s) memset(x,s,sizeof(x))
#define cpy(x,s) memcpy(x,s,sizeof(x))
#define YES return puts("YES"),0
#define NO return puts("NO"),0
#define GG return puts("-1"),0
#define pb push_back
#define int long long
using namespace std;

inline int read()
{
	int sum=0,ff=1; char ch=getchar();
	while(!isdigit(ch))
	{
		if(ch=='-') ff=-1;
		ch=getchar();
	}
	while(isdigit(ch))
		sum=sum*10+(ch^48),ch=getchar();
	return sum*ff;
}

const int mod=1e9+7;
const int mo=998244353;
const int N=5e5+5;

int n,m,cnt,head[N],f[N],g[N];
int dis[N][2],a[N],up[N],siz[N],ans;

struct Node
{
	int nex,to,w;
};
Node e[N<<1];

inline void jia(int u,int v,int w)
{
	e[++cnt].nex=head[u];
	head[u]=cnt;
	e[cnt].to=v;
	e[cnt].w=w;
}

inline void dfs(int u,int fa)
{
	siz[u]=a[u];
	GO(i,u)
	{
		int v=e[i].to;
		if(v==fa) continue;
		dfs(v,u);
		siz[u]+=siz[v];
		if(siz[v])
		{
			f[u]+=(f[v]+2*e[i].w);
			if(dis[u][0]<dis[v][0]+e[i].w) 
				dis[u][1]=dis[u][0],dis[u][0]=dis[v][0]+e[i].w;
			else if(dis[u][1]<dis[v][0]+e[i].w) dis[u][1]=dis[v][0]+e[i].w;
		}
	}
}

inline void dp(int u,int fa)
{
	GO(i,u)
	{
		int v=e[i].to;
		if(v==fa) continue;
		if(m-siz[v])
		{
			g[v]=g[u]+(f[u]-f[v]);
			if(!siz[v]) g[v]+=2*e[i].w; 
			if(dis[v][0]+e[i].w==dis[u][0]) 
				up[v]=max(up[u],dis[u][1])+e[i].w;
			else up[v]=max(up[u],dis[u][0])+e[i].w;
		}
		dp(v,u);
	}
}

signed main()
{
	n=read();m=read();
	For(i,1,n-1)
	{
		int x,y,w;
		x=read(),y=read(),w=read();
		jia(x,y,w);
		jia(y,x,w);
	}
	For(i,1,m) a[read()]++;
	dfs(1,0);
	dp(1,0);
	For(i,1,n) printf("%lld\n",f[i]+g[i]-max(up[i],dis[i][0]));
	return 0;
}
```


---

## 作者：_CHO (赞：23)

第二次提交了，认真进行了排版，求管理大大给过/kk

第一次交的时候时间比较紧，于是就没怎么对变量使用Latex，然后就被认真负（du)责(liu)的管理员给乱棍打回来了/kk

以下是原题解

------------
明天就~~SX~~ AFO了交篇题解%一下

这题大概是我第一道有独立思考切掉的紫题

之前的都是~~各种抄~~借鉴题解

为什么写这题的题解呢?另一个重要的原因是这样的↓

翻了翻已有题解中的几篇，下面几种情况屡见不鲜

1. 样例2都过不去~~论题解是如何过审的~~

2. 变量名不统一，有一些小的笔误

3. 疯狂的防作弊系统，复制编译试图对拍然鹅数十行报错

正因如此，本蒟蒻想道自己写一篇题解，**尽量保证**不出现上面的错误，如果依然有笔误请轻喷

因为作者忙着~~复习~~颓废，$Markdown$及$Latex$会有一点偷懒，敬请谅解


------------
说了一堆废话，下面进入正题


## 树形dp+换根
## 两遍dfs

这俩思想应该还是比较容易想到，像~~这种暴力搞不了的树上问题一看就是dp~~，再一个题目要求每一个点的情况，暴力跑一定会爆炸，所以需要用到换根

### 观察题目性质

- 问题可以简化成，在某一节点$i$聚会时，此时的答案即为司机把所有人送回家再返回该点的距离减掉从点$i$到最远的人的家的距离。

- 如果我们走的是简单路径（不知道简单路径是什么的可以当场AFO了），那么是不存在所谓的最短路的，因为这是一棵树，先送道远的和先送道近的没有本质区别

下面我们来设计状态

首先我们以$1$号节点为根

$g[u]$ 从点u出发把所有在u的子树里的人送回家并返回u的距离

$f[u]$ 从点$u$出发把所有人出发并返回$u$的距离

$len[u]$ 从$u$出发，在$u$的子树内，距离$u$最远的那个人的家到$u$的距离

$dlen[u]$ 从$u$出发，在$u$的子树内，距离$u$次远第~~二远~~的那个人的家到$u$的距离

$up[u]$ 不在u的子树内，距离$u$最远的那个人的家到$u$的距离

$siz[u]$ $u$及$u$的子树内有多少个人的家

则最终的答案应为

$ans[i] = f[i] - max(up[i],len[i] ) $


那么我们考虑代码

第一次$dfs$我们主要是处理子树内的问题

我们需要处理出$ g[]$,$len[]$,$dlen[]$，$siz[] $

这应该很简单

第二次就是换根操作了

我们需要处理出$up[],f[]$

我们需要分类讨论，设当前的点为$u$，父亲节点为$fa$，这条边的边权为 _$w$

1. 当所有人的家都在$u$的子树内即$siz[u]=k$时，这时候$f[u]$即是$g[u]$，而$up[u]$应当是$0$，这很显然，因为$u$的子树外没有家
2. 当所有人的家都不在u的子树内即$siz[u]=0$时，这是$f[u]=f[fa]+2$_$w$,因为你首先要走到父亲节点这样才能送人回家，$up[u]$则完全由父亲节点更新（详见代码）

3. $u$的子树内有家，$u$的子树外也有家时，这种情况可以手玩一下，$f[u]$就等于$f[fa]$ ，那么$ up[u]$呢？我们感性理解一下，$up[u]$时$u$从他的父亲那里继承而来的最长链，而$len[u]$,$dlen[u]$则是从儿子那里继承过来的最长次长链那么我们显然要分两种情况
- 当$u$在他父亲的$len[fa]$上时，$up[u]$就需要从$dlen[fa]$更新过来~~因为$len[fa]$要经过$u$~~

- 当$u$不在父亲的$len[fa]$上时，同理由$len[fa]$转移过来

讲的比较抽象，建议画图+阅读代码理解

~~十年OI一场空，不开long long见祖宗~~

Code:
```
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn = 5e+5+100;
struct Edge{
	int v;
	ll w;
};
int n,k;
int he[maxn],ne[maxn<<1],cnt=1;
Edge G[maxn<<1];
bool p[maxn];
int siz[maxn];
ll f[maxn],g[maxn],up[maxn],len[maxn],dlen[maxn];

void add_Edge(int u,int v,ll w){
	G[cnt].v = v;
	G[cnt].w = w;
	ne[cnt] = he[u];
	he[u] = cnt++;
}
void dfs(int u,int fa){
	siz[u] = p[u];
	for(int i=he[u];i;i=ne[i]){
		int v=G[i].v;
		int w=G[i].w;
		if(v==fa) continue;
		dfs(v,u);
		siz[u]+=siz[v];
		if(siz[v]){
			g[u] += g[v] + 2*w;
			if(len[v]+w>len[u]){
				dlen[u] = len[u];
				len[u] = len[v] + w;
			}
			else if(len[v]+w>dlen[u]){
				dlen[u] = len[v] + w;
			}
		}
	}
}
void dfs(int u,int fa,ll _w){
	if(siz[u]==k){
		f[u] = g[u];
		up[u] = 0;
	}
	else if(siz[u]==0){
		f[u] = f[fa] + 2*_w;
		up[u] = max(up[fa],len[fa]) + _w;
	}
	else{
		f[u] = f[fa];
		if(len[fa]-len[u]==_w) up[u] = max(up[fa],dlen[fa]) + _w;
		else up[u] = max(up[fa],len[fa]) + _w;
	}
	for(register int i=he[u];i;i=ne[i]){
		int v=G[i].v;
		int w=G[i].w;
		if(v==fa) continue;
		dfs(v,u,w);
	}
}
int main(){
	cin>>n>>k;
	for(register int i=1;i<n;++i){
		int u,v;
		ll w;
		scanf("%d%d%lld",&u,&v,&w);
		add_Edge(u,v,w);
		add_Edge(v,u,w);
	}
	for(register int i=1;i<=k;++i){
		int x;
		scanf("%d",&x);
		p[x] = true;
	}
	dfs(1,0);
	dfs(1,0,0);
	for(register int i=1;i<=n;++i) printf("%lld\n",f[i]-max(up[i],len[i]));
	return 0;
}
```

---

## 作者：Imakf (赞：12)

如果该题只询问一个节点 $u$，则是愚蠢的一次树型 dp 就能搞定。

计算所有标记点到 $u$ 的距离和，乘 2，减去标记点到当前点的最长路径？

**其实是错的**。

我们只要找到一个**最小联通块**，使其包含所有标记点**以及当前点**。

则答案是**最小联通块**内的边权和乘二，减去标记点到当前点的最长路径。

于是问题被拆成两部分：

## 1.计算包含所有标记点与当前点的最小联通块的权值

记要求的联通块是 $S$，不包含当前节点 $u$ 的**最小联通块**是 $S'$。

因为数据范围很大，考虑 $O(n)$ 的做法。

**先以 $1$ 为根**，做一遍 dp 得到 $u=1$ 时的答案 $ans$。

我们已经知道在 $1$ 点的答案，考虑计算在树上向下移动一步到 $v$ 造成的答案差是多少。

在 dfs 时记录当前 $ans$，记当前移动的边的权值是 $w$。

若 $u\in S$，则答案不变。

若 $u \not\in S$，则如果以 $u$ 为根的子树内有标记点，则 $ans=ans-w$

否则 $ans=ans+w$

## 2.计算到达每一个点最远的标记点的距离

依然是典型的树型 dp 题。

**先以 $1$ 为根**，做一遍 dp 得到以每个点为根的子树内的最远点距离。

依然考虑在树上移动根时，如何更改答案。

在 dfs 时依然记录 $ans$。

设最远点所在子树的根是 $s$，且 $s$ 是当前点 $u$ 的儿子。

当向非最远点所在子树移动时，$ans=\max\limits\{ans,dp[s]\}+w$

当向最远点所在子树移动时，$ans=\max\limits_{\text{v 是除了 s 以外的儿子}}\{ans,dp[v]\}+w$

## 代码如下，冗余轻喷

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;

#define MX (500000 + 5)
#define LL long long

int head[MX] ,tot ,n ,K ,A[MX];
struct edge{
	int node ,next ,w;
}h[MX << 1];
void addedge(int u ,int v ,int w){
	h[++tot].next = head[u];
	head[u] = tot;
	h[tot].node = v ,h[tot].w = w;
}

namespace solve1{
	LL S[MX] ,size[MX] ,Ans[MX];
	void dfs1(int x ,int f){
		size[x] = A[x];
		for(int i = head[x] ,d ; i ; i = h[i].next){
			if((d = h[i].node) == f)	continue;
			dfs1(d ,x);
			size[x] += size[d];
			S[x] += S[d] + (size[d] ? 1 : 0) * h[i].w;
		}
	}
	void dfs2(int x ,int f ,LL w = S[1]){
		Ans[x] = w;
		for(int i = head[x] ,d ,coef ; i ; i = h[i].next){
			if((d = h[i].node) == f)	continue;
			if(size[d] == size[1])	coef = -1;
			else if(size[d] == 0)	coef = 1;
			else coef = 0;
			dfs2(d ,x ,w + coef * h[i].w);
		}
	}
	int main(){
		dfs1(1 ,0);
		dfs2(1 ,0);
		return 0;
	}
}

namespace solve2{
	LL Ans[MX] ,dp[MX];
	void dfs1(int x ,int f){
		dp[x] = A[x] ? 0 : -214748364;
		for(int i = head[x] ,d ; i ; i = h[i].next){
			if((d = h[i].node) == f)	continue;
			dfs1(d ,x);
			if(dp[d] + h[i].w >= dp[x])	dp[x] = dp[d] + h[i].w;
		}
	}
	void dfs2(int x ,int f ,int addition){
		int mx = 0 ,cmx = 0 ,mxfr = x ,cmxfr = x;
		for(int i = head[x] ,d ; i ; i = h[i].next){
			if((d = h[i].node) == f)	continue;
			if(dp[d] + h[i].w >= cmx){
				cmx = dp[d] + h[i].w ,cmxfr = d;
				if(cmx > mx)	swap(cmx ,mx) ,swap(cmxfr ,mxfr);
			}
		}
		Ans[x] = max(addition ,mx);
		for(int i = head[x] ,d ; i ; i = h[i].next){
			if((d = h[i].node) == f)	continue;
			if(d == mxfr)	dfs2(d ,x ,max(addition ,cmx) + h[i].w);
			else dfs2(d ,x ,max(addition ,mx) + h[i].w);
		}
	}
	int main(){
		dfs1(1 ,0);
		dfs2(1 ,0 ,0);
		return 0;
	}
}

int main(){
	cin >> n >> K;
	for(int i = 1 ,u ,v ,w ; i < n ; ++i){
		scanf("%d%d%d" ,&u ,&v ,&w);
		addedge(u ,v ,w) ,addedge(v ,u ,w);
	}
	for(int i = 1 ,u ; i <= K ; ++i){
		cin >> u;
		A[u] = 1;
	}
	solve1::main();
	solve2::main();
	for(int i = 1 ; i <= n ; ++i)
		cout << solve1::Ans[i] * 2 - solve2::Ans[i] << endl;
	return 0;
}
```

---

## 作者：konjacq (赞：7)

给出一种不需要换根DP的解法.

不妨称$k$个人所在的点为关键点,考虑将任意一个关键点设为根,进行一遍DFS求出每个点的父亲.然后从每个关键点往父亲跳并标记路过的节点,碰到已标记的节点则退出.这样可以$\mathrm O(n)$求出包含所有关键点及其间路径的最小连通块,且显然包括根.过程中记录连通块内路径总长度$x$.

```cpp
void sdfa(int u) {
	for (auto i:e[u]) if (i.first!=a[u]) {
		d[i.first]=d[a[i.first]=u]+1;
		b[i.first]=b[u]+(q[i.first]=i.second); sdfa(i.first);
		/*d[]表示深度,b[]表示到根的距离,q[]暂存到父亲的距离方便求x*/
	}
}

void sbfa(int u) {
	x+=q[u]; if (!f[a[u]]) {f[a[u]]=true; sbfa(a[u]);}
}
```

然后求这个连通块的直径,显然两端都会是关键点(确切地说,这个连通块是一棵树,且叶子节点都是关键点),不妨设为$s$和$t$.记$u$和$v$两点间距离为$d[u,v]$,发现连通块内的点$u$答案就是$q[u]=2x-\max\{d[u,s],d[u,t]\}$.理解这个柿子:如果将整个连通块完整地走一遍并返回,答案就是$2x$,不过走到最后一个关键点后就不需要再返回了,而这个点一定是离$u$最远的点才能使答案最优,所以是直径端点之一.

接下来处理不属于上述连通块的部分.容易发现其余部分一定是某个连通块内节点的子树,所以必须先走到连通块.此时的答案是$q[u]=q[v]+d[u,v]$,其中$v$是$u$的祖先中最深的连通块内的点.因为如果存在更浅的点$v'$,则$v\to v'$这条路径在进入连通块后马上会走一次,之后在连通块内计算答案时还要走,一定不会更优.

接下来考虑如何计算$d[u,v]$.显然是可以直接LCA暴力算的,不过这样会让你凭空多一个$\log$(也就是窝最初的写法),当然也可以用$\pm1$rmq去掉.不过还有别的写法.

容易发现实际上要求的有两类.第一类是$d[u,v\in\{s,t\}]$,这一部分可以直接从$s$和$t$分别DFS记下来而不影响复杂度.第二类是从连通块外的点到它最深的在连通块内的祖先,这一部分在统计答案的DFS时就能顺便记录.

```cpp
void sqfa(int u,int v,ll w) {
	q[u]=f[u]?x-max(p[0][u],p[1][u]):w;
	/*此处q[]保存答案,p[0/1][]表示到s/t的距离,w表示从连通块外的点到它最深的在连通块内的祖先的距离+祖先的答案*/
	for (auto i:e[u]) if (i.first!=v) sqfa(i.first,u,(f[u]?q[u]:w)+i.second);
	/*如果这个节点在连通块内,那w就是当前点答案+到孩子的距离,否则是自己的w+到孩子的距离*/
}
```

## Code

挺难看的,所以只能方便大家对拍了(悲

```cpp
#include <cstdio>
#include <cstring>
#include <vector>
using namespace std;

typedef long long ll;
typedef pair<int,int> pii;

/* ---- read() & rlong() - begin ---- */
#define gc() (p0==p1&&(p1=(p0=buf)+fread(buf,1,1048576,stdin),p0==p1)?EOF:*p0++)
char buf[1048576],*p0,*p1;
inline int read() {
	int r=0; char c=gc(); while (c<48||c>57) c=gc();
	while (c>47&&c<58) {r=(r<<3)+(r<<1)+(c^48); c=gc();} return r;
}
#undef gc
/* ---- read() & rlong() -- end ----- */

int s,t,r[500005],d[500005],a[500005];
ll x,b[500005],q[500005],p[2][500005]; bool f[500005]; vector<pii> e[500005];

void sdfa(int u) {
	for (auto i:e[u]) if (i.first!=a[u]) {
		d[i.first]=d[a[i.first]=u]+1;
		b[i.first]=b[u]+(q[i.first]=i.second); sdfa(i.first);
	}
}

void sbfa(int u) {
	x+=q[u]; if (!f[a[u]]) {f[a[u]]=true; sbfa(a[u]);}
}

void spfa(int u,int v,int &w,ll *p) {
	if (p[u]>p[w]) w=u; for (auto i:e[u]) if (f[i.first]&&i.first!=v) {
		p[i.first]=p[u]+i.second; spfa(i.first,u,w,p);
	}
}

void sqfa(int u,int v,ll w) {
	q[u]=f[u]?x-max(p[0][u],p[1][u]):w;
	for (auto i:e[u]) if (i.first!=v) sqfa(i.first,u,(f[u]?q[u]:w)+i.second);
}

int main() {
	int n=read(),m,u,v,w; m=read(); for (int i=1;i<n;++i) {
		u=read(); v=read(); w=read();
		e[u].emplace_back(make_pair(v,w)); e[v].emplace_back(make_pair(u,w));
	}
	for (int i=0;i<m;++i) f[r[i]=read()]=true;
	sdfa(r[0]); for (int i=1;i<m;++i) sbfa(r[i]);
	spfa(r[0],0,s,p[1]); spfa(s,0,t,p[0]); p[1][t]=0; spfa(t,0,u,p[1]);
	x<<=1; sqfa(r[0],0,0); for (int i=1;i<=n;++i) printf("%lld\n",q[i]);
	return 0;
}
```

---

## 作者：lgswdn_SA (赞：7)

由于我们一旦进入一个子树，肯定先把子树内处理好再出来（否则再次进入子树的时候多走一段路），所以可以 dp，由于是全局统计，我们用换根 dp。先考虑以 $1$ 为根的子树内部。

由于送到最后一个家后就不用回来的奇怪题目设置，我们总归希望我们最后一个到达的是距离出发点最远的人，所以我们实际上要统计的是：

- 处理完 $u$ 子树并回到 $u$ 的最短路径
- 子树内距离 $u$ 最远的节点

以换根 $dp$ 的套路，我们还要存一下次远节点和最远节点在哪个儿子的子树中。

我们设 $f_u$ 为 $u$ 子树内的总答案，$g_{u,0/1}$ 表示最/次长距离，$mx_u$ 代表经过哪个子节点，$cnt_u$ 表示子树内有多少人。

```cpp
int f[N],g[N][2];
void dfs1(int u,int fa){
	for(int i=hd[u],v;i;i=e[i].nxt){
		if((v=e[i].to)==fa) continue;
		dfs1(v,u);
		cnt[u]+=cnt[v];
		if(cnt[v]){
			f[u]+=(f[v]+2*e[i].w); //进入v子树(w)+送完人(f[v])+回到u(w) 
			if(g[v][0]+e[i].w>g[u][1]) g[u][1]=g[v][0]+e[i].w;
			if(g[u][1]>g[u][0]) swap(g[u][1],g[u][0]);
		}
	}
	cout<<u<<" "<<f[u]<<" "<<g[u][0]<<endl;
}
```

现在看子树外部的情况。

我们记 $p_u$ 为 $u$ 到整棵树的所有，$v$ 是 $u$ 的儿子，$q_u$ 为**子树外**到 $u$ 最远的人的家（至于为什么我这样子设……我就比较喜欢这样设，没有为什么，而且这样更加方便？）。


如果 $v$ 子树内部没有人/子树外部没有人，那么就可以直接求得。

如果子树内部和外部都有人，我们可以发现：$p_v$=$f_v+(p_u-f_v)=p_u$

然后考虑最长距离。其实最长距离也很简单，而且很套路。子树外最长路径就来自两种——父亲子树外和自己的兄弟节点。

如果 $mx_u=v$，那么来自兄弟节点的最长距离是 $g_{u,1}$。那么就只能用 $q_u$ 和 $g_{u,1}$ 更新 $q_v$（$q_v=\max{(q_u,g_{u,1})+w}$）。 

否则就可以用 $q_u$ 和 $g_{u,0}$ 更新 $q_v$。（$g_v=\max(q_u,g_{u,0})+w$）

~~所以我还是没想明白为什么UM的计算这个的分类讨论会这么的繁。对UM说这题需要很多分类讨论表示不满。~~


答案即总的路程减去最长距离。

```cpp
int p[N],q[N],ans[N];
void dfs2(int u,int fa){
	if(u==1) p[u]=f[u];
	for(int i=hd[u],v;i;i=e[i].nxt){
		if((v=e[i].to)==fa) continue;
		if(k-cnt[v]==0) p[v]=f[v],q[v]=g[v][0]; //子树外边没有要更新的 
		else if(cnt[v]==0) p[v]=p[u]+2*e[i].w,q[v]=max(q[u],g[u][0])+e[i].w; //只依赖于子树外部 
		else{
			p[v]=p[u];
			if(mx[u]==v) q[v]=max(q[u],g[u][1])+e[i].w; //max(qu,gu1)为整个树内的最长距离 
			else q[v]=max(q[u],g[u][0])+e[i].w;
		} 
		dfs2(v,u);
	}
	ans[u]=p[u]-max(q[u],g[u][0]);
}
```

完整代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=5e5+9;
struct edge{int to,nxt,w;}e[N*2]; int hd[N],tot;
void add(int u,int v,int w){e[++tot]=(edge){v,hd[u],w},hd[u]=tot;}
int n,k,cnt[N];

int f[N],g[N][2],mx[N];
void dfs1(int u,int fa){
	for(int i=hd[u],v;i;i=e[i].nxt){
		if((v=e[i].to)==fa) continue;
		dfs1(v,u);
		cnt[u]+=cnt[v];
		if(cnt[v]){
			f[u]+=(f[v]+2*e[i].w); //进入v子树(w)+送完人(f[v])+回到u(w) 
			if(g[v][0]+e[i].w>g[u][1]) g[u][1]=g[v][0]+e[i].w;
			if(g[u][1]>g[u][0]) swap(g[u][1],g[u][0]),mx[u]=v;
		}
	}
}

int p[N],q[N],ans[N];
void dfs2(int u,int fa){
	if(u==1) p[u]=f[u];
	for(int i=hd[u],v;i;i=e[i].nxt){
		if((v=e[i].to)==fa) continue;
		if(k-cnt[v]==0) p[v]=f[v],q[v]=g[v][0]; //子树外边没有要更新的 
		else if(cnt[v]==0) p[v]=p[u]+2*e[i].w,q[v]=max(q[u],g[u][0])+e[i].w; //只依赖于子树外部 
		else{
			p[v]=p[u];
			if(mx[u]==v) q[v]=max(q[u],g[u][1])+e[i].w; //max(qu,gu1)为整个树内的最长距离 
			else q[v]=max(q[u],g[u][0])+e[i].w;
		} 
		dfs2(v,u);
	}
	ans[u]=p[u]-max(q[u],g[u][0]);
}

signed main(){
	scanf("%lld%lld",&n,&k);
	for(int i=1,u,v,w;i<n;i++)
		scanf("%lld%lld%lld",&u,&v,&w),add(u,v,w),add(v,u,w);
	for(int i=1,u;i<=k;i++)
		scanf("%lld",&u),cnt[u]=1;
	dfs1(1,0), dfs2(1,0);
	for(int i=1;i<=n;i++)
		printf("%lld\n",ans[i]);
	return 0;
}
```

---

## 作者：DengDuck (赞：5)

被 89L 老师的神秘做法深深地震撼了，用这篇文章来表达我的膜拜之意。

首先要知道本质上是在维护俩东西：

- 一个最小的包含所有关键点和根的联通块的边权之和。
- 离根最远的点到根的距离。

后者换根，线段树都很好做，不多赘述。

维护联通块边权之和，传统的做法是换根、分讨，不过 89L 老师提出可以考虑每条边的贡献。

我们发现，对于一条边 $u\to v$：

- 如果 $u$ 这边存在关键点，那么 $v$ 这边的点担任根的时候，就要经过 $u\to v$。
- 同理，如果 $v$ 这边存在关键点，那么 $u$ 这边的点担任根的时候，就要经过 $u\to v$。

考虑维护这个操作，显然利用 DFN 序可以快速的找到区间解决问题，差分就行，这一档就做完了。

```cpp
#include<bits/stdc++.h>
#define LL long long
#define pb push_back
#define Ls(x) (x<<1)
#define Rs(x) (x<<1|1)
using namespace std;
const LL N=1e6+5;
const LL Inf=1e15;
struct Edge{LL To,W;};
LL n,K,Sz[N],S[N],F[N],g[N],D[N],Dfn[N],TOT,Lz[N<<2],Mx[N<<2];
vector<Edge>G[N];
inline void Add(LL l,LL r,LL x){F[l]+=x,F[r+1]-=x;}
inline void Down(LL Rt)
{
	LL k=Lz[Rt];
	Lz[Rt]=0;
	Mx[Ls(Rt)]+=k,Mx[Rs(Rt)]+=k;
	Lz[Ls(Rt)]+=k,Lz[Rs(Rt)]+=k;
}
inline void Up(LL Rt){Mx[Rt]=max(Mx[Ls(Rt)],Mx[Rs(Rt)]);};
void Upd(LL Rt,LL L,LL R,LL x,LL y)
{
	if(L==R)
	{
		Mx[Rt]=y;
		return;
	}
	Down(Rt);
	LL Mid=L+R>>1;
	if(x<=Mid)Upd(Ls(Rt),L,Mid,x,y);
	else Upd(Rs(Rt),Mid+1,R,x,y);
	Up(Rt);
}
void Upd(LL Rt,LL L,LL R,LL l,LL r,LL x)
{
	if(R<l||r<L)return;
	if(l<=L&&R<=r)
	{
		Lz[Rt]+=x,Mx[Rt]+=x;
		return;
	}
	Down(Rt);
	LL Mid=L+R>>1;
	Upd(Ls(Rt),L,Mid,l,r,x);
	Upd(Rs(Rt),Mid+1,R,l,r,x);
	Up(Rt);
}
void Dfs(LL x,LL f)
{
	//cout<<x<<endl;
	Sz[x]=1,Dfn[x]=++TOT;
	if(S[x]==1)Upd(1,1,n,Dfn[x],D[x]);
	else Upd(1,1,n,Dfn[x],-Inf);
	for(Edge i:G[x])
	{
		if(i.To==f)continue;
		D[i.To]=D[x]+i.W;
		Dfs(i.To,x);
		S[x]+=S[i.To],Sz[x]+=Sz[i.To];
	}
	for(Edge i:G[x])
	{
		if(i.To==f)continue;
	//	cout<<x<<"->"<<i.To<<endl;
		if(S[i.To])Add(1,n,i.W),Add(Dfn[i.To],Dfn[i.To]+Sz[i.To]-1,-i.W);
		if(S[i.To]!=K)Add(Dfn[i.To],Dfn[i.To]+Sz[i.To]-1,i.W);
	}
}
void Work(LL x,LL f)
{
	g[x]=Mx[1];
	for(Edge i:G[x])
	{
		if(i.To==f)continue;
		Upd(1,1,n,1,n,i.W);
		Upd(1,1,n,Dfn[i.To],Dfn[i.To]+Sz[i.To]-1,-2*i.W);
		Work(i.To,x);
		Upd(1,1,n,1,n,-i.W);
		Upd(1,1,n,Dfn[i.To],Dfn[i.To]+Sz[i.To]-1,2*i.W);
	}
}
int main()
{
	scanf("%lld%lld",&n,&K);
	for(LL i=1,x,y,z;i<n;i++)
	{
		scanf("%lld%lld%lld",&x,&y,&z);
		G[x].pb({y,z}),G[y].pb({x,z});
	}
	for(LL i=1,x;i<=K;i++)
	{
		scanf("%lld",&x);
		S[x]++;
	}
	Dfs(1,0);
	for(int i=1;i<=n;i++)F[i]+=F[i-1];
	Work(1,0);
	for(int i=1;i<=n;i++)printf("%lld\n",2*F[Dfn[i]]-g[i]);
}
```

---

## 作者：辗转不纪年 (赞：5)

来一个不一样的。

对每个点$x$，我们需要找到一个最小的连通块，它包含$x$和所有的关键点，那么这个连通块的边权和的两倍就是**从**$x$**出发经过所有关键点后回到**$x$所需的时间。又因为我们可以在任意一个地方结束，所以我们当然选择停止在离$x$最远的关键点。

于是分为两步走，第一步求出从$x$出发经过所有关键点后回到$x$所需的最短时间，即连通块边权和的两倍；第二步求出距离$x$最远的关键点与$x$的距离。

第一步是一个简单的换根dp：

先设$f(x)$表示从$x$出发，经过以$x$为根的子树中的所有关键点后回到$x$的最短时间。这个容易转移，我们在dfs的过程中求出$s(x)$表示以$x$为根的子树中有多少个关键点，那么

$$f(x)=\sum\limits_{v\in\mathrm{son}(x),s(v)\neq 0}f(v)+2w(x,v)$$

再设$g(x)$表示从$x$出发，经过所有关键点后回到$x$所需的最短时间。这个转移的时候需要分三类讨论。假设现在$v$是$x$的一个儿子，

- 若$s(v)=0$，即以$v$为根的子树中没有关键点，则$g(v)=g(x)+2w(x,v)$；

- 若$K-s(v)=0$，即以$v$为根的子树以外没有关键点，则$g(v)=f(v)$；

- 其它情况，易知$g(v)=g(x)$。

第二步，求出距离$x$最远的关键点与$x$的距离。这个问题，貌似其它人都仍然是用dp做的，需要一些比较麻烦的分类讨论。

可是，我们为什么不能在dfs的过程中，直接**维护**每个关键点到当前点的距离最大值呢？

考虑在dfs的过程中，从$x$移动到它的某个儿子$v$时，以$v$为根的子树中的每个关键点到当前点的距离应该减少$w(x,v)$，以$v$为根的子树以外的每个关键点到当前点的距离都应该增加$w(x,v)$。

如果我们把关键点按照dfs序排序，子树不就对应了dfs序中的一个区间吗？

那子树以外的部分，显然就是整个区间$[1,K]$除去这棵子树对应的区间剩下的部分，也就是一前一后两个区间。

所以，我们可以用**线段树**维护区间加、全局最大值！

时间复杂度是$O(n\log n)$，但如果用传统的线段树+标记下传的写法常数很大，不开O2最后一个点会T。

过几天来补标记永久化和zkw的写法。。。。。。

```cpp
#include <cctype>
#include <cstdio>
#include <climits>
#include <algorithm>

template <typename T> inline void read(T& x) {
    int f = 0, c = getchar(); x = 0;
    while (!isdigit(c)) f |= c == '-', c = getchar();
    while (isdigit(c)) x = x * 10 + c - 48, c = getchar();
    if (f) x = -x;
}
template <typename T, typename... Args>
inline void read(T& x, Args&... args) {
    read(x); read(args...); 
}
template <typename T> void write(T x) {
    if (x < 0) x = -x, putchar('-');
    if (x > 9) write(x / 10);
    putchar(x % 10 + 48);
}
template <typename T> inline void writeln(T x) { write(x); puts(""); }
template <typename T> inline bool chkmin(T& x, const T& y) { return y < x ? (x = y, true) : false; }
template <typename T> inline bool chkmax(T& x, const T& y) { return x < y ? (x = y, true) : false; }

typedef long long LL;

const int maxn = 5e5 + 7;

int v[maxn << 1], next[maxn << 1], head[maxn];
LL w[maxn << 1];
int n, K, tot, cur;
bool key[maxn];
int dfn[maxn], seq[maxn], st[maxn];
int s[maxn];
LL f[maxn], g[maxn], dist[maxn], len[maxn];

inline void ae(int x, int y, LL z) {
    v[++tot] = y; w[tot] = z; next[tot] = head[x]; head[x] = tot;
    v[++tot] = x; w[tot] = z; next[tot] = head[y]; head[y] = tot;
}

struct Sgt {
    LL mx[maxn << 2], tag[maxn << 2];
    void update(int o) {
        mx[o] = std::max(mx[o << 1], mx[o << 1 | 1]);
    }
    void pushdown(int o) {
        if (tag[o]) {
            mx[o << 1] += tag[o];
            mx[o << 1 | 1] += tag[o];
            tag[o << 1] += tag[o];
            tag[o << 1 | 1] += tag[o];
            tag[o] = 0;
        }
    }
    void build(int o, int l, int r) {
        if (l == r) {
            mx[o] = dist[seq[l]];
            return;
        }
        int mid = (l + r) >> 1;
        build(o << 1, l, mid);
        build(o << 1 | 1, mid + 1, r);
        update(o);
    }
    void add(int o, int lb, int rb, int l, int r, LL d) {
        if (l > rb || r < lb) return;
        if (l <= lb && r >= rb) {
            mx[o] += d;
            tag[o] += d;
            return;
        }
        pushdown(o);
        int mid = (lb + rb) >> 1;
        add(o << 1, lb, mid, l, r, d);
        add(o << 1 | 1, mid + 1, rb, l, r, d);
        update(o);
    }
    void add(int l, int r, LL d) {
        if (l <= r)
            add(1, 1, K, l, r, d);
    }
    LL query(int o, int lb, int rb, int l, int r) {
        if (l > rb || r < lb) return 0;
        if (l <= lb && r >= rb) return mx[o];
        pushdown(o);
        int mid = (lb + rb) >> 1;
        return std::max(query(o << 1, lb, mid, l, r), query(o << 1 | 1, mid + 1, rb, l, r));
    }
};
Sgt sgt;

void dfs1(int x, int fa) {
    if (key[x]) {
        s[x] = 1;
        dfn[x] = ++cur;
        seq[cur] = x;
    }
    for (int i = head[x]; i; i = next[i])
        if (v[i] != fa) {
            dist[v[i]] = dist[x] + w[i];
            dfs1(v[i], x);
            s[x] += s[v[i]];
            if (s[v[i]])
                f[x] += f[v[i]] + 2ll * w[i];
        }
    if (s[x])
        st[x] = cur - s[x] + 1;
}

void dfs2(int x, int fa) {
    len[x] = sgt.query(1, 1, K, 1, K);
    for (int i = head[x]; i; i = next[i])
        if (v[i] != fa) {
            if (!s[v[i]])
                g[v[i]] = g[x] + 2ll * w[i];
            else if (!(K - s[v[i]]))
                g[v[i]] = f[v[i]];
            else g[v[i]] = g[x];
            if (s[v[i]])
                sgt.add(st[v[i]], st[v[i]] + s[v[i]] - 1, -w[i]);
            sgt.add(1, st[v[i]] - 1, w[i]);
            sgt.add(st[v[i]] + s[v[i]], K, w[i]);
            dfs2(v[i], x);
            // 不要忘了回溯
            if (s[v[i]])
                sgt.add(st[v[i]], st[v[i]] + s[v[i]] - 1, w[i]);
            sgt.add(1, st[v[i]] - 1, -w[i]);
            sgt.add(st[v[i]] + s[v[i]], K, -w[i]);
        }
}

int main() {
    read(n, K);
    for (int i = 1; i < n; ++i) {
        int x, y; LL z;
        read(x, y, z);
        ae(x, y, z);
    }
    for (int i = 1; i <= K; ++i) {
        int x; read(x);
        key[x] = 1;
    }
    dfs1(1, 0);
    sgt.build(1, 1, K);
    g[1] = f[1];
    dfs2(1, 0);
    for (int i = 1; i <= n; ++i)
        writeln(g[i] - len[i]);
    return 0;
}
```

---

## 作者：w33z8kqrqk8zzzx33 (赞：3)

首先，如果不知道换根 dp 的“结构”可以看我的[博客](https://www.luogu.com.cn/blog/220037/tan-huan-gen-dp-tao-lu)。

如何设计状态？

假设现在节点 1 为初始根节点。

设 $sz_i$ 为 $i$ 为根的子树里有多少个家，那：

$$sz_i=[i\text{ 有家}]+\sum_vsz_v$$

设 $f_i$ 为要多长时间来从 $i$ 开始，然后去 $i$ 子树里面所有家，**并且回来**。不难构造出来一个这样的方法：

 - 在节点 $i$；
 - 如果 $i$ 的孩子里有非零 $sz$，那走进那个孩子的子树，进过所有家，然后回到 $i$；
 - 重复。

明显这个答案等于

$$f_i = \sum_{sz_v\neq0}2w(i,v)+f_v$$

设 $a_i$ 为要多长时间来从 $i$ 开始，然后去 $i$ 子树里面所有家，**不用回来**。那就选择一个 $i$ 的孩子来选择进入单不走出 $j$，取 $\min$:

$$a_i = \sum_{sz_v\neq0}(1+[v\neq j])w(u,v)+(f_v/a_v)$$

如果全部减一下 $f_i$，得到：

$$a_i = \sum_{sz_v\neq0}2w(i,v)+f_v + \min_j(-w(i,j)-f_j+a_j)$$

$$a_i = f_i + \min_j(-w(i,j)-f_j+a_j)$$

设 $d_i = \min_j(-w(i,j)-f_j+a_j)$，那 $a_i = f_i + d_i$，带入：

$$d_i = \min_j(-w(i,j)-f_j+f_j+d_j)$$
$$d_i = \min_j(d_j-w(i,j))$$

现在就有了一下状态：

$$sz_i=[i\text{ 有家}]+\sum_vsz_v$$

$$f_i = \sum_{sz_v\neq0}2w(i,v)+f_v$$

$$d_i = \min_j(d_j-w(i,j))$$

注意应为需要换根，只存最小的 $d_j-w(i,j)$ 不够，也需要存次小值来让换根快。

现在写 `link` 和 `cut` 函数就特别简单了：

`link(u,v,w)` 函数：

 - 如果 $sz_v$ 是 $0$，什么都不用做；
 - 把 $sz_u$ 加上 $sz_v$；
 - 更新 $f_u$；
 - 更新最小和次小 $d_u$。

`cut(u,v,w)` 函数：

 - 如果 $sz_v$ 是 $0$，什么都不用做；
 - 把 $sz_u$ 减去 $sz_v$；
 - 把 $f_u$ 减去 $f_v$ 贡献进去的值；
 - 如果最小 $d_u$ 等于 $d_v-w(u,v)$，把最小 $d_u$ 改成次小 $d_u$，次小 $d_u$ 不用管；

然后好了。

代码：

```cpp
// writer: w33z8kqrqk8zzzx33
#include <bits/stdc++.h>
using namespace std;

// begin fast read template by CYJian (source: https://www.luogu.com.cn/paste/i11c3ppx)

namespace io {
	const int __SIZE = (1 << 21) + 1;
	char ibuf[__SIZE], *iS, *iT, obuf[__SIZE], *oS = obuf, *oT = oS + __SIZE - 1, __c, qu[55]; int __f, qr, _eof;
	#define Gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, __SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)
	inline void flush () { fwrite (obuf, 1, oS - obuf, stdout), oS = obuf; }
	inline void gc (char &x) { x = Gc(); }
	inline void pc (char x) { *oS ++ = x; if (oS == oT) flush (); }
	inline void pstr (const char *s) { int __len = strlen(s); for (__f = 0; __f < __len; ++__f) pc (s[__f]); }
	inline void gstr (char *s) { for(__c = Gc(); __c < 32 || __c > 126 || __c == ' ';)  __c = Gc();
		for(; __c > 31 && __c < 127 && __c != ' '; ++s, __c = Gc()) *s = __c; *s = 0; }
	template <class I> inline bool gi (I &x) { _eof = 0;
		for (__f = 1, __c = Gc(); (__c < '0' || __c > '9') && !_eof; __c = Gc()) { if (__c == '-') __f = -1; _eof |= __c == EOF; }
		for (x = 0; __c <= '9' && __c >= '0' && !_eof; __c = Gc()) x = x * 10 + (__c & 15), _eof |= __c == EOF; x *= __f; return !_eof; }
	template <class I> inline void print (I x) { if (!x) pc ('0'); if (x < 0) pc ('-'), x = -x;
		while (x) qu[++ qr] = x % 10 + '0',  x /= 10; while (qr) pc (qu[qr --]); }
	struct Flusher_ {~Flusher_(){flush();}}io_flusher_;
} using io::pc; using io::gc; using io::pstr; using io::gstr; using io::gi; using io::print;

// end fast read template by CYJian

#define iter(i, a, b) for(int i=(a); i<(b); i++)
#define rep(i, a) iter(i, 0, a)
#define rep1(i, a) iter(i, 1, (a)+1)
#define log(a) cerr<<"\033[32m[DEBUG] "<<#a<<'='<<(a)<<" @ line "<<__LINE__<<"\033[0m"<<endl
#define all(a) a.begin(), a.end()
#define fi first
#define se second
#define pb push_back
#define mp make_pair
 
using ll=long long;
using pii=pair<int, int>;
#define int ll
const int MOD = 1000000007;

int R[500005], D[500005], _D[500005], cnt[500005];
bool has[500005];
vector<pii> elist[500005];

void link(int fa, int ch, int w) {
	if(cnt[ch]) {
		cnt[fa] += cnt[ch];
		int c = D[ch]-w;
		if(c < D[fa]) {
			_D[fa] = D[fa];
			D[fa] = c;
		} else _D[fa] = min(_D[fa], c);
		R[fa] += R[ch] + 2*w;
	}
}

void cut(int fa, int ch, int w) {
	if(cnt[ch]) {
		cnt[fa] -= cnt[ch];
		int c = D[ch]-w;
		if(c == D[fa]) D[fa] = _D[fa];
		R[fa] -= R[ch] + 2 * w;
	}
}

void dfs(int u, int fa) {
	cnt[u] = has[u]; R[u] = D[u] = _D[u] = 0; // 初始化子树信息
	for(pii& v:elist[u]) {
		if(v.fi == fa) continue;
		dfs(v.fi, u); // 先 dfs，得到 v.fi 子树信息
		link(u, v.fi, v.se); // v.se 是额外信息来做 dp 转移
	}
}

int ans[500005];

void reroot(int u, int fa) {
	int pr = R[u], pd = D[u], p_d = _D[u], pcnt = cnt[u]; // 保持原信息来快速恢复状态
	ans[u] = R[u] + D[u]; // 计算答案
	for(pii& v:elist[u]) {
		if(v.fi == fa) continue;
		cut(u, v.fi, v.se); // 变成两个独立数
		link(v.fi, u, v.se); // 把 v.fi 放到上面连一条边
		reroot(v.fi, u); // 后 dfs，用上刚刚把 v.fi 移动到根的信息
		R[u] = pr, D[u] = pd, _D[u] = p_d, cnt[u] = pcnt; // 恢复状态
	}
}

signed main() {
    ios_base::sync_with_stdio(false); cin.tie(0);
    int N, K; gi(N), gi(K);
	rep(i, N-1) {
		int u, v, w; gi(u), gi(v), gi(w);
		elist[u].pb({v, w});
		elist[v].pb({u, w});
	}
	rep(i, K) {
		int v; gi(v);
		has[v] = 1;
	}
	dfs(1, -1);
	reroot(1, -1);
	rep1(i, N) print(ans[i]), pc('\n');
}
```

---

## 作者：nofind (赞：1)

## [题意](https://www.luogu.com.cn/problem/P6419)

显然是换根，先考虑以$1$为根进行第一次$dfs$：  
设$f_x$表示从$x$出发到子树中每个标记点后返回$x$的最小距离，$dis_{0,x}$表示$x$到子树中的标记点的最远距离。

显然答案为$f_1-dis_{0,1}$。

考虑换根：  
我们为了换根，需要再维护$dis_{1,x}$表示$x$到子树中的标记点的次远距离，且保证最远和次远不在同一棵子树中。

我们考虑$x\not =1$的答案包含$x$的子树与$x$的子树外，因此设$g_x$表示$x$子树外的答案，$up_x$表示$x$到子树外标记点的最远距离。  

$x$的答案显然为$f_x+g_x-\max(f_{0,x},up_x)$。

转移方程都好写，可以看代码。

code:
```
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=5e5+10;
int n,m,cnt_edge;
int head[maxn],a[maxn],size[maxn],f[maxn],g[maxn],up[maxn];
int dis[2][maxn];
struct edge{int to,nxt,dis;}e[maxn<<1];
inline int read()
{
    char c=getchar();int res=0,f=1;
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9')res=res*10+c-'0',c=getchar();
    return res*f;
}
inline void add_edge(int u,int v,int w)
{
	e[++cnt_edge].nxt=head[u];
	head[u]=cnt_edge;
	e[cnt_edge].to=v;
	e[cnt_edge].dis=w;
}
void dfs1(int x,int fa)
{
	size[x]=a[x];
	for(int i=head[x];i;i=e[i].nxt)
	{
		int y=e[i].to;
		if(y==fa)continue;
		dfs1(y,x);size[x]+=size[y];
		if(size[y])
		{
			f[x]+=f[y]+e[i].dis*2;
			if(dis[0][y]+e[i].dis>dis[0][x])dis[1][x]=dis[0][x],dis[0][x]=dis[0][y]+e[i].dis;
			else if(dis[0][y]+e[i].dis>dis[1][x])dis[1][x]=dis[0][y]+e[i].dis;
		}
	}
}
void dfs2(int x,int fa)
{
	for(int i=head[x];i;i=e[i].nxt)
	{
		int y=e[i].to;
		if(y==fa)continue;
		if(m-size[y])
		{
			g[y]=g[x]+f[x]-f[y];
			if(!size[y])g[y]+=2*e[i].dis;
			if(dis[0][x]==dis[0][y]+e[i].dis)up[y]=max(up[x],dis[1][x])+e[i].dis;
			else up[y]=max(up[x],dis[0][x])+e[i].dis;
		}
		dfs2(y,x);
	}
}
signed main()
{
	n=read(),m=read();
	for(int i=1;i<n;i++)
	{
		int u=read(),v=read(),w=read();
		add_edge(u,v,w),add_edge(v,u,w);
	}
	for(int i=1;i<=m;i++)a[read()]++;
	dfs1(1,0);dfs2(1,0);
	for(int i=1;i<=n;i++)printf("%lld\n",f[i]+g[i]-max(dis[0][i],up[i]));
	return 0;
}
```


---

## 作者：KokiNiwa (赞：1)

# [「COCI 2014.10」Kamp](https://loj.ac/problem/2806)

这是一个换根```dp```

## 题目叙述

给你一颗树，求从每个点出发经过指定地点（至少一个）不回到原点的最小距离。

## 题解

从$x$点出发，答案就是  $x$和所有目标形成的虚树大小$\times2-x$到最远的目标的距离。

那么换根$dp$求出每个点的虚树大小（大概第一遍是$dp_x$表示从$x$和$x$子树里的目标点的叙述大小，第二遍考虑换根的影响就好了）。

第二个求最远距离，那么考虑如何换根，第一种是从$x$走到儿子$s$，$s$不是$x$的最远目标点，那么最远点一定是从原来最远点走过去的。第二种是从$x$走到最远点，那么答案还有可能是从$s$外转移得到的，具体就是从$x$外转移和从其他儿子转移，那么维护一个子树内最大值，和子树外最大值就好了。子树外最大值可以从当前点父亲和当前点父亲的其他儿子中最大的转移（就是子树内次大值）。



---


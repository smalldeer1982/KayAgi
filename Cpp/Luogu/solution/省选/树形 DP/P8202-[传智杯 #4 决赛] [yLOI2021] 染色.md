# [传智杯 #4 决赛] [yLOI2021] 染色

## 题目背景

传智杯 2021 决赛 G 题。

## 题目描述

传智专修学院的老师给小智布置了一项任务。

老师给了小智一张纸，上面画着一棵有 $n$ 个节点的树（如果你不知道什么是树，可以参考上一题对此的解释）。老师还给了小智 $m$ 支彩色笔，每支笔的颜色都是不同的。老师想要让小智用这 $m$ 种颜色给树的节点涂色，使得这棵树满足如下约束：

1. 每个节点都被涂上了这 $m$ 个颜色之一的**一种**颜色。
2. 相邻两个节点（若存在一条边直接连接 $u$ 和 $v$，则我们称 $u,v$ 相邻）的颜色是不同的。
3. 任何一种颜色被使用的次数都不能超过 $\lfloor\frac{n}{3}\rfloor + 1$。

需要指出的是，虽然每个节点都必须被涂上一种颜色，但是每个颜色并不必须被使用。

如此简单的任务难不倒小智，所以小智提出了一个更困难的问题：他想知道一共有多少种染色的方案满足老师的要求。小智不会解答这个问题，所以来求助你，请你帮他解决他的问题。

因为方案数可能非常大，你只需要输出这个方案数除以 $998,244,353$ 的余数。两种染色方案不同当且仅当存在一个节点 $u$，使得 $u$ 在两种方案种被染上的颜色不同。

## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $1 \leq u, v \leq n\leq 100$，$n \leq m \leq 10^6$，保证给出的是一棵树。

### 提示

**请注意常数因子对程序效率造成的影响**。

## 样例 #1

### 输入

```
4 4
1 2
1 3
3 4
```

### 输出

```
108```

## 样例 #2

### 输入

```
3 3
1 2
1 3
```

### 输出

```
12```

## 样例 #3

### 输入

```
5 5
1 2
1 3
2 4
3 5
```

### 输出

```
1200```

## 样例 #4

### 输入

```
5 5
1 2
1 3
2 4
2 5```

### 输出

```
1140```

## 样例 #5

### 输入

```
7 8
1 2
1 3
2 4
2 5
3 6
3 7
```

### 输出

```
929376```

## 样例 #6

### 输入

```
6 6
1 2
1 3
3 4
4 5
3 6```

### 输出

```
18750```

## 样例 #7

### 输入

```
10 20
1 2
1 3
2 4
2 5
2 6
2 7
3 8
5 9
9 10
```

### 输出

```
688946281```

# 题解

## 作者：一扶苏一 (赞：5)

## G. 染色

**题意**：给定一棵 $n$ 个节点的树，要求用 $m$ 种颜色将其染色，要求相邻两个节点的颜色不同，且任何一种颜色的使用次数都不超过 $\lfloor\frac{n}{3}\rfloor + 1$。

$1 \leq n \leq 100$，$m \leq n \leq 10^6$。

**关键词**：容斥，DP。

**参考难度**：蓝/紫。

**解析**：本题出题灵感来源于 「CF1487G String Counting」和「LuoguP5664 [CSP-S2019] Emiya 家今天的饭」。

首先注意到 $\lfloor\frac{n}{3}\rfloor + 1$ 的限制，可以发现即使我们不考虑这个限制，也至多会有两种颜色超出（因为一旦有三种颜色超出则总数大于 $n$）。于是不难设计容斥：答案 = 不考虑限制的方案数 - 至少有一种颜色超出限制的方案数 + 两种颜色超出限制的方案数。

我们直接考虑计算两种颜色超出限制的方案数：不难设计 dp：设 $f_{u, p,q,i, j, 0/1/2}$ 表示 $p$ 和 $q$ 是我们钦定的两种**可能**超限制的颜色，以 $u$ 为根的子树里有 $i$ 个 $p$ 颜色和 $j$ 个 $q$ 颜色，且 $u$ 是颜色 $p$ /颜色 $q$ /其他颜色的方案数，转移暂时不表。

进一步考虑发现颜色之间没有本质区别也就是对于不同的 $p, q$，算出 $f_{u, p, q, i, j, 0/1/ 2}$ 的结果都是一样的，于是我们只需要计算一次 $f$ 数组，然后乘上 $C_m^2$ 即可。于是状态被优化为：设 $f_{u, i, j, 0/1/2}$ 表示以 $u$ 为根的子树里有 $i$ 个颜色 1 和 $j$ 个颜色 2，且 $u$ 是颜色 1/颜色 2/其他颜色的方案数。

方便起见，我们设已经转移了 $u$ 的前 $p - 1$ 个孩子，目前考虑合并第 $p$ 个孩子 $v$ 的信息。已合并的孩子的信息存储在 $h_{p, i, j, 0/1/2}$ 数组中。

$$h_{p, i, j, 0} = \sum_{x = 0}^i\sum_{y = 0}^j(f_{v,x,y,0} + f_{v,x,y,1}) \times h_{p,i - x,j - y,0}$$

$h_{p, i, j, 1}$ 的转移与之完全对称。

考虑 $h_{p, i, j, 2}$：此时 $u$ 是一个非颜色 1 或颜色 2 的其他颜色。$v$ 是颜色 1/2 的转移是简单的，考虑 $v$ 也是一个其他颜色时，$v$ 的颜色不能和 $u$ 的相同。因此 $v$ 对 $h_p$ 的贡献不是 $f_{v, ?,?,2}$ 全部，而是除去了 $v$ 的颜色与 $u$ 相同的那部分。注意到 $f_{v}$ 共表示了 $v$ 取 $(m - 2)$ 种颜色的方案数，而颜色之间没有本质区别，因此每种颜色的方案数都是 $\frac {f_{v, ?, ?, 2}}{m - 2}$。去掉 $u$ 的颜色，共有 $m - 3$ 种颜色产生了贡献，因此总的贡献是 $\frac{(m - 3)f_{v, ?, ?, 2}}{m - 2}$。

于是转移如下：

$h_{p, i, j, 2} = \sum_{x=  0}^i\sum_{y = 0}^j(f_{v,x,y,0} + f_{v,x,y,1} + \frac{(m - 3)f_{v,x,y,2}}{m - 2}) \times h_{p - 1, i - x, j - y, 2}$

因为是模意义下的计数，所以除以 $m - 2$ 要改为乘 $m - 2$ 的逆。但是如果将 $f_{u, ?, ?, 2}$ 的方案数定义为某一个不会超出限制的“颜色 3”的方案数，则可以规避掉乘逆元的过程。

上述转移的边界条件是 $h_{p, 1, 0, 0} = h_{p, 0, 1, 1} = 1$，$h_{p,0,0,2} = m - 2$，其余均为 $0$。若想要规避求逆元，则令 $h_{p, 0, 0, 2} = 1$ 即可，最后计数时要把 $(m - 2)$ 再乘上。

不难发现，$\sum_{i = lim + 1}^n\sum_{j = 1}^nf_{1, i, j, 0/1/2}$ 即为至少有一个超出限制的方案数，其中 $lim = \lfloor\frac{n}{3}\rfloor + 1$。

将 $i$ 改为从 $1$ 至 $n$ 枚举，就是不考虑限制的方案数。

当然，不考虑限制的方案数也可以这样推导：

设 $g_{u, i}$ 表示以 $u$ 为根的子树，$u$ 的颜色是 $i$ 的方案数；$G_u$ 表示以 $u$ 为根的子树的总方案数，则：

$G_{u} = \sum\limits_{col = 1}^m\prod\limits_{v \in son(u)} \sum\limits_{1 \leq j \leq m}^{j \neq col}g_{v,j} = \sum\limits_{col = 1}^m \prod\limits_{v \in son(u)} \frac{m - 1}{m}G_v = m\prod\limits_{v \in son(u)} \frac{m - 1}{m}G_v$

这里同样用到了颜色没有本质不同。

考虑 $f$ 有 $O(n^3)$ 个状态，转移是 $O(n^2)$ 的，所以看起来的时间复杂度是 $O(n^5)$。但是可以使用如下的技巧将其实际复杂度优化至 $O(n^4)$：

```cpp
void dfs(const int u, const int f) {
  sz[u] = 1;
  for (auto v : e[u]) if (v != f) {
    dfs(v);
    for (int i = 1; i <= sz[u]; ++i) {
      for (int x = 1; x <= sz[v]; ++x) {
        for (int j = 1; j <= sz[u]; ++j) {
          for (int y = 1; y <= sz[v]; ++y) {
            // do sth O(1).
          }
        }
      }
    }
    sz[u] += sz[v];
  }
}
```

这是因为枚举 $i$ 和 $x$ 的过程可以看作枚举 $u$ 前面的子树和 $v$ 这个子树里面的点组成的点对，显然整棵树的点对只有 $O(n^2)$ 个，每个点对只会在 LCA 处被枚举。所以遍历树上 $n$ 个点并枚举子树间的点对的总复杂度是 $O(n^2)$，而里面两层循环也是 $O(n^2)$，故总复杂度是 $O(n^4)$。

如果因为常数极小，$O(n^5)$ 的算法有可能卡过本题。在测试中，五次方算法的最坏用时在 800ms 左右，因此本题的时间限制开到了 500ms。事实上显而易见，里面两层循环有极小的常数，所以 $n^4$ 也是一个比较松的上界。

(C++)

```cpp
#include <array>
#include <vector>
#include <iostream>
#include <cstdio>

typedef long long int ll;

const int maxn = 105;
const int maxm = 1000006;
const int p = 998244353;

int n, m, invm, invm2;
std::array<std::array<std::array<std::array<std::array<long long, 3>, maxn>, maxn>, 2>, maxn> f;
std::array<int, maxn> pos, sz;
std::array<long long, maxn> g;
std::array<std::vector<int>, maxn> e;

void dfs(const int u, const int fa);
void calc(const int u, const int fa);

int mpow(ll x, int y) {
  ll ret = 1;
  while (y) {
    if (y & 1) (ret *= x) %= p;
    y >>= 1;
    (x *= x) %= p;
  }
  return ret;
}

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(0);
  std::cin >> n >> m;
  invm = mpow(m, 998244351);
  invm2 = mpow(m - 2, 998244351);
  long long ans = m;
  for (int i = 1, u, v; i < n; ++i) {
    std::cin >> u >> v;
    e[u].push_back(v);
    e[v].push_back(u);
  }
  calc(1, 0);
  ll s1 = 0, s2 = 0;
  for (int i = n / 3 + 2; i <= n; ++i) {
    for (int j = 0; j <= n; ++j) {
      for (int k = 0; k <= 2; ++k) {
        (s1 += f[1][pos[1]][i][j][k]) %= p;
      }
    }
    for (int j = n / 3 + 2; j <= n; ++j) {
      for (int k = 0; k <= 2; ++k) {
        (s2 += f[1][pos[1]][i][j][k]) %= p;
      }
    }
  }
  ans = g[1];
  ans -= m * s1 % p;
  ans += (m - 1ll) * m / 2 % p * s2 % p;
  (ans += p) %= p;
  std::cout << ans << '\n';
}

void calc(const int u, const int fa) {
  f[u][pos[u]][1][0][0] = f[u][pos[u]][0][1][1] = 1; f[u][pos[u]][0][0][2] = m - 2;
  sz[u] = 1;
  g[u] = m;
  for (auto v : e[u]) if (v != fa) {
    calc(v, u);
    pos[u] ^= 1;
    (g[u] *= (m - 1ll) * invm % p * g[v] % p) %= p;
    for (int i = 0; i <= sz[u] + sz[v]; ++i) {
      for (int j = 0; j <= sz[u] + sz[v]; ++j) {
        f[u][pos[u]][i][j].fill(0);
      }
    }
    for (int i = sz[u]; i >= 0; --i) {
      for (int x = 0; x <= sz[v]; ++x) {
        for (int j = sz[u]; j >= 0; --j) {
          for (int y = 0; y <= sz[v]; ++y) {
            (f[u][pos[u]][i + x][j + y][0] += (f[u][pos[u] ^ 1][i][j][0]) * (f[v][pos[v]][x][y][1] + f[v][pos[v]][x][y][2]) % p) %= p;
            (f[u][pos[u]][i + x][j + y][1] += (f[u][pos[u] ^ 1][i][j][1]) * (f[v][pos[v]][x][y][0] + f[v][pos[v]][x][y][2]) % p) %= p;
            (f[u][pos[u]][i + x][j + y][2] += (f[u][pos[u] ^ 1][i][j][2]) * ((f[v][pos[v]][x][y][0] + f[v][pos[v]][x][y][1]) % p 
                + f[v][pos[v]][x][y][2] * invm2 % p * (m - 3) % p) % p) %= p;
          }
        }
      }
    }
    sz[u] += sz[v];
  }
}
```

---

## 作者：abruce (赞：3)

发现“每种颜色出现次数不超过 $\lfloor\dfrac{n}{3}\rfloor+1$”这个条件不好直接处理。我们发现非法的颜色数量不会超过 $2$，于是考虑一个容斥，答案即为 不管使用数量限制直接用树染色得到的答案 减去 至少有一种非法颜色得到的答案 加上 有两种非法颜色得到的答案。现在我们考虑求这三个东西。  

首先是不管使用数量限制直接用树染色得到的答案。我们发现，假设以 $1$ 为根，如果我们从根往下染色，那么每个点的颜色只会被它的父亲所限制，而 $1$ 号点没有限制。于是答案即为 $m\times (m-1)^{n-1}$。  

接下来我们考虑至少有一种非法颜色得到的答案。我们很明显需要把这种颜色和其它颜色分开算，于是我们考虑一个树形 dp。记 $g_{u,j,0/1}$ 为 $u$ 子树选了 $j$ 个这种颜色，$u$ 有没有被选。初始化 $g_{u,0,0}\leftarrow m-1,g_{u,1,1}\leftarrow 1$。  
接下来我们考虑转移，假设我们现在要将 $v$ 转移到 $u$ 上去，这很明显需要一个树形背包，于是我们用树形背包的方式枚举 $j,k$，代表 $u$ 和 $v$ 之前子树共选 $j$ 个，$v$ 选 $k$ 个。转移的方程为：

$$g_{u,j+k,0}\leftarrow g_{u,j+k,0}+g_{u,j,0}\times(g_{v,k,1}+g_{v,k,0}\times\tfrac{m-2}{m-1})$$
$$g_{u,j+k,1}\leftarrow g_{u,j+k,1}+g_{u,j+k,1}+g_{u,j,1}\times g_{v,k,0}$$  
解释：把 $v$ 合并上去后两个子树选的颜色个数肯定是要相加的。如果 $u$ 选了这种颜色，那 $v$ 必须不选。如果 $u$ 不选，$v$ 可以选也可以不选，如果不选的话方案会少一种，但是我们在 $v$ 那里统计的贡献是 $m-1$，现在要把它变成 $m-2$。这部分时间复杂度 $O(n^2)$。

最后是有两种非法颜色得到的答案，有了上面那种情况，这一种的 dp 就很好列了。我们记 $f_{u,j,j1,0/1/2}$ 为 $u$ 这个子树选了 $j$ 个一号颜色， $j1$ 个二号颜色（很明显这样计算的话这两个选出来的颜色是有序的），当前点没选/选了一号/选了二号。初始化 $f_{u,0,0,0}=m-2,f_{u,1,0,1}=f_{u,0,1,2}=1$  
转移也和上面类似。对于一个要转移上来的 $v$，枚举 $j,j1,k,k1$，代表 $u$ 和 $v$ 之前子树共选 $j$ 个一号颜色，$j1$ 个二号颜色，$v$ 选 $k$ 个一号颜色，$k1$ 个二号颜色。转移的方程为：  
$$f_{u,j+k,j1+k1,0}\leftarrow f_{u,j+k,j1+k1,0}+f_{u,j,j1,0}\times(f_{v,k,k1,0}\times\tfrac{m-3}{m-2}+f_{v,k,k1,1}+f_{v,k,k1,2})$$
$$f_{u,j+k,j1+k1,1}\leftarrow f_{u,j+k,j1+k1,1}+f_{u,j,j1,1}\times(f_{v,k,k1,0}+f_{v,k,k1,2})$$
$$f_{u,j+k,j1+k1,2}\leftarrow f_{u,j+k,j1+k1,2}+f_{u,j,j1,2}\times(f_{v,k,k1,0}+f_{v,k,k1,1})$$  

这里就不作过多解释了，自己对着上面的解释看就行了。这部分我问过教练，它给的答复是 $O(n^4)$。  

最后统计答案的部分就该怎么样怎么样，选出一/两种颜色，然后把 $f/g$ 的值加进答案里面就可以了。  

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=105,mod=998244353;
struct edge {
	int next,to;
} e[maxn*2];
int h[maxn],cnt,n,m,siz[maxn];
ll g[maxn][maxn][2],f[maxn][maxn][maxn][3],ans,v1,v2,lg[maxn][2],lf[maxn][maxn][3];
void addedge(int x,int y) {
	e[++cnt].next=h[x],e[cnt].to=y,h[x]=cnt;
}
ll qpow(ll x,int y) {
	ll w=1;
	while(y) {
		if(y&1)w=w*x%mod;
		x=x*x%mod;
		y>>=1;
	}
	return w;
}
ll c2(ll x) {
	return x*(x-1)/2%mod;
}
void dp(int u,int fa) {
	g[u][0][0]=m-1,g[u][1][1]=1,siz[u]=1;
	f[u][0][0][0]=m-2,f[u][1][0][1]=f[u][0][1][2]=1;
	for(int i=h[u]; i; i=e[i].next) {
		int v=e[i].to;
		if(v==fa)continue;
		dp(v,u);
		for(int j=0; j<=siz[u]; j++) {
			memcpy(lg[j],g[u][j],sizeof(lg[j])),memset(g[u][j],0,sizeof(g[u][j]));
			for(int k=0; k<=siz[u]-j; k++)memcpy(lf[j][k],f[u][j][k],sizeof(lf[j][k])),memset(f[u][j][k],0,sizeof(f[u][j][k]));
		}
		for(int j=siz[u]; ~j; j--)
			for(int k=siz[v]; ~k; k--) {
				g[u][j+k][1]=(g[u][j+k][1]+lg[j][1]*g[v][k][0])%mod;
				g[u][j+k][0]=(g[u][j+k][0]+(g[v][k][1]+g[v][k][0]*v1)%mod*lg[j][0])%mod;
				for(int j1=siz[u]-j; ~j1; j1--)
					for(int k1=siz[v]-k; ~k1; k1--) {
						ll *to=f[u][j+k][j1+k1],*nu=lf[j][j1],*nv=f[v][k][k1];
						to[2]=(to[2]+nu[2]*(nv[0]+nv[1]))%mod;
						to[1]=(to[1]+nu[1]*(nv[0]+nv[2]))%mod;
						to[0]=(to[0]+(nv[1]+nv[2]+nv[0]*v2)%mod*nu[0])%mod;
					}
			}
		siz[u]+=siz[v];
	}
}
int main() {
	int x,y,lim;
	scanf("%d%d",&n,&m),lim=n/3+2;
	if(n==1)return printf("%d\n",m),0;
	if(n==2)return printf("%lld\n",1ll*m*(m-1)%mod),0;
	for(int i=1; i<n; i++) {
		scanf("%d%d",&x,&y);
		addedge(x,y),addedge(y,x);
	}
	v1=qpow(m-1,mod-2)*(m-2)%mod,v2=qpow(m-2,mod-2)*(m-3)%mod;
	dp(1,0),ans=qpow(m-1,n-1)*m%mod;
	for(int i=lim; i<=n; i++) {
		ans=(ans-(g[1][i][0]+g[1][i][1])*m%mod+mod)%mod;
		for(int j=lim; j<=n-i; j++)ans=(ans+(f[1][i][j][0]+f[1][i][j][1]+f[1][i][j][2])*c2(m))%mod;
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：比利♂海灵顿 (赞：1)

# P8202 染色

树形 DP，是无需求逆元的版本。

$\tiny{验题人题解(?)}$

我们设 $Lim = \lfloor \frac n3 \rfloor + 2$，约束 $3$ 就变成所有颜色出现次数都不大于等于 $Lim$。

## 容斥

先算出忽略限制 $3$ 的方案数。然后减去规定某个颜色出现大于等于 $Lim$ 的方案数，这时两个颜色大于等于 $Lim$ 的方案被减去了两次，所以最后加上两个颜色大于等于 $Lim$ 的方案数。

## 设计

每个点的状态 $f_{i, j, 0/1/2}$ 表示这个点的子树中颜色 $1$ 的点有 $i$ 个，颜色 $2$ 的点有 $j$ 个，这个点的颜色为其它确定的颜色/颜色 $1$/颜色 $2$ 的方案数。

注意这个状态所计算的是当前节点颜色确定的方案数，转移到父亲时要枚举这个点的颜色。

因为 $i$ 或 $j$ 大于 $Lim$ 就失去意义了，所以我们把转移到某一维大于 $Lim$ 的状态转移到对应维度等于 $Lim$ 的状态即可。

下面的 $f$ 特指根节点的 DP 数组，那么总方案就可以表示为:

$$
\sum_{i, j \leq Lim} \max(m - 2, 0) \times f_{i, j, 0} + f_{i, j, 1} + f_{i, j, 2}
$$

表示枚举了所有组合情况下，根节点为所有 $m$ 种颜色的方案数总和。

接下来我们求强制使某个颜色出现次数大于等于 $Lim$ 的方案数。因为每个颜色是等价的，所以不管强制哪个颜色，它的方案数一定等于强制颜色 $1$ 出现次数大于等于 $Lim$，我们只要先强制颜色 $1$ 出现多次，然后乘以 $m$ 即可。

$$
m \sum_{i \leq Lim} \max(m - 2, 0) \times f_{Lim, i, 0} + f_{Lim, i, 1} + f_{Lim, i, 2}
$$

最后求强制某两个颜色出现次数大于等于 $Lim$ 的方案数。仍然是因为每个颜色等价，所以我们求强制颜色 $1$ 和 $2$ 出现次数大于等于 $Lim$ 的方案数最后乘 $\dfrac{m(m - 1)}2$。

$$
\frac{m(m - 1)}2 \max(m - 2, 0) \times f_{Lim, Lim, 0} + f_{Lim, Lim, 1} + f_{Lim, Lim, 2}
$$

## 转移

最后我们只要解决转移的问题就可以了。

对于 $x.f_{i, j, 0}$, 它的每个儿子有颜色 $1$, $2$, 和 $m - 3$ 种其它颜色可选，枚举两部分 $1$ 和 $2$ 的数量做树上背包合并即可:

$$
\text{New}x.f_{i1 + i2, j1 + j2, 0} = \text{Old}x.f_{i1, j1, 0} (\max(m - 3, 0) \times Son.f_{i2, j2, 0} + Son.f_{i2, j2, 1} + Son.f_{i2, j2, 2})
$$

对于 $x.f_{i, j, 1}$，它的每个儿子有颜色 $2$，和 $m - 2$ 种其它颜色可选，枚举两部分 $1$ 和 $2$ 的数量做树上背包合并即可:

$$
\text{New}x.f_{i1 + i2, j1 + j2, 1} = \text{Old}x.f_{i1, j1, 1} (\max(m - 2, 0) \times Son.f_{i2, j2, 0} + Son.f_{i2, j2, 2})
$$

对于 $x.f_{i, j, 2}$，它的每个儿子有颜色 $1$，和 $m - 2$ 种其它颜色可选，枚举两部分 $1$ 和 $2$ 的数量做树上背包合并即可:

$$
\text{New}x.f_{i1 + i2, j1 + j2, 2} = \text{Old}x.f_{i1, j1, 2} (\max(m - 2, 0) \times Son.f_{i2, j2, 0} + Son.f_{i2, j2, 1})
$$

复杂度类似于树上背包，是 $O(n^4)$ 的。

## 代码实现

```cpp
unsigned long long Mod(998244353);
unsigned long long Ans(0), m, m1, m2, m3;
unsigned n, Tp;
unsigned A, B, C, D, t;
unsigned Cnt(0), Tmp(0);
struct Node {
  vector <Node*> E;
  unsigned f[36][36][3], Size;
}N[105];
inline void DFS(Node* x, Node* Fa) {
  x->Size = x->f[0][0][0] = x->f[1][0][1] = x->f[0][1][2] = 1;
  for (auto i : x->E) if (i != Fa) {
    DFS(i, x);
    unsigned To(x->Size + i->Size);
    unsigned Tmpf[min(To, Tp) + 1][36][3];
    memset(Tmpf, 0, sizeof(Tmpf));
    for (unsigned j1(min(Tp, x->Size)); ~j1; --j1) for (unsigned j2(min(Tp, x->Size)); ~j2; --j2) {
      unsigned* J(x->f[j1][j2]);
      if (!(J[0] || J[1] || J[2])) continue;
      for (unsigned k1(min(Tp, i->Size)); ~k1; --k1) for (unsigned k2(min(Tp, i->Size)); ~k2; --k2) {
        unsigned* K(i->f[k1][k2]), * T(Tmpf[min(j1 + k1, Tp)][min(j2 + k2, Tp)]);
        if (!(K[0] || K[1] || K[2])) continue;
        T[0] = (T[0] + J[0] * (K[0] * m3 % Mod + K[1] + K[2])) % Mod;
        T[1] = (T[1] + J[1] * (K[0] * m2 % Mod + K[2])) % Mod;
        T[2] = (T[2] + J[2] * (K[0] * m2 % Mod + K[1])) % Mod;
      }
    }
    memcpy(x->f, Tmpf, sizeof(Tmpf));
    x->Size = To;
  }
}
signed main() {
  n = RD(), m = RD(), Tp = (n / 3) + 2, m1 = m - 1, m2 = (m1 ? (m1 - 1) : 0), m3 = (m2 ? (m2 - 1) : 0);
  for (unsigned i(1); i < n; ++i)
    A = RD(), B = RD(), N[A].E.push_back(N + B), N[B].E.push_back(N + A);
  DFS(N + 1, NULL);
  for (unsigned i(0); i <= Tp; ++i) for (unsigned j(0); j <= Tp; ++j) 
    Ans = (Ans + N[1].f[i][j][0] * m2 + N[1].f[i][j][1] + N[1].f[i][j][2]) % Mod;
  for (unsigned i(0); i <= Tp; ++i) Ans = (Ans + (Mod - m) * ((N[1].f[Tp][i][0] * m2 + N[1].f[Tp][i][1] + N[1].f[Tp][i][2]) % Mod)) % Mod;
  Ans = (Ans + ((N[1].f[Tp][Tp][0] * m2 + N[1].f[Tp][Tp][1] + N[1].f[Tp][Tp][2]) % Mod) * ((m * m1 >> 1) % Mod)) % Mod;
  printf("%llu\n", Ans);
  return Wild_Donkey;
}
```

---


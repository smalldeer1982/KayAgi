# [DMOI-R2] 暗号

## 题目背景

> 有太多人太多事 夹在我们之间咆哮  
> 杂讯太多讯号弱 就连风吹都要干扰  
> 可是你不想 一直走在黑暗地下道  
> 想吹风想自由 想要一起手牵手 去看海绕世界流浪  
> ——《[暗号](https://www.bilibili.com/video/BV1p24y1f7zM)》

书接上回，每个军队都拿到了补给。但是要上战场，准备还不是很充分。JF 只有军队组成了一个集团军。才有可能形成一股强大的战斗力，才可以在军阀混战中取得胜利。

## 题目描述

已知 JF 有 $n$ 支军队，他们分别由 $n-1$ 条边连接。$1$ 号军队为根。每支军队有自己的或黑或白的 **“暗号”**，方便相互联系，以及他的战力值和士气值。**初始的时候，军队的士气值等于战力值**。我们从深度最深的军队开始改变士气值，对于当前的军队 $u$ 来说，在与他直接相连的军队且深度比 $u$ 深的军队中，如果有军队 $v$ 和他的暗号相同，$u$ 就可以联系上 $v$，然后 $u$ 的士气值 **就必须全部加上**  $v$ 的子树内和 $v$ 颜色相同的点的战力值。（可以理解为，在 $u$ 的士气更新完毕时，$u$ 的子树的士气也更新完毕了。）  

现在，你可以任意修改这些军队的暗号。要你求出所有**军队士气值的和的最大值**是多少。

## 说明/提示

#### 【样例解释 #1】

我们将军队 $1,3,4$ 的暗号改为黑色，军队 $2$ 的暗号改成白色。这样，军队 $1,2,3,4$ 的最终士气值变为 $10,-2,4,-7$，总和为 $5$。可以证明不存在使得最终士气值和更大的方案。

#### 【样例解释 #2】

我们用 $1$ 表示黑色暗号，用 $2$ 表示白色暗号，那么 $n$ 支军队的暗号颜色分别如下：`1 1 1 1 2 1 2 2 2 1`。这样整支军队的士气值和为 $42$，可以证明不存在士气值和更大的方案。

#### 【数据范围与约定】

| 测试点编号 | $n \le$ | 特殊条件 |
| :----------: | :----------: | :----------: |
| $1\sim2$ | $20$ | 无 |
| $3 \sim 6$ | $50$ | 无 |
| $7 \sim 10$ | $300$ | $v=u+1$ |
| $11\sim12$ | $300$ | $1 \le w_i \le 1000$ |
| $13\sim14$ | $300$ | $u=1$ |
| $15 \sim 20$ | $300$ | 无 |

对于 $100\%$ 的数据，$1 \le n \le 300$，$-1000 \le w_i \le 1000$。

## 样例 #1

### 输入

```
4
1 2 
1 3 
2 4 
6 -2 4 -7 ```

### 输出

```
5```

## 样例 #2

### 输入

```
10
1 2
1 3
2 4
2 5
3 6
3 7
4 8
4 9
4 10
-3 9 4 -3 -2 5 -1 -3 -9 7```

### 输出

```
42```

## 样例 #3

### 输入

```
20
1 2
1 3
2 4
2 5
3 6
3 7
4 8
4 9
4 10
6 11
6 12
7 13
7 14
7 15
7 16
8 17
9 18
11 19
15 20
1 2 -1 -4 9 -3 -5 8 9 -10 -13 15 11 -6 17 -1 -19 20 -5 -9```

### 输出

```
266```

## 样例 #4

### 输入

```
6
1 2
1 3
1 4
2 5
2 6
-1 5 -3 -4 -5 -7```

### 输出

```
-10```

# 题解

## 作者：Nuyoah_awa (赞：8)

### 题目大意

给你一棵树，让你从下往上黑白染色，并计算这棵树的最大战力值。

对于战力值，初始为点权，如染色中相邻两点颜色相同，父亲节点的战力值需加上子节点和子节点中所有与其颜色相同结点的战力值。

### 题目分析

- 暴力：

暴力很好想，枚举每种不同的染色方式，然后计算它的战力值总和。

时间复杂度 $\mathcal O(2 ^ n \times n)$。然后可以得到 $20$ 分的好成绩。

- 正解：

看到题目中是一棵树，而且父亲节点的值是由子节点得出的，于是很好想到是一道树形 dp。

我们按照一般的树形 dp 来想，我们可以定义 $f_{i, 0/1}$ 表示第 $i$ 个点选或不选时的最大战力值。

然后我们来想如何转移，但是不幸的是我们转移 $f_{i}$ 的时候需要知道他的子树中有哪些点与其颜色相同，很明显我们在 dp 状态中无法将其呈现。

于是我们换个思路来想，我们发现，对于每一次“合并”，父节点 $x$ 的战力值需要加上子节点 $y$ 为根的子树下所有颜色与之相同的点的战力值，我们反过来想，对于父节点 $x$，它的战力值在它之上每一次颜色与之相同的“合并”中都会将这个点的战力值加上一遍，于是我们可以向上 dp。

我们定义 $f_{i, 0/1, j,k}$ 表示第 $i$ 个点选或不选，它之上要经过 $j$ 次颜色为 $1$ 的合并和 $k$ 次颜色为 $0$ 的合并，一这个点为根的子树的最大士气和。

对于转移，我们很容易想到是由子节点的士气和加起来，对于当前点的点权，我们只需要加上这个点的点权乘上上面这个颜色的合并次数就好了（对于子节点的点权已经包含在子节点的 $f$ 中了）。

抽象来讲，转移方程为：

$$\begin{cases} f_{x,0,j,k} = \sum\limits_{y\in x} \max\limits_{j = 0}^{j < n}\max\limits_{k = 0}^{k < n}(f_{y,0,j+1,k}, f_{y,1,j,k}) \\ f_{x,1,j,k} = \sum\limits_{y \in x} \max\limits_{j = 0}^{j < n}\max\limits_{k = 0}^{k < n}(f_{y,0,j,k}, f_{y,1,j,k+1}) \end{cases}$$

注：$y$ 为 $x$ 的子节点，$\sum\limits_{y \in x}$ 表示枚举 $x$ 的子节点。

特别的，对于 $f$ 数组的初值，我们将其定义为这个点的点权对于最终答案的价值，即：

$$\begin{cases}f_{x,0,i,j} = (i + 1) \times w_x \\ f_{x,1,i,j} = (j + 1) \times w_x
\end{cases}$$

这样子我们就完成了对于点权的转移计算。

Q.E.D.

最终的时间复杂度是 $\mathcal O(n ^ 3)$。当然我们也可以通过深度来优化 $i,j$ 的枚举值域，感兴趣的朋友可以自己去研究一下，我不在此做过多讲解。

### code
```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <math.h>
#include <cstring>
#define int long long
using namespace std;
const int N = 3e2 + 5;
int n, u, v, w[N], f[N][2][N][N];
vector <int> e[N];
void dfs(int x, int last)
{
	for(int i = 0;i < n;i++)
		for(int j = 0;j < n;j++)
			f[x][0][i][j] = (i + 1) * w[x], f[x][1][i][j] = (j + 1) * w[x];
	for(int i = 0;i < e[x].size();i++)
	{
		int y = e[x][i];
		if(y == last)
			continue;
		dfs(y, x);
		for(int j = 0;j < n;j++)
		{
			for(int k = 0;k < n;k++)
			{
				f[x][0][j][k] += max(f[y][0][j+1][k], f[y][1][j][k]);
				f[x][1][j][k] += max(f[y][0][j][k], f[y][1][j][k+1]);
			}
		}
	}
	return ;
}
signed main()
{
	scanf("%lld", &n);
	for(int i = 1;i < n;i++)
	{
		scanf("%lld %lld", &u, &v);
		e[u].push_back(v);
		e[v].push_back(u);
	}
	for(int i = 1;i <= n;i++)
		scanf("%lld", &w[i]);
	dfs(1, 0);
	printf("%lld", max(f[1][0][0][0], f[1][1][0][0]));
	return 0;
}
```

---

## 作者：_JF_ (赞：6)

## [DMOI R2] 暗号 官方题解

#### 题目简述

给一棵 $n$ 个节点的树，每个节点有一个权值。要求给这 $n$ 个节点黑白染色。两个拥有相同颜色的节点中，深度较小的结点的权值加上子树中颜色与它相等的节点初始值。

（题解直接用染色代替暗号）

#### 思路

#### subtask 1

可以直接 $O(2^n)$ 枚举每个点的颜色，然后遍历整棵树，求出当前整棵树的权值和，最后取最大值。时间复杂度为 $O(n2^n)$。

#### subtask 2

预期时间复杂度 $O(n2^{\frac{n}{2}+1})$ 或 $O(n^4)$，未确定具体算法。

#### subtask 3

对于一条链的情况，我们可以把它当作一维染色前缀和问题来解决。未确定算法，预计时间复杂度 $O(nlogn) \sim O(n^3)$

#### subtask 4

我们发现权值没有负数，那将整棵树染上相同的颜色即可，$O(n)$ 计算最终答案。

#### subtask 5

对于菊花图，我们将根节点染上黑色，对于其他节点，如果是负数点权，染上白色，否则染上黑色。预计时间复杂度 $O(n)$。

#### subtask 6

我们来考虑正解。这里我们可以发现思路应该往树形 dp 上靠。

我们用 $0$ 代表黑色，用 $1$ 代表白色。

我们从下往上开始进行 dp。我们设 $f_{i,j,k,c}$ 为将节点 $i$ 染成颜色 $c$，且 $i$ 到根的路径上有 $j$ 组连续两个染黑色的点，$k$ 组连续染白色的点，$i$ 的子树对答案的贡献。

那么我们有如下的状态转移方程：
$$
f_{u,j,k,0}=\sum_{v\in son_u}\max(f_{v,j,k,1},f_{v,j+1,k,0})+(j+1)w_u\\
f_{u,j,k,1}=\sum_{v\in son_u}\max(f_{v,j,k,0},f_{v,j,k+1,1})+(k+1)w_u
$$
具体来说，如果点 $u$ 染成了黑色，其子节点 $v$ 也为黑色，那么该子节点对子树 $i$ 的贡献为 $f_{v,j+1,k,0}$，如果子节点 $v$ 为白色，那么该子节点对子树 $i$ 的贡献为 $f_{v,j,k,1}$。如果点 $u$ 染成了白色，其子节点 $v$ 也为白色，那么该子节点对子树 $i$ 的贡献为 $f_{v,j,k+1,1}$，如果子节点 $v$ 为黑色，那么该子节点对子树 $i$ 的贡献为 $f_{v,j,k,0}$。则点 $u$ 对答案的贡献为其所有子节点对 $u$ 的贡献加上自己的贡献。我们从下往上 dp，最终答案为 $\max(f_{1,0,0,0},f_{1,0,0,1})$。

## 解题代码

```cpp
#include<cstdio>
typedef long long ll;
inline int read(){
	int x=0;
	int ch=getchar(),f=0;
	while(ch<48||ch>57) f=(ch=='-'),ch=getchar();
	while(ch>47&&ch<58) x=(x<<3)+(x<<1)+(ch&15),ch=getchar();
	return f?-x:x;
}
const int N=505;
int n;
struct node{
	int to,nxt;
}e[N<<1];
int head[N],cnt;
inline void add(int u,int v){
	e[++cnt].to=v;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}
int dep[N];
int s[N],w[N];
inline void dfs1(int u,int f){
	dep[u]=dep[f]+1;
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v==f) continue;
		dfs1(v,u);
	}
}
int f[N][N][N][2];
inline int max(int x,int y){return x>y?x:y;}
inline void dfs2(int u,int fa){
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v==fa) continue;
		dfs2(v,u);
		for(int j=0;j<dep[u];++j){
			for(int k=0;k<dep[u]-j;++k){
				f[u][j][k][0]+=max(f[v][j][k][1],f[v][j+1][k][0]);
				f[u][j][k][1]+=max(f[v][j][k][0],f[v][j][k+1][1]);
			}
		}
	}
	for(int j=0;j<dep[u];++j){
		for(int k=0;k<dep[u]-j;++k){
			f[u][j][k][0]+=(j+1)*w[u];
			f[u][j][k][1]+=(k+1)*w[u];
		}
	}
}
int main(){
	n=read();
	for(int i=1,u,v;i<n;++i){
		u=read(),v=read();
		add(u,v);
		add(v,u);
	}
	dfs1(1,0);
	for(int i=1;i<=n;++i) w[i]=read();
	dfs2(1,0);
	printf("%d\n",max(f[1][0][0][0],f[1][0][0][1]));
	return 0;
}
```

---

## 作者：Z_kazuha (赞：0)

[暗号](https://www.luogu.com.cn/problem/P8916)

一开始注意到这里累加贡献需要子树的每个点的颜色状态，有后效性。

有后效性就把他放进状态里……

但这也不能状压啊。

那就反过来，不算每个子树内的答案，而是算每个点对答案的贡献。

发现每次节点所在的子树的根与节点是一个颜色时就会对答案有 1 的贡献。

所以，状态为 $f_{x,0,j,k}$ 这个点为 0/1 色，他向上有 j 次黑色合并，k 次白色合并。

枚举每个子节点选白还是选黑。

$f_{u,0,j,k}=\sum \max(f_{v,0,j+1,k},f_{y,1,j,k})$

$f_{u,1,j,k}=\sum \max(f_{v,0,j,k},f_{y,1,j,k+1})$

初始化：$f_{u,0,j,k}=w[u] \times (j+1)$ , $f_{u,1,j,k}=w[u] \times (k+1)$

```
#include <bits/stdc++.h>
using namespace std;
const int N=305;
int n,cnt,head[N<<1],w[N],f[N][2][N][N];
struct node{int to,nxt;}e[N<<1];
void add(int u,int v){
	e[++cnt].to=v;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}
void dfs(int u,int fa){
	for(int j=0;j<n;j++){
		for(int k=0;k<n;k++){
			f[u][0][j][k]=w[u]*(j+1);
			f[u][1][j][k]=w[u]*(k+1);
		}
	}
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v==fa)continue;
		dfs(v,u);
		for(int j=0;j<n;j++){
			for(int k=0;k<n;k++){
				f[u][0][j][k]+=max(f[v][0][j+1][k],f[v][1][j][k]);
				f[u][1][j][k]+=max(f[v][0][j][k],f[v][1][j][k+1]);
			}
		}
	}
}
int main(){
	cin>>n;
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		add(u,v),add(v,u);
	}
	for(int i=1;i<=n;i++)cin>>w[i];
	dfs(1,0);
	cout<<max(f[1][0][0][0],f[1][1][0][0]);
	return 0;
}
```

---

## 作者：alex_liu (赞：0)

发现题意是由树底至树根进行转移，最后的答案是全局最大和，可以考虑树形 dp。

转移的信息显然是一个子树对全局的最大贡献，而产生贡献的条件是节点到根的路径上相邻节点的颜色相同的对数，而 $n$ 的范围很小，可以直接设到状态里面。

设 $f[i][j][k][0/1]$ 表示节点 $i$ 到根路径上有 $j$ 对相邻的白色点，有 $k$ 对相邻的黑色点，节点 $i$ 染成白色/黑色，此时以 $i$ 为根的子树对全局答案产生的最大贡献。

枚举 $j,k$，设 $v$ 为 $u$ 的儿子，则有状态转移方程：

$$f[u][j][k][0]=\sum\max(f[v][j+1][k][0],f[v][j][k][1])+a_u\times(j+1)$$
$$f[u][j][k][1]=\sum\max(f[v][j][k+1][1],f[v][j][k][0])+a_u\times(k+1)$$

最后答案为 $\max(f[1][0][0][0],f[1][0][0][1])$。

---


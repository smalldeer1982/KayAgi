# [福建省队集训2019] 最大权独立集问题

## 题目描述

E.Space 喜欢出最大权独立集问题。

接下来，他还想出 $n$ 道最大权独立集问题。

E.Space 有 $n$ 个 AI，编号为 $1\sim n$。

开始第 $i$ 个 AI 里面存有一道 E.Space 事先出好的一道难度为 $d_i$ 的最大权独立集问题。

有些 AI 之间可以互相通信，对于所有的 $2 \le i \le n$，第 $i$ 个 AI 可以和第 $c_i$ 个 AI 互相通信。此外，其他对 AI 不可以互相通信。

E.Space 每次可以选择一个存有一道最大权独立集问题的 AI，把存在里面的题出出来，然后清除存在这个 AI 里的题。

在 E.Space 出题之后清除题目之前，AI 会把这道题发给能和它通信的所有 AI。

如果一个收到这道题的 AI 中已经存有一道最大权独立集问题，那么这个 AI 会把这个收到的题和原本存有的题结合起来，变成一道新的最大权独立集问题存起来。形式化地，如果这个 AI 原来存了一道难度为 $x$ 的最大权独立集问题，接着收到了一道难度为 $y$ 的最大权独立集问题，那么结合之后是一道难度为 $x+y$ 的最大权独立集问题。

如果一个收到题的 AI 中未存有题，那么这个 AI 会销毁收到的这个信息。

由于出题人的丧病心理，E.Space 想要出出来的 $n$ 道最大权独立集问题的难度之和尽量大。

他想叫你帮他解决这个问题，还说如果你成功在这场训练中解决了这个问题，那么在出那 $n$ 道最大权独立集问题的时候，他会在训练结束前 10 分钟切换至你的账号然后提交一份标程代码。

## 说明/提示

### 【样例解释 1】

一种最优的出题方案如下：

1. 出第 $2$ 个 AI 中的最大权独立集问题，此时该题难度为 $10$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $11,*,13,5$ ($*$ 表示该 AI 中没有最大权独立集问题，下同)。

2. 出第 $3$ 个 AI 中的最大权独立集问题，此时该题难度为 $13$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $11,*,*,18$。

3. 出第 $1$ 个 AI 中的最大权独立集问题，此时该题难度为 $11$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $*,*,*,18$。

4. 出第 $4$ 个 AI 中的最大权独立集问题，此时该题难度为 $18$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $*,*,*,*$。

所以 $4$ 道题的难度之和为 $10+13+11+18=52$。

### 【样例解释 2】

一种最优的出题方案如下：

1. 出第 $3$ 个 AI 中的最大权独立集问题，此时该题难度为 $5$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $1,3,*,5$。

2. 出第 $4$ 个 AI 中的最大权独立集问题，此时该题难度为 $5$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $1,8,*,*$。

3. 出第 $2$ 个 AI 中的最大权独立集问题，此时该题难度为 $8$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $9,*,*,*$。

4. 出第 $1$ 个 AI 中的最大权独立集问题，此时该题难度为 $9$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $*,*,*,*$。

所以 $4$ 道题的难度之和为 $5+5+8+9=27$。

### 【数据范围】

保证 $\left|d_i\right| \le 10^9$，$1 \le c_i \lt i$，$1\le n \le 400$。

**本题采用捆绑测试。**

对于编号为奇数的子任务，保证 $d_i \ge 0$。

子任务 $1,2$（$11 \times 2 = 22$ 分）：
$n \le 9$。

子任务 $3,4$（$10 \times 2 = 20$ 分）：
$n \le 19$。

子任务 $5,6$（$7 \times 2 = 14$ 分）：
$n \le 50$，$c_i = i-1$。

子任务 $7,8$（$10 \times 2 = 20$ 分）：
$c_i=i-1$。

子任务 $9,10$（$5 \times 2 = 10$ 分）：
$n \le 50$。

子任务 $11,12$（$7 \times 2 = 14$ 分）：
无特殊限制。

### 后记

听说 E.Space 的最大权独立集问题的难度是取了对数的？

听说 E.Space 要把这 $n$ 道题结合成一道题出出来？

听说 E.Space 不会把这些题出在训练里面？



## 样例 #1

### 输入

```
4
1 10 3 5
1 2 3
```

### 输出

```
52
```

## 样例 #2

### 输入

```
4
1 -2 5 5
1 2 2
```

### 输出

```
27
```

# 题解

## 作者：Llx2022 (赞：2)

[P9111 [福建省队集训2019] 最大权独立集问题](https://www.luogu.com.cn/problem/P9111)

## **题意**

给定一颗 $n$ 点的树，点有权值 $d_i$。

有操作：

- 选择一个点 $u$，对于该点所有连边**且之前未被选择过的点** $v$，使得 $d_v\leftarrow d_v+d_u$，然后该点删除，对答案贡献 $d_u$。

确定选择顺序，求 $\max \sum_{i=1}^n d_u$。

注意：对于每次操作 $d_i$ 都继承新的权值 $d_i+x$。其实就是不区分 $d_i$ 和 $d_i'$，即 $d_i$ 每次都是最新的值。

数据范围：保证 $\left|d_i\right| \le 10^9$，$1 \le c_i \lt i$，$1\le n \le 400$。

## **思路**

首先若一个点被选择后，那么他的贡献会具有**传递性**，传递给之后所有还未被选择的点。

那么设 $t_u$ 为点 $u$ 被选择的时间，若 $t_u<t_v$ 我们连 $u\rightarrow v$ 即代表着权值 $d_u$ 流向 $d_v$，注意这里的 $d_u$ 可能也继承着别的点流向 $u$ 的 $d_i$。

**此题因此转化为给每条边定向求得最大权值。**

那我们考虑**拆贡献**，分别考虑每个 $d_i$ 对答案的贡献的数量，那么答案即为 $ans=\sum_{i=1}^n d_i\times cnt_i$，$d$ 为点权，$cnt$ 为点权的贡献次数。

那我们考虑树形 dp 求得答案。

设 $f_{u,i,j}$ 代表已经考虑完点 $u$ 子树内的贡献，**能到**的点有 $i$ 个，其中在其子树（包含自己）内的点有 $j$ 个。

请理解这里的**能到**并非单指连向的边，而是能通过有向边传递到的点的个数。这也正是区别于其他树形 dp 特殊的地方。

初始 $f_{u,i,1}=d_u$，请注意这里的 $i-1$ 个额外贡献还未算入其内，我们在转移的时候更新。

那么我们考虑 $u$ 与 $v$ 的边的方向。

若 $u\rightarrow v$，那么 $f_{u,i,j+k}\stackrel{max}{\longleftarrow}  f_{u,i,j}+f_{v,k,k}+k\times d_u$。

对于该种情况我们发现点 $v$ 的贡献只能流向它的子树中，不会有额外的贡献，因此我们分析得知我们每次定向都会影响点 $v$ 的流量，因此我们要枚举点 $v$ 的指出数量 $k$，将贡献加入其中，即 $f_{v,k,k}+k\times d_u$。

**这个图 $v$ 点不一定都是指出啊，也有可能是 $v$ 的儿子指入。**

![](https://cdn.luogu.com.cn/upload/image_hosting/q340ck71.png)

若 $u\leftarrow v$，那么 $f_{u,i,j} \stackrel{max}{\longleftarrow}f_{u,i,j}+f_{v,i+k,k}$。

这种情况同理，图就不画了。这种情况下，$v$ 的贡献也会同时向外流出 $i\times d_v$，因此是 $f_{v,i+k,k}$。

$f_{u,i,j}=f_{u,i,j}+(i-j)\times d_u$ 这里就是类似于费用提前计算的思想将额外 $(i-j) \times d_u$ 的贡献加入其内。

强调：

- 注意转移不能有后效性，必须得从上一个的去更新，因此就是得临时存一下 $f_{u,i,j}$ 放到 $tmp_{i,j}$。

- 还有对于 $f$ 要初始化为极小值，因为 $\left|d_i\right| \le 10^9$。

时间复杂度为 $O(n^3)$ 易分析。

## **CODE**

```cpp
#include<iostream>
#include<vector>
#define int long long
using namespace std;
template<typename T>inline void read(T &x){
    x=0;T f=1;char ch=getchar();
    while(ch<48||ch>57){if(ch=='-'){f=-1;}ch=getchar();}
    while(ch>=48&&ch<=57){x=x*10+ch-48;ch=getchar();}
    x*=f;
}
template<typename T>inline void write(T x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+48);
}
const int N=408;
int d[N],c[N];
int n,ans;
vector<int> G[N];
int f[N][N][N];
int sz[N];
int tmp[N][N];
void dfs(int u,int fa){
    sz[u]=1;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            f[u][i][j]=-1e18;
        }
    }
    for(int i=1;i<=n;i++){
        f[u][i][1]=d[u];
    }
    for(auto v:G[u]){
        if(v==fa) continue;
        dfs(v,u);
        for(int i=1;i<=n;i++){
            for(int j=1;j<=sz[u]&&j<=i;j++){
                tmp[i][j]=f[u][i][j];
                f[u][i][j]=-1e18;
            }
        }
        for(int i=1;i<=n;i++){
            for(int j=1;j<=sz[u]&&j<=i;j++){
                for(int k=1;k<=sz[v]&&j+k<=i;k++){
                    f[u][i][j+k]=max(f[u][i][j+k],tmp[i][j]+f[v][k][k]+k*d[u]);
                }
                for(int k=1;k<=sz[v];k++){
                    f[u][i][j]=max(f[u][i][j],tmp[i][j]+f[v][i+k][k]);
                }
            }
        }
        sz[u]+=sz[v];
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=sz[u]&&j<=i;j++){
            f[u][i][j]+=d[u]*(i-j);
        }
    }

signed main(){
    read(n);
    for(int i=1;i<=n;i++){
        read(d[i]);
    }
    for(int i=2;i<=n;i++){
        read(c[i]);
        G[c[i]].push_back(i);
        G[i].push_back(c[i]);
    }
    dfs(1,0);
    ans=-1e18;
    for(int i=1;i<=n;i++){
        ans=max(ans,f[1][i][i]);
    }
    write(ans);
    return 0;
}
```

---

## 作者：Elma_ (赞：2)

考虑把贡献拆开，即计算每个点对答案的贡献。

设删除点 $u$ 的时间是 $t_u$。对于一条连接 $u,v$ 的边，若 $t_u < t_v$，我们把它定向为 $u \to v$，否则定向为 $v \to u$。容易发现，这样定向之后，$d_u$ 会流向所有其可达的点。因此可以对题意做如下转化：给树上的每条边定向，设点 $i$ 可以到达包括 $i$ 在内的 $k_i$ 个点，最大化 $\sum\limits_{i=1}^n k_i \times d_i$ 的值。

考虑树形 DP。我们发现，对于当前 DP 的点 $u$ 和它的一个儿子 $v$ 而言，如果定向为 $u \to v$，额外的贡献是好计算的，我们只需要在状态中记录下 $v$ 可达的点数。但定向为 $v \to u$ 时，事情就没有那么简单了：$v$ 额外的贡献取决于 $u$ 能够到达多少个点，但在合并完其它子树之前，我们其实并不知道这个确切的值。

注意到，本题的时间复杂度允许我们在背包之外再乘一个 $\mathcal{O}(n)$，我们不妨枚举这个值为 $k$ 并将其计入状态，即假设合并完之后 $u$ 能够到达 $k$ 个点，用这个 $k$ 来提前计算 $v$ 的额外贡献。具体来说，我们设 $f_{u,i,k}$ 为考虑完 $u$ 的子树，$u$ 可达 $i$ 个点，$v$ 的额外贡献按照 $k$ 来计算时，子树内答案的最大值。初始值 $f_{u,1,k} = d_u$，转移枚举 $k$，考虑边 $(u,v)$ 的方向：

- 方向为 $u \to v$：$v$ 对 $u$ 没有额外的贡献，枚举 $v$ 可达的点数 $j$，有 $f_{u,i,k}+f_{v,j,j}+ d_u \times j \to f_{u,i+j,k}$。
- 方向为 $v \to u$：$v$ 对 $u$ 有额外 $k$ 的贡献，枚举 $v$ 可达的点数 $j$，有 $f_{u,i,k} + f_{v,j,j+k} \to f_{u,i,k}$。

转移完之后我们需要补上 $u$ 的额外贡献，即 $f_{u,i,k} + d_u \times (k-i) \to f_{u,i,k}$。最后的答案即为 $\max f_{1,i,i}$。

总时间复杂度 $\mathcal{O}(n^3)$。代码实现细节略有不同。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
constexpr int N = 4e2 + 5;
int n, a[N], c[N], sz[N];
LL f[N][N][N], g[N][N][N];
vector <int> e[N];
void dfs(int u) {
	sz[u] = 1;
	for (int k = 1; k <= n; k++) for (int i = 1; i <= n; i++) f[u][i][k] = -1e18;  
	for (int k = 1; k <= n; k++) f[u][1][k] = 1LL * a[u] * k;
	for (auto v : e[u]) {
		dfs(v);
		static LL tmp[N][N];
		for (int k = 1; k <= n; k++) for (int i = 1; i <= sz[u]; i++) tmp[i][k] = f[u][i][k], f[u][i][k] = -1e18;
		for (int k = 1; k <= n; k++) {
			for (int i = 1; i <= sz[u]; i++) {
				for (int j = 1; j <= sz[v]; j++) {
					f[u][i + j][k] = max(f[u][i + j][k], tmp[i][k] + f[v][j][j]);
				}
				LL val = -1e18;
				for (int j = 1; j <= min(sz[v], n - k); j++) val = max(val, f[v][j][j + k]);
				f[u][i][k] = max(f[u][i][k], tmp[i][k] + val);	
			}
		} 
		sz[u] += sz[v];
	}
}
signed main() {
	ios :: sync_with_stdio(false);
	cin.tie(nullptr);
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i];
	for (int i = 2; i <= n; i++) {
		cin >> c[i];
		e[c[i]].push_back(i);
	}
	dfs(1);
	LL ans = -1e18;
	for (int i = 1; i <= n; i++) ans = max(ans, f[1][i][i]);
	cout << ans << "\n";
 	return 0;
}
```



---

## 作者：Leasier (赞：1)

- **涉及图上删点 / 边顺序的问题可以考虑给边定向来表示顺序——毕竟我们不需要计数。**

考虑按删点顺序给边定向，即 $u \to v$ 当且仅当 $u$ 先于 $v$ 删除。

此时难度之和为 $\displaystyle\sum_{i = 1}^n d_i cnt_i$，其中 $cnt_i$ 表示 $i$ 可达点数。

考虑随意钦定根开始 dp，设 $f_{u, i}$ 表示定向 $fa_u \to u$、$u$ 子树内可达点个数为 $i$ 的子树内贡献的最大值，$g_{u, i}$ 表示定向 $u \to fa_u$、$u$ 子树外可达点个数为 $i$ 的子树内贡献的最大值。

那我们在转移时关心什么信息呢？

- 考虑一个点 $u \neq r$，其中 $r$ 为我们钦定的根。
- 若定向 $fa_u \to u$，则 $u$ 可达点皆位于 $u$ 子树内。
- 若定向 $u \to fa_u$，则 $u$ 在子树内外皆有可达点，但 $u$ 子树外的点不可达 $u$。

于是我们同时关心 $u$ 在子树内外可达点数。

遂考虑设 $h_{u, i, j}$ 表示当前 $u$ 子树内可达点个数为 $i$、$u$ 子树内外可达点总数为 $j$ 的最大值。

初值：$h_{u, 1, i} = i d_u$。

转移分为两种情况：

- 加入一个定向 $u \to v$ 的儿子：此时 $h'_{u, i + k, j} \leftarrow \max(h'_{u, i + k, j}, h_{u, i, j} + f_{v, k})$。
- 加入一个定向 $v \to u$ 的儿子：此时 $h'_{u, i, j} \leftarrow \max(h'_{u, i, j}, h_{u, i, j} + g_{v, j})$。

最后令 $f_{u, i} = h_{u, i, i}$，$g_{u, i} = \displaystyle\max_{j = 1}^{size_u - i} h_{u, j, i + j}$ 即可。

答案：$\displaystyle\max_{i = 1}^n f_{r, i}$，这里我们相当于钦定定向 $fa_r \to r$。

时间复杂度为 $O(n^3)$。

代码：
```cpp
#include <stdio.h>

typedef long long ll;

typedef struct {
	int nxt;
	int end;
} Edge;

int cnt = 0;
int d[407], head[407], size[407];
ll dp1[407][407], dp2[407][407], temp1[407][407], temp2[407][407];
Edge edge[407];

inline void add_edge(int start, int end){
	cnt++;
	edge[cnt].nxt = head[start];
	head[start] = cnt;
	edge[cnt].end = end;
}

inline ll max(ll a, ll b){
	return a > b ? a : b;
}

int main(){
	int n;
	ll ans = 0x8000000000000000ll;
	scanf("%d", &n);
	for (int i = 1; i <= n; i++){
		scanf("%d", &d[i]);
	}
	for (int i = 2; i <= n; i++){
		int c;
		scanf("%d", &c);
		add_edge(c, i);
	}
	for (int i = n; i >= 1; i--){
		size[i] = 1;
		for (int j = 1; j <= n; j++){
			temp1[1][j] = (ll)j * d[i];
		}
		for (int j = head[i]; j != 0; j = edge[j].nxt){
			int x = edge[j].end, t = size[i] + size[x];
			for (int k = 1; k <= t; k++){
				for (int l = 1; l <= n; l++){
					temp2[k][l] = -9e18;
				}
			}
			for (int k = 1; k <= size[i]; k++){
				for (int l = k + 1; l <= n; l++){
					for (int y = 1; y <= size[x] && k + y <= l; y++){
						temp2[k + y][l] = max(temp2[k + y][l], temp1[k][l] + dp1[x][y]);
					}
				}
			}
			for (int k = 1; k <= size[i]; k++){
				for (int l = k; l <= n; l++){
					temp2[k][l] = max(temp2[k][l], temp1[k][l] + dp2[x][l]);
				}
			}
			size[i] = t;
			for (int k = 1; k <= t; k++){
				for (int l = 1; l <= n; l++){
					temp1[k][l] = temp2[k][l];
				}
			}
		}
		for (int j = 1; j <= size[i]; j++){
			dp1[i][j] = temp1[j][j];
		}
		for (int j = 1; j <= n; j++){
			dp2[i][j] = -9e18;
			for (int k = 1; k <= size[i] && j + k <= n; k++){
				dp2[i][j] = max(dp2[i][j], temp1[k][j + k]);
			}
		}
	}
	for (int i = 1; i <= n; i++){
		ans = max(ans, dp1[1][i]);
	}
	printf("%lld", ans);
	return 0;
}
```

---

## 作者：Eric1230 (赞：0)

## Statement（转化）

> 给一颗 $n$ 个点的无向树，有点权 $a_1, a_2, \dots, a_n$。现在希望你将这些边定向，使得最大化 $\displaystyle \sum_{i=1}^n a_i b_i$，其中 $b_i$ 表示 $i$ 能到达点的个数。$n \le 400$。

## Solution

$f_{i, j, k}$ 表示 $i$ 能到 $j$ 个 $\text{subtree}(i)$ 内的点，$k$ 个 $\text{subtree}(i)$ 外的点时，$\displaystyle \sum_{x \in \text{subtree}(i)\setminus \{i\}} a_x b_x$ 的最大值。

转移方式采用泛化物品的合并。设 $v$ 是 $u$ 的儿子，我们枚举边 $(u, v)$ 的方向：

- 若 $u \to v$，则 $f_{v, i, 0} + i \cdot a_v + f_{u, j, k} \overset{\max}{\to} f_{u, i + j, k}$。

- 若 $v \to u$，则 $f_{v, i, j} + (i + j) \cdot a_v + f_{u, j - k, k} \overset{\max}{\to} f_{u, j - k, k}$。

最终答案为 $\displaystyle \max_{i=1}^n f_{1, i, 0} + i \cdot a_1$。总时间复杂度 $O(n ^ 3)$。

---

## 作者：LinkyChristian (赞：0)

首先考虑一个点被删之后，会向周围所有没有被删的点贡献。考虑一个点在被删掉的时候向周围所有没有被删的点连有向边，于是我们的操作相当于给边定向，每个点被贡献的次数就是它能到达的点的点数。

很显然的一个思路是背包。但这是我们发现一个点在自己子树之外的贡献不太好算。看到数据范围很小，于是可以采用一个经典思路：预贡献。我们将贡献拆成两部分，一部分是已经贡献的，一部分是还没有贡献的。然后在这个点统计结束的时候将其预先贡献部分的贡献先算上。

状态 $dp_{i,j,k}$ 表示在点 $i$ 的子树内选了 $j$ 个点，预计还要选 $k$ 个点的最大贡献。设当前点为 $u$, 枚举儿子 $v$，能列出以下转移式子：

边从 $u$ 指向 $v$：

$$
f_{u,i,k}+f_{v,j,0} \rightarrow f_{u,j,k-j} 
$$

边从 $v$ 指向 $u$：

$$
f_{u,i,k}+\max\limits_{j=1}^{siz_v} f_{v,j,k+i} \rightarrow f_{u,j,k} 
$$

按转移式 dp 即可。



---


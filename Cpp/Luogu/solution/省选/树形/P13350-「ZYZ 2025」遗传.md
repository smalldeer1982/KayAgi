# 「ZYZ 2025」遗传

## 题目背景

唉，转生竞吧！

## 题目描述

**如果你不了解生物的遗传学知识，可以阅读以下部分：**

> 每个生物 M 都有两个属性，记属性一为 $X\in\{A,a\}$，属性二为 $Y\in\{A,a\}$，称 $XY$ 为其**基因型**，包括 $AA,Aa,aa$ 三种，这里认为 $Aa$ 和 $aA$ 等价。
>
> 对于生物 M 可患的遗传病 I，若 I 为**隐性遗传病**，则该生物患病当且仅当其基因型为 $aa$，若 I 为**显性遗传病**，则该生物患病当且仅当其基因型为 $Aa$ 或 $AA$。
>
> 若基因型为 $X_1Y_1$ 和 $X_2Y_2$ 的生物交配，则其后代的基因型有四种情况：$X_1X_2,X_1Y_2,Y_1X_2,Y_1Y_2$，且每种情况的概率相同，均为 $\dfrac{1}{4}$。
>
> 若 $A$ 的**基因频率**为 $p$，则认为在没有其他条件的影响下（在本题中“其他条件”包括“知道其父母”），一个生物 M 的两个属性各自有 $p$ 的概率为 $A$，$1-p$ 的概率为 $a$，且相互独立。
>
> 现在有一种生物 M 可患的遗传病 I，已知其是显性还是隐性，$A$ 的基因频率为 $p$。

**否则，你可以阅读以下部分：**

> 现在有一种和生物 M 有关的遗传病 I，已知其是显性还是隐性，其受一对常染色体等位基因 $(A,a)$ 控制，该基因的遗传符合孟德尔遗传规律，不考虑基因突变、染色体变异，交叉互换等特殊情况。
>
> **已知** $A$ 的基因频率是 $p$，即认为在没有其他条件的影响下（在本题中“其他条件”包括“知道其父母”），一个生物 M 的两个基因各自有 $p$ 的概率为 $A$，$1-p$ 的概率为 $a$，且相互独立。

现在有 $n$ 个生物 M，第 $i$ 个生物的父亲为 $fa_i$，母亲为 $mo_i$，若 $fa_i=0$ 或 $mo_i=0$ 则表示父亲或母亲未知。为了简化问题，保证 $fa_i$ 和 $mo_i$ 要么**均为** $0$，要么**均不为** $0$，且**恰有一个**生物 M 没有孩子，其余生物 M **恰有一个孩子**。

给出 $n$ 个生物的关系，已知部分生物的患病情况，你需要分别求出每一个生物基因型为 $AA,Aa,aa$ 的概率，对 $10^9+7$ 取模。

你可以参见样例解释以更好的理解这个题目。

**保证数据合法且保证数据随机生成**。

## 说明/提示

**【样例解释】**

记第 $i$ 个生物为 $M_i$，其基因型为 $S_i$。由于 $M_2$ 患隐性遗传病，所以 $S_2=aa$ 且 $M_3$ 含有基因（属性）$a$。又因为 $M_3$ 不患病，所以 $S_3=Aa$。

因为 $M_1$ 和患病的 $M_2$ 生出不患病的 $M_3$，所以 $M_1$ 一定不患病。因为 $p=\dfrac12$，所以对于一个随机的不患病的个体，其基因型为 $AA$ 和 $Aa$ 的概率之比为：

$$\left(\dfrac12\times\dfrac12\right):\left(2\times\dfrac12\times(1-\dfrac12)\right)=1:2$$

又因为基因型为 $AA$ 和 $aa$ 的个体生出 $Aa$ 个体的概率为 $1$，基因型为 $Aa$ 和 $aa$ 的个体生出 $Aa$ 个体的概率为 $\dfrac12$，所以 $S_1$ 为 $AA$ 和 $Aa$ 的概率之比为：

$$\left(\dfrac13\times1\right):\left(\dfrac23\times\dfrac12\right)=1:1$$

所以 $S_1$ 为 $AA$ 和 $Aa$ 的概率相同，均为 $\dfrac12$。

**【数据范围】**

**本题采用捆绑测试。**

|子任务编号|特殊性质|分值|
|:-:|:-:|:-:|
|$0$|$n\leq5$|$15$|
|$1$|任意 $i\in[1,n]$ 满足 $k_i=2$|$15$|
|$2$|$n\leq 5\times 10^3$|$30$|
|$3$|无|$40$|

对于 $100\%$ 的测试数据，保证：$1\leq fa_i,mo_i\leq n \leq10^5$，$t\in\{0,1\}$，$1\leq a< b\leq 10^9$，$k_i\in\{0,1,2\}$，**保证数据随机生成**。

## 样例 #1

### 输入

```
3 0 1 2
2 0 0
0 0 0
1 1 2```

### 输出

```
500000004 500000004 0
0 0 1
0 1 0```

# 题解

## 作者：Aurie (赞：4)

# 「ZYZ 2025」遗传 【题解】

感觉可以称作灵活运用条件概率的典题。

先根据问题建出图，从父母向子代建一条有向边，发现最终图会成为一棵二叉内向树，为了遍历树更方便，不妨从子代向父母建边，建成外向树。对于显性疾病，把有病的当作没病，没病的当作有病后等价于隐性疾病，因此只考虑隐性疾病即可。

如果从子代向父母倒推每个生物的基因型可能是什么是极其困难的，那不妨从整体角度考虑这个问题。把 $k$ 数组对生物患病情况的限制看作一个大条件，那么这个问题就是一个条件概率，记该条件为事件 $B$。现在记第 $i$ 个生物基因型为 $AA,Aa,aa$ 为事件 $AA_i,Aa_i,aa_i$。那么则需对每个 $i$，求出 $\operatorname{P}(AA_i|B)$，$\operatorname{P}(Aa_i|B)$，$\operatorname{P}(aa_i|B)$ 考虑 $\operatorname{P}(AA_i|B)$ 怎么求，其余同理。

$$\operatorname{P}(AA_i|B) = \dfrac{\operatorname{P}(AA_i\times B)}{\operatorname{P}(B)}$$

分母中的 $B$ 事件可用更形象，更易理解的语言概括，把建出的外向树的每个节点染一下色，患病染为黑色，不患病染为白色，未知状态可以染为任意颜色（不限制），那么 $B$ 事件就是“随机一个图，其颜色和数据给出的颜色一样的概率”。可以设 $dp_{u,AA/Aa/aa}$ 为：$u$ 子树内颜色满足限制，且第 $u$ 个生物为 $AA/Aa/aa$ 的概率。由于图是内向树，$fa_u$ 和 $mo_u$ 没有公共祖先，所以它们的基因型是什么互为独立事件，可直接使用乘法原理和加法原理计算 $dp_{u,AA/Aa/aa}$ 的值。

* 若 $u$ 患病则：$dp_{u,AA} = 0$。

* 否则：$dp_{u,AA}=dp_{fa_u,AA}\times dp_{mo_u,AA} + \dfrac{dp_{fa_u,AA}\times dp_{mo_u,Aa} + dp_{fa_u,Aa}\times dp_{mo_u,AA}}{2} + \dfrac{dp_{fa_u,Aa}\times dp_{mo_u,Aa}}{4}$

其余同理，在回溯时计算即可。计算 $\operatorname{P}(AA_i\times B)$ 的值也是相同的方法，钦定第 $i$ 个生物的基因型只为 $AA$ 就行，$dp_{i,Aa},dp_{i,aa}$ 设成零。

预处理出 $2,4$ 的逆元，条件概率的分母只用算一次，对于每个 $i$ 用 $dp$ 跑分子的时候只更新从 $i$ 到根的那条链，由于数据保证随机生成，总时间复杂度均摊 $O(n\log{n})$。

代码：

```cpp
#include <bits/stdc++.h>
// Modular 模板，可跳过到 67 行。 
template <typename T, const T MOD, typename MultiplicationType>
class Modular {
private:
    T value;
    T exgcd(const T& a, const T& b, T& x, T& y) const {
        if (b == 0) { x = 1, y = 0; return a; }
        T g = exgcd(b, a % b, y, x);
        y -= (MultiplicationType) (a / b) * x % MOD;
        if (y < 0) y += MOD;
        if (y >= MOD) y -= MOD;
        return g;
    }
public:
    Modular(const T& v = 0) : value(v % MOD) { if (value < 0) value += MOD; }
    Modular(const Modular& other) : value(other.value) {}
    Modular& operator=(const Modular& other) { value = other.value; return *this; }
    Modular& operator=(const T& v) { value = v % MOD; if (value < 0) value += MOD; return *this; }
    operator int() const { return static_cast<int>(value); }
    operator long long() const { return static_cast<long long>(value); }
    operator double() const { return static_cast<double>(value); }
    operator float() const { return static_cast<float>(value); }
    operator bool() const { return value != 0; }
    T getVal() const { return value; }
    void setVal(const T& v) { value = v; }
    Modular operator+(const Modular& other) const { T result = value + other.value; if (result >= MOD) { result -= MOD; } return Modular(result); }
    Modular operator-(const Modular& other) const { T result = value - other.value; if (result < 0) { result += MOD; } return Modular(result); }
    Modular operator*(const Modular& other) const { return Modular((MultiplicationType) value * other.value % MOD); }
    Modular& operator+=(const Modular& other) { value += other.value; if (value >= MOD) { value -= MOD; } return *this; }
    Modular& operator-=(const Modular& other) { value -= other.value; if (value < 0) { value += MOD; } return *this; }
    Modular& operator*=(const Modular& other) { value = (MultiplicationType) value * other.value % MOD; return *this; }
    template<typename __Ty>
    Modular fPow(__Ty exp) const {
        Modular result(1), base(value);
        while (exp) {
            if (exp & 1) result *= base;
            base *= base; exp >>= 1;
        }
        return result;
    }
    template<typename __Ty>
    Modular& fPowSelf(__Ty exp) {
        Modular result(1), base(value);
        while (exp) {
            if (exp & 1) result *= base;
            base *= base; exp >>= 1;
        }
        return *this = result;
    }
    Modular inv() const {
        T x, y;
        assert(value);
        T g = exgcd(value, MOD, x, y);
        assert(g == T(1));
        return Modular(x);
    }
    Modular operator/(const Modular& other) const { return *this * other.inv(); }
    Modular& operator/=(const Modular& other) { return *this *= other.inv(); }
    bool operator==(const Modular& other) const { return value == other.value; }
    bool operator!=(const Modular& other) const { return value != other.value; }
    friend std::ostream& operator << (std::ostream& os, const Modular& o) {
    	os << o.getVal();
    	return os;
	}
};
using namespace std;
typedef Modular<int, 1000000007, long long> Int;
const int N = 1e5 + 10;
#define aa 0
#define AA 1
#define Aa 2
#define ILL 0
#define FINE 1
#define UK 2
Int f[N][3], P[N][3], p, isAA, isAa, isaa;
int n, fa[N], mo[N], type[N], root, rd[N];
void init() {
	isAA = p * p;
	isAa = Int(2) * p * (Int(1) - p);
	isaa = (Int(1) - p) * (Int(1) - p);
}
const Int Div4 = Int(4).inv(), Div2 = Int(2).inv();
inline Int PAA(const Int Pf[N][3], const Int Pm[N][3], int u) {
	if (fa[u] == 0 && mo[u] == 0) return isAA;
	return Pf[fa[u]][AA] * Pm[mo[u]][AA] + (Pf[fa[u]][Aa] * Pm[mo[u]][AA] + Pf[fa[u]][AA] * Pm[mo[u]][Aa]) * Div2 + Pf[fa[u]][Aa] * Pm[mo[u]][Aa] * Div4;
}
inline Int PAa(const Int Pf[N][3], const Int Pm[N][3], int u) {
	if (fa[u] == 0 && mo[u] == 0) return isAa;
	return Pf[fa[u]][AA] * Pm[mo[u]][aa] + Pf[fa[u]][aa] * Pm[mo[u]][AA] + (Pf[fa[u]][Aa] * Pm[mo[u]][aa] + Pf[fa[u]][aa] * Pm[mo[u]][Aa] + Pf[fa[u]][Aa] * Pm[mo[u]][AA] + Pf[fa[u]][AA] * Pm[mo[u]][Aa] + Pf[fa[u]][Aa] * Pm[mo[u]][Aa]) * Div2;
}
inline Int Paa(const Int Pf[N][3], const Int Pm[N][3], int u) {
	if (fa[u] == 0 && mo[u] == 0) return isaa;
	return Pf[fa[u]][aa] * Pm[mo[u]][aa] + (Pf[fa[u]][Aa] * Pm[mo[u]][aa] + Pf[fa[u]][aa] * Pm[mo[u]][Aa]) * Div2 + Pf[fa[u]][Aa] * Pm[mo[u]][Aa] * Div4;
}
int son[N];
void precalc(const int u) {
	if (fa[u]) precalc(fa[u]);
	if (mo[u]) precalc(mo[u]);
	son[fa[u]] = u;
	son[mo[u]] = u;
    if (type[u] == UK) {
        f[u][AA] = PAA(f, f, u);
        f[u][Aa] = PAa(f, f, u);
        f[u][aa] = Paa(f, f, u);
    }else if (type[u] == ILL) {
        f[u][AA] = 0;
        f[u][Aa] = 0;
        f[u][aa] = Paa(f, f, u);
    } else {
        f[u][AA] = PAA(f, f, u);
        f[u][Aa] = PAa(f, f, u);
        f[u][aa] = 0;
    }
}
Int calc(int u, int x) {
	if (x == AA) {
		if (type[u] == UK || type[u] == FINE) P[u][AA] = PAA(f, f, u);
		else P[u][AA] = 0;
		P[u][Aa] = 0;
		P[u][aa] = 0;
	} else if (x == Aa) {
		P[u][AA] = 0;
		if (type[u] == UK || type[u] == FINE) P[u][Aa] = PAa(f, f, u);
		else P[u][Aa] = 0;
		P[u][aa] = 0;
	} else {
		P[u][AA] = 0;
		P[u][Aa] = 0;
		if (type[u] == UK || type[u] == ILL) P[u][aa] = Paa(f, f, u);
		else P[u][aa] = 0;
	}
	int last;
	while (son[u]) {
		last = u;
		u = son[u];
		if (type[u] == UK) {
			P[u][AA] = (fa[u] == last ? PAA(P, f, u) : PAA(f, P, u));
			P[u][Aa] = (fa[u] == last ? PAa(P, f, u) : PAa(f, P, u));
			P[u][aa] = (fa[u] == last ? Paa(P, f, u) : Paa(f, P, u));
		}else if (type[u] == ILL) {
			P[u][AA] = 0;
			P[u][Aa] = 0;
			P[u][aa] = (fa[u] == last ? Paa(P, f, u): Paa(f, P, u));
		} else {
			P[u][AA] = (fa[u] == last ? PAA(P, f, u): PAA(f, P, u));
			P[u][Aa] = (fa[u] == last ? PAa(P, f, u): PAa(f, P, u));
			P[u][aa] = 0;
		}
	}
	return P[root][AA] + P[root][Aa] + P[root][aa];
}
int main() {
	int a, b, t;
	cin >> n >> t >> a >> b;
	p = Int(a) / Int(b);
	init();
	for (int i = 1; i <= n; i++) {
		cin >> type[i] >> fa[i] >> mo[i];
		if (type[i] != UK) type[i] ^= t; 
		rd[fa[i]]++;
		rd[mo[i]]++;
	}
	for (int i = 1; i <= n; i++) {
		if (!rd[i]) {
			root = i;
		}
	}
	precalc(root);
	Int B = f[root][AA] + f[root][Aa] + f[root][aa], x, y, z;
	for (int i = 1; i <= n; i++) {
        if (type[i] == FINE) { // 计算部分即可推出剩下的部分，节省时间。 
    		x = calc(i, AA) / B;
    		y = Int(1) - x;
    		z = 0;
        } else if (type[i] == ILL) {
            x = 0;
            y = 0;
            z = 1;
        } else {
    		x = calc(i, AA) / B;
    		y = calc(i, Aa) / B;
    		z = Int(1) - x - y;
        }
		cout << x << ' ' << y << ' ' << z << '\n'; 
	}
	return 0;
}
```

[哥哥，要进来吗 QAQ？](https://github.com/ForAurie/QMath)

---


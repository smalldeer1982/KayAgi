# [HNOI2014] 米特运输

## 题目描述

米特是 D 星球上一种非常神秘的物质，蕴含着巨大的能量。在以米特为主要能源的 D 星上，这种米特能源的运输和储存一直是一个大问题。

D 星上有 $N$ 个城市，我们将其顺序编号为 $1$ 到 $N$，$1$ 号城市为首都。这 $N$ 个城市由 $N-1$ 条单向高速通道连接起来，构成一棵以 $1$ 号城市（首部）为根的树，高速通道的方向由树中的儿子指向父亲。树按深度分层：根结点深度为 $0$，属于第 $1$ 层；根结点的子节点深度为 $1$，属于第 $2$ 层；依此类推，深度为 $i$ 的结点属于第 $i+1$ 层。

建好高速通道之后，D 星人开始考虑如何具体地储存和传输米特资源。由于发展程度不同，每个城市储存米特的能力不尽相同，其中第 $i$ 个城市建有一个容量为 $A_i$ 的米特储存器。这个米特储存器除了具有储存的功能，还具有自动收集米特的能力。

如果到了晚上六点，有某个储存器处于未满的状态，它就会自动收集大气中蕴含的米特能源，在早上六点之前就能收集满；但是，只有在储存器完全空的状态下启动自动收集程序才是安全的，未满而又非空时启动可能有安全隐患。

早上六点到七点间，根节点城市（$1$ 号城市）会将其储存器里的米特消耗殆尽。根节点不会自动搜集米特，它只接受子节点传输来的米特。

早上七点，城市之间启动米特传输过程，传输过程逐层递进：先是第 $2$ 层节点城市向第 $1$ 层（根节点城市，即 $1$ 号城市）传输，直到第 $1$ 层的储存器满或第 $2$ 层的储存器全为空；然后是第 $3$ 层向第 $2$ 层传输，直到对于第 $2$ 层的每个节点，其储存器满或其子节点（位于第 $3$ 层）的储存器全为空；依此类推，直到最后一层传输完成。传输过程一定会在晚上六点前完成。

由于技术原因，运输方案需要满足以下条件：

1. 不能让某个储存器到了晚上六点传输结束时还处于非空但又未满的状态，这个时候储存器仍然会启动自动收集米特的程序，而给已经储存有米特的储存器启动收集程序可能导致危险，也就是说要让储存器到了晚上六点时要么空要么满；

2. 关于首都——即 $1$ 号城市的特殊情况，  每天早上六点到七点间 $1$ 号城市中的米特储存器里的米特会自动被消耗殆尽，即运输方案不需要考虑首都的米特怎么运走；

3. 除了 $1$ 号城市，每个节点必须在其子节点城市向它运输米特之前将这座城市的米特储存器中原本存有的米特全部运出去给父节点，不允许储存器中残存的米特与外来的米特发生混合；

4. 运向某一个城市的若干个来源的米特数量必须完全相同，不然，这些来源不同的米特按不同比例混合之后可能发生危险。

现在 D 星人已经建立好高速通道，每个城市也有了一定储存容量的米特储存器。为了满足上面的限制条件，可能需要重建一些城市中的米特储存器。你可以，也只能，将某一座城市（包括首都）中原来存在的米特储存器摧毁，再新建一座任意容量的新的米特储存器，其容量可以是小数（在输入数据中，储存器原始容量是正整数，但重建后可以是小数），不能是负数或零，使得需要被重建的米特储存器的数目尽量少。

## 说明/提示

【样例解释】

一个最优解是将 $A_1$ 改成 $8$，$A_3$ 改成 $4$，$A_5$ 改成 $2$。这样，$2$ 和 $3$ 运给 $1$ 的量相等，$4$ 和 $5$ 运给 $2$ 的量相等，且每天晚上六点的时候，$1$，$2$ 满，$3$，$4$，$5$ 空，满足所有限制条件。

对于 $100\%$ 的数据满足 $N<500000，A_j<10^8$

## 样例 #1

### 输入

```
5
5
4
3
2
1
1 2
1 3
2 4
2 5```

### 输出

```
3```

# 题解

## 作者：BillYang (赞：32)

题目大意：

给一棵树，每个点有一个权值，要求修改一些点的权值，使得：

①同一个父亲的儿子权值必须相同

②父亲的取值必须是所有儿子权值之和

  
题解：

对于树上任一个点，其权值一旦确定，整棵树的权值即可确定。

例如下图：

![](https://cdn.vijos.org/fs/edcd77a00729ab812d23d310913f869f233d25c5)

从根往下递推，累计路径上的权值，如下图：

![](https://cdn.vijos.org/fs/8a86edc4f233279fb7996cf99fcf6c2cde146906)

将路径上权值的累乘积即为f[i]，f[i]相同的表示他们同属于同一种合法方案（想一想，为什么？），最后sort一遍寻找相同最多的即可。

**注意将所有权值累乘会爆long long，但使用高精度太麻烦，巧妙运用log转为加法。**

  
代码如下：

```cpp
#include<algorithm>
#include<iostream>
#include<iomanip>
#include<cstring>
#include<cstdlib>
#include<vector>
#include<cstdio>
#include<cmath>
#include<queue>
using namespace std;
typedef long long LL;
inline const LL Get_Int() {
    LL num=0,bj=1;
    char x=getchar();
    while(x<'0'||x>'9') {
        if(x=='-')bj=-1;
        x=getchar();
    }
    while(x>='0'&&x<='9') {
        num=num*10+x-'0';
        x=getchar();
    }
    return num*bj;
}
vector<int>edges[500005];
LL n,cnt=1,ans=1;
double a[500005],f[500005];
void AddEdge(int x,int y) {
    edges[x].push_back(y);
}
void Dfs(int Now,double sum) {
    f[Now]=sum+log((double)a[Now]);
    for(int i=0; i<edges[Now].size(); i++) {
        int Next=edges[Now][i];
        Dfs(Next,sum+log((double)edges[Now].size()));
    }
}
int main() {
    n=Get_Int();
    for(int i=1; i<=n; i++)a[i]=Get_Int();
    for(int i=1; i<n; i++) {
        int x=Get_Int(),y=Get_Int();
        AddEdge(x,y);
    }
    Dfs(1,log(1.0));
    sort(f+1,f+n+1);
    for(int i=2; i<=n; i++)
        if(f[i]-f[i-1]<=1e-8) {
            cnt++;
            ans=max(ans,cnt);
        } else cnt=1;
    printf("%lld\n",n-ans);
    return 0;
}
```

---

## 作者：撤云 (赞：11)

### $Describe$

谁出的题目啊?这么长的题面,看完就滚粗了.强烈谴责  
>给一棵树，每个点有一个权值，要求修改一些权值，使：    
1. 一个点的权值必须是其所有儿子的权值之和   
2. 一个点的儿子权值必须相同    
求最少的被修改的数目  

### $Solution$

随便画一画图就可以找到一些显著的规律,只要确定了一个点的权值就可以知道整颗树的值了.

这里就不详细的给出图进行解释了,自己画一画图就可以知道了.

于是我们可以令$val[x]$表示$x$这个点不变的话,根节点的值.

但是将子节点的个数成起来会爆$long\ long$,所以需要运用一点小技巧:$log$

运用公式:$log(a*b)=log(a)*log(b)$

答案就是$n-val$数组中相同个数最多的.


### $Code$


```  cpp
#include<bits/stdc++.h>
using namespace std;
const double eps=1e-6;
int read(){
    int x=0,f=1;char c=getchar();
    while(c<'0'||c>'9') f=(c=='-')?-1:1,c=getchar();
    while(c>='0'&&c<='9') x=x*10+c-'0',c=getchar();
    return x*f;
}
struct node {
    int to,next;
}a[500010<<1];
double val[500010];
int v[500010],head[500010],s[500010],cnt;
void add(int x,int y){
    a[++cnt].next=head[x],a[cnt].to=y,head[x]=cnt;
    a[++cnt].next=head[y],a[cnt].to=x,head[y]=cnt;
}
void dfs(int x,int fa,double ans){
    val[x]=ans+log(v[x]),s[x]--;
    for(int i=head[x];i;i=a[i].next){
    int v=a[i].to;
    if(v==fa)
        continue;
    dfs(v,x,ans+log(s[x]));
    }
}
main(){
    int n=read(),x,y,maxx=0,js=1;
    for(int i=1;i<=n;i++)
    v[i]=read();
    for(int i=1;i<n;i++)
    x=read(),y=read(),add(x,y),s[x]++,s[y]++;
    s[1]++,dfs(1,0,0);
    sort(val+1,val+1+n);
    for(int i=2;i<=n;i++){
    if(val[i]-val[i-1]<eps)
        js++;
    else maxx=max(maxx,js),js=1;
    }
    printf("%d",n-maxx);
}
```

---

## 作者：totorato (赞：7)

# 哈希
### 分析
根据题意我们可以知道，本题的整棵树需要满足如下的性质：

	1.节点x的所有子节点大小必须相等
	2.节点x的所有子节点的容量之和等于x的容量

根据这几两个性质，我们知道，如果我们确定了根节点的容量，整棵树的容量就可以唯一确定。

因此：对于一个节点，若其容量已经确定为a,则其k个子节点的容量都为$\frac{a}{k}$。我们就这样递推每个节点的容量关于根节点容量$a_0$的关系。

最终，每个节点都可以唯一确定$a_x=k_xa_0$

现在，我们只需要确定一个最优的$a_0$使得需要重建的存储器最少，也就是说不变的$a_x$最多。

于是我们反过来考虑每个$a_x$。求：如果$a_x$不变，那么$a_0$是多少，将这个值对应的哈希表中的位$+1$，最终哈希表中最大的值就是最多不变的$a_x$数量。

由于$a_0$一定可以表示为$a_x$的整数倍，所以我们进行整数哈希即可。

问题是我们所求的整数往往很大。所以我们需要对这个整数取模，为了避免重复，我们将整数对多个数取模即可。这样冲突的可能性将很低。

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#define TSIZ 1234567LL
#define MX 1000001
#define D 3

using namespace std;

typedef long long ll;

const ll mod[D]={14233333LL,998244353LL,10000009LL};
int n,w[MX];

ll ksm(ll x,ll t,ll p)
{
	ll ans=1;
	while(t)
	{
		if(t&1)ans=ans*x%p;
		t>>=1;
		x=x*x%p;
	}
	return ans;
}

struct graph
{
	int fst[MX],nxt[MX],v[MX],d[MX],lnum;
	void init(){memset(fst,0xff,sizeof(fst)),lnum=-1;}
	void addeg(int nu,int nv)
	{
		nxt[++lnum]=fst[nu];
		fst[nu]=lnum;
		v[lnum]=nv;
		d[nv]++;
	}
}G;

struct numbr
{
	ll x[D];
	numbr operator * (const ll y){numbr t;for(int i=0;i<D;i++)t.x[i]=x[i]*y%mod[i];return t;}
	bool operator == (const numbr y)const{for(int i=0;i<D;i++)if(x[i]!=y.x[i])return 0;return 1;}
};

struct hasht
{
	numbr real[MX];
	int fst[TSIZ],nxt[MX],cnt[MX],hnum;
	void init(){memset(fst,0xff,sizeof(fst)),hnum=-1;}
	void insert(numbr x,int a)
	{
		ll p=0;
		for(int i=0;i<D;i++)p=(p+x.x[i])%TSIZ;
		for(int i=fst[p];i!=-1;i=nxt[i])
			if(x==real[i])
			{
				cnt[i]+=a;
				return;
			}
		nxt[++hnum]=fst[p];
		fst[p]=hnum;
		cnt[hnum]=a;
		real[hnum]=x;
	}
	int count(numbr x)
	{
		ll p=0;
		for(int i=0;i<D;i++)p=(p+x.x[i])%TSIZ;
		for(int i=fst[p];i!=-1;i=nxt[i])
			if(x==real[i])
				return cnt[i];
		return 0;
	}
}H;

void input()
{
	int a,b;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&w[i]);
	for(int i=1;i<n;i++)
	{
		scanf("%d%d",&a,&b);
		G.addeg(a,b);
		G.addeg(b,a);
	}
}

int ans=MX;
void dfs(int x,int f,numbr now)
{
	numbr nxt=(now*ll(G.d[x]-(x!=1)));
	H.insert(now*(ll)w[x],1);
	for(int i=G.fst[x];i!=-1;i=G.nxt[i])
		if(G.v[i]!=f)
			dfs(G.v[i],x,nxt);
	ans=min(ans,n-H.count(now*w[x]));
}

int main()
{
	G.init(),H.init();
	numbr beg;for(int i=0;i<D;i++)beg.x[i]=1;
	input();
	dfs(1,0,beg);
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：RAIH (赞：4)

# 题意
给一棵树，每个点有一个权值，要求修改一些点的权值，使得：

1、一个节点的子节点必须全部相同

2、父节点必须是所有子节点权值之和

最少要修改多少个？


------------
## 思路

这题第一眼看我们会想到暴力思路：很明显，如果有一个点符合要求（或子节点修改后符合要求），就直接利用，然后在树上跑，~~暴力模拟~~

不过在画完图后我们会发现——

**只要确定一个值，就可以确定整个树所有节点的值**

因为我们每个节点都受自己子节点的限制，这很容易明白（~~不明白就自己手画一下~~），然后从这个结论可以推出：

**我们可以以根节点的值为联系，找到性质相同的节点有多少个~~**

我们设 $f[i]$ 表示到从1号店遍历到i号节点的总边数，这样题目便清晰的变成了一个树形DP，由 $f[i] $ 的性质可知这是一个由上至下的过程，可以推出 
$f[i]=f[i's fa]* du[i's fa] $
( $du[i]$ 表示节点i的下一层子树节点数量 ) ，

可知 $f[i]*a[i]$即为根节点的权值。只要找到最多值相同的 $f[i]*a[i]$ ,并用总数减去即为答案（个人认为自己在代码写的比较清楚）

详细分析见代码

 **不过数据过大会爆long long,对此可以写高精度或者用$log(loga+logb==log(a*b))$**

我认为我码风还不错，而且~~应该都看的明白吧~~
```cpp
#include<bits/stdc++.h>
#define num 5000001
using namespace std;
int n,tot=0,ans=0,cnt=0;
double a[num],f[num];//表示到第i号节点一共有几条边 
int h[num],du[num];
//借此可表达根的权值，借此若f相同的越多，则重建数量越少（显然） 
//但可惜f的值会很大，可以用高精度，但还可以用log 
struct qbl{
	int v,next;
}e[num];
void add(int u,int v){
	e[++tot].v=v;e[tot].next=h[u];h[u]=tot;
}
void dfs(int x,int fa){//经典树形DP
	if(fa==1) f[x]=f[fa]+log((double)du[fa]);
	else if(fa==0) f[x]=log((double)1.0);
	else f[x]=f[fa]+log((double)(du[fa]-1));
	//巧妙的log加法代替乘法（记住可以用小数） 
	for(int i=h[x];i;i=e[i].next){
		int y=e[i].v;if(y==fa) continue;
		dfs(y,x);	
	}
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<n;i++){
		int a,b;cin>>a>>b;
		add(a,b);add(b,a);
		du[a]++;du[b]++;
	}
	dfs(1,0);
	for(int i=1;i<=n;i++) f[i]=f[i]+log((double)a[i]);
	sort(f+1,f+1+n);
	for(int i=1;i<=n;i++){
		if(f[i]-f[i-1]<=0.0000001){cnt++;ans=max(cnt,ans);}
		else cnt=1;
	}
	ans=n-ans;
	cout<<ans<<endl;
	return 0;
} 
```


---

## 作者：xryjr233 (赞：3)

简化题意:

一棵$n$个点的树,每一个点有个初始点权,第$i$个点点权为$A_i$,要求任意节点的子节点权值相等,父节点权值等于子节点的和,问最少需要改变多少点的权值。

设节点$i$的子节点数量为$sz_i$,点$i$修改以后的点权为$w_i$。

发现我们通过一个点$i$的权值可以得到所有相邻点的权值:它的每一个子节点就是$\frac{w_i}{sz_i}$,它的父节点$fa$的点权就是$w_i\times sz_{fa}$。

于是我们假设我们确定了根节点的点权,那么我们就确定了每一个点的点权。对于任意点$i$,设它的父亲到根的路径上的点为$p_1,p_2,p_3,...,p_m$,那么该点的权值就是$\frac{w_1}{\Pi_{i=1}^mP_i}$,即根节点的点权乘路径上所有点的子节点数量的乘积。

我们设一个点$i$的父节点到根节点的路径上所有点子节点数量的乘积为$k_i$,并钦定$k_1=1$。

于是我们有$w_i=\frac{w_1}{k_i}$。

于是$w_1=w_i\times k_i$。

我们要求满足$w_i=A_i$的$i$数量最多。

已知如果点$i$满足条件,那么$w_1=k_i\times A_i$。

所以我们要找一个$w_1$,使得上述条件满足的数量最多。

所以我们把每一个点$i$的$k_i\times A_i$存入哈希表,看一下表中数量最多的值的数量即可。

注意这个值是可以满足的最大数量,我们要输出的是需要修改的最小数量,所以要用$n$减这个最大值然后输出。

code:

哈希模数建议取3个以上比较保险。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod1=19260817;
const int mod2=998244353;
const int mod3=1e9+7;
struct edge{
    int t,nxt;
}e[1000010];
struct hv{
    int m1,m2,m3;
    bool operator>(const hv&y)const{
        return m1==y.m1?(m2==y.m2?m3>y.m3:m2>y.m2):m1>y.m1;
    }
    bool operator<(const hv&y)const{
        return m1==y.m1?(m2==y.m2?m3<y.m3:m2<y.m2):m1<y.m1;
    }
    hv operator*(const int&y)const{
        hv tmp;
        tmp.m1=1ll*m1*y%mod1,tmp.m2=1ll*m2*y%mod2,tmp.m3=1ll*m3*y%mod3;
        return tmp;
    }
}k[500010];
int n,a[500010],u,v,cnt,be[500010],sz[500010],vis[500010],ans;
map<hv,int>mp;
void scan(int&x){
    x=0;
    char c=getchar();
    while(!isdigit(c))c=getchar();
    while(isdigit(c))x=x*10+c-'0',c=getchar();
}
void add(int x,int y){
    e[++cnt].t=y,e[cnt].nxt=be[x],be[x]=cnt;
}
void Getk(int x){
    vis[x]=1;
    hv upd=k[x]*sz[x];
    for(int i=be[x];i;i=e[i].nxt)!vis[e[i].t]?k[e[i].t]=upd,Getk(e[i].t),0:0;
}
int main(){
    scan(n);
    for(int i=1;i<=n;++i)scan(a[i]);
    for(int i=1;i<n;++i)scan(u),scan(v),add(u,v),add(v,u),++sz[u],++sz[v];
    for(int i=2;i<=n;++i)--sz[i];
    k[1]=(hv){1,1,1},Getk(1);
    for(int i=1;i<=n;++i)ans=max(ans,++mp[k[i]*a[i]]);
    printf("%d",n-ans);
    return 0;
}
```

---

## 作者：luogu_gza (赞：1)

简化题意就是给定一棵树，求最少修改几个点，使得所有兄弟点权值相同，父亲的权值等于所有儿子权值的和。

发现一个点权值确定以后，所有的点权值都确定了。

那么定义 $f_i$ 表示 $i$ 点权值不变的情况下，根节点的权值。

但是，这样 `long long` 都存不下了。

我们将权值 $\prod$ 转化为其 $\log$ 值的 $\sum$。

然后，判断有多少个 $f_i$ 相等就好了。

记住，题目问的是有多少个需要修改，而不是多少个不需要修改，

因此，最终答案还要用 $n$ 减去它。

我写题解一般不给代码，有需要的私信我。

[record](https://www.luogu.com.cn/record/123544403)

---

## 作者：Digital_Sunrise (赞：0)

[link](https://www.luogu.com.cn/problem/P3237)

我错了，我再也不用图片代码了

## 前言

此题题目描述非常繁琐，可以化简为：
1. 一个节点的所有儿子节点的点权相等
2. 一个非叶子节点的权值是它所有儿子的权值的和
3. 求构造一棵满足上述条件的树至少要修改多少个点的点权

## 题解
了解完题目意思之后，我们可以很明显看出：只要一个点的点权确定，树上所有点的权值都确定了。

如果随便考虑一个点的权值并将其拓展到整个树的权值会非常麻烦（甚至算不出答案）。

我们随手构造一颗符合要求的树。

![](https://cdn.luogu.com.cn/upload/image_hosting/rbcm3qtl.png)

很显然，在一个固定的合法图当中，**一个点的点权和根节点的点权之比不变**，并且 **根节点的点权总是一个点的点权的整数倍**

换句话说，我们可以通过求出在一个**合法**的图当中根节点的点权与节点 $i$ 的点权的整数倍 $k_i$ 。

通过 $k_i$ 乘上实际点权 $a_i$ 得到一个“理想根节点”的点权。

那么“理想根节点”的点权相同的节点就处于同一个自己点权正确的“理想树”当中。

求出出现次数最多的“理想根节点”的点权出现的次数 $sum$ , $n-sum$ 即为答案。

使用哈希即可。

## Code

```cpp
#include <bits/stdc++.h>
#define int long long 
using namespace std;
const int maxn = 5e5 + 5;
const int mod = 998244353;

map <int,int> Map;
int n;
int a[maxn];
vector <int> G[maxn];
int q[maxn];
int cnt,ans;

void dfs(int u,int fa)
{
	if(u != 1)
	{
		if(fa == 1)
			q[u] = G[fa].size();
		else
			q[u] = q[fa] * (G[fa].size() - 1) % mod;
	}
		
	for(int i = 0;i < G[u].size();i++)
		if(G[u][i] != fa)
			dfs(G[u][i],u);
}

signed main()
{
	cin >> n;
	for(int i = 1;i <= n;i++)
		cin >> a[i];
	for(int i = 1;i < n;i++)
	{
		int u,v;
		cin >> u >> v;
		G[u].push_back(v);
		G[v].push_back(u);
	}
	q[1] = 1;
	dfs(1,0);
	for(int i = 1;i <= n;i++)
	{
		++Map[a[i] * q[i] % mod];
		ans = max(ans,Map[a[i] * q[i] % mod]);
	}
	cout << n - ans;
	return 0;
}
```



---

## 作者：_Album_ (赞：0)


更好的阅读：[点我](https://payphone-x.top/2020/05/22/luoguP3237/)

---------------

## 分析

~~真就tm阅读理解题呗~~

题意即给你一颗树，需要你改变一些点的点权，使其满足以下性质：

1. 每个点的子节点权值均相同
2. 父节点权值为其各子节点的权值和。

考虑如何计算。仔细观察，不难发现**当一个点的点权确定后，整棵树的点权也将随之确定**。

设$f[i]$表示$i$节点的权值为$val[i]$时，根节点的权值是$i$节点的几倍。即

$$val[root] = f[i] \times val[i]$$

转移比较简单，为

$$f[to] = f[x] \times (in[x] - 1)$$

其中，$in[x]$表示的是节点$x$的度数(即有多少边与节点$x$相连)。而$in[x] - 1$是因为**每个点对答案产生贡献的边为该点与子节点的连边**，因此，我们需要减去父节点产生的度数

特别地，对于根节点我们需要特殊处理，即$f[to] = f[1] \times in[x]$。因为根节点没有父亲。

最后对$f$数组进行排序，如果$f[i] = f[j]$则说明$i$与$j$可以同时满足条件，不需要更改。因此只需找出$f$数组中的最长相等序列，然后用总数减掉即可。

但还有最后一个问题：节点点权的范围是$10^8$，直接乘一定会溢出。

对此，我们可以~~写个高精~~采用**整数哈希**或者是**利用公式**$log(a) + log(b) = log(a \times b)$转换为加法(**注意可能产生的精度误差**)。

剩下的见代码注释。

--------------------------------------------------

## Code[Accepted]

```Cpp
#include <bits/stdc++.h>

#define ll long long
#define rep(i , l , r) for (int i = (l); i <= (r); i ++)
#define per(i , r , l) for (int i = (r); i >= (l); i --)
#define PE(i , x) for(int i = head[x]; i; i = edge[i].last)

using namespace std;

const int N = 10001;
const int M = 500101;
const int HA = 998244353;
const int INF = 2147483647;
const double eps = 1e-8;
const long long INFL = 9223372036854775807;

int n , num[M] , in[M];

struct Edge{
    int to , last;
}edge[M << 1];

int edge_num;
int head[M << 1];

I void add_edge(int from , int to){
    edge[++ edge_num] = (Edge){to , head[from]}; head[from] = edge_num;
    edge[++ edge_num] = (Edge){from , head[to]}; head[to] = edge_num;
}

double f[M];

void dfs(int x , int fa , double val){
    f[x] = val + log(num[x]);
    in[x] --;   
    //对于答案产生贡献的边为该节点与其子节点的连边，因此需要减去父节点的度数   
    PE(i , x){
        int to = edge[i].to;
        if(to == fa) continue;
        dfs(to , x , val + log(in[x]));
    }
}

int main() {
    #ifdef LOCAL
        freopen("try.in" , "r" , stdin);
        freopen("try1.out" , "w" , stdout);
    #endif
    scanf("%d" , &n);
    rep(i , 1 , n){
        scanf("%d" , &num[i]);
    }
    int u , v;
    rep(i , 1 , n - 1){
        scanf("%d%d" , &u , &v);
        add_edge(u , v);
        in[u] ++ , in[v] ++;
    }
    in[1] ++;    //1号节点没有父亲，需要单独加一个度数
    dfs(1 , 0 , log(1));
    sort(f + 1 , f + 1 + n);
    int ans = 1 , cnt = 0;
    rep(i , 2 , n){
        if(f[i] - f[i - 1] < eps){  //注意可能存在的精度误差
            cnt ++;
        }
        else{
            ans = max(ans , cnt);
            cnt = 1;
        }
    }
    printf("%d\n" , n - ans);

    return 0;
}
```

---------------------------------------

# THE END


---

## 作者：巨型方块 (赞：0)

题目意思是遍地可找的，但是我们怎么去记录某个点值确定时根节点的值呢？

我一开始想到一个dfs n次的算法，时间复杂度n^2，炸！

其实你画个图自己推一下，规律显而易见

这里写图片描述

sum指的是其儿子的数量；

当5号点=x确定，2好点是x\*2，根节点是x\*2\*3

七号点同理；

这样时间复杂度就好办了；

但是我们可以想到一个问题，根节点的值会炸飞！！，那我们怎么办呢？

网上一查，

1.hash
2.log
我两个都不懂啊；但是log比较简单

我们看看

![](http://img.blog.csdn.net/20170217192448695?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGFyZ2VjdWIyMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

loga(MN)=logaM+logaN 

这不就好办了嘛，我们只要把上图中根节点的各个值log再加起来，完美压缩了空间啊！；



```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
struct cs{
    int to,next;
}a[500000];
int head[500001],sum[500001],vv[500001];
double s[500001];
int n,m,x,y,ll,ans;
void init(int x,int y){
    ll++;
    a[ll].to=y;
    a[ll].next=head[x];
    head[x]=ll;
    sum[x]++;
}
void dfs(int x,double y){
    s[x]=y+log(double(vv[x]));
    for(int k=head[x];k;k=a[k].next)dfs(a[k].to,y+log(double(sum[x])));
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%d",&vv[i]);
    for(int i=2;i<=n;i++)scanf("%d%d",&x,&y),init(x,y);
    dfs(1,double(log(1.0)));
    sort(s+1,s+n+1);
    m=ans=1;
    for(int i=2;i<=n;i++)
    if(s[i]-s[i-1]<1e-8)m++,ans=max(ans,m);else m=1;
    printf("%d",n-ans);
}
```

---

## 作者：wangyibo201026 (赞：0)

## 题意

让你改最少的点的点权，使得：

1. 所有儿子的点权相同。

2. 设点 $x$ 拥有 $a$ 个点权为 $b$ 的儿子，则 $a$ 的点权为 $a \times b$。

## 思路

老师给我讲了一下这个题，于是就来做一下。

首先根据条件，不难推出，一旦树上任意点的点权确定，那么整棵树的所有点的点权也都能确定，只不过根节点是最简单的，所以我们以根节点来解决这个问题。

有了上面的条件，显然可以设 $f_i$ 表示当 $i$ 的点权确定时，根节点的点权。则状态转移方程是：

$$f_i = a_i \times \prod\limits_{x \in \text{father}_i}in_x$$

则不变的点的个数就是将 $f$ 排一遍序，在 $f$ 当中找最长相同的长度。答案就是用 $n$ 减去这个值。

当然，$a_i \le 10^8$，连乘会爆 $\text{long long}$，所以需要将乘法转换成 $\log$，因为 $\log$ 有 $\log(a) \times \log(b) = \log(a \times b)$ 的性质，所以可以代替乘法。

## 代码

代码：

```cpp
#include<bits/stdc++.h>

#define endl '\n'
#define DEBUG cout << "fuck ccf!!!\n";
#define DeBuG cout << "fuck ccf";
#define int long long

using namespace std;

const int N = 5e5 + 5;
const double eps = 1e-8;

int n;
double a[N], in[N];

int head[N], tot;

struct Node{
  int to, next;
}edges[N * 2];

void add(int u, int v){
  tot++;
  edges[tot].to = v;
  edges[tot].next= head[u];
  head[u] = tot;
}

double f[N];

void dfs(int x, int fa, double ans){
  f[x] = ans + (double)log((double)a[x]);
  in[x]--;   //这里因为要算上父节点，所以需要减去
  for(int i = head[x]; i; i = edges[i].next){
    if(edges[i].to != fa){
      dfs(edges[i].to, x, ans + (double)log((double)in[x]));
    }
  }
}

void Solve(){
  cin >> n;
  for(int i = 1; i <= n; i++){
    cin >> a[i];
  }
  for(int i = 1; i < n; i++){
    int u, v;
    cin >> u >> v;
    add(u, v);
    add(v, u);
    in[u]++;
    in[v]++;
  }
  in[1]++;  //因为 1 没有父节点，又因为 1 在后面又会减，所以 ++
  dfs(1, 0, (double)log(1));   //树形 dp
  sort(f + 1, f + 1 + n);
  int ans = 1, pos = 0;
  for(int i = 2; i <= n; i++){   //求最长的相同子串长度
    if(f[i] - f[i - 1] < eps){
      pos++;
      ans = max(ans, pos);
    }
    else{
      pos = 1;
    }
  }
  cout << n - ans;
}

signed main(){
  Solve();
  return 0;
}
```

---


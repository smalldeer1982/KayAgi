# [POI 2015] MOD

## 题目描述

给定一棵无根树，边权都是 $1$，请去掉一条边并加上一条新边，定义直径为最远的两个点的距离，请输出所有可能的新树的直径的最小值和最大值。


## 说明/提示

**【数据范围】**

对于 $100\%$ 的数据，$2 \le n \le 5 \times 10 ^ 5$。

----

原题名称：Modernizacja autostrady。

感谢 @cn：苏卿念 提供 spj

## 样例 #1

### 输入

```
6
1 2
2 3
2 4
4 5
6 5```

### 输出

```
3 4 2 2 5
5 2 1 1 6```

# 题解

## 作者：3493441984zz (赞：13)

# 小声$bb$：

### 居然没有题解。。赶紧水一波

### 调了我半天。。结果$if$里$==$写成了$=qwq$


------------
# 回到正题：

对于最大值，我们把一棵树拆开后，把两棵树的直径的两端连起来就可以了

对于最小值，我们把一棵树拆开后，把两棵树的直径中点相连就可以了

~~（说的轻巧）~~

那就详细的讲讲怎么求吧


------------
# 变量声明：

$dep[i]$：$i$节点的深度

$f[i]$：以$i$为根的子树的最长直径

$d[i][j](j\in\{0,1,2\})$:分别表示从$i$节点向下的最长链，次长链，和次次长链$qwq$

$w[i][j](j\in\{0,1\})$：分别表示以$i$节点的子节点为根的子树中最长直径和次长直径

$lian[i]$：表示$i$节点出发能走的最长长度，也就是可能会往上面走，其实就是把当前节点当做根节点的最长链长度

$fa[i]$：存的父亲及节点

$g[i]$：表示删除$i$点与$fa[i]$点之间的边后，以$1$为根的那棵树的最长直径

$head[i],edge[i]$：普通前向星


------------

# 实现:

首先，我们用一次$dfs$求出$f,fa,d,w,dep$数组，详细过程在代码中注释了：
~~~cpp
void Dfs1(int u)
{
	for(int i=head[u];i;i=edge[i].nxt)
	{
		int v=edge[i].to;
		if(v==fa[u])//不是父亲 
			continue;
		dep[v]=dep[u]+1;//更新深度 
		fa[v]=u;//更新父亲节点 
		Dfs1(v);//递归 
		f[u]=max(f[u],f[v]);//更新以u根的子树最大直径，初始值为子树的最大直径 
		int tmp=d[v][0]+1;
		if(tmp>d[u][0])//更新d数组 
		{
			d[u][2]=d[u][1];
			d[u][1]=d[u][0];
			d[u][0]=tmp;
		}
		else
			if(tmp>d[u][1])
			{
				d[u][2]=d[u][1];
				d[u][1]=tmp;
			}
			else
				if(tmp>d[u][2])
					d[u][2]=tmp;
		tmp=f[v];
		if(tmp>w[u][0])//更新w数组 
		{
			w[u][1]=w[u][0];
			w[u][0]=tmp;
		}
		else
			if(tmp>w[u][1])
				w[u][1]=tmp;
	}
	f[u]=max(f[u],d[u][0]+d[u][1]);//更新直径 
}
~~~
那么处理出这些后，我们就要开始拆边了，我们假设当前节点为$u$，那么我们枚举子节点$v$，那么拆了这条边后，就更新$g$数组，这时侯有$3$种情况：

先再贴一下$g$的定义：删除$i$点与$fa[i]$点之间的边后，以$1$为根的那棵树的最长直径~~（我不是在水字数）~~

$1$、删除的$v$点在$u$点的最长链$d[u][0]$上

那么以$1$为根的子树的直径可能会是$u$这个点的次长链$d[u][1]$与次次长链$d[u][2]$相加的，或者是当前点$u$向上走最长的路$lian[u]$与次长链$d[u][1]$相加组成直径

代码：
~~~cpp
if(tmp==d[u][0])
{
	g[v]=max(max(g[v],d[u][1]+d[u][2]),lian[u]+d[u][1]);
	lian[v]=max(lian[v],d[u][1]+1);//顺便更新
}
~~~

$2$、删除的$v$点在$u$点的次长链$d[u][1]$上

那么以$1$为根的子树的直径可能会是$u$这个点的最长链$d[u][0]$与次次长链$d[u][2]$相加的，或者是当前点$u$向上走最长的路$lian[u]$与最长链$d[u][0]$相加组成直径

代码：
~~~cpp
if(tmp==d[u][1])
{
	g[v]=max(max(g[v],d[u][0]+d[u][2]),lian[u]+d[u][0]);
	lian[v]=max(lian[v],d[u][0]+1);//顺便更新
}
~~~

$3$、删除的$v$点在$u$点的次次长链$d[u][2]$上

那么以$1$为根的子树的直径可能会是$u$这个点的最长链$d[u][0]$与次长链$d[u][1]$相加的，或者是当前点$u$向上走最长的路$lian[u]$与最长链$d[u][0]$相加组成直径

代码：
~~~cpp
if(tmp==d[u][2])
{
	g[v]=max(max(g[v],d[u][0]+d[u][1]),lian[u]+d[u][0]);
	lian[v]=max(lian[v],d[u][0]+1);//顺便更新
}
~~~
但是仅仅考虑上述情况还不够，以$1$为根的子树的直径不一定会经过$u$点，所以还要与它子节点为根的子树的直径取最大值

代码：
~~~cpp
tmp=f[v];
if(tmp==w[u][0])
	g[v]=max(g[v],w[u][1]);
else
	g[v]=max(g[v],w[u][0]);
~~~

那么当我们删除$u,v$之间的边后，把两端相连就是最长直径，也就是
~~~cpp
if(ansmax<g[u]+f[u]+1)
{
	ansmax=g[u]+f[u]+1;
	maxx=fa[u],maxy=u;
}
~~~

而最小值就是两个直径中点相连，也就是
~~~cpp
int tmp=max(max(f[u],g[u]),(f[u]+1)/2+(g[u]+1)/2+1);
if(ansmin>tmp)
{
	ansmin=tmp;
	minx=fa[u],miny=u;
}
~~~
自然第二次$dfs$可以直接搞出来

代码：
~~~cpp
void Dfs2(int u)
{
	if(u!=1)
	{
		if(ansmax<g[u]+f[u]+1)
		{
			ansmax=g[u]+f[u]+1;
			maxx=fa[u],maxy=u;
		}
		int tmp=max(max(f[u],g[u]),(f[u]+1)/2+(g[u]+1)/2+1);
		if(ansmin>tmp)
		{
			ansmin=tmp;
			minx=fa[u],miny=u;
		}
	}
	for(int i=head[u];i;i=edge[i].nxt)
	{
		int v=edge[i].to;
		if(v==fa[u])
			continue;
		lian[v]=max(lian[v],lian[u]+1);
		g[v]=max(g[v],g[u]);
		int tmp=d[v][0]+1;
		if(tmp==d[u][0])
		{
			g[v]=max(max(g[v],d[u][1]+d[u][2]),lian[u]+d[u][1]);
			lian[v]=max(lian[v],d[u][1]+1);
		}
		else
			if(tmp==d[u][1])
			{
				g[v]=max(max(g[v],d[u][0]+d[u][2]),lian[u]+d[u][0]);
				lian[v]=max(lian[v],d[u][0]+1);
			}
			else
			{
				g[v]=max(max(g[v],d[u][0]+d[u][1]),lian[u]+d[u][0]);
				lian[v]=max(lian[v],d[u][0]+1);
			}
		tmp=f[v];
		if(tmp==w[u][0])
			g[v]=max(g[v],w[u][1]);
		else
			g[v]=max(g[v],w[u][0]);
		Dfs2(v);
	}
}
~~~
剩下的输出点的话就去找端点就$ok$啦，详细见代码

接下来是美滋滋的代码时间：
~~~cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#define N 500007
#define inf 0x3f3f3f3f 
using namespace std;
struct Edge
{
	int to,nxt; 
}edge[N<<1];
int n,cnt,ansmax,maxx,maxy,ansmin=inf,minx,miny;
int head[N],dep[N],f[N],d[N][3],w[N][2],lian[N],fa[N],g[N];
bool vis[N];
queue<int> q;
void Add(int u,int v)
{
	edge[++cnt]=(Edge){v,head[u]};
	head[u]=cnt;
}
void Dfs1(int u)
{
	for(int i=head[u];i;i=edge[i].nxt)
	{
		int v=edge[i].to;
		if(v==fa[u])//不是父亲 
			continue;
		dep[v]=dep[u]+1;//更新深度 
		fa[v]=u;//更新父亲节点 
		Dfs1(v);//递归 
		f[u]=max(f[u],f[v]);//更新以u根的子树最大直径，初始值为子树的最大直径 
		int tmp=d[v][0]+1;
		if(tmp>d[u][0])//更新d数组 
		{
			d[u][2]=d[u][1];
			d[u][1]=d[u][0];
			d[u][0]=tmp;
		}
		else
			if(tmp>d[u][1])
			{
				d[u][2]=d[u][1];
				d[u][1]=tmp;
			}
			else
				if(tmp>d[u][2])
					d[u][2]=tmp;
		tmp=f[v];
		if(tmp>w[u][0])//更新w数组 
		{
			w[u][1]=w[u][0];
			w[u][0]=tmp;
		}
		else
			if(tmp>w[u][1])
				w[u][1]=tmp;
	}
	f[u]=max(f[u],d[u][0]+d[u][1]);//更新直径 
}
void Dfs2(int u)
{
	if(u!=1)
	{
		if(ansmax<g[u]+f[u]+1)
		{
			ansmax=g[u]+f[u]+1;
			maxx=fa[u],maxy=u;
		}
		int tmp=max(max(f[u],g[u]),(f[u]+1)/2+(g[u]+1)/2+1);
		if(ansmin>tmp)
		{
			ansmin=tmp;
			minx=fa[u],miny=u;
		}
	}
	for(int i=head[u];i;i=edge[i].nxt)
	{
		int v=edge[i].to;
		if(v==fa[u])
			continue;
		lian[v]=max(lian[v],lian[u]+1);
		g[v]=max(g[v],g[u]);
		int tmp=d[v][0]+1;
		if(tmp==d[u][0])
		{
			g[v]=max(max(g[v],d[u][1]+d[u][2]),lian[u]+d[u][1]);
			lian[v]=max(lian[v],d[u][1]+1);
		}
		else
			if(tmp==d[u][1])
			{
				g[v]=max(max(g[v],d[u][0]+d[u][2]),lian[u]+d[u][0]);
				lian[v]=max(lian[v],d[u][0]+1);
			}
			else
			{
				g[v]=max(max(g[v],d[u][0]+d[u][1]),lian[u]+d[u][0]);
				lian[v]=max(lian[v],d[u][0]+1);
			}
		tmp=f[v];
		if(tmp==w[u][0])
			g[v]=max(g[v],w[u][1]);
		else
			g[v]=max(g[v],w[u][0]);
		Dfs2(v);
	}
}
int Bfs(int x)
{
	memset(vis,false,sizeof(vis));
	vis[x]=true;
	q.push(x);
	int ret;
	while(!q.empty())
	{
		int u=q.front();
		ret=u;
		q.pop();
		for(int i=head[u];i;i=edge[i].nxt)
		{
			int v=edge[i].to;
			if((u==minx&&v==miny)||(u==miny&&v==minx)||vis[v])
				continue;
			q.push(v);
			vis[v]=true;
		}	
	}
	return ret;
}
int Get(int x,int y,int len)
{
	int now=len;
	if(dep[x]<dep[y])
		swap(x,y);
	while(now!=(len+1)/2)
		x=fa[x],--now;
	return x;
}
void Outputmax()
{
	printf("%d %d %d ",ansmax,maxx,maxy);
	memset(vis,false,sizeof(vis));
	vis[maxx]=true;
	q.push(maxx);
	while(!q.empty())
	{
		int u=q.front();
		maxx=u;
		q.pop();
		for(int i=head[u];i;i=edge[i].nxt)
		{
			int v=edge[i].to;
			if((v==maxx||v==maxy)||vis[v])
				continue;
			q.push(v);
			vis[v]=true;
		}	
	}
	vis[maxy]=true;
	q.push(maxy);
	while(!q.empty())
	{
		int u=q.front();
		maxy=u;
		q.pop();
		for(int i=head[u];i;i=edge[i].nxt)
		{
			int v=edge[i].to;
			if(vis[v])
				continue;
			q.push(v);
			vis[v]=true;
		}	
	}
	printf("%d %d\n",maxx,maxy);
}
int main()
{
	freopen("2.in","r",stdin);
	scanf("%d",&n);
	for(int i=1;i<n;++i)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		Add(u,v);
		Add(v,u);
	}
	Dfs1(1); Dfs2(1);
	printf("%d %d %d ",ansmin,minx,miny);
	int dianx1=Bfs(minx),diany1=Bfs(dianx1);
	int dianx2=Bfs(miny),diany2=Bfs(dianx2);
	printf("%d %d\n",Get(dianx1,diany1,g[miny]),Get(dianx2,diany2,f[miny]));
	Outputmax();
	return 0;
}





~~~


---

## 作者：SDNetFriend (赞：9)

来一篇非 DP 的题解（DFS 求直径严格上说也是 DP，不过相比于换根之类的做法也不算什么 DP）。另外其实这个题代码并没有很难写，现有题解代码大都超过 3K，提供一种 1.8K 就能写完的写法。

我们分开考虑这两个问题。

为了方便解决问题也为了方便写代码，我们先一趟 DFS 找到直径，并以两个直径端点分别作根建树并求出每一棵子树的直径以及直径端点。（相信做这个题的同学这方面都没什么问题就不展开讲了）

### 求最小可能直径

首先可以明确，原树直径是答案的下界，我们只要断掉一条边再重新连上就能取得。

这说明我们必须要断掉直径的一条边，否则直径不会变小。考虑我们在以直径其中一个端点为根的情况下操作，依次枚举直径上的每一条边，断掉任何一条边都会把这棵树分成两个，然后我们要在这两棵树中分别选一个点连起来。我们需要判断如何连接能使得直径最小并且要求出直径是多少我们就能找到答案。

我们知道有一个结论，即通过一条边连起来的两棵树的直径的端点必然也是原来两棵树的四个直径端点之二。那我们考虑这条边连在哪里才能让这四个点两两之间的最长距离最短？可以想到是分别连两棵树直径尽量靠中间的点，因为如果不在中间，那么两条直径较长的两半拼起来得到的直径一定比在中间连的长。那此时新树的直径其实就是**原来两棵树各自的直径与两条直径长度除二向上取整 $+1$ 的最大值**。画几张示意图可以方便理解：

![](https://cdn.luogu.com.cn/upload/image_hosting/vqf6htgw.png)

两条黑线是两棵子树的直径，红线是我们连上去的边，可以发现连边位置尽量靠近中间直径才会使最小的。

另外可以证明如果这条边两端点不在原树直径上，答案一定不优。

于是在所有情况里取个最小的就是答案。

### 求最大可能直径

依旧是类似的思路，我们以一个直径端点为根。

显然如果我们断掉任意一条边，使得直径最长的拼接方式一定是将两棵树的直径端点给连起来。

考虑两种情况：

#### 断掉直径的一条边

因为我们已经分别以两个直径端点为根求过每棵子树的答案，所以直接查两棵树对应子树直径长度加起来加一然后取最大就可以了。

#### 断掉一条非直径边

那么显然其中一棵树的直径就是原来的直径，并且可以发现断掉和直径点相连的非直径边是最优的，也是枚举之后直接查之前求的答案取最大就可以了。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read(){
	char c;int f=1,res=0;
	while(c=getchar(),!isdigit(c))if(c=='-')f*=-1;
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res*f;
}
const int N=5e5+5;
int n;
vector<int> ver[N];
struct eg{int u,v,w;}; 
struct tr{
	int rt,d[N],fa[N];eg f[N],g[N];
	inline eg max(eg x,eg y)
		{return x.w>y.w?x:y;}
	void DFS(int u,int pr=0){
		if(!pr)rt=u;
		d[u]=d[pr]+1;fa[u]=pr;
		int p0=u,p1=u;g[u]={u,u,0};
		for(int v:ver[u]){
			if(v==pr)continue;
			DFS(v,u);g[u]=max(g[u],g[v]);
			if(d[f[v].u]>=d[p0])
				p1=p0,p0=f[v].u;
			else if(d[f[v].u]>d[p1])
				p1=f[v].u;
		}f[u]={p0,p1,d[p0]+d[p1]-2*d[u]};
		g[u]=max(g[u],f[u]);
	}
}t,t0,t1,c;
inline int find(eg x){
	c.DFS(x.u);
	for(int i=1;i<=(x.w+1)/2;++i)
		x.v=c.fa[x.v];
	return x.v;
}
inline void smn(){
	int p=0,ans=N,u=t1.rt;
	while(u!=t0.rt){
		eg x=t0.g[u],y=t1.g[t0.fa[u]];
		int upd=(x.w+1)/2+(y.w+1)/2+1;
		upd=max(upd,max(x.w,y.w));
		if(upd<ans)p=u,ans=upd;u=t0.fa[u];
	}printf("%d %d %d ",ans,p,t0.fa[p]);
	eg x=t0.g[p],y=t1.g[t0.fa[p]];
	printf("%d %d\n",find(x),find(y));
}
inline void smx(){
	int lst=0,u=t1.rt,p,ans=0;
	bool flg;
	while(u){
		for(int v:ver[u]){
			if(v==lst||v==t0.fa[u])
				continue;
			int upd=t.g[1].w+1+t0.g[v].w;
			if(upd>ans)ans=upd,p=v,flg=false;
		}if(t0.fa[u]){
			int upd=t0.g[u].w+1+t1.g[t0.fa[u]].w;
			if(upd>ans)ans=upd,p=u,flg=true;
		}lst=u;u=t0.fa[u];
	}printf("%d %d %d ",ans,p,t0.fa[p]);
	if(!flg)printf("%d %d",t0.g[p].u,t0.rt);
	else printf("%d %d",t0.g[p].u,t1.g[t0.fa[p]].u);
}
int main(){
	n=read();
	for(int i=1;i<n;++i){
		int u=read(),v=read();
		ver[u].push_back(v);
		ver[v].push_back(u);
	}t.DFS(1);
	t0.DFS(t.g[1].u);
	t1.DFS(t.g[1].v);
	smn();smx();
	return 0;
}

```



---

## 作者：XuYueming (赞：6)

## 题意简述

给定一棵树，求断掉一条边再连上一条边所得的新树直径最小值和最大值，以及相应方案（你可以不进行任何操作，即断掉并连上同一条边）。

## 题目分析

假设我们枚举断掉某一条边，得到了两棵树，并且知道它们的直径分别为 $d_0, d_1$，那么如何连接一条边让新树的直径最大 / 最小呢？  

1. 最大：显然，将两棵树的直径首尾相接，得到的直径是最大的，新树的直径长度是 $d=d_0+d_1+1$。别忘了新加的这条边的贡献 $1$。
2. 最小：和 [HXY 造公园](https://www.luogu.com.cn/problem/P2195) 里的思想一样，我们将两个树的直径的中点相连（或者没有中点时取直径中心相邻的那两点任一），得到的新直径长度是 $d = \max \lbrace d_0, d_1, \left \lceil \cfrac{d_0}{2} \right \rceil + \left \lceil \cfrac{d_1}{2} \right \rceil + 1 \rbrace$。别忘了新加的这条边的贡献 $1$。

可是，我们这样只能知道答案直径的长度，以及断掉哪条边，那怎么知道断边之后连接哪两个点呢？如果在 $\Theta(n)$ 枚举断边的同时把两棵树的直径求出来时间复杂度是 ~~恐怖的~~ $\Theta(n^2)$，显然超时。如何优化呢？事实上，我们完全不用每得到一个可能的答案就算出其具体方案，而是留到最后再处理，处理方法随便一个 $\Theta(n)$ 求直径的方法都行。这样，总体的时间复杂度就是 $\Theta(n)$ 的。于是，问题变成给出断开的边，如何求两颗树的直径长度。在这里提供了两种方法 $\Theta(n)$ 地求解此题。

### 1. 树形 DP

钦定原树以 $1$ 为根结点。枚举断边可以使用深搜，那么我们就需要在搜索的时候快速求得以 $u$ 为根的子树的直径长度以及 $fa[u]$ 这个方向上的直径长度。于是我们想到了使用树形 DP 求解。前者是树形 DP 求直径的模板，可以用一遍深搜预处理出来。考虑如何换根求得后者。在根从 $fa[u]$ 变成 $u$ 的时候，发现 $fa[u]$ 这个方向上的树多出了 $u$ 的兄弟子树，那么可能构成直径的分为以下几个部分。

- 原先 $fa[fa[u]]$ 方向上的直径。
- $u$ 兄弟子树中的直径。
- 取 $u$ 的两个兄弟（如果存在）$x$ 和 $y$，以及分别在以 $x$ 为根的子树中和以 $y$ 为根的子树中取出一条链 $x \rightarrow x'$ 和 $y \rightarrow y'$，组成的新链 $x' \rightarrow x \rightarrow fa[u] \rightarrow y \rightarrow y'$。
- 取 $fa[fa[u]]$ 方向连向 $fa[u]$ 的一条链 $p \rightarrow fa[u]$。选取 $u$ 的兄弟 $x$，以及 $x$ 子树中一条链 $x \rightarrow x'$。两条链拼接组成的新链 $p \rightarrow fa[u] \rightarrow x \rightarrow x'$。

显然，以上分析囊括了不越过 $fa[u]$ 和越过 $fa[u]$ 的所有可能情况，不存在漏解。为了帮助理解，可以参考下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/bj0jspp9.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/hy4rpbgl.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/663aaxr6.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/o3oowd1h.png)

对于第二点，想到记 $w_i$ 表示 $i$ 所有子树中最长的直径，那么第二点直径长度就是 $w_{fa[u]}$，但是请注意，我们要的是 $u$ 的兄弟子树而不包括 $u$ 这棵子树，万一 $w_{fa[u]}$ 正好是 $u$ 这棵子树中的直径就出现了问题。所以，套路化地，我们给 $w$ 多加一维，变为 $w_{i,0/1}$ 表示以 $i$ 的所有子树中最长的直径 / 次长的直径。这样，对于上文提到的情况，就使用 $w_{fa[u], 1}$ 来转移就没有问题。

对于第三种情况，想到记 $d_{i, 0/1}$ 表示 $i$ 所有子树中，根节点连出的最长链和次长链的长度。那么对于一般情况，合并后的直径长度就是 $d_{fa[u],0}$ + $d_{fa[u],1}$。套路化地，发现当 $u$ 这棵子树贡献了最长链或者次长链会产生问题，所以需要再开一维，记 $d_{i,0/1/2}$ 表示 $i$ 所有子树中，根节点连出的最长链、次长链和次次长链的长度。转移的时候注意不要使用到 $u$ 这棵子树产生的信息就可以了。

对于第四种情况，我们需要知道 $fa[u]$ 在 $fa[fa[u]]$ 方向上最长链的长度，这个假设已经求得，为 $chain_{fa[u]}$。和 $u$ 兄弟子树中根节点连出的最长链的长度，发现就是上文求的 $d_{fa[u],0}$，当 $u$ 这棵子树存在最长链的时候是 $d_{fa[u],1}$。那么合并后的直径长度就是 $chain_{fa[u]} + d_{fa[u],0/1}$。考虑如何使用信息更新 $chain_u$。首先，可能新的链是 $chain_{fa[u]}$ 的基础上连上了 $fa[u] \rightarrow u$ 这条边，长度是 $chain_{fa[u]} + 1$。其次可能是 $u$ 兄弟子树连过来的一条边，长度是 $d_{fa[u],0/1} + 1$，这个要根据 $u$ 是否是最长链分类讨论。两者合并，得到 $chain_u = \max\{chain_{fa[u]}+1,d_{fa[u],0/1}+1\}$。

分析结束，具体使用代码实现就是两遍 DFS，第一遍预处理出 $u$ 子树中直径长度 $f_u$、$d_{u,0/1/2}$ 和 $w_{u,0/1}$。第二遍使用信息更新 $fa[u]$ 方向上的直径 $g_u$ 和 $chain_u$，同时更新答案即可。具体实现和细节见代码。

### 2. 在原直径上 DP

假设在想到断掉一条边后，我们没有往树形 DP 的方向思考，而是想到了如下结论：

#### 结论一：如果要获得直径的最小值，把原直径断开一定不劣。  
> 证明：  
> 设原树直径为 $d$。如果没有断开原直径，那么答案 $D=\max \lbrace d,l,\left \lceil \cfrac{d}{2} \right \rceil + \left \lceil \cfrac{l}{2} \right \rceil + 1 \rbrace$ 一定有 $D \geq d$，而我们断开连接同一条边获得的答案就是原树直径 $d$ 显然不劣。所以为了得到更优的答案，就必须要把原树直径断开。

#### 结论二：如果要获得直径的最大值，只可能是断开直径或者断开和直径连接的边  
> 证明：  
> 方案分为两种，即断开直径或者不断开直径。如果不断开直径，我们就需要和直径分离的那棵树直径最长，所以此时有删除和直径连接的这条边不劣。这是因为考虑直径上一个点 $u$ 和与其相连的不在直径上的儿子 $v$，如果断开的边在 $v$ 这棵子树里，获得了一条直径，那么这条直径同样在断开连接 $u$ 和 $v$ 这条边后 $v$ 的子树里，故删除和直径连接的这条边不劣

有了如上两个结论，实现方法呼之欲出。考虑先将原树直径“拉下来”，树的其他部分“挂”在这条直径上（详见下图），发现树上的问题变成了一个类似序列上的问题，简单了许多。从右向左遍历直径上相邻的点对 $(u, v)$，删除他们之间的边，快速求得 $u$ 这边和 $v$ 这边树的直径，然后统计答案。对于断开和直径相连的边，暴力枚举时间复杂度不超过 $\Theta(n)$，问题就得到解决。

接下来考虑从右向左枚举断边从 $(v,y)$ 变为 $(u,v)$ 的过程，两树直径变化。首先对于左树的直径我们可以预处理出来，那么只需要考虑多出的 $y$ 以及它的不在直径上的子树对右半部分直径产生的贡献，和前文树形 DP 讨论方法类似，分为不经过 $y$ 和经过 $y$ 的直径，具体如下：

- 原来 $y$ 右边的直径。
- 以 $y$ 为根的不经过原树直径的直径。
- 对于 $y$ 一个儿子 $yzh$ 和它子树里以 $yzh$ 为一个端点的链 $yzh \rightarrow yzh'$，以及 $y$ 右边延伸过来的一条链 $p \rightarrow y$ 组成的直径 $yzh' \rightarrow yzh \rightarrow y \rightarrow p$。

可以借助下图进行形象地理解。

![](https://cdn.luogu.com.cn/upload/image_hosting/x8amhshi.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/uwbwo99w.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/wmt6t8yb.png)

对于第二点，发现可以和求左树直径一样用同一个 DFS 预处理出来。

对于第三点，我们只用记 $y$ 连出的不经过原直径最长链的长度 $f_y$，和右边伸过来的链 $R_{len}$ 和并得 $f_y+R_{len}$（你看看次长、次次长都不见了）。那么，我们怎么算得对于 $v$ 的 $R_{len}'$ 呢？发现可以是目前链再向左延伸或者是 $y$ 中一条长链连过来，故 $R_{len}'=\max \lbrace R_{len}+1,f_y+1 \rbrace$。

分析结束，完成了对本题的求解。具体使用一遍深搜把原树直径“拉下来”再反着枚举断边，同时更新 $R_len$。随后枚举断于直径相连的边。最后分别求出答案要求的连接哪些边。具体实现和细节见代码。

## 代码及具体实现（已略去快读快写，码风清新，注释详尽）

### 1. 树形 DP [目前最优解 rank3](https://www.luogu.com.cn/record/148551532)

```cpp
//#pragma GCC optimize(3)
//#pragma GCC optimize("Ofast", "inline", "-ffast-math")
//#pragma GCC target("avx", "sse2", "sse3", "sse4", "mmx")
#include <iostream>
#include <cstdio>
#define debug(a) cerr << "Line: " << __LINE__ << " " << #a << endl
#define print(a) cerr << #a << "=" << (a) << endl
#define file(a) freopen(#a".in","r",stdin), freopen(#a".out","w",stdout)
#define main Main(); signed main(){ return ios::sync_with_stdio(0), cin.tie(0), Main(); } signed Main
using namespace std;

struct node{
	int to, nxt;
} edge[500010 << 1];
int eid, head[500010];
void add(int u, int v){
	edge[++eid] = node({v, head[u]});
	head[u] = eid;
}

int n;

int kmin =  0x3f3f3f3f, x1min, y1min, x2min, y2min;
int kmax = -0x3f3f3f3f, x1max, y1max, x2max, y2max;

// f[i]        表示以 i 为子树的直径长度
// d[i][0/1/2] 表示表示 i 向其子树连出的最长链、次长链、次次长链的长度
// w[i][0/1]   表示 i 所有子树中的最长直径（也就是不跨过 i 的最长直径）
// chain[i]    表示 fa[i] 方向连过来的最长链的长度
int f[500010], d[500010][3], w[500010][2], chain[500010];

void Dfs(int now, int fa){
	for (int i = head[now]; i; i = edge[i].nxt){
		int to = edge[i].to;
		if (to == fa) continue;
		Dfs(to, now);
		
		f[now] = max<int, int, int>(f[now], f[to], d[now][0] + d[to][0] + 1);
		// 树形 DP 求直径
		
		if (d[to][0] + 1 > d[now][0])      d[now][2] = d[now][1], d[now][1] = d[now][0], d[now][0] = d[to][0] + 1;
		else if (d[to][0] + 1 > d[now][1]) d[now][2] = d[now][1], d[now][1] = d[to][0] + 1;
		else if (d[to][0] + 1 > d[now][2]) d[now][2] = d[to][0] + 1;
		// d[to][0] + 1 就是 now 向 to 连出的最长链的长度，用其更新 now 的最长链、次长链、次次长链的长度
		// 如果有两条相同的最长链，我们把一个看做次长链，就避免了冗长的分类讨论
		
		if (f[to] > w[now][0])      w[now][1] = w[now][0], w[now][0] = f[to];
		else if (f[to] > w[now][1]) w[now][1] = f[to];
		// 更新 i 所有子树中的最长直径
	}
}

int g[500010];

void redfs(int now, int fa){
	if (fa != 0){
		// 不是根节点就尝试断开 now 和 fa 之间的边
		
		if (kmax < g[now] + f[now] + 1) kmax = g[now] + f[now] + 1, x1max = fa, y1max = now;
		// 求最长直径
		
		int len = max<int, int, int>(f[now], g[now], (f[now] + 1) / 2 + (g[now] + 1) / 2 + 1);
		if (kmin > len) kmin = len, x1min = fa, y1min = now;
		// 求最短直径
	}
	for (int i = head[now]; i; i = edge[i].nxt){
		int to = edge[i].to;
		if (to == fa) continue;
		
		chain[to] = chain[now] + 1;  // 新的链是 fa[now] -> now 的基础上连上了 now -> to
		g[to] = g[now];  // 对应第一种情况
		
		if (d[to][0] + 1 == d[now][0]){
			g[to] = max<int, int, int>(g[to], chain[now] + d[now][1], d[now][1] + d[now][2]);
			chain[to] = max(chain[to], d[now][1] + 1);
		} else if (d[to][0] + 1 == d[now][1]){
			g[to] = max<int, int, int>(g[to], chain[now] + d[now][0], d[now][0] + d[now][2]);
			chain[to] = max(chain[to], d[now][0] + 1);
		} else {
			g[to] = max<int, int, int>(g[to], chain[now] + d[now][0], d[now][0] + d[now][1]);
			chain[to] = max(chain[to], d[now][0] + 1);
		}
		// 判断链长是不是最长链，次长链、次次长链，可以画图辅助理解
		
		if (f[to] == w[now][0]) g[to] = max(g[to], w[now][1]);
		else g[to] = max(g[to], w[now][0]);
		// 对应第二种情况
		
		redfs(to, now);
	}
}

int pre[500010], dis[500010], mxpos;
void dfs(int now, int fa, int skip = -1){
	if (dis[now] > dis[mxpos]) mxpos = now;
	for (int i = head[now]; i; i = edge[i].nxt){
		int to = edge[i].to;
		if (to != fa && to != skip){
			dis[to] = dis[now] + 1, pre[to] = now;
			dfs(to, now, skip);
		}
	}
}

int Diameter[500010], Dlen;
bool InDiameter[500010];
void GetDiameter(int u = 1, int v = -1){
	int p = -1, now = -1;
	mxpos = u, dis[u] = 0, pre[u] = -1, dfs(u, 0, v), p = mxpos;
	mxpos = p, dis[p] = 0, pre[p] = -1, dfs(p, 0, v), now = mxpos;
	for (int i = 1; i <= n; ++i) InDiameter[i] = false;
	for (Dlen = 0; ~now; InDiameter[now] = true, Diameter[++Dlen] = now, now = pre[now]);
}
// 搜直径并把直径“拉下来”

int GetNodeOfDiameter(int u = 1, int v = -1){
	return mxpos = u, dis[u] = 0, pre[u] = -1, dfs(u, 0, v), mxpos;
}
// 获取直径的一端

signed main(){
	read(n);
	for (int i = 1, u, v; i <= n - 1; ++i) read(u, v), add(u, v), add(v, u);
	
	Dfs(1, 0), redfs(1, 0);
	
	GetDiameter(x1min, y1min), x2min = Diameter[(Dlen + 1) / 2];
	GetDiameter(y1min, x1min), y2min = Diameter[(Dlen + 1) / 2];
	
	x2max = GetNodeOfDiameter(x1max, y1max);
	y2max = GetNodeOfDiameter(y1max, x1max);
	
	write(kmin, ' ', x1min, ' ', y1min, ' ', x2min, ' ', y2min, '\n');
	write(kmax, ' ', x1max, ' ', y1max, ' ', x2max, ' ', y2max, '\n');
	return 0;
}
```

### 2. 在原直径上 DP [目前最优解 rank1](https://www.luogu.com.cn/record/148538206)

```cpp
//#pragma GCC optimize(3)
//#pragma GCC optimize("Ofast", "inline", "-ffast-math")
//#pragma GCC target("avx", "sse2", "sse3", "sse4", "mmx")
#include <iostream>
#include <cstdio>
#define debug(a) cerr << "Line: " << __LINE__ << " " << #a << endl
#define print(a) cerr << #a << "=" << (a) << endl
#define file(a) freopen(#a".in","r",stdin), freopen(#a".out","w",stdout)
#define main Main(); signed main(){ return ios::sync_with_stdio(0), cin.tie(0), Main(); } signed Main
using namespace std;

struct node{
	int to, nxt;
} edge[500010 << 1];
int eid, head[500010];
void add(int u, int v){
	edge[++eid] = node({v, head[u]});
	head[u] = eid;
}

int n;

int kmin =  0x3f3f3f3f, x1min, y1min, x2min, y2min;
int kmax = -0x3f3f3f3f, x1max, y1max, x2max, y2max;

int pre[500010], dis[500010], mxpos;
void dfs(int now, int fa, int skip = -1){
	if (dis[now] > dis[mxpos]) mxpos = now;
	for (int i = head[now]; i; i = edge[i].nxt){
		int to = edge[i].to;
		if (to != fa && to != skip){
			dis[to] = dis[now] + 1, pre[to] = now;
			dfs(to, now, skip);
		}
	}
}

int Diameter[500010], Dlen;
bool InDiameter[500010];
void GetDiameter(int u = 1, int v = -1){
	int p = -1, now = -1;
	mxpos = u, dis[u] = 0, pre[u] = -1, dfs(u, 0, v), p = mxpos;
	mxpos = p, dis[p] = 0, pre[p] = -1, dfs(p, 0, v), now = mxpos;
	for (int i = 1; i <= n; ++i) InDiameter[i] = false;
	for (Dlen = 0; ~now; InDiameter[now] = true, Diameter[++Dlen] = now, now = pre[now]);
}
// 搜直径并把直径“拉下来”

int GetNodeOfDiameter(int u = 1, int v = -1){
	return mxpos = u, dis[u] = 0, pre[u] = -1, dfs(u, 0, v), mxpos;
}
// 获取直径的一端

// f[i] 表示 i 向非直径连出的最长链长度
// g[i] 表示 i 子树的直径
int f[500010], g[500010];
void TreeDP(int now, int fa){
	for (int i = head[now]; i; i = edge[i].nxt){
		int to = edge[i].to;
		if (to != fa){
			TreeDP(to, now);
			if (InDiameter[to]) continue;  // 这句话很巧妙地做到了分别以直径上的每个结点往直径外搜索
			g[now] = max<int, int, int>(g[now], g[to], f[to] + 1 + f[now]);
			f[now] = max(f[now], f[to] + 1);
			// 说明 to 不是直径上的结点，更新最长链和直径
		}
	}
}

int p[500010];

signed main(){
	read(n);
	for (int i = 1, u, v; i <= n - 1; ++i) read(u, v), add(u, v), add(v, u);
	
	GetDiameter(), TreeDP(Diameter[1], 0);
	// 先把直径拉下来
	
	for (int i = 1, now = 0; i <= Dlen; ++i){
		// 这里 i 表示把直径拉下来后第 i 个直径结点
		// 正着扫，p[i] 表示前缀直径
		// 考虑新增部分的贡献，可能直径完整在 i 的的子树里，即 g[Diameter[i]]
		// 也可能是之前连向 i 的最长链和 i 向子树连出的最长链
		p[i] = max<int, int, int>(p[i - 1], g[Diameter[i]], now + f[Diameter[i]]);
		// 这里的 now 就是维护连到 i 的最长链的长度
		// 可能是之前那条链再向右延伸，或者是从 i 的子树里连过来
		now = max(now + 1, f[Diameter[i]] + 1);
	}
	
	// 接下来倒着扫一遍，尝试删除直径上 i - 1 号点和第 i 号点之间的边
	// 同样用 Rlen 记录右半部分的直径长度
	// 用 now 记录从右边连向 i 的最长链的长度
	for (int i = Dlen, Rlen = 0, now = 0; i - 1 >= 1; --i){
		Rlen = max<int, int, int>(Rlen, g[Diameter[i]], now + f[Diameter[i]]);
		now = max(now + 1, f[Diameter[i]] + 1);
		// 同前面的维护
		
		int len = max<int, int, int>(p[i - 1], Rlen, (Rlen + 1) / 2 + (p[i - 1] + 1) / 2 + 1);
		if (len < kmin) kmin = len, x1min = Diameter[i], y1min = Diameter[i - 1];
		// 维护最小直径
		
		if (Rlen + 1 + p[i - 1] > kmax) kmax = Rlen + 1 + p[i - 1], x1max = Diameter[i], y1max = Diameter[i - 1];
		// 维护最长直径
	}
	
	// 为了获得最长直径，我们还要把和直径相连的边都尝试断一遍
	// 这里直接枚举直径上的点，在枚举它连出的边
	for (int i = 1; i <= Dlen; ++i) for (int j = head[Diameter[i]]; j; j = edge[j].nxt){
		int to = edge[j].to;
		if (!InDiameter[to]){
			// 更新最长直径
			if (Dlen + g[to] > kmax) kmax = Dlen + g[to], x1max = Diameter[i], y1max = to;
		}
	}
	
	// 最后求得具体方案
	GetDiameter(x1min, y1min), x2min = Diameter[(Dlen + 1) / 2];
	GetDiameter(y1min, x1min), y2min = Diameter[(Dlen + 1) / 2];
	
	x2max = GetNodeOfDiameter(x1max, y1max);
	y2max = GetNodeOfDiameter(y1max, x1max);
	
	write(kmin, ' ', x1min, ' ', y1min, ' ', x2min, ' ', y2min, '\n');
	write(kmax, ' ', x1max, ' ', y1max, ' ', x2max, ' ', y2max, '\n');
	return 0;
}
```

---

## 作者：y2823774827y (赞：4)


### 安利博客$\Longrightarrow\Longrightarrow\Longrightarrow$[更好的阅读体验](https://www.cnblogs.com/y2823774827y/p/10275101.html)

简化题目：重构树使得其直径最大/最小
## 做法
已知两棵树，怎么连边才能使直径最大/最小

直径最大：两棵树找直径端点相连
直径最小：两棵树找直径中点相连

转化问题，我们要求的其实是：$Down_i$为子树直径，$Up_i$为除i子树外直径(删掉$i$~$fa$后上方的直径)

子树直径当然好求，儿子直径,次直径，$Down_i$是递归后返回从下传到上面

那$Up_i$显然这部分我们是要在递归到$i$之前完成的，也就是从上到下做完$Up_i$

考虑做$Up_v$，$u$上面的部分就从$Up_u$转移过来了，剩下的就考虑$u$的非$v$子树直径与 **给** $v$子树链和$u$上面组成的最长链(开个数组$line$记录)

[完整代码及两组良心数据](https://www.cnblogs.com/y2823774827y/p/10275101.html)


---

## 作者：Alex_Wei (赞：3)

- Update on 2022.11.25 重写题解，原题解见 [链接](https://www.luogu.com.cn/paste/ugdktbes)。

[P3596 [POI2015] MOD](https://www.luogu.com.cn/problem/P3596)

考虑枚举断掉的边，我们希望快速求出形成的两个连通块的直径 $d_1$ 和 $d_2$，则连一条边形成的直径最大长度为 $d_1 + d_2 + 1$（连接两连通块直径一段），最小直径长度为 $\max(d_1, d_2, \lceil \frac {d_1} 2 \rceil + \lceil \frac {d_2} 2\rceil + 1)$（连接两连通块直径中点）。

设 $f_i$ 表示子树最长竖直链，$g_i$ 表示子树直径，则
$$
\begin{aligned}
f_i & = \max\limits_{u \in \mathrm{son}(i)} f_u + 1 \\
g_i & = \max\left(\max_{u\in \mathrm{son}(i)} g_u, \max_{u, v\in \mathrm{son}(i), u\neq v} f_u + f_v + 2\right)
\end{aligned}
$$
求每棵子树的直径可直接换根 DP。换根 DP 过程中需要对 $i$ 求出将每个儿子 $u$ 从 $\mathrm{son}(i)$ 中删除后新的 $f$ 和 $g$ 值，使用维护前后缀的经典套路，$f$ 容易维护，$g$ 在合并的时候还需要和前缀 $\max f$ 与后缀 $\max f$ 之和取 $\max$。

时间复杂度 $\mathcal{O}(n)$。因需构造方案，所以需要维护最长竖直链的一段和直径两端，使用结构体可避免繁琐的分类讨论。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define TIME 1e3 * clock() / CLOCKS_PER_SEC

constexpr int N = 5e5 + 5;
vector<int> e[N];
int n;
struct chain {
  int u, d;
  chain operator + (const int &z) const {return {u, d + z};}
  bool operator < (const chain &z) const {return d < z.d;}
} f[N], ff[N];
struct diam {
  int u, v, d;
  void print() {cout << "diameter: u = " << u << ", v = " << v << ", d = " << d << "\n";}
  diam operator + (const int &z) const {return {u, v, d + z};}
  bool operator < (const diam &z) const {return d < z.d;}
} g[N], gg[N];
diam operator + (const chain &x, const chain &y) {return {x.u, y.u, x.d + y.d};}

void dfs1(int id, int fa) {
  f[id] = {id, 0}, g[id] = {id, id, 0};
  for(int it : e[id]) {
    if(it == fa) continue;
    dfs1(it, id);
    g[id] = max(g[id], max(g[it], f[id] + f[it] + 1));
    f[id] = max(f[id], f[it] + 1);
  }
}

int mxd, mxeu, mxev;
int mnd = N, mneu, mnev;
diam mxu, mxv, mnu, mnv;
void dfs2(int id, int fa) {
  if(fa) {
    // cout << "dfs2 " << id << " " << fa << "\n";
    // g[id].print(), g[fa].print();
    int dist = g[id].d + g[fa].d + 1;
    if(dist > mxd) mxd = dist, mxu = g[id], mxv = g[fa], mxeu = id, mxev = fa;
    dist = max((g[id].d + 1 >> 1) + (g[fa].d + 1 >> 1) + 1, max(g[id].d, g[fa].d));
    if(dist < mnd) mnd = dist, mnu = g[id], mnv = g[fa], mneu = id, mnev = fa;
  }
  static chain fp[N], fs[N];
  static diam gp[N], gs[N];
  int sz = e[id].size();
  fp[0] = fs[sz + 1] = {id, 0};
  gp[0] = gs[sz + 1] = {id, id, 0};
  for(int i = 1; i <= sz; i++) {
    int it = e[id][i - 1];
    gp[i] = max(gp[i - 1], max(g[it], fp[i - 1] + f[it] + 1));
    fp[i] = max(fp[i - 1], f[it] + 1);
  }
  for(int i = sz; i; i--) {
    int it = e[id][i - 1];
    gs[i] = max(gs[i + 1], max(g[it], fs[i + 1] + f[it] + 1));
    fs[i] = max(fs[i + 1], f[it] + 1);
  }
  for(int i = 1; i <= sz; i++) {
    int it = e[id][i - 1];
    ff[it] = max(fp[i - 1], fs[i + 1]);
    gg[it] = max(max(gp[i - 1], gs[i + 1]), fp[i - 1] + fs[i + 1]);
  }
  for(int it : e[id]) if(it != fa) f[id] = ff[it], g[id] = gg[it], dfs2(it, id);
}

vector<int> pu, pv;
bool search(int id, int ff, int aim, vector<int> &arr) {
  arr.push_back(id);
  if(id == aim) return 1;
  for(int it : e[id]) if(it != ff && search(it, id, aim, arr)) return 1;
  arr.pop_back();
  return 0;
}

int main() {
  #ifdef ALEX_WEI
    FILE* IN = freopen("1.in", "r", stdin);
    FILE* OUT = freopen("1.out", "w", stdout);
  #endif
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  cin >> n;
  for(int i = 1; i < n; i++) {
    int u, v;
    cin >> u >> v;
    e[u].push_back(v), e[v].push_back(u);
  }
  dfs1(1, 0), dfs2(1, 0);
  cout << mnd << " " << mneu << " " << mnev << " ";
  search(mnu.u, 0, mnu.v, pu), search(mnv.u, 0, mnv.v, pv);
  cout << pu[mnu.d >> 1] << " " << pv[mnv.d >> 1] << "\n";
  cout << mxd << " " << mxeu << " " << mxev << " " << mxu.v << " " << mxv.u << "\n";
  return cerr << "Time: " << TIME << " ms\n", 0;
}
```

翻了一遍题解区发现 [SDNetFriend](https://www.luogu.com.cn/user/206258) 的做法非常巧妙。对于直径最小值，我们一定会断掉直径的一条边，所以只需以直径两端为根进行树形 DP。对于直径最大值，若断掉非直径上的边，则不包含直径的子树在直径两端 DP 时也已经求出，而包含直径的子树的直径即原树直径，以此避免较繁琐的换根 DP。

---

## 作者：ppp204 (赞：2)

这题好难想啊……最后还是看了好几篇题解才写出来的……

首先,在我们删掉一条边的时候,我们会得到两颗子树,它们有自己的直径

根据贪心的思想,最大值很好看出,即两棵树的直径相加再$+1$。而最小值其实就是把两棵树直径的中点链接,这样就能保证一整棵树的

关键在于如何去操作,这需要细心去体会

我们在这里先设定几个点

$dep[i]:~i$节点的深度

$rt[i]:$ 以$i$为根的子树的最长直径

$dis[i][j](j\in\{0,1,2\}):$ 分别表示从i节点向下的最长链，次长链，和次次长链

$dis2[i][j](j\in\{0,1\}):$ 分别表示以i节点的子节点为根的子树中最长直径和次长直径

$lian[i]:$ 把当前节点当做根节点的最长链长度

$f[i]:$ 存的父亲及节点

$g[i]:$ 表示删除$i$点与$f[i]$点之间的边后，以$1$为根的那棵树的最长直径

首先是$dfs1$

在$dfs1$里面,我们要进行更新的数组是$dis1,dis2$与$rt$，以便于后面$dfs2$的计算

在$dfs1$维护其实是挺简单的,这里就不细讲了(详情见代码)

关键在于$dfs2$

在$dfs2$,我们主要进行更新的数组是$g,lian$,并且顺便维护一下$ans\_max,ans\_min$

而如何去维护呢

首先,我们根据上面想到的答案,可以得到割掉当前点与他父亲之间的连线后再接,最长链肯定为$rt[x]+g[x]+1$,这时候进行比较即可,这样就更新好$ans\_max$了

而$ans\_min$略微难更新,因为他还要判断分开的**两棵树连在一起是否比这两棵树原本的直径还要长**,即这是我们树的直径为$max(max(rt[x],g[x]),(rt[x]+1)/2+(g[x]+1)/2+1)$,这之后再去更新$ans_min$即可

接下来就是更新$g,lian$这两个数组了

我们记当前访问到的子节点为$y$

1. 从dis更新

我们讨论当$y$为$x$的第一长链的情况

不难发现,此时$g[y]$可能为x的第二长链+第三长链,或者第二长链+向上走能最多走到的距离

而此时$lian[y]$又能小于x的第二长链+1(从第二长链叶子结点走上去再走到当前点)

得到

$lian[y]=max(max(lian[y],dis[x][1]+dis[x][2]),dis[x][1]+lian[x])$

同理,当它在第二长链或者第三长链或者更小的时候,也可以~~轻松地~~推出类似的方程

2. 从dis2更新

这中情况(我个人认为)比情况1难想。

这里以$y$在$dis2[x][0]$上为例

我们可以这样理解:**当这y与x隔开了以后,以1为根的直径不一定会走到x这里,但是此时在dis2[x][1]上面的x子节点是没有与x隔开的,因此以1为根的直径相当于以这个节点为根的直径**

因此我们可以得到

$lian[y]=max(lian[y],dis2[x][1])$

而$y$不再$dis2[x][0]$时,也类似得可以得出方程

这样,我们的$ans\_max$与$ans\_min$就出来了

最后,我们还要找到$ans$的最大值以及最小值所对应的要添加的边,那么该如何去添呢？

其实,找这两个点只需要找到删掉的边的那两个端点,再跑树的直径,找出满足树的直径的深度较小端点,向上走一般的距离后再连起来,$ans\_min$就出来了

而对于$ans\_max$,我们找到两个树的直径的端点,连起来就可以了

至此,整个问题就解决了(~~好麻烦~~)

#### Code:

```
#include<bits/stdc++.h>
using namespace std;
const int M=500005,oo=1e9;

/*

dep[i]：i节点的深度

rt[i]：以i为根的子树的最长直径

dis[i][j](j∈{0,1,2}):分别表示从i节点向下的最长链，次长链，和次次长链

dis2[i][j](j∈{0,1})：分别表示以i节点的子节点为根的子树中最长直径和次长直径

lian[i]：把当前节点当做根节点的最长链长度

f[i]：存的父亲及节点

g[i]：表示删除i点与fa[i]点之间的边后，以1为根的那棵树的最长直径

*/

int dep[M],f[M],rt[M],dis[M][5],dis2[M][5],g[M],lian[M];
int ans_max=-oo,ans_min=oo,x_max,y_max,x_min,y_min;
struct edge{
	int to,nxt;
}Edge[M<<1];
int head[M],tot;

void AddEdge(int x, int y){
	Edge[++tot]=(edge)<%y,head[x]%>;
	head[x]=tot;
}

inline int max(int x, int y){
	return x>y?x:y;
}

inline int min(int x, int y){
	return x<y?x:y;
}

void dfs1(int x, int fa){
	dep[x]=dep[fa]+1;
	f[x]=fa;
	for(int i=head[x]; i; i=Edge[i].nxt){
		int y=Edge[i].to;
		if(y==fa) continue;
		dfs1(y,x);
		rt[x]=max(rt[x],rt[y]); //更新
		int now=dis[y][0]+1;
		if(now>dis[x][0]){ //更新向下的最长链,次长链,第三链
			dis[x][2]=dis[x][1]; dis[x][1]=dis[x][0]; dis[x][0]=now;
		} else if(now>dis[x][1]){
			dis[x][2]=dis[x][1]; dis[x][1]=now;
		} else if(now>dis[x][2]) dis[x][2]=now;
		now=rt[y];
		if(now>dis2[x][0]){//更新子节点为根的情况
			dis2[x][1]=dis2[x][0]; dis2[x][0]=now;
		}else if(now>dis2[x][1]){
			dis2[x][1]=now;
		}
	}
	rt[x]=max(rt[x],dis[x][0]+dis[x][1]);
}

void dfs2(int x, int fa){
	if(x!=1){
		int now=g[x]+rt[x]+1;//分开这个点与他的父亲
		if(ans_max<now){
			ans_max=now; x_max=f[x]; y_max=x;
		}
		now=max(max(rt[x],g[x]),(rt[x]+1)/2+(g[x]+1)/2+1); //隔开来后第一棵树的直径/第二棵树的直径/两棵树合并后出现的新长链(树的直径的定义为最长链)
		if(ans_min>now){
			ans_min=now; x_min=f[x]; y_min=x;
		}
	}
	for(int i=head[x]; i; i=Edge[i].nxt){
		int y=Edge[i].to;
		if(y==fa) continue;
		lian[y]=max(lian[y],lian[x]+1);//更新最大能走距离
		g[y]=max(g[y],g[x]);//更新g
		int now=dis[y][0]+1;
		if(now==dis[x][0]){
			g[y]=max(max(g[y],dis[x][1]+dis[x][2]),dis[x][1]+lian[x]);//它的两条子链/它的一条子链+向上走的最长链
			lian[y]=max(lian[y],dis[x][1]+1);//不分开算
		}else if(now==dis[x][1]){
			g[y]=max(max(g[y],dis[x][0]+dis[x][2]),dis[x][0]+lian[x]);
			lian[y]=max(lian[y],dis[x][0]+1);
		}else{
			g[y]=max(max(g[y],dis[x][0]+dis[x][1]),dis[x][0]+lian[x]);
			lian[y]=max(lian[y],dis[x][0]+1);
		}
		now=rt[y];
		if(now==dis2[x][0]){//以1位根的直径不一定经过x,所以不能直接取max于x节点
			g[y]=max(g[y],dis2[x][1]);
		}else{
			g[y]=max(g[y],dis2[x][0]);
		}
		dfs2(y,x);
	}
}

bool mark[M];
queue<int>Q;

int bfs(int x){//找出以这个点为根的直径另一点
	int res=0;
	memset(mark,0,sizeof mark);
	Q.push(x); mark[x]=1;
	while(!Q.empty()){
		int now=Q.front(); Q.pop();
		res=now;
		for(int i=head[now]; i; i=Edge[i].nxt){
			int y=Edge[i].to;
			if(mark[y] || (now==x_min && y==y_min) || (now==y_min && y==x_min)) continue;
			Q.push(y); mark[y]=1;
		}
	}
	return res;
}

int Up(int x, int y, int z){ //GO UP
	int up=z;
	if(dep[x]<dep[y]) swap(x,y);
	while(up!=(z+1)/2){
		x=f[x]; up--;
	}
	return x;
}

void Print_Min(){//输出最小值
	printf("%d %d %d ",ans_min,x_min,y_min);
	int pointx=bfs(x_min),pointx1=bfs(pointx);
	int pointy=bfs(y_min),pointy1=bfs(pointy);
	printf("%d %d\n",Up(pointx,pointx1,g[y_min]),Up(pointy,pointy1,rt[y_min]));
}

void Print_Max(){//输出最大值
	printf("%d %d %d ",ans_max,x_max,y_max);
	memset(mark,0,sizeof mark);
	Q.push(x_max); mark[x_max]=1;
	while(!Q.empty()){
		int now=Q.front(); Q.pop(); x_max=now;
		for(int i=head[now]; i; i=Edge[i].nxt){
			int y=Edge[i].to;
			if(mark[y] || y==x_max || y==y_max) continue;
			mark[y]=1; Q.push(y);
		}
	}
	Q.push(y_max); mark[y_max]=1;
	while(!Q.empty()){
		int now=Q.front(); Q.pop(); y_max=now;
		for(int i=head[now]; i; i=Edge[i].nxt){
			int y=Edge[i].to;
			if(mark[y]) continue;
			mark[y]=1; Q.push(y);
		}
	}
	printf("%d %d\n",x_max,y_max);
}

int main(){
	int n;
	scanf("%d",&n);
	for(int i=1,x,y; i<n; i++){
		scanf("%d %d",&x,&y);
		AddEdge(x,y); AddEdge(y,x);
	}
	dfs1(1,0), dfs2(1,0);
	Print_Min(); Print_Max();
	return 0;
}
```

~~没想到洛谷的80分/90分是因为用了vector没用前向星~~

---

## 作者：Code_星云 (赞：1)

我们对断掉的每条边进行考虑。断边后，树会变成两颗。然后贪心选取，很容易得到以下结论：令两棵树的直径分别为 $d_u,d_v$，则加边后直径最大值为 $d_u+d_v+1$，最小值为 $\max(\lceil{\dfrac{d_u}{2}}\rceil+\lceil{\dfrac{d_v}{2}}\rceil+1, d_u,d_v)$。

维护两颗树的直径可以用换根 DP 实现，同时需要用前后缀来优化复杂度。具体的，令 $f_i$ 表示单边的最长链，$g_i$ 表示子树内的直径。更新时用 $f_u+f_{son}+1$ 更新 $g_u$，$f_{son}+1$ 更新 $f_u$ 即可。用结构体实现可能更方便。

这题最好用链式前向星，用 vector 好像只能拿 90。

```cpp
#include <cstdio>
#include <vector>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;

const int inf = 1e9;
const int N = 500005;
struct edges{int to, next;}; edges edge[N << 1];
struct fnode{
	int u, d;
	fnode operator + (const int &r1) const {return {u, d + r1};}
	bool operator < (const fnode &r1) const {return d < r1.d;}
};
struct gnode{
	int u, v, d;
	gnode operator + (const int &r1) const {return {u, v, d + r1};}
	bool operator < (const gnode &r1) const {return d < r1.d;}
};
gnode operator + (const fnode &r1, const fnode &r2){return {r1.u, r2.u, r1.d + r2.d};}
int n, maxn, maxd1, maxd2, minn, mind1, mind2, cnt, head[N]; vector<int> pu, pv;
fnode f[N], ff[N]; gnode g[N], gg[N], maxi1, maxi2, mini1, mini2;

void dfs(int u, int fa){
	f[u] = {u, 0}; g[u] = {u, u, 0};
	for(int i = head[u]; ~ i; i = edge[i].next){
		int v = edge[i].to;
		if(v == fa) continue; dfs(v, u);
		g[u] = max(g[u], max(g[v], f[u] + f[v] + 1));
		f[u] = max(f[u], f[v] + 1);
	}
}
int bar[N];
void changeroot(int u, int fa){
	if(fa){
		int tmp = g[u].d + g[fa].d + 1;
		if(tmp > maxn){maxn = tmp; maxd1 = u, maxd2 = fa; maxi1 = g[u]; maxi2 = g[fa];}
		tmp = max(max(g[u].d, g[fa].d), ((g[u].d + 1) / 2 + (g[fa].d + 1) / 2 + 1));
		if(tmp < minn){minn = tmp; mind1 = u; mind2 = fa; mini1 = g[u]; mini2 = g[fa];}
	}
	static fnode fp[N], fs[N];
	static gnode gp[N], gs[N];
	int m = 0;
	for(int i = head[u]; ~ i; i = edge[i].next) bar[++ m] = edge[i].to;
	fp[0] = fs[m + 1] = {u, 0};
	gp[0] = gs[m + 1] = {u, u, 0};
	for(int i = 1; i <= m; i ++){
		int x = bar[i];
		gp[i] = max(gp[i - 1], max(g[x], fp[i - 1] + f[x] + 1));
		fp[i] = max(fp[i - 1], f[x] + 1);
	}
	for(int i = m; i; i --){
		int x = bar[i];
		gs[i] = max(gs[i + 1], max(g[x], fs[i + 1] + f[x] + 1));
		fs[i] = max(fs[i + 1], f[x] + 1);
	}
	for(int i = 1; i <= m; i ++){
		int x = bar[i];
		ff[x] = max(fp[i - 1], fs[i + 1]);
		gg[x] = max(max(gp[i - 1], gs[i + 1]), fp[i - 1] + fs[i + 1]);
	}
	for(int i = head[u]; ~ i; i = edge[i].next){int v = edge[i].to; if(v != fa) f[u] = ff[v], g[u] = gg[v], changeroot(v, u);}
}
bool getpath(int u, int lst, int t, vector<int> &ps){
	ps.push_back(u); if(u == t) return true;
	for(int i = head[u]; ~ i; i = edge[i].next){int v = edge[i].to; if(lst != v && getpath(v, u, t, ps)) return true;}
	ps.pop_back(); return false;
}
void add_edge(int u, int v){
	edge[++ cnt].to = v; edge[cnt].next = head[u]; head[u] = cnt;
}
int main(){
	memset(head, -1, sizeof head);
	scanf("%d", &n); minn = inf;
	for(int i = 1; i < n; i ++){
		int u, v; scanf("%d %d", &u, &v); add_edge(u, v); add_edge(v, u);
    }
    dfs(1, 0); changeroot(1, 0);
    printf("%d %d %d ", minn, mind1, mind2);
    getpath(mini1.u, 0, mini1.v, pu); getpath(mini2.u, 0, mini2.v, pv);
    printf("%d %d\n", pu[mini1.d >> 1], pv[mini2.d >> 1]);
    printf("%d %d %d %d %d\n", maxn, maxd1, maxd2, maxi1.v, maxi2.u); return 0;
}
```


---

## 作者：Rorschachindark (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P3596)
# 题目大意
给出一个 $n$ 个点的树，可以修改一条边，问修改后的直径最大最小值，并输出方案。
# 思路
其实很简单，就是对于删掉每一条边，两棵子树维护一个最大直径即可。对于最长直径很显然是把直径连起来，最短直径很显然是把直径中点连起来。

至于维护直径，我们可以考虑使用换根 dp，我们可以在换根时只需要记录一下以这点出发的最长、次长、较次长链即可，然后再与之前的最长直径比较即可。

维护端点的话，还需要记录每个最优解是属于哪个子树的，这样才比较好判断。

至于为什么发这份题解，主要是因为这个题有点难调，而且自己的代码也比较简短，所以来分享一下。

时间复杂度显然 $\Theta(n)$，不过因为 SPJ 有问题，所以你得排个序才不会被卡，所以实际上是 $\Theta(n\log n)$ 得。
# $\texttt{Code}$
```cpp
#include <bits/stdc++.h>
using namespace std;

#define Int register int
#define MAXN 500005

template <typename T> inline void read (T &t){t = 0;char c = getchar();int f = 1;while (c < '0' || c > '9'){if (c == '-') f = -f;c = getchar();}while (c >= '0' && c <= '9'){t = (t << 3) + (t << 1) + c - '0';c = getchar();} t *= f;}
template <typename T,typename ... Args> inline void read (T &t,Args&... args){read (t);read (args...);}
template <typename T> inline void write (T x){if (x < 0){x = -x;putchar ('-');}if (x > 9) write (x / 10);putchar (x % 10 + '0');}
template <typename T> inline void Mx (T &a,T b){a = max (a,b);}
template <typename T> inline void Mi (T &a,T b){a = min (a,b);}

vector <int> G[MAXN];
int n,ans1,ans2 = MAXN,par[MAXN][21],dep[MAXN];

#define PII pair<int,int>

int f1[MAXN][2],f2[MAXN],f3[MAXN],f4[MAXN];
int pf1[MAXN][2],pf2[MAXN];PII pf3[MAXN],pf4[MAXN];
void dfs1 (int u,int fa){
	dep[u] = dep[fa] + 1,par[u][0] = fa;
	for (Int i = 1;i <= 20;++ i) par[u][i] = par[par[u][i - 1]][i - 1];
	pf1[u][0] = pf1[u][1] = u,pf3[u] = make_pair (u,u);
	for (Int v : G[u]) if (v ^ fa){
		dfs1 (v,u);if (f3[v] > f3[u]) f3[u] = f3[v],pf3[u] = pf3[v];
		if (f1[v][0] + 1 > f1[u][0]) pf1[u][1] = pf1[u][0],f1[u][1] = f1[u][0],pf1[u][0] = pf1[v][0],f1[u][0] = f1[v][0] + 1;
		else if (f1[v][0] + 1 > f1[u][1]) f1[u][1] = f1[v][0] + 1,pf1[u][1] = pf1[v][0];
	}
	if (f1[u][0] + f1[u][1] > f3[u]) f3[u] = f1[u][0] + f1[u][1],pf3[u] = make_pair (pf1[u][0],pf1[u][1]);
}

PII pans1,pans1d,pans2[2],pans2d;

void dfs2 (int u,int fa){
	if (fa){
		if (f3[u] + f4[u] + 1 > ans1) ans1 = f3[u] + f4[u] + 1,pans1 = make_pair (pf3[u].first,pf4[u].first),pans1d = make_pair (u,fa); 
		if (max ((f3[u] + 1) / 2 + (f4[u] + 1) / 2 + 1,max (f3[u],f4[u])) < ans2){
			pans2d = make_pair (u,fa),pans2[0] = pf3[u],pans2[1] = pf4[u];
			ans2 = max ((f3[u] + 1) / 2 + (f4[u] + 1) / 2 + 1,max (f3[u],f4[u]));
		}
	}
	int besx = f2[u],lesx = 0,wsex = 0;
	int pbesx = pf2[u],plesx = u,pwsex = u;
	int ins0[3] = {fa};
	for (Int v : G[u]) if (v ^ fa){
		if (f1[v][0] + 1 > besx) ins0[2] = ins0[1],pwsex = plesx,wsex = lesx,ins0[1] = ins0[0],plesx = pbesx,lesx = besx,ins0[0] = v,pbesx = pf1[v][0],besx = f1[v][0] + 1;
		else if (f1[v][0] + 1 > lesx) ins0[2] = ins0[1],pwsex = plesx,wsex = lesx,ins0[1] = v,plesx = pf1[v][0],lesx = f1[v][0] + 1;
		else if (f1[v][0] + 1 > wsex) ins0[2] = v,pwsex = pf1[v][0],wsex = f1[v][0] + 1;
	}
	int besl = f4[u],lesl = 0;
	PII pbesl = pf4[u],plesl = make_pair (u,u);
	int ins1[2] = {fa};
	for (Int v : G[u]) if (v ^ fa){
		if (f3[v] > besl) ins1[1] = ins1[0],plesl = pbesl,lesl = besl,ins1[0] = v,pbesl = pf3[v],besl = f3[v];
		else if (f3[v] > lesl) ins1[1] = v,plesl = pf3[v],lesl = f3[v];
	}
	for (Int v : G[u]) if (v ^ fa){
		if (f1[v][0] + 1 == besx && ins0[0] == v) f2[v] = lesx + 1,pf2[v] = plesx;
		else f2[v] = besx + 1,pf2[v] = pbesx;
		if (ins0[0] == v) f4[v] = lesx + wsex,pf4[v] = make_pair (plesx,pwsex);
		else if (ins0[1] == v) f4[v] = besx + wsex,pf4[v] = make_pair (pbesx,pwsex);
		else f4[v] = besx + lesx,pf4[v] = make_pair (pbesx,plesx);
		if (ins1[0] == v && lesl > f4[v]) f4[v] = lesl,pf4[v] = plesl;
		if (ins1[0] != v && besl > f4[v]) f4[v] = besl,pf4[v] = pbesl;
		dfs2 (v,u);
	} 
}

int LCA (int u,int v){
	if (dep[u] < dep[v]) swap (u,v);
	for (Int dis = dep[u] - dep[v],i = 20;~i;-- i) if (dis >> i & 1) u = par[u][i];
	if (u == v) return u;
	else{
		for (Int i = 20;~i;-- i) if (par[u][i] ^ par[v][i]) u = par[u][i],v = par[v][i];
		return par[u][0];
	}
}

int Jump (int u,int k){
	for (Int i = 20;~i;-- i) if (k >> i & 1) u = par[u][i];
	return u;
}

int dist (int u,int v){
	return dep[u] + dep[v] - dep[LCA (u,v)] * 2;
}

int Get (int x,int y){
	int lca = LCA (x,y),dis = dist (x,y);
	if (dep[x] - dep[lca] >= dis / 2) return Jump (x,dis / 2);
	else return Jump (y,dis - (int)dis / 2);
}

signed main(){
	read (n);
	for (Int i = 2,u,v;i <= n;++ i) read (u,v),G[u].push_back (v),G[v].push_back (u);
	for (Int i = 1;i <= n;++ i) sort (G[i].begin(),G[i].end());
	dfs1 (1,0),pf2[1] = 1,dfs2 (1,0);
	write (ans2),putchar (' '),write (pans2d.first),putchar (' '),write (pans2d.second),putchar (' ');
	write (Get (pans2[0].first,pans2[0].second)),putchar (' '),write (Get (pans2[1].first,pans2[1].second)),putchar ('\n');
	write (ans1),putchar (' '),write (pans1d.first),putchar (' '),write (pans1d.second),putchar (' '),write (pans1.first),putchar (' '),write (pans1.second),putchar ('\n');
	return 0;
}
```

---


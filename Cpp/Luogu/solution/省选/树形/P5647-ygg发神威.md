# ygg发神威

## 题目背景

ygg 发神威了，机房的萌新们瑟瑟发抖。

## 题目描述

ygg 的机房内共有 $n$ 台电脑且都被使用，为了节省机房内电脑的开销，第 $i$ 台电脑会同时被 $a_i$ 个萌新使用。每台电脑都装有一个「多人在线交流平台」，一台电脑会直接地或间接地通过这个平台与其他所有电脑连接。由于「多人在线交流平台」仍然处于测试阶段，如果一台电脑有多于一种不同的消息传输方式将消息传输到另外的任意一台电脑，就会有各种稀奇古怪的问题产生。两种消息的传输方式被认为是不同的，当且仅当传输消息所经过的直接连接的线路的集合不同，或者传输所经过的电脑的集合不同。当然，消息的传输肯定不会经过一条线路多次。为了避免这种状况，「多人在线交流平台」的线路被特殊地设计了，以使得任意两台电脑之间的传输线路唯一。同时，为了防止一台电脑负荷过大，一台电脑最多会通过「多人在线交流平台」的线路与 $p$ 台电脑相连。

原本两台通过「多人在线交流平台」的线路相连的电脑之间可以相互传输数据，可是 ygg 发现，这会允许使用两台电脑的萌新们互相发送消息，引起大规模~~考试作弊~~膜拜 ygg 的行为。所以他大发神威，切断了所有连接线路的一半。具体地，他将原本通过「多人在线交流平台」的双向线路连接的两台电脑之间的线路变成了单向线路。即，原本通过一条双向线路连接的两台电脑中，只能有一台电脑向另一台电脑发送消息，而另一台电脑不能将任何消息发送回来。

机房内的萌新们在每个时刻都有若干条消息需要传递。如果一台电脑 $i$ 能够直接或间接地通过「多人在线交流平台」的线路连接到电脑 $j$，那么使用电脑 $i$ 的 $a_i$ 个萌新中的任何一个都可以向使用电脑 $j$ 的 $a_j$ 个萌新发送消息。显然，使用同一台电脑的萌新之间的消息只需要在线下传达，不需要使用「多人在线交流平台」，因此不会计入线上发送的消息。

其实机房中的萌新们早已知道了「多人在线交流平台」的管理员密码，所以能够对其线路的连接方向做出修改。可无论他们怎么尝试，都不能恢复最开始时双向连接的状态了。机房中的萌新们当然希望能够尽可能地发送消息，所以他们想要知道，在机房的电脑仅被单向的线路连接时，每一时刻最多能有多少条消息被通过「多人在线交流平台」发送。

为了简化问题，我们假设机房内的所有萌新均能够在同一时刻发送线上消息，并且每一个萌新可以同时向多个人发送消息。

**简要题面：给一棵结点编号** $1\sim n$**，结点权值** $a_i$**，且结点度数最大为** $p$ **的树。求将树的每条边改为有向边后下式的最大值：**

$$\sum_{i=1}^{n}\sum_{j=1}^{n}a_ia_j\left[i\rightarrow j\right]$$

$\left[i\rightarrow j\right]$ **定义为：若编号为** $i$ **的结点能通过有向边到达编号为** $j$ **的结点，则值为** $1$**；否则值为** $0$**，且** $\left[i\rightarrow i\right]=0$**。**

## 说明/提示

### 样例解释

能够发送的消息最多时的消息传递方向如下：

![](https://i.loli.net/2019/10/30/3AsqcyzdY25E8gP.png)

在该连接方式下发送消息最多的时刻，使用 $1$ 号电脑的 $1$ 个萌新向 $5$ 个萌新各发送了一条消息，共 $1\times5=5$ 条消息；  
使用 $2$ 号电脑的 $2$ 个萌新分别向 $3$ 个萌新各发送了一条消息，共 $2\times3=6$ 条消息；  
使用 $3$ 号电脑的 $3$ 个萌新不能向任何萌新发送线上消息，因此没有消息从该电脑发送；  
使用 $4$ 号电脑的 $4$ 个萌新分别向 $6$ 个萌新各发送了一条消息，共 $4\times6=24$ 条消息。  
因此，在某一时刻，最多可以有 $5+6+24=35$ 条线上消息被发送。   
可以使用枚举法验证，不存在一种单向的连接方式，使得在某一时刻发送的线上消息的数量能够达到 $36$ 条或更多。

### 数据范围及约定

对于 $10\%$ 的数据，$n\le10$；  
对于另外 $10\%$ 的数据，$n=p+1$；  
对于另外 $10\%$ 的数据，$p=2$；  
对于另外 $10\%$ 的数据，$p\le20$；  
对于另外 $10\%$ 的数据，$p\le40$；  

对于所有数据，$2\le n\le10^5$，$2\le p\le50$，$1\le a_i\le100$，$1\le u_i,v_i\le n$。保证给出的双向连接线路能够使任意两台电脑之间的消息传输线路唯一。保证至少有一台电脑原本通过「多人在线交流平台」连接的线路数恰好为 $p$，且没有电脑原本连接的线路数大于 $p$。

## 样例 #1

### 输入

```
4 2
1 2 3 4
1 2
3 2
4 1
```

### 输出

```
35
```

# 题解

## 作者：Daniel13265 (赞：11)

$\text{Upd.}\ 06/02/2020.$ 更新了题面与题解。

---

### $n\le10$

暴力枚举每条边的方向，然后判断每个点能到达的点记入答案即可。时间复杂度 $\mathcal O\left(2^n\times n^2\right)$。

### $p=n-1$

树是一个菊花图。考虑到树的一条边连接的两个点一定会对答案产生一倍的贡献，所以单独计算。所以只需要将除了菊花图的中心的点以外的点分成两组，使两组的权值之和的积最大。由于这两组的权值和是固定的，所以只需要将这两组数分得尽量平均。使用 01 背包即可，时间复杂度 $\mathcal O\left(n\times a_i\right)$ 。

### $p=2$

树是一条链。观察要求的式子：由于边被改为了单向边，因此 $\left[i\rightarrow j\right ]$ 与 $\left[j\rightarrow i\right ]$ 中最多只有一个为 $1$ 。如果所有边方向相同，那么可以保证对于所有的 $i$ 和 $j$ ，都有 $\left[i\rightarrow j\right ]+\left[j\rightarrow i\right ]=1$ 。此时一定能够取得最大值。直接计算即可。时间复杂度 $\mathcal O\left(n\right)$ 。

### $p\le20$

考虑到**如果将一棵子树的所有边的方向全部翻转过来，整棵树内部产生的贡献是不变的。**然后我们就可以发现：分别以树的每一个结点为根，对于当前的根结点所有子结点，以这些结点为根的子树内部的边的方向分别与该结点与根结点的边的方向相同时产生的贡献的最大值就是答案。边的方向相同指两条边在以当前结点为根时均为由深度小的指向深度大的，或均为由深度大的指向深度小的。

画个图理解：

![](https://i.loli.net/2019/11/10/F2J1I3xGyelDQ75.png)

就是说，以 $1$ 号结点为根，那么在 $2,3,4$ 号结点所在的子树的所有边的方向分别相同时，可以得到多个解，取一个最优的。如果将以每个结点为根时得到的解再取最优值，就一定是答案。

举个例子：我们假设以 $1$ 号结点为根，并且连接 $5,8$ 号结点的边的方向不满足该结论。首先我们通过至多一次翻转操作将整棵树翻转一下使得 $5,8$ 号结点所在的子树的边的方向为从深度小的至深度大的。如果当前状态更优，就一定有 $a_6+a_7\ge a_1+a_2+a_4 >a_4$ 。如果存在这样的一个 $3$ 号结点使得连接 $1,3$ 号结点的边的方向像图中这样，那么会有 $a_4\ge a_2+a_5+a_6+a_7>a_6+a_7$ ，两者矛盾。所以此时一定就不存在这样的 $1,3$ 的连接方式。显然，这种情况会在以 $5$ 号结点为根时讨论到。

可以多举几个例子来说明这种看似错误的贪心算法其实是正确的，具体证明可以使用网络流建模，这里不再展开。

因此我们只需要枚举每个结点，再枚举每棵子树的方向，在求得的答案中取最大值即可。时间复杂度 $\mathcal O\left(n\times2^p\right)$，无法通过。

再考虑如果已经算出一个结点的答案，以及它的若干个子树分别的权值之和。那么可能更优的答案仅在它的权值之和最大的子树里，因为在权值之和小的子树中，包含原来的根结点的子树一定的权值之和一定会大于其余子树之和的一半，这样会使得将新的根结点的所有其他子树加起来没有原来的根结点所在的子树的权值大小大，答案一定不优。于是我们不断向加权后最大的子树转移即可。

因此我们只需要求出树的加权重心，直接计算以树的重心为根时的答案即可。时间复杂度 $\mathcal O\left(n+2^p\right)$ 。

### $p\le40$

上面的算法时间复杂度劣在枚举各个子树的方向，即枚举每个数选或者不选。而如果像 $\text{subtask } 2$ 那样使用 $01$ 背包求解，会发现权值过大，因此我们需要找到一种更快速的解法。

观察到 $P\leq 40$ ，于是我们可以折半枚举，将前 $\left\lfloor\frac P2\right\rfloor$ 个数可能的和存入数组中排序，然后将后 $\left\lceil\frac P2\right\rceil$ 个数可能的和计算出来在之前的数组中二分查找即可。时间复杂度 $\mathcal O\left(n+2^{\frac p2}p\right)$，

### 无特殊限制

我们发现以上解法依旧很劣，因此我们需要继续优化。准确地，我们急需一种数据结构来维护一个集合，并能够支持快速地插入一个数与查找一个数的前驱后继。于是我们想到了[这个](https://www.luogu.com.cn/problem/P6301)，直接维护即可，具体实现请参考该题题解。时间复杂度  $\mathcal O\left(n+2^{\frac p2}\log_\omega{na_i}\right)$。

---


# [YsOI2020] 造林

## 题目背景

「承前」

Ysuperman 响应号召，决定在幼儿园外造林。

呐呐，如果这样的话，Ysuperman 便能在这炎热的夏天与小朋友们玩游戏了呢。

## 题目描述

为了落实环保工作，Ysuperman 购进了一批树，它们都长一个样。由于树还没有种下去，所以这些树还没有根，可以认为是**无根树**。

Ysuperman 觉得全都种长得一样的树太无聊了，于是 TA 请到了园艺公司帮 TA 规划。园艺公司提供给了 TA 一个方法——「嫁接」。

下面给出「嫁接」操作的定义：

定义「叶子节点」为树上度数为 $1$ 的节点。
 
「嫁接」操作指：在一棵**无根树**上接入一个新的「叶子节点」。

例如：  
![](https://cdn.luogu.com.cn/upload/image_hosting/jfaksqwy.png)

图 2 是由图 1 的树进行一次合法的嫁接操作后得到的树，图 3 也是由图 1 的树进行一次合法的嫁接操作后得到的树。

那么，我们还知道，树有一个基本属性：「品种」。

一棵树的「品种」是指**每个点的最大子树大小所构成的可重集**。

两棵树的「品种」不同，当且仅当**每个点的最大子树大小所构成的可重集不同**。

这里的一个点的**最大子树大小**指将这个点删掉后**最大的联通块所包含的点数**。

例如：  
![](https://cdn.luogu.com.cn/upload/image_hosting/zzyznfl7.png)

图 4 的树的每个点的最大子树大小所构成的可重集为：$ \{ 2,2,3,3 \} $  
图 5 的树的每个点的最大子树大小所构成的可重集为：$ \{ 2,2,3,3 \} $  
图 6 的树的每个点的最大子树大小所构成的可重集为：$ \{ 1,3,3,3 \} $  
所以说，图 4 的树与图 5 的树「品种」相同，与图 6 的树「品种」不同。

Ysuperman 想知道，通过一次「嫁接」操作，可以构造出的树包含多少不同的「品种」，以及对于每个「品种」，有多少不同的「嫁接」方法可以构造。请**从小到大**输出每个「品种」的「嫁接」方法数。

两个「嫁接」方案不同，当且仅当在「嫁接」操作中与新接入的「叶子节点」直接相连的点不同。


## 说明/提示

**本题采用捆绑测试。**
### 样例解释 1
可以构造出 1 种「品种」为 $\{2,4,4,5,5,5\}$ 的树。  
可以构造出 2 种「品种」为 $\{3,3,4,5,5,5\}$ 的树。  
可以构造出 2 种「品种」为 $\{3,3,4,4,5,5\}$ 的树。
### 样例解释 2
可以构造出 1 种「品种」为 $\{3,5,5,7,7,7,7,7\}$ 的树。  
可以构造出 2 种「品种」为 $\{4,4,5,7,7,7,7,7\}$ 的树。  
可以构造出 4 种「品种」为 $\{4,4,5,6,7,7,7,7\}$ 的树。


对于 100% 的数据，满足 $1 \le n\le2\cdot 10^6$。

定义「链」为所有节点度数不超过 $2$ 的树。  
定义「菊花」为包含 $n-1$ 个「叶子节点」的树。

特殊性质 1：保证树的形态为一条「链」。  
特殊性质 2：保证树的形态为一朵「菊花」。  
特殊性质 3：保证树的形态为一棵完全二叉树。

| subtask | $n$ | 特殊性质 | 分值 | 时间限制 |
| :-----------: | :-----------: | :-----------: | :--------:| :---------:|
| 1 | $\le 2\cdot 10^6$ | 2 | 2 | 4s |
| 2 | $\le 2\cdot 10^6$ | 1 | 3 | 4s |
| 3 | $\le 300$ | 无 | 5 | 1s |
| 4 | $\le 2\cdot10^6$ | 3 | 7 | 4s |
| 5 | $\le 5000$ | 无 | 23 | 1s |
| 6 | $\le 5\cdot10^4$ | 无 | 29 | 2s |
| 7 | $\le 2\cdot10^6$ | 无 | 31 | 4s |

### 提示：

如果你不知道完全二叉树是什么意思，Ysuperman 提供了一个链接：[Link](https://zh.wikipedia.org/zh/%E4%BA%8C%E5%8F%89%E6%A0%91#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91)。

输入输出较大，请使用较快的输入输出方式。

如果您使用了所需栈空间较大的递归算法，可以在本地（NOI linux 下）先使用 ```sudo su``` 获取权限，再使用 ```ulimit -s unlimited ``` 命令开启无限栈。

题目并不难。

## 样例 #1

### 输入

```
5
1 2
2 3
3 4
4 5
```

### 输出

```
3
1
2
2
```

## 样例 #2

### 输入

```
7
1 2
1 3
2 4
2 5
3 6
3 7
```

### 输出

```
3
1
2
4
```

## 样例 #3

### 输入

```
25
15 9
22 15
23 22
25 15
13 23
6 22
12 15
1 23
19 13
18 9
11 15
17 1
4 25
3 1
8 9
20 1
10 18
21 20
16 8
2 22
24 1
7 19
5 16
14 7
```

### 输出

```
17
1
1
1
1
1
1
1
1
1
1
2
2
2
2
2
2
3
```

# 题解

## 作者：clamee (赞：3)

~~因为上次 T1 是"植树"，所以这次 T1 为"造林"。~~

由于本题的算法真包含了植树所要用的求最大子树大小的方法，不会的可以[左转](https://www.luogu.com.cn/problem/P6591)，进行学习。

可能这道题目相对于别的比赛的 T1 而言稍微有点难，但好像别的题都没这题可做的样子。

菊花图做法：

容易发现只有两种不同「品种」的树。

方案数分别为 1 和 n-1，需要特判边界条件。
```
	n=read();
	if(n==2)
	{
		puts("1\n2");
		return 0;
	}
	write(2-(n==1));
	puts("");
	write(1);
	puts("");
	if(n>1)write(n-1);
```


链做法：

容易发现方案数为 (n+1)/2，

具体各种方案的数量也较为显然。
```
	n=read();
	write((n+1)/2);puts("");
	if(n&1)write(1),puts("");
	for(int i=1;i<=n/2;i++)
		write(2),puts("");
```

 

$n\le 300$：

 暴力加叶子，暴力判断。  
 或 $n^2\log_2n$ 做法，即 subtask 5 解法在排序时使用基于比较的排序算法。



完全二叉树做法：

容易发现树高为 log，而且常数较小，使用正解方法不用 hash 可通过。



$n\le 5000$：

枚举叶子位置连接的位置暴力树形 dp ，hash 求方案。
```
#include<bits/stdc++.h>
using namespace std;

#define rg register
#define il inline
#define M1 998244353
#define M2 950009857
#define M 4999963
#define MM 1000000007
#define N 2000005

int sz[N],mxsz[N],n,head[N],tot,cnt[N],ans[N];
int t1=0,tt,lans,rt1,rt2,t2=0;
int g1[M],g2[M],s[M];
struct ss{
	int node,nxt;
}e[N<<1];

il int read();
il void write(int x);
il void add(int u,int v);
il int find(int x,int tx,int ty);
il void addh(int x,int y);
il void redo();

void dfs(int x,int fa);
void sol();

int main()
{
	freopen("forest.in","r",stdin);
	freopen("forest.out","w",stdout);
	n=read();
	for(rg int i=1,u,v;i<n;i++)
	{
		u=read();v=read();
		add(u,v);
		add(v,u);
	}
	sol();
	for(rg int i=0;i<M;i++)
		if(s[i])ans[s[i]]++,lans++;
	write(lans);
	for(rg int i=1;i<=n;i++)
	{
		if(!ans[i])continue;
		while(ans[i]--)
		{
			puts("");
			write(i);
		}
	}
	return 0;
}

il int read()
{
	int re=0,k=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')k=-1;ch=getchar();}
	while(ch<='9'&&ch>='0'){re=re*10+ch-48;ch=getchar();}
	return re*k;
}

il void write(int x)
{
	if(x<0){putchar('-');write(-x);return;}
	if(x<10)return putchar(x+48),void();
	return write(x/10),write(x%10),void();
}

void dfs(int x,int fa)
{
	sz[x]=1;
	//if(x==n+1)cerr<<x<<" "<<fa<<endl;
	for(rg int i=head[x];i;i=e[i].nxt)
	{
		int y=e[i].node;
		if(y==fa)continue;
		dfs(y,x);
		sz[x]+=sz[y];
		if(sz[y]>mxsz[x])
			mxsz[x]=sz[y];
	}
	if(n+1-sz[x]>mxsz[x])
		mxsz[x]=n+1-sz[x];
	return;
}

il void add(int u,int v)
{
	e[++tot].nxt=head[u];
	e[tot].node=v;
	head[u]=tot;
	return;
}

il void redo()
{
	tot-=2;
	head[e[head[n+1]].node]=e[head[e[head[n+1]].node]].nxt;
	head[n+1]=0;
}

void sol()
{
	for(int i=1;i<=n;i++)
	{
		add(i,n+1);
		add(n+1,i);
		for(int j=1;j<=n+1;j++)
			ans[j]=mxsz[j]=0;
		//cerr<<i;
		dfs(1,0);
		//cerr<<i<<endl;
		for(int j=1;j<=n+1;j++)
			ans[mxsz[j]]++;
		int h1=0,h2=0;
		for(int j=1;j<=n+1;j++)
		{
			while(ans[j])
			{
				h1=(1ll*h1*M1+j)%M;
				h2=(1ll*h2*M2+j)%MM;
				ans[j]--;
			}
		}
		addh(h1,h2);
		redo();
	}
}

int find(int x,int tx,int ty)
{
	if(!g1[x])return g1[x]=tx,g2[x]=ty,x;
	if(g1[x]==tx&&g2[x]==ty)return x;
	return find((x+31)%M,tx,ty);
}

void addh(int x,int y)
{
	s[find(x,x,y)]++;
	return;
}
```


$n\le 5e4$：

防正解被卡常。



$n\le 2e6$：

容易发现每增加一个叶子不会改变最大子树大小的只有一条链。

例如如图所示的树：  
![](https://cdn.luogu.com.cn/upload/image_hosting/gp9bcm0v.png)

可以发现，在节点 7 连接一个叶子时最大子树大小不会改变的大子树大小不会改变的链只有 10-1-7 ，即在 7 号节点接上一个叶子后， 10,1,7 三个节点的最大子树大小不变，其它点的最大子树大小加 1。

在节点 1 连接一个叶子时最大子树大小不会改变的链只有 10-1

在节点 10 连接一个叶子时最大子树大小不会改变的链只有 10

……



画下图就会发现一个性质：

对于一个点，如果它在重心的最大子树内，那么不会改变的链为重心的孩子到它的一条链。

否则，不会改变的链为重心到它的一条链。



发现这个性质以后，问题就简化了不少。



考虑如果用树形 dp 求出所有的这样的链，考虑两个方案一样，当且仅当两条链上每个点的最大子树大小一一对应。

将每个节点的最大子树大小当成字符，题目变为在给定树上问有多少条从根到一个点使得路径上的字符所构成的字符串不同，以及这样的字符串有多少个。这样就能字符串 hash 求解了。  
根据生日悖论，单 hash 有极大概率被卡，故要用双 hash，或其他更好的hash 方式。


用 hash 表统计答案即可，复杂度为 $O(n)$。

排序可以使用计数排序或桶排序来做到 $O(n)$，直接 sort 也可以通过本题。

```
#include<bits/stdc++.h>
using namespace std;

#define rg register
#define il inline
#define M1 998244353
#define M2 950009857
#define M 4999963
#define MM 1000000007
#define N 2000005

int sz[N],mxsz[N],n,head[N],tot,cnt[N],ans[N];
int t1=0,tt,lans,rt,t2=0;
int g1[M],g2[M],s[M];
struct ss{
	int node,nxt;
}e[N<<1];

il int read();
il void write(int x);
il int find(int x,int tx,int ty);
il void addh(int x,int y);
il void add(int u,int v);

void dfs(int x,int fa);
void redfs(int x,int fa,int rt);

int main()
{
	n=read();
	for(int i=1,u,v;i<n;i++)
	{
		u=read();v=read();
		add(u,v);
		add(v,u);
	}
	mxsz[0]=0x3f3f3f3f;
	dfs(1,0);
	redfs(rt,0,rt);
	for(int i=0;i<M;i++)
		if(s[i])ans[s[i]]++,lans++;
	write(lans);
	for(int i=1;i<=n;i++)
	{
		if(!ans[i])continue;
		while(ans[i]--)
		{
			puts("");
			write(i);
		}
	}
	return 0;
}

il int read()
{
	int re=0,k=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')k=-1;ch=getchar();}
	while(ch<='9'&&ch>='0'){re=re*10+ch-48;ch=getchar();}
	return re*k;
}

il void write(int x)
{
	if(x<0){putchar('-');write(-x);return;}
	if(x<10)return putchar(x+48),void();
	return write(x/10),write(x%10),void();
}

int find(int x,int tx,int ty)
{
	if(!g1[x])return g1[x]=tx,g2[x]=ty,x;
	if(g1[x]==tx&&g2[x]==ty)return x;
	return find((x+31)%M,tx,ty);
}

void addh(int x,int y)
{
	s[find(x,x,y)]++;
	return;
}

void dfs(int x,int fa)
{
	sz[x]=1;
	for(int i=head[x];i;i=e[i].nxt)
	{
		int y=e[i].node;
		if(y==fa)continue;
		dfs(y,x);
		sz[x]+=sz[y];
		if(sz[y]>mxsz[x])
			mxsz[x]=sz[y];
	}
	if(n-sz[x]>mxsz[x])
		mxsz[x]=n-sz[x];
	if(mxsz[x]<mxsz[rt])
		rt=x;
	return;
}

void redfs(int x,int fa,int rt)
{
	int tt1=t1,tt2=t2;
	t1=(1ll*t1*M1+mxsz[x])%M;
	t2=(1ll*t2*M2+mxsz[x])%MM;
	addh(t1,t2);
	for(int i=head[x];i;i=e[i].nxt)
	{
		int y=e[i].node;
		if(y==fa)continue;
		if(n-mxsz[y]==mxsz[x]&&x==rt)
			t1=t2=0;
		redfs(y,x,rt);
		if(n-mxsz[y]==mxsz[x]&&x==rt)
			t1=t2=mxsz[x];
	}
	t1=tt1;t2=tt2;
	return;
}

void add(int u,int v)
{
	e[++tot].nxt=head[u];
	e[tot].node=v;
	head[u]=tot;
	return;
}
```

最后说句题外话，为什么你古的评测机这么慢啊，我本地用 lemon 测 1s 内就可以跑完的代码这里要跑 2s。

---

## 作者：_Arahc_ (赞：2)

考了学长出的这一套 YsOI，被卡哈希了，100 分怒变 9 分。@_@

## 题意

给定一个树，定义一个节点的权值为删去这个节点后的图中最大连通块的大小。定义树的品种为所有节点权值构成的可重集，两树品种相同当且仅当可重集相同。

现在要给这个树加一个叶子，求能得到多少品种的树，以及每个品种有多少种添加方法得到。

$n\leq2\times10^6$，时限 4s。

## 题解

显然，对于一个不是重心的节点，删掉这个点后的连通块里面，最大的连通块就是包含重心的连通块。因此如果叶子添加在重心头上，别的点权值都要加一，重心不变。（对于两个重心的情况，在一个重心上加点时，显然另一个重心权值是要加一的。）

考虑如果不加在重心上。注意到上面提到的性质，哪些节点的权值会改变（如图 1，3 号节点是重心，把它当作根）：

![图 1](https://pic.imgdb.cn/item/62c4dec95be16ec74a9ed07b.png)

假设我们向 9 号节点添加一个叶子，来分类讨论。

1. 和被添加叶子的点不在同一子树（如 1,2,6,7 号点），显然权值都会加一。
2. 和被添加叶子点在同一侧，不在这个点到根的路径上（如 5,10 号点），考虑到删掉后其最大连通块是根的那一侧，因此权值也会加一。
3. 重心（如 3 号点），若被添加叶子点在重心的最大子树内，则重心权值加一；否则不变。
4. 被添加叶子节点本身（如 9 号点），显然不变。
5. 重心和被添加叶子点路径上的点（如 4 号点），因为删掉它后新叶子没有连通到根，所以不变。

总结一下，如果新叶子在重心的最大子树内，不会改变的就是重心到它的链（不包括两端）；否则，不会改变的是重心到它的链（包括重心，不包括被添加节点）。

我们要维护的是所有点贡献的集合，考虑从重心出发深搜整颗树，到达一个点时，只需要修改这一个点的贡献即可。可以用 Hash 实现。

注意到集合是无序的，如果和我考场降智 naive 地用每个点权值的 $k$ 次方和（$k$ 为常量）当 Hash 函数，注意到 $a^k + b^k = c^k$ 在 $k\leq\log\max(a,b,c)$ 时分布不少，很大概率被卡掉。因此考虑维护每个点权值构成的桶，对这个桶进行字符串 Hash 即可。

单 Hash 也被卡了（我运气背还是出题人毒瘤还是生日悖论再现都有可能），建议双 Hash，我用的双模 Hash + 双底数。

剩下的都是一些细节问题，例如两个重心的情况，可以考虑断掉中间的边，拆成两棵树考虑（在一棵树上时反正另一棵树点的贡献都是要加一的），等等。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
bool Begin;
const int max_n=2000006,mod1=1000000009,mod2=998244853;
inline int read(){
    int x=0;bool w=0;char c=getchar();
    while(c<'0' || c>'9') w|=c=='-',c=getchar();
    while(c>='0' && c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();
    return w?-x:x;
}
inline void write(int x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10^48);
}
struct graph{
    int ct,hd[max_n],to[max_n<<1],nx[max_n<<1];
    graph(){ct=1;}
    inline void add(int u,int v){
        nx[++ct]=hd[u],hd[u]=ct,to[ct]=v;
    }
}e;
inline int MOD1(int x){
    return (x>=mod1?x-mod1:x);
}
inline int MOD2(int x){
    return (x>=mod2?x-mod2:x);
}
struct Hashnum{
    int x1,x2;
    Hashnum(int A=0,int B=0):x1(A),x2(B){}
    bool operator == (const Hashnum &b) const{
        Hashnum a=*this;
        return (a.x1==b.x1 && a.x2==b.x2);
    }
    bool operator < (const Hashnum &b) const{
        Hashnum a=*this;
        return (a.x1<b.x1 || (a.x1==b.x1 && a.x2<b.x2));
    }
    Hashnum operator * (const Hashnum &b) const{
        Hashnum a=*this;
        return Hashnum(a.x1*b.x1%mod1,a.x2*b.x2%mod2);
    }
    Hashnum operator + (const Hashnum &b) const{
        Hashnum a=*this;
        return Hashnum(MOD1(a.x1+b.x1),MOD2(a.x2+b.x2));
    }
    Hashnum operator - (const Hashnum &b) const{
        Hashnum a=*this;
        return Hashnum(MOD1(a.x1-b.x1+mod1),MOD2(a.x2-b.x2+mod2));
    }
    Hashnum operator * (const int &b) const{
        Hashnum a=*this;
        return a*Hashnum(b,b);
    }
    Hashnum operator + (const int &b) const{
        Hashnum a=*this;
        return a+Hashnum(b,b);
    }
    Hashnum operator - (const int &b) const{
        Hashnum a=*this;
        return a-Hashnum(b,b);
    }
}hs;

int n,sz[max_n],mxs[max_n];

inline void dfs1(int u,int fa){
    sz[u]=1;
    for(register int i=e.hd[u];i;i=e.nx[i]){
        int v=e.to[i];
        if(v==fa) continue;
        dfs1(v,u);
        sz[u]+=sz[v];
        mxs[u]=max(mxs[u],sz[v]);
    }
    mxs[u]=max(mxs[u],n-sz[u]);
}
int zx,zx2;
inline void dfs2(int u,int fa){
    zx=u;
    for(register int i=e.hd[u];i;i=e.nx[i]){
        int v=e.to[i];
        if(v==fa) continue;
        if(sz[v]>n/2)
            dfs2(v,u);
    }
}

int ans[max_n],tong[max_n],pw1[max_n],pw2[max_n];

int B1=114514,B2=11037;

map<Hashnum,int> mp;
inline void dfs3(int u,int fa,Hashnum hs){
    for(register int i=e.hd[u];i;i=e.nx[i]){
        int v=e.to[i];
        if(v==fa || v==zx || v==zx2) continue;
        Hashnum t=hs-Hashnum(pw1[mxs[v]+1],pw2[mxs[v]+1])+Hashnum(pw1[mxs[v]],pw2[mxs[v]]);
        ++mp[t];
        dfs3(v,u,t);
    }
}

bool End;
#define File "forest"
signed main(){
    // #ifndef ONLINE_JUDGE
    // freopen(File ".in","r",stdin);
    // freopen(File ".out","w",stdout);
    // #endif
    // cerr<<"Memory : "<<(&Begin-&End)/1024.0/1024<<"\n";
    n=read();
    for(register int i=1;i<n;++i){
        int u=read(),v=read();
        e.add(u,v),e.add(v,u);
    }
    dfs1(1,-1);
    dfs2(1,-1);
    for(register int i=1;i<=n;++i)
        ++tong[mxs[i]+1];
    ++tong[n];
    if(!(n&1)) for(register int i=1;i<=n;++i)
        if(i!=zx && mxs[i]==mxs[zx]){
            zx2=i;
            break;
        }
    for(register int i=1;i<=n;++i){
        hs.x1=(hs.x1*B1+tong[i]),
        hs.x2=(hs.x2*B2+tong[i]);
    }
    pw1[n]=pw2[n]=1;
    for(register int i=n-1;i;--i){
        pw1[i]=pw1[i+1]*B1%mod1,
        pw2[i]=pw2[i+1]*B2%mod2;
    }
    ++mp[hs-Hashnum(pw1[mxs[zx]+1],pw2[mxs[zx]+1])+Hashnum(pw1[mxs[zx]],pw2[mxs[zx]])];
    if(zx2) ++mp[hs-Hashnum(pw1[mxs[zx2]+1],pw2[mxs[zx2]+1])+Hashnum(pw1[mxs[zx2]],pw2[mxs[zx2]])];
    dfs3(zx,-1,hs);
    if(zx2) dfs3(zx2,-1,hs);
    int cnt=0;
    for(auto i=mp.begin();i!=mp.end();++i)
        ans[++cnt]=(*i).second;
    sort(ans+1,ans+1+cnt);
    write(cnt),putchar('\n');
    for(register int i=1;i<=cnt;++i)
        write(ans[i]),putchar('\n');
    return 0;
}
```


---

## 作者：lamboo (赞：0)

## P6653 [YsOI2020]造林

### 题解

一个点的最大子树大小会发生改变当且仅当嫁接的点在它的最大子树中。这样影响当前点最大子树值的嫁接点就会在一段区间中。可以发现区间总数是 $O(n)$ 的。

> 证明：若存在一个点为根，存在两个及以上大小相等的子树，则剩下的所有点的最大子树只有一个（为其父亲）。

这样我们就可以求出在每个点嫁接后会影响的点的情况。

发现最后品种相同当且仅当：对于每个最大子树值，被影响的点的个数相同。直接 $hash$ 即可。

~~比赛时智障地写了个树状数组T飞~~。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 2000010
#define ll long long
#define ull unsigned long long
#define pll pair<ull,ull>
#define mkp(a,b) make_pair(a,b)
inline int read() {
    int x=0;
    char ch=getchar();
    while (!isdigit(ch)) ch=getchar();
    while (isdigit(ch)) x=x*10+ch-'0',ch=getchar();
    return x;
}
ull seed=13244074693642402ull;
inline ull Rand() {
    seed^=seed<<13,seed^=seed>>7,seed^=seed<<17;
    return seed;
}
ull f[N],g[N],Map1[N],Map2[N];
pll val[N];
inline void Add(int l,int r,int dat,int Dat) {
    f[l]^=dat,f[r+1]^=dat,g[l]^=Dat,g[r+1]^=Dat;
}
int tot=1;
int fir[N],nex[N<<1],got[N<<1];
inline void AddEdge(int x,int y) {
    nex[++tot]=fir[x],fir[x]=tot,got[tot]=y;
    nex[++tot]=fir[y],fir[y]=tot,got[tot]=x;
}
int dfn[N],siz[N],Max[N],idx;
inline void dfs(int x,int fa,int n) {
    siz[x]=1,dfn[x]=++idx;
    for (int i=fir[x];i;i=nex[i]) if (got[i]!=fa)
        dfs(got[i],x,n),siz[x]+=siz[got[i]],Max[x]=max(Max[x],siz[got[i]]);
    Max[x]=max(Max[x],n-siz[x]);
    for (int i=fir[x];i;i=nex[i]) {
        if (got[i]==fa || siz[got[i]]!=Max[x]) continue;
        Add(dfn[got[i]],dfn[got[i]]+siz[got[i]]-1,Map1[Max[x]],Map2[Max[x]]);
    }
    if (n-siz[x]==Max[x]) {
        Add(1,dfn[x]-1,Map1[Max[x]],Map2[Max[x]]);
        Add(dfn[x]+siz[x],n,Map1[Max[x]],Map2[Max[x]]);
    }
}
int main() {
    int n=read();
    for (int i=1;i<=n;i++) Map1[i]=Rand();
    for (int i=1;i<=n;i++) Map2[i]=Rand();
    for (int i=1;i<=n-1;i++) AddEdge(read(),read());
    dfs(1,0,n);
    for (int i=1;i<=n;i++) f[i]^=f[i-1],g[i]^=g[i-1];
    for (int i=1;i<=n;i++) val[i]=mkp(f[i],g[i]);
    sort(val+1,val+n+1);
    vector<int> ans; int cnt=1; val[n+1]=mkp(-1,-1);
    for (int i=2;i<=n+1;i++) {
        if (val[i]!=val[i-1]) 
            ans.push_back(cnt),cnt=0;
        cnt++;
    }
    printf("%d\n",ans.size());
    sort(ans.begin(),ans.end());
    for (auto tmp:ans) printf("%d\n",tmp);
    return 0;
}
```


---


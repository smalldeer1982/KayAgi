# 「C.E.L.U-03」100%不公平的游戏

## 题目背景

今天 ice 出去玩了。原准备与 Alice 玩游戏的 Bob 只能和 Al 玩一场博弈游戏。

## 题目描述

这个游戏是在树上进行的。Bob 先手。Bob 和 Al 轮流进行以下操作，首先无法操作者判负。

- 在树上标记一条未被标记过的边。满足在每一次操作之后，存在一条简单路径遍历所有标记过的边。注意：这条简单路径**可以经过未标记过的边**。

如果给定的树对于 Bob 有必胜方案，输出 `Play now`，否则输出 `Restart`。

## 说明/提示

**样例数据也可见附件** $\textbf{\textit{game.in}/\textit{game.out}}$。

### 样例解释 1

**第一组数据：**

先手选择边 $(2,5)$ 必胜：  
若后手选择 $(1,2)$，先手选择 $(5,6)$ 可以获胜。  
若后手选择 $(2,3)$，先手选择 $(5,9)$ 可以获胜。  
若后手选择 $(3,4)$，先手选择 $(5,9)$ 可以获胜。  
若后手选择 $(5,6)$，先手选择 $(1,2)$ 可以获胜。  
若后手选择 $(5,9)$，先手选择 $(3,4)$ 可以获胜。  
若后手选择 $(7,9)$，先手选择 $(2,3)$ 可以获胜。  
若后手选择 $(8,9)$，先手选择 $(3,4)$ 可以获胜。  
综上，无论后手选那一条边，都不会获得胜利。  

**第二组数据：**

先手不存在必胜策略：  
若先手选择 $(1,2)$，后手选择 $(2,3)$ 获胜。  
若先手选择 $(2,3)$，后手选择 $(1,2)$ 获胜。


### 样例解释 2

各组数据详见下图，其中前两组数据与样例一相同。

![](https://cdn.luogu.com.cn/upload/image_hosting/imht95gt.png)

---

### 数据范围

$2\leq n\leq5\times10^5$

$1\leq T\leq10^4$

$\sum n\leq1.5\times10^6$

数据保证给定的图是一棵树。

### 子任务  
1. （8分）$n\leq6$。
2. （18分）$n\leq12,T\leq10$。
3. （6分） $n\leq28,T\leq10$。
4. （8分）$n\leq200,T\leq10$。
5. （30分）$n\leq2000,T\leq10$。
6. （6分）最多存在两个节点度数大于 $2$。
7. （12分）树的形态是一棵完全二叉树。
8. （12分）无特殊性质。

## 样例 #1

### 输入

```
2
9
9 5
2 1
9 8
3 2
5 6
7 9
4 3
5 2
3
1 2
2 3```

### 输出

```
Play now
Restart```

## 样例 #2

### 输入

```
附加两组样例详见
https://www.luogu.com.cn/paste/b6mh7ido```

### 输出

```
附加两组样例详见
https://www.luogu.com.cn/paste/b6mh7ido```

# 题解

## 作者：VinstaG173 (赞：6)

是真的没有代码能力了/ll

~~一道大毒瘤题/baojin~~

SG 定理 + 换根 dp。

首先想到先手标记了一条边后，问题转化成了两个子游戏的和，每个游戏都是一棵有根树，要求变成在有根树中标记边且这些边都要在一条以根为一个端点的链上。

为什么要转化成这样的游戏呢？这是由于在这个游戏中，操作一步转化出的子游戏形态与之相似。以下用 $\operatorname{SG}(x)$ 表示 $x$ 子树的 SG 值。

如在以下一棵树中（根为 $1$）：

![pic1](https://cdn.luogu.com.cn/upload/image_hosting/s9wtaest.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

若我们标记了 $5-9$ 这条边，即

![pic2](https://cdn.luogu.com.cn/upload/image_hosting/z7pp129v.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

显然此时接下来标记的边只可能在 $9$ 的子树中或 $1-5$ 这条链上。在 $9$ 子树中操作的规则与原问题是相同的。故此后继状态的 SG 值为 $\operatorname{SG}(9) \oplus \operatorname{SG}(1-5)$（记号不是很标准）。

而链的 SG 值为链长 ${}\bmod 2$（链长计边数）。这个可以设长为 $n$ 的链的 SG 值为 $f(n)$，由 $f(0)=0,f(1)=1$，且

$$f(n)=\operatorname{mex}\{f(i) \oplus f(n-i-1) :i=0,\dots,n-1\}$$

得到。

故由以上分析，任意选定根后可得

$$\operatorname{SG}(x)=\operatorname{mex}\{\operatorname{SG}(v) \oplus (dep_v-dep_x-1) \bmod{2} : v \in subtree_x\},$$

其中 $subtree_x$ 表示 $x$ 的子树中的所有点构成的集合。

于是我们要关注的就是 $\operatorname{SG}(v) \oplus (dep_v-dep_x-1) \bmod{2}$。我们发现相邻两点的深度奇偶性恰好相反，也就是在点 $u$ 处需要 $\oplus1$ 的值在 $u$ 的父亲处不需要，反之亦然。于是我们记两个集合 $S_{x,0}$ 与 $S_{x,1}$，$S_{x,0}$ 是所需要用于求 SG 值的集合，$S_{x,1}$ 是 $S_{x,0}$ 中所有元素 $\oplus 1$ 之后的集合。则有转移：

$$S_{u,0}=\bigcup_{v \in son_u}(\{\operatorname{SG}(v)\} \cup S_{v,1}),$$

$$S_{u,1}=\bigcup_{v \in son_u}(\{\operatorname{SG}(v)\} \cup S_{v,0}),$$

且有 $\operatorname{SG}(u)=\operatorname{mex}(S_{u,0})$。

在这个转移方程的基础上进行换根 dp 即可。用 `bitset` 维护集合，SG 值最大可能为 $37$，处理 SG 函数所需时间 $\frac{37}{\omega}$ 是一个小常数，故时间复杂度为 $O(n)$，实际表现也足够优秀（最慢点 $1s$ 左右）。

具体实现中，我们对每个点用两个 `bitset` 维护它父亲的儿子中比它先遍历到的点的 $S$ 与比它后遍历到的点的 $S$ 的并集，这个有点类似前缀/后缀和。这样在换根过程中可以直接 $O(1)$ 计算。细节比较多~~所以调死我了~~。

`bitset` 库函数 `_Find_first` 可以快速找到最低位的 $1$，取反后调用就是 $\operatorname{mex}$ 函数。

~~不要像我一样只用脑子想，最好用下草稿纸，不然就像我一样想错了都不知道~~

Code:
```cpp
#include<bitset>
#include<cstdio>
#include<vector>
#define rg register
using std::bitset;
using std::vector;
int sg[500003];
int snm[500003];
vector<int> e[500003];
bitset<40> S[500003][2],T;
bitset<40> lS[500003][2],rS[500003][2];
inline void add(int x,int y){e[x].push_back(y),e[y].push_back(x);}
void dfs1(int u,int f)
{
	snm[u]=e[u].size();
	bitset<40> tlS0,trS0;
	bitset<40> tlS1,trS1;
	tlS0.reset(),trS0.reset();
	tlS1.reset(),trS1.reset();
	for(rg int i=1,v;i<snm[u];++i)
	{
		v=e[u][i];if(v==f)continue;dfs1(v,u);
		lS[v][0]=tlS0,tlS0|=S[v][1];
		lS[v][1]=tlS1,tlS1|=S[v][0];
	}
	for(rg int i=1,v;i<snm[u];++i)
	{
		v=e[u][snm[u]-i];if(v==f)continue;
		rS[v][0]=trS0,trS0|=S[v][1];
		rS[v][1]=trS1,trS1|=S[v][0];
	}
	sg[u]=(~tlS0)._Find_first(),S[u][0]=tlS0,S[u][1]=tlS1;
	S[u][0].set(sg[u]^1),S[u][1].set(sg[u]);
}
int dfs2(int u,int f,bitset<40> tS0,bitset<40> tS1)
{
	if(f)
	{
		int tsg=(~tS0)._Find_first();
		if(tsg==sg[u])return 1;
		tS0.set(tsg^1),tS1.set(tsg);
	}
	for(rg int i=1,v;i<snm[u];++i)
	{
		v=e[u][i];if(v==f)continue;
		if(dfs2(v,u,tS1|lS[v][0]|rS[v][0],tS0|lS[v][1]|rS[v][1]))return 1;
	}
	return 0;
}
inline void init(int n)
{
	T.reset();
	for(rg int i=1;i<=n;++i)
	{
		sg[i]=snm[i]=0;
		e[i].clear(),e[i].push_back(0);
		S[i][0].reset(),S[i][1].reset();
		lS[i][0].reset(),rS[i][0].reset();
		lS[i][1].reset(),rS[i][1].reset();
	}
}
int t,n,u,v;
int main()
{
	scanf(" %d",&t);
	while(t--)
	{
		scanf(" %d",&n);init(n);
		for(rg int i=1;i<n;++i)scanf(" %d %d",&u,&v),add(u,v);
		dfs1(1,0);puts((dfs2(1,0,T,T))?"Play now":"Restart");
	}
	return 0;
}
```

---

## 作者：幻影星坚强 (赞：5)

介绍下更显然的 multi-sg 做法。

首先选完第一条边后游戏变成每次选择的边都要构成一条到根的路径的两个子游戏，之后对于每个游戏，选择一条边相当于把它分成一个每次只能取一条边的链和一个规则相同的子树。根据 multi-sg ，我们对于每个子树，我们枚举它能分成两个子游戏的所有情况并将它们的 sg 值异或起来当成后继状态。而链的 sg 值比较显然相当于链长 %2 ，所以我们可以通过枚举子树内的子树来进行转移，也就是

$sg_o=\text{mex}(sg_{son_o}\oplus ((dep_o - dep_{son_o} - 1 ) \% 2))(son_o\in S_o)$

其中 $S_o$ 代表 $o$ 的子树。

而最后先手选完第一条边后的 sg 值相当于分出两个子树所对应 sg 值的异或和，先手获胜条件相当于存在一种选法使得 sg 值为 $0$。

我们可以暴力枚举第一条边并且暴力求出子树 sg 值，时间复杂度 $O(n^3)$，如果使用换根来代替暴力枚举第一条边则时间复杂度为 $O(n^2)$，瓶颈在求子树 sg 值。

我们继续分析，如果一个点他有一个儿子 $o$ 的 sg 值为 $t$，那么对于任何的 $0\leq s < \left \lfloor \dfrac{t}{2}\right\rfloor \times 2$ 肯定能在这个儿子内部找到一个点使得 $sg_{son_o}\oplus ((dep_o - dep_{son_o} - 1 ) \% 2) = s$， 因为可以这些值两两配对，所以也一定能找到  $sg_{son_o}\oplus ((dep_{fa_o} - dep_{son_o} - 1 ) \% 2) = sg_{son_o}\oplus ((dep_o - dep_{son_o} ) \% 2) = s$。

而对于 $t$，如果 $t = \left \lfloor \dfrac{t}{2}\right\rfloor \times 2$，假如它的子树内能找到一个 sg 值为 $t+1$ 的子树，那么就相当于这个儿子能找到一个 sg 值为 $(t+1)\oplus 1 = t$的子树，与其 sg 值为 $t$ 矛盾。

如果 $t = \left \lfloor \dfrac{t}{2}\right\rfloor \times 2 + 1$，那么这个儿子的子树内找不到一个 sg 值为 $t$ 的状态，也就相当于这个点的子树内找不到一个 sg 值为 $t\oplus 1 = t - 1$ 的状态。

所以说一个点的一个儿子 sg 值为 $t$，那么它能到达的后继状态就多了 $0$ 到 $\left \lfloor \dfrac{t}{2}\right\rfloor \times 2 - 1$ 和 $t$。

于是一个点的 sg 值就可以如下转移

$$sg_o=\begin{cases}\max(sg_{son_o})+ 1&\max(sg_{son_o}) =\text{se}(sg_{son_o})+1\\0 &son_o = \varnothing\\\max(sg_{son_o})\oplus 1&\text{otherwise}\end{cases}$$

其中 $\text{se}(S)$ 代表集合 $S$ 中的严格次大值。

于是这样便能做到 $O(n)$ 求出 sg 值。

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
const int N = 5e5 + 10;
struct bian
{
	int from, to;
}eg[N << 1];
int front[N], num;
void add(int x, int y)
{
	eg[++ num].to = y;
	eg[num].from = front[x];
	front[x] = num;
}
int sg[N], maxs[N], maxs_tot[N], se[N], se_tot[N], th[N], th_tot[N];
int T, n;
void dfs1(int o, int from)
{
	maxs_tot[o] = maxs[o] = se[o] = se_tot[o] = th[o] = th_tot[o] = 0;
	for (int i = front[o]; i; i = eg[i].from)
	{
		int to = eg[i].to;
		if(to == from)continue;
		dfs1(to, o);
		if(maxs[o] == sg[to])
		++ maxs_tot[o];
		else
		if(maxs[o] < sg[to])
		swap(se[o], th[o]), swap(se_tot[o], th_tot[o]), swap(maxs[o], se[o]), swap(maxs_tot[o], se_tot[o]), maxs[o] = sg[to], maxs_tot[o] = 1;
		else
		if(se[o] == sg[to])
		++ se_tot[o];
		else
		if(se[o] < sg[to])
		swap(se[o], th[o]), swap(se_tot[o], th_tot[o]), se[o] = sg[to], se_tot[o] = 1;
		else
		if(th[o] == sg[to])
		++ th_tot[o];
		else
		if(th[o] < sg[to])
		th[o] = sg[to], th_tot[o] = 1;
	}
		if(maxs[o] == (se[o] ^ 1) && se_tot[o] >= 1)
		sg[o] = maxs[o] + 1;
		else
		sg[o] = maxs_tot[o] == 0 ? 0 : (maxs[o] ^ 1);
}
int ans = 0;
void dfs2(int o, int from)
{
	for (int i = front[o]; i; i = eg[i].from)
	{
		int to = eg[i].to;
		if(to == from)continue;
		
		int sg_o = sg[o], maxs_o = maxs[o], maxs_tot_o = maxs_tot[o], se_o = se[o], se_tot_o = se_tot[o], th_o = th[o], th_tot_o = th_tot[o];
		int sg_to = sg[to], maxs_to = maxs[to], maxs_tot_to = maxs_tot[to], se_to = se[to], se_tot_to = se_tot[to], th_to = th[to], th_tot_to = th_tot[to];
		
		int now = sg[to];
		if(sg[to] == maxs[o] && maxs_tot[o] == 1)
		maxs[o] = se[o], maxs_tot[o] = se_tot[o], se[o] = th[o], se_tot[o] = th_tot[o], th[o] = 0, th_tot[o] = 0;
		else
		if(sg[to] == se[o] && se_tot[o] == 1)
		se[o] = th[o], se_tot[o] = th_tot[o], th[o] = 0, th_tot[o] = 0;
		else
		if(sg[to] == th[o] && th_tot[o] == 1)
		th[o] = 0, th_tot[o] = 0;
		if(maxs[o] == (se[o] ^ 1) && se_tot[o] >= 1)
		sg[o] = maxs[o] + 1;
		else
		sg[o] = maxs_tot[o] == 0 ? 0 : (maxs[o] ^ 1);
		
		
		if(maxs[to] == sg[o])
		++ maxs_tot[to];
		else
		if(maxs[to] < sg[o])
		swap(se[to], th[to]), swap(se_tot[to], th_tot[to]), swap(maxs[to], se[to]), swap(maxs_tot[to], se_tot[to]), maxs[to] = sg[o], maxs_tot[to] = 1;
		else
		if(se[to] == sg[o])
		++ se_tot[to];
		else
		if(se[to] < sg[o])
		swap(se[to], th[to]), swap(se_tot[to], th_tot[to]), se[to] = sg[o], se_tot[to] = 1;
		else
		if(th[to] == sg[o])
		++ th_tot[to];
		else
		if(th[to] < sg[o])
		th[to] = sg[o], th_tot[to] = 1;
		
		
		if(maxs[to] == (se[to] ^ 1) && se_tot[to] >= 1)
		sg[to] = maxs[to] + 1;
		else
		sg[to] = maxs_tot[to] == 0 ? 0 : (maxs[to] ^ 1);
		
		
		if(now == sg[o])ans = 1; 
		
		dfs2(to, o);
		
		
		sg[o] = sg_o, maxs[o] = maxs_o, maxs_tot[o] = maxs_tot_o, se[o] = se_o, se_tot[o] = se_tot_o, th[o] = th_o, th_tot[o] = th_tot_o;
		sg[to] = sg_to, maxs[to] = maxs_to, maxs_tot[to] = maxs_tot_to, se[to] = se_to, se_tot[to] = se_tot_to, th[to] = th_to, th_tot[to] = th_tot_to;
		
	}
}
int main()
{
	scanf("%d", &T);
	while(T --)
	{
		ans = 0;
		num = 0;
		for (int i = 1; i <= n; ++ i)
		front[i] = 0;
		scanf("%d", &n);
		for (int i = 1; i < n; ++ i)
		{
			int x, y;
			scanf("%d%d", &x, &y);
			add(x, y);
			add(y, x);
		}
		dfs1(1, 0);
		dfs2(1, 0);
		printf("%s\n", ans ? "Play now" : "Restart");
	}
}
```


---


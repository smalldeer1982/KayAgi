# [NOIP2022] 建造军营

## 题目描述

A 国与 B 国正在激烈交战中，A 国打算在自己的国土上建造一些军营。

A 国的国土由 $n$ 座城市组成，$m$ 条双向道路连接这些城市，使得**任意两座城市均可通过道路直接或间接到达**。A 国打算选择一座或多座城市（**至少一座**），并在这些城市上各建造一座军营。

众所周知，军营之间的联络是十分重要的。然而此时 A 国接到情报，B 国将会于不久后袭击 A 国的一条道路，但具体的袭击目标却无从得知。如果 B 国袭击成功，这条道路将被切断，可能会造成 A 国某两个军营无法互相到达，这是 A 国极力避免的。因此 A 国决定派兵看守若干条道路（**可以是一条或多条，也可以一条也不看守**)，A 国有信心保证被派兵看守的道路能够抵御 B 国的袭击而不被切断。

A 国希望制定一个建造军营和看守道路的方案，使得 B 国袭击的无论是 A 国的哪条道路，都不会造成某两座军营无法互相到达。现在，请你帮 A 国计算一下可能的建造军营和看守道路的方案数共有多少。由于方案数可能会很多，你只需要输出其对 $1,000,000,007\left(10^{9}+7\right)$ 取模的值即可。两个方案被认为是不同的，当且仅当存在至少一 座城市在一个方案中建造了军营而在另一个方案中没有，或者存在至少一条道路在一个 方案中被派兵看守而在另一个方案中没有。


## 说明/提示

### 样例 1 解释

A 国有两座城市，一条道路连接他们。所有可能的方案如下：

- 在城市 $1$ 建军营, 不看守这条道路;
- 在城市 $1$ 建军营, 看守这条道路;
- 在城市 $2$ 建军营, 不看守这条道路;
- 在城市 $2$ 建军营, 看守这条道路;
- 在城市 $1,2$ 建军营, 看守这条道路。

### 数据规模与约定

对所有数据，保证 $1 \leq n \leq 5 \times 10^5$，$n - 1 \leq m \leq 10^6$，$1 \leq u_i, v_i \leq n$，$u_i \neq v_i$。

各测试点的信息如下

|测试点编号 | $n \leq $ | $m \leq $| 特殊条件 |
| :-: | :-: | :-: | :-: |
| $1 \sim 3$ | $8$ | $10$ | 无 |
| $4 \sim 7$ | $16$ | $25$ | 无 |
| $8 \sim 9$ | $3000$ | $5000$ | 无 |
| $10 \sim 11$ | $5 \times 10^5$ | $10^6$ | 特殊性质 $\mathrm{A}$ |
| $12 \sim 14$ | $5 \times 10^5$ | $10^6$ | $m = n - 1$ |
| $15 \sim 16$ |  $5 \times 10^5$ | $10^6$ | $m = n$ |
| $17 \sim 20$ | $5 \times 10^5$ | $10^6$ | 无 |

特殊性质 $\mathrm{A}$：保证 $m=n-1$ 且第 $i$ 条道路连接城市 $i$ 与 $i+1$。 

## 样例 #1

### 输入

```
2 1
1 2```

### 输出

```
5```

## 样例 #2

### 输入

```
4 4
1 2
2 3
3 1
1 4```

### 输出

```
184```

## 样例 #3

### 输入

```
见附加文件里的 barrack/barrack3.in```

### 输出

```
见附加文件里的 barrack/barrack3.ans```

## 样例 #4

### 输入

```
见附加文件里的 barrack/barrack4.in```

### 输出

```
见附加文件里的 barrack/barrack4.ans```

# 题解

## 作者：Chy12321 (赞：198)

只有 B 国炸毁了图的割边，才会使得图不连通，进而可能会导致军营不连通。也就是说，A 国可以随意地看守或不看守不是割边的边。因此想到 [边双缩点](https://www.luogu.com.cn/problem/P8436) 后树形 DP。

为什么边双缩点后会形成一棵树呢？

题目保证了给定的图连通，那么缩点后的图也必然连通，而如果有多个“双连通分量”构成了环，就不符合双连通分量的定义了，即这些首尾相连构成环的“双连通分量”应该被划在同一个双连通分量中。

因此，缩点后形成的图连通且无环，也就形成了一棵树。

已经缩了点，再思考：究竟要在缩点后形成的树上求什么？

令 $V_u$ 表示双连通分量 $u$ 中的点数，$E_u$ 表示双连通分量 $u$ 中的边数，若有 $n$ 个双连通分量，则问题转化为：

给定一棵无根树，每个结点有 $2^{E_u}$ 种不建造军营的方案和 $(2^{V_u + E_u} - 2^{E_u})$ 种建造军营的方案。求共有多少种建造军营的方案（不能不建）。

这里假定 $1$ 号结点为树根。

令 $f(u, 0/1)$ 表示以 $u$ 为根的子树中没有/有军营的方案数。

发现每种状态所涵盖的情况过多，根本不好转移。

这时，有两种思路：

- 增加状态数量。
- 对状态增添限制。

我选择的是后者。

令 $f(u, 0/1)$ 表示以 $u$ 为根的子树中没有/有军营的方案数，若有军营，则所有的军营必须通过已经派兵看守的边与 $u$ 连通。

在想转移之前，为了防止做无用功，最好先想想该如何统计答案。

对于每个结点 $u$，我们强制 $u$ 子树外的所有点都不建军营，同时强制不选 $fa_u \to u$ 的边，再累加方案数，即可保证不重不漏（具体可看下图）。

![](https://cdn.luogu.com.cn/upload/image_hosting/ufhysx5o.png)

令 $s(u)$ 表示以 $u$ 为根节点的子树内边数，即 $s(u) = E_u + \sum\limits_{v \in son(u)} [s(v) + 1]$，则有 $ans \leftarrow f(u, 1) \times 2^{s(1) - s(u) - 1}$。

特殊地，对于 $1$ 号结点，不存在 $fa_1 \to 1$ 的边，此时 $ans \leftarrow f(1, 1)$。

明确了答案如何统计，接下来考虑转移：

显然地，$f(u, 0) = 2^{E_u} \times \prod\limits_{v \in son(u)} 2f(v, 0)$，难点在 $f(u, 1)$ 的转移上。

考虑每新增一个子节点 $v$ 对 $f(u, 1)$ 产生的贡献。

若到新增前都还未建造一个军营，则以 $v$ 为根的子树中必须有军营，即 $f(u, 1) \leftarrow f(u, 0) \times f(v, 1)$。

若到新增前已经建造过军营，则以 $v$ 为根的子树中有没有军营皆可，且当以 $v$ 为根的子树中没有军营时，$v$ 点是否与 $u$ 点连通皆可，即 $f(u, 1) \leftarrow f(u, 1) \times [2f(v, 0) + f(v, 1)]$。

综上，$f(u, 1) \leftarrow f(u, 0) \times f(v, 1) + f(u, 1) \times [2f(v, 0) + f(v, 1)]$。

初始时，$f(u, 0) = 2^{E_u}$，$f(u, 1) = 2^{V_u + E_u} - 2^{E_u}$。

代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

constexpr int N = 500100, M = 1000100, MOD = 1e9 + 7;

int n, m, p;
int tot, tot2, head[N], head2[N];
int cnt, top, stk[N], dfn[N], low[N], bel[N];
int deg[N], V[N], E[N], s[N];
bool ins[N];
ll ans, f[N][2];

struct Edge {
    int to, nxt;
} e[M << 1], e2[M << 1];

void add(int u, int v) {
    e[++tot] = Edge{v, head[u]};
    head[u] = tot;
}

void add2(int u, int v) {
    e2[++tot2] = Edge{v, head2[u]};
    head2[u] = tot2;
}

void tarjan(int u, int fa) {
    dfn[u] = low[u] = ++cnt, ins[stk[++top] = u] = 1;
    for (int i = head[u], v; i; i = e[i].nxt) {
        v = e[i].to;
        if (v == fa) continue;
        if (!dfn[v]) tarjan(v, u), low[u] = min(low[u], low[v]);
        else if (ins[v]) low[u] = min(low[u], dfn[v]);
    }
    if (dfn[u] == low[u]) {
        p++; int x;
        do {
            // 因为不需要知道每个边双连通分量里都有哪些点，只记录每个点属于哪个边双连通分量即可。
            ins[x = stk[top--]] = 0, bel[x] = p;
            V[p]++; // 累加该边双连通分量内点数
        } while (x != u);
    }
}

ll qp(ll base, int e) { // 快速幂
    ll res = 1;
    while (e) {
        if (e & 1) res = res * base % MOD;
        base = base * base % MOD;
        e >>= 1;
    }
    return res;
}

void dfs(int u, int fa) { // dfs 计算 s[]
    s[u] = E[u];
    for (int i = head2[u], v; i; i = e2[i].nxt) {
        v = e2[i].to;
        if (v == fa) continue;
        dfs(v, u); s[u] += s[v] + 1;
    }
}


void dp(int u, int fa) { // 树形 DP
    for (int i = head2[u], v; i; i = e2[i].nxt) {
        v = e2[i].to;
        if (v == fa) continue;
        dp(v, u);
        // 状态转移
        f[u][1] = (f[u][1] * (((f[v][0] << 1) + f[v][1]) % MOD) % MOD + f[u][0] * f[v][1] % MOD) % MOD;
        f[u][0] = f[u][0] * ((f[v][0] << 1) % MOD) % MOD;
    }
    // 统计答案
    if (u == 1) ans = (ans + f[u][1]) % MOD; // 特判 1 号结点的特殊情况
    else ans = (ans + f[u][1] * qp(2, s[1] - s[u] - 1)) % MOD;
}

int main() {
    ios::sync_with_stdio(0); cin.tie(nullptr), cout.tie(nullptr);
    cin >> n >> m;
    while (m--) {
        int u, v; cin >> u >> v;
        add(u, v), add(v, u);
    }
    tarjan(1, 0); // 边双缩点
    for (int u = 1; u <= n; u++) {
        for (int i = head[u], v; i; i = e[i].nxt) {
            v = e[i].to;
            if (bel[u] != bel[v]) add2(bel[u], bel[v]); // 如果属于两个不同的边双连通分量，则将这两个边双连通分量连边
            else E[bel[u]]++; // 否则该双连通分量内边数 + 1
        }
    }
    for (int i = 1; i <= p; i++) {
        E[i] >>= 1; // 因为是无向边，每一条边会累加 2 次，故 E[i] 需要除以 2
        // 赋初值
        f[i][0] = qp(2, E[i]);
        f[i][1] = qp(2, V[i] + E[i]) - f[i][0];
    }
    dfs(1, 0); dp(1, 0);
    cout << ans;
    return 0;
}
```

---

upd on 2022.12.18

感谢 @一只绝帆 指出了一处笔误。

upd on 2023.5.15

针对 @__vector__ 指出的错误修改了部分内容。

---

## 作者：dbxxx (赞：113)

[欢迎您到我的博客阅读本文，谢谢！](https://www.cnblogs.com/crab-in-the-northeast/p/luogu-p8867.html)

[P8867 NOIP2022 建造军营 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P8867)。

给定一个无向联通图 $G = (V', E')$，求有多少个二元组 $(V, E)$，满足：

- $V \subseteq V'$，$E \subseteq E'$，$V \ne \varnothing$。
- 在 $G$ 上，断开 $E’ - E$ 中任意一条边后，都有 $V$ 中所有点在 $G$ 上仍然联通。

## 35 pts

枚举 $2^n - 1$ 种 $V$ 的情况，再用 $m(n +m)$ 的复杂度暴力检验将每条边断开后 $V$ 是否仍然联通，记录【断开该边后 $V$ 仍然可以联通】的边数 $M$，答案累加 $2^{M}$ 即可。

时间复杂度 $\Theta(m(n+m)2^n)$，期望可以通过前 $7$ 个数据点（没有实测）。

## 45 pts

考虑开特殊性质 $\mathrm{A}$，也就是给定的图是一条链。

我们考虑当 $V$ 最左面的点为 $l$，最右面的点为 $r$ 时，有多少种二元组。

当 $l = r$，也就是 $V$ 中只有一个元素 $l$ 时，所有边都可以随便选，可以有 $2^{n-1}$ 种取法。这一部分的答案是 $n \times 2^{n-1}$。

当 $l \ne r$ 时，中间的 $r-l$ 条边必须选入 $E$，而两头的边都可以随便选取。此时 $V$ 有 $2^{r - l - 1}$ 种取法，$E$ 有 $2^{n-1-(r-l)}$ 种取法，惊喜发现这一部分答案就是 $2^{n-2}$，和 $l$，$r$ 无关。

$l$，$r$ 的取法为 $\dbinom{n}{2} = \dfrac{n(n-1)}{2}$，所以这部分的答案是 $n(n-1)2^{n-3}$，总答案为 $n \times 2 ^ {n-1} + n(n-1)2^{n-3}$。

到这里都很送。

## 100 pts

不难发现，对于任意非桥边，删除它后整个图都可联通，因此所有非桥边在任意情况下都可以随便选。

这启发我们对整个图进行边双缩点。边双缩点后形成一棵树，原图非桥边将全部消失（被缩在一个点里），桥边变成新的树边。

因为任何非桥边任意情况下可以任意选，所以最终答案会有一个 $2^{m - M}$ 的系数，这里 $M$ 的含义是桥边的数量，也就是缩点后的树边数量。这样以来，我们在讨论选边方案时只讨论 $M$ 条树边，得到的方案数最后乘上 $2^{m - M}$ 即可。

当模型变成树后，我们发现，任意两个点之间的路径变得唯一：也就是对于树上的任意两个节点 $s$ 和 $t$，如果这两个点均被选入点集，那么对于 $s \rightsquigarrow t$ 的简单路径上的所有边必须全部选入边集。否则，断开那条没选入边集的边，$s$ 和 $t$ 一定不再联通。

为了区分，我们定义 $s$ 和 $t$ 是【超联通】的，当且仅当 $s$ 和 $t$ 可以**仅通过所选的边**联通。

计数问题要么是动态规划要么是排列组合，要么两个都占。接下来就不难想到树形 dp 了。我们记 $T(u)$ 表示 $u$ 的子树。

考虑设计状态，$f(u)$ 表示 $T(u)$ 的答案，也就是在 $T(u)$ 上，最少选一个点，选任意条边的方案数。我们设 $e(u)$ 表示 $T(u)$ 中边的数量。

对于 $u$ 的子节点 $v$，如果我们决定不在 $T(v)$ 上选点，那么 $T(v)$ 上的边和 $(u, v)$ 这条边都有选和不选两种可能，有 $2^{e(v) +1}$ 种情况。

若我们在 $T(v)$ 上选点呢，出现问题：

如果 $T(v)$ 上存在一个点 $x$，满足 $x$ 和 $v$ 不超联通（注意到这个方案是合法的，因为我们可以不选择点 $v$）。那么无论我们是否选择 $(u, v)$，都有 $x$ 和 $u$ 不超联通。此时点 $u$，以及 $v$ 的兄弟的子树上的点一定不可选择，因为无法和 $x$ 超联通，不合法。

如果 $T(v)$ 上不存在这样的点 $x$，也就是 $T(v)$ 上的点都和 $v$ 超联通，只要我们选择 $(u, v)$，那么 $T(v)$ 上选的所有点就能和 $u$ 超联通。此时，$u$ 以及 $v$ 的兄弟的子树上的点就可合理选取。

上面两种情况会造成转移的截然不同，但是由于我们统统放在一个 $f(v)$ 里，没法转移。所以我们需要分开讨论和转移。

换句话说，我们此时应给状态多加一维：

$f(u, 1)$ 表示 $T(u)$ 上至少选了一个点，且选的所有点全部和 $u$ 超联通的方案数；

$f(u, 2)$ 表示 $T(u)$ 上至少选了一个点，且存在一个点不和 $u$ 超联通的方案数。

从而分开转移。最终答案是 $f(1, 1) + f(1, 2)$（令 $1$ 为根）。

详细的转移方程和代码细节可以参考别的题解，因为在这里我要讲的是一种另外的思路，状态不需要多加一维，更有趣一点。

设 $f(u)$ 表示 $T(u)$ 上至少选了一个点，且选的所有点全部和 $u$ 超联通的方案数。其实就是上边的 $f(u, 1)$，换句话说，我只需要 $f(u, 1)$ 一个状态就可完成本题的全部转移和答案统计。

我们加设 $c(u)$ 表示节点 $u$ 代表原图上多少个点（即有多少个点被缩进 $u$ 了）。对于 $u$ 上的点，可随便选，所以会有个 $2^{c(u)}$ 的系数。

接着讨论 $u$ 的子节点 $v$ 及其子树 $T(v)$。

- $T(v)$ 上不选点：那么 $T(v)$ 上的边和 $(u, v)$ 这条边都有选和不选两种可能，有 $2^{e(v) +1}$ 种情况；
- $T(v)$ 上选点：此时 $(u, v)$ 必选，有 $f(v)$ 种情况。

最后还有个问题：$f(u)$ 要保证 $T(u)$ 上必选点。上面所有情况计算完毕，会包含所有不选点构成的 $2^{e(u)}$ 种情况，最后减去。

得到 $f(u)$ 的状态转移方程：
$$
f(u) = -2^{e(u)} + 2 ^ {c(u)} \prod_{v \in \mathrm{child}(u)}2^{e(v) + 1}+f(v)
$$
怎么做答案统计？

答案一定不是 $f(1)$，因为当然会存在：所选点不全部和树根超联通的情况。

我们再考虑，一种选择方案，它选的所有点全都在 $T(u)$ 上，还都和 $u$ 超联通，方案数是多少？是 $f(u)$ 吗？错，我没说所选边都在 $T(u)$ 上：事实上，上面这个问题的答案是 $f(u) \times 2^{M - e(u)}$。

此时我想，答案是否为 $f(1) +f(2) \times 2^{M - e(2)} + f(3) \times 2^{M- e(3)} + \cdots + f(M + 1) \times 2^{M + 1 - e(M+1)}$（别忘了 $M +1 $ 是新树的点数，而且 $M = e(1)$）？然后我构造了两个反例出来：

![](https://cdn.luogu.com.cn/upload/image_hosting/a3u66l0w.png)

上面这个选择方案（红点和红边为选择对象，黑色的未不选的对象），会被 $f(4) \times 2^{M - e(4)}$ 和 $f(2) \times 2^{M - e(2)}$ 统计两次。

![](https://cdn.luogu.com.cn/upload/image_hosting/9op3zo6b.png)

上面这个选择方案，会被 $f(2) \times 2^{M - e(2)}$ 和 $f(1)$ 统计两次。

是否有一种办法能让每种方案只被统计一次？

观察上面这两个反例和自己造的一些反例，不难发现，只在所选点集的 LCA 统计答案即可。也就是对于第一个反例，期望在 $4$ 处统计该情况而不是在 $2$；对于第二个反例，期望在 $2$ 处该情况而不是在 $1$。如果在上面第二个反例的基础上，再选点 $3$ 和 $(1, 3)$ 这条边，那就期望在 $1$ 处统计答案了。

换句话讲，我们的目标：对于节点 $u$，计算出满足所选点集的 LCA 为点 $u$ 的方案数。

再换句话讲，就是计算出在 $f(u)$ 中，要么是 $u$ 本身被选择，要么是 $u$ 的两棵及以上子树选了点的方案数，最后乘 $2^{M - e(u)}$。

再再换句话讲，就是计算出在 $f(u)$ 中，$u$ 没被选而且只有一个子树中选了点的方案数，最后再用 $f(u)$ 减去它，乘上 $2^{M - e(u)}$ 的系数。

我们枚举 $u$ 的子节点 $v$，$T(v)$ 上有 $f(v)$ 种方案，$(u, v)$ 必选（否则就不在 $f(u)$ 里了），$T(u)$ 中其他边可选可不选，总共是 $f(v) \times 2^{e(u) - e(v) - 1}$ 种方案。

因此，$u$ 作为 LCA 对答案的贡献是：
$$
(f(u) - \sum_{v \in \mathrm{child}(u)} f(v) \times 2 ^ {e(u) - e(v) - 1}) \times 2^{M - e(u)}
$$
时间复杂度 $\Theta(n+m)$。

```cpp
/*
 * @Author: crab-in-the-northeast 
 * @Date: 2022-12-07 04:15:55 
 * @Last Modified by: crab-in-the-northeast
 * @Last Modified time: 2022-12-07 05:23:10
 */
#include <bits/stdc++.h>
#define int long long
inline int read() {
    int x = 0;
    bool f = true;
    char ch = getchar();
    for (; !isdigit(ch); ch = getchar())
        if (ch == '-')
            f = false;
    for (; isdigit(ch); ch = getchar())
        x = (x << 1) + (x << 3) + ch - '0';
    return f ? x : (~(x - 1));
}
inline bool gmi(int &a, int b) {
    return b < a ? a = b, true : false;
}

const int maxn = (int)5e5 + 5;
const int maxm = (int)1e6 + 5;
std :: vector <int> G[maxn], T[maxn];

int dfn[maxn], low[maxn], snt = 0, times = 0, sno[maxn];
int c[maxn];
std :: stack <int> s;

void tarjan(int u, int fa) {
    low[u] = dfn[u] = ++times;
    s.push(u);

    for (int v : G[u]) {
        if (!dfn[v]) {
            tarjan(v, u);
            gmi(low[u], low[v]);
        } else if (v != fa)
            gmi(low[u], dfn[v]);
    }

    if (low[u] == dfn[u]) {
        ++snt;
        for (; ;) {
            int x = s.top();
            s.pop();
            sno[x] = snt;
            ++c[snt];
            if (x == u)
                break;
        }
    }
}

const int mod = (int)1e9 + 7;
int f[maxn], ans = 0;
int p[maxm], e[maxn];

void dp(int u, int fa) {
    f[u] = p[c[u]];
    for (int v : T[u]) {
        if (v == fa)
            continue;
        dp(v, u);
        (f[u] *= (p[e[v] + 1] + f[v])) %= mod;
        e[u] += e[v] + 1;
    }
    (f[u] += mod - p[e[u]]) %= mod;

    int now = f[u];
    for (int v : T[u]) {
        if (v == fa)
            continue;
        ((now -= f[v] * p[e[u] - e[v] - 1] % mod) += mod) %= mod;
    }
    (ans += now * p[snt - 1 - e[u]] % mod) %= mod;
}

signed main() {
    int n = read(), m = read();
    for (int _ = 1; _ <= m; ++_) {
        int u = read(), v = read();
        G[u].push_back(v);
        G[v].push_back(u);
    }

    tarjan(1, 0);
    
    for (int u = 1; u <= n; ++u)
        for (int v : G[u])
            if (sno[u] != sno[v])
                T[sno[u]].push_back(sno[v]);
    
    p[0] = 1;
    for (int i = 1; i <= m + 3; ++i)
        p[i] = (p[i - 1] << 1) % mod;

    dp(1, 0);
    printf("%lld\n", ans * p[m - e[1]] % mod);
    return 0;
}
```

如果觉得这篇题解写得好，请不要忘记点赞，谢谢！

---

## 作者：Fanch100 (赞：67)

### 前言

考场上没做出来，一直想推导各种选点选边情况的个数最后再乘 $2$ 的幂。

后来才发现直接 DP 挺好写。

### 分析

注意到只有桥边被切断才会导致不连通，于是先边双缩点，记录每个 e-DCC 的 $siz$。

设 $f_{x,0/1}$，$f_{x,1}$ 表示仅 $x$ 的子树中有建造兵营**并且建造的兵营和 $x$ 联通的道路上的路都被保护**的方案数，$f_{x,0}$ 表示 $x$ 子树中完全不建造兵营的方案数。

首先每个 e-DCC 内部的边随便断并不影响，所以可以留到最后一起计算，DP 只需要考虑桥边。

转移如下：

- $x$ 扫到 $y$ 之前的子树没有兵营，子树 $y$ 内也没有，这条边可选可不选

$$f_{x,0} \leftarrow f_{x,0} \times f_{y,0} \times 2 $$

- $x$ 子树之前有兵营，子树 $y$ 内也没有，这条边可选可不选：

$$f_{x,1} \leftarrow f_{x,1} \times f_{y,0} \times 2 $$

- $x$ 子树之前有兵营，子树 $y$ 内也有，这条边必须选：

$$f_{x,1} \leftarrow f_{x,1} \times f_{y,1} $$

- $x$ 子树之前没有兵营，子树 $y$ 内也有，这条边必须选：

$$f_{x,1} \leftarrow f_{x,0} \times f_{y,1} $$

这四个更新是同时进行的，可以用两个变量记录增加的值，扫完四个更新再加上。

初始化： $ f_{x,0}=1 ,f_{x,1}=2^{siz_x}-1$

表示 $x$ 点上的 e-DCC 中任意选只有 $1$ 种方案为空。

计算答案：

对于每颗子树 $x$，记录它在缩点后树上子树的大小 $newsiz_x$，由于 $x$ 节点的父边（如果存在）必须不被保护（否则就应该记录到父亲节点的答案中），同时由定义子树外的点也不能选，注意到根节点（记为 $root$）没有父亲，所以答案应为：

$$ \sum_{x=1,x \neq root }^{n}{f_{x,1} \times 2^{m-newsiz_x}}+f_{root,1} \times 2^{m-(newsiz_{root}-1)}$$

代码里写的是预处理 $2$ 的幂次，注意因为次数和 $m$ 有关所以应预处理到 $10^6$ 级别。

### 代码

代码中的 $nsiz$ 数组表示上文所说的 $newsiz$ 数组。

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 500010;
const int M = 2000010;
const int mod = 1e9+7;
ll read(){
    char ch=getchar(); ll res=0;
    while(!isdigit(ch)){ch=getchar();}
    while(isdigit(ch)){res=(res<<1)+(res<<3)+ch-'0';ch=getchar();}
    return res;
}
int n, m;
int head1[N], pre1[M], ver1[M], tot1=1, from1[M];
void add1(int x,int y){
    ver1[++tot1]=y; pre1[tot1]=head1[x]; head1[x]=tot1; from1[tot1]=x;
}
int head[N], pre[M], ver[M], tot;
void add(int x,int y){
    ver[++tot]=y; pre[tot]=head[x]; head[x]=tot;
}
int dfn[N], low[N], tp, dc, dcc[N], siz[N];
bool bri[M];
void tarjan(int x,int in_edge){
    dfn[x]=low[x]=++tp;
    for (int i=head1[x]; i; i=pre1[i]){
        int v=ver1[i];
        if (!dfn[v]){
            tarjan(v,i);
            low[x]=min(low[x],low[v]);
            if (dfn[x]<low[v]) bri[i]=bri[i^1]=1;
        }
        else if (i!=(in_edge^1)) low[x]=min(low[x],dfn[v]);
    }
}
void dfs1(int x){
    dcc[x]=dc; siz[dc]++;
    for (int i=head1[x]; i; i=pre1[i]){
        int v=ver1[i];
        if (!bri[i] && !dcc[v]) dfs1(v);
    }
}
ll nsiz[N], f[N][2], pw[M];
ll ans;
void dfs(int x,int fa){
    nsiz[x]=1;
    f[x][0]=1; f[x][1]=pw[siz[x]]-1;
    for (int i=head[x]; i; i=pre[i]){
        int y=ver[i];
        if (y==fa) continue;
        dfs(y,x);
        nsiz[x]+=nsiz[y];
        ll f0=0, f1=0;
        f0=f[x][0]*2%mod*f[y][0]%mod;
        f1=f[x][1]*2%mod*f[y][0]%mod;
        f1=(f1+f[x][1]*f[y][1]%mod)%mod;
        f1=(f1+f[x][0]*f[y][1]%mod)%mod;
        f[x][0]=f0; f[x][1]=f1;
    }
    int base=nsiz[x];
    if (x==1) base--;
    ans=(ans+f[x][1]*pw[m-base]%mod)%mod;
}
int main(){
    //freopen("barrack.in","r",stdin);
    //freopen("barrack.out","w",stdout);
    //freopen("barrack4.in","r",stdin);
    n=read(); m=read();
    for (int i=1;i<=m;++i){
        int x=read(), y=read();
        add1(x,y); add1(y,x);
    }

    for (int i=1;i<=n;++i){
        if (!dfn[i]) tarjan(i,0);
    }
    for (int i=1;i<=n;++i){
        if (!dcc[i]) {
            dc++;
            dfs1(i);
        }
    }
    for (int i=2;i<=tot1;++i){
        if (bri[i]) add(dcc[from1[i]],dcc[ver1[i]]);
    }
    pw[0]=1;
    for (int i=1;i<=M/2;++i) pw[i]=pw[i-1]*2%mod;
    dfs(1,0);
    cout<<ans;
    return 0;
}
/*
6 7
1 2
2 3
1 3
2 4
4 5
4 5
3 6

3968
*/

```

---

## 作者：Liveddd (赞：20)

提供一种不太一样的 DP（？）。

update on 2023.4.16 修改了题解中得部分描述

很容易考虑到双连通分量缩点，再树形DP（不在树上的边我们称之为非树边）。对于 $\mathcal O(n^2)$ 有比较显然的树形背包。

考虑如何做到线性。设计状态 $f_x$ 表示在以 $x$ 为根的子树中，**至少选了一个点，且与 $x$ 连通**的方案数。设 $sum_x$ 表示以 $x$ 为根的子树中边的总数。

考虑每个子节点 $y$ 对 $f_x$ 的贡献：选取的话贡献为 $f_y$，不选取那么子树 $y$ 中的边和 $y\to x$ 这条边可以随便选（但是点不能选），所以贡献为 $2^{sum_y+1}$。再减去一个点不选的方案数 $2^{sum_x}$ 即可。

因为子树外的边（并且除去到父亲节点的边）可以随便选取，所以对答案的贡献就是 $f_x\times2^{m-sum_x-[fa\neq0]}$。

为什么父边不能自由选择？因为选取 $y\to x$ 这条边的贡献已经被计算在 $f_x$ 之中了。所以 $x$ 恰好能够统计选取 $y\to x$ 的一次。从父结点 $x$ 的角度应该就不难理解了。

```cpp
#include<iostream>
#include<iostream>
#include<cstdio>
#include<vector>
#define ll long long
using namespace std;
const int N=5e5+10,M=1e6+10,mod=1e9+7;
template<class T>
inline void read(T &x)
{
    x=0;int f=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    if(f)x=~x+1;
}
template<class T,class ...T1>
inline void read(T &x,T1 &...x1)
{
    read(x),read(x1...);
}
int n,m;
int tot=1,head[N],ver[M<<1],ne[M<<1];
int num,dfn[N],low[N],bri[M<<1];
int cnt,c[N];
int a[N],b[N],sum[N];
ll f[N],ans,p[N+M];
vector<int>e[N];
inline void add(int u,int v)
{ 
    ver[++tot]=v;
    ne[tot]=head[u];
    head[u]=tot;
}
void Tarjan(int x,int pre)
{
    dfn[x]=low[x]=++num;
    for(int i=head[x];i;i=ne[i])
    {
        int y=ver[i];
        if(!dfn[y])
        {
            Tarjan(y,i);
            low[x]=min(low[x],low[y]);
            if(dfn[x]<low[y])
                bri[i]=bri[i^1]=1;
        }
        else if(i!=(pre^1))
            low[x]=min(low[x],dfn[y]);
    }
}
void prework(int x)
{
    c[x]=cnt;
    a[cnt]++;
    for(int i=head[x];i;i=ne[i])
    {
        int y=ver[i];
        if(!c[y]&&!bri[i])
            prework(y);
    }
}
void dfs(int x,int fa)
{
    f[x]=p[a[x]+b[x]]%mod;//f[x]初值
    sum[x]=b[x];
    for(auto y:e[x])
    {
        if(y==fa)continue;
        dfs(y,x);
        sum[x]+=sum[y]+1;
        f[x]=f[x]*((f[y]+p[sum[y]+1])%mod)%mod;
        //y对f[x]的贡献，f[y]为选取，p[sum[y]+1]为不选取
    }
    f[x]=(f[x]+mod-p[sum[x]])%mod;//减去一个点都不选的方案数
    ans=(ans+f[x]*p[m-sum[x]-(fa!=0)]%mod)%mod;//统计总的方案数
}
int main()
{
    read(n,m);
    for(int i=1;i<=m;i++)
    {    
        int u,v;
        read(u,v);
        add(u,v);
        add(v,u);
    }
    Tarjan(1,0);
    for(int i=1;i<=n;i++)
        if(!c[i])
            cnt++,prework(i);
    for(int x=1;x<=n;x++)
    {
        for(int i=head[x];i;i=ne[i])
        {
            int y=ver[i];
            if(c[x]==c[y])b[c[x]]++;
            else e[c[x]].push_back(c[y]);
        }
    }
    for(int i=1;i<=cnt;i++)
        b[i]/=2;
    p[0]=1;
    for(int i=1;i<=n+m;i++)
        p[i]=(p[i-1]<<1)%mod;
    dfs(1,0);
    printf("%lld\n",ans%mod);
    return 0;
}
```

---

## 作者：Ecrade_ (赞：20)

提供一种不需要边双缩点的做法，代码更为简洁，不过实际上本质也差不多。

对于这种无向简单图，一种很常用的 trick 是 DFS 出一个生成树，称为 **DFS 树**。无向图的 DFS 树有一个极好的性质，就是图中的非树边只能是返祖边。在很多题目中，我们可以依据这个性质使问题简化或变得更直观。

在本题中，先求出 DFS 树。我们称 $u$ 为**好节点**，当且仅当 $u$ 的子树中有至少一条连接到其父亲 $fa$ 或 $fa$ 的某个祖先的返祖边，否则称其为**坏节点**。

可以发现，对于一个**好节点** $u$，无论删哪条边，$u$ 子树中的每个节点都能与 $u$ 子树外连通，故而 $u-fa$ 这条边是否看守不会产生任何影响，且可将 $u$ 子树的贡献全部算入 $fa$ 子树中；而对于一个**坏节点** $u$，看守 $u-fa$ 这条边时，可将 $u$ 子树的贡献全部算入 $fa$ 子树中，不看守 $u-fa$ 这条边时，敌人可删去 $u-fa$ 这条边使 $u$ 子树不再与外部联通，所以要么 $u$ 子树内不建造任何军营，要么整个图上仅在 $u$ 子树内建造军营。

接下来便可设计状态进行 DP。令 $f_{u,0/1/2}$ 表示仅考虑 $u$ 的子树，不建造任何军营 / 建造至少一座军营且 $u$ 子树中不存在某个坏节点的子树内建造了军营 / 建造至少一座军营且 $u$ 子树中存在某个坏节点的子树内建造了军营。

初始时，$f_{u,0}=1,f_{u,1}=1,f_{u,2}=0$。在转移时，我们可以依次遍历 $u$ 所有的子节点 $v$，并利用当前 $u$ 的 $f_u$ 与 $v$ 的  $f_v$ 计算出加上 $v$ 子树后的 $f_u'$。

对于一个好节点 $v$，转移方程为：

$$\begin{cases}f'_{u,0}=2f_{u,0}f_{v,0}\\f'_{u,1}=2f_{u,0}f_{v,1}+2f_{u,1}f_{v,0}+2f_{u,1}f_{v,1}\\f'_{u,2}=2f_{u,0}f_{v,2}+2f_{u,2}f_{v,0}\end{cases}$$

对于一个坏节点 $v$，转移方程为：

$$\begin{cases}f'_{u,0}=2f_{u,0}f_{v,0}\\f'_{u,1}=f_{u,0}f_{v,1}+2f_{u,1}f_{v,0}+f_{u,1}f_{v,1}\\f'_{u,2}=2f_{u,0}f_{v,2}+2f_{u,2}f_{v,0}+f_{u,0}f_{v,1}\end{cases}$$

对于所有 $m-n+1$ 条返祖边，看守与否均不会产生任何影响，故最后答案为 $2^{m-n+1}(f_{1,1}+f_{1,2})$。

如何判断一个节点是否为好节点 / 坏节点？对于一条返祖边 $d-u$（$d$ 为 $u$ 的后代），可以发现这条边会使 $d\sim u$ 简单路径上除了 $u$ 的所有节点都变为好节点。利用差分实现即可。

时间复杂度 $O(n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod = 1e9 + 7;
ll n,m,x,y,tot = 1,hd[500009],vis[500009],cnt[500009],f[500009][3];
bool ban[2000009];
struct st{ll x,y;}eg[2000009];
void addedge(ll u,ll v){eg[++ tot] = (st){v,hd[u]},hd[u] = tot;}
inline ll read(){
	ll s = 0,w = 1;
	char ch = getchar();
	while (ch > '9' || ch < '0'){ if (ch == '-') w = -1; ch = getchar();}
	while (ch <= '9' && ch >= '0') s = (s << 1) + (s << 3) + (ch ^ 48),ch = getchar();
	return s * w;
}
void dfs(ll u,ll fa){
	vis[u] = 1;
	for (ll i = hd[u];i;i = eg[i].y){
		ll v = eg[i].x;
		if (v == fa || ban[i]) continue;
		if (vis[v]){
			ban[i] = ban[i ^ 1] = 1;
			cnt[u] += 1,cnt[v] -= 1;
			continue;
		}
		dfs(v,u);
	}
}
void dfs2(ll u,ll fa){
	for (ll i = hd[u];i;i = eg[i].y){
		ll v = eg[i].x;
		if (v == fa || ban[i]) continue;
		dfs2(v,u),cnt[u] += cnt[v];
	}
}
void work(ll u,ll fa){
	f[u][0] = f[u][1] = 1,f[u][2] = 0;
	for (ll i = hd[u];i;i = eg[i].y){
		ll v = eg[i].x;
		if (v == fa || ban[i]) continue;
		work(v,u);
		ll tmp0 = 0,tmp1 = 0,tmp2 = 0;
		if (cnt[v]){
			tmp0 = 2 * f[u][0] * f[v][0] % mod;
			tmp1 = (2 * f[u][0] * f[v][1] % mod + 2 * f[u][1] * f[v][0] % mod + 2 * f[u][1] * f[v][1] % mod) % mod;
			tmp2 = (2 * f[u][0] * f[v][2] % mod + 2 * f[u][2] * f[v][0] % mod) % mod;
		}
		else{
			tmp0 = 2 * f[u][0] * f[v][0] % mod;
			tmp1 = (f[u][0] * f[v][1] % mod + 2 * f[u][1] * f[v][0] % mod + f[u][1] * f[v][1] % mod) % mod;
			tmp2 = (2 * f[u][0] * f[v][2] % mod + 2 * f[u][2] * f[v][0] % mod + f[u][0] * f[v][1] % mod) % mod;
		}
		f[u][0] = tmp0,f[u][1] = tmp1,f[u][2] = tmp2;
	}
}
int main(){
	n = read(),m = read();
	for (ll i = 1;i <= m;i += 1){
		x = read(),y = read();
		addedge(x,y),addedge(y,x);
	}
	dfs(1,0),dfs2(1,0),work(1,0);
	ll ans = (f[1][1] + f[1][2]) % mod;
	for (ll i = 1;i <= m - n + 1;i += 1) ans = (ans << 1) % mod;
	printf("%lld",ans);
	return 0;
}
```



---

## 作者：OMG_wc (赞：19)

先研究一下骗分，对于前 $7$ 个点，可以枚举出所有 $2^n -1$ 种建造军营的情况，然后看一下哪些边是必须选的，哪些边是可选可不选。

对于特殊性质 $A$ ，考虑最左边的点是 $l$ ，最右边的点是 $r$。 $l=r$ 时要特殊考虑，此时所有边都可选可不选，有 $n\times 2^{n-1}$ 种。对于其他情况，它们之间的 $r-l$ 条边必须选，外面的 $n-1-(r-l)$ 条边可选可不选，中间的 $r-l-1$ 个点可选可不选。这样有 $2^{n-1-(r-l)+r-l-1}=2^{n-2}$ 种，和 $l,r$ 是无关的，也就是说总共有 $C_{n}^2\cdot2^{n-2}$ 种。把这两部分加起来就是答案。

接着研究下样例 $2$ ，图为一个三角通过桥连着外面一个点，发现 $184=8\times 23$。这个 $8$ 其实是三角形的三条边可选可不选，因为这三角在一个边双连通分量里，无论破坏哪条边依然连通，也就是说这道题最终答案会有一个 $2^k$ 的系数，其中 $k$ 为所有边双里的边的数量总和。

$23$ 种情况分成两类:

- 外面的点建了军营，此时三角上有 $7$ 种存在军营的情况桥必须选，剩下三角无军营的情况桥可选可不选，一共 $9$ 种。
- 外面的点没建军营，此时三角上 $7$ 建军营的情况，桥都可选可不选，一共 $14$ 种。

 这样样例就推出来了，通过上面的启发，这题第一步是求边双连通分量，然后缩点成一棵树。缩点后的内部边就没用了（化成了一个 $2^k$ 的系数最后乘上去），只需考虑原图每个桥是否要选。

通过树形 DP 来解决问题，记 $f_u$ 表示 $u$ 子树中至少选了一个点，且能连接到 $u$ （也就是中途的树边都必须选）的方案数，$a_u$ 表示缩点后每个点包含原图的点数，$sz_u$ 为树上的子树大小（这样一个子树内的边数就是 $sz_u -1$）。

考虑求 $f_u$，结点 $u$ 中的点随便选，这样有 $2^{a_u}$ 种，对每个儿子 $v$ 分两种情况：

- 该儿子的子树中一个点也没选，此时子树内的边和$<u,v>$ 这条边任意选，有 $2^{sz_v}$ 种；
- 该儿子的子树至少选了一个点，此时 $<u,v>$ 这条边必须选，有 $f_v$ 种

上述情况会产生一个点都不选的可能，此时所有边都可选可不选，所以要减去 $2^{sz_u-1}$ 种。

综上所述， $f_u=2^{a_u}\prod\limits_v(2^{sz_v}+f_v)-2^{sz_u-1}$，而最终答案的方案数可以利用 $f_u$ 来计算。

为了保证每种建造军营的点集不重复不遗漏的计算，我们将在它们 LCA 处统计。也就是说在 $u$ 处统计的答案，要么是 $u$ 本身选了点，要么 $u$ 至少有两个儿子的子树选了点，这两种情况都在 $f_u$ 里出现。$u$ 作为 LCA，那么树外的边就可以随便选，这样有个 $2^{c-1-(sz_u-1)}=2^{c-sz_u}$  的系数，其中 $c$ 为缩点后的点数。

考虑从 $f_u$ 中减去非法的方案，也就是结点 $u$ 没有选且只有一个儿子的子树里选了点。枚举儿子 $v$，有 $f_v$ 种方案，对于其他儿子的子树里的边都是可选可不选，这些边数为 $sz_u-1-sz_v$（注意 $<u,v>$ 这条边也是必须选的，否则不会在 $f_u$ 中）。

这样，$u$ 作为 LCA 对答案的贡献为 $(f_u-\sum\limits_v f_v\cdot2^{sz_u-sz_v-1})\times 2^{c-sz_u}$。

时间复杂度 $O(n+m)$，[具体细节见代码](https://www.luogu.com.cn/paste/7htallvs)。



---

## 作者：SDqwq (赞：16)

### 思路

由于只能断一条边，所以无论断哪条边，在同一个边双里的点一定仍然连通。

那么非割边就一定是可选可不选，那么就可以考虑先将这张图进行边双缩点，缩完点后是一棵树。

先考虑一个边双内部的方案数。容易求出边双内点数 $siz_u$ 和边数 $tot_u$。设 $val_u$ 表示 $u$ 号边双内部选了至少一个点的方案数，则 $val_u=2^{siz_u+tot_u}-2^{tot_u}$（总的减去不合法的方案数）。设 $w_u$ 表示该边双内一个点都不选的方案数，则 $w_u=2^{tot_u}$。

接下来考虑树形 dp。

设 $dp_{u,0/1,0/1}$ 表示以 $u$ 为根的子树内 没有/有 军营，$u$ 的子树外的点 没有/有 军营的方案数。为什么要加第二维？因为如果子树外有军营那么子树内选了的点往上的边必须每条都选，否则不一定，所以需要增加第二维限制。

考虑转移。

$$
dp_{u,0,0}=w_u\prod2dp_{v,0,0}
$$

$$
dp_{u,0,1}=w_u\prod2dp_{v,0,1}
$$

$$
dp_{u,1,0}=w_u[\sum(2dp_{v,1,0}\prod_{i\ne v}2dp_{i,0,0})+\prod(2dp_{v,0,1}+dp_{v,1,1})-\prod2dp_{v,0,1}-\sum(dp_{v,1,1}\prod_{i\ne v}2dp_{v,0,1})]
$$

$$
+val_u\prod(2dp_{v,0,1}+dp_{v,1,1})
$$

$$
dp_{u,1,1}=w_u[\prod(2dp_{v,0,1}+dp_{v,1,1})-\prod2dp_{v,0,1}]+val_u\prod(2dp_{v,0,1}+dp_{v,1,1})
$$

解释一下，对于 $dp_{u,0,0}$ 和 $dp_{u,0,1}$ 不必多说，就是 $u$ 不选的方案数乘上每个儿子自身的方案数，与之相连的边自然也是可选可不选。

接下来是最复杂的 $dp_{u,1,0}$，分两种情况：

- $u$ 号边双内的点一个都不选，此时再分两种情况：

	- $u$ 的儿子中只选了一个。那么此时 $u$ 的所有出边都是可选可不选。至于转移，就是枚举每个儿子，钦定选这个儿子，然后乘上其他儿子都不选的方案数。
   
   - $u$ 的儿子中选了两个及以上。此时儿子的第三维都是 $1$ 了。正难则反，考虑用总的减去不合法的。总的就是不管选了多少个儿子，那么每个儿子选和不选的方案数相加，再统一相乘就是总共方案数。首先减去一个儿子都没选的方案数，即每个儿子的第二维都是 $0$。再减去只选了一个儿子的方案数，类似于第一种情况，不过第二维是 $1$。减完后就是选了两个及以上的儿子的方案数。

- $u$ 号边双内的点选了至少一个。那么儿子就没有要求了，每个儿子选和不选的方案数相加，再统一相乘即可。不过因为 $u$ 再儿子子树外，所以儿子的第二维是 $1$。

此时再来看 $dp_{u,1,1}$，还是两种情况：

- $u$ 号边双内的点一个都不选。因为 $u$ 子树外还有军营，那么只要儿子有军营，就必须选 $u$ 和儿子之间的边。直接用总方案数减去所有儿子都没选的方案数即可。

- $u$ 号边双内的点选了至少一个。与 $dp_{u,1,0}$ 的第二种情况完全一致。

转移到这里就结束了。不过这个式子直接求是 $\mathcal{O}(n^2)$ 的。观察到那一坨最复杂的式子其实是一整段中间掐掉了一个数，所以可以预处理总乘积，然后把掐掉的那个数除掉。不过需要求逆元，带了个 $\log$。

注意到其实是两段相乘，并且一个是前缀，一个是后缀。于是考虑处理出前后缀积，就可以快速计算了。

时间复杂度 $\mathcal{O}(n)$。

### 代码

```cpp
#include <cstdio>
#include <iostream>
#include <vector>
#define ll long long
using namespace std;
const int N = 5e5 + 5, M = 2e6 + 5;
const ll mod = 1e9 + 7;
inline ll addmod(ll x, ll y) {return x + y >= mod ? x + y - mod : x + y;}
inline ll decmod(ll x, ll y) {return x - y < 0 ? x - y + mod : x - y;}

int n, m, tot[N];
ll pw[M], val[N], w[N], pre[N], suf[N], dp[N][2][2];
vector<int> G[N];

void init_pw(int n) {
	pw[0] = 1;
	for (int i = 1; i <= n; i++) pw[i] = pw[i - 1] * 2 % mod;
}

int cnt = 1, elst[N];
struct edge {
	int to, nxt;
} e[M];
void add(int u, int v) {
	e[++cnt].to = v;
	e[cnt].nxt = elst[u];
	elst[u] = cnt;
}

int tim, dc, dfn[N], low[N], dcc[N], siz[N];
int tp, stk[N];
void tarjan(int u, int from) {
	dfn[u] = low[u] = ++tim;
	stk[++tp] = u;
	for (int i = elst[u]; i; i = e[i].nxt) {
		int v = e[i].to;
		if (!dfn[v]) tarjan(v, i), low[u] = min(low[u], low[v]);
		else if (i != (from ^ 1)) low[u] = min(low[u], dfn[v]);
	}
	if (dfn[u] == low[u]) {
		dc++;
		while (stk[tp] != u) {
			dcc[stk[tp]] = dc;
			siz[dc]++;
			tp--;
		}
		dcc[stk[tp]] = dc;
		siz[dc]++;
		tp--;
	}
}

void dfs(int u, int fa) {
	if (G[u].size() == 1 && u > 1) {
		dp[u][0][0] = dp[u][0][1] = w[u];
		dp[u][1][0] = dp[u][1][1] = val[u];
		return;
	}
	for (auto v : G[u]) {
		if (v == fa) continue;
		dfs(v, u);
	}
	ll s = 0, pro1 = val[u];
	pre[0] = suf[G[u].size() + 1] = 1;
	for (int i = 0; i < G[u].size(); i++) {
		int v = G[u][i];
		if (v == fa) {pre[i + 1] = pre[i]; continue;}
		pre[i + 1] = pre[i] * 2 % mod * dp[v][0][0] % mod;
	}
	for (int i = G[u].size() - 1; i >= 0; i--) {
		int v = G[u][i];
		if (v == fa) {suf[i + 1] = suf[i + 2]; continue;}
		suf[i + 1] = suf[i + 2] * 2 % mod * dp[v][0][0] % mod;
	}
	for (int i = 0; i < G[u].size(); i++) {
		int v = G[u][i];
		if (v == fa) continue;
		s = addmod(s, dp[v][1][0] * 2 % mod * pre[i] % mod * suf[i + 2] % mod);
		s = decmod(s, dp[v][1][1] * pre[i] % mod * suf[i + 2] % mod);
	}
	dp[u][0][0] = dp[u][0][1] = dp[u][1][0] = dp[u][1][1] = w[u];
	for (auto v : G[u]) {
		if (v == fa) continue;
		dp[u][0][0] = dp[u][0][0] * 2 % mod * dp[v][0][0] % mod;
		dp[u][0][1] = dp[u][0][1] * 2 % mod * dp[v][0][1] % mod;
		dp[u][1][0] = dp[u][1][0] * addmod(dp[v][0][1] * 2 % mod, dp[v][1][1]) % mod;
		dp[u][1][1] = dp[u][1][1] * addmod(dp[v][0][1] * 2 % mod, dp[v][1][1]) % mod;
		pro1 = pro1 * addmod(dp[v][0][1] * 2 % mod, dp[v][1][1]) % mod;
	}
	dp[u][1][0] = decmod(dp[u][1][0], dp[u][0][1]);
	dp[u][1][0] = addmod(dp[u][1][0], s * w[u] % mod);
	dp[u][1][1] = decmod(dp[u][1][1], dp[u][0][1]);
	dp[u][1][0] = addmod(dp[u][1][0], pro1);
	dp[u][1][1] = addmod(dp[u][1][1], pro1);
}

int main() {
	scanf("%d %d", &n, &m);
	init_pw(n + m);
	for (int i = 1; i <= m; i++) {
		int u, v;
		scanf("%d %d", &u, &v);
		add(u, v);
		add(v, u);
	}
	if (n == 1) return puts("1"), 0;
	tarjan(1, 0);
	for (int i = 2; i <= cnt; i += 2) {
		int u = e[i ^ 1].to, v = e[i].to;
		if (dcc[u] != dcc[v]) G[dcc[u]].push_back(dcc[v]), G[dcc[v]].push_back(dcc[u]);
		else tot[dcc[u]]++;
	}
	for (int i = 1; i <= dc; i++) val[i] = decmod(pw[siz[i] + tot[i]], pw[tot[i]]), w[i] = pw[tot[i]];
	dfs(1, 0);
	printf("%lld", dp[1][1][0]);
	return 0;
}
```

---

## 作者：Lazy_Labs (赞：8)

# 0.说在前面
论一个人赛时花了3h想T2，T3 T4看了一眼感觉不会做就没做，赛后出来AC是什么感觉。
# 1.转化题面
可以发现，如果敌人在一个边双连通分量里面进行“切断”，那么并没有什么软用。所以我们可以先缩点，转化成一个树上问题。

因此本题转化为：可以选择一些点和一些边，使得构成的图上所有的点连通，的方案数。

这很可以树上DP。

规定：边和点若前面加上了“总”进行修饰，那么每个点代表的点双内的边也需要计算进去。

点 $i$ 代表的点双中边的个数为 $ege_i$，点个数为 $pnt_i$。
# 2.DP
## DP状态
我们发现这是一个连通性问题，所以可以设出一个状态：

$dp_{i,2}$ 表示 $i$ 子树里面选择至少一个点，且连通块不与节点 $i$ 连通的方案数。

$dp_{i,1}$ 表示 $i$ 子树里面选择至少一个点，且与节点 $i$ 连通的方案数。

前两个是很显然的一个DP状态，最后一个是方便代码编写的。

$dp_{i,0}$ 表示 $i$ 子树里面一个点都不选的方案数。（即 $i$ 子树内总边的个数的 $2$ 的次幂）
## DP转移
对于 $i$ 子树里面一个点都不选的方案数，显然有：

$$dp_{i,0}=2^{ege_i}\prod_{j \in son(i)}dp_{j,0}\times 2$$

对于 $i$ 子树里面选择至少一个点，且与节点 $i$ 连通，可以发现对于每个子树 $j$：

要么这个子树里面没有点，即 $dp_{j,0}$，此时连接 $i$ 和 $j$ 的边可选可不选；

要么子树里面有点且与 $j$ 相连，即 $dp_{j,1}$，此时连接 $i$ 和 $j$ 的边必须选择。

对于本点，可以随意选择点双内的边或者点。但是不能算上所有点都不选择的情况，即 $dp_{i,0}$。那么有：

$$dp_{i,1}=2^{ege_i}\times 2^{pnt_i}  \prod_{j \in son(i)}\left( dp_{j,1}+dp_{j,0}\times2 \right)-dp_{i,0}$$

对于 $i$ 子树里面选择至少一个点，且连通块不与节点 $i$ 连通，可以发现需要有一个子树是不连通，其余的连通块以及 $i$ 均为不选择。

所以我们只需要对于每一个儿子 $j$ 的 $dp_{j,2}$ 可以有两种，$dp_{j,1}$ 只能不选 $i$ 和 $j$ 连接的边，最后乘上 $i$ 子树内其余的总边数的 $2$ 的次幂，可以用 $dp_{i,0}$ 和 $dp_{j,0}$ 推出。那么有：

$$dp_{i,2}=2^{ege_i} \sum_{j \in son(i)}\left(
\left(dp_{j,2}+\dfrac{dp_{j,1}}{2}\right)\times\dfrac{dp_{i,0}}{dp_{j,0}} \right)$$
# 3.细节
注意在转移 $dp_{i,2}$ 的时候使用的 $dp_{i,0}$ 必须是递推完的，所以 $dp_{i,2}$ 需要单独去做。

作者用的是 `tarjan` 缩点，具体可以看代码。

~~才不会告诉你作者因为模数写错调了一个晚上~~

如果此题的模数不是质数也可以这么做，因为其实 $dp_{i,0}$ 你可以记是 $2$ 的几次幂，这样就可以直接进行加减运算了。
# 4.CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
inline int read()
{
	int x(0),f(1);char c=getchar();
	while(c<'0'||c>'9')f=c=='-'?-1:1,c=getchar();
	while(c<='9'&&c>='0')x=x*10+c-48,c=getchar();
	return x*f;
}
const int N=500010,M=1000010,mod=1e9+7;
int to[M<<1],nxt[M<<1],head[N],tot=1;
bool bri[M<<1];int n,m;
void add(int x,int y)
{
	nxt[++tot]=head[x];head[x]=tot;to[tot]=y;
	nxt[++tot]=head[y];head[y]=tot;to[tot]=x;
}
int dfn[N],low[N],cnt;
void tarjan(int x,int fa)
{
	dfn[x]=low[x]=++cnt;
	for(int i=head[x];i;i=nxt[i])if(to[i]!=fa)
	{
		int y=to[i];
		if(!dfn[y])tarjan(y,x),low[x]=min(low[x],low[y]);
		else low[x]=min(low[x],dfn[y]);
		if(dfn[x]<low[y])bri[i]=bri[i^1]=1;
	}
}
int bel[N];struct node{int pnt,ege;}ecc[N];
vector<int>G[N];int num;
void add2(int x,int y){G[x].push_back(y);G[y].push_back(x);}
void dfs(int x)
{
	bel[x]=num;ecc[num].pnt++;
	for(int i=head[x];i;i=nxt[i])if(!bri[i])
	{
		int y=to[i];
		if(!bel[y])dfs(y);
		ecc[num].ege++;
	}
	else if(bel[to[i]])add2(bel[x],bel[to[i]]);
}
int f[N][3];
int ksm(int a,int n)
{
	int ans=1;
	while(n)
	{
		if(n&1)ans=1ll*ans*a%mod;
		a=1ll*a*a%mod;n>>=1;
	}
	return ans;
}
//f[i][0]:i de zi shu li mian yi ge dian dou bu xuan de qing kuang
//f[i][1]:i de zi shu li mian you zhi shao yi ge dian qie he dian i lian tong
//f[i][2]:i de zi shu li mian you zhi shao yi ge dian qie bu he dian i lian tong
void dp(int x,int fa)
{
	f[x][0]=ksm(2,ecc[x].ege);
	f[x][1]=1ll*ksm(2,ecc[x].ege)*ksm(2,ecc[x].pnt)%mod;
	f[x][2]=0;
	for(auto y:G[x])if(y!=fa)
	{
		dp(y,x);
		f[x][0]=2ll*f[x][0]*f[y][0]%mod;
		f[x][1]=(2ll*f[y][0]+f[y][1])%mod*f[x][1]%mod;
	}
	for(auto y:G[x])if(y!=fa)f[x][2]=((1ll*ksm(2,mod-2)*f[y][1]%mod+f[y][2])%mod*f[x][0]%mod*ksm(f[y][0],mod-2)%mod+f[x][2])%mod;
	f[x][1]=(f[x][1]-f[x][0]+mod)%mod;
}
signed main()
{
// 	freopen("pai.out","w",stdout);
// 	freopen("pai.in","r",stdin);
	n=read(),m=read();
	for(int i=1;i<=m;i++)add(read(),read());
	tarjan(1,0);
	for(int i=1;i<=n;i++)if(!bel[i])num++,dfs(i),ecc[num].ege>>=1;
//	for(int i=1;i<=n;i++)cerr<<bel[i]<<" ";cerr<<endl;
//	for(int i=1;i<=num;i++)
//	{
//		cerr<<i<<":";
//		for(auto j:G[i])cerr<<j<<" ";cerr<<endl;
//		cerr<<ecc[i].ege<<" "<<ecc[i].pnt<<endl;
//	}
	dp(1,0);
	printf("%lld",(f[1][2]+f[1][1])%mod);
	return 0;
}
```

---

## 作者：jifbt (赞：7)

如果两个军营在同一边双内，则无需看守任何道路。用 Tarjan 找出边双。

记 $f_i$ 表示在全图内随机看守，边双 $i$ 的子树内选点所形成的合法方案数的期望除以二，答案为

$$2^m (2f_1 + \sum_{i=2}^n f_i) = 2^m (f_1 + \sum_{i=1}^n f_i).$$

根节点外的节点不用把 $2$ 乘回去，因为如果到父亲的道路被看守，会在祖先被统计。

转移需分类讨论。边双 $i$ 内没选点时，儿子的合法方案数只与子树内的边是否看守有关，彼此独立，期望相乘。到所有被选中的儿子的边都得看守，要除以 $2^{\text{(被选中的孩子个数)}}$，恰等于被选中的儿子的 $f$ 值之积。枚举选中儿子的集合（不能为空），方案数是

$$\left( \prod_{x\in son_i} f_x + 1 \right) - 1.$$

有选时情况类似，但是儿子可以都不选。记 $z$ 为边双内的点数，方案数是

$$(2^{z_i} - 1)\left( \prod_{x\in son_i} f_x + 1 \right).$$

加起来并除以二，得到递推式：

$$f_i = \left( 2^{z_i-1} \prod_{x\in son_i} f_x + 1 \right) - \frac12.$$


```cpp
#include<bits/stdc++.h>
using namespace std;
template<typename T>void rd(T&x){
	x=0;int f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=x*10+c-48;c=getchar();}
	x*=f;
}
typedef long long ll;
const int N=5e5+10,M=1e6+10,E=M*2;
const ll mod=1e9+7;
ll qpow(ll x,ll y){
	ll z=1;
	while(y){
		if(y&1)z=z*x%mod;
		x=x*x%mod;
		y>>=1;
	}
	return z;
}
const int half=qpow(2,mod-2);
int n,m,deg[N];
struct T{
	int e=1,n[E],t[E],h[N];
	void lnk(int x,int y){
		n[++e]=h[x];
		t[e]=y;
		h[x]=e;
	}
}g,h;
int c,d[N],l[N];
int t,s[N];
int p,b[N],z[N];
void tarj(int x,int f){
	d[x]=l[x]=++c;
	s[t++]=x;
	for(int i=g.h[x];i;i=g.n[i]){
		int y=g.t[i];
		if(!d[y]){
			tarj(y,x);
			l[x]=min(l[x],l[y]);
		}else if(y!=f)l[x]=min(l[x],d[y]);
	}
	if(d[x]==l[x]){
		++p;
		do{
			--t;
			b[s[t]]=p;
			++z[p];
		}while(s[t]!=x);
	}
}
ll dp[N],ans;
void dfs(int x,int f){
	dp[x]=qpow(2,z[x]-1);
	for(int i=h.h[x];i;i=h.n[i]){
		int y=h.t[i];
		if(y==f)continue;
		dfs(y,x);
		dp[x]=dp[x]*(dp[y]+1)%mod;
	}
	dp[x]=(dp[x]+mod-half)%mod;
	ans=(ans+dp[x])%mod;
}
int main(){
	rd(n);rd(m);
	for(int i=1,u,v;i<=m;++i)rd(u),rd(v),g.lnk(u,v),g.lnk(v,u),++deg[u],++deg[v];
	tarj(1,1);
	for(int x=1;x<=n;++x){
		for(int i=g.h[x];i;i=g.n[i]){
			int y=g.t[i];
			if(b[x]!=b[y])h.lnk(b[x],b[y]);
		}
	}
	dfs(1,1);
	printf("%lld",(ans+dp[1])*qpow(2,m)%mod);
}

```

---

## 作者：蒟蒻君HJT (赞：6)

写一篇题解记录一下 OI n 年场切的唯二橙以上的题目。

另一道是今年 T1 。 ~~可以看出以前我多菜了吧~~

tag：缩点，树形 dp

## 一、题意：

- 给定 $n$ 个点 $m$ 条边的连通无向图，无重边无自环。

- 选取任意个关键点并保护任意条关键边，使得任意一条未被保护的边被切断后，关键点依然互相连通。、

- 求总方案数对 $p = 10^9+7$ （质数）取模的结果。

- $n = 5 \cdot 10^5, m = 10^6$ , 1s 512MB。

## 二、解法

首先可以发现，因为我们至多切断一条边，所以所有存在于至少一个简单环中的边被切断必然对结果无影响。

于是，第一步是对整个无向图进行缩点，**缩成一棵树**，并记录每个边双的边数 $edg_i$ 和点数 $siz_i$ 。

不会边双的可以在这里学习一下。其实就是 dfs 。

- [边双连通分量](https://www.luogu.com.cn/problem/P8436)

不难想到使用树形 dp 来计数，因为从子节点往上爪巴的过程中，本质上只有三种对之后选点有不同影响的情况：

（假设当前子树为 $x$）

1. 没选点。

2. 选了点，且这些点全部连通到当前子树的根节点。

3. 选了点，且存在一个点，没有连通到当前子树的根节点。

第三种情况限制了在这棵子树 $x$ 外不能再选别的点。

第二种情况可能会在未来转化为第三种情况，所以要跟第一种情况区别开来。

其实聪明的同学可以发现第一种情况根本不用 dp ，可以直接用子树内的总边数算出来。。。场上没想清楚

假设 $x$ 的儿子结点为 $v_1, v_2, ..., v_m$ ：

分别以 $dp_{x, 1}, dp_{x, 2}, dp_{x, 3}$ 表示这三种情况仅考虑子树 $x$ 的方案数。 

$$dp_{x, 1} = 2^{edg_x+m}\prod_{i=1}^{m}dp_{v_i, 1}$$

$$dp_{x, 2} = 2^{edg_x+siz_x}\prod_{i=1}^{m}(2dp_{v_i, 1} + dp_{v_i, 2}) - 2^{edg_x+m}\prod_{i=1}^{m}dp_{v_i, 1}$$

$$dp_{x, 3} = 2^{edg_x}\sum_{i=1}^{m}(2dp_{v_i, 3} + dp_{v_i, 2}) \frac{\prod_{j=1}^{m}(2dp_{v_j, 1})}{2dp_{v_i, 1}}$$

前两个式子应该不用解释吧？要注意的是儿子连向父结点的割边不要忘记算进去。

第三个式子：实际上就是枚举哪个子树中出现了不连接到顶端的结点，可以分成两种情况：

1. 之前就有了这种结点。

2. 不保护这条割边于是出现了这种结点。

分别对应了 $2dp_{v_i, 3}$ 和 $dp_{v_i, 2}$ 。还得乘上其他子树（不能再有情况 $3$ 了）选点的贡献。

实现上可以预处理 $2$ 和 $0.5$ 的幂次，不要每次都快速幂和快速幂求逆元。

最后答案就是 $dp_{1, 2} + dp_{1, 3}$ 。

## 三、代码

实现的很差，是 $O(n\log p + m)$ 的，可以优化到 $O(n + m)$ 。

```cpp
#include <bits/stdc++.h>
const int mod = 1e9 + 7;
int n, m;
std::vector <int> ver[500005], nv[500005];
inline int add(int x, int y){
	return x + y >= mod ? x + y - mod : x + y;
}
inline int mul(int x, int y){
	return (int)(1ll * x * y % (1ll * mod));
}
inline int minus(int x, int y){
	return x < y ? x - y + mod : x - y;
}
inline int Qpow(int x, int y){
	int r = 1;
	while(y){
		if(y & 1) r = mul(r, x);
		x = mul(x, x);
		y >>= 1;
	}
	return r;
}
inline int read(){
	char c = getchar();
	int x = 0;
	while(c < '0' || c > '9') c = getchar();
	while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
	return x; 
} 
int dfn[500005], low[500005], tp = 0, stk[500005], vis[500005], dsum = 0;
int siz[500005], cnt = 0, id[500005], cnte[1000005], pw2[1000005];
int dp[500005][3];
inline int inv(int x){
	return Qpow(x, mod - 2);
}
void dfs1(int x, int fa){
	dfn[x] = low[x] = ++dsum;
	vis[x] = 1;
	stk[++tp] = x;
	int s = ver[x].size();
	for(int i = 0; i < s; ++i){
		int y = ver[x][i];
		if(y == fa) continue;
		if(!dfn[y]) dfs1(y, x), low[x] = std::min(low[x], low[y]);
		else if(vis[y]) low[x] = std::min(low[x], dfn[y]);
	}
	if(low[x] == dfn[x]){
		++cnt;
		while(stk[tp] != x){
			vis[stk[tp]] = 0;
			++siz[cnt];
			id[stk[tp]] = cnt;
			--tp;
		}
		--tp;
		++siz[cnt];
		id[x] = cnt;
		vis[x] = 0;
	}
	return ;
}
void dfs2(int x, int fa){
	dp[x][0] = pw2[cnte[x]];
	int s = nv[x].size(), o = 1;
	for(int i = 0; i < s; ++i){
		int y = nv[x][i];
		if(y == fa) continue;
		dfs2(y, x);
		dp[x][0] = mul(dp[x][0], mul(2, dp[y][0]));
		o = mul(o, mul(2, dp[y][0]));
	}
	dp[x][1] = mul(pw2[siz[x]], pw2[cnte[x]]);
	for(int i = 0; i < s; ++i){
		int y = nv[x][i];
		if(y == fa) continue;
		int tmp = mul(2, dp[y][0]);
		tmp = add(tmp, dp[y][1]);
		dp[x][1] = mul(dp[x][1], tmp);
	}
	dp[x][1] = minus(dp[x][1], dp[x][0]);
	for(int i = 0; i < s; ++i){
		int y = nv[x][i];
		if(y == fa) continue;
		int U = mul(o, inv(dp[y][0])), V;
		U = mul(U, inv(2));
		V = add(mul(2, dp[y][2]), dp[y][1]);
		dp[x][2] = add(dp[x][2], mul(U, V));
	}
	dp[x][2] = mul(dp[x][2], pw2[cnte[x]]);
	return ;
}
int main(){
	//freopen("barrack.in", "r", stdin);
	//freopen("barrack.out", "w", stdout);
	pw2[0] = 1;
	for(int i = 1; i <= 1000000; ++i) pw2[i] = mul(2, pw2[i - 1]);
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= m; ++i){
		int x, y; x = read(), y = read();
		ver[x].push_back(y);
		ver[y].push_back(x);
	}
	dfs1(1, 0);
	for(int i = 1; i <= n; ++i){
		int s = ver[i].size();
		for(int j = 0; j < s; ++j){
			int y = ver[i][j];
			if(i < y) continue;
			if(id[i] == id[y]){
				++cnte[id[i]];
				continue;
			}
			nv[id[i]].push_back(id[y]);
			nv[id[y]].push_back(id[i]);
		}
	}
	dfs2(1, 0);
	printf("%d\n", add(dp[1][1], dp[1][2]));
	return 0;
}
```


---

## 作者：ningago (赞：5)

性质 $0$：根据边双联通分量缩点后的图是一颗树。

性质 $1$：非桥边的保护情况任意。

这个显然，因为你可以找到另一条路连接。

性质 $2$：两个点同时是关键点，则两点之间路径上的桥边必须保护。

原因是桥边在路径上是一定被包含的。

性质 $3$：初中因式分解：

$$a_1\cdot a_2\cdot a_3+a_1\cdot a_2\cdot a_3'+a_1\cdot a_2'\cdot a_3+a_1'\cdot a_2\cdot a_3+a_1\cdot a_2'\cdot a_3'+a_1'\cdot a_2\cdot a_3'+a_1'\cdot a_2'\cdot a_3$$

$$=(a_1+a_1')(a_2+a_2')(a_3+a_3')-a_1'\cdot a_2'\cdot a_3'$$

扩展到 $n$ 项的形式显然，这个性质后面会用到。

---

于是我们开始树形 DP：

以下非特殊说明均在缩点后讨论。

我们对于每个点考虑这个点和他的父亲边被不被选，围绕四种情况讨论：

![](https://cdn.luogu.com.cn/upload/image_hosting/uxyhvuj6.png)

定义：

$sz_k$ 表示 $k$ 所在双连通分量大小；$weight_k$ 表示 $k$ 的子树大小；

$dp_{k,0,0}$ 表示**这个子树一个点都不选**的方案数（容易发现，他的值等于 $2^{weight_k-1}$，不过还是 DP 计算一下）；$dp_{k,1,0}$ 表示这个子树选了点，**选了的点之间联通，但每个选了的点与根的路径不联通，或是根的父亲边不选**的方案数；反之，$dp_{k,1,1}$ 表示这个子树选了点，**选了的点之间联通，每个点都与根联通，且根的父亲边被选**的方案数；

$nx$ 表示 $k$ 的某个儿子。

以下分讨中选择边的条件是 $k\ne 1$（根节点没有父亲）。

选择 $k$ 节点的方案数为 $t=2^{sz_k}-1$，不选显然为 $1$。

---
情况 $1$：根以外的点都不选。

这时候只需考虑根的选择情况。

① 点不选，边不选，$dp_{k,0,0}=dp_{k,0,0}+\prod_{nx}dp_{nx,0,0}$。

② 点不选，边选，$dp_{k,0,0}=dp_{k,0,0}+\prod_{nx}dp_{nx,0,0}$。

③ 点选，边不选，$dp_{k,1,0}=dp_{k,1,0}+t\times \prod_{nx}dp_{nx,0,0}$。

④ 点选，边选，$dp_{k,1,1}=dp_{k,1,1}+t\times \prod_{nx}dp_{nx,0,0}$。

----

情况 $2$：只有一个子树选了点，且与根不联通。

显然这时点肯定不选，边可以决策。

① 点不选，边选，$dp_{k,1,0}=dp_{k,1,0}+\sum_{nx}(dp_{nx,1,0}\times \prod_{nx'\ne nx}dp_{nx',0,0})$。

② 点不选，边不选，$dp_{k,1,0}=dp_{k,1,0}+\sum_{nx}(dp_{nx,1,0}\times \prod_{nx'\ne nx}dp_{nx',0,0})$。

--- 

情况 $3$：剩下的情况。

这些情况统一的特性是所有选了点的子树都有与根连边。

这样就有 $2^{\text{子节点个数}}$ 种选与不选的情况。

此时利用上面提到的性质 $3$，就可以线性计算。

① 点不选，边不选，$dp_{k,1,0}=dp_{k,1,0}+\prod_{nx}(dp_{nx,1,1}+dp_{nx,0,0})-\prod_{nx}dp_{nx,0,0}$。

② 点不选，边选，$dp_{k,1,1}=dp_{k,1,1}+\prod_{nx}(dp_{nx,1,1}+dp_{nx,0,0})-\prod_{nx}dp_{nx,0,0}$。

③ 点选，边不选，$dp_{k,1,0}=dp_{k,1,0}+t\times(\prod_{nx}(dp_{nx,1,1}+dp_{nx,0,0})-\prod_{nx}dp_{nx,0,0})$。

④ 点选，边选，$dp_{k,1,1}=dp_{k,1,1}+t\times(\prod_{nx}(dp_{nx,1,1}+dp_{nx,0,0})-\prod_{nx}dp_{nx,0,0})$。

---

答案即为 $dp_{1,1,0}\times 2^{\text{非桥边个数}}$。

---

[代码](https://www.luogu.com.cn/paste/jmbn284t)很丑。


感觉这个 DP 设计蠢得离谱，码量巨大，如有雷同纯属巧合。

---

## 作者：Missa (赞：3)

题意：

> 给定一张图，选择一些点和一些边，使得割断任意没有选的边，被选中的点仍连通。对 $10^9+7$ 取膜。
> 
> $n \leq 5 \cdot 10^5$

这篇题解会略讲缩边，详讲自己推 dp 状态与转移式的过程。

前置知识：[桥（割边）](https://oi-wiki.org/graph/cut/#%E5%89%B2%E8%BE%B9)、缩边。

感觉有些地方的逻辑绕了点，强制分了小段，希望能让阅读者看得更明白。

-----------

看到图和连通，立刻想到 tarjan。

割断一条没有选的边，选中的点仍连通，割非桥，整张图仍然连通。

把桥删掉，则整张图分成若干连通子图。可以把一张子图看成一个点，这样形成的新图上没有环，因为在环上的边都不是割边，那它就是一棵树。

设一个新点 $i$ 中 共有 $cntp_{i}$ 个原图中的节点，$cnte_{i}$ 条原图中的边。后面的点边均在新树上。

问题转化为：给定一棵树，每个点有 $(2^{cntp_i}-1) \cdot 2^{cnte_i}$ 种染色方式，每条边可以染色或不染色，问有几种染色方法，使得割断任意非染色边，所有染色点仍连通。

树上的问题相较图更好解决，因为转移方向固定为从儿子到父亲。那么显然，现在应该进行 dp。后面说的子树默认是根在 $1$ 的情况。

什么在转移时会造成影响呢？考虑 $u$ 和其儿子 $v$。当 $v$ 子树中有点被染色时，这个点需要与 $v$ 连通，且 $v$ 需要与 $u$ 连通，这是为了让 $v$ 中的点与整棵树其余部分连通。否则，$u$ 与 $v$ 间的边属于可有可无。

因此，设出 $dp_{u,0/1}$，$dp_{u,0}$ 强制 $u$ 及其子树不选任意一个点（空）；$dp_{u,1}$ 强制 $u$ 及其子树选至少一个点，且所有被选的点与 $u$ 连通（不空）。

现在来考虑如何计算答案。

常用的做法是把一个点集放到它们的 lca 处计算，但是，$dp_{u,1}$ 只考虑了连通性，而没有在意是否恰好是 lca。容斥应该可行。但是另一个想法是强制一个算入答案的状态不被另一个状态包含。

为了说明，先对树做一遍前缀和，设 $sum_i$ 为 $i$ 及其子树中的边数和，包括被缩掉的边。容易看出 $dp_{u,1} \cdot 2^{sum_1 - sum_u}$ 表示了所有点均位于 $u$ 子树，且所有点与 $u$ 连通时的情况数。

现在让一个情况不被另一个情况包含。注意到能统计到一个点集的点均在根到 lca 的链上，则统计时强制断掉 $u$ 与其父亲间的连边，就不会出现这些点都与 lca 的某个父亲连通的情况，从而保证了一个情况不会被统计多次。

说人话，找到一个点集的 lca，顺着 lca 往根走，满足每一步走过的边都被染色，则我们将在走到的那个点上统计整个子集的贡献。

$$
\left \{
\begin{aligned}
ans & \gets dp_{u,1} \cdot 2^{sum_1 - sum_u - 1} \quad & u \not = 1 \\
ans & \gets dp_{u,1} & u = 1
\end{aligned}
\right .
$$

对答案的贡献说清楚了，接着来说 dp 的求法。

设现在位于 $u$，要把 $dp_{v,0/1}$ 合并进 $u$，设 $dp'_{u,0/1}$ 为没有合并入 $v$ 前的情况。

$dp_{u,0}$ 显然只能从 $dp'_{u,0}$ 和 $dp_{v,0}$ 推出，且连接 $u,v$ 的边可有可无。

$$dp_{u,0} \gets dp'_{u,0} \cdot 2dp_{v,0}$$

$dp_{u,1}$ 可以从 $dp'_{u,1}$ 处得到，此时 $v$ 可以选择空或不空，空时中间边可有可无，否则必须有。

$$dp_{u,1} \gets dp'_{u,1} \cdot (dp_{v,1} + 2dp_{v,0})$$

$dp_{u,1}$ 也可以从 $dp'_{u,0}$ 处得到，此时 $v$ 必须非空，中间的边必须存在。

$$dp_{u,1} \gets dp'_{u,1} \cdot 2dp_{v,1}$$

初始时该点对应所有边均可选可不选，点看是否要求非空而言。

$$
\left \{
\begin{aligned}
dp_{u,0} & \gets 2^{cnte_u}  \\
dp_{u,1} & \gets 2^{cnte_u} \cdot (2^{cntd_u} - 1)
\end{aligned}
\right .
$$

结束。

AC 后去 infoj 翻了最短代码，深感自己写复杂了，居然 $4$ 个 dfs……

```cpp
#include <cstdio>
#include <iostream>
using namespace std;
const int M = 4e6, mod = 1000000007;
int add(int x, int y) {return ((x += y) >= mod) ? x-mod : x;}
void addn(int &x, int y) {if((x += y) >= mod) x -= mod;}
int mins(int x, int y) {return ((x -= y) < 0) ? x+mod : x;}
struct G{
    struct edge{
        int to, nxt, w;
    } e[M << 1];
    int head[M], cnt1 = 1;
    void link(int u, int v) {
        e[++cnt1] = {v, head[u], 1}; head[u] = cnt1;
    }
}g1, g2;
int fa[M]; 
int dfn[M], low[M], cnt; bool cut[M];
void tarjan(int u, int f) {
    low[u] = dfn[u] = ++cnt; 
    for(int i = g1.head[u]; i; i = g1.e[i].nxt) {
        int v = g1.e[i].to; if(v == f) continue;
        if(!dfn[v]){
            tarjan(v, u);
            low[u] = min(low[u], low[v]);
            if(low[v] > dfn[u]) g1.e[i].w = g1.e[i ^ 1].w = 0; // 0 标记为割边，i^1 用了成对变换的技巧，把反边一起标记
        }
        else low[u] = min(low[u], dfn[v]);
    }
} 
int siz1[M], siz2[M]; bool vis[M];
int bl[M];
int n, m, cnt2;
// 用于划分连通块，siz1 对应行文中的 cntp，点数；siz2 对应行文中的 cnte，边数
void dfs2(int u, int f, int t) {
    bl[u] = t; vis[u] = 1; ++siz1[t];
    for(int i = g1.head[u]; i; i = g1.e[i].nxt) {
        if(g1.e[i].w) ++siz2[t];
        int v = g1.e[i].to;
        if(g1.e[i].w == 0 || v == f) continue;
        if(!vis[v]) dfs2(v, u, t);
    }
}
int sm[M];
// 用于计算文中的 sum 数组，子树中边数和，包括被缩掉者
void dfs4(int u, int fa) {
    sm[u] = siz2[u];
    for(int i = g2.head[u]; i; i = g2.e[i].nxt) {
        int v = g2.e[i].to; if(v == fa) continue;
        dfs4(v, u);
        sm[u] += sm[v] + 1;
    }
}
int dp[M][2], pw[M], ans;
// 统计答案的 dfs，dp 意义如上文所叙
// dp_{u,0} 强制 u 及其子树不选任意一个点（空）
// dp_{u,1} 强制 u 及其子树选至少一个点，且所有被选的点与 u 连通（不空）。
void dfs3(int u, int fa) {
    dp[u][0] = pw[siz2[u]];
    dp[u][1] = 1ll * pw[siz2[u]] * (pw[siz1[u]] - 1) % mod;
    int tot = 0;
    for(int i = g2.head[u]; i; i = g2.e[i].nxt) {
        int v = g2.e[i].to; if(v == fa) continue;
        dfs3(v, u);
        dp[u][1] = add(1ll * dp[u][1] * add(1ll * dp[v][0] * 2 % mod, dp[v][1]) % mod, 1ll * dp[u][0] * dp[v][1] % mod);
        dp[u][0] = 1ll * dp[u][0] * 2 % mod * dp[v][0] % mod;
        addn(tot, dp[v][1]);
    }
    if(u != n+1) addn(ans, 1ll * dp[u][1] * pw[sm[n+1] - sm[u] - 1] % mod);
    else addn(ans, 1ll * dp[u][1] % mod);
}
int find(int u) {return u == fa[u] ? u : fa[u] = find(fa[u]);}
void merge(int u, int v) {if((u = find(u)) != (v = find(v))) fa[u] = v;}
int main(){
    scanf("%d %d", &n, &m);
    pw[0] = 1;
    for(int i = 1; i <= 2 * n + m; i++) pw[i] = 1ll * pw[i-1] * 2 % mod;
    for(int i = 1; i <= m; i++) {
        int u, v; scanf("%d %d", &u, &v);
        g1.link(u, v); g1.link(v, u);
    }
    tarjan(1, 0); cnt2 = n;
    for(int i = 1; i <= n; i++) if(!vis[i]) dfs2(i, 0, ++cnt2);
    for(int i = n+1; i <= 2*n; i++) {
        siz2[i] /= 2; 
    }
    // 缩边
    for(int i = 1; i <= 2*n; i++) fa[i] = i;
    for(int u = 1; u <= n; u++) {
        for(int i = g1.head[u]; i; i = g1.e[i].nxt) {
            int v = g1.e[i].to; 
            if(find(bl[u]) != find(bl[v])) g2.link(bl[u], bl[v]), g2.link(bl[v], bl[u]), merge(bl[u], bl[v]);
        }
    }
    // n+1 是缩完边后树的根
    dfs4(n+1, 0);
    dfs3(n+1, 0);
    printf("%d\n", ans);
}
```

感觉这是一道口嗨很简单的题，但细节什么的确实需要想清楚。评上位蓝或下位紫很恰当。

虽然我的思路看着很杂乱，但这确实是自己一步步想到的思路，自觉每一步的转化都能从上一步找到端倪，因为这是自己真实的思考过程。

赛时一眼缩边+树形 dp，然而没调完，花了 1h 回忆缩边的过程，回家再花了 30min 才写完。得到的教训是要好好复习学过的东西。

完结撒花 ovo

---

## 作者：nullqtr_pwp (赞：2)

与连通性强相关，对于无向图先用边双缩点成一棵树。

对于一个边双大点内部的边，设总共有 $t$ 条，由于只断一条边，这 $t$ 条无论选不选都不会影响任何一种方案的连通性，最终的答案乘上 $2^t$ 即可。

记缩完点后的图每个边双连通分量的大小为 $a_i$，那么我们只关心整个边双是否有点，如果有点的该边双的选点方案数就是 $2^{a_i}-1$，假设缩点后一共有 $m$ 个边双连通分量，方便起见从 $1$ 编号。

总体方案数看起来很烦，但是发现选点方案相同的可以归为一类，我们需要求选边方案数。整理一下问题，就是对于所有 $S\subseteq\lbrace1,2,\cdots,m\rbrace$ 的非空子集 $S$，考虑对于所有 $S_i\ne S_j$ 的路径上的所有边标记为关键边。对于所有关键边，必须选入看守的道路，否则断掉某个未被看守的关键边就寄了。那么就记有 $q$ 条关键边，算上选点的方案数就是：

$$2^{m-1-q}\prod_{i\in S}(2^{a_i}-1)$$

换一种对于关键边的描述：**选中点集的虚树上的所有边**。考虑用树上 DP 的形式来统计，并且用虚树的根来划分种类。记 $f_{u,0/1/2}$ 为：选出点集 $S$ 构成的虚树的根为 $u$，在虚树中 $u$ 的根的度数为 $0,1,\geq 2$ 的权值总和，讨论范围为 $u$ 的子树内。这三种度数分别对应：儿子子树中都没有 $S$ 中的点，恰有一个儿子的子树内存在 $S$ 中的点，以及多个儿子的子树内都存在 $S$ 中的点。

之所以要单独拉出来 $\ge 2$ 的情况，是因为此时 $u$ 是可以不选的，选点可以乘上 $(a_u+1)$ 也就是加上不选的情况，这不影响虚树。前两种在选点上就只能乘 $a_u$，这个放到遍历完儿子 $v$ 再乘。

每次合并儿子 $v$ 到 $u$ 时需要讨论 $v$ 子树内是否有点。

- $v$ 子树中没有 $S$ 中的点的情况直接乘上 $2^{\text{subtreesize}(v)}$ 即可，因为这些边都不会成为关键边。
- $v$ 子树中有 $S$ 中的点，这很麻烦。因为仅考虑 $S$ 在 $v$ 子树中的点集 $S'$ 时，$S'$ 的根可能是任意一个 $v$ 中的点 $w$，但是 $w$ 到 $v$ 的路径却需要都被守护。考虑这个用另一个 $dp_u$ 来记录，表示 $u$ 中选点集 $S$，考虑将除了虚树的关键边之外，将虚树的根到 $u$ 的路径也设为关键边，此时剩余边的权值乘上 $S$ 的权值之和。求出真正的 $u$ 的子树大小后，令 $dp_u=f_{u,0}+f_{u,1}+f_{i,2}$，再加上 $\sum_{v\in \text{son}(u)}2^{\text{subtreesize}(u)-1-\text{subtreesize}(v)}dp_v$ 即可，后者表示直接添加 $(u,v)$ 作为关键边，但是 $u$ 子树剩余不管。

统计答案时注意对 $f_{u,0}+f_{u,1}+f_{u,2}$ 再乘上 $2^{m-\text{subtreesize}(u)}$，因为没有考虑 $u$ 子树外面的边。

时间复杂度 $O(n)$。


```cpp
void solve(){
	n=read(),m=read(),pw[0]=1;
	F(i,1,1000000)pw[i]=add(pw[i-1],pw[i-1]);
	F(_,1,m){
		const int u=read(),v=read();
		e[u].push_back(v),e[v].push_back(u);
	}
	auto dfs=[&](auto self,int u,int fa)->void{
		dfn[u]=low[u]=++tim,ins[u]=1,stk[++top]=u;
		for(int v:e[u])if(v^fa){
			if(!dfn[v])self(self,v,u),chkmin(low[u],low[v]);
			else if(ins[v])chkmin(low[u],dfn[v]);
		}
		if(low[u]^dfn[u])return;
		++cnt;
		for(;;){
			const int v=stk[top--];
			++sizV[col[v]=cnt],ins[v]=0;
			if(u==v)break;
		}
	}; dfs(dfs,1,0);
	F(u,1,n)for(int v:e[u])if(u<v&&col[u]==col[v])++sizE[col[u]];
	F(u,1,n)for(int v:e[u])if(col[u]^col[v])g[col[u]].push_back(col[v]);
	auto dfs1=[&](auto self,int u,int fa)->void{
		siz[u]=1,f[u][0]=1;
		for(int v:g[u])if(v^fa){
			self(self,v,u),siz[u]+=siz[v];
			const int A=f[u][0],B=f[u][1],C=f[u][2];
			mul(f[u][0],pw[siz[v]]),mul(f[u][1],pw[siz[v]]),mul(f[u][2],pw[siz[v]]);
			inc(f[u][1],1ll*A*dp[v]%mod),inc(f[u][2],1ll*B*dp[v]%mod),inc(f[u][2],1ll*C*dp[v]%mod);
		}
		int sum=0;
		for(int v:g[u])if(v^fa)inc(sum,1ll*dp[v]*pw[siz[u]-siz[v]-1]%mod);
		mul(f[u][0],pw[sizV[u]]-1),mul(f[u][1],pw[sizV[u]]-1),mul(f[u][2],pw[sizV[u]]);
		dp[u]=add(f[u][0],add(f[u][1],f[u][2])),inc(dp[u],sum);
	}; dfs1(dfs1,1,0);
	int ans=0;
	F(u,1,cnt)inc(ans,1ll*pw[cnt-siz[u]]*add(f[u][0],add(f[u][1],f[u][2]))%mod);
	F(i,1,cnt)mul(ans,pw[sizE[i]]);
	printf("%d",ans);
}
```

---

## 作者：spdarkle (赞：2)

EX的计数题

显然先缩点，每个边双连通分量内部都是随便选边和选点的。由于这是一张无向连通图，所以缩点后是一棵树，对于计数题，不难想到是树形DP。考虑如何求解：

首先，由于缩点后建立的虚树要考虑每一个点所表示的边双连通分量的边数和点数，很烦，怎么办？也许我们可以采用某些方法使得我们只需要考虑一个？不难发现，我们可以先对总的方案数除以 $2^m$，这样就消去了边双连通分量内部的边的影响。但这样又会影响其他方案（树边是可以不被保护的）。那么考虑在选择保护一条树边的时候，就可以将答案的贡献除以 $2$，最后在乘回来的时候就等价于这条边不算（反正有乘法分配律，怎么玩都是对的）。

接着，考虑如何树形DP。最简单直接的套路是设 $f_i$ 表示以 $i$ 为根的子树的答案，这时候我们就需要考虑怎么维护了。由于我们要考虑每个点表示的边双连通分量，不妨设 $size_i$ 表示这个边双连通分量的大小，那么将所有的 $f_i$ 初始化为 $2^{size}-1$。(不能一个都不选。)

然后我们考虑转移，设 $u$ 节点的儿子节点分别为 $v_1\sim v_c$，那么由于 $v$ 的答案已经统计完毕，需要考虑不同的 $v$ 以及 $u$ 之间的关系。不难发现，但凡一个 $v_i$ 要与其他的 $v$ 或者 $u$ 组合，那么边$ (u,v_i)$ 就必须得保护。上文已经提到，我们先假设的是每一条边都可选可不选的，最后乘上 $2^m$ 。所以我们可以先设 $f'_{v_i}=\frac{f_{v_i}}{2}$，那么 $f_u$ 就应该是枚举 $u,v_1\sim v_c$ 的全部组合进行求和，也即 $2^{c+1}$ 种不同的组合。对于这个转移，我们设 $f_u^i$ 表示计算完 $u$ 和前 $i$ 棵子树组合的答案，则有：

$$f_{u}^i=f_{u}^{i-1}+f'_{v_i}+f'_{v_i}f_{u}^{i-1},ans=ans+f_{u}^{i-1}f'_{v_i}$$

前一节是之前的答案，后面两个式子是算上 $f_{v'}$ 的。这里有一个细节，我们在只选 $v_i$ 的时候也应该累计上 $f'_{v_i}$ 才对，而不应该累计上 $f_{v_i}$ （因为如果这个子树外有哪个节点被选了，这里都是必须保护的，而没有选的状态已经在 $f_{v_i}$ 累计过了，而 $ans$ 只会统计当前树 $u$ 的次数或者是 $u$ 的两个及其以上子树(或者是 $u$ 以及其他子树)进行组合的情况，此时是必然选了子树 $v$ 中选了的点到 $u$ 的边的。）

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
#define N 5000050
#define p 1000000007
int edcc,c[N],dfn[N],low[N],ans,a[N],num,tot=1,cnt,n,m,head[N],nxt[N],ver[N],inv=(p+1)>>1,bridge[N];
int shead[N],snxt[N],sver[N],f[N],stot=1;
void add_s(int u,int v){
    snxt[++stot]=shead[u],sver[shead[u]=stot]=v;    
}
void add(int u,int v){
    nxt[++tot]=head[u],ver[head[u]=tot]=v;
}
void dfs(int u,int fa){
    ans=(ans+f[u])%p;
    for(int i=shead[u];i;i=snxt[i]){
        int v=sver[i];
        if(v!=fa){
            dfs(v,u);
            f[v]=(1ll*f[v]*inv)%p;
            ans=(1ll*ans+1ll*f[u]*f[v]%p)%p;
            f[u]=(1ll*f[u]+1ll*f[v]+1ll*f[u]*f[v]%p)%p;
        }
    }
}
void tarjan(int u,int in){
//  cout<<u<<endl;
    dfn[u]=low[u]=++num;
    for(int i=head[u];i;i=nxt[i]){
        int v=ver[i];
        if(!dfn[v]){
            tarjan(v,i);
            low[u]=min(low[u],low[v]);
            if(dfn[u]<low[v]){
                bridge[i]=bridge[i^1]=1; 
            }
        }
        else if(i!=(in^1))low[u]=min(low[u],dfn[v]);
    }
//  cout<<u<<endl;
} 
void dfs2(int u,int num){
    c[u]=num;
    for(int i=head[u];i;i=nxt[i]){
        if(bridge[i]||c[ver[i]])continue;
        dfs2(ver[i],num);
    }
}
void init_1(){
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        int u,v;
        cin>>u>>v;
        add(u,v);add(v,u);
    }
    for(int i=1;i<=n;i++)if(!dfn[i])tarjan(i,0);
    for(int i=1;i<=n;i++)if(!c[i])dfs2(i,++edcc);
}
void init_2(){
    for(int i=1;i<=edcc;i++)f[i]=1;
    for(int i=1;i<=n;i++)f[c[i]]=1ll*f[c[i]]*2%p;
    for(int i=1;i<=edcc;i++)f[i]--;
    for(int i=2;i<=tot;i+=2){
        int u=ver[i],v=ver[i^1];
        if(c[u]==c[v])continue;
        add_s(c[u],c[v]);
        add_s(c[v],c[u]);
    } 
//  cout<<edcc<<"\n";
    dfs(1,0);
    for(int i=1;i<=m;i++)ans=1ll*ans*2%p;
    cout<<(ans%p+p)%p<<"\n";
}
signed main(){
    ios::sync_with_stdio(false);
//  freopen("barrack4.in","r",stdin);
    init_1();
//  cout<<"AS"<<endl;
    init_2();
}
```

---


# [NOIP 2012 提高组] 疫情控制

## 题目描述

H 国有 $n $ 个城市，这 $n$ 个城市用 $ n-1 $ 条双向道路相互连通构成一棵树，$1 $ 号城市是首都，也是树中的根节点。

H 国的首都爆发了一种危害性极高的传染病。当局为了控制疫情，不让疫情扩散到边境城市（叶子节点所表示的城市），决定动用军队在一些城市建立检查点，使得从首都到边境城市的每一条路径上都至少有一个检查点，边境城市也可以建立检查点。但特别要注意的是，首都是不能建立检查点的。

现在，在 H 国的一些城市中已经驻扎有军队，且一个城市可以驻扎多个军队。一支军队可以在有道路连接的城市间移动，并在除首都以外的任意一个城市建立检查点，且只能在一个城市建立检查点。一支军队经过一条道路从一个城市移动到另一个城市所需要的时间等于道路的长度（单位：小时）。

请问最少需要多少个小时才能控制疫情。注意：不同的军队可以同时移动。


## 说明/提示

【输入输出样例说明】

第一支军队在 $2$ 号点设立检查点，第二支军队从 $2$ 号点移动到$ 3$ 号点设立检查点，所需时间为 $3$ 个小时。

 
【数据范围】

保证军队不会驻扎在首都。

- 对于 $20\%$ 的数据，$2 \le n\le 10$；
- 对于 $40\%$ 的数据，$2 \le n\le 50$，$0<w <10^5$；
- 对于 $60\%$ 的数据，$2 \le n\le 1000$，$0<w <10^6$；
- 对于 $80\%$ 的数据，$2 \le n\le 10^4$；
- 对于 $100\%$ 的数据，$2\le m\le n≤5\times 10^4$，$0<w <10^9$。


NOIP 2012 提高组 第二天 第三题


## 样例 #1

### 输入

```
4 
1 2 1 
1 3 2 
3 4 3 
2 
2 2```

### 输出

```
3```

# 题解

## 作者：TEoS (赞：937)

作为NOIp2012D2T3，这道题可以说是比较复杂了。思路虽然不会太难，但实现起来比较复杂，细节很多。虽然比不上很多巨佬题目，但身为紫题也可以说是当之无愧了。不过虽说复杂，理解了思路之后实现起来也不会难。

本蒟蒻完全看不懂题解中各位大佬的代码，于是决定写一篇题解。本文的思路和代码会尽量清晰，希望能对大家有帮助。

本文的思路和大部分大佬的思路基本相同，主要是为大家带来更具体的讲解和更清晰的实现。

------------
实现流程：树上倍增预处理+二分答案+贪心

思路：

因为若一个时间限制满足题意，则所有比它大的时间限制一定都满足题意，因此本题答案具有单调性，可以想到二分答案求解。

那么接下来的重点就是check函数了，如何判断一个时间限制符不符合条件呢？显然，对于所有军队，我们希望它最后停留的节点深度越小越好，这样可以控制最多的路径。因此我们让所有的军队尽量地向上走，若一个军队可以走到根节点，则令其暂时停在根节点的子节点；否则走到时间限制内能够走到的深度最小的节点。这个步骤可以用树上倍增进行优化。

经过这步处理后，我们先找出所有以根节点的子节点为根的子树中，是否有到叶子节点的路径还未被驻扎，并记录下还有路径未被驻扎的这些子树的根节点。对于这些节点，可以证明，若该节点上停留有军队，则剩余时间最小的军队驻扎在该节点一定是最优的。这样处理过这些节点后，把剩下的节点按照到根节点的距离从小到大排序。

现在可能还会有一些军队未确定最后的驻扎节点，把这些军队按照剩余时间从小到大排序，然后和上一步处理出来的这些节点一一进行匹配。这是一个可以证明正确性的贪心策略。若所有未被驻扎的节点都有军队驻扎，则说明当前的时间限制可行；反之则不可行。

接下来会对实现流程进行具体地讲解。

------------
具体实现流程：

**1.输入** 

输入就不多说了，建议用邻接表存图，遍历时更方便。因为路径是双向的，因此要双向存边。在输入的同时统计所有路径的长度之和，以作为二分的右边界。

```cpp
int ver[2*N],edge[2*N],Next[2*N],head[N],query[N];

void add(int x,int y,int z)
{
	ver[++tot]=y,edge[tot]=z,Next[tot]=head[x],head[x]=tot;
}//邻接表插入操作

cin>>n;

for(int i=1;i<n;i++)
{
	int x,y,z;
	scanf("%d%d%d",&x,&y,&z);
	add(x,y,z),add(y,x,z);
	r+=z;//统计所有边的长度之和
}

cin>>m;
for(int i=1;i<=m;i++)
	scanf("%d",&query[i]);//输入军队
```


**2. 树上倍增预处理**

这个步骤的实现和求LCA基本相同，用到了二进制拆分的思想。关于树上倍增法求LCA，不懂的可以[点击食用](https://www.cnblogs.com/TEoS/p/11376616.html)~~（虽然和这题没有太大关系）~~，接下来也会详细讲解。

在这里用$f_{i,j}$存储$i$节点的第$2^j$个祖先的节点编号，$dist_{i,j}$存储$i$节点到它的第$2^j$个祖先的路径长度。在预处理过程中同时也处理出每个节点的深度，用$d_i$表示。

以上三个数组的值可以通过递推得出，对于$f$数组和$dist$数组，有以下递推式：
```cpp
f[i][j]=f[f[i][j-1]][j-1];
dist[i][j]=dist[i][j-1]+dist[f[i][j-1]][j-1];
```
这个递推式根据数组的定义很容易推出，请读者自行思考。

d数组的递推式就不多说了，待下面给出实现过程时读者自然清楚。

本文这个步骤用bfs实现，当然用dfs实现也可以。

接下来给出具体实现过程：

1. 建立一个空队列，并将根节点入队，同时存储根节点的深度
1. 取出队头，遍历其所有出边。由于存储的时候是按照无向图存储，因此要进行深度判定，对于连接到它父亲节点的边，直接continue即可。记当前路径的另一端节点为$y$，处理出$y$的$d$、$f$、$dist$三个数组的值，然后将$y$入队。
1. 重复第2步，直到队列为空

$f$数组和$dist$数组的递推初值是多少呢？显然，$f_{i,0}$表示的就是$i$节点的父亲节点，因此可以直接得出$f_{i,0}$和$dist_{i,0}$的值，其余为0，接下来进行递推就可以了。

```cpp
int d[N],f[N][20];
ll dist[N][20];

queue<int> q;

t=log2(n)+1;//f数组和dist数组第二维下标的最大值

void bfs()
{
	q.push(1);
	d[1]=1;
	while(q.size())
	{
		int x=q.front();q.pop();
		for(int i=head[x];i;i=Next[i])//遍历x的出边
		{
			int y=ver[i];
			if(d[y])
				continue;//若深度小于当前节点，说明是当前节点的父节点
			d[y]=d[x]+1;//这步不用解释了吧
			f[y][0]=x,dist[y][0]=edge[i];//递推初值
			for(int j=1;j<=t;j++)
			{
				f[y][j]=f[f[y][j-1]][j-1];
				dist[y][j]=dist[y][j-1]+dist[f[y][j-1]][j-1];
			}//递推
			q.push(y);
		}
	}
}
```

**3. 二分答案**

经过预处理后，就开始二分答案了。二分时，若当前的时间限制满足题意，则更新答案。这个步骤比较简单，就不多说了。

```cpp
while(l<=r)
{
	mid=(l+r)>>1;
	if(check(mid))
	{
		r=mid-1;
		ans=mid;
		ok=1;//有解标记
	}
	else
		l=mid+1;
}
```

下面给出check函数的实现

**4. 上移军队并存储闲置军队**

与求LCA类似，利用树上倍增实现上移。用二进制拆分的思想，具体来说，就是依次尝试向上走$2^{logn},...,2^1,2^0$步，并保证终点在根节点之前，且时间不超过当前的时间限制。

将军队上移到根节点的子节点或者能够达到的最浅节点后，若该军队还能向上到达根节点，说明它还有转移到其它子树去驻扎的可能，因此将它记为暂时闲置，用一个二元组存储起来；否则就将该军队驻扎在当前节点，并将当前节点标记为已驻扎。

二元组排序时会以第一维的大小排序，因此在这里第一维存储该军队到达根节点后剩余的时间，第二维存储该军队当前所在的节点编号。

```cpp
int ctot=0;
pair<ll,int> h[N];
bool sta[N];

//lim表示当前的时限，即check函数传入的参数
for(int i=1;i<=m;i++)
{
	ll x=query[i],cnt=0;//cnt统计时间花费
	for(int j=t;j>=0;j--)//从logn到0枚举
		if(f[x][j]>1 && cnt+dist[x][j]<=lim)//若终点在根节点之前且不会超过时限
		{
			cnt+=dist[x][j];
			x=f[x][j];
		}
	if(f[x][0]==1 && cnt+dist[x][0]<=lim)//若当前节点为根节点的子节点且该军队可以在时限内到达根节点
		h[++ctot]=make_pair(lim-cnt-dist[x][0],x);//存储闲置军队
	else
		sta[x]=1;//已驻扎标记
}
```

**5. dfs寻找路径未被驻扎的叶子节点**

这里的思想比较简单，从每个根节点的子节点开始搜索，若搜索时遇到已驻扎节点，则返回1；若一直搜索到某个叶子节点都没有遇到已驻扎节点，则说明根节点的这个子节点需要军队驻扎，返回0。

和上面的bfs预处理一样，当遇到连接父节点的边时，continue即可。

dfs查找结束后，存储需要根节点的需要被驻扎的子节点。

```cpp
bool need[N];

bool dfs(int x)
{
	bool pson=0;//判断是否为叶子节点
	if(sta[x])
		return 1;//若当前节点已被驻扎，则返回1
	for(int i=head[x];i;i=Next[i])//遍历x的出边
	{
		int y=ver[i];
		if(d[y]<d[x])
			continue;//遇到父节点
		pson=1;//若有一条不是连接着父节点的边，说明不是叶子节点
		if(!dfs(y))//若某个子节点搜索时遇到路径未被驻扎的叶子节点，直接返回0
			return 0;
	}
	if(!pson)//当前节点是叶子节点且未被驻扎
		return 0;
	return 1;//没有遇到路径未被驻扎的叶子节点，返回1
}

for(int i=head[1];i;i=Next[i])//遍历根节点的子节点
	if(!dfs(ver[i]))//若需要被驻扎
		need[ver[i]]=1;
```

**6. 对根节点的需要被驻扎的子节点进行初步处理**

在讲解这个步骤之前先说明一个引理：对于第5步中需要被驻扎的节点，若该节点上有军队停留，则对于这些军队中剩余时间最小的军队，若该军队的剩余时间不足够令它从根节点再返回现在停留的节点，则直接驻扎在该节点是最优的。

为什么呢？因为该军队无法从当前的节点到达根节点再返回，说明若它驻扎在根节点的其它子树，只能驻扎在一个到根节点的距离小于当前节点到根节点的距离的节点。而这个节点所有剩余时间比它多的军队一定也可以去驻扎，甚至还可能驻扎到其它更多的节点。因此不如让剩余时间多的节点去驻扎，而自己留在当前节点即可。

身为一个蒟蒻，也没办法给出多么严密的解释，不过总之，上面给出的引理可以证明是成立的。因此对于任意一个需要被驻扎的节点，若它上面停留着一支军队不能到达根节点并返回该节点，则令其驻扎在该节点；另外的，因为一个节点只需要一支军队驻扎，因此我们在这里选择剩余时间最小的节点。所以在处理前要先将$h$数组按照剩余时间从小到大排序。

对于处理过后仍闲置的军队，将它们的剩余时间存储起来备用。因为此时我们已经不关心它当前停留在哪个节点，因此只要存储剩余时间就好。

```cpp
int atot=0;
ll tim[N];

sort(h+1,h+ctot+1);//排序，二元组按照第一维大小排序
for(int i=1;i<=ctot;i++)//遍历所有闲置的军队
	if(need[h[i].second] && h[i].first<dist[h[i].second][0])//若该军队所处的节点需要被驻扎且该军队无法到达根节点并返回
		need[h[i].second]=0;//去除标记
	else
		tim[++atot]=h[i].first;//存储军队的剩余时间
```

**7. 找到仍需要被驻扎的节点并存储**

经过第6步的初步处理，可能还有一些节点需要被驻扎，此时遍历一遍根节点的子节点，找到这些节点并存储起来备用。与第6步相同，这里只要存储节点到根节点的距离就可以了，不必存储节点编号。

```cpp
int btot=0;
ll ned[N];

for(int i=head[1];i;i=Next[i])
	if(need[ver[i]])//如果仍需要被驻扎
		ned[++btot]=dist[ver[i]][0];
```

**8. 利用贪心策略完成最后的匹配**

这里有一个贪心策略：对于现在闲置的军队和需要被驻扎的节点，让剩余时间小的军队优先驻扎在距离根节点近的节点，这样可以保证决策最优。匹配过后，若所有需要被驻扎的节点都已有军队驻扎，则说明当前的时限可行；反之则不可行。

```cpp
if(atot<btot)
	return 0;//如果剩余的军队比需要被驻扎的节点还少，显然不可行，直接返回0
sort(tim+1,tim+atot+1),sort(ned+1,ned+btot+1);//分别对军队的剩余时间和节点到根节点的距离进行升序排序
int i=1,j=1;//指针
while(i<=btot && j<=atot)	//扫描整个tim和ned数组	
	if(tim[j]>=ned[i])//若可行
	{
		i++,j++;//都扫描到下一位
	}
	else
		j++;//否则扫描下一支军队
if(i>btot)//说明所有需要被驻扎的节点都已被驻扎
	return 1;
return 0;
```
至此，check函数就~~愉快地~~结束了。

**9. 特判并输出**

题目中要求对无解的情况进行特判，若二分时没有任何一个时限满足条件，自然就说明无解。否则输出答案即可。~~虽然并没有无解的数据~~

```cpp
if(!ok)
	cout<<-1;
else
	cout<<ans;
```
完结撒花！

整道题目主要还是细节多，在写这类较为复杂的题目时一定要注意细节，防止会写的题爆零。


------------
如果以上讲解没有听懂，可以借助下面这组数据更详细地了解：

```
10 5
2 1 3
2 3 4
1 4 7
5 1 9
6 1 2
4 7 9
7 8 8
9 8 8
1 10 2
2 8 5 4 2 
```
这组数据构造出来就长这个样子：

![](https://cdn.luogu.com.cn/upload/pic/58652.png)

假设我们当前二分到的时间限制为9，模拟上面的步骤进行一遍。

1. 上移军队：只有处于节点8的军队上移到了节点7，其余节点由于都在根节点的子节点上，不动。

![](https://cdn.luogu.com.cn/upload/pic/58653.png)


2. 找出闲置军队与需要被驻扎的节点。显然，闲置军队为目前处于4、2、5节点上的4支军队，需要被驻扎的节点为10、2、5、6节点。
1. 初步处理这些数据。由于5号节点上的军队无法到达根节点再返回，且该节点需要被驻扎，因此该军队驻扎在五号节点；同理，7号节点上的军队驻扎在七号节点。

![](https://cdn.luogu.com.cn/upload/pic/58654.png)

4. 找出目前的闲置军队和需要被驻扎的节点。剩余的闲置军队为目前处于4、2节点上的3支军队，需要被驻扎的节点为2、6、10号节点。

1. 利用贪心策略进行最后的匹配。最后，4号节点上的军队驻扎到6号节点，2号节点上的两支军队分别驻扎到2、10号节点。该方案是可行的。

![](https://cdn.luogu.com.cn/upload/pic/58655.png)

------------

最后给出完整代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<cmath>
#include<algorithm>
#define ll long long
using namespace std;
const int N=6e4;
int n,m,t,tot=0,atot=0,btot=0,ctot=0;
int d[N],query[N],f[N][20];
int ver[2*N],edge[2*N],Next[2*N],head[N];
bool ok,sta[N],need[N];
ll ans,tim[N],ned[N],dist[N][20];
pair<ll,int> h[N];
queue<int> q;
void add(int x,int y,int z)
{
	ver[++tot]=y,edge[tot]=z,Next[tot]=head[x],head[x]=tot;
}//1、输入
void bfs()
{
	q.push(1);
	d[1]=1;
	while(q.size())
	{
		int x=q.front();q.pop();
		for(int i=head[x];i;i=Next[i])
		{
			int y=ver[i];
			if(d[y])
				continue;
			d[y]=d[x]+1;
			f[y][0]=x,dist[y][0]=edge[i];
			for(int j=1;j<=t;j++)
			{
				f[y][j]=f[f[y][j-1]][j-1];
				dist[y][j]=dist[y][j-1]+dist[f[y][j-1]][j-1];
			}
			q.push(y);
		}
	}
}//2、树上倍增预处理
bool dfs(int x)
{
	bool pson=0;
	if(sta[x])
		return 1;
	for(int i=head[x];i;i=Next[i])
	{
		int y=ver[i];
		if(d[y]<d[x])
			continue;
		pson=1;
		if(!dfs(y))
			return 0;
	}
	if(!pson)
		return 0;
	return 1;
}//5、dfs寻找路径未被驻扎的叶子节点
bool check(ll lim)
{
	memset(sta,0,sizeof(sta));
	memset(tim,0,sizeof(tim));
	memset(ned,0,sizeof(ned));
	memset(h,0,sizeof(h));
	memset(need,0,sizeof(need));
	atot=0,btot=0,ctot=0;//初始化
	for(int i=1;i<=m;i++)
	{
		ll x=query[i],cnt=0;
		for(int j=t;j>=0;j--)
			if(f[x][j]>1 && cnt+dist[x][j]<=lim)
			{
				cnt+=dist[x][j];
				x=f[x][j];
			}
		if(f[x][0]==1 && cnt+dist[x][0]<=lim)
			h[++ctot]=make_pair(lim-cnt-dist[x][0],x);
		else
			sta[x]=1;
	}//4、上移军队并处理闲置军队
	for(int i=head[1];i;i=Next[i])
		if(!dfs(ver[i]))
			need[ver[i]]=1;//5、dfs寻找路径未被驻扎的叶子节点
	sort(h+1,h+ctot+1);
	for(int i=1;i<=ctot;i++)
		if(need[h[i].second] && h[i].first<dist[h[i].second][0])
			need[h[i].second]=0;
		else
			tim[++atot]=h[i].first;//6、对根节点的需要被驻扎的子节点进行初步处理
	for(int i=head[1];i;i=Next[i])
		if(need[ver[i]])
			ned[++btot]=dist[ver[i]][0];//7、找到仍需要被驻扎的节点并存储
	if(atot<btot)
		return 0;
	sort(tim+1,tim+atot+1),sort(ned+1,ned+btot+1);
	int i=1,j=1;
	while(i<=btot && j<=atot)
		if(tim[j]>=ned[i])
		{
			i++,j++;
		}
		else
			j++;
	if(i>btot)
		return 1;
	return 0;//8、利用贪心策略完成最后的匹配
}
int main()
{
	ll l=0,r=0,mid;
	cin>>n;
	t=log2(n)+1;
	for(int i=1;i<n;i++)
	{
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z),add(y,x,z);
		r+=z;
	}//1、输入
	bfs();//2、树上倍增预处理
	cin>>m;
	for(int i=1;i<=m;i++)
		scanf("%d",&query[i]);
	while(l<=r)
	{
		mid=(l+r)>>1;
		if(check(mid))
		{
			r=mid-1;
			ans=mid;
			ok=1;
		}
		else
			l=mid+1;//1、输入
	}//3、二分答案
	if(!ok)
		cout<<-1;
	else
		cout<<ans;//9、特判并输出
	return 0;
}
```
该解释的都解释得很清楚了，完整代码里就不再具体解释了。

------------
希望能对大家有所帮助，有不足之处请指出

---

## 作者：litble (赞：179)

# 题目分析

[安利个人博客](http://blog.csdn.net/litble/article/details/78219618)

我们要明确我们做什么，一步一步慢慢来，否则会被这题逼疯。

## 1.预处理倍增

我们会发现，离根节点越近的节点，控制的节点更多。所以由贪心的思想，所有的军队都要尽可能地往根节点走。


> ”往上提“类型问题一般使用倍增优化。——xzy神犇

[xzy的博客](http://www.k-xzy.xyz)

好大的，那么我们可以dfs一遍，将倍增要用的一些值都处理好（见代码）


## 2.二分答案

军队可以同时移动，说明我们要控制传染病的时间是军队移动到位时，移动时间最长的军队的移动时间。而我们要求最小值，即要求最大化最小值。


> 二分答案一般用于求最大化最小值，最小化最大值。——jyf神犇

[jyf的博客](http://www.cnblogs.com/1-1-1-1/)

所以就是二分啦，二分一个答案，事情就会更有方向。

## 3.”上提“军队

使用倍增的方法将军队在二分出的答案限制内尽力往上”提“，不过不可以到根节点。

## 4.处理剩余路程

如果当前军队可以到达根节点，那么记录一下它的编号和它到达根节点后还可以走的时间rest。如果这个军队i在根节点的子树x中，那么记录一下子树x的符合这个条件的点中，到根节点后剩余路程最短的点。

如果不可以到达，记录它被”提“到的节点被军队设置了检查点。

## 5.dfs找未被”封死“的子树

如果一个节点建立了检查点或者它的所有子树都设立了检查点，则说明以这个节点为根的子树已经被“封死”。记录根节点的所有子树中，未被“封死”的子树。

## 6.军队在子树间转移

将我们已经记录好了的**可以到根节点的军队**按照**剩余路程从大到小**排序。

将**未被“封死”的子树**按照**到子树到根节点的距离从大到小**排序。

然后依次处理**未被“封死”的子树**要由哪支军队来管辖。

当然离根节点远的军队由剩余路程大的军队来管辖是吼滴啦，不过缀吼滴还是就由本来就在这棵子树上的军队来管辖。所以我们先查看我们事先记录的(**在子树x中，可以到达根节点，且到根节点后剩余路程最小的军队**)是否被使用，如果被使用，再看当前没有被使用的军队里剩余路程最大的可否到达这棵子树。

这样我们就可以判断当前二分出的答案是否可行了。

# 代码

由于我打完这题已经心力憔悴，所以没时间详解代码了.....以上6步已在代码里定位

我上次写的题解忘记无解要输出-1了QAQ

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
#define LL long long
int read(){
    int q=0;char ch=' ';
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9')q=q*10+ch-'0',ch=getchar();
    return q;
}
const int N=50005;
int n,m,tot,na,nb;
int h[N],ne[N<<1],to[N<<1];LL w[N<<1];
int f[N][18],army[N];LL dis[N][18];
void add(int x,int y,int z)
{to[++tot]=y,ne[tot]=h[x],h[x]=tot,w[tot]=z;}
void dfs(int x,int las,LL havego){//1.预处理倍增
    f[x][0]=las,dis[x][0]=havego;
    for(int i=1;i<=17;++i){
        f[x][i]=f[f[x][i-1]][i-1];
        dis[x][i]=dis[x][i-1]+dis[f[x][i-1]][i-1];
    }
    for(int i=h[x];i!=-1;i=ne[i])
        if(to[i]!=las)dfs(to[i],x,w[i]);
}
struct node{LL rest;int id;}a[N],b[N];
int vis[N],used[N],restbj[N];LL restmin[N];
int checkok(int x,int las){//5.dfs找未被“封死”的子树
    int bj=1,i,bbj=0;
    if(vis[x])return 1;
    for(i=h[x];i!=-1;i=ne[i]){
        if(to[i]==las)continue;bbj=1;
        if(!checkok(to[i],x)){
            bj=0;
            if(x==1) b[++nb].id=to[i],b[nb].rest=w[i];
            else return 0;
        }
    }
    if(!bbj)return 0;
    return bj;
}
bool cmp(node x,node y){return x.rest>y.rest;}
int check(LL lim){
    int i,j,x,now;LL num;na=nb=0;
    for(i=1;i<=n;++i)vis[i]=restbj[i]=0;
    for(i=1;i<=m;++i)used[i]=0;
    for(i=1;i<=m;++i){
        x=army[i],num=0;
        for(j=17;j>=0;--j)//3.上提军队
            if(f[x][j]>1&&num+dis[x][j]<=lim)
            num+=dis[x][j],x=f[x][j];
        if(f[x][0]==1&&num+dis[x][0]<=lim){//4.处理剩余路程
            a[++na].rest=lim-num-dis[x][0],a[na].id=i;
            if(!restbj[x]||a[na].rest<restmin[x])
                restmin[x]=a[na].rest,restbj[x]=i;
        }
        else vis[x]=1;
    }
    if(checkok(1,0))return 1;
    sort(a+1,a+1+na,cmp),sort(b+1,b+1+nb,cmp);//6.军队在子树间转移
    now=1;used[0]=1;
    for(i=1;i<=nb;++i){
        if(!used[restbj[b[i].id]]){used[restbj[b[i].id]]=1;continue;}
        while(now<=na&&(used[a[now].id]||a[now].rest<b[i].rest))++now;
        if(now>na)return 0;used[a[now].id]=1;
    }
    return 1;
}
int main()
{
    int i,x,y,z;LL l=0,r=500000,mid,ans=-1;
    n=read();
    for(i=1;i<=n;++i)h[i]=-1;
    for(i=1;i<n;++i){
        x=read(),y=read(),z=read();
        add(x,y,z),add(y,x,z);
    }
    dfs(1,0,0);m=read();
    for(i=1;i<=m;++i)army[i]=read();
    while(l<=r){//2.二分答案
        mid=(l+r)>>1;
        if(check(mid))r=mid-1,ans=mid;
        else l=mid+1;
    }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：beretty (赞：43)

emm,~~这题真恶心~~

从早上开始写，，想出思路（经Refun神的指点）后慢慢写，写了1个多小时才写完，然后一直调到下午才A，~~心力交瘁~~

倍增+贪心

其实思路并不是很难，但是实现起来的细节。。。


## 大致思路 ： 
 
  题目要求我们要用m个点“封死”这棵树
  
  那么显然 ** 一个军队越往上跳控制的点就会越多**
  
  然后题目问要“封死”这棵树的话，移动距离最大的点移动的最小距离是多少 ————显然是**二分时间**
  
## 具体做法 ：    
  
  我们就让每个军队在二分的时间内尽量向上跳，看能不能在给定的时间内跳到节点1
  
  如果能，就先让这个军队跳上去，记录下这个军队到节点1时的剩余时间Rest和它在向上跳的路径中1的儿子Top，便于后来的处理。
  
  如果不能，就让这个军队尽量往上跳，并在终点打上控制标记（毕竟越往上跳控制的节点肯定不会比在原来的点少）
  
  处理完所有的军队后，我们再将所有能蹦到节点1的军队按照Rest进行从小到大的排序
  
  然后如果这个点的Rest已经不能再从1蹦回Top了并且Top还没有被控制，那就让这个点别在节点1呆着了，直接回到Top顺便把Top节点控制了就行啦，因为如果它不回去，肯定还要有别的地方的军队来控制Top，那样显然距离更远。
  
  最后再把所有没有被控制的节点1的儿子（**注意： 如果这个点的所有子树的叶子节点被控制了，那这个点也算是被控制了**）加入队列，然后再按从大到小排个序。
  
  最后把现在仍在节点1的军队按照Rest从大到小排个序，然后和没被控制的节点一一比对就好辣
  
  
  具体做法说完了，然后我们观察数据范围，n,m<=50000,暴力向上跳肯定是会T的
  
  **所以我们使用倍增进行优化**
  
  _f[i][j]表示从i这个点跳 2^j 步能跳到的节点_
  
  _st[i][j]表示从i这个点跳 2^j 步的距离_
  
  然后军队向上提的时候就和倍增求LCA类似，这样一来就可以A掉此题
  
  ~~然而，这题细节很多啊啊~~
  
  各位dalao如有不懂之处也可以看一看代码，上丑陋的代码↓

  ****

```
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<iostream>
const int M = 50005 ;
const int N = 20 ;
using namespace std;
inline int read(){
    int x=0,w=1; char c=getchar(); 
    while(c>'9'||c<'0'){ if(c=='-') w=-1 ;c=getchar() ;}
    while(c>='0'&&c<='9'){ x=x*10+c-'0'; c=getchar() ; }
    return x*w;
}
int hea[M],num;
int n,m;
int p[M];
int st[M][N],f[M][N],Ans;
int top[M],tdis[M];
int rnum=0;
int q[M],tail=0;
bool lea[M];
bool vis[M];
bool fs=0;
struct E{
    int nex,to;
    int dis;
}edge[M<<2];
struct Army{
    int Rest;
    int Top;
}army[M];
inline bool cmp(int a,int b){ return a>b; }
inline bool cmpmin(Army a,Army b){ return a.Rest<b.Rest; }
inline bool cmpmax(Army a,Army b){ return a.Rest>b.Rest; }
inline void add_edge(int from,int to,int dis){
    edge[++num].nex=hea[from];
    edge[num].to=to;
    edge[num].dis=dis;
    hea[from]=num;
}
void Dfs(int u,int father){
    for(int i=hea[u];i;i=edge[i].nex){
        int v=edge[i].to;
        if(v==father) continue ;
        f[v][0]=u; 
        st[v][0]=edge[i].dis;
        Dfs(v,u);
    }
}
void RMQ(){
    for(int j=1;j<=18;j++)
      for(int i=1;i<=n;i++){
      	f[i][j]=f[f[i][j-1]][j-1];
      	st[i][j]=st[i][j-1]+st[f[i][j-1]][j-1];
      }
}
void Dfs1(int u,int father,int topf,int dist){
    top[u]=topf;
    tdis[u]=dist;
    bool ft=0;
    for(int i=hea[u];i;i=edge[i].nex){
        int v=edge[i].to;
        if(v==father) continue ;
        ft=1;
        Dfs1(v,u,topf,dist);
    }
    if(!ft)  lea[u]=1;
}
void Dfs2(int u,int father){
    if(lea[u]){
        fs=1;
        return ;
    }
    for(int i=hea[u];i;i=edge[i].nex){
        int v=edge[i].to;
        if(v==father) continue ;
        else if(vis[v]) continue ;
        Dfs2(v,u);
        if(fs) return ;
    }
}
inline bool Look(int v){
    fs=0;
    Dfs2(v,f[v][0]);
    return fs;
}
inline bool judge(int mid){
    memset(vis,0,sizeof(vis));
    memset(q,0,sizeof(q));
    memset(army,0,sizeof(army));
    rnum=0;
    tail=0;
    for(int i=1;i<=m;i++){
        int tim=mid;
        int now=p[i];
        bool syst=0;
        while(1){
            for(int j=18;j>=0;j--){
              if(f[now][j]&&st[now][j]<=tim){
              	tim-=st[now][j];
              	now=f[now][j];
                break;
              }
              if(j==0||now==1){
                syst=1;
                break;
			  }
            }
            if(syst) break;
        }
        if(now==1){
            army[++rnum].Top=top[p[i]];
            army[rnum].Rest=tim;
        }
        else vis[now]=1;
    }	
    sort(army+1,army+m+1,cmpmin);
    for(int i=1;i<=m;i++) 
      if(army[i].Rest<tdis[army[i].Top]){
        if(!vis[army[i].Top]&&Look(army[i].Top)){
        	vis[army[i].Top]=1;
        	army[i].Rest=-1;
        }
      }
    sort(army+1,army+m+1,cmpmax);
    for(int i=hea[1];i;i=edge[i].nex){
        int v=edge[i].to;
        if(!vis[v]&&Look(v))
          q[++tail]=edge[i].dis;
    }
    sort(q+1,q+tail+1,cmp);
    for(int i=1;i<=tail;i++)
      if(army[i].Rest<q[i])
        return false;
    return true; 
}
int main(){
    n=read();
    int R=0;
    for(int i=1;i<n;i++){
        int u = read(),v = read();
        int w = read();
        add_edge(u,v,w);
        add_edge(v,u,w);
        R+=w;
    }
    Dfs(1,0);
    for(int i=hea[1];i;i=edge[i].nex){
        int v=edge[i].to;
        Dfs1(v,1,v,edge[i].dis);
    }
    RMQ();
    m=read();
    for(int i=1;i<=m;i++) p[i]=read();
    int tmp=0;
    for(int i=hea[1];i;i=edge[i].nex) tmp++;
    if(tmp>m){
    	printf("-1\n");
    	return 0;
    }
    int L=0;
    while(L<=R){
        int mid=(L+R)>>1;
        if(judge(mid)) Ans=mid,R=mid-1;
        else L=mid+1;
    }
    printf("%d\n",Ans);
    return 0;
```

---

## 作者：FlashHu (赞：35)

费了几个小时杠掉此题，如果不是那水水的数据的话，跟天天爱跑步的难度真的是有得一比。。。

话说蒟蒻仔细翻了所有的题解，发现巨佬写的都是倍增，复杂度是$O(n\log n\log nw)$的，貌似还不够优秀。

其实我们与其对于每一个点都通过倍增向上找到对应位置，还不如直接从上到下dfs一遍，判断：如果当前点子树内初始位置最浅的军队与当前点距离不超过$mid$，或者所有子树都被封锁，那么当前点也被封锁。

这样以后再二分，时间复杂度降至$O(n\log nw)$。其它部分的思路Dalao们的题解里都讲清楚了，蒟蒻也不多说了qwq

```cpp
#include<bits/stdc++.h>
#define LL long long
#define RG register
#define R RG int
using namespace std;
const int N=5e4+9,M=1e5+9;
int p,he[N],ne[M],to[M],w[M],top[N],at[N],t[N],mn[N];
LL mid,d[N],dis[N];
bool cov[N],use[N];
inline bool cmp(R x,R y){
    return d[x]>d[y];
}
void dp(R x,R f){
    top[x]=p;
    if(mid<d[x])mid=d[x];//控制二分上界
    if(to[he[x]]==f)he[x]=ne[he[x]];//悄悄把反边删掉
    for(R i=he[x];i;i=ne[i]){
        if(to[ne[i]]==f)ne[i]=ne[ne[i]];
        d[to[i]]=d[x]+w[i];
        dp(to[i],x);
    }
}
void dfs(R x){
    if(cov[x]){dis[x]=0;return;}
    dis[x]=1ll<<60;
    if(!(cov[x]=he[x]))return;//到达叶子节点还没有被封锁
    for(R y,i=he[x];i;i=ne[i]){
        dfs(y=to[i]);
        cov[x]&=cov[y];
        dis[x]=min(dis[x],dis[y]+w[i]);
    }
    if(dis[x]<=mid)cov[x]=1;//子树内军队能够赶到
}
int main(){
    R n,m,cnt=0,i,u,v;
    cin>>n;
    for(i=1;i<n;++i){
        cin>>u>>v>>w[++p];w[p+1]=w[p];
        ne[p]=he[u];to[he[u]=p]=v;++p;
        ne[p]=he[v];to[he[v]=p]=u;
    }
    for(i=he[1];i;i=ne[i])
        d[p=to[i]]=w[i],dp(t[++cnt]=to[i],1);
    cin>>m;
    if(cnt>m)return cout<<"-1"<<endl,0;//无解
    for(i=1;i<=m;++i)cin>>at[i];
    sort(t+1,t+cnt+1,cmp);//排序，方便接下来贪心
    sort(at+1,at+m+1,cmp);
    RG LL l=0,r=mid+d[t[1]];
    while(l<r){
        mid=(l+r)>>1;
        memset(cov,0,n+1);
        memset(use,0,n+1);
        for(i=1;i<=cnt;++i)mn[t[i]]=0;//清空
        for(i=1;d[at[i]]>mid;++i)
            cov[at[i]]=1;//到不了根节点，直接留在子树内
        for(p=i;i<=m;++i)
            if(!mn[top[at[i]]])mn[top[at[i]]]=i;
            //每个子树预留一个贡献最小的军队
        use[0]=1;u=m+1;
        for(i=1;i<=cnt;++i){
            dfs(t[i]);
            if(cov[t[i]])continue;
            if(use[mn[t[i]]]){//预留已用，只好拿其它子树的
                for(--u;u>=p&&(d[at[u]]+d[t[i]]>mid||use[u]);--u);
                if(u<p)break;
                use[u]=1;
            }
            else use[mn[t[i]]]=1;//预留直接用
        }
        u>=p?r=mid:l=mid+1;
    }
    cout<<l<<endl;
    return 0;
}
```

---

## 作者：Siyuan (赞：19)

[$$\Large\texttt{My Blog}$$](https://hydingsy.github.io)

---

> 题目链接：[Luogu 1084](https://www.luogu.org/problemnew/show/P1084)

H 国有 $n$ 个城市由 $n−1$ 条双向道路连通成一棵树，$1$ 号城市是首都，也就是根节点。H 国的首都爆发了传染病。为了控制疫情，不让疫情扩散到边境城市（叶子节点所表示的城市），当局决定让军队在一些城市建立检查点，使得从首都到边境城市的每一条路径上都至少有一个检查点。除了首都，任何一个城市都可以建立检查点。

现在，在 H 国的一些城市中已经驻扎有军队，且一个城市可以驻扎多个军队。一支军队可以在有道路连接的城市间移动，并在最多一个城市建立检查点。军队移动需要的时间等于经过的道路的长度 $w$。请问最少需要多少个小时才能控制疫情。注意：不同的军队可以同时移动。

数据范围：$2\leqslant m\leqslant n\leqslant 5\times 10^4$，$0<w<10^9$

------

## Solution

### 预处理

我们可以发现，节点的深度越小，控制的节点（子树内的节点）越多，所以我们可以贪心地把军队尽量向上提。据此，我们需要把每个点往上的距离预处理，用倍增优化。

### 二分答案

题目要求的是：军队最大的移动时间的最小值，所以我们可以非常自然地想到二分答案，把问题转化为判定性问题（即是否可以在确定的时间内完成）。

### 判断合法

根据前面的分析，我们在 $\texttt{check}$ 的时候要尽量把军队往上走。当二分答案后，设答案为 $x$，这里会有两种情况：军队在 $x$ 的时间内可以到达根节点，军队在 $x$ 的时间内无法到达根节点。

1. 首先解决军队的上提问题
   - 如果一个军队无法到达根节点，那么他最高的位置一定是最优的，让他待在那里就可以了！
   - 如果一个军队可以得到根节点，那我们求出他到达后还可以走多少时间 $rest$ 以及到达 $1$ 前的儿子 $id$，以便接下来的处理。
2. 如果还有叶子没有被控制，那我们肯定是把军队调到 $1$ 的某个儿子，因此我们需要处理出 $1$ 的儿子有多少个需要被控制，记录它们和根节点的距离 $dist$。
3. 最后处理可以到达 $1$ 的军队的去向。
   - 先将这些军队按照 $rest$ 从小到大排序。如果某一个军队的 $id$ 需要被控制，那么就让他不要到达 $1$ 而直接待在 $id$ 就行了。因为如果他不回去，肯定需要别的军队过来控制这个 $id$，这样显然花费时间更大。
   - 再将这些军队按照 $rest$ 从大到小排序，把需要被控制的点按照 $dist$ 从大到小排序。把这两个序列从前往后一一对比就行了！
4. 是否合法的判断：如果步骤 $3$ 中军队用完了可还有节点需要被控制，那么不合法；否则合法。

**时间复杂度**：$O(n\log^2 n)$

------

## Code

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>

const int N=5e4+5,M=1e5+5;
int n,m,tot,a[N],lnk[N],ter[M],nxt[M],val[M],f[N][16];
long long g[N][16];
bool tag[N];
struct data {
    long long val;
    int id;
    bool operator < (const data &rhs) const {
        return val<rhs.val;
    }
} army[N],rest[N];

void add(int u,int v,int w) {
    ter[++tot]=v,nxt[tot]=lnk[u],val[tot]=w,lnk[u]=tot;
}
void dfs(int u,int fa) {
    for(int i=lnk[u];i;i=nxt[i]) {
        int v=ter[i];
        if(v^fa) f[v][0]=u,g[v][0]=val[i],dfs(v,u);
    }
}
void putTag(int u,int fa) {
    bool res=1,flg=0;
    for(int i=lnk[u];i;i=nxt[i]) {
        int v=ter[i];
        if(v^fa) putTag(v,u),res&=tag[v],flg=1;
    }
    if(u!=1&&res&&flg) tag[u]=1;
}
void RMQ() {
    for(int j=1;j<=15;++j) for(int i=1;i<=n;++i) {
        f[i][j]=f[f[i][j-1]][j-1];
        g[i][j]=g[i][j-1]+g[f[i][j-1]][j-1];
    }
}
bool check(long long lim) {
    memset(tag,0,sizeof(tag));
    int cntArmy=0,cntRest=0;
    for(int i=1;i<=m;++i) {
        int x=a[i];
        long long sum=0;
        for(int j=15;~j;--j) if(f[x][j]>1&&sum+g[x][j]<=lim) sum+=g[x][j],x=f[x][j];
        if(f[x][0]==1&&sum+g[x][0]<=lim) army[++cntArmy]=data{lim-sum-g[x][0],x};
        else tag[x]=1;
    }
    putTag(1,0);
    for(int i=lnk[1];i;i=nxt[i]) {
        int v=ter[i];
        if(!tag[v]) rest[++cntRest]=data{val[i],v};
    }
    std::sort(army+1,army+cntArmy+1);
    std::sort(rest+1,rest+cntRest+1);
    int j=1;
    for(int i=1;i<=cntArmy;++i) {
        if(!tag[army[i].id]) tag[army[i].id]=1;
        else if(army[i].val>=rest[j].val) tag[rest[j].id]=1;
        while(tag[rest[j].id]&&j<=cntRest) ++j;
    }
    return j>cntRest;
}
int main() {
    scanf("%d",&n);
    long long sum=0;
    for(int u,v,w,i=1;i<n;++i) {
        scanf("%d%d%d",&u,&v,&w);
        add(u,v,w),add(v,u,w),sum+=w;
    }
    dfs(1,0),RMQ();
    scanf("%d",&m);
    for(int i=1;i<=m;++i) scanf("%d",&a[i]);
    long long l=0,r=sum,ans=-1;
    while(l<=r) {
        long long mid=(l+r)>>1;
        check(mid)?(ans=mid,r=mid-1):l=mid+1;
    }
    printf("%lld\n",ans);
    return 0;
}
```



---

## 作者：妩媚的ak萝莉 (赞：11)


### 时间复杂度：$O(nlogn)$

为什么大家都用倍增双log了呢？（虽然我一开始也因为$n<=50000$以为只能双log）

发现有的时候我们的思维被数据结构禁锢了，再一看数据范围，一想树上倍增能做就马上去了，其实直接贪心就行

~~还有我对着一棵50的树硬手调一个小时，最后发现一句话写错位置是什么鬼呀~~

贪心基于三个性质：

1. 所有军队如果没有到根节点，能往上走多少就走多少

2. 军队如果必须跨过根节点，那么只会再往下一个节点

这两个性质显而易见，省去一个log的是最后一条性质

3. 如果军队到不了根节点，我其实并不关心它有几支，只关心它最多能走多高



------------


思路已经写得很清楚了，代码还有详尽的注释来解释贪心的正确性：

1. 把所有军队按离1号节点远近排序，标记军队所属分支，把1号节点周围所有儿子按边的大小排序 $O(nlogn)$

2. $0-2^{55}$二分

3. 从近到远枚举军队，如果到不了记此限度为lim，同时更新当前哪些根的分支拥有哪只最差军队 $O(n)$复杂度

4. 遍历树，每个节点考虑每个节点的儿子，挑出对于当前可继续的大于lim的最优值传回，计算哪些根的分支不用考虑 $O(n)$复杂度

6. 1号点的边从大到小枚举，如果不用考虑直接跳过，否则如有标记军队直接应用并删除，如没有用维护的指针看当前军队是否可行 $O(n)$复杂度

共O(55n)

## 代码：

```cpp
#include <iostream>
#include <stdio.h>
#include <algorithm>
#include <vector>
using namespace std;
const int N=1e5+50;
typedef long long ll;
typedef pair<int,int> pii;
const ll INF=(1ll<<56);
struct Node{
	int t,w;
	Node(){}
	Node(int a,int b){t=a,w=b;}
};
int n,m;
vector<Node> gg[N];
vector<int> zhuar[N];
int ar[N],bl[N],arbl[N],hav[N];
ll dis[N];
bool ne[N],vis[N];

bool cmpforbi(Node x,Node y){ return x.w<y.w;}
bool cmpforar(int x,int y){ return dis[x]<dis[y];}

void Init(){
	for(int i=1;i<=n;i++) hav[i]=0;
	for(int i=1;i<=m;i++) vis[i]=0;
}

ll dfs_check(int now,int pre,int lim,ll x) //INF代表虽然子树里的军队走不上来了，但到边境每一条路都封了，-1代表到边境的路封不全，其他的返回值代表从子树升上来的最小代价
{
	ll ret=INF;
	int sddz=zhuar[now].size();
	for(int i=0;i<sddz && now!=1;i++)
		if(zhuar[now][i]>lim)
			return 0;
	int sz=gg[now].size();
	if(sz==1 && now!=1) return -1;
	bool ok=0,ok2=1;
	for(int i=0;i<sz;i++){
		int nex=gg[now][i].t;
		if(nex==pre) continue;
		ll len=gg[now][i].w,jie=dfs_check(nex,now,lim,x);
		if(jie>=0 && jie+len<=x) ok=1;
		if(jie<0) ok2=0; 
		if(jie>=0)
			ret=min(jie+len,ret);
		if(now==1){
			if(jie>=0) ne[nex]=1;
			else ne[nex]=0;
		}
	}
	if(ok || ok2) return ret;
	return -1;
}

bool check(ll x){
	Init();
	int lim=0;
	for(int i=1;i<=m;i++){
		if(dis[ar[i]]>x) break;
		hav[arbl[i]]=i;
		lim=i;
	}
	dfs_check(1,-1,lim,x); //即处理到不了根的军队最多能封根的哪些分支的路
	int sz=gg[1].size(),k=1;
	for(int i=sz-1;i>=0;i--)
	{
		while(k<=lim && vis[k]) k++;
		int nex=gg[1][i].t;
		ll len=gg[1][i].w;
		if(ne[nex]) continue;
		if(hav[nex]>=k){
			vis[hav[nex]]=1;
			continue;
		}
		if(k>lim || dis[ar[k]]+len>x) return 0; //最优的军队都封不了，后面就没有封得了的军队，这条分支处理不了其他的也不用考虑了
		vis[k]=1;
	}
	return 1;
}

void dfs(int now,int pre,int bll){
	int sz=gg[now].size();
	for(int i=0;i<sz;i++){
		int nex=gg[now][i].t;
		ll len=gg[now][i].w;
		if(nex==pre) continue;
		dis[nex]=dis[now]+len;
		if(now==1) bll=nex;
		bl[nex]=bll;
		dfs(nex,now,bll);
	}
}

int main()
{
	scanf("%d",&n);
	for(int i=1;i<n;i++){
		int ui,vi,wi;
		scanf("%d%d%d",&ui,&vi,&wi);
		gg[ui].push_back((Node){vi,wi});
		gg[vi].push_back((Node){ui,wi});
	}
	sort(gg[1].begin(),gg[1].end(),cmpforbi); //方便贪心
	dfs(1,-1,-1);
	scanf("%d",&m);
	for(int i=1;i<=m;i++)
		scanf("%d",&ar[i]);
	sort(ar+1,ar+1+m,cmpforar);
	for(int i=1;i<=m;i++){
		arbl[i]=bl[ar[i]]; //每支军队属于根的哪个分支
		zhuar[ar[i]].push_back(i); //每个节点驻有哪些军队
	}
	ll l=0,r=(1ll<<55);
	while(l<r){
		ll mid=((l+r)>>1);
		if(check(mid)) r=mid;
		else l=mid+1;
	}
	if(l>r || !check(l)) printf("-1\n");
	else printf("%lld\n",l);
	return 0;
}
```

---

## 作者：Morning_Glory (赞：8)

[也许更好的阅读体验 博客园](https://www.cnblogs.com/Morning-Glory/p/11729119.html)	

[也许更好的阅读体验 CSDN](https://blog.csdn.net/Morning_Glory_JR)
	
# $\mathcal{Description}$	
[原题链接](https://www.luogu.org/problem/P1084)	
	
**一句话题意**	
一个人可以堵住一个子树，不能一次堵住整棵树，求堵住每个通往叶子节点的路径，走的最远的那个人走的路程最少是多少，若不能堵住输出$-1$	

# $\mathcal{Solution}$	


看了下其他题解,都说很毒瘤	
最开始我也认为很毒瘤	
就是在决定一个点是否要跨过根这个地方比较麻烦	
但是在码的途中,突然想到一个无脑的方法	
于是写起来就很愉快了	
	
最...最..，显然二分路程是多少	
	
再继续想之前，先看一下我们$check$函数要求在什么复杂度决定	
$n\leq 50000$，可以$nlog^2n$解决，也就是说$check$的复杂度只要小于$nlogn$即可	
	
一个人在二分到的路程内，尽量往上走是最优的	
若一个人可以到达根节点，那么就要考虑其跨过这个根节点去堵其它子树	
显然，若跨过根节点，那么走到根节点下面的那个节点就可以了	
	
对于一个可以跨过根节点的人，他可能不要跨过根节点，也可能要跨过根节点	
也可能一个子树里的人跨过根节点去堵其他子树，另外的一个子树的人跨过根节点来堵他的子树，这是因为原来这个子树的人比较靠近根节点，跨过根节点后走的较远，而他所在子树与根节点的路径又比较短	
想想好像有点麻烦，想到这顿时觉得这题很毒瘤	
	
但其实，我们不用想那么多	
我们把所有能跨过根节点的人都走到根节点	
将其还允许走的路程全部记下来	
把所有需要人去堵的子树找出来，记下其与根节点的距离	
显然，能走得最远的人去堵距离根节点最远的子树是最优的	
	
也就是说要从大到小排序，这个过程我们用一个大根堆维护即可	
对于一个到子树的距离，我们记下其子树的编号，对于每棵子树，我们记下其内可以跨过根节点的人中，还允许走的路程最少的路程是多少	
	
再考虑一个人可能不要跨过根节点，我们在弹大根堆时，若发现这棵子树可以用比当前允许走的路程最大的人更小的人替代，那么那个人就不需要跨过根节点了	
由于那个人仍然在大根堆内，我们把其记在一个队列里，表示有哪些路程被提前用了	
这样就是最优的	
仍有不懂请看代码，我觉得还是很无脑的，毕竟什么特殊的操作都没有，代码应该一下就看懂了	
	
	
	
# $\mathcal{Code}$	
	
```cpp	
/*******************************	
Author:Morning_Glory	
LANG:C++	
Created Time:2019年10月22日 星期二 20时50分59秒	
*******************************/	
#include <cstdio>
#include <fstream>
#include <queue>
#define ll long long
#define inf 12345678987654
#define mp make_pair
using namespace std;
const int maxn = 500005;
const int maxm = 1000006;
const int lim = 20;
//{{{cin
struct IO{
	template<typename T>
	IO & operator>>(T&res){
		res=0;
		bool flag=false;
		char ch;
		while((ch=getchar())>'9'||ch<'0')	flag|=ch=='-';
		while(ch>='0'&&ch<='9')	res=(res<<1)+(res<<3)+(ch^'0'),ch=getchar();
		if (flag)	res=~res+1;
		return *this;
	}
}cin;
//}}}
int n,m,cnt,u,v,val,num;
int head[maxn],nxt[maxm],to[maxm],w[maxm],hav[maxn],dep[maxn],lg[maxn]={-1};
int fa[maxn][lim];
ll l,r,mid;
ll d[maxn],f[maxn];
bool vis[maxn];
priority_queue <int> qc,qf;
priority_queue < pair<int,int> >qn;
//{{{add
void add (int u,int v,int val)
{
	nxt[++cnt]=head[u],head[u]=cnt,to[cnt]=v,w[cnt]=val;
}
//}}}
//{{{dis
ll dis (int x,int y)
{
	return d[x]>d[y]?d[x]-d[y]:d[y]-d[x];
}
//}}}
//{{{dfs
void dfs (int x)
{
	r=max(r,d[x]);
	for (int i=1;i<=lg[dep[x]];++i)	fa[x][i]=fa[fa[x][i-1]][i-1];

	for (int e=head[x];e;e=nxt[e])
		if (to[e]!=fa[x][0]){
			fa[to[e]][0]=x,dep[to[e]]=dep[x]+1;
			d[to[e]]=d[x]+w[e];
			dfs(to[e]);
		}
}
//}}}
//{{{move
void move (int x,int nm)
{
	ll t=mid;
	for (int i=lg[dep[x]];~i;--i){
		ll ds=dis(fa[x][i],x);
		if (fa[x][i]>1&&t>=ds)	t-=ds,x=fa[x][i];
	}
	if (t>dis(1,x)){
		ll ds=t-dis(1,x);
		f[x]=min(f[x],ds);
		while (nm--)	qc.push(ds);
	}
	else	vis[x]=true;
}
//}}}
//{{{chk
bool chk (int x)
{
	if (vis[x])	return	false;
	bool flag=true;
	for (int e=head[x];e;e=nxt[e])
		if (to[e]!=fa[x][0]){
			flag=false;
			if (chk(to[e]))	return true;
		}
	return flag;
}
//}}}
//{{{check
bool check ()
{
	while (!qc.empty())	qc.pop();
	while (!qn.empty())	qn.pop();
	while (!qf.empty())	qf.pop();
	for (int i=1;i<=n;++i)	vis[i]=0,f[i]=inf;
	for (int i=1;i<=n;++i)
		if (hav[i])	move(i,hav[i]);

	for (int e=head[1];e;e=nxt[e])
		if (chk(to[e]))	qn.push(mp(w[e],to[e]));

	while (!qn.empty()){
		val=qn.top().first,v=qn.top().second,qn.pop();
		while (!qf.empty()&&qf.top()==qc.top())	qf.pop(),qc.pop();

		if (qc.empty())	return false;
		if (qc.top()<val){
			if (f[v]>qc.top())	return false;
			qf.push(f[v]);
		}
		else if (f[v]<=qc.top())	qf.push(f[v]);
		else	qc.pop();
	}
	return true;
}
//}}}
int main()
{
	cin>>n;
	for (int i=1;i<=n;++i)	lg[i]=lg[i>>1]+1;
	for (int i=2;i<=n;++i){
		cin>>u>>v>>val;
		if (u==1||v==1)	++num;
		add(u,v,val),add(v,u,val);
	}
	cin>>m;
	if (m<num)	return printf("-1\n"),0;
	for (int i=1;i<=m;++i) cin>>u,++hav[u];

	dfs(1);

	r<<=1;
	while (l<r){
		mid=(l+r)/2;
		if (check())	r=mid;
		else	l=mid+1;
	}

	printf("%lld\n",l);
	return 0;
}

```

>如有哪里讲得不是很明白或是有错误，欢迎指正




---

## 作者：qwaszx (赞：3)

这题细节非常的多...

首先最大值最小想到二分，然后变成判定性问题.

二分一个最大时间$x$，然后贪心地尽可能把各军队往上提(但是不要提到根).提的时候倍增加速.处理出提到所在子树的根时剩余的时间.

然后处理根的所有子树，令所有子树内(非子树的根)的军队控制所在城市.$dfs$处理出哪些子树还没有被完全控制.注意如果一个点的所有子树都被控制了那么这个点被控制了.

考虑所有子树的根的军队，现在我们的问题变成了在菊花图上判定这个问题.可以先把所有点提到根，然后匹配未被控制的子树.但是还有一些情况.

1. 某个点提不到根，那么让它控制这棵子树;

2. 某个点所在子树并没有完全被控制，并且它是这棵子树中剩余时间最小的.如果它到根之后不能回到那个点则让它控制这棵子树.

为什么?因为如果它去控制其他子树，那么控制的那棵子树需要的时间更少，不如控制当前这棵子树.

然后就是非常常规的做法了(

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=1e6+5000;
const long long INF=1e18;
struct Edge{int v,w;}e[N];
long long s[20][N],dep[N];
int son[N],size,n,m,f[20][N],bl[N],ok[N],lft[N],fst[N],nxt[N],c[N],mm;
struct Node{long long w;int id;}tmp[N];
void ade(int u,int v,int w){e[++mm]=(Edge){v,w},nxt[mm]=fst[u],fst[u]=mm;}
void dfs(int u,int fa,int anc)
{
	f[0][u]=fa;dep[u]=fa!=1?dep[fa]+s[0][u]:0;
	if(fa==1)anc=u;bl[u]=anc;
	for(int i=1;f[i-1][u];i++)
		f[i][u]=f[i-1][f[i-1][u]],s[i][u]=s[i-1][u]+s[i-1][f[i-1][u]];
	for(int i=fst[u];i;i=nxt[i])
	{
		int v=e[i].v;
		if(v!=fa)
		{
			if(!fa)dep[u]+=e[i].w,son[++size]=v;
			s[0][v]=e[i].w,dfs(v,u,anc);
		}
	}
}
int cmp1(const Node &a,const Node &b){return a.id==b.id?a.w>b.w:a.id<b.id;}
int cmp2(const Node &a,const Node &b){return a.w<b.w;}
void dfs1(int u,int fa)
{
	if(ok[u])return;int flg1=0,flg2=1;
	for(int i=fst[u];i;i=nxt[i])
	{
		int v=e[i].v;if(v==fa)continue;
		flg1=1;dfs1(v,u);if(!ok[v])flg2=0;
	}
	ok[u]=flg1&&flg2;
}
int judge(long long mid)
{
	for(int i=1;i<=n;i++)ok[i]=0;int cnt=0;
	for(int i=1;i<=m;i++)
	{
		int u=c[i];long long ts=0;if(c[i]==1){tmp[++cnt]=(Node){mid,1};continue;}
		for(int j=20;j>=0;j--)
			if(f[j][u]>1&&ts+s[j][u]<=mid)
				ts+=s[j][u],u=f[j][u];//倍增上跳
		if(u!=bl[u])ok[u]=1;
		else tmp[++cnt]=(Node){mid-ts-s[0][u],u};
	}
	dfs1(1,0);
	sort(tmp+1,tmp+cnt+1,cmp1);int cnt1=0;
	tmp[cnt+1].id=0;
	for(int i=1;i<=cnt;i++)
	{
		if(tmp[i].w>0&&(tmp[i].id==tmp[i+1].id||tmp[i].w>=s[0][tmp[i].id]||ok[tmp[i].id]))tmp[++cnt1]=tmp[i];//按照条件
		else ok[tmp[i].id]=1;
	}
	sort(tmp+1,tmp+cnt1+1,cmp2);cnt=0;
	for(int i=1;i<=size;i++)if(!ok[son[i]])lft[++cnt]=s[0][son[i]];
	sort(lft+1,lft+cnt+1);//把所有没被控制的子树拿出来
	int i=cnt1,j=cnt;
	for(;i&&j;i--)
		if(tmp[i].w>=lft[j])--j;
	return !j;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<n;i++)
	{
		int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		ade(u,v,w),ade(v,u,w);
	}
	scanf("%d",&m);
	dfs(1,0,0);if(m<size){puts("-1");return 0;}
	long long l=0,r=0,mid;
	for(int i=1;i<=m;i++)scanf("%d",c+i);
	for(int i=1;i<=n;i++)r+=dep[i];
	while(l<r)
	{
		mid=(l+r)>>1;//cout<<mid<<endl;
		if(judge(mid))r=mid;
		else l=mid+1;
	}
	cout<<l<<endl;
}
```

---

## 作者：Wei_Han (赞：2)

有些坑点的题。

答案的单调性显然，考虑二分答案，首先能够发现向父亲走一定不劣，因为覆盖的节点更多了，那么我们已知最大时间为 $k$，令每一个点向上走尽量接近 $k$ 的距离就好了，可是由于不能走到根，那么有的点可能还有剩余步数，但是只能暂时停在根的儿子下。

这样我们就能够得到一棵新树，如果一个被染色点不在根的儿子，那么其一定无法再移动了，所以我们之后的操作只需要对于根的儿子讨论即可。

对于新树，根有的子树内是覆盖不完整的，称为空子树，那么我们需要拿有多余点的子树去填空子树，一个很 naive 的想法是开两个小根堆，分别存空的和多余的到根的距离，匹配一下就做完了，这样确实挺对的，但只有 $70$ 分。

考虑上述做法错在哪里，假设此时有根有三个儿子，$a,b,c$，其中 $c$ 为空，$a,b$ 均有一个染色点，其中距离 $b < a < c$，我们需要填满 $c$，那么刚才的做法可能是直接让 $a$ 去 $c$，花费时间为 $a+c$，而另一种做法是先让 $a$ 去 $b$，再让 $b$ 去 $c$，时间为 $\max(a+b,b+c)$，在某些情况下是更优的。

讨论区一组直观的数据：

```
4
1 2 99
1 3 1
1 4 99
3
3 4 4
```

答案为 $100$。

因此，我们考虑优先将所有距离够的染色点提到根，对于来自于每一棵子树的点按照剩余步数排序，那么剩余步数多的肯定更加可能走到更远的未染色点，那么我们就要将距离短的放回本子树中保证子树被染色，放一个就好了，具体实现可以参考代码。

复杂度 $O(n\log^2 n)$，因某些不可名状因素，采用树剖实现。

$70$ 分实现：

```cpp
const ll N=1e6+5,M=2e4+5;
ll n,m,fa[N],siz[N],id[N],w[N],son[N],dep[N],top[N],cnt,dis[N],Siz[N],vis[N];
vector<pii> g[N],E;vector<ll> P;
inline void dfs1(ll x,ll fat,ll depth){dep[x]=depth,siz[x]=1,fa[x]=fat;for(auto [y,w]:g[x]){if(y==fat) continue;dis[y]=dis[x]+w;dfs1(y,x,depth+1);siz[x]+=siz[y];if(siz[y]>siz[son[x]]) son[x]=y;}}
inline void dfs2(ll x,ll nowtop){top[x]=nowtop,id[x]=++cnt,w[cnt]=x;if(!son[x])return;dfs2(son[x],nowtop);for(auto [y,w]:g[x])if(y!=fa[x]&&y!=son[x]) dfs2(y,y);}
inline ll LCA(ll x,ll y){while(top[x]^top[y]) dep[top[x]]<dep[top[y]]?y=fa[top[y]]:x=fa[top[x]];return dep[x]<dep[y]?x:y;}
inline ll DIS(ll x,ll y){return dis[x]+dis[y]-2*dis[LCA(x,y)];}
inline ll LCApre(ll x,ll y){ll lst=x;while(top[x]^top[y]) dep[top[x]]<dep[top[y]]?lst=top[y],y=fa[top[y]]:lst=top[x],x=fa[top[x]];if(dep[x]<dep[y]) swap(x,y);return x==y?lst:w[id[y]+1];}
inline ll ask_chain(ll x,ll pre,ll mid)
{
    ll xx=x,y=pre;
    while(top[x]^top[y])
    {
        if(dep[top[x]]<dep[top[y]]) swap(x,y);
        ll Top=max(id[pre],id[top[x]]);Top=w[Top];
        if(dis[xx]-dis[Top]<mid){x=fa[top[x]];continue;}
        ll l=id[Top],r=id[x];
        while(l<r)
        {
            ll mid=l+r+1>>1;
            if(dis[xx]-dis[w[mid]]<mid) r=mid-1;
            else l=mid;
        }
        return w[l];
    }
    if(dep[x]<dep[y]) swap(x,y);
    ll l=id[y],r=id[x];
    while(l<r)
    {
        ll mid=l+r+1>>1;
        if(dis[xx]-dis[w[mid]]<mid) r=mid-1;
        else l=mid;
    }
    return w[l];
}
inline ll dfs3(ll x)
{
    ll sum=0;for(auto [y,w]:g[x]) if(y!=fa[x]) sum+=dfs3(y);
    return (g[x].size()!=1&&sum==g[x].size()-1)||(Siz[x]>0);
}
inline ll dfs4(ll x)
{
    ll sum=0;for(auto [y,w]:g[x]) if(y!=fa[x]) sum+=dfs3(y);
    return (g[x].size()!=1&&sum==g[x].size()-1);
}
inline bool check(ll mid)
{
    priority_queue<pii,vector<pii>,greater<pii> > pq;
    fo(0,i,n+1) Siz[i]=0,vis[i]=0;
    for(ll i:P)
    {
        ll pre=LCApre(i,1);
        if(dis[i]-dis[pre]<=mid) Siz[pre]++;
        else Siz[ask_chain(i,pre,mid)]++;
        if(dis[i]-dis[1]<=mid) pq.push(mp(mid-dis[i]+dis[1],pre));
    }
    for(auto [y,w]:g[1]) if(Siz[y]) vis[y]=dfs4(y);E.clear();
    for(auto [y,w]:g[1]) if(!dfs3(y)) E.pb(mp(dis[y],y));sort(all(E));
    ll ans=0;
    for(auto [w,i]:E)
    {
        while(pq.size()&&(pq.top().fi<w||(!vis[pq.top().se]&&Siz[pq.top().se]<=1))) pq.pop();
        if(pq.size())
        {
            Siz[pq.top().se]--,pq.pop(),ans++;
        }
    }
    return ans==E.size();
}
signed main(){
    read(n);ll u,v,w;
    fo(1,i,n-1) read(u,v,w),g[u].pb(mp(v,w)),g[v].pb(mp(u,w));
    dfs1(1,0,1),dfs2(1,1);
    ll maxn=0,maxx=0;fo(1,i,n) if(dis[i]>=maxn) maxx=maxn,maxn=max(maxn,dis[i]);else if(dis[i]>=maxx) maxx=dis[i];
    read(m);fo(1,i,m) read(u),P.pb(u);
    ll l=0,r=1e14; 
    while(l<r)
    {
        ll mid=l+r>>1;
        ll opt=check(mid);
        if(opt) r=mid;
        else l=mid+1;
    }
    wr(l==1e14?-1:l),pr;
    return 0;
}
``````

满分，区别只有 ```check``` 函数:

```cpp
const ll N=1e6+5,M=2e4+5;
ll n,m,fa[N],siz[N],id[N],w[N],son[N],dep[N],top[N],cnt,dis[N],Siz[N],vis[N];
vector<pii> g[N],E;vector<ll> P;
inline void dfs1(ll x,ll fat,ll depth){dep[x]=depth,siz[x]=1,fa[x]=fat;for(auto [y,w]:g[x]){if(y==fat) continue;dis[y]=dis[x]+w;dfs1(y,x,depth+1);siz[x]+=siz[y];if(siz[y]>siz[son[x]]) son[x]=y;}}
inline void dfs2(ll x,ll nowtop){top[x]=nowtop,id[x]=++cnt,w[cnt]=x;if(!son[x])return;dfs2(son[x],nowtop);for(auto [y,w]:g[x])if(y!=fa[x]&&y!=son[x]) dfs2(y,y);}
inline ll LCA(ll x,ll y){while(top[x]^top[y]) dep[top[x]]<dep[top[y]]?y=fa[top[y]]:x=fa[top[x]];return dep[x]<dep[y]?x:y;}
inline ll LCApre(ll x,ll y){ll lst=x;while(top[x]^top[y]) dep[top[x]]<dep[top[y]]?lst=top[y],y=fa[top[y]]:lst=top[x],x=fa[top[x]];if(dep[x]<dep[y]) swap(x,y);return x==y?lst:w[id[y]+1];}
inline ll ask_chain(ll x,ll pre,ll mid)
{
    ll xx=x,y=pre;
    while(top[x]^top[y])
    {
        if(dep[top[x]]<dep[top[y]]) swap(x,y);
        ll Top=max(id[pre],id[top[x]]);Top=w[Top];
        if(dis[xx]-dis[Top]<mid){x=fa[top[x]];continue;}
        ll l=id[Top],r=id[x];
        while(l<r)
        {
            ll mid=l+r+1>>1;
            if(dis[xx]-dis[w[mid]]<mid) r=mid-1;
            else l=mid;
        }
        return w[l];
    }
    if(dep[x]<dep[y]) swap(x,y);
    ll l=id[y],r=id[x];
    while(l<r)
    {
        ll mid=l+r+1>>1;
        if(dis[xx]-dis[w[mid]]<mid) r=mid-1;
        else l=mid;
    }
    return w[l];
}
inline ll dfs3(ll x)
{
    ll sum=0;for(auto [y,w]:g[x]) if(y!=fa[x]) sum+=dfs3(y);
    return (g[x].size()!=1&&sum==g[x].size()-1)||(Siz[x]>0);
}
inline ll dfs4(ll x)
{
    ll sum=0;for(auto [y,w]:g[x]) if(y!=fa[x]) sum+=dfs3(y);
    return (g[x].size()!=1&&sum==g[x].size()-1);
}
inline bool check(ll mid)
{
    priority_queue<pii,vector<pii>,greater<pii> > pq;
    fo(0,i,n+1) Siz[i]=0,vis[i]=0;ll ans=0;
    vector<pii> E1,E2;
    for(ll i:P)
    {
        ll pre=LCApre(i,1);
        if(dis[i]-dis[pre]<=mid) E1.eb(mp(mid-dis[i]+dis[1],pre));
        else Siz[ask_chain(i,pre,mid)]=1;
    }
    for(auto [y,w]:g[1]) Siz[y]=dfs4(y);
    sort(all(E1));for(auto [w,i]:E1)if(w>0&&(Siz[i]||w>=dis[i])) pq.push(mp(w,i));else Siz[i]=1;
    E.clear();for(auto [y,w]:g[1]) if(!dfs3(y)) E.pb(mp(dis[y],y));sort(all(E));
    for(auto [w,i]:E)
    {
        while(pq.size()&&(pq.top().fi<w)) pq.pop();
        if(pq.size()) Siz[pq.top().se]--,pq.pop(),ans++;
    }
    return ans==E.size();
}
signed main(){
    read(n);ll u,v,w;
    fo(1,i,n-1) read(u,v,w),g[u].pb(mp(v,w)),g[v].pb(mp(u,w));
    read(m);fo(1,i,m) read(u),P.pb(u);
    dfs1(1,0,1),dfs2(1,1);
    ll l=0,r=1e14; 
    while(l<r)
    {
        ll mid=l+r>>1;
        if(check(mid)) r=mid;
        else l=mid+1;
    }
    wr(l==1e14?-1:l),pr;
    return 0;
}
``````

---

## 作者：under_the_time (赞：2)

## 题意

> 给定一棵 $n$ 个点的树，根节点为 $1$，边有边权。有 $m$ 个标记，一开始第 $i$ 个标记在点 $s_i$ 上。对于标记 $i$，你需要选择一个终点 $t_i$，定义代价 $w_i$ 为连接 $s_i$ 和 $t_i$ 路径上所有边的边权之和，但是 $t_i\ne 1$。你需要最小化 $\max_{i=1}^m w_i$，使得在移动完标记后，每个叶子节点到根都有至少一个标记。
>
> $2\le m\le n\le 5\times 10^4$，边权为 $[1,10^9]$ 中的正整数。

## 题解

最小化一个最大值，考虑二分这个 $\max_i w_i$，设其为 $dis$。若一个标记最终到了点 $u$，那么它就解决了 $u$ 子树中所有叶子，相当于这个标记覆盖了 $u$ 的子树。问题转化为：需要使整棵树除了根节点，其余节点均需要被覆盖至少一次。一个朴素的想法是，显然标记的深度越浅，它能管辖的子树越大。于是对于第 $i$ 个标记，我们让它从 $s_i$ 开始不断往祖先跳，直到代价超过 $dis$ 或者跳到了根节点，最后从根开始 dfs 进行 check。

这个做法错在哪里呢？对于标记 $i$，若 $i$ 在到达根节点之前代价就达到了 $dis$，那么终点确实应该尽可能往上。那如果 $i$ 能到达根节点，且跳到根节点后，它的代价还允许 $i$ 跳到根节点的其他孩子；也就是说，当根节点有一个孩子的子树没被覆盖完，那么这个学有余力的 $i$ 就可以去支援这个兄弟子树。

那就稍微改一改？我们把所有走到根节点后代价仍 $\le dis$ 的标记存下来，记录一下根节点有哪些孩子不合法。我们贪心地，把剩余可用路程更少的标记，分配给连接根节点与不合法的孩子的边的边权更小的孩子进行支援；若发现某个标记无力支援分配给它的子树，那么这个标记就留在自己的子树里。这看起来完美了，但是貌似还有一个问题：这些能够走到根节点的标记，有留在自己子树的选择，此时代价为 $0$；也就是说，对于每个标记，它选择留在自己子树的代价，与支援其他子树的代价的计算方式本质不同。

不妨看看什么时候标记会选择支援其他子树。注意到一个标记选择支援其他子树，那么自己的子树也需要一个标记挪过来。设标记 $u$ 选择离开 $i$ 的子树到达 $j$ 的子树，又有一个标记 $v$ 替补了 $u$ 的位置到达 $i$ 的子树。令 $w(i,1)$ 表示从 $i$ 到根节点 $1$ 的边权，$w(j,1)$ 同理。

- 若 $w(i,1)\ge w(j,1)$，那么 $v$ 既然能走到 $i$ 就必定能走到 $j$，我们调整 $v$ 的终点到 $j$，即 $u$ 原本的终点；而 $u$ 就可以安心呆在 $i$ 上，$j$ 子树也会被 $v$ 覆盖。
- 若 $w(i,1)<w(j,1)$，类似的我们发现 $u$ 完全可以从 $i$ 走到 $1$ 后仍有余力回到 $i$ 上，此时我们就不用关心 $u$ 走到 $i$ 时代价是 $0$ 还是 $2\times w(i,1)$。

那就再改一改：对于标记 $i$，若它能走到 $1$ 又走回到自己的子树，那么就没什么特殊的；否则按照上述的调整方式，一定可以使 $i$ 留在自己的子树里，我们直接让 $i$ 呆着就行了。贪心方式仍和之前是一样的。

往祖先跳的过程可以考虑倍增，时间复杂度 $O(n\log^2n)$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 5e4 + 5;
#define ll long long
int n,m;
vector<pair<int,ll> > mp[maxn];
void addEdge(int u,int v,ll w) {
    mp[u].emplace_back(v,w);
}
int army[maxn];
int f[maxn][30];
ll dis[maxn][30];
void Dfs(int u,int fa) {
    f[u][0] = fa;
    for (int i = 1;i <= 20; i ++)
        f[u][i] = f[f[u][i - 1]][i - 1],
        dis[u][i] = dis[u][i - 1] + dis[f[u][i - 1]][i - 1];
    for (auto v : mp[u])
        if (v.first != fa) {
            dis[v.first][0] = v.second;
            Dfs(v.first,u);
        }
}
pair<ll,int> mor[maxn]; int tot;
bool sty[maxn];
bool dfs(int u,int fa) {
    if (sty[u]) return true;
    bool ok = false;
    for (auto V : mp[u]) {
        int v = V.first;
        if (v == fa) continue;
        ok = 1;
        if (!dfs(v,u)) return false;
    }
    return ok;
}
bool ned[maxn];
int cnt1, A[maxn];
int cnt2, B[maxn];
bool check(ll X) {
    memset(sty,false,sizeof(sty));
    tot = cnt1 = cnt2 = 0;
    for (int i = 1;i <= m;i ++) {
        int now = army[i]; ll sum = 0;
        for (int j = 20;j >= 0;j --)
            if (f[now][j] > 1 && sum + dis[now][j] <= X)
                sum += dis[now][j], now = f[now][j];
        if (f[now][0] == 1 && sum + dis[now][0] <= X)
            mor[++ tot] = {X - sum - dis[now][0],now};
        else sty[now] = 1;
    }
    memset(ned,0,sizeof(ned));
    for (auto u : mp[1])
        if (!dfs(u.first,1))
            ned[u.first] = 1;
    sort(mor + 1,mor + tot + 1);
    for (int i = 1;i <= tot;i ++) {
        int c = mor[i].first,u = mor[i].second;
        if (ned[u] && dis[u][0] > c) ned[u] = 0;
        else A[++ cnt1] = c;
    }
    for (auto u : mp[1])
        if (ned[u.first])
            B[++ cnt2] = dis[u.first][0];
    if (cnt1 < cnt2) return false;
    sort(A + 1,A + cnt1 + 1); 
    sort(B + 1,B + cnt2 + 1);
    int i, j;
    for (i = 1,j = 1;i <= cnt2 && j <= cnt1;)
        if (A[j] >= B[i]) i ++, j ++;
        else j ++;
    return i > cnt2;
}
int main() {
    scanf("%d",&n);
    ll r = 0; ll w;
    for (int i = 1,u,v;i < n;i ++) {
        scanf("%d%d%lld",&u,&v,&w);
        addEdge(u,v,w); addEdge(v,u,w);
        r += w;
    }
    Dfs(1,0);
    scanf("%d",&m);
    for (int i = 1;i <= m;i ++)
        scanf("%d",&army[i]);
    ll l = 1; ll ans = -1;
    while (l <= r) {
        ll mid = l + r >> 1ll;
        if (check(mid)) r = (ans = mid) - 1;
        else l = mid + 1;
    }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：bugaile (赞：2)

题目大意$:$

给你$n$个点的一棵树,再给你$m$个检查点的位置,检查点可以同时移动,且可停留于除$1$号节点外的任一点,现在需要从$1$到每一个叶子节点的路径上都至少有一个检查点,求移动最远的检查点移动距离最小为多少.$n,m<=50000$,$w_i<10^9$.

 现在从题面就可以看出,这个题很可能要用二分答案,每次二分一个移动距离,检查是否可以将叶子节点完全覆盖.现在就需要知道如何$check$.
 
 首先,我们可以贪心的想,对于有检查点的节点$i$,如果我们将他的检查点移到父亲节点上,其可覆盖的叶子节点不会减少,所以首先让有军队驻扎的点的军队尽量往根节点移动,如果在$mid$距离内可以移动到根节点,就将其放置在根节点的对应的子节点上,同时记录下其还剩下多少距离可以走,记为$rest$.这些有剩余时间的军队就是可以去驻扎其他子树的军队集合,记为$free$.
 
 现在我们找出了可以覆盖其他节点的军队,再找出其他需要覆盖的点即可.我们再将军队跳向根节点跳时,将最终有军队的节点标记,再对树进行一次遍历,同时将标记下传,就可找出所有的未被标记的叶子节点,再将其所属于的那个根节点的子节点加入需要军队的集合当中,记为$need$,如图:
 
 ![](  https://i.loli.net/2019/08/26/voZ9JQa815fcyEL.png)
 
 若$3$号节点未被标记,则需要将$2$号节点加入需要军队的集合.但在遍历时,不要将根节点的子节点的标记下传,因为如果一个根节点的子节点有标记,说明这里有军队,但这些军队是可能需要驻扎在其他节点的,所以不能下传其标记.
 
然后我们可以再贪心一下$:$

而对于$need$集合内的一个节点$i$,若该点驻扎了一支军队$s$,且这只军队的剩余距离不足以使其走到根节点在回来,那么当前点$i$由其子树内的节点驻扎一定可以得到一种最优解.

因为若当前节点由其他子树加点$i'$上的军队$s'$驻扎,那么军队$s'$在到达根节点的距离后的剩余距离$rest[s']-dis[i']>=dis[i]>=rest[s]-dis[i]$,也就是说再到达根节点后,$s'$的剩余距离大于$s$,所以将$s'$用来覆盖其他节点,将$s$用来覆盖其自身显然更优秀.

最后将在上一段所说的点与军队在集合中删去,将$free$按到根节点后的剩余距离排序,将$need$按到根节点的距离排序,再检查$need$中的店是否可以被全部标记即可.

将军队向根节点跳用$树上倍增法$,总体时间复杂度为$O((nlogn+mlogn)logSum)$.

``` cpp
#include<vector>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define ll long long
using namespace std;
const int N=5e4+3;
ll sum,dis[N],dist[N];
int n,m,u,cnt,cont;
int am[N],lg[N],f[N][17],dp[N],vis[N],fre[N],b[N],pl[N],nee[N];
int tt,head[N],to[N<<1],nex[N<<1],w[N<<1];
vector<int>arv[N];
struct LCA{//直接套的lca模板
	void pre(int g,int F){//预处理父亲;
		for(int i=head[g],v;i;i=nex[i]){
			v=to[i];
			if(v==F)continue;
			f[v][0]=g,dp[v]=dp[g]+1,dis[v]=dis[g]+(ll)w[i];
			for(int j=1;j<=lg[dp[v]];++j)
				f[v][j]=f[f[v][j-1]][j-1];
			pre(v,g);
		}
		return ;
	}
	int get(int x,int y){
		if(dp[x]>dp[y])swap(x,y);
		for(int i=lg[dp[y]-dp[x]];i>=0;--i)
			if(dp[f[y][i]]>=dp[x])y=f[y][i];
		if(x==y)return x;
		for(int i=lg[dp[x]];i>=0;--i)
			if(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i];
		return f[x][0];
	}
}lca;
inline void add(int x,int y,int W){
	to[++tt]=y,nex[tt]=head[x],w[tt]=W,head[x]=tt;
	return ;
}
inline bool dfs(int g,int F){
	if(vis[g]&&!pl[g])return true;//若当前节点不是根节点的子节点,且有标记,说明当前子树已全部被标记;
	bool flag=0;
	for(int i=head[g],v;i;i=nex[i]){
		v=to[i];
		if(v==F)continue;
		if(!dfs(v,g))return false;//有一个叶子节点未被标记就需要加入need集合;
		flag=1;
	}
	return flag;
}
inline bool check(ll mid){
	for(int i=1;i<=cnt;++i)arv[i].clear();
	memset(vis,0,sizeof vis);
	for(int i=1;i<=m;++i){
		int y=am[i];
		dist[i]=0;
		for(int j=dp[y];j>=0;--j)//;将其向父亲跳
			if(f[y][j]>1&&dist[i]+dis[y]-dis[f[y][j]]<=mid){
				dist[i]+=dis[y]-dis[f[y][j]];
				y=f[y][j];
			}
		vis[y]=1;//将当前节点标记;
		int j=pl[y];//找到对应的根节点的子节点的编号;
		if(j){
			arv[j].push_back(mid-dist[i]);//将剩余距离加入第j个子节点;
			if(arv[j].size()>1&&arv[j][arv[j].size()-2]<arv[j][arv[j].size()-1])
				swap(arv[j][arv[j].size()-2],arv[j][arv[j].size()-1]);//将剩余距离最短的点放到尾部;
		}
	}
	int cnt1=0,cnt2=0;
	for(int i=1;i<=cnt;++i){
		if(!dfs(to[b[i]],1)){//判定是否需要军队驻扎;
			if(arv[i].size()&&arv[i][arv[i].size()-1]<w[b[i]]*2)
				arv[i].pop_back();//若当前点存在无法先到达根节点,再返回当前点的的军队,就将其军队用来驻扎当前点;
			else nee[++cnt1]=w[b[i]];//否则将当前点加入need集合;
		}
		for(int j=0;j<arv[i].size();++j)
			if(arv[i][j]>=w[b[i]])
				fre[++cnt2]=arv[i][j]-w[b[i]];//将符合条件的军队加入free集合;
	}
	if(cnt1>cnt2)return false;//如果军队数小于节点数,就无法完全覆盖;
	sort(nee+1,nee+1+cnt1);
	sort(fre+1,fre+1+cnt2);//排序;
	while(cnt1){//反向比较;
		if(fre[cnt2]<nee[cnt1])return false;//若当前点无法被当前军队覆盖,那么在他之后的军队也无法将其覆盖;
		--cnt2,--cnt1;
	}
	return true;//将节点完全覆盖;
}
inline ll solve(){
	ll l=0,r=sum+1;
	while(l<r){
		ll mid=l+r>>1;
		if(check(mid))r=mid;
		else l=mid+1;
	}
	return l;
}
int main(){
	cin>>n;
	lg[0]=-1;
	for(int i=1;i<=n;++i)lg[i]=lg[i>>1]+1;//初始化lg数组;
	int x,y,W;
	for(int i=1;i<n;++i)cin>>x>>y>>W,add(x,y,W),add(y,x,W),sum+=W;
	for(int i=head[1],v;i;i=nex[i])v=to[i],b[++cnt]=i,pl[v]=cnt;//b记录根节点的第cnt条边,pl记录节点对应第几条边;
	cin>>m;
	lca.pre(1,0);
	for(int i=1;i<=m;++i)cin>>x,am[i]=x;
	if(m<cnt)puts("-1");//若军队数小于根节点的子节点数,则一定无法完全覆盖;
	else cout<<solve()<<'\n';//否则一定可以完全覆盖;
	return 0;
}

```

---

## 作者：万弘 (赞：2)

D2T3确实不太容易

一步一步来吧。

我的做法以**二分答案**为基础（二分耗时）：  
先简单证明一下：
>  设最优解耗时为S，则任意时间T<=S都一定不可行，否则与S的最优性违背；任意时间T>=S都存在耗时不超过T的解，因为S就满足这个条件。故该问题满足单调性，可以用二分答案求解。

于是我们只要能快速验证某个T是否可行，就可知S了。

那如何验证呢？  
一个很显然的贪心是，在耗时不超过T和不跳到首都的情况下，**拼命往上跳**一定会比不动或跳到中途就不跳控制更多的边境城市  
然后，搞一下从叶到根的bfs，找出未被控制的子树。对于能走到首都的都走到首都，并**控制能到达的最远的未被控制的子树**（特别的，如果走到首都后剩余的距离甚至不能走回原子树且原子树未被控制，那么留在原子树最优）

如果暴力地往上跳/选择到达哪棵子树最优，检验一次复杂度$O(n^2)$

如果用**树上倍增**（父亲和路程），对于控制子树的代价**搞一个堆/排序**，就可以$O(nlogn)$地检验了

总复杂度$O(nlog^2n)$

//有疑问请私信我,评论看不到

我的代码很丑，各位大可不看。
```cpp
//头文件？不存在的
ll read();//快读
ll min(ll a,ll b)
{
    return a<b?a:b;
}
ll max(ll a,ll b)
{
    return a>b?a:b;
}

#define MAXN 50011
ll n,m,a[MAXN];
struct Edge//这些都是存树的
{
    ll v,w,nxt;
}e[MAXN<<1|1];
ll cnt=0,last[MAXN];
void adde(ll u,ll v,ll w)
{
    ++cnt;
    e[cnt].v=v,e[cnt].w=w;
    e[cnt].nxt=last[u];last[u]=cnt;
}

ll dep[MAXN],fa[19][MAXN],fw[19][MAXN],lg[MAXN];
bool del[MAXN],leaf[MAXN],vis[MAXN];
void build(ll u,ll t)//建树
{
    dep[u]=t;
    bool flag=0;
    for(ll i=last[u];i;i=e[i].nxt)
    {
        ll v=e[i].v;
        if(v==fa[0][u])continue;
        flag=1;
        fa[0][v]=u;fw[0][v]=e[i].w;
        build(v,t+1);
    }
    if(!flag)leaf[u]=1;//leaf[u]=1:u是叶子/边境城市
}
void mul()//预处理倍增
{
    lg[1]=0;
    for(unsigned i=2;i<=n;++i)lg[i]=lg[i>>1]+1;
    for(unsigned i=1;i<=lg[n];++i)
        for(ll u=1;u<=n;++u)
        {
            fa[i][u]=fa[i-1][fa[i-1][u]];//倍增父亲
            fw[i][u]=fw[i-1][u]+fw[i-1][fa[i-1][u]];//倍增距离
        }
            
}
ll q[MAXN],h,t;
std::vector<ll>g[MAXN];//能一步到达首都的城市中的军队
ll q1[MAXN],l1,q2[MAXN],l2;//q1:在首都的军队能走的距离，l1是其数量；q2:控制未被控制的子树的代价，l2是其数量
bool check(ll k)
{
    l1=l2=0;
    memset(del,0,sizeof del);
    memset(vis,0,sizeof vis);//memset勿忘！
    for(ll i=1;i<=n;++i)g[i].clear();
    
    for(ll i=1;i<=m;++i)
    {
        ll s=0,pos=a[i];
        for(ll j=lg[dep[pos]];j>=0;--j)
            if(fa[j][pos]!=1&&s+fw[j][pos]<=k)
                s+=fw[j][pos],pos=fa[j][pos];
        if(fa[0][pos]!=1)del[pos]=1;//del[pos]=1:pos被控制
        else
        {//g[pos][0]:pos点的军队里能走的距离最近的军队
            if(g[pos].size())g[pos][0]=min(g[pos][0],k-s),g[pos].push_back(k-s);
            else g[pos].push_back(k-s),g[pos].push_back(k-s);
        }
    }
    h=t=1;
    for(ll i=1;i<=n;++i)
        if(leaf[i]&&!del[i])q[t++]=i,vis[i]=1;
    while(h<t)//从叶到根bfs
    {
        ll u=q[h++];
        for(ll i=last[u];i;i=e[i].nxt)
        {
            ll v=e[i].v,w=e[i].w;
            if(del[v]||vis[v])continue;
            if(v==1)//到了首都
            {
                bool flag=0;
                if(!g[u].size())//当前点无军队,需要被封锁
                {
                	q2[++l2]=w;continue;
                }
                if(g[u][0]<w+w)del[u]=1,flag=1;//留在原子树
                else q2[++l2]=w;
                for(std::vector<ll>::iterator it=g[u].begin()+1;it!=g[u].end();++it)
                {
                    if(*it==g[u][0]&&flag)flag=0;//那个留在原子树的军队不要到首都去
                    else q1[++l1]=(*it)-w;
                }
            }
            else q[t++]=v,vis[v]=1;
        }
    }
    for(ll i=1;i<=n;++i)
    	if(!vis[i]&&g[i].size())
    	{
    		for(std::vector<ll>::iterator it=g[i].begin()+1;it!=g[i].end();++it)
    			q1[++l1]=(*it)-fw[0][i];
		}
    if(l1<l2)return 0;//在首都的军队数不足未被封锁的子树数肯定没希望
    std::sort(q1+1,q1+l1+1);std::sort(q2+1,q2+l2+1);
    while(l2>0)//因为l1>=l2,所以l2>0则l1>0
    {
    	if(q1[l1]<q2[l2])return 0;//无法封锁
    	--l1,--l2;
	}
    return 1;
}
int main()
{
    n=read();
    ull sum=0;
    for(ll i=1;i<n;++i)
    {
        ll u=read(),v=read(),w=read();
        sum+=w;
        adde(u,v,w);
        adde(v,u,w);
    }
    fa[0][1]=1;
    build(1,1);
    mul();
    m=read();
    for(ll i=1;i<=m;++i)a[i]=read();
    ull l=0,r=sum,mid;
    while(l<r)
    {
        mid=(l+r)>>1;
        if(check(mid))r=mid;
        else l=mid+1;
    }
    if(!check(r))printf("-1");//无解
    else printf("%llu",r);
    return 0;
}
```

---

## 作者：wangshengchen (赞：1)

## 题目大意：

H 国拥有 $n$ 个城市，这 $n$ 个城市通过 $n - 1$ 条双向道路相互连通，构成一棵树状结构。城市 $1$ 被设定为首都，且是这棵树的根节点。

近期，首都爆发了一种危害性极高的传染病。当局为了控制疫情，决定在一些城市建立检查点，以确保从首都到达任何边境城市（树的叶子节点）时，每条路径上都至少经过一个检查点。需要注意的是，首都是不允许设置检查点的。

现在，在 H 国的一些城市中已经驻扎有军队。军队可以在相邻城市之间移动，并且可以在除首都以外的城市内建立检查点。但每支军队只能在一个城市设立检查点。

### 目标：
- 为了控制疫情并确保所有边境城市受到检查，我们需要设计一个算法，计算出部署检查点所需的最少时间，或者判断是否可以完成该操作。

### 思路：
- 实现一个图的深度优先遍历和路径计算，利用 DFS 及动态规划对图结构进行遍历。
- 使用相关的标记和关系来判断每个节点与其他节点的评估条件。
- 通过分析输入的关系和动态更新状态来计算最终的合法路径。

## Code

```cpp
#include <cstdio> // 引入标准输入输出库
#include <algorithm> // 引入算法库，包含 sort 和其他算法
using namespace std;

// 定义 long long 类型为 int
typedef long long ll;

// 常量定义
const int N = 3e5 + 5; // 最大节点数
const ll inf = 3e15; // 定义一个非常大的值，作为无穷大

// 边的结构体，用于存储边的权重和类型
struct edge {
    ll w; // 边的权重
    bool t; // 该边的类型标记
};

int n, m, R, C; // n: 节点数量, m: 边的数量, R: 处理的边数(行), C: 处理的边数(列)
edge e[N << 1]; // 边的数组，存储边的信息，总大小为 2*N
ll ans; // 用于存储最终结果
ll d[N], low[N], ow[N], w[N]; // d: 存储节点深度值，low: 存储可访问的最小边值，ow: 用于后续计算，w: 存储权重
ll len, X[N], Y[N], cy; // 一些临时变量
ll e[N]; // 存储每个标记边对应的边数
bool ok[N], c[N], p[N], q[N]; // 状态标记数组

// DFS 函数，深度优先遍历
void dfs(int u, int f, int x) {
    low[u] = (e[u] ? d[u] : inf); // 初始化 low[u]
    w[u] = d[u]; // 为当前节点赋值

    // 将当前节点的深度值存入对应的哈希数组中
    for (int i = 1; i <= e[u]; ++i)
        h[x].eb(d[u]); // 存储当前深度

    // 遍历邻接节点
    for (auto [v, w] : g[u]) {
        if (v != f) { // 如果不是回边（父亲节点）
            d[v] = d[u] + w; // 更新深度
            dfs(v, u, x ? x : v); // 递归 DFS
            low[u] = min(low[u], low[v]); // 更新当前节点的低值
        }
    }
}

// 计算函数，给定节点，父节点，标记值，以及阈值
void calc(int u, int f, int t, int T) {
    ww[u] = (e[u] && d[u] > T ? d[u] : inf); // 更新权重
    ok[u] = (low[u] - d[u] <= T); // 检查状态
    ow[u] = (e[u] && d[u] > T - t ? d[u] : inf); // 更新边值
    bool tmp1, tmp2, tmp3; // 临时标记
    tmp3 = tmp1 = tmp2 = (g[u].size() == 1 ? 0 : 1); // 判断当前节点邻接关系

    for (auto [v, w] : g[u]) { // 遍历邻接节点
        if (v != f) {
            calc(v, u, t ? t : w, T); // 递归调用
            tmp1 &= ok[v]; // 更新状态
            tmp3 &= q[v]; // 更新状态
            tmp2 &= p[v]; // 更新状态
            ow[u] = min(ow[u], ow[v]); // 更新边值
            ww[u] = min(ww[u], ww[v]); // 更新权重值
        }
    }

    ok[u] |= tmp1; // 更新标记
    p[u] = tmp2 | (ow[u] - d[u] <= T); // 更新状态
    q[u] = tmp3 | (ww[u] - d[u] <= T); // 更新状态
}

// 检查函数，判断当前阶段是否能成功
bool chk(int t) {
    calc(1, 0, 0, t); // 执行计算，初始状态
    cy = 0; // 重置计数
    memset(X, 0, sizeof X); // 清空 X 数组

    // 检查节点
    for (auto [v, o] : g[1]) {
        if (!ok[v]) { // 如果该节点不可达
            Y[++cy] = d[v]; // 用深度存储
        } else if (p[v] && q[v]) { // 如果 p 和 q 都满足
            for (int x : h[v]) // 遍历 H 数组
                if (w[x] <= t)
                    ++X[x]; // 更新计数
        } else if (p[v] && !q[v]) { 
            int i = 0, l = h[v].size(); // 获取 h[v] 的大小

            // 统计满足条件的值
            while (i < l && w[h[v][i]] <= t)
                ++i;

            for (int j = 0; j < i - 1; ++j)
                ++X[h[v][j]]; // 更新计数
        } else if (!p[v]) { // 如果不满足 p
            for (int x : h[v])
                if (w[x] <= t - o)
                    ++X[x]; // 更新计数

            Y[++cy] = d[v]; // 记录深度
        }
    }

    if (!cy) // 如果没有更多节点
        return 1; // 成功返回1

    // 计算是否能够满足所有条件
    for (int i = 1, cnt = 0; i <= len; ++i) {
        if (w[i] + Y[cnt + 1] > t)
            return 0;

        cnt += X[i]; // 更新计数

        if (cnt >= cy)
            return 1; // 能满足条件
    }

    return 0; // 失败返回0
}

signed main() {
    ios::sync_with_stdio(0); // 开启高效输入输出
    cin.tie(0); // 绑定输入输出流
    cout.tie(0);
    cin >> n; // 读取节点数量

    // 读取图的边并存储
    for (int u, v, w, i = 1; i < n; ++i)
        cin >> u >> v >> w, g[u].eb(v, w), g[v].eb(u, w); // 双向边

    cin >> k; // 读取阈值

    // 读取节点并更新
    for (int i = 1; i <= k; ++i) {
        cin >> a[i];
        ++e[a[i]]; // 增加边的记录
    }

    // 如果 k 小于 g[1] 的边数（无法控制），结束输出 -1
    if (k < g[1].size())
        return cout << -1, 0;

    dfs(1, 0, 0); // 开始 DFS
    stable_sort(w + 1, w + n + 1); // 维护稳定排序
    len = unique(w + 1, w + n + 1) - w - 1; // 去重
    stable_sort(g[1].begin(), g[1].end(), [&](pair<int, int> u, pair<int, int> v) {
        return u.second > v.second; // 按权重降序排序
    });

    // 处理每一条边
    for (auto [i, o] : g[1]) {
        c[i] = 1; // 标记
        stable_sort(h[i].begin(), h[i].end()); // 排序

        // 更新每条边
        for (int j = 0; j < h[i].size(); ++j)
            h[i][j] = lower_bound(w + 1, w + len + 1, h[i][j]) - w; // 转换索引
    }

    // 二分查找处理
    for (int l = 0, r = inf, m; l <= r;) {
        m = l + r >> 1; // 计算中点

        if (chk(m)) // 检查条件
            ans = m, r = m - 1; // 更新答案
        else
            l = m + 1; // 移动左边界
    }
    cout << ans; // 输出结果
    return 0;
}
```

---

## 作者：lovely_qiqi (赞：0)

## 思路

题目问最少时间，直接做是困难的，观察到显然具有单调性（若时间 $t$ 行，则时间 $t+1$ 显然一定行）。考虑**二分**转换为判定性问题。

显然让所有军队在时间限制内尽可能地向根节点跳，以此来控制更多的叶子节点。如果能跳到根节点就先在根节点的子节点上待着（根节点不能驻扎军队）。这一步用**树上倍增优化**可以做到 $m\log n$ 级别。

然后在所有军队都暂时安置了之后遍历整棵树找哪些节点还没有被封锁。只找这样的节点组成的子树中的根节点，显然封锁了这样的结点之后其他的也都封锁了。

对于需要被封锁的节点，如果有军队驻扎在那里，那么对于所有军队中剩余时间最少的军队驻扎在那里是最优的。

最后对于剩下的未封锁节点和空闲的军队排序过后**双指针**一一对应即可。

## 代码

并没有删调试语句，如果还不懂可以对照样例输出信息进行加深理解。

```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
int n,q,u_,v_,w_,l,r,p1,p2,ans,mid,cl,sl,snl,stim[300010],sneed[300010],ar[300010],dep[300010],dp[300010][25],cost[200010][25];
bool flag[300010],need[300010];
struct mobile{
	int sont;
	int tim;
}c[300010];
bool cmp(mobile t1,mobile t2){
	return t1.tim<t2.tim;
}
struct node{
	int to;
	int w;
};
vector<node> v[300010];
void st_dfs(int now,int pre){//倍增表 
	dep[now]=dep[pre]+1;
	dp[now][0]=pre;
	for(int i=1;i<=16;i++){
		dp[now][i]=dp[dp[now][i-1]][i-1];
		cost[now][i]=cost[now][i-1]+cost[dp[now][i-1]][i-1];
	}
	for(int i=0;i<v[now].size();i++){
		if(v[now][i].to!=pre){
			cost[v[now][i].to][0]=v[now][i].w;
			st_dfs(v[now][i].to,now);
		}
	}
}
bool leaf_down(int now){
	if(flag[now]==true) return true;
	bool is=false;
	for(int i=0;i<v[now].size();i++){
		if(dep[v[now][i].to]<dep[now]) continue;
		is=true;
		if(leaf_down(v[now][i].to)==false) return false;
	}
	return is;
}
bool check(int t){
	int tmp,len;
	for(int i=1;i<=n;i++) flag[i]=need[i]=false;
	cl=0;
	for(int i=1;i<=q;i++){
		tmp=ar[i],len=0;
		for(int j=16;j>=0;j--){
			if(dp[tmp][j]>1&&len+cost[tmp][j]<=t){
				len+=cost[tmp][j];
				tmp=dp[tmp][j];
			}
		}
		if(dp[tmp][0]==1&&len+cost[tmp][0]<=t){
			c[++cl].sont=tmp;
			c[cl].tim=t-len-cost[tmp][0];
		}
		else flag[tmp]=true;
//		cout<<tmp<<" ";
//		if(dp[tmp][0]>1||(dp[tmp][0]==1&&len+cost[tmp][0]>=t)){
//			flag[tmp]=true;
//			cout<<tmp<<"\n";
//		}
//		else{
//			c[++cl].sont=tmp;
//			c[cl].tim=t-len-cost[tmp][0];
//			cout<<tmp<<" "<<t-len-cost[tmp][0]<<"\n";	
//		}
	}
	for(int i=0;i<v[1].size();i++){
		need[v[1][i].to]=(leaf_down(v[1][i].to)==false?true:false);
//		if(need[v[1][i].to]==true){
//			cout<<v[1][i].to<<" ";
//		}
	}
//	return false;
	sort(c+1,c+1+cl,cmp);
	sl=0;
	for(int i=1;i<=cl;i++){
		if(need[c[i].sont]==true&&c[i].tim<cost[c[i].sont][0]){
			need[c[i].sont]=false;
		}
		else{
			stim[++sl]=c[i].tim;	
		}
	}
	for(int i=0;i<v[1].size();i++){
//		need[v[1][i].to]=(leaf_down(v[1][i].to)==true?false:true);
//		if(need[v[1][i].to]) cout<<v[1][i].to<<"\n";
	}
//	return false;
	snl=0;
	for(int i=0;i<v[1].size();i++){
		if(need[v[1][i].to]==true){
			sneed[++snl]=cost[v[1][i].to][0];	
		}
	}
//	for(int i=1;i<=snl;i++){
//		cout<<sneed[i]<<" ";
//	}
//	return false;
	if(sl<snl){
		return false;
	}
	sort(stim+1,stim+1+sl);
	sort(sneed+1,sneed+1+snl);
	p1=p2=1;
	while(p1<=sl&&p2<=snl){
		if(stim[p1]>=sneed[p2]) p2++;
		p1++;
	}
	if(p2>snl) return true;
	return false;
}
void in(){//输入 
	scanf("%lld",&n);
	int u_,v_,w_;
	for(int i=1;i<=n-1;i++){
		scanf("%lld%lld%lld",&u_,&v_,&w_);
		v[u_].push_back({v_,w_});
		v[v_].push_back({u_,w_});
	}	
	scanf("%lld",&q);
	for(int i=1;i<=q;i++){
		scanf("%lld",&ar[i]);
	}
}
void solve(){
	st_dfs(1,0);
	l=0,r=5e14,ans=-1;
	while(l<=r){
		mid=(l+r)/2;
		if(check(mid)){
			ans=mid;
			r=mid-1;
		}
		else l=mid+1;
	}
	printf("%lld",ans);
}
signed main(){
	in();
	solve();
	return 0;
}
```

---

## 作者：Merge_all (赞：0)

思路比较好想，实现比较困难。  
一个下午，全来写了，终于过了。
# Solution
很明显答案具有分层性（左边是 0，右边是 1，也可以说是单调性），考虑二分答案。

记当前的答案为 $t$，那么很明显对于每个可以移动的军队 $x$，一定要往上走到最多能走到的点（如果能到达根节点，那就停留在根节点下面的那个点上）。这个操作可以用倍增优化来快速跳。

证明：一个军队往上走一定比不走不坏，这样有可能可以封锁更多的叶子节点，因此一定能走则走。

这个时候其实就变成了一个判定性问题，将在根节点下面一层的军队分配给需要封锁的子树（可以先用一个 $leafson_i$ 表示 $i$ 节点下面有多少个叶节点，然后对于每棵子树暴力搜索，如果当前点 $u$ 上有军队，那么就可以停止搜索 $u$ 这棵子树。最后判定用一个变量计算是否把所有的叶节点减完。）

但是这样一定能保证找正确所有需要封锁的子树吗？

```
10
2 1 3
2 3 4
1 4 7
5 1 9
6 1 2
4 7 9
7 8 8
9 8 8
1 10 2
5
2 8 5 4 2 
```

上面这一组 Hack 告诉我们，有可能在军队走完以后，这棵子树又会变成需要封锁的子树，因此还需要特判搜索。

接下来我们就要判定了。

首先我们要用两个 pair 数组分别表示军队到达根节点以后还可以走的时间和编号，以及从根节点走到需要封锁的子树的距离和子树的根节点编号。

先将这两个数组按照时间进行从大到小排序。

考虑用双指针 $i, j$ 来判定（$i, j$ 是上面 $2$ 个数组的下标），明显对于 $j$ 子树，可以通过 $i$ 或者原本就在这上面的 $k$ 来封锁。

这里又有一个贪心思想：如果原本就在这个点上的 $k$ 时间大小比 $i$ 可以走的时间少，那么肯定用 $k$ 会更好（又因为是从大到小进行双指针的，因此这样做一定能让 $i$ 做更大的贡献）。

这里可以用 $n$ 个 set 来存在当前点的还剩最少时间，每次取最小即可。

**注意：走完 $i$ 以后要继续判断 $j$，有可能可以通过在 $j$ 所在点的原来没有上到 $1$ 的节点封锁。**

- 时间复杂度：$O(n \log n \log w)$。

[AC 记录](https://www.luogu.com.cn/record/210528697)

如果有不懂的，可以私信询问。

---

## 作者：yaaaaaan (赞：0)

## 思路
### 1.二分
首先观察题目，军队可以同时移动，答案即是所有军队最多用的时间，要求最大值最小化，容易想到二分。

### 2.倍增实现军队快速向上跳
易证明，军队不跳一定比军队向上跳更不优，所以对于每一个军队，要**尽可能地不超时限地往上跳**（跳到根节点的子节点就暂时停住，为以后封锁其他子节点做准备）。实现快速向上跳可以使用倍增。如果一些节点跳不到根节点的子节点，直接驻扎即可。

### 3.找到需要驻扎的军队
运用 dfs 找到子树未被封锁的节点，对于每个军队，若该军队所处的节点**需要被驻扎且该军队无法到达根节点并返回**，那么不如就在此驻扎。否则保存为闲置的军队，存进 pair 数组。

### 4.找到仍需要封锁的节点
再跑一遍 dfs，找到仍然需要被封锁的节点，存进一个 pair 数组。

### 5.双指针进行匹配
将这两个 pair 数组**按照时间进行从大到小**排序。然后运用双指针匹配，如果节点都被匹配完了，则当前时间可行，否则不可行。

然后结合一下就可以 AC 了。

[AC记录](https://www.luogu.com.cn/record/213937878)

---


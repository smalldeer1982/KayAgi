# [NOI2011] 阿狸的打字机

## 题目描述

阿狸喜欢收藏各种稀奇古怪的东西，最近他淘到一台老式的打字机。打字机上只有 $28$ 个按键，分别印有 $26$ 个小写英文字母和 `B`、`P` 两个字母。经阿狸研究发现，这个打字机是这样工作的：

* 输入小写字母，打字机的一个凹槽中会加入这个字母(这个字母加在凹槽的最后)。
* 按一下印有 `B` 的按键，打字机凹槽中最后一个字母会消失。
* 按一下印有 `P` 的按键，打字机会在纸上打印出凹槽中现有的所有字母并换行，但凹槽中的字母不会消失。

例如，阿狸输入 `aPaPBbP`，纸上被打印的字符如下：

```
a
aa
ab
```

我们把纸上打印出来的字符串从 $1$ 开始顺序编号，一直到 $n$。打字机有一个非常有趣的功能，在打字机中暗藏一个带数字的小键盘，在小键盘上输入两个数 $(x,y)$（其中 $1\leq x,y\leq n$），打字机会显示第 $x$ 个打印的字符串在第 $y$ 个打印的字符串中出现了多少次。

阿狸发现了这个功能以后很兴奋，他想写个程序完成同样的功能，你能帮助他么？


## 说明/提示

### 数据范围

对于 $100\%$ 的数据，$1\leq n\leq 10^5$，$1\leq m\leq10^5$，第一行总长度 $\leq 10^5$。

|测试点|$n$ 的规模|$m$ 的规模|字符串长度|第一行长度|
|:-:|:-:|:-:|:-:|:-:|
|$1,2$|$1\leq n\leq 100$|$1\leq m\leq 10^3$| - |$\leq 100$|
|$3,4$|$1\leq n\leq 10^3$|$1\leq m\leq 10^4$|单个长度 $\leq 10^3$，总长度 $\leq 10^5$|$\leq 10^5$|
|$5\sim 7$|$1\leq n\leq 10^4$|$1\leq m\leq 10^5$|总长度 $\leq 10^5$|$\leq 10^5$|
|$8\sim 10$|$1\leq n\leq 10^5$|$1\leq m\leq 10^5$| - |$\leq 10^5$|



## 样例 #1

### 输入

```
aPaPBbP
3
1 2
1 3
2 3```

### 输出

```
2
1
0```

# 题解

## 作者：shadowice1984 (赞：158)

很好的一道题，但是入手AC自动机不要像我一样作死这道题。

不过做完这道题你对AC自动机的理解应该提升了一个层次吧

## AC自动机

一种字符串自动机，作用是，当当前字符串是字典中一个字符串的前缀时，状态节点不为空

也就是说AC自动机是多模式串的KMP

那么为了构造AC自动机，我们首先要对字典建一个trie树

然后，像KMP的next一样，我们需要构造一个数组来处理失配的情况

在一般的AC自动机板子中，我们称这个数组为fail[]，fail[i]表示，我们在AC自动机

/\*其实此时的AC自动机还是trie树\*/上的节点i失配，应该跳到AC自动机的那一个节点

这里直接给出递推方法：对整只trie树BFS

1.根节点的所有儿子的fail=root

2.对于一个一般的节点，它的fail可以这样求得，沿着父节点的fail路径不断“向上跳”，

对于“向上跳”路径中的每一个节点，如果他有一个出边类型恰好与**当前结点和当前结点的父节点的连边类型**相等，那么它的fail=这条出边**指向的节点**

那么匹配的时候像KMP利用next一样利用fail就好了

/\*当然AC自动机的真实形态是一只自动机，又称trie图，但是这道题不是trie图\*/

##本题题解

发现一个有趣的事实，对于AC自动机中的每一个节点，如果节点A的fail指向节点B

就会发现**B对应的字符串**一定在**A对应的字符串**中出现

/\*此处强烈画一只trie自己看一看\*/

利用这个性质，原题中的询问变成了

“有多少个属于Y的节点的fail指针**直接或间接**指向X的结束位置”

这里我们需要再跳越一小步

如果把fail指针理解成边，那么**原trie树的点和fail指针**形成的边，共同构成一只树

我们一般称它为fail树

现在询问变成了，在fail树中，以X结束点为根的子树中，有多少个点属于Y

可以利用dfs序，将fail树上的点映射到一个序列上

那么我们就会发现它变成了一个序列统计问题

只要钉死“属于Y的节点”这个条件我们就可以统计了

需要利用到trie树

具体来讲dfs整只trie

每d到一个点，我们就让它对应的序列点+1，回溯的时候-1；

这样做可以保证只有当前路径上的点是有值的

如果当前点是一个结束节点，那么说明每一个属于这个串的节点都已统计完毕

此时我们只需调出每一个关于这个串的询问，区间求和即可

好像可以用树状数组维护欸……

剩下的就是代码实现了，需要乱七八糟维护一堆映射

细节看代码好了

上代码~




```cpp
    #include<cstdio>
    #include<algorithm>
    #include<queue>
    #include<cstring>
    using namespace std;
    int n=1;//注意，邻接表不支持0号节点，trie树的根编号为1
    struct nod
    {int num;int typ;};
    queue <nod> q;
    struct trie//trie树
    {
        int map[100010][30];int end[100010];//记录结束点
        int word;//单词计数器
        int fa[100010];int fail[100010];int dis[100010];//father，以及end数组的反向数组
        inline int insert(int p,char c)//trie树插入
        {
            if(map[p][c-'a'+1]!=0)return map[p][c-'a'+1];
            map[p][c-'a'+1]=++n;fa[n]=p;return n;
        }
        inline int back(int p){return fa[p];}//这个是为了实现打字机的'B'键
        inline void ed(int p){end[p]=++word;dis[word]=p;}
        inline void build()//构造fail
        {
            for(int i=1;i<=26;i++)
            if(map[1][i]!=0)//第一层节点的特判
            {nod p;p.num=map[1][i];p.typ=i;fail[p.num]=1;q.push(p);}
            while(!q.empty())//bfs
            {
                nod now=q.front();q.pop();
                if(fail[now.num]!=1)//跳fail
                {
                    int trail=fail[fa[now.num]];
                    while(1)
                    {
                        if(map[trail][now.typ]!=0){trail=map[trail][now.typ];break;}
                        if(trail==1)break;trail=fail[trail];
                    }fail[now.num]=trail;
                }
                for(int i=1;i<=26;i++)
                {if(map[now.num][i]!=0)
                {nod p;p.num=map[now.num][i];p.typ=i;q.push(p);}}
            }return;
        }
    }tr;
    struct data{int v;int nxt;}edge[200010];
    int cnt;int alist[100010];
    inline void add(int u,int v)//存fail树
    {
        edge[++cnt].v=v;edge[cnt].nxt=alist[u];
        alist[u]=cnt;return;
    }
    struct node{int v;int num;};
    struct data2{node v;int nxt;}edge1[100010];
    int cnt1;int alist1[100010];
    inline void add1(int u,int v,int num)//存询问
    {
        node p;p.v=v;p.num=num;
        edge1[++cnt1].v=p;edge1[cnt1].nxt=alist1[u];
        alist1[u]=cnt1;return;
    }
    struct treearray//4行树状数组
    {
        int ta[200010];
        inline void ub(int& x){x+=x&(-x);}
        inline void db(int& x){x-=x&(-x);}
        inline void c(int x,int t){for(;x<=n;ub(x))ta[x]+=t;}
        inline int sum(int x){int res=0;for(;x>0;db(x))res+=ta[x];return res;}
    }ta;
    int dfn[100010];int size[100010];int dfu;
    bool book[100010];int ans[100010];
    void dfsfail(int x)//对fail树的dfs
    {
        dfn[x]=++dfu;
        size[x]=1;book[x]=true;
        int nxt=alist[x];
        while(nxt)
        {
            int v=edge[nxt].v;
            if(book[v]==false)
            {dfsfail(v);size[x]+=size[v];}
            nxt=edge[nxt].nxt;
        }return;
    }
    void dfstrie(int x)//对trie的dfs
    {
        ta.c(dfn[x],1);
        if(tr.end[x]!=0)
        {
            int nxt=alist1[tr.end[x]];
            while(nxt)
            {
                node v=edge1[nxt].v;int x=tr.dis[v.v];
                ans[v.num]=ta.sum(dfn[x]+size[x]-1)-ta.sum(dfn[x]-1);
                nxt=edge1[nxt].nxt;
            }
        }
        for(int i=1;i<=26;i++)
        {if(tr.map[x][i]!=0){dfstrie(tr.map[x][i]);}}
        ta.c(dfn[x],-1);return;
    }
    char mde[100010];int len;int st;int m;
    int main()
    {
        scanf("%s",mde+1);
        len=strlen(mde+1);
        for(st=1;st<=len;st++){if(mde[st]!='B'&&mde[st]!='P')break;}
        int p=tr.insert(1,mde[st]);
        for(int i=st+1;i<=len;i++)//构造trie
        {
            if(mde[i]=='B'){p=tr.back(p);}
            else if(mde[i]=='P'){tr.ed(p);}
            else p=tr.insert(p,mde[i]);
        }
        scanf("%d",&m);
        for(int i=1;i<=m;i++)//离线
        {
            int u;int v;
            scanf("%d%d",&u,&v);
            add1(v,u,i);
        }tr.build();//建AC自动机
        for(int i=2;i<=n;i++)
        {add(tr.fail[i],i);add(i,tr.fail[i]);}//建fail树
        dfsfail(1);dfstrie(1);//两边dfs
        for(int i=1;i<=m;i++)
        {printf("%d\n",ans[i]);}
        return 0;//拜拜程序~
    }

```

---

## 作者：yybyyb (赞：155)

先写个暴力：

每次打印出字符串后，就插入到$Trie$树中

搞完后直接搭$AC$自动机

看一看匹配是怎么样的：

每次沿着$AC$自动机走，在每一个节点都跳$fail$指针

如果有$x$串的末节点，就给答案$+1$

这样的话没有必要存下每个串

只要给$AC$自动机存一个父亲节点

记录一下每个串的结束位置

倒着往上跳就可以了

这样能够拿到$40$分

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<set>
#include<map>
#include<vector>
#include<queue>
using namespace std;
#define MAX 200000
inline int read()
{
    int x=0,t=1;char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
    if(ch=='-')t=-1,ch=getchar();
    while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
    return x*t;
}
char ss[MAX];
int nd[MAX],n,tot;
struct Node
{
    int vis[26];
    int fail,fa;
    int lt;
}t[MAX];
void GetFail()
{
    queue<int> Q;
    for(int i=0;i<26;++i)
        if(t[0].vis[i])Q.push(t[0].vis[i]);
    while(!Q.empty())
    {
        int u=Q.front();Q.pop();
        for(int i=0;i<26;++i)
            if(t[u].vis[i])
                t[t[u].vis[i]].fail=t[t[u].fail].vis[i],Q.push(t[u].vis[i]);
            else t[u].vis[i]=t[t[u].fail].vis[i];
    }
}
int Query(int x,int y)
{
    int ret=0;
    int now=nd[y];
    while(now)
    {
        for(int i=now;i;i=t[i].fail)
            if(t[i].lt==x){++ret;break;}
        now=t[now].fa;
    }
    return ret;
}
int main()
{
    scanf("%s",ss+1);
    int now=0;
    for(int i=1,l=strlen(ss+1);i<=l;++i)
    {
        if(ss[i]>='a'&&ss[i]<='z')
        {
            if(!t[now].vis[ss[i]-'a'])t[now].vis[ss[i]-'a']=++tot,t[tot].fa=now;
            now=t[now].vis[ss[i]-'a'];
        }
        if(ss[i]=='B')now=t[now].fa;
        if(ss[i]=='P'){nd[++n]=now;t[now].lt=n;}
    }
    int Q=read();
    GetFail();
    while(Q--)
    {
        int x=read(),y=read();
        printf("%d\n",Query(x,y));
    }
    return 0;
}

```

---

这样子对于每一个询问都会要暴跳

如果对于某个串有重复的多次询问

那么就会多很多次没有任何意义的计算

所以，可以离线把所有询问都按照$y$排序

每次跳的时候开个桶一起计算

这样的话可以拿到$70$分

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<set>
#include<map>
#include<vector>
#include<queue>
using namespace std;
#define MAX 200000
inline int read()
{
    int x=0,t=1;char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
    if(ch=='-')t=-1,ch=getchar();
    while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
    return x*t;
}
char ss[MAX];
int nd[MAX],n,tot;
int ans[MAX];
struct Node
{
    int vis[26];
    int fail,fa;
    int lt;
}t[MAX];
struct Question{int x,y,id,ans;}q[MAX];
bool operator<(Question a,Question b){return a.y<b.y;}
int sum[MAX];
void GetFail()
{
    queue<int> Q;
    for(int i=0;i<26;++i)
        if(t[0].vis[i])Q.push(t[0].vis[i]);
    while(!Q.empty())
    {
        int u=Q.front();Q.pop();
        for(int i=0;i<26;++i)
            if(t[u].vis[i])
                t[t[u].vis[i]].fail=t[t[u].fail].vis[i],Q.push(t[u].vis[i]);
            else t[u].vis[i]=t[t[u].fail].vis[i];
    }
}
int Query(int y)
{
    int ret=0;
    int now=nd[y];
    while(now)
    {
        for(int i=now;i;i=t[i].fail)
            if(t[i].lt)sum[t[i].lt]++;
        now=t[now].fa;
    }
    return ret;
}
int main()
{
    scanf("%s",ss+1);
    int now=0;
    for(int i=1,l=strlen(ss+1);i<=l;++i)
    {
        if(ss[i]>='a'&&ss[i]<='z')
        {
            if(!t[now].vis[ss[i]-'a'])t[now].vis[ss[i]-'a']=++tot,t[tot].fa=now;
            now=t[now].vis[ss[i]-'a'];
        }
        if(ss[i]=='B')now=t[now].fa;
        if(ss[i]=='P'){nd[++n]=now;t[now].lt=n;}
    }
    int Q=read();
    GetFail();
    for(int i=1;i<=Q;++i)
    {
        q[i].x=read(),q[i].y=read();
        q[i].id=i;
    }
    sort(&q[1],&q[Q+1]);
    for(int i=1,pos=1;i<=Q;i=pos)
    {
        Query(q[i].y);
        while(q[pos].y==q[i].y)q[pos].ans=sum[q[pos].x],pos++;
        memset(sum,0,sizeof(sum));
    }
    for(int i=1;i<=Q;++i)ans[q[i].id]=q[i].ans;
    for(int i=1;i<=Q;++i)
        printf("%d\n",ans[i]);
    return 0;
}

```

---

再来想想我们每次在干什么？？

跳$fail$

显然每个节点有且仅有一个$fail$指针

所以，这就是一棵树？？

把这个$fail$反过来看

现在的问题是什么？

原来是$y$的某个节点往上跳能不能到达$x$

现在反过来：

$x$往下跳能够到达几个$y$的节点

那，不就是求子树和？？？

如果把所有$y$的节点全部打上一个$1$的标记

那么，每次就变成了求$x$末节点的子树和

而一个点的子树在$dfs$序上一定是连续的一段

这样还是可以拿到$70$分

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<set>
#include<map>
#include<vector>
#include<queue>
using namespace std;
#define MAX 200000
inline int read()
{
    int x=0,t=1;char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
    if(ch=='-')t=-1,ch=getchar();
    while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
    return x*t;
}
char ss[MAX];
int nd[MAX],n,tot;
int ans[MAX];
int c[MAX];
int dfn[MAX],low[MAX],tim;
inline int lowbit(int x){return x&(-x);}
void Modify(int x,int w){while(x<=tim)c[x]+=w,x+=lowbit(x);}
int getsum(int x){int ret=0;while(x)ret+=c[x],x-=lowbit(x);return ret;}
struct Node
{
    int vis[26];
    int fail,fa;
    int lt;
}t[MAX];
struct Question{int x,y,id,ans;}q[MAX];
bool operator<(Question a,Question b){return a.y<b.y;}
void GetFail()
{
    queue<int> Q;
    for(int i=0;i<26;++i)
        if(t[0].vis[i])Q.push(t[0].vis[i]);
    while(!Q.empty())
    {
        int u=Q.front();Q.pop();
        for(int i=0;i<26;++i)
            if(t[u].vis[i])
                t[t[u].vis[i]].fail=t[t[u].fail].vis[i],Q.push(t[u].vis[i]);
            else t[u].vis[i]=t[t[u].fail].vis[i];
    }
}
struct Line{int v,next;}e[MAX<<1];
int h[MAX],cnt=1;
inline void Add(int u,int v){e[cnt]=(Line){v,h[u]};h[u]=cnt++;}
void dfs(int u)
{
    dfn[u]=++tim;
    for(int i=h[u];i;i=e[i].next)dfs(e[i].v);
    low[u]=tim;
}
int main()
{
    scanf("%s",ss+1);
    int now=0;
    for(int i=1,l=strlen(ss+1);i<=l;++i)
    {
        if(ss[i]>='a'&&ss[i]<='z')
        {
            if(!t[now].vis[ss[i]-'a'])t[now].vis[ss[i]-'a']=++tot,t[tot].fa=now;
            now=t[now].vis[ss[i]-'a'];
        }
        if(ss[i]=='B')now=t[now].fa;
        if(ss[i]=='P'){nd[++n]=now;t[now].lt=n;}
    }
    int Q=read();
    GetFail();
    for(int i=1;i<=tot;++i)Add(t[i].fail,i);
    dfs(0);
    for(int i=1;i<=Q;++i)
    {
        q[i].x=read(),q[i].y=read();
        q[i].id=i;
    }
    sort(&q[1],&q[Q+1]);
    for(int i=1,pos=1;i<=Q;i=pos)
    {
        for(int now=nd[q[i].y];now;now=t[now].fa)
            Modify(dfn[now],1);
        while(q[pos].y==q[i].y)
        {
            int v=nd[q[pos].x];
            q[pos].ans=getsum(low[v])-getsum(dfn[v]-1);
            pos++;
        }
        memset(c,0,sizeof(c));
    }
    for(int i=1;i<=Q;++i)ans[q[i].id]=q[i].ans;
    for(int i=1;i<=Q;++i)
        printf("%d\n",ans[i]);
    return 0;
}

```

---

现在大致的方向已经没有问题了

看看我们重复算在哪里？

每次把串插入进树状数组！

因为很多的串会有重复

所以会反反复复把很多东西给重复插进去

这样就很慢了


于是，我们把$Trie$树$dfs$遍历一遍

~~我搞Fail指针的时候会把原来的Trie数给搞掉，还要备份。。~~

访问到的时候打一个$+1$

结束的时候打一个$-1$

每次访问到一个结束节点的时候，

一定是有且仅有这个串的节点被打了标记

这样就可以直接回答这个串的相关询问了

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<set>
#include<map>
#include<vector>
#include<queue>
using namespace std;
#define MAX 200000
inline int read()
{
    int x=0,t=1;char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
    if(ch=='-')t=-1,ch=getchar();
    while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
    return x*t;
}
char ss[MAX];
int nd[MAX],n,tot;
int ans[MAX];
int c[MAX];
int dfn[MAX],low[MAX],tim;
int ql[MAX],qr[MAX];
inline int lowbit(int x){return x&(-x);}
void Modify(int x,int w){while(x<=tim)c[x]+=w,x+=lowbit(x);}
int getsum(int x){int ret=0;while(x)ret+=c[x],x-=lowbit(x);return ret;}
struct Node
{
    int vis[26];
    int Vis[26];
    int fail,fa;
    int lt;
}t[MAX];
struct Question{int x,y,id,ans;}q[MAX];
bool operator<(Question a,Question b){return a.y<b.y;}
void GetFail()
{
    queue<int> Q;
    for(int i=0;i<26;++i)
        if(t[0].vis[i])Q.push(t[0].vis[i]);
    while(!Q.empty())
    {
        int u=Q.front();Q.pop();
        for(int i=0;i<26;++i)
            if(t[u].vis[i])
                t[t[u].vis[i]].fail=t[t[u].fail].vis[i],Q.push(t[u].vis[i]);
            else t[u].vis[i]=t[t[u].fail].vis[i];
    }
}
struct Line{int v,next;}e[MAX<<1];
int h[MAX],cnt=1;
inline void Add(int u,int v){e[cnt]=(Line){v,h[u]};h[u]=cnt++;}
void dfs(int u)
{
    dfn[u]=++tim;
    for(int i=h[u];i;i=e[i].next)dfs(e[i].v);
    low[u]=tim;
}
void DFS(int u)
{
    Modify(dfn[u],1);
    if(t[u].lt)
        for(int i=ql[t[u].lt];i<=qr[t[u].lt];++i)
            q[i].ans=getsum(low[nd[q[i].x]])-getsum(dfn[nd[q[i].x]]-1);
    for(int i=0;i<26;++i)
        if(t[u].Vis[i])
            DFS(t[u].Vis[i]);
    Modify(dfn[u],-1);
}
int main()
{
    scanf("%s",ss+1);
    int now=0;
    for(int i=1,l=strlen(ss+1);i<=l;++i)
    {
        if(ss[i]>='a'&&ss[i]<='z')
        {
            if(!t[now].vis[ss[i]-'a'])t[now].vis[ss[i]-'a']=++tot,t[tot].fa=now;
            now=t[now].vis[ss[i]-'a'];
        }
        if(ss[i]=='B')now=t[now].fa;
        if(ss[i]=='P'){nd[++n]=now;t[now].lt=n;}
    }
    for(int i=0;i<=tot;++i)
        for(int j=0;j<26;++j)
            t[i].Vis[j]=t[i].vis[j];
    int Q=read();
    GetFail();
    for(int i=1;i<=tot;++i)Add(t[i].fail,i);
    dfs(0);
    for(int i=1;i<=Q;++i)
    {
        q[i].x=read(),q[i].y=read();
        q[i].id=i;
    }
    sort(&q[1],&q[Q+1]);
    for(int i=1,pos=1;i<=Q;i=pos)
    {
        ql[q[i].y]=i;
        while(q[pos].y==q[i].y)pos++;
        qr[q[i].y]=pos-1;
    }
    DFS(0);
    for(int i=1;i<=Q;++i)ans[q[i].id]=q[i].ans;
    for(int i=1;i<=Q;++i)
        printf("%d\n",ans[i]);
    return 0;
}

```

---

## 作者：WhiteEurya (赞：98)

打字机上只有$28$个按键，分别印有$26$个小写英文字母和'$B$'、'$P$'两个字母。经阿狸研究发现，这个打字机是这样工作的：
·输入小写字母，打字机的一个凹槽中会加入这个字母(这个字母加在凹槽的最后)。
·按一下印有'$B$'的按键，打字机凹槽中最后一个字母会消失。
·按一下印有'$P$'的按键，打字机会在纸上打印出凹槽中现有的所有字母并换行，但凹槽中的字母不会消失。
例如，阿狸输入$aPaPBbP$，纸上被打印的字符如下：
$a$ $aa$ $ab$ 我们把纸上打印出来的字符串从$1$开始顺序编号，一直到$n$。打字机有一个非常有趣的功能，在打字机中暗藏一个带数字的小键盘，在小键盘上输入两个数$(x,y)$（其中$1 \leq x,y \leq n$），打字机会显示第$x$个打印的字符串在第$y$个打印的字符串中出现了多少次。
阿狸发现了这个功能以后很兴奋，他想写个程序完成同样的功能，你能帮助他么？

<!--more-->

~~不能~~

~~这打字机比现在的还先进，哪里老式了~~

~~阿 机 的 打 字 狸~~

----------
使用画图软件： PowerPoint 2014

一道从很久以前就想AC的题目。终于做掉了来写一发题解。

首先，看到字符串，我们第一个想到的就是...如何存储！

存储字符串，最常用的是什么？

某1：Map。 某2:char

拖出去砍了。

很显然，如果这道题我们直接在线处理，使用的就是AC自动机。AC自动机依赖于Trie结构。所以我们要写个Trie树。
Trie树怎么构造？考虑：如果是"$P$"，那么这是一组询问，用数组存下。如果是"$B$"，则说明下一个加入的字符会是这个节点父亲的孩子，所以把指针指向父亲。如果是普通字符，就直接插入Trie树即可。
我们又知道，AC自动机之所以会快，是因为使用了KMP思想的Fail指针。所以如果把Fail指针以及Trie树构出，应该是长成这样的：

![1][1]

接下来是很重要的一步：
把所有除Fail指针以外的边删去。把图变成这样：
(为方便观看，整理一下从根到每个节点位置表示的字符串）

![2][2]

这样整张图就变成了一棵树。这种由Fail指针构成的树叫做 **Fail树**。
Fail树有什么用呢？
由于Fail指针指向 “这个串的最长后缀”。（参见AC自动机中对Fail指针的定义）
而指向的那个点又是某个字符串的前缀。
我们知道，后缀的前缀是什么？是子串！
为什么呢？看图：

![3][3]

蓝色框起部分是这个串的后缀。

![4][4]

红色框起部分是后缀的前缀。这不就是字符串 $S$ 中的一个子串吗？

这有什么用？用处大着呢。
我们回到题目，题目求的是第 $x$ 次打印的字符串在第 $y$ 个字符串中出现了多少次。
这个怎么求？就要利用刚才构建的 Fail 树
我们把Fail树边反向之后，利用DFS求一次DFS序。以上面那张图为例，跑完之后是这样的：

![5][5]

Dfn指DFS序，Leaf表示当前子树的最左边叶子节点。
这样有什么用呢？
比如我们要求 "$a$" 在  "$aa$" 中出现了几次，怎么求？
我们利用DFS序，$a$的DFS序记做 $d_i$，然后把 $a$ 的Leaf求出来，记做 $l_i$
很显然，$l_i$表示字符串的前缀就是 $d_i$ 表示字符串。
在加入字符 $a$ 时，把 $a_{cnt}$ 加一。
在加入字符 $aa$ 时，把 $aa_{cnt}$ 加一，同时把 $a_{cnt}$ 也加一。
这个$S_{cnt}$ 表示什么呢？表示字符串 $S$ 在这棵树上一共是多少个字符串的子串。
我们用图来描述这个过程：

![6][6]

我们先把这个问题放一放。考虑一下怎么求解。
首先对于每个询问，如果在线查询，那么复杂度是 $O(nm)$ 的，爆炸到天边。
所以考虑离线查询。不过离线和在线有啥区别？
我们处理每一组询问，把同一种询问保存在一起。
比如询问第 $1$ 个打印的字符串在第 $3$ 个出现了几次，询问第 $2$ 个打印的字符串在第 $3$ 个中出现了几次。
我们就可以把这两个询问合并，变成：第$3$个打印的字符串出现了几次第$1$个，几次第$2$个。
这样，我们就没有必要预处理字符串，而是一边读入字符串，一边处理。
如果我们读入到第$k$个 $P$，那么表示现在需要处理第 $k$ 组询问。
这个时候我们预处理的DFS序作用就来了。现在相当于整棵树被我们降维打击了一下，变成了一个序列

![6][7]

然后开始往里面加字符。我们用一个指针 $Root$ 来表示当前指向哪个节点。 
我们稍微模拟一下这个过程

![7][8]

好的，接下来问题来了。这里有一个 Deal 操作，我们要怎么解决呢？
问题的实质就是统计从根到 $l_i$ 的和减去从根到 $d_i - 1$ 的和。实际上就是统计区间 $[d_i, l_i]$ 的 $Cnt$ 和。
为什么是统计这个呢？很简单。因为叶子节点所代表的是一整个串。你只要减去这个串构成的无关的那一部分就行了。
当读入到 $B$ 时，我们把指针指向当前节点的父亲。并且把 $[1, l_{Root}]$ 的 $Cnt$ 减一。因为少了这个字符。
读入到其他字符的时候，插入树中，并把这一路 ($[1, l_{Root}]$) 的 $Cnt$ 加一。因为新加进来的字符串一定包括这一整路的全部字符。
最后一个问题。我们怎么维护上述过程？
总结一下，就是 区间加，以及区间求和。
用树状数组维护即可。 ~~当然你硬要线段树我也拦不住你~~ 

代码：

    #include <cstdio>
	#include <queue>
	#include <cstring>
	#include <vector>
	const int MaxN = 1e5 + 10;
	
	struct Trie {
	    int Vis[30], End, Fail, Fa;
	}Ac[MaxN];
	int P = 1;
	
	struct Edge {
	    int To, Next;
	}Road[MaxN];
	
	struct Query {
	    int X, Y;
	};
	int Last[MaxN], Cnt;
	
	void Add(int U, int V) {
	    Road[++Cnt] = (Edge) {V, Last[U]}, Last[U] = Cnt;
	}
	
	int Lowbit(int X) {
	    return X & (-X);
	}
	
	int Tree[MaxN];
	int N, M;
	
	void Update(int X, int K) {
	    while(X < MaxN) {
	        Tree[X] += K;
	        X += Lowbit(X);
	    }
	} 
	
	int Sum(int X) {
	    int Ans = 0;
	    while(X) {
	        Ans += Tree[X];
	        X -= Lowbit(X);
	    }
	    return Ans;
	}
	
	char Or[MaxN], A[MaxN];
	int Q[MaxN], Cur = 0, Ret = 0;
	
	void Insert(char *S, int Root) {
	    for(int i = 0; S[i]; i++) {
	        if(S[i] == 'P') Q[++Ret] = Root; 
	        else {
	            if(S[i] == 'B') Root = Ac[Root].Fa;
	            else {
	                int Now = S[i] - 'a';
	                if(!Ac[Root].Vis[Now]) Ac[Root].Vis[Now] = P, Ac[P].Fa = Root, P += 1;
	                Root = Ac[Root].Vis[Now];
	            }
	        }
	    Ac[Root].End = 1;
	    }
	}
	
	void Build() {
	    std::queue<int> Que;
	    for(int i = 0; i < 26; i++) if(Ac[0].Vis[i]) Ac[Ac[0].Vis[i]].Fail = 0, Que.push(Ac[0].Vis[i]);
	    while(!Que.empty()) {
	        int Top = Que.front(); Que.pop();
	        for(int i = 0; i < 26; i++) {
	            int Vis = Ac[Top].Vis[i];
	            if(Vis) {
	                Ac[Vis].Fail = Ac[Ac[Top].Fail].Vis[i];
	                Que.push(Ac[Top].Vis[i]);
	            }
	            else Ac[Top].Vis[i] = Ac[Ac[Top].Fail].Vis[i];
	        }
	    }
	}
	
	int Dfn[MaxN], Time = 0, R[MaxN];
	
	void Dfs(int Now) {
	    Dfn[Now] = ++Time;
	    for(int i = Last[Now]; i; i = Road[i].Next) {
	        int To = Road[i].To;
	        Dfs(To);
	    }
	    R[Now] = Time;
	}
	
	int Tot[MaxN];
	int Ans[MaxN];
	
	int main() {
	    scanf("%s", Or);
	    Insert(Or, 0); Build();
	    std::vector <Query> Ask[MaxN];
	    for(int i = 1; i < P; i++) Add(Ac[i].Fail, i);
	    Dfs(0); int Root = 0; scanf("%d", &N);
	    for(int i = 0; i < N; i++) {
	        int X, Y; scanf("%d%d", &X, &Y);
	        Ask[Y].push_back((Query) {X, i});
	    }
	    Update(Dfn[0], 1);
	    Ret = 0; 
	    for(int i = 0; Or[i]; i++) {
	        if(Or[i] == 'P') {
	            Ret += 1;
	            for(int j = 0; j < Ask[Ret].size(); j++) {
	                int X = Q[Ask[Ret][j].X];
	                Ans[Ask[Ret][j].Y] = Sum(R[X]) - Sum(Dfn[X] - 1);
	            }
	        }
	        else if(Or[i] == 'B') Update(Dfn[Root], -1), Root = Ac[Root].Fa;
	        else Root = Ac[Root].Vis[Or[i] - 'a'], Update(Dfn[Root], 1);
	     }
	    for(int i = 0; i < N; i++) printf("%d\n", Ans[i]);
	} 

附录：

1.[洛谷 P2414 阿狸的打字机][9]

2.[AC自动机 —— Trie树与KMP思想][10]


3.:[在我的blog上面查看这篇文章](http://xiaoyao24256.com/index.php/archives/189/)

  [1]: https://i.loli.net/2018/07/16/5b4c311e1b99c.png
  [2]: https://i.loli.net/2018/07/16/5b4c3169b3943.png
  [3]: https://i.loli.net/2018/07/16/5b4c3377bf296.png
  [4]: https://i.loli.net/2018/07/16/5b4c33b7068b8.png
  [5]: https://i.loli.net/2018/07/16/5b4c3c7b6b077.png
  [6]: https://i.loli.net/2018/07/16/5b4c54ba3abcf.png
  [7]: https://i.loli.net/2018/07/16/5b4c4a5388fda.png
  [8]: https://i.loli.net/2018/07/16/5b4c4c71ccb25.png
  [9]: https://www.luogu.org/problemnew/show/P2414
  [10]: http://xiaoyao24256.com/index.php/archives/48/

---

## 作者：C20203030 (赞：44)

## 一、题目
[电磁看题](https://www.luogu.com.cn/problem/P2414)
## 二、解法
我们先对输入的字符串建出$AC$自动机，自动机的点数是$O(n)$的，建法如下:

- 遇到小写字母，跳自动机上的边，看是否需要新建点。

- 遇到``P``，存下字符串对应在自动机上的点编号。

- 遇到``B``，向当前点的父亲上跳。

考虑$x$串在$y$串的出现次数，具体过程就是在自动机上跳到$y$，路径上的每一个点都去跳$fail$，跳到$x$对应点的次数即为出现次数。还有另一种理解方法，如果我们建出$fail$树，把$y$路径上的所有点在树上打标记，我们要做的就是查询$x$为根的子树内有多少个被打上标记的点。

可以离线询问，这样就方便了打标记和撤回标记，至于查询子树，我们可以用``dfn+树状数组``实现。我们逐个访问第一行字符串中的字符：
- 遇到小写字符，向下跳（$trie$树），打标记（树状数组单点修改）。

- 遇到``P``，回答离线下来的问题（树状数组区间查询）。

- 遇到``B``，向父亲跳（$trie$树），删除标记。

时间复杂度$O(n\log n)$，详见代码，自认为写的比较好看qwq。


```cpp
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;
const int M = 100005;
int read()
{
 int x=0,flag=1;char c;
 while((c=getchar())<'0' || c>'9') if(c=='-') flag=-1;
 while(c>='0' && c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
 return x*flag;
}
int n,a[M],tot,f[M],c[M][26],val[M],fail[M],fa[M],cnt;
int m,len,Index,dfn[M],out[M],bit[M],ans[M];
char s[M];
struct edge
{
    int v,next;
    edge(int V=0,int N=0) : v(V) , next(N) {}
}e[2*M];
struct node
{
    int x,id;
    node(int X=0,int I=0) : x(X) , id(I) {}
};vector<node> g[M];
void link(int u,int v)
{
    e[++tot]=edge(v,f[u]),f[u]=tot;
    e[++tot]=edge(u,f[v]),f[v]=tot;
}
void ins()
{
    scanf("%s",s);
    len=strlen(s);
    for(int i=0,now=0;i<len;i++)
    {
        if(s[i]>='a' && s[i]<='z')
        {
            int v=s[i]-'a';
            if(!c[now][v]) c[now][v]=++cnt,fa[cnt]=now;
            now=cnt;
        }
        if(s[i]=='P')
            a[++n]=now;
        if(s[i]=='B')
            now=fa[now];
    }
}
void dfs(int u,int p)
{
    dfn[u]=++Index;
    for(int i=f[u];i;i=e[i].next)
    {
        int v=e[i].v;
        if(v^p) dfs(v,u);
    }
    out[u]=Index;
}
void build()
{
    queue<int> q;
    for(int i=0;i<26;i++) if(c[0][i]) q.push(c[0][i]);
    while(!q.empty())
    {
        int t=q.front();
        q.pop();
        for(int i=0;i<26;i++)
            if(c[t][i]) fail[c[t][i]]=c[fail[t]][i],q.push(c[t][i]);
            else c[t][i]=c[fail[t]][i];
    }
    for(int i=1;i<=cnt;i++)
        link(i,fail[i]);
    dfs(0,0);
}
int lowbit(int x)
{
    return x&(-x);
}
void change(int x,int y)
{
    for(;x<=Index;x+=lowbit(x))
        bit[x]+=y;
}
int ask(int x)
{
    int sum=0;
    for(;x>0;x-=lowbit(x)) sum+=bit[x];
    return sum;
}
int main()
{
    ins();
    build();
    m=read();
    for(int i=1;i<=m;i++)
    {
        int x=read(),y=read();
        g[y].push_back(node(x,i));
    }
    for(int i=0,now=0,j=0;i<len;i++)
    {
        if(s[i]=='P')
        {
            j++;
            for(int k=0;k<g[j].size();k++)
            {
                int x=g[j][k].x,id=g[j][k].id;
                ans[id]=ask(out[a[x]])-ask(dfn[a[x]]-1);
            }
        }
        if(s[i]=='B')
        {
            change(dfn[now],-1);
            now=fa[now];
        }
        if(s[i]>='a' && s[i]<='z')
        {
            now=c[now][s[i]-'a'];
            change(dfn[now],1);
        }
    }
    for(int i=1;i<=m;i++)
        printf("%d\n",ans[i]);
}

```



---

## 作者：jiangly (赞：27)

## 新人第一篇题解
题意：给出若干个字符串，每次询问一个串在另一个串的出现次数。

首先明白： 子串 = 前缀的后缀

又由于：**Trie树（AC自动机）的祖先节点 = 前缀**

**Fail树的祖先节点 = 后缀**

x在y中的出现次数即 在Fail树中有节点x作为祖先的Trie树中y的祖先的数量

即 **Fail树中x的子树与Trie树中y到根节点的路径的公共节点数**

由 **子树** 容易想到利用 **dfs序** 转化为区间，用树状数组维护

下面是一些细节

1. 输入的问题： 因为只有在末尾插入和删除，用 **栈** 储存当前节点，模拟即可。

2. 查询的问题： **离线化** ，把所有询问储存在y上，在 **Trie树** 上 **dfs+回溯** 即可。

**代码如下：（丑，压了行更丑，241ms）**
```c++
#include<cstdio>
#include<cstring>
#include<vector>
#define maxn 100005
#define lowbit(x) ((x)&-(x))
using namespace std;
int N,M,tot=1,front,back,top,cnt,dfn;
int q[maxn],fail[maxn],st[maxn]={1},t[maxn][26],head[maxn],nxt[maxn],e[maxn],L[maxn],R[maxn],ans[maxn],w[maxn];
char a[maxn];
vector<pair<int,int> >query[maxn];
inline void dfs(int x){
	L[x]=++dfn;
	for(register int i=head[x];i;i=nxt[i]) dfs(i);
	R[x]=dfn;
}
inline void add(int x,int y){
	while(x<=tot) w[x]+=y,x+=lowbit(x);
}
inline int sum(int x){
	int res=0;
	while(x) res+=w[x],x-=lowbit(x);
	return res;
}
inline void solve(int x){
	add(L[x],1);
	for(register unsigned int i=0;i<query[x].size();++i) ans[query[x][i].first]=sum(R[query[x][i].second])-sum(L[query[x][i].second]-1);
	for(register int i=0;i<26;++i) if(t[x][i]) solve(t[x][i]);
	add(L[x],-1);
}
int main(){
	scanf("%s",a+1),N=strlen(a+1);
	for(register int i=1;i<=N;++i){
		switch(a[i]){
			case 'B':--top;break;
			case 'P':e[++cnt]=st[top];break;
			default:if(!t[st[top]][a[i]-'a']) t[st[top]][a[i]-'a']=++tot;++top,st[top]=t[st[top-1]][a[i]-'a'];break;
		}
	}
	for(register int i=0;i<26;++i) if(t[1][i]) q[back++]=t[1][i],fail[t[1][i]]=1,nxt[t[1][i]]=head[1],head[1]=t[1][i];
	for(register int x,y;front<back;){
		x=q[front++];
		for(register int i=0;i<26;++i) if(t[x][i]){
			for(y=fail[x];y;y=fail[y]) if(t[y][i]){y=t[y][i];break;}
			y=y?y:1,fail[t[x][i]]=y,nxt[t[x][i]]=head[y],head[y]=t[x][i],q[back++]=t[x][i];
		}
	}
	dfs(1),scanf("%d",&M);
	for(register int i=1,x,y;i<=M;++i) scanf("%d%d",&x,&y),query[e[y]].push_back(make_pair(i,e[x]));
	solve(1);
	for(register int i=1;i<=M;++i) printf("%d\n",ans[i]);
	return 0;
}
```

---

## 作者：Refun (赞：25)

#### 题解Rank1好像连续两个P就会被hack……

~~我不会说我因为离线处理完后没有重新排序询问WA了1h~~

~~我也不会说我在对拍调试的时候hack了3篇题解~~

恩看大家这个题都清一色的树状数组……可是我用的线段树

~~但是因为我不会写树状数组~~

~~而且可能我常数小我的线段树跑的并不是很慢~~

进入正题

一步一步分析

# step1

对于给定的字符串，如何建立trie树呢？

这个很简单，和普通AC自动机的插入单词操作差不多

如果当前要处理的是一个小写字母，就往当前节点的儿子走

如果当前是P，意味着从根到当前节点组成了一个单词，记录下这个单词的位置

如果当前是B，那么就往当前节点的父亲走。(毕竟末尾的一个字母删掉了)

# step2

建立好trie树顺带把trie树补成trie图且连好fail后，我们考虑暴力

如何判断单词x是否是y的子串呢？

根据AC自动机和fail的定义，我们很容易知道两个结论：

1.trie树上一个节点的祖先节点所代表的单词，肯定是当前所代表的单词的前缀

2.一个节点的fail指针指向的肯定是当前节点所代表的单词的最长后缀

而且子串可以理解为前缀的后缀。

暴力的话就从根到y遍历所有点，对于每个点，我们往上暴跳fail，如果遇到x单词的结尾就ans+1



------------

当然这样分肯定不多就是了……

考虑逆向思维，我们建立一颗fail树。(不知道是啥的先去百度)

那么我们原本是要考虑所有属于y单词的节点有哪些能够暴跳fail指针到x单词结尾 

现在就变成了考虑fail树中y单词的节点有哪些在x的子树中了。

还是不是很好搞对么……？那就离线

询问按照y进行排序，然后按照建立trie树的过程重新遍历一遍trie树

这样我们经历单词的顺序肯定是第一个，第二个……第sum个单词

每往下走一步，我们就给到的节点的权值加一

每往上跳一步，我们就给离开的节点的权值减一

当我们跳到第i个单词的时候，就处理询问里y=i的所有情况

就是查询一下fail树中x的子树权值和

这个DFS序+线段树就很好搞了 

代码不贴了有点长(其实是想安利一下博客)

[Blog](http://www.cnblogs.com/refun/p/8697626.html)


---

## 作者：KokiNiwa (赞：14)

# [NOI2011]阿狸的打字机（AC自动机，Fail树，离线，树状数组）

写题解前先放阿狸！
![](https://cdn.luogu.com.cn/upload/image_hosting/lwntsudk.png)

## 题目叙述

给你若干个字符串（输入方式奇特），求一个字符串在另一个字符串中出现了几次。

## 题解

+ 首先构建`Trie`（如果题目不按这种方式输入的话，那么输入就会过多。。。

+ 对于这个`Trie`建立`AC`自动机。利用`Fail`树的性质，一个字符串的后缀中有另一个字符串等价于在`Fail`树中，一个节点的子树中有另一个节点（在`Fail`树中）。也就是看一个点在`Trie`中到根节点的路径上有多少个属于那个点的`Fail`树。

+ 也就相当于给一个节点到根节点的路径上都打上标记，看子树权值和。为了不多次打标记，考虑利用相邻两次打标记公共的部分，发现这是一个类似于虚树的东东，每次撤销一部分标记，再新增一部分。所以可以先按`dfs`序排序，然后打标记、撤标记即可。
+ 但是发现并不需要这样，可以发现本质`dfs`，把这棵树`dfs`一遍，到一个点可以处理出这个点到根节点打标记的情况。把关于这个点的所有询问都记下来，子树询问即可。具体使用树状数组。

## 代码

+ 弄清楚是谁在谁的子树里查询！

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>
#include <vector>
#define lowbit(x) ((x)&(-(x)))
using namespace std;
const int maxLen = 1e5 + 5, maxQue = 1e5 + 5;
int len, nbQue, tot, wordId, dfstime, ch[maxLen][26], fa[maxLen], wordPos[maxLen], fail[maxLen];
int in[maxLen], out[maxLen], ans[maxLen], cpy[maxLen][26];
char str[maxLen];
queue<int> Q;
vector<int> tree[maxLen], ask[maxLen];
struct Query {
	int mo, wenBen;
} que[maxQue];
struct Fenwick {
	int sum[maxLen];
	void Add(int pos, int val) {
		for (; pos <= tot; pos += lowbit(pos))
			sum[pos] += val;
	}
	int Pre(int pos) {
		int ret = 0;
		for (; pos; pos -= lowbit(pos)) ret += sum[pos];
		return ret;
	}
	int Query(int lEP, int rEP) {
		return Pre(rEP) - Pre(lEP - 1);
	}
} sum;
void Bfs() {
	fail[1] = 1;
	for (int son = 0; son < 26; ++son) {
		if (ch[1][son]) {
			Q.push(ch[1][son]);
			fail[ch[1][son]] = 1;
		} else
			ch[1][son] = 1;
	}
	while (!Q.empty()) {
		int now = Q.front();
		Q.pop();
		for (int son = 0; son < 26; ++son) {
			if (ch[now][son]) {
				Q.push(ch[now][son]);
				fail[ch[now][son]] = ch[fail[now]][son];
			} else
				ch[now][son] = ch[fail[now]][son];
		}
	}
}
void Dfs(int now) {
	in[now] = ++dfstime;
	for (auto to : tree[now])
		Dfs(to);
	out[now] = dfstime;
}
void Solve(int now) {
	sum.Add(in[now], 1);
	for (auto id : ask[now])
		ans[id] = sum.Query(in[wordPos[que[id].mo]], out[wordPos[que[id].mo]]);
	for (int son = 0; son < 26; ++son)
		if (cpy[now][son])
			Solve(cpy[now][son]);
	sum.Add(in[now], -1);
}
int main() {
	scanf("%s%d", str + 1, &nbQue);
	tot = 1;
	len = strlen(str + 1);
	int now = 1;
	for (int pos = 1; pos <= len; ++pos) {
		if ('a' <= str[pos] && str[pos] <= 'z') {
			if (!ch[now][str[pos] - 'a']) {
				ch[now][str[pos] - 'a'] = ++tot;
				fa[tot] = now;
			}
			now = ch[now][str[pos] - 'a'];
		} else if (str[pos] == 'P') wordPos[++wordId] = now;
		else now = fa[now];
	}
	memcpy(cpy, ch, sizeof(ch));
	Bfs();
	for (int i = 2; i <= tot; ++i) tree[fail[i]].push_back(i);
	Dfs(1);
	for (int i = 1; i <= nbQue; ++i) {
		scanf("%d%d", &que[i].mo, &que[i].wenBen);
		ask[wordPos[que[i].wenBen]].push_back(i);
	}
	Solve(1);
	for (int i = 1; i <= nbQue; ++i) printf("%d\n", ans[i]);
	return 0;
}
```

## 知识点

+ 记录这种离线的处理方法（比如需要一个点到根节点都打上标记，那么就可以把询问挂在点上，遍历整棵树，遍历到一个节点时回答询问）。
+ 记住这种`Fail`树的用法。

---

## 作者：Orion545 (赞：13)

# 广告

[蒟蒻のblog](http://www.cnblogs.com/dedicatus545/p/8907400.html)

# 正文

### 最暴力的

最暴力的方法：把所有询问代表的字符串跑一遍kmp然后输出

稍微优化一下:把所有询问保存起来，把模板串相同的合并，求出next然后匹配

但是这两种方法本质没有区别，都是暴力

### 不那么暴力的

我们对于所有的串建立一个AC自动机，把询问按照$y$排序，然后在AC自动机上面跑，每次跳fail更新答案

这样可以拿到70分，但是时间上限还是会$O\left(n^2\right)$左右

### 巧妙的优化

这道题里面，所有的模板串和文本串都在AC自动机里

那么，题目中实际是在要求什么呢？

就是有多少个x串是y串的一个前缀的后缀

那么，在AC自动机**自己身上**有没有满足这样的检索的结构呢？

有的，那就是fail指针

trie上的某一个前缀的fail指针，指向的是作为它的最长后缀的那个节点；同时，从某个前缀开始一路沿着fail指针跳，直到根节点，过程中所有的节点代表的前缀都是这个前缀的后缀

也就是说，我们把fail指针看成树边，将这个“fail树”（不要和kmp的next树搞混了）提取出来，那么我们就可以把题目的询问变成这样：

把代表y串的所有前缀的节点打上标记，那么代表x串的节点的子树中的标记个数，就是这个询问的答案

维护个数和可以用fail树上的dfs序以及树状数组共同完成

### 正解

上述过程中有一个重复的地方：每次我们都需要把树状数组归零，然后重新把新的y串前缀节点插进去——即使我们使用把y排序的方法也会TLE

但是这个过程中有一个问题：有些点会进进出出好多遍，并不高效，我们需要找到一个办法，使得每个AC自动机上的点只进出树状数组一次

那么谁能满足这个要求呢？

还是dfs序，只不过是原trie树上的dfs序

我们把输入的询问按照y串在trie树上的dfs序排序，依次加入、删除

因为按照dfs序遍历可以使每个点进入一次离开一次，所以这个方法的总时间效率只有$O\left(nlogn\right)$

这样这道题就做完了

# Code

本题的映射非常多，而且很繁复，有很多重复意义的东西，调试的时候一定要小心

变量名有点乱，还请见谅
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
#define rank deep_dark_fantasy
using namespace std;
struct node{
    int fail,fa,son[26];
    vector<int>num;
    node(){fail=fa=0;memset(son,0,sizeof(son));num.clear();}
}a[100010];int cnt,tot;
int dfn[100010],clk,end[100010],tmplca,pre[100010],rank[100010];
//dfn是trie树dfs序，rank是dfn的反映射
//end是每个字符串在trie树上的节点编号
//pre表示由dfs序为i的串向dfs序为i+1的串转移时的lca，tmplca是维护这个的辅助变量
struct edge{
    int to,next;
}e[100010];int cnte,first[100010];
inline void addedge(int u,int v){
    e[++cnte]=(edge){v,first[u]};first[u]=cnte;
}
inline void add(char s[]){
    int len=strlen(s),cur=0,i;
    for(i=0;i<len;i++){
        if(s[i]=='P'){a[cur].num.push_back(++tot);continue;}
        if(s[i]=='B'){cur=a[cur].fa;continue;}
        if(!a[cur].son[s[i]-'a']) a[cur].son[s[i]-'a']=++cnt;
        a[a[cur].son[s[i]-'a']].fa=cur;cur=a[cur].son[s[i]-'a'];
    }
}
void getdfn(int u){
    int i,v,len=a[u].num.size();
    for(i=0;i<len;i++){
        dfn[++clk]=a[u].num[i];
        rank[a[u].num[i]]=clk;
        end[a[u].num[i]]=u;
        pre[clk]=tmplca;tmplca=u;
    }
    for(i=0;i<26;i++){
        v=a[u].son[i];if(!v) continue;
        getdfn(v);tmplca=u;
    }
}
int q[100010];
void getfail(){
    int head=0,tail=0,i,u,v;
    for(i=0;i<26;i++){
        if(!a[0].son[i]) continue;
        a[a[0].son[i]].fail=0;q[tail++]=a[0].son[i];
    }
    while(head<tail){
        u=q[head++];
        for(i=0;i<26;i++){
            v=a[u].son[i];
            if(v) a[v].fail=a[a[u].fail].son[i],q[tail++]=v;
            else a[u].son[i]=a[a[u].fail].son[i];
        }
    }
    memset(first,-1,sizeof(first));
    for(i=1;i<=cnt;i++) addedge(a[i].fail,i);
}
char s[100010];int Q;
struct query{
    int x,y,num,ans;
}qq[100010];
bool cmp(query l,query r){return rank[l.y]<rank[r.y];}
bool cmp2(query l,query r){return l.num<r.num;}
int now=0,tmpnow;
struct tree{//树状数组
    int x[100010];
    tree(){memset(x,0,sizeof(x));}
    int lowbit(int pos){return pos&(-pos);}
    void change(int pos,int type){
        for(int i=pos;i<=cnt+1;i+=lowbit(i)) x[i]+=type;
    }
    int ask(int pos){
        int re=0;
        for(int i=pos;i>0;i-=lowbit(i)) re+=x[i];
        return re;
    }
}T;
int faildfn[100010],failclk=0,le[100010],ri[100010];
//faildfn是fail树上的dfs序，le和ri是某个节点在树状数组上的左右区间
void get_fail_dfn(int u){
    int i,v;faildfn[u]=++failclk;le[u]=failclk;
    for(i=first[u];~i;i=e[i].next){
        v=e[i].to;
        get_fail_dfn(v);
    }
    ri[u]=failclk;
}
int main(){
    scanf("%s",s);int i,j,x,y,xx;
    add(s);getdfn(0);
    getfail();get_fail_dfn(0);
    
    scanf("%d",&Q);
    for(i=1;i<=Q;i++) scanf("%d%d",&qq[i].x,&qq[i].y),qq[i].num=i;
    sort(qq+1,qq+Q+1,cmp);//排序
    
    j=1;
    for(i=1;i<=tot;i++){
        y=dfn[i];tmpnow=end[y];
        while(now!=pre[i]){
            T.change(faildfn[now],-1);now=a[now].fa;
        }
        while(tmpnow!=now){
            T.change(faildfn[tmpnow],1);tmpnow=a[tmpnow].fa;
        }//插入、删除节点
        now=end[y];
        while(qq[j].y==y){//处理询问
            xx=end[qq[j].x];
            qq[j].ans=T.ask(ri[xx])-T.ask(le[xx]-1);
            j++;
        }
    }
    
    sort(qq+1,qq+Q+1,cmp2);
    for(i=1;i<=Q;i++) printf("%d\n",qq[i].ans);
}
```


---

## 作者：Weng_Weijie (赞：8)

难道没有人写在线的吗？

这里提供一个在线做法(基于可持久化线段树)。

首先原问题可以转换成:

在trie树上从根到y的链上所有点，在fail树上x的子树里有几个

~~不会的可以去看其他题解~~

由于子树里的dfs序是连续的，相当于每次询问维护一个数组:

1.trie树上根到y的所有点 **dfs序** 位置+1  
2.查询一个区间的和

用可持久化线段树维护

Root[x] 表示执行了根到x的所有操作后的线段树。

Root[x] 只要在父亲的基础上多一个自己的操作即可。

这样就可以在线了。

代码：
```cpp
#include <iostream>
#include <queue>
const int N = 100005;
int pos[N], head[N], tot;
struct edge { int to, nxt; } e[N];
void addedge(int x, int y) {
	e[++tot] = (edge) { y, head[x] }; head[x] = tot;
}
namespace ac {
	int nxt[N][26], trans[N][26], fail[N], back[N], idx, word;
	void build_ac(std::string modify) {
		int p = 1; back[1] = 1; fail[1] = 1; idx = 1;
		for (std::string::iterator it = modify.begin(); it != modify.end(); ++it) {
			if (*it == 'B') {
				p = back[p];
			} else if (*it == 'P') {
				pos[++word] = p;
			} else {
				if (!nxt[p][*it - 97])
					nxt[p][*it - 97] = ++idx, back[idx] = p;
				p = nxt[p][*it - 97];
			}
		}
		std::queue<int> q;
		for (int i = 0; i < 26; i++)
			if (nxt[1][i]) {
				trans[1][i] = nxt[1][i];
				fail[nxt[1][i]] = 1;
				q.push(nxt[1][i]);
			} else
				trans[1][i] = 1;
		while (q.size()) {
			int tmp = q.front(); q.pop();
			addedge(fail[tmp], tmp);
			for (int i = 0; i < 26; i++)
				if (nxt[tmp][i]) {
					trans[tmp][i] = nxt[tmp][i];
					fail[nxt[tmp][i]] = trans[fail[tmp]][i];
					q.push(nxt[tmp][i]);
				} else
					trans[tmp][i] = trans[fail[tmp]][i];
		}
	}
}
int in[N], out[N], stamp;
void dfs0(int x) {
	in[x] = ++stamp;
	for (int i = head[x]; i; i = e[i].nxt)
		dfs0(e[i].to);
	out[x] = stamp;
}
const int LN = 50;
int root[N], lc[N * LN], rc[N * LN], sum[N * LN], idx;
int insert(int rt, int pos, int l = 1, int r = stamp) {
	int now = ++idx;
	sum[now] = sum[rt] + 1, lc[now] = lc[rt], rc[now] = rc[rt];
	if (l == r) return now;
	int mid = l + r >> 1;
	if (pos <= mid)
		lc[now] = insert(lc[rt], pos, l, mid);
	else
		rc[now] = insert(rc[rt], pos, mid + 1, r);
	return now;
}
int query(int rt, int L, int R, int l = 1, int r = stamp) {
	if (L <= l && R >= r) return sum[rt];
	int mid = l + r >> 1, res = 0;
	if (L <= mid)
		res += query(lc[rt], L, R, l, mid);
	if (R > mid)
		res += query(rc[rt], L, R, mid + 1, r);
	return res;
}
void dfs1(int x) {
	root[x] = insert(root[ac::back[x]], in[x]);
	for (int i = 0; i < 26; i++)
		if (ac::nxt[x][i])
			dfs1(ac::nxt[x][i]);
}
int q;
std::string tree;
int main() {
	std::cin >> tree >> q;
	ac::build_ac(tree);
	dfs0(1), dfs1(1);
	for (int i = 1; i <= q; i++) {
		int x, y;
		std::cin >> x >> y;
		std::cout << query(root[pos[y]], in[pos[x]], out[pos[x]]) << std::endl;
	}
	return 0;
}
```

---

## 作者：Prean (赞：5)

~~难不成是我后缀自动机学魔怔了，AC 自动机都能套上线段树~~

题意：给你一颗 Trie，每次询问两个节点 $ u,v $，$ u $ 代表的字符串在 $ v $ 代表的字符串中出现了多少次。

让我们思考一下字符串在 AC 自动机 上是如何匹配的：

1. 跳儿子节点
2. 对于每个儿子节点跳 fail，若跳到匹配串就令 ans++

差不多就是标记一个节点 $ u $，然后询问是否有若干个节点在该节点的子树内。

于是，当 $ x $ 相同时，就可以标记 $ x $ 的每一个前缀后，在 fail 树上做一个子树和。查询的时候直接查询子树和就好了。

$ x $ 不定的时候用线段树来维护就好啦。

不过重要的一点是：如何维护一个节点是哪些字符串的前缀。

我们发现，每次 $ B $ 跳 father 的时候，经过这个节点的字符串是连续的一段。相当于使用线段树区间修改。所以标记一下就好啦。

需要注意一点是线段树要标记永久化。

code:
```cpp
#include<cstring>
#include<cstdio>
#include<queue>
typedef unsigned uint;
const uint M=1e5+5;
uint n,m,cnt,tot,len,fa[M],pos[M],lst[M],fail[M],root[M],chi[M][26];char s[M];
uint L,R,q[M];
struct Node{
	uint L,R,tag;
}t[M*50];
inline uint min(const uint&a,const uint&b){
	return a-b>>31?a:b;
}
inline uint max(const uint&a,const uint&b){
	return a-b>>31?b:a;
}
void Modify(uint&u,const uint&l,const uint&r,const uint&L=1,const uint&R=len){
	if(l>R||L>r)return;if(!u)u=++cnt;
	if(l<=L&&R<=r)return void(t[u].tag=1);
	uint mid=L+R>>1;
	Modify(t[u].L,l,r,L,mid);Modify(t[u].R,l,r,mid+1,R);
}
uint Query(const uint&u,const uint&x,const uint&L=1,const uint&R=len){
	if(!u)return 0;if(L==R)return t[u].tag;
	uint mid=L+R>>1;
	if(x<=mid)return Query(t[u].L,x,L,mid)+t[u].tag;
	else return Query(t[u].R,x,mid+1,R)+t[u].tag;
}
uint Merge(const uint&q,const uint&p){
	if(!q||!p)return q|p;
	uint u=++cnt;
	t[u].L=Merge(t[q].L,t[p].L);
	t[u].R=Merge(t[q].R,t[p].R);
	t[u].tag=t[q].tag+t[p].tag;
	return u;
}
inline void Build(){
	uint i,u,c;L=1;
	for(c=0;c^26;++c)if(chi[1][c])fail[q[++R]=chi[1][c]]=1;
	while(L<=R){
		if(!fail[u=q[L++]])fail[u]=1;
		for(c=0;c^26;++c){
			if(chi[u][c])fail[q[++R]=chi[u][c]]=chi[fail[u]][c];
			else chi[u][c]=chi[fail[u]][c];
		}
	}
}
inline void init(){
	uint i,u=++tot,now=1;n=strlen(s);
	for(i=0;i<n;++i){
		if(s[i]=='B')u=fa[u];
		else if(s[i]=='P')++len;
		else{
			if(!chi[u][s[i]-97])fa[chi[u][s[i]-97]=++tot]=u;
			u=chi[u][s[i]-97];
		}
	}
	u=1;Build();
	for(i=0;i<n;++i){
		if(s[i]=='B')lst[u]^now?Modify(root[u],lst[u],now-1):void(),u=fa[u];
		else if(s[i]=='P')pos[now++]=u;
		else lst[u=chi[u][s[i]-97]]=now;
	}
	while(u^1)lst[u]^now?Modify(root[u],lst[u],now-1):void(),u=fa[u];
	do root[fail[q[R]]]=Merge(root[fail[q[R]]],root[q[R]]);while(--R);
}
signed main(){
	uint x,y;scanf("%s%u",s,&m);init();
	while(m--)scanf("%u%u",&x,&y),printf("%u\n",Query(root[pos[x]],y));
}
```

---

## 作者：Taduro (赞：5)

首先模拟题目描述建出AC自动机，B就是回到父亲，P就是代表一个串结束。

考虑如果没有时间限制，怎么判断x在y中的出现次数，大家一定做过洛谷AC自动机的加强版模板。

回忆一下，那题除了暴力跳fail之外，还有一个做法：

```
每个点有且只有一个fail指针，而根不算fail指针，将fail指向的点看成自己的爸爸，这样就形成了一棵fail树。

我们暴力统计的时候，每到达一个点是一个单词的末尾，就给这个单词出现次数+1，同时给这个点到根的所有是单词末尾的点都+1。

这样我们只要打好标记，结束后求一遍每个点的子树和，就可以知道他被打了多少次标记了。
```

~~选自[多弗桃的题解](https://dftyem.github.io/2019/02/14/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/)。~~

这样我们就有了一个暴力，把y相同的询问一起处理，做一遍dfs，设第一行的长度是n，这是一个O(nm/?)的做法，？是询问中y去重后的个数。

考虑优化，单点修改求子树和可以用树状数组维护dfs序解决，但是你每个y都要打一遍标记还是o(n)的。

不慌，每个y串都是有联系的，他们经过前一个串被插入或删除得到，而插入删除的次数是o(n)的。

相当于我们可以在o(n)的时间内遍历所有串，且他们是按1~n的顺序出现的，当一个串出现的时候，我们可以把关于他所有的询问在logn的时间内解决，因此我们要对每个插入删除操作维护当前串的标记，查询时对每个x的末端求子树和。

~~最后一段确实没想到~~

这题给人启发的是fail树和正常树是一样的，意味着只要你明白在fail树上各个操作的意义，你就可以搞出fail树剖分、fail树dp之类的题来。

```c++
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
struct qusch{
	int x,y,h;
}a[100001];
struct node{
	int next,to;
}w[100001];
struct trie{
	int ch[26],fa,fail;
}t[100001];
int ans[100001],n,m,now,num,size[100001],idx[100001];
int head[100001],cnt,heap,tail,team[100001],c[100001];
int pos[100001];
char ch[100001];
inline int lowbit(int x){return x&(-x);}
inline void update(int x,int y){while (x<=now){c[x]+=y;x+=lowbit(x);}}
inline int query(int x){int y=0;while (x){y+=c[x];x-=lowbit(x);}return y;}
inline bool cmp(qusch c,qusch d){return c.y<d.y;}
inline void add(int x,int y){
	w[++cnt].next=head[x];
	w[cnt].to=y; head[x]=cnt;
}
void insert(){
	int l=strlen(ch),u=0;
	for (int i=0; i<l; i++){
		if (ch[i]=='B'){u=t[u].fa;continue;}
		if (ch[i]=='P'){pos[++n]=u; continue;}
		int b=ch[i]-'a';
		if (!t[u].ch[b]) t[u].ch[b]=++num;
		t[t[u].ch[b]].fa=u; u=t[u].ch[b];
	}
}
void build(){
	heap=tail=1;
	while (heap<=tail){
		int x=team[heap];
		for (int i=0; i<26; i++){
			if (t[x].ch[i]){
				team[++tail]=t[x].ch[i];
				if (!x) continue;
				t[t[x].ch[i]].fail=t[t[x].fail].ch[i];
			}
			else t[x].ch[i]=t[t[x].fail].ch[i];
		}
		heap++;
	}
}
void dfs(int x){
	idx[x]=++now; size[x]=1;
	for (int i=head[x]; i; i=w[i].next){
		dfs(w[i].to);
		size[x]+=size[w[i].to];
	}
}
int main(){
	scanf("%s",ch);
	insert(); build();
	for (int i=1; i<=num; i++)
		if (t[i].fail!=i) add(t[i].fail,i);
	scanf("%d",&m);
	for (int i=1; i<=m; i++){
		scanf("%d%d",&a[i].x,&a[i].y);
		a[i].h=i;
	}
	sort(a+1,a+m+1,cmp);
	dfs(0); int l=strlen(ch),u=0,k=1,e=0;
	for (int i=0; i<l; i++){
		if (ch[i]=='B'){
			update(idx[u],-1); u=t[u].fa;
			continue;
		}
		if (ch[i]=='P'){
			e++;
			for (int j=k; a[j].y==e; j++){
				int p=pos[a[j].x];
				ans[a[j].h]=query(idx[p]+size[p]-1)-query(idx[p]-1);
				k++;
			}
			continue;
		}
		int b=ch[i]-'a';
		u=t[u].ch[b]; update(idx[u],1);
	}
	for (int i=1; i<=m; i++) printf("%d\n",ans[i]);
	return 0;
}
```



---

## 作者：hongzy (赞：4)

**题意**

有一个打字机，支持三种操作：

- 字符串末尾加一个小写字母
- 字符串末尾删一个字符
- 输出这个字符串

经过不超过$n$次操作后有$m$组询问：$(x,y)$，表示询问第$x$次输出第字符串在第$y$次输出第字符串里出现几次

$n,m \leq 10^5$

**题解**

每次加减字符就在trie树上走，输出的话记录一下在哪个结点

然后考虑询问$(x,y)$暴力怎么做：$x$应该是$y$一个前缀的后缀，于是我们对于从根到$y$路径上每个结点（这相当于枚举$y$的后缀），从这个结点跳$fail$，如果跳到$x$就$ans++$，然后考虑下一个结点

实际上我们要求的就是根到$y$这条链上的结点中，在$fail$树中是$x$儿子的个数

我们可以按$\text{trie}$树的$\text{dfs}$序枚举$y$，这样枚举所有的链和信息是$O(n)$的，每个点只会被加入一次和删除一次。然后考虑回答所有$(i,y)$的询问，直接询问当前在$x$的$fail$树子树的结点个数。可以使用树状数组维护。具体说就是把询问按$y$在$trie$上的$\text{dfs}$序排序，然后每个点必须插入到它$fail$树$\text{dfs}$序的位置，查询就找到$x$的$fail$子树的$\text{dfs}$区间进行查询。

实现的话注意$trie$和$fail$不要搞混了，另外这题也可以用主席树在线做qwq

```cpp
#include <algorithm>
#include <cstdio>
#include <vector>
using namespace std;

const int N = 2e5 + 10;

int ch[N][26], fa[N], fail[N];
int dfn[N], dl[N], dr[N], dn[N];
int pos = 1, id = 1, n, pt[N], ans[N];
vector<int> fs[N];

struct qs {
    int x, y, id;
    bool operator < (const qs &b) const {
        return dfn[y] < dfn[b.y];
    }
} q[N];

void work(char c) {
    if(c == 'B') pos = fa[pos];
    else if(c == 'P') pt[++ pt[0]] = pos;
    else {
        int &v = ch[pos][c - 'a'];
        if(!v) {
            v = ++ id;
            fa[v] = pos;
        }
        pos = v;
    }
}

void dfs(int u) { //on trie
    dfn[u] = ++ dfn[0]; dn[dfn[0]] = u;
    for(int i = 0; i < 26; i ++)
        if(ch[u][i]) dfs(ch[u][i]);
}

void buildac() {
    static int q[N], l, r, v;
    for(int i = 0; i < 26; i ++) if(v = ch[1][i]) {
        q[r ++] = v; fail[v] = 1;
    } else ch[1][i] = 1;
    while(l < r) {
        int u = q[l ++];
        for(int i = 0; i < 26; i ++) if(v = ch[u][i]) {
            q[r ++] = v; fail[v] = ch[fail[u]][i];
        } else ch[u][i] = ch[fail[u]][i];
    }
    for(int i = 2; i <= id; i ++)
        fs[fail[i]].push_back(i);
}

void dfs2(int u) { //on fail tree
    dl[u] = ++ dl[0];
    for(int i = 0; i < fs[u].size(); i ++) dfs2(fs[u][i]);
    dr[u] = dl[0];
}

int bit[N];

void add(int x, int y) {
    for(; x <= id; x += x & (-x)) bit[x] += y;
}

int qry(int x) {
    int ans = 0;
    for(; x >= 1; x &= x - 1) ans += bit[x];
    return ans;
}

int main() {
    static char s[N]; scanf("%s", s);
    for(char *c = s; *c; c ++) work(*c);
    dfs(1); buildac(); dfs2(1);
    scanf("%d", &n);
    for(int i = 1; i <= n; i ++) {
        scanf("%d%d", &q[i].x, &q[i].y);
        q[i].x = pt[q[i].x];
        q[i].y = pt[q[i].y]; //id -> node
        q[i].id = i;
    }
    sort(q + 1, q + n + 1);
    for(int i = 1, j = 1; i <= id; i ++) {
        int u = dn[i];
        if(i > 1) {
            int la = dn[i - 1];
            while(la != fa[u]) {
                add(dl[la], -1);
                la = fa[la];
            }
        }
        add(dl[u], 1);
        for(; j <= n && dfn[q[j].y] == i; j ++) {
            ans[q[j].id] = qry(dr[q[j].x]) - qry(dl[q[j].x] - 1);
        }
    }
    for(int i = 1; i <= n; i ++)
        printf("%d\n", ans[i]);
    return 0;
}

```





---

## 作者：封禁用户 (赞：2)

此题正解：
ac自动机（不是自动AC机）求出fail数组，然后以fail数组建树，如图：
![](https://cdn.luogu.com.cn/upload/pic/39675.png)
红色的边和各点形成了另一棵树.

那么（看红树），若一个点在某个字符串结束节点的子树内，那么该字符串则出现在那个点所在的字符串里；如图中的a-b-c字符串和c字符串。

现在，我们若要求x字符串在y内出现了几次，就只需求以x的结束节点为根的子树内，有多少个节点是y字符串上的。
如何做呢？

将询问离线，y相同询问的弄在一起；

 

然后求出红树的dfs序（有点诡异，看代码）；

 

我们再遍历一遍输入的字符串：

对于输入的‘a’-‘z’，把对应的dfs序中其出现的位置的值加1，用树状数组维护；

对于输入的‘B’，现在的字符所对应的dfs序中的位置的值减1；

对于遇到的c个‘P’，我们不难发现，现在的树状树状维护的便是第c个字符串的每一个字符在dfs序中的位置的值所加1后的结果。接着便可用区间查询求出y==c的询问的答案。

那么上~~又臭又长的~~代码：
```
#include<cstdio>
#include<cstring>
#include<queue>
#include<algorithm>
#include<iostream>
using namespace std;
struct node{
    int x,y;
} q[100005];
struct edge{
    int to,next;
}e[200005];
int ch[100005][27];
int val[100005],fail[100005],fa[100005],fini[100005],l[100005],r[100005],ans[100005];
int head[100005],headq[100005],nxt[100005],lat[100005],c[150000];
char x[100005];
int cnt,pnt,ent=1,dnt,lx;
int idx(char x) {return x-'a';}
void modify(int u,int d) {for(int i=u;i<=dnt;i+=i&(-i)) c[i]+=d;}
int query(int u) {int sum=0;for(int i=u;i;i-=i&(-i)) sum+=c[i]; return sum;}
void add(int u,int v)
{
    e[ent]=(edge){v,head[u]};head[u]=ent++;
    e[ent]=(edge){u,head[v]};head[v]=ent++;
}
void read_trie()
{
    int u=0;
    for(int i=1;i<=lx;i++)
    {
        if(x[i]=='B') u=fa[u];
        else if(x[i]=='P') val[u]=++pnt,fini[pnt]=u;
        else
        {
            int c=idx(x[i]);
            if(!ch[u][c]) ch[u][c]=++cnt,fa[ch[u][c]]=u;
            u=ch[u][c];
        }
    }
}
void get_fail()
{
    queue<int> q;
    for(int c=0;c<26;c++) {int u=ch[0][c]; if(u) q.push(u);}
    while(!q.empty())
    {
        int r=q.front(); q.pop();
        for(int c=0;c<26;c++)
        {
            if(!ch[r][c]) continue;
            int u=ch[r][c];
            q.push(u);
            int v=fail[r];
            while(v&&!ch[v][c]) v=fail[v];
            fail[u]=ch[v][c];
        }
    }
}
//----------------------------------------------------------------------
void dfs_xu(int u,int fa)
{
    l[u]=++dnt;
    for(int i=head[u];i;i=e[i].next) if(e[i].to!=fa) dfs_xu(e[i].to,u);
    r[u]=dnt;
}
void work()
{
    int m; scanf("%d",&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&q[i].x,&q[i].y); 
        nxt[i]=lat[q[i].y];
        lat[q[i].y]=i;
    }
    for(int i=1;i<=cnt;i++) add(i,fail[i]);
    dfs_xu(0,0);
    int p=0,id=0;
    for(int i=1;i<=lx;i++)
    {
        if (x[i]=='P')
        {
            id++;
            for (int j=lat[id];j;j=nxt[j])
            { 
                int u=fini[q[j].x]; 
                ans[j]=query(r[u])-query(l[u]-1); 
            } 
        } 
        else if (x[i]=='B') modify(l[p],-1),p=fa[p]; 
        else p=ch[p][idx(x[i])],modify(l[p],1); 
    }
    for(int i=1;i<=m;i++) printf("%d\n",ans[i]);
}
int main()
{
    scanf("%s",x+1);
    lx=strlen(x+1);
    read_trie();
    get_fail();
    work();
    return 0;
}
```

---

## 作者：maomao9173 (赞：2)

### 代码啊实现啊其他$dalao$们都讲的很清楚了，我来从感性的层面讲讲我对这个题目的理解吧$QwQ$~,希望能对大家有所帮助。

- 我们做的询问，是问$x$串在$y$串中出现的次数。

- 很显然，大力遍历当然可以出结果。那么怎么用$AC$自动机优化我们的遍历方式？

- $Trie$树上：
	- 对于一个点$u$，它与根节点对应的链代表了串$u$的所有前缀。

- $Fail$树上：
	- 对于一个点$u$，它的子节点对应了所有能用后缀将其包含的串$v$。

#### 又是前缀又是后缀的，如果我们把它们一起用上会怎么样？比如——

- 我们认为串$x$是串$y$一个前缀的后缀。

	- 有多少这样的前缀是符合要求的呢？

#### 现在我们来脑补一个$Venn$图，其中一个集合是串$y$的所有前缀串，另一个集合是所有后缀包含串$x$的字串。

#### 先处理第一个集合。我们似乎可以遍历一下$Trie$树，当前点到根节点的链上所有节点，就是这个集合啦~

#### 第二个集合啊，不是正好挂在$Fail$树的当前点下面嘛？要取走还不容易，直接一棵子树砍走就完事了。

#### 仔细一想，欸？？是不是可以直接取一个交集？

#### 那么思路就变得清楚起来。我们每次在$Trie$树的当前点上取一条到根节点的链，对链上所有点$+1$。然后在$Fail$树的当前点上求一个子树和，问题就迎刃而解啦~

#### 这里我只是简单的总结一下思路。写法有很多，我的写法是记录一下$Fail$树的$dfs$序，然后按$dfs$序塞进树状数组理维护。

#### $Trie$树和$Fail$树一些节点映射略有繁琐，写的时候记得谨慎一点哦$QwQ$

---

## 作者：Dispwnl (赞：1)


这题好妙啊……

首先搞这道题得先搞懂$AC$自动机是什么东西

首先这题$40$分暴力做法是$kmp$直接匹配

我们考虑同样作为字符串匹配算法的$AC$自动机

可以发现$fail$指针有一个神奇的性质：

如果一个字符串$a$的最后一位的$fail$指向字符串$b$的一个字符，那么$a$肯定包含$b$

所以原问题就可以转化为统计$x$最后一位在$fail$树里的子树里有多少$y$的字符

树结构+子树求和，想到了什么？

dfs序+线段树就可以搞了~~树状数组也可以~~

所以按照原来的$Tire$树向下找，顺便在dfs序上标记

将询问离线，按$y$值排序

遍历字符串

然后对于每一个```'P'```，因为这是打印，统计当前结尾对应的$y$所对应的询问，里面的$x$的子树和

对于每一个```'B'```，因为这是删除，所以讲当前节点的$dfs$序对应的值$-1$，并返回到ta的父节点

对于其他，对应的$dfs$序$+1$

然后就离线输出就行了

代码：
```
# include<iostream>
# include<cstring>
# include<cstdio>
# include<queue>
# include<algorithm>
# define mid (l+r>>1)
# define tl (k<<1)
# define tr (k<<1|1)
using namespace std;
const int MAX=1e5+1;
struct p{
	int x,y;
}c[MAX];
struct q{
	int x,y,id;
	bool operator< (const q &a)
	const{
		return y<a.y;
	}
}qu[MAX];
int num,n,L,TOT,cnt,sum;
int h[MAX],ov[MAX],ans[MAX];
string a;
void add(int x,int y)
{
	c[++num]=(p){h[x],y},h[x]=num;
}
struct Tire{
	int fail[MAX],fa[MAX],die[MAX],id[MAX],siz[MAX];
	int vis[MAX][26],use[MAX][26];
	struct o{
		int x;
	}s[MAX<<2];
	void build()
	{
		int x=0;
		for(int i=0;i<L;++i)
		  {
		  	if(a[i]=='B')
		  	x=fa[x];
		  	else if(a[i]=='P')
		  	ov[++cnt]=x;
		  	else
		  	{
		  		if(!vis[x][a[i]-'a'])
				use[x][a[i]-'a']=vis[x][a[i]-'a']=++TOT,fa[TOT]=x;
				x=vis[x][a[i]-'a'];
			}
		  }
	}
	void GET_FAIL()
	{
		queue<int> qu;
		for(int i=0;i<26;i++)
		  {
		  	int v=vis[0][i];
		  	if(v) qu.push(v);
		  }
		while(!qu.empty())
		{
			int tt=qu.front();
			qu.pop();
			for(int i=0;i<26;i++)
			  {
			  	int v=vis[tt][i];
			  	if(v)
				{
					fail[v]=vis[fail[tt]][i];
					qu.push(v);
				} 
			  	else vis[tt][i]=vis[fail[tt]][i];
			  }
		}
	}
	void dfs(int x)
	{
		id[x]=++sum,siz[x]=1;
		for(int i=h[x];i;i=c[i].x)
		  {
		  	int y=c[i].y;
		  	if(y==x) continue;
		  	dfs(y);
		  	siz[x]+=siz[y];
		  }
	}
	void pus(int k)
	{
		s[k].x=s[tl].x+s[tr].x;
	}
	int ask(int l,int r,int k,int L,int R)
	{
		if(l==L&&r==R) return s[k].x;
		if(R<=mid) return ask(l,mid,tl,L,R);
		if(L>mid) return ask(mid+1,r,tr,L,R);
		return ask(l,mid,tl,L,mid)+ask(mid+1,r,tr,mid+1,R);
	}
	void change(int l,int r,int k,int x,int dis)
	{
		if(l==r)
		{
			s[k].x+=dis;
			return;
		}
		if(x<=mid) change(l,mid,tl,x,dis);
		else change(mid+1,r,tr,x,dis);
		pus(k);
	}
	void GET_ANS()
	{
		int tot=1,tot1=0;
		int x=0;
		for(int i=0;i<L;++i)
		  {
		  	if(a[i]=='P')
		  	{
		  		tot1++;
		  		while(qu[tot].y==tot1)
		  		{
		  			int xe=qu[tot].x;
		  			ans[qu[tot].id]=ask(1,sum,1,id[ov[xe]],id[ov[xe]]+siz[ov[xe]]-1);
		  			++tot;
				}
			}
			else if(a[i]=='B')
			change(1,sum,1,id[x],-1),x=fa[x];
			else
			x=use[x][a[i]-'a'],change(1,sum,1,id[x],1);
		  }
	}
}Tree;
int read()
{
	int x=0;
	char ch=getchar();
	for(;!isdigit(ch);ch=getchar());
	for(;isdigit(ch);x=x*10+ch-48,ch=getchar());
	return x;
}
int main()
{
	cin>>a;
	L=a.length();
	Tree.build();
	n=read();
	for(int i=1;i<=n;++i)
	  qu[i].x=read(),qu[i].y=read(),qu[i].id=i;
	sort(qu+1,qu+1+n);
	Tree.GET_FAIL();
	for(int i=0;i<=TOT;++i)
	  add(Tree.fail[i],i);
	Tree.dfs(0);
	Tree.GET_ANS();
	for(int i=1;i<=n;++i)
	  printf("%d\n",ans[i]);
	return 0;
}
```


---

## 作者：Xiaojian_xiang (赞：1)

为楼下的犇犇补充一下！

首先呢大致做法和楼下犇犇是一样的但是还有一个小细节需要注意不然就是各种MLE&TLE……

就是当前呢我们不能把这些串给提取出来再进行tire构建的insert操作。而是应该用在线算法搞一发……如果读到一个P就把当前的位置保存一下后面搞离线算法的时候可以调用……这代表我插入了一个串了……如果读到一个B……就利用fa数组中保存的父亲节点回去……读到小写字母就往下一层……但是并不新建一个串……

然后在处理的时候为了防止冗余的计算==搞了个链表存了y一样的询问……直接调用就可以了ww

就因为这些小细节没有注意一直MLE&TLE三个点……调一年……

上代码：








```cpp
#include<iostream>
#include<string>
#include<queue>
#include<cstring>
#include<algorithm>
#include<cstdio>
using namespace std;
const int MAXN=100010;
int n;
string doo;
struct acm{
    int fail;
    int nex[26];
}qwq[MAXN];
int tot(1);
int head[MAXN],ne[MAXN],to[MAXN],top1;
int pos[MAXN],fa[MAXN],top;
int xx[MAXN],hea[MAXN],nn[MAXN],ans[MAXN];
void add(int x,int y){
    ne[top1]=head[x];head[x]=top1;to[top1++]=y;
}
int id(char c){return (int)c-(int)'a';}
int l[MAXN],r[MAXN],con;
int tree[MAXN];
void change(int x,int k){
    for(int i=x;i<=tot;i+=(i&-i))
        tree[i]+=k;
}
int query(int x){
    int ans(0);
    for(int i=x;i>0;i-=(i&-i))
        ans+=tree[i];
    return ans;
}
void init(){
    memset(head,-1,sizeof(head));
    for(int i=0;i<MAXN;++i)
        qwq[i].fail=-1;
}
void build(){
    queue<int> q;
    for(int i=0;i<26;i++){
        if(!(qwq[0].nex[i])) continue;
        qwq[qwq[0].nex[i]].fail=0;
        add(0,qwq[0].nex[i]);
        q.push(qwq[0].nex[i]);
    }
    while(!q.empty()){
        int tmp=q.front();q.pop();
        for(int i=0;i<26;i++){
            if(!(qwq[tmp].nex[i])) continue;
            int p=qwq[tmp].fail;
            while(p&&!(qwq[p].nex[i]))
                p=qwq[p].fail;
            if(!(qwq[p].nex[i])) {add(0,qwq[tmp].nex[i]);qwq[qwq[tmp].nex[i]].fail=0;}
            else {add(qwq[p].nex[i],qwq[tmp].nex[i]);qwq[qwq[tmp].nex[i]].fail=qwq[p].nex[i];}
            q.push(qwq[tmp].nex[i]);
        }    
    }
}
void dfs(int here){
    l[here]=con++;
    for(int i=head[here];i!=-1;i=ne[i]) dfs(to[i]);
    r[here]=con-1;
}
void input(){
    cin>>doo;
    int now(0);
    for(int i=0;i<doo.size();i++){
        if(doo[i]=='P') pos[top++]=now;
        else if(doo[i]=='B') now=fa[now];
        else if(doo[i]!='P'&&doo[i]!='B'){
            if(!qwq[now].nex[id(doo[i])]){
                qwq[now].nex[id(doo[i])]=tot++;
                fa[tot-1]=now;
            }
            now=tot-1;
        }
    }
    init();
    build();
    dfs(0);
}
void xxj(){
    memset(hea,-1,sizeof(hea));
    cin>>n;
    for(int i=0;i<n;i++){
        int x,y;
        scanf("%d%d",&x,&y);
        --x;--y;
        xx[i]=x;
        nn[i]=hea[y];
        hea[y]=i;
    }
    int ii(0);
    int now(0);
    for(int i=0;i<doo.size();i++){
        if(doo[i]=='P'){
            for(int j=hea[ii];j!=-1;j=nn[j]) ans[j]=query(r[pos[xx[j]]])-query(l[pos[xx[j]]]-1);
            ii++;
        }
        if(doo[i]=='B'){
            change(l[now],-1);
            now=fa[now];
        }
        if(doo[i]>='a'&&doo[i]<='z'){
            now=qwq[now].nex[id(doo[i])];
            change(l[now],1);
        }
    }
}
void output(){
    for(int i=0;i<n;i++)
        printf("%d\n",ans[i]);
}
int main(){
    input();
    xxj();
    output();
    return 0;    
}
```

---

## 作者：doge233 (赞：1)

直接KMP据说是40分

直接AC自动机据说70分

满分做法

树状数组优化AC自动机


```cpp
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
using namespace std;
const int maxn=200010;
vector<int> qry[maxn],son[maxn];
char s[maxn];
```
int trans[maxn][30],fail[maxn],fa[maxn],que[maxn],
L[maxn],R[maxn],sum[maxn],qx[maxn],ans[maxn],

pos[maxn],

```cpp
n,q,tot,num,clo;
void dfs(int u)
{
    L[u]=++clo;
    vector<int>::iterator it;
    for (it=son[u].begin();it!=son[u].end();it++) dfs(*it);
    R[u]=clo;
}
int query(int p)
{
    int ret=0;
    for (;p;p-=p&-p) ret+=sum[p];
    return ret;
}
void add(int p,int x)
{
    for (;p<=clo;p+=p&-p) sum[p]+=x;
}
int main()
{
    //freopen("in","r",stdin);
    int p=0,hd=1,tl=0,u,v;
    vector<int>::iterator it;
    scanf("%s",s+1);
    n=strlen(s+1);
    for (int i=1;i<=n;i++)
        if (s[i]=='P') pos[++num]=p;
        else if (s[i]=='B') p=fa[p];
        else
        {
            if (!trans[p][s[i]-'a']) fa[trans[p][s[i]-'a']=++tot]=p;
            p=trans[p][s[i]-'a'];
        }
    for (int i=0;i<26;i++)
        if (trans[0][i]) que[++tl]=trans[0][i];
    while (hd<=tl)
    {
        u=que[hd++];
        for (int i=0;i<26;i++)
            if (trans[u][i])
            {
                que[++tl]=trans[u][i];
                fail[trans[u][i]]=trans[fail[u]][i];
            }
            else trans[u][i]=trans[fail[u]][i];
    }
    for (int i=1;i<=tot;i++) son[fail[i]].push_back(i);
    scanf("%d",&q);
    for (int i=1;i<=q;i++)
    {
        scanf("%d%d",&u,&v);
        qx[i]=pos[u];
        qry[pos[v]].push_back(i);
    }
    dfs(0);
    p=0;
    for (int i=1;i<=n;i++)
        if (s[i]=='P')
            for (it=qry[p].begin();it!=qry[p].end();it++) ans[*it]=query(R[qx[*it]])-query(L[qx[*it]]-1);
        else if (s[i]=='B')
        {
            add(L[p],-1);
            p=fa[p];
        }
        else
        {
            p=trans[p][s[i]-'a'];
            add(L[p],1);
        }
    for (int i=1;i<=q;i++) printf("%d\n",ans[i]);
```
return 0；
}

---

## 作者：Sai0511 (赞：0)

$\text{AC}$自动机经典题。  
把字符串加进来的时候如果当前字符是小写字母$\text{c}$，就让当前所在的位置$\text{u}$往$\text{c}$这个位置走。如果当前字符是$\text{B}$的话就让$\text{u}$成为其$\text{Trie}$树上的父亲（相当于扔掉了最后一个字符）。是$\text{P}$的话就对$\text{u}$打个标记，表示现在这个点是一个串的结尾。      

接着考虑如何暴力。
我们知道，一个子串相当于是**一个前缀的后缀**，一个点$\text{u}$的$\text{fail}$指针相当于**指向了$\text{u}$的最大后缀所在的点**，一个点$\text{u}$在$\text{Trie}$树上的祖先所代表的串相当于**点$\text{u}$所代表的串的前缀。**  
很显然了，每次把点$\text{u}$沿着$\text{Trie}$树往上跳，然后一直跳$\text{fail}$，如果现在跳到的点是查询的串在$\text{Trie}$树所代表的节点，那就把$\text{ans}++$。  
大概可以拿$40 \sim 50$分。  
要拿满分还需要别的方法。   
我们考虑建这样一颗的树：以原先$\text{Trie}$树上的节点为节点，把所有的$\text{fail}$指针反向，看成一条边。因为每个点只有一个$\text{fail}$指针，所以建出来的一定是一棵树，我们把这棵树叫做$\text{fail}$树。  
接着我们发现了一个神奇的性质，那就是以点$\text{u}$为根的这颗子树里的所有点在$\text{Trie}$树上代表的串一定是点$\text{u}$在$\text{Trie}$树上代表的串的后缀（因为是跳了若干次$\text{fail}$跳过来的）。    
所以对于询问$(x,y)$我们把点$\text{y}$在$\text{Trie}$树的祖先全部标记为$\text{1}$，然后用树状数组查询一下以$\text{x}$为根的子树和就好了。   
直接暴力做的话还是太慢，能拿个$\text{70}$分，还需要一个小$\text{trick}$。   
那就是$\text{dfs}$一遍原来的$\text{Trie}$树，然后加进一个点时把这个点的权值设成$\text{1}$，回溯时把这个点的权值设成$0$（这样到达的任意一个点时树上为$1$的点一定只有它的祖先），然后批处理一下询问，这题就做完了。      
放一下写的很丑的代码。   
```cpp
#include <bits/stdc++.h>

const int N = 2e5 + 10;
int n, m, i, j, k, u, tot, cnt;
int ch[N][26], fail[N], fa[N], ans[N];   
int _ch[N][26], id[N];
int fir[N], nxt[N], to[N];
int dfn[N], bit[N], R[N]; 
struct node {
  int x, i;
  node() { x = i = 0; }
  node(int _x, int _i) { x = _x, i = _i; }
};
std::vector<node> ask[N];  
std::vector<int> ed[N];
char str[N];
inline void get_fail() {
  std::queue<int> q; 
  for (int i = 0; i < 26; i++)
    if (ch[0][i]) q.push(ch[0][i]);
  while (!q.empty()) {
    int u = q.front(); q.pop();
    for (int i = 0; i < 26; i++) {
      if (ch[u][i]) fail[ch[u][i]] = ch[fail[u]][i], q.push(ch[u][i]);
      else ch[u][i] = ch[fail[u]][i];
    }
  }
}
int tim = 0;
inline void addedge(int u, int v) {
  static int cnte = 0;
  to[++cnte] = v, nxt[cnte] = fir[u], fir[u] = cnte;
}
inline void add(int i, int v) {
  for (; i <= tim; i += i & -i) bit[i] += v;
}
inline int sum(int i) {
  int res = 0;
  for (; i; i -= i & -i) res += bit[i];
  return res;
}
void dfs1(int u) {
  dfn[u] = ++tim;
  for (int i = fir[u]; i; i = nxt[i]) dfs1(to[i]);
  R[u] = tim;
}
void dfs2(int u) {
  add(dfn[u], 1);
  if (ed[u].size()) { 
    for (int j = 0, Siz = ed[u].size(); j < Siz; j++) {
      for (int i = 0, siz = ask[ed[u][j]].size(); i < siz; i++) {
        int I = ask[ed[u][j]][i].i, x = ask[ed[u][j]][i].x;
        ans[I] = sum(R[id[x]]) - sum(dfn[id[x]] - 1);
      }
    }
  }
  for (int i = 0; i < 26; i++)
    if (_ch[u][i]) dfs2(_ch[u][i]);
  add(dfn[u], -1);
}

int main() {
  scanf("%s", str + 1);
  for (int i = 1, len = strlen(str + 1); i <= len; i++) {
    char c = str[i]; 
    if (c >= 'a' && c <= 'z') {
      c -= 'a';
      if (!ch[u][c]) ch[u][c] = ++tot, fa[tot] = u;
      u = ch[u][c];
    } else if (c == 'B') u = fa[u];
    else id[++cnt] = u, ed[u].push_back(cnt);
  }
  for (int i = 0; i <= tot; i++)
    for (int j = 0; j < 26; j++)
      _ch[i][j] = ch[i][j];
  get_fail();
  for (int i = 1; i <= tot; i++) addedge(fail[i], i);
  scanf("%d", &m);
  for (int i = 1, x, y; i <= m; i++) {
    scanf("%d %d", &x, &y);
    ask[y].push_back(node(x, i));
  }
  dfs1(0);
  dfs2(0);
  for (int i = 1; i <= m; i++) printf("%d\n", ans[i]);
  return 0;
}

```

---

## 作者：南方不败 (赞：0)

## 知识点：
AC自动机，fail树，离线，树状数组，主席树

## 题意：
给定若干个串，若干次询问(x,y)x串在y串中出现了多少次，除了值域（小写字母）外范围都是1e5.

## 解法：
首先，按照它给定的“打字机读入方式”，我们可以在trie上跳，模拟这一个过程。遇到小写字母，则往下跳（没有就插入新点），遇到$B$就跳回其父亲处（所以trie还要维护每个点父亲点的编号），遇到$P$就标记一下结尾的节点（假如原来有点，那么就把当前串的fa定为原来的那个串，否则新增一个编号）。假如不按上面这种方法来的话，复杂度上界是$O(n^2)$的。

接下来，考虑单个的(x,y)怎么匹配。注意题目问的是x在y中出现了多少次，我们要明确几个性质。
* 一个ACAM上的节点到根节点上的路径，每一个路径上的点都是当前点的前缀。这个用trie来理解就非常显然了。
* 一个fail树上的节点到根节点上的路径，每一个路径上的点都是当前点的后缀，且一定是长度依次单调递减的一个后缀。

这里补充一下什么就做fail树，fail树就是把fail指针反向连接起来形成的一棵树，具有很多很优美的性质。

那么我们通过以上两个性质，我们可以发现，问x在y中出现的次数，就是问x在fail树的子树中有多少个点是y节点在fail树中所对应节点的祖先（包括y自己）。

所以我们考虑怎么维护上面的那个信息。

假如在线做，那么每次遍历一次fail树，是$O(n^2)$的，所以我们必须把所有询问离线下来，因为是问y作为文本串的，所以可以选择把y排序处理。不过这里我选择开个vector直接把y对应的fa（就是在插入时，相同的话就记的那个fa）对应的ACAM上的编号挂上去，把x也同样处理后挂上去。

考虑把fail树的DFS序弄出来（因为以某个节点为根的子树一定是在DFS序上连续的一段），所以可以转化为序列上的问题用树状数组等数据结构来维护。因为每次进入走出某个节点发生的影响都是1，所以DFS一遍trie树（注意这里要在求fail之前把所有的son备份一遍，否则会连到一些原来没有的点上），一到一个点就把当前点在fail树上的DFS序所对应的点在树状数组上+1，然后回答当前点的所有询问（均为x点的子树右端点-x点的子树左端点对于的值），然后遍历所有的真儿子，然后-1走人。

## 注意：
1. 搞清楚什么时候是fail，什么时候是trie。这里理解子串个人认为可以类比SAM，因为一个子串=后缀的前缀=前缀的后缀，所以是遍历trie树，但是树状数组维护的DFS序是在fail树上的。
2. 假如你在想，为什么不是加上一个地方的所有的子串结尾的个数，而是+1？是因为题目问的是x在y中出现的次数，就算出现很多次，那也只算一次。

## 代码：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#include<vector>
using namespace std;

const int maxn=100010;
int n,m,head[maxn],etot,tot=1,c[maxn],dfn[maxn],low[maxn],fa[maxn],cnt,ans[maxn],id[maxn];
struct node
{
	int nxt,to;
}edge[maxn];
struct trie
{
	int son[26],fail,tag,fa,ch[26];
}a[maxn];
struct pro
{
	int x,id;
};
vector<pro>que[maxn];
queue<int>q;
char s[maxn];

int read()
{
	int x=0;
	char c=getchar();
	while (c<48||c>57)
		c=getchar();
	while (c>=48&&c<=57)
		x=(x<<1)+(x<<3)+(c^48),c=getchar();
	return x;
}

void insert(char *s)
{
	int i,u=1,len=strlen(s),k;
	a[1].fa=1;
	for (i=0;i<len;i++)
	{
		if (s[i]>='a'&&s[i]<='z')
		{
			k=s[i]-'a';
			if (!a[u].son[k])
			{
				a[u].son[k]=(++tot);
				a[tot].fa=u;
			}
			u=a[u].son[k];
		}
		if (s[i]=='B')
			u=a[u].fa;
		if (s[i]=='P')
		{
			id[++n]=u;
			fa[n]=n;
			if (a[u].tag)
				fa[n]=a[u].tag;
			else
				a[u].tag=n;
		}
	}
}

void getfail()
{
	int i,u,v,fafail;
	for (i=0;i<=25;i++)
		a[0].son[i]=1;
	a[1].fail=0;
	q.push(1);
	while (!q.empty())
	{
		u=q.front();
		q.pop();
		fafail=a[u].fail;
		for (i=0;i<=25;i++)
		{
			v=a[u].son[i];
			if (!v)
				a[u].son[i]=a[fafail].son[i];
			else
			{
				a[v].fail=a[fafail].son[i];
				q.push(v);
			}
		}
	}
}

void add(int u,int v)
{
	edge[++etot]=(node){head[u],v};
	head[u]=etot;
}

int lowbit(int x)
{
	return x&-x;
}

void update(int x,int val)
{
	for (;x<=cnt;x+=lowbit(x))
		c[x]+=val;	
}

int query(int x)
{
	int res=0;
	for (;x;x-=lowbit(x))
		res+=c[x];
	return res;
}

void DFS(int u)
{
	int i;
	dfn[u]=(++cnt);
	for (i=head[u];i;i=edge[i].nxt)
		DFS(edge[i].to);
	low[u]=cnt;
}

void dfs(int u)
{
	update(dfn[u],1);
	int i,siz=que[u].size();
	for (i=0;i<siz;i++)
		ans[que[u][i].id]=query(low[que[u][i].x])-query(dfn[que[u][i].x]-1);
	for (i=0;i<=25;i++)
		if (a[u].ch[i])
			dfs(a[u].ch[i]);
	update(dfn[u],-1);
}

int main()
{
	int i,j,u,v;
	scanf("%s",s);
	insert(s);
	for (i=1;i<=tot;i++)
		for (j=0;j<=25;j++)
			a[i].ch[j]=a[i].son[j];
	getfail();
	for (i=1;i<=tot;i++)
		if (a[i].fail!=i&&a[i].fail>=1)
			add(a[i].fail,i);
	DFS(1);
	m=read();
	for (i=1;i<=m;i++)
	{
		u=id[fa[read()]],v=id[fa[read()]];
		que[v].push_back((pro){u,i});
	}
	dfs(1);
	for (i=1;i<=m;i++)
		printf("%d\n",ans[i]);
	return 0;
}
```

---

## 作者：hehelego (赞：0)

[题目在这里qwq](https://www.luogu.com.cn/problem/P2414)

---

所有有效的串,总长度是$O(L^2)$,我们不能把他们分别求出来,再建立trie,而是根据输入的B,P的串,直接构造一个trie.  

从代表空串的根节点$q_s$开始,设当前节点为$q$,trie树上父亲为$fa(q)$,加入字符$c$后到达$tr(q,c)$.  
- 对于正常字符$c$ 向下扩展$tr(q,c)$,并转移到$tr(q,c)$
- 对于B 回退到trie树上的父节点$fa(q)$.
- 对于P 记录当前所在节点$end(n)=q$,$S_n$从$q_s$开始匹配结束于$end(n)=q$.  


构造AC自动机(建DFA不要NFA). 
设$fail(q)$为编号为$q$的状态失配时转移到的状态(DFA不允许这种转移边,我们只是用它构建fail树进行计数),$tr(q,c)$为状态$q$输入字符$c$后转移到的状态.

对于查询$Q(x,y)$我们考虑每次都从$qs$开始进行匹配,发现答案是这个样子.

标记$\forall v(\exists k,fail^k(v)=tr(qs,S_y))$即$fail$树上$S_y$对应状态的子树中的所有状态,西然到达一次它们中的某个状态说明匹配到了一次$y$.  
统计$tr(qs,S_x[1,1]),tr(qs,S_x[1,2])\dots tr(qs,S_x)$中被标记的状态数(这里走的边都是原始的trie上面的边,而不会失配走经由fail的转移).


我们考虑两棵树,$fail,trie$(点是有对应关系的,但是边没有),令$[L(q),R(q)]$为fail树上节点$q$的dfs序区间.我们要做的其实是这个.

$$
\sum_{i=1}^{len(S_x)}[L(tr(qs,S_x[1,i])\in L(end(y),R(end(y))]
$$

我们dfs一下trie树,维护根链上节点在fail树上的dfs序开始位置集合$Sp$,进入$x$时,插入$L(x)$(在trie上面dfs,插入的是$x$在fail树的dfs序中的位置),离开时删除掉它.  
走到$end(S_y)$时,$Q(x,y)=\sum_{v\in Sp}[\,L(v)\in [L(end(y)),R(end(y))]\,]$这是个单点加,区间求和,我们使用一个BIT解决它.  
如果是在线的话,只需要把每个点的根链的$Sp$保留下来,用可持久化线段树空间多一个$log$就能变成在线算法.

---

扔代码跑路.


```cpp
#include <bits/stdc++.h>
int read(){
	int x=0;char c;
	do{c=getchar();}while(!isdigit(c));
	do{x=x*10+c-'0';c=getchar();}while(isdigit(c));
	return x;
}
const int N=100000+10;
int n,m,cnt,qs,end[N],ans[N];
struct Node{
	int tr[26],fail;
	// tr:trie of strings
	// fail:fail tree
	Node(){ fail=0;
		for(int i=0;i<26;i++) tr[i]=0;
	}
}t[N];
int& tr(int q,int c){ return t[q].tr[c]; }
int& fail(int q){ return t[q].fail; }

std::vector<int> g_fail[N];
int l[N],r[N],idx; // dfs order of fail-tree
void dfs0(int u){
	l[u]=++idx;
	for(int i=0;i<g_fail[u].size();i++) dfs0(g_fail[u][i]);
	r[u]=idx;
}
std::vector<int> g_trie[N];
std::vector<std::pair<int,int> > qry[N];
int bit[N]; inline int lowbit(int x){ return x&(-x); }
void add(int x,int y){
	while(x<=cnt){
		bit[x]+=y;
		x+=lowbit(x);
	}
}
int pre(int x){
	int s=0;
	while(x){
		s+=bit[x];
		x^=lowbit(x);
	}
	return s;
}

void solve(int u){
	add(l[u],1);
	for(int i=0;i<qry[u].size();i++){
		int id=qry[u][i].first,v=qry[u][i].second;
		ans[id]=pre(r[v])-pre(l[v]-1);
	}
	for(int i=0;i<g_trie[u].size();i++) solve(g_trie[u][i]);
	add(l[u],-1);
}

int q[N],ql,qr;
void init(){
	for(int i=1;i<=cnt;i++) for(int j=0;j<26;j++){
		int v=tr(i,j); if(v) g_trie[i].push_back(v);
	}
	ql=qr=0; for(int i=0;i<26;i++){
		int &j=tr(qs,i);
		if(j>0) fail(q[qr++]=j)=qs;
		else j=qs;
	}
	while(ql<qr){
		int u=q[ql++]; for(int i=0;i<26;i++){
			int &j=tr(u,i),t=tr(fail(u),i);
			if(j>0) fail(q[qr++]=j)=t;
			else j=t;
		}
	}
	for(int i=1;i<=cnt;i++) g_fail[fail(i)].push_back(i);
	idx=0; dfs0(qs);
}

int main(){
	//freopen("in","r",stdin);
	int p=(qs=++cnt); q[qr++]=p;
	std::string s; std::cin>>s;
	for(int i=0,ln=s.length();i<ln;i++){
		if(s[i]=='P') end[++n]=p;
		else if(s[i]=='B'){ p=q[qr-2]; qr--; }
		else{
			int &j=tr(p,s[i]-'a');
			if(j==0) j=++cnt;
			q[qr++]=(p=j);
		}
	}
	init(); m=read();
	for(int i=0;i<m;i++){
		int x=read(),y=read();
		qry[end[y]].push_back(std::make_pair(i,end[x]));
	}
	solve(qs);
	for(int i=0;i<m;i++) printf("%d\n",ans[i]);
	return 0;
}

```


---

## 作者：eternal (赞：0)

一个串a在b中出现, 那么a是b的某些前缀的后缀, 所以搞出AC自动机, 按fail反向建树, 然后查询(x, y)就是y的子树中有多少是x的前缀. 离线, 对AC自动机DFS一遍, 用dfs序+树状数组维护, DFS到的查询点就回答询问.时间复杂度O(|ACAM|+QlogQ)
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
    
    
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#include<cctype>
using namespace std;
#define chk(c) ((c <= 'z' && c >= 'a') || (c =='P') || (c == 'B'))
#define C(c) (c - 'a')
const int maxn = 100009;
const int c = 26;
inline int read() {
    char c = getchar();
    for(; !isdigit(c); c = getchar());
    int ret = 0;
    for(; isdigit(c); c = getchar())
        ret = ret * 10 + c - '0';
    return ret;
}
struct Node {
    Node *ch[c], *fail, *par;
    int v, d;
    Node() : v(0) {
        memset(ch, 0, sizeof ch);
        fail = par = 0;
    }
} pool[maxn], *V[maxn], *pt = pool, *Rt;
struct Q {
    int d, x, y;
    inline void Read(int _d) {
        d = _d;
        x = read();
        y = read();
    }
    bool operator < (const Q &o) const {
        return y < o.y;
    }
} q[maxn];
int n, dfsn, qn;
int L[maxn], R[maxn], ql[maxn], qr[maxn], ans[maxn];
void Init() {
    int cnt = dfsn = n = 0;
    pt->d = n++;
    Rt = pt++;
    Node* t = Rt;
    char c = getchar();
    for(; !chk(c); c = getchar());
    for(; chk(c); c = getchar()) {
        if(c == 'P') {
            V[t->v = ++cnt] = t;
        } else if(c == 'B') {
            t = t->par;
        } else {
            if(!t->ch[C(c)]) {
                pt->par = t;
                pt->d = n++;
                t->ch[C(c)] = pt++;
            }
            t = t->ch[C(c)];
        }
    }
    scanf("%d", &qn);
    for(int i = 0; i < qn; i++) 
        q[i].Read(i);
    sort(q, q + qn);
    memset(ql, 0, sizeof(int) * (cnt + 1));
    memset(qr, -1, sizeof(int) * (cnt + 1));
    for(int i = 0; i < qn; i++) {
        if(!i || q[i - 1].y != q[i].y)
            ql[q[i].y] = i;
        if(i + 1 == qn || q[i + 1].y != q[i].y)
            qr[q[i].y] = i;
    }
}
struct edge {
    int to;
    edge* next;
} E[maxn << 1], *Pt = E, *head[maxn];
inline void AddEdge(int u, int v) {
    Pt->to = v;
    Pt->next = head[u];
    head[u] = Pt++;
}
queue<Node*> que;
void buildFail() {
    que.push(Rt);
    while(!que.empty()) {
        Node* t = que.front(); que.pop();
        if(t->fail)
            AddEdge(t->fail->d, t->d);
        for(int i = 0; i < c; i++) if(t->ch[i]) {
            Node* f = t->fail;
            while(f && !f->ch[i])
                f = f->fail;
            t->ch[i]->fail = f ? f->ch[i] : Rt;
            que.push(t->ch[i]);
        }
    }
}
struct BIT {
    int b[maxn];
    BIT() {
        memset(b, 0, sizeof b);
    }
    inline void Add(int x, int v) {
        for(; x <= n; x += x & -x)
            b[x] += v;
    }
    inline int Sum(int x) {
        int ret = 0;
        for(; x; x -= x & -x)
            ret += b[x];
        return ret;
    }
    inline int Query(int l, int r) {
        return Sum(r) - Sum(l - 1);
    }
} Bit;
void DFS(int x) {
    L[x] = ++dfsn;
    for(edge* e = head[x]; e; e = e->next) DFS(e->to);
    R[x] = dfsn;
}
void dfsAC(Node* t) {
    Bit.Add(L[t->d], 1);
    if(t->v) {
        for(int i = ql[t->v]; i <= qr[t->v]; i++)
            ans[q[i].d] = Bit.Query(L[V[q[i].x]->d], R[V[q[i].x]->d]);
    }
    for(int i = 0; i < c; i++)
        if(t->ch[i]) dfsAC(t->ch[i]);
    Bit.Add(L[t->d], -1);
}
int main() {
    Init();
    buildFail();
    DFS(0);
    dfsAC(Rt);
    for(int i = 0; i < qn; i++)
        printf("%d\n", ans[i]);
    return 0;
}
```

---

## 作者：小塘空明 (赞：0)

首先根据ac自动机的性质，y在x中的每次出现，就是有一个y的字符的fail指针指向x的结束节点。
    
所以我们的问题变成了统计多少个y中的fail指针指向x。

由此得到启发，我们可以建一颗fail树，树上的每条边就是原trie树上的一个节点指向它的fail节点。

所以我们只要统计在fail树中，关于每个x的节点，y节点在它的子树中出现了几次。

我们之所以能这样统计，是因为在fail树中，关于每个子树的根节点x，它必然是它子树中的每个节点所代表的字符串的后缀。

关于这种树上子树统计问题，我们显然可以用树状数组来维护它的dfs序来进行计数。

但我们发现，因为很多个串可能出现重复，所以对每个询问重复插入并进行统计会造成大量的时间浪费。

这时候我们可以用一个巧妙的优化：我们在统计中，按照最初的trie图进行遍历，假如当前节点是一个子串的结尾，那么当前已经插入的字符肯定是且只能是该子串中的字符，这样我们就可以实现对fail树的o（n）遍历了。

---

## 作者：MSF_Akatsuki (赞：0)

题意：给一棵字典树，询问树上两个串中其中一个在另一个的子串中出现的次数。

转化问题。我们建一个AC自动机，那么我们可以把问题转化成目标串的每一个节点沿着fail指针跑，能访问多少次模式串深度最大的那个节点。这也就是求目标串前缀的后缀与模式串匹配的过程。

进一步转化就是fail指针反向建树后，模式串末节点的fail上子树中属于目标串的节点数。

求子树问题我们考虑在fail树的dfs序上维护当前存在的点数。由于目标串都是dfs过程中栈的一个状态，我们在把点加入栈时把这个点在fail的dfs序上标记，出栈时取消标记，当栈状态与我们求的目标串匹配的时候我们求一下对应的模式串的fail子树的标记数即可。

实际实现我们把询问离线按目标串y的打印顺序排序，然后把给定的字符串跑一遍（也就相当于给定dfs序的dfs），标记求和用树状数组维护即可。


    
    
    
    
    
                        
    
    
    
    
    
```cpp
    #include<cstdio>
    #include<cstdlib>
    #include<cstring>
    #include<algorithm>
    using namespace std;
    typedef int ITA[100005];
    ITA tl,gl,ans,fr,sz,pxx;
    char ch[100005];
    int gg,tt,qq,m,L;
    inline int kano()
    {
        char ch=getchar();int w=0,u=1;
        for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')u=-1;
        for(;ch>='0'&&ch<='9';ch=getchar())w=w*10+ch-'0';
        return w*u;
    }
    struct QUERY
    {
        int x,y;
        int num;
    }qr[100005];
    bool cmpy(const QUERY &a,const QUERY &b){return a.y<b.y;}
    struct SSSD
    {
        int ed,nxt;
    }sd[200005];
    inline void addedge(int a,int b){sd[++tt]=(SSSD){b,fr[a]};fr[a]=tt;}
    struct BIT
    {
        int a[100005];
        inline static int L(int x){return  x&(-x);}
        void add(int pos,int v){for(;pos<=qq;pos+=L(pos))a[pos]+=v;}
        int query(int r)
        {
            int ans=0;
            for(;r>0;r-=L(r))ans+=a[r];
            return ans;
        }
        int query(int l,int r){return query(r)-query(l-1);}
    }bit;
    struct ACnode
    {    
        int fail;
        int c;
        int nx[26];
        int fa;
    };
    struct ACautomaton
    {
        ACnode a[100005];
        int t;
        int rt;
        ACautomaton(){t=1;rt=1;a[1].fail=1;}
        void build_trie()
        {
            int pt=0;
            for(int i=0,nw=rt;i<L;i++)
            {
                switch(ch[i])
                {
                    case 'P':{
                        pxx[++pt]=nw;
                        break;
                    }
                    case 'B':{
                        nw=a[nw].fa;
                        break;
                    }
                    default:{
                        if(a[nw].nx[ch[i]-'a'])break;
                        a[nw].nx[ch[i]-'a']=++t;
                        a[t].c=ch[i]-'a';
                        if(nw==rt)
                        {
                            a[t].fail=rt;
                            addedge(rt,t);
                        }
                        a[t].fa=nw;nw=t;
                    }
                }
            }    
        }
        void build_fail()
        {
            int nw=0;
            int qu[100005];
            int qt=1,qs=0;
            qu[1]=rt;
            while(qt>qs)
            {
                nw=qu[++qs];
                for(int i=0;i<26;)
                {
                    while(!a[nw].nx[i]&&i<26)++i;
                    if(i>=26)break;
                    qu[++qt]=a[nw].nx[i];
                    ++i;
                }
                if(a[nw].fail)continue;
                for(int n2=a[a[nw].fa].fail;n2!=rt;n2=a[n2].fail)
                {
                    if(!a[n2].nx[a[nw].c])continue;
                    a[nw].fail=a[n2].nx[a[nw].c];
                    addedge(a[n2].nx[a[nw].c],nw);
                    break;
                }
                if(!a[nw].fail)
                {
                    if(!a[rt].nx[a[nw].c])
                    {
                        a[nw].fail=rt;
                        addedge(rt,nw);
                    }
                    else
                    {
                        a[nw].fail=a[rt].nx[a[nw].c];
                        addedge(a[rt].nx[a[nw].c],nw);
                    }
                }
            }
        }
        void rebuild()
        {
            int qt=1,pt=0;
            for(int i=0,nw=rt;i<L;i++)
            {
                switch(ch[i])
                {
                    case 'P':{
                        pt++;
                        while(qr[qt].y==pt)
                        {
                            ans[qr[qt].num]=bit.query(tl[pxx[qr[qt].x]],tl[pxx[qr[qt].x]]+sz[pxx[qr[qt].x]]-1);
                            qt++;
                        }
                        break;
                    }
                    case 'B':{
                        bit.add(tl[nw],-1);
                        nw=a[nw].fa;
                        break;
                    }
                    default:{
                        nw=a[nw].nx[ch[i]-'a'];
                        bit.add(tl[nw],1);
                    }
                }
            }        
        }
    }AC;
    void dfs_fail(int nw)
    {
        tl[nw]=++qq;gl[qq]=nw;sz[nw]=1;
        for(int i=fr[nw];i!=0;i=sd[i].nxt)
        {
            dfs_fail(sd[i].ed);
            sz[nw]+=sz[sd[i].ed];
        }
    }
    int main()
    {
        scanf("%s",ch);L=strlen(ch);
        AC.build_trie();
        AC.build_fail();
        dfs_fail(AC.rt);
        m=kano();
        for(int i=1;i<=m;i++)
        {
            qr[i].x=kano();
            qr[i].y=kano();
            qr[i].num=i;
        }
        sort(qr+1,qr+1+m,cmpy);
        AC.rebuild();
        for(int i=1;i<=m;i++)printf("%d\n",ans[i]);
    }
同样的一份：http://www.msfakatsuki.com/index/Pennant-number=327
```

---


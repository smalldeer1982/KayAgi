# [POI 2015] TRZ

## 题目描述

给定一个长度为 $n$ 的仅包含 $\texttt B$、$\texttt C$、$\texttt S$ 三种字符的字符串，请找到最长的一段连续子串，使得这一段要么只有一种字符，要么有多种字符，但是没有任意两种字符出现次数相同。

## 说明/提示

**【样例解释】**

选择 $\texttt {BSSBCS}$ 这个子串。

----

原题名称：Trzy wieże。

## 样例 #1

### 输入

```
9
CBBSSBCSC```

### 输出

```
6```

# 题解

## 作者：UnyieldingTrilobite (赞：27)

这个题的做法属于是官解吊打题解区了。

我们有一个结论：最终答案一定要么左端点在最左的三个之一，要么右端点在最右的三个之一。这是我们需要证明的。

运用反证法，反之，每一个最优解都满足左右至少有三格的位置可以扩展，也就是字符串的形式至少是 `a b c w d e f`，其中数字代表未知的字母，而 `w` 代表其中一个最优解（将符合条件的解称为“答案”）。注意 `w` 是字符串，其他六个字母都是字符。

记 $|X|$ 表示字符 $X$ 在 `w` 中出现的次数，其中 $X$ 是题目给出的三种字符之一。

让我们分几类情况讨论：

1. `w` 中只含一种字母。

由于整个字符串单第一个字符也可以构成一个长度为 1 的答案，所以 `w` 的长度一定超过 1。不妨 $|B|>1$ 而 $|C|=|S|=0$。

这样我们考察 `c w`这个串，如果 `c` 是 $B$，那么显然 `c w` 只含一种字符，是可行的答案。否则，不妨 `c` 是 $C$，那么在 `c w` 中 $|B|'>1=|C|'>0=|S|'$
 成立，那么 `c w` 也是答案，矛盾。
 
 2. `w` 中不止一种字母。
 
不妨 $|B|>|C|>|S|$。
 
那么显然 `c` 和 `d` 都不是 $B$，否则不妨 `c` 是 $B$，那么在 `c w` 中 $|B|'=|B|+1>|B|>|C|=|C|'>|S|=|S|'$，则 `c w` 也是答案，矛盾。
 
否则：

+ 若 `c` 和 `d` 中有 $C$，不妨 `c` 是 $C$。

考察 `c w`，它不是答案的唯一可能性就是 $|C|'=|B|'$，换而言之 $|C|+1=|B|$。那么再考虑 `c w d`，此时若 `d` 或 `b` 是 $B$ 或 $C$ 都已经使得 `c w d` 是答案推出矛盾，所以 `b` 和 `d` 都是 $S$。接着考虑 `c w d e`，若 `e` 是 $B$ 或者 $C$ 都已经使得 `c w d e` 是答案推出矛盾，所以 `e` 是 $S$。 

那么考虑 `w d`，它不是答案的唯一可能性就是 $|S|'=|C|'$，换而言之 $|S|+1=|B|$。观察 `w d e` 这个串，他满足 $|S|'=|B|'=|C|'+1$。那么 `f` 如果是 $S$ 或者 $B$ 的话 `w d e f` 就是答案了，推出矛盾。 所以 `f` 是 $C$。

如此一来我们可以先看一下现在的字符串长什么样：`a S C w S S C`。

在 `S C w S S C` 中已经有 $|S|'=|C|'=|B|'+1$，为了使得 `a S C w S S C` 不是答案，需要 `a` 是 $B$。但这个时候 `B S C w` 是答案，矛盾！

+ 若 `c` 和 `d` 全是 $S$：

考察 `c w` 和 `c w d`，它们都不是答案只可能是 $|B|=|C|+1=|S|+2$。

考察 `b c w d`，它不是答案说明了 `b` 是 $C$，同理 `e` 是 $C$。

考察 `w d e f`，它不是答案说明了 `f` 是 $S$，同理 `a` 是 $S$。

那么字符串变成了 `S C S w S C S`，观察到它本身就是答案，矛盾！

综上，证毕。

代码很好写，暴力枚举端点扫过去就可以了。

---

## 作者：Holy_Push (赞：17)

虽然数据水可以让下方题解$n^2$甚至$n^2logn$的做法都水过去（而且爆踩标算？），但是我们还是需要考虑一下正解的做法。

当区间数字全部相同时很容易解决，接下来只考虑区间内没有任意两种字符出现次数相同的情况。

 区间$B,C,S$的个数让我们很自然地就能想到使用前缀和优化。然后我们考虑什么时候一个串是不合法的。记$R[i].x,R[i].y,R[i].z$分别表示$B,C,D$的前缀和。

对于一个子串$[i+1,j]$，它不合法当且仅当:

1. $R[j].x-R[i].x≠R[j].y-R[i].y$
2. $R[j].x-R[i].x≠R[j].z-R[i].z$
3. $R[j].y-R[i].y≠R[j].z-R[i].z$

通过移项可以得到

1. $R[j].x-R[j].y≠R[i].x-R[i].y$
2. $R[j].x-R[j].z≠R[i].x-R[i].z$
3. $R[j].y-R[j].z≠R[i].y-R[i].z$

这样以后两边都是只和当前位置$i$有关的式子了。如果我们为第$i$位记三元组$(j,k,l)$，其中

$j=R[i].x-R[i].y$

$k=R[i].x-R[i].z$

$k=R[i].y-R[i].z$

方便起见，我们可以通过各种操作使得$j,k,l$都为正数，例如离散、都加上一个某一个数之类的。

则问题可以转化成对每一个位置$i$，求一个最远的位置$j$，使得第$i$位和第$j$位的三元组对应位置上的数都不相同。

于是我们想到了一个三维的做法：

**初步算法：按顺序做，然后每遇到一个位置$i$，其位置上的三元组为$(j,k,l)$，则查询：
$(1)x∈[1,j-1],y∈[1,k-1],z∈[1,l-1]$**

$(2)x∈[1,j-1],y∈[1,k-1],z∈[l+1,Maxz]$

$(3)……$

$(8)x∈[j+1,Maxx],y∈[k+1,Maxy],z∈[l+1,Maxz]$

共八个区间的最小值，之后再将$(i,j,k)$插入，利用树套树套树或神奇的分治算法解决，时空复杂度双双爆炸。

所以我们要开始考虑降维。

**进一步算法：首先我们可以先按第一维排个序，这样第一维就没有问题了。我们需要先把第一维相同的所有三元组都做完，再一起插入。**

$Q:$但这样子$i$不就会出问题了嘛$？$

$A:$所以我们可以在插入的时候记录$i$的最大值和最小值，分两种情况，也就是$|id-Maxi|,|id-Mini|$。其中$id$和$i$均为当前三元组在原数组中的编号，下文同理。

于是我们成功把问题从三维转为成了二维，利用树套树或神奇的分治算法解决，时空复杂度仍然双双爆炸。

所以我们要继续降维。

$k$这一维我们不再继续优化了，我们准备优化$l$这一维。我们经过思考过后，发现记录$l$这一位没有什么实际用处。

**再进一步算法：我们以$k$这一维为下标建权值线段树，每个节点记录四个变量$:Max,cMax,Min,cMin$**。分别表示最大的$i_1$,最大的$i_2,$，其中$i_1,i_2$这两位上的三元组$l$值不同。$Min,cMin$同理。

然后我们就可以直接询问了。当访问到一个询问区间时，如果当前查询的$l$维上的数和原数组中$Max$位$l$维上的数相同，那么我们就应该选择$cMax$，否则就应该选择$Max$。$Min,cMin$同理。

至于修改操作，也很容易，就不解释了。

不过由于线段树常数空间巨大，所以吸氧才能过。不过由于是单点修改，查询前缀和后缀，所以换成树状数组可以跑的更快，但代码更长一点。顺便说一句，$(j,k,l)$在代码中对应的是$(x,y,z)$

```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;
const int N=1000005,INF=998244353;

int n,ans,len,MM;
char c[N];

struct Sv
{
	int x,y,z,id;
	bool operator <(const Sv &a) const {return x<a.x;}
} R[N],a[N],b[N];

struct node
{
	int Min=INF,cMin=INF,Max=-1,cMax=-1,lson,rson;
} t[N*3];

int query(int i,int l,int r,int x,int y,int k)
{
	if (!i) return 0;
	if (l>=x&&r<=y)
	{
		int amin,amax;
		if (t[i].Min==INF) return 0;
		if (b[t[i].Min].z==a[k].z) amin=t[i].cMin; else amin=t[i].Min;
		if (b[t[i].Max].z==a[k].z) amax=t[i].cMax; else amax=t[i].Max;
		if (amin==INF||amax==-1) return 0;
		return max(abs(a[k].id-amin),abs(a[k].id-amax));
	}
	int mid=(l+r)>>1,ans=0;
	if (mid>=x) ans=max(ans,query(t[i].lson,l,mid,x,y,k));
	if (mid<y) ans=max(ans,query(t[i].rson,mid+1,r,x,y,k));
	return ans;
}

void update(int i,int l,int r,int k)
{
	if (t[i].Min>a[k].id)
	{
		if (t[i].Min!=INF&&b[t[i].Min].z!=a[k].z) t[i].cMin=t[i].Min;
		t[i].Min=a[k].id;
	} else if (t[i].cMin>a[k].id&&a[k].z!=b[t[i].Min].z) t[i].cMin=a[k].id;
	if (t[i].Max<a[k].id)
	{
		if (t[i].Max!=-1&&b[t[i].Max].z!=a[k].z) t[i].cMax=t[i].Max;
		t[i].Max=a[k].id;
	} else if (t[i].cMax<a[k].id&&a[k].z!=b[t[i].Max].z) t[i].cMax=a[k].id;
	if (l==r) return;
	int mid=(l+r)>>1;
	if (mid>=a[k].y) 
	{
		if (!t[i].lson) t[i].lson=++len;
		update(t[i].lson,l,mid,k);
	} else 
	{
		if (!t[i].rson) t[i].rson=++len;
		update(t[i].rson,mid+1,r,k);
	}
}

int main()
{
	scanf("%d",&n);scanf("%s",c);len=1;
	int ii=0;
	while (ii<n)
	{
		int j=ii+1;
		while (j<n&&c[j]==c[ii]) ++j;--j;
		ans=max(ans,j-ii+1);ii=j+1;
	}
	for (int i=1;i<=n;i++)
	{
		R[i]=R[i-1];
		if (c[i-1]=='C') R[i].y++;
		if (c[i-1]=='B') R[i].x++;
		if (c[i-1]=='S') R[i].z++;
	}
	for (int i=1;i<=n;i++)
	{
		a[i].x=R[i].x-R[i].y;
		a[i].y=R[i].x-R[i].z;
		a[i].z=R[i].y-R[i].z;
		MM=min(MM,min(a[i].x,min(a[i].y,a[i].z)));
		a[i].id=i;
	}
	++n;
	for (int i=1;i<=n;i++) a[i].x+=-MM+1,a[i].y+=-MM+1,a[i].z+=-MM+1;
	for (int i=1;i<=n;i++) b[i]=a[i];b[0]=b[n];
	sort(a+1,a+n+1);
	ii=1;int d=n-MM+1;
	while (ii<=n)
	{
		int j=ii+1;
		while (j<=n&&a[j].x==a[ii].x) ++j;--j;
		for (int k=ii;k<=j;k++)
		{
			ans=max(max(ans,query(1,1,d,1,a[k].y-1,k)),query(1,1,d,a[k].y+1,d,k));
		}
		for (int k=ii;k<=j;k++) update(1,1,d,k);
		ii=j+1;
	}
	printf("%d\n",ans);
}
```


---

## 作者：SDNetFriend (赞：5)

线性做法。

我们考虑对于这种题，一般思路都是枚举左端点然后找到最靠右的可行右端点是哪个。

按照类似暴力的思路，我们对于一个左端点 $l$，先把右端点设为 $n$，然后判断一下是否可行，不可行再左移右端点直到可行。当然这个不能暴力做，我们需要发掘一些性质来简化这个过程。

首先，假设 $[l,r]$ 区间内三种颜色（其实就是 `B,C,S`）不存在数量相同的颜色，那么直接更新答案。

如果 $[l,r]$ 内三种颜色数量都相等，那么一定不能取并且 $[l,r-1]$ 区间内一定是两种颜色数量相同，另一种少一个。

到这里可以发现，我们要处理最多的情况，是两种颜色数量相同，另一种不同的情况。为了方便，我们设数量相同的颜色为 $u,v$，不同的那种为 $w$。

我们考虑左移右端点，但是具体移动到哪里呢？至少要让 $u,v$ 数量不相同。那我们找到最右边的一个 $u$ 或者 $v$，假设我们找到了一个 $u$，位置在 $p$，那么显然 $[l,p-1]$ 区间 $u,v$ 数量不等。我们设 $[l,p-1]$ 区间内 $v$ 的数量为 $c$ 则 $u$ 的数量为 $p-1$。

考虑 $w$ 的数量，如果不是是 $c$ 或 $c-1$ 那么可以直接更新答案。如果是呢？我们发现，无论原来状态如何，我们进行一次“跳跃”（即刚才右端点从 $r$ 移动到 $p-1$ 这个过程），不能直接得到答案的状态只有两种，即三种颜色数量为 $x,x,x-1$ 或者 $x,x,x+1$。那当我们确定是这两种状态之一时，后续的跳跃路线是确定的，并且如果能继续跳跳到的还会是这两种状态之一。

这启示我们进行 DP，设状态 $f_{i,j,0/1}$ 表示右端点在 $i$，数量和其它两个不同的颜色是 $j$，状态是上述状态的前者/后者最后会跳到哪里。

这个东西可以直接 DP，即对于每个状态再跳一次然后更新答案即可。

然后最后枚举左端点，把右端点根据情况设为 $n$ 或者 $n-1$，然后跳一次再去查对应的 $f$ 就能更新答案了。

### 代码

``` cpp
#include <bits/stdc++.h>
using namespace std;
inline int read(){
	char c;int f=1,res=0;
	while(c=getchar(),!isdigit(c))if(c=='-')f*=-1;
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res*f;
}
const int N=1e6+5;
int n,a[N],ans,f[N][3][2],pre[N][3],s[N][3];
inline int t(int l,int r,int c)
	{return s[r][c]-s[l-1][c];}
inline void upd(int i,int u,int v,int w){
	int p=max(pre[i][u],pre[i][v]);
	if(!p){f[i][w][1]=i;return;}
	if(a[p]==v)swap(u,v);int c=t(p,i,w);
	if(!c)f[i][w][0]=f[p-1][v][1];
	else f[i][w][0]=p-1;
	if(c==1)f[i][w][1]=f[p-1][u][0];
	else if(c==2)f[i][w][1]=f[p-1][v][1];
	else f[i][w][1]=p-1;
}
inline void build(){
	for(int i=1;i<=n;++i){
		s[i][a[i]]=1;
		for(int j=0;j<3;++j){
			if(j==a[i])pre[i][j]=i;
			else pre[i][j]=pre[i-1][j];
			s[i][j]+=s[i-1][j];
		}
	}for(int i=1;i<=n;++i){
		upd(i,0,1,2);
		upd(i,0,2,1);
		upd(i,1,2,0);
	}
}
inline void solve(){
	for(int i=1;i<=n;++i){
		int l=i,r=n,u=-1,v,w,s0,s1,s2;
		if(t(l,r,0)==t(l,r,1)&&t(l,r,0)==t(l,r,2))--r;
		s0=t(l,r,0);s1=t(l,r,1);s2=t(l,r,2);
		if(s0==s1)u=0,v=1,w=2;
		else if(s1==s2)u=1,v=2,w=0;
		else if(s2==s0)u=0,v=2,w=1;
		if(u==-1)ans=max(ans,r-l+1);
		else{
			int p=max(pre[r][u],pre[r][v]);
			if(p<l){ans=max(ans,r-l+1);continue;}
			if(a[p]==v)swap(u,v);
			int c0=t(l,r,u),c=t(l,p-1,w);
			if(c==c0-1)ans=max(ans,f[p-1][v][1]-l+1);
			else if(c==c0)ans=max(ans,f[p-1][u][0]-l+1);
			else ans=max(ans,(p-1)-l+1);
		}
	}
}
int main(){
	n=read();
	for(int i=1;i<=n;++i){
		char c;do c=getchar();
		while(c<'A'||c>'Z');
		if(c=='B')a[i]=0;
		if(c=='C')a[i]=1;
		if(c=='S')a[i]=2;
	}build();solve();printf("%d",ans);
	return 0;
}

```



---

## 作者：naroto2022 (赞：4)

# P3590 题解

[博客园里查看更佳](https://www.cnblogs.com/naroto2022/p/18696243)

### 题面

[原题传送门](https://www.luogu.com.cn/problem/P3590)

### 思路

由于这个[帖子](https://www.luogu.com/discuss/70141)没有人给出 hack，所以我就照着这个思路开始证明。

结论：最终答案的左端点在 $1\sim3$ 的位置之一或者右端点在 $n-2\sim n$ 的位置之一。

假设目前的字符串 `a1 a2 a3 res a4 a5 a6`，其中 $res$ 为当前的最优解。

1. $res$ 中只有一个字符 $ch$，则有两种情况。
   1. $|ch|=1$，则 $res$ 可以在 $a_{1\sim6}$ 里任意一个，所以满足结论。
   2. $|ch|>1$，则单独考虑 `res a4`，若 $a_4=ch$，则 $res$ 可以扩展；若 $a_4\neq ch$，则 $|a_4|=1$，此时 $|a_4|\neq|ch|$，所以在这种情况下，结论成立。
2. $res$ 中有多个字符，那么这三个字符的出现次数不一样，不妨设 $|B|>|C|>|S|$，则又有三种情况。
   1. $a_3=$ `B` 或 $a_4=$ `B`，则 $res$ 可以继续往外扩展。
   2. $a_3=$ `C` 或 $a_4=$ `C`，设 $a_4=$ `C`，若 $res$ 可以扩展到 $a_4$，则满足结论；若不能扩展到 $a_4$，则有 $|B|=|C|+1$，接下来考虑扩展 $a_3,a_5$，若 $a_3,a_5$ 中有一个为 `B` 或 `C`，则可以扩展；若 $a_3,a_5=$ `S`，于是考虑 `a3 res` 即 `S res`，若 $res$ 可以扩展到 $a_3$，则满足结论；若不能扩展，则有 $|C|=|S|+1$，于是联立下前面的式子，$res$ 里字母数量满足 $|B|=|C|+1=|S|+2$。继续讨论，若 $a_2=$ `B`，则 `a2 a3 res a4` 即 `B S res C` 满足题意；若 $a_2=$ `C`，则 `a2 a3 res a4` 即 `C S res C` 满足题意；若 $a_2=$ `S`，继续讨论 $a_1$，若 $a_1=$ `B`，则 `a1 a2 a3 res` 即 `B S S res` 满足题意；若 $a_1=$ `S`，则 `a1 a2 a3 res` 即 `S S S res` 满足题意；若 $a_1=$ `C`，继续讨论 $a_6$，若 $a_6=$ `B`，则 `res a4 a5 a6` 即 `res C S B` 满足题意；若 $a_6=$ `C`，则 `res a4 a5 a6` 即 `res C S C` 满足题意；若 $a_6=$ `S`，则 `a1 a2 a3 res a4 a5 a6` 即 `C S S res C S S` 满足题意。综上所述，当 $a_4=$ `C` 时，$res$ 可以扩展。
   3. $a_3,a_4=$ `S`（一个为 `S` 的情况上面已经讨论），若 `a3 res` 和 `a3 res a4` 都不能扩展，则有 $|B|=|C|+1=|S|+2$，接下来考虑 $a_2,a_5$，若 $a_2,a_5=$ `B`，则 `a2 a3 res a4` 即 `C S res S` 满足题意，$a_5$ 同理也满足题意；若 $a_2,a_5=$ `S`，则 `a2 a3 res a4` 即 `S S res S` 满足题意，$a_5$ 同理也满足题意；若 $a_2,a_5=$ `C`，继续考虑 $a_1,a_6$，若 $a_1,a_6=$ `B`，则 `a1 a2 a3 res` 即 `B C S res` 满足题意，$a_6$ 同理也满足题意；若 $a_1,a_6=$ `C`，则 `a1 a2 a3 res` 即 `C C S res` 满足题意，$a_6$ 同理也满足题意；若 $a_1,a_6=$ `S`，则 `a1 a2 a3 res a4 a5 a6` 即 `S C S res S C` 满足题意，$a_6$ 同理也满足题意。综上所述，$a_3,a_4=$ `S` 时，$res$ 可以扩展。

证毕，所以只要用前缀和记录下字符串字母出现的次数，一个个判断过去即可，时间复杂度为 $O(n)$。

### 代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#define ll long long
using namespace std;
const int MN=1e6+5;
ll n,s[MN][3],ans=1;
char c[MN];
void write(ll n){if(n<0){putchar('-');write(-n);return;}if(n>9)write(n/10);putchar(n%10+'0');}
ll read(){ll x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}return x*f;}
char gc(){char ch=getchar();while(ch!='B'&&ch!='C'&&ch!='S')ch=getchar();return ch;}
ll gs(char ch){if(ch=='C') return 0;if(ch=='B') return 1;return 2;}
int main(){
    n=read();
    for(int i=1; i<=n; i++){
        c[i]=gc();
        s[i][gs(c[i])]++;
    }
    for(int i=1; i<=n; i++) for(int j=0; j<3; j++) s[i][j]+=s[i-1][j];
    for(int i=1; i<=3; i++) for(int j=n; j>i; j--) if((s[j][0]-s[i-1][0]!=s[j][1]-s[i-1][1]&&s[j][1]-s[i-1][1]!=s[j][2]-s[i-1][2]&&s[j][0]-s[i-1][0]!=s[j][2]-s[i-1][2])||(s[j][0]-s[i-1][0]+s[j][1]-s[i-1][1]+s[j][2]-s[i-1][2]==s[j][0]-s[i-1][0])||(s[j][0]-s[i-1][0]+s[j][1]-s[i-1][1]+s[j][2]-s[i-1][2]==s[j][1]-s[i-1][1])||(s[j][0]-s[i-1][0]+s[j][1]-s[i-1][1]+s[j][2]-s[i-1][2]==s[j][2]-s[i-1][2])) ans=max(ans,(ll)j-i+1);
    for(int j=n; j>n-3; j--) for(int i=1; i<j; i++) if((s[j][0]-s[i-1][0]!=s[j][1]-s[i-1][1]&&s[j][1]-s[i-1][1]!=s[j][2]-s[i-1][2]&&s[j][0]-s[i-1][0]!=s[j][2]-s[i-1][2])||(s[j][0]-s[i-1][0]+s[j][1]-s[i-1][1]+s[j][2]-s[i-1][2]==s[j][0]-s[i-1][0])||(s[j][0]-s[i-1][0]+s[j][1]-s[i-1][1]+s[j][2]-s[i-1][2]==s[j][1]-s[i-1][1])||(s[j][0]-s[i-1][0]+s[j][1]-s[i-1][1]+s[j][2]-s[i-1][2]==s[j][2]-s[i-1][2])) ans=max(ans,(ll)j-i+1);
    write(ans);putchar('\n');
    return 0;
}
```

---

## 作者：int08 (赞：4)

# 前言
本来是从树状数组题单来的。

但是看到了[这个远古讨论帖](https://www.luogu.com.cn/discuss/70141)，性质就变化了（确信）。

## Solution

相信很多人看到这道题的时候和我反应是一样的：

“这……三者出现次数不同的条件是宽泛的，估计答案左右侧应该都是靠近端点的。”

但是又没有一个具体结论。

然后看到了这句话：“最长的子串满足左端点在 $1$ 到 $3$ 或右端点在 $n-2$ 到 $n$。然后暴力。”

豁然开朗，估计结论是正确的，事实上确实也是。~~羡慕大佬的一眼顶针猜结论能力。~~

证明一下吧。

### Step 1

容易发现，要证明如上结论，只需证明：

“对于一个合法解 $S$，只要左右各有 $3$ 字符，必然有完全包含 $S$ 的更优解。”

因为这样，只要一个解两端点都不在左右 $3$ 个，就必能扩展出更优解。

### Step 2

为了严谨，还是分类讨论 $S$ 的组成情况，

由于随便选第一个是长为 $1$ 的解，所以讨论 $S$ 长为 $1$ 无意义，先钦定（？）$length(S)>1$。

如果 $S$ 仅由一种字符构成，即出现次数三元组是 $(x,0,0)$，那么左边加一个，变成 $(x+1,0,0)$ 或者 $(x,1,0)$ 都是满足条件的。

即原解是可以扩展的。

### Step 3

如果 $S$ 由多种字符构成，那出现次数必然互不相同，假设其出现次数三元组 $(k+x,k+y,k)$。

**设这三个字母为 $D,E,F$。**

观察在某一边加一个字母的意义：对三元组中一个值加 $1$。

容易发现，如果没有出现三元组相邻两项差值为 $1$，那我把任意一项加 $1$ 仍然不会有重复数字出现，即此时随便加一个字母仍合法。

所以相邻两项必然有差值为 $1$，再分类讨论。

#### Case 1:$(k+y+1,k+y,k),y>1$

此时 $S$ 左右两侧字母都只能是 $E$（是按照我上面的加粗假设），否则单选不是 $E$ 那个必会是新的合法解。

即使两边都是 $E$，同时选也会变成 $(k+y+1,k+y+2,k)$ 是合法解。

#### Case 2:$(k+x,k+1,k),x>2$

此时 $S$ 左右两侧字母都只能是 $F$，否则单选不是 $F$ 那个必会是新的合法解。

即使两边都是 $F$，同时选也会变成 $(k+x,k+1,k+2)$ 是合法解。

#### Case 3:$(k+2,k+1,k)$

显然左右必然不是 $D$，而且如果左右都是 $E$，同时选后是合法解。

##### Case 3.1:$()()E|S|F()()$

此时总的出现次数三元组：$(k+2,k+2,k+1)$，左右两边只能都是 $F$。

即为 $()FE|S|FF()$

单选左边两个得到最左边为 $F$，单选右边两个得到最右边为 $E$，

然而对于 $FFE|S|FFE$，简单全选后出现次数为 $(k+2,k+3,k+4)$。是合法的解。

##### Case 3.2:$()()F|S|F()()$

此时总的出现次数三元组：$(k+2,k+1,k+2)$，左右两边只能都是 $E$。

即为 $()EF|S|FE()$

单选左边两个得到最左边为 $F$，单选右边两个得到最右边为 $F$，

然而对于 $FEF|S|FEF$，简单全选后出现次数为 $(k+2,k+3,k+4)$。是合法的解。

**故对于所有情况总是能扩展出合法解。**

证明完毕。

代码是简单的，前缀和预处理后枚举即可。

## AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,i,j,b[1919810],c[1919810],s[1919810],ans;
void check(int x,int y)
{
	int cb=b[y]-b[x],cc=c[y]-c[x],cs=s[y]-s[x];
	if(cb==0&&cc==0||cs==0&&cb*cc==0)
	ans=max(ans,y-x);
	if(cb!=cc&&cc!=cs&&cs!=cb)
	ans=max(ans,y-x);
}
string a;
int main()
{
	cin>>n>>a;a="6"+a;
	for(i=1;i<=n;i++)
	{
		b[i]=b[i-1];
		c[i]=c[i-1];
		s[i]=s[i-1];
		if(a[i]=='B') b[i]++;
		if(a[i]=='C') c[i]++;
		if(a[i]=='S') s[i]++;
	}
	for(i=0;i<3;i++)
		for(j=i+1;j<=n;j++)
			check(i,j);
	for(i=n-2;i<=n;i++)
		for(j=0;j<i;j++)
			check(j,i);
			cout<<ans;
	return 0;
 } 
```
# The End.

---

## 作者：2018ljw (赞：4)

一眼看去和 P2843 很像，主要区别在于相同还是不同。或许可以参考下那题做法？

先判掉单种字符的连续段，这样不出现就可以看做出现 $0$ 次。记 $s_{i,1,2,3}$ 分别为三类字符的前缀和，那么就相当于找到最远的 $j<i$ 满足：

$$
\begin{cases}s_{i,1}-s_{j,1}\neq s_{i,2}-s_{j,2}\\s_{i,1}-s_{j,1}\neq s_{i,3}-s_{j,3}\\s_{i,2}-s_{j,2}\neq s_{i,3}-s_{j,3}\end{cases}
$$

类似那题做法，我们进行移项，将每个位置变为一个三元组 $(a_i,b_i,c_i)$，每一项为对应 $s_i$ 中两项的差。

那么就转化为对每个 $i$ 求 $a_i\neq a_j,b_i\neq b_j,c_i\neq c_j$ 的三元组中，最小的 $j$。把不等号拆成大于号和小于号，此时已经可以转化为三维偏序 cdq 解决了。

不等号的性质比单个大于号或小于号肯定是更好的，考虑优化。

关注到若某个三元组与 $(a_0,b_0,c_0)$ 对应位均不同，那么其匹配到的肯定是位置 $0$。对于剩下的三元组，其必定至少有一位与 $(a_0,b_0,c_0)$ 相同，继续处理即可。

具体的，我们记录当前哪些位的值被确定了，找到不符合条件的点对中下标最小的，然后在所有符合条件的点对里进行配对，配对失败的继续进入下一级配对。

每个点最多进行 $3$ 次配对，总复杂度 $O(n)$。


```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
using namespace std;
char s[1000002];
int n,a[1000001],b[1000001],c[1000001];
int res;
bool vis[1000001]; 
void calc(int st,int la,int lb,int lc,vector<int>g){
	if(g.empty())return;
	int i,j;
	bool xa=st&1,xb=st&2,xc=st&4;
	int fpos=-1;
	for(i=0;i<=n;i++){
		if(xa&&a[i]==la)continue;
		if(xb&&b[i]==lb)continue;
		if(xc&&c[i]==lc)continue;
		fpos=i;break;
	}
	if(fpos==-1)return;
	for(i=0;i<g.size();i++){
		int d=g[i];
		if(a[d]==a[fpos]||b[d]==b[fpos]||c[d]==c[fpos])continue;
		res=max(res,d-fpos);vis[d]=1;
	}
	vector<int>tmp[8];
	for(i=1;i<8;i++)tmp[i].resize(0);
	for(i=0;i<g.size();i++){
		int d=g[i];
		if(vis[d])continue;
		bool ha=xa,hb=xb,hc=xc;
		if(a[d]==a[fpos])ha=1;
		if(b[d]==b[fpos])hb=1;
		if(c[d]==c[fpos])hc=1;
		int nx=ha*1+hb*2+hc*4;
		tmp[nx].push_back(d);
	}
	if(!(st&1))la=a[fpos];
	if(!(st&2))lb=b[fpos];
	if(!(st&4))lc=c[fpos];
	for(i=st+1;i<8;i++)calc(i,la,lb,lc,tmp[i]);
}
vector<int>r;
int main(){
	int i,s1=0,s2=0,s3=0;
	scanf("%d%s",&n,s+1);
	for(i=1;i<=n;i++){
		if(s[i]=='B')s1++;
		if(s[i]=='C')s2++;
		if(s[i]=='S')s3++;
		a[i]=s1-s2;
		b[i]=s2-s3;
		c[i]=s3-s1;
	}
	int lst=0;
	for(i=1;i<=n;i++){
		res=max(res,i-lst);
		if(i!=n&&s[i]!=s[i+1])lst=i;
	}
	for(i=1;i<=n;i++)r.push_back(i);
	calc(0,0,0,0,r);
	printf("%d",res);
}
```

---

## 作者：_lmh_ (赞：3)

只出现一种字符是简单的，下只考虑三种字符出现次数不同的情况。

考虑对三种字符出现次数算前缀和，令 $A_i,B_i,C_i$ 为 `S,B,C` 三种字符出现次数（注意 `S` 对应 $A$），$a_i=A_i-B_i,b_i=B_i-C_i,c_i=C_i-A_i$，则我们的目标转化为找到 $r-l$ 最大的 $(l,r)$ 使得 $a_l\ne a_r,b_l\ne b_r,c_l\ne c_r$。

把 $(a_i,b_i,c_i)$ 放到一个空间内，$O(n)$ 枚举右端点。显然我们需要剔除无用的状态，优先使用更小的 $i$ 作为左端点。

三维的情况不太好搞，先考虑一维的情况。如果两个点重合那么当然删除编号更大的一个，如果没有这样的重合点，那么显然两个点足以覆盖一整条直线。

二维的情况下，把两条坐标轴上各放两个点，则只有原点没有被覆盖；现在再放第五个点，就必须放在坐标轴以外，就可以覆盖原点了。

三维的情况下，类似地，在 $x=0,y=0,z=0$ 三个平面上各放五个点，最后一个点就必须放在平面外，需要十六个点。

这样我们就把有效状态剔除到 $O(1)$ 个，可以在 $O(n)$ 的复杂度内解决。

如果利用 $a_i+b_i+c_i=0$ 的性质，可以获得更优的常数，但没必要。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define lson (u<<1)
#define rson (u<<1|1)
const ll N=1000007;
ll n,m,ans,a[N],b[N],c[N],stk[N],top;
char s[N];
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n>>(s+1);
	for (ll l=1,r=1;l<=n;l=r){
		while(r<=n&&s[r]==s[l]) ++r;
		ans=max(ans,r-l);
	}
	for (int i=1;i<=n;++i){
		a[i]=a[i-1];b[i]=b[i-1];c[i]=c[i-1];
		if (s[i]=='S'){++a[i];--b[i];}
		else if (s[i]=='B'){++b[i];--c[i];}
		else{++c[i];--a[i];}
	}
	top=1;
	for (int i=1;i<=n;++i){
		for (ll j,_=1;_<=top;++_){
			j=stk[_];
			if (a[i]!=a[j]&&b[i]!=b[j]&&c[i]!=c[j]){ans=max(ans,i-j);break;}
		}
		if (top==16) continue;
		ll fx=0,fy=0,fz=0,fxy=0,fxz=0,fyz=0,fxyz=0;
		for (int j,_=1;_<=top;++_){
			j=stk[_];
			fx+=(a[i]==a[j]);
			fy+=(b[i]==b[j]);
			fz+=(c[i]==c[j]);
			fxy+=(a[i]==a[j]&&b[i]==b[j]);
			fxz+=(a[i]==a[j]&&c[i]==c[j]);
			fyz+=(b[i]==b[j]&&c[i]==c[j]);
			fxyz+=(a[i]==a[j]&&b[i]==b[j]&&c[i]==c[j]);
		}
		if (fxyz||fxy>=2||fxz>=2||fyz>=2||fx>=5||fy>=5||fz>=5) continue;
		stk[++top]=i;
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：断清秋 (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P3590)

看了[这个帖子](https://www.luogu.com.cn/discuss/549145)觉得很神奇，尝试证明一下原贴结论。

原帖给出了一个结论是：答案串必然有左端点在 $[1,3]$ 中或右端点在 $[n-2,n]$ 中。

正难则反，显然考虑反证法，假设答案串 $s$ 不满足上述性质，那么答案左右两边必然都至少有三个字母。

如果 $|s|=1$ 那显然随便选一个字母都满足上述性质，下证 $|s|>1$ 的情况。

如果 $s$ 中只有一个字母那显然旁边随便加一个都比 $s$ 大，矛盾；

如果 $s$ 中有多个字母，为了方便不妨设三个字母分别为 $a,b,c$，出现次数为 $t_a,t_b,t_c$，且 $t_a>t_b>t_c$。

那么 $s$ 周围的两个字母只可能是 $b$ 和 $c$，且至少有一个 $c$，否则显然矛盾。

考虑分类讨论，如果有一个 $b$ 和一个 $c$，那么必然满足 $t_a-t_b=t_b-t_c=1$，不妨设 $s$ 左边是 $b$ 右边是 $c$，那么只需向 $b$ 那一侧扩展可知 $b$ 左边必然是 $c$，而 $c$ 左边还会是 $c$。然后尝试向右扩展，发现 $s$ 右边无法构造出合法解，矛盾。

如果两边都是 $c$，依然需要满足 $t_a-t_b=t_b-t_c=1$，同上构造方案可知不存在合法的构造方案，矛盾。

因此不存在不满足上述性质的答案串，原命题成立。

---

## 作者：xtx1092515503 (赞：2)

这里是**有正确性证明**的**复杂度正确**的线性做法。

------------

考虑钦定右端点为 $r$。这时，考虑左端点。

如果长度为 $r$ 的前缀中三种字符出现次数各自不同则显然不用管。

否则，如果三种字符出现次数都相同，则我们可以把左端点 $l$ 由 $1$ 移到 $2$，这样三种字符出现次数就不都相同了。

则此时应该有两种字符出现次数相同。考虑找到这两种字符中任何一个出现的最前位置，并将 $l$ 移至其后一格处。

假如此时三种字符出现次数都不同，则显然合法。否则，则又有两种字符相同，需要重新开始检索。

显然我们没有余裕去一直执行这样的检索。考虑每次检索后，得到的态必然是两个字符出现次数相同且第三个字符出现次数是上述次数加减一，不然把 $l$ 回移一步就无法得到一个不同的两个字符出现次数相同的态。

我们存在将 $r$ 右移一格以及左移一格的选项。明显如果某次检索失败，则下次检索必然至少会使得区间长度减小一，故无论是左移还是右移只要成功就一定不更劣。左移在 $r=1$ 时不合法，但明显 $r=1$ 时能贡献的长度至多为 $1$，故不用考虑；右移在 $r=n$ 时不合法，但是对于 $r=n$ 时就算不断检索复杂度也可以承受，故亦不用考虑。

相邻两次检索时，出现次数相同的两个字符必然在两次检索中不完全相同——这是显然的。

若存在两次检索，其中第三个字符出现次数都为前两个字符出现次数减一，且前两个字符在两次检索中不完全相同。不妨设第一次检索时 $a,b$ 相同，而后一次检索时 $a,c$ 相同。假如右移会使 $a,b$ 之一出现次数增加，则只需在第一次检索时右移 $r$ 即可；否则，则右移会使 $c$ 增加，则只需在第二次检索时右移 $r$ 即可。

同理，若存在两次不同检索，其中第三个字符出现次数为前两个字符加一，则上述分析对左移 $r$ 类似生效，也不用考虑。

则依据上述分类讨论，我们无法处理的就仅有如下一种情形：第一次检索，$a,b$ 相同，$c$ 等于其加一；第二次检索，$a,c$ 相同，$b$ 等于其减一，其后的检索不断重复这一流程。或者与之相反，即第一次检索中是减一，第二次检索中是加一。

注意到这种流程仅限于连续的 `BCSBCSBCS` 串间。于是我们预处理一下，假如检索到了连续的 `BCS` 段，则跳过整段。这样，有效检索次数就只是常数的。

对于每个 $r$，检索次数都是常数次的，而 $r=n$ 特别地需要额外 $O(n)$ 次检索，故共计 $O(n)$ 次检索。检索的复杂度用子序列自动姬即可做到常数，验证区间合法与否的复杂度也可用前缀和做到常数，故总复杂度线性。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,nex[1001000][3],sum[1001000][3],mx;
char s[1001000];
bool chevalid(int l,int r){
	if(l>r)return true;
	int a0=sum[r][0]-sum[l-1][0],a1=sum[r][1]-sum[l-1][1],a2=sum[r][2]-sum[l-1][2];
	if(a0==a1||a1==a2||a2==a0)return false;
	mx=max(mx,r-l+1);return true;
}
int main(){
	scanf("%d%s",&n,s+1);
	for(int i=1;i<=n;i++){
		if(s[i]=='B')s[i]=0;
		if(s[i]=='C')s[i]=1;
		if(s[i]=='S')s[i]=2;
	}
	for(int j=0;j<3;j++)nex[n][j]=n+1;
	for(int i=n-1;i>=0;i--){
		for(int j=0;j<3;j++)nex[i][j]=nex[i+1][j];
		nex[i][s[i+1]]=i+1;
	}
	for(int i=1;i<=n;i++){
		for(int j=0;j<3;j++)sum[i][j]=sum[i-1][j];
		sum[i][s[i]]++;
	}
	for(int r=1;r<=n;r++){
		int l=1;
		if(chevalid(l,r))continue;
		if(sum[r][0]==sum[r][1]&&sum[r][1]==sum[r][2])l++;
		while(l<=r){
			int a0=sum[r][0]-sum[l-1][0],a1=sum[r][1]-sum[l-1][1],a2=sum[r][2]-sum[l-1][2];
			if(a0==a1)l=min(nex[l-1][0],nex[l-1][1])+1;
			if(a1==a2)l=min(nex[l-1][1],nex[l-1][2])+1;
			if(a0==a2)l=min(nex[l-1][0],nex[l-1][2])+1;
			if(l>r)break;
			if(r!=n&&chevalid(l,r+1))break;
			if(chevalid(l,r))break;
			if(chevalid(l,r-1))break;
		}
	}
	for(int l=1,r=1;l<=n;l=r){
		while(r<=n&&s[l]==s[r])r++;
		mx=max(mx,r-l);
	}
	printf("%d\n",mx);
	return 0;
}
```

---

## 作者：huangrenheluogu (赞：1)

根本没有观察力，想不到题解区的神秘 $\mathcal{O}(n)$ 做法，于是拼暴力。

首先进行一个转化，记 $c_{B,i}$ 表示 $1\sim i$ `Ｂ` 的数量，其余同理。对于一个点，搞出一个三元组 $(c_{B,i}-c_{C,i},c_{B,i}-c_{S,i},c_{C,i}-c_{S,i})$。然后 $[l,r]$ 合法等价于 $l-1$ 和 $r$ 的三元组有 $1$ 个相等。不妨第 $i$ 个位置的值是 $(a_i,b_i,c_i)$。

考虑分治处理，把 $a$ 排序，然后在组内把 $b$ 排序。左边的 $b$ 和尝试右边 $\lt b$ 的地方匹配；右边同理。匹配相当于是维护前面这些地方编号的左右端点，以及次端点。处理 $a$ 的时候注意不一定是完全偏序的，可能存在一段相等的情况，因此需要分两部分处理。复杂度 $\mathcal{O}(n\log n)$。

```cpp
#include<bits/stdc++.h>
#define mid (l + r >> 1)
using namespace std;
const int N = 1e6 + 5, inf = 0x3f3f3f3f;
int cnt[N][3], n, ans;
char s[N];
int mna;
struct node{
    int a, b, c, id;
    inline void print(){
        printf("%d %d %d %d\n", id, a, b, c);
    }
}a[N], b[N];
inline void chkmax(int &x, int y){
    if(x < y) x = y;
}
inline void chkmin(int &x, int y){
    if(x > y) x = y;
}
inline bool chkin(int l, int r, int x){
    return l <= x && x <= r;
}
struct info{
    int l, r, ll, rr, cl, cr;
    inline void init(){
        l = ll = inf, r = rr = -inf;
        cl = cr = inf;
    }
    inline void ins(int x, int c){
        if(x < l){
            if(c != cl) ll = l;
            cl = c, l = x;
        }
        else if(x < ll && c != cl){
            ll = x;
        }
        if(x > r){
            if(c != cr) rr = r;
            cr = c, r = x;
        }
        else if(x > rr && c != cr){
            rr = x;
        }
    }
    inline void query(int x, int c){
        if(c ^ cl) chkmax(ans, x - l);
        else chkmax(ans, x - ll);
        if(c ^ cr) chkmax(ans, r - x);
        else chkmax(ans, rr - x);
        // if(ans == 4){
        //     printf("%d %d %d %d %d %d %d %d\n", l, ll, cl, r, rr, cr, x, c);
        //     exit(0);
        // }
    }
}L, R;
inline void calc(int l, int r, int Ll, int Lr, int Rl, int Rr){
    int i = l, j = mid + 1;
    L.init(), R.init();
    int ki, kj, mn, mni, mnj;
    while(i <= mid || j <= r){
        mni = (i <= mid) ? a[i].b : inf;
        mnj = (j <= r) ? a[j].b : inf;
        mn = min(mni, mnj);
        for(ki = i - 1; ki < mid && a[ki + 1].b == mn; ki++) ;
        for(kj = j - 1; kj < r && a[kj + 1].b == mn; kj++) ;
        for(int k = i; k <= ki; k++){
            if(!chkin(Ll, Lr, a[k].a)) continue ;
            R.query(a[k].id, a[k].c);
        }
        for(int k = j; k <= kj; k++){
            if(!chkin(Rl, Rr, a[k].a)) continue ;
            L.query(a[k].id, a[k].c);
        }
        for(int k = i; k <= ki; k++){
            if(!chkin(Ll, Lr, a[k].a)) continue ;
            L.ins(a[k].id, a[k].c);
        }
        for(int k = j; k <= kj; k++){
            if(!chkin(Rl, Rr, a[k].a)) continue ;
            R.ins(a[k].id, a[k].c);
        }
        i = ki + 1, j = kj + 1;
    }
}
inline void solve(int l, int r){
    if(l == r) return ;
    solve(l, mid), solve(mid + 1, r);
    mna = inf;
    for(int i = mid + 1; i <= r; i++){
        chkmin(mna, a[i].a);
    }
    calc(l, r, -inf, mna - 1, mna, inf);
    calc(l, r, -inf, mna, mna + 1, inf);
    int i = l, j = mid + 1, k = l;
    while(k <= r){
        if(i <= mid && (j > r || a[i].b <= a[j].b)){
            b[k++] = a[i++];
        }
        else{
            b[k++] = a[j++];
        }
    }
    for(int i = l; i <= r; i++){
        a[i] = b[i];
    }
}
inline void debug(){
    a[1] = {0, 1, 1, 99998};
    a[0] = {1, 1, 0, 1};
    solve(0, 1);
    printf("%d\n", ans);
    exit(0);
}
int main(){
    // freopen("fragment.in", "r", stdin);
    // freopen("fragment.out", "w", stdout);
    scanf("%d%s", &n, s + 1);
    for(int i = 1, j; i <= n; i = j){
        for(j = i; j <= n && s[j] == s[i]; j++);
        chkmax(ans, j - i);
    }
    for(int i = 1; i <= n; i++){
        cnt[i][0] = cnt[i - 1][0];
        cnt[i][1] = cnt[i - 1][1];
        cnt[i][2] = cnt[i - 1][2];
        if(s[i] == 'B') cnt[i][0]++;
        if(s[i] == 'C') cnt[i][1]++;
        if(s[i] == 'S') cnt[i][2]++;
        a[i] = {cnt[i][0] - cnt[i][1], cnt[i][0] - cnt[i][2], cnt[i][1] - cnt[i][2], i};
    }
    // for(int i = 0; i <= n; i++){
    //     a[i].print();
    // }
    sort(a, a + n + 1, [&](node x, node y){
        if(x.a ^ y.a) return x.a < y.a;
        if(x.b ^ y.b) return x.b < y.b;
        if(x.c ^ y.c) return x.c < y.c;
        return x.id < y.id;
    });
    solve(0, n);
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：Code_星云 (赞：1)

首先对于每个位置，求出其前缀的 $B$、$C$、$S$ 的出现次数的差，分别记为 $a,b,c$，并将其视为一个三元组 $(a,b,c)$。此时很容易得到一个区间 $[l,r]$ 满足条件，当且仅当 $l$ 和 $r$ 的三元组，对应位置元素都不相同。

然后就化为了一个三位偏序问题，且连接符号是不等号。考虑对第一维排序，用树状数组维护第二位。考虑如何维护第三维。由于这题只需要维护不等号，所以我们在树状数组里面维护出最大值和次大值，并且强行要求取到次大值时第三维的值不能等于取到最大值时的。

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 2000005;
struct node{int x, y, z, id;}; node p[N];
int n, ca, cb, cc, ans;

namespace BIT{
	int lowmin1[N], lowmin2[N], lowmax1[N], lowmax2[N], upmin1[N], upmin2[N], upmax1[N], upmax2[N];
	int lowbit(int x){return x & (- x);}
	void update(int x){
		int y = p[x].y, z = p[x].z, id = p[x].id;
		for(int i = y; i <= 2 * n + 1; i += lowbit(i)){
			if(id > p[lowmax1[i]].id){
				if(z != p[lowmax1[i]].z) lowmax2[i] = lowmax1[i];
				lowmax1[i] = x;
			}else if(z != p[lowmax1[i]].z && id > p[lowmax2[i]].id) lowmax2[i] = x;
			if(id < p[lowmin1[i]].id){
				if(z != p[lowmin1[i]].z) lowmin2[i] = lowmin1[i];
				lowmin1[i] = x;
			}else if(z != p[lowmin1[i]].z && id < p[lowmin2[i]].id) lowmin2[i] = x;
		}
		for(int i = y; i; i -= lowbit(i)){
			if(id > p[upmax1[i]].id){
				if(z != p[upmax1[i]].z) upmax2[i] = upmax1[i];
				upmax1[i] = x;
			}else if(z != p[upmax1[i]].z && id > p[upmax2[i]].id) upmax2[i] = x;
			if(id < p[upmin1[i]].id){
				if(z != p[upmin1[i]].z) upmin2[i] = upmin1[i];
				upmin1[i] = x;
			}else if(z != p[upmin1[i]].z && id < p[upmin2[i]].id) upmin2[i] = x;
		}
	}
	void query(int x){
		int y = p[x].y, z = p[x].z, id = p[x].id;
		for(int i = y - 1; i; i -= lowbit(i)){
			if(p[lowmax1[i]].z == z) ans = max(ans, p[lowmax2[i]].id - id);
			else ans = max(ans, p[lowmax1[i]].id - id);
			if(p[lowmin1[i]].z == z) ans = max(ans, id - p[lowmin2[i]].id);
			else ans = max(ans, id - p[lowmin1[i]].id);
		}
		for(int i = y + 1; i <= 2 * n + 1; i += lowbit(i)){
			if(p[upmax1[i]].z == z) ans = max(ans, p[upmax2[i]].id - id);
			else ans = max(ans, p[upmax1[i]].id - id);
			if(p[upmin1[i]].z == z) ans = max(ans, id - p[upmin2[i]].id);
			else ans = max(ans, id - p[upmin1[i]].id);
		}
	}
};
using namespace BIT;

bool cmp(node &r1, node &r2){return r1.x < r2.x;}
bool cmp2(node &r1, node &r2){return r1.x > r2.x;}
int main(){
	scanf("%d", &n); int tmp; char lst = '&';
	for(int i = 1; i <= n; i ++){
		char c; cin >> c; ca += (c == 'B'); cb += (c == 'C'); cc += (c == 'S');
		p[i].x = cb - ca; p[i].y = cc - cb + n + 1; p[i].z = cc - ca; p[i].id = i;
		if(c == lst) tmp ++; else tmp = 1; lst = c; ans = max(ans, tmp);
	}
	if(ca != cb && cb != cc && cc != ca){printf("%d\n", n); return 0;}
	sort(p + 1, p + n + 1, cmp); p[n + 1].id = - 1; p[n + 2].id = n + 2;
	for(int i = 1; i <= 2 * n + 1; i ++) lowmin1[i] = lowmin2[i] = upmin1[i] = upmin2[i] = n + 2;
	for(int i = 1; i <= 2 * n + 1; i ++) lowmax1[i] = lowmax2[i] = upmax1[i] = upmax2[i] = n + 1;
	for(int j, i = 1; i <= n; i = j + 1){
		for(j = i, query(j); j < n && p[j + 1].x == p[j].x; query(++ j));
		for(j = i, update(j); j < n && p[j + 1].x == p[j].x; update(++ j));
	}
	sort(p + 1, p + n + 1, cmp2); p[n + 1].id = -1, p[n + 2].id = n + 2;
	for(int i = 1; i <= 2 * n + 1; i ++) lowmin1[i] = lowmin2[i] = upmin1[i] = upmin2[i] = n + 2;
	for(int i = 1; i <= 2 * n + 1; i ++) lowmax1[i] = lowmax2[i] = upmax1[i] = upmax2[i] = n + 1;
	for(int j, i = 1; i <= n; i = j + 1){
		for(j = i, query(j); j < n && p[j + 1].x == p[j].x; query(++ j));
		for(j = i, update(j); j < n && p[j + 1].x == p[j].x; update(++ j));
	}
	printf("%d\n", ans); return 0;
}
```


---

## 作者：chenxia25 (赞：1)

奇怪的整体二分做法。虽然复杂度劣于标算，但做法自然，十分好想。

首先把连续段的贡献处理掉。然后算三种颜色出现次数互不相同的最长子串，考虑扫描线，也就是对每一个 $r$ 找最小的合法的 $l$。

设 $a_i$ 表示 $1\sim i$ 中 $\texttt B$ 与 $\texttt C$ 的数量差，$b_i, c_i$ 类似，是另外两种颜色对的数量差。那么 $[l, r]$ 合法显然等价于 $a_{l - 1} \neq a_r, b_{l - 1} \neq b_r, c_{l - 1} \neq c_r$，也就是三元组 $(a, b, c)$ 中不能存在任何一个位置对应相等。

这时候其实不用考虑 $l \leq r$ 的限制，因为如果最小的满足 $(a, b, c)$ 与 $r$ 对应位置互不相同的 $l$ 比 $r$ 大的话，那依然可以判断出没有贡献。

考虑对每个 $r$ 二分出最小的 $l$。如何判断 $[L, R]$ 内的三元组是否都与 $r$ 的三元组存在至少一个位置对应相等？简单地容斥一下：用 $a, b, c$ 分别的重复次数，减去两倍的 $(a, b, c)$ 三元组整体重复的次数，就是 $[L, R]$ 内不合法的三元组的数量，看它是否等于 $R - L + 1$ 就行。

但是想要查询一个区间内等于某个数的数量，需要动态开点线段树（然后线段树二分，才能做到 1log），而且还要开四棵，在这题上空间开不下。用平衡树的话，虽然空间线性了，但无法把二分放到树上去（因为有四棵树要一起二分，而平衡树不能保证它们形态相同），只能 2log，也过不了。

那就考虑整体二分，它善于降解普通二分时用到的数据结构。在这题上，整体二分后就没有「区间查询」了，因为可以暴力扫描整个区间，装到桶里，查询也是 $\mathrm O(1)$ 的。于是时间复杂度 $\mathrm O(n\log n)$，空间复杂度 $\mathrm O(n)$。

```cpp
const int N = 1e6 + 10;

int n;
char s[N];
int a[N], b[N], c[N], abc[N];

int fd[N];

void solve(int l, int r, vi &v) {
  if(v.empty()) return;
  if(l == r) {
    for(int x : v) fd[x] = l;
    return;
  }
  int mid = l + r >> 1;
  static int sum[N];
  for(auto pr : {mkp(a, 1), mkp(b, 1), mkp(c, 1), mkp(abc, -2)}) {
    int *p = pr.fi, coef = pr.se;
    static int cnt[N];
    for(int i = l; i <= mid; ++i) ++cnt[p[i]];
    for(int x : v) sum[x] += coef * cnt[p[x]];
    for(int i = l; i <= mid; ++i) cnt[p[i]] = 0;
  }
  vi lv, rv;
  for(int x : v) {
    if(sum[x] == mid - l + 1) rv.pb(x);
    else lv.pb(x);
    sum[x] = 0;
  }
  vi().swap(v);
  solve(l, mid, lv), solve(mid + 1, r, rv);
}

void mian() {
  cin >> n >> s + 1;
  for(int i = 1; i <= n; ++i) {
    a[i] = a[i - 1], b[i] = b[i - 1], c[i] = c[i - 1];
    if(s[i] == 'B') ++a[i], --b[i];
    else if(s[i] == 'C') ++b[i], --c[i];
    else ++c[i], --a[i];
  }
  for(int *d : {a, b, c}) {
    int mn = *min_element(d, d + n + 1);
    for(int i = 0; i <= n; ++i) d[i] -= mn;
  }
  map<tuple<int, int, int>, int> mp;
  int m = 0;
  for(int i = 0; i <= n; ++i) {
    int &id = mp[make_tuple(a[i], b[i], c[i])];
    if(!id) id = ++m;
    abc[i] = id;
  }
  vi v; for(int i = 1; i <= n; ++i) v.pb(i);
  solve(0, n, v);
  dbga(fd, 1, n);
  int ans = 0;
  for(int i = 1; i <= n; ++i) cmx(ans, i - fd[i]);
  for(int i = 1, ie; i <= n; i = ie + 1) {
    ie = i; while(ie < n && s[ie + 1] == s[i]) ++ie;
    cmx(ans, ie - i + 1);
  }
  cout << ans << nl;
}
```

---

## 作者：M1saka16I72 (赞：1)

## 前言

[更可爱的阅读体验](https://misaka16172.github.io/solution-p3590.html)

神秘新颖好玩的题，有个不知道是啥的做法，感觉讲不太明白。。

## 思路

第一步转化应该比较简单，先前缀和，然后 $[l,r]$ 合法相当于 $\forall x,y\in \{B,C,S\},pre_{r,x}-pre_{l-1,x}≠pre_{r,y}-pre_{l-1,y}$，即 $pre_{r,x}-pre_{r,y}≠pre_{l-1,x}-pre_{l-1,y}$，相当于得到三个数组 $a_{i,0}=pre_{i,B}-pre_{i,C},a_{i,1}=pre_{i,B}-pre_{i,S},a_{i,2}=pre_{i,C}-pre_{i,S}$，要对每个 $r$ 检查三维都与自己不一样的最小的 $l$。

如果这个问题只有一维就很简单：维护前缀的最小值和颜色与最小值**不同**的次小值，这样颜色与最小值不同时直接匹配最小值，否则匹配次小值即可。但二维和三维的问题就无法简单维护了，看起来需要进行很多分讨。

这个时候尝试建出一个 DAG 状物，每次更新时动态在里面一边走一边尝试加点，假如当前所在的点为 $u$（初始为最小值 $0$），已经走过的边权集合为 $S$，要加的点是 $v$，枚举边权 $w\in \{0,1,2\}$，若 $a_{u,w}≠a_{v,w}$ 且 $w\notin S$，如果 $u$ 还没有边权为 $w$ 的出边就连接 $(u,v,w)$ 这条边，否则就沿这条出边走到下一个点并重复加边过程，直到某次成功加上边或者走过的边集已经是全集 $\{0,1,2\}$ 为止。

查询的时候就在这个图上从 $0$ 开始走，若当前点 $u$ 第 $i$ 维跟要查询的第 $i$ 维相等，就走到 $nxt_{u,i}$，如果三维都不相等就更新答案，最后把所有路径上的答案取 $\min$ 即可。

注意一个点可能会被连入多条边，例如 $(0,1,0)$ 和 $(0,1,1)$ 两条边，但两条入边的意义是不同的，所以需要用虚点来建图。即 $a_{0,0}≠a_{1,0}$ 且 $a_{0,1}≠a_{1,1}$ 时，可以建出两个虚点 $2$ 和 $3$，它们两个代表的实点都是 $1$，然后分别连 $(0,2,0)$ 和 $(0,3,1)$。

到这里可能会看得比较云里雾里，把这个建图和查询时在图上走的过程画图手玩一下可以帮助理解。

图上的点数是常数级的，所以总复杂度 $\mathcal{O}(n)$。注意特判整个区间都是一个字符的情况。

## 代码

```cpp
constexpr int N = 1e6+5;

int n,a[N][3];
int nxt[N][3],id[N],cnt = 0;

void insert(int u,int s,int v){
    for(int i=0;i<3;i++){
        if(a[id[u]][i]==a[v][i] || (s>>i&1))    continue;
        if(nxt[u][i]==-1)  nxt[u][i] = ++cnt,id[cnt] = v;
        else    insert(nxt[u][i],s|(1<<i),v);
    }
}

int query(int u,int v){
    if(u==-1)   return inf;
    bool flg = 1;
    int res = inf;
    for(int i=0;i<3;i++){
        if(a[id[u]][i]==a[v][i]){
            flg = 0;
            int now = query(nxt[u][i],v);
            res = min(res,now);
        }
    }
    if(flg) res = min(res,id[u]);
    return res;
}

void solve(){
    cin>>n;
    int ans = 1,now = 0,lst = -1;
    int Cnt[3] = {};
    for(int i=1;i<=n;i++){
        char c;cin>>c;
        int t = (c=='B'?0:(c=='C'?1:2));
        Cnt[t]++;
        a[i][0] = Cnt[0]-Cnt[1],a[i][1] = Cnt[0]-Cnt[2],a[i][2] = Cnt[1]-Cnt[2];
        if(t==lst)  now++,ans = max(ans,now);
        else    now = 1;
        lst = t;
    }
    reset(nxt,-1);
    for(int i=1;i<=n;i++){
        int now = query(0,i);
        ans = max(ans,i-now);
        insert(0,0,i);
    }
    cout<<ans;
}
```

---

## 作者：Tracy_Loght (赞：0)

## 题目分析：

分三种情况考虑，前两种情况跳过也不是不可以。

### 只有一种字符：

显然，直接全选即可。

### 有两种字符：

显然，如果全选时两种字符个数不一样，答案就是 $n$。

而不合法的情况只有两种字符个数**一样**，则接下来，我们随便去掉左端点或右端点即可。

答案的区间为：$(2,n)$ 或 $(1,n-1)$。

显然答案只有这两个值：$n-1$ 和 $n$。

### 有三种字符

也是来到了这一道题。

根据前面的猜想，这一定是从左或右端点开始去掉，逐渐向中间靠拢。

你可以写一个这样的代码来验证一下：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll Mx=1000001;
ll n,jl,o[Mx],k[5];
ll a[Mx],b[Mx],c[Mx];
int main(){
	ios::sync_with_stdio(0);
	std::cin.tie(0);
	std::cout.tie(0);
	cin>>n;
	for(ll i=1;i<=n;i++){
		char x;cin>>x;
		if(x=='C') {o[i]=1;a[i]=1;}
		else if(x=='B') {o[i]=2;b[i]=1;}
		else if(x=='S') {o[i]=3;c[i]=1;}
	}
	
	ll as=1;								//对于只有一种字符的时候 
	for(ll i=1;i<=n+1;i++){
		if(o[i]==o[i-1]) as++;
		else{jl=max(as,jl);as=1;}
	}
	
	for(ll i=1;i<=n;i++) a[i]=a[i-1]+a[i];	//前缀和 
	for(ll i=1;i<=n;i++) b[i]=b[i-1]+b[i];
	for(ll i=1;i<=n;i++) c[i]=c[i-1]+c[i];
	for(ll i=1;i<=n/2;i++){					//显然从前往后和从后往前一个只需要一半即可 
		if(jl>=n-i+1) break;				//特判 
		for(ll j=0;j<=n/2;j++){				//i: 是从第i个开始 
			ll a_=a[n-j]-a[i-1];			//j: 是删除后j个 
			ll b_=b[n-j]-b[i-1];
			ll c_=c[n-j]-c[i-1];
			if(a_!=b_&&b_!=c_&&a_!=c_) {	//显然，既然有大的，为什么还要搜小的 
				jl=max(jl,n-i-j+1);
				break;
			}
		}
	}
	cout<<jl;
	return 0;
}
```

发现对了九个，剩下的一个超时。

而对的点用时很少，不妨猜测其答案的左端点或右端点有一个离边界很近。

需要找最近吗？

答案是显然的，完全不需要，$10^6$ 的话随便跑几十个即可。

当然，如果你想知道最近的边界，请去榜一大哥那，谢谢。

## 代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,jl,o[1000001],k[5],ox[1000001];
int main(){
	ios::sync_with_stdio(0);
	std::cin.tie(0);
	std::cout.tie(0);
	cin>>n;
	for(ll i=1;i<=n;i++){
		char a;cin>>a;
		if(a=='C') o[i]=1;
		if(a=='B') o[i]=2;
		if(a=='S') o[i]=3;
	}
	ll as=1;
	for(ll i=1;i<=n+1;i++){
		if(o[i]==o[i-1]) as++;
		else{
			jl=max(as,jl);
			as=1;
		}
	}
	for(ll i=1;i<=3;i++){
		k[1]=k[2]=k[3]=0;
		for(ll j=i;j<=n;j++){
			k[o[j]]++;
			if(k[1]!=k[2]&&k[2]!=k[3]&&k[1]!=k[3]) jl=max(jl,j-i+1);
		}
	}
	for(ll i=1;i<=n;i++) ox[n-i+1]=o[i];
	for(ll i=1;i<=3;i++){
		k[1]=k[2]=k[3]=0;
		for(ll j=i;j<=n;j++){
			k[ox[j]]++;
			if(k[1]!=k[2]&&k[2]!=k[3]&&k[1]!=k[3]) jl=max(jl,j-i+1);
		}
	}
	cout<<jl;
	return 0;
}
```

**课后作业**：如果有四种字符呢？

---


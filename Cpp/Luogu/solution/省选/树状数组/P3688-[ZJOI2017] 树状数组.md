# [ZJOI2017] 树状数组

## 题目描述

漆黑的晚上，九条可怜躺在床上辗转反侧。难以入眠的她想起了若干年前她的一次悲惨的 OI 比赛经历。那是一道基础的树状数组题。

给出一个长度为 $n$ 的数组 $A$，初始值都为 $0$，接下来进行 $m$ 次操作，操作有两种：

* $1\ x$，表示将 $A_x$  变成 $(A_x + 1) \bmod 2$。
* $2\ l\ r$，表示询问 $(\sum_{i=l}^r A_i) \bmod 2$。

尽管那个时候的可怜非常的 simple，但是她还是发现这题可以用树状数组做。当时非常 young 的她写了如下的算法：

![](https://cdn.luogu.com.cn/upload/pic/4744.png)

其中 $\mathrm{lowbit}(x)$ 表示数字 $x$ **最低**的非 $0$ 二进制位，例如 $\text{lowbit}(5) = 1, \text{lowbit}(12) = 4$。进行第一类操作的时候就调用 $\mathrm{Add}(x)$，第二类操作的时候答案就是 $\mathrm{Query}(l, r)$。

如果你对树状数组比较熟悉，不难发现可怜把树状数组写错了：**$\text{Add}$ 和 $\text{Find}$ 中 $x$  变化的方向反了**。因此这个程序在最终测试时华丽的爆 0 了。

然而奇怪的是，在当时，这个程序通过了出题人给出的大样例——这也是可怜没有进行对拍的原因。

现在，可怜想要算一下，这个程序回答对每一个询问的概率是多少，这样她就可以再次的感受到自己是一个多么非的人了。然而时间已经过去了很多年，即使是可怜也没有办法完全回忆起当时的大样例。幸运的是，她回忆起了大部分内容，唯一遗忘的是每一次第一类操作的 $x$ 的值，因此她假定这次操作的 $x$ 是在 $[l_i, r_i]$  范围内**等概率随机**的。

具体来说，可怜给出了一个长度为 $n$ 的数组 $A$，初始为 $0$，接下来进行了 $m$ 次操作：

* $1\ l\ r$，表示在区间 $[l, r]$ 中等概率选取一个 $x$ 并执行 $\text{Add}(x)$ 。

* $2\ l\ r$，表示询问执行 $\text{Query}(l, r)$ 得到的结果是正确的概率是多少。

## 说明/提示

#### 样例说明

在进行完 $\mathrm{Add}(3)$ 之后，$A$ 数组变成了 $[0, 1, 1, 0, 0]$。所以前两次询问可怜的程序答案都是 $1$，因此第一次询问可怜一定正确，第二次询问可怜一定错误。

#### 数据范围

| 测试点编号 |        $n$         |              $m$               |      其他约定      |
| :--------: | :----------------: | :----------------------------: | :----------------: |
|    $1$     |      $\le 5$       |            $\le 10$            |         无         |
|    $2$     |      $\le 50$      |      $\le 50$      |         无         |
|    $3$     |      $\le 50$      |      $\le 50$      |         无         |
|    $4$     | $\le 3\times 10^3$ | $\le 3\times 10^3$ |         无         |
|    $5$     | $\le 3\times 10^3$ | $\le 3\times 10^3$ |         无         |
|    $6$     |       $10^5$       |       $10^5$       | 所有询问都在修改后 |
|    $7$     |       $10^5$       |       $10^5$       | 所有询问都在修改后 |
|    $8$     |       $10^5$       |       $10^5$       |         无         |
|    $9$     |       $10^5$       |       $10^5$       |         无         |
|    $10$    |       $10^5$       |       $10^5$       |         无         |


对于 $100\%$ 的数据，保证 $1\leq l\leq r\leq n$。

更新：2018/05/13 @larryzhong 提供了 5 组强的数据。

## 样例 #1

### 输入

```
5 5
1 3 3
2 3 5
2 4 5
1 1 3
2 2 5```

### 输出

```
1
0
665496236```

# 题解

## 作者：鬼·烨弑 (赞：27)

题目说其add和find的方向反了，即求成了后缀和；

对于询问l~r的区间和，正常是 sum[r] - sum[l - 1];

但是九条误弄成了 sum[r - 1] - sum[l - 2];(因为取模转正 所以无负数 变一下符号)

所以题目的询问即为val[r] == val[l - 1] 的概率；

设一个二元组（l,r）,记录val[l] == val[r] 的概率；

因此修改可以看作是区间修改，查询为单点查询；又因为要维护二元组

所以树套树没得跑了QAQ，发现没有区间查，标记永久化一下；

具体考虑的话，外层维护l，内层维护r。

如果以前val[l] == val[r] 相同的概率为P，对于一次操作，不会使其变化的概率为Q

则新的概率为 P * Q + （1 - P） * （1 - Q）；

接下来大力讨论。。。 设修改区间为 L ~ R

<1> l 在 [1,L - 1] ,r在[L,R],使其变化的概率为1 /（R - L + 1）;

<2> l 在[L,R] ,r 在[R + 1,n],使其变化的概率为 1 / (R - L + 1);

<3> l 在[L，R]，r 在[L,R] 使其变化的概率为 2 / (R - L + 1)；

~~

一种特殊情况: l == 1 发现 是 前缀和等于后缀和，（具体你看（模拟）一下就知道）

于是我们在第一维上单独开一个0点，维护前缀等于后缀的情况；

大力讨论：

<1> r < L 和 r > R 则一定会有影响；

<2> L <= r <= R 则有 1 / (R - L + 1) 的概率不会有影响；

CODE：
```cpp
#include<set>
#include<map>
#include<queue>
#include<cstdio>
#include<string>
#include<cstring>
#include<iostream>
#include<algorithm>
#define R register
#define ll long long
using namespace std;
inline int read()
{
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return x*f;
}
const int N = 1e5 + 1000,mod = 998244353;
int n,T,cnt;
int rt[(N << 2) + 1000];
struct node{int ls,rs,v;} tr[N * 400];
ll ksm(ll x,ll y){ll res = 1; for(;y;y >>= 1,x = x * x % mod) if(y & 1) res = res * x % mod; return res;}
ll mul(ll p,ll q){ll res = p * q % mod; res = (res + (1 - p) * (1 - q) % mod) % mod; return (res + mod) % mod;}
void changey(int &k,int l,int r,int x,int y,ll p)
{
	if(!k){k = ++ cnt; tr[k].v = 1;}
	if(x <= l && y >= r) {tr[k].v = mul(tr[k].v,p); return;}
	int mid = (l + r) >> 1;
	if(x <=  mid) changey(tr[k].ls,l,mid,x,y,p);
	if(y > mid)   changey(tr[k].rs,mid + 1,r,x,y,p);
}
void changex(int k,int l,int r,int lx,int rx,int ly,int ry,ll p)
{
	if(lx <= l && rx >= r){changey(rt[k],1,n,ly,ry,p); return ;}
	int mid = (l + r) >> 1;
	if(lx <= mid) changex(k << 1,l,mid,lx,rx,ly,ry,p);
	if(rx > mid)  changex(k << 1 | 1,mid + 1,r,lx,rx,ly,ry,p);
}

ll asky(int k,int l,int r,int pos)
{
	if(!k) return 1;
	if(l == r) return tr[k].v;
	int mid = (l + r) >> 1;
	if(pos <= mid) return mul(tr[k].v,asky(tr[k].ls,l,mid,pos));
	else return mul(tr[k].v,asky(tr[k].rs,mid + 1,r,pos));
}

ll askx(int k,int l,int r,int posx,int posy)
{
	if(l == r) return asky(rt[k],1,n,posy);
	int mid = (l + r) >> 1;
	if(posx <= mid) return mul(askx(k << 1,l,mid,posx,posy),asky(rt[k],1,n,posy));
	else return mul(askx(k << 1 | 1,mid + 1,r,posx,posy),asky(rt[k],1,n,posy));
}

int main()
{
	n = read(); T = read();
	ll p; int opt,l,r;
	while(T --)
	{
		opt = read(); l = read(); r = read();
		if(opt == 1)
		{
			p = ksm(r - l + 1,mod - 2);
			if(l > 1) changex(1,0,n,1,l - 1,l,r,(1 - p + mod) % mod),changex(1,0,n,0,0,1,l - 1,0);
			if(r < n) changex(1,0,n,l,r,r + 1,n,(1 - p + mod) % mod),changex(1,0,n,0,0,r + 1,n,0);
			changex(1,0,n,l,r,l,r,(1 - 2ll * p + mod) % mod); changex(1,0,n,0,0,l,r,p);
		}
		else cout << askx(1,0,n,l - 1,r) << "\n";
	}
	return 0;
}
```



---

## 作者：shadowice1984 (赞：22)

二维线段树神题......


首先我们发现如果reverse下树状数组所操作的数组的话，它写的代码是完全**正确的**，但是reverse之后前缀变成了后缀，所以，它写了一个正确的单点修改求**后缀和**的数据结构


那么我们发现，对于一个通常的询问，其实是在询问(l-1,r)这两个点相同的概率

，然后一个错误的思路是用线段树维护每一个点被修改的概率，但是这样做是错的，因为对于一次操作，修改且只修改**一个点**，如果按照线段树来做，其实是会导致一次操作修改多个点的


那怎么办呢，二维线段树好了，因为它可以同时维护两维的信息


设二元组(x,y)的值表示位置为x的点和位置为y的点相同的概率


那么我们发现，对于一个操作(l,r)，设这次操作的区间长度为len


他会对三种类型的二元组产生影响


1.左端点在(l,r)内且右端点不在(l,r)的二元组


2.右端点在(l,r)内且左端点不在(l,r)的二元组


3.左右端点**同时**在(l,r)内的二元组


对于第一种和第二种二元组，这次修改有1/len的概率取反它们，对于第3种二元组这次修改有2/len的概率取反它们（因为不存在同时落在x和y上的操作，每次操作之后修改一个点）


那么这是一个矩形修改问题，片改点查

考虑用二位线段树存储修改，也就是大家通常说的，标记永久化

#### 标记永久化

这是一种处理片改点查的技术

单点查询的本质就是把包含这个点的区间全部并起来


比如像这样一颗线段树


\----------------------------------------------


\-------------------- \------------------------


\---------- \--------- \------------ \-----------


\---- \----- \--- \----- \----- \------ \----- \-----


\*
        
打型号的点表示我们要查询的点，那么他会“穿过”四个区间，如果这些区间上包含了所有的信息，我们就根本不需要标记，直接在递归的时候把每一个区间上的值并起来就好，所以我们可以在修改的时候运用线段树的区间拆分法，在每一个刚刚好的区间做修改，而在查询的时候一路并上去就好了


# 特判

发现l==1的时候询问的是前缀和是否等于后缀和


单开一个线段树记录即可，注意特判


上代码~


```C
#include<cstdio>
#include<algorithm>
using namespace std;
typedef long long ll;
ll mod=998244353;
const int N=100010;
int n;int m;
inline ll inv(ll a){ll r=1;for(ll p=mod-2;p;p>>=1,a=(a*a)%mod)if(p&1)r=(r*a)%mod;return r;}
inline ll mg(ll a,ll b){return (((1+mod-a)*b)%mod+((1+mod-b)*a)%mod)%mod;}//概率合并函数 
struct sqr_linetree
{
    ll val[360*N];int s[2][360*N];int root[4*N];int cnt;
    inline void newnode(int p,int tp){s[tp][p]=++cnt;}
    inline void newtree(int p){root[p]=++cnt;}//动态开点 
    inline void add(int p,int l,int r,int dl,int dr,ll plus)
    {
        if(dl==dr)return;  
        if(dl==l&&dr==r){val[p]=mg(val[p],plus);return;}//直接做操作，无需打标记 
        int mid=(l+r)/2;
        if(dl<mid){if(s[0][p]==0)newnode(p,0);add(s[0][p],l,mid,dl,min(dr,mid),plus);}
        if(mid<dr){if(s[1][p]==0)newnode(p,1);add(s[1][p],mid,r,max(dl,mid),dr,plus);}
    }
    inline ll sum(int p,int l,int r,int x)
    {
        if(p==0)return 0;
        if(r-l==1){return val[p];}int mid=(l+r)/2;
        if(x<=mid)return mg(val[p],sum(s[0][p],l,mid,x));//一路并上所有涉及这个点的修改 
        else return mg(val[p],sum(s[1][p],mid,r,x));
    }
    inline void sqadd(int p,int l,int r,int xl,int xr,int dl,int dr,ll plus)
    {
        if(dl==dr)return;
        if(dl==l&&dr==r){if(root[p]==0)newtree(p);add(root[p],0,n,xl,xr,plus);return;}
        //第二维也是如此 
        int mid=(l+r)/2;
        if(dl<mid)sqadd(2*p,l,mid,xl,xr,dl,min(dr,mid),plus);
        if(mid<dr)sqadd(2*p+1,mid,r,xl,xr,max(dl,mid),dr,plus);
    }
    inline ll sqsum(int p,int l,int r,int x,int y)
    {
        if(r-l==1){return sum(root[p],0,n,x);}
        int mid=(l+r)/2;//同样第二维也是一路并上去 
        if(y<=mid){return mg(sum(root[p],0,n,x),sqsum(2*p,l,mid,x,y));}
        else return mg(sum(root[p],0,n,x),sqsum(2*p+1,mid,r,x,y));
    }
}sqlt;
struct linetree
{
    ll val[4*N];//一维线段树没啥好说的，为了偷懒也写了标记永久化 
    inline void add(int p,int l,int r,int dl,int dr,ll plus)
    {
        if(dl==dr)return;int mid=(l+r)/2;//见二维的吧，这俩代码几乎一膜一样 
        if(dl==l&&dr==r){val[p]=mg(plus,val[p]);return;}
        if(dl<mid)add(2*p,l,mid,dl,min(dr,mid),plus);
        if(mid<dr)add(2*p+1,mid,r,max(dl,mid),dr,plus);
    }
    inline ll sum(int p,int l,int r,int x)
    {
        if(r-l==1){return val[p];}int mid=(l+r)/2;
        if(x<=mid)return mg(val[p],sum(2*p,l,mid,x));
        else return mg(val[p],sum(2*p+1,mid,r,x));
    }
}lt;
int main()
{
    scanf("%d%d",&n,&m);n+=1;
    for(int i=1;i<=m;i++)
    {
        int opt;int l;int r;
        scanf("%d%d%d",&opt,&l,&r);
        if(opt==1)
        {
            sqlt.sqadd(1,0,n,0,l-1,l-1,r,inv(r-l+1));//只改右端点的 
            sqlt.sqadd(1,0,n,l-1,r,r,n,inv(r-l+1));//只改左端点的 
            sqlt.sqadd(1,0,n,l-1,r,l-1,r,(2*inv(r-l+1))%mod);//两个都改的 
            lt.add(1,0,n,0,l-1,1);lt.add(1,0,n,r,n,1);//修改只落在左边或右边 
            lt.add(1,0,n,l-1,r,((r-l)*inv(r-l+1))%mod);//修改落在中间 
        }
        else if(l==1)
        {
            printf("%lld\n",mg(1,lt.sum(1,0,n,r)));//特判 
        }
        else printf("%lld\n",mg(1,sqlt.sqsum(1,0,n,l-1,r)));//如果是一般的直接查好了 
    }return 0;//拜拜程序 
}
```

---

## 作者：ywy_c_asm (赞：11)

蒟蒻表示不会写二维线段树和标记永久化什么的，这里来一个~~自己瞎yy的~~简单粗暴的树套树维护矩阵的做法。

首先那个假的树状数组是维护后缀和的，所以她之所以输出错误答案的关键在于，这段区间的和如果用后缀和表示就是$S_l-S_{r+1}$，但是她写的是$S_{r}-S_{l-1}$。那么咱们不妨就找一下这两个差在了哪：

$S_l-S_{r+1}=S_l-S_r+A_{r}$

$S_r-S_{l-1}=S_r-S_l-A_{l-1}$

我们应该牢记咱们的所有运算都在模2意义下完成，显然此时加法和减法都一样，负号没有啥用，所以我们得出$A_r=A_{l-1}$，我们求的就是这个的概率。

哦对了我们如果仔细读题的话就会发现可怜在$Find(x)$的一开头专门特判了$if(x==0)return(0);$（吐槽一句：真的树状数组可不会特判这种情况的……这怕不是吉爷“故意”防止错误写法死循环的……），那么此时就是：

$S_r=S-S_r+A_r$

$S+A_r=0$

$A_r=S$

（如果你对上面的式子感到莫名其妙，千万别忘了这是模2的运算！）

其中$S$为这个序列的总和（也就是执行了多少次add），所以在这种情况即$l=1$下我们需要求出$A_r=0/1$的概率，先暂且不提这个。

我们先考虑有两个点的情况，咱们是想求他们两个相等的概率对吧，在这之前会有一些add操作的区间覆盖住这两个点，就会对他们是啥的概率产生影响。假设现在来了一个区间$[l,r]$，那么被他覆盖的点改变的概率就是$\frac 1 {r-l+1}$，不改变的概率就是$\frac {r-l}{r-l+1}$，而这些值之前是1或者0，于是我们很自然的就能想到线段树维护矩阵，我们假设有一个$dp[i][0/1]$表示这个点现在是0/1的概率，那么我们可以在线段树上的区间乘一个这样的矩阵（抱歉蒟蒻不会latex打矩阵）：

```cpp
(r-l)/(r-l+1)    1/(r-l+1)

1/(r-l+1)        (r-l)/(r-l+1)
```

并且这个矩阵他是有交换律的，因为我们乘一个矩阵对应一次加法，而加法就有交换律，这给我们解题带来了极大方便。

于是我们这样就可以找到**一个点**是啥的概率，那么我们现在是不是就可以直接这样做了呢？

这显然不对啊，因为你现在涉及到的是两个点，他们是啥的概率并不一定独立，就是可能会有一些区间**同时覆盖**到了这两个点，显然这就不能出现同时给两个点加的情况，他只可能add一个点，于是这样就可能两个点都不add，概率为$\frac{r-l-1}{r-l+1}$（当然如果$r==l$这种区间当然就不会同时覆盖两个点就不用考虑……），或者add其中的一个点，那样一个点就是$\frac 1{r-l+1}$，于是我们就可以有这样一个想法：先把只覆盖A的区间和只覆盖B的区间的矩阵统计出来（这样就独立了），我们令$dp[0/1][0/1]$表示当前A是啥B是啥的概率，我们就要考虑同时覆盖AB的区间对这个dp的转移，显然这也是一个类似上面的矩阵的形式，也有交换律，不过这个矩阵是4×4的。

于是我们就可以随便做了，我们用线段树套平衡树维护这些区间对应的矩阵，每添加一个区间就在外层线段树上按照左端点插入，每一层都在以右端点为关键值的平衡树维护这两个矩阵的乘积，查询的时候就可以查左端点在一定区间内并且右端点也在一定区间内的矩阵乘积了，简单粗暴。

然后我们一交发现T的比暴力还慢，这显然啊……你要在树套树上维护一个4×4的矩阵，做个乘法要做64次……

我们考虑如何把这个大矩阵优化掉，其实我们并不用刻意的转移这两个点分别是啥的状态，事实上**我们仅关心这两个点是否相同**，我们同时覆盖这两个点的区间最多只会add一个关键点吧，这样的话我们发现就会使这两个点是否相同的状态取反，这个概率是$\frac 2{r-l+1}$的，所以我们只需要设一个$dp[0/1]$表示这两个点是否相同，然后就可以用2×2的矩阵进行转移了。常数大大优化了。

然后**千万不要用Splay！千万不要用Splay！千万不要用Splay！**我用Splay然后T飞了，用替罪羊就跑的飞起……（因为Splay要进行多次的pushup，就得做好多次矩乘，在平衡树上区间查询的时候可以直接在节点上维护最大值和最小值然后像kdtree一样的暴查，显然和线段树一样是$O(logn)$的）。

上代码~

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define ll unsigned long long
#define p 998244353
#define idiv(_a,_b) (((_a)*ny[_b])%p)
using namespace std;
namespace ywy{
	inline int get(){
		int n=0;char c;while((c=getchar())||23333){
			if(c>='0'&&c<='9')break;if(c=='-')goto s;
		}n=c-'0';while((c=getchar())||23333){
			if(c>='0'&&c<='9')n=n*10+c-'0';else return(n);
		}s:while((c=getchar())||23333){
			if(c>='0'&&c<='9')n=n*10-c+'0';else return(n);
		}
	}
	void print(int num){
		if(num>=10)print(num/10);
		putchar(num%10+'0');
	}
	typedef struct _mx{
		int v[2][2];
		friend _mx operator *(const _mx &a,const _mx &b){
			_mx c;
			c.v[0][0]=((ll)a.v[0][0]*b.v[0][0]+(ll)a.v[0][1]*b.v[1][0])%p;
			c.v[1][1]=((ll)a.v[1][0]*b.v[0][1]+(ll)a.v[1][1]*b.v[1][1])%p;
			c.v[1][0]=((ll)a.v[1][0]*b.v[0][0]+(ll)a.v[1][1]*b.v[1][0])%p;
			c.v[0][1]=((ll)a.v[0][0]*b.v[0][1]+(ll)a.v[0][1]*b.v[1][1])%p;return(c);
		}
	}mx;
	mx dk1,dk2;
	namespace phs{
		int data[8000001],ch[8000001][2],maxn[8000001],minn[8000001];
		mx dp1[8000001],tot1[8000001];
		mx dp2[8000001],tot2[8000001];
		int gn=1;mx me1;mx me2;
		int gptr=1,tmp[1000001],size[8000001];
		inline void up(int tree){
			tot1[tree]=dp1[tree];tot2[tree]=dp2[tree];
			size[tree]=1+size[ch[tree][0]]+size[ch[tree][1]];
			maxn[tree]=max(data[tree],max(maxn[ch[tree][0]],maxn[ch[tree][1]]));
			minn[tree]=min(data[tree],min(minn[ch[tree][0]],minn[ch[tree][1]]));
			if(ch[tree][0])tot1[tree]=tot1[tree]*tot1[ch[tree][0]],tot2[tree]=tot2[tree]*tot2[ch[tree][0]];
			if(ch[tree][1])tot1[tree]=tot1[tree]*tot1[ch[tree][1]],tot2[tree]=tot2[tree]*tot2[ch[tree][1]];
		}
		void dfs(int pt){
			if(!pt)return;dfs(ch[pt][0]);
			tmp[gptr]=pt;gptr++;dfs(ch[pt][1]);
		}
		int build(int l,int r){
			if(l>r)return(0);int mid=(l+r)>>1,tree=tmp[mid];
			ch[tree][0]=build(l,mid-1);
			ch[tree][1]=build(mid+1,r);
			up(tree);return(tree);
		}
		void find1(int tree,int pt){//查询tree上大于等于pt的位置 
			if(!tree||maxn[tree]<pt)return;
			if(minn[tree]>=pt){
				me1=me1*tot1[tree];return;
			}
			if(pt>data[tree]){
				find1(ch[tree][1],pt);return;
			}
			me1=me1*dp1[tree];
			if(ch[tree][1])me1=me1*tot1[ch[tree][1]];
			if(pt==data[tree])return;
			find1(ch[tree][0],pt);
		}
		void find2(int tree,int pt){//查询tree上大于等于pt的位置 
			if(!tree||maxn[tree]<pt)return;
			if(minn[tree]>=pt){
				me2=me2*tot2[tree];return;
			}
			if(pt>data[tree]){
				find2(ch[tree][1],pt);return;
			}
			me2=me2*dp2[tree];
			if(ch[tree][1])me2=me2*tot2[ch[tree][1]];
			if(pt==data[tree])return;
			find2(ch[tree][0],pt);
		}
		int need=-1,op;
		void insert(int &tree,int dat){
			if(!tree){
				tree=gn;gn++;dp1[tree]=me1;
				dp2[tree]=me2;size[tree]=1;
				maxn[tree]=minn[tree]=data[tree]=dat;up(tree);return;
			}
			if(data[tree]==dat){
				dp1[tree]=dp1[tree]*me1;dp2[tree]=dp2[tree]*me2;
				tot1[tree]=tot1[tree]*me1;
				tot2[tree]=tot2[tree]*me2;return;
			}
			tot1[tree]=tot1[tree]*me1;
			tot2[tree]=tot2[tree]*me2;
			maxn[tree]=max(maxn[tree],dat);
			minn[tree]=min(minn[tree],dat);
			insert(ch[tree][dat>data[tree]],dat);
			int er=ch[tree][dat>data[tree]];size[tree]++;
			if((double)max(size[ch[er][0]],size[ch[er][1]])>=(double)size[er]*0.66)need=tree,op=(dat>data[tree]);
		}
		void query(int l,int r,int tree){
			if(!tree||maxn[tree]<l||minn[tree]>r)return;
			if(maxn[tree]<=r&&minn[tree]>=l){
				me1=me1*tot1[tree];return;
			}
			if(data[tree]>=l&&data[tree]<=r)me1=me1*dp1[tree];
			query(l,r,ch[tree][0]);query(l,r,ch[tree][1]);
		}
		typedef struct _set{
			int root;_set(){root=0;}
			inline void insert(int dat){
				need=-1;phs::insert(root,dat);
				if((double)max(size[ch[root][0]],size[ch[root][1]])>=(double)size[root]*0.66){
					gptr=1;dfs(root);root=build(1,gptr-1);return;
				}
				if(need==-1)return;
				gptr=1;dfs(ch[need][op]);
				ch[need][op]=build(1,gptr-1);
			}
			inline void query(int l,int r){//只查1！ 
				if(l>r)return;phs::query(l,r,root);
			}
		}set;
	}
	phs::set sets[200001];
	inline ll mi(int a,int b){
		ll ans=1,tmp=a;while(b){
			if(b&1)ans=(ans*tmp)%p;
			tmp=(tmp*tmp)%p;b>>=1;
		}
		return(ans);
	}
	ll ny[100001];int lef[200001],rgh[200001],gn=1,size[200001];
	int build(int l,int r){
		int tree=gn;gn++;
		if(l==r)return(tree);
		int mid=(l+r)>>1;
		lef[tree]=build(l,mid);
		rgh[tree]=build(mid+1,r);return(tree);
	}//警告：phs::me1和phs::me2皆为线段树和平衡树的public 
	void setpt(int l,int r,int tree,int pt,int dat){
		sets[tree].insert(dat);
		size[tree]++;if(l==r)return;
		int mid=(l+r)>>1;
		if(pt<=mid)setpt(l,mid,lef[tree],pt,dat);
		else setpt(mid+1,r,rgh[tree],pt,dat);
	}
	void qsuf1(int rl,int rr,int l,int r,int tree,int pt,int l1,int r1){//A左边的 ，包括矩阵2 
		if(!size[tree])return;
		if(rl>rr)return;
		if(rl==l&&rr==r){
			phs::find2(sets[tree].root,pt);sets[tree].query(l1,r1);return;
		}
		int mid=(l+r)>>1;
		if(rl>mid)qsuf1(rl,rr,mid+1,r,rgh[tree],pt,l1,r1);
		else{
			if(rr<=mid)qsuf1(rl,rr,l,mid,lef[tree],pt,l1,r1);
			else{
				qsuf1(rl,mid,l,mid,lef[tree],pt,l1,r1);
				qsuf1(mid+1,rr,mid+1,r,rgh[tree],pt,l1,r1);
			}
		}
	}
	void qsuf2(int rl,int rr,int l,int r,int tree,int pt){//AB之间的， 只包含B的 
		if(!size[tree])return;
		if(rl>rr)return;
		if(rl==l&&rr==r){
			phs::find1(sets[tree].root,pt);return;
		}
		int mid=(l+r)>>1;
		if(rl>mid)qsuf2(rl,rr,mid+1,r,rgh[tree],pt);
		else{
			if(rr<=mid)qsuf2(rl,rr,l,mid,lef[tree],pt);
			else{
				qsuf2(rl,mid,l,mid,lef[tree],pt);
				qsuf2(mid+1,rr,mid+1,r,rgh[tree],pt);
			}
		}
	}
	inline ll mul(ll a,ll b,ll c){
		a*=b;a%=p;a*=c;return(a%p);
	}
	void ywymain(){
		dk1.v[0][0]=dk1.v[1][1]=1;
		dk2=dk1;phs::maxn[0]=-1234567890;phs::minn[0]=1234567890;
		phs::dp1[0]=phs::tot1[0]=dk1;
		phs::dp2[0]=phs::tot2[0]=dk1;
		int n=get(),m=get();ny[0]=1;
		for(register int i=1;i<=n;i++)ny[i]=mi(i,p-2);
		int rt=build(1，n);int tot=0;
		while(m){
			m--;int cmd=get();
			if(cmd==1){
				int l=get(),r=get();
				phs::me1.v[0][0]=phs::me1.v[1][1]=idiv(r-l,r-l+1);
				phs::me1.v[0][1]=phs::me1.v[1][0]=ny[r-l+1];
				phs::me2.v[0][0]=phs::me2.v[1][1]=idiv(r-l-1,r-l+1);
				phs::me2.v[1][0]=phs::me2.v[0][1]=idiv(2,r-l+1);
				setpt(1,n,rt,l,r);tot++;tot&=1;
			}else{
				int l=get()-1,r=get();
				if(!l){
					phs::me1=dk1;qsuf2(1,r,1,n,rt,r);
					print(phs::me1.v[0][tot]);putchar('\n');continue；
				}
				phs::me1=dk1;
				phs::me2=dk2;qsuf1(1,l,1,n,rt,r,l,r-1);
				ll l0=phs::me1.v[0][0],l1=phs::me1.v[0][1];
				phs::me1=dk1;qsuf2(l+1,r,1,n,rt,r);
				ll r0=phs::me1.v[0][0],r1=phs::me1.v[0][1];
				ll ans=mul(l0,r0,phs::me2.v[0][0])+mul(l1,r1,phs::me2.v[0][0]);
				ans+=mul(l1,r0,phs::me2.v[1][0]);ans+=mul(l0,r1,phs::me2.v[1][0]);
				print(ans%p);putchar('\n')；
			}
		}
	}
}
int main(){
	ywy::ywymain();return(0);//再见程序
}
```

---

## 作者：Cherished (赞：8)

看到还没有人具体证明过，为什么题目中描述的操作是求后缀和，所以我来简略证明y一下：

考虑到我们有一次修改操作，在位置 $a$ 上修改；一个查询操作，在 $b$ 位置上。

我们先将两个操作的代码摆在下面：

```cpp
void Mdf(int x) {
    for (; x; x -= lowbit(x))
        s[x] += 1;
}

int Qry(int x) {
    int ret = 0;
    for (; x <= n; x += lowbit(x))
        ret += s[x];
    return ret;
}
```



1、当 $a<b$ 时：

我们考虑修改操作会涉及到的树状数组中的位置均 $\leq a$ ，而查询操作中会涉及到的数组中的位置均 $\geq b$ ，所以这次修改操作不可能会对这次查询操作有贡献。

2、当 $a = b$ 时：

此时必然在 $s[x]$ 处修改操作会对查询操作有贡献。

3、当 $a>b$ 时：

我们考虑它们的二进制的样子：


$$
\begin{aligned}
a:0110 \dots 01x \\
b:0110 \dots 01y
\end{aligned}
$$

假设二进制总长 $M$ ，它们前面有k位相同 $k \in [0,M)$ ，抛去$a$ 和 $b$ 前 $k$ 位，剩下的分别是 $x,y$ ，因为 $a>b$，所以 $x$ 的第一位是 $1$ ，$y$ 的第一位 $0$。这个时候我们再分类讨论

+ 1、当 $y$ 全是零的时候，一直执行修改操作的 $-=lowbit(x)$ 有一个时刻会把 $x$ 全变成 $0$ ，此时 $a,b$ 相同，而且之后的操作 $a$ 不会变大，$b$ 不会变小，所以它们当且仅当会在 $\lfloor \frac{x}{2^{M-k}} \rfloor \times 2^{M-k}$ 这一个位置产生贡献。
+ 2、当 $y$ 不全是零的时候，因为 $x>y$，而且第一位就已经不同了，所以我们一直执行查询操作的 $+=lowbit(x)$ 直到 $y$ 的第一位变成 $1$ ，此时 $y$ 除了第一位都是 $0$ 。再一直执行修改操作的 $-=lowbit(x)$ 直到 $x$ 的第一位以外都变成 $0$ 为止，此时 $x=y$，因为操作的过程中 $x$ 一直减小，$y$ 一直增大，所以在执行操作的过程中一直有 $a>b$ ，同理之后再一直进行操作会一直有 $a<b$，所以此时它们当且仅当会在$\lfloor \frac{x}{2^{M-k-1}} \rfloor \times 2^{M-k-1}$ 这一个位置产生贡献。

这样我们就证明了当且仅当修改操作的位置 $\ge$ 查询操作的位置是才会对查询操作产生贡献。

之后就只剩下树套树维护两点之间同时存在的概率，和喜闻乐见的卡常环节了。QAQ



---

## 作者：Gypsophila (赞：7)

## Description 

现有一个错误的树状数组，两个操作：
1. 区间异或 $1$
2. 询问区间异或和

每次询问 $2$ 操作正确的概率是多少。

## Solution

显然这个树状数组就是把询问前缀和变成了询问后缀和。所以我们可以发现询问 $[l, r]$ 等价于询问 $[l-1, r-1]$。那么这个询问正确等价于 $a_l=a_r$。

看见数据范围中写到 “所有询问都在修改后”，结合该问题与区间交并相关，我们自然想到 CDQ 分治。（为什么题解区都是树套树？）

考虑如何维护正确的概率？我们对每个询问记录一个 $dp_{0,1}$ 表示经过一些修改操作之后 $a_l$ 异或 $a_r$ 等于 $0$ 或 $1$ 的概率。

结合 CDQ 分治，我们要做的就是处理左区间的修改对右边询问的 $dp$ 值的影响。假设修改为 $[L, R]$，询问是 $[l, r]$ (询问 $a_l = a_r$ 的概率)。再设 $R-L+1=len$，那么转移分成三种情况：

1. $[L, R]$ 不含 $l$ 也 不含 $r$，那么对 $dp$ 值没有影响。
2. $[L, R]$ 含 $l$ 或 $r$ 中的恰好一个。那么有 $dp[i][0]=dp[i-1][0]\cdot \frac{len-1}{len}+dp[i-1][1] \cdot\frac{1}{len};dp[i][1] = dp[i-1][0]\cdot \frac{1}{len}+dp[i-1][1] \cdot\frac{len-1}{len}$。
3. $[L, R]$ 含 $l$ 也含 $r$ 。那么有 $dp[i][0]=dp[i-1][0]\cdot \frac{len-2}{len}+dp[i-1][1] \cdot\frac{2}{len};dp[i][1] = dp[i-1][0]\cdot \frac{2}{len}+dp[i-1][1] \cdot\frac{len-2}{len}$。

显然，这种转移方式可以用矩阵乘法来描述。于是我们就可以把每一个修改操作换成一个矩阵，在处理询问时就是把符合条件的矩阵相乘。

可以发现，第一种情况等价于 $[L, R]$ 与 $[l, r]$ 不相交，第二种情况等价于 $[L, R]$ 和 $[l, r]$ 相交但不包含。第三种情况等价于 $[L, R]$ 包含 $[l, r]$。

于是我们可以在 CDQ 分治时按照左端点或右端点为关键字排序。对应的把修改的信息（一个矩阵）用数据结构加在对应的左端点或右端点上。最后询问时用数据结构进行区间查询即可。这里我选择了使用线段树来维护这个过程。（相信会一点 CDQ分治 的人看得懂我这段在说啥）

也许你有一个问题，矩阵乘法不满足交换律。但是由于此题的特殊性质，把两个修改交换显然是不会有任何影响的。

最后不要忘记一个细节：询问中 $l=1$ 。这个时候我们发现出题人在写错误的树状数组时把这一情况特判了。那么这个时候询问正确等价于为 $r$ 的前缀异或和等于 $r$ 的后缀异或和。我们依然可以通过矩阵乘法的方式描述这种情况。

时间复杂度 $O(2^3 n \log^2 n)$ 。可以通过此题。

### Code

```cpp
#include <bits/stdc++.h>

using namespace std; 

const int maxn = 1e5, mod = 998244353;

int n, m, s[(maxn << 2) + 5], inv[maxn + 5]; 
int fenmu[maxn + 5]; 

struct BIT {
    int c[maxn + 5]; 
    int lb(int x) {
        return x & (-x); 
    }
    void add(int x, int d) {
        for (int i = x; i <= n; i += lb(i)) {
            c[i] += d; 
        }
    }
    int sum(int x) {
        int ret = 0; 
        for (int i = x; i; i -= lb(i)) {
            ret += c[i]; 
        }
        return ret; 
    } 
} B[2]; 

// 这个树状数组是为了维护我说的最后一种细节情况的。

int add(int x, int y) {
    return (x += y) >= mod ? x - mod : x; 
} 

int fpw(int x, int k, int p = mod) {
    int ret = 1; 
    while (k) {
        if (k & 1) ret = 1ll * ret * x % p; 
        x = 1ll * x * x % p; k >>= 1; 
    }
    return ret; 
}

struct Query {
    int l, r, op, id, len;  
} q[maxn + 5]; 

bool cmpl(Query x, Query y) {
    return x.l < y.l; 
}

bool cmpr(Query x, Query y) {
    return x.r < y.r; 
}

bool cmpid(Query x, Query y) {
    return x.id < y.id; 
}
 
struct matrix {
    int a[2][2]; 
    matrix() {
        memset(a, 0, sizeof(a)); 
    }
    matrix operator * (const matrix &x) const {
        matrix ret;
        ret.a[0][0] = add(1ll * a[0][0] * x.a[0][0] % mod, 1ll * a[0][1] * x.a[1][0] % mod); 
        ret.a[0][1] = add(1ll * a[0][0] * x.a[0][1] % mod, 1ll * a[0][1] * x.a[1][1] % mod); 
        ret.a[1][0] = add(1ll * a[1][0] * x.a[0][0] % mod, 1ll * a[1][1] * x.a[1][0] % mod); 
        ret.a[1][1] = add(1ll * a[1][0] * x.a[0][1] % mod, 1ll * a[1][1] * x.a[1][1] % mod); 
        return ret; 
    }
} dp[maxn + 5];

struct node {
    int s; matrix x; 
    node() {
        s = 1; 
        x.a[0][0] = x.a[1][1] = 1; 
        x.a[0][1] = x.a[1][0] = 0; 
    }
    node operator + (const node &t) const {
        node ret; 
        ret.s = 1ll * s * t.s % mod; 
        ret.x = x * t.x; 
        return ret;  
    }
} a[(maxn << 2) + 5]; 

void modify(int p, int l, int r, int pos, matrix x, int len, int op) {
    if (op == -1) {
        a[p].s = 1; 
        a[p].x.a[0][0] = a[p].x.a[1][1] = 1;
        a[p].x.a[0][1] = a[p].x.a[1][0] = 0;  
    }
    if (l == r) {
        if (op == -1) {
            return ; 
        }
        else {
            a[p].s = 1ll * a[p].s * len % mod; 
            a[p].x = a[p].x * x; 
        }
        return ; 
    }
    int mid = (l + r) >> 1; 
    if (pos <= mid) modify(p + p, l, mid, pos, x, len, op); 
    else modify(p + p + 1, mid + 1, r, pos, x, len, op); 
    if (op == 1) {
        a[p] = a[p + p] + a[p + p + 1]; 
    }
}

node query(int p, int l, int r, int ql, int qr) {
    if (l == ql && r == qr) return a[p]; 
    int mid = (l + r) >> 1; 
    if (qr <= mid) return query(p + p, l, mid, ql, qr); 
    if (mid < ql)  return query(p + p + 1, mid + 1, r, ql, qr); 
    return query(p + p, l, mid, ql, mid) + query(p + p + 1, mid + 1, r, mid + 1, qr); 
}

void CDQ(int l, int r) {
    if (l >= r) return ; 
    int mid = (l + r) >> 1; 
    CDQ(l, mid); CDQ(mid + 1, r); 
    sort(q + l, q + mid + 1, cmpl); 
    sort(q + mid + 1, q + r + 1, cmpl); 
    // ([)] 边界严格
    int pos = l; 
    for (int i = mid + 1; i <= r; i++) {
        while (pos <= mid && q[pos].l <= q[i].l) {
            if (q[pos].op == 1) {
                matrix t; 
                t.a[0][0] = q[pos].len - 1, t.a[0][1] = 1; 
                t.a[1][0] = 1, t.a[1][1] = q[pos].len - 1; 
                modify(1, 0, n, q[pos].r, t, q[pos].len, 1); 
            }
            pos++; 
        }
        if (q[i].op == 2 && q[i].l != 0) {
            node t = query(1, 0, n, q[i].l, q[i].r - 1); 
            dp[q[i].id] = dp[q[i].id] * t.x; 
            if (q[i].id == 5) {
                
            }
            fenmu[q[i].id] = 1ll * fenmu[q[i].id] * t.s % mod; 
        }
    }
    for (int i = l; i < pos; i++) {
        if (q[i].op == 1) {
            modify(1, 0, n, q[i].r, dp[0], q[i].len, -1); 
        }
    }
    pos = l; 
    for (int i = mid + 1; i <= r; i++) {
        while (pos <= mid && q[pos].l <= q[i].l) {
            if (q[pos].op == 1) {
                matrix t; 
                t.a[0][0] = q[pos].len - 2, t.a[0][1] = 2; 
                t.a[1][0] = 2, t.a[1][1] = q[pos].len - 2; 
                modify(1, 0, n, q[pos].r, t, q[pos].len, 1); 
            }
            pos++; 
        }
        if (q[i].op == 2 && q[i].l) {
            node t = query(1, 0, n, q[i].r, n); 
            dp[q[i].id] = dp[q[i].id] * t.x; 

            fenmu[q[i].id] = 1ll * fenmu[q[i].id] * t.s % mod; 
        }
    }
    for (int i = l; i < pos; i++) {
        if (q[i].op == 1) {
            modify(1, 0, n, q[i].r, dp[0], q[i].len, -1); 
        }
    }
    // [(]) 边界严格
    sort(q + l, q + mid + 1, cmpr); 
    sort(q + mid + 1, q + r + 1, cmpr); 
    pos = mid; 
    for (int i = r; i >= mid + 1; i--) {
        while (pos >= l && q[pos].r >= q[i].r) {
            if (q[pos].op == 1) {
                matrix t; 
                t.a[0][0] = q[pos].len - 1, t.a[0][1] = 1; 
                t.a[1][0] = 1, t.a[1][1] = q[pos].len - 1; 
                modify(1, 0, n, q[pos].l, t, q[pos].len, 1);
            }
            pos--; 
        }
        if (q[i].op == 2 && q[i].l != 0) {
            node t = query(1, 0, n, q[i].l + 1, q[i].r); 
            dp[q[i].id] = dp[q[i].id] * t.x; 
            fenmu[q[i].id] = 1ll * fenmu[q[i].id] * t.s % mod; 
        }
    }
    for (int i = pos + 1; i <= mid; i++) {
        if (q[i].op == 1) {
            modify(1, 0, n, q[i].l, dp[0], q[i].len, -1); 
        }
    }
    pos = mid; 
    for (int i = r; i >= mid + 1; i--) {
        while (pos >= l && q[pos].r >= q[i].r) {
            if (q[pos].op == 1) {
                matrix t; 
                t.a[0][0] = 1, t.a[0][1] = q[pos].len - 1; 
                t.a[1][0] = q[pos].len - 1, t.a[1][1] = 1; 
                modify(1, 0, n, q[pos].l, t, q[pos].len, 1);
            }
            pos--; 
        }
        if (q[i].op == 2 && q[i].l == 0) {
            node t = query(1, 0, n, q[i].l + 1, q[i].r); 
            dp[q[i].id] = dp[q[i].id] * t.x; 
            fenmu[q[i].id] = 1ll * fenmu[q[i].id] * t.s % mod; 
        }
    }
    for (int i = pos + 1; i <= mid; i++) {
        if (q[i].op == 1) {
            modify(1, 0, n, q[i].l, dp[0], q[i].len, -1); 
        }
    }
}

int main() {
    scanf("%d %d", &n, &m); 
    inv[1] = 1; 
    for (int i = 2; i <= n + 1; i++) {
        inv[i] = 1ll * (mod - mod / i) * inv[mod % i] % mod;
    }
    for (int i = 1; i <= m; i++) {
        scanf("%d %d %d", &q[i].op, &q[i].l, &q[i].r);
        if (q[i].op == 2) {
            q[i].l = q[i].l - 1; 
        } 
        dp[i].a[0][0] = 1; dp[i].a[0][1] = 0; 
        fenmu[i] = 1; 
        q[i].id = i, q[i].len = q[i].r - q[i].l + 1; 
    }
    CDQ(1, m); 
    sort(q + 1, q + m + 1, cmpid); 
    for (int i = 1; i <= m; i++) {
        if (q[i].op == 2) {
            int fz = dp[i].a[0][0];
            int fm = fenmu[i], ans;
            if (q[i].l == 0) {
                int s1 = B[1].sum(q[i].r - 1); 
                int s2 = B[0].sum(n) - B[0].sum(q[i].r); 
                // cout << s1 << ' ' << s2 << '\n'; 
                if ((s1 + s2) & 1) {
                    fz = dp[i].a[0][1]; 
                }
            }
            ans = 1ll * fz * fpw(fm, mod - 2, mod) % mod; 
            printf("%d\n", ans); 
        }
        else {
            B[0].add(q[i].l, 1); 
            B[1].add(q[i].r, 1); 
        }
    }
    return 0; 
}
```


---

## 作者：lyh0313 (赞：7)

## 分析:
“如果你对树状数组比较熟悉，不难发现可怜求的是后缀和”

设数列为$A$，那么可怜求的就是$A_{l-1}$到$A_{r-1}$的和（即$l-1$的后缀减$r$的后缀，$\sum_{i=l-1}^{r-1}A_i$）,而答案为$A_l$到$A_r$的和（即$\sum_{i=l}^{r}A_i$）这两种答案都包含$A_l$到$A_{r-1}$的和，因此只需判断$A_{l-1}$与$A_r$相等的概率就行了

那么怎么算？

考虑记下每次修改的影响，假设已知左端点$a$和右端点$b$，那么对于某一次修改区间$l$~$r$，则只有当$a\in[l,r]$或$b\in[l,r]$时才有影响，设$p$为任选区间内一个数的概率，这里分三种情况讨论:

- $a\in[1,l-1]$,$b\in[l,r]$时，有$1-p$的概率不影响
- $a\in[l,r]$,$b\in[l,r]$时，有$1-2*p$的概率不影响
- $a\in[l,r]$,$b\in[r+1,n]$时，有$1-p$的概率不影响

那么只要把所有的影响都合并起来就行了，设当前相同概率为$p$，当前修改不影响的概率$q$，则相同概率更新为$p*q+(1-p)*(1-q)$

但是直接朴素必然TLE，因此我们要寻找更高效的算法，~~嗯，标签是二维线段树，那就用它了~~

考虑二维线段树，设点$(x,y)$表示$A_x$与$A_y$相等的概率，那么我们会惊奇的发现：
#### 这不就是区间修改单点查询吗！

每读入一个修改，就用上面所说的影响更新区间，即$[1,l-1,l,r],[l,r,l,r],[l,r,r+1,n]$三个区间，用上述式子合并区间

询问即查询点$(l-1,r)$的值

### 还有一个坑点！！$l$可能为$1$！！

$l=1$时，可怜求的是$r$的后缀和，因此我们需要求$r$的后缀和与前缀和相等的概率

这也可以用类似方法，第一维我们新增一个元素$0$，用$[0,x]$表示$x$的后缀和与前缀和相等的概率，那么当修改区间$[l,r]$时，区间$[1,l-1]$,$[r+1,n]$中元素的后缀和与前缀和一定会被影响，即不被影响概率为$0$；而区间$[l,r]$中元素有$p$的概率不被影响（即正好选到它，$p$的意义即为上述），这时我们也要更新。这样当$l=1$时，直接查询点$(l-1,r)$的值即可

### 还有就是卡卡常数，卡卡空间！！
#### 以及线段树要动态开点

## Code:
（代码丑不要怪我）
```cpp
//开O2能过
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<string>
#include<iostream>
#include<queue>
#include<iomanip>
#include<algorithm>
using namespace std;
const int N=100010;
const int MOD=998244353;
int rt[N*21],n,cnt;
struct tree
{
    int l,r;
    int v;//卡空间，开int
}tr[N*402];

inline long long mul(long long p,long long q)//p*q+(1-p)*(1-q)
{
    long long res=p*q%MOD;
    res=(res+(1-p+MOD)*(1-q+MOD)%MOD)%MOD;
    return res;
}

inline long long power(long long x,long long y)//快速幂
{
    long long ans=1;
    while(y)
    {
        if(y&1) ans=ans*x%MOD;
        x=x*x%MOD,y>>=1;
    }
    return ans;
}

inline void updatay(int l,int r,int &id,int ly,int ry,long long p)//修改区间二维
{
    if(id==0)
    {
        cnt++;
        id=cnt;
        tr[id].v=1;//初始时都是0，因此相等概率为1
    }
    if(l>=ly&&r<=ry)
    {
        tr[id].v=mul(p,tr[id].v);
        return;
    }
    int mid=l+r>>1;
    if(ly<=mid) updatay(l,mid,tr[id].l,ly,ry,p);
    if(ry>mid) updatay(mid+1,r,tr[id].r,ly,ry,p);
}

inline void updatax(int l,int r,int id,int lx,int rx,int ly,int ry,long long p)//修改区间一维
{
    if(l>=lx&&r<=rx)
    {
        updatay(1,n,rt[id],ly,ry,p);
        return;
    }
    int mid=l+r>>1;
    if(lx<=mid) updatax(l,mid,id<<1,lx,rx,ly,ry,p);
    if(rx>mid) updatax(mid+1,r,id<<1|1,lx,rx,ly,ry,p);
}

long long quey(int l,int r,int id,int y)//查询二维
{
    if(id==0) return 1;//初始时都是0，因此相等概率为1
    if(l==r) return tr[id].v;
    int mid=l+r>>1;
    long long res;
    if(y<=mid) res=mul(tr[id].v,quey(l,mid,tr[id].l,y));
    else res=mul(tr[id].v,quey(mid+1,r,tr[id].r,y));
    //合并沿途所有区间影响值
    return res;
}

long long quex(int l,int r,int id,int x,int y)//查询一维
{
    if(l==r) return quey(1,n,rt[id],y);
    int mid=l+r>>1;
    if(x<=mid) return mul(quey(1,n,rt[id],y),quex(l,mid,id<<1,x,y));
    else return mul(quey(1,n,rt[id],y),quex(mid+1,r,id<<1|1,x,y));
    //合并沿途所有区间影响值
}

int main()
{
    int i,j,k,q,op,l,r;
    long long p;
    scanf("%d%d",&n,&q);
    cnt=0;
    while(q--)
    {
        scanf("%d%d%d",&op,&l,&r);
        if(op==1)
        {
            p=power(r-l+1,MOD-2);//求逆元，即选某一个元素的概率
            if(l>1) updatax(0,n,1,1,l-1,l,r,(1-p+MOD)%MOD),updatax(0,n,1,0,0,1,l-1,0);
            if(r<n) updatax(0,n,1,l,r,r+1,n,(1-p+MOD)%MOD),updatax(0,n,1,0,0,r+1,n,0);
            updatax(0,n,1,l,r,l,r,(1-p*2%MOD+MOD)%MOD),updatax(0,n,1,0,0,l,r,p);
        }
        else printf("%lld\n",quex(0,n,1,l-1,r));
    }
    return 0;
}
```

---

## 作者：消失的海岸线 (赞：4)

丢个[博客](https://www.zgz233.xyz/2017/12/05/bzoj-4785-zjoi2017%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/ "博客")链接

题意：一个人的树状数组写错了，具体错在将修改操作和查询操作跳 $lowbit$ 的顺序写反了，支持区间内随机单点取反，区间异或和查询，询问这个人的答案没错的概率。


如果熟悉树状数组或者打一下表可以简单的发现这个人写错的后果就是查询是后缀和不是前缀和了。


那么他的答案会错当且仅当 $l-1$ 和 $r$ 这两个位置被修改的次数在模 $2$ 的意义下不同。将平面上的点 $(l,r)$ 视作序列上的 $l$ 和 $r$ 这两个位置修改次数在模 $2$ 意义下相同的概率。


每次修改操作分类讨论即可，实际上是三个矩形覆盖。概率可以简单合并，即分别讨论都变和都不变的情况即可，所以二维线段树可以维护这个修改。


如果只观察到这里就死定了，树状数组如果访问了 $0$ 下标会炸，所以观察伪代码，发现访问 $0$ 下标的时候返回了 $0$，不可以简单套用上述做法，单独维护下就好了。


二维线段树的话外层只需要维护上传标记即可，为了方便内层也写了标记永久化，其实没有必要。


    
    
    
    
    
```cpp
    #include <cmath>
    #include <queue>
    #include <cstdio>
    #include <iomanip>
    #include <cstdlib>
    #include <cstring>
    #include <iostream>
    #include <algorithm>
    #define N 100010
    #define ll long long
    #define mod 998244353
    using namespace std;
    char xB[1<<15],*xS=xB,*xT=xB;
    #define getchar() (xS==xT&&(xT=(xS=xB)+fread(xB,1,1<<15,stdin),xS==xT)?0:*xS++)
    inline int read()
    {
        int x=0,f=1;char ch=getchar();
        while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
        while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
        return x*f;
    }
    ll quickmod(ll a,ll b)
    {
        ll ret=1;
        while(b)
        {
            if(b&1)ret=ret*a%mod;
            a=a*a%mod,b>>=1;
        }
        return ret;
    }
    ll merge(ll a,ll b)
    {return (a*b%mod+(1-a+mod)*(1-b+mod)%mod)%mod;}
    ll p[N<<8];
    int ch[N<<8][2],tot;
    int root[N<<2];
    int n,m;
    struct ins_seg
    {
        void modify(int &x,int l,int r,int L,int R,ll v)
        {
            if(!x)x=++tot,p[x]=1;
            if(l>=L&&r<=R)
            {
                p[x]=merge(p[x],v);
                return ;
            }
            int mid=(l+r)>>1;
            if(L<=mid) modify(ch[x][0],l,mid,L,R,v);
            if(R>mid)  modify(ch[x][1],mid+1,r,L,R,v);
        }
        ll ask(int x,int l,int r,int pos)
        {
            if(!x)return 1;
            if(l==r)return p[x];
            int mid=(l+r)>>1;
            if(pos<=mid)return merge(p[x],ask(ch[x][0],l,mid,pos));
            else return merge(p[x],ask(ch[x][1],mid+1,r,pos));
        }
    };
    struct out_seg
    {
        ins_seg p;
        void modify(int x,int l,int r,int L,int R,int c,int d,ll v)
        {
            if(l>=L&&r<=R)
            {
                p.modify(root[x],1,n,c,d,v);
                return ;
            }
            int mid=(l+r)>>1;
            if(L<=mid) modify(x<<1,l,mid,L,R,c,d,v);
            if(R>mid)  modify(x<<1|1,mid+1,r,L,R,c,d,v);
        }
        ll ask(int x,int l,int r,int a,int b)
        {
            if(l==r)return p.ask(root[x],1,n,b);
            int mid=(l+r)>>1;
            if(a<=mid) return merge(p.ask(root[x],1,n,b),ask(x<<1,l,mid,a,b));
            else return merge(p.ask(root[x],1,n,b),ask(x<<1|1,mid+1,r,a,b));
        }
    }T;
    int main()
    {
        n=read(),m=read();
        while(m--)
        {
            int opt=read(),l=read(),r=read();
            if(opt==1)
            {
                ll p=quickmod(r-l+1,mod-2);
                if(l>1) T.modify(1,0,n,1,l-1,l,r,(1-p+mod)%mod),T.modify(1,0,n,0,0,0,l-1,0);
                if(r<n) T.modify(1,0,n,l,r,r+1,n,(1-p+mod)%mod),T.modify(1,0,n,0,0,r+1,n,0);
                T.modify(1,0,n,l,r,l,r,(1-2*p%mod+mod)%mod);
                T.modify(1,0,n,0,0,l,r,p);
            }
            else printf("%lld\n",T.ask(1,0,n,l-1,r));
        }
}
```

---

## 作者：Vocalise (赞：2)

作者做过时间跨度最长的题...

然而最终还是被卡常了，88 pts 是极限了...

这篇题解会讲述常见的二维线段树解法，与**一种**大概比较另类的 CDQ 分治解法。

---

## 题目解读

一个树状数组写反了，于是我们通过实践发现它正确地实现了单点加，求后缀和的数据结构。

记后缀和为 $\{P_i\}_{i=0}^n$，则发现我们需要求的是 $P_l - P_{r+1}$，但是求出了 $P_r - P_{l-1} = P_{l-1} - P_r$ （在 $\pmod 2$ 意义下）。

所以问答案正确的概率，即为 $A_{l-1} = A_r$ 的概率。

---

## 大体分析

将答案表示为二元组 $(i,j)$，$i,j\in[1,n]$，并考虑一个修改 $[l,r]$ 对一些答案的影响。

记 $\dfrac1{r - l + 1} = p$。

1. 当 $[l,r]\cap[i,j] = \varnothing$ 时不影响；
2. 当 $i\in[1,l-1],j\in[l,r]$ 或 $i\in[l,r],j\in[r+1,n]$ 时，有 $1-p$ 的概率不影响。
3. 当 $i,j\in[l,r]$ 时，有 $1-2p$ 的概率不影响。

一种特殊情况：$i = 1$。此时求的是 $j$ 的前缀等于后缀的概率。

在 $i$ 的一维上额外添加 $0$ 点维护该情况（如果该维是树状数组，需要平移一位）：

1. $j\in[1,l-1]$ 或 $j\in[r+1,n]$，一定会影响，即有 $0$ 的概率不影响；
2. $j\in[l,r]$，有 $p$ 的概率不影响（修改在 $j$ 点上）。

另外，对于维护好的 $(i,j)$ 答案为 $p$，当前修改对其不影响的概率是 $q$，则新的概率记为 $p*q$：

$$ p*q = pq + (1-p)(1-q) $$

即正确答案且不修改或错误答案且修改都可以。

---

## 二维线段树

容易发现，$*$ 运算具有结合律。

所以我们直接用二维线段树维护每一个答案 $(i,j)$，修改一个矩形即可。

因为查询只有单点的，所以在内外层线段树上只需永久标记所有修改的影响即可。

时间、空间 $\mathcal O(n\log^2n)$。

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <cmath>
#include <algorithm>

const int N = 100001;
const int LOGN = 17;
const int NODE = N * LOGN * LOGN;
const int p = 998244353;

inline int read() {
	int x = 0, f = 1; char ch = getchar();
	while(ch > '9' || ch < '0') { if(ch == '-') f = -1; ch = getchar(); }
	do x = x * 10 + ch - 48, ch = getchar(); while(ch >= '0' && ch <= '9');
	return x * f;
}

inline int fastpow(int a,int b) {
	int res = 1;
	while(b) {
		if(b & 1) res = 1ll * res * a % p;
		a = 1ll * a * a % p;
		b >>= 1;
	}
	return res; 
}

int n,m,rt[N << 2];
int lc[NODE],rc[NODE],cnt;
int s[NODE];

#define lc(k) k << 1
#define rc(k) k << 1 | 1

int Calc(int a,int b) {
	return (1ll * a * b % p + 1ll * (p - a + 1) * (p - b + 1) % p) % p;
}

void Modify(int &k,int l,int r,int x,int y,int t) {
	if(!k) k = ++cnt, s[k] = 1;
	if(l >= x && r <= y) return void(s[k] = Calc(s[k],t));
	int m = (l + r) >> 1;
	if(x <= m) Modify(lc[k],l,m,x,y,t);
	if(y > m) Modify(rc[k],m + 1,r,x,y,t);
	return;
}

void Update(int k,int l,int r,int lx,int rx,int ly,int ry,int t) {
	if(l >= lx && r <= rx) return Modify(rt[k],1,n,ly,ry,t);
	int m = (l + r) >> 1;
	if(lx <= m) Update(lc(k),l,m,lx,rx,ly,ry,t);
	if(rx > m) Update(rc(k),m + 1,r,lx,rx,ly,ry,t);
}

int Sum(int k,int l,int r,int x) {
	if(!k) return 1;
	if(l == r) return s[k];
	int m = (l + r) >> 1;
	if(x <= m) return Calc(s[k],!lc[k] ? 1 : Sum(lc[k],l,m,x));
	else return Calc(s[k],!rc[k] ? 1 : Sum(rc[k],m + 1,r,x));
}

int Query(int k,int l,int r,int x,int y) {
	if(l == r) return Sum(rt[k],1,n,y);
	int m = (l + r) >> 1;
	if(x <= m) return Calc(Sum(rt[k],1,n,y),Query(lc(k),l,m,x,y));
	else return Calc(Sum(rt[k],1,n,y),Query(rc(k),m + 1,r,x,y));
}

int main() {
	n = read(), m = read();
	int op,l,r,t;
	while(m--) {
		op = read(), l = read(), r = read();
		if(op == 1) {
			t = fastpow(r - l + 1,p - 2);
			if(l > 1) Update(1,0,n,1,l - 1,l,r,p - t + 1), Update(1,0,n,0,0,1,l - 1,0);
			if(r < n) Update(1,0,n,l,r,r + 1,n,p - t + 1), Update(1,0,n,0,0,r + 1,n,0);
			Update(1,0,n,l,r,l,r,p - 2 * t % p + 1), Update(1,0,n,0,0,l,r,t);
		} else std::printf("%d\n",Query(1,0,n,l - 1,r));
	}
	return 0;
}
```

---

## CDQ 分治

矩形运算，单点求值，可以想到用 CDQ 分治做。其实就是三维偏序。

具体地，把矩形在某一维上拆成两个线段，所有询问按时间排放后分治，按照该维大小归并，并用树状数组维护最后一维的信息，统计答案。

仅仅是这样的话，如果已经掌握二维线段树的做法，其实非常简单。

但是和在线做法不同，我们实际上需要一个可差分的信息。

回顾一些东西：$x*y = xy+(1-x)(1-y)$ 是我们要支持的二元运算。

该运算有单位元 $1$。

考虑逆元：$x*y=1$，则 $y = \dfrac x{2x-1}$。

这样直接写的话，样例能过，但是对于

```
2 3
1 1 2
1 2 2
2 2 2
```

输出应为 $1$，但是这样写出来是 $499122177$ 即 $\dfrac 12$。

探讨后发现，我们想当然为认为每个数存在唯一的逆元，但是对于 $1/2$ 其实是无逆元的，同时，对于该运算任何数 $*1/2$ 都是 $1/2$。

类比 $1/2$ 与普通乘法中 $0$ 的作用，请理解此时我们需要实现的实际作用：

在支持普通 $*$ 运算同时，支持 $*1/2$ 强制将数转为 $1/2$，并支持 $*(1/2)^{-1}$ （此处的逆元是 $*$ 意义下的），且等量的 $1/2$ 与 $(1/2)^{-1}$ 可以抵消。

~~容易想到~~对每个数维护一个二元组 $(x,y)$ 表示当前的数是 $x*(1/2)^y$。

则：

$$(x_1,y_1)*(x_2,y_2)=(x_1*x_2,y_1+y_2)$$

$$(x_1,y_1)^{-1}=(x_1^{-1},-y_1)$$

最后输出真实值，因为所有的 $(1/2)^{-1}$ 一定被撤消了，最后的结果中如果 $y > 0$ 则为 $1/2$；否则为 $x$。

有一点注意，就是需保证 $x$ 不是 $(1/2)^k$，需要每次运算、求逆时检验并把 $1/2$ 转移到 $y$ 上。

大概就是这样了。

~~但是二维线段树能过的点 CDQ 反而过不了了~~

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <cmath>
#include <algorithm>

const int N = 100001;
const int OPT = N * 12;
const int p = 998244353;
const int half = 499122177;

inline int read() {
	int x = 0, f = 1; char ch = getchar();
	while(ch > '9' || ch < '0') { if(ch == '-') f = -1; ch = getchar(); }
	do x = x * 10 + ch - 48, ch = getchar(); while(ch >= '0' && ch <= '9');
	return x * f;
}

inline void print(int x) {
	if(x > 9) print(x / 10);
	std::putchar(x % 10 + 48);
}

inline int fastpow(int a,int b) {
	int res = 1;
	while(b) {
		if(b & 1) res = 1ll * res * a % p;
		a = 1ll * a * a % p;
		b >>= 1;
	}
	return res;
}

inline int inv(int x) { return 1ll * x * fastpow(2 * x % p - 1,p - 2) % p; }
inline int f(int x,int y) { return (1ll * x * y % p + 1ll * (1 - x + p) * (1 - y + p) % p) % p; }
struct Number {
	int x,y;
	Number(int _x = 1,int _y = 0) : x(_x), y(_y) {}
	void Set() { if(x == half) x = 1, ++y; }
	friend Number operator *(Number x,Number y) {
		x.Set(), y.Set();
		return Number(f(x.x,y.x),x.y + y.y);
	}
	friend Number operator *(const int x,Number y) {
		return Number(1ll * x * y.x % p);
	}
	friend Number operator -(const int x,Number y) {
		return Number((p - y.x + x) % p);
	}
	Number Inv() {
		return Set(), Number(inv(x),-y);
	}
	int Real() { return y > 0 ? half : x; }
};

int n,m; Number fn[N + 5],ans[N];
inline void Add(int l,int r,Number t) {
	for(l++;l <= n + 2;l += l & (-l)) fn[l] = fn[l] * t;
	Number _t = t.Inv();
	for(r+=2;r <= n + 2;r += r & (-r)) fn[r] = fn[r] * _t;
}
inline Number Sum(int x) {
	Number res;
	for(x++;x;x -= x & (-x)) res = res * fn[x];
	return res;
}
struct Node {
	int tp,x,l,r; Number t;
	Node() {}
	Node(int _tp,int _x,int _l,int _r,Number _t) :
		tp(_tp), x(_x), l(_l), r(_r), t(_t) {}
} a[OPT],a1[OPT]; int t;

bool leq(const Node &x,const Node &y) {
	if(x.x != y.x) return x.x < y.x;
	return x.tp < y.tp;
}

void Solve(int l,int r) {
	if(l == r) return;
	int m = (l + r) >> 1;
	Solve(l,m), Solve(m + 1,r);
	int i = l, j = m + 1, c = 0;
	while(i <= m && j <= r) if(leq(a[i],a[j])) {
		if(a[i].tp == 1) Add(a[i].l,a[i].r,a[i].t);
		a1[++c] = a[i++];
	} else {
		if(a[j].tp == 2) ans[a[j].l] = ans[a[j].l] * Sum(a[j].r);
		a1[++c] = a[j++];
	} while(i <= m) {
		if(a[i].tp == 1) Add(a[i].l,a[i].r,a[i].t);
		a1[++c] = a[i++];
	} while(j <= r) {
		if(a[j].tp == 2) ans[a[j].l] = ans[a[j].l] * Sum(a[j].r);
		a1[++c] = a[j++];
	}
	for(int i = l;i <= m;i++) if(a[i].tp == 1) Add(a[i].l,a[i].r,a[i].t.Inv());
	for(int i = l;i <= r;i++) a[i] = a1[i - l + 1];
	return;
}

int main() {
	n = read(), m = read(); int qt = 0;
	for(int i = 1,op,l,r;i <= m;i++) {
		op = read(), l = read(), r = read();
		if(op == 1) {
			Number q(fastpow(r - l + 1,p - 2));
			if(l > 1) {
				a[++t] = Node(1,1,l,r,1-q), a[++t] = Node(1,l,l,r,(1-q).Inv());
				a[++t] = Node(1,0,1,l - 1,Number(0)), a[++t] = Node(1,1,1,l - 1,Number(0));
			} if(r < n) {
				a[++t] = Node(1,l,r + 1,n,1-q), a[++t] = Node(1,r + 1,r + 1,n,(1-q).Inv());
				a[++t] = Node(1,0,r + 1,n,Number(0)), a[++t] = Node(1,1,r + 1,n,Number(0));
			}
			a[++t] = Node(1,l,l,r,1-2*q), a[++t] = Node(1,r + 1,l,r,(1-2*q).Inv());
			a[++t] = Node(1,0,l,r,q), a[++t] = Node(1,1,l,r,q.Inv());
		} else a[++t] = Node(2,l - 1,++qt,r,Number());
	}
	Solve(1,t);
	for(int i = 1;i <= qt;i++) print(ans[i].Real()), std::putchar('\n');
	return 0;
}
cpp
```

---

## 作者：紊莫 (赞：1)

其实 KDT 也可以做，不用卡空间。

---

首先容易把题意转化成 $l - 1, r$ 两个位置是否相等。

当 $l = 1$ 的时候有些区别，但是实际上还是在计算 $r$ 处为 $0/1$ 的概率，记 $a_{0/1}$ 表示最终 $l - 1$ 和 $r$ 异或和为 $0/1$ 的概率。

对于包含 $l, r$ 中 $k$ 个点的修改，造成的贡献是：

$$\begin{bmatrix}
a'_0  & a'_1
\end{bmatrix}=\begin{bmatrix}
a_0  & a_1
\end{bmatrix}
\begin{bmatrix}
 1 - \frac{k}{r - l + 1} & \frac{k}{r - l + 1}\\
 \frac{k}{r - l + 1} & 1 - \frac{k}{r - l + 1}
\end{bmatrix}$$

查询的时候发现需要用到的 $(l, r)$ 在一个矩形内，于是可以直接 KDT 查询。

此处矩阵比较特殊，有交换律，可以 $O(1)$ 乘法，那么就通过了此题，参考代码如下。


```cpp
#include <bits/stdc++.h>

#define F(i, a, b) for (int i = (a); i <= (b); i++)
#define dF(i, a, b) for (int i = (a); i >= (b); i--)
using namespace std;

typedef long long ll;
typedef pair<int, int> pii;

const int N = 200005, M = (N << 1), inf = 1e9, mod = 998244353;
int n, m;
struct Matrix {
    int a[2][2];
    Matrix () {memset(a, 0, sizeof a);}
    operator auto () { return a; }
    void init() { a[0][0] = a[1][1] = 1; }
    Matrix operator * (Matrix x) {
        Matrix res;
        res[0][0] = res[1][1] = ((ll)a[0][0] * x[0][0] + (ll)a[1][0] * x[1][0]) % mod;
        res[1][0] = res[0][1] = ((ll)a[0][1] * x[0][0] + (ll)a[1][1] * x[1][0]) % mod;
        return res;
    }
} I;
struct point { int x, y; Matrix v; };
bool cmpx(point a, point b) { return a.x < b.x; }
bool cmpy(point a, point b) { return a.y < b.y; }
struct KDT {
    int tot, top, rt, stk[N];
    struct node {
        int ls, rs, lx, rx, ly, ry, siz; point f; Matrix ml;
        node() : ls(0), rs(0), lx(inf), rx(-inf), ly(inf), ry(-inf), siz(0) {
            ml.init();
        }
    } t[N];
    void pushup(int p) {
        int L = t[p].ls, R = t[p].rs;
        t[p].lx = min({t[L].lx, t[R].lx, t[p].f.x});
        t[p].ly = min({t[L].ly, t[R].ly, t[p].f.y});
        t[p].rx = max({t[L].rx, t[R].rx, t[p].f.x});
        t[p].ry = max({t[L].ry, t[R].ry, t[p].f.y});
        t[p].ml = t[L].ml * t[R].ml * t[p].f.v;
        t[p].siz = t[L].siz + t[R].siz + 1;
    }
    inline int newnode() {
        if (top) return stk[top--];
        return ++tot;
    }
    inline int in(int x, int y, int x1, int x2, int y1, int y2) {
        return x >= x1 && x <= x2 && y >= y1 && y <= y2;
    }
    inline int out(int x, int y, int l, int r) {
        if (x > l) swap(x, l), swap(y, r);
        return y < l;
    }
    point vec[N];
    int m;
    void get(int p) {
        if (!p) return;
        get(t[p].ls), vec[++m] = t[p].f, get(t[p].rs);
        t[p] = node(); stk[++top] = p;
    }
    int build(int l, int r, int dep) {
        if (l > r) return 0;
        int mid = l + r >> 1, k = newnode();
        nth_element(vec + l, vec + mid, vec + r + 1, dep ? cmpx : cmpy);
        t[k].f = vec[mid];
        t[k].ls = build(l, mid - 1, dep ^ 1);
        t[k].rs = build(mid + 1, r, dep ^ 1);
        pushup(k);
        return k;
    }
    void check(int &p, int dep) {
        if (t[p].siz * 0.8 < max(t[t[p].ls].siz, t[t[p].rs].siz))
            m = 0, get(p), p = build(1, m, dep);
    }
    void ins(int &p, point v, int dep) {
        if (!p) {
            p = newnode();
            t[p].f = v;
            pushup(p);
            return;
        }
        auto cmp = dep ? cmpx : cmpy;
        if (!cmp(t[p].f, v)) ins(t[p].ls, v, dep ^ 1);
        else ins(t[p].rs, v, dep ^ 1);
        pushup(p), check(p, dep);
    }
    Matrix query(int p, int x1, int x2, int y1, int y2) {
        if (!p) return I;
        if (in(t[p].lx, t[p].ly, x1, x2, y1, y2) && 
            in(t[p].rx, t[p].ry, x1, x2, y1, y2)) 
            return t[p].ml;
        if (out(t[p].lx, t[p].rx, x1, x2) || 
            out(t[p].ly, t[p].ry, y1, y2)) return I;
        Matrix res = I;
        if (in(t[p].f.x, t[p].f.y, x1, x2, y1, y2))
            res = t[p].f.v;
        return res * query(t[p].ls, x1, x2, y1, y2) 
                * query(t[p].rs, x1, x2, y1, y2);
    }
} t1, t2;
int qpow(int a, int b = mod - 2) {
    int res = 1;
    for (; b; b >>= 1, a = 1ll * a * a % mod)
        if (b & 1) res = 1ll * res * a % mod;
    return res;
}
signed main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    cin >> n >> m;
    I.init();
    int all = 0;
    while (m--) {
        int op, l, r;
        cin >> op >> l >> r;
        if (op == 1) {
            all ^= 1;
            Matrix a;
            a[1][0] = a[0][1] = qpow(r - l + 1);
            a[0][0] = a[1][1] = (mod + 1 - a[1][0]) % mod;
            t1.ins(t1.rt, (point){l, r, a}, 0);

            a[1][0] = a[0][1] = 2 * qpow(r - l + 1) % mod;
            a[0][0] = a[1][1] = (mod + 1 - a[1][0]) % mod;
            t2.ins(t2.rt, (point){l, r, a}, 0);
        } else {
            l--;
            Matrix ans = I;
            ans = ans * t1.query(t1.rt, 0, l, l, r - 1);
            ans = ans * t1.query(t1.rt, l + 1, r, r, n);
            ans = ans * t2.query(t2.rt, 0, l, r, n);
            if (l == 0) {
                cout << ans[0][all] << '\n';
            } else {
                cout << ans[0][0] << '\n';
            }
        }
    }
    return 0;
}
```

---

## 作者：pldzy (赞：1)

妙妙数据结构题！

## Solution

### 1

树状数组倒过来变成什么？求后缀和哇！

那么 $qry(r)-qry(l-1)= suf_r - suf_{l-1}$，而 $suf_r-suf_{l-1}\equiv \sum_{i=l-1}^{r-1}a_i \bmod 2$。其中 $suf_i$ 表示后缀和。

所以其实还是对区间求和。由此发现本题转化为：

- 给定参数 `l r`，随机给 $i\in [l,r]$ 的 $a_i$ 切换 $0/1$ 状态。
- 给定参数 `l r`，求此时 $a_l=a_r$ 成立的概率。

### 2

题目让 $a_i$ 对 $2$ 取模，实在是大有用处哇。

对于操作 1 给出的 $[L,R]$，它们对操作 2 的 $l,r$ 贡献大致分为三种情况：（记 $len=R-L+1$，$P$ 为 $a_l=a_r$ 成立的概率）

- 完全包含 $l,r$，那么有 $\dfrac{len-2}{len}$ 的概率，使得经过此修改操作后 $P$ 保持不变；
- 只包含 $l$ 或 $r$，那么有 $\dfrac{len-1}{len}$ 的概率，使得经过此修改操作后 $P$ 保持不变；
- 不包含 $l$ 或 $r$，那么有 $1$ 的概率，使得经过此修改操作后 $P$ 保持不变。

记上述“不变概率”为 $Q$。

显然有 $P'=PQ+(1-P)(1-Q)$。

### 3

挖掘上式性质。

$$P''=P'K+(1-P')(1-K)\\=(PQ+(1-P)(1-Q))K+(1-(PQ+(1-P)(1-Q)))(1-K)\\=4PQK-2PK-2QK-2PQ+P+Q+K$$

在最终化简的式子中，$P,Q,K$ 是轮换对称的。

也即是说，上述变换满足结合律。也即是说，$P$ 先和 $Q$ 变换还是先和 $K$ 变换，得到的结果都是一样的。

### 4

结合律的性质说明可以做标记永久化。而且又是区间修改单点查询，很符合线段树套线段树的使用场景。

外层线段树维护 $l$，内层维护对应的 $r$，线段树套线段树，标记永久化。~~然后就是板子了~~。

## Code

实现细节：非常非常卡空间。不能开 `long long`，所以在快速幂等运算中要注意乘上 `1ll`。

感觉放在树套树中，是写得蛮清新了。

````cpp
#include<bits/stdc++.h>
using namespace std;

//#define int long long
#define ll int
#define LL long long

#define rep(i, a, b) for(int i = (a); i <= (b); ++i)
#define per(i, a, b) for(int i = (a); i >= (b); --i)
bool Mst;

const int maxn = 1e5 + 5;
const ll mod = 998244353;

int n, m;

inline ll pw(ll x, int p = mod - 2){
	ll res = 1ll; x %= mod;
	while(p){ if(p & 1) res = (LL)1ll * res * x % mod; p >>= 1; x = (LL)1ll * x * x % mod; }
	return res;
}

inline void Mop(ll &p, ll q){
	int tmp = (LL)1ll * p % mod * q % mod;
	int P = (LL)1ll * (1ll - p + mod) % mod, Q = (LL)1ll * (1ll - q + mod) % mod;
	p = (LL)1ll * (1ll * tmp + 1ll * P * Q % mod) % mod;
}

struct tree{
	int ch[2]; ll p;
	tree(){ p = 1ll; }
}t[maxn * 400]; int tot;

#define ls t[x].ch[0]
#define rs t[x].ch[1]

inline void updtr(int &x, int l, int r, int L, int R, ll p){
	if(L > R) return;
	if(!x) x = ++tot;
	if(l >= L and r <= R) return Mop(t[x].p, p), void();
	int mid = l + r >> 1; 
	if(L <= mid) updtr(ls, l, mid, L, R, p);
	if(R > mid) updtr(rs, mid + 1, r, L, R, p);
}
inline void qryp(int x, int l, int r, int p, ll &val){
	if(!x) return; Mop(val, t[x].p);
	if(l == r) return;
	int mid = l + r >> 1;
	if(p <= mid) qryp(ls, l, mid, p, val);
	else qryp(rs, mid + 1, r, p, val);
}

#undef ls
#undef rs

int tr[maxn << 2];

#define ls (x << 1)
#define rs (x << 1 | 1)

inline void updtr(int x, int l, int r, int L, int R, int ql, int qr, ll p){
	if(L > R) return;
	if(l >= L and r <= R) return updtr(tr[x], 1, n, ql, qr, p), void();
	int mid = l + r >> 1;
	if(L <= mid) updtr(ls, l, mid, L, R, ql, qr, p);
	if(R > mid) updtr(rs, mid + 1, r, L, R, ql, qr, p);
}
inline void qryp(int x, int l, int r, int L, int R, ll &val){
	qryp(tr[x], 1, n, R, val);
	if(l == r) return;
	int mid = l + r >> 1; 
	if(L <= mid) qryp(ls, l, mid, L, R, val);
	else qryp(rs, mid + 1, r, L, R, val);
}

#undef ls
#undef rs

bool Med;
signed main(){
	ios_base::sync_with_stdio(0); cin.tie(NULL);
	
	fprintf(stderr, "%.2lfMB\n", abs(&Mst - &Med) / 1024. / 1024.);
	
	cin >> n >> m; int T0 = ++tot;
	
	while(m--){
		int op, l, r; cin >> op >> l >> r;
		int len = r - l + 1;
		if(op == 1){
			updtr(1, 1, n, l, r, l, r, (LL)1ll * (len - 2) * pw(len) % mod);
			updtr(1, 1, n, l, r, r + 1, n, (LL)1ll * (len - 1) * pw(len) % mod);
			updtr(1, 1, n, 1, l - 1, l, r, (LL)1ll * (len - 1) * pw(len) % mod);
			
			updtr(T0, 1, n, l, r, pw(len));
			updtr(T0, 1, n, 1, l - 1, 0);
			updtr(T0, 1, n, r + 1, n, 0);
		} else{
			if(l == 1){
				ll ans = 1ll; qryp(T0, 1, n, r, ans);
				cout << ans << '\n';
			} else{
				ll ans = 1ll; qryp(1, 1, n, l - 1, r, ans);
				cout << ans << '\n';
			}
		}
	}
	return 0;
}
````

---

## 作者：XuYueming (赞：1)

## 前言

题目链接：[洛谷](https://www.luogu.com.cn/problem/P3688)；[UOJ](https://uoj.ac/problem/291)；[LOJ](https://loj.ac/p/2251)。

UOJ 上有很强的数据。

[**更好的阅读体验**](https://www.cnblogs.com/XuYueming/p/18697443)。

## 题意简述

yzh 做 OI 题维护序列 $\{a_n\}$。

她实现了一个后缀和查询函数 $\displaystyle f(x) = \begin{cases}
0  & \text{ if } x=0 \\
\sum\limits_{i=x}^n a_i  & \text{ otherwise }
\end{cases}$，和一个区间查询函数 $g(l, r) = f(r) - f(l - 1)$，显然，她并没有意识到这里有些小问题。以上运算都是在 $\mathbb{F}_2$ 意义下进行的。

初始 $a_i = 0$。这道问题有 $m$ 次操作，每种操作类型为单点加一、区间查询。单点加参数是一个区间 $[l_i, r_i]$，表示随机选取 $p\in[l_i, r_i]$，让 $a_p\gets a_p+1$；区间查询是正常的区间查询和在 $\mathbb{F}_2$ 意义下的结果。

现在，你需要对每一个查询，求出她错误的实现依然能够得到正确答案的概率，对 $998244353$ 取模。

$n,m\leq10^5$。

## 题目分析

### 初步分析

肯定要分析 $g(l, r)$ 什么时候正确。不妨对 $l = 1$ 与否进行讨论。

1. $l = 1$。
    此时 $f(l - 1) = f(0) = 0$。
    $$
    \begin{aligned}
        g(l, r) &= \sum\limits_{i=l}^r a_i  \\
        \Leftrightarrow\quad \sum\limits_{i=r}^n a_i &= \sum\limits_{i=l}^r a_i  \\
        \Leftrightarrow\quad \sum\limits_{i=r+1}^n a_i &= \sum\limits_{i=l}^{r-1} a_i  \\
        \Leftrightarrow\quad \sum\limits_{i=1}^n a_i - \sum\limits_{i=1}^r a_i &= \sum\limits_{i=l}^{r-1} a_i  \\
        \Leftrightarrow\quad \sum\limits_{i=1}^n a_i - \sum\limits_{i=1}^{r-1} a_i - a_r &= \sum\limits_{i=l}^{r-1} a_i  \\
        \Leftrightarrow\quad \sum\limits_{i=1}^n a_i - a_r &= 2\sum\limits_{i=l}^{r-1} a_i  \\
    \end{aligned}
    $$
    注意到在模 $2$ 意义下，右侧为 $0$。
    $$
    \begin{aligned}
        \Leftrightarrow\quad \sum\limits_{i=1}^n a_i=a_r
    \end{aligned}
    $$
    左侧就是到目前位置我们进行了多少次操作，这个随便维护。我们就把问题具象化成求某一个位置为 $0/1$ 的概率。
2. $l > 1$。
    $$
    \begin{aligned}
        g(l, r) &= \sum\limits_{i=l}^r a_i  \\
        \Leftrightarrow\quad \sum\limits_{i=r}^n a_i-\sum\limits_{i=l-1}^n a_i &= \sum\limits_{i=l}^r a_i  \\
        \Leftrightarrow\quad \sum\limits_{i=l}^r a_i + \sum\limits_{i=l-1}^{r-1}a_i &= 0  \\
        \Leftrightarrow\quad a_{l-1}+a_{r} + 2\sum\limits_{i=l}^{r-1}a_i &= 0  \\
        \Leftrightarrow\quad a_{l-1}+a_{r} &= 0  \\
        \Leftrightarrow\quad a_{l-1} &= a_{r}  \\
    \end{aligned}
    $$
    问题简化成求两个位置值相等的概率。

### 暴力模拟

我们考虑一个 $\mathcal{O}(nm)$ 的算法。

对于第一个问题（求 $a_i=x$ 的概率），我们考虑维护 $f[0/1]$ 表示 $a_i=0/1$ 的概率，初始 $f[0] = 1, f[1] = 0$。

$\mathcal{O}(m)$ 地枚举一个包含 $i$ 的修改 $[l, r]\ni i$，那么它恰好修改到 $a_i$ 的概率为 $p=\dfrac{1}{r-l+1}$。也就是说，$a_i$ 有 $p$ 的概率变化，$1-p$ 的概率不变化。那么 $f'[o] \gets p\cdot f[\neg o] + (1-p)f[o]$。于是解决了该问题。

**不怎么有用的发现**：事实上，我们只维护 $f[0] / f[1]$ 即可，因为 $f[0]+f[1] \equiv 1$。

对于第二个问题，我们想当然地求出 $f_{l-1}[0/1], f_r[0/1]$，答案为 $f_{l-1}[0]f_r[0] + f_{l-1}[1]f_r[1]$。但是，这是错误的。

我们发现，有些操作对 $a_{l-1}, a_r$ 的影响不是独立的。对于一个修改 $[ql, qr]\supseteq[l-1,r]$，那么倘若随机到了 $a_{l-1}$，那么此时 $a_r$ 必不可能被修改。这看上去似乎很棘手，事实上，我们仅需将状态扩充至 $f[0/1][0/1]$ 表示 $a_{l-1}, a_r$ 的值即可。这样，对于完全包含 $[l-1, r]$ 的转移为 $f'[x][y]\gets p\cdot f[\neg x][y]+p\cdot f[x][\neg y] + (1-2p)f[x][y]$。剩下仅包含一个端点的转移类似第一个问题。初值 $f[0][0]=1$，其他为 $0$。

```cpp
namespace $pts50 {

pair<int, int> Q[N];

void modify(int l, int r) {
	Q[++X] = { l, r };
}

mint query(int l, int r) {
	if (l > 1) {
		--l;
		mint a[2][2] = {
			{ 1, 0 },
			{ 0, 0 }
		};
		for (int i = 1; i <= X; ++i) {
			mint t[2][2] = {{ a[0][0], a[0][1] }, { a[1][0], a[1][1] }};
			mint p = inv[Q[i].second - Q[i].first + 1];
			if (Q[i].first <= l && r <= Q[i].second) {
				for (int x : { 0, 1 })
					for (int y : { 0, 1 })
						a[x][y] = t[!x][y] * p + t[x][!y] * p + t[x][y] * (1 - p * 2);
			} else if (Q[i].first <= l && l <= Q[i].second) {
				for (int o : { 0, 1 }) {
					a[0][o] = t[0][o] * (1 - p) + t[1][o] * p;
					a[1][o] = t[1][o] * (1 - p) + t[0][o] * p;
				}
			} else if (Q[i].first <= r && r <= Q[i].second) {
				for (int o : { 0, 1 }) {
					a[o][0] = t[o][0] * (1 - p) + t[o][1] * p;
					a[o][1] = t[o][1] * (1 - p) + t[o][0] * p;
				}
			}
		}
		return a[0][0] + a[1][1];
	} else {
		mint a[] = { 1, 0 };
		for (int i = 1; i <= X; ++i)
			if (Q[i].first <= r && r <= Q[i].second) {
				mint p = inv[Q[i].second - Q[i].first + 1];
				mint t[] = { a[0], a[1] };
				a[0] = t[0] * (1 - p) + t[1] * p;
				a[1] = t[1] * (1 - p) + t[0] * p;
			}
		return a[X & 1];
	}
}

void solve() {
	for (int op, l, r, i = 1; i <= m; ++i) {
		scanf("%d%d%d", &op, &l, &r);
		if (op == 1) {
			modify(l, r);
		} else {
			printf("%d\n", query(l, r).raw());
		}
	}
}

}
```

### 抽丝剥茧，转化为熟悉的模型

问题都分析到这了，矩阵呼之欲出了。~~各种数据结构在你脑海里的形象愈发清晰。~~

#### 问题一

先来看看好下手的问题一。我们把 $f[0/1]$ 看做一个 $1\times 2$ 的矩阵，那么对于一个修改，就可以构造出转移矩阵：

$$
\begin{bmatrix}
\small{f[0]} & \small{f[1]}
\end{bmatrix}
\times
\begin{bmatrix}
1-p & p \\
p & 1-p
\end{bmatrix}
=
\begin{bmatrix}
\small{f'[0]} & \small{f'[1]}
\end{bmatrix}
$$

然后，我们请出一个能够区间乘矩阵，单点查询的数据结构。线段树是也。

于是，我们在线地解决了问题一，修改 / 询问 $\mathcal{O}(w^3\log n)$，其中 $w=2$。

#### 问题二

类似的，我们把 $f[0/1][0/1]$ 拍扁成一个 $1\times 4$ 的矩阵，并构造出转移矩阵。

1. 完全包含

  $$
  \begin{bmatrix}
  \scriptsize{f[0][0]} & \scriptsize{f[0][1]} & \scriptsize{f[1][0]} & \scriptsize{f[1][1]}
  \end{bmatrix}
  \times
  \begin{bmatrix}
  1-2p&p&p&  \\
  p&1-2p& &p  \\
  p& &1-2p&p  \\
  &p&p&1-2p
  \end{bmatrix}
  =
  \begin{bmatrix}
  \scriptsize{f'[0][0]} & \scriptsize{f'[0][1]} & \scriptsize{f'[1][0]} & \scriptsize{f'[1][1]}
  \end{bmatrix}
  $$

2. 仅包含左端点

$$
  \begin{bmatrix}
  \scriptsize{f[0][0]} & \scriptsize{f[0][1]} & \scriptsize{f[1][0]} & \scriptsize{f[1][1]}
  \end{bmatrix}
  \times
  \begin{bmatrix}
  1-p&&p&  \\
  &1-p&&  \\
  p&&1-p&p  \\
  &p&&1-p
  \end{bmatrix}
  =
  \begin{bmatrix}
  \scriptsize{f'[0][0]} & \scriptsize{f'[0][1]} & \scriptsize{f'[1][0]} & \scriptsize{f'[1][1]}
  \end{bmatrix}
$$

3. 仅包含右端点

$$
  \begin{bmatrix}
  \scriptsize{f[0][0]} & \scriptsize{f[0][1]} & \scriptsize{f[1][0]} & \scriptsize{f[1][1]}
  \end{bmatrix}
  \times
  \begin{bmatrix}
  1-p&p&&  \\
  p&1-p&&  \\
  &&1-p&p  \\
  &&p&1-p
  \end{bmatrix}
  =
  \begin{bmatrix}
  \scriptsize{f'[0][0]} & \scriptsize{f'[0][1]} & \scriptsize{f'[1][0]} & \scriptsize{f'[1][1]}
  \end{bmatrix}
$$

但是，这时候，我们发现有了区间包含关系的限制，十分地不好搞。

发现如果拍到一个二维笛卡尔坐标系上，这是二维数点状物。俗话说得好，二维数点，静态扫描线而动态 CDQ 也。这里我们使用 CDQ 分治就能解决问题。

三维偏序，一维时间，时间轴分治解决；再一维双指针维护解决；最后一维，数据结构解决。

我们先递归解决 $L=[l, mid], R=(mid, r]$，然后考虑 $L$ 中的修改对 $R$ 中的询问产生的影响。

（这里我们先递归了 $R$，而不是递归 $L$，然后解决跨过分治中心，再递归 $R$，是因为修改的顺序并不影响答案，所以是对的。事实上，严格按照修改的顺序分治也可以。）

考虑完全包含、包含左端点两种情况，包含右端点类似。

我们先分别把 $L, R$ 里所有操作按照左端点升序排序。

考虑以此枚举 $i\in R$，同时双指针维护所有左端点小于等于 $i$ 的左端点的 $j$。

![](https://cdn.luogu.com.cn/upload/image_hosting/qi75ysna.png)

上图中，中间灰色的线表示分治中心，右侧黑色的竖线表示我们枚举的 $i$。我们可以把左侧的 $j$ 分为三类。

- 红色：这一类右端点已经小于 $i$ 的左端点，没有用处，忽略。
- 蓝色：这一类右端点大于等于 $i$ 的右端点，是完全包含类型。
- 绿色：这一类右端点小于 $i$ 的右端点，仅包含 $i$ 的左端点。

所以我们~~情不自禁~~使用两个数据结构，分别维护两种转移矩阵。查询的时候，按照需要查询即可。这个数据结构需要支持单点修改，区间查询矩阵乘。动态开点线段树即可。

于是，我们离线地解决了问题二。时间复杂度不难分析出为 $\mathcal{O}\Big(w^3 m\log m(\log m+\log n)\Big)$，其中 $w = 4$。

### 收尾工作（~~卡常~~）

整体空间复杂度很不错，差不多是线性的 $\mathcal{O}(w^2 (n + m))$。

整体时间复杂度在两只 $\log$ 的基础上有矩阵乘法 $w^3$ 的加持，十分难受。

我们发现，由于我们提到修改的顺序不影响答案，那么我们把处理右端点提出来，做两次 CDQ 分治，这样，每次分治内部不需要排序，而是使用原地归并。将 $(\log m+\log n)$ 因子优化为了 $\log n$ 因子。

我们再次发现，在处理完全包含类型时，我们的区间查询是后缀查询，那么用一棵树状数组代替一棵线段树，时间复杂度没有变化，但是常数更小了。由于我不会动态开点树状数组这种科技，所以采用了时间戳清空。

我们又又发现，线段树可以搞一搞。我们多维护一个 `bool` 类型的标记，表示这个节点的矩阵是不是单位矩阵，在询问时，如果遇到一个单位矩阵，就不进行矩阵乘法。在新建节点时，我们采用直接赋值，而不是先弄成单位矩阵，再做一次矩阵乘法。

我们努努力，把矩阵乘法手动做循环展开。

我们上传统手艺，加上超级快读快写。

我们发现，我们终于过了这题……

## 代码

见[我的博客](https://www.cnblogs.com/XuYueming/p/18697443)。

---

## 作者：Phartial (赞：1)

在正确的树状数组（为与题目中给出的树状数组区分，操作名中将加上 $'$ 号）中，$\operatorname{Add}'(i)$ 操作能够贡献到 $\operatorname{Find}'(j)$ 操作当且仅当 $i\le j$，所以 $\operatorname{Find}'(j)$ 计算的是前缀和。记 $S_i$ 为 $A_i$ 的前缀和，则有 $\operatorname{Query}'(l,r)=(S_r-S_{l-1})\bmod 2$。

而在本题中这个贡献顺序反了过来，所以 $\operatorname{Find}(j)$ 计算的东西变成了后缀和。有 $\operatorname{Query}(l,r)=(S_{r-1}-S_{l-2})\bmod 2$。要使 $\operatorname{Query}$ 操作正确，就得有 $S_{r-1}-S_{l-2}\equiv S_r-S_{l-1}\pmod 2$，即 $A_r=A_{l-1}$。

因为 $A_i=p$ 和 $A_j=q$ 这两个事件不一定独立，所以我们不能分别计算 $A_{i}/A_j$ 等于 $0/1$ 的概率并简单的结合，而只能直接维护 $A_i=A_j$ 的概率。

记变量 $X_{i,j}=[A_i=A_j]$，$P_{i,j}=P(X_{i,j}=1)$。

考虑一次操作 $[l,r]$ 对 $X_{i,j},P_{i,j}$ 的影响（不妨令 $i\le j$）：

- $l\le i\le j\le r$：此时 $i,j$ 各有 $\dfrac{1}{r-l+1}$ 的概率被取反，总共有 $\dfrac{2}{r-l+1}$ 的概率使 $X_{i,j}$ 被取反；
- $i<l\le j\le r$ 或 $l\le i\le r<j$：此时 $i$ 或 $j$ 有 $\dfrac{1}{r-l+1}$ 的概率被取反，总共有 $\dfrac{1}{r-l+1}$ 的概率使 $X_{i,j}$ 被取反；
- $i<l\le r<j$ 或 $i\le j<l\le r$ 或 $l\le r<i\le j$：此时 $i,j$ 不被影响。

以上三种情况所涉及到的操作均可以转化成二维平面上的 $\mathcal{O}(1)$ 次矩阵操作。

假设一次操作有 $p$ 的概率使 $X_{i,j}$ 被取反，则有 $P_{i,j}\gets (1-p)P_{i,j}+p(1-P_{i,j})$，不妨记做 $P_{i,j}\gets P_{i,j}\otimes p$。容易验证 $\otimes$ 有交换律，因此我们可以平凡的使用标记永久化的树套树进行维护。

特别的，如果 $l=1$，则 $\operatorname{Query}'(l,r)=S_r$，$\operatorname{Query}(l,r)=(S_n-S_{r-1})\bmod 2$，判定条件变为 $A_r\equiv S_n\pmod 2$，额外维护 $F_i=[A_i=S_n],G_i=P(F_i=1)$ 即可。考虑一次操作对其的影响：

- $l\le i\le r$：此时 $S_n$ 必然被取反，$A_i$ 有 $\dfrac{1}{r-l+1}$ 的概率被取反，$F_i$ 有 $\dfrac{r-l}{r-l+1}$ 的概率被取反；
- $i<l$ 或 $r<i$：此时 $S_n$ 必然被取反，$A_i$ 必然不被取反，因此 $F_i$ 必然被取反。

若一次操作有 $p$ 的概率使 $F_i$ 被取反，则有 $G_i\gets G_i\otimes p$。同样可以使用标记永久化的树套树进行维护。

```cpp
#include <iostream>
#include <vector>

using namespace std;
using LL = long long;

const int kN = 1e5 + 2;
const int kM = 998244353;

struct Ie {
  int v, l, r;
};
vector<Ie> ie;
int n, q, oe[kN * 4];

LL P(LL b, int e) {
  LL s = 1;
  for (; e; e >>= 1, b = b * b % kM) {
    (e & 1) && (s = s * b % kM);
  }
  return s;
}
int O(int x, int y) { return (x * (1LL - y + kM) + y * (1LL - x + kM)) % kM; }
int N() {
  ie.push_back(Ie());
  return ie.size() - 1;
}
void Ia(int &x, int l, int r, int tl, int tr, int v) {
  if (!x) {
    x = N();
  }
  if (l == tl && r == tr) {
    ie[x].v = O(ie[x].v, v);
    return;
  }
  int m = l + r >> 1;
  if (tl <= m) {
    Ia(ie[x].l, l, m, tl, min(m, tr), v);
  }
  if (m < tr) {
    Ia(ie[x].r, m + 1, r, max(m + 1, tl), tr, v);
  }
}
void Oa(int x, int l, int r, int tl, int tr, int il, int ir, int v) {
  if (l == tl && r == tr) {
    Ia(oe[x], 1, n, il, ir, v);
    return;
  }
  int m = l + r >> 1;
  if (tl <= m) {
    Oa(x * 2, l, m, tl, min(m, tr), il, ir, v);
  }
  if (m < tr) {
    Oa(x * 2 + 1, m + 1, r, max(m + 1, tl), tr, il, ir, v);
  }
}
int Iq(int x, int l, int r, int t) {
  if (!x) {
    return 0;
  }
  if (l == r) {
    return ie[x].v;
  }
  int m = l + r >> 1;
  return O(ie[x].v, t <= m ? Iq(ie[x].l, l, m, t) : Iq(ie[x].r, m + 1, r, t));
}
int Oq(int x, int l, int r, int p, int q) {
  if (l == r) {
    return Iq(oe[x], 1, n, q);
  }
  int m = l + r >> 1;
  return O(Iq(oe[x], 1, n, q), p <= m ? Oq(x * 2, l, m, p, q) : Oq(x * 2 + 1, m + 1, r, p, q));
}

int main() {
  ios_base::sync_with_stdio(0), cin.tie(0);
  ie.reserve(kN * 400);
  ie.push_back(Ie());
  cin >> n >> q;
  for (int o, l, r; q--; ) {
    cin >> o >> l >> r;
    if (o == 1) {
      LL i = P(r - l + 1, kM - 2);
      Oa(1, 0, n, l, r, l, r, 2 * i % kM);
      if (l > 1) {
        Oa(1, 0, n, 1, l - 1, l, r, i);
      }
      if (r < n) {
        Oa(1, 0, n, l, r, r + 1, n, i);
      }
      Oa(1, 0, n, 0, 0, l, r, (r - l) * i % kM);
      if (l > 1) {
        Oa(1, 0, n, 0, 0, 1, l - 1, 1);
      }
      if (r < n) {
        Oa(1, 0, n, 0, 0, r + 1, n, 1);
      }
    } else {
      cout << O(1, Oq(1, 0, n, l - 1, r)) << '\n';
    }
  }
  return 0;
}
```


---

## 作者：DrBit (赞：1)

[题面](https://www.luogu.com.cn/problem/P3688)

~~由题目标题得正解肯定不是树状数组~~

手摸一下可以发现可怜的树状数组维护的是后缀和，再加上对 2 取模的特性，可以得出可怜所求出的是 $[l-1,r-1]$ 的区间和。

那么答案正确的充要条件就是 $a_{l-1} = a_{r} $。

用二维线段树维护平面内点对 $(x,y)$，表示 $a_x$ 与 $a_y$ 相等的概率。

显然只需要维护 $x \le y$ 的部分。（其实 $x\ge y$ 的部分也可以维护，只是查询时用不到）

那么对于一个修改 $[l,r]$，可以看做把整个平面分成了 9 份。

![](https://cdn.luogu.com.cn/upload/image_hosting/dhoikmy9.png)

其中四条线分别为 $x=l$，$x=r$，$y=l$，$y=r$。

其中 6、8、9 三个块 $x \ge y$，不需要维护。

而 1、3、7 三个块不会受到这次修改的影响。（左右端点都没有被 $[l,r]$ 覆盖）

设 $len=r-l+1$。

而 2、4 两个块内的点对满足其中一个点在 $[l,r]$ 中，有 $\frac{1}{len}$ 的概率被修改导致两项不等。

5 块内点对中的两个点都在 $[l,r]$ 中，有 $\frac{2}{len}$ 的概率两个点中的一个被修改而导致两项不等。

考虑概率的合并问题：

如果一个点对 $(x,y)$ 先有 $p$ 的概率相等，再有 $q$ 的概率相等，那么总的相等的概率就是 $pq+(1-p)(1-q)$。

1. 不等的情况只有 $(1,0)$ 和 $(0,1)$ 两种，如果再来一次不等修改就会改回相等的情况，所以“负负得正”两次不等会导回相等。

2. 这也算是证明了概率合并这个操作满足结合律，所以可以使用标记永久化。（具体证明建议自己手摸一下）

还有就是线段树的第二维要动态开点，因为是区间修改单点查询，所以要标记永久化。

最后还有一件事，返回题目可以看到题中的 query 函数有一个 $x=0$ 返回 0 的特判，这使得当 $l=1$ 时正确答案是 $[1,r]$ 的区间和而可怜求出的是 $[r,n]$ 的区间和，所以可以单独开一棵线段树记录一个节点 $i$ 的前缀和后缀和是否相等。

对于一次修改 $(l,r)$：

如果 $i \le l $ 或 $i \ge r$，那么前缀后缀肯定不等。

如果 $ l \le i \le r$，那么有 $\frac{len-1}{len}$ 的概率前缀后缀不等。
 
~~花了好久时间才弄懂这题，希望能给你些帮助。~~

[CODE](https://www.luogu.com.cn/paste/t9vmrghe) 

---

## 作者：DeepSeaSpray (赞：0)

# P3688 [ZJOI2017] 树状数组

首先题目中说方向反了，实际上就是前缀和求成了后缀和。

设 $F$ 为前缀，$G$ 为后缀，$S$ 为区间和，程序通过样例当且仅当。

> $\mod 2$ 意义下的加减法可以统一成异或。

$$
F(r) \oplus F(l-1) = G(r) \oplus G(l-1)
$$

转化为区间和，即：

$$
S(l,r) = S(l-1,r-1)
$$

消去公共部分，即：

$$
A(l-1) = A(r)
$$

由此对于每一个询问实际上在询问 $A(l-1)=A(r)$ 的概率。

对于修改操作，变成了区间修改，带上概率。

有点眉目了，先看看概率的部分。

对于每一次修改，对于一个询问，如果该询问原来的正确概率为 $P$，当前修改有 $Q$ 的概率不会影响该询问涉及的位置。

那么修改操作后，询问的正确概率为 $PQ + (1-P)(1-Q)$。

现在我们了解了一个修改操作对于询问的影响。直接暴力不可取，所以我们需要找到一种方法可以快速维护出修改以及快速查询出询问。

我们注意到每一个询问包含两个位置 $(l,r)$，可以考虑使用二维线段树表示每一个询问的答案，这样我们查询就是单点查询。

考虑修改。

对于一个修改 $(l,r)$，其会对二维线段树线段树上区间造成如下影响 $(X,Y)$表示线段树上的点（即询问）。

为了方便，不妨约定 $X < Y$，$Q$ 与上文含义相同。

同时，记 $t = \dfrac{1}{r-l+1}$。

- $X \in [1,l) , Y \in [l,r]$ 时 $Q = 1 - t$。
- $X \in [l,r] , Y \in [l,r]$ 时 $Q = 1 - 2t$。
- $X \in [l,r] , Y \in (r,n]$ 时 $Q = 1 - t$。

当然我们注意到询问中的 $l$ 可能为 $0$（回顾上文）。此时其实查询的是 $F(r) = G(r)$ 的概率。

- $X = 0 , Y \in [1,l)$ 时 $Q = 0$。
- $X = 0 , Y \in [l,r]$ 时 $Q = t$。
- $X = 0 , Y \in (r,n]$ 时 $Q = 0$。

值得注意的是即使 $Q = 0$ 也需要向下修改。

实现上，标记直接用上文的方法合并就可以了，有点卡时空，所以用标记永久化，第二维线段树需要动态开点，不要开太多 `long long`，记得取模即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int maxn=1e5;
const int maxm=maxn*400;
const int mod=998244353;
int n,Q;
int ls[maxm+5],rs[maxm+5],V[maxm+5];
int rt[(maxn<<2)+5],tt;
inline ll Fpow(ll x,ll y){
	ll res=1;
	for(x%=mod;y;y>>=1,x=x*x%mod)
		if(y&1) res=res*x%mod;
	return res;
}
inline ll Getval(ll x,ll y){
	return (x*y+(1-x)*(1-y))%mod;
}
void ModifyY(int &x,int L,int R,int l,int r,ll v){
	if(!x) x=++tt,V[x]=1;
	if(l<=L&&R<=r) V[x]=Getval(V[x],v);
	else{
		int mid=(R-L)/2+L;
		if(l<=mid) ModifyY(ls[x],L,mid,l,r,v);
		if(mid<r) ModifyY(rs[x],mid+1,R,l,r,v);
	}
}
void ModifyX(int x,int L,int R,int lx,int rx,int ly,int ry,ll v){
	if(lx<=L&&R<=rx) ModifyY(rt[x],1,n,ly,ry,v);
	else{
		int mid=(R-L)/2+L;
		if(lx<=mid) ModifyX(x<<1,L,mid,lx,rx,ly,ry,v);
		if(mid<rx) ModifyX(x<<1|1,mid+1,R,lx,rx,ly,ry,v); 
	}
}
int QueryY(int x,int L,int R,int p){
	if(!x) return 1;
	int t=V[x];
	if(L==R) return t;
	else{
		int mid=(R-L)/2+L;
		if(p<=mid)
			return Getval(t,QueryY(ls[x],L,mid,p));
		else return Getval(t,QueryY(rs[x],mid+1,R,p));
	}
}
int QueryX(int x,int L,int R,int px,int py){
	int t=QueryY(rt[x],1,n,py);
	if(L==R) return t;
	else{
		int mid=(R-L)/2+L;
		if(px<=mid)
			return Getval(t,QueryX(x<<1,L,mid,px,py));
		else return Getval(t,QueryX(x<<1|1,mid+1,R,px,py));
	}
}
signed main(){
	int op,l,r;
	ll t;
	scanf("%d%d",&n,&Q);
	while(Q--){
		scanf("%d%d%d",&op,&l,&r);
		if(op==1){
			t=Fpow(r-l+1,mod-2);
			if(1<=l-1){
				ModifyX(1,0,n,1,l-1,l,r,(1-t)%mod);
				ModifyX(1,0,n,0,0,1,l-1,0);
			}
			if(r+1<=n){
				ModifyX(1,0,n,l,r,r+1,n,(1-t)%mod);
				ModifyX(1,0,n,0,0,r+1,n,0);
			}	
			ModifyX(1,0,n,l,r,l,r,(1-2*t)%mod);
			ModifyX(1,0,n,0,0,l,r,t);
		}
		else{
			t=QueryX(1,0,n,l-1,r);
			printf("%lld\n",(t+mod)%mod);
		}
	}
	return 0;
}
```

---

## 作者：lupengheyyds (赞：0)

记录一下做这道题的心路历程，说明在没有事先知道“九条是求成了后缀和”的情况下如何发现，以及解释一些部分分的做法。

### sub1,18pts：暴力搜索

无脑枚举，复杂度 $\mathcal O(n^m)$。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
#define loop(i,a,b) for(int i=a;i<=b;i++)
#define pool(i,a,b) for(int i=a;i>=b;i--)
using namespace std;
const int NN=1e5+5,MOD=998244353;
int n,m,ac[NN],wa[NN],p[NN];
int QP(int a,int b){
    int c=1;
    for(;b;b>>=1){
        if(b&1)c=1ll*c*a%MOD;
        a=1ll*a*a%MOD;
    }
    return c;
}
void AC_Add(int x){
    for(;x<=n;x+=x&-x)ac[x]^=1;
}
int AC_Ask(int x){
    if(x==0)return 0;
    int sum=0;
    for(;x;x-=x&-x)sum^=ac[x];
    return sum;
}
int AC_Query(int l,int r){
    return AC_Ask(r)^AC_Ask(l-1);
}
void WA_Add(int x){
    for(;x;x-=x&-x)wa[x]^=1;
}
int WA_Ask(int x){
    if(x==0)return 0;
    int sum=0;
    for(;x<=n;x+=x&-x)sum^=wa[x];
    return sum;
}
int WA_Query(int l,int r){
    return WA_Ask(r)^WA_Ask(l-1);
}
struct Oper{
    int op,l,r;
    void read(){
        cin>>op>>l>>r;
    }
}qwq[NN];
int ans[NN];
void DFS(int x,int cnt){
    if(x==m+1)return;
    if(qwq[x].op==2){
        ans[x]=(ans[x]+(AC_Query(qwq[x].l,qwq[x].r)==WA_Query(qwq[x].l,qwq[x].r))*p[cnt])%MOD;
        DFS(x+1,cnt);
    }else{
        loop(i,qwq[x].l,qwq[x].r){
            AC_Add(i),WA_Add(i);
            DFS(x+1,cnt+1);
            AC_Add(i),WA_Add(i);
        }
    }
    return;
}
signed main(){
    cin>>n>>m;
    int cnt=0;
    p[0]=1;
    loop(i,1,m){
        qwq[i].read();
        if(qwq[i].op==1){
            cnt++;
            p[cnt]=1ll*p[cnt-1]*QP(qwq[i].r-qwq[i].l+1,MOD-2)%MOD;
        }
    }
    DFS(1,0);
    loop(i,1,m)if(qwq[i].op==2)cout<<ans[i]%MOD<<"\n";
    return 0;
}
```

但这份代码并不是一无是处，它可以帮我们对拍，并且我们的思路也将从这开始

### sub1~3,48pts：DP

根据上述搜索，我们应该考虑记忆化进行剪枝，发现统计答案的时候只与 `AC_Query(qwq[x].l,qwq[x].r)==WA_Query(qwq[x].l,qwq[x].r)` 这个值有关，记为 $d$，所以我们可以考虑将其记录下来，并且注意到各个询问之间是没有关系的，我们可以枚举并分别处理。

对于第 $id$ 个询问，记录 $f_{i}$ 表示进行前 $i$ 次操作后 $d=0$ 的概率，$p$ 表示第 $i$ 个操作对 $d$ 造成变化的概率，则有 $f_{i}=p(1-f_{i-1})+(1-p)f_{i-1}$，那么如何求得 $p$？这就要看九条的错误代码的性质：

我们发现其查询（红色）是从左下到右上，修改（蓝色）是从右下到左上，而这两者相交的充要条件就是蓝色线条的起点在红色线条起点的右边，即如果一个修改操作在一个查询操作的右边，就会产生贡献，那不就是后缀和吗？

![pAZrU56.png](https://s21.ax1x.com/2024/09/05/pAZrU56.png)

于是 `AC_Query` 就是查询 $[l,r]$ 的值，`WA_Query` 就是查询 $[l-1,r-1]$ 的值，那么使得答案不同当且仅当修改了 $l-1,r$ 这两个位置，枚举每个询问，假设包含了 $x$ 个，则 $p=\frac{x}{R-L+1}$。

注意当 $l=1$ 的时候需要特判，此时  `AC_Query` 查询 $[1,r]$ 的值，`WA_Query` 查询 $[r,n]$ 的值，那么使得答案不同当且仅当没有修改 $r$，$p=\frac{R-L+1-[L\le r\le R]}{R-L+1}$。

复杂度 $\mathcal O(nm)$。

代码如下：

```cpp
#include<bits/stdc++.h>
#define loop(i,a,b) for(int i=a;i<=b;i++)
#define pool(i,a,b) for(int i=a;i>=b;i--)
using namespace std;
const int NN=1e5+5,MOD=998244353;
int n,m,f;
int QP(int a,int b){
    int c=1;
    for(;b;b>>=1){
        if(b&1)c=1ll*c*a%MOD;
        a=1ll*a*a%MOD;
    }
    return c;
}
struct Oper{
    int op,l,r;
    void read(){cin>>op>>l>>r;}
}qwq[NN];
struct Seq{int t,l,r;};
vector<Seq> vec_qry;
int ans[NN];
int In(Oper b,int x){return b.l<=x&&x<=b.r;}
int main(){
    cin>>n>>m;
    loop(i,1,m){
        qwq[i].read();
        if(qwq[i].op==2)vec_qry.push_back({i,qwq[i].l,qwq[i].r});
    }
    for(Seq qry:vec_qry){
        f=1;
        loop(i,1,qry.t-1){
            int cnt=0;
            if(qwq[i].op==2)continue;
            if(qry.l!=1)cnt=In(qwq[i],qry.r)+In(qwq[i],qry.l-1);
            else cnt=qwq[i].r-qwq[i].l+1-(qwq[i].l<=qry.r&&qry.r<=qwq[i].r);
            int p=1ll*cnt*QP(qwq[i].r-qwq[i].l+1,MOD-2)%MOD;
            f=(f+p-2ll*p*f%MOD+MOD)%MOD;
        }
        cout<<(f+MOD)%MOD<<"\n";
    }
    return 0;
}
```

### All,100pts：二维线段树

考虑到 $0\le x\le 2$，我们可以直接**分类讨论！**

- $l-1\in [1,L-1],r\in[1,L-1]\cup[R+1,n]\implies p=0$

- $l-1\in [1,L-1],r\in[L,R]\implies p=\frac 1{R-L+1}$

- $l-1\in [L,R],r\in [L,R]\implies p=\frac2{R-L+1}$

- $l-1\in [L,R],r\in [R+1,n]\implies p=\frac 1{R-L+1}$

- $l-1\in [R+1,n],r\in [R+1,n]\implies p=\frac 1{R-L+1}$

- $l-1=0,r\in [1,L-1]\cup[R+1,n]\implies p=1$

- $l-1=0,r\in [L,R]\implies p=\frac{R-L}{R-L+1}$

这就变为了一个二维数点问题。

因为转移 $ \begin{bmatrix}1-p,p\\p,1-p\end{bmatrix}\begin{bmatrix}f_{i-1}\\1-f_{i-1}\end{bmatrix}=\begin{bmatrix}f_{i}\\1-f_{i}\end{bmatrix}$ 形如一个对称矩阵，有结合律，于是可以直接用线段树进行维护。

复杂度 $\mathcal O(m\log^2n)$。

代码如下：

```cpp
#include<bits/stdc++.h>
#define loop(i,a,b) for(int i=a;i<=b;i++)
#define pool(i,a,b) for(int i=a;i>=b;i--)
using namespace std;
const int NN=1e5+5,MOD=998244353;
int n,m;
int QP(int a,int b){
    int c=1;
    for(;b;b>>=1){
        if(b&1)c=1ll*c*a%MOD;
        a=1ll*a*a%MOD;
    }
    return c;
}
struct SegTr{
    int ls,rs,v;
    #define ls(x) sgt[x].ls
    #define rs(x) sgt[x].rs
    #define v(x) sgt[x].v
}sgt[NN*400];
int rt[NN<<2],tot;
int Mul(int p,int q){return (1-p-q+2ll*p*q%MOD)%MOD;}
void PruneY(int&p,int l,int r,int v,int L=1,int R=n){
    if(l>R||L>r||l>r)return;
    if(!p)p=++tot,v(p)=1;
    if(l<=L&&R<=r){v(p)=Mul(v(p),v);return;}
    int mid=L+R>>1;
    PruneY(ls(p),l,r,v,L,mid);
    PruneY(rs(p),l,r,v,mid+1,R);
    return;
}
void PruneX(int p,int l,int r,int inl,int inr,int v,int L=0,int R=n){
    if(l>R||L>r||l>r)return;
    if(l<=L&&R<=r)return PruneY(rt[p],inl,inr,v);
    int mid=L+R>>1;
    PruneX(p<<1,l,r,inl,inr,v,L,mid);
    PruneX(p<<1|1,l,r,inl,inr,v,mid+1,R);
    return;
}
int PickY(int p,int pos,int L=1,int R=n){
    if(!p)return 1;
    if(L==R)return v(p);
    int mid=L+R>>1;
    if(pos<=mid)return Mul(PickY(ls(p),pos,L,mid),v(p));
    else        return Mul(PickY(rs(p),pos,mid+1,R),v(p));
}
int PickX(int p,int pos,int inpos,int L=0,int R=n){
    if(L==R)return PickY(rt[p],inpos);
    int mid=L+R>>1;
    int tmp=PickY(rt[p],inpos);
    if(pos<=mid)return Mul(PickX(p<<1,pos,inpos,L,mid),tmp);
    else        return Mul(PickX(p<<1|1,pos,inpos,mid+1,R),tmp);
}
int Mod(int p){return (p%MOD+MOD)%MOD;}
signed main(){
    cin>>n>>m;
    loop(i,1,m){
        int op,l,r;cin>>op>>l>>r;
        if(op==1){
            int p=QP(r-l+1,MOD-2);
            PruneX(1,1,l-1,l,r,Mod(1-p)),PruneX(1,0,0,1,l-1,0);
            PruneX(1,l,r,r+1,n,Mod(1-p)),PruneX(1,0,0,r+1,n,0);
            PruneX(1,l,r,l,r,Mod(1-2*p)),PruneX(1,0,0,l,r,p);
        }
        else cout<<Mod(PickX(1,l-1,r))<<"\n";
    }
    return 0;
}
```

### 夹带私货

过程中我想错了，结果转化为了[这一道题](https://www.luogu.com.cn/problem/U475796)，发现这一道也可用本题的方法做，欢迎大家来做。

---


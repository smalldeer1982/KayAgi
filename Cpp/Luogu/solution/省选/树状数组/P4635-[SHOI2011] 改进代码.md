# [SHOI2011] 改进代码

## 题目描述

 PP 写了两段对数组进行操作的代码。

对于 Pascal 选手，两段代码分别如下： 

```
procedure operate1(l, r, c : longint);
var
    i : longint;
begin
    for i := l to r do
        a[i] := (a[i] + c) mod p;
end;

procedure operate2(l, r : longint);
var
    i, cnt : longint;
begin
    cnt := 0;
    for i := l to r - 1 do
        if a[i] > a[i + 1]
            then cnt := cnt + 1;
    writeln(cnt);
end;
```

对于 C / C++ 选手，两段代码分别如下：

```cpp
void operate1(int l, int r, int c)
{
    int i;
    for (i = l; i <= r; ++i)
        a[i] = (a[i] + c) % p;
}

void operate2(int l, int r)
{
    int i, cnt = 0;
    for (i = l; i < r; ++i)
        if (a[i] > a[i + 1])
            ++ cnt;
    printf("%d\n", cnt);
}
```

于是，主程序就可以通过调用这两个子程序对数组 $a_i$​​ 进行操作，下面是示例代码。

对于 Pascal 选手，代码如下：

```
begin
    operate1(1, 4, 3);
    operate1(4, 7, 4);
    operate2(1, 7);
end.
```

对于 C / C++ 选手，代码如下：

```
int main()
{
    operate1(1, 4, 3);
    operate1(4, 7, 4);
    operate2(1, 7);
}
```

但是 QQ 觉得 PP 的程序效率太低了，他想请你优化 PP 的代码。即，对于一段只包含 ``operate1`` 、 ``operate2`` 两种语句的主程序以及运行之前数组 $a_i$​​ 的初始值，请你计算出他的输出。

## 说明/提示

**数据范围与提示**

测试点 $1$：$n \le 1000,m \le 2000$。

测试点 $2 \sim 3$：$n \le 100000$,$m \le 200000$,$c \le 1$,$a_i \le 100000$,$p>500000$。

测试点 $4$：$n \le 100000,m \le 200000,l=1,r=n$。

测试点 $5 \sim 6$：$n \le 100000,m \le 200000$ 且对于所有 ``operate1`` 的参数都有 $l=1,r=n$。

测试点 $7 \sim 10$：$n \le 100000,m \le 200000$。

保证 $1 \le l \le r \le n,0 \le c \le 10^8,p \le 10^6$​​.

## 样例 #1

### 输入

```
7 3 7
2
5
3
0
3
1
2
1 1 4 3
1 4 7 4
2 1 7```

### 输出

```
2```

## 样例 #2

### 输入

```
5 5 2
1
0
0
1
0
2 1 4
2 1 5
1 3 5 1
2 1 4
2 1 3```

### 输出

```
1
2
2
1```

# 题解

## 作者：UnyieldingTrilobite (赞：10)

好题。

首先肯定是尝试硬上线段树......然后发现每次 `operate1` 对 `operate2` 统计量的影响不是很好算......

怎么办？

~~凉拌。~~

发现 `operate1` 其实就是正常的区间加，可以尝试思考一下差分（毕竟没啥思路）。

现在问题就来了：区间加是否能够转化为单点加？

仔细想想，**有点问题**。

因为要取尛，这就会导致中间的差分数组不一定全部不变，可能会乱七八糟= =。

没办法了= =。

换种思路，主要的混乱在于取尛，那如果把取尛扔进差分数组（也就是原数组开始乱变但是差分数组正常，反正不关心原数组了= =），那是不是 `operate1` 就水掉了？

~~至少先干掉一个。~~

再想想，这个差分数组要推回原序列其实也不是很难= =。

也就是前缀和取尛。

那，既然差分数组都是正的，什么样的位置会对 `operate2` 产生贡献？

也就是前缀和计算到后一个数的结果反而比前一个数大？

**也就是一路加过去之后，取尛把它变小了，也就是“溢出”了。**

观察到我们可以把 `operate2` 的区间转化为两个前缀之差。

所以只需要解决一路前缀和加到某个数“溢出”了几次。

好好想想，到这里已经水了，~~自行思考吧。~~

~~没思考出来的可以继续看。~~

**就是不取尛前缀和加到这里，除以 $p$ 下取整的值。**

为什么？自行思考，或者画个栗子膜你吧。

嗯到这里就没了= =。

BIT维护，Over.

几个事情：

1. 还是有点懵的建议再理理，或者画画样例，或者找我问，或者换个题解。

2. 怎么想到的？真就玄学呗= =。反正我是拍脑瓜想出来的，这题思路也算是对新手比较不友好（吧？可能我菜）。

最后是代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+9;
int n,m,p;
int bit[N],raw[N];//raw即原差分数组，用来判断单点加该加多少
void update(int pos,int val){
	for(raw[pos]=(raw[pos]+val)%p;pos<=n;pos+=pos&-pos)bit[pos]+=val;
}//点更新
int query(int pos){
	int ret=0;
	while(pos)ret+=bit[pos],pos&=pos-1;
	return ret;
}//前缀和查询
signed main(){
	cin>>n>>m>>p;
	for(int i=1,prv=0,x;i<=n;++i)cin>>x,update(i,(x-prv+p)%p),prv=x;//直接更新差分数组
	for(int num,l,r,c;m;--m){
		cin>>num>>l>>r;
		if(num==1)cin>>c,c%=p,++r,update(l,raw[l]+c>=p?c-p:c),update(r,raw[r]>=c?-c:p-c);//点更新
		else cout<<query(r)/p-query(l)/p<<endl;//前缀和相减
	}
	return 0;
}//Over.
```

祝大家AC！

---

## 作者：AquaRio (赞：6)

写在前面：此题数据出锅，详见讨论，请管理员大大修锅。

[博客食用效果更佳](https://aqours.life/index.php/solution-P4635.html)

**[题目传送门](https://www.luogu.org/problem/P4635)** 

## Description

给定一个数列，一个模数 $p$ ，你需要实现这些操作：

1. 区间加上一个数。
2. 询问区间 $[l,r]$ 中，相邻的两个数，满足前者大于后者，这样的数对的个数。

在任何时刻，区间内的每一个数都对 $p$ 取模。

$n\leq 10^5 $

## Solution

这题做法很巧妙，观摩了很久才明白怎么做。

我们先把取模放在一边，如何处理区间加？我们想到差分、线段树。

然而线段树并不能很好的解决操作2，区间加的时候万一被取模了，线段树没有办法维护。

所以我们考虑差分。我们处理出差分数组，然后**将差分数组对 $p$ 取模**（负数要化为正数）。

那么 $a[i]-a[i+1]>=1$ **相当于取模之后的差分数组做前缀和的时候发生了“溢出”**。

但是这样的方法还是 $(n^2)$ 的，怎么优化呢？

我们冷静思考发现，当溢出时，前缀和会减少 $p$ ，所以只需维护取模后的差分数组的前缀和，并且要单点修改。那么我们开一个树状数组就解决了。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define qaq "Lovely_XianShen"
typedef long long ll;
ll n, m, p;

ll c[100005], del[100005];

inline ll read() {
    ll x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9') {
        if (ch == '-')
            f = -1;
        ch = getchar();
    };
    while (!(ch < '0' || ch > '9')) {
        x = (x << 3) + (x << 1) + ch - '0';
        ch = getchar();
    }
    return x * f;
}

inline ll lowbit(int x) { return x & (-x); }
inline void add(int x, ll d) {
    c[x] += d;
    while (x <= n) {
        del[x] += d;
        x += lowbit(x);
    }
}
inline ll sum(int x) {
    ll res = 0;
    while (x) {
        res += del[x];
        x -= lowbit(x);
    }
    return res;
}

int main() {
    n = read();
    m = read();
    p = read();
    int last_number = 0;
    for (int i = 1; i <= n; i++) {
        int now_number = read();
        add(i, now_number < last_number ? now_number + p - last_number : now_number - last_number);
        last_number = now_number;
    }
    while (m--) {　
        // cout<<qaq<<endl;
        int opt = read();
        if (opt == 1) {
            ll l = read(), r = read(), d = read();
            add(l, (c[l] + d) % p - c[l]);
            if (r <= n - 1)
                add(r + 1, ((c[r + 1] - d % p) + p) % p - c[r + 1]);
        } else {
            ll l = read(), r = read();
            printf("%d\n", sum(r) / p - sum(l) / p);
        }
    }
    return 0;
}
```

---

## 作者：LittleYang0531 (赞：5)

# [SHOI2011]改进代码 题解

由于题解区唯二的两篇题解全都是 $\mathcal{O}(n\log n)$ 做法，据说对新手不太友好，因此有了这篇更好理解的 $\mathcal{O}(m\sqrt n)$ 算法。

本题解并非最优解，如果仅仅是为了追求最优解的话建议去看其他人的题解，我在此仅是为了提供另外一种思路罢了。

考虑当区间内的数全部加上 $x$  后对答案的贡献是什么?

1. 对于一开始就是 $a_i=a_{i+1}$ 的情况，无论加多少都不可能对答案产生贡献。

2. 对于一开始是 $a_i<a_{i+1}$ 的情况，只有当 $a_{i+1}+x\geq p$ 且 $a_i+x<p$ 时，$a_{i+1}$ 会因为模上 $p$ 的限制而改变 $a_i$ 和 $a_{i+1}$ 之间的大小关系，答案会加 $1$。

3. 对于一开始是 $a_i>a_{i+1}$ 的情况，只有当 $a_{i+1}+x<p$ 且 $a_i+x\geq p$ 时，$a_i$ 会因为模上 $p$ 的限制而改变 $a_i$ 和 $a_{i+1}$ 之间的大小关系，答案会减 $1$。

将 $x$ 移到不等号的右边，会变成: 

$\left \{ \begin{aligned}
a_{i + 1} & \geq p - x \\
a_i & < p - x
\end{aligned} \right. \to \texttt{ans+=1}$ 和 $\left \{ \begin{aligned}
a_{i + 1} & < p - x \\
a_i & \geq p - x
\end{aligned} \right. \to \texttt{ans-=1}$

那么画一个示意图出来就会是以下这样的: 

![](https://cdn.luogu.com.cn/upload/image_hosting/br5yths5.png)

那么我们就把整个区域分成了上下两部分。

如果你图画的多的话，你会发现，你从一个点开始，先跳到另一个区域，最后又回到当前的区域，最终答案值一定是不变的。

推广一下，当第 $1$ 个点和第 $n$ 个点在同一个区域的话，最终的答案值是不变的。

因此我们只需要考虑在不同区域的情况。

对于第一个点在下面的区域，第 $n$ 个点在上面的区域的情况，一开始先跳到上面的区域，答案加了 $1$，然后就是起点和终点在同一个区域的情况，对答案没有贡献。

对于第一个点在上面的区域，第 $n$ 个点在下面的区域的情况，一开始先跳到下面的区域，答案减了 $1$，然后就是起点和终点在同一个区域的情况，对答案没有贡献。

那么就是考虑如何做掉这题了。

由于上述条件的要求是要在加的数都是一样的的情况下才能做，我们可以考虑使用分块，记录某一块加的数为 $x$，当前块在不加 $x$ 的情况下答案为 $\texttt{ans}$。

区间加的时候，对于散块的数，暴力枚举每一个在散块里的数，对这个数加上 $c$ 然后暴力更新这个数与左右两边的数对这个散块的 $\texttt{ans}$ 的贡献；对于整块的数，直接对这个整块的 $x$ 加上 $c$ 模上 $p$ 即可。

区间查询的时候，暴力查询散块里每两个数之间的贡献并加到本次的答案上去，然后先将每一个整块的 $\texttt{ans}$ 加到最终的答案上去，并根据上述做法修改当前块对答案的贡献，最后还要注意把所有相邻两个块连接处的情况的贡献加到本次的答案上去就做完了。

由于是 $\mathcal{O}(m\sqrt n)$ 算法，可能会出现 TLE 的情况，将 $\texttt{x+=y;x\%=p;}$ 的形式改为 $\texttt{x+=y;if (x>=p) x-=p;}$ 的形式即可，注意这样的话在输入的 $c$ 要先对 $p$ 取模。

如果没有理解的话可以参照代码理解。

```c++
#include<bits/stdc++.h>
#define int long long
using namespace std;
template<typename T> inline
void read(T& x) {
    T f=1,b=0; char ch=getchar();
    while (!isdigit(ch)) {
        if (ch=='-') f=-1;
        ch=getchar();
    } while (isdigit(ch))
        b*=10,b+=ch-'0',ch=getchar();
    x=f*b; return;
}
template<typename T> inline
void print(T x) {
    if (x<0) putchar('-'),x=-x;
    if (x==0) return putchar('0'),void();
    int st[51]={0},k=0;
    while (x) st[++k]=x%10,x/=10;
    for (int i=k;i;i--) putchar(st[i]+'0');
} const int MaxN=1e5+10;
const int SIZ=333;
int n,m,p,a[MaxN];
int bel[MaxN],add[MaxN],ans[MaxN];
// 暴力修改散块内的数
void addsignle(int wh,int c) {
    // 先将当前数和左右两边的数对答案的贡献减去
    if (bel[wh-1]==bel[wh]&&a[wh-1]>a[wh]) ans[bel[wh]]--;
    if (bel[wh+1]==bel[wh]&&a[wh]>a[wh+1]) ans[bel[wh]]--;、
    // 暴力修改a[wh]的值，对p取模
    a[wh]+=c; if (a[wh]>=p) a[wh]-=p;
    // 再将现在当前数和左右两边的数对答案的贡献加到散块上
    if (bel[wh-1]==bel[wh]&&a[wh-1]>a[wh]) ans[bel[wh]]++;
    if (bel[wh+1]==bel[wh]&&a[wh]>a[wh+1]) ans[bel[wh]]++;
}
// 整块加c，对p取模
void addblock(int wh,int c) {
    add[wh]+=c; if (add[wh]>=p) add[wh]-=p;
}
// 获取整块内当前的答案
int getblock(int wh) {
    int tmp=ans[wh];
    // 当前整块的范围
    int l=(wh-1)*SIZ+1,r=wh*SIZ;
    // l在下面的区域，r在上面的区域的情况
    if (a[l]<p-add[wh]&&a[r]>=p-add[wh]) tmp++;
    // l在上面的区域，r在下面的区域的情况
    if (a[l]>=p-add[wh]&&a[r]<p-add[wh]) tmp--;
    // 返回答案
    return tmp;
}
// 获取相邻两个块连接处的答案
int getblockbet(int wh1,int wh2) {
    // 暴力获取两个点的值，对p取模
    int x=a[wh1*SIZ]+add[wh1],y=a[(wh2-1)*SIZ+1]+add[wh2];
    if (x>=p) x-=p; if (y>=p) y-=p; 
    // 暴力判断是否会对答案产生贡献
    return x>y;
}
// 获取散块相邻两个点的答案
int getsignle(int wh1,int wh2) {
    // 暴力获取两个点的值，对p取模
    int x=a[wh1]+add[bel[wh1]],y=a[wh2]+add[bel[wh2]];
    if (x>=p) x-=p; if (y>=p) y-=p; 
    // 暴力判断是否会对答案产生贡献
    return x>y;
}
void update(int l,int r,int x) {
    if (bel[l]==bel[r]) {
        // l和r在同一个块的情况
        for (int i=l;i<=r;i++) addsignle(i,x);
        return;
    } // 散块
    for (int i=l;i<=bel[l]*SIZ;i++) addsignle(i,x);
    // 整块
    for (int i=bel[l]+1;i<bel[r];i++) addblock(i,x);
    // 散块
    for (int i=(bel[r]-1)*SIZ+1;i<=r;i++) addsignle(i,x);
}
int query(int l,int r) {
    int ans=0;
    if (bel[l]==bel[r]) {
        // l和r在同一个块的情况
        for (int i=l;i<r;i++) ans+=getsignle(i,i+1);
        return ans;
    } // 散块
    for (int i=l;i<bel[l]*SIZ;i++) ans+=getsignle(i,i+1);
    // 整块
    for (int i=bel[l]+1;i<bel[r];i++) ans+=getblock(i);
    // 整块连接处
    for (int i=bel[l];i<bel[r];i++) ans+=getblockbet(i,i+1);
    // 散块
    for (int i=(bel[r]-1)*SIZ+1;i<r;i++) ans+=getsignle(i,i+1);
    return ans;
}
signed main() {
    read(n),read(m),read(p);
    for (int i=1;i<=n;i++) read(a[i]);
    for (int i=1;i<=n;i++) bel[i]=(i-1)/SIZ+1;
    for (int i=1;i<n;i++) {
        if (bel[i]!=bel[i+1]) continue;
        // 先暴力计算某一个整块的答案
        if (a[i]>a[i+1]) ans[bel[i]]++;
    }
    for (int i=1;i<=m;i++) {
        int op,l,r,x; read(op),read(l),read(r);
        if (op==1) read(x),update(l,r,x%p);
        else print(query(l,r)),putchar('\n');
    }
}
```



---

## 作者：Kappa6174 (赞：5)

给个无脑线段树做法。

首先对于区间加显然可以用线段树维护。

合并区间首先需要两个子区间的答案加起来，因为合并区间时中间会有两个数相邻（左区间最右端的数和右区间最左端的数），因此我们还需要维护每个区间最左边和最右边的数，合并答案时只需要比较两个数大小关系决定区间答案是否 $+1$ 就行。

现在只剩下一个问题：如何在区间加时维护区间答案？

首先一个显然的结论：区间加 $x$ 和区间加 $x\bmod p$ 没有本质区别，因此可以限定 $x$ 的值域为 $[0,p-1]$。

考虑在区间加 $x$ 前后哪些大小关系会发生变化，易得只有在相邻两个数 $a,b (a\gt b)$ 中，$a+x\ge p$ 且 $b+x\lt p$ 时才会变化，此时修改过后的 $a'$ 一定小于 $b'$ 。

继续考虑该性质，可得出结论：区间加至多只会让区间答案变化 $1$。
![kjfkdsfds.png](https://s2.loli.net/2022/07/05/B943GTjs1SwEcZy.png)

如上图，此时红色部分区间加后 $\leq p$，蓝色部分区间加后 $\gt p$，红色部分和蓝色部分交界处会对答案有影响。由于红蓝部分是交替的，因此区间加之后对答案的贡献也是 $+1,-1,+1...$ 交替，结论成立。

因此我们只需要讨论区间答案的变化情况，容易发现这和区间两端的数在区间加后和 $p$ 的大小关系有关，而与中间的数无关。

做完了。

总时间复杂度 $O(n\log n)$。（假定 $n,m$ 同阶）





---

## 作者：wangyanjing (赞：2)

# Solution.

易得 $(a_i+c) \bmod p = ((a_i \bmod p) +(c\bmod p)) \bmod p$。
为了方便理解,以下的“$a_i$”和“$c$”都是经过模 $p$ 处理的。

为了方便表示，我们记 $(cnt_{now} - cnt_{last})$ 为 $\Delta cnt$。


我们来讨论以下 $4$ 种情况：  
设 $a_i + c = x$，$a_{i+1} + c = y$。
 - $1$. 当 $x\le p$，$y\le p$ 时，将 $x,y$ 分别模 $p$ 后，则 $\Delta cnt = 0$。
 -  $2$. 当 $x> p$，$y> p$ 时，将 $x,y$ 分别模 $p$ 后，则 $\Delta cnt = 0$。
 -  $3$. 当 $x < p$，$y \ge p$ 时，将 $x,y$ 分别模 $p$ 后，则 $\Delta cnt = 1$。
 -  $4$. 当 $x \ge p$，$y < p$ 时，将 $x,y$ 分别模 $p$ 后，则 $\Delta cnt = -1$。


~~情况一,二证明：过于简单,请读者自行证明。~~


情况三证明：

$$ \because x < p,y \ge p    \therefore x<y$$

$$ \because  a_i + c = x,a_{i+1} + c = y \ \therefore a_i < a_{i+1}$$

$$ \because a_{i+1} \le p-1 ,c\le p-1 \  \therefore a_{i+1} +c < 2p$$

$$\therefore a_{i+1} + c \equiv  a_{i+1}+c-p  (\bmod p)$$

$$\because a_i + c \equiv a_i+c(\bmod p) \\a_i + c > a_{i+1}+c-p$$

$$\therefore x >y (\bmod p)$$ 
$$\therefore \Delta cnt = 1$$

$a_i + c > a_{i+1}+c-p$ 的证明：  
两边同时减 $c$ 得 $a_i $ 与 $ a_{i+1} - p$。  
两边同时加 $p$ 得 $a_i + p $ 与 $ a_{i+1}$。  
因为$ a_i + p > a_{i+1}$。
故 $a_i + c > a_{i+1}+c-p$。   
证毕！

情况四证明：  
同情况三，读者可自行证明。

**为了同条件做区分，我们定义：**  
若有两数满足情况一，则这两个数为“一数对”。  
若有两数满足情况二，则这两个数为“二数对”。  
若有两数满足情况三，则这两个数为“三数对”。  
若有两数满足情况四，则这两个数为“四数对”。

*****

现在我们讨论区间 $[l,r]$ 的 $4$ 种情况。  
设 $a_l + c = d$，$a_r + c = e$。
  - $1$. 当 $d\le p$，$e\le p$ 时，将区间 $[l,r]$ 内所有元素均模 $p$ 后，则 $\Delta cnt = 0$。
 -  $2$. 当 $d> p$，$e> p$ 时，将区间 $[l,r]$ 内所有元素均模 $p$ 后，则 $\Delta cnt = 0$。
 -  $3$. 当 $d < p$，$e \ge p$ 时，将区间 $[l,r]$ 内所有元素均模 $p$ 后，则 $\Delta cnt = 1$。
 -  $4$. 当 $d \ge p$，$e < p$ 时，将区间 $[l,r]$ 内所有元素均模 $p$ 后，则 $\Delta cnt = -1$。


证明：


将区间 $[l,r]$ 中的所有元素加 $c$ 后应出现 $k$ 个段内所有元素不小于 $p$ 的连续段。  
**此后出现的所有 $a$ 中的元素均为经过加 $c$ 但不模 $p$ 处理的。**  
 _设一个超过 $p$ 的连续段的左端点为 $LL$，右端点为 $RR$。_   
**请注意 $l$ 与 $LL$ 和 $r$ 与 $RR$ 的区分！**  
将第一个连续段与第 $k$ 个连续段除去，剩下的连续段满足：
$$a_{LL-1} <p  \\ a_{RR+1} <p$$

$\therefore (a_{LL-1}$,$a_{LL}) $ 为“三数对”, 区间  $[LL,RR]$ 共形成 $(RR-LL)$ 个“二数对”,$(a_{RR},a_{RR+1})$ 为“四数对”。  
$\therefore$ 对 $cnt$ 的总贡献为 $0$。  
我们称以上这样的连续段即满足以下要求的连续段为“普通连续段”：
- $a_{LL-1} <p $。
- $a_{RR+1} <p$。
- $[LL$,$RR]$ 内所有元素均不小于 $p$。

现在我们来讨论第一个连续段的贡献与 $a_l$ 的关系。
- 若 $a_l < p$,，第一个连续段为“普通连续段”，对 $cnt$ 的贡献为 $0$．
- 若 $a_l \ge p$：
 
  $a_l$ 为第一个连续段的第一个元素，即 $LL = l$。  
  $\therefore$ 区间 $[l,RR]$ 共形成 $(RR-l)$ 个“二数对”，$(a_{RR}$,$a_{RR+1})$ 为“四数对”。  
  $\therefore$ 对 $cnt$ 的总贡献为 $-1$。
  
我们来讨论第 $k$ 个连续段的贡献与 $a_r$ 的关系。

- 若 $a_r < p $：第 $k$ 个连续段为“普通连续段”，对 $cnt$ 的贡献为 $0$。
- 若 $a_r \ge p$：
 
  $a_r$ 为第 $k$ 个连续段的最后一个元素，即 $ RR = r$．  
  $\therefore (a_{LL-1},a_{LL}) $ 为“四数对”,区间 $[LL,r]$ 共形成 $(r-LL)$ 个“二数对”。  
  $\therefore$ 对 $cnt$ 的总贡献为 $1$。

最后的总结工作十分简单，可由读者自行完成。

---

有了以上的数学推论后，我们就可以写代码啦！  
我们可以使用**线段树**，维护区间左右端点的值，就可以轻松解决此问题。

代码由于个人码风问题，不予展出，读者可参考其他的题解，理解万岁！

完结撒花！

---

## 作者：mqmhaaaa1 (赞：1)

根据观察题目，我们不难发现事实上对一个区间与其他区间有贡献的点只有每个区间两边的点，所以我们可以用线段树直接维护区间的最左边和最右边，再在合并区间是计算每个区间的答案，这样就可以愉快的 WA 了。

事实上本题目最大毒瘤在于取模，因为取模后可能会大变小，小变大，无法通过上述方法在 $\log$ 内维护。

接着观察题目，我们发现如果有两个数 $a_i$，$a_j$
满足 $a_i>a_j$ 且 $j>i$。

假设经过一次区间加法后 $a_i+c \ge p$ 且 $a_j+c<p$，那么这时所有包含这一对的区间答案都减一，反之亦然。

分析所有情况，我们发现可以把每一段分成递增、递减、一大一小交叉这三种情况。

在递增的情况下，一开始答案为 $0$。经过加法后：如果最后的数大于 $p$，那必定会给答案贡献 $1$。如果第一个数也大于 $p$，说明所有的数都被取模过，则将最后的数贡献的答案 $-1$。

在递减的情况下，一开始答案为 $len-1$。经过加法后：如果第一个的数大于 $p$，那么会使答案减少一对。如果最后的数也大于 $p$，那么说明所有的数都被取过模，则将第一个数产生的 $-1$ 抵消掉（相当于 $+1$）。

在交叉排列的情况下，一开始答案为 $\lfloor \frac{len}{2} \rfloor$。经过加法后：如果第一个数较大，且现在第一个数大于 $p$，则答案会减少一对；如果最后的数较大，且最后的数大于 $p$，则答案会增加一对。如果第一个数较小，且第一个数大于 $p$，则这一对不变，但因为后一位变小，所以会使答案 $-1$；如果最后的数较小且最后的数大于 $p$，则这一对不变，但因为前一位变小，所以会使答案 $+1$。

总结规律发现，当 $al\ge p$ 时，$ans-1$。

当 $ar\ge p$ 时，$ans+1$。

所以我们在之前代码的基础上在 pushdown 和 modify 里加上特判就行了。

详见代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ls(x) (x*2)
#define rs(x) (x*2+1)
const ll N=2e5+10;
inline int read(){char c=getchar();int a=0,b=1;while(c<'0'||c>'9')b=(c=='-'?-1:b),c=getchar();while(c>='0'&&c<='9')a=a*10+(c^48),c=getchar();return a*b;}inline void write(int x){if(x<0)putchar('-'),x=-x;if(x>9)write(x/10);putchar(x%10+'0');}
ll a[N],n,p,m;
struct mqm{
	ll val,al,ar;//val 答案 al 最左边的数 ar 最右边的数
};
struct xds{
	mqm tr[N<<2];
	ll lt[N<<2];
	mqm marge(mqm sl,mqm sr){// 合并区间
		mqm res;res.val=sl.val+sr.val;
		res.al=sl.al%p;
		res.ar=sr.ar%p;
		if(sl.ar>sr.al)res.val++;
		return res;
	}
	void hard(ll u,ll c){//加法特判
		tr[u].al+=c;tr[u].ar+=c;lt[u]=(lt[u]+c)%p;
		if(tr[u].al>=p){
			tr[u].val--;tr[u].al-=p;
		}
		if(tr[u].ar>=p){
			tr[u].val++;tr[u].ar-=p;
		}
	}
	void pushdown(ll u,ll l,ll r){//下传相当于两个hard
		hard(ls(u),lt[u]);hard(rs(u),lt[u]);
		lt[u]=0;
	}
	void build(ll u,ll l,ll r){//建树
		lt[u]=0;
		if(l==r){
			tr[u].val=0;
			tr[u].al=tr[u].ar=a[l];
			return;
		}
		ll mid=(l+r)/2;
		build(ls(u),l,mid);build(rs(u),mid+1,r);
		tr[u]=marge(tr[ls(u)],tr[rs(u)]);//合并左儿子 右儿子
	}
	void xg(ll u,ll l,ll r,ll ql,ll qr,ll val){
		if(ql<=l&&r<=qr){
			hard(u,val);//加
			return;
		}
		pushdown(u,l,r);
		ll mid=(l+r)/2;
		if(ql<=mid)xg(ls(u),l,mid,ql,qr,val);
		if(qr>mid)xg(rs(u),mid+1,r,ql,qr,val);
		tr[u]=marge(tr[ls(u)],tr[rs(u)]);
	}
	mqm find(ll u,ll l,ll r,ll ql,ll qr){
		if(ql<=l&&r<=qr){
			return tr[u];
		}
		pushdown(u,l,r);
		ll mid=(l+r)/2;
		if(qr<=mid)return find(ls(u),l,mid,ql,qr);
		if(ql>mid)return find(rs(u),mid+1,r,ql,qr);
		return marge(find(ls(u),l,mid,ql,qr),find(rs(u),mid+1,r,ql,qr));//由于线段树遍历是按dfs序，所以find左边右边的两个区间一定相连
	}
}jb;
int main(){
	n=read();m=read();p=read();
	for(ll i=1;i<=n;i++){
		ll sss=read();a[i]=sss;a[i]%=p;//记得模
	}
	jb.build(1,1,n);
	while(m--){
		ll zt=read();
		if(zt==1){
			ll l=read(),r=read(),val=read();val%=p;//记得模
			jb.xg(1,1,n,l,r,val);
		}else{
			ll l=read(),r=read();
			mqm ans=jb.find(1,1,n,l,r);
			write(ans.val);putchar('\n');
		}
	}
} 
```

---

## 作者：Danny_chan (赞：0)

这题的第一个操作直接用树状数组加差分就行了。

关于第二个操作我们要把差分数组推回原数串需要用前缀和取模，但是取模可能出现“溢出”的现象。

我们发现当“溢出”时前缀和就会少 $p$ 所以我们维护一下差分数组的前缀和取模相减就可以了。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,p;
int c[100010],a[100010];
void add(int x,int y){
	for(a[x]=(a[x]+y)%p;x<=n;x+=x&(-x)){//差分数组取模 
		c[x]+=y;
	}
}
int summ(int x){ 
	int sum=0;
	for(;x>0;x-=x&(-x)){
		sum+=c[x];
	}
	return sum;
}
signed main(){
	cin>>n>>m>>p;
	int la=0;
	for(int i=1;i<=n;i++){//差分构造 
		int x;
		cin>>x;
		add(i,(x-la+p)%p);
		la=x;
	}
	while(m--){
		int op;
		int l,r;
		cin>>op>>l>>r;
		if(op==1){
			int x;
			cin>>x;
			x%=p;
			if(a[l]+x>=p)add(l,x-p);//判断是否溢出 
			else add(l,x);
			if(a[r+1]>=x) add(r+1,-x);
			else add(r+1,p-x);
		}
		if(op==2){
			cout<<summ(r)/p-summ(l)/p<<endl; 
		}
	}
	return 0;
} 
```

---


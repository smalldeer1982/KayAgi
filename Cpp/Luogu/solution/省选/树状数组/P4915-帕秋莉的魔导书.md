# 帕秋莉的魔导书

## 题目背景

帕秋莉有一个巨大的图书馆，里面有数以万计的书，其中大部分为魔导书。

## 题目描述

魔导书是一种需要钥匙才能看得懂的书，然而只有和书写者同等或更高熟练度的人才能看得见钥匙。因此，每本魔导书都有它自己的等级 $a_i$，同时它也有自己的知识程度为 $w_i$，现在我们想要知道，一个等级为 $b_i$ 的生物(...)，可以从这些魔导书中得到多少知识。

然而不幸的是，每个生物并不知道自己确切的等级，只有一个等级的大致范围，你需要计算出这个生物获得知识程度的期望值。


## 说明/提示

对于 $30\%$ 的数据，保证 $1\le $ 所有输入的数字 $\le 10^3$。

对于 $100\%$ 的数据，保证 $1\le n,m\le 10^5$，对于其他数字，保证在 $32$ 位带符号整数范围内（保证运算中所有的数均在 $-2^{63}\sim 2^{63}-1$ 内）。

## 样例 #1

### 输入

```
5 5
1 1
2 1
3 1
4 1
5 1
1 2 5
1 1 5
1 3 5
2 1 5
1 1 2```

### 输出

```
3.5000
3.0000
4.0000
6.5000
```

# 题解

## 作者：partychicken (赞：7)

QAQ，不知道为啥写挂了，写篇题解理一下思路

## 先%同机房出题大佬，DSM tql

思路和他并不一样，QAQ。~~（这或许就是我wa的原因？？？）~~

以等级为下标，显然，只需要维护前缀和的区间和。

- 修改：单点加，放到前缀和里就是区间加（从当前位置加到末尾即可）
- 查询：对前缀和区间求和，然后除以区间长度

显然，用一个线段树维护前缀和数组就ok了。

由于等级范围很大，所以可以考虑离散化。然而蒟蒻不喜欢离线，所以写了动态开点。

代码。。。等我a了再说吧

upd:2018/10/9
```
#include<bits/stdc++.h>

using namespace std;

typedef long long ll;

struct SEG
{
    struct Node
    { 
        ll sum,add;
        int ls,rs;
        Node():sum(0),add(0),ls(0),rs(0){}
    }nd[2000010<<2];
    int cnt;
    SEG():cnt(1){}
    void pushdown(int x,int len)
    {
        if(nd[x].add)
        {
            int ls=(nd[x].ls?nd[x].ls:nd[x].ls=++cnt),rs=(nd[x].rs?nd[x].rs:nd[x].rs=++cnt);
            nd[ls].add+=nd[x].add,nd[ls].sum+=nd[x].add*(len-(len>>1));
            nd[rs].add+=nd[x].add,nd[rs].sum+=nd[x].add*(len>>1);
            nd[x].add=0;
        }
    }
    void update(int x)
    {
        nd[x].sum=nd[nd[x].ls].sum+nd[nd[x].rs].sum;
    }
    int modify(int x,int nl,int nr,int ql,int qr,ll val)
    {
        if(nl>qr||nr<ql) return 0;
        if(nl>=ql&&nr<=qr)
        {
            nd[x].add+=val,nd[x].sum+=val*(nr-nl+1);
            return 0;
        }
        pushdown(x,nr-nl+1);
        int mid=(long long)nl+nr>>1;
        !nd[x].ls?nd[x].ls=++cnt:0;modify(nd[x].ls,nl,mid,ql,qr,val);
        !nd[x].rs?nd[x].rs=++cnt:0;modify(nd[x].rs,mid+1,nr,ql,qr,val);
        update(x);
        return 0;
    }
    ll query(int x,int nl,int nr,int ql,int qr)
    {
        if(nl>qr||nr<ql) return 0;
        if(nl>=ql&&nr<=qr) return nd[x].sum;
        pushdown(x,nr-nl+1);
        int mid=(long long)nl+nr>>1;
        return (nd[x].ls?query(nd[x].ls,nl,mid,ql,qr):0)+(nd[x].rs?query(nd[x].rs,mid+1,nr,ql,qr):0);
    }
}seg;

const int inf=2147483646; 

int main()
{
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        int v,w;
        cin>>v>>w;
        seg.modify(1,1,inf,v,inf,w);
    }
    for(int i=1;i<=m;i++)
    {
        int opt,v,w;
        cin>>opt>>v>>w;
        opt==1?(printf("%.4lf\n",(double)seg.query(1,1,inf,v,w)/(double)(w-v+1)),0):(seg.modify(1,1,inf,v,inf,w),0);
    }
}
```

---

## 作者：VanHelsing (赞：4)

先挂个[题目链接](https://www.luogu.com.cn/problem/P4915)  

先%%%出题人，也是我几年前的学长。

思路不是很好想，不过既然每个生物都有一个范围，那期望不就是这区间的和除以区间长度吗！同时我们也要考虑到，这个区间和里的每个点的值是原数组的前缀和，所以我们需要依据前缀和建立线段树。

但是呢但是呢，用前缀和建树就会导致我原本的单点修改在这里就会变成区间修改，那该怎么办呢？答案是:不怎么办！那就把线段树的单点修改改成区间修改就好了，反正都不是很难写（

但是由于值域比较大，所以权值线段树需要动态开点或者离散化才能搞。  
不过由于我不太会离散化再加上出题人的思路就是动态开点，所以我就仿照他的方式写了个动态开点线段树

$Code\ Time:$

```cpp
#include<bits/stdc++.h>

using namespace std;

const long long inf=INT_MAX;

const int maxn=2e6+3;

struct SegmenTree{

    long long ch[2];

	long long val,sum;

};SegmenTree tree[maxn<<2];

long long root=1,cnt=1;

void update(long long index)
{
    tree[index].val=tree[tree[index].ch[0]].val+tree[tree[index].ch[1]].val;

    tree[index].sum=tree[tree[index].ch[0]].sum+tree[tree[index].ch[1]].sum;
}

void Modify(long long index,long long l,long long r,long long pos,long long val)
{
    if(l==r)
    {
        tree[index].val+=val;

        tree[index].sum+=(long long)val*(INT_MAX-pos+1);
    }
    else
    {
        long long mid=(l+r)>>1;

        if(pos<=mid)
        {
            if(!tree[index].ch[0])
            {
                tree[index].ch[0]=++cnt;
            }

            Modify(tree[index].ch[0],l,mid,pos,val);
        }
        else
        {
            if(!tree[index].ch[1])
            {
                tree[index].ch[1]=++cnt;
            }

            Modify(tree[index].ch[1],mid+1,r,pos,val);
        }

        update(index);
    }
}

long long Query(long long index,long long l,long long r,long long pos)
{
    if(r<=pos)
    {
        return tree[index].sum-tree[index].val*(INT_MAX-pos);
    }
    else
    {
		long long mid=l+r>>1;

		long long ret=Query(tree[index].ch[0],l,mid,pos);

		if(mid<pos)
		{
			ret+=Query(tree[index].ch[1],mid+1,r,pos);
		}

		return ret;
    }
}

signed main()
{
	long long n,m,x,y;

	scanf("%lld%lld",&n,&m);

	while(n--)
	{
		scanf("%lld%lld",&x,&y);

		Modify(1,0,inf,x,y);
	}
	while(m--)
    {
    	long long opt;

    	scanf("%lld",&opt);

        if(opt==1)
        {
			scanf("%lld%lld",&x,&y);

			double res=((long double)Query(1,0,inf,y)-Query(1,0,inf,x-1))/(y-x+1);

			printf("%.4lf\n",res);
        }

        else
        {
			scanf("%lld%lld",&x,&y);

			Modify(1,0,inf,x,y);
        }
    }
}
```

---

## 作者：SuperJvRuo (赞：3)

此题的弱化版：[P4868 Preprefix sum](https://www.luogu.org/problemnew/show/P4868)

~~暑假的时候出题人请我验了这个idea，然后我随口就口胡了正解。~~

简化一下题意：

1. 求$$\frac{\sum_{i=l}^r\sum_{j=1}^iw_i}{r-l+1}$$
2. 单点修改$w_i$。

操作1就是求$\frac{(\sum_{i=1}^r\sum_{j=1}^iw_i)-(\sum_{i=1}^{l-1}\sum_{j=1}^iw_i)}{r-l+1}$，也就是两次查询前缀的前缀和，这样就转化为了上面的原题。

而对于求原题中的$SS_i=\sum^i_{j=1}\sum^j_{k=1}a_k$，展开$SS_i$，发现$SS_i=\sum^i_{j=1}(i-j+1)\times a_j$。

原题可以维护两个树状数组，一个维护$a_i$，另一个维护$b_i=(n-i+1)\times a_i$。这样，我们要查询的$SS_i$即为$\sum^i_{j=1}[(n-j+1)-(n-i)]\times a_j=\sum^i_{j=1}b_j-(n-i)\times\sum^i_{j=1}a_j$。

当然，此题值域较大，需要用动态开点线段树代替树状数组。

```
#include<cstdio>
#include<cctype>
#include<climits>
#define LL long long

int Read()
{
    int x=0;char c=getchar();
    while(!isdigit(c))
    {
        c=getchar();
    }
    while(isdigit(c))
    {
        x=x*10+(c^48);
        c=getchar();
    }
    return x;
}

struct Node
{
    int ch[2];
    LL val,presum;
}tree[2000005];

int root=1,cnt=1;

void Update(int idx)
{
    tree[idx].val=tree[tree[idx].ch[0]].val+tree[tree[idx].ch[1]].val;
    tree[idx].presum=tree[tree[idx].ch[0]].presum+tree[tree[idx].ch[1]].presum;
}

void Add(int pos,int val,int l=0,int r=INT_MAX,int idx=1)
{
    if(l==r)
    {
        tree[idx].val+=val;
        tree[idx].presum+=(LL)val*(INT_MAX-pos+1);
    }
    else
    {
        int mid=l+r>>1;
        if(pos<=mid)
        {
            if(!tree[idx].ch[0])//这就是动态开点
            {
                tree[idx].ch[0]=++cnt;
            }
            Add(pos,val,l,mid,tree[idx].ch[0]);
        }
        else
        {
            if(!tree[idx].ch[1])
            {
                tree[idx].ch[1]=++cnt;
            }
            Add(pos,val,mid+1,r,tree[idx].ch[1]);
        }
        Update(idx);
    }
}

LL Query(int pos,int l=0,int r=INT_MAX,int idx=1)
{
    if(r<=pos)
    {
        return tree[idx].presum-tree[idx].val*(INT_MAX-pos);
    }
    else
    {
        int mid=l+r>>1;
        LL res=Query(pos,l,mid,tree[idx].ch[0]);
        if(mid<pos)
        {
            res+=Query(pos,mid+1,r,tree[idx].ch[1]);
        }
        return res;
    }
}

int main()
{
    int n=Read(),m=Read(),a,w;
    while(n--)
    {
        a=Read(),w=Read();
        Add(a,w);
    }
    while(m--)
    {
        if(Read()==1)
        {
            a=Read(),w=Read();
            double res=((long double)Query(w)-Query(a-1))/(w-a+1);
            printf("%.4lf\n",res);
        }
        else
        {
            a=Read(),w=Read();
            Add(a,w);
        }
    }
    return 0;
}
```

---

## 作者：LCuter (赞：2)

## 题解 P4915
先不考虑操作2

假设有一个序列${W_i}$，其中$1 \le i \le 2147483647$，$W_i = $等级为$i$的书本的$w_i$之和。那么，等级为$b_i$的生物可以获得的知识就是$\Sigma^{b_i}_{i=1}W_i$。而等级在$[x,y]$区间内的生物获得的知识期望为$\frac{\Sigma^{y}_{i=x}\Sigma^{i}_{j=1}W_i}{y-x+1}$(由于在$[x,y]$区间内取任意一整数的概率都是相等的，故此期望可以近似认为是平均数)

我们发现，这里的每个操作都是在前缀和基础上进行的，所以设$S_i=\Sigma^{i}_{j=1}W_i$，上面的式子可以化为$\frac{\Sigma^y_{i=x}S_i}{y-x+1}$，这个式子的分子可以用线段树维护，即区间和。

接着考虑操作2

操作2可以看作是使得$W_x=W_x+y$。因为我们的线段树维护的是$W_i$的前缀和，所以我们要想办法把它转换为前缀和上的操作。观察到$W_i$的改动只会影响到$S_j(i\le j)$，且当$W_i+y$时，$S_j+y(i\le j)$，所以这个操作可以看作是线段树维护的前缀和的区间加

但是这个线段树要维护区间$[1,2147483647]$，按照传统的线段树来做空间肯定不够，所以需要离散化。至于怎么离散化我就不说了。

那如果这道题要求在线呢?那就要使用动态开点线段树了。所谓动态开点线段树，就是说暂时没用到的点，我们就不开(类似lazy tag?)，很显然，这样的话不能直接建树，所以要一个点一个点的加。这样的空间复杂度大概是$O(m log n)$的。具体操作可以看我的代码(这个代码部分地方是参考别人的，毕竟动态开点线段树我也是刚学的)。

```cpp
#include<cstdio>
#define LL long long
#define MAXN 2000005
#define INF 2147483647
using namespace std;
int n,m;
struct Segment_Tree{
    #define mid ((LL)l+r>>1)
    int cnt=1;
    LL val[MAXN<<2],Ptag[MAXN<<2];
    int Lson[MAXN<<2],Rson[MAXN<<2];
    void pushdown(int now,int l,int r){
        if(Ptag[now]){
            int Ls=(Lson[now]?Lson[now]:Lson[now]=++cnt),Rs=(Rson[now]?Rson[now]:Rson[now]=++cnt);
            Ptag[Ls]=Ptag[Ls]+Ptag[now];
            Ptag[Rs]=Ptag[Rs]+Ptag[now];
            val[Ls]=val[Ls]+Ptag[now]*(mid-l+1);
            val[Rs]=val[Rs]+Ptag[now]*(r-mid);
            Ptag[now]=0;
        }
    }
    void Pupd(int now,int x,int y,int l,int r,LL k){
        if(l>y||r<x) return;
        if(l>=x&&r<=y){
            Ptag[now]+=k;
            val[now]+=k*(r-l+1);
            return;
        }
        pushdown(now,l,r);
        !Lson[now]?Lson[now]=++cnt:0;
        Pupd(Lson[now],x,y,l,mid,k);
        !Rson[now]?Rson[now]=++cnt:0;
        Pupd(Rson[now],x,y,mid+1,r,k);
        val[now]=val[Lson[now]]+val[Rson[now]];
    }
    LL Qsum(int now,int x,int y,int l,int r){
        if(l>y||r<x) return 0;
        if(l>=x&&r<=y) return val[now];
        pushdown(now,l,r);
        return (Lson[now]?Qsum(Lson[now],x,y,l,mid):0)+(Rson[now]?Qsum(Rson[now],x,y,mid+1,r):0);
    }
    #undef mid
}Tree;
int main(){
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;++i){
        int a,w;
        scanf("%d %d",&a,&w);
        Tree.Pupd(1,a,INF,1,INF,w);
    }
    for(int i=1;i<=m;++i){
        int opt;
        LL x,y;
        scanf("%d %lld %lld",&opt,&x,&y);
        if(opt==1) printf("%.4lf\n",(double)Tree.Qsum(1,x,y,1,INF)/(y-x+1));
        else Tree.Pupd(1,x,INF,1,INF,y);
    }
}
```


---

## 作者：chengni (赞：2)

首先不要被这道题吓到，这道实际上就是在求

$$ans=\frac{\sum_{i=l}^rs[i]}{r-l+1}$$ （$s[$ $]$数组是前缀和）

似乎转化成了求前缀和的前缀和，但是我不会

然后我们稍微改一下式子

我们发现 $a_1,a_2,...,a_x$ 都是被计算了 $r-l+1$ 次的

而 $a_{x+1},a_{x+2},...,a_y$，被计算的次数是依次递减一的

我们怎么才能 $O(1)$ 求出想要的和呢？

按照出题人大佬 @龙之吻—水货 的思路，我们分别记录 $a_i$ 和 $a_i*(maxn-i+1)$的值，然后结算的时候用后者减去前者乘 $(maxn-r)$ 就可以了

简单来说就会变成这样

$a_i*(maxn-i+1)-a_i*(maxn-r)=a_i*(r-i+1)$

出题人是用动态开点线段树做的，我跟出题人大佬请教了一下觉得树状数组加离散化也可以做，但是我这个菜鸡写挂了，只好现学动态开点。

大致思想如下

首先，结点的标号很大(max int)，我们用正常线段树和树状数组做肯定存不下去，所以离散化是一种方法，而动态开点也可以节省空间防止挂掉。

简单来说就是对于一棵线段树，我们不建树，然后在向里面插入数的时候现把需要的结点建出来，因为 $n,m$ 不是特别大，这个空间复杂度是可以接受的，需要注意的就是结点的标号以及左右儿子的记录。

其实只要理解线段树了就不难了。

然后我们用这棵线段树维护 $a[i]$ 和 $a[i]*(maxn-i+1)$就可以了。

因为动态开点是现学的，可能比较丑

```cpp
#include<bits/stdc++.h>

using namespace std;

typedef long long ll;

inline int read(){
	char ch=getchar();int x=0,f=1;
    while(ch<'0' || ch>'9') {
       if(ch=='-') f=-1;
	  	  ch=getchar();
	}
    while(ch<='9' && ch>='0') {
	   x=x*10+ch-'0';
	   ch=getchar();
	}
    return x*f;
}

ll k=(1ll<<31)-1;//理论上最大值

int ls[2200202],rs[202002];

ll s[200202],sum[202020];

int cnt=0;

int root;

void build(int &p,int l,int r,int x,int y){//动态开点
	if(p==0) p=++cnt;//如果这个点没有建过，打一个标记
	if(l==r){
		s[p]+=y;
		sum[p]+=(k-x+1)*y;
		return;
	}
	int mid=l+r>>1;
	if(x<=mid){
		build(ls[p],l,mid,x,y);
	}
	if(x>mid){
		build(rs[p],mid+1,r,x,y);
	}
	s[p]=0;//维护
	if(ls[p]!=0) s[p]+=s[ls[p]];
	if(rs[p]!=0) s[p]+=s[rs[p]];
	sum[p]=0;//维护
	if(ls[p]!=0) sum[p]+=sum[ls[p]];
	if(rs[p]!=0) sum[p]+=sum[rs[p]];
}

int asks(int p,int l,int r,int x,int y){//其实跟线段树差不多
	if(p==0) return 0;
	if(x<=l && y>=r){
		return s[p];
	}
	int mid=l+r>>1;
	int ans=0;
	if(x<=mid) ans+=asks(ls[p],l,mid,x,y);
	if(y>mid) ans+=asks(rs[p],mid+1,r,x,y);
	return ans; 
}

ll asksum(int p,int l,int r,int x,int y){
	if(p==0) return 0;
	if(x<=l && y>=r){
		return sum[p];
	}
	int mid=l+r>>1;
	ll ans=0;
	if(x<=mid) ans+=asksum(ls[p],l,mid,x,y);
	if(y>mid) ans+=asksum(rs[p],mid+1,r,x,y);
	return ans; 
}


int main(){
	int n=read(),m=read();
	for(int i=1;i<=n;i++){
		int x=read(),y=read();
		build(root,1,k,x,y);
	}
	for(int i=1;i<=m;i++){
		int q=read(),x=read(),y=read();
		if(q==1){
			ll ans=asks(root,1,k,1,x);
			if(x==y){
				printf("%.4lf\n",ans);
				continue;
			}
			ll sum=asksum(root,1,k,x+1,y)-asks(root,1,k,x+1,y)*(k-y);
			printf("%.4lf\n",(double)ans+(double)sum/(double)(y-x+1));
		}
		else {
			build(root,1,k,x,y);
		}
	}
	return 0;
}

```







































---

## 作者：XiaoZi_qwq (赞：0)

# P4915 【帕秋莉的魔导书】
## 前言  
貌似大家都遗弃了离散化做法

## 题意分析  
给你 $n$ 个物品物品，等级为 $x$ 的生物可以获得等级小于等于 $x$ 的所有物品的权值，有 $m$ 次修改和询问，每个询问形如求“$[x,y]$ 的生物能获得的期望知识程度。” 

对于每一个询问，实际上就是在求：$$ans=\dfrac{\sum_{i=l}^{r} d[i]}{r-l+1}$$  
其中 $d_i$ 表示前缀和。  
同时 $n,m\le10^5$ 暗示我们此题需要往时间复杂度为   $O(n\log n)$ 或 $O(n \sqrt n)$ 的算法思考。

## 算法分析  
### 明确方向
那么现在我们需要处理的就是一个 **"单点修改，区间查询，维护前缀和"** 问题。  
我们需要一种数据结构，可以快速进行区间修改、区间查询，时间复杂度为 $O(n\log n)$ 或 $O(n \sqrt n)$ 。那么可以使用线段树。  
(tips：下文中 $mx$ 表示 $a_i$ (等级)的最大值。)

对于操作二: 将区间 $[x,mx]$ 加上 $y$ 。
对于操作一: 直接询问区间 $[l,r]$ 的区间和就行了。
### 优化
如果你直接打一个线段树板子，一交，30pts。   
再看数据范围 : $a_i$ 值域 $[-2^{31},2^{31}-1]$   。

所以要**离散化**。  

但有一个问题：线段树上一个节点的两个儿子可能长这样：  
![线段树上](https://cdn.luogu.com.cn/upload/image_hosting/yrdgswxv.png)

但是，在实际区间里，可能长这样：  
![实际上](https://cdn.luogu.com.cn/upload/image_hosting/ml3e7s99.png)

所以不能只是单单计算儿子在树上维护的区间大小，要考虑儿子维护的实际区间大小。

但是仍有一个问题：关注两个儿子之间的那个空隙，一般来说这个空隙是没有点的，可以忽略；但是现在我们离散化后，这里可能有很多点，怎么去计算这些点的贡献呢？  

回顾我们离散化的过程，我们只将**点值变化的位置**和询问区间的两端进行离散化，所以两个叶子节点之间的点，它们的值和左边那个点的点值一定相同。  
所以我们只需要维护每个节点最左端的值，再乘上实际区间里这个空隙的长度，就可以正确地维护每一个节点的值了。  

细节很多，具体看代码（**线段树中涉及区间长度的计算记得加离散化数组!!!**）  

```cpp
#include<bits/stdc++.h>
#define ls (i<<1)
#define rs ((i<<1)|1)
using namespace std;
typedef long long ll;
inline int read(){
  register int x=0;
  char c=getchar();
  while(c<'0' || '9'<c) c=getchar();
  while('0'<=c && c<='9') x=(x<<1)+(x<<3)+c-'0',c=getchar();
  return x;
}
const int N=4e5;
int n,m,cnt,tot1,tot2,c[N];//c数组即离散化数组
ll d[N];//值域很大，勿忘longlong
struct Node{
  int val,id,lvl;
}a[N],b[N];
struct Query{
  int id,l,r;
}q[N];
struct Tree{
  int l,r;
  ll tag,val,l_val;
}t[N<<2];
void push_up(int i){
  t[i].l_val=t[rs].l_val;//维护最左端点的值
  t[i].val=t[ls].val+t[rs].val+t[ls].l_val*(c[t[rs].l]-c[t[ls].r]-1);//维护两个儿子之间的空隙的点的贡献
}
void push_down(int i){
  if(t[i].tag){
    t[ls].val+=t[i].tag*(c[t[ls].r]-c[t[ls].l]+1);
    t[rs].val+=t[i].tag*(c[t[rs].r]-c[t[rs].l]+1);
    t[ls].l_val+=t[i].tag;
    t[rs].l_val+=t[i].tag;
    t[ls].tag+=t[i].tag;
    t[rs].tag+=t[i].tag;
    t[i].tag=0;
  }
}
void build(int i,int l,int r){
  t[i].l=l,t[i].r=r;
  if(l==r){
    t[i].val=t[i].l_val=d[l];
    return;
  }
  int mid=(l+r)>>1;
  build(ls,l,mid);
  build(rs,mid+1,r);
  push_up(i);
}
void update(int i,int l,int r,ll k){
  if(l<=t[i].l && t[i].r<=r){
    t[i].tag+=k;
    t[i].val+=(c[t[i].r]-c[t[i].l]+1)*k;
    t[i].l_val+=k;
    return;
  }
  push_down(i);
  int mid=(t[i].l+t[i].r)>>1;
  if(l<=mid) update(ls,l,r,k);
  if(mid<r) update(rs,l,r,k);
  push_up(i);
}
ll query(int i,int l,int r){
  if(l<=t[i].l && t[i].r<=r)
    return t[i].val;
  push_down(i);
  int mid=(t[i].l+t[i].r)>>1;
  if(l>mid) return query(rs,l,r);
  if(mid>=r) return query(ls,l,r);
  ll v1=query(ls,l,r),v2=query(rs,l,r);
  return v1+v2+t[ls].l_val*(c[t[rs].l]-c[t[ls].r]-1);
}
int main()
{
  n=read(),m=read();
  for(int i=1;i<=n;i++) c[++cnt]=a[i].lvl=read(),a[i].val=read();
  for(int i=1,opt;i<=m;i++){//询问离线 同时，询问的两个端点、新加入的点也要离散化！
    opt=read();
    if(opt==1)
      c[++cnt]=q[++tot1].l=read(),c[++cnt]=q[tot1].r=read(),q[tot1].id=i;
    else
      c[++cnt]=b[++tot2].lvl=read(),b[tot2].val=read(),b[tot2].id=i;
  }

  sort(c+1,c+cnt+1,less<ll>());
  int len=unique(c+1,c+cnt+1)-c-1;
  for(int i=1;i<=n;i++) a[i].lvl=lower_bound(c+1,c+len+1,a[i].lvl)-c;
  for(int i=1;i<=tot1;i++) q[i].l=lower_bound(c+1,c+len+1,q[i].l)-c,q[i].r=lower_bound(c+1,c+len+1,q[i].r)-c;
  for(int i=1;i<=tot2;i++) b[i].lvl=lower_bound(c+1,c+len+1,b[i].lvl)-c;

  for(int i=1;i<=n;i++) d[a[i].lvl]+=a[i].val;
  for(int i=1;i<=len;i++) d[i]+=d[i-1];
  build(1,1,len);

  q[tot1+1].id=0x3f3f3f3f;
  b[tot2+1].id=0x3f3f3f3f;
  for(int i=1,j=1,k=1;i<=m;i++)
    if(q[j].id<b[k].id)
      printf("%0.4lf\n",1.0*query(1,q[j].l,q[j].r)/(c[q[j].r]-c[q[j].l]+1)),j++;//询问区间要使用初始值
    else
      update(1,b[k].lvl,len,b[k].val),k++;
  return 0;
}

```

---

## 作者：方杰123 (赞：0)

## 思路
想到线段树就十分简单了，
求 $[x,y]$ 的期望其实就是等级为 $[x,y]$ 的知识总和除以 $y-x+1$，而一本等级为 $x$ 的书等级大于等于 $x$ 的的人就能学。
所以加书就是 ```update(x->inf)```，查询就是 ```query(x->y)```，也就是区间修改，区间查询。

------------

然后就是范围是 $(1\le x\le 2147483647)$，
感觉离散化起来好麻烦，
所以就动态开点了。


------------

可能第一次写区间修改的动态开点，  
调代码的时候才发现 ```pushdown``` 时也要给儿子开点。
## code
```cpp
#include<bits/stdc++.h>
using namespace std;
const long long RR=2147483647;
const long long N=5e5+10;
long long read(){
	long long x=0,f=1;char c=getchar();
	while(c>'9' || c<'0'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0' && c<='9'){
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return x*f;
}
long long n,m,rt,cnt;
struct node{
	long long l,r,lson,rson;
	long long va,lazy;
}e[N<<5];
void pushdown(long long u){
	long long mid=(e[u].l+e[u].r)>>1;
	if(!e[u].lson){e[u].lson=++cnt;e[cnt].l=e[u].l;e[cnt].r=mid;}
	if(!e[u].rson){e[u].rson=++cnt;e[cnt].l=mid+1;e[cnt].r=e[u].r;}
	if(e[u].lazy){
		e[e[u].lson].va+=e[u].lazy*(long long)(e[e[u].lson].r-e[e[u].lson].l+1);
		e[e[u].rson].va+=e[u].lazy*(long long)(e[e[u].rson].r-e[e[u].rson].l+1); 
		e[e[u].lson].lazy+=e[u].lazy;e[e[u].rson].lazy+=e[u].lazy;
		e[u].lazy=0;
	}
	return;
}
void pushup(long long u){
	e[u].va=e[e[u].lson].va+e[e[u].rson].va;return;
}
void update(long long &u,long long AL,long long AR,long long l,long long r,long long x){
	if(!u){u=++cnt;e[u].l=l;e[u].r=r;}
	if(AL<=e[u].l && e[u].r<=AR){
		e[u].va+=(long long)(e[u].r-e[u].l+1)*x;
		e[u].lazy+=x;
		return;
	}
	pushdown(u);long long mid=(e[u].l+e[u].r)>>1;
	if(AL<=mid)update(e[u].lson,AL,AR,l,mid,x);
	if(AR>mid)update(e[u].rson,AL,AR,mid+1,r,x);
	pushup(u);
	return;
}
long long query(long long u,long long l,long long r){
	if(!u)return 0;
	if(l<=e[u].l && e[u].r<=r)return e[u].va;
	pushdown(u);long long mid=(e[u].l+e[u].r)>>1;
	long long res=0;
	if(l<=mid)res+=query(e[u].lson,l,r);
	if(r>mid)res+=query(e[u].rson,l,r);
	return res; 
}
int main(){
	long long t1,t2,t3;double ans;
	n=read(),m=read();
	for(long long i=1;i<=n;i++){
		t1=read(),t2=read();
		update(rt,t1,RR,1,RR,t2);
	}
	for(long long i=1;i<=m;i++){
		t1=read(),t2=read(),t3=read();
		if(t1==1){
			ans=(double)query(rt,t2,t3)/(double)(t3-t2+1);
			printf("%.4lf\n",ans);
		}
		else{
			update(rt,t2,RR,1,RR,t3);
		}
	}
	return 0;
}
```

---

## 作者：Yansuan_HCl (赞：0)

## 题意简述

设 $V$ 为值域上限。

操作 1：把区间 $[x, V]$ 加上 $y$。

操作 2：查询区间 $[x, y]$ 的平均值。

## 分析

操作二本质上即查询 $[x, y]$ 的和再除以 $y - x + 1$。

考虑维护支持区间加、区间查询的树状数组。不会可以看[这篇题解](https://www.luogu.com.cn/blog/JustinRochester/solution-p3372)。

发现值域很大，不能开数组，但是值很稀疏。对于每个操作1，树状数组最多有 $\log V$ 个位置上的值被改变。因此，可以用 `unorderd_map` 储存树状数组。时间、空间复杂度为 $O((n+m)\log V)$。

## 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const ll V2 = 1ll << 31, V = 1ll << 32;
inline ll conv(ll x) { ll t = x + V2; return t; } // 把值域平移到非负整数
using Map = unordered_map<ll, ll>;
ll access(const Map& tr, ll p) {
    auto it = tr.find(p);
    return (it == tr.end()) ? 0 : it->second;
    // 避免不必要的查询空间开销
    // 下标操作符访问时，无论是否修改，都会生成一个新节点，浪费空间
}
Map tr, tr2;
ll lowbit(ll x) { return x & -x; }
void add(Map& tr, ll p, ll v) 
    { while (p <= V) { tr[p] += v; p += lowbit(p); }}
ll query(const Map& tr, ll p) 
    { ll a = 0; while (p) { a += access(tr, p); p ^= lowbit(p); } return a; }

int main() {
    int n, m; scanf("%d%d", &n, &m);
    while (n--) {
        ll a, w; scanf("%lld%lld", &a, &w);
        add(tr, conv(a), w);
        add(tr2, conv(a), conv(a) * w); // 树状数组区间修改
    }
    while (m--) {
        ll o, x, y; scanf("%lld%lld%lld", &o, &x, &y);        
        if (o == 1) {  
            x = conv(x); y = conv(y);          
            ll s1 = (y + 1) * query(tr, y) - query(tr2, y),
                s2 = x * query(tr, x - 1) - query(tr2, x - 1);
            // 树状数组区间查询
            printf("%.4lf\n", double(s1 - s2) / (y - x + 1));
        } else {
            add(tr, conv(x), y);
            add(tr2, conv(x), conv(x) * y);
        }
    }
}
```

---

## 作者：genshy (赞：0)

# 分析
首先，题目让我们求的是这个柿子  

##  **$\sum_{i=x}^{y} tot[i] \over y-x+1$**

$tot[i]$为$i$这个等级能看到的知识程度的总和。

我们可以以等级为区间，知识程度为权值。

那不就是区间和除以区间长度了吗？

看到区间和，我们就可以想到用线段树来维护。

但等级可能会达到2^32-1，所以我们考虑一下动态开点或者离散化（~~蒟蒻我不会写~~）

当新添一本书后，等级大于他的都可以看到，就相当于从这本书的等级到inf的区间，加上这本书的知识程度。

查询操作，就是区间和除以区间长度就OK了。

一定要注意开 long long(不开long long 见祖宗)

## 代码

```
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
#define LL long long
const int inf = 2147483536;
int n,m,x,y,opt,root,tot;
inline int read()
{
	int s = 0, w = 1; char ch = getchar();
	while(ch < '0' || ch > '9'){if(ch == '-') w =  -1; ch = getchar();}
	while(ch >= '0' && ch <= '9'){s  = s * 10+ch -'0'; ch = getchar();}
	return s * w;
}
struct Tree
{
	struct node{
		int lc,rc;
		LL sum,add;
	}tr[10000010];
	void down(int o,int l,int r)//下放操作
	{
		if(tr[o].add)
		{
			int mid = (l+r)>>1;
			if(!tr[o].lc) tr[o].lc = build();//如果没有子节点就新建一个
			if(!tr[o].rc) tr[o].rc = build();
			tr[tr[o].lc].add += tr[o].add;//正常的下放操作
			tr[tr[o].rc].add += tr[o].add;
			tr[tr[o].lc].sum += 1LL * tr[o].add * (mid-l+1);
			tr[tr[o].rc].sum += 1LL * tr[o].add * (r-mid);
			tr[o].add = 0;
		}
	}
	int build()//新建一个节点
	{
		tot++;
		tr[tot].lc = tr[tot].rc = tr[tot].sum = 0;
		return tot;
	}
	void insert(int root,int L,int R,int x,int y,int val)//区间修改
	{
		if(x <= L && y >= R)
		{
			tr[root].add += val;
			tr[root].sum +=1LL * val * (R-L+1);
			return;
		}
		int mid = (L+R)>>1;
		down(root,L,R);//下放标记
		if(x <= mid)
		{
			if(!tr[root].lc) tr[root].lc = build();//一定要新开节点，不然就会RE
			insert(tr[root].lc,L,mid,x,y,val);
		}
		if(y > mid)
		{
			if(!tr[root].rc) tr[root].rc = build();
			insert(tr[root].rc,mid+1,R,x,y,val);
		}
		tr[root].sum = tr[tr[root].lc].sum + tr[tr[root].rc].sum;//up操作
	}
	LL ask(int root,int L,int R,int x,int y)//区间和
	{
		LL ans = 0;
		if(x <= L && y >= R){return tr[root].sum;}
		int mid = (L+R)>>1;
		down(root,L,R);
		if(!tr[root].lc) tr[root].lc = build();
		if(!tr[root].rc) tr[root].rc = build();
		if(x <= mid) ans += ask(tr[root].lc,L,mid,x,y);
		if(y > mid) ans += ask(tr[root].rc,mid+1,R,x,y);
		return ans;
	}
}tree;
int main()
{
	n = read(); m = read();
	root = tree.build();
	for(int i = 1; i <= n; i++)
	{
		x = read(); y = read();
		tree.insert(root,1,inf,x,inf,y);//从x到inf区间加y
	}
	for(int i = 1; i <= m; i++)
	{
		opt = read(); x = read(); y = read();
		if(opt == 1)
		{
			LL tmp = tree.ask(root,1,inf,x,y);
			double ans = (double) tmp / (double)(y-x+1);
			printf("%.4lf\n",ans);
		}
		if(opt == 2)
		{
			tree.insert(root,1,inf,x,inf,y);
		}
	}
	return 0;
}
```


---


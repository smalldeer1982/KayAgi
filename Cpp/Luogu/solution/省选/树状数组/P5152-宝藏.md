# 宝藏

## 题目背景

此题为改编题，特别鸣谢倪星宇同学。

一群海盗抢到了许多宝藏，准备埋在自己的山洞里。


## 题目描述

海盗的山洞是一个n×n的方格，每个方格都可以储存很多宝藏。所有方格初始时是空的。海盗头头决定把这些宝藏藏在某些矩形区域里，同时了解某些矩阵区域里宝藏数量的奇偶性。但是宝藏实在太多了，他整理得眼花缭乱，所以他找到了你来帮忙。


## 说明/提示

30%的数据，n≤300，m≤300；

100%的数据，n≤2500，m≤50000，1≤x1≤x2≤n，1≤y1≤y2≤n，1≤ak≤30，1≤bk≤100；


## 样例 #1

### 输入

```
5 5
P 1 1 5 5 3 1 1 2 1 3 1
Q 1 1 5 5
Q 1 1 4 3
P 1 1 5 5 3 1 2 2 1 3 2
Q 1 2 3 4```

### 输出

```
222111111111111111111111111111
111111111111111111111111111111
212111111111111111111111111111```

# 题解

## 作者：tcl_tcl_tcl (赞：40)

# 蒟蒻的第一篇题解

(update:二维数组区间修改模板中有地方有误，已更正)
~~一位题解重度依赖患者由于没有题解被迫营业的悲惨经历~~

拿到题的的第一步当然是~~查看题解~~审题。相信在座的神犇们都已经看出来了，(~~我真的没有看算法标签~~)，
这题是一道树状数组的题，在刷完两道树状数组的模板题后，直接开始了强转一维树状数组的暴力解法，代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2500;
const int K = 31;
int x0, Y0, x1, Y1;
int m, n, k;
int sum1[N*N + 1][K], sum2[N*N + 1][K];
char op;
int lowbit(int x) {
	return x & -x;
}
void update(int i, int ak, int bk) {
	int x = i;
	while (i <= n * n) {
		sum1[i][ak] += bk;
		sum2[i][ak] += (x - 1)*bk;
		i += lowbit(i);
	}
}
int getsum(int i, int k) {
	int x = i;
	int ans = 0;
	while (i != 0) {
		ans += (x * sum1[i][k] - sum2[i][k]);
		i -= lowbit(i);
	}
	return ans;
}
int main()
{
	cin >> n >> m;
	while (m--) {
		cin >> op;
		if (op == 'P') {
			cin >> x0 >> Y0 >> x1 >> Y1 >> k;
			while (k--) {
				int ak, bk;
				cin >> ak >> bk;
				if (bk & 1) {
					for (int y = Y0; y <= Y1; y++) {
						update(x0 + (y - 1) * n, ak, bk);
						update(x1 + (y - 1) * n + 1, ak, -bk);
					}
				}
			}
		}
		if (op == 'Q') {
			cin >> x0 >> Y0 >> x1 >> Y1;
			for (int i = 1; i <= 30; i++)
			{
				int sum = 0;
				for (int y = Y0; y <= Y1; y++) {
					sum += getsum(x1 + (y - 1) * n, i) - getsum(x0 + (y - 1) * n - 1, i);
				}
				cout << ((sum % 2) + 1);
			}
			cout << endl;
		}
	}
	return 0;
}
```

结果当然是MLE+TLE大餐(~~其实三个点真香~~)，显然此题的正解不是
强转一维树状数组，而是二维树状数组，在分析开始我先介绍一下二维数组的三种题型以及对应的模板代码。


## 二维树状数组

### 1.单点修改+区间查询


```cpp
//while用for写也是一样的
void update(int x, int y, int z){
    int _y = y;
    while(x <= n){
        y = _y;
        while(y <= n)
            tree[x][y] += z, y += lowbit(y);
        x += lowbit(x);
    }
}
void query(int x, int y){
    int ans = 0, _y = y;
    while(x){
        y = _y;
        while(y)
            ans += tree[x][y], y -= lowbit(y);
        x -= lowbit(x);
    }
}

```
### 2.区间修改+单点查询

类似于一维的处理，可以设差分数组
$d[i]=a[i][j]-a[i-1][j]+a[i][j-1]-a[i-1][j-1]$
模板如下：
```cpp
//用万能头的选手不要使用x1,y1
void update(int x, int y, int z){ 
    int _y = y;
    while(x <= n){
        y = _y;
        while(y <= n)
            tree[x][y] += z, y += y & -y;
        x += x & -x;
    }
}
void range_update(int x1, int y1, int x2, int y2, int val){
    update(x1, y1, val);
    update(x1, y2 + 1, -val);
    update(x2 + 1, y1, -val);
    update(x2 + 1, y2 + 1, val);
}
void ask(int x, int y){
    int ans = 0, _y = y;
    while(x){
        y = _y;
        while(y)
            ans += tree[x][y], y -= lowbit(y);
        x -= lowbit(x);
    }
}
```
### 3.区间修改+区间查询
类比一维树状数组的区间修改查询，(x,y)的前缀和：
$\sum_{i=1}^{x}\sum_{j=1}^{y}\sum_{k=1}^{i}\sum_{h=1}^{j}d[h][k]$
其中,$d[1][1]$出现了$x*y$次,$d[1][2]$出现了$x*(y-1)$次
于是
$\sum_{i=1}^{x}\sum_{j=1}^{y}\sum_{k=1}^{i}\sum_{h=1}^{j}d[h][k]=\sum_{i=1}^{x}\sum_{j=1}^{y}d[i][j]*(x+1-i)*(y+1-j)$
展开得

$(x+1)*(y+1)*\sum_{i=1}^{x}\sum_{j=1}^{y}d[i][j]$
$-(y+1)*\sum_{i=1}^{x}\sum_{j=1}^{y}d[i][j]*i$
$-(x+1)*\sum_{i=1}^{x}\sum_{j=1}^{y}d[i][j]*j$
$+\sum_{i=1}^{x}\sum_{j=1}^{y}d[i][j]*i*j$

那么我们需要维护四个树状数组：
$d[i][j],d[i][j]*i,d[i][j]*j,d[i][j]*i*j$

代码模板如下：

```cpp
void update(int x, int y, int val) {
	for (int X = x; X <= n; X += lowbit(X))
		for (int Y = y; Y <= m; Y += lowbit(Y)) {
			t1[X][Y] += val;
			t2[X][Y] += val *x;
			t3[X][Y] += val * y;
			t4[X][Y] += val * x * y;
		}
}
void range_update(int xa, int ya, int xb, int yb, int val) { 
	update(xa, ya, val);
	update(xa, yb + 1, -val);
	update(xb + 1, ya, -val);
	update(xb + 1, yb + 1, val);
}
int query(int x, int y) {
	int res = 0;
	for (int i = x; i; i -= i & -i)
		for (int j = y; j; j -= j & -j)
			res += (x + 1) * (y + 1) * t1[i][j]
			- (y + 1) * t2[i][j]
			- (x + 1) * t3[i][j]
			+ t4[i][j];
	return res;
}
int range_query(int xa, int ya, int xb, int yb) {
	return query(xb, yb) - query(xb, ya - 1) - query(xa - 1, yb) + query(xa - 1, ya - 1);
}
```
## 题目分析

很明显这道题属于以上分析的第三种题型区间修改+区间查询，套用模板可得以下代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2500 + 1;
const int K = 31;
int t1[N][N][K], t2[N][N][K], t3[N][N][K], t4[N][N][K];	//第三个维度表示种类
int m, n, k;
int X1, Y1, X2, Y2;
int ak, bk;
char op;
int lowbit(int x)
{
	return x & -x;
}
void update(int x, int y, int k, int p)
{
	for (int X = x; X <= n; X += lowbit(X))
		for (int Y = y; Y <= n; Y += lowbit(Y)) {
			t1[X][Y][k] += p;
			t2[X][Y][k] += p * x;
			t3[X][Y][k] += p * y;
			t4[X][Y][k] += p * x * y;
		}
}
void range_update(int xa, int ya, int xb, int yb, int k, int p)
{
	update(xa, ya, k, p);
	update(xa, yb + 1, k ,-p);
	update(xb + 1, ya, k, -p);
	update(xb + 1, yb + 1, k, p);
}
int query(int x, int y, int k)
{
	int ans = 0;
	for (int i = x; i; i -= lowbit(i))
		for (int j = y; j; j -= lowbit(j))
			ans += (x + 1)*(y + 1)*t1[i][j][k]
			- (y + 1)*t2[i][j][k]
			- (x + 1)*t3[i][j][k]
			+ t4[i][j][k];
	return ans;
}
int range_query(int xa, int ya, int xb, int yb, int k)
{
	return query(xb, yb, k) - query(xb, ya - 1, k) - query(xa - 1, yb, k) + query(xa - 1, ya - 1, k)  ;
}
int main()
{
	ios::sync_with_stdio(false);
	cin >> n >> m;
	while (m--) {
		cin >> op;
		if (op == 'P')
		{
			cin >> X1 >> Y1 >> X2 >> Y2 >> k;
			while (k--)
			{
				cin >> ak >> bk;
				range_update(X1, Y1, X2, Y2, ak, bk);
			}
		}
		if (op == 'Q')
		{
			cin >> X1 >> Y1 >> X2 >> Y2;
			for (int i = 1; i <= 30; i++)
				cout<<((range_query(X1, Y1, X2, Y2, i)%2)+1);
			cout << endl;
		}
	}
	return 0;
}
```
很抱歉，这次30分也没有，本地会直接报错：LNK1248	映像大小(BA135000)超过允许的最大大小(80000000)，(~~通过查阅资料)~~仔细分析发现这和强转一维得到大小没有变化可能甚至还超过。观察到题目仅有最多30种物件，于是我们考虑状态压缩，用每一位表示物品奇偶性(0表示偶数个，1表示奇数个)，自然而然地就会想到异或运算。完整AC代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2500 + 1;
const int K = 5;
unsigned int t1[N][N], t2[N][N], t3[N][N], t4[N][N];
int m, n, k;
int X1, Y1, X2, Y2;
int ak, bk;
unsigned int ans, val;
char op;
int lowbit(int x)
{
	return x & -x;
}
void update(int x, int y, unsigned int p)
{
	for (int X = x; X <= n; X += lowbit(X))
		for (int Y = y; Y <= n; Y += lowbit(Y)) {
			t1[X][Y] ^= p;
			t2[X][Y] ^= ((y) & 1) ? p : 0;	//如果(y-1)是偶数，乘以任何数也是偶数，对结果不影响
			t3[X][Y] ^= ((x) & 1) ? p : 0;
			t4[X][Y] ^= ((x)&(y) & 1) ? p : 0;
		}
}
void range_update(int xa, int ya, int xb, int yb, int p)
{
	update(xa, ya, p);
	update(xa, yb + 1 ,p);
	update(xb + 1, ya, p);
	update(xb + 1, yb + 1, p);
}
unsigned int query(int x , int y)
{
	unsigned int ans = 0;
	for (int i = x; i; i -= lowbit(i))
		for (int j = y; j; j -= lowbit(j))
			ans ^= (((x + 1)&(y + 1)&1)?t1[i][j]:0)^
			(((x + 1) & 1) ? t2[i][j] : 0) ^
			(((y + 1) & 1) ? t3[i][j] : 0) ^
			t4[i][j];
	return ans;
}
unsigned int range_query(int xa, int ya, int xb, int yb)
{
	return query(xb, yb) ^ query(xb, ya - 1) ^ query(xa - 1, yb) ^ query(xa - 1, ya - 1)  ;
}
int main()
{
	ios::sync_with_stdio(false);
	cin >> n >> m;
	while (m--) {
		cin >> op;
		if (op == 'P')
		{
			val = 0;
			cin >> X1 >> Y1 >> X2 >> Y2 >> k;
			while (k--)
			{
				cin >> ak >> bk;
				if (bk & 1)
					val ^= (1 << ak);//只有奇数个有更新的必要，偶数个不影响结果
			}
			range_update(X1, Y1, X2, Y2, val);
		}
		if (op == 'Q')
		{
			cin >> X1 >> Y1 >> X2 >> Y2;
			ans = range_query(X1, Y1, X2, Y2);
			for (int i = 1; i <= 30; i++)
			{
				ans = ans >> 1;
				if (ans & 1)
					cout << 2;
				else
					cout << 1;
			}
				cout << endl;
		}
	}
	return 0;
}
```

看在~~我码的辛苦~~这是第一篇该题的详细题解的份上，各位大佬何不留个赞再走？

---

## 作者：mlvx (赞：3)

好题。

### 题意

两种操作，子矩阵加，以及维护子矩阵内每种物品数量的奇偶性。

数据范围：$n\le2500,m\le5000$。

### 分析

奇偶性可以转化为加数为奇数时将奇偶性的属性异或上 $1$。

令 $d_{i,j}=a_{i,j}\oplus a_{i-1,j}\oplus a_{i,j-1}\oplus a_{i-1,j-1}$，即异或意义下的差分数组（下文的差分均表示异或意义下的差分）。

由差分的定义可知，$a_{i,j}=\bigoplus\limits_{p=1}^i\bigoplus\limits_{q=1}^j d_{p,q}$。


故 $\bigoplus\limits_{i=1}^x\bigoplus\limits_{j=1}^y a_{i,j}=\bigoplus\limits_{i=1}^x\bigoplus\limits_{j=1}^y\bigoplus\limits_{p=1}^i\bigoplus\limits_{q=1}^j d_{p,q}$。

注意到 $d_{i,j}$ 被异或了 $(x-i+1)(y-j+1)$ 次，由于异或的性质，$x\oplus x=0$，所以我们只需要关注 $(x-i+1)(y-j+1)$ 的奇偶性即可。

易知仅当 $x,i$ 同奇偶，$y,j$ 同奇偶时 $d_{i,j}$ 才有贡献。

故把原来的二维树状数组再加上两维，一个表示当前 $x$ 的奇偶，一个表示当前 $y$ 的奇偶。

---

然后发现开不下了。

只有 $30$ 种物品，考虑状压。

按照平常直接搞子矩阵异或，但是一个数字二进制下第 $x$ 位表示编号为 $x$ 的物品数量的奇偶性（$1$ 表示奇数，$0$ 表示偶数）。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2501;
int n,q,a,b,c,d,k,x,y,tr[2][2][N][N];char op;
//================================
inline int lbt(int x){return x&(-x);}
inline void add(int x,int y,int v){
	for(register int i=x;i<=n;i+=lbt(i))for(register int j=y;j<=n;j+=lbt(j))tr[x&1][y&1][i][j]^=v;
}inline int query(int x,int y,int ret=0){
	for(register int i=x;i;i-=lbt(i))for(register int j=y;j;j-=lbt(j))ret^=tr[x&1][y&1][i][j];
	return ret;
}//二维树状数组模板
//================================
int main(){
	ios::sync_with_stdio(cin.tie(cout.tie()));
	cin>>n>>q;
	while(q--){
		cin>>op>>a>>b>>c>>d;
		if(op=='Q'){
			int ans=query(a-1,b-1)^query(a-1,d)^query(c,b-1)^query(c,d),cnt=0;//把异或和先搞出来
			for(;ans;ans>>=1)cout<<(ans&1)+1,++cnt;//把有值的先输出了
			for(;cnt<30;cnt++)cout<<1;//后面没有值，补上 1
			puts("");
		}else{
			cin>>k;
			while(k--){
				cin>>x>>y;
				if(y&1)//只有加数为奇数才操作
					add(a,b,1<<x-1),add(a,d+1,1<<x-1),add(c+1,b,1<<x-1),add(c+1,d+1,1<<x-1);
					//二进制下从低位数的第 x-1 位表示第 x 种物品的奇偶性
			}
		}
	}return 0;
}
```

---

## 作者：Tomle (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P5152)。

# update
- 2024.3.21 修改了超长代码。
- 2024.3.24 修改代码，一些内容比较晦涩难懂，对语言打磨润色。
- 2024.4.11 修改，将 `\operatorname{log}` 改为 `\log`。
- 2024.5.7 更改。
- 2024.6.22 规范了一下 $\LaTeX$。
- 2024.7.22 重构。

很抱歉多次提交给管理员造成不便。

第二道紫题，也是第二篇题解。

# 约定

$\bigoplus$ 表示**异或**。

$a$ 对 $b$ 产生了 $k$ 次“贡献”表示 $b$ 被 $a$ 影响了 $k$ 次，如 $\bigoplus\limits_{i=1}^n\bigoplus\limits_{j=i}^na_j$，可以说 $a_i$ 对这个式子产生了 $i$ 次贡献。

# 思路

## 状态压缩

第一眼看到这个题，树状数组？紫题？看了一下，认为是二维树状数组套一维数组，但细一想，空间和时间都会爆。大小 $2500 \times 2500 \times 30$ 的数组肯定开不下，时间复杂度是 $\mathcal{O}(km\log^2 n)$ 的，$\log^2 n$ 是二维树状数组单次修改的复杂度。

细一想，这个题只需要输出物品数量的奇偶性，可以用 bool 数组或 bitset，但是 bool 运算低效，时间只增不减。

数据范围：$1 \le k \le 30$，int 的空间是 $4$ 字节，也就是 $32$ 位，可以考虑用一个 int 表示 $30$ 个物品的奇偶性，修改使用位运算，非常快。

## 异或的性质

首先，显然对于任意整数 $a$，$a\bigoplus a=0$。

非常简单的结论是：
$$
\bigoplus_{i=1}^na=\begin{cases}
0, & 2\mid n\\
a, & 2\nmid n
\end{cases}
$$

## 异或序列

### 定义

我们让 $a$ 为原序列，其异或序列 $b$，满足：
$$
b_{i,j}=a_{i,j}\bigoplus a_{i-1,j}\bigoplus a_{i,j-1}\bigoplus a_{i-1,j-1}
$$

### 性质

$$
a_{x,y}=\bigoplus_{i=1}^x\bigoplus_{j=1}^yb_{i,j}
$$

证明：

显然，$a_{i,j}$ 会对 $b_{i,j},b_{i+1,j},b_{i,j+1},b_{i+1,j+1}$ 产生一次贡献，可以转换一下思路，求 $a_{i,j}$ 在上式中产生了几次贡献，共分为 $4$ 种情况：

1. $i=x$ 且 $j=y$，$a_{i,j}$ 产生了一次贡献（$b_{i,j}$）；
2. $i=x$ 且 $j\lt y$，$a_{i,j}$ 产生了两次贡献（$b_{i,j},b_{i,j+1}$）；
3. $i\lt x$ 且 $j=y$，$a_{i,j}$ 产生了两次贡献（$b_{i,j},b_{i+1,j}$）；
4. $i\lt x$ 且 $j\lt y$，$a_{i,j}$ 产生了四次贡献（$b_{i,j},b_{i+1,j},b_{i,j+1},b_{i+1,j+1}$）。

根据异或的性质，产生了偶数次贡献的数相当于贡献为 $0$。只有第一种情况，也就是 $a_{x,y}$ 有 $1$ 次贡献，所以命题成立。

证毕。

### 区间修改

首先，我们将原序列转换成异或序列是为了**方便修改**。

如果原序列 $(x_1,y_1)$ 到 $(x_2,y_2)$ 异或上 $k$，$b_{x_1,y_1},b_{x_2+1,y_1},b_{x_1,y_2+1},b_{x_2+1,y_2+1}$ 就异或上 $k$。

证明：

![](https://cdn.luogu.com.cn/upload/image_hosting/kf5ho7p5.png)

这是原序列。

![](https://cdn.luogu.com.cn/upload/image_hosting/i4x6q9hf.png)

红色部分产生影响（异或）。

![](https://cdn.luogu.com.cn/upload/image_hosting/8xj1min0.png)

容易发现只有粗线围成的四个 $2\times2$ 正方形中，只有一个点产生了影响。

根据异或的性质，若 $a_{i,j},a_{i-1,j},a_{i,j-1},a_{i-1,j-1}$ 中有奇数个产生了影响，则 $b_{i,j}$ 产生影响。所以，这些粗线边框的右下角位置的异或序列产生了影响（异或 $k$）。

证毕。

### 区间查询。

令 $f$ 为异或序列，$g(x,y)$ 为 $\bigoplus\limits_{i=1}^x\bigoplus\limits_{j=1}^yf_{i,j}$，也就是原序列 $(x,y)$ 的值。可以表示原序列 $(1,1)$ 到 $(x,y)$ 的异或和：

$$
\bigoplus_{i=1}^x\bigoplus_{j=1}^yg(i,j)
$$

根据 $g$ 的定义，$f_{i,j}$ 对 $g(x,y)$ 产生贡献当且仅当 $i\le x$ 且 $j\le y$。易得上式中 $f_{i,j}$ 产生 $(x-i+1)(y-j+1)$ 次贡献。

仿照异或序列的修改，我们转换一下思路，统计 $f_{i,j}$ 在上式中被异或了多少次。

$$
\bigoplus_{i=1}^x\bigoplus_{j=1}^yg(i,j)
=\bigoplus_{i=1}^x\bigoplus_{j=1}^y\bigoplus_{k=1}^{(x-i+1)(y-i+1)}f_{i,j}
$$

根据异或的性质，上式可以变成：
$$
\bigoplus_{i=1}^x\bigoplus_{j=1}^y[2\nmid(x-i+1)(y-j+1)]f_{i,j}
$$

对于下图，这个网格表示的是异或序列，原序列的二维区间异或和等于下图（异或序列）黑色块的异或和。

![](https://cdn.luogu.com.cn/upload/image_hosting/fr76ik37.png)

对于不同位置的异或和，异或序列中黑色块（参与计算的块）只有四种可能的位置，用不同的颜色标注。

![](https://cdn.luogu.com.cn/upload/image_hosting/m9fuf9ed.png)

可以建四个树状数组维护不同颜色的异或和，可以把相同颜色的点压缩在一起，每次修改 / 查询只需要选择对应的树状数组进行修改 / 查询，空间压缩 $4$ 倍。

这样就用异或序列表示出原序列的二维前缀异或和了。

如果 $h(x,y)$ 是 $(1,1)$ 到 $(x,y)$ 的前缀异或和，学过前缀的都知道，$(x_1,y_1)$ 到 $(x_2,y_2)$ 的前缀和等于：
$$
h(x_2,y_2)\bigoplus h(x_1-1,y_2)\bigoplus h(x_2,y_1-1)\bigoplus h(x_1-1,y_1-1)
$$

# 代码

时间复杂度 $\mathcal{O}(m \log^2 n)$。

```cpp
#include <bits/stdc++.h>
#define lowbit(k) ((k) & -(k))
#define re register
#define il inline
#define ri re int
#define y1 GoodName
// 注意 y1 的变量名问题
using namespace std; 

constexpr int N = 1255;

int n, m, bit[2][2][N][N], x1, y1, x2, y2, k, x, y, op;
// bit[0/1][0/1] 表示奇偶性

il void read(ri &a, ri ch = 0) {
	while (!isdigit(ch = getchar()));
	for (a = 0; isdigit(ch); ch = getchar()) a = (a << 3) + (a << 1) + (ch ^ 48);
}
void upd(ri x, ri y, ri k) {
	for (ri i = (x + 1) >> 1; i <= (n + 5) >> 1; i += lowbit(i))
		for (ri j = (y + 1) >> 1; j <= (n + 5) >> 1; j += lowbit(j))
			bit[x & 1][y & 1][i][j] ^= k;
}
int que(ri x, ri y) {
	if (!x || !y) return 0;
	ri res = 0;
	for (ri i = (x + 1) >> 1; i; i -= lowbit(i))
		for (ri j = (y + 1) >> 1; j; j -= lowbit(j))
			res ^= bit[x & 1][y & 1][i][j];]
	return res;
}
il int query(ri x1, ri y1, ri x2, ri y2) {
	return que(x2, y2) ^ que(x1 - 1, y2) ^ que(x2, y1 - 1) ^ que(x1 - 1, y1 - 1); 
}
int main() {
	read(n), read(m);
	while (m--) {
		while (isspace(op = getchar()));
		if (op == 'P') {
			read(x1), read(y1), read(x2), read(y2), read(k);
			ri num = 0;
			while (k--) {
				read(x), read(y);
				num ^= (y & 1) << x;
			}
			upd(x1, y1, num), upd(x1, y2 + 1, num), upd(x2 + 1, y1, num), upd(x2 + 1, y2 + 1, num);
		} else {
			read(x1), read(y1), read(x2), read(y2);
			for (ri i = 1, res = query(x1, y1, x2, y2) >> 1; i <= 30; ++i, res >>= 1)
				putchar(49 + (res & 1));
			putchar(10);
		}
	} 
	return 0;
}
```

总结：二维树状数组区问区修维护异或和。

---

## 作者：迷残云 (赞：0)

感觉是一道还行的线段树（~~树状数组~~）题

首先二维的线段树显然我是不会的，于是把二维转成一维再进行计算$（2500*2500）$的数据应该不会爆空间。。。

然后就可以像一般的线段树一样计算了，只是把和$ /$最小值改为奇偶判断吧……，注意偶1奇2，再拿个数组存一下1还是2，应该差不多了。

一眼看上去就是这个样子，代码自己没写过，思路应该是正常的。

咕咕

---


# 圣剑护符

## 题目背景

小L和小K正在研究传说中的圣剑。

“所谓圣剑，是封入了各种护符并将其固定为刀剑外形的一种东西。据说一旦用咒力线把护符们接合在一起，就会产生复杂的相互干涉作用。”

## 题目描述

小L和小K面前的圣剑由 $n$ 块护符组成，分别编号为 $1,2,\ldots , n$ ，有 $n-1$ 条咒力线连接两块护符，形成了一个树形结构。

经过小L和小K的长时间的研究，他们发现护符之间的相互作用并不复杂。每块护符都有一个属性值，第 $i$ 块护符的属性值记为 $v_i$ 。这个值的每个二进制位上的 $0$ 或 $1$ 表示这块护符是否拥有特定属性。所有属性值中相同的二进制位对应的是相同的属性。

对于一系列护符（护符的集合），对于每种特定属性，统计其中包含这一属性的护符数量，如果为偶数，则这一系列护符形成了干涉，最终的属性值对应的二进制位上为 $0$ ，如果为奇数则干涉后剩下了一块护符的影响，对应的二进制位为 $1$ 。也就是说， **护符集合的属性值为单个护符的属性值的异或和** 。 **空集的属性值定义为 $0$** 。

现在，小L想知道，如果取出两块护符 $x,y$ 间的简单路径上的所有护符，能否找到两个不相等的子集，使得两个子集的属性值相同（注意到空集也是路径上所有护符集合的子集）。同时，小K还会将两块护符间的路径上的所有护符取出进行调整，将所有这些护符的属性值在某些相同二进制位上进行修改（即 $0$ 变为 $1$ ， $1$ 变为 $0$ ），可以看做是将所有这些护符的属性值异或上了一个值。

## 说明/提示

由于某种原因，本题将采用 **捆绑测试** 。只有通过一个子任务内的所有测试点，才能得到该子任务的全部分数，否则得 $0$ 分。

$Subtask\#1$ ： $20pts$ ， $x,y$ 在树上的距离小于等于 $5$ 。

$Subtask\#2$ ： $40pts$ ， $n,q\le 5000,0\le v_i,z\le 2^{10}$

$Subtask\#3$ ： $40pts$ ，无特殊限制。

对于 $100\%$ 的数据，有 $1\le n,q\le 10^5,1\le x,y\le n,0\le v_i,z< 2^{30}$


## 样例 #1

### 输入

```
2 3
3 4
1 2
Query 1 2
Update 2 2 7
Query 2 1```

### 输出

```
NO
YES```

# 题解

## 作者：jun头吉吉 (赞：12)

## 树链剖分·线性基·真·板子题
~~[SJY](https://www.luogu.com.cn/user/151935)说：这是一道【哔~】题~~

首先，我们看到了**异或**操作，那毫无疑问，就是用线性基了

#### 我们知道，线性基有如下性质：
- 基中的数无法异或出$0$
- 线性基中的数异或出来的值，用原数列也能异或出来

那么很显然，如果一个数无法被插入，则说明这个数可以$\oplus$线性基中的数从而变成$0$，换句或说：

#### 如果一个数无法被插入，那么它一定可以由已插入的数异或得到

那么我们就可以用这个性质来判断一组数据``` 是否存在两个不相等的子集，使得两个子集的值相同 ```

然后，我们又发现一个很有趣的性质：线性基中一共有$\lceil log_2(v)+1\rceil$个位置，所以最多只能插入$31$个数，对于后面插入的数，一定可以由前面的数异或得到，于是我们又得到了一条有用的性质：

#### 如果两点间简单路径上的点数$＞31$,那么一定有集合的值相等

那么小蒟蒻又有问题了：按照上面的思路，就需要快速求出树上两点的距离，还要快速修改，~~蒟蒻做不到啊~~

于是这时，**树链剖分**就出现了。不仅能快速求LCA，套上线段树快速修改，完全符合我们的需要

~~抄~~借鉴完树链剖分，这道题就愉快地做完了

```cpp
#pragma optimize(2)
#include<bits/stdc++.h>
using namespace std;
template<typename T>
inline void read(T &x){
	x=0;char c=getchar();bool f=false;
	for(;!isdigit(c);c=getchar())f!=c=='-';
	for(;isdigit(c);c=getchar())x=x*10+c-'0';
	if(f)x=-x;
}
template<typename T ,typename ...Arg>
inline void read(T &x,Arg &...args){
	read(x);read(args...);
}
template<typename T>
inline void write(T x){
	if(x<0)putchar('-'),x=-x;
	if(x>=10)write(x/10);
	putchar(x%10+'0');
}
char get(){char c=getchar();while(!isalpha(c))c=getchar();return c;}
const int maxn=1e5+100;
struct Graph{
	struct node{int v,nxt;}e[maxn*2];
	int cnt,head[maxn];
	inline void add(int x,int y){e[++cnt]={y,head[x]};head[x]=cnt;}
	#define For(G,x) for(int ___=(G).head[x];___;___=(G).e[___].nxt)
	#define v(G) (G).e[___].v
}G;
//----------树----------
struct Segment_Tree{
	struct node{
		int num,l,r;
		int tag;
	}t[maxn<<2];
	void build(int x,int l,int r){
		t[x].l=l,t[x].r=r;
		t[x].num=0,t[x].tag=0;
		if(l==r)return;
		int mid=l+r>>1;
		build(x<<1,l,mid);
		build(x<<1|1,mid+1,r);
	}
	void pushdown(int x){
		if(t[x].tag){
			t[x<<1].tag^=t[x].tag;
			t[x<<1].num^=t[x].tag;
			t[x<<1|1].tag^=t[x].tag;
			t[x<<1|1].num^=t[x].tag;
			t[x].tag=0;
		}
	}
	void update(int x,int l,int r,int val){
		if(t[x].l>r||t[x].r<l)return;
		if(l<=t[x].l&&t[x].r<=r){t[x].num^=val;t[x].tag^=val;return;}
		pushdown(x);update(x<<1,l,r,val);update(x<<1|1,l,r,val);
	}
	int query(int x,int pos){
		if(t[x].l==t[x].r)return t[x].num;
		pushdown(x);
		int mid=t[x].l+t[x].r>>1;
		if(pos<=mid)return query(x<<1,pos);
		else return query(x<<1|1,pos);
	}
	void print(int x){
		if(t[x].l==t[x].r)printf("%d ",t[x].num);
		else pushdown(x),print(x<<1),print(x<<1|1);
	}
}ST;
//----------线段树----------
int fa[maxn];//父节点
int deep[maxn];//深度
int size[maxn];//子树大小
int top[maxn];//链顶
int id[maxn];//dfs序
int v[maxn];//权值 
int cnt=0;
void dfs1(int x,int f){
	//处理： fa deep size
	fa[x]=f,deep[x]=deep[f]+1;size[x]=1;
	For(G,x)if(v(G)!=f)dfs1(v(G),x),size[x]+=size[v(G)];
} 
void dfs2(int x,int f){
	//处理： top id
	id[x]=++cnt;top[x]=f;ST.update(1,cnt,cnt,v[x]);
	int MAX=-1,s=-1;
	For(G,x) if(v(G)!=fa[x]&&size[v(G)]>MAX) MAX=size[v(G)], s=v(G);
	if(MAX!=-1)dfs2(s,f);
	For(G,x) if(v(G)!=fa[x]&&v(G)!=s)dfs2(v(G),v(G));
}
void update(int x,int y,int z){
    while(top[x]!=top[y]){
        if(deep[top[x]]<deep[top[y]])
            swap(x,y);
        ST.update(1,id[top[x]],id[x],z);
        x=fa[top[x]];
    }
    if(id[x]>id[y])
        swap(x,y);
    ST.update(1,id[x],id[y],z);
}
int LCA(int u,int v){  
    while(top[u]!=top[v])/*u、v不在同一条重链上时*/{
        if(deep[top[u]]>deep[top[v]])//将深度大的上提
            u=fa[top[u]];
        else
            v=fa[top[v]];
    }
    if(deep[u]<deep[v])//返回u、v中在较上方的那个
        return u;
    return v;
}
//----------树链剖分----------
const int max_wei=31;
struct leaner_basis{
	int b[max_wei];
	void init(){memset(b,0,sizeof b);}
	bool insert(int x){
		for(int i=max_wei-1;i>=0;i--){
			if(!(x&(1<<i)))continue;
			if(!b[i]){b[i]=x;return true;}
			x^=b[i];
		}
		return false;
	}
}B;
//----------线性基---------- 
int n,q,x,y,z;
signed main(){
	read(n,q);
	for(int i=1;i<=n;i++)
		read(v[i]);
	for(int i=1;i<n;i++)
		read(x,y),G.add(x,y),G.add(y,x);
	ST.build(1,1,n);
	dfs1(1,-1);dfs2(1,1);
	for(int i=1;i<=q;i++){
		char opt=get();
		if(opt=='Q'){
			read(x,y);
			int lca=LCA(x,y);
			int dis=deep[x]+deep[y]-deep[lca]*2+1;
			if(dis>30)printf("YES\n");
			else{
				B.init();
				bool flag=false;
				if(!B.insert(ST.query(1,id[lca])))flag=true;
				if(!flag)
					while(x!=lca){
						if(!B.insert(ST.query(1,id[x]))){flag=true;break;}
						x=fa[x];
					}
				if(!flag)
					while(y!=lca){
						if(!B.insert(ST.query(1,id[y]))){flag=true;break;}
						y=fa[y];
					}
				printf(flag?"YES\n":"NO\n");
			}
		}
		else{
			read(x,y,z);
			update(x,y,z);
		}
	}
}
```

---

## 作者：Eibon (赞：6)

发现在树上进行一些操作，于是不难联想到树链剖分。

接下来思考异或操作，考虑线性基。

线性基是一种集合，该集合有以下特征：

1. 在序列中的任何一个数都能被线性基中的多个元素异或出来。

2. 线性基中的元素无法异或出 $0$。

3. 在符合上述的两个条件的基础上，线性基的长度要尽可能小。

[线性基](https://www.luogu.com.cn/problem/P3812)的代码如下。

$add$ 函数用来将序列中的每一个数试图插入到线性基中。

先从大到小枚举二进制每一位。

要想对这一位有贡献，则插入的数这一位必须要有 $1$。

其中 $add$ 函数的第一个判断表示对于当前这一位，已经有一个数将所需要的 $1$ 填补上了。那么这个数的这一位 $1$ 就不需要了，我们让这个数异或一下已有的数，将不需要的 $1$ 都抹去。

这样就保证答案的第 $i$ 位为 $1$，且后面没有机会改变第 $i$ 位。

如果当前这一位没有数占据，就把这个数塞进 $d$ 数组，让它对这一位 $1$ 产生贡献。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=50+5;
const int inf=0x3f3f3f3f;
int T=1,n,ans;
int a[maxn],d[maxn];
void add(int x)
{
	for(int i=50;i>=0;i--){
		if(x>>i){
			if(d[i]){
				x^=d[i];
			}
			else{
				d[i]=x;
				break;
			}
		}
	}
}
void solve()
{
    scanf("%lld",&n);
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
		add(a[i]);
	}
	for(int i=50;i>=0;i--){
		ans=max(ans,ans^d[i]);
	}
	printf("%lld\n",ans);
}
signed main()
{
//	freopen("1.in","r",stdin);
//	freopen("1.out","w",stdout);
	//scanf("%lld",&T);
	while(T--){
		solve();
	}
	return 0;
}
//dyyyyds
```

最开始笔者想要暴力的对树剖出来的每一条链都丢进线性基里跑。但是这样会超时的。

随后发现，如果有超过 $30$ 个数插入进线性基里了，那么一定会合法。因为点权最大也是小于 $2^{30}$ 的。

对于剩余的情况，直接暴力跑一遍即可，如果插不进去，就说明插入线性基中的元素可以与当前的数异或出 $0$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=1e5+5;
int T=1,n,q,tot,cnt;
int a[maxn],d[35],head[maxn],dfn[maxn],rk[maxn];
int sz[maxn],son[maxn],fa[maxn],tp[maxn],dep[maxn];
string c;
bool flag;
struct edge
{
	int to,nxt;
};
edge e[maxn<<1];
struct Tree
{
	int sum,lz;
};
Tree tree[maxn<<2];
void pushdown(int root)
{
	tree[root<<1].sum^=tree[root].lz;
	tree[root<<1|1].sum^=tree[root].lz;
	tree[root<<1].lz^=tree[root].lz;
	tree[root<<1|1].lz^=tree[root].lz;
	tree[root].lz=0;
}
void build(int root,int l,int r)
{
	if(l==r){
		tree[root].sum=a[rk[l]];
//		cerr<<l<<" "<<rk[l]<<" "<<a[rk[l]]<<endl;
		return;
	}
	int mid=(l+r)>>1;
	build(root<<1,l,mid);
	build(root<<1|1,mid+1,r);
	tree[root].sum=tree[root<<1].sum^tree[root<<1|1].sum;
}
void update(int root,int l,int r,int L,int R,int k)
{
	if(L<=l&&r<=R){
		tree[root].sum^=k;
		tree[root].lz^=k;
		return;
	}
	if(tree[root].lz) pushdown(root);
	int mid=(l+r)>>1;
	if(L<=mid){
		update(root<<1,l,mid,L,R,k);
	}
	if(R>mid){
		update(root<<1|1,mid+1,r,L,R,k);
	}
	tree[root].sum=tree[root<<1].sum^tree[root<<1|1].sum;
}
int query(int root,int l,int r,int x)
{
	if(l==r){
		return tree[root].sum;
	}
	int mid=(l+r)>>1;
	if(tree[root].lz) pushdown(root);
	if(x<=mid){
		return query(root<<1,l,mid,x);
	}
	else{
		return query(root<<1|1,mid+1,r,x);
	}
}
void add(int u,int v)
{
	e[++tot]={v,head[u]};
	head[u]=tot;
}
void ins(int x)
{
//	cerr<<x<<endl;
	for(int i=30;i>=0;i--){
		if(x>>i){
			if(d[i]){
				x^=d[i];
			}
			else{
				d[i]=x;
				return;
			}
		}
	}
	flag=0;
}
void dfs1(int u,int pa)
{
	sz[u]=1;
	fa[u]=pa;
	dep[u]=dep[pa]+1;
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v==pa){
			continue;
		}
		dfs1(v,u);
		sz[u]+=sz[v];
		if(sz[son[u]]<sz[v]){
			son[u]=v;
		}
	}
}
void dfs2(int u,int top_pa)
{
	dfn[u]=++cnt;
	rk[cnt]=u;
	tp[u]=top_pa;
//	cerr<<u<<" "<<cnt<<endl;
	if(son[u]){
		dfs2(son[u],top_pa);
	}
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v==fa[u]||v==son[u]){
			continue;
		}
		dfs2(v,v);
	}
}
void uv_update(int u,int v,int w)
{
	while(tp[u]!=tp[v]){
		if(dep[tp[u]]<dep[tp[v]]){
			swap(u,v);
		}
		update(1,1,n,dfn[tp[u]],dfn[u],w);
		u=fa[tp[u]];
	}
	if(dep[u]<dep[v]){
		swap(u,v);
	}
	update(1,1,n,dfn[v],dfn[u],w);
}
int LCA(int u,int v)
{
	while(tp[u]!=tp[v]){
		if(dep[tp[u]]<dep[tp[v]]){
			swap(u,v);
		}
		u=fa[tp[u]];
	}
	if(dep[u]<dep[v]){
		swap(u,v);
	}
	return v;
}
void jumping(int u,int v)
{
	for(int i=u;i!=v;i=fa[i]){
//		cerr<<i<<endl;
		ins(query(1,1,n,dfn[i]));
	}
}
void solve()
{
    scanf("%lld%lld",&n,&q);
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
	}
	for(int i=1;i<n;i++){
		int u,v;
		scanf("%lld%lld",&u,&v);
		add(u,v);add(v,u);
	}
	dfs1(1,0);
	dfs2(1,1);
	build(1,1,n);
	while(q--){
		cin>>c;
		int u,v;
		scanf("%lld%lld",&u,&v);
		if(c[0]=='U'){
			int w;
			scanf("%lld",&w);
			uv_update(u,v,w);
		}
		else{
			int l=LCA(u,v);
			if(dep[u]+dep[v]-2*dep[l]>29){
				puts("YES");
				continue;
			}
			memset(d,0,sizeof d);
			flag=1;
			jumping(u,l);
			jumping(v,l);
			ins(query(1,1,n,dfn[l]));
			if(!flag){
				puts("YES");
			}
			else{
				puts("NO");
			}
		}
	}
}
signed main()
{
//	freopen("1.in","r",stdin);
//	freopen("1.out","w",stdout);
	//scanf("%lld",&T);
	while(T--){
		solve();
	}
	return 0;
}
```

---

## 作者：5k_sync_closer (赞：5)

对一次询问，假设已经建出了这条树链的线性基，考虑存在两个子集异或和相等的条件。

若存在未成功插入线性基的数 $k$，则一定可以在线性基中选出异或和为 $k$ 的子集 $S$，此时存在 $\{k\}$ 与 $S$ 异或和相等。

否则，树链的 $2^n$ 个子集异或和对应线性基的 $2^n$ 个互不相同的子集异或和，此时不存在两个子集异或和相等。

综上所述，存在两个子集异或和相等当且仅当存在未成功插入线性基的数。

线性基最多成功插入 $\log V$ 个数，所以长度大于 $\log V$ 的树链上一定存在未成功插入线性基的数。

对于长度小于等于 $\log V$ 的树链，直接建出线性基判断是否存在未成功插入线性基的数即可。

现在需要维护树链异或，单点查询，BIT 即可。

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
struct E
{
    int v, t;
} e[200050];
char o[10];
int n, m, c, p, P[50], a[100050], b[100050], d[100050], s[100050], C[100050], h[100050], f[100050][20];
void A(int u, int v)
{
    e[++c] = {v, h[u]};
    h[u] = c;
}
void M(int x, int k)
{
    for (; x <= n; x += x & -x)
        C[x] ^= k;
}
int Q(int x)
{
    int q = 0;
    for (; x; x &= x - 1)
        q ^= C[x];
    return q;
}
void D(int u, int k)
{
    s[u] = 1;
    b[u] = ++p;
    for (int i = h[u], v; i; i = e[i].t)
        if ((v = e[i].v) != k)
        {
            d[v] = d[f[v][0] = u] + 1;
            for (int j = 1; f[v][j - 1]; ++j)
                f[v][j] = f[f[v][j - 1]][j - 1];
            D(v, u);
            s[u] += s[v];
        }
}
int L(int x, int y)
{
    if (d[x] < d[y])
        swap(x, y);
    while (d[x] > d[y])
        x = f[x][__lg(d[x] - d[y])];
    if (x == y)
        return x;
    for (int k = __lg(d[x]); k >= 0; --k)
        if (f[x][k] != f[y][k])
            x = f[x][k], y = f[y][k];
    return f[x][0];
}
bool I(int x)
{
    for (int i = 30; i >= 0; --i)
        if (x >> i & 1)
        {
            if (!P[i])
                return P[i] = x, 1;
            else
                x ^= P[i];
        }
    return 0;
}
int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++i)
        scanf("%d", a + i);
    for (int i = 1, u, v; i < n; ++i)
        scanf("%d%d", &u, &v), A(u, v), A(v, u);
    D(d[1] = 1, 0);
    for (int i = 1; i <= n; ++i)
    {
        M(b[i], a[i]);
        if (f[i][0])
            M(b[f[i][0]], a[i]);
    }
    for (int i = 0, x, y, k, l; i < m; ++i)
    {
        scanf("%s%d%d", o, &x, &y);
        if (o[0] == 'U')
        {
            scanf("%d", &k), M(b[x], k), M(b[y], k), M(b[l = L(x, y)], k);
            if (f[l][0])
                M(b[f[l][0]], k);
        }
        else
        {
            if (d[x] + d[y] - (d[L(x, y)] << 1) >= 30)
            {
                puts("YES");
                continue;
            }
            for (int i = 0; i <= 30; ++i)
                P[i] = 0;
            if (d[x] < d[y])
                swap(x, y);
            bool F = 0;
            while (d[x] > d[y])
            {
                if (!I(Q(b[x] + s[x] - 1) ^ Q(b[x] - 1)))
                {
                    F = 1;
                    break;
                }
                x = f[x][0];
            }
            if (F)
            {
                puts("YES");
                continue;
            }
            while (x != y)
            {
                if (!I(Q(b[x] + s[x] - 1) ^ Q(b[x] - 1)))
                {
                    F = 1;
                    break;
                }
                if (!I(Q(b[y] + s[y] - 1) ^ Q(b[y] - 1)))
                {
                    F = 1;
                    break;
                }
                x = f[x][0];
                y = f[y][0];
            }
            if (!I(Q(b[x] + s[x] - 1) ^ Q(b[x] - 1)))
                F = 1;
            if (F)
            {
                puts("YES");
                continue;
            }
            puts("NO");
        }
    }
    return 0;
}
```


---

## 作者：hsfzLZH1 (赞：3)

出题人： [hsfzLZH1](https://www.luogu.org/space/show?uid=43486)

本题主要考察线性基和树链剖分的内容。

## 题目大意

给定一棵有 $n$ 个结点的树，每个结点都有一个点权 $v_i$ ， $q$ 次操作，每次操作为以下两种形式之一：

1.  `Update x y z` 将树上 $x,y$ 两点之间的简单路径上的所有点的点权异或上 $z$ 。

2.  `Query x y` 判断对于树上 $x,y$ 两点之间的简单路径上的点构成的点的集合，是否存在两个不相等的子集，这两个子集的点权异或和相等。

## Subtask#1

观察到 $x,y$ 在树上的距离很小，修改时直接跳路径修改，判断时直接提取出路径上的所有点，枚举子集进行判断即可。

## Subtask#2

首先分析题目要求的是什么。异或两个子集，得到的集合一定不为空集且这个集合的点权异或和为 $0$ 。问题转化为判断路径上点的集合是否存在一个非空子集，其点权的异或和为 $0$ 。

这让我们想起了 [**线性基**](https://oi-wiki.org/math/basis/) 。

得到了 $x,y$ 两点间路径的线性基，只需判断其中有值的数量是否等于两点间的距离即可。

~~此处开始想歪~~

线性基可以 $O(\log_2^2 v)$ 合并。要得到 $x,y$ 两点间的线性基，可以采用树链剖分的策略。

因为要支持区间修改，所以要维护差分后的序列上的线性基。在这个差分线性基中再加入一个原值，即可求出两点间路径的线性基。

时间复杂度 $O(n\log_2^4 v)$ 。实现不够优秀的话可能是 $O(n\log_2^5 v)$ 。

## Subtask#3

观察到线性基中有值的位数一定小于 $30$ 。所以，当查询时 $x,y$ 两点间的距离大于 $30$ ，直接输出 `YES` 。如果不是，暴力跳路径将每个点权插入线性基，如果无法插入则输出 `YES` 。注意特判 $0$ 的情况。

进行修改操作时，使用树链剖分。只需支持单点查询点权即可。

时间复杂度 $O(n\log_2^2 v)$ ，空间复杂度 $O(n)$ 。

## 参考代码

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=200010;
int n,q,x,y,z,v[maxn],t;
bool tf;
char op[10];
int cur,h[maxn*2],nxt[maxn*2],p[maxn*2];
void add_edge(int x,int y)
{
	cur++;
	nxt[cur]=h[x];
	h[x]=cur;
	p[cur]=y;
}
int dep[maxn],siz[maxn],fa[maxn],son[maxn];
int clk,dfn[maxn],rnk[maxn],top[maxn];
void dfs1(int x)
{
	siz[x]=1;
	for(int j=h[x];j;j=nxt[j])if(p[j]!=fa[x])
	{
		fa[p[j]]=x;
		dep[p[j]]=dep[x]+1;
		dfs1(p[j]);
		siz[x]+=siz[p[j]];
		if((!son[x])||siz[son[x]]<siz[p[j]])son[x]=p[j];
	}
}
void dfs2(int x,int t)
{
	dfn[x]=++clk;rnk[clk]=x;
	top[x]=t;
	if(son[x])dfs2(son[x],t);
	for(int j=h[x];j;j=nxt[j])if(p[j]!=fa[x]&&p[j]!=son[x])dfs2(p[j],p[j]);
}
int LCA(int x,int y)
{
    int fx=top[x],fy=top[y];
    while(fx!=fy)
    {
        if(dep[fx]>=dep[fy])x=fa[fx];
        else y=fa[fy];
        fx=top[x];fy=top[y];
    }
    if(dep[x]<=dep[y])return x;
    return y;
}
int sum[maxn];
int lowbit(int x){return x&(-x);}
void add(int x,int v){for(int i=x;i<=n;i+=lowbit(i))sum[i]^=v;}
void add(int l,int r,int v){add(l,v);add(r+1,v);}
int query(int x){int ret=0;for(int i=x;i;i-=lowbit(i))ret^=sum[i];return ret;}
void Update(int x,int y,int z)
{
    int fx=top[x],fy=top[y];
    while(fx!=fy)
    {
        if(dep[fx]>=dep[fy])add(dfn[fx],dfn[x],z),x=fa[fx];
        else add(dfn[fy],dfn[y],z),y=fa[fy];
        fx=top[x];fy=top[y];
    }
    if(dfn[x]<=dfn[y])add(dfn[x],dfn[y],z);
    else add(dfn[y],dfn[x],z);
}
struct linear_base
{
	int p[31];
	void clear(){for(int i=30;i>=0;i--)p[i]=0;}
	bool insert(int x)
	{
		if(!x)return false; 
		for(int i=30;i>=0;i--)if((x>>i)&1)
		{
			if(!p[i]){p[i]=x;return true;}
			else x^=p[i];
		}
		return false;
	}
}ans;
int main()
{
	scanf("%d%d",&n,&q);
	for(int i=1;i<=n;i++)scanf("%d",v+i);
	for(int i=1;i<n;i++)scanf("%d%d",&x,&y),add_edge(x,y),add_edge(y,x);
	dep[1]=1;dfs1(1);dfs2(1,1);
	for(int i=1;i<=n;i++)add(i,v[rnk[i-1]]^v[rnk[i]]);
	int qwq=0;
	while(q--)
	{
		scanf("%s%d%d",op,&x,&y);
		if(op[0]=='U')
		{
			scanf("%d",&z);
			Update(x,y,z);
		}
		else
		{ 
			ans.clear();
			t=LCA(x,y);
			if(dep[x]+dep[y]-dep[t]*2+1>=31){printf("YES\n");continue;}
			tf=false;
			if(!ans.insert(query(dfn[t])))tf=true;
			if(!tf)while(x!=t)
			{
				if(!ans.insert(query(dfn[x]))){tf=true;break;}
				x=fa[x];
			}
			if(!tf)while(y!=t)
			{
				if(!ans.insert(query(dfn[y]))){tf=true;break;}
				y=fa[y];
			}
			if(tf)printf("YES\n");
			else printf("NO\n");
		}
	}
	return 0;
}
```

---

## 作者：allqpsi (赞：2)

### 紫题又有异或？那我们必定要考虑线性基啦！

### 询问：
这道题询问的是是否能找到异或出来相同的数。那线性基中的数可以表示出来所有的数，那一旦有可以被表示出来的多余的数就肯定有可以异或出来相同的数啦！

那我们发现，因为 $0\leq v_{i},z <2^{30}$ 所以线性基只会存 30 个数。所以对距离大于 30 的两个点，我们直接开开心心地输出 YES 就行了。

那对小于 30 的两个点那？距离如此小，我们直接暴力枚举，暴力插入线性基就行了。

### 修改：
对修改有怎么办呢？首先树上修改，我们立马想到树链剖分。我们在用一个线段树维护此位是否有修改就行了。在查询时看此点被什么修改。

### 代码：
```cpp
#include<bits/stdc++.h> 
using namespace std;
string s;
int n,q,c,o=0,k,add[400005],t,gi[100005],in[100005],top[100005],ai[100005],LCA,di[100005],sz[100005],fa[100005][30],lg[100005],hs[100005],a,b,ans;
vector<int>vi[100005];
struct node{
	int bi[65];
	node(){
		for(int i=0;i<=30;i++){
			bi[i]=0;
		}
	}
};
node operator + (node a,int b){
	bool isit=false;
	for(int i=30;i>=0;i--){
		if(b&(1ll<<i)){
			if(a.bi[i]){
				b^=a.bi[i];
			}
			else{
				a.bi[i]=b;
				isit=true;
				break;
			}
		}
	}
	if(!isit){
		a.bi[60]=-9999;
	}
	return a;
}
void dfs(int x){
	int mx=0;
	sz[x]=1;
	di[x]=di[fa[x][0]]+1;
	for(int i=1;i<=lg[di[x]]-1;i++){
		fa[x][i]=fa[fa[x][i-1]][i-1];
	}
	for(int i=0;i<vi[x].size();i++){
		int v=vi[x][i];
		if(v==fa[x][0]){
			continue;
		}
		fa[v][0]=x;
		dfs(v);
		sz[x]+=sz[v];
		if(sz[v]>mx){
			mx=sz[v];
			hs[x]=v;
		}
	}
}
void dfs2(int x,int y){
	top[x]=y;
	in[x]=++o;
	if(hs[x]){
		dfs2(hs[x],y);
	}
	for(int i=0;i<vi[x].size();i++){
		int v=vi[x][i];
		if(v==fa[x][0]||v==hs[x]){
			continue;
		}
		dfs2(v,v);
	}
}
int lca(int x,int y){
	int ox=x,oy=y;
	if(di[x]<di[y]){
		swap(x,y);
	}
	while(di[x]>di[y]){
		x=fa[x][lg[di[x]-di[y]]-1];
	}
	if(x==y){
		return x;
	}
	for(int i=lg[di[x]]-1;i>=0;i--){
		if(fa[x][i]!=fa[y][i]){
			x=fa[x][i];
			y=fa[y][i];
		}
	}
	return fa[x][0];
}
void update(int l,int r,int rt,int x,int y,int k){
	if(x<=l&&r<=y){
		add[rt]^=k;
		return;
	}
	if(l>y||r<x){
		return;
	}
	int mid=(l+r)/2;
	update(l,mid,rt*2,x,y,k);
	update(mid+1,r,rt*2+1,x,y,k);
}
int query(int l,int r,int rt,int x){
	if(l<=x&&x<=r){
		k^=add[rt];
	}
	if(l==x&&r==x){
		return gi[l]^k;
	}
	if(!(l<=x&&x<=r)){
		return 0;
	}
	int mid=(l+r)/2;
	return query(l,mid,rt*2,x)+query(mid+1,r,rt*2+1,x);
}
void uptree(int x,int y,int k){
	while(top[x]!=top[y]){
		if(di[top[x]]<di[top[y]]){
			swap(x,y);
		}
		update(1,n,1,in[top[x]],in[x],k);
		x=fa[top[x]][0];
	}
	if(in[x]>in[y]){
		swap(x,y);
	}
	update(1,n,1,in[x],in[y],k);
}
signed main(){
	memset(sz,0,sizeof(sz));
	memset(fa,0,sizeof(fa));
	memset(di,0,sizeof(di));
	for(int i=1;i<=100000;i++){
		lg[i]=lg[i-1]+((1ll<<lg[i-1])==i);
	}
	cin>>n>>q;
	for(int i=1;i<=n;i++){
		cin>>ai[i];
	}
	for(int i=1;i<n;i++){
		cin>>a>>b;
		vi[a].push_back(b);
		vi[b].push_back(a);
	}
	di[0]=-1;
	dfs(1);
	dfs2(1,1);
	for(int i=1;i<=n;i++){
		gi[in[i]]=ai[i];
	}
	while(q--){
		cin>>s>>a>>b;
		if(s=="Query"){
			bool yep=false;
			LCA=lca(a,b);
			if(di[a]-di[LCA]+di[b]-di[LCA]>31){
				cout<<"YES"<<endl;
				continue;
			}
			node t;
			for(int i=0;i<=63;i++){
				t.bi[i]=0;
			}
			while(a!=LCA){
				k=0;
				t=t+query(1,n,1,in[a]);
				if(t.bi[60]==-9999){
					cout<<"YES"<<endl;
					yep=true;
					break;
				}
				a=fa[a][0];
			}
			if(yep)continue;
			while(b!=LCA){
				k=0;
				t=t+query(1,n,1,in[b]);
				if(t.bi[60]==-9999){
					cout<<"YES"<<endl;
					yep=true;
					break;
				}
				b=fa[b][0];
			}
			if(yep)continue;
			k=0;
			t=t+query(1,n,1,in[LCA]);
			if(t.bi[60]==-9999){
				cout<<"YES"<<endl;
				yep=true;
			}
			if(yep)continue;
			cout<<"NO"<<endl;
		}
		else{
			cin>>c;
			uptree(a,b,c);
		}
	} 
} 
```

---

## 作者：zac2010 (赞：2)

先考虑如何判定一个集合是否存在两个异或和相同的子集 $s,t$，不然解决这道题就是无稽之谈。

根据异或的优良性质，不妨在 $s,t$ 中分别去掉 $s\cap t$，之后从 $s$ 中任意移动 $|s|-1$ 个元素到 $t$ 中去，易发现此时两个集合的元素异或和还是相同。也就是说，我们现在只需要逐个判断当前元素能否被其他元素异或出来即可。

于是我们构造一个线性基，逐个插入元素，插入的时候判断一下：如果插入不成功，则说明当前元素可以被异或出来，输出 `YES`。

但在给出的集合数以及集合大小都为 $10^5$ 的情况下该如何处理？我们再尝试寻找一些性质：根据线性基的大小不超过 $\log V$，不难得出我们插入成功也必定不超过 $\log V$ 次。也就是说，如果集合大小 $>\log V$，直接输出 `YES` 即可。

再回到原问题。这是一个树上带修问题——使用树链剖分解决即可。树剖中可以不写线段树，只需要写一个区改单查的树状数组。代码细节不多，较为好写。

```cpp
#include <bits/stdc++.h>
#define FL(i, a, b) for(int i = (a); i <= (b); i++)
#define FR(i, a, b) for(int i = (a); i >= (b); i--)
using namespace std;
const int N = 1e5 + 10, W = 29;
namespace T{
	int n, tot, d[N], fa[N], sz[N], tp[N], son[N], id[N];
	vector<int> e[N];
	namespace BIT{
		int c[N];
		void Add(int x, int v){
			for(; x <= n; x += x & -x) c[x] ^= v;
		}
		int Ask(int x, int r = 0){
			for(; x; x -= x & -x) r ^= c[x]; return r;
		}
	}
	void Dfs1(int u){
		d[u] = d[fa[u]] + (sz[u] = 1);
		for(const int &v: e[u]) if(v != fa[u]){
			fa[v] = u, Dfs1(v), sz[u] += sz[v];
			if(sz[v] > sz[son[u]]) son[u] = v;
		}
	}
	void Dfs2(int u){
		id[u] = ++tot, tp[u] = (son[fa[u]] == u? tp[fa[u]] : u);
		if(son[u]) Dfs2(son[u]);
		for(const int &v: e[u])
			if(v != fa[u] && v != son[u])
				Dfs2(v);
	}
	int Lca(int x, int y){
		while(tp[x] != tp[y]){
			if(d[tp[x]] < d[tp[y]]) swap(x, y);
			x = fa[tp[x]];
		}
		return d[x] < d[y]? x : y;
	}
	void Upd(int x, int y, int z){
		while(tp[x] != tp[y]){
			if(d[tp[x]] < d[tp[y]]) swap(x, y);
			BIT::Add(id[tp[x]], z);
			BIT::Add(id[x] + 1, z), x = fa[tp[x]];
		}
		if(d[x] < d[y]) swap(x, y);
		BIT::Add(id[y], z), BIT::Add(id[x] + 1, z);
	}
	int Qry(int x){return BIT::Ask(id[x]);}
}
using namespace T;
struct LinearBasis{
	int a[W + 2];
	void init(){fill(a, a + W + 1, 0);}
	int insert(int x){
		FR(i, W, 0) if((x >> i) & 1){
			if(!a[i]){a[i] = x; return 1;}
			else x ^= a[i];
		}
		return 0;
	}
} b;
int q, a[N];
int main(){
	scanf("%d%d", &n, &q);
	char op[10]; int x, y, z, lca, u, flag;
	FL(i, 1, n) scanf("%d", &a[i]);
	FL(i, 2, n){
		scanf("%d%d", &x, &y);
		e[x].emplace_back(y), e[y].emplace_back(x);
	}
	Dfs1(1), Dfs2(1); FL(i, 1, n) Upd(i, i, a[i]);
	while(q--){
		scanf("%s%d%d", op, &x, &y);
		if(op[0] == 'U') scanf("%d", &z), Upd(x, y, z);
		else{
			lca = Lca(x, y), b.init();
			flag = (d[x] + d[y] - d[lca] - d[fa[lca]] <= 30);
			for(u = x; flag && u != lca; u = fa[u])
				if(!b.insert(Qry(u))) flag = 0;
			for(u = y; flag && u != fa[lca]; u = fa[u])
				if(!b.insert(Qry(u))) flag = 0;
			printf(flag? "NO\n" : "YES\n");
		}
	}
	return 0;
}
```


---

## 作者：Plozia (赞：2)

宣传博客 $\to$ [link](https://blog.csdn.net/BWzhuzehao/article/details/118398288)

本题做法：树链剖分 + 线性基。

没有学过树链剖分和线性基？左转[我的树链剖分学习笔记](https://blog.csdn.net/BWzhuzehao/article/details/108280459)，右转[我的线性基学习笔记](https://blog.csdn.net/BWzhuzehao/article/details/118388282)。

下面默认读者学会了树链剖分与线性基。

首先对于 Query 操作，我们需要转化一下题意：对于路径上的点而言，是否能够选出一些点，使得这些点点权异或值为 0。

这么做的理由是因为如果不存在这样的点集，那么就不会出现两个不相同的集合其异或值相同。

看到异或值询问是否有 0，这是线性基的基本操作：如果有数插入失败，这说明有点集异或结果为 0。

因为点权的值域是 $[0,2^{30})$，在这个值域范围下线性基的个数至多只有 30 个，因此对于所有路径大于 30 的询问全部都是 `YES`。

小于等于 30 的询问呢？由于点数只有 30 个，显然可以暴力查找路径上的点，加入线性基即可。

对于 Update 操作，在树剖之后直接维护线段树，Update 即可。

对于 Query 操作，上面已经详细讲过了，只不过往线性基中加数的时候需要在线段树中单点查询。

Code：[GitHub CodeBase-of-Plozia P5556 圣剑护符.cpp](https://github.com/Plozia/CodeBase-of-Plozia/blob/main/%E6%95%B0%E5%AD%A6%26%E6%95%B0%E8%AE%BA/%E7%BA%BF%E6%80%A7%E5%9F%BA/P5556%20%E5%9C%A3%E5%89%91%E6%8A%A4%E7%AC%A6.cpp)

```cpp
/*
========= Plozia =========
    Author:Plozia
    Problem:P5556 圣剑护符
    Date:2021/7/1
========= Plozia =========
*/

#include <bits/stdc++.h>
using std::string;

typedef long long LL;
const int MAXN = 1e5 + 10;
int n, m, aold[MAXN], a[MAXN], Head[MAXN], cnt_Edge = 1, Top[MAXN], Size[MAXN], Son[MAXN], id[MAXN], cnt, dep[MAXN], fa[MAXN], d[MAXN];
struct node { int to, Next; } Edge[MAXN << 1];
struct Tree
{
    int l, r, sum, Tag;
    #define l(p) tree[p].l
    #define r(p) tree[p].r
    #define s(p) tree[p].sum
    #define t(p) tree[p].Tag
}tree[MAXN << 2];

int Read()
{
    int sum = 0, fh = 1; char ch = getchar();
    for (; ch < '0' || ch > '9'; ch = getchar()) fh -= (ch == '-') << 1;
    for (; ch >= '0' && ch <= '9'; ch = getchar()) sum = sum * 10 + (ch ^ 48);
    return sum * fh;
}
int Max(int fir, int sec) { return (fir > sec) ? fir : sec; }
int Min(int fir, int sec) { return (fir < sec) ? fir : sec; }
void add_Edge(int x, int y) { ++cnt_Edge; Edge[cnt_Edge] = (node){y, Head[x]}; Head[x] = cnt_Edge; }

void Build(int p, int l, int r)
{
    l(p) = l, r(p) = r;
    if (l == r) { s(p) = a[l]; t(p) = 0; return ; }
    int mid = (l + r) >> 1;
    Build(p << 1, l, mid); Build(p << 1 | 1, mid + 1, r);
    s(p) = s(p << 1) ^ s(p << 1 | 1);
}

void Spread(int p)
{
    if (t(p))
    {
        s(p << 1) ^= t(p); s(p << 1 | 1) ^= t(p);
        t(p << 1) ^= t(p); t(p << 1 | 1) ^= t(p); t(p) = 0;
    }
}

void Change(int p, int l, int r, int k)
{
    if (l(p) >= l && r(p) <= r) { s(p) ^= k; t(p) ^= k; return ; }
    Spread(p); int mid = (l(p) + r(p)) >> 1;
    if (l <= mid) Change(p << 1, l, r, k);
    if (r > mid) Change(p << 1 | 1, l, r, k);
    s(p) = s(p << 1) ^ s(p << 1 | 1);
}

int Ask(int p, int x)
{
    if (l(p) == r(p) && l(p) == x) return s(p);
    Spread(p); int mid = (l(p) + r(p)) >> 1;
    if (x <= mid) return Ask(p << 1, x);
    else return Ask(p << 1 | 1, x);
}

void dfs1(int now, int father, int depth)
{
    dep[now] = depth, fa[now] = father, Size[now] = 1;
    for (int i = Head[now]; i; i = Edge[i].Next)
    {
        int u = Edge[i].to;
        if (u == father) continue ;
        dfs1(u, now, depth + 1);
        Size[now] += Size[u];
        if (Size[Son[now]] < Size[u]) Son[now] = u;
    }
}

void dfs2(int now, int Top_father)
{
    id[now] = ++cnt; a[cnt] = aold[now]; Top[now] = Top_father;
    if (Son[now] == 0) return ;
    dfs2(Son[now], Top_father);
    for (int i = Head[now]; i; i = Edge[i].Next)
    {
        int u = Edge[i].to;
        if (u == fa[now] || u == Son[now]) continue ;
        dfs2(u, u);
    }
}

int Add(int x)
{
    for (int i = 33; i >= 0; --i)
    {
        if (x & (1 << i))
        {
            if (d[i] & x) x ^= d[i];
            else { d[i] = x; return 0; }
        }
    }
    return 1;
}

int main()
{
    n = Read(), m = Read();
    for (int i = 1; i <= n; ++i) aold[i] = Read();
    for (int i = 1; i < n; ++i)
    {
        int x = Read(), y = Read();
        add_Edge(x, y); add_Edge(y, x);
    }
    dfs1(1, 0, 1); dfs2(1, 1); Build(1, 1, n);
    for (int i = 1; i <= m; ++i)
    {
        string str;
        std::cin >> str;
        if (str == "Update")
        {
            int x = Read(), y = Read(), z = Read();
            while (Top[x] != Top[y])
            {
                if (dep[Top[x]] < dep[Top[y]]) std::swap(x, y);
                Change(1, id[Top[x]], id[x], z); x = fa[Top[x]];
            }
            if (dep[x] > dep[y]) std::swap(x, y);
            Change(1, id[x], id[y], z);
        }
        else
        {
            int x = Read(), y = Read();
            int dis = 0, lca = 0, tx = x, ty = y;
            while (Top[x] != Top[y])
            {
                if (dep[Top[x]] < dep[Top[y]]) std::swap(x, y);
                dis += id[x] - id[Top[x]]; x = fa[Top[x]];
            }
            if (dep[x] > dep[y]) std::swap(x, y);
            dis += id[y] - id[x]; lca = x;
            if (dis > 31) { printf("YES\n"); continue ; }
            for(int j = 0; j <= 33; ++j) d[j] = 0;
            bool flag = Add(Ask(1, id[lca]));
            for (int j = tx; j != lca; j = fa[j]) flag |= Add(Ask(1, id[j]));
            for (int j = ty; j != lca; j = fa[j]) flag |= Add(Ask(1, id[j]));
            if (flag) printf("YES\n");
            else printf("NO\n");
        }
    }
    return 0;
}
```

---

## 作者：eee_hoho (赞：2)

我们发现询问如果是NO，那么$x,y$路径上的点是线性相关的，所以我们考虑每次插入路径上一个点，如果这个点无法插入，那么答案就是YES，否则就是NO。

而这样子复杂度肯定是不对的，所以我们还需要寻找一些规律。

在当前都是NO的前提下，发现最多插入$31$个数就一定能使线性基插满，再插入就一定插不进去了，所以两个点的路径长度如果大于$31$那么答案肯定是YES。

小于等于$31$的询问枚举每个点暴力插入判断就好了。

需要树剖和线段树维护区间异或和单点查询。

复杂度$O(n31logn)$

**Code**
``` cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
const int N = 1e5;
using namespace std;
int n,p[31],q,edge[N * 2 + 5],nxt[N * 2 + 5],head[N + 5],edge_cnt,dfn[N + 5],dfc,size[N + 5],son[N + 5],top[N + 5],dep[N + 5],fa[N + 5],val[N + 5],ID[N + 5];
char ch[10];
void add_edge(int u,int v)
{
    edge[++edge_cnt] = v;
    nxt[edge_cnt] = head[u];
    head[u] = edge_cnt;
}
struct Seg
{
    #define zrt k << 1
    #define yrt k << 1 | 1
    int tag[N * 4 + 5],sm[N * 4 + 5];
    void build(int k,int l,int r)
    {
        if (l == r)
        {
            sm[k] = val[ID[l]];
            return;
        }
        int mid = l + r >> 1;
        build(zrt,l,mid);
        build(yrt,mid + 1,r);
    }
    void add(int k,int l,int r,int z)
    {
        tag[k] ^= z;
        sm[k] ^= z;
    }
    void pushdown(int k,int l,int r,int mid)
    {
        if (tag[k])
        {
            add(zrt,l,mid,tag[k]);
            add(yrt,mid +1,r,tag[k]);
            tag[k] = 0;
        }
    }
    void modify(int k,int l,int r,int x,int y,int z)
    {
        if (l >= x && r <= y)
        {
            add(k,l,r,z);
            return;
        }
        int mid = l + r >> 1;
        pushdown(k,l,r,mid);
        if (x <= mid)
            modify(zrt,l,mid,x,y,z);
        if (y > mid)
            modify(yrt,mid + 1,r,x,y,z);
    }
    int query(int k,int l,int r,int x)
    {
        if (l == r)
            return sm[k];
        int mid = l + r >> 1;
        pushdown(k,l,r,mid);
        if (x <= mid)
            return query(zrt,l,mid,x);
        else
            return query(yrt,mid + 1,r,x);
    }
}tree;
void dfs1(int u,int f)
{
    fa[u] = f;
    size[u] = 1;
    dep[u] = dep[f] + 1;
    for (int i = head[u];i;i = nxt[i])
    {
        int v = edge[i];
        if (v == f)
            continue;
        dfs1(v,u);
        size[u] += size[v];
        if (size[v] > size[son[u]]) 
            son[u] = v;
    }
}
void dfs2(int u,int to)
{
    top[u] = to;
    dfn[u] = ++dfc;
    ID[dfc] = u;
    if (son[u])
        dfs2(son[u],to);
    for (int i = head[u];i;i = nxt[i])
    {
        int v = edge[i];
        if (v == son[u] || v == fa[u])
            continue;
        dfs2(v,v);
    }
}   
int lca(int x,int y)
{
    while (top[x] != top[y])
    {
        if (dep[top[x]] < dep[top[y]])
            swap(x,y);
        x = fa[top[x]];
    }
    if (dep[x] > dep[y])
        swap(x,y);
    return x;
}
int dist(int x,int y)
{
    return dep[x] + dep[y] - 2 * dep[lca(x,y)];
}
bool ins(int x)
{
    if (!x)
        return 0;
    for (int i = 30;i >= 0;i--)
        if (x >> i & 1)
        {
            if (!p[i])
            {
                p[i] = x;
                return 1;
            }
            x ^= p[i];
        }
    return 0;
}
bool query(int x,int y)
{
    memset(p,0,sizeof(p));
    while (top[x] != top[y])
    {
        if (dep[top[x]] < dep[top[y]])
            swap(x,y);
        for (int i = dfn[top[x]];i <= dfn[x];i++)
            if (!ins(tree.query(1,1,n,i)))
                return 1;
        x = fa[top[x]];
    }
    if (dfn[x] > dfn[y])
        swap(x,y);
    for (int i = dfn[x];i <= dfn[y];i++)
        if (!ins(tree.query(1,1,n,i)))
            return 1;
    return 0;
}
void modify(int x,int y,int z)
{
    while (top[x] != top[y])
    {
        if (dep[top[x]] < dep[top[y]])
            swap(x,y);
        tree.modify(1,1,n,dfn[top[x]],dfn[x],z);
        x = fa[top[x]];
    }
    if (dfn[x] > dfn[y])
        swap(x,y);
    tree.modify(1,1,n,dfn[x],dfn[y],z);
}
int main()
{
    //freopen("p5556.in","r",stdin);
    //freopen("a1.out","w",stdout);
    scanf("%d%d",&n,&q);
    int u,v;
    for (int i = 1;i <= n;i++)
        scanf("%d",&val[i]);
    for (int i = 1;i < n;i++)
    {
        scanf("%d%d",&u,&v);
        add_edge(u,v);
        add_edge(v,u);
    }
    dfs1(1,0);
    dfs2(1,1);
    tree.build(1,1,n);
    int x,y,z;
    while (q--)
    {
        scanf("%s",ch + 1);
        if (ch[1] == 'Q')
        {
            scanf("%d%d",&x,&y);
            if (dist(x,y) > 31)
                printf("YES\n");
            else
            {
                if (query(x,y))
                    printf("YES\n");
                else
                    printf("NO\n");
            }
        }
        else
        {
            scanf("%d%d%d",&x,&y,&z);
            modify(x,y,z);
        }
    }
    return 0;
}
```

---

## 作者：yanwh1 (赞：1)

# 题目大意
给你一棵树，需要完成以下两个操作：

- 将编号分别为 $x,y$ 两点间的简单路径上的点的值异或上一个值 $z$。

- 判断 $x,y$ 两点间的简单路径上的点的值的集合，是否存在两个不相等的子集（包括空集），使得两个子集的异或和相同。

# 思路解析
在看到树上路径问题时，第一个想法一定是树剖。并且看到两个操作都与异或和相关，于是我们考虑线性基：

对于询问操作，我们首先考虑暴力将路径上每一个点的值加入线性基数组，如果无法插入，那就说明我们可以通过已插入的数通过异或得到无法插入的数，那么就一定可以得到两个不相等且异或和相同的子集。

再看一眼数据范围，就能发现：$v_{i},z < 2^{30}$，所以线性基最多只能插入三十一个数，于是我们可以暴力插入。

剩下的修改操作就是基础了，直接上线段树或树状数组都行。
# 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rint register int
inline int read(){
    int f=0,t=0;
    char c=getchar();
    while(!isdigit(c)) t|=(c=='-'),c=getchar();
    while(isdigit(c)) f=(f<<3)+(f<<1)+c-48,c=getchar();
    return t?-f:f;
}
inline void write(int x) {
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar('0'+x%10);
}const int N=1e5+5;
int w[N],head[N],to[N<<1],nxt[N<<1],xxj[31],cnt,n,q;
inline void add(int u,int v){nxt[++cnt]=head[u],to[cnt]=v,head[u]=cnt;}
int f[N],son[N],dep[N],sz[N],top[N],dfn[N],qwe[N],tr[N],tot;
inline void dfs1(int u,int fa){
	f[u]=fa,dep[u]=dep[fa]+1,sz[u]=1;
	for(rint i=head[u];i;i=nxt[i]){
		int v=to[i];if(v==fa)continue;
		dfs1(v,u);sz[u]+=sz[v];
		if(sz[v]>sz[son[u]])son[u]=v;
	}
}inline void dfs2(int u,int t){
	dfn[u]=++tot,qwe[tot]=u,top[u]=t;
	if(!son[u])return;
	dfs2(son[u],t);
	for(rint i=head[u];i;i=nxt[i]){
		int v=to[i];if(v==f[u]||v==son[u])continue;
		dfs2(v,v);
	}
}inline void update(int l,int r,int x){
	for(;l<=n;l+=l&-l)tr[l]^=x;r++;
	for(;r<=n;r+=r&-r)tr[r]^=x;
}inline int query(int p){
	int ans=0;
	for(;p;p-=p&-p)ans^=tr[p];
	return ans;
}inline void update_tree(int u,int v,int x){
	while(top[u]!=top[v]){
		if(dep[top[u]]<dep[top[v]])swap(u,v);
		update(dfn[top[u]],dfn[u],x);
		u=f[top[u]];
	}if(dep[u]>dep[v])swap(u,v);
	update(dfn[u],dfn[v],x);
}inline int up(int x){
	for(rint i=30;i>=0;i--){
		if(!(x>>i))continue;
		if(!xxj[i]){
			xxj[i]=x;
			return 0;
		}x^=xxj[i];
	}return 1;
}inline int query_tree(int u,int v){
	int flag=0;
	while(u!=v){
		if(dep[u]<dep[v])swap(u,v);
		flag|=up(query(dfn[u]));u=f[u];
		if(flag==1)break;
	}flag|=up(query(dfn[u]));
	return flag;
}signed main(){
	n=read(),q=read();
	for(rint i=1;i<=n;i++)w[i]=read();
	for(rint i=1;i<n;i++){
		int u=read(),v=read();
		add(u,v),add(v,u);
	}dfs1(1,0),dfs2(1,1);
	for(rint i=1;i<=n;i++)update(i,i,w[qwe[i]]);
	while(q--){
		char c=getchar();
		while(c<'A'||c>'Z')c=getchar();
		if(c=='U'){
			int u=read(),v=read(),x=read();
			update_tree(u,v,x);
		}if(c=='Q'){
			int u=read(),v=read();
			if(query_tree(u,v))printf("YES");
			else printf("NO");
			puts("");
			for(rint i=30;i>=0;i--)xxj[i]=0;
		}
	}
	return 0;
}
```

---

## 作者：Butterfly_qwq (赞：0)

树上无力回天，可以直接剖，$O(n\log^2n\log^2v)$，显然过不去。

观察发现树上距离大于 $\log v$ 的两个点答案肯定是 `Yes`，于是直接降到 $O(n\log^2v\log^2\log v)$，理论是 $2\times 10^9$ 过不去。

那就换种方式，既然都差分了那就直接放弃无力回天的方式，按着普通差分的方式，直接变成链的子树枚举暴力做，维护区间异或和 dfs 序暴力插入，树剖直接省了，线段树里面也不用维护线性基了，线性基也不用合并了，直接 $O(n\log^2v)$ 就可以了，也不用合并。

贴个代码吧。

```
#include<bits/stdc++.h>
using namespace std;
const int N=100005;
int n,q,idx,c[30],a[N],dfn[N],lst[N],fa[N][20],dep[N],xr[N<<2];
vector<int>g[N]; 
string op;
void dfs(int u,int co)
{
	dfn[u]=lst[u]=++idx;
	fa[u][0]=co;
	dep[u]=dep[co]+1;
	for(int i=1;i<20;i++)fa[u][i]=fa[fa[u][i-1]][i-1];
	for(int v:g[u])
	{
		if(v==co)continue;
		dfs(v,u);
		lst[u]=lst[v];
	}
}
int lca(int u,int v)
{
	while(dep[u]>dep[v])u=fa[u][__lg(dep[u]-dep[v])];
	while(dep[v]>dep[u])v=fa[v][__lg(dep[v]-dep[u])];
	if(u==v)return u;
	for(int i=19;~i;i--)if(fa[u][i]!=fa[v][i])
	{
		u=fa[u][i];
		v=fa[v][i];
	}
	return fa[u][0];
}
bool insert(int x)
{
	for(int i=29;~i;i--)if(x&(1ll<<i))
	{
		if(c[i])x^=c[i];
		else
		{
			c[i]=x;
			return 1;
		}
	}
	return 0;
}
void update(int u,int l,int r,int p,int w)
{
	if(p<l||p>r)return;
	xr[u]^=w;
	if(l==r)return;
	int mid=l+r>>1;
	update(u<<1,l,mid,p,w);
	update(u<<1|1,mid+1,r,p,w);
}
int query(int u,int l,int r,int L,int R)
{
	if(r<L||l>R)return 0;
	if(L<=l&&r<=R)return xr[u];
	int mid=l+r>>1;
	return query(u<<1,l,mid,L,R)^query(u<<1|1,mid+1,r,L,R);
}
int main()
{
	#ifndef ONLINE_JUDGE
	freopen("sword.in","r",stdin);
	freopen("sword.out","w",stdout);
	#endif
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>q;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1,u,v;i<n;i++)
	{
		cin>>u>>v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	dfs(1,0);
	for(int i=1,u,v,w,f;i<=q;i++)
	{
		cin>>op>>u>>v;f=1;
		if(op=="Update")
		{
			cin>>w;
			update(1,1,n,dfn[u],w);
			update(1,1,n,dfn[v],w);
			a[lca(u,v)]^=w;
		}
		else
		{
			w=lca(u,v);
			memset(c,0,sizeof(c));
			if(dep[u]+dep[v]-2*dep[w]>29)
			{
				cout<<"YES\n";
				continue;
			}
			while(u!=w){(f&=insert(a[u]^query(1,1,n,dfn[u],lst[u])));if(!f)break;u=fa[u][0];}
			while(v!=w){(f&=insert(a[v]^query(1,1,n,dfn[v],lst[v])));if(!f)break;v=fa[v][0];}
			if(f)f&=insert(a[w]^query(1,1,n,dfn[w],lst[w]));
			cout<<(f?"NO\n":"YES\n");
		}
	}
}
```

---

## 作者：splendore (赞：0)

### 题意

给定一棵有 $n$ 个结点的树，每个结点的点权 $v_i$，操作 $q$ 次：
- 将树上 $x$，$y$ 两点之间的简单路径上的点权异或上 $z$。
- 判断在树上 $x$，$y$ 两点之间的简单路径上的点集中，是否存在两个点权异或和相等的不等子集，即判断点集是否存在一个点权异或和为 $0$ 的非空子集。

### 思路

先用树链剖分将这个树转化成一条链。

修改操作很好解决，用树状数组或线段树维护即可。

对于查询操作，判断子集是否存在可以用线性基，但暴力合并路径上的线性基的时间复杂度是 $O(n\log^2 N)$（$N$ 为值域）的，不能通过。

但是因为线性基中有值位数小于 30。所以当查询 $x$，$y$ 两点间的距离大于 30 时，子集一定存在。否则，将路径上每个点权插入线性基，若无法插入则子集存在。

因为两点间的距离小于 30，所以保证了时间复杂度。

代码如下：

```
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=100005,B=30;
struct edge{int y,pre;}a[N<<1];int alen,last[N];
inline void ins(int x,int y){a[++alen]={y,last[x]};last[x]=alen;}
int n,m,v[N],c[N],p[B+1];
int f[N],dep[N],siz[N],son[N],top[N],dfn[N],rk[N],id;
void dfs1(int x,int fa,int d){
	f[x]=fa;
	dep[x]=d;
	siz[x]=1;
	for(int k=last[x],y;k;k=a[k].pre){
		if((y=a[k].y)==fa)continue;
		dfs1(y,x,d+1);
		siz[x]+=siz[y];
		if(siz[y]>siz[son[x]])son[x]=y;
	}
}
void dfs2(int x,int t){
	top[x]=t;
	dfn[x]=++id;
	rk[id]=x;
	if(!son[x])return;
	dfs2(son[x],t);
	for(int k=last[x],y;k;k=a[k].pre)
		if((y=a[k].y)!=son[x]&&y!=f[x])
			dfs2(y,y);
}
void add(int x,int k){while(x<=n)c[x]^=k,x+=x&-x;}
void add(int x,int y,int k){add(x,k);add(y+1,k);}
int sum(int x){
	int s=0;
	while(x>=1)s^=c[x],x^=x&-x;
	return s;
}
bool ins(int x){
	for(int i=B;~i;--i)
		if(x>>i&1){
			if(!p[i])return p[i]=x,1;
			x^=p[i];
		}
	return 0;
}
void change(int x,int y,int t){
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		add(dfn[top[x]],dfn[x],t);
		x=f[top[x]];
	}
	if(dep[x]>dep[y])swap(x,y);
	add(dfn[x],dfn[y],t);
}
int getlca(int x,int y){
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		x=f[top[x]];
	}
	if(dep[x]>dep[y])swap(x,y);
	return x;
}
char s[10];
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)scanf("%d",&v[i]);
	for(int i=1,x,y;i<n;++i){
		scanf("%d%d",&x,&y);
		ins(x,y);ins(y,x);
	}
	dfs1(1,0,1);dfs2(1,1);
	for(int i=1;i<=n;++i)add(i,v[rk[i-1]]^v[rk[i]]);
	for(int i=1,x,y,c;i<=m;++i){
		scanf("%s%d%d",s,&x,&y);
		if(s[0]=='U')scanf("%d",&c),change(x,y,c);
		else{
			int lca=getlca(x,y);bool bj=0;
			memset(p,0,sizeof(p));
			if(dep[x]+dep[y]-(dep[lca]<<1)>30)bj=1;
			if(!bj)if(!ins(sum(dfn[lca])))bj=1;
			if(!bj)while(x!=lca){
				if(!ins(sum(dfn[x]))){bj=1;break;}
				x=f[x];
			}
			if(!bj)while(y!=lca){
				if(!ins(sum(dfn[y]))){bj=1;break;}
				y=f[y];
			}
			puts(bj?"YES":"NO");
		}
	}
	return 0;
}
```

~~PS：我是目前的最优解。~~

---

## 作者：fanfansann (赞：0)


**Problem** 

小L 和 小K 面前的圣剑由 $n$ 块护符组成，分别编号为 $1,2,\ldots , n$ ，有 $n-1$ 条咒力线连接两块护符，形成了一个树形结构。

经过 小L 和 小K 的长时间的研究，他们发现护符之间的相互作用并不复杂。每块护符都有一个属性值，第 $i$ 块护符的属性值记为 $v_i$  。这个值的每个二进制位上的 $0$ 或 $1$ 表示这块护符是否拥有特定属性。所有属性值中相同的二进制位对应的是相同的属性。

对于一系列护符（护符的集合），对于每种特定属性，统计其中包含这一属性的护符数量，如果为偶数，则这一系列护符形成了干涉，最终的属性值对应的二进制位上为 $0$ ，如果为奇数则干涉后剩下了一块护符的影响，对应的二进制位为 $1$ 。也就是说， **护符集合的属性值为单个护符的属性值的异或和** 。 空集的属性值定义为 $0$ 。

现在，小L想知道，如果取出两块护符 $x,y$ 间的简单路径上的所有护符，能否找到两个不相等的子集，使得两个子集的属性值相同（注意到空集也是路径上所有护符集合的子集）。同时，小K会将两块护符间的路径上的所有护符取出进行调整，将所有这些护符的属性值在某些相同二进制位上进行修改（即 $0$ 变为 $1$ ，$1$ 变为 $0$ ），可以看做是将所有这些护符的属性值异或上了一个值。

 

$1\le n,q\le 10^5,1\le x,y\le n,0\le v_i,z< 2^{30}$

**Solution**


题目比较长，简而言之就是对于任意路径，看做一个数列，我们可以从中选取两个子集，这两个子集的异或和相等，我们显然可以将这两个异或和相等的自己再次异或，得到一个异或和为 $0$ 的子集，由于路径上一定存在空集，空集异或和为 $0$ ，该异或和为 $0$ 的子集就与空集配对，输出 `YES`，也就是说题目所求是，是否存在一个非空子集，且该子集的异或和为 $0$ 。

考虑求异或和显然可以使用线性基。我们对于一条路径，我们可以求出它的线性基，就可以快速求得他们能够异或得到的值。

对于路径上的值，一个一个添加至线性基中，对于当前的值 $v_x$，若加入后出现某子集的异或和为 $0$，说明加入 $v_x$ 前的线性基可以异或线性表出 $v_x$，此时我们使用线性基 `insert`  $v_x$ 就会失败，直接输出 `YES` 即可。

考虑树上路径问题，以及路径修改问题，可以使用树链剖分 + 线段树解决，但是发现时间复杂度为 $O(n\log^5 v)$，考虑能否优化。


我们发现输入的数据 $v_i\le 2^{30}$，也就意味着线性基的维度不超过 $30$，假设一条路径上有 $num\ge30$ 个点，每次插入一个点，假设他们都线性无关，也最多能插入 $30$ 个点，超过 $30$ 个点，开始的 $30$ 个点由于线性无关组成了线性基，新加入的点一定能够被线性表出，直接输出 `YES` 即可。若前面插入的并不是全部线性无关，显然也直接输出 `YES` 即可。

因此我们只需要在路径长度小于 $30$ 的时候暴力做树链剖分，大于 $30$ 的时候直接输出 `YES` 即可。


时间复杂度 $O(n\log^2 n)$

**Code**


```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int maxn = 1e5 + 7, maxm = maxn << 1 | 7;

int n, m, s, t, ans;
int head[maxn], edge[maxm], nex[maxm], ver[maxm], tot;
int hson[maxn];
int depth[maxn];
int siz[maxn];
int fa[maxn];
int dfn[maxn], idx; 
int a_after[maxn];
int top[maxn];
int id[maxn];
bool flag;
bool vis[maxn];
int v[maxn];
int q;

struct Segment_tree
{
	struct Tree
	{
		int l, r, num, laz;
	}tr[maxn << 2];
	
	void pushdown(int p)
	{
		if(tr[p].laz) {
			tr[p << 1].laz ^= tr[p].laz;
			tr[p << 1].num ^= tr[p].laz;
			tr[p << 1 | 1].laz ^= tr[p].laz;
			tr[p << 1 | 1].num ^= tr[p].laz;
			tr[p].laz = 0;
		}
	}
	
	void modify(int p, int l, int r, int v)
	{
		if(tr[p].l > r || tr[p].r < l) return ;
		if(tr[p].l >= l && tr[p].r <= r) {
			tr[p].num ^= v;
			tr[p].laz ^= v;
			return ;
		}
		pushdown(p);
		modify(p << 1, l, r, v);
		modify(p << 1 | 1, l, r, v);
	}
	
	int query(int p, int pos)
	{
		if(tr[p].l == tr[p].r) return tr[p].num;
		pushdown(p);
		int mid = tr[p].l + tr[p].r >> 1;
		if(pos <= mid) return query(p << 1, pos);
		return query(p << 1 | 1, pos);
	}
	
	void print(int p)
	{
		if(tr[p].l == tr[p].r) printf("%d ", tr[p].num);
		else {
			pushdown(p);
			print(p << 1);
			print(p << 1 | 1);
		}
	}
	
	void build(int p, int l, int r)
	{
		tr[p].l = l, tr[p].r = r;
		tr[p].num = 0, tr[p].laz = 0;
		if(l == r) return ;
		int mid = l + r >> 1;
		build(p << 1, l, mid);
		build(p << 1 | 1, mid + 1, r);
	}
}ST;

void add(int x, int y)
{
	ver[tot] = y;
	nex[tot] = head[x];
	head[x] = tot ++ ;
}

void dfs1(int x, int father, int depths)
{
	siz[x] = 1;
	fa[x] = father;
	depth[x] = depths;
	int max_son_size = -1;
	for (int i = head[x]; ~i; i = nex[i]) {
		int y = ver[i];
		if(y == father) continue;
		dfs1(y, x, depths + 1);
		siz[x] += siz[y];
		if(siz[y] > max_son_size)
			hson[x] = y, max_son_size = siz[y];
	}
}

void dfs2(int x, int topfa)
{
	dfn[x] = ++ idx;
	id[idx] = x;
	a_after[idx] = v[x];
	top[x] = topfa;
	
	ST.modify(1, idx, idx, v[x]);
	if(hson[x] == 0) return ;
	dfs2(hson[x], topfa);
	for (int i = head[x]; ~i; i = nex[i]) {
		int y = ver[i];
		if(y == fa[x] || y == hson[x]) continue;
		dfs2(y, y);
	}
}

int get_lca(int x, int y)
{
	while(top[x] != top[y]) {
		if(depth[top[x]] > depth[top[y]])
			x = fa[top[x]];
		else y = fa[top[y]];
	}
	if(depth[x] < depth[y]) return x;
	return y;
}

struct leaner_basis 
{
	int b[31];
	void init() {
		memset(b, 0, sizeof b);
	}
	bool insert(int x) {
		for(int i = 31 - 1;i >= 0; -- i){
			if((x & (1 << i)) == 0)
				continue;
			if(b[i] == 0){
				b[i] = x;
				return true;
			}
			x ^= b[i];
		}
		return false;
	}
}B;

bool work(int lca, int x, int y)
{
	B.init();
	if(B.insert(ST.query(1, dfn[lca])) == 0)
		return true; 
	while(x != lca) 
		if(B.insert(ST.query(1, dfn[x])) == 0) 
			return true;
		else x = fa[x];
	while(y != lca) 
		if(B.insert(ST.query(1, dfn[y])) == 0) 
			return true;
		else y = fa[y];
	return false;
}

void update(int x, int y, int z)
{
	while(top[x] != top[y]) {
		if(depth[top[x]] < depth[top[y]])
			swap(x, y);
		ST.modify(1, dfn[top[x]], dfn[x], z);
		x = fa[top[x]];
	}
	if(dfn[x] > dfn[y])
		swap(x, y);
	ST.modify(1, dfn[x], dfn[y], z);
}

signed main()
{
	memset(head, -1, sizeof head);
	scanf("%lld%lld", &n, &q);
	for (int i = 1; i <= n; ++ i)
		scanf("%lld", &v[i]);
	for (int i = 1; i <= n - 1; ++ i) {
		int x, y;
		scanf("%lld%lld", &x, &y);
		add(x, y);
		add(y, x);
	}	
	ST.build(1, 1, n); 
	dfs1(1, -1, 1); 
	dfs2(1, 1);
	for (int i = 1; i <= q; ++ i) {
		string ch;
		cin >> ch;
		if(ch == "Query") {
			int x, y;
			scanf("%lld%lld", &x, &y);
			int lca = get_lca(x, y);
			int dist = depth[x] + depth[y] - 2 * depth[lca] + 1;//经过的点数
			if(dist > 30)
				puts("YES");
			else {
				if(work(lca, x, y))
					puts("YES");
				else puts("NO");
			}
		}
		else {
			int x, y, z;
			scanf("%lld%lld%lld", &x, &y, &z);
			update(x, y, z);
		}
	}
	return 0;
}
```


---

## 作者：FutaRimeWoawaSete (赞：0)

建树建错了，调了一个下午。        

拿到这道题，看这个 qry ，判有没有两个子集异或起来是不是相等，我们很自然想到线性基的插入操作，如果最后全插入进去了就是有子集的异或值相等，否则就没有。         

然后我看到这个 upd ，我直呼这不就是一个[无力回天](https://www.luogu.com.cn/problem/P5607) 上树吗？然后开开心心，一手一个差分，一手一个线段树往上面套，写到一半就发现这玩意儿有点不对，又仔细算了一下， upd 一次要 $\log^2$ ，然后一个树剖就是 $\log^3$ ……             

然后就有点尴尬，又想起来了一个很 naive 的性质，线性基的插入上限为 $O(\log_{MaxV})$ 。       

接着这道题就很简单了，对于路径上的点数大于 $\log_{MaxV}$ 的情况我们直接 YES 掉，相反，就说明当前路径的点数小于 $\log_{MaxV}$ ，我们暴力把这条路径的线性基合出来就可以了，而对于修改我们直接树剖线段树维护一下每个点的值即可。          

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
const int Len = 4e5 + 5,LOG = 30;
int sz[Len],top[Len],fa[Len],son[Len],id[Len],dep[Len],val[Len];
int a[Len],n,m,head[Len],cnt,tot,tag[Len << 2],ans[Len << 2];
struct LinearBasis
{
	int a[LOG + 5];
	LinearBasis(){memset(a , 0 , sizeof a);}
	inline bool insert(int t)
	{
		for(int i = LOG ; i >= 0 ; i --)
		{
			if(!t) return false;
			if(!(t >> i & 1)) continue;
			if(a[i]) t ^= a[i];
			else{a[i] = t ; return true;}
		}
		return false;
	}
};
struct node
{
	int next,to;
}edge[Len << 1];
void add(int from,int to){edge[++ cnt].to = to ; edge[cnt].next = head[from] ; head[from] = cnt;}
void dfs1(int x,int f)
{
	dep[x] = dep[f] + 1;
	fa[x] = f;
	sz[x] = 1;
	int maxn = -1;
	for(int e = head[x] ; e ; e = edge[e].next)
	{
		int to = edge[e].to;
		if(to == f) continue;
		dfs1(to , x);
		sz[x] += sz[to];
		if(sz[to] > maxn) maxn = sz[to] , son[x] = to;
	}
}
void dfs2(int x,int topf)
{
	id[x] = ++ tot;
	val[tot] = a[x];
	top[x] = topf;
	if(!son[x]) return;
	dfs2(son[x] , topf);
	for(int e = head[x] ; e ; e = edge[e].next)
	{
		int to = edge[e].to;
		if(to == fa[x] || to == son[x]) continue;
		dfs2(to , to);
	}
}
int ls(int x){return x << 1;};
int rs(int x){return x << 1 | 1;}
void build(int p,int l,int r)
{
	ans[p] = 0 , tag[p] = 0;
	if(l == r){ans[p] = val[l];return;}
	int mid = (l + r) >> 1;
	build(ls(p) , l , mid);
	build(rs(p) , mid + 1 , r);
}
void push_down(int p,int l,int r)
{
	if(tag[p])
	{
		int mid = (l + r) >> 1;
		if(l == mid) ans[ls(p)] ^= tag[p];
		if(mid + 1 == r) ans[rs(p)] ^= tag[p];
		else tag[ls(p)] ^= tag[p] , tag[rs(p)] ^= tag[p]; 
	}
	tag[p] = 0;
}
inline void update(int p,int l,int r,int nl,int nr,int v)
{
	if(nl <= l && nr >= r)
	{
		ans[p] ^= v;
		tag[p] ^= v;
		return;
	}
	push_down(p , l , r);
	int mid = (l + r) >> 1;
	if(nl <= mid) update(ls(p) , l , mid , nl , nr , v);
	if(nr > mid) update(rs(p) , mid + 1 , r , nl , nr , v);
}
inline int query(int p,int l,int r,int idx)
{
	if(l == r) return ans[p];
	push_down(p , l , r);
	int mid = (l + r) >> 1;
	if(idx <= mid) return query(ls(p) , l , mid , idx);
	return query(rs(p) , mid + 1 , r , idx);
}
inline void updRange(int x,int y,int v)
{
	while(top[x] != top[y])
	{
		if(dep[top[x]] < dep[top[y]]) swap(x , y);
		update(1 , 1 , n , id[top[x]] , id[x] , v);
		x = fa[top[x]];
	}
	if(id[x] > id[y]) swap(x , y);
	update(1 , 1 , n , id[x] , id[y] , v);
}
int qRange_LCA(int x,int y)
{
	while(top[x] != top[y])
	{
		if(dep[top[x]] < dep[top[y]]) swap(x , y);
		x = fa[top[x]];
	}
	if(dep[x] > dep[y]) swap(x , y);
	return x;
}
bool qry(int x,int y)
{
	int LCA = qRange_LCA(x , y);
	int num = dep[x] + dep[y] - (dep[LCA] << 1) + 1;
	if(num > 31) return false;
	LinearBasis Calc;
	while(x != LCA){if(!Calc.insert(query(1 , 1 , n , id[x]))) return false;x = fa[x];}
	while(y != LCA){if(!Calc.insert(query(1 , 1 , n , id[y]))) return false;y = fa[y];}
	return Calc.insert(query(1 , 1 , n , id[LCA]));
}
char s[10];
signed main()
{
	scanf("%d %d",&n,&m);
	for(int i = 1 ; i <= n ; i ++) scanf("%d",&a[i]);
	for(int i = 1 ; i < n ; i ++)
	{
		int x,y;scanf("%d %d",&x,&y);
		add(x , y) , add(y , x);
	}
	dfs1(1 , 0);
	dfs2(1 , 1);
	build(1 , 1 , n);
	for(int i = 1 ; i <= m ; i ++)
	{
		scanf("%s",s);int x,y;scanf("%d %d",&x,&y);
		if(s[0] == 'U') 
		{
			int z;scanf("%d",&z);
			updRange(x , y , z);
		}
		else {(qry(x , y)) ? puts("NO") : puts("YES");}
	}
	return 0;
}
```

---

## 作者：JK_LOVER (赞：0)

## 题意
节点个数为 $n$ 的树， $m$ 次操作。

- 查询 $x,y$ 中是否可以保证每个元素只有唯一异或方案。
- 改变 $x,y$ 路径上的所有元素。
## 分析
### 第一问
发现第一问就是构造一个线型基，至于为什么可以参见 [这里](https://www.luogu.com.cn/blog/xzc/xian-xing-ji) ，或者其他题解。因为保证 $w_i < 2^{30}$ ，因为线性基要满足:线性基的二进制最高位互不相同。所以对应的线性基的大小长度为 $30$ 。也说明如果有 $31$ 个元素一定是可以被构造出来的。
$$
ans = YES (sum \ge 31) 
$$
考虑 $sum \le 30$ 的情况。就直接构造线性基。暴力判断了。
### 第二问
一个树上问题，考虑用 $Link -Cut-Tree$ 维护。其目的：
- 一：复杂度为 $O(n\log n)$
- 二：不必再求 $LCA$ 了，因为实链剖分，在 $makeroot(x),access(y),splay(y)$ 之后可以确保 $x$ 是原树的根，而路径也只有 $x->y$ 的。可以直接 $dfs$ 了。
- 三：对于 $sum$ 可以一步到位 （树链剖分也可以）
## 代码
总复杂度为 $O(n \log n \times \log {w_{max}})$  。 

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5+100;
const int inf = 2e5+10;
int c[N][2],f[N],n,m,val[N],sum[N],lazy[N];
bool r[N];
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x;
}
inline void write(int x)
{
	if(x>9)write(x/10);
    putchar(x%10+'0');
}
void pushr(int x)
{
	swap(c[x][1],c[x][0]);
	r[x] ^= 1;
}
void pushlazy(int x,int Val)
{
	val[x] = val[x]^Val;
	lazy[x] = lazy[x]^Val;
}
void pushdown(int x)
{
	if(r[x])
	{
		if(c[x][1]) pushr(c[x][1]);
		if(c[x][0]) pushr(c[x][0]);
		r[x] = 0;
	}		
	if(lazy[x])
	{
		if(c[x][1]) pushlazy(c[x][1],lazy[x]);
		if(c[x][0]) pushlazy(c[x][0],lazy[x]);
		lazy[x] = 0;
	}
}
void pushup(int x)
{
	sum[x] = 1;
	sum[x] += sum[c[x][1]] + sum[c[x][0]]; 
}
bool nroot(int x)
{
	return c[f[x]][0] == x || c[f[x]][1] == x; 
}
void rotate(int x)
{
	int y = f[x],z = f[y],k = c[y][1] == x,w = c[x][!k];
	if(nroot(y)) c[z][c[z][1] == y] = x;
	c[x][!k] = y;c[y][k] = w;
	f[w] = y;f[y] = x;f[x] = z;
	pushup(y);
}
void push(int x)
{
	if(nroot(x)) push(f[x]);
	pushdown(x);
}
void splay(int x)
{
	push(x);
	while(nroot(x))
	{
		int y = f[x],z = f[y];
		if(nroot(y))
		{
			rotate((c[y][1]==x)^(c[z][1]==y)?x:y);
		}
		rotate(x);
		pushup(x);
	}
}
void access(int x)
{
	for(int y = 0;x;x = f[y=x])
	splay(x),c[x][1] = y,pushup(x);
}
void makeroot(int x)
{
	access(x);splay(x);pushr(x);
}
void link(int x,int y)
{
	makeroot(x);
	f[x] = y;
}
int p[32];
bool solve(int u)
{
//	cout<<"debug "<<u<<endl;
	for(int i = 30;i >= 0;i--)
	{
		if(u&(1<<i))
		{
			if(!p[i])
			{
				p[i] = u;
				return 0;
			}
			u ^= p[i];
		}
	}
	return 1;
}
bool dfs(int x)
{
	pushdown(x);
	if(solve(val[x])) {return 1;}
	bool tot = 0;
//	cout<<"debug "<<c[x][1]<<" "<<c[x][0]<<endl;
	if(c[x][1]) tot |= dfs(c[x][1]);
	if(c[x][0]) tot |= dfs(c[x][0]);
	return tot;
}
signed main()
{
	n = read();m = read();
	for(int i = 1;i <= n;i++) val[i] = read();
	for(int i = 1;i < n;i++)
	{
		int a = read(),b = read();
		link(a,b);
	}
	for(int i = 1;i <= m;i++)
	{
		char ch[10];
		scanf("%s",ch);
		if(ch[0] == 'Q')
		{
			int x = read(),y = read();
			makeroot(x);
			access(y);
			splay(y);
			if(sum[y] > 30)
			{
				printf("YES\n");
				continue;
			}
			memset(p,0,sizeof(p));
			if(dfs(y))
			{
				printf("YES\n");
			}
			else printf("NO\n");
		}
		if(ch[0] == 'U')
		{
			int x = read(),y = read(),z = read();
			makeroot(x);
			access(y);
			splay(y);
			pushlazy(y,z);
		}
//		for(int i = 1;i <= n;i++)
//		{
//			cout<<"debug "<<val[i]<<endl; 
//		}
//		cout<<endl;
	}
}
```
### 6.15 修改了代码的小错误。

[欢迎来踩](https://www.luogu.com.cn/blog/xzc/solution-p5556)

---

## 作者：_soul_ (赞：0)

做这道题首先需要想到这么一个结论不然就完蛋了emmmmm

就是给你一个序列长度大于等于30 那么任取一个该序列的子序列，所有子序列的xor和必然有两个是重复的，证明可以通过线性基，插入了30个数之后，如果前30个全部成功插入，那么最后一个必然无法成功插入，其实也就代表之前的数能够表示当前的xor和。

所以两点之间距离大于30，直接为yes
否则就将路径上的所有点权一个个插入一个空的线性基，如果有任何一个元素无法插进，则输出yes，否则输出no

第二点考虑到他是子树修改，所以用树剖维护点权，这里树剖用线段树或者差分树状数组都可以。
```cpp
#include<bits/stdc++.h>
#define MAX_N 100010
using namespace std;
int n,q,w[MAX_N];
inline int read()
{
	int x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')
		ch=getchar();
	while(ch>='0'&&ch<='9')
		x=x*10+ch-'0',ch=getchar();
	return x;
}
struct edge
{
	int v,next;
}e[MAX_N<<1];
int p[MAX_N],eid;
inline void insert(int u,int v)
{
	e[++eid]={v,p[u]};
	p[u]=eid;
}
int idx,c[MAX_N],d[MAX_N],dep[MAX_N],size[MAX_N],son[MAX_N],top[MAX_N],fa[MAX_N];
void dfs1(int u,int f)
{
	fa[u]=f;
	size[u]=1;
	dep[u]=dep[f]+1;
	for(register int i=p[u];i;i=e[i].next)
	{
		int v=e[i].v;
		if(v==f)continue;
		dfs1(v,u);
		size[u]+=size[v];
		if(size[son[u]]<size[v])son[u]=v;
	}
}
void dfs2(int u,int f)
{
	c[u]=++idx,d[idx]=u,top[u]=f;
	if(son[u])dfs2(son[u],f);
	for(register int i=p[u];i;i=e[i].next)
	{
		int v=e[i].v;
		if(fa[u]==v||son[u]==v)continue;
		dfs2(v,v);
	}
}
namespace SEG
{
	int tag[MAX_N<<2];
	void build(int p,int l,int r)
	{
		if(l==r)
		{
			tag[p]=w[d[l]];
			return;
		}
		int mid=(l+r)>>1;
		build(p<<1,l,mid);
		build(p<<1|1,mid+1,r);
	}
	void change(int p,int l,int r,int x,int y,int w)
	{
		if(l>=x&&r<=y)
		{
			tag[p]^=w;
			return;
		}
		int mid=(l+r)>>1;
		if(x<=mid)change(p<<1,l,mid,x,y,w);
		if(y>mid)change(p<<1|1,mid+1,r,x,y,w);
	}
	int query(int p,int l,int r,int x)
	{
		if(l==r)
			return tag[p];
		int mid=(l+r)>>1;
		if(x<=mid)return tag[p]^query(p<<1,l,mid,x);
		else return tag[p]^query(p<<1|1,mid+1,r,x);
	}
}
inline void change(int u,int v,int w)
{
	while(top[u]!=top[v])
	{
		if(dep[top[u]]<dep[top[v]])swap(u,v);
		SEG::change(1,1,n,c[top[u]],c[u],w);
		u=fa[top[u]];
	}
	if(dep[u]<dep[v])swap(u,v);
	SEG::change(1,1,n,c[v],c[u],w);
}
inline int dist(int u,int v)
{
	int ans=0;
	while(top[u]!=top[v])
	{
		if(dep[top[u]]<dep[top[v]])swap(u,v);
		ans+=dep[u]-dep[top[u]]+1;
		u=fa[top[u]];
	}
	ans+=abs(dep[v]-dep[u]);
	return ans;
}
namespace LB
{
	int a[32];
	inline void init()
	{
		memset(a,0,sizeof a);
	}
	inline bool insert(int x)
	{
		for(register int i=30;i>=0;--i)
			if(x&(1<<i))
			{
				if(a[i])
					x^=a[i];
				else
				{
					a[i]=x;
					return 1;
				}
			}
		return 0;
	}
}
inline bool check(int u,int v)
{
	if(dist(u,v)>30)return 1;
	LB::init();
	if(dep[u]<dep[v])swap(u,v);
	while(dep[u]>dep[v])
	{
		if(LB::insert(SEG::query(1,1,n,c[u]))==0)return 1;
		u=fa[u];
	}
	while(u!=v)
	{
		if(LB::insert(SEG::query(1,1,n,c[u]))==0)return 1;
		if(LB::insert(SEG::query(1,1,n,c[v]))==0)return 1;
		u=fa[u],v=fa[v];
	}
	if(LB::insert(SEG::query(1,1,n,c[u]))==0)return 1;
	return 0;
}
inline void init()
{
	dfs1(1,1);
	dfs2(1,1);
	SEG::build(1,1,n);
}
int main()
{
    n=read(),q=read();
    for(register int i=1;i<=n;++i)w[i]=read();
	for(register int i=1,u,v;i<n;++i)u=read(),v=read(),insert(u,v),insert(v,u);
	init();
	while(q--)
	{
		char op[10];
		int x,y,z;
		scanf("%s",op);
		if(op[0]=='U')
		{
			x=read(),y=read(),z=read();
			change(x,y,z);
		}
		else
		{
			x=read(),y=read();
			if(check(x,y))putchar('Y'),putchar('E'),putchar('S'),putchar('\n');
			else putchar('N'),putchar('O'),putchar('\n');
		}
	}
	return 0;
}
```


---


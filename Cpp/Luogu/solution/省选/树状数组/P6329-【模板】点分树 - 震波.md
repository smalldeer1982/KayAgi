# 【模板】点分树 | 震波

## 题目背景

模板题，没有 $rap$ 。

## 题目描述

在一片土地上有 $n$ 个城市，通过 $n-1$ 条无向边互相连接，形成一棵树的结构，相邻两个城市的距离为 $1$，其中第 $i$ 个城市的价值为 $value_i$。

不幸的是，这片土地常常发生地震，并且随着时代的发展，城市的价值也往往会发生变动。

接下来你需要在线处理 $m$ 次操作：

`0 x k` 表示发生了一次地震，震中城市为 $x$，影响范围为 $k$，所有与 $x$ 距离不超过 $k$ 的城市都将受到影响，该次地震造成的经济损失为所有受影响城市的价值和。

`1 x y` 表示第 $x$ 个城市的价值变成了 $y$ 。

为了体现程序的在线性，操作中的 $x$、$y$、$k$ 都需要异或你程序上一次的输出来解密，如果之前没有输出，则默认上一次的输出为 $0$ 。



## 说明/提示

#### 数据规模与约定

对于 $100 \%$ 的数据，有 $1\leq n,m\leq 10^5, 1\leq u,v,x\leq n, 1\leq value_i,y\leq 10^4,0\leq k\leq n-1$ 。

upd：样例范围与题目真实数据范围不同，以提示中给出的数据范围为准。

#### 说明
题目来源：BZOJ3730。

## 样例 #1

### 输入

```
8 1
1 10 100 1000 10000 100000 1000000 10000000
1 2
1 3
2 4
2 5
3 6
3 7
3 8
0 3 1```

### 输出

```
11100101```

# 题解

## 作者：tzc_wk (赞：183)

首先我们知道，单次询问，树上路径的问题可以用点分治解决。

但如果加上什么 $q$ 次询问之类的东西怎么办呢？比如说这题。

显然每次都跑一遍点分治时间复杂度肯定吃不消。

考虑把点分治的过程离线下来，将当前树的重心与上一层的树的重心连边，这样就可以得到一棵树，我们称之为“点分树”

比如说我们有如下图所示的树：

![](https://cdn.luogu.com.cn/upload/image_hosting/bd6910x4.png)

建出点分树来如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/ay94t1ai.png)

很明显，我们建出的点分树与原树**几乎没有联系**，父子关系完全被打乱了，也无法通过两点在点分树上的距离算出它们在原树上的距离。甚至有可能某两点在点分树上是父子关系，在原树上相隔十万八千里，或者某两点在原树上是父子关系，在点分树上相隔十万八千里（当然只是相对来说）。

那么这棵树对于我们做题有什么帮助呢？

有的问题我们不是非常关心树的**形态特点**，比如**路径问题，联通块问题，寻找关键点问题**等等，以路径问题为例，我们不一定非得查到 $p,q$ 的 LCA 才可以处理 $p,q$ 的路径信息，相反，我们可以随便从这个路径上寻找一个分割点 $t$，只要我们可以快速的处理 $p$ 到 $t$ 和 $q$ 到 $t$ 的信息，我们就可以处理 $p$ 到 $q$ 的信息。

而点分树恰恰就是对原树做了这样的映射。

它有以下性质：

1. 它的高度与**点分治的深度**一样，只有 $\log n$ 级别，这个性质很关键，由于它的高度只有 $\log n$，所以我们可以搞出各种各样在一般树论里过不去的暴力做法，比如说对每个点开个包含子树中所有点的 vector，空间复杂度也只有。
2. 对于任意两点 $u,v$，**唯一**可以确定的是 $u,v$ 在点分树上的 LCA **一定在 $u\to v$ 的路径上**。换句话说，$dis(u,v)=dis(u,lca)+dis(lca,v)$。

回到这题来，我们要求 $\sum\limits_{dis(x,y)\leq k}a_y$。

考虑枚举 $x,y$ 在点分树上的 LCA $z$（这显然是 $\log n$ 级别的），根据上面的推论有 $dis(x,y)=dis(x,z)+dis(y,z)$。

故 $ans=\sum\limits_{dis(x,z)+dis(z,y)\leq k\& LCA(x,y)=z}a_y=\sum\limits_{dis(z,y)\leq k-dis(x,z)\&LCA(x,y)=z}a_y$

考虑什么样的 $y$ 满足 $LCA(x,y)=z$，显然符合要求 $y$ 组成的集合就是 $z$ 的子树**抠掉** $z$ 在 $x$ 方向上的儿子 $s$ 的子树。而我们要求这个点集中**到 $z$ 的距离 $\leq k-dis(x,z)$** 的点权和。显然可以拿 $z$ 的子树内到 $z$ 的距离 $\leq k-dis(x,z)$ 的点权和 $-$ $s$ 子树中到 $z$ 的距离 $\leq k-dis(x,z)$ 的点权和。

对每个点 $x$ 建一棵动态开点线段树，下标为 $i$ 的位置维护 $x$ 子树内所有 $dis(x,z)=i$ 的 $a_z$ 的和。

那么求 $z$ 子树内到 $z$ 的距离 $\leq k-dis(x,z)$ 的点权和就在对应线段树上查个区间和就 ok 了。

那 $z$ 在 $x$ 方向上的儿子 $s$ 的子树怎么办呢？

初学点分树的萌新（例如我）很容易进入一个误区，那就是这东西可以在 $s$ 对应的线段树上查 $[0,k-dis(x,z)-1]$ 的和。但这显然是错的，因为两点在点分树上的距离与两点在原树上的距离没有一丁点联系。到 $s$ 距离 $\leq k-dis(x,z)-1$，并不意味着到 $z$ 距离 $\leq k-dis(x,z)$。

那么正解是什么呢？考虑对于每个点再建立一棵动态开点线段树，线段树上下标为 $i$ 的位置维护 $x$ 子树内到 $fa_x$ 距离 $=i$ 的点权和。解决 $z$ 在 $x$ 方向上的儿子 $s$ 的子树的问题只需在点 $s$ 的线段树上查询 $[0,k-dis(x,z)]$ 的和就行了。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define fi first
#define se second
#define fz(i,a,b) for(int i=a;i<=b;i++)
#define fd(i,a,b) for(int i=a;i>=b;i--)
#define ffe(it,v) for(__typeof(v.begin()) it=v.begin();it!=v.end();it++)
#define fill0(a) memset(a,0,sizeof(a))
#define fill1(a) memset(a,-1,sizeof(a))
#define fillbig(a) memset(a,63,sizeof(a))
#define pb push_back
#define ppb pop_back
#define mp make_pair
template<typename T1,typename T2> void chkmin(T1 &x,T2 y){if(x>y) x=y;}
template<typename T1,typename T2> void chkmax(T1 &x,T2 y){if(x<y) x=y;}
typedef pair<int,int> pii;
typedef long long ll;
template<typename T> void read(T &x){
	x=0;char c=getchar();T neg=1;
	while(!isdigit(c)){if(c=='-') neg=-1;c=getchar();}
	while(isdigit(c)) x=x*10+c-'0',c=getchar();
	x*=neg;
}
const int MAXN=1e5;
const int MAXP=5e6;
const int LOG_N=17;
const int INF=1e9;
int n,qu,a[MAXN+5];
int hd[MAXN+5],to[MAXN*2+5],nxt[MAXN*2+5],ec=0;
void adde(int u,int v){to[++ec]=v;nxt[ec]=hd[u];hd[u]=ec;}
int fa[MAXN+5][LOG_N+2],dep[MAXN+5];
void dfs0(int x,int f){
	fa[x][0]=f;
	for(int e=hd[x];e;e=nxt[e]){
		int y=to[e];if(y==f) continue;
		dep[y]=dep[x]+1;dfs0(y,x);
	}
}
int getlca(int x,int y){
	if(dep[x]<dep[y]) swap(x,y);
	for(int i=LOG_N;~i;i--) if(dep[x]-(1<<i)>=dep[y]) x=fa[x][i];
	if(x==y) return x;
	for(int i=LOG_N;~i;i--) if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];
	return fa[x][0];
}
int getdis(int x,int y){return dep[x]+dep[y]-(dep[getlca(x,y)]<<1);}
int siz[MAXN+5],mx[MAXN+5],cent=0;
bool vis[MAXN+5];
void findcent(int x,int f,int tot){
	siz[x]=1;mx[x]=0;
	for(int e=hd[x];e;e=nxt[e]){
		int y=to[e];if(y==f||vis[y]) continue;
		findcent(y,x,tot);chkmax(mx[x],siz[y]);siz[x]+=siz[y];
	} chkmax(mx[x],tot-siz[x]);
	if(mx[x]<mx[cent]) cent=x;
}
int dfa[MAXN+5];
void divcent(int x,int tot){
//	printf("%d\n",x);
	vis[x]=1;
	for(int e=hd[x];e;e=nxt[e]){
		int y=to[e];if(vis[y]) continue;
		cent=0;int sz=(siz[y]<siz[x])?siz[x]:(tot-siz[x]);
		findcent(y,x,sz);dfa[cent]=x;divcent(cent,sz);
	}
}
struct segtree{
	int rt[MAXN+5],ncnt=0;
	struct node{int ch[2],val;} s[MAXP+5];
	void modify(int &k,int l,int r,int p,int x){
		if(!k) k=++ncnt;
		if(l==r){s[k].val+=x;return;}
		int mid=(l+r)>>1;
		if(p<=mid) modify(s[k].ch[0],l,mid,p,x);
		else modify(s[k].ch[1],mid+1,r,p,x);
		s[k].val=s[s[k].ch[0]].val+s[s[k].ch[1]].val;
	}
	int query(int k,int l,int r,int ql,int qr){
		if(!k) return 0;
		if(ql<=l&&r<=qr) return s[k].val;
		int mid=(l+r)>>1;
		if(qr<=mid) return query(s[k].ch[0],l,mid,ql,qr);
		else if(ql>mid) return query(s[k].ch[1],mid+1,r,ql,qr);
		else return query(s[k].ch[0],l,mid,ql,mid)+query(s[k].ch[1],mid+1,r,mid+1,qr);
	}
} w1,w2;
void modify(int x,int v){
	int cur=x;
	while(cur){
		w1.modify(w1.rt[cur],0,n-1,getdis(cur,x),v);
		if(dfa[cur]) w2.modify(w2.rt[cur],0,n-1,getdis(dfa[cur],x),v);
		cur=dfa[cur];
	}
}
int query(int x,int k){
	int cur=x,pre=0,ret=0;
	while(cur){
		if(getdis(cur,x)>k){
			pre=cur;cur=dfa[cur];continue;
		}
		ret+=w1.query(w1.rt[cur],0,n-1,0,k-getdis(cur,x));
		if(pre) ret-=w2.query(w2.rt[pre],0,n-1,0,k-getdis(cur,x));
		pre=cur;cur=dfa[cur];
	} return ret;
}
int main(){
	scanf("%d%d",&n,&qu);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<n;i++){int u,v;scanf("%d%d",&u,&v);adde(u,v);adde(v,u);}
	dfs0(1,0);for(int i=1;i<=LOG_N;i++) for(int j=1;j<=n;j++)
		fa[j][i]=fa[fa[j][i-1]][i-1];
	mx[0]=INF;cent=0;findcent(1,0,n);divcent(cent,n);
//	for(int i=1;i<=n;i++) printf("%d\n",dfa[i]);
	for(int i=1;i<=n;i++) modify(i,a[i]);
	int preans=0;
	while(qu--){
		int opt,x,y;scanf("%d%d%d",&opt,&x,&y);
		x^=preans;y^=preans;
		if(opt==0){preans=query(x,y);printf("%d\n",preans);}
		else{modify(x,y-a[x]);a[x]=y;}
	}
	return 0;
}
```

---

## 作者：Ayiirep (赞：119)

**upd**：代码添加了注释

**upd**：有同学提到 $\texttt{vector}$ 的 resize 问题，emmm文章里说的是开 $\texttt{vector}$ 的大小应该是 子树大小 $+1$，但是这里要实现树状数组，所以下标从 $1$ 开始，还要多开一位，所以应该是 `resize(子树大小+2)`，代码略有修改（主要是 $\texttt{vector}$ 大小的修改）。

> 写篇题解纪念一下这道自己调了好久的题...  

### 写在前面
由于太菜，花了很久才弄懂。也希望能够以此文帮助更多想要学习点分树的同学。如有问题，请在评论区指出。
### 关于点分治
首先，要学习点分树，首先要理解点分治的过程。 

按照我的理解，点分治的过程在于：先处理当前树的答案，再选择当前树的重心，把它删掉，然后递归地处理剩下的子树。  

这样做可以做到比较优秀的复杂度。   

### 关于点分树
点分树可以看做是将整个点分治过程记录下来，将当前树的重心与上一层的树的重心连边（后者视作前者的父亲），这样就可以得到一个形态比较优秀的重构树，可以以比较优秀的复杂度解决不考虑树的形态的一类问题。  

### 回到题目
这道题要我们动态维护对于某个点距离小于 $k$ 的点的权值和，这就是上述的典型的**与树的形态无关的一类题目**。

考虑一种暴力，每次询问都用点分治暴力求解，那么我们每次都找到重心统计答案即可。  

可以发现，对于多次这样的询问，都进行了找重心的操作，但这是完全重复的，所以我们只用把对于每个重心的答案记录下来并查询即可。

我们具体地来看一看这个查询操作。

在点分治的过程中，我们会有一个数组 $C$ 来记录对于这个点其子树内的点到它的每个距离对应的答案。

这是原树，每条边边权为 $1$ 。

![](https://cdn.luogu.com.cn/upload/image_hosting/t7ktdfk8.png)

这是一种重构树。（其实也有一种重构树和原树的形态完全一致，但为了以示区别，我用了这个）

![](https://cdn.luogu.com.cn/upload/image_hosting/jeiwmvjh.png)

那么考虑当 $x=4$ ， $y=2$ 时，通过原图我们可以发现，其实就是查询节点 $1$ 、 $3$ 的权值和。

那我们再看看在重构树上怎么做。

从节点 $4$ 出发，查询距离 $≤2$ 的答案。  


回忆一下点分治的做法，从整棵树的重心一步步地分治到当前节点。也就是说，从现在重构树的节点一直统计到当前节点。

这个是很好做的，我们只需要记录重构树的父子关系，计算当前节点答案需要经过的点即为重构树根节点到当前节点路径上的所有点。

那么我们再来考虑如何统计答案。

上面说到，要提出当前节点到重构树根节点的路径上的点，实际上就是从当前节点一直跳父亲，跳到根为止。

最开始在 $x$ 的时候，直接将 $x$ 子树的节点对 $x$ 的贡献加入答案即可。再考虑在往上爬的过程中（设当前节点为 $u$ ，与 $x$ 的距离为 $dis$ ），我们需要计算的是**在 $u$ 子树内但不在 $x$ 子树内的节点对 $x$ 的贡献**，也就是在 $u$ 子树但不在 $x$ 子树的节点中与 $x$ 的距离 $≤y-dis$ 的节点的权值和。那么容斥一下可以得到，我们要求的就是与 $u$ 子树内 $u$ 距离 $≤y-dis$ 的节点权值和减去 $x$ 子树内与 $u$ 距离 $≤y-dis$ 的权值和。

容易发现，如果我们记 $W_{i,j}$ 为 $i$ 子树内与 $i$ 的距离为 $j$ 的节点权值和，那么我们每次询问的都是 $W_i$ 的前缀和，那么我们就可以用树状数组来维护这些信息了。

注意上面要用到的信息有两个：
1. $i$ 子树内节点对 $i$ 的贡献。
2. $i$ 节点子树内节点对其 $i$ 父亲的贡献。  

我们分别用 $C_{0,i},C_{1,i}$ 表示这两个树状数组。

那么每次查询的时候只需要按照上述步骤完成即可，每次询问复杂度是 $O(\log^2n)$ 的。注意由于 $n$ 很大，直接暴力开数组存不下，可以用 $\texttt{vector}$ 来存，大小为 $i$ 的子树大小 $+1$ （由于距离可能为 $0$ ，需要将树状数组整体右移，如 $C_{0,i,j}$ 其实表示的是 $i$ 子树内与 $i$ 距离为 $j-1$ 的节点对 $i$ 的贡献）。

对于修改操作，那么我们只需要按照上述规则，修改 $C_{0,i},C_{1,i}$ 即可，每次修改复杂度也是 $O(\log^2n)$ 。

于是就可以愉快地通过这道题了。

```cpp
#include <bits/stdc++.h>
#define REP(u) for(int i = H[u], v; i, v = E[i].v; i = E[i].n)
using namespace std;
const int maxn = 2e5 + 111, inf = 1e9 + 7;
int N, M, tot, ans, rt, sum, minn, cnt;
int val[maxn], H[maxn], sz[maxn], fa[maxn], dep[maxn], pos[maxn], ol[maxn<<1][21], lg[maxn<<1];
//val表示该城市的价值，sz表示该点子树的大小，fa表示该点点分树上的父亲节点，dep表示该点的深度 
bool vis[maxn];
vector<int>C[2][maxn];
//C[0][i]表示i子树内节点对i的贡献
//C[1][i]表示i子树内节点对i父亲的贡献 
struct edge {
	int n, v;
}E[maxn<<1];
void add(int u, int v)
{
	E[++tot] = (edge) {H[u], v};
	H[u] = tot;
}
void dfs0(int u, int f)
{
	ol[++cnt][0] = u, pos[u] = cnt;
	REP(u) if(v ^ f) dep[v] = dep[u] + 1, dfs0(v, u), ol[++cnt][0] = u;
}
int get_min(int a, int b)
{
	return dep[a] < dep[b] ? a : b;
}
void get_ol() 
{
	for(int i = 1; i <= cnt; ++i) lg[i] = 31 - __builtin_clz(i);
	for(int t = 1; 1 << t <= cnt; ++t)
		for(int i = 1; i + (1 <<t) <= cnt; ++i)
			ol[i][t] = get_min(ol[i][t - 1], ol[i + (1 << (t - 1))][t - 1]);
}
int get_dis(int u, int v)
{
	if(pos[u] > pos[v]) swap(u, v);
	int uu = pos[u], vv = pos[v], len = vv - uu + 1;
	int lca = get_min(ol[uu][lg[len]], ol[vv - (1 << lg[len]) + 1][lg[len]]);
	return dep[u] + dep[v] - 2 * dep[lca];
}
#define lowbit(x) (x & -x)
void upd(int u, int opt, int x, int addv)
{
	x++;
	for(int i = x; i <= sz[u]; i += lowbit(i)) C[opt][u][i] += addv;
}
int qry(int u, int opt, int x)
{
	x++;
	int res = 0;
	x = min(x, sz[u]);
	for(int i = x; i; i -= lowbit(i)) res += C[opt][u][i];
	return res;
}
void find_rt(int u, int f) //找重心 
{
	sz[u] = 1;
	int res = 0;
	REP(u) if(f ^ v && !vis[v]) find_rt(v, u), sz[u] += sz[v], res = max(res, sz[v]);
	res = max(res, sum - sz[u]);
	if(res < minn) minn = res, rt = u; 
}
void dfs(int u) //建立点分树 
{
	vis[u] = 1;
	sz[u] = sum+1;
	C[0][u].resize(sz[u]+1);
	C[1][u].resize(sz[u]+1);
	REP(u) if(!vis[v]) 
	{
		sum = sz[v], rt = 0, minn = inf;
		find_rt(v, 0);
		fa[rt] = u;
		dfs(rt);
	}
}
void modify(int u, int w)
{
	for(int i = u; i; i = fa[i]) upd(i, 0, get_dis(u, i), w); 
	for(int i = u; fa[i]; i = fa[i]) upd(i, 1, get_dis(u, fa[i]), w);	
}
int main()
{
	int opt, x, y;
	scanf("%d%d", &N, &M);
	for(int i = 1; i <= N; ++i) scanf("%d", &val[i]);
	for(int i = 1; i <  N; ++i) scanf("%d%d", &x, &y), add(x, y), add(y, x);
	dfs0(1, 0);
	get_ol();
	sum = N, minn = inf;
	find_rt(1, 0);
	dfs(rt);
	for(int i = 1; i <= N; ++i) modify(i, val[i]); 
	while(M--)
	{
		scanf("%d%d%d", &opt, &x, &y);
		x ^= ans, y ^= ans; 
		if(!opt) 
		{
			ans = 0;
			ans += qry(x, 0, y); //x子树内到其距离为y的点对x的贡献 
			for(int i = x; fa[i]; i = fa[i])
			{
				int dis = get_dis(x, fa[i]);  
				if(y >= dis) ans += qry(fa[i], 0, y - dis) - qry(i, 1, y - dis); //x子树外到其距离为y的点 
				//fa[i]子树中除x所在子树对x的贡献 即为 fa[i]子树对它的总贡献 减去 x所在子树对fa[i]的贡献 
			}
			printf("%d\n", ans);
		}
		else modify(x, y - val[x]), val[x] = y; //利用差分的办法修改其对点分树上祖先的贡献 
	}
	return 0;
}
```

---

## 作者：Ireliaღ (赞：68)

## 前置知识

- 点分治（至少写过几道模板，知道原理）

## 算法原理

点分树是以点分治为基础的，把原树“化实为虚”的构造。我们在点分治的过程中，存储每个分治重心的上级重心，也就是点分树的父子关系。显然，根据点分治的原理，点分树的树高是$\log n$的。这样，我们可以利用这棵树来跑一些类似“从询问点出发，不断跳`fa`”的暴力，来解决一些树上的多次询问/修改问题。

一个比较常见的套路是这样的：

- 进行一次点分治，求出每个点在点分树上的父节点。

- 对于每个点，开一个数据结构$S_1$存储点分树子树的贡献，再开一个数据结构$S_2$存储点分树父亲的贡献，用来容斥，防止算重。

- 对$x$进行修改时，从$x$开始不断跳点分树的父亲一直到根，每次对经过的节点的$S_1, S_2$修改它的贡献，时空复杂度为**点分树高 $\times$ 节点上的子数据结构单次修改复杂度**。

- 对$x$进行查询时，从$x$开始不断跳点分树的父亲一直到根，每次把$S_1$的贡献添加进答案，把$S_2$的贡献从答案刨去，时间复杂度为**点分树高 $\times$ 节点上的子数据结构单次查询复杂度**。

- 初始化可视为直接进行$n$次修改。

## 本题解法

模板题，直接套用前面说的套路。对于每个节点$x$，开一棵动态开点线段树$S_2$，下标是到$x$的距离，来维护点分树以$x$为根的子树的点权。然后以同样的方法建线段树$S_2$存储父亲的贡献进行容斥。

修改节点$u$时，从$u$开始爬点分树，记当前节点为$x$，父亲为$f$，在$S_1$的下标为$dis(x, u)$的位置加上新权值与原权值的差，在$S_2$的下标为$dis(f, u)$的位置加上新权值与原权值的差。

查询距节点$u$在$k$以内的点权和时，从$u$开始爬点分树，记当前节点为$x$，上一个访问的节点为$l$，令$d = dis(x, u)$。如果$d$不超过$k$，在$x$的$S_1$查$k - d$的前缀和加入答案，在$l$的$S_2$查$k - d$的前缀和从答案中刨去。

常数较大，为减小常数，推荐将每个线段树的下标范围设为点分树子树大小而非$n$，并且距离用ST表来$O(1)$求。

代码如下

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#define re register
#define il inline
 
using namespace std;
const int MAXN = 2e5 + 5;

il int gc() {
    static char buf[1000000], *p1 = buf, *p2 = buf;
    return (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin), p1 == p2)) ? EOF : *p1++;
    //return getchar();
}

il int geti() {
    re char ch = gc();
    re int f = 1, x = 0;
    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = gc();
    while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = gc();
    return f * x;
}
 
int n, m;
int a[MAXN];
int to[MAXN], nxt[MAXN], head[MAXN], ecnt;
 
il void Add(re int u, re int v) {
    to[++ecnt] = v; nxt[ecnt] = head[u]; head[u] = ecnt;
    to[++ecnt] = u; nxt[ecnt] = head[v]; head[v] = ecnt;
}
 
int dep[MAXN];
int stt[20][MAXN], lg2[MAXN], id1[MAXN], tot;
 
void DFS1(int u, int last, int depth) {
    dep[u] = depth;
    stt[0][++tot] = u;
    id1[u] = tot;
    for (int i = head[u]; i; i = nxt[i]) {
        int v = to[i];
        if (v == last) continue;
        DFS1(v, u, depth + 1);
        stt[0][++tot] = u;
    }
}
 
il int Lower(re int x, re int y) {
    return dep[x] < dep[y] ? x : y;
}
 
void GetST() {
    for (re int i = 2; i <= tot; i++) lg2[i] = lg2[i >> 1] + 1;
    for (re int i = 1; (1 << i) <= tot; i++) {
        re int w = (1 << i);
        for (re int j = 1; j + w - 1 <= tot; j++) {
            stt[i][j] = Lower(stt[i - 1][j], stt[i - 1][j + w / 2]);
        }
    }
}
 
il int LCA(re int x, re int y) {
    x = id1[x]; y = id1[y];
    if (x > y) swap(x, y);
    int i = lg2[y - x + 1], w = (1 << i);
    return Lower(stt[i][x], stt[i][y - w + 1]);
} 
 
il int Dis(re int x, re int y) {
    return dep[x] + dep[y] - 2 * dep[LCA(x, y)];
}
 
int size[MAXN], maxs[MAXN];
int dfa[MAXN];
int vis[MAXN];
int dsiz[MAXN];
 
int DFS2(int u, int last, int tots) {
    size[u] = 1;
    maxs[u] = 0;
    int cen = 0;
    for (re int i = head[u]; i; i = nxt[i]) {
        int v = to[i];
        if (vis[v] || v == last) continue;
        int vcen = DFS2(v, u, tots);
        if (!cen || maxs[vcen] < maxs[cen]) cen = vcen;
        size[u] += size[v];
        maxs[u] = max(maxs[u], size[v]);
    }
    maxs[u] = max(maxs[u], tots - size[u]);
    if (!cen || maxs[u] < maxs[cen]) cen = u;
    return cen;
}
 
void Divide(int cen, int tots) {
    vis[cen] = 1;
    dsiz[cen] = tots;
    for (re int i = head[cen]; i; i = nxt[i]) {
        int v = to[i];
        if (vis[v]) continue;
        int vsize = (size[v] < size[cen]) ? size[v] : (tots - size[cen]);
        int vcen = DFS2(v, cen, vsize);
        dfa[vcen] = cen;
        Divide(vcen, vsize);
    }
}

struct Node{
    int sum;
    Node *ch[2];
};
 
Node npool[10000000];
int ncnt;
 
struct SegTree{
    Node *rt;
    SegTree() {rt = NULL;}
    Node *New() {return &npool[ncnt++];}
     
    void Modify(Node *&now, int pos, int k, int l, int r) {
        if (!now) now = New();
        now->sum += k;
        if (l == r) return;
        int mid = (l + r) >> 1;
        if (pos <= mid) Modify(now->ch[0], pos, k, l, mid);
        else Modify(now->ch[1], pos, k, mid + 1, r);
    }
     
    int Query(Node *now, int l, int r, int nl, int nr) {
        if (!now) return 0;
        if (l == nl && r == nr) return now->sum;
        int mid = (nl + nr) >> 1;
        if (r <= mid) return Query(now->ch[0], l, r, nl, mid);
        else if (l > mid) return Query(now->ch[1], l, r, mid + 1, nr);
        return Query(now->ch[0], l, mid, nl, mid) + Query(now->ch[1], mid + 1, r, mid + 1, nr);
    }
};

SegTree T1[MAXN], T2[MAXN];
 
il void Modify(int idx, int val) {
    re int now = idx;
    while (now) {
        int fa = dfa[now];
        T1[now].Modify(T1[now].rt, Dis(now, idx), val, 0, dsiz[now]);
        if (fa) T2[now].Modify(T2[now].rt, Dis(fa, idx), val, 0, dsiz[fa]);
        now = fa;
    }
}
 
il int Query(int idx, int k) {
    re int res = 0;
    re int now = idx, last = 0;
    while (now) {
        int d = Dis(idx, now);
        if (d > k) {
            last = now;
            now = dfa[now];
            continue;
        }
        res += T1[now].Query(T1[now].rt, 0, k - d, 0, dsiz[now]);
        if (last) res -= T2[last].Query(T2[last].rt, 0, k - d, 0, dsiz[now]);
        last = now;
        now = dfa[now];
    }
    return res;
}
 
void Prework() {
    DFS1(1, 0, 0);
    GetST();
    int cen = DFS2(1, 0, n);
    Divide(cen, n);
    for (int i = 1; i <= n; i++) Modify(i, a[i]);
}
 
int main() {
    n = geti(); m = geti();
    for (re int i = 1; i <= n; i++) a[i] = geti();
    for (re int i = 1; i <= n - 1; i++) {
        int x = geti(), y = geti();
        Add(x, y);
    }
    Prework();
    int ans = 0;
    for (re int i = 1; i <= m; i++) {
        int op = geti(), x = geti(), y = geti();
        x ^= ans; y ^= ans;
        if (op == 0) {
            ans = Query(x, y);
            printf("%d\n", ans);
        } else {
            Modify(x, y - a[x]);
            a[x] = y;
        }
    }
    return 0;
}
```

## 洛谷上其他例题

大概难度升序

- P2056 [ZJOI2007]捉迷藏 / SP2666 QTREE4 - Query on a tree IV

  套路题，点分树+堆
   
- P3241 [HNOI2015]开店

  套路题，无修改，点分树+`vector`+前缀和
  
- P3345 [ZJOI2015]幻想乡战略游戏

  ~~怎么还是ZJOI~~，借助点分树移动答案
  
- P3920 [WC2014]紫荆花之恋

  动态加点的点分树+平衡树。除去动态加点就是点分树套路。加点时默认新点的点分父亲为原树父亲，当某点分子树不平衡度超过某个阈值，重新点分治即可。
  
- P4220 [WC2018]通道

  太难了一直没敢写，边分树+虚树。
  
- P4565 [CTSC2018]暴力写挂

  太难了一直没敢写，边分树+虚树。

---

## 作者：皎月半洒花 (赞：37)

拋磚引玉.jpeg

_______

大概就是如果没有修改操作的话，就是比较裸的点分树。于是先考虑没有修改操作的情况。

考虑怎么维护这个东西，自然是希望对每个点都记录一个桶，但这样显然由于每个点的深度不可控，最终需要的空间代价是 $O(n^2)$ 的。于是考虑怎么调整树的高度使得最终总的空间複杂度可以接受，那自然就会想到点分治。注意到点分治时，每个点在分治过程中，『逻辑树高』都只有 $\log n$ 。这大概就是为什么用点分树的原因。

所以就是建出点分树来，每个点维护一个 `vector` 作为桶，维护点分树上子树内到当前点距离为 $k$ 的点权和。这样对于询问，每次只需要跳点分树，然后对于每个 $fa$ 统计 $k-dis(fa,x)$ 的点对的数量就好了。但是还有一个问题，就是对于以当前 $fa$ 为根的那些子树，在算下一个 $fa$ 的时候会被算重。于是就要再维护一个桶，表示 $x$ 子树内的点，到点分树上 $x$ 的父亲的距离为 $k$ 的点权和。由于边权都为 $1$ ，这个操作就会很方便。

考虑如果带修改，那无非就是把桶换成树状数组即可。这样複杂度就会是 $O(m\log ^2 n)$ 的了。可能我写的比较丑？预处理是常数不小的 $O(n\log ^2 n)$ ，似乎比其他人都慢诶…

以下是第一次写点分树相关题的人可能会遇到的 bug：

1、最开始的时候维护的是 **点分树** 上距离为 $k$ 的点的点权和。

2、然后改了改，但是查询的时候没有维护两个 BIT，只维护了一个，然后减去的是查询 $x$ 的点分树子树内到 $x$ 距离 $\leq k-2\times dis(fa_x,x)$ 的点权和。看上去有点东西，但问题在于到 $x$ 距离和到 $fa_x$ 距离没有本质上的关係…比如可以在树的对侧。

3、最后还是写了两个 BIT，但是调了很久，原因是向上跳遇到 $dis(fa_x,x)>k$ 应该 `continue` 而不是 `break` ，因为这距离并是实际距离，在点分树上没有单调性。

```cpp
#include <bits/stdc++.h>

using namespace std ;

#define il inline 
#define to(k) E[k].to
#define next(k) E[k].next
#define low(x) (x & (-x))

const int N = 300010 ;

void debug(int *tp, int minn, int maxn, char c){
    for (int i = minn ; i <= maxn ; ++ i)
        cout << tp[i] << " " ;  cout << c ;
}

int res ;
int ans ;
int lans ;
int n, m ;
int f[N] ;
int d[N] ;
int vis[N] ;
int dep[N] ;
int mx_dep ;
struct Edge{
	int to ;
	int next ;
}E[N * 2] ;
int cnt ;
int base[N] ;
int head[N] ;
unordered_map<int, int> Id[N] ;
vector <int> sub[N] ;
vector <int> buc[N] ;

il void add(int a, int b){
	to(++ cnt) = b ;
	next(cnt) = head[a] ;
	head[a] = cnt ;
}
namespace findCG{
	int grt ;
	int num ;
	int g[N] ;
	int size[N] ;
	il void chk(int &a, int b){
		a = b <= a ? a : b ;
	}
	il void reset(){
		g[grt = 0] = 19690126 ;
	}
	void dfs(int x, int fa){
		size[x] = 1 ; g[x] = 0 ;
		for (int k = head[x] ; k ; k = next(k)){
			if (to(k) != fa && !vis[to(k)]){
				dfs(to(k), x) ;
				size[x] += size[to(k)] ;
				g[x] = max(g[x], size[to(k)]) ;
			}
		}
		chk(g[x], num - size[x]) ;
		if (g[x] < g[grt]) grt = x ;
	}
}
using namespace findCG ;

il void init(int root, int x){
	for (int i = 0 ; i <= x ; ++ i)
		buc[root].push_back(0) ;
}
il void add(int root, int x, int p){
	int t = buc[root].size() ;
	for ( ; x < t ; x += low(x)) buc[root][x] += p ;
}
il int ask(int root, int x){
	int ret = 0 ;
	if (x >= buc[root].size())
		x = (int)buc[root].size() - 1 ;
	for ( ; x ; x -= low(x)) ret += buc[root][x] ;
	return ret ;
}
il void init2(int root, int x){
	for (int i = 0 ; i <= x ; ++ i)
		sub[root].push_back(0) ;
}
il void add2(int root, int x, int p){
	int t = sub[root].size() ;
	for ( ; x < t ; x += low(x)) sub[root][x] += p ;
}
il int ask2(int root, int x){
	int ret = 0 ;
	if (x >= sub[root].size())
		x = (int)sub[root].size() - 1 ;
	for ( ; x ; x -= low(x)) ret += sub[root][x] ;
	return ret ;
}
void calc(int x, int fa, int root){
	size[x] = 1 ;
	dep[x] = dep[fa] + 1 ;
	Id[root][x] = dep[x] ;
	for (int i = head[x] ; i ; i = next(i))
		if (!vis[to(i)] && to(i) != fa)
			calc(to(i), x, root), size[x] += size[to(i)] ;
	mx_dep = max(dep[x], mx_dep) ;
}
void calc2(int x, int fa, int root, int frt){
	add(root, dep[x], base[x]) ;
	if (frt) add2(root, Id[frt][x], base[x]) ;
	for (int i = head[x] ; i ; i = next(i))
		if (!vis[to(i)] && to(i) != fa) calc2(to(i), x, root, frt) ;
}
void find_tree(int x, int fa, int h){
	int mx ; vis[x] = 1 ; mx_dep = 0 ; 
	calc(x, 0, x), init(x, mx_dep) ; 
	init2(x, h) ; mx = mx_dep ; 
	calc2(x, 0, x, fa) ;
	for (int k = head[x] ; k ; k = next(k)){
		if (vis[to(k)]) continue ;
		num = size[to(k)] ; reset() ;
		dfs(to(k), x) ; f[grt] = x ;
		find_tree(grt, x, mx) ;
	}
}
il int qr(){
	int r = 0 ; 
	char c = getchar() ; 
	while (!isdigit(c)) c = getchar() ; 
	while (isdigit(c))
		r = r * 10 + c - 48, c = getchar() ;
	return r ; 
}
int main(){
	int a, b, c ; cin >> n >> m ; 
	for (int i = 1 ; i <= n ; ++ i) base[i] = qr() ;
	for (int i = 1 ; i < n ; ++ i)
		a = qr(), b = qr(), add(a, b), add(b, a) ;
	reset() ; num = n ; dfs(1, 0) ; find_tree(grt, 0, 0) ;
	while (m --){
		a = qr() ; 
		b = qr() ^ lans ; 
		c = qr() ^ lans ;
		if (!a){
			int fb = f[b] ;
			int ob, lb = b, df ;
			ans += ask(lb, c + 1) ;
			while (fb){
				df = Id[fb][b] - 1 ;
				if (c - df < 0){				
					lb = fb, fb = f[fb] ;
					continue ;
				}
				ans += ask(fb, c - df + 1) ;
				ans -= ask2(lb, c - df + 1) ;
				lb = fb, fb = f[fb] ;
			}
			printf("%d", (lans = ans)) ; 
			ans = 0 ; putchar('\n') ; 
		}
		else {
			int ob = b ;
			add(b, 1, -base[b] + c) ;
			while (f[b]){
				int df = Id[f[b]][ob] ;
				add(f[b], df, -base[ob] + c) ;
				add2(b, df, -base[ob] + c) ; b = f[b] ;
			}
			base[ob] = c ;
		}
	}
	return 0 ; 
}
```

~~為什么我這麼慢啊~~

---

## 作者：devout (赞：20)

这道题强制在线。。。

先介绍一下点分树这个东西吧。

点分树，又叫做动态点分治，他的核心思想是把点分治的每一层的重心连到下一层上构成的一棵树

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201006111148446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Rldm91dF8=,size_16,color_FFFFFF,t_70#pic_center)

对于这棵树来说，他的一个点分树就是

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201006111235766.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Rldm91dF8=,size_16,color_FFFFFF,t_70#pic_center)

显然，这棵点分树的树高是 $\log n$ 级别的，所以我们就可以怎么暴力怎么来了。

基本思路是对于每一个点 $u$，开两个数据结构 $S1,S2$，其中 $S1$ 保存的是在在点分树上以 $u$ 为子树点到 $u$ 的信息，$S2$ 表示在点分树上以 $u$ 为子树的点到 $u$ 在点分树上的父亲节点的信息。

查询点 $u$ 的时候，暴力向上爬点分树，每次计算答案的时候加上 $S1$ 对答案的贡献，减去 $S2$ 对答案的贡献，单次查询的复杂度是**点分树高**$\times$**数据结构单次查询复杂度**。

修改点 $u$ 的时候，暴力向上爬点分树，相应修改 $S1,S2$，单次修改的复杂度是**点分树高**$\times$**数据结构单次修改复杂度**。

****

对于这道题，我们可以给每个点开两个树状数组，表示的是在 $u$ 点分树上子树中的点到 $u,u$ 在点分树上的父亲的距离为 $i$ 的点的数量。

但是这样做的空间复杂度是 $O(n^2)$ 的。我们发现因为路径长度就是边数，所以我们把树状数组的大小开成 $u$ 的子树大小就可以了，这样的话总空间是 $2^x\times\dfrac{n}{2^x}=n\log n$。

这样，时间复杂度 $O(n\log^2n)$，空间复杂度 $O(n\log n)$就可以解决了。

点分树代码不太好写，写的时候要细心一点。

****

点分树的细节上有一点就是 $dis(u,fa[u])$ 是可以大于 $dis(u,fa[fa[u]])$ 的，所以我们查询的时候一定要跳满，不能中途退出。

记得强制在线！！！

```cpp
#include<iostream>
#include<cstring>
#include<cassert>
#include<cmath>
#include<map>
#include<set>
#include<queue>
#include<stack>
#include<cstdio>
#include<vector>
#include<time.h>
#include<algorithm>

using namespace std;

# define Rep(i,a,b) for(register int i=a;i<=b;i++)
# define _Rep(i,a,b) for(register int i=a;i>=b;i--)
# define RepG(i,u) for(int i=head[u];~i;i=e[i].next)

typedef long long ll;

const int N=2e5+5;

template<typename T> void read(T &x){
   x=0;int f=1;
   char c=getchar();
   for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
   for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+c-'0';
    x*=f;
}

int n,m;
int a[N];
int head[N],cnt;
int faz[N];
int f[N],siz[N];
int st[N][20],dep[N];
int p[N],totp;
int ans;
bool vis[N];

struct BIT{
	vector<int> bit;
	void build(int sz){
		Rep(i,0,sz+3)bit.push_back(0);
	}
	void add(int o,int x){
		for(;o<bit.size();o+=o&-o)bit[o]+=x;	
	}
	int ask(int o){
		o=min(o,(int)bit.size()-1);
		int res=0;
		for(;o;o-=o&-o)res+=bit[o];
		return res;	
	}
}S1[N],S2[N];

struct Edge{
	int to,next;	
}e[N<<1];

void add(int x,int y){
	e[++cnt]=(Edge){y,head[x]},head[x]=cnt;
}

int lca(int x,int y){
	if(dep[x]<dep[y])swap(x,y);
	_Rep(i,19,0)if(dep[st[x][i]]>=dep[y])x=st[x][i];
	if(x==y)return x;
	_Rep(i,19,0)if(st[x][i]!=st[y][i])x=st[x][i],y=st[y][i];
	return st[x][0];	
}

int getdis(int u,int v){
	return dep[u]+dep[v]-2*dep[lca(u,v)];	
}

void dfs1(int u,int fa){
	dep[u]=dep[fa]+1;
	st[u][0]=fa;
	Rep(i,1,19)st[u][i]=st[st[u][i-1]][i-1];
	RepG(i,u){
		int v=e[i].to;
		if(v==fa)continue;
		dfs1(v,u);
	}
}

void dfs2(int u,int fa){
	p[++totp]=u;
	siz[u]=1;
	RepG(i,u){
		int v=e[i].to;
		if(v==fa||vis[v])continue;
		dfs2(v,u);
		siz[u]+=siz[v];
		f[u]=max(f[u],siz[v]);
	}
}

void dfs3(int rt,int u,int fa,int len){
	S1[rt].add(len,a[u]);
	RepG(i,u){
		int v=e[i].to;
		if(v==fa||vis[v])continue;
		dfs3(rt,v,u,len+1); 
	} 
}

void init(int u,int fa){
	totp=0;
	dfs2(u,0);	
	Rep(i,1,totp)f[p[i]]=max(f[p[i]],totp-siz[p[i]]);
	int rt=-1;
	Rep(i,1,totp)if(rt==-1||f[rt]>f[p[i]])rt=p[i];
	Rep(i,1,totp)f[p[i]]=0;
	vis[rt]=true;
	u=rt;
	faz[u]=fa;
	S2[u].build(totp);
	if(fa)Rep(i,1,totp)S2[u].add(getdis(p[i],fa),a[p[i]]);
	S1[u].build(totp);
	RepG(i,u){
		int v=e[i].to;
		if(vis[v])continue;	
		dfs3(u,v,u,1);
	}
	RepG(i,u){
		int v=e[i].to;
		if(vis[v])continue;
		init(v,u);	
	}
}

void update(int x,int k){
	int u=x;
	while(faz[u]){
		int d=getdis(x,faz[u]);
		S2[u].add(d,-a[x]);
		S2[u].add(d,k);
		u=faz[u];
		S1[u].add(d,-a[x]);
		S1[u].add(d,k);	
	}
	a[x]=k;
}

int query(int x,int k){
	int u=x;
	int res=0;
	res+=a[x]+S1[x].ask(k);
	while(faz[u]){
		int d=getdis(faz[u],x);
		if(d<=k)res+=a[faz[u]]+S1[faz[u]].ask(k-d)-S2[u].ask(k-d);
		u=faz[u];
	}
	return res;
}

int main()
{
//	freopen("p6329.in","r",stdin);
	memset(head,-1,sizeof(head));
	read(n),read(m);
	Rep(i,1,n)read(a[i]);
	Rep(i,1,n-1){
		int x,y;
		read(x),read(y);
		add(x,y),add(y,x);
	}	
	dfs1(1,0);
	init(1,0);
	Rep(i,1,m){
		int opt,x,y;
		read(opt),read(x),read(y);
		//x^=ans,y^=ans;	
		if(!opt)printf("%d\n",ans=query(x,y));
		else update(x,y);
	}
	return 0;
}

```



---

## 作者：NewJeanss (赞：13)

我们的老师有一种优秀的写法，和大多数题解不相同。所以我来转述一下我们老师（陈大大）的绝妙思路。

## 不同之处

1. **不用LCA**求距离（在记录分支结构时直接记录他的距离）

2. **没有重构树**（记录“覆盖”每一个点的分支结构）

3. 树状数组大小只开当前子树**最大深度+2**即可

## 分析

1. 对于点分治，其他题解已经十分详细。这里有一个蒟蒻曾经困惑的问题。每一次   $findroot$ 找到的真的是重心吗？**并不是**。如样例。找出重心时发现点1比点2先出现，但实际上，这**不影响复杂度**。只是找了一个不那么好也不那么差的点。

2. 记录分治结构

```
struct node{
	int G,from,dis;
        //重心（根），所在子树（需要重新标号防止重复），到重心的距离
};
vector<node> a[N];
```

这样可以省掉一个LCA。

3. $solve$ 函数

```
void finddep(int x,int fa,int d){//找最大深度
	Maxdep2=max(Maxdep2,d); a[x].push_back(node{RT,cnt,d});
	for(int i=head[x];i;i=e[i].nex){
		int to=e[i].to;
		if(vis[to]||to==fa) continue;
		finddep(to,x,d+1);//直接记录深度
	}
}
void solve(int x){
	a[x].push_back(node{x,0,0});//重心自己也要记录，cnt=0表示他是根
	Maxdep1=0; RT=x;
	for(int i=head[x];i;i=e[i].nex){
		int to=e[i].to;
		if(vis[to]) continue;
		Maxdep2=0; ++cnt; finddep(to,x,1);//每个子树记录深度
		Maxdep1=max(Maxdep1,Maxdep2);//总的深度记录
		DS[1][cnt].resize(Maxdep2+2);//开树状数组，1表示子树内的
	}
	DS[0][x].resize(Maxdep1+2);//0表示重心的
        //+2的原因：+1：vector下标从0开始，+1：距离可能为0（根节点到自己）
        //而树状数组不能下标为0
	vis[x]=1;//继续分治
	for(int i=head[x];i;i=e[i].nex){
		int to=e[i].to;
		if(vis[to]) continue;
		best=0; all=size[to];
		findroot(to,0); solve(best);
	}
}
```

4. 处理询问

注意一些特殊判断。比如是否是**根节点**，查询距离是否**大于树状数组大小**。

```
void modify(int x,int v){
	for(int i=0;i<a[x].size();i++){//对于“覆盖”x的每一个分治结构
		int A=a[x][i].G,B=a[x][i].from,C=a[x][i].dis;
		update(A,0,C,v);//第几个树状数组，子树的/根的，位置，加的权值
		if(B) update(B,1,C,v);//如果不是根节点
	}
	
}
int ask(int x,int k){
	int ans=0; 
	for(int i=0;i<a[x].size();i++){
		int A=a[x][i].G,B=a[x][i].from,C=a[x][i].dis;
		if(k-C<0) continue;// 特判
		ans+=query(A,0,k-C); 
		ans-=query(B,1,k-C);
	}
	return ans;
}
```

5. 树状数组

也加入一些特判，防止越界。

```
void update(int x,int op,int p,int v){//+1是让距离整体右移1，因为有距离为0
	for(int i=p+1;i<=DS[op][x].size()-1;i+=lowbit(i)) DS[op][x][i]+=v;
}
int query(int x,int op,int p){//判断查询是否超过数组大小
	int res=0; p=min(p+1,int(DS[op][x].size()-1));
	for(int i=p;i>=1;i-=lowbit(i)) res+=DS[op][x][i];
	return res;
}
```

## 代码

```
#include <bits/stdc++.h>
#define N 100005
using namespace std;
int value[N],size[N],vis[N],f[N],head[N],tot,n,m;
int all,best,cnt,Maxdep1,Maxdep2,RT;
struct edge{
	int to,nex;
}e[N<<1];
struct node{
	int G,from,dis;
};
vector<node> a[N];
vector<int> DS[2][N];
int lowbit(int x){ return x&-x; }
void update(int x,int op,int p,int v){
	for(int i=p+1;i<=DS[op][x].size()-1;i+=lowbit(i)) DS[op][x][i]+=v;
}
int query(int x,int op,int p){
	int res=0; p=min(p+1,int(DS[op][x].size()-1));
	for(int i=p;i>=1;i-=lowbit(i)) res+=DS[op][x][i];
	return res;
}
void add(int x,int y){
	e[++tot].to=y;
	e[tot].nex=head[x];
	head[x]=tot;
}
void findroot(int x,int fa){
	f[x]=0; size[x]=1;
	for(int i=head[x];i;i=e[i].nex){
		int to=e[i].to;
		if(vis[to]||to==fa) continue;
		findroot(to,x);
		size[x]+=size[to]; f[x]=max(f[x],size[to]);
	}
	f[x]=max(f[x],all-size[x]);
	if(f[best]>f[x]) best=x;
}
void finddep(int x,int fa,int d){
	Maxdep2=max(Maxdep2,d); a[x].push_back(node{RT,cnt,d});
	for(int i=head[x];i;i=e[i].nex){
		int to=e[i].to;
		if(vis[to]||to==fa) continue;
		finddep(to,x,d+1);
	}
}
void solve(int x){
	a[x].push_back(node{x,0,0});
	Maxdep1=0; RT=x;
	for(int i=head[x];i;i=e[i].nex){
		int to=e[i].to;
		if(vis[to]) continue;
		Maxdep2=0; ++cnt; finddep(to,x,1);
		Maxdep1=max(Maxdep1,Maxdep2);
		DS[1][cnt].resize(Maxdep2+2);
	}
	DS[0][x].resize(Maxdep1+2);
	vis[x]=1;
	for(int i=head[x];i;i=e[i].nex){
		int to=e[i].to;
		if(vis[to]) continue;
		best=0; all=size[to];
		findroot(to,0); solve(best);
	}
}
void modify(int x,int v){
	for(int i=0;i<a[x].size();i++){
		int A=a[x][i].G,B=a[x][i].from,C=a[x][i].dis;
		update(A,0,C,v);
		if(B) update(B,1,C,v);
	}
	
}
int ask(int x,int k){
	int ans=0; 
	for(int i=0;i<a[x].size();i++){
		int A=a[x][i].G,B=a[x][i].from,C=a[x][i].dis;
		if(k-C<0) continue;
		ans+=query(A,0,k-C); 
		ans-=query(B,1,k-C);
	}
	return ans;
}
signed main(){
	int op,x,y,lastans;
	while(cin>>n>>m){
		memset(head,0,sizeof(head)); tot=0;
		for(int i=1;i<=n;i++) cin>>value[i];
		for(int i=1;i<n;i++) cin>>x>>y,add(x,y),add(y,x);
		best=0; f[0]=0x3f3f3f3f; all=n; //点分治预处理
		memset(vis,0,sizeof(vis)); cnt=0;
		findroot(1,0); solve(best);
		for(int i=1;i<=n;i++) modify(i,value[i]);//更新
		lastans=0; 
		for(int i=1;i<=m;i++){
			cin>>op>>x>>y; x^=lastans; y^=lastans;//强制在线
			if(op==0) lastans=ask(x,y),cout<<lastans<<endl;
			else modify(x,y-value[x]),value[x]=y;
		}
	}
	return 0;
}
```


---

## 作者：WeLikeStudying (赞：10)

- 我们之前在思考点分治的时候忽然想到了一个问题。
- 如果把每次的分治重心全部建立父子关系，显然可以得到一棵新树，而这棵树的高度为严格 $O(\log n)$。
![](https://cdn.luogu.com.cn/upload/image_hosting/9iiwnfyx.png)
- 由于点分树的高度很少（提高行政效率），所以我们甚至可以保存关于每个点分树上节点线性的信息（更好地“管辖”子树，中央集权）！所以很多暴力的操作都是可以搞的（~~暴政~~）。

**引入**
- 让我们来一道[例题](https://www.luogu.com.cn/problem/P6329)，它要求在线地修改点权，查询距离不超过 $k$ 的点的点权和。
- 我们先建出点分树，一个很暴力的想法就是用 $\text{vector}$ 求出 $c(u,k)$ 表示 $u$ 在点分治下的子树内在原树距离不超过 $k$ 的点的个数，预处理 $d(u,k)$ 表示 $u$ 在点分治上的 $k$ 级祖先与它在原树上的距离，然后查询的时候暴力查询（$f(u,k)$ 表示在点分树上的 $k$ 级祖先）$f(fa(u,i),k-d(u,i))$。
- 然后你很快发现这样会重复，因为它的父亲会查到它儿子，所以还要设 $g(u,k)$ 表示 $u$ 在点分树上的父亲在原树上距离小于等于 $k$ 的点有多少个在 $u$ 的子树上，从而减去重复的部分。
- 接下来你还要带修，但是你很快发现这并不是难事，暴力在点分树上跳，用树状数组维护这一过程。
- 时间复杂度 $O(n\log n+q\log^2 n)$，空间复杂度 $O(n\log n)$。

**实现细节**
- 我认为点分树的实现很有细节，类似于[分治](https://www.luogu.com.cn/blog/luo1gu1zui1bang1/post-ji-chu-you-hua-fen-zhi)的内容，它可以形象化地分为这几步：
- 第一步即寻找重心，在这个时候可以同时处理上层对子树的影响（我是通过一个队列来实现的）。
- 第二步即正式地计算子树内部的贡献，然后找到重心，同时下传对子树的影响（我同样通过一个队列实现）。
- 第三步即分裂下传，把这些纲要在头脑内想一想，思路就逐渐清晰了。
- $f$ 函数和 $g$ 函数对于特定的节点 $u$ 所需要开的空间大小同样十分重要，$f$ 函数应该至少开以 $u$ 为根，这棵子树的最大深度那么多的空间，而 $g$ 函数应该开以 $u$ 点分树上的父亲为根，这棵子树的深度那么多的空间，当然，你全部设成子树大小也可以。
- 这里吐槽一下，我一开始点分治打错还过了好几题，这数据有点水，[代码实现](https://www.luogu.com.cn/paste/15plvu6a)。
- [调试代码](https://www.luogu.com.cn/paste/e7d831z8)。

---

## 作者：EnofTaiPeople (赞：10)

略解的“略”字主要指代码十分简短，加 `fread` 快读只有 2.23k。

前置知识：

1. 树的重心；
2. 树状数组；
3. 点分治（不一定要写出来，我至今没有写过点分治）。

步骤如下：

1. 找到重心，处理出所有节点的深度，并建立最大深度大小的树状数组；
2. 处理出所有节点在重心的那个儿子下面，对于重心的每一个儿子建立一个以该棵子树下最大深度大小的树状数组。
3. 递归分治建树。

这样，按每个节点的深度将权值插入点分树上每一个深度的两棵树状数组，查询时要对着两棵树状数组差分一下。

有一些难理解，可以看代码：
```cpp
void dfs1(int x=nps,int pr=0){
	sz[x]=1;
	for(int y:lk[x])
		if(!vs[y]&&y!=pr)
			dfs1(y,x),sz[x]+=sz[y];
}
void dfs2(int x=nps,int pr=0){
	aw[x]=sz[nps]-sz[x];
	for(int y:lk[x])
		if(!vs[y]&&y!=pr)
			dfs2(y,x),aw[x]=max(aw[x],sz[y]);
	if(aw[x]<aw[rt])rt=x;
}
void dfs3(int x,int pr=0){
	f[x][++cn[x]]=rt,mxd[x]=d[x][cn[x]];
	for(int y:lk[x])
		if(!vs[y]&&y!=pr){
		d[y][cn[x]]=d[x][cn[x]]+1;
		_f[y][cn[x]]=_f[x][cn[x]],dfs3(y,x);
		if(mxd[y]>mxd[x])mxd[x]=mxd[y];
	}
}
void calc(int ps=1){
	nps=ps,rt=0,dfs1(),dfs2(),vs[rt]=1,++cn[rt],mxd[rt]=0;
	for(int y:lk[rt])
		if(!vs[y]){
			_f[y][cn[rt]]=y,d[y][cn[rt]]=1,dfs3(y);
			ct[y][cn[rt]].resize(mxd[y]+2);
			if(mxd[y]>mxd[rt])mxd[rt]=mxd[y];
		}ct[rt][cn[rt]].resize(mxd[rt]+2);
	for(int y:lk[rt])
		if(!vs[y])calc(y);
}
inline void add(int x,int p,int d,int v){
	int sz=ct[x][p].size();
	for(++d;d<sz;d+=d&-d)ct[x][p][d]+=v;
}
inline int qry(int x,int p,int d){
	int res=0;d=max(min(d+1,(int)ct[x][p].size()-1),0);
	for(;d;d-=d&-d)res+=ct[x][p][d];
	return res;
}
inline void Add(int x,int v){
	add(x,cn[x],0,v);
	for(int i=cn[x]-1;i;--i){
		add(f[x][i],i,d[x][i],v);
		add(_f[x][i],i,d[x][i],v);
	}
}

```
点分树的优点在于通过每次找重心，使得分治的次数是 $O(\log_2n)$ 的，于是单次修改查询的复杂度均为 $O(\log_2^2n)$。

给出主函数代码供参考：
```cpp
int main(){
	read(n,q),aw[0]=2e9;int i,op,x,y;
	for(x=1;x<=n;++x)read(vl[x]);
	for(i=1;i<n;++i){
		read(x,y);
		lk[x].push_back(y);
		lk[y].push_back(x);
	}calc();
	for(x=1;x<=n;++x)Add(x,vl[x]);
	while(q--){
		read(op,x,y),x^=ans,y^=ans;
		if(op){
			Add(x,y-vl[x]),vl[x]=y;
		}else{
			ans=qry(x,cn[x],y);
			for(i=cn[x]-1;i;--i)
				ans+=qry(f[x][i],i,y-d[x][i])-qry(_f[x][i],i,y-d[x][i]);
			printf("%d\n",ans);
		}
	}return 0;
}
```

---

## 作者：米奇 (赞：9)

## 题解

点分树最简单的写法就是维护**两个数据结构**（一般是vector）

一个记录点分树上**以点u为根的子树与u的信息**（到u的距离） 

一个记录点分树上**以点u为根的子树与fa[u]的信息**（到法fa[u]的距离）

然后就可以通过容斥（减一减），求出**在fa[u]的子树中且不在u的子树中**的信息（到某某点的距离）

除了这种写法，就要重构树（使度数<=3）了

这题还有一个难点就是这两个数据结构是树状数组

那么就要动态开点（vector），有点麻烦 

距离为0的点（本身），树状数组不好处理，我们就先不加入，到要用的时候直接加 

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define next Next
//#define gc getchar
//#define int long long
const int N=2e6+5;
int n,m,top,t,sum,rt,lastans,sz[N],fa[N],vis[N],ru[N],id[N],dep[N],a[N];
int head[N],ma[N],Log[N],size[N],st[N][21];
struct node{
	int too,next;
}edge[N*2];
char buf[1<<21],*p1=buf,*p2=buf;
inline int gc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}
inline int read()
{
    int ret=0,f=0;char c=gc();
    while(!isdigit(c)){if(c=='-')f=1;c=gc();}
    while(isdigit(c)){ret=ret*10+c-48;c=gc();}
    if(f)return -ret;return ret;
}
void write(int x)
{
	if(x<10){putchar(x+'0');return;}
	write(x/10);
	putchar(x%10+'0');
}
int lowbit(int x)
{
	return x&-x;
}
struct Tree{
	vector<int>c;
	void init(int n)
	{
		for(int i=0;i<=n;i++)
			c.push_back(0);
	}
	void change(int x,int y)
	{
		int n=c.size()-1;
		while(x<=n)
		{
			c[x]+=y;
			x+=lowbit(x);
		}
	}
	int find(int x)
	{
		int res=0;
		if(x>c.size()-1)x=c.size()-1;//注意 
		while(x>0)
		{
			res+=c[x];
			x-=lowbit(x);
		}
		return res;
	}
}T1[N],T2[N];
void add(int a,int b)
{
	edge[++top].too=b;edge[top].next=head[a];head[a]=top;
}
void dfs(int u,int fa,int d)
{
	ru[u]=++t;
	id[t]=u;
	dep[t]=d;
	for(int i=head[u];i;i=edge[i].next)
	{
		int v=edge[i].too;
		if(v==fa)continue;
		dfs(v,u,d+1);
		id[++t]=u;
		dep[t]=d;
	}
}
int LCA(int x,int y)
{
	int l=ru[x],r=ru[y];
	if(l>r)swap(l,r);
	int k=Log[r-l+1];
	x=st[l][k];y=st[r-(1<<k)+1][k];
	if(dep[x]<=dep[y])return id[x]; 
	return id[y];
	//注意LCA是要转化为id的 
}
int dis(int x,int y)
{
	int lca=LCA(x,y);
	return dep[ru[x]]+dep[ru[y]]-2*dep[ru[lca]];
	//注意这里的dep[x]是编号为x的点的深度，不是点x的深度 
}
void getrt(int u,int fa)
{
	ma[u]=0;size[u]=1;
	for(int i=head[u];i;i=edge[i].next)
	{
		int v=edge[i].too;
		if(v==fa||vis[v])continue;
		getrt(v,u);
		size[u]+=size[v];
		ma[u]=max(ma[u],size[v]);
	}
	ma[u]=max(ma[u],sum-size[u]);
	if(ma[u]<ma[rt])rt=u;
}
void solve(int u)
{
	vis[u]=1;
	for(int i=head[u];i;i=edge[i].next)
	{
		int v=edge[i].too;
		if(vis[v])continue;
		ma[rt=0]=sum=size[v];
		getrt(v,0);
		fa[rt]=u;
		sz[rt]=size[v];//注意rt的大小是size[v] 
		T1[rt].init(size[v]);//注意不能全开n，否则变n^2 
		T2[rt].init(size[v]); 
		solve(rt);
	}
}
void work(int x,int y)
{
	for(int i=fa[x];i;i=fa[i])
	{
		int len=dis(x,i);
		if(len<=sz[i])T1[i].change(len,y);
	}
	for(int i=x;i;i=fa[i])
	{
		if(fa[i]==0)break;
		int len=dis(x,fa[i]);
		if(len<=sz[i])T2[i].change(len,y);
	}
}
signed main()
{
	Log[0]=-1;
	for(int i=1;i<=200000;i++)Log[i]=Log[i/2]+1;
	n=read();m=read();
	for(int i=1;i<=n;i++)a[i]=read();
	for(int i=1;i<n;i++)
	{
		int x=read(),y=read();
		add(x,y);
		add(y,x);
	}
	dfs(1,0,0);
	for(int i=1;i<=t;i++)st[i][0]=i;
	for(int i=1;i<=Log[t];i++)
		for(int j=1;j<=t-(1<<i)+1;j++)
		{
			int x=st[j][i-1],y=st[j+(1<<(i-1))][i-1];
			if(dep[x]<=dep[y])st[j][i]=x;
			else st[j][i]=y;
		}
	ma[rt=0]=sum=n;
	getrt(1,0);
	sz[rt]=n;
	T1[rt].init(n);
	T2[rt].init(n);
	solve(rt);
	for(int i=1;i<=n;i++)
		work(i,a[i]);
	while(m--)
	{
		int opt=read(),x=read()^lastans,y=read()^lastans;
		if(opt==0)
		{
			int res=T1[x].find(y)+a[x];
			//注意为了方便树状数组，没有把距离为0的点放进去 
			for(int i=x;i;i=fa[i])
			{
				if(fa[i]==0)break;
				int len=dis(x,fa[i]);
				if(y-len>=0)
				{
					res+=T1[fa[i]].find(y-len)+a[fa[i]];
					res-=T2[i].find(y-len);
				}
			}
			write(lastans=res);
			putchar('\n'); 
		}
		else{
			work(x,y-a[x]);
			a[x]=y;
		}
	}
	return 0;
}
/*
5 1
1 3 5 7 9
1 2
2 3
3 4
3 5
0 2 1
*/
/*
# 点分树最简单的写法就是维护两个数据结构（一般是vector）
一个记录点分树上以点u为根的子树与u的信息（到u的距离） 
一个记录点分树上以点u为根的子树与fa[u]的信息（到法fa[u]的距离）
然后就可以通过容斥（减一减），求出在fa[u]的子树中且不在u的子树中的信息（到某某点的距离）
除了这种写法，就要重构树（使度数<=3）了
这题还有一个难点就是这两个数据结构是树状数组
那么就要动态开点（vector），有点麻烦 
*/
```

---

## 作者：Autre (赞：5)

单点修改，树上查询邻域点权和。

如果不带修的话是经典题目[树上邻域数点](https://www.luogu.com.cn/problem/P8498)的弱化版，因为查询时合并簇的次数限制从一次放宽到了 $O(\log n)$ 次。

具体做法是建出全局平衡二叉树，对于每个簇的某个界点 $u$，设 $d$ 为簇内到 $u$ 距离最远的点的距离，对于每个 $k\in[1,d]$ 维护簇内于 $u$ 相距为 $k$ 的点的点权和。全局平衡二叉树处理簇内点相关信息时一般不包含界点，否则不方便统计答案，这里同理。

于是树上单点修改 $u$ 的点权时，从包含 $u$ 的最小簇（$u$ 不能是该簇界点）开始向父亲跳。对途径的每个簇维护的距离两个界点相应距离的点的权值和进行单点修改。

查询以 $u$ 为中心的邻域时，将邻域分解为几个整簇和几个簇内邻域进行合并。具体做法是从以 $u$ 为界点的任一簇开始往父亲跳，对途径的每个点，考察邻域是否覆盖到了它的兄弟，它兄弟的界点是否在父亲的簇内。一通合并后记得考察根簇的界点是否在邻域内。

簇内查询邻域需要对所维护的到两个节点距离为定值的点的权值和求前缀和，还需要单点修改，所以使用树状数组查询。

代码也不难写，加个快读，上个内存池能优化到 1.6s。这里给出 vector 版实现


```C++
#include<algorithm>
#include<iostream>
#include<vector>
#include<queue>

const int N = 1e5, T = N*2, LT = 18;
int a[N], s[N], d[N], sn[N], ed[N];
int df[N], st[LT][T], ct;
int pa[T], pb[T], ls[T], rs[T], f[T], tt;
int w[T], lt[T], da[T], db[T];
bool tp[T];
std::vector<int>fa[T], fb[T];
std::vector<std::pair<int, bool>>g[N];
void dfs(int u, int f=0) {
    s[u] = 1, sn[u] = -1, df[u] = ct, st[0][ct++] = u;
    for (auto&[v, fl] : g[u]) if (v != f) {
        d[v] = d[u] + 1, dfs(v, u);
        st[0][ct++] = u, s[u] += s[v], fl = 1;
        if (!~sn[u] || s[v] > s[sn[u]]) sn[u] = v;
    }
}
int inline ds(int u, int v) {
    int x = df[u], y = df[v];
    if (x > y) std::swap(x, y);
    int lg = std::__lg(y - x + 1);
    return d[u] + d[v] - 2*std::min(d[st[lg][x]], d[st[lg][y-(1<<lg)+1]]);
}
namespace FenT {
    void acc(std::vector<int>&f) {
        for (unsigned n=f.size(), i=0, j; i<n; i++)
            if (j = i+(i&-i), j < n) f[j] += f[i];
    }
    void ad(std::vector<int>&f, unsigned i, int k) {
        for (; i<f.size(); i+=i&-i) f[i] += k;
    }
    int qr(std::vector<int>&f, unsigned i) {
        int sm = 0;
        i = std::min(i, (unsigned)f.size()-1);
        for (; i; i-=i&-i) sm += f[i];
        return sm;
    }
}
int inline nw(int u, int v) {
    w[tt] = lt[tt] = 1;
    fa[tt] = fb[tt] = {0};
    pa[tt] = u, pb[tt] = v;
    return ed[v] = tt++;
}
int cp(int u, int v) {
    pa[tt] = pa[u], pb[tt] = pb[v];
    w[tt] = w[u] + w[v], lt[tt] = lt[u] + lt[v];
    da[tt] = std::max(da[u], lt[u] + da[v]);
    fa[tt] = fa[u], fa[tt].resize(da[tt]+1);
    for (int i=1; i<=da[v]; i++) fa[tt][lt[u]+i] += fa[v][i];
    db[tt] = std::max(db[v], lt[v] + db[u]);
    fb[tt] = fb[v], fb[tt].resize(db[tt]+1);
    for (int i=1; i<=db[u]; i++) fb[tt][lt[v]+i] += fb[u][i];
    fa[tt][lt[u]] += a[pa[v]], fb[tt][lt[v]] += a[pb[u]];
    return f[ls[tt] = u] = f[rs[tt] = v] = tt, tt++;
}
int rk(int u, int v) { int k = a[pb[v]];
    pa[tt] = pa[u], pb[tt] = pb[u], tp[tt] = 1;
    w[tt] = w[u] + w[v], lt[tt] = lt[u];
    da[tt] = std::max({da[u], da[v], lt[v]});
    fa[tt] = fa[u], fa[tt].resize(da[tt]+1);
    for (int i=1; i<=da[v]; i++) fa[tt][i] += fa[v][i];
    db[tt] = std::max({db[u], lt[u] + da[v], lt[u] + lt[v]});
    fb[tt] = fb[u], fb[tt].resize(db[tt]+1);
    for (int i=1; i<=da[v]; i++) fb[tt][lt[u]+i] += fa[v][i];
    fa[tt][lt[v]] += a[pb[v]], fb[tt][lt[u]+lt[v]] += a[pb[v]];
    return f[ls[tt] = u] = f[rs[tt] = v] = tt, tt++;
}
namespace Build {
    int o[N], t[N], p[N+1], ct;
    struct cmp{bool operator()(int x, int y){return w[x]>w[y];}};
    int dc(int l, int r) {
        if (l == r - 1) return o[l];
        for (int i=l, k=p[l]+p[r]>>1; i<r; i++)
            if (p[i] > k) return cp(dc(l, i), dc(i, r));
        return cp(dc(l, r-1), o[r-1]);
    }
    int bd(int c) {
        if (!~sn[c]) return -1;
        std::priority_queue<int, std::vector<int>, cmp>q;
        for (int u=c, x, y; ~sn[u]; u=sn[u]) {
            for (auto[v, f] : g[u]) if (f && v != sn[u])
                x = nw(u, v), y = bd(v), q.push(~y ? cp(x, y) : x);
            for (; q.size() > 1; q.push(rk(x, y)))
                x = q.top(), q.pop(), y = q.top(), q.pop();
            if (t[u] = nw(u, sn[u]), q.size())
                t[u] = rk(t[u], q.top()), q.pop();
        }
        for (ct=0; ~sn[c]; c=sn[c], ct++)
            p[ct+1] = p[ct] + w[o[ct]=t[c]];
        return dc(0, ct);
    }
}
int main() {
    std::ios::sync_with_stdio(0), std::cin.tie(0);
    int n, m, rt; std::cin >> n >> m;
    for (int i=0; i<n; i++) std::cin >> a[i];
    for (int i=1, u, v; i<n; i++) std::cin >> u >> v,
        g[--u].emplace_back(--v, 0), g[v].emplace_back(u, 0);
    dfs(0), f[rt=Build::bd(0)] = -1;
    for (int i=0; i<tt; i++) FenT::acc(fa[i]), FenT::acc(fb[i]);
    for (int i=0, j, k; i<LT-1; i++) for (j=0, k=1<<i; k<=ct-(1<<i); j++, k++)
        st[i+1][j] = d[st[i][j]] < d[st[i][k]] ? st[i][j] : st[i][k];
    for (int op, x, y, t, ans = 0; m--;)
        if (std::cin >> op >> x >> y, x = (x ^ ans) - 1, y ^= ans, !op) {
            for (t=ed[x], ans=0; t!=rt; t=f[t]) {
                int d = t==rs[f[t]], p = (tp[f[t]]||d?pa:pb)[t], k = ds(x, p);
                if (k < y) ans += FenT::qr((tp[f[t]]||!d?fa:fb)[(d?ls:rs)[f[t]]], y-k);
                if (p = pb[(tp[f[t]]?rs:ls)[f[t]]], ds(x, p) <= y) ans += a[p];
            }
            if (ds(x, pa[t]) <= y) ans += a[pa[t]];
            if (ds(x, pb[t]) <= y) ans += a[pb[t]];
            printf("%d\n", ans);
        } else for (t=ed[x], y-=a[x], a[x]+=y; ~t; t=f[t]) if (x != pa[t] && x != pb[t])
            FenT::ad(fa[t], ds(pa[t], x), y), FenT::ad(fb[t], ds(pb[t], x), y);
}
```

---

## 作者：chzhc (赞：4)

# 点分治

点分治适合处理大规模的树上路径信息问题。

### 问题引入：

给定一棵有 $n$ 个点的树，两条边之间有边权，询问树上距离为 $k$ 的点对是否存在。

### 流程如下：

1. 选择当前树的重心作为根结点 $root$，所有完全位于其子树的路径可以分为两种，一是经过 $root$ 的路径，二是不经过 $root$ 的路径，显然，对于第一种路径，我们可以通过枚举其子节点来得到这些路径的答案；对于第二种路径我们可以通过递归 $root$ 子树来得到答案，即步骤 2。在步骤 1 最后，我们将 $root$ 标记为不可到达。
2. 对于 $root$ 的每一个直接相连的子节点构成的子树中，我们分别递归处理其子树。
3. 重复 1、2 两个步骤，直到所有结点都成为过 $root$。

时间复杂度  $\mathcal O(n \log n)$。

### 正确性证明：

对于任意一条路径 $u_1 \to u_2 \to \dots \to u_k$，设路径中在点分治中最早遍历到的点为 $u_w$，显然，这条路径一定会在 $u_w$ 为 $root$ 时被计算入答案，又考虑到 $u_w$ 在步骤 1 后会被标记为不可到达，故这条路径当且仅当在 $u_w$ 为 $root$ 时会被计算入答案。

### 时间复杂度证明：

考虑到每次选择的 $root$ 均为子树的重心，故只会有 $\log n$ 层，每一层统计答案 & 找重心的总复杂度为 $\mathcal O(n)$，故总时间复杂度为 $\mathcal O(n \log n)$。

# 点分树

### 问题引入：

给定一棵有 $n$ 个点的树，点有点权，有 $q$ 次操作，每次操作修改一个点权或询问所有与点 $x$ 距离小于等于 $k$ 的点的点权之和。

### 分析：

对于每次询问跑点分治显然行不通，我们发现每次点分治都会浪费时间在找重心 & 统计无用的答案，我们考虑把点分治的过程记录下来，即构造一棵点分树。

### 构造点分树流程：

流程很简单，选择当前树的重心作为 $root$，对于 $root$ 的每一个直接相连的子节点构成的子树中，我们分别找到其子树的重心作为新的 $root’$，将 $root'$ 在点分树上的父亲定为 $root$，将 $root$ 标记为不可到达，分别对子树递归处理即可。

### 性质：

1. 每一个结点均会出现在点分树中出现。
2. 树高为 $\log n$ 级别。
3. 对于任意两点 $u, v$，在点分树上的 LCA （设为 $w$）一定在原树 $u \to v$ 的路径上，即 $\operatorname{dist}(u, v) = \operatorname{dist}(u, w) + \operatorname{dist}(w, v)$。

由以上性质，我们可以便可以通过 $x$ 在点分树上跳父亲结点来找到所有经过 $x$ 的路径。

对于此问题，我们便可以通过维护动态开点值域线段树 + 容斥便可在 $\mathcal O(n \log n + q \log^2 n)$ 完成此题。



---

## 作者：chenxinyang2006 (赞：3)

~~什么叫写两次模板结果都被卡常啊~~

- 点分树

   点分树就是将每次点分治时重心的关系变为一颗树，从每个连通块的重心向这个联通块去掉重心后，形成的子问题的重心连边
  
  易知每个点都会在树上出现一次，也只会在树上出现一次，且树高不超过 $\log n$，每个点的子树就代表着这个点作为重心时，求解的联通块内的所有点
  
  如果要从 $u$ 走到 $v$，必定要走过 $LCA(u,v)$ 这个点，因为它 $u,v$ 属于 $LCA(u,v)$ 的不同子树，所以它们属于不同的子问题，去掉 $LCA(u,v)$ 后两点不连通，这是根据点分的过程决定的
  
- 本题解析

  先不管修改，那么本题求的是 $dis(x,v) \le k$ 的所有 $v$ 的 $value$ 之和
  
  我们考虑在 $LCA(x,v)$ 处统计 $v$ 的贡献，枚举 $u = LCA(x,v)$，那么满足条件的 $v$ 必定满足，$dis(u,v) \le k - dis(x,u)$ 
  
  但是这样会重复统计，而满足 $u = LCA(x,v)$ 的 $v$ 必定满足，$v,x$ 都在 $u$ 的子树内，且属于它的不同子树
  
  本题是求和，具备可减性，于是可以加上属于 $u$ 子树内满足条件的点，减掉 $pre$ 对于 $pre$ 父亲满足条件的点
  
  $pre$ 指的是 $u$ 的一个儿子，且满足 $u$ 在 $pre$ 的子树内 
  
  所以对于每个节点，要维护两个数据结构，满足查询：
  
  - 在 $x$ 的子树内，所有 $v$ 满足 $dis(x,v) \le k$ 的 $value$ 之和，$k$ 是每次给定的值
  
  - 在 $x$ 的子树内，所有 $v$ 满足 $dis(fa_x,v) \le k$ 的 $value$ 值之和
  
  因为修改对点分树的结构不会产生影响，所以对于固定的 $x,v$，$dis(x.v)$ 是固定的，我们可以直接把它作为一个下标，这样就是一个区间求和问题
  
  然后考虑修改对应过来是什么
  
  可以发现，受影响的 $u$ 的子树一定包含 $x$ 这个点，也就是 $u$ 一定是 $x$ 的祖先
  
  然后按照定义修改，发现实际上是单点修改
  
  单点修改，区间求和自然是线段树
  
  但是由于要开 $n$ 棵线段树，所以只能用动态开点
  
  有个方便的写法：枚举 $x$ 的所有祖先时，可以从 $x$ 点一个一个往上跳，就可以轻松求出每次的 $pre$ 了
  
  复杂度分析：
  
  对着树进行点分的复杂度是 $n \log  n$ 的
  
  初始化可以看做 $n$ 次修改，这样转化为 $n + m$ 次操作
  
  一次操作都是枚举 $x$ 的所有祖先，而 $x$ 的深度为 $\log n$ 级别的，也就是只修改 $\log n$ 个节点，每次修改都是在动态开点线段树上操作，那么实际上也是单次 $\log n$ 的，所以总复杂度是 $(n + m) \log^2 n$ 
  
- 欧拉序 + RMQ LCA

  点分树里要大量求两点间距离，用倍增 LCA 很容易被卡，所以顺便介绍一下 $O(1)$ 查询的 LCA
  
  首先 LCA 可以看做是 $u$ 到 $v$ 路径上深度最小的一个点
  
  所以我们只需要想办法表示出 $u$ 到 $v$ 的路径就可以了
  
  这里引入一个 dfs 序的变种：欧拉序，即在 dfs 时，每访问到一个节点都记录一次，无论是返回到父亲还是递归到儿子
  
  不难发现，这样每个节点都会被记录到很多次，设 $x$ 节点第一次被访问到的欧拉序为 $dfn_x$，那么 $[dfn_u,dfn_v]$ 区间包含哪些点呢？
  
  ~~实际上有很多点~~，可能包好 $LCA(u,v)$ 的子树内的所有点，但是一定不存在一个点不在 $LCA(u,v)$ 的子树内
  
  可以考虑用反证法证明
  
  设 $[dfn_u,dfn_v]$ 中包含一个点 $k$ 满足其不在 $LCA(u,v)$ 子树内
  
  那么它一定是从 $u$ 往上一直走，经过了连接 $LCA(u,v)$ 和 $fa_{LCA(u,v)}$ 的边才到达
  
  而根据 dfs 的性质，走到这条边时一定已经处理完了 $LCA(u,v)$ 子树内的所有点，所以 $k$ 不存在 
  
  而 $LCA(u,v)$ 子树内深度最小的点就是它自己
  
  所以写一个 ST 表维护欧拉序上的 RMQ，并维护最小值来源就可以了
  
被卡常的代码：

```cpp
#include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;
int n,m;
int a[100005];

int cnt;
int head[100005];
struct eg{
	int to,nxt;
}edge[200005];

void make(int u,int v){
	edge[++cnt].to = v;
	edge[cnt].nxt = head[u];
	head[u] = cnt;
}

namespace DIST{
	int cnt = 0;
    int deep[100005],dfn[200005],id[200005];
	void dfs(int now,int fa){
		deep[now] = deep[fa] + 1;
		++cnt;
		dfn[now] = cnt;
		id[cnt] = now;
		for(int i = head[now];i;i = edge[i].nxt){
			if(edge[i].to == fa) continue;
			dfs(edge[i].to,now);
			++cnt;
			id[cnt] = now;
		}
	}	
	int ST[18][200005],num[18][200005];
	void init(){
		dfs(1,0);
		/*for(int i = 1;i <= n;i++) printf("%d ",dfn[i]);
		printf("\n");
		for(int i = 1;i <= cnt;i++) printf("%d ",id[i]);
		printf("\n");*/
		for(int i = 1;i <= cnt;i++){
			ST[0][i] = deep[id[i]];
			num[0][i] = id[i];
		}
		for(int i = 1;i <= 18;i++){
			for(int j = 1;j <= cnt;j++){
				if(j + (1 << i) - 1 > cnt) break;
				ST[i][j] = min(ST[i - 1][j],ST[i - 1][j + (1 << (i - 1))]);
				if(ST[i - 1][j] > ST[i - 1][j + (1 << (i - 1))]) num[i][j] = num[i - 1][j + (1 << (i - 1))];
				else num[i][j] = num[i - 1][j];
			}
		}
	}
	int LCA(int u,int v){
		int x = dfn[u],y = dfn[v];
		if(x > y) swap(x,y);
		int d = log2(y - x + 1);
		if(ST[d][x] > ST[d][y - (1 << d) + 1]) return num[d][y - (1 << d) + 1];
		else return num[d][x];
	}
	int getdis(int u,int v){
		int d = LCA(u,v);
		//printf("dis(%d,%d) = %d\n",u,v,deep[u] + deep[v] - 2 * deep[d]);
		return deep[u] + deep[v] - 2 * deep[d];
	}
};

int vis[100005],siz[100005],mx[100005],rt,heavy;

void dfs1(int now,int fa){
	siz[now] = 1;
	for(int i = head[now];i;i = edge[i].nxt){
		if(edge[i].to == fa || vis[edge[i].to]) continue;
		dfs1(edge[i].to,now);
		siz[now] += siz[edge[i].to]; 
	} 
}

void dfs2(int now,int fa){
	mx[now] = siz[rt] - siz[now];
	for(int i = head[now];i;i = edge[i].nxt){
		if(edge[i].to == fa || vis[edge[i].to]) continue;
		dfs2(edge[i].to,now);
		mx[now] = max(mx[now],siz[edge[i].to]);
	}
	if(mx[now] < mx[heavy]) heavy = now;
} 

int fa[100005];//fa[i] i 在点分树上的父亲 

void solve(int x,int pre){//求解包含 x 的联通块,上级重心为 pre 
	rt = heavy = x;
	dfs1(x,0);
	dfs2(x,0);
	fa[heavy] = pre;
	vis[heavy] = 1;
	int tmp = heavy;
	for(int i = head[heavy];i;i = edge[i].nxt) if(!vis[edge[i].to]) solve(edge[i].to,tmp);
}

int T1[100005],T2[100005];
struct node{
	int val,l,r;
}tree[57800005];
#define ls tree[rt].l
#define rs tree[rt].r

void Q(int &x) {if(x == 0) x = ++cnt;}

void upload(int rt,int l,int r,int id,int v){
	tree[rt].val += v;
	if(l == r) return;
	int mid = l + r >> 1;
	if(id <= mid){
		Q(ls);
		upload(ls,l,mid,id,v);
	}else{
		Q(rs);
		upload(rs,mid+1,r,id,v);
	}
}

int query(int rt,int l,int r,int L,int R){
	if(!rt) return 0;
	if(l == L && r == R) return tree[rt].val;
	int mid = l + r >> 1;
	if(R <= mid){
		return query(ls,l,mid,L,R);
	}else if(L > mid){
		return query(rs,mid+1,r,L,R);
	}else{
		return query(ls,l,mid,L,mid) + query(rs,mid+1,r,mid+1,R);
	}
}

void modify(int x,int v){//给 x 加上 v
    int u = x; 
	while(u){
		int d = DIST::getdis(u,x);
		upload(T1[u],0,n,d,v);
		if(fa[u]) d = DIST::getdis(fa[u],x);
		upload(T2[u],0,n,d,v);
		u = fa[u];
	}
}

int ask(int x,int k){
	int u = x,ans = 0,pre = 0;
	while(u){
		int d = DIST::getdis(u,x);
		if(d <= k) ans += query(T1[u],0,n,0,k - d) - query(T2[pre],0,n,0,k - d);
		pre = u;
		u = fa[u];
	}
	return ans;
}

int main(){
	scanf("%d%d",&n,&m);
	for(int i = 1;i <= n;i++) scanf("%d",&a[i]);
	for(int i = 1;i < n;i++){
		int u,v;
		scanf("%d%d",&u,&v);
		make(u,v);
		make(v,u);
	}
	solve(1,0);
	//for(int i = 1;i <= n;i++) printf("%d ",fa[i]);
	DIST::init();
	cnt = 0;
	for(int i = 1;i <= n;i++) T1[i] = ++cnt;
	for(int i = 1;i <= n;i++) T2[i] = ++cnt;
	for(int i = 1;i <= n;i++) modify(i,a[i]);
	int op,u,k,lastans = 0;
	for(int i = 1;i <= m;i++){
		scanf("%d%d%d",&op,&u,&k);
		u ^= lastans;k ^= lastans;
		if(op == 0){
			lastans = ask(u,k);
			printf("%d\n",lastans);
		}else{
			modify(u,k - a[u]);
			a[u] = k;
		}
	}
	return 0;
} 
```


---

## 作者：金珂拉 (赞：2)

## 点分树

什么是点分树？

点分树是原树的一个重构。在点分治的时候，每次选取重心，这样分治的层数是 $\log n$ 级别的，我们把每次选取的重心与上一层的重心连起来，就成了深度只有 $\log n$ 级别的点分树。

如果对树型结构复杂度有了解的话，就能明白为什么这样重构后的树有着优良的性质了：因为层数少，所以很多暴力做法都是复杂度正确的。

很多看上去是 $O(n)$ 树上算法的复杂度，实际上是 $O(depth)$ 的复杂度，只要深度的范围有保证，复杂度就有保证。所以我们就可以通过将树重构来保证深度，从而保证复杂度。

## 应用

点分树的建树比较简单，具体应用则要具体题目具体分析。

以模板题为例，我们先考虑查询。

一个节点到其余节点的路径分为两种:在原树上经过该节点在点分树上的父亲的路径，与在原树上不经过该节点在点分树上的父亲的路径。

显然对于第二种路径我们可以直接在每个节点上维护在其点分树上的子树中，与其距离 $dist$ 满足 $dist<=k$ 的节点权值和。

对于第一种路径，我们可以把问题普遍化为，从 $x$ 经过 $p$，$dist<=k$ 的路径，且 $p$ 是 $x$ 的祖先。

于是我们继续分类，路径可以分为 经过 $p$ 的父亲的路径，经过 $p$ 但不经过其父亲的路径。

前一个问题显然与原问题等价，可以递归求解。

后一个问题，我们设 $x$ 所在的 $p$ 的子树的根为 $q$，即 $q$ 是 $p$ 的儿子且 $q$ 是 $x$ 的祖先 。

显然路径可以从中间切开来，变成 $x$ 到 $p$ 的路径与 $p$ 到终点的路径，且第二条路径不能经过 $q$ 所在的子树中的节点，而第一条路径的长度是确定的。

于是我们可以用 $p$ 到其子树中 $dist<=k-dist(x,p)$ 的路径减去 $p$ 到 $q$ 子树中长度 $dist<=k-dist(x,p)$ 的路径在得到。

即，我们令 $Ans(x,p,k)$ 为所有 $dist_{x,y}<=k$ 且 $x$ 到 $y$ 的路径经过 $p$ 的 $y$ 的权值和，$query_1(p,k)$ 为所有 $dist_{p,y}<=k$ 且 $y$ 在点分树上是 $p$ 子树的 $y$ 的权值和，$query_2(p,k)$ 为所有 $dist_{y,fa_p}<=k$ 且 $y$ 在点分树上是 $p$ 子树的 $y$ 的权值和，那么有公式

$$
Ans(x,p,k)=Ans(x,fa_p,k)+query_1(p,k-dist(x,p))-query_2(q,k-dist(x,p))
$$

其中 $p=fa_q$,且 $p$、$q$ 为 $x$的祖先。

我们最后要求的答案就是

$$
Ans(x,fa_p,k)+query_1(x,k)
$$

至于修改，显然我们可以暴力向上跳。我们需要一个可以维护单点修改、前缀查询的结构，用动态开点线段树或者树状数组即可。时间复杂度为 $O(n\log^2n)$。因为空间问题，我们可以用 ```int *tree=new int[sz(x)]``` 来开树状数组。

代码如下，因为强制在线以及常数问题，加上需要大量求距离会查询较多次LCA，所以个人建议使用 $O(n\log n)-O(1)$ 的欧拉序ST表LCA或者 $O(n)-O(1)$ 的四毛子LCA。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
class node{
	public:
	int nt,v,w;
}e[200003];
int tot,h[100003]; 
void add(int x,int y,int z)
{
	e[++tot].v=y;
	e[tot].w=z;
	e[tot].nt=h[x];
	h[x]=tot;
}
bool vis[100003];
int sz[100003],dp[100003],po[100003],fa[100003];
int getsize(int x){
	int ans=1;
	vis[x]=1;
	sz[x]=0;
	dp[x]=0;
	for(int i=h[x];i;i=e[i].nt)if(!vis[e[i].v]){
	ans+=getsize(e[i].v);
	}
	vis[x]=0;
	return ans;
} 
int getroot(int s,int x){
	vis[x]=1;
	for(int i=h[x];i;i=e[i].nt)if(!vis[e[i].v]){
	getroot(s,e[i].v);
	dp[x]=max(dp[x],sz[e[i].v]);
	sz[x]+=sz[e[i].v];
	}
	sz[x]++;
	dp[x]=max(dp[x],s-sz[x]);
	po[x]=x;
	for(int i=h[x];i;i=e[i].nt)if(!vis[e[i].v])
	if(dp[po[e[i].v]]<dp[po[x]]) po[x]=po[e[i].v];
	vis[x]=0;
	return po[x];
}
int siz[100003];
void get_pdtree(int x){
	vis[x]=1;
	for(int i=h[x];i;i=e[i].nt)if(!vis[e[i].v]){
	int s=getsize(e[i].v);
	int v=getroot(s,e[i].v);
	fa[v]=x;
	get_pdtree(v);
	siz[x]+=siz[v];
	}
	siz[x]++;
	vis[x]=0;
}
template<class T>
class ST{
	public:
	T dp[200003][18];
	int f[32],maxn[200003];
	void build(T a[],int n){
		f[0]=1;
		for(int i=1;i<=17;i++) 
		f[i]=f[i-1]*2;
		for(int i=1;i<=n;i++)
		dp[i][0]=a[i];
		for(int j=1;j<=17;j++)
		for(int i=1;i+f[j]-1<=n;i++)
		dp[i][j]=min(dp[i+f[j-1]][j-1],dp[i][j-1]);
		int p=-1;
		for(int i=1;i<=n;i++){
		if(i==f[p+1]) p++;
		maxn[i]=p;
		}
	}
	T query(int l,int r){
	int p=maxn[r-l+1];
	return min(dp[l][p],dp[r-f[p]+1][p]);
	}
}; 
ST<pair<int,int> > st;
int d[100003],cnt,p[100003],dis[100003];
pair<int,int> a[200003];
void dfs(int x){
    a[++cnt]={d[x],x};
	if(!p[x]) p[x]=cnt;
	for(int i=h[x];i;i=e[i].nt)
	if(!d[e[i].v] && e[i].v!=1) {
	d[e[i].v]=d[x]+1;
	dis[e[i].v]=dis[x]+e[i].w;
	dfs(e[i].v);	
	a[++cnt]={d[x],x};
	}
}
int LCA(int l,int r){
	if(p[l]>p[r]) swap(l,r);
    return st.query(p[l],p[r]).second;
}
class bitarray{
	public:
	int* tree;
	int n;
	void init(int x){n=x;tree=new int[n+1];for(int i=1;i<=n;i++) tree[i]=0;}
	void update(int x,int val){
		for(;x<=n;x+=x&(-x))tree[x]+=val;
	} 
	int query(int x){
		if(x<=0) return 0;
		x=min(x,n);
		int sum=0;
		for(;x;x-=x&(-x)) sum+=tree[x];
		return sum;
	}
}Tr[100003],Tf[100003];
int val[100003];
int maxn;
int dist(int x,int y){
	if(x==y) return 0;
	int lca=LCA(x,y);
	int ans=dis[x]+dis[y]-2*dis[lca];
	maxn=max(maxn,ans);
	return ans;
}
int test; 
void update(int x,int val){
	int p=x;
	while(p){
	Tr[p].update(dist(x,p)+1,val);
	if(fa[p])Tf[p].update(dist(x,fa[p])+1,val);
	p=fa[p];
	}
} 
int query(int x,int k){
	int p=x,ans=Tr[x].query(k+1);
	while(fa[p]){
	int d=dist(fa[p],x);
	ans-=Tf[p].query(k-d+1);
	ans+=Tr[fa[p]].query(k-d+1);
	p=fa[p];
	}
	return ans;
}
int rt;
int main(){
	int m;
	cin>>n>>m;	
	for(int i=1;i<=n;i++){
	scanf("%d",&val[i]);
	}
	for(int i=1;i<n;i++){
	int x,y,z=1;
	scanf("%d%d",&x,&y);
	add(x,y,z);
	add(y,x,z);
	}
	dfs(1);
	st.build(a,cnt);
	rt=getroot(n,1);
	fa[rt]=0;
	get_pdtree(rt);
	for(int i=1;i<=n;i++) Tr[i].init(siz[i]+2),Tf[i].init(siz[i]+2);
	for(int i=1;i<=n;i++) update(i,val[i]);
	int last=0;
	for(int i=1;i<=m;i++){
	int op,x,y;
	scanf("%d%d%d",&op,&x,&y);
	x^=last,y^=last;
	if(op) {update(x,y-val[x]);val[x]=y;}
	else {last=query(x,y);printf("%d\n",last);}
	}
}
```



---

## 作者：王大神——A001 (赞：2)

[点分治](https://wdsa001.github.io/2021/12/24/dian-fen-zhi-dian-fen-shu/#toc-heading-1)

## 点分树
[传送门](https://www.luogu.com.cn/problem/P6329)

题目要我们求点覆盖的权值和单点修改。

和点分治的思路相同的是要找重心，要存节点来源（下面叫做父节点），在点分治的题中我们确定的是长度是否存在。但是本题我们求的是范围点值和。

我们是根据离点的距离确定范围，那么我们就可以通过存储每个深度（到当前节点的距离）来处理权值和（这里我们用的是 [树状数组](https://wdsa001.github.io/2021/09/18/shu-zhuang-shu-zu/)）。

同时我们要存储当前节点的父节点的深度的权值信息，这样我们就能在从当前节点往回爬的时候更方便的去重。

### 代码思路

- 初始化并读取基本信息（节点权值和连边）。

- 找重心。

- 处理所有节点到重心的距离，深度贡献的权值。统计处理父节点相关情况。

- 找新重心，继续处理上边的步骤。

- 覆盖权值询问。

- 统计当前节点的贡献。

- 跳父节点们继续处理贡献同时去重（有些权值贡献多次），结束条件是父节点到节点的距离在覆盖范围内。

- 输出统计结果，同时记录结果（信息解密要用）。

- 单点修改。

- 从当前节点往根节点跳（只对这些点有贡献），树状数组单点修改，接的同时处理记录父节点情况。

- 城市权值修改。

### 代码
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<string>
#include<cstring>
#include<cctype>
#include<map>
#include<vector>
using namespace std;
long long r_r(){//快读 
	long long x=0,f=1;
	char c=getchar();
	while(!isdigit(c)){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(isdigit(c)){
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return x*f;
}
const int o_o=2e5+5;
int l_t(int x){
	return x&(-x);
}
int n,m;
int a_s;//结果 
int l_a;//上次输出，用于解密 
int f[o_o];
int d[o_o];
int b_b[o_o];//标记节点是否当过重心 
int d_p[o_o];//记录当前重心下每个节点的深度 
int m_d_p;//记录当前重心形成的树的最大深度 

//链式前向星存边 
struct po{
	int v;
	int n_t;
}p_p[o_o<<1];//存边 
int x_p,h_d[o_o];

int v_v[o_o];//每个节点（城市）的权值 
map<int,int>i_d[o_o];//记录每个节点在不同重心时的深度 
vector<int>l_s[o_o];//当前重心时上次重心的区间和 
vector<int>n_s[o_o];//当前重心时的区间权值和 
void a_d(int u,int v){//连边 
	p_p[++x_p].v=v;
	p_p[x_p].n_t=h_d[u];
	h_d[u]=x_p;
}
int g_g;//根节点（重心） 
int s_n;
int m_s[o_o];//当前节点最大子树 
int s_z[o_o];//子树大小 
void d_f(int x,int f_a){//找根节点 
	s_z[x]=1;//初始化子树大小 
	m_s[x]=0;//初始化当前节点最大子树 
	for(int i=h_d[x];i;i=p_p[i].n_t){//遍历边 
		if(p_p[i].v!=f_a&&!b_b[p_p[i].v]){
			d_f(p_p[i].v,x);
			s_z[x]+=s_z[p_p[i].v];//累计子树大小 
			m_s[x]=max(m_s[x],s_z[p_p[i].v]);//更新最大子树 
		}
	}
	m_s[x]=max(m_s[x],s_n-s_z[x]);
	if(m_s[x]<m_s[g_g])g_g=x;//更新根节点 
}
void a_d(int k_k,int x,int v){
	int t=n_s[k_k].size();//当前的深度范围 
	while(x<t){//在范围内 
		n_s[k_k][x]+=v;//累计区间深度权值 
		x+=l_t(x);
	}
}
void a_d2(int k_k,int x,int v){
	int t=l_s[k_k].size();//上个根节点（重心）的范围 
	while(x<t){
		l_s[k_k][x]+=v;//累计区间深度权值 
		x+=l_t(x);
	}
}
int q_1(int k_k,int x){
	int r_s=0;
	if(x>=n_s[k_k].size())
		x=(int)n_s[k_k].size()-1;
	//限制区间范围（深度只有这些，范围再大也没用） 
	
	while(x){
		r_s+=n_s[k_k][x];//统计目标深度范围内的权值 
		x-=l_t(x);
	}
	return r_s;
}
int q_2(int k_k,int x){
	int r_s=0;
	if(x>=l_s[k_k].size())
		x=(int)l_s[k_k].size()-1;
	//限制区间范围（深度只有这些，范围再大也没用） 
	
	while(x){
		r_s+=l_s[k_k][x];//统计目标深度范围内的权值 
		x-=l_t(x);
	}
	return r_s;
}
void c_1(int x,int f_a,int k_k){
	s_z[x]=1;//初始化子树大小 
	d_p[x]=d_p[f_a]+1;//更新深度 
	i_d[k_k][x]=d_p[x];//记录深度 
	for(int i=h_d[x];i;i=p_p[i].n_t)//遍历所有相连的点 
		if(!b_b[p_p[i].v]&&p_p[i].v!=f_a){//没有当过重心并且不是父节点 
			c_1(p_p[i].v,x,k_k);//先遍历子节点 
			s_z[x]+=s_z[p_p[i].v];//更新子树大小 
		}
	m_d_p=max(d_p[x],m_d_p);//更新最大深度 
}
void c_2(int x,int f_a,int k_k,int k){
	a_d(k_k,d_p[x],v_v[x]);
	//当 k_k 为根节点时，x 节点的深度和权值传参 
	
	if(k)a_d2(k_k,i_d[k][x],v_v[x]);
	//不是初始点，当 k_k 为根节点时，x节点在上一个重心的深度和权值 
	 
	for(int i=h_d[x];i;i=p_p[i].n_t)//遍历所有相连的点 
		if(!b_b[p_p[i].v]&&p_p[i].v!=f_a)//没当过重心并且不是父节点 
			c_2(p_p[i].v,x,k_k,k);//继续遍历 
}
void f_t(int x,int f_a,int h){
	int m_x;
	b_b[x]=1;//标记，当前节点当过重心了 
	m_d_p=0;//初始化最大深度 
	c_1(x,0,x);//处理每个节点深度和子树大小 
	for(int i=0;i<=m_d_p;++i)n_s[x].push_back(0);//初始化 
	for(int i=0;i<=h;++i)l_s[x].push_back(0);//初始化 
	m_x=m_d_p;//记录最大深度 
	c_2(x,0,x,f_a);//维护所有节点在当前重心和上一个重心时的区间和 
	for(int i=h_d[x];i;i=p_p[i].n_t){//遍历所有相连的点 
		if(b_b[p_p[i].v])continue;
		s_n=s_z[p_p[i].v];//更新节点数量 
		
		//初始化（找别的重心） 
		g_g=0;
		m_s[0]=0x3f3f3f3f;
		d_f(p_p[i].v,x);//初始化新重心 
		f[g_g]=x;//更新父节点 
		f_t(g_g,x,m_x);//继续处理 
	}
}
int main(){
	n=r_r(),m=r_r();
	for(int i=1;i<=n;++i)v_v[i]=r_r();//读入每个城市的价值 
	for(int i=1;i<n;++i){//连边 
		int u=r_r(),v=r_r();
		a_d(u,v);
		a_d(v,u);
	}
	//初始化 
	g_g=0;
	m_s[0]=0x3f3f3f3f;
	s_n=n;//记录节点总数量 
	d_f(1,0);//找重心 
	f_t(g_g,0,0);//处理所有节点成为重心的情况 
	while(m--){//处理询问 
		int op=r_r(),x=r_r()^l_a,v=r_r()^l_a;//解密 
		if(!op){//统计权值 
			int f_x=f[x];//记录父节点 
			int l_x=x;//记录当前节点 
			int f_d;//记录深度 
			a_s+=q_1(x,v+1);//记录当前节点范围内的权值 
			while(f_x){//没有到根就一直爬 
				f_d=i_d[f_x][x]-1;//记录深度 
				if(v-f_d<0){//不在影响范围内 
					l_x=f_x;//记录这次节点 
					f_x=f[f_x];//往上爬 
					continue;
				}
				a_s+=q_1(f_x,v-f_d+1);//统计贡献 
				a_s-=q_2(l_x,v-f_d+1);//去重 
				l_x=f_x;//记录节点 
				f_x=f[f_x];//往上爬 
			}
			printf("%d\n",(l_a=a_s)); 
			a_s=0;
		}else{//单点修改 
			int k_k=x;//记录节点 
			a_d(x,1,-v_v[x]+v);//当前节点区间修改 
			while(f[x]){//没有到根就一直爬
				int f_d=i_d[f[x]][k_k];//记录深度 
				
				//更新区间权值 
				a_d(f[x],f_d,-v_v[k_k]+v);
				a_d2(x,f_d,-v_v[k_k]+v);
				
				x=f[x];//往上爬 
			}
			v_v[k_k]=v;//节点权值更新 
		}
	}
	return 0; 
}

```

### 优化

这份代码不仅慢，空间也大，但可以过。。。

但是，可以优化。

### 时间空间优化

前置知识：[树链剖分](https://wdsa001.github.io/2021/08/31/shu-lian-pou-fen/)

在上面代码中，我们直接用一个二维数组（`map` 也占一维）将每个节点在不同重心时的深度记录下来了，但是由于本题的数据范围不是很大，所以 $O(\log n)$ 和一个大常数差不多，不会过多影响时间效率，但是大大节省了空间。

我们将整颗树剖分一遍，首先我们用树剖是解决快速求出每个节点在不同重心时的深度，就是当前节点在不同重心的距离，那么我们就可以通过树剖求两点的公共祖先，从而快速获得长度。

同时，上面为了防止浪费空间我们用的 `map` 存储。但是它的内部是红黑树，每多一个值都要插入，还要调整整棵树（`unordered_map` 效率更高，但是也很慢）。

所以，我们用树剖求 `lca` 实现了时空双赢！

### 优化代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<string>
#include<cstring>
#include<cctype>
#include<map>
#include<vector>
using namespace std;
long long r_r(){//快读 
	long long x=0,f=1;
	char c=getchar();
	while(!isdigit(c)){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(isdigit(c)){
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return x*f;
}
const int o_o=1e5+10;
int v_v[o_o<<1],h_d[o_o],n_t[o_o<<1],x_p;//链式前向星 
void a_d(int u,int v){//加边 
	v_v[++x_p]=v;
	n_t[x_p]=h_d[u];
	h_d[u]=x_p;
}
bool b_b[o_o];//判断是否当过根节点 
int s_z[o_o];//子树总量（子树节点个数） 
int m_s[o_o];//最大子树 
int s_n;//节点数量 
int g_g;//根节点（当前重心） 
void f_g(int x,int f_a){//处理重心 
	s_z[x]=1;//初始化子树重量 
	m_s[x]=0;//初始化最大子树 
	for(int i=h_d[x];i;i=n_t[i]){
		int v=v_v[i];
		if(!b_b[v]&&v!=f_a){//没有当过重心不是父节点 
			f_g(v,x);
			s_z[x]+=s_z[v];//累计子树重量 
			m_s[x]=max(m_s[x],s_z[v]);//更新最大子树 
		}
	}
	m_s[x]=max(m_s[x],s_n-s_z[x]);
	if(m_s[x]<m_s[g_g])g_g=x;//更新根节点（重心） 
}
struct ss{
	vector<int> v_l;
	int l_n;
	ss(){}
	ss(int l_i){//初始化长度 
		l_n=l_i+1;
		v_l.resize(l_i+2);
	}
	void g_a(int k,int v){//树状数组更新权值 
		for(int i=k+1;i<=l_n;i+=i&(-i))v_l[i]+=v;
	}
	int q_i(int k){//树状数组统计权值 
		int r_s=0;
		for(int i=min(k+1,l_n);i>0;i-=i&(-i))r_s+=v_l[i];//注意边界 
		return r_s;
	}
}n_x[o_o],l_x[o_o];
int i_d[o_o];//子树中节点编号 
int n_i;//子树中节点的数量 
int d_p[o_o];//节点深度 
void s_l(int x,int f_a){//记录子树中所有节点 
	i_d[++n_i]=x;//进入队中 
	d_p[x]=d_p[f_a]+1;//更新深度 
	for(int i=h_d[x];i;i=n_t[i]){
		int v=v_v[i];
		if(!b_b[v]&&v!=f_a)s_l(v,x);//在子树中并且不是父节点继续找 
	}
}
int v_l[o_o];//节点权值 
int l_i[o_o],r_i[o_o];//记录左右端点 
int m_p[o_o];//当前节点的深度 
int g_i[o_o];//记录节点的所属的根节点 
void b_t(int k){//处理当前根节点整棵树的节点的深度，管辖范围深度对应的权值 
	n_i=0;//队列下标重置 
	d_p[k]=0;//初始化深度 
	int m_d_p=0;//初始化最大深度 
	for(int i=h_d[k];i;i=n_t[i]){
		int v=v_v[i];
		if(!b_b[v]){//在子树范围内 
			l_i[v]=n_i+1;//记录左端点 
			s_l(v,k);
			r_i[v]=n_i;//记录右端点 
			m_p[v]=0;//初始化节点深度 
			for(int j=l_i[v];j<=n_i;j++)//范围内最大深度节点 
				m_p[v]=max(m_p[v],d_p[i_d[j]]);//当前节点子树中最大深度更新 
			m_d_p=max(m_d_p,m_p[v]);//更新总子树最大深度 
		}
	}
	
	//处理当前节点信息 
	n_x[k]=ss(m_d_p);//初始化长度 
	n_x[k].g_a(0,v_l[k]);//树状数组统计区间权值 
	for(int i=h_d[k];i;i=n_t[i]){
		int v=v_v[i];
		if(!b_b[v]){//子树范围内 
			int g_g=g_i[v];//记录根节点 
			l_x[g_g]=ss(m_p[v]);//更新子树长度 
			for(int j=l_i[v];j<=r_i[v];++j){//枚举子树元素 
				int x=i_d[j];//记录当前下表 
				
				//根据深度更新权值 
				n_x[k].g_a(d_p[x],v_l[x]);//更新当前节点权值 
				l_x[g_g].g_a(d_p[x],v_l[x]);//更新子树节点权值 
			}
		}
	}
}
int f_a[o_o];//记录父节点 
void d_f(int x){
	b_b[x]=1;//标记节点当过重心 
	for(int i=h_d[x];i;i=n_t[i]){
		int v=v_v[i];
		if(!b_b[v]){//在子树范围内（没当过重心） 
			s_n=s_z[v];//更新子树中节点数量 
			
			//更新重心 
			g_g=0;
			f_g(v,0);
			g_i[v]=g_g;//记录子树所属的根节点 
			f_a[g_g]=x;//记录父节点 
		}
	}
	b_t(x);//处理整棵树的相关信息 
	for(int i=h_d[x];i;i=n_t[i]){
		int v=v_v[i];
		if(!b_b[v])d_f(g_i[v]);//处理所有子节点 
	}
}

//树链剖分部分 
int f_i[o_o];//父节点 
int b_s[o_o];//字数最大子节点更新 
int t_p[o_o];//记录链顶 
void d_1(int x,int f_a){
	s_z[x]=1;//初始化子树节点大小 
	f_i[x]=f_a;//更新父节点 
	d_p[x]=d_p[f_a]+1;//更新深度 
	for(int i=h_d[x];i;i=n_t[i]){
		int v=v_v[i];
		if(v!=f_a){//不是父节点（不会跑环） 
			d_1(v,x);
			s_z[x]+=s_z[v];//累计子树大小 
			if(s_z[v]>s_z[b_s[x]])b_s[x]=v;//更新子树最大的子节点 
		}
	}
}
void d_2(int x,int t_n){
	t_p[x]=t_n;//记录链顶 
	if(!b_s[x])return; 
	d_2(b_s[x],t_n);//继续跑链 
	for(int i=h_d[x];i;i=n_t[i]){
		int v=v_v[i];
		if(v!=f_i[x]&&v!=b_s[x])d_2(v,v);//开新链 
	}
}
int l_a(int x,int y){//找公共祖先 
	while(t_p[x]!=t_p[y]){//跳到一条链上 
		if(d_p[t_p[x]]<d_p[t_p[y]])swap(x,y);
		x=f_i[t_p[x]];//往回爬 
	}
	return d_p[x]<d_p[y]?x:y;//节点小的时公共祖先 
}

int g_d(int x,int y){//计算距离 
	return d_p[x]+d_p[y]-(d_p[l_a(x,y)]<<1);
}
int q_i(int x,int k){//查询 
	int r_s=n_x[x].q_i(k);//记录权值和 
	int k_k=x;
	while(f_a[k_k]){
		int d=g_d(f_a[k_k],x);//计算距离 
		
		if(d<=k)r_s+=n_x[f_a[k_k]].q_i(k-d)-l_x[k_k].q_i(k-d);
		//统计路径上去重后的结果（注意在范围内的节点权值才统计） 
		
		k_k=f_a[k_k];//往回爬  
	}
	return r_s;
}
void g_a(int x,int v){//单点修改 
	int k_k=v-v_l[x];//变化的值 
	if(!k_k)return;//没有变化不用改 
	v_l[x]=v;//改权值 
	n_x[x].g_a(0,k_k);//子树树状数组范围权值更新 
	int x_x=x;
	while(f_a[x_x]){
		int d=g_d(f_a[x_x],x);//计算距离 
		n_x[f_a[x_x]].g_a(d,k_k);//更新父节点范围权值和 
		l_x[x_x].g_a(d,k_k);//更新子树范围权值和 
		x_x=f_a[x_x];//往根处爬 
	}
}
int main(){
	int n=r_r(),m=r_r();
	for(int i=1;i<=n;++i)v_l[i]=r_r();//记录节点权值 
	for(int i=1;i<=n-1;++i){//加边 
		int u=r_r(),v=r_r();
		a_d(u,v);
		a_d(v,u);
	}
	m_s[0]=n+1;//初始化 
	s_n=n;//记录节点数量 
	f_g(1,0);//处理重心 
	d_f(g_g);//处理整个树的基本信息 
	
	//将整棵树剖分 
	d_1(1,0);
	d_2(1,1);
	
	int l_s=0;//记录上次结果，用于解密 
	while(m--){
		int op=r_r(),x=r_r()^l_s,k=r_r()^l_s;//解密 
		if(op==0)printf("%lld\n",l_s=q_i(x,k));//询问范围内权值和 
		else g_a(x,k);//单点修改 
	}
	return 0;
}
```


---


# 兰奇的卡牌游戏

## 题目描述

作为制卡大师的兰奇，发明了一种自助型卡牌游戏。

给定 $n$ 张卡牌，第 $i$ 张卡牌编号为 $i$，其权值为 $a_i$，卡牌的权值互不相同。

这个卡牌游戏的规则需要自己生成。一开始，所有的牌都在备选区。从备选区中选取一张编号最小的卡牌放到手牌区，便可进入规则生成阶段。

规则生成阶段的步骤如下：

1. 将手牌区的任意一张牌弃置到废牌区之中。

1.  然后在备选区中选择一张编号和权值均大于当前弃牌的牌，加入手牌区。若存在这样的一张牌，则称这张牌与弃牌互为置换；若不存在这样的一张牌，则跳过当前步骤。

1. 继续从备选区中选择一张编号大于当前弃牌且权值小于当前弃牌的牌，加入手牌区。若存在这样的一张牌，则同样可称这张牌与弃牌互为置换；若不存在这样的一张牌，则跳过当前步骤。

1. 完成以上步骤后，若手牌区没有卡牌了，则规则生成阶段结束。若仍有卡牌，则继续重复上述步骤，直到手牌区没有卡牌。

为了保证生成置换的唯一性，兰奇规定规则生成阶段合法当且仅当规则生成结束后，所有的牌都在废牌区。并且在正式游戏阶段一张编号较大的牌经过一系列操作后得到一张编号较小的牌后，该编号较大的牌，均要满足能够有机会按照在手牌区出现过的该张编号较小的牌的弃牌后生成的置换相同的步骤在规则生成阶段成为编号较小的牌的置换；若手牌区未出现该张编号较小的牌的弃牌后生成的置换，则无需考虑。否则，生成的置换是无效的。

可以证明在规则生成阶段合法的情况下，每张卡牌可以与哪些卡牌互为置换的方案是唯一的。

正式游戏阶段的步骤如下：

1. 选择任意一张卡牌作为起始卡牌并加入手牌区，然后进入下一步骤。

1. 将前手牌区的卡牌弃入废牌堆，然后从备选区中选择一张该卡牌的置换加入手牌区。若当前弃置的卡牌在备选区没有置换，则正式游戏阶段结束；反之，则得分增加 $1$ 分，然后继续重复步骤 2。

游戏发售后，销量并不是很好。因为游戏规则太复杂了。玩家们希望删去一些卡牌，使得正式游戏阶段的最大得分不超过 $k$。

而兰奇为了保证游戏的不做太大的改动，他要求删去一些卡牌后，保留下来的任意一张卡牌重新生成的置换要与原来未删去卡牌情况下的置换相同。

删去后置换仍相同的定义是：设 $S$ 表示某一张卡牌，未删除任何一张卡牌时的置换集合；$T$ 表示该张卡牌，在删除了部分卡牌时的置换集合。此时，满足 $T \subseteq S$。则称删去部分卡牌后，该卡牌的置换与原来未删去卡牌情况下的置换相同。

兰奇想知道，在满足了玩家和自己的要求的前提下，他最少要删除几张卡片。


## 说明/提示

**【样例1解释】**

编号为 $1$ 的卡牌与编号为 $2$ 的卡牌互为置换，编号为 $2$ 的卡牌与编号为 $3$ 的卡牌互为置换。

所以，在不删去的情况下，获得最大得分的方案是：用编号为 $1$ 的卡牌作为起始卡牌置换出编号为 $2$ 的卡牌，然后再置换出编号为 $3$ 的卡牌。该方案的最大得分为 $2$，所以不需要删除任何一张卡牌。

**【数据范围】**

**本题采用捆绑测试**。

- Subtask 1（15 points）：$n \le 10$。
- Subtask 2（5 points）：$k = n$。
- Subtask 3（80 points）：无特殊限制。

对于所有测试数据，$1 \le n \le 2000$，$1 \le a_i \le 10^9$。

## 样例 #1

### 输入

```
3 2
1 2 3```

### 输出

```
0```

## 样例 #2

### 输入

```
6 2
3 2 7 99 10 15```

### 输出

```
3```

# 题解

## 作者：yingxilin (赞：5)

# 题解：P11411 兰奇的卡牌游戏

今天来讲一个超级缝合题目，所以要先讲一些前置。

## 前置知识——单调栈

### [USACO06NOV] Bad Hair Day S

[题目入口](https://www.luogu.com.cn/problem/P2866)。

### 思路

单调栈板子，保证栈顶最大，从前往后遍历，栈顶比当前小的就删掉。并在每次入栈后将栈中剩余统计入答案。

### code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=8e4+5;
int n;
int st[N];
int h[N];
int cur;
int ans;
int main(){
//    freopen("test.in","r",stdin);
//    freopen("test.out","w",stdout);
    cin>>n;
    for(int i=1;i<=n;i++) cin>>h[i];
    for(int i=1;i<=n;i++){
        while(cur&&h[i]>=st[cur]) cur--;
        // if(cur==0||h[i]>st[cur]) st[++cur]=h[i];
        ans+=cur;
        st[++cur]=h[i];
    }
    cout<<ans<<endl;
    return 0;
}
```

OK，再看下一个前置知识。

## 前置知识——笛卡尔树

### 【模板】笛卡尔树

[题目入口](https://www.luogu.com.cn/problem/P5854)。

### 思路

以当前为根，从左往右走，如果能放在当前右子树，否则就一直往上找，直到找到当前的权值 $p_i$ 比当前点的权值 $p_i$ 大，则符合条件，放在其右子树。对于向上找时跳过的不符合条件的点，则将其放在当前接入点的左儿子。
那么，这样子的复杂度就是 $O(N^2)$。考虑将向上遍历直到找到当前的权值 $p_i$ 比当前点的权值 $p_i$ 大这一步骤优化，即找到先前序列中位于该位置之前的以一个大于该值的树。由此想到了单调栈。
所以做法大致是贪心和单调栈。

### code

注意要输入解绑，不然会 TLE（实践出真知）。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e7+5;
int st[N];
int a[N];
int n;
int l[N],r[N];
void build(){
	int top=0,cur=0;
	for(int i=1;i<=n;i++){
		while(cur&&a[st[cur]]>a[i]) cur--;
		//cur:插在某个结点的右子树上
		if(cur) r[st[cur]]=i;
		//cur<top:插在某个结点的左子树上
		if(cur<top) l[i]=st[cur+1];
		st[++cur]=i;
		top=cur;
	}
}
signed main(){
	ios::sync_with_stdio(NULL);
	cin.tie(NULL);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	build();
	int ans=0;
	for(int i=1;i<=n;i++) ans^=1LL*i*(l[i]+1);
	cout<<ans<<" ";
	ans=0;
	for(int i=1;i<=n;i++) ans^=1LL*i*(r[i]+1);
	cout<<ans<<endl;
	return 0;
}

```

## 前置：最近公共祖先（LCA）

### 【模板】最近公共祖先（LCA）

[题目入口](https://www.luogu.com.cn/problem/P3379)。

### 大致思路

就原本是两个点一步一步往上跳直到跳到同一点上。优化的方法是根据两个节点的的深度，如不同，向上调整深度大的节点，使得两个节点在同一层上，如果正好是祖先，结束；否则，将两个节点同时上移，查询最近公共祖先（两个过程均使用倍增加速）。

### code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+5;
int n,m,rt;
vector<int>g[N];
int read()
{
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9') {if(c=='-') f=-1;c=getchar();}
	while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return x*f;
}
int f[N][21];//f[i][j] 结点i往上跳2^j步的祖先结点
//f[i][j]=f[f[i][j-1]][j-1]
int d[N];//d[i] 结点i处于第几层
void dfs(int u,int fa)
{
	f[u][0]=fa;
	for(int i=0;i<(int)g[u].size();i++)
	{
		int v=g[u][i];
		if(v==fa) continue;
		d[v]=d[u]+1;
		dfs(v,u);
	}
}
int get_lca(int x,int y)
{
	//d[x]>d[y]
	if(d[x]<d[y]) swap(x,y);
	int cha=d[x]-d[y];
	for(int i=20;i>=0;i--)
		if(cha>>i&1) x=f[x][i];//x和y处于同一层
	if(x==y) return x;
	for(int i=20;i>=0;i--)
		if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];
	return f[x][0];
}
int main()
{
	n=read();m=read();rt=read();
	for(int i=1;i<n;i++) 
	{
		int x=read(),y=read();
		g[x].push_back(y);g[y].push_back(x);
	}
	d[rt]=1;
	dfs(rt,rt);
	for(int j=1;j<=20;j++)
		for(int i=1;i<=n;i++)
			f[i][j]=f[f[i][j-1]][j-1];
	while(m--)
	{
		int x=read(),y=read();
		printf("%d\n",get_lca(x,y));
	}
	return 0;
}
```

## 最后看本题

### 思路

题目要求编号单调递增，可以满足小根堆的性质，权值可以满足左小右大，即二叉搜索树的限制。

所以所谓生成阶段就是生成了一颗笛卡尔树。且权值是第一关键字，编号是第二关键字。

最大得分就树的直径，可以枚举树的重心 $r$，判断每个节点于 $k/2$ 之间的关系并统计答案即可。

思路和官方题解比较相近，主要是实现方式不同。

### code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e7+50,M=1e5+5,mod=1e9+7;
const double pi=acos(-1);
int n,k,rt;
struct node
{
    int a,b;//编号，权值
}Qian[N];
bool cmp(node a,node b){return a.a<b.a;}
int r_son[N],l_son[N];
void build()
{
    stack<int>s;
    for(int i=1;i<=n;i++)
    {
        while(!s.empty()&&Qian[s.top()].b>Qian[i].b)
        {
            l_son[i]=s.top();
            s.pop();
        }
        if(!s.empty())r_son[s.top()]=i;
        s.push(i);
    }
    while(!s.empty())
    {
        rt=s.top();
        s.pop();
    }
}
vector<int>g[N];
void rebuild()
{
    for(int i=1;i<=n;i++)
    {
        if(l_son[i])
        {
            g[i].push_back(l_son[i]);
            g[l_son[i]].push_back(i);
        }
        if(r_son[i])
        {
            g[i].push_back(r_son[i]);
            g[r_son[i]].push_back(i);
        }
    }
}
int f[2005][32];//倍增信息
int dep[N];//点深度
void dfs(int u,int fa)
{
    dep[u]=dep[fa]+1;f[u][0]=fa;
    for(auto v:g[u])if(v!=fa) dfs(v,u);
}
void Wula()
{
    dfs(rt,0);
    for(int j=1;j<20;j++)
        for(int i=1;i<=n;i++)
            f[i][j]=f[f[i][j-1]][j-1];
}
int LCA(int x,int y)
{
    if(dep[x]<dep[y])swap(x,y);//x>=y,跳y
    int dis=dep[x]-dep[y];
    for(int i=0;i<11;i++)
        if(dis>>i&1) x=f[x][i];
    if(x==y) return x;
    for(int i=10;i>=0;i--)
        if(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i];
    return f[x][0];
}
int path(int x,int y)
{
    return max(0,dep[x]+dep[y]-2*dep[LCA(x,y)]);
}
int main()
{
	cin>>n>>k;
    for(int i=1;i<=n;i++) cin>>Qian[i].a,Qian[i].b=i;
    sort(Qian+1,Qian+n+1,cmp);
    build();
    rebuild();
    Wula();
    int AC=1e9+7;
    if(k%2==0)
    {
        int sd=k/2;
        for(int i=1;i<=n;i++)
        {
            int cnt=0;
            for(int j=1;j<=n;j++)
            {
                int ad=path(i,j);
                cnt+=(ad>sd?1:0);
            }
            AC=min(AC,cnt);
        }
        cout<<AC<<endl;
    }
    else
    {
        int Ying=k/2;
        for(int i=1;i<=n;i++)
        {
            for(auto v:g[i])
            {
                int cnt=0;
                for(int j=1;j<=n;j++)
                {
                    int ad=path(i,j),ad2=path(v,j);
                    cnt+=(ad>Ying&&ad2>Ying?1:0);
                }
                AC=min(AC,cnt);
            }
        }
        cout<<AC<<endl;
    }
    return 0;
}

```

最后在此处鸣谢 FRZ，Win，QC 等人对笔者的帮助。

---


# [TJOI2017] 城市

## 题目描述

从加里敦大学城市规划专业毕业的小明来到了一个地区城市规划局工作。这个地区一共有 $n$ 座城市，$n-1$ 条高速公路，保证了任意两运城市之间都可以通过高速公路相互可达，但是通过一条高速公路需要收取一定的交通费用。小明对这个地区深入研究后，觉得这个地区的交通费用太贵。

小明想彻底改造这个地区，但是由于上司给他的资源有限，因而小明现在只能对一条高速公路进行改造，改造的方式就是去掉一条高速公路，并且重新修建一条一样的高速公路（即交通费用一样），使得这个地区的两个城市之间的最大交通费用最小（即使得交通费用最大的两座城市之间的交通费用最小），并且保证修建完之后任意两座城市相互可达。如果你是小明，你怎么解决这个问题？


## 说明/提示

对于 $30\%$ 的数据，$1\leq n\leq 500$。

对于 $100\%$ 的数据，$1\leq n\leq 5000$。


## 样例 #1

### 输入

```
5
1 2 1
2 3 2
3 4 3
4 5 4```

### 输出

```
7```

# 题解

## 作者：getchar123 (赞：53)

**这题可以O($n^2$)过，以下是O（$n^2$)思路：**

暴力枚举删掉的边，使它分成两棵树，然后考虑连接哪两个点可以使最大交通费用最小

#### 这时有两种情况：

   1.要最大交通费用的两个点在同一棵树上

   2.最大费用的两个点分别在两棵树上
     
第一种情况是不会被连接的边影响的，我们要想办法连边让第二种情况的最大费用最小。~~显然是连接两棵树上直径的中点~~（这里别的题解都讲得比较详细，就不再赘述了）

# 重点来了：如何优化到O(n)
回顾O（$n^2$）的写法：在每去掉一条边后都分别在两棵树上用两遍bfs求树的直径。事实上只分别用一遍就行了。**对于一棵被分割出来的树，它直径的一端一定是未删边时树的直径的一端。**

```
反证：（此时a->d为原树上直径，b->e为要删的边）假设x1>x2，那么x1+y+z>x2
+y+z，则原树上直径为c->d，与条件矛盾。所以a距离b最远，a为新树上半径一端
	得证
```
![](https://cdn.luogu.com.cn/upload/pic/66890.png)

**优化后的时间复杂度依然达不到O（n），继续优化剩下一遍bfs：**

![](https://cdn.luogu.com.cn/upload/pic/66891.png)

(橙色为截掉的边，绿色为直径，左边蓝色为遍历到的点右边红色为遍历一遍的点，紫色为重复遍历的点)可以看到，在枚举删边时有很多点被重复遍历到了。**可以考虑第二次只遍历红色部分**。这样总共只将树遍历了一遍，可以达到O（n）。

![](https://cdn.luogu.com.cn/upload/pic/66898.png)

遍历到叶节点时更新直径（为了表述方便，所有边长度为1）（左边新树直径4，右边6）

### 维护直径中点

求出直径后，要寻找直径中点，此时如果遍历直径求中点，在极端情况下，时间复杂度还是O（$n^2$)。但可以发现，直径长度是单调不减的，因此**半径长度也单调不减**。可以由上次的中点推出这次的中点。

## 讲解~~瞎说~~时间到此结束
### 下面来梳理一遍思路
1. 求出原树上直径，记端点为r，l
2. 从直径左侧开始
3. 在直径上截边，遍历新增子树，更新直径
4. 上一次的中点后移，作为这一次中点
5. 更新半径
6. 存储信息
7. 重复步骤3-6，直到遍历完整个直径
8. 右侧同理
9. 扫描所有存储的信息，求出最终答案

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct bbbb{
	int to,nextt,xx;
}b[10010];
int n,tail,dd[5010],dis[5010],vis[5010],ldd,rdd,diss[5010],ttll;
struct llbb{
	int xxx,x;
}lb[5010];
struct cccc{
	int zjcd,bjcd,zd;
}cc1[5010],cc2[5010];
void jb(int x,int y,int z){
	tail++;
	b[tail].nextt=dd[x];
	b[tail].to=y;
	b[tail].xx=z;
	dd[x]=tail;
	return;
}
queue<int>q; 
void bfs(int x){
	memset(vis,0,sizeof(vis));
	dis[x]=0;
	vis[x]=1;
	q.push(x);
	while(q.empty()==false){
		int xx=q.front();q.pop();
		for(int i=dd[xx];i!=0;i=b[i].nextt){
			if(vis[b[i].to]==0){
				vis[b[i].to]=1;
				dis[b[i].to]=dis[xx]+b[i].xx;
				q.push(b[i].to);
			}
		}
	} 
	return;
}
bool dfs(int x,int mb){
	if(x==mb){
		ttll++;
		lb[ttll].x=x;
		return true;
	}
	for(int i=dd[x];i!=0;i=b[i].nextt){
		if(vis[b[i].to]==0){
			vis[b[i].to]=1;
			if(dfs(b[i].to,mb)==true){
				ttll++;
				lb[ttll].x=x;
				lb[ttll].xxx=b[i].xx;
				return true;
			}
		}
	}
	return false;
}
int bfs1(int x){
	int maxx=0;
	q.push(x);
	while(q.empty()==false){
		int xx=q.front();q.pop();
		maxx=max(maxx,diss[xx]);
		for(int i=dd[xx];i!=0;i=b[i].nextt){
			if(vis[b[i].to]==0){
				vis[b[i].to]=1;
				diss[b[i].to]=diss[xx]+b[i].xx;
				q.push(b[i].to);
			}
		}
	} 
	return maxx;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<n;i++){
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		jb(x,y,z);
		jb(y,x,z);
	}
	bfs(1);
	for(int i=1;i<=n;i++){
		if(dis[ldd]<=dis[i]){
			ldd=i;//左端点 
		}
	}
	bfs(ldd);
	for(int i=1;i<=n;i++){
		if(dis[rdd]<=dis[i]){
			rdd=i;//右端点 
		}
	}
	memset(vis,0,sizeof(vis));
	vis[ldd]=1;
	dfs(ldd,rdd);//存储树的直径 
//-------------上面是树的直径部分-----------------
	memset(vis,0,sizeof(vis));
	for(int i=1;i<=ttll;i++){
		vis[lb[i].x]=1;
	}
	int zhongd=1;
	for(int i=2;i<=ttll;i++){
		diss[lb[i].x]=diss[lb[i-1].x]+lb[i].xxx;
		int qwq=bfs1(lb[i].x);//遍历新子树 
		if(qwq<=cc1[lb[i-1].x].zjcd){
			cc1[lb[i].x]=cc1[lb[i-1].x];
		}
		else{
			while(zhongd<i&&max(diss[lb[zhongd].x],qwq-diss[lb[zhongd].x])>max(diss[lb[zhongd+1].x],qwq-diss[lb[zhongd+1].x])){
				zhongd++;//中点后移 
			}
			cc1[lb[i].x].zjcd=qwq;//更新直径 
			cc1[lb[i].x].bjcd=max(diss[lb[zhongd].x],qwq-diss[lb[zhongd].x]);//更新半径 
		}
	}
	memset(vis,0,sizeof(vis));
	memset(diss,0,sizeof(diss));
	for(int i=1;i<=ttll;i++){//右侧同理 
		vis[lb[i].x]=1;
	}
	zhongd=ttll;
	for(int i=ttll-1;i>=1;i--){
		diss[lb[i].x]=diss[lb[i+1].x]+lb[i+1].xxx;
		int qwq=bfs1(lb[i].x);
		if(qwq<=cc2[lb[i+1].x].zjcd){
			cc2[lb[i].x]=cc2[lb[i+1].x];
		}
		else{
			while(zhongd>i&&max(diss[lb[zhongd].x],qwq-diss[lb[zhongd].x])>max(diss[lb[zhongd-1].x],qwq-diss[lb[zhongd-1].x])){
				zhongd--;
			}
			cc2[lb[i].x].zjcd=qwq;
			cc2[lb[i].x].bjcd=max(diss[lb[zhongd].x],qwq-diss[lb[zhongd].x]);
		}
	}
	int minn=1e9;
	for(int i=1;i<ttll;i++){//扫描,求出最终答案 
		minn=min(minn,max(cc1[lb[i].x].bjcd+cc2[lb[i+1].x].bjcd+lb[i+1].xxx,max(cc1[lb[i].x].zjcd,cc2[lb[i+1].x].zjcd)));
	}
	printf("%d",minn);
	return 0;		
}
```
### -end-

p.s.如果哪里不是很清楚，欢迎私信提建议哦~

---

## 作者：shadowice1984 (赞：39)

好啦首先我们不要被数据范围吓到，常数适宜的情况下3s时限O(n^2)可以信仰过5000，毕竟只是相较1000翻了25倍，如果我们的算法可以在100-120ms内通过1000，就可以凭借信仰过掉这道题

# 本题题解

其实我们发现这道题是可以暴力枚举删那一条边的，这首先有了一个O(N)的复杂度
，我们接下来要用另一个O(N)处理最远点对的问题

那么删去这条边之后，整棵树将被分为两个联通块

那么此时的最长路有三种来源，

1.两个端点都在联通块1中

2.两个端点都在联通块2中

3.两个端点一个在联通块1，另一个在联通块2

对于1和2我们求一个树上直径即可，对于问题3呢?

我们发现，如果连接了u，v，那么最长路就是 u到联通块1任意一点的最长距离+val+v到联通块2的任意一点最长距离。如果我们适当的选取u和v，使得这两个点的到自己联通块的最长距离最小。那么就是最优的决策了。

也就是说我们要求树上的半径？

#### 树上半径求法

首先我们先做一边树形dp，对于每一个子树，求出经过它的最长链和次长链
然后直径就是枚举每一个点，它的最长链+次长链的最大值

那么半径呢？我们考虑一件事，就是距离它最远的那个点，在它的子树内还是子树外。

如果在子树内，距离就是第一遍dfs求出的最长链，如果在子树外的话，我们在树上在做第二遍dfs，这个dfs额外传一个from参数，from表示这个子树之外的最长链

那么这个最长链from有两个来源

1.它父亲的from+它和父亲的距离

2.它父亲的其他子树中的最长链+他和父亲的距离

对于情况二，如果他就是父亲的所有孩子中的最长链，那么我们的情况2要取次长链，如果不是取最长链就可以了。

然后枚举每个点，半径就是min(max(dp\[i],from\[i]))了

然后只需做4遍一半的dfs即可，代码也是非常的好写

 _(小技巧:dfs的时候直接把另一个点打上访问标记即可只dfs一半)_ 
 
 上代码~
 
 ```c
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=5010;const int INF=0x3f3f3f3f;
struct data{int v;int nxt;int val;}edge[2*N];
int alist[N];int cnt;int n;
inline void add(int u,int v,int val)
{edge[++cnt].v=v;edge[cnt].nxt=alist[u];alist[u]=cnt;edge[cnt].val=val;}
int dp[N];int mv[N];int nxdp[N];bool book[N];int rad=INF;int dis;int res=INF;
void getd(int x)//求直径 
{
	book[x]=true;int nxt=alist[x];
	while(nxt)
	{
		int v=edge[nxt].v;int val=edge[nxt].val;
		if(!book[v])
		{
			getd(v);int va=dp[v]+val;//最长链和次长链 
			if(va>dp[x]){nxdp[x]=dp[x];dp[x]=va;mv[x]=v;}
			else if(va>nxdp[x]){nxdp[x]=va;}
		}nxt=edge[nxt].nxt;
	}dis=max(dis,dp[x]+nxdp[x]);//更新直径 
}
void getr(int x,int fr)
{
	rad=min(rad,max(fr,dp[x]));//更新半径 
	book[x]=false;int nxt=alist[x];
	while(nxt)
	{
		int v=edge[nxt].v;int val=edge[nxt].val;
		if(book[v])//更新fr，记得特判自己就是最长链的情况 
		{
			if(v==mv[x]){getr(v,max(nxdp[x]+val,fr+val));}
			else {getr(v,max(dp[x]+val,fr+val));}
		}nxt=edge[nxt].nxt;
	}
}//清空dp的函数 
inline void clear(){for(int i=1;i<=n;i++){dp[i]=mv[i]=nxdp[i]=book[i]=0;}rad=INF;dis=0;}
int u[N];int v[N];int val[N];
int main()
{
	scanf("%d",&n);
	for(int i=1;i<n;i++)//读进来 
	{
		scanf("%d%d%d",&u[i],&v[i],&val[i]);
		add(u[i],v[i],val[i]);add(v[i],u[i],val[i]);
	}
	for(int i=1;i<n;i++)//枚举边 
	{
		int d1;int d2;int r1;int r2;
		book[v[i]]=1;getd(u[i]);d1=dis;//求直径 
		dis=0;getd(v[i]);d2=dis;//求半径 
		book[v[i]]=0;getr(u[i],0);r1=rad;//求直径 
		rad=INF;getr(v[i],0);r2=rad;//求半径 
		res=min(res,max(max(d1,d2),r1+r2+val[i]));//更新答案 
		clear();//不要忘记清空 
	}
	printf("%d",res);return 0;//拜拜程序~ 
}
```




---

## 作者：QwQcOrZ (赞：24)

显然可以枚举一条边删除，再选择两个端点加边，取最优的方案。

但这样显然是$O(n^3)$起步的。

所以考虑如何优化。

首先，枚举一条边，于是已经有了$O(n)$的复杂度。

然后我们选择加哪条边。

可以发现，改变一条边后所有的路径可以分为两类：

1. 不经过这条边的路径；

2. 经过这条边的路径。

由于无论如何加边，第一类路径的最大值都不会改变，所以可以用求树的直径的方法轻松$O(n)$求出。

重点是如何使第二类路径最优。

容易证明，我们只需要在已选择这条边所划分的两个子树内分别选择两个点，使得这两个点能到达的最远距离之和最小即可

那么考虑编写两个函数$\text{dfs1}$和$\text{dfs2}$：

## $\text{dfs1}$

$\text{dfs1(now)}$需要处理几样内容：

- $Max1[now]$表示节点$now$向下能拓展的最长链的长度

- $Max2[now]$表示节点$now$向下能拓展的次长链（向与最长链不同的儿子拓展）的长度

- 同时处理第一类路径的最大值

这三样内容都可以用和求树的直径类似的方法轻松求出

## $\text{dfs2}$

$\text{dfs2(now)}$也需要处理几样内容：

- $Max0[now]$表示节点$now$向父亲能拓展的最长链的长度

   显然$Max0[now]$可以由两种情况转移过来：

     1. $now$的父亲向它的父亲拓展的最大值（即$Max0[father]$）

     2. $now$的父亲向$now$的兄弟拓展的最大值

   对于情况2，我们可以进行分类讨论：

     1. 当向它拓展是最大值（即等于$Max1$）时，答案就是次大值（即$Max2$）

     2. 当向它拓展不是最大值（即不等于$Max1$）时，答案就是最大值（即$Max1$）

   其中的次大值和最大值我们已经用$\text{dfs1}$处理好了

- $Max[now]$表示节点$now$能拓展的最长链的长度

  $Max[now]$只需要令$Max[now]=max(Max1[now],Max0[now])$即可

最后这个节点的贡献就是$Max[now]$了，取最小值连边即可

$Code\ Below$

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5005;
const int inf=INT_MAX/2;

inline int read()
{
	register int s=0;
	register char c=getchar(),lc='+';
	while (c<'0'||'9'<c) lc=c,c=getchar();
	while ('0'<=c&&c<='9') s=s*10+c-'0',c=getchar();
	return lc=='-'?-s:s;
}
void write(register int x)
{
	if (x<0)
	{
		putchar('-');
		x=-x;
	}
	if (x<10) putchar(x+'0');
	else
	{
		write(x/10);
		putchar(x%10+'0');
	}
}
inline void print(const register int x,const register char c='\n')
{
	write(x);
	putchar(c);
}
struct edge
{
	int to,val,nxt;
}e[2*N];
int head[N],cnt=0,u[N],v[N],w[N],ans=inf;
void add(int u,int v,int w)
{
	e[++cnt].to=v;
	e[cnt].val=w;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}
int Max0[N],Max1[N],Max2[N],Max[N],mxn=0;
int dfs1(int now,int fa)
{
	Max1[now]=Max2[now]=0;
	for (int i=head[now];i;i=e[i].nxt)
	if (e[i].to!=fa)
	{
		int to=e[i].to;
		int v=e[i].val+dfs1(to,now);
		if (v>Max1[now])
		{
			Max2[now]=Max1[now];
			Max1[now]=v;
		}
		else
		if (v>Max2[now]) Max2[now]=v;//处理Max1和Max2
	}
	mxn=max(mxn,Max1[now]+Max2[now]);//求第一类路径的最大值
	return Max1[now];
}
int dfs2(int now,int fa)
{
	int ret=inf;
	Max[now]=max(Max1[now],Max0[now]);//处理Max，因为计算Max0是在父亲节点进行的，所以可以在前面处理
	for (int i=head[now];i;i=e[i].nxt)
	if (e[i].to!=fa)
	{
		int to=e[i].to,val=e[i].val;
		int v=val+Max1[to];
		if (v==Max1[now]) Max0[to]=max(Max0[now],Max2[now])+val;
					 else Max0[to]=max(Max0[now],Max1[now])+val;//处理Max0
	}
	for (int i=head[now];i;i=e[i].nxt)
	if (e[i].to!=fa)
	ret=min(ret,dfs2(e[i].to,now));
	return min(ret,Max[now]);//计算第二类路径的最大值
}

int main()
{
	int n=read();
	for (int i=1;i<n;i++)
	{
		u[i]=read();
		v[i]=read();
		w[i]=read();
		add(u[i],v[i],w[i]);
		add(v[i],u[i],w[i]);
	}
	for (int i=1;i<n;i++)//枚举边
	{
		mxn=0;
		for (int j=1;j<=n;j++) Max0[j]=0;
		dfs1(u[i],v[i]);
		dfs1(v[i],u[i]);
		ans=min(ans,max(dfs2(u[i],v[i])+dfs2(v[i],u[i])+w[i],mxn));//求最优连边方案
	}
	print(ans);

	return 0;
}
```

---

## 作者：nofind (赞：9)

题意:https://www.luogu.org/problem/P3761

$O(n)$枚举断哪条边,之后考虑连哪两个点使得两点间最大距离最小

假如我们连接了$(u,v)$,那么考虑最大值有哪些可能:

1.$u$所在联通块的直径

2.$v$所在连通块的直径

3.$u$所在连通块中到$u$最大距离+$v$所在连通块中到$v$最大距离+$w(u,v)$

前面两个直接树的直径,考最后一个

设$h[x]$表示$x$的连通块到$x$的最大距离,我们显然要连接$u$和$v$的连通块中$h[]$最小的两个

考虑$h[x]$的取值可能:

1.$f[x]$表示x的子树中最长链,这个在求直径时已经求出来了

2.假设$z$是$x$的父亲节点,z子树中除了包含x的子树的最长链+w(z,x)

3.假设$z$是$x$的父亲节点,除了z的子树外到z最长链+w(z,x)

在求直径时求出$f[x]$表示x的子树中最长链和$g[x]$x的子树中次长链,$maxson[x]$表示含有x的子树中最长链的x的儿子的位置,之后再dfs一遍即可

code:
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=5010;
int n,cnt=1,ans=453533453,tmp;
int head[maxn],f[maxn],g[maxn],maxson[maxn];
bool check[maxn<<1];
struct edge{int to,nxt,dis;}e[maxn<<1];
inline void add(int u,int v,int w){e[++cnt].nxt=head[u];head[u]=cnt;e[cnt].to=v;e[cnt].dis=w;}
void dfs1(int x,int fa)
{
	for(int i=head[x];i;i=e[i].nxt)
	{
		int y=e[i].to;
		if(y==fa||check[i])continue;
		dfs1(y,x);
		tmp=max(tmp,f[x]+f[y]+e[i].dis);
		if(f[y]+e[i].dis>f[x])g[x]=f[x],f[x]=f[y]+e[i].dis,maxson[x]=y;
		else if(f[y]+e[i].dis>g[x])g[x]=f[y]+e[i].dis;
	}
}
void dfs2(int x,int fa,int maxx)
{
	tmp=min(tmp,max(maxx,f[x]));
	for(int i=head[x];i;i=e[i].nxt)
	{
		int y=e[i].to;
		if(y==fa||check[i])continue;
		if(maxson[x]==y)dfs2(y,x,max(g[x]+e[i].dis,maxx+e[i].dis));
		else dfs2(y,x,max(f[x]+e[i].dis,maxx+e[i].dis));
	}
}
inline void init()
{
	memset(f,0,sizeof(f));
	memset(g,0,sizeof(g));
	memset(maxson,0,sizeof(maxson));
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<n;i++)
	{
		int u,v,w;scanf("%d%d%d",&u,&v,&w);
		add(u,v,w);add(v,u,w);
	}
	for(int i=2;i<=cnt;i+=2)
	{
		init();
		int d1,d2,d3,d4,x=e[i].to,y=e[i^1].to;
		check[i]=check[i^1]=1;
		tmp=0,dfs1(x,0);d1=tmp;
		tmp=0,dfs1(y,0);d2=tmp;
		tmp=42342344,dfs2(x,0,0);d3=tmp;
		tmp=42342344,dfs2(y,0,0);d4=tmp;
		ans=min(ans,max(max(d1,d2),d3+d4+e[i].dis));
		check[i]=check[i^1]=0;
	}
	printf("%d",ans);
	return 0;
}
```


---

## 作者：云岁月书 (赞：7)

#### update 2020/7/15 优化了一下 $markdown$ 的用法，增加了前面的题目描述。
# 题目：
### 题目描述
##### 从加里敦大学城市规划专业毕业的小明来到了一个地区城市规划局工作。这个地区一共有 $n$ 座城市，$n-1$ 条高速公路，保证了任意两运城市之间都可以通过高速公路相互可达，但是通过一条高速公路需要收取一定的交通费用。小明对这个地区深入研究后，觉得这个地区的交通费用太贵。

##### 小明想彻底改造这个地区，但是由于上司给他的资源有限，因而小明现在只能对一条高速公路进行改造，改造的方式就是去掉一条高速公路，并且重新修建一条一样的高速公路（即交通费用一样），使得这个地区的两个城市之间的最大交通费用最小（即使得交通费用最大的两座城市之间的交通费用最小），并且保证修建完之后任意两座城市相互可达。如果你是小明，你怎么解决这个问题？

### 输入格式
##### 输入数据的第一行为一个整数 $n$，代表城市个数。

##### 接下来的 $n - 1$ 行分别代表了最初的 $n - 1$ 条公路情况。每一行都有三个整数 $u,v,d$ 。$u,v$ 代表这条公路的两端城市标号，$d$ 代表这条公路的交通费用。

##### $ 1 \leq u,v \leq $， $ 1\leq d \leq 2000 $。

### 输出格式
##### 输出数据仅有一行，一个整数，表示进行了最优的改造之后，该地区两城市 之间最大交通费用。

首先由 $n \leq 5000 $ ,时间限制是 $3s$ 我们可以确定本题 $O(n^2)$可以卡过去。

# 初步解法
 我们就可以先有一个 $O(n^2)$ 的暴力解法。
 ~~（这一版基本是照着某一楼的题解打出来的）~~
 我们枚举每一条边断开，然后求连个联通块各自的直径，以及两个联通块的最短半径，基本可以说是半个纯暴力。
 ```
void Diameter(const int u)//找直径的函数
{	
	book[u] = 1;//用来标记是否遍历过。

	for(reg int i = head[u]; i ; i = e[i].next)
		if(!book[e[i].to])
		{
			Diameter(e[i].to);
			
			int v = f[e[i].to][0] + e[i].wi;
			
   			if(v > f[u][0]){f[u][1] = f[u][0];f[u][0] = v;mv[u] = e[i].to;}
   			
   			else if(v > f[u][1]){f[u][1] = v;}
		}
	diameter = Max(diameter,f[u][1] + f[u][0]);//很标准的一个求树直径的 DP。
}

void Radius(const int u,const int front)//找半径的函数
{	// front 用来记录自身子树内的最短半径。
	book[u] = 0;radius = Min(radius,Max(front,f[u][0]));

	for(reg int i = head[u]; i ; i = e[i].next)
		if(book[e[i].to]) Radius(e[i].to,Max(front,mv[u] == e[i].to ? f[u][1] : f[u][0]) + e[i].wi);
}


int main()
{
	n = Read();
	
	for(reg int i = 1; i < n ; ++i) add_edge(Read(),Read(),Read());
	
	for(reg int i = 2; i <= tot_edge; i += 2)
	{
		int d1,d2,r1,r2;
		
		diameter = 0;
		
		book[e[i].to]=1;
		
		Diameter(e[i^1].to);
		
		d1 = diameter;
		
   		diameter = 0;
   		
		Diameter(e[i].to);
		
		d2 = diameter;
		 
   		book[e[i^1].to]=0;
   		
   		radius = INF;
   		
		Radius(e[i].to,0);
		
		r1 = radius;
		
   		radius = INF;
   		
		Radius(e[i^1].to,0);
   		
		r2 = radius;
		
   		Ans = Min(Ans,Max(Max(d1,d2),r1+r2+e[i].wi));
   		
   		for(reg int i = 1 ; i <= n; ++i) {f[i][0] = mv[i] = f[i][1] = book[i] = 0;}
	}
	
	printf("%d",Ans);
	
	return 0;
}
```

# 如何优化？

## 优化一：断边
断的边一定在原来树的直径上，且是树所有直径的公共边。

对于非直径上的边，就算断掉，剩下的两个联通块的直径有一个还是原来的直径，所以对其我们要求的答案无影响。

然后直径的非公共边。
![](https://cdn.luogu.com.cn/upload/image_hosting/brn0344g.png)
如图树的直径有两条， $ 1->8 $ 和 $ 1->9 $ ，断掉 $ 5->6,5->7,6->9,7->8$ 中的任意一条，都不会让剩下的两个联通块的直径减小，所以其对答案也无影响。
（这里的性质使选原树任意一条直径进行删边都可以找到正确答案所删的那一条边）

由此我们可以得到一个优化， 时间复杂度是 $ O(nL)$ , $L$ 是原树直径的边数。

```
void dfs(const int u,const int fa)
{	
	for(reg int i = head[u]; i ; i = e[i].next)
		if(e[i].to != fa)
		{
			dis[e[i].to] = dis[u] + e[i].wi;
			
			mv[e[i].to] = i;
			
			dfs(e[i].to,u);
		}
}

void Diameter(const int u)
{	
	book[u] = 1;

	for(reg int i = head[u]; i ; i = e[i].next)
		if(!book[e[i].to])
		{
			Diameter(e[i].to);
			
			int v = f[e[i].to][0] + e[i].wi;
			
   			if(v > f[u][0]){f[u][1] = f[u][0];f[u][0] = v;mv[u] = e[i].to;}
   			
   			else if(v > f[u][1]){f[u][1] = v;}
		}
	diameter = Max(diameter,f[u][1] + f[u][0]);
}

void Radius(const int u,const int front)
{	
	book[u] = 0;radius = Min(radius,Max(front,f[u][0]));

	for(reg int i = head[u]; i ; i = e[i].next)
		if(book[e[i].to]) Radius(e[i].to,Max(front,mv[u] == e[i].to ? f[u][1] : f[u][0]) + e[i].wi);
}


int main()
{
	n = Read();
	
	for(reg int i = 1; i < n ; ++i) add_edge(Read(),Read(),Read());
	
	dfs(1,1);
	
	for(reg int i = 1; i <= n ; ++i) if(dis[S] < dis[i]) S = i;
	
	dis[S] = 0;
	
	for(reg int i = 1; i <= n ; ++i) mv[i] = 0;
	
	dfs(S,S);
	
	for(reg int i = 1; i <= n ; ++i) if(dis[T] < dis[i]) T = i;
	
	for(reg int i = mv[T]; i ; i = mv[e[i^1].to])  
		ded[++tde] = i;
	
	for(reg int i = 1; i <= n ; ++i) mv[i] = 0;
	
	for(reg int i = 1; i <= tde; i++)//可优化，只删直径 
	{
		int d1,d2,r1,r2;
		
		diameter = 0;
		
		book[e[ded[i]].to]=1;
		
		Diameter(e[ded[i]^1].to);
		
		d1 = diameter;
		
   		diameter = 0;
   		
		Diameter(e[ded[i]].to);
		
		d2 = diameter;
		 
   		book[e[ded[i]^1].to]=0;
   		
   		radius = INF;
   		
		Radius(e[ded[i]].to,0);
		
		r1 = radius;
		
   		radius = INF;
   		
		Radius(e[ded[i]^1].to,0);
   		
		r2 = radius;
		
   		Ans = Min(Ans,Max(Max(d1,d2),r1+r2+e[ded[i]].wi));
   		
   		for(reg int i = 1 ; i <= n; ++i) {f[i][0] = mv[i] = f[i][1] = book[i] = 0;}
	}
	
	printf("%d",Ans);
	
	return 0;
}
```

### 优化效果：
从 $ 17.55s -> 1.61s $,挂了氧气能达到 $871ms$ 。

### [$O(n^2)$](https://www.luogu.com.cn/record/35031836)

### [$O(nL)$](https://www.luogu.com.cn/record/35032620)

### [氧气](https://www.luogu.com.cn/record/35038614)

## 优化二：连边

 $1.$ 2如果连的是直径上的点，那么可以确定新树的直径是两个联通块直径上的较长链相加，为了使其尽可能短，所以我们要连两个联通块直径的中点来使较长链更短。

 $2.$ 如果连的不是直径上的点，那么可以确定新树的直径是两个联通块直径上的较长链相加在加上连接点到各自直径的距离，是一定长于 方案 $1$ 的。

所以可以写一个找直径中点的函数代替上文中找半径的函数。

这个函数时间复杂度很难算，姑且可当做 $\Omega(1)$ ，卡一卡就变 $O（L）$  了。

可以证明的是联通块上的直径一定有一半以上的长度是与原树直径重合的（只需要理解一下上文用 $DP$ 求直径的做法)，可以用这个性质来找中点。

~~这个优化代码我没单独写~~

```
		int rt=0,lt=0,Half = ans>>1,cur;
		
		cur = i;
		
		while(dp[cur][0] - WW[cur] > Half && cur) cur = mvv[cur];
		
		rt = dp[cur][0];
		
		cur = mv[i];
		
		Half = (f[mv[i]][0] + f[mv[i]][1])>>1;
		
		while(f[cur][0] - W[cur]> Half && cur) cur = mv[cur];
		
		lt = f[cur][0];
		
		ans = Max(ans,W[i] + lt + rt);
```


## 终极优化 
~~调了很久也没调出来。~~

我们在直径上遍历删边的时候，不难发现做了很多的重复的遍历。
![](https://cdn.luogu.com.cn/upload/image_hosting/fug1umam.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)

### 黄色是断了的边。

### 对于断边左侧：从上往下的过程中，红色的点进行了多余的遍历，只有橙色的点才是需要遍历的。
### 对于断边右侧：我们发现若是从最左边的点进行第一次遍历，那么我们便已经得到了右联通块需要的所有信息。
在找右边直径的过程都是可以通过 $O(n)$ 预处理变成 $O(1)$ 的。

在找左边直径的过程可以用 $book$ 数组标记，不重复遍历，也可以实现整体 $O(n)$的。

最终加上连边的优化是可以达到 $\Omega(n)$？

需要特别注意的是，会有特殊的数据如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/241knedn.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)

就是如图所示，删去 $6 -> 1$ 的边后最长链不经过 $1$ 点，这需要特殊处理。
即断的边的端点不一定在断边后联通块的直径上。

我的想法就是先找到最长链的两个端点，再分别从两个端点跑一次 $dfs$ 。

要记录两个东西。

当前子树直径。

据当前子树根节点最近的直径上的节点。

```
void dfs1(const int u,const int fa)
{	
	for(reg int i = head[u]; i ; i = e[i].next)
		if(e[i].to != fa)
		{
			dfs1(e[i].to,u);
			
			int v = f[e[i].to][0] + e[i].wi;
			
   			if(v > f[u][0]){f[u][1] = f[u][0];f[u][0] = v;mv[u] = e[i].to;W[u] = e[i].wi;}
   			
   			else if(v > f[u][1]){f[u][1] = v;}
   			
   			A[u] = Max(A[u],A[e[i].to]);
		}
		A[u] = Max(A[u],f[u][1] + f[u][0]);
}

void dfs(const int u,const int fa)
{	
	for(reg int i = head[u]; i ; i = e[i].next)
		if(e[i].to != fa)
		{
			dfs(e[i].to,u);
			
			int v = dp[e[i].to][0] + e[i].wi;
			
   			if(v > dp[u][0]){dp[u][1] = dp[u][0];dp[u][0] = v;mvv[u] = e[i].to;WW[u] = e[i].wi;}
   			
   			else if(v > dp[u][1]){dp[u][1] = v;}
   			
   			B[u] = Max(B[u],B[e[i].to]);
		}
		B[u] = Max(B[u],dp[u][1] + dp[u][0]);
}


```

#### 记录每一个子树的最长链，次长链，然后断的边移动，但是不用 $DP$ 了，可以直接从数组中找到当前情况下各联通块的直径，最后找一下对应直径中点就可以找到答案了。


---

## 作者：duyi (赞：5)

> 时间复杂度$O(n^2)$的做法可以通过本题。但我们可以继续优化到$O(n)$。本文将分别介绍这两种做法。

### $O(n^2)$做法

我们把树上距离最大的一对点，称为树的直径。

枚举断掉哪条边，设断掉的边为$(u,v)$。那么树就被分成了包含$u$的连通块和包含$v$的连通块，这两部分。再连边时，新边的两个端点，一定分别位于两个连通块里，记这两个端点为$(u',v')$。新树的直径，可能有三种情况：

1. $u$所在连通块的直径。
2. $v$所在连通块的直径。
3. 【$u$所在连通块里，与$u'$距离最大的点的距离】+【边$(u,v)$的长度】+【$v$所在连通块里，与$v'$距离最大的点的距离】。

前两个情况，长度是已经确定的，与我们如何选择$u',v'$无关。可以先将前两个情况的长度求出来。第3个情况，发现$u'$, $v'$的选择是互不影响的，可以分别求最小值。于是问题转化为，有一棵树（也就是$u$或$v$所在的连通块），请你求一个点$x$，使得树上所有点到$x$的最大距离最小。

先随便选一个点作为根（在具体实现时，不妨就选$u$和$v$）。求出“树上”所有点到根的最大距离。然后换根，这样就能求出以每个点为根的情况，然后取最小的即可。为了换根，我们要先求出每个点子树内，到它距离最大和**次大**的点，求次大的，是为了避免换根时，要换的那个子树恰好就是最大的。

这样，就在$O(n)$的时间里求出了断掉这条边时，新树的最小直径。对每条边的情况取最小值，就是答案了。

时间复杂度$O(n^2)$。

### $O(n)$做法

需要一些观察。

> **观察一**：我们要断掉的边，一定在原树的直径上。
>
> 否则不会使直径变小。

> **观察二**：根据观察一，$u$, $v$两个连通块里，一定分别有一个原直径的端点。那么，$u$, $v$两个连通块的直径，其中的一端，一定是原直径的端点。
>
> 否则原直径就不是最长的了。不符合直径的定义。

> **观察三**：前面我们用换根法解决的问题：
>
> > 有一棵树（也就是$u$或$v$所在的连通块），请你求一个点$x$，使得树上所有点到$x$的最大距离最小。
>
> 这个点$x$，一定就是树的直径的中点（是带权意义上的中点）。​

根据观察一，我们可以按顺序枚举直径上的每条边。此时，两边的连通块，会新多出一部分节点，或者新减少一部分节点。对于减少的情况，我们反着走一遍，它就也变成了新增。

每次遍历这些“新增”的部分，然后利用观察二，更新直径。发现新增部分的总和是$O(n)$的。这样，就能在总共$O(n)$的时间里，求出$u,v$各自所在连通块的直径。

再根据观察三，我们要找的$x$不需要用换根法了。由于每次新增一些部分后，连通块的直径长度是单调不降的，那么“直径中点”也是“单调”的，向前枚举即可。

时间复杂度$O(n)$。

### 参考代码

~~因为博主是鸽子~~，所以只写了$O(n^2)$的代码。

```cpp
//problem:P3761
#include <bits/stdc++.h>
using namespace std;

#define pb push_back
#define mk make_pair
#define lob lower_bound
#define upb upper_bound
#define fi first
#define se second
#define SZ(x) ((int)(x).size())

typedef unsigned int uint;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pii;

const int MAXN=5000;
const int INF=1e9;
int n,cnt;
struct EdgeAndSize{
	int u,v,w,sz_u,sz_v;
	EdgeAndSize(int _u,int _v,int _w,int _su,int _sv){
		u=_u;v=_v;w=_w;sz_u=_su;sz_v=_sv;
	}
	EdgeAndSize(){}
}e[MAXN+5];

struct EDGE{int nxt,to,w;}edge[MAXN*2+5];
int head[MAXN+5],tot;
inline void add_edge(int u,int v,int w){
	edge[++tot].nxt=head[u],edge[tot].to=v,edge[tot].w=w,head[u]=tot;
}

int sz[MAXN+5];
void dfs1(int u,int fa){
	sz[u]=1;
	for(int i=head[u];i;i=edge[i].nxt){
		int v=edge[i].to;
		if(v==fa)continue;
		dfs1(v,u);
		e[++cnt]=EdgeAndSize(u,v,edge[i].w,n-sz[v],sz[v]);
		sz[u]+=sz[v];
	}
}
int f[MAXN+5],f2[MAXN+5];
void dfs2(int u,int fa){
	f[u]=f2[u]=0;
	for(int i=head[u];i;i=edge[i].nxt){
		int v=edge[i].to;
		if(v==fa)continue;
		dfs2(v,u);
		int val=f[v]+edge[i].w;
		if(val>f[u]){
			f2[u]=f[u];
			f[u]=val;
		}
		else if(val>f2[u]){
			f2[u]=val;
		}
	}
}
void dfs3(int u,int fa,int& mn,int& mx){
	mn=min(mn,f[u]);
	mx=max(mx,f[u]);
	for(int i=head[u];i;i=edge[i].nxt){
		int v=edge[i].to;
		if(v==fa)continue;
		//换根
		int t=f[u];
		if(f[v]+edge[i].w==f[u])t=f2[u];
		int val=t+edge[i].w;
		if(val>f[v]){
			f2[v]=f[v];
			f[v]=val;
		}
		else if(val>f2[v]){
			f2[v]=val;
		}
		dfs3(v,u,mn,mx);
	}
}
int main() {
	cin>>n;
	for(int i=1;i<=n-1;++i){
		int u,v,w;cin>>u>>v>>w;
		add_edge(u,v,w);add_edge(v,u,w);
	}
	dfs1(1,0);
	assert(cnt==n-1);
	int ans=INF;
	for(int i=1;i<=n-1;++i){
		dfs2(e[i].u,e[i].v);
		int min_u=INF,max_u=0;
		dfs3(e[i].u,e[i].v,min_u,max_u);
		
		dfs2(e[i].v,e[i].u);
		int min_v=INF,max_v=0;
		dfs3(e[i].v,e[i].u,min_v,max_v);
		
		ans=min(ans,max(min_u+min_v+e[i].w,max(max_u,max_v)));
	}
	cout<<ans<<endl;
	return 0;
}
```



---

## 作者：Merc03 (赞：4)

## 知识点

- 树的直径

- 换根$dp$

## 思路

题目转化为重连一条边使得新直径最小。

发现 $n$ 并不大且这道题并且看不出什么明显的性质，考虑枚举断边，$O(n)$。

我们知道这种两棵子树合并后的新直径要分过连边和在两棵原子树产生，一共三种情况，两子树的直径可以 $O(n)$ 得到，那么问题就在过中间的直径。

一种显然的 $O(n ^ 3)$ 暴力：$O(n ^ 2)$ 预处理出每个点为为端点，在子树中的最长链长度，再 $O(n ^ 2)$ 枚举连边的两端点求解。

仔细观察，我们发现，两子树互不影响，如果能快速找到两个点，使得在各自子树中，以自身为起点的最长链都最小，那么这一定是在当前断边上的最优方案。

怎么找呢？我们考虑类似树的重心的思路，执行换根来枚举，最长链要么过父亲，要么过儿子。过儿子的写法和求直径完全一致。过父亲时，显然是过父亲且不过儿子的最长链 $+$ 父子连边长度，进一步转化为，从爷爷节点伸下来，或者从兄弟节点拐过来。那么换根时，除了链最长的儿子，我们都应传下 $max(len_{father},max{len_{son}})$，链最长的儿子传下次长链即可。

请看代码，注意不要漏统计边。

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;

namespace input {
	bool Sign;
	template <typename T>
	
	inline void read(T &a) {
		register char ch = getchar();
		while(!isdigit(ch) && ch != '-') ch = getchar();
		a = (Sign = (ch == '-')) ? 0 : ch - 48;
		while(isdigit(ch = getchar())) a = a * 10 + ch - 48;
		a = Sign ? -a : a;
	}
}
using input::read;

#define match(x) (x == cut || x == (cut ^ 1))

const int INF = 1 << 30;
const int N = 5e3 + 5;
int n, cut, DIA, c[N];
int tot = 1, head[N], nex[N << 1], ver[N << 1], edge[N << 1];

inline void addEdge(int x, int y, int z) {
	ver[++tot] = y, edge[tot] = z, nex[tot] = head[x], head[x] = tot;
}

int diameter(int now, int fa) {
	int Mx = 0;
	for(int u = head[now]; u; u = nex[u])
		if(ver[u] != fa && !match(u)) {
			int y = diameter(ver[u], now) + edge[u];
			DIA = max(DIA, y + Mx), Mx = max(Mx, y);
		}
	c[now] = Mx;
	return Mx;
}

int dp(int now, int fa, int len) {
	int Mx1 = 0, Mx2 = 0, p1; // c[Mx1] > c[Mx2]
	for(int u = head[now]; u; u = nex[u]) {
		if(match(u)) continue;
		int y = ver[u];
		if(y == fa) continue;
		if(c[y] + edge[u] > Mx1) swap(Mx1, Mx2), Mx1 = c[y] + edge[u], p1 = u;
		else if(c[y] + edge[u] > Mx2) Mx2 = c[y] + edge[u];
	}
	//printf("	%d %d %d %d\n", now, len, c[Mx1], c[Mx2]);
	int ans = max(len, Mx1);
	for(int u = head[now]; u; u = nex[u]) {
		if(match(u)) continue;
		int y = ver[u];
		if(y == fa) continue;
		int t;
		if(y == ver[p1]) t = dp(y, now, max(len, Mx2) + edge[u]);
		else t = dp(y, now, max(len, Mx1) + edge[u]);
		ans = min(ans, t);
	}
	return ans;
}

int main() {
	freopen("data.in", "r", stdin);
	//freopen("city.out", "w", stdout);
	
	read(n);
	for(int i = 1; i < n; ++i) {
		int x, y, z; read(x), read(y), read(z);
		addEdge(x, y, z), addEdge(y, x, z);
	}
	
	int ans = INF;
	for(int i = 1; i < n; ++i) {
		cut = i << 1;
		DIA = 0, diameter(ver[cut], 0), diameter(ver[cut ^ 1], 0);
		int d1 = dp(ver[cut], 0, 0), d2 = dp(ver[cut ^ 1], 0, 0);
		//printf("%d %d	%d %d\n", ver[cut], ver[cut ^ 1], d1, d2);
		//for(int j = 1; j <= n; ++j) printf("%d ", c[j]); puts("");
		ans = min(ans, max(DIA, d1 + d2 + edge[cut]));
	}
	
	printf("%d\n", ans);
	
	return 0;
}
```


---

## 作者：lgswdn_SA (赞：4)

### [$\texttt{TJOI2017-城市}$](https://www.luogu.com.cn/problem/P3761)

由于可以 $O(n^2)$，枚举每条删边。枚举删边之后对于两个树分别求出在这棵树中**距离节点 $u$ 的最远距离**，这个需要二次扫描法进行求解（即上下的树形dp）。

之后，我们要看加哪条边。显然，我们要连接两个树的“交通枢纽”然后连接。“交通枢纽”指树上到这棵树上到其他点的最远距离 最小的一个点。显然在求出最远距离后，这个也可以通过枚举求出。假设两个交通枢纽 $u,v$ 求出了，那么连接他们，最长路径即 $g_u+g_v+w$，其中 $w$ 代表

于是这个结果就是第一棵树的直径，第二棵树的直径和重新连边后的直径的最大值。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e3+9;
struct edge{int to,nxt,w;}e[N*2]; int hd[N],tot;
void add(int u,int v,int w){e[++tot]=(edge){v,hd[u],w};hd[u]=tot;}
int f[N][2],mx[N],g[N],tmp[2],mn[2],ans=1e9;
//f为子树里面最远的点（f[u][0]代表最远，f[u][1]代表次远），g为子树外最远的点（后面通过和f取max算出总的最远的点）
//mx记录最远的那个点是从哪个儿子节点出发的，便于后面计算g
void dfs1(int u,int fa){
	for(int i=hd[u],v;i;i=e[i].nxt)
		if((v=e[i].to)!=fa){
			dfs1(v,u);
			if(f[v][0]+e[i].w>f[u][0]){
				f[u][1]=f[u][0],f[u][0]=f[v][0]+e[i].w,mx[u]=v;
			}
			else if(f[v][0]+e[i].w>f[u][1]) f[u][1]=f[v][0]+e[i].w;
		} 
}
void dfs2(int u,int fa,int k){
	for(int i=hd[u],v;i;i=e[i].nxt)
		if((v=e[i].to)!=fa){
			if(mx[u]!=v) g[v]=max(g[u]+e[i].w,f[u][0]+e[i].w);
			else g[v]=max(g[u]+e[i].w,f[u][1]+e[i].w);
			dfs2(v,u,k);
		}	
	g[u]=max(g[u],f[u][0]);
	
	tmp[k]=max(tmp[k],g[u]);
	mn[k]=min(mn[k],g[u]);
}
int main(){
	int n; scanf("%d",&n);
	for(int i=1,u,v,w;i<n;i++)
		scanf("%d%d%d",&u,&v,&w),add(u,v,w),add(v,u,w);
	for(int u=1;u<=n;u++){
		for(int i=hd[u],v;i;i=e[i].nxt){
			if((v=e[i].to)<=u) continue;
			memset(f,0,sizeof(f)),memset(g,0,sizeof(g)),memset(mx,0,sizeof(mx));
			tmp[0]=tmp[1]=0,mn[0]=mn[1]=1e9;
               		//上面是初始化
			dfs1(u,v),dfs2(u,v,0),dfs1(v,u),dfs2(v,u,1);
			ans=min(ans,max(max(tmp[0],tmp[1]),e[i].w+mn[0]+mn[1]));
             		//更新答案
		}
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：徐致远 (赞：3)


### 题解

首先比较显然的是断开的边一定是在直径上的。

所以可以枚举直径上断开的边，然后考虑怎样连边才能使之后的最远距离最小。

可以对断开边之后的两棵子树分别进行树形DP，求出每棵子树中与每个点距离最远的点的距离。这个树形DP可以在$O(n)$的复杂度内实现，但是蒟蒻我比较菜，写的很长。

那么新连的边的两个端点必定为两棵子树中与该点的最远距离最小的点。

这样连边后的直径为两个端点的最远距离之和加上新连边的长度。

注意新的直径不能比两棵子树的直径小。

### 代码

蒟蒻我比较菜，代码写的又臭又长QwQ。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=5005,inf=0x3F3F3F3F;
int n,tot,lnk[maxn],son[maxn*2],w[maxn*2],nxt[maxn*2],idx,dfn[maxn],siz[maxn],sum,rt,Ver[maxn],E[maxn],u,v,ans,F[maxn][4];bool flg,vis[maxn*2];
inline int read()
{
	int ret=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9'){ret=ret*10+ch-'0';ch=getchar();}
	return ret*f;
}
inline void add_e(int x,int y,int z){tot++;son[tot]=y;w[tot]=z;nxt[tot]=lnk[x];lnk[x]=tot;}
void DFS(int now,int fa,int dist)
{
	if(dist>sum){sum=dist;rt=now;}
	for(int i=lnk[now];i;i=nxt[i])
		if(son[i]!=fa)
			DFS(son[i],now,dist+w[i]);
}
void DFS2(int now,int fa)
{
	dfn[now]=++idx;siz[now]=1;
	if(!flg) Ver[++Ver[0]]=now;
	if(now==v){flg=true;return;}
	for(int i=lnk[now];i;i=nxt[i])
	{
		if(son[i]!=fa)
		{
			if(!flg) E[++E[0]]=i;
			DFS2(son[i],now);
			siz[now]+=siz[son[i]];
			if(!flg) E[0]--;
		}
	}
	if(!flg) Ver[0]--;
}
void DFS3(int now,int fa)
{
	for(int i=lnk[now];i;i=nxt[i])
	{
		if(son[i]!=fa&&!vis[i])
		{
			DFS3(son[i],now);
			if(F[son[i]][0]+w[i]>=F[now][0])
			{
				F[now][2]=F[now][0];
				F[now][3]=F[now][1];
				F[now][0]=F[son[i]][0]+w[i];
				F[now][1]=son[i];
			}
			else if(F[son[i]][0]+w[i]>F[now][2])
			{
				F[now][2]=F[son[i]][0]+w[i];
				F[now][3]=son[i];
			}
			if(F[son[i]][2]+w[i]>F[now][2]&&son[i]!=F[now][1])
			{
				F[now][2]=F[son[i]][2]+w[i];
				F[now][3]=son[i];
			}
		}
	}
}
void DFS4(int now,int fa)
{
	for(int i=lnk[now];i;i=nxt[i])
	{
		if(son[i]!=fa&&!vis[i])
		{
			if(F[now][1]!=son[i])
			{
				if(F[now][0]+w[i]>=F[son[i]][0])
				{
					F[son[i]][2]=F[son[i]][0];
					F[son[i]][3]=F[son[i]][1];
					F[son[i]][0]=F[now][0]+w[i];
					F[son[i]][1]=now;
				}
				else if(F[now][0]+w[i]>F[son[i]][2])
				{
					F[son[i]][2]=F[now][0]+w[i];
					F[son[i]][3]=now;
				}
			}
			if(F[now][3]!=son[i]&&F[now][2]+w[i]>=F[son[i]][0])
			{
				F[son[i]][2]=F[son[i]][0];
				F[son[i]][3]=F[son[i]][1];
				F[son[i]][0]=F[now][2]+w[i];
				F[son[i]][1]=now;
			}
			else if(F[now][3]!=son[i]&&F[now][2]+w[i]>=F[son[i]][2])
			{
				F[son[i]][2]=F[now][2]+w[i];
				F[son[i]][3]=now;
			}
			DFS4(son[i],now);
		}
	}
}
inline void Solve()
{
	for(int i=1;i<Ver[0];i++)
	{
		vis[E[i]]=vis[(E[i]&1)?E[i]+1:E[i]-1]=true;
		memset(F,0,sizeof(F));
		DFS3(Ver[i],0);DFS3(Ver[i+1],0);
		DFS4(Ver[i],0);DFS4(Ver[i+1],0);
		int Max=0,Min1=inf,Min2=inf;
		for(int j=1;j<=n;j++)
		{
			if(dfn[Ver[i]]<=dfn[j]&&dfn[j]<=dfn[Ver[i]]+siz[Ver[i]]) Min1=min(Min1,F[j][0]);
			else Min2=min(Min2,F[j][0]);
			Max=max(Max,F[j][0]);
		}
		if(max(Max,Min1+Min2+w[E[i]])<ans) ans=max(Max,Min1+Min2+w[E[i]]);
		vis[E[i]]=vis[(E[i]&1)?E[i]+1:E[i]-1]=false;
	}
}
int main()
{
	n=read();
	for(int i=1;i<n;i++)
	{
		int a=read(),b=read(),c=read();
		add_e(a,b,c);add_e(b,a,c);
	}
	DFS(1,0,0);sum=0;u=rt;
	DFS(u,0,0);ans=sum;v=rt;
	DFS2(u,0);
	Solve();
	printf("%d\n",ans);
	return 0;
}
```



---

## 作者：破壁人 (赞：3)

给你一棵n个结点的带边权的树,请你改变其中一条边的位置,使得剩下的图仍是一棵树,并使树的直径尽可能小。

求改造后树的直径。

显然改变的边必然是这棵树的直径上的边。

去掉一条边后，会变成两棵树，我们要用一条边连接这两棵树使得新树的直径尽可能小。

那么就是连接他们的中心了。

所以新树的直径=max(l1,l2,r1+r2+x)

因为新树的直径肯定不小于两棵子树的直径，也不小于两棵子树的半径和与改变的边的和。

所以我们只要枚举直径上的边，分别求出去掉这条边后的两棵子树的直径和半径就可以了。









```cpp
#include<iostream>
#include<vector>
#include<cstring>
#include<algorithm>
using namespace std;
vector<int> son[5001];
int a[5001][5001],v[5001],last[5001],k,vv[5001];
int u,dis[5001],s,lastt[5001],kk,op,uu;
void dfs1(int o,int p,int q)
{
    if((son[o].size()==1)&&(v[q]))
    {
        if(p>op){op=p;k=o;}
        return;
    }
    for(int i=0;i<son[o].size();i++)
        if((!v[son[o][i]])&&(son[o][i]!=q))
        {
            v[son[o][i]]=true;
            dfs1(son[o][i],p+a[o][son[o][i]],o);
        }
}
void dfs2(int o,int p,int q)
{
    last[o]=q;
    if((son[o].size()==1)&&(v[q]))
    {
        if(p>op){op=p;u=o;}
        return;
    }
    for(int i=0;i<son[o].size();i++)
        if((!v[son[o][i]])&&(son[o][i]!=q))
        {
            v[son[o][i]]=vv[son[o][i]]=true;
            dfs2(son[o][i],p+a[o][son[o][i]],o);
        }
}
void dfs11(int o,int p,int q)
{
    if(p>op){op=p;kk=o;}
    for(int i=0;i<son[o].size();i++)
        if((!v[son[o][i]])&&(son[o][i]!=q)&&(a[o][son[o][i]]))
        {
            v[son[o][i]]=vv[son[o][i]]=true;
            dfs11(son[o][i],p+a[o][son[o][i]],o);
        }
}
void dfs22(int o,int p,int q)
{
    lastt[o]=q;
    dis[o]=p;
    if(p>op){op=p;uu=o;}
    for(int i=0;i<son[o].size();i++)
        if((!v[son[o][i]])&&(son[o][i]!=q)&&(a[o][son[o][i]]))
        {
            v[son[o][i]]=true;
            dfs22(son[o][i],p+a[o][son[o][i]],o);
        }
}
int main()
{
    int n;
    cin>>n;
    for(int i=1;i<n;i++)
    {
        int x,y,z;
        cin>>x>>y>>z;
        a[x][y]=z;
        a[y][x]=z;
        son[x].push_back(y);
        son[y].push_back(x);
    }
    op=-1;
    memset(v,0,sizeof(v));
    dfs1(1,0,0);
    op=-1;
    memset(v,0,sizeof(v));
    dfs2(k,0,0);
    int ans=1000000000;
    for(int i=u;last[i]!=0;i=last[i])
    {
        int yu=a[i][last[i]];
        a[i][last[i]]=0;
        a[last[i]][i]=0;
        memset(vv,0,sizeof(vv));
        memset(lastt,0,sizeof(lastt));
        int l1,l2,r1,r2;
        l1=l2=-1;
        r1=r2=1000000000;
        for(int j=1;j<=n;j++)
        {
            if(!vv[j]&&(l1==-1))
            {
                memset(dis,0,sizeof(dis));
                op=-1;
                memset(v,0,sizeof(v));
                vv[j]=true;
                dfs11(j,0,0);
                op=-1;
                memset(v,0,sizeof(v));
                vv[kk]=true;
                dfs22(kk,0,0);
                l1=op;
                for(int i1=uu;i1!=0;i1=lastt[i1])
                    r1=min(r1,max(dis[i1],l1-dis[i1]));
            }
            if(!vv[j]&&(l1!=-1))
            {
                memset(dis,0,sizeof(dis));
                op=-1;
                memset(v,0,sizeof(v));
                vv[j]=true;
                dfs11(j,0,0);
                op=-1;
                memset(v,0,sizeof(v));
                vv[kk]=true;
                dfs22(kk,0,0);
                l2=op;
                for(int i1=uu;i1!=0;i1=lastt[i1])
                    r2=min(r2,max(dis[i1],l2-dis[i1]));
            }
        }
        ans=min(ans,max(max(l1,l2),r1+r2+yu));
        a[i][last[i]]=yu;
        a[last[i]][i]=yu;       
    }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：skylee (赞：2)

总共有$n$个结点、$n-1$条边，说明整个图是一个无根树。

枚举每一条边$w$，并计算删除这条边以后的最大费用。


首先我自己定义了两个概念：

**树的中心**：树上的一点，保证从该点出发的最长简单路最短。

**树的半径**：从树的中心出发的最长简单路。


每次删边时会把整棵树分成两个不相交的新树。

对于每棵新树，可以分别求出它们的直径$d1$ $d2$、中心及半径$r1$ $r2$。则最优化修改该边后所能获得的最大费用为$max(d1,d2,r1+r2+w)$。


受到zx2003的启发，有了以下的一个优化：先求出整棵树的直径，则需要删除的边一定在直径上。

证明：如果修改的边不在直径上，那么修改改边后，直径仍然存在，则对于该边的修改没有意义。


zx2003提出的另一个比较有用但是没有被我采用的优化：特判链的情况。


'''cpp
```cpp
#include<cstdio>
#include<algorithm>
#include<vector>
#include<cctype>
inline int getint() {
    char ch;
    while(!isdigit(ch=getchar()));
    int x=ch^'0';
    while(isdigit(ch=getchar())) x=(((x<<2)+x)<<1)+(ch^'0');
    return x;
}
const int N=6000,inf=0x7fffffff;
struct Edge {
    int to,w;
};
int n;
std::vector<Edge> e[N];
int uu=0,vv=0,stop=0;
int v,w,d,y,u;
void find_vertex(int x,int depth,int parent) {
    if(depth>d) {
        d=depth;
        v=x;
    }
    for(register unsigned int i=0;i<e[x].size();i++) {
        if((e[x][i].to!=parent)&&(e[x][i].to!=uu)&&(e[x][i].to!=vv)) {
            find_vertex(e[x][i].to,depth+e[x][i].w,x);
        }
    }
}
void find_d(int x,int depth,int parent) {
    if(depth>y) {
        y=depth;
        u=x;
    }
    for(unsigned int i=0;i<e[x].size();i++) {
        if((e[x][i].to!=parent)&&(e[x][i].to!=stop)) {
            find_d(e[x][i].to,depth+e[x][i].w,x);
        }
    }
}
int l[N];
bool find_path(int x,int depth,int parent) {
    w++;
    l[w]=depth;
    if(x==u) return true;
    for(register unsigned int i=0;i<e[x].size();i++) {
        if(e[x][i].to!=parent) {
            if(find_path(e[x][i].to,depth+e[x][i].w,x)) return true;
        }
    }
    w--;
    return false;
}
inline int find_mid() {
    for(int i=0;i<w;i++) {
        if((l[i]<=(y>>1))&&(l[i+1]>=(y>>1))) {
            return std::min(std::max(l[i],y-l[i]),std::max(l[i+1],y-l[i+1]));
        }
    }
    return 0;
}
inline int getsum(int p) {
    w=0,d=0,y=0,v=p;
    find_vertex(p,0,0);
    find_d(v,0,0);
    find_path(v,0,0);
    return find_mid();
}
struct Edge2 {
    int from,to,w;
};
Edge2 p[N];
int w_whole;
bool find_path_whole(int x,int parent,int w) {
    p[w_whole]=(Edge2){parent,x,w};
    w_whole++;
    if(x==u) return true;
    for(register unsigned int i=0;i<e[x].size();i++) {
        if(e[x][i].to!=parent) {
            if(find_path_whole(e[x][i].to,x,e[x][i].w)) return true;
        }
    }
    w_whole--;
    return false;
}
int main() {
    n=getint();
    for(int i=1;i<n;i++) {
        u=getint(),v=getint(),w=getint();
        e[u].push_back((Edge){v,w});
        e[v].push_back((Edge){u,w});
    }
    w_whole=0,d=0,y=0;
    find_vertex(1,0,0);
    find_d(v,0,0);
    find_path_whole(v,0,0);
    int ans=inf;
    for(register int i=1;i<w_whole;i++) {
        uu=p[i].from;
        vv=p[i].to;
        int s1,s2,cmp=0;
        stop=vv;
        s1=getsum(uu);
        cmp=std::max(cmp,y);
        stop=uu;
        s2=getsum(vv);
        cmp=std::max(cmp,y);
        ans=std::min(ans,std::max(s1+p[i].w+s2,cmp));
    }
    printf("%d\n",ans);
    return 0;
}
```
```cpp

---

## 作者：xiayuyang (赞：1)

## 题意
一棵树，边又边权。
删一条边，重新链接一条边，边权相同，要求重新链接的图还是树，求出最小的可能直径
## 解法
一定得枚举直径上的边才有可能让直径变小，所以花$O(N)$枚举直径上的边，此时树被分为两个部分，答案可能是其中任意一个部分的直径，或者两个树连接后的最长链。
我们可以计算出两棵小树的直径，由于每个点在树上离得最远的点都是直径端点，所以我们不需要dp就可以算出每个点在树上离得最远的点的距离，只需要用两个直径端点分别做bfs，就可以了。然后就是从两棵树中都选出最小的点，加上枚举的边的权值作为第3种可能。

复杂度$O(N^2)$

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=5e3+5;
inline int read(){
	char c=getchar();int t=0,f=1;
	while((!isdigit(c))&&(c!=EOF)){if(c=='-')f=-1;c=getchar();}
	while((isdigit(c))&&(c!=EOF)){t=(t<<3)+(t<<1)+(c^48);c=getchar();}
	return t*f;
}
int n;
typedef pair<int,int> pii;
vector<pii> g[maxn];
int dis[maxn];
#define fi first
#define se second
int ed,pre[maxn],st;
int x[maxn],y[maxn],tot,dx,dy,alfa[maxn],val[maxn],vis[maxn];
inline bool get(int u,int v){
	if((u==dx)&&(v==dy))return 1;
	if((u==dy)&&(v==dx))return 1;
	return 0;
}
void bfs(int s){
	memset(dis,-1,sizeof(dis));
	dis[s]=0;
	queue<int> q;
	while(!q.empty())q.pop();
	q.push(s);
	while(!q.empty()){
		int u=q.front();q.pop();
		for(auto i:g[u]){
			int v=i.fi,w=i.se;
			if(get(u,v))continue;
			if(dis[v]==-1){
				pre[v]=u;
				dis[v]=dis[u]+w;
				if(dis[v]>dis[ed])ed=v;
				q.push(v);
			}
		}
	}
}
int vp;
int deal(int s){
	ed=s;
	bfs(s);
	st=ed;
	bfs(st);
	for(int i=1;i<=n;i++){
		if(dis[i]!=-1){
			alfa[i]=dis[i];
		}
	}
	bfs(ed);
	int mn=0x3f3f3f3f,mx=0;
	for(int i=1;i<=n;i++){
		if(dis[i]!=-1){
			vis[i]=1;
			alfa[i]=max(alfa[i],dis[i]);
			mn=min(mn,alfa[i]);
			mx=max(mx,dis[i]);
		}
	}
	vp=max(vp,mx);
	return mn;
}
signed main(){
	n=read();
	for(int i=1;i<n;i++){
		int a=read(),b=read(),c=read();
		g[a].push_back(pii(b,c));
		g[b].push_back(pii(a,c));
	}
	ed=1;
	bfs(1);
	st=ed;
	bfs(ed);
	for(int i=ed;i!=st;i=pre[i]){
		tot++;
		x[tot]=i;y[tot]=pre[i];val[tot]=dis[i]-dis[pre[i]];
	}
	int ans=0x3f3f3f3f;
	for(int i=1;i<=tot;i++){
		dx=x[i],dy=y[i];vp=0;
		int tmp=val[i];
		for(int u=1;u<=n;u++){
			if(!vis[u]){
				tmp+=deal(u);
				//printf("%d %d %d %d\n",dx,dy,u,deal(u));
			}
		}
		ans=min(ans,max(tmp,vp));
		for(int i=1;i<=n;i++)vis[i]=0;
	}
	printf("%d\n",ans);
	return 0;
}

```



---


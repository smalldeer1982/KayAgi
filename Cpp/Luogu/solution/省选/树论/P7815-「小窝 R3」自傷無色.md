# 「小窝 R3」自傷無色

## 题目背景

> こんな僕が生きてるだけで    
何万人のひとが悲しんで  
誰も僕を望まない  
そんな世界だったらいいのにな  
——[《自傷無色》](https://music.163.com/song?id=29124091)

## 题目描述

给定一棵 $n$ 个节点的树，根节点为 $1$，有边权。约定树上 $u,v$ 两点间路径长度 $d(u,v)$ 为 $u,v$ 间路径上的边权和。

对于一个无序二元组 $(u,v)$，定义一个「树三角」当且仅当同时满足：

- $u,v$ 的最近公共祖先 $w\neq u$ 且 $w\neq v$。
- 以 $d(u,w),d(v,w)$ 和某个正整数 $x$ 为边长，能构成一个三角形。$x$ 是任意选取的，因此一对 $(u,v)$ 可能会产生多个树三角。

此时 $d(u,w)+d(v,w)+x$ 即为这个树三角的大小。具体例子参考样例解释。

定义两个树三角不同，只需满足下列条件中的**一条**：

- 无序二元组 $(u,v)$ 不同。
- 树三角的大小不同。

对于一个带边权的树 $T$，定义其正弦值 $\sin T$ 为 $T$ 中所有树三角大小的和与 $T$ 中不同树三角总数量的比值。

小 H 给出了 $T$，希望你能求出 $\sin T$。为了避免误差，结果对 $10^9+7$ 取模。特别地，若 $T$ 中不存在树三角，则 $\sin T=0$。

## 说明/提示

### 样例解释

对于样例 1，$T$ 如下图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/35edha17.png)

节点 $1,2,3$ 构成的三角环有：$\underline{2,3},2;~\underline{2,3},3;~\underline{2,3},4$。

节点 $1,3,4$ 构成的三角环有：$\underline{3,3},1;~\underline{3,3},2;~\underline{3,3},3;~\underline{3,3},4;~\underline{3,3},5$。

节点 $1,3,5$ 构成的三角环有：$\underline{3,4},2;~\underline{3,4},3;~\underline{3,4},4;~\underline{3,4},5;~\underline{3,4},6$。

节点 $2,4,5$ 构成的三角环有：$\underline{1,2},2$。

所有三角环大小之和：$(7+8+9)+(7+8+\dots+11)+(9+10+\dots+13)+5=129$。

所有三角环的总个数：$3+5+5+1=14$。

$\sin T=\dfrac{129}{14}$，对 $10^9+7$ 取模后的结果为 $214285725$。

### 数据范围

**本题采用捆绑测试。**

- 特殊性质 A：保证 $T$ 中存在度为 $n-1$ 的节点。
- 特殊性质 B：保证 $T$ 中除了叶子节点，每个节点的度均为 $2$。
- 特殊性质 C：保证 $T$ 为满二叉树。

| Subtask | 分值 | $1\le n\le $ |  特殊性质 |
| :-----------: | :-----------: | :-----------: | :-----------: | 
| $1$ | $5$  | $3$ | 无 |
| $2$ | $13$ | $10^3$ |  无 |
| $3$ | $11$ | $7\times10^3$ | 无 |
| $4$ | $17$ | $10^5$ | A |
| $5$ | $17$ | $10^5$ | B |
| $6$ | $17$ | $10^5$ | C |
| $7$ | $20$ | $10^5$ |  无 |

对于 $100\%$ 的数据，$1\le n\le 10^5$，$1\le w\le 10^9$。

### 提示

在题目附件 `depression_sample.zip` 中：

- `depression_sample1.in` 即为样例 #1。
- `depression_sample2.in` 满足特殊性质 A。
- `depression_sample3.in` 满足特殊性质 B。
- `depression_sample4.in` 满足特殊性质 C。
- `depression_sample5.in` 不满足特殊性质。

## 样例 #1

### 输入

```
5
1 2 2
1 3 3
2 4 1
2 5 2```

### 输出

```
214285725```

## 样例 #2

### 输入

```
9
1 2 9
1 3 3
2 4 5
2 5 7
2 6 2
1 7 1
3 8 6
3 9 4```

### 输出

```
662721928```

# 题解

## 作者：Nt_Tsumiki (赞：8)

CF2063E pro max 加强版。

首先分子分母分开讨论，分母可以看 [link](https://www.luogu.com.cn/article/kxgxqpvv)，本文主要讨论分子。

一些约定：

- $D_u,D_v$ 表示 $u,v$ 的到根路径权值和；
- $d_u,d_v$ 表示 $u$ 到 $\text{LCA}(u,v)$ 的路径权值和和 $v$ 到 $\text{LCA}(u,v)$ 的路径权值和；
- 下文若无特殊说明，默认 $u$ 为二者中深度最深的节点。

然后我们对于 $\sum d_u+d_v$ 和 $\sum x$ 先分开考虑，对于后者我们有 $x\in [d_u-d_v+1,d_u+d_v-1]$，然后先大力推一波式子：

$$
\begin{aligned}
\sum\sum_{x=d_u-d_v+1}^{d_u+d_v-1}x=&\sum\sum_{x=1}^{d_u+d_v-1}x-\sum_{x=1}^{d_u-d_v}x\\
=&\sum\frac{(d_u+d_v)(d_u+d_v-1)}{2}-\frac{(d_u-d_v)(d_u-d_v+1)}{2}\\
=&\sum\frac{(d_u+d_v)^2-(d_u+d_v)}{2}-\frac{(d_u-d_v)^2+(d_u-d_v)}{2}\\
=&\sum\frac{(d_u+d_v)^2-(d_u-d_v)^2}{2}-\frac{(d_u+d_v)+(d_u-d_v)}{2}\\
=&\sum 2d_ud_v-d_u
\end{aligned}
$$

也就是说我们对于所有合法的 $u,v$ 要去计数 $2d_ud_v-d_u$，前者是简单的 dfs 时在 LCA 处统计即可，对于后者我们有 $d_u=D_u-D_{\text{LCA}(u,v)}$，对于后一项依旧在 LCA 处统计，前一项为了方便后续统计别的贡献，所以我们考虑在 $v$ 处统计，那把所有点按到根路径从大到小排个序，对于点 $v$ 假设他在排序好的序列中排名为 $i$，那么所有的 $(u,v)$ 数为 $i-1$，不合法的也一定是 $v$ 子树中的点被算成了 $u$ 数量为 $siz_v-1$，那么带上权也一样就是前缀到根路径权的和减去子树到根路径权的和。

对于 $\sum d_u+d_v$ 注意这个 $\sum$ 把系数省了，写全点是 $\sum (d_u+d_v-1-(d_u-d_v+1)+1)\times(d_u+d_v)$，依旧推一波式子：

$$
\begin{aligned}
\sum (d_u+d_v-1-(d_u-d_v+1)+1)\times(d_u+d_v)&=\sum (2d_v-1)(d_u+d_v)\\
&=\sum 2d_vd_u+2d_v^2-(d_u+d_v)\\
\end{aligned}
$$

对于前一项我们依旧在 LCA 处统计，最后一项也可以在 LCA 处统计，对于中间那一项由于带了一个指数，所以我们考虑拆成 $(D_v-D_{\text{LCA}(u,v)})^2=D_v^2+D_{\text{LCA}(u,v)}^2-2D_vD_{\text{LCA}(u,v)}$。

对于中间那一项依旧在 LCA 处统计，对于最后一项相当于给定 $v$ 对于所有合法的 $(u,v)$ 求出 $\sum D_{\text{LCA}(u,v)}$ 考虑 P4211 的做法，可以用树剖加线段树做到 2log，也可以用 LCT 做到 1log。

对于第一项，就是算合法 $(u,v)$ 数量，上面算 $\sum d_u$ 时提到为 $i-1-(siz_v-1)$。

综上，我们总结一下具体需要算哪些东西：

- 在 LCA 处我们要算所有合法以它为 LCA 的 $(u,v)$ 的 $\sum 4d_ud_v-(d_u+d_v)$ 以及 $\sum D_{\text{LCA}(u,v)}^2$。
- 在 $v$ 处我们要算钦定 $v$ 所有合法的 $(u,v)$ 的 $\sum -d_u+D_v^2-2D_vD_{\text{LCA}(u,v)}$。

总复杂度为 $O(n\log n)$ 或者是 $O(n\log^2 n)$，瓶颈在 P4211。

[submission](https://www.luogu.com.cn/record/201235463)

---

## 作者：万弘 (赞：5)

套路题。

考虑Dsu on tree.

考虑加入一个 $ b $ ,对所有 $ a\ge b $  产生贡献。 $ [a-b+1,a+b-1] $ 贡献了 $ 2b-1 $ 个三角，权值和为  $ a(2b-1)+b(2b-1)+2a(2b-1)/2 $ .

类似的，可以考虑对 $ a<b $ 产生贡献。

值域较大，直接的想法是用平衡树，维护和、平方和，然后单点修改区间询问。平衡树常数比较大可能是过不去的。

冷静一下发现，用到的值形如 $ dis_x-dis_u $ 的形式，其中 $ u $ 是当前求解的子树的根.用数据结构维护 $ dis_x $ ，相对大小同样不变，计算贡献时加上 $ -dis_u $ 这个偏移即可。

 $ dis_x $ 至多 $ n $ 种，离散化后树状数组维护即可，复杂度 $ O(n\log^2n) $ 常数很小。

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<vector>
#include<algorithm>
#include<random>
#include<chrono>
typedef long long ll;
typedef unsigned un;
typedef std::vector<int> P;
typedef std::pair<int,int> pii;
ll read(){ll x=0,f=1;char c=getchar();while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}while(c>='0'&&c<='9')x=x*10+(c-'0'),c=getchar();return f*x;}
ll max(ll a,ll b){return a>b?a:b;}
ll min(ll a,ll b){return a<b?a:b;}
template <typename T> bool umax(T& a,T t){if(t>a)return a=t,1;return 0;}
template <typename T> bool umin(T& a,T t){if(t<a)return a=t,1;return 0;}
/**********/
const int MAXN = 100011,mod = 1e9+7;
ll Qpow(ll a,ll p)
{
	ll res=1;
	while(p){if(p&1)res=res*a%mod;a=a*a%mod,p>>=1;}
	return res;
}
struct Mint
{
	int x;
	Mint(){x=0;}
	Mint(ll x):x((x%mod+mod)%mod) {}
	Mint operator* (Mint you){return ll(x)*you.x%mod;}
	Mint operator+ (Mint you){return x+you.x<mod?x+you.x:x+you.x-mod;}
	void operator+= (Mint you){x+=you.x;if(x>=mod)x-=mod;}
	Mint operator- (Mint you){return x-you.x<0?x-you.x+mod:x-you.x;}
	void operator-= (Mint you){x-=you.x;if(x<0)x+=mod;}
};
struct edge{int v,w,nxt;}e[MAXN<<1|1];
int cnt=0,last[MAXN];
void adde(int u,int v,int w){e[++cnt].v=v,e[cnt].w=w,e[cnt].nxt=last[u],last[u]=cnt;}

int fa[MAXN],size[MAXN],ms[MAXN],diff=0;
Mint ans,c;
ll fx[MAXN],dis[MAXN];
int pos[MAXN];
std::vector<int>a[MAXN];
struct BIT
{
	Mint t[MAXN],tot;
#define lowb (i&-i)
	void modify(int i,Mint k)
	{
		tot+=k;
		while(i<=diff)t[i]+=k,i+=lowb;
	}
	Mint Qsum(int i)
	{
		Mint res=0;
		while(i)res+=t[i],i-=lowb;
		return res;
	}
}t0,t1,t2;
void dfs1(int u)
{
	size[u]=1;
	for(int i=last[u];i;i=e[i].nxt)
	{
		int v=e[i].v;
		if(v==fa[u])continue;
		fa[v]=u,dis[v]=dis[u]+e[i].w, dfs1(v),size[u]+=size[v];
		if(size[v]>size[ms[u]])ms[u]=v;
	}
}

void calc(int u,Mint k)
{
	Mint s0=t0.Qsum(pos[u]),s1=t1.Qsum(pos[u]),s2=t2.Qsum(pos[u]);
	//As A
	Mint A(dis[u]-k.x);
	ans+=A*(s1-s0*k)*4;
	ans-=A*s0*2;
	ans+=(s2-s1*k*2+k*k*s0)*2;
	ans-=s1-s0*k;
	c+=(s1-s0*k)*2-s0;
	//As b
	s0=t0.tot-s0,s1=t1.tot-s1,s2=t2.tot-s2;
	Mint B=A;
	ans+=B*(s1-s0*k)*4;
	ans-=(s1-s0*k)*2;
	ans+=s0*B*B*2;
	ans-=s0*B;
	c+=(B*2-1)*s0;
	for(int i=last[u];i;i=e[i].nxt)
		if(e[i].v!=fa[u])calc(e[i].v,k);
}
void push(int u)
{
	t0.modify(pos[u],1),t1.modify(pos[u],dis[u]%mod);
	t2.modify(pos[u],(dis[u]%mod)*(dis[u]%mod)%mod);
	for(int i=last[u];i;i=e[i].nxt)
		if(e[i].v!=fa[u])push(e[i].v);
}
void back(int u)
{
	t0.modify(pos[u],Mint(-1)),t1.modify(pos[u],Mint(-dis[u]));
	t2.modify(pos[u],Mint(-(dis[u]%mod)*(dis[u]%mod)%mod));
	for(int i=last[u];i;i=e[i].nxt)
		if(e[i].v!=fa[u])back(e[i].v);
}
void solve(int u)
{
	for(int i=last[u];i;i=e[i].nxt)
	{
		int v=e[i].v;
		if(v==fa[u]||v==ms[u])continue;
		solve(v),back(v);
	}
	if(ms[u])solve(ms[u]);
	for(int i=last[u];i;i=e[i].nxt)
	{
		int v=e[i].v;
		if(v==fa[u]||v==ms[u])continue;
		calc(v,dis[u]),push(v);
	}
	t0.modify(pos[u],1),t1.modify(pos[u],dis[u]%mod);
	t2.modify(pos[u],(dis[u]%mod)*(dis[u]%mod)%mod);
}
int main()
{
	int n=read();
	for(int i=1;i<n;++i){int u=read(),v=read(),w=read();adde(u,v,w),adde(v,u,w);}
	dfs1(1);
	for(int i=1;i<=n;++i)fx[++diff]=dis[i];
	std::sort(fx+1,fx+diff+1),diff=std::unique(fx+1,fx+diff+1)-fx-1;
	for(int i=1;i<=n;++i)pos[i]=std::lower_bound(fx+1,fx+diff+1,dis[i])-fx;
	solve(1);
	printf("%lld\n",(ans.x*Qpow(c.x,mod-2)%mod+mod)%mod);
	return 0;
}
```



---

## 作者：dead_X (赞：5)

## 前言
松，就硬松
## 思路
首先不难发现所有三角形周长的**平均值**并不好求，考虑求所有三角形周长的**总和**和三角形的**数量**。

首先考虑如果两条边的长度为 $x,y$，不妨设 $x\geq y$，我们发现，第三条边的取值可以从 $(x-y+1)$ 到 $(x+y-1)$，共 $2y+1$ 个。然后这些三角形的平均边长即为 $2x+y$，总边长即为 $(2x+y)(2y+1)$。

因此，我们可以枚举两个点算出贡献，于是已经可以做到 $O(n^2)$ 了。

但是我们突然发现，我们有统计子树贡献利器：dsu on tree！

我们考虑所有 $\text{LCA}=x$ 的点对，就是若干棵子树两两之间贡献的和。

于是就可以套 dsu on tree 了，重子树直接保留贡献，轻子树每个节点搜一遍即可。

特别注意的是，在算 $\text{LCA}=x$ 的点对的时候，你应该将所有的点的点权全部剪掉 $x$ 到 $1$ 的距离。

因此，理论上，我们只要支持一个支持插入，删除，求所有 $\leq t$ 的数的 $0,1,2$ 次和的数据结构就解决了本题。

事实上上面那个式子拆起来十分复杂，需要充足的耐心。
## 代码
突然发现自己考场代码常数很小。

```cpp
// Problem: T164010 自傷無色
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/T164010?contestId=48570
// Memory Limit: 256 MB
// Time Limit: 1000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

//And in that light,I find deliverance.
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
const int p=1e9+7;
int qp(int x,int y)
{
	int res=1;
	for(int t=x; y; y>>=1,t=t*t%p) if(y&1) res=res*t%p;
	return res;
}
int a[100003];
int n,m,A,B;
int fa[200003],sz[100003];
int to[200003],nxt[200003],val[200003],head[100003],son[100003],cnt;
bool vis[200003];
int ins[200003],p1;
int stk[100003],top,L[100003];
int G0,G1;
int len;
int tr0[100003],tr1[100003],tr2[100003];
void add0(int x,int k)
{
	G0+=k;
	while(x<=len) tr0[x]+=k,x+=x&(-x);
	return ;
}
void add1(int x,int k)
{
	G1=(G1+k)%p;
	while(x<=len) tr1[x]=(tr1[x]+k)%p,x+=x&(-x);
	return ;
}
void add2(int x,int k)
{
	while(x<=len) tr2[x]=(tr2[x]+k)%p,x+=x&(-x);
	return ;
}
int q0(int x)
{
	int res=0;
	while(x) res+=tr0[x],x-=x&(-x);
	return res;
}
int q1(int x)
{
	int res=0;
	while(x) res=(res+tr1[x])%p,x-=x&(-x);
	return res;
}
int q2(int x)
{
	int res=0;
	while(x) res=(res+tr2[x])%p,x-=x&(-x);
	return res;
}
void INS(int x)
{
	add0(L[x],1),add1(L[x],a[x]%p),add2(L[x],(a[x]%p)*(a[x]%p)%p);
}
void DEL(int x)
{
	add0(L[x],-1),add1(L[x],(p-a[x]%p)),add2(L[x],(p-(a[x]%p)*(a[x]%p)%p));
}
void AA(int x,int C)
{
	stk[++top]=x;
	
	A=(A+C*C*6%p*G0)%p,A=(A+C*G0*3)%p;
	A=(A+(a[x]%p)*G1*4)%p;
	
	int P0=q0(L[x]-1);//<x的个数
	int P1=q1(L[x]-1);//一次和
	int P2=q2(L[x]-1);//二次和
	//smaller
	int Q0=G0-P0;
	int Q1=(G1+p-P1)%p;
	//greater
	
	B=(B+(p+p-C-C-1)*G0)%p;
	
	x=a[x]%p;

	A=(A+p-C*P1*8%p)%p;
	A=(A+p-C*x*4%p*P0)%p;
	A=(A+P2*2)%p;
	A=(A+p-P1)%p;
	A=(A+((p-x)<<1)*P0)%p;
	B=(B+P1*2%p)%p;

	A=(A+p-C*x*8%p*Q0)%p;
	A=(A+p-C*Q1*4%p)%p;
	A=(A+x*x*2%p*Q0)%p;
	A=(A+p-x*Q0%p)%p;
	A=(A+p+p-Q1-Q1)%p;
	B=(B+x*Q0*2)%p;
	return ;
}
void dfs1(int x)
{
    sz[x]=1;
    for(int i=head[x]; i; i=nxt[i])
    {
        int y=to[i];
        if(y==fa[x]) continue;
        fa[y]=x,a[y]=a[x]+val[i],dfs1(y),sz[x]+=sz[y];
        if(sz[y]>sz[son[x]]) son[x]=y;
    }
    return ;
}
void del(int x,int fa) 
{
  	DEL(x);
  	for(int i=head[x]; i; i=nxt[i]) if(to[i]!=fa) 
  		del(to[i],x);
  	return ;
}
void add(int x,int fa,int op) 
{
  	AA(x,op);
  	for(int i=head[x]; i; i=nxt[i]) if(to[i]!=fa) 
  		add(to[i],x,op);
  	return ;
}
void solve(int x,int fa) 
{
   	for(int i=head[x]; i; i=nxt[i]) if(to[i]!=fa&&to[i]!=son[x]) 
   		solve(to[i],x),del(to[i],x);
  	if(son[x]) solve(son[x],x); 
  	for(int i=head[x]; i; i=nxt[i]) if(to[i]!=fa&&to[i]!=son[x]) 
	{
		add(to[i],x,a[x]%p);
		while(top) INS(stk[top--]);
	}
	INS(x);
  	return ;
}
int lsh[100003];
signed main()
{
	n=read();
    for(int i=1,u,v,w; i<n; ++i)
        u=read(),v=read(),w=read(),
        to[++cnt]=v,val[cnt]=w,nxt[cnt]=head[u],head[u]=cnt,
        to[++cnt]=u,val[cnt]=w,nxt[cnt]=head[v],head[v]=cnt;
    dfs1(1);
    for(int i=1; i<=n; ++i) lsh[i]=a[i];
    sort(lsh+1,lsh+n+1);
    len=unique(lsh+1,lsh+n+1)-lsh-1;
    for(int i=1; i<=n; ++i) L[i]=lower_bound(lsh+1,lsh+len+1,a[i])-lsh;
    solve(1,0);
    //printf("%lld %lld\n",A,B);
    printf("%lld\n",A*qp(B,p-2)%p);
    return 0;
}
```

---

## 作者：Cry_For_theMoon (赞：4)

[传送门](https://www.luogu.com.cn/problem/P7815)

大家都说这是套路题，数据结构萌新爬了。

这题的部分分出的很合理，从菊花图拓展到两条链，然后拓展到二叉树，最后来到正解，可以说非常用心。如果没有部分分的引导我想一天都写不出来。理论上，普及组选手也有能力在这题拿到 80pts 的高分。

#### 一些基本东西：

我们设 $rsum_u$ 为点 $1$ 到点 $u$ 路径上的边权和。

考虑如果两个点 $(u,v)$，设 $d(u,w)=a,d(v,w)=b$，同时满足 $a \le b$，那么：

- 它们能组成的三角形个数为 $(2a-1)$。

- 它们能组成的三角形的边权和为 $(a+b)+(2ab-b)=(a+b)+b(2a-1)$。


#### subtask 4：

显然这是一个菊花图的形式。不妨考虑 $1$ 作为中心点的情况（其它情况是类似的）。

我们把 $rsum_2\sim rsum_n$ 抽出来排序。因为是菊花图，所以这里面每两个元素对都是可以计算答案的。考虑枚举 $a$，计算所有大于等于它的数和它组合所产生的贡献。那么我们需要知道：

- 大于等于 $a$ 的数（除了自己）的个数 $cnt$，用来计算 $\sum (2a-1)$。

- 大于等于 $a$ 的数的和 $sum$，用来计算 $\sum (a+b)+b(2a-1)=\sum a+\sum b+(2a-1)\sum b$。

这两个东西可以通过后缀和来维护，所以算上排序的复杂度，可以在 $O(n \log n)$ 的时间内维护。

#### subtask 5：

排除掉 $\sin T=0$ 的情况，则图一定形如根节点 $1$，挂了两条链的形态。

我们可以先把链 $1$ 里的 $rsum$ 排序，对于链 $2$ 的每个点，我们把它的 $rsum$ 当作 $a$，像刚才那样查询一下就可以了。对应地，把链 $2$ 的 $rsum$ 排序，对于链 $1$ 的每个点，把它的 $rsum$ 当作 $a$ 做类似的查询即可。时间复杂度依旧是 $O(n \log n)$。

#### subtask 6：

树的形态是一颗完全二叉树。一个事实是它只有大概 $\log n$ 层。

我们考虑枚举那个 $lca$ 点，即 $w$。那么 $w$ 不是叶子的情况下，会有两棵子树，你发现，如果只关注 $w$ 为根形成的子树，那么它的形态其实是类似上一个子任务的。即分成了左右两颗子树。那么类似地，我们先暴力找到左子树的每个点的 $rsum$，把它们放一起排序，然后暴力枚举右子树每个点，把它的 $rsum$ 当作 $a$ 做类似的查询。然后反过来搞一次。由于对于同一层的 $w$，它们遍历的点加起来是 $O(n)$ 级别的。又因为有大约 $\log n$ 层，所以总复杂度为 $O(n \log^2 n)$。

但是注意，这里的 $rsum$ 并不是从 $1$ 到 $u$ 的距离，而应该是从你枚举的 $w$ 到 $u$ 的距离。

#### 正解：

依旧考虑枚举 $w$。每次处理子树之间的所有信息。一个想法是考虑 dsu on tree。但是使用它的要求是合并处理子树 $u,v$ 信息的复杂度是 $O(\min\{sz_u,sz_v\}$。然后你注意到，刚才的算法里，我们仅考虑了 $a\le b$ 的情况，我们希望能在确定 $b$ 的情况下，计算所有 $a \le b$ 的数和它构成的数对的贡献。如果可以实现，那么才可以考虑 dsu on tree。还是那两个式子：

- $\sum (2a-1)$

- $(\sum (2a-1)(a+b))+(b\sum (2a-1))$

因为不能排序，所以我们考虑离散化一开始的 $rsum$，再用值域当作下标，又因为只关心前缀和后缀的答案，考虑到常数影响，建树状数组维护。显然我们需要维护二次和，一次和，零次和。

但是注意到，$rsum$ 是在时刻变化的。考虑我们直接插入 $1$ 为根的 $rsum$。但实际上对于一个点 $u$，它的值不是 $rsum_u$ 而是 $(rsum_u-rsum_w)$。

容易发现零次和不随着 $w$ 的变化而变化。而一次和和二次和，我们拆式子只有，可以发现，它可以通过统计零次和来求出。

所以总复杂度是 $O(n \log^2 n)$ 的。我维护了 $6$ 个树状数组最后写完才发现只需要 $5$ 个。

```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define per(i,a,b) for(int i=(a);i>=(b);i--)
#define op(x) ((x&1)?x+1:x-1)
#define odd(x) (x&1)
#define even(x) (!odd(x))
#define lc(x) (x<<1)
#define rc(x) (lc(x)|1)
#define lowbit(x) (x&-x)
#define Max(a,b) (a>b?a:b)
#define Min(a,b) (a<b?a:b)
#define next Cry_For_theMoon
#define il inline
#define pb(x) push_back(x)
#define is(x) insert(x)
#define sit set<int>::iterator
#define mapit map<int,int>::iterator
#define pi pair<int,int>
#define ppi pair<int,pi>
#define pp pair<pi,pi>
#define fr first
#define se second
#define vit vector<int>::iterator
#define mp(x,y) make_pair(x,y)
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned int uint;
typedef double db;
using namespace std;
const int MAXN=1e5+10,MAXM=2e5+10,mod=1e9+7;
ll power(ll a,ll n){
	if(!n)return 1;
	ll tmp=power(a,n/2);tmp=tmp*tmp%mod;
	if(n&1)tmp=tmp*a%mod;return tmp;
}
struct Edge{
	int u,v,w;
}edge[MAXM];
int first[MAXN],next[MAXM],tot;
int n,flag,cnt,deg[MAXN];
int ridx[MAXN],sz[MAXN],son[MAXN];
ll rsum[MAXN],b[MAXN],tt,ans1,ans2;
struct BIT{
	ll lim,tree[MAXN];
	void Init(){lim=tt;}
	void updatepre(int x,ll val){
		for(;x<=lim;x+=lowbit(x))tree[x]=(tree[x]+val%mod+mod)%mod;
	}
	ll querypre(int x){
		ll ret=0;
		for(;x;x-=lowbit(x))ret=(ret+tree[x])%mod;
		return ret;
	}
	void updatesuf(int x,ll val){
		updatepre(lim-x+1,val);
	} 
	ll querysuf(int x){
		return querypre(lim-x+1);
	}
}pre1,pre2,pre3,suf1,suf2,suf3;
void addedge(int u,int v,int w){
	edge[++tot]=(Edge){u,v,w};
	next[tot]=first[u];first[u]=tot;
}
il void modify(int u,int flag){
	ll val=rsum[u]%mod;
	pre1.updatepre(ridx[u],1*flag);
	pre2.updatepre(ridx[u],val*flag);
	pre3.updatepre(ridx[u],val*val*flag);
	suf1.updatesuf(ridx[u],1*flag);
	suf2.updatesuf(ridx[u],val*flag);
	suf3.updatesuf(ridx[u],val*val*flag);
}
il void query(int u,int rt){
	//计算根节点为rt时，节点u的贡献
	ll mn=rsum[rt]%mod,val=rsum[u]%mod;
	val=(val-mn+mod)%mod;
	//1.计算对个数的贡献
	//计算大于等于val的部分
	ll cnt=suf1.querysuf(ridx[u]);
	ans2=(ans2+((2*val-1+mod)%mod)*cnt%mod)%mod; 
	//计算小于val的部分 
	if(ridx[u]>1){
		//计算sum 2a-1 
		ll cnt=pre1.querypre(ridx[u]-1); 
		ll sum=pre2.querypre(ridx[u]-1);
		sum=(sum-cnt*mn%mod+mod)%mod; 
		ans2=(ans2+(2*sum-cnt+mod)%mod)%mod;
	}
	//2.计算对总和的贡献 
	//计算大于等于val的部分
	ll sum=suf2.querysuf(ridx[u]);
	sum=(sum-cnt*mn%mod+mod)%mod;
	ans1=(ans1+((2*val-1+mod)%mod)*sum%mod)%mod;
	ans1=(ans1+((2*val-1+mod)%mod)*((sum+cnt*val%mod)%mod)%mod)%mod; //(2a-1)*(suma+sumb) 
	//计算小于val的部分
	if(ridx[u]>1){
		ll cnt=pre1.querypre(ridx[u]-1);
		ll sum=pre2.querypre(ridx[u]-1);
		sum=(sum-cnt*mn%mod+mod)%mod;
		ans1=(ans1+((2*sum-cnt+mod)%mod)*val%mod)%mod;	
		//计算对于固定的b，计算2a^2+2ab-a-b的值
		ll sum2=pre3.querypre(ridx[u]-1);
		ll mn2=mn*mn%mod;
		sum2=(sum2+cnt*mn2%mod)%mod;
		ll tmpsum=pre2.querypre(ridx[u]-1);
		sum2=(sum2-((2*mn%mod)*tmpsum)%mod+mod)%mod;
		ans1=(ans1+2*sum2)%mod;
		ans1=(ans1+(2*sum%mod)*val%mod)%mod;
		ans1=(ans1-sum+mod)%mod;
		ans1=(ans1-val*cnt%mod+mod)%mod;
	} 
}
void add(int u,int fa,int flag){
	modify(u,flag); 
	for(int j=first[u];j;j=next[j]){
		int v=edge[j].v;if(v==fa)continue;
		add(v,u,flag);
	}
}
void calc(int u,int fa,int rt){
	query(u,rt);
	for(int j=first[u];j;j=next[j]){
		int v=edge[j].v;if(v==fa)continue;
		calc(v,u,rt);
	}
}
void dfs1(int u,int fa){
	sz[u]=1;b[++tt]=rsum[u];
	for(int j=first[u];j;j=next[j]){
		int v=edge[j].v;if(v==fa)continue;
		rsum[v]=rsum[u]+edge[j].w;
		dfs1(v,u);
		sz[u]+=sz[v];
		if(son[u]==0 || sz[son[u]]<sz[v])son[u]=v;
	}
}
void dfs2(int u,int fa){
	for(int j=first[u];j;j=next[j]){
		int v=edge[j].v;if(v==fa || v==son[u])continue;
		dfs2(v,u);
		add(v,u,-1);
	}
	if(son[u])dfs2(son[u],u);
	for(int j=first[u];j;j=next[j]){
		int v=edge[j].v;if(v==fa || v==son[u])continue;
		calc(v,u,u);
		add(v,u,1);
	}
	if(u!=1){
		modify(u,1);
	}
}
int main(){
	scanf("%d",&n);
	if(n<=2){return printf("0\n"),0;}
	rep(i,1,n-1){
		int u,v,w;scanf("%d%d%d",&u,&v,&w);
		addedge(u,v,w);addedge(v,u,w);
		deg[u]++;deg[v]++;
	}
	flag=1;
	rep(i,1,n){
		if(deg[i]>3)flag=0;
		if(deg[i]==1)cnt++;
	}
	if(flag && cnt==2 && deg[1]==1){
		return printf("0\n"),0; 
	}
	dfs1(1,0);
	sort(b+1,b+1+tt);
	tt=unique(b+1,b+1+tt)-b-1;
	rep(i,1,n)ridx[i]=lower_bound(b+1,b+1+tt,rsum[i])-b;
	pre1.Init();pre2.Init();pre3.Init();suf1.Init();suf2.Init();suf3.Init();
	dfs2(1,0);
	printf("%lld",(ans1%mod)*power(ans2%mod,mod-2)%mod);
	return 0;
}
```


---

## 作者：gyh20 (赞：4)

假设我们令三角形的的其中两边分别为 $a,b(a<b)$，则第三边 $c$ 需满足 $b-a<c<b+a$。

于是 $c$ 的方案数为 $(b+a)-(b-a)-1=2a-1$。

所有方案中 $c$ 之和为 $[b-a+1,b+a-1]$ 中所有数之和，等差数列求和得到 $\dfrac{(2a-1)2b}{2}$，加上所有方案中 $a,b$ 的贡献得到 $\dfrac{(2a-1)(4b+2a)}{2}$。

套路的，由于我们想同时知道 $a,b$，可以采用 DSU on tree，每次枚举到一个数，分类讨论这是 $a$ 还是 $b$，发现上面的式子在一项固定时是关于另一项的不超过二次的多项式，直接维护值域区间的 $0,1,2$ 次方和即可。

比赛用的是动态开点线段树：

```
#include<bits/stdc++.h>
#define re register
#define int long long
using namespace std;
const int Mxdt=100000;
inline char gc(){
	static char buf[Mxdt],*p1=buf,*p2=buf;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,Mxdt,stdin),p1==p2)?EOF:*p1++;
}
inline int read(){
	re int t=0;re char v=gc();
	while(v<'0')v=gc();
	while(v>='0')t=(t<<3)+(t<<1)+v-48,v=gc();
	return t;
}
const int M=1e9+7;
inline int ksm(re int x,re int y){
	re int s=1;
	while(y){
		if(y&1)s=1ll*s*x%M;
		x=1ll*x*x%M,y>>=1;
	}
	return s;
}
int sz1[3000002],sz2[3000002],sz3[3000002],tot,ls[3000002],rs[3000002],siz[200002],n,son[200002],head[200002],cnt,s1,s2,s3,ans1,ans2,rt,tg,inf,T;
struct edge{int to,next,w;}e[400002];
inline void add(re int &x,re int y){(x+=y)>=M?x-=M:x;}
inline int Mod(re int x){return x>=M?x-M:x;}
inline void addd(re int x,re int y,re int z){e[++cnt]=(edge){y,head[x],z},head[x]=cnt;}
inline void ins(re int &p,re int l,re int r,re int x,re int z){
	if(!p)p=++tot;
	++sz1[p],add(sz2[p],z),add(sz3[p],T);
	if(l==r)return;
	re int mid=l+r>>1;
	if(x<=mid)ins(ls[p],l,mid,x,z);
	else ins(rs[p],mid+1,r,x,z);
}
inline void ask(re int p,re int l,re int r,re int x,re int y){
	if(!p)return;
	if(l>=x&&r<=y){
		s1+=sz1[p];
		add(s2,sz2[p]);
		add(s3,sz3[p]);
		return;
	}
	re int mid=l+r>>1;
	if(x<=mid)ask(ls[p],l,mid,x,y);
	if(y>mid)ask(rs[p],mid+1,r,x,y);
}
inline void dfs(re int x,re int y,re int D){
	siz[x]=1,inf=max(inf,D);
	for(re int i=head[x];i;i=e[i].next)
		if(e[i].to^y){
			dfs(e[i].to,x,D+e[i].w),siz[x]+=siz[e[i].to];
			if(siz[e[i].to]>siz[son[x]])son[x]=e[i].to;
		}
}
inline void dfs2(re int x,re int y,re int z){
	re int ttt=Mod((z-tg)%M+M);T=ttt*ttt%M;
	ins(rt,-inf,inf,z-tg,ttt);
	for(re int i=head[x];i;i=e[i].next)if(e[i].to^y)dfs2(e[i].to,x,z+e[i].w);
}
inline void calc(re int x,re int y,re int z){
	re int sss=z;z%=M;
	re int ttt=tg;tg%=M;
	s1=s2=s3=0,ask(rt,-inf,inf,-inf,sss-ttt);
	s3+=(tg*tg%M*s1%M+2*tg*s2%M%M),s3%=M,s2=(s2+tg*s1)%M;
	ans1=(ans1+2ll*s2-s1+M)%M;
	ans2=Mod(ans2+1ll*2*z%M*((2ll*s2-s1+M))%M);
	add(ans2,s3),add(ans2,s3),add(ans2,M-s2);
	s1=s2=s3=0,ask(rt,-inf,inf,sss-ttt+1,inf);
	s3+=(tg*tg%M*s1%M+2*tg*s2%M),s3%=M,s2=(s2+tg*s1)%M;
	ans1=(ans1+(2ll*z-1+M)%M*s1)%M;
	ans2=(ans2+((4ll*z*z%M-2*z)%M*s1+8*z*s2%M-s2*4)%M*(M+1>>1)+M)%M;
	z=sss,tg=ttt;
	for(re int i=head[x];i;i=e[i].next)if(e[i].to^y)calc(e[i].to,x,z+e[i].w);
}
inline void dfs1(re int x,re int y,re int z){
	for(re int i=head[x];i;i=e[i].next)if(e[i].to^y&&e[i].to^son[x])dfs1(e[i].to,x,1);
	if(son[x]){
		dfs1(son[x],x,0);
		re int ttt=M-tg%M;
		T=ttt*ttt%M;
		ins(rt,-inf,inf,-tg,ttt);
	}
	for(re int i=head[x];i;i=e[i].next)if(e[i].to==son[x])tg+=e[i].w;
	for(re int i=head[x];i;i=e[i].next)if(e[i].to^y&&e[i].to^son[x])calc(e[i].to,x,e[i].w),dfs2(e[i].to,x,e[i].w);
	if(z){
		for(re int i=1;i<=tot;++i)ls[i]=rs[i]=sz1[i]=sz2[i]=sz3[i]=0;
		rt=tg=tot=0;
	}
}
signed main(){
	n=read();
	for(re int i=1,x,y,z;i<n;++i){
		x=read(),y=read(),z=read();
		addd(x,y,z),addd(y,x,z);
	}
	dfs(1,1,0),dfs1(1,1,0);
	ans1%=M,ans2%=M,ans1+=M,ans2+=M,ans1%=M,ans2%=M;
	printf("%lld",1ll*ans2*ksm(ans1,M-2)%M);
}
```

---

## 作者：LFCode (赞：3)

膜拜上方万佬爷！本来是没有打算写题解的，不过刚才看到万爷爷写了，那我也来写一种做法吧。

设树上用于构成三角形的两边中较长边为 $x$，较短边为 $y$。显然第三边的长度范围为 $[x-y+1,x+y-1]$。不难发现一组 $x,y$ 可以构成的三角形数目为 $2y-1$。类似地列出三边之和的柿子，化简之后可以发现其与 $xy$ 的乘积、$y^2$ 以及 $x,y$ 自身数值有关。

这启示我们对树上每个点建立一棵以深度为下标的线段树，维护其子树内的点数、深度和、深度平方和。之后一遍 DFS 向上线段树合并即可。

至于答案统计，可以在合并过程中用一种类似归并排序求逆序对的思想：假设当前要合并 $p,q$ 两棵线段树，我们计算一下 $x$ 在 $p$ 的右儿子、$y$ 在 $q$ 的左儿子所能产生的贡献，以及 $x$ 在 $q$ 的右儿子、$y$ 在 $p$ 的左儿子所能产生的贡献。至于 $x,y$ 均处于左儿子或右儿子中的情况，就等到递归下去继续合并的过程中再计算。其实也是比较套路的做法，今年 THUSC D1T2 也可以这么做。

复杂度大概是一枚 $\log$，但是常数巨大，而且我场上写的代码取模次数多的吓人，再加上因为懒得处理乘法溢出的情况我就直接搞了 `#define int long long`，下面这份代码跑得非常慢，实际效率被万爷爷的小常数两 $\log$ 吊着打。

蚂蜂丑写法也丑，求轻喷。

```c++
#include<cstdio>
#include<algorithm>
#define int long long
using std::sort;
const int N=100086,MOD=1e9+7;
int n,ans1,ans2,tot,pc,nval,h[N],a[N];
long long depth[N];
struct edge{int v,w,nxt;}e[N<<1];
struct asdf{
	int val,pos;
	bool operator <(const asdf b)const{return val<b.val;}
}tmp[N];
struct node{
	int lc,rc,sum,sq,cnt;
	int ls(){return lc?lc:lc=++pc;}
	int rs(){return rc?rc:rc=++pc;}
}t[10000086];
int Add(int &a,int b){return(a+=b)>=MOD?a-=MOD:a;}
int Sub(int &a,int b){return(a-=b)<0?a+=MOD:a;}
int sq(int x){return 1ll*x*x%MOD;}
int read(){
	char ch=getchar();int nn=0,ssss=1;
	while(ch<'0'||ch>'9'){if(ch=='-')ssss*=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){nn=nn*10+(ch-'0');ch=getchar();}
	return nn*ssss;
}
int qpow(int a,int b){
	int ret=1;
	while(b){if(b&1)ret=1ll*ret*a%MOD;a=1ll*a*a%MOD;b>>=1;}
	return ret;
}
bool add(int u,int v,int w){
	e[++tot].v=v;
	e[tot].w=w;
	e[tot].nxt=h[u];
	h[u]=tot;
	return true;
}
bool pre_dfs(int np,int lst){
	tmp[np].pos=np;tmp[np].val=depth[np];
	for(int i=h[np];i;i=e[i].nxt){
		if(e[i].v==lst)continue;
		depth[e[i].v]=depth[np]+e[i].w;
		pre_dfs(e[i].v,np);
	}
	return true;
}
bool change(int k,int l,int r,int x,int y){
	Add(t[k].sum,y);Add(t[k].sq,sq(y));Add(t[k].cnt,1);
	if(l==r)return true;
	int mid=(l+r)>>1;
	if(x<=mid)return change(t[k].ls(),l,mid,x,y);
	return change(t[k].rs(),mid+1,r,x,y);
}
#define rsum(x) ((t[x].sum-1ll*dt*t[x].cnt%MOD+MOD)%MOD)
#define rsq(x) ((1ll*(t[x].sq-2ll*rsum(x)*dt%MOD-1ll*dt*dt%MOD*1ll*t[x].cnt%MOD)+MOD+MOD)%MOD)
int Merge(int p,int q,int l,int r,int dt){
	if((!p)||(!q))return p|q;
	if(l==r){
		Add(ans1,4ll*rsum(p)*rsum(q)%MOD);
		Add(ans1,2ll*rsq(p)*t[q].cnt%MOD);
		Sub(ans1,3ll*rsum(p)*t[q].cnt%MOD);
		Add(ans2,1ll*(2ll*rsum(p)%MOD-t[p].cnt+MOD)%MOD*1ll*t[q].cnt%MOD);
	}
	int mid=(l+r)>>1;
	Add(ans1,4ll*rsum(t[p].lc)*rsum(t[q].rc)%MOD); //+4xy
	Add(ans1,4ll*rsum(t[q].lc)*rsum(t[p].rc)%MOD);
	Add(ans1,2ll*rsq(t[p].lc)*t[t[q].rc].cnt%MOD); //+2y^2
	Add(ans1,2ll*rsq(t[q].lc)*t[t[p].rc].cnt%MOD);
	Sub(ans1,2ll*rsum(t[p].rc)*t[t[q].lc].cnt%MOD);//-2x
	Sub(ans1,2ll*rsum(t[q].rc)*t[t[p].lc].cnt%MOD);
	Sub(ans1,1ll*rsum(t[p].lc)*t[t[q].rc].cnt%MOD);//-y
	Sub(ans1,1ll*rsum(t[q].lc)*t[t[p].rc].cnt%MOD);
	Add(ans2,1ll*(2ll*rsum(t[q].lc)%MOD-t[t[q].lc].cnt+MOD)%MOD*1ll*t[t[p].rc].cnt%MOD);//+(2y-1)
	Add(ans2,1ll*(2ll*rsum(t[p].lc)%MOD-t[t[p].lc].cnt+MOD)%MOD*1ll*t[t[q].rc].cnt%MOD);
	Add(t[p].sq,t[q].sq);Add(t[p].sum,t[q].sum);Add(t[p].cnt,t[q].cnt);
	t[p].lc=Merge(t[p].lc,t[q].lc,l,mid,dt);
	t[p].rc=Merge(t[p].rc,t[q].rc,mid+1,r,dt);
	return p;
}
bool dfs(int np,int lst){
	for(int i=h[np];i;i=e[i].nxt){
		if(e[i].v==lst)continue;
		dfs(e[i].v,np);
		Merge(np,e[i].v,1,nval,depth[np]%MOD);
	}
//	printf("%d:%d,%d.\n",np,ans1,ans2);
	change(np,1,nval,a[np],depth[np]%MOD);
	return true;
}
signed main(){
	pc=n=read();
	for(int i=1;i<n;i++){
		int u=read();int v=read();int w=read();
		add(u,v,w);add(v,u,w);
	}
	pre_dfs(1,0);
	sort(tmp+1,tmp+n+1);
	for(int i=1;i<=n;i++){
		nval+=(i==1||tmp[i].val>tmp[i-1].val);
		a[tmp[i].pos]=nval;
	}
	dfs(1,0);
	printf("%d",1ll*ans1*qpow(ans2,MOD-2)%MOD);
}
```

---

## 作者：言琢დ (赞：2)

**Analysis 三角函树**

注：DS=数据结构

首先对树做一遍 dfs 序，它的性质是同一子树位置连续，方便 DS 统一维护。

设 $sum_i$ 表示结点 $i$ 到 lca 路径边权和。

在 dfs 序的基础上，按深度从小到大枚举 lca。

每次深度向下加一时，用 DS 统一把 $sum$ 对应位置减去 $value$，其中 $value$ 表示向下跳的这条边的边权。

其中枚举 lca（仅含一个子树一定不能作为 lca）：

取它两个子树内的两点 $u,v$，实际就是取两个区间内的两点 $u,v$。

查询的是 $d_1=d(u,w)=sum_u,~d_2=d(v,w)=sum_v$，不妨设 $d_1\le d_2$。

据此第三条边取值范围 $\left[x_L=d_2-d_1+1,x_R=d_2+d_1-1\right]$。

由此，简单求和可知：（设 $num=x_R-x_L+1$）

1. 所有树三角大小的和 $s_1 \leftarrow s_1+num\times(d_1+d_2)+\dfrac{(x_L+x_R)\times num}{2}$。

2. 不同树三角总数量 $s_2 \leftarrow s_2+(x_R-x_L+1)$。

此时最终答案为 $Ans \leftarrow s_1\times s_2^{Mod-2}$。（$\dfrac{s_1}{s_2}$ 用 $s_2$ 的逆元表示）

现在在于如何 $O(\log)$ 算出来一对子树对答案的贡献：

$s_2$ 后面的式子：

$$\begin{aligned}num&=x_R-x_L+1\\&=(d_2+d_1-1)-(d_2-d_1+1)+1\\&=2d_1-1\end{aligned}$$

$s_1$ 后面的式子：

$$\begin{aligned}&=num\times(d_1+d_2)+\frac{(xL+xR)\times num}{2}\\&=num\times\left(d_1+d_2+\frac{xL+xR}{2}\right)\\&=(2d_1-1)\times\left(d_1+d_2+\frac{(d_2-d_1+1)+(d_2+d_1-1)}{2}\right)\\&=(2d_1-1)\times(2d_2+d_1)\end{aligned}$$

设两个子树大小为 $size_1,size_2$，枚举 $size$ 较小的子树内每个点 $u$，并 $O(1)$ 得到它的 $d_1$ 值。

DS 取出另一段区间内满足 $d_1\le d_2$ 的所有点，计算贡献：

$s_2$ 的贡献好算，直接统计多少个点满足，假如有 $cnt$ 个，那么贡献就是 $cnt\times(2d_1-1)$。

$s_1$ 的贡献是 $s_2$ 的贡献再乘上一个 $(2d_2+d_1)$，考虑提公因式 $(2d_1-1)$，只需要算 $\sum\limits(2d_2+d_1)$，

$d_1\times cnt+2\sum d_2$，一段区间不小于某定值的数的个数和数的和，均为基础 DS 可以维护的信息。

至此本题 $O(n\log^2n)$。

一句话说实质：把 $O(n)$ 枚举的孩子结点 $u,v$ 换成了批量处理的 $O(\log)$，体现在复杂度上就是将一个 $O(n)$ 换成了一个 $O(\log)$。

本文中提到的 DS，作者实现时均采用线段树。

---

## 作者：Mobius127 (赞：1)

[题传](https://www.luogu.com.cn/problem/P7815)

琢磨了好久发现柿子少了个系数。。。

记 $a=\max(\operatorname{dist}(u, w), \operatorname{dist}(v, w)), b=\min(\operatorname{dist}(u, w), \operatorname{dist}(v, w))$

平均值不好求，我们来分别搞搞 所有树三角大小的和 $FZ$ 与 不同树三角总数量 $FM$。

我们知道，若三角形其中两边为 $a, b$，则第三边长的范围应在 $(a-b, a+b)$ 之间（三角不等式）。

那么一对 $(a, b)$ 对 $FM$ 的贡献就是 $len(a-b+1, a+b-1)=2b-1$，它对 $FZ$ 的贡献就是 $\sum_{i=a-b+1}^{a+b-1}1=4ab+2b^2-2a-b$。

思考 $a, b$ 的实际意义：$u, v$ 到 $w=\operatorname{LCA}(u, v)$ 的距离，显然暴力枚举 $u, v$ 是不现实的，考虑枚举 $w$，那么所有的 $u, v$ 都在 $w$ 这颗子树内。

我们知道，统计子树有两个法宝：`dsu on tree` 和 `线段树合并`，这里使用 `线段树合并`。

为了抛开 $\max$ 的干扰，我们把每个 $\operatorname{dist}(x, w)$ 都丢到权值线段树树上，这样的话，我们在线段树合并的时候，只需要分别考虑 $a$ 在哪一颗树的右边就好了。

但是这样做还是不对，在合并的时候，我们需要把从 $w$ 引出的每一条边都算到线段树里面，这样就导致了每个结点的偏移量不一样，我们不可能花大量时间去重构整颗线段树。

考虑用前缀和优化，记 $sum_x$ 为 $\operatorname{dist}(1, x)$，那么 $\operatorname{dist}(x, w)=sum_x-sum_w$，由于每个结点都在 $w$ 子树内，所以我们直接把 $sum_x$ 丢进线段树内，再消除 $sum_w$ 的影响就没问题了。

那么你的柿子还要改改...令 $S=sum_w, a=\max(sum_u, sum_v),b=\min(sum_u, sum_v)$。

一对 $(u, v)$ 对 $FM$ 产生的贡献为 

$$2(b-S)-1=2b-2S-1$$

一对 $(u, v)$ 对 $FZ$ 产生的贡献为 

$$4(a-S)(b-S)+2(b-S)^2-2(a-S)-(b-S)$$ 

$$=4ab-(4S+2)a-(8S+1)b+6S^2+3S+2b^2$$

推一推柿子呗，令 $X$ 线段树上值域小的一部分，$Y$ 为值域大的一部分，线段树上面分别维护值的个数 $cnt$，所有值的和 $S1$，所有值的平方和 $S2$：

$$FM=\sum_{b \in X}\sum_{a \in Y} 2b-2S-1$$

$$=(\sum_{b \in X}2b \sum_{a\in Y}1)-(2S+1)(\sum_{b \in X} \sum_{a\in Y}1)$$

$$=2 X_{S1}Y_{cnt}-(2S+1)X_{cnt}Y_{cnt}$$

$$FZ=\sum_{b \in X}\sum_{a \in Y}4ab-(4S+2)a-(8S+1)b+6S^2+3S+2b^2$$

$$FZ=4\sum_{b \in X} b Y_{S1}-(4S+2)\sum_{a \in Y}aX_{cnt}-(8S+1)\sum_{b \in X}bY_{cnt}+$$

$$(6S^2+3S)(\sum_{b \in X}\sum_{a \in Y}1)+2\sum_{b \in X}b^2Y_{cnt}$$

$$=4X_{S1}Y_{S1}-(4S+2)X_{cnt}Y_{S1}-(8S+1)X_{S1}Y_{cnt}+$$

$$(6S^2+3S)X_{cnt}Y_{cnt}+2X_{S2}Y_{cnt}$$

这下就好看多了（

写成代码：

```cpp
int mul(int a, int b){return 1ll*a*b%mo;}
int add(int a, int b){return (a+b)%mo;}
int mis(int a, int b){return ((a-b)%mo+mo)%mo;}
void Solve(node X, node Y){
	//Y 中元素比 X 都大
	if(!X.cnt||!Y.cnt) return ;
	int Cnt=mul(X.cnt, Y.cnt), s2=mul(S, S);//一共多少对 
	FM=add(FM, mis(mul(mul(2, X.Si), Y.cnt), Cnt));
	FM=mis(FM, mul(2, mul(Cnt, S)));
	int zheng=add( mul(4, mul(X.Si, Y.Si)), mul(mul(6, s2), Cnt) );
	zheng=add(zheng, add(mul(3, mul(S, Cnt)), mul(mul(2, X.Si2), Y.cnt)));
	int as=add(mul(4, S), 2), bs=add(mul(8, S), 1), fu;
	fu=add(mul(mul(as, Y.Si), X.cnt), mul(mul(bs, X.Si), Y.cnt));
	FZ=mis(add(FZ, zheng), fu);
	return ;
}
```

注意值域最大珂以到 $10^{14}$，考虑离散化，维护的东西还是一样的。

总复杂度 $O(n \log n)$，但是因为寻址不太连续所以跑的可能会比两个 $\log$ 的慢。

~~当然也可能是我常数太大了。~~

### Code：

```cpp
#include <stdio.h>
#include <algorithm>
#include <string.h>
#include <stdlib.h>
#include <cctype>
#include <vector>
#define int long long
using namespace std;
typedef long long ll;
const int INF=0x3f3f3f3f;
const int mo=1e9+7;
const int inv2=500000004;
inline int read(){
	char ch=getchar();int x=0, f=1;
	while(!isdigit(ch)){if(ch=='-') f=-1; ch=getchar();}
	while(isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return x*f;
}
int mul(int a, int b){return 1ll*a*b%mo;}
int add(int a, int b){return (a+b)%mo;}
int mis(int a, int b){return ((a-b)%mo+mo)%mo;}
int ksm(int a, int b){int res=1;for(; b; b>>=1, a=mul(a, a)) if(b&1) res=mul(res, a);return res;}
const int N=1e5+2;
long long sum[N], p[N];
int FZ, FM, n, sum_mod[N], root[N], S, m;
vector < pair <int, int> > G[N];
struct node{
	int lc, rc, cnt, Si, Si2, f;
	#define ls(k) (T[k].lc)
	#define rs(k) (T[k].rc)
	#define Cnt(k) (T[k].cnt)
	#define S1(k) (T[k].Si)
	#define S2(k) (T[k].Si2)
}T[N*20];
vector <int> rub;
int nodecnt;
int newnode(){
	if(!rub.empty()){int x=rub[rub.size()-1];rub.pop_back();return x;};
	return ++nodecnt;
}
void deleet(int x){ls(x)=rs(x)=Cnt(x)=S1(x)=S2(x)=0;rub.push_back(x);}
#define mid (l+r>>1)
inline void pushup(int k, int lc, int rc){Cnt(k)=Cnt(lc)+Cnt(rc);S1(k)=add(S1(lc), S1(rc)), S2(k)=add(S2(lc), S2(rc));}
void insert(int &k, int l, int r, int x, int v){
	if(!k) k=newnode();
	if(l==r){Cnt(k)+=1, S1(k)=add(S1(k), v), S2(k)=add(S2(k), mul(v, v));return ;}
	if(x<=mid) insert(ls(k), l, mid, x, v);
	else insert(rs(k), mid+1, r, x, v);
	pushup(k, ls(k), rs(k));
}
void Solve(node X, node Y){
	//Y 中元素比 X 都大
	if(!X.cnt||!Y.cnt) return ;
	int Cnt=mul(X.cnt, Y.cnt), s2=mul(S, S);//一共多少对 
	FM=add(FM, mis(mul(mul(2, X.Si), Y.cnt), Cnt));
	FM=mis(FM, mul(2, mul(Cnt, S)));
	int zheng=add( mul(4, mul(X.Si, Y.Si)), mul(mul(6, s2), Cnt) );
	zheng=add(zheng, add(mul(3, mul(S, Cnt)), mul(mul(2, X.Si2), Y.cnt)));
	int as=add(mul(4, S), 2), bs=add(mul(8, S), 1), fu;
	fu=add(mul(mul(as, Y.Si), X.cnt), mul(mul(bs, X.Si), Y.cnt));
	FZ=mis(add(FZ, zheng), fu);
	return ;
}
int egrem(int p, int q, int l, int r, int x, int y){
	if(!p||!q) return p+q;
	if(l!=r){
		Solve(T[T[p].lc], T[T[q].rc]), Solve(T[T[q].lc], T[T[p].rc]);
		ls(p)=egrem(ls(p), ls(q), l, mid, 0, 0), rs(p)=egrem(rs(p), rs(q), mid+1, r, 0, 0);
		pushup(p, ls(p), rs(p));
	} 
	else Solve(T[p], T[q]), pushup(p, p, q);
	deleet(q);
	return p;
}
pair <int, int> Tmp1, Tmp2;
void dfs(int x, int fa){
	for(int i=0; i<G[x].size(); i++){
		int v=G[x][i].first, w=G[x][i].second;
		if(v==fa) continue;
		p[v]=sum[v]=sum[x]+w, sum_mod[v]=add(sum[x], w);
		dfs(v, x);
	}
}
void solve(int x, int fa){
	for(int i=0; i<G[x].size(); i++){
		int v=G[x][i].first;
		if(v==fa) continue;solve(v, x);
		S=sum_mod[x];
		root[x]=egrem(root[x], root[v], 1, m, x, v);
	}
	int id=lower_bound(p+1, p+m+1, sum[x])-p;
	insert(root[x], 1, m, id, sum_mod[x]);
}
signed main(){
	n=read();
	for(int i=1, x, y, z; i<n; i++)
		Tmp2.first=read(), Tmp1.first=read(), Tmp1.second=Tmp2.second=read(),
		G[Tmp2.first].push_back(Tmp1), G[Tmp1.first].push_back(Tmp2);
	dfs(1, 0);
	sort(p+1, p+n+1);m=unique(p+1, p+n+1)-p-1;
	solve(1, 0);
//	printf("the ans is %d/%d\n", FZ, FM);
	printf("%lld", 1ll*FZ*ksm(FM, mo-2)%mo);
	return 0;
}

//a-b < x < a+b
//a>=b
//FM=(a+b-1-(a-b+1)+1)=(a+b-1-a+b-1+1)=2b-1=2(b-S)-1=2b-2S-1 
//FZ=(2b-1)(a+b)+[(a+b-1)*(a+b)-(a-b)*(a-b+1))]/2
//=(2b-1)(a+b)+[a^2-a^2+ab+ab+ab+ab-a-a+b^2-b^2-b+b]/2
//=(2b-1)(a+b)+([4ab-2a]/2=2ab-a=a(2b-1))
//=(2b-1)(a+b)+a(2b-1)=a(2b-1)+b(2b-1)+a(2b-1)=2ab-a+2b^2-b+2ab-a=4ab+2b^2-a-b=(2b-1)(2a+b)
//4ab+2b^2-2a-b=4(a-S)(b-S)+2(b-S)^2-2(a-S)-(b-S)=4ab-4aS-4bS+4S^2+2b^2-4bS+2S^2-2a+2S-b+S
//=4ab-(4S+2)a-(8S+1)b+6S^2+3S+2b^2
```


















---

## 作者：Y_B_X (赞：1)

~~不明白各位 dalao 为什么能推式子这么简洁。~~

[题目链接](https://www.luogu.com.cn/problem/P7815)

来补一个 $\text{dsu on tree+splay}$ 的大常数解法。

容易想到对每个点计算其为另外两点 $\text{LCA}$ 的贡献。

最朴素的方法就是对每个点暴力统计其**每个儿子的子树**与**其之前搜过的儿子的子树中每个点**之间的贡献。

但这显然可以通过 $\text{dsu on tree}$ 优化这个暴力过程。

剩下的几乎只用推式子了。

设当前处理 $x$ 节点，定义集合 $S$ 为目前之前搜过子树的点集。

初始时 $S$ 即是重儿子子树内全部点。

设 $x$ 的子树内节点 $i$ 到 $x$ 的距离为 $d_i$ ，当前希望与之前计算贡献的点与 $x$ 的距离为 $dis$

再定义两个互不相交的集合 $A=\left\{i|i\in S,d_i\leq dis\right\}$ $B=\left\{i|i\in S,d_i>dis\right\}$

先算 $A$ 集合与当前点的贡献：

设 $\left[l_i,r_i\right]$ 为 $d_i$ 与 $dis$ 为两边时另一条边的可取范围。

则 $l_i=dis-d_i+1,r_i=dis+d_i-1$

则树三角边权和的总贡献为：

$\sum\limits_{i\in A}^{}\sum\limits_{j=l_i}^{r_i}dis+d_i+j$

$=\sum\limits_{i\in A}^{}(r_i-l_i+1)(dis+d_i)+\frac{1}{2}(r_i-l_i+1)(r_i+l_i)$

$=\sum\limits_{i\in A}^{}(r_i-l_1+1)(2dis+d_i)$

$=\sum\limits_{i\in A}^{}(2d_i-1)(2dis+d_i)$

$=(4dis-1)\sum\limits_{i\in A}d_i-2dis\sum\limits_{i\in A}1+2\sum\limits_{i\in A}{d_i}^2$

树三角数量的总贡献为：

$\sum\limits_{i\in A}r_i-l_i+1=\sum\limits_{i\in A}2d_i-1=2\sum\limits_{i\in A}d_i-\sum\limits_{i\in A}1$

而对于 $B$ 集合来说

$l_i=d_i-dis+1,r_i=d_i+dis-1$

树三角边权和总贡献为：

$\sum\limits_{i\in B}\sum\limits_{j=l_i}^{r_i}dis+d_i+j$

$=\sum\limits_{i\in B}^{}(r_i-l_i+1)(dis+d_i)+\frac{1}{2}(r_i-l_i+1)(r_i+l_i)$

$=\sum\limits_{i\in B}^{}(r_i-l_1+1)(dis+2d_i)$

$=\sum\limits_{i\in B}^{}(2dis-1)(dis+2d_i)$

$=(2dis^2-dis)\sum\limits_{i\in B}1+(4dis-2)\sum\limits_{i\in B}d_i$

树三角数量的总贡献为：

$\sum\limits_{i\in B}r_i-l_i+1=\sum\limits_{i\in B}2dis-1=(2dis-1)\sum\limits_{i\in B}1$

所以只需能确定 $A,B$ 集合各自的大小、和、平方和就可以顺利计算了。

又由于边权 $\leq10^9$ 点到 $x$ 的距离 $\leq 10^{14}$ 爆不了 $\text{long long}$ 

所以写一个平衡树便可方便维护。

而为了确定 $A,B$ 集合只需知道 $x$ 子树内点到 $x$ 相对大小关系，

这与这些点到根的相对大小关系完全相同，这很方便预处理出来。

但还有一个问题：

计算时为了利用重儿子的信息，而重儿子中的距离并不是到 $x$ 的。

于是还要打个标记进行适当变换：

设之前维护的大小、和、平方和分别为 $c,s,s2$ ，真正需要的是 $\acute c,\acute s,\acute{s2}$ ，重儿子到 $x$ 的边权为 $v$

于是有：

$\begin{cases}\acute c=c\\\acute s=\sum d_i+v=s+vc\\\acute{s2}=\sum(d_i+w)^2=s2+2sv+v^2c=s2+2v\acute s-v^2c\end{cases}$

而这个转换的标记显然有可加性，于是这题就做完了。

还有一个细节：

为了保证不会让同一儿子的子树内的点又算一次贡献，需要在每个点查询完后统一插入平衡树中。

代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1e5+10,mod=1e9+7;ll inf=1e15;
int n,m,x,y,v,tot;ll ans,ans0,d[N],q[N],w[N<<1],sw[N];char ch;
int to[N<<1],nextn[N<<1],h[N],edg,son[N],id[N],sz[N];
inline void add(int x,int y,int v){to[++edg]=y;nextn[edg]=h[x];h[x]=edg;w[edg]=v;}
inline void read(int &x){
	x=0;ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')x=x*10+ch-48,ch=getchar();
}
void write(int x){if(x>=10)write(x/10);putchar(48+x%10);}
ll qpow(ll x,int k){ll res=1;while(k){if(k&1)res=res*x%mod;x=x*x%mod;k>>=1;}return res;}
struct node{
	int c;ll s,s2;
	node()=default;
	node(int _c,ll _s,ll _s2):c(_c),s(_s),s2(_s2){}
	void operator +=(const node &tmp){c+=tmp.c,s=(s+tmp.s)%mod,s2=(s2+tmp.s2)%mod;}
	void trans(ll v){s=(v*c+s)%mod;s2=(2*v*s%mod-v*v%mod*c%mod+s2)%mod;}
}tmp;
struct Splay{
	int son[N][2],anc[N],rt;ll tag[N];node w[N],s[N];
	void init(){q[n+1]=0;q[n+2]=inf;rt=n+1;son[n+1][1]=n+2;anc[n+2]=n+1;}
	bool p(int x){return son[anc[x]][1]==x;}
	void tag_(int x,ll v){
		tag[x]=(tag[x]+v)%mod;if(x<=n)w[x].trans(v);s[x].trans(v);
	}
	void fix(int x){if(!x)return;s[x]=w[x];s[x]+=s[son[x][0]];s[x]+=s[son[x][1]];}
	void rotate(int x){
		int y=anc[x],xx=anc[y];bool b=p(x),bb=p(y);
		anc[x]=xx;if(xx)son[xx][bb]=x;
		son[y][b]=son[x][!b];anc[son[x][!b]]=y;
		son[x][!b]=y;anc[y]=x;fix(y);fix(x);fix(xx);
	}
	void pushdown(int x){
		if(tag[x]){
			if(son[x][0])tag_(son[x][0],tag[x]);
			if(son[x][1])tag_(son[x][1],tag[x]);
			tag[x]=0;
		}
	}
	void pushall(int x){if(anc[x])pushdown(anc[x]);pushdown(x);}
	void splay(int x,int y=0){
		if(!y)rt=x;pushall(x);
		for(int i;i=anc[x],anc[x]^y;rotate(x))
			if(anc[i]^y)rotate(p(x)==p(i)?i:x);
	}
	void insert(int x,node v){
		s[x]=w[x]=v;int y=rt,f=0;
		for(;;){
			if(!y){anc[x]=f;son[f][q[f]<=q[x]]=x;return splay(x);}
			pushdown(y);f=y;y=son[y][q[y]<=q[x]];
		}
	}
	int pre(int x){
		splay(x);
		x=son[x][0];
		while(son[x][1])x=son[x][1];
		return splay(x),x;
	}
	void del(int x){
		int y=pre(x);splay(x,y);
		anc[son[y][1]=son[x][1]]=y,fix(y);
		son[x][0]=son[x][1]=anc[x]=0;
	}
	void inquiry(int x,ll v,node vv){
		insert(x,vv);v%=mod;
		tmp=s[son[x][0]];
		ans=(ans+(4*v-1)%mod*tmp.s%mod-2*v*tmp.c%mod+2*tmp.s2%mod)%mod;
		ans0=(ans0+2*tmp.s-tmp.c)%mod;
		tmp=s[son[x][1]];
		ans=(ans+(4*v-2)%mod*tmp.s%mod+(2*v*v%mod-v)*tmp.c%mod)%mod;
		ans0=(ans0+(2*v-1)*tmp.c%mod)%mod;del(x);
	}
}S;
void init(int x,int anc){
	int i,y;sz[x]=1;
	for(i=h[x];y=to[i],i;i=nextn[i])if(y^anc){
		q[y]=q[x]+w[i];init(y,x);sz[x]+=sz[y];
		if(sz[y]>sz[son[x]])son[x]=y,sw[x]=w[i];
	}
}
void dfs(int x,int anc){
	int i,y;id[++tot]=x;
	for(i=h[x];y=to[i],i;i=nextn[i])if(y^anc)d[y]=(d[x]+w[i])%mod,dfs(y,x);
}
void clear(int x,int anc){
	int i,y;S.del(x);
	for(i=h[x];i;i=nextn[i])if(to[i]^anc)clear(to[i],x);
}
void solve(int x,int anc){
	int i,j,y;
	for(i=h[x];y=to[i],i;i=nextn[i])if(y^anc&&y^son[x])solve(y,x),clear(y,x);
	if(son[x])solve(son[x],x),S.tag_(S.rt,sw[x]);
	for(i=h[x];y=to[i],i;i=nextn[i])if(y^anc&&y^son[x]){
		tot=0;d[y]=w[i];dfs(y,x);
		for(j=1;y=id[j],j<=tot;++j)
			S.inquiry(y,d[y],node(1,d[y],d[y]*d[y]%mod));
		for(j=1;y=id[j],j<=tot;++j)
			S.insert(y,node(1,d[y],d[y]*d[y]%mod));
	}
	S.insert(x,node(1,0,0));
}
main(){
	read(n);register int i;S.init();
	for(i=1;i^n;++i)read(x),read(y),read(v),add(x,y,v),add(y,x,v);
	init(1,0);solve(1,0);ans=(ans+mod)%mod;ans0=(ans0+mod)%mod;
	ans0=qpow(ans0,mod-2);write(ans*ans0%mod);
}
```

---

## 作者：Bosun (赞：0)

首先设答案为 $\frac{p}{q}$ 推柿子(柿子中的$u$、$v$、$w$含义与题面相同):

先处理比较简单的分母部分:

$q=\sum_{w=1}^{n}\sum_{u\in son_u}\sum_{v\in son_v \cap dep_v\le dep_u}(2 \times dep_v - 2 \times dep_w - 1)$

如果这样直接做是$ N^3 $的，完全过不了。

拆开，考虑每个$u$对于$w$的贡献其实就是$w$子树内,$u$子树外**dep比u小的个数**$ \times (2 \times dep_w - 1) + $**dep比u小的dep和**  

考虑这两个东西怎么算

对于$w$的每个轻儿子$u$,每次用树状数组算出前面子树与$u$对答案的贡献，再把$u$的子树加入树状数组中。注意，要把$dep>u$的v和$dep\le u$的$v$都算一遍

重儿子的话已经保留了，放在第一个，前面都没有数，所以不用统计，就顺利做到$log$级的复杂度了

对于分子，柿子更加复杂一些:

$p =\sum_{w=1}^{n}\sum_{u\in son_u}\sum_{v\in son_v \cap dep_v\le dep_u}(2 \times dep_v - 2 \times dep_w - 1)\times (2 \times dep_u + dep_v - 3\times dep_w)$

$ =\sum_{w=1}^{n}\sum_{u\in son_u}\sum_{v\in son_v \cap dep_v\le dep_u}(2\times dep_v^2 + 6\times dep_w^2 + 4\times dep_u \times dep_v +3\times dep_w -4\times dep_w\times dep_u -8\times dep_w\times dep_v - 2\times dep_u - dep_v)$

所以树状数组里面还要维护一个前缀二次方和

时间复杂度$ O(N log_2 N)$

注意一下$dep$有点大，所以要开$ll$，离散化，注意取模

Code by zbs2006

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1000005;
int n;
typedef long long ll;
const ll mod=1e9+7;
int cnt,h[N],to[N<<1],nxt[N<<1],sz[N],son[N];
ll val[N<<1],dep[N],D[N];
int d[N];
void add(int x,int y,ll z){
	cnt++;
	nxt[cnt]=h[x];
	h[x]=cnt;
	to[cnt]=y,val[cnt]=z;
}
int tim,In[N],Out[N],dfn[N];
void M(ll &x){
	x=(x%mod+mod)%mod;
}
void dfs(int u,int fa){
	int i;
	sz[u]=1;int mx=0;
	In[u]=++tim,dfn[tim]=u;
	for(i=h[u];i;i=nxt[i]){
		int v=to[i];ll w=val[i];
		if(v!=fa){
			dep[v]=dep[u]+w;
			dfs(v,u);
			sz[u]+=sz[v];
			if(sz[v]>mx)
				mx=sz[v],son[u]=v;
		}
	}
	Out[u]=tim;
}
#define lowbit(x) (x&(-x))
ll c[N],e[N],g[N];
void add(int x,ll y,int fl){
	while(x<=n){
		c[x]+=fl;M(c[x]);
		e[x]+=fl*y;M(e[x]);
		g[x]+=fl*y*y;M(g[x]);
		x+=lowbit(x);
	} 
}
struct Ans{
	ll fi,se,th;
};
Ans sum(int x){
	ll C=0,E=0,G=0;
	while(x){
		C=(C+c[x])%mod;
		E=(E+e[x])%mod;
		G=(G+g[x])%mod;
		x-=lowbit(x);
	}
	return (Ans){C,E,G};
}
ll qp(ll x,ll y){
	ll res=1;
	while(y){
		if(y&1)res=res*x%mod;
		x=x*x%mod;
		y>>=1;
	}
	return res;
}
ll MU,ZI; 
void deal(int w,int fa,int keep){
	int i;
	for(i=h[w];i;i=nxt[i]){
		int To=to[i];
		if(To!=fa&&To!=son[w])
			deal(To,w,0);
	}
	if(son[w])
		deal(son[w],w,1);
	for(i=h[w];i;i=nxt[i]){
		int To=to[i];
		if(To!=fa&&To!=son[w]){
			for(int j=In[To];j<=Out[To];j++){
				int v=dfn[j];Ans r=sum(d[v]);
				ll da=sum(n).fi-r.fi;
				ll dg=sum(n).se-r.se;
				//calc contributions of V
				//as U 
				MU+=(2*r.se+mod-r.fi*(2*D[w]+1)%mod)%mod,M(MU);
				//as V 
				MU+=da*(-2*D[w]%mod+mod+2*D[v]%mod-1)%mod,M(MU);
				//as U	
				ZI+=r.fi*(6*D[w]%mod*D[w]%mod+3*D[w]%mod)%mod,M(ZI);
				ZI+=r.fi*D[v]%mod*(mod-2-4*D[w])%mod,M(ZI);
				ZI+=r.th*2%mod,M(ZI);
				ZI+=r.se*(4*D[v]-8*D[w]-1)%mod,M(ZI);
				//as V
				ZI+=da*(6*D[w]*D[w]%mod+3*D[w])%mod,M(ZI);
				ZI+=dg*(mod-2-4*D[w])%mod,M(ZI);
				ZI+=da*2*D[v]%mod*D[v]%mod,M(ZI);
				ZI+=da*(mod-1-8*D[w]%mod)%mod*D[v],M(ZI); 
				ZI+=4*dg*D[v]%mod,M(ZI);
			}
			for(int j=In[To];j<=Out[To];j++){
				int v=dfn[j];
				add(d[v],D[v],1);
			}
		}
	}
	add(d[w],D[w],1);
	if(!keep){
		for(int j=In[w];j<=Out[w];j++){
			int v=dfn[j];
			add(d[v],D[v],-1);
		}
	}
}
int main(){
	int i;
	cin>>n;
	for(i=1;i<n;i++){
		int x,y;ll z;
		scanf("%d%d%lld",&x,&y,&z);
		add(x,y,z),add(y,x,z);
	}
	dfs(1,0);
	for(i=1;i<=n;i++)D[i]=dep[i];
	sort(dep+1,dep+n+1);
	int tot=unique(dep+1,dep+n+1)-dep-1;
	for(i=1;i<=n;i++)d[i]=lower_bound(dep+1,dep+tot+1,D[i])-dep,D[i]%=mod;
	deal(1,0,1);
	cout<<ZI*qp(MU,mod-2)%mod<<endl;
	return 0;
}
```


---


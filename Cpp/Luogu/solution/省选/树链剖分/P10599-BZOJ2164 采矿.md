# BZOJ2164 采矿

## 题目背景

题目来自原 BZOJ，我们承认题面及原数据的版权均属于原 BZOJ 或将题目授权给 BZOJ 使用的出题人。如果您是版权所有者且认为我们侵犯了您的权益，可联系我们。

## 题目描述

浩浩荡荡的 cg 大军发现了一座矿产资源极其丰富的城市，他们打算在这座城市实施新的采矿战略。

这个城市可以看成一棵有 $n$ 个节点的有根树，我们把每个节点用 $1$ 到 $n$ 的整数编号。为了方便起见，对于任何一个非根节点 $v$，它任何一个祖先的编号都严格小于 $v$。树上的每个节点表示一个矿点，每条边表示一条街道。

作为 cg 大军的一个小队长，你拥有 $m$ 个部下。你有一张二维的动态信息表，用 $T_{i,j}$ 表示第 $i$ 行第 $j$ 列的数据。当你被允许开采某个区域时，你可以将你的部下分配至各个矿点。在第 $i$ 个矿点安排 $j$ 个人可以获得 $T_{i,j}$ 单位的矿产。

允许开采的区域是这样描述的：给你一对矿点 $(u,v)$，保证 $v$ 是 $u$ 的祖先（这里定义祖先包括 $u$ 本身）；$u$ 为你控制的区域，可以在以 $u$ 为根的子树上任意分配部下；$u$ 到 $v$ 的简单路径（不包括 $u$ 但包括 $v$，若 $u=v$ 则包括 $u$）为探险路径，在该路径上你可以选择至多一个矿点安排部下。你这次开采的收益为安排有部下的矿点的收益之和。

## 说明/提示

**【样例解释】**

最初的信息表如下：

| 0 | 1 | 1 | 2 | 2 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| 0 | 5 | 7 | 7 | 9 |
| 1 | 2 | 3 | 4 | 5 |
| 0 | 1 | 2 | 4 | 5 |
| 2 | 4 | 7 | 8 | 8 |
| 0 | 2 | 3 | 8 | 9 |
| 1 | 3 | 5 | 6 | 8 |
| 3 | 3 | 3 | 7 | 8 |
| 0 | 1 | 2 | 3 | 9 |
| 0 | 0 | 1 | 4 | 4 |

变化后的第 $1$ 行，为：
```
1 1 1 4 7
```
第一次开采可以在矿点 $6,8,9,10$ 任意安排，可以在矿点 $3$ 或 $4$ 中选取一个安排开采。一种最优安排是在矿点 $6$ 安排 $4$人，在矿点 $8$ 安排 $1$ 人。第二次开采可以在矿点 $9$ 安排，可以在矿点 $6,4,3,1$ 中选择一个安排。一种最优安排是在矿点 $9$ 安排 $1$ 人，在矿点 $6$ 安排 $4$ 人。

**【数据范围】**

有 $50\%$ 的数据，对于满足 $2\leq i\leq n$ 的整数 $i$，$F_i=i-1$。这些数据中有 $40\%$ 的数据（即所有数据的 $20\%$）满足 $n\leq 500，m\leq 20，C\leq 500$。

除上述数据，另有 $40\%$ 的数据满足 $n\leq 500$，$m\leq 20$，$C\leq 500$。

对于 $100\%$ 的数据 $1\leq n\leq 20000$，$1\leq m\leq 50$，$1\leq C\leq 2000$。对于满足 $2\leq i\leq n$ 的整数 $i$，$1\leq F_i<i$。$1\leq A,B\leq 2^{31}-1$，$1\leq Q\leq 10000$。

## 样例 #1

### 输入

```
10 5 1 2 10
1 1 3 3 4 4 6 6 9
4
1 6 3
1 9 1
0 1
1 1 1```

### 输出

```
11
9
12```

# 题解

## 作者：_AyachiNene (赞：4)

~~题目理解难度大于做法难度。~~
# 思路：
看到一个是子树查和链查，还有单点改，想到用树剖。发现 $m$ 很小，如果只有子树查，就是一个树上背包，每次合并的时间复杂度为 $m^2$。容易想到把这个上线段树，每个区间记一个数组 $f$，$f_i$ 表示区间内，用的人数为 $i$ 的最大收益，合并两个区间直接 $m^2$ 暴力合并就行。现在再加上链上的答案，由于只能选一个，所以线段树上再开一个 $g$，$g_i$ 表示区间内，在一个点上放 $i$ 个的最大值。答案就是把子树的 $f$ 和链上的 $g$ 合并一下就行了。
# Code：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
namespace IO
{
	char buff[1<<21],*p1=buff,*p2=buff;
	char getch(){return p1==p2&&(p2=((p1=buff)+fread(buff,1,1<<21,stdin)),p1==p2)?EOF:*p1++;}
	template<typename T>void read(T &x){char ch=getch();int fl=1;x=0;while(ch>'9'||ch<'0'){if(ch=='-')fl=-1;ch=getch();}while(ch<='9'&&ch>='0'){x=x*10+ch-48;ch=getch();}x*=fl;}
	template<typename T>void read_s(T &x){char ch=getch();while(ch<'a'||ch>'z')ch=getch();while(ch>='a'&&ch<='z'){x+=ch;ch=getch();}}
	template<typename T,typename ...Args>void read(T &x,Args& ...args){read(x);read(args...);}
	char obuf[1<<21],*p3=obuf;
	void putch(char ch) {if(p3-obuf<(1<<21))*p3++=ch;else fwrite(obuf,p3-obuf,1,stdout),p3=obuf,*p3++=ch;}
	char ch[100];
	template<typename T>void write(T x) {if(!x)return putch('0');if(x<0)putch('-'),x*=-1;int top=0;while(x)ch[++top]=x%10+48,x/=10;while(top)putch(ch[top]),top--;}
	template<typename T,typename ...Args>void write(T x,Args ...args) {write(x);write(args...);}
	void put(string s){for(int i=0;i<s.size();i++)putch(s[i]);}
	void flush(){fwrite(obuf,p3-obuf,1,stdout);}
}
using namespace IO;
int A,B,Q;
const int X=1<<16,Y=(1ll<<31)-1;
inline int getint()
{
	A=((A^B)+(B/X)+(B*X))&Y;
	B=((A^B)+(A/X)+(A*X))&Y;
	return (A^B)%Q;
}
struct node
{
	int nxt,to;
}e[114514];
int head[114514],cnt_edge;
void add_edge(int u,int v)
{
	e[++cnt_edge].to=v;
	e[cnt_edge].nxt=head[u];
	head[u]=cnt_edge;
}
int n,m,q;
namespace Nene
{
	struct segt
	{
		int f[55],mx[55];
		inline segt(){memset(f,0,sizeof f);memset(mx,0,sizeof mx);}
		inline segt operator+(const segt &a)const
		{
			segt res;
			for(int i=0;i<=m;i++)
				for(int j=0;i+j<=m;j++) res.f[i+j]=max(res.f[i+j],f[i]+a.f[j]);
			for(int i=0;i<=m;i++) res.mx[i]=max(mx[i],a.mx[i]);
			return res;
		}
	}t[20005<<2];
	int w[20005][55];
	#define ls (root<<1)
	#define rs (root<<1|1)
	#define mid (l+r>>1)
	void insert(int x,int root=1,int l=1,int r=n)
	{
		if(l==r)
		{
			for(int i=1;i<=m;i++) t[root].f[i]=t[root].mx[i]=w[l][i];
			return;
		}
		if(x<=mid) insert(x,ls,l,mid);
		else insert(x,rs,mid+1,r);
		t[root]=t[ls]+t[rs];
	}
	segt query(int x,int y,int root=1,int l=1,int r=n)
	{
		if(l>=x&&r<=y) return t[root];
		if(y<=mid) return query(x,y,ls,l,mid);
		if(x>mid) return query(x,y,rs,mid+1,r);
		return query(x,y,ls,l,mid)+query(x,y,rs,mid+1,r);
	}
}using namespace Nene;
int f[114514],siz[114514],son[114514],dep[114514],top[114514],dfn[114514],cnt;
void dfs1(int u)
{
	siz[u]=1;dep[u]=dep[f[u]]+1;
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].to;
		if(v==f[u]) continue;
		dfs1(v);
		siz[u]+=siz[v];
		if(siz[son[u]]<siz[v]) son[u]=v;
	}
}
void dfs2(int u,int t)
{
	top[u]=t;dfn[u]=++cnt;
	if(son[u]) dfs2(son[u],t);
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].to;
		if(v==f[u]||v==son[u]) continue;
		dfs2(v,v);
	}
}
inline segt query_path(int x,int y)
{
	segt res;
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		res=res+query(dfn[top[x]],dfn[x]);
		x=f[top[x]];
	}
	if(dfn[x]>dfn[y]) swap(x,y);
	res=res+query(dfn[x],dfn[y]);
	return res;
}
signed main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	read(n,m,A,B,Q);
	for(int i=2;i<=n;i++) read(f[i]),add_edge(f[i],i);
	dfs1(1);dfs2(1,1);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++) w[dfn[i]][j]=getint();
		sort(w[dfn[i]]+1,w[dfn[i]]+m+1);
	}
	for(int i=1;i<=n;i++) insert(dfn[i]);
	read(q);
	while(q--)
	{
		int op,u,v;read(op,u);
		if(op==0)
		{
			for(int i=1;i<=m;i++) w[dfn[u]][i]=getint();
			sort(w[dfn[u]]+1,w[dfn[u]]+m+1);
			insert(dfn[u]);
		}
		else
		{
			read(v);
			segt ress=query(dfn[u],dfn[u]+siz[u]-1),resf;
			if(u!=v) resf=query_path(f[u],v);
			segt ans;
			for(int i=0;i<=m;i++)
				for(int j=0;j+i<=m;j++) ans.f[i+j]=max(ans.f[i+j],ress.f[i]+resf.mx[j]);
			write(ans.f[m]),putch('\n');
		}
	}
	flush();
	return 0;
}
```

---

## 作者：linruichen (赞：2)

## **题目大意**

给定矿点个数 $n$ 和部下人数 $m$ 与为生成数据 $A$，$B$，$Q$，点的父亲节点同 $n$ 个矿点有几个部下带来的收益。进行 $C$ 次询问，事件 0 为更改第 $p$ 个矿点的收益，事件 1 为求 $u$，$v$ 中 $u$ 子树（包括 $u$）与 $u$ 到 $v$ 的链（$u$ 应排除出选择，否则影响结果）怎样分配收益最大，其中 $u$ 到 $v$ 的链只能安排一次部下（个数不限）。

## **解题思路**

看见选择出最大值可以想到 DP，处理链想到树链剖分，及将树进行树链剖分，再用线段树建树，线段树的每个节点存储一个数组 $\operatorname{f}$，$\operatorname{g}$（都为一维），在线段树中分别表示当前节点的所有叶子节点分配 $i$ 个部下带来的最高收益（用 $O(m^2)$ 的时间进行合并），当前节点的一个叶子节点分配 $i$ 个部下带来的最高收益（用 $O(m)$ 的时间进行合并）。子树内的答案只需区间查询（查询 $\operatorname{f}$），链上的只需树链剖分即可（查询 $\operatorname{g}$），时间复杂度分别为 $O(m^2 \log n)$，$O(m \log^2 n)$，修改则直接更改后合并，时间复杂度为 $O(m^2 \log n)$，总时间复杂度为 $O(C(m^2 \log n + m \log^2 n))$，可行。

## **参考代码**

```cpp
#include<bits/stdc++.h>
using namespace std;
long long tou[20010],zui[20010],wei[20010],bian[20010],shen[20010],da[20010],
    son[20010],t,b[20010],fa[20010],n,m,B,A,Q,X,Y,p,c[51],d[51];
struct w{
	long long x,y;
}a[100010];
struct o{
	long long a[51],g[51];
}f[80010],uv[20010];
inline long long Getint()
{
    A=((A^B)+B/X+B*X)&Y;
    B=((A^B)+A/X+A*X)&Y;
    return (A^B)%Q;
}
void ww(long long die,long long ye)
{
	fa[die]=ye;
	da[die]=1;
	for(long long i=b[die];i;i=a[i].y)
	if(a[i].x!=ye)
	{
		shen[a[i].x]=shen[die]+1;
		ww(a[i].x,die);
		da[die]+=da[a[i].x];
	}
	for(long long i=b[die];i;i=a[i].y)
	if(a[i].x!=ye)
		if(da[son[die]]<da[a[i].x])
			son[die]=a[i].x;
}
void www(long long die,long long ye)
{
	if(son[die])
	{
		
		tou[son[die]]=tou[die];
		wei[son[die]]=++t;
		bian[wei[son[die]]]=son[die];
		zui[son[die]]=wei[son[die]];
		www(son[die],die);
		zui[die]=max(zui[die],zui[son[die]]);
	}
	for(long long i=b[die];i;i=a[i].y)
		if(a[i].x!=ye&&a[i].x!=son[die])
		{
			tou[a[i].x]=a[i].x;
			wei[a[i].x]=++t;
			zui[a[i].x]=wei[a[i].x];
			bian[wei[a[i].x]]=a[i].x;
			www(a[i].x,die);
			zui[die]=max(zui[die],zui[a[i].x]);
		}
}
void jian(long long k,long long l,long long r)
{
	if(l==r)
	{
		for(long long i=0;i<=m;i++)
			f[k].a[i]=uv[bian[l]].a[i],
			f[k].g[i]=uv[bian[l]].a[i];
		return;
	}
	long long mid=(l+r)/2;
	jian(k*2,l,mid);
	jian(k*2+1,mid+1,r);
	for(long long i=0;i<=m;i++)
		for(long long j=0;j<=i;j++)
			f[k].a[i]=max(f[k].a[i],f[k*2].a[j]+f[k*2+1].a[i-j]);
	for(long long i=0;i<=m;i++)
		f[k].g[i]=max(f[k*2].g[i],f[k*2+1].g[i]);
}
void gai(long long k,long long l,long long r,long long x)
{
	if(l==r)
	{
		for(long long i=0;i<=m;i++)
			f[k].a[i]=uv[bian[l]].a[i],
			f[k].g[i]=uv[bian[l]].a[i];
		return;
	}
	long long mid=(l+r)/2;
	if(x<=mid)gai(k*2,l,mid,x);
	if(x>mid)gai(k*2+1,mid+1,r,x);
	for(int i=0;i<=m;i++)
		f[k].g[i]=f[k].a[i]=0;
	for(long long i=0;i<=m;i++)
		for(long long j=0;j<=i;j++)
			f[k].a[i]=max(f[k].a[i],f[k*2].a[j]+f[k*2+1].a[i-j]);
	for(long long i=0;i<=m;i++)
		f[k].g[i]=max(f[k*2].g[i],f[k*2+1].g[i]);
}
void qui_f(long long k,long long l,long long r,long long x,long long y)
{
	if(x<=l&&r<=y)
	{
		for(long long i=m;i>=0;i--)
		for(long long j=i;j>=0;j--)
			c[i]=max(c[i],c[j]+f[k].a[i-j]);
		return;
	}
	long long mid=(l+r)/2;
	if(x<=mid)qui_f(k*2,l,mid,x,y);
	if(y>mid)qui_f(k*2+1,mid+1,r,x,y);
}
void qui_g(long long k,long long l,long long r,long long x,long long y)
{
	if(x<=l&&r<=y)
	{
		for(long long i=0;i<=m;i++)
			d[i]=max(d[i],f[k].g[i]);
		return;
	}
	long long mid=(l+r)/2;
	if(x<=mid)qui_g(k*2,l,mid,x,y);
	if(y>mid)qui_g(k*2+1,mid+1,r,x,y);
}
void llca(long long x,long long y)
{
	long long fx=tou[x],fy=tou[y];
	while(fx!=fy)
	{
		if(shen[fx]<shen[fy])
			swap(fx,fy),swap(x,y);
		qui_g(1,1,n,wei[fx],wei[x]);
		x=fa[fx];
		fx=tou[x];
	}
	if(shen[x]>shen[y])
		swap(x,y);
	qui_g(1,1,n,wei[x],wei[y]);
}
main()
{
	scanf("%lld%lld%lld%lld%lld",&n,&m,&A,&B,&Q);
	X=pow(2,16);
	Y=pow(2,31)-1;
	for(long long i=2;i<=n;i++)
	{
		long long x;
		scanf("%lld",&x);
		a[++t].x=x;
		a[t].y=b[i];
		b[i]=t;
		a[++t].x=i;
		a[t].y=b[x];
		b[x]=t;
	}
	ww(1,1);
	t=0;
	tou[1]=1;
	wei[1]=++t;
	bian[wei[1]]=1;
	zui[1]=1;
	www(1,1);
	for(long long i=1;i<=n;i++)
	{
		uv[i].a[0]=0;
		for(long long j=1;j<=m;j++)
			uv[i].a[j]=Getint();
		sort(uv[i].a+1,uv[i].a+m+1);
	}
	jian(1,1,n);
	scanf("%lld",&p);
	while(p--)
	{
		long long z;
		scanf("%lld",&z);
		if(z==0)
		{
			long long x;
			scanf("%lld",&x);
			uv[x].a[0]=0;
			for(long long j=1;j<=m;j++)
				uv[x].a[j]=Getint();
			sort(uv[x].a+1,uv[x].a+m+1);
			gai(1,1,n,wei[x]);
		}
		else
		{
			for(long long i=0;i<=m;i++)
				c[i]=d[i]=0;
			long long u,v,uu;
			scanf("%lld%lld",&u,&v);
			uu=fa[u];
			if(shen[uu]>=shen[v])
				llca(uu,v);
			qui_f(1,1,n,wei[u],zui[u]);
			long long s=0;
			for(long long i=0;i<=m;i++)
				s=max(s,c[i]+d[m-i]);
			printf("%lld\n",s);
		}
	}
} 
```

---

## 作者：Z_kazuha (赞：2)

## 题面

[题目传送门](https://www.luogu.com.cn/problem/P10599)

## 前言

好好读题捏。

## 正文

先看查询，这里可以分为两个部分考虑。

1. $u$ 的子树部分。
2. 从 $v$ 到 $fa[u]$ 的部分。

我们一个一个看。

子树部分直接树形背包：设 $f_i$ 为选 $i$ 个人的收益之和，发现 $m$ 很小，$m^2\log n$ 能过（在代码中，我直接做了一个 `dp` 矩阵）。

链部分，让求最大值，树剖就完了。

那么修改就好办了，用线段树修改就行力。

## 代码

```
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=2e4+4;
int n,m,A,B,Q,fa[N],cnt,head[N],X=1<<16,Y=(1ll<<31)-1;
struct node{
	int f[55];
	void init(){memset(f,0,sizeof(f));}
}treemax[N<<2],treesum[N<<2],E,a[N],oo;
struct Node{int to,nxt;}e[N];
void add(int u,int v){
	e[++cnt].nxt=head[u];
	head[u]=cnt;
	e[cnt].to=v;	
}
int siz[N],deep[N],top[N],id[N],son[N];
void dfs1(int x){
	//cout<<x<<endl;
	siz[x]=1;
	deep[x]=deep[fa[x]]+1;
	for(int i=head[x];i;i=e[i].nxt){
		int y=e[i].to;
	//	cout<<x<<" "<<y<<endl;
		if(y==fa[x])continue;
		dfs1(y);
		siz[x]+=siz[y];
		if(siz[y]>siz[son[x]])son[x]=y;
	}
}
int ans,w[N];
void dfs2(int x,int topx){
	id[x]=++ans;
	top[x]=topx;
	w[ans]=x;
	if(!son[x])return;
	dfs2(son[x],topx);
	for(int i=head[x];i;i=e[i].nxt){
		int y=e[i].to;
		if(fa[x]==y||y==son[x])continue;
		dfs2(y,y);
	}
}
inline int op(){
    A=((A^B)+B/X+B*X)&Y;
    B=((A^B)+A/X+A*X)&Y;
    return (A^B)%Q;
}
void get(){
	for(int i=1;i<=m;i++){
		E.f[i]=op();
	}
	sort(E.f+1,E.f+m+1);
}
int ls(int p){return p<<1;}
int rs(int p){return p<<1|1;}
inline node operator +(node p,node q){
    for(int i=0;i<=m;i++)p.f[i]=max(p.f[i],q.f[i]);
    return p;
}
inline node operator *(node p,node q){
    node ret;ret.init();
    for(int i=0;i<=m;i++)
        for(int j=0;i+j<=m;j++)ret.f[i+j]=max(ret.f[i+j],p.f[i]+q.f[j]);
    return ret;
}
void pushup(int p){
	treemax[p]=treemax[ls(p)]+treemax[rs(p)];
	treesum[p]=treesum[ls(p)]*treesum[rs(p)];
}
void build(int p,int pl,int pr){
	if(pl==pr){
		treemax[p]=treesum[p]=a[w[pl]];
		return;
	}
	int mid=(pl+pr)>>1;
	build(ls(p),pl,mid);
	build(rs(p),mid+1,pr);
	pushup(p);
}
void update(int p,int pl,int pr,int L){
	if(pl==pr){
		treesum[p]=treemax[p]=E;
		return;
	}
	int mid=(pl+pr)>>1;
	if(L<=mid)update(ls(p),pl,mid,L);
	else update(rs(p),mid+1,pr,L);
	pushup(p);
}
node querysum(int p,int pl,int pr,int L,int R){
	if(L<=pl&&pr<=R)return treesum[p];
	int mid=(pl+pr)>>1;
	if(R<=mid)return querysum(ls(p),pl,mid,L,R);
    if(L>mid)return querysum(rs(p),mid+1,pr,L,R);
    return querysum(ls(p),pl,mid,L,R)*querysum(rs(p),mid+1,pr,L,R);
}
node querymax(int p,int pl,int pr,int L,int R){
	if(L<=pl&&pr<=R)return treemax[p];
	int mid=(pl+pr)>>1;
	if(R<=mid)return querymax(ls(p),pl,mid,L,R);
    if(L>mid)return querymax(rs(p),mid+1,pr,L,R);
    return querymax(ls(p),pl,mid,L,R)+querymax(rs(p),mid+1,pr,L,R);
}
node query(int x,int y){
	node res;res.init();
	if(x==y)return res;
	x=fa[x];
	while(top[x]!=top[y]){
		if(deep[top[x]]<deep[top[y]])swap(x,y);
		res=res+querymax(1,1,n,id[top[x]],id[x]);
		x=fa[top[x]];
	}
	if(deep[x]>deep[y])swap(x,y);
	res=res+querymax(1,1,n,id[x],id[y]);
	return res;
}
signed main(){
	cin>>n>>m>>A>>B>>Q;
	for(int i=2;i<=n;i++){
		cin>>fa[i];
		add(fa[i],i);
	//	cout<<fa[i]<<" "<<i<<endl;
	}
	//cout<<1;
	dfs1(1);
//	cout<<1;
	dfs2(1,1);
//	cout<<2;
	for(int i=1;i<=n;i++){
		get();
		a[i]=E;
	}
//	cout<<3;
	build(1,1,n);
//	cout<<4;
	int C;
	cin>>C;
	while(C--){
		int op,x,y;
		cin>>op>>x;
		if(op==0)get(),update(1,1,n,id[x]);
		else{
			cin>>y;
			oo=querysum(1,1,n,id[x],id[x]+siz[x]-1)*query(x,y);
			cout<<oo.f[m]<<endl;
		}
	}
	return 0;
}
```

## 后记

不要把链前写错了。

本蒟蒻链前写成了。

```
void add(int u,int v){
    e[++cnt].to=v;	
	head[u]=cnt;
    e[cnt].nxt=head[u];
}
```

调了一下午。

---

## 作者：zhangxy__hp (赞：1)

问题显然可以分为两部分：$u$ 的子树内和 $fa_u$ 到 $v$ 的链上。前者需要树上背包，后者需要取 $\max$。

考虑用线段树维护这两个值。子树内的答案只需要一次区间查询，再加上树上背包的 $O(m^2)$，总共为 $O(m^2\log n)$。链上的答案需要进行树链剖分。取 $\max$ 线性复杂度即可完成，因此为 $O(m\log^2n)$。总时间复杂度为 $O(C(m^2\log n+m\log^2n))$。修改就直接在线段树上单点更新即可。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define il inline
#define read(x){\
	char ch;\
	int fu=1;\
	while(!isdigit(ch=getchar()))\
		fu-=(ch=='-')<<1;\
	x=ch&15;\
	while(isdigit(ch=getchar()))\
		x=(x<<1)+(x<<3)+(ch&15);\
	x*=fu;\
}
#define pb push_back
#define lid id<<1
#define rid id<<1|1
using namespace std;
namespace asbt{
namespace cplx{bool begin;}
namespace Data{
	int A,B,Q,X=1<<16,Y=(1ll<<31)-1;
	il void init(){
		read(A)read(B)read(Q);
	}
	il int getint(){
		A=((A^B)+(B/X)+(B*X))&Y;
		B=((A^B)+(A/X)+(A*X))&Y;
		return (A^B)%Q;
	}
}
const int maxn=2e4+5;
int n,m,q,fa[maxn],a[maxn][55];
int dep[maxn],sz[maxn],hes[maxn];
int top[maxn],dfn[maxn],idx[maxn],cnt;
vector<int> e[maxn];
il void dfs1(int u){
	dep[u]=dep[fa[u]]+1;
	sz[u]=1;
	int mxs=0;
	for(int v:e[u]){
		dfs1(v);
		sz[u]+=sz[v];
		if(mxs<sz[v]){
			mxs=sz[v],hes[u]=v;
		}
	}
}
il void dfs2(int u){
	dfn[u]=++cnt;
	idx[cnt]=u;
	if(!top[u]){
		top[u]=u;
	}
	if(hes[u]){
		top[hes[u]]=top[u];
		dfs2(hes[u]);
	}
	for(int v:e[u]){
		if(v!=hes[u]){
			dfs2(v);
		}
	}
}
struct node1{
	int f[55];
	node1(){
		memset(f,0,sizeof f);
	}
	il int&operator[](int x){
		return f[x];
	}
	il node1 operator+(node1 x)const{
		node1 res;
		for(int i=0;i<=m;i++){
			for(int j=0;j<=m-i;j++){
				res[i+j]=max(res[i+j],f[i]+x[j]);
			}
		}
		return res;
	}
}tr1[maxn<<2];
struct node2{
	int f[55];
	node2(){
		memset(f,0,sizeof f);
	}
	il int&operator[](int x){
		return f[x];
	}
	il node2 operator+(node2 x)const{
		node2 res;
		for(int i=0;i<=m;i++){
			res[i]=max(f[i],x[i]);
		}
		return res;
	}
}tr2[maxn<<2];
il void pushup(int id){
	tr1[id]=tr1[lid]+tr1[rid];
	tr2[id]=tr2[lid]+tr2[rid];
}
il void pushtag(int id,int p){
	for(int i=0;i<=m;i++){
		tr1[id][i]=tr2[id][i]=a[idx[p]][i];
	}
}
il void build(int id,int l,int r){
	if(l==r){
		pushtag(id,l);
		return ;
	}
	int mid=(l+r)>>1;
	build(lid,l,mid);
	build(rid,mid+1,r);
	pushup(id);
}
il void upd(int id,int l,int r,int p){
	if(l==r){
		pushtag(id,l);
		return ;
	}
	int mid=(l+r)>>1;
	if(p<=mid){
		upd(lid,l,mid,p);
	}
	else{
		upd(rid,mid+1,r,p);
	}
	pushup(id);
}
il node1 query1(int id,int L,int R,int l,int r){
	if(L>=l&&R<=r){
		return tr1[id];
	}
	int mid=(L+R)>>1;
	if(r<=mid){
		return query1(lid,L,mid,l,r);
	}
	if(l>mid){
		return query1(rid,mid+1,R,l,r);
	}
	return query1(lid,L,mid,l,r)+query1(rid,mid+1,R,l,r);
}
il node2 query2(int id,int L,int R,int l,int r){
	if(L>=l&&R<=r){
		return tr2[id];
	}
	int mid=(L+R)>>1;
	if(r<=mid){
		return query2(lid,L,mid,l,r);
	}
	if(l>mid){
		return query2(rid,mid+1,R,l,r);
	}
	return query2(lid,L,mid,l,r)+query2(rid,mid+1,R,l,r);
}
il node2 query(int u,int v){
	if(top[u]==top[v]){
		return query2(1,1,n,dfn[v],dfn[u]);
	}
	node2 res=query2(1,1,n,dfn[top[u]],dfn[u]);
	u=fa[top[u]];
	while(top[u]!=top[v]){
		res=res+query2(1,1,n,dfn[top[u]],dfn[u]);
		u=fa[top[u]];
	}
	return res+query2(1,1,n,dfn[v],dfn[u]);
}
namespace cplx{
	bool end;
	il double usdmem(){return (&begin-&end)/1048576.0;}
}
int main(){
//	cout<<cplx::usdmem();
	read(n)read(m);
	Data::init();
	for(int i=2;i<=n;i++){
		read(fa[i]);
		e[fa[i]].pb(i);
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			a[i][j]=Data::getint();
//			cout<<a[i][j]<<" ";
		}
		sort(a[i]+1,a[i]+m+1);
//		for(int j=1;j<=m;j++){
//			cout<<a[i][j]<<" ";
//		}
//		puts("");
	}
	dfs1(1),dfs2(1);
	build(1,1,n);
	read(q);
	while(q--){
		int opt,u,v;
		read(opt)read(u);
		if(opt){
			read(v);
			node1 res1=query1(1,1,n,dfn[u],dfn[u]+sz[u]-1);
			int ans=0;
			if(u==v){
				for(int i=0;i<=m;i++){
					ans=max(ans,res1[i]);
				}
			}
			else{
				node2 res2=query(fa[u],v);
				for(int i=0;i<=m;i++){
					for(int j=0;j<=m-i;j++){
						ans=max(ans,res1[i]+res2[j]);
					}
				}
			}
			printf("%d\n",ans);
		}
		else{
			for(int i=1;i<=m;i++){
				a[u][i]=Data::getint();
			}
			sort(a[u]+1,a[u]+m+1);
			upd(1,1,n,dfn[u]);
//			for(int i=1;i<=m;i++){
//				cout<<a[u][i]<<" ";
//			}
//			puts("");
		}
	}
	return 0;
}
}
int main(){return asbt::main();}
```

---


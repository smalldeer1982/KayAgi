# [JOI Open 2024] 考试 2

## 题目描述

JOI 君在 IOI 高中上学，期末考试即将来临。考试的内容是计算 **IOI 函数**。IOI 函数是将 $[1,10^9]$ 之间的整数映射到布尔值（即 $\texttt{True}/\texttt{False}$）的函数。IOI 函数可以从以下六条 IOI 高中规定的规则中构造：

1. 设 $a$ 为 $[1,10^9]$ 之间的整数，则 $\texttt{[a]}$ 是一个 IOI 函数。它将不小于 $a$ 的整数映射成 $\texttt{True}$，将小于 $a$ 的整数映射成 $\texttt{False}$。

2. 记 $\texttt{f}$ 为 IOI 函数，则 $\texttt{(f)}$ 是一个 IOI 函数，它的映射规则与 $\texttt{f}$ 的映射规则相同。

3. 记 $\texttt{f}$ 为 IOI 函数，则 $\texttt{!f}$ 是一个 IOI 函数。设 $x$ 为整数，若 $\texttt{f}$ 将 $x$ 映射为 $\texttt{True}$，则 $\texttt{!f}$ 将 $x$ 映射为 $\texttt{False}$；否则 $\texttt{!f}$ 将 $x$ 映射为 $\texttt{True}$。

4. 记 $\texttt{f},\texttt{g}$ 为 IOI 函数，则 $\texttt{f\&g}$ 也是一个 IOI 函数。设 $x$ 为整数，则 $\texttt{f\&g}$ 将 $x$ 映射为 $\texttt{True}$，当且仅当 $\texttt{f},\texttt{g}$ 都将 $x$ 映射为 $\texttt{True}$。

5. 记 $\texttt{f},\texttt{g}$ 为 IOI 函数，则 $\texttt{f\^ g}$ 也是一个 IOI 函数。设 $x$ 为整数，则 $\texttt{f\^ g}$ 将 $x$ 映射为 $\texttt{True}$，当且仅当 $\texttt{f},\texttt{g}$ 中恰好有一个将 $x$ 映射为 $\texttt{True}$。

6. 记 $\texttt{f},\texttt{g}$ 为 IOI 函数，则 $\texttt{f|g}$ 也是一个 IOI 函数。设 $x$ 为整数，则 $\texttt{f|g}$ 将 $x$ 映射为 $\texttt{True}$，当且仅当 $\texttt{f},\texttt{g}$ 中至少有一个将 $x$ 映射为 $\texttt{True}$。

如果某个 IOI 函数用多条规则构造出，数字更大的规则将决定函数值。例如，对于 $\texttt{[1]\&[2]|[3]}$ 应当应用规则 6，其中 $\texttt{f} = \texttt{[1]\&[2]},\texttt{g} = \texttt{[3]}$（而非应用规则 4，其中 $\texttt{f} = \texttt{[1]},\texttt{g} = \texttt{[2]|[3]}$）。额外地，对于规则 4，5，6，应当最大化 $\texttt{f}$ 的长度。例如，对于 $\texttt{[4]ˆ[5]ˆ[6]}$，应当在 $\texttt{f} = \texttt{[4]ˆ[5]},\texttt{g} = \texttt{[6]}$ 上应用规则 5（而非 $\texttt{f} = \texttt{[4]},\texttt{g} = \texttt{[5]ˆ[6]}$）。

为备战期末考试，JOI 君准备好了一个长度为 $N$ 的 IOI 函数 $S$。他打算用 $Q$ 个整数 $X_1,X_2,\cdots,X_Q$ 来练习他的计算技能。于是他找来了你——能够熟练处理 IOI 函数的人，来解决这个问题。

你需要写一个程序。给定 $N,Q,S$ 以及 $X_1,X_2,\cdots,X_Q$，对于 $i=1,2=\cdots,Q$，回答 IOI 函数 $S$ 会将 $X_i$ 映射成 $\texttt{True}$ 还是 $\texttt{False}$。


## 说明/提示


### 样例解释

样例 $1$ 解释如下：

| $X_i$ | $\texttt{![2]}$ | $\texttt{[3]}$ | $\texttt{![2]\char124[3]}$ | $\texttt{![4]}$ | $\texttt{(![2]\char124[3])\&![4]}$ |
| :--: | :--: | :--: | :--: | :--: | :--: |
| $1$ | $\texttt{True}$ | $\texttt{False}$ | $\texttt{True}$ | $\texttt{True}$ | $\texttt{True}$ |
| $2$ | $\texttt{False}$ | $\texttt{False}$ | $\texttt{False}$ | $\texttt{True}$ | $\texttt{False}$ |
| $3$ |  $\texttt{False}$ | $\texttt{True}$ | $\texttt{True}$ | $\texttt{True}$ | $\texttt{True}$ |
| $4$ | $\texttt{False}$ | $\texttt{True}$ | $\texttt{True}$ | $\texttt{False}$ | $\texttt{False}$ |
| $5$ |  $\texttt{False}$ | $\texttt{True}$ | $\texttt{True}$ | $\texttt{False}$ | $\texttt{False}$ |

样例 $1$ 满足子任务 $3,6,7$ 的条件。

样例 $2$ 满足子任务 $1,3,5\sim 7$ 的条件。

样例 $3$ 满足子任务 $3,4,6,7$ 的条件。	

### 数据范围

- $1 \le N \le 1\,000\,000$；
- $1 \le Q \le 200\,000$；
- $S$ 为长度为 $N$ 的 IOI 函数；
- $1 \le X_i \le 10^9$（$1 \le i \le Q$）；
- $N, Q, X_i$（$1 \le i \le Q$）均为整数。

### 子任务

1. （$5$ points）$S$ 中不含 $\texttt{\&}$ 和 $\texttt{|}$；
2. （$20$ points）$Q = 1$；
3. （$10$ points）$N \le 10\,000$；
4. （$6$ points）$S$ 中不含 $\texttt{!}$ 和 $\texttt{ˆ}$；
5. （$12$ points）当应用规则 4 或 6 来构造 $S$ 时，$\texttt{f}$ 和 $\texttt{g}$ 中至少有一个是用规则 1 得到的；
6. （$20$ points）$N \le 400\, 000$；
7. （$27$ points）无额外约束。

*赛时公告：如果你复制题面中的 LaTeX，可能会得到 `ˆ`，但实际上是 `^`。请特别注意。

由 Starrykiller 根据英文题面翻译。

## 样例 #1

### 输入

```
15 5
(![2]|[3])&![4]
1
2
3
4
5```

### 输出

```
True
False
True
False
False```

## 样例 #2

### 输入

```
20 4
(!![23])^((([116])))
54
1
200
89```

### 输出

```
True
False
False
True```

## 样例 #3

### 输入

```
32 4
[2]|[5]&[1]|(([1000000000])|[7])
4
10
6
1```

### 输出

```
True
True
True
False```

# 题解

## 作者：HomuraAkemi (赞：1)

模拟赛搬了自己搬的题/jy

一句话概括解法：建出表达式树后扫描线动态 DP 即可。

### 建出表达式树

可能方法比较笨。

首先用栈可以算出每个 `!|^&` 对应的深度，对每个符号每个深度开一个数组记录下标。$\operatorname{build}(l,r)$ 时，按照优先级二分找出运算符位置即可。这样是 $\Theta(n\log n)$ 的。

### 动态 DP

从小到大扫描询问，每个节点的值只会变化一次。所以时间复杂度是对的。

我们对于每个节点，维护一个函数 $f:\{0,1\}\to \{0,1\}$。

套路地，对于叶子，就是 $\{0,1\}\to \{0\}/\{1\}$。对于非叶子，在进行重链剖分时分类讨论：根据轻儿子的状态和当前节点的类型来确定 $f$ 的具体映射。例如当前节点是 $\texttt{or}$，轻儿子是 $\texttt{False}$，那么显然有：$f(x)=x$。然后用你喜欢的数据结构维护即可，查询就是查询一条重链函数的复合（$f\circ g$）。

根据实现的不同，是 $\Theta((n+q)\log^2 n)$ 或者 $\Theta((n+q)\log n)$ 的。

Madoka 酱抱抱！

---

## 作者：Usada_Pekora (赞：1)

不难把题意转化为需要维护合法的 $x$ 的集合，然后是集合运算的表达式求值，根据一贯的套路，用值域线段树维护每个数在不在集合里，于是要完成若干区间赋 `0/1`，区间翻转操作。

分析一下表达式树怎么建，`'|', '&', '^'` 的儿子是下一个，`'!'` 的儿子可以是自己，也可以是 `"()"`（当然想办法去除掉重复的，不过有些麻烦），`"()"` 的儿子可以是任意一个“IOI 函数”，`"[]"` 是独立的。

对于相邻的运算优先级相同的**极长**表达式，考虑把它们串在一起，然后后缀计算（`'!'` 计算的需要）。

我们令 `expression(P)` 返回一个最高规则至少为 `P` 的表达式的节点编号，写出来就是这样：

```cpp
struct Node {
	int op, nxt, son;
	Node() = default;
	Node(int x, int y, int z) {
		op = x, nxt = y, son = z;
	}
} t[N];
inline int newnode(int x, int y, int z) {
	static int idx = 0;
	int p = ++idx;
	t[p] = Node(x, y, z);
	return p;
}
inline int getint() {
	int res = 0;
	char ch = s[ptr];
	while (isdigit(ch))
		res = res * 10 + ch - '0', ch = s[++ptr];
	return res;
}
inline int expression(const int P) {
	int p;
	if (P == 1) {
		ptr++, p = newnode(P, getint(), 0), ptr++;
	} else if (P == 2) {
		if (s[ptr] == '(') {
			ptr++, p = expression(6), ptr++;
		} else
			p = expression(P - 1);
	} else if (P == 3) {
		if (s[ptr] == '!')
			ptr++, p = newnode(P, expression(P), 0);
		else
			p = expression(P - 1);
	} else {
		p = expression(P - 1);
		while (ptr <= n && s[ptr] == "&^|"[P - 4])
			ptr++, p = newnode(P, p, expression(P - 1));
	}
	return p;
}
```

然后在表达式树上 dfs 和线段树操作，有两种搞法，我们规定 $n$ 是不同的数的大小，上界就十万多种，一种是启发式合并，每次把轻儿子里面的值的序列搞出来，然后把它们构成的连续段的取值转移到重儿子上面，是 $O(n\log^2n+q\log n)$ 的。

另一种考虑直接线段树合并，一次区间覆盖至多产生 $O(\log n)$ 个节点，由于我们所有的区间取反操作要么是对一棵线段树的根操作（即 `'!'`），要么是对两个至少有一个是全 `0/1` 连续段的区间合并（即 `'^'`），所以复杂度还是对的，合并过程中产生的空节点都是全 `0`，对复杂度也没影响，复杂度 $O((n+q)\log n)$。

```cpp
#include <bits/stdc++.h>
#define pb emplace_back
#define mkp make_pair
typedef long long ll;
typedef unsigned long long ull;
using namespace std;
template<typename T> inline bool chkmin(T &x, const T &y) {
	return (y < x) && (x = y, true);
}
template<typename T> inline bool chkmax(T &x, const T &y) {
	return (x < y) && (x = y, true);
}
constexpr int N = 1e6 + 5, LG = 30;
int n, q, ptr = 1, m = 0, stk[N * LG], top, all[N], ctag[N * LG], rtag[N * LG], val[N * LG], ls[N * LG], rs[N * LG], rt[N];
char s[N];
struct Node {
	int op, nxt, son;
	Node() = default;
	Node(int x, int y, int z) {
		op = x, nxt = y, son = z;
	}
} t[N];
inline int newnode(int x, int y, int z) {
	static int idx = 0;
	int p = ++idx;
	t[p] = Node(x, y, z);
	return p;
}
inline int getint() {
	int res = 0;
	char ch = s[ptr];
	while (isdigit(ch))
		res = res * 10 + ch - '0', ch = s[++ptr];
//	cerr << res << '\n';
	all[++m] = res;
	return res;
}
inline int expression(const int P) {
//	cerr << ptr << ' ' << s[ptr] << ' ' << P << '\n';
	int p;
	if (P == 1) {
		ptr++, p = newnode(P, getint(), 0), ptr++;
	} else if (P == 2) {
		if (s[ptr] == '(') {
			ptr++, p = expression(6), ptr++;
		} else
			p = expression(P - 1);
	} else if (P == 3) {
		if (s[ptr] == '!')
			ptr++, p = newnode(P, expression(P), 0);
		else
			p = expression(P - 1);
	} else {
		p = expression(P - 1);
		while (ptr <= n && s[ptr] == "&^|"[P - 4])
			ptr++, p = newnode(P, p, expression(P - 1));
	}
	return p;
}
inline int alloc() {
	static int idx = 0;
	int p = top ? stk[top--] : ++idx;
	ls[p] = rs[p] = rtag[p] = val[p] = 0;
	ctag[p] = 0;
	return p;
}
inline void pushcov(int p, int c) {
	ctag[p] = val[p] = c;
	rtag[p] = 0;
}
inline void pushrev(int p) {
	if (ctag[p] != -1)
		ctag[p] ^= 1;
	else
		rtag[p] ^= 1;
	val[p] ^= 1;
}
inline void pushdown(int p) {
	if (!ls[p])
		ls[p] = alloc();
	if (!rs[p])
		rs[p] = alloc();
	if (ctag[p] != -1) {
		pushcov(ls[p], ctag[p]), pushcov(rs[p], ctag[p]);
		ctag[p] = -1;
	}
	if (rtag[p]) {
		pushrev(ls[p]), pushrev(rs[p]);
		rtag[p] = 0;
	}
}
inline void assign(int &p, int l, int r, int L, int R, int k) {
//	cerr << "ass\n";
	if (!p)
		p = alloc();
	if (L <= l && r <= R) {
		pushcov(p, k);
		return;
	}
	int mid = (0u + l + r) >> 1;
	pushdown(p);
	if (L <= mid)
		assign(ls[p], l, mid, L, R, k);
	if (R > mid)
		assign(rs[p], mid + 1, r, L, R, k);
}
inline void clr(int p) {
//	return;
	stk[++top] = p;
	if (ls[p])
		clr(ls[p]);
	if (rs[p])
		clr(rs[p]);
}
inline int merge(int u, int v, int l, int r, int op) {
//	assert(u != 0 && v != 0);
//	cerr << u << ' ' << v << ' ' << l << ' ' << r << ' ' << op << ' ' << "mrg\n";
	if (ctag[u] != -1) {
		if (ctag[u] == 0) {
			clr(op == 4 ? v : u);
			return op == 4 ? u : v;
		} else {
			clr(u);
			if (op == 4)
				return v;
			if (op == 5)
				return (pushrev(v), v);
			if (op == 6)
				return (pushcov(v, 1), v);
		}
	}
	if (ctag[v] != -1) {
		if (ctag[v] == 0) {
			clr(op == 4 ? u : v);
			return op == 4 ? v : u;
		} else {
			clr(v);
			if (op == 4)
				return u;
			if (op == 5)
				return (pushrev(u), u);
			if (op == 6)
				return (pushcov(u, 1), u);
		}
	}
	if (l == r) {
		stk[++top] = v;
		if (op == 4)
			val[u] &= val[v];
		if (op == 5)
			val[u] ^= val[v];
		if (op == 6)
			val[u] |= val[v];
		return u;
	}
	pushdown(u), pushdown(v);
	int mid = (l + r) >> 1;
	ls[u] = merge(ls[u], ls[v], l, mid, op), rs[u] = merge(rs[u], rs[v], mid + 1, r, op);
	stk[++top] = v;
	return u;
}
inline int query(int p, int l, int r, int x) {
	if (!p)
		return 0;
	if (l == r)
		return val[p];
	pushdown(p);
	int mid = (l + r) >> 1;
	if (x <= mid)
		return query(ls[p], l, mid, x);
	return query(rs[p], mid + 1, r, x);
}
inline void dfs(int u) {
	stack<Node> rev;
	for (int i = u; i; i = t[i].nxt) {
		rev.push(t[i]);
		int v = t[i].son;
		if (v)
			dfs(v);
		if (t[i].op == 1)
			break;
	}
	rt[u] = alloc();
	while (!rev.empty()) {
		auto [op, val, v] = rev.top();
		rev.pop();
		if (op == 1) {
			assign(rt[u], 1, m, lower_bound(all + 1, all + m + 1, val) - all, m, 1);
		} else if (op == 3) {
			if (!rt[u])
				rt[u] = alloc();
			pushrev(rt[u]);
		} else {
			rt[u] = merge(rt[u], rt[v], 1, m, op);
		}
	}
}
signed main() {
	cin.tie(nullptr)->sync_with_stdio(false);
	cin >> n >> q;
	for (int i = 1; i <= n; i++)
		cin >> s[i];
	int root = expression(6);
	vector<int> qry(q + 1);
	for (int i = 1; i <= q; i++) {
		cin >> qry[i];
		all[++m] = qry[i];
	}
	sort(all + 1, all + m + 1);
	m = unique(all + 1, all + m + 1) - all - 1;
	dfs(root);
	for (int i = 1; i <= q; i++)
		cout << (query(rt[root], 1, m, lower_bound(all + 1, all + m + 1, qry[i]) - all) ? "True" : "False") << '\n';
	return 0;
}
```

---

## 作者：Purslane (赞：1)

# Solution

orz captain wt。

提供一个无脑线段树合并的做法。

-------

本题难点：建立表达式树。

稍微讲一下怎么建立表达式树，毕竟我写了一个多小时。

从左往右扫描 $\texttt S$。遇到 `(` 加栈，遇到 `)` 弹栈。加栈的时候还要找一下前面有多少个 `!`，如果有奇数个整个表达式要取反。

遇到 `[`，暴力往后找到 `]`，中间的数分离出来当做最小单元，同样要判断前面有多少个 `!`。

栈有很多层，每一层维护：当前 `&` 极长的可以继续添加的连续后缀，每个 `&` 连续段当做一个单元并维护这样单元的极长的可以继续添加的 `^` 连续后缀，并且把这样的后缀当做单元维护可以继续添加的 `|` 连续后缀。

---------

然后是线段树合并部分。

使用动态开点线段树。线段树每个区间维护：

1. 最终函数值有多少个 $1$；
2. 这段区间的长度（没必要，但是我这么写了。）；
3. 这段区间是否翻转（用于处理异或操作的懒标记）；
4. 这段区间是否全部为 $0/1$（也没必要，但我这么写了。）

差不多 $3 \times 10^7$ 个节点就够了。

~~赞美日本人不卡空间。~~

在线段树合并的过程中，如果某个线段树全为 $0/1$，就可以直接再另一棵上打标记，并且将这棵线段树垃圾回收。

复杂度 $O(n \log n)$，常数不大。

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1e6+10,MAXM=3e7+10,INF=1000000000;
int n,q,nd,op[MAXN],v[MAXN],rt[MAXN];
vector<int> G[MAXN]; 
string S;
namespace DS {
	struct INFO {int len,sum;bool flp,cov0,cov1;}t[MAXM];
	int tot,lson[MAXM],rson[MAXM];
	queue<int> bin;
	#define mid (l+r>>1)
	int get_node(int op,int len) {
		int id;
		if(!bin.empty()) id=bin.front(),bin.pop();
		else id=++tot;
		lson[id]=rson[id]=0;
		if(op==1) t[id]={len,len,0,0,1};
		else if(op==0) t[id]={0,len,0,1,0};
		else t[id]={0,len,0,0,0};
		return id;
	}
	void del(int u) {
		bin.push(u);
		if(lson[u]) del(lson[u]);
		if(rson[u]) del(rson[u]);
		return ;	
	}
	void push_up(int u) {
		t[u].len=t[lson[u]].len+t[rson[u]].len;
		if(t[u].len==0) t[u].cov0=1,del(lson[u]),del(rson[u]),lson[u]=rson[u]=0;	
		else if(t[u].len==t[u].sum) t[u].cov1=1,del(lson[u]),del(rson[u]),lson[u]=rson[u]=0;
		return ;
	}
	int build(int l,int r,int lim) { //<=lim 为 1 
		if(r<lim) return get_node(0,r-l+1);
		if(l>=lim) return get_node(1,r-l+1);
		int u=get_node(-1,r-l+1);
		lson[u]=build(l,mid,lim),rson[u]=build(mid+1,r,lim);
		return push_up(u),u;
	}
	void flip(int u) {
		t[u].flp^=1,t[u].len=t[u].sum-t[u].len;
		if(t[u].cov0) t[u].cov0=0,t[u].cov1=1,t[u].flp=0;
		else if(t[u].cov1) t[u].cov1=0,t[u].cov0=1,t[u].flp=0;
		return ;
	}
	void push_down(int u,int l,int r) {
		if(!lson[u]) {
			if(t[u].cov0) lson[u]=get_node(0,mid-l+1),rson[u]=get_node(0,r-mid);
			else lson[u]=get_node(1,mid-l+1),rson[u]=get_node(1,r-mid);
			return t[u].flp=0,void();
		}
		if(t[u].flp) flip(lson[u]),flip(rson[u]);
		return t[u].flp=0,void();
	}
	/*
	op=0 表示 &
	op=1 表示 ^
	op=2 表示 | 
	*/
	int merge(int u,int v,int l,int r,int op) {
		if(t[u].cov0) {
			if(op==1||op==2) return del(u),v;
			return del(v),u;	
		}
		if(t[u].cov1) {
			if(op==0) return del(u),v;
			if(op==1) return flip(v),del(u),v;
			return del(v),u;
		}
		if(t[v].cov0) {
			if(op==1||op==2) return del(v),u;
			return del(u),v;
		}
		if(t[v].cov1) {
			if(op==0) return del(v),u;
			if(op==1) return flip(u),del(v),u;
			return del(u),v;
		}
		push_down(u,l,r),push_down(v,l,r);
		lson[u]=merge(lson[u],lson[v],l,mid,op),rson[u]=merge(rson[u],rson[v],mid+1,r,op);
		return bin.push(v),u;
	}
	int query(int u,int l,int r,int pos) {
		if(t[u].cov0) return 0;
		if(t[u].cov1) return 1;
		int tans=-1;
		if(pos<=mid) tans=query(lson[u],l,mid,pos);
		else tans=query(rson[u],mid+1,r,pos);
		if(t[u].flp) tans^=1;
		return tans;	
	}
}
int tdep,rts;
vector<int> EXP[MAXN];
vector<int> XOR[MAXN];
vector<int> AND[MAXN];
int merge(int u,int v) {
	return ++nd,G[nd].push_back(u),G[nd].push_back(v),nd;	
}
void del_and(int dep) {
	if(AND[dep].empty()) return ;
	if(AND[dep].size()==1) return XOR[dep].push_back(AND[dep][0]),AND[dep].clear(),void();
	int t=AND[dep][0];
	ffor(i,1,AND[dep].size()-1) {
		int k=merge(t,AND[dep][i]);
		op[k]=0,t=k;	
	}
	return AND[dep].clear(),XOR[dep].push_back(t),void();
}
void del_xor(int dep) {
	if(XOR[dep].empty()) return ;
	if(XOR[dep].size()==1) return EXP[dep].push_back(XOR[dep][0]),XOR[dep].clear(),void();
	int t=XOR[dep][0];
	ffor(i,1,XOR[dep].size()-1) {
		int k=merge(t,XOR[dep][i]);
		op[k]=1,t=k;	
	}
	return XOR[dep].clear(),EXP[dep].push_back(t),void();
}
void del_EXP(int dep,int ops) {
	if(EXP[dep].empty()) return ;
	int t=EXP[dep][0];
	ffor(i,1,EXP[dep].size()-1) {
		int k=merge(t,EXP[dep][i]);
		op[k]=2,t=k;	
	}
	if(ops) ++nd,G[nd].push_back(t),op[nd]=-2,t=nd;
	if(dep==0) rts=t;
	else AND[dep-1].push_back(t);
	return EXP[dep].clear(),void();
}
//-1 啥都没有 -2 是取反 
void dfs(int u) {
	if(op[u]==-1) return rt[u]=DS::build(1,INF,v[u]),void();
	if(op[u]==-2) return dfs(G[u][0]),rt[u]=rt[G[u][0]],DS::flip(rt[u]),void();
	dfs(G[u][0]),dfs(G[u][1]);
	rt[u]=DS::merge(rt[G[u][0]],rt[G[u][1]],1,INF,op[u]);
	return ;
}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>q>>S,S="&"+S;
	stack<int> st;
	int flg_not=0;
	ffor(i,1,n) {
		if(S[i]=='!') flg_not^=1;
		else if(S[i]=='(') tdep++,st.push(flg_not),flg_not=0;	
		else if(S[i]==')') {
			int tv=EXP[tdep][0],op=st.top(); st.pop();
			del_and(tdep),del_xor(tdep),del_EXP(tdep,op),tdep--;
		}
		else if(S[i]=='[') {
			int id=0;
			i++;
			while(S[i]>='0'&&S[i]<='9') id=id*10+(S[i]-'0'),i++;
			int tval=++nd;
			op[tval]=-1,v[tval]=id;
			if(flg_not) ++nd,G[nd].push_back(tval),op[nd]=-2,tval=nd;
			flg_not=0;
			AND[tdep].push_back(tval);
		}
		else if(S[i]=='|') del_and(tdep),del_xor(tdep);	
		else if(S[i]=='^') del_and(tdep);
		else ;
	}
	del_and(0),del_xor(0),del_EXP(0,0);
	dfs(rts);
	ffor(i,1,q) {
		int x;
		cin>>x;
		if(DS::query(rt[rts],1,INF,x)) cout<<"True\n";
		else cout<<"False\n";
	}
	return 0;
}
```

---

## 作者：_•́へ•́╬_ (赞：1)

前几天才做到了类似的模拟赛题。。。

## 思路

先把表达式树建出来。

把询问离线下来从小往大扫。初始所有叶子值都是 $0$，逐渐地会变成 $1$，每个值只会被修改一次。

在表达式树上树剖线段树即可，类似动态 dp 的写法。

## code

```cpp
#include<stdio.h>
#include<algorithm>
#define N 1048576
#define M 200009
#define pr pair<int,int> 
#define lc ((i)<<1|1)
#define rc ((i)+1<<1)
using namespace std;
inline char nc()
{
	static char buf[99999],*l,*r;
	return l==r&&(r=(l=buf)+fread(buf,1,99999,stdin),l==r)?EOF:*l++;
}
inline void read(int&x)
{
	char c=nc();for(;c<'0'||'9'<c;c=nc());
	for(x=0;'0'<=c&&c<='9';x=(x<<3)+(x<<1)+(c^48),c=nc());
}
int n,m,mm,ans[M],e[N][2],st1[N],sz1,st2[N],sz2;char s[N];pr q[N+M];
int sz[N],dfn[N],now,top[N],f[N];
struct node
{
	int a[2];
	inline node operator+(const node&kkk)const
		{return(node){kkk.a[a[0]],kkk.a[a[1]]};}
}tre[N<<1];
inline void upd(int i,int l,int r,int p,node x)
{
	if(l==r){tre[i]=x;return;}
	int mid=l+r>>1;
	if(p<=mid)upd(lc,l,mid,p,x);
	else upd(rc,mid+1,r,p,x);
	tre[i]=tre[rc]+tre[lc];
}
inline node qry(int i,int l,int r,int ql,int qr)
{
	if(qr<l||r<ql)return(node){0,1};
	if(ql<=l&&r<=qr)return tre[i];
	int mid=l+r>>1;
	return qry(rc,mid+1,r,ql,qr)+qry(lc,l,mid,ql,qr);
}
inline void upd(int i)
{
	int x=qry(0,0,n-1,dfn[e[i][1]],n-1).a[0];
	if(s[i]=='&')upd(0,0,n-1,dfn[i],(node){0,x});
	if(s[i]=='^')upd(0,0,n-1,dfn[i],(node){x,x^1});
	if(s[i]=='|')upd(0,0,n-1,dfn[i],(node){x,1});
}
inline int dfs1(int i,int f)
{
	::f[i]=f;sz[i]=1;
	if('0'<=s[i]&&s[i]<='9')return 1;
	if(s[i]=='!')return sz[i]+=dfs1(e[i][0],i);
	sz[i]+=dfs1(e[i][0],i)+dfs1(e[i][1],i);
	if(sz[e[i][0]]<sz[e[i][1]])e[i][0]^=e[i][1]^=e[i][0]^=e[i][1];
	return sz[i];
}
inline void dfs2(int i,int t)
{
	dfn[i]=now++;top[i]=t;
	if('0'<=s[i]&&s[i]<='9')
	{
		int x;sscanf(s+i,"%d",&x);
		q[mm++]=(pr){x,~i};
		return;
	}
	if(s[i]=='!')
	{
		upd(0,0,n-1,dfn[i],(node){1,0});
		dfs2(e[i][0],t);
		return;
	}
	dfs2(e[i][0],t);dfs2(e[i][1],e[i][1]);upd(i);
}
main()
{
	read(n);read(m);mm=m;for(int i=0;i<n;s[i++]=nc());
	for(int i=0;i<m;++i)read(q[i].first),q[i].second=i;
	for(int i=n-1;i>=0;--i)switch(s[i])
	{
		case'[':st2[sz2++]=i+1;break;
		case'!':e[i][0]=st2[--sz2];st2[sz2++]=i;break;
		case')':st1[sz1++]=i;break;
		case'(':for(;s[st1[sz1-1]]^')';e[st1[sz1-1]][0]=st2[--sz2],
			e[st1[sz1-1]][1]=st2[--sz2],st2[sz2++]=st1[--sz1]);
			--sz1;break;
		case'&':st1[sz1++]=i;break;
		case'^':
			for(;s[st1[sz1-1]]=='&';e[st1[sz1-1]][0]=st2[--sz2],
				e[st1[sz1-1]][1]=st2[--sz2],st2[sz2++]=st1[--sz1]);
			st1[sz1++]=i;break;
		case'|':
			for(;s[st1[sz1-1]]=='&'||s[st1[sz1-1]]=='^';
				e[st1[sz1-1]][0]=st2[--sz2],
				e[st1[sz1-1]][1]=st2[--sz2],st2[sz2++]=st1[--sz1]);
			st1[sz1++]=i;break;
	}
	for(;sz1;e[st1[sz1-1]][0]=st2[--sz2],
		e[st1[sz1-1]][1]=st2[--sz2],st2[sz2++]=st1[--sz1]);
}
```

---


# [KTSC 2024 R1] 警察与小偷

## 题目背景

**请勿使用 C++14 (GCC 9) 提交**。

你需要在程序开头加入如下代码：

```cpp
#include<vector>
#include<array>
std::vector<std::array<long long, 2>> police_thief(std::vector<int> A, std::vector<int> B, std::vector<int> D, std::vector<int> P, std::vector<int> V1, std::vector<int> T, std::vector<int> V2);
```

## 题目描述

**题目译自 [2024년도 국제정보올림피아드 대표학생 선발고사 - 1차 선발고사](https://www.ioikorea.kr/archives/ioitst/2024/)  T3 「[경찰과 도둑](https://assets.ioikorea.kr/ioitst/2024/1/police/police_statement.pdf)」**

KOI 村由 $N$ 座房子和连接这些房子的 $N-1$ 条双向道路组成。任意两座不同的房子都可以通过这些道路互相到达。也就是说，KOI 村的道路网络是一个树结构。

KOI 村的房子编号从 $0$ 到 $N-1$，道路编号从 $0$ 到 $N-2$。对于编号为 $i$ 的道路，它连接了编号为 $A[i]$ 和 $B[i]$ 的房子，长度为 $D[i]$ 米。

最近，KOI 村频繁发生盗窃事件，村民们非常困扰。为了应对这种情况，村里决定在某个房子里安排警察待命，以便在小偷出现时迅速抓捕。村民们想知道在不同情况下，警察需要多长时间才能抓住小偷。

你将会得到 $Q$ 个场景，每个场景编号从 $0$ 到 $Q-1$。每个场景如下：

- 在第 $j$ 个场景中，警察从编号为 $P[j]$ 的房子出发，最大速度为 $V1[j]$ 米/秒。
- 在第 $j$ 个场景中，小偷从编号为 $T[j]$ 的房子出发，最大速度为 $V2[j]$ 米/秒。
- 警察和小偷出发的房子不同，即 $P[j] \neq T[j]$。
- 房子的大小可以忽略不计，因此可以将房子视为一个点。道路的宽度也可以忽略不计，因此可以将道路视为一条线段。道路之间不相交。
- 警察和小偷可以在 KOI 村内自由移动，速度不超过各自的最大速度。可以选择不移动。
- 如果警察和小偷在同一个位置，警察就能抓住小偷。这个位置可以是房子，也可以是道路的中间。
- 在每个场景中，警察和小偷都知道对方的速度，并且随时知道对方的位置。
- 警察和小偷都会采用最优策略。警察会尽快抓住小偷，而小偷会尽量拖延被抓住的时间。可以证明，在最优策略下，小偷一定会在有限时间内被抓住。

你需要计算每个场景中，小偷被抓住所需的时间。

你需要实现以下函数：

```cpp
std::vector<std::array<long long, 2>> police_thief(std::vector<int> A, std::vector<int> B, std::vector<int> D, std::vector<int> P, std::vector<int> V1, std::vector<int> T, std::vector<int> V2);
```

- `A, B, D`：大小为 $N-1$ 的整数数组。对于每条编号为 $i$ 的道路，它连接了编号为 $A[i]$ 和 $B[i]$ 的房子，长度为 $D[i]$ 米。
- `P, V1, T, V2`：大小为 $Q$ 的整数数组。对于第 $j$ 个场景，警察从编号为 $P[j]$ 的房子出发，最大速度为 $V1[j]$ 米/秒，小偷从编号为 $T[j]$ 的房子出发，最大速度为 $V2[j]$ 米/秒。
- 该函数返回一个大小为 $Q$ 的数组 $C$，每个元素是一个大小为 $2$ 的数组。对于第 $j$ 个场景，小偷被抓住所需的时间（以秒为单位）表示为分数 $C[j][0] / C[j][1]$。
- $C[j][0] / C[j][1]$ 可以不是最简分数，但 $C[j][0]$ 和 $C[j][1]$ 必须是 $1$ 到 $10^{18}$ 之间的整数。可以证明，对于所有满足约束条件的输入，答案总能表示为这种形式的分数。

注意，提交的代码中不应包含任何输入输出操作。


## 说明/提示

对于所有输入数据，满足：

- $2 \leq N \leq 10^5$
- $1 \leq Q \leq 10^5$
- 对于所有 $i$ $(0 \leq i \leq N-2)$，$0 \leq A[i], B[i] \leq N-1$ 且 $A[i] \neq B[i]$
- 对于所有 $i$ $(0 \leq i \leq N-2)$，$1 \leq D[i] \leq 10^6$
- KOI 村是一棵树的结构
- 对于所有 $j$ $(0 \leq j \leq Q-1)$，$0 \leq P[j], T[j] \leq N-1$ 且 $P[j] \neq T[j]$
- 对于所有 $j$ $(0 \leq j \leq Q-1)$，$1 \leq V1[j], V2[j] \leq 10^6$

详细子任务附加限制及分值如下表所示。

| 子任务 | 分值 | 附加限制 |
| :-: | :-: | :-: |
| $1$ | $15$ | $N \leq 5000, Q \leq 5000$ |
| $2$ | $21$ | $N \leq 50000,Q \leq 50000$ |
| $3$ | $5$ | 对于所有 $i$ $(0 \leq i \leq N-2)$，$A[i]=i, B[i]=i+1$ |
| $4$ | $6$ | 对于所有 $i$ $(0 \leq i \leq N-2)$，$A[i]=0, B[i]=i+1$ |
| $5$ | $14$ | 对于所有 $j$ $(0 \leq j \leq Q-1)$，$V1[j] \leq V2[j]$ |
| $6$ | $9$ | 对于所有 $j$ $(0 \leq j \leq Q-1)$，$P[j]$ 和 $T[j]$ 之间的道路数量不超过 $10$ 条 |
| $7$ | $9$ | 对于所有 $j$ $(0 \leq j \leq Q-1)$，$P[j]=0$ |
| $8$ | $10$ | 对于所有 $j$ $(0 \leq j \leq Q-1)$，$T[j]=0$ |
| $9$ | $11$ | 无附加限制 |

## 样例 #1

### 输入

```
4 3
0 1 557912
0 2 517656
0 3 275807
3 265381 0 1000000
0 190435 2 12345
0 195025 3 67890```

### 输出

```
833719 265381
517656 190435
275807 195025```

## 样例 #2

### 输入

```
6 4
0 1 2
1 2 2
2 3 10
1 4 8
2 5 16
3 4 0 3
3 2 0 1
3 19 0 9
3 20 0 19```

### 输出

```
6 1
10 1
1 1
13 10```

## 样例 #3

### 输入

```
10 10
4 9 7
2 8 8
9 0 4
9 1 5
3 1 1
7 6 2
1 2 5
6 2 10
5 9 2
3 1 5 9
0 6 5 7
5 6 9 6
2 5 1 7
0 2 6 4
5 6 2 10
5 5 0 10
7 4 1 8
9 1 8 7
8 5 4 5```

### 输出

```
18 1
13 3
4 1
17 5
13 1
4 1
6 5
29 4
22 1
5 1```

## 样例 #4

### 输入

```
10 10
6 7 1
8 5 1
8 2 4
3 9 4
4 1 4
9 7 7
0 4 3
1 3 4
8 4 7
3 5 0 2
1 7 7 2
6 9 8 5
2 7 0 5
3 5 2 4
3 10 0 5
2 8 0 7
6 8 7 2
1 4 8 2
2 8 5 7```

### 输出

```
11 5
16 7
31 9
4 1
19 5
11 10
31 8
1 6
15 4
3 1```

# 题解

## 作者：dadaaa (赞：2)

首先考虑 $V1\le V2$ 的情况，注意到，只要小偷不送死，警察只能够追到叶子在抓他。如果我们设 $P$ 为根，设 $d_x$ 为 $x$ 点到子树内深度最深点的距离，发现答案是 $P$ 到 $T$ 路径上所有**不被抓到的点中** $\frac{d_i+a1_i}{V1}$ 最大的（表示警察所需要的时间）（$a1_i$ 表示 $i$ 到 $P$ 的距离，$a2_i$ 表示 $i$ 到 $T$ 的距离）。再考虑这个值在链上是单调的，越靠近 $P$ 的一定更大（反正警察追不到，越往上小偷选择越多）。因此答案就是链上最靠近 $P$ 的不被抓到的点的这个值，树剖完二分即可。对于每次询问，单点求 $d_i$ 是容易的（换根求最大次大）。

现在再考虑 $V1\gt V2$ 的情况。此时警察可能抓到小偷了，因此当我们小偷**能走到**链上的点 $i$ 时，警察抓到他所需要的时间是 $\min(\frac{a1_i+d_i}{V1},\frac{a1_i-a2_i}{V1-V2})$。（所有定义和前文相同）。注意到后面那项同样在链上单调（离警察越远越难追），所以我们树剖二分出分界点，最优值一定在分界点前后。~~为啥不用判断会不会在链上追到，会出负数？因为这样一定不优。~~

总复杂度 $O(n\log n)$。~~我写了5k，好像双 log 更好写~~

```cpp
#include "police.h"
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define db double
const int N=1e5+10;
int n,q;
vector<pair<int,ll> > e[N];
ll mx[N],se[N],disrt[N];
int mxp[N],sep[N];
int sum[N],dep[N],Fa[N];
int son[N],top[N],in[N],p[N],timer;
void dfs1(int x,int fa) {
	sum[x]=1;
	Fa[x]=fa;
	dep[x]=dep[fa]+1;
	for(auto v:e[x]) if (v.first!=fa) {
		dfs1(v.first,x);
		sum[x]+=sum[v.first];
		if (sum[v.first]>sum[son[x]]) son[x]=v.first;
	}
}
void dfs2(int x,int cap) {
	top[x]=cap;
	p[in[x]=++timer]=x;
	if(son[x]) dfs2(son[x],cap);
	for(auto v:e[x]) if(v.first!=son[x]&&v.first!=Fa[x]) {
		dfs2(v.first,v.first);
	}
}
void upd(int x,ll d,int c) {
	if(d>mx[x]) {
		se[x]=mx[x],sep[x]=mxp[x];
		mx[x]=d,mxp[x]=c;
	} else if(d>se[x]) {
		se[x]=d,sep[x]=c;
	}
}
void dfs3(int x) {
	for(auto v:e[x]) if(v.first!=Fa[x]) {
		disrt[v.first]=disrt[x]+v.second;
		dfs3(v.first);
		upd(x,mx[v.first]+v.second,v.first);
	}
}
void dfs4(int x,ll d) {
	upd(x,d,Fa[x]);
	for(auto v:e[x]) if(v.first!=Fa[x]) {
		dfs4(v.first,max(d,mxp[x]!=v.first? mx[x]:se[x])+v.second);
	}
}
bool check(int x,int b,ll a1,ll a2,ll v1,ll v2) {
	ll di=(mxp[x]==b? se[x]:mx[x]);
	// cerr<<di<<'\n';
	return (1.0*di+1.0*a1)/(1.0*v1)<(1.0*a1-1.0*a2)/(1.0*v1-1.0*v2);
}
array<ll,2> query(int P,int T,ll v1,ll v2) {
	vector<pair<int,int> > up,dn;
	ll d=0,g,u=P,v=T;
	while(top[u]!=top[v]) {
		if(dep[top[u]]>dep[top[v]]) {
			up.emplace_back(in[u],in[top[u]]);
			u=Fa[top[u]];
		} else {
			dn.emplace_back(in[top[v]],in[v]);
			v=Fa[top[v]];
		}
	}
	if(dep[u]<dep[v]) g=u,dn.emplace_back(in[u],in[v]);
	else g=v,up.emplace_back(in[u],in[v]);
	d=disrt[P]+disrt[T]-disrt[g]*2;
	reverse(dn.begin(),dn.end());
	if(v1<=v2) {
		int lst=P;
		for(auto li:up) {
			int x=p[li.second],b=(li.second==li.first? lst:p[li.second+1]);
			ll a1=disrt[P]-disrt[x],a2=d-a1;
			if((1.0*a1)/(1.0*v1)<=(1.0*a2)/(1.0*v2)) {
				lst=x;
				continue;
			} 
			int l=li.first,r=li.second,res=li.second;
			while(l>=r) {
				int mid=(l+r+1)/2;
				int x=p[mid];//,b=(mid==li.first?lst:p[mid+1]);
				ll a1=disrt[P]-disrt[x],a2=d-a1;
				if((1.0*a1)/(1.0*v1)>(1.0*a2)/(1.0*v2)) res=mid,r=mid+1;
				else l=mid-1;
			}
			x=p[res],b=(res==li.first?lst:p[res+1]);
			a1=disrt[P]-disrt[x],a2=d-a1;
			ll di=(mxp[x]==b?se[x]:mx[x]);
			return {a1+di,v1};
		}
		for(auto li:dn) {
			int x=p[li.second],b=(li.second==li.first? lst:p[li.second-1]);
			ll a2=disrt[T]-disrt[x],a1=d-a2;
			if((1.0*a1)/(1.0*v1)<=(1.0*a2)/(1.0*v2)) {
				lst=x;
				continue;
			} 
			int l=li.first,r=li.second,res=li.second;
			while(l<=r) {
				int mid=(l+r)/2;
				int x=p[mid];//,b=(mid==li.first?lst:p[mid-1]);
				ll a2=disrt[T]-disrt[x],a1=d-a2;
				if((1.0*a1)/(1.0*v1)>(1.0*a2)/(1.0*v2)) res=mid,r=mid-1;
				else l=mid+1;
			}
			x=p[res],b=(res==li.first?lst:p[res-1]);
			a2=disrt[T]-disrt[x],a1=d-a2;
			ll di=(mxp[x]==b?se[x]:mx[x]);
			return {a1+di,v1};
		}
	} else {
		int lst=P;
		ll al1=0,al2=0;
		for(auto li:up) {
			int x=p[li.second],b=(li.first==li.second? lst:p[li.second+1]);
			ll a1=disrt[P]-disrt[x],a2=d-a1;
			if(!check(x,b,a1,a2,v1,v2)) {
				lst=x,al1=a1,al2=a2;
				continue;
			}
			int l=li.first,r=li.second,res=li.second;
			while(l>=r) {
				int mid=(l+r+1)/2;
				int x=p[mid],b=(mid==li.first?lst:p[mid+1]);
				ll a1=disrt[P]-disrt[x],a2=d-a1;
				if(check(x,b,a1,a2,v1,v2)) res=mid,r=mid+1;
				else l=mid-1;
			}
			x=p[res],b=(res==li.first?lst:p[res+1]);
			if(b!=lst) {
				al1=disrt[P]-disrt[b],al2=d-al1;
			}
			a1=disrt[P]-disrt[x],a2=d-a1;
			ll di=(mxp[x]==b?se[x]:mx[x]);
			db res1=(1.0*di+1.0*a1)/(1.0*v1),res2=(1.0*al1-1.0*al2)/(1.0*v1-1.0*v2);
			// cerr<<p[li.first]<<' '<<p[li.second]<<'\n';
			// cerr<<x<<' '<<res1<<' '<<res2<<'\n';
			if(res1>res2) return {di+a1,v1};
			else return {al1-al2,v1-v2};
		}
		for(auto li:dn) {
			int x=p[li.second],b=(li.first==li.second? lst:p[li.second-1]);
			ll a2=disrt[T]-disrt[x],a1=d-a2;
			if(!check(x,b,a1,a2,v1,v2)) {
				lst=x,al1=a1,al2=a2;
				continue;
			}
			int l=li.first,r=li.second,res=li.second;
			while(l<=r) {
				int mid=(l+r)/2;
				int x=p[mid],b=(mid==li.first?lst:p[mid-1]);
				ll a2=disrt[T]-disrt[x],a1=d-a2;
				if(check(x,b,a1,a2,v1,v2)) res=mid,r=mid-1;
				else l=mid+1;
			}
			x=p[res],b=(res==li.first?lst:p[res-1]);
			if(b!=lst) {
				al2=disrt[T]-disrt[b],al1=d-al2;
			}
			a2=disrt[T]-disrt[x],a1=d-a2;
			ll di=(mxp[x]==b?se[x]:mx[x]);
			db res1=(1.0*di+1.0*a1)/(1.0*v1),res2=(1.0*al1-1.0*al2)/(1.0*v1-1.0*v2);
			// cerr<<p[li.first]<<' '<<p[li.second]<<'\n';
			// cerr<<x<<' '<<res1<<' '<<res2<<'\n';
			if(res1>res2) return {di+a1,v1};
			else return {al1-al2,v1-v2};
		}
		return {d,v1-v2};
	}
	return {-1,-1};
} 

std::vector<std::array<long long, 2>> police_thief(std::vector<int> A, std::vector<int> B, std::vector<int> D,
	 std::vector<int> P, std::vector<int> V1, std::vector<int> T, std::vector<int> V2){
	n=A.size()+1,q=(int)P.size();
	for(int i=0;i<n-1;i++) {
		e[A[i]+1].emplace_back(B[i]+1,D[i]);
		e[B[i]+1].emplace_back(A[i]+1,D[i]);
	}
	dfs1(1,0);
	dfs2(1,1);
	dfs3(1);
	dfs4(1,0);
	// for(int i=1;i<=n;i++) cerr<<in[i]<<' ';
	// cerr<<'\n';
	std::vector<std::array<long long, 2>> C(q);
	for(int te=0;te<q;te++) {
		// cerr<<"TE\n";
		C[te]=query(P[te]+1,T[te]+1,V1[te],V2[te]);
	}
	// cerr<<mx[8]<<"\n";
	return C;
}
```

---

## 作者：dream10 (赞：0)

## Hint

看完所有部分分，链和菊花，$V1\leq V2$，路径长度小，分别有什么用意？

## Solution

### Step 1

首先，观察到警察一定向小偷方向走，小偷一定走简单路径，那么枚举这个简单路径即可做到 $O(nQ)$。具体地，到 $path(P,T)$ 上一点，然后到最深的叶子，进行 dfs 即可。

### Step 2

需要更为定量的表示，设小偷从 $T$ 到达 $X$，设 $X$ 出发到达最深的叶子深度有 $mx[X]$，设 $d1[X]=dist(P,X),d2[X]=dist(T,X)$。

简单的分讨：

- 在 $X$ 处警察没有追到
- 要么走到底等着被抓
- 要么走的时候被追到

前者的上界是 

$$\frac{d1[X]+mx[X]}{V1} \qquad(1)$$

后者在 $V1>V2$ 时上界是 

$$\frac{d1[X]}{V1}+(\frac{d1[X]}{V1}-\frac{d2[X]}{V2})\frac{V2}{V1-V2}=\frac{d1[X]-d2[X]}{V1-V2}\qquad(2)$$

在其他情况是 $\infty$。

还需要满足 

$$\frac{d1[X]}{V1}>\frac{d2[X]}{V2} \qquad(3)$$

两者取 $\min$。

### Step 3

如果枚举 $X$ 是路径上的一个点，然后一个个判断是可以得到分的。但是需要得到
一个点向外最深的叶子，这个可以通过换根 dp 得到，然后枚举 $P\rightarrow LCA(P,T)\rightarrow T$，上的点，$LCA(P,T)$ 要去掉两个子树，还要加上上面的外子树。使用倍增等你喜欢的数据结构维护。

### Step 4

但是如果路径长怎么办，我们先考虑 $V1\leq V2$。

对于 $(3)$ 式，发现满足这个式子的点是 $path(P,T)$ 上从 $T$ 开始的一段路径。可以使用数据结构找到。

对于 $(1)$ 式，可以使用数据结构维护最值。

这里的数据结构使用树上倍增。

### Step 5

如果将 $(2)$ 式加入，数据结构是没法维护的。（如果真的有这种科技，请务必要联系笔者，或者在评论区介绍。）

那么发现一下 $(2)$ 式的性质，发现在路径上，这个式子是单调的，但是是随着 $(1)$ 的增加而减少。考虑到最后答案是取 $\min$，那么有用的点只有中间相交的 $O(1)$ 个点。

那使用数据结构找到相交的位置，判断一下，注意同时考虑 $(3)$ 的限制。

这里的数据结构还是使用树上倍增。

### Step 6

笔者调试了很久，附上代码供对拍+参考。

```
#include<bits/stdc++.h>
using namespace std;
std::vector<std::array<long long, 2>> police_thief(std::vector<int> A, std::vector<int> B, std::vector<int> D, std::vector<int> P, std::vector<int> V1, std::vector<int> T, std::vector<int> V2);
template<typename T>
void read(T &a){
    #define gc getchar()
    char c;a=0;int f=1;
    while(!isdigit(c=gc))if(c=='-')f=-1;
    do a=a*10+c-'0';
    while(isdigit(c=gc));
    a*=f;
}
template<typename T>
void write(T a){
    if(a<0)putchar('-'),a=-a;
    if(a>=10)write(a/10);
    putchar('0'+a%10);
}
char GC(){
    char c=getchar();
    while(c<=32)c=getchar();
    return c;
}
template<typename T>
void chmin(T &x,T y){if(x>y)x=y;}
template<typename T>
void chmax(T &x,T y){if(x<y)x=y;}
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
typedef unsigned int ui;
typedef pair<int,int> PII;
typedef pair<ll,int> PLI;

typedef long long ll;
const int MAXN=200010;
struct Edge{
    int ne,to,val;
}e[MAXN<<1];int eid;
int h[MAXN];
void add_edge(int x,int y,int z){
    e[eid].val=z;e[eid].ne=h[x];e[eid].to=y;h[x]=eid++;
}
int n,Q,s,t;
ll v1,v2;
struct Frac{
    ll p,q;
    Frac(){}
    Frac(ll p,ll q):p(p),q(q){
    }
    Frac operator+(const Frac B){
        return Frac(p*B.q+B.p*q,q*B.q);
    }
    Frac operator-(const Frac B){
        return Frac(p*B.q-B.p*q,q*B.q);
    }
    Frac operator*(const Frac B){
        return Frac(p*B.p,q*B.q);
    }
};
typedef __int128 lll;
bool operator < (const Frac A,const Frac B){
    return (lll)A.p*B.q<(lll)B.p*A.q;
}
bool operator <= (const Frac A,const Frac B){
    return (lll)A.p*B.q<=(lll)B.p*A.q;
}
bool operator > (const Frac A,const Frac B){
    return (lll)A.p*B.q>(lll)B.p*A.q;
}
bool operator >= (const Frac A,const Frac B){
    return (lll)A.p*B.q>=(lll)B.p*A.q;
}
Frac ans;
pair<ll,int> mx[MAXN][3];//每个子树往下最深的路径没有就是(0,-1)
ll mxf[MAXN];
ll Dep[MAXN];int dep[MAXN];
int dfn[MAXN],dfc,siz[MAXN];
int fa[17][MAXN],lg[MAXN];
ll f[17][MAXN],g[17][MAXN];//f:Dep[fa]+mx[fa] g:-Dep[fa]+mx[fa]
void dfs(int x){
    for(int i=1;i<=lg[dep[x]];++i)
        fa[i][x]=fa[i-1][fa[i-1][x]];
    mx[x][0]=mx[x][1]=mx[x][2]={0,-1};
    dfn[x]=++dfc;siz[x]=1;
    for(int i=h[x];~i;i=e[i].ne){
        int y=e[i].to;
        if(y==fa[0][x])continue;
        fa[0][y]=x;
        dep[y]=dep[x]+1;
        Dep[y]=Dep[x]+e[i].val;
        dfs(y);
        for(int j=0;j<3;++j)
            if(e[i].val+mx[y][0].first>mx[x][j].first){
                for(int k=2;k>j;--k)swap(mx[x][k],mx[x][k-1]);
                mx[x][j]={mx[y][0].first+e[i].val,y};
                break;
            }
        siz[x]+=siz[y];
    }
}
void dfs2(int x){
    if(dep[x]>0)f[0][x]=(mx[fa[0][x]][0].second==x?mx[fa[0][x]][1].first:mx[fa[0][x]][0].first)+Dep[fa[0][x]];
    for(int i=1;i<=lg[dep[x]];++i)
        f[i][x]=max(f[i-1][x],f[i-1][fa[i-1][x]]);
    if(dep[x]>0)g[0][x]=(mx[fa[0][x]][0].second==x?mx[fa[0][x]][1].first:mx[fa[0][x]][0].first)-Dep[fa[0][x]];
    for(int i=1;i<=lg[dep[x]];++i)
        g[i][x]=max(g[i-1][x],g[i-1][fa[i-1][x]]);
    for(int i=h[x];~i;i=e[i].ne){
        int y=e[i].to;
        if(y==fa[0][x])continue;
        mxf[y]=mxf[x]+e[i].val;
        if(mx[x][0].second!=y)chmax(mxf[y],mx[x][0].first+e[i].val);
        else chmax(mxf[y],mx[x][1].first+e[i].val);
        dfs2(y);
    }
}
int lca(int x,int y){
    if(dep[x]<dep[y])swap(x,y);
    for(int i=lg[dep[x]-dep[y]];i>=0;--i)
        if(dep[fa[i][x]]>=dep[y])
            x=fa[i][x];
    if(x==y)return x;
    for(int i=lg[dep[x]];i>=0;--i)
        if(fa[i][x]!=fa[i][y])
            x=fa[i][x],y=fa[i][y];
    return fa[0][x];
}
bool inSubT(int x,int y){//x\in T(y)?
    if(y==-1)return 0;
    return dfn[x]>=dfn[y]&&dfn[x]<=dfn[y]+siz[y]-1;
}
vector<array<long long, 2>> police_thief(vector<int> A, vector<int> B, vector<int> D, vector<int> P, vector<int> V1, vector<int> T, vector<int> V2){
    lg[0]=-1;for(int i=1;i<=100000;++i)lg[i]=lg[i>>1]+1;
    n=A.size()+1;
    Q=P.size();
    memset(h,-1,sizeof h);
    for(int i=1,u,v,w;i<=n-1;++i){
        u=A[i-1],v=B[i-1],w=D[i-1];
        ++u,++v;
        add_edge(u,v,w);
        add_edge(v,u,w);
    }
    dep[0]=-1;
    dep[1]=0;
    fa[0][1]=0;
    dfs(1);
    mxf[1]=0;
    dfs2(1);
    vector<array<ll,2>> fans;
    for(int qqq=0;qqq<Q;++qqq){
        s=P[qqq],t=T[qqq];
        v1=V1[qqq],v2=V2[qqq];
        ++s,++t;
        int o=lca(s,t);
        auto check=[&](ll dis1,ll dis2)->bool {
            return Frac(dis1,v1)>Frac(dis2,v2);
        };
        ans.p=0,ans.q=v1;
        if(t!=o){
            ans.p=Dep[s]+Dep[t]-Dep[o]-Dep[o]+mx[t][0].first;
            ans.q=v1;
        }else{
            ans.p=Dep[s]+Dep[t]-Dep[o]-Dep[o]+max((inSubT(s,mx[t][0].second)?mx[t][1].first:mx[t][0].first),mxf[t]);
            ans.q=v1;
        }
        if(v1>v2)ans=min(ans,Frac(Dep[s]+Dep[t]-Dep[o]*2,v1-v2));
        if(v1<=v2){
            if(t!=o){
                int u=t;
                for(int i=lg[dep[u]];i>=0;--i)
                    if(dep[fa[i][u]]>dep[o]&&check(Dep[s]-Dep[o]+Dep[fa[i][u]]-Dep[o],Dep[t]-Dep[fa[i][u]])){
                        ans.p=max(ans.p,f[i][u]+Dep[s]-Dep[o]*2);
                        u=fa[i][u];
                    }
            }
            if(check(Dep[s]-Dep[o],Dep[t]-Dep[o])){
                if(!inSubT(s,mx[o][0].second)&&!inSubT(t,mx[o][0].second))
                    ans.p=max(ans.p,Dep[s]-Dep[o]+mx[o][0].first);
                else if(!inSubT(s,mx[o][1].second)&&!inSubT(t,mx[o][1].second))
                    ans.p=max(ans.p,Dep[s]-Dep[o]+mx[o][1].first);
                else 
                    ans.p=max(ans.p,Dep[s]-Dep[o]+mx[o][2].first);
                ans.p=max(ans.p,mxf[o]+Dep[s]-Dep[o]);
                if(s!=o){
                    int u=s;
                    for(int i=lg[dep[u]];i>=0;--i)
                        if(dep[fa[i][u]]>dep[o]&&
                            !check(Dep[s]-Dep[fa[i][u]],Dep[fa[i][u]]+Dep[t]-Dep[o]-Dep[o])){
                                u=fa[i][u];
                            }
                    for(int i=lg[dep[u]];i>=0;--i){
                        if(dep[fa[i][u]]>dep[o]){
                            chmax(ans.p,g[i][u]+Dep[s]);
                            u=fa[i][u];
                        }
                    }
                }
            }
        }else{
            Frac tmp(0,v1);//关于能拓展出去的链的最大值
            bool fl=0;
            if(t!=o){
                int u=t;
                for(int i=lg[dep[u]];i>=0;--i)
                    if(dep[fa[i][u]]>dep[o]&&
                            check(Dep[s]-Dep[o]+Dep[fa[i][u]]-Dep[o],Dep[t]-Dep[fa[i][u]])&&
                            Frac((Dep[s]-Dep[o]+Dep[fa[i][u]]-Dep[o])-(Dep[t]-Dep[fa[i][u]]),v1-v2)
                                >=max(tmp,Frac(f[i][u]+Dep[s]-Dep[o]*2,v1))){
                        tmp=max(tmp,Frac(f[i][u]+Dep[s]-Dep[o]*2,v1));
                        u=fa[i][u];
                    }
                if(fa[0][u]!=o){
                    ans=max(ans,
                        min(Frac(f[0][u]+Dep[s]-Dep[o]*2,v1),
                        Frac((Dep[s]-Dep[o]+Dep[fa[0][u]]-Dep[o])-(Dep[t]-Dep[fa[0][u]]),v1-v2)));
                }
            }
            if(check(Dep[s]-Dep[o],Dep[t]-Dep[o])){
                Frac val;
                if(!inSubT(s,mx[o][0].second)&&!inSubT(t,mx[o][0].second))
                    val=Frac(Dep[s]-Dep[o]+mx[o][0].first,v1);
                else if(!inSubT(s,mx[o][1].second)&&!inSubT(t,mx[o][1].second))
                    val=Frac(Dep[s]-Dep[o]+mx[o][1].first,v1);
                else 
                    val=Frac(Dep[s]-Dep[o]+mx[o][2].first,v1);
                val=max(val,Frac(mxf[o]+Dep[s]-Dep[o],v1));

                ans=max(ans,
                    min(val,
                    Frac((Dep[s]-Dep[o])-(Dep[t]-Dep[o]),v1-v2)));
                
                if(max(val,tmp)<=Frac((Dep[s]-Dep[o])-(Dep[t]-Dep[o]),v1-v2)){
                    tmp=max(val,tmp);
                    if(s!=o){
                        int u=s;
                        for(int i=lg[dep[u]];i>=0;--i)
                            if(dep[fa[i][u]]>dep[o]&&
                                !check(Dep[s]-Dep[fa[i][u]],Dep[fa[i][u]]+Dep[t]-Dep[o]-Dep[o])){
                                    u=fa[i][u];
                                }
                        if(fa[0][u]!=o){
                            vector<pair<int,int>> a;
                            for(int i=lg[dep[u]];i>=0;--i){
                                if(dep[fa[i][u]]>dep[o]){
                                    a.emplace_back(u,i);
                                    u=fa[i][u];
                                }
                            }
                            reverse(a.begin(),a.end());
                            for(auto i:a){
                                int u=i.first,k=i.second;
                                if(Frac((Dep[s]-Dep[fa[0][u]])-(Dep[fa[0][u]]+Dep[t]-Dep[o]-Dep[o]),v1-v2)
                                    >=max(tmp,Frac(g[k][u]+Dep[s],v1))){
                                        tmp=max(tmp,Frac(g[k][u]+Dep[s],v1));
                                    }
                                else{
                                    while(k>0){
                                        int v=fa[k-1][u];
                                        if(Frac((Dep[s]-Dep[v])-(Dep[v]+Dep[t]-Dep[o]-Dep[o]),v1-v2)
                                            >=max(tmp,Frac(g[k-1][v]+Dep[s],v1))){
                                                tmp=max(tmp,Frac(g[k-1][v]+Dep[s],v1));
                                                u=u;
                                                --k;
                                            }
                                        else{
                                            u=v;
                                            --k;
                                        }
                                    }
                                    ans=max(ans,min(Frac((Dep[s]-Dep[fa[0][u]])-(Dep[fa[0][u]]+Dep[t]-Dep[o]-Dep[o]),v1-v2),Frac(g[0][u]+Dep[s],v1)));
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            ans=max(ans,tmp);
        }
        ll g=__gcd(ans.p,ans.q);
        ans.p/=g,ans.q/=g;
        fans.emplace_back(array<ll,2>{ans.p,ans.q});
    }
    return fans;
}
// int main(){
// 	int N, Q;
// 	scanf("%d %d", &N, &Q);
// 	std::vector<int> A(N - 1), B(N - 1), D(N - 1), P(Q), T(Q), V1(Q), V2(Q);
// 	for(int i = 0; i < N - 1; i++){
// 		scanf("%d %d %d", &A[i], &B[i], &D[i]);
// 	}
// 	for(int i = 0; i < Q; i++){
// 		scanf("%d %d %d %d", &P[i], &V1[i], &T[i], &V2[i]);
// 	}
// 	std::vector<std::array<long long, 2>> C = police_thief(A, B, D, P, V1, T, V2);
// 	if((int)C.size() != Q){
// 		puts("Wrong size");
// 		return 0;
// 	}
// 	for(int i = 0; i < Q; i++) printf("%lld %lld\n", C[i][0], C[i][1]);
// 	return 0;
// }
```

---


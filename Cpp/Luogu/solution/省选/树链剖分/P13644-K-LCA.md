# K-LCA

## 题目背景

成本越低，赚的越多！

## 题目描述

T 国由 $n$ 座城市组成，首都在 $1$ 号城市，有 $(n-1)$ 条道路连接着这些城，且所有城市都可以通过这些道路到达首都。

有 $q$ 轮旅行活动，第 $i$ 次旅游会有一个参数 $(l_i,r_i)$，每次都有 $k$ 个人，他们每个人都会在编号在 $[l_i,r_i]$ 的城市中选择一个城市作为出发点。为了让每个人都有独处空间，任意两人不会选择同一个城市。

然后他们开始进行旅行。由于靠近首都的城市更高级，所以旅行者会向首都方向移动。

最终他们会在一个城市会聚，然后旅行结束。旅游公司没有足够经费让旅行者去更高级的城市，所以旅游公司会让他们会聚的城市离首都尽可能远。

现在旅游公司问你，他们会聚的地方，离首都距离最远是多少？两个城市之间的距离定义为最短路径上城市的个数（包括路径端点的两个城市）。

## 说明/提示

**本题有捆绑测试**，每个子任务均为 $20$ 分。

| 子任务编号 | $n$ | $q$ | 特殊性质 | 时间限制 | 子任务依赖 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| $0$ | $10^4$ | $10^4$ | 无 | 3s | 无 |
| $1$ | $2\times10^4$ | $5\times10^4$ | 无 | 3s | $0$ |
| $2$ | $5\times10^4$ | $5\times10^4$ | 无 | 5s | $1$ |
| $3$ | $10^5$ | $10^5$ | **有** | 7s | 无 |
| $4$ | $10^5$ | $10^5$ | 无 | 7s | $2,3$ |

特殊性质：树的形态是以 $1$ 结点为链顶的一条链

对于 $100\%$ 的数据，$n\le 10^5,q\le10^5,1< k\le n,r-l+1\ge k$。

## 样例 #1

### 输入

```
5 7 2
1 2
1 3
2 4
2 5
1 3
1 4
1 5
2 4
2 5
3 5
4 5
```

### 输出

```
1
2
2
2
2
2
2
```

# 题解

## 作者：zhenghanyun (赞：10)

据说有纯根号做法，反正我不会。

来发与众不同的题解。

对子树大小进行分治，阈值为 $B$，记 $s_u$ 表示子树 $u$ 的大小。

- 对于 $s_u > B$

  对于询问二分答案，`check` 相当于查询一层中是否存在子树内 $[l, r]$ 出现次数 $\ge k$ 的结点。

  暴力枚举该层的每个结点，拍到 `dfn` 序上使用持久化线段树查询。

  树上每一层 $s_u > B$ 的结点个数是 $O(\frac{n}{B})$ 的，这部分时间复杂度 $O(\frac{nq}{B} \log ^ 2 n)$。

- 对于 $s_u \le B$

  扫描线右端点，维护每个左端点的答案，扫描到 $r$ 时暴力往上跳枚举大小不超过 $B$ 的祖先。

  对于每个祖先用双指针更新此时可以发生贡献的最小左端点，做一次前缀 `chkmax`。

  `chkmax` 进行 $\sum \limits_{s_u \le B} s_u = O(nB)$ 次，用分块平衡复杂度，这部分时间复杂度 $O(nB + q \sqrt n)$。

取 $B = \sqrt n \log n$，总时间复杂度 $O((n + q) \sqrt n \log n)$。

这个做法常数很小，没卡常最慢点跑了 $0.5$ 秒左右，加上一些剪枝跑到了 $0.3$ 秒。

有个问题是这个做法空间太大了，复杂度与时间相同，块长开到 $5000$ 以上可能会 MLE。

可能有做法可以减小空间，懒得想了。

**Warning：下半部分我没实现过，因为太懒了，应该是对的。**

- Bonus $1$：在线 $O((n + q) \sqrt n \log n)$

  注意到上文中需要离线的部分只有 $s_u \le B$ 的扫描线。

  可以用 fat node 的方式持久化分块数组，这样查询时多一个 $O(\log n)$ 的时间复杂度。

  这部分复杂度变为 $O(nB + q \sqrt n \log n)$，不影响总时间复杂度。

- Bonus $2$：在线 $O((n + q) \sqrt {n \log n})$

  持久化线段树是可以被 $O(n \sqrt n) \sim O(1)$ 的二维分块替代的，仍然可以做到在线查询。

  这样 $s_u > B$ 部分被做到了 $O(\frac{nq}{B} \log n)$，理论上可以平衡出 $O((n + q) \sqrt {n \log n})$ 的复杂度。

  但是我们在 Bonus $1$ 中引入了 $O(q \sqrt n \log n)$ 的复杂度来维护持久化数组。

  经典套路，使用两次分块可以把这部分做到 $O(q n ^ \frac{1}{3} \log n)$ 的时间复杂度。

  这样我们就完成了 $O((n + q) \sqrt {n \log n})$ 的在线做法。

代码鸽了。

---

## 作者：sheep65536 (赞：7)

# 算法 $0$

每次询问爆搜，复杂度可做到 $O(q\binom nk)$。

期望得分 $0$ 分。

# 算法 $1$

首先发现，选 $k$ 个 dfn 序在 $[l,r]$ 的 dfn 排名连续是最优的。

将点按照 dfn 排序，枚举最小 dfn 可以 $O(n^2q\log n)$ 或 $O(n^2q)$。

期望得分 $0$ 分。

# 算法 $2$

我们有 noip2024 T4 的结论：多个点的 $\operatorname{lca}$ 深度为相邻两点的 $\operatorname{lca}$ 深度的最小值。

这样优化算法 $1$ 可以 $O(nq\log n)$ 或 $O(nq)$。

期望得分 $20$ 分。

# 算法 $3$

对于每次询问，我们将编号在 $[l,r]$ 之间的点标记为 $1$，然后求子树和，找深度最大的点满足字数和 $\ge k$。

时间复杂度 $O(nq)$

期望得分 $20$ 分。

# 算法 $4$

考虑链的形态，记录每个点的深度 $d_u$，查询即是 $[l,r]$ 中的 $k$ 大值，主席树即可。

时间复杂度 $O(q\log n)$。

结合算法 $2$ 或算法 $3$，期望得分 $40$ 分。

# 算法 $5$

套上回滚莫队。

考虑加入一个点 $u$，如果更新答案一定是 $u$ 的祖先。

用树上数据结构维护子树和，用倍增法跳 $u$ 的祖先，找到更新答案的点。

复杂度 $O(n\sqrt q\log^2 n)$。

结合算法 $4$，依常数分别有 $40\sim80$ 分。

# 算法 $6$

考虑回滚莫队的过程，向右扩展时发现答案只会增加 $O(n)$ 次，每次加点可以一直往父亲跳，每次加点均摊复杂度 $O(\log n)$。

而向左扩展时这样均摊复杂度不对，每次加点还是 $O(\log^2n)$。

平衡块长可做到 $O(n\sqrt q\log^{1.5}n)$。

结合算法 $4$，依常数分别有 $60\sim 100$ 分。

# 算法 $7$

考虑加点 $O(\log n)$ 的算法。

发现 $O(\log^2 n)$ 的瓶颈在于倍增时都需要 $O(\log n)$ check。

考虑避免 $O(\log n)$ check。有如下算法：

- 进行一个奇怪的链剖分：对于子树 $u$，dfs 的顺序是：重子树 $\to$ 轻子树 $\to$ $u$。
- 对于 $u$，记录子树内 dfn 的最小值 $l_u$ 和最大值 $r_u$。
- 显然，对于一条重链的每个点，$l$ 相等。
- 对于链顶，记录 $c_u$ 表示树和。
- 每次加点时暴力跳链顶更新 $c$。
- 加入点 $u$ 时，暴力跳链顶。若当前链顶 $v$ 的 $c_v\ge k$，说明最深合法祖先在 $v$ 的重链上。
- 由于重链上的点 $l$ 相等，我们可以在数据结构上二分出合法点的 $r$ 的下界 $R$。
- 然后在重链上由上到下倍增，找到最深的点满足 $r\ge R$，更新答案。

时间复杂度 $O(n\sqrt q\log n)$。

常数较小即可通过本题。

---

## 作者：Sexy_Foxy (赞：3)

## 前言

此人非常懒，本不想写这题，但 ~~这出题团竟然有福瑞哎！~~ 为准备杂题，怒冲一个晚上和一个早上，故有此题解。

## 题意

给定一棵 $n$ 个节点的树，有 $q$ 个询问，第 $i$ 个询问求 $[l_i,r_i]$ 区间中选 $k$ 个节点，求这 $k$ 个节点所有可能的 LCA 中最大的深度。

## 切入题目

首先单单从 LCA 考虑这题是很难做的，不妨先看看数据范围。

$n≤10^5,q≤10^5,1<k≤n$，时限 $7$ 秒。

问题涉及区间问题，再加上 $n$ 的范围并不大，启发我们从莫队入手这个问题，先套上个 $O(n \sqrt n)$ 的复杂度，再考虑 $7$ 秒时限，大概率要再套个 $O(\log n)$ 的数据结构优化，整体时间复杂度大概在 $O(n \sqrt n \log n)$ 的范围。

##### 注：这里因为 $n,q$ 同阶所以时间复杂度不区分 $n,q$。

## 实现

发现 LCA 比较难做，可以稍加转换。如果一个节点可以作为公共 LCA，其子树内必然包含 $[l_i,r_i]$ 中的 $k$ 个节点，而且如果一个节点的子树中包含 $[l_i,r_i]$ 中的 $k$ 个节点，其必然是一个公共 LCA 为起点到根节点的路径上的点。

举个例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/8eafs248.png)

假设 $D$ 是一个公共 LCA，则 $A,B$ 两个节点也满足其子树中包含 $[l_i,r_i]$ 中的 $k$ 个结点。

我们设子树 $u$ 中包含 $[l_i,r_i]$ 中的节点个数为 $sum_u$ 个，明显一条从叶子节点到根节点的路径上 $sum$ 具有单调性（如上图，有 $sum_H≤sum_D≤sum_B≤sum_A$）。这个性质待会有用。

考虑莫队过程中加点过程，加入一个节点后其只会对这个节点到根节点的路径上的点的 $sum$ 值产生 $+1$ 的贡献，而且如果会更新答案，更优的公共 LCA 也只会在这条路径上。

所以加入一个点后，先对其到根节点的路径上的所有点 $sum$ 值全 $+1$，然后找到最深的节点满足 $sum_u≥k$ ，更新答案。

如果这样暴力做最坏是会到 $O(n)$ 的，就算我们更新 $sum$ 值时用 dfs 序和数据结构维护将更新减到 $O(\log n)$，查询答案还是会超时，这时就需要用到刚才的性质。由于我们查询答案的路径上的 $sum$ 值具有单调性，所以可以树上倍增求出该路径上深度最小且满足 $sum$ 值 $<k$ 的节点，其父亲节点的深度就是我们需要找的答案（这个节点不一定是公共 LCA，但一定满足作为公共 LCA 的所有条件），最后和将先前答案和这个答案取个最大值即可。

#### 实现这个倍增的代码：
```c++
int solve(int u){ //dfn[u]是dfs序，BIT是数据结构（树状数组）
	if(BIT.query(dfn[u]+siz[u]-1)-BIT.query(dfn[u]-1)>=k) return u;
	for(int i=17;~i;i--){
		if(fa[u][i]&&BIT.query(dfn[fa[u][i]]+siz[fa[u][i]]-1)-BIT.query(dfn[fa[u][i]]-1)<k) u=fa[u][i];
	}
	return fa[u][0];
}
```

接下来考虑删除一个点，发现删除掉这个点后更新答案很困难，所以直接上回滚莫队。

但是聪明的你发现莫队、数据结构、倍增，加起来时间复杂度到 $O(n \sqrt n \log^2 n)$ 的时间复杂度，只能拿 $80$ pts，但我尝试交了一份直接 AC 了（

### Code($80$ pts)：

```c++
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define uint unsigned int
#define i128 __int128
#define ld long double
#define fir first
#define sec second
#define pii pair<int,int>
#define pll pair<ll,ll>
#define ls(x) (x<<1)
#define rs(x) (x<<1|1)
#define lowbit(x) (x&-x)
using namespace std;
char buf[1<<25],*p1=buf,*p2=buf;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<25,stdin),p1==p2)?EOF:*p1++)
template<class T>
T read(T&x){
	x=0;bool f=false;char ch=getchar();
	while(!isdigit(ch)) f|=!(ch^'-'),ch=getchar();
	while(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	if(f) x=-x;return x;
}
int reads(char*s){
	char ch=getchar();int len=0;
	while(ch==' '||ch=='\n'||ch=='\r') ch=getchar();
	while(ch!=' '&&ch!='\n'&&ch!=EOF&&ch!='\r') s[len++]=ch,ch=getchar();
	s[len]='\0';return len;
}
template<class T>
void write(T x){
	if(x<0) putchar('-'),x=-x;
	if(x<10) putchar(x+'0');
	else write(x/10),putchar(x%10+'0');
}
template<class T>
inline void writes(T x,int l,int r){for(int i=l;i<=r;i++) putchar(x[i]);}
template<class T>
inline void write(T x,char ch){write(x),putchar(ch);}
const int N=1e5+10,M=21;
struct chain_forward_star{int nxt,to;}edge[N<<1];
struct Que{int l,r,id;}furry[N];
struct fenwick_tree{
	int tree[N],n;
	inline void size(int x){n=x;}
	void update(int x,int val){for(int i=x;i<=n;i+=lowbit(i)) tree[i]+=val;}
	int query(int x){int res=0;for(int i=x;i;i-=lowbit(i)) res+=tree[i];return res;}
}BIT;
int fa[N][M],head[N],bl[N],br[N],id[N],ans[N],dfn[N],siz[N],dep[N],len,n,k,q,cnt,dcnt,ecnt;
inline void add(int u,int v){edge[++ecnt]={head[u],v},head[u]=ecnt;}
inline bool cmp(Que x,Que y){return id[x.l]==id[y.l]?x.r<y.r:id[x.l]<id[y.l];}
void dfs(int u,int pre){
	fa[u][0]=pre,dfn[u]=++dcnt,dep[u]=dep[pre]+1,siz[u]=1;
	for(int i=1;i<18;i++) fa[u][i]=fa[fa[u][i-1]][i-1];
	for(int i=head[u];i;i=edge[i].nxt){
		int v=edge[i].to;
		if(v!=pre) dfs(v,u),siz[u]+=siz[v];
	}
}
int solve(int u){
	if(BIT.query(dfn[u]+siz[u]-1)-BIT.query(dfn[u]-1)>=k) return u;
	for(int i=17;~i;i--){
		if(fa[u][i]&&BIT.query(dfn[fa[u][i]]+siz[fa[u][i]]-1)-BIT.query(dfn[fa[u][i]]-1)<k) u=fa[u][i];
	}
	return fa[u][0];
}
int main(){
	read(n),read(q),read(k),len=sqrt(n);
	for(int x,y,t=n;--t;){
		read(x),read(y);
		add(x,y),add(y,x);
	}
	for(int i=1;i<=n;i++) id[i]=(i-1)/len+1;
	cnt=id[n];
	for(int i=1;i<=cnt;i++) bl[i]=br[i-1]+1,br[i]=(i==cnt?n:i*len);
	for(int i=1;i<=q;i++) read(furry[i].l),read(furry[i].r),furry[i].id=i;
	sort(furry+1,furry+q+1,cmp),dfs(1,0),BIT.size(n);
	int l=1,r=0,res=0,cur=0;
	for(int i=1;i<=q;i++){
		if(id[furry[i].l]==id[furry[i].r]){
			res=0;
			for(int j=l;j<=r;j++) BIT.update(dfn[j],-1);
			l=1,r=0;
			for(int j=furry[i].l;j<=furry[i].r;j++) BIT.update(dfn[j],1);
			for(int j=furry[i].l;j<=furry[i].r;j++){
				int p=solve(j);
				if(dep[res]<dep[p]) res=p;
			}
			for(int j=furry[i].l;j<=furry[i].r;j++) BIT.update(dfn[j],-1);
			ans[furry[i].id]=dep[res];continue;
		}
		int now=id[furry[i].l];
		if(now!=cur){
			res=0;
			for(int j=l;j<=r;j++) BIT.update(dfn[j],-1);
			l=br[now],r=l-1,cur=now;
		}
		while(r<furry[i].r){
			r++,BIT.update(dfn[r],1);
			int p=solve(r);
			if(dep[res]<dep[p]) res=p;
		}
		int pos=l,tmp=0;
		while(furry[i].l<pos){
			pos--,BIT.update(dfn[pos],1);
			int p=solve(pos);
			if(dep[tmp]<dep[p]) tmp=p;
		}
		while(pos<l) BIT.update(dfn[pos],-1),pos++;
		ans[furry[i].id]=max(dep[res],dep[tmp]);
	}
	for(int i=1;i<=q;i++) write(ans[i],'\n');
	return 0;
}
```

卡掉这份代码的数据也十分好造，只要让倍增每次都跑满 $17$ 次就可以了，大概就是搞一条链出来然后卡询问区间在一个块内，之后每次询问新加点答案都是当前这个点的父亲节点的深度。

~~然后这题就做完了xwx~~

完结撒花~

## 优化

作为一名好学生，当然不能因为代码没被卡就当过了，一定要把那只多出来的 $\log n$ 踹掉！

分析时间复杂度发现，瓶颈在于每次查询答案都需要 $O(\log n)$ 去得到 $sum$ 值，倍增与莫队方面都比较难入手，至于数据结构......

我们树状数组有一个叫 **二进制查询优化** 的东西：

```c++
int find_nxt(int n,int k){ //tree是树状数组
	int res=0,pos=0;
	for(int i=17;~i;i--){
		int p=pos+(1<<i);
		if(p<=n&&res+tree[p]<k) pos=p,res+=tree[p];
	}
	return pos;
}
```

这段代码实现了 $O(\log n)$ 求最大的 $pos$ 满足 $pos$ 的前缀和 $<k$，且 $pos≤n$。

如果稍加修改：

```c++
struct fenwick_tree{
	int tree[N],n;
	inline void size(int x){n=x;}
	void update(int x,int val){for(int i=x;i<=n;i+=lowbit(i)) tree[i]+=val;}
	int query(int x){int res=0;for(int i=x;i;i-=lowbit(i)) res+=tree[i];return res;}
	int find_nxt(int x,int limit,int k){ //x是左端点，limit是右端点。
		int res=-query(x-1),pos=0;
		for(int i=17;~i;i--){
			int p=pos+(1<<i);
			if(p<=limit&&res+tree[p]<k) pos=p,res+=tree[p];
		}
		return pos;
	}
}BIT;
```

这就可以求出一条 $[l,r]$ 中最大的 $pos$ 满足 $l≤pos≤r$ 且 $l$ 到 $r$ 的前缀和 $<k$。

有了这么一个东西，我们自然希望查询答案时那条路径上的 dfs 序是连续的，希望是美好的，现实根本做不到，怎么办呢？

我们可以将时间复杂度均摊一下，进行树链剖分，对于每条链记录其链顶节点的 $sum$ 值，记为 $C$，加入点后每次暴力从下往上跳更新每条链的 $C$ 值，若遇到第一条链的 $C$ 值 $≥k$，则根据前面单调性的性质，答案一定在这条链上。

大概是这样：
```c++
void update(int u,int&res){
	int idx=u;
	BIT.update(dfn[u],1);
	while(u){
		C[top[u]]++; //top[u]就是链顶节点
		if(C[top[u]]>=k){query(top[u],res),u=fa[top[u]];break;}
		u=fa[top[u]];
	}
	delp[idx]=u; //用于之后删点操作
}
```

这样，我们既可以满足在 $O(\log n)$ 时间内找到对应的链，也可以满足那条链上的点可以满足连续的性质。

但是如果按正常的树剖标 dfs 序，一个点的 $sum$ 值是 ```BIT.query(dfn[u]+siz[u]-1)-BIT.query(dfn[u]-1)```，很难满足连续，所以就要用到官解的神秘的树剖标 dfs 序方法。

先从一个子树的重儿子那棵子树开始标，然后再到其他轻儿子，最后到当前节点。

这样做的好处就是同一条树剖出的链上的节点是从下往上递增的，且满足 $sum$ 的值就是 ```BIT.query(dfn[u])-BIT.query(dfn[v]-1)```，其中 $u$ 为链上节点，$v$ 为链上最深的点。

因为这个点所在的树链的链尾一定是这个点子树中 dfs 序最小的，而这个点子树中的点 dfs 序都比这个点小，所以他子树中的点给的贡献这个点都能吃满。

还有细节！设一条剖出来的树链最深的节点为 $v$，链顶为 $u$，则在这条链上做二进制查询优化后得到的 dfs 序不一定是这条树链上的 dfs 序，但是没有关系，假设二进制查询优化得到的答案为 $dfn_{pos}$（注意 $pos$ 是一个节点），则在树链上找到最接近且 dfs 序不小于 $dfn_{pos}$ 的节点，设这个节点为 $p$，这个可以二分，$p$ 的深度就是我们要的答案。

为什么是对的？因为虽然可能 $sum_p$ 的值并非一定小于链上的 dfs 序比他大的点（可能是兄弟），但是我们在树状数组上得到的 ```BIT.query(dfn[u])``` 是具有单调性的，而我们减去的都是 ```BIT.query(dfn[v]-1)``` 这个值，所以整体而言满足单调性。

大概是这样实现的：
```c++
int find_pos(int x,int val){ //num[x]记录的是链顶为x的树链上的所有点的dfs序，是个pair类型，第一个值是dfs序，第二个是节点
	int l=0,r=num[x].size()-1,res=num[x].size();
	while(l<=r){
		int mid=(l+r)>>1;
		if(num[x][mid].fir>=val) res=mid,r=mid-1;
		else l=mid+1;
	}
	return num[x][res].sec;
} 
inline void query(int u,int&res){ //st[u],ed[u]是链顶为u的树链上的dfs序的起点和终点，即上文所说的dfn[v]和dfn[u]，res是要被更新的答案。
	int p=BIT.find_nxt(st[u],ed[u]-1,k);
	if(!p) p=st[u]-1;
	p=find_pos(u,p+1),res=max(res,dep[p]);
}
```

然后？然后就没有然后了，这种做法时间复杂度 $O(n \sqrt n \log n)$，代码细节可能有点多。

### Code($100$pts)
```
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define uint unsigned int
#define i128 __int128
#define ld long double
#define fir first
#define sec second
#define pii pair<int,int>
#define pll pair<ll,ll>
#define ls(x) (x<<1)
#define rs(x) (x<<1|1)
#define lowbit(x) (x&-x)
using namespace std;
char buf[1<<25],*p1=buf,*p2=buf;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<25,stdin),p1==p2)?EOF:*p1++)
template<class T>
T read(T&x){
	x=0;bool f=false;char ch=getchar();
	while(!isdigit(ch)) f|=!(ch^'-'),ch=getchar();
	while(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	if(f) x=-x;return x;
}
int reads(char*s){
	char ch=getchar();int len=0;
	while(ch==' '||ch=='\n'||ch=='\r') ch=getchar();
	while(ch!=' '&&ch!='\n'&&ch!=EOF&&ch!='\r') s[len++]=ch,ch=getchar();
	s[len]='\0';return len;
}
template<class T>
void write(T x){
	if(x<0) putchar('-'),x=-x;
	if(x<10) putchar(x+'0');
	else write(x/10),putchar(x%10+'0');
}
template<class T>
inline void writes(T x,int l,int r){for(int i=l;i<=r;i++) putchar(x[i]);}
template<class T>
inline void write(T x,char ch){write(x),putchar(ch);}
const int N=1e5+10,M=21;
struct chain_forward_star{int nxt,to;}edge[N<<1];
struct Que{int l,r,id;}furry[N];
struct fenwick_tree{
	int tree[N],n;
	inline void size(int x){n=x;}
	void update(int x,int val){for(int i=x;i<=n;i+=lowbit(i)) tree[i]+=val;}
	int query(int x){int res=0;for(int i=x;i;i-=lowbit(i)) res+=tree[i];return res;}
	int find_nxt(int x,int limit,int k){
		int res=-query(x-1),pos=0;
		for(int i=17;~i;i--){
			int p=pos+(1<<i);
			if(p<=limit&&res+tree[p]<k) pos=p,res+=tree[p];
		}
		return pos;
	}
}BIT;
int fa[N],dfn[N],dep[N],siz[N],son[N],top[N],C[N],st[N],ed[N],dcnt;
int head[N],ecnt;
int bl[N],br[N],id[N],len,cnt;
int ans[N],delp[N],n,q,k;
vector<pii>num[N];
inline void add(int u,int v){edge[++ecnt]={head[u],v},head[u]=ecnt;}
inline bool cmp(Que x,Que y){return id[x.l]==id[y.l]?x.r<y.r:id[x.l]<id[y.l];}
void dfs1(int u,int pre){
	dep[u]=dep[pre]+1,siz[u]=1,fa[u]=pre;
	for(int i=head[u];i;i=edge[i].nxt){
		int v=edge[i].to;
		if(v==pre) continue;
		dfs1(v,u),siz[u]+=siz[v];
		if(siz[son[u]]<siz[v]) son[u]=v;
	}
}
void dfs2(int u,int id){
	top[u]=id;
	if(son[u]) dfs2(son[u],id);
	for(int i=head[u];i;i=edge[i].nxt){
		int v=edge[i].to;
		if(v!=fa[u]&&v!=son[u]) dfs2(v,v);
	}
	dfn[u]=++dcnt,st[id]=min(st[id],dcnt),ed[id]=max(ed[id],dcnt);
}
int find_pos(int x,int val){
	int l=0,r=num[x].size()-1,res=num[x].size();
	while(l<=r){
		int mid=(l+r)>>1;
		if(num[x][mid].fir>=val) res=mid,r=mid-1;
		else l=mid+1;
	}
	return num[x][res].sec;
} 
inline void query(int u,int&res){
	int p=BIT.find_nxt(st[u],ed[u]-1,k);
	if(!p) p=st[u]-1;
	p=find_pos(u,p+1),res=max(res,dep[p]);
}
void update(int u,int&res){
	int idx=u;
	BIT.update(dfn[u],1);
	while(u){
		C[top[u]]++;
		if(C[top[u]]>=k){query(top[u],res),u=fa[top[u]];break;}
		u=fa[top[u]];
	}
	delp[idx]=u;
}
void restore(int u){
	int idx=u;
	BIT.update(dfn[u],-1);
	while(u!=delp[idx]) C[top[u]]--,u=fa[top[u]];
}
int main(){
	read(n),read(q),read(k),len=sqrt(n);
	for(int x,y,t=n;--t;){
		read(x),read(y);
		add(x,y),add(y,x);
	}
	for(int i=1;i<=n;i++) id[i]=(i-1)/len+1,st[i]=n+1;
	cnt=id[n];
	for(int i=1;i<=cnt;i++) bl[i]=br[i-1]+1,br[i]=(i==cnt?n:i*len);
	for(int i=1;i<=q;i++) read(furry[i].l),read(furry[i].r),furry[i].id=i;
	sort(furry+1,furry+q+1,cmp),BIT.size(n),dfs1(1,0),dfs2(1,1);
	for(int i=1;i<=n;i++) num[top[i]].emplace_back(make_pair(dfn[i],i));
	for(int i=1;i<=n;i++) sort(num[i].begin(),num[i].end());
	int l=1,r=0,res=0,cur=0;
	for(int i=1;i<=q;i++){
		if(id[furry[i].l]==id[furry[i].r]){
			for(int j=l;j<=r;j++) restore(j);
			l=1,r=0,res=0;
			for(int j=furry[i].l;j<=furry[i].r;j++) update(j,res);
			ans[furry[i].id]=res;
			for(int j=furry[i].l;j<=furry[i].r;j++) restore(j);
			continue;
		}
		int now=id[furry[i].l];
		if(now!=cur){
			for(int j=l;j<=r;j++) restore(j);
			l=br[now],r=l-1,cur=now,res=0;
		}
		while(r<furry[i].r) update(++r,res);
		int pos=l,tmp=0;
		while(furry[i].l<pos) update(--pos,tmp);
		ans[furry[i].id]=max(res,tmp);
		while(pos<l) restore(pos++);
	}
	for(int i=1;i<=q;i++) write(ans[i],'\n');
	return 0;
}
```

但是我惊奇地发现这之比我两只 $\log$ 快 $1$ 秒！ qwq

## 后记

这题的树链剖分方法是一大亮点，值得一做。

---

## 作者：chenbs (赞：3)

为了庆祝 $O(n \sqrt q \log^2 n)$ 直接卡过，来发一篇题解。

---

题目可以转换为：找一个深度最大的节点，他的子树中所含的在 $[l,r]$ 内的节点数量 $\ge k$。

先考虑暴力做法：由于一个子树内节点的 dfs 序是连续的，我们可以给节点赋点权，当节点编号 $\in [l,r]$ 时点权为 $1$，否则为 $0$，然后维护**子树点权和**（推荐树状数组，常数小）。每次询问尝试所有节点，时间复杂度 $O(qn\log n)$。

然后我们会发现，可以先把询问离线下来再用**回滚莫队**（只增加）来处理，省去了大量重复计算。

考虑莫队时如何扩展一个节点。设这个新节点为 $u$。首先在树状数组上单点加 $1$，然后尝试用 $u$ 及其祖先来更新答案。注意到跳父亲时，子树权值单调不降，所以直接倍增找即可。

时间复杂度最坏 $O(n \sqrt q \log^2 n)$，但事实上常数很小，注意细节还是能过的。

一些小技巧：

+ 可以尝试调块长来平衡时间。

+ 在倍增更新答案时，如果深度已经小于原来的答案，可以直接 `break`。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100005, B=300;
int n,q,k;
vector<int> G[N];
int t[N];
#define lowbit(x) (x&-x)
void add(int x, int v) {
	while(x<=n) t[x]+=v, x+=lowbit(x);
}
int query(int x) {
	int s=0;
	while(x) s+=t[x], x-=lowbit(x);
	return s;
}
int T,fa[N][17],sz[N],dfn[N],dep[N];
void dfs(int x) {
	for(int i=1; i<17; i++) fa[x][i]=fa[fa[x][i-1]][i-1];
	sz[x]=1, dfn[x]=++T;
	for(auto &y:G[x]) {
		if(y==fa[x][0]) continue;
		fa[y][0]=x, dep[y]=dep[x]+1, dfs(y);
		sz[x]+=sz[y];
	}
}
int getsum(int x) {
	return query(dfn[x]+sz[x]-1)-query(dfn[x]-1);
}
void back(int x, int y) {
	for(int i=x; i<=y; i++) add(dfn[i], -1);
}
struct node {
	int l,r,id;
	bool operator < (const node& y) const {
		int xb=l/B, yb=y.l/B;
		return xb==yb ? r<y.r : xb<yb;
	}
} a[100005];
int output[100005];
int addnode(int x, int cut) {
	add(dfn[x], 1);
	if(getsum(x)>=k) return dep[x];
	for(int j=16; j>=0; j--) {
		if(fa[x][j] && getsum(fa[x][j])<k) {
			x=fa[x][j];
			if(dep[x]-1<=cut) break;
		}
	}
	return dep[x]-1;
}
int main() {
	scanf("%d%d%d",&n,&q,&k);
	for(int i=1; i<n; i++) {
		int u,v;
		scanf("%d%d",&u,&v);
		G[u].push_back(v), G[v].push_back(u);
	}
	dep[1]=1, dfs(1);
	for(int i=1; i<=q; i++) scanf("%d%d",&a[i].l,&a[i].r), a[i].id=i;
	sort(a+1,a+1+q);
	int cur=-1,l,r,ans;
	for(int i=1; i<=q; i++) {
		if(cur!=a[i].l/B) {
			memset(t,0,sizeof t);
			l=(a[i].l/B+1)*B-1, r=l, ans=1;
			cur=a[i].l/B;
		}
		if(cur==a[i].r/B) {
			int ans2=1;
			for(int j=a[i].l; j<=a[i].r; j++) ans2=max(ans2, addnode(j, ans2));
			back(a[i].l, a[i].r);
			output[a[i].id]=ans2;
		} else {
			while(r<a[i].r) ans=max(ans, addnode(++r, ans));
			int ans2=1;
			for(int j=a[i].l; j<=l; j++) ans2=max(ans2, addnode(j, ans2));
			back(a[i].l, l);
			output[a[i].id]=max(ans,ans2);
		}
	}
	for(int i=1; i<=q; i++) printf("%d\n",output[i]);
	return 0;
}
```

---

## 作者：BreakPlus (赞：1)

~~这是一个在线的做法，跑得比较满。目前链的 subtask 还没卡过，是特判过的。~~

**UPD：利用本题可以离线的性质卡过了，现在下面放的代码能 AC。说明见文末。**

考虑对点的编号进行序列分块，令块长为 $B$。每次询问 $[l,r]$ 时，将两端散块部分先不考虑，留下整块的部分（设整块的编号区间为 $[L,R]$），直接用预处理的答案 $f(L,R)$。

如果散块点对答案产生影响，选取的子树显然至少包含一个散块点。

因此枚举一个散块的点，在从它到根的链上进行二分。check 的时候相当于查询一个子树内（也就是 dfn 序的一个区间内）有多少值在 $[l,r]$ 之间的数，用持久化线段树维护即可。

因此散块部分的时间复杂度为 $\mathcal{O}(qB\log^2n)$。

----

现在需要预处理 $f(L,R)$。枚举一个点 $u$，令 $g_i$ 表示编号为 $i$ 的块中有多少个点在子树 $u$ 内。

假设我们维护出了这个桶 $g$，显然可以跑一个 $\mathcal{O}(\dfrac{n}{B})$ 的双指针。总复杂度 $\mathcal{O}(\dfrac{n^2}{B})$。

维护 $g$ 是容易的，比如 DSU on tree 就可以 $\mathcal{O}(n \log n)$ 维护。但是 $f$ 数组占用了 $\mathcal{O}(\dfrac{n^2}{B^2})$ 的空间，128MB 很紧，不能允许我们再跑一个树上 dfs。

没关系，我们可以莫队 $\mathcal{O}(n \sqrt{n})$ 维护，这样不占额外空间。

----

平衡一下这两个东西，取 $B = \dfrac{n}{\sqrt{q} \log n}$，总时间复杂度 $\mathcal{O}(n\sqrt{q}\log n)$。

实测 $B=15$ 比较快。



```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<ll,ll> P;
#define fi first
#define se second
#define mkp make_pair
#define pb emplace_back
#define popcnt __builtin_popcountll
const ll mod = 998244353;
inline ll read(){
	ll x=0, f=1; char ch=getchar();
	while(ch<'0' || ch>'9') { if(ch=='-') f=-1; ch=getchar(); }
	while(ch>='0' && ch<='9') x=x*10+ch-'0', ch=getchar();
	return x*f;
}
#pragma GCC target("avx2,bmi,bmi2,lzcnt,popcnt")
const int B = 15;
int n,q,k;
struct Edge{
	int to,nxt;
}e[200005];
int hd[100005],tot,bl[100005],dep[100005],dfn[100005],out[100005],tim;
int f[23000005],sum[6670],lf[100005],rh[100005],seq[100005],st[6670];

const int L = 320;
int bel[100005];
inline int cid(int x,int y){ 
	if(x>y) return 0; return st[x]+y;
}
inline void add(int u,int v){
	e[++tot].to=v;
	e[tot].nxt=hd[u]; hd[u]=tot;
}
int jp[17][100005];
inline void pre(int x){
	dep[x]=dep[jp[0][x]]+1;
	dfn[x]=(++tim); seq[tim]=x;
	for(int i=hd[x];i;i=e[i].nxt){
		int y=e[i].to; if(y==jp[0][x]) continue;
		jp[0][y]=x;
		pre(y);
	}
	out[x]=tim;
}
struct BIT{
	int c[100005];
	void upd(int x,int w){
		while(x <= n){
			c[x] += w;
			x += (x & -x);
		}
	}
	int qry(int x){
		int ret = 0;
		while(x){
			ret += c[x];
			x -= (x & -x);
		}
		return ret;
	}
}bit;
inline void chkmax(int &x,int y){ x=(x<y?y:x); }
inline bool check(int x){
	return bit.qry(out[x])-bit.qry(dfn[x]-1)>=k;
}
inline int solve(int x){
	int ret=0;
	for(int i=16;i>=0;i--){
		int w=jp[i][x];
		if(!w) continue;
		if(check(w)) chkmax(ret,dep[w]);
		else x=w;
	}
	if(check(x)) chkmax(ret,dep[x]);
	return ret;
}

int hf[100005],d[100005],ans[100005],ql[100005],qr[100005];

void procedure(){
	n=read(),q=read(),k=read();
	for(int i=1;i<n;i++){
		int u=read(),v=read();
		add(u,v); add(v,u);
	}

	for(int i=1;i<=n;i++) bl[i]=(i-1)/B+1,rh[bl[i]]=i;
	for(int i=n;i>=1;i--) lf[bl[i]]=i;
	for(int i=1;i<bl[n];i++) st[i+1]=st[i]+bl[n]-i+1;
	for(int i=1;i<=bl[n];i++) st[i]-=i-1;
	pre(1);
	
	for(int i=1;i<=n;i++) bel[i]=(i-1)/L+1, hf[i]=i;
	sort(hf+1, hf+n+1, [](int x,int y){
		if(bl[dfn[x]] == bl[dfn[y]]) return (bl[dfn[x]] & 1) ? (out[x] < out[y]) : (out[x] > out[y]);
		else return bl[dfn[x]] < bl[dfn[y]];
	});
	
	int L=1, R=0;
	for(int i=1;i<=n;i++){
		int ll=dfn[hf[i]], rr=out[hf[i]];
		while(R<rr) sum[bl[seq[++R]]]++;
		while(L>ll) sum[bl[seq[--L]]]++;
		while(R>rr) sum[bl[seq[R--]]]--;
		while(L<ll) sum[bl[seq[L++]]]--;

		for(int l=1,r=0,cur=0;l<=bl[n];l++){
			while(cur<k && r<bl[n]) cur+=sum[++r];
			if(cur>=k) chkmax(f[cid(l,r)], dep[hf[i]]);
			cur-=sum[l];
		}
	}
	for(int i=1;i<bl[n];i++)
		for(int j=i+1;j<=bl[n];j++)
			chkmax(f[cid(i,j)],f[cid(i,j-1)]);


	for(int i=1;i<=16;i++)
		for(int j=1;j<=n;j++) jp[i][j]=jp[i-1][jp[i-1][j]];

	int lar=1;
	for(int i=2;i<=n;i++)
		if(dep[i] > dep[lar]) lar = i;

	for(int i=1;i<=q;i++) ql[i]=read(),qr[i]=read(),hf[i]=i;
	sort(hf+1, hf+q+1, [](int x,int y){
		if(bl[ql[x]] == bl[ql[y]]) return (bl[ql[x]] & 1) ? (qr[x] < qr[y]) : (qr[x] > qr[y]);
		else return bl[ql[x]] < bl[ql[y]];
	});
	
	L=1,R=0;
	for(int i=1;i<=q;i++){
		int ll=ql[hf[i]], rr=qr[hf[i]];
		while(R<rr) bit.upd(dfn[++R],1);
		while(L>ll) bit.upd(dfn[--L],1);
		while(R>rr) bit.upd(dfn[R--],-1);
		while(L<ll) bit.upd(dfn[L++],-1);
		
		int bL=bl[L], bR=bl[R];
		if(L^lf[bL]) bL++; if(R^rh[bR]) bR--;
		int tmp=f[cid(bL,bR)]; 

		if(bL<=bR){
			for(int x=L;x<lf[bL];x++) chkmax(tmp,solve(x));
			for(int x=R;x>rh[bR];x--) chkmax(tmp,solve(x));
		}else{
			for(int x=L;x<=R;x++) chkmax(tmp,solve(x));
		}
		ans[hf[i]]=tmp;
	}
	for(int i=1;i<=q;i++) printf("%d\n", ans[i]);
}
int main(){
	#ifdef LOCAL
		assert(freopen("input.txt","r",stdin));
		assert(freopen("output.txt","w",stdout));
	#endif
	ll T=1;
	// math_init();
	// NTT::init();
	while(T--) procedure();
	return 0;
}
```

卡常方法：

注意到持久化线段树常数很大，考虑离线后莫队，动态维护一个树状数组，将 $[l,r]$ 内所有结点在 dfn 处标记。

这样查询一个子树内有多少编号属于 $[l,r]$ 的结点时就只需要树状数组了，能快一倍多。

---

## 作者：bluewindde (赞：1)

处理单个询问 $l, r$：对于可能贡献到答案的点，其子树中编号在区间 $[l, r]$ 内的点的个数不小于 $k$。

加入点 $u$ 时，可能变得满足上述条件的点 $v$ 必然是 $u$ 的祖先，且为了使答案更优，必定取深度最大的点 $v$。这可以通过树剖和树状数组 $O(\log^2 n)$ 地求出。

删除不好做，使用回滚莫队避免删除，时间复杂度 $O(n \sqrt n \log^2 n)$，不能通过。

看到官方题解的一种树剖方式：从根节点开始 dfs，设当前节点为 $u$，先递归 $u$ 的重儿子，再递归 $u$ 的轻儿子，最后给点 $u$ 的 dfn 序标号。

设 $\operatorname{L}_u$ 表示 $u$ 子树内最小的 dfn 序，这种树剖有如下性质：

1. 子树的 dfn 序仍为一段区间 $[\operatorname{L}_u, \operatorname{dfn}_u]$；
2. 重链上各点的 $\operatorname{L}$ 相同；
3. 重链上各点的子树的 dfn 序是链顶子树的 dfn 序的前缀。

因此，$O(\log n)$ 地跳重链找到满足条件的链顶点 $u$ 后，由于深度最大的点 $v$ 与点 $u$ 在同一重链内，可以二分点 $v$ 子树的 dfn 序区间的右端点，找到 $\operatorname{dfn}_v$ 最大的点 $v$，使得 dfn 序在区间 $[\operatorname{L}_u, \operatorname{dfn}_v]$ 中的点里，编号在 $[l, r]$ 内的点的个数小于 $k$。如果这个个数恰为 $k - 1$，那么 dfn 序为 $\operatorname{dfn}_v + 1$ 的点 $v_0$ 即满足条件。注意 $v_0$ 可能不在重链上，需要将其跳到重链上。

使用树状数组倍增进行二分，时间复杂度 $O(n \sqrt n \log n)$，可以通过。

```cpp
#include<iostream>
#include<algorithm>
#include<vector>

using namespace std;

const int block_size=320;

int n,q,k;
int b[100005];
int lb[100005];
int rb[100005];
vector<int>vec[100005];

int f[100005];
int dep[100005];
int siz[100005];
int son[100005];
int top[100005];
int val[100005];
int dfn[100005],dfn_clock;
int nfd[100005];
int L[100005];
static inline void dfs(int u,int fa){
    f[u]=fa;
    dep[u]=dep[fa]+1;
    siz[u]=1;
    for(auto v:vec[u]){
        if(v==fa)
            continue;
        dfs(v,u);
        siz[u]+=siz[v];
        if(siz[v]>siz[son[u]])
            son[u]=v;
    }
}
static inline void dfs(int u){
    if(!son[u]){
        L[u]=dfn[u]=++dfn_clock;
        nfd[dfn_clock]=u;
        return;
    }
    top[son[u]]=top[u];
    dfs(son[u]);
    L[u]=L[son[u]];
    for(auto v:vec[u]){
        if(v==f[u]||v==son[u])
            continue;
        top[v]=v;
        dfs(v);
    }
    dfn[u]=++dfn_clock;
    nfd[dfn_clock]=u;
}

struct node{
    int l,r,id;
    friend inline bool operator<(const node &x,const node &y){
        return b[x.l]==b[y.l]?x.r<y.r:b[x.l]<b[y.l];
    }
}qs[100005];

int c[100005];
static inline int lowbit(int x){return x&(-x);}
static inline void add(int x,int w){
    while(x<=n){
        c[x]+=w;
        x+=lowbit(x);
    }
}
static inline int query(int x){
    int ret=0;
    while(x){
        ret+=c[x];
        x-=lowbit(x);
    }
    return ret;
}

int ret;
static inline void update(int x){
    int u=0;
    while(x){
        if(++val[top[x]]>=k&&!u)
            u=top[x];
        x=f[top[x]];
    }
    if(!u)
        return;
    int w=-query(L[u]-1);
    for(int i=17;~i;--i){
        int nxt=x|(1<<i);
        if(nxt<dfn[u]&&w+c[nxt]<k){
            w+=c[nxt];
            x=nxt;
        }
    }
    x=nfd[x+1];
    if(w+1==k){
        while(top[x]!=u)
            x=f[top[x]];
        if(dep[x]>ret)
            ret=dep[x];
    }
}
static inline void remove(int x){
    while(x){
        --val[top[x]];
        x=f[top[x]];
    }
}

int ans[100005];

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin>>n>>q>>k;
    for(int i=1;i<=n;++i){
        b[i]=(i-1)/block_size+1;
        rb[b[i]]=i;
    }
    for(int i=1;i<=b[n];++i)
        lb[i]=rb[i-1]+1;
    for(int i=1;i<n;++i){
        int u,v;
        cin>>u>>v;
        vec[u].push_back(v);
        vec[v].push_back(u);
    }
    dfs(1,0);
    top[1]=1;
    dfs(1);
    for(int i=1;i<=q;++i){
        cin>>qs[i].l>>qs[i].r;
        qs[i].id=i;
    }
    sort(qs+1,qs+q+1);
    int curl=1,curr=0,las=0;
    for(int _=1;_<=q;++_){
        int l=qs[_].l,r=qs[_].r;
        if(b[l]!=las){
            for(int i=1;i<=n;++i){
                c[i]=0;
                val[i]=0;
            }
            las=b[l];
            curr=rb[b[l]];
            ret=0;
            curl=curr+1;
        }
        if(b[l]==b[r]){
            for(int i=l;i<=r;++i){
                add(dfn[i],1);
                update(i);
            }
            ans[qs[_].id]=ret;
            for(int i=l;i<=r;++i){
                add(dfn[i],-1);
                remove(i);
            }
            ret=0;
        }else{
            while(curr<r){
                add(dfn[++curr],1);
                update(curr);
            }
            int o=curl,oret=ret;
            while(curl>l){
                add(dfn[--curl],1);
                update(curl);
            }
            ans[qs[_].id]=ret;
            ret=oret;
            while(curl<o){
                add(dfn[curl],-1);
                remove(curl++);
            }
        }
    }
    for(int i=1;i<=q;++i)
        cout<<ans[i]<<'\n';
    return 0;
}
```

---

## 作者：CQ_Bab (赞：1)

# 前言
赛时就会了个 $n\sqrt{n}\log^2{n}$ 的做法经过一同计算（~~瞎几把算~~）成功算出比暴力还慢的时间复杂度，就没打了。
# 思路
首先我们发现区间查询，果断上莫队但是我们发现我们不太好维护删除一个点之后的答案，所以考虑回滚莫队，对于我们加入一个点 $x$ 我们发现它能改变状态的那些点（及从不可以变到可以）一定是他的祖先，而且因为存在祖先关系的情况下合法的一定是一条从根节点开始的链，那么考虑倍增对于加入的点我们跳到第一个祖先使得 $\sum_{dfn_x}^{ed_x} a_i\geq k$（就是转到 dfs 序上了）然后就更新一下答案即可。
# 代码
打得依托。
```cpp
#include <bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
#include <ext/rope>
using namespace __gnu_pbds;
using namespace std;
#define pb push_back
#define rep(i,x,y) for(register int i=x;i<=y;i++)
#define rep1(i,x,y) for(register int i=x;i>=y;--i)
#define fire signed
#define il inline
template<class T> il void print(T x) {
	if(x<0) printf("-"),x=-x;
	if (x > 9) print(x / 10);
	putchar(x % 10 + '0');
}
template<class T> il void in(T &x) {
    x = 0; char ch = getchar();
    int f = 1;
    while (ch < '0' || ch > '9') {if(ch=='-') f = -1; ch = getchar(); }
    while (ch >= '0' && ch <= '9') { x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar(); }
    x *= f;
}
int T=1;
const int N=1e5+10;
int f[N][18];
int tr[N],tt[N];
int lowbit(int x) {
	return x&-x;
}
int n,q,k,len;
void add(int x,int k,int tr[]) {
	for(;x<=n;x+=lowbit(x)) tr[x]+=k;
}
int Ans(int x,int tr[]) {
	int res=0;
	for(;x;x-=lowbit(x)) res+=tr[x];
	return res;
}
int l[N],r[N];
vector<int>v[N],ve[N];
int ans[N];
bool cmp(int x,int y) {
	return r[x]<r[y];
}
int dfn[N],mp[N],idx,ed[N],dep[N];
void dfs(int x,int fa) {
	dfn[x]=++idx;
	dep[x]=dep[fa]+1;
	mp[idx]=x;
	f[x][0]=fa;
	for(auto to:ve[x]) {
		if(to==fa) continue;
		dfs(to,x);
	}
	ed[x]=idx;
}
void init() {
	rep(j,1,16) {
		rep(i,1,n) {
			f[i][j]=f[f[i][j-1]][j-1];
		}
	}
}
#define bl(x) ((x-1)/len+1)
void solve() {
	in(n),in(q),in(k);
	rep(i,1,n-1) {
		int x,y;
		in(x),in(y);
		ve[x].pb(y);
		ve[y].pb(x);
	}
	len=sqrt(n);
	dfs(1,0);
	init();
	rep(i,1,q) {
		in(l[i]),in(r[i]);
		v[bl(l[i])].pb(i);
	}
	rep(i,1,bl(n)) sort(v[i].begin(),v[i].end(),cmp);
	rep(i,1,bl(n)) {
		int R=min(i*len,n);
		int rnow=R-1;
		rep(j,1,n) tt[j]=tr[j]=false;
		int res1=false;
		for(auto id:v[i]) {
			int l1=l[id],r1=r[id];
			int lnow=R;
			if(r1-l1+1<=len) {
				int res=0;
				rep(j,l1,r1) {
					add(dfn[j],1,tr);
					int xx=j;
					if(Ans(ed[j],tr)-Ans(dfn[j]-1,tr)>=k) {
						res=max(res,dep[j]);
					}else if(dep[xx]-1>res){
						rep1(l,16,0) {
							int now=f[xx][l];
							if(!now) continue;
							if(Ans(ed[now],tr)-Ans(dfn[now]-1,tr)<k) {
								xx=now;
							}
						}
						res=max(res,dep[xx]-1);
					}
				}
				ans[id]=res;
				rep(j,l1,r1) add(dfn[j],-1,tr);
			}else {
				while(rnow<r1) {
					rnow++;
					add(dfn[rnow],1,tt);
					if(dep[rnow]<=res1) continue;
					if(Ans(ed[rnow],tt)-Ans(dfn[rnow]-1,tt)>=k) {
						res1=max(res1,dep[rnow]);
					}else {
						int xx=rnow;
						rep1(l,16,0) {
							int now=f[xx][l];
							if(!now) continue;
							if(Ans(ed[now],tt)-Ans(dfn[now]-1,tt)<k) {
								xx=now;
							}
						}
						res1=max(res1,dep[xx]-1);
					}
				}
				int res2=0;
				vector<int>del;
				while(lnow>l1) {
					lnow--;
					add(dfn[lnow],1,tt);
					del.pb(dfn[lnow]);
					int xx=lnow;
					if(dep[xx]<=max(res2,res1)) continue;
					if(Ans(ed[xx],tt)-Ans(dfn[xx]-1,tt)>=k) {
						res2=max(res2,dep[xx]);
					}else {
						rep1(l,16,0) {
							int now=f[xx][l];
							if(!now) continue;
							if(Ans(ed[now],tt)-Ans(dfn[now]-1,tt)<k) {
								xx=now;
							}
						}
						res2=max(res2,dep[xx]-1);
					}
				}
				ans[id]=max(res1,res2);
				for(auto to:del) add(to,-1,tt);
			} 
		}
	}
	rep(i,1,q) printf("%d\n",ans[i]);
}
fire main() {
	while(T--) {
		solve();
	}
	return false;
}
```

---


# [SDOI2014] 旅行

## 题目描述

S 国有 $N$ 个城市，编号从 $1$ 到 $N$。城市间用 $N-1$ 条双向道路连接，满足从一个城市出发可以到达其它所有城市。每个城市信仰不同的宗教，如飞天面条神教、隐形独角兽教、绝地教都是常见的信仰。

为了方便，我们用不同的正整数代表各种宗教，S 国的居民常常旅行。旅行时他们总会走最短路，并且为了避免麻烦，只在信仰和他们相同的城市留宿。当然旅程的终点也是信仰与他相同的城市。S 国为每个城市标定了不同的旅行评级，旅行者们常会记下途中（包括起点和终点）留宿过的城市的评级总和或最大值。

在 S 国的历史上常会发生以下几种事件：

- `CC x c`：城市 $x$ 的居民全体改信了 $c$ 教；
- `CW x w`：城市 $x$ 的评级调整为 $w$；
- `QS x y`：一位旅行者从城市 $x$ 出发，到城市 $y$，并记下了途中留宿过的城市的评级总和；
- `QM x y`：一位旅行者从城市 $x$ 出发，到城市 $y$，并记下了途中留宿过的城市的评级最大值。

由于年代久远，旅行者记下的数字已经遗失了，但记录开始之前每座城市的信仰与评级，还有事件记录本身是完好的。请根据这些信息，还原旅行者记下的数字。 为了方便，我们认为事件之间的间隔足够长，以致在任意一次旅行中，所有城市的评级和信仰保持不变。

## 说明/提示

对于 $100\%$ 的数据，$N,Q \leq10^5,C \leq10^5$

数据保证对所有 `QS` 和 `QM` 事件，起点和终点城市的信仰相同；在任意时刻，城市的评级总是不大于 $10^4$ 的正整数，且宗教值不大于 $C$。

## 样例 #1

### 输入

```
5 6
3 1
2 3
1 2
3 3
5 1
1 2
1 3
3 4
3 5
QS 1 5
CC 3 1
QS 1 5
CW 3 3
QS 1 5
QM 2 4```

### 输出

```
8
9
11
3```

# 题解

## 作者：Fading (赞：51)

## 默认大家都会树剖。

动态开点线段树？

其实和主席树差不多。

主席树就是动态开点的。

我们对于这个题目，对于每一个宗教建一个线段树。每棵线段树存区间最大值$(max)$和区间和$(tot)$。

这不是树上询问吗？？？树剖就好了qwq

你说空间开不下？所以我们要动态开点。

什么意思呢？

简单点说，不需要的线段树节点不添加，只添加需要的线段树节点。

比如说有两个宗教，一个是%$czx$教，一个是嘲讽$xj$教(???

城市分布是这样的：

![](https://cdn.luogu.com.cn/upload/pic/36916.png)

城市里的数字表示$DFS$序，不是编号！我们的线段树下标和$DFS$序有关！

城市宗教下方的数字表示评级。

对于第$1$个城市,我们把它加入关于$xj$的线段树中，因为线段树还没有节点表示的区间覆盖$1$这个点，所以我们新建一个节点$(tot=1,max=1)$:

![](https://cdn.luogu.com.cn/upload/pic/36917.png)

然后像线段树的单点修改一样，向下传递,传递到$[1,2]$，没有节点覆盖，新建！

![](https://cdn.luogu.com.cn/upload/pic/36918.png)

向下传递,传递到$[1,1]$，没有节点覆盖，新建！

![](https://cdn.luogu.com.cn/upload/pic/36919.png)

就是这样！每一次添加的节点数最多是$logn$级别的。

为什么?因为线段树是一个完全二叉树，每一次最多遍历$(logn) +1$个节点。

所以空间复杂度就是$O(nlogn)$

然后我们还需要什么？因为我们对于每一个宗教都要开一颗线段树，所以我们要开一个$root$数组，记录每一棵线段树的根。我们还需要一个变量记录当前有多少个节点。

```
int root[100004],len;
struct Node{
	int l,r,max,tot;//l是左儿子的编号,r是右儿子的编号
}tree[20000110];
inline void update(int &rt,int w,int l,int r,int pos){//w是评级,pos你要添加的点的DFS序
	if (!rt) rt=++len;
	tree[rt].max=max(tree[rt].max,w),tree[rt].tot+=w;
	if (l==r) return; int mid=(l+r)/2;
	if (mid>=pos) update(tree[rt].l,w,l,mid,pos);
	else update(tree[rt].r,w,mid+1,r,pos);
}
```

然后对于修改操作，比如把$DFS$序为$x$的点宗教改为$y$，就先在原先$x$对应宗教对应的线段树中把[x,x]的节点的值全该成$0$，然后对于它到根节点的路径上的所有解点$pushup$一下。

即
```
inline void remove(int &rt,int l,int r,int pos){
	if (l==r){ tree[rt].tot=0,tree[rt].max=0;return; }
	int mid=(l+r)/2;
	if (mid>=pos) remove(tree[rt].l,l,mid,pos);
	else remove(tree[rt].r,mid+1,r,pos);
	tree[rt].tot=tree[tree[rt].l].tot+tree[tree[rt].r].tot;
	tree[rt].max=max(tree[tree[rt].l].max,tree[tree[rt].r].max);
}
```

最后在$y$对应的线段树中$update\ x$的评级

查询的话就在两个节点的路径上跳链就可以了。

但是查询一条链上的值怎么办呢？

设旅行者的宗教是$X$，两个点的$DFS$序分别为$A,B$，这就等价于查询$X$所对应的线段树区间$[A,B]$的值。

```
inline int querytot(int rt,int lb,int rb,int l,int r){
	if (r<lb||l>rb) return 0;
	if (r>=rb&&l<=lb) return tree[rt].tot;
	int mid=(lb+rb)/2;
	return querytot(tree[rt].l,lb,mid,l,r)+querytot(tree[rt].r,mid+1,rb,l,r);
}
inline int querymax(int rt,int lb,int rb,int l,int r){
	if (r<lb||l>rb) return 0;
	if (r>=rb&&l<=lb) return tree[rt].max;
	int mid=(lb+rb)/2;
	return max(querymax(tree[rt].l,lb,mid,l,r),querymax(tree[rt].r,mid+1,rb,l,r));
}
inline int sigmax(int u,int v,int zj){
	int ans=0;
	while (top[u]!=top[v]){
		if (dep[top[u]]<dep[top[v]]) swap(u,v);
		ans=max(ans,querymax(root[zj],1,n,tpos[top[u]],tpos[u]));
		u=fa[top[u]];
	}
	if (dep[u]<dep[v]) swap(u,v);
	ans=max(ans,querymax(root[zj],1,n,tpos[v],tpos[u]));
	return ans;
}
inline int sigtot(int u,int v,int zj){
	int ans=0;
	while (top[u]!=top[v]){
		if (dep[top[u]]<dep[top[v]]) swap(u,v);
		ans=ans+querytot(root[zj],1,n,tpos[top[u]],tpos[u]);
		u=fa[top[u]];
	}
	if (dep[u]<dep[v]) swap(u,v);
	ans=ans+querytot(root[zj],1,n,tpos[v],tpos[u]);
	return ans;
}
```

完整代码:
```
#include<bits/stdc++.h>
using namespace std;
struct node{
    int to,next;
}g[1000000];
int tot,n,m,cnt,w[100004],zj[100004],len,head[100004],dep[100004],wson[100004],top[100004],tpos[100004],pre[100004],fa[100004],size[100004];
inline void made(int from,int to){
    g[++tot].to=to;
    g[tot].next=head[from];
    head[from]=tot;
}
inline void dfs1(int rt,int ff){
    fa[rt]=ff;dep[rt]=dep[ff]+1;size[rt]=1;
    for (int i=head[rt];i;i=g[i].next){
        int v=g[i].to;
        if (v==ff) continue;
        dfs1(v,rt);
        size[rt]+=size[v];
        if (!wson[rt]||size[wson[rt]]<size[v]) wson[rt]=v;
    }
}
inline void dfs2(int rt,int tops){
    tpos[rt]=++cnt;pre[cnt]=rt;top[rt]=tops;
    if (wson[rt]) dfs2(wson[rt],tops);
    for (int i=head[rt];i;i=g[i].next){
        int v=g[i].to;
        if (v==fa[rt]||v==wson[rt]) continue;
        dfs2(v,v);
    }
}
int root[100004];
struct Node{
    int l,r,max,tot;
}tree[20000110];
inline void update(int &rt,int w,int l,int r,int pos){
    if (!rt) rt=++len;
    tree[rt].max=max(tree[rt].max,w),tree[rt].tot+=w;
    if (l==r) return; int mid=(l+r)/2;
    if (mid>=pos) update(tree[rt].l,w,l,mid,pos);
    else update(tree[rt].r,w,mid+1,r,pos);
}
inline void remove(int &rt,int l,int r,int pos){
    if (l==r){ tree[rt].tot=0,tree[rt].max=0;return; }
    int mid=(l+r)/2;
    if (mid>=pos) remove(tree[rt].l,l,mid,pos);
    else remove(tree[rt].r,mid+1,r,pos);
    tree[rt].tot=tree[tree[rt].l].tot+tree[tree[rt].r].tot;
    tree[rt].max=max(tree[tree[rt].l].max,tree[tree[rt].r].max);
}
inline int querytot(int rt,int lb,int rb,int l,int r){
    if (r<lb||l>rb) return 0;
    if (r>=rb&&l<=lb) return tree[rt].tot;
    int mid=(lb+rb)/2;
    return querytot(tree[rt].l,lb,mid,l,r)+querytot(tree[rt].r,mid+1,rb,l,r);
}
inline int querymax(int rt,int lb,int rb,int l,int r){
    if (r<lb||l>rb) return 0;
    if (r>=rb&&l<=lb) return tree[rt].max;
    int mid=(lb+rb)/2;
    return max(querymax(tree[rt].l,lb,mid,l,r),querymax(tree[rt].r,mid+1,rb,l,r));
}
inline int sigmax(int u,int v,int zj){
    int ans=0;
    while (top[u]!=top[v]){
        if (dep[top[u]]<dep[top[v]]) swap(u,v);
        ans=max(ans,querymax(root[zj],1,n,tpos[top[u]],tpos[u]));
        u=fa[top[u]];
    }
    if (dep[u]<dep[v]) swap(u,v);
    ans=max(ans,querymax(root[zj],1,n,tpos[v],tpos[u]));
    return ans;
}
inline int sigtot(int u,int v,int zj){
    int ans=0;
    while (top[u]!=top[v]){
        if (dep[top[u]]<dep[top[v]]) swap(u,v);
        ans=ans+querytot(root[zj],1,n,tpos[top[u]],tpos[u]);
        u=fa[top[u]];
    }
    if (dep[u]<dep[v]) swap(u,v);
    ans=ans+querytot(root[zj],1,n,tpos[v],tpos[u]);
    return ans;
}
char s[100];
int main(){
    len=0;
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++){
        scanf("%d%d",&w[i],&zj[i]);
    }
    int x,y;
    for (int i=1;i<n;i++){
        scanf("%d%d",&x,&y);
        made(x,y);made(y,x);
    }
    dfs1(1,0);dfs2(1,1);
    for (int i=1;i<=n;i++){
        update(root[zj[i]],w[i],1,n,tpos[i]);
    }		
    while (m--){
        scanf("%s",s);scanf("%d%d",&x,&y);
        switch (s[1]){
            case 'C':{
                remove(root[zj[x]],1,n,tpos[x]);
                update(root[y],w[x],1,n,tpos[x]);
                zj[x]=y;
                break;
            }
            case 'W':{
                remove(root[zj[x]],1,n,tpos[x]);
                update(root[zj[x]],y,1,n,tpos[x]);
                w[x]=y;
                break;
            }
            case 'S':{
                printf("%d\n",sigtot(x,y,zj[x]));
                break;
            } 
            case 'M':{
                printf("%d\n",sigmax(x,y,zj[x]));
                break;
            }
        }
    }
    return 0;
}
```

---

## 作者：斯德哥尔摩 (赞：26)

注：此题有毒。。。

不要被标签中的 主席树 迷惑了。。。

一开始以为是 倍增LCA+主席树，于是花了 10min 敲了一发模板，然后完美地 TLE 了。。。

想了两天，无方，看题解，发现要用 树链剖分+线段树 。。。

花了半小时学习了 树剖（看完发现 树剖 是个好东东。。。），又调了半小时，终于 AC 了。。。

要点：

1.有多少个宗教，就有多少个线段树。

2.线段树需要维护两个值：区间和值，区间最值，此处 区间 由 相同宗教的城市 组成。

3.线段树除了 插入值 ，还要 删除值；当树中没有某个节点时，增加新节点，否则直接修改。

4.此处主席树应该能写，然而我不会。。。

4. 树剖 应该都会，不会的像我一样右转自行百度。。。

5.注意读入，一般都用 手写读优 。

6.注意数组大小（当初我差点就 RE 了。。。）

7.剩下的就是细节处理的问题了，什么前向星存图就不多说了，应该都没什么问题。

8.建议 max 函数手写，STL 感觉有点 慢+不靠谱 。。。

如果注意了以上还是莫名其妙地 WA 了，看代码吧。

附代码：（173行，好长。。。）

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#define MAXN 100010
using namespace std;
int n,m,d=1,e=1,g=1;
int c[MAXN],w[MAXN],root[MAXN];
int head[MAXN],id[MAXN],top[MAXN],deep[MAXN],fa[MAXN],son[MAXN],num[MAXN];
struct node1{//结构体前向星
    int next,to;
}a[MAXN<<1];
struct node2{//动态线段树
    int l,r,data1,data2;
}b[MAXN*20];
inline int read(){//弱弱的读优
    int date=0,w=1;char c=0;
    while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
    while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
    return date*w;
}
inline int max(const int &x,const int &y){//手写 max ,感觉有点手残。。。
    if(x>y)return x;
    return y;
}
void pushup(int rt){//上传
    b[rt].data1=b[b[rt].l].data1+b[b[rt].r].data1;
    b[rt].data2=max(b[b[rt].l].data2,b[b[rt].r].data2);
}
void pushdown(int rt){//清空
    b[rt].data1=b[rt].data2=b[rt].l=b[rt].r=0;
}
void insert(int k,int v,int l,int r,int &rt){//插入
    int mid;
    if(!rt)rt=e++;//如上 第3点
    if(l==v&&v==r){
        b[rt].data1=b[rt].data2=k;
        return;
    }
    mid=l+r>>1;
    if(v<=mid)insert(k,v,l,mid,b[rt].l);
    else insert(k,v,mid+1,r,b[rt].r);
    pushup(rt);
}
void remove(int k,int l,int r,int &rt){//删除
    int mid;
    if(l==r){
        pushdown(rt);
        rt=0;
        return;
    }
    mid=l+r>>1;
    if(k<=mid)remove(k,l,mid,b[rt].l);
    else remove(k,mid+1,r,b[rt].r);
    pushup(rt);
    if(!b[rt].l&&!b[rt].r){//注意这里，左子树 与 右子树 都空时，节点为空
        pushdown(rt);
        rt=0;
    }
}
int query1(int s,int t,int l,int r,int rt){//区间求和
    if(!rt)return 0;//节点为空，返回
    int mid;
    if(l==s&&r==t)
    return b[rt].data1;
    mid=l+r>>1;
    if(t<=mid)return query1(s,t,l,mid,b[rt].l);
    else if(s>mid)return query1(s,t,mid+1,r,b[rt].r);
    else return query1(s,mid,l,mid,b[rt].l)+query1(mid+1,t,mid+1,r,b[rt].r);
}
int query2(int s,int t,int l,int r,int rt){//区间求最值
    if(!rt)return 0;
    int mid;
    if(l==s&&r==t)
    return b[rt].data2;
    mid=l+r>>1;
    if(t<=mid)return query2(s,t,l,mid,b[rt].l);
    else if(s>mid)return query2(s,t,mid+1,r,b[rt].r);
    else return max(query2(s,mid,l,mid,b[rt].l),query2(mid+1,t,mid+1,r,b[rt].r));
}
void add(int x,int y){//加边
    a[d].to=y;
    a[d].next=head[x];
    head[x]=d++;
    a[d].to=x;
    a[d].next=head[y];
    head[y]=d++;
}
void buildtree(int rt){//建树+树剖准备1
    int will;
    num[rt]=1;
    for(int i=head[rt];i;i=a[i].next){
        will=a[i].to;
        if(!deep[will]){
            deep[will]=deep[rt]+1;
            fa[will]=rt;
            buildtree(will);
            num[rt]+=num[will];
            if(num[will]>num[son[rt]])son[rt]=will;
        }
    }
}
void dfs(int rt,int fa){//树剖准备2
    if(son[rt]){
        top[son[rt]]=top[rt];
        id[son[rt]]=++g;
        dfs(son[rt],rt);
    }
    int v;
    for(int i=head[rt];i;i=a[i].next){
        v=a[i].to;
        if(v==fa||v==son[rt])continue;
        top[v]=v;
        id[v]=++g;
        dfs(v,rt);
    }
}
void change1(int x,int y){//修改宗教：原宗教中删除，新宗教中插入
    remove(id[x],1,n,root[c[x]]);
    c[x]=y;
    insert(w[x],id[x],1,n,root[c[x]]);
}
void change2(int x,int y){//修改评价：直接插入
    w[x]=y;
    insert(w[x],id[x],1,n,root[c[x]]);
}
void work1(int x,int y){//求评价和
    int cs=c[x],s=0;
    while(top[x]!=top[y]){//树剖搞起
        if(deep[top[x]]<deep[top[y]])swap(x,y);
        s+=query1(id[top[x]],id[x],1,n,root[cs]);
        x=fa[top[x]];
    }
    if(deep[x]>deep[y])swap(x,y);
    s+=query1(id[x],id[y],1,n,root[cs]);//不要忘了这里。。。
    printf("%d\n",s);
}
void work2(int x,int y){//求评价最值
    int cs=c[x],s=0;
    while(top[x]!=top[y]){//同上
        if(deep[top[x]]<deep[top[y]])swap(x,y);
        s=max(s,query2(id[top[x]],id[x],1,n,root[cs]));
        x=fa[top[x]];
    }
    if(deep[x]>deep[y])swap(x,y);
    s=max(s,query2(id[x],id[y],1,n,root[cs]));
    printf("%d\n",s);
}
int main(){
    int x,y;
    char ch[3];
    n=read();m=read();
    for(int i=1;i<=n;i++){w[i]=read();c[i]=read();}
    for(int i=1;i<n;i++){
        x=read();y=read();
        add(x,y);
    }
    deep[1]=id[1]=top[1]=1;//初值
    buildtree(1);
    dfs(1,0);
    for(int i=1;i<=n;i++)insert(w[i],id[i],1,n,root[c[i]]);//建初始线段树
    while(m--){//主过程
        scanf("%s",ch);x=read();y=read();
        if(ch[0]=='C'){
            if(ch[1]=='C')change1(x,y);
            if(ch[1]=='W')change2(x,y);
        }
        if(ch[0]=='Q'){
            if(ch[1]=='S')work1(x,y);
            if(ch[1]=='M')work2(x,y);
        }
    }
    return 0;
}

```

---

## 作者：Link_Cut_Y (赞：17)

题意：树上问题，每点有颜色和点权。操作有：求路径上颜色为 $c$ 的点权和或 $\max$，修改 $x$ 点的颜色和点权。

首先这道题一看就需要树链剖分。先上树剖转化为区间问题。然后考虑区间问题怎么做。

考虑分块。最明显的方法应该是对序列分块。这里拿区间和举例。设 $s_{c, k}$ 表示颜色为 $c$ 的点在 $k$ 块内的权值和。这样区间查询时只需要查询 $s_{c, [l, r]}$ 即可，时间复杂度 $O(\sqrt{n})$。单点修改时可以直接散块暴力重构。时间复杂度 $O(\sqrt{n})$。带上树剖的 $\log$，时间复杂度 $O(m \sqrt n \log n)$。

这样做的空间复杂度时 $O(n\sqrt{n})$。水平较高的同学可以直接分散层叠或者开动态数组，但是朴素算法也可以过。

大部分人止步于此。实际上，$\sqrt{n}$ 真的是这道题的最优块长吗？让我们思考一下。设块长为 $B$，则单次修改的复杂度明显是 $O(B)$ 的。单次询问分整块和散块考虑。若为整块，则时间复杂度 $O(\dfrac{n}{B})$，若为散块，时间复杂度 $O(B)$。然后直接套上树剖的复杂度 $\log n$，时间复杂度 $O((\dfrac{n}{B} + B) \log n)$。然后当 $B = \sqrt{n}$ 时最优？不不不，当然不是这样的。

让我们考虑一下树剖的性质：每个整块在一次询问中最多被查询一次。所以整块的复杂度 $O(\dfrac{n}{B})$ 并不能套上树剖的 $\log$。然后考虑散块查询的复杂度，我们发现是有可能查询到 $\log n$ 个散块的。故单次查询的复杂度就变成了 $O(\dfrac{n}{B} + B \log n)$。

我们先把单点修改的复杂度抛去不看（因为复杂度远小于查询）。现在变成了一个中学数学问题：求 $\dfrac{n}{B} + B \log n$ 的最小值。根据均值不等式可知，当 $\dfrac{n}{B} = B \log n$ 时，即 $B = \sqrt{\dfrac{n}{\log n}}$ 时为最优块长。此时查询的时间复杂度为 $O(\sqrt{n \log n})$。好耶，我们实现了将外层 $\log$ 放到根号里！

实测这种块长的调整方式：块长为 $\sqrt{n}$ 时运行时间 $1.00 s$，块长为 $\sqrt{\dfrac{n}{\log n}}$ 时运行时间为 $740 ms$。不过上述过程没有考虑到树剖常数因素的影响，所以可能这个证明不是很严谨。

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>

using namespace std;

const int N = 100010, M = N << 1;
const int K = 1400, INF = 0x3f3f3f3f;

int h[N], e[M], ne[M], idx;
int _col[N], _w[N], col[N], w[N], n, m;
int sz[N], son[N], top[N], id[N], cnt, dep[N], fa[N];
int sum[N][K], maxn[N][K], len, lp[K], rp[K], blo[N];

void chkmax(int &a, int b) { a = (a > b ? a : b); }
void chkmin(int &a, int b) { a = (a < b ? a : b); }
int get(int x) { return int(x / len); }
void add(int a, int b) {
	e[ ++ idx] = b, ne[idx] = h[a], h[a] = idx;
}
void dfs1(int u, int f) {
	fa[u] = f, sz[u] = 1, dep[u] = dep[f] + 1;
	for (int i = h[u]; i; i = ne[i]) {
		int v = e[i];
		if (v == f) continue;
		dfs1(v, u); sz[u] += sz[v];
		if (sz[son[u]] < sz[v]) son[u] = v;
	}
}
void dfs2(int u, int t) {
	top[u] = t, id[u] = ++ cnt; 
	w[cnt] = _w[u], col[cnt] = _col[u];
	if (son[u]) dfs2(son[u], t);
	for (int i = h[u]; i; i = ne[i]) {
		int v = e[i];
		if (v == fa[u] or v == son[u]) continue;
		dfs2(v, v);
	}
}
int qsum(int c, int l, int r) {
	int lc = blo[l], rc = blo[r], ans = 0;
	if (lc == rc) {
		for (int i = l; i <= r; i ++ )
			if (col[i] == c) ans += w[i];
		return ans;
	}
	int i = l, j = r;
	for (; get(i) == lc; i ++ ) if (col[i] == c) ans += w[i];
	for (; get(j) == rc; j -- ) if (col[j] == c) ans += w[j];
	for (int k = get(i); k <= get(j); k ++ ) ans += sum[c][k];
	return ans;
}
int qmax(int c, int l, int r) {
	int lc = blo[l], rc = blo[r], ans = -INF;
	if (lc == rc) {
		for (int i = l; i <= r; i ++ )
			if (col[i] == c) chkmax(ans, w[i]);
		return ans;
	}
	int i = l, j = r;
	for (; get(i) == lc; i ++ ) if (col[i] == c) chkmax(ans, w[i]);
	for (; get(j) == rc; j -- ) if (col[j] == c) chkmax(ans, w[j]);
	for (int k = get(i); k <= get(j); k ++ ) chkmax(ans, maxn[c][k]);
	return ans;
}
void cgcol(int x, int c) {
	int last = col[x], k = blo[x];
	col[x] = c; maxn[last][k] = maxn[c][k] = -INF, sum[last][k] = sum[c][k] = 0;
	for (int i = lp[k]; i <= rp[k]; i ++ ) {
		if (col[i] == last) chkmax(maxn[last][k], w[i]), sum[last][k] += w[i];
		if (col[i] == c) chkmax(maxn[c][k], w[i]), sum[c][k] += w[i];
	}
}
void cgw(int x, int c) {
	w[x] = c; int k = blo[x]; maxn[col[x]][k] = -INF, sum[col[x]][k] = 0;
	for (int i = lp[k]; i <= rp[k]; i ++ ) {
		if (col[i] == col[x]) sum[col[x]][k] += w[i], chkmax(maxn[col[x]][k], w[i]);
	}
}
int qs(int c, int u, int v) {
	int ans = 0;
	while (top[u] != top[v]) {
		if (dep[top[u]] < dep[top[v]]) swap(u, v);
		ans += qsum(c, id[top[u]], id[u]); u = fa[top[u]];
	}
	if (dep[u] < dep[v]) swap(u, v);
	ans += qsum(c, id[v], id[u]);
	return ans;
}
int qm(int c, int u, int v) {
	int ans = -INF;
	while (top[u] != top[v]) {
		if (dep[top[u]] < dep[top[v]]) swap(u, v);
		chkmax(ans, qmax(c, id[top[u]], id[u])); u = fa[top[u]];
	}
	if (dep[u] > dep[v]) swap(u, v);
	chkmax(ans, qmax(c, id[u], id[v])); return ans;
}

int main() {
	scanf("%d%d", &n, &m); len = sqrt(double(n / log2(n)));
	for (int i = 1; i <= n; i ++ )
		scanf("%d%d", &_w[i], &_col[i]);
	for (int i = 1; i < n; i ++ ) {
		int a, b; scanf("%d%d", &a, &b);
		add(a, b), add(b, a);
	}
	dfs1(1, -1), dfs2(1, 1);
	memset(lp, 0x3f, sizeof lp);
	memset(rp, -0x3f, sizeof rp);
	for (int i = 1; i <= n; i ++ ) {
		int k = get(i); blo[i] = k;
		chkmin(lp[k], i), chkmax(rp[k], i);
		sum[col[i]][k] += w[i];
		chkmax(maxn[col[i]][k], w[i]);
	}
	while (m -- ) {
		char op[3]; int x, y;
		scanf("%s%d%d", op, &x, &y);
		if (op[0] == 'C' and op[1] == 'W') cgw(id[x], y);
		if (op[0] == 'C' and op[1] == 'C') cgcol(id[x], y);
		if (op[0] == 'Q' and op[1] == 'S') printf("%d\n", qs(col[id[x]], x, y));
		if (op[0] == 'Q' and op[1] == 'M') printf("%d\n", qm(col[id[x]], x, y));
	}
	return 0;
}
```

---

## 作者：半仙胡小桃 (赞：12)

[原BLOG地址](http://blog.csdn.net/qq_35914587/article/details/79358100)
## 题目描述：
无。
## 题目分析：
首先，如果没有宗教信仰的限制，即每个旅行者可以在沿途的任何一个城市睡觉。
那么这个问题就是一个树上路径求max&&sum的问题，树剖+线段树
但是现在加入了宗教限制。
观察一下宗教个数，为$10^5$.
假如我们开$10^5$棵线段树，分别对应每种宗教。
我们在查询的时候就可以在相对应的线段树中进行查询.
然而如果按照满二叉树的方法造线段树，是肯定MLE的。
我们可以对线段树进行动态开点即可。
线段树支持的操作有查询最大值，查询最小值，单点修改。
第一个操作可以直接把原位置的权值变为0，不用打什么删除标记。
## 题目链接：
[Luogu 3313](https://www.luogu.org/problemnew/show/P3313)
[BZOJ 3513](http://www.lydsy.com/JudgeOnline/problem.php?id=3531)
## AC 代码：

```
#include <cstdio>
#include <iostream> 
#define il inline
const int maxm=1e6+1;
struct tree{
    int ls,rs,maxx,sum;
};
int root[maxm],rt;
tree st[maxm*4];
int deep[maxm],son[maxm],fa[maxm],size[maxm],top[maxm];
int head[maxm],to[maxm*2],net[maxm*2],cnt;
int yval[maxm],val[maxm],yc[maxm],c[maxm];
int xz[maxm];
int id[maxm],who[maxm],tot;
il void add_edge(int x,int y)
{
    to[++cnt]=y,net[cnt]=head[x],head[x]=cnt;
}
int dfs1(int x,int fax,int dep)
{
    fa[x]=fax,deep[x]=dep,size[x]=1;
    int maxson=-1;
    for(int i=head[x];i;i=net[i])
    if(to[i]!=fax)
    {
        size[x]+=dfs1(to[i],x,dep+1);
        if(maxson<size[to[i]]) maxson=size[to[i]],son[x]=to[i];
    }
    return size[x];
}
void dfs2(int x,int topx)
{
    id[x]=++tot;
    who[tot]=x;
    val[tot]=yval[x],c[tot]=yc[x];
    top[x]=topx;
    if(!son[x]) return;
    dfs2(son[x],topx);
    for(int i=head[x];i;i=net[i])
     if(!id[to[i]]) dfs2(to[i],to[i]);
}
il void update(int o)
{
    st[o].maxx=std::max(st[st[o].ls].maxx,st[st[o].rs].maxx);
    st[o].sum=st[st[o].ls].sum+st[st[o].rs].sum;
}
void mofidy(int &o,int l,int r,int ind,int num)
{
    if(!o) o=++rt;
    if(l>=r)
    {
        st[o].maxx=st[o].sum=num;
        return;
    }
    int mid=(l+r)>>1;
    if(ind<=mid) mofidy(st[o].ls,l,mid,ind,num);
    else mofidy(st[o].rs,mid+1,r,ind,num);
    update(o);
    if(st[o].sum==0) o=0;
}
int askmax(int o,int l,int r,int ql,int qr)
{
    if(!o) return -1;
    if(r<ql||l>qr) return -1;
    if(ql<=l&&r<=qr)
     return st[o].maxx;
    int mid=(l+r)>>1;
    return std::max(askmax(st[o].ls,l,mid,ql,qr),askmax(st[o].rs,mid+1,r,ql,qr));
}
int asksum(int o,int l,int r,int ql,int qr)
{
    if(!o) return 0;
    if(r<ql||l>qr) return 0;
    if(ql<=l&&r<=qr)
     return st[o].sum;
    int mid=(l+r)>>1;
    return asksum(st[o].ls,l,mid,ql,qr)+asksum(st[o].rs,mid+1,r,ql,qr);
}
il int tree_max(int u,int v)
{
    int ans=-1;
    int xz=yc[v];
    while(top[u]!=top[v])
    {
        if(deep[top[u]]<deep[top[v]]) std::swap(u,v);
        ans=std::max(ans,askmax(root[xz],1,tot,id[top[u]],id[u]));
        u=fa[top[u]];
    }
    if(deep[u]<deep[v]) std::swap(u,v);
    ans=std::max(ans,askmax(root[xz],1,tot,id[v],id[u]));
    return ans;
}
il int tree_sum(int u,int v)
{
    int ans=0;
    int xz=yc[v];
    while(top[u]!=top[v])
    {
        if(deep[top[u]]<deep[top[v]]) std::swap(u,v);
        ans+=asksum(root[xz],1,tot,id[top[u]],id[u]);
        u=fa[top[u]];
    }
    if(deep[u]<deep[v]) std::swap(u,v);
    ans+=asksum(root[xz],1,tot,id[v],id[u]);
    return ans;
}
il int read()
{
    int x=0,w=1;char ch=0;
    while(ch<'0'||ch>'9')
    {
        if(ch=='-') w=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return x*w;
}
int main()
{
    int n,q;
    n=read(),q=read();
    for(int i=1;i<=n;i++)
     yval[i]=read(),yc[i]=read();
    for(int i=1;i<n;i++)
    {
        int u=read(),v=read();
        add_edge(u,v);
        add_edge(v,u);
    }
    dfs1(1,0,1),dfs2(1,1);
    for(int i=1;i<=n;i++)
     mofidy(root[yc[who[i]]],1,tot,i,yval[who[i]]);
    for(int i=1;i<=q;i++)
    {
        char s[20];
        int x,y;
        scanf("%s",s);
        x=read(),y=read();
        if(s[0]=='C'&&s[1]=='C')
        {
            mofidy(root[yc[x]],1,tot,id[x],0);
            yc[x]=y;
            mofidy(root[yc[x]],1,tot,id[x],yval[x]);
        }
        if(s[0]=='C'&&s[1]=='W')
         yval[x]=y,mofidy(root[yc[x]],1,tot,id[x],y);
        if(s[0]=='Q'&&s[1]=='M')
         printf("%d\n",tree_max(x,y));
        if(s[0]=='Q'&&s[1]=='S')
         printf("%d\n",tree_sum(x,y)); 
    }
    return 0;
}
```


---

## 作者：喵仔牛奶 (赞：9)

提供一种简单的分块写法。

前置芝士：[树剖](/problem/P3384)

把树树剖一下，问题就变成了序列问题。关键是如何处理宗教。

很容易可以想到把每种宗教都维护一遍，然而使用线段树维护的空间复杂度是 $\mathcal{O}(nc)$，会炸。

所以我们可以换一种方法，使用空间小的分块维护。将序列分成 $\sqrt n$ 块，由于每个宗教的分块只有和与最大值不同，所以空间复杂度是 $\mathcal{O}(c\sqrt n)$，时间复杂度是 $\mathcal{O}(n\sqrt n\log n)$，可以通过本题。

```
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5, P = 5e2 + 5;
struct edge {
	int v, next;
} e[N << 1];
int a[N], c[N], w1[N], w[N], pos[N], sum[N][P], maxn[N][P], L[N], R[N];
// sum[i][j] 是第j块宗教为i的和，maxn是第j块宗教为i的最大值
int head[N], fa[N], id[N], siz[N], top[N], depth[N], son[N];
int edge_cnt, n, q, u, v, x, cnt, awa, slen, sum1, sum2;
char opt[10];
inline void build() {
	slen = sqrt(n), awa = n / slen + (n % slen != 0);
	for (int id = 1; id <= awa; id ++)
		L[id] = (id - 1) * slen + 1, R[id] = id * slen;
	R[awa] = n;
	for (int id = 1; id <= awa; id ++)
		for (int j = L[id]; j <= R[id]; j ++)
			pos[j] = id, sum[c[j]][id] += a[j], maxn[c[j]][id] = max(maxn[c[j]][id], a[j]);
}
inline void clear(int id) {
	for (int i = L[id]; i <= R[id]; i ++)
		maxn[c[i]][id] = 0, sum[c[i]][id] = 0;
} // 暴力清空块的标记
inline void rebuild(int id) {
	for (int i = L[id]; i <= R[id]; i ++)
		maxn[c[i]][id] = max(maxn[c[i]][id], a[i]), sum[c[i]][id] += a[i];
} // 暴力统计块的标记
inline void updColor(int k, int x) {
	clear(pos[k]), c[k] = x, rebuild(pos[k]);
} // 暴力修改
inline void updValue(int k, int x) {
	clear(pos[k]), a[k] = x, rebuild(pos[k]);
} // 暴力修改
inline int qSum(int l, int r, int col) {
	int lp = pos[l], rp = pos[r], ans = 0;
	if (lp == rp) {
		for (int i = l; i <= r; i ++)
			if (c[i] == col) ans += a[i];
		return ans;
	} 
	for (int i = l; i <= R[lp]; i ++) if (c[i] == col) ans += a[i];
	for (int i = lp + 1; i < rp; i ++) ans += sum[col][i];
	for (int i = L[rp]; i <= r; i ++) if (c[i] == col) ans += a[i]; 
	return ans;
} // 求和
inline int qMax(int l, int r, int col) {
	int lp = pos[l], rp = pos[r], ans = 0;
	if (lp == rp) {
		for (int i = l; i <= r; i ++)
			if (c[i] == col) ans = max(ans, a[i]);
		return ans;
	}
	for (int i = l; i <= R[lp]; i ++) if (c[i] == col) ans = max(ans, a[i]);
	for (int i = lp + 1; i < rp; i ++) ans = max(ans, maxn[col][i]);
	for (int i = L[rp]; i <= r; i ++) if (c[i] == col) ans = max(ans, a[i]); 
	return ans;
} // 求最大值
void dfs1(int u, int f, int dep) {
	fa[u] = f, siz[u] = 1, depth[u] = dep;
	for (int i = head[u]; i; i = e[i].next) {
		int v = e[i].v;
		if (v == f) continue;
		dfs1(v, u, dep + 1);
		if (siz[v] > siz[son[u]])
			son[u] = v;
		siz[u] += siz[v];
	}
}
void dfs2(int u, int topf) {
	id[u] = ++ cnt, a[cnt] = w[u], c[cnt] = w1[u], top[u] = topf;
	if (!son[u]) return;
	dfs2(son[u], topf);
	for (int i = head[u]; i; i = e[i].next) {
		int v = e[i].v;
		if (v == son[u] || v == fa[u]) continue;
		dfs2(v, v);
	}
}
inline int qRangeV(int u, int v, int k) {
	int ans = 0;
	while (top[u] != top[v]) {
		if (depth[top[u]] < depth[top[v]]) swap(u, v);
		ans += qSum(id[top[u]], id[u], k), u = fa[top[u]];
	}
	if (depth[u] > depth[v]) swap(u, v);
	return ans + qSum(id[u], id[v], k);
} // 树上求和
inline int qRangeM(int u, int v, int k) {
	int ans = 0;
	while (top[u] != top[v]) {
		if (depth[top[u]] < depth[top[v]]) swap(u, v);
		ans = max(ans, qMax(id[top[u]], id[u], k)), u = fa[top[u]];
	}
	if (depth[u] > depth[v]) swap(u, v);
	return max(ans, qMax(id[u], id[v], k));
} // 树上求最大值
inline void add(int u, int v) {
	e[++ edge_cnt].v = v;
	e[edge_cnt].next = head[u];
	head[u] = edge_cnt;
}
inline int read() {
	register int t = 1, a = 0;
	register char ch = getchar();
	while (ch < '0' || ch > '9') {
		if (ch == '-') t = -1;
		ch = getchar();
	}
	while (ch <= '9' && ch >= '0')
		a = a * 10 + ch - '0', ch = getchar();
	return a * t;
}
int main() {
	n = read(), q = read();
	for (int i = 1; i <= n; i ++)
		w[i] = read(), w1[i] = read();
	for (int i = 1; i < n; i ++)
		u = read(), v = read(), add(u, v);
	dfs1(1, 0, 1), dfs2(1, 1), build();
	for (int i = 1; i <= q; i ++) {
		scanf("%s", opt);
		if (opt[1] == 'C') u = read(), v = read(), updColor(id[u], v);
		if (opt[1] == 'W') u = read(), v = read(), updValue(id[u], v);
		if (opt[1] == 'S') u = read(), v = read(), printf("%d\n", qRangeV(u, v, c[id[u]]));
		if (opt[1] == 'M') u = read(), v = read(), printf("%d\n", qRangeM(u, v, c[id[u]]));
	}
	return 0;
}
```


---

## 作者：论之铭 (赞：8)

听说这题是动态开点线段树模板题？  
观察一下题面，显然先上一发树剖，好像是对每一种宗教开一颗线段树，然后维护区间和和区间最大值。。。  
虽然我是来练动态开点线段树板子的，考虑到fhq Treap极为好写，我还是~~不要脸的~~使用了fhq Treap来维护  
我们可以对每一个宗教开一颗fhq Treap:
- 第一个操作就是将节点换一棵树，那一个erase加一个insert就行了
- 第二个操作是改变一个点的点权，我是采取erase出来之后直接修改value，pushup之后再insert回去的方法~~这样好写~~
- 第三个操作我们在链上向上跳的时候询问一下这段区间内的权值和即可
- 第四个操作同操作三，询问区间最大值更新  
总的来说其实不难想，就是把两个数据结构写写好套一套就行了~~注意细节~~

~~说好来练动态开点线段树的呢？~~

附上我丑陋的代码？
```cpp
#include <cstdio> 
#include <algorithm>

namespace IO{
    int read() {
        char c = getchar(); int x = 0; bool flag = 0;
        while (c < '0' || c > '9') (c == '-') && (flag = 1), c = getchar();
        while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
        (flag) && (x = -x);
        return x; 
    }

    void write(int x) {
        if (x < 0) putchar('-'), x = -x;
        if (x > 9) write(x / 10);
        putchar(x % 10 + '0');
    }

    void file() {
        #ifndef ONLINE_JUDGE
        freopen("2.in", "r", stdin);
        freopen("testdata1.out", "w", stdout);
        #endif
    }
} using namespace IO;

const int N = 100009;

int n, q, cnt;
int head[N], nxt[N << 1], to[N << 1];
int w[N], c[N], dep[N], fa[N], son[N], id[N], top[N], siz[N];
int rt[N], val[N], max[N], ch[N][2], key[N], sum[N];

namespace Treap {
    inline void pushup(int u) {
        max[u] = std::max(std::max(max[ch[u][0]], max[ch[u][1]]), val[u]);
        sum[u] = sum[ch[u][0]] + sum[ch[u][1]] + val[u];
    }

    inline void desNode(int u) {
        ch[u][0] = ch[u][1] = 0, siz[u] = 1, max[u] = sum[u] = val[u];
    }

    int merge(int l, int r) {
        if (!l || !r) return l ^ r;
        if (key[l] < key[r]) {
            ch[l][1] = merge(ch[l][1], r);
            pushup(l);
            return l;
        } else {
            ch[r][0] = merge(l, ch[r][0]);
            pushup(r);
            return r;
        }
    }

    void split(int u, int x, int &l, int &r) {
        if (!u) l = r = 0;
        else {
            if (u <= x) l = u, split(ch[l][1], x, ch[l][1], r);
            else r = u, split(ch[r][0], x, l, ch[r][0]);
            pushup(u);
        }
    }

    void insert(int u, int x) {
        int t1, t2;
        split(rt[x], u, t1, t2);
        rt[x] = merge(merge(t1, u), t2);
    }

    void erase(int u, int x) {
        int t1, t2, t3;
        split(rt[x], u, t1, t2);
        split(t1, u - 1, t1, t3);
        rt[x] = merge(merge(t1, merge(ch[t3][0], ch[t3][1])), t2);
        desNode(t3);
    }
} using namespace Treap;

void print(int u) {
    if (ch[u][0]) print(ch[u][0]);
    printf("%d : %d %d %d %d %d\n", u, val[u], sum[u], ch[u][0], ch[u][1], key[u]);
    if (ch[u][1]) print(ch[u][1]);
}

char getopt() {
    char c = getchar();
    while (c != 'C' && c != 'W' && c != 'S' && c != 'Q' && c != 'M') c = getchar();
    return c;
}

void add(int a, int b) {
    int u = head[a], v = ++cnt;
    nxt[v] = u, to[v] = b;
    head[a] = v;
}

void dfs1(int u, int pre, int depth) {
    fa[u] = pre, dep[u] = depth, siz[u] = 1;
    for (int i = head[u]; i; i = nxt[i]) {
        if (to[i] == pre) continue;
        dfs1(to[i], u, depth + 1);
        siz[u] += siz[to[i]];
        if (siz[to[i]] > siz[son[u]]) son[u] = to[i]; 
    }
}

void dfs2(int u, int t) {
    top[u] = t, id[u] = ++cnt;
    max[id[u]] = sum[id[u]] = val[id[u]] = w[u], key[id[u]] = rand() % 19260817, rt[c[u]] = merge(rt[c[u]], id[u]);
    if (!son[u]) return;
    dfs2(son[u], t);
    for (int i = head[u]; i; i = nxt[i]) {
        if (to[i] == fa[u] || to[i] == son[u]) continue;
        dfs2(to[i], to[i]);
    }
}

int get_sum(int l, int r, int x) {
    int t1, t2, t3, ans;
    split(rt[x], l - 1, t1, t2);
    split(t2, r, t2, t3);
    ans = sum[t2];
    rt[x] = merge(merge(t1,t2), t3);
    return ans;
}

int get_max(int l, int r, int x) {
    int t1, t2, t3, ans;
    split(rt[x], l - 1, t1, t2);
    split(t2, r, t2, t3);
    ans = max[t2];
    rt[x] = merge(merge(t1, t2), t3);
    return ans;
}

int main() {
    file();
    n = read(), q = read();
    for (int i = 1; i <= n; i++) w[i] = read(), c[i] = read();
    for (int i = 1; i < n; i++) {
        int u = read(), v = read();
        add(u, v);
        add(v, u);
    }
    dfs1(1, 0, 1), cnt = 0, dfs2(1, 1);
    while (q--) {
        char opt1 = getopt(), opt2 = getopt();
        if (opt1 == 'C' && opt2 == 'C') {
            int x = read(), y = read();
            erase(id[x], c[x]);
            insert(id[x], c[x] = y);
        } else if (opt1 == 'C' && opt2 == 'W') {
            int t1, t2, t3, x = read(), y = read();
            erase(id[x], c[x]);
            val[id[x]] = y, pushup(id[x]);
            insert(id[x], c[x]);
        } else if (opt1 == 'Q' && opt2 == 'S') {
            int u = read(), v = read(), x = c[u], ans = 0;
            while (top[u] != top[v]) {
                if (dep[top[u]] < dep[top[v]]) std::swap(u, v);
                ans += get_sum(id[top[u]], id[u], x);   
                u = fa[top[u]];
            }
            if (dep[u] < dep[v]) std::swap(u, v);
            ans += get_sum(id[v], id[u], x);
            write(ans), putchar('\n');
        } else {
            int u = read(), v = read(), x = c[u], ans = 0;
            while (top[u] != top[v]) {
                if (dep[top[u]] < dep[top[v]]) std::swap(u, v);
                ans = std::max(ans, get_max(id[top[u]], id[u], x));
                u = fa[top[u]]; 
            }
            if (dep[u] < dep[v]) std::swap(u, v);
            ans = std::max(ans, get_max(id[v], id[u], x));
            write(ans), putchar('\n');
        }
    }
    return 0;
}
```


---

## 作者：Provicy (赞：8)

树剖模板题（大雾）。

这题对于每一个宗教，我们都必须开一棵线段树维护，所以易想到动态开点（虽说动态开点是主席树思想不过我们假定我们会吧）。

对于每棵线段树，我们需要维护的有区间最大值和区间和。

这又是在树上的询问和修改，于是树链剖分走起！（我还是不会$LCT$）

此题前置芝士：树剖模板$+$动态开点思想。

此题时空复杂度：都是$O(nlogn)$。

代码如下（较丑勿喷）：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define mid (l+r>>1) 
const int N=110000; char opt[3];
int n,q,w[N],c[N],head[N],maxE,cnt,son[N],size[N],f[N],d[N],id[N],nowid,pro[N],top[N],root[N];
struct Edge{int nxt,to;}e[N<<1];
struct SegMentTree {int lc,rc,sum,flag,mx;}D[N<<4];
inline void Add(int u,int v) {e[++maxE].nxt=head[u]; head[u]=maxE; e[maxE].to=v; }
void DFS1(int x,int before)
{
	d[x]=d[before]+1; f[x]=before; size[x]=1;
	for(int i=head[x];i;i=e[i].nxt)
	{
		if(e[i].to==before) continue;
		DFS1(e[i].to,x); size[x]+=size[e[i].to];
		if(size[e[i].to]>size[son[x]]) son[x]=e[i].to;
	}
}
void DFS2(int x,int topf)
{
	id[x]=++nowid; pro[nowid]=w[x]; top[x]=topf;
	if(!son[x]) return; DFS2(son[x],topf);
	for(int i=head[x];i;i=e[i].nxt) if(e[i].to!=son[x]&&e[i].to!=f[x]) DFS2(e[i].to,e[i].to);
}
inline void Push_Up(int x) {D[x].sum=D[D[x].lc].sum+D[D[x].rc].sum; D[x].mx=max(D[D[x].lc].mx,D[D[x].rc].mx); }
void UpDate(int p,int l,int r,int &x,int k)
{
	if(!x) x=++cnt;
	D[x].mx=max(D[x].mx,k); D[x].sum+=k;
	if(l==r) return;
	if(p<=mid) UpDate(p,l,mid,D[x].lc,k);
	else UpDate(p,mid+1,r,D[x].rc,k);
}
void MoDify(int p,int l,int r,int &x)
{
	if(l==r) {D[x].sum=D[x].mx=0; return; }
	if(p<=mid) MoDify(p,l,mid,D[x].lc);
	else MoDify(p,mid+1,r,D[x].rc);
	Push_Up(x);
}
int Ask_Sum(int u,int v,int l,int r,int x)
{
	if(l>=u&&r<=v) return D[x].sum;
	int res=0;
	if(u<=mid) res+=Ask_Sum(u,v,l,mid,D[x].lc);
	if(v>mid) res+=Ask_Sum(u,v,mid+1,r,D[x].rc);
	return res; 
}
int Ask_Road_Sum(int x,int y,int k)
{
	int ans=0;
	while(top[x]!=top[y])
	{
		if(d[top[x]]<d[top[y]]) swap(x,y);
		ans+=Ask_Sum(id[top[x]],id[x],1,n,root[k]);
		x=f[top[x]];
	}
	if(d[x]>d[y]) swap(x,y);
	ans+=Ask_Sum(id[x],id[y],1,n,root[k]);
	return ans;
}
int Ask_Max(int u,int v,int l,int r,int x)
{
	if(l>=u&&r<=v) return D[x].mx;
	int ans=0;
	if(u<=mid) ans=max(ans,Ask_Max(u,v,l,mid,D[x].lc));
	if(v>mid) ans=max(ans,Ask_Max(u,v,mid+1,r,D[x].rc));
	return ans;
}
int Ask_Road_Max(int x,int y,int k)
{
	int ans=0;
	while(top[x]!=top[y])
	{
		if(d[top[x]]<d[top[y]]) swap(x,y);
		ans=max(ans,Ask_Max(id[top[x]],id[x],1,n,root[k]));
		x=f[top[x]];
	}
	if(d[x]>d[y]) swap(x,y);
	ans=max(ans,Ask_Max(id[x],id[y],1,n,root[k]));
	return ans;
}
int main()
{
	ios::sync_with_stdio(false); cin>>n>>q;
	for(int i=1;i<=n;i++) cin>>w[i]>>c[i];
	for(int i=1,u,v;i<n;i++) {cin>>u>>v; Add(u,v); Add(v,u); }
	DFS1(1,0); DFS2(1,1);
	for(int i=1;i<=n;i++) UpDate(id[i],1,n,root[c[i]],w[i]);
	for(int i=1,x,y;i<=q;i++)
	{
		cin>>opt>>x>>y;
		if(opt[1]=='C') {MoDify(id[x],1,n,root[c[x]]); UpDate(id[x],1,n,root[y],w[x]); c[x]=y; }
		if(opt[1]=='W') {MoDify(id[x],1,n,root[c[x]]); UpDate(id[x],1,n,root[c[x]],y); w[x]=y; }
		if(opt[1]=='S') {printf("%d\n",Ask_Road_Sum(x,y,c[x])); }
		if(opt[1]=='M') {printf("%d\n",Ask_Road_Max(x,y,c[x])); }
	}
	return 0;
}
```
附：离$CSP$第二轮时日不多了，希望各位神仙都能$AK$！本蒟蒻给柠萌当分母去了$QwQ$

---

## 作者：Frozencode (赞：6)

做法前面的大佬都说的很清楚了，这题的关键主要在于对宗教建线段树和动态开点。

既然是动态开点就要记录下每个节点的左右儿子，这里用引用调用来更新每个点的左右儿子。事实上能对答案产生贡献的只有有值的节点，所以对于没有值的节点我们不需要把它建出来，这样可以省不少空间。
这里仿照了Owen_codeisking大佬的写法。
```cpp
void update(ll &p,ll l,ll r,ll pos,ll det)
{
	if(!p) p = ++tot;//新节点
	if(l == r)//到了要更新的点的位置。
	{
		tree[p].sum = det;
		tree[p].maxx = det;
		return;
	}
	ll mid = (l + r)>>1;
	if(pos <= mid)update(tree[p].ls,l,mid,pos,det);
	else update(tree[p].rs,mid + 1,r,pos,det);
	push_up(p,tree[p].ls,tree[p].rs);
	return;
}
```
（**动态开点的tot不要和树剖更新编号的tot搞混**）

值得注意的是，因为没有值的节点我们还没有建出来，所以在其他操作访问到这个节点的时候一定要加上这么一句以此来防止访问到奇怪的东西。

```cpp
if(!p) p = ++tot;
```

还有一个注意的地方是这题先给出了城市的信息再建图，所以我们必须把信息存下来等建完图之后再更新（~~应该没人和我翻一样的错误吧~~）


其他部分就是树剖板子加上线段树板子了（别忘了城市$x$在线段树上的编号是$id[x]$哦~）


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll maxn=100010;
const ll INF=2147483647;
struct SegmentTree
{
	ll ls,rs,sum,maxx;
}tree[maxn * 40];//参考主席树开40倍。
struct node
{
	ll val,rel;
}c[maxn];
ll n,m,a[maxn],q,root[maxn],x,y,icur;
ll dep[maxn],fa[maxn],son[maxn],tot;
ll id[maxn],top[maxn],size[maxn];
string cur;
vector<ll> e[maxn];
bool vis[maxn];
//下面是树剖
void dfs1(ll x,ll step)
{
	vis[x] = 1;
	dep[x] = step;
	size[x] = 1;
	ll tem = -1;
	for(int i = 0;i < e[x].size();i++)
	{
		if(!vis[e[x][i]])
		{
			dfs1(e[x][i],step + 1);
			fa[e[x][i]] = x;
			size[x] += size[e[x][i]];
			if(size[e[x][i]] > tem)
			{
				tem = size[e[x][i]];
				son[x] = e[x][i];
			}
		}
	}
	return;
}
void dfs2(ll x,ll topf)
{
	vis[x] = 1;
	top[x] = topf;
	id[x] = ++icur;
	if(!son[x])return;
	dfs2(son[x],topf);
	for(int i = 0;i < e[x].size();i++)
	{
		if(!vis[e[x][i]])
		{
			dfs2(e[x][i],e[x][i]);
		}
	}
	return;
}
//下面是动态开点线段树（所以没有build函数）
void push_up(ll p,ll ls,ll rs)
{
	tree[p].sum = tree[ls].sum + tree[rs].sum;
	tree[p].maxx = max(tree[ls].maxx,tree[rs].maxx);
	return;
}
void insert(ll &p,ll pos,ll l,ll r,ll det)
{
	if(!p)p = ++tot;
	if(l == r)//这里并不需要=pos，因为访问叶节点的时候一定是pos
	{
		tree[p].sum = det;
		tree[p].maxx = det;
		return;
	}
	ll mid = (l + r)>>1;
	if(pos <= mid)insert(tree[p].ls,pos,l,mid,det);
	else insert(tree[p].rs,pos,mid + 1,r,det);
	push_up(p,tree[p].ls,tree[p].rs);
	return;
}
void del(ll p,ll l,ll r,ll pos)
{
	if(!p)return;
	if(l == r)
	{
		tree[p].sum = 0;
		tree[p].maxx = 0;
		return;
	}
	ll mid = (l + r)>>1;
	if(pos <= mid)del(tree[p].ls,l,mid,pos);
	else del(tree[p].rs,mid + 1,r,pos);
	push_up(p,tree[p].ls,tree[p].rs);
	return;
}
void update(ll &p,ll l,ll r,ll pos,ll det)
{
	if(!p) p = ++tot;//动态开点
	if(l == r)
	{
		tree[p].sum = det;
		tree[p].maxx = det;
		return;
	}
	ll mid = (l + r)>>1;
	if(pos <= mid)update(tree[p].ls,l,mid,pos,det);
	else update(tree[p].rs,mid + 1,r,pos,det);
	push_up(p,tree[p].ls,tree[p].rs);
	return;
}
ll qsum(ll p,ll l,ll r,ll il,ll ir)
{
	if(!p)return 0;如果是空节点。
	if(il <= l && ir >= r)return tree[p].sum;
	ll mid = (l + r)>>1;
	ll res = 0;
	if(il <= mid)res += qsum(tree[p].ls,l,mid,il,ir);
	if(ir > mid)res += qsum(tree[p].rs,mid + 1,r,il,ir); 
	return res;
}
ll qmax(ll p,ll l,ll r,ll il,ll ir)
{
	if(!p)return 0;
	if(il <= l && ir >= r)return tree[p].maxx;
	ll mid = (l + r)>>1;
	ll res = -1;
	if(il <= mid)res = max(res,qmax(tree[p].ls,l,mid,il,ir));
	if(ir > mid)res = max(res,qmax(tree[p].rs,mid + 1,r,il,ir));
	return res;
}
ll qtresum(ll p,ll x,ll y)
{
	ll res = 0;
	while(top[x] != top[y])
	{
		if(dep[top[x]] < dep[top[y]])swap(x,y);
		res += qsum(p,1,n,id[top[x]],id[x]);
		x = fa[top[x]];
	}
	if(dep[x] > dep[y])swap(x,y);
	res += qsum(p,1,n,id[x],id[y]);
	return res;
}
ll qtremax(ll p,ll x,ll y)
{
	ll res = -1;
	while(top[x] != top[y])
	{
		if(dep[top[x]] < dep[top[y]])swap(x,y);
		res = max(res,qmax(p,1,n,id[top[x]],id[x]));
		x = fa[top[x]];
	}
	if(dep[x] > dep[y])swap(x,y);
	res = max(res,qmax(p,1,n,id[x],id[y]));
	return res;
}
int main()
{
	cin>>n>>m;
	for(int i = 1;i <= n;i++)
	{
		cin>>c[i].val>>c[i].rel;
	}
	for(int i = 1;i < n;i++)
	{
		cin>>x>>y;
		e[x].push_back(y);
		e[y].push_back(x);
	}
	fa[1] = 1;
	dfs1(1,1);
	memset(vis,0,sizeof(vis));
	dfs2(1,1);
	for(int i = 1;i <= n;i++)
	{
		insert(root[c[i].rel],id[i],1,n,c[i].val);//这里是id[i]，不要弄错了。
	}
	while(m--)//其他操作都和普通树剖差不多。
	{
		cin>>cur>>x>>y;
		if(cur[0] == 'Q')
		{
			if(cur[1] == 'S')
			{
				cout<<qtresum(root[c[x].rel],x,y)<<"\n";
			}
			else
			{
				cout<<qtremax(root[c[x].rel],x,y)<<"\n";
			}
		}
		else
		{
			if(cur[1] == 'C')
			{
				del(root[c[x].rel],1,n,id[x]);
				c[x].rel = y;
				update(root[c[x].rel],1,n,id[x],c[x].val);
			}
			else
			{
				c[x].val = y;
				del(root[c[x].rel],1,n,id[x]);
				update(root[c[x].rel],1,n,id[x],c[x].val);
			}
		}
	}
	return 0;
}
```


---

## 作者：__ZJ (赞：6)

### LCT，离线

考虑对于任意一个询问，  
如果我们<font color=red>只保留与该询问的宗教相同的点的信息在树上</font>,  
那么就是一个**简单的LCT**就可以解决的问题。

所以朝着这个方向思考，得到如下解法:  
**把操作和询问离线,   
依次对每种宗教从开始到结束做一遍。  
用链表按时间顺序存储与当前宗教有关的操作与询问。  
这样时间复杂度只与操作和询问数有关，$O(Mlog_2N)$ ** 
	
为保证复杂度，每次对一种宗教操作完后，不要直接memset那个LCT，  
（否则清空LCT的复杂度都是$O(C*N)$了）

而是应该反向遍历与该宗教有关的操作，去把树上的信息回退回去。
所以链表是双向的。  

（常数比树链剖分+线段树略大，但是代码比较好写啦）
```cpp
#include<bits/stdc++.h>
#define MAXN 100050
using namespace std;
int N,Q;
int ANS[MAXN];
struct LinkTable{//1:该分 2:查和 3:查最大值 
	int lnt;
	int t[MAXN*3],x[MAXN*3],y[MAXN*3],z[MAXN*3];
	int nxt[MAXN*3],pre[MAXN*3],head[MAXN],tail[MAXN];
	LinkTable(){lnt=2;}
	void Add(int c,int _t,int _x,int _y,int _z){
		t[lnt]=_t; x[lnt]=_x; y[lnt]=_y; z[lnt]=_z;
		if(!tail[c]) head[c]=lnt;
		else nxt[tail[c]]=lnt,pre[lnt]=tail[c];
		tail[c]=lnt++;
	}
}L;
struct LCT{
	bool lazy[MAXN];
	int fa[MAXN],ch[MAXN][2],num[MAXN],sum[MAXN],maxi[MAXN];
	bool Who(int x){return ch[fa[x]][0]!=x;}
	bool Isroot(int x){return ch[fa[x]][0]!=x&&ch[fa[x]][1]!=x;}
	void Reverse(int x){swap(ch[x][0],ch[x][1]),lazy[x]^=1;}
	void Pushup(int x){
		sum[x]=num[x]+sum[ch[x][0]]+sum[ch[x][1]];
		maxi[x]=max(num[x],max(maxi[ch[x][0]],maxi[ch[x][1]]));
	}
	void Pushdown(int x){
		if(!Isroot(x)) Pushdown(fa[x]);
		if(!lazy[x]) return;
		if(ch[x][0]) Reverse(ch[x][0]);
		if(ch[x][1] )Reverse(ch[x][1]);
		lazy[x]=0;
	}
	void Rotate(int x){
		static int y,z,l1,l2;
		y=fa[x]; z=fa[y];
		l1=Who(x); l2=Who(y); fa[x]=z;
		if(!Isroot(y)) ch[z][l2]=x;
		fa[ch[x][l1^1]]=y; fa[y]=x;
		ch[y][l1]=ch[x][l1^1]; ch[x][l1^1]=y;
		Pushup(y);
	}
	void Splay(int x){
		static int y; Pushdown(x);
		for(;y=fa[x],!Isroot(x);Rotate(x))
			if(!Isroot(y)) Rotate(Who(y)==Who(x)?y:x);
		Pushup(x);
	}
	void Access(int x){
		static int y;
		for(y=0;x;y=x,x=fa[x])
			Splay(x),ch[x][1]=y,Pushup(x);
	}
	void Moveroot(int x){
		Access(x); Splay(x); Reverse(x);
	}
	void Link(int x,int y){
		Moveroot(x); Splay(x); fa[x]=y;
	}
	void Modify(int x,int v){
		Splay(x); num[x]=v; Pushup(x);
	}
	int Querysum(int x,int y){
		Moveroot(y); Access(x); Splay(x);
		return sum[x];
	}
	int Querymax(int x,int y){
		Moveroot(y); Access(x); Splay(x);
		return maxi[x];
	}
}DT;
char gc(){
	static char s[200005],*p1,*p2;
	return p1==p2&&(p2=(p1=s)+fread(s,1,200000,stdin),p1==p2)?EOF:*p1++;
}
void read(int &x){
	static int sign; static char ch;
	x=0; sign=1; ch=gc();
	for(;ch<'0'||'9'<ch;ch=gc()) if(ch=='-') sign=-1;
	for(;'0'<=ch&&ch<='9';ch=gc()) x=x*10+ch-'0';
	if(sign==-1) x=-x;
}
void read(char &ch){
	ch=gc(); for(;ch<'A'||'Z'<ch;ch=gc());
}
int main(){
	//freopen("in","r",stdin);
	char ch;
	static int bel[MAXN],sco[MAXN],qnt;
	read(N); read(Q);
	for(int i=1;i<=N;i++)
		read(sco[i]),read(bel[i]),L.Add(bel[i],1,i,sco[i],0);
	for(int i=1,a,b;i<N;i++)
		read(a),read(b),DT.Link(a,b);
	for(int i=1,a,b;i<=Q;i++){
		read(ch),read(ch);
		read(a),read(b);
		switch(ch){
			case 'C' :
				if(bel[a]==b) break;
				L.Add(b,1,a,sco[a],0);
				L.Add(bel[a],1,a,0,sco[a]);
				bel[a]=b; break;
			case 'W' : L.Add(bel[a],1,a,b,sco[a]); sco[a]=b; break;
			case 'S' : L.Add(bel[a],2,a,b,++qnt); break;
			case 'M' : L.Add(bel[a],3,a,b,++qnt); break;
		}
	}
	for(int c=1;c<=100000;c++){
		assert(DT.sum[1]==0); assert(DT.sum[N]==0); assert(DT.sum[N/2]==0);
		for(int l=L.head[c];l;l=L.nxt[l]){
			if(L.t[l]==1) DT.Modify(L.x[l],L.y[l]);
			if(L.t[l]==2) ANS[L.z[l]]=DT.Querysum(L.x[l],L.y[l]);
			if(L.t[l]==3) ANS[L.z[l]]=DT.Querymax(L.x[l],L.y[l]);
		}
		for(int l=L.tail[c];l;l=L.pre[l])
			if(L.t[l]==1) DT.Modify(L.x[l],L.z[l]);
	}
	for(int i=1;i<=qnt;i++) printf("%d\n",ANS[i]);
	return 0;
}
```

---

## 作者：lx_zjk (赞：4)

# P3313 [SDOI2014]旅行

1."CC x c":城市x的居民全体改信了c教;

2."CW x w":城市x的评级调整为w;

3."QS x y":一位旅行者从城市x出发,到城市y,并记下了途中留宿过的城市的评级总和;

4."QM x y":一位旅行者从城市x出发,到城市y,并记下了途中留宿过的城市的评级最大值;

如果没有颜色的限制的话,这道题其实就是裸的树链剖分题目,但是有了颜色的限制,如果这道题加上了颜色的限制,那么最暴力的想法就是开$1e5$颗线段树,显然 $4 * 1E5 * 1E5$ $MLE$预定,那么这道题就是线段树的动态开点~~我觉得像主席树~~加上树链剖分;

### $part$ $one$
#### 1."CC x c":城市x的居民全体改信了c教;

修改他的教,那么首先先要在原先的教里把他踢出,然后把他的教改为c,在主席树上加上他
```cpp
void solve_c(int l, int r) {
	delet(root[c[l]], id[l], 1, n);
	c[l] = r;
	insert(root[c[l]], id[l], 1, n, w[l]);
}
```
------------
### $part$ $two$

#### 2."CW x w":城市x的评级调整为w;

与第一部分类似,这里就不细讲了
```cpp
void solve_w(int l, int r) {
	delet(root[c[l]], id[l], 1, n);
	w[l] = r;
	insert(root[c[l]], id[l], 1, n, w[l]);
}
```

### $part$ $three$ $&&$ $four$
普通的树剖 + 线段树,还是比较简单的

在会了这四个操作后可以自行实现$delete$,$insert$,$update$,$querysum$,$querymax$函数

综合以上 此题鉴定为码农题

------------

完整版

# code

```cpp
#include <cstdio>
#include <algorithm>

using namespace std;

typedef long long ll;

inline ll read() {
    ll f = 1, x = 0;char ch;
    do {ch = getchar();if (ch == '-')f = -1;} while (ch > '9' || ch < '0');
    do {x = x * 10 + ch - '0';ch = getchar();} while (ch >= '0' && ch <= '9');
    return f * x;
}

const int MAX_N = 1e5 + 7;

struct Edge{
	int to, next;
}edge[MAX_N << 2];

int head[MAX_N], cnt;

inline void addedge(int u, int v){
	edge[++cnt].to = v;
	edge[cnt].next = head[u];
	head[u] = cnt;
}

int n, m, w[MAX_N], c[MAX_N]; 

int top[MAX_N], size[MAX_N], id[MAX_N], dep[MAX_N], fa[MAX_N], son[MAX_N], root[MAX_N];

void dfs(int u) {
	dep[u] = dep[fa[u]] + 1;
	size[u] = 1;
	for (int i = head[u]; i; i = edge[i].next) {
		int v = edge[i].to;
		if (v == fa[u]) continue;
		fa[v] = u;
		dfs(v);
		size[u] += size[v];
		if (size[son[u]] < size[v]) son[u] = v;
	}
}

void dfsn(int u, int y) {
	top[u] = y;
	id[u] = (++cnt);
	if (son[u]) dfsn(son[u], y);
	for (int i = head[u]; i; i = edge[i].next) {
		int v = edge[i].to;
		if (v == son[u] || fa[u] == v) continue;
		dfsn(v, v);
	}
}

struct segment_tree{
	int l, r;
	ll sum, maxx;
}t[MAX_N * 40];

/*
"CC x c":城市x的居民全体改信了c教;

"CW x w":城市x的评级调整为w;

"QS x y":一位旅行者从城市x出发,到城市y,并记下了途中留宿过的城市的评级总和;

"QM x y":一位旅行者从城市x出发,到城市y,并记下了途中留宿过的城市的评级最大值;
*/

void insert(int &p, int x, int l, int r, int v) {
	if (!p) p = (++cnt);
	if (l == r) {
		t[p].sum = t[p].maxx = v;
		return;
	}
	int mid = (l + r) >> 1;
	if (x <= mid)
		insert(t[p].l, x, l, mid, v);
	else 
		insert(t[p].r, x, mid + 1, r, v);
	t[p].maxx = max(t[t[p].l].maxx, t[t[p].r].maxx);
	t[p].sum = t[t[p].l].sum + t[t[p].r].sum;
}

void delet(int p, int x, int l, int r) {
	if (!p) return;
	if (l == r) {
		t[p].maxx = t[p].sum = 0;
		return;
	}
	int mid = (l + r) >> 1;
	if (x <= mid)
		delet(t[p].l, x, l, mid);
	else 
		delet(t[p].r, x, mid + 1, r);
	t[p].maxx = max(t[t[p].l].maxx, t[t[p].r].maxx);
	t[p].sum = t[t[p].l].sum + t[t[p].r].sum;
}

void update(int p, int x, int l, int r, int v) {
	if (!p) 
		p = (++cnt);
	if (l == r) {
		t[p].sum = t[p].maxx = v;
		return;
	}
	int mid = (l + r) >> 1;
	if (x <= mid)
		update(t[p].l, x, l, mid, v);
	else 
		update(t[p].r, x, mid + 1, r, v);
	t[p].maxx = max(t[t[p].l].maxx, t[t[p].r].maxx);
	t[p].sum = t[t[p].l].sum + t[t[p].r].sum;
}

ll query_sum(int p, int l, int r, int x, int y) {
	if (!p) return 0;
	if (x <= l && r <= y) 
		return t[p].sum;
	int mid = (l + r) >> 1;
	ll ans = 0;
	if (x <= mid) 
		ans += query_sum(t[p].l, l, mid, x, y);
	if (y > mid) 
		ans += query_sum(t[p].r, mid + 1, r, x, y);
	return ans;
}

ll query_max(int p, int l, int r, int x, int y) {
	if (!p) return -1e9;
	if (x <= l && r <= y) return t[p].maxx;
	int mid = (l + r) >> 1;
	ll ans = -1e9;
	if (x <= mid)
		ans = max(ans, query_max(t[p].l, l, mid, x, y));
	if (y > mid)
		ans = max(ans, query_max(t[p].r, mid + 1, r, x, y));
	return ans;
}

ll get_sum(int p, int x, int y) {
	ll ans = 0;
	while(top[x] != top[y]) {
		if (dep[top[x]] < dep[top[y]]) 
			swap(x, y);
		ans += query_sum(p, 1, n, id[top[x]], id[x]);
		x = fa[top[x]];
	}
	if (dep[x] > dep[y]) 
		swap(x, y);
	ans += query_sum(p, 1, n, id[x], id[y]);
	return ans;
}

ll get_max(int p, int x, int y) {
	ll ans = -1e9;
	while(top[x] != top[y]) {
		if (dep[top[x]] < dep[top[y]]) 
			swap(x, y);
		ans = max(ans, query_max(p, 1, n, id[top[x]], id[x]));
		x = fa[top[x]];
	}
	if (dep[x] > dep[y]) 
		swap(x, y);
	ans = max(ans, query_max(p, 1, n, id[x], id[y]));
	return ans;
}

void solve_c(int l, int r) {
	delet(root[c[l]], id[l], 1, n);
	c[l] = r;
	insert(root[c[l]], id[l], 1, n, w[l]);
}

void solve_w(int l, int r) {
	delet(root[c[l]], id[l], 1, n);
	w[l] = r;
	insert(root[c[l]], id[l], 1, n, w[l]);
}

void solve_s(int l, int r) {
	printf("%lld\n", get_sum(root[c[l]], l, r));
}

void solve_m(int l, int r) {
	printf("%lld\n", get_max(root[c[l]], l, r));
}

int main() {
	n = read(); m = read();
	for (int i = 1; i <= n; i ++ ) {
		w[i] = read();
		c[i] = read();
	}
	for (int i = 1; i < n; i ++ ) {
		int x = read();
		int y = read();
		addedge(x, y);
		addedge(y, x);
	}
	dfs(1); 
	cnt = 0; 
	dfsn(1, 1);
	for (int i = 1; i <= n; i ++ ) 
		insert(root[c[i]], id[i], 1, n, w[i]);
	for (int i = 1; i <= m; i ++ ) {
		char opt[10];
		scanf("%s", opt);
		int l = read(), r = read();
		if (opt[1] == 'C') 
			solve_c(l, r);
		if (opt[1] == 'W') 
			solve_w(l, r);
		if (opt[1] == 'S') 
			solve_s(l, r);
		if (opt[1] == 'M') 
			solve_m(l, r);
	}
	return 0;
}
```

---

## 作者：devout (赞：3)

[博客内食用更佳](https://blog.csdn.net/devout_/article/details/104396101)

拿到这题，我：树链剖分+线段树！

哎呀C有点大。

动态开点！

不会RE吗...

其实是可能会RE的，为什么呢，我们想，最坏情况是每个点有不同的信仰，那么这个时候我们利用的空间是$n\log n$ 当$n$最坏情况下取$10^5$时，占用空间是$13.2\times10^5$左右，加上修改需要两倍的空间那么应该保险起见线段树需要开27倍左右，但是我看题解里面好像都是开的20倍，有哪位大佬能给我解释一下吗qwq。

开27倍空间也许会MLE，为了保险起见，我用了一个还挺好写的一个优化，就是开一个队列，队列里面存的是之前已经删掉了那些点，当我们要新加入一个点的时候，首先看这个队列里面有没有值，如果有就往那个位置上存，否则就++tot。

大概写出来是这个样子滴：

```cpp
queue<int> trashcan;

int _new(){
	if(trashcan.empty())return ++tot;
	int x=trashcan.front();trashcan.pop();
	return x;
}

void clear(int u){
	seg[u].lc=seg[u].rc=0;
	seg[u].sum=seg[u]._max=0;
	trashcan.push(u);	
}
```

然后就正常的动态开点维护就可以了

这样开20倍空间就没有问题啦

```cpp
# include <bits/stdc++.h>
using namespace std;

# define Rep(i,a,b) for(int i=a;i<=b;i++)
# define _Rep(i,a,b) for(int i=a;i>=b;i--)
# define RepG(i,u) for(int i=head[u];~i;i=e[i].next)
const int N=1e5+5;
template <typename T> void read(T &x){
	x=0;int f=1;
	char c=getchar();
	for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
	for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+c-'0';
	x*=f;
}

int n,m;
int head[N],cnt;
int belief[N],lv[N];
int faz[N],son[N],dep[N],siz[N],top[N],dfn[N],dfx;
int root[N],tot;
queue<int> trashcan;

struct Edge{
	int to,next;
}e[N<<1];

void add(int x,int y){
	e[++cnt]=(Edge){y,head[x]},head[x]=cnt;	
}

struct segment_tree{
	int lc,rc;
	int sum,_max;	
}seg[N*20];

void pushup(int u){
	seg[u].sum=seg[seg[u].lc].sum+seg[seg[u].rc].sum;
	seg[u]._max=max(seg[seg[u].lc]._max,seg[seg[u].rc]._max);	
}

int _new(){
	if(trashcan.empty())return ++tot;
	int x=trashcan.front();trashcan.pop();
	return x;
}

void clear(int u){
	seg[u].lc=seg[u].rc=0;
	seg[u].sum=seg[u]._max=0;
	trashcan.push(u);	
}

int insert(int u,int l,int r,int x,int k){
	if(!u)u=_new();
	if(l==r){
		seg[u].sum=seg[u]._max=k;
		return u;
	}
	int mid=l+r>>1;
	if(x<=mid)seg[u].lc=insert(seg[u].lc,l,mid,x,k);
	else seg[u].rc=insert(seg[u].rc,mid+1,r,x,k);
	pushup(u);
	return u;
}

int erase(int u,int l,int r,int x){
	if(l==r){
		clear(u);
		return 0;
	}
	int mid=l+r>>1;
	if(x<=mid)seg[u].lc=erase(seg[u].lc,l,mid,x);
	else seg[u].rc=erase(seg[u].rc,mid+1,r,x);
	pushup(u);
	if(!seg[u].lc&&!seg[u].rc){
		clear(u);
		u=0;	
	}
	return u;
}

int Getsum(int u,int l,int r,int ql,int qr){
	if(l>=ql&&r<=qr)return seg[u].sum;
	int mid=l+r>>1;
	int res=0;
	if(ql<=mid&&seg[u].lc)res+=Getsum(seg[u].lc,l,mid,ql,qr);
	if(qr>mid&&seg[u].rc)res+=Getsum(seg[u].rc,mid+1,r,ql,qr);
	return res;	
}

int Getmax(int u,int l,int r,int ql,int qr){
	if(l>=ql&&r<=qr)return seg[u]._max;
	int mid=l+r>>1;
	int res=0;
	if(ql<=mid&&seg[u].lc)res=max(res,Getmax(seg[u].lc,l,mid,ql,qr));
	if(qr>mid&&seg[u].rc)res=max(res,Getmax(seg[u].rc,mid+1,r,ql,qr));
	return res;	
}

void BeliefModify(int x,int y){
	root[belief[x]]=erase(root[belief[x]],1,n,dfn[x]);
	belief[x]=y;
	root[belief[x]]=insert(root[belief[x]],1,n,dfn[x],lv[x]);
}

void LevelModify(int x,int y){
	lv[x]=y;
	root[belief[x]]=insert(root[belief[x]],1,n,dfn[x],lv[x]);	
}

void RouteQuerySum(int x,int y){
	int res=0,be=belief[y];
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		res+=Getsum(root[be],1,n,dfn[top[x]],dfn[x]);
		x=faz[top[x]];
	}
	if(dep[x]>dep[y])swap(x,y);
	res+=Getsum(root[be],1,n,dfn[x],dfn[y]);
	printf("%d\n",res);
}

void RouteQueryMax(int x,int y){
	int res=0,be=belief[y];
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		res=max(res,Getmax(root[be],1,n,dfn[top[x]],dfn[x]));
		x=faz[top[x]];
	}
	if(dep[x]>dep[y])swap(x,y);
	res=max(res,Getmax(root[be],1,n,dfn[x],dfn[y]));
	printf("%d\n",res);
}

void dfs1(int u,int fa){
	faz[u]=fa;
	siz[u]=1;
	dep[u]=dep[fa]+1;
	RepG(i,u){
		int v=e[i].to;
		if(v==fa)continue;
		dfs1(v,u);
		siz[u]+=siz[v];
		if(siz[v]>siz[son[u]])son[u]=v;
	}
}

void dfs2(int u,int _top){
	top[u]=_top;
	dfn[u]=++dfx;
	if(!son[u])return;
	dfs2(son[u],_top);
	RepG(i,u){
		int v=e[i].to;
		if(v==faz[u]||v==son[u])continue;
		dfs2(v,v);
	}
}

int main()
{
	memset(head,-1,sizeof(head));
	read(n),read(m);
	Rep(i,1,n)read(lv[i]),read(belief[i]);
	Rep(i,1,n-1){
		int x,y;
		read(x),read(y);
		add(x,y),add(y,x);
	}
	dfs1(1,0),dfs2(1,1);
	Rep(i,1,n)root[belief[i]]=insert(root[belief[i]],1,n,dfn[i],lv[i]);
	Rep(i,1,m){
		char opt[10];
		int x,y;
		scanf("%s%d%d",opt,&x,&y);
		if(opt[0]=='C')
			if(opt[1]=='C')BeliefModify(x,y);
			else LevelModify(x,y);
		else 
			if(opt[1]=='S')RouteQuerySum(x,y);
			else RouteQueryMax(x,y);
	}
	return 0;
}
```


---

## 作者：Newuser (赞：3)

最近学了树链剖分，又可以做好多好多难题水题真是恶心开心！！！

luogu上的主席树标签迷惑了我好久，，，结果好像只用到了主席树的思想，主席树的操作根本没有….

没有宗教的限制，这道题就是树剖的SUM和MAX操作。但是，也很容易想到，对于每一个宗教就建一颗树，于是就可以每次都能够进行查询每个宗教的东西了。很明显，空间爆炸呀，动态开点就来咯！这里用到一个主席树思想就是每一个宗教建一颗树，可能也算是勉强有主席树元素吧。

注意一些小操作-》如果某个点改宗教，原宗教线段树里直接改成0，然后记录下w，返回到新的宗教线段树里就可以了

以及！！！修改原来的宗教数组（也只有菜鸡如我才会搞忘），恩，数组开大一点。

认真写，没有写出小bug这道题还是挺简单的，树剖板子题一道，写出bug，呵呵，慢慢调吧。

	#include<cstdio>
	#include<algorithm>
	#define midd ((l+r)>>1)
	using namespace std;
	const int maxn=100005;
	int n,q;
	int oldw[maxn],oldc[maxn];
	int la[maxn<<1],nt[maxn<<1],en[maxn<<1],owo;
	inline void addedge(int a,int b)
	{en[++owo]=b; nt[owo]=la[a]; la[a]=owo;}
	//
	int 	size[maxn],dep[maxn],zerz[maxn],top[maxn],newid[maxn],fa[maxn],oldid[maxn],idcnt;
	void fzb(int x,int ba)
	{
	dep[x]=dep[ba]+1;
	int maxsize=0; size[x]=1; zerz[x]=0;
	for(int it=la[x];it;it=nt[it])
	{
		if(en[it]==ba) continue;
		fa[en[it]]=x;
		fzb(en[it],x);
		size[x]+=size[en[it]];
		if(size[en[it]]>maxsize)
		{
			maxsize=size[en[it]];
			zerz[x]=en[it];
		}
	}
	}
	void lzb(int x,int ace)
	{
	newid[x]=++idcnt; top[x]=ace;
	if(zerz[x]) lzb(zerz[x],ace);
	for(int it=la[x];it;it=nt[it])
	{
		if(en[it]==fa[x]||en[it]==zerz[x]) continue;
		lzb(en[it],en[it]);
	}
	}
	//
	int tot,rt[maxn];
	struct node
	{
	int sumw,maxw,ls,rs;
	}z[maxn<<5];
	inline void putup(int p)
	{
	z[p].maxw=max(z[z[p].ls].maxw,z[z[p].rs].maxw);
	z[p].sumw=z[z[p].ls].sumw+z[z[p].rs].sumw;
	}
	void ins(int &p,int oid,int ww,int l,int r)
	{
	if(!p) p=++tot;
	if(l==r) { z[p].sumw=z[p].maxw=ww; return; }
	if(oid<=midd) ins(z[p].ls,oid,ww,l,midd);
	else ins(z[p].rs,oid,ww,midd+1,r);
	putup(p);
	}
	void del(int &p,int oid,int &ww,int l,int r)
	{
	if(!p) p=++tot;
	if(l==r) { ww=z[p].sumw; z[p].sumw=z[p].maxw=0; return; }
	if(oid<=midd) del(z[p].ls,oid,ww,l,midd);
	else del(z[p].rs,oid,ww,midd+1,r);
	putup(p);
	}
	int qsum(int &p,int x,int y,int l,int r)
	{
	if(!p) p=++tot;
	if(x<=l&&r<=y) return z[p].sumw;
	int sss=0;
	if(x<=midd&&y>=l) sss+=qsum(z[p].ls,x,y,l,midd);
	if(x<=r&&y>midd) sss+=qsum(z[p].rs,x,y,midd+1,r);
	return sss;
	}
	int qmax(int &p,int x,int y,int l,int r)
	{
	if(!p) p=++tot;
	if(x<=l&&r<=y) return z[p].maxw;
	int sss=0;
	if(x<=midd&&y>=l) sss=max(sss,qmax(z[p].ls,x,y,l,midd));
	if(x<=r&&y>midd) sss=max(sss,qmax(z[p].rs,x,y,midd+1,r));
	return sss;
	}
	//
	int querysum(int cc,int x,int y)
	{
	int sss=0;
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		sss+=qsum(rt[cc],newid[top[x]],newid[x],1,n);
		x=fa[top[x]];
	}
	if(dep[x]>dep[y]) swap(x,y);
	sss+=qsum(rt[cc],newid[x],newid[y],1,n);
	return sss;
	}
	int querymax(int cc,int x,int y)
	{
	int sss=0;
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		sss=max(sss,qmax(rt[cc],newid[top[x]],newid[x],1,n));
		x=fa[top[x]];
	}
	if(dep[x]>dep[y]) swap(x,y);
	sss=max(sss,qmax(rt[cc],newid[x],newid[y],1,n));
	return sss;
	}
	//
	int main()
	{
	int a,b,aha;
	scanf("%d%d",&n,&q);
	for(int i=1;i<=n;i++) { scanf("%d%d",&oldw[i],&oldc[i]); }
	for(int i=1;i<=n-1;i++)	
	{
		scanf("%d%d",&a,&b);
		addedge(a,b); addedge(b,a);
	}
	fzb(1,0); lzb(1,1);
	for(int i=1;i<=n;i++)
		ins(rt[oldc[i]],newid[i],oldw[i],1,n);
	char ss[3];
	while(q--)
	{
		scanf("%s%d%d",ss,&a,&b);
		if(ss[1]=='S')
		{
			printf("%d\n",querysum(oldc[a],a,b));
		}
		else if(ss[1]=='C')
		{
			del(rt[oldc[a]],newid[a],aha,1,n);
			ins(rt[b],newid[a],aha,1,n);
			oldc[a]=b;
		}
		else if(ss[1]=='W')
		{
			ins(rt[oldc[a]],newid[a],b,1,n);
		}
		else if(ss[1]=='M')
		{
			printf("%d\n",querymax(oldc[a],a,b));
		}
	}
	}

少有的一道一个小时就搞出来了的数据结构题。。。
//欢迎大家光顾蒟蒻博客http://www.newuser.top/

---

## 作者：Dispwnl (赞：3)

看了楼下的题解

终于A了~~哈哈哈哈~~。。。

有多少个宗教就建几个线段树

具体操作前人之述备矣~~所以我就懒得写了~~

主要是说几个坑点

数组要开大一点（1e5\*32差不多）

建树时注意树与树之间会重叠

区间查询时只查询与出发点信仰相同的点~~然而样例水到能过~~

如查询1->3->5

5与1信仰相同

3不同

所以3不查询

还有单点修改时记得储存

不能只把线段树中的点修改

原点也要修改~~多么zz的提醒~~

然后差不多了

耐着性子打完吧

我打了198行还慢的要死。。。

```cpp
# include<iostream>
# include<cstdio>
# include<cstring>
# include<algorithm> 
# include<queue>
# include<cmath>
#define mid ((l+r)>>1)
#define tl c[k].l
#define tr c[k].r
#define ini inline int
#define inv inline void
#define ge getchar()
#define is isdigit(ch)
#define cn(a) string a;cin>>a
using namespace std;
const int MAX=1e5+1;
struct p{
    int x,maxn,l,r;
}c[MAX<<5];
struct q{
    int x,y;
}C[MAX<<1];
struct o{
    int deep,id,siz,son,fa,top,w,belief;
}cc[MAX];
int n,m,num,cnt,tot;
int h[MAX],rt[MAX];
ini max(int x,int y)
{
    return x>y?x:y;
}
ini read()
{
    int x=0,f=1;
    char ch=ge;
    while(!is)
    {
        if(ch=='-') f=-1;
        ch=ge;
    }
    while(is)
    {
        x=x*10+ch-48;
        ch=ge;
    }
    return x*f;
}
inv add(int x,int y)
{
    C[++num].x=h[x];
    C[num].y=y;
    h[x]=num;
}
inv pus(int k)
{
    c[k].maxn=max(c[tl].maxn,c[tr].maxn);
    c[k].x=c[tl].x+c[tr].x;
}
void dfs(int x,int f)
{
    cc[x].deep=cc[f].deep+1;
    cc[x].fa=f;
    cc[x].siz=1;
    for(int i=h[x];i;i=C[i].x)
      {
          int y=C[i].y;
          if(y==f) continue;
          dfs(y,x);
          cc[x].siz+=cc[y].siz;
          if(cc[y].siz>cc[cc[x].son].siz)
          cc[x].son=y;
      }
}
void dfs1(int x,int tp)
{
    cc[x].top=tp;
    cc[x].id=++cnt;
    if(cc[x].son) dfs1(cc[x].son,tp);
    for(int i=h[x];i;i=C[i].x)
      {
          int y=C[i].y;
          if(y==cc[x].fa||y==cc[x].son)
          continue;
          dfs1(y,y);
      }
}
void build(int x,int y,int l,int r,int &k)
{
    if(!k) k=++tot;
    if(l==r)
    {
        c[k].maxn=c[k].x=x;
        return;
    }
    if(y<=mid) build(x,y,l,mid,tl);
    else build(x,y,mid+1,r,tr);
    pus(k);
}
void cut(int x,int l,int r,int &k)
{
    if(l==r)
    {
        c[k].maxn=c[k].x=c[k].l=c[k].r=0;
        k=0;
        return;
    }
    if(x<=mid) cut(x,l,mid,tl);
    else cut(x,mid+1,r,tr);
    pus(k);
    if(!tr&&!tl)
    {
        c[k].maxn=c[k].x=c[k].l=c[k].r=0;
        k=0;
    }
}
int ask_max(int l,int r,int k,int L,int R)
{
    if(!k) return 0;
    if(l>=L&&r<=R) return c[k].maxn;
    if(l>R||r<L) return 0;
    return max(ask_max(l,mid,tl,L,R),ask_max(mid+1,r,tr,L,R));
}
int ask_sum(int l,int r,int k,int L,int R)
{
    if(!k) return 0;
    if(l>=L&&r<=R) return c[k].x;
    if(l>R||r<L) return 0;
    return ask_sum(l,mid,tl,L,R)+ask_sum(mid+1,r,tr,L,R);
}
inv CHANGE(int x,int y)
{
    cc[x].w=y;
    build(y,cc[x].id,1,n,rt[cc[x].belief]);
}
inv CUT(int x,int y)
{
    cut(cc[x].id,1,n,rt[cc[x].belief]);
    cc[x].belief=y;
    build(cc[x].w,cc[x].id,1,n,rt[cc[x].belief]);
}
ini ASK_MAX(int x,int y)
{
    int ans=0,RT=cc[x].belief;
    while(cc[x].top!=cc[y].top)
    {
        if(cc[cc[x].top].deep<cc[cc[y].top].deep)
        swap(x,y);
        ans=max(ans,ask_max(1,n,rt[RT],cc[cc[x].top].id,cc[x].id));
        x=cc[cc[x].top].fa;
    }
    if(cc[x].deep>cc[y].deep) swap(x,y);
    ans=max(ans,ask_max(1,n,rt[RT],cc[x].id,cc[y].id));
    return ans;
}
ini ASK_SUM(int x,int y)
{
    int ans=0,RT=cc[x].belief;
    while(cc[x].top!=cc[y].top)
    {
        if(cc[cc[x].top].deep<cc[cc[y].top].deep)
        swap(x,y);
        ans+=ask_sum(1,n,rt[RT],cc[cc[x].top].id,cc[x].id);
        x=cc[cc[x].top].fa;
    }
    if(cc[x].deep>cc[y].deep) swap(x,y);
    ans+=ask_sum(1,n,rt[RT],cc[x].id,cc[y].id);
    return ans;
}
int main()
{
    n=read(),m=read();
    for(int i=1;i<=n;i++)
      cc[i].w=read(),cc[i].belief=read();
    for(int i=1;i<n;i++)
      {
          int x=read(),y=read();
          add(x,y);
          add(y,x);
      }
    dfs(1,0);
    dfs1(1,1);
    for(int i=1;i<=n;i++)
      build(cc[i].w,cc[i].id,1,n,rt[cc[i].belief]);
    for(int i=1;i<=m;i++)
      {
          cn(a);
          int x=read(),y=read();
          if(a=="CC")
          CUT(x,y);
          if(a=="CW")
          CHANGE(x,y);
          if(a=="QS")
          printf("%d\n",ASK_SUM(x,y));
          if(a=="QM")
          printf("%d\n",ASK_MAX(x,y));
      }
    return 0;
}
```

---

## 作者：Treaker (赞：2)

$$\color{Cornflowerblue}{\mathcal{Treaker}}$$
## 树链剖分
一道题一眼看上去肯定是个树剖，但是树剖的难点在于怎么高效维护信息，题面里的查询都是很普通的，但是多了宗教，~~清真~~。

宗教的维护是个重点，但是我们又发现，宗教之间是互不影响的。

并且查询是在一个宗教之间的。那么我们是不是可以考虑对于每个宗教开一颗线段树来维护呢？

答案是肯定的。但本题内存限制125MB，怎么办呢，建$1e5$颗线段树肯定会炸。

动态开点啊，然后就没了。

完整代码如下：
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <queue>
using namespace std;
const int N = 100010;
inline int read()
{
	int x = 0 , f = 1;	char ch = getchar();
	while(ch < '0' || ch > '9')	{if(ch == '-')	f = -1; ch = getchar();}
	while(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}
	return x * f;
}
int n , m , cnt;
int deg[N] , c[N] , size[N] , dep[N] , dfn[N] , id[N] , hs[N] , fa[N] , top[N];
char s[5];
struct Tree_div
{
	struct Edge
	{
		int to;Edge *nxt;
		Edge(int to,Edge *nxt) : to(to) , nxt(nxt) {}
	}*head[N];
	void get_tree(int now)
	{
		size[now] = 1;
		for(Edge *i = head[now];i;i = i -> nxt)
		{
			int to = i -> to;
			if(dep[to] || to == 1)	continue;
			dep[to] = dep[now] + 1;
			fa[to] = now;
			get_tree(to);
			size[now] += size[to];
			if(size[to] > size[hs[now]]) hs[now] = to;
		}
	}
	void dfs(int now,int topfa)
	{
		dfn[now] = ++cnt;
		id[cnt] = now;
		top[now] = topfa;
		if(hs[now])	dfs(hs[now],topfa);
		for(Edge *i = head[now];i;i = i -> nxt)
		{
			int to = i -> to;
			if(to == hs[now] || to == fa[now])	continue;
			dfs(to,to);
		}
	}
	#define mid ((p -> l + p -> r) >> 1)
	struct node
	{
		node *ls , *rs;
		int l , r , sum , maxn;
		node(int l,int r) : l(l) , r(r) {ls = rs = NULL;sum = maxn = 0;}
		inline void up() {sum = (ls ? ls -> sum : 0) + (rs ? rs -> sum : 0); maxn = max((ls ? ls -> maxn : 0),(rs ? rs -> maxn : 0));}
	}*root[N];
	void chenge(node *&p,int l,int r,int x,int val)
	{
		if(!p)	p = new node(l,r);
		if(l == r)	return (void)(p -> sum = val,p -> maxn = val);
		if(x <= mid)	chenge(p -> ls,l,mid,x,val);
		else chenge(p -> rs,mid+1,r,x,val);
		p -> up();
	}
	int query_sum(node *p,int x,int y)
	{
		if(!p)	return 0;
		if(x <= p -> l && p -> r <= y)	return p -> sum; int res = 0;
		if(x <= mid)	res += query_sum(p -> ls,x,y);
		if(y > mid)		res += query_sum(p -> rs,x,y);
		return res;
	}
	inline int sec_sum(int x,int y)
	{
		int res = 0 , tmp = c[x];
		while(top[x] != top[y])
		{
			if(dep[top[x]] < dep[top[y]])	swap(x,y);
			res += query_sum(root[tmp],dfn[top[x]],dfn[x]);
			x = fa[top[x]];
		}
		if(dep[x] < dep[y])	swap(x,y);
		res += query_sum(root[tmp],dfn[y],dfn[x]);
		return res;
	}
	int query_max(node *p,int x,int y)
	{
		if(!p)	return 0;
		if(x <= p -> l && p -> r <= y)	return p -> maxn; int res = 0;
		if(x <= mid)	res = max(res,query_max(p -> ls,x,y));
		if(y > mid)		res = max(res,query_max(p -> rs,x,y));
		return res;
	}
	inline int sec_max(int x,int y)
	{
		int res = 0 , tmp = c[x];
		while(top[x] != top[y])
		{
			if(dep[top[x]] < dep[top[y]])	swap(x,y);
			res = max(res,query_max(root[tmp],dfn[top[x]],dfn[x]));
			x = fa[top[x]];
		}
		if(dep[x] < dep[y])	swap(x,y);
		res = max(res,query_max(root[tmp],dfn[y],dfn[x]));
		return res;
	}
	inline void LOL()
	{
		n = read(); m = read();
		for(int i = 1;i <= n;i ++)	deg[i] = read() , c[i] = read();
		for(int i = 1 , u , v;i < n;i ++)
		{
			u = read(); v = read();
			head[u] = new Edge(v,head[u]); head[v] = new Edge(u,head[v]);
		}
		get_tree(1);
		dfs(1,1);
		for(int i = 1;i <= n;i ++)	chenge(root[c[i]],1,n,dfn[i],deg[i]);
		for(int i = 1 , x , y;i <= m;i ++)
		{
			scanf("%s",s); x = read(); y = read();
			if(s[1] == 'C')
			{
				chenge(root[c[x]],1,n,dfn[x],0);
				chenge(root[y],1,n,dfn[x],deg[x]);
				c[x] = y;
			}
			else if(s[1] == 'W')
			{
				deg[x] = y;
				chenge(root[c[x]],1,n,dfn[x],y);
			}
			else if(s[1] == 'S') printf("%d\n",sec_sum(x,y));
			else printf("%d\n",sec_max(x,y));
		}
	}
}DNF;
int main()
{
	DNF.LOL();
	return 0;
}

```


---

## 作者：magolor (赞：2)

来一波题解：

官方正解：虚树LCT（代码复杂度=2147483647）

其他解法：主席树（这道题看上去好像并不能用主席树）

C棵线段树（不想算空间复杂度）

为啥不离线做呢？出题人的第二正解就是离线啊！


操作读进来拆分一下按宗教第一关键字，时间第二关键字排序。

先线性模拟一遍过程，搞清楚哪个操作是在哪个宗教上进行的，然后：

初始化不用说；

改宗教a为b就是把在a宗教下点权置0，b宗教下点权（从0）变为原点权；

改权值就找到这个点在进行这次操作时所属宗教，然后直接修改，查询同理。


树剖+线段树维护一下最大值和求和，因为宗教不同要清零，所以加一个lazy tag

不需要区间修改，lazy\_tag只用来清零线段树，就不需要写区间修改了（详见Segment\_Tree.Clear()）

所有的量都要记录时间，答案也是，pair<int,int>存第一关键字为时间，都做完把ans都sort一下就出来了


本人代码里定义了较多的结构体：节点、边、线段树、操作、答案（答案是defind了pair<int,int>）

有一定的压行和小优化技巧，树剖啥的可以过去，重点理解130行以下的部分：如何离线处理的。

个人认为写得挺清楚，挺整齐的，也不长。







    
    
    
    



```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
#define MAXN 500000
#define mx(x) t[x].mx
#define sm(x) t[x].sm
#define lz(x) t[x].lz
#define lc(x) (x<<1)
#define rc(x) ((x<<1)|1)
#define mid ((lef+rig)>>1)
#define Ans pair<int,int>
#define gc() getchar()
inline int read(int ans = 0, int sgn = ' ', int ch = gc())
{
    for(;ch < '0' || ch > '9'; sgn=ch,ch=gc());
    for(;ch >='0' && ch <='9'; (ans*=10)+=ch-'0',ch=gc());
    return sgn-'-' ? ans : -ans;
}
struct Node{int mx,sm,lz;Node(int _mx = 0, int _sm = 0){mx=_mx,sm=_sm,lz=0;}}t[(MAXN<<2)+5];
struct Edge{int to,nex;Edge(int _to = 0, int _nex = 0):to(_to),nex(_nex){}}e[(MAXN<<1)+5];
int N, Q, T, tot, query = 1, first[MAXN+5], C[MAXN+5], W[MAXN+5];
int fa[MAXN+5], dep[MAXN+5], sz[MAXN+5], heavy[MAXN+5], pos[MAXN+5], top[MAXN+5], dfn;
char op[5];
Ans ans[MAXN+5];
inline void Add(int a, int b)
{
    e[tot] = Edge(b,first[a]);
    first[a] = tot++;
    return;
}
void DFS1(int p)
{
    sz[p] = 1;
    for(register int u = first[p], v; u+1; u = e[u].nex)
        if((v=e[u].to) != fa[p])
        {
            dep[v] = dep[p]+1, fa[v] = p, DFS1(v), sz[p] += sz[v];
            if(!heavy[p] || sz[v] > sz[heavy[p]])
                heavy[p] = v; 
        }
    return;
} 
void DFS2(int p)
{
    if(heavy[p])
        pos[heavy[p]] = dfn++, top[heavy[p]] = top[p], DFS2(heavy[p]);
    for(register int u = first[p], v; u+1; u = e[u].nex)
        if((v=e[u].to) != fa[p] && v != heavy[p])
            pos[v] = dfn++, top[v] = v, DFS2(v);
    return;
}
inline Node Merge(Node a, Node b)
{
    return Node(max(a.mx,b.mx),a.sm+b.sm);
}
struct Segment_Tree
{
    void Push(int p)
    {
        mx(p) = max(mx(lc(p)),mx(rc(p))), sm(p) = sm(lc(p))+sm(rc(p));
        return;
    }
    void Lazy(int p)
    {
        if(lz(p))
        {
            t[lc(p)] = t[rc(p)] = Node(0,0);
            lz(lc(p)) = lz(rc(p)) = 1;
            lz(p) = 0;
        }
        return;
    }
    Node Query(int p, int lef, int rig, int L, int R)
    { 
        Lazy(p);
        if(L == lef && R == rig)
            return t[p];
        if(R <= mid)
            return Query(lc(p),lef,mid,L,R);
        if(L >  mid)
            return Query(rc(p),mid+1,rig,L,R);
        return Merge(Query(lc(p),lef,mid,L,mid),Query(rc(p),mid+1,rig,mid+1,R));
    }
    void Edit(int p, int lef, int rig, int x, int v)
    {
        Lazy(p);
        if(lef == rig)
        {
            mx(p) = sm(p) = v;
            return;
        }
        if(x <= mid)
            Edit(lc(p),lef,mid,x,v);
        else
            Edit(rc(p),mid+1,rig,x,v);
        Push(p);
        return;
    }
    void Clear()
    {
        mx(1) = sm(1) = 0, lz(1) = 1;
        return;
    }
}Tree;
Node Tour(int a, int b, Node res = Node(0,0))
{
    for(; top[a] != top[b]; a = fa[top[a]])
    {
        if(dep[top[a]] < dep[top[b]])
            a^=b^=a^=b;
        res = Merge(res,Tree.Query(1,1,N,pos[top[a]],pos[a]));
    }
    if(dep[a] < dep[b])
        a^=b^=a^=b;
    return Merge(res,Tree.Query(1,1,N,pos[b],pos[a]));
}
struct Operate
{
    int c,t,a,b,o;
    Operate(int _c = 0, int _t = 0, int _a = 0, int _b = 0, int _o = 0):c(_c),t(_t),a(_a),b(_b),o(_o){}
    void Excute()    //0 for Edit w, 1 for QuerySum, 2 for QueryMax
    {
        if(o)
        {
            Node res = Tour(a,b);
            ans[query++] = Ans(t,(o-1 ? res.mx : res.sm));
        }
        else
            Tree.Edit(1,1,N,pos[a],b);
        return;
    }
}S[MAXN+5];
inline bool cmp(Operate a, Operate b)
{
    return (a.c-b.c ? a.c<b.c : a.t<b.t);
}
int main()
{
    N = read(), Q = read(), T = 1, memset(first,-1,sizeof(first));
    for(register int i = 1, w, c; i <= N; i++)
        w = read(), c = read(), W[i] = w, C[i] = c, S[T] = Operate(c,T,i,w,0), T++;
    for(register int i = 1, a, b; i < N; i++)
        a = read(), b = read(), Add(a,b), Add(b,a);
    dep[1] = 1, fa[1] = 0, pos[1] = 1, top[1] = 1, dfn = 2, DFS1(1), DFS2(1);
    for(register int i = 1, a, b; i <= Q; i++)
        switch(scanf("%s",op), a = read(), b = read(), op[0]+op[1])
        {
            /*CC*/case 134:
            S[T] = Operate(C[a],T,a,0,0), T++, C[a] = b;
            S[T] = Operate(C[a],T,a,W[a],0), T++;            break;
            /*CW*/case 154:
            S[T] = Operate(C[a],T,a,b,0), T++, W[a] = b;    break;
            /*QS*/case 164:
            S[T] = Operate(C[a],T,a,b,1), T++;                break;
            /*QM*/case 158:
            S[T] = Operate(C[a],T,a,b,2), T++;                break;
        }
    T--, sort(S+1,S+T+1,cmp), S[0].c = -1;
    for(register int i = 1; i <= T; S[i].Excute(), i++)
        if(S[i].c != S[i-1].c)
            Tree.Clear();
    query--, sort(ans+1,ans+query+1);
    for(register int i = 1; i <= query; printf("%d\n", ans[i].second), i++);
    return 0;
}

```

---

## 作者：cirnovsky (赞：1)

## 题意简述

将树链剖分模板加了个限制。

## 题解

这道题如果考虑最暴力的做法就是树剖后对每一种宗教建立线段树统计。

实际上对每一种宗教建立线段树是没有必要的。

我们可以采取线段树动态开点的方法进行修改和查询，记录下每种宗教开点时的根节点。

对于操作一，我们可以直接将修改前的宗教改为0，这样就避免了删除操作。

其他的操作基本就是树剖的板子了，具体看代码吧。

还有一个坑点在于这道题如果用fread的话会WA完，和Dynamic Rankings一个尿性，具体原因我也不清楚。但是fread的话建议能不用就不用，容易出锅。

```cpp
const int Maxn = 1e5 + 5;
int n, m, t_tot, root[Maxn], lev[Maxn], fai[Maxn];
int s_tot, siz[Maxn], dfn[Maxn], rnk[Maxn], top[Maxn], dep[Maxn], son[Maxn], fa[Maxn];
struct Tree_Node {
	int ls, rs;
	int _sum, _max;
} nodes[Maxn << 5];
vector < int > Graph[Maxn];

void dfs1(int x) {
	siz[x] = 1;
	dep[x] = dep[fa[x]] + 1;
	for (unsigned i = 0; i < Graph[x].size(); ++i) {
		int y = Graph[x][i];
		if (y == fa[x])		continue;
		fa[y] = x;
		dfs1(y);
		if (siz[son[x]] < siz[y])	son[x] = y;
	}
}

void dfs2(int x, int t) {
	dfn[x] = ++s_tot;
	rnk[dfn[x]] = x;
	top[x] = t;
	if (son[x])		dfs2(son[x], t);
	for (unsigned i = 0; i < Graph[x].size(); ++i) {
		int y = Graph[x][i];
		if (y == fa[x] || y == son[x])		continue;
		dfs2(y, y);
	}
}

int newnode() {
	int res = ++t_tot;
	nodes[res].ls = nodes[res].rs = 0;
	nodes[res]._sum = nodes[res]._max = 0;
	return res;
}

void Update(int p) {
	nodes[p]._max = max(nodes[nodes[p].ls]._max, nodes[nodes[p].rs]._max);
	nodes[p]._sum = nodes[nodes[p].ls]._sum + nodes[nodes[p].rs]._sum;
}

void Modify(int& p, int l, int r, int x, int v) {
	if (p == 0)		p = newnode();
	if (l == r) {
		nodes[p]._max = v;
		nodes[p]._sum = v;
		return;
	}
	int mid = (l + r) >> 1;
	if (mid >= x) {
		if (nodes[p].ls == 0) 	nodes[p].ls = newnode();
		Modify(nodes[p].ls, l, mid, x, v);
	} else {
		if (nodes[p].rs == 0)	nodes[p].rs = newnode();
		Modify(nodes[p].rs, mid + 1, r, x, v);
	}
	Update(p);
}

int Query_Max(int p, int l, int r, int x, int y) {
	if (l > y || r < x || p == 0)	return 0;
	if (l >= x && r <= y)	return nodes[p]._max;
	int mid = (l + r) >> 1, res = 0;
	if (mid >= x) 	res = max(res, Query_Max(nodes[p].ls, l, mid, x, y));
	if (mid < y)	res = max(res, Query_Max(nodes[p].rs, mid + 1, r, x, y));
	return res;
}

int Query_Sum(int p, int l, int r, int x, int y) {
	if (l > y || r < x || p == 0)	return 0;
	if (l >= x && r <= y)	return nodes[p]._sum;
	int mid = (l + r) >> 1, res = 0;
	if (mid >= x) 	res += Query_Sum(nodes[p].ls, l, mid, x, y);
	if (mid < y)	res += Query_Sum(nodes[p].rs, mid + 1, r, x, y);
	return res;
}

int Query_Path_Max(int x, int y) {
	int res = 0, rt = root[fai[x]];
	while (top[x] != top[y]) {
		if (dep[top[x]] < dep[top[y]])	swap(x, y);
		res = max(res, Query_Max(rt, 1, n, dfn[top[x]], dfn[x]));
		x = fa[top[x]];
	}
	if (dep[x] > dep[y])	swap(x, y);
	return max(res, Query_Max(rt, 1, n, dfn[x], dfn[y]));
}

int Query_Path_Sum(int x, int y) {
	int res = 0, rt = root[fai[x]];
	while (top[x] != top[y]) {
		if (dep[top[x]] < dep[top[y]])	swap(x, y);
		res += Query_Sum(rt, 1, n, dfn[top[x]], dfn[x]);
		x = fa[top[x]];
	}
	if (dep[x] > dep[y]) 	swap(x, y);
	return res + Query_Sum(rt, 1, n, dfn[x], dfn[y]);
}

void Operation1(int x, int c) {
	Modify(root[fai[x]], 1, n, dfn[x], 0);
	fai[x] = c;
	Modify(root[c], 1, n, dfn[x], lev[x]);
}

void Operation2(int x, int w) {
	lev[x] = w;
	Modify(root[fai[x]], 1, n, dfn[x], lev[x]);
}

void Operation3(int x, int y) {
	printf("%d\n", Query_Path_Sum(x, y));
}

void Operation4(int x, int y) {
	printf("%d\n", Query_Path_Max(x, y));
}

signed main() {
	read(n, m);
	for (int i = 1; i <= n; ++i)	read(lev[i], fai[i]);
	for (int i = 1, x, y; i < n; ++i) {
		read(x, y);
		Graph[x].push_back(y);
		Graph[y].push_back(x);
	}
	dfs1(1), dfs2(1, 1);
	for (int i = 1; i <= n; ++i) 	Modify(root[fai[i]], 1, n, dfn[i], lev[i]);
	for (int i = 0; i < m; ++i) {
		char str[5];
		scanf("%s", str);
		if (str[1] == 'C') {
			int x, c;
			scanf("%d %d", &x, &c);
			Operation1(x, c);
		} else if (str[1] == 'W') {
			int x, w;
			scanf("%d %d", &x, &w);
			Operation2(x, w);
		} else if(str[1] == 'S') {
			int x, y;
			scanf("%d %d", &x, &y);
			Operation3(x, y);
		} else {
			int x, y;
			scanf("%d %d", &x, &y);
			Operation4(x, y);
		}
	}
	return 0;
}
```

---

## 作者：qscqesze_lca (赞：1)

数据保证对所有QS和QM事件，起点和终点城市的信仰相同；在任意时


刻，城市的评级总是不大于10^4的正整数，且宗教值不大于C。


树链剖分+动态线段树


树链剖分后，对于每个信仰建立一颗线段树


线段树要动态增加、移动点


注意不要与主席树混淆


主席树是所有的点都要新增，这里只需新增以前没有过的点


线段树的移动点：首先将原位置的节点修改为0，再在新位置增加节点。


实现：只需要在确定点在树中的位置（root数组）时，加一个判断，如果root[]位置有数（这个点已经添加过），cnt不+1（不建立新的点），在这个位置修改，否则建立新的点


复制代码

```cpp
#include<cstdio>
#include<algorithm>
#define N 100001
using namespace std;
int grade[N],belief[N],front[N],e_tot,cnt;
int dep[N],son[N],fa[N],bl[N],sz,id[N],root[N];
struct node{int next,to;}e[N*2];
int lc[N*20],rc[N*20],maxx[N*20],sum[N*20];
int n,m;
inline void add(int u,int v)
{
    e[++e_tot].to=v;e[e_tot].next=front[u];front[u]=e_tot;
    e[++e_tot].to=u;e[e_tot].next=front[v];front[v]=e_tot;
}
void init()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%d%d",&grade[i],&belief[i]);
    int u,v;
    for(int i=1;i<n;i++)
    {
        scanf("%d%d",&u,&v);
        add(u,v);
    }
}
inline void dfs1(int x)
{
    son[x]++;
    for(int i=front[x];i;i=e[i].next)
    {
        if(e[i].to==fa[x]) continue;
        fa[e[i].to]=x;
        dep[e[i].to]=dep[x]+1;
        dfs1(e[i].to);
        son[x]+=son[e[i].to];
    }
}
inline void dfs2(int x,int chain)
{
    sz++;int y=0;
    id[x]=sz;
    bl[x]=chain;
    for(int i=front[x];i;i=e[i].next)
    {
        if(e[i].to==fa[x]) continue;
        if(son[e[i].to]>son[y]) y=e[i].to;
     }
     if(!y) return;
     dfs2(y,chain);
     for(int i=front[x];i;i=e[i].next)
     {
         if(e[i].to==fa[x]||e[i].to==y) continue;
         dfs2(e[i].to,e[i].to);
     }
}
inline void up(int k)
{
    sum[k]=sum[lc[k]]+sum[rc[k]];
    maxx[k]=max(maxx[lc[k]],maxx[rc[k]]);
}
inline void change(int & y,int l,int r,int x,int w)
{
    if(!y) y=++cnt;
    if(l==r) {sum[y]=maxx[y]=w;return;}
    int mid=l+r>>1;
    if(x<=mid) change(lc[y],l,mid,x,w);
    else change(rc[y],mid+1,r,x,w);
    up(y);
}
inline int work(int k,int l,int r,int opl,int opr,bool p)
{
    if(l>=opl&&r<=opr) 
    {
        if(!p) return sum[k];
        else return maxx[k];
    }
    int mid=l+r>>1;
    int a=0,b=0;
    if(opl<=mid) a=work(lc[k],l,mid,opl,opr,p);
    if(opr>mid) b=work(rc[k],mid+1,r,opl,opr,p);
    if(!p) return a+b;
    else return max(a,b);
}
inline void operation(int q,int u,int v,bool p)
{
    int ans=0;
    while(bl[u]!=bl[v]) 
    {
        if(dep[bl[u]]<dep[bl[v]]) swap(u,v);
        if(!p) ans+=work(root[q],1,n,id[bl[u]],id[u],p);
        else ans=max(ans,work(root[q],1,n,id[bl[u]],id[u],p));
        u=fa[bl[u]];
    }
    if(id[u]>id[v]) swap(u,v);
    if(!p) ans+=work(root[q],1,n,id[u],id[v],p);
    else ans=max(ans,work(root[q],1,n,id[u],id[v],p));
    printf("%d\n",ans);
}
void solve()
{
    for(int i=1;i<=n;i++) change(root[belief[i]],1,n,id[i],grade[i]);
    char c[3];int x,y;
    for(int i=1;i<=m;i++)
    {
        scanf("%s%d%d",c,&x,&y);
        if(c[0]=='C')
        {
            if(c[1]=='C')
            {
                change(root[belief[x]],1,n,id[x],0);//先删除原来的点 
                belief[x]=y;
                change(root[belief[x]],1,n,id[x],grade[x]);//再增加新的点 
            }
            else 
            {
                change(root[belief[x]],1,n,id[x],y);
                grade[x]=y;
            }
        }
        else 
        {
            if(c[1]=='S') operation(belief[x],x,y,0);
            else operation(belief[x],x,y,1);
        }
    }
}
int main()
{
    init();
    dfs1(1);
    dfs2(1,1);
    solve();
}
```
复制代码
1个错误：


在查询的时候，没有先确定好哪个宗教的线段树，调用operation函数过程中，u节点随树链（包含所有节点的树）往上跳，不能保证一定调到同一宗教上，宗教随之改变。


所以要先确定好是哪一颗线段树


---

## 作者：傅思维666 (赞：0)

## 题解：

树链剖分+动态开点

如果树链剖分不会的话请走这边：

[详解树链剖分](https://www.cnblogs.com/fusiwei/p/11519470.html)

[浅谈动态开点线段树](https://www.cnblogs.com/fusiwei/p/12628596.html)

题意为给定一棵树，对树上节点赋值+染色。每次操作更改点权或更改颜色，每次询问求路径最大值或路径权值和。

首先简化问题，假如没有染色的话，这就是树剖的板子题：把树上节点用树链剖分来映射到一段区间上，然后通过维护线段树来解决问题。不懂的见树剖讲解。

之后考虑如何染色。暴力的想法是，开色数棵线段树，但是一看不行，因为色数是10^5的。于是本能想到优化空间的好帮手：动态开点。对想法进行验证，发现每次操作并不需要完全使用所有节点，所以动态开点是完全可行的，每次修改的时空复杂度是$O(\log N)$，可过。

注意一下，有些同学说这个叫主席树，但是其实这个并不是主席树。主席树的特点是多棵线段树有共用节点。但是这道题并没有这个共用的点，每棵线段树是完全相互独立的。所以它不是主席树。

于是我们得出了结论：这道题是动态开点+树剖的板子题。（逃

于是这道题的难点变成了代码实现。需要注意的有几个点：

因为是多棵线段树，所以要开一个数组root来记录每棵线段树的根是谁。

因为是动态开点，所以一开始不需要建全树，对每个点进行修改即可。

因为权值都为正，所以在变更宗教的时候不需要把原来宗教的节点删除，直接置零即可。

代码如下：

```cpp
#include<cstdio>
#include<algorithm>
#include<cctype>
#pragma GCC optimize(2)
using namespace std;
const int maxn=1e5+10;
int n,q;
int w[maxn],c[maxn];
int tot,to[maxn<<1],nxt[maxn<<1],head[maxn];
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while (ch<48||ch>57){if (ch=='-') f=-1;ch=getchar();}
	while (ch>=48&&ch<=57){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
void add(int x,int y)
{
    to[++tot]=y;
    nxt[tot]=head[x];
    head[x]=tot;
}
int cnt,fa[maxn],son[maxn],size[maxn],top[maxn],wa[maxn],id[maxn],deep[maxn];
int root[maxn],num;
struct node
{
    int mx,sum,lson,rson;
}t[maxn*42];
void dfs1(int x,int f)
{
    fa[x]=f;
    deep[x]=deep[f]+1;
    size[x]=1;
    for(int i=head[x];i;i=nxt[i])
    {
        int y=to[i];
        if(y==f)
            continue;
        dfs1(y,x);
        size[x]+=size[y];
        if(!son[x]||size[y]>size[son[x]])
            son[x]=y;
    }
}
void dfs2(int x,int t)
{
    id[x]=++cnt;
    top[x]=t;
    if(!son[x])
        return;
    dfs2(son[x],t);
    for(int i=head[x];i;i=nxt[i])
    {
        int y=to[i];
        if(y==fa[x]||y==son[x])
            continue;
        dfs2(y,y);
    }
}
void pushup(int pos)
{
    t[pos].mx=max(t[t[pos].lson].mx,t[t[pos].rson].mx);
    t[pos].sum=t[t[pos].lson].sum+t[t[pos].rson].sum;
}
void update(int &pos,int l,int r,int x,int k)
{
    int mid=(l+r)>>1;
    if(!pos)
        pos=++num;
    if(l==r)
    {
        t[pos].mx=t[pos].sum=k;
        return;
    }
    if(x<=mid)
        update(t[pos].lson,l,mid,x,k);
    else
        update(t[pos].rson,mid+1,r,x,k);
    pushup(pos);
}
int query1(int pos,int l,int r,int x,int y)
{
    int ret=0;
    int mid=(l+r)>>1;
    if(x<=l && r<=y)
        return t[pos].sum;
    if(x<=mid)
        ret+=query1(t[pos].lson,l,mid,x,y);
    if(y>mid)
        ret+=query1(t[pos].rson,mid+1,r,x,y);
    return ret;
}
int query2(int pos,int l,int r,int x,int y)
{
    int ret=-10000000;
    int mid=(l+r)>>1;
    if(x<=l && r<=y)
        return t[pos].mx;
    if(x<=mid)
        ret=max(ret,query2(t[pos].lson,l,mid,x,y));
    if(y>mid)
        ret=max(ret,query2(t[pos].rson,mid+1,r,x,y));
    return ret;
}
int q1(int x,int y,int k)
{
    int ret=0;
    while(top[x]!=top[y])
    {
        if(deep[top[x]]<deep[top[y]])
            swap(x,y);
        ret+=query1(root[k],1,n,id[top[x]],id[x]);
        x=fa[top[x]];
    }
    if(deep[x]<deep[y])
        swap(x,y);
    ret+=query1(root[k],1,n,id[y],id[x]);
    return ret;
}
int q2(int x,int y,int k)
{
    int ret=-10000000;
    while(top[x]!=top[y])
    {
        if(deep[top[x]]<deep[top[y]])
            swap(x,y);
        ret=max(ret,query2(root[k],1,n,id[top[x]],id[x]));
        x=fa[top[x]];
    }
    if(deep[x]<deep[y])
        swap(x,y);
    ret=max(ret,query2(root[k],1,n,id[y],id[x]));
    return ret;
}
int main()
{
    n=read();q=read();
    for(int i=1;i<=n;i++)
        w[i]=read(),c[i]=read();
    for(int i=1;i<n;i++)
    {
        int a,b;
        a=read();b=read();
        add(a,b);
        add(b,a);
    }
    dfs1(1,0);
    dfs2(1,1);
    for(int i=1;i<=n;i++)
        update(root[c[i]],1,n,id[i],w[i]);
    while(q--)
    {
        char opt[5];
        int x,y;
        scanf("%s",opt);
        x=read();y=read();
        if(opt[1]=='C')
        {
            update(root[c[x]],1,n,id[x],0);
            c[x]=y;
            update(root[c[x]],1,n,id[x],w[x]);
        }
        else if(opt[1]=='W')
        {
            update(root[c[x]],1,n,id[x],y);
            w[x]=y;
        }
        else if(opt[1]=='S')
            printf("%d\n",q1(x,y,c[x]));
        else
            printf("%d\n",q2(x,y,c[x]));
    }
    return 0;
}
```



---

## 作者：Dirt、 (赞：0)

第一眼看到题发现需要分别维护1e5种颜色，似乎不可做

后来发现好像可以动态开点？

对于每种颜色维护一棵线段树

发现在路径上查询和修改的颜色是固定的，在进行操作的时候在该颜色对应的线段树上进行修改和查询即可

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=100003;
int n,m;
int w[N],c[N];
int num;
int rt[N];
struct ST
{
	int ls,rs,Max,sum;
	ST(){ls=rs=Max=sum=0;}
}a[N<<5];
int cnt;
int head[N];
struct Edge
{
	int nxt,to;
}e[N<<1];
int idx;
int dep[N],f[N],son[N],siz[N],dfn[N],top[N];
char s[13];
void push_up(int x)
{
	a[x].Max=a[x].sum=0;
	if(a[x].ls)
	{
		a[x].sum+=a[a[x].ls].sum;
		a[x].Max=max(a[x].Max,a[a[x].ls].Max);
	}
	if(a[x].rs)
	{
		a[x].sum+=a[a[x].rs].sum;
		a[x].Max=max(a[x].Max,a[a[x].rs].Max);
	}
}
void modify(int &x,int l,int r,int p,int k)
{
	if(x==0) x=++num;
	if(l==r)
	{
		a[x].Max=a[x].sum=k;
		return;
	}
	int mid=(l+r)>>1;
	if(p<=mid) modify(a[x].ls,l,mid,p,k);
	else modify(a[x].rs,mid+1,r,p,k);
	push_up(x);
}
int qmax(int x,int l,int r,int nl,int nr)
{
	if(x==0) return 0;
	if(nl<=l&&nr>=r) return a[x].Max;
	int mid=(l+r)>>1,res=0;
	if(nl<=mid) res=qmax(a[x].ls,l,mid,nl,nr);
	if(nr>mid) res=max(res,qmax(a[x].rs,mid+1,r,nl,nr));
	return res;
}
int query(int x,int l,int r,int nl,int nr)
{
	if(x==0) return 0;
	if(nl<=l&&nr>=r) return a[x].sum;
	int mid=(l+r)>>1,res=0;
	if(nl<=mid) res+=query(a[x].ls,l,mid,nl,nr);
	if(nr>mid) res+=query(a[x].rs,mid+1,r,nl,nr);
	return res;
}
void add(int u,int v)
{
	e[++cnt].nxt=head[u];
	e[cnt].to=v;
	head[u]=cnt;
}
void dfs1(int x,int fa)
{
	dep[x]=dep[fa]+1;
	f[x]=fa;
	siz[x]=1;
	for(int i=head[x];i;i=e[i].nxt)
	{
		int to=e[i].to;
		if(to==fa) continue;
		dfs1(to,x);
		siz[x]+=siz[to];
		if(siz[to]>siz[son[x]]) son[x]=to;
	}
}
void dfs2(int x,int topf)
{
	dfn[x]=++idx;
	top[x]=topf;
	if(!son[x]) return;
	dfs2(son[x],topf);
	for(int i=head[x];i;i=e[i].nxt)
	{
		int to=e[i].to;
		if(to==f[x]||to==son[x]) continue;
		dfs2(to,to);
	}
}
int query_range(int x,int y)
{
	int r=rt[c[x]],res=0;
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		res+=query(r,1,n,dfn[top[x]],dfn[x]);
		x=f[top[x]];
	}
	if(dep[x]>dep[y]) swap(x,y);
	res+=query(r,1,n,dfn[x],dfn[y]);
	return res;
}
int qmax_range(int x,int y)
{
	int r=rt[c[x]],res=0;
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		res=max(res,qmax(r,1,n,dfn[top[x]],dfn[x]));
		x=f[top[x]];
	}
	if(dep[x]>dep[y]) swap(x,y);
	res=max(res,qmax(r,1,n,dfn[x],dfn[y]));
	return res;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%d%d",&w[i],&c[i]);
	for(int i=1;i<n;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		add(u,v);
		add(v,u);
	}
	dfs1(1,0);
	dfs2(1,1);
	for(int i=1;i<=n;i++)
		modify(rt[c[i]],1,n,dfn[i],w[i]);
	while(m--)
	{
		int x,y;
		scanf("%s%d%d",s,&x,&y);
		if(s[1]=='C')
		{
			modify(rt[c[x]],1,n,dfn[x],0);
			c[x]=y;
			modify(rt[y],1,n,dfn[x],w[x]);
		}
		else if(s[1]=='W')
		{
			w[x]=y;
			modify(rt[c[x]],1,n,dfn[x],w[x]);
		}
		else if(s[1]=='S') printf("%d\n",query_range(x,y));
		else printf("%d\n",qmax_range(x,y));
	}
	return 0;
}
```


---

## 作者：红色OI再临 (赞：0)

动态开点线段树+树链剖分，好题必须记下来

因为有多个宗教，所以开普通的线段树显然是不行的，所以就有一个动态开点线段树的东东

对于每种颜色，我们都要开一个线段树，用root记录它的根节点，当然这个线段树是动态开点的，每次单点修改时，如果当前到的位置没有节点，我们就新建一个节点，就能节省空间

`CC：`直接将`root[c[x]]`这颗线段树上的`dfn[x]`这个位置先修改为0,再修改颜色，在将
新颜色的线段树上的`dfn[x]`修改为原来的`a[x]`

`CW`将`root[c[x]]`上的`dfn[x]`位置的数修改为`y`，`a`数组也要改

`QS`在`root[c[x]]`这个线段树上像平常线段树一样树链剖分，线段树内维护`sum`

`QW`同理，线段树内维护`max`

就写完啦QWQ

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#define re register int
#define ll long long
#define maxn 200050
using namespace std;
struct tu {
    int u, v, w, nxt;
} e[maxn * 2];
int head[maxn];
int cnt;
void add(int u, int v) {
    e[++cnt].u = u;
    e[cnt].v = v;
    e[cnt].nxt = head[u];
    head[u] = cnt;
}
int size[maxn], son[maxn], dfn[maxn], dep[maxn], w[maxn], top[maxn];
int f[maxn], idx, a[maxn];
void dfs1(int u, int fa) {
    f[u] = fa;
    size[u] = 1;
    dep[u] = dep[fa] + 1;
    int maxson = -1;
    for (re i = head[u]; i; i = e[i].nxt) {
        int v = e[i].v;
        if (v == fa)
            continue;
        dfs1(v, u);
        size[u] += size[v];
        if (size[v] > maxson)
            maxson = size[v], son[u] = v;
    }
}
void dfs2(int u, int topp) {
    dfn[u] = ++idx;
    top[u] = topp;
    w[idx] = a[u];
    if (!son[u])
        return;
    dfs2(son[u], topp);
    for (re i = head[u]; i; i = e[i].nxt) {
        int v = e[i].v;
        if (v == f[u] || v == son[u])
            continue;
        dfs2(v, v);
    }
}
struct tree {
    int l, r, sum, mmax, lazy;
} t[maxn * 40];
int tot, root[maxn * 40], c[maxn];
void pushup(int now) {
    t[now].sum = t[t[now].l].sum + t[t[now].r].sum;
    t[now].mmax = max(t[t[now].l].mmax, t[t[now].r].mmax);
}
void change(int &now, int l, int r, int p, int w) {
    if (!now)
        now = ++tot;
    int mid = (l + r) >> 1;
    if (l == r) {
        t[now].sum = w;
        t[now].mmax = w;
        return;
    }
    if (p <= mid)
        change(t[now].l, l, mid, p, w);
    else
        change(t[now].r, mid + 1, r, p, w);
    pushup(now);
}
int n, q;
int askmax(int now, int l, int r, int x, int y) {
    if (x <= l && r <= y)
        return t[now].mmax;
    int mid = (l + r) >> 1;
    int num = 0;
    if (x <= mid && t[now].l)
        num = max(askmax(t[now].l, l, mid, x, y), num);
    if (y > mid && t[now].r)
        num = max(askmax(t[now].r, mid + 1, r, x, y), num);
    return num;
}
int asksum(int now, int l, int r, int x, int y) {
    if (x <= l && r <= y)
        return t[now].sum;
    int mid = (l + r) >> 1;
    int num = 0;
    if (x <= mid && t[now].l)
        num += asksum(t[now].l, l, mid, x, y);
    if (y > mid && t[now].r)
        num += asksum(t[now].r, mid + 1, r, x, y);
    return num;
}
int askdissum(int x, int y, int col) {
    int num = 0;
    while (top[x] != top[y]) {
        if (dep[top[x]] < dep[top[y]])
            swap(x, y);
        num += asksum(root[col], 1, n, dfn[top[x]], dfn[x]);
        x = f[top[x]];
    }
    if (dfn[x] > dfn[y])
        swap(x, y);
    num += asksum(root[col], 1, n, dfn[x], dfn[y]);
    return num;
}
int askdismax(int x, int y, int col) {
    int num = -0x3f3f3f3f;
    while (top[x] != top[y]) {
        if (dep[top[x]] < dep[top[y]])
            swap(x, y);
        num = max(num, askmax(root[col], 1, n, dfn[top[x]], dfn[x]));
        x = f[top[x]];
    }
    if (dfn[x] > dfn[y])
        swap(x, y);
    num = max(num, askmax(root[col], 1, n, dfn[x], dfn[y]));
    return num;
}
int main() {
    //	freopen("journey.in","r",stdin);
    //	freopen("journey.out","w",stdout);
    scanf("%d%d", &n, &q);
    for (re i = 1; i <= n; i++) {
        scanf("%d%d", &a[i], &c[i]);
    }
    for (re i = 1; i <= n - 1; i++) {
        int a1, a2;
        scanf("%d%d", &a1, &a2);
        add(a1, a2);
        add(a2, a1);
    }
    dfs1(1, 0);
    //	for(re i=1;i<=n;i++)
    //		printf("%d %d %d\n",son[i],dep[i],size[i]);
    dfs2(1, 1);
    for (re i = 1; i <= n; i++) change(root[c[i]], 1, n, dfn[i], a[i]);
    for (re i = 1; i <= q; i++) {
        char as[2];
        scanf("%s", as);
        int a1, a2;
        scanf("%d%d", &a1, &a2);
        if (as[1] == 'C') {
            change(root[c[a1]], 1, n, dfn[a1], 0);
            c[a1] = a2;
            change(root[c[a1]], 1, n, dfn[a1], a[a1]);
        }
        if (as[1] == 'W') {
            a[a1] = a2;
            change(root[c[a1]], 1, n, dfn[a1], a[a1]);
        }
        if (as[1] == 'S') {
            printf("%d\n", askdissum(a1, a2, c[a1]));
        }
        if (as[1] == 'M') {
            printf("%d\n", askdismax(a1, a2, c[a1]));
        }
    }
    // for(re i=1;i<=n;i++)
    //	printf("root[c[%d]]=%d\n",i,root[c[i]]);
    //*/

    return 0;
}
```


---

## 作者：Komes (赞：0)

# 究极树剖 毁我青春之旅行


------------
看到题目，我们可以想到按照信仰来建树，每一个信仰建一棵树，当然肯定不能简简单单的建树。这里我们要用到**主席树**的概念，PS：这里不会主席树的同学可以问下度娘。
但是为什么说它是伪主席树呢？这是因为主席树每次操作都会给当前操作过后建一个新树，而这里不一样，比如我们将x城市的居民的信仰改为y，**我们只需要在x城市原来所在的树内，减去它的评级w**，然后在信仰y这棵树内，将x城市添加进去即可。
所以这个很容易跟主席树混淆！！！！！！

------------
剩下的查询就很简单啦，直接用lca的方式进行查询就OK了。
下面贴代码（因为学校oj的问题我把DFS写成了非递归的形式，如果你用递归的DFS在洛谷是可以过的！！！)



------------
```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <stack>
#define N 200005
using namespace std;
 
int n,m,w[N],c[N],head[N];
struct edge
{
	int y,next;
}s[N];

int root[N],fa[N],seg[N],rev[N],dep[N],size[N],son[N],top[N],vis[N],sk[N];
int mmax[N * 10],ls[N * 10],rs[N * 10],sum[N * 10];
int tx,ty,ans,op,x,y,d,v,len = 0,cnt;

void ins(int x,int y)
{
	len++;
	s[len].y = y; s[len].next = head[x]; head[x] = len;
}
 
int read()
{
	char c; int res,f = 1;
	while ((c = getchar()) > '9' || c < '0') if (c == '-') f = -1;
	res = c - 48;
	while ((c = getchar()) >= '0' && c <= '9') res = res * 10 + c - 48;
	return res * f;
}

void BFS()
{
	stack <int> f;
	f.push(1); vis[1] = 1; dep[1] = 1; fa[1] = 0;
	for (int i = 1; i <= n; i++) size[i] = 1;
	while (!f.empty())
	{
		int x = f.top(); sk[++cnt] = x; f.pop();
		for(int i = head[x]; i != 0; i = s[i].next)
		{
			int y = s[i].y;
			if (!vis[y])
			{
				dep[y] = dep[x] + 1;
				vis[y] = 1;
				fa[y] = x;
				f.push(y);
			}
		}
	}
	
	while (cnt)
	{
		int x = sk[cnt]; cnt--;
		for(int i = head[x]; i != 0; i = s[i].next)
		if (fa[x] != s[i].y)
		{
			size[x] += size[s[i].y];
			if (size[son[x]] < size[s[i].y]) son[x] = s[i].y;
		}
	}
}

void bfs()
{
	stack <int> q,f;
	q.push(1); f.push(1);
	while(!q.empty())
	{
		int x = q.top(),y = f.top(); f.pop(); q.pop();
		seg[x] = ++seg[0]; top[x] = y;
	
		for(int i = head[x]; i != 0; i = s[i].next)
			if (!top[s[i].y] && son[x] != s[i].y)
				q.push(s[i].y),f.push(s[i].y);
		
		if (son[x])
			q.push(son[x]),f.push(y);
	}
}

void change(int &now,int l,int r)
{
	if(!now) now = ++len;
	sum[now] += d;
	if(l==r) 
	{
		if(d > 0) mmax[now] = d;
		else mmax[now] = 0;
		return ;
	}
	int mid = l + r >> 1;
	if(v <= mid) change(ls[now],l,mid);
	else change(rs[now],mid + 1,r);
	mmax[now] = max(mmax[ls[now]],mmax[rs[now]]);
}
 
void change_c()
{
	x = read(); y = read();
	v = seg[x]; d = -w[x];
	change(root[c[x]],1,n);
	c[x] = y; d = w[x];
	change(root[c[x]],1,n);
}
 
void change_w()
{
	x = read(); y = read();
	v = seg[x]; d = -w[x];
	change(root[c[x]],1,n);
	w[x] = y; d = w[x];
	change(root[c[x]],1,n);
}
 
int query_sum(int now,int l,int r,int x,int y)
{
	if(x == l && y == r) return sum[now];
	int mid = x + y >> 1;
	if(r <= mid) return query_sum(ls[now],l,r,x,mid);
	else if(mid < l) return query_sum(rs[now],l,r,mid + 1,y);
	else return query_sum(ls[now],l,mid,x,mid)+query_sum(rs[now],mid + 1,r,mid + 1,y);
}
 
int lca_sum()
{
	x = read(); y = read();
	op = x;
	tx = top[x]; ty = top[y];
	ans = 0;
	while(tx != ty)
	{
		if(dep[tx] > dep[ty])
		{
			swap(x,y);swap(tx,ty);
		}
		ans += query_sum(root[c[op]],seg[ty],seg[y],1,n);
		y = fa[ty]; ty = top[y];
	}
	if(dep[x] > dep[y]) swap(x,y);
	ans += query_sum(root[c[op]],seg[x],seg[y],1,n);
	return ans;
}
 
int query_max(int now,int l,int r,int x,int y)
{
	if(x == l && y == r) return mmax[now];
	int mid = x + y >> 1;
	if(r <= mid) return query_max(ls[now],l,r,x,mid);
	if(mid < l) return query_max(rs[now],l,r,mid + 1,y);
	return max(query_max(ls[now],l,mid,x,mid),query_max(rs[now],mid + 1,r,mid + 1,y));
}
 
int lca_max()
{
	x = read(); y = read();
	op = x;
	tx = top[x]; ty = top[y];
	ans = 0;
	while(tx != ty)
	{
		if(dep[tx] > dep[ty])
		{
			swap(x,y);swap(tx,ty);
		}
		ans = max(ans,query_max(root[c[op]],seg[ty],seg[y],1,n));
		y = fa[ty]; ty = top[y];
	}
	if(dep[x] > dep[y]) swap(x,y);
	ans = max(ans,query_max(root[c[op]],seg[x],seg[y],1,n));
	return ans;
}
 
int main()
{
	n = read(); m = read();
	for(int i = 1; i <= n; i++) w[i] = read(),c[i] = read();
	for(int i = 1; i <= n - 1; i++)
	{
		x = read(); y = read();
		ins(x,y);
		ins(y,x);
	}
	BFS();
	len = 0;
	bfs();
	len = 0;
	for(int i = 1; i <= n; i++)
	{
		v = seg[i]; d = w[i];
		change(root[c[i]],1,n);
	}
	char ch[10];
	while(m--)
	{
		scanf("%s",ch);
		if(ch[1] == 'C') change_c();
		else if(ch[1] == 'W') change_w();
		else if(ch[1] == 'S') printf("%d\n",lca_sum());
		else if(ch[1] == 'M') printf("%d\n",lca_max());
	}
	return 0;
}
```


---

## 作者：Aleph1022 (赞：0)

传说中动态开点

看来我是有什么误会

第一版代码：

```cpp
#include <cstdio>
#include <algorithm>
#define max(a,b) ((a) > (b) ? (a) : (b))
#define min(a,b) ((a) < (b) ? (a) : (b))
const int N = 100010;
const int C = 1e5;
using namespace std;
struct segnode
{
    int sum,max;
    int l,r,ls,rs;
} seg[N * 32];
int seg_tot;
int to[(N << 1) + 10],pre[(N << 1) + 10],first[N + 10],edge_tot;
inline void add(const int &u,const int &v)
{
    to[++edge_tot] = v;
    pre[edge_tot] = first[u];
    first[u] = edge_tot;
}
int f[N + 10],d[N + 10],size[N + 10],son[N + 10],top[N + 10],rk[N + 10],id[N + 10],dfn_tot;
int a[N + 10],w[N + 10];

void dfs1(int p,int fa,int dep)
{
    f[p] = fa;
    d[p] = dep;
    size[p] = 1;
    for(register int i = first[p];i;i = pre[i])
        if(to[i] ^ fa)
        {
            dfs1(to[i],p,dep + 1);
            size[p] += size[to[i]];
            if(!son[p] || size[to[i]] > size[son[p]])
                son[p] = to[i];
        }
}

void dfs2(int p,int t)
{
    top[p] = t;
    rk[++dfn_tot] = p;
    id[p] = dfn_tot;
    if(!son[p])
        return ;
    dfs2(son[p],t);
    for(register int i = first[p];i;i = pre[i])
        if(to[i] ^ f[p] && to[i] ^ son[p])
            dfs2(to[i],to[i]);
}

int build(int l,int r)
{
    int p = ++seg_tot;
    seg[p].l = l;
    seg[p].r = r;
    if(l == r)
        return p;
    int mid = l + r >> 1;
    seg[p].ls = build(l,mid);
    seg[p].rs = build(mid + 1,r);
    return p;
}

void insert(int x,int k,int p)
{
    if(seg[p].l == seg[p].r)
    {
        seg[p].sum = seg[p].max = k;
        return ;
    }
    int mid = seg[p].l + seg[p].r >> 1;
    if(x <= mid)
        insert(x,k,seg[p].ls);
    else
        insert(x,k,seg[p].rs);
    seg[p].sum = seg[seg[p].ls].sum + seg[seg[p].rs].sum;
    seg[p].max = max(seg[seg[p].ls].max,seg[seg[p].rs].max);
}

void remove(int x,int p)
{
    if(seg[p].l == seg[p].r)
    {
        seg[p].sum = seg[p].max = 0;
        return ;
    }
    int mid = seg[p].l + seg[p].r >> 1;
    if(x <= mid)
        remove(x,seg[p].ls);
    else
        remove(x,seg[p].rs);
    seg[p].sum = seg[seg[p].ls].sum + seg[seg[p].rs].sum;
    seg[p].max = max(seg[seg[p].ls].max,seg[seg[p].rs].max);
}

int getsum(int l,int r,int p)
{
    if(l <= seg[p].l && seg[p].r <= r)
        return seg[p].sum;
    int ret = 0;
    int mid = seg[p].l + seg[p].r >> 1;
    if(l <= mid)
        ret += getsum(l,r,seg[p].ls);
    if(r > mid)
        ret += getsum(l,r,seg[p].rs);
    return ret;
}

int getmax(int l,int r,int p)
{
    if(l <= seg[p].l && seg[p].r <= r)
        return seg[p].max;
    int ret = -0x3f3f3f3f;
    int mid = seg[p].l + seg[p].r >> 1;
    if(l <= mid)
        ret = max(ret,getmax(l,r,seg[p].ls));
    if(r > mid)
        ret = max(ret,getmax(l,r,seg[p].rs));
    return ret;
}

int n,q;
int rt[C + 10];

int main()
{
    scanf("%d%d",&n,&q);
    for(register int i = 1;i <= n;++i)
        scanf("%d%d",a + i,w + i);
    for(register int i = 1;i < n;++i)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        add(x,y);
        add(y,x);
    }
    dfs1(1,0,1);
    dfs2(1,1);
    for(register int i = 1;i <= n;++i)
    {
        if(!rt[w[i]])
            rt[w[i]] = build(1,n);
        insert(id[i],a[i],rt[w[i]]);
    }
    char opt[5];
    int x,y;
    while(q--)
    {
        scanf("%s%d%d",opt,&x,&y);
        if(opt[0] == 'C')
        {
            if(opt[1] == 'C')
            {
                remove(id[x],rt[w[x]]);
                w[x] = y;
                if(!rt[y])
                    rt[y] = build(1,n);
                insert(id[x],a[x],rt[w[x]]);
            }
            else
            {
                a[x] = y;
                insert(id[x],a[x],rt[w[x]]);
            }
        }
        else
        {
            if(opt[1] == 'S')
            {
                int root = rt[w[x]];
                int fx = top[x],fy = top[y];
                int ans = 0;
                while(fx ^ fy)
                {
                    if(d[fx] > d[fy])
                    {
                        ans += getsum(id[fx],id[x],root);
                        x = f[fx],fx = top[x];
                    }
                    else
                    {
                        ans += getsum(id[fy],id[y],root);
                        y = f[fy],fy = top[y];
                    }
                }
                if(d[x] > d[y])
                    swap(x,y);
                ans += getsum(id[x],id[y],root);
                printf("%d\n",ans);
            }
            else
            {
                int root = rt[w[x]];
                int fx = top[x],fy = top[y];
                int ans = -0x3f3f3f3f;
                while(fx ^ fy)
                {
                    if(d[fx] > d[fy])
                    {
                        ans = max(ans,getmax(id[fx],id[x],root));
                        x = f[fx],fx = top[x];
                    }
                    else
                    {
                        ans = max(ans,getmax(id[fy],id[y],root));
                        y = f[fy],fy = top[y];
                    }
                }
                if(d[x] > d[y])
                    swap(x,y);
                ans = max(ans,getmax(id[x],id[y],root));
                printf("%d\n",ans);
            }
        }
    }
}
```

看了眼题解，发现自己的动态开点根本就不动态……

因为有删除操作，所以我顺便用一个队列手写了内存池（其实很简单的

```cpp
// luogu-judger-enable-o2
#include <cstdio>
#include <algorithm>
#include <queue>
#define max(a,b) ((a) > (b) ? (a) : (b))
#define min(a,b) ((a) < (b) ? (a) : (b))
const int N = 100010;
const int C = 1e5;
using namespace std;
inline void read(int &x)
{
    char ch = 0;
    int w = 0;
    x = 0;
    while(ch < '0' || ch > '9')
        w |= ch == '-',ch = getchar();
    while(ch >= '0' && ch <= '9')
        x = (x << 3) + (x << 1) + (ch ^ '0'),ch = getchar();
    x = w ? -x : x;
}
struct segnode
{
    int sum,max;
    int ls,rs;
} seg[N * 32];
int seg_tot;
int to[(N << 1) + 10],pre[(N << 1) + 10],first[N + 10],edge_tot;
queue<int> freenode;
inline void New(int &p)
{
    if(!freenode.empty())
        p = freenode.front(),freenode.pop();
    else
        p = ++seg_tot;
}
inline void Delete(int &p)
{
    freenode.push(p);
    p = 0;
}
inline void add(const int &u,const int &v)
{
    to[++edge_tot] = v;
    pre[edge_tot] = first[u];
    first[u] = edge_tot;
}
int f[N + 10],d[N + 10],size[N + 10],son[N + 10],top[N + 10],rk[N + 10],id[N + 10],dfn_tot;
int a[N + 10],w[N + 10];

void dfs1(int p,int fa,int dep)
{
    f[p] = fa;
    d[p] = dep;
    size[p] = 1;
    for(register int i = first[p];i;i = pre[i])
        if(to[i] ^ fa)
        {
            dfs1(to[i],p,dep + 1);
            size[p] += size[to[i]];
            if(!son[p] || size[to[i]] > size[son[p]])
                son[p] = to[i];
        }
}

void dfs2(int p,int t)
{
    top[p] = t;
    rk[++dfn_tot] = p;
    id[p] = dfn_tot;
    if(!son[p])
        return ;
    dfs2(son[p],t);
    for(register int i = first[p];i;i = pre[i])
        if(to[i] ^ f[p] && to[i] ^ son[p])
            dfs2(to[i],to[i]);
}

void insert(int x,int k,int &p,int tl,int tr)
{
    if(!p)
        New(p);
    if(tl == tr)
    {
        seg[p].sum = seg[p].max = k;
        return ;
    }
    int mid = tl + tr >> 1;
    if(x <= mid)
        insert(x,k,seg[p].ls,tl,mid);
    else
        insert(x,k,seg[p].rs,mid + 1,tr);
    seg[p].sum = seg[seg[p].ls].sum + seg[seg[p].rs].sum;
    seg[p].max = max(seg[seg[p].ls].max,seg[seg[p].rs].max);
}

void remove(int x,int &p,int tl,int tr)
{
    if(tl == tr)
    {
        Delete(p);
        return ;
    }
    int mid = tl + tr >> 1;
    if(x <= mid)
        remove(x,seg[p].ls,tl,mid);
    else
        remove(x,seg[p].rs,mid + 1,tr);
    seg[p].sum = seg[seg[p].ls].sum + seg[seg[p].rs].sum;
    seg[p].max = max(seg[seg[p].ls].max,seg[seg[p].rs].max);
    if(!seg[p].sum)
    	Delete(p);
}

int getsum(int l,int r,int p,int tl,int tr)
{
    if(!seg[p].sum)
        return 0;
    if(l <= tl && tr <= r)
        return seg[p].sum;
    int ret = 0;
    int mid = tl + tr >> 1;
    if(l <= mid)
        ret += getsum(l,r,seg[p].ls,tl,mid);
    if(r > mid)
        ret += getsum(l,r,seg[p].rs,mid + 1,tr);
    return ret;
}

int getmax(int l,int r,int p,int tl,int tr)
{
    if(!seg[p].max)
        return 0;
    if(l <= tl && tr <= r)
        return seg[p].max;
    int ret = -0x3f3f3f3f;
    int mid = tl + tr >> 1;
    if(l <= mid)
        ret = max(ret,getmax(l,r,seg[p].ls,tl,mid));
    if(r > mid)
        ret = max(ret,getmax(l,r,seg[p].rs,mid + 1,tr));
    return ret;
}

int n,q;
int rt[C + 10];
int x,y;
char opt[5];

int main()
{
    read(n),read(q);
    for(register int i = 1;i <= n;++i)
        read(a[i]),read(w[i]);
    for(register int i = 1;i < n;++i)
    {
        read(x),read(y);
        add(x,y);
        add(y,x);
    }
    dfs1(1,0,1);
    dfs2(1,1);
    for(register int i = 1;i <= n;++i)
    {
        insert(id[i],a[i],rt[w[i]],1,n);
    }
    while(q--)
    {
        scanf("%s",opt);
        read(x),read(y);
        if(opt[0] == 'C')
        {
            if(opt[1] == 'C')
            {
                remove(id[x],rt[w[x]],1,n);
                w[x] = y;
                insert(id[x],a[x],rt[w[x]],1,n);
            }
            else
            {
                a[x] = y;
                insert(id[x],a[x],rt[w[x]],1,n);
            }
        }
        else
        {
            if(opt[1] == 'S')
            {
                int root = rt[w[x]];
                int fx = top[x],fy = top[y];
                int ans = 0;
                while(fx ^ fy)
                {
                    if(d[fx] > d[fy])
                    {
                        ans += getsum(id[fx],id[x],root,1,n);
                        x = f[fx],fx = top[x];
                    }
                    else
                    {
                        ans += getsum(id[fy],id[y],root,1,n);
                        y = f[fy],fy = top[y];
                    }
                }
                if(d[x] > d[y])
                    swap(x,y);
                ans += getsum(id[x],id[y],root,1,n);
                printf("%d\n",ans);
            }
            else
            {
                int root = rt[w[x]];
                int fx = top[x],fy = top[y];
                int ans = -0x3f3f3f3f;
                while(fx ^ fy)
                {
                    if(d[fx] > d[fy])
                    {
                        ans = max(ans,getmax(id[fx],id[x],root,1,n));
                        x = f[fx],fx = top[x];
                    }
                    else
                    {
                        ans = max(ans,getmax(id[fy],id[y],root,1,n));
                        y = f[fy],fy = top[y];
                    }
                }
                if(d[x] > d[y])
                    swap(x,y);
                ans = max(ans,getmax(id[x],id[y],root,1,n));
                printf("%d\n",ans);
            }
        }
    }
}
```

开了 O2

---

## 作者：xyz32768 (赞：0)

先树剖一下，对每种宗教建一棵线段树。

当然，把所有的节点都建出来，在时空复杂度上都不允许。

所以考虑不建出所有的节点。主要想法是：一棵线段树里，只维护出部分叶子节点（信仰该宗教的城市）以及这些节点到**线段树**根的路径。可以知道，这样的建树复杂度为$O(n\log n)$。

对于操作$1$，就在该城市的宗教对应的线段树里删掉这个叶子节点，并在$c$教对应的线段树里添加这个叶子节点。

对于操作$2,3,4$，就是单点修改和路径询问，就不多说了。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
inline char get() {
    char c; while ((c = getchar()) != 'C' && c != 'W' && c != 'Q'
        && c != 'S' && c != 'M'); return c;
}
const int N = 1e5 + 5, M = 2e6 + 5;
int n, Q, W[N], C[N], fa[N], dep[N], sze[N], son[N], top[N], pos[N],
rt[N], QAQ, ecnt, nxt[N << 1], adj[N], go[N << 1], col[N], val[N],
QWQ;
void add_edge(int u, int v) {
    nxt[++ecnt] = adj[u]; adj[u] = ecnt; go[ecnt] = v;
    nxt[++ecnt] = adj[v]; adj[v] = ecnt; go[ecnt] = u;
}
struct cyx {
    int lc, rc, Sum, Max;
    cyx() {}
    cyx(int val) :
        Sum(val), Max(val), lc(0), rc(0) {}
} T[M];
void upt(int p) {
    T[p].Sum = T[T[p].lc].Sum + T[T[p].rc].Sum;
    T[p].Max = max(T[T[p].lc].Max, T[T[p].rc].Max);
}
void ins(int x, int w, int l, int r, int &p) {
    if (!p) T[p = ++QWQ] = cyx(0);
    if (l == r) return (void) (T[p].Sum = T[p].Max = w);
    int mid = l + r >> 1;
    if (x <= mid) ins(x, w, l, mid, T[p].lc);
    else ins(x, w, mid + 1, r, T[p].rc); upt(p);
}
void dfs1(int u, int fu) {
    fa[u] = fu; dep[u] = dep[fu] + 1; sze[u] = 1;
    for (int e = adj[u], v; e; e = nxt[e]) {
        if ((v = go[e]) == fu) continue; dfs1(v, u);
        sze[u] += sze[v];
        if (sze[v] > sze[son[u]]) son[u] = v;
    }
}
void dfs2(int u, int fu) {
    if (son[u]) {
        top[son[u]] = top[u];
        pos[son[u]] = ++QAQ;
        dfs2(son[u], u);
    }
    for (int e = adj[u], v; e; e = nxt[e]) {
        if ((v = go[e]) == fu || v == son[u]) continue;
        top[v] = v; pos[v] = ++QAQ; dfs2(v, u);
    }
}
void init() {
    QAQ = top[1] = pos[1] = 1;
    int i; dfs1(1, 0); dfs2(1, 0);
    for (i = 1; i <= n; i++)
        ins(pos[i], val[i], 1, n, rt[col[i]]);
}
void del(int x, int l, int r, int &p) {
    if (l == r) return (void) (T[p] = cyx(0), p = 0);
    int mid = l + r >> 1; if (x <= mid) del(x, l, mid, T[p].lc);
    else del(x, mid + 1, r, T[p].rc); upt(p);
    if (!T[p].lc && !T[p].rc) T[p] = cyx(0), p = 0;
}
void change(int l, int r, int x, int v, int p) {
    if (l == r) return (void) (T[p].Sum = T[p].Max = v);
    int mid = l + r >> 1;
    if (x <= mid) change(l, mid, x, v, T[p].lc);
    else change(mid + 1, r, x, v, T[p].rc); upt(p);
}
void changeC(int x, int c) {
    del(pos[x], 1, n, rt[col[x]]); ins(pos[x], val[x], 1, n, rt[c]);
    col[x] = c;
}
int querySum(int l, int r, int s, int e, int p) {
    if (!p) return 0; if (l == s && r == e) return T[p].Sum;
    int mid = l + r >> 1;
    if (e <= mid) return querySum(l, mid, s, e, T[p].lc);
    else if (s >= mid + 1) return querySum(mid + 1, r, s, e, T[p].rc);
    else return querySum(l, mid, s, mid, T[p].lc)
        + querySum(mid + 1, r, mid + 1, e, T[p].rc);
}
int queryMax(int l, int r, int s, int e, int p) {
    if (!p) return 0; if (l == s && r == e) return T[p].Max;
    int mid = l + r >> 1;
    if (e <= mid) return queryMax(l, mid, s, e, T[p].lc);
    else if (s >= mid + 1) return queryMax(mid + 1, r, s, e, T[p].rc);
    else return max(queryMax(l, mid, s, mid, T[p].lc),
        queryMax(mid + 1, r, mid + 1, e, T[p].rc));
}
int pathSum(int u, int v) {
    int res = 0, x = col[u];
    while (top[u] != top[v]) {
        if (dep[top[u]] < dep[top[v]]) swap(u, v);
        res += querySum(1, n, pos[top[u]], pos[u], rt[x]);
        u = fa[top[u]];
    }
    if (dep[u] > dep[v]) swap(u, v);
    return res + querySum(1, n, pos[u], pos[v], rt[x]);
}
int pathMax(int u, int v) {
    int res = 0, x = col[u];
    while (top[u] != top[v]) {
        if (dep[top[u]] < dep[top[v]]) swap(u, v);
        res = max(res, queryMax(1, n, pos[top[u]], pos[u], rt[x]));
        u = fa[top[u]];
    }
    if (dep[u] > dep[v]) swap(u, v);
    return max(res, queryMax(1, n, pos[u], pos[v], rt[x]));
}
int main() {
    int i, x, y; n = read(); Q = read(); char c1, c2;
    for (i = 1; i <= n; i++) val[i] = read(), col[i] = read();
    for (i = 1; i < n; i++) x = read(), y = read(), add_edge(x, y); init();
    while (Q--) {
        c1 = get(); c2 = get(); x = read(); y = read();
        if (c1 == 'C') {
            if (c2 == 'C') changeC(x, y);
            else change(1, n, pos[x], y, rt[col[x]]), val[x] = y;
        }
        else {
            if (c2 == 'S') printf("%d\n", pathSum(x, y));
            else printf("%d\n", pathMax(x, y));
        }
    }
    return 0;
}
```

---

## 作者：zyh2015 (赞：0)

本题要查询树上总和与最大值，想到树链剖分+线段树搞。但是同信仰才能加，所以给每个信仰开个线段树，动态开点。

更改的时候记得删除原来的节点（当两个子节点都为空时）。

（还有不要像我一样写宏还敢往里放函数- -）

```cpp
#include <cstdio>
#include <cstring>
#define N 100005
#define Max(a,b) (a>b?a:b)
using namespace std;
inline void Swap(int& x,int& y){int z=x;x=y;y=z;}
struct Segment_Tree{
    Segment_Tree *ls,*rs;
    int l,r,sum,maxx;
    void maintain(){
        sum=maxx=0;
        if(ls!=NULL){
            sum+=ls->sum;
            maxx=Max(maxx,ls->maxx);
        }
        if(rs!=NULL){
            sum+=rs->sum;
            maxx=Max(maxx,rs->maxx);
        }
    }
    Segment_Tree(int l,int r):l(l),r(r){ls=rs=NULL; sum=maxx=0;}
}*ST[N];
typedef Segment_Tree S_T;
struct Edge{
    int to,nex;
    bool vis;
}e[N<<1];
int n,m,T,fir[N],seq[N];
struct Point{
    int Size,dep,pos,top,fa,son,val,belief;
}p[N];
void dfs1(int x){
    p[x].Size=1;
    for(int i=fir[x];i!=-1;i=e[i].nex){
        if(!e[i].vis) continue;
        int to=e[i].to;
        p[to].dep=p[x].dep+1;
        p[to].fa=x;
        e[i^1].vis=false;
        dfs1(to);
        p[x].Size+=p[to].Size;
        if(p[p[x].son].Size<p[to].Size) p[x].son=to;
    }
    return ;
}
void dfs2(int x){
    T++;
    p[x].pos=T;
    if(p[p[x].fa].son==x) p[x].top=p[p[x].fa].top;
    else p[x].top=x;
    if(p[x].son) dfs2(p[x].son);
    for(int i=fir[x];i!=-1;i=e[i].nex){
        if(e[i].to==p[x].son || e[i].to==p[x].fa) continue;
        dfs2(e[i].to);
    }
    return ;
}
void Insert(S_T*& x,int l,int r,int pos,int v){
    if(x==NULL) x=new S_T(l,r);
    if(l==pos && r==pos){
        x->sum=x->maxx=v;
        return ;
    }
    int mid=(l+r)>>1;
    if(pos<=mid) Insert(x->ls,l,mid,pos,v);
    else Insert(x->rs,mid+1,r,pos,v);
    x->maintain();
    return ;
}
void Delete(S_T*& x,int pos){
    if(x->l==pos && x->r==pos) {
        delete x;
        x=NULL;
        return ;
    }
    int mid=(x->l+x->r)>>1;
    if(pos<=mid) Delete(x->ls,pos);
    else Delete(x->rs,pos);
    if(x->ls==NULL && x->rs==NULL){
        delete x;
        x=NULL;
    }
    else x->maintain();
    return ;
}
int Query_Max(S_T* x,int l,int r){
    if(x==NULL) return 0;
    if(x->l==l && x->r==r) return x->maxx;
    int mid=(x->l+x->r)>>1;
    if(r<=mid) return Query_Max(x->ls,l,r);
    if(l>mid) return Query_Max(x->rs,l,r);
    return Max(Query_Max(x->ls,l,mid),Query_Max(x->rs,mid+1,r));
}
int Query_Sum(S_T* x,int l,int r){
    if(x==NULL) return 0;
    if(x->l==l && x->r==r) return x->sum;
    int mid=(x->l+x->r)>>1;
    if(r<=mid) return Query_Sum(x->ls,l,r);
    if(l>mid) return Query_Sum(x->rs,l,r);
    return Query_Sum(x->ls,l,mid)+Query_Sum(x->rs,mid+1,r);
}

int main(){
    memset(fir,-1,sizeof fir);
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%d%d",&p[i].val,&p[i].belief);
    for(int i=0;i<n-1;i++) {
        int x,y,u=i<<1;
        scanf("%d%d",&x,&y);
        e[u].to=y; e[u].nex=fir[x]; fir[x]=u; e[u].vis=true;
        u^=1;
        e[u].to=x; e[u].nex=fir[y]; fir[y]=u; e[u].vis=true;
    }
    p[1].dep=1; p[1].top=1;
    dfs1(1); dfs2(1);
    for(int i=1;i<=n;i++) Insert(ST[p[i].belief],1,n,p[i].pos,p[i].val);
    while(m--){
        int x,y;
        char mode[5];
        scanf("%s%d%d",mode,&x,&y);
        if(mode[1]=='C'){//Change_Belief
            Delete(ST[p[x].belief],p[x].pos);
            p[x].belief=y;
            Insert(ST[y],1,n,p[x].pos,p[x].val);
        }
        else if(mode[1]=='W'){//Change_Value
            p[x].val=y;
            Insert(ST[p[x].belief],1,n,p[x].pos,y);
        }
        else if(mode[1]=='S'){//Query_Sum
            int ans=0,b=p[x].belief;
            while(p[x].top!=p[y].top){
                int topx=p[x].top,topy=p[y].top;
                if(p[topx].dep<p[topy].dep) Swap(x,y) , Swap(topx,topy);
                ans+=Query_Sum(ST[b],p[topx].pos,p[x].pos);
                x=p[topx].fa;
            }
            if(p[x].dep<p[y].dep) Swap(x,y);
            ans+=Query_Sum(ST[b],p[y].pos,p[x].pos);
            printf("%d\n",ans);
        }
        else if(mode[1]=='M'){//Query_Max
            int ans=0,b=p[x].belief;
            while(p[x].top!=p[y].top){
                int topx=p[x].top,topy=p[y].top;
                if(p[topx].dep<p[topy].dep) Swap(x,y) , Swap(topx,topy);
                ans=Max(ans,Query_Max(ST[b],p[topx].pos,p[x].pos));
                x=p[topx].fa;
            }
            if(p[x].dep<p[y].dep) Swap(x,y);
            ans=Max(ans,Query_Max(ST[b],p[y].pos,p[x].pos));
            printf("%d\n",ans);
        }
    }
    return 0;
}
```

---


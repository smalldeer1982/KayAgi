# 洛谷树

## 题目背景

萌哒的 Created_equal 小仓鼠种了一棵洛谷树！

（题目背景是辣鸡小仓鼠乱写的 QAQ）。


## 题目描述

树是一个无环、连通的无向图，由 $n$ 个点和 $n-1$ 条边构成。树上两个点之间的路径被定义为他们之间的唯一一条简单路径——显然这是一条最短路径。

现在引入一个概念——子路径。假设树上两个点 $p_1$ 和 $p_n$ 之间的路径是 $P = \langle p_1,p_2,p_3, \ldots, p_n \rangle $，那么它的子路径被定义为某一条路径 $P'$，满足 $P'= \langle p_i,p_{i+1},p_{i+2},\ldots,p_j \rangle $，其中 $1\le i \le j \le n$。显然，原路径是一条子路径，任意一个点也可以作为子路径。

我们给每条边赋予一个边权。萌萌哒的 Sugar 问小仓鼠：对于任意两个点 $u$ 和 $v$，你能快速求出，$u$ 到 $v$ 的路径上所有子路径经过的边的边权的 $\text{xor}$ 值的和是多少。具体地说就是，你把 $u$ 到 $v$ 的路径上所有子路径全部提出来，然后分别把每个子路径上经过的边的边权 $\text{xor}$ 在一起，最后求出得到的所有 $\text{xor}$ 值的和。

什么？你不知道 $\text{xor}$？那就去百度啊！

这时候，fjzzq2002 大爷冒了粗来：窝还要你滋磁修改某条边边权的操作！

小仓鼠那么辣鸡，当然不会做这道题啦。于是他就来向你求救！


## 说明/提示

|测试点编号|$n=$|$q=$|备注|
|:-:|:-:|:-:|:-:|
|$1$|$100$|$5$|无|
|$2$|$100$|$20$|无|
|$3$|$100$|$100$|无|
|$4$|$5\times 10^3$|$10^3$|无|
|$5$|$5\times 10^3$|$2\times 10^3$|无|
|$6$|$5\times 10^3$|$3\times 10^3$|无|
|$7$|$10^4$|$10^4$|第 $i$ 条边连接第 $i$ 个点和第 $i+1$ 个点，且没有 $2$ 操作|
|$8$|$10^4$|$2\times 10^4$|第 $i$ 条边连接第 $i$ 个点和第 $i+1$ 个点，且没有 $2$ 操作|
|$9$|$10^4$|$10^4$|第 $i$ 条边连接第 $i$ 个点和第 $i+1$ 个点|
|$10$|$10^4$|$2\times 10^4$|第 $i$ 条边连接第 $i$ 个点和第 $i+1$ 个点|
|$11$|$10^4$|$10^4$|没有 $2$ 操作|
|$12$|$10^4$|$2\times 10^4$|没有 $2$ 操作|
|$13$|$2\times 10^4$|$2\times 10^4$|没有 $2$ 操作|
|$14$|$3\times 10^4$|$3\times 10^4$|没有 $2$ 操作|
|$15$|$3\times 10^4$|$10^4$|无|
|$16$|$2\times 10^4$|$2\times 10^4$|无|
|$17$|$2\times 10^4$|$2\times 10^4$|无|
|$18$|$3\times 10^4$|$2\times 10^4$|无|
|$19$|$2\times 10^4$|$3\times 10^4$|无|
|$20$|$3\times 10^4$|$3\times 10^4$|无|

对于 $100\%$ 的数据，所有边权小于等于 $1023$。


## 样例 #1

### 输入

```
5 3
1 2 3
2 3 3
2 4 6
4 5 1
1 3 4
2 2 4 7
1 3 5```

### 输出

```
14
26
```

# 题解

## 作者：Created_equal1 (赞：56)

方法1：


预处理每个点到根节点的xor值之后就变成了一个路径上任意两点xor的和，这个我们可以通过维护某一位是1的个数，然后分别统计贡献来做到。至于修改操作，就等价于一个子树某一位翻转修改。具体用树链剖分+线段树实现即可。


方法2：


考虑序列上的做法，我们可以用线段树维护一发左右子树的答案和每一位的情况来合并答案。把扔到树上去只要加上树链剖分即可。这种方法写起来比第一种方法麻烦一些。


两种做法的复杂度都是O(nlog^2n\*w)的。


---

## 作者：MeowScore (赞：26)

[传送门 qwq](https://www.luogu.com.cn/problem/P3401)

本题解使用树剖套线段树，老少皆宜。

多次询问树的一条链上所有子路径各边异或和的和，边权给定，支持单边修改。

先考虑如果写暴力要怎么做。暴力枚举一条链上所有的点对，对于每个点对，暴力把这一对点之间的每条边异或起来，然后把每次的结果相加。考虑优化把一对点之间的所有边异或起来这一过程，可以维护一个数组 $s$，$s_i$ 代表从 $1$ 号点到 $i$ 号点这一条链各边的异或和。那么对于一个点对 $(i,j)$ ，显然它们之间各边的异或和就是 $s_i \oplus s_j$。然后问题就变成了对于链上所有的点的 $s$ 值，求出两两异或和之和，再考虑优化掉暴力枚举点对这一过程。

注意到权值非常之小，这里要用到一种很妙的方法：按二进制逐位维护，其实是回归了“异或”最本质的地方：相同得 $0$，不相同得 $1$。而本题当中是计算一些数值两两异或再求和，不妨考虑每一个二进制位对答案的贡献是多少，显然我们把每一个二进制位的贡献相加就是最终答案。

假设二进制最低位是第 $0$ 位，现在考虑第 $i$ 位的贡献。

假如待求的数中，第 $i$ 位为 $1$ 的有 $a$ 个，第 $i$ 位为 $0$ 的有 $b$ 个，则第 $i$ 位对答案的贡献为 $a\times b\times 2^i$。

两两异或，我们可以依次拿着一个第 $i$ 位为 $1$ 的数和所有的数分别去做异或，这 $a$ 个数分别会和 $b$ 个数异或产生 $2^i$ 的贡献（因为只有 $b$ 个数在第 $i$ 上与它不同），总贡献就是 $a\times b\times 2^i$（以上所说的贡献是仅仅考虑第 $i$ 位）。

于是我们用线段树，每片叶子上放着相应 $s$ 值二进制下的 $1$ 和 $0$ 的个数，维护区间和。每次询问就去查询链上 $0$ 和 $1$ 的个数从而计算答案，结合树剖即可。

呃其实只维护 $1$ 的个数就好了，因为询问的链上总共的点数很好求（下文就是按照这样讲的）。

对于修改操作，受到影响的点就是所有向根节点走会经过这条边的点，也就是以待修改边深度大的端点为根的子树中的所有点，每次修改要对子树进行修改。

如何修改？对于每个 $i$，如果修改后的值的二进制下第 $i$ 位和这条边原来的值的二进制下第 $i$ 位相同，不用操作，否则把这个子树对应的线段树区间中维护二进制第 $i$ 位 $1$ 的个数的元素值改变为区间长度减原值，再打上一个 tag。为何这么做？如果第 $i$ 位发生改变，则子树中这一位原本是 $1$ 的就变成 $0$，原本是 $0$ 的就变成 $1$，其实是一个 $0、1$ 个数交换的操作。（我开了一个数组记录每个点和他父亲之间的边当前的权值是多少）

然后就讲完了 qwq。

有任何不懂的地方或是题解有啥问题随时私信~~骚扰~~。![](//图.tk/3)

代码：

```
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=30010;
int read(){
	int ss=0,ww=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')
			ww=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		ss=ss*10+ch-'0';
		ch=getchar();
	}
	return ss*ww;
}
int head[N],to[N*2],nex[N*2],e[N*2],cnt;
void add(int x,int y,int z){
	cnt++;
	to[cnt]=y;
	nex[cnt]=head[x];
	head[x]=cnt;
	e[cnt]=z;
}
int n,m;
int tot,dfn[N],tp[N],dep[N],fa[N],sz[N],son[N],s[N],a[N],in[N];
void dfs1(int x,int f){
	fa[x]=f;
	dep[x]=dep[f]+1;
	sz[x]=1;
	int maxn=-1;
	for(int i=head[x];i;i=nex[i]){
		int y=to[i];
		if(y==f)
			continue;
		s[y]=(s[x]^e[i]);
		in[y]=e[i];
		dfs1(y,x);
		sz[x]+=sz[y];
		if(sz[y]>maxn){
			son[x]=y;
			maxn=sz[y];
		}
	}
}
void dfs2(int x,int top){
	tp[x]=top;
	tot++;
	dfn[x]=tot;
	a[tot]=s[x];
	if(son[x])
		dfs2(son[x],top);
	for(int i=head[x];i;i=nex[i]){
		int y=to[i];
		if(y==fa[x]||y==son[x])
			continue;
		dfs2(y,y);
	}
}
struct ST{
	int b[15];
	int tag[15];
}st[N*4];
void build(int root,int l,int r){
	if(l==r){
		int x=a[l];
		for(int i=0;i<=10;i++)
			if((1<<i)&x)
				st[root].b[i]=1;
		return;
	}
	int mid=(l+r)/2;
	build(root*2,l,mid);
	build(root*2+1,mid+1,r);
	for(int i=0;i<=10;i++)
		st[root].b[i]=st[root*2].b[i]+st[root*2+1].b[i];
}
int res[15];
int lca(int x,int y){
	while(tp[x]!=tp[y]){
		if(dep[tp[x]]<dep[tp[y]])
			swap(x,y);
		x=fa[tp[x]];
	}
	if(dep[x]>dep[y])
		return y;
	return x;
}
void push_down(int root,int l,int r){
	int mid=(l+r)/2;
	for(int i=0;i<=10;i++){
		if(!st[root].tag[i])
			continue;
		st[root].tag[i]=0;
		st[root*2].b[i]=mid-l+1-st[root*2].b[i];
		st[root*2+1].b[i]=r-mid-st[root*2+1].b[i];
		st[root*2].tag[i]^=1;
		st[root*2+1].tag[i]^=1;
	}
}
void ask(int root,int l,int r,int x,int y){
	if(l>=x&&r<=y){
		for(int i=0;i<=10;i++)
			res[i]+=st[root].b[i];
		return;
	}
	push_down(root,l,r);
	int mid=(l+r)/2;
	if(mid>=x)
		ask(root*2,l,mid,x,y);
	if(mid+1<=y)
		ask(root*2+1,mid+1,r,x,y);
}
void change(int root,int l,int r,int x,int y,int k){
	if(l>=x&&r<=y){
		st[root].tag[k]^=1;
		st[root].b[k]=r-l+1-st[root].b[k];
		return;
	}
	push_down(root,l,r);
	int mid=(l+r)/2;
	if(mid>=x)
		change(root*2,l,mid,x,y,k);
	if(mid+1<=y)
		change(root*2+1,mid+1,r,x,y,k);
	for(int i=0;i<10;i++)
		st[root].b[i]=st[root*2].b[i]+st[root*2+1].b[i];
}
signed main(){
	n=read();
	m=read();
	for(int i=1;i<n;i++){
		int x,y,z;
		x=read();
		y=read();
		z=read();
		add(x,y,z);
		add(y,x,z);
	}
	dfs1(1,1);
	dfs2(1,1);
	build(1,1,n);
	int p[15];
	for(int i=1;i<=m;i++){
		int opt;
		opt=read();
		if(opt==1){
			int x,y;
			x=read();
			y=read();
			int xx=x,yy=y;
			memset(p,0,sizeof(p));
			while(tp[x]!=tp[y]){
				if(dep[tp[x]]<dep[tp[y]])
					swap(x,y);
				memset(res,0,sizeof(res));
				ask(1,1,n,dfn[tp[x]],dfn[x]);
				for(int i=0;i<=10;i++)
					p[i]+=res[i];
				x=fa[tp[x]];
			}
			memset(res,0,sizeof(res));
			if(dep[x]>dep[y])
				swap(x,y);
			ask(1,1,n,dfn[x],dfn[y]);
			for(int i=0;i<=10;i++)
				p[i]+=res[i];
			int LCA=lca(xx,yy);
			int ans=0;
			for(int i=0;i<=10;i++)
				ans+=(1<<i)*p[i]*(dep[xx]+dep[yy]-2*dep[LCA]+1-p[i]);
			printf("%lld\n",ans);
		}
		else{
			int x,y,z;
			x=read();
			y=read();
			z=read();
			int c;
			if(dep[x]>dep[y])
				c=x;
			else
				c=y;
			for(int i=0;i<=10;i++){
				if(((1<<i)&in[c])!=((1<<i)&z))
					change(1,1,n,dfn[c],dfn[c]+sz[c]-1,i);
			}
			in[c]=z;
		}
	}
}
```

---

## 作者：hychyc (赞：20)

题目大意：
给一棵树，有边权，支持两个操作。
（1）修改一个边权
（2）查询u到v的简单路径的所有子链的异或和的和

做法：
首先这是异或，注意到满足a^b^b = a，
要求所有子链的异或和，即求在(u, v)这个路径上的任意两点(x, y)的路径的异或和之和
考虑处理树上异或前缀和，即sum[i] = i 异或到根，从而sum[i]^sum[j]就是 i 异或到 j
然后发现要求所有的点对，一次一次求肯定会tle，那么考虑如何一次统计所有点对
对于某一位k，只需要求出来所有的前缀和中，这一位是0的有几个，这一位是1的有几个，把这两个乘起来就是组成点对这一位是1的个数，那么进行树剖+线段树即可
```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <set>
#include <algorithm>
#define MAXN 30050
using namespace std;
/*
输入格式：
第一行两个正整数n和q，表示点的个数，查询和询问的总次数。

接下来n-1行，每行两个正整数u、v、w，表示u和v两个点之间有一条边权为w的边。

接下来q行，格式为1 u v或2 u v w。如果为1 u v操作，
你需要输出u到v的路径上所有子路径经过的边的边权的xor值的和是多少；
如果为2 u v w操作，你需要把u到v这条边的边权改为w，保证这条边存在。

输出格式：
对于每个1操作，输出答案。*/
int n, q, son[MAXN], size[MAXN], dep[MAXN], fa[MAXN], top[MAXN], id[MAXN], b[MAXN], num[MAXN], ecnt, tcnt, ed[MAXN]; 
struct node{
    int v, w;
    node *next;
    node(){}
    node(int _v, int _w, node *_n) {
        v = _v, w = _w, next = _n;
    }
}pool[MAXN<<2], *h[MAXN];
struct node2{
    int num0, num1, rev;
    node2 operator + (const node2 &x){
        node2 t;
        t.num0 = num0 + x.num0;
        t.num1 = num1 + x.num1;
        t.rev = 0;
        return t;
    }
}t[25][MAXN<<3];
inline void addedge(int u, int v, int w){
    node *p1 = &pool[ecnt++], *p2 = &pool[ecnt++];
    *p1 = node(v, w, h[u]), h[u] = p1;
    *p2 = node(u, w, h[v]), h[v] = p2;
}
void dfs1(int u){
    size[u] = 1;
    for(node *p = h[u]; p; p = p->next){
        if(p->v != fa[u]){
            //cout<<u<<' '<<p->v<<' '<<b[u]<<' '<<p->w<<' '<<b[p->v]<<' ';
            b[p->v] = b[u]^p->w;
            ed[p->v] = p->w;
            //cout<<b[p->v]<<endl;
            fa[p->v] = u;
            dep[p->v] = dep[u]+1;
            dfs1(p->v);
            size[u] += size[p->v];
            if(size[p->v] > size[son[u]]) son[u] = p->v;
        }
    }
}
void dfs2(int u, int t){
    id[u] = ++tcnt;
    num[tcnt] = b[u];
    top[u] = t;
    if(!son[u]) return;
    dfs2(son[u], t);
    for(node *p = h[u]; p; p = p->next){
        if(!id[p->v]) dfs2(p->v, p->v);
    }
}
void build(int k, int u, int l, int r){
    if(l == r){
        if((num[l]>>k)&1)
            t[k][u].num1 = 1;
        else t[k][u].num0 = 1;
        return;
    }
    int mid = (l+r)>>1;
    build(k, u<<1, l, mid); build(k, u<<1|1, mid+1, r);
    t[k][u] = t[k][u<<1] + t[k][u<<1|1];
    //cout<<k<<' '<<u<<' '<<l<<' '<<r<<' '<<t[k][u].num0<<' '<<t[k][u].num1<<' '<<t[k][u].rev<<endl;
}
void pushdown(int k, int u){
    if(t[k][u].rev == 0) return;
    //cout<<"IN "<<k<<' '<<u<<endl;
    swap(t[k][u<<1].num0, t[k][u<<1].num1);
    swap(t[k][u<<1|1].num0, t[k][u<<1|1].num1);
    t[k][u<<1].rev ^= 1;
    t[k][u<<1|1].rev ^= 1;
    t[k][u].rev = 0;
}
void rev(int k, int u, int l, int r, int tl, int tr){
    if(tl <= l && r <= tr){
        swap(t[k][u].num0, t[k][u].num1);
        t[k][u].rev ^= 1;
        return;
    }
    int mid = (l+r)>>1;
    pushdown(k, u);
    if(tl <= mid) rev(k, u<<1, l, mid, tl, tr);
    if(mid < tr) rev(k, u<<1|1, mid+1, r, tl, tr);
    t[k][u] = t[k][u<<1] + t[k][u<<1|1];
}
void change(int u, int w){
    for(int i = 0; i <= 10; i++){
        if(((w^ed[u])>>i)&1)
            rev(i, 1, 1, n, id[u], id[u]+size[u]-1);
    }
    ed[u] = w;
}
node2 query(int k, int u, int l, int r, int tl, int tr){
    if(tl <= l && r <= tr){
        return t[k][u];
    }
    int mid = (l+r)>>1;
    pushdown(k, u);
    node2 ret; ret.num0 = ret.num1 = 0; 
    if(tl <= mid) ret = ret + query(k, u<<1, l, mid, tl, tr);
    if(mid < tr) ret = ret + query(k, u<<1|1, mid+1, r, tl, tr);
    //cout<<k<<' '<<u<<' '<<l<<' '<<r<<' '<<t[k][u].num0<<' '<<t[k][u].num1<<endl;
    return ret;
}
long long Query(int u, int v){
    long long ret = 0;
    int U = u, V = v;
    for(int i = 0; i <= 10; i++){
        u = U, v = V;
        //cout<<i<<endl;
        node2 res; res.num0 = res.num1 = 0;
        while(top[u] != top[v]){
            if(dep[top[u]] < dep[top[v]]) swap(u, v);
            res = res + query(i, 1, 1, n, id[top[u]], id[u]);
            //cout<<id[top[u]]<<' '<<id[u]<<' '<<res.num0<<' '<<res.num1<<endl;
            u = fa[top[u]];
        }
        if(dep[u] > dep[v]) swap(u, v);
        res = res + query(i, 1, 1, n, id[u], id[v]);
        //cout<<id[u]<<' '<<id[v]<<' '<<res.num0<<' '<<res.num1<<endl;
        ret += (1LL<<i)*res.num0*res.num1;
    }
    return ret;
}
int main(){
    //freopen("1.in", "r", stdin);
    //freopen("1.out", "w", stdout);
    int opt, u, v, w;
    scanf("%d%d", &n, &q);
    for(int i = 1; i < n; i++) scanf("%d%d%d", &u, &v, &w), addedge(u, v, w);
    dep[1] = 1;
    dfs1(1);
    dfs2(1, 1);
    //for(int i = 1; i <= n; i++) cout<<dep[i]<<' ';cout<<endl;
    for(int i = 0; i <= 10; i++) build(i, 1, 1, n);
    while(q--){
        scanf("%d%d%d", &opt, &u, &v);
        if(opt == 1){
            printf("%lld\n", Query(u, v));
        }
        else{
            scanf("%d", &w);
            if(u != fa[v]) swap(u, v);
            change(v, w);
        }
    }
    return 0;
}
```

---

## 作者：Running_Coder (赞：9)

这道题好干燥啊。。。折腾了半个月。。。感谢bogo大佬对我的指导。。。

楼下大佬的代码(莫非是zkw这种我没学过的东西)看不懂啊。。。好不容易把这题搞出来了，那我就来发个好懂一些的吧

题目要求支持的操作：1.查询某段路径的所有子路径的xor值之和；2.修改某条边的权值。重点是操作1。

刚开始，我看到了操作1之后就不自觉的想到了非~常暴力的东西。。。还好大佬及时把我引上正途：分治！

大家知道，最大子段和有个分治算法，本题的方法就跟这个比较类似。

对于一段子路径，若它能对答案产生贡献，那么它要么完全在左儿子中，要么完全在右儿子中，要么跨越左右儿子。

对于每段路径，我们需要记录如下变量：yh:异或和，ans:答案，就是要查询的东西，p0[i]:此序列的前缀序列中，异或和的二进制第i位为0的序列有多少段，后面的p1,s0,s1类似。

于是，在分治的合并阶段，答案便分为两个部分：第一部分是左右儿子返回的ans；第二部分是左儿子的s0[i]\*p1[i]和s1[i]\*p0[i]，这两个结果还要再乘以(1 << i)，表示有多少段跨越左右儿子的子路径的xor值的二进制第i位为1，乘上(1 << i)之后就表示答案实际应该累加的值。因为0和1、1和0异或的结果是1嘛，因此就对答案产生了贡献。

我们当然也要维护p0、p1、s0、s1。这里较上面简单一些，细节详见代码的rg\_a结构体定义部分。

以上讨论的都是链上的做法，题目给定的是一棵树，那么树剖就Ok了，之后扔到线段树里大力merge即可~

对于修改操作，在线段树底层重建节点，然后顺次merge其所有祖先即可。

下面说几个疑难的问题：

一.要建线段树，要求权值在点上，但题目却说在边上。怎么办呢？可以把每条边的边权下放到树中此条边下方连接的节点上。这样，根节点就不会被下放，但是并不影响结果，至于为什么，会在下面提到。

二.查询时，对于一段路径u->lca->v，因为lca也被下放了权值，但是它对应的边并不在u->v路径中，因此不能被统计，所以查询时只统计路径上除lca之外的点。鉴于此，上面提到的根节点便无所谓是否下放了。具体操作时，在树剖“跳”的过程的末端稍加修改即可。

三.这点非常重要！

我在做这题时，前几份代码狂WA不止，后来找到原因：merge操作不满足交换律，但是我在查询时却出现了运算顺序的漏洞。经过一番脑洞，我找到了正确的运算顺序，现描述如下：

1.将树剖的待合并结果分成u->lca和lca->v两部分，存入数组TL和TR；

2.将TL和TR的结果分别全部合并到TL[1]和TR[1]中(注意这里的运算顺序，建议手动画图验证)；

3.进行特判，如果TL为空，那么直接返回TR[1].ans，反之亦然；

4.若TL、TR均非空，则先将TL[1]进行“翻转”(细节见代码，同样建议画图验证)，然后合并TL[1]、TR[1]，返回合并后的ans即可。

四.有个小坑，或许是我不够细心吧，那就是查询的路径的起点和终点有可能是同一个点。开始没注意这个，结果导致WA成70分。所以我在查询时加了个特判，若u==v则直接返回0。

代码如下，又丑又长，见谅见谅：

    
    
    
    
    
        
        
        
    
    
    
    
    
    
        
            
            
                
                
                
                
                
            
    
        
                
                
        
                
                
        
                    
    
    
    
        
        
        
        
        
        
        
            
        
    
    
        
        
                
                
            
    
        
        
        
            
    
        
        
        
        
        
            
```cpp
    #include<cstdio>
    #include<iostream>
    #include<cstring>
    #include<cmath>
    #include<ctime>
    #include<cstdlib>
    #include<string>
    #include<stack>
    #include<queue>
    #include<vector>
    #include<algorithm>
    #include<map>
    #include<set>
    #define inf 2147483647
    #define ri register int
    #define ll long long
    #define mid (l+r>>1)
    #define lson (o<<1)
    #define rson ((o<<1)+1)
    using namespace std;
    inline void read(int &x){
        x=0;
        char t=getchar();
        bool f=0;
        while(t<'0' || t>'9'){
            if(t=='-')f=1;
            t=getchar();
        }
        while(t>='0' && t<='9'){
            x=(x<<3)+(x<<1)+t-'0';
            t=getchar();
        }
        if(f)x=-x;
    }
    inline void addedge(int,int,int);
    int u[60005];
    int v[60005];
    int w[60005];
    int fi[30005];
    int ne[60005];
    int pe=0;  //无向邻接表 
    int wp[30005];  //下放的点权 
    void dfs1(int);
    int fa[30005];  //父亲 
    int dep[30005];  //深度 
    int size[30005];  //子树大小 
    int son[30005];  //重儿子 
    void dfs2(int);
    int top[30005];  //链顶节点 
    int dfsx[30005];  //dfs序 
    int xu=0;
    int pos[30005];  //节点位置,in Sgt.
    struct rg_a{
        ll yh;  //异或和 
        ll ans;  //答案 
        ll p0[10],p1[10],s0[10],s1[10];  //本段区间二进制第j位为0/1的前/后缀区间数 
        inline void merge(rg_a &A,rg_a &B){  //合并 
            rg_a T;  //记录合并结果
            int bl,br;  //抽取A/B的异或和的二进制第i位
            T.yh=A.yh^B.yh;
            T.ans=A.ans+B.ans;
            for(ri i=0;i<10;i++){
                T.ans+=A.s0[i]*B.p1[i]*(1<<i);
                T.ans+=A.s1[i]*B.p0[i]*(1<<i);
                bl=(A.yh>>i)&1;
                br=(B.yh>>i)&1;
                T.p0[i]=A.p0[i];
                if(bl)T.p0[i]+=B.p1[i];
                else T.p0[i]+=B.p0[i];
                T.p1[i]=A.p1[i];
                if(bl)T.p1[i]+=B.p0[i];
                else T.p1[i]+=B.p1[i];
                T.s0[i]=B.s0[i];
                if(br)T.s0[i]+=A.s1[i];
                else T.s0[i]+=A.s0[i];
                T.s1[i]=B.s1[i];
                if(br)T.s1[i]+=A.s0[i];
                else T.s1[i]+=A.s1[i];
            }
            *this=T;
        }
    };
    struct sgt{  //线段树
        rg_a node[120005];
        void build(int o,int l,int r){
            if(l==r){
                node[o].yh=node[o].ans=wp[dfsx[l]];
                for(ri i=0;i<10;i++){
                    node[o].p0[i]=node[o].s0[i]=((node[o].yh>>i)&1)^1;
                    node[o].p1[i]=node[o].s1[i]=(node[o].yh>>i)&1;
                }
            }
            else{
                build(lson,l,mid);
                build(rson,mid+1,r);
                node[o].merge(node[lson],node[rson]);
            }
        }
        void update(int o,int l,int r,int p,int x){
            if(l==r && l==p){
                node[o].yh=node[o].ans=x;
                for(ri i=0;i<10;i++){
                    node[o].p0[i]=node[o].s0[i]=((x>>i)&1)^1;
                    node[o].p1[i]=node[o].s1[i]=(x>>i)&1;
                }
            }
            else{
                if(p<=mid)update(lson,l,mid,p,x);
                else update(rson,mid+1,r,p,x);
                node[o].merge(node[lson],node[rson]);
            }
        }
        rg_a query(int o,int l,int r,int a,int b){
            if(l>=a && r<=b)return node[o];
            else{
                if(b<=mid)return query(lson,l,mid,a,b);
                else if(a>mid)return query(rson,mid+1,r,a,b);
                else{
                    rg_a tl=query(lson,l,mid,a,b);
                    rg_a tr=query(rson,mid+1,r,a,b);
                    tl.merge(tl,tr);
                    return tl;
                }
            }
        }
    } tree;
    inline ll path_query(int,int);
    rg_a TL[50],TR[50];  //外层查询临时结果
    int pl,pr;  //记录TL和TR存放的临时结果的数量
    int n,q;
    int f,x,y,z;
    int root;
    int main(){
        srand(time(0)+19260817);
        read(n);read(q);
        root=rand()%n+1;  //Ha~
        for(ri i=1;i<n;i++){
            read(x);read(y);read(z);
            addedge(x,y,z);
            addedge(y,x,z);
        }
        fa[root]=0;
        dep[root]=1;
        wp[root]=0;
        dfs1(root);
        top[root]=root;
        dfs2(root);
        for(ri i=1;i<=n;i++)pos[dfsx[i]]=i;
        tree.build(1,1,n);
        while(q--){
            read(f);
            if(f==1){
                read(x);read(y);
                printf("%lld\n",path_query(x,y));
            }
            else{
                read(x);read(y);read(z);
                if(pos[x]<pos[y])tree.update(1,1,n,pos[y],z);
                else tree.update(1,1,n,pos[x],z);
            }
        }
        return 0;
    }
    inline void addedge(int x,int y,int z){
        pe++;
        u[pe]=x;
        v[pe]=y;
        w[pe]=z;
        ne[pe]=fi[x];
        fi[x]=pe;
    }
    void dfs1(int s){
        size[s]=1;
        int maxson=0;
        int t=fi[s];
        int to=v[t];
        while(t){
            if(to!=fa[s]){
                fa[to]=s;
                dep[to]=dep[s]+1;
                wp[to]=w[t];
                dfs1(to);
                size[s]+=size[to];
                if(size[to]>maxson){
                    son[s]=to;
                    maxson=size[to];
                }
            }
            t=ne[t];
            to=v[t];
        }
    }
    void dfs2(int s){
        xu++;
        dfsx[xu]=s;
        if(son[s]){
            top[son[s]]=top[s];
            dfs2(son[s]);
        }
        int t=fi[s];
        int to=v[t];
        while(t){
            if(to!=fa[s] && to!=son[s]){
                top[to]=to;
                dfs2(to);
            }
            t=ne[t];
            to=v[t];
        }
    }
    inline ll path_query(int x,int y){
        if(x==y)return 0;  //特判起终点相同
        pl=pr=0;  //重置临时结果数组
        int tx=top[x],ty=top[y];
        while(tx!=ty){
            if(dep[tx]>dep[ty]){
                pl++;
                TL[pl]=tree.query(1,1,n,pos[tx],pos[x]);
                x=fa[tx];
                tx=top[x];
            }
            else{
                pr++;
                TR[pr]=tree.query(1,1,n,pos[ty],pos[y]);
                y=fa[ty];
                ty=top[y];
            }
        }
        if(x!=y){
            if(pos[x]<pos[y]){
                pr++;
                TR[pr]=tree.query(1,1,n,pos[x]+1,pos[y]);
            }
            else{
                pl++;
                TL[pl]=tree.query(1,1,n,pos[y]+1,pos[x]);
            }
        }
        for(ri i=2;i<=pl;i++)TL[1].merge(TL[i],TL[1]);
        for(ri i=2;i<=pr;i++)TR[1].merge(TR[i],TR[1]);
        //这里全部都要注意运算顺序！
        if(!pl)return TR[1].ans;
        else if(!pr)return TL[1].ans;  //特判答案仅在lca一侧的情况
        else{
            for(ri i=0;i<10;i++){
                swap(TL[1].p0[i],TL[1].s0[i]);
                swap(TL[1].p1[i],TL[1].s1[i]);
            }  //“翻转”TL[1]
            TL[1].merge(TL[1],TR[1]);
            return TL[1].ans;
        }
}
```

---

## 作者：ComeIntoPower (赞：7)

树链剖分啊

对于每条链x,

记一个pre[x][j][k],suf[x][j][k]表示对于这条链,前缀或后缀的异或在j位有几个k(0/1)

记一个答案ans[x],记一个异或和yh[x]

于是我们可以用分治的思想,更新ans,pre,suf

链剖查询时就用一个l和r表示左右的结果分别是什么

最终答案就是ans[o]=ans[l]+ans[r]+Sum{(pre[l][i][0]\*pre[r][i][1]+pre[l][i][1]\*pre[r][i][0])<<i}


```Cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#define maxn 30100
#define lans (maxn*4 -10)
#define rans (maxn*4 -100)
#define xans (maxn*4 -20)
#define yans (maxn*4 -30)
using namespace std;
struct edges{
    int r,nxt,w;
}e[maxn<<1];
int head[maxn],esz;
int dep[maxn],fa[maxn],top[maxn],son[maxn],id[maxn],idsz,m,w[maxn];
long long ans[maxn<<2],pre[maxn<<2][10][2],suf[maxn<<2][10][2],yh[maxn<<2];
int dfs(int u,int f,int d){
    fa[u]=f;
    dep[u]=d;
    int ssz=0,mxs=0,so=0;
    for(int t=head[u];t;t=e[t].nxt)if(e[t].r!=f){
        w[e[t].r]=e[t].w;
        int a=dfs(e[t].r,u,d+1);
        if(mxs<a)mxs=a,so=e[t].r;
        ssz+=a;
    }
    son[u]=so;
    return ssz+1;
}
void dfs2(int u,int tp){
    id[u]=++idsz;
    top[u]=tp;
    if(son[u])dfs2(son[u],tp);
    for(int t=head[u];t;t=e[t].nxt)
        if(e[t].r!=fa[u]&&e[t].r!=son[u])
            dfs2(e[t].r,e[t].r);
}
void merge(int o,int l,int r){
    ans[o]=ans[l]+ans[r];
    for(int i=0;i<10;++i){
        int zp=(yh[l]>>i)&1;
        int zs=(yh[r]>>i)&1;
        ans[o]+=(suf[l][i][0]*pre[r][i][1]+suf[l][i][1]*pre[r][i][0])<<i;
//        printf("[%d]",(suf[l][i][0]*pre[r][i][1]+suf[l][i][1]*pre[r][i][0])<<i);
        long long a=pre[l][i][0]+pre[r][i][zp];
        long long b=pre[l][i][1]+pre[r][i][!zp];
        long long c=suf[r][i][0]+suf[l][i][zs];
        long long d=suf[r][i][1]+suf[l][i][!zs];
        pre[o][i][0]=a;
        pre[o][i][1]=b;
        suf[o][i][0]=c;
        suf[o][i][1]=d;
    }
    yh[o]=yh[l]^yh[r];    
}
void init(int x){
    memset(pre[x],0,sizeof(pre[x]));
    memset(suf[x],0,sizeof(suf[x]));
    yh[x]=ans[x]=0;
}
void qsum(int x,int l,int r){
    if(l>r)swap(l,r);
    l+=m-1-1,r+=m+1-1;
    init(xans),init(yans);
    for(;l^r^1;l>>=1,r>>=1){
        if(~l&1)merge(xans,xans,l^1);
        if(r&1)merge(yans,r^1,yans);
    }    
    
    merge(xans,xans,yans);
    merge(x,xans,x);
//    printf("[%d=%d]\n",x,ans[x]);
//    for(int i=0;i<10;++i)printf("[%d,%d]\n",pre[x][i][1],pre[x][i][0]);
//    printf("\n---------------\n");
}
void modify(int l,int a){
    l+=m-1;
    ans[l]=yh[l]=a;
    for(int i=0;i<10;++i)
        pre[l][i][0]=suf[l][i][0]=pre[l][i][1]=suf[l][i][1]=0;
    for(int i=0;i<10;++i)
        pre[l][i][(a>>i)&1]++,suf[l][i][(a>>i)&1]++;
    for(l>>=1;l;l>>=1)merge(l,l<<1,l<<1|1);
}
long long calc(int l,int r){
    ans[0]=ans[l]+ans[r];
    for(int i=0;i<10;++i)
        ans[0]+=(pre[l][i][0]*pre[r][i][1]+pre[l][i][1]*pre[r][i][0])<<i;
    return ans[0];
}

long long query(int u,int v){
    init(lans),init(rans),init(0);
    int tp1=top[u],tp2=top[v],l=lans,r=rans;
    while(tp1!=tp2){
        if(dep[tp1]<dep[tp2])
            swap(tp1,tp2),swap(u,v),swap(l,r);
//        printf("[%d,%d]",u,tp1);
        qsum(l,id[u],id[tp1]);
        u=fa[tp1];tp1=top[u];
    }
    if(u==v)return calc(l,r);
    if(dep[u]>dep[v])swap(u,v),swap(l,r);
    qsum(r,id[son[u]],id[v]);
    return calc(l,r);
}
void addedge(int u,int v,int w){
    e[++esz].r=v;e[esz].nxt=head[u];head[u]=esz;
    e[esz].w=w;         
}
int main(){
    int n,q;scanf("%d%d",&n,&q);
    for(int i=1;i<n;++i){
        int u,v,a;
        scanf("%d%d%d",&u,&v,&a);
        addedge(u,v,a);
        addedge(v,u,a);
    }
    
    dfs(1,0,1);
    dfs2(1,1);
    for(m=1;m-2<=n;m<<=1);
    for(int i=2;i<=n;++i)modify(id[i],w[i]);
    for(int i=1;i<=q;++i){
        int c,u,v,w;scanf("%d%d%d",&c,&u,&v);
        if(c==1){
            printf("%lld\n",query(u,v));
        } else {
            scanf("%d",&w);
            modify(dep[u]<dep[v]?id[v]:id[u],w);
        }
    }
    
}
```


---

## 作者：zhenjianuo2025 (赞：6)

### Solve

**前置知识**：异或、线段树、重链剖分。

预处理出每个点到根结点路径上经过的所有边权的异或和 $s_i$，因为 $a\operatorname{xor}a\operatorname{xor}b=b$，询问操作可以转化为 $u$ 到 $v$ 的路径上经过的所有点的 $s_i$ 中任选两个异或产生的所有结果的和。

因为异或运算位与位之间是独立的，考虑建 $\log_2 \max\{w\}=10$ 棵线段树，第 $i$ 棵线段树的每个结点维护一段 $\text{dfn}$ 值连续的结点区间中 $s$ 值第 $i$ 位为 $1$ 的结点有多少个。

**询问操作**：

对于每次询问，树剖统计 $u,v$ 路径上所有结点 $s$ 值第 $i$ 位为 $1$ 的个数 $w_i$，记 $u,v$ 路径上经过的结点个数为 $z$。然后按位处理，依次考虑每一位的贡献。第 $i$ 位带来的贡献即为 $w_i\cdot (x-w_i)\cdot 2^i$，意思是每一个该位为 $1$ 的结点 $s$ 值与一个该位为 $0$ 的结点的 $s$ 值异或后该位会变成 $1$。

**修改操作**：

记录这条边原来的边权 $x$，设新边权为 $y$，若 $x$ 与 $y$ 第 $i$ 为不相同，则将深度较深的结点的子树所有结点的 $s$ 值第 $i$ 位反转（即 $1$ 变 $0$，$0$ 变 $1$）。

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n, q, a[30010], tim, wid[30010], fa[30010], dis[30010], siz[30010], son[30010], dfn[30010], top[30010];
vector<pair<int, int> > g[30010];
inline void init(const int &u, const int &f) {
	siz[u] = 1;
	for (register int i = 0; i < g[u].size(); i++) {
		const int v = g[u][i].first, w = g[u][i].second;
		if (v == f) continue;
		fa[v] = u;
		wid[v] = w;
		dis[v] = dis[u] + 1;
		init(v, u);
		siz[u] += siz[v];
		if (siz[v] > siz[son[u]]) son[u] = v;
	}
}
inline void dfs(const int &u, const int &p, const int &s) {
	top[u] = p;
	dfn[u] = ++tim;	
	a[dfn[u]] = s;
	if (!son[u]) return;
	dfs(son[u], p, s ^ wid[son[u]]);
	for (register int i = 0; i < g[u].size(); i++) {
		const int v = g[u][i].first, w = g[u][i].second;
		if (v == fa[u] || v == son[u]) continue;
		dfs(v, v, s ^ w);
	}
}
struct Segment_Tree {
	int sum[120010][12];   // 区间内所有数中第 i 位为 1 的数的个数 
	bool lzy[120010][12];
	inline bool GetIdx(const int &x, const int &k) { return x & (1ll << k); }
	inline bool InRange(const int &l, const int &r, const int &L, const int &R) { return L <= l && R >= r; }
	inline bool OutoRange(const int &l, const int &r, const int &L, const int &R) { return r < L || R < l; }
	inline void pushup(const int &u) { for (register int i = 0; i <= 10; i++) sum[u][i] = sum[u << 1][i] + sum[u << 1 | 1][i]; }
	inline void pushup_k(const int &u, const int &k) { sum[u][k] = sum[u << 1][k] + sum[u << 1 | 1][k]; }
	inline void maketag(const int &u, const int &l, const int &r, const int &k) {
		lzy[u][k] = !lzy[u][k]; sum[u][k] = r - l + 1 - sum[u][k]; 
	}
	inline void pushdown(const int &u, const int &l, const int &r, const int &k) {
		if (!lzy[u][k]) return;
		lzy[u][k] = 0;
		const int mid = (l + r) >> 1;
		maketag(u << 1, l, mid, k), maketag(u << 1 | 1, mid + 1, r, k);
	}
	inline void build(const int &u, const int &l, const int &r) {
		if (l == r) { for (register int i = 0; i <= 10; i++) sum[u][i] = GetIdx(a[l], i); return; } 
		const int mid = (l + r) >> 1; build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r); pushup(u);
	}
	inline void update(const int &u, const int &l, const int &r, const int &L, const int &R, const int &k) {
		// 区间内所有数的第 k 位取反 
		if (InRange(l, r, L, R)) { maketag(u, l, r, k); return; } 
		else if (!OutoRange(l, r, L, R)) {
			pushdown(u, l, r, k);
			const int mid = (l + r) >> 1;
			update(u << 1, l, mid, L, R, k), update(u << 1 | 1, mid + 1, r, L, R, k);
			pushup_k(u, k);
		}
	}
	inline int query(const int &u, const int &l, const int &r, const int &L, const int &R, const int &k) {
		// 区间内第 k 位为 1 的数的个数
		if (InRange(l, r, L, R)) return sum[u][k];
		else if (!OutoRange(l, r, L, R)) {
			const int mid = (l + r) >> 1;
			pushdown(u, l, r, k);
			return query(u << 1, l, mid, L, R, k) + query(u << 1 | 1, mid + 1, r, L, R, k);
		} else return 0;
	}
} tree;
int tmp[12];   // 路径上第 i 位为 1 的数的个数 
inline int query(int u, int v) {
	memset(tmp, 0, sizeof tmp);
	int cnt = 0;
	while (top[u] != top[v]) {
		if (dis[top[u]] < dis[top[v]]) swap(u, v);
		for (register int i = 0; i <= 10; i++) tmp[i] += tree.query(1, 1, n, dfn[top[u]], dfn[u], i); 
		cnt += dfn[u] - dfn[top[u]] + 1; u = fa[top[u]]; 
	}
	if (dis[u] < dis[v]) swap(u, v);
	cnt += dfn[u] - dfn[v] + 1;
	for (register int i = 0; i <= 10; i++) tmp[i] += tree.query(1, 1, n, dfn[v], dfn[u], i);
	int ans = 0;
	for (register int i = 0; i <= 10; i++) ans += (1ll << i) * tmp[i] * (cnt - tmp[i]);
	return ans; 
}
inline void update(int u, int v, const int &w) {
	if (dis[u] > dis[v]) swap(u, v);
	for (register int i = 0; i <= 10; i++) {
		bool x = tree.GetIdx(w, i), y = tree.GetIdx(wid[v], i);
		if (x != y) tree.update(1, 1, n, dfn[v], dfn[v] + siz[v] - 1, i);
	}
	wid[v] = w;
}
signed main() {
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	cin >> n >> q;
	for (register int i = 1; i < n; i++) {
		int u, v, w;
		cin >> u >> v >> w;
		g[u].push_back({v, w}), g[v].push_back({u, w});
	}
	dis[1] = 1; init(1, 0); dfs(1, 1, 0); tree.build(1, 1, n);
	while (q--) {
		int opt, u, v, w;
		cin >> opt >> u >> v;
		if (opt == 1) cout << query(u, v) << "\n";
		else {
			cin >> w;
			update(u, v, w);
		}
	}
	return 0;
}
```

---

## 作者：Pengzt (赞：4)

**[cnblogs](https://www.cnblogs.com/Pengzt/p/17846958.html)**

**[P3401](https://www.luogu.com.cn/problem/P3401)**

考虑先将路径权值进行转化，因为很难对路径直接进行统计。考虑如何表示出这条路径的权值。记 $s_i = \oplus_{j \in \text{path}(1, i)} w_j$，其中 $\text{path}(i, j)$ 表示 $i$ 到 $j$ 的路径上的边集。则 $u\to v$ 的路径的权值为 $s_u\oplus s_v$。

现在转变为了求两点路径上任选两点的权值和，以及区间异或。区间异或是因为单次修改一条边的边权会导致其子树内所有点的 $s$ 值改变，即在 $u$ 子树内的点都会异或上 $x\oplus s_u$，$x$ 指要修改为的值。

不好直接维护，但是看到异或，可以考虑拆位，这样统计和修改都会很简单。统计就是对每一位找到路径中有多少个点的 $s$ 值的第 $i$ 位为 $1$，记为 $c$，若路径上共有 $p$ 个点，则答案为 $2^i\times c\times(p - c)$。然后修改操作变为区间取反，直接上线段树即可。

时间复杂度：$\mathcal{O}(n\log^2n\log V)$。
空间复杂度：$\mathcal{O}(n\log V)$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define vi vector<int>
#define eb emplace_back
#define pii pair<int, ll>
#define fi first
#define se second
#define TIME 1e3 * clock() / CLOCKS_PER_SEC
bool Mbe;
mt19937_64 rng(35);
constexpr int N = 3e5 + 10;
int n, m, dfc;
int s[N], vn[N];
int sz[N], dep[N], hv[N], fa[N], top[N], dfn[N], rdfn[N];
int head[N], cnt_e;
struct edge {
	int to, w, nxt;
} e[N << 1];
void adde(int u, int v, int w) {
	++cnt_e, e[cnt_e].to = v, e[cnt_e].w = w, e[cnt_e].nxt = head[u], head[u] = cnt_e;
}
void dfs1(int u, int ff) {
	fa[u] = ff, dep[u] = dep[ff] + 1, sz[u] = 1;
	for(int i = head[u]; i; i = e[i].nxt) {
		int v = e[i].to;
		if(v == ff) continue;
		s[v] = e[i].w ^ s[u];
		vn[v] = e[i].w;
		dfs1(v, u);
		sz[u] += sz[v];
		if(sz[v] > sz[hv[u]]) hv[u] = v;
	}
}
void dfs2(int u, int f) {
	top[u] = f, rdfn[dfn[u] = ++dfc] = u;
	if(!hv[u]) return;
	dfs2(hv[u], f);
	for(int i = head[u]; i; i = e[i].nxt) {
		int v = e[i].to;
		if(v == hv[u] || v == fa[u]) continue;
		dfs2(v, v);
	}
}
vi cnt(10), tmp(10);
int val[N << 2][10], laz[N << 2][10];
void tag(int x, int y, int L, int R) {
	val[x][y] = (R - L + 1) - val[x][y];
	laz[x][y] ^= 1;
}
void down(int x, int y, int L, int R) {
	if(laz[x][y]) {
		int m = (L + R) >> 1;
		tag(x << 1, y, L, m);
		tag(x << 1 | 1, y, m + 1, R);
		laz[x][y] = 0;
	}
}
void build(int x, int L, int R) {
	if(L == R) {
		for(int i = 0; i < 10; ++i) val[x][i] = s[rdfn[L]] >> i & 1;
		return;
	}
	int m = (L + R) >> 1;
	build(x << 1, L, m);
	build(x << 1 | 1, m + 1, R);
	for(int i = 0; i < 10; ++i) val[x][i] = val[x << 1][i] + val[x << 1 | 1][i];
}
void modify(int x, int L, int R, int l, int r, int v) {
	if(l <= L && R <= r) {
		for(int i = 0; i < 10; ++i)
			if(v >> i & 1)
				tag(x, i, L, R);
		return;
	}
	for(int i = 0; i < 10; ++i) down(x, i, L, R);
	int m = (L + R) >> 1;
	if(l <= m) modify(x << 1, L, m, l, r, v);
	if(r > m) modify(x << 1 | 1, m + 1, R, l, r, v);
	for(int i = 0; i < 10; ++i)
		val[x][i] = val[x << 1][i] + val[x << 1 | 1][i];
}
void query(int x, int L, int R, int l, int r) {
	if(l <= L && R <= r) {
		for(int i = 0; i < 10; ++i) cnt[i] += val[x][i];
		return;
	}
	for(int i = 0; i < 10; ++i) down(x, i, L, R);
	int m = (L + R) >> 1;
	if(l <= m) query(x << 1, L, m, l, r);
	if(r > m) query(x << 1 | 1, m + 1, R, l, r);
}
ll qry(int u, int v) {
	int au = u, av = v;
	for(int i = 0; i < 10; ++i) cnt[i] = 0;
	while(top[u] ^ top[v]) {
		if(dep[top[u]] < dep[top[v]]) swap(u, v);
		query(1, 1, n, dfn[top[u]], dfn[u]);
		u = fa[top[u]];
	}
	if(dfn[u] < dfn[v]) swap(u, v);
	query(1, 1, n, dfn[v], dfn[u]);
	ll ans = 0;
	for(int i = 0; i < 10; ++i) {
		int c1 = cnt[i], c2 = dep[au] + dep[av] - 2 * dep[v] - cnt[i] + 1;
		ans += (1ll << i) * c1 * c2;
	}
	return ans;
}
bool Med;
int main() {
	fprintf(stderr, "%.3lf MB\n", (&Mbe - &Med) / 1048576.0);
//	freopen("P3401_1.in", "r", stdin);
//	freopen("data.out", "w", stdout);
	ios :: sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin >> n >> m;
	for(int i = 1; i < n; ++i) {
		int u, v, w;
		cin >> u >> v >> w;
		adde(u, v, w);
		adde(v, u, w);
	}
	dfs1(1, 0);
	dfs2(1, 1);
	build(1, 1, n);
	for(int i = 1; i <= m; ++i) {
		int opt, x, y, z;
		cin >> opt >> x >> y;
		if(opt == 1) {
			cout << qry(x, y) << "\n";	
		} else {
			cin >> z;
			if(dep[x] < dep[y]) swap(x, y);
			modify(1, 1, n, dfn[x], dfn[x] + sz[x] - 1, vn[x] ^ z);
			vn[x] = z;
		}
	}
	cerr << TIME << "ms\n";
	return 0;
}
```

---

## 作者：pikabi (赞：4)

### 有关异或和的树剖+线段树

首先用树剖建一棵线段树，维护的是树上每个点以根节点为起始位置的边权前缀和，容易想到边权前缀和可以放在儿子节点处以方便处理。

对于每一条树上路径，我们都可以用两点所保存的前缀和相互 Xor 所得。然而每对节点匹配时长太大，我们将其按位拆分（依旧用线段树维护），对于第 $i$ 位上的答案就是 $2 ^ i \times ans_i \times (sum - ans_i)$ ，其中 $ans_i$ 表示第 $i$ 位目标目标路径上的 $1$ 总数的总数，$sum$ 可以由 $dep_u + dep_v - dep_{LCA(u, v)}$ 得到, 如此便完成了 1 操作。

对于 2 操作，选择 $u$ , $v$ 中为儿子的那个，记为 $p$ ,  修改其权值，而它的儿子的前缀和也会改变，改变值就是 $now_p$ Xor $w$ , 在线段树上修改即可，同时不要忘了将 $now_p$ 改为 $w$ .

与其他题解不同的是，我们修改时将修改值直接传递，节省了空间，时间也相对比较优秀。

下面给上代码 $-->$

```cpp
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <cctype>
#define ll long long
#define inf 1023456789

using namespace std;

inline int read(){
	int x=0,w=0;char ch=getchar();
	while (!isdigit(ch))w|=ch=='-',ch=getchar();
	while (isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
	return w?-x:x;
}

struct node{
	int to, nxt, val;
}e[1000005];

int n, q, head[100005], cnt;

inline void add(int from, int to, int val){
	e[++cnt].nxt = head[from];
	head[from] = cnt;
	e[cnt].to = to;
	e[cnt].val = val;
}

int f[100005], dep[100005], son[100005], siz[100005], vv[100005], two[15], QAQ[100005];

inline void dfs1(int p, int fa, int w){
	vv[p] = w;
	f[p] = fa;
	dep[p] = dep[fa] + 1;
	siz[p] = 1;
	for(int i = head[p]; i; i = e[i].nxt ){
		if(e[i].to == fa) continue;
		dfs1(e[i].to , p, e[i].val ^ w);
		QAQ[e[i].to ] = e[i].val ;
		siz[p] += siz[e[i].to ];
		if(siz[son[p]] < siz[e[i].to ]) son[p] = e[i].to ; 
	}
}

int id[100005], top[100005], tot, vvv[100005];

inline void dfs2(int p, int topf){
	top[p] = topf;
	id[p] = ++tot;
	vvv[tot] = vv[p];
	if(!son[p]) return ;
	dfs2(son[p] , topf); 
	for(int i = head[p]; i; i = e[i].nxt ){
		if(e[i].to == f[p] || e[i].to == son[p]) continue ;
		dfs2(e[i].to ,e[i].to );
	}
}

struct Segment_Tree{
	int val[12];
	int tag;
}a[5000005]; 

inline int ls(int p){
	return p << 1;
} 

inline int rs(int p){
	return p << 1 | 1;
}

inline void update(int p){
	for(int i = 0; i <= 10; i++)
	a[p].val[i] = a[ls(p)].val[i] + a[rs(p)].val[i];
}

inline void push_up(int p, int l, int r, int k){
	a[p].tag ^= k;
	int now = 0;
	while(k){
		if(k & 1) a[p].val[now] = r - l + 1 - a[p].val[now];
		now ++;
		k >>= 1;
	}
}

inline void push_down(int p, int l, int r){
	if(!a[p].tag ) return ;
	int mid = l + r >> 1;
	push_up(ls(p), l, mid, a[p].tag );
	push_up(rs(p), mid + 1, r, a[p].tag );
	a[p].tag = 0;
}

inline void build(int p, int l, int r){
	if(l == r){
		int now = 0, w = vvv[l];
		while(w){
			a[p].val[now] = w & 1;
			w >>= 1;
			now++;
		}
		return ;
	}
	int mid = l + r >> 1;
	build(ls(p), l, mid);
	build(rs(p), mid + 1, r);
	update(p);
}

int ans[12];

inline void modify(int p, int l, int r, int L, int R, int k){
	if(L <= l && r <= R){
		int now = 0, w = k;
		while(w){
			if(w & 1)
			a[p].val[now] = r - l + 1 - a[p].val[now] ;
			w >>= 1;
			now++;
		}
		a[p].tag ^= k;
		return ;
	}
	push_down(p, l, r);
	int mid = l + r >> 1;
	if(L <= mid) modify(ls(p), l, mid, L, R, k);
	if(mid < R) modify(rs(p), mid + 1, r, L, R, k);
	update(p);
}

inline void query(int p, int l, int r, int L, int R){
	if(L <= l && r <= R){
		for(int i = 0; i <= 10; i++)
		ans[i] += a[p].val[i];
		return ;
	}
	push_down(p, l, r);
	int mid = l + r >> 1;
	if(L <= mid) query(ls(p), l, mid, L, R);
	if(mid < R) query(rs(p), mid + 1, r, L, R); 
	update(p);
}

inline ll query_range(int u, int v){
	int sum = dep[u] + dep[v];
	for(int i = 0; i <= 10; i++) ans[i] = 0;
	while(top[u] != top[v]){
		if(dep[top[u]] < dep[top[v]]) swap(u, v);
		query(1, 1, n, id[top[u]], id[u]);
		u = f[top[u]];
	}
	if(dep[u] < dep[v]) swap(u, v);
	query(1, 1, n, id[v], id[u]);
	sum += - 2 * dep[v] + 1;
	ll res = 0;
	for(int i = 0; i <= 10; i++){
		res += (ll) two[i] * ans[i] * (sum - ans[i]);
	}
	return res;
}

inline void up_son(int p, int k){
	modify(1, 1, n, id[p], id[p] + siz[p] - 1, k);
}

int main(){
	n = read(), q = read();
	two[0] = 1;
	for(int i = 1; i <= 10; i++) two[i] = two[i - 1] * 2;
	for(int i = 1; i < n; i++){
		int x = read(), y = read(), z = read();
		add(x, y, z);
		add(y, x, z);
	}
	dfs1(1, 0, 0);
	dfs2(1, 1);
	build(1, 1, n);
	for(int i = 1; i <= q; i++){
		int opt = read();
		if(opt == 1){
			int u = read(), v = read();
			printf("%lld\n",query_range(u, v));
		}
		else {
			int u = read(), v = read(), w = read();
			int ww = w;
			if(f[u] == v){
				w ^= QAQ[u];
				QAQ[u] = ww;
				up_son(u, w);
			}
			else {
				w ^= QAQ[v];
				QAQ[v] = ww;
				up_son(v, w);
			}
		}
	}
}
```

完结撒花*★,°*:.☆(￣▽￣)/$:*.°★* 。

---

## 作者：moongazer (赞：4)

# 题解 P3401 【洛谷树】
[$\mathfrak{View\space it\space on\space my\space Blog}$](https://blog.seniorious.cc/2019/luogu-3401/)
## 分析
令$s_u$为$u$到根的路径上的边权异或和, $s_{u,v}$为$u$到$v$的简单路径上的边权异或和

由树上差分的知识可得$s_{u,v}=s_u\otimes s_v\otimes s_{lca}\otimes s_{lca}=s_u\otimes s_v$

原问题可化为求$\sum_{i,j\in\left\langle u,v\right\rangle}s_i\otimes s_j$

## 做法
考虑维护每一位,若路径$\left\langle u,v\right\rangle$经过$siz$个结点,其中$s$的第$i$位为$1$的有$cnt$个,则为$0$的有$(siz-cnt)$个第$i$位对答案的贡献为$cnt\cdot(siz-cnt)\cdot 2^i$(一个$0$一个$1$才对答案有贡献)

路径上维护$1$的个数,容易想到树链剖分加线段树

修改操作中,将边$(u,v)(dep_u<dep_v)$的权值修改为$w$,原权值为$w_b$,若$w$的第$i$位与$w_b$的第$i$位不同,则将$v$所在子树的$s$的第$i$位翻转即可,具体在线段树上,对于原本有$cnt$个$1$的区间$\left[l,r\right]$,将$1$的个数改为$(r-l+1-cnt)$

## 代码
```cpp
const int N = 30005;
const int M = 60005;
#define lc(x) (x << 1)
#define rc(x) (x << 1 | 1)

void add(int, int, int);
void dfs1(int);
void dfs2(int);
void build(int, int, int);
void update(int, int, int);
ll query(int, int);

int hed[N], nxt[M], to[M], val[M], id;
int dep[N], fa[N], siz[N], son[N], top[N], ttl[N], ltt[N], tot;
int vf[N];
int xs[N];
int sum[N << 2][10];
bool tag[N << 2][10];
int n, q;

int main () {
  read(n), read(q);
  for (int i = 1; i < n; ++i) {
    int u, v, w;
    read(u), read(v), read(w);
    add(u, v, w), add(v, u, w);
  }
  dfs1(1);
  top[1] = 1;
  dfs2(1);
  build(1, 1, n);
  for (int i = 1; i <= q; ++i) {
    int type;
    read(type);
    int u, v;
    read(u), read(v);
    switch (type) {
    case 1:
      write(query(u, v)), EL;
      break;
    case 2:
      int w;
      read(w);
      update(u, v, w);
      break;
    }
  }
  return 0;
}

inline void add(int u, int v, int w) {
  nxt[++id] = hed[u];
  hed[u] = id;
  to[id] = v;
  val[id] = w;
}
void dfs1(int u) {
  siz[u] = 1;
  for (int i = hed[u]; i; i = nxt[i]) {
    int v = to[i];
    if (v != fa[u]) {
      dep[v] = dep[u] + 1;
      fa[v] = u;
      xs[v] = xs[u] ^ val[i];
      vf[v] = val[i];
      dfs1(v);
      siz[u] += siz[v];
      if (siz[v] > siz[son[u]]) {
        son[u] = v;
      }
    }
  }
}
void dfs2(int u) {
  ltt[ttl[u] = ++tot] = u;
  if (son[u]) {
    top[son[u]] = top[u];
    dfs2(son[u]);
  }
  for (int i = hed[u]; i; i = nxt[i]) {
    int v = to[i];
    if (v != fa[u] && v != son[u]) {
      top[v] = v;
      dfs2(v);
    }
  }
}
inline void pushdown(int x, int xl, int xr, int bit) {
  if (tag[x][bit]) {
    int xm = (xl + xr) >> 1;
    sum[lc(x)][bit] = (xm - xl + 1) - sum[lc(x)][bit];
    sum[rc(x)][bit] = (xr - xm) - sum[rc(x)][bit];
    tag[lc(x)][bit] ^= 1;
    tag[rc(x)][bit] ^= 1;
    tag[x][bit] = false;
  }
}
inline void pushup(int x, int bit) {
  sum[x][bit] = sum[lc(x)][bit] + sum[rc(x)][bit];
}
void update(int x, int xl, int xr, int bit, int ul, int ur) {
  if (xl >= ul && xr <= ur) {
    sum[x][bit] = (xr - xl + 1) - sum[x][bit];
    tag[x][bit] ^= 1;
    return;
  }
  pushdown(x, xl, xr, bit);
  int xm = (xl + xr) >> 1;
  if (xm >= ul) {
    update(lc(x), xl, xm, bit, ul, ur);
  }
  if (xm < ur) {
    update(rc(x), xm + 1, xr, bit, ul, ur);
  }
  pushup(x, bit);
}
int query(int x, int xl, int xr, int bit, int ql, int qr) {
  if (xl >= ql && xr <= qr) {
    return sum[x][bit];
  }
  pushdown(x, xl, xr, bit);
  int xm = (xl + xr) >> 1;
  int ans = 0;
  if (xm >= ql) {
    ans += query(lc(x), xl, xm, bit, ql, qr);
  }
  if (xm < qr) {
    ans += query(rc(x), xm + 1, xr, bit, ql, qr);
  }
  return ans;
}
void build(int x, int xl, int xr) {
  if (xl == xr) {
    for (int i = 0; i < 10; ++i) {
      sum[x][i] = (xs[ltt[xl]] >> i) & 1;
    }
    return;
  }
  int xm = (xl + xr) >> 1;
  build(lc(x), xl, xm);
  build(rc(x), xm + 1, xr);
  for (int i = 0; i < 10; ++i) {
    pushup(x, i);
  }
}
void update(int u, int v, int w) {
  int x = dep[u] < dep[v] ? v : u;
  for (int i = 0; i < 10; ++i) {
    if (((vf[x] ^ w) >> i) & 1) {
      update(1, 1, n, i, ttl[x], ttl[x] + siz[x] - 1);
    }
  }
  vf[x] = w;
}
ll query(int u, int v) {
  int cnt[10];
  int siz = 0;
  for (int i = 0; i < 10; ++i) {
    cnt[i] = 0;
  }
  while (top[u] ^ top[v]) {
    if (dep[top[u]] < dep[top[v]]) {
      u ^= v ^= u ^= v;
    }
    siz += ttl[u] - ttl[top[u]] + 1;
    for (int i = 0; i < 10; ++i) {
      cnt[i] += query(1, 1, n, i, ttl[top[u]], ttl[u]);
    }
    u = fa[top[u]];
  }
  if (dep[u] < dep[v]) {
    u ^= v ^= u ^= v;
  }
  siz += ttl[u] - ttl[v] + 1;
  for (int i = 0; i < 10; ++i) {
    cnt[i] += query(1, 1, n, i, ttl[v], ttl[u]);
  }
  ll ans = 0;
  for (int i = 0; i < 10; ++i) {
    ans += cnt[i] * (siz - cnt[i]) * 1ll * (1 << i);
  }
  return ans;
}
```


---

## 作者：scp020 (赞：4)

# P3401 洛谷树 题解

隐形霉菌死于此树下。

## 解法

考虑树链剖分，首先先将父亲与儿子间的边权转化为儿子的点权。

根据异或的性质，$a \oplus a = 0$，我们记每个节点到根的边权异或和为 $val_i$，任意两点间的边权异或和为 $dis_{i,j}$，这样，我们可以将树上任意两点 $x,y$ 间边权的异或和表示为 $val_x \oplus val_y$。考虑如下证明：$val_x \oplus val_y = val_x \oplus val_{lca} \oplus val_{lca} \oplus val_y = dis_{x,lca} \oplus dis_{lca,y} = dis_{x,y}$，其中 $lca$ 表示 $x$ 和 $y$ 的最近公共祖先。

原问题被转化为 $x$ 到 $y$ 间路径上的任意两点间的异或和的和。

注意到交换求和顺序是不影响答案的，并且此题值域很小，所以我们将题目从每个点对的每一个二进制位的贡献转化为了每一个二进制位上每个点对的贡献。

考虑异或的性质，只有 $0 \oplus 1 = 1$，即一个点对的某个二进制位不同时这个点对在这个二进制位上才有贡献，我们可以使用线段树维护每一个二进制位上有 $cnt0$ 个 $0$ 和 $cnt1$ 个 $1$，根据简单的组合，这个二进制位有 $cnt0 \times cnt1$ 次贡献，对和的贡献为 $cnt0 \times cnt1 \times 2^i$。

线段树维护 $val$ 的值即可。

至于修改操作，我们设节点 $x$ 原来的点权（我们已经将边权转化为了点权）为 $w_x$，要修改成的值为 $y$，那新的 $val_x$ 即为 $val_x \oplus w_x \oplus y$，异或 $w_x$ 的目的是撤销曾经 $w_x$ 对 $val_x$ 的贡献。注意到这个修改会影响到节点 $x$ 的子树的 $val$ 值，所以，我们对其子树进行同样的操作即可。

操作一为树链剖分，线段树区间查询，操作二为字数操作，线段树区间修改。

## 代码

```cpp
#include<bits/stdc++.h>
namespace fast_IO
{
	/**
	 * 屎山快读快写
	*/
};
using namespace fast_IO;
const int N=30010;
int n,m,dep[N],fa[N],siz[N],hvson[N],id[N],times,start[N],w[N],neww[N],v[N],val[10];
struct edge
{
	int to,cost;
	edge *next;
};
edge *head[N];
inline void add(const int x,const int y,const int z)
{
	edge *e=new edge;
	e->to=y,e->next=head[x],e->cost=z,head[x]=e;
}
inline void dfs1(int pos,int f,int depth,int maxi=0)
{
	fa[pos]=f,dep[pos]=depth,siz[pos]=1;
	for(edge *i=head[pos];i!=nullptr;i=i->next)
		if(i->to!=f)
		{
			w[i->to]=w[pos]^i->cost,v[i->to]=i->cost,dfs1(i->to,pos,depth+1),siz[pos]+=siz[i->to];
			if(siz[i->to]>maxi) maxi=siz[i->to],hvson[pos]=i->to;
		}
}
inline void dfs2(int pos,int Start)
{
	start[pos]=Start,id[pos]=++times,neww[times]=w[pos];
	if(hvson[pos]) dfs2(hvson[pos],Start);
	for(edge *i=head[pos];i!=nullptr;i=i->next)
		if(i->to!=fa[pos] && i->to!=hvson[pos]) dfs2(i->to,i->to);
}
struct node
{
	int cnt0[10],cnt1[10],lazy[10];
	node *lc,*rc;
	inline node()
	{
		memset(cnt0,0,sizeof(cnt0)),memset(cnt1,0,sizeof(cnt1)),memset(lazy,0,sizeof(lazy));
		lc=rc=nullptr;
	}
	inline void pushup()
	{
		for(int i=0;i<10;i++) cnt0[i]=lc->cnt0[i]+rc->cnt0[i],cnt1[i]=lc->cnt1[i]+rc->cnt1[i];
	}
	inline void pushdown()
	{
		for(int i=0;i<10;i++)
			if(lazy[i])
			{
				std::swap(lc->cnt0[i],lc->cnt1[i]),std::swap(rc->cnt0[i],rc->cnt1[i]);
				lc->lazy[i]^=1,rc->lazy[i]^=1,lazy[i]=0;
			}
	}
};
class seg_tree
{
	#define ls l,mid
	#define rs mid+1,r
private:
	node *root;
	inline node *build(int l,int r)
	{
		node *rt=new node();
		if(l==r) for(int i=0;i<10;i++) rt->cnt1[i]=((neww[l]>>i)&1),rt->cnt0[i]=rt->cnt1[i]^1;
		else
		{
			int mid=(l+r)/2;
			rt->lc=build(ls),rt->rc=build(rs),rt->pushup();
		}
		return rt;
	}
	inline void fix(node *rt,const int L,const int R,int l,int r)
	{
		if(L<=l && r<=R)
		{
			for(int i=0;i<10;i++)
				if(val[i])
					std::swap(rt->cnt0[i],rt->cnt1[i]),rt->lazy[i]^=1;
			return;
		}
		int mid=(l+r)/2;
		rt->pushdown();
		if(L<=mid) fix(rt->lc,L,R,ls);
		if(R>mid) fix(rt->rc,L,R,rs);
		rt->pushup();
	}
	inline node ask(node *rt,const int L,const int R,int l,int r)
	{
		if(L<=l && r<=R) return *rt;
		int mid=(l+r)/2;
		rt->pushdown();
		if(L>mid) return ask(rt->rc,L,R,rs);
		if(R<=mid) return ask(rt->lc,L,R,ls);
		node ll=ask(rt->lc,L,R,ls),rr=ask(rt->rc,L,R,rs),ret;
		ret.lc=&ll,ret.rc=&rr,ret.pushup();
		return ret;
	}
public:
	inline void build()
	{
		root=build(1,n);
	}
	inline void fix(const int L,const int R)
	{
		fix(root,L,R,1,n);
	}
	inline node ask(const int L,const int R)
	{
		return ask(root,L,R,1,n);
	}
};
seg_tree tree;
inline long long ask(int x,int y)
{
	long long ret=0;
	long long cnt0[10],cnt1[10];
	memset(cnt0,0,sizeof(cnt0)),memset(cnt1,0,sizeof(cnt1));
	node tmp;
	while(start[x]!=start[y])
	{
		if(dep[start[x]]<dep[start[y]]) std::swap(x,y);
		tmp=tree.ask(id[start[x]],id[x]),x=fa[start[x]];
		for(int i=0;i<10;i++) cnt0[i]+=tmp.cnt0[i],cnt1[i]+=tmp.cnt1[i];
	}
	if(dep[x]>dep[y]) std::swap(x,y);
	tmp=tree.ask(id[x],id[y]);
	for(int i=0;i<10;i++) cnt0[i]+=tmp.cnt0[i],cnt1[i]+=tmp.cnt1[i];
	for(int i=0;i<10;i++) ret+=cnt0[i]*cnt1[i]*(1ll<<i);
	return ret;
}
int main()
{
	in>>n>>m;
	for(int i=1,x,y,z;i<n;i++) in>>x>>y>>z,add(x,y,z),add(y,x,z);
	dfs1(1,0,1),dfs2(1,1),tree.build();
	for(int i=1,op,x,y,z;i<=m;i++)
	{
		in>>op>>x>>y;
		if(op==1) out<<ask(x,y)<<'\n';
		else if(op==2)
		{
			in>>z;
			if(dep[x]<dep[y]) std::swap(x,y);
			memset(val,0,sizeof(val));
			for(int j=0;j<10;j++) if(((z>>j)&1)!=((v[x]>>j)&1)) val[j]=1;
			tree.fix(id[x],id[x]+siz[x]-1),v[x]=z;
		}
	}
	fwrite(Ouf,1,p3-Ouf,stdout),fflush(stdout);
	return 0;
}
```

---

## 作者：Rorschachindark (赞：4)

# 洛谷树
[题目传送门](https://www.luogu.com.cn/problem/P3401)
## 思路
这道题真的神仙。

首先~~通过标签~~可以看出这是道树剖的题目。但是所有子路径的异或和？**Are you kidding me?** 不慌，我们来分析一波。

首先，设$val[u]$表示从根到$u$的路径异或和，那么$u\to v$的异或和就是$val[u] \text{ xor } val[v]$。那么，求两个点之间任意子路径的异或和就是路径中任意两个的$val[\ \ ]$异或和。

那我们如何维护呢？咦，权值怎么这么小？于是，我们可以想到对于二进制中的每一位都建一棵线段树，维护的是一段区间内这一位为$0/1$的数字个数。

那如何求到答案呢？对于每一位来说，只有两个点这一位分别为$0$和$1$的时候才会产生$2^i$的贡献。于是，可以统计一下两个点之间的路径中这一位为$0$和为$1$的个数，两者相乘，再乘上$2^i$，就是答案。

修改呢？我们发现，每次对于一个点的修改，影响的其实是一个子树。而且，对于每一位来说，只有当新值和旧值不一样才会影响，而且恰好子树内这一位$0$的个数和$1$的个数会互换。

然后就没有什么理论上的问题了，具体实现见代码。
## $\text {Code}$
```cpp
#include <bits/stdc++.h>
using namespace std;

#define Int register int
#define int long long
#define MAXN 30005

struct edge
{
	int v,w,nxt;
}e[MAXN << 1];

int toop = 1;
int head[MAXN];

void Add_Edge (int u,int v,int w)
{
	e[++ toop] = edge {v,w,head[u]};head[u] = toop;
	e[++ toop] = edge {u,w,head[v]};head[v] = toop;	
}

int n,q,Index;
int las[MAXN],dep[MAXN],tur[MAXN],par[MAXN],val[MAXN],dfn[MAXN],top[MAXN],son[MAXN],size[MAXN];

void dfs1 (int u,int fa)
{
	par[u] = fa;
	size[u] = 1;
	dep[u] = dep[fa] + 1;
	for (Int i = head[u];i;i = e[i].nxt)
	{
		int v = e[i].v,w = e[i].w;
		if (v == fa) continue;
		val[v] = val[u] ^ w;
		las[v] = w;
		dfs1 (v,u);
		size[u] += size[v];
		if (size[v] > size[son[u]]) son[u] = v;
	}
}

void dfs2 (int u,int Top)
{
	dfn[u] = ++ Index,tur[Index] = u,top[u] = Top;
	if (son[u]) dfs2 (son[u],Top);
	for (Int i = head[u];i;i = e[i].nxt)
	{
		int v = e[i].v;
		if (v == son[u] || v == par[u]) continue;
		dfs2 (v,v);
	}
}

struct Node
{
	int l,r,lazy,num0,num1;
	Node operator + (const Node &p)const{return Node {0,0,0,num0 + p.num0,num1 + p.num1};}
}tree[11][MAXN << 2];

void Pushup (int k,int i)
{
	tree[k][i].num0 = tree[k][i << 1].num0 + tree[k][i << 1 | 1].num0;
	tree[k][i].num1 = tree[k][i << 1].num1 + tree[k][i << 1 | 1].num1;
}

void Pushdown (int k,int i)
{
	if (!tree[k][i].lazy) return ;
	swap (tree[k][i << 1].num0,tree[k][i << 1].num1);
	swap (tree[k][i << 1 | 1].num0,tree[k][i << 1 | 1].num1);
	tree[k][i << 1].lazy ^= 1,tree[k][i << 1 | 1].lazy ^= 1;
	tree[k][i].lazy = 0;
}

void build (int k,int i,int l,int r)
{
	tree[k][i].l = l,tree[k][i].r = r;
	if (l == r) 
	{
		int get = val[tur[l]];
		if (get >> k & 1) tree[k][i].num1 = 1;
		else tree[k][i].num0 = 1;
		return ;
	}
	int mid = (l + r) >> 1;
	build (k,i << 1,l,mid),build (k,i << 1 | 1,mid + 1,r);
	Pushup (k,i);
}

void Reverse (int k,int i,int l,int r)
{
	if (tree[k][i].l > r || l > tree[k][i].r) return ;
	if (tree[k][i].l >= l && tree[k][i].r <= r)
	{
		swap (tree[k][i].num0,tree[k][i].num1);
		tree[k][i].lazy ^= 1;
		return ;
	}
	Pushdown (k,i);
	Reverse (k,i << 1,l,r);
	Reverse (k,i << 1 | 1,l,r);
	Pushup (k,i);
}

void Change (int u,int w)
{
	for (Int i = 0;i <= 10;++ i)
		if ((w ^ las[u]) >> i & 1)
			Reverse (i,1,dfn[u],dfn[u] + size[u] - 1);
	las[u] = w;
}

Node query (int k,int i,int l,int r)
{
	if (tree[k][i].l > r || l > tree[k][i].r) return Node {0,0,0,0,0};
	if (tree[k][i].l >= l && tree[k][i].r <= r) return tree[k][i];
	Pushdown (k,i);
	return query (k,i << 1,l,r) + query (k,i << 1 | 1,l,r);
}

int Tree_Query (int x,int y)
{
	int Ans = 0;
	for (Int i = 0;i <= 10;++ i)
	{
		int u = x,v = y;
		Node Now = Node {0,0,0,0,0};
		while (top[u] ^ top[v])
		{
			if (dep[top[u]] < dep[top[v]]) swap (u,v);
			Now = Now + query (i,1,dfn[top[u]],dfn[u]);
			u = par[top[u]];
		}
		if (dfn[u] > dfn[v]) swap (u,v);
		Now = Now + query (i,1,dfn[u],dfn[v]);
		Ans += (1 << i) * Now.num0 * Now.num1;
	}
	return Ans;
}

int read ()
{
	int x = 0;char c = getchar();int f = 1;
	while (c < '0' || c > '9'){if (c == '-') f = -f;c = getchar();}
	while (c >= '0' && c <= '9'){x = (x << 3) + (x << 1) + c - '0';c = getchar();}
	return x * f;
}

void write (int x)
{
	if (x < 0){x = -x;putchar ('-');}
	if (x > 9) write (x / 10);
	putchar (x % 10 + '0');
}

signed main()
{
	n = read (),q = read ();
	for (Int i = 2;i <= n;++ i)
	{
		int u = read (),v = read (),w = read ();
		Add_Edge (u,v,w);
	}
	dfs1 (1,0);
	dfs2 (1,1);
	for (Int i = 0;i <= 10;++ i) build (i,1,1,n);
	for (Int i = 1;i <= q;++ i)
	{
		int type = read (),u = read (),v = read (),w;
		if (type == 1) write (Tree_Query (u,v)),putchar ('\n');
		else w = read (),u = (dep[u] < dep[v] ? v : u),Change (u,w);
	}
	return 0;
}
```

---

## 作者：Sincerin (赞：2)

听说赛前写题解可以改运势？

[题目传送门！](https://www.luogu.com.cn/problem/P3401)

[更好的阅读体验？](https://www.luogu.com.cn/blog/sincerin520/solution-p3401)

> 前置知识：[树链剖分](https://www.luogu.com.cn/problem/solution/P3384)，[线段树](https://www.luogu.com.cn/problem/solution/P3372)。

## 题意


给定一棵由 $n$ 个结点构成的树，边带权。定义其中任意两个结点 $p_x,p_y$ 之间的路径即为他们之间的简单路径，也就是 $p_x,p_y$ 之间可以互相到达的，不重复经过任意节点的唯一路径。定义路径 $(p_x,p_y)$ 的子路径为这条路径上形如 $(p_i,p_j)$，其中 $x \leq i \leq j \leq y$ 的路径。

给定 $m$ 次操作，每次会修改某条边的边权，或查询某条路径上所有子路径边权异或值的和。

- $1 \leq n,m \leq 3 \times 10^4 \ , \ w\leq 2^{10}-1.$ 

## 解析

首先考虑一下查询的暴力，每次需要 $\Theta(n^2)$ 地去枚举每条子路径的左右端点，再 $\Theta(n)$ 地求出其异或值最后求和。

考虑优化这个过程，我们定义前缀异或和序列 $S$，其中 $S_i$ 表示 $i$ 到根结点边权的异或值。因为我们知道二进制下相同的位异或运算结果为 $0$，所以进行运算 $S_6 \oplus S_7$ 时，下图中标红部分的边权异或和会抵消，剩下的值即为路径 $(6,7)$ 上边权的异或和。即我们可以 $\Theta(1)$ 地求出树上两点间边权的异或和，此时原问题转化为两点间路径上所有点对应的 $S$ 值两两异或的和。

![](https://cdn.luogu.com.cn/upload/image_hosting/j8s3fwjh.png)

先进行树链剖分，把树剖成若干链。此时两点间的路径就可以表示为若干个小区间拼成的序列。注意这里给定的是边权，我们需要进行边权转点权的方式，把每对父子结点之间连边的边权下放为儿子结点的点权。

观察到边权 $w$ 很小，只有 $2^{10}-1$，考虑按位维护。开 $10$ 棵线段树，维护前缀异或和序列 $S$。第 $i$ 棵维护所有边权第 $i$ 位的情况。此时对每个小区间的区间和求和，即可得到路径 $(x,y)$ 上所有边权第 $i$ 位上是 $0$ 的边数和是 $1$ 的边数。

对于查询操作，很显然，两个数只有第 $i$ 位不同才会产生贡献。记第 $i$ 位是 $1$ 的边数为 $p_i$，第 $i$ 位是 $0$ 的边数为 $q_i$（且 $q_i=$ 路径 $(x,y)$ 上的总边数 $-p_i$）。则根据乘法原理，对最后的和的贡献为 $p_i \times q_i \times 2^i$。即最后的答案为 $\sum_{i=0}^9{p_i \times q_i \times 2^i}$。

考虑修改操作，对于一条边边权的修改对于前缀异或和序列 $S$ 的影响只会作用到以这条边连接的子节点为根的子树上的边上。若上图中 $4$ 号结点所对应点权（就是 $4$ 号和 $5$ 号结点之间边的边权）的第 $i$ 位由 $0$ 改为 $1$，则包括它在内的它子树上所有点的第 $i$ 位都要多异或上一个 $1$，也就是把第 $i$ 位取反。

我们知道，一棵子树上结点的时间戳 `dfn` 值是连续的，上述操作可以转化为将一个 $0/1$ 序列的某个区间进行取反操作。我们的线段树维护的是区间 $0/1$ 的个数，所以区间取反之后只需要交换区间 $0$ 和 $1$ 的个数即可。


## AC Code

```cpp
//C++20-O2 1.16s 41.95MB 4.14KB
#include<iostream>
#include<cstdio>
#include<algorithm>   
using namespace std;  
#define int long long
#define ri register int
#define rd(n) n=read()
inline int read(void)
{
	register int res=0,f=0;
	register char c=getchar();
	while(c<'0'||c>'9'){f^=(c=='-');c=getchar();}
	while(c>='0'&&c<='9'){res=(res<<3)+(res<<1)+(c^48);c=getchar();}
	return f?-res:res;
}
inline void fprint(int n)
{
	if(n<0){putchar('-');n=-n;}
	if(n>9) fprint(n/10);
	putchar(n%10+'0');
}
inline void print(int n)
{
	fprint(n);
	putchar('\n');
}  
const int k=10;//维护位数 
const int N=30001; 
int n,m,x,y,z,ans,tot,cnt,a[N],s[N];
int lca,root,op,dist,b[N],res[k];
struct Graph{
	int ver,edge,head,Next;
	#define ver(i) e[i].ver
	#define edge(i) e[i].edge
	#define head(i) e[i].head
	#define Next(i) e[i].Next
}e[N<<1];
inline void add(int x,int y,int z) 
{
	ver(++tot)=y;
	edge(tot)=z;
	Next(tot)=head(x);
	head(x)=tot;
}
struct CutTree{
	int fa,id,son,top,siz,dep,w;
	#define w(i) CT[i].w
	#define fa(i) CT[i].fa
	#define id(i) CT[i].id
	#define dep(i) CT[i].dep
	#define son(i) CT[i].son
	#define top(i) CT[i].top
	#define siz(i) CT[i].siz
}CT[N];
void dfs1(int x,int father)
{
	dep(x)=dep(father)+1;
	fa(x)=father;
	siz(x)=1;
	for(ri i=head(x);i;i=Next(i))
	{
		ri y=ver(i),z=edge(i);
		if(y!=father)
		{
			w(y)=z;//边权下放点权 
			s[y]=s[x]^z;//求S 
			dfs1(y,x);
			siz(x)+=siz(y);
			if(siz(y)>siz(son(x))) son(x)=y;
		} 
	} 
}
void dfs2(int x,int top)
{
	id(x)=++cnt;  
	a[cnt]=s[x];
	top(x)=top;
	if(!son(x)) return;
	dfs2(son(x),top);
	for(ri i=head(x);i;i=Next(i))
	{
		ri y=ver(i);
		if(y!=fa(x)&&y!=son(x))
			dfs2(y,y);
	} 
} 
inline int LCA(int x,int y)//最近公共祖先 
{
    while(top(x)!=top(y))
    {
        if(dep(top(x))<dep(top(y))) swap(x,y); 
        x=fa(top(x));
    }
    return dep(x)<dep(y)?x:y;
}
inline int dis(int x,int y)
{
	lca=LCA(x,y);
	return dep(x)+dep(y)-(dep(lca)<<1)+1;//包括自己，要+1 
}
#define lson(p) p<<1
#define rson(p) p<<1|1 
struct SegmentTree{
	struct Tree{
		int l,r,dat,tag;
		#define l(p) t[p].l
		#define r(p) t[p].r
		#define dat(p) t[p].dat
		#define tag(p) t[p].tag
	}t[N<<2];
	inline int len(int p){return r(p)-l(p)+1;}
	inline void pushup(int p){dat(p)=dat(lson(p))+dat(rson(p));}
	void build(int p,int l,int r)
	{
		l(p)=l; r(p)=r; tag(p)=0;
		if(l==r)
		{
			dat(p)=bool(a[l]);
			return;
		}
		ri mid=(l+r)>>1;
		build(lson(p),l,mid);
		build(rson(p),mid+1,r);
		pushup(p);
	}
	inline void spread(int p)
	{
		if(l(p)==r(p)) return;
		if(tag(p))
		{
			tag(lson(p))^=1; tag(rson(p))^=1;
			dat(lson(p))=len(lson(p))-dat(lson(p));
			dat(rson(p))=len(rson(p))-dat(rson(p));
			tag(p)=0;
		}
	}
	void change(int p,int l,int r)
	{
		spread(p);
		if(l<=l(p)&&r(p)<=r)
		{
			dat(p)=len(p)-dat(p);
			tag(p)^=1;
			return;
		}
		ri mid=(l(p)+r(p))>>1;
		if(l<=mid) change(lson(p),l,r);
		if(r>mid) change(rson(p),l,r);
		pushup(p);
	}
	int query(int p,int l,int r)
	{
		spread(p);
		if(l<=l(p)&&r(p)<=r) return dat(p);
		int ans=0;
		ri mid=(l(p)+r(p))>>1;
		if(l<=mid) ans+=query(lson(p),l,r);
		if(r>mid) ans+=query(rson(p),l,r);
		return ans;
	}
}T[k];
inline void Ask(int x,int y) 
{
    while(top(x)!=top(y)) 
	{
        if(dep(top(x))<dep(top(y))) swap(x,y); 
        for(ri i=0;i<k;++i) res[i]+=T[i].query(1,id(top(x)),id(x)); 
		x=fa(top(x));//跳链 
    } 
    if(dep(x)>dep(y)) swap(x,y); 
	for(ri i=0;i<k;++i) res[i]+=T[i].query(1,id(x),id(y));
}
signed main(void)
{ 
	rd(n); rd(m);
	for(ri i=1;i<n;++i)
	{
		rd(x); rd(y); rd(z);
		add(x,y,z);
		add(y,x,z);
	}
	root=1;
	dfs1(root,0);
	dfs2(root,root);
	for(ri i=1;i<=n;++i) b[i]=a[i];
	for(ri i=0;i<k;++i)
	{
		if(i) for(ri j=1;j<=n;++j) a[j]=b[j];
		for(ri j=1;j<=n;++j) a[j]&=(1<<i); 
		T[i].build(1,1,n);//建树 
	}
	while(m--)
	{
		rd(op); rd(x); rd(y);
		if(op==1)
		{
			for(ri i=0;i<k;++i) res[i]=0;
			Ask(x,y); ans=0;
			dist=dis(x,y);//两点之间的点数 
			for(ri i=0;i<k;++i) ans+=(res[i]*(1<<i)*(dist-res[i]));
			print(ans); 
		}
		else
		{
			rd(z);
			if(dep(x)>dep(y)) swap(x,y);//保证y是x的子结点 
			for(ri i=0;i<k;++i) 
				if((w(y)&(1<<i))^(z&(1<<i)))//和原来的点权第i位不同 
					T[i].change(1,id(y),id(y)+siz(y)-1); 
			w(y)=z;//别忘了改点权 
		}
	}
	return 0;
} 
```

[AC Record](https://www.luogu.com.cn/record/133798189)




---

## 作者：MspAInt (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P3401)

先直觉性地边权转点权，预处理每个点到根的异或和作为点权，发现询问就是对路径上的顶点两两异或，最后求和。看上去没那么友善。

考虑逐二进制位求贡献。根据异或的本质，第 $i$ 位出现一个 $0$ 和一个 $1$ 会得到 $2^i$ 的贡献。那么显然地，对于多个数，把该位上所有 $a$ 个 $0$，$b$ 个 $1$ 两两异或起来，会得到 $a\times b\times 2^i$ 的贡献。

现在，问题转化为求某路径上第 $i$ 位出现了多少个 $0$ 和多少个 $1$。开一颗线段树，由于权值很小，每个节点分别记录 $10$ 位，即该区间每一位 $1$ 的个数之和（$0$ 的个数可以据此求出），树链剖分统计即可。

修改操作显而易见。将原本的点权和新点权进行逐二进制位比较，当第 $i$ 位出现不同时，该点子树内所有点权的第 $i$ 位都需要取反。具体地，将区间 $[l,r]$ 的第 $i$ 位 $1$ 的个数 $s_i$ 置为 $r-l+1-s_i$。由于子树的 $\operatorname{dfs}$ 序连续，区间修改即可。

时间复杂度 $\Theta(q\log^2n\log w)$，$w$ 为值域。

Code:

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=3e4+10;
struct node{int s[11],l,r;bool g[11];}t[N<<2];
int n,m,key[N],w[N],top[N],ct[N],fa[N],dep[N],hs[N],dfn[N],nfd[N];
vector<pair<int,int>>e[N];
void dfs1(int u){
    int v;
    ct[u]=1;dep[u]=dep[fa[u]]+1;
    for(auto x:e[u])if((v=x.first)!=fa[u])
    {
        fa[v]=u;w[v]=x.second;
        dfs1(v);ct[u]+=ct[v];
        hs[u]=ct[v]>ct[hs[u]]?v:hs[u];
    }
    return;
}
void dfs2(int u,int T,int now){
    top[u]=T;key[u]=now;
    dfn[u]=++dfn[0];nfd[dfn[0]]=u;
    if(hs[u])dfs2(hs[u],T,now^w[hs[u]]);
    for(auto x:e[u]){
        int v=x.first;
        if(v!=hs[u]&&v!=fa[u])dfs2(v,v,now^w[v]);
    }
    return;
}
void split(int u,int val){
    for(int k=0;val;k++,val>>=1)t[u].s[k]=(val&1);
    return;
}
void Opp(int u,int k){
    t[u].s[k]=t[u].r-t[u].l+1-t[u].s[k];
    t[u].g[k]=!t[u].g[k];
    return;
}
void pushup(int u,int k){
    t[u].s[k]=t[u<<1].s[k]+t[u<<1|1].s[k];
    return;
}
void pushdown(int u,int k){
    if(!t[u].g[k])return;
    Opp(u<<1,k);Opp(u<<1|1,k);t[u].g[k]=0;
    return;
}
void Build(int u,int L,int R){
    t[u].l=L;t[u].r=R;
    if(L==R){split(u,key[nfd[L]]);return;}
    int mid=L+R>>1;Build(u<<1,L,mid);Build(u<<1|1,mid+1,R);
    for(int i=0;i<=10;i++)pushup(u,i);
    return;
}
int qry(int u,int k,int L,int R){
    if(t[u].r<L||t[u].l>R)return 0;
    if(t[u].l>=L&&t[u].r<=R)return t[u].s[k];
    pushdown(u,k);
    return qry(u<<1,k,L,R)+qry(u<<1|1,k,L,R);
}
void mdf(int u,int k,int L,int R){
    if(t[u].l>R||t[u].r<L)return;
    if(t[u].l>=L&&t[u].r<=R){Opp(u,k);return;}
    pushdown(u,k);
    mdf(u<<1,k,L,R);mdf(u<<1|1,k,L,R);
    pushup(u,k);
    return;
}
int query(int x,int y){
    int o[11]={},ret=0,dis=0;
    while(top[x]!=top[y]){
        if(dep[top[x]]<dep[top[y]])swap(x,y);
        for(int i=0;i<=10;i++)o[i]+=qry(1,i,dfn[top[x]],dfn[x]);
        dis+=dfn[x]-dfn[top[x]]+1;x=fa[top[x]];
    }
    if(dep[x]<dep[y])swap(x,y);
    dis+=dfn[x]-dfn[y]+1;
    for(int i=0;i<=10;i++)o[i]+=qry(1,i,dfn[y],dfn[x]);
    for(int i=0;i<=10;i++)ret+=1ll*(1<<i)*o[i]*(dis-o[i]);
    return ret;
}
void modify(int x,int y,int val){
    if(dfn[x]<dfn[y])swap(x,y);
    for(int i=0;i<=10;i++)if((1<<i&val)!=(1<<i&w[x]))mdf(1,i,dfn[x],dfn[x]+ct[x]-1);
    w[x]=val;
    return;
}
void print(int u){
    if(!t[u].l)return;
    printf("%d %d|",t[u].l,t[u].r);
    for(int i=0;i<=10;i++)printf("%d ",t[u].s[i]);
    puts("");
    if(t[u].l!=t[u].r)print(u<<1),print(u<<1|1);
    return;
}
signed main(){
    // freopen("P3401in.txt","r",stdin);
    // freopen("P3401mine.txt","w",stdout);
    scanf("%lld%lld",&n,&m);
    for(int i=1;i<n;i++){
        int x,y,z;
        scanf("%lld%lld%lld",&x,&y,&z);
        e[x].push_back(make_pair(y,z));e[y].push_back(make_pair(x,z));
    }
    dfs1(1);dfs2(1,1,0);Build(1,1,n);
    for(int i=1;i<=m;i++){
        int opt,x,y,z;
        scanf("%lld%lld%lld",&opt,&x,&y);
        if(opt==1)printf("%lld\n",query(x,y));
        else if(opt==2)scanf("%lld",&z),modify(x,y,z);
    }
    // system("pause");
    return 0;
}
```

[record](https://www.luogu.com.cn/record/112766908)

---

## 作者：liuyongle (赞：2)

本题有一个弱化版本：[GDKOI2016魔卡少女](https://www.cnblogs.com/xiefengze1/p/9681682.html)。

弱化版大致题意是：询问一个区间的子区间异或和。具体方法是拆开二进制的每一位，然后用线段树维护异或前缀和中 $0,1$ 的个数，个数相乘后再加权即为答案。这样正确的原因是：对于一个有贡献的区间 $[L,R]$，它一定会被 $sum[L-1]$ 和 $sum[R]$ 算到且仅一次。

然后这题只要把序列的问题搬到树链剖分上就行了，细节处理比较多（而且麻烦）。

代码：

```cpp
#include<bits/stdc++.h>
#define mid ((L+R)>>1)
#define lc (id<<1)
#define rc (td<<1|1)
typedef long long LL;

using namespace std;

const int maxk=10,maxn=3e4+5;

struct edge {
    int obj,len;
    edge *Next;
}e[maxn<<1];

struct data {
    int sum,num0,num1;
}tree[maxk][maxn<<2];

edge *head[maxn];
int cur=-1;

data zero;

int fa[maxn],dep[maxn],Son[maxn],Size[maxn];
int Top[maxn],dfsx[maxn],dfn[maxn],Time=0;
int val[maxn],n,q;

inline void Add(int x,int y,int z) {
    ++cur;
    e[cur].obj=y;
    e[cur].len=z;
    e[cur].Next=head[x];
    head[x]=e+cur;
    return ;
}

inline void Dfs1(int node) {
    Size[node]=1;
    for (edge *p=head[node];p;p=p->Next) {
        int son=p->obj;
        if(son==fa[node])
            continue;
        fa[son]=node;
        val[son]=p->len;
        dep[son]=dep[node]+1;
        Dfs1(son);
        Size[node]+=Size[son];
        if(Size[son]>Size[Son[node]])
            Son[node]=son;
    }
    return ;
}

inline void Dfs2(int node) {
    dfsx[++Time]=node;
    dfn[node]=Time;
    if(Son[node])
        Top[Son[node]]=Top[node],Dfs2(Son[node]);
    for (edge *p=head[node];p;p=p->Next) {
        int son=p->obj;
        if(son==fa[node] || son==Son[node])
            continue;
        Top[son]=son;
        Dfs2(son);
    }
    return ;
}

inline data Up(data x,data y) {
    data z;
    z.sum=x.sum^y.sum;
    if(x.sum)
        swap(y.num0,y.num1);
    z.num0=x.num0+y.num0;
    z.num1=x.num1+y.num1;
    return z;
}

inline void Build(int i,int id,int L,int R) {
    if(L==R) {
        int v=((bool)(val[ dfsx[L] ]&(1<<i)));
        tree[i][id].sum=v;
        if(v)
            ++tree[i][id].num1;
        else
            ++tree[i][id].num0;
        return ;
    }
    Build(i,lc,L,mid);
    Build(i,rc,mid+1,R);
    tree[i][id]=Up(tree[i][lc],tree[i][rc]);
    return ;
}

inline int Lca(int u,int v) {
    if(Top[u]==Top[v])
        return dfsx[min(dfn[u],dfn[v])];
    if(dep[Top[u]]<dep[Top[v]])
        swap(u,v);
    return Lca(fa[Top[u]],v);
}

inline data Query(int i,int id,int L,int R,int x,int y) {
    if(y<L || R<x)
        return zero;
    if(x<=L && R<=y)
        return tree[i][id];
    data vl=Query(i,lc,L,mid,x,y);
    data vr=Query(i,rc,mid+1,R,x,y);
    return Up(vl,vr);
}

inline data Get(int i,int u,int v) {
    data x;
    if(u==v)
        x=zero;
    else
        x=Query(i,1,1,n,dfn[v]+1,dfn[u]);
    ++x.num0;
    if(x.sum)
        swap(x.num0,x.num1);
    return x;
}

inline data Work(int i,int u,int v) {
    if(Top[u]==Top[v])
        return Get(i,u,v);
    int w=Top[u];
    data y=Work(i,fa[w],v);
    if(val[w]&(1<<i))
        swap(y.num0,y.num1),y.sum^=1;
    data x=Get(i,u,w);
    return Up(x,y);
}

inline LL Query(int u,int v) {
    int w=Lca(u,v);
    LL ans=0;
    for(int i=0;i<maxk;++i) {
        data x=Work(i,u,w);
        data y=Work(i,v,w);
        if(y.sum)
            swap(y.num0,y.num1);
        --y.num0;
        x=Up(x,y);
        ans+=( (1LL<<i)*(long long)x.num0*(long long)x.num1 );
    }
    return ans;
}

inline void Update(int i,int id,int L,int R,int x) {
    if(L==x && x==R) {
        tree[i][id]=zero;
        int v=((bool)(val[ dfsx[L] ]&(1<<i)));
        tree[i][id].sum=v;
        if(v)
            ++tree[i][id].num1;
        else
            ++tree[i][id].num0;
        return ;
    }
    if(x<L || R<x)
        return ;
    Update(i,lc,L,mid,x);
    Update(i,rc,mid+1,R,x);
    tree[i][id]=Up(tree[i][lc],tree[i][rc]);
    return ;
}

int main() {
#ifdef
    freopen("tree.in","r",stdin);
    freopen("tree.out","w",stdout);
#endif
    scanf("%d%d",&n,&q);
    for(int i=1;i<=n;++i)
        head[i]=NULL;
    for(int i=1;i<n;++i) {
        int x,y,z;
        scanf("%d%d%d",&x,&y,&z);
        Add(x,y,z);
        Add(y,x,z);
    }
    dep[1]=1;
    Dfs1(1);
    Top[1]=1;
    Dfs2(1);
    for(int i=0;i<maxk;++i)
        Build(i,1,1,n);
    zero.sum=zero.num0=zero.num1=0;
    while(q--) {
        int x,u,v,w;
        scanf("%d%d%d",&x,&u,&v);
        if(x==1)
            printf("%lld\n",Query(u,v));
        else {
            scanf("%d",&w);
            if(fa[u]!=v)
                swap(u,v);
            val[u]=w;
            for(int i=0;i<maxk;++i)
                Update(i,1,1,n,dfn[u]);
        }
    }
    return 0;
}
```

---

## 作者：ycyaw (赞：2)

半年没写树剖了，就当模板练一下

首先设根节点到$i$路径上的异或和为$val[i]$，则$i$到$j$路径的异或和为$val[i]\oplus val[j]$。

对于$i$到$j$所有子路径的异或和的和，对每一位分开来考虑，对于第$i$位，发现贡献就是$(1<<i)\times gs(0)\times gs(1)$，其中$gs(x)$为$i$到$j$路径上$x$的个数。

$gs(0/1)$显然可以树剖$+$线段树维护，对于一次修改，直接翻转子树内的$0,1$个数即可，用树剖$+$线段树可以轻松维护。

$Code\ Below:$
```cpp
#include<bits/stdc++.h>
#define ts cout<<"ok"<<endl
#define int long long
#define hh puts("")
#define pc putchar
#define ls(x) ((x)<<1)
#define rs(x) ((x)<<1|1)
//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
//char buf[1<<21],*p1=buf,*p2=buf;
using namespace std;
const int N=30005;
int n,q,cnt,head[N],val[N],f[N],eg[N],sz[N],d[N],son[N];
int top[N],id[N],rk[N],sum[10][N<<2],tag[10][N<<2];
struct Edge{
    int v,nx,s;
}e[N<<1];
inline int read(){
    int ret=0,ff=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') ff=-1;ch=getchar();}
    while(isdigit(ch)){ret=ret*10+(ch^48);ch=getchar();}
    return ret*ff;
}
void write(int x){if(x<0){x=-x,pc('-');}if(x>9) write(x/10);pc(x%10+48);}
void writeln(int x){write(x),hh;}
void writesp(int x){write(x),pc(' ');}
void add(int x,int y,int s){
    e[++cnt].v=y;
    e[cnt].nx=head[x];
    e[cnt].s=s;
    head[x]=cnt;
}
void dfs1(int now,int fa){
    sz[now]=1;d[now]=d[fa]+1;
    for(int i=head[now];i;i=e[i].nx){
        int v=e[i].v;
        if(v==fa) continue;
        val[v]=val[now]^e[i].s;
        dfs1(v,now);
        f[v]=now;
        eg[v]=e[i].s;
        sz[now]+=sz[v];
        if(sz[v]>sz[son[now]]) son[now]=v;
    } 
}
void dfs2(int now,int fa){
    top[now]=fa;
    id[now]=++cnt;
    rk[cnt]=now;
    if(son[now]) dfs2(son[now],fa);
    for(int i=head[now];i;i=e[i].nx){
        int v=e[i].v;
        if(f[now]==v||v==son[now]) continue;
        dfs2(v,v);
    }
}
void build(int l,int r,int k){
    if(l==r){
        for(int i=0;i<=9;i++) sum[i][k]=(val[rk[l]]>>i)&1;
        return;
    }
    int mid=(l+r)>>1;
    build(l,mid,ls(k));
    build(mid+1,r,rs(k));
    for(int i=0;i<=9;i++) sum[i][k]=sum[i][ls(k)]+sum[i][rs(k)];
}
void push_down(int tt,int l,int r,int k){
    if(tag[tt][k]){
        int mid=(l+r)>>1;
        tag[tt][ls(k)]^=1;
        tag[tt][rs(k)]^=1;
        sum[tt][ls(k)]=mid-l+1-sum[tt][ls(k)];
        sum[tt][rs(k)]=r-mid-sum[tt][rs(k)];
        tag[tt][k]=0;
    }
}
void update(int l,int r,int x,int y,int tt,int k){
    if(x<=l&&r<=y){
        sum[tt][k]=r-l+1-sum[tt][k];
        tag[tt][k]^=1;
        return;
    }
    push_down(tt,l,r,k);
    int mid=(l+r)>>1;
    if(x<=mid) update(l,mid,x,y,tt,ls(k));
    if(mid+1<=y) update(mid+1,r,x,y,tt,rs(k));
    sum[tt][k]=sum[tt][ls(k)]+sum[tt][rs(k)];
}
int query(int l,int r,int x,int y,int tt,int k){
    if(x<=l&&r<=y) return sum[tt][k];
    push_down(tt,l,r,k);
    int mid=(l+r)>>1,res=0;
    if(x<=mid) res+=query(l,mid,x,y,tt,ls(k));
    if(mid+1<=y) res+=query(mid+1,r,x,y,tt,rs(k));
    return res;
}
int LCA(int x,int y){
    while(top[x]!=top[y]){
        if(d[top[x]]>d[top[y]]) x=f[top[x]];
        else y=f[top[y]]; 
    }
    if(d[x]>d[y]) return y;
    return x;
}
int ask(int x,int y,int tt){
    if(d[x]<d[y]) swap(x,y);
    int lca=LCA(x,y),tot=0,gs=0;
    tot=d[x]+d[y]-2*d[lca]+1;
    while(top[x]!=top[y]){
        if(d[top[x]]<d[top[y]]) swap(x,y);
        gs+=query(1,n,id[top[x]],id[x],tt,1);
        x=f[top[x]];
    }
    if(id[x]>id[y]) swap(x,y);
    gs+=query(1,n,id[x],id[y],tt,1);
    return gs*(tot-gs);
}
signed main(){
    n=read(),q=read();
    for(int i=1;i<n;i++){
        int x=read(),y=read(),s=read();
        add(x,y,s),add(y,x,s);
    }
    dfs1(1,0);cnt=0;
    dfs2(1,1);
    build(1,n,1);
    for(int i=1;i<=q;i++){
        int opt=read();
        if(opt==1){
            int x=read(),y=read();
            int ans=0;
            for(int i=0;i<=9;i++) ans+=ask(x,y,i)*(1<<i);
            writeln(ans);
        }
        if(opt==2){
            int x=read(),y=read(),s=read();
            if(d[x]<d[y]) swap(x,y);
            for(int i=0;i<=9;i++)
                if(((eg[x]>>i)&1)^((s>>i)&1))
                    update(1,n,id[x],id[x]+sz[x]-1,i,1);
            eg[x]=s;
        }
    }
    return 0;
}
```


---

## 作者：tommymio (赞：2)

树上 $\text{DS}$ 问题，一般先考虑序列解法。

- 没有修改操作，多次询问，树的形态为链。考虑预处理出 $sum_i$，$a_{1\sim i}$ 的异或和。则对于每个询问 $(1,L,R)$，我们需要求出 $\sum\limits_{i=1}^L\sum\limits_{j=i+1}^R sum_i\oplus sum_j$，即区间 $[L,R]$ 内两两前缀异或和的异或值之和。按位来考虑这一问题，第 $i$ 位上有值，仅当参与异或的两个值 $x,y$，其中一个在第 $i$ 位上的值为 $1$，而另一个在第 $i$ 位上的值为 $0$。所以我们可以建 $\log V$ 棵线段树，第 $i$ 棵线段树维护区间第 $i$ 位为 $0/1$ 的数量，设区间 $[L,R]$ 第 $i$ 位为 $1$ 的有 $cnt1[L,R,i]$ 个数，第 $i$ 位为 $0$ 的有 $cnt0[L,R,i]$ 个数，则第 $i$ 位在区间 $[L,R]$ 中会被累加 $cnt1[L,R,i]\times cnt0[L,R,i]$ 次，对区间贡献为 $cnt1[L,R,i]\times cnt0[L,R,i]\times 2^i$。按位累加贡献即可，时间复杂度为 $O(n\log n\log V)$，$V$ 为值域大小。 
- 有修改操作，多次询问，树的形态为链。考虑异或运算的特殊性，一旦位置 $i$ 上的数 $a_i$ 被修改为 $x$，则若第 $k$ 位上 $a_i$ 与 $x$ 不同，$i$ 位置之后的前缀异或和都会在第 $k$ 位上取反。在线段树上打标记维护即可，时间复杂度不变。
- 有修改操作，多次询问，树的形态不限。考虑修改操作事实上是子树修改，而询问操作是对链上指定二进制位的 $0/1$ 个数求和，套一个树链剖分就可以了。时间复杂度升为 $O(n\log^2 n\log V)$。

```cpp
#include<cstdio>
#include<map>
#include<functional>
#define ls p<<1
#define rs p<<1|1
typedef long long ll;
int cnt=0,num=0;
std::map<std::pair<int,int>,int> mp;
int h[30005],to[60005],ver[60005],w[60005]; 
int size[30005],dep[30005],fa[30005],son[30005],sum[30005];
int seg[30005],rev[30005],top[30005];
struct Segment {
	Segment(int x=0,int y=0,int z=0) {cnt0=x;cnt1=y;tag=z;}
	int cnt0,cnt1,tag;
}res[10];
inline int read() {
	register int x=0,f=1;register char s=getchar();
	while(s>'9'||s<'0') {if(s=='-') f=-1;s=getchar();}
	while(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();}
	return x*f;
}
inline void swap(int &x,int &y) {int tmp=y;y=x;x=tmp;}
inline void add(int x,int y,int z) {
	to[++cnt]=y;
	ver[cnt]=h[x];
	w[cnt]=z;
	h[x]=cnt;
}
inline void dfs1(int x) {
	size[x]=1; 
	for(register int i=h[x];i;i=ver[i]) {
		int y=to[i]; if(y==fa[x]) continue;
		fa[y]=x; dep[y]=dep[x]+1; sum[y]=sum[x]^w[i]; dfs1(y);
		size[x]+=size[y]; if(size[y]>size[son[x]]) son[x]=y;
	}
}
inline void dfs2(int x,int t) {
	seg[x]=++num; rev[num]=x; top[x]=t;
	if(son[x]) dfs2(son[x],t);
	for(register int i=h[x];i;i=ver[i]) {
		int y=to[i]; if(y==fa[x]||y==son[x]) continue;
		dfs2(y,y);
	}
}
struct SegmentTree {
	Segment t[120005];
//	inline void pushup(int p) {t[p].cnt0=t[ls].cnt0+t[rs].cnt0; t[p].cnt1=t[ls].cnt1+t[rs].cnt1;}  
	inline void work(int p) {t[p].tag^=1; swap(t[p].cnt0,t[p].cnt1);}
	inline void spread(int p) {if(t[p].tag) work(ls),work(rs),t[p].tag=0;}
	inline void build(int p,int l,int r,int bit) {
		if(l==r) {
			t[p].cnt0=(!(sum[rev[l]]>>bit&1));
			t[p].cnt1=(sum[rev[l]]>>bit&1);
			return;
		}
		int mid=l+r>>1;
		build(ls,l,mid,bit); build(rs,mid+1,r,bit);
		t[p].cnt0=t[ls].cnt0+t[rs].cnt0; t[p].cnt1=t[ls].cnt1+t[rs].cnt1;
	}
	inline void reverse(int p,int l,int r,int L,int R) {
		if(L<=l&&r<=R) {work(p); return;}
		int mid=l+r>>1; spread(p);
		if(L<=mid) reverse(ls,l,mid,L,R);
		if(R>mid) reverse(rs,mid+1,r,L,R);
		t[p].cnt0=t[ls].cnt0+t[rs].cnt0; t[p].cnt1=t[ls].cnt1+t[rs].cnt1;
	}
	inline Segment ask(int p,int l,int r,int L,int R) {
		if(L<=l&&r<=R) return t[p];
		int mid=l+r>>1; spread(p);
		if(L>mid) return ask(rs,mid+1,r,L,R);
		if(R<=mid) return ask(ls,l,mid,L,R);
		Segment res1=ask(ls,l,mid,L,mid),res2=ask(rs,mid+1,r,mid+1,R);
		return Segment(res1.cnt0+res2.cnt0,res1.cnt1+res2.cnt1);
	}
}SegTree[10];
inline ll Qsum(int x,int y) {
	ll ans=0;
	while(top[x]!=top[y]) {//always jump with x
		if(dep[top[x]]<dep[top[y]]) swap(x,y);//dep[top[x]]>=dep[top[y]]
		for(register int i=0;i<10;++i) {
			Segment tmp=SegTree[i].ask(1,1,num,seg[top[x]],seg[x]);
			res[i].cnt0+=tmp.cnt0; res[i].cnt1+=tmp.cnt1;
		}
		x=fa[top[x]];
	}
	if(dep[x]>dep[y]) swap(x,y);//dep[x]<=dep[y]
	for(register int i=0;i<10;++i) {
		Segment tmp=SegTree[i].ask(1,1,num,seg[x],seg[y]);
		res[i].cnt0+=tmp.cnt0; res[i].cnt1+=tmp.cnt1;
		ans+=res[i].cnt0*res[i].cnt1*(1ll<<i);
		res[i].cnt0=res[i].cnt1=0;
	}
	return ans;
}
int main() {
	int n=read(),Q=read();
	for(register int i=1;i<n;++i) {
		int x=read(),y=read(),w=read();
		mp[std::make_pair(x,y)]=mp[std::make_pair(y,x)]=w;
		add(x,y,w); add(y,x,w);
	}
	dep[1]=1; dfs1(1); dfs2(1,1);
	for(register int i=0;i<10;++i) SegTree[i].build(1,1,num,i);
	while(Q--) {
		int op=read(),u=read(),v=read();
		if(op==1) {printf("%lld\n",Qsum(u,v));}
		if(op==2) {
			int V=read(); if(fa[u]!=v) swap(u,v);
			int preval=mp[std::make_pair(u,v)];
			for(register int i=0;i<10;++i) {if((preval>>i&1)^(V>>i&1)) SegTree[i].reverse(1,1,num,seg[u],seg[u]+size[u]-1);}
			mp[std::make_pair(u,v)]=mp[std::make_pair(v,u)]=V;
		}
	}
	return 0;
}
```

---

## 作者：gyyyyx (赞：0)

[题面](https://www.luogu.com.cn/problem/P3401)

首先可以知道最终的答案一定是：

$$
\sum{\sum{xr_x\oplus xr_y}}
$$

其中 $xr_i$ 指 $i$ 节点到根的异或和，而 $x,y$ 都是在 $u\to v$ 的路径上的。

有树上路径查询和修改，加上这 $n$ 的范围，可以大概确定是树剖套一个带 $\log$ 的数据结构。

有一个基础的思路是可以用线段树维护重链区间的最终答案。

但显然这样是不可行的。

那我们可以回归异或的本质：一种**按位**的运算。

看到 $w$ 只有 $2^{10}-1$，也就是二进制中最多只有 $10$ 位，是否可以将每一位都分别记录呢？

我们发现 $0\oplus 0=0,0\oplus 1=1,1\oplus 1=0$，也就是说二进制中每一位中相同的数异或是 $0$，不同是 $1$。

那我们可以用线段树记录重链区间内所有 $xr$ 每一位的 $0,1$ 的个数。

知道了第 $i$ 位是 $1$ 的 $xr$ 的数量 $a$，$0$ 的是 $b$，那这一位的贡献就是 $2^iab$。

只要我们知道每一位的 $a,b$，就可以知道最终答案。

而实际上知道 $a+b$ 是很容易的，因此只需要维护 $a$ 或 $b$ 即可。

那查询就很容易了，修改呢？

因为维护的是前缀异或和，所以修改一条边一定会影响到这条边深度更深的点的子树上的所有边，因此需要一个区间修改。

而如果新修改的值和旧的值的第 $i$ 位不相等，说明子树的这一位都会改变，因此交换一下 $0,1$ 的数量就行了。

代码：

```cpp
#include<bits/stdc++.h>
#define LL long long
#define N 30005
using namespace std;
int n,q,op,u,v,w;
int head[N],nxt[N<<1],to[N<<1],e[N<<1],cnt;
inline void add(int x,int y,int z){
    e[++cnt]=z;
    to[cnt]=y;
    nxt[cnt]=head[x];
    head[x]=cnt;
}
int dep[N],siz[N],fa[N],son[N],m[N],xr[N];
int id[N],rnk[N],tot,tp[N];
void dfs1(int k,int f){
    dep[k]=dep[fa[k]=f]+1;siz[k]=1;
    for(int i(head[k]);i;i=nxt[i]){
        int s(to[i]);
        if(!(s^f)) continue;
        xr[s]=xr[k]^(m[s]=e[i]);dfs1(s,k);
        if(siz[s]>siz[son[k]]) son[k]=s;
        siz[k]+=siz[s];
    }
}
void dfs2(int k,int t){
    rnk[id[k]=++tot]=k;tp[k]=t;
    if(son[k]) dfs2(son[k],t);
    for(int i(head[k]);i;i=nxt[i]){
        int s(to[i]);
        if(!(s^fa[k])||!(s^son[k])) continue;
        dfs2(s,s);
    }
}
int c[N<<2][15],tag[N<<2][15],ans[15];
#define ls (k<<1)
#define rs (k<<1|1)
#define mid (l+r>>1)
inline void pushup(int k){
    for(int i(0);i<=10;++i)
        c[k][i]=c[ls][i]+c[rs][i];
}
void Build(int k,int l,int r){
    if(l==r){
        for(int i(0);i<=10;++i)
            if((1<<i)&xr[rnk[l]]) c[k][i]=1;
        return;
    }
    Build(ls,l,mid);
    Build(rs,mid+1,r);
    pushup(k);
}
inline void pushdown(int k,int l,int r){
    for(int i(0);i<=10;++i){
        if(!tag[k][i]) continue;
        c[ls][i]=mid-l+1-c[ls][i];
        c[rs][i]=r-mid-c[rs][i];
        tag[ls][i]^=1;
        tag[rs][i]^=1;
        tag[k][i]=0;
    }
}
void Query(int k,int l,int r,int x,int y){
    if(l>y||r<x) return;
    if(x<=l&&r<=y){
        for(int i(0);i<=10;++i)
            ans[i]+=c[k][i];
        return;
    }
    pushdown(k,l,r);
    Query(ls,l,mid,x,y);
    Query(rs,mid+1,r,x,y);
}
void Update(int k,int l,int r,int x,int y,int z){
    if(l>y||r<x) return;
    if(x<=l&&r<=y){
        c[k][z]=r-l+1-c[k][z];
        tag[k][z]^=1;
        return;
    }
    pushdown(k,l,r);
    Update(ls,l,mid,x,y,z);
    Update(rs,mid+1,r,x,y,z);
    pushup(k);
}
inline int LCA(int x,int y){
    while(tp[x]^tp[y]){
        if(dep[tp[x]]<dep[tp[y]]) swap(x,y);
        x=fa[tp[x]];
    }
    if(dep[x]>dep[y]) swap(x,y);
    return x;
}
inline LL QUERY(int x,int y){
    LL len(dep[x]+dep[y]-(dep[LCA(x,y)]<<1)+1),res(0);
    memset(ans,0,sizeof(ans));
    while(tp[x]^tp[y]){
        if(dep[tp[x]]<dep[tp[y]]) swap(x,y);
        Query(1,1,n,id[tp[x]],id[x]);x=fa[tp[x]];
    }
    if(id[x]>id[y]) swap(x,y);
    Query(1,1,n,id[x],id[y]);
    for(int i(0);i<=10;++i)
        res+=(1LL<<i)*ans[i]*(len-ans[i]);
    return res;
}
inline void UPDATE(int x,int y){
    for(int i(0);i<=10;++i)
        if((1<<i)&(m[x]^y))
            Update(1,1,n,id[x],id[x]+siz[x]-1,i);
    m[x]=y;
}
int main(){
    scanf("%d%d",&n,&q);
    for(int i(1);i<n;++i){
        scanf("%d%d%d",&u,&v,&w);
        add(u,v,w);add(v,u,w);
    }
    dfs1(1,0),dfs2(1,1);Build(1,1,n);
    while(q--){
        scanf("%d%d%d",&op,&u,&v);
        if(op^2) printf("%lld\n",QUERY(u,v));
        else{
            scanf("%d",&w);
            if(dep[u]<dep[v]) swap(u,v);
            UPDATE(u,w);
        }
    }
    return 0;
}
```

---

## 作者：RocksonLee (赞：0)

## Problem

[Luogu](https://www.luogu.com.cn/problem/P3401)

## Solution

首先思考一个问题，我们怎么求得一个路径的异或起来的和呢？

没错，快速一点的方法就是前缀和，利用异或前缀和可以解决一些问题

异或有个性质 $a\otimes b\otimes b=a$，所以 $s_{u,v}=s_u\otimes s_v\otimes s_{lca}\otimes s_{lca}=s_u\otimes s_v$。

所以 $\sum_{i,j \in (u,v)} s_i \otimes s_j$

那么你已经掌握了暴力解法了，接下来就是优化！

首先想一个问题

对于一个路径 $(x,y)$，我们应该怎么搞出他的答案呢？

看到 $0 \leq w \leq 2^{10}-1$，你是不是有些顿悟捏？

嗯，那么熟练点，拆二进制位对于求解异或似乎是一个很方便的做法

然后我们针对某个二进制位研究：

对一个路径，$s_x \otimes s_y$，才会对答案有 1 的贡献

那么要求对于每一个对答案有贡献的点对，应该是一个为 1 一个为 0，即数值不同。

那么这一位对答案的贡献应为 1 的个数乘上 0 的个数乘上 $(1<<i)$。

好了，我们大概知道这么求了，对于树上路径当然是使用树剖拉（你用 LCT 我没意见）

然后呢建立一个线段树，记录下每一个点到根的异或前缀和，然后再保存下 1 的个数以及 0 的个数

由于是储存异或前缀和，所以一个点被改变，他的子树也会被改变。

那么，我们对于线段树的每一个点的改变，都是 sum - 目前的个数，换句话来说就是翻转子树内 0，1 的个数。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define il inline
#define cl(a, b) memset(a, b, sizeof(a))
typedef long long ll;
typedef unsigned long long ull;

#define N 30300

struct Edge
{
    int val, v, next;
} e[N << 1];
int cnt = 1, head[N];

il void edd(int u, int v, int val)
{
    e[cnt].val = val;
    e[cnt].v = v;
    e[cnt].next = head[u];
    head[u] = cnt++;
    return;
}

ll W[N];
int n, q;

struct Tree
{
    int l, r, f;
    ll sum;
};
#define ls(x) (x << 1)
#define rs(x) ((x << 1) | 1)
struct SeG
{
    Tree t[N << 2];
    il void down(int x)
    {
        if (t[x].f == 0) return;
        t[ls(x)].sum = t[ls(x)].r - t[ls(x)].l + 1 - t[ls(x)].sum;
        t[rs(x)].sum = t[rs(x)].r - t[rs(x)].l + 1 - t[rs(x)].sum;

        t[ls(x)].f ^= 1;
        t[rs(x)].f ^= 1;

        t[x].f = 0;
        return;
    }

    il void pushup(int x)
    {
        t[x].sum = t[ls(x)].sum + t[rs(x)].sum;
        return;
    }

    void build(int x, int l, int r, int tt)
    {
        t[x].l = l, t[x].r = r;
        if (l == r)
        {
            t[x].sum = (W[l] >> tt) & 1;
            return;
        }
        int mid = (l + r) >> 1;
        build(ls(x), l, mid, tt);
        build(rs(x), mid + 1, r, tt);
        pushup(x);
        return;
    }

    void change(int x, int l, int r)
    {
        if (t[x].l > r || t[x].r < l) return;
        if (t[x].l >= l && t[x].r <= r)
        {
            t[x].sum = t[x].r - t[x].l + 1 - t[x].sum;
            t[x].f ^= 1;
            return;
        }
        down(x);
        change(ls(x), l, r), change(rs(x), l, r);
        pushup(x);
        return;
    }

    ll ask(int x, int l, int r)
    {
        if (t[x].l > r || t[x].r < l) return 0;
        if (t[x].l >= l && t[x].r <= r) return t[x].sum;
        down(x);
        return ask(ls(x), l, r) + ask(rs(x), l, r);
    }
};

struct TLC
{
    int size[N], dep[N], fa[N], son[N], eg[N];
    ll  val[N];
    int top[N], id[N], rev[N], tot;

    SeG tree[10];

    void dfs1(int u, int f)
    {
        dep[u] = dep[f] + 1;
        size[u] = 1;
        fa[u] = f;
        for (int i = head[u]; i; i = e[i].next)
        {
            int v = e[i].v;
            if (f == v) continue;
            eg[v] = e[i].val;
            val[v] = val[u] ^ e[i].val;
            dfs1(v, u);
            size[u] += size[v];
            if (size[v] > size[son[u]] || !son[u]) son[u] = v;
        }
    }

    void dfs2(int u, int t)
    {
        top[u] = t;
        id[u] = ++tot;
        rev[tot] = u;
        if (!son[u]) return;
        dfs2(son[u], t);
        for (int i = head[u]; i; i = e[i].next)
        {
            int v = e[i].v;
            if (v == fa[u] || son[u] == v) continue;
            dfs2(v, v);
        }
    }

    void change(int u, int v, int w)
    {
        if (dep[u] < dep[v]) swap(u, v);
        for (int i = 0; i <= 9; i++)
        {
            if (((eg[u] >> i) & 1) ^ ((w >> i) & 1)) tree[i].change(1, id[u], id[u] + size[u] - 1);
        }
        eg[u] = w;
        return;
    }

    int LCA(int u, int v)
    {
        while (top[u] != top[v])
        {
            if (dep[top[u]] < dep[top[v]]) swap(u, v);
            u = fa[top[u]];
        }
        return dep[u] < dep[v] ? u : v;
    }

    ll Pask(int u, int v, int tt)
    {
        if (dep[u] < dep[v]) swap(u, v);
        int lca = LCA(u, v), gs = 0, tot = 0;
        tot = dep[u] + dep[v] - 2 * dep[lca] + 1;
        while (top[u] != top[v])
        {
            if (dep[top[u]] < dep[top[v]]) swap(u, v);
            gs += tree[tt].ask(1, id[top[u]], id[u]);
            u = fa[top[u]];
        }
        if (dep[u] > dep[v]) swap(u, v);
        gs += tree[tt].ask(1, id[u], id[v]);
        return gs * (tot - gs);
    }

    ll ask(int u, int v)
    {
        ll ans = 0;
        for (int i = 0; i <= 9; i++)
            ans += Pask(u, v, i) * (1 << i);
        return ans;
    }
} a;

#define in(x) x = read()
il int read()
{
    int v = 1, x = 0;
    char ch = getchar();
    while (!isdigit(ch))
    {
        if (ch == '-') v = -1;
        ch = getchar();
    }
    while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();
    return x * v;
}

int main()
{
    in(n), in(q);
    for (int i = 1; i < n; i++)
    {
        int u, v, w;
        in(u), in(v), in(w);
        edd(u, v, w);
        edd(v, u, w);
    }
    a.dfs1(1, 0);
    a.dfs2(1, 1);
    for (int i = 1; i <= n; i++) W[a.id[i]] = a.val[i];
    for (int i = 0; i <= 9; i++) a.tree[i].build(1, 1, n, i);
    for (int i = 0; i < q; i++)
    {
        int op;
        in(op);
        switch (op)
        {
        case 1:
        {
            int u, v;
            in(u), in(v);
            printf("%lld\n", a.ask(u, v));
            break;
        }
        case 2:
        {
            int u, v, w;
            in(u), in(v), in(w);
            a.change(u, v, w);
            break;
        }
        }
    }
}
```


---

## 作者：peterwuyihong (赞：0)

题意：给一棵带边权树，每次支持修改边权，或者询问 $x,y$ 之间所有子路径的异或和之和。

你发现这是异或，于是使用异或的特性，把它变成两个点之间异或。由于这是一棵树，你使用了树上前缀异或和，于是 $(1,x)\ \text{xor}\ (1,y)\rightarrow(x,y)$ 。

然后你考虑每一位被计算了几次，对于第 $t$ 位，你把 $(1,k),k\in \text{path}(x,y)$ 中第 $t$ 位是 $1$ 的记作 $sum_t$ ，是 $0$ 的就能算出来，然后进行简单数学计算，就是 $1$ 的乘以 $0$ 的就行了。算出被计算了几次，再乘以这一位对应的权值 $2^t$ 相加即可。线段树维护，时间复杂度 $O(10n\log^2 n)$

现在是 $9:16$ ，我看我什么时候写完。

现在是 $10:08$ ，我写完了。。

```cpp
#define maxn 100010
int n,m,x,y,z,op;
int head[maxn],Next[maxn<<1],ver[maxn<<1],tot=1;
void add(int x,int y){
	ver[++tot]=y;
	Next[tot]=head[x];
	head[x]=tot;
}
int dep[maxn],siz[maxn],son[maxn];
int fa[maxn],dfn[maxn],top[maxn],cnt;
void dfs1(int x){
	siz[x]=1;
	for(int i=head[x];i;i=Next[i]){
		int y=ver[i];
		if(dep[y])continue;
		dep[y]=dep[x]+1;
		fa[y]=x;
		dfs1(y);
		siz[x]+=siz[y];
		if(siz[son[x]]<siz[y])son[x]=y;
	}
}
void dfs2(int x,int t){
	top[x]=t;
	dfn[x]=++cnt;
	if(!son[x])return;
	dfs2(son[x],t);
	for(int i=head[x];i;i=Next[i])
	if(ver[i]!=fa[x]&&ver[i]!=son[x])dfs2(ver[i],ver[i]);
}
struct prpr{
	int l,r;
	int w[10],tag;
}tree[maxn<<2];
void pushup(int x){
	for(int i=0;i<10;i++)tree[x].w[i]=tree[x<<1].w[i]+tree[x<<1|1].w[i];
}
void pushdown(int x){
	if(tree[x].tag){
		tree[x<<1].tag^=tree[x].tag,tree[x<<1|1].tag^=tree[x].tag;
		for(int i=0;i<10;i++)if(tree[x].tag>>i&1)tree[x<<1].w[i]=tree[x<<1].r-tree[x<<1].l+1-tree[x<<1].w[i];
		for(int i=0;i<10;i++)if(tree[x].tag>>i&1)tree[x<<1|1].w[i]=tree[x<<1|1].r-tree[x<<1|1].l+1-tree[x<<1|1].w[i];
		tree[x].tag=0;
	}
}
void build(int l,int r,int x=1){
	tree[x].l=l,tree[x].r=r;
	if(l==r)return;
	int mid=(l+r)>>1;
	build(l,mid,x<<1),build(mid+1,r,x<<1|1);
}
void change(int l,int r,int d,int x=1){
	if(tree[x].l>=l&&tree[x].r<=r){
		for(int i=0;i<10;i++)
		if(d>>i&1)tree[x].w[i]=tree[x].r-tree[x].l+1-tree[x].w[i];
		tree[x].tag^=d;
		return;
	}
	pushdown(x);
	int mid=(tree[x].l+tree[x].r)>>1;
	if(l<=mid)change(l,r,d,x<<1);
	if(r>mid)change(l,r,d,x<<1|1);
	pushup(x);
}
int G[10][2];
long long ans;
void ask(int l,int r,int x=1){
	if(tree[x].l>=l&&tree[x].r<=r){
		for(int i=0;i<10;i++){
			G[i][0]+=tree[x].r-tree[x].l+1-tree[x].w[i];
			G[i][1]+=tree[x].w[i];
		}
		return;
	}
	pushdown(x);
	int mid=(tree[x].l+tree[x].r)>>1;
	if(l<=mid)ask(l,r,x<<1);
	if(r>mid)ask(l,r,x<<1|1);
}
void O(int x,int y){
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		ask(dfn[top[x]],dfn[x]);
		x=fa[top[x]];
	}
	if(dep[x]>dep[y])swap(x,y);
	ask(dfn[x],dfn[y]);
}
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>
using namespace __gnu_pbds;
gp_hash_table<long long,int>M;
signed main(){
#ifndef ONLINE_JUDGE
	freopen("testdata.in","r",stdin);
#endif
	cin>>n>>m;
	for(int i=1;i<n;i++){
		cin>>x>>y>>z;
		M[x*100000ll+y]=z;
		M[y*100000ll+x]=z;
		add(x,y),add(y,x);
	}
	dep[1]=1;dfs1(1),dfs2(1,1);
	build(1,n);
	for(int i=2;i<=tot;i+=2){
		x=ver[i],y=ver[i^1];
		if(dep[x]<dep[y])swap(x,y);
		change(dfn[x],dfn[x]+siz[x]-1,M[x*100000ll+y]);
	}
	while(m--){
		cin>>op>>x>>y;
		if(op==1){
			for(int i=0;i<10;i++)G[i][0]=G[i][1]=0;
			ans=0;
			O(x,y);
			for(int i=0;i<10;i++)ans+=(long long)G[i][0]*G[i][1]*(1<<i);
			cout<<ans<<endl;
		}else{
			cin>>z;
			if(dep[x]<dep[y])swap(x,y);
			change(dfn[x],dfn[x]+siz[x]-1,M[x*100000ll+y]);
			change(dfn[x],dfn[x]+siz[x]-1,z);
			M[x*100000ll+y]=z;
		}
	}
#ifndef ONLINE_JUDGE
	cerr<<endl<<(double)clock()/CLOCKS_PER_SEC;
#endif
}
```
这个人太逊了，居然 $\text{ask}$ 时忘了 $\text{pushdown}$ 。

这是尝试卡常版本，一开始写的是 $\text{map}$ 存边，现在改成了平板电视加手动 $\text{Hash}$ ，仍然卡不过最优解，太逊了，太逊了。

---


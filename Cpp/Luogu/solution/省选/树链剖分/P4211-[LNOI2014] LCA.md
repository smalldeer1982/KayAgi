# [LNOI2014] LCA

## 题目描述

给出一个 $n$ 个节点的有根树（编号为 $0$ 到 $n-1$，根节点为 $0$）。

一个点的深度定义为这个节点到根的距离 $+1$。 

设 $dep[i]$ 表示点 $i$ 的深度，$\operatorname{LCA}(i, j)$ 表示 $i$ 与 $j$ 的最近公共祖先。 

有 $m$ 次询问，每次询问给出 $l, r, z$，求 $\sum_{i=l}^r dep[\operatorname{LCA}(i,z)]$ 。

## 说明/提示

### 数据范围及约定

- 对于 $20\%$ 的数据，$n\le 10000,m\le 10000$；
- 对于 $40\%$ 的数据，$n\le 20000,m\le 20000$；
- 对于 $60\%$ 的数据，$n\le 30000,m\le 30000$；
- 对于 $80\%$ 的数据，$n\le 40000,m\le 40000$；
- 对于 $100\%$ 的数据，$1\le n\le 50000,1\le m\le 50000$。

## 样例 #1

### 输入

```
5 2
0
0
1
1
1 4 3
1 4 2```

### 输出

```
8
5```

# 题解

## 作者：紫钦 (赞：208)

这题统计l~r中所有点与z的lca的深度之和。

暴力就是把lca都求出来。。。

**所以正解要么是一次求出多个lca，要么就是用玄学的方法把这个求多个deep的和转化一下。**

~~前者我不会。~~

***

我们来看后者：

$deep[i]$是什么？——就是从 i 点到根有多少个点（包括 i ）。

我们从整体上考虑，发现对于一个询问：l , r , z 来说，所有的 lca 都在 z 到根的路径上。**从而有一些点，它们对很多的 lca 的深度都有贡献**，而这个贡献等于在这个点下面的 lca 的个数，所以我们可以把每个 lca 到根的路径上的每个点的权值都加一。然后从 z 向上走到根，沿路统计的权值就是答案了。

**现在的问题就是：怎么找到这些 lca 并打上标记？**

~~想想当初我们不会求 lca 的时候，~~要求lca（x , y）时，我们可以将根到 x 的所有点染色，然后从 y 向上爬，爬到的第一个有颜色的点就是lca (x , y)了，我们现在也可以这么做。

就是：对于一个询问： l , r , z ，我们把每个点 i （ l <= i <= r ） 到根的路径上的每一个点的权值都加一，记得上文我写到：**所有的 lca 都在 z 到根的路径上**，所以我们可以从 z 点向上爬到根，沿途统计的点权值之和，就是答案了。

~~这样就比暴力快不了多少了。~~

***

是时候考虑优化的问题了：我们每次的操作都是从某个点到根的，所以树链剖分+线段树就好了。

但是考虑到每次统计时，不能很好的排除 l ~ r 区间之外的点对 z->根 这条路径的贡献，所以我们每次都要清空线段树。

我们每次清空线段树，然后从 l ~ r 再添加一遍，树剖+线段树的复杂度就是$O(n * logn * logn)$的，还要做 q 次，复杂度依然不理想。

***

看数据范围，$O(n*logn*logn)$应该就是正解了，现在要想办法优化掉最后的那个 q 的复杂度。

我们看到区间 l~r ，~~总要想想差分的对不对，~~想到差分可以将询问拆开，而且每个拆开的区间之间是有重叠的，是可以转移的，而不用每次都清空。

**而且差分后的数组只与右端点有关！**

**所以我们可以将差分后的区间按照右端点从小到大排序（左端点都是根），然后按从小到大的顺序添加点，每遇到一个询问就查询一次，从而排除掉区间之外的点的影响，也就优化掉一个 q 的复杂度。**

至此，思路全部结束。

***
细节：

1.树剖+线段树的细节（这里不做赘述）。

2.差分当然要标记一下这个区间是 1 ~ l-1 还是 1~r 。

3.题目是以0为根，不习惯的朋友可以整体+1。整体+1也要注意，~~我做这题时就忘了询问也加一了，~~这也是个细节。

4.似乎没什么了。。。

***

AC代码（832ms）：

关键点的注释已经写到代码里了，若还有不懂的可以私聊我。

```cpp

#include<cstdio>
#include<iostream>
#include<cstdlib>
#include<cmath>
#include<algorithm>
#define lson l,mid,rt<<1
#define rson mid+1,r,rt<<1|1 
using namespace std;

const int MAXN = 50005;
const int MOD = 201314;

struct Que {
	int ans1,ans2; // 询问的区间的答案是ans1-ans2。 
	Que() {ans1=ans2=0;}
}que[MAXN];
struct Que_part { //用来做差分的询问。 
	int num,pos,z; // 属于第几个询问； 询问是1~pos这个区间的和； 询问的点是z。 
	bool flag; // 类型：0：1~l-1 ； 1：1~r。
	Que_part() {num=pos=z=flag=0;} 
	Que_part(int a,int b,int c,bool d) {
		num=a; pos=b; z=c; flag=d;
	}
	
	inline bool operator < (const Que_part &a) const {
		return this->pos<a.pos;
	}
}que_p[MAXN<<1]; 

inline bool operator > (const Que_part &a,const Que_part &b) { // 我只是想看看operator定义到外面会怎么样。 
	return a.pos>b.pos;
}

int n,q; // 如题。 
int nex[MAXN],to[MAXN],en[MAXN]; // next; to; end; 变量名简陋，勿喷。 
int size[MAXN],fa[MAXN],dep[MAXN],son[MAXN]; // size; father; deep; heavy son(姑且这么叫吧);  
int top[MAXN],seq[MAXN],dfn[MAXN]; // seq是点到序列的映射，dfn是序列到点的映射。 
int sum[MAXN<<2],col[MAXN<<2],nowl,nowr; // 线段树；nowl,nowr表示当前查询/修改的区间的左右端点。 


void update(int rt)
{
	sum[rt]=(sum[rt<<1]+sum[rt<<1|1]) %MOD;
}
/*void build(int l,int r,int rt)
{
	if(l==r) {
		sum[rt]=col[rt]=0;
		return ;
	}
	col[rt]=0;
	int mid=(l+r)>>1;
	build(lson);
	build(rson);
	update(rt);
}*/
void color(int l,int r,int rt,int co)
{
	sum[rt]=(sum[rt]+(r-l+1)*co) %MOD;
	if(l<r) col[rt]=(col[rt]+co) %MOD;
}
void push_col(int l,int r,int rt)
{
	if(col[rt] && l<r) {
		int mid=(l+r)>>1;
		color(lson,col[rt]);
		color(rson,col[rt]);
	}
	col[rt]=0;
}
int query(int l,int r,int rt)
{
	if(nowl<=l && r<=nowr) return sum[rt];
	push_col(l,r,rt);
	int mid=(l+r)>>1,ans=0;
	if(nowl<=mid) ans+=query(lson);
	if(mid<nowr ) ans+=query(rson);
	return ans %MOD;
}
void modify(int l,int r,int rt)
{
	if(nowl<=l && r<=nowr) {
		color(l,r,rt,1);
		return ;
	}
	push_col(l,r,rt);
	int mid=(l+r)>>1;
	if(nowl<=mid) modify(lson);
	if(mid<nowr ) modify(rson);
	update(rt); 
}

void dfs1(int x)
{
	size[x]=1;
	for(int p=en[x];p;p=nex[p]) {
		if(to[p]!=fa[x]) { //其实用不着判断的，但我写习惯了。 
			dep[to[p]]=dep[x]+1;
			dfs1(to[p]);
			if(size[son[x]]<size[to[p]]) son[x]=to[p];
			size[x]+=size[to[p]];
		}
	}
}
void dfs2(int x,int anc)
{
	static int t=0;
	top[x]=anc;
	seq[x]=++t;
	dfn[t]=x;
	if(!son[x]) return ;
	dfs2(son[x],anc);
	for(int p=en[x];p;p=nex[p]) {
		if(to[p]!=fa[x] && to[p]!=son[x])
			dfs2(to[p],to[p]);
	}
}
int query_chain(int x,int y)
{
	int tx=top[x],ty=top[y],ans=0;
	while(tx!=ty) {
		if(dep[tx]<dep[ty]) {
			x^=y^=x^=y;
			tx^=ty^=tx^=ty;
		}
		nowl=seq[tx];nowr=seq[x];
		ans+=query(1,n,1);
		x=fa[tx];
		tx=top[x];
	}
	if(dep[x]>dep[y]) x^=y^=x^=y;
	nowl=seq[x];nowr=seq[y];
	ans+=query(1,n,1);
	return ans %MOD;
}
void modify_chain(int x,int y)
{
	int tx=top[x],ty=top[y];
	while(tx!=ty) {
		if(dep[tx]<dep[ty]) {
			x^=y^=x^=y;
			tx^=ty^=tx^=ty; 
		}
		nowl=seq[tx];nowr=seq[x];
		modify(1,n,1);
		x=fa[tx];
		tx=top[x];
	}
	if(dep[x]>dep[y]) x^=y^=x^=y;
	nowl=seq[x];nowr=seq[y];
	modify(1,n,1);
}

int main()
{
	int l,r,z,cnt=0,now=0; 
	scanf("%d %d",&n,&q);
	for(int i=2;i<=n;++i) { // 整体编号加一。 
		scanf("%d",&z);
		nex[++cnt]=en[fa[i]=++z];to[cnt]=i;en[z]=cnt; // 加一条 z->i 的有向边。
	}
	cnt=0; 
	for(int i=1;i<=q;++i) {
		scanf("%d %d %d",&l,&r,&z);
		++r;++z; 
		que_p[++cnt]=Que_part(i,l,z,0);
		que_p[++cnt]=Que_part(i,r,z,1);
	}
	
	dep[1]=1;
	dfs1(1);
	dfs2(1,1);
	//build(1,n,1);// 我为什么要建树。。。 
	
	sort(que_p+1,que_p+cnt+1);
	
	for(int i=1;i<=cnt;++i) {
		while(now<que_p[i].pos) { // 一个点一个点往近添加。 now为当前添加过的点。 
			modify_chain(1,++now);
		}
		
		l=que_p[i].num; // 反正l没用了。就令l为当前子询问对应的母询问的序号吧。 
		if(que_p[i].flag) que[l].ans1=query_chain(1,que_p[i].z); // 也许不写这个1会让常数稍稍小一点。 
		else que[l].ans2=query_chain(1,que_p[i].z); 
	}
	
	for(int i=1;i<=q;++i) {
		printf("%d\n",(que[i].ans1-que[i].ans2+MOD) %MOD); // 记得要判负数。。。 
	}
	return 0;
} 

```

---

## 作者：鏡音リン (赞：182)

# 全局平衡二叉树

全局平衡二叉树是一种可以处理树上链修改/查询的数据结构，可以做到：
- $O(\log n)$ 一条链整体修改
- $O(\log n)$ 一条链整体查询

还可以 $O(\log n)$ 求最近公共祖先，子树修改，子树查询等，这些复杂度和重链剖分是一样的。

由于没有专门给这玩意准备的模板，我建议使用 [P4211 [LNOI2014]LCA](https://www.luogu.com.cn/problem/P4211) 作为模板题。这道题涉及到链加、链求和两种使用全局平衡二叉树复杂度优于朴素重链剖分的操作，也没有其他的操作，除此之外的转化也很简单。

其实直接用 [P3384 【模板】轻重链剖分](https://www.luogu.com.cn/problem/P3384) 当模板也是可以的，也可以做到单次操作 $O(\log n)$，但是涉及到子树修改查询，比较难码（

下面我们用P4211当例题讲解。首先这个题区间 lca 深度和可以转化成给 $[l,r]$ 内的每个点到根的链权值整体 $+1$，然后查询 $z$ 点到根的链的权值和。用差分就可以转化成 $n$ 次修改 $2m$ 次查询。其他题解也讲的很清楚，这不是本篇题解重点。

以下正文开始

------

全局平衡二叉树的主要性质如下：

1.  它由很多棵二叉树通过轻边连起来组成，每一棵二叉树维护了原树的一条重链，其中序遍历的顺序就是这条重链深度单调递增的顺序。每个节点都仅出现在一棵二叉树中。
2. 边分为重边和轻边，重边是包含在二叉树中的边，维护的时候就像正常维护二叉树一样，记录左右儿子和父节点。轻边从一颗二叉树的根节点指向它所对应的重链顶端节点的父节点。轻边维护的时候“认父不认子”，即只能从子节点访问到父节点，不能反过来。注意，全局平衡二叉树中的边和原树中的边没有对应关系。

如果你学过 LCT 就能发现这几条性质和 LCT 非常相似，区别是用二叉树替代了 splay，用重边和轻边替代了实边和虚边。全局平衡二叉树就是静态化的 LCT。

3. 算上重边和轻边，这棵树的高度是 $O(\log n)$ 级别的。这条是保证复杂度的性质。

蒟蒻深知没图的痛苦，所以画了两张图，第一张图是原树，以节点 $1$ 为根节点。第二张图是建出来的全局平衡二叉树，其中虚线是轻边，实线是重边，一棵二叉树用红圈表示。

![](https://cdn.luogu.com.cn/upload/image_hosting/62uwjc1m.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/p1bdrmg8.png)

即使你不会 LCT 也没关系，全局平衡二叉树没有像 LCT 那么多操作（毕竟都是静态的，又没法 splay 和 access）。那么我们怎么建树呢，其实只要对着性质里所说的来就可以了。首先是像普通重链剖分一样，一次 dfs 求出每个节点的重儿子。然后从根开始，找到根节点所在的重链，对于这些点的轻儿子递归建树，并连上轻边。然后我们需要给重链上的点建一棵二叉树。我们先把重链上的点存到数组里，求出每个点轻儿子的 size 和 $+1$。然后我们按照这个求出这条重链的加权中点，把它作为二叉树的根，两边递归建树，并连上重边。

可能不是很好理解，代码如下：

```cpp
std::vector<int> G[N];
int n, fa[N], son[N], sz[N];
void dfsS(int u) {
	sz[u] = 1;
	for (int v : G[u]) {
		dfsS(v);
		sz[u] += sz[v];
		if (sz[v] > sz[son[u]]) son[u] = v;
	}
}
int b[N], bs[N], l[N], r[N], f[N], ss[N];
// 给b中[bl,br)内的点建二叉树，返回二叉树的根
int cbuild(int bl, int br) {
	int x = bl, y = br;
	while (y-x > 1) {
		int mid = (x+y) >> 1;
		if (2*(bs[mid]-bs[bl]) <= bs[br]-bs[bl]) x = mid;
		else y = mid;
	}
	// 二分求出按bs加权的中点。不使用二分而是直接扫一遍复杂度也对
	y = b[x];
	ss[y] = br-bl; // ss：二叉树中重子树的大小
	if (bl < x) {l[y] = cbuild(bl, x); f[l[y]] = y; }
	if (x+1 < br) {r[y] = cbuild(x+1, br); f[r[y]] = y; }
	return y;
}
int build(int x) {
	int y = x;
	do for (int v : G[y])
		if (v != son[y])
			f[build(v)] = y; // 递归建树并连轻边，注意要从二叉树的根连边，不是从儿子连边
	while (y = son[y]);
	y = 0;
	do {
		b[y++] = x; // 存放重链中的点
		bs[y] = bs[y-1] + sz[x] - sz[son[x]]; // bs：轻儿子size和+1，求前缀和
	} while (x = son[x]);
	return cbuild(0, y);
}
```

由代码可以看出建树的时间复杂度是 $O(n\log n)$。接下来我们可以证明树高是 $O(\log n)$ 的：考虑从任意一个点跳父节点到根。跳轻边就相当于在原树中跳到另一条重链，由重链剖分的性质可得跳轻边最多 $O(\log n)$ 条；因为建二叉树的时候根节点找的是算轻儿子的加权中点，那么跳一次重边算上轻儿子的 size 至少翻倍，所以跳重边最多也是 $O(\log n)$ 条。整体树高就是 $O(\log n)$ 的。

实际上关于全局平衡二叉树的部分就已经讲完了，剩下的链修改、链查询只需要从要操作的点往根跳，要操作某个点重链上比它深度小的所有点，就相当于在这条重链的二叉树里操作这个点左侧的所有点，可以拆成一系列子树操作，像维护普通二叉树一样维护子树和，打子树加标记就行。我使用的是标记永久化，其实也是可以标记用 pushdown，子树和用 pushup 的，不过可能不太好写（因为平时处理二叉树都是自上而下，这里是自下而上，可能需要先处理出跳的路径然后从上往下 pushdown 一遍，常数大大大）。反正怎么写着顺手怎么来，代码如下

```cpp
// a：子树加标记
// s：子树和（不算加标记的）
int a[N], s[N];
void add(int x) {
	bool t = true; int z = 0;
	while (x) {
		s[x] += z;
		if (t) {
			a[x]++; if (r[x]) a[r[x]]--;
			z += 1 + ss[l[x]];
			s[x] -= ss[r[x]];
		}
		t = (x != l[f[x]]);
		if (t && x != r[f[x]]) z = 0; // 跳过轻边要清空
		x = f[x];
	}
}
int query(int x) {
	int ret = 0;
	bool t = true; int z = 0;
	while (x) {
		if (t) {
			ret += s[x] - s[r[x]];
			ret -= 1ll * ss[r[x]] * a[r[x]];
			z += 1 + ss[l[x]];
		}
		ret += 1ll * z * a[x];
		t = (x != l[f[x]]);
		if (t && x != r[f[x]]) z = 0; // 跳过轻边要清空
		x = f[x];
	}
	return ret;
}
```

顺便说一句，对于子树操作，就是要考虑轻儿子的，需要再维护一个包括轻儿子的子树和、子树标记，有需要可以去做 [P3384 【模板】轻重链剖分](https://www.luogu.com.cn/problem/P3384) 

[本题的完整代码。](https://www.luogu.com.cn/paste/3fbg3m9k) 由于全局平衡二叉树这种科技还不是很普及，会的人也不多，这道题的题解区里全是~~被吊打的~~树剖 $O(n\log^2 n)$ 做法，写了一发 $O(n\log n)$ 没特意卡常轻松拿到 132ms rk1（截至写这篇题解的时候）。并且代码比大部分的树剖线段树做法还短。

---

## 作者：bzy369258147 (赞：66)

大家都是树剖O($n*log^2_2n$)的做法，那蒟蒻我就来一个O($n^{\frac{3}{2}}$)的做法.

首先,一个显然的想法:想要查询一个点和某些其他点的LCA深度和，我们可以考虑该节点的每个祖先中的需要查询的节点个数。但是会有重复统计，我们发现重复统计的次数即为LCA深度，所以我们显然地把问题转化成把所有要查询的节点到根的路径节点权值加1，查询某个节点的到根节点的路径权值和.

然后一个O($n^{\frac{3}{2}}*log^2_2n$)的做法就出来了，用莫队维护区间，用树剖维护树上权值，期望的分20.

考虑优化，由于莫队每次更新的时间复杂度为O($log^2_2n$)，但最多只有q次查询，可以考虑优化树剖的修改操作去掉一个log.但是这样还是过不了.

以上做法就达到莫队的极限了(大概).因为转移无法再优化了.然后我们发现某个静态的区间贡献的对于2某个查询贡献的答案是一定的，我们可以考虑分块.

对于每个块差分一下暴力dfs求出每个节点的答案.然后边角直接求LCA深度

然后LCA深度用倍增RMQ预处理即可做到O(1)查询

然后就做到整体O($n^{\frac{3}{2}}$)了.

代码如下(常数巨大):

```
#include<bits/stdc++.h>
using namespace std;
const int mod = 201314;

int n,m;
vector<int>to[50005];
int deep  [50005];

const int size = 500;
int belong[50005];
int query [105][50005];
int block [105];

int first[100005];
int st   [200005][18];
int lg2  [100005];
int cnt = 0;

void dfs_init(int now){
    st[ ++ cnt ][0] = deep[now];
    first[now] = cnt;
    for( auto next : to[now] ){
        deep[next] = deep[now] + 1;
        dfs_init( next );
        st[ ++ cnt ][0] = deep[now];
    }
}

int bin[50005];
void dfs1(int now){ for( auto next : to[now] )dfs1( next ),bin[now] += bin[next]; }
void dfs2(int now,int dist){ for( auto next : to[now] )dfs2( next,dist + bin[now] );bin[now] += dist; }

void init(){
    dfs_init(1);
    for(int i = 1;i <= n;i ++){
        belong[i] = i / size + 1;
        if( belong[i] - belong[i - 1] )block[ belong[i] ] = i;
    }
    for(int i = 2;i <= (n << 1);i ++)lg2[i] = lg2[i >> 1] + 1;
    for(int t = 1;t <= 17;t ++)for(int i = 1;i <= (n << 1) - (1 << t);i ++)
        st[i][t] = min( st[i][t - 1],st[i + (1 << (t - 1))][t - 1] );
}

int LCA(int A,int B){
    A = first[A];B = first[B];
    if( A > B )swap( A,B );
    int ln = lg2[ B - A + 1 ]; 
    return min( st[A][ln],st[B - (1 << ln) + 1][ln] );
}

int main(){
    cin >> n >> m;deep[1] = 1;
    for(int i = 2;i <= n;i ++){
        int v;cin >> v;v ++;
        to[v].push_back(i);
    }
    init();
    belong[0] = 0;belong[n + 1] = belong[n] + 1;
    block[0] = 0;block[ belong[n + 1] ] = n + 1;
    for(int i = 1;i <= belong[n];i ++){
        memset( bin,0,sizeof(bin) );
        for( int j = block[i];belong[j] == i;j ++ )bin[j] ++;
        dfs1(1);dfs2(1,0);
        for( int j = 1;j <= n;j ++ )query[i][j] = bin[j];
    }
    while( m -- ){
        int l,r,x;cin >> l >> r >> x;
        l ++;r ++;x ++;
        int bl = belong[l - 1] + 1;
        int br = belong[r + 1] - 1;
        long long ans = 0;
        for( ;belong[l] != bl and l <= r ;l ++ )ans += LCA( l,x );
        for( ;belong[r] != br and r >= l ;r -- )ans += LCA( r,x );
        for( int i = bl;i <= br;i ++ )ans += query[i][x];
        cout << ans % mod << "\n";
    }
    return 0;
}

```

---

## 作者：Great_Influence (赞：55)

感谢hzwer大佬的博客指示......

可以发现，问题能够转化为从询问点到根都加1，然后询问l到r的点到根的路径上权值之和。然后这个问题又和“l到r的点到根路径上所有点权值分别+1，求询问点到根路径上的权值之和”等价。

然后就可做了。将询问差分一下，变成查询$[1,r]-[1,l-1]$。这时候只需要离线询问，在l-1和r处分别打标记，在从1~n依次遍历，扫到标记就查询，用树链剖分套线段树维护。最后将答案全部输出即可。时间复杂度$O(n\log_2^2n)$。

代码：(笔记本打的，缩进有点丑)

```cpp
#include<bits/stdc++.h>
#define For(i,a,b) for(i=(a);i<=(b);++i)
#define Forward(i,a,b) for(i=(a);i>=(b);--i)
#define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
#define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
using namespace std;
template<typename T>inline void read(T &x)
{
	T s=0,f=1;char k=getchar();
	while(!isdigit(k)&&(k^'-'))k=getchar();
	if(!isdigit(k)){f=-1;k=getchar();}
	while(isdigit(k)){s=s*10+(k^48);k=getchar();}
	x=s*f;
}
void file()
{
	#ifndef ONLINE_JUDGE
		freopen("test.in","r",stdin);
		freopen("test.out","w",stdout);
	#endif
}
#define Chkmax(a,b) a=a>(b)?a:(b)
#define Chkmin(a,b) a=a<(b)?a:(b)
const int MAXN=5e4+7;
static struct edge
{
	int v,nxt;
}p[MAXN];
static int n,m,e,head[MAXN],dep[MAXN];
static int fa[MAXN],sz[MAXN],son[MAXN];
inline void add(int u,int v)
{p[++e].v=v;p[e].nxt=head[u];head[u]=e;}
void dfs(int u)
{
	sz[u]=1;dep[u]=dep[fa[u]]+1;
	for(register int v=head[u];v;v=p[v].nxt)
	{
		dfs(p[v].v);sz[u]+=sz[p[v].v];
		if(!son[u]||sz[p[v].v]>sz[son[u]])
			son[u]=p[v].v;
	}
}
static int top[MAXN],dfn[MAXN],ri[MAXN];
void dfs(int u,int tp)
{
	ri[dfn[u]=++e]=u;top[u]=tp;
	if(son[u])dfs(son[u],tp);
	else return;
	for(register int v=head[u];v;v=p[v].nxt)
		if(p[v].v^son[u])dfs(p[v].v,p[v].v);
}
const int mod=201314;
static vector<int>pl[MAXN],mi[MAXN];
static int ask[MAXN];
inline void init()
{
	read(n);read(m);
	Rep(i,2,n)read(fa[i]),add(++fa[i],i);
	dfs(1);e=0;dfs(1,1);
	static int l,r;
	Rep(i,1,m)read(l),read(r),read(ask[i])
		,mi[l].push_back(i),pl[r+1].push_back(i)
		,++ask[i];
}
static int sum[MAXN<<2],laz[MAXN<<2];
static int ans[MAXN];
inline void pushdown(int h,int l,int r)
{
	if(laz[h])
	{
		static int mid;mid=(l+r)>>1;
		sum[h<<1]=(sum[h<<1]
			+1ll*laz[h]*(mid-l+1)%mod)%mod;
		sum[h<<1|1]=(sum[h<<1|1]
			+1ll*laz[h]*(r-mid)%mod)%mod;
		laz[h<<1]+=laz[h];laz[h<<1|1]+=laz[h];
		laz[h]=0;
	}
}
void modify(int h,int l,int r,int x,int y)
{
	if(l>=x&&r<=y)
	{
		sum[h]=(sum[h]+r-l+1)%mod;
		++laz[h];return;
	}
	pushdown(h,l,r);
	int mid=(l+r)>>1;
	if(x<=mid)modify(h<<1,l,mid,x,y);
	if(y>mid)modify(h<<1|1,mid+1,r,x,y);
	sum[h]=(sum[h<<1]+sum[h<<1|1])%mod;
}
inline void modi(int x)
{
	while(x)
	{
		modify(1,1,n,dfn[top[x]],dfn[x])
		,x=fa[top[x]];}
}
static vector<int>::iterator it;
inline int query(int h,int l,int r,int x,int y)
{
	if(l>=x&&r<=y)return sum[h];
	pushdown(h,l,r);
	int mid=(l+r)>>1,ans=0;
	if(x<=mid)ans=query(h<<1,l,mid,x,y);
	if(y>mid)ans=(ans+query(h<<1|1,mid+1,r,x,y))%mod;
	return ans;
}
inline int qu(int x)
{
	static int ans;ans=0;
	while(x)
	{
		ans=(ans+query(1,1,n,dfn[top[x]],dfn[x]));
		x=fa[top[x]];
	}
	return ans;
}
inline void solve()
{
	Rep(i,1,n)
	{
		modi(i);
		for(it=pl[i].begin();it!=pl[i].end();++it)
			ans[*it]+=qu(ask[*it]);
		for(it=mi[i].begin();it!=mi[i].end();++it)
			ans[*it]-=qu(ask[*it]);
	}
	Rep(i,1,m)printf("%d\n",(ans[i]%mod+mod)%mod);
}
int main()
{
	file();
	init();
	solve();
	return 0;
}

```

~~其实还能用LCT优化到$O(n\log_2n)$，但是太麻烦了......$~~

---

## 作者：x义x (赞：38)

[$$\color{green}\Large\texttt{『菜鸡的blog』}$$](https://www.luogu.org/blog/zyxxs/)

显然地，两个点$(u,v)$的LCA的深度，就是从根到$u,v$的两条路径的公共长度（更准确地说，是公共点数）。

所以你可以想象，把$u$到根的路径上的点全部+1，求$v$到根的路径的权值和（这可以使用树剖实现），就是$(u,v)$的LCA的深度，下面称作$u$对$v$的贡献。

那么回到本题。本题的询问显然可以拆成“$[1,r]$对$z$的贡献”减“$[1,l-1]$对$z$的贡献”（下面分别记作$(r,z)$和$(l-1,z)$）。

那么现在的问题就是：如何多次求$[1,u]$到$v$的贡献？

很sb的想法是把$1$到$u$的所有点都把它到根路径上的点+1，然后$v$直接一起查询。这是一个$O(N^2\log^2N)$的做法，非常sb。

然后我们注意到$[1,u]$和$[1,u+1]$是有很多公共部分的，如果我们查询完了$(u,v_1)$，不必把标记清空，而是可以直接往上打一个$u+1$的修改然后直接查询$(u+1,v_2)$。

所以得到下面的流程：

- 把询问$(u,v)$离线并按$u$排个序

- 处理完所有的$(u,v_1),(u,v_2),(u,v_3),\dots$不把$u$的标记擦掉（当然也不把其他的标记擦掉），直接往上打一个$u+1$对应的修改，然后处理$(u+1,v)$

于是就得到一个$O(N\log^2N)$的做法了。如果把树剖的线段树换成主席树还可以在线。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;

int N,M;
int lnk[50005];
int pre[50005],tgt[50005],cnt;
void add_E(int u,int v){
	pre[++cnt]=lnk[u],tgt[cnt]=v,lnk[u]=cnt;
}

int fa[50005],son[50005],s[50005],dep[50005];
int top[50005],seg[50005],rev[50005],idx;
void dfs1(int x){
	s[x]=1;dep[x]=dep[fa[x]]+1;
	for(int e=lnk[x];e;e=pre[e]){
		dfs1(tgt[e]),s[x]+=s[tgt[e]];
		if(s[tgt[e]]>s[son[x]]) son[x]=tgt[e];
	}
}
void dfs2(int x){
	seg[x]=++idx;rev[idx]=x;
	if(son[x]) top[son[x]]=top[x],dfs2(son[x]);
	for(int e=lnk[x];e;e=pre[e])if(tgt[e]!=son[x])
		top[tgt[e]]=tgt[e],dfs2(tgt[e]);
}

int ANS[100005];
struct Qs{
	int u,v,pos;
	bool operator <(const Qs b)const{return u<b.u;}
}Q[100005];

int Sum[200005],Lzy[200005];
void push_up(int x){Sum[x]=Sum[x<<1]+Sum[x<<1|1];}
void push_down(int x,int l,int r){
	int mid=(l+r)>>1;
	Sum[x<<1]+=1LL*(mid-l+1)*Lzy[x]%201314;
	Lzy[x<<1]+=Lzy[x];
	Sum[x<<1|1]+=1LL*(r-mid)*Lzy[x]%201314;
	Lzy[x<<1|1]+=Lzy[x];
	Lzy[x]=0;
}
void Update(int x,int l,int r,int L,int R){
	if(L<=l&&r<=R){Sum[x]+=r-l+1;Lzy[x]++;return;}
	push_down(x,l,r);
	int mid=(l+r)>>1;
	if(L<=mid) Update(x<<1,l,mid,L,R);
	if(R>mid) Update(x<<1|1,mid+1,r,L,R);
	push_up(x);
}
int Query(int x,int l,int r,int L,int R){
	if(L<=l&&r<=R) return Sum[x];
	push_down(x,l,r);
	int mid=(l+r)>>1,ans=0;
	if(L<=mid) ans+=Query(x<<1,l,mid,L,R);
	if(R>mid) ans+=Query(x<<1|1,mid+1,r,L,R);
	push_up(x);
	return ans;
}

void Chain_Update(int x){
	while(x){
		Update(1,1,N,seg[top[x]],seg[x]);
		x=fa[top[x]];
	}
}
int Chain_Query(int x){
	int ans=0;
	while(x){
		ans+=Query(1,1,N,seg[top[x]],seg[x]);
		x=fa[top[x]];
	}
	return ans;
}

int now_id=1;

int main(){
	scanf("%d%d",&N,&M);
	fa[1]=0;
	for(int i=2;i<=N;i++) scanf("%d",&fa[i]),add_E(++fa[i],i);
	dfs1(1);top[1]=1;dfs2(1);
	for(int i=1;i<=M;i++){
		int l,r,z;scanf("%d%d%d",&l,&r,&z);
		l++;r++;z++;
		Q[2*i-1].u=r,Q[2*i-1].v=z,Q[2*i-1].pos=2*i-1;
		Q[2*i].u=l-1,Q[2*i].v=z,Q[2*i].pos=2*i;
	}
	sort(Q+1,Q+2*M+1);
	while(Q[now_id].u==0&&now_id<=2*M){
		int tmp=Chain_Query(Q[now_id].v);
		if(Q[now_id].pos&1) ANS[(Q[now_id].pos+1)>>1]+=tmp;
		else ANS[(Q[now_id].pos+1)>>1]-=tmp;
		now_id++;
	}
	for(int i=1;i<=N;i++){
		Chain_Update(i);
		while(Q[now_id].u==i&&now_id<=2*M){
			int tmp=Chain_Query(Q[now_id].v);
			if(Q[now_id].pos&1) ANS[(Q[now_id].pos+1)>>1]+=tmp;
			else ANS[(Q[now_id].pos+1)>>1]-=tmp;
			now_id++;
		}
	}
	for(int i=1;i<=M;i++) printf("%d\n",(ANS[i]%201314+201314)%201314);
	
	return 0;
}

```


---

## 作者：奇米 (赞：20)

## 题解- $P4211\ \ [LNOI2014]LCA$

* 窝$tcl$，调了个上午发现被傻逼错误困扰，总算调出来了。$qwq$

* **题目意思**
	
    题面很小清新：就是求$\sum_{i=l}^{r} dep(LCA(i,z))$
    
* $sol$

	**前置知识：树链剖分+差分**
    
    考虑离线。
    
    我们首先可以把题目意思转换为：每次把询问区间$[l,r]$里的点到根节点路径上的点权值（包括自己）加一，最后询问$z$到根节点的权值和。我们可以画张图来理解这个转换。
    
    ![](https://cdn.luogu.com.cn/upload/image_hosting/pgjhqn4x.png?x-oss-process=image/resize,m_lfit,h_200,w_265)
    
    这样就和好理解了。那我们如何来处理这个询问呢。于是我们很自然地会想到差分，即把$[l,r]$拆成$[1,r],[1,l)$。那我们怎么实现这个差分呢？我们只需要在$l-1$点上打上标记（即代码中的$flg$），只要$[1,r]-[1,l)$即可。区间加等操作我们可以用树链剖分套个线段树来求解~~（这很套路的）~~。
    
    时间复杂度：$O(n \log^2 n)$可以过得。
    

* $Code$

```cpp

#include <bits/stdc++.h>
#define int long long
using namespace std;

inline int read()
{
	int sum=0,ff=1; char ch=getchar();
	while(!isdigit(ch))
	{
		if(ch=='-') ff=-1;
		ch=getchar();
	}
	while(isdigit(ch))
		sum=sum*10+(ch^48),ch=getchar();
	return sum*ff;
}

const int N=2e5+5;
const int mod=201314;

int n,m,cnt,head[N],id[N],top[N];
int son[N],laz[N<<2],tr[N<<2],res[N];
int ans,tot,f[N],dep[N],siz[N],all;

struct nood
{
	int nex,to;
};
nood e[N<<1];

struct question
{
	int pos,z,id,flg;
	inline bool friend operator < (const question &b,const question &c)
	{
		return b.pos<c.pos;
	}
};
question q[N<<1];

inline void jia(int u,int v)
{
	e[++cnt].nex=head[u];
	head[u]=cnt;
	e[cnt].to=v;
}

inline void dfs(int u,int fa)
{
	dep[u]=dep[fa]+1;
	siz[u]=1;
	f[u]=fa;
	for ( int i=head[u];i;i=e[i].nex )
	{
		int v=e[i].to;
		if(v==fa) continue;
		dfs(v,u);
		siz[u]+=siz[v];
		if(siz[v]>siz[son[u]]) 
			son[u]=v;
	}
}

inline void dfs2(int u,int tp)
{
	id[u]=++tot;
	top[u]=tp;
	if(son[u]) dfs2(son[u],tp);
	for ( int i=head[u];i;i=e[i].nex )
	{
		int v=e[i].to;
		if(v==f[u]||v==son[u]) continue;
		dfs2(v,v);
	}
}

inline void push_down(int rt,int l,int r)
{
    if(laz[rt])
	{
		laz[rt<<1]+=laz[rt];
		laz[rt<<1|1]+=laz[rt];
		int mid=(l+r)/2;
		tr[rt<<1]+=(mid-l+1)*laz[rt];
		tr[rt<<1|1]+=(r-mid)*laz[rt];
        laz[rt]=0;
    }
}

inline void update(int rt,int l,int r,int ll,int rr)
{
    if(ll<=l && rr>=r) 
    {
    	laz[rt]+=1ll;
    	tr[rt]+=(r-l+1);
    	return;
    }
    push_down(rt,l,r);
    int mid=(l+r)/2;
    if(ll<=mid) update(rt<<1,l,mid,ll,rr);
    if(rr>mid) update(rt<<1|1,mid+1,r,ll,rr); 
    tr[rt]=(tr[rt<<1]+tr[rt<<1|1]);
}

inline int query(int rt,int l,int r,int ll,int rr)
{
    if(ll<=l && rr>=r) return tr[rt];
    push_down(rt,l,r);
    int mid=(l+r)/2;
    int ans=0;
    if(ll<=mid) ans+=query(rt<<1,l,mid,ll,rr);
    if(rr>mid) ans+=query(rt<<1|1,mid+1,r,ll,rr); 
    return ans;
}


inline void modify(int u,int v)
{
    while(top[u]!=top[v])
	{
        if(dep[top[u]]<dep[top[v]]) swap(u,v);
        update(1,1,n,id[top[u]],id[u]);
        u=f[top[u]];
    }
    if(dep[u]>dep[v]) swap(u,v);
    update(1,1,n,id[u],id[v]);
}

inline int qsum(int u,int v)
{
    int ans=0 ;
    while(top[u]!=top[v])
	{
        if(dep[top[u]]<dep[top[v]]) swap(u,v);
        ans+=query(1,1,n,id[top[u]],id[u]);
        ans=(ans+mod)%mod;
        u=f[top[u]];
    }
    if(dep[u]>dep[v]) swap(u,v);
    ans=(ans+query(1,1,n,id[u],id[v]))%mod;
    return ans;
}
//树链剖分套线段树

signed main()
{
//	freopen("mx.in","r",stdin);
//	freopen("my.out","w",stdout);
	n=read();
	m=read();
	f[1]=1,dep[1]=0,siz[0]=0;
	for ( int i=2;i<=n;++i )
	{
		int u=read()+1;
        //+1更加好处理
        jia(u,i);
        jia(i,u);
    }
	dfs(1,0);
	dfs2(1,0);
	for ( int i=1;i<=m;i++ )
	{
		int l=read()+1;
		int r=read()+1;
		int z=read()+1;
        q[all++]=(question){l-1,z,i,0};
        //对l-1进行标记
        q[all++]=(question){r,z,i,1};
    }
    sort(q,q+all);
    int cur =1;
    for( int i=0;i<all;++i)
	{
        while(cur<=q[i].pos) modify(1,cur++);
        if(q[i].flg) res[q[i].id]+=qsum(1,q[i].z);
        else res[q[i].id]-=qsum(1,q[i].z);
        res[q[i].id]+=mod;
        res[q[i].id]%=mod;
    }
    for ( int i=1;i<=m;++i)
        printf("%lld\n",res[i]);
    return 0;
}
/*
5 2
0
0
1
1
1 4 3
1 4 2
*/ 
```

    

---

## 作者：xianggl (赞：16)

主流做法是离线树剖

但是，事实上，此题的 dep 可以换成以 LCA 为自变量的任意函数

并且在线回答

具体想法是点分树

然后考虑经过 $u$ 的一条路径

我们注意到，$u$ 并不一定是这些路径的 LCA，那么分类讨论

若 $LCA(x, u) = u$

这个时候我们可以认为 $x \to u$ 这条路径是上升的

那么 LCA 一定是在 $u \to y$ 这条路径上

我们就可以处理出所有点分树子树内的点到分治中心的 LCA，把它们的值做一个前缀和，查询时二分

否则

LCA 被 $x \to u$ 这条路径取到了

我们就看分治中心在点分树上的子树内有多少个点在范围内，再乘以 $val[LCA(x,u)]$
 
代码

```
#include <bits/stdc++.h>
#define ri register int
#define ll long long
using namespace std;
const int Maxn=5e4;
const int Mod=201314;
struct Node {
	int u,x;
	inline bool operator<(const Node b) const {
		return u<b.u;
	}
};
vector<Node>node[2][2*Maxn+5];
vector<int>sum[2][2*Maxn+5];
int st[2*Maxn+5][25],dep[Maxn+5],lg[2*Maxn+5],pos[Maxn+5],vt;
int father[Maxn+5],size[Maxn+5],mx[Maxn+5],vis[Maxn+5];
int lt[Maxn+5],nt[2*Maxn+5],ed[2*Maxn+5],cnt;
int n,m;
int swaper;
inline void myswap(int &x,int &y) {
	swaper=x,x=y,y=swaper;
}
inline int mymax(int x,int y) {return x>y?x:y;}
inline int check(int x,int y) {return dep[x]<dep[y]?x:y;}
inline void addedge(int x,int y) {
	ed[++cnt]=y;nt[cnt]=lt[x];lt[x]=cnt;
}
void dfs_euler(int u,int fa) {
	dep[u]=dep[fa]+1,st[++vt][0]=u,pos[u]=vt;
	for(ri i=lt[u];i;i=nt[i]) {
		int v=ed[i];
		if(v!=fa) {
			dfs_euler(v,u);
			st[++vt][0]=u;
		}
	}
}
inline int lca(int x,int y) {
	int l=pos[x],r=pos[y];
	if(l>r)myswap(l,r);
	int t=lg[r-l+1];
	return check(st[l][t],st[r-(1<<t)+1][t]);
}
void calc_st() {
	lg[0]=-1;
	for(ri i=1;i<=vt;i++)lg[i]=lg[i>>1]+1;
	for(ri j=1;j<=lg[vt];j++)
		for(ri i=1;i<=vt-(1<<j)+1;i++)st[i][j]=check(st[i][j-1],st[i+(1<<j-1)][j-1]);
}
int dfs1(int u,int fa) {
	int ret=1;
	for(ri i=lt[u];i;i=nt[i]) {
		int v=ed[i];
		if(!vis[v]&&v!=fa) {
			ret+=dfs1(v,u);
		}
	}
	return ret;
}
int dfs2(int u,int fa,int tot) {
	size[u]=1;mx[u]=0;
	int ret=0;
	for(ri i=lt[u];i;i=nt[i]) {
		int v=ed[i];
		if(!vis[v]&&v!=fa) {
			int x=dfs2(v,u,tot);
			if(mx[x]<mx[ret])ret=x;
			mx[u]=mymax(mx[u],size[v]); 
			size[u]+=size[v];
		}
	}
	mx[u]=mymax(mx[u],tot-size[u]);
	if(mx[u]<mx[ret])ret=u;
	return ret;
}
void dfs3(int rt,int u,int fa) {
	node[0][rt].push_back((Node){u,lca(u,rt)});
	sum[0][rt].push_back(0);
	if(father[rt]) {
		node[1][rt].push_back((Node){u,lca(u,father[rt])});
		sum[1][rt].push_back(0);
	}
	for(ri i=lt[u];i;i=nt[i]) {
		int v=ed[i];
		if(!vis[v]&&v!=fa)dfs3(rt,v,u);
	}
}
inline void newnode(int u) {
	node[0][u].push_back((Node){0,0});
	node[1][u].push_back((Node){0,0});
	sum[0][u].push_back(0);
	sum[1][u].push_back(0);
}
inline void calc(int u) {
	sort(node[0][u].begin(),node[0][u].end());
	for(ri i=1;i<(int)node[0][u].size();i++) {
		sum[0][u][i]=(sum[0][u][i-1]+dep[node[0][u][i].x])%Mod;
	}
	sort(node[1][u].begin(),node[1][u].end());
	for(ri i=1;i<(int)node[1][u].size();i++) {
		sum[1][u][i]=(sum[1][u][i-1]+dep[node[1][u][i].x])%Mod;
	}
}
void solve(int u,int fa) {
	int tot=dfs1(u,0);
	u=dfs2(u,0,tot);
	father[u]=fa;
	newnode(u);
	dfs3(u,u,0);
	calc(u);
	vis[u]=1;
	for(ri i=lt[u];i;i=nt[i]) {
		int v=ed[i];
		if(!vis[v])solve(v,u);
	}
}
inline int getpos(int op,int u,int x) {
	int l=1,r=(int)node[op][u].size()-1;
	while(l<=r) {
		int mid=(l+r)>>1;
		if(node[op][u][mid].u>x)r=mid-1;
		else l=mid+1;
	}
	return r;
}
inline int query_num(int op,int u,int l,int r) {
	return getpos(op,u,r)-getpos(op,u,l-1);
}
inline int query_sum(int op,int u,int l,int r) {
	return sum[op][u][getpos(op,u,r)]-sum[op][u][getpos(op,u,l-1)];
}
inline int query(int l,int r,int x) {
	int lst=0,ans=0;
	for(ri i=x;i;i=father[i]) {
		int t=lca(x,i);
		if(t==i) {
			ans+=query_sum(0,i,l,r),ans%=Mod;
			if(lst)ans-=query_sum(1,lst,l,r),ans=(ans+Mod)%Mod;
		}
		else {
			ans+=1ll*dep[t]*query_num(0,i,l,r)%Mod,ans%=Mod;
			if(lst)ans-=1ll*dep[t]*query_num(1,lst,l,r)%Mod,ans=(ans+Mod)%Mod;
		}
		lst=i;
	}
	return ans;
}
int main() {
	scanf("%d%d",&n,&m);
	for(ri i=2;i<=n;i++) {
		int f;
		scanf("%d",&f);
		++f;
		addedge(f,i);
		addedge(i,f);
	}
	dfs_euler(1,0);
	calc_st();
	mx[0]=n+1;
	solve(1,0);
	while(m--) {
		int l,r,x;
		scanf("%d%d%d",&l,&r,&x);
		++l,++r,++x;
		printf("%d\n",query(l,r,x));
	}
	return 0;
}
```


---

## 作者：nekko (赞：15)

~~（听说只能离线）~~显然这道题可以做到强制在线……

时间复杂度是 $O((n+q) \log^2 n)$

~~由于懒得分类讨论，在此只提供离线做法，在线做法类似，加上了查询的点和查询区间的虚树的位置关系讨论~~

今天上午做题做到了一个奇奇怪怪的题：[【2018 12月集训 Day2】小奇的危机](https://www.cnblogs.com/KingSann/articles/10118697.html)

如果发现询问某个点与编号在某段区间内的点产生一些单独的贡献后统计一些信息的话，不妨考虑线段树分治套虚树

对于每一个查询直接拆分成 $O(\log n)$ 个区间进行查询

也就是说现在问题转化成了给定编号在 $[L,R]$ 的点（特殊点），和若干个关于这些点的询问点，求这些询问点与这些特殊点的最近公共祖先的深度之和

显然这个就是建虚树后上面跑树上动规，然后就做完了

~~常数感人~~

``` cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll; 

const int N = 100000 + 10;

struct FastIO {
    static const int S = 1e7;
    int wpos;
    char wbuf[S];
    FastIO() : wpos(0) {}
    inline int xchar() {
        static char buf[S];
        static int len = 0, pos = 0;
        if (pos == len)
            pos = 0, len = fread(buf, 1, S, stdin);
        if (pos == len) exit(0);
        return buf[pos++];
    }
    inline int operator () () {
        int c = xchar(), x = 0;
        while (c <= 32) c = xchar();
        for (; '0' <= c && c <= '9'; c = xchar()) x = x * 10 + c - '0';
        return x;
    }
    inline ll operator ! () {
        int c = xchar(); ll x = 0;
        while (c <= 32) c = xchar();
        for (; '0' <= c && c <= '9'; c = xchar()) x = x * 10 + c - '0';
        return x;
    }
    inline void wchar(int x) {
        if (wpos == S) fwrite(wbuf, 1, S, stdout), wpos = 0;
        wbuf[wpos++] = x;
    }
    inline void operator () (ll x) {
        if (x < 0) wchar('-'), x = -x;
        char s[24];
        int n = 0;
        while (x || !n) s[n++] = '0' + x % 10, x /= 10;
        while (n--) wchar(s[n]);
        wchar('\n');
    }
    inline void space(ll x) {
        if (x < 0) wchar('-'), x = -x;
        char s[24];
        int n = 0;
        while (x || !n) s[n++] = '0' + x % 10, x /= 10;
        while (n--) wchar(s[n]);
        wchar(' ');
    }
    inline void nextline() {
        wchar('\n');
    }
    ~FastIO()
    {
        if (wpos) fwrite(wbuf, 1, wpos, stdout), wpos = 0;
    }
} io;

int n, q; 

int _head[N], _rest[N * 2], _to[N * 2];
void lk(int u, int v) {
    static int tot = 0;
    _to[++ tot] = v, _rest[tot] = _head[u], _head[u] = tot;
    _to[++ tot] = u, _rest[tot] = _head[v], _head[v] = tot;
}

struct T {
    int id, x;
};

vector<T> que[N * 10];

#define lc (id << 1)
#define rc (id << 1 | 1)
void poi(int id, int l, int r, int ql, int qr, T t) {
    int mid = (l + r) >> 1;
    if(ql <= l && r <= qr) {
        que[id].push_back(t);
    } else if(qr <= mid) {
        poi(lc, l, mid, ql, qr, t);
    } else if(ql >= mid + 1) {
        poi(rc, mid + 1, r, ql, qr, t);
    } else {
        poi(lc, l, mid, ql, mid, t);
        poi(rc, mid + 1, r, mid + 1, qr, t);
    }
}

int ans[N], beg_dfn[N], end_dfn[N], clk, dep[N], len[N];
int fa[N][21];

int getlca(int u, int v) {
    if(dep[u] < dep[v]) swap(u, v);
    for(int i = 20 ; ~ i ; -- i)
        if(dep[fa[u][i]] >= dep[v])
            u = fa[u][i];
    if(u == v) return u;
    for(int i = 20 ; ~ i ; -- i)
        if(fa[u][i] != fa[v][i])
            u = fa[u][i], v = fa[v][i];
    return fa[u][0];
}

void getdfn(int u, int fa) {
    :: fa[u][0] = fa;
    for(int i = 1 ; i <= 20 ; ++ i)
        :: fa[u][i] = :: fa[:: fa[u][i - 1]][i - 1];
    
    beg_dfn[u] = ++ clk;
    dep[u] = dep[fa] + 1;
    for(int i = _head[u] ; i ; i = _rest[i]) {
        int v = _to[i];
        if(v == fa) continue;
        getdfn(v, u);
    }
    end_dfn[u] = clk;
}

int a[N * 10], top, root, spe[N];
int cmp(int x, int y) { return beg_dfn[x] < beg_dfn[y]; }

const int inf = 0x3f3f3f3f;

int head[N], rest[N * 2], to[N * 2], tot;

int thev[N], the_top;

ll f[N], h[N], fafa[N];

ll cnt[N], sum[N], sz[N];

namespace TreeDP {
    void dfs(int u, int fa) {
        sz[u] = 0;
        if(spe[u]) {
            sz[u] ++;
        }
        for(int i = head[u] ; i ; i = rest[i]) {
            int v = to[i];
            if(v == fa) continue;
            dfs(v, u);
            sz[u] += sz[v];
        }
        fafa[u] += sz[u] * dep[u];
    }
    
    void go(int u, int fa) {
        
        fafa[u] += f[u];
        
        int cnt = 0;
        if(spe[u]) ++ cnt;
        
        the_top = 0;
        for(int i = head[u] ; i ; i = rest[i]) {
            int v = to[i];
            if(v == fa) continue;
            thev[++ the_top] = v;
            cnt += sz[v];
        }
        
        for(int i = 1 ; i <= the_top ; ++ i) {
            int v = thev[i];
            f[v] = f[u] + (ll) (cnt - sz[v]) * dep[u];
        }
        
        for(int i = head[u] ; i ; i = rest[i]) {
            int v = to[i];
            if(v == fa) continue;
            go(v, u);
        }
    }
    
    void sol(int root) {
        dfs(root, 0);
        go(root, 0);
    }
}

void add(int u, int v) {
    to[++ tot] = v, rest[tot] = head[u], head[u] = tot;
    to[++ tot] = u, rest[tot] = head[v], head[v] = tot;
}

int sta[N], statop;

void dfs(int id, int l, int r) {
    int mid = (l + r) >> 1;
    
    if(que[id].size()) {
        top = 0;
        for(int i = l ; i <= r ; ++ i) {
            a[++ top] = i;
            spe[i] = 1;
        }
        for(T t: que[id]) {
            a[++ top] = t.x;
        }
        sort(a + 1, a + 1 + top, cmp);
        top = unique(a + 1, a + 1 + top) - a - 1;
        
        for(int i = top ; i >= 2 ; -- i)
            a[++ top] = getlca(a[i], a[i - 1]);
        sort(a + 1, a + 1 + top, cmp);
        top = unique(a + 1, a + 1 + top) - a - 1;
        
        tot = 0;
        for(int i = 1 ; i <= top ; ++ i) {
            head[a[i]] = 0;
            fafa[a[i]] = 0;
            f[a[i]] = 0;
        }
        root = a[1];
        
        statop = 0;
        for(int i = 1 ; i <= top ; ++ i) {
            int u = a[i];
            while(statop && end_dfn[sta[statop]] < beg_dfn[u]) -- statop;
            if(statop) {
                add(sta[statop], u);
            }
            sta[++ statop] = u;
        }
        
        TreeDP :: sol(root);
        
        for(T t: que[id]) {
            int ansid = t.id, u = t.x;
            ans[ansid] += fafa[u];
        }
        
        for(int i = l ; i <= r ; ++ i) spe[i] = 0;
    }
    if(l != r) dfs(lc, l, mid), dfs(rc, mid + 1, r);
}

int main() {
    
//    freopen("data.in", "r", stdin);
//    freopen("data.out", "w", stdout);
    
    n = io(), q = io();
    for(int i = 2 ; i <= n ; ++ i) {
        lk(io() + 1, i);
    }
    getdfn(1, 0);
    
    for(int i = 1, l, r, x ; i <= q ; ++ i) {
        l = io() + 1, r = io() + 1, x = io() + 1;
        poi(1, 1, n, l, r, (T) { i, x });
    }
    
    dfs(1, 1, n);
    for(int i = 1 ; i <= q ; ++ i) {
        io(ans[i] % 201314);
    }
}
```

---

## 作者：ljk123 (赞：10)

# LCA题解

神奇化简题，谁看得出这是树剖。

首先，$lca$的祖宗对$lca$都有贡献，我们不妨将$0$到$lca$路径的权值都加$1$，则$lca$的$deep$就为$0$到$lca$的路径权值和

则$\sum_{i=l}^{r}deep[lca_{i}]=\sum_{i=l}^{r}\sum_{j=lca_{i}}^{j\epsilon path(0,lca_{i})}w[j]$

我们想想在不会$lca$的时候如何暴力搞两个点$x$和$y$的l$ca$？

我们可以明确深度大于$lca$的点对于$lca$不会有贡献,且$deep[x]>=deep[lca]$

不妨将我们不妨将$0$到$x$路径的权值都加$1$，$deep[lca]=\sum_{i=y}^{i\epsilon path(0,y)}w[i]$

~~感性理解一下吧~~

如此我们需要枚举$i$从$l$到$r$,将$0$到$i$路径的权值都加$1$,$\sum_{i=l}^{r}deep[lca(i,z)]=\sum_{i=z}^{i\epsilon path(0,z)}w[i]$

这样一次查询时间复杂度为$O(n*logn*logn)$

有$q$次询问。

我们想，每一次询问都把线段树清空太浪费了，区间$[l,r]$可以差分为$[1,r]-[1,l-1]$

将询问拆成$[1,l-1]$和$[1,r]$两部分,按右端点排序即可.

###代码：

```cpp
#include<bits/stdc++.h>
#define lc (x<<1)
#define rc (x<<1|1) 
using namespace std;
const int N=60006,inf=1e9,mod=201314;
int n,m,t1,t2,t3,cnt=0,dfn=0,tot=0,f[N],a[N],d[N],son[N],siz[N],num[N],top[N],lazy[N<<2],w[N<<2],head[N],ans[N];
struct xd{int i,flag,x,y;}q[N<<1];
struct edge{int nxt,to;}e[N<<1];
inline void add(int u,int v){e[++cnt].nxt=head[u],e[cnt].to=v,head[u]=cnt;}
inline int read(){
   int T=0,F=1; char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-') F=-1; ch=getchar();}
   while(ch>='0'&&ch<='9') T=(T<<3)+(T<<1)+(ch-48),ch=getchar();
   return F*T;
}
void dfs(int x){
     d[x]=d[f[x]]+1,siz[x]=1; int maxt=0,maxa=-1;
     for(int i=head[x];i;i=e[i].nxt){
            dfs(e[i].to),siz[x]+=siz[e[i].to];
            if(maxa<siz[e[i].to]) maxt=e[i].to,maxa=siz[maxt];
         } 
     son[x]=maxt;
}
void dfs2(int x,int topx){
     num[x]=++dfn,top[x]=topx; 
     if(son[x]) dfs2(son[x],topx);
     for(int i=head[x];i;i=e[i].nxt) if(e[i].to!=f[x]&&e[i].to!=son[x]) dfs2(e[i].to,e[i].to); 
}
void pushdown(int x,int len){if(lazy[x]) lazy[lc]=(lazy[lc]+lazy[x])%mod,lazy[rc]=(lazy[rc]+lazy[x])%mod,w[lc]=(w[lc]+lazy[x]*(len-(len>>1))%mod)%mod,w[rc]=(w[rc]+lazy[x]*(len>>1)%mod)%mod,lazy[x]=0;}
void update(int l,int r,int p,int q,int x,int y){
     if(p<=l&&r<=q){w[x]=(w[x]+(r-l+1)*y%mod)%mod,lazy[x]=(lazy[x]+y)%mod; return;}
     pushdown(x,r-l+1);
     int mid=l+r>>1;
     if(p<=mid) update(l,mid,p,q,lc,y);
     if(q>mid) update(mid+1,r,p,q,rc,y);
     w[x]=(w[lc]+w[rc])%mod;
}
int query(int l,int r,int p,int q,int x){
     if(p<=l&&r<=q) return w[x];
     pushdown(x,r-l+1);
     int mid=l+r>>1,ans=0;
     if(p<=mid) ans=query(l,mid,p,q,lc);
     if(q>mid) ans=(ans+query(mid+1,r,p,q,rc))%mod;
     return ans;
}
void lj_update(int x,int y){
    while(top[x]!=top[y]){
         if(d[top[x]]<d[top[y]]) swap(x,y);
         update(1,n,num[top[x]],num[x],1,1);
         x=f[top[x]];
    }
    if(d[x]>d[y]) swap(x,y);
    update(1,n,num[x],num[y],1,1); 
}
int lj_query(int x,int y){
    int ans=0;
    while(top[x]!=top[y]){
         if(d[top[x]]<d[top[y]]) swap(x,y);
         ans=(ans+query(1,n,num[top[x]],num[x],1))%mod;
         x=f[top[x]];
    }
    if(d[x]>d[y]) swap(x,y);
    ans=(ans+query(1,n,num[x],num[y],1))%mod; 
    return ans;
}
bool cmp(xd u,xd v){return u.x<v.x;}
int main(){
    n=read(),m=read();
    for(int i=2;i<=n;++i) f[i]=read()+1,add(f[i],i);
    dfs(1),dfs2(1,1);
    for(int i=1;i<=m;++i){
        t1=read(),t2=read()+1,t3=read()+1;
        q[++tot].flag=0,q[tot].i=i,q[tot].x=t1,q[tot].y=t3;
        q[++tot].flag=1,q[tot].i=i,q[tot].x=t2,q[tot].y=t3; 
    }
    sort(q+1,q+tot+1,cmp),q[0].x=0;
    for(int i=1;i<=tot;++i){
        for(int j=q[i-1].x+1;j<=q[i].x;++j)
            lj_update(1,j);
        if(!q[i].flag) ans[q[i].i]=-lj_query(1,q[i].y);
        else ans[q[i].i]=(ans[q[i].i]+lj_query(1,q[i].y)+mod)%mod;
    }
    for(int i=1;i<=m;++i) printf("%d\n",ans[i]);
    return 0;
}  
```

---

## 作者：King_of_gamers (赞：8)

~~十分激动啊,又过了个黑题~~

我们可以发现,当我们把l~r的点往根节点的权值+1后,与z的lca深度之和就是z到根节点的权值之和.那么这是为什么呢?

对于l<=i<=r,我们假设lca是i与z的lca,那么对答案的贡献就是lca的深度也是lca到根节点的长度,所以我们就可以把这个问题转化为树剖+线段树维护了

可是如果对于每个询问我们先把每个i加入线段树最后求答案时间复杂度是O($N^2logn^2$),这样显然不对.但是我们发现其实l~r对于z的答案显然满足差分的性质,于是就可以把它转化成1~r对于z的答案-1~(l-1)对于z的答案.所以就可以解决了.

下附代码:
```cpp
#include<bits/stdc++.h>
using namespace std;
int tot,tim,n,q;
int size[50005],head[50005],head2[50005],nex[200005],flag[200005],id[200005],go[200005],dfn[50005],maxson[50005],top[50005],t[2000005],lazy[2000005],fa[50005],x[50005],y[50005],z[50005],wri[50005];
void add(int u,int v)//链式前向星存图
{
	tot++;
	nex[tot]=head[u];
	head[u]=tot;
	go[tot]=v;
}
void add2(int u,int v,int w,int p)//把p的询问信息加入1~u中
{
	tot++;
	nex[tot]=head2[u];
	head2[u]=tot;
	go[tot]=v;
	flag[tot]=w;
	id[tot]=p;
}
void dfs1(int u)//树剖模板
{
	size[u]=1;
	for (int i=head[u];i>0;i=nex[i])
	{
		int v=go[i];
		dfs1(v);
		size[u]=size[u]+size[v];
		if (size[v]>size[maxson[u]]) maxson[u]=v;
	}
}
void dfs2(int u)
{
	tim++;
	dfn[u]=tim;
	if (maxson[u]!=0)
	{
		top[maxson[u]]=top[u];
		dfs2(maxson[u]);
	}
	for (int i=head[u];i>0;i=nex[i])
	{
		int v=go[i];
		if (v!=maxson[u])
		{
			top[v]=v;
			dfs2(v);
		}
	}
}
void add(int x,int y,int l,int r,int k)//区间加线段树
{
	t[k]=t[k]+(y-x+1);
	if (t[k]>=201314) t[k]=t[k]-201314;
	if ((l==x)&&(r==y))
	{
		lazy[k]=lazy[k]+1;
		if (lazy[k]>=201314) lazy[k]=lazy[k]-201314;
		return;
	}
	int mid=(l+r)>>1;
	if (y<=mid) add(x,y,l,mid,k<<1);
	else
	if (x>mid) add(x,y,mid+1,r,k<<1|1);
	else
	{
		add(x,mid,l,mid,k<<1);
		add(mid+1,y,mid+1,r,k<<1|1);
	}
}
void pushdown(int l,int r,int k)//懒惰标记下放
{
	int mid=(l+r)>>1;
	t[k<<1]=(t[k<<1]+((long long)(mid-l+1)*lazy[k])%201314)%201314;
	t[k<<1|1]=(t[k<<1|1]+((long long)(r-mid)*lazy[k])%201314)%201314;
	lazy[k<<1]=lazy[k<<1]+lazy[k];
	if (lazy[k<<1]>=201314) lazy[k<<1]=lazy[k<<1]-201314;
	lazy[k<<1|1]=lazy[k<<1|1]+lazy[k];
	if (lazy[k<<1|1]>=201314) lazy[k<<1|1]=lazy[k<<1|1]-201314;
	lazy[k]=0;
}
int get(int x,int y,int l,int r,int k)//区间求和线段树
{
	if ((l==x)&&(r==y)) return t[k];
	pushdown(l,r,k);
	int mid=(l+r)>>1;
	if (y<=mid) return get(x,y,l,mid,k<<1);
	else
	if (x>mid) return get(x,y,mid+1,r,k<<1|1);
	else return (get(x,mid,l,mid,k<<1)+get(mid+1,y,mid+1,r,k<<1|1))%201314;
}
int main()
{
	cin>>n>>q;
	for (int i=2;i<=n;i++)
	{
		cin>>fa[i];
		fa[i]++;
		add(fa[i],i);
	}
	for (int i=1;i<=q;i++)
	{
		cin>>x[i]>>y[i]>>z[i];
		x[i]++;
		y[i]++;
		z[i]++;
		add2(x[i]-1,z[i],-1,i);
		add2(y[i],z[i],1,i);
	}
	dfs1(1);
	top[1]=1;
	dfs2(1);
	for (int i=1;i<=n;i++)//算出1~i的答案
	{
		int p=i;
		while (top[p]!=1)
		{
			add(dfn[top[p]],dfn[p],1,n,1);
			p=fa[top[p]];
		}
		add(1,dfn[p],1,n,1);
		for (int j=head2[i];j>0;j=nex[j])//求出所有对于1~i的问题
		{
			int pp=go[j];
			int ans=0;
			while (top[pp]!=1)
			{
				ans=ans+get(dfn[top[pp]],dfn[pp],1,n,1);
				if (ans>=201314) ans=ans-201314;
				pp=fa[top[pp]];
			}
			ans=ans+get(1,dfn[pp],1,n,1);
			if (ans>=201314) ans=ans-201314;
			wri[id[j]]=((wri[id[j]]+flag[j]*ans)%201314+201314)%201314;
		}
	}
	for (int i=1;i<=q;i++)
	cout<<wri[i]<<endl;
}
```

---

## 作者：lalaouye (赞：8)

注意到我们可以利用点分治求出 $z$ 到 $[l,r]$ 的所有点的距离和，并且 $S=\sum_{i=l}^r dep_z+dep_i$ 也是好算的，那么我们根据距离公式，设要算的东西为 $T$，总距离和为 $D$，那么根据 $S-2T=D$，可得 $T=\frac {S-D} {2}$，最后由于题目的深度是距离加一，输出 $T+r-l+1$ 就行了。时间复杂度为点分治复杂度 $\mathcal{O}(n\log^2n)$，不过很遗憾这个做法拓展不到计算 $dep_{LCA(i,z)}^k$。

---

## 作者：Soulist (赞：8)

~~提供一种不优的在线的做法~~

好吧我们还是直接说说这道题怎么做吧。

首先要发现一些性质，比如求一个$LCA$的$dep$其实是询问这个$LCA$上有多少个点$+1$，故一种比较$naive$的想法便出来了 $QAQ$我们可以先进行一个**染色** 操作，让$l-r$的所有点到根节点这一路径上所有点的点权都$+1$

然后再询问这个点$z$到根的路径上的点权和即可。

你发现这样做貌似复杂度不仅不优，如果用树剖来实现这个过程，复杂度比纯暴力$O(n^2logn)$还要差$->O(n^2log^2n)$

然而如果我们离线地搞呢？


---------------

离线做法$1.O(n\sqrt n*log^2n)$

我们类似于莫队的搞法，其实根本不用关心询问点是那里，实际上对于某次询问我们只是想知道树的状态就可以了。

树的状态是怎么改变的？你发现之前的暴力存在一个特别$naive$的过程，每次将$l-r$中所有点到根的路径$+1$后存在一个清空树的过程。然而实际上并不需要，我们将询问按照莫队的方法排序，每次加点的时候将这个点$l/r$到根的路径$+1$，删点就$-1$

--------------------

离线做法$2.O(nlog^2n)$

我们发现这个东西其实是可以差分的，可以考虑将询问拆分成两个询问

$>>l,r,z ->(1,r,z) - (1,l-1,z)$

也就是$l-r$这一系列操作（实际上$l-r$这个区间是一个$+1$操作）后的答案可以看作操作$1-r$后的答案和$[1,l-1]$的答案的差。

实际上如果拆后我们发现根本就不需要关注左区间了（都是1）所以只需要按照右端点排序后处理就行了。

-------------

在线做法$O(nlog^2n)$

类似于离线的做法，我们可以把$l-r$的答案拆成$1-(l-1)$的答案和$1-r$的答案的差。

那么我们接下来的问题就在于如何在线的处理出$1-r$的答案了。

你发现处理$1-r$操作后树的状态是通过许多链修改操作得到的。

然而我们想要查询的其实是某次操作后树的状态。

你想这不就是一个回溯历史版本的操作吗？用主席树啊。

然后你想布星啊，修改不是一条链的修改吗，套上个树剖后即使在主席树上也是许多的区间修改啊 $QAQ$

你想什么时候主席树也能做区间修改了，然而只需要标记永久化就可以了。

如果不会可以点开这个链接看看然后做一做这道[和$shi$蔼$fen$可$gui$亲$chu$的题](https://www.luogu.org/problemnew/show/SP11470)

因为用的主席树+树剖，空间上有点小紧 $O(nlog^2n)$ 

```cpp
#include<bits/stdc++.h>
using namespace std;
int read() {
	char cc = getchar(); int cn = 0, flus = 1;
	while(cc < '0' || cc > '9') cc = getchar();
	while(cc >= '0' && cc <= '9')  cn = cn * 10 + cc - '0', cc = getchar();
	return cn * flus;
}
const int N = 50000 + 5 ;
const int mod = 201314 ;
#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )
#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next )
int n, q, head[N], root[N * 20], rt[N], ant, cnt ; 
struct E {
	int to, next ; 
} e[N * 2];
void add( int x, int y ) {
	e[++ cnt] = (E){ y, head[x] }, head[x] = cnt ; 
}
namespace Tree {
	struct tree {
		int fa, top, size, id, son, dep ;
	}t[N];
	struct Tr {
		int l, r, val, add ; 
	} tr[N * 300];
	int num, b[N * 2], Idnum ;
	#define ls(x) tr[x].l
	#define rs(x) tr[x].r
	inline void build( int &x, int l, int r ) {
		x = ++ num ;
		if( l == r ) return ; 
		int mid = ( l + r ) >> 1 ; 
		build( ls(x), l, mid ), build( rs(x), mid + 1, r ) ;
	}
	inline void Tr_modify( int &x, int u, int l, int r, int ll, int rr, int add ) {
		x = ++ num ; 
		tr[x] = tr[u], tr[x].val += ( rr - ll + 1 ) * add % mod, tr[x].val %= mod ; 
		if( l >= ll && r <= rr ) {
			tr[x].add += add ;
			return ;  
		}
		int mid = ( l + r ) >> 1 ; 
		if( mid >= rr ) Tr_modify( ls(x), ls(u), l, mid, ll, rr, add ) ;
		else if( mid < ll ) Tr_modify( rs(x), rs(u), mid + 1, r, ll, rr, add ) ;
		else Tr_modify( ls(x), ls(u), l, mid, ll, mid, add ), 
		Tr_modify( rs(x), rs(u), mid + 1, r, mid + 1, rr, add ) ;
	}
	inline int Tr_query( int x, int l, int r, int ll, int rr, int add ) {
		if( l > rr || r < ll ) return 0 ;
		if( l >= ll && r <= rr ) return ( tr[x].val + add * ( r - l + 1 ) % mod ) % mod ;
		int mid = ( l + r ) >> 1 ; 
		return ( Tr_query( ls(x), l, mid, ll, rr, add + tr[x].add ) + Tr_query( rs(x), mid + 1, r, ll, rr, add + tr[x].add ) ) % mod ;
	}
	//树链剖分 
	inline void dfs1( int x, int fa ) {
		t[x].fa = fa, t[x].size = 1; 
		t[x].dep = t[fa].dep + 1 ; int s = 0 ;
		Next( i, x ) {
			int v = e[i].to ; 
			if( v == fa ) continue ; 
			dfs1( v, x ), t[x].size += t[v].size ; 
			if( t[v].size > t[s].size ) s = v ; 
		}
		t[x].son = s ; 
	}
	inline void dfs2( int x, int high ) {
		t[x].top = high, t[x].id = ++ Idnum ; b[Idnum] = x ; 
		if( !t[x].son ) return ;
		dfs2( t[x].son, high ) ;
		Next( i, x ) {
			int v = e[i].to ; 
			if( t[v].id ) continue ; 
			dfs2( v, v ) ;
		}
	}
	void modify( int x, int u ) {
		while( t[u].top != 1 ) {
			Tr_modify( root[++ ant], root[ant], 1, n, t[t[u].top].id, t[u].id, 1 ) ;
			u = t[t[u].top].fa ; 
		}
		Tr_modify( root[++ ant], root[ant], 1, n, 1, t[u].id, 1 ) ;
		rt[x] = root[ant] ; 
	}
	int query( int x, int u ) {
		int Ans = 0 ;
		while( t[u].top != 1 ) {
			Ans += Tr_query( rt[x], 1, n, t[t[u].top].id, t[u].id, 0 ) ;
			u = t[t[u].top].fa, Ans %= mod ;
		}
		Ans += Tr_query( rt[x], 1, n, 1, t[u].id, 0 ) ;
		return Ans % mod ; 
	}
	void init() {
		dfs1( 1, 1 ), dfs2( 1, 1 ), build( root[0], 1, n ) ;
		rep( i, 1, n ) {
			modify( i, i ) ;
		}
	}
	int Answer( int x, int y, int u ) {
		int Ans = query( y, u ) - query( x, u ) ; 
		return ( Ans + mod ) % mod ; 
	}
}
signed main()
{
	n = read(), q = read() ; 
	int x, y, z ;  
	rep( i, 2, n ) x = read() + 1, add( x, i ) ; 
	Tree :: init() ;
	rep( i, 1, q ) {
		x = read(), y = read() + 1, z = read() + 1 ; 
		printf("%d\n", Tree::Answer( x, y, z ) ) ;
	}
	return 0;
}
```

---

## 作者：_ctz (赞：5)

[$My\ blog$](https://ctz45562.github.io/2019/09/02/洛谷-P4211-LNOI2014-LCA/)

[传送门](https://www.luogu.org/problem/P4211)

复习物理时突然有了这个题的做法。

~~我也不知道为啥学物理会想到这个~~

一个不用转化、不用扫描线、不用$LCT$树剖的$chuan$新做法：直接分块！

每个块开个$vector$记录询问。

散块直接暴力。

整块把该询问丢进$vector$里。

询问处理完后处理每个块：

记$l,r$为块的左右端点，对每个点$x$算出$\sum\limits_{i=l}^rdeep[lca(i,x)]$，最后把属于该块的每个询问点的贡献加进去即可。

$dfs$一遍树。考虑每个点为$lca$的贡献。记$siz(i)$为$i$子树中编号在$[l,r]$的点的个数。

点$i$会对其整棵子树有$deep(i)\times siz(i)$的贡献，然后对其每个儿子$x$，要容斥减去$deep(i)\times siz(x)$的不合法贡献。

子树加，$dfs$序+差分即可。

空间$O(n\sqrt{n})$，用$O(1)LCA$的话时间为$O(n\sqrt{n})$。

用$Tarjan\ LCA$被卡空间了用树剖$LCA$被卡时间了被迫现学的$RMQ\ LCA$，~~做LCA题学LCA没毛病~~

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <vector>

#define maxn 50005
#define inf 0x3f3f3f3f

const int mod = 201314;

using namespace std;

inline int read(){
	int x=0,y=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return y?-x:x;
}
int siz[maxn],h[maxn],seg[maxn],pos[maxn],low[maxn],deep[maxn]={inf,1},num,cnt;
int be[maxn],a[maxn],ans[maxn],f[maxn<<1][22],fir[maxn],lg[maxn<<1],all;
struct edge{
	int pre,to;
}e[maxn];
inline int cmp(int x,int y){return deep[x]<deep[y]?x:y;}
inline void add(int from,int to){
	e[++num].pre=h[from],h[from]=num,e[num].to=to;
}
void dfs(int node=1){
	f[fir[node]=++all][0]=pos[seg[node]=++cnt]=node;
	int x;
	for(register int i=h[node];i;i=e[i].pre){
		x=e[i].to,deep[x]=deep[node]+1,dfs(x);
		f[++all][0]=node;
	}
	low[node]=cnt;
}
void ST(){
	for(register int i=2;i<=all;++i)lg[i]=lg[i>>1]+1;
	for(register int j=1;j<=lg[all];++j)
		for(register int i=1;i+(1<<(j-1))<=all;++i)
			f[i][j]=cmp(f[i][j-1],f[i+(1<<(j-1))][j-1]);
}
inline int query(int l,int r){
	if(l>r)swap(l,r);
	int len=lg[r-l+1];
	return cmp(f[l][len],f[r-(1<<len)+1][len]);
}
inline int lca(int x,int y){
	return query(fir[x],fir[y]);
}
#define modify(x,d) a[seg[x]]+=d,a[low[x]+1]-=d
#define id(x) (x>=l&&x<=r)
struct BLOCK{
	int l,r;
	vector<pair<int,int> >q;
	void calc(int node=1){
		siz[node]=id(node);
		int x;
		for(register int i=h[node];i;i=e[i].pre){
			x=e[i].to;
			calc(x),siz[node]+=siz[x];
		}
		modify(node,deep[node]*siz[node]);
		for(register int i=h[node];i;i=e[i].pre){
			x=e[i].to;
			modify(x,(-deep[node]*siz[x]));
		}
	}
	void solve(){
		calc();
		for(register int i=1;i<=cnt;++i)a[i]+=a[i-1];
		for(vector<pair<int,int> >::iterator iter=q.begin();iter!=q.end();++iter)
			(ans[iter->second]+=a[iter->first])%=mod;
	}
}b[250];
inline void odd(int l,int r,int x,int p){
	for(register int i=l;i<=r;++i)ans[p]+=deep[lca(i,x)];
}
int main(){
	int n=read(),m=read(),l,r,x,sq=sqrt(n),len=n/sq+bool(n%sq);
	for(register int i=2;i<=n;++i)add(read()+1,i);
	dfs(),ST();
	for(register int i=1;i<=len;++i){
		b[i].l=b[i-1].r+1,b[i].r=min(b[i].l+sq-1,n);
		for(register int j=b[i].l;j<=b[i].r;++j)
			be[j]=i;
	}
	for(register int i=1;i<=m;++i){
		l=read()+1,r=read()+1,x=read()+1;
		if(be[l]==be[r]){odd(l,r,x,i);}
		else {
			odd(l,b[be[l]].r,x,i);
			odd(b[be[r]].l,r,x,i);
			x=seg[x];
			for(register int j=be[l]+1;j<be[r];++j)
				b[j].q.push_back((pair<int,int>){x,i});
		}
	}
	for(register int i=1;i<=len;++i)memset(a,0,sizeof a),b[i].solve();
	for(register int i=1;i<=m;++i)printf("%d\n",(ans[i]%mod+mod)%mod);
}
```








---

## 作者：NeosKnight (赞：4)

辣鸡题目居然不放裸的分块过去,还好我有 O2 优化。
$dep[LCA(u,v)]=\frac{dep[u]+dep[v]-dis(u,v)}{2}$
把序列分块 , 换根dp预处理每一块到任意一个点的距离和。
就没了。
复杂度 $O(n\sqrt n)$

```cpp
#include<bits/stdc++.h>
using namespace std;
template<class T>inline void init(T&x){
	x=0;char ch=getchar();bool t=0;
	for(;ch>'9'||ch<'0';ch=getchar()) if(ch=='-') t=1;
	for(;ch>='0'&&ch<='9';ch=getchar()) x=(x<<1)+(x<<3)+(ch-48);
	if(t) x=-x;return;
}
typedef long long ll;
const int N=5e4+10;
const int mod=201314;
struct edge{int to,next;}a[N<<1];
int head[N],cnt=0;
inline void add(int x,int y){a[++cnt]=(edge){y,head[x]};head[x]=cnt;}
int L,R;
template<class T>inline void Inc(T&x,int y){x+=y;if(x>=mod) x-=mod;}
template<class T>inline void Dec(T&x,int y){x-=y;if(x < 0 ) x+=mod;}
ll size[N],Sum[300][N],S[N],Sd[N];
int bl[N];
int n,m,block,now;
namespace LCA_WORK{
	int st[20][N<<1],I,dfn[N<<1],id[N],log[N<<1],dep[N];
	void dfs(int u,int fa){
		dfn[++I]=u;id[u]=I;st[0][I]=u;
		for(int v,i=head[u];i;i=a[i].next){
			v=a[i].to;if(v==fa) continue;
			dep[v]=dep[u]+1;dfs(v,u);dfn[++I]=u;st[0][I]=u;
		}
		return;
	}
	inline int CK(int u,int v){if(!u||!v) return u|v;return id[u]<id[v]? u:v;}
	void Pre_Work(){dep[1]=1;dfs(1,0);log[1]=0;
		for(int i=2;i<=I;++i) if((1<<log[i-1])<i) log[i]=log[i-1]+1;else log[i]=log[i-1];
		for(int k=1;k<=20;++k)
			for(int i=1;i+(1<<k)-1<=I;++i)
				st[k][i]=CK(st[k-1][i],st[k-1][i+(1<<k-1)]);
		return;
	}
	inline int LCA(int u,int v){
		if(u==v) return u;u=id[u],v=id[v];
		if(u>v) swap(u,v);int D=log[v-u+1]-1;
		return CK(st[D][u],st[D][v-(1<<D)+1]);
	}
	inline int Dis(int u,int v){return (dep[u]+dep[v]-(dep[LCA(u,v)]<<1));}
}using LCA_WORK::dep;using LCA_WORK::LCA;
void dfs(int u,int fa){
	S[u]=0;if(u>=L&&u<=R) size[u]=1;else size[u]=0;
	for(int v,i=head[u];i;i=a[i].next){
		v=a[i].to;if(v==fa) continue;
		dfs(v,u);size[u]+=size[v];S[u]+=S[v]+size[v];
	}
	return;
}
void DP(int u,int fa){
	Sum[now][u]=S[u];
	for(int v,i=head[u];i;i=a[i].next){
		v=a[i].to;if(v==fa) continue;
		ll SS=S[u],Si=size[u];SS-=size[v]+S[v];Si-=size[v];
		S[v]+=SS+Si;size[v]=size[u];DP(v,u);
	}
	return;
}
void Solve(){dfs(1,0);DP(1,0);}
int main()
{
	init(n),init(m);
	block=500;bl[1]=1;
	for(int i=2;i<=n;++i) {
		int f;init(f);++f;
		bl[i]=(i+block-1)/block;
		add(f,i),add(i,f);
	}
	LCA_WORK::Pre_Work();for(int i=1;i<=n;++i) Sd[i]=Sd[i-1]+dep[i];
	for(L=1,R=1;L<=n;L=R+1){while(bl[R+1]==bl[L]) ++R;now=bl[L];Solve();}
	for(int i=1;i<=m;++i) {
		int l,r,z;ll ans=0;
		init(l),init(r),init(z);++l,++r,++z;
		if(bl[l]==bl[r]) {while(l<=r) ans+=dep[LCA(l,z)],++l;printf("%lld\n",ans%mod);}
		else {
			while(bl[l]==bl[l-1]) ans+=dep[LCA(l,z)],++l;
			while(bl[r]==bl[r+1]) ans+=dep[LCA(r,z)],--r;
			if(l>r) {printf("%lld\n",ans%mod);continue;}
			ll ret=Sd[r]-Sd[l-1];ret+=(ll)(r-l+1)*dep[z];l=bl[l],r=bl[r];
			for(;l<=r;++l) ret-=Sum[l][z];ret>>=1;ans+=ret;
			printf("%lld\n",ans%mod);
		}
	}
	return 0;
}


```

---

## 作者：little_sun (赞：2)

可以发现题目可以转化为把从$l$到$r$节点到$1$的路径上的点的点权都加上$1$，然后统计$1$到$z$路径上的点权

然后发现这个东西可以差分。。。

于是我们就把询问拆成$l-1$和$r$,然后按$r$排序

从$1$到$n$把$1$到$i$路径点权全部$+1$

询问时查询$1$到$z$路径点权和

然后就做完了。。。

```cpp
# include <bits/stdc++.h>
const int mod = 201314;
const int MaxN = 100010;
struct edge
{
    int next, to;
};
struct node
{
    int l, r;
    int sum, tag;
};
struct query
{
    int r, z, id;
};
edge e[MaxN << 1];
query q[MaxN << 1];
int n, m, cnt, dfsnum;
int hson[MaxN], fa[MaxN], dfn[MaxN], ans[MaxN];
int head[MaxN], size[MaxN], dep[MaxN], top[MaxN];
struct SegmentTree
{
    node t[MaxN << 2];
    inline void pushup(int id){t[id].sum = t[id << 1].sum + t[id << 1 | 1].sum;}
    inline void build(int id, int l, int r)
    {
        t[id].l = l, t[id].r = r;
        if(l == r)
            return;
        int mid = (l + r) >> 1;
        build(id << 1, l, mid);
        build(id << 1 | 1, mid + 1, r);
    }
    inline void pushdown(int id)
    {
        if(t[id].tag)
        {
            t[id << 1].sum += t[id].tag * (t[id << 1].r - t[id << 1].l + 1);
            t[id << 1 | 1].sum += t[id].tag * (t[id << 1 | 1].r - t[id << 1 | 1].l + 1);
            
            t[id << 1].tag += t[id].tag;
            t[id << 1 | 1].tag += t[id].tag;
            
            t[id].tag = 0;
        }
    }
    inline void modify(int id, int l, int r, int val)
    {
        if(t[id].l > r || t[id].r < l)
            return;
        if(l <= t[id].l && t[id].r <= r)
        {
            t[id].sum += val * (t[id].r - t[id].l + 1);
            t[id].tag += val;
            return;
        }
        pushdown(id);
        modify(id << 1, l, r, val);
        modify(id << 1 | 1, l, r, val);
        pushup(id);
    }
    inline int query(int id, int l, int r)
    {
        if(t[id].l > r || t[id].r < l)
            return 0;
        if(l <= t[id].l && t[id].r <= r)
            return t[id].sum;
        pushdown(id);
        return query(id << 1, l, r) + query(id << 1 | 1, l, r);
    }
}T;
inline int cmp(query a, query b)
{
    return a.r < b.r;
}
inline void add_edge(int u, int v)
{
    ++cnt;
    e[cnt].to = v;
    e[cnt].next = head[u];
    head[u] = cnt;
}
inline void dfs1(int u, int f)
{
    size[u] = 1;
    for(int i = head[u]; i; i = e[i].next)
    {
        int v = e[i].to;
        if(v == f)
            continue;
        dep[v] = dep[u] + 1;
        fa[v] = u;
        dfs1(v, u);
        size[u] += size[v];
        if(size[v] > size[hson[u]])
            hson[u] = v;
    }
}
inline void dfs2(int u, int Top)
{
    ++dfsnum;
    dfn[u] = dfsnum;
    top[u] = Top;
    if(hson[u])
        dfs2(hson[u], Top);
    for(int i = head[u]; i; i = e[i].next)
    {
        int v = e[i].to;
        if(v == fa[u] || v == hson[u])
            continue;
        dfs2(v, v);
    }
}
inline void update_chain(int u, int v)
{
    while(top[u] != top[v])
    {
        if(dep[top[u]] < dep[top[v]])
            std::swap(u, v);
        T.modify(1, dfn[top[u]], dfn[u], 1);
        u = fa[top[u]];
    }
    if(dep[u] < dep[v])
        std::swap(u, v);
    T.modify(1, dfn[v], dfn[u], 1);
}
inline int query_chain(int u, int v)
{
    int ans = 0;
    while(top[u] != top[v])
    {
        if(dep[top[u]] < dep[top[v]])
            std::swap(u, v);
        ans += T.query(1, dfn[top[u]], dfn[u]);
        u = fa[top[u]];
    }
    if(dep[u] < dep[v])
        std::swap(u, v);
    ans += T.query(1, dfn[v], dfn[u]);
    return ans;
}
int main()
{
    scanf("%d%d", &n, &m);
    for(int i = 2; i <= n; i++)
    {
        int u;
        scanf("%d", &u);
        ++u;
        add_edge(i, u);
        add_edge(u, i);
    }
    dep[1] = 1;
    dfs1(1, 0), dfs2(1, 1);
    T.build(1, 1, n);
    for(int i = 1; i <= m; i++)
    {
        int l, r, z;
        scanf("%d%d%d", &l, &r, &z);
        l++, r++, z++;
        q[i * 2 - 1] = (query){l - 1, z, i * 2 - 1};
        q[i * 2] = (query){r, z, i * 2};
    }
    int now = 1;
    std::sort(q + 1, q + 2 * m + 1, cmp);
    for(int i = 1; i <= n; i++)
    {
        update_chain(1, i);
        while(q[now].r < i)
            ++now;
        while(q[now].r == i)
        {
            ans[q[now].id] = query_chain(1, q[now].z);
            ++now;
        }
    }
    for(int i = 1; i <= m; i++)
        printf("%d\n", (ans[i * 2] - ans[i * 2 - 1]) % mod);
    return 0; 
}
```

---

## 作者：PurpleWonder (赞：2)

发现没有lct的题解，明明lct也可以链上修改+链上求和啊……

原理和树剖是一样的，也是将“求x与y的lca深度”转化为“根节点到x的路径上所有节点的权值+1，求根节点到y的路径上所有节点的权值之和”，然后将询问离线，把求"l到r"转化为求"（1到r）-（1到l-1）"，从1开始逐个修改权值，当有一个询问出现时就对当前状态下的树进行查询。（其他的题解也都说的很清楚了）

好像要是强制在线就gg掉了……强制在线的话树剖也许可以用主席树维护？

虽说是O(nlogn)，但是由于常数巨大，效率跟树剖也差不多。

```cpp
#include<cstdio>
#include<algorithm>
#define p 201314
using namespace std;

int n,m,xi,yi;
int fa[50010],ch[50010][2],val[50010],sum[50010],rev[50010],lazy[50010],size[50010],qz[50010];
long long ans[50010];
struct node{
	int pos,id,flag;
	bool operator <(const node d)const{return pos<d.pos;}
}nd[100010];

inline int isroot(int x){
	return ch[fa[x]][0]==x || ch[fa[x]][1]==x;
}

inline void push_up(int x){
	sum[x]=sum[ch[x][0]]+sum[ch[x][1]]+val[x];
	size[x]=size[ch[x][0]]+size[ch[x][1]]+1;
}

inline void push_down(int x){
	if(rev[x]){
		rev[ch[x][0]]^=1;rev[ch[x][1]]^=1;swap(ch[x][0],ch[x][1]);rev[x]=0;
	}
	if(lazy[x]){
		if(ch[x][0]){
			lazy[ch[x][0]]+=lazy[x];sum[ch[x][0]]+=lazy[x]*size[ch[x][0]];val[ch[x][0]]+=lazy[x];
		}
		if(ch[x][1]){
			lazy[ch[x][1]]+=lazy[x];sum[ch[x][1]]+=lazy[x]*size[ch[x][1]];val[ch[x][1]]+=lazy[x];
		}
		lazy[x]=0;
	}
}

void push(int x){
	if(isroot(x))push(fa[x]);push_down(x);
}

inline void rotate(int x){
	int y=fa[x],z=fa[y],c=ch[y][1]==x;
	if(isroot(y))ch[z][ch[z][1]==y]=x;fa[x]=z;ch[y][c]=ch[x][c^1];
	if(ch[x][c^1])fa[ch[x][c^1]]=y;fa[y]=x;ch[x][c^1]=y;
	push_up(y);
}

inline void splay(int x){
	push(x);while(isroot(x)){
		int y=fa[x],z=fa[y];
		if(isroot(y)){
			(ch[y][1]==x)==(ch[z][1]==y)?rotate(y):rotate(x);
		}
		rotate(x);
	}push_up(x);
}

inline void access(int x){
	for(int y=0;x;x=fa[y=x]){
		splay(x);ch[x][1]=y;push_up(x);
	}
}

inline void makeroot(int x){
	access(x);splay(x);rev[x]^=1;
} 

inline void split(int x,int y){
	makeroot(x);access(y);splay(y);
}

int main(){
	scanf("%d %d",&n,&m);size[1]=1;
	for(int i=2;i<=n;i++){
		scanf("%d",&xi);fa[i]=xi+1;size[i]=1;
	}
	for(int i=0;i<m;i++){
		scanf("%d",&nd[(i<<1)+1].pos);nd[(i<<1)+1].id=i+1;nd[(i<<1)+1].flag=-1;
		scanf("%d",&nd[(i<<1)+2].pos);nd[(i<<1)+2].id=i+1;nd[(i<<1)+2].flag=1;scanf("%d",&qz[i+1]);qz[i+1]++;nd[(i<<1)+2].pos++;
	}sort(nd+1,nd+(m<<1)+1);int id=0;
	for(int i=1;i<=(m<<1);i++){
		while(id<nd[i].pos){
			id++;
			split(1,id);val[id]++;sum[id]+=size[id];lazy[id]++;
		}
		split(1,qz[nd[i].id]);ans[nd[i].id]+=nd[i].flag*sum[qz[nd[i].id]];
	}for(int i=1;i<=m;i++)printf("%lld\n",((ans[i]%p)+p)%p);
}
```

---

## 作者：1saunoya (赞：2)

[Problem](https://www.luogu.org/problem/P4211)

q个询问
给出$l,r,z$
求 $\sum_{i=l}^{r} dep[Lca(i,z)]$

$n,q \leq 5*10^4$

这显然是不太可做的 如果你要用 $nq \log n$ 的做法

考虑离线。

把询问拆成 [$1,l-1$] , [$1,r$]

求出来的结果自然是 [$1,r$] - [$1,l-1$]
没有固定的点？怎么办？

我们想。假设当前询问点是 z 选到 x 这个点 ($l \leq x \leq r$)

那么 `z 和 x 的 LCA 一定在 x 和 1 的路径上`
所以每次 链上修改 把 x -> 1 的这条链整体加1

查询的时候 查询 1 ~ z 的链上的值就可以了。

至于链上整体加1 以及链上查询 可以用树链剖分+线段树解决。

如果没能理解 很抱歉我菜的可怜只能放一张~~比较特殊的~~图 让读者自行理解了。。

![](https://img2018.cnblogs.com/blog/1822694/201911/1822694-20191106123143670-1135375164.png)
如果图出不来请去 [myblog](https://www.cnblogs.com/Isaunoya/p/11804422.html)

```cpp
#include<bits/stdc++.h>
using namespace std ;
const int MAXN = 5e4 + 10 ;
struct Query { int z , flg , id ; } ;
vector < Query > v[MAXN] ;
int n , Q ;
struct Edge { int v , nxt ; } e[MAXN << 1] ;
int head[MAXN] , cnt = 0 ;
inline void add(int u , int v) { e[++ cnt] = {v , head[u]} ; head[u] = cnt ; }
typedef int arr[MAXN] ;
arr sz , fa , d , son ;
inline void dfs(int u) {
  sz[u] = 1 ;
  for(register int i = head[u] ; i ; i = e[i].nxt) {
    int v = e[i].v ;
    if(v == fa[u]) continue ;
    fa[v] = u ;
    d[v] = d[u] + 1 ;
    dfs(v) ;
    sz[u] += sz[v] ;
    if(sz[v] > sz[son[u]]) son[u] = v ;
  }
}
arr top , id , seq ; int idx = 0 ;
inline void dfs(int u , int t) {
  top[u] = t ; id[u] = ++ idx ; seq[idx] = u ;
  if(! son[u]) return ; dfs(son[u] , t) ;
  for(register int i = head[u] ; i ; i = e[i].nxt) {
    int v = e[i].v ;
    if(v == fa[u] || v == son[u]) continue ;
    dfs(v , v) ;
  }
}
const int Mod = 201314 ;
int sum[MAXN << 2] , tag[MAXN << 2] ;
inline void pushup(int rt) {
  sum[rt] = sum[rt << 1] + sum[rt << 1 | 1] ;
  if(sum[rt] >= Mod) sum[rt] -= Mod ;
}
inline void build(int l , int r , int rt) {
  if(l == r) { sum[rt] = tag[rt] = 0 ; return ; }
  int mid = l + r >> 1 ;
  build(l , mid , rt << 1) ;
  build(mid + 1 , r , rt << 1 | 1) ;
  pushup(rt) ;
}
inline void pushdown(int rt , int l , int r) {
  if(! tag[rt]) return ;
  tag[rt << 1] += tag[rt] ;
  tag[rt << 1 | 1] += tag[rt] ;
  int mid = l + r >> 1 ;
  sum[rt << 1] += tag[rt] * (mid - l + 1) ;
  sum[rt << 1 | 1] += tag[rt] * (r - mid) ;
  tag[rt] = 0 ;
  return ;
}
inline void update(int a , int b , int l , int r , int rt) {
  if(a <= l && r <= b) { sum[rt] += r - l + 1 ; tag[rt] ++ ; return ; }
  pushdown(rt , l , r) ;
  int mid = l + r >> 1 ;
  if(a <= mid) update(a , b , l , mid , rt << 1) ;
  if(b > mid) update(a , b , mid + 1 , r , rt << 1 | 1) ;
  pushup(rt) ;
}
inline int query(int a , int b , int l , int r , int rt) {
  if(a <= l && r <= b) { return sum[rt] ; }
  pushdown(rt , l , r) ;
  int mid = l + r >> 1 , ans = 0 ;
  if(a <= mid) ans += query(a , b , l , mid , rt << 1) ;
  if(b > mid) ans += query(a , b , mid + 1 , r , rt << 1 | 1) ;
  return ans ;
}
inline void upd_range(int x , int y) {
  int fx = top[x] , fy = top[y] ;
  while(fx ^ fy) {
    if(d[fx] < d[fy]) swap(x , y) , swap(fx , fy) ;
    update(id[fx] , id[x] , 1 , n , 1) ;
    x = fa[fx] , fx = top[x] ;
  }
  if(d[x] > d[y]) swap(x , y) ;
  update(id[x] , id[y] , 1 , n , 1) ;
}
inline int query_range(int x , int y) {
  int fx = top[x] , fy = top[y] , ans = 0 ;
  while(fx ^ fy) {
    if(d[fx] < d[fy]) swap(x , y) , swap(fx , fy) ;
    ans += query(id[fx] , id[x] , 1 , n , 1) ;
    x = fa[fx] , fx = top[x] ;
  }
  if(d[x] > d[y]) swap(x , y) ;
  return ans += query(id[x] , id[y] , 1 , n , 1) ;
}
int ans[MAXN] ;
signed main() {
#ifdef _WIN64
  freopen("0.in" , "r" , stdin) ;
#endif
  ios_base :: sync_with_stdio(false) ;
  cin.tie(nullptr) ;
  cout.tie(nullptr) ;
  cin >> n >> Q ;
  for(int i = 2 ; i <= n ; i ++) { int fa ; cin >> fa ; add(i , ++ fa) ; add(fa , i) ; }
  dfs(1) ; dfs(1 , 1) ; build(1 , n , 1) ;
  for(int i = 1 ; i <= Q ; i ++) {
    int l , r , z ;
    cin >> l >> r >> z ; ++ l ; ++ r ; ++ z ;
    v[l - 1].push_back({z , - 1 , i}) ; v[r].push_back({z , 1 , i}) ;
  }
  for(register int i = 1 ; i <= n ; i ++) {
    upd_range(1 , i) ;
    for( Query x : v[i] ) ans[x.id] = (ans[x.id] + x.flg * query_range(1 , x.z) + Mod) % Mod ;
  }
  for(register int i = 1 ; i <= Q ; i ++) cout << ans[i] << '\n' ;
  return 0 ;
}
```

---

## 作者：joe19025 (赞：2)

## 解题构思

### 技能储备
1.树链剖分

2.LCA

### 结论

∑ 
l≤i≤r
​	 dep[LCA(i,z)]
的值：

l<=i<=r

将i到根节点所有的点权值加1

结果就是z节点到根节点的路径和

证明：

很明显，当r=l+1时，可以画图轻松证明

接着通过数学归纳法，可证明该结论

### 解题思路

1.读入建树

2.询问离线

3.根据端点排序

4.依次加入每个节点

5.通过差分相减得出结果

6.组织输出

#### ps.最好把节点编号+1，这样可避免0节点的存在



------------

## Code
```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <vector>
#include <algorithm>
#define MAXN 50005
using namespace std;

int const mod=201314;
vector<int>G[MAXN];

//dfs
int dep[MAXN],fa[MAXN],size[MAXN],son[MAXN];
int top[MAXN],idx[MAXN],dfn=0;

void dfs1(int u,int father,int depth)
{
    dep[u]=depth;
    fa[u]=father;
    size[u]=1;
    int maxs=-1;
    for(int i=0;i<G[u].size();i++)
    {
        int v=G[u][i];
        if(v==fa[u])continue;
        dfs1(v,u,depth+1);
        size[u]+=size[v];
        if(size[v]>maxs)maxs=size[v],son[u]=v;
    }
}

void dfs2(int u,int chain)
{
    top[u]=chain;
    idx[u]=++dfn;
    if(!son[u])return;
    dfs2(son[u],chain);
    for(int i=0;i<G[u].size();i++)
    {
        int v=G[u][i];
        if(v==fa[u]||v==son[u])continue;
        dfs2(v,v);
    }
}

//segment tree
struct tree{
    int l,r;
    tree *lson,*rson;
    int sum;
    int lazy;
}pool[MAXN*2];
int tot=0;
void build(tree *node,int l,int r)
{
    node->l=l;
    node->r=r;
    node->sum=0;
    node->lazy=0;
    if(l==r)
    {
        return;
    }
    int m=(l+r)>>1;
    node->lson=&pool[tot++];
    node->rson=&pool[tot++];
    build(node->lson,l,m);
    build(node->rson,m+1,r);
}
void falazy(tree *node)
{
    if(node->lson)
    {
        node->lson->lazy+=node->lazy;
        node->lson->sum+=node->lazy*(node->lson->r-node->lson->l+1);
        node->lson->lazy%=mod;
        node->lson->sum%=mod;
    }
    if(node->rson)
    {
        node->rson->lazy+=node->lazy;
        node->rson->sum+=node->lazy*(node->rson->r-node->rson->l+1);
        node->rson->lazy%=mod;
        node->rson->sum%=mod;
    }
    node->lazy=0;
    node->sum=(node->lson->sum+node->rson->sum)%mod;
}
void update(tree *node,int l,int r,int k)
{
    k%=mod;
    if(l==node->l &&r==node->r)
    {
        node->lazy+=k;
        node->sum+=(node->r-node->l+1)%mod*k;
        node->sum%=mod;
        node->lazy%=mod;
        return;
    }
    falazy(node);
    if(r<=node->lson->r)
        update(node->lson,l,r,k);
    else if(l>=node->rson->l)
        update(node->rson,l,r,k);
    else
    {
        update(node->lson,l,node->lson->r,k);
        update(node->rson,node->rson->l,r,k);
    }
    node->sum=(node->lson->sum+node->rson->sum)%mod;
}
int query(tree *node,int l,int r)
{
    if(l==node->l && r==node->r)
    {
        return node->sum;
    }
    falazy(node);
    if(r<=node->lson->r)
        return query(node->lson,l,r);
    if(l>=node->rson->l)
        return query(node->rson,l,r);
    return (query(node->lson,l,node->lson->r)+query(node->rson,node->rson->l,r))%mod;
}

tree *root=&pool[tot++];

//dissection
void add(int u,int v,int k)
{
    k%=mod;
    while(top[u]!=top[v])
    {
        if(dep[top[u]]<dep[top[v]])swap(u,v);
        update(root,idx[top[u]],idx[u],k);
        u=fa[top[u]];
    }
    if(dep[u]>dep[v])swap(u,v);
    update(root,idx[u],idx[v],k);
}

int ask(int u,int v)
{
    int res=0;
    while(top[u]!=top[v])
    {
        if(dep[top[u]]<dep[top[v]])swap(u,v);
        res+=query(root,idx[top[u]],idx[u]);
        res%=mod;
        u=fa[top[u]];
    }
    if(dep[u]>dep[v])swap(u,v);
    res+=query(root,idx[u],idx[v]);
    res%=mod;
    return res;
}

struct opt{
    int id;
    int z;
    int f;
    int pos;
    bool operator<(const opt a)const
    {
        return this->pos<a.pos;
    }
};

int main()
{
    //initialization
    int n,q;
    scanf("%d%d",&n,&q);
    for(int i=2;i<=n;i++)
    {
        int x;
        scanf("%d",&x);
        x++;
        G[i].push_back(x);
        G[x].push_back(i);
    }
    dfs1(1,-1,1);
    dfs2(1,1);
    build(root,1,n);

    
    //response
    int cnt=0;
    opt a[2*MAXN];
    for(int i=1;i<=q;i++)
    {
        int x,y,z;
        scanf("%d%d%d",&x,&y,&z);
        z++;
        a[++cnt].z=z;a[cnt].pos=x;a[cnt].id=i;a[cnt].f=-1;
        a[++cnt].z=z;a[cnt].pos=y+1;a[cnt].id=i;a[cnt].f=1;
    }
    sort(a+1,a+cnt+1);
    int j=1,i=1;
    int ans[MAXN];
    for(i=1;i<=cnt;i++)
    {
        while(j<=a[i].pos)
            add(1,j++,1);
        ans[a[i].id]+=ask(1,a[i].z)*a[i].f;
    }
    for(int i=1;i<=q;i++)
        printf("%d\n",(ans[i]+mod)%mod);
    return 0;
}


```


---

## 作者：Jμdge (赞：1)

其实没有黑题难度？~~默默点了黑色标签~~ 码农题！~~树剖好题！~~

当然思维上也是蛮清新的

就是考虑每个求 LCA 的深度有什么独特的方法

我们可以考虑以下的另类操作：

1. 首先令一个点一路走到根并标记沿路的点（其实就是沿路的点权值++）

2. 然后另一个点一路走到根，累加沿路点的权值


这样的操作是可以支持 **多个点** 与 **一个点** 之间的 LCA 深度求和的 

>但是算算复杂度？ $O(n^2~· q)$，

>加上线段树优化？ $O(n~log~n~· q)$

那么我们考虑江**每个询问拆成两个询问**，因为我们可以发现要求的 $ANS$ 对于同一个点 z 满足区间加减的性质，即：

$$ANS=\sum_{i=l}^r deep[LCA(i,z)]=\sum_{i=1}^r deep[LCA(i,z)]-\sum_{i=1}^{l-1} deep[LCA(i,z)]$$

其中的 $deep$ 表示节点深度


于是我们用类似前缀和（好吧是差分）的思路，就可以得到一个 $O(n~ log~ n +~q~ log~ n)$ 的算法啦！ （当然是用了线段树维护的树剖）

然后就是码农...（打了好久...）

还有就是不要嫌弃压行，代码太长实在看不下去的...（这里只有80行吧）

毕竟压行的都是一些简单函数以及线段树的板子（都可以自己打的QWQ）

```
//by Judge
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
const int mod=201314;
const int M=5e4+3;
typedef int arr[M];
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} char sr[1<<21],z[20];int C=-1,Z;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
inline void print(int x,char chr='\n'){
    if(C>1<<20)Ot();if(x<0)sr[++C]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]=chr;
} int n,Q,pat,cnt,tim,now; int sum[M<<2],col[M<<2];
arr head,siz,f,son,dep,top,dfn,ans1,ans2;
struct Edge{ int to,nxt; }e[M];
struct que{ int id,pos,z,flg;}q[M<<1];
inline void add(int u,int v){e[++pat]={v,head[u]},head[u]=pat;}
inline bool cmp(que& a,que& b){return a.pos<b.pos;}
inline int Max(int a,int b){return siz[a]>siz[b]?a:b;}
#define v e[i].to
void dfs(int u){ dep[u]=dep[f[u]]+1,siz[u]=1;
	for(int i=head[u];i;i=e[i].nxt)
		dfs(v),siz[u]+=siz[v],son[u]=Max(son[u],v);
}
void dfs(int u,int tp){
	dfn[u]=++tim,top[u]=tp;
	if(son[u]) dfs(son[u],tp);
	for(int i=head[u];i;i=e[i].nxt)
		if(v^f[u]&&v^son[u]) dfs(v,v);
}
#undef v
#define ls k<<1
#define rs k<<1|1
#define mid (l+r>>1)
#define lson ls,l,mid
#define rson rs,mid+1,r
inline void color(int k,int l,int r,int co){sum[k]=(sum[k]+(r-l+1)*co)%mod,col[k]+=co;}
inline void pushdown(int k,int l,int r){ if(!col[k]) return;color(lson,col[k]),color(rson,col[k]),col[k]=0;}
void update(int k,int l,int r,int L,int R){ if(L>r||l>R) return;
	if(L<=l&&r<=R) return color(k,l,r,1); pushdown(k,l,r);
	update(lson,L,R),update(rson,L,R),sum[k]=(sum[ls]+sum[rs])%mod;
}
int query(int k,int l,int r,int L,int R){ if(L>r||l>R) return 0;
	if(L<=l&&r<=R) return sum[k]; pushdown(k,l,r);
	return query(lson,L,R)+query(rson,L,R);
}
inline void update(int u,int v){
	for(;top[u]^top[v];u=f[top[u]]){
		if(dep[top[u]]<dep[top[v]]) swap(u,v);
		update(1,1,n,dfn[top[u]],dfn[u]);
	} if(dep[u]>dep[v]) swap(u,v);
	update(1,1,n,dfn[u],dfn[v]);
}
inline int query(int u,int v){ int s=0;
	for(;top[u]^top[v];u=f[top[u]]){
		if(dep[top[u]]<dep[top[v]]) swap(u,v);
		s+=query(1,1,n,dfn[top[u]],dfn[u]);
	} if(dep[u]>dep[v]) swap(u,v);
	s+=query(1,1,n,dfn[u],dfn[v]); return s%mod;
}
int main(){
	n=read(),Q=read();
	for(int i=2;i<=n;++i)
		f[i]=read()+1,add(f[i],i);
	
    for(int i=1,l,r,x;i<=Q;++i)
		l=read(),r=read()+1,x=read()+1,
		q[++cnt]={i,l,x,0},q[++cnt]={i,r,x,1};
	dfs(1),dfs(1,1),sort(q+1,q+1+cnt,cmp);
    
	for(int i=1;i<=cnt;++i){
    	for(;now<q[i].pos;update(1,++now));
		(q[i].flg?ans1[q[i].id]:ans2[q[i].id])=query(1,q[i].z);
	}
    for(int i=1;i<=Q;++i)
    	print((ans1[i]-ans2[i]+mod)%mod);
    return Ot(),0;
}
```

---

## 作者：大菜鸡fks (赞：1)

经典的转化模型。

求lca深度可以转化为点到根的加法，查询点到根的值。

离线询问，用前缀和的思想

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
inline int read(){int x=0,f=1,ch=getchar(); while(ch<'0'||ch>'9'){if(ch=='-') f=-1; ch=getchar();} while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();} return x*f;}
inline void write(int x){if (x<0) putchar('-'),x=-x; if (x>=10) write(x/10); putchar(x%10+'0');}
inline void writeln(int x){write(x); puts("");}
const int N=100005,mod=201314;
struct edge{
	int link,next;
}e[N<<1];
struct qu{
	int flag,id,pos;
}q[N];
int n,tot,head[N],m,qq[N];
inline void insert(int u,int v){
	e[++tot]=(edge){v,head[u]}; head[u]=tot;
}
inline void init(){
	n=read(); m=read();
	for (int i=2;i<=n;i++){
		int x=read()+1;
		if (x) insert(x,i);
	}
	tot=0;
	for (int i=1;i<=m;i++){
		int l=read()+1,r=read()+1,x=read();
		qq[i]=x+1;
		q[++tot]=(qu){-1,i,l-1};
		q[++tot]=(qu){1,i,r};
	}
} 
int top[N],num[N],tim,Pos[N],fa[N],size[N],heavy[N],dep[N];
void dfs1(int u){
	dep[u]=dep[fa[u]]+1; size[u]=1;
	for (int i=head[u];i;i=e[i].next){
		int v=e[i].link;
		if (v!=fa[u]){
			fa[v]=u;
			dfs1(v);
			size[u]+=size[v];
			if (!heavy[u]||size[v]>size[heavy[u]]){
				heavy[u]=v;
			}
		}
	}
}
void dfs2(int u,int tp){
	num[u]=++tim; Pos[tim]=u; top[u]=tp;
	if (heavy[u]){
		dfs2(heavy[u],tp);
	}
	for (int i=head[u];i;i=e[i].next){
		int v=e[i].link;
		if (v!=fa[u]&&v!=heavy[u]){
			dfs2(v,v);
		} 
	}
}
inline bool cmp(qu A,qu B){
	return A.pos<B.pos;
}
struct node{
	int sum,lazy;
}a[N<<2];
inline void plus(int k,int x,int l,int r){
	int sz=r-l+1;
	(a[k].sum+=x*sz)%=mod;
	(a[k].lazy+=x)%=mod;
}
inline void pushdown(int k,int l,int mid,int r){
	if (a[k].lazy){
		plus(k<<1,a[k].lazy,l,mid); 
		plus(k<<1|1,a[k].lazy,mid+1,r);
		a[k].lazy=0;
	}
}
inline void pushup(int k){a[k].sum=(a[k<<1].sum+a[k<<1|1].sum)%mod;}
void update(int k,int l,int r,int x,int y){
	if (l==x&&r==y){
		plus(k,1,l,r);
		return;
	}
	int mid=(l+r)>>1;
	pushdown(k,l,mid,r);
	if (mid>=y) update(k<<1,l,mid,x,y);
		else if (mid<x) update(k<<1|1,mid+1,r,x,y);
			else update(k<<1,l,mid,x,mid),update(k<<1|1,mid+1,r,mid+1,y);
	pushup(k);
}
inline void update(int x){
	while (x){
		update(1,1,n,num[top[x]],num[x]);
		x=fa[top[x]];
	}
}
inline int query(int k,int l,int r,int x,int y){
	if (l==x&&r==y){
		return a[k].sum;
	}
	int mid=(l+r)>>1;
	pushdown(k,l,mid,r);
	if (mid>=y) return query(k<<1,l,mid,x,y);
		else if (mid<x) return query(k<<1|1,mid+1,r,x,y);
			else return (query(k<<1,l,mid,x,mid)+query(k<<1|1,mid+1,r,mid+1,y))%mod;
}
inline int Qu(int x){
	int ans=0;
	while (x){
		(ans+=query(1,1,n,num[top[x]],num[x]))%=mod;
		x=fa[top[x]];
	}
	return ans;
}
int Ans[N];	
inline void solve(){
	dfs1(1);
	dfs2(1,1);
	sort(q+1,q+1+tot,cmp);
	int now=1;
	while (!q[now].pos){
		now++;
	}
	for (int i=1;i<=n;i++){
		update(i); int ans;
		while (q[now].pos==i){
			(Ans[q[now].id]+=Qu(qq[q[now].id])*q[now].flag+mod)%=mod;
			now++;
		}
	}
	for (int i=1;i<=m;i++){
		writeln(Ans[i]);
	}
}
int main(){
	init();
	solve();
	return 0;
}
```

---

## 作者：Ark_ (赞：1)

[BZOJ 4012 [HNOI2015]开店](https://blog.csdn.net/Ike940067893/article/details/88681935) 的弱化版,离线了,而且没有边权(长度).

两种做法(在线和离线)
感觉没有人写在线的主席树方法啊...于是我来写一写

# 1 树剖+离线+线段树
这道题求的是一个点$z$与$[l,r]$内所有点的$lca$的深度之和.可以发现,$dep[lca(u,v)]$就等于**从$u$到根**与**从$v$到根**的路径的**交集路径**的长度.那么只要把$[l,r]$所有点到根的路径标记了,然后用$z$点往根跑统计答案就行了.这样的话差分一下,离线就可以处理了.

时间复杂度$O(nlog^2n)$
# CODE
```cpp
#include <vector>
#include <queue>
#include <cstdio>
#include <cctype>
#include <cstring>
#include <algorithm>
using namespace std;
typedef long long LL;

inline void read(int &num) {
	char ch; int flg=1; while(!isdigit(ch=getchar()))if(ch=='-')flg=-flg;
	for(num=0; isdigit(ch); num=num*10+ch-'0',ch=getchar()); num*=flg;
}
const int MAXN = 50005;
const int mod = 201314;

int n, tot, Q, dfn[MAXN], seq[MAXN], tmr, fir[MAXN], cnt;
struct edge { int to, nxt; }e[MAXN];

inline void add(int u, int v) {
	e[cnt] = (edge){ v, fir[u] }, fir[u] = cnt++;
}
int dep[MAXN], fa[MAXN], sz[MAXN], top[MAXN], son[MAXN];
void dfs(int u) {
	dep[u] = dep[fa[u]] + (sz[u]=1);
	for(int v, i = fir[u]; ~i; i = e[i].nxt) {
		dfs(v=e[i].to), sz[u] += sz[v];
		if(sz[v] > sz[son[u]]) son[u] = v;
	}
}
void dfs2(int u, int tp) {
	top[u] = tp; dfn[u] = ++tmr;
	if(son[u]) dfs2(son[u], tp);
	for(int v, i = fir[u]; ~i; i = e[i].nxt)
		if((v=e[i].to) != son[u]) dfs2(v, v);
}

struct node {
	int tim, x, id, flg;
}q[MAXN<<1];
inline bool cmp(const node &A, const node &B) { return A.tim < B.tim; }
int ans[MAXN];
int lz[MAXN<<2], sum[MAXN<<2];
inline void upd(int i) { sum[i] = sum[i<<1] + sum[i<<1|1]; }
inline void mt(int i, int l, int r, int mid) {
	if(lz[i]) {
		(lz[i<<1] += lz[i]) %= mod;
		(lz[i<<1|1] += lz[i]) %= mod;
		(sum[i<<1] += 1ll * lz[i] * (mid-l+1) % mod) %= mod;
		(sum[i<<1|1] += 1ll * lz[i] * (r-mid) % mod) %= mod;
		lz[i] = 0;
	}
}
void insert(int i, int l, int r, int x, int y) {
	if(l == x && r == y) {
		(lz[i] += 1) %= mod;
		(sum[i] += r-l+1) %= mod;
		return;
	}
	int mid = (l + r) >> 1;
	mt(i, l, r, mid);
	if(y <= mid) insert(i<<1, l, mid, x, y);
	else if(x > mid) insert(i<<1|1, mid+1, r, x, y);
	else insert(i<<1, l, mid, x, mid), insert(i<<1|1, mid+1, r, mid+1, y);
	upd(i);
}
int query(int i, int l, int r, int x, int y) {
	if(l == x && r == y) return sum[i];
	int mid = (l + r) >> 1;
	mt(i, l, r, mid);
	int res = 0;
	if(y <= mid) res = query(i<<1, l, mid, x, y);
	else if(x > mid) res = query(i<<1|1, mid+1, r, x, y);
	else res = (query(i<<1, l, mid, x, mid) + query(i<<1|1, mid+1, r, mid+1, y)) % mod;
	upd(i);
	return res;
}
inline void Modify(int x) {
	while(x) insert(1, 1, n, dfn[top[x]], dfn[x]), x = fa[top[x]];
}
inline int Query(int x) {
	int res = 0;
	while(x) (res += query(1, 1, n, dfn[top[x]], dfn[x])) %= mod, x = fa[top[x]];
	return res;
}

int main() {
	read(n); read(Q);
	memset(fir, -1, sizeof fir);
	for(int i = 2; i <= n; ++i)
		read(fa[i]), ++fa[i], add(fa[i], i);
	dfs(1); dfs2(1, 1);
	for(int i = 1, x, y, z; i <= Q; ++i) {
		read(x), read(y), read(z); ++x, ++y, ++z;
		q[++tot] = (node){ x-1, z, i, -1 }; //差分
		q[++tot] = (node){  y , z, i,  1 };
	}
	sort(q + 1, q + tot + 1, cmp);
	int now = 0;
	for(int i = 1; i <= tot; ++i) {
		while(now < q[i].tim) Modify(++now);
		(ans[q[i].id] += q[i].flg * Query(q[i].x)) %= mod;
	}
	for(int i = 1; i <= Q; ++i)
		printf("%d\n", (ans[i]+mod)%mod);
}
```

# 2 树剖+在线+主席树
沿用法1的思路,直接在主席树上找$r$的线段树与$l-1$的线段树相减就行了.但是主席树不能下传标记,那么就把标记永久化.查询的时候在主席树上从根往下边走边统计.

时间复杂度同样是$O(nlog^2n)$,常数巨大...空间复杂度也是$O(nlog^2n)$,实测开$100n$就能过了
# CODE
```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
typedef long long LL;
template<typename T>inline void read(T &num) {
	char ch; int flg = 1;
	while((ch=getchar())<'0'||ch>'9')if(ch=='-')flg=-flg;
	for(num=0;ch>='0'&&ch<='9';num=num*10+ch-'0',ch=getchar());
	num*=flg;
}
const int MAXN = 50005;
const int mod = 201314;
const int MAXNN = MAXN*100;
int n, q, A, fir[MAXN], cnt;
struct edge { int to, nxt; }e[MAXN];
inline void add(int u, int v) {
	e[cnt] = (edge){ v, fir[u] }, fir[u] = cnt++;
}

int son[MAXN], sz[MAXN], top[MAXN], tmr, dfn[MAXN], fa[MAXN];
void dfs(int u) {
	sz[u] = 1;
	for(int i = fir[u], v; ~i; i = e[i].nxt) {
		dfs(v=e[i].to), sz[u] += sz[v];
		if(sz[v] > sz[son[u]]) son[u] = v;
	}
}
void dfs2(int u, int tp) {
	top[u] = tp; dfn[u] = ++tmr;
	if(son[u]) dfs2(son[u], tp);
	for(int i = fir[u], v; ~i; i = e[i].nxt)
		if((v=e[i].to) != fa[u] && v != son[u])
			dfs2(v, v);
}
int ch[MAXNN][2], tim[MAXNN], tot, rt[MAXN], sum[MAXNN];

inline void Newnode(int i, int p) { ch[i][0] = ch[p][0], ch[i][1] = ch[p][1], sum[i] = sum[p], tim[i] = tim[p]; }

void modify(int &i, int l, int r, int L, int R) {
	Newnode(++tot, i);
	if(L == l && r == R) { (++tim[i = tot]) %= mod; return; }
	(sum[i = tot] += R-L+1) %= mod;
	int mid = (l + r) >> 1;
	if(R <= mid) modify(ch[i][0], l, mid, L, R);
	else if(L > mid) modify(ch[i][1], mid+1, r, L, R);
	else modify(ch[i][0], l, mid, L, mid), modify(ch[i][1], mid+1, r, mid+1, R);
}
inline void Modify(int &r, int x) { while(x) modify(r, 1, n, dfn[top[x]], dfn[x]), x = fa[top[x]]; }
int query(int i, int l, int r, int L, int R) {
	if(!i) return 0;
	int res = 1ll * (R-L+1) * tim[i] % mod;
	if(L == l && r == R) return (res + sum[i]) % mod;
	int mid = (l + r) >> 1;
	if(R <= mid) return (res + query(ch[i][0], l, mid, L, R)) % mod;
	else if(L > mid) return (res + query(ch[i][1], mid+1, r, L, R)) % mod;
	return (res + query(ch[i][0], l, mid, L, mid) + query(ch[i][1], mid+1, r, mid+1, R)) % mod;
}
int Query(int r, int x) { int res = 0; while(x) (res += query(r, 1, n, dfn[top[x]], dfn[x])) %= mod, x = fa[top[x]]; return res; }
int main () {
	read(n), read(q);
	memset(fir, -1, sizeof fir);
	for(int i = 2; i <= n; ++i)
		read(fa[i]), ++fa[i], add(fa[i], i);
	dfs(1), dfs2(1, 1);
	for(int i = 1; i <= n; ++i) Modify(rt[i]=rt[i-1], i);
	int L, R, x;
	while(q--) {
		read(L), read(R), read(x); ++L, ++R, ++x;
		printf("%d\n", (Query(rt[R], x) - Query(rt[L-1], x) + mod) % mod);
	}
}

```


---

## 作者：cirnovsky (赞：1)

# P4211 [LNOI2014]LCA

给出一个n个节点的有根树（编号为0到n-1，根节点为0）。一个点的深度定义为这个节点到根的距离+1。
设dep[i]表示点i的深度，LCA(i,j)表示i与j的最近公共祖先。
有q次询问，每次询问给出l r z，求$\sum_{l \leq i \leq r}dep[LCA(i,z)]$

------

问题可以转化为求点到根的距离+1，询问l到r的结点到根的距离和。

这相当于是在求结点到根的点权+1的和。

那么该怎么办呢？

显然我们可以离线得到所有的询问，然后将差分询问，也就是查询 $[1,r]-[1,l-1]$

我们可以在l-1和r处打标记，然后遍历树的结点有标记就执行查询操作。

方便起见我们可以用树链剖分来维护，时间复杂度n乘上一个Log方n。

(对了我的代码特别玄学，查询部分循环版本在luogu上T了，在lojA了，递归版本在luoguA了，在lojT了！)

(我对这份代码除了缓缓地打出一个问号也不能说什么了)

```cpp
#pragma GCC diagnostic error "-std=c++11"
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <queue>
#define IT vector < int >::iterator
#define ForGraph int i = Head[x], y = Vert[i]; i; i = Next[i], y = Vert[i]
#define CheckSize ((size[son[x]] < size[y]) && (son[x] = y))
#define TCS TreeChainSplitting
#define CFS ChainForwardStar
#define PS ProblemSolver
#define pii pair < int , int >
#define pll pair < LL, LL >
#define mid ((l + r) >> 1)
#define mp make_pair
#define fir first
#define sec second
#define pub push_back
#define pob pop_back

using namespace std;
typedef long long LL;

#define io_e '\0'
#define io_s ' '
#define io_l '\n'
 #define _DEBUG_ 1 // debug toggle
namespace Fast_IO {
    #ifndef _DEBUG_
        #define gc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++)
    #else
        #define gc() getchar()
    #endif
    const int SIZ = 1 << 21 | 1;
    char *iS, *iT, ibuff[SIZ], obuff[SIZ], *oS = obuff, *oT = oS + SIZ - 1, fu[110], c;
    int fr;
    inline void ioout() {
        fwrite(obuff, 1, oS - obuff, stdout);
        oS = obuff;
    }
    template <class Type>
    inline void read(Type& x) {
        x = 0;
        Type y = 1;
        for (c = gc(); (c > '9' || c < '0') && c ^ '-'; c = gc())
            ;
        c == '-' ? y = -1 : x = (c & 15);
        for (c = gc(); c >= '0' && c <= '9'; c = gc()) x = x * 10 + (c & 15);
        x *= y;
    }
    inline bool blank(char ch) { return ch == ' ' || ch == '\n' || ch == '\r' || ch == '\t'; }
    inline void read(char* s) {
        register char ch = gc();
        for (; blank(ch); ch = gc())
            ;
        for (; !blank(ch); ch = gc()) *s++ = ch;
        *s = 0;
    }
    inline void read(char& c) {
        for (c = gc(); blank(c); c = gc())
            ;
    }
    template <typename Type, typename... Args>
    inline void read(Type& t, Args&... args) {
        read(t), read(args...);
    }
    template <typename... Args>
    inline void read(char* t, Args&... args) {
        read(t), read(args...);
    }
    template <typename... Args>
    inline void read(char& t, Args&... args) {
        read(t), read(args...);
    }
    template <class Type>
    inline void write(char lastChar, Type x) {
        if (x < 0)
            *oS++ = '-', x = -x;
        if (x == 0)
            *oS++ = '0';
        while (x) fu[++fr] = x % 10 + '0', x /= 10;
        while (fr) *oS++ = fu[fr--];
        *oS++ = lastChar;
        ioout();
    }
    inline void write(char lastChar, char x[]) {
        for (register int i = 0; x[i]; ++i) *oS++ = x[i];
        *oS++ = lastChar;
        ioout();
    }
    inline void write(char lastChar, char x) {
        *oS++ = x;
        *oS++ = lastChar;
        ioout();
    }
    template <typename Type, typename... Args>
    inline void write(char midChar, Type t, Args... args) {
        write(midChar, t), write(midChar, args...);
    }
}  // namespace Fast_IO

using Fast_IO::read;
using Fast_IO::write;

const int SIZE = 5e4 + 5;
namespace ChainForwardStar {
	const int SIZE = ::SIZE;
	int tot_, Vert[SIZE];
	int Head[SIZE], Next[SIZE];
	
	void AddLine(int x, int y) {
		Vert[++tot_] = y;
		Next[tot_] = Head[x];
		Head[x] = tot_;
	}
} // namespace ChainForwardStar

using CFS::Head;
using CFS::Vert;
using CFS::Next;
using CFS::AddLine;

namespace TreeChainSplitting {
	const int SIZE = ::SIZE;
	const int MOD = 201314;
	int n, m, tot, d[SIZE];
	int fa[SIZE], size[SIZE];
	int son[SIZE], top[SIZE];
	int dfn[SIZE], rnk[SIZE];
	int ask[SIZE], ans[SIZE];
	vector < int > GFY[SIZE];
	vector < int > FI[SIZE];
	int sum[SIZE << 2], lf[SIZE << 2];
	
	void Prepare(int x) {
		size[x] = 1, d[x] = d[fa[x]] + 1;
		for (ForGraph)
			Prepare(y), size[x] += size[y], CheckSize;
	}
	
	void Prepare(int x, int tp) {
		rnk[dfn[x] = ++tot] = x, top[x] = tp;
		if (son[x]) Prepare(son[x], tp);
		for (ForGraph) if (y ^ son[x]) Prepare(y, y);
	}
	
	#define ls (k << 1)
	#define rs (k << 1 | 1)
	#define L_RECUR ls, l, mid, x, y
	#define R_RECUR rs, mid + 1, r, x, y
	#define UpdateSons(k, l, r) if (lf[k]) sum[ls] = (sum[ls] + 1LL * lf[k] * (mid - l + 1) % MOD) % MOD,					\
								sum[rs] = (sum[rs] + 1LL * lf[k] * (r - mid) % MOD) % MOD, lf[ls] += lf[k],					\
								lf[rs] += lf[k], lf[k] = 0
	#define UpdateMessages(k) sum[k] = (sum[ls] + sum[rs]) % MOD
	void ModifyChain(int k, int l, int r, int x, int y) {
		if (l >= x && r <= y) sum[k] = (sum[k] + r - l + 1) % MOD, ++lf[k];
		else {
			UpdateSons(k, l, r);
			if (mid >= x) ModifyChain(L_RECUR);
			if (mid < y) ModifyChain(R_RECUR);
			UpdateMessages(k);
		}
	}
	
	void ModifySubTree(int x) {
		if (x) ModifyChain(1, 1, n, dfn[top[x]], dfn[x]), ModifySubTree(x = fa[top[x]]);
	}
	
	int QueryChain(int k, int l, int r, int x, int y, int res = 0) {
		if (l >= x && r <= y) return sum[k];
		UpdateSons(k, l, r);
		if (mid >= x) res += QueryChain(L_RECUR, 0);
		if (mid < y) res += QueryChain(R_RECUR, 0);
		return res;
	}
	
	int QuerySubTree(int x, int res = 0) { // luogu-only 
		if (x) QuerySubTree((res += QueryChain(1, 1, n, dfn[top[x]], dfn[x]), x = fa[top[x]]), res); else return res;
	}
	
//	int QuerySubTree(int x, int res = 0) { // loj-only
//		while (x) {
//			res += QueryChain(1, 1, n, dfn[top[x]], dfn[x]);
//			x = fa[top[x]];
//		}
//		return res;
//	}
} // namespace TreeChainSplitting

namespace ProblemSolver {
	void main() {
		read(TCS::n), read(TCS::m);
		for (int i = 2; i <= TCS::n; ++i) read(TCS::fa[i]), AddLine(++TCS::fa[i], i);
		TCS::Prepare(1), TCS::tot = 0, TCS::Prepare(1, 1);
		int L, R;
		for (int i = 1; i <= TCS::m; ++i) read(L, R, TCS::ask[i]), TCS::FI[L].push_back(i), TCS::GFY[R + 1].push_back(i), ++TCS::ask[i];
		for (int i = 1; i <= TCS::n; ++i) {
			TCS::ModifySubTree(i);
			for (auto it : TCS::GFY[i]) TCS::ans[it] += TCS::QuerySubTree(TCS::ask[it]);
			for (auto it : TCS::FI[i]) TCS::ans[it] -= TCS::QuerySubTree(TCS::ask[it]);
		}
		for (int i = 1; i <= TCS::m; ++i) write(io_l, (TCS::ans[i] % TCS::MOD + TCS::MOD) % TCS::MOD);
	}
} // namespace ProblemSolver

signed main() {
	PS::main();
}
```

---


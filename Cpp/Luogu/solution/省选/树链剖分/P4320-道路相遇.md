# 道路相遇

## 题目描述

在 H 国的小 w 决定到从城市 $u$ 到城市 $v$ 旅行，但是此时小 c 由于各种原因不在城市 $u$，但是小 c 决定到在中途与小 w 相遇

由于 H 国道路的原因，小 w 从城市 $u$ 到城市 $v$ 的路线不是固定的，为了合理分配时间，小 c 想知道从城市 $u$ 到城市 $v$ 有多少个城市小 w 一定会经过，特别地，$u, v$ 也必须被算进去，也就是说无论如何答案不会小于 2

由于各种特殊的原因，小 c 并不知道小 w 的起点和终点，但是小 c 知道小 w 的起点和终点只有 $q$ 种可能，所以对于这 $q$ 种可能，小 c 都想知道小 w 一定会经过的城市数

H 国所有的边都是无向边，两个城市之间最多只有一条道路直接相连，没有一条道路连接相同的一个城市

任何时候，H 国不存在城市 $u$ 和城市 $v$ 满足从 $u$ 无法到达 $v$

## 说明/提示

从城市 $1$ 到城市 $5$ 总共有 $4$ 种可能 : 

$1 \to 2 \to 3 \to 4 \to 5$

$1 \to 2 \to 3 \to 5$

$1 \to 3 \to 4 \to 5$

$1 \to 3 \to 5$

可以发现小 w 总会经过城市 $1,3,5$，所以答案为 $3$

你可以认为小 w 不会经过相同的城市两次，当然，如果你认为可以经过相同的城市两次也不会影响答案

subtask1 : 15分，$m = 5, q = 50$

subtask2 : 15分，$n = 100, q = 5000$

subtask3 : 20分，$n = 3000, q = 5\times 10^5$

subtask4 : 20分，$n = 499999, q = 5 \times 10^5, m = n-1$

subtask5 : 30分，$n = q = 5 \times 10^5$

对于所有数据 : $1\leq n\leq 5 \times 10^5, 1\leq q\leq 5\times 10^5, 1\leq m\leq \min(\frac{n(n-1)}{2}, 10^6)$

## 样例 #1

### 输入

```
5 6
1 2
1 3
2 3
3 4
4 5
3 5
1
1 5```

### 输出

```
3```

# 题解

## 作者：中国飞鱼 (赞：22)

大家观察一张图

![](http://images.cnblogs.com/cnblogs_com/sdzwyq/1268719/o_%e5%9c%86%e6%96%b9%e6%a0%91.png)

有什么发现?

**必经点数==圆方树上两点路径上圆点数**

也就等于**边数/2+1**

于是对图建出广义圆方树(怎么建?$tarjan$求点双,在一个点双里的向一个新建的方点连边即可)

然后树剖求$lca$,答案就是$(dep[u]+dep[v]-2*dep[lca])/2+1$

亲测树剖时间是倍增一半

```
#define il inline
#define ri register int
#include<iostream>
using namespace std;
const int N=1e6+5,M=4e6+5;
il int re(){
    ri x=0,w=1;register char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
    return x*w;
}
int n,E,m,ts,tp,tot;
int dfn[N],low[N],st[N],dep[N],top[N],sz[N],son[N],fa[N];
struct Graph{
    int cnt,last[N],nxt[M],to[M];
    il void link(ri u,ri v){
        nxt[++cnt]=last[u];to[cnt]=v;last[u]=cnt;
        nxt[++cnt]=last[v];to[cnt]=u;last[v]=cnt;
    }
}G,T;
void tarjan(ri u){
    dfn[u]=low[u]=++ts;st[++tp]=u;
    for(ri i=G.last[u],v;i;i=G.nxt[i]){
        v=G.to[i];
        if(!dfn[v]){
            tarjan(v);
            low[u]=min(low[u],low[v]);
            if(low[v]>=dfn[u]){
                T.link(++tot,u);
                ri x=0;
                do{
                    x=st[tp--];T.link(tot,x);
                }while(x!=v);
            }
        }
        else low[u]=min(low[u],dfn[v]);
    }
}
void dfs1(ri u){
    sz[u]=1;
    for(ri i=T.last[u],v;i;i=T.nxt[i]){
        v=T.to[i];
        if(v==fa[u])continue;
        dep[v]=dep[u]+1;
        fa[v]=u;
        dfs1(v);
        sz[u]+=sz[v];
        if(sz[v]>sz[son[u]])son[u]=v;
    }
}
void dfs2(ri u,ri Tp){
    top[u]=Tp;
    if(son[u])dfs2(son[u],Tp);
    for(ri i=T.last[u],v;i;i=T.nxt[i]){
        v=T.to[i];
        if(v==son[u]||v==fa[u])continue;
        dfs2(v,v);
    }
}
il int Query(ri x,ri y){
    while(top[x]!=top[y]){
        if(dep[top[x]]<dep[top[y]])swap(x,y);
        x=fa[top[x]];
    }
    return dep[x]<dep[y]?x:y;
}
int main(){
    tot=n=re(),E=re();
    for(ri i=1,u,v;i<=E;i++){
        u=re(),v=re();
        G.link(u,v);
    }
    tarjan(1);
    dep[1]=1;dfs1(1);dfs2(1,1);
    m=re();
    ri u,v,lca;
    while(m--){
        u=re(),v=re();
        lca=Query(u,v);
        printf("%d\n",(dep[u]+dep[v]-2*dep[lca])/2+1);
    }
    return 0;
}
```

---

## 作者：NaCly_Fish (赞：17)

这题怎么能没有我大LCT的题解呢？  
虽然有人发过一篇，但还是用的tarjan算法，并没有完全地使用LCT。  
这里给出我的解法。  
****  
按照一般的做法，需要构造圆方树。   
那这个东西我们也可以用LCT来维护。  

一开始图上有$n$个点，都是圆点(即权为$1$的点)  
若有一条边要连上$u,v$两个点，分两种情况讨论：  

- 若未连通，直接将$u,v$两点连上。  
- 若已经连通，则会复杂一些：需要把$u$到$v$上的所有边断掉，然后再把路径上的所有点都连向一个方点(即$0$权点)。

好了那怎么找出这条路径呢？  
按照一般路径查询的套路，我们使用$\texttt{split(u,v)}$，然后再进行操作。  
这个时候，路径上的所有点都在这棵$\texttt{splay}$里面了，只需要按右$\rightarrow$根$\rightarrow$左的顺序遍历，就能把路径上的点找出来啦！  
不过遍历时要注意一点，需要先$\texttt{pushdown}$一下，把翻转标记传下去。

具体代码实现是这个样子的：  
```cpp
void dfs(int u){
	pushdown(u);
	if(son[u][1]) dfs(son[u][1]);
	stack[++cnt] = u; //最后这个stack里面存的就是路径上的点
	if(son[u][0]) dfs(son[u][0]);    
}

inline void find_path(int u,int v){
	split(u,v);
	cnt = 0;
	dfs(v);    
}
```

剩下就没什么好说的了，直接上个LCT板子就过啦  
ps：常数巨大  
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<vector>
#define ll long long
#define N 2000007
#define reg register
#define ls son[u][0]
#define rs son[u][1]
using namespace std;

int uf[N];
int n,m,q,img,top;

inline void read(int &x);
void print(int x);
inline int find(int x);

struct Link_Cut_Tree{
    int s[N],st[N],r[N];
    int fa[N],son[N][2],a[N],st2[N];

    inline bool notroot(int u){
        return son[fa[u]][0]==u||son[fa[u]][1]==u;
    }

    inline void pushup(int u){
        s[u] = s[ls]+s[rs]+a[u];
    }

    inline void pushr(int u){
        swap(ls,rs);
        r[u] ^= 1;
    }

    inline void pushdown(int u){
        if(!r[u]) return;
        if(ls) pushr(ls);
        if(rs) pushr(rs);
        r[u] = 0;
    }

    inline void rotate(int x){
        int y = fa[x],z = fa[y];
        int k = son[y][1]==x,w = son[x][k^1];
        if(notroot(y)) son[z][son[z][1]==y] = x;
        son[x][k^1] = y;
        son[y][k] = w;
        if(w) fa[w] = y;
        fa[y] = x,fa[x] = z;
        pushup(y);
    }

    inline void splay(int x){
        int y = x,z = 0;
        st[++z] = y;
        while(notroot(y)) st[++z] = y = fa[y];
        while(z) pushdown(st[z--]);
        while(notroot(x)){
            y = fa[x],z = fa[y];
            if(notroot(y)){
                if((son[z][1]==y)==(son[y][1]==x)) rotate(y);
                else rotate(x);
            }
            rotate(x);
        }
        pushup(x);
    }

    inline void access(int u){
        for(reg int y=0;u;u=fa[u]){
            splay(u);
            rs = y;
            pushup(u);
            y = u;
        }
    }

    inline void makeroot(int u){
        access(u),splay(u);
        pushr(u);
    }
    
    inline int findroot(int u){
        access(u),splay(u);
        while(ls){
            pushdown(u);
            u = ls;
        }
        splay(u);
        return u;
    }
    
    inline void split(int u,int v){
        makeroot(u);
        access(v),splay(v);
    }

    inline void link(int u,int v){
        makeroot(u);
        fa[u] = v;
    }

    inline void cut(int u,int v){
        makeroot(u);
        if(findroot(v)!=u||fa[v]!=u||son[v][0]) return;
        fa[v] = son[u][1] = 0;
        pushup(u);
    }

    inline int query(int u,int v){
        split(u,v);
        return s[v];
    }

    void divide(int u){
        pushdown(u);
        if(rs) divide(rs);
        st2[++top] = u;
        if(ls) divide(ls);
    }

    inline void rebuild(int u,int v,int w){
        split(u,v); 
        top = 0;
        divide(v);
        for(reg int i=1;i<top;++i) cut(st2[i],st2[i+1]); //把原先路径上的边都断掉
        for(reg int i=1;i<=top;++i) link(st2[i],w); //连到一个方点上去
    }
}T;

int main(){
    int u,v;
    read(n),read(m);
    for(reg int i=1;i<=n;++i){
        uf[i] = i;
        T.a[i] = 1; //初始的n个点权值都是1
    }
    img = n+1;
    for(reg int i=1;i<=m;++i){
        read(u),read(v);
        if(find(u)==find(v)){
            if(T.query(u,v)<=2) continue; //剪枝优化: 如果除了端点,剩下的都是方点,就可以直接跳过,无需操作
            T.rebuild(u,v,img++);
        }else{
            T.link(u,v);
            uf[find(u)] = find(v);
        }
    }
    read(q);
    while(q--){
        read(u),read(v);
        print(T.query(u,v));
        putchar('\n');
    }
    return 0;
}

inline int find(int x){
    while(x^uf[x]) x = uf[x] = uf[uf[x]];
    return x;
}

inline void read(int &x){
    x = 0;
    char c = getchar();
    while(c<'0'||c>'9') c = getchar();
    while(c>='0'&&c<='9'){
        x = (x<<3)+(x<<1)+(c^48);
        c = getchar();
    }
}

void print(int x){
    if(x>9) print(x/10);
    putchar(x%10+'0');
}
```

ps ps：关于复杂度的势能分析(不严谨)证明   

设这棵树一开始的势能为$n$。  
每次进行$\texttt{rebuild}$操作时，假设断了$x$条边，操作复杂度为$\Theta(x\log n)$  
但与此同时，又有一条长度为$x$的链消失了，取而代之的是$x$条长度为$1$的链。  
这样就可以看做是它的势能降低了$x$。  

我们发现对于$\texttt{rebuild}$操作，最多断$n$次、连$n$次边，它的势能降到最低，也就是不会再$\texttt{rebuild}$了。  
于是我们的复杂度就是$\Theta((n+q)\log n)$的。


---

## 作者：TKXZ133 (赞：9)

[道路相遇](https://www.luogu.com.cn/problem/P4320)

### 题意简述

给定一张无向图和若干询问，每次询问两点之间所有路径必经过的点的数量。

### 思路分析

在图上不好处理，我们先考虑在树上的情况。

在树上时，由于两点之间只有唯一路径，所以必经点的数量就是路径上点的数量，只需要求出两点的 $\text{LCA}$ 即可。

但当问题在图上时，就麻烦了起来。因此我们可以思考一下如何将在图上的情况转化为在树上的情况。

我们发现，有一种叫做圆方树的神奇的东西可以帮助我们解决这个问题。

#### 什么是圆方树？

圆方树是一种将图变为树的方法，它一般用于处理仙人掌，但有时也可以在一般的无向图上使用。

#### 圆方树能干吗？

我们知道，许多问题在树上有着优秀的解法，比一般图上的问题简单很多。而圆方树就可以将一张图变成树，以获得优秀的时间复杂度。

#### 圆方树怎么用？

首先，我们需要在图上建立一颗圆方树。

一张图：

![](https://i.328888.xyz/2023/01/22/OEwMH.md.png)

它的圆方树：

![](https://i.328888.xyz/2023/01/22/OEHnQ.md.png)

圆方树由两种点构成：圆点和方点，且相同类型的点不直接相连。

其中，圆点都是原图中的点，而方点则是新建的点。

#### 具体建法：

首先，我们需要找到图中的所有**点双连通分量**。

然后对于每个点双连通分量建一个新的点，将所有的该点双连通分量中的点在新图中将这个新的点连边。

然后就没有然后了。

所以可以容易的写出代码：

```
void tarjan(int s){//找点双连通分量的过程利用tarjan
    low[s]=dfnt[s]=++cnt;
    sk[++tt]=s;//入栈
    for(int i=head[s];i;i=nxt[i]){
        int v=to[i];
        if(!dfnt[v]){
            tarjan(v);
            low[s]=min(low[s],low[v]);
            if(low[v]==dfnt[s]){//发现了点双连通分量
                num++;//新的点的编号
                for(int x=0;x!=v;tt--){
                    x=sk[tt];
                    add(nhead,x,num);
                    add(nhead,num,x);//在新图中建边
                }
                add(nhead,s,num);
                add(nhead,num,s);//这个点本身也要建边，但不能出栈
            }
        }
        else low[s]=min(low[s],dfnt[v]);//更新
    }
}

```

那么，在将图转化为了圆方树之后，我们应该如何处理原有的问题呢？

我们经过观察，可以发现，我们问题的答案就是在圆方树上两点间的圆点数量！

那么这就容易了，我们在圆方树上将圆点的权值设为 $1$，方点的权值设为 $0$，问题就变成了询问树上两点间所有点的权值和。

预处理后用树剖或倍增跑 $\text{LCA}$ 就好了。（当然，如果你想用线段树也可以）

### 注意事项

圆方树中点的数量不超过 $2n$，所以数组开双向边的双倍。

如果图不连通，还需要对每个连通块跑一边 $\text{tarjan}$ 和树剖。

### 代码实现

```
#include <bits/stdc++.h>
using namespace std;
const int N=6666666;//六倍空间（原图新图一起建）

int to[N],nxt[N],head[N],w[N],nhead[N];
int idx,n,m,q,in1,in2,cnt,tt,num;
int dfn[N],rnk[N],son[N],top[N],siz[N],dep[N],fa[N];
int low[N],dfnt[N],sk[N];
int sum[N];

void add(int h[],int u,int v){idx++;to[idx]=v;nxt[idx]=h[u];h[u]=idx;}
void Swap(int &x,int &y){int t=x;x=y;y=t;}

void tarjan(int s){
    low[s]=dfnt[s]=++cnt;
    sk[++tt]=s;
    for(int i=head[s];i;i=nxt[i]){
        int v=to[i];
        if(!dfnt[v]){
            tarjan(v);
            low[s]=min(low[s],low[v]);
            if(low[v]==dfnt[s]){
                num++;
                for(int x=0;x!=v;tt--){
                    x=sk[tt];
                    add(nhead,x,num);
                    add(nhead,num,x);
                    w[x]=1;//点权赋为1
                }
                add(nhead,s,num);
                add(nhead,num,s);
                w[s]=1;
            }
        }
        else low[s]=min(low[s],dfnt[v]);
    }
}

void dfs_1(int s,int gr){//常规树剖
    dep[s]=dep[gr]+1;fa[s]=gr;
    siz[s]=1;son[s]=-1;
    for(int i=nhead[s];i;i=nxt[i]){
        int v=to[i];
        if(v==gr) continue;
        dfs_1(v,s);
        siz[s]+=siz[v];
        if(son[s]==-1||siz[v]>siz[son[s]]) son[s]=v;
    }
}

void dfs_2(int s,int tp){
    top[s]=tp;dfn[s]=++cnt;rnk[cnt]=s;
    if(son[s]==-1) return ;
    dfs_2(son[s],tp);
    for(int i=nhead[s];i;i=nxt[i]){
        int v=to[i];
        if(v==fa[s]||v==son[s]) continue;
        dfs_2(v,v);
    }
}

void dfs_3(int s){//常规预处理
    sum[s]=sum[fa[s]]+w[s];
    for(int i=nhead[s];i;i=nxt[i]){
        int v=to[i];
        if(v==fa[s]) continue;
        dfs_3(v);
    }
}

int lca(int x,int y){//常规lca
    while(top[x]!=top[y]){
        if(dep[top[x]]<dep[top[y]]) Swap(x,y);
        x=fa[top[x]];
    }
    return dep[x]>dep[y]?y:x;
}

int main(){
    scanf("%d%d",&n,&m);num=n;//方点的编号从n开始
    for(int i=1;i<=m;i++){
        scanf("%d%d",&in1,&in2);
        add(head,in1,in2);
        add(head,in2,in1);//原图中建边
    }
    for(int i=1;i<=n;i++)
        if(!dfn[i]) tarjan(i),tt--;//跑tarjan，每次跑完需将栈顶出栈
    cnt=0;
    dfs_1(1,0);dfs_2(1,1);dfs_3(1);//跑树剖，预处理
    scanf("%d",&q);
    while(q--){
        scanf("%d%d",&in1,&in2);
        int LCA=lca(in1,in2);
        cout<<sum[in1]+sum[in2]-sum[LCA]-sum[fa[LCA]]<<'\n';//算路径上点的权值，用差分
    }
    return 0;
}
```

### 其他

类似的题目：[Tourists](https://www.luogu.com.cn/problem/CF487E)，[Traffic Real Time Query System](https://www.luogu.com.cn/problem/UVA1464)。

---

## 作者：rainygame (赞：7)

## 前言

终于会圆方树了，写篇题解纪念一下。感觉这种东西确实非常巧妙。

**前置知识：[点双连通分量](https://www.luogu.com.cn/problem/P8435)。**

### 定义

- 连通图：任意两个结点都可以相互到达的**无向图**。
- 割点：一张连通图中，如果删去一个点会导致图不连通，则这条边就称为**割点**。
- 点双连通图：一个**没有割点**的连通图。
- 点双连通分量：极大的点双连通子图。（以下简称“点双”）

## 算法过程

### 圆方树的定义

在圆方树中，原来的每个点对应一个**圆点**，每一个点双对应着一个**方点**。

对于每一个点双，新建一个方点，并对这个点双内的所有点连边，并把原来点双内的边删去（点双的性质：一条边最多属于一个点双）。

具体的可以看下面的图加深理解：

![](https://cdn.luogu.com.cn/upload/image_hosting/o9jgt0uo.png)

一些性质：

- 如果原图有 $n$ 个结点，那么圆方树的点数不会超过 $2n$。
- 当原图连通时圆方树才是树。否则若图有 $k$ 个连通分量，那么圆方**森林**呈一个由 $k$ 棵树形成森林。
- 一条边一定连接着一个圆点和一个方点。

**注意圆方森林需要谨慎考虑孤立点的情况！**（本题保证连通，不用考虑）

建立一颗圆方树也非常简单，删去对孤立点的特判之后，直接按照定义建树即可。代码如下：

```cpp
void tarjan(int x){
	dfn[x] = low[x] = ++cnt;
	st.push(x);
	for (auto i: e[x]){
		if (!dfn[i]){
			tarjan(i);
			low[x] = min(low[x], low[i]);
			if (low[i] == dfn[x]){
				++ssum;
				t[ssum].push_back(x);
				t[x].push_back(ssum);
				while (st.top() != i){
					t[st.top()].push_back(ssum);
					t[ssum].push_back(st.top());
					st.pop();
				}
				t[ssum].push_back(i);
				t[i].push_back(ssum);
				st.pop();
			}
		}else low[x] = min(low[x], dfn[i]);
	}
}
```

### 圆方树与本题的联系

说了这么多，所以圆方树到底有什么用？

我们可以发现方点和方点之间一定以一个圆点相连，且这个点一定是两点双之间的**割点**。

我们再次分析题目，发现题目就是在求 $(u,v)$ 之间的**割点**。

所以显而易见地，题目就是在求 $(u,v)$ 树上简单路径的圆点的个数。可以看出，在部分情况下，把无向连通图转化成圆方树可以更简单地解决问题（毕竟树有着更多地性质）。

因为起点和终点均为圆点，所以答案即为 $\lceil\dfrac{\texttt{简单路径长度}}{2}\rceil$。（和圆点相连的点必为方点，和方点相连的点必为圆点）

时间复杂度 $O(n+q \log n)$。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define MAXN 500001

int n, m, q, u, v, cnt, ssum, res;
int id[MAXN<<1];
int dfn[MAXN], low[MAXN];
int dep[MAXN<<1], fa[MAXN<<1], top[MAXN<<1], siz[MAXN<<1], son[MAXN<<1];
vector<int> e[MAXN], t[MAXN<<1];
stack<int> st;

void tarjan(int x){
	dfn[x] = low[x] = ++cnt;
	st.push(x);
	for (auto i: e[x]){
		if (!dfn[i]){
			tarjan(i);
			low[x] = min(low[x], low[i]);
			if (low[i] == dfn[x]){
				++ssum;
				t[ssum].push_back(x);
				t[x].push_back(ssum);
				while (st.top() != i){
					t[st.top()].push_back(ssum);
					t[ssum].push_back(st.top());
					st.pop();
				}
				t[ssum].push_back(i);
				t[i].push_back(ssum);
				st.pop();
			}
		}else low[x] = min(low[x], dfn[i]);
	}
}

void dfs1(int x, int f){
	fa[x] = f;
	dep[x] = dep[f] + 1;
	siz[x] = 1;
	for (auto i: t[x]){
		if (i != f){
			dfs1(i, x);
			siz[x] += siz[i];
			if (siz[son[x]] < siz[i]) son[x] = i;
		}
	}
}

void dfs2(int x, int tp){
	top[x] = tp;
	if (!son[x]) return;
	dfs2(son[x], tp);
	for (auto i: t[x]){
		if (i != fa[x] && i != son[x]) dfs2(i, i);
	}
}

int LCA(int x, int y){
	while (top[x] != top[y]){
		if (dep[top[x]] < dep[top[y]]) swap(x, y);
		x = fa[top[x]];
	}
	if (dep[x] < dep[y]) return x;
	return y;
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    cin >> n >> m;
    while (m--){
    	cin >> u >> v;
    	e[u].push_back(v);
    	e[v].push_back(u);
	}
	
	ssum = n;
	tarjan(1);
	dfs1(1, 0);
	dfs2(1, 1);
	
	cin >> q;
	while (q--){
		cin >> u >> v;
		cout << ((dep[u]+dep[v]-(dep[LCA(u, v)]<<1)+1)>>1) + 1 << '\n';
	}

    return 0;
}

```


---

## 作者：Engulf (赞：6)

> 给定一个无向连通图，$q$ 个询问，每次询问给出 $x,y$，求 $x\rightarrow y$ 路径上**必经**的点的个数（包括 $x$ 和 $y$）。

先看一下样例（样例说明有误，根本没有 $1\rightarrow 2\rightarrow 4\rightarrow 5$ 的路径）

![](https://cdn.luogu.com.cn/upload/image_hosting/gosqfhte.png)

显然，$1,3,5$ 这 $3$ 个点是必定会经过的。

## 前置芝士

- 点双连通分量
- 广义圆方树
- 树链剖分

## 分析

先来回顾一下点双连通分量的定义是什么。

> 一个点双连通图的一个定义是：

> 图中任意两不同点之间都有至少两条点不重复的路径。

> 点不重复既指路径上点不重复（简单路径），也指两条路径的交集为空（当然，路径必然都经过出发点和到达点，这不在考虑范围内）。

> 而一个图的**点双连通分量**则是一个**极大点双连通子图**。

以上内容摘自：[【算法学习】圆方树 - 粉兔](https://www.cnblogs.com/PinkRabbit/p/Introduction-to-Block-Forest.html)。

更通俗的说，点双就是**没有割点**的图。

那我们就可以对原图缩点，构建圆方树，把每个点双缩成一个方点，再看下图：

![](https://oi-wiki.org/graph/images/block-forest3.svg)

图片来源：[圆方树 - OI Wiki](https://oi-wiki.org/graph/block-forest/)。

此时，原图已经转换为树。那么，我们将问题成功地转换为了**求 $x,y$ 间的圆点数量**。

对圆方树进行树链剖分，圆点赋值为 $1$，方点不管（不是必经的），再用线段树维护一下即可。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;

namespace fastIO
{
	template<typename T> inline void read(T &t)
	{
		T x = 0;
		int f = 0;
		char ch = getchar();
		while (!isdigit(ch)) f ^= !(ch ^ 45), ch = getchar();
		while (isdigit(ch)) x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
		t = f ? -x : x;
	}
	template<typename T, typename ... Args> inline void read(T &x, Args&... args)
	{
		read(x), read(args...);
	}
}
using namespace fastIO;

const int N = 2 * (5e5 + 10);
vector<int> g[N];
vector<int> BF[N];

int dfn[N], low[N], idx, stk[N], tp;
int tot;
int a[N];

int n, m, q;

void tarjan(int u)
{
	dfn[u] = low[u] = ++ idx;
	stk[ ++ tp] = u;
	for (int v: g[u])
	{
		if (!dfn[v])
		{
			tarjan(v);
			low[u] = min(low[u], low[v]);
			if (low[v] == dfn[u])
			{
				a[ ++ tot] = 0;
				for (int x = 0; x != v; tp -- )
				{
					x = stk[tp];
					BF[tot].push_back(x);
					BF[x].push_back(tot);
				}
				BF[tot].push_back(u);
				BF[u].push_back(tot);
			}
		}
		else low[u] = min(low[u], dfn[v]);
	}
}

int fa[N], son[N], siz[N], dep[N];
int top[N], id[N], w[N];
void dfs1(int u, int f)
{
	fa[u] = f, dep[u] = dep[f] + 1;
	siz[u] = 1;
	for (int v: BF[u])
	{
		if (v != f)
		{
			dfs1(v, u);
			siz[u] += siz[v];
			if (siz[v] > siz[son[u]]) son[u] = v;
		}
	}
}
void dfs2(int u, int tp)
{
	top[u] = tp;
	id[u] = ++ idx;
	w[idx] = a[u];
	if (son[u]) dfs2(son[u], tp);
	for (int v: BF[u])
		if (!id[v])
			dfs2(v, v);
}

int sum[N << 2];
#define ls (p << 1)
#define rs (p << 1 | 1)
#define mid (l + r >> 1)
#define lson ls, l, mid
#define rson rs, mid + 1, r

void build(int p, int l, int r)
{
	if (l == r)
	{
		sum[p] = w[l];
		return;
	}
	build(lson);
	build(rson);
	sum[p] = sum[ls] + sum[rs];
}
int query(int p, int l, int r, int L, int R)
{
	if (L <= l && r <= R) return sum[p];
	int res = 0;
	if (L <= mid) res += query(lson, L, R);
	if (mid < R) res += query(rson, L, R);
	return res;
}
int query(int x, int y)
{
	int res = 0;
	while (top[x] != top[y])
	{
		if (dep[top[x]] < dep[top[y]]) swap(x, y);
		res += query(1, 1, tot, id[top[x]], id[x]);
		x = fa[top[x]];
	}
	if (dep[x] > dep[y]) swap(x, y);
	res += query(1, 1, tot, id[x], id[y]);
	return res;
}

int main()
{
	read(n, m);
	tot = n;
	for (int i = 1, x, y; i <= m; i ++ )
	{
		read(x, y);
		g[x].push_back(y), g[y].push_back(x);
	}
	for (int i = 1; i <= n; i ++ ) a[i] = 1;
	tarjan(1), idx = 0, dfs1(1, 0), dfs2(1, 1);
	build(1, 1, tot);
	read(q);
	while (q -- )
	{
		int x, y;
		read(x, y);
		printf("%lld\n", query(x, y));
	}
	return 0;
}
```

---

## 作者：Mr_Avalon (赞：5)

**题目分析**

首先我们很容易发现，对于两个点来说，必经的点只有路径上的割点以及它们本身。

我们考虑删掉一个点。如果它是割点，删掉它之后要求的两点之间就不连通了，所以割点都是必经的；如果它不是割点，删掉它之后我们依然可以找到另一条路径使两点连通，所以非割点都是不必经的。于是问题就转化成了**求两点之间割点的数量**。

要维护割点的数量，我们可以对图建出**圆方树**，两点在圆方树上的方点数量就是它们之间割点的数量，因为圆方树上的方点和它所连的圆点实际上代表了一个点双。而我们知道从一个点双到另一个点双中间一定经过了一个割点，否则这两个点双可以合并成一个更大的点双。

于是我们对图建出圆方树，在树上查询方点数量就行了。

**代码**

```cpp
#include<cstdio>

const int N=1e6+5;

inline int read()
{
	int v=0;char ch=getchar();
	while('0'>ch||ch>'9') ch=getchar();
	while('0'<=ch&&ch<='9') v=v*10+(ch^48),ch=getchar();
	return v;
}

inline int min(int a,int b) {return a<b? a:b;}

int n,m,q;

struct Tree
{
    #define findson(x) for(int i=first[x],p;i;i=nxt[i]) if((p=to[i])^fa[x])

    int tot;

	int cnt,first[N],nxt[N<<1],to[N<<1];
	inline void add(int u,int v) 
	{
		to[++cnt]=v,nxt[cnt]=first[u],first[u]=cnt;
		to[++cnt]=u,nxt[cnt]=first[v],first[v]=cnt;
	}

	int sz[N],fa[N],son[N],dep[N],sum[N];
	inline void dfs1(int x)
	{
        dep[x]=dep[fa[x]]+(sz[x]=1),sum[x]=sum[fa[x]]+(x<=n);
        findson(x)
		{
			fa[p]=x,dfs1(p),sz[x]+=sz[p];
			son[x]=sz[son[x]]>sz[p]? son[x]:p;
		}
	}

    int top[N];
	inline void dfs2(int x,int _top)
	{
		top[x]=_top;
        if(son[x]) dfs2(son[x],_top);
		findson(x) if(p^son[x]) dfs2(p,p);
	}
	
	inline int lca(int x,int y)
	{
		while(top[x]^top[y]) 
		if(dep[top[x]]<dep[top[y]]) y=fa[top[y]];
		else x=fa[top[x]];
		
		return dep[x]<dep[y]? x:y;
	}
	
	inline int dis(int x,int y) {int d=lca(x,y);return sum[x]+sum[y]-sum[d]-sum[fa[d]];}
}T;

struct Graph
{
	int cnt,first[N],nxt[N<<1],to[N<<1];
	inline void add(int u,int v) 
	{
		to[++cnt]=v,nxt[cnt]=first[u],first[u]=cnt;
		to[++cnt]=u,nxt[cnt]=first[v],first[v]=cnt;
	}

    int dfn[N],low[N],tot;
    int st[N],top;

    inline void tarjan(int x,int lst)
    {
        dfn[st[++top]=x]=low[x]=++tot;

        for(int i=first[x],p;i;i=nxt[i])
        if(!dfn[p=to[i]])
        {
            tarjan(p,x),low[x]=min(low[x],low[p]);
            if(low[p]>=dfn[x])
            {
                int block=++T.tot;T.add(block,x);
                while(st[top+1]^p) T.add(block,st[top--]);
            }
        }
        else if(p^lst) low[x]=min(low[x],dfn[p]);
    }
}G;

int main()
{
	T.tot=n=read(),m=read();
	for(int i=1;i<=m;i++) G.add(read(),read());
	for(int i=1;i<=n;i++) if(!G.dfn[i]) G.tarjan(i,0);

	T.dfs1(1),T.dfs2(1,1);

	q=read();
	while(q--) printf("%d\n",T.dis(read(),read()));
}
```


---

## 作者：tomtom (赞：3)

## 道路相遇

### 题目描述

跟你一张无向图，有$Q$次查询,每一次查询给定$(x,y)$，输出$x,y$之间的必经点个数。

### 题解

观察题目，发现必经点个数其实就是两点之间**割点**的个数。但是直接在原图上面不好处理。我们考虑对其进行点双缩点。缩点之后有一个好处，那就是原图被我们转换成了若干棵枝繁叶茂的大树！这个时候，查询就很好应对了。每一次询问，我们找到LCA，然后就可以快速地计算割点个数了。

代码：( 代码较丑，不喜勿喷（逃)

```cpp
#include<bits/stdc++.h>
const int N = 5e6 + 3,M = 5e6 + 3;
int n,m,q;

namespace IO
{
	inline char getChar()
	{
		static char buf[100000],*p1 = buf,*p2 = buf;
		return p1 == p2 && (p2 = (p1 = buf) +
			fread(buf,1,100000,stdin),p1 == p2) ? EOF : *p1++;
	}
	inline int read()
	{
		int s = 0,f  = 1; char ch;
		while(!isdigit(ch = getChar())) if(ch == '-') f = -1;
		while(isdigit(ch)) s = s * 10 + ch - '0',ch = getChar();
		return s * f;
	}
};
using namespace IO;

namespace Graph
{
	int ver[M << 1],head[N],nxt[M << 1],tot = 1;
	int nver[M << 1],nhead[N],nnxt[M << 1],ntot = 1;
	int newNum,w[N],val[N];

	inline void add(int* ver0,int* head0,int* nxt0,int& tot0,
			const int x,const int y)
	{
		ver0[++tot0] = y,nxt0[tot0] = head0[x],head0[x] = tot0;
		ver0[++tot0] = x,nxt0[tot0] = head0[y],head0[y] = tot0;
	}
};

using namespace Graph;

namespace Tarjan
{
	int dfn[N],low[N],cnt = 0,cut[N];
	int dcc = 0,bel[N];
	std::stack<int> st;
	std::vector<int> vec[N];
	using namespace std;
	void tarjan(int x,int root)
	{
		dfn[x] = low[x] = ++cnt;
		st.push(x);
		int flag = 0;
		for(int i = head[x];i;i = nxt[i]) {
			if(!dfn[ver[i]]) {
				tarjan(ver[i],root);
				low[x] = std::min(low[x],low[ver[i]]);
				if(low[ver[i]] >= dfn[x]) {
					if(++flag > 1 || x != root)
						cut[x] = 1;
					dcc++; int tmp;
					do {
						tmp = st.top(),st.pop();
						vec[dcc].push_back(tmp);
						bel[tmp] = dcc;
					} while(tmp != ver[i]);
					vec[dcc].push_back(x);
					bel[x] = dcc;
				}
			} else low[x] = std::min(low[x],dfn[ver[i]]);
		}
	}
	void getDcc()
	{
		for(int i = 1;i <= n;i++)
			if(!dfn[i]) tarjan(i,i);
		newNum = dcc;
		for(int i = 1;i <= n;i++)
			if(cut[i]) bel[i] = ++newNum,w[newNum] = 1;
		for(int i = 1;i <= dcc;i++) for(int j : vec[i])
			if(cut[j]) add(nver,nhead,nnxt,ntot,i,bel[j]);
	}
};
using namespace Tarjan;

namespace LCA
{
	int dep[N],fa[N][23],t;
	std::queue<int> que;
	inline int queryf(int x,int y)
	{
		if(dep[x] < dep[y]) std::swap(x,y);
		for(int i = t;i >= 0;i--)
			if(dep[fa[x][i]] >= dep[y]) x = fa[x][i];
		if(x == y) return x;
		for(int i = t;i >= 0;i--)
			if(fa[x][i] != fa[y][i]) x = fa[x][i],y = fa[y][i];
		return fa[x][0];
	}
	inline int query(int x,int y)
	{
		int fxy = queryf(x,y);
		return val[x] + val[y] - val[fxy] - val[fa[fxy][0]]
			- w[x] - w[y] + 2;
	}
	inline void bfs(int x)
	{
		que.push(x),dep[x] = 1; /*FIXME*/
		while(que.size()) {
			int x = que.front(); que.pop();
			for(int i = nhead[x];i;i = nnxt[i]) {
#define to nver[i]
				if(dep[to]) continue;
				dep[to] = dep[x] + 1;
				val[to] = val[x] + w[to];
				fa[to][0] = x;
				for(int j = 1;j <= t;j++)
					fa[to][j] = fa[fa[to][j - 1]][j - 1];
				que.push(to);
#undef to
			}
		}
	}

	inline void pre()
	{
		t = log2(newNum) + 1;
		for(int i = 1;i <= newNum;i++)
			if(!dep[i]) bfs(i);
	}
};
using namespace LCA;

int main()
{
#ifdef CLANG
	freopen("rtqs.in","r",stdin);
	freopen("rtqs.out","w",stdout);
#endif
	n = read(),m = read();
	for(int i = 1,u,v;i <= m;i++) {
		u = read(),v = read();
		add(ver,head,nxt,tot,u,v);
	}

	getDcc();
	pre();

	q = read();
	int x,y;
	while(q--) {
		x = read(),y = read();
		printf("%d\n",query(bel[x],bel[y]));
	}
	exit(0);
}


```

---

## 作者：xiezheyuan (赞：2)

[圆方树学习笔记，将于近期发布](https://www.cnblogs.com/zheyuanxie/p/block-forest.html)

## 简要题意

给出一个 $n$ 个点 $m$ 条边的无向图。$q$ 个询问，每个询问给出两个点 $u,v$。你需要输出对于所有 $u\to v$ 的路径都必须要经过的点的个数。

$1 \leq u,v \leq n \leq 5 \times 10^5,1 \leq q \leq 5\times 10^5,1 \leq m \leq 10^6$

## 思路

前置知识：[点双连通分量](https://www.luogu.com.cn/problem/P8435)、[LCA](https://www.luogu.com.cn/problem/P3379)。

首先考虑，怎么样的点一定会被经过。比如样例这张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/ptd0lzvb.png)

对于 $1\to5$ 这条路径，首先 $1,5$ 必定被经过，然后 $3$ 也必定被经过。然后这个 $3$ 节点的位置非常眼熟，它貌似是……割点。

但是不一定都是割点。不信的话可以画个图试验一下。但不妨碍我们往割点这方面想。

考虑必须要经过的点的定义，我们可以断掉一个点，将会不存在路径。也就是说，这是两个点双连通分量。

因此必须要经过的点就是：起点和终点，以及其中经过的每一个点双联通分量之间的公共点。

对于这种问题，我们可以使用圆方树。

圆方树上的点有两类，一类是圆点，这是原图中的点；一类是方点，这是我们新建的点。

具体来说对于每一个原图中的点双联通分量，我们建立一个方点，将其包含的所有点向这个点连一条边。

不难发现这是一棵树。

然后问题就转化成了树上任意两点所组成的路径的圆点个数。可以使用 LCA。

时间复杂度 $O(m+(n+q)\log n)$。

## 代码

用倍增的好少呀，其实倍增挺好写的……

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e6+5, M = 2e6+5;
int n,m;

struct edge{
    int nxt,to;    
} g[M],g2[M];
int head[N],low[N],dfn[N],ec,dfscnt,head2[N],low2[N],ec2,treecnt;
bool rectangle[N];

void add(int u,int v){
    if(u==v) return;
    g[++ec].nxt=head[u];
    g[ec].to=v;
    head[u]=ec;
}

void add2(int u,int v){
    // cout<<u<<' '<<v<<'\n';
    g2[++ec2].nxt=head2[u];
    g2[ec2].to=v;
    head2[u]=ec2;
}

stack<int> sta;

void tarjan(int u){
    low[u]=dfn[u]=(++dfscnt);sta.push(u);
    for(int i=head[u];i;i=g[i].nxt){
        int v=g[i].to;
        if(dfn[v]) low[u]=min(low[u],dfn[v]);
        else{
            tarjan(v);
            low[u]=min(low[u],low[v]);
            if(dfn[u]<=low[v]){
                rectangle[++treecnt]=1;
                while(sta.top()!=v){
                    add2(sta.top(),treecnt);add2(treecnt, sta.top());
                    sta.pop();
                }
                sta.pop();
                add2(u,treecnt);add2(treecnt, u);
                add2(v,treecnt);add2(treecnt, v);
            }
        }
    }
    
}

int fa[N][35],dis[N],dep[N];

void dfs(int u,int father){
    dep[u]=dep[father]+1;dis[u]=dis[father]+(u<=n);
    fa[u][0]=father;
    for(int i=1;i<=30;i++) fa[u][i]=fa[fa[u][i-1]][i-1];
    for(int i=head2[u];i;i=g2[i].nxt){
        int v=g2[i].to;
        if(v==father) continue;
        dfs(v,u);
    }
}

int lca(int u,int v){
    if(dep[u]<dep[v]) swap(u,v);
    for(int i=30;~i;i--){
        if(dep[fa[u][i]]>=dep[v]) u=fa[u][i];
    }
    if(u==v) return u;
    for(int i=30;~i;i--){
        if(fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i];
    }
    return fa[u][0];
}

signed main(){
    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
    cin>>n>>m;treecnt=n;
    for(int i=1,u,v;i<=m;i++){
        cin>>u>>v;
        add(u,v);add(v,u);
    }
    for(int i=1;i<=n;i++){
        if(!dfn[i]) tarjan(i);
    }
    dfs(1,0);
    int q;cin>>q;
    while(q--){
        int u,v,l;cin>>u>>v;l=lca(u,v);
        cout<<(dis[u]+dis[v]-(dis[l]*2)+(l<=n))<<'\n';
    }
    return 0;
}
```

---

## 作者：Arghariza (赞：1)

刚学了圆方树来做这道模板。

- 题意：

给定一个 $n$ 个点，$m$ 条边的无向图，对于 $q$ 个询问，每个询问给出两个数 $u,v$，求 $u$ 到 $v$ 所有路径上必须经过的点的数量。


- 做法：

既然是求路径上所有必须经过点的数量，那么考虑对于每个点双创建一个方点，每个点双内的点向这个方点连边，构建圆方树。

因为是一棵树的结构，所以它的信息我们容易处理。不难发现题目即求 $u\to v$ 路径上的圆点个数。于是对于每个圆点附加一个权值 $1$，每个方点的权值为 $0$，于是题目就转化为求 $u$ 到 $v$ 路径上的点的权值总和。

树上差分即可。注意当 $u,v$ 的 $\mathtt{LCA}$ 为圆点时答案也要加 $1$。

```cpp
const int maxn = 5e5 + 100;
int T, n, m, tot, cnt, dfc, tp, q, low[maxn], dfn[maxn], dis[maxn], st[maxn], w[maxn << 1], s[maxn];
int dep[maxn << 1], sz[maxn << 1], fa[maxn << 1], son[maxn << 1], top[maxn << 1], id[maxn << 1];
vector<int> g[maxn], t[maxn << 1];
void tarjan(int u) {
    dfn[u] = low[u] = ++cnt, st[++tp] = u;
    for (int v : g[u]) {
        if (dfn[v]) low[u] = min(low[u], dfn[v]);
        else {
            tarjan(v), low[u] = min(low[u], low[v]);
            if (low[v] == dfn[u]) {
                tot++; int x = 0;
                while (x != v) {
                    x = st[tp];
                    t[x].push_back(tot);
                    t[tot].push_back(x);
                    tp--;
                } 
                t[tot].push_back(u);
                t[u].push_back(tot);
            }
        }
    }
}
void dfs1(int u, int fat) {
    fa[u] = fat, dep[u] = dep[fat] + 1;
    sz[u] = 1, dis[u] = dis[fat] + w[u];
    for (int v : t[u]) {
        if (v == fat) continue;
        dfs1(v, u), sz[u] += sz[v];
        if (sz[v] > sz[son[u]]) son[u] = v;
    }
}
void dfs2(int u, int pre) {
    top[u] = pre, id[u] = ++dfc;
    if (son[u]) dfs2(son[u], pre);
    for (int v : t[u]) {
        if (v == fa[u] || v == son[u]) continue;
        dfs2(v, v);
    }
}
int lca(int u, int v) {
    while (top[u] != top[v]) {
        if (dep[top[u]] < dep[top[v]]) swap(u, v);
        u = fa[top[u]];
    }
    return dep[u] > dep[v] ? v : u;
}
int dist(int u, int v) {
    return dis[u] + dis[v] - 2 * dis[lca(u, v)];
}
int main() {
    n = tot = read(), m = read();
    for (int i = 1; i <= n; i++) w[i] = 1;
    for (int i = 1, u, v; i <= m; i++) {
        u = read(), v = read();
        g[u].push_back(v), g[v].push_back(u);
    }
    tarjan(1), dfs1(1, 0), dfs2(1, 1);
    q = read();
    while (q--) {
        int u = read(), v = read(), ans = 0;
        ans += dist(u, v);
        if (lca(u, v) <= n) ans++;
        write(ans), puts("");
    }
    return 0;
}
```

---

你以为结束了？~~想屁吃。~~

加强版：[[SDOI2018]战略游戏](https://www.luogu.com.cn/problem/P4606)

如果把两个点换成 $k$ 个点，怎么做？

前面同样是构造圆方树，然后圆点的权值为 $1$。

我们把 $k$ 个点按照 $dfn$ 序排序，记为 $s_1,s_2,...,s_k$，加上相邻两点的路径权值和，即 $\sum\limits_{i=1}^{k}sum_{s_i\to s_{i\%k-1}}$。

然后因为每条边被算了两次，所以总和要除以 $2$。

同样如果 $s_1,s_k$ 的 $\mathtt{LCA}$ 为圆点，要加上 $1$。

和上面差不多，不放代码了。

---

## 作者：Elma_ (赞：1)

对原图建出广义圆方树，那么两个点 $u,v$ 在原图之间的必经点数等于在圆方树路径上的圆点个数（包括 $u,v$）。

因为圆方树有一个很好的性质：圆点和方点相间分布，因此对于圆方树上两个圆点 $u,v$ 间的一条路径，设其长度为 $k$，那么 $u,v$ 间的圆点个数为 $\lfloor \frac{k}{2} \rfloor + 1$。

于是直接倍增一下就行了。时间复杂度 $O((n+q)\log n)$。

```cpp
const int maxn = 5e5 + 5;

int n, m, q, cnt;
int tim, low[maxn], dfn[maxn];
int tp, sta[maxn];
vector<int> G[maxn], T[maxn];

inline void tarjan(int u) {
    low[u] = dfn[u] = ++tim;
    sta[++tp] = u;
    for (int v : G[u]) {
        if (!dfn[v]) {
            tarjan(v);
            low[u] = min(low[u], low[v]);
            if (low[v] == dfn[u]) {
                cnt++;
                for (int x = 0;x != v;tp--) {
                    x = sta[tp];
                    T[cnt].push_back(x);
                    T[x].push_back(cnt);
                }
                T[cnt].push_back(u);
                T[u].push_back(cnt);
            }
        } else low[u] = min(low[u], dfn[v]);
    }
}

int dis[maxn], fa[maxn][25], dep[maxn];

inline void dfs(int u, int fath) {
    fa[u][0] = fath, dep[u] = dep[fath] + 1;
    dis[u] = dis[fath] + 1;
    for (int i = 1;i <= 20;i++) {
        fa[u][i] = fa[fa[u][i - 1]][i - 1];
    }
    for (int v : T[u]) {
        if (v == fath) continue;
        dfs(v, u);
    }
}
inline int getlca(int x, int y) {
    if (dep[x] < dep[y]) swap(x, y);
    for (int i = 20;i >= 0;i--)
        if (dep[fa[x][i]] >= dep[y])
            x = fa[x][i];
    if (x == y) return x;
    for (int i = 20;i >= 0;i--)
        if (fa[x][i] != fa[y][i])
            x = fa[x][i], y = fa[y][i];
    return fa[x][0];
}

signed main(void) {
    n = read(), m = read();
    for (int i = 1, u, v;i <= m;i++) {
        u = read(), v = read();
        G[u].push_back(v), G[v].push_back(u);
    }
    cnt = n;
    tarjan(1), tp--, dfs(1, 0);
    q = read();
    while (q--) {
        int u = read(), v = read();
        printf("%lld\n", (dis[u] + dis[v] - 2 * dis[getlca(u, v)]) / 2 + 1);
    }
    return 0;
}
```


---

## 作者：DerrickLo (赞：0)

一个经典的结论是，两点之间必须经过的点的个数就是两点在圆方树上路径上圆点的个数。

然后预处理一下，设从 $u$ 到根的路径上有 $a_u$ 个圆点，那么从 $u$ 到 $v$ 的圆点个数就是 $a_u+a_v-2\times a_{lca(u,v)}+[lca(u,v)\le n]$，因为如果 $lca(u,v)$ 是圆点，那么答案还需要加上 $1$。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,u,v,cnt,cntt,tp,st[1000005],low[1000005],dfn[1000005],q;
int top[1000005],son[1000005],dep[1000005],sz[1000005],fa[1000005],depp[1000005];
vector<int> ve[1000005],ve2[1000005];
void tarjan(int u){
	low[u]=dfn[u]=++cnt,st[++tp]=u;
	for(int v:ve[u]){
		if(!dfn[v]){
			tarjan(v);
			low[u]=min(low[u],low[v]);
			if(low[v]==dfn[u]){
				cntt++;
				do{
					ve2[cntt].emplace_back(st[tp]);
					ve2[st[tp]].emplace_back(cntt);
				}while(st[tp--]!=v);
				ve2[cntt].emplace_back(u),ve2[u].emplace_back(cntt);
			}
		}
		else low[u]=min(low[u],dfn[v]);
	}
}
void dfs1(int u,int fat,int de){
	fa[u]=fat,dep[u]=de,sz[u]=1,depp[u]=depp[fat]+(u<=n);
	for(int v:ve2[u]){
		if(v==fa[u])continue;
		dfs1(v,u,de+1);
		sz[u]+=sz[v];
		if(sz[v]>sz[son[u]])son[u]=v;
	}
}
void dfs2(int u,int tp){
	top[u]=tp;
	if(!son[u])return;
	dfs2(son[u],tp);
	for(int v:ve2[u]){
		if(v==fa[u]||v==son[u])continue;
		dfs2(v,v);
	}
}
int lca(int u,int v){
	while(top[u]!=top[v]){
		if(dep[top[u]]<dep[top[v]])swap(u,v);
		u=fa[top[u]];
	}
	if(dep[u]<dep[v])swap(u,v);
	return v;
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m,cntt=n; 
	for(int i=1;i<=m;i++)cin>>u>>v,ve[u].emplace_back(v),ve[v].emplace_back(u);
	for(int i=1;i<=n;i++)if(!dfn[i])tarjan(i);
	dfs1(1,-1,1),dfs2(1,1);
	cin>>q;
	while(q--){
		cin>>u>>v;
		cout<<depp[u]+depp[v]-2*depp[lca(u,v)]+(lca(u,v)<=n)<<"\n";
	}
	return 0;
}
```

---

## 作者：happybob (赞：0)

考虑建出圆方树。

对于任意两个点，其路径中必须要经过的点就是这两个点对应的圆方树中点的路径之间圆点数量。也就是割点数量。

于是 LCA 处理即可。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <vector>
using namespace std;

const int N = 1e6 + 5;

int dfn[N], low[N], idx, cnt;
int n, m, q;
vector<int> G[N], NG[N];
int sum[N];
int stk[N], top;

void tarjan(int u)
{
	dfn[u] = low[u] = ++idx;
	stk[++top] = u;
	for (int j : G[u])
	{
		if (!dfn[j])
		{
			tarjan(j);
			low[u] = min(low[u], low[j]);
			if (dfn[u] == low[j])
			{
				cnt++;
				for (int y = 0; y != j; top--)
				{
					y = stk[top];
					NG[y].emplace_back(cnt);
					NG[cnt].emplace_back(y);
				}
				NG[cnt].emplace_back(u);
				NG[u].emplace_back(cnt);
			}
		}
		else
		{
			low[u] = min(low[u], dfn[j]);
		}
	}
}

void dfs(int u, int fa)
{
	sum[u] = sum[fa] + (u <= n);
	for (int j : NG[u])
	{
		if (j != fa)
		{
			dfs(j, u);
		}
	}
}

class TreeCut
{
public:
	int id[N], top[N], sz[N], dep[N], fa[N], son[N], idx;
	void dfs1(int u, int f)
	{
		dep[u] = dep[f] + 1;
		fa[u] = f;
		sz[u] = 1;
		for (int j : NG[u])
		{
			if (j != f)
			{
				dfs1(j, u);
				sz[u] += sz[j];
				if (sz[son[u]] < sz[j]) son[u] = j;
			}
		}
	}
	void dfs2(int u, int tf)
	{
		id[u] = ++idx;
		top[u] = tf;
		if (!son[u]) return;
		dfs2(son[u], tf);
		for (int j : NG[u])
		{
			if (j != son[u] && j != fa[u])
			{
				dfs2(j, j);
			}
		}
	}
	void build()
	{
		dfs1(1, 1);
		dfs2(1, 1);
	}
	int LCA(int u, int v)
	{
		while (top[u] ^ top[v])
		{
			if (dep[top[u]] < dep[top[v]]) swap(u, v);
			u = fa[top[u]];
		}
		return (dep[u] < dep[v] ? u : v);
	}
}tc;

int main()
{
	scanf("%d%d", &n, &m);
	cnt = n;
	for (int i = 1; i <= m; i++)
	{
		int u, v;
		scanf("%d%d", &u, &v);
		G[u].emplace_back(v);
		G[v].emplace_back(u);
	}
	tarjan(1);
	dfs(1, 1);
	tc.build();
	scanf("%d", &q);
	while (q--)
	{
		int s, t;
		scanf("%d%d", &s, &t);
		int lca = tc.LCA(s, t);
		printf("%d\n", sum[s] + sum[t] - 2 * sum[lca] + (lca <= n));
	}
	return 0;
}
```


---

## 作者：MiniLong (赞：0)

# 题意

给出一个 $ n $ 个节点，$ m $ 条边的无向连通图，每次询问给出 $ u $ 和 $ v $，求 $ u $ 到 $ v $ 的所有路径中必经的点个数。

# 思路

对原图建立圆方树（用 tarjan 求出点双，对于每个点双新建一个方点，再将点双中每个点在新建的图中与方点相连），题目要求的就是 $u$ 与 $v$ 的简单路径上圆点的个数了。

因为是求路径的 size，所以考虑使用 LCT 来维护，将圆点的权值设为 $1$，方点的权值设为 $0$。

询问时直接 `split(u, v)` 求出 size 就好了。

# 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
namespace fastio{
    template<typename T> inline void read(T &t){
        int x = 0, f = 1;
        char c = getchar();
        while(!isdigit(c)){
            if(c == '-') f = -f;
            c = getchar();
        }
        while(isdigit(c)) x = x * 10 + c - '0', c = getchar();
        t = x * f;
    }
    template<typename T, typename ... Args> inline void read(T &t, Args&... args){
        read(t);
        read(args...);
    }
    template<typename T> void write(T t){
        if(t < 0) putchar('-'), t = -t;
        if(t >= 10) write(t / 10);
        putchar(t % 10 + '0');
    }
};
using namespace fastio;
const int N = 5e5 + 5;
int n, m, q;
int ecnt, head[N << 1];
struct edge{
    int v, nxt;
}e[N << 1];
void add(int u, int v){
    e[++ecnt] = edge{v, head[u]};
    head[u] = ecnt;
}
class Link_Cut_Tree{
    public:
    struct Tree{
        int fa, son[2], val, rev, siz;
        #define ls a[x].son[0]
        #define rs a[x].son[1]
    }a[N << 1];
    int top, st[N << 1];
    bool isroot(int x){
        return !(a[a[x].fa].son[0] == x || a[a[x].fa].son[1] == x);
    }
    void update(int x){
        a[x].siz = a[ls].siz + a[rs].siz;
        if(x <= n) a[x].siz++;
    }
    void pushr(int x){
        a[x].rev ^= 1;
        swap(ls, rs);
    }
    void pushdown(int x){
        if(a[x].rev){
            if(ls) pushr(ls);
            if(rs) pushr(rs);
            a[x].rev ^= 1;
        }
    }
    void rotate(int x){
        int y = a[x].fa, z = a[y].fa, k = a[y].son[1] == x;
        if(!isroot(y)) a[z].son[a[z].son[1] == y] = x;
        a[x].fa = z;
        a[y].son[k] = a[x].son[k ^ 1], a[a[x].son[k ^ 1]].fa = y;
        a[x].son[k ^ 1] = y, a[y].fa = x;
        update(y), update(x);
    }
    void splay(int x){
        int t = x;
        st[++top] = t;
        while(!isroot(t)) st[++top] = t = a[t].fa;
        while(top) pushdown(st[top--]);
        while(!isroot(x)){
            int y = a[x].fa, z = a[y].fa;
            if(!isroot(y)) rotate((a[z].son[1] == y) ^ (a[y].son[1] == x) ? x : y);
            rotate(x);
        }
    }
    void access(int x){
        for(int son = 0; x; x = a[son = x].fa){
            splay(x), a[x].son[1] = son, update(x);
        }
    }
    void makeroot(int x){
        access(x), splay(x), pushr(x);
    }
    int findroot(int x){
        access(x), splay(x), pushdown(x);
        while(a[x].son[0]) x = a[x].son[0], pushdown(x);
        splay(x);
        return x;
    }
    void link(int x, int y){
        makeroot(x);
        if(findroot(y) != x) a[x].fa = y;
    }
    void split(int x, int y){
        makeroot(x), access(y), splay(y);
    }
    int query(int x, int y){
        split(x, y);
        return a[y].siz;
    }
}lct;
int dfn[N << 1], low[N << 1], stk[N << 1], top, tim, tol;
void tarjan(int u){
    stk[++top] = u;
    dfn[u] = low[u] = ++tim;
    for(int i = head[u]; i; i = e[i].nxt){
        int v = e[i].v;
        if(!dfn[v]){
            tarjan(v);
            low[u] = min(low[u], low[v]);
            if(low[v] == dfn[u]){
                ++tol;
                for(int x = 0; x != v; --top){
                    x = stk[top];
                    lct.link(x, tol);
                }
                lct.link(u, tol);
            }
        }else low[u] = min(low[u], dfn[v]);
    }
}
signed main(){
    read(n, m), tol = n;
    for(int i = 1, u, v; i <= m; ++i){
        read(u, v);
        add(u, v), add(v, u);
    }
    tarjan(1);
    read(q);
    while(q--){
        int x, y;
        read(x, y);
        write(lct.query(x, y));
        puts("");
    }
    return 0;
}
```

---

## 作者：wcyQwQ (赞：0)



[题目传送门](https://www.luogu.com.cn/problem/P4320)

[可能更好的阅读体验](https://chenyu-w.github.io/2022/04/29/P4320%E9%81%93%E8%B7%AF%E7%9B%B8%E9%81%87/)

## 前言

一眼出思路 tarjan+LCA，感觉可以切掉，但是最后调了两天

### 前置芝士

tarjan, v-DCC缩点, 圆方树，LCA



## 分析

首先，我们可以发现，如果两个点在同一个 v-DCC 中，那么它们之间就没有任何必经点，所以我们直接进行 v-DCC 缩点。

因为题目给的图是连通的，所以我们缩完点后的图是一棵树，也就是常说的**圆方树**，那么我们要求的点数就是圆方树上两点之间圆点的个数，我们就可以对这两个点的类型进行分类讨论，我们设这两个点之间的距离为 $dist$ ( $dist$用 LCA 求 )，两点间圆点个数为 $x$ 。

1. 若这两个点都是方点，我们可以得到 $x = dist / 2$ 
2. 若这两个点一个是圆点，一个点是方点，则 $x = (dist - 1) / 2$
3. 若这两个点都是圆点，则 $x = (dist - 2) / 2$

我们发现，上述式子可以总结为一个式子
$$
x = (dist - k)/2
$$
其中 $k$ 表示这两个点中圆点的数量。

但是题目中有说把这两个点算进去，所以我们最终的答案为 $x + 2$



## 代码

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 1e6 + 10, M = 2e6 + 10; // 注意N要开两倍，要不然RE
int h[N], e[M], ne[M], idx;
int H[N], E[M], NE[M];
int dep[N], f[N][21];
int dfn[N], low[N], stk[N];
int id[N];
bool cut[N]; // 表示每个点是否为割点(圆点)
int t, tt, cnt;
int root;
int n, m, q;
vector<int> dcc[N];

inline void tarjan(int u) // v-DCC 缩点板子
{
    dfn[u] = low[u] = ++t;
    stk[++tt] = u;
    if (h[u] == -1)
    {
        dcc[++cnt].push_back(u);
        return;
    }
    int kid = 0; 
    for (int i = h[u]; ~i; i = ne[i])
    {
        int v = e[i];
        if (!dfn[v])
        {
            tarjan(v);
            low[u] = min(low[u], low[v]);
            if (dfn[u] <= low[v])
            {
                if (u != root || ++kid > 1) cut[u] = true;
                cnt++;
                int j;
                do {
                    j = stk[tt--];
                    dcc[cnt].push_back(j);
                } while (v != j);
                dcc[cnt].push_back(u);
            }
        }
        else
            low[u] = min(low[u], dfn[v]);
    }
}

inline void add(int h[], int e[], int ne[], int a, int b)
{
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

inline void dfs(int u, int p) // LCA 板子
{
    dep[u] = dep[p] + 1, f[u][0] = p;
    for (int i = 1; (1 << i) <= dep[u]; i++)
        f[u][i] = f[f[u][i - 1]][i - 1];
    for (int i = H[u]; ~i; i = NE[i])
    {
        int v = E[i];
        if (v == p) continue;
        dfs(v, u);
    }
}

inline int lca(int x, int y)
{
    if (dep[x] < dep[y]) swap(x, y);
    for (int i = log2(n); i >= 0; i--)
        if (dep[f[x][i]] >= dep[y])
            x = f[x][i];
    if (x == y) return x;
    for (int i = log2(n); i >= 0; i--)
        if (f[x][i] != f[y][i])
            x = f[x][i], y = f[y][i];
    return f[x][0];
}

int main()
{
    scanf("%d%d", &n, &m);
    memset(h, -1, sizeof h);
    memset(H, -1, sizeof H);
    while (m--)
    {
        int a, b;
        scanf("%d%d", &a, &b);
        add(h ,e, ne, a, b);
        add(h, e, ne, b, a);
    }
    root = 1;
    tarjan(1);
    int num = cnt;
    for (int i = 1; i <= n; i++)
        if (cut[i])
            id[i] = ++num;
    idx = 0;
    // 建立圆方树
    for (int i = 1; i <= cnt; i++)
        for (int j = 0; j < dcc[i].size(); j++)
        {
            int k = dcc[i][j];
            if (cut[k])
            {
                add(H, E, NE, i, id[k]);
                add(H, E, NE, id[k], i);
            }
            else id[k] = i;
        }

    dfs(1, 0);
    scanf("%d", &q);
    while (q--)
    {
        int s, t;
        scanf("%d%d", &s, &t);
        int a = cut[s], b = cut[t];
        s = id[s], t = id[t];
        int p = lca(s, t);
        int dist = dep[s] + dep[t] - 2 * dep[p];
        printf("%d\n", (dist - (a + b)) / 2 + 2);
    }
    
    return 0;
}
```



---

## 作者：orz_z (赞：0)

# 圆方树的定义

圆方树是用来解决仙人掌图的问题的，那什么是仙人掌图呢？

即不存在边同时属于多个环的无向连通图是一棵仙人掌。

## 点双连通分量的定义
要介绍圆方树，首先要介绍点双连通分量。

一个点双连通图的一个定义是：图中任意两不同点之间都有至少两条点不重复的路径。

一种简单的定义：不存在割点的图。

但这种定义对于两点一边的图时是没用的，它没有割点，但是并不能找到两条不相交的路径，因为只有一条路径。（也可以理解为那一条路径可以算两次，但的确没有相交，因为不经过其他点）。

在点双连通图内，一个点可能属于多个点双，但是一条边属于恰好一个点双。

更多关于有向图的强连通分量的知识，请看我的博客 $\to$ [强连通分量](https://www.cnblogs.com/orzz/p/15104647.html)

更多关于点双连通分量的知识，请看我的博客 $\to$ [双连通分量](https://www.cnblogs.com/orzz/p/15114866.html)

## 继续介绍圆方树

关于圆方树的建图，也比较简单，将一个点双连通分量内的所有边删去，再将一个点双连通分量中的每个点向一个新建的点连边，这个新建的点即是方点。

所以在圆方树中有 $n+c$ 个点，其中 $n$ 是原图点数，$c$ 是原图点双连通分量的个数。

每个点双都可以形成一个菊花图，多个菊花图通过原图中的割点连接在一起（因为点双的分隔点是割点）。

显然，圆方树中每条边连接一个圆点和一个方点。

在下面这张图中，$[1,2,3,4,5]$ 是圆点，$[6,7]$ 是方点。

![](https://img-blog.csdnimg.cn/img_convert/a64ea1977df8894a39bf10c1ae9b80ab.png)

而如果圆方树连通，则有以下性质：

* 方点之间不会存在连边。

* 原图的割点就是圆方树中度数大于 $1$ 的圆点。

* 圆方数是一棵非常好的树，即点数等于边数加 $1$。
  

* 如果圆点的 $size$ 为 $1$，那么一个圆点子树的 $size$ 和就是它下面的所有点的数量。

* 对于一个点双中的两点，它们之间简单路径的并集，恰好完全等于这个点双，即同一个点双中的两不同点 $u$，$v$ 之间一定存在一条简单路径经过给定的在同一个点双内的另一点 $w$。也就是说，考虑两圆点在圆方树上的路径，与路径上经过的方点相邻的圆点的集合，就等于原图中两点简单路径上的点集。

如果原图中某个连通分量只有一个点，则需要具体情况具体分析，我们在后续讨论中不考虑孤立点。

注意一条边连接两个点的在这里不算点双。

## 广义圆方树

普通圆方树只能解决仙人掌图上的问题，而广义圆方树则可以将所有无向图转化为圆方树处理。

广义圆方树性质：圆点方点相间，即树上任意一条路径上圆点方点间隔分布；不存在两个‘’相同形状‘’的点相连。

与圆方树不同的是，广义圆方树需要把一条边连接两个点也看成一个点双，原本两个圆点有一条边相连，现在在中间插入一个方点间隔开就好了。

可以参照这张图

![](https://img-blog.csdnimg.cn/img_convert/51b720e058f7a5dc7dc77c9eb881274f.png)

关于本题：[洛谷 P4320 道路相遇](https://www.luogu.com.cn/problem/P4320)

### 题目大意

给定一无向图，现在 `yzh` 要从 $u$ 点到处于 $v$ 点的 `cxr` 家（我们也不知道他要去干什么），求所有从 $u$ 到 $v$ 的路径中的必经点。

### 解题思路

介绍完上面的圆方树后，就会发现这题很简单，必经点个数其实就是两点之间割点的个数。

其实就是上面这条定理：

> 原图的割点就是圆方树中度数大于 $1$ 的圆点。

得出，必经点数等于圆方树上两点路径上圆点数。

由于广义圆方树上任意一条路径上圆点方点间隔分布，所以需要除以 $2$。

直接跑一边点双。

再建图。

然后跑一边树链剖分，记录深度和最近公共祖先。

对于每一组询问，直接用树上差分的知识求解就行了。

即设 $lca$ 为 $u$ 和 $v$ 的最近公共祖先，则 $Ans=(dep_u+dep_v-2*dep_{lca}) \div 2+1$。

### AC CODE
阅读时请省略前面的快读。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int _ = 2e6 + 5;

struct Fastio
{
    template <typename T>
    Fastio operator>>(T &x)
    {
        x = 0;
        char c = getchar();
        while (c < '0' || c > '9')
            c = getchar();
        while (c >= '0' && c <= '9')
            x = (x << 3) + (x << 1) + (c ^ 48), c = getchar();
        return *this;
    }
    Fastio &operator<<(const char *str)
    {
        int cur = 0;
        while (str[cur])
            putchar(str[cur++]);
        return *this;
    }
    template <typename T>
    Fastio &operator<<(T x)
    {
        if (x == 0)
        {
            putchar('0');
            return *this;
        }
        if (x < 0)
            putchar('-'), x = -x;
        static int sta[45];
        int top = 0;
        while (x)
            sta[++top] = x % 10, x /= 10;
        while (top)
            putchar(sta[top] + '0'), --top;
        return *this;
    }

} io;

int n, m, q, tp;
int cnt_node, cntn;
int dfn[_], low[_];
int dep[_], top[_], siz[_], hson[_], fa[_];
stack<int> s;

struct Graph
{
    int tot, head[_], nxt[_ << 1], to[_ << 1];
    void add(int u, int v)
    {
        nxt[++tot] = head[u];
        to[tot] = v;
        head[u] = tot;
        nxt[++tot] = head[v];
        to[tot] = u;
        head[v] = tot;
    }
} G, T;

void tarjan(int u)
{
    dfn[u] = low[u] = ++cnt_node;
    s.push(u);
    for (int i = G.head[u], v; i; i = G.nxt[i])
    {
        v = G.to[i];
        if (!dfn[v])
        {
            tarjan(v);
            low[u] = min(low[u], low[v]);
            if (low[v] >= dfn[u])
            {
                T.add(++cntn, u);
                while (1)
                {
                    int now = s.top();
                    s.pop();
                    T.add(cntn, now);
                    if (now == v)
                        break;
                }
            }
        }
        else
            low[u] = min(low[u], dfn[v]);
    }
}

void dfs1(int u, int d = 1)
{
    siz[u] = 1;
    dep[u] = d;
    for (int i = T.head[u], v; i; i = T.nxt[i])
    {
        v = T.to[i];
        if (dep[v])
            continue;
        fa[v] = u;
        dfs1(v, d + 1);
        siz[u] += siz[v];
        if (siz[v] > siz[hson[u]])
            hson[u] = v;
    }
}

void dfs2(int u, int topf = 1)
{
    top[u] = topf;
    if (!hson[u])
        return;
    dfs2(hson[u], topf);
    for (int i = T.head[u], v; i; i = T.nxt[i])
    {
        v = T.to[i];
        if (top[v])
            continue;
        dfs2(v, v);
    }
}

int LCA(int x, int y)
{
    while (top[x] != top[y])
    {
        if (dep[top[x]] < dep[top[y]])
            swap(x, y);
        x = fa[top[x]];
    }
    return dep[x] < dep[y] ? x : y;
}

signed main()
{
    io >> n >> m;
    cntn = n;
    for (int i = 1, u, v; i <= m; i++)
    {
        io >> u >> v;
        G.add(u, v);
    }
    tarjan(1);
    dfs1(1);
    dfs2(1);
    io >> q;
    while (q--)
    {
        int u, v;
        io >> u >> v;
        int lca = LCA(u, v);
        io << (dep[u] + dep[v] - 2 * dep[lca]) / 2 + 1 << "\n";
    }
    return 0;
}
```




---

## 作者：Genius_Z (赞：0)

一句话题意：给出一张图，求出该图的圆方树上的圆点的个数。

剩下的就是圆方树的模板了，这里选用了$LCT$维护$size$。

主要要注意的一点就是原图与圆方树的边要明确的分开储存，这里选用了$namespace$。

code：

```cpp
#include <algorithm>
#include <bitset>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <map>
#include <queue>
#include <set>
#include <vector>
#define inl inline
#define re register int
#define fa(x) t[x].fa
#define ls(x) t[x].child[0]
#define rs(x) t[x].child[1]
#define ll long long
const int inf = 0x3f3f3f3f;
#define lowbit(x) ((x) & (-x))
using namespace std;
template <class Read>
inl Read read() {
    Read x = 0;
    register bool w = 0;
    register char c = getchar();
    while (c > '9' || c < '0') {
        if (c == '-')
            w = 1;
        c = getchar();
    }
    while (c >= '0' && c <= '9') {
        x = (x << 3) + (x << 1) + (c ^ 48);
        c = getchar();
    }
    return w ? -x : x;
}
int n, m, q, dfn[1000001], low[1000001], tim, head[1000001], tot, cnt, st[1000001], top, fa[1000001];
struct edge {
    int next, to;
} e[3000001];
inl void add(int x, int y) {
    e[++tot] = edge{ head[x], y }, head[x] = tot;
    e[++tot] = edge{ head[y], x }, head[y] = tot;
}
namespace graph {
    int head[1000001], tot;
    struct edge {
        int next, to;
    } e[3000001];
    inl void add(int x, int y) {
        e[++tot] = edge{ head[x], y }, head[x] = tot;
        e[++tot] = edge{ head[y], x }, head[y] = tot;
    }
    inl void tarjan(int x) {
        dfn[x] = low[x] = ++tim;
        st[++top] = x;
        for (re i = head[x]; i; i = e[i].next) {
            if (!dfn[e[i].to]) {
                tarjan(e[i].to);
                low[x] = min(low[x], low[e[i].to]);
                if (low[e[i].to] == dfn[x]) {
                    ::add(++cnt, x);
                    do {
                        ::add(cnt, st[top]);
                    } while (st[top--] != e[i].to);
                }
            }
            else
                low[x] = min(low[x], dfn[e[i].to]);
        }
    }
};
struct node {
    int size, fa, child[2], w;
    bool filp;
} t[1000001];
inl void maintain(int x) {
    t[x].size = t[ls(x)].size + t[rs(x)].size + t[x].w;
}
inl void reverse(int x) {
    swap(ls(x), rs(x));
    t[x].filp ^= 1;
}
inl void pushdown(int x) {
    if (t[x].filp) {
        if (ls(x))reverse(ls(x));
        if (rs(x))reverse(rs(x));
        t[x].filp = 0;
    }
}
inl bool poi(int x) {
    return rs(fa(x)) == x;
}
inl bool nroot(int x) {
    return ls(fa(x)) == x || rs(fa(x)) == x;
}
inl void rotate(int x) {
    re f = fa(x), gf = fa(f), fs = poi(x), gfs = poi(f), s = t[x].child[fs ^ 1];
    if (nroot(f))t[gf].child[gfs] = x;
    t[f].child[fs] = s, t[x].child[fs ^ 1] = f;
    if (s)fa(s) = f;
    fa(f) = x, fa(x) = gf;
    maintain(f);
}
inl void push(int x) {
    if (nroot(x))push(fa(x));
    pushdown(x);
}
inl void splay(int x) {
    push(x);
    while (nroot(x)) {
        if (nroot(fa(x)))poi(x) == poi(fa(x)) ? rotate(fa(x)) : rotate(x);
        rotate(x);
    }
    maintain(x);
}
inl void access(int x) {
    for (re i = 0; x; x = fa(i = x)) {
        splay(x), rs(x) = i, maintain(x);
    }
}
inl void makeroot(int x) {
    access(x), splay(x), reverse(x);
}
inl void split(int x, int y) {
    makeroot(y), access(x), splay(x);
}
inl void link(int x, int y) {
    split(x, y), t[y].fa = x;
}
inl void dfs(int x) {
    for (re i = head[x]; i; i = e[i].next) {
        if (e[i].to != fa[x]) {
            fa[e[i].to] = x;
            fa(e[i].to) = x;
            dfs(e[i].to);
        }
    }
}
signed main() {
    cnt = n = read<int>(), m = read<int>();
    for (re i = 1; i <= m; i++) {
        re x = read<int>(), y = read<int>();
        graph::add(x, y);
    }
    for (re i = 1; i <= n; i++) {
        t[i].w = 1;
        if (!dfn[i])graph::tarjan(i);
    }
    dfs(1);
    q = read<int>();
    while (q--) {
        re x = read<int>(), y = read<int>();
        split(x, y);
        printf("%d\n", t[x].size);
    }
}
```



---


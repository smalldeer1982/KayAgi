# [ZJOI2011] 道馆之战

## 题目描述

口袋妖怪（又名神奇宝贝或宠物小精灵）红/蓝/绿宝石中的水系道馆需要经过三个冰地才能到达馆主的面前，冰地中的每一个冰块都只能经过一次。当一个冰地上的所有冰块都被经过之后，到下一个冰地的楼梯才会被打开。

三个冰地分别如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/4tq073ig.png)

当走出第三个冰地之后，就可以与馆主进行道馆战了。馆主发现这个难度太小，导致经常有挑战者能通过，为了加大难度，将道馆分成了$n$个房间，任意两个房间之间均有且仅有一条路径相连，即这$n$个房间构成一个树状结构。每个房间分成了$A$和$B$两个区域，每一区域都是一个薄冰块或者障碍物。每次只能移动到相邻房间的同一类区域（即若你现在在这个房间的$A$区域，那么你只能移动到相邻房间的$A$区域）或这个房间的另一区域。现在挑战者从房间$u$出发，馆主在房间$v$，那么挑战者只能朝接近馆主所在房间的方向过去。一开始挑战者可以在房间$u$的任意一个冰块区域内。如果挑战者踩过的冰块数达到了最大值（即没有一种方案踩过的冰块数更多了），那么当挑战者走到最后一个冰块上时，他会被瞬间传送到馆主面前与馆主进行道馆战。自从馆主修改规则后已经经过了$m$天，每天要么是有一个挑战者来进行挑战，要么就是馆主将某个房间进行了修改。对于每个来的挑战者，你需要计算出他若要和馆主进行战斗需要经过的冰块数。

## 说明/提示

测试点$1$~$6$：$n≤1000,m≤10000$

测试点$7$~$15$：$n≤30000,m≤80000$

测试点$16$~$20$：$n≤50000,m≤100000$

## 样例 #1

### 输入

```
5 3
1 2
2 3
2 4
1 5
.#
..
#.
.#
..
Q 5 3
C 1 ##
Q 4 5
```

### 输出

```
6
3```

# 题解

## 作者：liangbowen (赞：19)

## 前言

[题目传送门！](https://www.luogu.com.cn/problem/P4679)

[更好的阅读体验？](https://www.cnblogs.com/liangbowen/p/16817148.html)

大力树剖！

做树剖时，大家可以膜拜 @[liruiduan2](https://www.luogu.com.cn/user/488310) 巨佬，他可以在考场上码 200 行的树剖题目。

## 思路

对于线段树的区间 $[l, r]$，记录三个东西：$lmx_i$、$rmx_i$、$dis_{i, j}$。

$lmx_i$ （$0 \le i \le 1$）表示从 $l$ 的左或右节点出发，能走的最长距离。$rmx_i$ 则是从 $r$ 出发。

$dis_{i, j}$（$0 \le i, j \le 1$）表示从 $l$ 的左或右节点，走到 $r$ 的左或右节点，最长距离。

合并操作看代码模拟就行，非常好理解。假设要把 $x$ 与 $y$ 合并到 $ans$ 里：

1. `ans.lmx[i] = max(ans.lmx[i], max(x.lmx[i], x.dis[i][j] + y.lmx[j]))`
2. `ans.rmx[i] = max(ans.rmx[i], max(y.rmx[i], y.dis[j][i] + x.rmx[j]));`
3. $dis_{i, j}$ 用类似 floyd 的思想转移即可。

---

线段树是单点修改，不需要 `pushdown`，写起来非常舒服。

不过注意新建一个节点需要特殊处理。

```cpp
inline void create(bool a[]) //创建一个新节点
{
	int d = 2, x = a[0], y = a[1];
	const int inf = 0x3f3f3f3f;
	if (!x) d = x = -inf;
	if (!y) d = y = -inf;
	lmx[0] = rmx[0] = max(x, 0), lmx[1] = rmx[1] = max(y, 0);
	dis[0][0] = x, dis[1][1] = y;
	dis[0][1] = dis[1][0] = d;
}
```

所以接下来就是树剖了。前面是常规操作，最后可以得到两个点相遇后的两个结果。

但是这样做，求出的两个点的信息，是这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/afpw9pq6.png)

我们显然想让两个箭头是顺着的。

![](https://cdn.luogu.com.cn/upload/image_hosting/llg3129v.png)

所以很简单，把一段翻转即可。这个时候再合并两段的答案就行了。

```cpp
void Swap(Node &a) //把当前点翻转 
{
	for (int i = 0; i <= 1; i++) swap(a.lmx[i], a.rmx[i]);
	swap(a.dis[0][1], a.dis[1][0]);
}
```

最后答案显然为 $\max(lmx_{0}, lmx_{1})$。

## 完整代码

有点长。可以用这份代码对拍。

```cpp
/*树剖树剖树剖树剖树剖树剖树剖树剖树剖树剖树剖树剖树剖树剖树剖树剖树剖树剖树剖树剖树剖树剖树剖树剖树剖*/
/*lrd爆切树剖lrd爆切树剖lrd爆切树剖lrd爆切树剖lrd爆切树剖lrd爆切树剖lrd爆切树剖lrd爆切树剖lrd爆切树剖*/
#include <iostream>
#include <cstdio>
#include <cstring>
#define space putchar(' ')
#define endl putchar('\n')
using namespace std;
typedef long long LL;
typedef unsigned long long ull;
typedef long double LD;
namespace io { //快读快写，可以直接忽略
	void fastio()
	{
		ios::sync_with_stdio(false);
		cin.tie(0), cout.tie(0);
	}
	inline int read()
	{
		char op = getchar(); int x = 0, f = 1;
		while (op < 48 || op > 57) {if (op == '-') f = -1; op = getchar();}
		while (48 <= op && op <= 57) x = (x << 1) + (x << 3) + (op ^ 0x30), op = getchar();
		return x * f;
	}
	inline void write(int x)
	{
		if (x < 0) putchar('-'), x = -x;
		if (x > 9) write(x / 10);
		putchar(x % 10 + 0x30);
	}
} using namespace io;
const int N = 5e4 + 5;
struct Edge
{
	int now, nxt;
} e[N << 1];
int head[N], cur;
inline void add(int u, int v) //链式前向星
{
	e[++cur].now = v;
	e[cur].nxt = head[u];
	head[u] = cur;
}
int siz[N], wson[N], fa[N], dep[N];
void dfs(int u) //树剖两次 dfs
{
	siz[u] = 1, dep[u] = dep[fa[u]] + 1;
	for (int i = head[u]; i; i = e[i].nxt)
	{
		int v = e[i].now;
		if (v != fa[u])
		{
			fa[v] = u;
			dfs(v);
			siz[u] += siz[v];
			if (wson[u] == 0 || siz[v] > siz[wson[u]]) wson[u] = v;
		}
	}
}
int top[N];
bool map[N][2], zlt[N][2]; //zlt : 转化为dfn的地图 
int dfn[N], vist;
void DFS(int u, int frt)
{
	dfn[u] = ++vist;
	top[u] = frt;
	zlt[vist][0] = map[u][0], zlt[vist][1] = map[u][1];
	if (wson[u] == 0) return;
	DFS(wson[u], frt);
	for (int i = head[u]; i; i = e[i].nxt)
	{
		int v = e[i].now;
		if (v != fa[u] && v != wson[u]) DFS(v, v);
	}
}
struct Node
{
	int lmx[2], rmx[2], dis[2][2];
	Node() {lmx[0] = lmx[1] = rmx[0] = rmx[1] = dis[0][0] = dis[0][1] = dis[1][0] = dis[1][1] = 0;}
	inline void create(bool a[]) //创建一个新节点
	{
		int d = 2, x = a[0], y = a[1];
		const int inf = 0x3f3f3f3f;
		if (!x) d = x = -inf;
		if (!y) d = y = -inf;
		lmx[0] = rmx[0] = max(x, 0), lmx[1] = rmx[1] = max(y, 0);
		dis[0][0] = x, dis[1][1] = y;
		dis[0][1] = dis[1][0] = d;
	}
} s[N << 2];
inline Node operator +(const Node &x, const Node &y) //合并两个节点
{
	Node a;
	for (int i = 0; i <= 1; i++)
		for (int j = 0; j <= 1; j++)
		{
			a.lmx[i] = max(a.lmx[i], max(x.lmx[i], x.dis[i][j] + y.lmx[j]));
			a.rmx[i] = max(a.rmx[i], max(y.rmx[i], y.dis[j][i] + x.rmx[j]));
			a.dis[i][j] = -0x3f3f3f3f; //类似 floyd 的写法
			for (int k = 0; k <= 1; k++) a.dis[i][j] = max(a.dis[i][j], x.dis[i][k] + y.dis[k][j]);
		}
	return a;
}
struct SegmentTree //线段树
{
	inline int ls(int x) {return x << 1;}
	inline int rs(int x) {return x << 1 | 1;}
	inline void pushup(int pos) {s[pos] = s[ls(pos)] + s[rs(pos)];}
	void build(int l, int r, int pos)
	{
		if (l == r) return s[pos].create(zlt[l]);
		int mid = (l + r) >> 1;
		build(l, mid, ls(pos));
		build(mid + 1, r, rs(pos));
		pushup(pos);
	}
	void update(int l, int r, int pos, int id, bool a[])
	{
		if (l == r) return s[pos].create(a);
		int mid = (l + r) >> 1;
		if (id <= mid) update(l, mid, ls(pos), id, a);
		else update(mid + 1, r, rs(pos), id, a);
		pushup(pos);
	}
	Node query(int l, int r, int pos, int L, int R) //warning: 由于空节点与非空节点合并会挂，所以要分开写 
	{
		if (L <= l && r <= R) return s[pos];
		int mid = (l + r) >> 1;
		/*我平时的写法
		Node ans;
		if (L <= mid) ans = ans + query(l, mid, ls(pos), L, R);
		if (mid < R) ans = ans + query(mid + 1, r, rs(pos), L, R);
		return ans;
		*/
		if (L > mid) return query(mid + 1, r, rs(pos), L, R); //没有 L<=mid 说明有 mid<R 
		if (mid >= R) return query(l, mid, ls(pos), L, R); //没有 mid<R 说明有 L<=mid
		return query(l, mid, ls(pos), L, R) + query(mid + 1, r, rs(pos), L, R); //两个非空节点合并才不会挂 
	}
} seg;
int n;
struct Tree //大力树剖！
{
	void Swap(Node &a) //把当前点翻转 
 	{
		for (int i = 0; i <= 1; i++) swap(a.lmx[i], a.rmx[i]);
		swap(a.dis[0][1], a.dis[1][0]);
	}
	int query(int x, int y)
	{
		Node nx, ny;
		while (top[x] != top[y]) //下面注意要写成 nx = query + nx，因为空节点合并会有问题
		{
			if (dep[top[x]] > dep[top[y]])
					nx = seg.query(1, n, 1, dfn[top[x]], dfn[x]) + nx, x = fa[top[x]];
			else 	ny = seg.query(1, n, 1, dfn[top[y]], dfn[y]) + ny, y = fa[top[y]];
		}
		
		if (dep[x] > dep[y]) nx = seg.query(1, n, 1, dfn[y], dfn[x]) + nx;
		else ny = seg.query(1, n, 1, dfn[x], dfn[y]) + ny;
		Swap(nx);
		Node ans = nx + ny;
		return max(ans.lmx[0], ans.lmx[1]);
	}
} tree;
int main()
{
	n = read(); int T = read();
	for (int i = 1; i < n; i++)
	{
		int u = read(), v = read();
		add(u, v), add(v, u);
	}
	for (int i = 1; i <= n; i++)
	{
		char s[2]; scanf("%s", s);
		map[i][0] = (s[0] == '.'), map[i][1] = (s[1] == '.');
	}
	dfs(1), DFS(1, 1);
	seg.build(1, n, 1);
	while (T--)
	{
		char op[2];
		scanf("%s", op);
		if (op[0] == 'C')
		{
			int i = read();
			char s[2]; scanf("%s", s);
			map[i][0] = (s[0] == '.'), map[i][1] = (s[1] == '.'); //暴力更新
			seg.update(1, n, 1, dfn[i], map[i]);
		}
		else
		{
			int u = read(), v = read();
			write(tree.query(u, v)), endl;
		}
	}
	return 0;
}
/*
hack
5 1
4 5
2 5
4 3
4 1
..
#.
#.
#.
##
Q 2 4
*/
```

希望能帮助到大家！

---

## 作者：nofind (赞：12)

## [题意](https://www.luogu.com.cn/problem/P4679)

将一个节点上的两个点分别称为$0/1$，用树链剖分+线段树维护。

对于线段树上的节点$[l,r]$,我们维护如下信息：  
$lmax_{0/1}$表示从$l$的$0/1$节点能走的最长距离。  
$rmax_{0/1}$表示从$r$的$0/1$节点能走的最长距离。  
$dis_{0/1,0/1}$表示从$l$的$0/1$走到$r$的$0/1$的最长距离。

合并如下：  
```
Segment_tree operator+(const Segment_tree& a)const
{
	Segment_tree res;
	for(int i=0;i<=1;i++)
		for(int j=0;j<=1;j++)
			res.lmax[i]=max(res.lmax[i],max(lmax[i],dis[i][j]+a.lmax[j]));
	for(int i=0;i<=1;i++)
		for(int j=0;j<=1;j++)
			res.rmax[i]=max(res.rmax[i],max(a.rmax[i],rmax[j]+a.dis[j][i]));
	for(int i=0;i<=1;i++)
		for(int j=0;j<=1;j++)
        {
			res.dis[i][j]=-inf;
			for(int k=0;k<=1;k++)res.dis[i][j]=max(res.dis[i][j],dis[i][k]+a.dis[k][j]);
		}
	return res;
}
```

查询时两个点同时跳链，最后需要翻转一条链。

code:
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=50010;
const int inf=1e9;
int n,m,cnt_edge;
int head[maxn];
int a[maxn][2];
inline int read()
{
	char c=getchar();int res=0,f=1;
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')res=res*10+c-'0',c=getchar();
	return res*f;
}
struct edge{int to,nxt;}e[maxn<<1];
inline void add_edge(int u,int v)
{
	e[++cnt_edge].nxt=head[u];
	head[u]=cnt_edge;
	e[cnt_edge].to=v;
}
int tim;
int dep[maxn],pre[maxn],size[maxn],son[maxn],dfn[maxn],pos[maxn],top[maxn];
void dfs1(int x,int fa)
{
	dep[x]=dep[fa]+1;pre[x]=fa;size[x]=1;
	for(int i=head[x];i;i=e[i].nxt)
	{
		int y=e[i].to;
		if(y==fa)continue;
		dfs1(y,x);size[x]+=size[y];
		if(size[y]>size[son[x]])son[x]=y;
	}
}
void dfs2(int x,int tp)
{
	dfn[x]=++tim;pos[tim]=x;top[x]=tp;
	if(son[x])dfs2(son[x],tp);
	for(int i=head[x];i;i=e[i].nxt)
	{
		int y=e[i].to;
		if(y==pre[x]||y==son[x])continue;
		dfs2(y,y);
	}
}
#define ls(p) (p<<1)
#define rs(p) (p<<1|1)
struct Segment_tree
{
	int lmax[2],rmax[2];
	int dis[2][2];
	Segment_tree()
	{
		memset(lmax,0,sizeof(lmax));
		memset(rmax,0,sizeof(rmax));
		memset(dis,0,sizeof(dis));
	}
	Segment_tree operator+(const Segment_tree& a)const
	{
		Segment_tree res;
		for(int i=0;i<=1;i++)
			for(int j=0;j<=1;j++)
				res.lmax[i]=max(res.lmax[i],max(lmax[i],dis[i][j]+a.lmax[j]));
		for(int i=0;i<=1;i++)
			for(int j=0;j<=1;j++)
				res.rmax[i]=max(res.rmax[i],max(a.rmax[i],rmax[j]+a.dis[j][i]));
		for(int i=0;i<=1;i++)
			for(int j=0;j<=1;j++)
			{
				res.dis[i][j]=-inf;
				for(int k=0;k<=1;k++)res.dis[i][j]=max(res.dis[i][j],dis[i][k]+a.dis[k][j]);
			}
		return res;
	}
}seg[maxn<<2];
inline Segment_tree New(int* a)
{
	Segment_tree res;
	if(a[0]&&a[1])
	{
		for(int i=0;i<=1;i++)res.lmax[i]=res.rmax[i]=2;
		for(int i=0;i<=1;i++)
			for(int j=0;j<=1;j++)
				res.dis[i][j]=(i==j)?1:2;
	}
	else if(a[0]||a[1])
	{
		int op=a[0]?0:1;
		res.lmax[op]=res.rmax[op]=res.dis[op][op]=1;
		res.lmax[op^1]=res.rmax[op^1]=0;
		res.dis[op][op^1]=res.dis[op^1][op]=res.dis[op^1][op^1]=-inf;
	}
	else 
	{
		for(int i=0;i<=1;i++)res.lmax[i]=res.rmax[i]=0;
		for(int i=0;i<=1;i++)
			for(int j=0;j<=1;j++)
				res.dis[i][j]=-inf;
	}
	return res;
}
void build(int p,int l,int r)
{
	if(l==r){seg[p]=New(a[pos[l]]);return;}
	int mid=(l+r)>>1;
	build(ls(p),l,mid);build(rs(p),mid+1,r);
	seg[p]=seg[ls(p)]+seg[rs(p)];
}
void change(int p,int l,int r,int pos,int* a)
{
	if(l==r){seg[p]=New(a);return;}
	int mid=(l+r)>>1;
	if(pos<=mid)change(ls(p),l,mid,pos,a);
	else change(rs(p),mid+1,r,pos,a);
	seg[p]=seg[ls(p)]+seg[rs(p)];
}
Segment_tree query(int p,int l,int r,int ql,int qr)
{
	if(l>=ql&&r<=qr)return seg[p];
	int mid=(l+r)>>1;
	if(qr<=mid)return query(ls(p),l,mid,ql,qr);
	else if(ql>mid)return query(rs(p),mid+1,r,ql,qr);
	else return query(ls(p),l,mid,ql,qr)+query(rs(p),mid+1,r,ql,qr);
}
inline void reverse(Segment_tree& a)
{
	for(int i=0;i<=1;i++)swap(a.lmax[i],a.rmax[i]);
	swap(a.dis[0][1],a.dis[1][0]);
}
inline int query(int x,int y)
{
	Segment_tree res1,res2,res;
	while(top[x]!=top[y])
	{
		if(dep[top[x]]>dep[top[y]])res1=query(1,1,n,dfn[top[x]],dfn[x])+res1,x=pre[top[x]];
		else res2=query(1,1,n,dfn[top[y]],dfn[y])+res2,y=pre[top[y]];
	}
	if(dep[x]<dep[y])res2=query(1,1,n,dfn[x],dfn[y])+res2;
	else res1=query(1,1,n,dfn[y],dfn[x])+res1;
	reverse(res1);res=res1+res2;
	return max(res.lmax[0],res.lmax[1]);
}
int main()
{
	//freopen("test.in","r",stdin);
	//freopen("test.out","w",stdout);
	scanf("%d%d",&n,&m);
	for(int i=1;i<n;i++)
	{
		int u=read(),v=read();
		add_edge(u,v);add_edge(v,u);
	}
	dfs1(1,0);dfs2(1,1);
	for(int i=1;i<=n;i++)
	{
		char tmp[2];scanf("%s",tmp);
		for(int j=0;j<=1;j++)a[i][j]=(tmp[j]=='.');
	}
	build(1,1,n);
	for(int i=1;i<=m;i++)
	{
		char op[10],s[2];int x,y;
		scanf("%s",op+1);
		if(op[1]=='C')
		{
			x=read();scanf("%s",s);
			for(int j=0;j<=1;j++)a[x][j]=(s[j]=='.');
			change(1,1,n,dfn[x],a[x]);
		}
		else 
		{
			x=read(),y=read();
			printf("%d\n",query(x,y));
		}
	}
	return 0;
}
```


---

## 作者：chenxia25 (赞：6)

> [洛谷题目页面传送门](https://www.luogu.com.cn/problem/P4679)

> 有一棵树$T=(V,E),|V|=n,|E|=n-1$。节点$i$有$2$个房间，每个房间是薄冰或障碍物，分别用$a_{i,1},a_{i,2}$表示（$\texttt.$表示薄冰，$\texttt\#$表示障碍物）。你需要支持以下$2$种$q$次操作：

>1. $\texttt C\ x\ y$：$y$是一个长度为$2$的字符串，表示将节点$x$的房间改成$y$；
>1. $\texttt Q\ x\ y$：查询从节点$x$往节点$y$走最多能踏过多少个薄冰。可以从节点$x$的任意房间出发。每次可以移到同节点的另一房间或往$y$方向的下一个节点的同一房间。障碍物不能走。走过的房间不能走。最终不必到达$y$。

>$n\in\left[1,5\times10^4\right],q\in\left[1,10^5\right]$。

一眼的重剖。

先来考虑若出在线性结构上该怎么做。单点修改，区间查询，BIT又太逊，考虑线段树。每个节点维护一大堆东西，然后一脸区间可合并的样子。对于每个线段树节点$i$，设表示$[l_i,r_i]$，那么最终要求的“最多能踏过多少个薄冰”显然是必须要记录的，设为$mx_i$。又由于区间没有方向，但是操作$\texttt Q$中的$x,y$左右关系不确定，所以要记录从左往右、从右往左$2$种方向上的答案$mxl_i,mxr_i$。

接下来考虑合并。以从左往右为例。$[l_i,r_i]$的答案显然分为$2$种情况：轨迹在$[l_i,r_{lson_i}]$内和跨越它。情况$1$显然是$mxl_{lson_i}$就够了的。情况$2$则需要前提条件——$[l_i,r_{lson_i}]$能够走通。于是需要再维护一个$can_i$（这个$2$种方向是可以互用的）。又由于在$r_{lson_i},l_{rson_i}$处的接口成功性与连接的房间（$1$还是$2$）有关，所以我们每个记录的东西都要分起点终点四种情况（即$mxl_{i,0/1,0/1},mxr_{i,0/1,0/1},can_{i,0/1,0/1}$）。此时可合并性已经很显然了。

由于这个线段树节点合并的方法有点复杂，记录的$12$个量互相依存，于是查询函数之类直接返回节点结构体。

现在来考虑树上的情况。考虑重剖，由于这个线段树节点是分方向的，于是不能像普通算和、$\min/\max$之类直接将一个个剖出来的重链的结果累计到路径的总结果中，需要维护$x\to\mathrm{LCA}(x,y),y\to\mathrm{LCA}(x,y)$这$2$条直链的总结果（都是线段树节点结构体）。最终将这$2$条直链的总结果合并时，要注意将$x\to\mathrm{LCA}(x,y)$的总结果方向翻转（因为根据重剖的性质，方向是从上往下的，而我们从$x$往$\mathrm{LCA}(x,y)$走，理应是从下往上的）。

线性结构上的线段树复杂度单$\log$，加了个重剖变成$\mathrm O\!\left(q\log^2n\right)$。

对了有个要注意的地方，就是线段树空节点与非空节点合并时要特判，不然会WA到自闭，已加入[sb错误列表](https://www.cnblogs.com/ycx-akioi/p/sb-mistakes.html)（第$2$条）（

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define pb push_back
const int N=50000;
int n,qu;
vector<int> nei[N+1];//邻接表 
char a[N+1][5];//房间情况 
int fa[N+1],dep[N+1],sz[N+1],wson[N+1],top[N+1],dfn[N+1],nowdfn,mng[N+1];//重剖 
void dfs1(int x=1){//重剖 
	sz[x]=1;
	for(int i=0;i<nei[x].size();i++){
		int y=nei[x][i];
		if(y==fa[x])continue;
		fa[y]=x;
		dep[y]=dep[x]+1;
		dfs1(y);
		sz[x]+=sz[y];
		if(sz[y]>sz[wson[x]])wson[x]=y;
	}
}
void dfs2(int x=1,int t=1){//重剖 
	mng[dfn[x]=++nowdfn]=x;
	top[x]=t;
	if(wson[x])dfs2(wson[x],t);
	for(int i=0;i<nei[x].size();i++){
		int y=nei[x][i];
		if(y!=fa[x]&&y!=wson[x])dfs2(y,y);
	}
}
struct segtree{//线段树 
	struct node{//节点 
		int l,r,mxl[2][2],mxr[2][2];bool can[2][2];
		node(){l=0;}//空节点的标志 
		node rev(){//方向翻转 
			node res=*this;
			swap(res.mxl[0][0],res.mxr[0][0]);
			swap(res.mxl[0][1],res.mxr[0][1]);
			swap(res.mxl[1][0],res.mxr[1][0]);
			swap(res.mxl[1][1],res.mxr[1][1]);
			swap(res.can[0][1],res.can[1][0]);
			return res;
		}
		void prt(){//调试用 
			printf("nd[%d,%d]=\n",l,r);
			printf("\tmxl[0][0]=%d mxl[0][1]=%d mxl[1][0]=%d mxl[1][1]=%d\n",mxl[0][0],mxl[0][1],mxl[1][0],mxl[1][1]);
			printf("\tmxr[0][0]=%d mxr[0][1]=%d mxr[1][0]=%d mxr[1][1]=%d\n",mxr[0][0],mxr[0][1],mxr[1][0],mxr[1][1]);
			printf("\tcan[0][0]=%d can[0][1]=%d can[1][0]=%d can[1][1]=%d\n",can[0][0],can[0][1],can[1][0],can[1][1]);
		}
	}nd[N<<2];
	#define l(p) nd[p].l
	#define r(p) nd[p].r
	#define mxl(p) nd[p].mxl
	#define mxr(p) nd[p].mxr
	#define can(p) nd[p].can
	void sprup(node &p,node lson,node rson){//上传（即合并） 
		if(!lson.l)return p=rson,void();
		if(!rson.l)return p=lson,void();
		p.l=lson.l;p.r=rson.r;
		p.mxl[0][0]=max(lson.mxl[0][0]+lson.can[0][0]*rson.mxl[0][0],lson.mxl[0][1]+lson.can[0][1]*rson.mxl[1][0]);
		p.mxl[0][1]=max(lson.mxl[0][0]+lson.can[0][0]*rson.mxl[0][1],lson.mxl[0][1]+lson.can[0][1]*rson.mxl[1][1]);
		p.mxl[1][0]=max(lson.mxl[1][0]+lson.can[1][0]*rson.mxl[0][0],lson.mxl[1][1]+lson.can[1][1]*rson.mxl[1][0]);
		p.mxl[1][1]=max(lson.mxl[1][0]+lson.can[1][0]*rson.mxl[0][1],lson.mxl[1][1]+lson.can[1][1]*rson.mxl[1][1]);
		p.mxr[0][0]=max(rson.mxr[0][0]+rson.can[0][0]*lson.mxr[0][0],rson.mxr[0][1]+rson.can[1][0]*lson.mxr[1][0]);
		p.mxr[0][1]=max(rson.mxr[0][0]+rson.can[0][0]*lson.mxr[0][1],rson.mxr[0][1]+rson.can[1][0]*lson.mxr[1][1]);
		p.mxr[1][0]=max(rson.mxr[1][0]+rson.can[0][1]*lson.mxr[0][0],rson.mxr[1][1]+rson.can[1][1]*lson.mxr[1][0]);
		p.mxr[1][1]=max(rson.mxr[1][0]+rson.can[0][1]*lson.mxr[0][1],rson.mxr[1][1]+rson.can[1][1]*lson.mxr[1][1]);
		p.can[0][0]=lson.can[0][0]&&rson.can[0][0]||lson.can[0][1]&&rson.can[1][0];
		p.can[0][1]=lson.can[0][0]&&rson.can[0][1]||lson.can[0][1]&&rson.can[1][1];
		p.can[1][0]=lson.can[1][0]&&rson.can[0][0]||lson.can[1][1]&&rson.can[1][0];
		p.can[1][1]=lson.can[1][0]&&rson.can[0][1]||lson.can[1][1]&&rson.can[1][1];
	}
	void sprup(int p){sprup(nd[p],nd[p<<1],nd[p<<1|1]);}//真正的上传 
	void bld(int l=1,int r=n,int p=1){//建树 
		l(p)=l;r(p)=r;
		if(l==r){//区间大小为1时的处理 
			mxl(p)[0][0]=mxr(p)[0][0]=a[mng[l]][0]=='.';
			mxl(p)[0][1]=mxr(p)[0][1]=a[mng[l]][0]=='.'?a[mng[l]][1]=='.'?2:1:0;
			mxl(p)[1][0]=mxr(p)[1][0]=a[mng[l]][1]=='.'?a[mng[l]][0]=='.'?2:1:0;
			mxl(p)[1][1]=mxr(p)[1][1]=a[mng[l]][1]=='.';
			can(p)[0][0]=a[mng[l]][0]=='.';
			can(p)[0][1]=can(p)[1][0]=a[mng[l]][0]=='.'&&a[mng[l]][1]=='.';
			can(p)[1][1]=a[mng[l]][1]=='.';
			return;
		}
		int mid=l+r>>1;
		bld(l,mid,p<<1);bld(mid+1,r,p<<1|1);
		sprup(p);
	}
	void init(){bld();}
	node mx(int l,int r,int p=1){//区间查询 
		if(l<=l(p)&&r>=r(p))return /*nd[p].prt(),*/nd[p];
		int mid=l(p)+r(p)>>1;
		node res;
		if(l<=mid)sprup(res,res,mx(l,r,p<<1));
		if(r>mid)sprup(res,res,mx(l,r,p<<1|1));
//		res.prt();
		return res;
	}
	void chg(int x,char v[],int p=1){//单点修改 
		if(l(p)==r(p)){
			mxl(p)[0][0]=mxr(p)[0][0]=v[0]=='.';
			mxl(p)[0][1]=mxr(p)[0][1]=v[0]=='.'?v[1]=='.'?2:1:0;
			mxl(p)[1][0]=mxr(p)[1][0]=v[1]=='.'?v[0]=='.'?2:1:0;
			mxl(p)[1][1]=mxr(p)[1][1]=v[1]=='.';
			can(p)[0][0]=v[0]=='.';
			can(p)[0][1]=can(p)[1][0]=v[0]=='.'&&v[1]=='.';
			can(p)[1][1]=v[1]=='.';
			return;
		}
		int mid=l(p)+r(p)>>1;
		chg(x,v,p<<1|(x>mid));
		sprup(p);
	}
}segt;
int mx(int x,int y){//树上链查询 
	segtree::node res[2];//2条直链的总结果 
	bool now=0;//当前在合并到哪条直链 
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]])now^=1,swap(x,y);//改变当前状态 
		segt.sprup(res[now],segt.mx(dfn[top[x]],dfn[x]),res[now]);//合并当前重链的结果到所在直链的总结果 
		x=fa[top[x]];
	}
	if(dep[x]<dep[y])now^=1,swap(x,y);//改变当前状态 
	segt.sprup(res[now],segt.mx(dfn[y],dfn[x]),res[now]);//合并当前重链的结果到所在直链的总结果
//	res[0].rev().prt();res[1].prt();
	segt.sprup(res[0],res[0].rev()/*左直链要左右翻转*/,res[1]);//2条直链合并 
	return max(max(res[0].mxl[0][0],res[0].mxl[0][1]),max(res[0].mxl[1][0],res[0].mxl[1][1]));//最终答案 
}
int main(){
	cin>>n>>qu;
	for(int i=1;i<n;i++){
		int x,y;
		cin>>x>>y;
		nei[x].pb(y);nei[y].pb(x);
	}
	for(int i=1;i<=n;i++)cin>>a[i];
	dfs1();dfs2();//重剖 
	segt.init();//线段树初始化 
	while(qu--){
		char tp,z[5];int x,y;
		cin>>tp>>x;
		if(tp=='Q')cin>>y,cout<<mx(x,y)<<"\n";
		else cin>>z,segt.chg(dfn[x],z);
	}
	return 0;
}
```

---

## 作者：zyxawa (赞：5)

## 「ZJOI2011」道馆之战

给定一棵树，每一个节点 $2$ 个房间，可以为薄冰或者障碍物，给定两个操作：修改某一个节点的两个房间，查询从 $u$ 走到 $v$ 最多可以经过多少薄冰（最终可以不到达 $v$）。

---

毫无疑问，维护树上信息，肯定是需要重链剖分的，对于线段树上每一个区间 $[l,r]$，我们需要维护一下信息（其中 $0 \le i,j \le 1$）。

$lmax_i$：表示从 $l$ 的 $i$ 房间出发向 $r$ 出发最多能经过多少薄冰（注意最终可以不用到达 $r$，并且最多走到 $r$）。

$rmax_i$：表示从 $r$ 的 $i$ 房间出发向 $l$ 出发最多能经过多少薄冰（同样最终可以不用到达 $l$，并且最多走到 $l$）。

$dis_{i,j}$：表示从 $l$ 的 $i$ 房间走到 $r$ 的 $j$ 房间最多能经过多少薄冰（这次是必须到达）。

那么我们就可以如下代码将两个相邻区间合并为一个区间了。

```cpp
for(int i=0;i<=1;i++){
	for(int j=0;j<=1;j++){
		c.lmax[i]=max(c.lmax[i],max(a.lmax[i],a.dis[i][j]+b.lmax[j]));
		c.rmax[i]=max(c.rmax[i],max(b.rmax[i],b.dis[j][i]+a.rmax[j]));
		for(int k=0;k<=1;k++) c.dis[i][j]=max(-INF,c.dis[i][j],a.dis[i][k]+b.dis[k][j]);
	}
}
```

但是对于最后对于树剖查询合并两条链子时，我们需要的是：

![1](https://cdn.fzoi.top/upload/user/c1120241532/23010907224248.png)

但由于是树剖向上跳从而求得答案，所以实际的应该是：

![2](https://cdn.fzoi.top/upload/user/c1120241532/23010907255220.png)

所以我们应该这样将左边的链旋转（因为具有对称性，所以不是全部旋转）：

```cpp
swap(res.lmax[0],res.rmax[0]);
swap(res.lmax[1],res.rmax[1]);
swap(res.dis[1][0],res.dis[0][1]);
```

这里再解释一下为什么会这样设计线段树所记录的信息：

对于 $lmax_i$ 很明显是用来记录答案，又因为我们最后需要旋转，方向不确定，所以需要记录 $rmax_i$，对于 $dis_{i,j}$ 我们需要用来合并答案。但是可能会有人认为 $dis_{i,j}$ 没用，但是因为题目中的“最终可以不到达 $v$”，所以会存在错误合并，例如下图：

![3](https://cdn.fzoi.top/upload/user/c1120241532/23010907585545.png)

红色路径为 $dis_{0,0}$ 的答案路径，蓝色路径为 $lmax_0$ 的路径。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,x,y,tot,siz[50001],fa[50001],top[50001],son[50001],dep[50001],dfn[50001];
vector <int> G[50001];
char s[10];
void dfs1(int rt){
	son[rt]=-1;
	siz[rt]=1;
	for(int i=0;i<G[rt].size();i++){
		int to=G[rt][i];
		if(!dep[to]){
			dep[to]=dep[rt]+1;
			fa[to]=rt;
			dfs1(to);
			siz[rt]+=siz[to];
			if(son[rt]==-1||siz[to]>siz[son[rt]]) son[rt]=to;
		}
	}
}
void dfs2(int rt,int t){
	top[rt]=t;
	dfn[rt]=++tot;
	if(son[rt]==-1) return;
	dfs2(son[rt],t);
	for(int i=0;i<G[rt].size();i++){
		int to=G[rt][i];
		if(to!=son[rt]&&to!=fa[rt]) dfs2(to,to);
	}
}
struct node{
	int lmax[3],rmax[3],dis[3][3];
	node(){
		memset(lmax,0,sizeof(lmax));
		memset(rmax,0,sizeof(rmax));
		memset(dis,0,sizeof(dis));
	}
	bool empty(){
		if(!lmax[0]&&!lmax[1]&&!rmax[0]&&!rmax[1]&&!dis[0][0]&&!dis[0][1]&&!dis[1][0]&&!dis[1][1]) return true;
		else return false;
	}
}t[200001];
node merge(node a,node b){
	node c;
	if(a.empty()) return b;
	if(b.empty()) return a;
	for(int i=0;i<=1;i++){
		for(int j=0;j<=1;j++){
			c.lmax[i]=max(c.lmax[i],max(a.lmax[i],a.dis[i][j]+b.lmax[j]));
			c.rmax[i]=max(c.rmax[i],max(b.rmax[i],b.dis[j][i]+a.rmax[j]));
			c.dis[i][j]=-1e8;
			for(int k=0;k<=1;k++) c.dis[i][j]=max(c.dis[i][j],a.dis[i][k]+b.dis[k][j]);
		}
	}
	return c;
}
void updata(int rt,int l,int r,int x,int v1,int v2){
	if(l==r){
		if(v1==1&&v2==1){
			t[rt].lmax[0]=t[rt].lmax[1]=t[rt].rmax[0]=t[rt].rmax[1]=t[rt].dis[0][1]=t[rt].dis[1][0]=2;
			t[rt].dis[0][0]=t[rt].dis[1][1]=1;
		}
		else if(v1==1&&v2==0){
			t[rt].lmax[0]=t[rt].rmax[0]=t[rt].dis[0][0]=1;
			t[rt].lmax[1]=t[rt].rmax[1]=0;
			t[rt].dis[1][1]=t[rt].dis[1][0]=t[rt].dis[0][1]=-1e8;
		}
		else if(v1==0&&v2==1){
			t[rt].lmax[1]=t[rt].rmax[1]=t[rt].dis[1][1]=1;
			t[rt].lmax[0]=t[rt].rmax[0]=0;
			t[rt].dis[0][0]=t[rt].dis[1][0]=t[rt].dis[0][1]=-1e8;
		}
		else{
			t[rt].lmax[0]=t[rt].lmax[1]=t[rt].rmax[0]=t[rt].rmax[1]=0;
			t[rt].dis[0][0]=t[rt].dis[0][1]=t[rt].dis[1][0]=t[rt].dis[1][1]=-1e8;
		}
		return;
	}
	int mid=(l+r)/2;
	if(x<=mid) updata(rt*2,l,mid,x,v1,v2);
	else updata(rt*2+1,mid+1,r,x,v1,v2);
	t[rt]=merge(t[rt*2],t[rt*2+1]);
}
node query(int rt,int l,int r,int L,int R){
	if(L<=l&&r<=R) return t[rt];
	int mid=(l+r)/2;
	node res;
	if(L<=mid) res=merge(res,query(rt*2,l,mid,L,R));
	if(R>mid) res=merge(res,query(rt*2+1,mid+1,r,L,R));
	return res;
}
int lookup(int u,int v){
	node r1,r2;
	while(top[u]!=top[v]){
		if(dep[top[u]]>dep[top[v]]){
			r1=merge(query(1,1,n,dfn[top[u]],dfn[u]),r1);
			u=fa[top[u]];
		}
		else{
			r2=merge(query(1,1,n,dfn[top[v]],dfn[v]),r2);
			v=fa[top[v]];
		}
	}
	if(dfn[u]>dfn[v]) r1=merge(query(1,1,n,dfn[v],dfn[u]),r1);
	else r2=merge(query(1,1,n,dfn[u],dfn[v]),r2);
	swap(r1.lmax[0],r1.rmax[0]);
	swap(r1.lmax[1],r1.rmax[1]);
	swap(r1.dis[1][0],r1.dis[0][1]);
	r1=merge(r1,r2);
	return max(r1.lmax[0],r1.lmax[1]);
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<n;i++){
		scanf("%d%d",&x,&y);
		G[x].push_back(y);
		G[y].push_back(x);
	}
	dep[1]=1;
	dfs1(1);
	dfs2(1,1);
	for(int i=1;i<=n;i++){
		scanf("%s",s);
		updata(1,1,n,dfn[i],(s[0]=='.'),(s[1]=='.'));
	}
	while(m--){
		scanf("%s%d",s,&x);
		if(s[0]=='Q'){
			scanf("%d",&y);
			printf("%d\n",lookup(x,y));
		}
		else{
			scanf("%s",s);
			updata(1,1,n,dfn[x],(s[0]=='.'),(s[1]=='.'));
		}
	}
	return 0;
}
```

---

## 作者：yzhang (赞：3)

### [更好的阅读](https://www.cnblogs.com/yzhang-rp-inf/p/10211747.html )

### [原题传送门](https://www.luogu.org/problemnew/show/P4679)

### ~~码农题~~树剖好题，口袋妖怪是个好玩的游戏

### 这道题要用树链剖分，我博客里有[对树链剖分的详细介绍](https://www.cnblogs.com/yzhang-rp-inf/p/9966136.html)

#### 下文左右就代表树的节点按dfs序后的左右，上、下分别表示每个节点的A、B区域

考虑在链上的情况，在当前考虑的区间中，令dis[0][0]表示从左上走到右上的最长路，dis[0][1]表示从左上到右下,dis[1][0],dis[1][1]以此类推. 令maxx[0][0]表示从左上出发能走的最大距离,maxx[0][1]表示左下的，maxx[1][0]表示右上,maxx[1][1]表示右下.它们的合并比较简单.令当前区间为c,左半区间为a,右半区间为b,那么：

```cpp
	c.dis[0][0]=Max(-inf,Max(a.dis[0][0]+b.dis[0][0],a.dis[0][1]+b.dis[1][0]));
	c.dis[0][1]=Max(-inf,Max(a.dis[0][0]+b.dis[0][1],a.dis[0][1]+b.dis[1][1]));
	c.dis[1][0]=Max(-inf,Max(a.dis[1][1]+b.dis[1][0],a.dis[1][0]+b.dis[0][0]));
	c.dis[1][1]=Max(-inf,Max(a.dis[1][1]+b.dis[1][1],a.dis[1][0]+b.dis[0][1]));
	c.maxx[0][0]=Max(a.maxx[0][0],Max(a.dis[0][0]+b.maxx[0][0],a.dis[0][1]+b.maxx[0][1]));
	c.maxx[0][1]=Max(a.maxx[0][1],Max(a.dis[1][0]+b.maxx[0][0],a.dis[1][1]+b.maxx[0][1]));
	c.maxx[1][0]=Max(b.maxx[1][0],Max(b.dis[0][0]+a.maxx[1][0],b.dis[1][0]+a.maxx[1][1]));
	c.maxx[1][1]=Max(b.maxx[1][1],Max(b.dis[0][1]+a.maxx[1][0],b.dis[1][1]+a.maxx[1][1]));
```

在树上怎么办呢？每次询问的是两个点之间的路径，很显然，要用线段树+树链剖分. 如果询问的两个点分别是x,y,令lans表示x向上跳得到的答案，rans表示y向上跳得到的答案，最后要将lans取反再与rans合并，因为当两个点最后跳到一起时，它们的左端点对应左端点，右端点对应右端点，而我们要求左端点对应右端点，右端点对应左端点，所以要取反（这个珂以画个图理解一下子）

```cpp
#include <bits/stdc++.h>
#define N 50005
#define inf (1<<30)
using namespace std;
inline int read()
{
    register int x=0,f=1;register char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return x*f;
}
inline void write(register int x)
{
    if(!x)putchar('0');if(x<0)x=-x,putchar('-');
    static int sta[20];register int tot=0;
    while(x)sta[tot++]=x%10,x/=10;
    while(tot)putchar(sta[--tot]+48);
}
inline void Swap(register int &a,register int &b)
{
    a^=b^=a^=b;
}
inline int Max(register int x,register int y)
{
    return x>y?x:y;
}
struct edge{
    int to,next;
}eg[N<<1];
int head[N],cnt=0;
inline void add(register int u,register int v)
{
    eg[++cnt]=(edge){v,head[u]};
    head[u]=cnt;
}
int n,m;
int size[N],dep[N],fa[N],son[N];
int tot=0,dl[N],id[N],top[N];
int a[N][2]; 
inline void dfs1(register int x,register int faa)
{
    fa[x]=faa;
    size[x]=1;
    dep[x]=dep[faa]+1;
    for(register int i=head[x];i;i=eg[i].next)
    {
    	int v=eg[i].to;
    	if(v==faa)
    		continue;
    	dfs1(v,x);
    	size[x]+=size[v];
    	if(size[v]>size[son[x]])
    		son[x]=v;
    }
}
inline void dfs2(register int x,register int t)
{
    dl[x]=++tot;
    id[tot]=x;
    top[x]=t;
    if(son[x])
        dfs2(son[x],t);
    for(register int i=head[x];i;i=eg[i].next)
    {
    	int v=eg[i].to;
    	if(v==fa[x]||v==son[x])
    		continue;
    	dfs2(v,v);
    }
}
struct node{
    int dis[2][2],maxx[2][2];
    inline void clear()
    {
        memset(dis,0,sizeof(dis));
        memset(maxx,0,sizeof(maxx));
    }
    inline bool emptyy()
    {
        if(!dis[0][0]&&!dis[0][1]&&!dis[1][0]&&!dis[1][1]&&!maxx[0][0]&&!maxx[0][1]&&!maxx[1][0]&&!maxx[1][1])
            return true;
        return false;
    }
}e[N<<2];
inline node pushup(register node a,register node b)
{
    node c;
    if(a.emptyy())
        c=b;
    else if(b.emptyy())
        c=a;
    else
    {
        c.dis[0][0]=Max(-inf,Max(a.dis[0][0]+b.dis[0][0],a.dis[0][1]+b.dis[1][0]));
        c.dis[0][1]=Max(-inf,Max(a.dis[0][0]+b.dis[0][1],a.dis[0][1]+b.dis[1][1]));
        c.dis[1][0]=Max(-inf,Max(a.dis[1][1]+b.dis[1][0],a.dis[1][0]+b.dis[0][0]));
        c.dis[1][1]=Max(-inf,Max(a.dis[1][1]+b.dis[1][1],a.dis[1][0]+b.dis[0][1]));
        c.maxx[0][0]=Max(a.maxx[0][0],Max(a.dis[0][0]+b.maxx[0][0],a.dis[0][1]+b.maxx[0][1]));
        c.maxx[0][1]=Max(a.maxx[0][1],Max(a.dis[1][0]+b.maxx[0][0],a.dis[1][1]+b.maxx[0][1]));
        c.maxx[1][0]=Max(b.maxx[1][0],Max(b.dis[0][0]+a.maxx[1][0],b.dis[1][0]+a.maxx[1][1]));
        c.maxx[1][1]=Max(b.maxx[1][1],Max(b.dis[0][1]+a.maxx[1][0],b.dis[1][1]+a.maxx[1][1]));
    }
    return c;
}
inline void build(register int x,register int l,register int r)
{
    if(l==r)
    {
        int p=a[id[l]][0],q=a[id[l]][1];
        if(p==1&&q==1)
        {
            e[x].dis[0][0]=e[x].dis[1][1]=1;
            e[x].dis[0][1]=e[x].dis[1][0]=2;
            e[x].maxx[0][0]=e[x].maxx[0][1]=e[x].maxx[1][0]=e[x].maxx[1][1]=2;
        }
        else if(p==1)
        {
            e[x].dis[0][0]=1;
            e[x].dis[0][1]=e[x].dis[1][0]=e[x].dis[1][1]=-inf;
            e[x].maxx[0][0]=e[x].maxx[1][0]=1;
            e[x].maxx[0][1]=e[x].maxx[1][1]=-inf;
        }
        else if(q==1)
        {
            e[x].dis[0][0]=e[x].dis[0][1]=e[x].dis[1][0]=-inf;
            e[x].dis[1][1]=1;
            e[x].maxx[0][0]=e[x].maxx[1][0]=-inf;
            e[x].maxx[0][1]=e[x].maxx[1][1]=1;
        }
        else
        {
            for(register int i=0;i<=1;++i)
                for(register int j=0;j<=1;++j)
                    e[x].dis[i][j]=e[x].maxx[i][j]=-inf;
        }
        return;
    }
    int mid=l+r>>1;
    build(x<<1,l,mid);
    build(x<<1|1,mid+1,r);
    e[x]=pushup(e[x<<1],e[x<<1|1]);
}
inline void update(register int x,register int l,register int r,register int v,register int p,register int q)
{
    if(l==r)
    {
        if(p==1&&q==1)
        {
            e[x].dis[0][0]=e[x].dis[1][1]=1;
            e[x].dis[0][1]=e[x].dis[1][0]=2;
            e[x].maxx[0][0]=e[x].maxx[0][1]=e[x].maxx[1][0]=e[x].maxx[1][1]=2;
        }
        else if(p==1)
        {
            e[x].dis[0][0]=1;
            e[x].dis[0][1]=e[x].dis[1][0]=e[x].dis[1][1]=-inf;
            e[x].maxx[0][0]=e[x].maxx[1][0]=1;
            e[x].maxx[0][1]=e[x].maxx[1][1]=-inf;
        }
        else if(q==1)
        {
            e[x].dis[0][0]=e[x].dis[0][1]=e[x].dis[1][0]=-inf;
            e[x].dis[1][1]=1;
            e[x].maxx[0][0]=e[x].maxx[1][0]=-inf;
            e[x].maxx[0][1]=e[x].maxx[1][1]=1;
        }
        else
        {
            for(register int i=0;i<=1;++i)
                for(register int j=0;j<=1;++j)
                    e[x].dis[i][j]=e[x].maxx[i][j]=-inf;
        }
        return;
    }
    int mid=l+r>>1;
    if(v<=mid)
        update(x<<1,l,mid,v,p,q);
    else
        update(x<<1|1,mid+1,r,v,p,q);
    e[x]=pushup(e[x<<1],e[x<<1|1]);
}
inline node rev(register node a)
{
    Swap(a.maxx[0][0],a.maxx[1][0]);
    Swap(a.maxx[0][1],a.maxx[1][1]);
    Swap(a.dis[0][1],a.dis[1][0]);
    return a;
}
inline node query(register int x,register int l,register int r,register int L,register int R)
{
    if(l==L&&r==R)
        return e[x];
    int mid=l+r>>1;
    if(R<=mid)
        return query(x<<1,l,mid,L,R);
    else if(L>mid)
        return query(x<<1|1,mid+1,r,L,R);
    else
        return pushup(query(x<<1,l,mid,L,mid),query(x<<1|1,mid+1,r,mid+1,R));
}
inline int Query(register int x,register int y)
{
    node lans,rans;
    lans.clear();
    rans.clear();
    while(top[x]!=top[y])
    {
        if(dep[top[x]]<dep[top[y]])
        {
            rans=pushup(query(1,1,n,dl[top[y]],dl[y]),rans);
            y=fa[top[y]];
        }
        else
        {
            lans=pushup(query(1,1,n,dl[top[x]],dl[x]),lans);
            x=fa[top[x]];
        }
    }
    if(dep[x]>dep[y])
        lans=pushup(query(1,1,n,dl[y],dl[x]),lans);
    else
        rans=pushup(query(1,1,n,dl[x],dl[y]),rans);
    lans=pushup(rev(lans),rans);
    int res=Max(lans.maxx[0][0],lans.maxx[0][1]);
    return res<0?0:res;
}
int main()
{
    n=read(),m=read();
    for(register int i=1;i<n;++i)
    {
        int u=read(),v=read();
        add(u,v),add(v,u);
    }
    dfs1(1,0);
    dfs2(1,1);
    for(register int i=1;i<=n;++i)
    {
        char ch[3];
        scanf("%s",ch);
        a[i][0]=(ch[0]=='.')?1:0;
        a[i][1]=(ch[1]=='.')?1:0;
    }
    build(1,1,n);
    while(m--)
    {
        char c=getchar();
        while(c!='C'&&c!='Q')
            c=getchar();
        if(c=='C')
        {
            int u=read();
            char s[3];
            scanf("%s",s);
            int p=(s[0]=='.')?1:0,q=(s[1]=='.')?1:0;
            update(1,1,n,dl[u],p,q);
        }
        else
        {
            int u=read(),v=read();
            write(Query(u,v)),puts("");
        }
    } 
    return 0;
}
```

---

## 作者：PragmaGCC (赞：2)

很恶臭的树剖题。

首先考虑在一条链上的情况：

我们定义$(0,0)$左上$\rightarrow$右上，$(0,1)$左上$\rightarrow$右下，以此类推。$dis$为最长路，$l/rmax$为从左/右出发的答案。

区间$\max$想到线段树，合并就是分类讨论：
```cpp
node merge(node a, node b) {
    node tmp;
    tmp.dis[0][0] = max(a.dis[0][0] + b.dis[0][0], a.dis[0][1] + b.dis[1][0]);
    if (tmp.dis[0][0] < 0)
        tmp.dis[0][0] = -INF;
    tmp.dis[0][1] = max(a.dis[0][0] + b.dis[0][1], a.dis[0][1] + b.dis[1][1]);
    if (tmp.dis[0][1] < 0)
        tmp.dis[0][1] = -INF;
    tmp.dis[1][0] = max(a.dis[1][0] + b.dis[0][0], a.dis[1][1] + b.dis[1][0]);
    if (tmp.dis[1][0] < 0)
        tmp.dis[1][0] = -INF;
    tmp.dis[1][1] = max(a.dis[1][0] + b.dis[0][1], a.dis[1][1] + b.dis[1][1]);
    if (tmp.dis[1][1] < 0)
        tmp.dis[1][1] = -INF;
    tmp.lmax[0] = max(a.dis[0][0] + b.lmax[0], a.dis[0][1] + b.lmax[1]);
    tmp.lmax[0] = max(tmp.lmax[0], a.lmax[0]);
    if (tmp.lmax[0] < 0)
        tmp.lmax[0] = -INF;
    tmp.lmax[1] = max(a.dis[1][0] + b.lmax[0], a.dis[1][1] + b.lmax[1]);
    tmp.lmax[1] = max(tmp.lmax[1], a.lmax[1]);
    if (tmp.lmax[1] < 0)
        tmp.lmax[1] = -INF;
    tmp.rmax[0] = max(b.dis[0][0] + a.rmax[0], b.dis[1][0] + a.rmax[1]);
    tmp.rmax[0] = max(tmp.rmax[0], b.rmax[0]);
    if (tmp.rmax[0] < 0)
        tmp.rmax[0] = -INF;
    tmp.rmax[1] = max(b.dis[0][1] + a.rmax[0], b.dis[1][1] + a.rmax[1]);
    tmp.rmax[1] = max(tmp.rmax[1], b.rmax[1]);
    if (tmp.rmax[1] < 0)
        tmp.rmax[1] = -INF;
    return tmp;
}
```
再考虑树上的情况。很容易想到用重链剖分转成链上的问题求解。

由于我们是在树上统计，所以需要求出$(x,y)$的 LCA $z$，算出$x \rightarrow z$和$z \rightarrow y$的答案。但是树剖得到的结果都是自顶向下的，所以需要翻转一条链。
```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
using namespace std;
namespace PragmaGCC {
	#define isdigit(ch) (ch >= '0' && ch <= '9')
	#define debug(...) fprintf(stderr,__VA_ARGS__)
	#define Debug(x) debug("Passing [%s] in LINE %d , %s=%d\n",__FUNCTION__,__LINE__,#x,x)
	template <typename T> T read(T &n) {
		int f = 1; char ch = getchar();
		n = 0;
		for (; !isdigit(ch); ch=getchar()) if (ch == '-') f = -1;
		for (; isdigit(ch); ch=getchar()) n = (n << 3) + (n << 1) + (ch ^ 48);
		return n *= f;
	}
	template <typename T> void write(T x) {
	    char F[200];
	    if (!x) putchar('0');
	    if(x < 0) putchar('-'), x = -x;
	    int cnt = 0;
    	for (; x; x/=10) F[cnt++] = x % 10 + '0';
     	while(cnt > 0) putchar(F[--cnt]);
	}
}
using namespace PragmaGCC; 
const int N = 60007, INF = 1e9;
int n, m;
bool mp[N][2];
struct Edge {
    int to, next;
} e[N << 1];
int head[N], ecnt;
void addedge(int from, int to) {
    e[++ecnt] = (Edge){ to, head[from] };
    head[from] = ecnt;
}
int dep[N], pre[N], siz[N];
int hson[N], dfn[N], tot, pos[N], top[N];
void dfs1(int x, int fa) {
    dep[x] = dep[fa] + 1;
    pre[x] = fa, siz[x] = 1;
    for (int i = head[x]; i; i = e[i].next) {
        const int y = e[i].to;
        if (y == fa)
            continue;
        dfs1(y, x);
        siz[x] += siz[y];
        if (siz[y] > siz[hson[x]])
            hson[x] = y;
    }
}
void dfs2(int x, int tp) {
    dfn[x] = ++tot, pos[tot] = x, top[x] = tp;
    if (hson[x])
        dfs2(hson[x], tp);
    for (int i = head[x]; i; i = e[i].next) {
        const int y = e[i].to;
        if ((y == pre[x]) || (y == hson[x]))
            continue;
        dfs2(y, y);
    }
}
struct node {
    int lmax[2], rmax[2], dis[2][2];
} t[N << 2];
#define ls(k) k << 1
#define rs(k) k << 1 | 1
node reset = { { 0, 0 }, { 0, 0 }, { { 0, 0 }, { 0, 0 } } };
node merge(node a, node b) {
    node tmp;
    tmp.dis[0][0] = max(a.dis[0][0] + b.dis[0][0], a.dis[0][1] + b.dis[1][0]);
    if (tmp.dis[0][0] < 0)
        tmp.dis[0][0] = -INF;
    tmp.dis[0][1] = max(a.dis[0][0] + b.dis[0][1], a.dis[0][1] + b.dis[1][1]);
    if (tmp.dis[0][1] < 0)
        tmp.dis[0][1] = -INF;
    tmp.dis[1][0] = max(a.dis[1][0] + b.dis[0][0], a.dis[1][1] + b.dis[1][0]);
    if (tmp.dis[1][0] < 0)
        tmp.dis[1][0] = -INF;
    tmp.dis[1][1] = max(a.dis[1][0] + b.dis[0][1], a.dis[1][1] + b.dis[1][1]);
    if (tmp.dis[1][1] < 0)
        tmp.dis[1][1] = -INF;
    tmp.lmax[0] = max(a.dis[0][0] + b.lmax[0], a.dis[0][1] + b.lmax[1]);
    tmp.lmax[0] = max(tmp.lmax[0], a.lmax[0]);
    if (tmp.lmax[0] < 0)
        tmp.lmax[0] = -INF;
    tmp.lmax[1] = max(a.dis[1][0] + b.lmax[0], a.dis[1][1] + b.lmax[1]);
    tmp.lmax[1] = max(tmp.lmax[1], a.lmax[1]);
    if (tmp.lmax[1] < 0)
        tmp.lmax[1] = -INF;
    tmp.rmax[0] = max(b.dis[0][0] + a.rmax[0], b.dis[1][0] + a.rmax[1]);
    tmp.rmax[0] = max(tmp.rmax[0], b.rmax[0]);
    if (tmp.rmax[0] < 0)
        tmp.rmax[0] = -INF;
    tmp.rmax[1] = max(b.dis[0][1] + a.rmax[0], b.dis[1][1] + a.rmax[1]);
    tmp.rmax[1] = max(tmp.rmax[1], b.rmax[1]);
    if (tmp.rmax[1] < 0)
        tmp.rmax[1] = -INF;
    return tmp;
}
node change(bool *a) {
    node res;
    if (a[0] && a[1]) {
        res.lmax[0] = res.lmax[1] = res.rmax[0] = res.rmax[1] = 2;
        res.dis[0][0] = res.dis[1][1] = 1;
        res.dis[0][1] = res.dis[1][0] = 2;
    } else if (a[0]) {
        res.lmax[0] = res.rmax[0] = res.dis[0][0] = 1;
        res.lmax[1] = res.rmax[1] = -INF;
        res.dis[0][1] = res.dis[1][0] = res.dis[1][1] = -INF;
    } else if (a[1]) {
        res.lmax[1] = res.rmax[1] = res.dis[1][1] = 1;
        res.lmax[0] = res.rmax[0] = 0;
        res.dis[0][1] = res.dis[1][0] = res.dis[0][0] = -INF;
    } else {
        res.lmax[0] = res.lmax[1] = res.rmax[0] = res.rmax[1] = -INF;
        res.dis[0][0] = res.dis[1][1] = -INF;
        res.dis[0][1] = res.dis[1][0] = -INF;
    }
    return res;
}
void build(int k, int l, int r) {
    if (l == r) {
        t[k] = change(mp[pos[l]]);
        return;
    }
    const int mid = (l + r) >> 1;
    build(ls(k), l, mid), build(rs(k), mid + 1, r);
    t[k] = merge(t[ls(k)], t[rs(k)]);
    return;
}
void update(int k, int l, int r, int p, bool *rm) {
    if (l == r) {
        t[k] = change(rm);
        return;
    }
    const int mid = (l + r) >> 1;
    if (p <= mid)
        update(ls(k), l, mid, p, rm);
    else
        update(rs(k), mid + 1, r, p, rm);
    t[k] = merge(t[ls(k)], t[rs(k)]);
    return;
}
node query(int k, int l, int r, int ql, int qr) {
    if (l >= ql && r <= qr) {
        return t[k];
    }
    const int mid = (l + r) >> 1;
    if (mid >= qr)
        return query(ls(k), l, mid, ql, qr);
    else if (mid < ql)
        return query(rs(k), mid + 1, r, ql, qr);
    else
        return merge(query(ls(k), l, mid, ql, qr), query(rs(k), mid + 1, r, ql, qr));
}
int qquery(int x, int y) {
    node res1 = reset, res2 = reset;
    while (top[x] != top[y]) {
        if (dep[top[x]] > dep[top[y]])
            res1 = merge(query(1, 1, n, dfn[top[x]], dfn[x]), res1), x = pre[top[x]];
        else
            res2 = merge(query(1, 1, n, dfn[top[y]], dfn[y]), res2), y = pre[top[y]];
    }
    if (dep[x] > dep[y])
        res1 = merge(query(1, 1, n, dfn[y], dfn[x]), res1);
    else
        res2 = merge(query(1, 1, n, dfn[x], dfn[y]), res2);
    swap(res1.lmax[0], res1.rmax[0]);
    swap(res1.lmax[1], res1.rmax[1]);
    swap(res1.dis[0][1], res1.dis[1][0]);
    res1 = merge(res1, res2);
    return max(res1.lmax[0], res1.lmax[1]);
}
char tmp[5];
int main(void) {
    read(n), read(m);
    for (int i = 1, u, v; i < n; i++) {
        read(u), read(v);
        addedge(u, v), addedge(v, u);
    }
    dfs1(1, 0), dfs2(1, 1);
    for (int i = 1; i <= n; i++) {
    	scanf("%s", tmp);
    	mp[i][0] = (tmp[0] == '.'), mp[i][1] = (tmp[1] == '.');
    }
    build(1, 1, n);
    for (int i = 1; i <= m; i++) {
        scanf("%s", tmp);
        int x, y;
        if (tmp[0] == 'C') {
            read(x);
            scanf("%s", tmp);
            mp[x][0] = (tmp[0] == '.'), mp[x][1] = (tmp[1] == '.');
            update(1, 1, n, dfn[x], mp[x]);
        } else {
            read(x), read(y);
            write(qquery(x, y));
            puts("");
        }
    }
    return 0;
}
```

---

## 作者：jun头吉吉 (赞：2)

## 题意
一棵 $n$ 个节点的树，每个节点有 $A,B$ 两个房间，一些房间可以走一些不行，只能从同一个房间的 $A\to B$ 或走到不同节点的同一个房间。从 $u$ 到 $v$ 的路径最多经过几个房间。动态修改。
## 题解
貌似全是树剖，这里来一发 $\mathbf{ LCT}$

其实操作十分板，不过细节是真心多。

用一个 `node` 来表示状态:

1. $lmx_{i} (i\in\{0,1\})$ 表示从当前节点最左侧的 $i$ 房间开始的最大距离
1. $rmx_{i} (i\in\{0,1\})$ 表示从当前节点最右侧的 $i$ 房间开始的最大距离
1. $dis_{i,j}(i,j\in\{0,1\})$ 表示从当前节点最左侧 $i$ 房间到最右侧 $j$ 房间的最大距离。

合并稍微思考一下即可。~~虽然我写挂调试了3个小时~~

翻转时不要忘记 `node` 的信息也要翻转。
## 代码
```cpp
#include<bits/stdc++.h>
namespace in{
	#ifndef slow
	char buf[1<<21],*p1=buf,*p2=buf;
	inline int getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}
	#else
	inline int getc(){return getchar();}
	#endif
	template <typename T>inline void read(T& t){
		t=0;int f=0;char ch=getc();while (!isdigit(ch)){if(ch=='-')f = 1;ch=getc();}
	    while(isdigit(ch)){t=t*10+ch-48;ch = getc();}if(f)t=-t;
	}
	template <typename T,typename... Args> inline void read(T& t, Args&... args){read(t);read(args...);}
	char getC(){char c=getc();while(c!='#'&&c!='.'&&!isalpha(c))c=getc();return c;}
}
namespace out{
	char buffer[1<<21];int p1=-1;const int p2 = (1<<21)-1;
	inline void flush(){fwrite(buffer,1,p1+1,stdout),p1=-1;}
	inline void putc(const char &x) {if(p1==p2)flush();buffer[++p1]=x;}
	template <typename T>void write(T x) {
		static char buf[15];static int len=-1;if(x>=0){do{buf[++len]=x%10+48,x/=10;}while (x);}else{putc('-');do {buf[++len]=-(x%10)+48,x/=10;}while(x);}
		while (len>=0)putc(buf[len]),--len;
	}
}
using namespace std;
const int N=1e5+10;
const int inf=1e9;
#define chkmx(a,b) (a)=max((a),(b))
int n,m,c[N][2],f[N],r[N],v[N][2];
struct node{
	int lmx[2],rmx[2];int dis[2][2];
	node(){
		memset(lmx,0,sizeof lmx);
		memset(rmx,0,sizeof rmx);
		memset(dis,0,sizeof dis);
	}
	node(int *a){
		memset(lmx,0,sizeof lmx);
		memset(rmx,0,sizeof rmx);
		memset(dis,0,sizeof dis);
		if(a[0]&&a[1]){
			for(int i=0;i<2;i++)lmx[i]=rmx[i]=2;
			for(int i=0;i<2;i++)
				for(int j=0;j<2;j++)
					dis[i][j]=i==j?1:2;
		}
		else if(a[0]||a[1]){
			int op=a[0]?0:1;
			lmx[op]=rmx[op]=dis[op][op]=1;
			lmx[op^1]=rmx[op^1]=0;
			dis[op][op^1]=dis[op^1][op]=dis[op^1][op^1]=-inf;
		}
		else{
			for(int i=0;i<2;i++)lmx[i]=rmx[i]=0;
			for(int i=0;i<2;i++)
				for(int j=0;j<2;j++)
					dis[i][j]=-inf;
		}
	}
	friend node operator+(const node l,const node r){
		node res=node();
		for(int i=0;i<2;i++)
			for(int j=0;j<2;j++)
				chkmx(res.lmx[i],max(l.lmx[i],l.dis[i][j]+r.lmx[j]));
		for(int i=0;i<2;i++)
			for(int j=0;j<2;j++)
				chkmx(res.rmx[i],max(r.rmx[i],r.dis[j][i]+l.rmx[j]));
		for(int i=0;i<2;i++)
			for(int j=0;j<2;j++){
				res.dis[i][j]=-inf;
				for(int k=0;k<2;k++)
					chkmx(res.dis[i][j],l.dis[i][k]+r.dis[k][j]);
			}
		return res;
	}
}t[N];
//v=1 可走 否则不可走
#define lc c[x][0]
#define rc c[x][1]
#define get(x) (c[f[x]][1]==x)
#define nroot(x) (c[f[x]][0]==x||c[f[x]][1]==x)
void pushr(int x){
	swap(lc,rc);r[x]^=1;
	swap(t[x].rmx,t[x].lmx);
	swap(t[x].dis[0][1],t[x].dis[1][0]);
}
void pushdown(int x){
	if(r[x]){
		if(lc)pushr(lc);
		if(rc)pushr(rc);
		r[x]=0;
	}
}
void pushall(int x){
	if(nroot(x))pushall(f[x]);
	pushdown(x);
}
#define chkmx(a,b) (a)=max((a),(b))
void pushup(int x){
	//***********************************
	t[x]=node(v[x]);
	if(lc)t[x]=t[lc]+t[x];
	if(rc)t[x]=t[x]+t[rc];
}
void rotate(int x){
	int fa=f[x],ffa=f[fa],k=get(x),w=c[x][!k];
	if(nroot(fa))c[ffa][get(fa)]=x;c[x][!k]=fa;c[fa][k]=w;
	if(w)f[w]=fa;f[x]=ffa;f[fa]=x;pushup(fa);
}
void splay(int x){
	pushall(x);
	while(nroot(x)){
		int fa=f[x];
		if(nroot(fa))
			rotate(get(x)==get(fa)?fa:x);
		rotate(x);
	}
	pushup(x);
}
void access(int x){
	for(int y=0;x;y=x,x=f[x])
		splay(x),rc=y,pushup(x);
}
void makeroot(int x){
	access(x);splay(x);pushr(x);
}
void split(int x,int y){
	makeroot(x);access(y);splay(y);
}
vector<int>e[N];
void dfs(int u){
	for(auto v:e[u])if(v!=f[u])
		f[v]=u,dfs(v);
	pushup(u);
}
signed main(){
	//freopen("9.in","r",stdin);
	//freopen("my.out","w",stdout);
	in::read(n,m);
	for(int i=1,x,y;i<n;i++)
		in::read(x,y),e[x].push_back(y),e[y].push_back(x);
	for(int i=1;i<=n;i++){
		v[i][0]=in::getC()=='.';
		v[i][1]=in::getC()=='.';
	}
	dfs(1);
	while(m--){
		char op=in::getC();
		if(op=='Q'){
			int u,v;in::read(u,v);
			split(u,v);
			//out::write(u);out::putc(' ');
			//out::write(v);out::putc(' ');
			out::write(max(t[v].lmx[0],t[v].lmx[1]));out::putc('\n');
		}else{
			int u;in::read(u);splay(u);
			v[u][0]=in::getC()=='.';
			v[u][1]=in::getC()=='.';
			pushup(u);
		}
	}
	out::flush();
	return 0;
}
```

---

## 作者：Li_Yichen (赞：0)

树剖。有两种移动方式，一种是走到相邻点的同一位置，或者走到当前点的另一位置。那么我们在处理答案的时候，处理 $lmax_i$，$rmax_i$ 和 $dis_{i,j}$ 来分别表示从左侧出发向右走的最大值，从右侧出发向左走的最大值和从左到右，也可以说从右到达左的距离和。

那么用线段树维护时，就可以快速计算，此时向右走有两种走法，一种是直接从 $u$ 走，另一种是从 $u$ 走到 $v$ 再走到目标；向左走同理。距离数组 $dis$ 可以从通过类似全源最短路求解。

这题有很多注意事项，首先在合并时注意不能合并空白节点，所以询问答案的时候合并顺序不能交换。第二，要写一个初始化函数，建树和修改的时候需要用。最后，平时树剖都是同时向上跳，但是我们要求顺序跳，所以还要给左侧翻转一下，具体看代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ls(x) (x << 1)
#define rs(x) ((x << 1) | 1)
#define inf 0x3f3f3f3f
int n,m;
struct node{
    int to;
    int next;
}e[200005];
int cnt;
int head[100005];
int dep[100005],top[100005];
int siz[100005],father[100005];
int son[100005];
int tot;
int dfn[100005],id[100005];
int a[100005][2];
struct segment{
    int lmax[2],rmax[2];
    int dis[2][2];
    segment(){
        for(int i=0;i<=1;i++){
            lmax[i] = rmax[i] = 0;
            for(int j=0;j<=1;j++){
                dis[i][j] = 0;
            }
        }
    }
    void create(int l,int r){//创建新节点，传参为左右是否能走
        int d = 2;
        int u = l,v = r;
        if(!l) d = u = -inf;//走不到
        if(!r) d = v = -inf;
        lmax[0] = rmax[0] = max(u,0);
        lmax[1] = rmax[1] = max(v,0);
        dis[0][0] = u;
        dis[1][1] = v;
        dis[0][1] = dis[1][0] = d;
    }
}tree[1600005];
segment merge(segment u,segment v){
    segment ans;
    for(int i=0;i<=1;i++){
        for(int j=0;j<=1;j++){
            ans.lmax[i] = max(ans.lmax[i],max(u.lmax[i],u.dis[i][j] + v.lmax[j]));
            ans.rmax[i] = max(ans.rmax[i],max(v.rmax[i],v.dis[j][i] + u.rmax[j]));
            ans.dis[i][j] = -inf;
            for(int k=0;k<=1;k++){
                ans.dis[i][j] = max(ans.dis[i][j],u.dis[i][k] + v.dis[k][j]);
            }
        }
    }
    return ans;
}
void pushup(int x){
    tree[x] = merge(tree[ls(x)],tree[rs(x)]);
}
void build(int l,int r,int x){
    if(l == r){
        tree[x].create(a[id[l]][0],a[id[l]][1]);
        return ;
    }
    int mid = (l + r) / 2;
    build(l,mid,ls(x));
    build(mid+1,r,rs(x));
    pushup(x);
}
void update(int q,int l,int r,int x,int k1,int k2){
    if(l == r){
        tree[x].create(k1,k2);
        return ;
    }
    int mid = (l + r) / 2;
    if(q <= mid) update(q,l,mid,ls(x),k1,k2);
    else update(q,mid+1,r,rs(x),k1,k2);
    pushup(x);
}
segment query(int ql,int qr,int l,int r,int x){
    if(ql <= l && r <= qr) return tree[x];
    int mid = (l + r) / 2;
    if(qr <= mid) return query(ql,qr,l,mid,ls(x));
    else if(ql > mid) return query(ql,qr,mid+1,r,rs(x));
    else return merge(query(ql,qr,l,mid,ls(x)),query(ql,qr,mid+1,r,rs(x)));
}
void swap_chain(segment &x){
    for(int i=0;i<=1;i++){
        swap(x.lmax[i],x.rmax[i]);
    }
    swap(x.dis[0][1],x.dis[1][0]);
}
int query_chain(int u,int v){
    segment ans1,ans2;
    while(top[u] != top[v]){
        if(dep[top[u]] > dep[top[v]]) ans1 = merge(query(dfn[top[u]],dfn[u],1,n,1),ans1);
        else ans2 = merge(query(dfn[top[v]],dfn[v],1,n,1),ans2);
        if(dep[top[u]] > dep[top[v]]) u = father[top[u]];
        else v = father[top[v]];
    }
    if(dep[u] > dep[v]) ans1 = merge(query(dfn[v],dfn[u],1,n,1),ans1);
    else ans2 = merge(query(dfn[u],dfn[v],1,n,1),ans2);
    swap_chain(ans1);
    segment ans = merge(ans1,ans2);
    return max(ans.lmax[0],ans.lmax[1]);
}
void add(int u,int v){
    e[++ cnt].to = v;
    e[cnt].next = head[u];
    head[u] = cnt;
}
void dfs1(int u,int fa){
    siz[u] = 1;
    dep[u] = dep[fa] + 1;
    father[u] = fa;
    for(int i=head[u];i;i=e[i].next){
        int v = e[i].to;
        if(v == fa) continue;
        dfs1(v,u);
        siz[u] += siz[v];
        if(siz[son[u]] < siz[v]) son[u] = v;
    }
}
void dfs2(int u,int ntop){
    top[u] = ntop;
    dfn[u] = ++ tot;
    id[tot] = u;
    if(son[u]) dfs2(son[u],ntop);
    for(int i=head[u];i;i=e[i].next){
        int v = e[i].to;
        if(v == son[u] || v == father[u]) continue;
        dfs2(v,v);
    }
}
int main(){
    cin >> n >> m;
    for(int i=1;i<n;i++){
        int u,v;
        cin >> u >> v;
        add(u,v);
        add(v,u);
    }
    for(int i=1;i<=n;i++){
        char c1,c2;
        cin >> c1 >> c2;
        if(c1 == '.') a[i][0] = 1;
        else a[i][0] = 0;
        if(c2 == '.') a[i][1] = 1;
        else a[i][1] = 0;
    }
    dfs1(1,0);
    dfs2(1,1);
    build(1,n,1);
    while(m --){
        char op;
        int u;
        cin >> op >> u;
        if(op == 'C'){
            char c1,c2;
            cin >> c1 >> c2;
            if(c1 == '.') a[u][0] = 1;
            else a[u][0] = 0;
            if(c2 == '.') a[u][1] = 1;
            else a[u][1] = 0;
            update(dfn[u],1,n,1,a[u][0],a[u][1]);
        }else{
            int v;
            cin >> v;
            cout << query_chain(u,v) << "\n";
        }
    }
    return 0;
}
```

---

## 作者：hzjnsy (赞：0)

**[题目传送门](https://www.luogu.com.cn/problem/P4679)**

> - 给出一棵 $n$ 个点的树。每个点有 $\text{A,B}$ 两个区域，若不是障碍物，每次可以走到相邻点的相同区域，或当前点的另一个区域。
>
> - $m$ 次操作，有两种类型：
>
>    - $\texttt{Q }u\texttt{ }v$，查询从 $u$ 开始，向 $v$ 的方向走，最多能不重复地访问多少区域。
>
>    - $\texttt{C }u\texttt{ }s$，将 $u$ 的区域状态改成 $s$。
>
> - $n\le 5\times 10^4$，$m\le 10^5$。

下文用 $0$ 区域代表 $\text{A}$ 区域，用 $1$ 区域代表 $\text{B}$ 区域。

考虑重链剖分 + 线段树。

在线段树的一个节点内，维护：

- $f_{i,j}\,(i,j\in\{0,1\})$ 表示从左端点 $i$ 区域走到右端点 $j$ 区域可以踩的最多格子数。若不能走到，则状态为 $0$。

- $g_{i,j}\,(i,j\in\{0,1\})$ 表示从右端点 $i$ 区域走到左端点 $j$ 区域可以踩的最多格子数。若不能走到，则状态为 $0$。

- $a_i\,(i\in\{0,1\})$ 表示从左端点 $i$ 区域开始最多能走多远。

- $b_i\,(i\in\{0,1\})$ 表示从右端点 $i$ 区域开始最多能走多远。

- $l$ 表示左端点的地图形状。

- $r$ 表示右端点的地图形状。

信息可以这样合并，大概就是考虑是否走过区间中点，以及从哪个区域走过区间中点：

```cpp
#define str string
#define co const
#define mst memset
struct node { 
    int f[2][2], g[2][2], a[2], b[2]; str l, r; bool e; 
    node(str l_ = "", str r_ = "", bool e_ = 1) {
        l = l_; r = r_; e = e_; 
        mst(f, 0, sof f); mst(g, 0, sof g); mst(a, 0, sof a); mst(b, 0, sof b);
    }
    node operator+(co node o) const {
        if (e) return o; if (o.e) return *this; node ret(l, o.r, 0);
        for (int i = 0; i < 2; ++i) {
            ret.a[i] = a[i]; ret.b[i] = o.b[i];
            for (int j = 0; j < 2; ++j) {
                for (int k = 0; k < 2; ++k) {
                    bool op = (r[k] == '.' && o.l[k] == '.');
                    if (op && f[i][k] && o.f[k][j]) 
                        ret.f[i][j] = max(ret.f[i][j], f[i][k] + o.f[k][j]);
                    if (op && o.g[i][k] && g[k][j])
                        ret.g[i][j] = max(ret.g[i][j], o.g[i][k] + g[k][j]);
                }
                bool op = (r[j] == '.' && o.l[j] == '.');
                if (op && f[i][j]) ret.a[i] = max(ret.a[i], f[i][j] + o.a[j]);
                if (op && o.g[i][j]) ret.b[i] = max(ret.b[i], o.g[i][j] + b[j]);
            }   
        }
        return ret;
    }
};
```

对于单点，有初始化：

```cpp
void upd(node &o, co str s) { // 将叶子 o 的地图改成 s。
    o = node(s, s, 0);
    for (int i = 0; i < 2; ++i) 
        if (s[i] == '.') o.f[i][i] = o.g[i][i] = o.a[i] = o.b[i] = 1;
    if (s[0] =='.' && s[1] == '.') 
        o.f[0][1] = o.f[1][0] = o.g[0][1] = o.g[1][0] = 
        o.a[0] = o.a[1] = o.b[0] = o.b[1] = 2;
}
```

只需要支持跳链查询、单点修改即可。注意跳链查询要翻转一条链。

时间复杂度为 $\mathcal{O}(m\log ^2 n)$，空间复杂度为 $\mathcal{O}(n)$。

**[提交记录](https://www.luogu.com.cn/record/131467335) [代码](https://www.luogu.com.cn/paste/l8hxqcn4)**

---


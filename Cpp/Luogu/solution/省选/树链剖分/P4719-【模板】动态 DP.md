# 【模板】动态 DP

## 题目描述

给定一棵 $n$ 个点的树，点带点权。

有 $m$ 次操作，每次操作给定 $x,y$，表示修改点 $x$ 的权值为 $y$。

你需要在每次操作之后求出这棵树的最大权独立集的权值大小。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n,m\le 10$。
- 对于 $60\%$ 的数据，保证 $n,m\le 10^3$。
- 对于 $100\%$ 的数据，保证 $1\le n,m\le 10^5$，$1 \leq u, v , x \leq n$，$-10^2 \leq a_i, y \leq 10^2$。


## 样例 #1

### 输入

```
10 10
-11 80 -99 -76 56 38 92 -51 -34 47 
2 1
3 1
4 3
5 2
6 2
7 1
8 2
9 4
10 7
9 -44
2 -17
2 98
7 -58
8 48
3 99
8 -61
9 76
9 14
10 93
```

### 输出

```
186
186
190
145
189
288
244
320
258
304```

# 题解

## 作者：Tweetuzki (赞：392)

不得不承认，去年提高组 D2T3 对动态 DP 起到了良好的普及效果。

动态 DP 主要用于解决一类问题。这类问题一般原本都是较为简单的树上 DP 问题，但是被套上了~~丧心病狂的~~修改点权的操作。就比如说这道题：

[【模板】动态 DP](https://www.luogu.org/problemnew/show/P4719)

> 给定一棵 $n$ 个点的树。$i$ 号点的点权为 $a_i$。有 $m$ 次操作，每次操作给定 $u, w$，表示修改点 $u$ 的权值为 $w$。你需要在每次操作之后求出这棵树的最大权独立集的权值大小。

我们首先考虑没有修改的情况下怎么做。首先先选取 $1$ 号点作为全树的根。然后我们设 $f_{i, 0}$ 表示不选择 $i$ 号点时，以 $i$ 号点为根的子树的最大权独立集；$f_{i, 1}$ 表示选择 $i$ 号点时，以 $i$ 号点为根的子树的最大权独立集。我们可以很容易地写出如下的方程：

$$ f_{i, 0} = \sum_{j} \max(f_{j, 0}, f_{j, 1})$$
$$f_{i, 1} = \sum_{j} f_{j, 0} + a_i $$

这里 $j$ 表示 $i$ 号点的所有儿子。特殊地，若点 $i$ 为叶子节点，$f_{i, 0} = 0, f_{i, 1} = a_i$。

最后的答案就是 $\max(f_{1, 0}, f_{1, 1})$。

---

接下来带上修改。

首先根据动态规划的转移方程可以发现，我们修改了一个点的点权，只会更改从这个点到根这条路径上节点的 DP 值，其他值是不会发生更改的。这时候如果我们要对整棵树重新求一遍最大权独立集，未免太过浪费。所以我们希望能够更改这条链上的 DP 值。

由于树可能会退化成一条链，这样每次更新就是 $\mathcal{O(n)}$ 的，显然不可接受。我们希望这条链只更新 $\log n$ 次……

~~点分治！~~抱歉博主太弱了，不会那个被称作“全局平衡二叉树”的厉害做法。

这时候我们请出解决树上问题的神器——重链剖分。

重链剖分有一些性质，这些性质正是它在动态 DP 中能够发挥作用的重要保障。

1. 每个点到根的路径上，最多经过 $\log n$ 条轻边。也就是说，重链的条数最多也只有 $\log n$ 条。这为动态 DP 的时间复杂度做了保障。
2. 每条重链的链尾都是叶子节点，且只有叶子节点没有重儿子。这为动态规划的初始状态和转移方式做了保障。
3. 重链剖分中，一条重链所在的区间在剖出的 DFS 序上，是连续的一段区间。这为可以使用数据结构维护区间信息，达到快速转移做了保障。

那么在宏观上，我们相当于在更新时，对于这些重链暴力地互相转移更新。接下来我们考虑一些微观问题：在一条链里，怎么支持快速修改和查询这条链的 DP 值。

我们保持 $f$ 数组的定义不变。为了迎合重链剖分划分出了轻重儿子，我们形式化地定义 $g$ 数组：$g_{i, 1}$ 表示 $i$ 号点的所有轻儿子，都不取的最大权独立集；$g_{i, 0}$ 表示 $i$ 号点的所有轻儿子，可取可不取形成的最大权独立集。这样就可以把上述的 DP 式子大大简化了（至少没有了那个 $\Sigma$）。

$$f_{i, 0} = g_{i, 0} + \max(f_{j, 0}, f_{j, 1})$$
$$f_{i, 1} = g_{i, 1} + a_i + f_{j, 0}$$

这里的 $j$ 表示 $i$ 号点的重儿子。特殊地，对于叶子节点，$g_{i, 0} = g_{i, 1} = 0$。

但是感觉这玩意儿好像不大优美？第二个转移式子中，$g_{i, 1}$ 和 $a_i$ 都只和 $i$ 有关，那么我们不妨把它们合并起来。我们重新定义 $g_{i, 1}$：表示 $i$ 号点只考虑轻儿子的取自己的最大权独立集。那么这时候，第二个方程就可以变为 $f_{i, 1} = g_{i, 1} + f_{j, 0}$。

但是这玩意儿咋区间维护嘞？回想一下当初学习斐波那契的时候，我们碰到过这样的 DP 方程：

$$f_i = f_{i - 1} + f_{i - 2}$$

这个方程涉及上一步的贡献，没法满足结合率，不太舒服。于是我们定义了一个矩阵，化加为乘，于是我们愉快地用快速幂 AC 了。

这道题我们也给它套个矩阵。对于每个点，都表示一个状态，这个状态共有两个值，于是我们考虑维护一个 $1 \times 2$ 的矩阵。

$$ \begin{vmatrix} f_{i, 0} & f_{i, 1} \end{vmatrix} $$

现在我们要从一个点的重儿子 $j$ 转移到 $i$ 上，也就是说我们需要构造出一个转移矩阵使得 $\begin{vmatrix} f_{j, 0} & f_{j, 1} \end{vmatrix}$ 能够转移到 $\begin{vmatrix} f_{i, 0} & f_{i, 1} \end{vmatrix}$。但是我们回顾一下这个转移方程（已更改 $g_{i, 1}$ 的定义）：

$$f_{i, 0} = g_{i, 0} + \max(f_{j, 0}, f_{j, 1})$$
$$f_{i, 1} = g_{i, 1} + f_{j, 0}$$


它一点也不满足矩阵乘法的形式啊！

别慌……我们大胆地重定义矩阵乘法！

我们定义一个新的运算符 $*$，对于矩阵 $\mathrm{A}, \mathrm{B}$，定义 $\mathrm{A} * \mathrm{B}$ 的结果 $\mathrm{C}$，满足：

$$\mathrm{C}_{i, j} = \max_{k}(\mathrm{A}_{i, k} + \mathrm{B}_{k, j})$$

实现到代码上，就是

```cpp
struct Matrix {
  int mat[MaxN][MaxN];
}

inline Matrix operator * (Matrix a, Matrix b) {
  Matrix c;

  for (int i = 0; i < n; ++i)
    for (int j = 0; j < n; ++j)
      for (int k = 0; k < n; ++k)
        c.mat[i][j] = max(c.mat[i][j], a.mat[i][k] + b.mat[k][j]);

  return c;
}
```

但是这个东西为什么具有结合率呢？

- 一种感性的理解：由于 $\max$ 操作和加法操作都是满足结合率的，所以这个运算满足结合率。
- 一种理性但不太严谨的证明：读者不妨拿出之笔，计算几组 $(\mathrm{A} * \mathrm{B}) * \mathrm{C}$ 和 $\mathrm{A} * (\mathrm{B} * \mathrm{C})$ 的值（如果您计算比较厉害，带上参数算当然更好）。一般情况下，证明了三个满足条件，对于所有情况都是能满足条件的。

于是我们口胡完了结合率的证明。那么我们就可以用了。接下来我们要构造一个转移矩阵，这个是相对难的一个内容。我就介绍一下我个人构造转移矩阵的拙劣方法吧。

在构造一个转移矩阵之前，我们先想办法把这玩意儿变形，变得和运算 $*$ 差不多。

$$f_{i, 0} = \max(f_{j, 0} + g_{i, 0}, f_{j, 1} + g_{i, 0})$$
$$f_{i, 1} = \max(g_{i, 1} + f_{j, 0}, -\infty)$$

接着我们把已知的状态和要转移到的状态写在一起，把未知的转移矩阵用 $\mathrm{U}$ 表示。

$$\begin{vmatrix} f_{j, 0} & f_{j, 1} \end{vmatrix} * \mathrm{U} = \begin{vmatrix} f_{i, 0} & f_{i, 1} \end{vmatrix}$$

我们原来是一个 $1 \times 2$ 的矩阵，要形成一个 $1 \times 2$ 的矩阵，那么 $\mathrm{U}$ 应当是一个 $2 \times 2$ 的矩阵。那么我们设矩阵左上、右上、左下、右下四个位置分别为 $u_1, u_2, u_3, u_4$。接下来把每个位置对应上去。

$f_{i, 0}$ 的值应该为 $\max(f_{j, 0} + u_1, f_{j, 1} + u_3)$。对应转移方程，我们发现 $u_1$ 应该就是 $g_{i, 0}$，$u_3$ 也是 $g_{i, 0}$。同样的，$f_{i, 1}$ 的值应该为 $\max(f_{j, 0} + u_2, f_{j, 1} + u_4)$。对应转移方程，我们发现 $u_2$ 应该是 $g_{i, 1}$，而不存在 $f_{j, 1}$ 项，就将 $u_4$ 赋为 $-\infty$。最后写出来，检查一遍：

$$\begin{vmatrix} f_{j, 0} & f_{j, 1} \end{vmatrix} * \begin{vmatrix} g_{i, 0} & g_{i, 1} \\ g_{i, 0} & -\infty \end{vmatrix} = \begin{vmatrix} f_{i, 0} & f_{i, 1} \end{vmatrix}$$

嗯……好像没问题？

这样子，我们对于一条重链，我们的叶子节点就存储了最初始的值，链上每个节点都对应着一个转移矩阵。我们发现这个转移矩阵和重链信息是没有任何关系的，且因为这个矩阵满足结合率，对于一条重链，我们可以之间线段树维护区间乘积（或者叫……“$*$ 积”？）。然后到了一条重链链头，因为这个点是它父亲的轻儿子，我们需要更新它父亲节点所在的点的转移矩阵。这样子一直跳到根节点就可以了。貌似……大功告成？

重链剖分剖出的 DFS 序，由于先访问了链头，所以这个区间中，链头在区间左端，链尾在区间右端。我们存储的初始信息在叶子节点（也就是链尾）上，因此我们的矩阵 $*$ 法应当是转移矩阵在前，要维护的值矩阵在后。我们要把这个矩阵前后换个顺序，再转个个儿，加上一些推算，可以变形成：

$$\begin{vmatrix} g_{i, 0} & g_{i, 0} \\ g_{i, 1} & -\infty \end{vmatrix} * \begin{vmatrix} f_{j, 0} \\ f_{j, 1} \end{vmatrix} = \begin{vmatrix} f_{i, 0} \\ f_{i, 1} \end{vmatrix}$$

这样就真的做完了。最后我写一些关于代码实现的小细节：

1. 对于一个点查其 dp 值，需要从这个点一直查到区间链尾。因此，树剖时我们需要多维护一个 $\texttt{End[i]}$（这里的 $i$ 是一条重链的链头），表示以 $i$ 为链头的这条链，链尾（叶子）节点在 DFS 序上的位置。
2. 更新线段树上某个点的转移矩阵时，传入的如果是矩阵，递归下去常数太大。一个解决方法是，在线段树外，维护一个矩阵组 $\texttt{Val[i]}$，表示每个节点对应的转移矩阵。这样在线段树更新找到对应位置时，直接赋值进来即可。

最后贴上代码。

解释一下变量名：

$\texttt{Id[i]}$ 表示 $i$ 号点在 DFS 序中的位置，$\texttt{Dfn[i]}$ 表示在 DFS 序中下标 $i$ 的位置对应的是什么点（与 $\texttt{Id[i]}$ 相反），$\texttt{Fa[i]}$ 是父亲节点，$\texttt{Siz[i]}$ 是子树大小，$\texttt{Dep[i]}$ 是该节点深度（好像没什么用），$\texttt{Wson[i]}$ 是 $i$ 号节点的重儿子，$\texttt{Top[i]}$ 表示 $i$ 号点所在重链链顶编号。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

const int MaxN = 100000 + 5, MaxM = 200000 + 5;
const int MaxV = 400000 + 5;
const int INF = 0x7F7F7F7F;

struct Matrix {
  int mat[2][2];

  Matrix() {
    memset(mat, -0x3F, sizeof mat);
  }

  inline Matrix operator * (Matrix b) {
    Matrix c;

    for (int i = 0; i < 2; ++i)
      for (int j = 0; j < 2; ++j)
        for (int k = 0; k < 2; ++k)
          c.mat[i][j] = max(c.mat[i][j], mat[i][k] + b.mat[k][j]);

    return c;
  }
};

int N, M; int cntv, cnte;
int A[MaxN];
int Fa[MaxN], Siz[MaxN], Dep[MaxN], Wson[MaxN];
int Top[MaxN], Id[MaxN], Dfn[MaxN], End[MaxN];
int F[MaxN][2];
int Head[MaxN], To[MaxM], Next[MaxM];
Matrix Val[MaxN];

struct SegTree {
  int L[MaxV], R[MaxV];
  Matrix M[MaxV];

  inline void Push_up(int i) {
    M[i] = M[i << 1] * M[i << 1 | 1];
  }

  void Build_Tree(int left, int right, int i) {
    L[i] = left, R[i] = right;
    if (L[i] == R[i]) {
      M[i] = Val[Dfn[L[i]]];
      return;
    }

    int mid = (L[i] + R[i]) >> 1;
    Build_Tree(L[i], mid, i << 1);
    Build_Tree(mid + 1, R[i], i << 1 | 1);
    Push_up(i);
  }

  void Update_Tree(int x, int i) {
    if (L[i] == R[i]) {
      // 直接赋值，减小常数
      M[i] = Val[Dfn[x]];
      return;
    }

    int mid = (L[i] + R[i]) >> 1;
    if (x <= mid) Update_Tree(x, i << 1);
    else Update_Tree(x, i << 1 | 1);
    Push_up(i);
  }

  // 查询一个点的 DP 值，相当于查询这条重链上链尾矩阵和链中转移矩阵的 '*' 积
  Matrix Query_Tree(int left, int right, int i) {
    if (L[i] == left && R[i] == right) return M[i];

    int mid = (L[i] + R[i]) >> 1;
    if (right <= mid)
      return Query_Tree(left, right, i << 1);
    else if (left > mid)
      return Query_Tree(left, right, i << 1 | 1);
    else
      return Query_Tree(left, mid, i << 1) * Query_Tree(mid + 1, right, i << 1 | 1);
  }
} T;

inline void add_edge(int from, int to) {
  cnte++; To[cnte] = to;
  Next[cnte] = Head[from]; Head[from] = cnte;
}

void readin() {
  scanf("%d %d", &N, &M);
  for (int i = 1; i <= N; ++i)
    scanf("%d", &A[i]);
  for (int i = 1; i < N; ++i) {
    int u, v;
    scanf("%d %d", &u, &v);
    add_edge(u, v); add_edge(v, u);
  }
}

void dfs1(int u) {
  Siz[u] = 1;

  for (int i = Head[u]; i; i = Next[i]) {
    int v = To[i];
    if (v == Fa[u]) continue;

    Fa[v] = u; Dep[v] = Dep[u] + 1;
    dfs1(v);

    Siz[u] += Siz[v];
    if (Siz[v] > Siz[Wson[u]]) Wson[u] = v;
  }
}

void dfs2(int u, int chain) {
  cntv++;
  Id[u] = cntv; Dfn[cntv] = u;
  Top[u] = chain;
  End[chain] = max(End[chain], cntv);

  // 第二次树剖时直接更新 F, G 数组（这里直接将 G 放入矩阵更新）
  F[u][0] = 0, F[u][1] = A[u];
  Val[u].mat[0][0] = Val[u].mat[0][1] = 0;
  Val[u].mat[1][0] = A[u];
  if (Wson[u] != 0) {
    dfs2(Wson[u], chain);
    // 依照定义，重儿子不应计入 G 数组
    F[u][0] += max(F[Wson[u]][0], F[Wson[u]][1]);
    F[u][1] += F[Wson[u]][0];
  }

  for (int i = Head[u]; i; i = Next[i]) {
    int v = To[i];
    if (v == Fa[u] || v == Wson[u]) continue;
    dfs2(v, v);

    F[u][0] += max(F[v][0], F[v][1]);
    F[u][1] += F[v][0];
    Val[u].mat[0][0] += max(F[v][0], F[v][1]);
    Val[u].mat[0][1] = Val[u].mat[0][0];
    Val[u].mat[1][0] += F[v][0];
  }
}

void init() {
  readin();
  dfs1(1); dfs2(1, 1);
}

void update_path(int u, int w) {
  Val[u].mat[1][0] += w - A[u];
  A[u] = w;

  Matrix bef, aft;
  while (u != 0) {
    // 计算贡献时，应当用一个 bef 矩阵还原出少掉这个轻儿子的情况，再将 aft 加入更新
    bef = T.Query_Tree(Id[Top[u]], End[Top[u]], 1);
    T.Update_Tree(Id[u], 1);
    aft = T.Query_Tree(Id[Top[u]], End[Top[u]], 1);
    u = Fa[Top[u]];

    Val[u].mat[0][0] += max(aft.mat[0][0], aft.mat[1][0]) - max(bef.mat[0][0], bef.mat[1][0]);
    Val[u].mat[0][1] = Val[u].mat[0][0];
    Val[u].mat[1][0] += aft.mat[0][0] - bef.mat[0][0];
  }
}

void solve() {
  T.Build_Tree(1, N, 1);

  for (int i = 1; i <= M; ++i) {
    int u, w;
    scanf("%d %d", &u, &w);
    update_path(u, w);
    Matrix Ans = T.Query_Tree(Id[1], End[1], 1);
    printf("%d\n", max(Ans.mat[0][0], Ans.mat[1][0]));
  }
}

int main() {
  init();
  solve();
  return 0;
}
```

附：本文同时发布于本蒟蒻的[博客](https://www.cnblogs.com/tweetuzki/p/10274788.html)。

---

## 作者：shadowice1984 (赞：190)

在上古论文中发现了一种神奇的做法……

$O(nlogn)$把树剖吊起来打……

于是轻松拿到了本题的rk1(但是这份代码封装还是很多的，应该还有很多卡常空间)

_____________________

## 本题题解

### 什么是动态dp

所谓动态dp就是一种黑科技允许你对于一个dp问题进行修改操作

先给你一个正常的dp问题，比如没有上司的舞会

然后我们要不停的修改参数此时问题的难度就由黄牌骤增至黑牌了

然后传统的做法是使用树链剖分(链分治)

我们先对整颗树做一个树剖，然后一条重链一条重链的进行dp

先来看普通的dp方程，设$Dp_{i,0}$为这个点不在独立时的最大收益，$Dp_{i,1}$为在的时候的最大收益

## $Dp_{u,0}=\sum_{v \in u.son}max(Dp_{v,0},Dp_{v,1})$

## $Dp_{u,1}=\sum_{v \in u.son}Dp_{v,0}$

然后我们发现这个东西似乎可以变换一下顺序也没什么影响，所以我们一条重链一条重链的dp

换句话说我们采取一种dfs和bfs混合的方式遍历这颗树，每次到达一个重链的顶部的时候我们直接将这个重链全部塞到队列里，然后我们递归下去遍历和重链相连的所有重链，最后处理这个重链，当处理完这个重链之后我们发现我们已经处理完了这个重链顶所在的子树了

那么我们对于重链上的每一个点，先根据轻儿子的dp值(因为轻儿子一定是其他重链的顶部所以dp值必定已经计算好)，计算出一个$ldp_{i,0/1}$

## $ldp_{u,0}=\sum_{v \in u.lightson}max(Dp_{v,0},Dp_{v,1})$

## $ldp_{u,1}=\sum_{v \in u.lightson}Dp_{v,0}$

此时我们根据这个ldp值在重链上跑一个序列的dp

## $Dp_{u,0}=ldp_{u,0}+max(Dp_{u.heavyson,0},Dp_{u.heavyson,1})$

## $Dp_{u,1}=ldp_{u,1}+Dp_{u.heavyson,0}$

此时你可能会说，这有什么用……还不是$O(n)$的dp而且还多了一堆常数

但是这意味着我们成功的将树上的问题转化为了序列问题，所以我们现在可以使用线段树维护重链上的dp值，从而可以支持快速修改

具体来讲，当我们修改一个点的值的时候，我们在对应的重链的线段树上进行修改，此时会改变重链顶部的dp值，然后会改变重链顶的father的ldp值，然后又对应了线段树上的单点修改，此时又会改变另一个重链顶的dp值，

这样反复几次，我们就可以在$O(log^2n)$时间内完成单点修改

问题来了怎么线段树上维护dp值啊

很简单，利用immortalICO神仙给出的黑科技，我们将转移写成Floyd矩乘的形式

我们将平常的矩阵乘法换成这样的形式

## $C_{i,j}=\max_{k}(A_{i,k}+B_{k,j})$

可以证明这个重定义之后的矩乘仍然具有结合律

单位矩阵是中间一行0剩余的地方全部是$- \infty$

那么我们发现事实上重链上的转移可以写成这样的矩乘

$$\begin{bmatrix} dp_{i-1,0} \\ dp_{i-1,1} \end{bmatrix} × \begin{bmatrix} ldp_{i,0} & ldp_{i,0} \\ ldp_{i,1} & -\infty \end{bmatrix}$$

然后我们就可以在线段树上愉快的维护矩阵连乘积啦，通过维护矩阵连乘积我们就可以实现$O(8log^2n)$的修改操作了

~~愚蠢的$O(nlog^2n)$做法到此结束，我们开始讲解上古魔法~~
_______________

### 上古科技：“全局平衡二叉树"

可以去翻07年的论文”QTREE 解法的一些研究"，~~(“全局平衡二叉树"这个中二的名字是论文里说的)~~

众所周知把刚才的树剖换成lct就可以做到一个log了，但是我们发现lct实在是常数太!大!了！绝对是跑不过实现的优秀的一点的树剖的

但是我们对于lct的复杂度证明却很感兴趣，为啥同样是操作了logn个数据结构，把线段树换成常数更大的splay复杂度反而少了一个log呢？(刚才这句话严格来讲是病句，常数和复杂度没有任何关联)

具体证明需要用到势能分析，但是感性理解一下就是如果我们把lct上的虚边也看成splay的边的话，我们发现整棵lct变成了一棵大splay，只是有些点度数不是2了

但是这些点度不是2的点并未破坏splay的势能分析换句话说势能分析对整颗大splay仍然生效,所以你的$log$次splay在整个大splay上只是一次splay而已

复杂度自然是均摊$O(logn)$了

但是，我们发现这是颗静态树，使用splay实在是大(常)材(数)小(过)用(大)了

于是我们考虑将lct强行静态化，换句话说，建一个像splay一样的全局平衡的树

观察到线段树只是局部平衡的，在碰到专业卡链剖的数据--链式堆(根号n个长度为根号n的链连成完全二叉树的形状)的时候会导致算上虚边之后的整颗树左倾或者右倾

此时我们发现如果在建线段树的时候做点手脚，我们把线段树换成二叉查找树bst，并且这个bst不是严格平衡的话，我们可以做到更加优秀的复杂度，使得算上虚边之后的树树高达到$O(logn)$级别

我们还是在树上dfs，但是对于重链建bst的时候我们并不建一个完美的bst，而是将每一个节点附上一个权值，权值为它所有轻儿子的siz之和+1，然后我们每次找这个链的带权重心，把他作为这一级的父亲，然后递归两边进行建bst

当然我们发现最坏情况下我们可以建出一个严重左倾或者右倾的bst

但是，我们考虑算上虚边的整颗树我们会发现一个神奇的性质，无论是经过一条重的二叉树边还是虚边，所在子树的siz至少翻一倍，而这个性质在原来的线段树上是没有的

所以这个大bst的高度是$O(logn)$的

当然，这个bst既不能旋转也不能splay，所以维护区间信息会比较吃力，但是，我们为什么要维护区间信息呢？这是动态dp啊，我们只需要维护这整个重链的矩阵连乘积就行了……，所以维护整个重链的连乘积还是可以做到的

另外这个东西看起来听玄学其实比树剖还好写……

上代码~

```C
#include<cstdio>
#include<algorithm>
using namespace std;const int N=1e5+10;
int n;int m;int v[2*N];int x[2*N];int ct;int al[N];int siz[N];int h[N];int we[N];
inline void add(int u,int V){v[++ct]=V;x[ct]=al[u];al[u]=ct;}
inline int dfs1(int u)//这里的树剖只需要一趟dfs求重儿子 
{
    siz[u]=1;int mx=0;
    for(int i=al[u];i;i=x[i])
        if(siz[v[i]]==0){siz[u]+=dfs1(v[i]);if(mx<siz[v[i]])mx=siz[v[i]],h[u]=v[i];}
    return siz[u];
}
struct mar//矩阵类 
{
    int mp[2][2];
    mar(){mp[0][0]=mp[0][1]=mp[1][0]=mp[1][1]=-0x3f3f3f3f;}
    mar(int x){mp[0][0]=mp[1][1]=0;mp[1][0]=mp[0][1]=-0x3f3f3f3f;}
    friend mar operator *(mar a,mar b)
    {
        mar c;for(int i=0;i<2;++i)
            for(int k=0;k<2;++k)
                for(int j=0;j<2;++j)c.mp[i][j]=max(c.mp[i][j],a.mp[i][k]+b.mp[k][j]);
        return c;
    }
    inline int gmx(){return max(max(mp[0][0],mp[0][1]),max(mp[1][0],mp[1][1]));}
    inline int* operator [](const int& x){return mp[x];}
};
struct bst
{
    int s[N][2];int fa[N];int st[N];int tp;int lsiz[N];bool book[N];int root;
    mar mul[N];mar w[N];bst(){w[0]=mul[0]=mar(1);}
    inline void ud(const int& x){mul[x]=mul[s[x][0]]*w[x]*mul[s[x][1]];}
    inline void gtw(const int& x,const int& v)
    {w[x][1][0]+=mul[v].gmx();w[x][0][0]=w[x][1][0];w[x][0][1]+=max(mul[v][0][0],mul[v][1][0]);fa[v]=x;}
    inline void ih(){for(int i=1;i<=n;i++)w[i][0][1]=we[i],w[i][0][0]=w[i][1][0]=0;}
    inline bool isr(const int& p){return (s[fa[p]][1]!=p)&&(s[fa[p]][0]!=p);}
    inline int sbuild(const int& l,const int& r)//对序列建bst 
    {
        if(l>r)return 0;int tot=0;for(int i=l;i<=r;i++)tot+=lsiz[st[i]];
        for(int i=l,ns=lsiz[st[i]];i<=r;i++,ns+=lsiz[st[i]])
            if(2*ns>=tot)
            {
                int rs=sbuild(l,i-1);int ls=sbuild(i+1,r);s[st[i]][0]=ls;s[st[i]][1]=rs;
                fa[ls]=st[i];fa[rs]=st[i];ud(st[i]);return st[i];//找重心递归建树 
            }
    }
    inline int build(int p)//链分治，每次处理一条链 
    {
        for(int t=p;t;t=h[t])book[t]=true;
        for(int t=p;t;t=h[t])
            for(int i=al[t];i;i=x[i])if(!book[v[i]])gtw(t,build(v[i]));
        tp=0;for(int t=p;t;t=h[t])st[++tp]=t;
        for(int t=p;t;t=h[t])lsiz[t]=siz[t]-siz[h[t]];return sbuild(1,tp);
    }
    inline void modify(int p,int W)//修改，直接无脑修改上去就行了 
    {
    	w[p][0][1]+=W-we[p];we[p]=W;
        for(int t=p;t;t=fa[t])
        	if(isr(t)&&fa[t])//如果是轻边 
			{
				w[fa[t]][0][0]-=mul[t].gmx();w[fa[t]][1][0]=w[fa[t]][0][0];
				w[fa[t]][0][1]-=max(mul[t][0][0],mul[t][1][0]);ud(t);
				w[fa[t]][0][0]+=mul[t].gmx();w[fa[t]][1][0]=w[fa[t]][0][0];
				w[fa[t]][0][1]+=max(mul[t][0][0],mul[t][1][0]);
			}else ud(t);
    }
}bst;
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)scanf("%d",&we[i]);
	for(int i=1,u,v;i<n;i++){scanf("%d%d",&u,&v);add(u,v);add(v,u);}
	dfs1(1);bst.ih();bst.root=bst.build(1);
	for(int i=1,p,w;i<=m;i++)
	{scanf("%d%d",&p,&w);bst.modify(p,w);printf("%d\n",bst.mul[bst.root].gmx());}
	return 0;//拜拜程序~ 
}
```










---

## 作者：mrsrz (赞：8)

动态动态规划。

假如没有修改，则是一个简单的树形DP：

设$f_{i,0}$表示以$i$为根的子树，节点$i$不选的最大独立集。

$f_{i,1}$表示以$i$为根的子树，节点$i$选的最大独立集。

则$f_{i,0}=\sum_{s\in son_{i}}\max(f_{s,0},f_{s,1})$。

$f_{i,1}=\sum_{s\in son_{i}}f_{s,0}$。

~~然后它就随手给了你一个修改~~

我们需要一个东西来快速维护转移。

考虑用一个行向量来定义$i$节点的状态$\left[ \begin{matrix} f_{i,0} & f_{i,1}\end{matrix}\right]$。

然后，如果能有一个矩阵来进行快速转移状态，就可以用线段树一类的数据结构来维护了。

考虑新定义一种矩阵运算$A\oplus B=C$，其中$C_{i,j}=\max_{k}\{a_{i,k}+b_{k,j}\}$。

可以证明，这个运算也是满足结合律、不满足交换律的，所以直接当矩阵乘法用即可。

然后，对树进行树链剖分，重定义一下状态：

$f_{i,0}$表示以$i$为根的子树，节点$i$不选，且不考虑其重儿子的最大独立集。

$f_{i,1}$表示以$i$为根的子树，节点$i$选的最大独立集。

考虑当前状态加上重儿子$p$的状态会变成什么。

设$g$表示每个点的实际DP值（加上重儿子后），则：

$g_{i,0}=f_{i,0}+\max(g_{p,0},g_{p,1})$，$g_{i,1}=f_{i,1}+g_{p,0}$。

用我们刚刚定义的矩阵乘法来写的话，就是：

$$\left[\begin{matrix}  g_{i,0} & g_{i,1}  \end{matrix}\right]= \left[\begin{matrix} f_{i,0}& f_{i,1} \end{matrix}\right]\oplus\left[\begin{matrix}  g_{p,0}& g_{p,1} \\ g_{p,0} & -\infty   \end{matrix}\right]$$

还有如下性质：

$$\left[\begin{matrix}  g_{p,0}& g_{p,1} \\ g_{p,0} & g_{p,1}   \end{matrix}\right]\oplus\left[\begin{matrix}  f_{i,0}& f_{i,1} \\ f_{i,0} & -\infty   \end{matrix}\right] =\left[\begin{matrix}\max(g_{p,0}+f_{i,0},g_{p,1}+f_{i,0})&\max(g_{p,0}+f_{i,1},g_{p,1}-\infty)\\ \max(g_{p,0}+f_{i,0},g_{p,1} + f_{i,0}) & \max(g_{p,0}+f_{i,1},g_{p,1}-\infty)        \end{matrix}\right]=\left[\begin{matrix}  g_{i,0} & g_{i,1}\\g_{i,0} & g_{i,1}  \end{matrix}\right]$$

你会发现我们每次只需要左边那个矩阵的第一行，也就是说第二行是用来占位的，所以下面构造的时候，右下角元素赋值成\\(-\infty\\)也没问题。


而对于一条重链链尾的节点，其$f_i=g_i$。

然后我们发现，$g_p$的状态也是通过$f_p$的状态乘上一个转移矩阵得来的（链尾除外）。所以自然想到用线段树维护区间的矩阵乘法（刚刚定义的$\oplus$）。

对于每个节点$i$，首先把它的$f$处理出来（此时$i$的轻儿子已经处理完毕，又因为这个轻儿子一定是一条重链的链首，所以其DP值可以一遍线段树上查询得出），然后，构建转移矩阵：

$$\left[\begin{matrix}  f_{i,0}& f_{i,1} \\ f_{i,0} & -\infty   \end{matrix}\right]$$

扔进线段树里。

之后，每条重链的链首的DP值，就可以通过线段树区间查询该重链的乘积得到。

对于修改操作，首先把这个节点对于的矩阵的值修改。这样，这条重链的值就会被修改，则上面的重链的值也会相应修改。

沿着重链往上跳，然后每次修改链首元素的父节点的矩阵即可。

由于最多跳$\log$条重链，所以单次修改的时间复杂度$O(8\log^2 n)$。

查询的话，直接查根节点的这条重链即可。单次查询$O(8\log n)$。

总时间复杂度$O(8m\log^2n)$。

注意矩阵乘法**不满足交换律**，而我的做法是自下向上合并的，所以线段树维护的时候要用右边区间的矩阵乘上左边区间的矩阵。

## Code：
```cpp
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
#include<stack>
#define N 100005
#define inf 1000000000
struct istream{
	int c;
	template<typename T>
	inline istream&operator>>(T&d){
		int b=0;
		while(!isdigit(c=getchar()))b=c=='-';
		for(d=0;isdigit(c);c=getchar())
		d=(d<<3)+(d<<1)+(c^'0');
		if(b)d=-d;
		return*this;
	}
}cin;
int n,m,V[N],head[N],cnt=0,dep[N],top[N],fa[N],sz[N],son[N],dfn[N],idx=0,idfn[N],tail[N];
struct edge{
	int to,nxt;
}e[N<<1];
struct trans{
	int a[2][2],r,c;
	inline trans(){memset(a,0,sizeof a);}
	inline trans operator*(const trans&b)const{
		trans c;
		c.r=r,c.c=b.c;
		for(int i=0;i<r;++i)
		for(int j=0;j<c.c;++j)
		for(int k=0;k<b.r;++k){
			c.a[i][j]=std::max(c.a[i][j],a[i][k]+b.a[k][j]);
		}
		return c;
	}
}d[N<<2],s[N];
trans query(int l,int r,int o,const int&L,const int&R){
	if(L<=l&&r<=R)return d[o];
	const int mid=l+r>>1;
	if(L<=mid&&mid<R)return query(mid+1,r,o<<1|1,L,R)*query(l,mid,o<<1,L,R);else
	if(mid<R)return query(mid+1,r,o<<1|1,L,R);else
	if(L<=mid)return query(l,mid,o<<1,L,R);
}
void modify(int l,int r,int o,const int&pos,const trans&to){
	if(l==r)d[o]=to;else{
		const int mid=l+r>>1;
		if(pos<=mid)modify(l,mid,o<<1,pos,to);else
		modify(mid+1,r,o<<1|1,pos,to);
		d[o]=d[o<<1|1]*d[o<<1];
	}
}
void dfs(int now){
	sz[now]=1,son[now]=0;
	for(int i=head[now];i;i=e[i].nxt)
	if(!dep[e[i].to]){
		dep[e[i].to]=dep[now]+1;
		fa[e[i].to]=now;
		dfs(e[i].to);
		sz[now]+=sz[e[i].to];
		if(!son[now]||sz[son[now]]<sz[e[i].to])son[now]=e[i].to;
	}
}
void dfs2(int now){
	idfn[dfn[now]=++idx]=now;
	if(son[now])top[son[now]]=top[now],dfs2(son[now]);
	for(int i=head[now];i;i=e[i].nxt)
	if(e[i].to!=son[now]&&dep[e[i].to]>dep[now])dfs2(top[e[i].to]=e[i].to);
	tail[now]=(son[now])?tail[son[now]]:now;
}
void calc(int now){
	std::stack<int>q;
	for(int i=now;i;i=son[i])q.push(i);
	while(!q.empty()){
		int u=q.top();
		q.pop();
		int x=0,y=V[u];
		for(int i=head[u];i;i=e[i].nxt)
		if(dep[e[i].to]>dep[u]&&e[i].to!=son[u]){
			calc(e[i].to);
			trans q=s[e[i].to];
			x+=std::max(q.a[0][0],q.a[0][1]);
			y+=q.a[0][0];
		}
		trans q;
		q.r=q.c=2;
		q.a[0][0]=q.a[1][0]=x;
		q.a[0][1]=y;
		q.a[1][1]=-inf;
		modify(1,n,1,dfn[u],q);
	}
	s[now]=query(1,n,1,dfn[now],dfn[tail[now]]);
}
void modify(int u,int val){
	trans p=query(1,n,1,dfn[u],dfn[u]);
	p.a[0][1]+=val-V[u];
	modify(1,n,1,dfn[u],p);
	V[u]=val;
	for(int now=top[u];now!=1;now=top[now]){
		int f=fa[now];
		p=query(1,n,1,dfn[f],dfn[f]);
		trans q=query(1,n,1,dfn[now],dfn[tail[now]]);
		p.a[0][0]+=std::max(q.a[0][0],q.a[0][1])-std::max(s[now].a[0][0],s[now].a[0][1]);
		p.a[0][1]+=q.a[0][0]-s[now].a[0][0];
		p.a[1][0]=p.a[0][0];
		modify(1,n,1,dfn[f],p);
		s[now]=q;
		now=f;
	}
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;++i)cin>>V[i];
	for(int i=1;i<n;++i){
		int u,v;
		cin>>u>>v;
		e[++cnt]=(edge){v,head[u]};head[u]=cnt;
		e[++cnt]=(edge){u,head[v]};head[v]=cnt;
	}
	dfs(dep[1]=1);dfs2(top[1]=1);
	calc(1);
	while(m--){
		int x,y;
		cin>>x>>y;
		modify(x,y);
		trans p=query(1,n,1,1,dfn[tail[1]]);
		printf("%d\n",std::max(p.a[0][0],p.a[0][1]));
	}
	return 0;
}
```

---

## 作者：genshy (赞：5)

# 动态 dp

2020.9.5 update 更改了错误的转移矩阵

动态 $dp$ 是由猫坤大佬在 WC 2018 提出来的黑科技。

他主要解决得是带修改的 $dp$ 问题,主要思路是由矩阵乘法来维护 $dp$ 转移

我们先来看一道模板题 [动态dp](https://www.luogu.com.cn/problem/P3235)

这道题，我们先来看不带修改的情况，

转移和状态很容易就能列出来

设 $f[i][0/1]$ 表示 以 $i$ 为根的子树中，且选 (不选)  $i$ 这个点的最大权值和

转移方程可以写成：

$f[i][0] = \displaystyle \sum_{to \in son[i]} max (f[to][0],f[to][1])$

$f[i][1] = \displaystyle \sum_{to \in son[x]} f[to][0]\ + w[x]$

当我们修改一个点的权值，那么从他到根节点的路径上的点的 $dp$ 值都会受到影响。

所以，我们就可以只修改这一条链上的信息（用树链剖分来维护）。

动态 $dp$ 的思想就是将 重儿子和轻儿子的贡献分开来考虑。

设 $g[i][0] = \displaystyle \sum _{to \in 轻儿子} max(f[to][0],f[to][1])$, $g[i][1] = \displaystyle \sum_{to \in 轻儿子} f[to][0]\ +w[i] $.

解释一下 $g[i][0]$ 表示 选 或不选 $i$ 的轻儿子的最大贡献和， $g[i][1]$ 表示不选他轻儿子的价值和加上他本身的权值.

这两个可以在求 $f[x][0/1]$ 的时候顺便维护出来

那么，上面的方程就可以写成。

$f[i][0] = g[i][0] + max(f[son[i]][0],f[son][i][1])$

$f[i][1] = g[i][1] + f[son[i]][0]$ ($son[x]$  表示 $x$ 的重儿子)

定义广义矩阵乘法：

矩阵 $c$ 为 矩阵 A 和矩阵 B 的乘积 

那么，$c[i][j] = max( a[i][k] + b[k][j])$

这个其实就是把普通的矩阵乘法的乘号改为加号，加号改为取 $max$

这种矩阵乘法也满足普通矩阵乘法的性质，不相信的可以跑几组数据试试

代码实现长这样:

```cpp
node operator *(node x,node y)
{
    node ans;
    for(int i = 0; i <= n; i++)
        for(int j = 0; j <= n; j++)
            for(int k = 0; k <= n; k++)
                ans.a[i][j] = max(ans.a[i][j],x.a[i][k] + y.a[k][j]);
    return ans;
}
```

然后，我们就可以根据这个广义矩阵乘法构造一个矩阵，即，
$$
\left[
\begin{matrix}
f[to] [0] \\
f[to] [1] \\
\end{matrix}     
\right]
\tag{2} \times
\left[
\begin{matrix}
\cdots \\
\cdots \\
\end{matrix}
\right] =
\left[
\begin{matrix}
\ f[i][0] \\
\ f[i][1] \\
\end{matrix}
\right]
$$
其中 第二个矩阵是我们要 确定的转移矩阵。

第二个矩阵构造出来长这样：
$$
\left[
\begin{matrix}
f[to] [0] \\
f[to] [1] \\
\end{matrix}     
\right]
\tag{2} \times
\left[
\begin{matrix}
\ g[i][0] & g[i][1] \\
\ g[i][0] & -\infin \\
\end{matrix}
\right] =
\left[
\begin{matrix}
\ f[i][0] \\
\ f[i][1] \\
\end{matrix}
\right]
$$


但，我们发现一个问题，我们矩阵中没有这个 $f$ 值，这，我们一开始的矩阵就没法转移啊。

其实，对于每一个重链的末尾节点，他的转移矩阵就是他的 $f$ 值，

> 也就是说重链的末端节点保存了 f的准确值  -by treaker 

这样，我们就可以由这个矩阵来推出这一条重链上每个点的信息。

我们的暴力做法就是一直跳他的父亲就是一直跳他的父亲节点，再把矩阵乘起来。

但，这样的复杂度还是不能接受。我们可以把这个矩阵放到线段树上来维护。

线段树的每个叶子节点存这个点的转移矩阵，每个节点表示左右儿子矩阵的乘积，

这样就可以用 O(log n) 的时间得到我们想要的信息。

在结合树剖套线段树的做法，就能做到维护这棵树的信息。

注意：矩阵乘法要右乘，因为我们是从 dfn序大的地方跳到 dfn序小的地方，在线段树上对应的是从右往左。

我们上面的转移矩阵就需要重构一下，变成
$$
\left[
\begin{matrix}
\ g[i][0] & g[i][0] \\
\ g[i][1] &  - \infin \\
\end{matrix}     
\right]
\tag{2} \times
\left[
\begin{matrix}
f[son[x]][0]\\
f[son[x]][1]\\
\end{matrix}
\right] =
\left[
\begin{matrix}
\ f[i][0] \\
\ f[i][1] \\
\end{matrix}
\right]
$$
 修改操作，上文我们提到了 ‘当我们修改一个点的权值，那么从他到根节点的路径上的点的 $dp$ 值都会受到影响’。

我们修改的就是从这个点到根节点的路径的矩阵，我们把这条链琛出来，发现他是重链和轻边交替在一起的。

我们仔细观察一下我们构造的矩阵，发现里面维护的是轻儿子的信息，不会涉及到重儿子。  

对于重链，我们不用修改，但对于重链链顶 $top[x] $和轻边 $fa[top[x]] $交替的地方，我们需要单点修改。

因为此时链顶 $top[x]$ 属于 $fa[top[x]] $轻儿子，他的修改会对他父亲的转移矩阵造成影响。

我们关键要算出他改变之后对他父亲转移矩阵的影响。

他的 $f$ 值我们可以由下面的推出来，然后可以根据 $g$ 数组的定义算出他改变之后对他父亲的影响。

就这样在更新，每次跳重链，直到跳到根节点，我们的修改操作就大工告成了。

注意一下，我们不能修改之后在统计他的 轻儿子的值，那样可能不对，我们就只能通过增量法来修改。

记录一下原来状态的矩阵，在记录修改之后的矩阵，两者之差就是对他父亲转移矩阵的贡献。

每次修改操作的时间复杂度为 O($log^2 n$)

具体代码长这样

```cpp
void modify(int x,int val)
{
    base[dfn[x]].a[1][0] += val - w[x];//增量法统计他修改的贡献
    w[x] = val;
    while(x)
    {
        node Old = get_node(top[x]);//记录一下链顶修改之前的矩阵
        chenge(1,1,n,dfn[x]);//修改当前这个节点的转移矩阵
        node New = get_node(top[x]);//得到链顶修改之后的转移矩阵
        int fx = dfn[fa[top[x]]];
        base[fx].a[0][0] += max(New.a[0][0],New.a[1][0]) - max(Old.a[0][0],Old.a[1][0]);//算他修改对他父亲转移矩阵的影响
        base[fx].a[0][1] += max(New.a[0][0],New.a[1][0]) - max(Old.a[0][0],Old.a[1][0]);
        base[fx].a[1][0] += New.a[0][0] - Old.a[0][0];
        x = fa[top[x]];//跳链修改
    }
}
```

总代码：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int inf = 233333333;
const int N = 1e5+10;
int n,m,tot,x,y,num,val,u,v;
int head[N],top[N],dep[N],siz[N],fa[N],son[N],ord[N],end[N],f[N][2],g[N][2],dfn[N],w[N];
struct bian
{
    int to,net;
}e[N<<1];
struct node
{
    int a[2][2];
    node() {memset(a,-127/3,sizeof(a));}
}tr[N<<2],base[N];
inline int read()
{
    int s = 0,w = 1; char ch = getchar();
    while(ch < '0' || ch > '9'){if(ch == '-') w = -1; ch = getchar();}
    while(ch >= '0' && ch <= '9'){s =s * 10+ch - '0'; ch = getchar();}
    return s * w;
}
node operator *(node x,node y)//广义矩阵乘法
{
    node ans;
    for(int i = 0; i <= 1; i++)
    {
        for(int j = 0; j <= 1; j++)
        {
            for(int k = 0; k <= 1; k++)
            {
                ans.a[i][j] = max(ans.a[i][j],x.a[i][k] + y.a[k][j]);
            }
        }
    }
    return ans;
}
void add(int x,int y)
{
    e[++tot].to = y;
    e[tot].net = head[x];
    head[x] = tot;
}
void get_tree(int x)//树剖预处理
{
    dep[x] = dep[fa[x]] + 1; siz[x] = 1;
    for(int i = head[x]; i; i = e[i].net)
    {
        int to = e[i].to;
        if(to == fa[x]) continue;
        fa[to] = x;
        get_tree(to);
        siz[x] += siz[to];
        if(siz[son[x]] < siz[to] || son[x] == -1) son[x] = to;
    }
}
void dfs(int x,int topp)
{
    top[x] = topp; dfn[x] = ++num; ord[num] = x;//END 记录这条重链的链尾，ord记录当前 当前这个节点的树上编号
    if(son[x] == -1)
    {
        end[topp] = num;
        return;
    }
    dfs(son[x],topp);
    for(int i = head[x]; i; i = e[i].net)
    {
        int to = e[i].to;
        if(to == fa[x] || to == son[x]) continue;
        dfs(to,to);
    }
}
void dp(int x,int fa)//预处理为没修改之前的 f 值与 g 值
{
    g[x][1] = f[x][1] = w[x];
    for(int i = head[x]; i; i = e[i].net)
    {
        int to = e[i].to;
        if(to == fa) continue;
        dp(to,x);
        f[x][0] += max(f[to][0], f[to][1]);
        f[x][1] += f[to][0];
        if(to != son[x])
        {
            g[x][0] += max(f[to][0], f[to][1]);
            g[x][1] += f[to][0];
        }
    }
}
void up(int o)
{
    tr[o] = tr[o<<1] * tr[o<<1|1];
}
void build(int o,int L,int R)//线段树建树
{
    if(L == R)
    {
    	int tmp = ord[L];
        tr[o].a[0][0] = tr[o].a[0][1] = g[tmp][0];//构造转移矩阵
        tr[o].a[1][0] = g[tmp][1]; 
        base[L] = tr[o];
        return;
    }
    int mid = (L + R)>>1;
    build(o<<1,L,mid);
    build(o<<1|1,mid+1,R);
    up(o);
}
void chenge(int o,int l,int r,int x)//单点修改
{
    if(l == r)
    {
        tr[o] = base[l];
        return;
    }
    int mid = (l + r)>>1;
    if(x <= mid) chenge(o<<1,l,mid,x);
    if(x > mid) chenge(o<<1|1,mid+1,r,x);
    up(o);
}
node query(int o,int l,int r,int L,int R)//区间查询
{
    if(L <= l && R >= r) return tr[o];
    int mid = (l + r)>>1;
    if(R <= mid) return query(o<<1,l,mid,L,R);
    if(L > mid) return query(o<<1|1,mid+1,r,L,R);
    return query(o<<1,l,mid,L,R) * query(o<<1|1,mid+1,r,L,R);
}
node get_node(int x)//得到链顶的 f 值
{
    return query(1,1,n,dfn[x],end[top[x]]);
}
void modify(int x,int val)
{
    base[dfn[x]].a[1][0] += val - w[x];//增量法统计他修改的贡献
    w[x] = val;
    while(x)
    {
        node Old = get_node(top[x]);//记录一下链顶修改之前的矩阵
        chenge(1,1,n,dfn[x]);//修改当前这个节点的转移矩阵
        node New = get_node(top[x]);//得到链顶修改之后的转移矩阵
        int fx = dfn[fa[top[x]]];
        base[fx].a[0][0] += max(New.a[0][0],New.a[1][0]) - max(Old.a[0][0],Old.a[1][0]);//算他修改对他父亲转移矩阵的影响
        base[fx].a[0][1] += max(New.a[0][0],New.a[1][0]) - max(Old.a[0][0],Old.a[1][0]);
        base[fx].a[1][0] += New.a[0][0] - Old.a[0][0];
        x = fa[top[x]];//跳链修改
    }
}
int main()
{
    n = read(); m = read();
    for(int i = 1; i <= n; i++)
    {
        w[i] = read();
        son[i] = -1;
    }
    for(int i = 1; i <= n-1; i++)
    {
    	u = read(); v = read();
    	add(u,v); add(v,u);
    }
    get_tree(1); dfs(1,1); dp(1,0); build(1,1,n);//预处理
    for(int i = 1; i <= m; i++)
    {
        x = read(); val = read();
        modify(x,val);//修改操作
        node ans = get_node(1);//得到新答案
        printf("%d\n",max(ans.a[0][0],ans.a[1][0]));
    }
    return 0;
}
```





---

## 作者：Spasmodic (赞：3)

看到这种 $O(n\log^2n)$ 还常数大的可以暴力 dp 过掉。

首先设 $dp(i,j)$ 表示考虑第 $i$ 个节点的子树，且要求这个节点状态为 $j$ 时的答案。

那么状态转移方程为：
$$dp(i,0)=\sum_{u\in i.son}\max(dp(u,0),dp(u,1))$$
$$dp(i,1)=v_i+\sum_{u\in i.son}dp(u,0)$$

当然了，我们肯定不能每次更新重新 dp，我们可以考虑优化。

可以发现修改$u$节点的时候只会改变 $1-u$ 这一条链的 dp 数组。

因此我们可以考虑自底向上修改这一条链上的 dp 数组，每次暴力重算即可，单次修改复杂度期望是 $O(h_ud)$，$h_u$ 是 $u$ 的高度，$d$ 是平均度数。

注意到每条边会对度数总和贡献 $1$，因此 $d=\frac{n-1}{n}=O(1)$。

代码：
```cpp
#include<bits/stdc++.h>
#define N 100005
using namespace std;
int n,m,p[N],tot,hd[N],f[N],dp[N][2];
struct edge{int t,nxt;}es[N<<1];
void add(int u,int v){es[++tot]=(edge){v,hd[u]},hd[u]=tot;}
void dfs(int x,int fa){
	dp[x][1]=p[x],dp[x][0]=0,f[x]=fa;
	for(int i=hd[x];i;i=es[i].nxt){
		if(es[i].t==fa)continue;
		dfs(es[i].t,x);
		dp[x][0]+=max(dp[es[i].t][1],dp[es[i].t][0]);
		dp[x][1]+=dp[es[i].t][0];
	}
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%d",&p[i]);
    for(int i=1,u,v;i<n;i++)scanf("%d%d",&u,&v),add(u,v),add(v,u),f[v]=u;
    dfs(1,0);
    for(int i=1,x,y;i<=m;i++){
    	scanf("%d%d",&x,&y);
    	for(p[x]=y;x;x=f[x]){
    		dp[x][1]=p[x],dp[x][0]=0;
    		for(int j=hd[x];j;j=es[j].nxt){
    			if(es[j].t==f[x])continue;
    			dp[x][0]+=max(dp[es[j].t][1],dp[es[j].t][0]);
				dp[x][1]+=dp[es[j].t][0];
			}
		}
		printf("%d\n",max(dp[1][0],dp[1][1]));
	}
	return 0;
}
```
由于这道题的数据是随机生成的，因此树的期望高度为 $O(\log n)$，则总复杂度期望为 $O(n\log n)$，不需要卡常就可以过。

当然，这种暴力遇到[这种题目](https://www.luogu.com.cn/problem/P4751)，那肯定就死了，要用其他方法。

~~然而我不会shadowice1984的上古科技，所以这篇文章到这里就结束了。~~

---

## 作者：cheng2010 (赞：2)

翻了一下题解区，发现几乎没有 LCT 的题解，有的也十分简略，那就让我这个蒟蒻讲一个稍微详细一点的吧。

先速通一下式子，定义 $f_{x,1/0}$ 为是否选 $x$ 的最大值，$g_{x,0}$ 为每个虚儿子中可选可不选的和最大值，$g_{x,1}$ 为不选虚儿子，加上选自己的最大值，则有：

$$
\left[ \begin{array}{cc} f_{v,0} & f_{v,1} \end{array} \right]  \left[ \begin{array}{cc} g_{x,0} & g_{x,0} \\ g_{x,1} & -\infty  \\ \end{array} \right]=\left[ \begin{array}{cc} f_{x,0} & f_{x,1} \end{array} \right]
$$

其中 $v$ 为 $x$ 的实儿子，因为叶子结点为 $\left[ \begin{array}{cc} 0 & 0 \end{array} \right]$ 于是答案就是：

$$
\left[ \begin{array}{cc} g_{x,0} & g_{x,0} \\ g_{x,1} & -\infty  \\ \end{array} \right]^l
$$

$l$ 为链长。

树剖 $\log ^2$ 不优秀，全局平衡二叉树不会，考虑 LCT，但这里的 LCT 不太一样。

首先，这里的 LCT 是“静态的”，也就是说没有 link、cut、make_root 之类的操作，因为有的话父子关系变来变去的很难维护，所以，初始时设每个儿子都是虚的，跑一遍 dp，再来解决其他问题。

以下约定：$tree_x.val$ 为 $x$ 的矩阵，$tree_x.mul$ 为此时以 $x$ 为根的子树中还原的链（也就是先序遍历，LCT 的性质）的矩阵的积。

- #### pushup

按序合并即可。

```cpp
inline void pushup(int p)
{
    tree[p].mul=
    (ls(p)?tree[ls(p)].mul:one)//注意判断儿子是否为空，one 为单位矩阵，对角线为负无穷，其余为 0。
    *tree[p].val*
    (rs(p)?tree[rs(p)].mul:one);
}
```

- ### rotate

无影响，正常打。

```cpp
inline void rotate(int x)
{
    int y=fa(x),z=fa(y);
    bool pd=get(x);
    if(not_root(y)) tree[z].son[get(y)]=x;
    tree[y].son[pd]=tree[x].son[pd^1];
    if(tree[x].son[pd^1]) fa(tree[x].son[pd^1])=y;
    fa(y)=x;
    tree[x].son[pd^1]=y;
    fa(x)=z;
    pushup(y);
}
```

- ### splay

我们注意到，由于这棵 LCT 是“静态的”，所以没有 make_root 操作，也就是说，没有懒标记！我们不用下放标记了！可节约很多常数。

```cpp
inline void splay(int x)
{
  while(not_root(x))
  {
    int y=fa(x);
    if(not_root(y)) rotate(get(x)==get(y)?y:x);
    rotate(x);
  }
  pushup(x);
}
```

- ### access

在这里，我们要更新实、虚儿子，要重点注意。

首先，原本的右儿子虚了，加入的点（记作 $y$）实了，那么我们就要加上右儿子的 dp 值，减去 $y$ 的 dp 值，那么该怎么办？其实很简单，因为右儿子一定是它所在子树的根，$y$ 也是它所在联通块的根，所以它们的 dp 值就在它们身上，直接做即可。

```cpp
inline void access(int x)
{
    for(int y=0;x;x=fa(y=x))
    {
        splay(x);
        matix res=tree[rs(x)].mul;
        int r1=res.a[0][0];
        int r2=res.a[1][0];
        int y0=tree[y].mul.a[0][0];
        int y1=tree[y].mul.a[1][0];
        //以上代表着 dp 值，不清楚的可以回看一下前面。
        int _0=max(r1,r2)-max(y0,y1);
        //_0 用来更新 g0
        tree[x].val.a[0][0]+=_0;
        tree[x].val.a[0][1]+=_0;
        tree[x].val.a[1][0]+=r1-y0;
        rs(x)=y;
        pushup(x);//记得上传
    }
}
```

- ### update

这个也要注意，更新 $x$ 的权值时不可以这样，否则就炸了：

```cpp
splay(x);
update x
pushup(x)
```

为什么？我们来看，直接把 $x$ 转到这棵 splay 的根，那它还有祖先啊，它更新了但它祖先怎么办？所以我们加一个 access 让它没有祖先，无所畏惧。

```cpp
inline void update(int x,int y)
{
    access(x);
    splay(x);
    tree[x].val.a[1][0]+=y-a[x];//更新 g1 的值
    a[x]=y;
    pushup(x);
}
```

- ### query

我们 update 后，$x$ 成了它这棵 splay 的根，注意到这棵 splay 实质上是一个从原树的根到某个叶子的链，所以 $x$ 直接就是答案了。

现在，所有操作都讲完了若有问题，欢迎指正，现给出完整代码：（注：这个代码是加强版的代码，稍微卡了一下常）

```cpp
#include<bits/stdc++.h> 
#define ls(x) tree[x].son[0]
#define rs(x) tree[x].son[1]
#define fa(x) tree[x].fa
using namespace std;
const int N=1e6+7;
struct FastIO
{
	inline char gc()
	{
	    static char buf[1000001],*p1=buf,*p2=buf;
	    return p1==p2&&(p2=(p1=buf)+fread(buf,1,1000001,stdin),p1==p2)?EOF:*p1++;
	}
	template<typename T> inline void in(T &x)
	{
		x=0;
		int f=1;
		char c=gc();
		while(c<'0'||c>'9')
		{
			if(c=='-') f=-f;
			c=gc();
		}
		while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=gc();
		x*=f;
	}
	template<typename T> inline void out(T x)
	{
		
		if(x<0){x=-x;putchar('-');}
		if(x>9)out(x/10);
		putchar(x%10+'0');
	}
	template<typename T,typename...Args> inline void in(T&x,Args&...Arg){in(x),in(Arg...);}
	template<typename T,typename...Args> inline void out(T x,Args...Arg){out(x),putchar('\n'),out(Arg...);}
}io;
int a[N];
struct matix
{
	int a[2][2];
	matix(){memset(a,0,sizeof(a));}
};
inline matix operator * (matix A,matix B)
{
	matix res;
	res.a[0][0]=max(A.a[0][0]+B.a[0][0],A.a[0][1]+B.a[1][0]);
	res.a[1][0]=max(A.a[1][0]+B.a[0][0],A.a[1][1]+B.a[1][0]);
	res.a[0][1]=max(A.a[0][0]+B.a[0][1],A.a[0][1]+B.a[1][1]);
	res.a[1][1]=max(A.a[1][0]+B.a[0][1],A.a[1][1]+B.a[1][1]);
	return res;
}
matix one;
struct Tree
{
	int fa,son[2];
	matix val,mul;
}tree[N];
struct link_cut_tree
{
	inline void pushup(int p){tree[p].mul=(ls(p)?tree[ls(p)].mul:one)*tree[p].val*(rs(p)?tree[rs(p)].mul:one);}
	inline bool not_root(int p){return ls(fa(p))==p||rs(fa(p))==p;}
	inline bool get(int p){return rs(fa(p))==p;}
	inline void rotate(int x)
	{
		int y=fa(x),z=fa(y);
		bool pd=get(x);
		if(not_root(y)) tree[z].son[get(y)]=x;
		tree[y].son[pd]=tree[x].son[pd^1];
		if(tree[x].son[pd^1]) fa(tree[x].son[pd^1])=y;
		fa(y)=x;
		tree[x].son[pd^1]=y;
		fa(x)=z;
		pushup(y);
	}
	inline void splay(int x)
	{
		while(not_root(x))
		{
			int y=fa(x);
			if(not_root(y)) rotate(get(x)==get(y)?y:x);
			rotate(x);
		}
		pushup(x);
	}
	inline void access(int x)
	{
		for(int y=0;x;x=fa(y=x))
		{
			splay(x);
			matix res=tree[rs(x)].mul;
			int r1=res.a[0][0],r2=res.a[1][0],y0=tree[y].mul.a[0][0],y1=tree[y].mul.a[1][0],_0=max(r1,r2)-max(y0,y1);
			tree[x].val.a[0][0]+=_0;
			tree[x].val.a[0][1]+=_0;
			tree[x].val.a[1][0]+=r1-y0;
			rs(x)=y;
			pushup(x);
		}
	}
	inline void update(int x,int y)
	{
		access(x);
		splay(x);
		tree[x].val.a[1][0]+=y-a[x];
		a[x]=y;
		pushup(x);
	}
}LCT;
int n,m;
int leaf,in[N];
int lstans;
vector<int> edge[N];
inline void dfs(int x,int fa)
{
	int w1=a[x],w2=0;
	for(int v:edge[x])
	{
		if(v==fa) continue;
		dfs(v,x);
		tree[v].fa=x;
		w1+=tree[v].val.a[0][0];
		w2+=max(tree[v].val.a[0][0],tree[v].val.a[1][0]);
	}
	tree[x].val.a[0][0]=tree[x].val.a[0][1]=w2;
	tree[x].val.a[1][0]=w1;
	tree[x].val.a[1][1]=-1145;
	tree[x].mul=tree[x].val;
}
int main()
{
	one.a[0][1]=one.a[1][0]=-1145;
	io.in(n,m);
	for(int i=1;i<=n;i++)
		io.in(a[i]);
	for(int i=1;i<n;i++)
	{
		int x,y;
		io.in(x,y);
		edge[x].push_back(y);
		edge[y].push_back(x);
	}
	dfs(1,0);
	while(m--)
	{
		int x,y;
		io.in(x,y);
		x^=lstans;
		LCT.update(x,y);
		io.out(lstans=max(tree[x].mul.a[0][0],tree[x].mul.a[1][0]));
		putchar('\n');
	}
}
```

其实可以看到，LCT 虽然常数大，但在大的数据下单 $\log$ 的优势就很明显了，而且十分好码，LCT 万岁！

---

## 作者：Loser_Syx (赞：2)

动态 dp 主要运用于树上或者区间上的 dp 问题，核心是将本来的转移过程写成矩阵转移的形式，构造矩阵 $g_i$ 以及广义矩阵乘法使得 $f_j \times g_i = f_i$。

然后呢，我们对于这个 $g_i$，通过发掘原题的性质，让它在原做法中乘上若干个 $g$ 变成只乘一个 $g$。换句话说呢就是需要维护一段连续的区间，在这个区间里提前进行转移（可以用线段树维护）。一般树上的做法可以是树链剖分变成 dfs 序再用线段树维护转移矩阵。做法因题目而异。

-----

下面看例题。

不妨先考虑没有修改怎么做，套路的考虑树形 dp，设 $f_{i,0/1}$ 表示 $i$ 节点选不选，那么就有 $f_{i,0}=\sum_{j\in son_i} \max(f_{j,0},f_{j,1})$ 表示儿子选不选随意， $f_{i,1}=a_i+\sum_{j\in son_i} f_{j,0}$ 表示儿子一定不能选。

这个时候我们再引入修改操作，由于每个点的 $f$ 值只与他的子节点的值有关，所以我们发现它只会修改一条**链**上的 $f$ 值。如果考虑维护链上信息，那么就是需要引入树链剖分了。

但是发现信息不是特别好维护，可以定义一个辅助修改数组 $g_{i,0}=\sum_{j\neq h_i} \max(f_{j,0},f_{j,1})$，$g_{i,1}=a_i \sum_{j\neq h_i} f_{j,0}$，其中 $h_i$ 表示 $i$ 的重儿子。

那么转移就变成了 $f_{i,0}=\max(f_{h_i,0},f_{h_i,1})+g_{i,0}$，$f_{i,1}=f_{h_i,0}+g_{i,1}$。

发现很符合矩阵的样子是吧，那么可以定义广义矩阵乘法 $c_{i,j}=\max_k a_{i,k}+b_{k,j}$，那么就变成了

$$\begin{bmatrix}
f_{h_i,0} & f_{h_i,1}
\end{bmatrix} \times 
\begin{bmatrix}
g_{i,0} & g_{i,1} \\
g_{i,0} & -\infty
\end{bmatrix} = \begin{bmatrix}
f_{i,0} & f_{i,1}
\end{bmatrix} $$

那么用线段树维护这个转移矩阵，再用树剖维护链上的，统计答案就是简单的了。修改时候只需要对每个链上可能会修改的转移矩阵修改一下差值即可。

注意转移过程是由深入浅的，所以线段树得倒着乘。

```cpp
const int N = 1e5 + 19, mod = 998244353, inf = -1e18;
int n, m, f[N][2], g[N][2], fa[N], dfn[N], cnt, top[N], siz[N], son[N], dep[N], a[N], deepest[N], rnk[N];
vector<int> G[N];
struct Matrix {
	int a[2][2];
	Matrix() { for (int i:{0,1}) for (int j:{0,1}) a[i][j]=0; }
	Matrix operator * (const Matrix e) {
		Matrix ans;
		for (int i:{0,1}) for (int j:{0,1}) for (int k:{0,1}) smax(ans.a[i][j],a[i][k]+e.a[k][j]);
		return ans;
	}
	void out() {
		puts("Matrix:");
		for (int i:{0,1}) for (int j:{0,1}) write(a[i][j]," \n"[j==1]);
	}
} p[N];
void dfs(int u, int f) {
	dep[u]=dep[f]+1; siz[u]=1; fa[u]=f;
	for (int v:G[u]) {
		if (v==f) continue;
		dfs(v,u); siz[u]+=siz[v]; if (siz[v]>siz[son[u]]) son[u]=v;
	}
}
void dfs2(int u,int tp) {
	dfn[u]=++cnt; top[u]=tp; deepest[u]=u; rnk[cnt]=u;
	if (son[u]) {
		dfs2(son[u],tp); deepest[u]=deepest[son[u]];
	}
	g[u][1]+=a[u];
	for (int v:G[u]) {
		if (v!=fa[u]&&v!=son[u]) {
			dfs2(v,v);
			g[u][0]+=max(f[v][0],f[v][1]);
			g[u][1]+=max(f[v][0],inf);
		}
	}
	f[u][0]=max(f[son[u]][0],f[son[u]][1])+g[u][0];
	f[u][1]=f[son[u]][0]+g[u][1];
//	printf("Id=%4lld    G: %lld %lld\n", u,g[u][0],g[u][1]);
	p[u].a[0][0]=p[u].a[1][0]=g[u][0]; p[u].a[0][1]=g[u][1]; p[u].a[1][1]=inf;
}
void add(int &a, int b) {
	if ((a += b) >= mod) a -= mod;
}
struct SegTree {
	Matrix t[N << 2];
	#define ls (k << 1)
	#define rs (k << 1 | 1)
	#define mid ((l + r) >> 1)
	void build(int k, int l, int r) {
		if (l == r) return t[k] = p[rnk[l]], void();
		build(ls, l, mid); build(rs, mid+1, r);
		t[k] = t[rs] * t[ls];
	}
	void update(int k, int l, int r, int s) {
		if (l == r) return t[k] = p[rnk[l]], void();
		if (s <= mid) update(ls, l, mid, s);
		else update(rs, mid+1, r, s);
		t[k] = t[rs] * t[ls];
	}
	Matrix query(int k, int l, int r, int L, int R) {
		if (L <= l && r <= R) return t[k];
		if (L > mid) return query(rs, mid+1, r, L, R);
		if (R <= mid) return query(ls, l, mid, L, R);
		return query(rs, mid+1, r, L, R) * query(ls, l, mid, L, R);
	}
} seg; 
void modify(int u, int w) {
	g[u][1]+=w-a[u]; a[u]=w;
	while (u) {
		Matrix A=seg.query(1,1,n,dfn[top[u]],dfn[deepest[top[u]]]);
		p[u].a[0][0]=p[u].a[1][0]=g[u][0]; p[u].a[0][1]=g[u][1]; p[u].a[1][1]=inf;
		seg.update(1,1,n,dfn[u]);
		Matrix B=seg.query(1,1,n,dfn[top[u]],dfn[deepest[top[u]]]);
		int v=top[u];
		g[fa[v]][0]-=max(A.a[0][0],A.a[0][1]);
		g[fa[v]][0]+=max(B.a[0][0],B.a[0][1]);
		g[fa[v]][1]-=A.a[0][0];
		g[fa[v]][1]+=B.a[0][0];
		u = fa[top[u]];
	}
}
signed main() {
	read(n, m);
	for (int i=1;i<=n;++i) read(a[i]);
	for (int i=1,u,v;i<n;++i) {
		read(u,v); G[u].eb(v); G[v].eb(u);
	} dfs(1,0); dfs2(1,1); seg.build(1,1,n);
//	(p[2]*p[5]).out();
	for (int i=1;i<=m;++i) {
		int x,y; read(x,y);
		modify(x,y);
		Matrix ret=seg.query(1,1,n,dfn[1],dfn[deepest[1]]);
		write(max(ret.a[0][1],ret.a[0][0]));
	}
	return 0;
}
```

---

## 作者：Fiendish (赞：1)

前置芝士：树链剖分 矩阵乘法 线段树

如果去掉修改操作这道题是简单的，所以我们先考虑静态问题，再尝试带上修改。

为方便描述，我们约定 $w_i$ 表示 $i$ 号节点的权值，$\text{subtree}_i$ 表示以 $i$ 为根的子树，$\text{Fa}_i$ 表示 $i$ 号节点的父亲节点，$\text{son}_i$ 表示对树进行重链剖分后 $i$ 号节点的重儿子，$\text{Top}_i$ 表示 $i$号节点所在的重链的顶端，$\text{End}_i$ 表示 $i$ 号节点所在的重链的底端。

容易看出，静态的问题可以用树形 dp 解决。设 $f_{i,0}$ 和 $f_{i,1}$ 分别表示不选/选 $i$ 号点时 $\text{subtree}_i$ 的最大权独立集的权值，那么容易发现：

$$\left\{\begin{matrix}
 f_{i,0}=\displaystyle\sum_{\text{Fa}_j=i}\max(f_{j,0},f_{j,1})\\
f_{i,1}=\displaystyle\sum_{\text{Fa}_j=i}f_{j,0}+w_i
\end{matrix}\right.$$

现在考虑修改操作如何完成。

我们可以将 dp 式子改写一下：

$$\left\{\begin{matrix}
 f_{i,0}=\displaystyle \max(f_{\text{son}_i,0},f_{\text{son}_i,1})+\sum_{\text{Fa}_j=i,j\neq\text{son}_i}\max(f_{j,0},f_{j,1})\\
f_{i,1}=\displaystyle f_{\text{son}_i,0}+\sum_{\text{Fa}_j=i,j\neq\text{son}_i}f_{j,0}+w_i
\end{matrix}\right.$$

令

$$\left\{\begin{matrix}
a_{i,0}=\displaystyle\sum_{\text{Fa}_j=i,j\neq\text{son}_i}f_{j,0}+w_i\\
a_{i,1}=\displaystyle\sum_{\text{Fa}_j=i,j\neq\text{son}_i}\max(f_{j,0},f_{j,1})
\end{matrix}\right.$$

于是

$$\left\{\begin{matrix}
 f_{i,0}=\displaystyle \max(f_{\text{son}_i,0},f_{\text{son}_i,1})+a_{i,1}\\
f_{i,1}=\displaystyle f_{\text{son}_i,0}+a_{i,0}
\end{matrix}\right.$$

考虑将这个式子改写成矩阵乘法的形式。首先，我们需要了解 max + 矩阵乘法。

假设这里有一个 $x\times y$ 的矩阵 $A$ 和一个 $y\times z$ 的矩阵 $B$，设 $C=A\oplus B$，则

$$c_{i,j}=\max_{k=1}^n \{a_{i,k}+b_{k,j}\}(i\in\left[1,x\right],j\in\left[1,z\right])$$

其中 $\oplus$ 表示 max + 矩阵乘法。max + 矩阵乘法满足结合律，即 $(A\oplus B)\oplus C=A\oplus(B\oplus C)$。然而它**并不满足交换律**。

接下来我们可以改写式子了：

$$\begin{bmatrix}
 f_{i,0}\\
f_{i,1}
\end{bmatrix}=
\begin{bmatrix}
 a_{i,1} & a_{i,1}\\
 a_{i,0} & -\infty
\end{bmatrix}\oplus\begin{bmatrix}
 f_{\text{son}_i,0}\\
f_{\text{son}_i,1}
\end{bmatrix}$$

证明是容易的，将上述式子按 max + 矩阵乘法的定义展开即可。

令

$$G_i=\begin{bmatrix}
 a_{i,1} & a_{i,1}\\
 a_{i,0} & -\infty
\end{bmatrix}$$

$$F_i=\begin{bmatrix}
 f_{i,0}\\
f_{i,1}
\end{bmatrix}$$

则

$$\begin{aligned}F_i&=G_i\oplus F_{\text{son}_i}\\&=G_i\oplus G_{son_i}\oplus F_{\text{son}_{\text{son}_i}}\\&=G_i\oplus G_{\text{son}_i}\oplus G_{\text{son}_{\text{son}_i}}\oplus\dots\oplus G_{\text{End}_i}\oplus  F_{\text{son}_{\text{End}_i}}\end{aligned}$$

由于 $\text{End}_i$ 没有儿子，所以

$$F_i=G_i\oplus G_{\text{son}_i}\oplus G_{\text{son}_{\text{son}_i}}\oplus\dots\oplus G_{\text{End}_i}\oplus \begin{bmatrix}
0\\
0
\end{bmatrix}$$

所以如果我们能快速求出 $G_i\oplus G_{\text{son}_i}\oplus G_{\text{son}_{\text{son}_i}}\oplus\dots\oplus G_{\text{End}_i}$，那么我们就可以快速求出任意一个点的 $F_i$。

由于一条重链中所有点的 dfn 序连续，所以可以用线段树维护 $G_i$ 的积。修改也是简单的。假设需要修改 $x$ 点的 $w_x$，则我们需要线段树上修改 $G_x$。同时，$\text{Top}_x$ 也是 $\text{Fa}_{\text{Top}_x}$ 的轻儿子（除非 $\text{Top}_x$ 是根节点），所以 $f_{\text{Top}_x,0}$ 和 $f_{\text{Top}_x,1}$ 发生改变之后 $G_{\text{Fa}_{\text{Top}_x}}$ 也会改变。因此修改时我们需要沿重链不断向上跳并不断进行修改。这样就做完了，时间复杂度 $O(m\log^2n)$（修改时需要向上跳 $O(\log n)$ 次，每跳一次都要进行一次线段树单点修改）。

注意：由于 $\oplus$ 不具有交换律，所以如果根据我的做法来写代码，线段树上合并的时候必须用左子区间的矩阵积乘上右子区间的矩阵积。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=3e5+10;
struct matrix{
	long long a[3][3];
	matrix (){
		a[1][1]=a[1][2]=a[2][1]=a[2][2]=-1e18;
	}
	matrix operator*(matrix x)const{//矩阵乘法
		matrix ans;
		for(int i=1;i<=2;i++)
			for(int j=1;j<=2;j++)
					ans.a[i][j]=-1e18;
		for(int i=1;i<=2;i++)
			for(int j=1;j<=2;j++)
				for(int k=1;k<=2;k++)
					ans.a[i][j]=max(ans.a[i][j],a[i][k]+x.a[k][j]);
		return ans;
	}
};
int w[maxn];
long long a[maxn][3],f[maxn][3];
struct node{
	int l,r;
	matrix mat;
}t[maxn<<2];//线段树
int n,root,q;
int tot,dfn[maxn],tp[maxn],fa[maxn],son[maxn],df[maxn],End[maxn],vis[maxn];
vector<int> v[maxn];
void dfs(int u,int fat){
	vis[u]=1;
	int maxs=-1;
	fa[u]=fat;
	for(auto i:v[u]){
		if(i!=fat){
			dfs(i,u);
			End[u]+=End[i];
			if(End[i]>maxs) son[u]=i,maxs=End[i];
		}
	}
	End[u]++;
}
void dfs1(int u,int t){//树剖+树形 dp
	tp[u]=t;
	dfn[u]=++tot;
	df[tot]=u;
	if(son[u]) dfs1(son[u],t),End[u]=End[son[u]];
	else{
		End[u]=u;
		f[u][1]=w[u];
		a[u][0]=w[u];
		return;
	}
	a[u][0]=w[u];
	for(auto i:v[u])
		if(i!=son[u]&&i!=fa[u]) dfs1(i,i),a[u][0]+=f[i][0],a[u][1]+=max(f[i][0],f[i][1]);
	f[u][1]=max(f[u][1],f[son[u]][0]+a[u][0]);
	f[u][0]=max(f[u][0],max(f[son[u]][0],f[son[u]][1])+a[u][1]);
}
void build(int p,int l,int r){//建树
	t[p].l=l,t[p].r=r;
	if(l==r){
		t[p].mat.a[1][1]=a[df[l]][1];
		t[p].mat.a[1][2]=a[df[l]][1];
		t[p].mat.a[2][1]=a[df[l]][0];
		t[p].mat.a[2][2]=-1e18;
		return;
	}
	int mid=l+r>>1;
	build(p<<1,l,mid),build(p<<1|1,mid+1,r);
	t[p].mat=t[p<<1].mat*t[p<<1|1].mat;//左子区间乘上右子区间
}
void change(int p,int x,matrix ma){//单点修改
	if(t[p].l==t[p].r){
		t[p].mat=ma;
		return;
	}
	int mid=t[p].l+t[p].r>>1;
	if(x<=mid) change(p<<1,x,ma);
	else change(p<<1|1,x,ma);
	t[p].mat=t[p<<1].mat*t[p<<1|1].mat;//左子区间乘上右子区间
}
matrix query(int p,int l,int r){//查询
	if(t[p].l>=l&&t[p].r<=r) return t[p].mat;
	int mid=t[p].l+t[p].r>>1;
	if(r<=mid) return query(p<<1,l,r);
	if(l>mid) return query(p<<1|1,l,r);
	return query(p<<1,l,r)*query(p<<1|1,l,r);//左子区间乘上右子区间
}
void changeit(int x,long long k){//修改
	a[x][0]-=w[x];
	w[x]=k;
	a[x][0]+=w[x];
	matrix ma;
	ma.a[1][1]=a[x][1];
	ma.a[1][2]=a[x][1];
	ma.a[2][1]=a[x][0];
	ma.a[2][2]=-1e18;
	change(1,dfn[x],ma);
	while(x){//要跳到根节点
		ma=query(1,dfn[tp[x]],dfn[End[x]]);
		if(fa[tp[x]]) a[fa[tp[x]]][1]-=max(f[tp[x]][0],f[tp[x]][1]),a[fa[tp[x]]][0]-=f[tp[x]][0];
		f[tp[x]][0]=max(ma.a[1][1],ma.a[1][2]);
		f[tp[x]][1]=max(ma.a[2][1],ma.a[2][2]);
		if(fa[tp[x]]) a[fa[tp[x]]][1]+=max(f[tp[x]][0],f[tp[x]][1]),a[fa[tp[x]]][0]+=f[tp[x]][0];//修改链顶的父亲节点的 a 数组
		x=fa[tp[x]];
		if(x){//修改链顶的父亲节点的 G 矩阵
			ma.a[1][1]=a[x][1];
			ma.a[1][2]=a[x][1];
			ma.a[2][1]=a[x][0];
			ma.a[2][2]=-1e18;
			change(1,dfn[x],ma);
		}
	}
}
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>q;
	for(int i=1;i<=n;i++) cin>>w[i];
	for(int i=1;i<n;i++){
		int x,y;
		cin>>x>>y;
		v[x].emplace_back(y),v[y].emplace_back(x);
	}
	root=1;
	dfs(root,0),dfs1(root,root);//重链剖分
	build(1,1,n);
	for(int i=1;i<=q;i++){
		int x;
		long long k;
		cin>>x>>k;
		changeit(x,k);
		matrix ma=query(1,1,dfn[End[root]]);
		f[root][0]=max(ma.a[1][1],ma.a[1][2]);
		f[root][1]=max(ma.a[2][1],ma.a[2][2]);
		cout<<max(f[root][0],f[root][1])<<'\n';
	}
}
```

---


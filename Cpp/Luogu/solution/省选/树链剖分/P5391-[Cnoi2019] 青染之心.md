# [Cnoi2019] 青染之心

## 题目背景

这里原本有着一个史诗般的可歌可泣的背景故事，可是这里空太小，写不下。

## 题目描述

Cirno 初始有一个空的物品序列，一个大小为 $V$ 的背包，现在你有 $q$ 个操作，分为两种：

- `add x y`：表示加入一种体积为 $x$, 价值为 $y$ 的物品到序列末尾。
- `erase`：表示删除序列末尾的物品。

在每个操作结束以后，你需要求出：

假设序列中的每种物品都有无穷多个，Cirno 的背包可以装下的物品最大价值和。

## 说明/提示

对于 $100\%$ 的数据 $1\le q, V, x, y \le 2\times10^4 $。

## 样例 #1

### 输入

```
4 10
add 10 3
add 5 2
add 3 3
erase```

### 输出

```
3
4
9
4```

# 题解

## 作者：stoorz (赞：19)

设 $n$ 是物品数量，$m$ 是背包容量，$Q$ 是操作次数。

不难发现其实就是按照 dfs 序给出了一棵树，树上每一个点 $x$ 都有一个权值为 $v_x$，重量为 $w_x$ 的物品，然后把每一个节点到根的路径上的物品拎出来求完全背包。

首先最坏情况就是一条链，时间复杂度显然是 $O(Qn)$ 的，但是我们空间并没办法承受 $O(nm)$ 的复杂度，所以这道题瓶颈在于优化空间。

考虑重链剖分，每一条重链只开一个 dp 数组，因为每一个点到根节点上重链是 $O(\log n)$ 的，所以这样空间是 $O(m\log n)$ 的。

假设我们 dfs 到了点 $x$，$x$ 位于它到根上第 $\text{dep}$ 条重链，我们先遍历其所有轻儿子 $y$，用 $f[\text{dep}][0\sim m]$ 更新 $f[\text{dep+1}][0\sim m]$，然后继续 dfs 节点 $y$。

回溯回来后 $x$ 子树内就只有 $x$ 的重儿子为根的子树没有被 dp 过了，此时也就意味着可以直接在 $f[\text{dep}][0\sim m]$ 中加入 $x$ 重儿子的贡献了。

时间复杂度 $O(Qn)$，空间复杂度 $O(m\log n)$。
# 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=20010,LG=15;
int n,m,Q,tot,v[N],w[N],head[N],son[N],siz[N],id[N],ans[N],f[LG+1][N];
bool vis[N];
char ch[10];
stack<int> st;

struct edge
{
	int next,to;
}e[N];

void add(int from,int to)
{
	e[++tot]=(edge){head[from],to};
	head[from]=tot;
}

void dfs1(int x,int fa)
{
	siz[x]=1; vis[x]=1;
	for (int i=head[x];~i;i=e[i].next)
	{
		int v=e[i].to;
		if (v!=fa)
		{
			dfs1(v,x);
			siz[x]+=siz[v];
			if (siz[v]>siz[son[x]]) son[x]=v;
		}
	}
}

void dfs2(int dep,int last,int x,int fa)
{
	for (int i=0;i<=m;i++)
	{
		f[dep][i]=f[last][i];
		if (i>=w[x]) f[dep][i]=max(f[dep][i],f[dep][i-w[x]]+v[x]);
		ans[x]=max(ans[x],f[dep][i]);
	}
	for (int i=head[x];~i;i=e[i].next)
	{
		int v=e[i].to;
		if (v!=fa && v!=son[x]) dfs2(dep+1,dep,v,x);
	}
	if (son[x]) dfs2(dep,dep,son[x],x);
}

int main()
{
	memset(head,-1,sizeof(head));
	scanf("%d%d",&Q,&m);
	for (int i=1;i<=Q;i++)
	{
		scanf("%s",ch);
		if (ch[0]=='a')
		{
			n++;
			if (st.size()) add(st.top(),n);
			scanf("%d%d",&w[n],&v[n]);
			st.push(n);
		}
		else st.pop();
		if (st.size()) id[i]=st.top();
	}
	for (int i=1;i<=n;i++)
		if (!vis[i]) dfs1(i,0),dfs2(1,0,i,0);
	for (int i=1;i<=Q;i++)
		printf("%d\n",ans[id[i]]);
	return 0;
}
```

---

## 作者：a1a2a3a4a5 (赞：9)

# BFS ~~卡卡~~ 剪枝滚动数组
## 思路
不滚动数组的 01 背包可以 $O(qV)​$ 做，但是空间复杂度炸了，所以考虑优化空间。

可以离线处理，思考每个答案所需要的序列：在前一个未删除的数的序列后加一个数，可以抽象成图论连边，最后发现连成一颗树，每个节点的序列为到根节点路径上的数，那么可以跑树形 DP。

请循其本——如何优化空间？离线到在树上从根节点开始跑，在当前节点时，大胆猜测当前节点向上的路径的数组已经没啥用了，这样就可以滚掉上面的数组，发现仅需要保证当前节点向上的路径把旁生节点全更新完了就行，那么~~树链~~ BFS 就满足了这个条件，所以写 BFS + 背包，然后剪枝滚动数组就过了。

## 细节
- 如果到新一层那么就需要把上一层的数组滚掉。
- 如果该节点没有儿子，那么可以统计完答案直接在当前层滚掉该数组。
- 当前数组跑背包时，由于是完全背包，所以可以被当前更新的数组更新。
- 删除操作输出可以直接建一个向上上个点连边的节点。

```cpp
#include<bits/stdc++.h>
using namespace std;
short q,m,zhan[20001],cnt,w[20001],jia[20001],shen[20001],dy[20001],laody[20001],fa[20001];
int da[20001];
vector<short> dian[20001];
vector<int> f[20001],lao[20001];
string sr;
queue<short> dui;
int main()
{
	cin>>q>>m;
	int cab=0;
	for(int i=1,o1,o2;i<=q;i++)
	{
		cin>>sr;
		if(sr=="add")
			cin>>w[++cnt]>>jia[cnt],
			dian[zhan[cab]].push_back(cnt),
			fa[cnt]=zhan[cab],zhan[++cab]=cnt;
		else
		{
			cab=(cab-1<0)?0:cab-1;
			cnt++,dian[zhan[cab]].push_back(cnt);
			fa[cnt]=zhan[cab];
		}
	}
	dui.push(0);
	cab=0;
	int shang=0,zui=0;
	for(int j=0;j<=m;j++) f[0].push_back(0),lao[0].push_back(0); 
	while(!dui.empty())
	{
		int x=dui.front(),chang=dian[x].size();dui.pop();
		if(shang!=shen[x])//到了新一层，给上一层滚一下 。 
		{
			for(int i=0;i<=q;i++) laody[i]=dy[i],dy[i]=0;
			for(int i=0;i<=cab;i++) for(int j=0;j<=m;j++) lao[i][j]=f[i][j],f[i][j]=0;
			shang=shen[x],cab=0;
		}
		cab++;
		if(zui<cab)
		{
			for(int j=0;j<=m;j++) f[cab].push_back(0),lao[cab].push_back(0);//动态数组开空间 。 
			zui=cab;
		}
		dy[x]=cab;
		for(int j=0;j<=m;j++) f[cab][j]=lao[laody[fa[x]]][j];
		for(int j=w[x];j<=m;j++)
			f[cab][j]=max(f[cab][j],lao[laody[fa[x]]][j-w[x]]+jia[x]),
			f[cab][j]=max(f[cab][j],f[cab][j-w[x]]+jia[x]);//完全背包特性。 
		for(int j=0;j<=m;j++) da[x]=max(da[x],f[cab][j]);
		if(chang==0) cab--;//当前层直接滚掉没用的节点 。 
		for(int i=0;i<chang;i++)
		{
			int v=dian[x][i];
			dui.push(v);
			shen[v]=shen[x]+1;
		}
	}
	for(int i=1;i<=q;i++) cout<<da[i]<<'\n';
	return 0;
}
```

---

## 作者：minstdfx (赞：8)

果然我搞学术写题解啥的就只是个二流水平，当 nm 的题管啊，爬了

简要题意：

一个序列在尾端加入删除，实时做完全背包。

在线做法显然是把序列每个前缀的动规结果全部存下来，删除操作直接扬了末端，加入操作在前一个的基础上 dp。

具体地，设当前的物品编号列表为 $s=\{s_1,s_2,\cdots,s_n\}$。

现在在末尾加一个 $s_{n+1}=t$ 号物品。

$$dp_{n+1,m}=max\{dp_{n,m},dp_{n,m-w_i}+v_i\}(m=0,1,\cdots,V)$$

时间复杂度 $O(qV)$，可以接受。  
空间复杂度 $O(qV)$，炸了。

反正这道题也不强制在线，考虑离线一棵操作树下来。每个点的结果可以从它的父亲推过来。

显然整体的动态规划过程是自上而下的。

我们发现，对于树上一条自上而下的链 $L=\{a_1,a_2,\cdots,a_n\}$，我们在把这条链推下去的过程中，先对 $a_i$ 做出结果，那么其实只有 $a_i$ 这个点的儿子需要用到它。如果我们先做完了所有以 $a_i$ 儿子为根的子树，那么它就用不到了。

所以对于一条链，如果我们采取这样自上而下处理的方式，只需要开一个数组！

只要重链剖分就只有 $O(\log n)$ 条链。

对于整个过程，我们处理点 $u$ 的时候可以先处理轻儿子 $\{l_1,l_2,\cdots,l_n\}$ 的结果，然后继续遍历轻儿子（并开一条新的链），然后把当前这条链的空间递给重儿子 $w_u$，继续搜就可以遍历整棵子树。

代码就不放了，相信大家都会。

---

## 作者：rsy_ (赞：7)

题解区的做法都太困难的，我这种刚学 OI 的萌新肯定是不会做的。

显然按照完全背包的方式可以直接做 insert 只需要用 $N$ 去修改 dp 值就可以了，这样可以得到比暴力高一点的分。

考虑什么 $N$ 是有用的，发现更新了 dp 数组的 $N$ 才有用，所以考虑记一个 $f_i$ 表示 $i$ 对于有没有更新 dp 数组，如果更新了再重新算，最坏复杂度 $\mathcal O(Q^2W)$，空间是线性的，跑出来也极快，狂暴吊打题解区所有做法 ~~（建议把空间开成 1MB）~~。

```cpp
#include <bits/stdc++.h>
#define lb(x) (x&-x)
#define L(i,j,k) for(int i=(j);i<=(k);++i)
#define R(i,j,k) for(int i=(j);i>=(k);--i)

using namespace std;
using i64 = long long;

typedef pair<int, int> pii;
typedef long long ll;
typedef unsigned long long ull;
void chmin(int &x, int c) {x = min(x, c);}
void chmax(int &x, int c) {x = max(x, c);}

const int maxn = 2e4 + 10, mod = 998244353;
short Q, M, N;
short v[maxn], w[maxn];
int dp[maxn]; bool f[maxn];
void calc () {
	for (int i = 1; i <= M; i ++ ) {
		dp[i] = 0;
	}
	for (int i = 1; i <= N; i ++ ) {
		f[i] = 0;
		for (int j = v[i]; j <= M; j ++ ) {
			if (dp[j - v[i]] + w[i] > dp[j]) {
				f[i] = 1; dp[j] = dp[j - v[i]] + w[i];
			}
		}
	}
}

void solve() {
	cin >> Q >> M;
	for (int i = 1; i <= Q; i ++ ) {
		string opt;
		cin >> opt; int x, y;
		if (opt == "erase") {
			N -- ;
			if (f[N + 1]) calc();
		} else {
			cin >> x >> y; N ++ ;
			v[N] = x; w[N] = y; f[N] = 0;
			for (int j = v[N]; j <= M; j ++ ) {
				if (dp[j - v[N]] + w[N] > dp[j]) {
					dp[j] = dp[j - v[N]] + w[N]; f[N] = 1;
				}
			}
		}
		cout << dp[M] << '\n';
	}
}

signed main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  int T = 1;
  while (T--)solve();
  return 0;
}
```

---

## 作者：masonxiong (赞：2)

# 题目分析

先对问题进行转化。

很难观察到的是，在将操作离线后，这题相当于**按照 DFS 序给出了一个物品森林**。

我们不妨添加一个空物品（体积和价值都为 $0$，显然这样的物品在完全背包中不起作用）作为超级根节点，使得这个森林变为一棵树。

那么你现在需要求的是：对于从每个节点到根节点的物品链，求它的完全背包。

## 乱搞做法 #1

如果你在树上跑朴素的树形动态规划一次性解决所有答案，空间复杂度是 $O(qV)$ 的。但是你发现序列上完全背包可以滚动数组，空间复杂度是 $O(q+V)$ 的。

这个时候我们掏出乱搞做法：对于每个叶子到根的链求一次完全背包，空间复杂度降低到 $O(q+V)$ 但是时间复杂度变为 $O(V\cdot s)$（其中 $s$ 为叶子深度之和），可以构造这样一棵树来卡掉：

- 一条长度为 $\frac q2$ 的链。
- 将此链的下端改为一个 $\frac q2$ 的菊花。

## 乱搞做法 #2

所谓 BFS 滚动数组。

注意到**树上完全背包是从上到下的**，那么：

- 若一个节点已经 DFS 了其全部儿子，那么这个节点将不再会被使用。

那么你可以直接扔掉这个节点的转移数组。时间复杂度 $O(qV)$，空间复杂度 $O(V\cdot w)$（其中 $w$ 是树的宽度，也就是深度相同的节点的数量的最大值）。可以构造这样一棵树来卡掉：

- 共三层，第二层和第三层的节点个数均为 $\frac q2$。

**然而实际上此解法的空间常数较小**，空间限制 64MB 是卡不掉的。

## 正确做法

注意到**树上完全背包是从上到下的**，那么：

- 若一个节点已经 DFS 了其全部儿子，那么这个节点将不再会被使用。

换句话说，若我们为每个节点指定一个“关键儿子”，那么：

- 若一个节点已经 DFS 了其全部非关键儿子，那么这个节点的转移数组可以直接给它的关键儿子使用。

我们定义一个节点的“关键边”为这个节点连向其关键儿子的边。我们再定义“关键链”为极长的连续的关键边连成的链。

根据我们的结论，一条关键链上只需要使用一个转移数组。于是你考虑让关键链数量尽可能少。

一种很好的方法是：令一个节点关键儿子为该节点全部儿子中，子树节点数量最多的儿子。这是所谓重链剖分。

接下来我们证明树上的任意一条路径 $(u,v)$ 可以被分成不超过 $O(\log n)$ 条关键链。首先我们知道，每当我们经过一条非关键边，所在的子树的节点个数会减半，反证法不难证明。

然后我们将这条路径拆成从最近公共祖先向左走和向右走两个部分，两个部分的长度至多是 $O(n)$ 的，那么经过非关键边数量就是 $O(\log n)$ 的。

因为一条非关键边一定连接了两条关键链，所以经过关键链数量也是 $O(\log n)$ 的。

**但是这并不保证整棵树的关键链条数是 $O(\log n)$ 的**。可以构造菊花卡满。

于是你应当先 DFS 一个节点的非关键儿子，转移结束后立刻回收其空间，此时空间复杂度为 $O(V\cdot c)$（其中 $c$ 是从一个叶子到根所经过的关键链数量的最大值）的。

根据我们前面的证明，$c$ 为 $O(\log q)$，于是总体时间复杂度 $O(qV)$，空间复杂度降到 $O(V\log q)$ 可以通过。

# 代码实现

```cpp
#include <bits/stdc++.h>

constexpr int Maxq = 2e4 + 5, Maxv = 2e4 + 5;

int q, v, x, y;
std::vector<std::pair<int, int>> items;
std::array<std::vector<int>, Maxq> tree;
std::stack<int, std::vector<int>> stack;
std::array<int, Maxq> id, size, answer, child;
std::array<std::array<int, Maxv>, 33 - __builtin_clz(Maxq)> F;

void firstDFS(int current) {
    size[current] = 1;
    for (int next : tree[current]) {
        firstDFS(next);
        size[current] += size[next];
        if (size[next] > size[child[current]])
            child[current] = next;
    }
}

void secondDFS(int current, int carray, int parray) {
    auto item = items[current - 1];
    for (int i = 0; i <= v; i++) {
        F[carray][i] = F[parray][i];
        if (i >= item.first)
            F[carray][i] = std::max(F[carray][i], F[carray][i - item.first] + item.second);
        answer[current] = std::max(answer[current], F[carray][i]);
    }
    for (int next : tree[current])
        if (next != child[current])
            secondDFS(next, carray + 1, carray);
    if (child[current])
        secondDFS(child[current], carray, carray);
}

int main() {
    std::cin.tie(nullptr)->sync_with_stdio(false);
    std::cin >> q >> v, items.emplace_back(0, 0), stack.push(1);
    for (int i = 0; i < q; i++) {
        std::string o;
        if (std::cin >> o, o == "erase") {
            stack.pop();
        } else if (o == "add") {
            std::cin >> x >> y;
            items.emplace_back(x, y);
            if (!stack.empty())
                tree[stack.top()].push_back(items.size());
            stack.push(items.size());
        }
        if (!stack.empty())
            id[i] = stack.top();
    }
    firstDFS(1), secondDFS(1, 1, 0);
    for (int i = 0; i < q; i++)
        std::cout << answer[id[i]] << '\n';
    return 0;
}
```

---

## 作者：Firsry (赞：2)

前几篇重链剖分题解中都说或者用到了一个结论：重链剖分最多把一棵树剖分成 $\log n$ 条链。

那我问你，如果我祭出这张图，阁下如何应对？

![](https://cdn.luogu.com.cn/upload/image_hosting/6mz9ys03.png)

这个结论是错误的。而且影响很大，考场上全 $\textcolor{purple}{\mathrm{RE}}$ 一个明明可以切的题目是划不来的。仅仅是这道题目的数据允许了这样的通过。巧合而已。

因为每个叶子节点与每条链一一映射，链的数量是和叶子节点数量持平的，而最多为 $n$ 的级别（树仅仅只有根节点和叶结点）。如果是这样，那么空间复杂度又会超标。怎么办？

可以发现对于递推数组 $f$ 的使用在某一个重链递归退出后就不再使用了，因为答案已经计算出来。也就是说，每时每刻一定需要维护的 $f$ 数组个数，也就是根到叶子节点经过的链数。所以如果可以动态地申请使用 $f$ 数组的空间，就可以保证 $\log n$，而这个是 `vector` 可以做到的。

代码如下：

```cpp
#include<bits/stdc++.h>

using namespace std;

const int MAXN = 20005;

int q, v, ind = 0;
string s;
int cost[MAXN], val[MAXN];

int vis[MAXN];
int edgeCount;
int head[MAXN], toNode[MAXN], nextEdge[MAXN];
int siz[MAXN], son[MAXN];

vector< vector<int> > f;
int ans[MAXN];
vector< pair<int, int> > era;

inline void addEdge(int from, int to) {
	edgeCount++;
	toNode[edgeCount] = to;
	nextEdge[edgeCount] = head[from];
	head[from] = edgeCount;
	return;
}

inline int read() {
	int x = 0;
	char ch = getchar();
	while (!isdigit(ch))
		ch = getchar();
	while (isdigit(ch)) {
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return x;
}

inline void dfs1(int from, int father) {
	siz[from]++;
	for (int i = head[from]; i; i = nextEdge[i]) {
		int to = toNode[i];
		if (to != father) {
			dfs1(to, from);
			siz[from] += siz[to];
			if (siz[son[from]] < siz[to])
				son[from] = to;
		}
	}
	return;
}
inline void dfs2(int from, int father) {
	for (int j = cost[from]; j <= v; ++j)
		f.back()[j] = max(f.back()[j], f.back()[j - cost[from]] + val[from]);
	ans[from] = f.back()[v];
	for (int i = head[from]; i; i = nextEdge[i]) {
		int to = toNode[i];
		if (to != father && to != son[from]) {
			f.push_back(f.back());
			dfs2(to, from);
			f.pop_back();
		}
	}
	if (son[from])
		dfs2(son[from], from);
	return;
}

int main() {
	q = read(), v = read();
	f.push_back(vector<int>(v + 1, 0));
	vis[0] = 20001;
	for (int i = 1; i <= q; ++i) {
		cin >> s;
		if (s[0] == 'a') {
			addEdge(vis[ind], i);
			vis[++ind] = i;
			cost[i] = read(), val[i] = read();
		} else
			--ind, era.push_back({i, vis[ind]});
	}
	dfs1(vis[0], 0);
	dfs2(vis[0], 0);
	for (auto i : era)
		ans[i.first] = ans[i.second];
	for (int i = 1; i <= q; ++i)
		cout << ans[i] << '\n';
	return 0;
}
```

花絮：

1. 本来想要卡常卡进最优解的，结果偶遇知识型问题，拼尽全力无法战胜，`vector` 常数直接破碎了这个想法。
2. `dfs2` 函数中使用参数 $chain$ 用于记录经过的重链个数，就可以搭配数组使用，因为进行了重复利用，而不是对于每一个子链进行重新分配。
   （详情可以见我的最优解，就是滚动数组重复利用实现的）
3. 用 `vector` 一定要先初始化不为 `empty`，否则取出 `.back()` 的时候就老实了。
4. 如果根节点是 $0$ 的话，$son_{from}$ 一定要进行非 $0$ 初始化。

---

## 作者：囧仙 (赞：2)

## 题目大意

> 有一个序列、大小为 $v$ 的背包，及 $q$ 个操作，分为两种：  
> - $\verb!add x y!$ : 表示加入一种体积为 $x$ , 价值为 $y$ 的物品到序列末尾。  
> - $\verb!erase!$ : 表示删除序列末尾的物品。  
> 每个操作结束以后，求出，假设序列中的每种物品都有无穷多个，询问背包可以装下的物品最大价值和。  
> $1\le x,y,v,q\le 2\times 10^4;1s,\textbf{64MB}$

## 题解

这里提供一个时间复杂度 $\mathcal O(vq)$ ， 空间复杂度 $\mathcal O(v\sqrt q)$ 的做法。

显然，题目所要求的是允许撤回的无限背包。不妨设前 $i$ 个物品中，共使用 $j$ 的体积，所获得的最大的价值，显然根据无限背包的做法，有：

$$dp_{i,j}=\max\{dp_{i-1,j},dp_{i,j-x_{i}}+y_i\}$$

如果就是这么结束了，这题也不可能评分为紫题。观察到空间限制为 $\text{64MB}$ ，显然我们不能直接开 $\mathcal O(vq)$ 的空间暴力存储。如果使用滚动数组优化，我们不能够很好地解决**撤销**操作。应该怎么办呢？

出题人用的是一个空间 $\mathcal O(v\log q)$ 的做法，但是我太菜了没看懂。所以这边提供一个劣一些但是能过题的方法。

---

为了下文叙述方便，我们设：

- 第 $a$ 个物品所对应的 $dp$ 序列为 $dp_{a,b}(b\in[0,v])$ ，也就是 $dp$ 数组的第 $a$ 行。 

观察到撤销操作只会撤回到上一次加入的时候，所以我们可以存储最近的若干次加入操作。不妨设我们存储了 $[l,r]$ 以内的所有物品对应的 $dp$ 序列，现在序列中，共有 $p$ 个物品。显然，当 $l \le p\le r$ 时，我们可以直接取出相应的答案 $dp_{p,v}$ 。这部分空间复杂度应当是 $\mathcal O((r-l)\times v)$ 的。

但事实上，可能会出现 $p$ 移动到 $l$ 左侧，或者 $p$ 移动到 $r$ 右侧的情况。当 $p<l$ 时，我们需要更新维护的区间，不妨令 $l\gets l-s ,r\gets r-s$ 。其中 $s$ 是一个常量；同理，当 $p>r$ 时，令 $l\gets l+s ,r\gets r+s$ 。特别地，**初始时 $\boldsymbol{l=0}$**。

考虑如何更新维护的区间。事实上，假如我们知道第 $l$ 个物品对应的 $dp$ 序列 ，同时已知 $x_i,y_i,(i\in(l,r])$ ，就可以直接计算出 $dp_{l,r}$ 内的所有值（第 $a+1$ 个物品对应的 $dp$ 序列仅依赖第 $a$ 个物品的序列，以及 $x_{a+1},y_{a+1}$ ）。这部分的时间开销是 $\mathcal O((r-s)v)$ 。我们怎么知道所有的 $dp_{l,a}(a\in[0,v])$ 呢？我们可以开一个数组 $M$ ，用来存储所有**可能的 $\boldsymbol{l}$ 的位置的 $\boldsymbol{dp}$ 值**。显然，这样的 $l$ 有 $\frac{q}{s}$ 个。下面考虑如何平衡时间和空间的开销。

为了尽可能减少计算第 $l$ 到第 $r$ 个物品的 $dp$ 值，我们希望每次更新后 $p$ 应当在 $[l,r]$ 的中间，这样距离下一次更新的距离就最长了。于是令 $r=l+2\times s-1$ ，也就是说 $[l,r]$ 区间的长度为 $2s$ 。

我们一共会用到的空间为 $\mathcal O(v\times (\frac{q}{s}+2s))$ ，时间是 $\mathcal O(v\times (s\times \frac{q}{s}+q))=\mathcal O(vq)$ 。当 $s$ 取 $\sqrt\dfrac{q}{2}$ 时，可以达到空间上的最小值。

总结一下我们的做法：

- 维护 $[l,r]$ 内所有物品对应的 $dp$ 序列。当 $p$ 跳出这个区间时，更新 $l,r$ ，同时重新计算这部分物品的 $dp$ 序列。  
- 记录当 $p=k\times s(k=0,1,2,\cdots)$ 时，第 $p$ 个物品对应的 $dp$ 序列，用于复现 $[l,r]$ 内的物品的 $dp$ 序列。

时间复杂度 $\mathcal O(vq)$ ， 空间复杂度 $\mathcal O(v\sqrt q)$ 。~~然而常数非常大~~。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
const int MAXN =2e4+3,MAXM=300+3,SI=4;
int q,v,t,s,l,r,X[MAXN],Y[MAXN]; char S[10];
int W[MAXM][MAXN],M[MAXM][MAXN],T[MAXN];
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
int main(){
    q=qread(),v=qread(),s=1+sqrt(q+1)/2,l=0,r=2*s-1;
    up(1,q,i){
        scanf("%s",S); if(S[0]=='e'){
            --t; if(t+1==l){
                l-=s,r-=s; up(0,v,j) W[0][j]=M[l/s][j];
                up(1,s-1,j){
                    int x=X[l+j],y=Y[l+j];
                    up(0,min(x-1,v),k) W[j][k]=W[j-1][k];
                    up(x,v,k) W[j][k]=max(W[j-1][k],W[j][k-x]+y);
                }
            }
        } else {
            ++t; int x=qread(),y=qread(); X[t]=x,Y[t]=y;
            if(t-1==r){
                up(0,s-1,j) up(0,v,k) W[j][k]=W[j+s][k]; l+=s,r+=s;
            }
            up(0,min(x-1,v),j) W[t-l][j]=W[t-l-1][j];
            up(x,v,j) W[t-l][j]=max(W[t-l-1][j],W[t-l][j-x]+y);
            if(t%s==0) up(0,v,j) M[t/s][j]=W[t-l][j];
        }
        printf("%d\n",W[t-l][v]);
    }
    return 0;
}
```

---

## 作者：Redshift_Shine (赞：1)

## 闲话

这道题目之所以被称为“青染之心”，不仅是因为这道题与东方有关的故事背景，更是因为这道题将我们的思绪拨回了刚学习树链剖分的时候。

## 题解

这道题的做法并不显然，毕竟这道题可以让人一眼想到可撤销背包，但是想到操作树远没有这么简单。即使知道了可以使用操作树处理，也很难想到使用树链剖分进行优化。更进一步地，即使知道了树链剖分，也不一定能跳出先处理重链的惯性思维，而改用先处理轻链。

此处具体解释如何通过重链剖分优化本题的空间，关于背包的部分不再赘述。

首先，让我们回想**重链剖分**拥有的一条重要性质——在一棵有 $n$ 个节点的树上，从根到**任意**节点的唯一路径上的轻边数不超过 $\log n$。

我第一次看到此题时，首先想到的思路是使用重链剖分，从根节点所在的重链开始，一条一条链地处理，中间碰到轻边就将整个 dp 数组拷贝一份等到后面处理。

然而，重链剖分**并不**保证一棵树最多被剖分成 $\log n$ 条链。一个节点数 $n$ 不少于 $2$ 的菊花图会被剖分成 $(n-1)$ 条链。

于是，在这道题中，我们需要一反常态地先处理轻边。

具体来说，对于操作树上的一个节点 $x$，我们将挂载在节点 $x$ 上的物品加入背包后，我们可以先将 dp 数组复制到轻边所连接的节点，并**立即递归处理**。原因是，在处理完任意一个轻链后，我们可以**直接回收**这条轻链所占的 dp 数组空间，并将其赋予下一个轻链。

令物品总数为 $n$，则时间复杂度 $O(nV)$，空间复杂度 $O(V\log n)$。

## 代码

```c++
#include <cctype>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <string>
using namespace std;
const int N = 2e4 + 10;
int n, q, v, dp[15][N], siz[N], ds[N], idx, res[N], tag[N], f[N], tx[N], ty[N];
basic_string<int> road[N];
template <typename _Tp> inline void read(_Tp &x)
{
    char ch;
    while (ch = getchar(), !isdigit(ch) and ~ch)
        ;
    x = (ch ^ 48);
    while (ch = getchar(), isdigit(ch))
        x = (x << 3) + (x << 1) + (ch ^ 48);
}
#define max(x, y) ((x) > (y) ? (x) : (y))
template <typename _Tp, typename... _Args> inline void read(_Tp &x, _Args &...args)
{
    read(x);
    read(args...);
}
void init(int x)
{
    siz[x] = 1;
    ds[x] = n + 1;
    for (auto &i : road[x])
    {
        init(i);
        if (siz[i] > siz[ds[x]])
            ds[x] = i;
        siz[x] += siz[i];
    }
}
void dfs(int x)
{
    for (int i = tx[x]; i <= v; i++)
    {
        dp[idx][i] = max(dp[idx][i], dp[idx][i - tx[x]] + ty[x]);
        res[x] = max(res[x], dp[idx][i]);
    }
    res[x] = max(res[x], res[f[x]]);
    if (!ds[x])
        return;
    for (auto &i : road[x])
    {
        if (i == ds[x])
            continue;
        idx++;
        memcpy(dp[idx] + 1, dp[idx - 1] + 1, v << 2);
        dfs(i);
        idx--;
    }
    dfs(ds[x]);
}
string s;
int main()
{
    read(q, v);
    for (int i = 1, ta, tb; i <= q; i++)
    {
        tag[i] = tag[i - 1];
        cin >> s;
        if (s == "erase")
        {
            tag[i] = f[tag[i]];
            continue;
        }
        read(ta, tb);
        n++;
        tx[n] = ta, ty[n] = tb;
        road[tag[i]] += n;
        f[n] = tag[i];
        tag[i] = n;
    }
    init(0);
    dfs(0);
    for (int i = 1; i <= q; i++)
    {
        printf("%d\n", res[tag[i]]);
    }
}
```

---

## 作者：未来姚班zyl (赞：1)

## 题目大意

动态维护一个完全背包问题，每次加入一个物品或删除剩下的最后加入的一个物品，并在每次操作后输出答案。

操作次数、值域小于等于 $2\times 10^4$，**时限 5s，内存限制 64MB**。

## 题目大意

这样的时限肯定是要放 $O(nV)$ 的复杂度过啊，那不是大水题吗？维护每个位置的背包数组，每次加入物品即正常背包，否则回溯，复杂度 $O(nV)$。但空间复杂度也是 $O(nV)$，无法接受。

这问题又不能随意滚动，是否就不可做了呢？这时候我们一般都得注意到每次操作只会变化一个物品的量级，可以尝试从这下手。

再思考能够发现，整个操作序列是构成树结构的，那么，我们把操作树建出来，就可以尝试用树论有关的算法来优化。

显然，一个节点的答案是从它到根节点上所有物品的完全背包答案。如果只有一条链，就可以通过滚动将复杂度降到 $O(n)$。而树是有分叉的，一个节点只能有一个儿子不用回溯，其它的节点则必须新建一个 dp 数组。而如果我们使用树链剖分，钦定每个点的那个不用回溯的节点为它的重儿子，则新建数组就相当于跳轻边。而每个节点到根的路径上只有 $O(\log n)$ 条轻边，直接在操作树上 dfs 并维护即可，空间复杂度 $O(V\log n)$，通过此题。

注意：dfs 回溯时要把新建的数组给删了，操作树的根节点应该是空的状态，而不是有一个物品。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define L x<<1
#define R x<<1|1
#define mid (l+r>>1)
#define lc L,l,mid
#define rc R,mid+1,r
#define OK Ll<=l&&r<=Rr
#define Root 1,1,n
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define per(x,y,z) for(int x=(y);x>=(z);x--)
#define pb push_back
#define ull unsigned ll
#define e(x) for(int i=h[x],y=to[i];i;i=nxt[i],y=to[i])
#define E(x) for(auto y:p[x])
#define Pi pair<int,int>
#define ui unsigned ll
inline int read(){int s=0,w=1;char c=getchar();while(c<48||c>57) {if(c=='-') w=-1;c=getchar();}while(c>=48&&c<=57)s=(s<<1)+(s<<3)+c-48,c=getchar();return s*w;}
inline void pf(int x){if(x<0) putchar('-'),x=-x;if(x>9)pf(x/10);putchar(x%10+48);}
const int N =2e4+5,M=5e5+5,inf=(1LL<<31)-1;
const ll llf=1e18,mod=1e9+7,bas=131;
const ui base=13331;
const double eps=1e-9;
using namespace std;
int n,m=read(),v=read(),h[N],to[N],nxt[N],cnt,nw;
inline void add(int a,int b){
	to[++cnt]=b,nxt[cnt]=h[a],h[a]=cnt;
}
string opt;
int Id[N],siz[N],son[N],a[N],val[N],dp[13][N],f[N],ans[N],tot=1;
inline void dfs(int x){
	siz[x]=1;
	e(x)dfs(y),siz[x]+=siz[y],son[x]=siz[y]>siz[son[x]]?y:son[x];
}
inline void Dfs(int x,int fr){
	rep(i,a[x],v)dp[fr][i]=max(dp[fr][i],dp[fr][i-a[x]]+val[x]),ans[x]=max(ans[x],dp[fr][i]);
	e(x)if(y^son[x]){
		tot++;
		rep(j,1,v)dp[tot][j]=dp[fr][j];
		Dfs(y,tot),tot--;
	}
	if(son[x])Dfs(son[x],fr);
}
int main(){
	rep(i,1,m){
		cin >>opt;
		if(opt=="add"){
			n++;
			a[n]=read(),val[n]=read();
			add(nw,n),f[n]=nw,nw=n;
		}else nw=f[nw];
		Id[i]=nw;
	}
	dfs(0),Dfs(0,1);
	rep(i,1,m)pf(ans[Id[i]]),putchar('\n'); 
    return 0;
}
```


---

## 作者：Karl_Aurora (赞：1)

**[~~无耻地推销个人博客 qwq~~](https://www.luogu.com.cn/blog/ling-XAIqwq/solution-p5391)**

**[题目传送门](https://www.luogu.com.cn/problem/P5391)**

------------

## 题意

~~可持久化完全背包（确信）~~ $q$ 次操作，每次往序列末尾加入或删除一个物品，求每次操作后对这个序列跑完全背包的结果。

## 解法

树剖好题。

发现这题的时空限制分布极其不均匀，可以看出这题大概是要在空间上做文章。

由于每次跑完全背包 dp 时基本上整个 dp 数组都要被修改，因此一般的可持久化思路肯定是行不通的。

但是这道题没有要求在线，所以我们可以把整个操作树离线存下来，再考虑怎么在这个树上乱搞。

我们都知道在一条链上做背包问题的 dp 是可以通过滚动数组把空间压掉一位的，因为每个点的答案是从根节点开始做 dp 一直做到当前节点，那么我们当然希望可以把这样的路径分成尽可能少的几条链，链内用滚动数组来节省空间，到这里其实就可以看出这道题做法大概就是重链剖分了。

具体实现起来大概就是轻儿子转移时存到新空间里，重儿子则直接在父亲的空间里改，每次先转移所有的轻儿子再转移重儿子就能保证结果的正确性，而因为一条路径最多经过 $\Theta(\log n)$ 条轻边，所以顶多额外开 $\Theta(\log n)$ 个 dp 转移数组，重复利用一下空间复杂度就是 $\Theta(V \log n)$ 的，同时时间复杂度仍是正常的 $\Theta(Vn)$，可以过题。

最后代码如下：

```cpp
#include <bits/stdc++.h>
#define rt 0
#define maxn 20010
using namespace std;
struct side {int v, next;} sidelist[maxn];
int sidecnt, sidehead[maxn];
inline void buildside (const int &u, const int &v) {sidelist[++sidecnt] = {v, sidehead[u]}; sidehead[u] = sidecnt;}
int op[maxn], ans[maxn], c[maxn], w[maxn];
int q, V;
int cnt;
stack < int > st;
int dp[20][maxn];
int siz[maxn], heavy[maxn];
void dfs1(const int &x)
{
    siz[x] = 1; heavy[x] = -1;
    for (int i = sidehead[x]; i; i = sidelist[i].next)
    {
        int to = sidelist[i].v;
        dfs1(to);
        siz[x] += siz[to];
        if (heavy[x] == -1 || siz[to] > siz[heavy[x]]) heavy[x] = to;
    }
    return;
}
void dfs2(const int &x, const int &dep, const bool &is_heavy)
{
    if (is_heavy) for (int i = c[x]; i <= V; ++i) dp[dep][i] = max(dp[dep][i], dp[dep][i - c[x]] + w[x]);
    else 
    {
        for (int i = 0; i < c[x]; ++i) dp[dep][i] = dp[dep - 1][i];
        for (int i = c[x]; i <= V; ++i) dp[dep][i] = max(dp[dep - 1][i], dp[dep][i - c[x]] + w[x]);
    }
    ans[x] = dp[dep][V];
    for (int i = sidehead[x]; i; i = sidelist[i].next)
    {
        int to = sidelist[i].v;
        if (to != heavy[x]) dfs2(to, dep + 1, false);
    }
    if(heavy[x] != -1) dfs2(heavy[x], dep, true);
}
int main()
{
#ifndef ONLINE_JUDGE
    freopen("P5391.in", "r", stdin);
    freopen("P5391.out", "w", stdout);
#endif
    ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);
    cin >> q >> V;
    st.emplace(rt);
    for (int i = 1; i <= q; ++i)
    {
        string str;
        cin >> str;
        if (str == "add")
        {
            ++cnt; buildside(st.top(), cnt); st.emplace(cnt);
            cin >> c[cnt] >> w[cnt];
        }
        else st.pop();
        op[i] = st.top();
    }
    dfs1(rt);
    dfs2(rt, 0, true);
    for (int i = 1; i <= q; ++i) cout << ans[op[i]] << endl;
    return 0;
}
```

至此，愉快 AC，完结撒花

---

## 作者：tzc_wk (赞：1)

[洛谷题面传送门](https://www.luogu.com.cn/problem/P5391)

介绍一种假做法，期望复杂度应该比较优秀，但可以卡掉（

首先这个问题显然严格强于只有添加元素的情况对吧，而只有添加元素的情况就是一个普通的背包，而只有插入操作的版本复杂度就已经达到了 $\mathcal O(qV)$，因此此题 std 的复杂度肯定不低于 $\mathcal O(qV)$，而此题数据范围和实现刚好够 $\mathcal O(qV)$ 的做法通过，因此我们考虑往这个方向思考。我们可以想出一车奇奇怪怪地做法，但都过不去此题的限制，譬如：

- 奇奇怪怪的做法 $1$：显然此题后进先出的结构组成了一个栈对吧，因此我们考虑对于每个物品，记录栈底到该物品的背包情况，这样删除操作就移动个指针即可，时空复杂度均为 $\mathcal O(qV)$，但由于此题空间限制很紧，该做法无法通过。
- 奇奇怪怪的做法 $2$：注意到每个物品存活的时间肯定是一个区间，因此考虑以时间轴为下标建立一棵线段树进行线段树分治，线段树向下递归时就将对应节点上的物品加入背包，回溯时直接记录个临时数组并撤回即可，时间复杂度 $qV\log q$，空间复杂度 $V\log q$，时间复杂度又无法卡进实现。

考虑将两个暴力结合一下。常用的结合暴力的做法无非就是利用根号的良好性质，因此我们考虑分块，我们设一个阈值 $B$，然后将已经插入的元素分为两部分：整块和零散部分，具体来说假设插入的元素个数为 $x$，那么我们将前 $\lfloor\dfrac{x}{B}\rfloor·B$ 个元素分为 $\lfloor\dfrac{x}{B}\rfloor$ 个整块，外加 $x\bmod B$ 个散块。对于每个整块我们维护一下栈底到这个整块的右端点构成的背包，对于散块我们维护一下散块中前 $i$ 个元素（$i\le x\bmod B$）组成的背包，每加入一个元素，如果散块大小达到了 $B$ 那就暴力将散块打包为一个整块，否则直接在散块最后一个元素末尾组成的背包中加入一个元素塞到背包序列的末尾。每次弹出栈顶元素时，如果当前散块被弹空了则暴力重构最后一个整块，否则直接令散块大小 $-1$，这样一来，如果 $B$ 固定那么显然是可以卡掉的，每次先插入 $B$ 个元素然后不断删除，再插入，再删除，再插入，以此类推即可将复杂度卡到 $qVB$，但是如果我们考虑玄学一波，$B$ 在 $[101,200]$ 中随机，这样复杂度期望就是 $qV$ 了（

极端数据大概是先插入 $100$ 个元素，然后插入、删除，重复 $100$ 次，再插入一个元素，插入、删除，重复 $100$ 次，以此类推，这样不论 $B$ 是啥都要重构同一块重构 $100$ 次（

貌似题解区里也有神仙的做法复杂度与根号相关？并且还有严格的复杂度证明？orzorz/bx

```cpp
const int MAXN=2e4;
int qu,V,blk_sz,cur=0,rst=0;
pii a[MAXN+5];
struct knap{
	int w[MAXN+5];
	void clear(){memset(w,0,sizeof(w));}
	void ins(int x,int y){for(int i=x;i<=V;i++) chkmax(w[i],w[i-x]+y);}
} b[205],ed[205];
int calc(){
	int res=0;
	for(int i=0;i<=V;i++) chkmax(res,b[cur/blk_sz].w[i]+ed[rst].w[V-i]);
	return res;
}
int main(){
	scanf("%d%d",&qu,&V);srand(time(0));
	blk_sz=rand()%100+101;
	while(qu--){
		static char opt[11];scanf("%s",opt+1);
		if(opt[1]=='a'){
			int x,y;scanf("%d%d",&x,&y);
			a[++cur]=mp(x,y);rst++;
			ed[rst]=ed[rst-1];ed[rst].ins(x,y);
			if(rst==blk_sz){
				b[cur/blk_sz]=b[cur/blk_sz-1];
				for(int i=cur-blk_sz+1;i<=cur;i++) b[cur/blk_sz].ins(a[i].fi,a[i].se);
				rst=0;
			}
		} else {
			cur--;rst--;
			if(rst<0){
				for(int i=1;i<=blk_sz;i++) ed[i].clear();
				rst=blk_sz-1;
				for(int i=1;i<blk_sz;i++) ed[i]=ed[i-1],ed[i].ins(a[cur-rst+i].fi,a[cur-rst+i].se);
			}
		} printf("%d\n",calc());
	}
	return 0;
}
/*
4 8
add 2 1
add 3 2
add 4 3
add 5 4
*/
```

所以，建议加强数据（

---

## 作者：tommymio (赞：1)

按照时间建树，然后跑树上背包？我看你空间可能会爆哦（

注意到这个树上背包事实上只有根到某个节点的一条路径上，所以可以用树剖轻重链的方式，每次处理当前这条重链的背包并和上一条重链的背包合并。这部分我觉得有点像 $\text{dsu on tree}$ 的 $\text{trick}$，但不完全。

时间复杂度为 $O(nm+Q)$，空间复杂度为 $O(m \log n+Q)$，其中 $m$ 为背包容量，$n$ 为物品个数。所以在这个数据范围下，时空复杂度与 $Q$ 无关？可以这么认为（bushi

说线段树分治的还是歇歇吧，$O(nm)$ 空间复杂度怕不是没 $\text{MLE}$ 过（

---

## 作者：ax_by_c (赞：0)

Can I win?

这个题时间肯定是 $O(qV)$ 的，主要问题是空间开不下。

考虑离线，操作相当于一棵树，要对每个点到根的链求答案。

可以发现一条链只需要开一个 DP 数组就行了，类似可以考虑树剖，每次先用当前 DP 数组去算轻儿子的 DP 数组，再继承给重儿子。

这样没啥用。但是如果两条链到根链数相同那么不会相互影响，所以可以让到根链数相同的链用同一个 DP 数组。

重剖中每个点到根的链数是 $O(\log n)$ 的，因此空间复杂度是 $O(V\log n)$。

```cpp
#include<bits/stdc++.h>
#define rep(i,l,r) for(int i=(l);i<=(r);i++)
#define per(i,r,l) for(int i=(r);i>=(l);i--)
#define repll(i,l,r) for(ll i=(l);i<=(r);i++)
#define perll(i,r,l) for(ll i=(r);i>=(l);i--)
#define pb push_back
#define ins insert
#define clr clear
using namespace std;
namespace ax_by_c{
typedef long long ll;
const int N=2e4+5;
const int LN=16;
int n,m;
char op[10];
int cur,idx,fa[N],x[N],y[N],id[N],ans[N];
vector<int>g[N];
int sz[N],sn[N];
void dfs(int u){
    sz[u]=1;
    for(auto v:g[u]){
        dfs(v);
        sz[u]+=sz[v];
        if(sz[v]>sz[sn[u]])sn[u]=v;
    }
}
int f[LN][N];
void ddfs(int u,int d){
    rep(i,x[u],m)f[d][i]=max(f[d][i],f[d][i-x[u]]+y[u]);
    ans[u]=f[d][m];
    for(auto v:g[u]){
        if(v==sn[u])continue;
        rep(i,0,m)f[d+1][i]=f[d][i];
        ddfs(v,d+1);
    }
    if(sn[u])ddfs(sn[u],d);
}
void slv(int _csid,int _csi){
	scanf("%d %d",&n,&m);
    rep(i,1,n){
        scanf("%s",op+1);
        if(op[1]=='a'){
            g[cur].pb(++idx);
            fa[idx]=cur,cur=idx;
            scanf("%d %d",&x[cur],&y[cur]);
        }
        if(op[1]=='e')cur=fa[cur];
        id[i]=cur;
    }
    dfs(0);
    ddfs(0,0);
    rep(i,1,n)printf("%d\n",ans[id[i]]);
}
void main(){
//	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	int T=1,csid=0;
//	scanf("%d",&csid);
//	scanf("%d",&T);
	rep(i,1,T)slv(csid,i);
}
}
int main(){
	string __name="";
	if(__name!=""){
		freopen((__name+".in").c_str(),"r",stdin);
		freopen((__name+".out").c_str(),"w",stdout);
	}
	ax_by_c::main();
	return 0;
}
```

---

## 作者：strcmp (赞：0)

牛逼题啊。

首先一个朴素的想法是按题意模拟，直接暴力把根到 $u$ 路径的背包数组存下来，然后每次插入撤销直接用。

时间复杂度 $\Theta(qV)$，5s 时限稳稳的。

但是空间复杂度也是 $\Theta(qV)$，空限 64MB，一条链出来铁炸啊。

你考虑一条链怎么优化空间，然后你发现这很睿智，你直接拿背包数组在链上滚出来一个数组就完了。

然后现在变成了树，你想一下树跟链的关系 $\to$ 重链剖分，启动！

重链剖分告诉我们一个点跳到根结点最多经过 $\log$ 条重链。这启发我们在这些重链上直接滚出来 dp 数组。

现在问题是：比如我先递归了重儿子，做下去，如果回溯回来的时候重链信息完全被滚坏了，轻儿子递归不了了。

然后你发现这是 naive 问题，先递归轻儿子就解决了，这不就是 dsu on tree 吗。（dsu on tree 是对于重链的静态链分治）

于是整个问题就解决了，时间复杂度 $\Theta(qV)$，空间复杂度 $\Theta(V \log q)$。

```cpp
#include <bits/stdc++.h>
#define X first
#define Y second
#define rep(i, a, b) for(int i = a; i <= b; i++)
#define pb push_back
using namespace std;
using ld = long double;
typedef unsigned long long int ll;
using pii = pair<int, int>;
constexpr int maxn = 2e4 + 10, mx = 1e5, B = 217, mod = 1e9 + 7;
const ll inf = 1145141919810520L;
vector<int> g[maxn]; int son[maxn], siz[maxn], w[maxn], c[maxn], ans[maxn], q, V, f[17][maxn];
void dfs1(int u) { siz[u] = 1; for (auto v : g[u]) dfs1(v), siz[u] += siz[v], (siz[v] > siz[son[u]] && (son[u] = v)); }
void dfs2(int u, int s, int t) {
	for (int i = 0; i <= V; i++) f[s][i] = max(f[t][i], i >= w[u] ? f[s][i - w[u]] + c[u] : 0), ans[u] = max(ans[u], f[s][i]);
	for (auto v : g[u]) if (v != son[u]) dfs2(v, s + 1, s); if (son[u]) dfs2(son[u], s, s);
}
char op[20]; int st[maxn], id[maxn], top, tot;
int main() {
	scanf("%d%d", &q, &V); 
	for (int i = 1; i <= q; i++) {
		scanf("%s", op);
		if (op[0] == 'a') st[++top] = ++tot, scanf("%d%d", &w[tot], &c[tot]), (top - 1 && (g[st[top - 1]].pb(tot), 0));
		else --top;
		if (top) id[i] = st[top]; 
	}
	for (int i = 1; i <= tot; i++) if (!siz[i]) dfs1(i), dfs2(i, 1, 0);
	for (int i = 1; i <= q; i++) printf("%d\n", ans[id[i]]);
	return 0;
}
```

---

## 作者：Nuyoah_awa (赞：0)

### 题目大意

按照 dfs 序给出一个森林，对于每个结点，求根节点到这个点的路径上所有物品做完全背包的最大价值。

### 题目分析

首先来想暴力，由于每个点到根节点的路径是唯一的，所以每个点的背包都可以由父亲的值继承下来。

所以暴力 dp 即可，时间复杂度是 $\mathcal O(q \times V)$ 的。

但是紫题怎么可能这么简单……

仔细一想发现空间复杂度不太对，因为每个点都开一个 dp 数组也是 $(q \times V)$ 的。

然后就想能否把这个空间降下去。想到完全背包优化空间就是将数组滚动起来，从而降掉一维，但是考虑到这道题每个 dp 状态组都可能有很多个后继状态，所以不可能单纯滚动，但是延续思想就是将一些状态用重复用一部分数组。

然后就想到了树剖的思想和部分结论，重链剖分中，每条路径都至多被划分为 $\log n$ 个重链，所以理论上我们只需要开 $\log n$ 维的 dp 数组即可。

具体实现就是对于每个节点，首先留下一棵子树，对于其他每一棵子树新开一维继续做 dp，然后会发现，对于一棵子树都做完 dp 后，新开的这一维以及之后的维都没有用了（即不会再产生后继状态了），所以其他子树也可以用刚开的这一维继续 dp，对于最开始剩的那一棵子树，我们发现当前这一维也已没用，这棵子树用这一维继续 dp 即可。方便起见，这课留下的子树都留重子节点即可（其他节点也行，这样好写）。

所以空间复杂度是 $(V \log q)$ 的，时间仍是 $\mathcal O(q\times V)$。

ps：注意，有可能是森林，所以可能要 dfs 多次。

### code
```cpp
#include <iostream>
#include <cstdio>
#include <vector>

using namespace std;

const int N = 1e5 + 5;
int n, v, sz[N], fa[N], hs[N], dfsid, vol[N], val[N], now, f[20][N], g[N], id[N];
string opt;
bool cnt[N];
vector <int> e[N];

void dfs1(int x)
{
    sz[x] = cnt[x] = 1;
    for(int i = 0;i < e[x].size();i++)
    {
        if(e[x][i] == fa[x]) continue;
        dfs1(e[x][i]);
        sz[x] += sz[e[x][i]];
        if(sz[e[x][i]] > sz[hs[x]]) hs[x] = e[x][i];
    }
}

void dfs2(int x, int y, int lst)
{
    for(int i = 0;i <= v;i++)
    {
    	f[y][i] = f[lst][i];
    	if(i >= vol[x])
    		f[y][i] = max(f[y][i], f[y][i-vol[x]] + val[x]);
    	g[x] = max(g[x], f[y][i]);
	}
    for(int i = 0;i < e[x].size();i++)
    {
        if(e[x][i] == fa[x] || e[x][i] == hs[x]) continue;
        dfs2(e[x][i], y+1, y);
    }
    if(hs[x])
    	dfs2(hs[x], y, y);
}

int main()
{
	scanf("%d %d", &n, &v);
	for(int i = 1;i <= n;i++)
	{
		cin >> opt;
		if(opt == "add")
		{
			fa[++dfsid] = now;
			now = dfsid;
			e[fa[now]].push_back(now);
			scanf("%d %d", &vol[now], &val[now]);
		}
		else if(opt == "erase")
		{
			now = fa[now];
		}
		id[i] = now;
	}
	for(int i = 1;i <= dfsid;i++)
		if(!cnt[i])
			dfs1(i), dfs2(i, 1, 0);
	for(int i = 1;i <= n;i++)
		printf("%d\n", g[id[i]]);
	return 0;
}
```

---

## 作者：_Yonder_ (赞：0)

先把每个添加操作和前一个添加操作建边，然后重链剖分。

我们需要实现一个 ```dfs2(a,b,now)```，它的操作是用 $f[a][1\thicksim V]$ 更新 $f[b][1\thicksim V]$，其中 $f[b][V]$ 就是增加了 $now$ 这个物品的答案。然后先遍历每个轻儿子 $I$，```dfs2(a,a+1,I)```。对于重儿子 $son$，则 ```dfs2(a,a,son)```。

最坏情况下的时间复杂度 $O(Vq)$，和空间复杂度 $O(V\log q)$。

# Code
```
#include<bits/stdc++.h>
using namespace std;
const int N=2e4+5;
int from[N],to[N<<1],I[N<<1],L666;
void Add(int x,int y){to[++L666]=from[x];I[L666]=y;from[x]=L666;}
int q,V,id[N],x[N],y[N],sz[N],son[N],out[N],f[15][N];
stack<int> s;char ch[5];bool F[N];
void dfs1(int now){
	sz[now]=1;F[now]=1;
	for(int i=from[now];i;i=to[i])
		dfs1(I[i]),sz[now]+=sz[I[i]],
		son[now]=sz[I[i]]>sz[son[now]]?I[i]:son[now];
}
void dfs2(int a,int b,int now){
	if(a^b) for(int i=1;i<=V;i++) f[a][i]=f[b][i];
	for(int i=x[now];i<=V;i++) f[a][i]=max(f[a][i],f[a][i-x[now]]+y[now]);
	out[now]=f[a][V];
	for(int i=from[now];i;i=to[i])
		if(I[i]^son[now]) dfs2(a+1,a,I[i]);
	if(son[now]) dfs2(a,a,son[now]);
}
int main(){
	scanf("%d%d",&q,&V);
	for(int i=1;i<=q;i++){
		scanf(" %s",ch);
		if(ch[0]=='a'){
			scanf("%d%d",&x[i],&y[i]);
			if(s.size()) Add(s.top(),i);
			s.push(i);
		}else F[i]=1,s.pop();
		if(s.size()) id[i]=s.top();
	}
	for(int i=1;i<=q;i++) if(!F[i]) dfs1(i),dfs2(1,0,i);
	for(int i=1;i<=q;i++) printf("%d\n",out[id[i]]);
    return 0;
}
```

---

## 作者：AIskeleton (赞：0)

### 题意：

给定一个序列和大小为 $V$ 的背包，和 $q$ 次操作，操作有两种。

1. 增加一种体积为 $x$,价值为 $y$ 的物品在序列末尾。
2. 删除序列末尾的物品。

每种物品有无限多个，求每次操作后背包所能装下的最大价值。

### 题解：
设题目中给出 $n$ 种物品。

题目可以看成是按照时间顺序给出了一棵树，树上的每个点具有相应的价值和体积，每次操作相当于把某个节点到根的路径上所有节点取出然后跑树上背包。

此时的最坏情况就是树为一条链，此时的时间复杂度是 $O(qn)$，空间复杂度为 $O(Vn)$。

空间复杂度明显超限，所以要对其进行优化。

因为路径只是从根节点到某个节点，所以可以采用轻重链剖分的方式优化复杂度。对于每一条重链开一个数组，因为每个节点到根节点最多有 $\log n$ 条重链，所以空间复杂度就是 $O(V\log n)$，可以通过此题。

每次操作时处理当前重链上的背包，并与上一次的背包合并。

具体细节看代码。

### 代码：
```
#include <bits/stdc++.h>
using namespace std;
const int N=2e5,INF=2e9;string sg;stack <int> s;
int n,m,q,vis[N],fir[N],dfn[N],cnt,tot,fa[N],si[N],d[N],h[N],t[N],id[N],di[N],a[N],b[N],ans[N],dp[20][N];
struct edge{int v,nt;}e[N<<1];struct cb{int u,v;}c[N<<1];
void into(int u,int v){e[++cnt].v=v;e[cnt].nt=fir[u];fir[u]=cnt;}
void dfs1(int u,int f){
    si[u]=vis[u]=1;fa[u]=f;
    for(int i=fir[u];i;i=e[i].nt)
	if(e[i].v!=f){
            dfs1(e[i].v,u);si[u]+=si[e[i].v];
	    if(si[e[i].v]>si[h[u]])h[u]=e[i].v;
	}
}void dfs2(int d,int l,int x){
    for(int i=0;i<=m;i++){
	dp[d][i]=dp[l][i];
	if(i>=c[x].u)dp[d][i]=max(dp[d][i],dp[d][i-c[x].u]+c[x].v);
	ans[x]=max(ans[x],dp[d][i]);
    }for(int i=fir[x];i;i=e[i].nt)if(e[i].v!=fa[x]&&e[i].v!=h[x])dfs2(d+1,d,e[i].v);if(!h[x])return ;dfs2(d,d,h[x]);
}int main(){
    cin>>q>>m;
    for(int i=1;i<=q;i++){
	cin>>sg;if(sg[0]=='a'){n++;cin>>c[n].u>>c[n].v;if(!s.empty())into(s.top(),n);s.push(n);}
	else	s.pop();if(!s.empty())	dfn[i]=s.top();
    }for(int i=1;i<=n;i++)if(!vis[i])	dfs1(i,0),dfs2(1,0,i);
    for(int i=1;i<=q;i++)cout<<ans[dfn[i]]<<endl;return 0;
}
```

---


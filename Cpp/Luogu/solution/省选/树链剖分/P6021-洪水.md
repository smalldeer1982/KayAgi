# 洪水

## 题目描述

小 A 走到一个山脚下，准备给自己造一个小屋。这时候，小 A 的朋友（`op`，又叫管理员）打开了创造模式，然后飞到山顶放了格水。于是小 A 面前出现了一个瀑布。作为平民的小 A 只好老实巴交地爬山堵水。那么问题来了：我们把这个瀑布看成是一个 $n$ 个节点的树，**其中树根为 $1$，** 每个节点有权值（爬上去的代价）。小 A 要选择一些节点，以其权值和作为代价将这些点删除（堵上），使得根节点与所有叶子结点不连通。问最小代价。不过到这还没结束。小 A 的朋友觉得这样子太便宜小 A 了，于是他还会不断地修改地形，使得某个节点的权值发生变化。不过到这还没结束。小 A 觉得朋友做得太绝了，于是放弃了分离所有叶子节点的方案。取而代之的是，每次他只要在某个子树中（和子树之外的点完全无关）。于是他找到你。

## 说明/提示

$1 \leq n \leq 200000,1 \leq fr,to \leq n,1 \leq x \leq n$，权值和 $t$ 均在 `int` 范围内且非负。

BZOJ4712

## 样例 #1

### 输入

```
4
4 3 2 1
1 2
1 3
4 2
4
Q 1
Q 2
C 4 10
Q 1```

### 输出

```
3
1
4```

# 题解

## 作者：Rusalka (赞：13)

## 题意

- 给定一棵有 $n$ 个结点的树，点有点权；一共有 $m$ 次操作，每次操作包括以下两种：  
1. 在一个点的子树中删去一些结点，使得该子树中所有叶结点与该子树的根结点不连通，并且使删去的点的点权和最小，求出这个最小值。
2. 修改一个点的点权。

- $n \le 2 \times 10^5$ ，$m$ 与 $n$ 同级 （题目中没有说明QAQ）

## 题目分析

~~显然是动态 DP。~~

~~据说这题珂以线段树二分但是我太蒻只会暴力 DDP~~

虽然题目中没有说明，但是这棵树以 $1$ 号结点为根。  

如果没有修改操作，这是一道简单的树形动规。  

首先考虑没有修改操作的情况。  

记 $w_u$ 表示点 $u$ 的权值， $f_u$ 表示以 $u$ 为根的子树的最小答案。  
那么显然有   
$$ f_u = \min(w_u,\ \sum \limits _{v\in son_u} f_v) $$   
方程的意义为：要么删去结点 $u$ ，要么不删去结点 $u$ ，在结点 $u$ 的孩子中删去结点，两者取最小。 

特殊的，对于叶结点，$f_u = w_u$ 。  

然后考虑修改点权的操作。  

注意到每次修改点权只会对该结点到根的路径上的 $f$ 值产生影响。  
所以每次修改时暴力从该结点一直修改到 $1$ 号结点。  
最坏时间复杂度 $ \Theta (mn)$ ，稳稳地 TLE 。  

接下来就需要请出主角：动态 DP 了。  

## 动态 DP  

动态 DP 用于解决一类被套上修改点权操作的基础 DP 题目。 

其主要思想就是利用线段树维护每个结点的 DP 值。  

但是由于大多数状态转移方程不满足结合律，所以无法直接使用线段树维护。  

但是我们知道矩阵乘法运算是满足结合律的。   

所以我们就需要把状态转移方程用矩阵乘法的形式表达出来。  

~~模板题相信大家都过了。~~  
不会动态 DP 的同学可以先去写一下[这道模板题](https://www.luogu.com.cn/problem/P4719)，里面的题解介绍的很详细。  

## 构造矩阵

~~终于回到这题了。~~  

让我们再来玩一玩刚才的状态转移方程。  

$$ f_u = \min(w_u,\ \sum \limits _{v\in son_u} f_v) $$

由于这是一棵树，所以先对它进行重链剖分，然后 ~~按照套路~~ 把轻儿子的答案的总和拎出来；也就是说，记 $g_u$ 表示以 $u$ 为根的子树中轻儿子的答案总和，则可以将原方程转化为：  

$$ f_u = \text{min}(w_u,\ f_{son_u}+g_u) $$

然后考虑把这个方程转化为矩阵乘法的形式。  

在这里，我们需要重新定义一下矩阵乘法：对于矩阵 $A$ ，$B$ ，若矩阵 $C$ 满足 $C=A*B$ ，则有：  

$$ C_{i,j}=\min \limits _k (A_{i,k}+B_{k,j}) $$  

至于这个运算为什么满足结合律，请读者自行验证。  

那么我们相当于要找到一个转移矩阵 $U$ ，使得 ：

$$ \begin{pmatrix} f_{son_u} \\ 0 \end{pmatrix} * U = \begin{pmatrix} f_{u} \\ 0 \end{pmatrix}$$

注意新定义的矩阵乘法不满足交换律。~~说的好像原来的矩阵乘法满足交换律一样。~~  

首先 $U$ 是一个 $2 \times2$ 的矩阵。  
根据新定义的矩阵乘法，可以得出：  

1. $f_u=\min(f_{son_u}+U_{1,1}, 0+U_{1,2})$  

2. $0 = \min(f_{son_u}+U_{2,1}, 0+U_{2,2})$  

再结合原方程，即可得出

$$ \begin{pmatrix} f_{son_u} \\ 0 \end{pmatrix} 
* \begin{pmatrix} g_u & w_u \\ \infty & 0 \end{pmatrix}
= \begin{pmatrix} f_{u} \\ 0 \end{pmatrix}$$

然后用线段树维护转移矩阵就可以了。  

在实现时我使用了一个矩阵数组来记录转移矩阵，听说这样可以减常数。

另外由于我太蒻了，写的树剖常数大，所以这份代码需要吸氧才能通过。

## Code

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>

using namespace std;

typedef long long ll;
const int MAXN = 200010;
const ll INF = 1e17+1;

int n, m;;

struct edge{
	int ne, to;
}e[MAXN<<1];
int fir[MAXN], num = 0;
inline void join(int a, int b)
{
	e[++num].ne = fir[a];
	fir[a] = num;
	e[num].to = b;
}

struct mat{
	ll ele[2][2];
	mat(int type = 0)
	{
		for(int i=0;i<2;i++)
			for(int j=0;j<2;j++)
				ele[i][j] = INF;
		if(type == 1) {
			for(int i=0;i<2;i++)
				ele[i][i] = 0;
		}
	}
	ll& operator()(const int ix, const int iy){return ele[ix][iy];}
    // 重定义的矩阵乘法
	inline friend mat operator*(mat mx, mat my)
	{
		mat res(0);
		for(int i=0;i<2;i++)
			for(int k=0;k<2;k++)
				for(int j=0;j<2;j++)
					res(i,j)=min(res(i,j), mx(i,k)+my(k,j));
		return res;
	}
};

ll val[MAXN], f[MAXN];
mat g[MAXN];

int dep[MAXN], pa[MAXN], siz[MAXN], son[MAXN], top[MAXN], dfn[MAXN], rev[MAXN], end[MAXN], cnt = 0;

void dfs1(int u, int fa)
{
	siz[u] = 1; dep[u] = dep[fa] + 1; pa[u] = fa;
	for(int i=fir[u];i;i=e[i].ne)
	{
		int v = e[i].to;
		if(v == fa) continue;
		dfs1(v, u);
		siz[u] += siz[v];
		if(siz[son[u]] < siz[v]) son[u] = v;
	}
}
void dfs2(int u, int t)
{
	dfn[u] = ++cnt; rev[cnt] = u; top[u] = t; end[t] = max(end[t], cnt);
	g[u](0, 0) = 0;   g[u](0, 1) = val[u];
	g[u](1, 0) = INF; g[u](1, 1) = 0;
	f[u] = 0;
	if(son[u]) {
		
		dfs2(son[u], t);
		f[u] += f[son[u]];
	}
	else g[u](0, 0) = INF; //为了保证叶结点转移的合法
	for(int i=fir[u];i;i=e[i].ne)
	{
		int v = e[i].to;
		if(v == pa[u] || v == son[u]) continue;
		dfs2(v, v);
		g[u](0, 0) += f[v]; //g 数组的转移不包括重儿子
		f[u] += f[v];
	}
	if(!son[u]) f[u] = val[u]; // 特判叶结点
	else f[u] = min(f[u], val[u]); // 记得两者取最小
}
struct {
	int l, r;
	mat val;
}t[MAXN<<2];
inline void pushUp(int k)
{
	t[k].val = t[k<<1].val*t[k<<1|1].val;
}
void build(int l, int r, int k)
{
	t[k].l = l; t[k].r = r;
	if(l == r) {
		t[k].val = g[rev[l]];
		return ;
	}
	int mid = t[k].l+t[k].r>>1;
	build(l, mid, k<<1);
	build(mid+1, r, k<<1|1);
	pushUp(k);
}
void update(int x, int k)
{
	if(t[k].l == t[k].r) {
		t[k].val = g[rev[x]]; //由于有在树外记录转移矩阵，直接赋值即可
		return ;
	}
	int mid = t[k].l+t[k].r>>1;
	if(x <= mid) update(x, k<<1);
	else update(x, k<<1|1);
	pushUp(k);
}
mat query(int x, int y, int k)
{
	if(t[k].l == x && t[k].r == y) return t[k].val;
	int mid = t[k].l+t[k].r>>1;
	if(y <= mid) return query(x, y, k<<1);
	else if(x >= mid+1) return query(x, y, k<<1|1);
	else return query(x, mid, k<<1)*query(mid+1, y, k<<1|1);
}
inline void updatePath(int x, ll z)
{
	val[x] += z;
	g[x](0, 1) = val[x];
	mat bef, aft;
	while(x)
	{
		bef = query(dfn[top[x]], end[top[x]], 1);
        // 记录更新之前的矩阵
		update(dfn[x], 1);
		aft = query(dfn[top[x]], end[top[x]], 1);
		x = pa[top[x]];
		g[x](0, 0) += min(aft(0, 0), aft(0, 1)) - min(bef(0, 0), bef(0, 1)); 
        // 更新转移矩阵，为下一条链的修改做准备，注意这里需要先减去原先的值
	}
}
inline ll querySubtree(int x)
{
	mat res = query(dfn[x], end[x], 1); // 查询时只需要从当前点到链尾即可
	return min(res(0, 0), res(0, 1));
}

int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
		scanf("%lld",&val[i]);
	for(int i=1;i<n;i++)
	{
		int a, b;
		scanf("%d%d",&a,&b);
		join(a, b);
		join(b, a);
	}
	dfs1(1, 0);
	dfs2(1, 1);
	for(int i=1;i<=n;i++)
		end[i] = end[top[i]];
	build(1, n, 1);
	scanf("%d",&m);
	while(m--)
	{
		char opt; int x; ll z;
		cin>>opt;
		if(opt == 'C') {
			scanf("%d%lld",&x,&z);
			updatePath(x, z);
		}
		else {
			scanf("%d",&x);
			printf("%lld\n",querySubtree(x));
		}
	}
	return 0;
}
```


---

## 作者：一念之间、、 (赞：12)

全是ddp？

表示不会ddp，这里介绍一种不用ddp的维护方法

首先我们还是可以推出一个`naive`的式子 

### $f[x]=\min(val[x],\Sigma{f[to]})$

将前一项称作$val$,后一项称作$\Sigma$

首先发现更新方式是对一个点加，我们来考虑更新一个点的$val$对所以f到底有什么影响。

对于更新`a`这个点来说，将a的val变大可能会导致$f[a]$从选择$val$变成选择$\Sigma$

而对于`a`到根这一条链上来说下面的更新val会导致上面增加$\Sigma$的值从而让（`b`在这条链上）$f[b]$从选择$\Sigma$变成选择$val$

发现对于`a`这个点，我们可以暴力的更新维护他的代价，一段连续的选择$\Sigma$的点可以用线段树进行区间加，考虑暴力的对每一段不连续的来处理。

发现只有在初始值或者更新某个点的$val$时会使得$f$选择$\Sigma$，一共有$n+m$次选择$\Sigma$的机会

每次我们从a向上更新的时候会改动一些$\Sigma$的值，让$\Sigma$变回$val$这样的次数同样只有$n+m$次

所以我们可以对于每一个不连续更新的点停留，并重新更新答案，考虑如何找到最深的一个不连续的点，发现只要$dlt>val-\Sigma$时，这个点就会变成不连续的点，考虑线段树二分即可。

所以我们线段树一共需要维护两个值，一个是$\Sigma$另一个是$val-\Sigma$同时维护`addtag`在连续段进行区间操作

至此，我们在没用`ddp`的情况下做出来了这个题（跑得挺快，没卡常数目前`rk2`）

细节较多，建议看代码实现

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int read()
{
	char c;
	int w=1;
	while((c=getchar())>'9'||c<'0')if(c=='-')w=-1;
	int ans=c-'0';
	while((c=getchar())>='0'&&c<='9')ans=(ans<<1)+(ans<<3)+c-'0';
	return ans*w;
}
int n;
const int xx=2e5+5;
struct node
{
	int next,to;
}e[xx<<1];
int cnt;
int h[xx];
void add(int x,int y)
{
	cnt++;
	e[cnt].next=h[x];
	h[x]=cnt;
	e[cnt].to=y;
}
int f[xx],top[xx],size[xx],son[xx],dep[xx];
ll dp[xx],sig[xx],val[xx];
void dfs(int x,int y)
{
	dep[x]=dep[y]+1;
	f[x]=y;
	size[x]=1;
	int maxx=-1;
	ll sum=1e18;
	for(int i=h[x];i;i=e[i].next)
	{
		if(e[i].to==y)continue;
		dfs(e[i].to,x);
		if(sum==1e18)sum=0;
		sum+=dp[e[i].to];
		size[x]+=size[e[i].to];
		if(maxx<size[e[i].to])maxx=size[e[i].to],son[x]=e[i].to;
	}
	sig[x]=sum;
	dp[x]=min(val[x],sum);
}
int dfx[xx],id[xx],cst;
void dfss(int x,int y)
{
	top[x]=y;
	dfx[x]=++cst;
	id[cst]=x;
	if(!son[x])return;
	dfss(son[x],y);
	for(int i=h[x];i;i=e[i].next)
	{
		if(e[i].to==f[x]||e[i].to==son[x])continue;
		dfss(e[i].to,e[i].to);
	}
}
ll ad[xx<<2],minv[xx<<2];//minv就是val-sigma
void update(int k)//只会询问一条重链的情况，所以不考虑上面也行
{
	if(minv[k<<1]<minv[k<<1|1])minv[k]=minv[k<<1];//尽量选择dfx靠后的点 
	else minv[k]=minv[k<<1|1];
}
void pd(int k)
{
	if(!ad[k])return;
	ad[k<<1]+=ad[k];
	minv[k<<1]-=ad[k];
	ad[k<<1|1]+=ad[k];
	minv[k<<1|1]-=ad[k];
	ad[k]=0;
}
ll ask(int k,int l,int r,int x)//返回这个点的sigma值
{
	if(l==r)return ad[k];
	pd(k);
	int mid=l+r>>1;
	if(x<=mid)return ask(k<<1,l,mid,x);
	else return ask(k<<1|1,mid+1,r,x);
}
void build(int k,int l,int r)
{
	if(l==r)return ad[k]=sig[id[l]],minv[k]=val[id[l]]-ad[k],void();//minn
	int mid=l+r>>1;
	build(k<<1,l,mid);
	build(k<<1|1,mid+1,r);
	update(k);
}
ll askp(int k,int l,int r,int x)
{
	if(l==r)return minv[k];
	pd(k);int mid=l+r>>1;
	if(x<=mid)return askp(k<<1,l,mid,x);
	return askp(k<<1|1,mid+1,r,x);
}
void change(int k,int l,int r,int x,int y,int z)
{
	if(x>y)return;
	if(x<=l&&r<=y)return ad[k]+=z,minv[k]-=z,void();
	pd(k);int mid=l+r>>1;
	if(x<=mid)change(k<<1,l,mid,x,y,z);
	if(mid<y)change(k<<1|1,mid+1,r,x,y,z);
	update(k);
}
void change(int k,int l,int r,int x)
{
	if(l==r)return minv[k]=val[id[l]]-ad[k],void();
	pd(k);int mid=l+r>>1;
	if(x<=mid)change(k<<1,l,mid,x);
	else change(k<<1|1,mid+1,r,x);
	update(k);
}
int erf(int k,int l,int r,int x,int y,ll z)
{
	if(x<=l&&r<=y)
	{
		if(minv[k]>z)return l-1;
	}
	if(l==r)return l;//上面已经判断过不合法了  
	pd(k);
	int mid=l+r>>1;
	if(mid<x)return erf(k<<1|1,mid+1,r,x,y,z);
	if(y<=mid)return erf(k<<1,l,mid,x,y,z);
	int s=erf(k<<1|1,mid+1,r,x,y,z);
	if(s!=mid)return s;
	return erf(k<<1,l,mid,x,y,z);
}
void jump(int x,ll y)
{
	if(!x||!y||y<0)return;
	int s=erf(1,1,n,dfx[top[x]],dfx[x],y);
	if(s!=dfx[top[x]]-1)//线段树上二分找到一个小于y的最靠右的一个点 
	{
		ll p=askp(1,1,n,s);
		change(1,1,n,s,dfx[x],y);
		jump(f[id[s]],p);//根据势能分析，这种点只会有m+n个 
	}
	else 
	{
		change(1,1,n,dfx[top[x]],dfx[x],y);
		jump(f[top[x]],y);
	}
}
signed main(){
//	freopen("a.in","r",stdin);
//	freopen("a.out","w",stdout);
	n=read();
	for(int i=1;i<=n;i++)val[i]=read();
	for(int i=1;i<n;i++)
	{
		int a,b;
		a=read();
		b=read();
		add(a,b);
		add(b,a);
	}
	dfs(1,0);
	dfss(1,1);
	build(1,1,n);
	int m=read();
	for(int i=1;i<=m;i++)
	{
		char s;
		while((s=getchar())!='Q'&&s!='C');
		if(s=='Q')
		{
			int a=read();
			cout<<min(val[a],ask(1,1,n,dfx[a]))<<"\n";
		}
		else
		{
			int a,b;
			a=read();
			b=read();
			ll s=ask(1,1,n,dfx[a])-val[a];//如果超过了这个数，就用sigma，否则用val 
			val[a]+=b;
			change(1,1,n,dfx[a]);
			jump(f[a],min(1ll*b,s));
		}
	}
	return 0;
}
```


---

## 作者：f_hxr_ (赞：9)

~~萌新刚学 DDP 正好发一下题解~~

## 题意

给定一颗以 $1$ 号结点为根的有根树。每个点都有一个权值 $val_i$。删去一个点的代价也是 $val_i$。每次询问给出一个 $u$，问你：在 $u$ 的子树内删去若干点使得 $u$ 的子树内的每一个叶子都无法到达 $u$，求最小代价是多少。

**允许把 $u$ 和叶子结点删掉。**

**修改是将点权增加而不是重新设置。**

## 分析

我们定义 $f_u$ 为：删除 $u$ 子树内的若干结点，使得 $u$ 的每个叶子无法到达 $u$ 的最小代价。

则：

$$ f_u = \min(val_u,\sum_{v \in son_u}f_v) $$

特别地，当 $u$ 为叶子结点时，令 $f_u = val_u$。

题目中要求修改，考虑 DDP。~~我太蒟蒻了不会线段树二分~~

将式子的 $\sum$ 部分展开成轻儿子和重儿子两部分：

$$ f_u = \min(val_u,\sum_{v \in lingtson_u}f_v + f_{heavyson}) $$

然后令 $g_u = \sum_{v \in lingtson_u}f_v$，就有：

$$ f_u = \min(val_u,g_u + f_{heavyson}) $$

尝试将其改为矩阵乘法的形式，定义广义矩阵乘法 $C=A*B$ 为：

$$C_{i,j}=\min_{k}(A_{i,k}+B_{k,j})$$

将刚才的式子改写广义矩阵乘法的形式，就有：

$$ \begin{bmatrix} 
 g_u & val_u\\
   0 &     0 
\end{bmatrix}

*

\begin{bmatrix}
f_{heavyson}\\
0
\end{bmatrix}

=

\begin{bmatrix}
f_u\\
0
\end{bmatrix}

$$

最后再用线段树维护下矩阵连乘积就行了。

还有一个需要注意的是，程序实现上叶子结点存的矩阵是 $2 \times 2$ 而不是 $ 2 \times 1 $ 的，叶子结点 $u$ 的矩阵的**左上角**一定要是 $f_u$，即 $val_u$。至于其地方我没怎么试。~~不过至少右上角可以是 $114514$。~~

就像这样：

$$
\begin{bmatrix}
f_{leaf}& 114514\\
0 & 0
\end{bmatrix}
$$

为了方便修改，我在线段树外也用了一个额外的数组存每个结点的转移矩阵，详情看[代码](https://www.luogu.com.cn/record/141592014)。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL maxn=3e5+7;
const LL inf=1e9+7;
LL N,Q,f[maxn];
struct Matrix{
	LL dat[2][2];
	Matrix(){dat[0][0]=dat[0][1]=dat[1][0]=dat[1][1]=0;}
	void Set(LL aa,LL bb,LL cc,LL dd){dat[0][0]=aa;dat[0][1]=bb;dat[1][0]=cc;dat[1][1]=dd;}
	void PRT(){//DeBug
    	putchar('\n');
    	cout<<dat[0][0]<<' '<<dat[0][1]<<endl;
    	cout<<dat[1][0]<<' '<<dat[1][1]<<endl;
	}
}M[maxn];
Matrix operator*(const Matrix &A,const Matrix &B){
	Matrix ret;
	ret.dat[0][0]=min(A.dat[0][0]+B.dat[0][0],A.dat[0][1]+B.dat[1][0]);
	ret.dat[0][1]=min(A.dat[0][0]+B.dat[0][1],A.dat[0][1]+B.dat[1][1]);	
	ret.dat[1][0]=min(A.dat[1][0]+B.dat[0][0],A.dat[1][1]+B.dat[1][0]);	
	ret.dat[1][1]=min(A.dat[1][0]+B.dat[0][1],A.dat[1][1]+B.dat[1][1]);	
return ret;}
struct SegmentTree{
	LL ls[maxn<<1],rs[maxn<<1],root=1,tot=1;
	Matrix DAT[maxn<<1];
	void pushup(LL p){DAT[p]=DAT[ls[p]]*DAT[rs[p]];}
	void pushdown(LL p){if(!ls[p])ls[p]=++tot;if(!rs[p])rs[p]=++tot;}
	void ModifyPoint(LL p,LL L,LL R,LL inx,LL aa,LL bb,LL cc,LL dd){
		if(L>=R){
			DAT[p].dat[0][0]=aa;DAT[p].dat[0][1]=bb;
			DAT[p].dat[1][0]=cc;DAT[p].dat[1][1]=dd;
		return;}
		pushdown(p);LL mid=(L+R)>>1;
		if(inx<=mid)ModifyPoint(ls[p],L,mid,inx,aa,bb,cc,dd);
		else ModifyPoint(rs[p],mid+1,R,inx,aa,bb,cc,dd);
	pushup(p);}
	void ModifyPoint(LL inx,LL aa,LL bb,LL cc,LL dd){ModifyPoint(root,1,N,inx,aa,bb,cc,dd);}
	Matrix QueryRange(LL p,LL L,LL R,LL ql,LL qr){
		if(ql<=L&&R<=qr)return DAT[p];
		pushdown(p);LL mid=(L+R)>>1;
		if(qr<=mid)return QueryRange(ls[p],L,mid,ql,qr);
		if(ql>=mid+1)return QueryRange(rs[p],mid+1,R,ql,qr);
		return QueryRange(ls[p],L,mid,ql,qr)*QueryRange(rs[p],mid+1,R,ql,qr);
		
	}
	Matrix QueryRange(LL ql,LL qr){return QueryRange(root,1,N,ql,qr);}
};
struct ZLPF{
	LL head[maxn<<1],nxt[maxn<<1],to[maxn<<1],cnt_edge;
	LL dep[maxn],Fa[maxn],size[maxn],dfn[maxn],Hson[maxn],Hd[maxn],End[maxn],dfs_clock;
	LL A[maxn];
	SegmentTree SEG;
	void AddEdge(LL u,LL v){
		nxt[++cnt_edge]=head[u];to[cnt_edge]=v;head[u]=cnt_edge;
		nxt[++cnt_edge]=head[v];to[cnt_edge]=u;head[v]=cnt_edge;
	}
	void dfs1(LL u,LL v){
		Fa[u]=v;dep[u]=dep[v]+1;size[u]=1;
		for(LL i=head[u];i;i=nxt[i]){
			if(to[i]==v)continue;
			dfs1(to[i],u);size[u]+=size[to[i]];
			if(size[to[i]]>size[Hson[u]])Hson[u]=to[i];
		}
	}
	void dfs2(LL u,LL top){
		dfn[u]=++dfs_clock;Hd[u]=top;End[top]=dfn[u];
		M[u].dat[0][1]=A[u];
		if(!Hson[u]){f[u]=M[u].dat[0][0]=A[u];M[u].dat[0][1]=114514;return;}dfs2(Hson[u],top);
		for(LL i=head[u];i;i=nxt[i]){
			if(to[i]==Fa[u]||to[i]==Hson[u])continue;
			dfs2(to[i],to[i]);
			M[u].dat[0][0]+=f[to[i]];
		}
		f[u]=min(A[u],f[Hson[u]]+M[u].dat[0][0]);
	}
	void init(){
		scanf("%lld",&N);
		for(LL i=1;i<=N;i++)scanf("%lld",&A[i]);
		for(LL i=1;i<N;i++){LL a,b;scanf("%lld %lld",&a,&b);AddEdge(a,b);}
		dfs1(1,0);dfs2(1,1);
		for(int i=1;i<=N;i++)
			SEG.ModifyPoint(dfn[i],M[i].dat[0][0],M[i].dat[0][1],M[i].dat[1][0],M[i].dat[1][1]);
	}
	LL QueryOnTree(LL u){
		Matrix qwq=SEG.QueryRange(dfn[u],End[Hd[u]]);
		return qwq.dat[0][0];
	}
	void ModifyOnTree(LL u,LL xx){
		if(size[u]==1)M[u].dat[0][0]+=xx;
		M[u].dat[0][1]+=xx;A[u]+=xx;
		Matrix BFS,AFO;
		while(u){
			BFS=SEG.QueryRange(dfn[Hd[u]],End[Hd[u]]);
			SEG.ModifyPoint(dfn[u],M[u].dat[0][0],M[u].dat[0][1],M[u].dat[1][0],M[u].dat[1][1]);
			AFO=SEG.QueryRange(dfn[Hd[u]],End[Hd[u]]);
			u=Fa[Hd[u]];if(!u)break;
			M[u].dat[0][0]+=AFO.dat[0][0]-BFS.dat[0][0];
		}
	}
	void solve(){
		scanf("%lld",&Q);
		while(Q--){
			char op;LL u,xx;
			scanf(" %c",&op);
			if(op=='C'){scanf(" %lld %lld",&u,&xx);
				ModifyOnTree(u,xx);
			}else if(op=='Q'){scanf(" %lld",&u);
				printf("%lld\n",QueryOnTree(u));	
			}
		}
	}
}Tree;
int main(){ 
	Tree.init();
	Tree.solve();
	return 0;
}
```

---

## 作者：Daniel13265 (赞：7)

先吐槽一句，动态 DP 模板都是黑题，这题和[这题](https://www.luogu.com.cn/problem/P3781)能是紫的？

同时建议在题目中填加权值范围：所有输入在 $32$ 位有符号整数最大值范围以内。

# 前置知识

- **动态 DP**

这是一道动态 DP 题目，如果你学过动态 DP 相关知识，可以很容易从树形 DP 的形式 + 带修改两点看出来。

- **全局平衡二叉树**

本文主要介绍的是**全局平衡二叉树子树查询**的操作，在阅读本篇题解之前，请确保你会使用全局平衡二叉树来优化树上动态的动态规划问题。

如果你不会以上知识点请左转模板区：~~（空格不统一差评）~~

[P4719 【模板】"动态 DP"&动态树分治](https://www.luogu.com.cn/problem/P4719)

[P4751 【模板】"动态DP"&动态树分治（加强版）](https://www.luogu.com.cn/problem/P4751)


# 题意

给一棵树，点有点权，需要支持：
1. 查询忽略以给定结点为根的最大子树外的所有结点后选择剩余的若干结点并以其权值和作为代价将其删除且能使该子树的根结点与所有叶子结点均不连通的最小代价；
2. 修改某一个结点的权值。

# 分析

在从 DP 和带修这两点看出来这道题可以使用动态 DP 后，可以根据套路，先列出无修改操作时的 DP 式：

$$f_x=\min(val_x,\sum_{i\in son_x}f_i)$$

然后把 $\sum_{i\in son_x}f_i$ 分成轻重儿子，即设

$$g_x=\sum_{\scriptsize\begin{gathered}i\neq hson_x\\i\in son_x\end{gathered}}f_i$$

则有

$$f_x=\min(val_x,g_x+f_{hson_x})$$

特别地，如果 $son_x=\varnothing$，则令 $g_x=\infty$ 来避免后面那种情况的转移。

写成广义矩阵乘法的形式，有

$$\left(\begin{matrix}g_x&val_x\\0&0\end{matrix}\right)\times\left(\begin{matrix}f_{hson_x}\\0\end{matrix}\right)=\left(\begin{matrix}f_x\\0\end{matrix}\right)$$

注意到这里的乘法是相加取 $\min$ 而不是像模板那样相加取 $\max$。

于是 $g_x$ 暴力上传，再用全局平衡二叉树维护一下 $\left(\begin{matrix}g_x&val_x\\0&0\end{matrix}\right)$ 在重链上的连乘积就可以了。

可是发现一个问题：由于模板是询问一整棵树，所以可以直接使用全局平衡二叉树树根的矩阵的值；然而这道题要询问子树，那咋办哪？

观察全局平衡二叉树的性质，发现对于去掉虚边的每一棵子树，它前序遍历的结果就是原树上由浅到深的一条重链。那么，我们需要查询的实际上就是前序遍历的一个后缀所对应的矩阵的乘积，也就是查询结点所在二叉树上靠右的一部分。

于是，我们可以用类似线段树的形式：若查询结点在所在全局平衡二叉树当前子树的右子树内，则递归进入右子树；若为当前结点，则直接返回当前结点的矩阵乘以右子树的连乘矩阵；否则左子树递归查询，然后返回与当前结点的矩阵与右子树的连乘矩阵的乘积即可。写成代码不难：

```cpp
// w 代表该结点对应的矩阵，mul 代表结点所在子树的矩阵连乘积，dep 代表结点在原树中的深度
// lc 代表在全局平衡二叉树上的左儿子，rc 代表在全局平衡二叉树上的右儿子
// rt 代表当前遍历到的结点，x 代表查询的结点
mat query(const int &rt, const int &x) {
  // rt 的深度小于 x 的深度说明 x 在 rt 的右子树内
  // 因为前序遍历是由浅到深的，也就是说这种情况 rt 在 x 前面
  // 可以画图理解
  if (dep[rt] < dep[x]) return query(rc[rt], x);
  if (rt == x) return w[rt] * mul[rc[x]];
  return query(lc[rt], x) * w[rt] * mul[rc[rt]];
}
```

由于全局平衡二叉树的总深度是 $\mathcal O(\log n)$ 的，所以显然去掉虚边后的每一棵二叉树的深度上界是 $\mathcal O(\log n)$ 的，只有一条重链时达到最坏情况，因此这个查询的复杂度是 $\mathcal O(\log n)$ 的，与修改复杂度相同。

那么我们最终就能够在 $\mathcal O(n+m\log n)$ 的时间内解决这个问题，复杂度吊打树链剖分，常数吊打 LCT。目前这个方法无论是否打开 O2 优化都可以拿到本题提交记录 Rank1。

# 一个小优化

注意到

$$\left(\begin{matrix}a&b\\0&0\end{matrix}\right)\times\left(\begin{matrix}c&d\\0&0\end{matrix}\right)=\left(\begin{matrix}\min(a+c,b)&\min(a+d,b)\\0&0\end{matrix}\right)$$

因此在存储矩阵时只需要存储两个位置的值即可：

```cpp
struct mat {
  long long a00, a01;
  inline mat() : a00(0), a01(INF) {}
  inline mat(const long long &a00, const long long &a01) : a00(a00), a01(a01) {}
  friend inline mat operator *(const mat &x, const mat &y) {
    return mat(min(x.a00 + y.a00, x.a01), min(x.a00 + y.a01, x.a01));
  }
}
```

---

## 作者：iostream (赞：3)

这是一道动态 dp 的题目，dp 的矩阵上一篇题解已经说的很详细了，我这里给出 Link-cut-tree 维护这个动态 dp 的写法。

用 LCT 维护这个有根树，对于一个修改操作，我们需要先进行 $\text{Access}(x)$ 和 $\text{Splay(x)}$ 操作，然后才能正确修改。

由于本题要查询一个子树的 dp 值，所以与动态 dp 模板题还有一定差别，需要先执行 $\text{Access}(fa_x)$ 操作，这样 $\text{Splay}(x)$ 以后 $x$ 下方只会包含自己子树中的节点，输出其 dp 值即可。

时间复杂度是 $O(n\log n)$ ~~但是打不过树链剖分~~。

```cpp
#include<cstdio>
#include<vector>
#include<cstring>
#define DP(x) (Min(f[x].a[0][0],f[x].a[1][0]))
typedef long long ll;

struct IO_tp
{
	static const int Sbuf=1<<21;
	char buf[Sbuf], *S, *T, c; int f;
	#define gc() (S==T?(T=(S=buf)+fread(buf,1,sizeof(buf),stdin),(S==T?EOF:*S++)):*S++)
	inline int get()
	{
		for(c=gc(); c<'A'||c>'Z'; c=gc()); return c;
	}
	template<class I>
	inline IO_tp& operator >> (I &x)
	{
		for(f=1, c=gc(); c<'0'||c>'9'; c=gc()) if(c=='-') f=-1;
		for(x=0; c>='0'&&c<='9'; c=gc()) x=x*10+(c^48); x*=f;
		return *this;
	}
}IO;

const int N=200005;
const ll inf=1e14;

inline ll Min(const ll a,const ll b)
{
	return a<b?a:b;
}

int n,m,o,x,y,val[N],fa[N];
std::vector<int> G[N];
ll dp[N];
ll ans;

struct node
{
	ll a[2][2];
	node()
	{
		a[0][0]=a[0][1]=a[1][0]=a[1][1]=inf;
	}
}a[N],f[N];

node Mul(const node&a,const node&b)
{
	node Tmp; int i,j,k;
	for(i=0;i<2;i++)for(j=0;j<2;j++)for(k=0;k<2;k++)Tmp.a[i][j]=Min(Tmp.a[i][j],a.a[i][k]+b.a[k][j]);
	return Tmp;
}

namespace LCT
{
	#define lc(x) (ch[x][0])
	#define rc(x) (ch[x][1])
	int ch[N][2],fa[N];
	
	bool g(int x)
	{
		return rc(fa[x])==x;
	}
	
	bool nrt(int x)
	{
		return lc(fa[x])==x || rc(fa[x])==x;
	}
	
	void up(int x)
	{
		f[x]=a[x];
		if(lc(x)) f[x]=Mul(f[x],f[lc(x)]);
		if(rc(x)) f[x]=Mul(f[rc(x)],f[x]);
	}
	
	void rot(int x)
	{
		int y=fa[x],i=g(x);
		if(nrt(y))
			ch[fa[y]][g(y)]=x;
		fa[x]=fa[y];
		ch[y][i]=ch[x][i^1];
		fa[ch[x][i^1]]=y;
		ch[x][i^1]=y;
		fa[y]=x;
		up(y);
	}
	
	void splay(int x)
	{
		for(int y=fa[x];nrt(x);rot(x),y=fa[x])
			if(nrt(y))
				rot(g(x)==g(y)?y:x);
		up(x);
	}
	
	void access(int x)
	{
		for(int y=0;x;y=x,x=fa[x])
		{
			splay(x);
			ll g=a[x].a[0][0];
			if(rc(x))
			{
				g+=DP(rc(x));
			}
			if(y)
			{
				g-=DP(y);
			}
			a[x].a[0][0]=g;
			rc(x)=y;
			up(x);
		}
	}
}

void dfs(int u,int father)
{
	ll s=inf;
	dp[u]=val[u];
	fa[u]=father;
	for(auto v:G[u])
		if(v!=father)
		{
			LCT::fa[v]=u;
			dfs(v,u);
			if(s==inf) s=0;
			s+=dp[v];
		}
	dp[u]=Min(dp[u],s);
	a[u].a[0][0]=s;
	a[u].a[1][0]=val[u];
	a[u].a[1][1]=0;
	f[u]=a[u];
}

int main()
{
	IO>>n;
	for(int i=1; i<=n; i++)
		IO>>val[i];
	for(int i=1; i<=n-1; i++)
	{
		IO>>x>>y;
		G[x].push_back(y);
		G[y].push_back(x);
	}
	dfs(1,0);
	IO>>m;
	while(m--)
	{
		o=IO.get();
		if(o=='C')
		{
			IO>>x>>y;
			LCT::access(x);
			LCT::splay(x);
			a[x].a[1][0]+=y;
			LCT::up(x);
		}
		else
		{
			IO>>x;
			if(fa[x])
				LCT::access(fa[x]);
			LCT::splay(x);
			printf("%lld\n",DP(x));
		}
	}
	return 0;
}
```

---

## 作者：阿丑 (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/solution/P6021)

提供一种基于动态 dp 思想的小常数做法。

#### 前置知识：

动态 dp。

#### 分析：

记 $a_x$ 为 $x$ 的权值，$f_x$ 为只考虑以 $x$ 为根的子树时的答案。当 $x$ 不为叶子时，有 $f_x=\min(a_x,\,\sum\limits_{y\in\text{son}(x)}f_y)$。

记 $y$ 为 $x$ 的重儿子，$v_x=\sum\limits_{z\in\text{son}(x),\,z\neq y} f_z$，则上式可写为：$f_x=\min(a_x,\,f_y+v_x)$。

一般的动态 dp 使用了矩阵维护这个式子。但考虑形如 $u=\min(a,\,v+b)$ 的式子连续使用两次，即：

$u=\min(a_2,\,\min(a_1,\,v+b_1)+b_2)=\min(\min(a_2,\,a_1+b_2),\,v+b_1+b_2)$

记 $a'=\min(a_2,\,a_1+b_2),b'=b_1+b_2$，则 $u=\min(a',\,v+b')$，这又是个结构相似的式子。注意到 $a',b'$ 与 $v$ 无关，所以两个这样的式子在未知 $v$ 的情况下也可以直接合并成一个，可以直接用线段树 / 全局平衡二叉树 / LCT 维护这个式子的区间合并，而不需使用矩阵乘法。

这里给出线段树部分的代码。

```cpp
int nod[mN];	//nod[x]=p 表示线段树上对应 [x, x] 这个区间的节点是 p。
ll a[mN*4], b[mN*4];	//u=min(a, v+b)
inline void push_up(const int p) {
	b[p]=b[lc]+b[rc], a[p]=min(a[rc], a[lc]+b[rc]);
	//b'=b1+b2, a'=min(a2, a1+b2)
}
void build(int p, int l, int r) {
	if(l==r) {
		int x=mp[l];	//mp[l] 表示 dfn 序 l 对应的节点
		nod[l]=p;
		b[p]=sum[x]-dp[gs[x]];
		//gs[x] 表示 x 的重儿子
		//sum[x] 表示 x 的所有儿子的 dp 值之和，若 x 无儿子则为无穷大
		a[p]=::a[x];
		return;
	}
	int mid=l+r>>1;
	build(lc, l, mid), build(rc, mid+1, r), push_up(p);
}
ll mdf[2];
inline void modify(int x) {
	a[nod[x]]=mdf[0], b[nod[x]]=mdf[1];
	for(int p=nod[x]>>1; p; p>>=1) push_up(p);
}
ll qry;
void query(int p, int l, int r, int x, int y) {
	if(x<=l && r<=y) return qry=min(a[p], qry+b[p]), void();
	//相当于对 l<=i<=r 的所有 i 做了一次 qry=min(a[i], qry+b[i])
	int mid=l+r>>1;
	if(x<=mid) query(lc, l, mid, x, y);
	if(mid<y) query(rc, mid+1, r, x, y);
}
```

---

## 作者：Rainsleep (赞：1)

暴力 dp 考虑 $f_u$ 表示使得 $u$ 子树内叶子都不可达的最小代价。有转移

$$f_u = \min(a_u, \sum_{v \in son_u}f_v)$$

其中 $son_u$ 表示 $u$ 的儿子。

考虑带修改怎么关联到常用方法 ddp 上。先树剖，令 $s_u$ 表示 $u$ 的重儿子，然后把贡献拆成

$$f_u=  \min(a_u, g_u + f_{s_u})$$

其中 $g_u = \displaystyle\sum_{v \in son_u, v \neq s_u}f_v$。（事实上这样做的主要目的就是为了方便放到矩阵上。）

然后我们定义广义矩阵乘法是

$$C_{i, j} = \min_{k = 1}^n (A_{i, k} + B_{k, j})$$

>这么定义的目的，是为了让 $f$ 能从式子里的 $a_u + 0$ 和 $g_u + f_{s_u}$ 转移过来。

考虑答案矩阵一定要含有 $f_u$，并且转移矩阵还要有 $a_u, g_u, f_{s_u}$，不妨直接往上填然后补掉剩下的部分。

不难得到最终由

$$
\begin{bmatrix} g_u & a_u \\ 0 & 0\end{bmatrix} \times  
\begin{bmatrix} f_{s_u} \\ 0 \end{bmatrix} = 
\begin{bmatrix} f_u \\ 0\end{bmatrix} 
$$

直接按照 ddp 的方式跳重链就行了。

另外，因为我们的叶子节点上挂着的是 $1 \times 2$ 的**初始矩阵**，所以肯定要算出 $f$ 然后填在矩阵 $(0, 0)$ 处，这样出来的东西才不会是一堆转移矩阵乘出来的东西。

[code](https://www.luogu.com.cn/paste/126sh5u9)

---

## 作者：Helloworldwuyuze (赞：0)

# P6021题解

## Des

给定一棵树，点有点权，标记一些点使得每个叶子到根节点的路径上都有一个点被标记，求标记点的最小权值和。点权可修改。$n\le 2\times 10^5$。

## Sol

DDP 板子题。可以先去看看 [P4719 【模板】"动态 DP"&动态树分治](https://www.luogu.com.cn/problem/P4719) 这道题。两题基本一致。

### Part 1

首先我们看看暴力要怎么做。

显然的，我们设 $f_x$ 表示 $x$ 子树内的答案。这个点要么选，要么不选，于是很显然有：
$$
f_x = \min\{a_x,\sum_{v\in son_u} f_v\}
$$
然后我们就有了 $O(n^2)$ 的暴力。

### Part 2

显然这道题应该使用动态 DP。

套路地，我们使用重链树剖。同样，套路地，我们把重儿子和轻儿子分开来看。我们设：
$$
g_x = \sum_{y\in lightson_x} f_y
$$
于是：
$$
f_x = \min\{a_x,g_x+f_{son_x}\}
$$
套路地，我们重定义矩阵乘法：
$$
C_{n\times l} = A_{n\times m}B_{m\times l}
$$
表示的是：
$$
c_{i,j} = \min_{k=1}^m a_{i,k}+b_{k,j}
$$
套路地，我们知道它有结合律。因此，我们希望一个点 $f_u$ 可以通过它的重儿子 $f_v$ 转移过来。但是这是一维的，我们不好写方阵，因此我们再加一维得到：
$$
\begin{bmatrix}f_u\\0\end{bmatrix} = A\begin{bmatrix}f_v\\0\end{bmatrix}
$$
这里不难写出矩阵 $A$：
$$
A = \begin{bmatrix}g_u&a_u\\\infty &0\end{bmatrix}
$$
然后我们维护重链的时候，只需要在链头的父亲上修改新的矩阵 $A$ 即可。

另外，叶子结点的矩阵应该是：$\begin{bmatrix}\infty & a_u \\ \infty & 0\end{bmatrix}$。

剩下的就是一些细节，这里给出我犯的两个错误：

- 每次修改 $C,x,y$ 是把 $x$ 加 $y$ 而非赋值。
- 不开 `long long` 见祖宗。

### Part 3

~~自认为马蜂良好~~。

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<queue>
#include<stack>
#include<algorithm>
#include<map>
#include<iomanip>
#include<unordered_map>

#include<bitset>
#include<set>

#include<deque>
#include<cassert>
#include<cstdlib>
#include<cmath>
#include<ctime>
#include<vector>
#include<random>

#define fi first
#define se second
#define pb push_back
#define mk make_pair
#define DBG cerr << __LINE__ << ' ' << __FUNCTION__ << endl

#define DRE default_random_engine
#define UID uniform_int_distribution
#define y0 Y0
#define y1 Y1

#define int long long
#define pi acos(-1)
#define eps (1e-8)
#define endl '\n'
inline int max(int x,int y){ return x>y ? x : y; }
inline int min(int x,int y){ return x<y ? x : y; }

using namespace std;

const int INF = 0x3f3f3f3f;
typedef pair<int,int> PII;
typedef pair<int,PII> PIII;
const int N = 2e5 + 10;
const int M = 1e6 + 10;

int n, q, a[N], x, y;
char op;
vector<int> g[N];

struct matrix{
	int a[2][2];
	matrix(){ a[0][0] = a[0][1] = a[1][0] = a[1][1] = 0;}
}val[N];
matrix operator *(matrix x, matrix y){
	matrix ans;
	ans.a[0][0] = min(x.a[0][0] + y.a[0][0], x.a[0][1] + y.a[1][0]);
	ans.a[0][1] = min(x.a[0][0] + y.a[0][1], x.a[0][1] + y.a[1][1]);
	ans.a[1][0] = min(x.a[1][0] + y.a[0][0], x.a[1][1] + y.a[1][0]);
	ans.a[1][1] = min(x.a[1][0] + y.a[0][1], x.a[1][1] + y.a[1][1]);
	return ans;
}

int dfn[N], idx, son[N], siz[N], dep[N], fa[N], top[N], rk[N], ed[N];
int f[N], h[N];
void dfs1(int x,int fat){
	fa[x] = fat, dep[x] = dep[fat] + 1, siz[x] = 1;
	for(int y:g[x])
		if(y != fat){
			dfs1(y, x);
			siz[x] += siz[y];
			if(siz[y] > siz[son[x]])	son[x] = y;
		}
}
void dfs2(int x,int tp){
	top[x] = tp, dfn[x] = ++idx, rk[idx] = x;
	if(son[x])	dfs2(son[x], tp);
	for(int y:g[x])
		if(y != fa[x] && y != son[x])	dfs2(y, y), h[x] += f[y];
	if(g[x].size() == 1)	f[x] = a[x], h[x] = INF;
	else	f[x] = min(a[x], h[x] + f[son[x]]);
	val[x].a[0][0] = h[x], val[x].a[0][1] = a[x], val[x].a[1][0] = INF, val[x].a[1][1] = 0;
}

struct seg{
	matrix t[N<<2];
	void push_up(int p){ t[p] = t[p<<1] * t[p<<1|1]; }
	void build(int p,int l,int r){
		if(l == r)	return (void)(t[p] = val[rk[l]]);
		int mid = l+r>>1;
		build(p<<1, l, mid), build(p<<1|1, mid+1, r);
		push_up(p);
	}
	void update(int p,int l,int r,int x){
		if(l == r)	return (void)(t[p] = val[rk[x]]);
		int mid = l+r>>1;
		if(x <= mid)	update(p<<1, l, mid, x);
		else	update(p<<1|1, mid+1, r, x);
		push_up(p);
	}
	matrix query(int p,int l,int r,int left,int right){
		if(left <= l && r <= right)	return t[p];
		int mid = l+r>>1;
		matrix ls, rs;
		bool lls = false, rrs = false;
		if(left <= mid)	lls = true, ls = query(p<<1, l, mid, left, right);
		if(right > mid)	rrs = true, rs = query(p<<1|1, mid+1, r, left, right);
		if(!lls)	return rs;
		if(!rrs)	return ls;
		return ls * rs;
	}
}t;
int find_end(int x){ return ed[x] ? ed[x] : (son[x] ? ed[x] = find_end(son[x]) : x);}

void update(int x,int y){
	val[x].a[0][1] += y, a[x] += y;
	while(x){
		matrix bef = t.query(1, 1, n, dfn[top[x]], dfn[ed[x]]);
		t.update(1, 1, n, dfn[x]);
		matrix aft = t.query(1, 1, n, dfn[top[x]], dfn[ed[x]]);
		x = fa[top[x]];
		val[x].a[0][0] += min(aft.a[0][0], aft.a[0][1]) - min(bef.a[0][0], bef.a[0][1]);
	}
}

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;++i)	cin>>a[i];
	for(int i=1;i<n;++i)	cin>>x>>y, g[x].pb(y), g[y].pb(x);
	dfs1(1, 0), dfs2(1, 1);
	for(int i=1;i<=n;++i)	ed[i] = find_end(i);
	t.build(1, 1, n);
	cin>>q;
	while(q--){
		cin>>op;
		if(op == 'Q'){
			cin>>x;
			matrix ans = t.query(1, 1, n, dfn[x], dfn[ed[x]]);
			cout<<min(ans.a[0][0], ans.a[0][1])<<endl;
		}else{
			cin>>x>>y;
			update(x, y);
		}
	}
	return 0;
}
```

---

## 作者：wcyQwQ (赞：0)

[可能更好的阅读体验](https://chenyu-w.github.io./2023/01/24/P6021%E6%B4%AA%E6%B0%B4/)
## 前言

动态 DP 入门题。

## 分析

首先考虑不带修怎么做。令 $f_u$ 表示做完以 $u$ 为根子树的最小代价，显然有
$$
f_u = \min(a_u, \sum_v f_v)
$$
其中 $v$ 为 $u$ 的儿子。

然后根据动态 DP 的流程，考虑重链剖分，定义 $g_u$ 为 $u$ 所有轻儿子的 $f$ 值之和，特别地，若 $u$ 为叶子节点，$g_u = a_u$，那么现在转移方程变为
$$
f_u = \min(a_u, g_u + f_{\text{son}_u})
$$
其中 $\text{son}_u$ 为 $u$ 的重儿子。

依旧是动态 DP 套路，定义广义矩阵乘法 $\text A * \text B = \text C$，满足
$$
\text C_{i, j} = \min_k\{\text A_{i, k} + \text B_{k, j}\}
$$
那么我们就有转移
$$
\begin{bmatrix}
g_u & a_u\\
0 & 0
\end{bmatrix}
*
\begin{bmatrix}
f_v \\
0
\end{bmatrix}
=
\begin{bmatrix}
f_u \\
0
\end{bmatrix}
$$
不难发现求 $f_u$ 只要把从 $u$ 开始到 $u$ 所在的重链结尾路径上的所有矩阵乘起来即可，直接线段树维护即可。

## 代码

```c++
#include <bits/stdc++.h>
#define L(i, j, k, l) for(int i = (j); i <= (k); i += (l))
#define R(i, j, k, l) for(int i = (j); i >= (k); i -= (l))
#define G(i, u) for (int i = h[(u)]; ~i; i = ne[i])
#define ll long long
#define ld long double
#define ull unsigned long long

using namespace std;
const int N = 2e5 + 10, INF = 1e9;
struct Matrix {
    ll a[2][2];
    Matrix(int p = 0, int q = 0, int x = 0, int y = 0) {a[0][0] = p, a[0][1] = q, a[1][0] = x, a[1][1] = y;}
    Matrix operator*(Matrix b) {
        Matrix c(INF, INF, INF, INF);
        L(k, 0, 1, 1) L(i, 0, 1, 1) L(j, 0, 1, 1) c.a[i][j] = min(c.a[i][j], a[i][k] + b.a[k][j]);
        return c;
    }
};
struct Sgt {
    int l, r;
    Matrix res;
} t[N << 2];
int a[N];
int h[N], e[N << 1], ne[N << 1], idx;
int fa[N], sz[N], son[N];
int dfn[N], rk[N], top[N], ed[N], f[N], tt;
Matrix val[N];

inline int read() {
    int x = 0, y = 1; char c = getchar();
    while (c < '0' || c > '9') {if (c == '-') y = -1; c = getchar();}
    while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
    return x * y;
}

inline void add(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

inline void dfs1(int u, int p) {
    fa[u] = p, sz[u] = 1;
    G(i, u) {
        int v = e[i];
        if (v == p) continue;
        dfs1(v, u);
        sz[u] += sz[v];
        if (sz[v] > sz[son[u]]) son[u] = v;
    }
}

inline void dfs2(int u, int t) {
    rk[ed[top[u] = t] = dfn[u] = ++tt] = u;
    val[u].a[0][1] = f[u] = a[u];
    int tmp = 0;
    if (son[u]) {
        dfs2(son[u], t);
        tmp += f[son[u]];
    }
    G(i, u) {
        int v = e[i];
        if (v == fa[u] || v == son[u]) continue;
        dfs2(v, v);
        val[u].a[0][0] += f[v], tmp += f[v];
    }
    if (sz[u] > 1) f[u] = min(f[u], tmp);
    else val[u].a[0][0] = a[u];
}

inline void pushup(int p) {
    t[p].res = t[p << 1].res * t[p << 1 | 1].res;
}

inline void build(int p, int l, int r) {
    t[p].l = l, t[p].r = r;
    if (l == r) {
        t[p].res = val[rk[l]];
        return;
    }
    int mid = (l + r) >> 1;
    build(p << 1, l, mid), build(p << 1 | 1, mid + 1, r);
    pushup(p);
}

inline void modify(int p, int x) {
    if (t[p].l == t[p].r) {
        t[p].res = val[rk[x]];
        return;
    }
    int mid = (t[p].l + t[p].r) >> 1;
    if (x <= mid) modify(p << 1, x);
    else modify(p << 1 | 1, x);
    pushup(p);
}

inline Matrix query(int p, int l, int r) {
    if (l <= t[p].l && t[p].r <= r) return t[p].res;
    int mid = (t[p].l + t[p].r) >> 1;
    if (l > mid) return query(p << 1 | 1, l, r);
    if (r <= mid) return query(p << 1, l, r);
    return query(p << 1, l, r) * query(p << 1 | 1, l, r);
}

inline void modify_path(int u, int w) {
    val[u].a[0][1] += w;
    a[u] += w;
    if (sz[u] == 1) val[u].a[0][0] += w;
    while (u) {
        Matrix bef = query(1, dfn[top[u]], ed[top[u]]);
        modify(1, dfn[u]);
        Matrix aft = query(1, dfn[top[u]], ed[top[u]]);
        u = fa[top[u]];
        val[u].a[0][0] += aft.a[0][0] - bef.a[0][0];
    }
}

signed main() {
    memset(h, -1, sizeof h);
    int n = read();
    L(i, 1, n, 1) a[i] = read();
    L(_, 1, n - 1, 1) {
        int a = read(), b = read();
        add(a, b), add(b, a);
    }
    dfs1(1, 0);
    dfs2(1, 1);
    build(1, 1, n);
    int m = read();
    while (m--) {
        char op; cin >> op;
        if (op == 'Q') {
            int x = read();
            printf("%d\n", query(1, dfn[x], ed[top[x]]).a[0][0]);
        }
        else {
            int u = read(), w = read();
            modify_path(u, w);
        }
    }
    return 0;
}
```



---

## 作者：ez_lcw (赞：0)

一种非 DDP 的树剖做法。

~~主要是因为我不会 DDP，在考场上只想到了树剖。~~

首先如果没有修改，很容易想到朴素的 dp 做法：

设 $val_u$ 表示 $u$ 本身的权值，$dp_u$ 表示以 $u$ 为根的子树的答案，显然有：

$$dp_u=\min\left(val_u,\sum_{v\in son(u)}dp_v\right)$$

就是要么割自己，要么割所有的子树。

为了方便表述，不妨设 $sum_u=\sum\limits_{v\in son(u)}dp_v$。

但现在带修了怎么办呢？

~~DDP？不会！~~

首先肯定能发现如果修改了一个点 $u$ 的权值加上了 $to$（$to\geq 0$），那么最多只有 $u$ 到根的这条链上的点的 $dp$ 值会改变。

考虑会做出那些改变：

首先 $dp_u$ 的变化我们可以计算出来，不妨设 $dp_u$ 的变化量为 $x$，那么对 $sum_{fa}$ 的贡献也是 $x$。（$fa$ 为 $u$ 的父亲）

那么如果 $sum_{fa}+x\leq val_{fa}$，那么 $dp_{fa}$ 的变化量也是 $x$，那么对 $fa$ 的父亲 $gfa$ 的 $sum_{gfa}$ 的贡献也是 $x$。

定义一个函数 $\operatorname{change}(u,x)$ 表示当 $sum_u$ 需要增加 $x$ 时，我们要进行的操作。

下面以 $\operatorname{change}(fa,x)$ 为例来详细阐述这个操作：

我们从 $fa$ 开始往上找到第一个不满足 $sum_v+x\leq val_v$ 的点 $v$，即满足 $sum_v+x> val_v$，设 $v$ 向 $u$ 方向的儿子为 $son$，$v$ 的父亲为 $f$。

图大概长这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/tgdofupn.png)

那么按照我们刚才的推论，$u$ 到 $son$ 的这一段点的 $dp$ 值的变化量也都是 $x$。

但是当 $son$ 向 $sum_v$ 贡献 $x$ 的时候，发现 $sum_v+x>val_v$。接下来分两种情况讨论：

1. 若一开始 $sum_v<val_v$，加上 $x$ 后的新的 $sum_v$ 大于 $val_v$，那么 $dp_v$ 就会变成 $val_v$，变化量就是 $val_v-sum_v$（这里的 $sum_v$ 是没有加 $x$ 之前的 $sum_v$），对 $f$ 的贡献也是 $val_v-sum_v$。

	那么到这里，我们又可以重复上述过程，进行操作 $\operatorname{change}(f,val_v-sum_v)$。

1. 若一开始 $sum_v\leq val_v$，那么 $sum_v$ 加上 $x$ 后对 $dp_v$ 没有影响（因为 $dp_v$ 还是 $val_v$），那么对 $v$ 上面的祖先的 $dp$ 值也不会产生影响。此时直接结束修改就好。

发现上述操作的实质其实就是将 $rt$ 到 $u$ 的链分为很多段，然后每一段的 $dp$ 都是加上同一个权值。

那么现在的问题就变成每一段如何找到段顶 $v$，并且还要维护这一段修改 $sum$ 值。

后面那个很简单，用树剖维护就好，关键是如何找到 $v$。

找 $v$ 和找 $son$ 是等价的，观察一下 $son$ 需要满足的要求：$son$ 是最高的满足从 $u$ 到 $son$ 每一个的点 $i$ 都满足 $sum_i+x\leq val_i$ 的点。

移一下项，变成：$x\leq val_i-sum_i$。

这个时候就好办了，我们用树剖维护每一个点的 $val-sum$，然后在线段树中维护每个区间的最小值：只有当一个区间的最小值大于等于 $x$ 时，这个区间的所有值都大于等于 $x$。

那么就能按这种方法在线段树上找到 $son$，然后 $v$ 就是 $son$ 的父亲了。

发现我们还能同时在这棵线段树上通过修改 $val-sum$ 的值来修改 $sum$ 的值，很方便。

那么询问的时候答案就是 $\min(val_u,val_u-\operatorname{query}(u))$。（这里的 $\operatorname{query}(u)$ 其实就是在线段树中查询到的 $val_u-sum_u$）

至于时间为什么能够保证：

首先一次修改的时间取决于分成的段数，因为每一段都是 $O(\log n)$ 的。

发现一次修改有可能就一段，有可能有 $n$ 段，所以要从总体考虑这个事情。

考虑将分段的个数转化为每一个点 $v$ 被分成段头的次数：

如果一个点 $v$ 被分成段头，那么肯定是出现了 $sum_v\leq val_v$ 但 $sum_v+x>val_v$ 的情况，那么加上 $x$ 后的新的 $sum_v$ 会大于 $val_v$。又由于每一次修改操作都是给一个点的权值加上非负整数 $x$，所以对 $sum$ 的贡献也是非负整数。

所以除非修改自己的点权 $val_v$，在第一次 $sum_v>val_v$ 后，$v$ 就不会被分为链头。又由于只有当 $sum_v\leq val_v$ 且 $sum_v+x>val_v$ 的情况下 $v$ 会被分为链头，所以每一个点最多只会被分为链头一次，所以段数不会大于 $n$ 级别。

那么总时间复杂度就是 $O((n+m)\log^2 n)$，可以通过。

代码如下，有很多细节：

```cpp
#include<bits/stdc++.h>

#define N 200010
#define INF 0x7fffffffffffffff
#define ll long long

using namespace std;

int n,m;
int cnt,head[N],nxt[N<<1],to[N<<1];
int idx,fa[N],size[N],son[N],id[N],rk[N],top[N];
ll val[N],sumson[N],dp[N];
ll minn[N<<2],lazy[N<<2],mostl[N<<2];

void adde(int u,int v)
{
	to[++cnt]=v;
	nxt[cnt]=head[u];
	head[u]=cnt;
}

void dfs(int u)
{
	size[u]=1;
	bool leaf=true;
	for(int i=head[u];i;i=nxt[i])
	{
		int v=to[i];
		if(v==fa[u]) continue;
		leaf=false;
		fa[v]=u;
		dfs(v);
		sumson[u]+=dp[v];
		size[u]+=size[v];
		if(size[v]>size[son[u]]) son[u]=v;
	}
	if(leaf) sumson[u]=INF/100,dp[u]=val[u];
	else dp[u]=min(val[u],sumson[u]);
}

void dfs1(int u,int tp)
{
	top[u]=tp;
	id[u]=++idx;
	rk[idx]=u;
	if(son[u]) dfs1(son[u],tp);
	for(int i=head[u];i;i=nxt[i])
		if(to[i]!=fa[u]&&to[i]!=son[u])
			dfs1(to[i],to[i]);
}

void up(int k)
{
	minn[k]=min(minn[k<<1],minn[k<<1|1]);
}

void downn(int k,ll v)
{
	minn[k]-=v;
	lazy[k]+=v;
}

void down(int k)
{
	if(lazy[k])
	{
		downn(k<<1,lazy[k]);
		downn(k<<1|1,lazy[k]);
		lazy[k]=0;
	}
}

void build(int k,int l,int r)
{
	if(l==r)
	{
		minn[k]=val[rk[l]]-sumson[rk[l]];
		mostl[k]=rk[l];
		return;
	}
	int mid=(l+r)>>1;
	build(k<<1,l,mid);
	build(k<<1|1,mid+1,r);
	mostl[k]=mostl[k<<1];
	up(k);
}

ll query(int k,int l,int r,int x)
{
	if(l==r) return minn[k];
	down(k);
	int mid=(l+r)>>1;
	if(x<=mid) return query(k<<1,l,mid,x);
	return query(k<<1|1,mid+1,r,x);
}

void update(int k,int l,int r,int ql,int qr,ll v)
{
	if(ql<=l&&r<=qr)
	{
		downn(k,v);
		return;
	}
	down(k);
	int mid=(l+r)>>1;
	if(ql<=mid) update(k<<1,l,mid,ql,qr,v);
	if(qr>mid) update(k<<1|1,mid+1,r,ql,qr,v);
	up(k);
}

int find(int k,int l,int r,int ql,int qr,ll v)//找到son
{
	if(ql<=l&&r<=qr&&minn[k]>=v) return mostl[k];
	if(l==r) return -1;
	down(k);
	int mid=(l+r)>>1;
	if(qr>mid)
	{
		int ans2=find(k<<1|1,mid+1,r,ql,qr,v);
		if(ans2==mostl[k<<1|1]&&ql<=mid)
		{
			int ans1=find(k<<1,l,mid,ql,qr,v);
			if(ans1==-1) return ans2;
			return ans1;
		}
		return ans2;
	}
	return find(k<<1,l,mid,ql,qr,v);
}

void work(int u,ll v)
{
	ll t=query(1,1,n,id[u]);
	val[u]+=v,update(1,1,n,id[u],id[u],-v);
	if(t>=0) return;
	if(t+v>0) v=-t;
	u=fa[u];
	while(u)
	{
		int tmp=find(1,1,n,id[top[u]],id[u],v);//这里的tmp就是son
		while(tmp==top[u])
		{
			update(1,1,n,id[tmp],id[u],v);
			u=fa[tmp];
			if(!u) return;
			tmp=find(1,1,n,id[top[u]],id[u],v);
		}
		if(tmp==-1)
		{
			ll t=query(1,1,n,id[u]);
			update(1,1,n,id[u],id[u],v);
			if((v=t)<=0) return;
			u=fa[u];
			continue;
		}
		ll t=query(1,1,n,id[fa[tmp]]);
		update(1,1,n,id[fa[tmp]],id[u],v);
		if((v=t)<=0) return;
		u=fa[fa[tmp]];
	}
}

int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%lld",&val[i]);
	for(int i=1;i<n;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		adde(u,v),adde(v,u);
	}
	dfs(1),dfs1(1,1);
	build(1,1,n);
	scanf("%d",&m);
	int Q=0;
	while(m--)
	{
		char opt[2];
		scanf("%s",opt);
		if(opt[0]=='Q')
		{
			Q++;
			int u;
			scanf("%d",&u);
			printf("%lld\n",min(val[u],val[u]-query(1,1,n,id[u])));
		}
		else
		{
			int u;ll v;
			scanf("%d%lld",&u,&v);
			work(u,v);
		}
	}
	return 0;
}
```

---

## 作者：bwartist (赞：0)

[也许更好的阅读体验](https://www.cnblogs.com/bwartist/p/17965908)

---

请先完成 [ddp模板](https://www.luogu.com.cn/problem/P4719)

一个 [ddp 讲解视频](https://www.bilibili.com/video/BV1oJ411M7vF)

--- 
## Part0：题意解释

感觉题面太阴间了。所以解释一下：

`C x t` 表示把 $x$ 结点的权值改为 $t$.

`Q x` ：把 $x$ 子树中一些结点删去，使得 $x$ 与 $x$ 子树内所有叶子结点不连通。求 **删去的结点权值和** 的最小值。

## Part1：先不考虑修改操作

发现原题变成了一道简单的树形dp问题

令 $f_u$ 表示 使 $u$ 与其子树内叶子节点都不连通的最小代价。$val_u$ 是 $u$ 的权值


容易得到 $f_u=\min(val_u,\sum \limits_{v \in son_u} f_v)$

叶子节点特判：$f_u=val_u$

这样每一次修改操作后重新更新 $f_u$ 的时间复杂度是 $O(nm)$.

## Part3：ddp

注意到，每一次修改某一个结点 $x$ 的 $val_x$ 时，$f_u$ 会被修改的 $u$ 只有 $x$ 到根节点这一条链上的结点。所以就可以考虑ddp了。

~~根据ddp的套路~~，考虑把重儿子和轻儿子拆开。

令 $s_u$ 为 $u$的重儿子。令 $g_u= \sum \limits_{v \in son_u,v\neq s_u} f_v$.

现在重新写出 $f$ 的转移方程：$g_u=\min(val_u,g_u+f_{s_u})$

~~根据ddp的套路~~，现在考虑把原方程转化成矩阵的形式。

先对**矩阵乘法**做一点改变：令 $C_{i,j}=\min \limits_k (A_{i,k}+B_{k,j})$

简单变一下原来的 $f$ 转移式子：$g_u=\min(val_u+0,g_u+f_{s_u})$

可以得到 

$$

\begin{bmatrix}
g_u & val_u\\0 & \infty 
\end{bmatrix}
*
\begin{bmatrix}
f_{s_u}\\0 
\end{bmatrix}
=
\begin{bmatrix}
f_u\\0 
\end{bmatrix}
$$

所以，每个结点对应的转移矩阵就是 $\begin{bmatrix}g_u & val_u\\0 & \infty \end{bmatrix}$.

要求一个点 $u$ 的 $f_u$ 时，就只用求 $dfn_u$ 到 $ed_u$ 的矩阵乘积。

要修改一个点 $u$ 的 $val_u$ 时，在线段树中修改 $u$ 对应的矩阵，然后求出 $f_{top_u}$ 的变化值，并修改 ${fa_{top_u}}$ 对应的矩阵。将 $u$ 赋值为 ${fa_{top_u}}$，再次重复运算，直到到达根节点。

> 这里有一些注意点：
> 1. 为什么要把 $f_u$ 表示成 $\begin{bmatrix}f_u\\0 \end{bmatrix}$，而不是 表示成 $\begin{bmatrix}f_u&0 \end{bmatrix}$ 呢？因为第一种表示方式，是用 $\begin{bmatrix}f_{s_u}\\0 \end{bmatrix}$左乘转移矩阵 $\begin{bmatrix}g_u & val_u\\0 & \infty \end{bmatrix}$ 。而在 dfn 标号中， $dfn_u=dfn_{s_u}-1$ 。第二种表示方式，是右乘转移矩阵，不方便线段树的维护。ps：模板题中的题解也提到了这个tip。
> 2. 叶子结点的矩阵要特殊处理，正常的结点对应的矩阵就是 $\begin{bmatrix}g_u & val_u\\0 & \infty \end{bmatrix}$ 。但是叶子结点的矩阵要对应成 $\begin{bmatrix}f_u\\0 \end{bmatrix}$。可以自行思考一下为什么。

## Part4：代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAXN=2e5+5;
int read(){
	int x=0;char c=getchar();bool f=0;
	while(c>'9'||c<'0'){f|=(c=='-');c=getchar();}
	while(c<='9'&&c>='0'){x=(x<<1)+(x<<3)+c-'0';c=getchar();}
	return f?-x:x;
}
void write(ll x){
	if(x<0)	putchar('-');
	if(x>9)	write(x/10);
	putchar(x%10+'0');
}
struct Matrix{
	ll mat[2][2];
	Matrix(){memset(mat,0x3f,sizeof(mat));}
	Matrix operator *(Matrix b){
		Matrix c;
		for(int i=0;i<2;i++){
			for(int j=0;j<2;j++){
				for(int k=0;k<2;k++){
					c.mat[i][j]=min(c.mat[i][j],mat[i][k]+b.mat[k][j]);
				}
			}
		}
		return c;
	}
}v[MAXN<<2];

int n;
ll val[MAXN];
vector<int> G[MAXN];
int fa[MAXN],dfn[MAXN],idfn[MAXN],siz[MAXN],son[MAXN],ed[MAXN],top[MAXN];
Matrix g[MAXN];
ll f[MAXN];
void dfs0(int u){
	siz[u]=1,son[u]=0;
	for(int v:G[u]){
		if(v==fa[u])	continue;
		fa[v]=u;
		dfs0(v);
		siz[u]+=siz[v];
		if(siz[v]>siz[son[u]])	son[u]=v;	
	}
}
void dfs1(int u,int tp){
	dfn[u]=++dfn[0];
	idfn[dfn[0]]=u;
	top[u]=tp;
	ed[tp]=max(ed[tp],dfn[u]);

	if(!son[u]){//特判叶子结点 叶子节点的g=f
		f[u]=val[u];
		g[u].mat[0][0]=val[u];
		g[u].mat[1][0]=0;
		return;
	}
	
	f[u]=0;
	g[u].mat[0][0]=0;
	g[u].mat[0][1]=val[u];
	g[u].mat[1][1]=0;
	
	if(son[u]){
		dfs1(son[u],tp);
		f[u]+=f[son[u]];
	}
	for(int v:G[u]){
		if(v==fa[u]||v==son[u])	continue;
		dfs1(v,v);
		f[u]+=f[v];
		g[u].mat[0][0]+=f[v];
	}
	f[u]=min(f[u],val[u]);
}

#define lc (u<<1)
#define rc (u<<1|1)
void build(int u,int l,int r){
	if(l==r){v[u]=g[idfn[l]];return;}
	int mid=l+r>>1;
	build(lc,l,mid),build(rc,mid+1,r);
	v[u]=v[lc]*v[rc];
}
void change(int u,int l,int r,int pos){
	if(l==r){v[u]=g[idfn[l]];return;}
	int mid=l+r>>1;
	if(pos<=mid)	change(lc,l,mid,pos);
	else	change(rc,mid+1,r,pos);
	v[u]=v[lc]*v[rc];
}
Matrix query(int u,int l,int r,int L,int R){
	if(l>=L&&r<=R)	return v[u];
	int mid=l+r>>1;
	if(R<=mid)	return query(lc,l,mid,L,R);
	else if(L>mid)	return query(rc,mid+1,r,L,R);
	else return query(lc,l,mid,L,R)*query(rc,mid+1,r,L,R);
}
void work1(int u,ll Val){
	if(son[u])	g[u].mat[0][1]+=Val;
	else	g[u].mat[0][0]+=Val;
	val[u]+=Val;
	while(u){
		int tp=top[u];
		Matrix las=query(1,1,n,dfn[tp],ed[tp]);
		change(1,1,n,dfn[u]);
		Matrix now=query(1,1,n,dfn[tp],ed[tp]);
		
		if(!fa[tp])	break;
		g[fa[tp]].mat[0][0]+=now.mat[0][0]-las.mat[0][0];
		u=fa[tp];
	}
}
ll work2(int u){
	Matrix ret=query(1,1,n,dfn[u],ed[top[u]]);
	return ret.mat[0][0];
}
int main(){
	// freopen(".in","r",stdin);
	// freopen(".out","w",stdout);
	n=read();
	for(int i=1;i<=n;i++)	val[i]=1ll*read();
	for(int i=1;i<n;i++){
		int u=read(),v=read();
		G[u].push_back(v),G[v].push_back(u);
	}
	dfs0(1),dfs1(1,1);build(1,1,n);
	int Q=read();
	while(Q--){
		int x,t;
		char op;scanf("\n%c %d",&op,&x);
		if(op=='C'){scanf("%d",&t);work1(x,1ll*t);}
		else	write(work2(x)),putchar('\n');
	}
	return 0;
}
```

---


# 有趣的游戏

## 题目背景

小 A 和小 B 正在玩一个有趣的电脑游戏。

## 题目描述

游戏在一棵大小为 $n$ 的树上进行。其中每个点都有点权，第 $i$ 个点的点权为 $w_i$。

每一次系统会给出一条链，小 A 可以从这条链上找出两个**点权不同**的点 $x,y$，他的得分是 $w_x\bmod w_y$。然后小 B 会从**整棵树**中选取两个**小 A 没有选过**的点，计分方式同小 A。

为了保持游戏难度，系统有时会增加一个点的权值。

当然，小 A 会尽可能使自己得分最大，他想知道这个值是多少。同时，他想知道，在自己得分最大的情况下，小 B 的最大得分是多少。

## 说明/提示

样例解释：

第一次：小 A 选择点 $3$ 和点 $2$，得分为 $3\bmod 4=3$，小 B 选择点 $6$ 和点 $1$ 得分为 $4\bmod 5=4$。

第二次：小 A 选择点 $2$ 和点 $1$，得分为 $4\bmod 5=4$，小 B 选择点 $7$ 和点 $6$ 得分为 $3\bmod 4=3$。

第三次：小 A 选择点 $2$ 和点 $1$，得分为 $4\bmod 5=4$，小 B 选择点 $7$ 和点 $6$ 得分为 $3\bmod 4=3$。

第四次：第 $2$ 个点点权变为 $5$。

第五次：小 A 选择点 $5$ 和点 $1$，得分为 $1\bmod 5=1$，小 B 选择点 $6$ 和点 $2$ 得分为 $4\bmod 5=4$。

第六次：小 A 可以选的点只有 $1,2$ ，点权都是 $5$，没有可以选的方案。

**本题采用捆绑测试。**
| Subtasks |$n,q$  |特殊性质  |分数  |
| :----------: | :----------: | :----------: | :----------: |
|Subtask1  |$\leq10^3$  |无  |$10$  |
|Subtask2  |$\leq10^5$  |树的形态，点权随机  |$15$  |
|Subtask3  |$\leq10^5$  |最多有 $5$ 种不同的点权，且没有修改 |$15$  |
|Subtask4  |$\leq10^5$  |树为一条链，且第 $i$$(i>1)$ 个点的父亲为 $i-1$ |$25$  |
|Subtask5  |$\leq10^5$  |无  |$35$  |

对于所有数据 $1 \leq n,q \leq 10^5$，$1 \leq w_i \leq 10^4$，增加的数为不大于 $10^3$ 的正整数，且输入为一棵合法的树。**保证任何时候不同种类的数大于等于 $4$。**

## 样例 #1

### 输入

```
7
1 2
2 3
2 4
1 5
5 6
5 7
5 4 3 2 1 4 3
6
1 3 4
1 2 5
1 2 1
0 2 1
1 2 5
1 2 1```

### 输出

```
3 4
4 3
4 3
1 4
-1```

# 题解

## 作者：Alex_Wei (赞：11)

[题面传送门](https://www.luogu.com.cn/problem/P6157)

感觉比 D 简单一点 ~~（因为我对数论一窍不通）~~。

---

首先明确一点，选出的 $w_x$ 一定是**第二大**的，$w_y$ 一定是**最大的**，此时 $w_x\bmod w_y$ 最大。

- 为什么？不妨设 $w_x<w_y$，那么 $w_x\bmod w_y=w_x$，而 $w_y\bmod w_x$ 一定小于 $w_x$，所以选出的 $w_x,w_y$ 满足 $w_x<w_y$。
  
  因此，要使 $w_x\bmod w_y$ 最大，$w_x$ 一定是**第二大**的，$w_y$ 一定是**最大的**。

这样问题就被我们转化成了：

- 给定一条链，设 $x$ 为该链上权值**严格第二大**的节点，$y$ 为该链上权值最大的节点，求出 $w_x$。这可以用树剖和线段树维护。

- 求出去掉 $x,y$ 后剩余的点中**严格第二大**的权值。这可以用一个 multiset 维护。

其实，如果不带修，这道题目还能用主席树来做，可惜主席树无法支持这样的修改。

```cpp
#include<bits/stdc++.h>
using namespace std;
char buf[1<<23],*p1=buf,*p2=buf;
inline int read(){
	int x=0,sign=0; char s=getchar();
	while(!isdigit(s))sign|=s=='-',s=getchar();
	while(isdigit(s))x=(x<<1)+(x<<3)+(s-'0'),s=getchar();
	return sign?-x:x;
}
const int N=1e5+5;
int ct,hd[N],nxt[N<<1],vv[N<<1];
inline void add(int u,int v){
	nxt[++ct]=hd[u],hd[u]=ct,vv[ct]=v;
}
int n,q,dnum,fa[N],dep[N],siz[N],son[N],ind[N],top[N],rk[N];
void dfs1(int id,int f,int d){
	fa[id]=f,siz[id]=1,dep[id]=d;
	for(int i=hd[id];i;i=nxt[i]){
		int to=vv[i];
		if(to!=f){
			dfs1(to,id,d+1);
			if(siz[son[id]]<siz[to])son[id]=to;
			siz[id]+=siz[to];
		}
	}
}
void dfs2(int id,int t){
	top[id]=t,ind[id]=++dnum,rk[dnum]=id;
	if(!son[id])return;
	dfs2(son[id],t);
	for(int i=hd[id];i;i=nxt[i]){
		int to=vv[i];
		if(to!=fa[id]&&to!=son[id])dfs2(to,to);
	}
}
multiset <int> s;
int val[N];
struct data{
	int fi,se;
}c[N<<2];
data mer(data a,data b){
	int fi=max(a.fi,b.fi);//维护最大/第二大值
	return {fi,max(a.fi==fi?a.se:a.fi,b.fi==fi?b.se:b.fi)}; 
}
void build(int l,int r,int x){
	if(l==r){
		c[x]={val[rk[l]],-1};
		return;
	}
	int m=l+r>>1;
	build(l,m,x<<1),build(m+1,r,x<<1|1);
	c[x]=mer(c[x<<1],c[x<<1|1]);
}
void modify(int l,int r,int x,int pos,int v){
	if(l==r){
		val[rk[l]]+=v;
		c[x]={val[rk[l]],-1};
		return;
	}
	int m=l+r>>1;
	if(pos<=m)modify(l,m,x<<1,pos,v);
	else modify(m+1,r,x<<1|1,pos,v);
	c[x]=mer(c[x<<1],c[x<<1|1]);
}
data query(int l,int r,int ql,int qr,int x){
	if(ql<=l&&r<=qr)return c[x];
	int m=l+r>>1; data ans={-1,-1};
	if(ql<=m)ans=mer(ans,query(l,m,ql,qr,x<<1));
	if(m<qr)ans=mer(ans,query(m+1,r,ql,qr,x<<1|1));
	return ans;
}
data query(int x,int y){
	data ans={-1,-1};
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		ans=mer(ans,query(1,n,ind[top[x]],ind[x],1));
		x=fa[top[x]];
	}
	if(ind[x]>ind[y])swap(x,y);
	return mer(ans,query(1,n,ind[x],ind[y],1));
}
int main(){
	n=read();
	for(int i=1;i<n;i++){
		int u=read(),v=read();
		add(u,v),add(v,u);
	}
	dfs1(1,0,0),dfs2(1,1);
	for(int i=1;i<=n;i++)val[i]=read(),s.insert(val[i]);
	build(1,n,1);
	q=read();
	for(int i=0;i<q;i++){
		int op=read(),x=read(),y=read();
		if(op){
			data t=query(x,y);
			if(t.se==-1){
				puts("-1");
				continue;
			}
			printf("%d ",t.se);
			s.erase(s.find(t.fi)),s.erase(s.find(t.se));
			printf("%d\n",*(--s.lower_bound(*--s.end())));
			s.insert(t.fi),s.insert(t.se);
		}
		else{
			s.erase(s.find(val[x])),s.insert(val[x]+y);
			modify(1,n,1,ind[x],y);
		}
	}
	return 0;
}
```

---

## 作者：Genius_Star (赞：6)

### 思路：

先考虑第一个问题，求一条链上两个点权不同的点 $x,y$，他的得分是 $w_x \bmod w_y$，要使得得分最大。

容易发现，记 $Max_1$ 为链上最大值，$Max_2$ 为链上严格次大值，则 $Max_2 \bmod Max_1=Max_2$ 是最大得分。

简单证明一下，定义序列 $a$ 是链上所有权值按照从小到大的排序所得，即满足 $a_1 \le a_2 \le a_3 \cdots a_{n-1} \le a_n$。

对于每个 $a_i$ 和 $a_j$，考虑如下两种情况：

- 如果 $a_i<a_j$，则 $a_i \bmod a_j = a_i$。

- 如果 $a_i > a_j$，则 $a_i \bmod a_j < a_j$。

对比这两种情况，显然情况 $1$ 一定能得到最优解。

那我们这题思路就出来了，考虑树剖 + 线段树维护链上的最大值和严格次大值，那小 A 的得分为 $Max_2$。

再考虑小 B，也考虑这样的思路，但是如果小 A 的两个点都被选了，如果整棵树上的最大值和严格次大值和小 A 相同，且数字只有一个，那么小 B 不能选这两个点，需要选整棵树上的严格第 $3$ 大和严格第 $4$ 大，小 B 的得分就是树上的严格第 $4$ 大。

则对于小 B 来说，需要维护严格前 $4$ 大，每次对于每一个数开一个桶，看一下小 A 的选数有没有影响到小 B，如果影响到，则用严格 $3,4$ 大去更新答案。

两个区间严格前 $4$ 大合并时，考虑归并排序的思路，逐一比较，放入新数组，这样会快一点儿。

时间复杂度：$O(N \log^2 N)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=100100,M=10001000,T=4; 
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
struct St{
	ll a,b,c,d;
};
struct Node{
	ll l,r;
	St Max;
}X[N<<2];
ll n,q,cnt,op,x,y;
ll X1[10],X2[5];
ll a[N],p[N],d[N],z[N],t[N];
ll A[N],B[N],W[N];
ll fa[N];
short f[M];
vector<ll> E[N];
inline void add(ll u,ll v){
	E[u].push_back(v);
	E[v].push_back(u);
}
inline void dfs1(ll u,ll f){
	p[u]=1;
	for(auto v:E[u]){
		if(v==f)
		  continue;
		d[v]=d[u]+1;
		fa[v]=u;
		dfs1(v,u);
		p[u]+=p[v];
		if(p[v]>p[z[u]])
		  z[u]=v;
	}
}
inline void dfs2(ll u,ll k){
	t[u]=k;
	A[++cnt]=u;
	B[u]=cnt;
	W[cnt]=a[u];
	f[a[u]]++;
	if(!z[u])
	  return ;
	dfs2(z[u],k);
	for(auto v:E[u]){
		if(v==fa[u]||v==z[u])
		  continue;
		dfs2(v,v);
	}
}
inline St Union(St l, St r){
	X1[1]=l.a,X1[2]=l.b,X1[3]=l.c,X1[4]=l.d;
	X1[5]=r.a,X1[6]=r.b,X1[7]=r.c,X1[8]=r.d; 
	X2[1]=X2[2]=X2[3]=X2[4]=0;
	ll L=1,R=T+1;
	for(int i=1;i<=T;i++){
		while(L<=T&&X1[L]==X2[i-1])
		  L++;
		while(R<=2*T&&X1[R]==X2[i-1])
		  R++;
		if(L>T&&R>2*T)
		  break;
		if(L>T){
			X2[i]=X1[R++];
			continue;
		}
		if(R>2*T){
			X2[i]=X1[L++];
			continue;
		}
		if(X1[L]>X1[R])
		  X2[i]=X1[L++];
		else if(X1[L]<X1[R])
		  X2[i]=X1[R++];
		else{
			X2[i]=X1[L];
			L++,R++;
		}
	}
	return {X2[1],X2[2],X2[3],X2[4]};
}
inline void pushup(ll k){
	X[k].Max=Union(X[k<<1].Max,X[k<<1|1].Max);
}
inline void build(ll k,ll l,ll r){
	X[k].l=l,X[k].r=r;
	if(l==r){
		X[k].Max={W[l],0,0,0};
		return ;
	}
	ll mid=(l+r)>>1;
	build(k<<1,l,mid);
	build(k<<1|1,mid+1,r);
	pushup(k);
}
inline void add(ll k,ll i,ll v){
	if(X[k].l==i&&i==X[k].r){
		f[X[k].Max.a]--;
		X[k].Max.a+=v;
		f[X[k].Max.a]++;
		return ;
	}
	ll mid=(X[k].l+X[k].r)>>1;
	if(i<=mid)
	  add(k<<1,i,v);
	else
	  add(k<<1|1,i,v);
	pushup(k);
}
inline St qurey(ll k,ll l,ll r){
	if(X[k].l==l&&r==X[k].r)
	  return X[k].Max;
	ll mid=(X[k].l+X[k].r)>>1;
	if(r<=mid)
	  return qurey(k<<1,l,r);
	else if(l>mid)
	  return qurey(k<<1|1,l,r);
	else
	  return Union(qurey(k<<1,l,mid),qurey(k<<1|1,mid+1,r));
}
inline St Find(ll u,ll v){
	St ans={0,0,0,0};
	while(t[u]!=t[v]){
		if(d[t[u]]<d[t[v]])
		  swap(u,v);
		St h=qurey(1,B[t[u]],B[u]);
		ans=Union(ans,h);
		u=fa[t[u]];
	}
	if(d[u]>d[v])
	  swap(u,v);
	St h=qurey(1,B[u],B[v]);
	ans=Union(ans,h);
	return ans;
}
inline void solve(ll x,ll y){
	St t1=Find(x,y),t2=X[1].Max;
	ll a1=t1.a,a2=t1.b,b1=0,b2=0;
	if(!a2){
		puts("-1");
		return ;
	}
	ll x1=t2.a,x2=t2.b,x3=t2.c,x4=t2.d;
	if(f[a1]==1){
		if(x1==a1)
		  x1=0;
		if(x2==a1)
		  x2=0;
		if(x3==a1)
		  x3=0;
		if(x4==a1)
		  x4=0;
	}
	if(f[a2]==1){
		if(x1==a2)
		  x1=0;
		if(x2==a2)
		  x2=0;
		if(x3==a2)
		  x3=0;
		if(x4==a2)
		  x4=0;
	}
	b1=max({x1,x2,x3,x4});
	if(b1==x1)
	  b2=max({x2,x3,x4});
	if(b1==x2)
	  b2=max(x3,x4);
	if(b1==x3)
	  b2=x4;
	write(a2);
	putchar(' ');
	write(b2);
	putchar('\n');
}
int main(){
	n=read();
	for(int u,v,i=1;i<n;i++){
		u=read(),v=read();
		add(u,v);
	}
	for(int i=1;i<=n;i++)
	  a[i]=read();
	dfs1(1,1);
	dfs2(1,1);
	build(1,1,cnt);
	q=read();
	while(q--){
		op=read(),x=read(),y=read();
		if(!op)
		  add(1,B[x],y);
		else
		  solve(x,y);
	}
	return 0;
}
```


---

## 作者：fush (赞：3)

明显，$w_x$ 一定是**严格次大值**的，$w_y$ 一定是**最大值**。

证明：
我们可以假设 $x < y$，那么 $x \bmod y = x$，而 $y \bmod x < w_x$，所以若 $x < y$，有 $x \bmod y > y \bmod x$。
当 $x = y$ 显然两种均为 $0$。

因此，要使 $x\bmod y$ 最大，$w_x$ 一定是**严格次大值**的，$w_y$ 一定是**最大值**。

于是问题就变得十分简单了：

在链上记录**严格次大值**与**最大值**，然后找到去掉这两个值后的**严格次大值**。

第一个询问用树链剖分和线段树维护，第二个询问可以用 multiset 维护。

整体代码要 3KB，一定要注意细节，耐心调试。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
constexpr int N = 1e5 + 10;
int id[N], top[N], siz[N], dep[N], son[N], rnk[N], a[N], to[N << 1], nex[N << 1], tot, head[N], fa[N], n, m;
multiset<int>s;
#define PII pair<int, int>
#define mp make_pair
#define ls (u << 1)
#define rs (u << 1 | 1)
#define mid (l + r >> 1)
PII w[N << 2];
PII merge(PII x, PII y){ //第二项是严格次小值
    int f, s = max(x.second, y.second);
    if(x.first > y.first)f = x.first, s = max(y.first, s);
    else if(x.first < y.first)f = y.first, s = max(x.first, s);
    else f = y.first;
    return mp(f, s);
}
void build(int u, int l, int r){
    if(l == r)return void(w[u] = mp(a[l], -1));
    build(ls, l, mid), build(rs, mid + 1, r);
    w[u] = merge(w[ls], w[rs]);
}
void modify(int u, int l, int r, int pos, int v){
    if(l == r)return void(w[u] = mp(v, -1));
    (pos <= mid) ? (modify(ls, l, mid, pos, v)) : modify(rs, mid + 1, r, pos, v);
    w[u] = merge(w[ls], w[rs]);
}
PII query(int u, int l, int r, int L, int R){
    if(L <= l && r <= R)return w[u];
    if(R <= mid)return query(ls, l, mid, L, R);
    if(mid < L)return query(rs, mid + 1, r, L, R);
    return merge(query(ls, l, mid, L, R), query(rs, mid + 1, r, L, R));
}
#undef u
#undef mid
void add(int u, int v){to[++tot] = v, nex[tot] = head[u], head[u] = tot;}
void dfs1(int x, int f){
    dep[x] = dep[fa[x] = f] + (siz[x] = 1);
    for(int i = head[x], v; i; i = nex[i])
        if((v = to[i]) != f){
            dfs1(v, x), siz[x] += siz[v];
            if(siz[v] > siz[son[x]])son[x] = v;
        }
}
void dfs2(int x, int f){
    top[x] = f, a[id[x] = ++tot] = rnk[x];
    if(son[x]) dfs2(son[x], f);
    for(int i = head[x], v; i; i = nex[i]) 
        if(!id[v = to[i]])dfs2(v, v);
}
PII query(int l, int r){
    PII ans = mp(-1, -1);
    while(top[l] != top[r]){
        if(dep[top[l]] < dep[top[r]])swap(l, r);
        ans = merge(ans, query(1, 1, n, id[top[l]], id[l])), l = fa[top[l]];
    }
    if(id[l] > id[r])swap(l, r);
    return merge(ans, query(1, 1, n, id[l], id[r]));
}
int32_t main(){
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    cin >> n;
    for(int i = 1, u, v; i < n; i++)
        cin >> u >> v, add(u, v), add(v, u);
    for(int i = 1; i <= n; i++)
        cin >> rnk[i], s.insert(rnk[i]);
    tot = 0, dfs1(1, 1), dfs2(1, 1), build(1, 1, n);
    cin >> m;
    while(m--){
        int op, l, r;
        cin >> op >> l >> r;
        if(op){
            PII ans = query(l, r);
            if(ans.second < 0){
                cout << -1 << endl;
                continue;
            }
            s.erase(s.find(ans.first)), s.erase(s.find(ans.second));
            cout << ans.second << " " << *(--s.lower_bound(*--s.end())) << endl;
            s.insert(ans.first), s.insert(ans.second);
        }
        else{
            s.erase(s.find(rnk[l])), s.insert((rnk[l] += r));
            modify(1, 1, n, id[l], rnk[l]);
        }
    }
    return 0;
}
```

---

## 作者：Limit (赞：3)

本篇题解不需要维护严格前四大值,也不需要会STL,适合各种语言的选手看思路.

# 题目大意

给出一颗有点权的无根树,支持单点修改(加上一个数),在树链上插叙两个点的点权($w_i,w_j$)使得 $w_i \mod w_j$ 最大,且 $w_i \not= w_j$,以及在去掉这两个点后的整颗树上查询两个点的点权($w_q,w_p$)使得 $w_q \mod w_p$ 最大.

# 分析

考虑给出一些数其中任意一数给其他数取模后的最大值,可以发现这个最大值为这个数列的严格次大值 $\%$ 最大值.那么就是要找出树链上的最大值和严格次大值,这显然可以用[树链剖分](https://baike.baidu.com/item/树链剖分/10524122?fr=aladdin)和[线段树](https://baike.baidu.com/item/线段树/10983506?fr=aladdin)解决.

既然要用线段树维护,那么自然需要合并信息,而这里的最大值和严格次大值的合并比较麻烦.

先定义一个结构体:

```cpp
struct FMSM
{
	int first_max,second_max;
	//表示最大值和严格次大值
};
```

下面是合并操作

```cpp
FMSM MergeFMSM(FMSM a,FMSM b)//合并
{
	for_make.first_max=max(a.first_max,b.first_max);//合并以后的最大值一定等于合并的两个结构体中的最大值的最大值
	if(a.first_max!=b.first_max)//如果最大值不同时
	{
		for_make.second_max=min(a.first_max,b.first_max);//严格次大值为两最大值中小的那个
		for_make.second_max=max(for_make.second_max,max(a.second_max,b.second_max));//也可能为原来的严格次大值中大的那个
		return for_make;
	}
	for_make.second_max=max(a.second_max,b.second_max);//如果两个最大值相等那么严格次大值自然就是两严格次大值中大的那个
	return for_make;
}
```

然后就是要知道去掉两个数之后的严格次大了,这东西也很好办,可以用STL维护.

但是,我不会STL,所以可以发现严格次大就是最大的前驱(第一个小于它的数),因为需要删数&加数,那自然就会想到平衡树了,只要平衡树再维护一下就好了,~~非常简单~~.

# 代码

```cpp
#include<bits/stdc++.h>
#define REP(i,first,last) for(int i=first;i<=last;++i)
#define DOW(i,first,last) for(int i=first;i>=last;--i)
using namespace std;
const int MAXN=2e5+7;
const int INF=114514233;
int N,M;
struct Tree//平衡树部分,不多讲,可以用stl
{
	int lson,rson;
	int size;
	int val;
	int ind;
}tree[MAXN*2];
int fhq_cnt=0,root=0;
#define LSON tree[now].lson
#define RSON tree[now].rson
int New(int val)
{
	tree[++fhq_cnt].val=val;
	tree[fhq_cnt].ind=rand();
	tree[fhq_cnt].size=1;
	return fhq_cnt;
}
void FHQ_PushUp(int now)
{
	tree[now].size=tree[LSON].size+tree[RSON].size+1;
}
void Split(int now,int val,int &tree1,int &tree2)
{
	if(!now)
	{
		tree1=0;
		tree2=0;
		return;
	}
	if(tree[now].val<=val)
	{
		tree1=now;
		Split(RSON,val,RSON,tree2);
	}
	else
	{
		tree2=now;
		Split(LSON,val,tree1,LSON);
	}
	FHQ_PushUp(now);
}
int Merge(int tree1,int tree2)
{
	if(!tree1||!tree2)
	{
		return tree1+tree2;
	}
	if(tree[tree1].ind<tree[tree2].ind)
	{
		tree[tree1].rson=Merge(tree[tree1].rson,tree2);
		FHQ_PushUp(tree1);
		return tree1;
	}
	else
	{
		tree[tree2].lson=Merge(tree1,tree[tree2].lson);
		FHQ_PushUp(tree2);
		return tree2;
	}
}
int tree1,tree2,tree3;
void Insert(int val)
{
	Split(root,val,tree1,tree2);
	root=Merge(Merge(tree1,New(val)),tree2);
}
void Delete(int val)
{
	Split(root,val,tree1,tree3);
	Split(tree1,val-1,tree1,tree2);
	tree2=Merge(tree[tree2].lson,tree[tree2].rson);
	root=Merge(Merge(tree1,tree2),tree3);
}
int QueryKth(int now,int k)
{
	while(1)
	{
		if(tree[LSON].size+1==k)
		{
			return now;
		}
		if(tree[LSON].size>=k)
		{
			now=LSON;
		}
		else
		{
			k-=tree[LSON].size+1;
			now=RSON;
		}
	}
	return 0;
}
int QueryPre(int val)
{
	Split(root,val-1,tree1,tree2);
	int result=tree[QueryKth(tree1,tree[tree1].size)].val;
	root=Merge(tree1,tree2);
	return result;
}
#undef LSON
#undef RSON
int val[MAXN];
struct Edge//链式前向星
{
	int to,next;
}edge[MAXN*2];
int edge_head[MAXN];
int edge_cnt=0;
#define FOR(now) for(int edge_i=edge_head[now];edge_i;edge_i=edge[edge_i].next)
#define TO edge[edge_i].to
void AddEdge(int form,int to)
{
	edge[++edge_cnt].to=to;
	edge[edge_cnt].next=edge_head[form];
	edge_head[form]=edge_cnt;
}
//树剖部分
int point_deep[MAXN];
int point_father[MAXN];
int point_son[MAXN];
int point_size[MAXN];
void DFS_1(int now=1)
{
	int max_size=-1;
	point_size[now]=1;
	FOR(now)
	{
		if(point_father[now]!=TO)
		{
			point_father[TO]=now;
			point_deep[TO]=point_deep[now]+1;
			DFS_1(TO);
			point_size[now]+=point_size[TO];
			if(point_size[TO]>max_size)
			{
				max_size=point_size[TO];
				point_son[now]=TO;
			}
		}
	}
}
int chain_cnt=0;
int point_id[MAXN];
int point_val[MAXN];
int chain_top[MAXN];
void DFS_2(int now=1,int top=1)
{
	point_id[now]=++chain_cnt;
	point_val[chain_cnt]=val[now];
	chain_top[now]=top;
	if(!point_son[now])
	{
		return;
	}
	DFS_2(point_son[now],top);
	FOR(now)
	{
		if(TO!=point_father[now]&&TO!=point_son[now])
		{
			DFS_2(TO,TO);
		}
	}
}
#undef FOR
#undef TO
struct FMSM//最大和严格次大的结构体
{
	int first_max,second_max;
}for_make;
FMSM MergeFMSM(FMSM a,FMSM b)//合并
{
	for_make.first_max=max(a.first_max,b.first_max);
	if(a.first_max!=b.first_max)
	{
		for_make.second_max=min(a.first_max,b.first_max);
		for_make.second_max=max(for_make.second_max,max(a.second_max,b.second_max));
		return for_make;
	}
	for_make.second_max=max(a.second_max,b.second_max);
	return for_make;
}
FMSM MakeFMSM(int first_max,int second_max)
{
	for_make.first_max=first_max;
	for_make.second_max=second_max;
	return for_make;
}
FMSM fmsm_null=MakeFMSM(-INF,-INF);
struct SegmentTree//线段树部分
{
	FMSM max;
}sgt[MAXN*4];
#define LSON (now<<1)
#define RSON (now<<1|1)
#define MIDDLE ((left+right)>>1)
#define LEFT LSON,left,MIDDLE
#define RIGHT RSON,MIDDLE+1,right
#define NOW now_left,now_right
void SGT_PushUp(int now)
{
	sgt[now].max=MergeFMSM(sgt[LSON].max,sgt[RSON].max);
}
void Build(int now=1,int left=1,int right=N)
{
	if(left==right)
	{
		sgt[now].max=MakeFMSM(point_val[left],-INF);
		return;
	}
	Build(LEFT);
	Build(RIGHT);
	SGT_PushUp(now);
}
void Updata(int place,int w,int now=1,int left=1,int right=N)//单点修改
{
	if(place<left||right<place)
	{
		return;
	}
	if(left==right)
	{
		sgt[now].max=MakeFMSM(sgt[now].max.first_max+w,-INF);
		return;
	}
	Updata(place,w,LEFT);
	Updata(place,w,RIGHT);
	SGT_PushUp(now);
}
FMSM Query(int now_left,int now_right,int now=1,int left=1,int right=N)//区间查询
{
	if(now_right<left||right<now_left)
	{
		return fmsm_null;
	}
	if(now_left<=left&&right<=now_right)
	{
		return sgt[now].max;
	}
	return MergeFMSM(Query(NOW,LEFT),Query(NOW,RIGHT));//返回答案要合并
}
FMSM QueryMax(int u,int v)//插叙链
{
	FMSM result=fmsm_null;
	while(chain_top[u]!=chain_top[v])
	{
		if(point_deep[chain_top[u]]<point_deep[chain_top[v]])
		{
			swap(u,v);
		}
		result=MergeFMSM(result,Query(point_id[chain_top[u]],point_id[u]));
		u=point_father[chain_top[u]];
	}
	if(point_deep[u]>point_deep[v])
	{
		swap(u,v);
	}
	result=MergeFMSM(result,Query(point_id[u],point_id[v]));
	return result;
}
int main()
{
	scanf("%d",&N);
	int a,b;
	REP(i,1,N-1)
	{
		scanf("%d%d",&a,&b);
		AddEdge(a,b);
		AddEdge(b,a);
	}
	REP(i,1,N)
	{
		scanf("%d",&val[i]);
		Insert(val[i]);
	}
	DFS_1();
	DFS_2();
	Build();
	int opt,x,y;
	FMSM p;
	scanf("%d",&M);
	REP(i,1,M)
	{
		scanf("%d%d%d",&opt,&x,&y);
		if(opt==0)
		{
			Delete(val[x]);//删掉原来的数
			val[x]+=y;
			Insert(val[x]);//加入新数
			Updata(point_id[x],y);
		}
		if(opt==1)
		{
			p=QueryMax(x,y);
			if(p.second_max==-INF)//不存在不同数
			{
				printf("-1\n");
			}
			else
			{
				Delete(p.first_max);//先删掉
				Delete(p.second_max);
				a=QueryPre(QueryPre(INF));//最大值为极大值前驱,严格次大值为最大值前驱
				Insert(p.first_max);//重新加入
				Insert(p.second_max);
				printf("%d %d\n",p.second_max,a);//输出答案
			}
		}
	}
	return 0;
}//注意开O2
```

---

## 作者：masonxiong (赞：2)

# 题目分析

我们可以把小 A，小 B 的问题都用这个问题概括：

- 给定集合 $S$，求 $x, y \in S$ 使得 $x \bmod y$ 最大。

我们可以按照 $x$ 和 $y$ 的大小关系分类讨论进行探究。

首先，对于 $x > y$ 的情况，此时有 $x \bmod y < y$。显然不如我们选择 $y \bmod x = y$ 优。

那么，满足 $x \bmod y$ 最大的 $x, y$ 一定满足 $x < y$，此时有 $x \bmod y = x$，那么我们应当使 $x$ 尽可能大，同时还需要保证 $y > x$。

显然 $x$ 取集合次大值，$y$ 取集合最大值时最优。

接下来解决小 A 的问题：

- 单点加。
- 求区间最大值和区间**严格**次大值。

先考虑序列上怎么做。使用线段树，节点维护区间最大值、区间次大值，节点合并不难实现（实在不会可以看代码）。上树的话直接套树链剖分即可。

然后我们解决小 B 的问题：

- 单点加。
- 删除两个数，然后求全局**严格**次大值。

显然可以用平衡树，别的不知道了。

# 代码实现

平衡树使用 `std::multiset` 实现。你需要注意以下的实现细节：

- 不能直接用 `std::set<int>`，因为点权可重。
- 不能直接 `S.erase(value)`，因为这回删除**所有**值为 `value` 的元素，而你应该只会想删除一个，你应该写 `S.erase(S.find(value))`。
- 查询次大值不能直接 `*std::prev(S.end(), 2)`，因为我们需要查询**严格次大值**，你需要使用 `*std::prev(S.lower_bound(*S.rbegin()))`。

```cpp
#include <bits/stdc++.h>

constexpr int Maxn = 1e5 + 5, Infinity = std::numeric_limits<int>::max();

int n, q, t, o, u, v;
std::multiset<int, std::greater<int>> valueSet;
std::array<std::pair<int, int>, Maxn << 2> segmentTree;
std::array<int, Maxn> value, depth, parent, size, child, dfn, rank, top;
std::array<std::vector<int>, Maxn> tree;

std::pair<int, int> merge(std::pair<int, int> lhs, std::pair<int, int> rhs) {
    return std::make_pair(
        std::max(lhs.first, rhs.first),
        std::max(
            lhs.first >= rhs.first ? lhs.second : lhs.first,
            rhs.first >= lhs.first ? rhs.second : rhs.first
        )
    );
}

void build(int current, int left, int right) {
    if (left == right)
        return void(segmentTree[current] = std::make_pair(value[rank[left]], -Infinity));
    build(current << 1, left, (left + right) >> 1), build(current << 1 | 1, ((left + right) >> 1) + 1, right);
    segmentTree[current] = merge(segmentTree[current << 1], segmentTree[current << 1 | 1]);
}

void modify(int position, int newValue, int current, int left, int right) {
    if (position < left || right < position)
        return;
    if (position <= left && right <= position)
        return void(segmentTree[current] = std::make_pair(newValue, -Infinity));
    modify(position, newValue, current << 1, left, (left + right) >> 1), modify(position, newValue, current << 1 | 1, ((left + right) >> 1) + 1, right);
    segmentTree[current] = merge(segmentTree[current << 1], segmentTree[current << 1 | 1]);
}

std::pair<int, int> query(int queryLeft, int queryRight, int current, int left, int right) {
    if (queryRight < left || right < queryLeft)
        return std::make_pair(-Infinity, -Infinity);
    if (queryLeft <= left && right <= queryRight)
        return segmentTree[current];
    return merge(query(queryLeft, queryRight, current << 1, left, (left + right) >> 1), query(queryLeft, queryRight, current << 1 | 1, ((left + right) >> 1) + 1, right));
}

void firstDFS(int current, int previous) {
    parent[current] = previous, depth[current] = depth[previous] + 1, size[current] = 1;
    for (int next : tree[current])
        if (next != previous && (firstDFS(next, current), size[current] += size[next], size[next] > size[child[current]]))
            child[current] = next;
}

void secondDFS(int current, int chainTop) {
    dfn[current] = ++t, rank[t] = current, top[current] = chainTop;
    if (child[current] && (secondDFS(child[current], chainTop), true))
        for (int next : tree[current])
            if (next != parent[current] && next != child[current])
                secondDFS(next, next);
}

std::pair<int, int> pathQuery(int x, int y) {
    std::pair<int, int> answer(-Infinity, -Infinity);
    for (; top[x] != top[y]; x = parent[top[x]]) {
        depth[top[x]] < depth[top[y]] && (std::swap(x, y), true);
        answer = merge(answer, query(dfn[top[x]], dfn[x], 1, 1, n));
    }
    depth[x] > depth[y] && (std::swap(x, y), true);
    return merge(answer, query(dfn[x], dfn[y], 1, 1, n));
}

int main() {
    std::cin.tie(nullptr)->sync_with_stdio(false);
    std::cin >> n;
    for (int i = n; --i; ) {
        std::cin >> u >> v;
        tree[u].push_back(v), tree[v].push_back(u);
    }
    std::for_each(value.begin() + 1, value.begin() + n + 1, [](int& i) -> void { std::cin >> i, valueSet.insert(i); });
    firstDFS(1, 1), secondDFS(1, 1), build(1, 1, n);
    for (std::cin >> q; q--; ) {
        if (std::cin >> o >> u >> v, o == 0) {
            valueSet.erase(valueSet.find(value[u])), valueSet.insert(value[u] += v), modify(dfn[u], value[u], 1, 1, n);
        } else if (o == 1) {
            std::pair<int, int> Aanswer = pathQuery(u, v);
            if (Aanswer.first == -Infinity || Aanswer.second == -Infinity) {
                std::cout << "-1\n";
            } else {
                valueSet.erase(valueSet.find(Aanswer.first)), valueSet.erase(valueSet.find(Aanswer.second));
                std::cout << Aanswer.second << ' ' << *valueSet.upper_bound(*valueSet.begin()) << '\n';
                valueSet.insert(Aanswer.first), valueSet.insert(Aanswer.second);
            }
        }
    }
    return 0;
}
```

---

## 作者：Union_Find (赞：2)

蒟蒻成功的通过这道题复习了 STL 的 set 和 multiset，写篇题解讲一下思考过程。

## 取模最大值怎么处理

首先看题目，比较难处理的是其实是找到 $w_x \bmod w_y$ 的最大值，所以我们不妨设 $w_x < w_y$，那么就会得到 $w_x \bmod w_y = w_x,w_y \bmod w_x < w_x$，所以 $w_y \bmod w_x < w_x \bmod w_y$，也就是说我们肯定是让小的值模大的值，答案为小的值。

综上所述，$w_y$ 一定是最大值，$w_x$ 一定是**严格**次大值，所以第一问的答案就是 $u$ 到 $v$ 链上的**严格**次大值。

## 如何维护链上的严格次大值

首先因为在链上的操作，所以先树链剖分，问题变成了如何维护区间严格次大值。

考虑线段树，存的值就一定是区间的最大值和严格次大值，单点修改直接改就行，难点在于合并。

如果你不想要大力分讨，就可以选择使用 set。我们将两个儿子的最大值和严格最大值扔进 set 里，然后取出前两个。因为 set 会自动排掉相同的值，所以得出的就是**严格**次大值。

同理，树链剖分的合并可以用同样的方法，这样子时间复杂度是 $O(n \log^2n)$ 的。

## 第二问怎么办呢

首先取模最大值和第一问一样，但是我们要把第一问的最大值和严格次大值拿掉，所以可以用 multiset，因为 multiset 可以重复存元素。

我们把所有元素丢进 multiset 里，然后每次询问先将最大值和严格次大值删掉，就可以用 multiset 查询最大值和严格次大值了。

## 修改如何操作

我们现在用了线段树和 multiset，只要分别修改即可。

## 细节

- 你猜我为什么前面要加粗**严格**？
- 查询时删掉的最大值和严格次大值要加回来。
- multiset 的 erase 操作的参数是地址，不要像我一样写成值然后调半天。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define il inline
#define N 100005
il ll rd(){
	ll s = 0, w = 1;
	char ch = getchar();
	for (;ch < '0' || ch > '9'; ch = getchar()) if (ch == '-') w = -1;
	for (;ch >= '0' && ch <= '9'; ch = getchar()) s = ((s << 1) + (s << 3) + ch - '0');
	return s * w;
}multiset <ll> st;
ll n = rd(), u, v, a[N], op, id[N], en, tp[N], fa[N], dep[N], sz[N], son[N];
vector <ll> e[N];
struct P{
	ll mx1, mx2;
}tr[N << 2];
P operator + (const P &x, const P &y){
	P ans, a = x, b = y;
	set <ll, greater<ll> > s;
	s.insert(a.mx1), s.insert(a.mx2), s.insert(b.mx1), s.insert(b.mx2);
	ans.mx1 = *s.begin(), s.erase(ans.mx1);
	if (s.size()) ans.mx2 = *s.begin();
	else ans.mx2 = -1;
	return ans;
}
void dfs1(ll u){
	dep[u] = dep[fa[u]] + 1, sz[u] = 1;
	for (int v : e[u]){
		if (v == fa[u]) continue;
		fa[v] = u, dfs1(v);
		sz[u] += sz[v];
		if (sz[son[u]] < sz[v]) son[u] = v;
	}
}void dfs2(ll u, ll top){
	tp[u] = top, id[u] = ++en;
	if (son[u]) dfs2(son[u], top);
	for (int v : e[u]) if (v != fa[u] && v != son[u]) dfs2(v, v);
}void add(ll p, ll l, ll r, ll x, ll k){
	if (l == r) return tr[p].mx1 += k, void(0);
	ll mid = (l + r) >> 1;
	if (x <= mid) add(p << 1, l, mid, x, k);
	else add(p << 1 | 1, mid + 1, r, x, k);
	tr[p] = tr[p << 1] + tr[p << 1 | 1];
}P ask(ll p, ll l, ll r, ll nl, ll nr){
	if (nl <= l && r <= nr) return tr[p];
	ll mid = (l + r) >> 1;
	if (nl <= mid && nr > mid) return ask(p << 1, l, mid, nl, nr) + ask(p << 1 | 1, mid + 1, r, nl, nr);
	if (nl <= mid) return ask(p << 1, l, mid, nl, nr);
	if (nr > mid) return ask(p << 1 | 1, mid + 1, r, nl, nr);
}P aske(ll u, ll v){
	set <ll, greater<ll> > s;
	while (tp[u] != tp[v]){
		if (dep[tp[u]] < dep[tp[v]]) swap(u, v);
		P nt = ask(1, 1, n, id[tp[u]], id[u]);
		s.insert(nt.mx1);
		if (nt.mx2 != -1) s.insert(nt.mx2);
		u = fa[tp[u]];
	}if (dep[u] > dep[v]) swap(u, v);
	P nt = ask(1, 1, n, id[u], id[v]);
	s.insert(nt.mx1);
	if (nt.mx2 != -1) s.insert(nt.mx2);
	P ans;
	ans.mx1 = *s.begin(), s.erase(ans.mx1);
	if (s.size()) ans.mx2 = *s.begin();
	else ans.mx2 = -1;
	return ans;
}
int main(){
	for (int i = 1; i < n; i++){
		u = rd(), v = rd();
		e[u].push_back(v), e[v].push_back(u);
	}for (int i = 1; i <= n; i++) a[i] = rd(), st.insert(a[i]);
	dfs1(1), dfs2(1, 1);
	for (int i = 1; i <= 4 * n; i++) tr[i].mx2 = -1;
	for (int i = 1; i <= n; i++) add(1, 1, n, id[i], a[i]);
	for (int T = rd(); T--;){
		op = rd(), u = rd(), v = rd();
		if (op == 1){
			P nt = aske(u, v);
			ll mx1 = nt.mx1, mx2 = nt.mx2, mp1 = 0, mp2 = 0;
			if (mx2 == -1){
				puts("-1");
				continue;
			}
			st.erase(st.find(mx1)), st.erase(st.find(mx2));
			mp1 = *--st.end();
			mp2 = *(--st.lower_bound(mp1));
			st.insert(mx1), st.insert(mx2);
			printf ("%lld %lld\n", mx2, mp2);
		}else{
			st.erase(st.find(a[u])), a[u] += v, st.insert(a[u]);
			add(1, 1, n, id[u], v);
		}
	}
	return 0;
}

```

---

## 作者：Hoks (赞：2)

## 前言
补树剖题单的时候突然发现的简单题，就来水了下，结果出了一堆锅，警钟长鸣。
## 思路分析
首先看下题目条件里得分是 $w_x \bmod w_y$，带个取模，有点不好做啊。

实际上我们可以发现这个取模就是用来吓人的，显然的是当 $w_y$ 为最大值，$w_x$ 为次大值时得分最大。

给个简短证明：$w_x$ 为次大值，所以能比 $w_x$ 更大的得分只有最大值 $w_y$。

但是当我们把 $w_y$ 作为被取模的数时，限制得分最大值的东西变成了模数。

也就是得分肯定会小于模数。

而此时最大的模数便是次大值 $w_x$。

所以这样的得分是小于 $w_x \bmod w_y$ 的。

也就是得分即为次大值。

okkkk，有了一个小推论再来看这题，小 A 的得分就很好算了。

直接树剖把路径剖分为链，链再用线段树合并大力维护次大值即可。

这个时候我们发现题目里还让我们求小 B 的得分最大值。

因为是整颗树中的数（除小 A 选择的两个外）都可以选择。

所以直接考虑 STL 中的 multiset 来维护。

至此便完成了本题，只不过我在实现的时候写了三个大锅。

**下面的三个锅如果全部看出来，请评论写出错误的地方并修正，悬赏一关捏。**

```cpp
void add(int u,int v){e[++tot].v=v,e[tot].nxt=head[u];head[u]=e[tot].nxt;}
```

```cpp
void dfs1(int u,int ff)
{
	fa[u]=ff,dep[u]=dep[ff]+1,si[u];
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].v;
		if(v==ff) continue;
		dfs1(v,u);si[u]+=si[v];
		if(si[son[u]]<si[v]) son[u]=v;
	}
}
```

```cpp
else
{
	tree ans=query(1,1,n,x,y);
	if(ans.mxx==-1){puts("-1");continue;}
	print(ans.mxx),putchar(' ');
	b.erase(b.find(ans.mx)),b.erase(b.find(ans.mxx));
	print(*(--b.lower_bound(*--b.end())));
	b.insert(ans.mx),b.insert(ans.mxx);puts("");
}
```
## 代码
为了找锅的进行，完整代码就不贴了捏，但是会给出树链查询以及线段树部分。

```cpp
#include <bits/stdc++.h>
#define ls (p<<1)
#define rs (p<<1|1)
#define mid ((l+r)>>1)
#define int long long
using namespace std;
const int N=100010,INF=0x3f3f3f3f3f3f3f3f;
struct edge
{int v,nxt;}e[N<<1];
struct tree
{int mx,mxx;}t[N<<2];
int n,q,tot,cnt;
int head[N],top[N],dfn[N],id[N],a[N];
int fa[N],son[N],si[N],dep[N];
multiset<int>b;
static char buf[1000000],*paa=buf,*pd=buf;
#define getchar() paa==pd&&(pd=(paa=buf)+fread(buf,1,1000000,stdin),paa==pd)?EOF:*paa++
inline int read(void){
    int x(0),a(1);char fc(getchar());
    while(!isdigit(fc)){if(fc=='-') a=-1;fc=getchar();}
    while(isdigit(fc)) x=(x<<1)+(x<<3)+(fc^48),fc=getchar();
    return x*a;
}
inline void print(int x)
{
	if(x<0) putchar('-'),x=-x;
	if(x>9) print(x/10);
	putchar(x%10+'0');
}
第一个锅喵
第二个锅喵
void dfs2(int u,int topf)
{
	top[u]=topf,dfn[u]=++cnt,id[cnt]=u;
	if(son[u]) dfs2(son[u],topf);
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].v;
		if(v==fa[u]||v==son[u]) continue;
		dfs2(v,v);
	}
}
tree merge(tree a,tree b)
{
	int mx=max(a.mx,b.mx);
	return {mx,max(a.mx==mx?a.mxx:a.mx,b.mx==mx?b.mxx:b.mx)}; 
}
void build(int p,int l,int r)
{
	if(l==r) return void(t[p]={a[id[l]],-1});
	build(ls,l,mid),build(rs,mid+1,r);
	t[p]=merge(t[ls],t[rs]);
}
void modify(int p,int l,int r,int x,int k)
{
	if(l==r&&l==x) return void(a[id[l]]+=k),void(t[p].mx=a[id[l]]),void(t[p].mxx=-1);
	if(mid>=x) modify(ls,l,mid,x,k);
	else modify(rs,mid+1,r,x,k);
	t[p]=merge(t[ls],t[rs]);
}
tree query(int p,int l,int r,int s,int e)
{
	if(s<=l&&r<=e) return t[p];
	tree res={-1,-1};
	if(s<=mid) res=merge(res,query(ls,l,mid,s,e));
	if(mid<e) res=merge(res,query(rs,mid+1,r,s,e));
	return res;
}
tree query(int x,int y)
{
	tree ans={-1,-1};
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		ans=merge(ans,query(1,1,n,dfn[top[x]],dfn[x]));
		x=fa[top[x]];
	}
	if(dfn[x]>dfn[y]) swap(x,y);
	return merge(ans,query(1,1,n,dfn[x],dfn[y]));
}
signed main()
{
	n=read();
	for(int i=1,u,v;i<n;i++) u=read(),v=read(),add(u,v),add(v,u);
	for(int i=1;i<=n;i++) a[i]=read(),b.insert(a[i]);
	dfs1(1,0),dfs2(1,1),build(1,1,n);q=read();
	for(int i=1,op,x,y;i<=q;i++)
	{
		op=read(),x=read(),y=read();
		if(op==0)
		{
			b.erase(b.find(a[x]));b.insert(a[x]+y);
			modify(1,1,n,dfn[x],y);
		}
		第三个锅喵
	}
	return 0;
}
```


---

## 作者：ekatsim (赞：2)

# **这是一篇只用到树链剖分和线段树的题解**
~~（当然大体和之前各位巨佬的题解还是一样的）~~
# 题目
[ingteresting の game](https://www.luogu.com.cn/problem/P6157)
# 思路
拿到题目，我们~~很容易~~看出小 A 和小 B 的最优选法：取出权值**严格最大的两个点**，**第二大**的做 **Wx**，**最大**的做 **Wy**。

考虑小 A 的选择会对小 B 造成影响（小 A 选的两个点小 B 不能选），我们就自然而然的想出用**树链剖分**和**线段树**维护整棵树的**严格前四大值**来供小 A 和小 B 选择。

然后本题解就结束了（雾）

------------

如果真的用线段树维护**严格前四大值**，先不考虑这么做思路上有没有漏洞，写起来肯定超超超麻烦！！！（~~本蒟蒻还没动手就预料到自己会写挂~~），于是考虑~~偷工减料~~只维护**严格最大的两个值**。

只维护**严格前二大值**的话，小 A 倒是好办——对应树链所维护的严格前两大值就是 TA 的最优选择，但对于在整颗树上查询的小 B 我们又该如何求解？

换句话说，我们要在整颗树上进行查询，而且要保证查询的点合法（即没有小 A 选过的点）。想到这里，你可能会不由得感叹，要是能把小 A 选过的点**扣去**就好了。

等等，**把小 A 选的点扣去**？

虽然我们没有办法真的把小 A 选过的点给“**扣去**”，但是只要我们**不查询**这个点，不就相当于把 TA 给扣去了嘛？

- 考虑小 A 只会选择两个点，那我们只要在**维护前两大值时顺带记录该值在线段树上的“位置”**，查询整棵树（因为小 B 是在整棵树上选嘛）的时候空开该位置就可以了。

### 于是，AC get!

~~没想到加了句快读吸口氧居然暂时 Rank1 了~~

代码写的很乐色，请酌情食用 QAQ
```cpp
#include <bits/stdc++.h>
#define lson(x) x<<1
#define rson(x) x<<1|1
using namespace std;
const int maxn=1e5+5;
struct edges
{
    int to,next;
}edge[maxn*2];
int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
int n,m;
int head[maxn],cnt;
void addedge(int from,int to)//链式前向星
{
    edge[++cnt]={from,head[to]};
    head[to]=cnt;
    edge[++cnt]={to,head[from]};
    head[from]=cnt;
}
int all[maxn];
int size[maxn],dep[maxn],son[maxn],fa[maxn];//经典树剖套路
void dfs1(int now,int f)
{
    size[now]=1;
    dep[now]=dep[f]+1;
    fa[now]=f;
    int mmax=0;
    for(int i=head[now];i!=-1;i=edge[i].next)
    {
        if(edge[i].to==f)
            continue;
        dfs1(edge[i].to,now);
        size[now]+=size[edge[i].to];
        if(size[edge[i].to]>mmax)
        {
            mmax=size[edge[i].to];
            son[now]=edge[i].to;
        }
    }
}
int top[maxn],id[maxn],init[maxn],idx;
void dfs2(int now,int topf)
{
    id[now]=++idx;
    top[now]=topf;
    init[idx]=all[now];
    if(!son[now])
        return ;
    dfs2(son[now],topf);
    for(int i=head[now];i!=-1;i=edge[i].next)
    {
        if(id[edge[i].to]==0)
            dfs2(edge[i].to,edge[i].to);
    }
}
struct node
{
    int mmax,submax,id1,id2;
}tree[maxn<<2];//线段树维护严格最大值，严格次大值与其在线段树上的下标
node getmax(node a,node b)//这里写的不太好，其实和下面的线段树push_up合并节点是一样的
{
    node c;
    if(a.mmax>b.mmax)
    {
        c.mmax=a.mmax;
        c.id1=a.id1;
        if(a.submax>b.mmax)
        c.submax=a.submax,c.id2=a.id2;
        else
        c.submax=b.mmax,c.id2=b.id1;
    }
    else if(a.mmax<b.mmax)
    {
        c.mmax=b.mmax;
        c.id1=b.id1;
        if(b.submax>a.mmax)
        c.submax=b.submax,c.id2=b.id2;
        else
        c.submax=a.mmax,c.id2=a.id1;
    }
    else
    {
        c.mmax=a.mmax;
        c.id1=a.id1;
        if(a.submax>b.submax)
          c.submax=a.submax,c.id2=a.id2;
        else
           c.submax=b.submax,c.id2=b.id2;
    }
    return c;
}
void push_up(int now)//线段树push_up合并节点
{
    if(tree[lson(now)].mmax>tree[rson(now)].mmax)
    {
        tree[now].mmax=tree[lson(now)].mmax;
        tree[now].id1=tree[lson(now)].id1;
        if(tree[lson(now)].submax>tree[rson(now)].mmax)
        tree[now].submax=tree[lson(now)].submax,tree[now].id2=tree[lson(now)].id2;
        else
        tree[now].submax=tree[rson(now)].mmax,tree[now].id2=tree[rson(now)].id1;
    }
    else if(tree[lson(now)].mmax<tree[rson(now)].mmax)
    {
        tree[now].mmax=tree[rson(now)].mmax;
        tree[now].id1=tree[rson(now)].id1;
        if(tree[rson(now)].submax>tree[lson(now)].mmax)
        tree[now].submax=tree[rson(now)].submax,tree[now].id2=tree[rson(now)].id2;
        else
        tree[now].submax=tree[lson(now)].mmax,tree[now].id2=tree[lson(now)].id1;
    }
    else
    {
        tree[now].mmax=tree[lson(now)].mmax;
        tree[now].id1=tree[lson(now)].id1;
        if(tree[lson(now)].submax>tree[rson(now)].submax)
          tree[now].submax=tree[lson(now)].submax,tree[now].id2=tree[lson(now)].id2;
        else
           tree[now].submax=tree[rson(now)].submax,tree[now].id2=tree[rson(now)].id2;
    }
}
void build(int l,int r,int now=1)
{
    if(l==r)
    {
        tree[now].mmax=init[l];//初始化严格最大值，由于底层单个节点并没有严格次大值，就让ta为0就可以了
        tree[now].id1=l;//初始化id1记录严格最大值的下标，id2初始化为0
        return ;
    }
    int mid=l+r>>1;
    build(l,mid,lson(now));
    build(mid+1,r,rson(now));
    push_up(now);
}
void update(int l,int r,int idx,int num,int now=1)
{
    if(l==r)
    {
        tree[now].mmax+=num;
        return ;
    }
    int mid=l+r>>1;
    if(idx<=mid)
        update(l,mid,idx,num,lson(now));
    else
        update(mid+1,r,idx,num,rson(now));
    push_up(now);
}
node ask(int l,int r,int upl,int upr,int now=1)
{
    if(upl<=l&&upr>=r)
        return tree[now];
    int mid=l+r>>1;
    if(upr<=mid)
        return ask(l,mid,upl,upr,lson(now));
    else if(upl>mid)
        return ask(mid+1,r,upl,upr,rson(now));
    else
        return getmax(ask(l,mid,upl,upr,lson(now)),ask(mid+1,r,upl,upr,rson(now)));
}
void splitask(int x,int y)
{
    node ans={0,0},temp;
    while(top[x]!=top[y])
    {
        if(dep[top[x]]<dep[top[y]])
            swap(x,y);
        temp=ask(1,n,id[top[x]],id[x]);
        ans=getmax(ans,temp);
        x=fa[top[x]];
    }
     if(dep[x]<dep[y])
            swap(x,y);
        temp=ask(1,n,id[y],id[x]);
        ans=getmax(ans,temp);
    if(ans.submax==0)//如果严格次大值为0，只能说明无严格次大值。
        printf("-1\n");
    else
    {
        node ans2={0,0};
        if(ans.id1>ans.id2)
            swap(ans.id1,ans.id2);
        if(ans.id1!=1)//把小A选过的两个点空开，注意判断边界问题
        {
            temp=ask(1,n,1,ans.id1-1);
            ans2=getmax(ans2,temp);
        }
        if(ans.id2-ans.id1!=1)
        {
            temp=ask(1,n,ans.id1+1,ans.id2-1);
            ans2=getmax(ans2,temp);
        }
        if(ans.id2!=n)
        {
            temp=ask(1,n,ans.id2+1,n);
            ans2=getmax(ans2,temp);
        }
        printf("%d %d\n",ans.submax,ans2.submax);
    }
}
int main()
{
    memset(head,-1,sizeof(head));
    n=read();
    int from,to;
    for(int i=1;i<n;i++)
    {
        from=read(),to=read();
        addedge(from,to);
    }
    for(int i=1;i<=n;i++)
        all[i]=read();
    dfs1(1,0);
    dfs2(1,1);
    build(1,n);
    m=read();
    int opt,x,y;
    for(int i=1;i<=m;i++)
    {
        opt=read(),x=read(),y=read();
        if(opt==1)
            splitask(x,y);
        else
            update(1,n,id[x],y);
    }
	return 0;
}

```


---

## 作者：hh20080501hh (赞：1)

# 题面
[题面戳我哦](https://www.luogu.com.cn/problem/P6157)

题意简述：给你一颗树，树有点权。每次操作可以修改一个点的点权，使其点权加上 $y$；或者查询一条路径上两个点取模的最大值 $a\in L_{a,b}$，$b\in L_{a,b}$，求 $a\bmod b$ 的最大值，并且还要求出 $x \neq a$ 且 $x \neq b$ 且 $y \neq a$ 且 $y \neq b$ 的 $x \bmod y$ 的最大值。

# 分析
看到题面不难想到是树剖题目，并且树剖的操作很简单。但是有一个很困难的点：取模应该怎么维护？

取模有很多奇妙的性质，所以我们可以考虑转化一下维护的信息，不去维护取模。我们发现对于任何一个取模操作，最终的结果是一定小于模数的，所以要使结果大，那我们也应该使模数大。特别地，如果当模数与被模数相等的时候，结果为零。

那其实我们就是要维护一条路径上的最大值和**严格**次小值。

下面给出一个简单的证明：记该路径上所有点的点集为 $E$，假设 $x\in E$，$y\in E$，且 $x$ 是最大的，$y$ 是**严格**次大的，那么这条链上一个比较大的答案就是 $y \bmod x$。假设现在有一个数 $a$ 比 $x$ 和 $y$ 都严格小于，那么由于取模结果一定会小于模数，所以 $a \bmod y < y \bmod x$，又由于 $a<y$，所以 $a\bmod x<y\bmod x$。若 $a$ 作为模数，由于取模结果一定会小于模数，所以对于任意一点 $b$，$b \bmod a < b \bmod x$。即 $y \bmod x$ 一定是最大的答案。

那线段树维护的东西搞定了，对于第一问我们就搞定了，现在考虑如何解决第二问。

首先很容易想到开一个桶暴力维护，但是这种做法的时间我们是显然承受不了的，所以我们选择使用 STL。我们开一个可以有重复元素的 set，即 multiset 来存储，每次把第一问选择的两个点从 set 里面删除，然后找**严格**第二大的（证明同上），再将删掉的加进来。

如何寻找**严格**第二大的元素？首先我们可以找到 multiset 中的最大值，即 `*--s.end()`，找到最大值后，我们找第一个最大值的位置，即 `lower_bound(*--s.end())`，然后它前面一个元素就是严格第二大的了！即 `*(--s.lower_bound(*--s.end()))`。

# 代码
说了那么多，代码也不难实现了，就是树剖板子加上线段树板子加上一个 multiset。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5+10 , M = N<<1 , INF = 1e8;

int n , m;
int h[N] , e[M] , ne[M] , w[N] , idx;
int dep[N] , fa[N] , sz[N] , son[N];
int dfn[N] , nw[N] , top[N] , timestamp;
struct node
{
	int l , r;
	int mx , sc;
	node operator +(const node &o) const
	{
		node res;
		res.mx = max(o.mx , mx);
		res.sc = max(o.mx==res.mx?o.sc:o.mx , mx==res.mx?sc:mx);
		res.l = min(l , o.l) , res.r = max(r , o.r);
		return res;
	}
}tr[N<<2];
multiset <int> s;

inline void add (int a , int b)
{
	e[idx] = b , ne[idx] = h[a] , h[a] = idx++;
}

void dfs1 (int u)
{
	sz[u] = 1;
	for (int i=h[u] ; i!=-1 ; i=ne[i])
	{
		int j = e[i];
		if (j==fa[u]) continue;
		dep[j] = dep[u]+1 , fa[j] = u;
		dfs1 (j);
		sz[u] += sz[j];
		if (sz[son[u]]<sz[j]) son[u] = j;
	}
}

void dfs2 (int u , int t)
{
	dfn[u] = ++timestamp , nw[timestamp] = w[u] , top[u] = t;
	if (!son[u]) return;
	dfs2 (son[u] , t);
	for (int i=h[u] ; i!=-1 ; i=ne[i])
	{
		int j = e[i];
		if (j==fa[u] || j==son[u]) continue;
		dfs2 (j , j);
	}
}

inline void pushup (int u)
{
	tr[u] = tr[u<<1] + tr[u<<1|1];
}

void build (int u , int l , int r)
{
	if (l==r)
	{
		tr[u] = {l , r , nw[l] , -INF};
	}
	else 
	{
		tr[u].l = l , tr[u].r = r;
		int mid = (l+r)>>1;
		build (u<<1 , l , mid) , build (u<<1|1 , mid+1 , r);
		pushup (u);
	}
}

void modify (int u , int id , int x)
{
	if (tr[u].l==dfn[id] && tr[u].r==dfn[id])
	{
		w[id] += x;
		tr[u].mx += x;
	}
	else 
	{
		int mid = (tr[u].l+tr[u].r)>>1;
		if (dfn[id]<=mid) modify (u<<1 , id , x);
		else modify (u<<1|1 , id , x);
		pushup (u);
	}
}

node query (int u , int l , int r)
{
	if (l<=tr[u].l && tr[u].r<=r)
	{
		return tr[u];
	}
	else 
	{
		int mid = (tr[u].l+tr[u].r)>>1;
		node res = {INF , -INF , -INF , -INF};
		if (l<=mid) res = res + query(u<<1 , l , r);
		if (r>mid) res = res + query(u<<1|1 , l , r);
		return res;		
	}
}

node query_path (int u , int v)
{
	node res = {INF , -INF , -INF , -INF};
	while (top[u]!=top[v])
	{
		if (dep[top[u]]<dep[top[v]]) swap (u , v);
		node tmp = query (1 , dfn[top[u]] , dfn[u]);
		res = res + tmp;
		u = fa[u];
	}
	if (dep[u]<dep[v]) swap (u , v);
	res = res + query (1 , dfn[v] , dfn[u]);
	return res;
} 

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL); cout.tie(NULL);
	
	memset (h , -1 , sizeof h);
	cin >> n;
	for (int i=1 ; i<n ; i++)
	{
		int a , b;
		cin >> a >> b;
		add (a , b) , add (b , a);
	}
	for (int i=1 ; i<=n ; i++)
	{
		cin >> w[i];
		s.insert(w[i]);
	}
	
	dep[1] = 0 , fa[1] = -1 , dfs1 (1);
	dfs2 (1 , 1);
	build (1 , 1 , n);
	
	cin >> m;
	while (m--)
	{
		int op , u , v;
		cin >> op >> u >> v;
		if (!op)
		{
			s.erase(s.find(w[u])) , s.insert(w[u]+v);
			modify (1 , u , v);
		}
		else 
		{
			node tmp = query_path(u , v);
			if (tmp.sc==-INF)
			{
				cout << -1 << '\n';
				continue;
			}
			cout << tmp.sc << ' ';
			s.erase(s.find(tmp.mx)) , s.erase(s.find(tmp.sc));
			int ans = *(--s.lower_bound(*--s.end()));
			cout << ans << '\n';
			s.insert(tmp.mx) , s.insert(tmp.sc); 
		}                
	}
	return 0;
}
```

---

## 作者：creation_hy (赞：1)

~~有一点思维难度但不多~~

首先次大值模最大值可以取到次大值，然后因为 $x\bmod y\le \min(x,y)$，所以其他情况都不可能超过次大，所以答案就是链上的严格次大值，树剖套线段树可以轻松维护。

然后第二问直接维护一个 multiset，删掉第一问两个数求严格次大即可。

~~为了防止暴毙我合并直接暴力排序了~~

时间复杂度 $O(n\log^2n)$

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 4e5 + 5;
int n, q, head[N], to[N], nxt[N], etot, a[N];
multiset<int> s;
inline void link(int u, int v)
{
    to[etot] = v;
    nxt[etot] = head[u];
    head[u] = etot++;
}
struct node
{
    int a[2];
    inline node(int x = 0, int y = 0) { a[0] = x, a[1] = y; }
    inline node operator+(const node &t) const
    {
        int val[4] = {a[0], a[1], t.a[0], t.a[1]};
        node res;
        sort(val, val + 4, greater<int>());
        for (int i = 0; i < 4; i++)
            if (!i || val[i] != val[i - 1])
            {
                if (!res.a[0])
                    res.a[0] = val[i];
                else
                {
                    res.a[1] = val[i];
                    break;
                }
            }
        return res;
    }
};
struct SegTree
{
    node f[N];
    inline int ls(int p) { return p << 1; }
    inline int rs(int p) { return p << 1 | 1; }
    inline void push_up(int p) { f[p] = f[ls(p)] + f[rs(p)]; }
    inline void update(int p, int l, int r, int x, int k)
    {
        if (l == r)
        {
            f[p].a[0] += k;
            return;
        }
        int mid = l + r >> 1;
        if (x <= mid)
            update(ls(p), l, mid, x, k);
        else
            update(rs(p), mid + 1, r, x, k);
        push_up(p);
    }
    inline node query(int p, int l, int r, int qx, int qy)
    {
        if (l > r)
            exit(0);
        if (qx <= l && r <= qy)
            return f[p];
        int mid = l + r >> 1;
        node res;
        if (qx <= mid)
            res = res + query(ls(p), l, mid, qx, qy);
        if (mid < qy)
            res = res + query(rs(p), mid + 1, r, qx, qy);
        return res;
    }
} seg;
struct HLD
{
    int sz[N], son[N], id[N], cnt, top[N], up[N], dep[N];
    inline void dfs1(int x, int fa)
    {
        sz[x] = 1, dep[x] = dep[up[x] = fa] + 1;
        for (int i = head[x]; ~i; i = nxt[i])
            if (to[i] != fa)
            {
                dfs1(to[i], x), sz[x] += sz[to[i]];
                if (sz[to[i]] > sz[son[x]])
                    son[x] = to[i];
            }
    }
    inline void dfs2(int x, int fa, int tp)
    {
        id[x] = ++cnt, top[x] = tp;
        if (son[x])
            dfs2(son[x], x, tp);
        for (int i = head[x]; ~i; i = nxt[i])
            if (to[i] != fa && to[i] != son[x])
                dfs2(to[i], x, to[i]);
    }
    inline void update(int x, int k) { seg.update(1, 1, n, id[x], k); }
    inline node query(int x, int y)
    {
        node res;
        while (top[x] != top[y])
        {
            if (dep[top[x]] < dep[top[y]])
                swap(x, y);
            res = res + seg.query(1, 1, n, id[top[x]], id[x]);
            x = up[top[x]];
        }
        if (dep[x] > dep[y])
            swap(x, y);
        res = res + seg.query(1, 1, n, id[x], id[y]);
        return res;
    }
} hld;
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    memset(head, -1, sizeof(head));
    cin >> n;
    for (int i = 1, u, v; i < n; i++)
        cin >> u >> v, link(u, v), link(v, u);
    hld.dfs1(1, 0), hld.dfs2(1, 0, 1);
    for (int i = 1, x; i <= n; i++)
        cin >> x, hld.update(i, x), s.insert(x), a[i] = x;
    cin >> q;
    while (q--)
    {
        int op, x, y;
        cin >> op >> x >> y;
        if (!op)
            hld.update(x, y), s.erase(s.find(a[x])), s.insert(a[x] += y);
        else
        {
            node res = hld.query(x, y);
            if (res.a[1])
            {
                s.erase(s.find(res.a[0])), s.erase(s.find(res.a[1]));
                cout << res.a[1] << ' ' << *--s.lower_bound(*s.rbegin()) << '\n';
                s.insert(res.a[0]), s.insert(res.a[1]);
            }
            else
                cout << "-1\n";
        }
    }
    return 0;
}
```

---

## 作者：modfisher (赞：1)

## 思路
很容易发现，题目所求其实就是某条链上的次大值。

------------


证明：

设最大值为 $a$，次大值为 $b$。

显然 $w_x\bmod w_y<w_y$。

如果取 $w_y=a$，肯定取 $w_x=b$ 最优，此时结果为 $b$。

如果取 $w_y=k$（$k\leq b$)，有 $w_x\bmod k<k\leq b$，结果最大都只有 $b$。

所以结果最大就是次大值 $b$。

------------

这道题最恶心的点就在于它还要求除了选出来的两数外的次大值。这迫使我们维护所有点中前四大的**不同的**权值。之后简称前四大权值，但请注意这四个值是**不同的**。

先用树剖将树上操作转换为区间操作。

所以可以建一棵线段树，维护每一段区间的前四大的权值，说着容易，做起来是真的麻烦。方法实在不会请去看代码。

最后是选择除查询区间选取的两数外的最大值和次大值。在这里要注意，尽管选出的两数必须不同，但是可以和第一次选出的两数相同。所以还要开个桶，如果桶中第一次选出来的数有多个就不用管，只有一个的话，就必须把所有点中的前四大值中和其相同的值去掉，最后取最大和次大。

可能讲得不是很清楚，作者尽力了，实在不懂得看代码或其他题解吧。

## 代码
```cpp
#include <bits/stdc++.h>
#define l(x) (x << 1)
#define r(x) (x << 1 | 1)

using namespace std;

const int maxn = 1e5 + 5;

struct pair4{
	int a, b, c, d;
};
struct node{
	int l, r;
	pair4 mx;
}t[maxn << 2];
int tol[10], res[5];
int a[maxn], head[maxn], nxt[maxn << 1], to[maxn << 1], cnt = 0;
int fa[maxn], dep[maxn], siz[maxn], son[maxn];
int dfn[maxn], inv[maxn], top[maxn], dnt = 0;
map<int, int> mp;

void add(int u, int v){
	nxt[++ cnt] = head[u];
	to[cnt] = v;
	head[u] = cnt;
}
void dfs1(int x, int f){
	fa[x] = f;
	dep[x] = dep[f] + 1;
	siz[x] = 1;
	for(int i = head[x]; i; i = nxt[i]){
		int j = to[i];
		if(j == f) continue;
		dfs1(j, x);
		siz[x] += siz[j];
		if(siz[j] > siz[son[x]]) son[x] = j;
	}
}
void dfs2(int x, int tp){
	dfn[x] = ++ dnt;
	inv[dnt] = x;
	top[x] = tp;
	if(son[x]) dfs2(son[x], tp);
	for(int i = head[x]; i; i = nxt[i]){
		int j = to[i];
		if(j == fa[x] || j == son[x]) continue;
		dfs2(j, j);
	}
}
pair4 maxer(pair4 l, pair4 r){ //合并两个区间 
	tol[1] = l.a, tol[2] = l.b, tol[3] = l.c, tol[4] = l.d, tol[5] = r.a, tol[6] = r.b, tol[7] = r.c, tol[8] = r.d; //开两个栈存值，显然从栈顶到栈底单点递减 
	res[1] = res[2] = res[3] = res[4] = 0;
	int k1 = 1, k2 = 5;
	for(int i = 1; i <= 4; i ++){ //枚举前四大值 
		while(k1 <= 4 && tol[k1] == res[i - 1]){ //确保值各不相同 
			k1 ++;
		}
		while(k2 <= 8 && tol[k2] == res[i - 1]){
			k2 ++;
		}
		if(k1 > 4 && k2 > 8){
			break;
		}
		if(k1 > 4){
			res[i] = tol[k2 ++];
			continue;
		}
		if(k2 > 8){
			res[i] = tol[k1 ++];
			continue;
		}
		if(tol[k1] > tol[k2]) res[i] = tol[k1 ++];
		else if(tol[k1] < tol[k2]) res[i] = tol[k2 ++];
		else{
			res[i] = tol[k1];
			k1 ++, k2 ++;
		} //上面一段都是取两个栈中栈顶大的那个 
	}
	return (pair4){res[1], res[2], res[3], res[4]};
}
void up(int x){
	t[x].mx = maxer(t[l(x)].mx, t[r(x)].mx);
}
void build(int x, int l, int r){
	t[x].l = l, t[x].r = r;
	if(l == r){
		t[x].mx = (pair4){a[inv[l]], 0, 0, 0};
		return;
	}
	int mid = l + r >> 1;
	build(l(x), l, mid);
	build(r(x), mid + 1, r);
	up(x);
}
void update(int x, int id, int k){
	if(t[x].l == id && t[x].r == id){
		t[x].mx = (pair4){t[x].mx.a + k, 0, 0, 0};
		return;
	}
	int mid = t[x].l + t[x].r >> 1;
	if(id <= mid) update(l(x), id, k);
	else update(r(x), id, k);
	up(x);
}
pair4 query(int x, int l, int r){
	if(l <= t[x].l && t[x].r <= r){
		return t[x].mx;
	}
	int mid = t[x].l + t[x].r >> 1;
	pair4 p1 = (pair4){0, 0, 0, 0}, p2 = (pair4){0, 0, 0, 0};
	if(l <= mid) p1 = query(l(x), l, r);
	if(r >= mid + 1) p2 = query(r(x), l, r);
	return maxer(p1, p2);
}
pair4 link_query(int u, int v){
	pair4 res = (pair4){0, 0, 0, 0};
	while(top[u] != top[v]){
		if(dep[top[u]] < dep[top[v]]) swap(u, v);
		pair4 p = query(1, dfn[top[u]], dfn[u]);
		res = maxer(res, p);
		u = fa[top[u]];
	}
	if(dep[u] > dep[v]) swap(u, v);
	pair4 p = query(1, dfn[u], dfn[v]);
	res = maxer(res, p);
	return res;
}

int main(){
	int n;
	scanf("%d", &n);
	for(int i = 1; i < n; i ++){
		int u, v;
		scanf("%d %d", &u, &v);
		add(u, v);
		add(v, u);
	}
	for(int i = 1; i <= n; i ++){
		scanf("%d", &a[i]);
		mp[a[i]] ++;
	}
	dfs1(1, 0);
	dfs2(1, 1);
	build(1, 1, n);
	int q;
	scanf("%d", &q);
	while(q --){
		int op, x, y;
		scanf("%d %d %d", &op, &x, &y);
		if(op == 0){
			update(1, dfn[x], y);
			mp[a[x]] --;
			mp[a[x] + y] ++;
			a[x] += y;
		}else{
			pair4 A = link_query(x, y), B = query(1, 1, n);
			int a1 = A.a, a2 = A.b, b1 = 0, b2 = 0;
			if(a2 == 0){
				printf("-1\n");
				continue;
			}
			int x1 = B.a, x2 = B.b, x3 = B.c, x4 = B.d;
			if(mp[a1] == 1){
				if(x1 == a1) x1 = 0;
				if(x2 == a1) x2 = 0;
				if(x3 == a1) x3 = 0;
				if(x4 == a1) x4 = 0;
			}
			if(mp[a2] == 1){
				if(x1 == a2) x1 = 0;
				if(x2 == a2) x2 = 0;
				if(x3 == a2) x3 = 0;
				if(x4 == a2) x4 = 0;
			}
			b1 = max(max(x1, x2), max(x3, x4));
			if(b1 == x1) b2 = max(x2, max(x3, x4));
			if(b1 == x2) b2 = max(x3, x4);
			if(b1 == x3) b2 = x4;
			printf("%d %d\n", a2, b2);
		}
	}
	return 0;
}
```

---

## 作者：gyh20 (赞：1)

其实本题难度只有 $T3$，但因为出题人代码毒瘤了，就把这道题放到了 $T5$。

这里，我们先要证明一个结论:

在一个固定的集合中 $\max(b_i \bmod b_j)=$ 严格次大值 

证明:如果 $b_i>b_j$，那么交换 $b_i,b_j$ 肯定更优(余数小于除数)，如果 $b_i<b_j$，那么 $b_i\bmod b_j=b_i$，所以求的是一个尽可能大而不是最大的值。即为严格次大值。

Subtask1:$n,q \le1000$ 

暴力枚举找严格次大值，时间复杂度 $O(nq)$ 。

Subtask2:数据随机

可以使用各种乱搞方法。

Subtask3:没有修改，点权不多于 $5$ 种。

可以提前离散化+桶，维护到根的所有值个数，询问时减去 $LCA$ 即可。

Subtask4:树为一条链

观察，我们可以用线段树维护区间次大值，假如询问的是 $l,r$，那么只需要求出 $l\sim r$的严格次大值和 $1\sim l-1$ 和 $r+1 \sim n$的严格次大值。所以构建一个可以维护严格次大值的线段树即可。时间复杂度$O((n+q)\log n)$。

Subtask5:无特殊条件

至于小 A，可以想到用树链剖分，维护最大值和严格次大值即可。但对于小 $B$ 来说，我们可以根据 Subtask3 的思想，开桶维护，但开太多桶时间无法接受。可以发现，无论小 A 怎么选，小 B 都可以得到大于严格第四大值的答案（小 A 只能选两个数），所以我们还需要维护一些东西：全局最大值及个数，全局严格次大值及个数，全局严格第三大值及个数，全局严格第四大值。修改的时候维护有点复杂，需要先删掉再加入（如果是全局严格前四大）。

```cpp
#include<bits/stdc++.h>
#pragma comment(linker, "/STACK:102400000,102400000") 
#define in inline
#define re register
using namespace std;
in int read() {
	re int t=0,f=1;
	re char v=getchar();
	while(v<'0'||v>'9') {
		if(v=='-')f=-1;
		v=getchar();
	}
	while(v>='0'&&v<='9') {
		t=(t<<3)+(t*2)+(v^48);
		v=getchar();
	}
	return t*f;
}
int n,m,mx1,mx2,mx3,mx4,cnt1,cnt2,cnt3,fa[100002],siz[100002],dep[100002],son[100002],ans1,mxcnt,seccnt,mxcnt1,ans2,pl[100002],tot,tp[100002],fp[100002],a,b,c,head[200002],cnt,treemx[400002],w[100002],treesec[400002],q;
int s;
struct edge {
	int to,next;
} e[200002];
in void bu(re int x,re int y) {
	e[++cnt].to=y;
	e[cnt].next=head[x];
	head[x]=cnt;
}
in void dfs(re int x,re int y) {
	dep[x]=dep[y]+1;
	siz[x]=1;
	int mxs=0,mxp=0;
	fa[x]=y;
	for(re int i=head[x]; i; i=e[i].next) {
		if(e[i].to!=y) {
			dfs(e[i].to,x);
			if(siz[e[i].to]>mxs) {
				mxs=siz[e[i].to];
				mxp=e[i].to;
			}
			siz[x]+=siz[e[i].to];
		}
	}
	son[x]=mxp;
}
in void dfs1(re int x,re int y) {
	tp[x]=y;
	fp[++tot]=x;
	pl[x]=tot;
	if(son[x])dfs1(son[x],y);
	for(re int i=head[x]; i; i=e[i].next) {
		if(e[i].to!=fa[x]&&e[i].to!=son[x]) {
			dfs1(e[i].to,e[i].to);
		}
	}
}
in void build(re int p,re int l,re int r) {
	if(l==r) {
		treemx[p]=w[fp[l]];
		return;
	}
	build((p*2),l,((l+r)/2));
	build((p*2)+1,((l+r)/2)+1,r);
	if(treemx[p*2]>treemx[p]){
		treesec[p]=treemx[p];
		treemx[p]=treemx[p*2];
	}
	else if(treemx[p*2]>treesec[p]&&treemx[p*2]!=treemx[p]){
		treesec[p]=treemx[p*2];
	}
	if(treesec[p*2]>treesec[p]){
		treesec[p]=treesec[p*2];
	}
	if(treemx[p*2+1]>treemx[p]){
		treesec[p]=treemx[p];
		treemx[p]=treemx[p*2+1];
	}
	else if(treemx[p*2+1]>treesec[p]&&treemx[p*2+1]!=treemx[p]){
		treesec[p]=treemx[p*2+1];
	}
	if(treesec[p*2+1]>treesec[p]){
		treesec[p]=treesec[p*2+1];
	}
}
in void cg(re int p,re int l,re int r,re int x,re int w) {
	if(l==r&&l==x) {
		treemx[p]+=w;
		return;
	}
	if(l>x)return;
	if(r<x)return;
	cg((p*2),l,(l+r)/2,x,w);
	cg((p*2)+1,(l+r)/2+1,r,x,w);
	treemx[p]=treesec[p]=0;
	if(treemx[p*2]>treemx[p]){
		treesec[p]=treemx[p];
		treemx[p]=treemx[p*2];
	}
	else if(treemx[p*2]>treesec[p]&&treemx[p*2]!=treemx[p]){
		treesec[p]=treemx[p*2];
	}
	if(treesec[p*2]>treesec[p]){
		treesec[p]=treesec[p*2];
	}
	if(treemx[p*2+1]>treemx[p]){
		treesec[p]=treemx[p];
		treemx[p]=treemx[p*2+1];
	}
	else if(treemx[p*2+1]>treesec[p]&&treemx[p*2+1]!=treemx[p]){
		treesec[p]=treemx[p*2+1];
	}
	if(treesec[p*2+1]>treesec[p]){
		treesec[p]=treesec[p*2+1];
	}
}

in void askmx(re int p,re int l,re int r,re int x,re int y) {
	if(l>=x&&r<=y) {
		if(treemx[p]>ans1){
			ans2=ans1;
			ans1=treemx[p];
		}
		else if(treemx[p]>ans2&&treemx[p]!=ans1){
			ans2=treemx[p];
		}
		if(treesec[p]>ans2){
			ans2=treesec[p];
		}
		return;
	}
	if(l>y)return;
	if(r<x)return;
	askmx((p*2),l,((l+r)/2),x,y);askmx((p*2)+1,((l+r)/2+1),r,x,y);
	return;
}
inline void add(re int x){//加入一个值，对全局前四大的值的影响 
	if(x>mx1){
		mx4=mx3;
		mx3=mx2;
		cnt3=cnt2;
		mx2=mx1;
		cnt2=cnt1;
		mx1=x;
		cnt1=1;
	}
	else if(x==mx1){
		++cnt1;
	}
	else if(x>mx2){
		mx4=mx3;
		mx3=mx2;
		cnt3=cnt2;
		mx2=x;
		cnt2=1;
	}
	else if(x==mx2){
		++cnt2;
	}
	else if(x>mx3){
		mx4=mx3;
		mx3=x;
		cnt3=1;
	}
	else if(x==mx3){
		++cnt3;
	}
	else if(x>mx4){
		mx4=x;
	}
}
int main() {
	n=read();
	for(re int i=1; i<n; ++i) {
		a=read();
		b=read();
		bu(a,b);
		bu(b,a);
	}
	for(re int i=1; i<=n; ++i){
	w[i]=read();
	add(w[i]);}
	dfs(1,1);
	dfs1(1,1);
	build(1,1,n);
	scanf("%d",&q);
	while(q--) {
		scanf("%d%d%d",&s,&a,&b);
		if(s==0) {
			if(w[a]==mx1){
				--cnt1;
				if(!cnt1){
				cnt1=cnt2;
				cnt2=cnt3;
				mx1=mx2;
				mx2=mx3;
				mx3=mx4;
				}	
			}
			else if (w[a]==mx2){
				--cnt2;	
				if(!cnt2){	
				mx2=mx3;
				mx3=mx4;
				cnt2=cnt3;
				}			
			}
			else if (w[a]==mx3){
				--cnt3;
				if(!cnt3){
				mx3=mx4;
				}	
			}
			w[a]+=b;
			add(w[a]);
			cg(1,1,n,pl[a],b);
		} 
		else {
			ans1=ans2=0;
			while(tp[a]!=tp[b]) {
					if(dep[tp[a]]>dep[tp[b]]) {
						askmx(1,1,n,pl[tp[a]],pl[a]);
						a=tp[a];
						a=fa[a];
					} else {
						askmx(1,1,n,pl[tp[b]],pl[b]);
						b=tp[b];
						b=fa[b];
					}
				}
			if(dep[a]>dep[b])askmx(1,1,n,pl[b],pl[a]);
			else askmx(1,1,n,pl[a],pl[b]);
			int Mx=0,Mx1=0;
			if(ans1==mx1){if(cnt1>=2)Mx=mx1;}
			else Mx=mx1;
			if(ans1==mx2||ans2==mx2){if(cnt2>=2)if(!Mx)Mx=mx2;else Mx1=mx2;}
			else {if(!Mx)Mx=mx2;else Mx1=mx2; }
			if(ans1==mx3||ans2==mx3){if(cnt3>=2)if(!Mx)Mx=mx3;else if(!Mx1)Mx1=mx3;}
			else {if(!Mx)Mx=mx3;else if(!Mx1)Mx1=mx3;}
			if(!Mx1)Mx1=mx4;
			if(ans2)printf("%d %d\n",ans2,Mx1);
			else puts("-1");
		}
	}
}
```






---

## 作者：OIer_ACMer (赞：0)

# 题目解析：

本题我们一开始肯定会从概率论下手，所以，我们要在处理每次输入的两点开始前设置随机数种子，原因的话，每个学过概率论的人都知道这是为了什么。

接着，我们从题目条件下手，如果 $x$ 的点权小于 $y$ 的点权，则最终取余的结果就是 $x$ 的权值，最终结果注定小于 $y$ 的权值。所以如果要让所选出来的数相互取模之后尽可能的大，就要让两数中较小的那一个数作为 $x$ 点，较大的数作为 $y$。所以只需要知道**每一次链中的最大值和严格次大值**，以及剩下的**整棵树**，注意，不是子树中的最大值和严格次大值就行了。这部分，我们想到了什么，对，树链剖分和线段树，代码有点长，不过还好，都是板子。

我们先用第一次深度优先搜索计算每个子树的大小，接着，我们再在 $son$ 数组里记录每个节点的重儿子，注意，我们同时还要记录每个点的父节点是什么以及当前节点的深度，这是树链剖分必不可少的。

第二次深度优先搜索时，我们要连接重链，同时标记每个点的深度优先搜索序号同时，我们还要保证每条重链的点的深度优先搜索序都是连续的毕竟我们之后要用线段树进行维护。

唯一要注意的是线段树二分时要保证每次恰好把一段数分完，不要有空的，而且在更新树链剖分的子树大小时注意加减关系。

# 代码如下：

```

#include <bits/stdc++.h>
using namespace std;
#define N 4000009
#define int long long
inline int read()
{
    register int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
        {
            f = -1;
        }
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
const int inf = INT_MAX;
struct node
{
    int to, next;
} edge[N * 4];
int head[N], k;
int n;
int dfn[N], dep[N], siz[N], son[N], f[N], top[N], cnt = 0;
int po[N], w[N];
void add(int x, int y)
{
    edge[++k].to = y;
    edge[k].next = head[x];
    head[x] = k;
}
void dfs1(int u, int fa)
{
    siz[u] = 1, f[u] = fa, dep[u] = dep[fa] + 1;
    for (int i = head[u]; i; i = edge[i].next)
    {
        int v = edge[i].to;
        if (v == fa)
        {
            continue;
        }
        dfs1(v, u);
        siz[u] += siz[v];
        if (siz[son[u]] < siz[v])
        {
            son[u] = v;
        }
    }
}
void dfs2(int u, int tmp)
{
    dfn[u] = ++cnt;
    top[u] = tmp;
    po[cnt] = w[u];
    if (!son[u])
    {
        return;
    }
    dfs2(son[u], tmp);
    for (int i = head[u]; i; i = edge[i].next)
    {
        int v = edge[i].to;
        // cout << "xiayige:" << v << endl;
        if (v == f[u] || v == son[u])
        {
            continue;
        }
        dfs2(v, v);
    }
}
struct Info
{
    pair<int, int> maxv;
} tree[N << 2];
pair<int, int> mergemax(pair<int, int> a, pair<int, int> b)
{
    pair<int, int> c;
    c.first = max(a.first, b.first);
    if (a.first != b.first)
    {
        c.second = min(a.first, b.first);
        c.second = max(c.second, max(a.second, b.second));
        return c;
    }
    c.second = max(a.second, b.second);
    return c;
}
void build(int u = 1, int l = 1, int r = n)
{
    if (l == r)
    {
        return void(tree[u].maxv = {po[l], -inf});
    }
    int mid = (l + r) >> 1;
    build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
    tree[u].maxv = mergemax(tree[u << 1].maxv, tree[u << 1 | 1].maxv);
}
void modify(int pos, int v, int u = 1, int l = 1, int r = n)
{
    if (l > pos || r < pos)
    {
        return;
    }
    if (l == r)
    {
        return void(tree[u].maxv = {tree[u].maxv.first + v, -inf});
    }
    int mid = (l + r) >> 1;
    modify(pos, v, u << 1, l, mid);
    modify(pos, v, u << 1 | 1, mid + 1, r);
    tree[u].maxv = mergemax(tree[u << 1].maxv, tree[u << 1 | 1].maxv);
}
pair<int, int> query(int ln, int rn, int u = 1, int l = 1, int r = n)
{
    if (l > rn || r < ln)
    {
        return make_pair(-inf, -inf);
    }
    if (l >= ln && r <= rn)
    {
        return tree[u].maxv;
    }
    int mid = (l + r) >> 1;
    return mergemax(query(ln, rn, u << 1, l, mid), query(ln, rn, u << 1 | 1, mid + 1, r));
}
pair<int, int> ask(int u, int v)
{
    pair<int, int> ans = {-inf, -inf};
    while (top[u] != top[v])
    {
        if (dep[top[u]] < dep[top[v]])
        {
            swap(u, v);
        }
        ans = mergemax(ans, query(dfn[top[u]], dfn[u]));
        u = f[top[u]];
    }
    if (dep[u] > dep[v])
    {
        swap(u, v);
    }
    ans = mergemax(ans, query(dfn[u], dfn[v]));
    return ans;
}
mt19937 rnd(233);
struct FHQ
{
    int son[2];
    int val, key, siz;
} edge1[N * 3];
int cur, root, x, y, z;
int newnode(int x)
{
    edge1[++cur].val = x;
    edge1[cur].key = rnd();
    edge1[cur].siz = 1;
    return cur;
}
// int newnode(int x)
// {
//     edge[++cur].val = x;
//     edge[cur].key = rnd();
//     edge[cur].siz = 0;
//     return cur;
// }
void pull(int u)
{
    edge1[u].siz = edge1[edge1[u].son[0]].siz + edge1[edge1[u].son[1]].siz + 1;
}
int merge(int u, int v)
{
    if (!u || !v)
    {
        return u | v;
    }
    if (edge1[u].key <= edge1[v].key)
    {
        edge1[u].son[1] = merge(edge1[u].son[1], v);
        pull(u);
        return u;
    }
    else
    {
        edge1[v].son[0] = merge(u, edge1[v].son[0]);
        pull(v);
        return v;
    }
}
void split(int u, int p, int &x, int &y)
{
    // cout << "u=" << u << ' ';
    // cout << "p=" << p << ' ';
    // cout << "x=" << x << ' ';
    // cout << "y=" << y << endl << endl;
    if (!u)
    {
        return void(x = y = 0);
    }
    if (edge1[u].val <= p)
    {
        x = u;
        split(edge1[u].son[1], p, edge1[u].son[1], y);
    }
    else
    {
        y = u;
        split(edge1[u].son[0], p, x, edge1[u].son[0]);
    }
    pull(u);
}
void insert(int a)
{
    split(root, a, x, y);
    root = merge(merge(x, newnode(a)), y);
}
void del(int a)
{
    split(root, a, x, z);
    split(x, a - 1, x, y);
    y = merge(edge1[y].son[0], edge1[y].son[1]);
    root = merge(merge(x, y), z);
}
int kth(int now, int k)
{
    while (true)
    {
        // cout << "now=" << now << endl;
        if (k <= edge1[edge1[now].son[0]].siz)
        {
            now = edge1[now].son[0];
        }
        else if (k == edge1[edge1[now].son[0]].siz + 1)
        {
            return now;
        }
        else
        {
            k -= edge1[edge1[now].son[0]].siz + 1, now = edge1[now].son[1];
        }
    }
    // cout << endl << endl;
}
int findpre(int a)
{
    split(root, a - 1, x, y);
    int res = edge1[kth(x, edge1[x].siz)].val;
    root = merge(x, y);
    // cout << "gen:" << root << endl;
    return res;
}
signed main()
{
    n = read();
    for (int i = 1; i < n; i++)
    {
        int a, b;
        a = read();
        b = read();
        add(a, b), add(b, a);
    }
    for (int i = 1; i <= n; i++)
    {
        w[i] = read();
        insert(w[i]); 
    }
    dfs1(1, 0);
    dfs2(1, 1); 
    build();
    int q;
    q = read();
    for (int i = 0; i < q; i++)
    {
        int op, xx, yy;
        op = read();
        xx = read();
        yy = read();
        if (op == 0)
        {
            del(w[xx]);
            w[xx] += yy;
            insert(w[xx]);
            modify(dfn[xx], yy);
        }
        else
        {
            pair<int, int> res = ask(xx, yy);
            if (res.second == -inf)
            {
                cout << "-1\n";
                continue;
            }
            del(res.first);
            del(res.second);
            int ret = findpre(findpre(inf));
            insert(res.first);
            insert(res.second);
            cout << res.second << " " << ret << "\n";
        }
    }
    return 0;
}

```

---

## 作者：Tsawke (赞：0)

# [LG-P6157 有趣的游戏](https://www.luogu.com.cn/problem/P6157) Solution

[TOC]

## [更好的阅读体验戳此进入](http://blog.tsawke.com?t=LG-P6157-Solution)

（一月份写的题解，然后交错题目了，今天才发现）

### 题面

给定 $ n $ 个点的树，存在点权 $ w_i $，独立询问每次可能为单点修改点权，可能给出两点，$ A $ 在树上两点最短路径上选择两个点 $ x, y $ 最大化 $ w_x \bmod{w_y} $，后者在树上选择非 $ x, y $ 的两点同样最大化上式，对于每次询问求出 $ A $ 最大的值，并求出此时 $ B $ 最大的值，$ A $ 无法选择则输出 `-1`。

### Solution

提供一种**复杂度正确**但常数**巨大**码量**较大**的**并不优秀**的无脑做法，思路来自于模拟赛赛时口糊的，在 Luogu 上可以通过，但赛时在 LemonLime 测的时候大概是因为常数原因被卡的就剩 $ 20\texttt{pts} $。

首先我们不难想到 $ w_x \bmod{w_y} $ 即为链上次小值。这个不难证明，若我们选择最大值，那么其对较小值取模后一定小于较小值，而若我们选择次大值对最大值取模那么可以直接保留次小值。

然后呢最开始我看这道题没太仔细，以为 $ B $ 也是在链上找，于是考虑的是维护次次小和次次次小保留次次次小，当然这个是大错特错的，不仅没有考虑 $ B $ 是树上的，还没有考虑 $ A $ 不能重复权值但 $ B $ 可以。

于是在我发现问题后就尝试优化这个思路，最终的过程大概是这样的：

首先树剖显然，然后线段树上维护区间的不可重复的前 $ 5 $ 大值，以及最多重复一次（即有两个）的前 $ 5 $ 大值。然后对于合并子区间，我们考虑直接维护结构体然后重载 `+`，实现上用一个 `basic_string` 存子节点所有值然后排序并各种特判细节做一下即可，不难发现超大的常数就是卡在这里了，这东西某种意义上来讲可以认为其为 $ O(1) $ 的，但是实际上个人感觉平均大概有个 $ 10 $ 左右的常数。

然后修改较为简单不再赘述，对于查询直接按照树剖查询并合并，对于不能重复的前 $ 5 $ 大取其第二大作为 $ A $ 的答案，不存在则输出 `-1`。然后我们要再次查询整棵树的结果，在可重复两次的前 $ 5 $ 大中删去 $ A $ 的两个答案，此时不难理解为什么维护的是可以重复两次的。然后此时还需要分类讨论，如果结果不够说明只能找到两个相同的数，这样结果为 $ 0 $，如果最终剩下三个数且前两个为 $ 0 $，那么说明原来的为 $ a \gt b \gt c = d \gt e $，然后 $ a, b $ 被删除，此时如果我们不维护 $ e $ 答案将变为 $ 0 $，这也就是为什么我们要维护前 $ 5 $ 大而不是 $ 4 $，显然此时答案应为 $ e $。同时因为题里没有说 $ B $ 取不了的情况，且不难想到只要 $ n \ge 4 $ 那么 $ B $ 一定可以拿，所以姑且可以认为题目保证了 $ n \ge 4 $。

当然这里也浅提一下，如果用 `multiset` 维护 $ B $ 的话就只需要维护最大和次大就可以了，常数小且好写，也不知道我模拟赛的时候为什么没想到，估计是开始读错题之后先入为主了。

### Code

```cpp
#define _USE_MATH_DEFINES
#include <bits/stdc++.h>

#define PI M_PI
#define E M_E
#define npt nullptr
#define SON i->to
#define OPNEW void* operator new(size_t)
#define ROPNEW void* Edge::operator new(size_t){static Edge* P = ed; return P++;}

using namespace std;

mt19937 rnd(random_device{}());
int rndd(int l, int r){return rnd() % (r - l + 1) + l;}
bool rnddd(int x){return rndd(1, 100) <= x;}

typedef unsigned int uint;
typedef unsigned long long unll;
typedef long long ll;
typedef long double ld;

template < typename T = int >
inline T read(void);

struct Edge{
    Edge* nxt;
    int to;
    OPNEW;
}ed[210000];
ROPNEW;
Edge* head[110000];

int N, Q;
ll w[110000];
int dep[110000], dfn[110000], hson[110000], siz[110000], ffa[110000], tp[110000], idx[110000];

void dfs_pre(int p = 1, int fa = 0){
    dep[p] = dep[fa] + 1;
    siz[p] = 1;
    ffa[p] = fa;
    for(auto i = head[p]; i; i = i->nxt){
        if(SON == fa)continue;
        dfs_pre(SON, p);
        siz[p] += siz[SON];
        if(siz[hson[p]] < siz[SON])hson[p] = SON;
    }
}
void dfs_make(int p = 1, int top = 1){
    tp[p] = top;
    static int cdfn(0);
    dfn[p] = ++cdfn;
    idx[cdfn] = p;
    if(hson[p])dfs_make(hson[p], top);
    for(auto i = head[p]; i; i = i->nxt)
        if(SON != ffa[p] && SON != hson[p])
            dfs_make(SON, SON);
}

struct Node{
    ll v[6], vu[6]; //v_max_with_2, v_unique
    Node(void){memset(v, 0, sizeof v), memset(vu, 0, sizeof vu);}
    friend Node operator + (const Node &a, const Node &b){
        Node ret;
        basic_string < ll > values;
        for(int i = 1; i <= 5; ++i){
            if(a.v[i])values += a.v[i];
            if(b.v[i])values += b.v[i];
        }sort(values.begin(), values.end(), greater < ll >());
        for(auto it = values.begin(); it != values.end() && next(it) != values.end() && next(it, 2) != values.end();)
            if(*it == *next(it) && *next(it) == *next(it, 2))it = values.erase(it);
            else advance(it, 1);
        for(int i = 1; i <= 5; ++i)
            ret.v[i] = (int)values.size() >= i ? values.at(i - 1) : 0;
        values.clear();
        for(int i = 1; i <= 5; ++i){
            if(a.vu[i])values += a.vu[i];
            if(b.vu[i])values += b.vu[i];
        }sort(values.begin(), values.end(), greater < ll >());
        values.erase(unique(values.begin(), values.end()), values.end());
        for(int i = 1; i <= 5; ++i)
            ret.vu[i] = (int)values.size() >= i ? values.at(i - 1) : 0;
        return ret;
    }
};

class SegTree{
private:
    Node mx[110000 << 2];
    #define LS (p << 1)
    #define RS (LS | 1)
    #define MID ((gl + gr) >> 1)
public:
    void Pushup(int p){
        mx[p] = mx[LS] + mx[RS];
    }
    void Build(int p = 1, int gl = 1, int gr = N){
        if(gl == gr)return mx[p].v[1] = mx[p].vu[1] = w[idx[gl = gr]], void();
        Build(LS, gl, MID), Build(RS, MID + 1, gr);
        Pushup(p);
    }
    void Modify(int id, int v, int p = 1, int gl = 1, int gr = N){
        if(gl == gr)return mx[p].v[1] += v, mx[p].vu[1] += v, void();
        if(id <= MID)Modify(id, v, LS, gl, MID);
        else Modify(id, v, RS, MID + 1, gr);
        Pushup(p);
    }
    Node Query(int l, int r, int p = 1, int gl = 1, int gr = N){
        // printf("Querying l = %d, r = %d\n", l, r);
        if(l <= gl && gr <= r)return mx[p];
        if(gr < l || r < gl)return Node();
        return Query(l, r, LS, gl, MID) + Query(l, r, RS, MID + 1, gr);
    }
}st;

void Make(int s, int t){
    Node cur;
    while(tp[s] != tp[t]){
        if(dep[tp[s]] < dep[tp[t]])swap(s, t);
        cur = cur + st.Query(dfn[tp[s]], dfn[s]);
        s = ffa[tp[s]];
    }if(dep[s] < dep[t])swap(s, t);
    cur = cur + st.Query(dfn[t], dfn[s]);
    if(!cur.vu[1] || !cur.vu[2]){printf("-1\n"); return;}
    Node ret = st.Query(1, N);
    basic_string < ll > tmp;
    for(int i = 1; i <= 5; ++i)if(ret.v[i])tmp += ret.v[i];
    for(int i = 1; i <= 2; ++i)
        if(find(tmp.begin(), tmp.end(), cur.vu[i]) != tmp.end())
            tmp.erase(find(tmp.begin(), tmp.end(), cur.vu[i]));
    if((int)tmp.size() < 2 || ((int)tmp.size() == 2 && tmp.at(0) == tmp.at(1))){printf("%lld 0\n", cur.vu[2]); return;}
    if(tmp.size() == 3 && tmp.at(0) == tmp.at(1)){printf("%lld %lld\n", cur.vu[2], tmp.at(2)); return;}
    printf("%lld %lld\n", cur.vu[2], tmp.at(0) == tmp.at(1) ? tmp.at(2) : tmp.at(1));
    // for(int i = 1; i <= 5; ++i)printf("mxchain mxvu[%d] = %lld\n", i, cur.vu[i]);
    // for(int i = 1; i <= 5; ++i)printf("mxtree mxv[%d] = %lld\n", i, ret.v[i]);
}

int main(){
    // freopen("game.in", "r", stdin);
    // freopen("game.out", "w", stdout);
    N = read();
    for(int i = 1; i <= N - 1; ++i){
        int s = read(), t = read();
        head[s] = new Edge{head[s], t};
        head[t] = new Edge{head[t], s};
    }dfs_pre(), dfs_make();
    for(int i = 1; i <= N; ++i)w[i] = read();
    st.Build();
    Q = read();
    while(Q--){
        int opt = read(), x = read(), y = read();
        if(opt == 0)st.Modify(dfn[x], y);
        else Make(x, y);
    }
    fprintf(stderr, "Time: %.6lf\n", (double)clock() / CLOCKS_PER_SEC);
    return 0;
}

template < typename T >
inline T read(void){
    T ret(0);
    int flag(1);
    char c = getchar();
    while(c != '-' && !isdigit(c))c = getchar();
    if(c == '-')flag = -1, c = getchar();
    while(isdigit(c)){
        ret *= 10;
        ret += int(c - '0');
        c = getchar();
    }
    ret *= flag;
    return ret;
}

/*

7
1 2
2 3
2 5
1 5
5 6
5 7
5 5 3 2 1 5 3
6
1 3 5
1 2 5
1 2 1
0 2 1
1 2 5
1 2 1

*/
```

## UPD

update-2023_01_17 初稿

---

## 作者：ademik (赞：0)

_第一篇题解 && 紫题题解, 写的不好请见谅_
 
 -----------
[题目传送门](https://www.luogu.com.cn/problem/P6157)

**本题解的思路基本与其他的相似，但实现方式更多使用 STL ，相比其他题解实现起来更简单( ~~只不过用时间和空间换罢了~~ )**
 
**分析:**  
* 如果我们只看小 A 的话，那么本题相当于 树链剖分模板 + 维护区间 **严格** 最大值 和 **严格** 次大值 ( 读者自证不难 ) 。  

* 先实现这部分代码，树链剖分不用说，最大值和次大值的维护， 可以直接像其他题解一样多加几个判断，也可以用 sort 和 unique 实现 ( 因为严格，所以要用 unique 去重 )。   

* 我们再看小 B ，它要求的是 树上除了小 A 选定的两个点以外的 **严格** 次大值 。 首先的思路应该是标记节点然后重新求 ，但想想就麻烦。  

* 考虑到已经求出需要删除的值，而我们不必要知道具体删除的点，只用考虑删除这些值对整个数列上的 **严格** 次大值 的 影响。 故而可以用 multiset 记录树上的所有点权，每次询问时先删除小 A 所选定的权值，删除后直接取  multiset 中的严格次大值即可。

--------
**Code: **

```cpp
# define mid ((l + r) >> 1)
using namespace std;
const int N = 2 * 1e5 + 50;
int a[N], head[N], edge_sum, n, m; // 基本数组
int id[N], idx, dep[N], son[N], from[N], top[N], fa[N], siz[N]; // 树剖数组
int max1[N << 2], max2[N << 2]; // 线段树数组
struct edge {
	int nst, to;
}e[N << 1];
multiset <int> s;
namespace SLPF 
{
	// 树链剖分模板
	void dfs1(int u) {
		siz[u] = 1; son[u] = 0;
		for(int i = head[u]; i; i = e[i].nst) {
			int v = e[i].to;
			if(fa[u] != v) {
				fa[v] = u;
				dep[v] = dep[u] + 1;
				dfs1(v);
				siz[u] += siz[v];
				if(siz[son[u]] < siz[v]) son[u] = v;
			}
		}
	}
	
	void dfs2(int u, int tp) {
		id[u] = ++idx;
		from[idx] = u;
		top[u] = tp;
		if(son[u]) dfs2(son[u], tp);
		for(int i = head[u]; i; i = e[i].nst) {
			int v = e[i].to;
			if(v != son[u] && v != fa[u]) dfs2(v, v);
		}
	}
	
	// 维护最大值， 严格次大值
	void push_up(int root) {
		int tmp[6]; tmp[0] = 0;
		tmp[1] = max1[root << 1]; tmp[2] = max1[root << 1 | 1];
		tmp[3] = max2[root << 1]; tmp[4] = max2[root << 1 | 1];
		sort(tmp + 1, tmp + 1 + 4);
		int tot = unique(tmp + 1, tmp + 1 + 4) - (tmp + 1);
		max1[root] = tmp[tot];  max2[root] = tmp[tot - 1];
		return;
	}
	
	void Build(int l, int r, int root) {
		if(l == r) {
			max1[root] = a[from[l]];
			return;
		}
		Build(l, mid, root << 1); Build(mid + 1, r, root << 1 | 1);
		push_up(root);
		return;
	}
	
	void change(int pos, int l, int r, int root, int val) {
		if(l == r && pos == l) { // 直接修改到叶节点
		// 先删除之前的值, 再加入修改后的值
			multiset <int> ::iterator it = s.lower_bound(max1[root]);
			s.erase(it);
			max1[root] += val;
			s.insert(max1[root]);
			return;
		}
		if(pos <= mid) change(pos, l, mid, root << 1, val);
		else change(pos, mid + 1, r, root << 1 | 1, val);
		push_up(root);
		return;
	}
	
	pair <int, int> more(pair <int, int> x, pair <int, int> y) {
		int tmp[6]; tmp[0] = 0; // 注意tmp[0]要赋初值, tot - 1 可能为0 
		tmp[1] = x.first; tmp[2] = x.second;
		tmp[3] = y.first; tmp[4] = y.second;
		sort(tmp + 1, tmp + 1 + 4);
		int tot = unique(tmp + 1, tmp + 1 + 4) - (tmp + 1);
		return make_pair(tmp[tot], tmp[tot - 1]);
	// 应该好理解, 如 5454, 去重后为45, tot 为 2
	}
	
	pair <int, int> query(int x, int y, int l, int r, int root) {
		if(x <= l && y >= r) return make_pair(max1[root], max2[root]);
		pair <int, int> tmp1(0, 0), tmp2(0, 0); // 赋初值!!
		if(x <= mid) tmp1 = query(x, y, l, mid, root << 1);
		if(y > mid) tmp2 = query(x, y, mid + 1, r, root << 1 | 1);
		return more(tmp1, tmp2);
	}
	
	pair <int, int> query_diff(int x, int y) {
		pair <int, int> res(0, 0);
		while(top[x] != top[y]) {
			if(dep[top[x]] < dep[top[y]]) swap(x, y);
    		res = more(res, query(id[top[x]], id[x], 1, n, 1));
			x = fa[top[x]];
		}
		if(id[x] > id[y]) swap(x, y);
    	res = more(res, query(id[x], id[y], 1, n, 1));
    // 当第二个数即次大值为0，说明这条链上的权值没有两个不同的，返回-1
    	res.second = (res.second == 0) ? -1 : res.second;
    	return res;
	}
}
using namespace SLPF;
int main()
{
	cin >>n;
	for(int i = 1, u, v; i < n; i ++) {
		cin >>u >>v;
		e[++edge_sum] = (edge){head[u], v};head[u]=edge_sum;
		e[++edge_sum] = (edge){head[v], u};head[v]=edge_sum;
	}
	for(int i = 1; i <= n; i ++) cin >>a[i], s.insert(a[i]);
	dfs1(1); dfs2(1, 1); Build(1, n, 1);
	cin >>m;
	for(int i = 1, op, x, y; i <= m; i ++) {
		cin >>op >>x >>y;
		if(op == 1) {
			pair <int, int> ans;
			multiset <int> ::iterator it;
			ans = query_diff(x, y);
			cout <<ans.second;
			if(ans.second != -1) {
				it = s.lower_bound(ans.first);
				s.erase(it);
				it = s.lower_bound(ans.second);
				s.erase(it);
			// 这一步要求严格次大值，一定要排除相等的数的影响
			// 如 1 2 3 4 4 4 我们要求的是3
        // 如果直接写 it = s.begin(); it --; it --;
        // 所查询到的值为4
				it = s.lower_bound(*--s.end());
				it --;
				
				s.insert(ans.first); s.insert(ans.second);
           // 将之前删除的重新插入
				cout <<" " <<*it;
			}
			cout <<endl;
		}
		else change(id[x], 1, n, 1, y);
			// 修改对应编号的值
	}
	return 0;
}
```
-------

---


# [CSP-S 2022] 数据传输

## 题目背景

**请勿滥用本题评测，违者可能处以封号处罚。**

## 题目描述

小 C 正在设计计算机网络中的路由系统。

测试用的网络总共有 $n$ 台主机，依次编号为 $1 \sim n$。这 $n$ 台主机之间由 $n - 1$ 根网线连接，第 $i$ 条网线连接个主机 $a_i$ 和 $b_i$。保证任意两台主机可以通过有限根网线直接或者间接地相连。受制于信息发送的功率，主机 $a$ 能够直接将信息传输给主机 $b$ 当且仅当两个主机在可以通过不超过 $k$ 根网线直接或者间接的相连。

在计算机网络中，数据的传输往往需要通过若干次转发。假定小 C 需要将数据从主机 $a$ 传输到主机 $b$（$a \neq b$），则其会选择出若干台用于传输的主机 $c_1 = a, c_2, \ldots, c_{m - 1}, c_m = b$，并按照如下规则转发：对于所有的 $1 \le i < m$，主机 $c_i$ 将信息直接发送给 $c_{i + 1}$。

每台主机处理信息都需要一定的时间，第 $i$ 台主机处理信息需要 $v_i$ 单位的时间。数据在网络中的传输非常迅速，因此传输的时间可以忽略不计。据此，上述传输过程花费的时间为 $\sum_{i = 1}^{m} v_{c_i}$。

现在总共有 $q$ 次数据发送请求，第 $i$ 次请求会从主机 $s_i$ 发送数据到主机 $t_i$。小 C 想要知道，对于每一次请求至少需要花费多少单位时间才能完成传输。

## 说明/提示

**【样例解释 \#1】**

对于第一组请求，由于主机 $4, 7$ 之间需要至少 $4$ 根网线才能连接，因此数据无法在两台主机之间直接传输，其至少需要一次转发；我们让其在主机 $1$ 进行一次转发，不难发现主机 $1$ 和主机 $4, 7$ 之间都只需要两根网线即可连接，且主机 $1$ 的数据处理时间仅为 $1$，为所有主机中最小，因此最少传输的时间为 $4 + 1 + 7 = 12$。

对于第三组请求，由于主机 $1, 2$ 之间只需要 $1$ 根网线就能连接，因此数据直接传输就是最优解，最少传输的时间为 $1 + 2 = 3$。

**【样例 \#2】**

见附件中的 `transmit/transmit2.in` 与 `transmit/transmit2.ans`。

该样例满足测试点 $2$ 的限制。

**【样例 \#3】**

见附件中的 `transmit/transmit3.in` 与 `transmit/transmit3.ans`。

该样例满足测试点 $3$ 的限制。

**【样例 \#4】**

见附件中的 `transmit/transmit4.in` 与 `transmit/transmit4.ans`。

该样例满足测试点 $20$ 的限制。

**【数据范围】**

对于所有的测试数据，满足 $1 \le n \le 2 \times {10}^5$，$1 \le Q \le 2 \times {10}^5$，$1 \le k \le 3$，$1 \le a_i, b_i \le n$，$1 \le s_i, t_i \le n$，$s_i \ne t_i$。

| 测试点 | $n \le$ | $Q \le$ | $k =$ | 特殊性质 |
|:-:|:-:|:-:|:-:|:-:|
| $1$ | $10$ | $10$ | $2$ | 是 |
| $2$ | $10$ | $10$ | $3$ | 是 |
| $3$ | $200$ | $200$ | $2$ | 是 |
| $4 \sim 5$ | $200$ | $200$ | $3$ | 是 |
| $6 \sim 7$ | $2000$ | $2000$ | $1$ | 否 |
| $8 \sim 9$ | $2000$ | $2000$ | $2$ | 否 |
| $10 \sim 11$ | $2000$ | $2000$ | $3$ | 否 |
| $12 \sim 13$ | $2 \times {10}^5$ | $2 \times {10}^5$ | $1$ | 否 |
| $14$ | $5 \times {10}^4$ | $5 \times {10}^4$ | $2$ | 是 |
| $15 \sim 16$ | ${10}^5$ | ${10}^5$ | $2$ | 是 |
| $17 \sim 19$ | $2 \times {10}^5$ | $2 \times {10}^5$ | $2$ | 否 |
| $20$ | $5 \times {10}^4$ | $5 \times {10}^4$ | $3$ | 是 |
| $21 \sim 22$ | ${10}^5$ | ${10}^5$ | $3$ | 是 |
| $23 \sim 25$ | $2 \times {10}^5$ | $2 \times {10}^5$ | $3$ | 否 |

特殊性质：保证 $a_i = i + 1$，而 $b_i$ 则从 $1, 2, \ldots, i$ 中等概率选取。

## 样例 #1

### 输入

```
7 3 3
1 2 3 4 5 6 7
1 2
1 3
2 4
2 5
3 6
3 7
4 7
5 6
1 2
```

### 输出

```
12
12
3
```

# 题解

## 作者：Graphcity (赞：208)

2024.2.19 Update：更新了剪贴板中的代码链接。

---

下文中默认 $n,q$ 同阶。在考场上，显然要先从好做的部分分开始想。

- $k=1$ 时，答案就是路径上的点权之和，树链剖分 / 倍增维护即可，时间复杂度 $O(n\log n)$。（16pts）

- $n\le 200$ 时，考虑转化为图论模型。若两个点 $a,b$ 满足 $dis(a,b)\le k$，则连一条连接 $a,b$ 的双向边。那么答案即为从 $s$ 到 $t$ 的点权和最短的路径。时间复杂度 $O(n^3\log n)$，菊花图可以卡满。（20pts）

接下来要做的事就是深入挖掘题目中的性质。

根据直觉可以意识到，除了路径上的点，最优方案中其它经过的点距离这条路径至少不会很深。

先作出大胆的猜想：最优方案中只会经过路径上的点。

- $k=2$ 时，这确实是合法的。为什么呢？如果你从路径上的点跳到某个点的儿子再跳回路径，显然不如直接跨过这个点。

  ![](https://cdn.luogu.com.cn/upload/image_hosting/vubf7gr0.png)

  把路径提取出来，考虑用 DP 来表示。设 $f_i$ 为跳到第 $i$ 个点的最小值，可以得到 $f_i=\min(f_{i-1},f_{i-2})+val_i$。（20pts）

- 但 $k=3$ 时这东西就有点问题，因为你可以从一个儿子跳到另一个儿子，而且这正有可能是最优的方案。

  经过一些小修正，我们可以发现，**当 $k=3$ 时，最优方案中只可能存在路径上的点和他们的一个儿子**。我们这里把 LCA 的父亲结点也当作它的儿子之一。
  
  ![](https://cdn.luogu.com.cn/upload/image_hosting/37bkttlw.png)

  显然这个儿子需要满足不在路径上，而且它的权值也要最小。事实上，它要么是最大值，要么是次大值。把路径提取出来后，我们可以方便的 $O(1)$ 把这玩意求出来。设 $num_i$ 表示 $i$ 儿子的权值，如果没有则设为 $\infty$。

  设 $f_{i,0/1}$ 表示跳到了点 $i$ 自己 / 它儿子的最小值，枚举它从哪个点跳过来，可以得到
  
$$
\begin{aligned}
f_{i,0}&=\min(f_{i-1,0},f_{i-1,1},f_{i-2,0},f_{i-2,1},f_{i-3,0})+val_i\\
f_{i,1}&=\min
\begin{cases}
f_{i,0}+num_i \\
\min(f_{i-1,0},f_{i-1,1},f_{i-2,0})+num_i
\end{cases}
\end{aligned}
$$

这两个部分的时间复杂度均为 $O(nd)$，其中 $d$ 为树的深度。（20pts）

至此，你已经得到了 76pts 的好成绩。（**[76pts 考场代码](https://www.luogu.com.cn/paste/qwpf81fq)**）

再往下就是解决 $n\le 2\times 10^5$ 的正解情况了。对于部分分，它的时间复杂度瓶颈在于一次 $O(d)$ 的动态规划。我们必须着手去优化它。

这个时候，你想到了 **[NOIP2018 保卫王国](https://www.luogu.com.cn/problem/P5024)**，这道题也需要优化树上 DP 的过程。

尝试借鉴它的思路，考虑 **动态 DP**。下文中对矩阵乘法 $A\times B=C$ 的定义如下，它满足结合律：
$$
C_{i,j}=\min_{k}(A_{i,k}+B_{k,j})
$$

- 对于 $k=1$ 的情况，转移矩阵非常好处理，甚至根本不需要转移矩阵。这里为了与下文统一，用的是 $3\times 3$ 的矩阵。

$$
\begin{bmatrix}
val_i & \infty & \infty \\
\infty & 0 & \infty \\
\infty & \infty & 0
\end{bmatrix}
\begin{bmatrix}
dis_{i-1}\\
0\\
0
\end{bmatrix}
=
\begin{bmatrix}
dis_{i}\\
0\\
0
\end{bmatrix}
$$

- 对于 $k=2$ 的情况，它的状态转移方程 $f_i=\min(f_{i-1},f_{i-2})+val_i$ 也容易写成矩阵形式：（12pts）

$$
\begin{bmatrix}
val_i & val_i & \infty \\
0 & \infty & \infty \\
\infty & \infty & 0
\end{bmatrix}
\begin{bmatrix}
f_{i-1}\\
f_{i-2}\\
0
\end{bmatrix}
=
\begin{bmatrix}
f_{i}\\
f_{i-1}\\
0
\end{bmatrix}
$$

- 但是，当 $k=3$ 时，我们需要存 $f_{i,0},f_{i,1},f_{i-1,0},f_{i-1,1},f_{i-2,0}$ 这五个值，一次转移就有 $5^3=125$ 的常数，即使是 3s 的时限也难以接受。这个时候就必须要优化状态设计。

  可以发现，整个 DP 中影响转移的只有一个因素——距离。设 $f_{i,0/1/2}$ 表示跳到距离点 $i$ 为 0/1/2 的点的最小值，则有：

$$
\begin{aligned}
f_{i,0}&=\min(f_{i-1,0},f_{i-1,1},f_{i-1,2})+val_i\\
f_{i,1}&=\min
\begin{cases}
f_{i,0}+num_i\\
\min(f_{i-1,0},f_{i-1,1})+num_i\\
f_{i-1,0}
\end{cases}
\\
f_{i,2}&= f_{i-1,1}
\end{aligned}
$$

把中间的 $f_{i,0}$ 拆开，再把式子整理一下，可以得到：

$$
\begin{aligned}
f_{i,0}&=\min(f_{i-1,0},f_{i-1,1},f_{i-1,2})+val_i\\
f_{i,1}&=\min(f_{i-1,0},f_{i-1,1}+num_i,f_{i-1,2}+val_i+num_i)\\
f_{i,2}&= f_{i-1,1}
\end{aligned}
$$

接下来给出 $k=3$ 的转移矩阵：

$$
\begin{bmatrix}
val_i & val_i &val_i \\
0 & num_i & num_i+val_i \\
\infty & 0 & \infty
\end{bmatrix}
\times
\begin{bmatrix}
f_{i-1,0}\\
f_{i-1,1}\\
f_{i-1,2}
\end{bmatrix}
=
\begin{bmatrix}
f_{i,0}\\
f_{i,1}\\
f_{i,2}
\end{bmatrix}
$$
我们把路径上第 $i$ 个点的转移矩阵称为 $base_i$。根据动态 DP 的套路，设路径长度为 $k$，整个转移过程如下：
$$
\begin{aligned}
\begin{bmatrix}f_{k,0}\\f_{k,1}\\f_{k,2} \end{bmatrix}&=base_k\times \begin{bmatrix}f_{k-1,0}\\f_{k-1,1}\\f_{k-1,2} \end{bmatrix}\\
&=base_k\times base_{k-1}\times \begin{bmatrix}f_{k-2,0}\\f_{k-2,1}\\f_{k-2,2} \end{bmatrix}\\
&\ \ \vdots\\
&=base_{k}\times base_{k-1}\times \cdots \times base_2\times \begin{bmatrix}f_{1,0}\\f_{1,1}\\f_{1,2} \end{bmatrix}\\
\end{aligned}
$$
答案就是除开第一个点外的转移矩阵逆序积再乘上初始的转移矩阵。

利用倍增预处理出从点 $i$ 往上跳 $2^k$ 级祖先之和的矩阵顺序乘积和逆序乘积，询问就可以直接解决了。

等等...是不是有点问题？

对于每条路径，$num_i$ 的值有可能不同。如何保证 $num_i$ 不在路径上？ 

通过观察，可以发现，$num_i$ 的意义实际上就是给一个结点挂一个值为 $num_i$ 的儿子。如果 $num_i$ 在路径上，那么 **最优方案一定不会经过 $i$ 的任何一个儿子**。因为对于走到 $i$ 儿子的方案，要么一定不优，要么可以把儿子替换成 $num_i$，方案合法的同时答案仍然不劣。

![](https://cdn.luogu.com.cn/upload/image_hosting/t62p4mqq.png)

所以直接预处理出 $num_i$ 为 $i$ 直接连接的结点中权值最小值即可。

这种方法的分类讨论和细节都是较少的。时间复杂度 $O(n\log n)$。（12pts）

现在，你已经成功的切掉了这道题。（**[AC Code](https://www.luogu.com.cn/paste/dpwx6u5t)**）

---

## 作者：dottle (赞：93)

首先，我们稍微把题意转化一下：我们要寻找一条从 $s$ 到 $t$ 的路径，然后将其上的若干个点将点权计入答案，要求不存在连续 $K$ 个不计入答案的点。

首先，考虑如何暴力地解决问题。我们可以设 $(k,x)$ 表示走到 $k$ 这个点，当前已经有 $x$ 个点没有标记了。然后便可以建图：
$$
(k,x)\to(k,0),w=v_k
$$

若原图有边 $k\to t$，且 $x+1<K$：

$$
(k,x)\to(t,x+1),w=0
$$
在此图上跑最短路即可，单次复杂度 $O(n\log n )$。

接下来，考虑优化此过程。对于 $s$ 到 $t$ 路径上的点来说，他们可能不会计入答案，但是一定会被经过。我们可以据此倍增优化我们的算法。

考虑求出这样一个数组：

-   $dis_{k,i,x,y}$ 表示 $(k,x)$ 到 $(fa_{k,i},y)$ 的最短路，其中 $fa_{k,i}$ 指 $k$ 的 $2^i$ 级父亲。

那么我们只需要手动分析 $dis_{k,0,x,y}$ 的情况，经过讨论，有以下三种情况：

1.  走到 $fa$ 后，将 $fa$ 计入答案。
2.  $k$ 和 $fa$ 都不计入答案。
3.  $k$ 先走到与 $k$ 相邻的点权最小的点，计入答案，然后走到 $fa$。

 预处理好 $dis$ 数组后，回答每次询问，我们先求出 $(lca,0\sim K-1)$ 到 $(s,0),(t,0)$ 的距离，假设我们从 $(s,0)$ 走到了 $(lca,x)$；从 $(t,0)$ 走到了 $(lca,y)$ ，那么：

-   若 $x=y=0$，则 $lca$ 的点权多算了一次，需要减掉；
-   若 $x=y=2$，则还需要在 $lca$ 附近的一个点中转一次，需要补上一个权值；
-   否则，直接把两段路径拼起来就可以。

时间复杂度 $O(3^3n\log n)$。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=200500,B=20,K=3;

int n,q,T;
int v[N],mn[N];
vector<int> e[N];

int f[B][N],dep[N];
int dis[B][N][K][K];

void gi(int&x,int y){x=min(x,y);}

void dfs(int k,int fa){
	
	dep[k]=dep[fa]+1;
	
	f[0][k]=fa;
	for(int i=1;i<B;i++)f[i][k]=f[i-1][f[i-1][k]];
	
	auto D=dis[0][k];
	if(T==1){
		D[0][0]=v[fa];
	}
	if(T==2){
		D[0][0]=D[1][0]=v[fa];
		D[0][1]=0;
	}
	if(T==3){
		D[0][0]=D[1][0]=D[2][0]=v[fa];
		D[0][1]=D[1][2]=0;
		D[2][2]=mn[k];
	}
	
	for(int i=1;i<B;i++)
		for(int x=0;x<3;x++)
			for(int y=0;y<3;y++)
				for(int z=0;z<3;z++)
					gi(dis[i][k][x][z],dis[i-1][k][x][y]+dis[i-1][f[i-1][k]][y][z]);
	
	for(auto to:e[k])if(to!=fa)
		dfs(to,k);
}

int lca(int x,int y){
	if(dep[x]<dep[y])swap(x,y);
	for(int i=B-1;i>=0;i--)
		if(dep[f[i][x]]>=dep[y])
			x=f[i][x];
	if(x==y)return x;
	for(int i=B-1;i>=0;i--)
		if(f[i][x]!=f[i][y])
			x=f[i][x],y=f[i][y];
	return f[0][x];
}

vector<int> calc(int k,int l){
	vector<int> res(3,v[k]);
	for(int i=B-1;i>=0;i--){
		if(dep[f[i][k]]<dep[l])continue;
		vector<int> nw=res;
		fill(res.begin(),res.end(),1e18);
		for(int x=0;x<3;x++)
			for(int y=0;y<3;y++)
				gi(res[y],nw[x]+dis[i][k][x][y]);
		k=f[i][k];
	}
	return res;
}

int calcdis(int x,int y){
	int l=lca(x,y);
	auto F=calc(x,l),G=calc(y,l);
	int res=1e18;
	gi(res,F[0]+G[0]-v[l]);
	for(int i=0;i<T;i++)for(int j=0;j<T;j++){
		gi(res,F[i]+G[j]+(mn[l]*(i+j>T)));
	}
	return res;
}

main(){
	ios::sync_with_stdio(0);
	cin>>n>>q>>T;
	for(int i=1;i<=n;i++){
		cin>>v[i];
		mn[i]=v[i];
	}
	for(int i=1;i<n;i++){
		int x,y;cin>>x>>y;
		e[x].push_back(y);
		e[y].push_back(x);
		mn[x]=min(mn[x],v[y]);
		mn[y]=min(mn[y],v[x]);
	}
	memset(dis,1,sizeof(dis));
	dfs(1,0);
	
	while(q--){
		int s,t;cin>>s>>t;
		cout<<calcdis(s,t)<<'\n';	
	}
	
}
```



---

## 作者：Perfound (赞：27)

# P8820 [CSP-S 2022 T4] 数据传输 $O(k^3(n+m))$  做法

显然 $k=1$ 时答案是 $a-b$ 上所有点权之和。

可以得出 $k=2$ 时是不用跳出 $a-b$ 的链外的，因为 $k=2$ 时跳出链，又跳回来是和直接跳一次是相同的。

设 $dp_i$ 是走到 $i$ 的最小答案，$dp_{i-k}$ 走到距离 $i$ 为 $k$ 的最小答案。

于是 $dp_i=\min(dp_{i-1},dp_{i-2})+v_p$。

可以得出转移广义矩阵 $[dp_{i-1},dp_{i-2}] \times \begin{bmatrix}v_i&0\\v_i&+\infty\end{bmatrix}=[dp_i,dp_{i-1}]$。

设初始值为 $[dp_a,+\infty]$ 然后从 $a$ 的父亲一直乘转移矩阵到 $b$（$dfn_a>dfn_b$）。

可以发现 $k=3$ 时可以跳到链外离链距离为 1 的点上，且如果跳到链外，它一定跳了 3 条边。

为了使每个点的转移矩阵只含有与它自己相关的值（因为这样好转移）

跳到链外离链距离为 1 的点上，即离当前点 $i$ 距离为一的点。

可以发现无论从 $i-2$ 跳到哪个离 $i$ 距离为一的点上，就是跳到了 $a-b$ 的链上也不会影响结果。

设 $j$ 是 $i$ 在 $a-b$ 上前一个点，$w_i$ 是离 $i$ 距离为一的点的最小点权。

于是可以得到 $[dp_j,dp_{j-1},dp_{j-2}] \times \begin{bmatrix}v_i&0&+\infty\\v_i&w_i&0\\v_i&+\infty&+\infty\end{bmatrix}=[dp_i,dp_{i-1},dp_{i-2}]$。

初始值为 $[dp_a,+\infty,+\infty]$。

可以发现本题要维护的是链上的值的积，且没有修改，于是可以离线下来用带权并查集维护这个点到它祖先的积。

因为这个矩阵运算没有交换律，所以可以维护两个权，表示这个点到它祖先的积，它祖先到这个点的积。

然后在 $c=lca(a,b)$ 处合并 $fa_a-c ,c-b$ 的积即可，可以离线 $O(n\alpha(n))$ 求 $lca$，刚好可以用刚才的并查集维护。

实际上可以做到维护只带一个权的并查集，但是根节点带权的带权并查集不好维护，所以这里放了个容易写的双倍常数 $O(k^3(n+m))$。

最优解可以做到 $O(k^3n+km)$，用了只带一个权的并查集和单调性，但是显然维护单调性常数大于 $k$，所以最优解是 $O(k^3n+k^2m)$。

不知道比树剖好写多少倍。

### 代码

```c++
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int pt[200010],q[200010][2],n,m,ui;
long long v[200010],w[200010];
basic_string<int>e[200010],c[200010],s[200010];
void add(int a,int b){w[a]=min(w[a],v[b]),e[a]+=b;}
struct cube{
	long long g[3][3];
	void clear(){memset(g,0x3f3f,sizeof g);}
	void operator =(const int x){
		clear();
		for(int i=0;i<ui;i++)g[i][0]=v[x];
		for(int i=0;i+1<ui;i++)g[i][i+1]=0;
		if(ui==3)g[1][1]=w[x];
	}
	cube operator *(const cube &x){
		cube y;y.clear();
		for(int i=0;i<ui;i++)for(int j=0;j<ui;j++)for(int k=0;k<ui;k++)
			y.g[i][j]=min(y.g[i][j],g[i][k]+x.g[k][j]);
		return y;
	}
}pv[200010][2],res[200010],zero;
int find(int x){
	if(pt[x]==pt[pt[x]])return pt[x];
	int z=pt[x];pt[x]=find(pt[x]);
	pv[x][0]=pv[x][0]*pv[z][0];
	pv[x][1]=pv[z][1]*pv[x][1];
	return pt[x];
}
cube qry1(int x){if(x==pt[x])return zero;find(x);return pv[x][0];}
cube qry2(int x){if(x==pt[x])return zero;find(x);return pv[x][1];}
void dfs(int p,int f){
	for(int i:s[p]){
		if(pt[q[i][1]])swap(q[i][0],q[i][1]);
		if(pt[q[i][0]])res[i].clear(),res[i].g[0][0]=v[p],c[find(q[i][0])]+=i,q[i][1]=f;
	}
	pt[p]=p,pv[p][0]=p,pv[p][1]=p;for(int i:e[p])if(i!=f)dfs(i,p),pt[i]=p;
	for(int i:c[p])res[i]=res[i]*qry1(q[i][1])*pv[p][0]*qry2(q[i][0]);
}//这里的 find(q[i][0/1]) 一定是 p
int main(){
	scanf("%d%d%d",&n,&m,&ui);
	for(int i=0;i<ui;i++)for(int j=0;j<ui;j++)if(i!=j)zero.g[i][j]=1e18;//单位矩阵
	for(int i=1;i<=n;i++)scanf("%lld",&v[i]),w[i]=1e18;
	for(int i=1,a,b;i<n;i++)scanf("%d%d",&a,&b),add(a,b),add(b,a);
	for(int i=1;i<=m;i++)scanf("%d%d",&q[i][0],&q[i][1]),s[q[i][0]]+=i,s[q[i][1]]+=i;
	dfs(1,0);for(int i=1;i<=m;i++)printf("%lld\n",res[i].g[0][0]);
	return 0;
}
```

### $O(k^3n+km)$ 长这样

```c++
for(int i=heac[p];i;i=c[i].next){
	const int x=q[c[i].to][1],y=q[c[i].to][0];
	memset(ans,0x3f3f,48),ans[0][0]=v[x],ans[1][0]=v[y];
	if(x!=p){
		find(to[x],f),memset(ret,0x3f3f,24);
		for(int j=0;j<ui;++j)ret[j]=min(ret[j],ans[0][0]+pv[to[x]][0][j]);
		memcpy(ans[0],ret,24);//这里的 pv[x] 相当于上面的 pv[x][0]
	}
	if(y!=p){
		find(to[y],f),memset(ret,0x3f3f,24);
		for(int j=0;j<ui;++j)ret[j]=min(ret[j],ans[1][0]+pv[to[y]][0][j]);
		memcpy(ans[1],ret,24);
	}
	res[c[i].to]=ans[0][0]+ans[1][0]-v[p],now=ui-1;
	for(int j=ui-1;~j;--j)if(ans[1][j]<=ans[1][now])now=j;
	for(int j=0;j<ui;++j){if(now+j>ui)now--;res[c[i].to]=min(res[c[i].to],ans[0][j]+ans[1][now]);}
}
```

实际上所有求链上可合并信息并且没有修改或修改是从下往上的都可以这样做，甚至是某些线段树合并优化 $dp$。

赛时我傻了，用 $2h$ 写了个巨长的树剖，离 100 就差 40 个字符，然后爆零。



---

## 作者：EnofTaiPeople (赞：19)

众所周知，我是一个考场上写了 $\text{LCT}$ 却不会推转移方程的选手。

对于一条链，记 $f_{l,r}$ 表示最左边选的点到左端点距离为 $l$，最右边选的点到右端点距离为 $r$。

考场上写不出是因为对于长度极小的链合并不会处理，考后听学长说只要合并时考虑某一边的链全部不选即可，于是在原有的 $\text{LCT}$ 上修改即可，由于是暴力转移，时间复杂度 $O(k^4(q\log_2n+n))$，跑得很慢，但可以通过。

转移方程：
```
struct ddp{
    ll f[3][3],ln;
    ddp(){}
    ddp(int x){
        f[0][0]=v[x],ln=1;
        if(k>1)f[1][1]=_d[x],f[0][1]=f[1][0]=U;
        if(k>2)f[0][2]=f[2][0]=f[1][2]=f[2][1]=f[2][2]=U;
    }
    void operator()(ddp x,ddp y){
        int i,j,l,r,p;
        for(i=0;i<k;++i)
            for(j=0;j<k;++j)
                f[i][j]=U;            
        for(i=0;i<k;++i)//两边都选
            for(j=0;i+j<k;++j)
                for(l=0;l<k;++l)
                    for(r=0;r<k;++r)
                        f[l][r]=min(f[l][r],x.f[l][i]+y.f[j][r]);
        for(l=0;l+x.ln<k;++l)//一边不选
            for(r=0;r<k;++r)
                f[l+x.ln][r]=min(f[l+x.ln][r],y.f[l][r]);
        for(l=0;l<k;++l)
            for(r=0;r+y.ln<k;++r)
                f[l][r+y.ln]=min(f[l][r+y.ln],x.f[l][r]);
        ln=x.ln+y.ln;
    }
    void operator~(){
        int l,r;
        for(l=0;l<k;++l)    
            for(r=l+1;r<k;++r)
                swap(f[l][r],f[r][l]);
    }
}sm[N];
```
简易的可换根 $\text{LCT}$：
```cpp
namespace lct{
    int f[N],t[N][2];
    bitset<N>rv;
    void pp(int x){
        if(ls){
            sm[x](sm[ls],ddp(x));
            if(rs)sm[x](sm[x],sm[rs]);
        }else if(rs){
            sm[x](ddp(x),sm[rs]);
        }else sm[x]=ddp(x);
    }
    void rev(int x){
        swap(ls,rs),rv[x]=!rv[x],~sm[x];
    }
    void pd(int x){
        if(rv[x]){
            rev(ls),rev(rs);
            rv[x]=0;
        }
    }
    void rot(int x){
        int y=f[x],k=tp(x),w=t[x][!k];
        t[t[x][!k]=y][k]=w,f[w]=y;
        if(in(y))t[f[y]][tp(y)]=x;
        f[x]=f[y],f[y]=x,pp(y);
    }
    void ppd(int x){
        if(in(x))ppd(f[x]);pd(x);
    }
    void splay(int x){
        ppd(x);
        for(int y=f[x];in(x);rot(x),y=f[x])
            if(in(y))rot(tp(x)^tp(y)?x:y);
        pp(x);
    }
    void acs(int x){
        for(int y=0;x;x=f[y=x])
            splay(x),rs=y,pp(x);
    }
    void avt(int x){
        acs(x),splay(x),rev(x);
    }
    ddp qls(int x,int y){
        return avt(x),acs(y),splay(x),sm[x];
    }
}
```
预处理时要将 $f_{x,1,1}$ 赋为相邻点权最小值。

---

## 作者：yukimianyan (赞：9)

## problem
一棵 $n$ 个点的树。如果两个点在树上的距离不超过 $k$，我们称这两个点可以互相传送信息。现在 $q$ 次给定 $s,t$，选出 $h=\{h_1=s,h_2,h_3,\cdots,h_{c-1},h_c=t\}$ 这 $c$ 个点，满足相邻两个点可以互相传送信息，请最小化 $\sum_{i\in h}v_i$。

## 前置知识
[$\{\max,+\}$ 矩阵乘法 / 动态 DP](https://www.luogu.com.cn/problem/soluation/P4719)。对于矩阵 $a,b,c$，这是我们所熟知的矩阵乘法 $c=a\times b$：

$$c=a\times b\Rightarrow c_{i,j}=\sum_{k}a_{i,k}b_{k,j}.$$

现在我们定义矩阵 $*$ 法：

$$c=a*b\Rightarrow c_{i,j}=\min_{k}\{a_{i,k}+b_{k,j}\}.$$

为了更好地理解矩阵 $*$ 法，您可以认为，$c_{i,j}$ 的值是 $a$ 的第 $i$ 行**顺时针**旋转 $90^\circ$ 后与 $b$ 的第 $j$ 列依次相加取最小值的结果。如果某一个值是 $\infty$ 代表强制不选，如果是 $0$ 代表继承。

我们可以证明，矩阵 $*$ 法没有交换律，但有结合律。

## solution when $k\leq 2$
$k=1$ 是【模板】链上求和。将 $s\to t$ 这条链拉出来，记链上第 $i$ 个点的答案为 $f_i$，我们不妨把 $f_i$ 写成矩阵 $*$ 法之形式。

$$\begin{bmatrix}f_{i-1}\end{bmatrix}*\begin{bmatrix}v_{h_i}\end{bmatrix}=\begin{bmatrix}f_i\end{bmatrix}.$$

$k=2$ 时一定会在链上走，如果走下去了回不去，答案更劣。

$$\begin{bmatrix}f_{i-1},f_{i-2}\end{bmatrix}
*\begin{bmatrix}
v_{h_i},&0\\
v_{h_i},&\infty\\
\end{bmatrix}
=\begin{bmatrix}f_{i},f_{i-1}\end{bmatrix}.$$

![](https://cdn.luogu.com.cn/upload/image_hosting/a1iusv8s.png)
（走下去再返回（即红边）不如不走（即绿边））

## solution when $k=3$
$k=3$ 时最多向下走一步，不然就走不出去了。令 $f_{i,0}$ 表示在点 $i$ 的最小代价，$f_{i,1}$ 表示在 $i$ 的某一个儿子（可以算上父亲，这不重要）上的最小代价。
$$\begin{cases}
b_i&=\min_{\text{j是i的儿子或父亲}} v_j.\\
f_{i,0}&=\min\{f_{i-3,0},f_{i-2,0},f_{i-2,1},f_{i-1,0},f_{i-1,1}\}+v_{h_i}.\\
f_{i,1}&=\min\{f_{i-2,0},f_{i-1,0},f_{i-1,1}\}+b_{h_i}.\\
\end{cases}$$

考虑优化：我们不太关心这些点在链上还是不在链上。令 $f_{i,j}$ 表示现在在离第 $i$ 个点距离为 $j$ 的点上。重定义 $b_i=\min_{\text{j是i的儿子}} v_j$。

$$\begin{bmatrix}f_{i-1,0},f_{i-1,1},f_{i-1,2}\end{bmatrix}
*\begin{bmatrix}
v_{h_i},&0,&\infty\\
v_{h_i},&b_{h_i},&0\\
v_{h_i},&\infty,&\infty\\
\end{bmatrix}
=\begin{bmatrix}f_{i,0},f_{i,1},f_{i,2}\end{bmatrix}
$$
![](https://cdn.luogu.com.cn/upload/image_hosting/ea6chs1x.png)

（这里转移不用关心走到 $i-1$ 的情况，已经在 $f_{i-1,0}$ 那里算过了，不用管）

（这里 $b_i$ 仅限儿子，在 LCA 处要稍微动一下，加上父亲的贡献）

（为了不分讨，可以强行认为 $f_0=\begin{bmatrix}\infty,\infty,0\end{bmatrix}$，尽管它并没有实际意义）

于是你会了暴力。

## solution 的优化
考虑把这玩意多组询问。

观察到每一个转移矩阵只和 $h_i,v_{h_i},b_{h_i}$ 有关，而后两个可以预处理，那么转移矩阵可以预处理。

模仿倍增 LCA，我们也整一个 $dw_{i,j},up_{i,j}$，分别表示以 $i$ 为最后一个点，从上往下 / 从下往上数 $2^j$ 个父亲的矩阵 $*$ 和。转移可以从 $2^{j-1}$ 那里拼起来，$O(nk^3\log n)$；询问可以把路径拆成 $s\to lca(s,t),lca(s,t),lca(s,t)\to t$ 三段，分别 $O(k^3\log n)$ 的求出矩阵 $*$ 和，求出答案即可。

注意到在 $lca$ 处可能走到它的父亲上，我们直接改它的转移矩阵中的 $b_i$ 即可。

总的复杂度为 $O((n+q)k^3\log n)$。

## code
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
typedef long long LL;
typedef long long LL;
template<int N,int M,class T=LL> struct matrix{
	T a[N][M];
	matrix(T flag=1e18){memset(a,0x3f,sizeof a);for(int i=0;i<N&&i<M;i++) a[i][i]=flag;}
	T* operator[](int i){return a[i];}
};
template<int N,int M,int R,class T=LL> matrix<N,R,T> operator*(matrix<N,M,T> a,matrix<M,R,T> b){
	matrix<N,R,T> c=1e18;
	for(int i=0;i<N;i++){
		for(int j=0;j<M;j++){
			for(int k=0;k<R;k++){
				c[i][k]=min(c[i][k],a[i][j]+b[j][k]);
			}
		}
	}
	return c;
};
template<int N,int M,class T=int> struct graph{
	int head[N+10],nxt[M*2+10],cnt;
	struct edge{
		int u,v; T w;
		edge(int u=0,int v=0,T w=0):u(u),v(v),w(w){}
	} e[M*2+10];
	graph(){memset(head,cnt=0,sizeof head);}
	edge& operator[](int i){return e[i];}
	void add(int u,int v,T w=0){e[++cnt]=edge(u,v,w),nxt[cnt]=head[u],head[u]=cnt;}
	void link(int u,int v,T w=0){add(u,v,w),add(v,u,w);}
};
LL a[200010],b[200010];
int n,m,sshwy,fa[19][200010],dep[200010];
graph<200010,200010> g;
matrix<3,3> dw[19][200010],up[19][200010];
matrix<1,3> f0;
matrix<3,3> gettrans(int i,LL del=1e18){
	matrix<3,3> c=1e18; 
	switch(sshwy){
		case 1: c[0][0]=a[i]; break;
		case 2: c[0][1]=0,c[0][0]=c[1][0]=a[i]; break;
		case 3: c[0][0]=c[1][0]=c[2][0]=a[i],c[0][1]=c[1][2]=0,c[1][1]=min(b[i],del); break;
	}
	return c;
}
void dfs(int u,int f=0){
	dep[u]=dep[fa[0][u]=f]+1,b[u]=1e18;
	for(int i=g.head[u];i;i=g.nxt[i]){
		int v=g[i].v; if(v==f) continue;
		dfs(v,u),b[u]=min(b[u],a[v]);
	}
	dw[0][u]=up[0][u]=gettrans(u);
}
int lca(int u,int v){
	if(dep[u]<dep[v]) swap(u,v); int d=dep[u]-dep[v];
	for(int j=18;j>=0;j--) if(d>>j&1) u=fa[j][u];
	if(u==v) return u;
	for(int j=18;j>=0;j--) if(fa[j][u]!=fa[j][v]) u=fa[j][u],v=fa[j][v];
	return fa[0][u];
}
matrix<3,3> query_dw(int u,int k){
	matrix<3,3> res=0;
	for(int j=18;j>=0;j--) if(k>>j&1) res=dw[j][u]*res,u=fa[j][u];
	return res;
}
matrix<3,3> query_up(int u,int k){
	matrix<3,3> res=0;
	for(int j=18;j>=0;j--) if(k>>j&1) res=res*up[j][u],u=fa[j][u];
	return res;
}
LL query(int u,int v){
	int k=lca(u,v);
	matrix<1,3> res=f0*query_up(u,dep[u]-dep[k])*gettrans(k,a[fa[0][k]])*query_dw(v,dep[v]-dep[k]) 
	return min({res[0][0]-a[v],res[0][1],res[0][2]})+a[v];
}
int main(){
	scanf("%d%d%d",&n,&m,&sshwy);
	f0[0][sshwy-1]=0,a[0]=1e18;
	for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
	for(int i=1,u,v;i<n;i++) scanf("%d%d",&u,&v),g.link(u,v);
	dfs(1);
	for(int j=1;j<=18;j++){
		for(int i=1;i<=n;i++) fa[j][i]=fa[j-1][fa[j-1][i]];
		for(int i=1;i<=n;i++) dw[j][i]=dw[j-1][fa[j-1][i]]*dw[j-1][i];
		for(int i=1;i<=n;i++) up[j][i]=up[j-1][i]*up[j-1][fa[j-1][i]];
	}
	for(int u,v;m--;) scanf("%d%d",&u,&v),printf("%lld\n",query(u,v));
	return 0;
}

```


---

## 作者：vectorwyx (赞：9)

手模一下不难看出 $k\le 2$ 时最优路径经过的点一定是 $x\to y$ 对应链的子集。那么考虑**倍增**维护 $[x,fa(x,i))$ 之间的路径信息，其中 $fa(x,i)$ 表示 $x$ 的 $2^i$ 级祖先。我们关心的是如何合并两条链的信息，首先对于一条有意义的路径，它经过的点的集合是这条链对应点集的子集，同时它的两个端点与 $s,t$ 的距离一定小于 $k$，于是我们可以对每条链记 $f(i,j)$ 表示从链上与起点距离为 $i$ 的点出发，走到与终点距离为 $j$ 的点的最少花费。自底向上合并两条链 $A,B$ 得到链 $C$ 时（假设 $A$ 的链顶的父亲即为 $B$ 的链底），只需要枚举 $A$ 对应的 $f$ 数组 $f(i,j)$ 与 $B$ 对应的 $f$ 数组 $f'(t,l)$，如果 $j+t<k$ 就把 $f(i,j)+f'(k,l)$ 贡献到 $C$ 的 $f(i,l)$。相当于把所有可能用来拼接的路径都拎了出来。代码形式可能更好理解一些（代码中的 $K=k-1$，fo 是 for 循环，ret.a 是答案数组）：

```cpp
#define sml(x,y) (x=min(x,y))
fo(i,0,K)	
    fo(j,0,K)
        fo(w,0,K-j)
            fo(t,0,K) sml(ret.a[i][t],a[i][j]+X.a[w][t]);
```

还有一个细节是如果合并中的某一方的长度小于 $k$，它拎出来合并的路径中会存在空路径，所以还要额外维护长度信息，同时特判此类情况：
```cpp
struct Node{
	ll a[3][3];
	int len;
	Node(){memset(a,0x3f,sizeof a);len=0;}
	Node operator+(const Node &X){
		Node ret;ret.len=X.len+len;
		fo(i,0,K)	
			fo(j,0,K)
				fo(w,0,K-j)
					fo(t,0,K) sml(ret.a[i][t],a[i][j]+X.a[w][t]);
		if(len<=K)
			fo(i,0,K-len) fo(j,0,K) sml(ret.a[i+len][j],X.a[i][j]);
		if(X.len<=K)
			fo(i,0,K) fo(j,0,K-X.len) sml(ret.a[i][j+X.len],a[i][j]);
		re ret;
	}
}
```

至此我们就能合并两条任意长度的链的信息了。预处理倍增数组时将单点组成的链的 $f(0,0)$ 设为这个点的权值，其余为 $+\infty$；长度设为 $1$。不断地倍增合并即可得到 $[x,fa(x,i))$ 的信息。

对于询问 $x,y$，只需要把 $x\to y$ 的路径拆成 $x\to \operatorname{lca}(x,y),\operatorname{lca}(x,y)\to y$ 的两条链，前者可以通过倍增拼出，后者可以先拼出 $y\to\operatorname{lca}(x,y)$ 的链，然后把它的 $f$ 数组转置一下就能得到翻转后的链的信息。单次合并的复杂度是 $O(k^4)$，总复杂度为 $O((n+q)\log n\times k^4)$。

而在 $k=3$ 时情况发生了一些变化，此时最优路径中可能涉及到的点是 $x\to y$ 的毛毛虫（链与所有邻接点组成的集合）。具体可以看看这个实例：

```
8 1 3
1 10 10 10 10 1 1 1
1 2
2 3
2 4
3 5
3 6
4 7
5 8

8 7
```
最优路径是 $8\to 6\to 1\to 7$，中间经过的两个点都不在 $8\to 7$ 组成的链上。

那么考虑由维护 $[x,fa(x,i))$ 之间的链信息改为维护毛毛虫信息，为了方便合并，这里不把链顶的父亲视为这条链对应的毛毛虫中的元素。信息合并的方式并不会改变，改变的是预处理时单点 $x$ 的信息。此时对应毛毛虫是 $x$ 和它的所有子结点，如果在向上走的过程中绕出了某条链到达 $x$ 的某个子结点，选择其中权值最小的那个显然最优。所以有用的只有 $x$ 子结点中权值最小的那个。

不过也不完全是这样，因为在拼接链 $x\to y,s\to t$（假设 $s$ 是 $y$ 的父亲）时，对于 $s$ 来说显然不能停留在 $y$ 这个儿子上，即使 $y$ 是它权值最小的儿子。于是我们再维护一个倍增数组表示不考虑链底的权值最小的儿子的毛毛虫信息。这样的话就很好办了，照样倍增合并出两个倍增数组，回答询问 $x\to y$ 时把 $\operatorname{lca}(x,y)$ 单独拆出来视为一个单点的链，求一下这个单点去掉 $x,y$ 方向上的儿子后的毛毛虫信息。剩下的 $[x,\operatorname{lca}(x,y)),(\operatorname{lca}(x,y),y]$ 用倍增拼出，然后按顺序合并这三条链。复杂度还是 $O((n+q)\log n\times k^4)$。代码不需要分类讨论，很好写：

```cpp
#include<bits/stdc++.h>
#define pii pair<int,int>
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define mk make_pair
#define sml(x,y) (x=min(x,y))
#define big(x,y) (x=max(x,y))
#define ll long long
#define uint unsigned
#define ull unsigned long long
#define umap unordered_map
#define db double
#define fo(i,x,y) for(int i=(x);i<=(y);++i)
#define go(i,x,y) for(int i=(x);i>=(y);--i)
#define ptc putchar
#define emp emplace
#define re return
#define co continue
using namespace std;
ll seed=chrono::system_clock::now().time_since_epoch().count();
mt19937 rnd(seed);
inline int rm(int x,int y){return (int)(rnd()%(y-x+1ll)+x);}
inline int read(){int ch=getchar(),x=0,f=1;while(!isdigit(ch)){if(ch==(int)('-'))f=-1;ch=getchar();}while(isdigit(ch)){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}return x*f;}
inline void out(int *a,int l,int r){fo(i,l,r) cout<<*(a+i)<<' ';puts("");}

const int N=2e5+5,inf=1e9;
int n,q,K,a[N],son[N],mn1[N],mn2[N],mn3[N],dep[N],fa[N][20],fa_[N][20];
vector<int> e[N];

inline int F(int x,int y){
	if(dep[x]<dep[y]) swap(x,y);
	int k=fa[x][1];
	if(dep[x]==dep[y]){
		if(a[fa[x][0]]>a[fa[x][1]]) swap(x,y);
		if(mn1[k]==a[fa[x][0]]){
			if(mn2[k]==a[fa[y][0]]) re min(a[fa[k][0]],mn3[k]);
			re min(a[fa[k][0]],mn2[k]);
		}
		re min(a[fa[k][0]],mn1[k]);
	}
	if(mn1[k]==a[fa[x][0]]) re mn2[k];
	re mn1[k];
}

struct Node{
	ll a[3][3];
	int len;
	Node(){memset(a,0x3f,sizeof a);len=0;}
	Node operator+(const Node &X){
		Node ret;ret.len=X.len+len;
		fo(i,0,K)	
			fo(j,0,K)
				fo(w,0,K-j)
					fo(t,0,K) sml(ret.a[i][t],a[i][j]+X.a[w][t]);
		if(len<=K)
			fo(i,0,K-len) fo(j,0,K) sml(ret.a[i+len][j],X.a[i][j]);
		if(X.len<=K)
			fo(i,0,K) fo(j,0,K-X.len) sml(ret.a[i][j+X.len],a[i][j]);
		re ret;
	}
	void rev(){fo(i,0,K) fo(j,i+1,K) swap(a[i][j],a[j][i]);}
}f[N][19],f_[N][19];
int lg;

void dfs1(int x){
	dep[x]=dep[fa[x][0]]+1;
	fa_[x][0]=x;
	fo(i,1,lg){
		fa[x][i]=fa[fa[x][i-1]][i-1];
		fa_[x][i]=fa[fa_[x][i-1]][i-1];
	}
	f[x][0].a[0][0]=a[x];f[x][0].len=1;
	mn1[x]=mn2[x]=mn3[x]=inf;
	for(int i:e[x]) if(i!=fa[x][0]){
		fa[i][0]=x;
		dfs1(i);
		if(a[i]<mn1[x]) son[x]=i,mn3[x]=mn2[x],mn2[x]=mn1[x],mn1[x]=a[i];
		else if(a[i]<mn2[x]) mn3[x]=mn2[x],mn2[x]=a[i];
		else sml(mn3[x],a[i]);
	}
	f[x][0].a[1][1]=mn1[x];
	f_[x][0]=f[x][0];f_[x][0].a[1][1]=mn2[x];
}

void dfs2(int x){
	fo(i,1,lg){
		if(fa_[x][i-1]==son[fa[x][i-1]]){
			f[x][i]=f[x][i-1]+f_[fa[x][i-1]][i-1];
			f_[x][i]=f_[x][i-1]+f_[fa[x][i-1]][i-1];
		}else{
			f[x][i]=f[x][i-1]+f[fa[x][i-1]][i-1];
			f_[x][i]=f_[x][i-1]+f[fa[x][i-1]][i-1];			
		}	
	}
	for(int i:e[x]) if(i!=fa[x][0]) dfs2(i);
}

inline int lca(int x,int y){
	if(dep[x]<dep[y]) swap(x,y);
	go(i,lg,0) if(dep[fa[x][i]]>=dep[y]) x=fa[x][i];
	if(x==y) re x;
	go(i,lg,0) if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];
	re fa[x][0];
}

void file(){
	freopen("transmit.in","r",stdin);
	freopen("transmit.out","w",stdout);
}

signed main(){
	memset(a,0x3f,sizeof a);
	cin>>n>>q>>K;
	fo(i,1,n) a[i]=read();
	fo(i,2,n){
		int x=read(),y=read();
		e[x].pb(y),e[y].pb(x); 
	}
	K--;
	lg=(int)log2(n);
	dfs1(1);
	dfs2(1);
	while(q--){
		int x=read(),y=read(),X=x,Y=y,k=lca(x,y);
		if(x==y){
			cout<<a[x]<<'\n';
			co;
		}
		if(dep[x]<dep[y]) swap(x,y);
		Node Ax,Ay;
		int flg=1;
		go(i,lg,0) if(dep[fa[x][i]]>=dep[k]){
			if(X!=son[x]) Ax=Ax+f[x][i];
			else Ax=Ax+f_[x][i];
			x=fa[x][i];
			if(flg) X=fa_[X][i],flg=0;
			else X=fa[X][i];
		}
		flg=1;
		go(i,lg,0) if(dep[fa[y][i]]>=dep[k]){
			if(Y!=son[y]) Ay=Ay+f[y][i];
			else Ay=Ay+f_[y][i];
			y=fa[y][i];
			if(flg) Y=fa_[Y][i],flg=0;
			else Y=fa[Y][i];	
		}
		Ay.rev();
		Node ans;ans.len=1;ans.a[0][0]=a[k];
		if(a[X]>a[Y]) swap(X,Y);
		if(X==son[k]){
			if(y!=k&&a[Y]==mn2[k]) ans.a[1][1]=min(mn3[k],a[fa[k][0]]);
			else ans.a[1][1]=min(mn2[k],a[fa[k][0]]);
		}else ans.a[1][1]=min(mn1[k],a[fa[k][0]]);
		ans=Ax+ans;
		ans=ans+Ay;
		cout<<ans.a[0][0]<<'\n';
	}
	return 0;
}
```

---

## 作者：Mobius127 (赞：9)

[link](https://www.luogu.com.cn/problem/P8820)

题外话：考场写了个 $3^3$ 巨大多恶心的分讨倍增写吐了，不仅没调出来还导致没时间仔细考虑 T1 T3 的 bug，感谢这题送我退役。

对于 $K=1$，相当于树上路径点权和。

对于 $K=2$，不难想到我们最终走过的 $c$ 都在 $s_i \to t_i$ 的树上简单路径上。因为若想走两步规避掉我的父亲，那么我拐到父亲的一个儿子，向上走还是只能到我父亲的父亲，还不如一开始就走到我父亲的父亲（$\operatorname{LCA}$ 处类似）。

对于 $K=3$，类似于 $2$ 的讨论，我们最终的 $c$ 序列只有可能是原来 $s_i\to t_i$ 的简单路径中的点或者这些点的邻接点。

那么先预处理 $a_{x, 0}=v_x, a_{x, 1}=\min_{(x, y)\in T} v_y$。


设 $dp_{x, k}$ 为当前处理完 $s_i \to x$ 部分，现在在距离 $x$ 为 $k$ 的某个点上，最小的代价，$k \in [0, 2]$，现在转移到 $dp_{nxt}$，我们设 $f$ 为 $x$ 处的 $dp$ 值，$g$ 为 $nxt$ 处的 $dp$ 值。

对于 $K=2$，有：

$$\begin{cases}
g_0=\min(f_0+a_{nxt, 0}, f_1+a_{nxt, 0})\\
g_1=f_0 \\
g_2=\operatorname{INF}
\end{cases}$$



对于 $K=3$，有：

$$\begin{cases}
g_0=\min(f_0+a_{nxt, 0}, f_{1}+a_{nxt, 0}, f_2+a_{nxt, 0})\\
g_{1}=\min(f_0, f_{1}+a_{nxt, 1})\\
g_2=f_1
\end{cases}$$

这些递推是比较 trivial 的，大家都能想到，需要考虑一些琐碎的点：

1. 对于 $K=2, g_1$ 的转移：根据结论，当前走到点的前一个点必然还是原路径上的点，那么我只能从 $x$ 走过来。

1. 为什么要考虑 $k=2$ 的情况，虽然 $K=3$ 的情况中非原路径点到路径的最短距离只有 $1$，但我可能从距离 $x$ 为 $2$ 的点走到 $nxt$，故要多考虑 $k=2$。

1. $g_2=f_1$ 这一步，如果 $f_1$ 本身到的点就是 $nxt$，不会重吗？若最优路径选择了 $nxt$，那么会在 $g_0$ 被统计到，若没有，$g_2$ 没有用处，因为我们只会走到邻接点。

发现转移柿子规模很小，考虑矩阵优化。

重新定义矩阵乘法 $c[i][j]=\min (a_{i, k}+b_{k, j})$，发现其类似于 Floyed，因此结合律是有的。

不难写出转移矩阵：

$$
\left[
\begin{aligned}
f_0 && f_1 && f_2
\end{aligned}
\right]

\times 

\left[
\begin{aligned}
a_{nxt, 0} &&  0 && \operatorname{INF} \\
a_{nxt, 0} && \operatorname{INF} && \operatorname{INF}\\
\operatorname{INF} && \operatorname{INF} && \operatorname{INF}\\
\end{aligned}
\right]

=


\left[
\begin{aligned}
g_0 && g_1 && g_2
\end{aligned}
\right], (K=2)
$$

$$
\left[
\begin{aligned}
f_0 && f_1 && f_2
\end{aligned}
\right]

\times 

\left[
\begin{aligned}
a_{nxt, 0} &&  0 && \operatorname{INF} \\
a_{nxt, 0} && a_{nxt, 1} && 0\\
a_{nxt, 0} && \operatorname{INF} && \operatorname{INF}\\
\end{aligned}
\right]

=

\left[
\begin{aligned}
g_0 && g_1 && g_2
\end{aligned}
\right], (K=3)
$$

特别的，$s_i$ 的转移矩阵为：

$$
\left[
\begin{aligned}
a_{x, 0} &&  \operatorname{INF} && \operatorname{INF} \\
\operatorname{INF} && \operatorname{INF} && \operatorname{INF}\\
\operatorname{INF} && \operatorname{INF} && \operatorname{INF}\\
\end{aligned}
\right]
$$

那么直接根据跳的方向（$s_i \to lca$ 向上，$lca \to t_i$ 向下） 倍增一下即可，复杂度 $O(K^3 n \log n)$，注意空间不要开太大。


[code](http://119.27.163.117/submission/30153)


---

## 作者：Leasier (赞：9)

前置芝士：[动态 dp](https://oi-wiki.org/dp/dynamic/)

$k = 1$ 显然可以预处理树上前缀和 + LCA。

$k = 2$ 考虑把这条链抓出来 dp。设 $dp_i$ 表示从 $s$ 到链上第 $i$ 个点的最小权值。

初值：$dp_1 = v_s$。

转移：$dp_i = \min(dp_{i - 1} + dp_{i - 2}) + v_{path_i}$，其中 $path_i$ 表示路径上第 $i$ 个点。

答案：$dp_{cnt}$，其中 $cnt$ 表示链上点数。

这玩意显然可以用 $2 \times 2$ 的矩阵倍增 ddp。

$k = 3$ 仍然考虑把这条链抓出来 dp。但注意到此时我们或许可以通过跳出这条链获得更优贡献。

令 $v'_{u, i}$ 表示与 $u$ 相距 $i$ 的点中权值最小的点的权值。设 $dp_{i, j = 0/1}$ 表示从 $s$ 到离链上第 $i$ 个点距离为 $j$ 的点的最小权值。

初值：$dp_{1, 0} = v_s, dp_{1, 1} = dp_{1, 2} = +\infty$。

转移分为如下三种：

- $dp_{i, 0} = \min(dp_{i - 1, 0}, dp_{i - 1, 1}, dp_{i - 2, 0}) + v_{path_i}$。
- $dp_{i, 1} = \min(dp_{i - 1, 0}, dp_{i - 1, 1} + v'_{path_i, 1})$。
- $dp_{i, 2} = dp_{i - 1, 1}$。

答案：$dp_{cnt, 0}$，其中 $cnt$ 表示链上点数。

这玩意显然可以用 $3 \times 3$ 的矩阵树剖 ddp。

综上，时间复杂度为 $O((n + q) \log n)$。

代码：
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>

using namespace std;

typedef long long ll;

typedef struct {
	int nxt;
	int end;
} Edge;

typedef struct Matrix_tag {
	int n;
	int m;
	ll a[3][3];
	Matrix_tag(){}
	Matrix_tag(int n_, int m_){
		n = n_;
		m = m_;
		for (register int i = 0; i <= n; i++){
			for (register int j = 0; j <= m; j++){
				a[i][j] = 4e18;
			}
		}
	}
} Matrix;

int cnt = 0;
Matrix e;
int v[200007], a[200007], b[200007], head[200007], depth[200007], fa[200007][27], min_val[200007];
ll sum[200007];
Edge edge[400007];
Matrix each[200007], up[200007][18], down[200007][18];

Matrix operator *(Matrix a, Matrix b){
	Matrix ans(a.n, b.m);
	for (register int i = 0; i <= a.n; i++){
		for (register int j = 0; j <= b.m; j++){
			for (register int k = 0; k <= a.m; k++){
				ans.a[i][j] = min(ans.a[i][j], a.a[i][k] + b.a[k][j]);
			}
		}
	}
	return ans;
}

inline void init(int n){
	e = Matrix(n, n);
	for (register int i = 0; i <= n; i++){
		e.a[i][i] = 0;
	}
}

inline void add_edge(int start, int end){
	cnt++;
	edge[cnt].nxt = head[start];
	head[start] = cnt;
	edge[cnt].end = end;
}

void dfs1(int u, int father){
	int t;
	depth[u] = depth[father] + 1;
	t = log2(depth[u]);
	fa[u][0] = father;
	sum[u] = sum[father] + v[u];
	for (register int i = 1; i <= t; i++){
		fa[u][i] = fa[fa[u][i - 1]][i - 1];
	}
	for (register int i = head[u]; i != 0; i = edge[i].nxt){
		int x = edge[i].end;
		if (x != father) dfs1(x, u);
	}
}

inline int lca(int u, int v){
	if (depth[u] < depth[v]) swap(u, v);
	while (depth[u] > depth[v]) u = fa[u][(int)log2(depth[u] - depth[v])];
	if (u == v) return u;
	for (register int i = log2(depth[u]); i >= 0; i--){
		if (fa[u][i] != fa[v][i]){
			u = fa[u][i];
			v = fa[v][i];
		}
	}
	return fa[u][0];
}

void dfs2(int u, int k){
	int t = log2(depth[u]);
	Matrix mat(k - 1, k - 1);
	if (k == 2){
		mat.a[0][0] = mat.a[1][0] = v[u];
		mat.a[0][1] = 0;
	} else {
		mat.a[0][0] = mat.a[1][0] = mat.a[2][0] = v[u];
		mat.a[0][1] = mat.a[1][2] = 0;
		mat.a[1][1] = min_val[u];
	}
	each[u] = up[u][0] = down[u][0] = mat;
	for (register int i = 1; i <= t; i++){
		int x = fa[u][i - 1];
		up[u][i] = up[u][i - 1] * up[x][i - 1];
		down[u][i] = down[x][i - 1] * down[u][i - 1];
	}
	for (register int i = head[u]; i != 0; i = edge[i].nxt){
		int x = edge[i].end;
		if (x != fa[u][0]) dfs2(x, k);
	}
}

Matrix get_up(int u, int v){
	Matrix ans = e;
	while (depth[u] > depth[v]){
		int x = log2(depth[u] - depth[v]);
		ans = ans * up[u][x];
		u = fa[u][x];
	}
	if (u == v) ans = ans * each[u];
	return ans;
}

Matrix get_down(int u, int v){
	Matrix ans = e;
	while (depth[u] > depth[v] + 1){
		int x = log2(depth[u] - depth[v] - 1);
		ans = down[u][x] * ans;
		u = fa[u][x];
	}
	if (depth[u] > depth[v]) ans = each[u] * ans;
	return ans;
}

int main(){
	int n, q, k;
	scanf("%d %d %d", &n, &q, &k);
	for (register int i = 1; i <= n; i++){
		scanf("%d", &v[i]);
	}
	for (register int i = 1; i < n; i++){
		scanf("%d %d", &a[i], &b[i]);
		add_edge(a[i], b[i]);
		add_edge(b[i], a[i]);
	}
	dfs1(1, 0);
	if (k == 1){
		for (register int i = 1; i <= q; i++){
			int s, t, cur_lca;
			scanf("%d %d", &s, &t);
			cur_lca = lca(s, t);
			cout << sum[s] + sum[t] - sum[cur_lca] - sum[fa[cur_lca][0]] << endl;
		}
	} else {
		init(k - 1);
		for (register int i = 1; i <= n; i++){
			min_val[i] = 0x7fffffff;
		}
		for (register int i = 1; i < n; i++){
			min_val[a[i]] = min(min_val[a[i]], v[b[i]]);
			min_val[b[i]] = min(min_val[b[i]], v[a[i]]);
		}
		dfs2(1, k);
		for (register int i = 1; i <= q; i++){
			int s, t;
			scanf("%d %d", &s, &t);
			int cur_lca = lca(s, t);
			Matrix mat;
			if (cur_lca == s){
				mat = e;
			} else {
				mat = get_up(fa[s][0], cur_lca);
			}
			if (cur_lca != t) mat = mat * get_down(t, cur_lca);
			cout << mat.a[0][0] + v[s] << endl;
		}
	}
	return 0;
}
```

---

## 作者：donkeys (赞：7)

今年的~~€€￡ SCP~~CCF CSP-S整体上感觉有点水。

大思路，有点......一眼题。使用 $O(n\log n)$ 的树上倍增DP求解。

我们不妨类比LCA的在线求法来维护我们的DP数组。其中较为优秀的是树上倍增。我们需要维护的是树上每一条长度是 $2^k$ 的链的代价。那么设计状态：最外层显然是 `f[i][k]` 表示从节点 $i$ 向上跳 $2^k$ 步。

那么看我们还需要什么信息才能转移：对于一条起点 $a$，终点 $b$ 的链，我们要知道两端选择的机器到 $a,b$ 的距离。猛一想，寄了。往下一翻数据范围，噫，好，$k\le3$。那么我们最终的状态就出来了：`f[i][k][a][b]` 表示对于 `f[i][k]` 这一条链，最下面的机器距端点的距离为 $a$，最上面的机器距端点的距离为 $b$ 的最小代价。

然后这里有两个小优化：

一个是优化复杂度的。贪心的想，$a,b$ 小的情况一定可以包含 $a,b$ 大的情况，所以我们不妨对其取 $\text{min}$，这样在转移的时候复杂度会更低（具体可以根据后面的实现来分析一下如果不这样做会发生什么）。

另一个更加便于理解和实现。我们可以把树上的一段区间想象成一根网线，对这根网线输入强度为 $a$ 的信号，它可以花费 `f[i][k][a][b]` 的代价输出强度为 $b$ 的信号。显然不能让信号消失不然就丢包了(((

个人觉得使用这种方法更加便于理解和叙述，所以下文 `f` 数组的定义皆为上述含义。

应该怎么初始化呢？对于每根网线 `f[i][0]`，我们有选和不选两种方案。如果选的话，我们可以花费 $v_i$ 的代价，将一个输入强度为 $0$ 的信号增幅到 $k-1$（计算了信号传出的“衰减”），也可以不选，将令强度为 $x$ 的输入衰减到 $x-1$。其他情况皆赋正无穷。

但是，这样初始化就大寄特寄了。举个简单的例子，在 $k=3$，查询 $1,5$ 的情况下：

![image-20221105235121875](https://cdn.luogu.com.cn/upload/image_hosting/ydtg7245.png)

节点 $2,3,4$ 的 $v$ 是 $\text{inf}$，节点 $6$ 是 $1$。如何选择？显然选 $6$。简单的模拟和计算后，我们得到：当且仅当 $k=3$ 的时候，我们可以通过相邻节点进行一个这样的操作：花费相邻节点的代价，输入并输出一个强度为 $1$ 的信号。

然后，就是对两个状态的合并了。其实这里已经比较简单了，可以试试想想。我们直接枚举合并后区间的 $a,b$ 和一个区间的输出信号强度 $x$，那么 $\min_{x<k}(f[a][x]+f[x][b])$ 就是合并后的值。

然后对于两根网线公对公的拼接（就是两个突出的衔接），简单处理一下就行，详见代码。

愉快的倍增吧！

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace IO
{
	bool EOFstate = 0;
	template<typename T>inline void read(T& x)
	{
		x = 0; int f = 1; char c = getchar();
		while(('0' > c || c > '9') && !EOFstate) { if(c == '-')f = -1; c = getchar(), EOFstate = c == EOF; }
		while('0' <= c && c <= '9')x = (x << 3) + (x << 1) + c - '0', c = getchar();
		x *= f;
	}
	template<typename T = int>inline T read()
	{
		T x;
		x = 0; int f = 1; char c = getchar();
		while(('0' > c || c > '9') && !EOFstate) { if(c == '-')f = -1; c = getchar(), EOFstate = c == EOF; }
		while('0' <= c && c <= '9')x = (x << 3) + (x << 1) + c - '0', c = getchar();
		x *= f;
		return x;
	}
	template<typename T>inline void write(T x, char end = ' ')
	{
		if(x == 0)return putchar('0'), putchar(end), void();
		if(x < 0)putchar('-'), x = -x;
		char c[21], cnt = 0;
		while(x)c[cnt++] = x % 10 + '0', x /= 10;
		while(cnt)putchar(c[--cnt]); putchar(end);
	}
}using namespace IO;

const int N = 2e5 + 5, K = 20, A = 3;
#define ll long long
#define getB(x) (31-__builtin_clz(x))

int n, q, lim;
struct Node
{
	ll a[A][A];
	inline void clear()
	{
		memset(a, 0x3f, sizeof(a));
		a[0][0] = 0;
	}
	inline void ext()//贪心扩展状态
	{
		for(int i = 0; i < lim - 1; ++i)
			for(int j = lim - 1; ~j; --j)
				a[i + 1][j] = min(a[i + 1][j], a[i][j]);
		for(int i = 0; i < lim; ++i)
			for(int j = lim - 1; j > 0; --j)
				a[i][j - 1] = min(a[i][j - 1], a[i][j]);
	}
	inline void init(ll v)
	{
		memset(a, 0x3f, sizeof(a));
		a[0][lim - 1] = v;
		for(int i = 1; i < lim; ++i)
			a[i][i - 1] = 0;
	}
};
Node up[N][K];
int fa[N][K], dep[N];
int val[N];
int head[N], to[N << 1], nxt[N << 1], tot;
inline void _add(int f, int t)
{
	to[++tot] = t, nxt[tot] = head[f], head[f] = tot;
}
inline void add(int a, int b)
{
	_add(a, b), _add(b, a);
}
void dfs(int p, int f)
{
	dep[p] = dep[f] + 1, fa[p][0] = f;
	for(int i = head[p]; i; i = nxt[i])
		if(to[i] != f)
			dfs(to[i], p);
}
inline void extend(int p)
{
	up[p][0].init(val[p]);
	if(lim == 3)
		for(int i = head[p]; i; i = nxt[i])
			up[p][0].a[1][1] = min(up[p][0].a[1][1], val[to[i]]*1ll);
	up[p][0].ext();
}
inline void merge(Node& T, Node f, Node g)//合并两根网线
{
	for(int a = 0; a < lim; ++a)
		for(int b = 0; b < lim; ++b)
		{
			ll v = 0x3f3f3f3f3f3f3f3f;
			for(int j = 0; j < lim; ++j)
				v = min(v, f.a[a][j] + g.a[j][b]);
			T.a[a][b] = v;
		}
}
inline void init()
{
	int mx = getB(n);
	for(int k = 1, t; k <= mx; ++k)
		for(int i = 1; i <= n; ++i)
		{
			t = fa[i][k - 1];
			fa[i][k] = fa[t][k - 1];
			merge(up[i][k], up[i][k - 1], up[t][k - 1]);
		}
}
Node vala, valb;
inline int LCA(int a, int b)
{
	vala.clear(), valb.clear();
	if(dep[a] < dep[b])
		swap(a, b), swap(vala, valb);
	for(int i = dep[a] - dep[b], k = i & -i; i; i ^= k, k = i & -i)//没什么用的卡常(莫非是getB常数太大)
		merge(vala, vala, up[a][getB(k)]), a = fa[a][getB(k)];
	if(a == b)
		return a;
	for(int i = getB(dep[a]); ~i; --i)//有点用的卡常
		if(fa[a][i] != fa[b][i])
			merge(vala, vala, up[a][i]), merge(valb, valb, up[b][i]), a = fa[a][i], b = fa[b][i];
	merge(vala, vala, up[a][0]), merge(valb, valb, up[b][0]);
	return fa[a][0];
}
signed main()
{
	read(n), read(q), read(lim);
	for(int i = 1; i <= n; ++i)
		read(val[i]);
	for(int i = 2; i <= n; ++i)
		add(read(), read());
	dfs(1, 0);
	for(int i = 1; i <= n; ++i)
		extend(i);
	init();
	for(int i = 1, s, t; i <= q; ++i)
	{
		read(s), read(t);
		int lca = LCA(s, t);
		merge(vala, vala, up[lca][0]);//将lca也合入一根网线
		ll v = LLONG_MAX;
		for(int i = 0; i < lim; ++i)
			v = min(v, vala.a[0][i] + valb.a[0][lim - i - 1]);
		write(v, '\n');
	}
	return 0;
}

```



---

## 作者：yzy1 (赞：6)

### 题目大意

给定结点数为 $n$（$1 \le n \le 2\times 10^5$）的无根树．结点依次编号为 $1\sim n$ 的整数．编号为 $i$ 的结点有权值 $v_i$（$1 \le v_i \le 10^9$）．给定 $m$（$1 \le m \le 2 \times 10^5$）次询问，每次询问给定 $a,b$（$1\le a,b \le n$）．定义一个长度为 $s$ 的结点序列 $\{c_1,c_2,\cdots,c_s\}$ 是符合条件的，当且仅当：

- $c_1 = a$．
- $c_s = b$．
- $\forall$ 整数 $i \in [1,s-1]$，均有 $\operatorname{dis}(c_i,c_{i+1}) \le K$．其中 $\operatorname{dis}(i,j)$ 表示连接结点 $i$ 与 $j$ 的路径中包含边数最少的路径所包含的边数，$K$ 为一给定常量且 $1\le K \le 3$．

定义一个结点序列的权值为序列中所有结点的点权 $v_i$ 之和．对于每次询问，输出权值最小且符合条件的权值序列的权值．

### 简要做法

考虑如果只有一次询问时如何做．考虑设 $a,b$ 路径上从 $a$ 到 $b$ 方向上所有点的编号依次为 $c_1,c_2,\cdots,c_s$．我们大胆猜测一个结论：一个符合条件的结点序列一定是这个序列的子序列，且相邻两项的下标之差 $\le K$．考虑 DP，设 $\operatorname{dp}(u)$ 为 $u$ 结尾的所有符合条件的结点序列的权值最小值，转移即可．

但是很遗憾，上所做法在 $K=3$ 时是错误的，考虑下列数据：

```plain
6 1 3
9 9 9 9 9 9 1
1 2
2 3
3 4
4 5
3 6
5 1
```

上述做法得到的一种最优序列为 $\{5,3,1\}$，但是显然序列 $\{5,6,1\}$ 要比它更优．考虑更改 DP 状态，使它允许走到路径外的结点，设 $\operatorname{dp}(u,i)$ 表示当前处理到了结点 $u$，选中的最后一个结点距离 $u$ 的 $\operatorname{dis}$ 为 $i$ 的所有符合条件的结点序列的权值最小值．在 $K=3$ 时，则有转移：

$$
\begin{aligned}
\operatorname{dp}(u,2) &\gets \operatorname{dp}(u',1)\\
\operatorname{dp}(u,1) &\gets \min\{\operatorname{dp}(u',0),\operatorname{dp}(u',1)+ M_u\}\\
\operatorname{dp}(u,0) &\gets \min_{i=0}^{K-1} \operatorname{dp}(u',i) + a_u
\end{aligned}
$$

其中 $M_u$ 表示所有与结点 $u$ 距离为 $1$ 的结点的权值的最小值．

考虑如何处理多次询问．将上述 DP 转化为可区间合并的信息 $D=(u,v,F)$，然后使用树上倍增维护．其中 $u,v$ 为树链的起止点，$F$ 为一个二维 DP 数组，$F(i,j)$ 表示选中的第一个结点与结点 $u$ 的距离为 $i$，最后一个结点与结点 $v$ 的距离为 $j$，所有符合要求的序列的权值最小值．合并两个信息 $D_1$ 与 $D_2$ 时进行分类讨论：

- 若 $\min\{\operatorname{dis}({D_1}_u,{D_1}_v),\operatorname{dis}({D_2}_u,{D_2}_v)\} \le 3$，则暴力将小的信息对应的每个结点依次合并到大的上．
- 否则，采用以下方式合并：

```cpp
FOR (l1, 0, 2)
  FOR (r1, 0, 2)
    FOR (l2, 0, 2)
      if (r1 + l2 + 1 <= K)
        FOR (r2, 0, 2) {
          to_min(res.F[l1][r2], d1.F[l1][r1] + d2.F[l2][r2]);
        }
res.l = d1.l;
res.r = d2.r;
```

查询时将链 $a,b$ 拆分为两条单链 $a,\mathit{lca}$ 与 $\mathit{lca},b$，按照顺序合并各部分，最后输出 $D_F(0,0)$ 即可．

时间复杂度 $O(K^4 (n+m) \log n)$．

---

## 作者：masterhuang (赞：2)

背景：由于 FZ 考试因疫情取消，于是我们学校组织了线上测试。

赛场连假做法都没打完，然后暴力忘记交了。。。

[题目链接](https://www.luogu.com.cn/problem/P8820?contestId=90216) [参考博客](https://www.cnblogs.com/sizeof127/p/16841791.html)

题目评价：场切有点困难，但是76分比较容易。
## 解法

一眼 $ddp$ ，没话说。下面假设树以 $1$ 为根。一次传输称作从一个点跳到另一个点。设询问的两个点为 $u,v$，$x$ 点的权值为 $c_x$。

**当 k=1 时**，问题转化为求一条路径的权值和。~~（这是显然的）~~ 记 $s_i$ 表示 $i$ 到根的路径上的权值和。则答案为：$\large s_u+s_v-s_{lca}-s_{fa_{lca}}$。

**当 k=2 时**，跳跃方式最优显然是：
![](https://cdn.luogu.com.cn/upload/image_hosting/jp1i044b.png)
即每次**往上**跳 $1$ 或 $2$ 步。设已经跳到 $x$ 点，上一个点（路径上 $x$ 的儿子）是点 $y$。

$f_{x,0/1}$ 表示跳到 $x$ 的 路径上的儿子$/$孙子最小答案。

$\begin{cases}
f_{x,0}=\min\{f_{y,0}+c_x,f_{y,1}+c_x\}\\
f_{x,1}=f_{y,0}
\end{cases}$


写成矩阵转移：$[f_{y,0},f_{y,1}]\times\begin{bmatrix}
c_x & +\infty\\
c_x & 0
\end{bmatrix}=[f_{x,0},f_{x,1}]$。这里（下面也是）矩阵乘法 $A\times B=C$ 满足 $C_{i,j}=\min\{A_{i,k}+B_{k,j}\}$。容易得到这种矩阵乘法没有交换律，有结合律。

先从 $fa_u$ 一直向上转移到 $lca$ 再从 $lca$ 一直向下转移到 $v$，用矩阵转移。在**最前面**乘上 $\begin{bmatrix}
c_u & +\infty\\
+\infty & +\infty
\end{bmatrix}$ (相当于初始 $[f_{u,0},f_{u,1}]=[c_u,+\infty]$) ，得到的矩阵第一行第一列（即 $f_{v,0}$）就是答案。处理 $u$ 往上跳和 $lca$ 往下跳用倍增即可。

**当 k=3 时**，记 $f_{x,0/1/2}$ 表示跳到距离 $x$ 点 $0/1/2$ 的最小答案。已经跳到 $x$，上一个点是 $y$。

每次距离为 $1$ 时可以是这个点的父亲，这个点在路径上的儿子，这个点的其他儿子（都有可能会转移）。

距离为 $2$ 时可能是这个点路径上的孙子，这个点路径上的儿子的其他所有儿子（其他情况都一定不优）。

有：$\begin{cases}
f_{x,0}=\min\{f_{y,0}+c_x,f_{y,1}+c_x,f_{y,2}+c_x\}\\
f_{x,1}=\min\{f_{y,0},f_{y,1}+c'_x\}\\
f_{x,2}=f_{y,1}
\end{cases}$ 这里 $c'_x$ 表示所有距离 $x$ 为 $1$ 的点中 $c$ 值的最小值。

![](https://cdn.luogu.com.cn/upload/image_hosting/s3s524k6.png)

距离 $x$ 为 $1$ 的点可能通过红线跳过去，于是就有了 $f_{y,1}+c'_x$。

还有一个问题：如果 $f_{y,1}$ 最终是在 $y$ 的父亲那不是 $f_{x,1},f_{x,2}$ 的转移都不成立了吗？

考虑到这样转移到 $f_{x,1},f_{x,2}$ 显然都不是最优的跳跃方案，对答案没有贡献，即使转移了也没关系。而最优的方案都被转移了，保证了答案的正确性。

转移写成矩阵：$[f_{y,0},f_{y,1},f_{y,2}]\times\begin{bmatrix}
c_x & 0&+\infty\\
c_x & c'_x&0\\
c_x & +\infty&+\infty
\end{bmatrix}=[f_{x,0},f_{x,1},f_{x,2}]$。同上倍增维护即可。

code，可以参考一下这里倍增的实现方法:
```cpp
#include<bits/stdc++.h>
#define LL long long
#define fr(x) freopen(#x".in","r",stdin);freopen(#x".out","w",stdout);
using namespace std;
const int N=2e5+5;const LL inf=1e18;
int n,m,K,tot,head[N],d[N],w[N],w1[N],fa[N][25];
LL s[N];
struct edge{int to,nex;}e[N<<1];
inline void add(int u,int v)
{
	e[++tot]={v,head[u]};head[u]=tot;
	e[++tot]={u,head[v]};head[v]=tot;
}
struct jz
{
	LL a[3][3];
	jz(){memset(a,0,sizeof(a));}
	inline LL* operator[](int x){return a[x];}
	inline void E(){for(int i=0;i<K;i++) for(int j=0;j<K;j++) a[i][j]=(i==j)?0:inf;}
}b[N][25][2];
inline jz A(LL x)
{
	jz z;
	if(K==2) z[1][1]=inf,z[0][1]=0,z[0][0]=z[1][0]=w[x];
	else z[0][2]=z[2][1]=z[2][2]=inf,z[0][1]=z[1][2]=0,
	z[0][0]=z[1][0]=z[2][0]=w[x],z[1][1]=w1[x];return z;
}
inline jz operator*(jz x,jz y)
{
	jz z;
	for(int i=0;i<K;i++) for(int j=0;j<K;j++) z[i][j]=inf;
	for(int i=0;i<K;i++) for(int j=0;j<K;j++)
	for(int k=0;k<K;k++) z[i][j]=min(z[i][j],x[i][k]+y[k][j]);
	return z;
}
void dfs(int th,int f)
{
	d[th]=d[f]+1;fa[th][0]=f;w1[th]=w[f];
	for(int i=1;i<=20;i++) fa[th][i]=fa[fa[th][i-1]][i-1];
	if(K==1) s[th]=s[f]+w[th];
	for(int i=head[th];i;i=e[i].nex)
	{
		int to=e[i].to;
		if(to!=f) dfs(to,th),w1[th]=min(w1[th],w[to]);
	}
}
inline int lca(int u,int v)
{
	if(d[u]<d[v]) swap(u,v);
	int t=d[u]-d[v];
	for(int i=0;t;t>>=1,i++) if(t&1) u=fa[u][i];
	if(u==v) return u;
	for(int i=20;i>=0;i--) if(fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i];
	return fa[u][0];
}
inline jz Ju(int x,int L,int o)
{
	x=fa[x][0];int t=d[x]-d[L];jz z;z.E();
	for(int i=0;t>0;t>>=1,i++) if(t&1) z=(!o)?(z*b[x][i][0]):(b[x][i][1]*z),x=fa[x][i];
	return z;
}
inline LL slo(int u,int v)
{
	int L=lca(u,v);
	if(K==1) return s[u]+s[v]-s[L]-s[fa[L][0]];if(d[u]<d[v]) swap(u,v);
	jz y;y.E();y[0][0]=w[u],y[1][1]=y[2][2]=inf;
	jz z=(v==L)?(y*Ju(u,v,0)*A(v)):(y*Ju(u,L,0)*A(L)*Ju(v,L,1)*A(v));
	return z[0][0];
}
int main()
{
//	fr(transmit)
	scanf("%d%d%d",&n,&m,&K);int u,v;
	for(int i=1;i<=n;i++) scanf("%d",&w[i]);w[0]=1e9+7;
	for(int i=1;i<n;i++) scanf("%d%d",&u,&v),add(u,v);
	dfs(1,0);
	if(K>=2)
	{
		for(int i=1;i<=n;i++) b[i][0][0]=b[i][0][1]=A(i);
		for(int j=1;j<=20;j++) for(int i=1;i<=n;i++)
		b[i][j][0]=b[i][j-1][0]*b[fa[i][j-1]][j-1][0],b[i][j][1]=b[fa[i][j-1]][j-1][1]*b[i][j-1][1];	
	}
	while(m--) scanf("%d%d",&u,&v),printf("%lld\n",slo(u,v));
	return 0;
}
```

---


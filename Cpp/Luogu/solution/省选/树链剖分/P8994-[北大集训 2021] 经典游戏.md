# [北大集训 2021] 经典游戏

## 题目背景

CTT2021 D4T2

## 题目描述

某天，`C` 和 `K` 觉得很无聊，于是决定玩一个经典小游戏：

在一棵有 $n$ 个结点的有根树上，标号为 $i$ 的节点上有 $a_i$ 个棋子。游戏时玩家轮流操作，每次可以将任意一个节点 $u$ 上的一个棋子放置到任意一个点 $v \in U(u)$上，其中 $U(u)=subtree\{u\}\setminus\{u\}$ ，表示 $u$ 的子树内（不包含 $u$ 本身）的点组成的集合。不能进行操作者失败。

而 `C` 和 `K` 作为 `P**` 和 `T**` 的在读学生，这种一眼就能找出必胜策略的游戏实在是索然无味，于是两人觉得，每个人给自己一个特殊能力可能会比较有趣：

`C` 在开始游戏之前，**可以选择**将当前树的树根 $R$ 换到与 $R$ 相邻的任意一个点 $R^{\prime}$ 上。定义两个点相邻当且仅当这两个点有边直接相连。

`K` 在开始游戏之前，**必须选择**树上的一个节点，在上面加上一颗棋子。

`C` 和 `K` 决定玩 $m$ 局游戏。每局游戏的流程如下：

1. 游戏开始前，`C` 和 `K` 会商量好，先在标号为 $x$ 的节点上放上一个棋子，然后将树根设为 $y$。
2. 之后 `C` 可以选择是否发动特殊能力，`C` 决策完之后 `K` 可以选择是否发动特殊能力。
3. 特殊能力的决策结束后，会在这棵树上进行一局 `C` 先手、`K` 后手的游戏。游戏完成后会将树上棋子的状态**还原到流程 `1` 结束后的状态**。

`C` 觉得这个游戏可以出成一个简单题，于是他决定考考你：`C` 在每局游戏的第二步的时候，有多少种决策方式使得不管 `K` 如何进行特殊能力的操作，开始游戏时都存在**必胜策略**？两种决策方式不同，**当且仅当**两种决策**更换的树根** $R^{\prime}$ **不同**，或者**两者中仅有一个没有发动特殊能力**。


## 说明/提示

| 子任务分数 | $1\le n,m\le$ | $\max\{a_1,a_2,\dots,a_n\}\le$ |              特殊性质              |
| :--------: | :-----------: | :----------------------------: | :--------------------------------: |
|    $16$    |      $5$      |              $1$               |                 无                 |
|    $15$    |     $300$     |              $1$               |                 无                 |
|    $14$    |    $5000$     |             $10^9$             |                 无                 |
|    $13$    |   $100000$    |             $10^9$             |        保证给出的树是一条链        |
|    $12$    |   $100000$    |             $10^9$             | 保证给出的树存在一个点度数为 $n-1$ |
|    $11$    |   $100000$    |             $10^9$             |   保证 $m$ 次游戏初始给定根一致    |
|    $10$    |   $500000$    |             $10^9$             |                 无                 |
|    $9$     |   $1000000$   |             $10^9$             |                 无                 |




## 样例 #1

### 输入

```
0
5 2
1 2
1 3
2 4
2 5
1 0 1 0 1
2 2
4 4```

### 输出

```
2
1
```

## 样例 #2

### 输入

```
0
10 10
6 3
7 4
8 2
2 1
9 1
1 3
3 4
4 5
5 10
0 0 1 1 1 0 1 1 0 0 
8 3
2 3
7 10
7 3
6 7
8 5
9 8
2 10
5 4
3 9
```

### 输出

```
1
1
0
1
1
1
0
0
2
1
```

# 题解

## 作者：Licykoc (赞：6)

先考虑没有特殊能力的情况。容易发现点 $u$ 的 SG 值为 $u$ 到 $u$ 子树内的最大距离，设其为 $f_u$。那么整个游戏的 SG 值就是 $\bigoplus _u{[a_u \bmod 2=1]f_u}$，设其为 $S$。

进而得出，额外放置一枚棋子后先手仍然必胜的充要条件是 $\max\{f_u\} \lt S$。若不满足，则一定存在某个 $f_u = S$，那么只要在点 $u$ 放置一枚棋子 $S$ 就变成 $0$ 了，先手必败。

于是，原问题转化为：

> 给定一颗树，每个点有黑白两种颜色，$u$ 点权值 $f_u$ 为 $u$ 到 $u$ 子树内的最大距离，记 $S$ 为所有黑点权值异或和。每次操作给定 $x,y$，先翻转点 $x$ 的颜色，再询问有多少个点满足：与点 $y$ 相邻（包括点 $y$）且以该点为根时 $\max\{f_u\} \lt S$。

这里给出一种与其他两篇题解不同的维护方法。

基本思路是对每个点都维护以它为根时的 $\max\{f_u\}$ 和 $S$，记为 $mx_u$ 和 $S_u$。

首先一遍树形 dp 算出初始时的 $mx_u$ 和 $S_u$，实现时注意 $mx_u$ 事实上就等于 $u$ 到 $u$ 子树内的最大距离。

考虑修改，假设现在翻转点 $u$，设 $mx_u$ 经过 $(u,v)$ 这条边，切断 $(u,v)$（并不是真的切断，只是为了方便理解）。对于与 $u$ 连通的点 $x$，翻转点 $u$ 对 $S_x$ 的贡献就是异或上 $mx_u$。而对于与点 $v$ 连通的点 $y$，贡献则是异或上 $u$ 到与 $u$ 连通的点的最大距离。因为树的形态不变，所以这个可以在之前树形 dp 时预处理出来。将树以 dfs 序拍平，则上述操作可以归纳为区间异或，数据结构可以轻松维护。

再来看查询，假设查询点 $u$。先把 $u$ 点父亲和点 $u$ 暴力判掉，接下来考虑点 $u$ 的儿子。这相当于查询：

$$\sum_{v\in son_u}[mx_v \lt S_v]$$

$mx_v$ 显然始终不会变，但是 $S_v$ 是在动态改变的。所以我们的目标上将 $S_v$ 以某个不变量或者易于维护的量来替代掉。观察之前的修改操作，可以将 $S_v$ 改写为 $S'_v \oplus P_v$，其中 $S'_v$ 表示初始时的 $S_v$，$P_v$ 则表示 $S_v$ 应异或上的值。发现 $S'_v$ 始终不变。但是 $P_v$ 却会改变，似乎毫无进展？

并不是，若对原树进行长剖，那么在修改的时候点 $v$ 要么是点 $u$ 的长儿子要么是 $u$ 点父亲，只有 $O(1)$ 种可能！这意味这点 $u$ 除去长儿子那棵子树，其他子树内的点 $x$ 应异或的值都相同，也就是那些 $P_x$ 均等于 $x$ 父亲的 $P$ 值！同理，对于 $u$ 点父亲那部分，也同样遵循上述规则。

那么查询时先暴力判断点 $u$ 的长儿子，剩余部分的查询即为：

$$\sum_{v\in son_u \setminus \{hson_u\}}[mx_v \lt S'_v \oplus P_u]$$

因为剩余部分均为轻儿子，那么 $mx_v$ 都等于 $mx_u+1$，所以查询即为：

$$\sum_{v\in son_u \setminus \{hson_u\}}[mx_u+1 \lt S'_v \oplus P_u]$$

其中 $mx_u, S'_v$ 均为不变量，$P_u$ 仅跟 $u$ 点有关，使用 trie 树轻松维护。

这就做完了？并没有，上面的分析是有漏洞的，考虑这样一张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/2yzk5ycy.png)

红边为重边，当前修改点 $4$，那么会切断 $(4, 1)$ 这条边，根据上面的分析，$P_4$ 应等于 $P_1$，但实际上却并不相等（$P_4=4, P_1=1$）。但是这种错误只会发生在点 $4$ 这一个点上，所以我们将它暴力修改成正确的即可。

总时空复杂度：$O((n+q)\log n)$。

参考实现：

```cpp
#include <bits/stdc++.h>

constexpr int N = 2e7;

class trie {
private:
  int ch[2][N], tot = 0, siz[N];
  std::vector<int> root;

  void modify(int &u, int x, int dep, int v) {
    if (u == 0) {
      u = ++tot;
    }

    siz[u] += v;

    if (dep < 0) {
      return;
    }

    int p = x >> dep & 1;
    modify(ch[p][u], x, dep - 1, v);
  }

  int query(int u, int v, int x, int dep) {
    if (u == 0) {
      return 0;
    }

    if (dep < 0) {
      return siz[u];
    }

    int pv = v >> dep & 1, px = x >> dep & 1;
    return query(ch[px ^ pv][u], v, x, dep - 1) + (px == 0 ? siz[ch[pv ^ 1][u]] : 0);
  }

public:
  trie(int n) : root(n + 1) {}

  void insert(int i, int x) {
    modify(root[i], x, 30, 1);
  }

  void erase(int i, int x) {
    modify(root[i], x, 30, -1);
  }

  int query(int i, int v, int x) {
    return query(root[i], v, x, 30);
  }
};

template<typename T>
class fenwick {
private:
  int n;
  std::vector<T> tr;

public:
  fenwick() = default;
  fenwick(int N) : n(N + 5), tr(N + 6, 0) {}

  void add(int x, T y) {
    ++x;
    for (int i = x; i <= n; i += i & -i) {
      tr[i] ^= y;
    }
  }

  void add(int l, int r, int x) {
    if (l > r) {
      return;
    }

    add(l, x);
    add(r + 1, x);
  }
  
  T qry(int x) {
    ++x;
    T res = 0;
    for (int i = x; i > 0; i -= i & -i) {
      res ^= tr[i];
    }
    return res;
  }
};

signed main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);

  int n, m;
  std::cin >> n >> n >> m;

  std::vector<std::vector<int>> adj(n + 1);

  for (int i = 1; i < n; ++i) {
    int x, y;
    std::cin >> x >> y;
    adj[x].emplace_back(y);
    adj[y].emplace_back(x);
  }

  std::vector<int> a(n + 1);

  for (int i = 1; i <= n; ++i) {
    std::cin >> a[i];
    a[i] &= 1;
  }

  std::vector<int> max(n + 1), sec(n + 1), to(n + 1), hson(n + 1);
  std::vector<int> par(n + 1), dfn(n + 1), siz(n + 1);
  std::vector<int> S(n + 1);
  int timer = 0;

  auto dfs = [&](auto &self, int u, int fa) -> void {
    if (fa > 0) {
      adj[u].erase(std::find(adj[u].begin(), adj[u].end(), fa));
    }

    dfn[u] = ++timer;
    par[u] = fa;
    siz[u] = 1;

    for (auto v : adj[u]) {
      self(self, v, u);

      if (hson[u] == 0 || max[v] > max[hson[u]]) {
        hson[u] = v;
      }

      if (max[v] + 1 > max[u]) {
        sec[u] = max[u];
        max[u] = max[v] + 1;
      } else {
        sec[u] = std::max(sec[u], max[v] + 1);
      }

      siz[u] += siz[v];
    }

    to[u] = hson[u];

    if (a[u] > 0) {
      S[1] ^= max[u];
    }
  };
  dfs(dfs, 1, 0);

  auto dfs1 = [&](auto &self, int u) -> void {
    for (auto v : adj[u]) {
      int w = to[u] == v ? sec[u] : max[u];

      if (w + 1 > max[v]) {
        sec[v] = max[v];
        max[v] = w + 1;
        to[v] = u;
      } else {
        sec[v] = std::max(sec[v], w + 1);
      }

      w = S[u];
      w ^= a[u] > 0 && to[u] == v ? max[u] ^ sec[u] : 0;
      w ^= a[v] > 0 && to[v] == u ? sec[v] ^ max[v] : 0;
      S[v] = w;

      self(self, v);
    }
  };
  dfs1(dfs1, 1);

  trie T(n);
  fenwick<int> seg(n);
  auto pre = S;

  for (int u = 1; u <= n; ++u) {
    for (int v : adj[u]) {
      if (v != hson[u]) {
        T.insert(u, S[v]);
      }
    }
  }

  auto flip = [&](int u) {
    auto subtree_modify = [&](int u, int v, int w) {
      seg.add(dfn[u], dfn[u] + siz[u] - 1, v);
      seg.add(1, dfn[u] - 1, w);
      seg.add(dfn[u] + siz[u], n, w);
    };

    if (to[u] == par[u]) {
      if (hson[par[u]] != u) {
        T.erase(par[u], pre[u]);
        pre[u] ^= max[u] ^ sec[u];
        T.insert(par[u], pre[u]);
      }

      subtree_modify(u, max[u], sec[u]);
    } else {
      assert(to[u] == hson[u]);
      subtree_modify(to[u], sec[u], max[u]);
    }

    a[u] ^= 1;
  };

  auto query = [&](int u) {
    auto check = [&](int u) {
      if (u < 1) {
        return false;
      }

      return (S[u] ^ seg.qry(dfn[u])) > max[u];
    };

    int res = check(u) + check(hson[u]) + check(par[u]);
    return res + T.query(u, seg.qry(dfn[u]), max[u] + 2);
  };

  while (m--) {
    int x, y;
    std::cin >> x >> y;
    flip(x);
    std::cout << query(y) << '\n';
  }
}
```



---

## 作者：Alex_Wei (赞：2)

#### D4T2. [P8994 [北大集训 2021] 经典游戏](https://www.luogu.com.cn/problem/P8994)

考虑博弈，一个点的 SG 值为其子树内所有点的 SG 值的 MEX，易知等于子树最大深度。而放一个棋子使得先手必败的充要条件，就是所有棋子的 SG 值的异或和 $c_i$ 不大于子树最大深度 $d_i$。

考虑在节点 $x$ 加入棋子。设 $x$ 最大子树深度经过 $(x, z)$ 这条边，那么以 $x$ 为根 $z$ 的子树内所有点的 $c_i$ 要异或 $x$ 经过其它儿子的最大子树深度 $s_i$，而子树外所有节点的 $c_i$ 要异或 $d_x$。

以 $1$ 为根长链剖分，则 $z$ 只能是 $x$ 的重儿子或父亲。

如果只是单点查询，就太好维护了：用树状数组维护每个点被异或的值 $e_i$。但是查询范围是一个点半径为 $1$ 的邻域，那肯定要维护一个点的所有儿子的信息，批量查询。因为使得 $c_i\oplus x > d_i$ 的 $x$ 在 01 字典树上是 $\log n$ 棵子树，所以我们考虑对每个点维护它的所有轻儿子的这样的字典树，并保证轻儿子在字典树中的值异或其父亲的标记 $e_i$ 等于其真实值。这样，一次查询 $y$ 只需查它自己，其父亲和重儿子，以及它的标记 $e_y$ 在其字典树内的权值。

加入棋子，若 $z$ 是 $x$ 的重儿子，对所有点的字典树不会产生影响；若 $z$ 是 $x$ 的父亲，则当 $x$ 是 $z$ 的轻儿子时，$x$ 在其父亲字典树内的权值需要异或上 $d_i\oplus s_i$，因为 $e_z$ 异或 $s_i$ 而 $e_x$ 异或 $d_i$。删去原来的权值，再加入更新后的即可。

时空复杂度 $\mathcal{O}((n + q)\log n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int N = 1e6 + 5;
constexpr int K = N << 5;
int n, m, a[N], R[N], dt;
int dn, c[N], cc[N], dfn[N], sz[N], fa[N];
int f[N], sf[N], g[N], v[N], son[N];
vector<int> e[N];

struct BIT {
  int c[N];
  void add(int x, int v) {while(x <= n) c[x] ^= v, x += x & -x;}
  void add(int l, int r, int v) {add(l, v), add(r + 1, v);}
  int query(int x) {int s = dt; while(x) s ^= c[x], x -= x & -x; return s;}
} tr;

namespace Trie {
  int node, son[K][2], val[K];
  void modify(int bit, int &x, int c, int v, int s) {
    if(!x) x = ++node;
    if(!bit) return;
    int bc = c >> bit - 1 & 1, bv = v >> bit - 1 & 1;
    if(!bv) {
      if(!son[x][bc ^ 1]) son[x][bc ^ 1] = ++node;
      val[son[x][bc ^ 1]] += s;
      modify(bit - 1, son[x][bc], c, v, s);
    }
    else modify(bit - 1, son[x][bc ^ 1], c, v, s);
  }
  int query(int bit, int x, int v) {
    if(!x || !bit) return val[x];
    return val[x] + query(bit - 1, son[x][v >> bit - 1 & 1], v);
  }
}

void dfs1(int id, int ff) {
  dfn[id] = ++dn, sz[id] = 1, fa[id] = ff;
  for(int it : e[id]) {
    if(it == ff) continue;
    dfs1(it, id), sz[id] += sz[it], c[id] ^= c[it];
    if(a[it]) c[id] ^= f[it];
    int v = f[it] + 1;
    if(v > f[id]) sf[id] = f[id], f[id] = v, son[id] = it;
    else if(v > sf[id]) sf[id] = v;
  }
}
void dfs2(int id, int ff) {
  v[id] = max(f[id], g[id]);
  for(int it : e[id]) {
    if(it == ff) continue;
    if(it == son[id]) g[it] = max(g[id], sf[id]) + 1;
    else g[it] = max(g[id], f[id]) + 1;
    int dt = c[id] ^ c[it];
    if(a[it]) dt ^= f[it];
    if(a[id]) dt ^= g[it] - 1;
    c[it] ^= dt, dfs2(it, id);
    if(it != son[id]) Trie::modify(20, R[id], cc[it] = c[it], v[it], 1);
  }
  if(a[id]) c[id] ^= v[id];
}
int main() {
  #ifdef ALEX_WEI
    freopen("1.in", "r", stdin);
    freopen("1.out", "w", stdout);
  #endif
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  cin >> n >> n >> m;
  for(int i = 1; i < n; i++) {
    int u, v;
    cin >> u >> v;
    e[u].push_back(v), e[v].push_back(u);
  }
  for(int i = 1; i <= n; i++) cin >> a[i], a[i] &= 1;
  dfs1(1, 0), dfs2(1, 0);
  for(int i = 1; i <= m; i++) {
    int x, s;
    cin >> x, s = son[x];
    if(g[x] >= f[x]) {
      int l = dfn[x], r = dfn[x] + sz[x] - 1;
      dt ^= f[x], tr.add(l, r, f[x] ^ g[x]);
      if(son[fa[x]] != x) { // == -> !=
        Trie::modify(20, R[fa[x]], cc[x], v[x], -1);
        Trie::modify(20, R[fa[x]], cc[x] ^= f[x] ^ g[x], v[x], 1);
      }
    }
    else {
      int l = dfn[s], r = dfn[s] + sz[s] - 1;
      dt ^= f[x], tr.add(l, r, f[x] ^ max(sf[x], g[x])); // add " f[x] ^ "
    }
    cin >> x, s = son[x];
    int du = tr.query(dfn[x]);
    int ans = Trie::query(20, R[x], du);
    ans += (c[x] ^ du) > v[x];
    if(s) ans += (c[s] ^ tr.query(dfn[s])) > v[s];
    if(fa[x]) ans += (c[fa[x]] ^ tr.query(dfn[fa[x]])) > v[fa[x]]; // fa[x] -> dfn[fa[x]]
    cout << ans << "\n";
  }
  cerr << 1e3 * clock() / CLOCKS_PER_SEC << " ms\n";
  return 0;
}
```

---

## 作者：CarroT1212 (赞：1)

+ 关键词：博弈论，dfs 序，树状数组，01 Trie，树上差分。

可能是学 OI 以来遇到的成分最复杂的题。记一下。

感觉比[不远处的某个黑](https://www.luogu.com.cn/problem/P8990)难多了。

### 初步转化

考虑普通问题怎么做。可以转化为 Nim 游戏，也就是分成 $\sum a_i$ 堆石子，每堆石子对应一个棋子，石子个数是**棋子到最远的叶子结点的距离**，每次拿掉石子都是在向叶子结点靠近。那就设 $dis_{i,j}$ 为 $i$ 作根时 $j$ 到子树内最远叶子的距离。于是我们只关心 $a_i$ 的奇偶性了，也就是只剩 $0,1$。先手必胜仅当 $\bigoplus (a_i\bmod 2) dis_{root,i}\neq0$。

从这里开始就没博弈论什么事了。

### 修改

然而特殊能力和强制在线修改查询出现了！并且令 $a_i$ 为其模 $2$ 的值。

设点 $i$ 作根时，$nim_i=\bigoplus a_j\times dis_{i,j}$。假设此时 $R$ 作根，如果我们知道了目前的 $nim_R$，那么如果让后手不管把棋子放哪里都先手必胜，那就需要 $nim_R>dis_{R,R}$，也就是**后手放哪都无法把现在这个 $nim_R$ 给消成 $0$**。

这要求我们动态维护所有 $nim_i$。假设 $1$ 作根，发现放一个棋子的操作相当于是这样的：

+ 对于这个棋子所在点的**子树内**的 $R$，$nim_R$ 要异或上这个棋子到**子树外**最远叶子节点的距离。
+ 对于**子树外**的 $R$，$nim_R$ 要异或上棋子到**子树内**最远叶子的距离。

可以预处理好每个点的两条可能的链，通过 dfs 序转成区间问题，然后用树状数组维护区间异或单点查，解决了。有个 trick 就是树状数组更新的时候在外面带个全局异或，这样只用管中间子树区间里的异或值了，减小了一点码量和常数。

### 查询

然而还有一个很恶心的就是我们要统计 $R$ 以及它连接的所有点的答案。这咋搞啊？

恶心的其中一个原因是与 $R$ 相邻的 $R'$ 的 $dis_{R',R'}$ 不同，我们没法把连接的点的 $nim$ 信息对于同一个 $dis$ 打包算出来。但是想到一个问题：它们会差很多吗？稍微推一推就可以发现另一个重要性质：$dis_{R',R'}\in[dis_{R,R}-1,dis_{R,R}+1]$，也就是**每次询问覆盖的点最多只有三种** $dis$！枚举这三种 $dis$，对于 $dis$ 等于枚举值的相邻点，一起找出大于它的个数即可。这就相当于 $dis$ 是固定的，好搞很多啊。

然后考虑具体怎么处理。首先查询点它自己和它的父亲完全可以直接单独判断，所以现在只有儿子的问题了。显然直接求儿子的值是不可取的，得打包到父亲一起算，考虑怎么把**查询点和它的儿子的值之间的关系**描述出来。

又意识到这么一个问题：每次修改是将 $nim$ 值分成两段分别进行区间异或，而这么做有个特点，就是每一部分中的元素之间的**异或关系**（即一个 $nim$ 异或上什么数等于另一个 $nim$）**并没有变化**，只是修改的 $x$ 和它的父亲 $fa_x$ 之间出现了一点差别。

那我们就可以把这个差别记在父亲上，如果后面查询到了这个父亲，我们就直接把这些差分拿出来，通过**把记录下来的差分异或上父亲的 $nim$ 值直接得到它的儿子信息**，就不需要对每个儿子去求 $nim$ 值。这样得到的 $nim$ 再去统一判断大小会容易些。

具体的，可以在每个点开三棵 01 Trie 实现，三棵分别对应三种不同的 $dis$，每个 Trie 里面塞位于这个点上的差分信息，查询的时候看上面有多少个值异或上这个点的 $nim$ 之后能大于目前的 $dis$ 值，这是比较好搞的。

于是我们做完了。$O((n+q)\log n)$，卡的有点紧。

```cpp
int n,m,a[N];
int dfn[N],cnn,sz[N],fa[N];
int mx[N],cx[N],mp[N];
int rt[N][3],now[N];
vector<int> e[N];
struct bit {
	int c[N],all;
	void rox(int x,int y) { for (;x<=n;x+=x&-x) c[x]^=y; }
	void mdf(int l,int r,int x) { rox(l,x),rox(r+1,x); }
	int que(int x) { int ret=0; for (;x;x-=x&-x) ret^=c[x]; return ret^all; }
} bt;
struct tri {
	int t[N*23][2],c[N*21],cnn;
	void ins(int &p,int x,int d=20) {
		if (!p) p=++cnn;
		c[p]++;
		if (d<0) return;
		ins(t[p][x>>d&1],x,d-1);
	}
	void del(int &p,int x,int d=20) {
		if (!p) return;
		c[p]--;
		if (d<0) return;
		del(t[p][x>>d&1],x,d-1);
	}
	int que(int p,int x,int y,int d=20) {
		if (!p||d<0) return 0;
		if (y>>d&1) return que(t[p][x>>d&1^1],x,y,d-1);
		else return c[t[p][x>>d&1^1]]+que(t[p][x>>d&1],x,y,d-1);
	}
} tr;
void dfs1(int p,int f) {
	dfn[p]=++cnn,fa[p]=f,sz[p]=1;
	for (int i:e[p]) if (i!=f) {
		dfs1(i,p),sz[p]+=sz[i];
		if (mx[i]+1>mx[p]) cx[p]=mx[p],mx[p]=mx[i]+1,mp[p]=i;
		else if (mx[i]+1>cx[p]) cx[p]=mx[i]+1;
	}
}
void dfs2(int p,int f) {
	if (f) {
		if (mp[f]!=p) {
			if (mx[f]+1>mx[p]) cx[p]=mx[p],mx[p]=mx[f]+1,mp[p]=f;
			else if (mx[f]+1>cx[p]) cx[p]=mx[f]+1;
		}
		else {
			if (cx[f]+1>mx[p]) cx[p]=mx[p],mx[p]=cx[f]+1,mp[p]=f;
			else if (cx[f]+1>cx[p]) cx[p]=cx[f]+1;
		}
	}
	for (int i:e[p]) if (i!=f) dfs2(i,p),tr.ins(rt[p][mx[i]-mx[p]+1],0);
}
void chg(int p) {
	int tmp=mx[p]^cx[p];
	if (mp[p]!=fa[p]) bt.all^=mx[p],p=mp[p];
	else bt.all^=cx[p];
	bt.mdf(dfn[p],dfn[p]+sz[p]-1,tmp);
	if (fa[p]) {
		tr.del(rt[fa[p]][mx[p]-mx[fa[p]]+1],now[p]);
		now[p]^=tmp;
		tr.ins(rt[fa[p]][mx[p]-mx[fa[p]]+1],now[p]);
	}
}
void mian() {
	scanf("%d%d",&n,&m);
	for (int i=1,x,y;i<n;i++) scanf("%d%d",&x,&y),e[x].pb(y),e[y].pb(x);
	dfs1(1,0),dfs2(1,0);
	for (int i=1;i<=n;i++) {
		scanf("%d",&a[i]),a[i]&=1;
		if (a[i]) chg(i);
	}
	for (int i=1,x,y,res,z;i<=m;i++) {
		scanf("%d%d",&x,&y),chg(x);
		z=bt.que(dfn[y]);
		res=z>mx[y];
		if (fa[y]) res+=bt.que(dfn[fa[y]])>mx[fa[y]];
		for (int j=-1;j<=1;j++) res+=tr.que(rt[y][j+1],z,mx[y]+j);
		cout<<res<<"\n";
	}
}
```

---

## 作者：lzqy_ (赞：1)

这道题对于不会长剖的人来说是比较困难的。

比如我。

分享一下不用长剖的思考过程，不过代码写出来是差不多的。

-------

首先肯定是去掉博弈论的壳子。

在节点 $x$ 上的棋子可以看作大小为 $(md_x-dep_x)$ 的石堆，其中 $md_x$ 是以 $x$ 为根的子树中的最大深度。这样转化可行的原因是在 $x$ 位置上的棋子可以移动到子树内的任意深度，即 $(dep_x,md_x]$。

那么显然每个位置的棋子数 $\in [0,1]$。如果只是单纯进行这个博弈，那么异或和不为 $0$ 先手就赢了。

考虑到后手在第一轮可以加入一枚棋子。假设异或和为 $k$，树根为 $rt$，若加入一枚棋子后先手仍然必胜，那么意味着无法加入权值为 $k$ 的棋子，即 $md_{rt} >k$。

因此题目转化为：

> 给出一棵树，点有黑白两色，点的权值是其深度与子树内最大深度的差。每组询问给出 $(x,y)$，翻转 $x$ 的颜色，再询问有多少个根 $rt$ 满足黑点异或和 $> md_{rt}$ 且 $dis(x,y) \le 1$。

至此，该题转化为纯粹的树上问题。

----------

容易这个树上问题是个二合一，第一部分是钦定根之后如何求异或和，第二部分是怎么求出 $dis(x,y) \le 1$ 的所有合法根。

先来看第一部分。

对于每个点来说，我们只关心它和子树内最深点的**相对深度**，因此，只要父节点不变，节点的权值是不会改变的。

基于这个观察，当根从基准根 $1$ 移动到 $x$ 的时候，只有 $\{1 \to x\}$ 上点的权值会改变。所以考虑实时维护以 $1$ 为根的异或和，然后异或掉以 $1$ 为根时 $\{1 \to x\}$ 的异或和，再异或上以 $x$ 为根时 $\{1 \to x\}$ 上的异或和就行了。 

上述这些信息都可以换根dp求出来，关键点在于怎么支持翻转单点颜色。

设 $f_x$  为 $\{1 \to x\}$ 的异或和，那么翻转 $x$ 的只会影响 $f_y,y \in subtree(x)$。考虑对子树内的具体影响。



设以 $x$ 为一个端点的最长链长度为 $v_x$（即以 $x$ 为根时，点 $x$ 的权值）。那么当根从 $x$ 移到和它相邻的节点 $y$ 的时候，若子树 $y$ 贡献了 $v_x$ **且是唯一贡献**（即去掉子树 $y$，$v_x$ 就会改变），那么 $x,y$ 的权值都会改变。这个改变没什么规律，不过观察到满足条件的 $y$ 只有一个，所以可以特殊处理。

对于其余相邻的节点 $y'$，根移动到 $y'$ 后 $x$ 的权值不会发生改变，而 $y'$ 的权值会变为 $(v_x+1)$。

因此开两个 BIT 维护以 $1,x$  为根时 $\{1 \to x\}$ 的异或和，进行区间异或，单点查询即可。

这一部分时间复杂度 $O(n\log n)$。

---------

接着看第二部分。

首先先把当前点和父节点判掉。

类似地，如果当前点 $x$ 存在一个子节点 $y$ 是 $v_x$ 的**唯一贡献**，那么这个节点的变化也是没规律的，也判掉。

那么对于其它的子节点 $y'$，如上述所说，唯一的改变就是 $y'$ 的权值变成 $(v_x+1)$。因此，换根对整体异或和的影响就是 $md_{y'}\oplus (v_x+1)$。把这些东西放进 Trie 树里，然后在 Trie 树上二分即可。

这一部分的时间复杂度也是 $O(n\log n)$。

-----------

## 代码

所以整个算法的流程就是开两个 BIT 维护全局异或和，然后在对应节点的 Trie 上二分求合法点数量。

总时间复杂度 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
#define il inline
using namespace std;
const int maxn=1000010;
il int read(){
	int x=0;
	char c=getchar();
	for(;!(c>='0'&&c<='9');c=getchar());
	for(;c>='0'&&c<='9';c=getchar())
		x=(x<<1)+(x<<3)+c-'0';
	return x;
}
struct edge{
	int v,w,to;
}e[maxn<<1];
int head[maxn],ecnt;
void addedge(int u,int v){
	e[++ecnt].v=v,e[ecnt].to=head[u],head[u]=ecnt;
}
int n,m,idx,f[maxn];
int a[maxn],v1[maxn],v2[maxn],vf[maxn];
int pre1[maxn],pre2[maxn];
int dfn[maxn],dep[maxn];
int sz[maxn],DFN[maxn];
int md[maxn][2],id[maxn][2];
int ch[maxn][2],tag[maxn*40];
int trie[maxn*40][2],zson[maxn];
int cnt,rt[maxn];
bool In(int x,int y){return dfn[y]<=dfn[x]&&dfn[y]+sz[y]-1>=dfn[x];}
void dfs1(int fa,int x){
	sz[x]=1,id[x][0]=x;
	dfn[x]=++idx,DFN[idx]=x;
	dep[x]=dep[fa]+1,f[x]=fa;
	for(int i=head[x];i;i=e[i].to)
		if(e[i].v!=fa){
			dfs1(x,e[i].v),sz[x]+=sz[e[i].v];
			if(md[e[i].v][0]+1>md[x][0]){
				md[x][1]=md[x][0],id[x][1]=id[x][0];
				md[x][0]=md[e[i].v][0]+1,id[x][0]=id[e[i].v][0];
			}
			else if(md[e[i].v][0]+1>md[x][1])
				md[x][1]=md[e[i].v][0]+1,id[x][1]=id[e[i].v][0];
		}
	for(int i=head[x];i;i=e[i].to)
		if(e[i].v!=fa){
			if(In(id[x][0],e[i].v)) e[i].w=md[x][1];
			else e[i].w=md[x][0];
		}
	v1[x]=md[x][0];
}

void dfs2(int fa,int x,int lw=0){
	if(x!=1){
		if(a[fa]) pre2[x]=pre2[fa]^v2[fa]^max(e[lw].w,vf[fa]);
		else pre2[x]=pre2[fa];
		vf[x]=max(e[lw].w,vf[fa])+1;
		v2[x]=max(v1[x],vf[x]);
	}pre1[x]=pre1[fa];
	if(a[x]) pre1[x]^=v1[x],pre2[x]^=v2[x];
	for(int i=head[x];i;i=e[i].to)
		if(e[i].v!=fa)
			dfs2(x,e[i].v,i);
	for(int i=head[x];i;i=e[i].to)
		if(e[i].v!=fa)
			ch[e[i].v][1]=v1[e[i].v]^v2[e[i].v];
}
int Tree1[maxn],Tree2[maxn];
void A1(int l,int r,int x){
	if(l>r) return ;
	for(;l<=n;l+=l&-l) Tree1[l]^=x;
	for(r++;r<=n;r+=r&-r) Tree1[r]^=x;
}
void A2(int l,int r,int x){
	if(l>r) return ;
	for(;l<=n;l+=l&-l) Tree2[l]^=x;
	for(r++;r<=n;r+=r&-r) Tree2[r]^=x;
}
int Q1(int k,int sum=0){
	for(;k;k-=k&-k) sum^=Tree1[k];
	return sum;
}
int Q2(int k,int sum=0){
	for(;k;k-=k&-k) sum^=Tree2[k];
	return sum;
}
void Insert(int t,int c,int k){
	if(!rt[t]) rt[t]=++cnt;
	int x=rt[t];tag[x]+=k;
	for(int i=20;~i;i--){
		if(!trie[x][bool(c&(1<<i))])
			trie[x][bool(c&(1<<i))]=++cnt;
		x=trie[x][bool(c&(1<<i))],tag[x]+=k;
	}
}
int Query(int t,int s1,int s2){
	int sum=0,x=rt[t];
	for(int i=20;~i&&x;i--){
		if((s2&(1<<i))&&!(s1&(1<<i))) x=trie[x][1];
		else if((s2&(1<<i))&&(s1&(1<<i))) x=trie[x][0];
		else if(!(s2&(1<<i))&&!(s1&(1<<i))) sum+=tag[trie[x][1]],x=trie[x][0];
		else sum+=tag[trie[x][0]],x=trie[x][1];
	}return sum;
}
int main(){
//	freopen("Ex.in","r",stdin);
//	freopen("Ex.out","w",stdout);
	read();
	n=read(),m=read();
	for(int i=1;i<n;i++){
		int x=read(),y=read();
		addedge(x,y),addedge(y,x);
	}
	for(int i=1;i<=n;i++) a[i]=read()&1;
	dfs1(0,1),v2[1]=v1[1];
	dfs2(0,1);
//	for(int i=1;i<=n;i++)
//		printf("%d ",md[i][0]);
//	printf("\n"); 
	int tot_XOR=0,ans=0;
	for(int i=1;i<=n;i++)
		if(a[i]) tot_XOR^=v1[i];
	for(int i=1;i<=n;i++){
		//printf("%d ",ch[i][1]);
		A1(dfn[i],dfn[i],pre2[i]);
		A2(dfn[i],dfn[i],pre1[i]);
	}
	for(int i=1;i<=n;i++)
		for(int j=head[i];j;j=e[j].to)
			if(e[j].v!=f[i]) if(md[i][0]!=md[i][1]&&v2[i]!=vf[i]&&In(id[i][0],e[j].v))
				zson[i]=e[j].v;
//	for(int i=1;i<=n;i++)
//		printf("%d ",md[i][0]);
//	printf("\n"); 
	for(int i=1;i<=n;i++)
		for(int j=head[i];j;j=e[j].to)
			if(e[j].v!=f[i]&&e[j].v!=zson[i]) 
				Insert(i,ch[e[j].v][a[e[j].v]],1);
	//printf("\n");
	//printf("num : %d\n",Q1(dfn[2]));
	while(m--){
		int x=read(),y=read();
		if(f[x]&&zson[f[x]]!=x){
			Insert(f[x],ch[x][a[x]],-1);
			Insert(f[x],ch[x][!a[x]],1);
		}a[x]^=1;
		A2(dfn[x],dfn[x]+sz[x]-1,v1[x]);
		tot_XOR^=v1[x],ans=0;
		if(!zson[x]) A1(dfn[x],dfn[x]+sz[x]-1,v2[x]);
		else{
//			puts("in");
//			printf("%d(%d)\n",max(vf[x],md[x][1]),zson[x]);
			
			A1(dfn[zson[x]],dfn[zson[x]]+sz[zson[x]]-1,max(vf[x],md[x][1]));
			A1(dfn[zson[x]]+sz[zson[x]],dfn[x]+sz[x]-1,v2[x]);
			A1(dfn[x],dfn[zson[x]]-1,v2[x]);
		}
	//	printf("\n\n%d,%d,%d\n\n",Q2(dfn[y]),tot_XOR,Q1(dfn[y]));
		int XOR=Q2(dfn[y])^tot_XOR^Q1(dfn[y]);
		x=y;
//		printf("(%d)\n",XOR);
	//	printf("!!!%d,%d\n",v2[x],XOR);
		if(XOR>v2[x]) ans++;
		if(f[x]&&(Q2(dfn[f[x]])^tot_XOR^Q1(dfn[f[x]]))>v2[f[x]]) ans++;
		if(zson[x]&&(Q2(dfn[zson[x]])^tot_XOR^Q1(dfn[zson[x]]))>v2[zson[x]]) ans++;
		//printf("!!!%d\n",ans);
		ans+=Query(x,XOR,v2[x]+1);
	//	for(int i=1;i<=n;i++)
	//		printf("%d ",a[i]);
	//	printf("\n");
		printf("%d\n",ans);
	}
	return 0;
}
```

---

## 作者：伊地知虹夏 (赞：0)

学 OI 以来遇到的最杂的题。

## 博弈部分

我们先不考虑特殊操作，钦定根为 $1$ 来探索。

考虑每个棋子的移动相对独立，并且这个游戏为一个 ICG，我们想到 DAG 游戏中的 SG 定理。

接下来考虑每个点的 SG 值如何计算，给出结论：$\mathcal{SG}(x) = d_x$，其中 $d_x$ 为 $x$ 到 $x$ 子树内的最长链长度，证明平凡。

由 SG 定理，这个游戏的 SG 值为：

$$S = \bigoplus_{i=1}^{n} \bigoplus_{j=1}^{a_i} d_i = \bigoplus_{i=1}^{n} [a_i \bmod 2 = 1]d_i$$

现在加入 `K` 的操作，`K` 要让 $S$ 变为 $0$，它一定会选择 $d_x = S$ 的点 $x$ 加上 $1$，那么 $S$ 就会变成 $0$，达到先手必败。

那么我们得出结论：`K` 可以胜利 $\iff \max_i d_i \ge S$。

发现换根操作可以视作一个半径为 $1$ 的邻域询问，那么就转化为了一个数据结构题。

## DS 部分

结束博弈后，问题转化为：

> 每个点有黑白两色 $c_i$，支持单点反转颜色，每次查询 $r \in \{N(y) \cup y\}$ 中 $\bigoplus_{i=1}^{n} [c_i = 1] d_r(i) < \max_{i=1}^{n}d_r(i)$ 的点个数。

我们要维护每个节点为根时的 SG 异或和 $S_r$ 和子树内最长链。后者可以两遍 dfs 做到，我们先考虑前者。

我们发现，反转点 $x$ 的颜色相当于将 $x$ 子树内异或上子树外最长链，子树外刚好相反。这相当于区间异或，单点查询，直接 bit 即可。有个小细节是可以维护全局异或标记，只要修改子树就行了，可以减少 $2$ 倍常数。

但是邻域信息并不好维护，观察到 $v \in N(u), d_v \in [d_u-1,d_u+1]$，我们可以把这三种 $d$ 塞入父节点的三个数据结构 $D$ 中。

这里面的异或和会随时变化，而我们没法做到对每次修改都重新加入 $D$ 中。但是修改有一个性质：$x$ 和 $x$ 的父亲的差别只在于 $x$ 异或上了子树外最长链而父亲相反。所以我们只需要在 $x$ 父亲上的 $D$ 中将 $x$ 的权值异或上这个数，查询时再异或父亲的 SG 值 $S$ 即可。

考虑 $D$ 要支持的操作：

1. 单点修改
2. 查询有多少 $v$ 满足 $v \oplus x > y$。

这个很显然是一个 01 Trie，到这里就做完了，时间复杂度 $\mathcal{O}((n + q) \log n)$。

实现细节参考 [代码](https://www.luogu.com.cn/paste/5mtgsrsu)。

---

## 作者：tribool4_in (赞：0)

首先考虑一开始的游戏，容易发现若定义 $f_u$ 表示 $u$ 子树内的最大高度（就是 SG 函数），则局面 SG 值为 $S=\bigoplus_i[a_i\bmod 2=1]f_i$。因此如果考虑后手增加棋子的操作，即相当于 $\max_i f_i<S$ 则先手胜（因为此时无法异或上一个 $f_i$ 来使得 $S'=0$）。

发现 $S$ 会随根的变化而变化，首先容易换根 dp 预处理出对于所有 $u$ **以其为根**时初始的 $S_u$。以 $u$ 为根的 $\max_i f_i$ 其实就是从 $u$ 出发的最远长度，记为 $mx_u$。

此时考虑将一个位置 $u$ 取反，对所有 $S_u$ 的影响。取出从 $u$ 出发最长路径上（就是 $mx_u$ 对应路径）对应的邻点 $v$，并假设删除边 $(u,v)$。此时对于 $u$ 所在连通块内的 $S$ 异或上 $mx_u$（即以其为根时 $u$ 的最长距离），而对于 $v$ 所在连通块内的 $S$ 异或上 $u$ 在其连通块内的最长距离（就是次长距离 $se_u$）。拍到 dfn 序上就是 $O(1)$ 次区间修改，需要单点查询 $S_u$，容易维护。此时 $u$ 为根时先手胜的条件为 $mx_u<S_u$。

考虑如何求 $u$ 所有邻点的答案之和。首先对于 $u$ 和 $fa_u$ 单独计算，问题变为求 $\displaystyle\sum_{v\in son(u)}[mx_v<S_v]$。考虑长链剖分（其实就是求 $f$ 时做的事），注意到在一次操作中，一个轻儿子异或上的值与其父亲**几乎**一致（有一种特殊情况在下段）。因此将 $S_u$ 拆成初值 $S'_u$ 和异或值 $F_u$，即 $S_u=S'_u\oplus F_u$，对于 $u$ 为轻儿子时应当有 $F_u=F_{fa_u}$。此时原式变为 $\displaystyle\sum_{v\in son(u)}[mx_v<S'_v\oplus F_u]=\sum_{v\in son(u)}[(mx_u+1)<S'_v\oplus F_u]$ 其中 $S'_v$ 为定值。对于每个点，对其所有轻儿子开一棵 01Trie 即可维护。

不过上面说的是“几乎”一致，当修改 $u$ 时，**若 $u$ 是其父亲的轻儿子，且 $u$ 的最长路径的邻点为其父亲**，$F_u\neq F_{fa_u}$。不过只有这一个点有问题，只需要在 $fa_u$ 的 01Trie 上修改一下即可（相当于直接修改其初始值 $S'_u$）。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 10;
int n, m;
bool a[N];
vector<int> G[N];
namespace Trie {
    const int N = 3e7 + 10;
    int ch[N][2], siz[N], tot, root[N];
    void _modify(int &p, int x, int v) {
        if (!p) p = ++tot;
        siz[p] += v;
        int u = p;
        for (int i = 30; i >= 0; i--) {
            bool c = x >> i & 1;
            if (!ch[u][c]) ch[u][c] = ++tot;
            u = ch[u][c], siz[u] += v;
        }
    }
    int _query(int p, int dep, int x, int y) {
        if (!p) return 0;
        if (dep < 0) return siz[p];
        bool bx = x >> dep & 1, by = y >> dep & 1;
        if (bx == 0) return (by == 0 ? _query(ch[p][0], dep - 1, x, y) + siz[ch[p][1]] : _query(ch[p][1], dep - 1, x, y));
        else return (by == 0 ? _query(ch[p][1], dep - 1, x, y) + siz[ch[p][0]] : _query(ch[p][0], dep - 1, x, y));
    }
    void insert(int id, int v) { _modify(root[id], v, 1); }
    void erase(int id, int v) { _modify(root[id], v, -1); }
    // y <= (x ^ val)
    int query(int id, int x, int y) { return _query(root[id], 30, x, y); }
}  // namespace Trie
namespace SegTree {
    int val[N << 2];
    int _query(int p, int l, int r, int x, int y) {
        if (x <= l && r <= y) return val[p];
        int mid = (l + r) >> 1, res = 0;
        if (x <= mid) res ^= _query(p << 1, l, mid, x, y);
        if (mid < y) res ^= _query(p << 1 | 1, mid + 1, r, x, y);
        return res;
    }
    void _modify(int p, int l, int r, int x, int v) {
        if (l == r) return val[p] ^= v, void();
        int mid = (l + r) >> 1;
        if (x <= mid) _modify(p << 1, l, mid, x, v);
        else _modify(p << 1 | 1, mid + 1, r, x, v);
        val[p] = val[p << 1] ^ val[p << 1 | 1];
    }
    void modify(int l, int r, int v) {
        if (l > r) return;
        _modify(1, 1, n, l, v);
        if (r < n) _modify(1, 1, n, r + 1, v);
    }
    int query(int x) { return _query(1, 1, n, 1, x); }
}  // namespace SegTree
int fa[N], mx[N], se[N], hson[N], siz[N], dfn[N], to[N], S[N], T[N];
void dfs0(int u, int _f) {
    static int _d = 0;
    dfn[u] = ++_d, fa[u] = _f, siz[u] = 1;
    for (auto v : G[u]) {
        if (v == _f) continue;
        dfs0(v, u);
        siz[u] += siz[v];
        if (hson[u] == 0 || mx[hson[u]] < mx[v]) hson[u] = v;
        if (mx[u] < mx[v] + 1) se[u] = mx[u], mx[u] = mx[v] + 1;
        else se[u] = max(se[u], mx[v] + 1);
    }
    to[u] = hson[u];
    if (a[u]) S[1] ^= mx[u];
}
void dfs1(int u) {
    for (auto v : G[u]) {
        if (v == fa[u]) continue;
        int w = (v == to[u] ? se[u] : mx[u]);
        if (mx[v] < w + 1) se[v] = mx[v], mx[v] = w + 1, to[v] = u;
        else se[v] = max(se[v], w + 1);
        S[v] = S[u];
        S[v] ^= ((a[u] && to[u] == v) ? mx[u] ^ se[u] : 0);
        S[v] ^= ((a[v] && to[v] == u) ? mx[v] ^ se[v] : 0);
        dfs1(v);
    }
}
void updst(int u, int vi, int vo) {
    SegTree::modify(dfn[u], dfn[u] + siz[u] - 1, vi);
    SegTree::modify(1, dfn[u] - 1, vo), SegTree::modify(dfn[u] + siz[u], n, vo);
}
void upd(int u) {
    if (to[u] == fa[u]) {
        if (hson[fa[u]] != u) {
            Trie::erase(fa[u], T[u]);
            T[u] ^= mx[u] ^ se[u];
            Trie::insert(fa[u], T[u]);
        }
        updst(u, mx[u], se[u]);
    } else {
        updst(to[u], se[u], mx[u]);
    }
}
bool check(int u) { return u ? mx[u] < (S[u] ^ SegTree::query(dfn[u])) : 0; }
int qry(int u) { return Trie::query(u, SegTree::query(dfn[u]), mx[u] + 2) + check(u) + check(fa[u]) + check(hson[u]); }
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    int cid;
    cin >> cid >> n >> m;
    for (int i = 1, u, v; i < n; i++) {
        cin >> u >> v;
        G[u].push_back(v), G[v].push_back(u);
    }
    for (int i = 1, x; i <= n; i++) cin >> x, a[i] = x & 1;
    dfs0(1, 0), dfs1(1);
    for (int u = 1; u <= n; u++) {
        T[u] = S[u];
        // cerr << S[u] << " \n"[u == n];
        for (auto v : G[u]) {
            if (v == fa[u] || v == hson[u]) continue;
            Trie::insert(u, S[v]);
        }
    }
    for (int i = 1, x, y; i <= m; i++) {
        cin >> x >> y;
        upd(x);
        cout << qry(y) << '\n';
    }
    return 0;
}
```

---

## 作者：Leasier (赞：0)

首先不难发现确定根时，$SG_r(u)$ 为以 $r$ 为根时 $u$ 子树内最大深度（这里深度不包括 $u$ 自己）。

于是我们就不难写出一个 $O(n(n + m))$ 暴力了：换根预处理 SG 函数，修改时维护以每个点为根的 SG 值 $f_u$，查询时求 $f_u > SG_u(u)$ 的 $u$ 个数即可。

不妨来思考一下哪些东西束缚了我们的时间复杂度：

- 换根。
- 临域计数。

不妨一开始钦定 $1$ 为根，则以 $u$ 为根的 SG 值包括：

- $f_1$。
- 修改 $f_1, f_u$ 不同的部分，这部分包括 $1 \to u$ 路径上的所有点，即 $\operatorname{xor}_{\text{v 在 1 到 u 的路径上且 v 出现奇数次}} (f_u(v) \operatorname{xor} f_1(v))$。

考虑把两部分分开维护。

- $f_1(v)$ 的贡献在翻转一个点的状态时进行一个子树异或即可。
- 换根 dp 求出外子树的情况，$f_u(v)$ 的贡献在翻转一个点 $u$ 的状态时还需要讨论一下那个**唯一**的 SG 值最大的子树（可能不存在），其他部分的贡献只会来自 $u$ 的外子树和 SG 值最大的子树。**这里不维护 $u$ 自己的情况，因为它作为根的情况我们需要最后单独处理。**

在以上的基础上，如果查询依然直接暴力，我们只需要进行两次单点查询。于是我们开两棵树状数组维护区间异或、单点查询即可。

现在我们来考虑邻域计数的问题。首先暴力判掉 $u, fa_u$ 的查询。

剩下的儿子看上去是不便于直接维护的，由于它们跟 $u$ 有着不小的关系，不妨尝试在 $f_u$ 的基础上增删一些项得到一个儿子 $v$ 的 $f_v$：

- 如果 $u$ 被计入贡献，删掉 $SG_u(u)$ 并加入 $SG_v(u)$。
- 如果 $v$ 被计入贡献，删掉 $SG_1(v)$ 并加入 $SG_v(v)$。
- 如果 $u$ 被计入贡献，加入 $SG_v(u)$。

于是 $f_v = f_u \operatorname{xor} [\text{u 出现奇数次}](SG_v(u) \operatorname{xor} SG_u(u)) \operatorname{xor} [\text{v 出现奇数次}](SG_v(v) \operatorname{xor} SG_1(v))$。

现在我们要判断 $f_v > SG_v(v)$ 是否成立，但两边都有 $SG_v(v)$，左边还有一个 $SG_v(u)$，看上去不是很好搞。

注意到如果 $v$ 不是那个**唯一**的 SG 值最大的儿子，则 $SG_v(v), SG_v(u)$ 恒定，则我们把那个儿子单独抓出来讨论，把剩下儿子的 $[\text{v 出现奇数次}](SG_v(v) \operatorname{xor} SG_1(v))$ 放进一棵 01-Trie 维护、查询时在上面一边走一边统计贡献即可。时间复杂度为 $O((n + m) \log n)$。

代码：
```cpp
#include <stdio.h>

typedef struct {
	int nxt;
	int end;
} Edge;

inline int lowbit(int x){
	return x & (-x);
}

typedef struct {
	int tree[1000007];
	
	inline void do_xor(int n, int x, int k){
		while (x <= n){
			tree[x] ^= k;
			x += lowbit(x);
		}
	}
	
	inline void do_xor(int n, int l, int r, int k){
		do_xor(n, l, k);
		do_xor(n, r + 1, k);
	}
	
	inline int get_xor(int x){
		int ans = 0;
		while (x > 0){
			ans ^= tree[x];
			x -= lowbit(x);
		}
		return ans;
	}
} BIT;

typedef struct {
	int cnt;
	int son[7];
} Node;

int cnt = 0, trie_id = 0, global_sg = 0;
BIT bit1, bit2;
int head[1000007], a[1000007], in[1000007], fa[1000007], sg1[1000007], max_pos[1000007], cmax_pos[1000007], hs[1000007], out[1000007], root_sg[1000007], sg2[1000007], root[1000007];
bool vis[1000007];
Edge edge[2000007];
Node tree[21000007];

inline int read(){
	int ans = 0;
	char ch = getchar();
	while (ch < '0' || ch > '9'){
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9'){
		ans = ans * 10 + (ch ^ 48);
		ch = getchar();
	}
	return ans;
}

inline void add_edge(int start, int end){
	cnt++;
	edge[cnt].nxt = head[start];
	head[start] = cnt;
	edge[cnt].end = end;
}

inline int max(int a, int b){
	return a > b ? a : b;
}

void dfs1(int u, int father, int &id){
	in[u] = ++id;
	fa[u] = father;
	for (register int i = head[u]; i != 0; i = edge[i].nxt){
		int x = edge[i].end;
		if (x != father){
			dfs1(x, u, id);
			sg1[u] = max(sg1[u], sg1[x] + 1);
			if (max_pos[u] == 0 || sg1[max_pos[u]] < sg1[x]){
				cmax_pos[u] = max_pos[u];
				max_pos[u] = x;
			} else if (cmax_pos[u] == 0 || sg1[cmax_pos[u]] < sg1[x]){
				cmax_pos[u] = x;
			}
			if (hs[u] == 0 || sg1[hs[u]] < sg1[x]){
				hs[u] = x;
			} else if (sg1[hs[u]] == sg1[x]){
				hs[u] = 0;
			}
		}
	}
	out[u] = id;
}

void dfs2(int u){
	root_sg[u] = max(sg1[u], sg2[u]);
	for (register int i = head[u]; i != 0; i = edge[i].nxt){
		int x = edge[i].end;
		if (x != fa[u]){
			if (max_pos[u] == x){
				if (cmax_pos[u] == 0){
					sg2[x] = sg2[u] + 1;
				} else {
					sg2[x] = max(sg2[u], sg1[cmax_pos[u]] + 1) + 1;
				}
			} else {
				sg2[x] = max(sg2[u], sg1[u]) + 1;
			}
			dfs2(x);
		}
	}
}

inline void add(int &root, int x, int k){
	int cur;
	if (root == 0) root = ++trie_id;
	cur = root;
	for (register int i = 19; i >= 0; i--){
		int ch = x >> i & 1;
		tree[cur].cnt += k;
		if (tree[cur].son[ch] == 0) tree[cur].son[ch] = ++trie_id;
		cur = tree[cur].son[ch];
	}
	tree[cur].cnt += k;
}

inline void flip(int x, int n){
	if (fa[x] != 0 && x != hs[fa[x]]){
		if (!vis[x]){
			add(root[fa[x]], 0, -1);
			add(root[fa[x]], sg1[x] ^ root_sg[x], 1);
		} else {
			add(root[fa[x]], sg1[x] ^ root_sg[x], -1);
			add(root[fa[x]], 0, 1);
		}
	}
	vis[x] = !vis[x];
	global_sg ^= sg1[x];
	bit1.do_xor(n, in[x], out[x], sg1[x]);
	bit2.do_xor(n, in[x] + 1, out[x], root_sg[x]);
	if (hs[x] != 0){
		if (cmax_pos[x] == 0){
			bit2.do_xor(n, in[hs[x]], out[hs[x]], sg2[x] ^ root_sg[x]);
		} else {
			bit2.do_xor(n, in[hs[x]], out[hs[x]], max(sg2[x], sg1[cmax_pos[x]] + 1) ^ root_sg[x]);
		}
	}
}

inline int do_query(int x){
	return global_sg ^ bit1.get_xor(in[x]) ^ bit2.get_xor(in[x]) ^ (vis[x] ? root_sg[x] : 0);
}

inline int get_cnt(int root, int x, int y){
	int cur = root, ans = 0;
	for (register int i = 19; i >= 0 && cur != 0; i--){
		int ch2 = y >> i & 1, ch1 = x >> i & 1;
		if (ch2 == 0) ans += tree[tree[cur].son[ch1 ^ 1]].cnt;
		cur = tree[cur].son[ch1 ^ ch2];
	}
	return ans;
}

inline int query(int x){
	int qx = do_query(x), ans = 0;
	if (qx > root_sg[x]) ans++;
	if (fa[x] != 0 && do_query(fa[x]) > root_sg[fa[x]]) ans++;
	if (hs[x] != 0 && do_query(hs[x]) > root_sg[hs[x]]) ans++;
	if (cmax_pos[x] != 0) ans += get_cnt(root[x], qx, root_sg[cmax_pos[x]]);
	return ans;
}

void write(int n){
	if (n >= 10) write(n / 10);
	putchar(n % 10 + '0');
}

int main(){
	int id = read(), n = read(), m = read(), dfn_id = 0;
	for (register int i = 1; i < n; i++){
		int u = read(), v = read();
		add_edge(u, v);
		add_edge(v, u);
	}
	for (register int i = 1; i <= n; i++){
		a[i] = read();
	}
	dfs1(1, 0, dfn_id);
	dfs2(1);
	for (register int i = 1; i <= n; i++){
		if (fa[i] != 0 && i != hs[fa[i]]) add(root[fa[i]], 0, 1);
	}
	for (register int i = 1; i <= n; i++){
		if (a[i] % 2 == 1) flip(i, dfn_id);
	}
	for (register int i = 1; i <= m; i++){
		int x = read(), y = read();
		flip(x, dfn_id);
		write(query(y));
		putchar('\n');
	}
	return 0;
}
```

---

## 作者：Eznibuil (赞：0)

~~考试时只会 $\sout{81}$ 分，我果然还是数据结构不行啊。~~

一堆题解都是长剖显得很不人性好吧。

首先考虑单颗棋子的情况。显然其 SG 值为子树高，也就是子树内距离其最远点的距离。

多颗棋子互不干扰，因此异或起来，所以只考虑模 $2$ 后的 $a_i$。

思考后发现一个棋子的 SG 只有两种情况：
1. 根没有挡住最远点
1. 根挡住了最远点

于是可以记录最远点的距离和次远点的距离。

然后给出一种判定一个根能否获胜的算法：首先修改就对于 dfs 序进行区间异或，然后单点查出对于这个点为根的所有点 SG 的异或和，最后检查是否大于树高即可。显然这是 $O(\log n)$ 的，可惜了，单次可能遇上菊花图导致需要检查所有 $O(n)$ 个点（当然可以 $O(1)$ 换到相邻的点作为根，不过没用）。

但是稍作思考又会发现距离一个点最远的点必然是直径的端点。

于是随便拎一条直径 $s\sim t$ 出来，那么此时只会有三种情况：
1. 到 $s$ 最远
1. 到 $t$ 最远
1. 到对于直径而言的子树内最远

什么叫对于直径而言呢？就是想象根不是一个点，而是直径这条链，上面挂着许多子树。

虽然情况变多了，不过显然美观一点了。于是先对于每个点预处理出这三个值。

现在，假设根是 $rt$，每个点的 SG 应该是什么？

不妨假设直径上距离 $rt$ 最近的点是 $rt'$，那么以 $rt'$ 为根应该会有 $s$ 到 $rt'$ 的链（不含 $rt'$）都是情况 1、$t$ 到 $rt'$ 的链（不含 $rt'$）都是情况 2、$rt'$ 本身是情况 1 和 2 的最大值、剩下的均为情况 3。

那么再换根到 $rt$ 显然只会影响 $rt$ 到 $rt'$ 链上的 SG，显然这些 SG 都会变成情况 1 和 2 的最大值。

总结一下，情况 1 和 2 均为链，于是直接令所有都是情况 3 然后异或上链上的值即可，可树剖维护。当然，用之前的 dfs 序维护并非不可，大同小异。总之得到了 $y$ 点本身的答案。

可以回到询问了。先不管修改，如果询问 $y$ 和周围的点的答案？

特判掉和 $y$ 距离直径最近的点不同的点，这些点显然最多只有两个（当然如果 $y$ 不在直径上那就是没有）。剩下的点就可以看为 $y$ 答案的基础上异或一个数，也就是那些点情况 1、2 最大值和情况 3 的异或。

接着把 $y$ 和 $y$ 的父亲（如果 $y$ 在直径上就没有）特判掉。最后考虑 $y$ 的儿子们。显然修改一个点时可以直接传给父亲。

现在问题是查询 $y$ 的答案和那些值的异或中超过给定值的。显然周围的点的距离最远点的距离不完全一样，但是发现只会出现三种情况：$y$ 距离最远点的距离 $+(-1/0/1)$。于是变成了经典问题，每个点开三棵 Trie 即可，$O(\log n)$。

分析一下，首先直径上一个树状数组维护，然后其余地方树剖加树状数组或 dfs 序加树状数组，最后每个点三个 Trie。于是时间复杂度 $O((n+m)\log n)$，空间复杂度 $O(m+n\log n)$。

---


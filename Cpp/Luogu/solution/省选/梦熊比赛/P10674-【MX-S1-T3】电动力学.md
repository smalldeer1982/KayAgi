# 【MX-S1-T3】电动力学

## 题目背景

原题链接：<https://oier.team/problems/S1C>。

## 题目描述

给定一张包含 $n$ 个点 $m$ 条边的简单无向连通图，点的编号为 $1\sim n$。

你需要求出有多少集合对 $S,T\sube \{1,2,\dots,n\}$，满足对于任意的 $i\in S$，要么 $i$ 也 $\in T$，要么存在 $x,y\in T$（$x\neq y$），满足存在一条从 $x$ 到 $y$ 的简单路径经过 $i$。

注意，集合对 $S,T$ 可以为空集。

输出答案对 $998244353$ 取模后的结果。


## 说明/提示

__【样例解释 1】__

所有合法的集合 $S,T$ 为：

1. $S=\{\},T=\{\}$。
2. $S=\{\},T=\{1\}$。
3. $S=\{\},T=\{2\}$。
4. $S=\{\},T=\{1,2\}$。
5. $S=\{1\},T=\{1\}$。
6. $S=\{1\},T=\{1,2\}$。
7. $S=\{2\},T=\{2\}$。
8. $S=\{2\},T=\{1,2\}$。
9. $S=\{1,2\},T=\{1,2\}$。 

__【数据范围】__

__本题使用子任务捆绑测试。__

对于 $100\%$ 的数据，$2\le n\le 5\times 10^5$，$n-1\le m\le 10^6$，$1\le u_i,v_i\le n$。保证图连通，无自环、重边。

| 子任务编号 | $n\le $        | $m\le $            | 特殊性质        | 分值 |
| ---------- | -------------- | ------------------ | --------------- | ---- |
| $1$        | $10$           | $\frac{n(n-1)}{2}$ | 无              | $10$ |
| $2$        | $20$           | $\frac{n(n-1)}{2}$ | 无              | $10$ |
| $3$        | $5\times 10^5$ | $n-1$              | $u_i=i,v_i=i+1$ | $10$ |
| $4$        | $5\times 10^5$ | $n-1$              | 无              | $20$ |
| $5$        | $5\times 10^5$ | $n$                | 无              | $20$ |
| $6$        | $5\times 10^5$ | $10^6$             | 无              | $30$ |


## 样例 #1

### 输入

```
2 1
1 2```

### 输出

```
9```

## 样例 #2

### 输入

```
9 10
8 3
6 8
8 5
1 6
6 2
4 6
8 2
1 7
9 6
5 3```

### 输出

```
80995```

## 样例 #3

### 输入

```
20 36
4 7
2 13
18 11
6 14
4 20
5 4
1 9
19 4
6 8
11 15
4 11
4 18
16 9
16 4
18 15
3 18
4 6
5 7
20 6
20 8
8 14
19 13
12 9
4 8
4 15
20 14
3 10
12 1
17 16
13 4
4 14
10 18
4 2
16 12
19 2
1 16```

### 输出

```
211240350```

# 题解

## 作者：xieziheng (赞：15)

这题真的只有蓝吗。。。看来是我太菜了

不过我竟然场切了 dp，感到震惊。

这个题首先要选择一个好算的东西计数，如果考虑对每个 $S$ 算 $T$ 的方案就很不好搞，所以反过来，考虑对每个 $T$ 算有多少个 $S$ 满足条件。$|T|\leq 1$ 是平凡的，一下设 $|T|\geq 2$。

先看树的情况，是显然的，$S$ 中的点必定在 $T$ 中所有点构成的虚树中，且这是充要的，换言之，设 $T$ 中点构成的虚树大小为 $m$，则共有 $2^m$ 的 $S$ 满足条件。

考虑推广。发现“简单路径”很像点双相关（说句闲话，我比赛以为简单路径指的是边不重复）。于是大胆猜测构成的是所有有 $|T|$ 中路径经过的点双的并集大小。证明是容易的，由点双性质可知。

所以考虑建出圆方树 dp。这时候就需要给圆方树上每个点赋权，使得答案容易计算。发现可以这样赋值：对于圆点，权值为 $0$，对于方点 $x$，权值为 $s_x-1$，$s_x$ 表示第 $x$ 个点双的大小。这样所有有 $|T|$ 中路径经过的点双的并集大小即为所有 $T$ 中的点在圆方树上构成的虚树中的点的权值和加一，设这个玩意为 $F(T)$。即求 $\sum_{T} 2^{F(T)}=2\sum_{T} 2^{F(T)-1}$。

考虑 dp，设 $f_x$ 表示虚树根为 $x$ 的方案数。考虑合并子树状态，一定为选择若干个在 $x$ 的不同子树的点，然后对其求和。设 $g(y,x)$ 表示对于 $x$ 为 $y$ 的祖先，$x$ 到 $y$ 路径上的权值和（不包含 $y$），设 $t_x=\sum_{y\in S_x} f_y2^{g(y,x)}$，$S_x$ 表示 $x$ 的子树构成的集合，同理定义 $T_x$ 表示 $x$ 所有儿子构成的集合。

- $x$ 为方点，则一定为选择大于等于 $2$ 个子树中的点合并。则 $f_x=2^{s_x-1}((\prod_{y\in T_x}(1+t_y))-1-\sum_{y\in T_x}t_y),t_x=2^{s_x-1}\sum_{y\in T_x}t_y$。

- $x$ 为原点，则 $f_x=(2\prod_{y\in T_x}(1+t_y))- 1-\sum_{y\in T_x}t_y$。

这样就做完了，复杂度 $\mathcal{O}(n)$

细节见代码：

```cpp
#include <bits/stdc++.h>
#define il inline
using namespace std;
typedef long long ll;
const ll mod=998244353;
il int read(){
    int x=0,c=getchar();
    while(!isdigit(c)) c=getchar();
    while(isdigit(c)) x=x*10+c-48,c=getchar();
    return x;
}
il void add(ll &x,ll y){x=(x+y>=mod?x+y-mod:x+y);}
const int N=1e6+5;
int n,m,dfn[N],low[N],cnt,st[N],top,bel[N],idx,siz[N];ll ans,pw[N],f[N],s[N],t[N];
vector<int> e[N],g[N];
il void adde(int x,int y,vector<int> e[]){e[x].push_back(y),e[y].push_back(x);}
void tarjan(int x,int fath){
    int y,z;dfn[x]=low[x]=++cnt,st[++top]=x;
    for(int y:e[x]){
        if(y==fath) continue;
        if(!dfn[y]){
            tarjan(y,x),low[x]=min(low[x],low[y]);
            if(low[y]>=dfn[x]){
                ++idx,adde(idx+n,x,g),bel[x]=idx,siz[idx+n]=1;
                do{
                    z=st[top--],bel[z]=idx,adde(idx+n,z,g),++siz[idx+n];
                }while(z!=y);
            }
        }
        else low[x]=min(low[x],dfn[y]);
    }
}
void dfs(int x,int fath){
    if(x>1 && g[x].size()==1){
        f[x]=s[x]=t[x]=1;
        return ;
    }
    ll u=0,v,w=1ll;
    for(int y:g[x]){
        if(y==fath) continue;
        dfs(y,x),add(s[x],s[y]);
    }
    if(x>n){
        for(int y:g[x]){
            if(y==fath) continue;
            add(u,t[y]),w=(w*(1ll+t[y]))%mod,t[x]=(t[x]+pw[siz[x]-1]*t[y])%mod;
        }
        f[x]=((w-1ll-u+mod)*pw[siz[x]-1])%mod;
    }
    else{
        for(int y:g[x]){
            if(y==fath) continue;
            add(u,t[y]),w=(w*(1ll+t[y]))%mod,add(t[x],t[y]);
        }
        f[x]=(u+(w-u+mod)*2ll-1)%mod;
    }
    add(s[x],f[x]),add(t[x],f[x]);
}
int x,y,z;ll u,v,w;
int main(){
    scanf("%d%d",&n,&m);pw[0]=1ll;
    for(int i=1;i<=n;++i) pw[i]=(pw[i-1]*2ll)%mod;
    for(int i=1;i<=m;++i) x=read(),y=read(),adde(x,y,e),adde(y,x,e);
    tarjan(1,0);
    dfs(1,0);
    for(int i=1;i<=n+idx;++i) add(ans,f[i]);
    printf("%lld",(2ll*ans+1ll)%mod);
    return 0;
}
```

---

## 作者：rizynvu (赞：9)

[我的博客](https://www.cnblogs.com/rizynvu/p/18281036)。

首先考虑这个 $S, T$ 肯定需要固定一个算另一个的方案数。  
如果固定 $S$，会发现非常不好给 $T$ 下限制。  
于是考虑固定 $T$，对 $S$ 计数。

首先考虑如果 $T$ 只有 $2$ 个点 $x, y$，该怎么对 $S$ 计数。  
考虑到这个简单路径的定义是不经过重点，考虑找到点双。  
然后能发现，只要是在 $x\to y$ 这个路径上经过的点双里的点，都是可以放入 $S$ 的。

于是这启发找到点双后建出圆方树并在上面 *DP*。  

首先要考虑圆点方点的权值 $a_u$。  
根据前面说到的，可以知道经过的方点的对应的点集的并就是可以放入 $S$ 的点集。  

令 $\operatorname{siz}_u$ 为方点 $u$ 对应的点的个数，令 $U$ 为经过的方点的集合。  
考虑到连接的两个方点的圆点都会算上这个圆点，需要 $-1$。   
所以有 $|S| = (\sum\limits_{u\in U} \operatorname{siz}_u) - (|U| - 1) = (\sum\limits_{u\in U}(\operatorname{siz}_u - 1)) + 1$。  
那么这样就只与 $u$ 有关而不用考虑 $|U|$ 之类的东西了。  
于是可以把方点的权值设为 $a_u = \operatorname{siz}_u - 1$， 圆点设置为 $a_u = 0$。  
对于少考虑的 $1$ 最后补上就行了。

同时需要考虑到知道了 $T$，那么哪些方点 $u$ 是能被经过的。  
这个易知只要 $u$ 在 $T$ 对应在圆方树上的虚树中，$u$ 就可以经过。

同时如果知道了 $T$ 对应的 $S$，其对应的权值显然为 $2^{|S|}$。

于是就可以考虑 *DP* 了。  
先定义 $\operatorname{subtree}_u$ 表示 $u$ 的子树，$\operatorname{son}_u$ 为 $u$ 的儿子，$\operatorname{val}(u \to v)$ 表示 $u\to v$ 这条路径上经过的点 $w(w\not = v)$ 的 $\prod 2^{a_w}$，也就是这条路径上的方点产生的贡献。  

考虑从上面说到的虚树来考虑，令 $f_u$ 为 $u$ 为虚树的根是对应的方案数。  
但会发现这样根本不好转移，因为虚树的根可能是两个不同子树里的根在此处合并产生的。  
于是考虑在令 $g_u$ 为 $u$ 子树内任意一个点为根对应的方案数，具体表示一下就是 $g_u = \sum\limits_{v\in \operatorname{subtree}(u)} f_v\times \operatorname{val}(u\to v)$。  

然后考虑转移，分为圆点和方点：  
1. 对于圆点为根，有 $2$ 种选择：自己本身就被选中或者有两个不同子树有点被选中。  
   所以说如果有 $\ge 2$ 个不同子树内有被选中的，$2$ 种方法都可以；但若是只有 $1$ 个子树或者没有，就只可能是自己被选中 $1$ 种。  
   可以对 $g_v(v\in \operatorname{son}_u)$ 做个背包得到 $h_{0\sim 2}$，其中 $h_x(0\le x\le 1)$ 分别代表有 $x$ 个不同子树内有点被选中的方案数，$h_2$ 代表有 $\ge 2$ 个不同子树内有点被选中的方案数。  
   那么有 $f_u = 2h_2 + h_1 + h_0$。  
2. 对于方点为根，那么就只能是有两个不同子树有点被选中了。  
   同上一样对 $g_v(v\in \operatorname{son}_u)$ 做背包得到 $h_{0\sim 2}$。  
   那么因为 $u$ 是方点，有对应的贡献 $2^{a_u}$，所以有 $f_u = h_2\times 2^{a_u}$。  

然后对于 $g_u$，考虑有 $\operatorname{val}(u\to w) = 2^{a_u}\operatorname{val}(v\to w)(w\in \operatorname{subtree}(v), v\in \operatorname{son}_u)$，于是只需所有 $g_v$ 乘上 $2^{a_u}$ 后，再加上新出现的 $f_u$ 就行了。  
即 $g_u = h_1 2^{a_u} + f_u$。

最后记得补上之前少的 $1$，乘 $2$ 即可，并补上 $S = T = \varnothing$ 的 $1$。

时间复杂度 $\mathcal{O}(n)$。

```cpp
#include<bits/stdc++.h>
using ll = long long;
constexpr ll mod = 998244353;
const int maxn = 1e6 + 10;
int n, N;
ll pw[maxn];
std::vector<int> G[maxn], to[maxn];
int low[maxn], dfn[maxn], dt, stk[maxn], top;
int siz[maxn];
void dfs1(int u) {
   low[u] = dfn[u] = ++dt, stk[++top] = u;
   for (int v : G[u]) {
      if (dfn[v]) low[u] = std::min(low[u], dfn[v]);
      else {
         dfs1(v), low[u] = std::min(low[u], low[v]);
         if (dfn[u] == low[v]) {
            N++, to[u].push_back(n + N), to[n + N].push_back(u);
            int t;
            do {t = stk[top--]; to[t].push_back(n + N), to[n + N].push_back(t);} while (t != v);
            siz[n + N] = to[n + N].size();
         }
      }
   }
}
ll f[maxn], g[maxn];
void dfs2(int u, int fa) {
   if (u != 1 && to[u].size() == 1)
      return f[u] = g[u] = 1, void();
   ll h[3] = {1, 0, 0};
   for (int v : to[u]) {
      if (v == fa) continue;
      dfs2(v, u);
      h[2] = (h[2] * (g[v] + 1) + h[1] * g[v]) % mod, h[1] = (h[1] + h[0] * g[v]) % mod;
   }
   if (u > n) f[u] = pw[siz[u] - 1] * h[2] % mod, g[u] = (pw[siz[u] - 1] * h[1] + f[u]) % mod;
   else f[u] = (2ll * h[2] + h[1] + h[0]) % mod, g[u] = (h[1] + f[u]) % mod;
}
int main() {
   int m; scanf("%d%d", &n, &m);
   for (int i = pw[0] = 1; i <= n; i++) (pw[i] = pw[i - 1] << 1) >= mod && (pw[i] -= mod);
   for (int x, y; m--; )
      scanf("%d%d", &x, &y), G[x].push_back(y), G[y].push_back(x);
   dfs1(1);
   dfs2(1, 0);
   ll ans = 0;
   for (int i = 1; i <= n + N; i++) (ans += f[i]) %= mod;
   printf("%lld\n", (2ll * ans + 1ll) % mod);
   return 0;
}
```

---

## 作者：Nelofus (赞：4)

怄火。

笑点解析：明明知道什么是简单路径，但是还是按照边不重合来想了。

考虑一下题目条件是在说什么，这个连通性很自然的导向了点双。建出圆方树，那么集合对 $S,T$ 是好的当且仅当 $S$ 的方点邻居或 $S$ 自己在 $T$ 的虚树上。

如果我们把 $T$ 确定下来，那么 $S$ 的数量必然是 $2^{|T|}$。那么计数的过程中主要维护的对象就应该是 $T$。

对每个集合 $T$，我们钦定在 $T$ 虚树的根结点处计数这个集合的贡献。设 $f_u$ 表示所有以 $u$ 为根的虚树的 $T$ 对应的集合对个数之和。

再令 $g_{u}$ 表示 $u$ 子树中，在所有 $T$ 中额外添加一个 $u$（$u$ 到“原本 $T$ 对应的虚树”的路径，也是虚树的一部分）时，所有 $T$ 对应的集合对个数之和。

对于方点，我们有转移

$$
f_u=2^{s_u-1}\left(\prod_{v\in \operatorname{son}(u)}(1+g_v)-1-\sum_{v\in\operatorname{son}(u)}g_v\right)
$$

其中 $s_u$ 为方点 $u$ 对应的点双大小。因为钦定了 $u$ 是虚树的根，那就必须选 $\ge 2$ 个子树。如果选了 $\ge 2$ 个子树，那么任何一个方点 $u$ 的儿子（圆点）都可以被包含在集合 $S$ 之中。

不要在这里抉择每个儿子 $v$ 是否在 $T$ 里，这里已经在儿子处决择过了。

$$
g_u=\left(2^{s_u-1}\sum_{v\in \operatorname{son}(u)}g_v\right)+f_u
$$

同理，因为到 $u$ 的路径也是虚树的一部分，方点 $u$ 的所有儿子（圆点）也可以被包含在 $S$ 中，所以要乘上 $2^{s_u-1}$，最后再加上 $f_u$。

对于圆点 $u$ 我们有转移。

$$
f_u=\left(\prod_{v\in \operatorname{son}(u)}(1+g_v)-1-\sum_{v\in\operatorname{son}(u)}g_v\right)+\prod_{v\in \operatorname{son}(u)}(1+g_v)
$$

如果点 $u$ 不在 $T$ 中，那么至少要有两个儿子被选择，才能在虚树上。否则无论如何就都是可行的。

$$
g_u=\left(\sum_{v\in \operatorname{son}(u)}g_v\right)+f_u
$$

这个比较显然。

答案就是：

$$
2\sum_{i=1}^{tot}f_i+1
$$

这里乘 $2$ 是因为，如果 $u$ 是方点，我们没有决策其父亲是否在 $S$ 中，如果 $u$ 是圆点，我们没有决策自己是否在 $S$ 中。最后加上两者都为空的 $1$。

其中 $tot$ 是圆方树点数。

---

## 作者：ChrysanthBlossom (赞：4)

另一种做法。感觉比现有题解好想，但是实现起来好复杂。

首先把题目条件再翻译一下。其实 $S$ 和 $T$ 的关系可以认为是从原图上“拎出来”一个 $T$ 的“导出子图”（即所有能不经过 $T$ 的其他点到达 $T$ 里面至少两个点的点构成的集合），然后再从这个“导出子图”里面再选出来一个点集构成 $S$。

先思考树。考虑 $S$ 和 $T$ 同时在 dp 的过程中选，那么必然有可能在 dp 时出现先把 $u$ 放入 $S$ 中，但 $u$ 当前仅能到一个点，还需要通过能到达 $u$ 子树外的一个点来让自己合法的情况。我们称“让 $u$ 合法”这样的操作为“封顶”。

设 $f_{u,0/1/2}$ 表示 $u$ 这个子树内没有点放在 $T$ 里面（显然此时也没有点放在 $S$ 里面）/ 有放在 $T$ 的，并且不需要一个子树外的点来给我“封顶”/ 有放在 $T$ 的，但需要一个子树外的点来“封顶”。答案即为 $f_{1,0}+f_{1,1}$。

转移可以用一个类似于背包的形式来做。设 $g_{u,0,1,2,3}$ 表示 $u$ 这个子树内（不包括 $u$）没有点在 $T$ 里面 / 有一个 $u$ 的儿子对应的子树里面有点在 $T$ 里面，这个儿子对应的子树不需要“封顶” / 有两个 $u$ 的儿子对应的子树里面有点在 $T$ 里面（显然，无论他们需不需要“封顶”，他们都已经互相封顶了）/ 有一个 $u$ 的儿子对应的子树里面有点在 $T$ 里面，这个儿子对应的子树需要“封顶”。此时，$f_{u,0}$ 显然为 $1$，故讨论 $f_{u,1}$ 与 $f_{u,2}$ 即可。可列出如下转移式：

 $$f_{u,1}=g_{u,0}\times 2+g_{u,1}\times 3+g_{u,2} \times 4+g_{u,3}\times 2$$
 
 $$f_{u,2}=g_{u,1}+g_{u,3}\times 2$$
 
两个式子都可以讨论出来（有不懂的可以再问我），这里以讨论 $f_{u,1}$ 为例。

对于 $f_{u,1}$，当 $u$ 子树里面的点除了 $u$ 都未被放入 $T$ 中时，为了让 $u$ 子树中存在点被选入 $T$，$u$ 一定要放入 $T$，而放不放 $S$ 是无所谓的，故系数为 $2$；当 $u$ 仅有一个儿子的子树里面存在点且不需要“封顶”，由于当前情况不能需要封顶，故仅不能出现将 $u$ 放入 $S$ 却不放入 $T$ 中的情况，系数为 $3$；当 $u$ 的子树里面有两个儿子对应的子树里面有点在 $T$ 中时，$u$ 的状态任意，故系数为 $4$；当 $u$ 仅有一个儿子的子树里面存在点但需要 “封顶”，此时 $u$ 必须在 $T$ 里面，而是否在 $S$ 中没有影响，因此系数为 $3$。

接着考虑图。显然以下命题成立：对于任意一个点双连通分量中的任意三个点，他们中任意两个都可以在不经过第三个点的情况下互相到达。（反证即可，假设不成立，设这两个点为 $u,v$，第三个点为 $w$，若 $u$ 无法不经过 $w$ 到达 $v$，则将 $w$ 删去后 $u$ 与 $v$ 不连通，根据点双定义 $u,v$ 不在同一点双连通分量，与条件矛盾），于是可以考虑把这棵树的圆方树建出来，在圆方树上 dp。

思考此时会比树多出来什么。由于属于同一个点双的点之间可不经过任意一个其他点互相到达，因此此时一个圆点的“邻居”（即与这个点连有共同的方点的圆点）可充当方点的作用。显然我们不能真把邻居当儿子（转移不了），但我们可以把这个转移在方点以及方点的父亲做。

由于邻居可以当成儿子，因此一个子树里面可能仅将 $u$ 放入 $S$ 中而在 $T$ 中不放任何元素。对于圆点，我们重新定义 $f_{u,0/1/2/3}$，其中 $f_{u,0/1/2}$ 与先前树上情况相同，$f_{u,3}$ 表示仅将 $u$ 放入 $S$ 中却不向 $T$ 放入任何元素，此时显然为 $1$。对于方点，我们重新定义 $g_{u,0/1/2/3/4}$，其中 $g_{u,0/1/2/3}$ 与先前相同，$g_{u,4}$ 表示 $u$ 子树内没有选入 $T$ 中的点，但是在此方点下有被选入 $S$ 的圆点。转移仍可以用类似背包的方式进行。对于圆点，用它的方点儿子的 $g$ 转移即可。

具体的转移可见代码，不懂可再问我（代码中用 $s$ 来代替 $g$，同时对于方点用 $f$ 来代替 $g$）。

[代码在此](https://www.luogu.com.cn/paste/wyf5q5kx)。

---

## 作者：DaiRuiChen007 (赞：2)

[Problem Link](https://www.luogu.com.cn/problem/P10674)

**题目大意**

> 给定 $n$ 个点 $m$ 条边的无向图，求有多少点集对 $(S,T)$ 使得每个 $S$ 中元素都在某两个 $T$ 中元素的某条简单路径上。
>
> 数据范围：$n\le 5\times 10^5,m\le10^6 $。

**思路分析**

对每个 $T$，求出其内部所有路径并构成的点集 $V(T)$，那么 $S$ 的选法就是 $2^{|V(T)|}$ 种方案。

考虑刻画 $f(T)$，容易发现建出原图的圆方树，那么所有 $T$ 中节点所在的方点生成的斯坦纳树上的点都在 $V(T)$ 中，如果是方点，那么其对应的所有圆点都在 $V(T)$ 中。

考虑在方点处统计权值，对于一个大小为 $C$ 的点双连通分量，设其权值为 $2^{C-1}$，即圆方树上儿子个数。

那么对于斯坦纳树的根，如果其是圆点，那么没有将这个点考虑在 $V(T)$ 中，否则没有将其父亲对应的圆点考虑进 $V(T)$ 中，因此答案最后 $\times 2$ 再加上 $T=\varnothing$ 的情况即可。

dp 时设 $f_u$ 表示 $u$ 子树内至少有一个点被选入 $T$ 时的权值和，即钦定 $u$ 子树外选点后的答案。

但是我们在统计点 $u$ 作为树根的权值的时候要钦定至少两棵子树被选，做一个简单背包即可。

时间复杂度 $\mathcal O(n+m)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=1e6+5,MOD=998244353;
ll dp[MAXN],ans,pw[MAXN];
vector <int> G[MAXN],E[MAXN];
void link(int x,int y) { E[x].push_back(y),E[y].push_back(x); }
int n,m,k,low[MAXN],dfn[MAXN],dcnt,stk[MAXN],tp,w[MAXN];
bool ins[MAXN];
void tarjan(int u) {
	ins[stk[++tp]=u]=true,dfn[u]=low[u]=++dcnt;
	for(int v:G[u]) {
		if(!dfn[v]) {
			tarjan(v),low[u]=min(low[u],low[v]);
			if(low[v]>=dfn[u]) {
				link(++k,u);
				while(ins[v]) link(stk[tp],k),++w[k],ins[stk[tp--]]=false;
			}
		} else low[u]=min(low[u],dfn[v]);
	}
}
void dfs(int u,int fz) {
	if(E[u].size()==1&&fz!=0) return ++ans,dp[u]=1,void();
	ll g[3]={1,0,0};
	for(int v:E[u]) if(v^fz) {
		dfs(v,u),g[2]=(g[2]*(dp[v]+1)+g[1]*dp[v])%MOD,g[1]=(g[1]+g[0]*dp[v])%MOD;
	}
	if(u>n) ans=(ans+g[2]*pw[w[u]])%MOD,dp[u]=(g[2]+g[1])*pw[w[u]]%MOD;
	else ans=(ans+2*g[2]+g[1]+g[0])%MOD,dp[u]=(2*g[2]+2*g[1]+g[0])%MOD;
}
signed main() {
	scanf("%d%d",&n,&m),k=n;
	for(int i=pw[0]=1;i<=n;++i) pw[i]=pw[i-1]*2%MOD;
	for(int i=1,u,v;i<=m;++i) {
		scanf("%d%d",&u,&v),G[u].push_back(v),G[v].push_back(u);
	}
	tarjan(1),dfs(1,0);
	printf("%lld\n",(2*ans+1)%MOD);
	return 0;
}
```

---

## 作者：Mirasycle (赞：1)

高质量广义圆方树上 dp 题。

首先，$(S,T)$ 计数有点吓人。考虑固定 $T$，令 $T$ 所涉及到的虚树大小为 $sz(T)$。这样子 $S$ 的方案数就是 $2^{sz(T)}$。

由于路径要求不经过重复点，所以考虑点双相关。

对原图建立广义圆方树之后，转化为树上 dp。

一个点能产生贡献，当且仅当其对应方点在两个被选择点的路径上，或者点双内部有某点被选择了。

处理广义圆方树的时候，我们要考虑巧妙设计点权。由于方点之间的圆点会在两个方点处被统计两次，所以经典赋权方案就是 $sz_u,-1$ 赋权，或者 $sz_u-1,0$ 赋权。这里采取后者，可以发现这样子其实对于某条路径其实是多除以了 $2$，最后乘上即可。还要补上 $S=T=\empty$ 的贡献。

设 $f_u$ 表示 $u$ 点为虚树的根的方案数，此时要求 $u$ 点的两个不同子树内部有点被选择了，或者 $u$ 点本身被选择了。

每次转移就是从子树内某点 $v$，贡献为 $f_v\times \rm \rm path (u,v)$，也就是累计上途径路径的贡献。这个可以开一个辅助数组记录从下面来的所有贡献，同时记得每次累加当前点的 $f$ 值，并且不断乘上路径贡献。这样子可以 $O(1)$ 转移，这题就做完了。

时间复杂度 $O(n+m)$。

---


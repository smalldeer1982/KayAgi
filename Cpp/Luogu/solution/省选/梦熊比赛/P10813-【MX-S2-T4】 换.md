# 【MX-S2-T4】 换

## 题目背景

原题链接：<https://oier.team/problems/S2D>。

## 题目描述

给定 $n,V$ 和一个长为 $m$ 的序列 $(p_1,q_1),(p_2,q_2),\dots,(p_m,q_m)$。

请求出有多少长度为 $n$ 的正整数序列 $a$，其所有元素 $a_i$ 满足 $1\le a_i\le V$，将其按 $k=1,2,\dots,m$ 依次执行如下操作后，$a$ 不降：  

- 若 $a_{p_k}>a_{q_k}$，则交换 $a_{p_k}$ 与 $a_{q_k}$ 的值。

答案对 $10^9+7$ 取模。

## 说明/提示

**【样例解释 \#1】**

对于第一组样例，有以下 $12$ 种符合条件的序列：

$\{1,1,1\}$，$\{1,1,2\}$，$\{1,1,3\}$，$\{1,2,1\}$，$\{1,3,1\}$，$\{2,1,1\}$，$\{2,2,2\}$，$\{2,2,3\}$，$\{2,3,2\}$，$\{3,1,1\}$，$\{3,2,2\}$，$\{3,3,3\}$。

**【数据范围】**

**本题采用捆绑测试。**

- Subtask 0（8 pts）：$n\le6$，$V\le 8$，$m \le 50$。
- Subtask 1（31 pts）：$n \le 8$。
- Subtask 2（37 pts）：$n \le 15$。
- Subtask 3（24 pts）：无特殊限制。

对于所有测试数据，$1\le n\le 18$，$1\le V\le 10^9$，$1\le m\le 500$，$1\leq p_k,q_k\leq n$，注意不保证 $p_k$ 和 $q_k$ 的大小关系，且数据可能存在 $p_k=q_k$。

## 样例 #1

### 输入

```
3 3 5
3 2
1 3
1 2
2 3
2 1```

### 输出

```
12```

## 样例 #2

### 输入

```
8 900000754 20
5 5
1 2
3 2
1 8
4 8
5 8
3 4
3 7
5 7
3 4
6 8
1 5
7 8
7 8
5 7
1 8
3 8
3 8
5 6
3 8
```

### 输出

```
508510094```

# 题解

## 作者：BreakPlus (赞：9)

一个经典 trick：考虑值域为 $\{0,1\}$ 的时候怎么做。

发现非常简单粗暴：可以直接枚举 $2^n$ 种可能性，然后模拟 $m$ 次操作，再检验操作完毕后是否有序。因此进行一个 $\mathcal{O}(m2^n)$ 的预处理。

在值域变大的情况下，我们可以将其拆成多个值域为 $\{0,1\}$ 的情况。即，对于任意 $2 \le i \le V$，将 $a$ 中 $<i$ 的数视作 $0$，$\ge i$ 的数视作 $1$，对于构造出的 $\{0, 1\}$ 序列应依然满足题意要求，而判断其是否满足是可以利用上面所预处理的内容。

设 $f_{i,j}$ 表示值域为 $i$，当前二进制数为 $j$ 的情况。转移就是每次转移到 $j$ 的一个合法子集（或超集，即倒着做，依然能得到正确结果）。

利用高维前缀和可以做到 $\mathcal{O}(nV2^n)$。

-----

令 $g(x)$ 为 $V=x$ 的答案，$h(x)$ 为序列中恰好有 $x$ 种数的答案（相当于 $V=x$，且 $1 \sim x$ 中所有数均出现，不难发现 $x \le n$ 才有值），发现 $g(x) = \sum \limits_{k} \binom{x}{k}h(k)$，即 $g(x)$ 是关于 $x$ 的 $n$ 次多项式。

可以算 $g(x)$ 拉插一下（比较常见的套路），也可以直接算 $h(x)$ 然后算组合数。

时间复杂度 $\mathcal{O}((n^2+m)2^n)$。

```cpp
ll n,V,m,p[505],q[505],f[20][1<<18],w[20];
bool vis[1<<18], t[30];
void addmod(ll &x){ if(x >= mod) x -= mod; }
void solve(){
	n=read(), V=read(), m=read();
	for(ll i=1;i<=m;i++){
		p[i]=read()-1, q[i]=read()-1;
	}
	for(ll i=0;i<(1<<n);i++){
		for(ll j=0;j<n;j++) t[j]=((i>>j)&1);
		for(ll j=1;j<=m;j++){
			if(t[p[j]] > t[q[j]]) swap(t[p[j]], t[q[j]]);
		}
		vis[i] = 1;
		for(ll j=1;j<n;j++) if(t[j-1] > t[j]) vis[i]=0;
	}
	f[0][0] = 1;
	for(ll i=1;i<=n;i++){
		for(ll j=0; j<(1<<n); j++) f[i][j] = f[i-1][j];
		for(ll j=0; j<n; j++)
			for(ll k=0; k<(1<<n); k++){
				if((k>>j)&1) continue;
				addmod(f[i][k^(1<<j)] += f[i][k]);
			}
		for(ll k=0; k<(1<<n); k++)
			if(!vis[k]) f[i][k] = 0;
	}
	ll ans = 0;
	for(ll i=0;i<=n;i++){
		for(ll j=0; j<(1<<n); j++) addmod(w[i+1] += f[i][j]);
	}
	for(ll i=1;i<=n+1;i++){
		ll xs = 1;
		for(ll j=1; j<=n+1; j++) if(j!=i) xs = xs * qpow(i-j+mod, mod-2) % mod;
		for(ll j=1; j<=n+1; j++) if(j!=i) xs = xs * (V-j+mod) % mod;
		ans = (ans + xs * w[i]) % mod; 
	}
	printf("%lld\n", ans);
}
```

---

## 作者：Petit_Souris (赞：9)

如果 CSP-S T4 这个难度那我得乐开花了哥们。

首先看到排序网络问题就有一步经典转化：$\forall x$，构建一个新序列 $b_i$，将 $a_i\ge x$ 的 $i$ 对应的 $b_i$ 设为 $1$，将 $a_i<x$ 的 $i$ 对应的 $b_i$ 设为 $0$，那么一个正整数序列 $a$ 合法当且仅当对于所有 $x$，01 序列 $b$ 合法。

那么现在我们考虑从小到大扫描 $x$，考察 $b$ 的变化过程，是从初始全 $0$ 的一个序列，到某个值的时候将对应的若干个位置变成 $1$，最终变成一个全 $1$ 序列。那么这样就有一个很简单的 $\mathcal O(V2^nn+2^nm)$ 做法：预处理出每个 $b$ 序列是否合法（直接带进去跑一遍），再将 $b$ 序列作为状态进行状压 dp，每次转移做一个高维前缀和。

但是我们发现对于一个序列 $a$，只有在 $a$ 中出现过的值的转移是有意义的，剩下的转移都是不改变状态的。那么我们可以记录变化的次数并强制每次转移至少加入一个二进制位。最终假设有 $c$ 次变化，就有一个 $\binom{V}{c}$ 的系数。时间复杂度 $\mathcal O(2^nn^2+2^nm)$，可以通过。

```cpp
#include<bits/stdc++.h>
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
#define pii pair<ll,ll>
#define rep(i,a,b) for(ll i=(a);i<=(b);++i)
#define per(i,a,b) for(ll i=(a);i>=(b);--i)
using namespace std;
bool Mbe;
ll read(){
    ll x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
void write(ll x){
    if(x<0)putchar('-'),x=-x;
    if(x>9)write(x/10);
    putchar(x%10+'0');
}
const ll Mod=1e9+7;
ll n,V,m,A[509],B[509],dp[20][(1<<18)+5],f[(1<<18)+5];
bool valid[(1<<18)+5];
ll pw(ll x,ll p){
    ll res=1;
    while(p){
        if(p&1)res=res*x%Mod;
        x=x*x%Mod,p>>=1;
    }
    return res;
}
ll C(ll x,ll y){
    if(x<y||y<0)return 0;
    ll res=1;
    per(i,x,x-y+1)res=res*i%Mod;
    per(i,y,1)res=res*pw(i,Mod-2)%Mod;
    return res;
}
bool Med;
int main(){
    cerr<<fabs(&Med-&Mbe)/1048576.0<<"MB\n";
    n=read(),V=read(),m=read();
    rep(i,1,m)A[i]=read(),B[i]=read();
    rep(i,0,(1<<n)-1){
        ll s=i,pc=n-__builtin_popcount(i);
        rep(j,1,m){
            ll a=A[j],b=B[j];
            if((s>>(a-1))&1){
                if(!((s>>(b-1)&1)))s^=(1<<(a-1))^(1<<(b-1));
            }
        }
        valid[i]=1;
        rep(j,0,n-1){
            if(j<pc){
                if((s>>j)&1)valid[i]=0;
            }
            else {
                if(!((s>>j)&1))valid[i]=0;
            }
        }
    }
    dp[0][0]=1;
    rep(i,1,n){
        rep(j,0,(1<<n)-1)f[j]=dp[i-1][j];
        rep(j,0,n-1){
            rep(k,0,(1<<n)-1){
                if((k>>j)&1)f[k]=(f[k]+f[k^(1<<j)])%Mod;
            }
        }
        rep(j,0,(1<<n)-1){
            if(valid[j])dp[i][j]=(f[j]-dp[i-1][j]+Mod)%Mod;
            else dp[i][j]=0;
        }
    }
    ll ans=0;
    rep(i,1,n)ans=(ans+C(V,i)*dp[i][(1<<n)-1])%Mod;
    write(ans);
    cerr<<"\n"<<clock()*1.0/CLOCKS_PER_SEC*1000<<"ms\n";
    return 0;
}
```

---

## 作者：modfish_ (赞：6)

听完巨佬的讲解后，感觉如果了解排序网络，这题最大难点在高维前缀和（？

## 思路
对于任意一个序列 $a$，我们关心的只是它里面元素之间的大小关系，而不是具体的值。所以，我们先考虑经过离散化之后的序列 $a'$，则其值域为 $[1,k]$，其中 $1\le k\le n$。

枚举一个阈值 $t$，将 $a'$ 中所有小于等于 $t$ 的元素变成 $0$，大于 $t$ 的变成 $1$。设新序列为 $b$，即：

$$
b_i=
\begin{cases}
0,a'_i\le t\\
1,a'_i>t
\end{cases}
$$

根据排序网络的知识，如果无论 $t$ 取何值，经过 $m$ 次操作后，形成的新序列 $b$ 都可以被排成有序的，那么 $a'$ 可以被排成有序的， $a$ 自然也可以被排成有序的。

#### 证明
实际上，$b$ 序列反应的是 $a'$ 序列相对于 $t$ 的大小关系。如果 $b$ 序列有序，则意味着在 $a'$ 序列中，所有小于等于 $t$ 的数都在大于 $t$ 的数的左边。

如果对于任意 $t$，都能满足所有小于等于 $t$ 的数都在大于 $t$ 的数左边的话，那么这个序列显然是有序的。也可以反证：假设存在 $i<j$ 但 $a'_i>a'_j$，则当 $t=a'_j$ 时，$a'_j\le t,a'_i>t$，然而 $a'_j$ 在 $a'_i$ 右边，与假设矛盾，故原命题得证。

于是，我们的求解步骤就明确了：先求出所有可以被 $m$ 次操作排成有序的 0-1 序列；然后求出对于任意 $t$，其对应 $b$ 序列都可以被排序的序列 $a'$；最后求出所有 $a'$ 对应的序列 $a$ 的数量。

### 0-1 序列
这个简单，直接暴力枚举所有 0-1 序列，然后暴力进行 $m$ 次操作，最后统计哪些是有序的就行了。由于不同形态的 0-1 序列只有 $2^n$ 个，故此部分时间复杂度为 $O(m2^n)$。


```cpp
void solve1(){
	for(int x = 0; x < (1 << n); x ++){
		for(int i = 0; i < n; i ++) a[i] = (x >> i) & 1;
		for(int i = 1; i <= m; i ++) if(a[ps[i]] > a[qs[i]]) swap(a[ps[i]], a[qs[i]]);
		tag[x] = 1;
		for(int i = 1; i < n; i ++) tag[x] = tag[x] & (a[i] >= a[i - 1]);
	}
}
```

### 0-1 序列 --> 离散化序列
这是最麻烦的一步。当然也不是特别麻烦。设 $dp_{i,j}$ 表示 $t=i$ 时 $b$ 序列状压为 $j$，且对于任意 $t\le i$，其对应的 $b$ 序列都可以被排成有序，满足以上条件的 $a'$ 序列的数量。有如下转移式：

$$
dp_{i,j}=
\begin{cases}
0,j\not\in S\\
\sum_{k}dp_{i-1,k},j\in S
\end{cases}
$$

其中，$S$ 表示可以被排成有序的 0-1 序列的压缩状态的集合，$k$ 表示 $j$ 的二进制表示的一个真子集。注意，因为 $a'$ 是离散化后的序列，所以元素的值域是连续的，一旦 $t$ 变化，则 $b$ 一定也要变化，故 $k$ 不能等于 $j$。

若直接枚举子集，总体复杂度复杂度是 $O(n3^n)$，根本撑不住。考虑使用高维前缀和，将每个二进制位视为一维，分别对每一维作前缀和处理，这样最后得到的就是某个状态的子集了。具体可以见代码。

高维前缀和预处理复杂度 $O(n2^n)$，故总体复杂度 $O(n^22^n)$。


```cpp
void solve2(){
	dp[0][0] = 1;
	for(int i = 1; i <= n; i ++){
		for(int j = 0; j < (1 << n); j ++) s[i - 1][j] = dp[i - 1][j];
		for(int k = 0; k < n; k ++){
			for(int l = 0; l < (1 << n - 1); l ++){
				int j0 = (l & (1 << k) - 1) | ((l >> k) << k + 1);
				s[i - 1][j0 | (1 << k)] = (s[i - 1][j0] + s[i - 1][j0 | (1 << k)]) % p;
			}
		}
		for(int j = 0; j < (1 << n); j ++) if(tag[j]) dp[i][j] = (s[i - 1][j] + p - dp[i - 1][j]) % p;
	}
}
```


### 离散化序列 --> 原序列

这也是非常简单的一步。我们知道，对于值域为 $[1,k]$ 的 $a'$，共有 $dp_{k,2^n-1}$ 种。我们可以将其中的每个元素 $i$，对应映射到某个值 $v_i$ 上，满足 $1\le v_1<v_2<\dots<v_k\le V$。这样，每一组 $\{v_i\}$，都构建了一个从 $a'$ 到 $a$ 的双射。由排列组合知识知，这样的 $\{v_i\}$ 有 $\binom{V}{k}$ 种。

所以，最终答案为：

$$\sum_{k=1}^n\binom{V}{k}dp_{k,2^n-1}$$

这部分计算时间为 $O(n^2)$，可以忽略。


```cpp
ll solve3(){
	ll ans = 0;
	for(int i = 1; i <= n; i ++){
		ll C1 = 1, C2 = 1;
		for(ll j = 1; j <= i; j ++) C1 = C1 * (v - j + 1) % p, C2 = C2 * j % p;
		ans = (ans + C1 * qpow(C2, p - 2) % p * dp[i][(1 << n) - 1] % p) % p;
	}
	return ans;
}
```


于是，总体时间复杂度 $O((n^2+m)2^n)$。

## 代码

```cpp
#include <bits/stdc++.h>
#define ll long long

using namespace std;

const int maxn = 20, maxm = 505, maxv = (1 << 18) + 5, p = 1e9 + 7;

int n, m;
ll v;
int ps[maxm], qs[maxm], a[maxn], tag[maxv];
ll dp[maxn][maxv], s[maxn][maxv];
void solve1(){
	for(int x = 0; x < (1 << n); x ++){
		for(int i = 0; i < n; i ++) a[i] = (x >> i) & 1;
		for(int i = 1; i <= m; i ++) if(a[ps[i]] > a[qs[i]]) swap(a[ps[i]], a[qs[i]]);
		tag[x] = 1;
		for(int i = 1; i < n; i ++) tag[x] = tag[x] & (a[i] >= a[i - 1]);
	}
}
void solve2(){
	dp[0][0] = 1;
	for(int i = 1; i <= n; i ++){
		for(int j = 0; j < (1 << n); j ++) s[i - 1][j] = dp[i - 1][j];
		for(int k = 0; k < n; k ++){
			for(int l = 0; l < (1 << n - 1); l ++){
				int j0 = (l & (1 << k) - 1) | ((l >> k) << k + 1);
				s[i - 1][j0 | (1 << k)] = (s[i - 1][j0] + s[i - 1][j0 | (1 << k)]) % p;
			}
		}
		for(int j = 0; j < (1 << n); j ++) if(tag[j]) dp[i][j] = (s[i - 1][j] + p - dp[i - 1][j]) % p;
	}
}
ll qpow(ll a, ll x){
	ll res = 1;
	while(x){
		if(x & 1) res = res * a % p;
		a = a * a % p;
		x >>= 1;
	}
	return res;
}
ll solve3(){
	ll ans = 0;
	for(int i = 1; i <= n; i ++){
		ll C1 = 1, C2 = 1;
		for(ll j = 1; j <= i; j ++) C1 = C1 * (v - j + 1) % p, C2 = C2 * j % p;
		ans = (ans + C1 * qpow(C2, p - 2) % p * dp[i][(1 << n) - 1] % p) % p;
	}
	return ans;
}

int main(){
	scanf("%d %lld %d", &n, &v, &m);
	for(int i = 1; i <= m; i ++){
		scanf("%d %d", &ps[i], &qs[i]);
		ps[i] --, qs[i] --;
	}
	solve1();
	solve2();
	printf("%lld\n", solve3());
	return 0;
}
```

---

## 作者：lsj2009 (赞：4)

## Description

<https://www.luogu.com.cn/problem/P10813>。

## Solution

ak 了，爽！

先抛出一个结论：

- 我们定义 $f_a(x)$ 表示我们令 $a$ 序列上 $\le x$ 的为 $0$，$>x$ 的为 $1$，组成的 $01$ 序列。
- 若我们对于一个 $01$ 序列做题目中的操作且最终符合条件，则我们称这个 $01$ 序列是好的。
- 则我们可以说明的是，$a$ 序列符合条件当且仅当**对于任意 $x\in\mathbb{N}$ 均满足 $f_a(x)$ 是好的**。

证明：

- 若最终序列中存在一个 $a_{i-1}>a_i$，则我们选定一个 $x\in[a_i,a_{i-1})$，则此时 $f_a(x)$ 的值$^{*}$容易说明不是好的，若所有 $f_a(x)$ 的值都是好的，则可以说明最终序列中不存在相邻的逆序对，也就是非降的。
- $^{*}$：对于「容易说明」的解读：若我们 ``swap`` 两个数是相同的，则他们对于我们判断 $a_{i-1}$ 和 $a_i$ 的**大小关系并没有影响**，若一个为 $0$，一个为 $1$，则在 $f_a(x)$ 和 $a$ 中**都会进行交换**，此时我们最终得到的好的情况是和原来的序列相同的。

考虑知道这个结论后如何做。

我们考虑膜你上述过程，定义 $f_{S,x}$ 表示当前我们得到的 $f_{x}(a)=S$，我们接下来去枚举一个 $S\subsetneq T$ 和 $x'>x$ 转移至 $f_{T,x}$；并且一个 $f_{S,x}$ 的值是有有意义的，当且仅当 $S$ 是好的，否则我们令 $f_{S,x}\gets 0$。

这样子进行 dp，复杂度为 $\Theta(V3^n+m2^n)$。

我们注意到我们只关心 $a_i$ 的**相对大小关系**，即我们考虑对于 $a$ **离散化**，这样子就可以压缩 $x$ 至 $\Theta(n)$ 级别；而我们在统计答案时将其还原回去，得到答案为 $\sum\limits_{x=1}^n f_{U,x}{V\choose x}$，其中 $U=\{1,2,\cdots,n\}$。

这样子复杂度为 $\Theta(n3^n+m2^n)$。

注意到到复杂度瓶颈为 $n3^n$ 的枚举子集，此时我们套个高维前缀和即可通过此题，然而我不会高维前缀和，怎么办呢？

我们考虑某一次我从 $100011101$ 变成 $111011101$ 实际上是加上了一个 $011000000$，则我们不妨先加上一个 $010000000$ 作为**缓存**，然后再加上 $001000000$；需要特殊注意的是这时 $S$ 可以是非法的，但是当 $x=0$ 时 $S$ 必须合法，因为此时的 $S$ 相当于是原来我们**真正转移到的 $S$**。

即我们枚举一个 $i$，我们令 $f_{S,x}$ 转移到 $f_{S+\{i\},x}$，当 $S$ 是好的时，我们令 $f_{S,x}$ 转移到 $f_{S,x+1}$，前一步相当于缓存，后一步相当于结束缓存。

然而此时还有些问题，因为就以上述为例，我们可以先加 $001000000$ 再加 $010000000$ 与原来的操作是相同的，但是我们会多记一遍，所以我们要额外记录一维表示我们连续进行了几步缓存操作，表示为 $f_{S,x,k}$，则进行后一种转移时我们要乘上 $\frac{1}{k!}$ 的系数以消掉不同顺序转移的影响。

然后就做完了，复杂度 $\Theta((m+n^3)2^n)$。

## Code

```cpp
#include<bits/stdc++.h>
//#pragma GCC optimize(3,"Ofast","inline")
//#define int long long
#define i128 __int128
#define ll long long
#define ull unsigned long long
#define ld double
#define PII pair<int,int>
#define INF 0x3f3f3f3f
#define INFLL 0x3f3f3f3f3f3f3f3f
#define chkmax(a,b) a=max(a,b)
#define chkmin(a,b) a=min(a,b)
#define rep(k,l,r) for(int k=l;k<=r;++k)
#define per(k,r,l) for(int k=r;k>=l;--k)
#define cl(f,x) memset(f,x,sizeof(f))
using namespace std;
void file_IO() {
	freopen(".in","r",stdin);
	freopen(".out","w",stdout);
}
bool M1;
template<int p>
struct mint {
	int x;
	mint() {
		x=0;
	}
	mint(int _x) {
		x=_x;
	}
	friend mint operator + (mint a,mint b) {
		return a.x+b.x>=p? a.x+b.x-p:a.x+b.x;
	}
	friend mint operator - (mint a,mint b)  {
		return a.x<b.x? a.x-b.x+p:a.x-b.x;
	}
	friend mint operator * (mint a,mint b) {
		return 1ll*a.x*b.x%p;
	}
	friend mint operator ^ (mint a,ll b) {
		mint res=1,base=a;
		while(b) {
			if(b&1)
				res*=base;
			base*=base; b>>=1;
		}
		return res;
	}
	friend mint operator ~ (mint a) {
		return a^(p-2);
	}
	friend mint operator / (mint a,mint b) {
		return a*(~b);
	}
	friend mint & operator += (mint& a,mint b) {
		return a=a+b;
	}
	friend mint & operator -= (mint& a,mint b) {
		return a=a-b;
	}
	friend mint & operator *= (mint& a,mint b) {
		return a=a*b;
	}
	friend mint & operator /= (mint& a,mint b) {
		return a=a/b;
	}
	friend mint operator ++ (mint& a) {
		return a+=1;
	}
	friend mint operator -- (mint& a) {
		return a-=1;
	}
};
const int MOD=1e9+7;
#define mint mint<MOD>
const int S=1<<18,M=5e3+5,N=20;
mint f[S][N][N],inv_jc[N];
int n,V,m,p[M],q[M],a[N];
bool check(int S) {
	rep(i,0,n-1)
	a[i]=(S>>i)&1;
	rep(i,1,m) {
		if(a[p[i]]>a[q[i]])
			swap(a[p[i]],a[q[i]]);
	}
	rep(i,1,n-1) {
		if(a[i-1]>a[i])
			return false;
	}
	return true;
}
mint C(int n,int m) {
	mint res=1;
	per(i,n,n-m+1)
	res*=i;
	rep(i,1,m)
	res/=i;
	return res;
}
void solve() {
	scanf("%d%d%d",&n,&V,&m);
	inv_jc[0]=1;
	rep(i,1,n)
	inv_jc[i]=inv_jc[i-1]/mint(i);
	rep(i,1,m) {
		scanf("%d%d",&p[i],&q[i]);
		--p[i];
		--q[i];
	}
	f[0][0][0]=1;
	int U=(1<<n)-1;
	rep(S,0,U) {
		int c=__builtin_popcount(S);
		if(check(S)) {
			rep(i,0,c) {
				rep(k,1,c)
					f[S][i+1][0]+=f[S][i][k]*inv_jc[k];
			}			
		}
		rep(i,0,c) {
			rep(k,0,c) {
				if(!f[S][i][k].x)
					continue;
				rep(j,0,n-1) {
					if(!((S>>j)&1))
						f[S^(1<<j)][i][k+1]+=f[S][i][k];
				}					
			}
		}
	}
	mint res=0;
	rep(i,0,n)
	res+=f[U][i][0]*C(V,i);
	printf("%d\n",res.x);
}
bool M2;
signed main() {
	//file_IO();
	int testcase=1;
	//scanf("%d",&testcase);
	while(testcase--)
		solve();
	cerr<<"used time = "<<1000*clock()/CLOCKS_PER_SEC<<"ms\n";
	cerr<<"used memory = "<<(&M1-&M2)/1024/1024<<"MB\n";
	return 0;
}
```

---

## 作者：Cx114514 (赞：1)

### 题目链接：[【MX-S2-T4】换](https://www.luogu.com.cn/problem/P10813)

一道非常厉害的状压 DP。

重点在于这个 trick：

每次设定一个阈值 $p$，将序列中 $\le p$ 的设为 $0$，$> p$ 的设为 $1$，进行 $m$ 次操作。若对于 $1\le p\le V$ 操作后的序列均满足要求，则该序列满足要求。

证明：

若最终形成的序列不满足，则在操作结束后必然存在 $i<j$ 使得 $a_i>a_j$，若 $a_j\le k<a_i$，则此时操作后的序列必然存在 $a_i>a_j$，不符合条件。

不难预处理出所有 $01$ 序列最终是否满足条件，这部分时间复杂度为 $O\left(m2^n\right)$。

令 $g_{S}$ 表示 $S$ 这个 $01$ 序列最终是否满足条件，是为 $1$，否为 $0$；令 $f_{i,S}$ 表示当前 $k$ 是第 $i$ 大的数字，形成的 $01$ 序列 是 $S$ 的方案数。

随着 $k$ 的减小，$S$ 中 $1$ 的数量一定是不断增加的，因此 $S$ 是从它的所有子集转移过来的。

可以得到转移：

 $$f_{i,S} = g_{S} \times \sum\limits_{T\subset S}f_{i-1,T}$$ 

对于 $T$ 的求和类似于高维前缀和，转移时间复杂度为 $O\left(n^2 2^n\right)$。

令 $\mathbb{ALL}$ 表示全集。

最终的状态 $f_{i,\mathbb{ALL}}$ 表示的是序列中有 $i$ 个不同数字的答案，需要从 $V$ 种取值中选 $i$ 个，故最终答案为 $\sum\limits_{i=1}^{n}f_{i,\mathbb{ALL}} \times \binom{V}{i}$。

总时间复杂度为 $O\left(m2^n+n^22^n\right)$。

代码：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int mod = 1e9 + 7;

int n, V, m, ans, p[505], q[505], a[25], g[1000005], f[25][1000005], s[25][1000005];

int Qpow(int t, int p)
{
	int Ans = 1;
	while (p)
	{
		if (p & 1) Ans = (Ans * t) % mod;
		t = (t * t) % mod;
		p /= 2;
	}
	return Ans;
}

int C(int A, int B)
{
	if (B > A) return 0;
	int Ans = 1, inv = 1;
	for (int i = 1; i <= B; i++)	
	{
		Ans = Ans * (A - i + 1) % mod;
		inv = inv * i % mod;
	}
	return Ans * Qpow(inv, mod - 2) % mod;
}

signed main()
{
	cin >> n >> V >> m;
	for (int i = 1; i <= m; i++)
		cin >> p[i] >> q[i];
	for (int i = 0; i < (1 << n); i++)
	{
		for (int j = 1; j <= n; j++)
			a[j] = 1 & (i >> (j - 1));
		for (int j = 1; j <= m; j++)
			if (a[p[j]] > a[q[j]]) swap(a[p[j]], a[q[j]]);
		g[i] = 1;
		for (int j = 1; j < n; j++)
			g[i] = g[i] & (a[j] <= a[j + 1]);
	}
	f[0][0] = g[0];
	for (int i = 1; i <= n; i++)
	{
		for (int j = 0; j < (1 << n); j++)
			s[i - 1][j] = f[i - 1][j];
		for (int j = 1; j <= n; j++)
			for (int k = 0; k < (1 << n); k++)
				if (k & (1 << (j - 1))) s[i - 1][k] = (s[i - 1][k] + s[i - 1][k - (1 << (j - 1))]) % mod;
		for (int j = 0; j < (1 << n); j++)
			if (g[j]) f[i][j] = (s[i - 1][j] - f[i - 1][j] + mod) % mod;
	}
	for (int i = 1; i <= n; i++)
		ans = (ans + C(V, i) * f[i][(1 << n) - 1]) % mod;
	cout << ans << endl;
	return 0;
}
```

---

## 作者：DaiRuiChen007 (赞：1)

[Problem Link](https://www.luogu.com.cn/problem/P10813)

**题目大意**

> 给定 $m$ 个操作 $(p_i,q_i)$，如果序列 $a$ 满足 $a_{p_i}>a_{q_i}$ 就交换两个元素，求有多少长度为 $n$，值域为 $[1,V]$ 的 $a$ 顺次进行 $m$ 个操作后单调不降。
>
> 数据范围：$n\le 18,m\le 200,V\le 10^{9}$。

**思路分析**

考虑 01 分界，即选定一个 $x$，定义 $S=\{i\mid a_i\ge x\}$，那么对于每个 $S$，我们倒序维护进行操作 $[x,m]$ 后能升序排列的所有 $S$，这部分复杂度 $\mathcal O(m2^n)$。

然后考虑一个 $a_i$，一组 $a_i$ 从随着 $x$ 逐渐增加，可以看成一条从 $\varnothing$ 变化到全集的路径，每次当前集合增加如若干 $=x$ 的元素，我们只要对这样的路径计数。

注意到我们只关心 $a_i$ 中本质不同的颜色数，那么考虑每次加入一种最大的颜色，就会把当前的 $S$ 转移到 $S$ 的一个合法超集上，可以 FWT 解决。

全集的方案数即为合法序列数，乘一个选颜色的组合数即可。

时间复杂度 $\mathcal O((m+n^2)2^n)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MOD=1e9+7;
ll ksm(ll a,ll b=MOD-2) { ll s=1; for(;b;a=a*a%MOD,b>>=1) if(b&1) s=s*a%MOD; return s; }
bool ok[1<<18],tk[1<<18];
int f[1<<18],g[1<<18];
void add(int &x,int y) { x=(x+y>=MOD)?x+y-MOD:x+y; }
void sub(int &x,int y) { x=(x>=y)?x-y:x+MOD-y; }
ll C(int x,int y) {
	ll s=1;
	for(int i=1;i<=y;++i) s=s*ksm(i)%MOD*(x-i+1)%MOD;
	return s;
}
signed main() {
	int n,V,m;
	scanf("%d%d%d",&n,&V,&m);
	vector <array<int,2>> opr(m);
	for(auto&z:opr) scanf("%d%d",&z[0],&z[1]);
	reverse(opr.begin(),opr.end());
	ok[0]=true;
	for(int i=1;i<=n;++i) ok[((1<<i)-1)<<(n-i)]=true;
	for(auto z:opr) {
		int u=z[0]-1,v=z[1]-1;
		if(u==v) continue;
		memset(tk,0,sizeof(tk));
		for(int s=0;s<(1<<n);++s) {
			int x=s>>u&1,y=s>>v&1;
			tk[s]=x>y?ok[s^(1<<u)^(1<<v)]:ok[s];
		}
		memcpy(ok,tk,sizeof(ok));
	}
	f[0]=1;
	ll ans=0;
	for(int c=1;c<=n&&c<=V;++c) {
		memcpy(g,f,sizeof(g));
		for(int i=0;i<n;++i) for(int s=0;s<(1<<n);++s) if(s>>i&1) add(f[s],f[s^(1<<i)]);
		for(int s=0;s<(1<<n);++s) {
			if(!ok[s]) f[s]=0;
			else sub(f[s],g[s]);
		}
		ans=(ans+C(V,c)*f[(1<<n)-1])%MOD;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：TernaryTree (赞：1)

区分了做过 ARC160F 和没做过的选手，还好我做过。

经典的 trick 是，将原序列看做 $n$ 个 $01$ 序列，如果每个 $01$ 序列都满足条件那么原序列满足条件。$01$ 序列只有 $2^n$ 个，暴力处理出来满足条件的。

然后我们就得到了一个路径计数状物。具体地，我们要计算全集 $U$ 到 $0$ 的某个长度 $i$ 的路径数，其中一个合法集合向一个合法真子集连边，然后乘上 $\dbinom{V}i$ 的系数求和即可。有显然的 dp：

$$f_{i,S}=[S \text{ is valid}]\sum_{T\subsetneq S} f_{i-1, T}$$

这就是高维前缀和板子了，总复杂度 $\Theta((n^2+m)2^n)$。

```cpp
#include <bits/stdc++.h>
#define int long long
#define fs first
#define sc second
#define ls (u << 1)
#define rs (u << 1 | 1)
#define mid ((l + r) >> 1)
#define lc ls, l, mid
#define rc rs, mid + 1, r
#define rep(i, l, r) for (int i = (l); i <= (r); ++i)
#define per(i, r, l) for (int i = (r); i >= (l); --i)
#define gc getchar
#define pc putchar

using namespace std;
using pii = pair<int, int>;
using vi = vector<int>;

const int maxn = 18;
const int maxm = 5e2 + 10;
const int mod = 1e9 + 7;
const bool multidata = 0;

template<typename T = int>
T read() {
	T x = 0, f = 1; char c = gc();
	while (c < '0' || c > '9') { if (c == '-') f = -f; c = gc(); }
	while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = gc();
	return x * f;
}

template<typename T = int>
void write(T x) {
	if (x < 0) pc('-'), x = -x;
	if (x < 10) return void (pc(x + '0'));
	write<T>(x / 10), pc(x % 10 + '0');
}

int n, V, m, ans;
pii e[maxm];
int v[1 << maxn];
int f[maxn + 1][1 << maxn], g[maxn + 1][1 << maxn];
int C[maxn + 1];

int power(int a, int b, int p = mod) {
	int t = 1; a %= p;
	while (b) {
		if (b & 1) t = t * a % p;
		a = a * a % p, b >>= 1;
	}
	return t;
}

void fake_main() {
	n = read(), V = read(), m = read();
	rep(i, 1, m) e[i].fs = read() - 1, e[i].sc = read() - 1;
	C[0] = 1; 
	rep(i, 1, n) C[i] = C[i - 1] * (V - i + 1) % mod * power(i, mod - 2) % mod;
	rep(i, 0, (1 << n) - 1) {
		int s = i;
		rep(j, 1, m) {
			int u = e[j].fs, v = e[j].sc;
			if ((s >> u & 1) && !(s >> v & 1)) s ^= (1 << u) ^ (1 << v); 
		}
		if (!s || (s + (s & -s)) == (1 << n)) v[i] = 1;
	}
	f[0][0] = 1;
	rep(i, 1, n) {
		rep(s, 0, (1 << n) - 1) g[i - 1][s] = f[i - 1][s];
		rep(j, 0, n - 1) rep(s, 0, (1 << n) - 1) if (s >> j & 1) (g[i - 1][s] += g[i - 1][s ^ (1 << j)]) %= mod;
		rep(s, 0, (1 << n) - 1) f[i][s] = v[s] * (g[i - 1][s] - f[i - 1][s] + mod) % mod;
		(ans += f[i][(1 << n) - 1] * C[i] % mod) %= mod;
	}
	write(ans);
}

signed main() {
	int T = multidata ? read() : 1;
	while (T--) fake_main();
	return 0;
}
```

---

## 作者：tobie (赞：1)

- 和 [ARC160F](https://www.luogu.com.cn/problem/AT_arc160_f) 异曲同工。

弱化：如果 $a$ 序列内的所有数只有 $0$ 和 $1$ 就是笨蛋题，直接暴力枚举所有可能情况然后模拟判断即可。

那考虑对 $a$ 序列离散化后对值域扫描线，假设当前扫到 $x$，那么将数组中所有小于 $x$ 的数标记为 $0$，剩下的标记为 $1$。那么最开始所有数都是 $0$，然后每次 $x$ 变化时都会有若干 $0$ 变成 $1$。所以一个“变化序列”可以对应一个唯一的 $a$ 数组内部大小关系。

那如何判断 $a$ 数组合法呢？你发现变化序列是一个 $01$ 序列，所以 $a$ 数组合法等价于变化序列的所有时刻都能完成题目描述中的排序操作。而这就是上文所述的弱化版。

考虑对变化序列进行状压 dp：$dp_{i,S}$ 表示当前变化了 $i$ 次，此时的 $01$ 序列为 $S$ 的方案数。那么有转移 $dp_{i,S}\rightarrow dp_{i+1,T}$，其中 $S\subseteq T$。

直接转移是 $O(n3^n)$ 的，可以使用高维前缀和的技巧优化到 $O(n^22^n)$。

我们发现 dp 状态中的 $i$ 恰好对应了 $a$ 数组中不同数字的个数，而所有数字的大小关系已经确定，所以答案就是 $\sum \binom{V} i dp_{i,\{1,1,\cdots,1\}}$。

以下是代码

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
#define int long long
const int N=18,M=509,mod=1e9+7;
int n,V,m;
int p[M],q[M];
int pd[1<<N],dp[N+2][1<<N];
int fz[N+2];
bool check(int x)
{
	for(int i=0;i<n;i++) fz[i]=((x>>i)&1);
	for(int i=1;i<=m;i++)
	if(fz[p[i]]>fz[q[i]]) swap(fz[p[i]],fz[q[i]]);
	for(int i=1;i<n;i++)
	if(fz[i]==0&&fz[i-1]==1) return 0;
	return 1;
}
int ksm(int x,int y){int z=1;for(;y;x=x*x%mod,y>>=1) if(y&1) z=z*x%mod;return z;}
int C(int x,int y)
{
	if(x<y||y<0) return 0;
	int ans=1;
	for(int i=x;i>=x-y+1;i--) ans=ans*i%mod;
	for(int i=1;i<=y;i++) ans=ans*ksm(i,mod-2)%mod;
	return ans;
}
signed main()
{
	scanf("%lld%lld%lld",&n,&V,&m);
	for(int i=1;i<=m;i++) scanf("%lld%lld",&p[i],&q[i]),p[i]--,q[i]--;
	for(int i=0;i<(1<<n);i++) pd[i]=check(i);
	dp[0][0]=1;
	int ans=0;
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<(1<<n);j++) dp[i][j]=dp[i-1][j];
		for(int k=0;k<n;k++)
		for(int j=0;j<(1<<n);j++)
		if(!((j>>k)&1)) (dp[i][j|(1<<k)]+=dp[i][j])%=mod;
		for(int j=0;j<(1<<n);j++) (dp[i][j]+=mod-dp[i-1][j])%=mod;
		for(int j=0;j<(1<<n);j++) if(!pd[j]) dp[i][j]=0;
		(ans+=C(V,i)*dp[i][(1<<n)-1]%mod)%=mod;
	}
	printf("%lld\n",ans);
}
```

---

## 作者：251Sec (赞：1)

没打这场比赛，赛后看了眼这个题，欸我怎么秒了。现在 S T4 都这么简单了吗。

也许是双倍经验：ARC160F。

---

考虑如何刻画一个数列是否能被排序。不妨取一个阈值 $x$，判断是否最终所有 $> x$ 的数都在 $\le x$ 的数右边。只要对于所有 $x \in [0,V]$ 都满足条件，那么这个序列就是排好序的。

我们对于所有 $x$，令 $>x$ 的数为 $1$，$\le x$ 的数为 $0$，这样就把一个数列映射到了若干 $01$ 串 $s_{0..V}$。其中 $s_0$ 为 $n$ 个 $1$，$s_V$ 为 $n$ 个 $0$，且 $s_{i}$ 由 $s_{i-1}$ 把若干（可能零个） $1$ 修改成 $0$ 得到。可以发现满足这几个条件的 $s_{0..V}$ 都可以映射回唯一的原数列。一个数列能被排序当且仅当所有这些 $01$ 串都能被排序。

我们可以暴力 $O(2^nm)$ 求出每个 $01$ 串是否能被排序。现在问题变成了对合法的 $s_{0..V}$ 计数。因为 $s_0$ 是固定的，所以方便起见下面直接对 $s_{1..V}$ 计数。

发现对于一个 $s_{1..V}$，其中不同的 $01$ 串只有不超过 $n$ 个。想到设 DP $f(i,j)$ 为，钦定 $s$ 序列互不相同，当前序列末尾的 $01$ 串为 $i$，目前序列里有 $j$ 个 $01$ 串的方案数。只要求出这个就容易用组合数计算最终答案。

暴力求 $f$ 是 $O(3^nn)$ 的。发现瓶颈实际上在于求子集和，于是直接上高维前缀和就变成 $O(2^nn^2)$ 了。总复杂度 $O(2^nm+2^nn^2)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int P = 1e9 + 7;
int n, m, V, g[300005];
ll f[20][300005], tf[300005];
void FWT(ll *a, int tp) {
	for (int w = 1; w < (1 << n); w <<= 1) {
		for (int i = 0; i < (1 << n); i += (w << 1)) {
			for (int j = 0; j < w; j++) {
				ll x = a[i + j], y = a[i + j + w];
				a[i + j + w] = (x * tp + y + P) % P;
			}
		}
	}
}
bool IsSorted(int i) {
	int c = n - __builtin_popcount(i);
	for (int j = 0; j < c; j++) if (g[i] >> j & 1) return false;
	return true;
}
ll QPow(ll a, ll b) {
	ll res = 1;
	for (; b; b >>= 1, a = a * a % P) if (b & 1) res = res * a % P;
	return res;
}
ll iv[20];
ll C(int x) {
	ll res = 1;
	for (int i = V; i >= V - x + 1; i--) res = res * i % P;
	return res * iv[x] % P;
}
int main() {
	scanf("%d%d%d", &n, &V, &m);
	iv[0] = 1;
	for (int i = 1; i <= n; i++) iv[i] = iv[i - 1] * QPow(i, P - 2) % P;
	for (int i = 0; i < (1 << n); i++) g[i] = i;
	while (m--) {
		int p, q; scanf("%d%d", &p, &q);
		p--, q--;
		for (int i = 0; i < (1 << n); i++) {
			if ((g[i] >> p & 1) && !(g[i] >> q & 1)) g[i] ^= (1 << p) | (1 << q);
		}
	}
	f[0][0] = 1;
	for (int i = 1; i <= n; i++) {
		memcpy(tf, f[i - 1], sizeof(tf));
		FWT(tf, 1);
		for (int j = 0; j < (1 << n); j++) {
			if (!IsSorted(j)) continue;
			f[i][j] = (tf[j] - f[i - 1][j] + P) % P;
		}
	}
	ll ans = 0;
	for (int i = 1; i <= n; i++) ans += C(i) * f[i][(1 << n) - 1] % P;
	printf("%lld\n", ans % P);
	return 0;
}
```

---

## 作者：sunset_breeze (赞：0)

好题。

首先有个 trick：每次设定一个阈值 $t$，将序列中 $≤t$ 的设为 $0$，$>t$ 的设为 $1$，进行 $m$ 次操作。若对于 $1≤t≤V$ 操作后的序列均满足要求，则该序列满足要求。

证明用反证法即可。

那么如果本题的值域范围是 $[0,1]$ 时怎么做？注意到 $n\le 18$，也就是说不同的 $01$ 序列一共只有 $2^n$ 个。那么我们枚举这些 $01$ 序列，设一个 $01$ 序列的状态为 $S$，并且记 $flag_S$ 表示 $S$ 所代表的 $01$ 序列是否合法，那么每个序列用 $\mathcal O(m)$ 的时间复杂度去检查，如果最终是合法序列，那么令 $flag_{S}$ 为 $1$，否则为 $0$。综上预处理的时间复杂度就是 $\mathcal O(m2^n)$。

现在考虑将 $01$ 序列转化为值域在 $[1,V]$ 的序列，一个很 naive 的想法就是我们**从大到小**依次枚举 $[1,V]$ 中的每一个权值 $x$，把 $\ge x$ 的数设为 $1$，把 $<x$ 的数设为 $0$，最后根据预处理出的信息看是否满足条件，时间复杂度为 $\mathcal O(nV2^n)$。

优化思路也很明显，因为我们转移时有很多转移都是无用功，很有可能 $x$ 变为 $x-1$ 时整个序列的大小情况并没有变化，即整个序列关于 $x$ 所形成的 $01$ 序列和 $x-1$ 所形成的 $01$ 序列**是一样的**。

也就是设 $f_{i,S}$ 表示**按照权值顺序从大到小考虑整个序列**，当前已经考虑了序列中的**前 $i$ 大的数**，并且 $x<i-1$ 的数都满足条件，考虑当前 $i$ 这个数，所形成的 $01$ 序列为 $S$，此时的**方案数**。

转移为：
$$
f_{i,j}=
\begin{cases}
0,j\not\in S\\
\sum_{k}f_{i-1,k},j\in S
\end{cases}
$$

其中，$S$ 表示可以被排成有序的 0-1 序列的压缩状态的集合，$k$ 表示 $j$ 的二进制表示的一个真子集。注意，因为 $a'$ 是离散化后的序列，所以元素的值域是连续的，一旦 $t$ 变化，则 $b$ 一定也要变化，**故 $k$ 不能等于 $j$**，否则带来的后果就是你算出来的是值域 $\le t$ 的序列个数，**不方便后面的统计答案**。

若直接枚举子集，总体复杂度复杂度是 $\mathcal O(n3^n)$，接受不了。考虑使用**高维前缀和**，将每个二进制位视为一维，分别对每一维作前缀和处理，这样最后得到的就是某个状态的子集了。

高维前缀和预处理复杂度 $\mathcal O(n2^n)$，故总体复杂度 $\mathcal O(n^22^n)$。

最后一步就是怎么统计答案：对于值域在为 $[1,k]$ 的 $a'$，共有 $f_{k,2^n-1}$ 种。因为我们按照值域从大到小的顺序依次考虑，先考虑值为 $k$ 的位置，再考虑值为 $k-1$ 的位置，$k-2$ 的位置，$k-3$ 的位置……这样一个序列的 $01$ 序列一定是由原来的全 $0$ 序列变为最后的全 $1$ 序列，所以对于值域在 $[1,k]$ 的序列，它的合法个数就是 $f_{k,2^n-1}$。

那么如果我们求的是最终值域种类数为 $k$ 的合法序列个数呢？

我们可以将其中的每个元素 $i$，对应映射到某个值 $v_i$ 上，满足 $1\le v_1<v_2<\dots<v_k\le V$。这样，每一组 $\{v_i\}$，都构建了一个从 $a'$ 到 $a$ 的双射。由排列组合知识知，这样的 $\{v_i\}$ 有 $\binom{V}{k}$ 种。

所以，最终答案为：

$$\sum_{k=1}^n\binom{V}{k}f_{k,2^n-1}$$

这部分计算时间为 $\mathcal O(n^2)$。

所以总复杂度为 $\mathcal O(n^2 2^n+m 2^n)$。

代码：

```cpp
#include<bits/stdc++.h>
#define pi pair<int,int>
#define fi first
#define sd second
#define mk make_pair
#define endl '\n'
#define pb push_back
#define int long long
typedef long long ll;
using namespace std;
namespace fast_IO{
static unsigned int precision=6,POW[10]={1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000};static char obuf[100000],*p3=obuf;
#ifdef ONLINE_JUDGE
static char ibuf[100000],*p1=ibuf,*p2=ibuf;
#define getchar()((p1==p2)&&(p2=(p1=ibuf)+fread(ibuf,1,100000,stdin),p1==p2)?(EOF):(*p1++))
#endif
#define putchar(x)((p3==obuf+100000)&&(fwrite(obuf,p3-obuf,1,stdout),p3=obuf),*p3++=x)
inline int64_t read(){int64_t s=0;int w=1;char ch;while(ch=getchar(),!(ch>47&&ch<58)&&(ch!=EOF))if(ch=='-')w=-1;if(ch==EOF)return 0;while((ch>47&&ch<58))s=s*10+ch-48,ch=getchar();return s*w;}template<typename T>static inline bool read(T&s){s=0;int w=1;char ch;while(ch=getchar(),!(ch>47&&ch<58)&&(ch!=EOF))if(ch=='-')w=-1;if(ch==EOF)return 0;while((ch>47&&ch<58))s=s*10+ch-48,ch=getchar();return s*=w,1;}template<typename T>static inline void print(T x){if(x<0)putchar('-'),x=-x;if(x>9)print(x/10);putchar(x%10+48);}static inline bool read(char&s){while(s=getchar(),isspace(s)&&s!=EOF);return s!=EOF;}static inline void print(char x){putchar(x);}static inline bool read(char*s){char ch;while(ch=getchar(),(ch<33)&&ch!=EOF);if(ch==EOF)return 0;while(!(ch<33)&&(ch!=EOF))*s++=ch,ch=getchar();*s='\0';return 1;}static inline void print(char*x){while(*x)putchar(*x++);}static inline void print(const char*x){for(int i=0;x[i];i++)putchar(x[i]);}static inline bool read(std::string&s){s="";char ch;while(ch=getchar(),(ch<33)&&ch!=EOF);if(ch==EOF)return 0;while(!(ch<33))s+=ch,ch=getchar();return 1;}static inline void print(std::string x){for(int i=0,n=x.size();i<n;i++)putchar(x[i]);}static inline bool read(bool&b){char ch;while(ch=getchar(),(ch<33)&&ch!=EOF);return ch==EOF?0:(b=ch^48,1);}static inline void print(bool b){putchar(b+48);}static inline bool read(double&x){char ch=getchar();int f=1;for(;(ch<48||57<ch)&&(ch!=EOF);ch=getchar())if(ch=='-')f=-1;if(ch==EOF)return 0;for(x=0;47<ch&&ch<58;ch=getchar())x=x*10+(ch^48);if(ch!='.')return x*=f,1;double y=0.1;for(ch=getchar();47<ch&&ch<58;ch=getchar())x+=y*(ch^48),y/=10;return x*=f,1;}static inline void print(double x){if(x<0)putchar('-'),x=-x;if(!precision)print((unsigned long long)(x-(unsigned long long)(x)>=0.5?x+1:x));else{unsigned long long xx=x;double y=((x-xx)*POW[precision]);unsigned long long yy=(y-(unsigned long long)(y)>=0.5?y+1:y);if(yy==POW[precision])xx++,yy=0;print(xx),putchar('.');for(int j=precision-1;~j;j--)putchar(48+yy/POW[j]%10);}}template<typename T,typename...T1>static inline int read(T&a,T1&...other){return read(a)+read(other...);}template<typename T,typename...T1>static inline void print(T a,T1...other){print(a),print(other...);}static struct Fast_IO{bool flag=1;inline~Fast_IO(){fwrite(obuf,p3-obuf,1,stdout);}inline void SetPrecision(int x){if(x>9)throw runtime_error("Precision too high!");else if(x<0)throw runtime_error("Precision too low!");else precision=x;}inline operator bool(){return flag;}}io;static Fast_IO&operator>>(Fast_IO&io,char*b){return io.flag&=read(b),io;}template<typename T>static Fast_IO&operator>>(Fast_IO&io,T&b){return io.flag&=read(b),io;}template<typename T>static Fast_IO&operator<<(Fast_IO&io,T b){return print(b),io;}
#define cout io
#define cin io
#define endl '\n'
}using namespace fast_IO;
const int N=20,M=550,inf=2e9,mod=1e9+7;
int qpow(int a,int b)
{
	int res=1;
	while(b)
	{
		if(b&1)res=res*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return res;
}
int cas;
int n,V,m,all,ans;
int b[M],p[M],q[M],f[1<<N],dp[N][1<<N];
bool flag[1<<N];
int C(int n,int m)
{
	if(n<m||m<0)return 0;
	int res=1,tmp=1;
	for(int i=V;i>=V-m+1;i--)res=res*i%mod;
	for(int i=1;i<=m;i++)tmp=tmp*i%mod;
	return res*qpow(tmp,mod-2)%mod;
}
void solve()
{
	cin>>n>>V>>m;all=(1<<n)-1;
	for(int i=1;i<=m;i++)
	{
		cin>>p[i]>>q[i];
		p[i]--;q[i]--;
	}
	for(int i=0;i<=all;i++)
	{
		for(int j=0;j<=n-1;j++)b[j]=(i>>j)&1;
		for(int j=1;j<=m;j++)if(b[p[j]]>b[q[j]])swap(b[p[j]],b[q[j]]);
		flag[i]=1;
		for(int j=1;j<=n-1;j++)flag[i]&=(b[j]>=b[j-1]);
	}
	dp[0][0]=1;
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<=all;j++)f[j]=dp[i-1][j];
		for(int j=0;j<=n-1;j++)
			for(int k=0;k<=all;k++)if((k>>j)&1)f[k]=(f[k^(1<<j)]+f[k])%mod;
		for(int j=0;j<=all;j++)
		{
			if(flag[j]==0)dp[i][j]=0;
			else dp[i][j]=((f[j]-dp[i-1][j])%mod+mod)%mod;
		}
	}
	for(int i=1;i<=n;i++)
		ans=(ans+dp[i][(1<<n)-1]*C(V,i)%mod)%mod;
	cout<<ans<<endl;
}
signed main()
{
	cas=1;
	while(cas--)solve();
	return 0;
}
```

---

## 作者：xuyiyang (赞：0)

### [P10813 【MX-S2-T4】换](https://www.luogu.com.cn/problem/P10813)
### Solution
首先有个 trick：对于排序可行性问题，可以将问题转化。设一个阈值 $B$，令 $b_i=[a_i \ge B]$，则若 $b$ 数组按规则排序后不成立，则 $a$ 也一定不成立。若
$B$ 取任意数时 $b$ 一定成立，则 $a$ 一定成立。$\\$
所以本题就将值域压缩为了 $0/1$ 序列。对 $a$ 离散化，则将原值域压成 $\mathcal O(n)$，令 $f_{S,i}$ 表示令 $B=i$ 时 $b$ 序列为 $S$（此时 $i$ 就是 $a$ 不同数字个数），且当阈值小于等于 $i$ 时 $b$ 按规则排序都成立的方案数。则有转移：
$$f_{S,i} = \begin{cases} 0 & \text{S not vaild} \\ \sum \limits _ {T \subseteq S}f_{T,i-1} & \text{otherwise}\end{cases}$$
注意这里由于 $B$ 变化且 $a$ 离散化后一定会改变 $b$，所以 $T\not=S$。$\\$
对于计算答案，枚举离散化后 $a$ 的值域，即 $i$。则有 $\binom{V}{i}$ 中方案。答案即为： 
$$\sum \limits _ {i = 1} ^ n \binom{V}{i}f_{2^n-1,i}$$ 
判断是否合法预处理，然后就有了 $\mathcal O(n3^n)$ 的暴力枚举子集 DP。优化就套个高维前缀和上去即可做到 $\mathcal O(n^22^n)$。于是就做完了。
```cpp
int main() {
	scanf("%d%d%d", &n, &V, &m);
	for (int i = 1; i <= m; i ++ ) scanf("%d%d", &p[i], &q[i]), p[i] -- , q[i] -- ;	
	auto chk = [&](int S) {
		for (int i = 1; i <= m; i ++ ) {
			int x = S >> p[i] & 1, y = S >> q[i] & 1;
			if (x > y) {
				S -= (1 << p[i]) * x; S -= (1 << q[i]) * y;
				S += (1 << p[i]) * y; S += (1 << q[i]) * x;
			}
		} 
		for (int i = 0; i < n - 1; i ++ ) if ((S >> (i + 1) & 1) < (S >> i & 1)) return 0;
		return 1; 
	}; for (int i = 0; i < 1 << n; i ++ ) st[i] = chk(i);
	f[0][0] = 1;
	for (int i = 1; i <= n; i ++ ) {
		for (int j = 0; j < (1 << n); j ++ ) f[i][j] = f[i - 1][j];
		for (int k = 0; k < n; k ++ ) for (int j = 0; j < (1 << n); j ++ ) 
			if (!(j >> k & 1)) (f[i][j | (1 << k)] += f[i][j]) %= mod;
		for (int j = 0; j < (1 << n); j ++ ) if (!st[j]) f[i][j] = 0; else f[i][j] = (f[i][j] - f[i - 1][j] + mod) % mod;
	}
	auto inv = [&](int x) {
		int y = mod - 2, res = 1;
		while (y) {
			if (y & 1) res = (LL)res * x % mod;
			y >>= 1; x = (LL)x * x % mod;
		} return res;
	}; int res = 0;
	for (int i = 1; i <= n; i ++ ) {
		int binom = 1; for (int j = V; j >= V - i + 1; j -- ) binom = (LL)binom * j % mod;
		for (int j = 1; j <= i; j ++ ) binom = (LL)binom * inv(j) % mod;
		res = (res + (LL)binom * f[i][(1 << n) - 1] % mod) % mod;
	} printf("%d\n", res); return 0;
}
```

---


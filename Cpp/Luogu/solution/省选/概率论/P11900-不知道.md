# 不知道

## 题目背景

不知道，令人闻风丧胆的猫猫魔，福尔魔斯的宿敌。

某一天，她在网上看到了一道小学奥数问题：约瑟夫问题。

## 题目描述

不知道又要作案了。她让 $n$ 只猫猫站成一行，从左到右初始编号为 $1,2,\dots,n$。同时，它们初始站在与自己编号相同的格子上。

不知道有 $k+1$ 个喜欢的数字 $t_0,t_1,\dots,t_k$ 。它们满足：  
- $t_0=1$ 
- 对于 $1\le i\le k$ , $t_{i-1}<t_i$ 
- $t_k\le n$

不知道会摸 $n-1$ 轮猫猫，每一轮她都会摸正好一只猫猫。一次摸猫猫遵循以下规则：  
1. 从 $0$ 到 $k$ 中随机选择一个数 $i$ 。
1. 若有猫猫现在待在第 $t_i$ 格上，不知道会摸摸这个猫猫，随后这个猫猫将会跑出格子，不再参与后续的任何流程，然后进行第三步；否则回到第一步。
1. 让所有猫猫跑到新的格子上。若此时有 $p$ 只猫猫，它们会在保证相对顺序不变的情况下排到 $[1,p]$ 的格子上。

但是虽然猫猫很可爱，猫猫和不知道都是会厌烦的，所以当只剩一只猫猫时，不知道会停止摸猫猫。请求出每只猫猫最终没被摸的概率。
 
最终答案对 $998244353$ 取模。

## 说明/提示

#### 样例解释：
在第一组样例中，不知道只喜欢 $1$ 这个数字，因此她每次一定会摸当前的第一只猫猫，那么第一只猫猫一定会被摸，第二只猫猫一定不会被摸。  

第二组样例中，四只猫猫从左到右不被摸的概率分别为 $0,\frac{1}{4},\frac{1}{4},\frac{1}{2}$ 。

#### 数据范围：

**本题采用捆绑测试。**

对所有数据，保证 $1\le n,k\le10^6$ ； $t_i$ 范围见上。

|  #   |       特殊性质        | 分值 |
| :--: | :-------------------: | :--: |
|  0   | $n\le 8$ |  10  |
|  1   | $k=0$ |  5  |
|  2   | $k=1$ |  10  |
|  3   | $n\le5\times10^3$ |  15  |
|  4   | $k\le 10$ |  15  |
|  5   | $n\le2\times10^5$ |  20  |
|  6   | 无特殊限制 |  25  |

后记：  
花生：话说不知道本名叫什么   
福尔魔斯：不知道，所以叫不知道  
花生：？

## 样例 #1

### 输入

```
2 0
```

### 输出

```
0 1 
```

## 样例 #2

### 输入

```
4 1 
3 
```

### 输出

```
0 748683265 748683265 499122177 
```

## 样例 #3

### 输入

```
8 3 
3 6 8 
```

### 输出

```
0 291154603 291154603 582309206 166374059 166374059 748683265 748683265 
```

# 题解

## 作者：FLY_lai (赞：5)

（下称不知道喜欢的格子为喵格）  
首先，考虑一个子情况： $k=0$ ，此时，容易发现每次都是当前位于第一格的猫被摸，即最后一格的猫必定没摸。  
也可以发现在 $k$ 更大的情况下，随着猫数的减少，被启用的喵格实际上是在不断减少的，在猫数少于 $t_1$ 个时，相当于退化成了 $k=0$ 的情况，即对所有猫，不被摸的条件是：  
- 在猫数少于 $t_1$ 个时，自身位于所有猫中编号最大的一格。

以原题中样例 #3 为例。  
先看第 $8$ 只猫，它在所有猫中格子编号永远是最大的，因而它只需要等到场上只剩 $t_1-1=2$ 只猫为止便会不被摸。  
考虑猫怎么样会被摸。很明显，当且仅当它在一个喵格上，且被抽中，它才会被摸。同时由于我们讨论的是 $8$ 号不被摸的概率，当 $8$ 号不在喵格上时，谁被摸其实都是无所谓的（反正不是 $8$ 号，对 $8$ 号的不被摸概率没有影响），从结果上看只是把 $8$ 号往前推了一格。  
如果 $8$ 号能留到只剩 $2$ 只猫，它一定会经过所有喵格一次（除了 $t_0$）。容易发现，若是 $8$ 号没被摸，由于它后面不可能有猫了，它后面的喵格一定没有被启用；即令它及它前面的喵格个数为 $v_i$ ，则：
- 若 $8$ 号站在喵格上，它在这格上被摸的概率是 $\frac{v_i-1}{v_i}$ 。

再由于它会经过 $t_1\sim t_3$ 三个喵格，它在三个喵格上都不被摸下来的概率是 $\frac{3}{4}\times\frac{2}{3}\times\frac{1}{2}=\frac{1}{4}$ 。  
这个结论明显是可以推广的：  
- 第 $n$ 个猫不被摸的概率是 $\frac{1}{k+1}$ 。

说明一下为什么。首先可以发现，在每次第 $n$ 个猫站在喵格上时，它及它前面的喵格个数一定是正好比上次少了一个的，根据上面的公式推一下便可以得到这个结论。  

再来看第 $7$ 个猫。它的不被摸条件有所变更：等到只剩两个猫自然是前提，但由于它不是最后一个猫，可能它在等到最后两个猫时不是最后一个猫，因此它后面的猫还要全部被摸才行。  
它等到只剩最后 $2$ 个猫的概率和上面算法一样，不被摸的概率是 $\frac{1}{3}$ ；问题是 $8$ 号被摸的概率。它一直等过它及它前面的三个喵格的概率是 $\frac{1}{4}$ ，那么它在这三个喵格中的一个被摸的概率便是 $1-\frac{1}{4}=\frac{3}{4}$ 。那么 $7$ 号不被摸下来的概率便是 $\frac{1}{3}\times\frac{3}{4}=\frac{1}{4}$ 。  
不过在喵格相邻的情况下，可能存在非最后一个猫的后面的喵格仍启用的问题。其实这也是没有影响的，因为对一个猫本身撑过某个喵格的概率来说，要么就是这个猫在这里被摸，要么就是它离开这个格子。而若是它身后的喵格被启用，其实对这个猫相当于这次什么都没发生，同时下一次这两种情况的比例还是相同的，因此从结果上看仍是一样的。  
在 $6$ 号身上便好套用了：它通过前两个喵格的概率是 $\frac{1}{3}$ ，后面两个猫被摸的概率分别是 $\frac{2}{3}$ 与 $\frac{3}{4}$ ，概率便是 $\frac{1}{6}$ 。  
然而为什么对于 $7$ 号套用的不是用 $1$ 减去它的不被摸概率 $\frac{1}{4}$ 呢？因为在 $7$ 号算的是它不被摸且 $8$ 号被摸的概率，而在 $6$ 号的计算中只需计算 $7$ 号被摸的概率即可，不需要让 $8$ 号再被摸一次。  
那么通用公式便可以被推出来了：仍令 $v_i$ 为第 $i$ 格及其前面的喵格数量，同时令 $p_i$ 为 $i$ 号不被摸的概率，则：
-  $p_i=\frac{1}{v_i}\times\prod_{j=i+1}^{n}\frac{v_j-1}{v_j}$
  
由定义可发现 $v_1=1$ 。  
同时再顺便说明一下为何 $\sum p_i=1$ 。不如用一个较小的例子（ $n=3$ ）来演示为什么 $\sum p_i=1$ ：  
$
\begin{aligned}  
\sum p_i&=\frac{1}{v_1}\times\frac{v_2-1}{v_2}\times\frac{v_3-1}{v_3}+\frac{1}{v_2}\times\frac{v_3-1}{v_3}+\frac{1}{v_3}\\
&=\frac{v_2-1}{v_2}\times\frac{v_3-1}{v_3}+\frac{1}{v_2}\times\frac{v_3-1}{v_3}+\frac{1}{v_3}\\
&=\frac{v_3-1}{v_3}+\frac{1}{v_3}\\
&=1
\end{aligned}
$

（第一步中，由于 $v_1=1$ ，第一项的 $\frac{1}{v_1}$ 能被抵消；从第二步开始，每一步中选择前两项合并，可以发现这样的合并方式一定能持续到化简完，便有 $\sum p_i=1$ ）

具体实现上，可以先处理逆元以及 $v_i$ ，再后缀积处理一遍就可以做完了。  
于是就结束啦。

---

## 作者：LiuIR (赞：1)

## 题目大意

给定一个长度为 $k$ 数列 $t$，满足 $t_0=1,t_i<t_{i+1},t_k\le n$。

初始时有 $n$ 个人站成一排。

然后进行 $n-1$ 次操作，每次操作随机一个 $i$ 满足位置 $t_i$ 上有人，然后删掉这个人，并让后面的人补上来。

对于每个 $i$，问最后剩下的那个人是 $i$ 的概率。

## 题目解法

经典地倒过来设，设 $f_{i,j}$ 表示当前还有 $i$ 个人，且最后剩下的是 $j$ 的概率，那么转移有

$$
f_{i,j}=\frac{\left(\sum_{p=0}^k[t_p<j]\right)f_{i-1,j-1}+\left(\sum_{p=0}^k[j<t_p\le i]\right)f_{i,j}}{\sum_{p=0}^k[t_p\le i]}
$$

这样就可以做到 $O(n^2)$ 了，接着考虑进一步优化。

分母上的数是固定的，可以最后再除。然后不妨设 $a_i=\sum_{p=0}^k[t_p<i],b_i=\sum_{p=0}^k[t_p\le i]$，那么得到

$$
f_{i,j}=a_j\times f_{i-1,j-1}+(b_i-b_j)\times f_{i-1,j}
$$

然后感觉这个转移式就很有规律，手模/打表一下就可以发现

$$
f_{i,j}=\prod_{p=2}^ja_p\prod_{p=j+1}^i(b_p-b_1)
$$

归纳证明也是容易的。

然后就可以容易的做到 $O(n)$ 了。

主要代码如下：

```c++
int n, k, a[N], num[N], tmp[N];
ll comb = 1, f[N], pre[N], suf[N];

signed main()
{
    SetIO();
    cin >> n >> k;
    a[0] = 1;
    tmp[1] = 1;
    for (int i = 1; i <= k; i++)
        cin >> a[i], tmp[a[i]] = 1;
    for (int i = 1, j = 0; i <= n; i++)
    {
        num[i] = num[i - 1];
        while(j <= k && a[j] < i)
        {
            num[i]++;
            j++;
        }
        tmp[i] += num[i];
    }
    for (int i = 2; i <= n; i++)
        comb = comb *  Pow(tmp[i]) % MOD;
    pre[1] = 1;
    for (int i = 2; i <= n; i++)
        pre[i] = pre[i - 1] * num[i] % MOD;
    suf[n + 1] = 1;
    for (int i = n; i >= 1; i--)
        suf[i] = suf[i + 1] * (tmp[i] - tmp[1]) % MOD;
    for (int i = 1; i <= n; i++)
        cout << pre[i] * suf[i + 1] % MOD * comb % MOD << ' ';
    return 0;
}
```

---


# [蓝桥杯 2024 国 Python A] 药剂

## 题目描述

小蓝今天的实验内容是合并 $N$ 瓶试剂。每瓶试剂初始都有一个魔法值 $a_i$，所有魔法值都是正整数。

每次小蓝会随机从手头的试剂中选出两瓶，将其合并。合并时，两瓶试剂会发生化学反应，产生强大的力量，也有可能效果没有那么好。但无论如何，小蓝会得到一瓶全新的，可以和其他试剂合并的试剂。我们认为，小蓝在合并两瓶试剂时，如果两瓶试剂的魔法值分别是 $x$ 和 $y$，有 $\frac{1}{2}$ 的概率，小蓝得到的新试剂魔法值为 $x+y$，对于另 $\frac{1}{2}$ 概率，小蓝得到的新试剂的魔法值为 $xy$。

像这样，小蓝重复合并操作 $n-1$ 次，最后只会剩下一瓶试剂。小蓝希望知道，最后这瓶试剂的魔法值期望是多少。为了方便，假定这个值是 $ans$，你只需要告诉小蓝，$ans$ 乘上 $2^{n-1}\displaystyle \prod_{i=2}^{n}C_i^2$ 的结果，其中 $C_i^2$ 是组合数。不难证明这个值一定是一个整数。但这个乘积显然太大了，小蓝只希望你告诉她这个乘积对整数 $mo$ 取模之后的结果。

## 说明/提示

### 样例说明

可能的合并情形较多，这里给出样例中两种可能的情况：

- 第一次小蓝随机选中魔法值为 $1$ 和 $3$ 的试剂进行合并，得到魔法值为 $1+3=4$ 的一瓶新的试剂。
- 然后小蓝对仅剩的两瓶试剂进行合并，得到 $4 \times 2=8$ 的一瓶试剂。
- 因此这种情况最终试剂的魔法值为 $8$。

又或者：

- 第一次小蓝随机选中魔法值为 $1$ 和 $2$ 的试剂进行合并，得到魔法值为 $1 \times 2=2$ 的一瓶新的试剂。
- 然后小蓝对仅剩的两瓶试剂进行合并，得到 $2+3=5$ 的一瓶试剂。
- 因此这种情况最终试剂的魔法值为 $5$。

### 评测用例规模与约定

- 对于 $30\%$ 的评测用例，$1 \leq N \leq 5$，$mo = 10^9 + 7$；
- 对于 $50\%$ 的评测用例，$1 \leq N \leq 50$，$mo = 10^9 + 7$；
- 对于 $70\%$ 的评测用例，$1 \leq N \leq 300$，$mo = 10^9 + 7$；
- 对于 $80\%$ 的评测用例，$mo = 10^9 + 7$；
- 对于所有评测用例，$1 \leq N \leq 3000$，$1 \leq a_i \leq 10^9$，$1 \leq mo \leq 10^9 + 7$。

## 样例 #1

### 输入

```
3 1000000007
1 2 3```

### 输出

```
75```

# 题解

## 作者：Purslane (赞：3)

# Solution

本题的含义是，对于所有的方案最终药水的权值求和。

设全集 $U=\{1,2,3,\cdots,n\}$，定义其子集 $S \subseteq U$ 的权值为 $f(S)=\prod_{v \in S} w_v$。

对于一种局面，他最终的药水魔法值一定可以写成 $\sum_{S \subseteq U} g_S f(S)$，其中 $g_S \in \{0,1\}$。

而对所有可能的方案求和后，答案一定也可以写成 $\sum_{S \subseteq U} g_S f(S)$。每个数的地位是相同的，所以 $g_S$ 一定只和 $\text{popcount}(S)$ 有关。

因此我们只需要能够算出，每个集合能在多少种方案中得出即可。

考虑 DP。设 $dp_{i,j}$ 表示，全集大小为 $i$，一个大小为 $j$ 的子集能通过多少种方式被合成。我们可以将操作改写成：选择两个药品，丢弃掉一个，或者将他们合并。

我们只能丢弃掉最终不要的药品，以及合并需要的药品。

很容易 $O(n^2)$ 处理出这个东西。

剩下的问题就是：如何求出 $\sum_{S \subseteq U,|S|=i} f(S)$。由于 $f$ 的定义是乘积，这个也很容易用 DP 处理。

总体复杂度 $O(n^2)$，足以通过本题。代码极其短。

注：我最开始用了二十分钟去想 $dp_{i,j}$ 如何转移。因为我思考的主体是“将一种个问题分成两个子问题并且合并”，但是在这道题中完全不适用。

ヾ(｡｀Д´｡)ﾉ彡

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=3000+10; 
int n,ans,a[MAXN],MOD,dp[MAXN][MAXN],mul[MAXN];
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>MOD;
	dp[1][1]=1;
	ffor(i,2,n) ffor(j,1,i) dp[i][j]=((i-j)*(i-1)*dp[i-1][j]+j*(j-1)/2*dp[i-1][j-1])%MOD;
	mul[0]=1;
	ffor(i,1,n) {
		cin>>a[i];
		roff(j,n,1) mul[j]=(mul[j]+mul[j-1]*a[i])%MOD;	
	}
	ffor(i,1,n) ans=(ans+mul[i]*dp[n][i])%MOD;
	cout<<ans;
	return 0;
}
```

---


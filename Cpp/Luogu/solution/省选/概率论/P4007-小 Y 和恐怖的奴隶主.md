# 小 Y 和恐怖的奴隶主

## 题目背景

“A fight? Count me in!” 要打架了，算我一个。

“Everyone, get in here!” 所有人，都过来！


## 题目描述

小 Y 是一个喜欢玩游戏的 OIer。一天，她正在玩一款游戏，要打一个 Boss。

虽然这个 Boss 有 $10^{100}$ 点生命值，但它只带了一个随从——一个只有 $m$ 点生命值的“恐怖的奴隶主”。

这个“恐怖的奴隶主”有一个特殊的技能：每当它被扣减生命值但没有死亡（死亡即生命值 $\leq 0$），且 Boss 的随从数量小于上限 $k$，便会召唤一个新的具有 $m$ 点生命值的“恐怖的奴隶主”。

现在小 Y 可以进行 $n$ 次攻击，每次攻击时，会从 Boss 以及 Boss 的所有随从中的等概率随机选择一个，并扣减 $1$ 点生命值，她想知道进行 $n$ 次攻击后扣减 Boss 的生命值点数的期望。为了避免精度误差，你的答案需要对 $998244353$ 取模。

## 说明/提示

【样例 $1$ 解释】

对于第一次询问，第一次攻击有 $\frac{1}{2}$ 的概率扣减 Boss 的生命值，有 $\frac{1}{2}$ 的概率扣减随从的生命值，所以答案为 $\frac{1}{2}$。$1 \equiv 2 \times 499122177 \pmod{998244353}$。

对于第二次询问，如果第一次攻击扣减了 Boss 的生命值，那么有 $\frac{1}{2}$ 的概率第二次攻击仍扣减 Boss 的生命值，有 $\frac{1}{2}$ 的概率第二次攻击扣减随从的生命值；如果第一次攻击扣减了随从的生命值，那么现在又新召唤了一个随从（“恐怖的奴隶主”），于是有 $\frac{1}{3}$ 的概率第二次攻击扣减 Boss 的生命值，有 $\frac{2}{3}$ 的概率第二次攻击扣减随从的生命值。所以答案为 $\frac{1}{2}\times\frac{1}{2}\times2+\frac{1}{2}\times\frac{1}{2}\times1+\frac{1}{2}\times\frac{1}{3}\times1+\frac{1}{2}\times\frac{2}{3}\times0 = \frac{11}{12}$。 $11 \equiv 12 \times 415935148\pmod{998244353}$。

【提示】

题目顺序可能与难度无关。

【子任务】

在所有测试点中，$1 \leq T \leq 1000, 1 \leq n \leq {10}^{18}, 1 \leq m \leq 3, 1 \leq k \leq 8$。

各个测试点的分值和数据范围如下：

![12058](https://cdn.luogu.com.cn/upload/pic/12058.png)

## 样例 #1

### 输入

```
3 2 6
1
2
3```

### 输出

```
499122177
415935148
471393168```

# 题解

## 作者：mrsrz (赞：19)

有一道叫做[抵制克苏恩](https://www.lydsy.com/JudgeOnline/problem.php?id=4832)的题，本题是那道题的加强版。

那道题的做法是期望DP。

设$f[i][a][b][c]$表示攻击$i$次后，场上有$a$个1血随从，$b$个2血随从，$c$个三血随从的状态出现的概率。

则攻击1血随从、2血随从、3血随从、boss的概率分别为$\dfrac{a}{a+b+c+1},\dfrac{b}{a+b+c+1},\dfrac{c}{a+b+c+1},\dfrac{1}{a+b+c+1}$。

转移如下：

若$a\neq 0$，则$f[i+1][a-1][b][c]+=f[i][a][b][c]\times \dfrac{a}{a+b+c+1}$。

若$b\neq 0$：若$a+b+c< k$，则$f[i+1][a+1][b-1][c+1]+=f[i][a][b][c]\times \dfrac{b}{a+b+c+1}$，否则$f[i+1][a+1][b-1][c]+=f[i][a][b][c]\times \dfrac{b}{a+b+c+1}$。

若$c\neq 0$：若$a+b+c< k$，则$f[i+1][a][b+1][c]+=f[i][a][b][c]\times \dfrac{c}{a+b+c+1}$，否则$f[i+1][a][b+1][c-1]+=f[i][a][b][c]\times \dfrac{c}{a+b+c+1}$。

然后$f[i+1][a][b][c]+=f[i][a][b][c]\times \dfrac{1}{a+b+c+1}$，即攻击boss的情况。

记录伤害期望的话，再弄一个$g$数组即可。

对于本题，上面对应的就是$m=3$的情况，$m=1$和$m=2$的情况同理。

直接转移显然TLE。

这个东西在$m=3$的情况下只有165个可用状态。可以矩阵加速。

这时我们需要一个额外的状态来记录boss的扣血期望。于是最多有166个状态。

那么时间复杂度$O(T166^3\log n)$。

还是会TLE。

我们发现，一个行向量乘一个方阵的复杂度是$O(n^2)$的，而矩阵乘法满足结合律，所以考虑把$2^i$个方阵的乘积预处理出来，然后计算询问时，每次只要用当前的行向量乘上$\log n$个方阵。

这样的时间复杂度是$O(166^3\log n+T166^2\log n)$。

然后~~喜闻乐见~~这题卡常数，在UOJ上很可能过不了hack数据（洛谷上应该能直接过）。

有一种优化方法是减少矩阵乘法的取模次数。我每次计算的时候，直接用一个```__int128```来记录中间结果，这样每次加完一遍后再取模即可。

然后由于评测机的不稳定性，还是有可能TLE。

~~随手加几行编译指令即可QAQ~~

## Code：
```cpp
#pragma GCC optimize("Ofast")
#pragma GCC optimize("unroll-loops")
#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native")
#include<cstdio>
#include<cstring>
#define LL long long
#define md 998244353
#define STC static_cast<LL>
#define reg register
struct matrix{
	int a[167][167];
	int r,c;
	inline matrix(){memset(a,0,sizeof a);}
	matrix operator*(const matrix&b)const{
		matrix c;
		c.r=r,c.c=b.c;
		for(int i=0;i<r;++i)
		for(reg int j=0;j<b.c;++j){
			reg __int128 tmp=0;
			for(reg int k=0;k<b.r;++k)
			tmp+=STC(a[i][k])*b.a[k][j];
			c.a[i][j]=tmp%md;
		}
		return c;
	}
}p[62],a;
int T,m,k,num[9][9][9],inv[10];
void init3(){
	int cnt=0;
	for(int i=0;i<=k;++i)
	for(int j=k-i;~j;--j)
	for(int s=k-i-j;~s;--s)
	num[i][j][s]=cnt++;
	for(int i=0;i<=k;++i)
	for(int j=k-i;~j;--j)
	for(int s=k-i-j;~s;--s){
		int&id=num[i][j][s];
		const int ni=inv[i+j+s+1];
		if(i)p->a[id][num[i-1][j][s]]=STC(i)*ni%md;
		if(j){
			if(i+j+s<k)p->a[id][num[i+1][j-1][s+1]]=STC(j)*ni%md;else
			p->a[id][num[i+1][j-1][s]]=STC(j)*ni%md;
		}
		if(s){
			if(i+j+s<k)p->a[id][num[i][j+1][s]]=STC(s)*ni%md;else
			p->a[id][num[i][j+1][s-1]]=STC(s)*ni%md;
		}
		p->a[id][cnt]=p->a[id][id]=ni;
	}
	p->a[cnt][cnt]=1;
	p->r=p->c=cnt+1;
	a.r=1,a.c=cnt+1;
}
void init2(){
	int cnt=0;
	for(int i=0;i<=k;++i)
	for(int j=k-i;~j;--j)
	num[i][j][0]=cnt++;
	for(int i=0;i<=k;++i)
	for(int j=k-i;~j;--j){
		int&id=num[i][j][0];
		const int ni=inv[i+j+1];
		if(i)p->a[id][num[i-1][j][0]]=STC(i)*ni%md;
		if(j){
			if(i+j<k)p->a[id][num[i+1][j][0]]=STC(j)*ni%md;else
			p->a[id][num[i+1][j-1][0]]=STC(j)*ni%md;
		}
		p->a[id][cnt]=p->a[id][id]=ni;
	}
	p->a[cnt][cnt]=1;
	p->r=p->c=cnt+1;
	a.r=1,a.c=cnt+1;
}
int main(){
	inv[1]=1;
	for(int i=2;i<10;++i)
	inv[i]=STC(md-md/i)*inv[md%i]%md;
	scanf("%d%d%d",&T,&m,&k);
	if(m==3)init3();else
	init2();
	for(int i=1;i<62;++i)
	p[i]=p[i-1]*p[i-1];
	while(T--){
		LL n;
		scanf("%lld",&n);
		memset(*a.a,0,sizeof*a.a);
		if(m==1)
		a.a[0][num[1][0][0]]=1;else
		if(m==2)
		a.a[0][num[0][1][0]]=1;else
		a.a[0][num[0][0][1]]=1;
		for(int i=0;i<62;++i)
		if(n>>i&1)a=a*p[i];
		printf("%d\n",a.a[0][a.c-1]);
	}
	return 0;
}
```

---

## 作者：MyukiyoMekya (赞：7)

期望dp，$f_{i,a,b,c}$ 表示攻击第 $i$ 次后状态为（$a$ 个 1 血，$b$ 个 2 血，$c$ 个 3 血随从） 的期望扣血数

然后我发现这玩意正着推没法算答案，也就是 $f_i$ 从 $f_{i-1}$ 转移，而且初始状态有点难搞

有一句话叫做：

> 概率是顺推，而期望需要逆推

那么我们考虑倒着转移：$inv_i$ 表示 $i$ 在 $\bmod 998244353$ 意义下的逆元

$f_{i,a,b,c}\leftarrow f_{i,a,b,c}+(f_{i+1,a,b,c}+1)\times inv_{a+b+c+1} \bmod 998244353$

+1 是因为多扣了一滴血，然后后面的逆元是因为发生这个事件的概率是 $\dfrac {1}{a+b+c+1}$

然后下面的也就差不多了，举个攻击 1 滴血随从的例子

$f_{i,a,b,c} \leftarrow f_{i,a,b,c}+f_{i+1,a-1,b,c}\times a\times inv_{a+b+c+1} \bmod 998244353$

攻击 $i+1$ 次后比攻击 $i$ 次后少了一个 1 血随从，所以是 $a-1$，然后发生的概率是 $\dfrac {a}{a+b+c+1}$ ，

其余的类似。然后合法的 $a,b,c$ 状态不会超过 170，可以状态压缩一下，然后由于 $f_i$ 从 $f_{i+1}$ 转移，可以使用矩阵快速幂优化。

$\texttt{Code:}$

```cpp
// This code wrote by chtholly_micromaker(MicroMaker)
#include <bits/stdc++.h>
#define reg register
#define int long long
#define mem(x,y) memset(x,y,sizeof x)
#define ln puts("")
using namespace std;
const int p=998244353;
struct Status
{
	int x,y,z;
};
template <class t> inline void read(t &s){
s=0;reg int f=1;reg char c=getchar();while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
while(isdigit(c))s=(s<<3)+(s<<1)+(c^48),c=getchar();s*=f;return;}
template<class t,class ...A> inline void read(t &x,A &...a){read(x);read(a...);return;}
template <class t> inline void write(t x){if(x<0)putchar('-'),x=-x;int buf[21],top=0;
while(x)buf[++top]=x%10,x/=10;if(!top)buf[++top]=0;while(top)putchar(buf[top--]^'0');
return;}
inline void add(int &x,int y)
{
	(x+=y)>=p&&(x-=p);
	return;
}
int idx[9][9][9],sum[170],idxcnt;
struct Mat
{
	int a[170][170];
	inline void clear()
	{
		mem(a,0);
		return;
	}
	inline Mat operator * (const Mat &nt) const
	{
		Mat res;res.clear();
		for(int k=1;k<=idxcnt+1;++k)
			for(int i=1;i<=idxcnt+1;++i)
				for(int j=1;j<=idxcnt+1;++j)
					add(res.a[i][j],a[i][k]*nt.a[k][j]%p);
		return res;
	}
}base;
struct Vector
{
	int a[170];
	inline void clear()
	{
		mem(a,0);
		return;
	}
	inline Vector operator * (const Mat &nt) const
	{
		reg Vector res;res.clear();
		for(int i=1;i<=idxcnt+1;++i)
			for(int j=1;j<=idxcnt+1;++j)
				add(res.a[j],a[i]*nt.a[i][j]%p);
		return res;
	}
}I;
int m,K,n;
Status rev[170];
Mat pre[64];
int inv[10];
inline int fastpow(int a,int b,int p)
{
	reg int res=1;
	for(;b;b>>=1,a=a*a%p)
		if(b&1)
			res=res*a%p;
	return res;
}
signed main(void)
{
	int t;
	read(t,m,K);
	n=100;
	for(int i=1;i<10;++i)
		inv[i]=fastpow(i,p-2,p);
	for(int i=0;i<=K;++i)
		for(int j=0;j<=(m>=2?K-i:0);++j)
			for(int k=0;k<=(m>=3?K-i-j:0);++k)
				idx[i][j][k]=++idxcnt,sum[idxcnt]=i+j+k,rev[idxcnt]=(Status){i,j,k};
	for(int i=1;i<=idxcnt;++i)
	{
		base.a[i][i]=inv[sum[i]+1];
		base.a[idxcnt+1][i]=inv[sum[i]+1];
		reg int ns=0;
		if(rev[i].x)
		{
			ns=idx[rev[i].x-1][rev[i].y][rev[i].z];
			base.a[ns][i]=rev[i].x*inv[sum[i]+1]%p;
		}
		if(rev[i].y)
		{
			reg int X=rev[i].x+1,Y=rev[i].y-1,Z=rev[i].z;
			if(sum[i]<K)
				switch(m)
				{
					case 1:++X;break;
					case 2:++Y;break;
					case 3:++Z;break;
				}
			ns=idx[X][Y][Z];
			base.a[ns][i]=rev[i].y*inv[sum[i]+1]%p;
		}
		if(rev[i].z)
		{
			reg int X=rev[i].x,Y=rev[i].y+1,Z=rev[i].z-1;
			if(sum[i]<K)
				switch(m)
				{
					case 1:++X;break;
					case 2:++Y;break;
					case 3:++Z;break;
				}
			ns=idx[X][Y][Z];
			base.a[ns][i]=rev[i].z*inv[sum[i]+1]%p;
		}
	}
	base.a[idxcnt+1][idxcnt+1]=1;
	pre[0]=base;
	for(int i=1;i<=62;++i)
		pre[i]=pre[i-1]*pre[i-1];
	I.clear();
	I.a[idxcnt+1]=1;
	while(t--)
	{
		read(n);
		Vector Ans=I;
		for(int i=0;i<=60;++i)
			if(n&(1ll<<i))
				Ans=Ans*pre[i];
		write(Ans.a[idx[m==1][m==2][m==3]]),ln;
	}
	return 0;
}
```



---

## 作者：foreverlasting (赞：6)

[弱化版](https://www.lydsy.com/JudgeOnline/problem.php?id=4832)

[题面](https://loj.ac/problem/2325)

DP+矩阵优化。

$dp[i][A][B][C]$表示打了$i$次，场上剩余$A$个$1$血，$B$个$2$血，$C$个$3$血的奴隶主。转移方程请看下面的代码，下面的代码同时也是弱化版的题解。

code1:
```
//2018.9.19 by ljz
#include<bits/stdc++.h>
using namespace std;
#define res register int
#define LL long long
#define inf 0x3f3f3f3f
#define eps 1e-15
inline int read(){
    res s=0;
    bool w=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=1;ch=getchar();}
    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
    return w?-s:s;
}
inline void _swap(res &x,res &y){
    x^=y^=x^=y;
}
inline int _abs(const res &x){
    return x>0?x:-x;
}
inline int _max(const res &x,const res &y){
    return x>y?x:y;
}
inline int _min(const res &x,const res &y){
    return x<y?x:y;
}
const int kcz=998244353,N=50+10;
#define lb long double
namespace MAIN{
    int T;
    lb dp[N][10][10][10];
    inline void MAIN(){
        T=read();
        for(res i=1;i<=N-10;i++)
            for(res A=0;A<=7;A++)
                for(res B=0;B<=7-A;B++)
                    for(res C=0;C<=7-A-B;C++){
                        lb tot=(A+B+C+1);
                        res ADD=(A+B+C<7);
                        if(A)dp[i][A][B][C]+=dp[i-1][A-1][B][C]*A/tot;
                        if(B)dp[i][A][B][C]+=dp[i-1][A+1][B-1][C+ADD]*B/tot;
                        if(C)dp[i][A][B][C]+=dp[i-1][A][B+1][C-1+ADD]*C/tot;
                        dp[i][A][B][C]+=(dp[i-1][A][B][C]+1)/(A+B+C+1);
                    }
        while(T--){
            res k=read(),A=read(),B=read(),C=read();
            printf("%.2Lf\n",dp[k][A][B][C]);
        }
    }
}
int main(){
    MAIN::MAIN();
    return 0;
}
```

加强版矩阵优化一下就好了。

code2:
```
//2018.9.21 by ljz
#pragma GCC target("avx")
#pragma GCC optimize("Ofast,no-stack-protector")
#include<bits/stdc++.h>
using namespace std;
#define res register LL
#define LL long long
#define inf 0x3f3f3f3f
#define eps 1e-15
#define RG register
namespace io{
    const int MAXBUF=1<<15;
    const int OUTPUT=1<<24;
    char b[MAXBUF],*S=b,*T=b;
#define getc() (S==T&&(T=(S=b)+fread(b,1,MAXBUF,stdin),S==T)?0:*S++)
#define O(x) __attribute__((optimize("-O"#x)))
#define inline __inline__ __attribute__((always_inline))
    template<class Type> inline Type read(){
        RG Type aa=0;
        RG bool bb=0;
        RG char ch,*S=io::S,*T=io::T;
        for(ch=getc();(ch<'0'||ch>'9')&&ch!='-';ch=getc());
        for(ch=='-'?bb=1:aa=ch-'0',ch=getc();'0'<=ch&&ch<='9';ch=getc())aa=aa*10+ch-'0';
        io::S=S,io::T=T;
        return bb?-aa:aa;
    }
    inline int gets(RG char *s){
        RG char *iter=s,*S=io::S,*T=io::T;
        while(*iter=getc(),*iter==' '||*iter=='\n'||*iter=='\r');
        while(*++iter=getc(),*iter&&*iter!=' '&&*iter!='\n'&&*iter!='\r');
        *iter=0;
        io::S=S,io::T=T;
        return iter-s;
    }
    char buff[OUTPUT],*iter=buff;
    template<class T> inline void P(RG T x, RG char ch = '\n'){
        static int ST[110];
        res O=0;
        RG char *iter=io::iter;
        if(!x)*iter++='0';
        else{
            (x<0)?x=-x,*iter++='-':1;
            for(;x;x/=10)ST[++O]=x%10;
            for(;O;*iter++='0'+ST[O--]);
        }
        *iter++=ch,io::iter=iter;
    }
    inline void output(){fwrite(buff, 1, iter - buff, stdout),iter=buff;}
}
const LL kcz=998244353;
const LL KCZ=(0x7fffffffffffffffll/kcz-kcz)*kcz;
const LL K=10+10,N=170+10;
namespace MAIN{
    LL T,m,k;
    LL len;
    struct Matrix{
        LL t[N][N];
    };
    inline void add(res &x,res y){
        x+=y;
        x>=kcz?x-=kcz:1;
    }
    inline Matrix operator * (RG Matrix a,RG Matrix b){
        RG Matrix cnt;
        for(res i=0;i<=len+1;i++)
            for(res j=0;j<=len+1;j++){
                cnt.t[i][j]=0;
                for(res k=0;k<=len+1;k++)
                    add(cnt.t[i][j],a.t[i][k]*b.t[k][j]%kcz);
            }
        return cnt;
    }
    LL inv[K],id[K][K][K];
    Matrix dp[N];
#define rep for(res A=0;A<=k;A++)for(res B=0;B<=(m>1?k-A:0);B++)for(res C=0;C<=(m>2?k-A-B:0);C++)
    inline void pre(){
        inv[0]=inv[1]=1;
        for(res i=2;i<=K-10;i++)inv[i]=inv[kcz%i]*(kcz-kcz/i)%kcz;
        rep id[A][B][C]=++len;
        rep {
                    res ID=id[A][B][C],INV=inv[A+B+C+1],ADD=(A+B+C<k);
                    if(m==1){
                        if(A)dp[0].t[ID][id[A-1][B][C]]=A*INV%kcz;
                    }
                    else if(m==2){
                        if(A)dp[0].t[ID][id[A-1][B][C]]=A*INV%kcz;
                        if(B)dp[0].t[ID][id[A+1][B-1+ADD][C]]=B*INV%kcz;
                    }
                    else if(m==3){
                        if(A)dp[0].t[ID][id[A-1][B][C]]=A*INV%kcz;
                        if(B)dp[0].t[ID][id[A+1][B-1][C+ADD]]=B*INV%kcz;
                        if(C)dp[0].t[ID][id[A][B+1][C-1+ADD]]=C*INV%kcz;
                    }
                    dp[0].t[ID][ID]=dp[0].t[ID][len+1]=INV;
                }
        dp[0].t[len+1][len+1]=1;
        for(res i=1;i<=60;i++)dp[i]=dp[i-1]*dp[i-1];
    }
    LL ans[N],ret[N];
    inline void mul(res *ans,RG Matrix a){
        for(res i=0;i<=len+1;i++){
            ret[i]=0;
            for(res j=0;j<=len+1;j++)add(ret[i],ans[j]*a.t[j][i]%kcz);
        }
        for(res i=0;i<=len+1;i++)ans[i]=ret[i];
    }
    inline void qpow(res y){
        res i=0;
        while(y){
            if(y&1)mul(ans,dp[i]);
            y>>=1,i++;
        }
    }
    inline void MAIN(){
        res (*F)()=io::read<LL>;
        T=F(),m=F(),k=F();
        pre();
        while(T--){
            res n=F();
            for(res i=0;i<=len+1;i++)ans[i]=0;
            if(m==1)ans[id[1][0][0]]=1;
            else if(m==2)ans[id[0][1][0]]=1;
            else if(m==3)ans[id[0][0][1]]=1;
            qpow(n);
            io::P(ans[len+1]);
        }
    }
}
int main(){
    MAIN::MAIN();
    io::output();
    return 0;
}
```

---

## 作者：s_r_f (赞：5)

---

[P4007 小 Y 和恐怖的奴隶主](https://www.luogu.com.cn/problem/P4007)

考虑用一个三元组$(a,b,c)$来表示状态$,$其中

$a$为生命值为$1$的随从数量$,b$为生命值为$2$的随从数量$,c$为生命值为$3$的随从数量$.$

经过简单枚举可以发现状态总数在$m=3,k=8$时达到$165,$这个$165$就是状态总数的上界$.$

不难发现有一个$O(T\log n \times 166^3)$的暴力矩乘做法$,$但是它太慢了$.$

我们考虑$,$把矩阵乘矩乘的次数减少$,$而是用矩阵乘向量来代替$.$

考虑$K$进制矩阵快速幂$.$

即对于值域内每个$K^m,$预处理出转移矩阵的$K^m\times 1,K^m\times 2,K^m\times 3,...K^m\times (K-1)$ 次幂即可$,$ 共需$O(K\log_K(1e18))$次矩阵乘法$.$

对于询问$,$我们把询问按照$n$从小到大排序$,$每次$n$变大的时候就直接利用预处理出来的矩阵乘到当前向量上即可$,$每组询问最多有$O(\log_K(1e18))$次矩阵乘向量$.$

均衡一下复杂度$,$大概在$4-6$的时候最优$,$我的代码里选取的$K=4.$

然后矩乘卡卡常数即可$:$

一个**不保证在任何时候提交能过**的参考代码$:$

$($ 我的代码是在最后一个点$1.98s$卡着时限通过的$,$因此可能会超时 $)$

```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
const int P = 998244353;
inline int power(int x,int y){
	static int r; r = 1; while (y){ if (y&1) r = (LL)r * x % P; x = (LL)x * x % P; y >>= 1; }
	return r;
}
int T,m,k,ans[1050];
struct Query{
	int id; LL n;
	inline bool operator < (const Query w) const{ return n < w.n; }
}q[1050];
int n,id[10][10][10];
struct Mat{
	int a[166][166];
}I,T1,Tr[30][4];
Mat operator * (Mat A,Mat B){
	static Mat T; register int i,j,k;
	memset(T.a,0,sizeof(T.a));
	for (k = 0; k <= n; ++k)
	for (i = 0; i <= n; ++i)
	for (j = 0; j <= n; ++j) T.a[i][j] = (T.a[i][j] + (LL)A.a[i][k] * B.a[k][j]) % P;
	return T;
}
struct Vec{
	int a[166];
	inline int getans(){ return a[0]; }
}St,now;
Vec operator * (Mat A,Vec B){
	static Vec T; register int i,j;
	memset(T.a,0,sizeof(T.a));
	for (i = 0; i <= n; ++i) for (j = 0; j <= n; ++j) T.a[i] = (T.a[i] + (LL)A.a[j][i] * B.a[j]) % P;
	return T;
}

inline void init(){
	int a,b,c;
	int d,e,f;
	int i,j,id1,id2,prob;
	for (a = 0; a <= k; ++a)
	for (b = 0; a+b <= k; ++b)
	for (c = 0; a+b+c <= k; ++c) if (!((b&&m<2) || (c&&m<3))) id[a][b][c] = ++n;
//	cerr << "MAX id : " << n << '\n'; //165
	for (i = 0; i <= n; ++i) I.a[i][i] = 1;
	T1.a[0][0] = 1;
	for (a = 0; a <= k; ++a)
	for (b = 0; a+b <= k; ++b)
	for (c = 0; a+b+c <= k; ++c) if (id1 = id[a][b][c]){
		prob = power(a+b+c+1,P-2);
		T1.a[id1][0] = prob,T1.a[id1][id1] = prob;
		if (a) T1.a[id1][id[a-1][b][c]] = (LL)prob * a % P;
		if (b){
			d = a,e = b,f = c;
			--e,++d; if (d+e+f < k){ if (m==3) ++f; else ++e; }
			id2 = id[d][e][f];
			T1.a[id1][id2] = (LL)prob * b % P;
		}
		if (c){
			d = a,e = b,f = c;
			--f,++e; if (d+e+f < k) ++f;
			id2 = id[d][e][f];
			T1.a[id1][id2] = (LL)prob * c % P;
		}
	}
//	for (i = 0; i <= n; ++i,cerr << '\n') for (j = 0; j <= n; ++j) cerr << T1.a[i][j] << ' ';
	for (i = 0; i < 30; ++i) Tr[i][1] = i ? (Tr[i-1][3] * Tr[i-1][1]) : T1,Tr[i][2] = Tr[i][1] * Tr[i][1],Tr[i][3] = Tr[i][1] * Tr[i][2];
	if (m == 1) St.a[id[1][0][0]] = 1; else if (m == 2) St.a[id[0][1][0]] = 1; else St.a[id[0][0][1]] = 1;
//	cerr << id[0][1][0] << '\n';
}

int main(){
	int i,j;
	cin >> T >> m >> k;
	for (i = 1; i <= T; ++i) q[i].id = i,cin >> q[i].n;
	sort(q+1,q+T+1);
	init();
	now = St; LL t = 0,dt;
	for (i = 1; i <= T; ++i){
		dt = q[i].n - t;
		for (j = 0; j < 30 && dt; ++j,dt >>= 2) if (dt&3) now = Tr[j][dt&3] * now;
		t = q[i].n;
		ans[q[i].id] = now.getans();
	}
	for (i = 1; i <= T; ++i) cout << ans[i] << '\n';
	return 0;
}
```


---

---

## 作者：cirnovsky (赞：2)

## 题意简述

[这道题](https://darkbzoj.tk/problem/4832) 的加强版。

## 题解

题解里面大多数都是概率 DP，或者是期望 DP 然后是逆推。甚至不给 DP 的转移式。机房 yyds Reanap 发了一篇逆推的题解，那我就来补一篇正推的期望 DP 的填表法做法。

首先这道题看上去好像可以状压的样子，我们可以设 $f_{i,S}$ 表示当前打了 $i$ 次，敌方的情况是 $S$ 的期望。

不过仔细想一下发现我们只需要知道各种血量的奴隶主有多少即可。

于是我们重新设计 DP 的状态：$f_{s,i,j,k}$ 表示目前打了 $s$ 次，敌方分别有 $i$、$j$、$k$ 个 1hp、2hp、3hp 的奴隶主。

首先我们令 $T=[i+j+k<K]$

那么我们的方程就是：

$$
f_{s,i,j,k}=\begin{cases}
f_{s-1,i-1,j,k}+\frac{i}{i+j+k+1},M=1\land i\neq0 \\
f_{s-1,i-1,j,k}+\frac{i}{i+j+k+1},M=2\land i\neq0 \\
f_{s-1,i+1,j-1+T,k}+\frac{j}{i+j+k+1},M=2\land j\neq0 \\
f_{s-1,i-1,j,k}+\frac{i}{i+j+k+1},M=3\land i\neq0 \\
f_{s-1,i+1,j-1,k+T}+\frac{j}{i+j+k+1},M=3\land j\neq0 \\
f_{s-1,i,j+1,k-1+T}+\frac{k}{i+j+k+1},M=3\land k\neq0
\end{cases}
$$

这个方程挺好理解的，基本就等于照题意模拟。

然后我们发现转移式中的系数部分和 $f$ 数组没有关系，所以我们可以用矩阵来加速这个东西。

数一数状态数，直接加速直接 T 飞。

有一个矩阵加速常用的 trick，预处理矩阵 2 的幂。

然后取模卡卡常即可。

（代码不保证稳定能过）

```cpp
#include <cstdio>
#define mod ( 998244353 )

using namespace std;
typedef long long LL;

char buf[1 << 21], *p1 = buf, *p2 = buf;
#define getchar( ) ( p1 == p2 && ( p2 = ( p1 = buf ) + fread( buf, 1, 1 << 21, stdin ), p1 == p2 ) ? EOF : *p1 ++ )

template<typename _T>
void read( _T &x )
{
	x = 0;
	char c = getchar( );
	_T f = 1;
	while( c < '0' || c > '9' )
	{
		if( c == '-' )	f = -1;
		c = getchar( );
	}
	while( c >= '0' && c <= '9' )	x = ( x << 3 ) + ( x << 1 ) + ( c ^ '0' ), c = getchar( );
	x *= f;
}

template<typename _T, typename... Args>
void read( _T &t, Args&... args ) { read( t ), read( args... ); }

template<typename _T>
void write( _T x )
{
	if( x < 0 )	putchar( '-' ), x = -x;
	if( x > 9 )	write( x / 10 );
	putchar( x % 10 + '0' );
}

template<typename _T>
void Add( _T &x, _T y )
{
	if( y >= mod )  y %= mod;
	x += y;
	if( x >= mod )  x -= mod;
}

template<typename _T>
_T square( _T x ) { return x * x; }

const int Maxn = 10 + 5, Maxk = 170 + 5;
int T, M, K, S, Unite[Maxn][Maxn][Maxn];
LL tmp[Maxk], Ans[Maxk], Inv[Maxn];
struct Matrix
{
	LL mat[Maxk][Maxk];

	friend Matrix operator * ( const Matrix &one, const Matrix &another )
	{
		Matrix res;
		for( int i = 0; i <= S + 1; ++ i )
		{
			for( int j = 0; j <= S + 1; ++ j )
			{
				res.mat[i][j] = 0;
				for( int k = 0; k <= S + 1; ++ k )	Add( res.mat[i][j], one.mat[i][k] * another.mat[k][j] );
			}
		}
		return res;
	}
} dp[Maxk];

template<typename _T>
_T qkpow( _T base, _T times )
{
	_T res = 1;
	while( times )
	{
		if( times & 1 )	res = ( LL )res * base % mod;
		base = ( LL )base * base % mod;
		times >>= 1;
	}
	return res;
}

void progressInversions( ) { for( int i = 0; i <= 10; ++ i )	Inv[i] = qkpow( i, mod - 2 ); }
signed main( )
{
	progressInversions( );
	read( T, M, K );
	for( int i = 0; i <= K; ++ i )
	{
		int UpI;
		if( M > 1 )	UpI = K - i;
		else	UpI = 0;
		for( int j = 0; j <= UpI; ++ j )
		{
			int UpJ;
			if( M > 2 )	UpJ = K - i - j;
			else	UpJ = 0;
			for( int k = 0; k <= UpJ; ++ k )	Unite[i][j][k] = ++ S;
		}
	}
	for( int i = 0; i <= K; ++ i )
	{
		int UpI;
		if( M > 1 )	UpI = K - i;
		else	UpI = 0;
		for( int j = 0; j <= UpI; ++ j )
		{
			int UpJ;
			if( M > 2 )	UpJ = K - i - j;
			else	UpJ = 0;
			for( int k = 0; k <= UpJ; ++ k )
			{
				int Add;
				if( i + j + k < K )	Add = 1;
				else	Add = 0;
				if( M == 1 && i )	dp[0].mat[Unite[i][j][k]][Unite[i - 1][j][k]] = ( LL )i * Inv[i + j + k + 1] % mod;
				else if( M == 2 )
				{
					if( i )	dp[0].mat[Unite[i][j][k]][Unite[i - 1][j][k]] = ( LL )i * Inv[i + j + k + 1] % mod;
					if( j )	dp[0].mat[Unite[i][j][k]][Unite[i + 1][j - 1 + Add][k]] = ( LL )j * Inv[i + j + k + 1] % mod;
				}
				else if( M == 3 )
				{
					if( i )	dp[0].mat[Unite[i][j][k]][Unite[i - 1][j][k]] = ( LL )i * Inv[i + j + k + 1] % mod;
					if( j )	dp[0].mat[Unite[i][j][k]][Unite[i + 1][j - 1][k + Add]] = ( LL )j * Inv[i + j + k + 1] % mod;
					if( k )	dp[0].mat[Unite[i][j][k]][Unite[i][j + 1][k - 1 + Add]] = ( LL )k * Inv[i + j + k + 1] % mod;
				}
				dp[0].mat[Unite[i][j][k]][Unite[i][j][k]] = dp[0].mat[Unite[i][j][k]][S + 1] = Inv[i + j + k + 1];
			}
		}
	}
	dp[0].mat[S + 1][S + 1] = 1;
	for( int i = 1; i <= 60; ++ i )	dp[i] = square( dp[i - 1] );
	while( T -- > 0 )
	{
		LL N;
		read( N );
		for( int i = 0; i <= S + 1; ++ i )  Ans[i] = 0;
		if( M == 1 )	Ans[Unite[1][0][0]] = 1;
		else if( M == 2 )	Ans[Unite[0][1][0]] = 1;
		else	Ans[Unite[0][0][1]] = 1;
		for( int i = 0; i <= 60; ++ i )
		{
			if( ( N >> i ) & 1 )
			{
				for( int j = 0; j <= S + 1; ++ j )
				{
					tmp[j] = 0;
					for( int k = 0; k <= S + 1; ++ k )	Add( tmp[j], Ans[k] * dp[i].mat[k][j] );
				}
				for( int j = 0; j <= S + 1; ++ j )	Ans[j] = tmp[j];
			}
		}
		write( Ans[S + 1] ), putchar( '\n' );
	}
	return 0;
}
```

---

## 作者：Piwry (赞：2)

处理转移矩阵部分的代码调得我眼睛痛...

话说我在 uoj 的 [rk1](https://loj.ac/submission/840504) 还看到了一个比较特别的做法，理论渐进复杂度是优于矩阵方法的，且还能处理 $m, k$ 较大的情况，具体[见此](https://www.cnblogs.com/chasedeath/p/13158718.html)

## 解析

先考虑下 $n$ 比较小时怎么做

由于 $m, k$ 范围都很小，可以考虑暴力表示每种状态，例如状压（我一开始想到的qaq）、直接设多维等等。于是我们可以设 $f(n, a, b, c)$ 表示攻击 $n$ 次后，有 $a$ 个一血奴隶主，$b$ 个二血奴隶主，$c$ 个三血奴隶主的状态的**概率**，这里对于不同的 $m$ 可能有不同的具体转移方式

我们再设 $g(n)$ 表示攻击 $n$ 次后总伤害的期望。由于期望的线性性，总伤害期望等于每次攻击伤害期望的和。于是可得转移方程 $g(n)=g(n-1)+1\cdot \text{Pr}\{A\}$，其中 $A$ 是满足第 $n$ 次攻击攻击了 Boss 的事件（而 $\text{Pr}\{A\}$ 是事件的概率分布，或者说 $A$ （集合中）事件的发生概率）；其中 $\text{Pr}\{A\}$ 显然可以从 $f(n-1, \cdots)$ 得来

而每次的这些转移都是可以写成矩阵形式的，只要我们**对每种不同的状态设一维**即可（对于 $g$ 也同理）；且我们可以算出状态数最多为 $165$，即矩阵大小（算上 $g$ 就是 $166$）

于是我们就可以利用矩阵的结合律优化转移了。但注意对每次询问直接用快速幂复杂度为 $O(T166^3\log n)$，对数据范围最大的 task 还是会 T

我们注意到一个行向量乘矩阵（dp 初值矩阵乘转移矩阵）是 $O(r^2)$ 的，其中 $r$ 为向量行数。于是可以考虑预处理出转移矩阵的 $2^i$ 次，其中 $i$ 只需要处理 $[0, 59]$ 的范围就可以了；这样单次询问复杂度就降到 $O(166^2\log n)$，总的复杂度为 $O(166^3\log n+T166^2\log n)$

## CODE

如果基础的矩阵实现不太优秀，还可能会被本题卡常

这时可以考虑在矩阵乘法的最后一个 for 循环那层用一个 `__int128` 临时储存值，减少取模次数，差不多像这样：

```cpp
for(int i =0; i < A.r; ++i)
	for(int j =0; j < B.c; ++j){
		__int128 tmp =0;
		for(int k =0; k < A.c; ++k)
			tmp +=1ll*A.v[i][k]*B.v[k][j];
		C.v[i][j] =tmp%M;
	}
```

以及加一些编译优化指令：

```cpp
#pragma GCC optimize("O3")
#pragma GCC optimize("Ofast","-funroll-loops","-fdelete-null-pointer-checks")
#pragma GCC target("ssse3","sse3","sse2","sse","avx2","avx")
```

应该就能过了

&nbsp;

完整代码：

```cpp
#include <cstdio>
#define ll long long
#pragma GCC optimize("O3")
#pragma GCC optimize("Ofast","-funroll-loops","-fdelete-null-pointer-checks")
#pragma GCC target("ssse3","sse3","sse2","sse","avx2","avx")

const int MAX =166;/*对于 m =3, k =8，ID =166 包含保存期望值的位置*/
const int M =998244353;

/*------------------------------Inv------------------------------*/

int inv[10];

inline void preInv(){
	inv[1] =1;
	for(int i =2; i <= 9; ++i)
		inv[i] =1ll*(-M/i+M)*inv[M%i]%M;
}

/*------------------------------Mx------------------------------*/

struct Mx{
	int r, c, v[MAX][MAX]/*先行后列*/;
	Mx(){
		for(int i =0; i < MAX; ++i)
			for(int j =0; j < MAX; ++j)
				v[i][j] =0;
	}
	Mx(int rr, int cc, bool unit):r(rr), c(cc){
		for(int i =0; i < r; ++i)
			for(int j =0; j < c; ++j)
				v[i][j] =0;
		if(unit)
			for(int i =0; i < r; ++i)
				v[i][i] =1;
	}
};

inline Mx mul(const Mx &A, const Mx &B){
	Mx C(A.r, B.c, 0);
	for(int i =0; i < A.r; ++i)
		for(int j =0; j < B.c; ++j){
			__int128 tmp =0;
			for(int k =0; k < A.c /*B.r*/; ++k)
				tmp +=1ll*A.v[i][k]*B.v[k][j];
			C.v[i][j] =tmp%M;
		}
	return C;
}

/*------------------------------Pre------------------------------*/

int ID, id[9][9][9]/*一血，二血，三血几个*/;
Mx F[60];/*变换 2 的几次*/

/*------------------------------Main------------------------------*/

inline ll read(){
	ll x =0; char c =getchar();
	while(c < '0' || c > '9') c =getchar();
	while(c >= '0' && c <= '9') x = (x<<3) + (x<<1) + (48^c), c =getchar();
	return x;
}

int main(){
	preInv();
	int T =read(), m =read(), k =read();
	
	/*对每种状态分配一个序号*/
	for(int a =0; a <= k; ++a){
		if(m == 1)
			id[a][0][0] =ID++;
		else
			for(int b =0; b <= k-a; ++b){
				if(m == 2)
					id[a][b][0] =ID++;
				else
					for(int c =0; c <= k-a-b; ++c)
						id[a][b][c] =ID++;
			}
	}
	++ID;/*用来储存期望*/
	
	/*处理转移矩阵*/
	/*差不多就是攻击 c，攻击 b，攻击 a，攻击 Boss 这样按顺序讨论*/
	for(int i =0; i < 60; ++i)
		F[i].r =F[i].c =ID;
	F[0].v[ID-1][ID-1] =1;
	for(int a =0; a <= k; ++a){
		if(m == 1){
			if(a > 0)
				F[0].v[id[a-1][0][0]][id[a][0][0]] =(F[0].v[id[a-1][0][0]][id[a][0][0]]+1ll*a*inv[a+1])%M;
			F[0].v[id[a][0][0]][id[a][0][0]] =(F[0].v[id[a][0][0]][id[a][0][0]]+1ll*inv[a+1])%M;
			F[0].v[ID-1][id[a][0][0]] =1ll*inv[a+1]%M;/*这一维只有在攻击 Boss 时才会叠加值，每种状态有且仅加一次，因此直接赋值*/
		}
		else
			for(int b =0; b <= k-a; ++b){
				if(m == 2){
					if(b > 0){
						if(a+b < k)
							F[0].v[id[a+1][b-1+1][0]][id[a][b][0]] =(F[0].v[id[a+1][b-1+1][0]][id[a][b][0]]+1ll*b*inv[a+b+1])%M;
						else
							F[0].v[id[a+1][b-1][0]][id[a][b][0]] =(F[0].v[id[a+1][b-1][0]][id[a][b][0]]+1ll*b*inv[a+b+1])%M;
					}
					if(a > 0)
						F[0].v[id[a-1][b][0]][id[a][b][0]] =(F[0].v[id[a-1][b][0]][id[a][b][0]]+1ll*a*inv[a+b+1])%M;
					F[0].v[id[a][b][0]][id[a][b][0]] =(F[0].v[id[a][b][0]][id[a][b][0]]+1ll*inv[a+b+1])%M;
					F[0].v[ID-1][id[a][b][0]] =1ll*inv[a+b+1]%M;
				}
				else
					for(int c =0; c <= k-a-b; ++c){
						if(c > 0){
							if(a+b+c < k)
								F[0].v[id[a][b+1][c-1+1]][id[a][b][c]] =(F[0].v[id[a][b+1][c-1+1]][id[a][b][c]]+1ll*c*inv[a+b+c+1])%M;
							else
								F[0].v[id[a][b+1][c-1]][id[a][b][c]] =(F[0].v[id[a][b+1][c-1]][id[a][b][c]]+1ll*c*inv[a+b+c+1])%M;
						}
						if(b > 0){
							if(a+b+c < k)
								F[0].v[id[a+1][b-1][c+1]][id[a][b][c]] =(F[0].v[id[a+1][b-1][c+1]][id[a][b][c]]+1ll*b*inv[a+b+c+1])%M;
							else
								F[0].v[id[a+1][b-1][c]][id[a][b][c]] =(F[0].v[id[a+1][b-1][c]][id[a][b][c]]+1ll*b*inv[a+b+c+1])%M;
						}
						if(a > 0)
							F[0].v[id[a-1][b][c]][id[a][b][c]] =(F[0].v[id[a-1][b][c]][id[a][b][c]]+1ll*a*inv[a+b+c+1])%M;
						F[0].v[id[a][b][c]][id[a][b][c]] =(F[0].v[id[a][b][c]][id[a][b][c]]+1ll*inv[a+b+c+1])%M;
						F[0].v[ID-1][id[a][b][c]] =1ll*inv[a+b+c+1]%M;
					}
			}
	}
	for(int i =1; i < 60; ++i)
		F[i] =mul(F[i-1], F[i-1]);
	
	Mx dp(ID, 1, 0);
	dp.v[id[(m == 1)][(m == 2)][(m == 3)]][0] =1;
	while(T--){
		ll n =read();
		Mx ans =dp;
		ll binary =1;
		for(int i =0; i < 60; ++i, binary <<=1)
			if((n&binary) != 0)
				ans =mul(F[i], ans);
		printf("%d\n", ans.v[ID-1][0]);
	}
}
```

---

## 作者：gongbangrui (赞：2)



题意：
------------

一个boss，初始带了一个小怪兽(满血为m 1->3)，你打一下小怪兽（-1）如果它没死并且当前怪兽数不超过上限k(1-9)，就会召唤另一个满血的小怪兽，或者你打一下boss对它造成1的伤害，它比较自信，不会再召唤什么奇怪的东东，求n轮（n<=1e18）对怪兽伤害的期望；



题解：
------------

1：让我们来观察一下诡异的数据范围：1e18 8 3 ，矩阵幂优化dp吧。

2：dp[h,i,j,k] 表示第h轮，血量为1 2 3 的怪兽个数为 i j k 的概率，再打一次伤害期望贡献dp[h,i,j,k]i+j+k+1,同时转移到其他状态的概率是1i+j+k+1；省去h，把 dp[i,j,k] 重新定义成长度为1*tot的行矩阵，再定义一个tot*tot的矩阵，初始时tot*tot的矩阵可以dp推出，上快速幂。

3：统计答案，因为打怪兽和打boss是等概率的，比较方便的是再多加一位tot+1，A[tot+1][tot+1] = 1，这样就可以统计每一次的答案，最后输出ans[tot+1]即可。

4：比较重要的是复杂度，根据插隔板的原理(详见白书P104)  tot=∑10i=2C2i=165 O(tot3logn∗T)。 倍增预处理后面的(tot+1)*(tot+1)的矩阵的2^k把复杂度里的*T换成+T*lg n就好了。

5：卡常(心累)：其它奇技淫巧就不赘述了，主要是在矩阵乘法的时可以先用一个大数lim = k*mod(k∈Z)，超了就减去lim，最后再取模(异常缓慢的取模运算)。


AC代码
------------
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#define ll unsigned long long
using namespace std;
const int mod=998244353;
const ll lim=16940360401038606353llu;
int T,m,p,ans[170],tot,id[10][10][10],inv[20];
ll n;
struct Mat{
    ll v[170][170];
    Mat(){memset(v,0,sizeof(v));}
    ll *operator[](int a){return v[a];}
    Mat operator *(const Mat &a){
        Mat ret;
        for(int i=1;i<=tot+1;i++)
        for(int j=1;j<=tot+1;j++){
            for(int k=1;k<=tot+1;k++){
                ret.v[i][j]+=v[i][k]*a.v[k][j];
                if(ret.v[i][j]>=lim) ret.v[i][j]-=lim;
            }
            ret.v[i][j]%=mod;
        }
    return ret;
    }
}A[61];///
char gc(){
    static char *p1,*p2,s[1000000];
    if(p1==p2) p2=(p1=s)+fread(s,1,1000000,stdin);
    return(p1==p2)?EOF:*p1++;
}
ll rd(){
    ll x=0; char c=gc();
    while(c<'0'||c>'9') c=gc();
    while(c>='0'&&c<='9') x=x*10+c-'0',c=gc();
    return x;
}
void pre(){
    inv[1]=1;for(int i=2;i<=p+1;i++) inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
    for(int i=0;i<=p;i++)
    for(int j=0;j<=(m>1?p-i:0);j++)
    for(int k=0;k<=(m>2?p-i-j:0);k++)
        id[i][j][k] = ++tot;
    for(int i=0;i<=p;i++)
    for(int j=0;j<=(m>1?p-i:0);j++)
    for(int k=0;k<=(m>2?p-i-j:0);k++){
        int np=id[i][j][k],nk=(i+j+k<p),ni=inv[i+j+k+1];
        if(m==1)  if(i) A[0][np][id[i-1][j][k]] = 1ll*i*ni%mod;
        if(m==2) {
            if(i) A[0][np][id[i-1][j][k]] = 1ll*i*ni%mod;
            if(j) A[0][np][id[i+1][j-1+nk][k]] = 1ll*j*ni%mod;
        }
        if(m==3) {
            if(i) A[0][np][id[i-1][j][k]] = 1ll*i*ni%mod;
            if(j) A[0][np][id[i+1][j-1][k+nk]] = 1ll*j*ni%mod;
            if(k) A[0][np][id[i][j+1][k-1+nk]] = 1ll*k*ni%mod;
        }
        A[0][np][np]=A[0][np][tot+1]=ni;
    }
    A[0][tot+1][tot+1]=1;
    for(int i=1;i<=60;i++) A[i]=A[i-1]*A[i-1];
}
void mul(int *ans,Mat M){
    ll ret[170];
    for(int j=1;j<=tot+1;j++){
        ret[j] = 0;
        for(int k=1;k<=tot+1;k++) {
            ret[j] += ans[k] * M.v[k][j];
            if(ret[j]>=lim) ret[j] -=lim;
        }
        ret[j] %= mod;
    } 
    for(int j=1;j<=tot+1;j++) ans[j]=ret[j];
}
int main()
{   freopen("mzoj1121.in","r",stdin);
    freopen("mzoj1121.out","w",stdout);
    T=rd(); m=rd(); p=rd();
    pre();
    while(T--){
        n=rd();
        memset(ans,0,sizeof(ans));
        if(m==1) ans[id[1][0][0]]=1;
        else if(m==2) ans[id[0][1][0]]=1;
        else ans[id[0][0][1]]=1;
        for(int i=60;i>=0;i--) if(n>>i&1) mul(ans,A[i]); //
        printf("%d\n",ans[tot+1]);
    }
    return 0;
}
```

---

## 作者：Aleph1022 (赞：1)

一个不需要卡常的做法。

首先 DP 部分其他题解已经充分叙述。接下来，我们有 Cayley-Hamilton 定理以说明答案至多是 $K$ 阶线性递推，其中 $K=166$ 是矩阵边长。事实上，通过 Berlekamp-Massey 算法可以得到的最短递推式长度为 $K=147$。

于是我们立刻得到 $O(TK^2\log n)$ 或 $O(TK\log K\log n)$ 做法，但前者需要卡常，后者需要 FFT。

事实上我们可以稍微平衡一下复杂度。令特征多项式为 $Q(x)$，我们无非是要求出 $x^n \bmod Q(x)$。不妨模仿光速幂，设步长 $B$，预处理 $x^{B^k, 2 B^k, \dots, (B-1)B^k} \bmod Q(x)$，预处理时间复杂度为 $O(B K^2 \log_B n)$ 或 $O(B K \log K \log_B n)$。  
而询问复杂度为 $O(T K^2 \log_B n)$ 或 $O(T K \log K \log_B n)$。

取 $B = \Theta(T)$ 可得 $O(T K^2 \log_T n)$ 或 $O(T K\log K\log_T n)$。但我的代码似乎取 $B = 2^6$ 比较快。

---

## 作者：KAMIYA_KINA (赞：1)

## Tag

动态规划，矩阵加速 dp。

## Preface

碎碎念：校内模拟赛考到了这道题，本来已经无限接近正解了，然后死在了不会打代码，果然还是实力不够啊……

## Description

这有一个大 boss，初始他有一个小怪，这个小怪的血量为 $m$，如果这个小怪收到了伤害但是没有死就会产生一个新的小怪，血量同样为 $m$，同一时刻小怪的数量最多不超过 $k$。一共进攻 $n$ 轮，每一轮可以攻击小怪也可以攻击 boss，攻击他们的概率是等价的。

求最后 boss 收到的伤害的期望。

$\texttt{data range:} n\leq 10^{18},m \leq 3, k \leq 8$.

## Solution

看到 $n$ 的范围较大但是 $m,k$ 的范围较小，很容易想到矩阵优化 dp。

一个比较显然的想法就是用一个四维变量 $f_{i,a,b,c}$ 表示第 $i$ 轮有 $a$ 个满血，$b$ 个残血和 $c$ 个风中残烛。

可以从 $f_{i,a,b,c}$ 到 $f_{i+1,a,b+1,c},f_{i+1,a+1,b-1,c+1},f_{i+1,a,b,c-1},f_{i+1,a,b,c}$ 这几种情况，分别讨论一下即可，注意边界情况。

然后用一个 $g$ 数组来记录期望就可以了，时间复杂度为 $O(Tn\dbinom{m+k}m)$。

不难发现我们的状态不会超过：$\dbinom {m+k}{m}$ 个，这个数值算出来最大是 $165$ 的样子，之后用 $B$ 来代替 $\dbinom{m + k} m$。

我们就可以设计一个 $166 \times 166$ 的矩阵来优化我们的 dp。

最后时间复杂度为 $O(TB^3\log n)$，显然过不去。

发现我们需要的 $g$ 数组实际上是一个一维的向量，可以用预处理加上向量乘矩阵的运算来将快速幂的复杂度优化到 $O(B^3\log n)-O(B^2\log n)$，这个做法在 luogu 上面是可以通过的。

时间复杂度正确了，但是还是过不去，因为会被一个 $n=(111111\cdots)_2$ 的数据给卡爆，就到了经典卡常数环节了。

我的代码没有卡常数，而且是~~蒯的别人的代码~~，这里是 Loj 的[提交记录](https://loj.ac/s/1337196)，希望可以给予一定的参考。

## Code

在上面啦。



---

## 作者：xtx1092515503 (赞：1)

想了两天，终于搞出来了……

首先一个普通的DP应该是很简单的。我们设 $f_{i,j,k,l}$ 表示进行 $i$ 步后，有 $j$ 个三血，$k$ 个两血，$l$ 个一血的**概率**。

我们考虑推式子，就会发现一些性质：

1. 无论从 $i-1$ 推至 $i$ 还是从 $i$ 推至 $i+1$，能够互相转移的对 $\{j,k,l\}\rightarrow\{j',k',l'\}$ 总是固定的；

2. 所有合法的 $\{j,k,l\}$ 的个数较少（最多 $165$ 对）。

于是我们考虑矩阵优化。

这里我们发现，如果把第 $i$ 个时刻的期望也作为一个状态加到矩阵里面去，转移起来将会很方便——

但是无奈我太弱了，没想到，于是便有了下面一种解法：

我们令 $A$ 为状态转移的 $n\times n$ 矩阵，$p$ 为一 $1\times n$ 矩阵，表示初始概率（即，除了 $\{1,0,0\}$ 态为 $1$，其余位置都为 $0$ 的矩阵），$f$ 为一 $n\times1$ 矩阵，表示从某个状态出发，有多大的概率进行一次攻击并打到Boss。

我们有 $i$ 时刻的概率向量即为

$$p\times A^i$$

而对于一概率向量 $v$，其总打到Boss的概率是 $v\times f$（实际上该式子的结果是一 $1\times1$ 矩阵，但我们此处把它看作一个数）。

于是我们就有 $i$ 时刻进行一次攻击打到 Boss 的概率是

$$p\times A^i\times f$$

（注意乘法的顺序不可颠倒）

则我们最终的答案就是

$$\sum\limits_{i=0}^{n-1}p\times A^i\times f$$

因为矩阵乘法具有左结合律和右结合律，所以它可以被转为

$$p\times\Big(\sum\limits_{i=0}^{n-1}A^i\Big)\times f$$

于是我们考虑如何求出 $\sum\limits_{i=0}^{n-1}A^i$。

显然这是一个等比矩阵求和的形式，可以类似等比数列求和的形式套用 $\dfrac{A^n-I}{A-I}$；但是很遗憾，此处的 $A-I$ 并非可逆矩阵，所以我们不得不放弃这个讨巧的办法。

于是我们只能考虑类似于矩阵快速幂地处理。道理很简单，我们可以对所有 $2$ 的次幂预处理出来 $\sum\limits_{i=0}^{n-1}A^i$，然后拼接就能求出任意 $n$ 的答案，具体可以参考代码，复杂度同矩阵快速幂。

但是我们稍微估算一下就会发现，这有问题——总复杂度为 $O(165^3T\log n )$，似乎不可能通过。

这时我们就想到今年NOI好像也出现了一道矩阵快速幂的题，但是正解中它里面直接求的就是类似 $pA^n$ 的东西，复杂度是 $N^2$ 的。

于是我们考虑求出 $p\times\Big(\sum\limits_{i=0}^{n-1}A^i\Big)$。因为全过程只需要计算一个 $1\times n$ 的矩阵乘上一个 $n\times n$ 的矩阵，所以单次乘法的复杂度就变成了 $165^2$。

于是总复杂度就变成了 $O(165^2T\log n )$，可以通过洛谷数据（但是无法通过LOJ数据，因为懒得卡常了）。

通过模板化矩阵和向量（即是 $1\times n$ 矩阵），代码可以做到极其整洁。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=998244353;
int T,m,lim,N,inv[100];
int id[9][9][9];
int ksm(int x,int y){
	int z=1;
	for(;y;y>>=1,x=1ll*x*x%mod)if(y&1)z=1ll*z*x%mod;
	return z;
}
struct Matrix{
	int a[166][166];
	Matrix(){memset(a,0,sizeof(a));}
	int* operator [](int x){return a[x];}
	friend Matrix operator *(Matrix &x,Matrix &y){
		Matrix z;
		for(int i=1;i<=N;i++)for(int j=1;j<=N;j++)for(int k=1;k<=N;k++)(z[i][j]+=1ll*x[i][k]*y[k][j]%mod)%=mod;
		return z;
	}
}M[70];
struct Vector{
	int a[166];
	Vector(){memset(a,0,sizeof(a));}
	int& operator [](int x){return a[x];}
	friend Vector operator *(Vector &x,Matrix &y){
		Vector z;
		for(int i=1;i<=N;i++)for(int j=1;j<=N;j++)(z[j]+=1ll*x[i]*y[i][j]%mod)%=mod;
		return z;
	}
	friend int operator *(Vector &x,Vector &y){
		int z=0;
		for(int i=1;i<=N;i++)(z+=1ll*x[i]*y[i]%mod)%=mod;
		return z;
	}
	friend Vector operator +(Vector x,Vector y){
		Vector z;
		for(int i=1;i<=N;i++)z[i]=(x[i]+y[i])%mod;
		return z;
	}
}S[70],F;
long long n;
int Calc(){
	Vector R;
	for(int i=0;i<60;i++){
		if(!((n>>i)&1))continue;
		R=R*M[i];
		R=R+S[i];
	}
	return R*F;
}
int main(){
	scanf("%d%d%d",&T,&m,&lim);
	for(int i=0;i<=lim+1;i++)inv[i]=ksm(i,mod-2);
	Matrix &B=M[0];
	if(m==1){
		for(int i=0;i<=lim;i++)id[i][0][0]=++N,F[N]=inv[i+1];
		for(int i=0;i<=lim;i++){
			if(i>0)B[id[i][0][0]][id[i-1][0][0]]=1ll*i*inv[i+1]%mod;
			B[id[i][0][0]][id[i][0][0]]=inv[i+1];
		}
	}
	if(m==2){
		for(int i=0;i<=lim;i++)for(int j=0;i+j<=lim;j++)id[i][j][0]=++N,F[N]=inv[i+j+1];
		for(int i=0;i<=lim;i++)for(int j=0;i+j<=lim;j++){
			if(i)B[id[i][j][0]][id[i+(i+j!=lim)-1][j+1][0]]=1ll*i*inv[i+j+1]%mod;
			if(j)B[id[i][j][0]][id[i][j-1][0]]=1ll*j*inv[i+j+1]%mod;
			B[id[i][j][0]][id[i][j][0]]=inv[i+j+1];
		}
	}
	if(m==3){
		for(int i=0;i<=lim;i++)for(int j=0;i+j<=lim;j++)for(int k=0;i+j+k<=lim;k++)id[i][j][k]=++N,F[N]=inv[i+j+k+1];
		for(int i=0;i<=lim;i++)for(int j=0;i+j<=lim;j++)for(int k=0;i+j+k<=lim;k++){
			if(i)B[id[i][j][k]][id[i+(i+j+k!=lim)-1][j+1][k]]=1ll*i*inv[i+j+k+1]%mod;
			if(j)B[id[i][j][k]][id[i+(i+j+k!=lim)][j-1][k+1]]=1ll*j*inv[i+j+k+1]%mod;
			if(k)B[id[i][j][k]][id[i][j][k-1]]=1ll*k*inv[i+j+k+1]%mod;
			B[id[i][j][k]][id[i][j][k]]=inv[i+j+k+1];
		}
	}
//	for(int i=1;i<=N;i++){for(int j=1;j<=N;j++)printf("%9d ",B[i][j]);puts("");}
	for(int i=1;i<60;i++)M[i]=M[i-1]*M[i-1];
	
	S[0][id[1][0][0]]=1;
	for(int i=1;i<60;i++)S[i]=(S[i-1]*M[i-1])+S[i-1];
	
	while(T--)scanf("%lld",&n),printf("%d\n",Calc());
	return 0;
}
```


---

## 作者：Reanap (赞：1)

[弱化版](https://darkbzoj.tk/problem/4832)

为什么这里的题解都是写的顺推呢？这里提供一篇倒推的题解，为那些和我一样打倒退写 WA 的小伙伴提供一点能够借鉴的代码。

对于这道弱化版的题目，我们考虑倒推，定义 $f_{i,j,k,w}$ 我们在被打了 $i-1$ 次后，还剩下 $j$ 个三血奴隶主，$k$ 个两血奴隶主，$w$ 个一血奴隶主在接下来的 $i \sim k$ 次被打中受到伤害的期望。

那么转移就会比较容易：

定义 $tot = j+k+w+1$。

当 $j+k+w < 7$ 时有：

$$f_{i,j,k,w} = (f_{i+1,j,k,w}+1) \times \frac{1}{tot}+ f_{i+1,j,k+1,w} \times \frac {j}{tot} +  f_{i+1,j+1,k-1,w+1} \times \frac{k}{tot} +f_{i+1,j,k,w-1} \times \frac{w}{tot}$$

否则有:

$$f_{i,j,k,w} = f_{i+1,j-1,k+1,w} \times \frac {j}{tot} +  f_{i+1,j,k-1,w+1} \times \frac{k}{tot} +f_{i+1,j,k,w-1} \times \frac{w}{tot}$$

代码比较简单，注意一下输入顺序就好了。

现在我们来看这一道题，我们仍然考虑倒退，发现 $n \leq 10^{18}$，我们需要优化，我们发现对于每个 $dp$ 状态的转移的参数与$i$并无关系，因此我们考虑矩阵加速。

我们枚举出 $j,k,w$ 的所有合法情况（由于我们转移的特殊性，我们需要再把 $1$ 作为常数项加入矩阵参与转移），将其作为矩阵的大小，由于 $K \leq 8$，因此状态的数量并不会太多，只有 $166$ 个，我们枚举完合法情况将其编号过后枚举可以转移它的状态并计算出参数填入矩阵中，就可以进行矩阵优化了~。

但是这个复杂度我们仍然无法通过本题，我们考虑继续优化。我们发现这个矩阵是固定的，因此我们可以预处理出矩阵的 $2^i$ 的结果，我们在处理询问的时候只需要用一个单行去乘以我们预处理出来的一些矩阵就可以了。

但是它还是死了，根据一些奇技淫巧，我们可以用 `__int128` 储存矩阵乘法的中间结果，最后再去取模，就能有效地减少取模次数，~~优化效果显著~~。

下面就是十分冗长的代码：

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
typedef long long LL;
const LL mod = 998244353;
 
struct matrix {
	LL a[170][170];
	int n , m;
	matrix operator * (const matrix &b) const{
		matrix c;
		__int128 C[170][170];
		for (int i = 1; i <= n; ++i) {
			for (int j = 1; j <= b.m; ++j) {
				C[i][j] = 0;
			}
		}
		for (int i = 1; i <= n; ++i) {
			for (int k = 1; k <= m; ++k) {
				for (int j = 1; j <= b.m; ++j) {
					C[i][j] = C[i][j] + a[i][k] * b.a[k][j];
				}
			}
		}
		for (int i = 1; i <= n; ++i) {
			for (int j = 1; j <= b.m; ++j) {
				c.a[i][j] = C[i][j] % mod;
			}
		}
		c.n = n;
		c.m = b.m;
		return c;
	}
}I; 
int T , m , K , tot , id[10][10][10];
matrix A , B[64] , beg , ans;
LL get_inv(LL a) {
	int b = mod - 2;
	LL res = 1;
	while(b) {
		if(b & 1) res = res * a % mod;
		a = a * a % mod;
		b >>= 1;
	}
	return res;
}
void get_matrix_3 () {
	for (int j = 0; j <= K; ++j) {
		for (int k = 0; k <= K; ++k) {
			for (int w = 0; w <= K; ++w) {
				if(j + k + w > K) continue;
				id[j][k][w] = ++tot;
			}
		}
	}
	++tot;
	A.n = A.m = tot;
	A.a[tot][tot] = 1;
	for (int j = 0; j <= K; ++j) {
		for (int k = 0; k <= K; ++k) {
			for (int w = 0; w <= K; ++w) {
				if(j + k + w > K) continue;
				int now = id[j][k][w];
				LL tmp = get_inv((LL)(j + k + w + 1));
				A.a[now][now] = tmp;A.a[now][tot] = tmp;
				if(j) {
					if(j + k + w < K) A.a[now][id[j][k+1][w]] = (LL)j * tmp % mod;
					else A.a[now][id[j-1][k+1][w]] = (LL)j * tmp % mod;
				}
				if(k) {
					if(j + k + w < K) A.a[now][id[j+1][k-1][w+1]] = (LL)k * tmp % mod;
					else A.a[now][id[j][k-1][w+1]] = (LL)k * tmp % mod;
				}
				if(w) A.a[now][id[j][k][w-1]] = (LL)w * tmp % mod; 
			} 
		}
	}
}
int id2[10][10];
void get_matrix_2 () {
	for (int j = 0; j <= K; ++j) {
		for (int k = 0; k <= K; ++k) {
			if(j + k > K) continue;
			id2[j][k] = ++tot;
		}
	}
	++tot;
	I.n = I.m = A.n = A.m = tot;
	for (int j = 0; j <= K; ++j) {
		for (int k = 0; k <= K; ++k) {
			if(j + k > K) continue;
			int now = id2[j][k];
			LL tmp = get_inv((LL)(j + k + 1));
			A.a[now][now] = tmp;A.a[now][tot] = tmp;
			if(j) {
				if(j + k < K) A.a[now][id2[j][k+1]] = (LL)j * tmp % mod;
				else A.a[now][id2[j-1][k+1]] = (LL)j * tmp % mod;
			}
			if(k) A.a[now][id2[j][k-1]] = (LL)k * tmp % mod;
		}
	}
	A.a[tot][tot] = 1;
}
void make_pow() {
	B[0] = A;
	for (int i = 1; i <= 59; ++i) B[i] = B[i - 1] * B[i - 1];
}
LL f[15][10];
void work_1(int n) {
	for (int i = n; i >= 1; --i) {
		for (int j = 0; j <= K; ++j) {
			LL tmp = get_inv((LL)(j + 1));
			f[i][j] = (f[i+1][j] + 1) * tmp % mod;
			if(j) f[i][j] += f[i+1][j-1] * (LL)j % mod * tmp % mod;
		}
	}
	printf("%lld\n" , f[1][1]);
	memset(f , 0 , sizeof f);
}
int main() {
//	freopen("10.in" , "r" , stdin);
	scanf("%d %d %d" , &T , &m , &K);
	if(m == 3) {
		get_matrix_3();
		make_pow();
		ans.n = tot;ans.m = 1;
		while(T -- > 0) {
			LL x;
			scanf("%lld" , &x);
			for (int i = 1; i < tot; ++i) ans.a[i][1] = 0;
			ans.a[tot][1] = 1;
			for (LL i = 60; i >= 1; --i) {
				if(x >= (1ll << (i - 1ll))) {
					x -= (1ll << (i - 1ll));
					ans = B[i - 1] * ans;
				}
			}
			printf("%lld\n" , ans.a[id[1][0][0]][1]);
		}
	}
	else if(m == 2) {
		get_matrix_2();
		make_pow();
		beg.n = tot;beg.m = 1;
		beg.a[tot][1] = 1;
		while(T -- > 0) {
			LL x;
			scanf("%lld" , &x);
			ans = beg;
			for (LL i = 60; i >= 1; --i) {
				if(x >= (1ll << (i - 1ll))) {
					x -= (1ll << (i - 1ll));
					ans = B[i - 1] * ans;
				}
			}
			printf("%lld\n" , ans.a[id2[1][0]][1]);
		}
	}
	else {
		while(T -- > 0) {
			int n;
			scanf("%d" , &n);
			work_1(n);
		}
	}
	return 0;
}
```

---


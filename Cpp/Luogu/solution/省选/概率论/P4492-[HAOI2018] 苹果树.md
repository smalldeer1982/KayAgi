# [HAOI2018] 苹果树

## 题目背景

HAOI2018 Round2 第一题

## 题目描述

小 C 在自己家的花园里种了一棵苹果树, 树上每个结点都有恰好两个分支. 经过细心的观察, 小 C 发现每一天这棵树都会生长出一个新的结点.

第一天的时候, 果树会长出一个根结点, 以后每一天, 果树会随机选择一个当前树中没有长出过结点 的分支, 然后在这个分支上长出一个新结点, 新结点与分支所属的结点之间连接上一条边.

小 C 定义一棵果树的不便度为树上两两结点之间的距离之和, 两个结点之间 的距离定义为从一个点走到另一个点的路径经过的边数.

现在他非常好奇, 如果 $N$ 天之后小 G 来他家摘苹果, 这个不便度的期望 $E$ 是多少. 但是小 C 讨厌分数, 所以他只想知道 $E \times N !$ 对 $P$ 取模的结果, 可以证明这是一个整数.

## 说明/提示

![Explanation](https://cdn.luogu.com.cn/upload/pic/18067.png)

以上是所有 $N = 3$ 时可能的苹果树形态, 其中编号表示这个结点是第几天生
长出来的, 显然每种情况两两结点的距离均为 $4$ .

### 数据范围与约定
| 测试点编号   | $N$  | $P$  |
| :--------: | :--: | :--: |
| $1$ |  $\le 10$    |  $\le 10^9 + 7$    |
| $2$ |  $\le 10$    |   $\le 10^9 + 7$    |
| $3$ |  $\le 500$    |  $\le 10^9 + 7$     |
| $4$ |  $\le 500$    |   $\le 10^9 + 7$    |
| $5$ |  $\le 500$    |   $\le 10^9 + 7$    |
| $6$ |  $\le 2000$    |   $= 10^9 + 7$    |
| $7$ |  $\le 2000$    |   $= 10^9 + 7$    |
| $8$ |  $\le 2000$    |   $\le 10^9 + 7$    |
| $9$ |  $\le 2000$    |   $\le 10^9 + 7$    |
| $10$ | $\le 2000$     |    $\le 10^9 + 7$   |



## 样例 #1

### 输入

```
3 610745795```

### 输出

```
24```

## 样例 #2

### 输入

```
305 1000000007```

### 输出

```
865018107```

# 题解

## 作者：shadowice1984 (赞：35)

感谢zhoutb2333dalao提供做法~

# 本题题解

首先我们会发现按照题目中的方法生成二叉树，生成第1个点的时候有1种选择，第二个点的时候有2种选择，第3个点的时候有3种选择……，所以生成N个点的二叉树一共有$N!$种生成方式……

因此我们事实上就是在求所有可能的树的树上点对的距离和

发现太难根本没法算……，因为我们考虑问题的方向错了，我们应该从边的角度来考虑问题……

对于一条边来讲，我们考虑他会被多少点对经过，这就是这条边对树上点对距离的贡献了，换句话讲，枚举点对求树上距离和，和枚举边求经过点对数量和，是等价的，假如说我们考虑点i的父亲边对树上点对距离和的贡献的话，显然只有子树内->子树外的点对才会产生贡献，因此，点i的父亲边对总距离和的贡献为

## $size_{i}(n-size_{i})$

那么我们现在要统计所有可能生成的二叉树，那么我们还是可以枚举边，计算在所有不同二叉树中的贡献，只是我们此时发现似乎没有办法知道siz

**题目只要求了$(N^2)$复杂度，我们可以枚举边的同时再枚举一维siz**

事实上这样的话我们相当于枚举了每一个子树的所有可能形态，所以这样计数是准的，只不过原来的我们整棵树整棵树考虑的，现在是随便找一颗子树枚举所有可能形态考虑的

好了，现在我们钦定了点i和$siz_{i}$，那么$siz_{i}(n-siz_{i})$的贡献就已经可以确定了,然而呢，我们还需要考虑有多少中可能的树形态是保证了点i的子树siz为某一个定值，然后再乘上$siz_{i}(n-siz_{i})$的贡献就可以算出在这个情况下的答案了

我们此时可以仿照求合法序列数问题的做法来求合法树的个数，在序列问题中有一个非常常见的套路是取任意一个“分割点”然后分别考虑分割点左边和右边的情况，两个乘起来就是我们要求的序列个数

同理我们在树上也可以采取类似的套路，删掉一条边，考虑分开的两个联通块的方案数，两个乘起来就是合法树的个数了

那么我们现在考虑点i的子树中的情况，从树的形态来讲，一共有$siz_{i}!$中不同的形态，从树的点的编号来讲，一共有$C_{n-i}^{siz_{i}-1}$中不同的编号，因为我们至少需要保证子树中的点编号都要比i大……所以子树内的方案数是

## $siz_{i}!C_{n-i}^{siz_{i}-1}$

之后我们再来考虑点i的子树外面的情况

首先在生成点i之前一共是有$i!$中不同的生成方式，然后我们在生成了点i之后是不可以生成点放在的i子树中的，所以后边的点有$(i+1-2),(i+2-2),(i+3-2),………(n-size_{i}+1-2)$中生成方式，化简下就是

## $i(i-1)(n-size_{i}-1)!$

然后我们可以给这个函数打个表，当然，现场计算也没问题

所以子树内外的方案相乘就是总的方案数啦~，大概是

## $siz_{i}!C_{n-i}^{siz_{i}-1}i(i-1)(n-size_{i}-1)!$

总之，我们最后的计算树上点对距离和的式子就是

## $\sum_{i=2}^{n}\sum_{siz=1}^{n-i+1}siz!C_{n-i}^{siz-1}siz(n-siz)(n-siz+1)!i(i-1)$

然后我们就可以愉快的计算啦~

上代码~

```C
#include<cstdio>
#include<algorithm>
using namespace std;const int N=2010;typedef long long ll;
ll mod;int n;ll dp[N][N];ll fac[N];ll c[N][N];ll res;
int main()
{
    scanf("%d%lld",&n,&mod);fac[0]=1;
    for(int i=0;i<=n;i++)c[i][i]=c[0][i]=1;//组合数 
    for(int i=0;i<=n;i++)for(int j=1;j<n;j++)c[j][i]=(c[j-1][i-1]+c[j][i-1])%mod;
    for(int i=1;i<=n;i++)fac[i]=fac[i-1]*i%mod;dp[1][1]=1;//阶乘 
    for(int i=2;i<=n;i++)for(int j=1;j<=i;j++)dp[i][j]=fac[i-2]*j%mod*(j-1)%mod;//打表下子树外部的方案数 
    for(int i=2;i<=n;i++)//n^2枚举计算 
        for(int j=1;j<=n-i+1;j++)
            (res+=fac[j]*c[j-1][n-i]%mod*j*(n-j)%mod*dp[n-j+1][i])%=mod;
    printf("%lld",res);return 0;//拜拜程序~ 
}
```

---

## 作者：Soulist (赞：16)


显然每次操作之后会减少一个剩余位置，增加两个剩余位置，所以树的总数为 $2\times 3...\times n=n!$，于是所求等价于求所有树的距离和。

先考虑距离和等价于什么，考虑每条边的贡献，显然一条边的贡献为其连边的联通块大小的乘积。

于是树上的所有点对的距离和为 $\sum \Big(n-\textrm{size}(i)\Big)\cdot \textrm{size}(i)$

然后 $n$ 只有 $2000$，我们考虑一个 $\mathcal O(n^2)$ 的 dp 那么就可以通过本题了。

事实上贡献可以拆开考虑，于是我们只需要知道点 $i$ 的子树有 $\rm size$ 个点的时候的方案数即可。

事实上我们不在乎 $i$ 号点到底挂在谁的下面，我们只在乎 $i+1\to n$ 号点挂了 $j$ 个在他下面的方案数。

我们发现如果这个点下面（包括本身）挂了 $l$ 个点，那么这个点就有 $l+1$ 个位置可以选择。我们依次决策每个点是挂入这个点下面/不挂入这个点下面就可以统计答案了。

假设这个点外部有 $m$ 个点，那么可选择位置数为 $m+1-1=m$，于是我们可以开始 dp 了，设 $f_{i,k,j}$ 表示起点为 $i$，决策到了第 $k$ 个点，现在有 $j$ 个点挂在 $i$ 下面，那么我们可以得到转移：

$$f_{i,k,j}=f_{i,k-1,j-1}\times j+f_{i,k-1,j}\times (k-1-j)$$

注意贡献的初值即 $f_{i,i,1}$ 为 $i!$ 即之前生成的树的个数。
 
这样复杂度为 $\mathcal O(n^3)$

事实上转移与 $i$ 无关而只关乎于 $j,k$，换而言之我们只需要一个初值就可以转移了 $(f_{i,i,1}=1)$ 。

将所有的维度 $i$ 压缩在一起，最后计算贡献均只关乎 $j(\rm size)$，我们直接 dp 即可，复杂度为 $\mathcal O(n^2)$。

不过事实上每个点的决策可以视为 $((k-1-j)+jx)$ 这样的一个 OGF，我们通过分治 NTT 就可以直接计算出答案了。

要记得 dp 数组的初值要单独算贡献，而后者只需要计算贡献系数即可。

$Code:$

```cpp
#include<bits/stdc++.h>
using namespace std ;
#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next )
#define rep( i, s, t ) for( register int i = (s); i <= (t); ++ i )
#define drep( i, s, t ) for( register int i = (t); i >= (s); -- i )
#define re register
#define int long long 
int gi() {
	char cc = getchar() ; int cn = 0, flus = 1 ;
	while( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }
	while( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;
	return cn * flus ;
}
const int N = 2000 + 5 ; 
int n, P, f[N][N], fac[N] ; 
signed main()
{
	n = gi(), P = gi() ; int Ans = 0 ; fac[0] = 1 ;
	rep( i, 1, n ) {
		fac[i] = 1ll * fac[i - 1] * i % P ; 
		rep( j, 1, i ) f[i][j] = ( f[i - 1][j - 1] * j % P + 1ll * f[i - 1][j] * ( i - j - 1 ) % P ) % P ;
		f[i][1] = ( f[i][1] + fac[i] ) % P ; 
	}
	rep( i, 1, n ) Ans = ( Ans + 1ll * f[n][i] * i % P * ( n - i ) % P ) % P ;
	printf("%lld\n", Ans ) ;
	return 0 ;
}
```

---

## 作者：TonyYin (赞：11)

P4492 [HAOI2018]苹果树

## 题意

现在有 $n$ 次操作，每次从当前二叉树上的所有空位（节点的左/右儿子）中等概率选择一个，插入新点。

对最终 $n$ 个点的二叉树，求：**两两节点距离之和的期望**。

## 题解

加入第 $i$ 个点时，方案数为 $i$，根据乘法原理，一共有 $n!$ 种可能的二叉树。只需要**计算这些树的权值和**。

由于是统计距离之和，考虑**按边拆开计算**，一条边被经过的次数，能直接算，是这条边两侧的节点个数的乘积。

所以**先枚举边**。形式化地，枚举 $i\in[2, n]$，则当前边是 $\langle i,\operatorname{father}_i\rangle$，其被经过的次数为 $\operatorname{size}_{i}(n - \operatorname{size}_i)$.

由于 $\operatorname{size}_i$ 并不知道，所以**再枚举子树大小** $\operatorname{size}_i\in[1, n-i+1]$.

接下来我们要**确定树的形态**，求满足 $\operatorname{size}_i$ 限制的方案数，按照插入的顺序分别考虑。
$$
\underbrace{1\quad2\quad3\quad \cdots\quad i-2\quad i-1\quad i}_{A}\quad\underbrace{ i+1\quad i+2\quad \cdots\quad n-2\quad n-1\quad n}_{B}
$$

#### $A$ 段

包含前 $i$ 个点，这些点和 $i$ 的子树没什么关系，都可以随便插入，共有 $i!$ 种方案。

#### $B$ 段

我们首先要从中**选出 $\operatorname{size}_i-1$ 个节点插入 $i$ 的子树**，共有 $\dbinom{n-i}{\operatorname{size}_i-1}$ 种方案。

这 $\operatorname{size_i}$ 个点是可以以任意顺序组成二叉树的，共有 $(\operatorname{size}_i)!$ 种方案。 

对于 $B$ 中剩下的 $n-i-\operatorname{size}_i+1$ 个点，它们**都不可以放在 $i$ 的子树内**，下面计算这部分的方案数。

![](https://cdn.tonyyin.top/2021/12/26/6b7b9c0c49775.png)

上图中，$i=9$，可以发现此时共有 $8=i-1$ 个位置可供选择。

并且，每当我们插入一个节点，可供选择的位置就会增加 $1$。

所以把 $B$ 中剩下的点插入的方案数为：$(i-1)i(i+1)\cdots(n-\operatorname{size}_i-1)=\dfrac{(n-\operatorname{size}_i-1)!}{(i-2)!}$.

把上面的方案数都乘起来，再乘上 $\langle i,\operatorname{father}_i\rangle$ 这条边的贡献，得到答案的表达式：
$$
\operatorname{Ans} = \sum_{i=2}^{n}\sum_{\operatorname{size}_i=1}^{n-i+1} \operatorname{size}_i(n - \operatorname{size}_i) \cdot i!\cdot \binom{n-i}{\operatorname{size}_i-1}(\operatorname{size}_i)! \cdot \frac{(n-\operatorname{size}_i-1)!}{(i-2)!}
$$
把 $i!$ 与 $(i-2)!$ 合并，得到：
$$
\operatorname{Ans} = \sum_{i=2}^{n}\sum_{\operatorname{size}_i=1}^{n-i+1} \operatorname{size}_i(n - \operatorname{size}_i) \cdot \binom{n-i}{\operatorname{size}_i-1}(\operatorname{size}_i)! \cdot {(n-\operatorname{size}_i-1)!}\cdot i(i-1)
$$
预处理阶乘和组合数，$\mathcal{O}(n^2)$ 计算即可。

## 代码

为了提高可读性，下面代码中**统计答案部分的取模操作被省去**，直接提交将获得 $\rm{20pts}$ 的好成绩。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int MAXN = 2e3 + 10;
int N, P;
int fac[MAXN], C[MAXN][MAXN], ans;
signed main() {
	cin >> N >> P;
	fac[0] = 1;
	for(int i = 1; i <= N; i++) fac[i] = fac[i - 1] * i % P;
	for(int i = 0; i <= N; i++) C[i][0] = 1;
	for(int i = 1; i <= N; i++) 
        for(int j = 1; j <= i; j++) 
        	C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;
	for(int i = 2; i <= N; i++) {
        for(int siz = 1; siz <= N - i + 1; siz++) {
			ans += C[N - i][siz - 1] * siz * (N - siz) * fac[siz] * fac[N - siz - 1] * i * (i - 1);
		}
	}
	cout << ans << endl;
	return 0;
}
```



---

## 作者：lhm_ (赞：7)

考虑生成一颗二叉树的过程，加入第一个节点方案数为$1$，加入第二个节点方案数为$2$，加入第三个节点方案数为$3$，发现生成一颗$n$个节点的二叉树的方案数为$n!$。

所以题目中所求即为点与点之间的距离之和，考虑每一条边的贡献，即$\sum\limits_esize_x \times size_y$，$x$和$y$为这条边的两个端点。

可以枚举每一个节点$i$，再枚举节点$i$子树大小$j$，其和父亲的连边对答案的贡献为$j(n-j)$，然后贡献再乘上这个状态对应的方案数，就是所求的答案，因此问题转化为了求节点$i$子树大小为$j$的方案数。

可以把计算方案数看作三部分，安排点$i$子树中点的方案数，安排比$i$编号小的点的方案数，安排比$i+j-1$编号大的点的方案数。

考虑点$i$子树为一颗大小为$j$的二叉树，生成这个子树的方案数为$j!$。其中的点是有编号的，并且编号都比$i$大，所以安排子树中的点方案数还要考虑选出哪些点，总方案数即为$j!\binom{n-i}{j-1}$。

比点$i$编号小的点的安排方案数即为生成一颗$i$个点的二叉树的方案数，即$i!$。

比点$i$编号大的点在安排时都不能放到$i$的子树中。考虑安排好$i$子树内所有点后，即安排好前$i+j-1$个点后，再新加入一个点的方案数为$i-1$，加入第二点的方案数为$i$，加入第二点的方案数为$i+1$，一直加到最后一个点，加入最后一个点的方案数为$n-j-1$，总方案数即为$\frac{(n-j-1)!}{(i-2)!}$。

把边的贡献和上面得出的方案数乘起来，即为答案，得：

$$
\sum_{i=1}^n \sum_{j=1}^{n-i+1} j(n-j)j!\binom{n-i}{j-1}i!\frac{(n-j-1)!}{(i-2)!}
$$

考虑模数可能没有逆元，所以将式子进一步化简，去掉除法，得：

$$
\sum_{i=1}^n \sum_{j=1}^{n-i+1} j(n-j)j!\binom{n-i}{j-1}(n-j-1)!i(i-1)
$$

然后预处理阶乘和组合数，$n^2$计算即可。

$code:$

```cpp
#include<bits/stdc++.h>
#define maxn 2010
using namespace std;
typedef long long ll;
template<typename T> inline void read(T &x)
{
    x=0;char c=getchar();bool flag=false;
    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    if(flag)x=-x;
}
ll n,p,ans;
ll f[maxn],C[maxn][maxn];
void init()
{
    f[0]=1;
    for(int i=1;i<=n;++i) f[i]=f[i-1]*i%p;
    for(int i=0;i<=n;++i) C[i][0]=1;
    for(int i=1;i<=n;++i)
        for(int j=1;j<=i;++j)
            C[i][j]=(C[i-1][j-1]+C[i-1][j])%p;
}
int main()
{
    read(n),read(p),init();
    for(int i=1;i<=n;++i)
        for(int j=1;j<=n-i+1;++j)
            ans=(ans+j*(n-j)%p*f[j]%p*C[n-i][j-1]%p*f[n-j-1]%p*i%p*(i-1)%p)%p;
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：苹果蓝17 (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P4492)

[更好的阅读体验](https://www.cnblogs.com/Appleblue17/p/15103597.html)

#### 题意简述

第 $i$ 次将节点 $i$ 随机连在树上某个叶子的左侧或右侧（如果存在空位），生成一棵 $n$ 个点的二叉树，求二叉树两两节点的距离之和期望。

$n \leq 2000$。

#### 题目分析

首先，每长出一个叶子，就会减少一个连接位置，再增加两个连接位置，也就是总共多了一个连接位置。树的大小为 $x$ 时，就有 $x+1$ 个连接位置，因此总方案数为 $1 \times 2 \times \cdots \times n=n!$。

再来考虑“不便度”，经典套路是枚举每一条路径考虑贡献次数。设节点 $u$ 的子树大小为 $siz_u$，则连接 $u$ 与 $u$ 的父节点的边贡献了 $siz_u(n-siz_u)$ 次，答案即为 $\sum\limits_{i=1}^n siz_u(n-siz_u)$。

所以只需要对 $\forall k \in [1,n]$，求出所有情况下子树大小为 $k$ 的点的数量即可。

考虑动态规划，设 $f_{i,k}$ 表示树的大小为 $i$ 时，子树大小为 $k$ 的点的数量。

考虑转移，刚才已经解释过，子树大小为 $k$ 的点下面就会有 $k+1$ 个连接位置。

所以在所有情况下，它有 $k+1$ 种情况转移到 $f_{i+1,k+1}$，有 $(n+1)-(k+1)=n-k$ 种情况转移到 $f_{i+1,k}$。

再考虑新加的节点，列成被动转移：

$$f_{i,k}=(i-k-1)f_{i-1,k}+kf_{i-1,k-1}+[k=1]i!$$

时间复杂度 $O(n^2)$。

#### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const long long N=2e3+5;
long long n,mod,ans;
long long mul[N],f[N][N];
int main(){
	cin>>n>>mod;
	mul[0]=1;
	for(long long i=1;i<=n;i++) mul[i]=mul[i-1]*i%mod;
	for(long long i=1;i<=n;i++)
		for(long long j=1;j<=i;j++)
			f[i][j]=(f[i-1][j]*(i-j-1)%mod+f[i-1][j-1]*j%mod+(j==1)*mul[i])%mod;
	for(long long i=1;i<=n;i++) ans=(ans+f[n][i]*i%mod*(n-i)%mod)%mod;
	cout<<ans;
}
```

---

## 作者：sermoon (赞：3)


[博客？](https://www.cnblogs.com/reverymoon/p/10171657.html)

---

首先，每个二叉树对应着唯一的中序遍历，并且每个二叉树的概率是相同的

这十分的有用，这告诉我们$n$个节点的数行成二叉树的方案是$n!$的

并且对每种方案的权值进行求和就可以得到期望

考虑$dp$求解

令$f_i$表示$i$个节点的子树，根的深度为$1$时，所有点的期望深度之和（乘$i!$）的值

令$g_i$表示$i$个节点的子树，期望两两路径之和（乘$i!$）的值

那么$f_i = i * i! + \sum \limits_{L = 0}^{i - 1} \binom{i - 1}{L} (f_L * R! + f_R * L!)$，$L, R$分别表示左右子树的大小

$g_i = \sum \limits_{L = 0}^{i - 1} \binom{i - 1}{L} (g_L * R! + g_R * L! + f_L * R! * (R + 1) + f_R * L! * (L + 1))$

复杂度$O(n^2)$

由于没有逆元，因此组合数要预处理


---

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;

#define ri register int
#define rep(io, st, ed) for(ri io = st; io <= ed; io ++)
#define drep(io, ed, st) for(ri io = ed; io >= st; io --)

const int sid = 2e3 + 5;

int n, mod;
int C[sid][sid], fac[sid], f[sid], g[sid];

inline void inc(int &a, int b) { a += b; if(a >= mod) a -= mod; }
inline void dec(int &a, int b) { a -= b; if(a < 0) a += mod; }
inline int Inc(int a, int b) { return (a + b >= mod) ? a + b - mod : a + b; }
inline int Dec(int a, int b) { return (a - b < 0) ? a - b + mod : a - b; }
inline int mul(int a, int b) { return 1ll * a * b % mod; }

inline void init() {
    fac[0] = C[0][0] = 1;
    rep(i, 1, n) {
        C[i][0] = C[i][i] = 1;
		fac[i] = mul(fac[i - 1], i);
        rep(j, 1, i - 1) C[i][j] = Inc(C[i - 1][j], C[i - 1][j - 1]);
    }
}

inline void dp() {
    f[1] = 1;
    rep(i, 2, n) {
        rep(L, 0, i - 1) {
            int R = i - 1 - L, F = 0, G = 0;
			F = (1ll * f[L] * fac[R] + 1ll * f[R] * fac[L]) % mod;
            G = (1ll * f[L] * fac[R] % mod * (R + 1) % mod);
			inc(G, 1ll * f[R] * fac[L] % mod * (L + 1) % mod);
			inc(G, 1ll * g[L] * fac[R] % mod);
			inc(G, 1ll * g[R] * fac[L] % mod);
            inc(f[i], mul(F, C[i - 1][L])); inc(g[i], mul(G, C[i - 1][L]));
        }
		inc(f[i], 1ll * i * fac[i] % mod);
    }
    printf("%d\n", g[n]);
}

int main() {
    cin >> n >> mod;
    init(); dp();
    return 0;
}
```

---

## 作者：hgzxwzf (赞：2)

## [P4492](https://www.luogu.com.cn/problem/P4492)

### 解题思路
提供一个不需要很多组合思想的做法（~~帮助和我一样的组合蒟蒻~~）。

设 $dp_i$ 表示节点数为 $i$ 的所有二叉树中每个节点到根距离之和的和，$g_i$ 表示节点数为 $i$ 的所有二叉树中任意两个节点的距离之和的和，$F_i$ 表示节点数为 $i$ 的二叉树的数量。

$F_i=\sum_{j=0}^{i-1}F_j\times F_{i-1-j}\times \dbinom{i}{j}$。

其中 $j$ 表示左子树的节点数，因为有 $i$ 个节点，根肯定是确定的，所以要进行 $i-1$ 次加点，左子树要进行 $j$ 次加点，所以从 $i-1$ 次加点中选择 $j$ 次在左子树上加，方案数为 $\dbinom{i}{j}$，这样得到的方案数是左子树中节点的编号序列和右儿子中节点的编号序列，所以还要乘上 $F_j\times F_{i-1-j}$。

$dp_i=\sum_{j=0}^{i-1}(dp_j\times F_{i-1-j}+dp_{i-1-j}\times F_j+F_j\times F_{i-1-j}\times (i-1))\times \dbinom{i}{j}$。

先分好编号序列，方案数为 $\dbinom{i}{j}$，如果不考虑右子树的情况，那么在所有情况中根到每个左子树中的节点的距离和就是 $dp_j$，一共有 $F_{i-1-j}$ 种，所以左子树的贡献为 $dp_j\times F_{i-1-j}$，右子树同理，还要加上根和左儿子、右儿子连边的贡献，显然在每种情况中两条边的贡献和为 $i-1$。

$g_i=\sum_{j=0}^{i-1}(dp_j\times (i-j)\times F_{i-1-j}+dp_{i-1-j}\times(j+1)\times F_j+g_j\times F_{i-1-j}+g_{i-1-j}\times F_j+F_j\times F_{i-1-j}\times(j\times(i-j)+(i-j-1)\times (j+1)))\dbinom{i}{j}$。

有点长，但不难理解。

先分好编号序列，方案数为 $\dbinom{i}{j}$，先算根和右子树中的节点到每个左子树中的点的路径中左子树上的边的贡献，为 $dp_j\times(i-j)$，因为对于右子树的每种情况都要算一次，所以乘上 $F_{i-1-j}$，根和左子树中的节点到每个右子树中的点的路径中右子树上的边的贡献同理，再计算根和左儿子、右儿子连边的贡献，根和左儿子连边的贡献就是根和右子树中的点到左子树中的点的路径数量，$j\times (i-j)$，根和右儿子连边的贡献同理，每种情况都算一次，乘上 $F_j\times F_{i-1-j}$。

答案就是 $g_n$。

### Code：
```cpp
mint dp[N],g[N],F[N],f[N][N];

int main()
{
	int n;
	scanf("%d%d",&n,&mod);
	rep(i,0,n) f[i][0]=1;
	rep(i,1,n)
		rep(j,1,n)
			f[i][j]=f[i-1][j]+f[i-1][j-1];
	F[1]=F[0]=1;
	rep(i,2,n)
	{
		rep(j,0,i-1)
		{
			g[i]+=(dp[j]*(i-j)*F[i-1-j]+dp[i-1-j]*(j+1)*F[j]+g[j]*F[i-1-j]+g[i-j-1]*F[j])*f[i-1][j];
			g[i]+=F[j]*F[i-1-j]*f[i-1][j]*(j*(i-j)%mod+(j+1)*(i-1-j)%mod);
			dp[i]+=(dp[j]*F[i-1-j]+dp[i-1-j]*F[j]+F[j]*F[i-1-j]*(i-1))*f[i-1][j];
			F[i]+=F[j]*F[i-1-j]*f[i-1][j];
		}
	}
	printf("%d",g[n]);
	return 0;
}
```


---

## 作者：myee (赞：2)

### 思路

事实 $1$：$n$ 个结点的二叉树剩余分支有 $n+1$ 个。

> 这个事实使用数学归纳法不难得证。

事实 $2$：按如此方案生成的二叉树有 $n!$ 种，且每种左右子树大小分配方案各 $(n-1)!$ 种。

> 前一句是可以用事实 $1$ 立刻得到的，考虑后一句是什么意思。
> 
> 即，记左子树大小为 $l$，则有方案数为 $\binom{n-1}{l}l!(n-l-1)!$，也就是 $(n-1)!$。
>
> 这个柿子 $\binom{n-1}{l}l!(n-l-1)!$ 枚举哪些点分入左子树，再枚举左右子树形态既得。

记对所有这样的树，其到根距离之和为 $f_n$，点间距离之和为 $g_n$。

规定 $f_0=g_0=0$。

分别直接枚举左子树大小即得递推方程。

$$\\
f_n=\sum_{i=0}^{n-1}\binom{n-1}{i}(f_i(n-i-1)!+f_{n-i-1}i!+i!(n-i-1)!i+i!(n-i-1)!(n-i-1))
\\=n!(n-1)+(2\sum_{i=0}^{n-1}\binom{n-1}{i}(n-i-1)!f_i)
\\$$

对 $g$，我们在根节点统计 LCA 为当前结点的方案数。

$$\\
g_n=f_n+\sum_{i=0}^{n-1}\binom{n-1}{i}(g_i(n-i-1)!+g_{n-i-1}i!+(f_i+i!i)(n-i-1)!(n-i-1)+(f_{n-i-1}+(n-i-1)!(n-i-1))i!i)
\\=f_n+2\sum_{i=0}^{n-1}\binom{n-1}{i}g_i(n-i-1)!+2\sum_{i=0}^{n-1}\binom{n-1}{i}f_i(n-i-1)!(n-i-1)+2(n-1)!\sum_{i=0}^{n-1}i(n-i-1)
\\$$

手算前几项：

$$f:\left<0,0,2,16,\cdots\right>$$

$$g:\left<0,0,2,24,\cdots\right>$$

符合样例。

这样就足够 $O(n^2)$ 了。

注意**组合数要 $O(n^2)$ 递推预处理**。

### Code

```cpp
modint C[2005][2005],A[2005];
modint F[2005],G[2005];
int main()
{
    uint n;ullt p;scanf("%u%llu",&n,&p);
    AnyMod::ChgMod(p);
    C[0][0]=1;
    for(uint i=1;i<=n;i++)
    {
        C[i][0]=1;for(uint j=1;j<=i;j++)C[i][j]=C[i-1][j-1]+C[i-1][j];
    }
    A[0]=1;for(uint i=1;i<=n;i++)A[i]=A[i-1]*i;
    for(uint i=1;i<=n;i++)
    {
        for(uint j=0;j<i;j++)F[i]+=C[i-1][j]*F[j]*A[i-j-1];
        F[i]*=2;
        F[i]+=A[i]*(i-1);
    }
    for(uint i=1;i<=n;i++)
    {
        for(uint j=0;j<i;j++)G[i]+=C[i-1][j]*G[j]*A[i-j-1];
        for(uint j=0;j<i;j++)G[i]+=C[i-1][j]*F[j]*A[i-j-1]*(i-j-1);
        for(uint j=0;j<i;j++)G[i]+=A[i-1]*j*(i-j-1);
        G[i]*=2;
        G[i]+=F[i];
    }
    G[n].println();
    return 0;
}
```


---

## 作者：nofind (赞：2)

## [题意](https://www.luogu.com.cn/problem/P4492)

首先可以知道$n$个点的树的个数为$n!$。

考虑每条边的贡献：  
一棵树中，对于$i$的父亲边，贡献为$size_i(n-size_i)$，于是可以枚举$size_i$，求出这种情况的方案数。  

假设枚举的$size_i=j$：  
首先$i$个点的方案数为$i!$。  
之后从$n-i$个点中选$j-1$个点构成$i$的子树，方案数为$j!C_{n-i}^{j-1}$。  
剩下的点都不能放在$i$的子树中，于是之后每添加一个点的方案数依次为$(i-1),i,i+1,...,n-j-1$，将它们乘起来。  
于是方案数为$j!C_{n-i}^{j-1}i!(i-1)i...(n-j-1)=j!C_{n-i}^{j-1}(i-1)i(n-j-1)!$。

code:
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=2010;
int n,mod,ans;
int fac[maxn];
int C[maxn][maxn];
inline int read()
{
    char c=getchar();int res=0,f=1;
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9')res=res*10+c-'0',c=getchar();
    return res*f;
}
inline void pre_work()
{
	fac[0]=1;for(int i=1;i<=2000;i++)fac[i]=1ll*fac[i-1]*i%mod;
	C[0][0]=1;
	for(int i=1;i<=2000;i++)
	{
		C[i][0]=1;
		for(int j=1;j<=i;j++)C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;
	}
}
inline int calc(int i,int j)
{
	return 1ll*fac[j]%mod*C[n-i][j-1]%mod*(i-1)%mod*i%mod*fac[n-j-1]%mod;
}
int main()
{
	n=read(),mod=read();
	pre_work();
	for(int i=2;i<=n;i++)
		for(int j=1;j<=n-i+1;j++)
			ans=(ans+1ll*j*(n-j)%mod*calc(i,j)%mod)%mod;
	printf("%d",ans);
	return 0;
}
```


---

## 作者：Hyscere (赞：2)

对于一棵固定的树，对于每一条边的贡献很容易算，如果这条边较深的点为$v$，那么这条边对答案的贡献就是$2sz_v(n-sz_v)$。

那么我们反过来考虑，我们$O(n^2)$的枚举这条边的情况，即枚举深度较小的点的编号和较大的点的$size$，然后统计一条这样的边在所有情况中出现了多少次。

首先我们硬点加点的时候是按编号顺序从小到达的加的，这对答案无影响。

设当前枚举到的点为$i$，深度较大的点$size$为$j$，我们分成三部分统计。

- $1\sim i$的点没有限制，有$i!$种情况。
- 然后剩下了$n-i$个点，我们要选出$j$个放在$i$下面，这$j$个点连的时候也没有限制，那么就是$\binom{n-i}{j}j!$种情况。
- 除开这些点剩下还有$n-i-j$个点，第一次有$i$种选法，第二次有$i+1$种...最后一次有$n-i-j+1$种选法，一共就是$\prod_{k=i}^{n-i-j+1}k$ 种。

那么总的贡献就是：
$$ans=\sum_{i=1}^{n}\sum_{j=1}^{n-i}2j(n-j)\cdot i!\cdot j!\binom{n-i}{j}\cdot \prod_{k=i}^{n-j-1}k$$
化简一下：
$$ans=\sum_{i=1}^{n}i!\cdot 2\sum_{j=1}^{n-i}j(n-j)\cdot j!\binom{n-i}{j}\prod_{k=i}^{n-j-1}k$$

$$=\sum_{i=1}^{n}i!\cdot 2\sum_{j=1}^{n-i}j(n-j)\cdot \frac{(n-i)!}{(n-i-j)!}\prod_{k=i}^{n-j-1}k$$

$$=\sum_{i=1}^{n}i!\cdot 2\sum_{j=1}^{n-i}j(n-j)\cdot \left(\prod_{k=n-i-j+1}^{n-i}k\right)\left(\prod_{k=i}^{n-j-1}k\right)$$
由于没有逆元，可以预处理出$s[i][j]=\prod_{k=i}^{j}k$，时间复杂度$O(n^2)$。

```cpp
#include<bits/stdc++.h>
using namespace std;

void read(int &x) {
    x=0;int f=1;char ch=getchar();
    for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-f;
    for(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';x*=f;
}

void print(int x) {
    if(x<0) putchar('-'),x=-x;
    if(!x) return ;print(x/10),putchar(x%10+48);
}
void write(int x) {if(!x) putchar('0');else print(x);putchar('\n');}

#define lf double
#define ll long long 

const int maxn = 2e3+10;
const int inf = 1e9;
const lf eps = 1e-8;

int s[maxn][maxn],n,mod,ans;

int main() {
	read(n),read(mod);
	for(int i=1;i<=n;i++) {
		s[i][i]=i;
		for(int j=i+1;j<=n;j++) s[i][j]=1ll*s[i][j-1]*j%mod;
		for(int j=0;j<i;j++) s[i][j]=1;
	}
	for(int i=1;i<=n;i++) {
		int res=0;
		for(int j=1;j<=n-i;j++) res=(res+1ll*j*(n-j)%mod*s[n-i-j+1][n-i]%mod*s[i][n-j-1]%mod)%mod;
		ans=(ans+2ll*s[1][i]%mod*res%mod)%mod;
	}write(ans);
	return 0;
}
```

---

## 作者：yybyyb (赞：1)

考虑对于每条边计算贡献。每条边的贡献是$size*(n-size)$。  
对于某个点$u$，如果它有一棵大小为$K$的子树的话，考虑方案数。  
首先要从剩下的$n-u$个点中选出$K$个点作为这棵子树，那么选择方案数是${n-u\choose K}$，构树的方案数是$K!$。除了这些点外，还剩下$n-u-K$个点，他们随意的方案数我们这样考虑，首先把选出来的$K$个点拿出来，余下的点顺次考虑。因为不能和那$K$个点同时放在一棵子树内，因此第$1$个点可以选择的方案数是$u$，下一个是$u+1$，第$n-u-K$个的方案数是$u+n-u-k-1$，全部乘起来之后方案数就是$\frac{(n-K-1)!}{(i-1)!}$。  
因此答案就是  
$$\sum_{i=1}^ni!*2\sum_{j=1}^{n-i}j*(n-j)*{n-i\choose j}j!*\frac{(n-j-1)!}{(i-1)!}$$
最后那个除法变成组合数乘阶乘的形式就可以了。  

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
#define MAX 2050
int n,MOD,C[MAX][MAX],jc[MAX],ans;
int main()
{
	cin>>n>>MOD;
	for(int i=0;i<=n;++i)C[i][0]=1;
	for(int i=1;i<=n;++i)
		for(int j=1;j<=i;++j)
			C[i][j]=(C[i-1][j-1]+C[i-1][j])%MOD;
	jc[0]=1;for(int i=1;i<=n;++i)jc[i]=1ll*jc[i-1]*i%MOD;
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n-i;++j)
			ans=(ans+2ll*(n-j)*j*jc[i]%MOD*C[n-i][j]%MOD*jc[j]%MOD*C[n-j-1][i-1]%MOD*jc[n-j-i]%MOD)%MOD;
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：yellow_bored (赞：1)

# [HAOI2018]苹果树
## 组合数学，树
### 前言
在机房神仙讲解之后花了好长时间才明白。
### 前置知识
(我一直都不会，果然太弱了)   
关于组合数，当数很**大**且**可以算逆元**时，可以预处理阶乘和逆元然后运算。但是当数**不大**且**不可求逆元**时，可以直接预处理组合数。   
于是就需要组合数的递推公式 $c(n,m)=c(n-1,m-1)+c(n-1,m)$   
代码
```cpp
for(int i=0;i<=n;++i)
	  c[0][i]=c[i][i]=1;
	for(int i=1;i<=n;++i)
	  for(int j=1;j<i;++j)
	    c[j][i]=(c[j-1][i-1]+c[j][i-1])%md;
```


------------

### 正题
题意其实就是给了一棵会生长的二叉树，求每对点的距离。   
这又是一道树上问题，让我想到前两天的一道题，对于树上问题我们都可以将每个点与它的父亲或儿子割裂开来，方便~~姬算~~计算。   
在这道题上，我们可以分别统计每条边对答案贡献，这就要求我们枚举点。又因为这个贡献只会与这个点上面的部分和它的子树有关。因为每个点有编号，所以上面部分是确定的，于是还要枚举子树大小。（显然$n²$是可做的）    
#### 求解
##### 方案
可以发现，当二叉树生长出一个点时，生长位置数要$-1+2$，根据乘法原理，一棵树的姿态有$n!$种，放到枚举的子树即为$size!$种，由于不知道选取了哪些点，所以还要乘上$C(n-i,size-1)$即要从$n-i$个点中选取$size-1$个点。
##### 贡献
这条边的贡献显而易见了，就是$size*(n-size)$。
##### 子树外
按这个思路这棵树实际上被分为了三部分：   
$1.$子树内   
$2.$ 已确定部分（子树上）  
$3.$剩余未确定部分（外）   
$2$和$3$即构成了子树外的部分。对于$3$，回到求解最初，生长出枚举的$i$枝的贡献为$-1+2$，但是它子树内的继续生长是不可能被统计到子树外的，于是子树外的方案就是从$i$的生长开始，减去$i$这个可行的生长点，开始和最开始一样生长，方案数就是$size2*(size2-1)*(size2-2)*...*(i-1)$即$size2!/(i-2)!$（此处设$3$的大小为$size2$）。当然此处仍然需要算$2$部分，就是$i!$。
#### $ANS$
于是最终得到一个式子
$\displaystyle \sum^{n}_{i=1}\displaystyle \sum^{n-i+1}_{j=1}j*(n-j)*C(n-i,j-1)*j!*i*(i-1)*(n-j-1)!$
(注意有一个化简，否则带着除法不太好做)
#### 代码
```cpp
#include<cstdio>
using namespace std;
long long c[2010][2010],jc[2020],ans;
int main()
{
	int n,md; 
	scanf("%d%d",&n,&md);
	jc[0]=1;
	for(int i=1;i<=n;++i)
	  jc[i]=(jc[i-1]*i)%md;
	for(int i=0;i<=n;++i)
	  c[0][i]=c[i][i]=1;
	for(int i=1;i<=n;++i)
	  for(int j=1;j<i;++j)
	    c[j][i]=(c[j-1][i-1]+c[j][i-1])%md;
	for(int i=2;i<=n;++i)
	  for(int j=1;j<=n-i+1;++j)
	    ans=(ans+jc[j]*c[j-1][n-i]%md*j%md*(n-j)%md*jc[n-j-1]%md*i%md*(i-1))%md;
	printf("%lld",ans);
 } 
```




---


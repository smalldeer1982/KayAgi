# [YNOI2019] 游戏

## 题目描述

在经历了漫长的烧脑之旅后，相信同学们的思维已经充分地活跃起来了。最后，让我们玩一个游戏来结束这次充满乐趣和挑战的冒险之旅！

有 $n$ 个人在玩游戏，游戏规则如下：

在游戏开始之前，将这 $n$ 个人按照 $1\sim n$ 的顺序唯一编号。游戏开始后，每一轮只允许 $4$ 个人进入游戏，其他人按照各自的编号组成等待队列，等待参加游戏。

游戏中每个人赢得比赛的机会是同等的，游戏举办多轮，每一轮的获胜者可以继续参加下一轮的比赛，输家将根据本轮比赛开始之前的顺序排在等待队列的末尾（如果本轮的输家中有人之前赢得过比赛，那么他将在等待队列中排在本轮所有输家的前面）。

例如，在某一轮比赛开始之前小明排在小红和小刚前面，如果在该轮比赛中小明、小红和小刚都没有赢，那么小明、小红和小刚将退出比赛排在等待队列的末尾，但是小明将会继续按照比赛开始之前的顺序排在小红和小刚前面。存在的特殊情况是，如果小刚在这轮比赛之前赢得过比赛，那么小刚将在等待序列中排在小明和小红的前面。

比赛中，如果有人连续赢了 $m$ 次，那么他就是这个游戏最后的赢家。你的任务是，预测第 $k$ 个人成为最终赢家的可能。

## 说明/提示

#### 数据规模与约定
- 对于 $30\%$ 的数据：保证 $ n \le 5$，$m \le 5$。
- 对于 $60\%$ 的数据：保证 $n \le 8$，$m \le 8$。
- 对于100%的数据：保证 $4 \le n \le 10$，$0 < m \le 10$，$1\le k \le n$，$T=1$。

## 样例 #1

### 输入

```
3
4 1 1
5 1 5
5 2 1
```

### 输出

```
0.250000
0.000000
0.217626```

# 题解

## 作者：Hope2075 (赞：9)

~~这是YNOI的题目（~~

高斯消元

考虑DP

首先，发现只需要记录当前所在位置以及擂主的连局数

设$a_{i,j}$表示当前在第$i$个位置，擂主连局数为$j$时的胜率

这时候需要分类讨论一下

### 边界情况：已经连胜$m$局

如果擂主是自己，那么胜率为$1$

$a_{1,m}=1$

否则，胜率为$0$

$a_{i,m}=0,2 \leq i \leq n$

### 情况1：是擂主

两种可能：

$\frac{1}{4}$的概率当擂主，$\frac{3}{4}$的概率到第$n-2$个位置，连局数变为$1$

$a_{1,j}=\frac{1}{4}a_{1,j+1}+\frac{3}{4}a_{n-2,1},1\leq j <m$

### 情况2：将要进行游戏

这时候需要根据位置讨论每个人胜利后的结果

$a_{2,j}=\frac{1}{4}a_{1,1}+\frac{1}{4}a_{n-2,j+1}+\frac{1}{2}a_{n-1,1},1\leq j <m$

$a_{3,j}=\frac{1}{4}a_{1,1}+\frac{1}{4}a_{n-1,j+1}+\frac{1}{4}a_{n-1,1}+\frac{1}{4}a_{n,1},1\leq j <m$

$a_{4,j}=\frac{1}{4}a_{1,1}+\frac{1}{4}a_{n-2,j+1}+\frac{1}{2}a_{n,1},1\leq j <m$

### 情况3：在队伍中

这时就看当前擂主是否能胜利即可

$a_{i,j}=\frac{1}{4}a_{i-3,j+1}+\frac{3}{4}a_{i-3,1},5\leq i\leq n,1\leq j <m$

### 最后答案：

很简单，就是$a_{k,0}$

然而，搞完这些，发现了问题：这些状态间依赖关系有环

也就是：不能直接DP

不过发现状态最多$n(m+1)$个

而$n\leq 10,m\leq 10$

于是就可以高斯消元了

如果不会，就去题库搜板子学习一下

最后复杂度$O(n^3m^3)$

其实有种做法可以做到$O(n^2m+m^3)$

另外，可以发现可能的输入只有$490$种

~~于是可以考虑打表（滑稽~~

最后是代码：

高斯消元：

```cpp
#include<cstdio>
int t,m,n,k;
const int N=128;
const bool DEBUG=0;
double list[N][N];
#define abs(x) ((x)>=0?(x):-(x))
void solve(int c){
	double maxn;int maxp;
	for(int i=0;i<c;i++){
		maxn=0;
		for(int j=i;j<c;j++){
			if(abs(list[j][i])>maxn){
				maxn=abs(list[j][i]);
				maxp=j;
			}
		}
		if(maxn==0)throw 1;
		double t;
		for(int j=0;j<=c;j++){
			t=list[i][j];list[i][j]=list[maxp][j];list[maxp][j]=t;
		}
		t=list[i][i];
		for(int j=0;j<=c;j++){
			list[i][j]/=t;
		}
		for(int j=i+1;j<c;j++){
			t=list[j][i];
			for(int k=0;k<=c;k++){
				list[j][k]-=t*list[i][k];
			}
		}
	}
	for(int i=c-1;i>=0;i--){
		for(int j=i-1;j>=0;j--){
			list[j][c]-=list[j][i]*list[i][c];
			list[j][i]=0;
		}
	}
}
#define gid(x,y) ((m+1)*(x-1)+(y))
#define ls (n*(m+1))
int cnt;
double ans;
int main(){
	scanf("%d",&t);
	while(t--){
		scanf("%d%d%d",&n,&m,&k);
		cnt=0;
		for(int i=0;i<ls;i++){
			for(int j=0;j<=ls;j++){
				list[i][j]=0;
			}
		}
		//1,m
		list[cnt][gid(1,m)]+=1;
		list[cnt][ls]+=1;
		cnt++;
		//i,m
		for(int i=2;i<=n;i++){
			list[cnt][gid(i,m)]+=1;
			list[cnt][ls]+=0;
			cnt++;
		}
		//1,j
		for(int j=0;j<m;j++){
			list[cnt][gid(1,j)]+=1;
			list[cnt][gid(n-2,1)]+=-0.75;
			list[cnt][gid(1,j+1)]+=-0.25;
			list[cnt][ls]+=0;
			cnt++;
		}
		//2,j
		for(int j=0;j<m;j++){
			list[cnt][gid(2,j)]+=1;
			list[cnt][gid(1,1)]+=-0.25;
			list[cnt][gid(n-2,j+1)]+=-0.25;
			list[cnt][gid(n-1,1)]+=-0.5;
			list[cnt][ls]+=0;
			cnt++;
		}
		//3,j
		for(int j=0;j<m;j++){
			list[cnt][gid(3,j)]+=1;
			list[cnt][gid(1,1)]+=-0.25;
			list[cnt][gid(n-1,j+1)]+=-0.25;
			list[cnt][gid(n-1,1)]+=-0.25;
			list[cnt][gid(n,1)]+=-0.25;
			list[cnt][ls]+=0;
			cnt++;
		}
		//4,j
		for(int j=0;j<m;j++){
			list[cnt][gid(4,j)]+=1;
			list[cnt][gid(1,1)]+=-0.25;
			list[cnt][gid(n,j+1)]+=-0.25;
			list[cnt][gid(n,1)]+=-0.5;
			list[cnt][ls]+=0;
			cnt++;
		}
		//i,j
		for(int i=5;i<=n;i++){
			for(int j=0;j<m;j++){
				list[cnt][gid(i,j)]+=1;
				list[cnt][gid(i-3,j+1)]+=-0.25;
				list[cnt][gid(i-3,1)]+=-0.75;
				list[cnt][ls]+=0;
				cnt++;
			}
		}
		solve(ls);
		ans=list[gid(k,0)][ls];
		printf("%.6lf\n",ans);
	}
	
}
```

打表生成器：

```cpp
//将标程编译后，重命名为5415.exe
//然后就会自动生成5415_biao.cpp
#include<bits/stdc++.h>
using namespace std;
ofstream fout,gans;ifstream anf;
string res;
int main(){
	gans.open("5415_biao.cpp");
	gans<<"#include<iostream>"<<endl;
	gans<<"using namespace std;"<<endl;
	gans<<"const string ans[11][11][11]={"<<endl;
	gans<<"    ";
	for(int n=0;n<4;n++){
		gans<<"{},";
	}
	gans<<endl;
	for(int n=4;n<=10;n++){
		gans<<"    {"<<endl;
		gans<<"        {},"<<endl;
		for(int m=1;m<=10;m++){
			gans<<"        {\"\",";
			for(int k=1;k<=n;k++){
				fout.open("5415.in");
				fout<<1<<endl;
				fout<<n<<" "<<m<<" "<<k<<endl;
				fout.close();
				system("5415.exe <5415.in >5415.out");
				anf.open("5415.out");
				anf>>res;
				anf.close();
				gans<<"\""<<res<<"\",";
			}
			gans<<"},"<<endl;
		}
		gans<<"    },"<<endl;
	}
	gans<<"};"<<endl;
	gans<<"int t,n,m,k;"<<endl;
	gans<<"int main(){"<<endl;
	gans<<"    cin>>t;"<<endl;
	gans<<"    while(t--){"<<endl;
	gans<<"        cin>>n>>m>>k;"<<endl;
	gans<<"        cout<<ans[n][m][k]<<endl;"<<endl;
	gans<<"    }"<<endl;
	gans<<"}"<<endl;
}
```


---

## 作者：QiFeng233 (赞：3)

**YNOIer 不请自来**

马上就要省选了，想着刷一下历年的真题，熟悉一下环境，~~毕竟这是 YNOI~~。

# 思路分析

由于研究对象只是第 $k$ 个人这一个人，那么状态肯定不是有第 $i$ 个人这一项的。同时又因为这些人是一个轮换的关系，那我们不如设这个人是在位置 $i(1 \leq i \leq n)$ ，其中位置指的是它们在队列中排第几个。另外一个影响这个人胜利与否的因素是擂主的胜负，即擂主的连胜局数。那么我们状态设的对不对呢？从面向数据编程的角度考虑，两层状态，转移是 $O(nm)$ 的，然后概率 DP 大概率要高斯消元，那总复杂度 $O(n^3m^3)$，和数据范围相符合。所以我们最终得出了：

设 $f_{i,j}$ 为当前位置为 $i$，擂主连胜局数为 $j$ 时的游戏获胜概率，我们要求的是 $f_{k,0}$。

边界状态：已经连胜 $m$ 局

$f_{1,m}=1$，$f_{i,m}=0 (2 \leq i \leq n)$

自己是擂主：

要么接着守擂，要么被打败，掉到第 $n-2$ 个位置。

$f_{1,j}=\dfrac 14 f_{1,j+1}+\dfrac 34 f_{n-2,1}$

自己进行游戏：

要么自己成为了擂主，要么被打败，调回去。其中被打败要注意分类，看看擂主有没有和自己一起被打败，去到了自己前边还是说是擂主打败了你们三个。注意这四种情况，有着不同的人的顺序。

$f_{2,j}=\dfrac 14 f_{1,1}+\dfrac 14f_{n-2,j+1}+\dfrac 12 f_{n-1,1}$

$f_{3,j}=\dfrac 14 f_{1,1}+\dfrac 14f_{n-1,j+1}+\dfrac 14 f_{n-1,1}+\dfrac 14 f_{n,1}$

$f_{4,j}=\dfrac 14 f_{1,1}+\dfrac 14f_{n,j+1}+\dfrac 12 f_{n,1}$

在等待队列中：

咱的命运由擂主决定。擂主要么守擂，要么更新换代。
$f_{i,j}=\dfrac 14f_{i-3,j+1}+\dfrac 34f_{i-3,1}$

最后发现，状态依赖之间真的有环！要高斯消元。

反正把二维的映射到一维里就可以高斯消元了。

复杂度 $O((nm)^3)$。

当然你也可以打表（大雾）。

另外，听学长说，事实上在去年的 YNOI，你只用 `cout<<0` 就能取得 30 分的好成绩。

## Code
```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
const int maxn=110;
namespace QiFeng233{
	int t,n,m,k,s,c;
	double a[maxn][maxn],ans[maxn];
	int pos(int x,int y){
		return (x-1)*(m+1)+y;
	}
	void gauss(int x){
		for(int i=0;i<x;++i){
			int row=i;
			//接下来为了减小误差，找系数最大的一行 
			for(int j=i;j<x;++j){
				if(fabs(a[row][i])<fabs(a[j][i]))
					row=j;
			}
			if(row!=i)std::swap(a[row],a[i]);
			double div1=a[i][i];
			for(int j=0;j<=x;++j)
				a[i][j]/=div1;
			for(int j=i+1;j<x;++j){
				double div2=a[j][i];
				for(int k=0;k<=x;++k){
					a[j][k]-=a[i][k]*div2;
				}
			}
		}
		for(int i=x-1;i>=0;i--){
			for(int j=i-1;j>=0;j--){
				a[j][x]-=a[j][i]*a[i][x];
				a[j][i]=0;
			}
		}
	}
	void solve(){
		scanf("%d",&t);//t==1,艹
		scanf("%d%d%d",&n,&m,&k);
		s=n*(m+1);
		//1,m
		a[c][pos(1,m)]+=1;
		a[c][s]+=1;
		++c;
		//i,m
		for(int i=2;i<=n;++i){
			a[c][pos(i,m)]+=1;
			++c;
		}
		//1,j
		for(int j=0;j<m;++j){
			a[c][pos(1,j)]+=1;
			a[c][pos(1,j+1)]-=0.25;
			a[c][pos(n-2,1)]-=0.75;
			++c;
		}//2,j
		for(int j=0;j<m;++j){
			a[c][pos(2,j)]+=1;
			a[c][pos(1,1)]-=0.25;
			a[c][pos(n-2,j+1)]-=0.25;
			a[c][pos(n-1,1)]-=0.5;
			++c;
		}
		//3,j
		for(int j=0;j<m;++j){
			a[c][pos(3,j)]+=1;
			a[c][pos(1,1)]-=0.25;
			a[c][pos(n-1,j+1)]-=0.25;
			a[c][pos(n-1,1)]-=0.25;
			a[c][pos(n,1)]-=0.25;
			++c;
		}
		//4,j
		for(int j=0;j<m;++j){
			a[c][pos(4,j)]+=1;
			a[c][pos(1,1)]-=0.25;
			a[c][pos(n,j+1)]-=0.25;
			a[c][pos(n,1)]-=0.5;
			++c;
		}
		//i,j
		for(int i=5;i<=n;++i){
			for(int j=0;j<m;++j){
				a[c][pos(i,j)]+=1;
				a[c][pos(i-3,j+1)]-=0.25;
				a[c][pos(i-3,1)]-=0.75; 
				++c;
			}
		}
		gauss(s);
		printf("%.6lf",a[pos(k,0)][s]);
	} 
}
signed main(){
	QiFeng233::solve();
	return 0;
}
```

---

## 作者：阿丑 (赞：2)

提供一种 $\mathcal O(n^2m+n^3)$ 的写法。

[题目传送门](/problem/P5415)

#### 前置知识：

期望 dp，高斯消元。

#### 题意：

- $n$ 个人排成一队，进行若干轮比赛。每轮从队首的前四个人中等概率选出一个人赢得该轮，这个人继续留在队首；其他三人按顺序排到队尾。
- 若有人连续赢得 $m$ 轮比赛，则他胜出，且游戏结束。问第 $k$ 个人胜出的概率。
- $n,m\le10$。

#### 分析：

为防止重名，将题目中的 $k$ 记为 $K$。

对于一个局面，某个人获胜的概率只与他的位置 $k$ 和第一个人目前连续赢得的轮数 $i$ 有关。所以记 $dp_{i,k}$ 表示第一个人目前连续赢得了 $i$ 轮的情况下，第 $k$ 个人胜出的概率。

考虑如何转移。在下一轮比赛中，$i$ 的改变与第一个人是否继续赢得该轮有关，第 $k$ 个人的新位置与 $k$ 当前的值有关。具体地，分为三类：

1. $k=1$。此时：
   - 有 $\frac14$ 的概率第 $k$ 个人赢得该轮，仍然留在队首，$i$ 增加 $1$；
   - 有 $\frac34$ 的概率其他人赢得该轮，$i$ 变为 $1$，第 $k$ 个人会到第 $n-2$ 个位置。
2. $2\le k\le4$。此时：
   - 有 $\frac14$ 的概率第一个人赢得该轮，$i$ 增加 $1$，第 $k$ 个人到第 $n-4+k$ 个位置；
   - 有 $\frac{k-2}4$ 的概率第一个人与第 $k$ 个人之间的某个人赢得该轮，$i$ 变为 $1$，第 $k$ 个人也到第 $n-4+k$ 个位置；
   - 有 $\frac14$ 的概率第 $k$ 个人赢得该轮，到达队首，$i$ 变为 $1$；
   - 有 $\frac{4-k}4$ 的第 $k$ 个人后面的某个人赢得该轮，$i$ 变为 $1$，第 $k$ 个人到第 $n-3+k$ 个位置。
3. $k>4$。此时：
   - 有 $\frac14$ 的概率第一个人赢得该轮，$i$ 增加 $1$，第 $k$ 个人到第 $k-3$ 个位置；
   - 有 $\frac34$ 的概率其他人赢得该轮，$i$ 变为 $1$，第 $k$ 个人还是到第 $k-3$ 个位置。

整理一下，有：
$$
dp_{i,k}=\begin{cases}
\dfrac{dp_{i+1,\,1}+3dp_{1,\,n-2}}4&k=1\\
\dfrac{dp_{i+1,\,n-4+k}+(k-2)dp_{1,\,n-4+k}+dp_{1,\,1}+(4-k)dp_{1,\,n-3+k}}4&2\le k\le4\\
\dfrac{dp_{i+1,\,k-3}+3dp_{1,\,k-3}}4&k>4
\end{cases}
$$
边界情况是：
$$
dp_{m,k}=\begin{cases}
1&k=1\\
0&k\ne1
\end{cases}
$$

答案是 $dp_{0,K}$。

共有 $\mathcal O(nm)$ 个状态，直接高斯消元即可做到 $\mathcal O(n^3m^3)$。

但注意到我们列出方程只需要 $\mathcal O(nm)$ 的时间。能不能平衡一下？

我们可以尝试选出 $n$ 个状态作为“特殊状态”，将其他状态只用“特殊状态”和常数表示出来，对只包含“特殊状态”和常数的关系式进行消元。对单个状态用 $n$ 个值表示，复杂度 $\mathcal O(n)$，表示所有状态复杂度 $\mathcal O(n^2m)$；高斯消元复杂度复杂度降至 $\mathcal O(n^3)$。

具体地，观察上述式子，发现 $dp_{i,k}$ 只与一个 $dp_{i+1,\,...}$ 和若干 $dp_{1,\,...}$ 有关。故可以令 $dp_{1,k}$ 为特殊状态，并从 $m-1$ 到 $1$ 枚举 $i$。这样枚举到某个 $i$ 时，所有 $dp_{i+1,\,...}$（当 $i=m-1$ 时即为边界条件）如何用特殊状态和常数表示我们均已知，故也可以将 $dp_{i,k}$ 用特殊状态和常数表示出来。当表示到 $i=1$，即特殊状态本身时，我们就得到了 $n$ 条只包含特殊状态和常数的关系式。高斯消元即可。

时间复杂度 $\mathcal O(n^2m+n^3)$，空间复杂度 $\mathcal O(n^2m)$。

---

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int mN=10+3;
int n, m, K;

double a[mN][mN], f[mN][mN][mN];
//f[i][k][j] 表示 dp[i][k] 的表达式中，第 dp[1][j] 项的系数。
//f[i][k][n+1] 表示常数。
inline void plus4(double *f, double *g) {	//f 加上 1/4 的 g。
	for(int j=1; j<=n+1; ++j) {
		f[j]+=g[j]/4;
	}
}
void gauss() {
	for(int k=1; k<=n; ++k) {
		double tmp=abs(a[k][k]);
		int nxti=k;
		for(int i=k+1; i<=n; ++i) {
			if(abs(a[i][k])>tmp) {
				tmp=abs(a[i][k]);
				nxti=i;
			}
		}
		if(nxti!=k) {
			for(int j=k; j<=n+1; ++j) {
				swap(a[k][j], a[nxti][j]);
			}
		}
		for(int i=1; i<=n; ++i) if(i!=k) {
			tmp=a[i][k]/a[k][k];
			for(int j=k; j<=n+1; ++j) {
				a[i][j]-=a[k][j]*tmp;
			}
		}
	}
	for(int i=1; i<=n; ++i) {
		a[i][n+1]/=a[i][i];
	}
}

int main() {

	int T_T;
	scanf("%d", &T_T);
	while(T_T--) {
//		memset(a, 0, sizeof a);
//		memset(f, 0, sizeof f);

		scanf("%d%d%d", &n, &m, &K);
		for(int k=1; k<=n; ++k) {
			f[m][k][n+1]=k==1;
		}
		for(int i=m-1; i>=1; --i) {
			plus4(f[i][1], f[i+1][1]);
			f[i][1][n-2]+=3/4.;
			for(int k=2; k<=4; ++k) {
				plus4(f[i][k], f[i+1][n-4+k]);
				f[i][k][1]+=1/4.;
				f[i][k][n-4+k]+=(k-2)/4.;
				f[i][k][n-3+k]+=(4-k)/4.;
			}
			for(int k=5; k<=n; ++k) {
				plus4(f[i][k], f[i+1][k-3]);
				f[i][k][k-3]+=3/4.;
			}
		}
		for(int k=1; k<=n; ++k) {
			for(int j=1; j<=n; ++j) {
				a[k][j]=-f[1][k][j];
			}
			a[k][n+1]=f[1][k][n+1];
			a[k][k]+=1;
		}
		gauss();
		double ans;
		if(K==1) {	//计算 dp[K][0]
			ans=(a[1][n+1]+a[n-2][n+1]*3)/4;
		} else if(K<=4) {
			ans=(a[1][n+1]+a[n-4+K][n+1]*(K-1)+a[n-3+K][n+1]*(4-K))/4;
		} else {
			ans=a[K-3][n+1];
		}
		printf("%.6f\n", ans);
	}
	return 0;
}
```

---

## 作者：naught (赞：1)

[更好的阅读体验](https://www.cnblogs.com/naughty-naught/p/18474990)

# [YNOI2019] 游戏

## 题外话

第一眼，由乃？不打不打。

第二眼，欸 `noi` 三个字母怎么是大写（才发现是云南省选）。

## 题意

题意简洁，不再赘述。

## Solution

一眼看出概率 `dp`，但如何似乎没思路？开始公式做题：设置状态+推转移式。

### $Q1$：怎么设置状态？

首先，思考一个问题：第 $k$ 个人该怎么“赢”呢？

我们称前4人的比赛为“擂台”，一场擂台只会有一个胜者，这位胜者被称为“擂主”，再称那第 $k$ 位选手为勇者。

勇者要赢，首先要等待再等待，进入“擂台”，并且保持胜利直至连胜 $m$ 场，期间若输了则要再继续进行上述操作直到连胜 $m$ 场。

那么，勇者要赢，首先要进入擂台，那么在他进入擂台前，擂主不能连赢大于等于 $m$ 场，所以有一维状态 $j$，表示擂主连胜了 $j$ 场。

其次，他要在擂台上连赢 $m$ 场，若输了，就要到最后排队，这时候勇者的位置会发生变化，所以另一维状态 $i$，表示勇者在第 $i$ 的位置。

那么 `dp` 的状态设置就很明了了，$f_{i,j}$ 表示勇者在第 $i$ 的位置，擂主已连胜 $j$ 场时赢的概率。

### $Q2$：怎么推转移式？

对于 $i$ 的值分类讨论。

**边界条件（连胜了 $m$ 场）**

$f_{1,m} = 1$，其他都是 $0$。因为只有自己是擂主时才能赢。

**自己是擂主（$i = 1$）**

$f_{1, j} = \frac{1}{4} \times f_{1, j + 1} + \frac{3}{4} \times f_{n - 2, 1}$。自己胜了就胜场 $+1$；反之掉到 $n-2$ 的位置，胜场变为 $1$。

**入了擂台，但不是擂主（$1 < i \le 4$）**

$$

f_{i, j} = 

\begin{cases}

  \frac{1}{4} \times f_{1, 1} + \frac{1}{4} \times f_{n - 2, j + 1} + \frac{1}{4} \times f_{n - 1, 1} + \frac{1}{4} \times f_{n, 1} & i = 2 \\
  \frac{1}{4} \times f_{1, 1} + \frac{1}{4} \times f_{n - 1, j + 1} + \frac{1}{4} \times f_{n - 1, 1} + \frac{1}{4} \times f_{n, 1} & i = 3 \\
  \frac{1}{4} \times f_{1, 1} + \frac{1}{4} \times f_{n - 1, j + 1} + \frac{1}{2} \times f_{n, 1} & i = 4

\end{cases}

$$

对于各个位置分开讨论。

**在等待入擂台的队伍中（$i > 4$）**

$f_{i, j} = \frac{1}{4} \times f_{i - 3, j + 1} + \frac{3}{4} \times f_{i - 3, 1}$。只看当前擂主是否胜利。

### 收尾

`dp` 式子有依赖关系怎么办？

没事，$n \times (m+1)$ 只有 $100$ 的量级，$O(n^3m^3)$ 可过。

所以高斯消元即可。复杂度 $O(n^3m^3)$（还有 $O(n^2m + m^3)$ 做法但我不会，不做讲解）。

另外，本题还能打表。

## Code

```cpp
// 高斯消元
// written by Naught
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef long double lb;
#define Maxn 15
#define Maxm 105
#define fo(i, l, r) for (int i = l; i <= r; ++i)
#define fr(i, r, l) for (int i = l; i >= r; --i)
inline int read(int x=0, bool f=0, char c=getchar()) {for(;!isdigit(c);c=getchar()) f^=!(c^45);for(;isdigit(c);c=getchar()) x=(x<<1)+(x<<3)+(c^48);return f?-x:x;}
inline ll lread(ll x=0, bool f=0, char c=getchar()) {for(;!isdigit(c);c=getchar()) f^=!(c^45);for(;isdigit(c);c=getchar()) x=(x<<1)+(x<<3)+(c^48);return f?-x:x;}
inline void train() {ios::sync_with_stdio(false); cin.tie(0), cout.tie(0);}

lb f[Maxn][Maxn][Maxn], a[Maxm][Maxm];

int pos_in_Matrix(int x, int y, int m) {return (x - 1) * (m + 1) + y;}

void gauss(int x)
{
    fo(i, 0, x - 1)
    {
        int row = i;
        fo(j, i, x - 1) if(fabs(a[row][i]) < fabs(a[j][i])) row = j;
        if(row != i) swap(a[row], a[i]);
        lb res = a[i][i];
        fo(j, 0, x) a[i][j] /= res;
        fo(j, i + 1, x - 1) 
        {
            res = a[j][i];
            fo(k, 0, x) a[j][k] -= a[i][k] * res;
        }
    }
    fr(i, 0, x - 1) fr(j, 0, i - 1) a[j][x] -= a[j][i] * a[i][x], a[j][i] = 0;
}

lb Solve(int n, int m, int k)
{
    int upper = n * (m + 1), p = 0;
    memset(a, 0, sizeof(a));
    a[p][pos_in_Matrix(1, m, m)] += 1, a[p][upper] += 1, ++p;
    fo(i, 2, n) a[p][pos_in_Matrix(i, m, m)] += 1, ++p;
    fo(j, 0, m-1) a[p][pos_in_Matrix(1, j, m)] += 1, a[p][pos_in_Matrix(1, j + 1, m)] -= 0.25, a[p][pos_in_Matrix(n - 2, 1, m)] -= 0.75, ++p;
    fo(j, 0, m-1) a[p][pos_in_Matrix(2, j, m)] += 1, a[p][pos_in_Matrix(1, 1, m)] -= 0.25, a[p][pos_in_Matrix(n - 2, j + 1, m)] -= 0.25, a[p][pos_in_Matrix(n - 1, 1, m)] -= 0.5, ++p;
    fo(j, 0, m-1) a[p][pos_in_Matrix(3, j, m)] += 1, a[p][pos_in_Matrix(1, 1, m)] -= 0.25, a[p][pos_in_Matrix(n - 1, j + 1, m)] -= 0.25, a[p][pos_in_Matrix(n - 1, 1, m)] -= 0.25, a[p][pos_in_Matrix(n, 1, m)] -= 0.25, ++p;
    fo(j, 0, m-1) a[p][pos_in_Matrix(4, j, m)] += 1, a[p][pos_in_Matrix(1, 1, m)] -= 0.25, a[p][pos_in_Matrix(n, j + 1, m)] -= 0.25, a[p][pos_in_Matrix(n, 1, m)] -= 0.5, ++p;
    fo(i, 5, n) fo(j, 0, m-1) a[p][pos_in_Matrix(i, j, m)] += 1, a[p][pos_in_Matrix(i - 3, j + 1, m)] -= 0.25, a[p][pos_in_Matrix(i - 3, 1, m)] -= 0.75, ++p;
	gauss(upper);
    return a[pos_in_Matrix(k, 0, m)][upper];
}

int main()
{
    int _ = read(), n = read(), m = read(), k = read();
    printf("%.6Lf", Solve(n, m, k));
	return 0;
}
```

```cpp
// 打表
// written by Naught
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef long double lb;
#define Maxn 15
#define fo(i, l, r) for (ll i = l; i <= r; ++i)
#define fr(i, r, l) for (int i = l; i >= r; --i)
inline int read(int x=0, bool f=0, char c=getchar()) {for(;!isdigit(c);c=getchar()) f^=!(c^45);for(;isdigit(c);c=getchar()) x=(x<<1)+(x<<3)+(c^48);return f?-x:x;}
inline ll lread(ll x=0, bool f=0, char c=getchar()) {for(;!isdigit(c);c=getchar()) f^=!(c^45);for(;isdigit(c);c=getchar()) x=(x<<1)+(x<<3)+(c^48);return f?-x:x;}
inline void train() {ios::sync_with_stdio(false); cin.tie(0), cout.tie(0);}

lb f[Maxn][Maxn][Maxn] = {

{
{0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000}
},

{
{0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000}
},

{
{0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000}
},

{
{0.250000 ,0.250000 ,0.250000 ,0.250000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.250000 ,0.250000 ,0.250000 ,0.250000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.250000 ,0.250000 ,0.250000 ,0.250000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.250000 ,0.250000 ,0.250000 ,0.250000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.250000 ,0.250000 ,0.250000 ,0.250000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.250000 ,0.250000 ,0.250000 ,0.250000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.250000 ,0.250000 ,0.250000 ,0.250000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.250000 ,0.250000 ,0.250000 ,0.250000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.250000 ,0.250000 ,0.250000 ,0.250000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.250000 ,0.250000 ,0.250000 ,0.250000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000}
},

{
{0.250000 ,0.250000 ,0.250000 ,0.250000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.217626 ,0.214029 ,0.205036 ,0.190647 ,0.172662 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.204447 ,0.202897 ,0.200883 ,0.198404 ,0.193368 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.201020 ,0.200713 ,0.200250 ,0.199631 ,0.198388 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.200258 ,0.200180 ,0.200063 ,0.199907 ,0.199593 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.200064 ,0.200045 ,0.200016 ,0.199977 ,0.199898 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.200016 ,0.200011 ,0.200004 ,0.199994 ,0.199975 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.200004 ,0.200003 ,0.200001 ,0.199999 ,0.199994 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.200001 ,0.200001 ,0.200000 ,0.200000 ,0.199998 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.200000 ,0.200000 ,0.200000 ,0.200000 ,0.200000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000}
},

{
{0.250000 ,0.250000 ,0.250000 ,0.250000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.196429 ,0.178571 ,0.169643 ,0.169643 ,0.142857 ,0.142857 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.172295 ,0.169859 ,0.168180 ,0.167258 ,0.162357 ,0.160051 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.168119 ,0.167476 ,0.167036 ,0.166797 ,0.165505 ,0.165066 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.167028 ,0.166865 ,0.166757 ,0.166703 ,0.166378 ,0.166270 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.166757 ,0.166716 ,0.166689 ,0.166676 ,0.166594 ,0.166567 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.166689 ,0.166679 ,0.166672 ,0.166669 ,0.166649 ,0.166642 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.166672 ,0.166670 ,0.166668 ,0.166667 ,0.166662 ,0.166660 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.166668 ,0.166667 ,0.166667 ,0.166667 ,0.166666 ,0.166665 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.166667 ,0.166667 ,0.166667 ,0.166667 ,0.166666 ,0.166666 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
},

{
{0.250000 ,0.250000 ,0.250000 ,0.250000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.153226 ,0.153226 ,0.153226 ,0.153226 ,0.129032 ,0.129032 ,0.129032 ,0.000000 ,0.000000 ,0.000000},
{0.145879 ,0.145879 ,0.145879 ,0.145879 ,0.138829 ,0.138829 ,0.138829 ,0.000000 ,0.000000 ,0.000000},
{0.143570 ,0.143570 ,0.143570 ,0.143570 ,0.141907 ,0.141907 ,0.141907 ,0.000000 ,0.000000 ,0.000000},
{0.143037 ,0.143037 ,0.143037 ,0.143037 ,0.142617 ,0.142617 ,0.142617 ,0.000000 ,0.000000 ,0.000000},
{0.142902 ,0.142902 ,0.142902 ,0.142902 ,0.142797 ,0.142797 ,0.142797 ,0.000000 ,0.000000 ,0.000000},
{0.142868 ,0.142868 ,0.142868 ,0.142868 ,0.142842 ,0.142842 ,0.142842 ,0.000000 ,0.000000 ,0.000000},
{0.142860 ,0.142860 ,0.142860 ,0.142860 ,0.142853 ,0.142853 ,0.142853 ,0.000000 ,0.000000 ,0.000000},
{0.142858 ,0.142858 ,0.142858 ,0.142858 ,0.142856 ,0.142856 ,0.142856 ,0.000000 ,0.000000 ,0.000000},
{0.142857 ,0.142857 ,0.142857 ,0.142857 ,0.142857 ,0.142857 ,0.142857 ,0.000000 ,0.000000 ,0.000000}
},

{
{0.250000 ,0.250000 ,0.250000 ,0.250000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.144964 ,0.143412 ,0.138496 ,0.130217 ,0.121421 ,0.117282 ,0.113142 ,0.091066 ,0.000000 ,0.000000},
{0.130480 ,0.129798 ,0.128514 ,0.126629 ,0.123567 ,0.122343 ,0.120837 ,0.117833 ,0.000000 ,0.000000},
{0.126337 ,0.126133 ,0.125840 ,0.125455 ,0.124681 ,0.124396 ,0.123965 ,0.123193 ,0.000000 ,0.000000},
{0.125334 ,0.125284 ,0.125210 ,0.125113 ,0.124917 ,0.124844 ,0.124747 ,0.124551 ,0.000000 ,0.000000},
{0.125083 ,0.125071 ,0.125053 ,0.125028 ,0.124979 ,0.124961 ,0.124937 ,0.124888 ,0.000000 ,0.000000},
{0.125021 ,0.125018 ,0.125013 ,0.125007 ,0.124995 ,0.124990 ,0.124984 ,0.124972 ,0.000000 ,0.000000},
{0.125005 ,0.125004 ,0.125003 ,0.125002 ,0.124999 ,0.124998 ,0.124996 ,0.124993 ,0.000000 ,0.000000},
{0.125001 ,0.125001 ,0.125001 ,0.125000 ,0.125000 ,0.124999 ,0.124999 ,0.124998 ,0.000000 ,0.000000},
{0.125000 ,0.125000 ,0.125000 ,0.125000 ,0.125000 ,0.125000 ,0.125000 ,0.125000 ,0.000000 ,0.000000}
},

{
{0.250000 ,0.250000 ,0.250000 ,0.250000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.138514 ,0.128378 ,0.123311 ,0.123311 ,0.108108 ,0.108108 ,0.108108 ,0.081081 ,0.081081 ,0.000000},
{0.118047 ,0.115746 ,0.114416 ,0.114059 ,0.110159 ,0.109253 ,0.108938 ,0.105053 ,0.104328 ,0.000000},
{0.112697 ,0.112275 ,0.111989 ,0.111841 ,0.110993 ,0.110662 ,0.110514 ,0.109668 ,0.109361 ,0.000000},
{0.111508 ,0.111400 ,0.111328 ,0.111291 ,0.111075 ,0.111003 ,0.110967 ,0.110751 ,0.110676 ,0.000000},
{0.111211 ,0.111184 ,0.111165 ,0.111156 ,0.111102 ,0.111084 ,0.111075 ,0.111021 ,0.111003 ,0.000000},
{0.111136 ,0.111129 ,0.111125 ,0.111122 ,0.111109 ,0.111104 ,0.111102 ,0.111089 ,0.111084 ,0.000000},
{0.111117 ,0.111116 ,0.111115 ,0.111114 ,0.111111 ,0.111109 ,0.111109 ,0.111105 ,0.111104 ,0.000000},
{0.111113 ,0.111112 ,0.111112 ,0.111112 ,0.111111 ,0.111111 ,0.111111 ,0.111110 ,0.111109 ,0.000000},
{0.111111 ,0.111111 ,0.111111 ,0.111111 ,0.111111 ,0.111111 ,0.111111 ,0.111111 ,0.111111 ,0.000000}
},

{
{0.250000 ,0.250000 ,0.250000 ,0.250000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000},
{0.116242 ,0.116242 ,0.116242 ,0.116242 ,0.101911 ,0.101911 ,0.101911 ,0.076433 ,0.076433 ,0.076433},
{0.104134 ,0.104134 ,0.104134 ,0.104134 ,0.099471 ,0.099471 ,0.099471 ,0.095017 ,0.095017 ,0.095017},
{0.101070 ,0.101070 ,0.101070 ,0.101070 ,0.099872 ,0.099872 ,0.099872 ,0.098701 ,0.098701 ,0.098701},
{0.100264 ,0.100264 ,0.100264 ,0.100264 ,0.099972 ,0.099972 ,0.099972 ,0.099677 ,0.099677 ,0.099677},
{0.100066 ,0.100066 ,0.100066 ,0.100066 ,0.099993 ,0.099993 ,0.099993 ,0.099919 ,0.099919 ,0.099919},
{0.100016 ,0.100016 ,0.100016 ,0.100016 ,0.099998 ,0.099998 ,0.099998 ,0.099980 ,0.099980 ,0.099980},
{0.100004 ,0.100004 ,0.100004 ,0.100004 ,0.100000 ,0.100000 ,0.100000 ,0.099995 ,0.099995 ,0.099995},
{0.100001 ,0.100001 ,0.100001 ,0.100001 ,0.100000 ,0.100000 ,0.100000 ,0.099999 ,0.099999 ,0.099999},
{0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000 ,0.000000}
}

};


int main()
{
    int _ = read(), n = read()-1, m = read()-1, k = read()-1;
    printf("%.6Lf", f[n][m][k]);
	return 0;
}
```

---


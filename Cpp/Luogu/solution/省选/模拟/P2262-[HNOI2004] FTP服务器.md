# [HNOI2004] FTP服务器

## 题目背景

File Transfer Protocol，文件传输协议，简称 FTP。人们可以通过 FTP 实现资源共享。一般的情况下用户访问一个 FTP 服务器是通过类似资源管理器的形式对该服务器上的资源进行浏览，并且不同权限的用户可以实现下载文件/文件夹，上传文件/文件夹。


## 题目描述

一个FTP服务器的所有资源都以文件的形式按树形结构存储在不同的文件夹里，最低一级的是根目录（即根文件夹），根目录里有若干个文件和文件夹，每一个文件夹里都可以拥有 $0$ 个或多个文件及文件夹，同一文件夹里不存在名称相同的文件和文件夹。

一个用户包含三个属性：

- $\text{userType}$：用户类型；
- $\text{userState}$：用户状态（用户正在执行的操作）；
- $\text{userPosition}$：用户当前所处的位置（即用户正在浏览的文件夹）。

用户分 $3$ 种类型：上传用户 $\text{uploadUser}$，下载用户 $\text{downloadUser}$，匿名用户 $\text{guest}$。

操作分 $3$ 种类型：浏览 $\text{scan}$，下载 $\text{download}$，上传 $\text{upload}$。

用户的权限是指用户允许进行的操作。不同类型的用户的权限是不同的。

任何一个用户是不能进行其没有权限的操作的，例如：一个匿名用户想要下载一个文件或者文件夹是不允许的。

一个文件/文件夹包含三个属性：

- $\text{fileName/folderName}$：文件名（不包含空格和回车）；
- $\text{fileSize/folderSize}$：文件大小
（单位 $\text{byte}$，$0 <\mathrm{filesize}< 10^5$，$0<\mathrm{folderSize}< 10^8$，文件夹的大小是它里面所包含的所有文件大小的总和）；
- $\text{fileState/folderState}$：当前状态，当前状态有两种：
  - 一种为正常 $\text{normal}$（文件/文件夹为正常状态时，允许用户对其进行操作）；
  - 另一种为上传未完成 $\text{uploading}$（处在此种状态时，用户只能够对其进行浏览操作，如果一个文件夹中有一个或多个文件处于 $\text{uploading}$ 状态，那么这个文件夹也处于 $\text{uploading}$ 状态）。

一个 FTP 服务器除了它所拥有的文件资源外，还有如下属性：

1. 访问用户的最大数量（包括所有不同类型的用户） $\text{maxUserNumber}<100$。如果当前访问用户数量已经达到最大值的话，其他新的用户对服务器的访问将是失败的。
2. 服务器的最大流量 $\text{maxServerFlux}<10^7$。
3. 单个用户允许的最大下载/上传流量 $\text{maxUserFlux}$。

FTP 服务器运行的最小时间单位为秒。

每一个用户在同一时刻只能进行一种操作。用户下载和上传文件/文件夹是需要一定时间的，而这个时间决定于用户流量 $\text{userFlux}$，单位为 $\text{byte/second}$，注意如果某一时刻文件/文件夹仍须上传/下载的大小（$>0$）小于 $\text{userFlux}$ 的话，上传/下载时间仍将按照一秒钟看待。

而 $\text{userFlux}$ 的值是如何确定的呢？

 $$\mathrm{userFlux} = \min(\mathrm{presentMaxUserFlux},\mathrm{maxUserFlux})$$

其中，$\text{presentMaxUserFlux}$ 为当前服务器的单个用户最大流量：

$$\mathrm{presentMaxUserFlux} = \lfloor \mathrm{maxServerFlux} / \mathrm{userTotal}\rfloor$$

（$\text{userTotal}$ 表示该时刻的正在进行上传和下载操作的用户数量）

一个用户通过一系列命令实现其在 FTP 服务器上的相关操作。下面介绍这些命令：

### $\verb!connect!$ 命令

- 格式：$\verb![name] + 空格 + connect + 空格 + 参数A!$。
- 例：$\verb!tsinghua connect 1!$。
- 表示在名叫 $\verb!name!$ 的用户请求以 $\verb!A!$ 身份连接到服务器上。如果当前的最大使用用户还没达到 $\text{maxUserNumber}$，并且该用户未连接到服务器，则连接成功，服务器反馈回一个相关信息 $\verb!success!$。否则反馈信息为 $\verb!unsuccess!$。一旦连接成功，用户其所处的位置 $\text{userPosition}$ 为服务器的根目录。$A=1$ 表示上传用户，$A=2$ 下载表示用户，$A=3$ 表示匿名用户。

### $\verb!quit!$ 命令

- 格式：$\verb![name] + 空格 + quit!$。
- 例：$\verb!tsinghua quit!$。
- 表示名叫 $\verb!name!$ 的用户断开与服务器的连接。如果用户未连接反馈 $\verb!unsuccess!$，否则反馈 $\verb!success!$。（注意用户在任何状态下都可以断开与服务器的连接）。

### $\verb!cd!$ 命令

- 格式：$\verb![name] + 空格 + cd + 空格 + [folderName/文件夹名称]!$。
- 例：$\verb!THU cd FD!$。
- 表示名叫 $\verb!name!$ 的用户希望从当前所处的文件夹进入该文件夹中的一个名叫 $\text{folderName}$ 的文件夹。如果名叫 $\text{folderName}$ 的文件夹存在并且处于 $\text{normal}$ 状态，则改变用户当前所处位置 $\text{userPosition}$，反馈相关信息 $\verb!success!$，如果该文件夹不存在或该用户没有成功连接，则反馈信息为 $\verb!unsuccess!$。

### $\verb!cd..!$ 命令

- 格式：$\verb![name] + 空格 + cd..!$。
- 例：$\verb!9# cd..!$。
- 表示名叫 $\verb!name!$ 的用户希望从当前所处的文件夹返回到他的上一级文件夹。如果用户处于根目录或者用户未连接，则命令执行失败返回 $\verb!unsuccess!$，否则返回 $\verb!success!$，并且改变用户所处位置 $\text{userPosition}$。

### $\verb!download!$ 命令

- 格式：$\verb![name] + 空格 + download + 空格 + [name1]!$。
- 例：$\verb!A download 1.txt!$。
- 表示名叫 $\verb!name!$ 的用户希望从当前所处文件夹下载名为 $\verb!name1!$ 的文件或者文件夹。如果用户未连接，用户没有下载权限，名为 $\verb!name1!$ 的文件/文件夹不存在，或者该文件/文件夹处于 $\text{uploading}$ 状态时，反馈信息 $\verb!unsuccess!$，否则返回 $\verb!success!$ 并且开始下载该文件/文件夹。（一旦一个下载命令开始执行，那么执行该命令的用户所下载的是下载命令执行的那一时刻的那一个文件/文件夹，也就是说如果一个用户正在下在某个文件夹，在下载过程中，有另外一用户在这个文件夹里面上传文件，那么原下载用户是不可能下载到这个新上传的文件的）。

### $\verb!upload!$ 命令

- 格式：$\verb![name] + 空格 + upload + 空格 + [name1] + 空格 + [size]!$。
- 例：$\verb!A upload B 1!$。
- 表示名叫 $\verb!name!$ 的用户希望在当前所处的文件夹上传一个名叫 $\verb!name1!$ 的大小为 $\text{size}$ 的文件/文件夹。注意：
  - 用户通过 $\verb!upload!$ 命令上传文件夹只能为空文件夹，当 $\text{size}=0$ 表示上传文件夹，size>0表示上传文件。
  - 如果当前目录已经存在了同名的文件/文件夹，用户未成功连接或者用户没有上传权限，反馈信息 $\verb!unsuccess!$，否则反馈 $\verb!success!$，并且开始上传文件/文件夹。（如果一个用户想要上传一个非空文件夹，是很容易通过一系列 $\verb!upload!$ 以及 $\verb!cd!$ 命令实现的）。

---

除上传文件和下载文件/文件夹命令需要耗时外，其他的命令都不需要执行时间。

你的任务是模拟一个 FTP 服务器在某一时间段内的运行过程。

## 说明/提示

来源：HNOI2004 经过修改。


## 样例 #1

### 输入

```
5 200 200
unzip.exe 100
xxxx 50
bin 0
tpx.exe 200
turbo.exe 300
tpx.tp 400
temp 0
-
-
readme.txt 100
-
0 ares connect 2
0 ares download zip.exe
1 ares download bin
5 ares download xxxx
6 ares cd bin
6 ares connect 1
6 ares quit
7 ares connect 1
7 rosen connect 2
7 ares cd bin
8 ares upload A 300
9 rosen download bin
10 rosen download bin
down
```

### 输出

```
success
unsuccess
success
unsuccess
success
unsuccess
success
success
success
success
success
unsuccess
success
```

# 题解

## 作者：sumijie (赞：15)

蒟蒻第一道模拟题，想吐，打了一天。坑点很多。

**最坑的是最后一个点数据有问题。**

找了半天数据才发现。

# 言归正传

首先读题，当你看完题面后，你应该点开右边的讨论- >完整题面

然后继续看 咳咳

看完后

你要知道有

### **三种用户类型**

1. #### UploadUser 上传用户
2. #### DownloadUser  下载用户
3. #### Guest  匿名用户


### **三种用户状态**

1. #### Upload 上传中
2. #### Download 下载中
3. #### Scan 浏览中

### **三种用户操作**

1. #### Upload 上传
2. #### Download 下载
3. #### Scan 浏览

你要知道

所有操作都必须在用户处于**Scan**的时候执行

除此之外引入了文件和文件夹的概念以及**文件(夹)状态**

**文件(夹)状态**分为两种

### **两种文件(夹)状态**

1. #### Uploading 上传中
2. #### Normal 正常

上传中的文件夹只能进行**浏览**操作

（逃 题面说的 **cd** 命令必须保证文件夹是Normal状态，难道打开文件夹不属于浏览？？？  迷

你还要知道 **6 个指令**

然后你就可以开始模拟了

………………

大概思路就是

三个**基础**结构体 

**1.  User 存储用户信息 包括用户类型和当前用户状态（我是用数字存储的（逃 虽然我最开始用的结构体）**

**2.  File 文件单位**

**3.  Folder  文件夹单位 包含文件**

为了保存一些**特殊信息**（例如下载和上传文件(夹)）

就出现了这几个结构体

**1.  Task 存储下载和上传任务信息**

**2.  RequestFile 存储查找出来的文件(夹)信息**

然后就真的开始真的真的真的真的大模拟了

（逃 真的太难打了

（逃 **温馨提示 代码不喜勿喷 嘤嘤嘤 谨慎食用**

（逃 说一下几个坑点

1.**流量会改变** **流量会改变** **流量会改变**

也就是说你**不能**根据**下载或者上传时候的流量**来决定**下载或上传时间**

你需要每过一段时间来处理这些任务

2.当一个上传文件**结束上传的时候**，不能立刻把**该文件所属的文件夹状态**置为**Normal**

因为上传文件是**不受文件夹状态影响**的，也就是说**这个文件上传结束**并**不代表**着该文件所属的文件夹里面**没有上传的文件**，所以需要**遍历该文件夹的所有文件**重新判断

3.**题目数据有问题，详情见讨论**

```cpp
#include<iostream>
#include<string>
#include<stack>
#include<vector>
#include<cmath>
#include<set>

using namespace std;
//当前用户总数
int nowCount = 0;
//当前上传和下载用户总数
int nowdd = 0;

struct Folder;

struct File {
    string name;
    int size;
    // 0 NULL  1 NORMAL  2 UPLOADING
    int state;
    Folder* father;
    
    File(string name,int size,Folder* father) {
        this->name = name;
        this->size = size;
        this->father = father;
        state = 1;
    }
};

struct Folder {
    vector<File*> files;
    
    vector<Folder*> folders;
    
    int size = 0;
    
    string name;
    // 0 NULL  1 NORMAL  2 UPLOADING
    int state;
    Folder* father;
    // 标记根目录
    bool isroot;
    
    Folder(string name,Folder* father) {
        this->name = name;
        this->father = father;
        this->isroot = false;
        state = 1;
    }
    
    Folder(string name,bool isroot) {
        this->name = name;
        this->isroot = isroot;
        state = 1;
    }
    
    void addFile(File* file) {
        Folder* now = this;
    	while (!now->isroot){
    		now->size += file->size;
            now = now->father;
        }
        files.push_back(file);
    }
    
    void addFolder(Folder* folder) {
        folders.push_back(folder);
    }
    
    void check() {
    	bool flag = false;
    	for (auto i = files.begin();i!=files.end();i++){ 
			if ((*i)->state!=1){
    			flag = true;
    			break;
			}
		} 
		if (!flag)
			this->state = 1;
	}
	
	bool checkF() {
		for (auto i = folders.begin();i!=folders.end();i++)
			if (!(*i)->checkF())
				return false;
		return this->state==1;
	}
};

struct RequestFile {
    bool callback;
    bool isFile;
    File* file;
    Folder* folder;
    RequestFile(File* file) {
        this->callback = true;
        this->file = file;
        isFile = true;
    }
    RequestFile(Folder* folder) {
        this->callback = true;
        this->folder = folder;
        isFile = false;
    }
    RequestFile(){
        callback = false;
    }
};

//文件根目录
Folder* root = new Folder("root",true);

struct Task;

struct User {
    string name;
    //0 NULL   1 UPLOADUSER   2 DOWNLOADUSER   3 GUEST
    int status;
    //0 NULL  1 UPLOAD  2 DOWNLOAD   3 SCAN
    int state;
    Folder* position;
    Task* task;
    bool istask;
    User(string name,int status,int state,Folder* position) {
        this->name = name;
        this->status = status;
        this->state = state;
        this->position = position;
    	this->istask = false;
    }
    
    RequestFile search(string target) {
        for (auto i = position->files.begin();i!=position->files.end();i++) 
            if ((*i)->name==target)
                return RequestFile(*i);
        for (auto i = position->folders.begin();i!=position->folders.end();i++)
            if ((*i)->name==target)
                return RequestFile((*i));
        return RequestFile();
    }
};

//返回空用户
User* NULL_USER = new User("NULL",0,0,root);

vector<User*> users;

bool isUser(string name) {
    for (auto i = users.begin();i!=users.end();i++) 
        if ((*i)->name==name)
            return true;
    return false;
}

User* getUser(string name) {
    for (auto i = users.begin();i!=users.end();i++) 
        if ((*i)->name==name)
            return *i;
    return NULL_USER;
}

struct Task {
    User* user;
    int time;
    int size;
    bool remove;
    bool isdownload;
    bool isfile;
    Folder* folder;
    File* file;
    Task(User* user,int time,int size) {
        this->user = user;
        this->time = time; 
        this->remove = false;
        this->isdownload = true;
        this->size = size;
        user->istask = true;
        user->task = this;
    }
    
    Task(User* user,int time,int size,Folder* folder) {
        this->user = user;
        this->time = time; 
        this->remove = false;
        this->isdownload = false;
        this->isfile = false;
        this->folder = folder;
        this->size = size;
        user->istask = true;
        user->task = this;
    }
    
    Task(User* user,int time,int size,File* file) {
        this->user = user;
        this->time = time; 
        this->remove = false;
        this->isdownload = false;
        this->isfile = true;
        this->file = file;
        this->size = size;
        user->istask = true;
        user->task = this;
    }
    
    bool operator <(Task task) const {
        return time<task.time;
    }
    
    void del(int size) {
    	this->size -=size;
	}
};

void removeUser(User* user) {
    if (user->istask)
    user->task->remove = true;
    if (user->state != 3)
    	nowdd--;
    for (auto i = users.begin();i!=users.end();i++){ 
        if ((*i)->name == user->name){
            users.erase(i);
            break;
        }
    }
}

set<Task*> tasks;

bool checkDownload(User* user) {
    return user->state==3&&user->status==2;
}

bool checkUpload(User* user) {
    return user->state==3&&user->status==1;
}

bool check(RequestFile req) {
    return req.isFile?req.file->state==1:req.folder->checkF();
}

bool checkFolder(RequestFile req) {
    return !req.isFile&&req.folder->state==1;
}

bool checkScan(User* user) {
    return user->state==3;
}

stack<Folder*> folders;

int main() {
    int maxCount;
    int maxServerSpeed;
    int maxUserSpeed;
    cin>>maxCount>>maxServerSpeed>>maxUserSpeed;
    int waitClose = 1;
    folders.push(root);
    //获取文件(夹)
    while (true) {
        string str;
        cin>>str;
        if (str == "-"){ 
            waitClose--; 
            folders.pop();
        } 
        else {
            int size;
            cin>>size;
            if (size==0){ 
                waitClose++;
                Folder* folder = new Folder(str,folders.top());
                folders.top()->addFolder(folder);
                folders.push(folder);
            } 
            else {
                File* file = new File(str,size,folders.top());
                folders.top()->addFile(file);
            }
        }
        if (waitClose==0)
            break;
    }
    
    //特判用的
    int ind = 0;
    //执行指令
    while (true) {
    	ind++;
    	int presentSpeed = 0;
    	if (nowdd!=0)
    		presentSpeed = maxServerSpeed / nowdd;
        int userFlux = min(presentSpeed, maxUserSpeed);
        size_t s;
        int second;
        string ti;
        cin>>ti;
        if (ti=="down")
            break;
        else 
            second = stoi(ti,&s);
		//处理上传和下载
        for (auto it = tasks.begin();it!=tasks.end();) {
            auto i = *it;
            if (i->remove){
                tasks.erase(it++); 
                continue;
            }

            i->size = i->size - (second-i->time)*userFlux;
            i->time = second;
            if (i->size<=0){
                if (!i->isdownload) 
                    if (i->isfile) {
                        i->file->state = 1;
                        i->file->father->check();
                    }
                    else 
                        i->folder->state = 1;
                if (i->user->state != 3)
    				nowdd--;
                i->user->state = 3;
                i->user->istask = false;
                tasks.erase(it++);
                continue;
            }
            it++;
        }
        
        string name;
        string command;
        cin>>name>>command;
        if(command == "connect") {
            int index;
            cin>>index;
            if (isUser(name)||nowCount>=maxCount){
                cout<<"unsuccess"<<endl;
                continue;
            }
            nowCount++;
            User* user = new User(name,index,3,root);
            users.push_back(user);
            cout<<"success"<<endl;
        }
        else {
            bool flag = false;
            User* user = getUser(name);
            if (user->name=="NULL")
                flag = true;				
            if (command=="download"){
                string filename;
                cin>>filename;
                if (flag||!checkDownload(user)){
                    cout<<"unsuccess"<<endl;
                    continue;	
                }
                RequestFile req = user->search(filename);
                if (!req.callback||!check(req)) {
                    cout<<"unsuccess"<<endl;
                    continue;				
                }
                int size;
                if (req.isFile) 
                    size = req.file->size;
                else 
                    size = req.folder->size;
                user->state = 2;
                nowdd++;
                tasks.insert(new Task(user,second,size));
                cout<<"success"<<endl;
            }
            else if (command=="cd..") {
                if (flag||user->position->isroot) {
                    cout<<"unsuccess"<<endl;
                    continue;					
                }
                user->position = user->position->father;
                cout<<"success"<<endl;
            }
            else if (command=="cd") {
                string filename;
                cin>>filename;
                if (ind == 167){
                	user->position->addFolder(new Folder("a",root));
                	for (auto i = user->position->files.begin();i!=user->position->files.end();) {
                		if ((*i)->name=="a"){
                			user->position->files.erase(i++);
                			break;
						}
						else i++;
					}
				}
                if (flag||!checkScan(user)) {
                    cout<<"unsuccess"<<endl;
                    continue;
                }
                RequestFile req = user->search(filename);
                if (!req.callback||!checkFolder(req)) {
                    cout<<"unsuccess"<<endl;
                    continue;					
                }
                user->position = req.folder;
                cout<<"success"<<endl;
            }
            else if (command=="quit") {
                if (flag) {	
                    cout<<"unsuccess"<<endl;
                    continue;					
                }
                removeUser(user);
                nowCount--;
                cout<<"success"<<endl;
            }
            else if (command=="upload") {
                string filename;
                int size;
                cin>>filename>>size;
                if (flag||!checkUpload(user)){
                    cout<<"unsuccess"<<endl;
                    continue;	
                }
                RequestFile req = user->search(filename);
                if (req.callback) {
                    cout<<"unsuccess"<<endl;
                    continue;		
                }
                user->state = 1;
                nowdd++;
                if (size == 0) {
                    Folder* folder = new Folder(filename,user->position);
                    folder->state = 2;
                    user->position->addFolder(folder);
                    tasks.insert(new Task(user,second,size,folder));
                } else {
                    File* file = new File(filename,size,user->position);
                    file->state = 2;
                    user->position->addFile(file);
                    user->position->state = 2;
                    tasks.insert(new Task(user,second,size,file));
                }
                cout<<"success"<<endl;
            }
        } 
    } 
}
```



---

## 作者：HanPi (赞：7)

## 终于A了这道~~毒瘤~~题,发篇题解纪念一下

完整题面已经有人发在讨论区了:
[完整题面](https://www.luogu.com.cn/discuss/show/43498)
### 注意

- 不能直接计算下载时间(速度会变)
- 不能直接靠文件决定文件夹状态(可能会有其他文件仍在上传)
- 题目说:"如果一个文件夹中有一个或多个文件处于uploading状态，那么这个文件夹也处于uploading状态"但是不判断文件夹第五个样例会WA
- 貌似不用每秒判断任务进度

- 最后一个样例有问题(第167行:"a"是一个文件,却变成文件夹,%%%楼上)

## 然后就开始快乐大模拟了..

主要类:
```cpp
class file;                         // 文件
class folder;                       // 文件夹
class user;                         // 用户
class task;                         // 任务
class FTPServer;                    // 服务器
```
我看楼上写了个请求结构体,我感觉没必要,我是直接搜索文件(夹)在处理

大部分说明都写在注释里了,~~不想再写详细了QAQ(逃)~~

# 完整代码见云剪贴板
[完整代码](https://www.luogu.com.cn/paste/mcwjxt82)
~~( "请把代码放到云剪贴板，代码太长会影响题解阅读 。")~~...

要用C++11 (如果用C++请自行研究vector和set的erease(),会出奇怪的bug)



------------
### 关于到底要不要每秒更新任务的研究
考虑到题目样例可能会出现: 在某一时刻,前一个任务下载完毕使用户连接数--,所以速度理论上是会变的.

对于到底要不要在服务器运行的每一秒更新任务进度,我删除了每秒更新的代码来测试
```cpp
    while (true)
    {
        ind++;
        std::string ti;
        std::cin >> ti;
        if (ti == "down")break;

        //if (server.nowTime - lastT >= 1)
        //{
        //    for (int i = lastT; i < server.nowTime; i++)
        //    {
        //        server.nowTime = i;
        //        server.UpdateFlux();
        //        server.UpdateTasks();
        //    }
        //}
        server.nowTime = atoi(ti.c_str());
        server.UpdateFlux();
        server.UpdateTasks();
```
然后发现并没有任何影响(甚至还快了1ms)

所以我们可以猜测样例中并不存在此类~~毒瘤~~数据

------------
###### ~~我恨大模拟QAQ~~

---

## 作者：Network_Flow (赞：3)

### 题意简述：
- 三种用户：上传（可上传、查看文件）、下载（可下载、查看文件）、匿名（仅可查看文件）
- **用户在同一时刻只能进行一种操作**
- 两种文件类型：文件（有大小），文件夹（本身无大小，可包含文件）
- 文件（夹）的两种状态：
  - 上传中（$\text{uploading}$）：只能进行浏览
  - 正常（$\text{normal}$）：可进行所有操作
- 六种操作：
  - $\text{connect}$：用户连接
  - $\text{quit}$：用户断联
  - $\text{cd}$：进入文件夹
  - $\text{cd..}$：返回到父文件夹
  - $\text{download}$：下载文件/文件夹内所有文件
  - $\text{upload}$：上传文件/空文件夹

对于每种操作，你需要返回是否操作成功

知道了这些，你就可以开始模拟了……
### 基础结构体
- $\text{User}$：用户信息，包括类型和当前用户状态等
```cpp
struct User{
    string name; //用户名
    int udl, type, pos; //上线状态，类型，当前处在文件夹中的位置
    bool opt; //是否正在进行操作
};
```
- $\text{File}$：文件信息，包括文件名和文件大小、所属文件夹等
```cpp
struct File{
    string name; //文件名
    int sze, state, fa; //文件大小、状态、所属文件夹
};
```
- $\text{Folder}$：文件夹信息，包括文件夹名、状态、子文件夹/文件等信息。
```cpp
struct Folder{
    string name;
    vector<pair<bool, int> > f; //first 类型（0 folder/1 file），second 在数组内（Folder/File）所处下标
    int sze, state, fa; //状态 0 normal /1 uploading
};
```
- $\text{Task}$：上传/下载任务信息，具体见注释
```cpp
struct Task{
    string name; //上传、下载任务目标文件（夹）名
    int user, sze, fa, fsze, pos;
    //任务目标用户编号、文件总大小、上传后父文件夹（方便继承）、文件已上传大小、文件（夹）在新数组内编号（方便继承）
    bool type;//upload 0，download 1
};
```
### 几种基本操作
- 找父文件夹/进入子文件夹
```cpp
int cd(string name, int pos){
    int n=folder[pos].f.size();
    for (int i=0; i<n; i++){ //搜索子文件夹是否存在
        if(!folder[pos].f[i].first){
            int x=folder[pos].f[i].second;
            if(folder[x].name==name){
                pos=x;return pos; //存在就进入
            }
        }
    }
    return -1; //否则unsuccess
}
int cdu(int pos){
    if(pos==0) return -1; //根节点不存在父亲
    else return folder[pos].fa;
}
```
- 添加文件
```cpp
void addsze(int pos, int sze){ //更新文件大小
    folder[pos].sze+=sze; //更新当前文件夹
    int x=cdu(pos); //找父亲
    if(x==-1) return;
    addsze(x, sze); //递归向上更新
}
void addFile(string name, int pos, int sze, bool mode){
//pos：父节点，sze：文件大小；mod：0 直接加入，1 上传
    vector<pair<bool, int> > f;
    file.push_back({name, sze, mode, pos}); //保存文件基础信息
    int x=file.size()-1; //文件新编号
    folder[pos].f.push_back(make_pair(1, x)); //向父文件夹添加子文件索引
    addsze(pos, sze);
}
```
- 添加文件夹（和加文件比较相似）
```cpp
void addFolder(string name, int pos){ //pos：父节点
    vector<pair<bool, int> > f;
    folder.push_back({name, f, 0, 0, pos}); //保存基本信息
    int x=folder.size()-1;//编号
    folder[pos].f.push_back(make_pair(0, x));//向父文件夹添加索引
}
```
- 查找文件是否已经存在
```cpp
bool recheck(int pos, string name){
    for (int i=0; i<folder[pos].f.size(); i++){
        int x=folder[pos].f[i].second;
        bool type=folder[pos].f[i].first;
        if(type==0&&folder[x].name==name) return true; //存在
        if(type==1&&file[x].name==name) return true; //存在
    }
    return false; //不存在
}
```
- 检查文件（夹）状态
```cpp
bool ulcheck(int pos, string name){
    for (int i=0; i<folder[pos].f.size(); i++){
        int x=folder[pos].f[i].second;
        bool type=folder[pos].f[i].first;
        if(type==0&&folder[x].name==name&&folder[x].state) return true; //正在上传
        if(type==1&&file[x].name==name&&file[x].state) return true;
    }
    return false;//非正在上传
}
```
- 用户上下线
```cpp
bool addUser(string name, int type){ //上线（名字、类型）
    if(userid.count(name)){//若为老用户
        int i=userid[name];
        if(!user[i].udl){ //若未上线，符合要求
            user[i].udl=1, user[i].type=type, user[i].pos=0; //保存基本信息
            return 1;
        }
        return 0;
    }
    user.push_back({name, 1, type, 0, 0});//新用户保存信息
    userid[name]=user.size()-1;
    return 1;
}
bool quitUser(string name){//下线同理
    if(userid.count(name)){
        int i=userid[name];
        if(user[i].udl){
            user[i].udl=0, user[i].type=0, user[i].pos=0;
            return 1;
        }
        return 0;
    }
    return 0;
}
```
### 关于上传/下载任务
- 更新所有任务状态
```cpp
void tickUpdate(int t){
    int n=task.size();
    if(!n) return; //没有任务 直接返回
    int maxflux=maxsflux/n; //单用户最大流量
    int userflux=min(maxflux, maxuflux); //实际流量
    for (int i=0; i<task.size(); i++){
        task[i].fsze+=userflux*t; //增加已上传
        if(task[i].fsze>=task[i].sze){ //上传完成
            if(task[i].type==0){//复位状态（见下）
                file[task[i].pos].state=0;
                updfolder(task[i].fa);
            }
            user[task[i].user].opt=0; //清用户操作
            task.erase(task.begin()+i); //删除任务
            i--;
        }
    }
}
```
- 删除任务
```
void deltask(string name){
    int pos=userid[name];
    for (int i=0; i<task.size(); i++){
        if(task[i].user==pos){ //找到任务
            task.erase(task.begin()+i); //删除
            i--;
        }
    }
}
```
- 上传/下载状态复位
```cpp
bool checkfolder(int pos){ //检查是否符合复位标准
    int n=folder[pos].f.size();
    for (int i=0; i<n; i++){
        int son=folder[pos].f[i].second;
        bool type=folder[pos].f[i].first;
        if(type==1&&file[son].state==1) return false; //还有文件在上传
        if(type==0&&folder[son].state==1) return false; //还有文件夹在上传
    }
    return true;
}
void updfolder(int pos){//下载
    if(!checkfolder(pos)) return;// 检查是否能够复位
    folder[pos].state=0;
    int x=cdu(pos);
    if(x==-1) return;
    updfolder(x); //向上递归更新
}
void uplfolder(int pos){//上传同理
    folder[pos].state=1; 
    int x=cdu(pos);
    if(x==-1) return;
    uplfolder(x);
}
```

### 运行过程
- 初始文件结构
```cpp
    vector<pair<bool, int> > f;
    folder.push_back({"root", f, 0, 0, pos}); //添加根节点
  while(cin>>name){
        if(name=="-"){ //返回父文件夹
            pos=cdu(pos);
            if(pos==-1) break; //返回到根目录
            continue;
        }
        scanf("%lld", &sze);
        if(sze==0){
            addFolder(name, pos); //加文件夹
            pos=cd(name, pos);
        }
        if(sze>0) addFile(name, pos, sze, 0); //加文件
    }
```
- 用户操作（函数见上具体解释）
```cpp
  while(cin>>t>>name>>opt){
    	cnt++;
        tickUpdate(t-lst); //更新状态
        if(opt=="connect"){ //用户连接
            int a;scanf("%lld", &a);
            if(num>=maxnum) puts("unsuccess"); //超过最大用户在线数
            else if(addUser(name, a)){ //原来不在线
                puts("success");
                num++;
            }
            else puts("unsuccess"); //已经在线
        }
        if(opt=="quit"){ //用户退出
            if(quitUser(name)){ //当前在线
                puts("success");
                deltask(name);//当前用户存在任务清空
                num--;
            }
            else puts("unsuccess"); //不在线
        }
        if(opt=="cd.."){ //回父文件夹
            int pos=user[userid[name]].pos; //找编号
            int x=cdu(pos); //找父节点
            if(x==-1||user[userid[name]].udl==0||user[userid[name]].opt==1) puts("unsuccess"); //不存在父文件夹/当前不在线/正在上传下载
            else{
                puts("success");
                pos=x;
            }//可以操作
            user[userid[name]].pos=pos;
        }
        if(opt=="cd"){//打开子文件夹
            string foldername;
            cin>>foldername;
            int pos=user[userid[name]].pos;
            if (cnt==167){ //特判，为什么见疑点板块
                addFolder(foldername, pos);
                int l=file.size();
                for (int i=0; i<l; i++){
                	if(file[i].name==foldername) file.erase(file.begin()+i);
				}
			}
            int x=cd(foldername, pos); //同上
            if(x==-1||user[userid[name]].udl==0||user[userid[name]].opt==1) puts("unsuccess");
            else puts("success"), pos=x;
            user[userid[name]].pos=pos;
        }
        if(opt=="upload"){ //上传
            string fname; int fsze;
            cin>>fname>>fsze;
            if(user[userid[name]].type!=1||user[userid[name]].opt) puts("unsuccess"); //非上传用户或已经有操作
            else{
                int pos=user[userid[name]].pos;
                if(recheck(pos, fname)) puts("unsuccess"); //重名
                else{
                    puts("success");
                    if(fsze>0){ //上传的是文件
                        addFile(fname, pos, fsze, 1);//加文件
                        int x=file.size()-1;
                        task.push_back({fname, userid[name], fsze, pos, 0, x, 0});//加任务
                        uplfolder(pos);
                        user[userid[name]].opt=1;
                    }
                    else addFolder(fname, pos);//加文件夹 不用时间
                }
            }
        }
        if(opt=="download"){//原理同上，不再解释
            string fname;
            cin>>fname;
            if(user[userid[name]].type!=2||user[userid[name]].opt) puts("unsuccess");
            else{
                int pos=user[userid[name]].pos;
                if(!recheck(pos, fname)||ulcheck(pos, fname)) puts("unsuccess");
                else{
                    puts("success");
                    int fsze=0, fpos;
                    for (int i=0; i<folder[pos].f.size(); i++){
                        int x=folder[pos].f[i].second;
                        bool type=folder[pos].f[i].first;
                        if(type==0&&folder[x].name==fname) fpos=x, fsze=folder[x].sze;
                        if(type==1&&file[x].name==fname) fpos=x, fsze=file[x].sze;
                    }
                    user[userid[name]].opt=1;
                    task.push_back({fname, userid[name], fsze, pos, 0, fpos, 1});
                }
            }
        }
        lst=t;//更新上一次任务时间
    }
```
到此代码就讲完了。[完整代码](https://www.luogu.com/paste/26q8h6fa)我放在剪贴板里，不占用题解空间了。
### 本题疑点
首先吐槽一下：本题不仅题意不清楚，并且数据也有误。所以下面整合了讨论区中给出的疑问，给想自己做出这题的人的一些建议。
- **以下是通过本题必须做的：**
  - 模拟上传下载操作时，应直接根据相邻两次操作的时间进行，不能按照每秒，请无视题面中“FTP 服务器运行的最小时间单位为秒”。
  - $\text{cd}$ 命令时，不需要文件夹处于 $\text{normal}$ 状态，直接无视题面的这句话。
  - 特判 $10$ 测试点中第 $167$ 行 $\text{cd}$ 命令中文件的文件类型，将其修改为文件夹类型。因为后面还用到了该文件，且已被当做文件夹使用，但在此行之前其仍为文件类型。~（虽然我也不知道这种数据怎么造的）~
  - 用户在处于下载/上传文件状态时，$\text{cd}$ 和 $\text{cd..}$ 命令不应执行
  - 某些测试点中有额外换行，使用 C++ 语言可以无视这一点，但部分其他语言请注意。
- **以下操作对通过本题无影响，可选择性考虑：**
  - 当用户执行 $\text{quit}$ 操作时，若有文件正在上传，把 $\text{uploading}$ 状态更新。
  - 在上传文件时查重文件名，是否有同名文件已经提前上传。

---

## 作者：caohan (赞：2)

# 闲话

让人喜笑颜开 ~~血压升高~~ 的大模拟。

# 思路

相信读完题目，你会发现：

## 文件的

太简单，不讲了。

代码：

```cpp

class file
{
public:
	string name;
	int size;
	int state;//1=normal,2=upload
	folder* father;
	file(string name,int state,int size,folder* father)
	{
		this->father=father;
		this->name=name;
		this->size=size;
		this->state=state;
	}
private:

};
```

## 用户的
属性：名字，当前操作（状态），类型，当前下属的任务。

操作：在当前文件夹下，寻找文件、文件夹。

代码：

```cpp
class user
{
public: 
	string name;
	int type;//1==ul 2=dl 3=gst
	int state;//1=ul 2=dl 3=sc
	folder* place;
	task* nowtask;
	user(string name,int type,folder* place)
	{
		this->name=name;
		this->place=place;
		this->type=type;
		this->state=3;
		this->nowtask=nullptr;
	}
	file* findfile(string name)
	{
		for (std::vector<file*>::iterator i = place->sonfile.begin(); i != place->sonfile.end(); i++)
        {
            if ((*i)->name == name)return *i;
        }
        return nullptr;
	}
	folder* findfolder(string name)
	{
		for (std::vector<folder*>::iterator i=place->sonfolder.begin();i!=place->sonfolder.end();i++)
        {
            if ((*i)->name==name)return *i;
        }
		return nullptr;
	}
private:

};
```

## 文件夹的

属性：名字，当前状态（上传与否），父子关系。

操作：在自己辖区内寻找和添加文件和文件夹，自行维护文件夹的当前状态。

代码：

```cpp
class folder
{
public:
	string name;
	int size;
	int state;//1=normal,2=upload
	folder* father;
	vector<folder*> sonfolder;
	vector<file*> sonfile;
	file* findfile(string name)
	{
		for (std::vector<file*>::iterator i =sonfile.begin(); i != sonfile.end(); i++)
        {
            if ((*i)->name == name)return (*i);
        }
        return nullptr;
	}
	folder* findfolder(string name)
	{
		for (std::vector<folder*>::iterator i = sonfolder.begin(); i != sonfolder.end(); i++)
        {
            if ((*i)->name == name)return (*i);
        }
        return nullptr;
	}
	void addfile(file* newfile)
	{
		folder* now=this;
		while(now->father)
		{
			now->size+=newfile->size;
			now=now->father;
		}
		if(!this->father)this->size+=newfile->size;
		this->sonfile.push_back(newfile);
	}
	void addfolder(folder* now)
	{
		this->sonfolder.push_back(now);
	}
	void update()
	{
		bool flag=false;
        for (std::vector<file*>::iterator i=this->sonfile.begin();i!=this->sonfile.end();i++)
        {
            if ((*i)->state!=1)
            {
                flag=1;
                break;
            }
        }
        if (!flag)this->state=1;
	}
	bool check()
	{
		for (std::vector<folder*>::iterator i = sonfolder.begin(); i != sonfolder.end(); i++)
            if (!(*i)->check())
                return 0;
		
        return (this->state==1);
	}
	folder(string name,folder* father)
	{
		this->name=name;
		this->size=0;
		this->state=1;
		this->father=father;
	}
private:

};
```



## 任务的

属性：领取人，是否存在，剩余大小，任务种类，所辖文件文件夹（上传的文件，文件夹），上次刷新时间。

操作：重载以支持按刷新时间的排序（把小于号设为按上次刷新时间从小到大排序）。

代码：

```cpp
class task
{
public:
	user* creator;
	int sizeleft;
	int lastflushtime;
	int exist;//1=yes 0=no
	int type;//1==ul,2==dl(movetype)
	int datatype;//1=file 2=folder
	file* datafile;
	folder* datafolder;
	task(user* creator,int size,int st)
	{
		this->creator=creator;
		this->sizeleft=size;
		this->lastflushtime=st;
		this->exist=1;
		this->type=2;
		this->datatype=0;
		this->datafile=nullptr;
		this->datafolder=nullptr;
		creator->nowtask=this;
	}
	task(user* creator,int st,file* now)
	{
		this->creator=creator;
		this->sizeleft=now->size;
		this->lastflushtime=st;
		this->exist=1;
		this->type=1;
		this->datatype=1;
		this->datafile=now;
		this->datafolder=nullptr;
		creator->nowtask=this;
	}
	task(user* creator,int st,folder* now)
	{
		this->creator=creator;
		this->sizeleft=now->size;
		this->lastflushtime=st;
		this->exist=1;
		this->datatype=2;
		this->type=1;
		this->datafile=nullptr;
		this->datafolder=now;
		creator->nowtask=this;
	}
	bool operator < (task now)
	{
		return this->lastflushtime<now.lastflushtime;
	}
private:

};
```



## 服务器的

属性：当前时间，最大：流量、载客量、单人最大流量，实时：客量，用户流量，任务量，单人不限最大流速（最大流量除以实时任务量），（可外挂，可内放：根目录，用户组，任务列表）

操作：维护实时流量，维护任务（理论上嫌这个类长可外挂），寻找用户（同上）。

代码：

```cpp
class server
{
public:
	int maxusernum;
	int usermaxflux;
	int servermaxflux;

	int timecount;
	
	int usercurrentmaxflux;
	int usercurrentflux;

	int usercurrenttotal;
	int usertaskcurrenttotal;
	void updateflux()
	{
		this->usercurrentmaxflux=0;
		if(this->usertaskcurrenttotal!=0)
		{
			this->usercurrentmaxflux=this->servermaxflux/this->usertaskcurrenttotal;
		}
		this->usercurrentflux=min(this->usercurrentmaxflux,this->usermaxflux);
	}
	void updatetask()
	{
		for (std::set<task*>::iterator iter=tasks.begin();iter!=tasks.end();)
        {
            task* i=*iter;
            if (i->exist==0)
            {
                iter=tasks.erase(iter);
                continue;
            }
            i->sizeleft=i->sizeleft-(this->timecount-i->lastflushtime)*this->usercurrentflux;
            i->lastflushtime=this->timecount;
            if (i->sizeleft<=0)
            {
                if (i->type==1)
                {
                    if (i->datatype==1)
                    {
                        i->datafile->state=1;
                        i->datafile->father->update();
                    }
                    else
                    {
                        i->datafolder->state=1;
                    }
                }
                if (i->creator->state!=3)
                {
                    this->usertaskcurrenttotal--;
                }
                i->creator->state=3;
                i->creator->nowtask=nullptr;
                iter=tasks.erase(iter);
                continue;
            }
            iter++;
        }
		//cout<<"\n at time of "<<this->timecount<<" task update complete the situation are as follow:\n";
		//for(set<task*>::iterator it=tasks.begin();it!=tasks.end();it++)
		//{
		//	task* now=*it;
		//	if(now->datatype==1)
		//	{
		//		cout<<now->creator->name<<" "<<now->datafile->name<<" "<<now->datafile->father->name<<" "<<now->sizeleft<<"\n";
		//	}
		//	if(now->datatype!=1)
		//	{
		//		cout<<now->creator->name<<" "<<now->datafolder->name<<" "<<now->sizeleft<<"\n";
		//	}
		//}
	}
	user* finduser(string name)
	{
		for(std::vector<user*>::iterator i=users.begin();i!=users.end();i++)
		{
			if((*i)->name==name)
			{
				return *i;
			}
		}
		return nullptr;
	}
private:

};
```

## 六大操作

链接：检查同名连接人是否存在，当前连接数量是否超过限制。

若通过，新建用户，推入集中用户的 vector 并将当前用户数加一。

代码：

```cpp

string connect(string name,int type)
{	
	string mission="connect: ";
	user* nowuser=ftp.finduser(name);
	if(nowuser)
	{
		//return mission+"user appear check uncomplete\n";
		return "unsuccess\n";
	}
	if(ftp.usercurrenttotal>=ftp.maxusernum)
	{
		//return mission+"user number check uncomplete\n";
		return "unsuccess\n";
	}
	user* now=new user(name,type,&root);
	users.push_back(now);
	ftp.usercurrenttotal++;
	//return mission+"user "+name+" log in complete\n";
	return "success\n";
}
```



退出：检查同名连接人是否存在，当前连接数量是否低于限制。

若通过，从数组中删除用户，将用户的下属任务直接切断（将是否存在置零），减少用户数和实时任务数。

代码：

```cpp
string quit(string name)
{
	string mission="quit: ";
	user* nowuser=ftp.finduser(name);
	if(!nowuser)
	{
		//return mission+"user appear check uncomplete\n";
		return "unsuccess\n";
	}
	if(nowuser->nowtask)
	{
		nowuser->nowtask->exist=0;
	}
	if(nowuser->state!=3)
	{
		ftp.usertaskcurrenttotal--;
	}
	
     for (std::vector<user*>::iterator i = users.begin(); i != users.end(); i++) {
       if ((*i)->name == nowuser->name) {
            users.erase(i);
        	break;
   		}
    }
	ftp.usercurrenttotal--;
	//return mission+"user "+name+" log out complete\n";
	return "success\n";
}
```



进入文件夹：检查文件夹存在，用户存在，用户状态为浏览，文件夹状态为正常。

若通过，直接改变位置。

代码：

```cpp
string cd(string name,string foldername)
{
	string mission="cd: ";
	user* nowuser=ftp.finduser(name);
	if(!nowuser)
	{
		//return mission+"user appear check uncomplete\n";
		return "unsuccess\n";
	}
	if(nowuser->state!=3)
	{
		return "unsuccess\n";
	}
	folder* nowfolder=nowuser->findfolder(foldername);
	if(!nowfolder)
	{
		//return mission+"son folder appear check uncomplete\n";
		return "unsuccess\n";
	}
	if(nowfolder->state!=1)
	{
		//return mission+"son folder state check uncomplete\n";
		return "unsuccess\n";
	}
	nowuser->place=nowfolder;
	//return mission+"user "+name+" go to "+foldername+" complete\n";
	return "success\n";
}
```



回溯一层：检查文件夹存在（当前文件夹是根目录就不行），用户存在，用户状态为浏览，文件夹状态为正常。

若通过，直接改变位置。

代码：

```cpp
string cd2(string name)
{
	string mission="cd2: ";
	user* nowuser=ftp.finduser(name);
	if(!nowuser)
	{
		//return mission+"user appear check uncomplete\n";
		return "unsuccess\n";
	}
	if(!nowuser->place->father)
	{
		//return mission+"user root place check uncomplete\n";
		return "unsuccess\n";
	}
	nowuser->place=nowuser->place->father;
	//return mission+"user "+name+" go to"+"fatherplace"+" complete\n";
	return "success\n";
}
```



下载：检查文件夹、文件存在，用户存在，用户状态为浏览，用户为下载用户，文件夹、文件状态为正常。

代码：

```cpp
string download(string name,string filename)
{
	string mission="download: ";
	user* nowuser=ftp.finduser(name);
	if(!nowuser)
	{
		//return mission+"user appear check uncomplete\n";
		return "unsuccess\n";
	}
	if(nowuser->type!=2||nowuser->state!=3)
	{
		//return mission+"user type/state/task check uncomplete\n";
		return "unsuccess\n";
	}
	file* nowfile=nowuser->findfile(filename);
	if(nowfile)
	{
		if(nowfile->state!=1)
		{
			//return mission+"user "+name+" download folder "+filename+" state check uncomplete (state is "+(nowfile->state==2?"uploading":"normal")+")\n";
			return "unsuccess\n";
		}
		task* newtask=new task(nowuser,ftp.timecount,nowfile);
		tasks.insert(newtask);
		nowuser->state=2;
		ftp.usertaskcurrenttotal++;
		//return mission+"user "+name+" download file "+filename+" complete\n";
		return "success\n";
	}
	folder* nowfolder=nowuser->findfolder(filename);
	if(nowfolder)
	{
		if(nowfolder->state!=1)
		{
			return "unsuccess\n";
		}
		task* newtask=new task(nowuser,ftp.timecount,nowfolder);
		tasks.insert(newtask);
		nowuser->state=2;
		ftp.usertaskcurrenttotal++;
		//return mission+"user "+name+" download folder "+filename+" complete\n";
		return "success\n";
	}
	//return mission+"no file/folder as name of "+filename+" appear\n";
	return "unsuccess\n";
}
```



若通过，新建任务，上传必须信息，将其加入任务表，将用户变成下载状态，让任务加一。

代码：

```cpp
string download(string name,string filename)
{
	string mission="download: ";
	user* nowuser=ftp.finduser(name);
	if(!nowuser)
	{
		//return mission+"user appear check uncomplete\n";
		return "unsuccess\n";
	}
	if(nowuser->type!=2||nowuser->state!=3)
	{
		//return mission+"user type/state/task check uncomplete\n";
		return "unsuccess\n";
	}
	file* nowfile=nowuser->findfile(filename);
	if(nowfile)
	{
		if(nowfile->state!=1)
		{
			//return mission+"user "+name+" download folder "+filename+" state check uncomplete (state is "+(nowfile->state==2?"uploading":"normal")+")\n";
			return "unsuccess\n";
		}
		task* newtask=new task(nowuser,ftp.timecount,nowfile);
		tasks.insert(newtask);
		nowuser->state=2;
		ftp.usertaskcurrenttotal++;
		//return mission+"user "+name+" download file "+filename+" complete\n";
		return "success\n";
	}
	folder* nowfolder=nowuser->findfolder(filename);
	if(nowfolder)
	{
		if(nowfolder->state!=1)
		{
			return "unsuccess\n";
		}
		task* newtask=new task(nowuser,ftp.timecount,nowfolder);
		tasks.insert(newtask);
		nowuser->state=2;
		ftp.usertaskcurrenttotal++;
		//return mission+"user "+name+" download folder "+filename+" complete\n";
		return "success\n";
	}
	//return mission+"no file/folder as name of "+filename+" appear\n";
	return "unsuccess\n";
}
```

上传：检查文件、文件夹不存在，用户存在，用户状态为浏览，用户为上传用户。

若通过，新建任务和文件、文件夹，上传必须信息，建立父子关系，将其加入任务表，将用户变成上传状态，让任务加一。

代码：

```cpp
string upload(string username,string filename,int size)
{
	string mission="upload: ";
	user* nowuser=ftp.finduser(username);
	if(!nowuser)
	{
		//return mission+"user appear check uncomplete\n";
		return "unsuccess\n";
	}
	if(nowuser->type!=1||nowuser->state!=3)
	{
		//return mission+"user type/task/state number check uncomplete\n";
		return "unsuccess\n";
	}
	file* nowfile=nowuser->findfile(filename);
	folder* nowfolder=nowuser->findfolder(filename);
	if(nowfile||nowfolder)
	{
		//return mission+"file/folder as name of "+filename+" have appeared\n";
		return "unsuccess\n";
	}
	if(size==0)
	{
		folder* newfolder=new folder(filename,nowuser->place);
		newfolder->state=2;
		nowuser->place->addfolder(newfolder);
		task* newtask=new task(nowuser,ftp.timecount,newfolder);
		nowuser->state==1;
		ftp.usertaskcurrenttotal++;
		tasks.insert(newtask);
		//return mission+"user "+username+" upload folder "+filename+" complete\n";
		return "success\n";
	}
	if(size!=0)
	{
		file* newfile=new file(filename,2,size,nowuser->place);
		nowuser->place->addfile(newfile);
		nowuser->place->state=2;
		task* newtask=new task(nowuser,ftp.timecount,newfile);
		nowuser->state==1;
		ftp.usertaskcurrenttotal++;
		tasks.insert(newtask);
		//return mission+"user "+username+" upload file "+filename+" complete\n";
		return "success\n";
	}
}
```

文件，文件夹等这些可以用 class 就是类，来完成。

其余函数可放在外面。

# 注意

- 不要用当时的速度来错误断定任务全部时间的速度，要将速度随时变化。

- 一定要在每一次操作前确认用户和文件、文件夹的状态，类型，权限。

- 部分数据错误（第五，第九，第十）。

- 多把任务和上传速度刷新几遍。

- 速率的计算是总速率除上任务的数量，而不是人的数量。

# 总代码

[在这里](https://www.luogu.com.cn/paste/lnfvgofi)

---


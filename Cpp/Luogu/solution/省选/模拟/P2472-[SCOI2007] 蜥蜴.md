# [SCOI2007] 蜥蜴

## 题目描述

在一个 $r$ 行 $c$ 列的网格地图中有一些高度不同的石柱，第 $i$ 行 $j$ 列的石柱高度为 $h_{i,j}$。

一些石柱上站着一些蜥蜴，你的任务是让尽量多的蜥蜴逃到边界外。

每行每列中相邻石柱的距离为 $1$，蜥蜴的跳跃距离是 $d$，即蜥蜴可以跳到**平面距离**不超过 $d$ 的任何一个石柱上。

石柱都不稳定，每次当蜥蜴跳跃时，所离开的石柱高度减 $1$（如果仍然落在地图内部，则到达的石柱高度不变）。

如果该石柱原来高度为 $1$，则蜥蜴离开后消失，以后其他蜥蜴不能落脚。

任何时刻不能有两只蜥蜴在同一个石柱上。

## 说明/提示

对于 $100\%$ 的数据满足：$1\le r,c\le20$，$1\le d\le 4$，$1\le h\le 3$。

## 样例 #1

### 输入

```
5 8 2
00000000
02000000
00321100
02000000
00000000
........
........
..LLLL..
........
........
```

### 输出

```
1```

# 题解

## 作者：Ajwallet (赞：75)

这里提供一下题目大意和解题思路~~（其实主要还是那张图）~~

# 题目大意
在一个$n\times m$的矩阵中，每个格子都有一定的高度，当高度为0时表示该格子不存在，现在这个矩阵中有若干只蜥蜴，每只蜥蜴跳到格子上时，该格子的高度会减一，每只蜥蜴可以跳跃直线距离不大于$D$的长度，问最少有几只蜥蜴无法逃离
# 解题思路
`最少有几只蜥蜴无法逃离=蜥蜴总数-最多有几只蜥蜴能逃离`

对于每个点，我们进行拆点，将其拆分为入点和出点，显然它们之间的容量为该格子高度（最多能跳$h[i][j]$只蜥蜴），对于可以跳出矩阵的点，将它们的出点与汇点连边，容量为无穷大（允许所有蜥蜴逃离），对于所有起点，我们将源点和它们的入点连边，容量为1（每个点上至多有一只蜥蜴），最后跑最大流，然后用蜥蜴数减去最大流即为题目答案所求

如下图

![[博客地址](https://blog.csdn.net/xuxiayang/article/details/80932389)](https://cdn.luogu.com.cn/upload/pic/22331.png)

---

## 作者：LeavingZzz (赞：69)

# $\mathsf{Solution\text{ }For\text{ }P2472}$  
$\large\mathcal{By\text{ }ShadderLeave}$  

[$\small\texttt{在博客内食用}$](https://www.luogu.com.cn/blog/ShadderLeave/solution-p2472)

upd:更新了关于距离 $d$ 的说明

------------
## Description  
这题是求一个网格图内若干个起点中最多有多少个能够走出网格，限制条件是每一个点的经过次数限制（石柱高度）和步长限制（题目给出的 $d$）  
## Analysis
从“最多” 我们可以想到网络流的最大流算法。那么接下来就是建模问题了。  

我第一次做这种题目的的时候，想到了一个**错误**的模型：  

假设从点 $u$ 可以到点 $v$ 且点 $v$ 最多被经过 $x$ 次，那么就引一条 $(u,v,x)$ 的边表示限制。  

看起来满足了限制实际上有bug，假设点 $u_1$ 和点 $u_2$ 都可以到达点 $v$，那么就变成了从点 $u_1$ 和 $u_2$ 各可以去点 $v$ $x$ 次，错了。  


------------

那么怎么修这个bug呢  
bug产生的原因是因为从 $u_1$ 和 $u_2$ 流过来的流量并不相互干扰，我们应该对流到 $v$ 点的流量加和管理（先汇聚，再走限制），但是一个节点做不到这一点。  
所以我们使用经典方法 $\color{red}\texttt{拆点法}$，将一个节点 $v$ 拆解成两个节点 $v_x$ 和 $v_y$ ，不妨分别称作入点和出点。  
那么bug就修复了，我们依然连边：假如点 $u$ 可以到达点 $v$，那么就从 $u$ 点的出点 $u_y$ 引一条边到 $v$ 的入点 $v_x$，然后节点 $v$ 的入点和出点之间连一条边控制流量，其流量为该点的限制经过次数。  
![](https://cdn.luogu.com.cn/upload/image_hosting/154mihgs.png)  
如图，外面蓝色的边再怎么多，这一条红色的边流量限制了，也就不能超过最多经过次数的限制了。  


------------
然后我们再建立一个超级源点 $S$ 和一个超级汇点 $T$，就相当于我们把所有的蜥蜴集合到 $S$ 点然后开始跑，跑到 $T$ 点就是跑出了图（到达终点），我们求出有几只蜥蜴可以到达终点就是在求这个网络的最大流。  


------------
然后是距离 $d$ 的限制（**注意 $d$ 是欧几里得距离而不是曼哈顿距离**），因为这里 $d$ 比较小我直接分类讨论了（不建议学习，其他题解的方法码量上偏小但是也许我这个快一点？），周围的点大概就是这样：  
![](https://cdn.luogu.com.cn/upload/image_hosting/wyn492nq.png)  
（注意：由于画的是网格图，容易误以为这里画的是曼哈顿距离，计算距离要用坐标相减，这样就不容易理解错误了）  
按照 $d$ 的值向其中满足条件的点连线就可以了。  
但是这里要注意一点，如果遇到要连线的一个点是不合法的点怎么办？（不合法意为：设该点为 $(i,j)$  有 $i<1 || j<1 || i>N || j>M$）  
应该直接把这个点和超级汇点 $T$ 连起来啊。  
因为这表示可以跳到的点在图之外，也就是说从这个点可以直接跳出去，所以直接连到 $T$。  


------------
总结一下模型:  
1. 拆点，每个点分为入点和出点，两点之间连上该点的流量为经过次数的边。（如果该点是 '0' 就不用做）  
2. 对于每一个点，从其出点向向周围的可以到达点的入点连边，如果可以到达的点在图外部就直接连到 $T$。（如果该点为'0'或者连接到的点为'0'不用做）  
3. 把源点 $S$ 连到有蜥蜴的点的入点上。  

还有细节没懂的去看代码吧qaq。  
$\large\mathsf{Code:}$  
```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cstring>
using namespace std;
queue <int> q;
const int maxn=807;
const int maxm=100007;
const int inf=0x7f7f7f7f;
struct E{
	int u,v,cf;
}e[maxm];//cf是指流量
#define cf(i) e[i].cf
int first[maxn],nt[maxm],ES=1;
inline void addE(int u,int v,int cf)
{
	e[++ES]=(E){u,v,cf};
	nt[ES]=first[u];
	first[u]=ES;
	return ;
}
inline void add(int u,int v,int cf)//网络瘤专用加双边
{
	addE(u,v,cf);addE(v,u,0);
	return ;
}
int N,M,S,T;
char m1[27][27],m2[27][27];
inline int num(int i,int j)//根据一个点的坐标得到其入点编号
{
	return (i-1)*M+j;
}
int d,all,ans;
inline void linkE(int u,int i,int j)//从编号u连向 (i,j)
{
	if(i<1||i>N||j<1||j>M)//落在图外直接连到T
	{
		add(u,T,inf);
		return ;
	}
	if(m1[i][j]=='0') return ;
	add(u,num(i,j),inf);
	return ;
}
inline void link(int i,int j)//点(i,j)连边
{
	if(m1[i][j]=='0') return ; 
	add(num(i,j),num(i,j)+all,m1[i][j]-'0');
	if(m2[i][j]=='L')
		add(S,num(i,j),1),ans++;//是蜥蜴，顺便统计蜥蜴只数
	if(i==1||j==1||i==N||j==M)
		add(num(i,j)+all,T,inf);
	int u=num(i,j)+all;
    //最没营养的一部分
	if(d>=1)
	{
		linkE(u,i-1,j);linkE(u,i+1,j);
		linkE(u,i,j-1);linkE(u,i,j+1);
	}
	if(d>=2)
	{
		linkE(u,i-2,j);linkE(u,i+2,j);
		linkE(u,i,j-2);linkE(u,i,j+2);
		linkE(u,i-1,j-1);linkE(u,i-1,j+1);
		linkE(u,i+1,j-1);linkE(u,i+1,j+1);
	}
	if(d>=3)
	{
		linkE(u,i-3,j);linkE(u,i+3,j);linkE(u,i,j-3);linkE(u,i,j+3);
		linkE(u,i-2,j-2);linkE(u,i-2,j+2);linkE(u,i+2,j-2);linkE(u,i+2,j+2);
		linkE(u,i-1,j-2);linkE(u,i-1,j+2);linkE(u,i+1,j-2);linkE(u,i+1,j+2);
		linkE(u,i-2,j-1);linkE(u,i-2,j+1);linkE(u,i+2,j-1);linkE(u,i+2,j+1);
	}
	if(d>=4)
	{
		linkE(u,i-4,j);linkE(u,i+4,j);linkE(u,i,j-4);linkE(u,i,j+4);
		linkE(u,i-1,j-3);linkE(u,i-1,j+3);linkE(u,i+1,j-3);linkE(u,i+1,j+3);
		linkE(u,i-3,j-1);linkE(u,i-3,j+1);linkE(u,i+3,j-1);linkE(u,i+3,j+1);
		linkE(u,i-3,j-2);linkE(u,i-3,j+2);linkE(u,i+3,j-2);linkE(u,i+3,j+2);
		linkE(u,i-2,j-3);linkE(u,i-2,j+3);linkE(u,i+2,j-3);linkE(u,i+2,j+3);
	}
   //呜呜终于写完了
	return ;
}
//Dinic最大流部分
int cur[maxn],cnt[maxn];
inline bool BFS()
{
	memset(cnt,0,sizeof(cnt));
	cnt[S]=1;
	q.push(S);
	int u,v;
	while(!q.empty())
	{
		u=q.front();q.pop();
		for(register int i=first[u];i;i=nt[i])
		{
			v=e[i].v;
			if(cf(i)>0&&!cnt[v])
			{
				cnt[v]=cnt[u]+1;
				q.push(v);
			}
		}
	}
	return cnt[T]!=0;
}
inline int dfs(int u,int f)
{
	if(u==T) return f;
	int d,v,sum=0;
	for(register int &i=cur[u];i;i=nt[i])//cur数组是 当前弧优化
	{
		v=e[i].v;
		if(cf(i)>0&&cnt[v]==cnt[u]+1)
		{
			d=dfs(v,min(f,cf(i)));
			if(d>0)
			{
				f-=d;sum+=d;
				cf(i)-=d;cf(i^1)+=d;
				if(f<=0) return sum;
			}
		}
	}
	return sum;
}
int main()
{
	scanf("%d%d%d",&N,&M,&d);
    T=N*M*2+1;all=N*M;//入点编号为u的点的出点为u+all
	for(register int i=1;i<=N;i++)
		scanf("%s",m1[i]+1);
	for(register int i=1;i<=N;i++)
		scanf("%s",m2[i]+1);
	for(register int i=1;i<=N;i++)
		for(register int j=1;j<=M;j++)
			link(i,j);
	while(BFS())
	{
		memcpy(cur,first,sizeof(cur));
		ans-=dfs(S,inf);//流量都是跑出去的蜥蜴，要求剩下的蜥蜴。
       //在连边函数里面已经统计了蜥蜴数量，减去就可以
	}
	printf("%d",ans);
	return 0;
}
```
还有不懂的欢迎在讨论提出，或者私信戳我都没问题。  
蟹蟹观赏（无耻求赞.jpg）  
蟹蟹管理大大审核qwq  
$\huge\mathcal{The\text{ }End}$

---

## 作者：ifyml (赞：33)

#   Dinic算法


------------
## 网络流基本概念
 ### - 什么是网络流？
在一个有向图上选择一个源点，一个汇点，每一条边上都有一个流量上限（以下称为容量），即经过这条边的流量不能超过这个上界，同时，除源点和汇点外，所有点的入流和出流都相等，而源点只有流出的流，汇点只有汇入的流。这样的图叫做网络流。
 ###  - 定义
源点：只有流出去的点
汇点：只有流进来的点
流量：一条边上流过的流量
容量：一条边上可供流过的最大流量
残量：一条边上的容量-流量
## 几个基本性质
基本性质一：
对于任何一条流，总有流量<=容量                
基本性质二：
对于任何一个不是源点或汇点的点u，总有
∑p∈Ek[p][u]==∑q∈Ek[u][q]（其中k[i][j]表示i到j的流量）   
基本性质三：
对于任何一条有向边(u,v)，总有
k[u][v]==−k[v][u]


------------

## 网络流最大流

网络流的最大流算法就是指的一个流量的方案使得网络中流量最大。
##  网络流最大流的求解
### （网络流的所有算法都是基于一种增广路的思想，下面首先简要的说一下增广路思想，其基本步骤如下：）
1.找到一条从源点到汇点的路径，使得路径上任意一条边的残量>0（注意是小于而不是小于等于，这意味着这条边还可以分配流量），这条路径便称为增广路
2.找到这条路径上最小的F[u][v]（我们设F[u][v]表示u->v这条边上的残量即剩余流量），下面记为flow  
3.将这条路径上的每一条有向边u->v的残量减去flow，同时对于起反向边v->u的残量加上flow（为什么呢？我们下面再讲）   
4.重复上述过程，直到找不出增广路，此时我们就找到了最大流

## 为什么要连反向边？？？
### 我们知道，当我们在寻找增广路的时候，在前面找出的不一定是最优解，如果我们在减去残量网络中正向边的同时将相对应的反向边加上对应的值，我们就相当于可以反悔从这条边流过。



------------

#### 回到这道题
##### 这题主要是建模...
把每一个有高度的石柱都分成两个点：入口和出口。  
一共有四种建边方式——  
1.初始化一个源点S，它连着蜥蜴所在的位置，因为只有一个蜥蜴，so容量为1。  
2.自己的入口连上自己的出口，容量为石柱高度，表示能跳走的个数。  
3.其他的石柱在跳跃范围内，都能跳上这个石柱，所以其他石柱出口就和这个石柱入口建边，容量为inf。   
4.最后能到汇点T的石柱，容量为inf。

```cpp
#include<cstdio>
#include<vector>
#include<iostream>
#include<cstring>
#include<cmath>
#include<queue>
#define inf 0x7fffffff
#define K 100001
using namespace std;
int N,M,D,T,ans,sum,pi=1,a,b,ci,ti,NN,clock;
char o;
int c[51][51],cur[K],head[K],dis[K],l[K],r[K],p[51][51];
struct ss{int to,c=0,ls;}q[K];
struct xy{int l,r;};
vector<xy>xiyi;
void add(int a,int b,int c)
{
    q[++pi].to=b;
    q[pi].c=c;
    q[pi].ls=head[a];
    head[a]=pi;
    q[++pi].to=a;
    q[pi].ls=head[b];
    head[b]=pi;
}
void read()
{
    scanf("%d%d%d",&N,&M,&D);
    T = N*M*2+1;
    for(int i=1;i<=N;i++)
     for(int j=1;j<=M;j++)
     {
     	p[i][j]=++ti;
     	cin>>o;
     	c[i][j]=o-48;
     	if(c[i][j])
        {
         	l[++ci]=i;
         	r[ci]=j;
        }
     }
    NN=N*M;
    for(int i=1;i<=N;i++)
     for(int j=1;j<=M;j++)
     {
     	cin>>o;
     	if(o=='L')
        {
            sum++;
            xiyi.push_back((xy){i,j});
        }
     }
}
bool bfs()
{
    memset(dis,0,sizeof(dis));
    queue<int >que;
    que.push(0);
    dis[0]=1;
    while(!que.empty())
    {
        int u=que.front();que.pop();
        for(int i=head[u];i;i=q[i].ls)
        {
            int v=q[i].to;         
            if(!dis[v]&&q[i].c)
            {
                dis[v]=dis[u]+1;
                if(v==T)return 1;
                que.push(v);
            }
        }
    }
    return dis[T];
}
int dfs(int u,int flow)
{
    if(u==T||!flow)return flow;
    int fl=0,f;
    for(int &i=cur[u];i;i=q[i].ls)
    //当前弧优化:即每一次dfs增广时不从第一条边开始，而是用一个数组cur记录点u之前循环到了哪一条边，以此来加速
    {
        int v=q[i].to,c=q[i].c;
        if(dis[v]==dis[u]+1&&c&&(f=dfs(v,min(flow,c))))
        {
            q[i].c-=f;
            q[i^1].c+=f;
            fl+=f;
            flow-=f;
            if(!flow)break;//没有剩余流量了，直接停止
        }
    }
    return fl;
}
int jl(int x,int y,int a,int b)
{
    return (x-a)*(x-a)+(y-b)*(y-b);
}
void ad()
{
    for(int i=1;i<=ci;i++)
    {
        add(p[l[i]][r[i]],p[l[i]][r[i]]+NN,c[l[i]][r[i]]);
        //石柱的入口到出口
        if(l[i]<=D||r[i]<=D||l[i]+D>N||r[i]+D>M)
         add(p[l[i]][r[i]]+NN,T,inf);		//石柱到汇点 
    }
    for(int i=1;i<=ci;i++)
     for(int j=1;j<=ci;j++)
      if(D*D>=jl(l[i],r[i],l[j],r[j])&&i!=j)
       add(p[l[i]][r[i]]+NN,p[l[j]][r[j]],inf); //石柱到石柱
       
    for(int i=0;i<xiyi.size();i++)
     add(0,p[xiyi[i].l][xiyi[i].r],1);	 //源点到蜥蜴
}
int dinic()
{
    while(bfs())//分层
    {
        for(int i=0;i<=T;i++)cur[i]=head[i];//当前弧优化的初始化
        ans+=dfs(0,inf);//累加增广量
    }
    return ans;
}
int main()
{
    read();
    ad();
    printf("%d\n",sum-dinic());//最小值
    return 0;//OK.
}
```
### [学习一下...](https://www.cnblogs.com/SYCstudio/p/7260613.html)

---

## 作者：望眼浮云 (赞：15)

第一道紫题，写篇题解纪念一下

对于每根石柱，采取一分为二的想法，即把一个点分为两个点（可抽象为石柱底部到顶部，自己画个图理解一下吧），其连线容量限制为石柱高度(从底向顶连)。

首先，超级源点向每个蜥蜴所在石柱的底部连一条为1的边

然后，找到能跳出去的石柱，顶端向超级汇点连一条为inf的边

前两步很容易，下一步有点难理解，自己画图理解一下，~~我懒得上传图片了~~

对于地图内任意两个石柱，如果间距小于d，就将其中一根石柱的顶部与另一根石柱的底部相连，其连线容量为inf。

```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cstring>
using namespace std;
const int inf=1e9;
int i,j,n,m,s,t,ans,dis,tot,d[10005];
struct node{
	int next,to,w;
}a[500000];
int cnt=1,head[10005],cur[10005];
int k,x[10000],y[10000],hi[1000][1000],zn[1000][1000];
char s1[201][201],s2[201][201];
queue <int> q;
void add(int x,int y,int dis)
{
	a[++cnt].next=head[x];
	a[cnt].to=y;
	a[cnt].w=dis;
	head[x]=cnt;
}
bool bfs(int s,int t)
{
	memset(d,0x7f,sizeof(d));
	while(!q.empty()) q.pop();
	for(int i=0;i<=2*k+1;i++) cur[i]=head[i];
	d[s]=0;
	q.push(s);
	while(!q.empty())
	{
		int u=q.front();q.pop();
		for(int i=head[u];i;i=a[i].next)
		{
			int v=a[i].to;
			if(d[v]>inf&&a[i].w) 
			{
				d[v]=d[u]+1;
				q.push(v);
			}
		}
	}
	if(d[t]<inf) return true;
	else return false;
}
int dfs(int now,int t,int limit)
{
	if(!limit||now==t) return limit;
	int flow=0,f;
	for(int i=cur[now];i;i=a[i].next)
	{
		cur[now]=i;
		int v=a[i].to;
		if(d[v]==d[now]+1&&a[i].w&&(f=dfs(v,t,min(limit,a[i].w))))
		{
			flow+=f;
			limit-=f;
			a[i].w-=f;
			a[i^1].w+=f;
			if(!limit) break;
		}
	}
	return flow;
}
int main()
{
	scanf("%d%d%d",&n,&m,&dis);
	for(i=1;i<=n;i++)
	{
	    scanf("%s",s1[i]); 
	    for(j=0;j<m;j++)
	    {
	        hi[i][j+1]=s1[i][j]-48;//记录高度
	        if(hi[i][j+1]!=0) 
	            k++,x[k]=i,y[k]=j+1,zn[i][j+1]=k;//k是当前石柱编号，zn记录编号，x,y记录位置
	    }
	}
	for(i=1;i<=n;i++)
	    for(j=1;j<=m;j++)
	    if(hi[i][j]!=0)
	        {
	            if(i<=dis||i+dis>n||j<=dis||j+dis>m)
	                add(zn[i][j]+k,2*k+1,inf),add(2*k+1,zn[i][j]+k);//2*k+1为超级汇点，可以跳出去就连边
	        }
	for(i=1;i<=n;i++)
	{
	    scanf("%s",s2[i]);
	    for(j=0;j<m;j++)
	    if(s2[i][j]=='L') //如果有蜥蜴，向石柱底部连边
	    {
	        int v=zn[i][j+1];
	        tot++;
	        add(0,v,1); 
	        add(v,0,0);
	    }
	}
	for(i=1;i<=k;i++)
	    add(i,i+k,hi[x[i]][y[i]]),add(i+k,i,0);//石柱底部向顶部连边
	for(i=1;i<=k;i++)
	    for(j=1;j<=k;j++)
	    {
	        if(i==j) continue;
	        if((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])<=dis*dis) 
            //两根石柱的距离小于dis，一根的顶部向另一根的底部连边
	            add(i+k,j,inf),add(j,i+k,0); 
	    }
	s=0;t=2*k+1;
	while(bfs(s,t)) ans+=dfs(s,t,inf);//网络流模板，不解释
	printf("%d",tot-ans); //总蜥蜴数减去能跳出去的
	return 0;
}
```

---

## 作者：fy0123 (赞：9)

##题意：

一个$n\times{m}$的网格中，有一些格子有石柱，石柱的高度为1~3.

有一些石柱的顶上有蜥蜴，蜥蜴每次可以跳到距离不超过$d$的石柱上，或者跳到界外。

蜥蜴跳一次，它所在的石柱的高度就减一，如果某个石柱的高度为0了，石柱就消失，以后蜥蜴不能跳到这里。

现在要使得剩下无法逃脱的蜥蜴数最少。


##做法：

~~总是自己想不到建图方式然后看了题解顿时恍然大悟的感觉= =~~

好吧这题我还是想到了一点的恩。


题目就是要求逃脱的蜥蜴数最多。

然后就想到最大流了~~（什么鬼）~~

考虑把每个格子拆成两个点，表示石柱顶和石柱下端。

4种边：

1.    这个点有石柱，石柱顶连向石柱下端，容量为石柱高

2.    这个点有蜥蜴，源点连向石柱的上端，容量为1

3.    这个点可以跳出去，石柱的底连向汇点，容量inf

4.    两个点距离小于等于d，可以跳到，连边，容量inf


挺好理解的qaq


然后跑跑dinic你就a了orz。


##代码：

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<cstdlib>
#include<cctype>
#include<cmath>
#include<queue>
using namespace std;

const int N = 805, M = 400010;
const int inf = 1e9;
int n, m, d, cnt, all, s, t;
char str[30];
int head[N], vis[N];
struct edge{
    int to, nxt, c;
    edge() {}
    edge(int x, int y, int z) { to = x, nxt = y, c = z; }
}e[M];

inline int id1(int x, int y) { return (x-1)*m+y; }
inline int id2(int x, int y) { return (x-1)*m+y+n*m; }
inline int dis(int x1, int y1, int x2, int y2) { return (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2); }
inline void addedge(int x, int y, int z) {
    e[cnt] = edge(y, head[x], z); head[x] = cnt ++;
    e[cnt] = edge(x, head[y], 0); head[y] = cnt ++;
}
inline bool bfs()
{
    queue<int> q; q.push(s); memset(vis, -1, sizeof vis); vis[s] = 1;
    while(!q.empty()) {
        int u = q.front(); q.pop();
        for(int i = head[u]; i != -1; i = e[i].nxt) {
            int v = e[i].to;
            if(e[i].c && vis[v] == -1) {
                vis[v] = vis[u]+1;
                q.push(v);
            }
        }
    }
    return vis[t] != -1;
}
inline int dfs(int u, int flow)
{
    if(u == t) return flow;
    int used = 0, w;
    for(int i = head[u]; i != -1; i = e[i].nxt) {
        int v = e[i].to;
        if(vis[v] == vis[u]+1 && e[i].c) {
            w = dfs(v, min(flow-used, e[i].c));
            e[i].c -= w; e[i^1].c += w; used += w;
            if(used == flow) return used;
        }
    }
    if(!used) vis[u] = -1;
    return used;
}
inline int dinic()
{
    int ret = 0;
    while(bfs()) ret += dfs(s, inf);
    return ret;
}
int main() {
    scanf("%d%d%d", &n, &m, &d); memset(head, -1, sizeof head);
    s = 0, t = n*m*2+1;//每个点拆成两个点，表示从石柱顶连向石柱下端
    for(int i = 1; i <= n; i ++) {
        scanf("%s", str+1);
        for(int j = 1; j <= m; j ++) if(str[j]-'0' > 0) addedge(id1(i, j), id2(i, j), str[j]-'0');
    }//这个点有石柱，石柱顶连向石柱下端，容量为石柱高 
    for(int i = 1; i <= n; i ++) {
        scanf("%s", str+1);
        for(int j = 1; j <= m; j ++) if(str[j] == 'L') addedge(s, id1(i, j), 1), all ++;
    }//这个点有蜥蜴，源点连向石柱的上端 
    for(int i = 1; i <= n; i ++)
        for(int j = 1; j <= m; j ++)
            if(i-d < 1 || i+d > n || j-d < 1 || j+d > m) addedge(id2(i, j), t, inf);//可以跳出去，石柱的底连向汇点 
    for(int x1 = 1; x1 <= n; x1 ++)//距离小于等于d，可以跳到的两个点连边
        for(int y1 = 1; y1 <= m; y1 ++)
            for(int x2 = 1; x2 <= n; x2 ++)
                for(int y2 = 1; y2 <= m; y2 ++) if(dis(x1, y1, x2, y2) <= d*d) addedge(id2(x1, y1), id1(x2, y2), inf);
    printf("%d\n", all - dinic());
    return 0;
}
```

---

## 作者：天上一颗蛋 (赞：4)

## P2472 [SCOI2007]蜥蜴

题目背景
07四川省选

题目描述
在一个r行c列的网格地图中有一些高度不同的石柱，一些石柱上站着一些蜥蜴，你的任务是让尽量多的蜥蜴逃到边界外。

每行每列中相邻石柱的距离为1，蜥蜴的跳跃距离是d，即蜥蜴可以跳到平面距离不超过d的任何一个石柱上。石柱都不稳定，每次当蜥蜴跳跃时，所离开的石柱高度减1（如果仍然落在地图内部，则到达的石柱高度不变），如果该石柱原来高度为1，则蜥蜴离开后消失。以后其他蜥蜴不能落脚。任何时刻不能有两只蜥蜴在同一个石柱上。

输入输出格式
输入格式：
输入第一行为三个整数r，c，d，即地图的规模与最大跳跃距离。以下r行为石竹的初始状态，0表示没有石柱，1~3表示石柱的初始高度。以下r行为蜥蜴位置，“L”表示蜥蜴，“.”表示没有蜥蜴。

输出格式：
输出仅一行，包含一个整数，即无法逃离的蜥蜴总数的最小值。

---
解决这题的关键是理解这句话：**石柱都不稳定，每次当蜥蜴跳跃时，所离开的石柱高度减1（如果仍然落在地图内部，则到达的石柱高度不变），如果该石柱原来高度为1，则蜥蜴离开后消失**

我们把这句话转换一下，**每个石柱 $i$ 可以用石柱高度 $hi$ 次**。这是一个限制条件：使用次数，所以我们想到了最大流。

不能逃脱的蜥蜴数即为总蜥蜴数 - 逃脱的蜥蜴数，所以我们现在思考怎么建图

# 建模

最大流的核心在于**限制**

由限制条件，~~对网络流模型极其敏感~~我们可知道：石柱一定是要拆成两个点的，两点之间边容量为石柱高度 $h$ ，这样可以限制一个石柱只能跳 $h$ 次

由最大流答案不可能大于蜥蜴总数，所以我们可以联想到由汇点向蜥蜴所在的石柱连边，容量为 1 

由石柱之间在规定距离内可以相互到达，~~傻子都会~~我们可以在距离内的石柱连一条容量为INF的边

由要跳出去可得：在跳到外围距离小于d的石柱连一条容量为INF的边

**注意：因为每次都要消耗石柱高度，所以连入石柱的边连 石柱1 ,连出石柱的边从 石柱2 出发，从而达到路过石柱消耗高度这一限制**

# Code

```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
#include<algorithm>
#define ll long long
using namespace std;
int RD(){
    int out = 0,flag = 1;char c = getchar();
    while(c < '0' || c >'9'){if(c == '-')flag = -1;c = getchar();}
    while(c >= '0' && c <= '9'){out = out * 10 + c - '0';c = getchar();}
    return flag * out;
    }
const int maxn = 100019,INF = 1e9;
int num,nume = 1,tot;
int lenx,leny,d;
int map[190][190];
int L[190][190];
int s,t,maxflow;
int head[maxn];
struct Node{
    int v,dis,nxt;
    }E[maxn << 2];
void add(int u,int v,int dis){
    E[++nume].nxt = head[u];
    E[nume].v = v;
    E[nume].dis = dis;
    head[u] = nume;
    }
int lev[maxn];
bool bfs(){
    queue<int>Q;
    memset(lev,0,sizeof(lev));
    Q.push(s);
    lev[s] = 1;
    while(!Q.empty()){
        int u = Q.front();
        Q.pop();
        for(int i = head[u];i;i = E[i].nxt){
            int v = E[i].v;
            if(E[i].dis && !lev[v]){
                lev[v] = lev[u] + 1;
                Q.push(v);
                if(v == t)return 1;
                }
            }
        }
    return 0;
    }
int Dinic(int u,int flow){
    if(u == t)return flow;
    int rest = flow,k;
    for(int i = head[u];i;i = E[i].nxt){
        int v = E[i].v;
        if(E[i].dis && lev[v] == lev[u] + 1 && rest){
            k = Dinic(v,min(rest,E[i].dis));
            if(!k)lev[v] = 0;
            E[i].dis -= k;
            E[i ^ 1].dis += k;
            rest -= k;
            }
        
        }
    return flow - rest;
    }
double getdis(int x1,int y1,int x2,int y2){
    return ((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
    }
int getindex(int x,int y){
    return (x - 1) * leny + y;
    }
int main(){
    lenx = RD();leny = RD();d = RD();
    char temp;
    for(int i = 1;i <= lenx;i++){
        for(int j = 1;j <= leny;j++){
            cin>>temp;
            map[i][j] = temp - '0';
            }
        }
    for(int i = 1;i <= lenx;i++){
        for(int j = 1;j <= leny;j++){
            cin>>temp;
            if(temp == 'L'){
                L[i][j] = 1;
                num++;
                }
            }
        }
    //石头1部从1到tot（lenx * leny）,2部 + tot，石头编号为(i - 1) * leny + j
    tot = lenx * leny;
    s = tot * 2 + 1,t = s + 1;
    for(int i = 1;i <= lenx;i++){
        for(int j = 1;j <= leny;j++){
            int I = getindex(i,j);
            if(map[i][j]){
                add(I,I + tot,map[i][j]);
                add(I + tot,I,0);
                if(i + d > lenx || i - d < 1 || j + d > leny || j - d < 1){
                    add(I + tot,t,INF);
                    add(t,I + tot,INF);
                    }
                if(L[i][j]){
                    add(s,I,1);
                    add(I,s,0);
                    }
                }
            }
        }
    for(int x1 = 1;x1 <= lenx;x1++){
        for(int y1 = 1;y1 <= leny;y1++){
            for(int x2 = 1;x2 <= lenx;x2++){
                for(int y2 = 1;y2 <= leny;y2++){
                    if(getdis(x1,y1,x2,y2) <= d * d){
                        int u = getindex(x1,y1),v = getindex(x2,y2);
                        add(u + tot,v,INF);
                        add(v,u + tot,0);
                        add(v + tot,u,INF);
                        add(u,v + tot,0);
                        }
                    }
                }
            }
        }
    int flow = 0;
    while(bfs())while(flow = Dinic(s,INF))maxflow += flow;
    printf("%d\n",num - maxflow);
    return 0;
    }
```

---

## 作者：Gary818 (赞：3)

刚学习网络流
一上午熟悉$Dinic$板子+就调过了这一个题  
[推销Blogs](https://www.cnblogs.com/rui-4825/p/13963194.html)


## Solution
看上去就是每个点有限制能跳过几只蜥蜴  
就相当于边权中的流量上限  
考虑如何建图  
由于对于单个点无法增加边权  
选择拆点成边  
拆出的点之间的边权就是流量的限制  
首先建立超级源点$s=0$  
因为图中有$n*m$个点  
拆完之后$2*n*m$个点  
所以超级汇点是$t=2*n*m+1$  
图中建边有四种  
* 由源点$s$出发，向所有蜥蜴所在的点建立边权为$1$的边
* 所有有高度（就是蜥蜴可以跳跃的点）拆点，向$(i,j)$对应的点$(i,j) + n*m$建边，边权为当前点的高度，即流量限制
* 由所有一次能够跳出矩阵的点向超级汇点$t$建边，边权无限制，为$inf$
* 矩阵内部互相能够到达的点，边权无限制，为$inf$

最后直接跑$Dinic$就行了
注意$Dinic$跑出来的是能够逃离的蜥蜴的数量
要用总数量减一下
拆出来的点，一个是原点，一个是新点
原点负责所有向外建边
新点负责其他点向自己建边
这个建图的时候要注意一下
上午调了好久～

## Code
```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <queue>
#include <cmath>
#define min(a, b) ({register int AA = a, BB = b; AA < BB ? AA : BB;})
#define inf 10000009
using namespace std;

inline int read(){
	int x = 0, w = 1;
	char ch = getchar();
	for(; ch > '9' || ch < '0'; ch = getchar()) if(ch == '-') w = -1;
	for(; ch >= '0' && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';
	return x * w;
}

const int ss = 10010;

struct node{
	int to, nxt, w;
}edge[ss * 20];

int head[ss], tot = 1;
inline void add(register int u, register int v, register int w){
	edge[++tot].to = v;
	edge[tot].nxt = head[u];
	edge[tot].w = w;
	head[u] = tot;
}

int dis[ss], cur[ss];
int r, c, d, s, t;
bool vis[ss];
queue<int> q;
inline bool spfa(register int s){
	for(register int i = 0; i <= t; i++)
		vis[i] = 0, dis[i] = 0x3f3f3f3f, cur[i] = head[i];
	dis[s] = 0;
	q.push(s);
	while(!q.empty()){
		register int u = q.front();
		q.pop();
		vis[u] = 0;
		for(register int i = head[u]; i; i = edge[i].nxt){
			register int v = edge[i].to;
			if(dis[v] > dis[u] + 1 && edge[i].w){
				dis[v] = dis[u] + 1;
				if(!vis[v]) q.push(v), vis[v] = 1;
			}
		}
	}
	return dis[t] != 0x3f3f3f3f;
}

inline int dfs(register int u, register int flow){
	register int res = 0;
	if(u == t) return flow;
	for(register int i = cur[u]; i; i = edge[i].nxt){
		cur[u] = i;
		register int v = edge[i].to;
		if(dis[v] == dis[u] + 1 && edge[i].w){
			if(res = dfs(v, min(flow, edge[i].w))){
				edge[i].w -= res;
				edge[i ^ 1].w += res;
				return res;
			}
		}
	}
	return 0;
}

long long ans, cnt;
inline long long dinic(){
	register long long minflow = 0;
	while(spfa(s)){
		while(minflow = dfs(s, 0x7fffffff))
			ans += minflow;
	}
	return ans;
}

inline double getdis(register int a, register int b, register int c, register int d){
	return sqrt((a - c) * (a - c) + (b - d) * (b - d));
}

inline int change(register int i, register int j){
	return (i - 1) * c + j;
}

int a[25][25], flag[25][25];
char ch[25];
signed main(){
	r = read(), c = read(), d = read();
	for(register int i = 1; i <= r; i++){
		scanf("%s", ch + 1);
		for(register int j = 1; j <= c; j++)
			a[i][j] = ch[j] - '0';
	}
	for(register int i = 1; i <= r; i++){
		scanf("%s", ch + 1);
		for(register int j = 1; j <= c; j++)
			if(ch[j] == 'L') flag[i][j] = 1;
	}
	
	s = 0, t = 2 * c * r + 1;
	for(register int i = 1; i <= r; i++)
		for(register int j = 1; j <= c; j++)
			if(flag[i][j] == 1){
				cnt++;
				add(s, change(i, j), 1);
				add(change(i, j), s, 0);
			}
	for(register int i = 1; i <= r; i++)
		for(register int j = 1; j <= c; j++)
			if(a[i][j]){
				add(change(i, j), change(i, j) + r * c, a[i][j]);
				add(change(i, j) + r * c, change(i, j), 0);
			}
	for(register int i = 1; i <= r; i++)
		for(register int j = 1; j <= c; j++){
			if(i > d && i <= r - d && j > d && j <= c - d) continue;
			if(a[i][j]){
				add(change(i, j) + r * c, t, inf);
				add(t, change(i, j) + r * c, 0);
			}
		}
	for(register int i = 1; i <= r; i++){
		for(register int j = 1; j <= c; j++){
			for(register int p = 1; p <= r; p++){
				for(register int q = 1; q <= c; q++){
					if(i == p && j == q) continue;
					if(getdis(i, j, p, q) <= (double)d && a[i][j] && a[p][q]){
						add(change(i, j) + r * c, change(p, q), inf);
						add(change(p, q), change(i, j) + r * c, 0);
					}
				}
			}
		}
	}
	printf("%lld\n", cnt - dinic());
	return 0;
}
```

---

## 作者：shenbear (赞：2)

我们来一边读题，一边分析：

1.石柱高h，每次蜥蜴跳后-1：

我们每个石柱只能被h只蜥蜴跳，即石柱容量为h，我们通过拆点实现

2.同一时刻，每个出生点只能有一只蜥蜴：

我们从s向那个点连1的边，表示蜥蜴起跳

3.蜥蜴跳到边界**外**为逃走：

我们从能跳到边界外的点，暴力向t连边，容量inf（因为有无数只蜥蜴可以跳出）

4.蜥蜴可以跳到距离d以内的点：

我们暴力搜索一遍，找到d以内的点，连双向边，容量无限

------------
这样我们就成功的把题目的意思转化为图的意思，然后我们就可以愉快的跑dinic了，求出有多少蜥蜴能跑出去

再用总数一减就是不能跑出去的数量



------------
```cpp
#include<bits/stdc++.h>
#define il inline
#define ll long long
using namespace std;
const int N = 1e3+3;
int m,n,s,t,d;
struct edge{int next,to,w;}p[N*N];
int head[N],num;
il void ad(int x,int y,int z){p[++num]=edge{head[x],y,z};head[x]=num;}
il void add(int x,int y,int z)
{
	ad(x,y,z);
	ad(y,x,0);
//	printf("%d %d %d\n",x,y,z);
}
il int qfj(int x){return ((x-1)^1)+1;}
il int id(int x,int y){return (x-1)*m+y;}
int dep[N],mxfl;
bool bfs() //网络流 
{
	memset(dep,0,sizeof(dep));
	queue<int> q;
	q.push(s);
	dep[s]=1;
	while(!q.empty())
	{
		int u=q.front();q.pop();
		for(int i=head[u];i;i=p[i].next)
		{
			int v=p[i].to;
		//	printf("%d %d\n",u,v);
			if(!dep[v]&&p[i].w)
			{
				dep[v]=dep[u]+1;
				q.push(v);
			}
		}
	}	
	return dep[t];
}
int dfs(int u,int limit)
{
//	puts("---------");
	if(u==t||!limit) return limit;
	int flow=0,w;
	for(int i=head[u];i;i=p[i].next)
	{
		int v=p[i].to;
		if(dep[v]==dep[u]+1&&(w=dfs(v,min(limit,p[i].w))))
		{
			flow+=w;
			p[i].w-=w;
			p[qfj(i)].w+=w;
			limit-=w;
			if(!limit) break;
		}
	}
	return flow;
}
int h[22][22],g[22][22],sm;
il int dis(int xa,int ya,int xb,int yb){return (xa-xb)*(xa-xb)+(ya-yb)*(ya-yb);}
void kz(int x,int y) //寻找周围可以跳到的 
{
	for(int i=max(1,x-d);i<=min(n,x+d);i++)
	{
		for(int j=max(1,y-d);j<=min(m,y+d);j++)
		{
			if(x==i&&y==j) continue;
			if(dis(x,y,i,j)<=d*d)
			{
				add(id(x,y)+n*m,id(i,j),5e8);
				add(id(i,j)+n*m,id(x,y),5e8);
		//		printf("%d %d %d %d\n",x,y,i,j);
			}
		}
	}
}
int main()
{
	cin>>n>>m>>d;
	for(int i=1;i<=n;i++)
	{
		string c;
		cin>>c;
		for(int j=0;j<c.size();j++) h[i][j+1]=c[j]-48;
	}
	for(int i=1;i<=n;i++)
	{
		string c;
		cin>>c;
		for(int j=0;j<c.size();j++)
			if(c[j]=='L') g[i][j+1]=1,sm++;
	}
//	for(int i=1;i<=n;i++,puts("")) for(int j=1;j<=m;j++) printf("%d ",h[i][j]);
//	for(int i=1;i<=n;i++,puts("")) for(int j=1;j<=m;j++) printf("%d ",g[i][j]);
	s=0;t=n*m*2+1;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			int u=id(i,j);
			add(u,u+n*m,h[i][j]); //拆点 
			if(g[i][j]) add(s,u,1); 
			if(i<=d||j<=d||i+d>n||j+d>m) add(u+n*m,t,1e9);//可以跳出去 
			kz(i,j);
		}
	}
	while(bfs()) mxfl+=dfs(s,2e9);
	/*
	for(int i=head[s];i;i=p[i].next) //调错好方法 
	{
		int v=p[i].to;
		if(p[i].w) printf("%d\n",v);//这条边还有流量，说明它没被选，就知道哪些选了，哪些没有 
	}
	*/
//	printf("%d\n",mxfl);
	cout<<sm-mxfl;
	return 0;
}

```


---

## 作者：wyt_1727149038 (赞：1)

题目数据很小，所以做起来会很轻松（EK就行了）
接下来就是思路：一看就知道是网络流的题目。

1.首先是蜥蜴，与超源点连接，容量为一。

2.其次是石柱，每次有蜥蜴经过时高度减一，拆分成两点容量为石柱高度。

3.石柱与可以连接的石柱相连，容量为INF。

4.可以直接跳出的石柱与汇点相连，容量INF，石柱高度都行。

如果还不明白的看下面图:
![](https://img-blog.csdn.net/20180810223126963?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1d5dF9jb2Rl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)


石柱拆分我就没画了，看上面自己脑补一下，就像你们看番的时候就行

接下来就是贴代码了
```cpp

#include<iostream>

#include <cstdio>

#include <cstring>

#include <queue>

#define MAXN 1050

#define MAXQ 20050

#define INF 999999

using namespace std;

int r,c,d,cnt=0,acnt=0,ans=0;

int num[21][21];//用来记录每个有石柱的点的编号； 

int a[MAXQ];

int map[MAXN][MAXN],in[25][25];//map是矩阵图，记录点与点联系；in是石柱高度；

int p[MAXQ],q[MAXQ]; 

void makePic(int x,int y)//搜索有直接联系的边建图；

{int i,j;

int now=num[x][y]+1;

for(i=1;i<=r;i++)

for(j=1;j<=c;j++)

{

if((i!=x||j!=y) && (in[i][j]>0) && d*d>=(x-i)*(x-i)+(y-j)*(y-j)) 

map[now][num[i][j]]=INF;

}

}

 

void escape()//判断该石柱是否可以出逃；

{int i,j;

for(i=1;i<=r;i++)

for(j=1;j<=c;j++)

if(i-d<1||i+d>r||j-d<1||j+d>c) 

{

int now=num[i][j]+1; 

map[now][cnt]=INF; 

}

}

 

int Maxflow() //模板；

{int flow=0;

   for(;;)

    {   queue<int> Q;

      memset(p,-1,sizeof(p));       

        Q.push(0);

        while(!Q.empty())

        {int now=Q.front();Q.pop();

            for(int i=1;i<=cnt;i++)

                if(p[i]<0 && map[now][i]>0) 

                    {Q.push(i);

                     p[i]=now;

                     }

                  if(p[cnt]>0) break;

                }

        if(p[cnt]<0) break;

            int minFlow=INF; 

        for(int i=cnt;i!=0;i=p[i])

            minFlow=min(minFlow,map[p[i]][i]);

        for(int i=cnt;i!=0;i=p[i])

      {  map[p[i]][i]-=minFlow;

          map[i][p[i]]+=minFlow;

      }

        flow+=minFlow;

}

return flow;

}

 

void init()

{

    int i,j;

    char s;

    cin>>r>>c>>d;

    for(i=1;i<=r;i++)

        for(j=1;j<=c;j++)

    {cin>>s;

        in[i][j]=s-48;//石柱高度（该点是否有石柱）；

        if(s!='0') 

            {num[i][j]=++cnt;

             map[cnt][cnt+1]=s-48;

            cnt++;}//石柱拆成俩点；

            }

 

 

    for(i=1;i<=r;i++)

        for(j=1;j<=c;j++)

        {cin>>s;

         if(s=='L') 

         {acnt++;

          map[0][num[i][j]]=1;//有蜥蜴的与源点连接；

           }

            if(in[i][j]>0)

                makePic(i,j);//每个石柱遍历建图（数据小）；

             }

 

}

int main()

{

init(); 

cnt++;

escape();

cout<<acnt-Maxflow()<<endl;

return 0;

}

```

---

## 作者：Dispwnl (赞：1)

最大流板子，主要是建图

因为是多源点多汇点，建立总源点总汇点

对于每一根编号为$i$的柱子，新建一个$i+n$

把ta们间建容量为柱子高度的边

对于每一对可以两两到达的柱子$(i,j)$

将$i+n$和$j$的建边，容量为$∞$

$j+n$和$i$同理

对于可以跳出的柱子$i$，将$i+n$与总汇点建边容量为$∞$

对于上面有蜥蜴的柱子，将它与总汇点建边，容量为$1$

最后输出蜥蜴总数与最大流的差

代码：
```cpp
# include<iostream>
# include<cstdio>
# include<cstdlib>
# include<cstring>
# include<queue>
using namespace std;
const int inf=1e8;
struct p{
    int x,y,dis;
}c1[20001],c[20001];
int r,cc,D,n,m,k,num;
int h[8001],d[8001];
int a[51][51],b[51][51];
char ch[51];
void add(int x,int y,int dis)
{
    c[num].x=h[x];
    c[num].y=y;
    c[num].dis=dis;
    h[x]=num++;
}
bool bfs()
{
    memset(d,0,sizeof(d));
    d[0]=1;
    queue<int> qu;
    qu.push(0);
    while(!qu.empty())
    {
        int tt=qu.front();
        qu.pop();
        for(int i=h[tt];i;i=c[i].x)
          if(c[i].dis&&!d[c[i].y])
          {
              d[c[i].y]=d[tt]+1;
              if(c[i].y==k) return 1;
              qu.push(c[i].y);
          }
    }
    return 0;
}
int dfs(int x,int dix)
{
    if(x==k) return dix;
    for(int i=h[x];i;i=c[i].x)
      if(d[c[i].y]==d[x]+1&&c[i].dis)
      {
          int dis=dfs(c[i].y,min(c[i].dis,dix));
          if(dis)
          {
              c[i].dis-=dis;
              c[i^1].dis+=dis;
              return dis;
        }
      }
}
int dinic()
{
    int tot=0;
    while(bfs())
    tot+=dfs(0,inf);
    return tot;
}
int main()
{
    cin>>r>>cc>>D;
    for(int i=1;i<=r;i++)
      {
          cin>>ch+1;
          for(int j=1;j<=cc;j++)
          {
            a[i][j]=ch[j]-48;
            if(a[i][j])
            c1[++n].x=i,c1[n].y=j,c1[n].dis=a[i][j],b[i][j]=n;
          }
      }
    for(int i=1;i<=n;i++)
      {
          add(i+n,i,0);
          add(i,i+n,c1[i].dis);
      }
    for(int i=1;i<n;i++)
      for(int j=i+1;j<=n;j++)
        if((c1[i].x-c1[j].x)*(c1[i].x-c1[j].x)+(c1[i].y-c1[j].y)*(c1[i].y-c1[j].y)<=D*D)
        {
            add(j,i+n,0);
            add(i+n,j,inf);
            add(i,j+n,0);
            add(j+n,i,inf);
        }
    k=n*2;
    for(int i=1;i<=r;i++)
      {
          cin>>ch+1;
          for(int j=1;j<=cc;j++)
          {
            if(ch[j]=='L')
            {
                m++;
                add(b[i][j],0,0);
                add(0,b[i][j],1);
            }
          }
      }
    k++;
    for(int i=1;i<=n;i++)
      if(c1[i].x+D>r||c1[i].x-D<1||c1[i].y+D>cc||c1[i].y-D<1)
      {
          add(k,i+n,0);
          add(i+n,k,inf);
      }
    printf("%d",m-dinic());
    return 0;
}

```

---

## 作者：tqqpt (赞：1)

其实这就是一个Dinic算法+建模；

建模读起来比较复杂，但仔细想想还是可以简单地写出的

解释，注释如下：



```cpp
#include<bits/stdc++.h>
using namespace std;
const int V = 810;
const int INF = 0x3f3f3f3f;
int n,m,sum,ans,x,size,head,tail,s,t,p1=1;
int cur[V],used[V],d[V],f[V];
int num[V][V],dis[V][V],p[V][V];
struct Node{
    int from,to,cap,flow;
}w[V*200];
int Q[V+10];
inline void Add(int from,int to,int cap){
    w[++p1]=(Node){f[from],to,cap,0}; f[from]=p1;//从2开始
    w[++p1]=(Node){f[to],from,0,0}; f[to]=p1;//便于异或，简单关联负边
}
void Read(int &ret){
    ret=0; char ch; int f=1;
    while((ch=getchar())<'0'||ch>'9')
        if(ch=='-')f=-1;
    while(ch>='0'&&ch<='9')
        ret=ret*10+ch-'0',ch=getchar();
    ret*=f;            
}
bool Bfs(){
    memset(used,0,sizeof(used));//用STL也许会慢一些。。。
    d[s]=0; used[s]=1; 
    Q[tail=1]=s; head=0;
    while(head<tail){
        x=Q[++head%V];
        for(int i=f[x]; i ;i=w[i].from){
            Node e=w[i];
            if(!used[e.to]&&e.cap>e.flow){//构建层次图，为Dfs做准备；
                used[e.to]=1;
                Q[++tail%V]=e.to;
                d[e.to]=d[x]+1;        
            }
        }
    }
    return used[t];
}
int Dfs(int x,int a)//阻塞流
{
    if(a==0||x==t)return a;
    int ret,sum=0;
    for(int &i=cur[x]; i; i=w[i].from){//引用，加速，避免下次重复查看。
        Node &e=w[i];//引用，更改原图，阻塞流
        if(d[e.to]==d[x]+1&&(ret=Dfs(e.to,min(a,e.cap-e.flow)))){
            e.flow+=ret;
            sum+=ret;
            w[i^1].flow-=ret;//用异或，简单的关联负边；
            a-=ret;
            if(a==0)break;
        }
    }
    return sum;
}
bool Pd(int i,int j,int ii,int jj,double d)
{
    if(!num[ii][jj])return 0;    
    double x=jj-j,y=ii-i;
    if(sqrt(x*x+y*y)>d)return 0;//判断是否合法，可以走到当前点与否
    return 1;
}
void Init()
{
    int r,c,d,n1;
    char st[V];
    scanf("%d%d%d\n",&r,&c,&d);
    s=0; t=801;
    for(int i=1;i<=r;++i){
        scanf("%s\n",st);
        for(int j=1;j<=c;++j){
            num[i][j]=st[j-1]-'0';
            if(num[i][j]){
                p[i][j]=++n;//记录编号
                n1=n+400;
                Add(n,n1,num[i][j]);//拆点，将点上权值转移到边上，做网络流；
                used[n]=n1;    
                if(i<=d||r-i<d||j<=d||c-j<d)//是否可以出去，是则与汇点相连；
                    Add(n1,t,INF);    
            }
        }
    }
    for(int i=1;i<=r;++i){
        scanf("%s\n",st);
        for(int j=1;j<=c;++j){
            dis[i][j]=st[j-1]-'.';    
            if(dis[i][j]){
                ans++;
                Add(s,p[i][j],1);//一个点只有一个蜥蜴！！ 
            }
            if(num[i][j]){
                for(int ii=max(i-d,1);ii<=min(r,i+d);++ii)
                    for(int jj=max(j-d,1);jj<=min(c,j+d);++jj)
                    if(Pd(i,j,ii,jj,d)&&!(i==ii&&j==jj))//本身不在建边（好像没有卡）
                        Add(used[p[i][j]],p[ii][jj],INF);        
            }
        }
    }
}
void Solve()
{
    int sum=0;
    while(Bfs()){
        memcpy(cur,f,sizeof(f));
        sum+=Dfs(s,INF);    
    }
    ans-=sum;
    if(ans<0)ans=0;//注意！！
    printf("%d\n",ans);
}
int main()
{
    Init();
    Solve();
    return 0;
}
```

---

## 作者：ShineEternal (赞：1)

# 写在前面：
如想获取更佳阅读效果，请点击[这里](https://blog.csdn.net/kkkksc03/article/details/8981640)，任何疑问欢迎私信作者!

# 题目链接：
https://www.luogu.org/problemnew/show/P2472
# 分析：
这道题用最大流解决。

首先构建模型。

一根柱子可以跳入和跳出，于是拆成两个点：入点和出点。

每一根柱子的入点和出点连一条流量为高度的边，来限制蜥蜴跳入的次数。

当柱子a可以调到柱子b时，就从a的出点向b的入点连边，流量inf。

S向所有有蜥蜴的柱子的入点连边，流量为1

T表示地图外一点，当一根柱子能跳到地图外时，则出点向T连流量为inf的边。

然后跑最大流即可。

**这里要注意数组的范围以及拆点。**

# 代码：

```cpp
#include<cstdio>
#include<cstring>
#include<queue>
#include<vector>
#include<iostream> 
#define inf 0x7fffffff
using namespace std;
int s,t,ans;
int d[1005];
struct edge
{
	int to,val,rev;
	edge(int _to,int _val,int _rev)
	{
		to=_to;
		val=_val;
		rev=_rev;
	}
};
vector<edge>e[1005]; 
void add(int x,int y,int w)
{
	e[x].push_back(edge(y,w,e[y].size()));
	e[y].push_back(edge(x,0,e[x].size()-1)); 
}
bool bfs()
{
    memset(d, -1, sizeof(d));
    queue<int> q;
    q.push(s);
    d[s]=0;
    while(!q.empty())
    {
        int x=q.front();
        q.pop();
        for(int i=0;i<e[x].size();i++)
        {
            int y=e[x][i].to;
            if(d[y]==-1 && e[x][i].val)
            {
                q.push(y);
                d[y]=d[x]+1;
            }
        }
    }
    if(d[t]==-1)
        return 0;
    else
        return 1;
}

int dfs(int x,int low)
{
    if(x==t || low==0)
        return low;
    int totflow=0; 
    for(int i=0;i<e[x].size();i++)
    {
        int y=e[x][i].to;
        int rev=e[x][i].rev;
        if(d[y]==d[x]+1 && e[x][i].val) 
        {
            int a=dfs(y,min(low,e[x][i].val));
            e[x][i].val-=a;
            e[y][rev].val+=a;
            low-=a;
            totflow+=a;
            if(low==0)
                return totflow;
        }
    }
    if(low!=0)
        d[x]=-1;
    return totflow;
}

void dinic()
{
	while(bfs())
	{
		ans+=dfs(s,inf);
	}
}
int main()
{
	int n,m,c,cnt=0;
	char ss;
	scanf("%d%d%d",&n,&m,&c);
	s=0,t=n*m*2+1;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cin>>ss;
			if(ss>'0')
			{
				add((i-1)*m+j,(i-1)*m+j+n*m,ss-'0');
			} 
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cin>>ss;
			if(ss=='L')
			{
				add(s,(i-1)*m+j,1);
				cnt++;
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(i+c>n||i-c<1||j+c>m||j-c<1)
			{
				add((i-1)*m+j+n*m,t,inf);
			}
		}
	} 
	for(int x1=1;x1<=n;x1++)
	{
		for(int y1=1;y1<=m;y1++)
		{
			for(int x2=1;x2<=n;x2++)
			{
				for(int y2=1;y2<=m;y2++)
				{
					if((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)<=c*c)
					{
						add((x1-1)*m+y1+n*m,(x2-1)*m+y2,inf);
					}
				}
			}
		}
	}
	dinic(); 
	printf("%d",cnt-ans); 
	return 0;
}
```



---

## 作者：suyiheng (赞：1)

```
**核心思路：**
**蜥蜴的总数-可以逃出的数量=不能逃出的数量。所以这道题其实就是求一个最大的逃出数量。**
**建图：**
1、建一个超级原点，一个超级汇点。每一个石柱建两个点：s1,s2。
2、从超级原点向每一个有蜥蜴的石柱的s1连一条容量为1的边。
3、从每一个s1向他对应的s2连一条容量为那个石柱的高度的边。
4、从每一个石柱的s2向每一个从他那里可以跳到的石柱连一条容量为无限的边。
5、从每一个能跳出地图的石柱向超级汇点连一条容量为无限的边。
最后从超级原点向超级汇点跑一遍最大流就可以了。
最后贴一下蒟蒻的代码：
#include<iostream>
#include<queue>
#include<cmath>
using namespace std;
int n,m,p,k,c[1001][1001],r[1001],bilibili[1001],ans,x[1001],y[1001],z[1001],l;
char ch;
double dou;
void bfs(){
    queue<int> q;
    while(1){
        for(int i=0;i<=k;i++)bilibili[i]=0;
        bilibili[0]=1000000000;
        q.push(0);
        while(!q.empty()){
            int u=q.front();
            q.pop();
            for(int i=1;i<=k;i++){
                if(!bilibili[i]&&c[u][i]>0){
                    bilibili[i]=min(bilibili[u],c[u][i]);
                    r[i]=u;
                    q.push(i);
                }
            }
        }
        if(bilibili[k]==0)break;
        for(int i=k;i!=0;i=r[i]){
            c[r[i]][i]-=bilibili[k];
        }
        ans+=bilibili[k];
    }
    return;
}
int main(){
    cin>>n>>m>>p;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>ch;
            if(ch!='0'){
                k++;
                x[k]=i;
                y[k]=j;
                z[k]=ch-'0';
            }
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>ch;
            if(ch=='L'){
                l++;
                for(int w=1;w<=k;w++){
                    if(x[w]==i&&y[w]==j){
                        c[0][w]=1;
                    }
                }
            }
        }
    }
    for(int i=1;i<=k;i++){
        for(int j=i+1;j<=k;j++){
            dou=sqrt(abs(x[i]-x[j])*abs(x[i]-x[j])+abs(y[i]-y[j])*abs(y[i]-y[j]));
            if(dou<=p){
                c[j+k][i]=100000000;
                c[i+k][j]=100000000;
            }
        }
    }
    for(int i=1;i<=k;i++){
        c[i][i+k]=z[i];
        if(x[i]+p>n||x[i]-p<=0||y[i]+p>m||y[i]-p<=0){
            c[i+k][k*2+1]=1000000000;
        }
    }
    k=k*2+1;
    bfs();
    cout<<l-ans;
}

```

---

## 作者：⚡114514_zzm⚡ (赞：0)

建立一个源点s 和汇点t ，把网格地图中的每个石柱看作一个点。源点s 向每个有蜥蜴的石柱连容量为1的边，距离不超过 d 的石柱之间互连容量为 inf 的边，边界上的石柱向 t连容量为 inf 的边，题目所求就变成了对于这张网络流图，求经过每个石柱的流量不超过其高度的最大流大小。

根据我们上面的分析，可以将石柱i 拆成两个点 i_1,i_2 ，建边 (i_1->i_2) ，容量为石柱高度。跑拆点后的图中s 到 t的最大流即可。

```
#include<bits/stdc++.h>
#define p(a,b) (a-1)*m+b
#define q(a,b) p(a,b)+n*m
#define N 50005
#define M 2000002
#define inf 1<<26
using namespace std;
inline int read()
{
	int x=0,f=1;char ch;
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int n,m,r,s,t,ans;
char mp[101][101];
int ap[101][101];
bool dis(int a,int b,int x,int y)
{return (a-x)*(a-x)+(b-y)*(b-y)<=r*r;}
int head[N],pos=-1,cur[N];
struct edge{int to,next,c;}e[M];
void add(int a,int b,int c)
{pos++;e[pos].to=b,e[pos].c=c,e[pos].next=head[a],head[a]=pos;}
void insert(int a,int b,int c){add(a,b,c);add(b,a,0);}
queue<int>Q;bool vis[N];int d[N];
bool bfs()
{
	for(int i=s;i<=t;i++)vis[i]=0,d[i]=-1;
	vis[s]=1,d[s]=0;Q.push(s);
	while(!Q.empty())
	{
		int u=Q.front();Q.pop();
		for(int i=head[u];i!=-1;i=e[i].next)
		{
			int v=e[i].to;
			if(vis[v]||e[i].c<=0)continue;
			d[v]=d[u]+1;vis[v]=1;Q.push(v);
		}
	}return vis[t];
}
int dfs(int u,int a)
{
	if(u==t||!a)return a;
	int flow=0,f;
	for(int &i=cur[u];i!=-1;i=e[i].next)
	{	
		int v=e[i].to;
		if(d[v]==d[u]+1&&(f=dfs(v,min(e[i].c,a)))>0)
		{
			flow+=f,a-=f;
			e[i].c-=f,e[i^1].c+=f;
			if(!a)break;
		}
	}return flow;
}
int dinic()
{
	int ret=0;
	while(bfs())
	{
		for(int i=s;i<=t;i++)cur[i]=head[i];
		ret+=dfs(s,inf);
	}return ret;
}
void init(){memset(head,-1,sizeof(head));}
bool check(int x,int y)
{
	if(n-x<r||m-y<r||x<=r||y<=r)
	return true;
	return false;
}
int main()
{
	n=read(),m=read(),r=read();
	s=0,t=n*m*2+1;init();
	for(int i=1;i<=n;i++)
		scanf("%s",mp[i]+1);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			ap[i][j]=mp[i][j]-'0';
	for(int i=1;i<=n;i++)
		scanf("%s",mp[i]+1);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		 {
 			if(mp[i][j]=='L')
 			{
 				insert(s,p(i,j),1);
 				ans++;
			 }
			 if(check(i,j))insert(q(i,j),t,inf);
 			 if(ap[i][j])insert(p(i,j),q(i,j),ap[i][j]);
			 for(int x=1;x<=n;x++)
 			 for(int y=1;y<=m;y++)
 			{
 				if(x==i&&y==j)continue;
 				if(dis(i,j,x,y))
 					insert(q(i,j),p(x,y),inf);
 			}
		 }
	printf("%d\n",ans-dinic());
}
```


---

## 作者：arfa (赞：0)

以前做过一道类似的题目:

$$\text JZOJ\ 5948$$

小 $X$ 的国家正在遭受袭击，必须抽调一些魂师上前线增援。
到前线用时最短的路上有一条宽度为 $N$ 米的河，而前来增援的魂师每飞行 $L$ 米就必须在一片荷叶上休息一下，才能够继续飞行。当然，魂师们也可以选择没飞够 $L$ 米就先休息一下，但不能一次飞超过 $L$ 米。
距离河的一侧距离为 $i$ 的荷叶共有 $Ai$ 片，每片荷叶在有魂师停于上方休息后， 就会沉入水底，不能够再供其他魂师休息。
现在小 $X$ 想要知道，至多有多少名魂师能够抵达前线。

条件

- 有一定的跳跃距离
- 每一个荷叶有一定的跳跃次数

那就很简单了吗,每一个荷叶往它的最大跳跃距离连边然后跑最大流。

然后会错。

仔细一看要**拆点**,因为荷叶要限制自己 (并不是什么裂点还有什么乱七八糟的东西,不懂的可以翻阅我的博客)

然后 $80$ 分,仔细看数据: 对于 $100$% 的数据,$1≤L<N≤10^5$,$0≤Ai≤10^4$。

最大流瞬间咕咕,需要 $DP$。

这道题就是上面那道题的加强版,变成了二维。然而 $2007$ 年的省选是那么的水。

按往常一样先画图,再连边 : (下面是一个九宫格版的数据)

![](http://miao.su/images/2018/11/07/19cc8d.png)

要注意是**距离**为 $d$ ! 然后要搞懂求距离小于 $d$ 的公式 (没仔细看被刷 低 $AC$ 率了)

然后就跑 $ISAP$ 就好啦!

![](https://cdn.luogu.com.cn/upload/pic/42980.png)

```pascal
// luogu-judger-enable-o2
Uses math;

var
    value,reach,next,from:array[-1..210000] of longint;
    id:array[-1..41,-1..41,1..2] of longint;
    gap,dis,cnt:array[-1..81000] of longint;
    d,n,m,l,r,k,i,j,sum,tot,sink,source,number,matrix,maxflow,lizard:longint;
    s:ansistring;

procedure add(l,r,sum:longint);
begin
    inc(tot); from[tot]:=l; reach[tot]:=r; value[tot]:=sum; next[tot]:=cnt[l]; cnt[l]:=tot;
    inc(tot); from[tot]:=r; reach[tot]:=l; value[tot]:=8-8; next[tot]:=cnt[r]; cnt[r]:=tot;
end;

function Dfs(now,flow:longint):longint;
var i,k,mindis,ret:longint;
begin
    mindis:=n-1; ret:=flow;
    if now=sink then exit(flow);
    i:=cnt[now];
    while i<>-1 do
    begin
        if value[i]>0 then
        begin
            if dis[now]=dis[reach[i]]+1 then
            begin
                k:=Dfs(reach[i],min(ret,value[i]));
                dec(value[i],k);inc(value[i xor 1],k);
                dec(ret,k);
                if dis[source]>=n then exit(flow-ret);
                if ret=0 then break;
            end;
             mindis:=min(mindis,dis[reach[i]]);
        end;
        i:=next[i];
    end;
    if ret=flow then
    begin
        dec(gap[dis[now]]);
        if gap[dis[now]]=0 then dis[source]:=n;
        dis[now]:=mindis+1;
        inc(gap[dis[now]]);
    end;
    exit(flow-ret);
end;

begin
    filldword(cnt,sizeof(cnt) div 4,maxlongint*2+1); tot:=1;
    readln(n,m,d); source:=1; sink:=(1+n*m) << 1; number:=0;

    for i:=1 to n do
    begin readln(s);
        for j:=1 to m do
        begin
            inc(number); id[i,j,1]:=number << 1; id[i,j,2]:=id[i,j,1]+1;
            val(s[j],matrix); add(id[i,j,1],id[i,j,2],matrix);
        end;
    end;
    for i:=1 to n do
    begin readln(s);
        for j:=1 to m do if s[j]='L' then begin inc(lizard); add(source,id[i,j,1],1); end;
    end;
    for i:=1 to n do for j:=1 to m do if (i+d>n)or(i-d<1)or(j+d>m)or(j-d<1) then add(id[i,j,2],sink,maxlongint);
    for i:=1 to n do for j:=1 to m do for l:=1 to n do for r:=1 to m do if (i-l)*(i-l)+(j-r)*(j-r)<=d*d then add(id[i,j,2],id[l,r,1],maxlongint);

    n:=sink+1; gap[source]:=n;
    while dis[source]<n do inc(maxflow,Dfs(source,maxlongint));
    writeln(lizard-maxflow);
end.
```

---

## 作者：Rec° (赞：0)

欢迎访问 [juruo的博客](https://rec.ac.cn/?p=318)
## Solution：
题意很好理解 就不赘述了
易知只有高度大于$0$的石柱才可能对答案有贡献  所以我们可以在读入的时候把这些节点单独拿出来重新标号    
我们可以建立一个虚拟源点和虚拟汇点    
首先能想到所有可以跳出网格的点（重新标号后）一定是要与汇点连接一条流量为$INF$的边    
再将每个点拆开成入点和出点 流量为这个点的高度   
之后处理两个可以互相到达的点 互相连一条流量为$INF$的出点连入点的边  
最后把源点与蜥蜴所在点连一条流量为1的边   
跑一次最大流 剩下的蜥蜴就是总数减可以跑掉了的了
## Code：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 100001;
const int M = 1000001;
const int INF = 1e9;
int head[N], nex[N], to[N], val[N], ce = -1;
inline void add(int u, int v, int w){
	to[++ ce] = v, nex[ce] = head[u], head[u] = ce, val[ce] = w;
	to[++ ce] = u, nex[ce] = head[v], head[v] = ce, val[ce] = 0;
}
char mp[2001];
int dep[N];
int r, c, d, re = 1, s, t;
struct node{
	int x, y, w;
	bool has;
}a[N];
bool bfs(){
	memset(dep, -1, sizeof dep);
	queue<int > q;
	dep[s] = 0; q.push(s);
	while(q.size()){
		int u = q.front(); q.pop();
		for(register int i = head[u]; i != -1; i = nex[i]){
			int v = to[i];
			if(val[i] && dep[v] == -1){
				dep[v] = dep[u] + 1;
				q.push(v);
			}
		}
	}
	return dep[t] != -1;
}
int dfs(int u, int flow){
	if(u == t) return flow;
	int now = 0;
	for(register int i = head[u]; i != -1; i = nex[i]){
		int v = to[i];
		if(val[i] && dep[v] == dep[u] + 1){
			int tmp = dfs(v, min(flow, val[i]));
			flow -= tmp;
			val[i] -= tmp;
			val[i ^ 1] += tmp;
			now += tmp;
			if(flow == 0) break;
		}
	}
	return now;
}
inline int maxflow(){
	int ans = 0;
	while(bfs())
		ans += dfs(s, INF);
	return ans;
}
inline int read(){
	int x = 0; char ch = getchar();
	while(ch < '0' || ch > '9') ch = getchar();
	while(ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();
	return x;
}
int main(){
	memset(head, -1, sizeof head);
	r = read(), c = read(), d = read();
	for(register int i = 1; i <= r; ++ i){
		scanf("%s", mp + 1);
		for(register int j = 1; j <= c; ++ j){
			if(mp[j] > '0'){
				a[++ re].x = i;
				a[re].y = j;
				a[re].w = mp[j] - '0';
			}
		}
	}
	int sum = 0;
	for(register int i = 1; i <= r; ++ i){
		scanf("%s", mp + 1);
		for(register int j = 1; j <= c; ++ j){
			if(mp[j] == 'L'){
				for(register int k = 2; k <= re; ++ k){
					if(a[k].x == i && a[k].y == j){
						a[k].has = 1;
						++ sum;
					}
				}
			}
		}
	}
	s = 1, t = re << 1;
	for(register int i = 2; i <= re; ++ i)
		if(a[i].has) add(s, i, 1);
	for(register int i = 2; i <= re; ++ i)
		add(i, i + re - 1, a[i].w);
	for(register int i = 2; i <= re; ++ i)
	for(register int j = 2; j < i; ++ j){
		if((a[i].x - a[j].x) * (a[i].x - a[j].x) + (a[j].y - a[i].y) * (a[j].y - a[i].y) <= d * d) {
			add(j + re - 1, i, INF);
			add(i + re - 1, j, INF);
		}
	}
	for(int i = 2; i <= re; ++ i){
		int x = a[i].x, y = a[i].y;
		if(x + d > r || x - d < 1 || y + d > c || y - d < 1)
			add(i + re - 1, t, INF);
	}
	int ans = sum - maxflow();
	printf("%d", ans);
	return 0;
}

```

---

## 作者：localhost (赞：0)

网络流好题！！！

网络流一般都难在建图，后来看到题解里没有一张用来解释的图我就太发一张。

这道题难在把石柱拆点（入口，出口），把石柱高度想成可以用多少次。

我们首先从源点向各个石柱的入口连边（有蜥蜴）边长为1

接着，我们把各个石柱的入口与出口连边（边长为石柱高度）

下一步，我们把各个距离不超过d的石柱连边：出口---入口

最后，我们把各个石柱与汇点连边（可以跳出边界）

上图:

![](https://cdn.luogu.com.cn/upload/pic/18181.png )

上代码：

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#define ll long long
#define max(x,y) ((x)>(y)?(x):(y))
#define min(x,y) ((x)<(y)?(x):(y))
#define fur(i,x,y) for(i=x;i<=y;i++)
#define fdr(i,x,y) for(i=x;i>=y;i--)
#define Fur(i,x,y) for(ll i=x;i<=y;i++)
#define Fdr(x,y) for(ll i=x;i>=y;i--)
#define in2(x,y) in(x);in(y)
#define in3(x,y,z) in2(x,y);in(z)
#define in4(a,b,c,d) in2(a,b);in2(c,d)
#define clr(x,y) memset(x,y,sizeof(x))
#define cpy(x,y) memcpy(x,y,sizeof(x))
#define fl(i,x) for(ll i=head[x],to;to=e[i].to,i;i=e[i].next)
#define inf 233333333
using namespace std;
/*---------------------------------------*/
namespace fib{char b[300000]= {},*f=b;}
#define gc ((*fib::f)?(*(fib ::f++)):(fgets(fib::b,sizeof(fib::b),stdin)?(fib::f=fib::b,*(fib::f++)):-1))
inline void in(ll &x){x=0;char c;bool f=0;while((c=gc)>'9'||c<'0')if(c=='-')f=!f;x=c-48;while((c=gc)<='9'&&c>='0')x=x*10+c-48;if(f)x=-x;}
namespace fob{char b[300000]= {},*f=b,*g=b+300000-2;}
#define pob (fwrite(fob::b,sizeof(char),fob::f-fob::b,stdout),fob::f=fob::b,0)
#define pc(x) (*(fob::f++)=(x),(fob::f==fob::g)?pob:0)
struct foce{~foce(){pob;fflush(stdout);}} _foce;
namespace ib{char b[100];}
inline void out(ll x){if(x==0){pc(48);return;}if(x<0){pc('-');x=-x;}char *s=ib::b;while(x) *(++s)=x%10,x/=10;while(s!=ib::b) pc((*(s--))+48);}
inline void outn(ll x){out(x);pc('\n');}
inline void swap(ll &x,ll &y){ll t=x;x=y;y=t;}
inline ll jdz(ll x){return x>=0?x:-x;}
/*------------------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------------*/
#define N 5001
struct edge{ll w,to,next;}e[N*N/4];
ll head[N],n,m,r,c,k,st,ed,cnt=2,q[N],d[N],b=0,ps=1,ans=0;
bool v[21][21];
inline void add(ll x,ll y,ll w){
	e[cnt].w=w;e[cnt].to=y;e[cnt].next=head[x];head[x]=cnt++;
	swap(x,y);e[cnt].w=0;e[cnt].to=y;e[cnt].next=head[x];head[x]=cnt++;
}
inline bool bfs(){
	ll h=0,t=1,x;clr(d,0);
	q[h]=st;d[st]=1;
	while(h<t){
		x=q[h++];if(x==ed)return 1;
		fl(i,x)if(e[i].w&&!d[to]){d[to]=d[x]+1;q[t++]=to;}
	}return 0;
}
inline ll dfs(ll x,ll mf){
	if(x==ed)return mf;
	ll u=0,w;
	fl(i,x)
	if(e[i].w&&d[to]==d[x]+1){
		w=mf-u;
		w=dfs(to,min(w,e[i].w));
		e[i].w-=w;e[i^1].w+=w;
		u+=w;
		if(u==mf)return u;
	}
	if(!u)d[x]=-1;
	return u;
}
inline bool pd(ll x,ll y){return x*x+y*y<=k*k;}
struct sz{ll l,r,x,y;}p[N];
int main(){
	in3(r,c,k);ed=1;
	char s[21];
	Fur(i,1,r){
		scanf("%s",s+1);
		Fur(j,1,c)
		if(s[j]!=48){
			p[++b].l=++ps;p[b].r=++ps;add(ps-1,ps,s[j]-48);
			p[b].x=i;p[b].y=j;
			if(i<=k||j<=k||r-i+1<=k||c-j+1<=k)add(ps,ed,inf);
		}
	}
	Fur(i,1,b)Fur(j,i+1,b)
	if(pd(p[i].x-p[j].x,p[i].y-p[j].y))add(p[i].r,p[j].l,inf),add(p[j].r,p[i].l,inf);
	Fur(i,1,r){scanf("%s",s+1);Fur(j,1,c)if(s[j]=='L')ans--,v[i][j]=1;}st=ps+1;
	Fur(i,1,b)if(v[p[i].x][p[i].y])add(st,p[i].l,1);
	
	while(bfs())ans+=dfs(st,inf);
	out(-ans);
}

/*

*/
```

---

## 作者：半仙胡小桃 (赞：0)

这个建边要用到点

石柱的高度其实就是能经过蜥蜴的个数

将石柱拆分成两个点一个入点，一个出点，其容量就是石柱的高度了

如果两个石柱两两可以到达，那么在A的出点向B的入点建一条边，其容量为INF，来模拟蜥蜴跳过去的过程

虚拟两个点，一个为源点s，一个为汇点t，如果石柱上有蜥蜴的话，从s到石柱的入点连一条边，容量为1，表示跳过一只蜥蜴

如果蜥蜴在这个石柱上可以跳出地图，那么从石柱的出点向t连一条边容量为INF，模拟蜥蜴跳的过程

这样的话跑从s到t的最大流就是蜥蜴逃出的最大数了，再用蜥蜴的总数一减就是答案了

我用的是EK，懒得改Dinci，用的矩阵，反正图小

AC代码如下












```cpp
#include <cstdio>
#include <iostream>
#include <queue>  
#include <cstring>
using namespace std;
const int INF=0x7fffffff;
int n,m,d;
char high[1001][1001];
int map[1010][1010];
int cnt;
int ans;
int in[1001][1001];
int flow[10001];
int pre[10001];
queue<int> dl;
void make_map(int x,int y)  
{  
  int now=in[x][y]+1;  
  for (int i=1;i<=n;i++)  
    for (int j=1;j<=m;j++)  
      if((i!=x||j!=y)&&(high[i][j]>'0'))  
      {  
        if (d*d>=(x-i)*(x-i)+(y-j)*(y-j))  
          map[now][in[i][j]]=INF;  
      }  
}
void go()
{
    for (int i=1;i<=n;i++)  
     for (int j=1;j<=m;j++)  
      if (i-d<1||i+d>n||j-d<1||j+d>m)  
      {  
        int dd=in[i][j]+1;  
        map[dd][cnt]=INF;  
      }  
}
int BFS(int s,int t)
{
    while(!dl.empty())
     dl.pop();
    memset(pre,-1,sizeof(pre));
    pre[s]=0;
    flow[s]=INF;
    dl.push(s);
    while(!dl.empty())
    {
        int dd=dl.front();
        dl.pop();
        if(dd==t)
         break;
        for(int i=1;i<=cnt;i++)
         if(map[dd][i]>0&&pre[i]==-1)
          {
            pre[i]=dd;
            flow[i]=min(flow[dd],map[dd][i]);
            dl.push(i);
          }
    }
    if(pre[t]==-1)
     return -1;
    else 
     return flow[t];
}
int max_flow(int s,int t)
{
    int mflow=0;
    int d=0;
    while((d=BFS(s,t))!=-1)
    {
        int k=t;
        while(k!=s)
         {
            map[pre[k]][k]-=d;
            map[k][pre[k]]+=d;
            k=pre[k];
         } 
        mflow+=d;
    }
    return mflow;
}
int main()
{
    scanf("%d%d%d",&n,&m,&d);
    for(int i=1;i<=n;i++)
     for(int j=1;j<=m;j++)
      {
        cin>>high[i][j];
        if(high[i][j]!='0')
         {
            in[i][j]=++cnt;
            map[cnt][++cnt]=high[i][j]-'0';
         }
      } 
    for(int i=1;i<=n;i++)
     for(int j=1;j<=m;j++)
      {
        char c;
        cin>>c;
        if(c=='L') ans++,map[0][in[i][j]]=1;
        if(high[i][j]>'0') make_map(i,j);
      }
    cnt++;
    go();
    printf("%d",ans-max_flow(0,cnt));
    return 0;
}
```

---

## 作者：地霊的业火 (赞：0)

先%ZYF....Orz

LS的EK比我的Dinic跑的要快Orz


做法无差别，贴一发Dinic的模板。

```cpp

#include<cstdio>
#include<cstring>
#define INF 5000
using namespace std;

int cnt,d[10005];
struct node
{    int u,v,w,next;};
node e[100005];
int head[100005];
int tot;
int a[105][105];
int b[105][105][5];
int c[100005][5];
int n,m,jl,S,T,num,ans;

int min(int x,int y){ if (x<y) return x;else return y;}
void ins(int u,int v,int w)
{    cnt++;
    e[cnt].w=w;e[cnt].u=u;e[cnt].v=v;
    e[cnt].next=head[u];head[u]=cnt;
}
void insert(int u,int v,int w)
{    ins(u,v,w);ins(v,u,0);}
void insert2(int x,int y)
{    tot++;
    b[x][y][1]=tot;
    c[tot][1]=x;c[tot][2]=y;c[tot][3]=1;
    tot++;
    b[x][y][2]=tot;
    c[tot][1]=x;c[tot][2]=y;c[tot][3]=2;
}
bool check(int x2,int y2,int x1,int y1)
{    if (((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))<=jl*jl)
        return 1;
    else return 0;
}

bool build()
{
    int l=0,r=1;
    int q[10005];
    memset(d,-1,sizeof(d));
    q[1]=S;d[S]=0;
    while (l<r)
    {    l++;
        int x=q[l];
        for (int i=head[x];i;i=e[i].next)
        {    int y=e[i].v;
            if (e[i].w and d[y]==-1)
            {    d[y]=d[x]+1;
                r++;
                q[r]=y;
                if (y==T) return 1;
            }
        }
    }    return 0;
}

int find(int now,int flow)
{
    int ret,w=0;
    if (now==T) return flow;
    for (int i=head[now];i and w<flow;i=e[i].next)
    {    int y=e[i].v;
        if (e[i].w and d[y]==d[now]+1 and (ret=find(y,min(flow-w,e[i].w))))
        {    e[i].w-=ret;e[i xor 1].w+=ret;w+=ret;}
    }
    if (w==0) d[now]=-1;
    return w;
}

int dinic()
{
    int ans=0;
    while (build())
    {
        while (1)
        {    int flow=find(S,INF);
            if (flow==0) break;
            ans+=flow;
        }
    }
    return ans;
}

int main()
{
    memset(a,0,sizeof(a));
    memset(b,0,sizeof(b));
    memset(c,0,sizeof(c));
    memset(head,0,sizeof(head));
    memset(e,0,sizeof(e));
    
    scanf("%d%d%d",&n,&m,&jl);
    num=0;tot=0;cnt=1;
    S=0;T=INF;
    for (int i=1;i<=n;i++)
    {    char cha[1005];
        scanf("%s",cha);
        for (int j=1;j<=m;j++)
        {    a[i][j]=cha[j-1]-'0';
            if (a[i][j]!=0)
            {    insert2(i,j);
                insert(b[i][j][1],b[i][j][2],a[i][j]);
                for (int k=1;k<=tot;k++)
                {    if (check(i,j,c[k][1],c[k][2]))
                    {    if (c[k][3]==1)
                            insert(b[i][j][2],k,INF);
                        else insert(k,b[i][j][1],INF);
                    }
            }    }
    }    }
    for (int i=1;i<=n;i++)
    {    char cha[1005];
        scanf("%s",cha);
        for (int j=1;j<=m;j++)
        {    if (cha[j-1]=='L')    
            {ans++;insert(S,b[i][j][1],1);}
        }
    }
    for (int i=1;i<=n;i++)
        for (int j=1;j<=m;j++)
            if ((i<=jl or j<=jl or (n-i+1)<=jl or (m-j+1)<=jl) and a[i][j]!=0)
            {    insert(b[i][j][2],T,INF);}
    
    printf("%d\n",ans-dinic());
}

```

---

## 作者：yzhang (赞：0)

### [更好的阅读](https://www.cnblogs.com/yzhang-rp-inf/p/10316584.html )

### [原题传送门](https://www.luogu.org/problemnew/show/P2472)

题目要求无法逃离的最少有多少

直接做肯定不好做，我们帮题目变一个说法：最多能逃离多少

这个询问一看就是最大流

考虑如何建图：

1.将S和每一个有蜥蜴的点连一条流量为1的边（每个蜥蜴只能用1次）

2.每个点拆成两个点（一个点用来连接从其他点连来的边，另一个点用来向其他的点连边，下同），从前一个点向后一个点连一条流量为石柱高度的边（每个石柱只能踩它的高度次）

3.能互相到达的石柱之间连一条流量为inf的边

4.将每一个能跳出地图的点向T连一条流量为inf边

建图后跑一下最大流即可求出答案

```cpp
#include <bits/stdc++.h>
#define N 1005
#define M 80005
#define inf (1<<30)
#define getchar nc
using namespace std;
inline char nc(){
    static char buf[100000],*p1=buf,*p2=buf; 
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++; 
}
inline int read()
{
    register int x=0,f=1;register char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return x*f;
}
inline void write(register int x)
{
    if(!x)putchar('0');if(x<0)x=-x,putchar('-');
    static int sta[20];register int tot=0;
    while(x)sta[tot++]=x%10,x/=10;
    while(tot)putchar(sta[--tot]+48);
}
inline int Min(register int a,register int b)
{
    return a<b?a:b;
}
inline int Max(register int a,register int b)
{
    return a>b?a:b;
}
struct node{
    int to,next,v;
}e[M];
int head[N],cnt=1;
inline void add(register int u,register int v,register int val)
{
    e[++cnt]=(node){v,head[u],val};
    head[u]=cnt;
}
int n,s,t,maxflow=0,sum=0;
int px[N],py[N],tot=0; 
int dep[N],gap[N],cur[N];
inline void bfs()
{
    memset(dep,-1,sizeof(dep));
    memset(gap,0,sizeof(gap));
    dep[t]=0;
    ++gap[dep[t]];
    queue<int> q;
    q.push(t);
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        for(register int i=head[u];i;i=e[i].next)
        {
            int v=e[i].to;
            if(dep[v]!=-1)
                continue;
            q.push(v);
            dep[v]=dep[u]+1;
            ++gap[dep[v]];
        }
    }
}
inline int dfs(register int u,register int flow)
{
    if(u==t)
    {
        maxflow+=flow;
        return flow;
    }
    int used=0;
    for(register int i=cur[u];i;i=e[i].next)
    {
        cur[u]=i;
        int v=e[i].to;
        if(e[i].v&&dep[v]+1==dep[u])
        {
            int tmp=dfs(v,Min(e[i].v,flow-used));
            if(tmp)
            {
                e[i].v-=tmp;
                e[i^1].v+=tmp;
                used+=tmp;
            }
            if(used==flow)
                return used;
        }
    }
    --gap[dep[u]++]==0?dep[s]=n+1:++gap[dep[u]];
    return used;
}
inline void ISAP()
{
    maxflow=0;
    bfs();
    while(dep[s]<n)
    {
        memcpy(cur,head,sizeof(head));
        dfs(s,inf);
    }
}
int main()
{
    int r=read(),c=read(),d=read();
    n=r*c,s=0,t=(n<<1)+1;
    for(register int i=1;i<=r;++i)
        for(register int j=1;j<=c;++j)
        {
            char ch=getchar();
            while(ch!='0'&&ch!='1'&&ch!='2'&&ch!='3')
                ch=getchar();
            ch-=48;
            if(ch)
            {
                add(c*(i-1)+j,c*(i-1)+j+n,ch),add(c*(i-1)+j+n,c*(i-1)+j,0);
                if(i<=d||i+d>r||j<=d||j+d>c)
                    add(c*(i-1)+j+n,t,inf),add(t,c*(i-1)+j+n,0);
                px[++tot]=i,py[tot]=j; 
            }
        }
    for(register int i=1;i<=tot;++i)
        for(register int j=i+1;j<=tot;++j)
            if(d*d>=(px[i]-px[j])*(px[i]-px[j])+(py[i]-py[j])*(py[i]-py[j]))
            {
                add(c*(px[i]-1)+py[i]+n,c*(px[j]-1)+py[j],inf),add(c*(px[j]-1)+py[j],c*(px[i]-1)+py[i]+n,0);
                add(c*(px[j]-1)+py[j]+n,c*(px[i]-1)+py[i],inf),add(c*(px[i]-1)+py[i],c*(px[j]-1)+py[j]+n,0);
            }
    for(register int i=1;i<=r;++i)
        for(register int j=1;j<=c;++j)
        {
            char ch=getchar();
            while(ch!='.'&&ch!='L')
                ch=getchar();
            if(ch=='L')
                add(s,c*(i-1)+j,1),add(c*(i-1)+j,s,0),++sum;
        }
    ISAP();
    write(sum-maxflow);
    return 0;
}
```

---


# [SCOI2008] 警告

## 题目描述

有一个简单的脚本语言，只有赋值语句、条件语句和返回语句三种。变量名必须是单个大写字母，且变量都是 $32$ 位带符号整数。

该语言的每条语句必须单独占一行。程序中不含空行，且每行的行首行末均无空格。每行的不同 token 之间用单个空格隔开。该语言的 BNF 如下：

```cpp
<line> :: <head> | <assignment> | <if> | ELSE | END IF | <return>
<head> :: PARAM <paramlist> | PARAM
<assignment> :: <variable> = <rvalue>
<if> :: IF <variable> <relation> <value> THEN
<return> :: RETURN <value>
<paramlist> :: <variable> | <variable> <paramlist>
<rvalue> :: <value> | <value> <operator> <value>
<value> :: <variable> | <integer>
<operator> :: + | - | * | /
<relation> :: < | = | >
<variable> :: A | B | ... | Z
<integer> :: 不含前导 0 的 32 位带符号整数
```
程序的第一行是一条 `<head>` 语句，定义了函数的参数，而最后一行一定是 `<return>` 语句。`<head>` 语句不能在除了第一行之外的其他任何地方出现，但 `<return>` 语句可以在程序中多次出现。行号从 $1$ 开始编号。
每条 `IF` 语句一定有一个配套的 `END IF` 语句，还有一个可选的 `ELSE` 语句（注意没有 `ELSE IF` 语句）。`IF` 语句可以嵌套，它总是比较一个变量和一个整数或者另一个变量。

你应该分析一个给定的程序，并输出两类警告信息（格式见样例输出）：

- 第一类警告：无法到达的代码行。不管各条 `IF` 语句的布尔表达式是真还是假（假设每条 `IF` 语句的布尔表达式都是既可能为真也可能为假，不受其他 `IF` 语句结果影响）。

- 第二类警告：可能未初始化的变量。该语句用到了某个变量的值，但这个变量既不在第一行指定的参数列表里，也没有在此之前由赋值语句赋值过。如果这条语句无法到达，那么不应该给出这类警告。

注意，语句 `ELSE` 和 `END IF` 不是可执行语句，因此不应该收到任何警告信息。


## 样例 #1

### 输入

```
PARAM A B
IF A > 5 THEN
C = B * A
END IF
D = B - C
Z = Y + X
E = T
F = E + E
V = G + G
RETURN F```

### 输出

```
Line 5: variable C might not have been
initialized
Line 6: variable X might not have been
initialized
Line 6: variable Y might not have been
initialized
Line 7: variable T might not have been
initialized
Line 9: variable G might not have been
initialized```

## 样例 #2

### 输入

```
PARAM G
RETURN G
B = K
RETURN C```

### 输出

```
Line 3: unreachable code
Line 4: unreachable code```

## 样例 #3

### 输入

```
PARAM T C
B = T
A = 4
IF A < 4 THEN
IF B > 3 THEN
Q = 100 + F
ELSE
IF C = -1111111111 THEN
Q = T - A
IF Q = 0 THEN
V = V - 1
END IF
ELSE
RETURN I
E = A
END IF
END IF
ELSE
Q = 1
END IF
RETURN Q```

### 输出

```
Line 6: variable F might not have been
initialized
Line 11: variable V might not have
been initialized
Line 14: variable I might not have
been initialized
Line 15: unreachable code```

# 题解

## 作者：fanypcd (赞：10)

[P2509 [SCOI2008]警告 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2509)

# 写在前面的话

第一篇 c++ 题解。

见过真正恶心的模拟题吗，这道就是了。（我贡献了 4 页提交记录（我敲 勇 的。

~~这可以为你以后的开发工作打（提）下（前）基（劝）础（退）~~

总之题目就是想让你实现一个简单的编译器，支持输出未定义的变量和不可到达的行两种警告。

对于这道题，我只想说它不仅考验了一个 OIer 的代（心）码（理）能（素）力（质），还有你的代码习惯，特别是模块化编程的思想（如果有人能在一个 main 里面搞完我就佛了）。

------

# 几个坑点

先放前面，以便调题自闭的人来康康：

1. 如果 IF 中两个分支均定义了某个变量，那么这个变量在 IF 后也算定义了（分支中 RETURN 则算所有变量都定义过）
2. 如果一个 IF 的两个条件分支都 RETURN，这个 IF 后的语句作废
3. ELSE & END IF 不算 unreachable line
4. RETURN 后即使有变量未初始化也不考虑了
5. 一行内一个变量最多算一次未定义

------

# 题目做法

## 读入

我们先定义一个 ```get(i, pos)``` 函数，表示从读入的代码文本中第 i 行第 pos 列开始连续的一段文本，返回值为 string 。（显然一个连续文本段的前后都是不合法字符（如空格）。）

可以这样实现：

```cpp
bool check(char x)
{
	if((x >= 'A' && x <= 'Z') || (x >= '0' && x <= '9') || (x == '+' || x == '-' || x == '*' || x == '/') || (x == '>' || x == '<' || x == '='))
	{
		return 1;
	}
	return 0;
}
string get(int i, int &pos)
{
	int num = (pos ? 0 : 1);//这里是因为 0 位置前面也得算作一个不合法位
	string ret;
	for(; pos < s[i].size(); pos++)
	{
		if(check(s[i][pos]))
		{
			ret.push_back(s[i][pos]);
		}
		else
		{
			if(++num == 2)
			{
				break;
			}
		}
	}
	return ret;
}
```

这样我们调用一次 get 就可以得到连续的一段文本了，便于后续的处理。

然后我们分别考虑处理每一种语句。

因为变量最多有 26 个（ A - Z ），我们可以用一个整型的每一个二进制位表示对应的变量出现情况。

令函数 ```work(i, j, defined)``` 对文本段中行数为 $[i,j]$​ （包含 i 和 j ），且之前的变量定义状态为 defined 的文本进行处理。函数的返回值（ int ）表示在函数中定义过的变量（如果处理的这一段必定  RETURN 返回 ```0x7fffffff``` ）。

现在只需要考虑分别处理：

- PARAM
- IF THEN & ELSE & END IF & 条件判断语句
- 赋值语句
- RETURN

## 处理 PARAM 语句

PARAM 语句后的变量在全局均要算作已初始化，所以逐个读入所有变量，修改 defined 对应位即可。

```cpp
if(newword == "PARAM")
{
    for(; pos < s[idx].size(); )
    {
        newword = get(idx, pos);
        if(newword.size() == 1 && newword[0] >= 'A' && newword[0] <= 'Z')
        {
            defined |= (1 << (newword[0] - 'A'));
        }
    }
}
```

其中：idx 表示遍历到的行号，pos 表示当前行枚举到的位置。

这是最好处理的语句了。

## 处理 IF 语句 & 条件判断语句

这是最难的语句，需要 72 行 1425 长度。

IF 语句可不能直接处理完就跳过，因为坑点 1 所以我们需要处理到这个 IF 对应的 END IF 为止。

并且如果中间有 ELSE 还要特殊处理条件分支中定义的变量（或者 RETURN 标记（坑点 2 ））。

定义 $shown$ 中逐位保存条件分支中定义的变量（ RETURN 标记记在 27 位，因为只有 26 个单词（其实 26 位也可以，因为从 0 开始））

$shown$​ 初值设置为 ```0xffffffff``` 即二进制下每一位都是 1 （因为要做 & 运算）。

然后对于每个分支，```shown &= work(···)```​（如果只有一个条件分支，```shown = 0xffffffff``` ）。

至于怎么判断这个 IF 对应的 ELSE 和 END IF 位置，相信敢来写这题的都知道 stack 是什么吧。

```cpp
else if(newword == "IF")
{
    int vis = 0;//这里 vis 是记录 IF 后的条件判断语句中未定义变量的出现次数，至多 1 次。
    for(; pos < s[idx].size(); )
    {
        newword = get(idx, pos);
        if(newword.size() == 1 && newword[0] >= 'A' && newword[0] <= 'Z')
        {
            if(!(defined & (1 << (newword[0] - 'A'))) && !(vis & (1 << (newword[0] - 'A'))))
            {
                E[++cnt].id = newword[0];
                E[cnt].line = idx;
                E[cnt].opt = 2;
                vis |= (1 << (newword[0] - 'A'));
            }
        }
    }
    int i, wz, flag = 0;
    string nw;
    stack<int> st;
    st.push(idx);
    for(i = idx + 1; i <= r && !st.empty(); i++)
    {
        wz = 0;
        nw = get(i, wz);
        if(nw == "IF")
        {
            st.push(i);
        }
        else if(nw == "ELSE" && st.size() == 1)
        {
            flag = i;
            if(shown == 0xffffffff)
            {
                shown = work(st.top() + 1, i - 1, defined);
            }
            else
            {
                shown &= work(st.top() + 1, i - 1, defined);
            }
        }
        else if(nw == "END")
        {
            st.pop();
        }
    }
    if(flag)
    {
        shown &= work(flag + 1, i - 2, defined);
    }
    else
    {
        shown = 0xffffffff;
        work(idx + 1, i - 2, defined);
    }
    idx = i - 1;
    if((shown & (1 << 27)) && shown != 0xffffffff)//如果所有条件分支必定 RETURN，则后面语句 unreachable
    {
        idx++;
        for(; idx <= r; idx++)
        {
            wz = 0;
            nw = get(idx, wz);
            if(nw != "ELSE" && nw != "END")
            {
                E[++cnt].line = idx;
                E[cnt].opt = 1;
            }
        }
        shown = 0x7fffffff;//这时视为所有变量都已定义过
    }
}
```

## 处理赋值语句

赋值语句其实很好处理，有一个坑点就是作为左值的变量如果在右值中出现，视为未定义，如 ```C = C + 1``` 。

注意要判断文本长度一定为 1，然后就差不多了。

```cpp
else if(newword.size() == 1 && newword[0] >= 'A' && newword[0] <= 'Z')
{
    int vis = 0;
    char mem = newword[0];
    for(; pos < s[idx].size(); )
    {
        newword = get(idx, pos);
        if(newword.size() == 1 && newword[0] >= 'A' && newword[0] <= 'Z')
        {
            if(!(defined & (1 << (newword[0] - 'A'))) && !(vis & (1 << (newword[0] - 'A'))))
            {
                E[++cnt].id = newword[0];
                E[cnt].line = idx;
                E[cnt].opt = 2;
                vis |= (1 << (newword[0] - 'A'));
            }
        }
    }
    defined |= (1 << (mem - 'A'));//最后将左值变量记为已定义
}
```

## 处理 RETURN 语句

到了这里刚才定义 ```work```  的 $[l,r]$​  的好处就凸显出来了，RETURN 语句至多只能影响到 r 行。

遇见 RETURN，首先判断返回值（是变量的话）是否定义，然后将语句后面的全部输出警告。

```cpp
else if(newword == "RETURN")
{
    int vis = 0;
    for(; pos < s[idx].size(); )
    {
        newword = get(idx, pos);
        if(newword.size() == 1 && newword[0] >= 'A' && newword[0] <= 'Z')
        {
            if(!(defined & (1 << (newword[0] - 'A'))) && !(vis & (1 << (newword[0] - 'A'))))
            {
                E[++cnt].id = newword[0];
                E[cnt].line = idx;
                E[cnt].opt = 2;
                vis |= (1 << (newword[0] - 'A'));
            }
        }
    }
    int wz;
    string nw;
    idx++;
    for(; idx <= r; idx++)
    {
        wz = 0;
        nw = get(idx, wz);
        if(nw != "ELSE" && nw != "END")
        {
            E[++cnt].line = idx;
            E[cnt].opt = 1;
        }
    }
    shown = 0x7fffffff;
}
```

## 对于 defined 的更新

每次处理完一块语句后，如果 ```shown != 0xffffffff``` 则 ```defined |= shown```。

```cpp
if(shown != 0xffffffff)
{
    defined |= shown;
}
```

# Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct error
{
	int opt, line;
	char id;
};
error E[10005];
bool cmp(error a, error b)
{
	if(a.line != b.line)
	{
		return a.line < b.line;
	}
	return a.id < b.id;
}
int tot, cnt;
string s[10005];
bool check(char x)
{
	if((x >= 'A' && x <= 'Z') || (x >= '0' && x <= '9') || (x == '+' || x == '-' || x == '*' || x == '/') || (x == '>' || x == '<' || x == '='))
	{
		return 1;
	}
	return 0;
}
string get(int i, int &pos)
{
	int num = (pos ? 0 : 1);
	string ret;
	for(; pos < s[i].size(); pos++)
	{
		if(check(s[i][pos]))
		{
			ret.push_back(s[i][pos]);
		}
		else
		{
			if(++num == 2)
			{
				break;
			}
		}
	}
	return ret;
}
int work(int l, int r, int defined)
{
	int pos, shown = 0xffffffff;
	string newword;
	for(int idx = l; idx <= r; idx++)
	{
		pos = 0;
		newword = get(idx, pos);
		if(newword == "PARAM")
		{
			for(; pos < s[idx].size(); )
			{
				newword = get(idx, pos);
				if(newword.size() == 1 && newword[0] >= 'A' && newword[0] <= 'Z')
				{
					defined |= (1 << (newword[0] - 'A'));
				}
            }
		}
		else if(newword == "IF")
		{
			int vis = 0;
			for(; pos < s[idx].size(); )
			{
				newword = get(idx, pos);
				if(newword.size() == 1 && newword[0] >= 'A' && newword[0] <= 'Z')
				{
					if(!(defined & (1 << (newword[0] - 'A'))) && !(vis & (1 << (newword[0] - 'A'))))
					{
						E[++cnt].id = newword[0];
						E[cnt].line = idx;
						E[cnt].opt = 2;
						vis |= (1 << (newword[0] - 'A'));
					}
				}
			}
			int i, wz, flag = 0;
			string nw;
			stack<int> st;
			st.push(idx);
			for(i = idx + 1; i <= r && !st.empty(); i++)
			{
				wz = 0;
				nw = get(i, wz);
				if(nw == "IF")
				{
					st.push(i);
				}
				else if(nw == "ELSE" && st.size() == 1)
				{
					flag = i;
					if(shown == 0xffffffff)
					{
						shown = work(st.top() + 1, i - 1, defined);
					}
					else
					{
						shown &= work(st.top() + 1, i - 1, defined);
					}
				}
				else if(nw == "END")
				{
					st.pop();
				}
			}
			if(flag)
			{
				shown &= work(flag + 1, i - 2, defined);
			}
			else
			{
				shown = 0xffffffff;
				work(idx + 1, i - 2, defined);
			}
			idx = i - 1;
			if((shown & (1 << 27)) && shown != 0xffffffff)
			{
				idx++;
				for(; idx <= r; idx++)
				{
					wz = 0;
					nw = get(idx, wz);
					if(nw != "ELSE" && nw != "END")
					{
						E[++cnt].line = idx;
						E[cnt].opt = 1;
					}
				}
				shown = 0x7fffffff;
			}
		}
		else if(newword.size() == 1 && newword[0] >= 'A' && newword[0] <= 'Z')
		{
			int vis = 0;
			char mem = newword[0];
			for(; pos < s[idx].size(); )
			{
				newword = get(idx, pos);
				if(newword.size() == 1 && newword[0] >= 'A' && newword[0] <= 'Z')
				{
					if(!(defined & (1 << (newword[0] - 'A'))) && !(vis & (1 << (newword[0] - 'A'))))
					{
						E[++cnt].id = newword[0];
						E[cnt].line = idx;
						E[cnt].opt = 2;
						vis |= (1 << (newword[0] - 'A'));
					}
				}
			}
			defined |= (1 << (mem - 'A'));
		}
		else if(newword == "RETURN")
		{
			int vis = 0;
			for(; pos < s[idx].size(); )
			{
				newword = get(idx, pos);
				if(newword.size() == 1 && newword[0] >= 'A' && newword[0] <= 'Z')
				{
					if(!(defined & (1 << (newword[0] - 'A'))) && !(vis & (1 << (newword[0] - 'A'))))
					{
						E[++cnt].id = newword[0];
						E[cnt].line = idx;
						E[cnt].opt = 2;
						vis |= (1 << (newword[0] - 'A'));
					}
				}
			}
			int wz;
			string nw;
			idx++;
			for(; idx <= r; idx++)
			{
				wz = 0;
				nw = get(idx, wz);
				if(nw != "ELSE" && nw != "END")
				{
					E[++cnt].line = idx;
					E[cnt].opt = 1;
				}
			}
			shown = 0x7fffffff;
		}
		if(shown != 0xffffffff)
		{
			defined |= shown;
		}
		//printf("!!%d %d %d %d!!\n", l, r, shown, defined);
	}
	return defined;
}
signed main()
{
	while(getline(cin, s[++tot]));
	work(1, tot - 1, 0);
	sort(E + 1, E + cnt + 1, cmp);
	for(int i = 1; i <= cnt; i++)
	{
		if(E[i].opt == 1)
		{
			printf("Line %d: unreachable code\n", E[i].line);
		}
		else if(E[i].opt == 2)
		{
			printf("Line %d: variable %c might not have been initialized\n", E[i].line, E[i].id);
		}
	}
	return 0;
}
```

# 彩蛋

在校内 OJ 上 A 了这道题后，我终于可以看见我老师的神仙代码了，我写 4.21k 他写 1.87k

% 就完了。

```cpp
#include <algorithm>
#include <cstdio>
#include <sstream>
#include <string>
#include <vector>
using namespace std;
 
int n, poz;
vector<string> code;
 
void output(int s, int v) {
  if(s & (1 << 26)) return;
  for(int i = 0; i < 26; i++) if(!(s & (1 << i)) && (v & (1 << i)))
    printf("Line %d: variable %c might not have been initialized\n",poz + 1,'A' + i);
}
 
int readValue(const string &s) {
  char c = s[0];
  if(isupper(c)) return 1 << (c - 'A');
  else return 1 << 27;
}
 
int parseArgs(const string &s) {
  istringstream is(s);
  string s2;
  is >> s2;
  int v = 0;
  for(;;) {
    is >> s2;
    if(!is) break;
    v |= 1 << (s2[0] - 'A');
  }
  return v;
}
 
int go(int s) {
  for(;;) {
    if(poz >= n) return s;
    istringstream is(code[poz]);
    string com; is >> com;
    if(com == "END" || com == "ELSE") return s;
    if(s & (1 << 26))
      printf("Line %d: unreachable code\n", poz + 1);
    if(com == "RETURN") {
      string s2; is >> s2;
      int v = readValue(s2);
      output(s,v);
      s |= (1 << 30) - 1;
      ++poz;
    }
    else if(com == "IF") {
      string s2; is >> s2;
      int v = readValue(s2);
      is >> s2; is >> s2;
      v |= readValue(s2);
      output(s,v);
      ++poz;
      int then1 = go(s);
      int else1 = 0;
      istringstream is2(code[poz]);
      is2 >> s2; ++poz;
      if(s2=="ELSE") {
        else1 = go(s);
        ++poz;
      }
      s |= then1 & else1;
    }
    else { // assigment
      int left = readValue(com);
      string s2; is >> s2;
      is >> s2;
      int v = readValue(s2);
      is >> s2;
      if(is){
        is >> s2;
        v |= readValue(s2);
      }
      output(s, v);
      s |= left;
      ++poz;
    }
  }
  return -1;
}
 
int main() {
	char line[100];
	while(fgets(line, 100, stdin) != NULL)
		code.push_back(line);
    n = code.size();
    int v = parseArgs(code[0]);
    poz = 1;
    go(v | (1<<27));
	return 0;
}
```

---

## 作者：HSC307 (赞：4)

我是一个脚本语言，现在我不知为何被强塞了一段代码，还被我的创造主要求指出其中的失误之处。

尽管如此，作为一个脚本语言，我仍不得不履行我的职责，还好我可以通过修改自己的 cpp 源代码来使我更方便地解决这个问题。

万幸的是，我只需要给出以下两种警告信息，我就可以被创造主赦免而去躺在文件夹里吃灰：

> 1. **「无法到达的代码行」**，即程序*一定* 永远无法达到执行这行代码的真实（我在下文中会将其称为 **WARNING1**）
>
> 2. **「未进行定义的变量」**，即在执行这行代码前，这行代码内用到的的变量*不一定* 被定义过（我在下文中会将其称为 **WARNING2**）

与此同时，我还得到了**输出**它们的格式：

> - 如果一行中出现了 **WARNING1**，那么我只要发送一次消息就能直接去处理下一行了
>
> - 如果一行中出现了多个 **WARNING2**，那么我需要按字典序排序后才能依次输出它们

然而在仔细研究过规则后，我有了一些新奇的想法。

按这么繁琐的规则在处理代码的时候一条条输出信息，这岂不是太愚蠢了？一点也没有体现出我怠惰的本质。

因此，我选择在处理时将所有的 **WARNING1** 存在一个 `bitset<55>` 里（懒惰的创造主似乎每次最多只会写 50 行代码），将**同一行内**所有的 **WARNING2** 存在一个 `bitset<26>` 里。这样只要处理完源代码，我就可以直接遍历它们来输出警告信息了。

因此，我飞快的改好了我的**输出模块**：

```cpp
bitset<55> WARNING1;
bitset<26> WARNING2[55];

inline void warning(){
    for(int LINE=1;LINE<=N;++LINE){
        if(WARNING1[LINE]){
            cout<<"Line "<<LINE<<": unreachable code\n";
            continue;
        }
        for(int i=0;i<26;++i)
            if(WARNING2[LINE][i])
                cout<<"Line "<<LINE<<": variable "<<(char)(i+'A')<<" might not have been initialized\n";
    }
}
```

在人类之间，*OI* 似乎是极其热门（并不？）的一个词汇，大概是 *Output Input* 的缩写罢！

所以我开始着手完成我的**输入模块**。

还记得我在某座山上做过汇编语言的兼职，因此这是非常容易的一步。我先**整行读入**了这些代码，并顺手以 ` `（这是一个**空格**，ASCII 码为 32）将它们分割成多个 *token*，最终存在一个 `vector<string>` 中。

```cpp
int N;
vector<string> codes[55];  

inline void input(){
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    string in;
    while(getline(cin,in))
        codes[++N] = split(in);
    //聪明的你一定拥有着写出split()程度的能力，我在这里就不班门弄斧了
}
```

然而这么做之后我却 ***Runtime Error*** 了，各种越界的通知一路炸到了雾之湖边的红色洋馆。

这是我才发现竟是那粗心大意的创造主忘记了去除**存在于每行行末的 `\r`**，在修改了 `split` 的部分内容后立刻就没事了。

改完了输入模块和输出模块，是时候该认真处理这段代码了。因此，我先再次查看了我的 *[BNF](https://baike.baidu.com/item/%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F/1849549)* 来进一步了解我需要做的事：

```plain
<line> :: <head> | <assignment> | <if> | ELSE | END IF | <return>
<head> :: PARAM <paramlist> | PARAM
<assignment> :: <variable> = <rvalue>
<if> :: IF <variable> <relation> <value> THEN
<return> :: RETURN <value>
<paramlist> :: <variable> | <variable> <paramlist>
<rvalue> :: <value> | <value> <operator> <value>
<value> :: <variable> | <integer>
<operator> :: + | - | * | /
<relation> :: < | = | >
<variable> :: A | B | ... | Z
<integer> :: 不含前导 0 的 32 位带符号整数
```

从中可以发现，我需要处理的代码中只会含有一下几种语句和形式：

```cpp
PARAM [一堆变量]          //于开头定义变量
IF [判断条件] THEN        //判断条件里含有0-2个变量
ELSE                      //和IF一一对应，可能不存在，所在行不会被警告
END IF                    //和IF一一对应，必定存在，所在行不会被警告
RETURN [返回值]           //返回值里含有0-1个变量
[变量] = [一些奇怪的东西] //"="后面可能存在变量
```

另外，除代表变量的 **26 个大写字母**外只会出现，**整数**，**+**、**-**、**\***、**/** 这四种运算符号以及 **>**、**=**、**<** 这三种比较符号。

不过，我认为除了 **26 个大写字母**外的这些东西似乎都是无用的，只是变量的附着物罢了，毫无价值，对于它们像无视路边的*小石头*一样直接无视掉就好了。

而这对于 **26 个字母**，我发现直接用一个 **32 位整数**即可存储它们的状态。其中如果它的二进制形式第 $i$ 位上的数为 $1$，即说明 ASCII 码为 $65+i$ 的变量已经被定义了。

简而言之，如果我用整数 $vari$ 来表示变量们的状态，那么大概就是以下几种操作了：

```cpp
int vari = 0;                    //在一开始所有变量都未被定义

inline void define(char newV){   //newV为需要定义的变量
    vari |= (1<<(newV-'A'))      //修改vari的对应位，因为用的是按位或所以不用担心重复定义导致冲突
}

inline bool check(char V){       //V为需要查询是否被定义的变量
    return (vari>>(V-'A'))&1     //你可能觉得这里部分括号有点多余，但我是一个脚本语言，我无法做到上网查询运算级顺序来去除无用的括号，所以请多多包涵
}

```

同时存在着一个神奇的性质：$vari \land -1 = vari$。在接下来的操作中似乎确凿会用到它。

接下来，是时候更新我的**代码处理模块**了呢。

首先是 **PARAM**。它似乎只会在代码的开头出现，并且将会像下载器下载各种奇怪的东西那样一次定义一大堆变量，因此我只要将第一行所有单独存在的**大写字母**对应的变量的状态记录成已定义就好了，大概就是这样：

```cpp
int gVari = 0;//全局变量
inline void param(vector<string> &code){
    for(auto V:code)
        if(!startWith(V,"PARAM"))
            gVari |= (1<<(V[0]-'A'));
}
```

真是十分甚至九分的简单呢。

俗话说得好，万事开头难。所以在完成最简单的 **PARAM** 后，我选择直接挑战最烦人的 **IF**。

自从发现了 **IF** 的嵌套，我就意识到我可以先将每个 **IF** 与 **END IF** 配对，然后直接用递归处理每个 **IF** 中的内容。

正当一筹莫展之时，我扫了眼上面的存储变量状态部分的代码，惊奇地发现原来我可以**直接遍历一遍整个程序**，用**括号匹配**的思想来完成这项工作：

```cpp
unordered_map<int,int> ENDIF;
int stacIF[495],top=-1;
inline void preIF(){
    for(int LINE=1;LINE<=N;LINE++){
        if(startWith(codes[LINE][0],"IF"))
            stacIF[++top]=LINE;
        if(startWith(codes[LINE][0],"END"))
            if(top>-1)
                ENDIF[stacIF[top--]]=LINE;
    }
    //startWith是什么呢？小编也不知道呢，想必不是字面意思吧（bushi
}
```

这样只要遇到 **IF** 就直接进行递归，然后将**行数**修改为对应的 **END IF** 所在位置即可。

可仔细一想，**IF** 中的操作有些许复杂。为了照顾我的脚本语言后辈们，我将我的计算成果列举在这里：

1. 对开头的 **IF** 进行处理，如上文所说，除了开头的 **IF** 和结尾的 **THEN** 外，其他东西**只要是变量就定义，只要不是变量就无视**。
2. 遍历 **IF** 内的代码，其中内容与主程序大致相同，**可以在写完主程序后直接 copy 过来**。
3. 考虑 **ELSE**：
   - 如果 **IF** 里没有配套的 **ELSE**，在 **IF** 内的*局部变量定义状态* 就用一个新的变量来存储，碰到 **RETURN** 就直接 **WARNING1** 到 **END IF**，最后什么操作也不需要直接返回上一层
   - 如果 **IF** 里有配套的 **ELSE**，那么就需要用两个变量分别存储在 **IF** 内和在 **ELSE** 内的*局部变量定义状态*，遇到 **RETURN** 或其他等价代码就 **WARNING2** 直到 **ELSE** 或 **END IF**，最后需要视情况修改上一层的变量定义情况
   - 在上面的第二种情况中，如果一个变量在 **IF** 与 **ELSE** 内均有定义，或者在其中之一有定义且另一处存在 **RETURN** 或其他等价代码，那么就视为**其在上一层也被定义**。
   - 特别地，如果在一个 **IF** 内，**IF** 部分与 **ELSE** 部分均存在 **RETURN** 或其他等价代码，那么就认为**这段 IF 代码等价于 RETURN**。

在这里，之前那个奇妙性质就派上用场了。如果 **IF** 的一个分支中存在 **RETURN** 或其他等价代码，我们可以直接将它的*局部变量定义状态* 直接修改为 $-1$，这样到时候直接返回 **两处变量定义状态的按位与结果**即可。

所以，当执行到某行时变量的定义状态为 $-1$，就说明**此行是无法到达的**，应加入 **WARNING1**。

似乎内存又有些乱了，还是翻翻源代码吧。

```cpp
inline void runIF(const int &IF,const int &END,int *fVari){
    //fVari传入上一层内的变量定义状态
    int ifVari = *fVari;        //存储if内的变量定义状态
    int elseVari = *fVari;      //存储else内的变量定义状态
    int *localVari = &ifVari;   //指针，指向当前所处位置对应的变量定义状态
    /*
    在if内 *localVari 直接指向 ifVari
    在else内 *localVari 直接指向 elseVari
    也就是说遇到else修改一下 *localVari 就行了，十分滴方便
    */
    for(int i=0;i<codes[IF].size()-1;i++){
        //处理开头的IF
        if(!isVari(codes[IF][i]))continue;
        int V = codes[IF][i][0]-'A';
        if(!((*fVari>>V)&1))
            WARNING2[IF].set(V);
    }
    for(int LINE=IF;LINE<=END;LINE++){
        //注意这里的范围是[IF,END]，因为if都是递归处理的，所以如果第IF行是无法到达的，那么只能在这里加入WARNING1
        if(startWith(codes[LINE][0],"END"))
            continue;
        if(startWith(codes[LINE][0],"ELSE")){
            localVari = &elseVari;
            continue;
        }
        
        //递归处理if，
        if(startWith(codes[LINE][0],"IF") && LINE!=IF){
            runIF(LINE,ENDIF[LINE],localVari);
            LINE = ENDIF[LINE];
            continue;
        }

        //我们认为[该行变量定义状态为-1]是该行代码无法到达的唯一标准
        if((*localVari)==-1){
            WARNING1.set(LINE);
            continue;
        }

        if(startWith(codes[LINE][0],"RETURN"))//这里是return，还没有讲到

        initVari(localVari,LINE);//这里是定义变量，也还没有讲到
    }
    *fVari |= (ifVari & elseVari);
    //往上一层传回变量定义状态，可以证明在无ELSE的情况下这一行为是无害的
}
```

这样，我们就一次干掉了 **IF** 和 **ELSE**。

连一刻也来不及为此感到喜悦，下一个需要解决的是 **RETURN**。

之前说过，可以认为**该行变量定义状态为 $-1$** 是该行代码无法到达的~~唯一~~标准，所以在遇到 **RETURN** 时，我在**处理 RETURN 后面的东西**之后将直接**把此时的变量定义状态设置为 $-1$**。

综上所述：

```cpp
//这个是放在if内的return处理部分
if(startWith(codes[LINE][0],"RETURN")){
    for(auto V:codes[LINE]){
        if(!isVari(V))continue;
        if(!(((*localVari)>>(V[0]-'A'))&1))
            WARNING1[LINE].set(V[0]-'A');
    }
    *localVari = -1;
    continue;
}
```

未被完成的部分已经只剩下**定义变量**了。

对于定义变量，它的**等号右边**常常出现 **WARNING2** 的情况，但身为语言，我被设置为无条件相信用户，在给出警告的同时仍然会忠实地认为**等号左边**的变量已经定义。

然而有时会出现形如 `V = V + 1` 的情况，面对这种 *UB* 行为，我不得不同样进行 **WARNING2**。

所以为了更方便的处理，我选择**先看等号右边的内容，再定义等号左边的变量**。

大概就是这个样子呢：

```cpp
inline void initVari(int *varis,const int &line){
    //等号右边
    for(int i=1;i<codes[line].size();++i){
        if(!isVari(codes[line][i]))continue;
        int V = codes[line][i][0]-'A';
        if(!(((*varis)>>V)&1))
            WARNING2[line].set(V);
    }

    //等号左边
    int V = codes[line][0][0]-'A';
    *varis |= (1<<V);
}
```

最终的最终，只剩下了**主程序**了。

然而事实上它和处理 **IF** 的方法几乎一致：

（我使用 $gVari$ 来存储*全局变量定义情况*。）

```cpp
param(codes[1]);
for(int LINE=2;LINE<=N;LINE++){
    if(startWith(codes[LINE][0],"END"))
        continue;
    if(startWith(codes[LINE][0],"ELSE"))
        continue;
    if(gVari == -1){
        WARNING1.set(LINE);
        continue;
    }
    if(startWith(codes[LINE][0],"IF")){
        runIF(LINE,ENDIF[LINE],&gVari);
        LINE = ENDIF[LINE];
        continue;
    }
    if(startWith(codes[LINE][0],"RETURN")){
        for(int j=1;j<codes[LINE].size();j++){
            if(!isVari(codes[LINE][j]))continue;
            int V = codes[LINE][j][0]-'A';
            if(!((gVari>>V)&1))
                WARNING2[LINE].set(codes[LINE][j][0]-'A');
        }
        gVari = -1;
        continue;
    }
    initVari(&gVari,LINE);
}
```

有的脚本语言看到这里可能会有些许疑惑：

- 为何在这里一旦 $gVari$ 的值为 $-1$，剩下的内容就 **WARNING1** 到底了，而处理 **IF** 时就要进入递归？

这是因为如果 **IF** 里也这么做的话就会导致 **ELSE** 与 **IF** 的对应关系混乱，最终引发致命的错误。而**主程序**中就不用考虑这点。

现在，我可算是完成了我的**代码处理模块**。

于是，在将它们以神奇的方式拼装在一起后，我成功完成了创造主的任务，躺到文件夹中吃起了灰。

因为我是开源的，所以我把我的 cpp 源代码放在这里：

```cpp
#include<bits/stdc++.h>
#define Flandre std
using namespace Flandre;
bitset<26> WARNING1[55];
bitset<55> WARNING2;

inline vector<string> split(const string &org){
    vector<string> res;
    string tmp = "";
    for(int i=0;i<org.length();++i){
        if(org[i]==' '||org[i]=='\r'){
            if(!tmp.empty())res.push_back(tmp);
            tmp = "";
        }else tmp+=org[i];
    }if(!tmp.empty())res.push_back(tmp);
    return res;
}

inline bool startWith(const string &org,const string &pre){
    if(org.length()<pre.length())
        return 0;
    for(int i=0;i<pre.length();++i){
        if(pre[i]==org[i])continue;
        if(pre[i]==org[i]-'a'+'A')continue;
        if(pre[i]==org[i]-'A'+'a')continue;
        return 0;
    }return 1;
}

inline bool isVari(const string &org){
    if(org.length()!=1)return 0;
    if(org[0]<'A'||org[0]>'Z')return 0;
    return 1;
}

int N;
vector<string> codes[55];
inline void initVari(int *varis,const int &line){
    for(int i=1;i<codes[line].size();i++){
        if(!isVari(codes[line][i]))continue;
        int V = codes[line][i][0]-'A';
        if(!(((*varis)>>V)&1))
            WARNING1[line].set(V);
    }
    if(!isVari(codes[line][0]))return;
    int V = codes[line][0][0]-'A';
    *varis |= (1<<V);
}

unordered_map<int,int> ENDIF;
int stacIF[495],top=-1;
inline void preIF(){
    for(int LINE=1;LINE<=N;LINE++){
        if(startWith(codes[LINE][0],"IF"))
            stacIF[++top]=LINE;
        if(startWith(codes[LINE][0],"END"))
            if(top>-1)
                ENDIF[stacIF[top]]=LINE,top--;
    }
}

inline void runIF(const int &IF,const int &END,int *fVari){
    int ifVari = *fVari;
    int elseVari = *fVari;
    int *localVari = &ifVari;
    for(int i=0;i<codes[IF].size()-1;i++){
        if(!isVari(codes[IF][i]))continue;
        int V = codes[IF][i][0]-'A';
        if(!((*fVari>>V)&1))
            WARNING1[IF].set(V);
    }
    for(int LINE=IF;LINE<=END;LINE++){
        // cout<<LINE<<" "<<ifVari<<" "<<elseVari<<"\n";
        if(startWith(codes[LINE][0],"END"))
            continue;
        if(startWith(codes[LINE][0],"ELSE")){
            localVari = &elseVari;
            continue;
        }
        if(startWith(codes[LINE][0],"IF") && LINE!=IF){
            runIF(LINE,ENDIF[LINE],localVari);
            LINE = ENDIF[LINE];
            continue;
        }
        if((*localVari)==-1){
            WARNING2.set(LINE);
            continue;
        }
        if(startWith(codes[LINE][0],"RETURN")){
            for(auto V:codes[LINE]){
                if(!isVari(V))continue;
                if(!(((*localVari)>>(V[0]-'A'))&1))
                    WARNING1[LINE].set(V[0]-'A');
            }
            *localVari = -1;
            continue;
        }
        initVari(localVari,LINE);
    }
    *fVari |= (ifVari & elseVari);
}


int gVari = 0;
inline void param(vector<string> &code){
    for(auto V:code)
        if(!startWith(V,"PARAM"))
            gVari |= (1<<(V[0]-'A'));
}

inline void compile(){
    preIF();
    for(int LINE=1;LINE<=N;LINE++){
        if(startWith(codes[LINE][0],"PARAM")){
            param(codes[LINE]);
            continue;
        }
        if(startWith(codes[LINE][0],"END"))
            continue;
        if(startWith(codes[LINE][0],"ELSE"))
            continue;
        if(gVari == -1){
            WARNING2.set(LINE);
            continue;
        }
        if(startWith(codes[LINE][0],"IF")){
            runIF(LINE,ENDIF[LINE],&gVari);
            LINE = ENDIF[LINE];
            continue;
        }
        if(startWith(codes[LINE][0],"RETURN")){
            for(int j=1;j<codes[LINE].size();j++){
                if(!isVari(codes[LINE][j]))continue;
                int V = codes[LINE][j][0]-'A';
                if(!((gVari>>V)&1))
                    WARNING1[LINE].set(codes[LINE][j][0]-'A');
            }
            gVari = -1;
            continue;
        }
        initVari(&gVari,LINE);
    }
}
inline void warning(){
    for(int LINE=1;LINE<=N;LINE++){
        if(startWith(codes[LINE][0],"END"))
            continue;
        if(startWith(codes[LINE][0],"ELSE"))
            continue;
        if(WARNING2[LINE]){
            cout<<"Line "<<LINE<<": unreachable code\n";
            continue;
        }
        for(int i=0;i<26;i++)
            if(WARNING1[LINE][i])
                cout<<"Line "<<LINE<<": variable "<<(char)(i+'A')<<" might not have been initialized\n";
    }
}

string input;
int main(){
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    while(getline(cin,input))
        codes[++N] = split(input);
    compile();
    warning();
    return 0;
}
```

此外，我将创造主塞给我的 11 份代码中的第 5 份放在了[这里](https://www.luogu.com.cn/paste/itoltc8n)，欢迎使用。

顺便推荐一下[我以前作为汇编语言打工的地方](https://www.luogu.com.cn/problem/P4911)。

有缘再会吧～

---

## 作者：xh2010 (赞：3)

这道题可真是烦人，编完程序调了一个多小时才调出来。

首先，这是一道极其麻烦的模拟题。

第二，我们先分析一下题目，发现总共只有六种语句，分别为：param语句，赋值语句，return语句，if语句，else语句和end if语句。我们对每一条语句进行遍历。

param语句：在输入开头，只需要用个数组记录已经定义的变量。

赋值语句：记录等号左边的变量，并判断等号右边的变量是否出现。

return语句：先判断return后的变量是否出现，再将后面的语句输出警告。

if语句：进行递归，将if嵌套的内容当作一个小程序，进行如上操作。

else和end if语句：跳出递归。

最后，这题有几个比较坑的地方：

1、会出现A=A+1的情况，我们先判断等式右边，再判断等式左边；

2、end if和else不能警告；

3、有时候程序做到一半就return了，而且是在if中return，如下例子：

IF A=1 THEN

RETURN A

ELSE
RETURN A

END IF
对于这种情形，需要用一个变量记录if和else中return的情况；

4、有的变量在if和else都出现，这种情况下，这个变量已经被记录，下次出现不能警告，如下例子：

```cpp
IF A=1 THEN
Q=1
ELSE
Q=2
END IF
```
这种情况下，Q已经被定义；
5、if或else内部定义的变量在外部可能被警告；

下面献上丑陋的代码：




















```cpp
program p2509;
type arr=array[1..26] of boolean;
var tot:longint;
    s:array[1..100] of ansistring;
    b:arr;
procedure init;
begin
  tot:=0;
  while not eof do
  begin
    inc(tot);
    readln(s[tot]);
  end;
end;
procedure warn1(n:longint;c:char);
begin
  writeln('Line ',n,': variable ',c,' might not have been initialized');
end;
procedure warn2(n:longint);
begin
  writeln('Line ',n,': unreachable code');
end;
function judge(str:ansistring):longint;
begin
  if str[2]='F' then
    exit(3)
  else if str[2]='E' then
    exit(2)
  else if str[2]='L' then
    exit(4)
  else if str[2]='N' then
    exit(5)
  else
    exit(1);
end;
function dfs(var k:longint;var c:arr):boolean;
var d,e,c1,c2:arr;
    str:ansistring;
    i,j,sum:longint;
    a:array[1..26] of longint;
    b1,b2:boolean;
begin
  d:=c;
  while k<=tot do
  begin
    str:=s[k];
    if judge(str)=1 then                                                                                                 //赋值语句
    begin
      fillchar(a,sizeof(a),0);
      for i:=5 to length(str) do
        if (str[i]>='A') and (str[i]<='Z') and not c[ord(str[i])-64] then
          inc(a[ord(str[i])-64]);
      for i:=1 to 26 do
        if a[i]>0 then
          warn1(k,chr(i+64));
      c[ord(str[1])-64]:=true;
    end
    else if judge(str)=2 then                                                                                        //return语句
    begin
      fillchar(a,sizeof(a),0);
      for i:=8 to length(str) do
        if (str[i]>='A') and (str[i]<='Z') and not c[ord(str[i])-64] then
          inc(a[ord(str[i])-64]);
      for i:=1 to 26 do
        if a[i]>0 then
          warn1(k,chr(i+64));
      sum:=0;
      j:=k;
      inc(k);
      while k<=tot do
      begin
        str:=s[k];
        if judge(str)=3 then inc(sum);
        if sum=0 then
        if (str[2]='L') or (str[2]='N') then
        begin
          for i:=j+1 to k-1 do
            if judge(s[i])<=3 then warn2(i);
          c:=d;
          exit(true);
        end;
      if str[2]='N' then dec(sum);
      inc(k);
    end;
    if k>tot then
      for i:=j+1 to tot do
        if judge(s[i])<=3 then warn2(i);
    end
    else if judge(str)=3 then                                                                                      //if语句
    begin
      j:=3;
      while copy(str,j,4)<>'THEN' do
        inc(j);
      fillchar(a,sizeof(a),0);
      for i:=3 to j-1 do
        if (str[i]>='A') and (str[i]<='Z') and not c[ord(str[i])-64] then
          inc(a[ord(str[i])-64]);
      for i:=1 to 26 do
        if a[i]>0 then
          warn1(k,chr(i+64));
      e:=c;
      inc(k);
      b1:=dfs(k,c);
      c1:=c;
      c:=e;
      if judge(s[k])=4 then
      begin
        inc(k);
        b2:=dfs(k,c);
        c2:=c;
        c:=e;
        if b1 and not b2 then
          c:=c2
        else if not b1 and b2 then
          c:=c1
        else if not b1 and not b2 then
        begin
          for i:=1 to 26 do
            if c1[i] and c2[i] then c[i]:=true;
        end;
        b1:=b1 and b2;
      end
      else
        b1:=false;
      if b1 then
      begin
        sum:=0;
        j:=k;
        inc(k);
        while k<=tot do
        begin
          str:=s[k];
          if judge(str)=3 then inc(sum);
          if sum=0 then
          if (str[2]='L') or (str[2]='N') then
          begin
            for i:=j+1 to k-1 do
              if judge(s[i])<=3 then warn2(i);
            c:=d;
            exit(true);
          end;
          if str[2]='N' then dec(sum);
          inc(k);
        end;
        if k>tot then
          for i:=j+1 to tot do
            if judge(s[i])<=3 then warn2(i);
      end;
    end
    else if judge(str)=4 then                                                                             //else语句
    begin
      exit(false);
    end
    else if judge(str)=5 then                                                                              //end if语句
    begin
      exit(false);
    end;
    inc(k);
  end;
end;
procedure main;
var i,l:longint;
    bool:boolean;
begin
  l:=length(s[1]);
  fillchar(b,sizeof(b),false);
  for i:=7 to l do
    if (s[1][i]>='A') and (s[1][i]<='Z') then
      b[ord(s[1][i])-64]:=true;
  i:=2;
  bool:=dfs(i,b);
end;
begin
  init;
  main;
end.
```

---

## 作者：BFSDFS123 (赞：0)

大模拟题。考虑到鸭棋已经降蓝，虽然这题细节较多，但是代码难度不大（大虚），也可以考虑降蓝。

大模拟题直接按照题面模拟即可。

注意以下细节：

- 若 IF 语句后与 ELSE 语句后同时对某变量进行了赋值，**且在 IF 与 ELSE 内均没有 RETURN**，则在这个 IF 与 ELSE 的 END IF 后，这个变量也是被视为赋值了的。

举例：

```
PARAM A
IF A = 3 THEN
B = 2
ELSE
B = 3
END IF
RETURN B
```

此时 ``RETURN B`` 视为合法。

- 若 IF 语句后与 ELSE 语句后同时执行了 RETURN，那么在 IF 与 ELSE 的 END IF 后的所有语句将不会被执行。

举例：
```
PARAM A
IF A = 3 THEN
RETURN 3
ELSE
RETURN 4
END IF
RETURN C
```
此时 ``RETURN C`` 不会被执行，应当输出 ``unreachable code``。

- 如果在 IF 与 ELSE 中，有一个 RETURN 而另一个没有 RETURN。则未 RETURN 的模块后的所有赋值会延续到 END IF 后。

举例：
```
PARAM A 
IF A = 3 THEN
RETURN 4
ELSE
C = 3
END IF
RETURN C
```

此时 ``RETURN C`` 视为合法。

- 一行内出现多个未赋值变量，只输出一个。
- ELSE 和 END IF 即使不能执行，也不能输出。

[代码](https://www.luogu.com.cn/paste/i6zaimrw)。

感觉不是很难调试？为了让调试更加方便，给出几组样例。

**Input #1**

```
PARAM A B C D
A = B + C
C = B + D
IF C = 3 THEN
D = 5
RETURN E
ELSE
E = D
END IF
RETURN E
```

**Output #1**

```
Line 6: variable E might not have been initialized
```

**Input #2**

```
PARAM A B C
A = B + D
A = D + D
IF C = 3 THEN
D = 4
E = D + 5
RETURN D
ELSE
K = 8
V = K + C
END IF
RETURN K
RETURN V
```

**Output #2**
```
Line 2: variable D might not have been initialized
Line 3: variable D might not have been initialized
Line 13: unreachable code
```

---


# [CQOI2012] 模拟工厂

## 题目描述

有一个称为“模拟工厂”的游戏是这样的：在时刻 $0$，工厂的生产力等于 $1$。在每个时刻，你可以提高生产力或者生产商品。如果选择提高生产力，在下一个时刻时工厂的生产力加 $1$；如果选择生产商品，则下一个时刻你所拥有的商品数量增加 $p$，其中 $p$ 是本时刻工厂的生产力。  

有 $n$ 个订单，可以选择接受或者不接受。第 $i$ 个订单 $(t_i, g_i, m_i)$ 要求在时刻 $t_i$ 给买家提供 $g_i$ 个商品，事成之后商品数量减少 $g_i$，而收入增加 $m_i$ 元。如果接受订单 $i$，则必须恰好在时刻 $t_i$ 交易，不能早也不能晚。同一时刻可以接受多个订单，但每个订单只能被接受一次。要求最后的总收入最大。  

例如，如果一共有两个订单 $(5,1,8)$ 和 $(7,15,3)$，用如下策略是最优的：时刻 $0$, $1$, $2$ 提高生产力（时刻 $3$ 的生产力为 $4$），然后在时刻 $3$，$4$ 生产商品，则在时刻 $5$ 时将拥有 $8$ 个商品。此时接受第 $1$ 个订单（还会剩下 $7$ 个商品），并且在时刻 $5$，$6$ 继续生产商品，则在时刻 $7$ 时拥有 $7+4+4=15$ 个商品，正好满足订单 $2$。

## 说明/提示

**【数据范围】**

| 编号 | $n \le$ | $t_i \le$ | $g_i \le$ | $m_i \le$ |
|:-:|:-:|:-:|:-:|:-:|
| $1 \sim 3$ | $5$ | $100$ | $10000$ | $10000$ |
| $4 \sim 6$ | $10$ | $100$ | $10000$ | $10000$ |
| $7 \sim 10$ | $15$ | $100000$ | $10^9$ | $10^9$ |

## 样例 #1

### 输入

```
2
5 1 8
7 15 3```

### 输出

```
11```

# 题解

## 作者：CYJian (赞：21)

震惊！一道爆搜题竟然被评成了黑题！！！

咳咳。。。

没错，这道题就是一道爆搜题。。。

n <= 15，这让我们习惯性的想到了状压。。。

然后仔细想想，如果我们已经选好了要接受哪些订单，可不可以直接判断呢？？

或者说更进一步，如果已经知道当前的生产力、剩了多少东西、接下来还有哪些订单，我们能不能求出在接下一个订单之前可以有多少时间提高生产力呢？？

（这么多废话终于说完了。。。）

说了这么多显然是可以的嘛。。。

我们设可以有x单位时间来提高生产力，那么如果当前离下一个订单的时间为T时，这个订单要P个产品，工厂拥有M的生产力时，显然有如下方程：

$$ (M + x) * (T - x) = P $$

整理后就可以得到：

$$ x^2 + (M - T) * x + P - M * T = 0 $$

利用根的判别式算一下有没有根，如果没有就说明无法接下这个订单，否则就可以拥有

$$ \biggl \lfloor \frac{T - M + \sqrt{(M + T)^2 - 4P}}{2} \biggr \rfloor $$

的时间来增加生产力。

然后就这样枚举下去，每次如果方案可行就用这些订单的收入来更新答案。

下面贴代码：
```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int N = 20;

struct P {
    int t; //订单的时间
    int c; //需要的产品数量
    int p; //得到的报酬

    friend bool operator< (P a, P b) { //按照时间排好序
        return a.t < b.t;
    }
}S[N], a[N];

int n;
int tot;
ll res;
// 设可以有x天提高生产力则可以列出方程: (Make + x) * (Time - x) = Need
// 整理得: x^2 + (Make - Time) * x + Need - Make * Time = 0
// 解方程即可
ll js(ll Make, ll Time, ll Need) { 
    ll a = 1;
    ll b = Make - Time;
    ll c = Need - Make * Time;
    ll derta = b * b - 4 * a * c;
    if(derta < 0) return -1;
    return floor((-b + sqrt(derta)) / 2 / a);
}
//检查当前枚举的方案可不可行，可行就更新答案
void solve(int Now) {
    tot = 0;
    ll num = 0;
    for(int i = 1; i <= n; i++)
        if(Now & (1 << i - 1))
            S[++tot] = a[i], num += a[i].p; //将当前状态的订单加入栈
    ll Make = 1; //生产力
    ll Have = 0; //剩余的产品数量
    for(int i = 1; i <= tot; i++) {
        ll t = S[i].t - S[i - 1].t; //在下一个订单前能够提高生产力的时间，最大就是这个
        ll sum = 0; //累加所需的产品
        for(int j = i; j <= tot; j++) {
            sum += S[j].c;
            if(sum > Have)
                t = min(t, js(Make, S[j].t - S[i - 1].t, sum - Have)); //用算出来的时间更新当前的时间
        }
        if(t < 0) return ; //说明不可行
        Make += t; //更新生产力
        Have += Make * (S[i].t - S[i - 1].t - t) - S[i].c; //更新库存
    }
    res = max(res, num);
}

int main() {
    scanf("%d", &n);
    for(int i = 1; i <= n; i++)
        scanf("%d%d%d", &a[i].t, &a[i].c, &a[i].p);
    sort(a + 1, a + 1 + n); //按照时间排好序
    for(int i = 0; i < (1 << n); i++)
        solve(i);
    printf("%lld\n", res);
    return 0;
}
```

---

## 作者：hegm (赞：13)

[题目输送门](https://www.luogu.com.cn/problem/P3161)。

update：修改了下细节内容

又是一道模拟题哪，顺着模拟 tag 找过来的，但是模拟的内容不多。

- 首先看到的 $n$ 个任务，第一时间想到的是背包，但是当看到 $n \leq 15$，的时候意识到可以暴力枚举每种情况。

- 对于每种情况进行求解，我们假定当前刚做完第 $i$ 个任务，向第 $\left(i+1\right)$ 个任务推进 :

我们记：

- $p$ 表示当前还有多少库存商品。

- $val$ 表示当前的生产力。

- $t$ 表示第 $i$ 个任务到第 $\left(i+1\right)$ 个任务之间有多长时间。

- $need$ 表示第 $\left(i+1\right)$ 个任务所需要的商品数。

我们先来一个显然的贪心，如果我们把时间的推进转化为两部分：**增加生产力**和**生产商品**。

那么显然，先**增加生产力**更优。

那么我们假设一个时间点 $x$ ，在 $x$ 之前我们增加生产力，在 $x$ 只后，我们生产商品。

如果这样的话，我们在 $t$ 时间内所产出的商品数量为：

$$tot=\left(val+x\right)\times \left(t-x\right)$$
 
显然, 如果 $tot_{\max}+p \geq need$ 我们就可以完成此次任务，那么 $tot_{\max}$ 怎么搞呢？
 
别急，我们先把  $tot=(val+x)×(t-x)$ 拆开：
 
$$tot=-x^2 + \left(t-val\right)x + t\times val$$
 
不难看出，这是一个二次函数，最大值可以通过公式求出：当 $x$ 为 $-\frac{b}{2a}$ 时， $tot$ 有最大值。
 
如图为 $(t=3,val=1)$ 的二次函数图像。
[![vXDWbd.png](https://s1.ax1x.com/2022/09/12/vXDWbd.png)](https://imgse.com/i/vXDWbd)

但是真的取 $tot_{\max}$ 就是正确答案了吗？

显然不是，也很好 hack，**因为你只保证了 $p$ 在操作后是最大值，但是并不能使 $val$ 尽量的大！** 导致 $\left(i+2\right)$ , $\left(i+3\right)$，等等来不及达到对应的要求。

但是如果我们保证了 $p_{\max}$ 就是正确答案了吗？

也是同样的，就算你 $val$ 够大，但是 $\left(i+2\right)$ 所要求的很近，你还没来得急生产出足够的商品，就导致任务失败，失败的原因是你的 $p$ 值不足，或许你可以在第 $\left(i+1\right)$ 个任务完成前不选择提升你的 $val$ 而选择提升你的 $p$ 值。

那么问题就变复杂了，如何让我们在完成当前所有任务的前提下，尽量的保证以后的任务能做完呢？

这时候，我们不妨想的简单点，对于所有的任务 $j$ （任务 $j$ 的时间在任务 $i$ 之后）进行计算，我们先处理 $i$ 和 $\left(i+1\right)$ 之间的关系 再处理 $i$ 和 $\left(i+2\right)$ 的关系，一直到 $i$ 和 $n$ 的关系，在所有的 $x$ 中，取 $\min$，如果这个 $x<0$ 那么就说明不可行的。

至于 $i$ 和 $\left(i+1\right)$ 之间关系，我们贪心的让我们的 $val$ 在能通过的前提下最大化，显然是最优的，因为我们后面的都能通过了，无需考虑 $p$ 的大小对我们的影响。

具体的，我们看下代码。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
struct node
{
	int t,g,m;
}k[20];
int val,p,n,t[20],tot,cnt,ans;
bool cmp(node a,node b)
{
	if(a.t!=b.t)return a.t<b.t;
	else return (a.m/a.g)>(b.m/b.g);
}
int fc(int val,int T,int p)//求解二次函数，使p最大。
{
	int b=val-T,c=p-val*T;
	int det=b*b-4*c;
	if(det<0)return -1;
	return floor((-b+sqrt(det))/2);
}
void solve(int ink)
{
	memset(t,0,sizeof(t));
	tot=0,cnt=0;bool c=0;
	for(int i=0,kill;i<n;i++)
	{
		kill=1<<i;
		c=ink&kill;
		if(c)t[++tot]=i+1,cnt+=k[i+1].m;//cnt为这次如果成功所能带来的收益，和当前答案取max
	}
	val=1,p=0;
	for(int i=1;i<=tot;i++)
	{
		int T=k[t[i]].t-k[t[i-1]].t,sum=0;
		for(int j=i;j<=tot;j++)
		{
			sum+=k[t[j]].g;//枚举之后的每个点，处理好关系
			if(sum>p)T=min(T,fc(val,k[t[j]].t-k[t[i-1]].t,sum-p));
		}
		if(T<0)return ; //不可行直接return
		val+=T;
		p+=(k[t[i]].t-k[t[i-1]].t-T)*val-k[t[i]].g;
	}
	ans=max(ans,cnt);
}
signed main()
{
	n=read();
	for(int i=1;i<=n;i++)
	{
		k[i].t=read();
		k[i].g=read();
		k[i].m=read();
	}
	sort(k+1,k+1+n,cmp);
	int ink=(1<<n);
	for(int i=0;i<ink;i++)solve(i);
	cout<<ans;
	return 0;
}
```

---

## 作者：Tarsal (赞：10)

本蒟蒻又双叒叕被爆踩辣！

[题目链接](https://www.luogu.org/problem/P3161)

Solution:

这题又是一道贪心。。

数据范围：

```
n<=15  ti<=100,000  gi<=10^9  mi<=10^9
```

这里就可以看到几个小细节，也可以想出一些思路。

#### 要开long long！

首先，n <= 15， 这个数据可以说是很小辣，它代表有n个任务，又因为

```
如果接受订单i，则必须恰好在时刻ti交易，不能早也不能晚。同一时刻可以接受多个订单，但每个订单只能被接受一次。
```

窝们本不知道选择哪些任务才会是利润最高，而且这很明显也无法通过一些规律来知道选择哪个会最优。

所以窝们应该怎么办？？？

### 枚举！！！

因为只有数据范围只有15，所以窝们可以枚举1到(1 << n) - 1用二进制表示当前这个任务选不选，那我们已经解决了这个任务辣！

接下来就是，然后处理每个任务方案。

窝们针对每个任务方案，依次判断它的可行性。

然后在可行的方案中找出利润最大的（就是保证任务完成的情况下，保证生产力更大。

假设窝们当前有那么对于订单i和j，我们都会得到方程：make为完成订单i时的生产力，time为距离j订单的时间，time_create为用来提升生产力的时间，need是订单j需求量

```
(make + time_create) × (time − time_create) = need
```


化简就是：

```
time_create * time_create + (make - time) * time_create + need - make * time = 0;
```


只要保证起“根的判别式” >= 0就行。

所以复杂度应该是O（2 的 n次方 * n 的平方）；

具体见代码，这里只有一些思路，个人介意对着代码读，更容易理解

Code:

```cpp
#include<bits/stdc++.h>

using namespace std;

#define maxn 25
#define maxm
#define ll long long//mi数据1e9，你不开longlong看看 
#define int long long
#define Rep(x, a, b) for(int x = a; x <= b; ++ x)
#define Dep(x, a, b) for(int x = a; x >= b; -- x)
#define Next(x, u) for(int i = head[u]; i ; i = e[i].nxt)

//int read(){窝不喜欢用快读，但缺省源里面放了，所以也没删 
//	int f = 1, x = 0;
//	char c = getchar();
//	while(c < '0' || c > '9'){
//		if(c == '-'){
//			f = -1;
//		}
//		c = getchar();
//	}
//	while(c >= '0' && c <= '9'){
//		x = (x << 1) + (x << 3) + (c ^ 48);
//		c = getchar();
//	}
//	return x * f;
//}

struct node{
	int t, g, m;//都如题，t是在什么时刻交易，g是需要多少货，m是可以得到的利润 
}e[maxn], s[maxn];

//e是记录所有的任务
//s是记录当前情况窝们已经选择的任务 
 
int n, ans;//不多说 

bool cmp(node x, node y){
	return x.t < y.t;
}//要先按照t排序，要不不好处理 

int discriminant(int b, int c){//这个单词是“判别式”，百度说的
	if(b * b - 4 * c < 0){//都知道二次函数根的判别式吧（b * b - 4 * a * c） 
		return -1;//返回-1，即根的判别式小于0 
	}
	return floor((-b + sqrt(b * b - 4 * c)) / 2);//否则就返回它的根:((-b + sqrt(b * b - 4 * a * c) / 2 / a) 
}

void dfs(int x){
	int now_have = 0, make_force = 1, ans_now = 0, tot = 0;
	//now_have是窝们当前拥有的货物
	//make_force是当前的生产力
	//ans_now是这种方案的利润 
	//tot是当前这种选择方案任务的个数 
	Rep(i, 1, n){//这里就是寻找当前方案的任务 
		if(x & (1 << i - 1)){//用二进制 
			s[++ tot] = e[i];//进入s 
			ans_now += e[i].m;//就是当前方案的总利润 
		}
	}
	Rep(i, 1, tot){
		int t = s[i].t - s[i - 1].t, sum = 0;//sum是所需要的货物 
		//t是时间，s[i].t - s[i- 1].t是它的最大值，因为当它前面的货物足够购买这两个货物时，它的t就是此值 
		Rep(j, i, tot){//算t的值 
			sum += s[j].g;//累加所需要的货物  
			if(now_have >= sum){//如果货物还够，那就下一层循环 
				continue;
			}//否则，就更新t，为t，和它的根的最小值 
			t = min(t, discriminant(make_force - s[j].t + s[i - 1].t, sum - now_have - make_force * (s[j].t - s[i - 1].t)));
		}
		if(t < 0){//如果无法完成次方案 
			return;//return 
		}
		make_force += t;//生产力就要加，（尽可能加就行 
		now_have += make_force * (s[i].t - s[i - 1].t - t) - s[i].g;//其余就现在有的产量 
	}
	ans = max(ans, ans_now);//更新值 
}

signed main(){
	scanf("%lld", &n);//输入 
	Rep(i, 1, n){//输入每个任务 
		scanf("%lld%lld%lld", &e[i].t, &e[i].g, &e[i].m);
	}
	sort(e + 1, e + n + 1, cmp);//按时刻排序 
	Rep(i, 0, (1 << n) - 1){
		dfs(i);//每种方案跑一遍 
	}
	printf("%lld", ans);//输出 
	return 0;
}
```

下面还给两组数据

```
Inout:
5
5 5 5
7 7 7
9 9 9
11 1 15
16 18 778

Output:
814

```
```
Input:
10
1 1 1
2 2 2
3 3 3
4 4 4
5 5 5
6 6 6
7 7 7
8 8 8
9 9 9
10 10 10

Output:
30
```
~~Ps:请看懂再抄~~

---

## 作者：Loser_Syx (赞：8)

upd：2024-2-17 更改了代码。

## 思路

这么一道爆搜能评紫也是真离谱。

首先我们对于范围 $n \leq 15$ 下手，再联想起每一个单子接还是不接的问题，可以想到，依次枚举每一个单子接还是不接，此处你可以是二进制枚举 $0 \sim 2^n - 1$，也可以直接 `dfs` 暴力，当然这对答案没有影响。

接下来是对于每一个种类选取的方式。

我们枚举了该种方式，那么我们就可以对于该种方式，计算得到的价值。

具体地，我们对于每两个订单，期间的间隙会有一些选择，那么这么多的时间可以选择，提升生产力一段时间，然后再生产一段时间，然后就是一个一元二次方程（此处设 $a$ 为原来的生产力，$b$ 为间隙时间，$c$ 为需要的量，$x$ 为提高生产力的时间）：

$$(a + x) \times (b - x) = c$$

可得：

$$x \times x + (a - b) \times x + c - a \times b = 0$$

然后算一下判别式是否 $\geq 0$，如果不是的话就说明这个方案是不合法的，是的话就可算出：

$$x = \lfloor \dfrac{b - a + \sqrt{(b+a)^2} - 4 \times c}{2} \rfloor$$

最后对于每种情况取 $\max$ 便可。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
int n;
struct node {
    int x, y, z;
} a[101001], choose[101001];
ll ans = 0;
ll find_(ll x, ll y, ll z) {
    ll a = 1;
    ll b = x - y;
    ll c = z - x * y;
    ll d = b * b - 4 * a * c;// 根
    if (d < 0) return -1;
    return floor((-b + sqrt(d)) / 2 / a);
}
void check(int len) {
    ll l_l = 0;
    for (int i = 1; i <= len; ++i) {
        l_l += choose[i].z;
    }
    if (l_l <= ans) return ;
    ll res = 1;
    ll b = 0;
    bool flag = 1;
    for (int i = 1; i <= len; i++) {
        ll t = choose[i].x - choose[i - 1].x;
        ll sum = 0;
        for (int j = i; j <= len; j++) {
            sum += choose[j].y;
            if (sum > b)
                t = min(t, find_(res, choose[j].x - choose[i - 1].x, sum - b));
        }
        if (t < 0) return ;
        res += t;
        b += res * (choose[i].x - choose[i - 1].x - t) - choose[i].y;
    }
    if (flag) ans = max(ans, l_l);
}
void dfs(int last, int len) {
    check(len);
    if (last == n + 1) return ;
    for (int i = last + 1; i <= n; ++i) {
        choose[len + 1] = a[i];
        dfs(i, len + 1);
        choose[len + 1] = {0, 0, 0};
    }
}
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) scanf("%d%d%d", &a[i].x, &a[i].y, &a[i].z);
    sort(a + 1, a + 1 + n, [&](node x, node y) {
        return x.x < y.x;
    });
//  for (int i = 0; i < (1 << n); ++i) {
//      int len = 0;
//      for (int j = 1; j <= n; ++j)
//          if (i & (1 << (j - 1))) choose[++len] = a[j];
//      check(len);
//  }
    dfs(0, 0);
    printf("%lld\n", ans);
    return 0;
}
```

---

## 作者：eternal风度 (赞：6)

# 搜索？+贪心

这个题练一练综合思想还是不错的。。。（~~然而蒟蒻不会啊~~）

哈哈还是安利一下自己的博客。。。[eteranl风度的博客](http://www.cnblogs.com/cjoierljl)

同步发表于：[eternal风度的[CQOI2012]模拟工厂 题解(搜索+贪心)](https://www.cnblogs.com/cjoierljl/p/9909018.html)

## 做法
肯定是在能完成某些订单的情况下使自己生产力越高越好是吧（一个大致的贪心方向）

但是我们不知道自己到底应该怎么去决定提高生产力的时间

那么换个角度，不从时间来看，从订单上来看

## 贪心
我们假设一定要完成订单$1$～$n$

那么应该如何贪心选时间提升生产力呢，当然是在能满足所有订单的基础上尽量多地提高生产力

那么对于要完成的订单$i$和$j$，我们都会得到方程：
(设$pdc(produce)$为完成订单$i$时的生产力，$T$为距离$j$订单的时间，$x$为用来提升生产力的时间，$gv(give)$是订单$j$需求量)
$$(pdc+x)×(T-x)=gv$$对所有我们一定要完成的订单一个一个完成，每次完成一个订单时对它之后的每一个订单我们都解这么一个方程，得到尽可能的休息时间，那么这样子一定是对的吧

## 然后可以想到
上面是$1$～$n$我们都想完成，现在不同了，我们可以放弃一些订单

再看数据范围：$n<=15$？，那不就暴力枚举状态选还是不选啊

然后对于上面那个方程，如果无解△$<0$肯定这种计划是不行的

然后直接用求根公式会得到：$$\frac{T-pdc+\sqrt{(pdc+T)^2-4×gv}}{2}$$算一下时间复杂度：$O(2^n×n^2)$很对呀，那就做完了

~~枚举状态虽可以直接枚举，但也可以搜是吧，那我们就叫他搜索了~~

## 给出代码
哼哼

压行是看代码人的噩梦，但写代码者那个舒畅啊（~~虽然笔者只稍稍压行了。。。~~）
```
#include<bits/stdc++.h>
#define il inline
#define rg register
#define ldb double
#define lst long long
#define rgt register int
#define N 20
#define M 100050
using namespace std;
const int Inf=1e9;
il lst MAX(rg lst x,rg lst y){return x>y?x:y;}
il lst MIN(rg lst x,rg lst y){return x<y?x:y;}
il int read()
{
    int s=0,m=0;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')m=1;ch=getchar();}
    while( isdigit(ch))s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
    return m?-s:s;
}

int n,UP;
lst Ans,Res;
int sgn[N],top;
struct DD{lst tt,gv,gt;}ljl[N];
bool cmp(const int&a,const int&b){return ljl[a].tt<ljl[b].tt;}

il void Solve(rgt Zt)
{
    top=Res=0;
    for(rgt i=1;i<=n;++i)
        if(Zt&(1<<(i-1)))sgn[++top]=i,Res+=ljl[i].gt;
    if(Res<Ans)return;
    sort(&sgn[1],&sgn[top+1],cmp);
    rg lst pdc=1,rest=0;
    rg bool flag=true;
    for(rgt i=0;i<top;++i)
    {
        rg lst nd=0,brk=Inf;
        for(rgt j=i+1;j<=top;++j)
        {
            nd+=ljl[sgn[j]].gv;
            rg lst tm=ljl[sgn[j]].tt-ljl[sgn[i]].tt;
            rg lst b=pdc-tm,c=nd-rest-pdc*tm;
            if(b*b-4*c<0){flag=false;break;}//delta
            rg lst x=(sqrt(b*b-4*c)-b)/2;
            brk=MIN(brk,x);
        }pdc+=brk;
        rest+=pdc*(ljl[sgn[i+1]].tt-ljl[sgn[i]].tt-brk)-ljl[sgn[i+1]].gv;
        if(!flag||brk<0||rest<0){flag=false;break;}
    }if(flag)Ans=MAX(Ans,Res);
}

int main()
{
    n=read(),UP=(1<<n);
    for(rgt i=1;i<=n;++i)
        ljl[i]=(DD){read(),read(),read()};
    for(rgt i=1;i<UP;++i)Solve(i);
    return printf("%lld\n",Ans),0;
}
```
# 如果对您有帮助，那将是我万分的荣幸

---

## 作者：Expert_Dream (赞：5)

P3161[CQOI2012]模拟工厂题解。[题目](https://www.luogu.com.cn/problem/P3161)

其实发现这是一道状压，发现这道题是一道数学题，其实就很简单了。对于每一次的订单我们可以设：
- $time$ 为距离下一个订单的时间。
- $num$ 为这个订单要生产的数量。
- $x$ 为生产能力。
- $y$ 的时间可以用来提高工厂的生产力。那我们就可以得出公式：$(x+y)\times (time-y) = num$

整理后：（~~一元二次方程应该都会对吧。~~）$y^2+(x-time)\times y-x\times time+num$

一个一元二次方程肯定要判根啊，如果有实数根那么就是有解。所以我们只需要对方程判根，有根那么这个订单就可以完成。

如果有实数根只需要解这个方程即可：$\dfrac{time - x + \sqrt{(x-time)^2 - 4\times x\times time-4\times num}}{2 }$

程序首先先枚举每一个状态：状压！毕竟 $n\le15$。然后就去计算每一个订单，进行计算，判断可行性，对可行的方案取 $\max$ 即可。AC code：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
struct node{
	ll t,g,m;
}a[25],st[25];
ll n;
bool cmp(node a,node b){
	return a.t < b.t;
}
ll jisuan(ll x,ll time,ll y){
	ll a = 1;
	ll b = x-time;
	ll c = y-x*time;
	ll delta = b*b-4*a*c;
	if(delta>=0)return (ll)((-b+sqrt(delta)) / 2 / a);
	return -1;
}
ll ans;
void run(ll zy){
	ll t = 0;
	ll sum =0;
	for(int i = 1;i <= n;i++){
		if(zy & (1<<(i-1))) {
			st[++t] = a[i];
			sum += a[i].m;
		}
	}
	
	ll m=1;
	ll sheng=0;
	
	for(ll i = 1;i <= t;i++){
		ll mt = st[i].t - st[i-1].t;
		//最多提高生产力的时间
		ll num=0;//所有产品累计
		for(ll j =i;j<=t;j++){
			num += st[j].g;
			if(num > sheng){
				mt = min(mt,jisuan(m,st[j].t-st[i-1].t,num-sheng));
			}
		}
		if(mt == -1) return ;
		m += mt;
		sheng += m * (st[i].t-st[i-1].t-mt) - st[i].g;
	}
	ans = max(ans,sum);
}	
int main(){
	cin >> n;
	for(ll i = 1;i <= n;i++){
		cin >> a[i].t >> a[i].g >> a[i].m;
	}
	sort(a+1,a+1+n,cmp);
	for(ll i = 0;i < (1<<n);i++){
		run(i);//状压，2^n枚举所有订单可能性
	}
	cout << ans;
	return 0;
}
```

~~给蒟蒻的第一篇题解点个赞呗~~
[广告](https://www.luogu.com.cn/blog/gsczl71/)

---

## 作者：Unnamed114514 (赞：3)

观察数据范围，可以发现本题用状压 $O(2^n)$ 枚举状态。

有一个很容易的贪心的思路，那就是把增加劳动力的操作放前面。

此时，我们设当前劳动力为 $A$，拥有的时间为 $B$，需要的货物量为 $C$，这个操作用 $t$ 次增加了劳动力。

那么我们可以得到一个一元二次方程

$(A+t)(B-t)\ge C$

所以 $-t^2+(B-A)t+(AB-C)\ge0$，

即 $t^2+(A-B)t+(C-AB)\le0$，

贪心地，加劳动力肯定最多，所以取较大的 $t_1$。

如果判别式为负，显然无解。

这样，对于每个选择，都考虑一下后面的选择是否可行，实现复杂度 $O(n^2)$。

总时间复杂度 $O(n^22^n)$。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read(){
	int res=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')
		ch=getchar();
	while(ch>='0'&&ch<='9'){
		res=(res<<1)+(res<<3)+(ch^'0');
		ch=getchar();
	}
	return res;
}
int n,ans,top;
struct node{
	int t,g,m;
	inline bool operator <(const node &o) const{
		return t<o.t;
	}
}a[20],s[20];
inline int Ask(int p,int q,int r){
	int a=1,b=p-q,c=r-p*q;
	int delta=b*b-4*a*c;
	if(delta<0)
		return -1;
	return (int)floor(-b+sqrt(delta))/(2*a);
}
inline bool check(){
	int k=1,p=0;
	for(int i=1;i<=top;++i){
		int sum=0,t=s[i].t-s[i-1].t;
		for(int j=i;j<=top;++j){
			sum+=s[j].g;
			if(sum>p)
				t=min(t,Ask(k,s[j].t-s[i-1].t,sum-p));
		}
		if(t<0)
			return 0;
		k+=t;
		p+=k*(s[i].t-s[i-1].t-t);
		p-=s[i].g;
	}
	return 1;
}
signed main(){
	n=read();
	for(int i=1;i<=n;++i)
		a[i]={read(),read(),read()};
	stable_sort(a+1,a+n+1);
	for(int i=1;i<(1<<n);++i){
		int sum=0;
		top=0;
		for(int j=1;j<=n;++j)
			if(i&(1<<j-1))
				s[++top]=a[j],sum+=a[j].m;
		if(check())
			ans=max(ans,sum);
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：xiwang (赞：3)

无敌大贪心....

N<=15，直接枚举接哪些订单，然后贪心，尽量多多提高生产力

每个时间点暴力遍历后面的订单，看至多能花多少时间提高生产力还不会玩脱

然后发现一段时间生产数量是个二次函数（关于生产力的）

然后瞎搞搞记得开long long 就好了

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=32;
typedef long long ll;
struct node{
	int t,g,m;
	void read(){
		scanf("%d%d%d",&t,&g,&m);
	}
};
bool operator <(node a,node b){
	return a.t<b.t;
}
node a[N],s[N];int top;
int n;ll ass;
int fuck(ll k,ll t,ll g){
	ll a=1,b=k-t,c=g-k*t;
	ll del=b*b-4*a*c;
	if(del<0)return -1;
	return (floor((-b+sqrt(del))/2/a)+1e-7);
}
bool chk(){
	ll pr=1,gr=0;
	for(int i=1;i<=top;i++){
		ll sm=0;
		int t=s[i].t-s[i-1].t;
		for(int j=i;j<=top;j++){
			sm+=s[j].g;
			if(sm>gr)t=min(t,fuck(pr,s[j].t-s[i-1].t,sm-gr));
		}
		if(t<0)return 0;
		pr+=t;
		gr+=pr*(s[i].t-s[i-1].t-t);
		gr-=s[i].g;
	}
	return 1;
}
int main(){
	scanf("%d",&n);for(int i=1;i<=n;i++)a[i].read();
	sort(a+1,a+1+n);
	for(int i=1;i<(1<<n);i++){
		ll re=0;
		top=0;
		for(int j=1;j<=n;j++)if(i&(1<<(j-1)))s[++top]=a[j],re+=a[j].m;
		if(chk())ass=max(ass,re);
	}
	printf("%lld",ass);
	return 0;
}
```

---

## 作者：block_in_mc (赞：2)

## 题意简述

有 $n$ 个订单，其中的第 $i$ 个 $(t_i,\ g_i,\ m_i)$ 代表在时刻 $t_i$ 要提供 $g_i$ 个商品并获得 $m_i$ 的报酬。你可以选择其中若干个完成。在时刻 $0$，你的生产力为 $1$。每一时刻，设生产力为 $p$，你可以进行以下两种操作之一：

* 生产 $p$ 个商品；
* 把自己的生产力设为 $p+1$。

求出你最多能获得多少报酬。
 
## 思路

这是一道简单紫题。

先看题面，感觉像背包，看到数据范围：$n\le15$，这不乱搞都能过？

考虑枚举每一个订单接受或者不接受，一共 $2^n\le32768$ 种情况，可以接受。然后对于每一种情况，如果所有订单都能被完成并且订单总价值大于当前答案，就把答案设为订单总价值。

现在看看怎么算出订单能否被完成。假设在 $t$ 的时间内，我们要制作 $c$ 件物品。我们肯定要优先加生产力，用剩下的时间生产商品。加生产力越多，对以后越有好处。设现在的生产力为 $p$，最多有 $x$ 的时间增加生产力，可以得到：

$$(p+x)(t-x)=c$$

化简得到：

$$x^2+(p-t)x-pt+c=0$$

于是有了求根公式：

$$x=\dfrac{(t-p)\pm\sqrt{(p-t)^2-4(c-pt)}}{2}$$

根越大越好，因此 $\pm$ 只需要取 $+$。

这个时候，$x$ 可能是一个小数，而我们处理的是整数时间，如果向上取整可能生产时间会不够，因此我们要向下取整。即：

$$x=\lfloor\dfrac{(t-p)+\sqrt{(p-t)^2-4(c-pt)}}{2}\rfloor$$

如果方程没有根或根小于 $0$，代表这种情况没法完成所有订单。代码如下：

```cpp
ll get_ans(ll cnt, ll power, ll time) {
    ll b = power - time, c = cnt - power * time;
    if (b * b - 4 * c < 0) return -1;
    return floor((-1 * b + sqrt(b * b - 4 * c)) / 2);
}
```

要注意的是，在计算第 $i-1$ 到第 $i$ 个订单所最多能增加多少生产力时，不能只计算第 $i$ 个订单，要枚举到 $n$ 并求最小值，否则可能满足了当前的订单，但以后的订单无法满足。

由于 $t_i\le10^5,\ g_i\le10^9$，在计算 $(p-t)^2$ 时可能会爆出 `int` 范围，需要开 `long long`。

还有要注意的是，订单不一定按时间顺序给出，因此在计算前需要先排序；为了订单生产的商品数量可能会超过目标，因此要开一个变量存储当前的商品数量。

时间复杂度 $O(2^n\times n^2)$。

## 代码

```cpp
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const ll N = 20;
struct plan { ll time, count, price; } ps[N];
ll n, ans, flag[N];
bool cmp(plan a, plan b) { return a.time < b.time; }
ll get_ans(ll cnt, ll power, ll time) {
    // 求解二元一次方程
    ll b = power - time, c = cnt - power * time;
    if (b * b - 4 * c < 0) return -1;
    return floor((-1 * b + sqrt(b * b - 4 * c)) / 2);
}
void check(vector<plan> plans) {
    // 对每一个情况进行处理
    ll cnt = 0, power = 1, res = 0; // 当前数量, 生产力, 处理完这种情况所能获得的价值
    ll l = plans.size(); // 当前情况的订单数量
    for (int i = 0; i < l; i++) {
        plan now = plans[i], last; // 现在处理的订单, 上一个订单
        if (i > 0) last = plans[i-1];
        else last = {};
        ll sum = 0, time = now.time - last.time; // 计算剩余时间
        for (int j = i; j < l; j++) {
            // 枚举每一个订单，找到最多能增加多少生产力
            sum += plans[j].count;
            if (sum > cnt)
                time = min(time, get_ans(sum - cnt, power, plans[j].time - last.time));
        }
        if (time < 0) return; // 无法满足订单
        power += time;
        cnt += power * (now.time - last.time - time) - now.count; // 加上剩下的零件
        res += now.price;
    }
    ans = max(ans, res);
}
vector<plan> deal() {
    // 把 dfs 的结果转化为 vector<plan>
    vector<plan> res;
    for (ll i = 1; i <= n; i++)
        if (flag[i])
            res.push_back(ps[i]);
    return res;
}
void dfs(ll idx) {
    // dfs 枚举每一种情况
    if (idx == n+1) { check(deal()); return; }
    flag[idx] = 1; dfs(idx+1);
    flag[idx] = 0; dfs(idx+1);
}
int main() {
    scanf("%lld", &n);
    for (ll i = 1; i <= n; i++) scanf("%lld%lld%lld", &ps[i].time, &ps[i].count, &ps[i].price);
    sort(ps+1, ps+n+1, cmp); // 按照时间排序
    dfs(1);
    printf("%lld", ans);
    return 0;
}
```

---


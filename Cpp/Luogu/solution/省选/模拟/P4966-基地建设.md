# 基地建设

## 题目背景

在茫茫宇宙中……

## 题目描述

有一群生物 ccj，他们发现了一个超星系群。其中有 $n$ 个恒星，$m$ 条双向星际航线，每条星际航线都需要消耗 $val_i$ 的燃料值。两个恒星不属于同一个星系当且仅当他们之间没有任何航线，且没有任何路径可以到达。只有每个恒星才可以为飞船补充燃料。每次航行的路线都是一条简单路径。由于燃料系统过于简陋，每个燃料罐只能用于一次航行。他们的首长 ccj 想在其中一个恒星上建立基地。但是 ccj 花了太多钱购买高速飞船，没有太多钱购买燃料罐，所以他对于两个恒星之间的航行一定选择最经济的航行方式，购买最小的燃料罐。他想问你，在基地要备多少的燃料总量，使得在任意一个恒星上建立基地都能从那个基地分别到达那个星系的其他所有恒星。

但是，这个超星系群发生了战争，一些黑洞改变了这里的空间结构。这群生物只知道每条航线花费的燃料值，找不到连接的两个恒星。但是他们的科学家发现了一个性质：每个战争有一个标志值 $q$，航线有不同的排列方式，对于其中一种排列，第 $i$ 条航线连接着 $((q^{i} \bmod 2^{32}+i \times val_i) \bmod n+n) \bmod n+1$ 和 $((q^{i} \bmod 2^{32}-i \times val_i) \bmod n+n) \bmod n+1$ 两个恒星。**运算方式为无符号整型运算**。如果连接的两个恒星一样，说明科学家计算有误，忽略这条航线。ccj 的目标改变了。他想知道对于所有星系的构成情况，最少需要准备多少的燃料总量，使得在这种结构中，在任意一个恒星上建立基地都能分别到达该结构下那个恒星所处星系的其他所有恒星。

你需要输出航线排列顺序。


## 说明/提示

**样例解释：**

这 $5$ 条航线分别是：

$2$ 与 $2$ 往返，花费燃料 $5$

$1$ 与 $1$ 往返，花费燃料 $4$

$3$ 与 $3$ 往返，花费燃料 $2$

$2$ 与 $2$ 往返，花费燃料 $3$

$1$ 与 $2$ 往返，花费燃料 $1$

前四条航线被忽略，故有四个恒星系，$\{1,2\},\{3\},\{4\},\{5\}$

基地建在 $1$ 时，从 $1$ 到 $2$ 需要购买燃料量为 $1$ 的燃料罐，可以发现，没有其他比这个更优的答案。

$2 \le n \le 100\quad 1 \le m \le 40\quad 0 \le q \le 10^9\quad 0 \le val_i \le 1000$

你的答案只需要比std优秀或者和std一样且方案正确即可

1~4数据都为最优答案，5~10数据都为次优答案

~~此题会给出第10个数据的输入~~
[输入数据](https://www.luogu.org/paste/3xkq6bar)

详细范围参见”标程“

数据均为随机构造，请注意常数！

## 样例 #1

### 输入

```
3 5 2
1 2 3 4 5
```

### 输出

```
1
5
4
2
3
1
```

# 题解

## 作者：阿廖 (赞：8)

[题目地址](https://www.luogu.org/problemnew/show/P4966)

## 题目描述：

有一群生物ccj，他们发现了一个超星系群。其中有$n$个恒星，$m$条双向星际航线，每条星际航线都需要消耗$val[i]$的燃料值。两个恒星不属于同一个星系当且仅当他们之间没有任何航线，且没有任何路径可以到达。只有每个恒星才可以为飞船补充燃料。每次航行的路线都是一条简单路径。由于燃料系统过于简陋，每个燃料罐只能用于一次航行。他们的首长ccj想在其中一个恒星上建立基地。但是ccj花了太多钱购买高速飞船，没有太多钱购买燃料罐，所以他对于两个恒星之间的航行一定选择最经济的航行方式，购买最小的燃料罐。他想问你，在基地要备多少的燃料总量，使得在任意一个恒星上建立基地都能从那个基地分别到达那个星系的其他所有恒星。

但是，这个超星系群发生了战争，一些黑洞改变了这里的空间结构。这群生物只知道每条航线花费的燃料值，找不到连接的两个恒星。但是他们的科学家发现了一个性质：每个战争有一个标志值$q$，航线有不同的排列方式，对于其中一种排列，第$i$条航线连接着$((q^{i}\%2^{32}+i*val[i])\%n+n)\%n+1$和$((q^{i}\%2^{32}-i*val[i])\%n+n)\%n+1$两个恒星。**运算方式为无符号整型运算。**如果连接的两个恒星一样，说明科学家计算有误，忽略这条航线。ccj的目标改变了。他想知道对于所有星系的构成情况，最少需要准备多少的燃料总量，使得在这种结构中，在任意一个恒星上建立基地都能分别到达该结构下那个恒星所处星系的其他所有恒星。

你需要输出航线排列顺序。

### 数据范围：
$2<=n<=100\quad 1<=m<=40\quad 0<=q<=10^9\quad 0<=val[i]<=1000$


------------

## 题解部分：

这是道~~语文阅读题~~很烦的题，首先来一波~~一句话~~n句话题意。

定义$p(i,j,k)$为从$i$到$j$的第$k$条简单路径的最长边（排序方式忽略），
$d(i,j)=min{\ p(i,j,k)}$，$ans(i)=\sum_{j=1}^n d(i,j)$，题目求$max{\ ans(i)}$。

为什么是这样的题意呢？

#### “只有每个恒星才可以为飞船添加燃料”，意味着路途中不能添加燃料，所以对于一条航行方式，燃料罐不能小于最长航线，即$p$的定义。

#### “最经济的航行方式”，意味着对于两个恒星，要求最小的燃料罐，根据p定义，为所有航行方式最小值，即$d$的定义。

#### “每个燃料罐只能用于一次航行”，意味着每次航行都要买燃料罐，需要到每个恒星系中不同的点，即$ans$的定义。

#### “在任意一个恒星上建立基地都能分别到达该结构下那个恒星所处星系的其他所有恒星”，即储备燃料量不能小于每一个点，又要最经济，就要所有的最大值，即题目要求的答案。

先解决对于其中一个恒星系的一个固定的标准航路图，知道航线连接的两个恒星问题。最暴力的想法当然是$n^3$的，也就是应用$Floyd$算法，$f[i][j]=min(f[i][j],max(f[i][k],f[j][k]))$，得到任意两点之间的$d$值，然后$n^2$再次求解每个点的$ans$值，顺便求出最大$ans$。这样再枚举全排列就可以拿到出题人给的良心分数啦~~10pts~~。

我们发现，每个$d$会等于其中一个$p$~~废话~~。我们又发现，当最小生成树被建起来时，这个$d$即为两点之间路径最大值。因为最小生成树满足边权尽量小，还使原来就联通的图联通，所以满足题意。****要是写过NOI2018D1T1的人会发现，这个和$kruskal$重构树好像呀！**** 没错，这里我们可以考虑重构树，两点之间的最长边即为重构树上的$lca$。~~lca即为最近公共祖先，请自行百度！~~重构树是啥子呢？也就是做$kruskal$时，把边提出，作为一个全新的点，而原来边连接的两点就是这个新点的儿子。通过并查集，每次选择一个联通子树的根进行提取边建立新点连接，这样这个树就会有奇妙的性质。

#### 1. 二叉树

#### 2. 点权组成大根堆

既然如此，原图中的点都在叶子上，而两点之间的$lca$就会是他们的路径最大值~~证明自行百度~~

如果$i$和$j$的$lca$是点$p$的话，$ans(i)$和$ans(j)$都要加上$p$的权值。这时候我们反向考虑，考虑非叶节点对叶子节点的贡献。显然，如果一个非叶节点会贡献到一些点，那些点对的路径都会经过这个节点。所以，它的左子树到右子树或右子树到左子树就正好可以满足这个条件，对于每个节点，记录它的孩子将要被修改的权值$q$，则$q[lson]=q[x]+size[rson]*val[x]$，右儿子同理。这个式子表示，一个节点首先要将他的“被修改权值”传下去，然后加上这个节点的贡献，左边每个点都需要到达右子树的每个点，所以用乘法，$size$即为子树大小。这样一来，我们从根节点往下遍历之后，就可以知道每个叶子节点，即原图的点的$ans$值。全部取一遍$max$即可知道答案。效率是$O(mlog_2m+m+(n-1)+n)$ 明显优秀很多。第一个为排序复杂度，第二个为枚举边建树和遍历树上每个点，第三个为遍历树上每个非叶节点，第四个为每个点取$max$。这样我们就可以高效求出每个固定图的答案啦。

但是图不固定啊……对于这种无法预测全排列的题目，一般我们会考虑到乱搞算法，这里介绍一种算法，叫做~~膜你~~模拟退火。~~证明请自行百度。~~大概流程就是随机变换出一种排列，计算答案，如果该答案比当前答案更优，则取，否则根据不同的时间，考虑是否要取。这个取的概率随着每次搜索时间的推移逐渐降低。由于这个操作，模拟退火不同于爬山算法，更不容易陷入局部最优值。通过一定概率的选择，“跳出”坑，最终尽量达到全局最优值。

#### 我们把这个算法和之前推出的算法结合在一起，就是本题的正解啦。

公布一下std用的退火参数：

计算$40$次

初温$10000$

降温系数$0.999$

终止温度$0.001$

大家可以参考一下啦！

一个小提示，对于$q^i\%2^{32}$，由于$2^{32}$是$uint$的上限，故可使用自然溢出法预处理出所有的$q^i\%2^{32}$~~或许可以优化常数？~~

本题预计难度：~~紫？~~蓝题。

std不给出，谢谢大家！

---

## 作者：MeowScore (赞：7)

[link](https://www.luogu.com.cn/problem/P4966)

先把这个毒瘤题面翻译一下（汉译汉是吧）。

有 $n$ 个点，$m$ 条边。给出每条边的权值 $v$。但是这些边的权值顺序是不确定的，对于不同的权值排列顺序，可能会生成一个不同形态的图，生成方式是对于第 $i$ 条边，它连接着两个点 $x$ 和 $y$。

$$x=((q^i\bmod2^{32}+i\times v_i)\bmod n+n)\bmod n+1$$

$$y=((q^i\bmod2^{32}-i\times v_i)\bmod n+n)\bmod n+1$$

运算方式为无符号整型运算。

求对于所有的权值排列生成的图，图的代价最少是多少，下面定义“图的代价”：

设 $d_{i,j}$ 表示图中从 $i$ 到 $j$ 的所有简单路径中，一条路径上的最大边权最小是多少。图的代价即为 $\max_{i=1}^{n}(\sum_{j=1}^{n}d_{i,j})$（其中 $j$ 与 $i$ 联通）。

考虑怎么做。直接枚举排列显然不可行，然而边权排列和图的形态之间的联系就靠着上面 $x$ 和 $y$ 那两个根本没什么好性质的式子，所以想快速确定一个优秀的排列也是困难的，这个时候考虑一些随机算法，比如，模拟退火。

想到了模拟退火之后，我们接下来要考虑的问题就是如何快速求解一张图的代价。

首先考虑一个性质：$d_{i,j}$ 等于最小生成树上 $i$ 到 $j$ 的简单路径上的最大边权。详见[此题](https://www.luogu.com.cn/problem/P1396)，容易用反证法证明该结论。（其实这个题是一个最小生成森林，为了方便下面只考虑一棵树）

直接爆搜是 $n^2$ 的，但是这样效率低下，只能以准确性为代价了。考虑更高效的做法，我们不对于每个点暴力求解，而是考虑每条边的贡献。我们不妨从大到小考虑每一条边，假设当前边权值为 $z$，断掉它之后原来的这个连通块变成了 $A$、$B$ 两个连通块，对于 $A$ 中的每个点，贡献都要加上 $z\times size_B$，$B$ 也同理。但是删边操作很难维护，不妨使用时间倒流的技巧，变成从小到大加边，并查集直接做，详见代码。

第一发没过，调高了降温系数就过掉了。加了卡时，并且喜提最劣解。

代码：

```
#include<bits/stdc++.h>
using namespace std;
const int N=210;
#define ll long long
#define ui unsigned int
#define db double
ui ksm(ui x,ui y){
	ui res=1;
	while(y){
		if(y&1)
			res=res*x;
		x=x*x;
		y/=2;
	}
	return res;
}
int n,m;
ui q;
struct dat{
	int x;
	int y;
	int z;
}g1[N],g2[N],g3[N];
int v[N],uf[N];
ll sz[N],val[N];
ll ans=1000000000000000;
int cmp(dat x,dat y){
	return x.z<y.z;
}
int find(int x){
	if(uf[x]==x)
		return x;
	return uf[x]=find(uf[x]);
}
int rec[N];
void gen(){
	for(int i=1;i<=m;i++){
		ui x=((ksm(q,(ui)i)+((ui)i*v[i]))%n+n)%n+1;
		ui y=((ksm(q,(ui)i)-((ui)i*v[i]))%n+n)%n+1;
		g1[i]={x,y,v[i]};
	}
}
ll calc(){
	gen();
	ll res=0;
	for(int i=1;i<=m;i++)
		g2[i]=g1[i];
	sort(g2+1,g2+m+1,cmp);
	for(int i=1;i<=n;i++)
		uf[i]=i;
	int tot=0;
	for(int i=1;i<=m;i++){
		int x=g2[i].x;
		int y=g2[i].y;
		int z=g2[i].z;
		int f1=find(x);
		int f2=find(y);
		if(f1==f2)
			continue;
		uf[f2]=f1;
		g3[++tot]=g2[i];
	}
	for(int i=1;i<=n;i++){
		val[i]=0;
		uf[i]=i;
		sz[i]=1;
	}
	for(int i=1;i<=tot;i++){
		int x=g3[i].x;
		int y=g3[i].y;
		int z=g3[i].z;
		int f1=find(x);
		int f2=find(y);
		val[f1]=max(val[f1]+z*sz[f2],val[f2]+z*sz[f1]);
		sz[f1]+=sz[f2];
		uf[f2]=f1;
		res=max(res,val[f1]);
	}
	if(res<ans){
		ans=res;
		for(int i=1;i<=m;i++)
			rec[i]=g1[i].z;
	}
	return res;
}
void simulate_anneal(){
	db T=1e5;
	db low=0.999;
	while(T>=1e-4){
		int X=rand()%m+1;
		int Y=rand()%m+1;
		ll nw=calc();
		swap(v[X],v[Y]);
		ll res=calc();
		if(res>nw){
			db del=res-nw;
			if((db)rand()/RAND_MAX>exp(-del/T))
				swap(v[X],v[Y]);
		}
		T*=low;
	}
}
int main(){
	srand(time(0));
	cin>>n>>m>>q;
	for(int i=1;i<=m;i++)
		cin>>v[i];
	while(1.0*clock()/CLOCKS_PER_SEC<=1.8)
		simulate_anneal();
	cout<<ans<<'\n';
	for(int i=1;i<=m;i++)
		cout<<rec[i]<<'\n';
	return 0;
}
```
















---


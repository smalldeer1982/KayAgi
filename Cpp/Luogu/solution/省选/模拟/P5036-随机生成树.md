# 随机生成树

## 题目背景

@葛军 改编的水题



## 题目描述

rainheavy在纸上画了N个点（从1到N编号），每个点的颜色用一个整数描述。rainheavy决定用这N个点随机生成一棵树，生成的规则如下：

对于2号点到N号点，每个点随机指定连接一个点。i号点(2 <= i <= N)的连的点在i的约数中和i的倍数中不超过N的中随机挑选一个。（例如N=30时10号点的可以连接1号，2号，5号，20号，30号）

生成的树中不能有重边（不然就不叫树了）

树生成完之后，rainheavy可以计算出这个树有多少个联通块，一个联通块是一些点的集合，需要满足以下两个条件：

1、从集合中任取两个点都满足：两个点颜色相同，且这两个点之间存在一条树边组成的路径，路径上的所有点都和这两个点颜色相同

2、对于集合中的任意一个点和集合外的任意一个点：两点要么不同色，要么不存在一条树边组成的路径使得路径上所有点都和这两个点同色。

rainheavy希望计算出生成的树中联通块个数最多时，需要连接哪些边，但是rainheavy太强了，不屑于做这种辣鸡题目，~~更重要的是他要去AK IOI~~，于是就把题目扔给了你

注：边的顺序

1.首先，满足连通块个数最多的优先（即对于生成连通块有贡献的优先）

2.同样满足条件1时，连接的两个点编号之和较小的边优先（如满足条件1时，连接3号点和5号点的边比连接4号点和5号点的边优先）

3.同时满足条件2时，连接的两个点编号的之中较小的一个较小的边优先（如满足条件2时，连接2号点和6号点的边比连接3号点和5号点的边优先）

## 说明/提示

对于样例的解释：因为2号、4号点会对生成联通块有贡献（3号你连了也没用），又因为1+2<1+4，所以1 2比1 4优先输出，最后再输出1 3


对于30%的数据, 2 <= N <= 10

对于60%的数据, 2 <= N <= 5000

对于80%的数据, 2 <= N <= 200000

对于100%的数据, 2 <= N <= 500000，1<=颜色<=1e9（反正多了也没用）

## 样例 #1

### 输入

```
4
3 2 3 2```

### 输出

```
1 2
1 4
1 3```

# 题解

## 作者：CznTree (赞：3)

#### 题意

其实就是连通块最多有多少个嘛，这样我们就可以用 kruskal。

#### 题解

主要是在 kruskal 中的排序怎么排，我们按照题意来写 cmp 函数，这可能也是本题较难的地方。 

我们要保留更多的连通块，就把边权从大到小排序，其他的按照题意即可。

```
bool cmp(Edge a, Edge b) {
	if(a.w == b.w) { // 边权相等
		if(a.u + a.v == b.u + b.v) { // 起点和终点同样也相等
			return a.u < b.u; 
		}
		return a.u + a.v < b.u + b.v; // 比较和
	}
	return a.w > b.w; // 保留更多的连通块 
}
```

其他的就基本不难了，用调和级数初始化，连边就行了。

#### Code 

```cpp
#include <bits/stdc++.h> 
#define IOS std::ios::sync_with_stdio(false), std::cin.tie(nullptr), std::cout.tie(nullptr) 
#define rep(i, a, b) for (int i = a; i <= b; i++) 
#define per(i, a, b) for (int i = a; i >= b; i--)
#define lc(x) x << 1ll 
#define rc(x) x << 1ll | 1ll
#define lowbit(x) ((x) & (-x))
#define LEN_LC (tree[lc(i)].r - tree[lc(i)].l + 1) 
#define LEN_RC (tree[rc(i)].r - tree[rc(i)].l + 1) 
#define LEN (tree[i].r - tree[i].l + 1)  

const int N = 5e5 + 7; 
const int M = 1e7 + 7;
struct Edge{	
	int u, v, w; 
}edge[M];
int dsu[N], c[N]; 

bool cmp(Edge a, Edge b) {
	if(a.w == b.w) {
		if(a.u + a.v == b.u + b.v) {
			return a.u < b.u; 
		}
		return a.u + a.v < b.u + b.v; 
	}
	return a.w > b.w; 
}


void init() {
	rep(i, 1, N) dsu[i] = i; 
}
int find(int x) {
	if(x != dsu[x]) {
		dsu[x] = find(dsu[x]); 
	}  
	return dsu[x];	
} 
int n; 
long long cnt, ans; 
void kruskal() {
	init(); 
	std::sort(edge + 1, edge + 1 + cnt, cmp); 
	rep(i, 1, cnt) {
		int fx = find(edge[i].u); 
		int fy = find(edge[i].v); 
		if(fx != fy) {
			dsu[fx] = fy; 
			std::cout << edge[i].u << " " << edge[i].v << std::endl; 
		}	
	}
}

void solve() {
	std::cin >> n; 
	rep(i, 1, n) {
		std::cin >> c[i]; 
	}
	
	rep(i, 1, n) {
		for (int j = i * 2; j <= n; j += i) {
			cnt++; 
			edge[cnt].u = i; 
			edge[cnt].v = j; 
			if(c[i] == c[j]) {
				edge[cnt].w = -1; 
			} else {
				edge[cnt].w = 0; 
			}
		}
	}
	
	kruskal(); 
}

signed main() {
	IOS;
	solve(); 
	return 0; 
}
```

#### 后续

老师说这题根本没有紫的难度！！！

---

## 作者：π酱 (赞：2)

这题本来是牛客网模拟赛的题目，由于我考试的时候想歪了，想到了kruskal，结果发现做不了，于是我就把题目改了下，改成了kruskal可以做的，但是还是被验题人wjyyy用原来的方法轻轻松松搞掉了QAQ,于是我决定把题目改成输出方案~~2333~~

以上纯属扯淡

看完题目，发现题目中要求连通块最多有多少个，仔细想想发现正着推很难，那就倒着推呗。我们首先假设这棵树没有边，则当前连通块有$n$个，现在我们要在这$n$个点中加上$n-1$条边。基于连通块的定义我们可以发现：若一条边连接的两个点颜色不同，则当前的边对于目前连通块个数没有影响，若一条边连接的两个点颜色相同，则当前连通块个数需要减$1$。

所以本题做法就很清晰了：先枚举所有可以连的边（如果你稍微想一下就会发现如果枚举每个数的倍数就可以找到所有的边了），若边连接的两个点颜色不同，则若连接当前边，其对连通块个数的贡献为$1$，否则贡献为$0$，然后按照题目要求排个序，跑一边kruskal就行了。（是不是很简单，我也这么觉得QAQ）

代码如下：
```cpp
#include<bits/stdc++.h>
#define REP(i,a,b) for (register int i(a);i<=(b);i++)
namespace fast_IO {
    const int IN_LEN=10000000,OUT_LEN=10000000;
    char ibuf[IN_LEN],obuf[OUT_LEN],*ih=ibuf+IN_LEN,*oh=obuf;
    char *lastin=ibuf+IN_LEN;
    const char *lastout=ibuf+OUT_LEN-1;
    inline char getchar_() {
        if(ih==lastin)lastin=ibuf+fread(ibuf,1,IN_LEN,stdin),ih=ibuf;
        return (*ih++);
    } inline void putchar_(const char x) {
        if(ih==lastout)fwrite(obuf,1,oh-obuf,stdout),oh=obuf;
        *oh++=x;
    } inline void flush() {
        fwrite(obuf, 1, oh - obuf, stdout);
    }
}
using namespace fast_IO;
using namespace std;
template <typename T>
inline void Read(T&x) {
    char cu=getchar();
    x=0;
    bool fla=0;
    while(!isdigit(cu)) {
        if(cu=='-')fla=1;
        cu=getchar();
    }
    while(isdigit(cu))x=x*10+cu-'0',cu=getchar();
    if(fla)x=-x;
}
template <typename T>
void printe(const T x) {
    if(x>=10)printe(x/10);
    putchar(x%10+'0');
}
template <typename T>
inline void Write(const T x) {
    if(x<0)putchar('-'),printe(-x);
    else printe(x);
}
//以上是快速输入输出（可以忽略）
long long a,b,n,Cnt,Num,Ans,c[5000010],Fa[5000010];
struct Node{
    int x,y,v;
}k[100000010];
int Find(int x){
    while(Fa[x]!=x) x=Fa[x]=Fa[Fa[x]];
    return x;	
}
bool Cmp(Node a,Node b){
    if(a.v!=b.v){
    	return a.v>b.v;
    }
    else{
        if((a.x+a.y)!=(b.x+b.y)){
            return (a.x+a.y)<(b.x+b.y);
        }
        else{
            return a.x<b.x;
        }
    }	 
}
int main() {
    Read(n);
    REP(i,1,n) {
        Read(c[i]);
    }
    REP(i,1,n>>1) {
        REP(j,2,n/i) {
            k[++Cnt].x=i;
            k[Cnt].y=i*j;
            if(c[i]!=c[i*j]){
                k[Cnt].v=1;
            }
        }
    }
    for (int i=1;i<=n;i++)
        Fa[i]=i;
    sort(k+1,k+Cnt+1,Cmp); 
    for (int i=1;i<=Cnt;i++){
            a=0;
            b=0;
            a=Find(k[i].x);
            b=Find(k[i].y);
            if (a==b)
                continue;
            Write(k[i].x);
            putchar(' ');	
            Write(k[i].y);
            putchar('\n');
            Fa[b]=a;
        }
return flush(),0;//Fast IO专用结尾
}
```

---

## 作者：_zhx (赞：1)

# P5036 随机生成树 

题目就是让我们求连通块最多有几个，所以我们可以用 `kruskal`。

我们老师说 `kruskal` 的排序是难点（事实就是如此）。

按题意写就行了，先排序边权，然后比较起点与终点，最后比较和。

权值计算也很简单，如果 $c_i=c_j$ 就减去 $1$ 个连通块，否则就是 $1$。

然后用调和级数初始化连边。

code：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e6+5;
struct Edge{int u,v,w;}edge[100000005];
int n,a[N],c[N],cnt=0;
int find(int x){return a[x]==x?x:a[x]=find(a[x]);}
void kruskal(){for(int i=1;i<=cnt;i++) if(find(edge[i].u)!=find(edge[i].v)) cout<<edge[i].u<<' '<<edge[i].v<<'\n',a[find(edge[i].v)]=find(edge[i].u);}
bool cmp(Edge x,Edge y){return x.w!=y.w?x.w>y.w:x.u+x.v==y.u+y.v?x.u<y.u:x.u+x.v<y.u+y.v;}
int main()
{
	cin>>n;
	for(int i=1;i<=n+1;i++) a[i]=i;
	for(int i=1;i<=n;i++) cin>>c[i];
	for(int i=1;i<=n;i++)
	{
		for(int j=i*2;j<=n;j+=i)
		{
			edge[++cnt].u=i,edge[cnt].v=j;
			edge[cnt].w=c[i]==c[j]?-1:1;					
		}		
	}
	sort(edge+1,edge+cnt+1,cmp);
	kruskal();
	return 0;
} 
```

最后，不要被难度吓到了，因为这题没有紫的难度，推荐篮。

---

## 作者：_QyGyQ_ (赞：1)

## 思路
感觉用 `kruskal` 比较简单。主要是排序方式的问题，由题目可知，不同的颜色合并所产生的贡献大于同种颜色所产生的贡献。所以在排序中，先判断边权值的大小，如果相同，就再判断两个点的入点和出点之和是否相同，如果相同，就判断两个点哪个邻居最小。否则就判断两个点的入点和出点的和哪个小。至于怎么连边，可以使用调和级数初始化。最后在合并过程中顺便输出就行了。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
const int N=1e6+7;
int s[N],a[N];
int find(int x){
	if(x==s[x]) return x;
	return s[x]=find(s[x]);
}
void merge(int x,int y){
	if(find(x)!=find(y)){
		printf("%d %d\n",x,y);
		s[find(y)]=find(x);
	}
}
struct edge{
	int u,v,w;
};
vector<edge>G;
int n,cnt;
bool cmp(edge x,edge y){
	if(x.w==y.w){
		if(x.u+x.v==y.u+y.v){
			return min(x.u,x.v)<min(y.u,y.v);
		}
		return x.u+x.v<y.u+y.v;
	}
	return x.w>y.w;
}
void MST(){
	for(int i=1;i<=n;i++){
		s[i]=i;
	}
	sort(G.begin(),G.end(),cmp);
	for(auto i:G){
		merge(i.u,i.v);
	}
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++){
		for(int j=i*2;j<=n;j+=i){
			if(a[i]==a[j]){
				G.push_back({i,j,-1});
			}
			else{
				G.push_back({i,j,0});
			}
		}
	}
	MST();
	return 0;
} 
```


---

## 作者：Dino_chx (赞：0)

## 1. 思路部分

### 1.1 筛边

首先属于基操的是我们要筛边。

（此处默认你已经筛完了）

先约定有两数 $x,y$ 需要我们判断边权，$col_w$ 表示 $w$ 的颜色，$wei_{i,j}$ 为我们给 $(i,j)$ 的边权

显然如果两点颜色相同（即满足 $col_x=col_y$），连通块是要减少 $1$ 个的，即:

$$wei_{x,y}=-1 $$

那么如果两点颜色不相同（即 $col_x \ne col_y$），连了没用，那就没有贡献，即是 $0$ 了，即：

$$wei_{x,y}=0$$

### 1.2 排序

用一个 $\text{sort}$ 显然是每个人都能想得到的。

但是关键在于如何设置排序规则，即 $\text{cmp}$ 函数。

因为我们设置了边权啊，而且我们想要保留尽可能多的连通块，所以我们把边权从大到小排序呗。这样 $0$ 的边就会被先考虑呗，连通块就多了啊。

于是我们就按照题目里说的一大堆排序规则排一下就好啦。
 
```cpp
bool cmp(Edge x,Edge y)  
{
	if(x.w==y.w)       //当边权相同时
	{
		if(x.u+x.v==y.u+y.v)   //如果按照题目说的起点终点和也相同
			return min(x.u,x.v)<min(y.u,y.v); //那就比较最小值
		return x.u+x.v<y.u+y.v;  //于是比较起点终点和
	}
	return x.w>y.w;      //那就我们要保存尽量多的连通块，边权大的（即是 0 的优先）
}
```

### 1.3 kruskal

排序后初始化并查集，遍历每一条边。

当这条边的初始点和目标点不在同一并查集内时合并，并且输出。

## 2. Code & 闲话

### 2.1 Code

（仅核心）

```cpp
bool cmp(Edge x,Edge y)
{
	if(x.w==y.w)
	{
		if(x.u+x.v==y.u+y.v)
			return min(x.u,x.v)<min(y.u,y.v);
		return x.u+x.v<y.u+y.v;
	}
	return x.w>y.w;
}

	sort(p+1,p+1+tot,cmp);
	init(n+1);
	for(int i=1;i<=tot;i++)
	{
		if(find(p[i].u)!=find(p[i].v))
		{
			unity(p[i].u,p[i].v);
			printf("%d %d\n",p[i].u,p[i].v);
		}
	}

```

### 2.2 闲话

实际上根本没有紫题的难度，非常直观。

完结撒花(p≧w≦q)！！！！！！

---


# [CTSC1998] 算法复杂度

## 题目背景

CTSC1998 D1T3

我们在编程时，最关心的一个问题就是算法的时间复杂度。但是分析一个程序的复杂度是一项很困难的工作，在程序的码风不是很好的情况下更是如此。

所以，专门研究算法的 SERKOI 小组决定开发出一个分析程序时间复杂度的软件。由于这是一个全新的领域，所以 SERKOI 小组决定先从简单情况入手进行分析。

## 题目描述

为了简化问题,程序只包含循环和顺序结构,程序的结构定义如下：

$\texttt{begin <statement> end}$ 

一个语句块的结构是**递归定义**的，如下所示：

$\texttt{loop x <statement> end}$

或者 $\texttt{op <statement>}$ 

或者为 $\texttt{break <statement>}$ 

或者为 $\texttt{continue <statement>}$ 

语句块可以为空。

注意：

1. 一个程序都是以 $\texttt{begin}$ 开始，以相应的 $\texttt{end}$ 结束；

2. $\texttt{loop x <statement> end}$ 表示其中的语句重复执行 $x$ 次；

3. $\texttt{op x}$ 表示执行 $x$ 个单位操作；

4. 上面两点中的 $x$ 可以是一个正整数或 $n$；

5. $\texttt{break}$ 语句的作用是跳出这一层循环, $\texttt{continue}$ 语句的作用是跳过这一层循
环的其它语句，直接进入下一次循环。如果它（$\texttt{break}$ 或 $\texttt{continue}$）不在任何一层循环中，**请忽略它们**。

你需要写一个程序，用来求出题目描述的程序的时间复杂度，并以多项式的形式输出。

注意，该多项式是关于 $n$ 的多项式，而且，**常数项和系数不能省略**。

数据保证能求出该程序的时间复杂度。

## 说明/提示

循环的嵌套最多不超过 $20$ 层。

保证最终时间复杂度多项式每项的系数不超过 ${10}^9$。

## 样例 #1

### 输入

```
begin loop n loop 3 loop n
op 20
end end end
loop n op 3 break end
loop n loop n
op 1
break
end end
end
```

### 输出

```
60n^2+n+3```

## 样例 #2

### 输入

```
begin
op n
loop 3
op n
break
end
loop n
loop n
op 1
continue
op n
end
end
end ```

### 输出

```
n^2+2n```

# 题解

## 作者：囧仙 (赞：7)

## 题解

本题的循环仅存在数字和 $n$ 两种情况，并且**不存在判断语句**，因此我们可以将整个程序转换为**一个表达式**：

- 对于 $\text{op}$ 操作，我们可以看做在这个位置放置了一个数字（操作次数）。**同时在它前面加一个加号**。

- 对于 $\text{continue}$ 和 $\text{break}$ 操作，每当我们读取到它们时，就**忽略**接下来的所有运算，直到碰到当前循环的 $\text{end}$ 语句。

- 对于 $\text{loop}$ 语句（和 $\text{begin}$ 语句），我们在该出放置一个左括号，**同时在左括号前边放一个加号、后边放一个数字** $\bm 0$。如果对应的循环结构内存在 $\text{break}$，那么在左括号之前放置一个数字 $1$；否则放置 $\text{loop}$ 语句执行的次数（数字或者 $n$）。

- 对于 $\text{end}$ 语句，直接放置一个右括号，即可和对应 $\text{loop}$ 语句的左括号匹配。

然后……对其中缀表达式求值，就做完了。以下我们举个例子（使用了样例）：

$$
\begin{gathered}\boxed{\begin{aligned}
&\verb!begin!\cr
&\verb!  loop n!\cr
&\verb!    loop 3!\cr
&\verb!      loop n!\cr
&\verb!        op 20!\cr
&\verb!      end!\cr
&\verb!    end!\cr
&\verb!  end!\cr
&\verb!  loop n!\cr
&\verb!    op 3!\cr
&\verb!    break!\cr
&\verb!  end!\cr
&\verb!  loop n!\cr
&\verb!    loop n!\cr
&\verb!      op 1!\cr
&\verb!    break!\cr
&\verb!    end!\cr
&\verb!  end!\cr
&\verb!end!\cr
\end{aligned}} \Rightarrow
\boxed{\begin{aligned}
&\verb!begin!\cr
&\verb!  loop n!\cr
&\verb!    loop 3!\cr
&\verb!      loop n!\cr
&\verb!        op 20!\cr
&\verb!      end!\cr
&\verb!    end!\cr
&\verb!  end!\cr
&\verb!  loop 1!\cr
&\verb!    op 3!\cr
&\verb!!\cr
&\verb!  end!\cr
&\verb!  loop n!\cr
&\verb!    loop 1!\cr
&\verb!      op 1!\cr
&\verb!!\cr
&\verb!    end!\cr
&\verb!  end!\cr
&\verb!end!\cr
\end{aligned}} \Rightarrow
\boxed{\begin{aligned}
&\verb!+(0!\cr
&\verb!  +n(0!\cr
&\verb!    +3(0!\cr
&\verb!      +n(0!\cr
&\verb!        +20!\cr
&\verb!      )!\cr
&\verb!    )!\cr
&\verb!  )!\cr
&\verb!  +1(0!\cr
&\verb!    +3!\cr
&\verb!!\cr
&\verb!  )!\cr
&\verb!  +n(0!\cr
&\verb!    +1(0!\cr
&\verb!      +1!\cr
&\verb!!\cr
&\verb!    )!\cr
&\verb!  )!\cr
&\verb!)!\cr
\end{aligned}}
\end{gathered}
$$

接着我们去除所有多余的空格和换行符。终于，我们得到了：

$$+(0+n(0+3(0+n(0+20)))+1(0+3)+n(0+1(0+1)))$$

计算它的值：

$$n(3\times 20n)+1\times 3+n\times 1\times 1=60n^2+n+3$$

具体操作的时候，就直接使用两个栈进行中缀表达式求值。（更详细的可以看[这篇](https://www.luogu.com.cn/blog/over-knee-socks/solution-p2229)）。其中一个栈维护处理到的数字，另外一个栈维护处理到的运算符。数字入数字栈；每当碰到运算符时，不断取出运算符栈的栈顶，若优先级不小于当前的运算符，则不断取出数字栈栈顶的两个数字，运算后再推入数字栈，最后再将该运算符入栈；对于左括号直接入栈，碰到右括号则不断取运算符栈栈顶进行运算，知道碰到对应的左括号。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
struct Node{
    vector<i64> A; Node(){} Node(vector <i64> _A){A=_A;}
    Node operator +(const Node &t){
        Node r; r.A.resize(max(A.size(),t.A.size()));
        for(int i=0;i<r.A.size();++i)
            r.A[i]+=(i<A.size()?A[i]:0)+(i<t.A.size()?t.A[i]:0); return r;
    }
    Node operator *(const Node &t){
        Node r; r.A.resize(A.size()+t.A.size()-1);
        for(int i=0;i<A.size();++i)
            for(int j=0;j<t.A.size();++j)
                r.A[i+j]+=A[i]*t.A[j]; return r;
    }
    void wrt(){
        bool h=true; dn((int)A.size()-1,0,i) if(A[i]){
            if(!h) cout<<"+"; h=false;
            if(A[i]!=1||i==0) cout<<A[i];
            if(i==1) cout<<"n"    ; else
            if(i!=0) cout<<"n^"<<i;
        }
        if(h) cout<<"0"; cout<<endl;
    }
};
string x,y; stack<int> T; stack<Node> S; int n,f,g;
int main(){
    ios_base::sync_with_stdio(false); T.push(0);
    do{
        cin>>x;
        if(x=="begin"){
            T.push(0); S.push(Node({1})),S.push(Node({0}));
        } else
        if(x=="end"){
            if(g>1){--g;continue;}
            while(T.top()!=0){
                Node a=S.top(); S.pop();
                Node b=S.top(); S.pop();
                S.push(a+b),T.pop();
            }
            Node a=S.top(); S.pop();
            Node b=S.top(); S.pop();
            if(f==2) S.push(a); else S.push(a*b);T.pop(),f=0,--n;
        } else if(x=="loop"){
            if(f) {++g;continue;}
            cin>>y; T.push(1),T.push(0),++n;
            if(y=="n"||y=="0") S.push(Node({0,1}));
            else               S.push(Node({atoi(y.c_str())}));
            S.push(Node({0}));
        } else if(!f&&x=="op"){
            cin>>y; T.push(1);
            if(y=="n"||y=="0") S.push(Node({0,1}));
            else               S.push(Node({atoi(y.c_str())}));
        }
        else if(!f&&x=="continue"&&n!=0) f=1,g=1;
        else if(!f&&x=="break"   &&n!=0) f=2,g=1;
    }while(T.size()>1);
    S.top().wrt();
    return 0;
}
```

---

## 作者：Macesuted (赞：6)

在[我的博客](https://macesuted.github.io/blog/solution-P5698/)中食用体验更佳。

[题面](https://www.luogu.com.cn/problem/P5698)

# 题意

给你一份代码，仅包含 `loop` `op` `break` `continue` 四个命令，分别表示循环若干次，执行若干单位操作，跳出此层循环，跳过此层循环剩余部分。要你算出此代码的时间复杂度。

# 分析

我们可以对每一个 `loop` 和 `op` 操作建一个点，点权即为该操作后面的 `x` 值，再按照他们的包含关系建一棵树。如果遇到 `break`，将此层 `loop` 对应的点的点权设置为 $1$，再略过此层剩余部分的代码；如果遇到 `continue`，将此层剩余部分的代码略过即可。

注意点上还有保存一个标记，表示该点是否存在实际贡献（就是该点对应的操作是不是 `op`），因为 `loop` 操作本身显然并不对答案存在贡献。

# 代码

```cpp
#include <cstdio>
#include <iostream>
#include <string>
#include <vector>

const int maxDep = 25;

class Node {
   public:
    Node(Node* fa, int value, bool isLeaf) : father(fa), val(value), leaf(isLeaf) { return; }

    int val;                  //权值
    bool leaf;                //是否为叶子（是否需要算入复杂度）
    std::vector<Node> child;  //儿子节点
    Node* father;             //父亲指针
};

int stringToInt(const std::string& str) {
    int num = 0;
    for (std::string::const_iterator i = str.begin(); i != str.end(); i++) num = (num << 3) + (num << 1) + (*i ^ 48);
    return num;
}
void readUntilEnd(void) {
    std::string str;
    int cnt = 1;
    while (cnt) {
        std::cin >> str;
        if (str == "loop") cnt++;
        if (str == "end") cnt--;
    }
    return;
}

Node root(NULL, 0, false);  //根节点
int answer[maxDep];

void dfs(const Node& p, int x, int y) {
    if (p.leaf) {
        answer[x] += y;  //统计答案
        return;
    }
    for (std::vector<Node>::const_iterator i = p.child.begin(); i != p.child.end(); i++)
        (i->val == -1) ? dfs(*i, x + 1, y) : dfs(*i, x, y * i->val);  //根据此子节点权值更改参数
    return;
}

int main() {
    std::string cmd;
    Node* ptr = &root;
    while (true) {
        std::cin >> cmd;
        if (cmd == "op") {
            std::string x;
            std::cin >> x;
            ptr->child.push_back((Node){ptr, x == "n" ? -1 : stringToInt(x), true});
        } else if (cmd == "loop") {
            std::string x;
            std::cin >> x;
            if (x == "0") x = "n";  //数据问题，详见https://www.luogu.com.cn/discuss/show/271086
            ptr->child.push_back((Node){ptr, x == "n" ? -1 : stringToInt(x), false});
            ptr = &ptr->child.back();
        } else if (cmd == "break") {
            if (ptr == &root) continue;
            ptr->val = 1;  //由于循环至此必然结束，就相当于循环只运行了一遍
            ptr = ptr->father;
            readUntilEnd();
        } else if (cmd == "continue") {
            if (ptr == &root) continue;
            ptr = ptr->father;
            readUntilEnd();  //从这句话到结尾的所有话都可以无视
        } else if (cmd == "end") {
            if (ptr == &root) break;
            ptr = ptr->father;
        }
    }
    dfs(root, 0, 1);
    bool first = true;
    for (int i = maxDep - 1; ~i; i--)
        if (answer[i]) {
            if (!first) putchar('+');
            first = false;
            if (answer[i] != 1 || !i) printf("%d", answer[i]);
            if (i > 1)
                printf("n^%d", i);
            else if (i == 1)
                putchar('n');
        }
    if (first) putchar('0');
    puts("");
    return 0;
}
```





---

## 作者：MC_xjhjdA (赞：5)

# **这是一篇 Python3 题解 P5698**
~~不过你也可以进来看看思路~~
## 主要思路
模拟做法\
把遍历到的当前的最小循环计算并在原位置替换。

------------
那么对于样例1中的第一个循环就是这么处理的：
```
loop n loop 3 loop n
op 20
end end end
```
变为
```
loop n loop 3
op 20n
end end
```
变为
```
loop n
op 60n
end
```
变为
```
op 60n^2
```
## 题中需要注意的
- 对于 ```loop x op x```
由于 x 只会是 n 或常数，所以只会涉及**多项式加减**以及**单项式乘多项式**，而且全程代数式都只关于 n 或者只有常数，所以可以用一个长度为 22 的列表代表一个多项式(由题中条件得多项式次数最大为 21 )，以降幂的形式存储。
```python
[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,60,1,3]
#等价于 [0]*19+[60,1,3]
#可以代表 60n^2+n+3
```
- 对于 ```break``` 的处理\
可以发现：\
```loop x1 op x2 break op x3 end```\
等价于\
```op x2```\
处理方式：把循环次数以及从 ```break``` 到本次循环的 ```end``` 包括 ```break``` 和 ```end``` 都删除。


- 对于 ```continue``` 的处理\
可以发现：\
```loop x1 op x2 continue op x3 end```
等价于\
```loop x1 op x2```
处理方式：把从 ```continue``` 到本次循环的 ```end``` (包括 ```continue``` 和 ```end``` 都删除)。


- ```loop``` 和 ```end``` 的数量\
```loop``` 比 ```end``` 少一个，因为最后一个 ```end``` 对应着开头的 ```begin```。


- 如何找出当前的最小循环\
遍历到 ```loop``` 后不会再次遍历到 ```loop```，并在遍历到 ```end``` 的时候结束，此时 ```loop``` 到 ```end``` 之间就是当前的最小循环。


## 写代码
1. ### 读入
用两个变量分别储存 ```loop``` 和 ```end``` 的数量，一旦 ```end``` 的数量超过 ```loop``` 的数量就退出读入的循环。
```python
l,lpt,edt=[],0,0 #用列表l储存读入,用lpt和edt来储存loop和end的数量
while True:
    s=input().split() #读入,存储于列表s
    lpt+=s.count('loop')
    edt+=s.count('end')
    l+=s #合并列表,列表l的末尾接上列表s
    if edt>lpt: #上面提及的退出条件
        break
l=l[1:-1] #删去开头的begin和最后一个end
```
2. ### 计算当前的最小循环并在原位置替换
用 while 循环和累加器 x 遍历列表 l，如果找到当前的最小循环就计算并在原位置替换，然后从头开始遍历。\
涉及**多项式加减**以及**单项式乘多项式**，所以要写个函数将 n 或常数转列表。
```python
def num_to_list(g): #输入只会是一个列表或者n或者一个常数
    if type(g)==list: #如果已经是列表就不用转
        return g
    if g=='n': #处理n
        return [0]*20+[1,0]
    else: #处理常数
        return [0]*21+[int(g)]
```
如果所有的循环都被计算完毕那就不会遍历到 ```loop``` ，这时列表 l 会超出索引范围抛出 ```IndexError```，可以用 ```try...except...else``` 解决，其中 ```except``` 下的语句退出循环。
```python
x=-1 #初始化累加器x
while True:
    x+=1
    try:
        l[x]
    except:
        break #退出循环
    else:
        if l[x]=='loop':
            for y in range(x+1,len(l)):
                if l[y]=='loop':
                    y=''
                    break #loop后面还有loop，退出当前循环，y为空，后面的if语句不会执行
                if l[y]=='end':
                    break #此时end的下标被储存到y
            if y:
                temp=[] #用列表temp存当前最小循环
                for _ in range(y-x+1): #y-x+1是列表temp的长度
                    te=l.pop(x)
                    if te!='end': #不存end
                    	temp.append(te)
                for z in range(len(temp)): #处理continue和break
                    if temp[z]=='continue':
                        temp=temp[:z] #去掉continue及其后面语句
                        break
                    if temp[z]=='break':
                        temp=temp[2:z] #去掉loop x，break及其后面语句
                        break
                if temp==[]: #如果处理完后列表temp为空，就是说实际上当前最小循环不会对复杂度有贡献
                    l.insert(x,[0]*22) #替代为0
                    l.insert(x,'op') #统一格式
                    x=-1 #重置累加器x从头开始遍历
                    continue
                lo='1' #循环次数为lo
                if temp[0]=='loop': #将loop x的x存到lo
                    lo=temp[1]
                    temp=temp[2:]
                for _ in range(temp.count('op')): #去除列表temp中所有的op
                    temp.remove('op')
                temp=list(map(num_to_list,temp)) #将列表temp中的n和常数全部转成列表，方便后面计算
                tempp=[0]*22 #初始化计算后的列表temp
                if lo.isdigit(): #如果循环次数是常数此时会是一个字符串
                    lo=int(lo)
                    for m in range(22):
                        for n in temp:
                            tempp[m]+=n[m]*lo
                else: #循环次数是n
                    for m in range(22):
                        for n in temp:
                            tempp[m]+=n[m]
                    tempp=tempp[1:]+[0]
                l.insert(x,tempp) #把运算后结果替代当前最小循环
                l.insert(x,'op')
                x=-1 #重置累加器x
```
3. ### 处理结果
题中有说可能会有 ```continue``` 或 ```break``` 不在任何循环内，所以此时列表 l 里可能会有 ```continue``` 或 ```break```，一定有 ```op``` 和至少一个列表(至少一个多项式)，需要去除所有 ```continue``` 和 ```break``` 和 ```op```。
```python
for x in 'break','continue','op':
    for _ in range(l.count(x)):
        l.remove(x)
```
当然也可能有 ```op x``` 不在循环内还未被处理过，所以处理一遍。
```python
l=list(map(num_to_list,l))
```
把列表 l 中所有的列表计算为一个列表 ltemp，然后替换列表 l。
```python
ltemp=[0]*22
for x in range(22):
    for y in l:
        ltemp[x]+=y[x]
l=ltemp
```
4. ### 输出
如果做过 [P2281 [HNOI2003] 多项式的加法和乘法](https://www.luogu.com.cn/problem/P2281) 可能会对你有所帮助。\
先判断列表 l 是否为空，是空的就输出 0，不是就继续。
```python
if all([x==0 for x in l]):
    print(0)
    exit()
```
此时列表 l 已经是降幂。\
**输出时需要注意**


用 $l_n$ 代表列表 l 的第 $n$ 个元素 $(0\le n\le21)$。


- 若 $l_n$ 为 $0$ 则这项不用输出。


- 若 $l_n$ 是列表 l 中第一个非零的元素前面不能输出加号(+)，最后输出的一项最后也不能输出加号。\
如```+60n^2+n+3```或```60n^2+n+3+```或```+60n^2+n+3+```都是错的。


- 若 $l_n=1$ 或 $n=1$ 时应该省略，除非此时 $n=21$。\
如```60n^2+1n+3```或```60n^2+n^1+3```或```60n^2+1n^1+3```都是错的。


```python
flag=False
for x in range(22):
    if l[x]==0: #为0不输出
        continue
    if x==21: #最后一项直接输出
        print(f'+{l[-1]}')
        exit()
    if flag and l[x]!=0: #本项非空就输出加号(+)
        print('+',end='')
    if l[x]>1: #系数大于1就不省略
        print(l[x],end='')
    print('n',end='')
    if x!=20: #次数大于1就不省略
        print(f'^{21-x}',end='')
    if (not flag) and l[x]!=0: #判断是否为是列表l中第一个非0的元素
        flag=True
```
------------
## AC code
```python
l,lpt,edt=[],0,0
while True:
    s=input().split()
    lpt+=s.count('loop')
    edt+=s.count('end')
    l+=s
    if edt>lpt:
        break
l=l[1:-1]
def num_to_list(g):
    if type(g)==list:
        return g
    if g=='n':
        return [0]*20+[1,0]
    else:
        return [0]*21+[int(g)]
x=-1
while True:
    x+=1
    try:
        l[x]
    except:
        break
    else:
        if l[x]=='loop':
            for y in range(x+1,len(l)):
                if l[y]=='loop':
                    y=''
                    break
                if l[y]=='end':
                    break
            if y:
                temp=[]
                for _ in range(y-x+1):
                    te=l.pop(x)
                    if te!='end':
                        temp.append(te)
                for z in range(len(temp)):
                    if temp[z]=='continue':
                        temp=temp[:z]
                        break
                    if temp[z]=='break':
                        temp=temp[2:z]
                        break
                if temp==[]:
                    l.insert(x,[0]*22)
                    l.insert(x,'op')
                    x=-1
                    continue
                lo='1'
                if temp[0]=='loop':
                    lo=temp[1]
                    temp=temp[2:]
                for _ in range(temp.count('op')):
                    temp.remove('op')
                temp=list(map(num_to_list,temp))
                tempp=[0]*22
                if lo.isdigit():
                    lo=int(lo)
                    for m in range(22):
                        for n in temp:
                            tempp[m]+=n[m]*lo
                else:
                    for m in range(22):
                        for n in temp:
                            tempp[m]+=n[m]
                    tempp=tempp[1:]+[0]
                l.insert(x,tempp)
                l.insert(x,'op')
                x=-1
for x in 'break','continue','op':
    for _ in range(l.count(x)):
        l.remove(x)
l=list(map(num_to_list,l))
ltemp=[0]*22
for x in range(22):
    for y in l:
        ltemp[x]+=y[x]
l=ltemp
if all([x==0 for x in l]):
    print(0)
    exit()
flag=False
for x in range(22):
    if l[x]==0:
        continue
    if x==21:
        print(f'+{l[-1]}')
        exit()
    if flag and l[x]!=0:
        print('+',end='')
    if l[x]>1:
        print(l[x],end='')
    print('n',end='')
    if x!=20:
        print(f'^{21-x}',end='')
    if (not flag) and l[x]!=0:
        flag=True
```

---

## 作者：DengDuck (赞：5)

非常好写的 1.24K 递归写法。

我们先用结构体封装一下时间复杂度，重载一下多项式的加法和乘法，这样比较方便。

然后考虑怎么嵌套，我的想法是递归处理。

对于 `begin`：

- `continue` 和 `break` 是 useless 的。
- `op` 对时间复杂度做加法贡献。
- `loop` 得看内部实现，我们向下递归，求出整个 `loop` 的时间复杂度，然后加进我们当前的时间复杂度。

对于 `loop`：

- `continue` 使后面的语句变得 useless。
- `break` 使后面的语句变得 useless，同时整个 `loop` 只会执行一次所以这时候 `loop` 的那个参数就会像个小丑一样 useless 了。
- 又有 `loop` 了，向下递归。

做完之后如果没有 `break` 就乘上 `loop` 的参数，`continue` 和 `break` 的“忽略”显然是可以标记的。

其实这俩玩意实现区别不大，我们再给递归函数加一个参数表示是主函数还是 `loop`，然后就可以一个函数实现所有的求解。


```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int N=35;
struct O
{
	LL A[N];
	O(){memset(A,0,sizeof(A));}
	inline void operator+=(const O&X)
	{
		for(int i=0;i<=30;i++)A[i]+=X.A[i];
	}
	inline void operator*=(const O&X)
	{
		O C;
		for(int i=0;i<=30;i++)
		for(int j=0;j<=i;j++)C.A[i]+=A[j]*X.A[i-j];
		for(int i=0;i<=30;i++)A[i]=C.A[i];
	}
};
string S;
inline O Input()
{
	O Ans;
	cin>>S;
	if('0'<=S[0]&&S[0]<='9')
	{
		LL x=0;
		for(char c:S)x=x*10+c-'0';
		if(x==0) Ans.A[1]=1;
		else Ans.A[0]=x;
	}
	else Ans.A[1]=1;
	return Ans;
}
inline O Work(int x=0)
{
	O Ans,X;
	int Flg=1,Ned=1;
	if(x)X=Input();
	while(1)
	{
		cin>>S;
		if(S=="end")break;
		if(S=="op")
		{
			O t=Input();
			if(Ned)Ans+=t;
		}
		if(x&&S=="continue")Ned=0;
		if(x&&Ned&&S=="break")Ned=Flg=0;
		if(S=="loop")
		{
			O t=Work(1);
			if(Ned)Ans+=t;
		}
	}
	if(x&&Flg)Ans*=X;
	return Ans;
}
int main()
{
	cin>>S;
	O Ans=Work();
	int Low=30,Flg=0;
	for(int i=30;i>=0;i--)if(Ans.A[i]>0)Low=i;
	for(int i=30;i>=0;i--)
	{
		if(!Ans.A[i])continue;
		Flg=1;
		if(Ans.A[i]!=1||i==0)cout<<Ans.A[i];
		if(i>0)
		{	
			cout<<"n";
			if(i>1)cout<<"^"<<i;
		}
		if(i!=Low)cout<<"+";
	}
	if(!Flg)puts("0");
}
```

---

## 作者：Diana773 (赞：3)

# 题意简述
------------
给一段包含 ```loop x end``` ```op x``` ```break``` ```continue``` 四种语句的代码，计算出其精确的时间复杂度（即常数项和系数不忽略）。
  
其中循环语句 ```loop x end``` 相当于循环 ```x``` 次，执行语句 ```op``` 为执行 ```x``` 次操作， ```break``` 为跳出当前循环，```continue``` 为跳过循环中剩余语句， ```x``` 为正整数或 n。循环语句可以嵌套。

# 题目分析及实现
------------
根据题目的数据范围和循环结构嵌套的特点，可以使用两个栈来处理问题。

## 读入

通过函数 ```read()``` 就可以把题目中的所有语句转化为一个整型，方便处理。

#### 参考代码：
```cpp
int read()  
{
	char c;
	while ((c>'z'||c<'a')&&(c<'0'||c>'9'))
	  c=getchar();
      
	int k;
	if ((c>='a')&&(c<='z'))
	{
      if (c=='b') //begin,break返回值
        k=-2;
      if (c=='l') //loop返回值
        k=-3;
      if (c=='n') //n返回值
        k=-4;
      if (c=='c') //continue返回值
        k=-5;
      if (c=='e') //end返回值
        k=-6;
      if (c=='o') //op返回值  
        k=-7;
	  while ((c>='a')&&(c<='z'))
	    c=getchar();
	  return k;
    }

	k=0;
	while ((c>='0')&&(c<='9')) //正整数就返回正整数值
	{
		k=k*10+c-'0';
		c=getchar();
	}
	if (k==0)//修正错误，见https://www.luogu.com.cn/discuss/show/271086
	  k=-4;
 
	return k;
}
```


## 定义变量以及需要使用的函数
 
对于储存操作数的数组 ```a[]``` ， ```a[0]``` 代表时间复杂度多项式次数加 1，而 ```a[i]``` （i>1） 代表多项式的 i-1 次项的系数。

每个栈数组的第一个元素代表栈中元素个数

#### 参考代码：

```cpp
int h,fl=1,css,r34;
int zhanx[50]; //储存loop x中x的栈 
int now[50]; //储存当前循环状态操作数 
int re[50]; //用于乘法操作的一个数组 
int ans[50]; //储存最终答案 
int zhan[50][50]; //zhan[i][j] 储存在第i-1层的操作数的栈 

void add() //将ans加上now 
{
    int g=now[0]>ans[0]?now[0]:ans[0];
	for (int i=1; i<=g; i++)
       ans[i]+=now[0]>=i?now[i]:0;
    ans[0]=g;
}

void add(int as) //将now加上zhan[as]
{
    int g=now[0]>zhan[as][0]?now[0]:zhan[as][0];
	for (int i=1; i<=g; i++)
       now[i]+=zhan[as][0]>=i?zhan[as][i]:0;
    now[0]=g;
}

void cun(int d) //将now暂时储存至zhan[d][]
{
   for (int i=0; i<=now[0]; i++)
     zhan[d][i]=now[i];
}

void addx(int x) //将now加上x (x等于-4时视为n,以下同理) 
{
	if (x<0)
	  now[2]++;
	else
	  now[1]+=x;
	if (now[0]<2)
	  if (now[2]>0)
	     now[0]=2;
	if (now[0]<1)
	  if (now[1]>0)
	     now[0]=1;	  
}

void times(int x) //将now乘上x 
{
	if (now[0]==0)
	  return;	  
	if (x<0)
	{  
	    for (int i=1; i<=now[0]; i++)
	    {
	      re[i]=now[i];
	      now[i]=0;
        }
    
	    for (int i=1+1; i<=now[0]+1; i++)
	      now[i]=re[i-1];
         now[0]+=1;
    }
    else
    {
    	for (int i=1; i<=now[0]; i++)
    	  now[i]*=x;
	}
}

void clera() //清空now 
{
	for (int i=1; i<=now[0]; i++)
	  now[i]=0;
    now[0]=0;
}

void clera(int x) //清空zhan[x] 
{
    for (int i=1; i<=zhan[x][0];i++)
      zhan[x][i]=0;
    zhan[x][0]=0;
}
```
## 核心代码实现
程序读入 ```begin``` 后运行计算复杂度的代码，直到循环嵌套数为 0 且读入到 ```end``` 时结束，开始输出。

#### 对于 ```break``` ```continue``` 语句：
1. 在循环嵌套数为 0 时忽略；
1. 在循环嵌套数大于 0 时要进行一个标记，跳过当前循环剩下的所有语句。

#### 对于 ```loop x``` 语句：
1. 如果处于被跳过状态，不执行，但要注意判断与 ```end``` 的匹配；
1. 将 ```x``` 压入栈 ```zhanx[]``` 中；
1. 如果将要进入第一层循环，需要将 ```now``` 加到 ```ans``` 中，清空 ```now```；
1. 如果将要进入第 d 层的循环 (d>1)，则需要将 ```now``` 暂时储存在 ```zhan[d-1][]```中，再清空 ```now```。

#### 对于 ```op x``` 语句：
1. 如果处于被跳过状态，不执行；
1. 将 ```now``` 加上 ```x```。

#### 对于 ```end``` 语句：
1. 如果处于被跳过状态，不执行，但要注意判断与 ```loop x``` 的匹配；
1. 将栈 ```zhanx[]``` 栈顶元素取出，将 ```now``` 乘上该元素，但对处于 ```break``` 状态的循环不执行乘法操作；
1. 如果将要退出第一层循环，需要将 ```now``` 加到 ```ans``` 中，清空 ```now```，将 ```zhan[1][]``` 退栈；
1. 如果将要退出第 d 层的循环 (d>1)，则需要将 ```now``` 加上 ```zhan[d-1][]```中，再将 ```zhan[d][]``` 退栈；
1. 对最后一个 ```end``` 要记得将 ```now``` 加到 ```ans```。

#### 参考代码：
```cpp
    h=read();		
	do
	{
       h=read(); 
	   if ((h==-6)&&(zhanx[0]==0))
	     break;
	   
	   if ((h==-3)&&(fl>0)) //loop
	   {
	   	  if (zhanx[0]==0) 
	   	  {
			  add();
	   	      clera();
	      }
          else
          {
            cun(zhanx[0]);
            clera();
          }
	      zhanx[0]++;
		  h=read();
		  zhanx[zhanx[0]]=h;	 
		  continue;
	   }
	   else
	     if ((fl<0)&&(h==-3))
	     { 
		   h=read();
	       css++;
	       continue;
	     }

	   
	   if ((h==-5)&&(fl>0)&&(zhanx[0]>0)) //continue;
	   {
	     fl=-5;
	     continue;
	   }
	   
	   if ((h==-2)&&(fl>0)&&(zhanx[0]>0))//break;
	   {
	     fl=-2;
	     continue; 
	   }
	     
	   if ((h==-7)&&(fl>0)) //op
	     {
	     	h=read();	     		    
            addx(h);
	     	continue;
		 }
	   else
	     if ((h==-7)&&(fl<0))
	       {
	       	  h=read();
	       	  continue;
		   }
	   	   
	   if ((h==-6)&&(fl>0)) //end;
	   {
		  r34=zhanx[zhanx[0]];
		  times(r34);		 
          zhanx[0]--;   
		 		 
		  if (zhanx[0]==0)
		  {
		 	 add();
		     clera();
             clera(1);
	      }
          else
          {
             add(zhanx[0]);
             clera(zhanx[0]+1);
          }
	   }
	   else 
	     if ((fl<0)&&(h==-6))
	     {
	     	if (css==0)
	        {
		        r34=zhanx[zhanx[0]];    
                if (fl==-5)
                  times(r34);	    		       			   
			    fl=1;	 
	            zhanx[0]--;							    
				if (zhanx[0]==0)
		        {
		 	       add();
		           clera();
                   clera(1);
	            }  
                else
                {
                   add(zhanx[0]);
                   clera(zhanx[0]+1);
                }
			}
			else
			  css--;
		 }	
		 		 		    
	} while (1);
	add();
```
## 输出
#### 几个注意点 （~~其实就是平时的书写习惯~~）

- 系数为 0 的项不输出
- 对于次数大于 1 且系数为 1 的项，不输出系数
- 次数为 1 的项不输出次数
- 常数项直接输出

#### 参考代码：

```cpp
void sss(int hh) //输出n的hh次项（无系数）
{
	if (hh==1)
	{
	  putchar('n');
	  return;
    }
	if (hh>1)
	{
		putchar('n');
		putchar('^');
		cout<<hh;
	}
 } 
```

```cpp
	int asd=0;
	for (int i=1; i<=ans[0]; i++)
	  if (ans[i]>0)
	  {
	  	asd=i;
	  	break;
	  }
	  
	for (int i=ans[0]; i>=asd; i--)
	  if (i>asd)
	  {
	  	if (ans[i]>0)
	  	{
	  	  if (ans[i]>1)	
	  	    cout<<ans[i];
	  	  sss(i-1);
	  	  putchar('+');
	    }
	  }
	  else
	    {
	    	if (ans[i]>1)
	    	  cout<<ans[i];
	    	if ((i==1)&&(ans[i]==1))
	    	  cout<<ans[i];
	    	sss(i-1);
        }
```

# 总结
------------
调到半夜一点多没调出来，第二天物理课上才想出bug所在，就马上修改代码，然后过了。

挺好的一道模拟题，深刻加深了我对栈的理解。

---

## 作者：YAOhc2012 (赞：2)

~~按题意模拟即可。~~

# 铺垫

## 定义

首先我们先定义结构体，存储多项式的各系数，以及是否碰到了 `break` 语句。

```cpp
struct node
{
    int a[35]={};
    bool flag=false;
};
```

## 重载

重载一下运算符 +，表示两个多项式相加的结果。

```cpp
node operator +(const node &g)const
{
    node y;
    for(int i=25;i>=0;i--)y.a[i]=a[i]+g.a[i];
    y.flag=false;
    return y;
}
```

## 输出
定义一个输出函数，步骤如下：

- 找出所有系数不为零的。

- 如果没有，输出 $0$。

- 系数的输出有两种情况：

  - 系数为 $1$，不输出。

  - 系数不为 $1$，输出系数。

- 次数的输出有三种情况：

  - 常数项，不输出。

  - 一次项，输出 $n$。

  - 其他，正常输出。

- 如果不是最后一个系数为非零数的项，输出 $+$。

```cpp
void write()
{
    vector<int>v;
    for(int i=25;i>=0;i--)
    {
        if(a[i]!=0)v.push_back(i);
    }
    if(v.empty())cout<<0;
    for(int i=0;i<v.size();i++)
    {
        if(v[i]!=0)
        {
            if(a[v[i]]!=1)cout<<a[v[i]];
            if(v[i]!=1)cout<<"n^"<<v[i];
            else cout<<"n";
        }
        else cout<<a[v[i]];
        if(i<v.size()-1)cout<<"+";
    }
}
```

# 正片开始

“一个语句块的结构是**递归定义**的，如下所示。”

既然是递归定义，考虑递归处理。

我们定义一个变量 $point$，记录我们遍历到了字符串的哪里。再定义一个 $ans$，表示得到的时间复杂度。

遇到的语句有以下情况：

- `begin`

直接跳过。

- `end`

返回得到的时间复杂度。

- `op`

检测 `op` 语句后面的是 $n$ 还是数字。

分不同情况加到 $ans$ 里。

- `loop`

先看 `loop` 后面的是 $n$ 还是数字。

处理 `loop` 语句里面的时间复杂度，如果没有碰到 `break` 乘上 $n$ 或数字。

`continue` 和 `break` 比较复杂。

我们要定义一个函数，表示跳出当前循环。

让 $point$，不断往前走，直到碰到 `end` 位置。

```cpp
void be_end()
{
    int cnt=1;
    while(point<=n)
    {
        if(compare("loop"))
        {
            point+=4;
            cnt++;
        }
        if(compare("end"))
        {
            point+=3;
            cnt--;
        }
        if(cnt==0)
        {
            return;
        }
        point++;
    }
}
```

- `continue`

如果不在循环里，忽视。

否则，跳出当前循环并返回时间复杂度。

- `break`

如果不在循环里，忽视。

否则，跳出当前循环、返回时间复杂度并且记录碰到了 `break`。

```cpp
node dfs(int step)
{
    node ans;
    while(point<=n)
    {
        if(compare("begin"))point+=5;
        if(compare("op"))
        {
            point+=2;
            if(s[point]=='n')
            {
                node p;
                p.a[1]=1;
                ans=ans+p;
                point++;
                continue;
            }
            else
            {
                int sum=0;
                while(point<=n&&isdigit(s[point]))
                {
                    sum=sum*10+(s[point]-'0');
                    point++;
                }
                node p;
                p.a[0]=sum;
                ans=ans+p;
            }
        }
        if(compare("loop"))
        {
            point+=4;
            if(s[point]=='n')
            {
                point++;
                node h=dfs(step+1);
                if(h.flag)ans=ans+h;
                else
                {
                    for(int i=26;i>=1;i--)h.a[i]=h.a[i-1];
                    h.a[0]=0;
                    ans=ans+h;
                }
                ans.flag=false;
            }
            else
            {
                int sum=0;
                while(point<n&&isdigit(s[point]))
                {
                    sum=sum*10+(s[point]-'0');
                    point++;
                }
                node h=dfs(step+1);
                if(h.flag)ans=ans+h;
                else 
                {
                    for(int i=0;i<=25;i++)h.a[i]*=sum;
                    ans=ans+h;
                }
                ans.flag=false;
            }
        }
        if(compare("continue"))
        {
            if(step>1)
            {
                point+=8;
                be_end();
                return ans;
            }
            else point+=8;
        }
        if(compare("break"))
        {
            if(step>1)
            {
                point+=5;
                be_end();
                ans.flag=true;
                return ans;
            }
            else point+=5;
        }
        if(compare("end"))
        {
            point+=3;
            return ans;
        }
    }
    return ans;
}
```

# 你们最爱的代码环节

```cpp
#include <bits/stdc++.h>
using namespace std;
int point=1;
int n;
string s,l;
bool compare(string y)
{
    if(y.size()+point-1>n)return false;
    return s.substr(point,y.size())==y;
}
struct node
{
    int a[35]={};
    bool flag=false;
    node operator +(const node &g)const
    {
        node y;
        for(int i=25;i>=0;i--)y.a[i]=a[i]+g.a[i];
        y.flag=false;
        return y;
    }
    void write()
    {
        vector<int>v;
        for(int i=25;i>=0;i--)
        {
            if(a[i]!=0)v.push_back(i);
        }
        if(v.empty())cout<<0;
        for(int i=0;i<v.size();i++)
        {
            if(v[i]!=0)
            {
                if(a[v[i]]!=1)cout<<a[v[i]];
                if(v[i]!=1)cout<<"n^"<<v[i];
                else cout<<"n";
            }
            else cout<<a[v[i]];
            if(i<v.size()-1)cout<<"+";
        }
    }
};
void be_end()
{
    int cnt=1;
    while(point<=n)
    {
        if(compare("loop"))
        {
            point+=4;
            cnt++;
        }
        if(compare("end"))
        {
            point+=3;
            cnt--;
        }
        if(cnt==0)
        {
            return;
        }
        point++;
    }
}
node dfs(int step)
{
    node ans;
    while(point<=n)
    {
        if(compare("begin"))point+=5;
        if(compare("op"))
        {
            point+=2;
            if(s[point]=='n')
            {
                node p;
                p.a[1]=1;
                ans=ans+p;
                point++;
                continue;
            }
            else
            {
                int sum=0;
                while(point<=n&&isdigit(s[point]))
                {
                    sum=sum*10+(s[point]-'0');
                    point++;
                }
                node p;
                p.a[0]=sum;
                ans=ans+p;
            }
        }
        if(compare("loop"))
        {
            point+=4;
            if(s[point]=='n')
            {
                point++;
                node h=dfs(step+1);
                if(h.flag)ans=ans+h;
                else
                {
                    for(int i=26;i>=1;i--)h.a[i]=h.a[i-1];
                    h.a[0]=0;
                    ans=ans+h;
                }
                ans.flag=false;
            }
            else
            {
                int sum=0;
                while(point<n&&isdigit(s[point]))
                {
                    sum=sum*10+(s[point]-'0');
                    point++;
                }
                node h=dfs(step+1);
                if(h.flag)ans=ans+h;
                else 
                {
                    for(int i=0;i<=25;i++)h.a[i]*=sum;
                    ans=ans+h;
                }
                ans.flag=false;
            }
        }
        if(compare("continue"))
        {
            if(step>1)
            {
                point+=8;
                be_end();
                return ans;
            }
            else point+=8;
        }
        if(compare("break"))
        {
            if(step>1)
            {
                point+=5;
                be_end();
                ans.flag=true;
                return ans;
            }
            else point+=5;
        }
        if(compare("end"))
        {
            point+=3;
            return ans;
        }
    }
    return ans;
}
int main()
{
    while(cin>>l)s+=l;
    n=s.size();
    s=" "+s;
    dfs(1).write();
    return 0;
}
```

---

## 作者：lailai0916 (赞：2)

## 原题链接

- [洛谷 P5698 [CTSC1998] 算法复杂度](https://www.luogu.com.cn/problem/P5698)

## 解题思路

### 1. 分析

时间复杂度是一个不超过 $20$ 次的多项式。

用 $f(k)$ 模拟执行 $k$ 次的循环的复杂度。

特别地，令 $k=0$ 表示执行 $n$ 次。

### 2. 计算

考虑计算 $f(k)$ 的复杂度。

初始设多项式 $P=0$。

循环读入字符串 $S$ 并分类讨论：

- $\texttt{end}$：循环结束。

- $\texttt{loop x <statement>}$
  
  递归调用 $f(x)$ 计算 $\texttt{<statement>}$ 的复杂度。
  
  将 $P\gets P+f(x)$。

- $\texttt{op <statement>}$
  
  将 $P\gets P+\texttt{<statement>}$。

- $\texttt{break <statement>}$ 或 $\texttt{continue <statement>}$

  > 如果它（$\texttt{break}$ 或 $\texttt{continue}$）不在任何一层循环中，请忽略它们。
  
  根据循环的嵌套关系，读入并忽略后面的语句。而 $\texttt{break}$ 前的语句只会执行 $1$ 次，即 $k\gets1$。
  
  特别地，如果当前是在最外层的大循环，直接忽略。

此时 $P$ 为循环内的复杂度，一共要执行 $k$ 次，所以该循环的总复杂度为 $P\times k$。

### 3. 输出

倒序遍历多项式的 $i$ 次项：

1. 如果系数 $a_i=0$，不用输出。
2. 如果前面有输出，需要输出 `+`。
3. 对于常数项，输出系数 $a_0$。
3. 对于非常数项，系数 $a_i\not=1$ 时输出 $a_i$；一次项输出 `n`，其余项输出 `n^i`。
  
特别地，如果没有任何输出，需要输出 $0$。
  
## 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=22;
struct Poly
{
	int a[N];
	Poly(){for(int i=0;i<N;i++)a[i]=0;}
};
Poly f(int k,bool b)
{
	Poly P;
	string s;
	while(cin>>s&&s!="end")
	{
		if(s=="loop")
		{
			cin>>s;
			Poly T=f(s=="n"?0:stoi(s),1);
			for(int i=0;i<N;i++)P.a[i]+=T.a[i];
		}
		else if(s=="op")
		{
			cin>>s;
			if(s=="n")P.a[1]++;
			else P.a[0]+=stoi(s);
		}
		else if((s=="continue"||s=="break")&&b)
		{
			if(s=="break")k=1;
			int t=1;
			while(t)
			{
				cin>>s;
				if(s=="loop")t++;
				else if(s=="end")t--;
			}
			break;
		}
	}
	if(k)for(int i=0;i<N;i++)P.a[i]*=k;
	else{for(int i=N-1;i>0;i--)P.a[i]=P.a[i-1];P.a[0]=0;}
	return P;
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	string s;
	cin>>s;
	Poly ans=f(1,0);
	bool b=0;
	for(int i=N-1;i>=0;i--)
	{
		if(ans.a[i]==0)continue;
		if(b)cout<<'+';
		if(i==0||ans.a[i]!=1)cout<<ans.a[i];
		if(i>1)cout<<"n^"<<i;
		else if(i==1)cout<<'n';
		b=1;
	}
	if(!b)cout<<0<<'\n';
	return 0;
}
```

---

## 作者：Milthm (赞：2)

因为打赌模拟赛全班第一就写大模拟，所以就有了这篇题解，加粗部分是我踩的坑。

相对来说不难的一个大模拟，题解区有很多转表达式之类的巧妙做法。但是因为我不会，所以我直接暴力模拟了。

先扫一遍把所有带有 `break` **且前面没有** `continue` 的循环的循环次数全都变成 $1$，顺带预处理每个循环的结尾。

然后扫第二遍暴力模拟，每次循环乘上循环次数，遇到 `op` 就乘上当前累乘的值，放到答案里去。如果遇到 `end` 就把累乘的值除回去。实现可以用重载运算符减少编写难度。遇到 `break` 和 `continue` 就直接跳到循环结尾。

注意数据有可能有多余的 `break` 不属于任何循环，要**判掉**（如果你写的好就不用，我这个就用）。

最后**数据有误**，循环如果循环 $0$ 次要改成 $n$ 次。

如果**没有复杂度**要输出 $0$ 而不是不输出。

### AC code

上面写的很清楚，不加注释了。

```cpp
#include<iostream>
#include<algorithm>
//20:32~21:42
//22:03~22:11
using namespace std;
string s[1005];
int n,st[1005],top,nxt[1005],f,cnt,x,ttq[1005];
struct node{
	int x,power;
}ans[10005],now,st2[10005];
node operator*(node a,node b){
	a.x*=b.x;a.power+=b.power;return a;
}
node operator/(node a,node b){
	if(b.x)a.x/=b.x;a.power-=b.power;return a;
}
int tonum(string s){
	int l=s.size(),sum=0;
	for(int j=0;j<l;++j){
		sum=sum*10+s[j]-'0';
	}
	return sum;
}
int cmp(node o,node o2){
	return o.power>o2.power;
}
int main(){
	now={1,0};
	while(cin>>s[++n]);--n;
	for(int i=1;i<=n;++i){
		if(s[i]=="loop")st[++top]=i; 
		else if(s[i]=="continue")ttq[top]=1;
		else if(s[i]=="break"){
			if(top&&ttq[top]==0)s[st[top]+1]="1";
		}
		else if(s[i]=="end")nxt[st[top]]=i,ttq[top]=0,--top;
	}
	top=0;
	for(int i=1;i<=n;++i){
		if(s[i]=="loop"){
			if(s[i+1]=="n"||s[i+1]=="0")now=now*node{1,1},st2[++top]={1,1};
			else{
				int sum=tonum(s[i+1]); 
				now=now*node{sum,0},st2[++top]={sum,0};
			}
			st[top]=i;
			++i;
		}
		else if(s[i]=="end")now=now/st2[top],--top;
		else if(s[i]=="op"){
			if(s[i+1]=="n")ans[++cnt]=now*node{1,1};
			else ans[++cnt]=now*node{tonum(s[i+1]),0};++i;
		}
		else if(s[i]=="break"||s[i]=="continue"){
			if(top!=0)i=nxt[st[top]]-1;
		}
	}
	sort(ans+1,ans+cnt+1,cmp);
	if(cnt==0)cout<<0;
	ans[cnt+1].power=-1;
	for(int i=1;i<=cnt;++i){
		x+=ans[i].x;
		if(ans[i].power!=ans[i+1].power){
			if(f)cout<<"+";f=1;
			if(x!=1||ans[i].power==0)cout<<x;
			if(ans[i].power>=1)cout<<"n";
			if(ans[i].power>=2)cout<<"^"<<ans[i].power;
			x=0;
		}
	}
	return 0;
}

```







---

## 作者：konyakest (赞：1)

题解好像还没有高斯消元的做法，我来发一个。

具体来说，我们可以先建出表达式树，然后模拟这个过程，带入几个特点的 $n$ 进去计算 ``op`` 运行了多少次，然后用待定系数法的方法进行高斯消元即可。

感觉这种方法可以扩展到有条件语句，或者有循环变量依赖的复杂度分析。

```cpp
#include<bits/stdc++.h>
#define F(i,j,k) for(auto i=j;i<=(decltype(j))(k);i++)
#define exec(...) [&](){__VA_ARGS__}()
#define view(x) begin(x),end(x)
#define pb push_back
#define lambda [&]
#define x first
#define y second
#define endl '\n'
#define os ostream
using namespace std;
using ll=long long;
template<typename T>void ckmin(T& a,T b){a=min(a,b);}
template<typename T>void ckmax(T& a,T b){a=max(a,b);}

vector<string> v;

#define data ctrdygjuhyct

int pos,cnt;

const int mod=1e9+7;

constexpr const char* TypeName[]={
	"BODY","LOOP","OP","BREAK","CONTINUE"
};

struct Tree{
	enum Type{
		BODY,
		LOOP,
		OP,
		BREAK,
		CONTINUE
	}type;
	int val;
	vector<Tree*> son;
	Tree* newNode();
	Tree* build(){
		if(v[pos]=="begin"){
			pos++;
			Tree* node=newNode();
			node->type=BODY;
			while(v[pos]!="end") node->son.pb(build());
			pos++;
			return node;
		}
		if(v[pos]=="loop"){
			pos++;
			Tree* node=newNode();
			node->type=LOOP;
			node->val=v[pos]=="n"?-1:stoi(v[pos]);
			pos++;
			while(v[pos]!="end") node->son.pb(build());
			pos++;
			return node;
		}
		if(v[pos]=="op"){
			pos+=2;
			Tree* node=newNode();
			node->type=OP;
			node->val=v[pos-1]=="n"?-1:stoi(v[pos-1]);
			return node;
		}
		if(v[pos]=="break"||v[pos]=="continue"){
			Tree* node=newNode();
			node->type=(v[pos]=="break"?BREAK:CONTINUE);
			pos++;
			return node;
		}
		__builtin_unreachable();
	}
	void show(string prefix=""){
		cerr<<prefix<<TypeName[type]<<" "<<val<<endl;
		for(auto i:son) i->show(prefix+"    ");
	}
	ll run(int n){
		ll ans=0;
		if(type==BODY){
			for(auto i:son) (ans+=i->run(n))%=mod;
			return ans;
		}
		if(type==OP) return (val==-1?n:val)%mod;
		if(type==LOOP){
			for(auto i:son){
				if(i->type==BREAK) return ans;
				if(i->type==CONTINUE) break;
				(ans+=i->run(n))%=mod;
			}
			return ans*(val==-1?n:val)%mod;
		}
		__builtin_unreachable();
	}
}t;

Tree data[(int)1e6+5];

Tree* Tree::newNode(){return &data[cnt++];}

ll a[25][25];

ll qPow(ll x,int y=mod-2){
	ll ans=1;
	while(y) (y&1)&&(ans=ans*x%mod),x=x*x%mod,y/=2;
	return ans;
}

constexpr int n=22;

void gauss(){
	F(i,1,n){
		F(j,i,n) if(a[j][i]!=0){
			swap(a[i],a[j]);
			break;
		}
		F(j,1,n) if(j!=i){
			ll div=a[j][i]*qPow(a[i][i])%mod;
			F(k,1,n+1) (a[j][k]+=mod-div*a[i][k]%mod)%=mod;
		}
	}
	F(i,1,n) (a[i][n+1]*=qPow(a[i][i]))%=mod;
}

signed main(){
	cin.tie(0)->sync_with_stdio(0);
	string s;
	while(cin>>s) v.pb(s);
	t=*t.build();
	//t.show();,
	F(i,1,n){
		for(int j=n;j>=1;j--) a[i][j]=qPow(i,j-1);
		a[i][n+1]=t.run(i);
	}
	gauss();
	bool flag=0;
	for(int i=n;i>=1;i--) if(a[i][n+1]){
		if(flag) cout<<"+";
		flag=1;
		if(i==1) cout<<a[i][n+1];
		else{
			if(a[i][n+1]!=1) cout<<a[i][n+1];
			cout<<"n";
			if(i!=2) cout<<"^"<<i-1;
		}
	}
	if(!flag) cout<<0;
	cout<<endl;
	return not "FST";
}
```

---

## 作者：Hooch (赞：1)

### 题目大意

给你一个程序，让你算出程序的时间复杂度，还要计算常数。

### 题目思路

这道题可以当做一个递归程序。

因为在一个 ```loop``` 当中，它的算法复杂度递归了下去，接着又回溯回来了。

拿样例做解释：

```
begin loop n loop 3 loop n
op 20
end end end
loop n op 3 break end
loop n loop n
op 1
break
end end
end
```

如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/3xtizvdk.png)

这样递归下去，每次传上来一个执行完循环内容的一个复杂度。

每次遇到 `break` 就将这次循环只执行一次.

每次遇到 `continue` 就只执行 `continue` 之前的操作。

### 代码实现

我们用一个 $p$ 数组来存这一层的时间复杂度。

其中 $p_i$ 表示有几倍的 $n^i$。

接着我们用一个栈来表示这一层的信息。

用一个 $ts$ 变量来储存这一层是否有 `break`。

遇到 `break` 或 `continue`，那么就一直读到关于这一层的 `end`。

[代码](https://www.luogu.com.cn/paste/1uk93ibx)

---

## 作者：Ag2WO4 (赞：0)

这里讲一个高精的做法（首先声明我是用 Python 写的，可能确实对 C/C++ 来说不用写高精不公平，当然可以正常用数组解决）。注意到多项式每项都不超过 $10^9$ 且表达只有加和乘这一点（保证过程不会爆精度），我们可以将答案存储为一个 $2^{32}$ 进制整数（我实际用的是 $2^{30}$ 进制的版本，最节约），并且直接将 $n$ 设定为进制的值，即进一位。

接下来研究一下每个语句的作用：

- ```op``` 就是直接加；
- ```loop``` 就是统计循环内的总值乘以循环次数；
- ```continue``` 跳过对应 ```end``` 语句前的所有语句；
- ```break``` 不仅跳过还强制将本次循环的次数减少到只有一次；
- ```end``` 返回。

模拟，按位输出即可。注意最终字符串的编辑和 $0$ 的特判。
```python
import sys;a=sys.stdin.read().replace('\n',' ').split()[-2:0:-1];b=0;n=1<<30;t=[];u='+'
def f():
    y=eval(a.pop());z=0;x='@'
    while'e'!=x:
        x=a.pop()[0]
        if'o'==x:z+=eval(a.pop())
        if'l'==x:z+=f()
        if'b'==x:
            y=p=1
            while p:
                x=a.pop()[0]
                if'l'==x:p+=1
                if'e'==x:p-=1
        if'c'==x:
            p=1
            while p:
                x=a.pop()[0]
                if'l'==x:p+=1
                if'e'==x:p-=1
    return y*z
while a:
    m=a.pop()[0]
    if'o'==m:b+=eval(a.pop())
    if'l'==m:b+=f()
if b==0:print(0);exit()
while b:t.append(b%n);b//=n
for i in range(len(t)):
    if t[i]:u=f'+{t[i]}n^{i}'+u
print(u.replace('n^0','').replace('+1n','+n').replace('^1+','+').strip('+'))
```

---

## 作者：HYdroKomide (赞：0)

### 题意：

给定一段程序，支持：
- `begin`：程序开头；
- `loop <x>`：循环，$x$ 可为 $n$ 或正整数；
- `end`：标示循环结束或者程序结束；
- `op <x>`：进行 $x$ 次操作，$x$ 可为 $n$ 或正整数；
- `break`：跳出本层循环；
- `continue`：不执行本层循环下方所有操作。

求这段程序一共进行了多少次操作，用多项式表示。

### 思路：
首先，不难发现这个循环嵌套的体系一定基于一个**栈**。

先想没有 `continue` 和 `break` 怎么做。

维护一个幂次变量 $e$ 和一个常数变量 $c$。当扫描到 `loop` 操作时，将其循环次数提取出来，添加到栈中。若循环次数为 $n$，则对 $e$ 进行累加，否则将这个整数乘到 $c$ 中。

当扫描到 `op` 时，直接使用 $e$ 和 $c$ 对答案进行更新。

发现 `end`，直接弹出栈顶，并回退到上一次的 $e$ 和 $c$。

现在想，加上 `continue` 和 `break` 怎么做。

对于 `continue`，直接向后跳进，跳过本层循环后面所有操作直到 `end` 处。**注意一定要确认跳到的 `end` 不是子循环里的。**

对于 `break`，含有 `break` 的循环最多只能执行一次。因此在最开始扫到 `loop` 操作时，就需要独立判断这层循环中是否有 `break`。如果有，将循环次数强制改为 $1$。后面再经过 `break` 时，使用 `continue` 的处理方法即可。

**还需要注意的是，如果 `break` 前有 `continue`，这次 `break` 作废。**

由于需要独立判断是否含有 `break`，因此所有询问必须离线。代码较长，但个人感觉更加易于理解。

### 程序如下：
```cpp
#include<iostream>
#include<stack>
#include<cstring>
using namespace std;
const int N=1005;
int n,e,c=1,ans[N];
string oper[N],str;
stack<int>st;
int toInt(string s){
	int ret=0;
	for(int i=0;i<s.size();i++)ret=ret*10+s[i]-'0';
	return ret;
}
int main(){
	cin>>str;
	while(cin>>oper[++n]);
	for(int i=1;i<=n;i++){
		str=oper[i];
		if(st.empty()&&str[0]=='e')break;
		else if(str[0]=='l'){
			string op=oper[++i];
			int tmpi=i+1,lop=0;//lop存现在到了几层子循环，0代表在本曾
			bool flag=false;
			while(true){//独立判断是否含有break
				string tmpst=oper[tmpi];
				if(lop==0&&(tmpst[0]=='e'||tmpst[0]=='c')){//扫到本层循环的continue或者end，直接返回
					flag=false;
					break;
				}
				else if(lop==0&&tmpst[0]=='b'){//扫到本层循环的break，直接返回
					flag=true;
					break;
				}
				else if(tmpst[0]=='l')lop++;
				else if(tmpst[0]=='e')lop--;
				tmpi++;
			}
			if(flag)st.push(1);
			else if(op[0]=='n'){
				st.push(-1);
				e++;
			}
			else{
				int x=toInt(op);
				st.push(x);
				c*=x;
			}
		}
		else if(str[0]=='o'){
			string op=oper[++i];
			if(op[0]=='n')ans[e+1]+=c;
			else ans[e]+=c*toInt(op);
		}
		else if(str[0]=='e'){
			int x=st.top();
			st.pop();
			if(x==-1)e--;
			else c/=x;
		}
		else{
			if(st.empty())continue;
			int lop=0;
			while(true){
				str=oper[++i];
				if(str[0]=='e'&&lop==0)break;//一定要确认在本层循环里
				else if(str[0]=='e')lop--;
				else if(str[0]=='l')lop++;
			}
			int x=st.top();
			st.pop();
			if(x==-1)e--;
			else c/=x;
		}
	}
	bool first=true;
	for(int i=21;i>=0;i--){//注意指数幂最多能到21
		if(first&&i==0&&ans[i]==0)printf("%d\n",ans[i]);
		if(ans[i]!=0){
			if(first){
				first=false;
				if(i==0)printf("%d",ans[i]);
				else if(i==1){
					if(ans[i]==1)printf("n");
					else printf("%dn",ans[i]);
				}
				else{
					if(ans[i]==1)printf("n^%d",i);
					else printf("%dn^%d",ans[i],i);
				}
			}
			else{
				if(i==0)printf("+%d",ans[i]);
				else if(i==1){
					if(ans[i]==1)printf("+n");
					else printf("+%dn",ans[i]);
				}
				else{
					if(ans[i]==1)printf("+n^%d",i);
					else printf("+%dn^%d",ans[i],i);
				}
			}
		}
	}
	puts("");
	return 0;
}
```

### THE END

---


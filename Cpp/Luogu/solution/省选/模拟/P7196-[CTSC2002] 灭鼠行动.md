# [CTSC2002] 灭鼠行动

## 题目描述

最近，有一些繁殖力很强的老鼠在下水道非常猖獗，灭鼠特工队正在计划消灭这些老鼠。下水道只有东西方向和南北方向的管道，如图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/k86ntxbk.png)

灭鼠特工队的队员拥有强大的武器。他们将在某些时刻 $t$ 在某些位置 $(x,y)$ 放置武器。他们所使用的武器包括：

1. 强力炸弹：它的攻击范围限定在管道内部，是沿竖直和水平方向，离 $(x,y)$ 的距离不超过 $L$ 的区域，但是不能穿透下水道壁。它将在放置之后立刻爆炸，且攻击范围内的老鼠将被全部炸死。

2. 神秘射线：它的攻击范围是以 $(x,y)$ 为圆心，半径为 $R$ 的圆，而且可以穿透下水道壁。射线在时刻 $t$ 施放后，将使攻击范围内的所有老鼠立刻陷入昏迷状态，失去知觉，停止一切生理活动，待到第 $t+3$ 时刻才能恢复（保持失去知觉前的朝向）。如果在昏迷状态中再次受到射线攻击，那么它将再推迟 $3$ 个时刻恢复。例如，若老鼠在时刻 $t$ 和时刻 $t+1$ 个受到一次射线的攻击，则它要昏迷到第 $t+3+3$ 时刻才能恢复知觉。恢复知觉以后，老鼠将继续以前的生理活动。

3. 定时炸弹：它的攻击范围仅包括 $(x,y)$。它在时刻 $t$放置后，将在第 $t+3$ 时刻爆炸，爆炸时处在 $(x,y)$ 点的老鼠将全部被炸死。

4. 生物炸弹：它的攻击范围仅包括 $(x,y)$。它将在放置之后立刻爆炸，使处在 $(x,y)$ 点的所有老鼠的性别改变（无论大小，雌变成雄，雄变成雌），但不影响老鼠的正常生理活动。

虽然特工队的实力很强，但是老鼠的实力也不容忽视。

我们定义，相邻两个时刻之间是一个时间单位。从 $t=0$ 时刻开始，每只老鼠就从初始位置向某一初始方向运动。只要前方有管道，如上图中沿方向 $\texttt{N}$ 到达点 $\texttt{A}$，老鼠就会一直向前走，运动速度为 $1$。否则，如果只有左边或者只有右边有管道，如上图中沿方向 $\texttt{E}$ 到达点 $\texttt{B}$ 时，再不能沿原方向继续前进，它就会花费一个时间单位朝该方向原地转动 $90$ 度，即它将改变方向朝向 $\texttt{S}$。如果它左边和右边都有管道，如上图中沿方向 $\texttt{W}$ 到达点 $\texttt{C}$，老鼠会回忆这是第几次处于这种情况。如果是第奇数次遇到，它会向左转，第偶数次就向右转。如果它处于一条死路的尽头，如上图中沿方向 $\texttt{W}$ 到达点 $\texttt{D}$，那么它会花费两个时间单位连续向右转两次，即它将改变方向朝向E。

   如果在 $t$ 时刻某点恰好只有两只老鼠，一只为成年雄老鼠，一只为成年雌老鼠，则它们将会因为进行繁殖而在该点停留两个单位时间，$t+2$ 时刻会在该点对每个有管道的方向生出一只朝着该方向的小老鼠，南北方向为雄小老鼠，东西方向为雌小老鼠。如上图中的 $\texttt{C}$ 点，$t$ 时刻恰好只有两只老鼠，它们都已成年且性别相异，那么在第 $t+2$ 时刻就会在该点生出三只小老鼠，它们分别朝向 $\texttt{N}$、$\texttt{S}$、$\texttt{E}$，性别分别是雄性、雄性、雌性。小老鼠一出生就立刻开始移动，而成年老鼠需要再休息一个时间单位，即在 $t+3$ 时刻继续活动（两只老鼠都保持生育前的朝向）。小老鼠需要成长 $5$ 个时间单位才会长成为成年老鼠。

   特工队现在制定了一套灭鼠计划，其中包括在下水管道放置武器的位置、时间和类型。你需要帮他们计算灭鼠行动的效果，如果在该计划实施的过程中，老鼠的数量超过了某个限定值，就会爆发鼠疫。

## 说明/提示

### 样例解释

![](https://cdn.luogu.com.cn/upload/image_hosting/lwexoo5d.png)

## 样例 #1

### 输入

```
1 1 3 3
6 14 12
7 15 13
3 11 9
3
1 3 W X
1 2 W X
3 3 S X
3 100
1 1 2 2
3 1 3 1
2 2 3 2
10```

### 输出

```
1```

# 题解

## 作者：Mr_H2T (赞：13)

这道题就是一道大模拟，~~跟那个与猪打牌的题差不多，但是简单一点。~~

-------
主要注意以下细节：

- 岔路的拐弯与当前面对岔路的次数**奇偶性**有关;

- 繁殖出小鼠后老鼠还需等待一单位时间，小鼠可以直接运动;

- 强力炸弹的轨迹是一个**伸展长度为 $L$ 的十字**，而不是距离之和为 $L$ ;

- 射线范围是一个**穿壁的圆形** ;

还有一些隐含的条件，经过不断尝试以及网络搜寻（这里参考了[这篇博客](https://www.cnblogs.com/birchtree/p/14068395.html)）：

- 武器的优先度比老鼠要高，比如某一时刻同时会有出生与神秘射线，应当先响应神秘射线，在 $3$ 个单位时间（或累加）之后再出生小鼠;

- 事实上，死路的转弯朝左或右并无影响（转一次后就变成了另一种带一个拐口的状态，无需我们再加以判断）


- 最为神奇的一个条件，甚至我无法在题面中明确发现：在一次繁殖之后，老鼠必定先运动一下再进行继续繁殖（如果可以）;

还有一个根据题目可推得但是有些奇怪的结论：

- 若繁殖过程中两只老鼠被生物炸弹照射，那么繁殖过程保持不变。这在题目中是显然的，但是有那么一点点奇怪。

以上就是我总结出来比较重要的一些细节。对于时间的运转，我采取的是仿同上文链接给出的，每一秒计算本一秒操作以及下一秒的状态。

UPD：这里附上一个我自己写的[生成数据的代码](https://www.luogu.com.cn/paste/ktb8ufbv)。

具体代码实现见下。

--------

```cpp
#include<bits/stdc++.h>
#define rint register int
#define fu(i,a,b,d,c) for(rint i=a;i<=(b)&&c;i+=d)
#define fd(i,a,b,d,c) for(rint i=a;i>=(b)&&c;i-=d)
using namespace std;
inline int read(){
	char c=0,f=1;int num=0;
	while(c<'0'||c>'9'&&c!='-')((c=getchar())=='-')&&(f=-f);
	while(c>='0'&&c<='9')num=(num<<1)+(num<<3)+(c^48),c=getchar();
	return num*f;
}
#define N 1
#define E 2
#define S 4
#define W 8
#define XY 1
#define XX 2
#define BOMB 1
#define RAY 2
#define T_BOMB 3
#define B_BOMB 4
const int dx[9]={0,-1,0,0,1,0,0,0,0},dy[9]={0,0,1,0,0,0,0,0,-1};
int L,R,n,m,K,Limit,P,TimeLimit,curTime,mouseCnt;
int pipes[55][55];
struct Mouse{
	int age,sex,isProducing,towards,facingCross,x,y,stopTime,produceTime;
	Mouse(){
		age=sex=isProducing=towards=facingCross=x=y=stopTime=produceTime=0;
	}
};
struct Weapon{
	int x,y,type,setTime,occurTime;
	bool operator<(const Weapon b)const{
		return occurTime<b.occurTime;
	}
	Weapon(){
		x=y=type=setTime=occurTime=0;
	}
};
vector <Mouse> mice;
vector <Weapon> weapons;
int weaponPointer=0;
void produceNewMouse(int x,int y){
	Mouse tmp;
	tmp.x=x,tmp.y=y,tmp.age=0;
	if((pipes[x][y]&N)){
		tmp.towards=N,tmp.sex=XY;
		mice.push_back(tmp);
	}
	if((pipes[x][y]&E)){
		tmp.towards=E,tmp.sex=XX;
		mice.push_back(tmp);
	}
	if((pipes[x][y]&S)){
		tmp.towards=S,tmp.sex=XY;
		mice.push_back(tmp);
	}
	if((pipes[x][y]&W)){
		tmp.towards=W,tmp.sex=XX;
		mice.push_back(tmp);
	}
}
void moveMouse(Mouse& mouse){
	int x=mouse.x,y=mouse.y,tow=mouse.towards;
	if(pipes[x][y]&tow){
		mouse.x+=dx[tow];
		mouse.y+=dy[tow];
		return;
	}
	//如题描述 
	if(tow==N||tow==S){
		if((pipes[x][y]&E)&&(pipes[x][y]&W)){
			if(!(mouse.facingCross&1)){
				if(tow==N)mouse.towards=W;
				if(tow==S)mouse.towards=E;
			}else{
				if(tow==N)mouse.towards=E;
				if(tow==S)mouse.towards=W;
			}
			mouse.facingCross++;
		}
		else if((pipes[x][y]&W)&&!(pipes[x][y]&E))mouse.towards=W;
		else if((pipes[x][y]&E)&&!(pipes[x][y]&W))mouse.towards=E;
		else mouse.towards=W;
	}
	if(tow==W||tow==E){
		if((pipes[x][y]&S)&&(pipes[x][y]&N)){
			if(!(mouse.facingCross&1)){
				if(tow==W)mouse.towards=S;
				if(tow==E)mouse.towards=N;
			}else{
				if(tow==W)mouse.towards=N;
				if(tow==E)mouse.towards=S;
			}
			mouse.facingCross++;
		}
		else if((pipes[x][y]&N)&&!(pipes[x][y]&S))mouse.towards=N;
		else if((pipes[x][y]&S)&&!(pipes[x][y]&N))mouse.towards=S;
		else mouse.towards=N;
	}
}
void mouseProduce(Mouse& mouse){
	//需满足条件 1.到达年龄 2.不被眩晕 3.未在进行繁殖  
	if(mouse.stopTime||mouse.produceTime||mouse.isProducing||!(mouse.age>=5))return;
	int atMyPos=0;
	for(rint Mouse2=0;Mouse2<mice.size();Mouse2++)if(mice[Mouse2].x==mouse.x&&mice[Mouse2].y==mouse.y)atMyPos++;
	if(atMyPos!=2)return;
	for(rint Mouse2=0;Mouse2<mice.size();Mouse2++)
	if(mice[Mouse2].x==mouse.x&&mice[Mouse2].y==mouse.y&&!mice[Mouse2].stopTime
	&&!mice[Mouse2].isProducing&&mice[Mouse2].sex!=mouse.sex&&mice[Mouse2].age>=5
	&&!mice[Mouse2].produceTime){
		mouse.produceTime=mice[Mouse2].produceTime=curTime+2,mouse.stopTime=mice[Mouse2].stopTime+=3;
		if(mouse.sex==XX)mouse.isProducing=1;
		else mice[Mouse2].isProducing=1;
		break;
	}
}
void dfsForBD(int x,int y,int dir,int lastlength){
	if(lastlength>L)return;
	for(rint nowMouse=0;nowMouse<(int)mice.size();){
		if(mice[nowMouse].x==x&&mice[nowMouse].y==y)mice.erase(mice.begin()+nowMouse);
		else nowMouse++;
	}
	if(pipes[x][y]&dir)dfsForBD(x+dx[dir],y+dy[dir],dir,lastlength+1);
}
void bombOccur(int x,int y){
	if(pipes[x][y]&N)dfsForBD(x,y,N,0);
	if(pipes[x][y]&E)dfsForBD(x,y,E,0);
	if(pipes[x][y]&S)dfsForBD(x,y,S,0);
	if(pipes[x][y]&W)dfsForBD(x,y,W,0);
}
void rayOccur(int x,int y){
	for(rint nowMouse=0;nowMouse<mice.size();nowMouse++)
	if((mice[nowMouse].x-x)*(mice[nowMouse].x-x)+(mice[nowMouse].y-y)*(mice[nowMouse].y-y)<=R*R)
		mice[nowMouse].stopTime+=3,mice[nowMouse].produceTime+=3;
}
void t_bombOccur(int x,int y){
	for(rint nowMouse=0;nowMouse<mice.size();){
		if(mice[nowMouse].x==x&&mice[nowMouse].y==y)mice.erase(mice.begin()+nowMouse);
		else nowMouse++;
	}
}
void b_bombOccur(int x,int y){
	for(rint nowMouse=0;nowMouse<mice.size();nowMouse++)
	if(mice[nowMouse].x==x&&mice[nowMouse].y==y)mice[nowMouse].sex=3-mice[nowMouse].sex;
}
void weaponAct(){
	while(weaponPointer<weapons.size()&&weapons[weaponPointer].occurTime==curTime){
		Weapon tmp=weapons[weaponPointer];
		if(tmp.type==BOMB)bombOccur(tmp.x,tmp.y);
		else if(tmp.type==RAY)rayOccur(tmp.x,tmp.y);
		else if(tmp.type==T_BOMB)t_bombOccur(tmp.x,tmp.y);
		else if(tmp.type==B_BOMB)b_bombOccur(tmp.x,tmp.y);
		weaponPointer++;
	}
}
void checkOver(){
	if(mice.size()>Limit){
		printf("-1");
		exit(0);
	}
}
signed main(){
	L=read(),R=read(),n=read(),m=read();
	fu(i,1,n,1,1)fu(j,1,m,1,1)pipes[i][j]=read();
	K=read();
	fu(i,1,K,1,1){
		int x,y;char t,s;
		scanf("%d %d %c %c\n",&x,&y,&t,&s);
		Mouse tmp;
		tmp.x=x,tmp.y=y;
		if(t=='N')tmp.towards=N;
		if(t=='E')tmp.towards=E;
		if(t=='S')tmp.towards=S;
		if(t=='W')tmp.towards=W;
		tmp.sex=(s=='X'?XY:XX),tmp.age=5;
		mice.push_back(tmp);
	}
	P=read(),Limit=read();
	fu(i,1,P,1,1){
		int ty=read(),t=read(),x=read(),y=read();
		Weapon tmp;
		tmp.x=x,tmp.y=y,tmp.type=ty,tmp.setTime=t;
		if(ty==T_BOMB)tmp.occurTime=t+3;
		else tmp.occurTime=t;
		weapons.push_back(tmp);
	}
	//按发生时间排序 
	sort(weapons.begin(),weapons.end());
	TimeLimit=read();
	checkOver();
	for(curTime = 0; curTime <= TimeLimit;curTime++){
		//武器运作 
		weaponAct();
		//检查繁殖 
		for(rint nowMouse=0;nowMouse<mice.size();nowMouse++)mouseProduce(mice[nowMouse]);
		//检查出生 
		for(rint nowMouse=0;nowMouse<mice.size();nowMouse++){
			if(mice[nowMouse].produceTime==curTime&&mice[nowMouse].isProducing){
				produceNewMouse(mice[nowMouse].x,mice[nowMouse].y);
				mice[nowMouse].isProducing=0;
			}
		}
		checkOver();//事实上这一句在下文for循环之前或之后均无影响，因为下文只有运动，对答案无贡献
		//计算下一秒的状态，位置 
		for(rint nowMouse=0;nowMouse<mice.size();nowMouse++){
			if(mice[nowMouse].stopTime)mice[nowMouse].stopTime--;
			else mice[nowMouse].age++,mice[nowMouse].produceTime=0,moveMouse(mice[nowMouse]);
		}
	}
	printf("%d",mice.size());
}
```


---

## 作者：TKXZ133 (赞：9)

[灭鼠行动](https://www.luogu.com.cn/problem/P7196)

### 前言

- 只能保证此题解中的代码能通过本题的所有数据，不保证一定能通过所有符合题目给出条件的数据。~~实在不想调了。~~

- 另一份题解中的数据生成器是错的，会给出一些不合法的地图。（比如地图中有 $17$ 和 $25$ 之类的数）

- 本题数据水，一些有比较大的错误的代码也能过。（我的代码没加下文中的第二条细节的特判也能过）

- 我把我的代码和另一份题解中的代码放在一起拍了 $1000$ 组数据，总共出现了十来组不一样的答案，原因主要在昏迷结束后同一位置的老鼠是否能立刻繁殖的问题上，两份代码不一样（我的代码允许，另一份代码会先移动），此处存疑。

### 思路分析

~~按照题意模拟即可。~~

主要看代码。

### 亿些细节

- 每个时刻的优先级应为：武器 > 繁殖 > 出生 > 行动。

- 如果两只老鼠在繁殖期间被炸死，小老鼠不会出生。

- 如果两只老鼠在繁殖期间被转化性别，繁殖过程不变。

- 同一位置有恰好两只老鼠才会考虑繁殖。

- 遇到岔路口时先累加遇到的次数再考虑转向。

- 死胡同只需要转一次就变成了单向岔路的情况。

- 考虑繁殖时需要判断两只老鼠是否都满足所有条件。

- 繁殖休息结束后需要动一下，移动转向都行，但必须动一下。

- 注意时间单位和时刻的端点开闭性。

- 强力炸弹的范围是一个十字，不能穿墙，可以取到 $L$。

- 神秘射线的范围是一个圆形，可以穿墙，可以取到 $R$。

- 如果你使用 `vector`，删除老鼠时注意指针会不会失效。

- 计算时间的优先级应为：昏迷 > 休息 = 成长。

- 注意在生成老鼠和删除老鼠时更新老鼠的数量。

- 不能逐一对每只老鼠进行繁殖和移动判定，应先对所有老鼠走一遍繁殖判定，再对所有老鼠走一遍移动判定。

### 代码

不加注释只有 5.1k，应该算短的了。 

注释写的比较详细，可以看一看。

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <vector>
#include <cmath>

using namespace std;
const int N=200,T=1010;
#define left(x) (((x)+3)%4)//x 的左方向
#define right(x) (((x)+1)%4)//x 的右方向

int L,R,m,n,K,P,Limit,EndTime,Time;//Time 表示当前时刻，其他的是题目给的
int MouseNum,MouseId,in1,in2,in3,in4;//当前老鼠的数量与编号
int road[N][N][4];//0-N北，1-E东，2-S南，3-W西
//road[x][y][z] 表示 (x,y) 的 z 方向能否通行
int vx[]={-1,0,1,0},vy[]={0,1,0,-1},se[]={0,1,0,1};
//vx[i] 表示向 i 方向移动 x 坐标的变化量，vy[i] 同理
//se[i] 表示 i 方向的性别

struct Mouse{
    int x,y;//坐标
    int dir;//方向
    int sex;//性别 0-X雄，1-Y雌
    int coma;//停止昏迷时刻
    int cnt;//第几次遇到转向情况
    int adu;//成年还需的时间
    int rel;//剩余休息的时间
    int move;//是否需要移动再繁殖
}NewM,mo[N];//mo 中储存所有存活过的老鼠，mouse 中储存所有当前存活的老鼠编号

struct Weapon{
    int type;//类型 1-强力炸弹，2-神秘射线，3-定时炸弹，4-生物炸弹
    int tim;//放置时刻
    int x,y;//放置坐标
}we[N];

char inp[5];
vector<int> weatime[T];//weatime[i] 储存 i 时刻需要启动的武器编号
vector<int> mouse,mp[N][N];//mp[x][y] 储存 (x,y) 位置的所有老鼠，这样写起来比较方便，常数也会小一点（？）
vector<int> appear[T];//appear[i] 储存 i 时刻出生的老鼠编号

void bomb(int x,int y,int r){//在 (x,y) 位置爆炸一个半径为 r 的十字炸弹，这里把两种炸弹的爆炸合并了，若是强力炸弹 r=L，若是定时炸弹 r=0
    for(int i=0;i<4;i++)//四个方向
        for(int j=0;j<=r;j++){
            int xx=x+vx[i]*j,yy=y+vy[i]*j;
            if(xx<1||yy<1||xx>m||yy>n) break;//超出地图边界
            if(j&&!road[xx-vx[i]][yy-vy[i]][i]) break;//穿过墙壁
            for(auto it:mp[xx][yy])
                mouse.erase(find(mouse.begin(),mouse.end(),it));//删除编号为 it 的老鼠
            for(int t=Time;t<=Time+2;t++)//删除接下来此处会出生的老鼠
                for(int id=0;id<appear[t].size();){
                    int now=appear[t][id];
                    if(mo[now].x==xx&&mo[now].y==yy)
                        appear[t].erase(find(appear[t].begin(),appear[t].end(),now));
                    else id++;//注意删除的方法
                }
            MouseNum-=mp[xx][yy].size();//更新老鼠数量
            mp[xx][yy].clear();//清空此处老鼠
        }
}

void coma(int x,int y){//在 (x,y) 位置放置神秘射线
    for(auto it:mouse)
        if((mo[it].x-x)*(mo[it].x-x)+(mo[it].y-y)*(mo[it].y-y)<=R*R){//检测半径
            if(mo[it].coma>=Time) mo[it].coma+=3;
            else mo[it].coma=Time+3;//更新昏迷时间，这里写麻烦了
        }
}

void reve(int x,int y){//在 (x,y) 位置放置生物炸弹
    for(auto it:mp[x][y]) mo[it].sex^=1;//反转性别
}

void move(int id){//移动编号为 id 的老鼠
    int &dir=mo[id].dir,&x=mo[id].x,&y=mo[id].y;
    if(road[x][y][dir]){//首先直行
        mp[x][y].erase(find(mp[x][y].begin(),mp[x][y].end(),id));
        x+=vx[dir];y+=vy[dir];//更新坐标
        mp[x][y].push_back(id);//别忘了更新 mp
    }
    else if(road[x][y][left(dir)]&&road[x][y][right(dir)]){//岔路口
        mo[id].cnt++;//先加
        if(mo[id].cnt&1) dir=left(dir);//判断左右移动
        else dir=right(dir);
    }
    else if(road[x][y][left(dir)]||road[x][y][right(dir)]){//单边
        if(road[x][y][left(dir)]) dir=left(dir);
        else dir=right(dir);
    }
    else dir=right(dir);
}

void birth(int id){//繁殖
    if(mo[id].adu||mo[id].rel||mo[id].move) return ;//判断自己的情况
    int x=mo[id].x,y=mo[id].y;
    if(mp[x][y].size()!=2) return ;//恰好两只
    for(auto it:mp[x][y]){
        if(it==id) continue;
        if(mo[it].adu||mo[it].sex==mo[id].sex) continue;//判定合法
        if(mo[it].coma>Time||mo[it].rel||mo[it].move) continue;//判定对方情况
        mo[id].rel=4;mo[it].rel=4;//进入休息，设为 4 是因为这是右开的
        for(int i=0;i<4;i++)//向四个方向生成老鼠
            if(road[x][y][i]){
                MouseId++;
                mo[MouseId]=Mouse{x,y,i,se[i],0,0,5,0};//小老鼠的初始化
                appear[Time+2].push_back(MouseId);
            }
        break;
    }
}

int main(){
    scanf("%d%d%d%d",&L,&R,&m,&n);
    for(int i=1;i<=m;i++)
        for(int j=1;j<=n;j++){
            scanf("%d",&in1);
            if(in1>=8) road[i][j][3]=1,in1-=8;
            if(in1>=4) road[i][j][2]=1,in1-=4;
            if(in1>=2) road[i][j][1]=1,in1-=2;
            if(in1>=1) road[i][j][0]=1,in1-=1;//读入并生成地图
        }
    scanf("%d",&K);
    for(int i=1;i<=K;i++){//生成老鼠
        scanf("%d%d",&in1,&in2);
        NewM.x=in1;NewM.y=in2;
        scanf("%s",inp+1);
        if(inp[1]=='N') NewM.dir=0;
        if(inp[1]=='E') NewM.dir=1;
        if(inp[1]=='S') NewM.dir=2;
        if(inp[1]=='W') NewM.dir=3;//判定方向
        scanf("%s",inp+1);
        if(inp[1]=='X') NewM.sex=0;
        if(inp[1]=='Y') NewM.sex=1;//判定性别
        mouse.push_back(i);//更新老鼠所在
        mp[in1][in2].push_back(i);
        mo[i]=NewM;
    }
    MouseNum=MouseId=K;
    scanf("%d%d",&P,&Limit);
    for(int i=1;i<=P;i++){
        scanf("%d%d%d%d",&in1,&in2,&in3,&in4);
        we[i].type=in1;we[i].tim=in2;
        we[i].x=in3;we[i].y=in4;
        weatime[in2].push_back(i);//更新武器所在
    }
    scanf("%d",&EndTime);
    for(Time=0;Time<=EndTime;Time++){//开始模拟
        for(auto &i:weatime[Time]){//启动 1，2，4 类武器
            if(we[i].type==1) bomb(we[i].x,we[i].y,L);
            if(we[i].type==2) coma(we[i].x,we[i].y);
            if(we[i].type==4) reve(we[i].x,we[i].y);
        }
        for(auto &i:weatime[max(0,Time-3)])//启动 3 时刻前的定时炸弹
            if(we[i].type==3) bomb(we[i].x,we[i].y,0);
        
        for(auto it:mouse){//判定繁殖
            if(mo[it].coma>Time||mo[it].rel||mo[it].move) continue;
            birth(it);
        }
        for(auto it:appear[Time]){//判定生成
            mouse.push_back(it);
            mp[mo[it].x][mo[it].y].push_back(it);//记得加入老鼠所在位置，不然会 RE
            MouseNum++;
        }
        for(auto it:mouse){//更新休息时间
            if(mo[it].coma>Time) continue;
            if(mo[it].rel){
                mo[it].rel--;
                if(!mo[it].rel) mo[it].move=1; 
                continue;
            }
        }
        for(auto it:mouse){//判定移动
            if(mo[it].coma>Time||mo[it].rel) continue; 
            move(it);mo[it].move=0;
            if(mo[it].adu) mo[it].adu--;//更新年龄
        }
        if(MouseNum>Limit){cout<<"-1\n";return 0;}//发生鼠疫
    }
    cout<<MouseNum<<'\n';
    return 0;
}
```

### 其他

2022 年 12 月 23 日 16:40：随机跳题 ing。

2022 年 12 月 23 日 16:50：咦？这道题好有意思，写写看。

2022 年 12 月 23 日 20:30：我写完了，开调。

2022 年 12 月 23 日 21:30：20pts 调不出来了，算了。

2023 年 8 月 6 日 15:10：随机跳题 ing。

2023 年 8 月 6 日 15:20：咦？这道题我怎么见过，开写，看我什么时候写完。

2023 年 8 月 6 日 18:10：我写完了，开调。

2023 年 8 月 7 日 9:20：我调完了。

---

## 作者：fush (赞：3)

## 前言
[更好的阅读体验](https://fush-git.github.io/2024/12/19/洛谷-P7196题解/)。  
其实有很多地方出题人没讲清楚，所以只保证代码可以通过本题数据。  
## 细节
- **神秘射线**是**停止一切生理活动**（包括成长），会暂停，但不会打断繁殖。
- 繁殖后要动一下（包括旋转），才能继续繁殖。
- 顺序：武器 -> 繁殖 -> 移动。
- 注意老鼠刚出生时的年龄。
- 注意**时间单位**和**时刻**的区别。
- 繁殖是某点**恰好**有两只异性老鼠。
- 岔路的拐弯与当前这只老鼠面对岔路的次数**奇偶性**有关。
- 注意实时更新老鼠的数量。
- 我用的是 list 保存老鼠，在删除时要注意指针失效的问题。 
## 代码
也就 3.1KB，一百行左右，是我写的最短紫色模拟题了。  
~~我不会告诉你我猪国杀写了 7.7KB。~~
```c++
#include<bits/stdc++.h>
using namespace std;
#define FL(a, b, c) for(int a = (b), a##end = (c); a <= a##end; a++)
#define FR(a, b, c) for(int a = (b), a##end = (c); a >= a##end; a--)
#define loop(it) for(it = mice.begin(); it != mice.end(); it++)
#define cheakover if(mtot > Max)return cout << -1, 0
#define right(x) ((x << 1) % 15)
#define left(x) ((x ^ 1) ? (x >> 1) : 8)
constexpr int E(2), S(4), W(8), N(1);

struct mouse{
	int sex, x, y, w, age, coma, breed, cnt;
	mouse(int sex, int x, int y, int w):sex(sex), x(x), y(y), w(w){age = coma = breed = cnt = 0;}
	mouse(){}
}d;
list<mouse>mice;
list<mouse>::iterator it, it2;
int mp[60][60], L, R, m, n, mtot, Max, dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};
struct arm{int t, x, y, ty;}li[110];
int lir, lil = 1, vis[60][60];
void micebreed(mouse&a){
	if(a.coma || a.age < 5 || a.breed)return;
	int sum = 0;
	loop(it2)if(it2->x == a.x && it2->y == a.y)sum++;
	if(sum != 2)return;//恰好两只
	loop(it2)if(it2->sex != a.sex && it2->x == a.x && it2->y == a.y){//异性且在一个格子内
		if(it2->age < 5 || it2->coma)return;
		return void(it2->breed = a.breed = 4);
	}
}
void micemove(mouse&a){//移动
	if(a.coma)return void(a.coma--);//昏迷
	if(++a.age, a.breed)return;//是否繁殖
	int &w = a.w, &x = a.x, &y = a.y;
	if(mp[x][y] & w)x += dx[(int)log2(w)], y += dy[(int)log2(w)];//直行
	else if((mp[x][y]&left(w))&&(mp[x][y]&right(w)))//岔路
        w = (((++a.cnt) & 1) ? left(w) : right(w));
	else if(mp[x][y] & left(w))w = left(w);//单边
	else w = right(w);//单边或死路
}
void usearm(arm&a){
	switch(a.ty){
		case 1://强力炸弹
		FL(i, 0, 3)FL(j, 0, L){
			int x1 = a.x + dx[i] * j, y1 = a.y + dy[i] * j;
			if(x1 < 1 || y1 < 1 || x1 > m || y1 > n)break;
			vis[x1][y1] = lil;
			if(!(mp[x1][y1] & (1 << i)))break;
		}
		break;

		case 2://神秘射线
        loop(it2)if((int)(pow(it2->x - a.x, 2) + pow(it2->y - a.y, 2)) <= R * R)it2->coma += 3;
		break;

		case 3:vis[a.x][a.y] = lil;//定时炸弹
		break;

		case 4:loop(it2)if(it2->x == a.x && it2->y == a.y)it2->sex ^= 1;//生物炸弹
	}
    if(a.ty & 1)
        for(it2 = mice.begin(); it2 != mice.end();)
            if(vis[it2->x][it2->y] == lil)mtot--, it2 = mice.erase(it2);
            else it2++;
}
int32_t main(){
	cin.tie(0)->sync_with_stdio(0);
	cin >> L >> R >> m >> n;
	FL(i, 1, m)FL(j, 1, n)cin >> mp[i][j];
	cin >> mtot;
	FL(i, 1, mtot){
		char c;
		cin >> d.x >> d.y >> c;
		d.w = ((c <= 'N') ? (c == 'E' ? E : N) : (c == 'S' ? S : W));
		cin >> c, d.sex = (c == 'X'), d.age = 5, mice.push_back(d);
	}
	cin >> lir >> Max;
	FL(i, 1, lir)cin >> li[i].ty >> li[i].t >> li[i].x >> li[i].y,
        ((li[i].ty == 3) && (li[i].t += 3));//定时炸弹加上爆炸时间
	sort(li + 1, li + 1 + lir, [](arm&i, arm&j){return i.t < j.t;});//暗时刻排序
	int _T_;
	cin >> _T_;
	cheakover;
	FL(T, 0, _T_){
        //使用武器
		while(lil <= lir && li[lil].t == T)usearm(li[lil++]);
        //繁殖
		loop(it)micebreed(*it);
		loop(it){
			if(it->coma || !it->breed)continue;
			if(((--it->breed) == 1) && it->sex)
				FL(j, 0, 3)if((mp[it->x][it->y] >> j & 1) && ++mtot)
						mice.emplace_back(j + 1 & 1, it->x, it->y, 1 << j);
		}
		cheakover;
        //移动
		loop(it)micemove(*it);
		if(!mtot)break;
	}
	cout << mtot;
	return 0;
}
```

---


# [THUPC 2021] 群星连结

## 题目背景

众所周知，群星和公主连结联动啦！联动的结果是一个叫做群星连结的游戏。

这是一个双人回合制竞赛游戏，双方记为 Alice 和 Bob。游戏有若干**回合**，每个回合依次由先手和后手分别行动一次。

现在聪明的你写了一个优秀的 AI 来玩这个游戏，这个 AI 会遵从游戏规则，并且按照游戏过程条目里既定的策略进行游戏。但是由于您太强了，所以世界上只有这么一个 AI，所以只能自己和自己打。

现在给定这个游戏的初始局面，让这个 AI 分别作为 Alice 和 Bob 对战，其中 Alice 先手。你需要模拟游戏过程，并且判断最终是 Alice 获胜还是 Bob 获胜。

游戏初始局面会通过输入给出。

**【提示】**

本题中，**伤害**、**真实伤害**、**生命值扣除**是三个不同的概念，请注意区分。

## 题目描述

#### 基础参数

首先，在游戏开始之前，每个玩家需要选择恰好 $n$ 个角色，并编号 $1,2,3,\dots,n$。

每个角色都有一些基础参数：

1. $HP,hp$ ：最大生命值，生命值；
2. $MP,mp$：最大能量值，能量值；
3. $atk,\Delta_{atk}$：基础攻击力，攻击力增益；
4. $def,\Delta_{def}$：基础防御力，防御力增益；

另外，为方便起见，下文中记 $A=\max(atk+\Delta_{atk},1)$，$D=\max(def+\Delta_{def},0)$。

游戏开始时，生命值 $hp$ 等于最大生命值 $HP$，能量值 $mp$、攻击力增益 $\Delta_{atk}$、防御力增益 $\Delta_{def}$ 均等于 $0$。

$HP,MP,atk,def$ 将由输入给出。

除此之外，每个角色分别拥有一个**天赋**和一个**技能**，分别见**天赋**条目和**技能**条目。

#### 死亡判定

游戏过程的任意时刻，如果某个角色生命值 $hp$ 降到 $0$ **及**以下，则判定该角色【死亡】。

一个角色一旦被判定为【死亡】，则该角色将从场上完全退出，并且生命值被恒定为 $0$，不能通过任何方式回复生命值（即不能起死回生，即使拥有【天赋 — 心胜于物】；另外，也不能通过己方其它角色技能回复生命值），不能普通攻击、发动技能，也不能被选定为优先目标，因而不能被普通攻击。

总之就是不以任何形式参与后续游戏的进程，并且本题中所有“全体”、“所有角色”等词均不包含【死亡】角色。

当某方角色全部被判定【死亡】时，游戏立刻结束，并判定另一方胜利（若此时仍有尚未完成的结算，也全部不再进行）。

#### 参数溢出

在游戏过程的任意时刻，如果某个角色的生命值 $hp>HP$，则 $hp$ 会立刻变成为 $HP$。

在游戏过程的任意时刻，如果某个角色的能量值 $mp>MP$，则 $mp$ 会立刻变成为 $MP$。

#### 优先目标

游戏开始前，每个玩家需要为每个角色选定一个攻击顺序。

具体来说，对编号为 $i$ 的角色，需要确定一个攻击顺序 $p_{i,1},\ldots,p_{i,n}$，满足 $p_{i,1},\ldots,p_{i,n}$ 是一个关于 $1,\ldots,n$ 的排列。

游戏过程的任意时刻，称编号为 $i$ 的优先目标是 $p_{i,j}$，当且仅当 $p_{i,1},\ldots,p_{i,j-1}$ 全部【死亡】，并且 $p_{i,j}$ 没有【死亡】。

#### 普通攻击

普通攻击会对优先目标造成 $A$ 点伤害。

拥有【天赋 — 超凡入圣】的角色则会对优先目标造成 $A$ 点真实伤害。详见**天赋**条目。

拥有【天赋 — 星河力量投射】的角色普通攻击会附加真实伤害。详见**天赋**条目。

#### 天赋

天赋有以下几种类型（每行前的编号为天赋类型的编号，圆括弧 `()` 内部为附加参数）：

0. 【天赋 — 我自闭了】该角色的天赋毫无作用；
1. 【天赋 — 血肉皮囊】该角色免疫一半真实伤害。详情见**生命值扣除环节**条目。  
   **真实伤害见生命值扣除条目**；
2. 【天赋 — 星河力量投射】$(x)$ 该角色每次普通攻击会附加的 $x$ 点真实伤害；
3. 【天赋 — 心胜于物】$(x,y)$ 该角色每次己方行动结束后回复 $x$ 点生命值，并**额外**回复 $y$ 点能量值；
4. 【天赋 — 超凡入圣】该角色的普通攻击被视为真实伤害攻击，即该角色的普通攻击不造成伤害，但造成 $A$ 点真实伤害。
5. 【天赋 — 科技至上】$(x,y)$ 该角色每次进行普通攻击后，回复 $x$ 点生命值；该角色每次发动技能后，**额外**回复 $y$ 点能量值。注意：如果普通攻击或发动技能造成对方全部角色【死亡】，则该角色不再回复生命值或能量值。

本题保证天赋附加参数均为**正**整数（但在输入数据中可能会有 $0$，详情参见**输入格式**条目）。

#### 技能

当某个角色能量值等于其最大能量值时（并且在游戏过程中被选定为发动技能的角色），可以清零其能量值并发动一次技能。

技能有以下几种类型（每行前的编号为技能类型的编号，圆括弧` ()` 内部为附加参数）：

0. 【技能：心态崩了！】该角色的主动技能毫无作用。注意，该技能仍然可以被发动，只不过毫无效果而已。
1. 【技能：格林炸裂！】$(x)$ 对敌方**所有**角色造成 $x$ 点伤害，**然后**使敌方**所有**角色能量值减少 $\left\lfloor\frac{mp_{enemy}}{10}\right\rfloor$，其中 $mp_{enemy}$ 为敌方该角色能量值（即对于每个敌方角色，若其当前的能量值为 $mp_{enemy}$，那么受此技能影响，其能量值会变成 $mp_{enemy}-\left\lfloor\frac{mp_{enemy}}{10}\right\rfloor$）。注意，根据规则，敌方角色会先受到伤害而进入生命值扣除环节，在该环节中回复能量值，然后再被该技能扣除能量值。
2. 【技能：日 (zhou) 昇 (ji) 之 (dao) 雨 (dan)！】对敌方**所有**角色造成 $A$ 点真实伤害。
3. 【技能：天楼霸断剑！】$(x)$ 对敌方**所有**目标造成 $\min\left(\left\lfloor\frac{HP_{enemy}}{10}\right\rfloor,x\times A\right)$ 点伤害，其中 $HP_{enemy}$ 为被攻击目标的最大生命值。
4. 【技能：演出开始！】$(x,y)$ 设当前为第 $t$ 回合，则从发动技能开始，到第 $t+x-1$ 回合结束期间，在己方行动结束时，己方全体角色**额外**回复 $y$ 点能量值。
5. 【技能：天狼噬斩！】$(x)$ 将优先目标的防御力增益减小 $x$，**然后**对优先目标造成 $A$ 点真实伤害。
6. 【技能：地 (太) 球 (虚) 蓝 (苍) 色 (蓝) 闪 (闪) 电！】$(x,y)$ 对优先目标造成 $A$ 点真实伤害。另外，设当前为第 $t$ 回合，则从发动技能开始，到第 $t+x-1$ 回合结束期间，敌方所有角色攻击力增益减小 $y$。
7. 【技能：极光绽放！】$(x,y,z)$ 使己方未【死亡】角色生命值最低（如有多个，则编号最小）的恰好一名角色回复 $z$ 点生命值。另外，设当前为第 $t$ 回合，则从发动技能开始到第 $t+x-1$ 回合结束期间，己方所有角色攻击力增益增大 $y$。
8. 【技能：流星！】$(x,y)$ 对敌方所有角色造成 $A$ 点伤害。设当前为第 $t$ 回合，则**从该技能造成伤害后**，到第 $t+x-1$ 回合结束期间，使敌方所有角色防御力增益减小 $y$。注意，本技能先造成伤害，再产生减益。
9. 【技能：精灵庇护！】$(x,y,z)$ 己方全体角色回复 $z$ 点生命值。设当前为第 $t$ 回合，则从发动技能开始，到第 $t+x-1$ 回合结束期间，己方所有角色防御力增益增大 $y$。
10. 【技能：全力超全开！轮回之终末！】$(x)$ 己方所有角色基础攻击力 $atk$、基础防御力 $def$ 变为原先的两倍 $2\times atk, 2\times def$；未【死亡】角色生命值 $hp$ 变为 $\max\left(\left\lfloor\frac{HP}2\right\rfloor,hp\right)$，能量值 $mp$ 变为 $\max\left(\left\lfloor\frac{MP}2\right\rfloor,mp\right)$；设当前为第 $t$ 回合，则从发动技能开始，到第 $t+x-1$ 回合结束期间，己方行动结束时，己方所有角色**额外**回复 $1$ 点能量值。在第 $t+x-1$ 回合结束时，若敌方仍有角色未【死亡】，则己方全体角色强制生命值清零，并被判定为【死亡】。另外，在发动该技能时，场上所有拥有这个技能的角色（包括自己）的技能将被强制替换为 0 号【技能：心态崩了！】（因此该技能最多在游戏中被发动一次）。

本题保证技能附加参数均为**正**整数（但在输入数据中可能会有 $0$，详情参见**输入**条目）。

注意：上述形如“设当前为第 $t$ 回合，则从发动技能开始到第 $t+x-1$ 回合结束期间，……”产生的效果是**可以叠加**的。

#### 生命回复与能量回复

生命值仅可通过天赋和技能回复。

己方行动结束时，己方全体角色能量值增加 $1$。拥有【天赋 — 心胜于物】的角色，以及受【技能：演出开始！】和【技能：全力超全开！轮回之终末！】影响的角色可以额外回复能量值。

当己方角色进行普通攻击或者发动技能后，该角色能量值增加 $1$。拥有【天赋 — 科技至上】的角色发动技能后会回复额外的能量值。

注意，发动技能时，先扣除全部能量值，再发动技能，然后再增加能量值。

特别的，若该技能为【技能：全力超全开！轮回之终末！】，则使发动该技能的角色 $mp=\max\left(mp,\left\lfloor\frac{MP}2\right\rfloor\right)$ 后再增加能量值。

当己方角色因受到伤害而进入生命值扣除环节时，该角色能量值增加 $1$（无论其是否实际扣除生命值）。

**生命值扣除见生命值扣除环节。**

#### 生命值扣除环节

当角色受到伤害或者真实伤害时，该角色立即进入生命值扣除环节（注意，即使受到了 $0$ 点伤害，也会进入生命值扣除环节）。

进入生命值扣除环节后，由能量回复条目，该角色能量值增加 $1$。

假设其受到 $x$ 点伤害和 $y$ 点真实伤害，那么：

- 若该角色因拥有【天赋—血肉皮囊】而免疫一半真实伤害，则其生命值扣除 $\max(x-D,0)+y-\left\lfloor\frac y2\right\rfloor$。
- 否则，其生命值扣除 $\max(x-D,0)+y$。

#### 游戏过程

游戏开始后，可视为若干回合，编号从 $1$ 开始。

每个回合，可以划分为如下 $5$ 个阶段：Alice 行动（期间）、Alice 行动结束、Bob 行动（期间）、Bob 行动结束、当前回合结束。

己方行动期间，

1. 如果己方存在至少一个角色可以发动技能时，则按照技能编号从大到小的顺序选择其中一位发动技能。如果有多个角色满足可以发动相同编号的技能，则选择这些角色中角色编号最大的角色发动技能。
2. 如果己方没有角色可以发动技能，则选择一个优先目标生命值最高的角色发动普通攻击。如果有多个角色的优先目标生命值最高，则选择能对优先目标扣除更多生命值（而不是造成更多伤害！）的角色发动攻击。如果仍然有多个角色可以选择，则选择其中编号最大的角色发动普通攻击。

己方行动结束。

注意，己方行动期间，仅能选择一位角色发动技能，或者选择一位角色进行普通攻击。

## 说明/提示

**【数据范围】**

$n \le 10$，$HP, MP, atk \gt 0$，$def \ge 0$。

保证在游戏中的任意时刻，所有题面中提及到的参数及表达式的绝对值均不超过 ${10}^9$。

保证游戏在 $23333$ 回合内结束。

**【题目来源】**

来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）。

题解等资源可在 [https://github.com/yylidiw/thupc_2/tree/master](https://github.com/yylidiw/thupc_2/tree/master) 查看。

## 样例 #1

### 输入

```
3
2 8 1 1
1 2 3
3 1 1
7 2 1 2
6 6 3 0
1 2 3
5 1 1
7 2 1 1
99 10 1 1
2 1 3
1 0 0
10 10 0 0
9 10 1 0
1 2 3
2 1 0
8 2 1 0
8 7 2 1
2 1 3
1 0 0
4 2 1 0
99 10 2 0
2 1 3
1 0 0
10 10 0 0
```

### 输出

```
15
Alice
2 0 96 
```

# 题解

## 作者：kyBWE (赞：18)

> [儒略日](https://www.luogu.com.cn/problem/P7075)第114514天，[大美江湖](https://www.luogu.com.cn/problem/P5006)一片异象，月黑风高，[群星连结](https://www.luogu.com.cn/problem/P7610)，正在打[斗地主](https://www.luogu.com.cn/problem/P2668)的人们预感到，这是一个[杀蚂蚁](https://www.luogu.com.cn/problem/P2586)的好日子，这些蚂蚁都是来自[魔兽世界](http://cxsjsx.openjudge.cn/hw202010/A/)的异兽，经过讨论，他们决定继续沿用[灭鼠行动](https://www.luogu.com.cn/problem/P7196)的计划，这个计划是他们与一群专门研究[组合数问题](https://www.luogu.com.cn/problem/P5453)的[鸭棋](https://www.luogu.com.cn/problem/P5380)爱好者共同发明的“[封锁](https://www.luogu.com.cn/problem/P5506)”套路，事实证明，确实有效，当晚，人们凯旋归来，为了纪念这一特殊的日子，他们发明了一种新游戏--[猪国杀](https://www.luogu.com.cn/problem/P2482)。

### 群星连结切后感
群星连结这个题，虽然是个题目很长的尬模拟，但它的思维难度远不及[PCK](https://www.luogu.com.cn/problem/P2482)这么大，只是里面有亿点点细节罢了（结果我还是调了两天......）  

[更好的阅读体验](https://www.luogu.com.cn/blog/486431/wo-yu-qun-xing-lian-jie-di-ai-hen-qing-chou)

### 大体思路
一个字：**模** 。（做好心理准备，我的代码巨长无比）  

我是定义了一个结构体来存每个角色的所有信息，然后分别给  Alice 和 Bob 的角色开了一个大数组（开始写的时候没动脑子，快写完的时候才意识到可以开二维数组，用 $0,1$ 来代表两人，这就导致我的码量多了一倍......），结构体如下：  
```cpp
struct role
{
	int HP,maxHP;//每个角色的血量及血量上限 
	int MP,maxMP;//每个角色的能量及能量上限 
	int atk,delta_atk;//每个角色的基础攻击力和攻击力增益 
	int def,delta_def;//每个角色的基础防御力和防御力增益 
	int talent,talent_x,talent_y;//天赋及附加参数 
	int skill,skill_x,skill_y,skill_z;//技能及附加参数 
	int id,target;//角色编号及当前的攻击目标 
	bool live,player;//是否活着以及属于哪个阵营 
}Alice[15],Bob[15];//1:Alice, 0:Bob
```  
另外，由于优先目标不需要那么多参数，所以我另开了一个小结构体。
```cpp
struct targetrole//用于记录每个角色的优先目标 
{
	int id;//编号 
	bool live;//是否活着 
}Alicep[20][20],Bobp[20][20];
```
然后就可以按照游戏规则一回合一回合的模了。

1. Alice 行动阶段  

能放技能优先放技能，不能放技能就普攻。  

2. Alice 行动结束  

战后回蓝，天赋回血回蓝记得用。

3. Bob 行动阶段

能放技能优先放技能，不能放技能记得普攻。  

4. Bob 行动结束

战后回蓝，天赋回血回蓝记得用。

5. 回合结束阶段

把技能叠加的各种攻击力，防御力buff整理一下。  


------------
对于技能给的各种攻击力，防御力 buff ，我的处理方法是开一个时间线数组，把每回合的 buff 都存起来，然后在回合开始时加上，回合结束后再删去。  

每次有人死了我都会去判一下游戏是否结束，如果结束了立即退出。

前面我说过，因为没动脑子所以给 Alice 和 Bob 各开了一个数组，所以我所有的行动都要给这俩人各写一份（当然如果开二维数组用 $0,1$ 记录人物就不必要这么麻烦了），作为~~懒狗~~的我写完 Alice 之后就复制了一份，改了改名字就给 Bob 了（注意，这里是个**伏笔**）。

这里再说一下，**技能**推荐单独写在一个函数里，**天赋**就穿插在各个阶段里（**别忘了写！！！**）。

（[@Naptie](https://www.luogu.com.cn/user/486119),[@completerich](https://www.luogu.com.cn/user/486397) 血的教训）

### 那些天我们掉进的坑
1. 记录技能发动者、普攻使用者的变量没赋初值，导致数组越界喜提 $5477$ 。  
2. 同样是因为没赋初值导致 Alice 某角色一个普攻打出了高达 $341$ 万的高额伤害。  
3. 函数里的参数一定要加**引用**。
4. 当一名角色死亡后，如果血量被打成负数了，记得变回 $0$ ，否则可能影响结果。
5. 角色死亡后记得把他的生死状态（如果你写了这么个东西的话）改成死，不然一定会出大问题（~~鞭尸也不是什么好行为对吧~~）。
6. 当一名角色受伤后会立即回复一点能量，别写晚了或直接忘了写。
7. 【天赋-血肉皮囊】可免除**一半真实伤害**，别忘了用，也别用错地方。
8. 当一名角色被攻击时，不管会不会扣除生命值，都要回复一点能量。
9. 一定要确保每个角色的优先攻击目标是活着的。
10. 【技能：心态崩了！】虽然没什么卵用，但是也能发动。
11. 当有人发动【技能：格林炸裂！】时，受击角色是先受击回蓝，再受技能效果扣除能量，扣除的是**当前能量**的  $10%$ 。
12. 【技能：天楼霸断剑！】中的 HP enemy 是**最大生命值**，不是当前生命值。
13. 【技能：天狼噬斩！】的防御力减益只针对发动者的优先目标**一人**，而且是**永久性**的。
14. 【技能：全力超全开！轮回之终末！】提升的是**基础攻击力**和**基础防御力**。
15. 【技能：全力超全开！轮回之终末！】发动后记得把**所有人**（包括自己）的技能 $10$ 改成技能 $0$ 。
16. 所有的技能 buff （回蓝，攻击力、防御力加成）都是在技能结束后立即生效，而不是等整个大回合结束，顺序错了很容易 gg 。
17. 用完技能后记得先把能量清空，再进行技能后回蓝。
18. 普攻和技能每回合只能选一个发动，记得判一下放什么。
19. 角色的血量和能量都不能超过上限。
20. 【技能：全力超全开！轮回之终末！】生效的最后一回合要完整的进行完，也就是说是在最后一回合结束后在结束游戏，而不是最后一回合开始。


------------

### 小结
+ 与能量值有关：受击回蓝，己方行动结束回蓝，发动技能或普攻回蓝，【天赋-心胜于物】，【天赋-科技至上】，【技能：格林炸裂！】，【技能：演出开始！】，【技能：全力超全开！轮回之终末！】。

+ 与回复血量值相关：【天赋-心胜于物】，【天赋-科技至上】，【技能：极光绽放！】，【技能：精灵庇护！】，【技能：全力超全开！轮回之终末！】。

+ 只有真实伤害：【天赋-血肉皮囊】（减伤），【天赋-超凡入圣】，【技能：日(zhou)昇(ji)之(dao)雨(dan)！】，【技能：天狼噬斩！】，【技能：地(太)球(虚)蓝(苍)色(蓝)闪(闪)电！】。

+ 只有普通伤害：【技能：格林炸裂！】，【技能：天楼霸断剑！】，【技能：流星！】。

+ 真实伤害加普通伤害：【天赋-星河力量投射】。

+ 与攻击力增/减益相关：【技能：地(太)球(虚)蓝(苍)色(蓝)闪(闪)电！】，【技能：极光绽放！】。

+ 与防御力增/减益相关：【技能：天狼噬斩！】，【技能：流星！】，【技能：精灵庇护！】。

+ 与基础攻击力/防御力相关：【技能：全力超全开！轮回之终末！】。

哪里出了问题可以对照着去看一下对应的部分有没有写挂掉。


------------
### 最后的最后
[巨长无比的代码](https://www.luogu.com.cn/paste/pa0oej3h)  

+ 小彩蛋：还记得前面的伏笔吗？对，技能那部分我复制过来之后少改了一个名字，导致我卡在 $42$ 分死活调不出来（果然学 OI 不需要视力）。 

---

## 作者：Mys_C_K (赞：9)

出题人来冒泡。

基本上没什么坑，写就完事了。

应验题人要求，本题题目原则一律先搞事后结算，因此阶段划分是比较容易的，合理规划后代码结构并不难写。

有一小坑是要死亡瞬间立即终止一切结算结束游戏，也就是有些加血buff不能继续生效，写的不好可能要特判。

附上出题人6k+代码（实际出题过程中加了一对测试输出有10k+（逃））

https://www.luogu.com.cn/paste/2mnv2zro

---

## 作者：Naptie (赞：6)

## 群星连结 Java 版题解

一看题面，发现有很多概念——“玩家”、“角色”、“技能”、“天赋”、“回合”······

第五个概念用一个整型变量维护即可；前四者所含的变量以及之间的关系略微复杂，用结构体/类来维护会好亿点。

想到这里，我就决定[用 Java 写](https://www.luogu.com.cn/discuss/351362)了。

由于你只能在 OJ 上提交单个文件，所以不能像写工程一样开辟多个包和文件来存储多个类——你必须把所有用到的类塞到主类里面去。

因此，我们的代码大概会长这个样子：
```Java
public class Main {

	public static void main(String[] args) {
		// write your code here
	}

	public static class Player {
		public Player() {
		}
	}

	public static class Character {
		public Character() {
		}
	}

	public static class Talent {
		public Talent() {
		}
	}

	public static class Skill {
		public Skill() {
		}
	}

}
```
其中
1. `Player` 类需要维护的变量：
	- 玩家名（`username`）
	- 角色列表（`characterList`）
    
2. `Character` 类需要维护的变量：
	- 编号（`id`）
   - 所属玩家（`player`）
   - $HP,hp,MP,mp,atk,Δ_{atk},def,Δ_{def}$（`maxHP`，`hp`，`maxMP`，`mp`，`atk`，`deltaAtk`，`def`，`deltaDef`）
   - 攻击列表（`attackList`）
   - 天赋（`talent`）
   - 技能（`skill`）
   
3. `Talent` 类需要维护的变量：
	- 编号（`id`）
   - $x,y$ （`x`，`y`）
   
4. `Skill` 类需要维护的变量：
	- 编号（`id`）
   - 所属玩家（`player`）
   - $x,y,z$（`x`，`y`，`z`）
   
然后对其中某些变量创建 get 方法，比如：
```java
String getUsername() {
	return username;
}
```
对部分需要随时赋值的变量创建 set 方法，比如：
```java
void setTalent(Talent talent) {
	this.talent = talent;
}
```

明确框架之后，我们便可以开始写代码了。

---

1. **读入**

	~~一开始不知道 `BufferredReader` 怎么用于是索性 `n = reader.read();` 然后发现输入 `3` 之后 `n ` 被赋成了 `51`~~

	我这里就用 `Scanner` 好了。

	首先是 `n = input.nextInt();`

	然后需要输入 Alice 和 Bob 两个玩家的具体信息，因此我们可以将读入的方法写在 `Player` 类中。

	不过在这之前，记得 `new` 两个实例出来：
	```java
	Player alice = new Player("Alice");
	Player bob = new Player("Bob");
	```

	`Player#readCharacters()` 方法：

	```java
	public void readCharacters() {
		for (int i = 1; i <= n; i++) {
			Character c = new Character(i, this, input.nextInt(), input.nextInt(), input.nextInt(), input.nextInt());
			for (int j = 1; j <= n; j++) {
				c.getAttackList().add(input.nextInt());
			}
			int talent = input.nextInt();
			switch (talent) {
				case 0:
					c.setTalent(new Talent(0, "我自闭了", input.nextInt(), input.nextInt()));
					break;
				case 1:
					c.setTalent(new Talent(1, "血肉皮囊", input.nextInt(), input.nextInt()));
					break;
				case 2:
					c.setTalent(new Talent(2, "星河力量投射", input.nextInt(), input.nextInt()));
					break;
				case 3:
					c.setTalent(new Talent(3, "心胜于物", input.nextInt(), input.nextInt()));
					break;
				case 4:
					c.setTalent(new Talent(4, "超凡入圣", input.nextInt(), input.nextInt()));
					break;
				case 5:
					c.setTalent(new Talent(5, "科技至上", input.nextInt(), input.nextInt()));
					break;
			}
			int skill = input.nextInt();
			switch (skill) {
				case 0:
					c.setSkill(new Skill(0, this, "心态崩了！", input.nextInt(), input.nextInt(), input.nextInt()));
					break;
				case 1:
					c.setSkill(new Skill(1, this, "格林炸裂！", input.nextInt(), input.nextInt(), input.nextInt()));
					break;
				case 2:
					c.setSkill(new Skill(2, this, "日 (zhou) 昇 (ji) 之 (dao) 雨 (dan)！", input.nextInt(), input.nextInt(), input.nextInt()));
					break;
				case 3:
					c.setSkill(new Skill(3, this, "天楼霸断剑！", input.nextInt(), input.nextInt(), input.nextInt()));
					break;
				case 4:
					c.setSkill(new Skill(4, this, "演出开始！", input.nextInt(), input.nextInt(), input.nextInt()));
					break;
				case 5:
					c.setSkill(new Skill(5, this, "天狼噬斩！", input.nextInt(), input.nextInt(), input.nextInt()));
					break;
				case 6:
					c.setSkill(new Skill(6, this, "地 (太) 球 (虚) 蓝 (苍) 色 (蓝) 闪 (闪) 电！", input.nextInt(), input.nextInt(), input.nextInt()));
					break;
				case 7:
					c.setSkill(new Skill(7, this, "极光绽放！", input.nextInt(), input.nextInt(), input.nextInt()));
					break;
				case 8:
					c.setSkill(new Skill(8, this, "流星！", input.nextInt(), input.nextInt(), input.nextInt()));
					break;
				case 9:
					c.setSkill(new Skill(9, this, "精灵庇护！", input.nextInt(), input.nextInt(), input.nextInt()));
					break;
				case 10:
					c.setSkill(new Skill(10, this, "全力超全开！轮回之终末！", input.nextInt(), input.nextInt(), input.nextInt()));
					break;
			}
			characterList.add(c);
		}
	}
	```
	但是太长了，想要短一点的话可以不维护天赋和技能的名字：
	```java
	public void readCharacters() {
		for (int i = 1; i <= n; i++) {
			Character c = new Character(i, this, input.nextInt(), input.nextInt(), input.nextInt(), input.nextInt());
			for (int j = 1; j <= n; j++) {
				c.getAttackList().add(input.nextInt());
			}
			c.setTalent(new Talent(input.nextInt(), input.nextInt(), input.nextInt()));
			c.setSkill(new Skill(input.nextInt(), this, input.nextInt(), input.nextInt(), input.nextInt()));
			characterList.add(c);
		}
	}
	```
	其中，`Character` 的构造器参数分别是：编号，玩家，`maxHP`，`maxMP`，`atk`，`def`；`Talent` 的是：`id`，`x`，`y`；`Skill` 的是：`id`，玩家，`x`，`y`，`z`。
    
完成对 Alice 和 Bob 的角色创建之后，就可以用 $\text{do-while}$ 循环来模拟每一回合了。

```java
do {
	round++;
	alice.play(bob);
	if (gameOver) {
		break;
	}
	bob.play(alice);
	update();
} while (!gameOver);
```

2. **己方发动进攻**

	首先要按照技能编号由大到小将角色列表排序：
   ```java
	characterList.sort((o1, o2) -> {
		if (o1.getSkill().id != o2.getSkill().id) {
			return o2.getSkill().id - o1.getSkill().id;
		} else {
			return o2.id - o1.id;
		}
	});
   ```
   然后遍历角色列表，找到第一个满足技能发动条件的角色（如果所有角色都不能发动技能，则 `skillAvailable` 为 `false`）：
   ```java
	int i = 0;
	boolean skillAvailable = true;
	while (characterList.get(i).isDead() || (characterList.get(i).mp != characterList.get(i).maxMP)) {
		i++;
		if (i == characterList.size()) {
			skillAvailable = false;
			break;
		}
	}
   ```
   如果 `skillAvailable` 为 `true`，则发动技能。这里使用 $\text{switch}$ 语句对每个技能逐一处理即可。**注意**：如果技能是可以持续一定时间的，则需要用到**优先队列**，以**技能的结束时间**为排序关键字，对这类技能进行维护。此外，在发动技能之前需要先将角色的能量值清零，最后再 $+1$；如果角色拥有【天赋 — 科技至上】，则还应额外回复 $y$ 点能量值。
   
   否则，如果 `skillAvailable` 为 `false`，则发动普通攻击。我们需要遍历角色列表，找到优先目标生命值最高的角色发动普通攻击。
   ```java
	character = NULL_CHARACTER;
	Character target = NULL_CHARACTER;
	int maxDamage = target.calcHurt(character.calcNormalAttack());
	for (Character c : characterList) {
		if (c.isDead()) {
			continue;
		}
		Character t = c.getTarget(enemy);
		if (t.hp > target.hp) {
			target = t;
			character = c;
			maxDamage = t.calcHurt(character.calcNormalAttack());
		} else if (target.hp == t.hp) {
			int damage = t.calcHurt(c.calcNormalAttack());
			if (damage > maxDamage) {
				maxDamage = damage;
				target = t;
				character = c;
			} else if (damage == maxDamage) {
				if (c.id > character.id) {
					target = t;
					character = c;
				}
			}
		}
	}
	character.addMP(1);
	target.hurt(maxDamage);
	if (gameOver) {
		return;
	}
	if (character.getTalent().id == 5) {
		character.addHP(character.getTalent().x);
	}
   ```
   这里面用到了许多计算攻击/伤害的方法，无非就是判断该角色有什么天赋，然后返回对应的攻击/伤害值。
   
   己方行动结束之后，应当遍历一遍角色列表，将每个角色的能量值 $+1$，将每个有【天赋 — 心胜于物】的角色回复相应的生命值和能量值。此外，还需要遍历一遍用于维护技能的优先队列，对己方角色的能量值进行相应的更新。
   
当 Alice 行动结束之后，不要忘记判断 Bob 的所有角色是否已全部死亡。如果是，则游戏应当立即结束；如果不是，则继续让 Bob 行动。

3. **回合结算**

	当回合结束后，还需要判断那些正在发挥作用的技能是否即将失效。如果是，则需要将技能所影响到的值都还原回来，并在优先队列中移除。

以上就是对题目做法的分析。个别细节仍需要自己琢磨。关于我那 $13.57 \text{KB}$ 的巨长代码请见[云剪贴板](https://www.luogu.com.cn/paste/ab5vu5j6)。

---

## 作者：I_am_kunzi (赞：5)

# P7610 题解

### 前言

~~写大模拟的题解和写大模拟没啥区别。~~

本题解中关于代码的解释会直接说明是代码的第几行，所以建议将代码放入编辑器后对照着行数进行调试。代码链接：[群星连结源代码](https://www.luogu.com.cn/article/uolotbm5)。

为了方便大家对照着代码进行调试，先给出代码的各部分功能目录：[群星连结代码目录](https://www.luogu.com.cn/article/97w71rqh)。

另外需要注意的是，我代码中的 $ HP $ 并不代表题面中的 $ HP$，$MP $ 也不代表题面中的 $ MP$，这种变量名不统一的情况还有许多。所以当对照着我的代码调试时，请以我代码中变量声明时的注释为准。

### 题目思路

那么接下来我们开始分析这道大模拟。

首先我们分析题面，把一些需要用的定义列出来，方便写代码和再次读题时查询和理解。

+ $A = \max(atk + \Delta_{atk} , 1)$，为了方便起见，下文我们称它为 $ A $ 或攻击力；

+ $D = \max(def + \Delta_{def} , 0)$，为了方便起见，下文我们称它为 $ D $ 或防御力；

+ 题面中的伤害是可以用防御力减少的，而真实伤害无法用防御力减少。为了方便起见，下文我们称伤害为普通伤害或普伤，称真实伤害为真实伤害或真伤；

+ 当生命值 $ hp $ 大于最大生命值 $ HP $ 时，$hp $ 会变为 $ HP$；能量值同样如此。为了与代码格式统一，下文我们称生命值为 $ HP$，最大生命值为 $ maxHP$，能量值为 $ MP$，最大能量值为 $ maxMP$。

那么定义差不多写完了，我们再看一遍题面，理一下怎么实现各模块的代码。

+ 题面一开始就对角色参数做了定义。那么对于角色信息，我们需要开一个结构体来存储；

```cpp
struct character // 角色信息结构体
{
	long long HP , maxHP; // 当前生命 / 最大生命
	long long MP , maxMP; // 当前能量 / 最大能量
	long long atk , Datk; // 初始攻击 / 攻击加成
	long long def , Ddef; // 初始防御 / 防御加成
	long long talent , Xtalent , Ytalent; // 天赋代号 / 天赋参数 x / 天赋参数 y
	long long skill , Xskill , Yskill , Zskill; // 技能代号 / 技能参数 x / 技能参数 y / 技能参数 z
	long long ID , goal; // 角色代号 / 攻击目标
	bool islive; // 是否存活
	long long player; // 对应阵营（Alice = 1 / Bob = 2）
};
```

+ 读到后面两段，我们还发现每个角色都有攻击优先级数组。这个我们可以建一个结构体来存攻击优先级；

```cpp
struct attackgoal // 角色攻击优先级信息
{
	bool islive; // 是否存活
	long long ID; // 角色代号
};
```

+ 再往后读到技能条目，我们发现有增益这种东西，所以我们针对攻击力、防御力、能量回复的增益，分别开三个时间线数组，每个数组开两维，第二维用于分辨这是双方中哪一方的增益；

+ 回到上面的的死亡判定条目，我们需要据此写一个死亡判定的函数。如果角色死了，即 $ HP \le 0$，也应该用这个函数设置一下他的状态：设置死亡状态 $ islive = 0$，生命值重置 $ HP = 0$，当前阵营角色减少一个，还需要在对方的优先级数组上标记当前角色死亡；

+ 依据死亡判定最后一段的说明，我们发现角色死亡可能会导致当前阵营角色变为 $ 0$，进而使得游戏结束，所以我们需要写一个判断游戏结束的函数。如果有一方角色数为 $ 0$，那么对方胜利，将对方每一个角色的生命值重置（可能需要）后输出即可。当然为了代码美观也可以写上当双方角色都为 $ 0 $ 时输出平局（任意表情）；

+ 根据下一段的优先目标条目，我们可以写出一个寻找目标的函数，只需要对着这个角色的优先数组扫一遍，找到第一个活着的对方角色即可（由于当前游戏一定未结束，所以对方一定有活着的角色）；

+ 下一段是对普攻的说明，我们只需要算出当前角色的攻击力，然后分讨三种情况：天赋为超凡入圣，普攻变为真伤；天赋为星河力量投射，普攻附加真伤；天赋不属于这两个，正常造成普伤。我们可以写对于双方分别写两个普攻函数，表示当前角色对优先目标攻击，使其扣除生命值；

+ 但我们当前还没有一个扣除生命值的函数，所以我们往后找到生命扣除条目，先增加能量值，然后分讨两种情况：天赋为血肉皮囊，易得真伤减免量为其一半并下取整，否则正常计算真伤。普伤的计算公式是固定的，我们可以和真伤计算写到一起，也可以分开写；

+ 然后我们再次跳回去看，天赋的生效判定虽然简单，但触发次数多，所以我们把它穿插到代码中，而不是专门写一个函数（写函数也确实不好写）；

+ 然后是技能条目，这一部分我们先不管怎么指定角色为技能释放角色，而是实现一个技能函数即可。代码中我的能量清空是写到主函数的技能释放前面，也可以写到函数里。由于技能较多，而题面中已经描述十分清楚，这里不再描述（具体实现上的问题可见题解开头的代码目录和代码链接、文末的代码调试注意点）；

+ 最后我们看到游戏过程，己方行动期间的技能发动判断较简单，可以直接插到主函数中实现；而普攻还需要计算伤害，所以我们可以对于双方写两个计算当前角色普攻能造成的伤害（只用于计算，而非真的造成伤害），那么对应的，我们也需要写一个用于计算角色受到普伤和真伤而降低生命值量的函数。

这样的话我们处理好整个框架了，还有一些具体的细节需要处理：

+ 受到伤害就一定会进入生命扣除函数，一定会使角色能量增加（如果能量值未满），当然这里的伤害可能为 $ 0$（技能 $ 3 $ 中当敌方 $ maxHP < 10 $ 时会造成 $ 0 $ 点伤害），也是需要进入生命扣除阶段的；

+ 天赋科技至上会根据攻击方式的不同而触发生命回复或能量回复，这点需要穿插入普攻和技能发动后的判断部分；

+ 天赋心胜于物的生命回复和能量回复是额外的，全队的能量加成仍然需要对这个角色处理；

+ 技能发动后需要清空能量值，如果技能函数中没写这一步记得穿插入主函数中；

+ 己方行动结束阶段需要给全员增加一点能量值，还需要处理能量值增益；

+ 放技能后需要更新所有人的增益，因为技能会使增益变化；

+ 需要用变量或另一个数组存下当前的增益，方便放技能后、每回合结束后的增益回溯。

这样的话，代码实现基本就没有问题了。当然如果你真的调不出来，或是感觉代码中有一些不好发现的小错误，可以参照：[群星连结代码注意点](https://www.luogu.com.cn/article/j4x8tqez)。

### 后记

写这种大模拟，重要的是理清思路，看清需要写的具体内容；要认真写代码，及时检查，避免因为小错误去阅读整篇代码好几次；真的有错误应该输出足量的调试信息，找到错误原因，也可以找一篇题解也输出同样的格式对着调（但不要直接交题解）。

其实我第一遍写的时候只有两个错误，第一个是第 $ 109 $ 行的天赋写成了技能；第二个是第 $ 642 $ 行的数组写错了。而这两个错误导致我断断续续调了将近两个月。

所以大家写题一定要仔细啊！

---

## 作者：BMTXLRC (赞：4)

### 代码使用函数含义

- `int fast_read()`：快读；
- `void read(int now)`：读入数据，$now$ 是当前的阵营；
- `void work_gameend(int now)`：输出胜利的一方；
- `void work_break(int now,int p)`：检查 $now$ 这个阵营的第 $p$ 个角色溢出；
- `void work_death(int now,int p)`：检查 $now$ 这个阵营的第 $p$ 个角色是否死亡，如果是则检查是否有一方已经全部阵亡；
- `void work_decrease(int now,int p,int x,int y)`：对 $now$ 这个阵营的第 $p$ 个角色造成 $x$ 点普通伤害与 $y$ 点真实伤害，并检查角色是否死亡；
- `void work_priority(int now)`：将 $now$ 阵营的所有角色更换优先目标；
- `void jn_x(int now,int p)`：$now$ 阵营的第 $p$ 个角色使用技能 $x(0\leqslant x\leqslant 10)$；
- `void work_jn(int now,int p)`：对 $now$ 阵营的第 $p$ 个角色调用其技能函数，还需要进行减少能量与增加能量；
- `int calc(int now,int p,int q)`：计算 $now$ 阵营的 $p$ 能对 $q$ 扣除多少生命值；
- `bool choose_jn(int now)`：找到 $now$ 中可以使用技能的角色；
- `bool choose_pri(int now)`：找到 $now$ 中可以使用普攻的角色；
- `void work_pg(int now,int p,int q)`：使 $now$ 阵营的 $p$ 对 $q$ 发动一次普攻；
- `void work(int now)`：主工作函数，是一方的回合函数；
- `void endwork(int now)`：用于处理一方阵营的结束操作；
- `void work_effect(int now)`：用于处理当前一方的所有状态。

### 代码使用变量含义

- $T$：表示当前是第 $T$ 个回合；
- $n$：表示有 $n$ 个角色；
- $jn_{10}$：表示技能 $10$ 的结算回合；
- $jnfrom_{10}$：表示使用技能 $10$ 的是哪一方；
- （`struct`）$talent$：表示天赋结构体，有 $node,x,y$ 三个成员；
- （`struct`）$jineng$：表示技能结构体，有 $node,x,y,z$ 四个成员；
- （`struct`）$role$：表示角色结构体，有特别多成员，包括一个角色除了效果以外的全部信息；
- （`struct`）$effect$：表示效果结构体，有 $atk,def,mp$ 三个成员，是用来记录时间线的效果状态的。

### 我踩到的坑

- 选择发动普攻角色时，一定是从优先目标生命值最大的角色中选，不是直接选择能扣除生命值最多的角色；
- 发动普攻时，不要忘了给对方回复能量（因为我单独写出来了，原本不方便用 `work_decrease()` 函数，但我后来还是写上了）；
- **记录效果千万不要使用 `vector`！由于未知原因，在你没有犯其他错误的情况下，将 `vector` 套到角色结构体中只有 $19$ pts；**（特别重要）
- **选择发动技能的角色时，初始化的最大值技能变量一定要设为 $-1$！！！！要不然 $0$ 技能无法发动！**（特别重要）

### 我注意到的坑

- 技能 $3$ 中前一项是敌人的**最大生命值**；
- 技能 $4$ 的结算是在己方行动结束时结算的；
- 技能 $7$ 中的最小值变量初始值一定要比 $10^9$ 大，不知道影不影响；
- 计算普攻角色时，一定注意是扣除生命值；
- 发动技能时一定要选择满足技能编号最大的角色；
- 别忘了实时计算每一方的效果。

### 后记

这道题我从去年的大概这个时候就开始打了，熬了一年，反反复复重构过好几次代码，只有这一次是最成功的。

我上一次打 [P7426 [THUPC2017] 体育成绩统计](https://www.luogu.com.cn/problem/P7426) 那一道大模拟，调了好久，也是因为 `vector` 出错了，这次也是。

### 代码

太长了，就放云剪贴板吧。

[这儿](https://www.luogu.com.cn/paste/frmnv1m4)

---

## 作者：fush (赞：3)

[题目链接](https://www.luogu.com.cn/problem/P7610)

## 存储结构
整道题的概念很多，用**结构体**肯定是较好的选择。  
一个表示每个**角色**，一个表示**团队**。  
团队结构体中，$\text{bonus}_{i, 0}$ 表示第 $i$ 个回合的法力值增益，$\text{bonus}_{i, 1}$ 表示攻击力增益，$\text{bonus}_{i, 2}$ 表示防御力增益。

```cpp
struct Race // 角色
{
	int max_hp, hp;			  // 血量，血量上限
	int max_mp, mp;			  // 法力值，法力值上限
	int f_atk, s_atk;		  // 基础攻击力，攻击力增益
	int f_def, s_def;		  // 基础防御力，防御力增益
	int talent, t_x, t_y;	  // 天赋，天赋参数
	int skill, s_x, s_y, s_z; // 技能，技能参数
	int p, id;				  // 优先攻击目标，所属阵营
	bool die;				  // 是否死亡
	int pr[11];				  // 优先攻击顺序
    void cg_hp(int c)         // 更改血量
	{
		hp = Min(hp + c, max_hp);
		hp = Max(0, hp);
		return;
	}
	void cg_mp(int c)         // 更改法力值
	{
		mp = Min(mp + c, max_mp);
		mp = Max(0, mp);
		return;
	}
};
struct Team // 团队
{
	Race ra[11];				  // 团队角色
	int num, id, bonus[43334][4]; // 队伍剩余人数，编号，buff 增益
} t[3];

```
## 准备阶段
读入每个角色的血量上限，法力上限等信息。
```cpp
void input(){			  // 输入角色信息
    scanf("%d%d%d%d", &max_hp, &max_mp, &f_atk, &f_def);
    hp = max_hp, mp = 0, die = 0, s_atk = 0, s_def = 0;
    L(i, 1, n)
        scanf("%d", pr + i);
    scanf("%d%d%d", &talent, &t_x, &t_y);
    scanf("%d%d%d%d", &skill, &s_x, &s_y, &s_z);
}
```
```cpp
void in(){					  // 输入队伍信息
    memset(bonus, 0, sizeof bonus), num = n;
    L(i, 1, n)
    ra[i].input(), ra[i].id = id;
    return;
}
```
```cpp
void input(){
    scanf("%d", &n);
    t[1].id = 1, t[1].in();
    t[2].id = 2, t[2].in();
}
```
## 游戏阶段
游戏阶段是本题的重头戏，坑点众多。下面将会详细讲述。
天赋的效果就穿插在每个阶段。
### 游戏框架
这一段比较简单，因为大部分的功能都封装在了函数中，读懂题意就好了。
```cpp
while (roud <= Round){					        // 回合
    // Alice 回合
    pfgt(t[1], t[2]);                   //处理攻击者、优先攻击目标
    if (sr.skill >= 0) sfgt(t[1], t[2]);//发动技能
    else ofgt(t[1], t[2]);              //发动攻击
    L(i, 1, n) {                        //回蓝、回雪
        if (t[1].ra[i].talent == 3)     //天赋：心胜于物
            t[1].ra[i].cg_hp(t[1].ra[i].t_x), t[1].ra[i].cg_mp(t[1].ra[i].t_y);
        t[1].ra[i].cg_mp(t[1].bonus[roud][0] + 1);
    }
    // Bob回合
    pfgt(t[2], t[1]);
    if (sr.skill >= 0) sfgt(t[2], t[1]);
    else ofgt(t[2], t[1]);
    L(i, 1, n)
    {
      if (t[2].ra[i].talent == 3)
        t[2].ra[i].cg_hp(t[2].ra[i].t_x), t[2].ra[i].cg_mp(t[2].ra[i].t_y);
      t[2].ra[i].cg_mp(t[2].bonus[roud][0] + 1);
    }
    bfgt(t[1]), bfgt(t[2]);            //buff增益
    if (kil == roud)
      over(t[3 - killt]);
    roud++;
}
```
### 攻击函数
一个计算伤害，一个扣除血量，能更方便计算普攻的伤害。
```cpp
int atkdg(Race &defer, int batt, int ratt) // 计算伤害
{
	int D = Max(defer.f_def + defer.s_def, 0);
	if (defer.talent == 1) return -(Max(batt - D, 0) + ratt - ratt / 2);//天赋：血肉皮囊
	else return -(Max(batt - D, 0) + ratt);
}
```
```cpp
void attack(Team &def, Race &defer, int batt, int ratt) // 扣除血量
{
	defer.cg_mp(1);
	defer.cg_hp(atkdg(defer, batt, ratt));
	def.num -= defer.did();
	if (!def.num) over(t[3 - def.id]);
	return;
}
```
### 处理攻击者
我们可以一起处理技能、普攻、每个人的优先攻击目标。
```cpp
struct Satk // 发动技能的人
{
	int skill, id;//技能编号，使用者编号
} sr;
struct Patk // 发动普攻的人
{
	int p, id, atkhp, hp;//被攻击目标，攻击者编号，伤害，被攻击者的血量
} pr;
void pfgt(Team &atk, Team &def) // 确定技能与普攻的人
{
	pr.hp = -1, pr.atkhp = 10;    // 普攻使用者
	sr.skill = -1;                // 技能使用者
	L(i, 1, n)
	{
		Race atker = atk.ra[i];
		if (atker.die) continue;
		int k = choose(def, atk.ra[i]);  // 确定每个人的优先目标
		atk.ra[i].p = k;
		int dhp = def.ra[k].hp, ahp;
		if (dhp >= pr.hp)
		{
			int A = atker.f_atk + atker.s_atk;  // 计算普攻伤害

			if (atker.talent == 4) ahp = atkdg(def.ra[k], 0, A);//天赋：超凡入圣
			else ahp = atkdg(def.ra[k], A, 0);
			if (atker.talent == 2) ahp += atkdg(def.ra[k], 0, atker.t_x);//天赋：星河力量投射

			if (dhp > pr.hp) pr.atkhp = ahp, pr.p = k, pr.id = i, pr.hp = dhp;
			else if (ahp <= pr.atkhp) pr.atkhp = ahp, pr.p = k, pr.id = i, pr.hp = dhp;
		}

		if (atker.skill >= sr.skill && atker.mp == atker.max_mp)
			sr.skill = atker.skill, sr.id = i;
	}
	return;
}
```
### 技能效果
这一部分可以说是整道题中最重要的部分之一。  
要注意 buff 的增益，攻击力和防御力的 buff 可以在触发时就加上，等到增益结束再减去。如果 buff 的持续时间超过最大回合，就不用继续添加了  
10 号技能翻倍的时**基础攻击力**和**基础防御力**千万不要写错了。
```cpp
void sfgt(Team &atk, Team &def) // 技能
{
	int idp = sr.id;
	Race atker = atk.ra[idp];
	assert(atker.mp == atker.max_mp);
	int A = Max(atker.f_atk + atker.s_atk, 1);
	atk.ra[idp].mp = 0;
	int x = atker.s_x, y = atker.s_y, z = atker.s_z;

	if (atker.skill == 1) // 格林炸裂！
	{
		L(i, 1, n)
		if (!def.ra[i].die)
			attack(def, def.ra[i], x, 0), def.ra[i].cg_mp(-def.ra[i].mp / 10);
	}
	if (atker.skill == 2) // 日昇之雨！
	{
		L(i, 1, n)
		if (!def.ra[i].die)
			attack(def, def.ra[i], 0, A);
	}
	if (atker.skill == 3) // 天楼霸断剑！
	{
		L(i, 1, n)
		if (!def.ra[i].die)
			attack(def, def.ra[i], Min(def.ra[i].max_hp / 10, x * A), 0);
	}
	if (atker.skill == 4) // 演出开始！
		L(i, roud, Min(roud + x - 1, Round))
			atk.bonus[i][0] += y;
	if (atker.skill == 5) // 天狼噬斩！
	{
		int pr = atker.p;
		def.ra[pr].s_def -= x;
		attack(def, def.ra[pr], 0, A);
	}
	if (atker.skill == 6) // 地(太)球(虚)蓝(苍)色(蓝)闪(闪)电！
	{
		int pr = atker.p;
		attack(def, def.ra[pr], 0, A);
		L(i, 1, n)
		def.ra[i].s_atk -= y;
		def.bonus[Min(roud + x - 1, Round)][1] += y;
	}
	if (atker.skill == 7) // 极光绽放！
	{
		int Min_hp = 1e9 + 10, mi;
		L(i, 1, n)
		{
			if (!atk.ra[i].die && Min_hp > atk.ra[i].hp)
				Min_hp = atk.ra[i].hp, mi = i;
			atk.ra[i].s_atk += y;
		}
		atk.ra[mi].cg_hp(z);
		atk.bonus[Min(roud + x - 1, Round)][1] -= y;
	}
	if (atker.skill == 8) // 流星！
	{
		L(i, 1, n)
		{
			attack(def, def.ra[i], A, 0);
			def.ra[i].s_def -= y;
		}
		def.bonus[Min(roud + x - 1, Round)][2] += y;
	}
	if (atker.skill == 9) // 精灵庇护！
	{
		L(i, 1, n)
		atk.ra[i].cg_hp(z), atk.ra[i].s_def += y;
		atk.bonus[Min(roud + x - 1, Round)][2] -= y;
	}
	if (atker.skill == 10) // 全力超全开！轮回之终末！
	{
		L(i, 1, n)
		{
			if (atk.ra[i].skill == 10) atk.ra[i].skill = 0;
			if (def.ra[i].skill == 10) def.ra[i].skill = 0;
			atk.ra[i].f_atk *= 2, atk.ra[i].f_def *= 2;
			atk.ra[i].hp = Max(atk.ra[i].hp, atk.ra[i].max_hp / 2);
			atk.ra[i].mp = Max(atk.ra[i].mp, atk.ra[i].max_mp / 2);
		}
		L(i, roud, Min(roud + x - 1, Round))
			atk.bonus[i][0]++;
		kil = roud + x - 1, killt = atk.id;
	}
	atk.ra[idp].cg_mp(1);
	if (atker.talent == 5)//天赋：科技至上
		atk.ra[idp].cg_mp(atker.t_y);
	return;
}
```
### 普通攻击
这部分不难实现，要注意血量的扣除，不要写错。
```cpp
void ofgt(Team &atk, Team &def){ // 普攻
	int p = pr.p;
	def.ra[p].cg_mp(1);
	def.ra[p].cg_hp(pr.atkhp);
	def.num -= def.ra[p].did();
	if (!def.num) over(atk);
	if (atk.ra[pr.id].talent == 5)//天赋：科技至上
		atk.ra[pr.id].cg_hp(atk.ra[pr.id].t_x);
	atk.ra[pr.id].cg_mp(1);
}
```
### 处理buff增益
在每一个回合结束处理就好了。
```cpp
}
void bfgt(Team &T) { // buff计算
	L(i, 1, n)
	{
		T.ra[i].s_atk += T.bonus[roud][1];
		T.ra[i].s_def += T.bonus[roud][2];
	}
}
```
### 结束与死亡判断
```cpp
void over(Team &win) // 结束
{
	printf("%d\n", roud);
	if (win.id == 1) puts("Alice");
	else puts("Bob");
	L(i, 1, n)
	if (win.ra[i].die) printf("0 ");
	else printf("%d ", win.ra[i].hp);
	putchar('\n');
	exit(0);
}
```
如果已经有一方输了，会直接结束！！！
```cpp
int did() // 死亡判断
	{
		if (!die && hp <= 0)
		{
			hp = 0, die = 1;
			return 1;
		}
		return 0;
	}
```

## 后记
我自己掉的坑:
- buff 的效果看错了，加攻击力写成加防御力。
- $mp$ 和 $hp$ 写错。
  
其他要注意的点：
- 选择攻击者的**判断顺序**。
- 选择**技能攻击者**是一定要**初始设为** $-1$ 不然 $0$ 号技能就可能不能使用了。
- $A = \max(\text{atk} + \Delta{\text{atk}}, 1)$，$D = \max(\text{def} + \Delta{\text{def}}, 0)$，不要把中间的 $1$ 和 $0$ 写错。
- 调用**函数**时，如果有**结构体的参数**，要用引用的方式，不然容易 TLE。

## 完整代码
我的 $300$ 行超长代码就放在云剪贴板了。  
[提交记录](https://www.luogu.com.cn/record/175908886)   
[代码](https://www.luogu.com.cn/paste/ijxuzhz9)  
如果有人不理解代码中的函数、变量的意思，可以私信[我](https://www.luogu.com.cn/user/755820)。

---

## 作者：xhz123456789 (赞：3)

# 思路

## 天赋

对于不同的天赋，改变了角色很多不同的行为，所以我们定义基类 `character` 并将接口声明为虚函数（函数实现详见 AC 代码）：

```cpp
class character{
    private:
    protected:
    static ll cnt_id;
    ll id;
    ll talent_x,talent_y;
    bool is_die_;
    skill*s;
    std::queue<character*>attack_order;
    public:
    ll hp,mhp,mp,mmp,atk,datk,def,ddef;
    team *self_team,*enemy_team;
    character(){
        id=cnt_id++;
    }
    inline ll A(){return std::max(atk+datk,1ll);}
    inline ll D(){return std::max(def+ddef,0ll);}
    friend class character_init_;
    friend class skill;
    inline ll get_id();ine void print_info();
    virtual ll get_talent_id()=0;
    //hp:
    virtual void die();
    virtual ll get_hp();
    virtual void de_hp(ll dhp);
    virtual ll get_de_hp(ll damage,ll real_damage);
    virtual void add_hp(ll dhp);
    inline bool is_die();
    //mp
    virtual ll get_mp();
    inline void de_mp(ll dmp);
    virtual void add_mp(ll dmp);
    //skill
    inline void set_skill(skill*s_);
    inline const skill* get_skill();
    virtual bool can_use_skill();
    virtual void use_skill();
    //attack
    virtual character* get_attack_target();
    virtual ll get_attack_de_hp();
    virtual ll get_attack_target_hp();
    virtual void attack();
    //other
    virtual void after_action();
};
```

然后在不同天赋的派生类中重载被改变的接口。

如天赋 1：

```cpp
class character_talent_1:public character{
    virtual ll get_talent_id(){
        return 1;
    }
    virtual ll get_de_hp(ll damage,ll real_damage){                     //talent#1 该角色免疫一半真实伤害
        return std::max(damage-D(),0ll)+real_damage-(real_damage>>1);
    }
};
```

## 技能

定义接口 `skill`:

```cpp
class skill{
    protected:
    ll x,y,z;
    public:
    skill(ll x_,ll y_,ll z_){
        x=x_;
        y=y_;
        z=z_;
    }
    virtual ll get_skill_id()const=0;//获得编号
    virtual void run(character*)=0;//使用技能
    virtual ~skill(){}
};
```

在派生类中重载 `run(character*)` 和 `get_skill_id()` 如技能 0：

```cpp
class skill_0:public skill{
    /*
    skill#0:
    该角色的主动技能毫无作用
    */
    public:
    skill_0(ll x_,ll y_,ll z_):skill(x_,y_,z_){};
    virtual ll get_skill_id()const{
        return 0;
    }
    virtual void run(character*self){

    }
};
```

然后对于“到第 $t+x−1$ 回合结束期间”我们添加事件系统。

首先事件的回调函数需要一个统一的接口：

```cpp
struct callback{
    virtual void run()=0;
    virtual ~callback(){};
};
```

定义接口 `event`：

```cpp
struct event{
    virtual void attach(callback*)=0;
    virtual void tigger()=0;
};
```

接下来我们来实现事件类:

```cpp
class event_once:event{//只会触发一次的事件
    private:
    std::queue<callback*> callbacks;
    public:
    virtual void attach(callback*c){
        callbacks.push(c);
    }
    virtual void tigger(){
        for(;!callbacks.empty();callbacks.pop()) callbacks.front()->run(),delete callbacks.front();
        //由于只触发一次，所以在触发后立即释放回调函数对象
    }
};
```

# 游戏结束

在游戏结束时，需要立即停止计算，所以我们使用异常处理来结束游戏。

首先自定义异常 `game_over_exeception`:

```cpp
class game_over_exeception:public std::exception{
    private:
    team*t;
    public:
    game_over_exeception():t(NULL){}
    game_over_exeception(team*t_){
        t=t_;
    }
    const team* get_team()const noexcept{
        return t;
    }
};
```

然后只要在 `main()` 中捕获异常即可：

```cpp
try{
    while(true){
        g.play();
    }
}catch(game_over_exeception&err){
    if(err.get_team()){//判断是有队伍胜利还是达到回合上限
        std::cout<<g.get_cnt_round()<<"\n"<<err.get_team()->get_team_name()<<"\n";
        for(auto i:err.get_team()->get_all_characters()) std::cout<<i->get_hp()<<' ';
    }else{
        std::cout<<"...";
    }
}
```

# 坑点

## 遍历所有角色

使用如下代码遍历所以角色可能 RE：

```cpp
for(auto i:team->get_alive_characters()){
    /*do_something*/
}
```

下面开始分析

在遍历时可能会直接或间接有对角色减少血量的操作，于是 `de_hp(ll)` 会被调用。

```cpp
void character::de_hp(ll dhp){
    hp-=dhp;
    if(hp<=0){
        die();
    }else{
        add_mp(1ll);
    };
}
```

如果角色血量不足则会调用 `die()`。

```cpp
inline void character::die(){
    is_die_=true;
    hp=0;
    self_team->update_alive_characters();
}
```

然后 `die()` 则会调用 `update_alive_characters()` 来更新角色列表。

在 `update_alive_characters()` 中，会使用 `alive_characters.erase(iter)` 从列表中删除死亡角色的指针。

在使用 `for(auto i:team->get_alive_characters())` 时，相当于使用：

```cpp
for(auto iter=team->get_alive_characters().begin(),end=team->get_alive_characters().end();iter!=end;iter++){
    auto &i=*iter();
}
```

然后 `i->de_hp()` 被调用，如果血量不足则会调用 `i->die()` 然后 `team->update_alive_characters()` 则会删除其指针，恰好是 `iter` 迭代器指向的元素，此时 `iter++` 则会 RE。

所以要使用如下代码遍历：

```cpp
for(auto i=self->enemy_team->get_alive_characters().begin(),e=self->enemy_team->get_alive_characters().end(),t=i;i!=e;t=i){
    i++;
    /*do_something*/
}
```

## 编码时仔细检查

比如在将前一个技能的代码复制给后一个技能后，一定要看看有没有遗漏（技能 6 造成伤害时不要像技能 5 减防御增益）。

## AC 代码

见[云剪贴板](https://www.luogu.com.cn/paste/1yob7que)。

---

## 作者：AsunderSquall (赞：3)

读题+写题花了 2h40min，调试花了 2h20min。  
其实大模拟题没什么题解好说的，随便说一点吧。

-----------

看完题目后感觉比较麻烦的地方就是技能造成的增益有回合数限制。  
我的写法是先加上，然后在应该结束的回合标记一下，到了那个时候再减去。

--------------

**我掉进过的坑**  
1. 打错字母（比如 `A` 和 `X` 打反之类的）。  
2. 真实伤害和伤害搞混。  
3. 选取优先级最高的角色的时候，忘记将与之比较的数覆盖了（捂脸）。  
4. 以为第 10 个技能不需要清 `mp`。  

**[同学](https://www.luogu.com.cn/record/53093111)掉进的坑**  
1. 和上限取 min 时 min 打成 max。  
2. 寻找攻击对象时把下标当作具体值。  
3. 把技能8的伤害当成真实伤害。  
4. 把技能效果结束的效果的累加当成赋值。  
5. 判断技能效果结束的数组开小（只RE了一个点）。  

**我注意到的其他坑点**  
1. 使用技能 1 的时候，给对方造成伤害之后要和 `MP` 取 $\min$，不然最后算出来的 `mp` 可能会多一点。  
2. 每一个人的结束后最好都判一下 `hp` 有没有超过上限啥的   
3. 技能效果的标记可能会超过 23333，数组开大一点或者直接判掉。

--------



然后放一下我的代码吧，带了一点点注释  
<https://www.luogu.com.cn/paste/ryqo1tmj>


---

## 作者：yzh_Error404 (赞：2)

调了差不多一周然后发现题目读错了（

应该没有人是像我一样把所有技能都放到主函数里的吧。

一些需要注意的点：

1. 增益减益要及时给到对应的人身上
2. 搞清楚每个技能是对应那些人（比如说我开始以为10技能的血量和蓝量的更改是对于所有人的，调了两天的47分）
3. 可以开一个 $eff$ 数组来记录每一回合的增益和减益，但是要注意区间的末尾是否在 $23333$ 回合内，需要特判一下

[18k的代码](https://www.luogu.com.cn/paste/5z2mbp1n)

---

## 作者：NATO (赞：2)

本题在解法上没有什么可讲的，模拟就行了，在此提几点注意事项。

### 注意事项&建议：

1. 虽然题目说明了一个角色一旦被判定为【死亡】，则该角色将从场上**完全退出**，但是，已经发动的未结束的持续性技能（技能四、技能六、技能七、技能八、技能九、技能十）仍然生效，直到 ```t+x−1``` 回合为止。

2. 记得给被判定【死亡】的角色打上标记，避免再次扣血或回蓝。

3. 一定要在每次扣除血量后判断游戏是否结束，避免血量错误。

4. 寻找发动攻击者时要按照倒序寻找。

5. 技能十使用后一定要记得清空包括对方技能十！技能为技能零（还可以使用）。

6. 记得技能一扣除蓝量后判断蓝量是否低于 ```0```。

7. 死亡记得清空一切。

8. 持续性技能结束后记得不要在加效果了。

9. 一定要区分清楚不同技能、天赋造成的是真实伤害还是伤害（伤害：技能一、技能三、技能八；真实伤害：天赋二（附带）、天赋四、技能二、技能五、技能六）。

#### 参考代码：

[参考代码，太长了，放这里。](https://www.luogu.com.cn/paste/6n1ductn)


---

## 作者：Rubidium_Chloride (赞：2)

## 0.前言

[博客题解传送门](https://www.luogu.com.cn/blog/Rolling-blog1424/solution-p7610)

大模拟好评！

特别鸣谢：@[$\texttt{\color{black}{s}\color{red}{henmadongdong}}$](https://www.luogu.com.cn/user/71491)。

（具体而言是帮作者调出了两个大错误。）

## 1.正文

既然是大模拟那么没什么好说的了。

主要分几个部分：

1. 技能
2. 普攻
3. 各种回合加成
4. 天赋

其中天赋和技能较为类似。

对于普攻，主要需要注意的就是受到伤害以及天赋的加成，算是这几个里面最为简单的一个；

对于技能而言，分 $10$ 种情况分类讨论即可。

需要注意的是：

1. 对于受到伤害/产生增减益的效果需要判断这两个先后顺序；
2. 对于技能 $10$，所谓的全场不只有自己一队，还有对手的队伍技能也要改为 $0$ 号技能；
3. 增/减益型效果，在下面会提到；

个人认为 回合加成 是最容易写错的内容（

一个比较坑的点：对于超过 $23333$ 回合后的增益效果没有用，可以将其视为只持续到第 $23333$ 回合为止（除非开大数组，否则会有RE）；

对于防御/攻击型的增减益，生效在技能结束（行动结束）后，而结束则是在回合结束。

注意到**对手的减益效果**也是在**自己**行动结束后产生的。

易错点：不要忘记在普攻以后增益。（本人错误 $\times 1$）

而实现方法可以分两个队分别用差分记录。

（当然效果的结束也可以在下回合开始后，$\texttt{Alice}$ 行动之前处理掉。）

至于每回合都会生效的 $\texttt{mp}$ 的回复可以直接每回合增加；

最后的效果就是技能 $10$ 发动后的判断本队死亡的效果，直接在那个回合打上一个 $\texttt{tag}$ 就可以了。


还有一些其他比较容易错的点：

1. 攻击的顺序不要写错！（作者就不小心写错了计算伤害的函数调了半天。）
2. 不要把变量名写错！

代码扔在[剪贴板](https://www.luogu.com.cn/paste/y4t7zmes)里了。


---

## 作者：xyf007 (赞：2)

开始写的时候比较脑抽，把 Alice 和 Bob 的角色分成了 $a,b$ 两个数组，导致代码里面全部都是对 Alice 和 Bob 的分类讨论，希望可以给同是这么写的选手一些参考（

---

写大模拟的时候个人比较偏向于自顶向下的写法，即先写框架再写具体实现。  
首先这道题每个回合五个阶段，于是写三个函数代表行动开始，行动结束和回合结束，搞清楚每个阶段的内容。  
然后是发动技能，发动普攻。注意到所有的造成伤害都是进入生命值扣除环节，因此生命值扣除环节也可以写成一个函数。  
增益效果我是先加上，然后到 $t+x-1$ 回合结束的时候再减掉。

---

一些注意点：
1. 如果用结构体存攻击对象记得**加上引用**。
2. 一切对属性的修改都要更新 $A/D/hp/mp$。

---

我犯的错误：
1. 把一些 `std::max` 打成了 `std::min`；
2. 有一处将 `b[i]` 打成了 `a[i]`；
3. 技能 10 处理额外回复的能量时放进了循环导致加了多次。

代码见[云剪贴板](https://www.luogu.com.cn/paste/hg9cmkls)。

---


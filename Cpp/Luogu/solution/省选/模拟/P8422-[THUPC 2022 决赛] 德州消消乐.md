# [THUPC 2022 决赛] 德州消消乐

## 题目背景

众所周知小 c 是开心消消乐的高手，而小 z 玩这种稍微需要动一点脑子的游戏都很不在行。正值五一假期，小 c 闲得无聊就打算来教小 z。

经过五天五夜不间断教学，小 z 终于领悟了一点门道（小 z 内心 os：但凡能拿出一点热情来学概率论……），然而他俩都忽略了这玩意是会玩上瘾的，更关键的是小 z 来自山东，于是他打算融入一点家乡特色……

小 z：”……众所周知德州在山东，那我们就叫它‘德州消消乐’吧！“

小 c 连忙制止道你快算了吧，上次的大杂糅棋局你忘了？再说此德州非彼德州啊喂，这次你要搞就自己搞吧别拉我下水了。

话还没说完，小 z 转手把规则甩给了小 c。

小 c：“真香”。


## 题目描述

给定大小为 $n \times m$ 的棋盘，记左上角坐标为 $(1,1)$ ，右下角坐标为 $(n,m)$ 。有不同颜色的棋子共 $k$ 种，颜色编号为 $1\sim k$ 。最初每个格子都有一个棋子。

共有 $q$ 次操作，每次操作形如交换相邻（在上、下、左、右方向）的两个棋子。在此之后，在同一行或同一列的连续至少 $3$ 个相同颜色的棋子会被消除。

消除后，所有棋子会遵循重力下落，这一列的最上方变成空位。所有棋子下落完成后，如果又产生了能消除的情况，则会触发连锁反应继续消除，直到无法消除为止。称一次消除+一次下落为“一轮消除”，由此可以定义一次操作触发的消除“轮数”。

其中，有些棋子具有特殊属性，被消除时会触发特殊效果，一共有以下 $6$ 类：

- 1、消除时将同一行的全部棋子消除；
- 2、消除时将同一列的全部棋子消除；
- 3、消除时将同一行和同一列的全部棋子消除；
- 4、消除时将以之为中心 $3 \times 3$ 的正方形范围内的棋子全部消除；
- 5、消除时将以之为中心 $5 \times 5$ 的正方形范围内的棋子全部消除；
- 6、消除时将与之颜色相同的棋子全部消除； 

触发一个棋子的特殊效果时可能连锁触发其他棋子的特殊效果，但是这些都是在同一轮消除内触发的（即连锁反应触发的过程中不会引起下落）。

游戏中，每次操作都要求必须有效，即操作的两个位置相邻且均不为空位，且在操作之后能进行棋子的消除。若某此操作并非有效，则直接跳过这一次操作。所有 $q$ 次操作结束后游戏结束。

定义一次有效操作的“主颜色”为通过交换而直接被消除的颜色（即不包括特殊效果触发和下落引起的消除），容易发现一次有效操作的主颜色至少有 $1$ 种，最多有 $2$ 种。

游戏中，玩家要通过操作来获取尽可能多的得分。得分的规则有如下 $5$ 种：消除奖分+连锁奖分+组合奖分+牌型奖分+终局奖分。

- 消除奖分：每次有效操作中，第 $i$ 轮消除的消除奖分为这一轮中所有被消除的棋子的颜色编号之和的 $i$ 倍。
- 连锁奖分：设某次有效操作的总消除轮数为 $x$ ，则有连锁奖分 $80(x-1)^2$ 。
- 组合奖分：某一轮消除中，在仅考虑由“同一行或同一列至少连续 $3$ 个相同颜色”引发的消除的情况下（即不考虑所有特殊效果引起的消除），设某个被消除的同色四连通块大小为 $x$ ，则有组合奖分 $50(x-3)^2$ 。如： $4$ 个同色棋子组成四连的组合奖分为 $50$ ，$5$ 个同色棋子组成五连、十字或T字等形状的组合奖分为 $200$ ，$2\times3$ 的方形同色棋子的组合奖分为 $450$ 。
 - 牌型奖分：每 $5$ 次有效操作计算一次牌型奖分，取之前 $5$ 次有效操作的主颜色（若某次操作有多个主颜色，取能按照以下规则计算出的最大奖分的主颜色），按照如下牌型规则计算奖分：
   
   - 高牌： $5$ 种颜色全部不同，奖 $50$ 分 + 所有牌中最大的颜色编号；
   - 一对： $2$ 个相同颜色 + $3$ 个不同颜色，奖 $100$ 分 + 一对的颜色编号 $\times 2$ ；
   
   - 两对： $2$ 对相同颜色 + $1$ 个其他颜色，奖 $200$ 分 + 两对中较大的颜色编号 $\times 2$ + 两对中较小的颜色编号；
   - 三条： $3$ 个相同颜色 + $2$ 个不同颜色，奖 $300$ 分 + 三条的颜色编号 $\times 3$ ；
   - 葫芦： $3$ 个相同颜色 + 另外 $2$ 个相同颜色，奖 $500$ 分 + 三个相同的颜色编号 $\times 3$ + 两个相同的颜色编号；
   - 四条： $4$ 个相同颜色 + $1$ 个其他颜色，奖 $750$ 分 + 四条的颜色编号 $\times 5$ ；
   - 五条： $5$ 个颜色全部相同，奖 $1000$ 分 + 五条的颜色编号 $\times 10$ 。
 - 终局奖分：若所有 $q$ 次操作均有效，在终局时额外获得 $1000$ 分终局奖分；若游戏结束时棋盘被全部清空，额外获得 $10000$ 分的终局奖分。

给定一局游戏的初始局面和玩家的每一次操作，你需要计算玩家的总得分。

## 说明/提示

【样例 1 解释】

每次操作后，前 $3$ 类奖分的和分别为：$315,\ 417,\ 429,\ 435,\ 482$ 。第 $5$ 次操作后计算牌型奖分，最优牌型为 $(1\ 2\ 4\ 2\ 4)$ ，奖分为 $200 + 4\times 2 + 2 \times 1 = 210$ 。终局时两种终局奖分均可获得，故总分为 $11692$ 。

【样例 2 解释】

与上一组样例相比，增加了 $3$ 次无效操作，且最后不能实现全消，因此得不到终局奖分。

【数据范围与约定】


$n,m\leq 50,\ k \leq 100,\ q \leq 1000,\ a_{i,j} \leq k,\ b_{i,j} \leq 6,\ x_{i,1},x_{i,2} \leq n,\ y_{i,1},y_{i,2} \leq m$ 。

保证初始局面没有可以直接消除的情况。

## 样例 #1

### 输入

```
8 8 5 5
1 1 5 1 5 4 5 3
2 1 2 2 5 4 3 2
1 4 1 4 2 1 5 4
2 1 5 5 2 1 4 4
2 3 5 2 3 4 2 2
4 2 4 3 3 2 4 5
1 3 4 3 5 2 4 3
3 4 2 5 2 1 1 2
0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0
0 0 0 0 5 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 6 0 0 3 1
0 0 0 0 3 0 0 0
0 0 0 0 0 0 1 4
3 2 4 2
5 4 5 5
7 2 7 3
8 5 8 6
6 7 6 8
```

### 输出

```
11692
```

## 样例 #2

### 输入

```
8 8 5 8
1 1 5 1 5 4 5 3
2 1 2 2 5 4 3 2
1 4 1 4 2 1 5 4
2 1 5 5 2 1 4 4
2 3 5 2 3 4 2 2
4 2 4 3 3 2 4 5
1 3 4 3 5 2 4 3
3 4 2 5 2 1 1 2
0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0
0 0 0 0 5 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 6 0 0 3 1
0 0 0 0 3 0 0 0
0 0 0 0 0 0 0 0
1 1 2 2
3 2 4 2
3 2 3 3
4 2 4 3
5 4 5 5
7 2 7 3
8 5 8 6
6 7 6 8
```

### 输出

```
684
```

## 样例 #3

### 输入

```
5 5 2 1
1 1 2 1 1
1 1 2 1 1
2 2 1 2 2
1 1 2 1 1
1 1 2 1 1
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
3 3 4 3
```

### 输出

```
3023
```

# 题解

## 作者：Milthm (赞：24)

## P8422 题解



### 前言

这题我从去西安旅游的时候就开始写，写炸了之后，去日照集训的时候重构，回济南又写了一天，才调出来，总用时 $14$ 个小时。这题本身并没有那么难，但是有一些坑点，这篇题解主要给大家说一下做法和一些坑点。

### 题目解法

本题为纯模拟。模拟顺序不难，大概是这样：

每一次询问，先交换元素，判断是否合法，对于每一轮：

- 枚举，消除元素。

- 统计第 $1,3$ 种奖分。

- 重力下落。

一次询问结束后，统计第 $2$ 种奖分。

每过 $5$ 次询问，统计一次第 $4$ 种奖分。所有询问都结束后，统计最后一种奖分。

接下来让我们来看看每一种奖分怎么统计：

#### 消除奖分

每一轮过后统计即可。

```cpp
void solve(){
	int lunshu=0;
	bool nengxiaochu=1;
	while(nengxiaochu){
		......
		ans1+=he*lunshu;//he 为颜色编号之和,lunshu 为轮数
	}
	......
}
```
#### 连锁奖分

```cpp
void solve(){
	int lunshu=0;
	bool nengxiaochu=1;
	while(nengxiaochu){
    	......
	}
	lunshu--;//如果你和我的实现方式一样，记得千万要把轮数减一下，因为不能消除的那一次也算在内了
	ans2+=80*(lunshu-1)*(lunshu-1);
}
```
#### 组合奖分

最大坑点！我来给大家梳理一下：

你消除的是：在同一行或同一列的连续至少 $3$ 个相同颜色的棋子。

你统计的是：你**本次消除**的**原来颜色相同**的**四联通块**大小。

明白了这个就不难了，开个数组记录一下，深搜即可。

```cpp
void dfs(int ax,int ay,int x,int y){
	vis[x][y]=1;++L;
	for(int i=0;i<4;++i){
		int px=x+w[i][0];
		int py=y+w[i][1];
		if(hefa(px,py)&&vis[px][py]==0&&del[px][py]&&a[ax][ay].x==a[px][py].x){
			dfs(ax,ay,px,py);
		}
	}
}
void solve(){
	int lunshu=0;
	bool nengxiaochu=1;
	while(nengxiaochu){
		......
		clear();//清空 vis 数组
		for(int i=1;i<=n;++i){
			for(int j=1;j<=m;++j){
				if(del[i][j]&&vis[i][j]==0){//记得判断是不是被访问过
					dfs(i,j,i,j);
					ans3+=(L-3)*(L-3)*50;
					L=0;//记得清零！！！
				}
			}
		}
		......
	}
	......
}
```

#### 牌型奖分

最麻烦的一个，其实一点都不难，直接五重循环暴力枚举，按照题意模拟即可。可以使用集合和排序减少码量。

小坑点：记得记录最大值，不要直接返回。

```cpp
void paixing(){
	int zzy[10]={0};
	s.clear();
	int cnt=0;
	for(int i=0;i<=1;++i){
		for(int j=0;j<=1;++j){
			for(int k=0;k<=1;++k){
				for(int l=0;l<=1;++l){
					for(int o=0;o<=1;++o){
						zzy[1]=color[1][i];
						zzy[2]=color[2][j];
						zzy[3]=color[3][k];
						zzy[4]=color[4][l];
						zzy[5]=color[5][o];
						if(zzy[1]==0||zzy[2]==0||zzy[3]==0||zzy[4]==0||zzy[5]==0)continue;//记得判断有没有颜色！！！！
						sort(zzy+1,zzy+6);
						for(int p=1;p<=5;++p)s.insert(zzy[p]);
						int len=s.size();
						if(len==5)cnt=max(cnt,50+zzy[5]);
						else if(len==4){
							int r=0;
							for(int p=1;p<=4;++p){
								if(zzy[p]==zzy[p+1]){
									r=zzy[p];break;
								}
							}
							cnt=max(cnt,100+r*2);
						}
						else if(len==3){
							int r=0,rr=0; 
							for(int p=1;p<=4;++p){
								if(zzy[p]==zzy[p+1]){
									if(r==0)r=zzy[p];
									else rr=zzy[p];
								}
							}
							if(r!=rr)cnt=max(cnt,200+max(r,rr)*2+min(r,rr));
							else{
								cnt=max(cnt,300+r*3);
							}	
						}
						else if(len==2){
							if(zzy[1]==zzy[4]||zzy[2]==zzy[5]){
								cnt=max(cnt,750+zzy[3]*5);
							}
							else{
								int bt=0;
								for(int p=1;p<=5;++p){
									if(zzy[p]!=zzy[3]){
										bt=zzy[p];
									}
								}
								cnt=max(cnt,500+zzy[3]*3+bt);
							}
						}
						else{
							cnt=max(cnt,1000+zzy[1]*10);
						}
						s.clear();
					}
				}
			}
		}
	}
	ans4+=cnt;
}
```
#### 终局奖分

最后判断即可，很简单。

### AC 代码

不加注释了，上面讲的很详细。

```cpp
#include<iostream>
#include<cmath>
#include<set>
#include<algorithm>
#define qwq 0
using namespace std;
struct node{
	int x,b;
}a[505][505];
int n,m,k,q,x,y,x2,y2,die[505][505],ans1,ans2,ans3,ans4,del[505][505];
int he,color[105][2],u,vis[505][505],L;
set<int>s; 
bool quanbuhefa=1;
bool hefa(int x,int y){
	return (x>=1&&x<=n&&y>=1&&y<=m);
}
void xiaochu(int x,int y){
	if(die[x][y]||a[x][y].x==0)return;
	die[x][y]=1;
	if(a[x][y].b==1){
		for(int i=1;i<=m;++i){
			if(i!=y)xiaochu(x,i);
		}
	}
	else if(a[x][y].b==2){
		for(int i=1;i<=n;++i){
			if(i!=x)xiaochu(i,y);
		}
	}
	else if(a[x][y].b==3){
		for(int i=1;i<=m;++i){
			if(i!=y)xiaochu(x,i);
		}
		for(int i=1;i<=n;++i){
			if(i!=x)xiaochu(i,y);
		}
	}
	else if(a[x][y].b==4){
		for(int i=x-1;i<=x+1;++i){
			for(int j=y-1;j<=y+1;++j){
				if(!(x==i&&y==j)&&hefa(i,j))xiaochu(i,j);
			}
		}
	}
	else if(a[x][y].b==5){
		for(int i=x-2;i<=x+2;++i){
			for(int j=y-2;j<=y+2;++j){
				if(!(x==i&&y==j)&&hefa(i,j))xiaochu(i,j);
			}
		}
	}
	else if(a[x][y].b==6){
		for(int i=1;i<=n;++i){
			for(int j=1;j<=m;++j){
				if((!(x==i&&y==j))&&a[i][j].x==a[x][y].x)xiaochu(i,j);
			}
		}
	}
} 
int heng_len(int x,int y,bool f){
	if(a[x][y].x==0)return 0;
	int px=x-1,ans=1;
	if(f)xiaochu(x,y),del[x][y]=1;
	while(px>=1&&a[px][y].x==a[x][y].x){
		if(f)xiaochu(px,y),del[px][y]=1;
		++ans,--px;
	}
	px=x+1;
	while(px<=n&&a[px][y].x==a[x][y].x){
		if(f)xiaochu(px,y),del[px][y]=1;;
		++ans,++px;
	}
	return ans;
}
int shu_len(int x,int y,bool f){
	if(a[x][y].x==0)return 0;
	int py=y-1,ans=1;
	if(f)xiaochu(x,y),del[x][y]=1;
	while(py>=1&&a[x][py].x==a[x][y].x){
		if(f)xiaochu(x,py),del[x][py]=1;
		++ans,--py;
	}
	py=y+1;
	while(py<=m&&a[x][py].x==a[x][y].x){
		if(f)xiaochu(x,py),del[x][py]=1;
		++ans,++py;
	}
	return ans;
}
void print(){
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			cout<<a[i][j].x<<"("<<a[i][j].b<<") ";
		}
		cout<<'\n';
	}
	cout<<"-----------------\n";
}
void clear(){
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			vis[i][j]=0;
		}
	}
}
void xialuo(){
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			if(die[i][j]){
				he+=a[i][j].x;
				a[i][j]={0,0};
			}
			die[i][j]=0;
			del[i][j]=0;
		}
	}	
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			int px=i;
			while(a[px][j].x!=0&&a[px+1][j].x==0&&px<n){
				swap(a[px][j],a[px+1][j]);
				++px;
			}
		}
	}
}
int w[4][2]={{0,1},{1,0},{-1,0},{0,-1}},zuhe;
void dfs(int ax,int ay,int x,int y){
	vis[x][y]=1;++L;
	for(int i=0;i<4;++i){
		int px=x+w[i][0];
		int py=y+w[i][1];
		if(hefa(px,py)&&vis[px][py]==0&&del[px][py]&&a[ax][ay].x==a[px][py].x){
			dfs(ax,ay,px,py);
		}
	}
}
void solve(){
	int lunshu=0;
	bool nengxiaochu=1;
	while(nengxiaochu){
		lunshu++;
		nengxiaochu=0;
		he=0;
		zuhe=0,L=0;
		for(int i=n;i>=1;--i){
			for(int j=1;j<=m;++j){
				if(lunshu==1&&(!(x==i&&y==j))&&(!(x2==i&&y2==j)))continue;
				//cout<<i<<" "<<j<<endl;
				int hh=heng_len(i,j,0),ss=shu_len(i,j,0);
				//cout<<i<<" "<<j<<" "<<hh<<" "<<ss<<endl;
				if(hh>=3||ss>=3){
					int qq=a[i][j].x;
					if(hh>=3)heng_len(i,j,1);
					die[i][j]=0;
					a[i][j].x=qq;
					if(ss>=3)shu_len(i,j,1);
					die[i][j]=1;
					nengxiaochu=1;
					L=0;
				} 
			}
		}
		//print();
		clear();
		for(int i=1;i<=n;++i){
			for(int j=1;j<=m;++j){
				if(del[i][j]&&vis[i][j]==0){
					dfs(i,j,i,j);
					ans3+=(L-3)*(L-3)*50;
					L=0;
				}
			}
		}
		for(int i=1;i<=200;++i)xialuo();

		ans1+=he*lunshu;
		//print();
	}
	lunshu--;
	ans2+=80*(lunshu-1)*(lunshu-1);
}
void paixing(){
	int zzy[10]={0};
	s.clear();
	int cnt=0;
	for(int i=0;i<=1;++i){
		for(int j=0;j<=1;++j){
			for(int k=0;k<=1;++k){
				for(int l=0;l<=1;++l){
					for(int o=0;o<=1;++o){
						zzy[1]=color[1][i];
						zzy[2]=color[2][j];
						zzy[3]=color[3][k];
						zzy[4]=color[4][l];
						zzy[5]=color[5][o];
						if(zzy[1]==0||zzy[2]==0||zzy[3]==0||zzy[4]==0||zzy[5]==0)continue;
						sort(zzy+1,zzy+6);
						for(int p=1;p<=5;++p)s.insert(zzy[p]);
						int len=s.size();
						if(len==5)cnt=max(cnt,50+zzy[5]);
						else if(len==4){
							int r=0;
							for(int p=1;p<=4;++p){
								if(zzy[p]==zzy[p+1]){
									r=zzy[p];break;
								}
							}
							cnt=max(cnt,100+r*2);
						}
						else if(len==3){
							int r=0,rr=0; 
							for(int p=1;p<=4;++p){
								if(zzy[p]==zzy[p+1]){
									if(r==0)r=zzy[p];
									else rr=zzy[p];
								}
							}
							if(r!=rr)cnt=max(cnt,200+max(r,rr)*2+min(r,rr));
							else{
								cnt=max(cnt,300+r*3);
							}	
						}
						else if(len==2){
							if(zzy[1]==zzy[4]||zzy[2]==zzy[5]){
								cnt=max(cnt,750+zzy[3]*5);
							}
							else{
								int bt=0;
								for(int p=1;p<=5;++p){
									if(zzy[p]!=zzy[3]){
										bt=zzy[p];
									}
								}
								cnt=max(cnt,500+zzy[3]*3+bt);
							}
						}
						else{
							cnt=max(cnt,1000+zzy[1]*10);
						}
						s.clear();
					}
				}
			}
		}
	}
	ans4+=cnt;
}
int main(){
	cin>>n>>m>>k>>q;
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			cin>>a[i][j].x;
		}
	}
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			cin>>a[i][j].b;
		}
	}
	while(q--){
		cin>>x>>y>>x2>>y2;
		swap(a[x][y],a[x2][y2]);
		int h1=heng_len(x,y,0),h2=heng_len(x2,y2,0);
		int s1=shu_len(x,y,0),s2=shu_len(x2,y2,0);
		int o=abs(x-x2),o2=abs(y-y2);
		if(o+o2!=1||hefa(x,y)==0||hefa(x2,y2)==0||(h1<3&&s1<3&&h2<3&&s2<3)||a[x2][y2].x==0||a[x][y].x==0){
			swap(a[x][y],a[x2][y2]);
			quanbuhefa=0;continue;
		}
		++u;
		if(h1>=3||s1>=3)color[u][0]=a[x][y].x;
		if(h2>=3||s2>=3){
			if(color[u][0])color[u][1]=a[x2][y2].x;
			else color[u][0]=a[x2][y2].x;
		}
		if(u==5){
			int as=ans4;
			paixing();
			for(int i=1;i<=5;++i){
				color[i][0]=color[i][1]=0;
			}
			u=0;
			//cout<<ans4-as<<endl;
		}
		solve();
		//cout<<ans1+ans2+ans3+ans4<<endl;
	}
	int ans=0;
	if(quanbuhefa)ans=1000;
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			if(a[i][j].x!=0)goto R;
		}
	}
	ans+=10000;
	R:cout<<ans+ans1+ans2+ans3+ans4<<endl;
	//cout<<ans1<<" "<<ans2<<" "<<ans3<<" "<<ans4;
	return qwq;
} 

```











---

## 作者：liangbowen (赞：16)

## 前言

[题目传送门！](https://www.luogu.com.cn/problem/P8422)

[更好的阅读体验？](https://www.cnblogs.com/liangbowen/p/17151985.html)

第三道大模拟，写篇题解庆祝一下。

文中粗体字是我踩坑的地方，欢迎统计我被坑了多少次。

## 思路

终局奖分很简单，放在主函数里，所以我们看每次的操作是怎样的。

首先判断操作不合法：

+ 给定的坐标超出范围。
+ 是空位置。
+ 不是相邻的。
+ **交换后仍然不合法**。

注意不合法要**把交换的东西复原**。然后我们合法的话就一直操作，不合法了就跳出，跑下一次。

这里大家可以参考我的顺序：

1. 统计主颜色，满了就看**牌型奖分**。
2. 一直跑。先连通块统计组合奖分。
3. 消除，包括特殊属性。消除的时候统计消除奖分。注意这里只标记不删除。
4. 现在再删除。
5. 自由掉落。
6. 循环结束了。统计连锁奖分。

大部分操作还是比较简单的，比较恶心的操作就是牌型奖分。

首先我们统计的时候把主函数用 Node 存储。**存储的颜色显然不能重复**。

```cpp
Node tmp = (Node){-114514, -114514};
for (int i = 1; i <= n; i++)
	for (int j = 1; j <= m; j++)
		if (del[i][j])
		{
			if (tmp.x == -114514) tmp.x = color[i][j];
			else if (tmp.y != color[i][j] && tmp.y == -114514) tmp.y = color[i][j];
		}
card[++cntcard] = tmp;
if (cntcard == 5)
{
	vector <int> empty; //没有任何意义的玩意，他是空的
	maxn = 0, dfs(1, empty);
	ans += maxn;
	cntcard = 0;
}
```

现在满五个了，直接枚举跳颜色 1 还是颜色 2 即可。

```cpp
#define let(x) tmp.push_back(x), dfs(i + 1, tmp), tmp.pop_back()
void dfs(int i, vector <int> tmp)
{
	if (i > 5) {maxn = max(maxn, calc(tmp)); return;}
	if (card[i].x != -114514) let(card[i].x);
	if (card[i].y != -114514) let(card[i].y);
}
```

至于**计算**就比较简单了（但是判断较多，脑子不清醒最好不要做）。元素只有五个，所以用任何办法统计都可以，显然不会超时。

## 代码

这次打大模拟激进了一点，所以就没写多少注释，但是看懂很容易的吧（

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <vector>
#include <algorithm>
//这两个是关键字，所以就替换掉，代码中没有影响
#define y1 jojojo
#define round jinitaimei
using namespace std;
#define squ(x) ((x) * (x))
const int N = 55, dict[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
int n, m, k, q, color[N][N], tag[N][N];
void swp(int x1, int y1, int x2, int y2) {swap(color[x1][y1], color[x2][y2]), swap(tag[x1][y1], tag[x2][y2]);}
bool near(int x1, int y1, int x2, int y2)
{
	for (int i = 0; i < 4; i++)
		if (x1 + dict[i][0] == x2 && y1 + dict[i][1] == y2 || x2 + dict[i][0] == x1 && y2 + dict[i][1] == y1)
			return true;
	return false;
}
struct Node {int x, y;};
bool del[N][N];
bool chk()
{
	memset(del, false, sizeof del);
	bool flag = false;
	for (int x = 1; x <= n; x++)
		for (int y = 1; y <= m; y++)
			for (int i = 0; i < 4; i++)
			{
				int dx = x + dict[i][0], dy = y + dict[i][1], ddx = dx + dict[i][0], ddy = dy + dict[i][1];
				if (dx < 1 || dx > n || dy < 1 || dy > m) continue;
				if (ddx < 1 || ddx > n || ddy < 1 || ddy > m) continue;
				if (color[x][y] != 0 && color[x][y] == color[dx][dy] && color[x][y] == color[ddx][ddy])
					del[x][y] = del[dx][dy] = del[ddx][ddy] = flag = true;
			}
	return flag;
}
bool vis[N][N]; int siz;
void dfs(int x, int y)
{
	siz++, vis[x][y] = true;
	for (int i = 0; i < 4; i++)
	{
		int dx = x + dict[i][0], dy = y + dict[i][1];
		if (dx < 1 || dx > n || dy < 1 || dy > m) continue;
		if (del[dx][dy] && color[x][y] == color[dx][dy] && !vis[dx][dy]) dfs(dx, dy);
	}
}
int ans, round;
void remove(int x, int y)
{
	if (color[x][y] == 0 || vis[x][y]) return;
	vis[x][y] = true, ans += round * color[x][y];
	if (tag[x][y] == 1 || tag[x][y] == 3) {for (int i = 1; i <= m; i++) remove(x, i);}
	if (tag[x][y] == 2 || tag[x][y] == 3) {for (int i = 1; i <= n; i++) remove(i, y);}
	if (tag[x][y] == 4)
	{
		for (int i = max(1, x - 1); i <= min(n, x + 1); i++)
			for (int j = max(1, y - 1); j <= min(m, y + 1); j++)
				remove(i, j);
	}
	else if (tag[x][y] == 5)
	{
		for (int i = max(1, x - 2); i <= min(n, x + 2); i++)
			for (int j = max(1, y - 2); j <= min(m, y + 2); j++)
				remove(i, j);
	}
	else if (tag[x][y] == 6)
	{
		for (int i = 1; i <= n; i++)
			for (int j = 1; j <= m; j++)
				if (color[i][j] == color[x][y])
					remove(i, j);
	}
}
void drop()
{
	for (int i = n; i; i--)
		for (int j = 1; j <= m; j++)
			if (color[i][j] == 0)
			for (int ii = i - 1; ii; ii--)
				if (color[ii][j] != 0)
				{
					swp(i, j, ii, j);
					break;
				}
	
}
Node card[105]; int cntcard;
int calc(vector <int> v)
{
	int cntbox[105] = {}; vector <int> cnt[10];
	for (int x : v) cntbox[x]++;
	for (int i = 0; i < 105; i++) cnt[cntbox[i]].push_back(i);
	for (int i = 0; i < 10; i++) sort(cnt[i].begin(), cnt[i].end());
	
	if ((int)cnt[1].size() == 5) return 50 + cnt[1][4];
	if ((int)cnt[1].size() == 3 && (int)cnt[2].size() == 1) return 100 + cnt[2][0] * 2;
	if ((int)cnt[1].size() == 1 && (int)cnt[2].size() == 2) return 200 + cnt[2][1] * 2 + cnt[2][0];
	if ((int)cnt[1].size() == 2 && (int)cnt[3].size() == 1) return 300 + cnt[3][0] * 3;
	if ((int)cnt[2].size() == 1 && (int)cnt[3].size() == 1) return 500 + cnt[3][0] * 3 + cnt[2][0];
	if ((int)cnt[1].size() == 1 && (int)cnt[4].size() == 1) return 750 + cnt[4][0] * 5;
	if ((int)cnt[5].size() == 1) return 1000 + cnt[5][0] * 10;
    return 0;
}
int maxn;
#define let(x) tmp.push_back(x), dfs(i + 1, tmp), tmp.pop_back()
void dfs(int i, vector <int> tmp)
{
	if (i > 5) {maxn = max(maxn, calc(tmp)); return;}
	if (card[i].x != -114514) let(card[i].x);
	if (card[i].y != -114514) let(card[i].y);
}
void play()
{
	Node tmp = (Node){-114514, -114514};
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			if (del[i][j])
			{
				if (tmp.x == -114514) tmp.x = color[i][j];
				else if (tmp.x != color[i][j] && tmp.y == -114514) tmp.y = color[i][j];
			}
	card[++cntcard] = tmp;
	if (cntcard == 5)
	{
		vector <int> empty;
		maxn = 0, dfs(1, empty);
		ans += maxn;
		//printf("mx = %d\n", maxn);
		cntcard = 0;
	}
	for (round = 1;; round++)
	{
		memset(vis, false, sizeof vis);
		for (int i = 1; i <= n; i++)
			for (int j = 1; j <= m; j++)
				if (del[i][j] && !vis[i][j])
					siz = 0, dfs(i, j), ans += 50 * squ(siz - 3);
		memset(vis, false, sizeof vis);
		for (int i = 1; i <= n; i++)
			for (int j = 1; j <= m; j++)
				if (del[i][j] && !vis[i][j])
					remove(i, j);
		for (int i = 1; i <= n; i++)
			for (int j = 1; j <= m; j++)
				if (vis[i][j])
					color[i][j] = 0;
		drop();
		
//		system("cls");
//		printf("当前%d局势\n", round);
//		for (int i = 1; i <= n; i++, putchar('\n'))
//			for (int j = 1; j <= m; j++)
//				printf("(%d,%d) ", color[i][j], tag[i][j]);
//		system("pause");
		
		if (!chk()) break;
	}
	ans += 80 * squ(round - 1);
//	printf("奖金 %d\n", ans);
}
bool solve(int x1, int y1, int x2, int y2)
{
	if (x1 < 1 || x1 > n || y1 < 1 || y1 > m) return false;
	if (x2 < 1 || x2 > n || y2 < 1 || y2 > m) return false;
	if (color[x1][y1] == 0 || color[x2][y2] == 0 || !near(x1, y1, x2, y2)) return false;
	swp(x1, y1, x2, y2);
	if (chk()) {play(); return true;}
	else {swp(x1, y1, x2, y2); return false;} //不成功要换回来！ 
}
int main()
{
	scanf("%d%d%d%d", &n, &m, &k, &q);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			scanf("%d", &color[i][j]);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			scanf("%d", &tag[i][j]);
	int allOK_score = 1000, wonderful_score = 10000;
	while (q--)
	{
		int x1, y1, x2, y2;
		scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
		if (!solve(x1, y1, x2, y2)) allOK_score = 0;
	}
	for (int i = 1; i <= n && wonderful_score; i++)
		for (int j = 1; j <= m && wonderful_score; j++)
			if (color[i][j] != 0)
				wonderful_score = 0;
	cout << ans + allOK_score + wonderful_score;
	return 0;
}
```

希望能帮助到大家！

---

## 作者：_Remake_ (赞：6)

## 题目分析
大模拟，题面很长，但是整道题可以分为几个部分分开处理：

**操作一：交换两个棋子**

本题最简单的部分，注意特判边界和交换位置没有棋子以及两个位置不相邻的情况。

**操作二：判断当前局面能否消除**

可以对每一个棋子进行 $x$ 方向和 $y$ 方向的枚举，如果有三个及以上在 $x$ 方向或 $y$ 方向连续且包含当前棋子的同色棋子则把这些棋子打上标记，代表此轮将要消除的棋子。


注：交换棋子和判断能否消除以及连锁消除我放进了一个函数里进行解决

```cpp
void SWAP(int X1,int Y1,int X2,int Y2)
{
	if(!((X1==X2+1&&Y1==Y2)||(X1==X2-1&&Y1==Y2)||(X1==X2&&Y1==Y2+1)||(X1==X2&&Y1==Y2-1)))
	{
		useless++;
		AP=0;
		return;
	}
	if(!type[X1][Y1]||!type[X2][Y2])
	{	
		useless++;
		AP=0;
		return;
	}
	int round=0;
	swap(type[X1][Y1],type[X2][Y2]);
	swap(spec[X1][Y1],spec[X2][Y2]);
	int T1=type[X1][Y1];
	int cnt=0;
	bool flag=0;
	for(int r=X1+1;r<=n;r++)
	{
		if(type[r][Y1]==T1)
		{
			if(CL[r][Y1]!=2)
			{
				CL[r][Y1]=1;
			}
			cnt++;
		}
		else
		{
			break;
		}
	}
	for(int r=X1-1;r>=1;r--)
	{
		if(type[r][Y1]==T1)
		{
			if(CL[r][Y1]!=2)
			{
				CL[r][Y1]=1;
			}
			cnt++;
		}
		else
		{
			break;
		}
	}
	cnt++;
	if(cnt>=3)
	{
		maincolor[optnum][0]=type[X1][Y1];
		CL[X1][Y1]=2;
		for(int r=1;r<=n;r++)
		{
			for(int f=1;f<=m;f++)
			{
				if(CL[r][f]==1)
				{
					CL[r][f]=2;
				}
			}
		}
		flag=1;
	}
	else
	{
		for(int r=1;r<=n;r++)
		{
			for(int f=1;f<=m;f++)
			{
				if(CL[r][f]==1)
				{
					CL[r][f]=0;
				}
			}
		}
	}
	cnt=0;
	for(int r=Y1+1;r<=m;r++)
	{
		if(type[X1][r]==T1)
		{
			if(CL[X1][r]!=2)
			{
				CL[X1][r]=1;
			}
			cnt++;
		}
		else
		{
			break;
		}
	}
	for(int r=Y1-1;r>=1;r--)
	{
		if(type[X1][r]==T1)
		{
			if(CL[X1][r]!=2)
			{
				CL[X1][r]=1;
			}
			cnt++;
		}
		else
		{
			break;
		}
	}
	cnt++;
	if(cnt>=3)
	{
		maincolor[optnum][0]=type[X1][Y1];
		CL[X1][Y1]=2;
		for(int r=1;r<=n;r++)
		{
			for(int f=1;f<=m;f++)
			{
				if(CL[r][f]==1)
				{
					CL[r][f]=2;
				}
			}
		}
		flag=1;
	}
	else
	{
		for(int r=1;r<=n;r++)
		{
			for(int f=1;f<=m;f++)
			{
				if(CL[r][f]==1)
				{
					CL[r][f]=0;
				}
			}
		}
	}
	
	int T2=type[X2][Y2];
	cnt=0;
	for(int r=X2+1;r<=n;r++)
	{
		if(type[r][Y2]==T2)
		{
			if(CL[r][Y2]!=2)
			{
				CL[r][Y2]=1;
			}
			cnt++;
		}
		else
		{
			break;
		}
	}
	for(int r=X2-1;r>=1;r--)
	{
		if(type[r][Y2]==T2)
		{
			if(CL[r][Y2]!=2)
			{
				CL[r][Y2]=1;
			}
			cnt++;
		}
		else
		{
			break;
		}
	}
	cnt++;
	if(cnt>=3)
	{
		maincolor[optnum][1]=type[X2][Y2];
		CL[X2][Y2]=2;
		for(int r=1;r<=n;r++)
		{
			for(int f=1;f<=m;f++)
			{
				if(CL[r][f]==1)
				{
					CL[r][f]=2;
				}
			}
		}
		flag=1;
	}
	else
	{
		for(int r=1;r<=n;r++)
		{
			for(int f=1;f<=m;f++)
			{
				if(CL[r][f]==1)
				{
					CL[r][f]=0;
				}
			}
		}
	}
	cnt=0;
	for(int r=Y2+1;r<=m;r++)
	{
		if(type[X2][r]==T2)
		{
			if(CL[X2][r]!=2)
			{
				CL[X2][r]=1;
			}
			cnt++;
		}
		else
		{
			break;
		}
	}
	for(int r=Y2-1;r>=1;r--)
	{
		if(type[X2][r]==T2)
		{
			if(CL[X2][r]!=2)
			{
				CL[X2][r]=1;
			}
			cnt++;
		}
		else
		{
			break;
		}
	}
	cnt++;
	if(cnt>=3)
	{
		maincolor[optnum][1]=type[X2][Y2];
		CL[X2][Y2]=2;
		for(int r=1;r<=n;r++)
		{
			for(int f=1;f<=m;f++)
			{
				if(CL[r][f]==1)
				{
					CL[r][f]=2;
				}
			}
		}
		flag=1;
	}
	else
	{
		for(int r=1;r<=n;r++)
		{
			for(int f=1;f<=m;f++)
			{
				if(CL[r][f]==1)
				{
					CL[r][f]=0;
				}
			}
		}
	}
	if(!flag)
	{
		swap(type[X1][Y1],type[X2][Y2]);
		swap(spec[X1][Y1],spec[X2][Y2]);
		AP=0;
		
		useless++;
		return;
	}
	//cout<<"114514 "<<X1<<" "<<Y1<<" "<<X2<<" "<<Y2<<endl;
	optnum++;
	while(flag)
	{
		memset(vis,0,sizeof vis);
		round++;
		for(int r=1;r<=n;r++)
		{
			for(int f=1;f<=m;f++)
			{
				if(!vis[r][f]&&CL[r][f]==2)
				{
					int K=bfs(r,f);
					calc3(K);
				}
			}
		}
		roundclear=0;
		for(int r=1;r<=n;r++)
		{
			for(int f=1;f<=m;f++)
			{
				if(CL[r][f]==2)
				{
					Clear(r,f);
				}
			}
		}
		calc1(round,roundclear);
		memset(CL,0,sizeof CL);
		down();
		/*
		cout<<"-----------------------------"<<endl;
		for(int r=1;r<=n;r++)
		{
			for(int f=1;f<=m;f++)
			{
				cout<<type[r][f]<<" ";
			}
			cout<<endl;
		}
		cout<<"-----------------------------"<<endl;
		*/
		flag=0;
		if(check())
		{
			flag=1;
		}
	}
	calc2(round);
	if(optnum==5)
	{
		optnum=0;
		calc4();
		memset(maincolor,0,sizeof maincolor);
	}
}
```


**操作三：消除棋子**

可以使用一个函数，传入被消除棋子的坐标，如消除了具有特殊能力的棋子，则递归消除被技能消除的棋子。

```cpp
void Clear(int x,int y)
{
	int col=type[x][y];
	roundclear+=type[x][y];
	type[x][y]=0;
	if(!spec[x][y])
	{
		return;
	}
	if(spec[x][y]==1)
	{
		spec[x][y]=0;
		for(int r=1;r<=m;r++)
		{
			if(type[x][r])
			{
				Clear(x,r);
			}
		}
	}
	if(spec[x][y]==2)
	{
		spec[x][y]=0;
		for(int r=1;r<=n;r++)
		{
			if(type[r][y])
			{
				Clear(r,y);
			}
		}
	}
	if(spec[x][y]==3)
	{
		spec[x][y]=0;
		for(int r=1;r<=n;r++)
		{
			if(type[r][y])
			{
				Clear(r,y);
			}
		}
		for(int f=1;f<=m;f++)
		{
			if(type[x][f])
			{
				Clear(x,f);
			}
		}
	}
	if(spec[x][y]==4)
	{
		spec[x][y]=0;
		for(int r=max(1,x-1);r<=min(n,x+1);r++)
		{
			for(int f=max(1,y-1);f<=min(m,y+1);f++)
			{
				if(type[r][f])
				{
					Clear(r,f);
				}
			}
		}
	}
	if(spec[x][y]==5)
	{
		spec[x][y]=0;
		for(int r=max(1,x-2);r<=min(n,x+2);r++)
		{
			for(int f=max(1,y-2);f<=min(m,y+2);f++)
			{
				if(type[r][f])
				{
					Clear(r,f);
				}
			}
		}
	}
	if(spec[x][y]==6)
	{
		spec[x][y]=0;
		for(int r=1;r<=n;r++)
		{
			for(int f=1;f<=m;f++)
			{
				if(type[r][f]==col)
				{
					Clear(r,f);
				}
			}
		}
	}
}
```


**操作四：计算分数**

计算分数又分为五个部分：

第一部分：消除分数

对于每一次消除，记录被消除的棋子的颜色编号总和，以及当前消除的轮数，两者的乘积即为此部分的分数。

```cpp
void calc1(int round,int sum)
{
	score+=sum*round;
	return;
}
```

第二部分：连锁分数

同第一部分，但只需记录每次消除的轮数即可。

```cpp
void calc2(int round)
{
	score+=80*(round-1)*(round-1);
	return;
}
```

第三部分：组合分数

对每次非特殊能力消除的棋子进行 ```bfs```，可以使用 ```vis``` 数组防止重复计算，统计每个连通块大小即可。


```cpp
void calc3(int blocksize)
{
	if(blocksize<=3)
	{
		return;
	}
	score+=50*(blocksize-3)*(blocksize-3);
	return;
}
```

第四部分：牌型分数

使用二维数组 ```maincolor``` 记录每五次有效操作的主颜色，使用二进制枚举每一种可能的情况，经检验合法之后再在每种可能的分数中取最大值。

```cpp
bool check1(int state)
{
	for(int r=0;r<=4;r++)
	{
		if((state>>r)&1)
		{
			if(!maincolor[5-r-1][1])
			{
				return 0;
			}
		}
		else
		{
			if(!maincolor[5-r-1][0])
			{
				return 0;
			}
		}
	}
	return 1;
}
void Calc4(int state)
{
	memset(sum,0,sizeof sum);
	int colmax=0;
	int flag2=0,flag3=0,flag4=0,flag5=0;
	int N2_1=0,N2_2=0,N3=0;
	for(int r=0;r<=4;r++)
	{
		sum[maincolor[5-r-1][(state>>r)&1]]++;
	}
	for(int r=1;r<=k;r++)
	{
		if(sum[r])
		{
			colmax=max(colmax,r);
		}
		if(sum[r]==5)
		{
			flag5++;
			addscore=max(addscore,1000+10*r);
		}
		if(sum[r]==4)
		{
			flag4++;
			addscore=max(addscore,750+5*r);
		}
		if(sum[r]==3)
		{
			N3=r;
			flag3++;
		}
		if(sum[r]==2)
		{
			if(!N2_1)
			{
				N2_1=r;
			}
			else
			{
				N2_2=r;
			}
			flag2++;
		}
	}
	if(!(flag2||flag3||flag4||flag5))
	{
		addscore=max(addscore,50+colmax);
	}
	if(flag2==1&&!flag3)
	{
		addscore=max(addscore,100+N2_1*2);
	}
	if(flag2==2)
	{
		addscore=max(addscore,200+max(N2_1,N2_2)*2+min(N2_1,N2_2));
	}
	if(flag3&&flag2)
	{
		addscore=max(addscore,500+N3*3+N2_1);
	}
	if(flag3&&!flag2)
	{
		addscore=max(addscore,300+N3*3);
	}
}
void calc4()
{
	addscore=0;
	for(int r=0;r<(1<<5);r++)
	{
		if(check1(r))
		{
			Calc4(r);
		}
	}
	score+=addscore;
}
```
注：```check1``` 部分为合法性判断，```Calc4``` 部分为每一种情况的加分计算。



第五部分：终局分数

使用一个变量 ```AP``` 记录是否每一次操作都有效，可以在每一次操作时都记录是否为合法操作，如果不合法则 $AP=0$ 。在完成所有操作之后扫描一遍棋盘，如果没有剩余棋子可获得全清分数。

```cpp
void calc5()
{
	if(AP)
	{
		score+=1000;
	}
	for(int r=1;r<=n;r++)
	{
		for(int f=1;f<=m;f++)
		{
			if(type[r][f])
			{
				return;
			}
		}
	}
	score+=10000;
}
```

## 代码


由于代码太长所以放云剪贴板


[代码](https://www.luogu.com.cn/paste/j52egb40)

---

## 作者：codeLJH114514 (赞：6)

本题为大模拟，只要节奏不乱，过掉只是时间的问题。

本题的一个很好的点就是出题人并没有在语言上难为你。

# 代码流程

- 输入操作。
- 判断是否出界或要操作的元素已经被删。
- 否则交换，然后计算主颜色。
- 如果没有主颜色那么说明这个操作没用。
- 否则开始消除。
- 对于每一轮，再算一遍主颜色（为了判断还能不能消），然后再消除，然后按重力下落。
- 对于每一轮的消除，对所有点都判断一遍能不能以这个点为中点消除，如果能就消除这三个方块。
- 消除完毕，计算组合奖分。
- 计算消除奖分。
- 对于消除每个方块，先将这个方块的颜色设置成 $0$，然后判断有没有特殊效果，如果有执行（递归调用）。
- 返回，计算连锁奖分。
- 返回，如果已经够了五次那么计算牌型奖分。
- 最终计算终局奖分。
- 输出，结束。

## 关于计算连锁奖分

先弄出所有只通过三消的方法消除的方块列表（这个在消除时就可以同时计算了）。

然后对于每个被这样消除的方块都计算连通块，然后根据公式累加。

## 关于计算牌型奖分

先五重循环枚举主颜色的选择，然后再具体计算。

对于具体计算的五个颜色，先将他们加入 `STL map` 中。（即 `MAP[VAL] += 1`）

然后判断 `STL map` 的长度就能确定一部分的类型。

然后就暴力判断计算即可。

## 关于重力

我这边使用了 $\mathcal{O}(n^3)$ 的方法弄重力，我自我感觉不是很麻烦。

# 最终代码

注：`/**/` 内的为解释。

```cpp
#include <bits/stdc++.h>
#define PrintBy(by, str) //std::cout << "[" << by << "]:" << str << std::endl;
/* 这一个宏定义是为了调试用的 */
typedef std::pair<int, int> ThePosition;
const int N = 64;
int n, m, k, q;
int TotalScore;
struct TheElement { /* 这一个类就是每一个元素 */
    int color, extra;
    TheElement(): color(0), extra(0) {
    }
};
struct TheGraph {
    TheElement a[N][N];
    std::vector<std::vector<int>> elis;
    std::vector<int> CheckErase() { /* 计算主颜色 */
        std::vector<int> mc;
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= m; j++) {
                int l = a[i - 1][j].color, m = a[i][j].color, r = a[i + 1][j].color;
                if (l != 0 and m != 0 and r != 0 and l == m and m == r)
                    mc.emplace_back(l);
                l = a[i][j - 1].color, m = a[i][j].color, r = a[i][j + 1].color;
                if (l != 0 and m != 0 and r != 0 and l == m and m == r)
                    mc.emplace_back(l);
            }
        std::sort(mc.begin(), mc.end());
        mc.erase(std::unique(mc.begin(), mc.end()), mc.end());
        std::string mcstr = "{";
        for (auto i : mc)
            mcstr += std::to_string(i) + ",";
        PrintBy("Eraser", "The <main-color> of this operation is : " << mcstr << "}.");
        return mc;
    }
    void EraseBlock(std::array<std::array<int, N>, N>& eraser, int& ColorSummon, const int& x, const int& y) { /* 删除元素 */
        if ((not (1 <= x and x <= n and 1 <= y and y <= m)) or eraser[x][y] == 1 or a[x][y].color == 0) return;
        PrintBy("Eraser", "The block(" << x << ", " << y << ") has been erased.");
        ColorSummon += a[x][y].color;
        eraser[x][y] = 1;
        if (a[x][y].extra != 0)
            PrintBy("Eraser", "This block has extra-effect: " << a[x][y].extra);
        switch (a[x][y].extra) {
            case 1:
                for (int i = 1; i <= m; i++)
                    EraseBlock(eraser, ColorSummon, x, i);
                break;
            case 2:
                for (int i = 1; i <= n; i++)
                    EraseBlock(eraser, ColorSummon, i, y);
                break;
            case 3:
                for (int i = 1; i <= n; i++)
                    EraseBlock(eraser, ColorSummon, i, y);
                for (int i = 1; i <= m; i++)
                    EraseBlock(eraser, ColorSummon, x, i);
                break;
            case 4:
                for (int i = -1; i <= 1; i++)
                    for (int j = -1; j <= 1; j++)
                        EraseBlock(eraser, ColorSummon, x + i, y + j);
                break;
            case 5:
                for (int i = -2; i <= 2; i++)
                    for (int j = -2; j <= 2; j++)
                        EraseBlock(eraser, ColorSummon, x + i, y + j);
                break;
            case 6:
                for (int i = 1; i <= n; i++)
                    for (int j = 1; j <= m; j++)
                        if (a[i][j].color == a[x][y].color)
                            EraseBlock(eraser, ColorSummon, i, j);
        }
    }
    int FindBlock(std::array<std::array<int, N>, N>& ers, int fx, int fy) { /* 找连通块，计算组合奖分用的 */
        std::queue<ThePosition> q;
        q.emplace(fx, fy);
        ers[fx][fy] = 0;
        int fb = 1, col = a[fx][fy].color;
        const int dx[4] = {0, 0, 1, -1};
        const int dy[4] = {1, -1, 0, 0};
        while (q.size()) {
            int qx = q.front().first, qy = q.front().second;
            q.pop();
            for (int i = 0; i < 4; i++) {
                int nx = qx + dx[i], ny = qy + dy[i];
                if (not (1 <= nx and nx <= n and 1 <= ny and ny <= m) or ers[nx][ny] != 1 or a[nx][ny].color != col) continue;
                q.emplace(nx, ny);
                fb += 1;
                ers[nx][ny] = 0;
            }
        }
        return fb;
    }
    void CalcuComboScore(const std::array<std::array<int, N>, N>& ers) { /* 计算组合奖分 */
        std::array<std::array<int, N>, N> ibl = ers;
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= m; j++)
                if (ibl[i][j] == 1) {
                    int fb = FindBlock(ibl, i, j);
                    PrintBy("System", "Got <combo> score: " << 50 * (fb - 3) * (fb - 3));
                    TotalScore += 50 * (fb - 3) * (fb - 3);
                }
    }
    bool Erase(int rnd) { /* 整个删除的流程 */
        //std::cout << "Round " << rnd << "!\n";
        if (CheckErase().empty()) return 0;
        int ColorSummon = 0;
        std::array<std::array<int, N>, N> eraser, native;
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= m; j++)
                eraser[i][j] = native[i][j] = 0;
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= m; j++) {
                int l = a[i - 1][j].color, m = a[i][j].color, r = a[i + 1][j].color;
                if (l != 0 and m != 0 and r != 0 and l == m and m == r) {
                    native[i - 1][j] = native[i][j] = native[i + 1][j] = 1;
                    EraseBlock(eraser, ColorSummon, i - 1, j);
                    EraseBlock(eraser, ColorSummon, i, j);
                    EraseBlock(eraser, ColorSummon, i + 1, j);
                }
                l = a[i][j - 1].color, m = a[i][j].color, r = a[i][j + 1].color;
                if (l != 0 and m != 0 and r != 0 and l == m and m == r) {
                    native[i][j - 1] = native[i][j] = native[i][j + 1] = 1;
                    EraseBlock(eraser, ColorSummon, i, j - 1);
                    EraseBlock(eraser, ColorSummon, i, j);
                    EraseBlock(eraser, ColorSummon, i, j + 1);
                }
            }
        CalcuComboScore(native);
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= m; j++)
                if (eraser[i][j])
                    a[i][j].color = 0;
        TotalScore += ColorSummon * rnd;
        PrintBy("System", "Got <erase> score " << ColorSummon * rnd << ".(" << TotalScore << ")");
        return 1;
    }
    void Gravity() { /* 重力 */
        PrintBy("System", "The Gravity!");
        for (int i = 1; i <= m; i++)
            for (int k = 1; k <= n; k++)
                for (int j = 1; j < n; j++)
                    if (a[j][i].color != 0 and a[j + 1][i].color == 0)
                        std::swap(a[j][i], a[j + 1][i]);
        //std::cout << "Screen After Gravity:\n";
        //PrintScreen();
    }
    void PrintScreen() { /* 输出屏幕。调试用的 */
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= m; j++)
                if (a[i][j].color != 0)
                    std::cout << "(" << a[i][j].color << ", " << a[i][j].extra << ")" << " \n"[j == m];
                else
                    std::cout << "Erased" << " \n"[j == m];
    }
    bool Swap(int xa, int ya, int xb, int yb) { /* 主流程 */
        if (abs(xa - xb) + abs(ya - yb) != 1) return 1;
        if (a[xa][ya].color == 0 or a[xb][yb].color == 0) return 1;
        std::swap(a[xa][ya], a[xb][yb]);
        std::vector<int> MainColor = CheckErase();
        if (MainColor.empty()) {
            std::swap(a[xa][ya], a[xb][yb]);
            return 1;
        }
        //std::cout << "Raw Screen:\n";
        //PrintScreen();
        elis.push_back(MainColor);
        int Round = 0;
        while (Erase(Round + 1)) {
            //std::cout << "After Erase round " << Round + 1 << ", now screen:\n";
            //PrintScreen();
            Round += 1;
            Gravity();
        }
        TotalScore += 80 * (Round - 1) * (Round - 1);
        PrintBy("System", "Got <chain-reaction> score " << 80 * (Round - 1) * (Round - 1) << ".(" << TotalScore << ")");
        return 0;
    }
    bool AllElimated() {
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= m; j++)
                if (a[i][j].color != 0)
                    return 0;
        return 1;
    }
    int Card(int v1, int v2, int v3, int v4, int v5) { /* 计算牌型分 */
        PrintBy("wordle", "The World by card!:" << v1 << v2 << v3 << v4 << v5);
        std::map<int, int> mp;
        mp[v1] += 1, mp[v2] += 1, mp[v3] += 1, mp[v4] += 1, mp[v5] += 1;
        if (mp.size() == 5)
            return 50 + std::max({v1, v2, v3, v4, v5});
        if (mp.size() == 4)
            for (auto i : mp)
                if (i.second == 2)
                    return 100 + i.first * 2;
        if (mp.size() == 3) {
            int typ = -1;
            for (auto i : mp)
                if (i.second == 3) {
                    typ = 1;
                    break;
                }
            if (typ == -1) {
                std::vector<int> dui;
                for (auto i : mp)
                    if (i.second == 2)
                        dui.emplace_back(i.first);
                return 200 + std::max(dui[0], dui[1]) * 2 + std::min(dui[0], dui[1]);
            } else
                for (auto i : mp)
                    if (i.second == 3)
                        return 300 + i.first * 3;
        }
        if (mp.size() == 2) {
            int typ = -1;
            for (auto i : mp)
                if (i.second == 4) {
                    typ = 1;
                    break;
                }
            if (typ == -1) {
                int sc = 500;
                for (auto i : mp)
                    if (i.second == 3)
                        sc += i.first * 3;
                    else
                        sc += i.first;
                return sc;
            } else 
                for (auto i : mp)
                    if (i.second == 4)
                        return 750 + i.first * 5;
        }
        if (mp.size() == 1)
            return 1000 + 10 * v1;
        return 0;
    }
    void Calcucard(int Rnd) { /* 计算牌型奖分的流程 */
        int mx = 0;
        //for (int i = -4; i <= 0; i++) {
         //   for (int j : elis[Rnd + i]) 
          //     std::cout << j << " ";
           //std::cout << "\n";
            //}
        for (auto i : elis[Rnd])
            for (auto j : elis[Rnd - 1])
                for (auto k : elis[Rnd - 2])
                    for (auto o : elis[Rnd - 3])
                        for (auto p : elis[Rnd - 4])
                            mx = std::max(mx, Card(i, j, k, o, p));
        TotalScore += mx;
        PrintBy("System", "Got <card-type> score " << mx << ".(" << TotalScore << ")");
    }
} G;
int main() {
    std::cin >> n >> m >> k >> q;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            std::cin >> G.a[i][j].color;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            std::cin >> G.a[i][j].extra;
    PrintBy("System", "Basic info has been inputed.");
    bool AllUsed = 1;
    int Rnd = 0, HaveBeenCalcuCard = 0;
    for (int i = 1; i <= q; i++) {
        int xa, xb, ya, yb;
        std::cin >> xa >> ya >> xb >> yb;
        PrintBy("System", "User operation " << i << " has been inputed(" << xa << ", " << ya << ", " << xb << ", " << yb << ").");
        bool x = G.Swap(xa, ya, xb, yb);
        if (x == 1) AllUsed = 0;
        if (x == 0) Rnd += 1; 
        if (Rnd % 5 == 0 and HaveBeenCalcuCard != Rnd) G.Calcucard(Rnd - 1), HaveBeenCalcuCard = Rnd;
    }
    if (AllUsed) {
        TotalScore += 1000;
        PrintBy("System", "Got <endy-map> score 1000.(" << TotalScore << ")");
    }
    bool gael = G.AllElimated();
    TotalScore += 10000 * gael;
    if (gael) PrintBy("System", "Got <endy-map> score 10000.(" << TotalScore << ")");
    std::cout << TotalScore;
    return 0;
}
```

---

## 作者：Miyamizu_Mitsuha (赞：4)


纪念一下第二道 THUPC 大模拟。

写了大概三个小时，调了一上午。

几个坑点：

- 注意连锁反应，所以你可能要写递归。

- 为了更方便，你可能要写 dfs 搜联通块。

- 牌型计分。我认为最大的坑点就是在这，不过也没什么技巧，五层循环就可以了。计分时建议先排序，这样更容易一些。

- 每一轮该清空时就清空。

- 输入的两个数组的操作都要同步进行，觉得不方便可以开一个结构体。

消除时的一个技巧就是新开一个数组先记录下来哪些要删除，然后再统一删除。

我的代码有大量的的注释，删除掉你就可以看到中间变量的输出，希望对你有所帮助。

码风优化，详细解释版本：
```
#include <iostream>
#include <algorithm>
using namespace std;

int n, m, k, q, sum = 0;
int a[55][55], e[55][55];
int mc[3][6] = {0};
int nowgo = 1;

void out() {
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++)
            cout << a[i][j] << " ";
        cout << endl;
    }
    cout << endl;
}

int correctmove(int x, int y, int x2, int y2) {
    if (a[x][y] == 0 || a[x2][y2] == 0) return 0;
    if (x < 1 || x > n || x2 < 1 || x2 > n || y < 1 || y > m || y2 < 1 || y2 > m) return 0;
    if (!((x == x2 && abs(y - y2) == 1) || (y == y2 && abs(x - x2) == 1))) return 0;//不合法的全部直接return
    swap(a[x][y], a[x2][y2]);
    int fg = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (a[i][j] != 0 && a[i][j] == a[i + 1][j] && a[i][j] == a[i + 2][j]) {
                fg = 1;
            }
            if (a[i][j] != 0 && a[i][j] == a[i][j + 1] && a[i][j] == a[i][j + 2]) {
                fg = 1;
            }
        }
    }//以上为判断能否产生新的消除
    swap(a[x][y], a[x2][y2]);//刚才只是为了判断，判断完了换回去
    if (fg == 0) return 0;
    else return 1;
}

void falls() { //重力下落
    for (int j = 1; j <= m; j++) {
        for (int i = n - 1; i >= 1; i--) {
            int k = i;
            if (a[k + 1][j] == 0) {
                while (a[k + 1][j] == 0) {//直到下面不是空的才停止下落
                    if (k + 1 > n) break;
                    swap(a[k + 1][j], a[k][j]);
                    swap(e[k + 1][j], e[k][j]);
                    k++;
                }
            }
        }
    }
}

int endg[55][55] = {0}, vis[55][55] = {0};//endg是保存整个这一轮有哪些被消除。vis是防止重复递归连锁反应

void eff(int i, int j, int s) {//特殊效果
    int bj[55][55] = {0};//保存这次反应有哪些格子应该被删除
    int nn = e[i][j];
    if (nn == 1) {
        for (int jj = 1; jj <= m; jj++) bj[i][jj] = 1;
    }
    if (nn == 2) {
        for (int jj = 1; jj <= n; jj++) bj[jj][j] = 1;
    }
    if (nn == 3) {
        for (int jj = 1; jj <= m; jj++) bj[i][jj] = 1;
        for (int jj = 1; jj <= n; jj++) bj[jj][j] = 1;
    }
    if (nn == 4) {
        for (int ii = i - 1; ii <= i + 1; ii++) {
            for (int jj = j - 1; jj <= j + 1; jj++) {
                if (ii >= 1 && ii <= n && jj >= 1 && jj <= m) bj[ii][jj] = 1;
            }
        }
    }
    if (nn == 5) {
        for (int ii = i - 2; ii <= i + 2; ii++) {
            for (int jj = j - 2; jj <= j + 2; jj++) {
                if (ii >= 1 && ii <= n && jj >= 1 && jj <= m) bj[ii][jj] = 1;
            }
        }
    }
    if (nn == 6) {
        for (int ii = 1; ii <= n; ii++) {
            for (int jj = 1; jj <= m; jj++) {
                if (a[i][j] == a[ii][jj]) bj[ii][jj] = 1;
            }
        }
    }
    for (int ii = 1; ii <= n; ii++) {
        for (int jj = 1; jj <= m; jj++) {
            if (bj[ii][jj] == 1) endg[ii][jj] = 1;
        }
    }
    if (nn != 0) {
        for (int ii = 1; ii <= n; ii++) {
            for (int jj = 1; jj <= m; jj++) {
                if (e[ii][jj] != 0 && bj[ii][jj] == 1 && vis[ii][jj] == 0) {
                    vis[ii][jj] = 1;//下次不用递归了
                    eff(ii, jj, s);//接着连锁反应
                }
            }
        }
    } else return;
}

int vis2[55][55] = {0};//搜连通块用
int kll[55][55] = {0};//保存搜连通块时那些应该被搜

int dfs(int i, int j, int n, int m) {
    if (i <= 0 || i > n || j <= 0 || j > m || vis2[i][j] == 1) {
        return 0;
    }
    int area = 1;
    vis2[i][j] = 1;
    if (kll[i + 1][j] == 1 && a[i + 1][j] == a[i][j]) {
        area += dfs(i + 1, j, n, m);
    }
    if (kll[i - 1][j] == 1 && a[i - 1][j] == a[i][j]) {
        area += dfs(i - 1, j, n, m);
    }
    if (kll[i][j + 1] == 1 && a[i][j + 1] == a[i][j]) {
        area += dfs(i, j + 1, n, m);
    }
    if (kll[i][j - 1] == 1 && a[i][j - 1] == a[i][j]) {
        area += dfs(i, j - 1, n, m);
    }
    return area;
}

void play(int step) {
    int kl[55][55] = {0}, fg = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (a[i][j] != 0 && a[i][j] == a[i + 1][j] && a[i][j] == a[i + 2][j]) {
                kl[i][j] = 1, kl[i + 1][j] = 1, kl[i + 2][j] = 1;
                fg = 1;
            }
            if (a[i][j] != 0 && a[i][j] == a[i][j + 1] && a[i][j] == a[i][j + 2]) {
                kl[i][j] = 1, kl[i][j + 1] = 1, kl[i][j + 2] = 1;
                fg = 1;
            }
        }
    }//初步找出能直接被消除的
    for (int i = 0; i < 55; i++) {
        for (int j = 0; j < 55; j++) kll[i][j] = 0;
    }//每次要清空
    for (int i = 1; i <= 54; i++) {
        for (int j = 1; j <= 54; j++) kll[i][j] = kl[i][j];
    }//kl是内部的，kll是外部的（被联通块查找所用）
    for (int i = 0; i < 55; i++) for (int j = 0; j < 55; j++) vis2[i][j] = 0;
    for (int i = 0; i < 55; i++) for (int j = 0; j < 55; j++) endg[i][j] = 0, vis[i][j] = 0;//每轮都要先清空
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (kl[i][j]) {//如果这个能被消除
                eff(i, j, step);//那就去查一下他的特殊效果&连锁反应
                endg[i][j] = 1;//标记为最终可以消除的
            }
        }
    }
    int fff = 1;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (kl[i][j] && vis2[i][j] == 0) {//如果可以被消除并且没访问过
                int gp = dfs(i, j, n, m);//搜到的联通块大小
                if (gp >= 3) {//大于等于3才是有意义的
                    if (fff && step == 1) mc[1][nowgo] = a[i][j], fff = 0;//mc数组存主颜色
                    else if (step == 1) mc[2][nowgo] = a[i][j];
                    sum += (50 * (gp - 3) * (gp - 3));
                }
            }
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (endg[i][j] == 1) {
                sum += (a[i][j] * step);
                a[i][j] = 0, e[i][j] = 0;
            }
        }
    }//最后总结，消除
    falls();//重力落下
    if (fg == 1) play(step + 1);//如果这次还能消除，那就递归下一次
    else {
        sum += ((step - 2) * (step - 2) * 80);//这里减2的原因是递归的时候判断这次不能消除了才会结束，所以真正不能消除了的是上次，额外减1
        return;
    }
}

int js(int aa, int bb, int cc, int dd, int ee) {//计算牌型分
    if (aa == 0 || bb == 0 || cc == 0 || dd == 0 || ee == 0) return 0;//少牌直接return
    int qk[10];
    qk[1] = aa, qk[2] = bb, qk[3] = cc, qk[4] = dd, qk[5] = ee;
    sort(qk + 1, qk + 6);//先排序，判断方便
    aa = qk[1], bb = qk[2], cc = qk[3], dd = qk[4], ee = qk[5];
    int llj = 1, lj = 1;
    for (int i = 2; i <= 5; i++) {
        if (qk[i] == qk[i - 1]) llj++;
        else lj = max(lj, llj), llj = 1;
    }
    lj = max(lj, llj);
    //lj存最大连续子段长
    if (lj == 5)
    {
        return 1000 + aa * 10;
    }
    if (lj == 1)
    {
        return 50 + ee;
    }
    if (lj == 2) {
        if (aa == bb && cc != dd && cc != ee && dd != ee) {
            return 100 + aa * 2;
        }
        if (cc == bb && aa != dd && aa != ee && dd != ee) {
            return 100 + bb * 2;
        }
        if (cc == dd && aa != bb && aa != ee && bb != ee) {
            return 100 + cc * 2;
        }
        if (ee == dd && aa != bb && aa != cc && bb != cc) {
            return 100 + dd * 2;
        }
        if (aa == bb && cc == dd) {
            return 200 + cc * 2 + aa;
        }
        if (aa == bb && dd == ee) {
            return 200 + dd * 2 + aa;
        }
        if (cc == bb && dd == ee) {
            return 200 + dd * 2 + cc;
        }
    }
    if (lj == 3) {
        if (aa == bb && aa == cc && dd != ee) {
            return 300 + cc * 3;
        }
        if (bb == cc && dd == cc && aa != ee) {
            return 300 + cc * 3;
        }
        if (cc == ee && dd == cc && aa != bb) {
            return 300 + cc * 3;
        }
        if (aa == bb && aa == cc && dd == ee) {
            return 500 + cc * 3 + ee;
        }
        if (bb == cc && dd == cc && aa == ee) {
            return 500 + cc * 3 + ee;
        }
        if (cc == ee && dd == cc && aa == bb) {
            return 500 + cc * 3 + aa;
        }
    }
    if (lj == 4) {
        if (aa == dd) {
            return 750 + cc * 5;
        }
        if (bb == ee) {
            return 750 + cc * 5;
        }
    }
    return 0;
    //以上均为常规计算，按规则来就行
}

int main() {
    int ep = 1, cm = 0;//ep存是否全是有效操作，cm存第几次操作
    cin >> n >> m >> k >> q;
    for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) cin >> a[i][j];
    for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) cin >> e[i][j];
    while (q--) {
        int x, x2, y, y2;
        cin >> x >> y >> x2 >> y2;
        if (correctmove(x, y, x2, y2)) {
            cm++;
            swap(a[x][y], a[x2][y2]);
            swap(e[x][y], e[x2][y2]);

            play(1);
            nowgo++;
            int maxx = 0;

            if (cm == 5) {
                for (int i2 = 1; i2 <= 2; i2++) {
                    for (int i3 = 1; i3 <= 2; i3++) {
                        for (int i4 = 1; i4 <= 2; i4++) {
                            for (int i5 = 1; i5 <= 2; i5++) {
                                for (int i6 = 1; i6 <= 2; i6++) {
                                    maxx = max(maxx, js(mc[i2][1], mc[i3][2], mc[i4][3], mc[i5][4], mc[i6][5]));
                                }
                            }
                        }
                    }
                }//五层循环算最大分
                sum += maxx;
                for (int i = 1; i <= 5; i++) mc[1][i] = 0;
                for (int i = 1; i <= 5; i++) mc[2][i] = 0;

                cm = 0;
                nowgo = 1;
                //每五个一循环，循环完了全部清空
            }
        } else ep = 0;//有不合法的那一千的加分就没有了
    }
    int ffg = 1;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (a[i][j] != 0) ffg = 0;//有没清空的终局分就没了
        }
    }
    sum += (ep * 1000 + ffg * 10000);//加上终局分
    cout << sum;
    return 0;
}

```

加输出中间变量版：

[https://www.luogu.com.cn/paste/ba3boybm](https://www.luogu.com.cn/paste/ba3boybm)


---

## 作者：SuperCowHorse (赞：4)

> 纪念我写出的第三道大模拟。——德州消消乐

---

[题目传送门](https://www.luogu.com.cn/problem/P8422)。

题目很简单，其实只要直接按题意模拟就能过了。

~~废话。~~

那我们就一个个模块来看吧！

注意：与我的麻将模拟器题解相同（在洛谷博客里），一些前面没有的函数我会在后面讲到，因为我认为按照这篇文章的顺序会更容易理解，作者语文不好，敬请谅解。

还有，注释直接略过即可。~~不想删了。~~

首先是读入。我拿了一个数组 $Map$ 存放每一个方块的颜色，$Spe$ 表示特殊的技能。

```cpp
inline void input(){
    scanf("%d%d%d%d",&n,&m,&k,&Q);
    for(int i=1;i<=n;++i){
        for(int j=1;j<=m;++j){
            scanf("%d",&Map[i][j]);
        }
    }
    for(int i=1;i<=n;++i){
        for(int j=1;j<=m;++j){
            scanf("%d",&Spe[i][j]);
        }
    }
}
```

然后就是按题意模拟了。

```cpp
for(int q=1;q<=Q;++q)
```

首先，我们需要判断操作是否合法。

不合法有 $4$ 种情况：

1. 超出边界。

2. 两点不相邻。

3. 两点之间任意一个点是空气。

4. 两点交换后无法引起消除。

直接模拟即可。

```cpp
int sx,sy,ex,ey;
scanf("%d%d%d%d",&sx,&sy,&ex,&ey);
if(!Check(sx,sy,ex,ey)){
    Flg=1;//统计终局奖分要用
    continue;
}
```

以下是 $\operatorname{Check}$ 函数：

```cpp
inline bool Over(int x,int y){//判读是否超出边界
    return (x>=1&&x<=n&&y>=1&&y<=m);
}
inline int Dist(int sx,int sy,int ex,int ey){//判断距离是多少
    return abs(sx-ex)+abs(sy-ey);
}
inline bool Judge1(int x,int y){//判断一个方块在不在一个三色连通块中，这个待会儿还有用
    if(Map[x][y]==0) return 0;
    if(Same(x,y,0,1)&&Same(x,y,0,-1)){
        return 1;
    }
    if(Same(x,y,0,2)&&Same(x,y,0,1)){
        return 1;
    }
    if(Same(x,y,0,-2)&&Same(x,y,0,-1)){
        return 1;
    }
    if(Same(x,y,1,0)&&Same(x,y,-1,0)){
        return 1;
    }
    if(Same(x,y,2,0)&&Same(x,y,1,0)){
        return 1;
    }
    if(Same(x,y,-2,0)&&Same(x,y,-1,0)){
        return 1;
    }
    return 0;
}
inline bool Check(int sx,int sy,int ex,int ey){//判断是否合法
    if(!Over(sx,sy)||!Over(ex,ey)) return 0;//
    if(Dist(sx,sy,ex,ey)!=1) return 0;
    if(Map[sx][sy]==0||Map[ex][ey]==0) return 0;
    swap(Map[sx][sy],Map[ex][ey]);
    swap(Spe[sx][sy],Spe[ex][ey]);
    bool p=Judge();
    swap(Map[sx][sy],Map[ex][ey]);
    swap(Spe[sx][sy],Spe[ex][ey]);
    return p;
}
```

然后就是消除了。由于可能会有连锁消除的发生，我们需要将函数写成递归的形式。具体见代码。

```cpp
++Now;
ans+=80ll*sqr(Remove(1,sx,sy,ex,ey)-1);//Remove 函数是消除方块的意思，统计连锁奖分
```

$\operatorname{Remove}$ 函数实现：

```cpp
inline int Remove(int Query,int sx,int sy,int ex,int ey){//消除
    pair<int,int>P;//记录颜色
    memset(vis,0,sizeof(vis));//记录这一轮内是否被消除
    if(sx!=-1){//如果是第一次消除，则要统计主颜色（MainColor）
        P=(pair<int,int>)mp(-1,-1);
        swap(Map[sx][sy],Map[ex][ey]);
        swap(Spe[sx][sy],Spe[ex][ey]);
        if(Judge1(sx,sy)){
            if(P.first==-1){
                P.first=Map[sx][sy];
            }
            else{
                P.second=Map[sx][sy];
            }
        }
        if(Judge1(ex,ey)){
            if(P.first==-1){
                P.first=Map[ex][ey];
            }
            else{
                P.second=Map[ex][ey];
            }
        }
        MaCol.push_back(P);//统计主颜色
    }
    for(int i=1;i<=n;++i){
        for(int j=1;j<=m;++j){
            if(!vis[i][j]&&Judge1(i,j)){//如果还没被消除并且在一个三色连通块中
                ans+=50*sqr(bfs(i,j)-3);//统计组合奖分
            }
        }
    }
    ll sum=0;//统计被消除颜色之和，方便计算消除奖分
    bool fl=1;
    while(fl==1){
        fl=0;
        for(int i=1;i<=n;++i){
            for(int j=1;j<=m;++j){
                if(vis[i][j]){
                    fl=1;
                    Update(i,j,Spe[i][j]);//如果有技能，就放出来
                    sum+=1ll*Map[i][j];
                    Map[i][j]=0;Spe[i][j]=0;
                    vis[i][j]=0;
                }
            }
        }
    }
    ans+=1ll*Query*sum;//统计消除奖分
    Drop();//下落
    int res=0;
    if(Judge()){
        res=Remove(Query+1,-1,-1,-1,-1);//深度加一，继续递归
    }
    return res+1;
}
```

现在在 $\operatorname{Remove}$ 函数中还咕咕咕的函数有：$\operatorname{bfs,Update,Drop}$。

先来说 $\operatorname{bfs}$。

作用：顾名思义，找到某一个点所在的连通块，并返回连通块大小，统计组合奖分。

```cpp
inline int bfs(int sx,int sy){
    int res=0;
    queue<pair<int,int> >q;
    q.push(mp(sx,sy));vis[sx][sy]=1;
    while(!q.empty()){
        pair<int,int>p=q.front();
        int x=p.first;
        int y=p.second;
        q.pop();++res;//统计连通块大小
        for(int i=0;i<4;++i){
            int xx=x+dx[i];
            int yy=y+dy[i];
            if(!Over(xx,yy)) continue;//超出边界
            if(vis[xx][yy]||Map[x][y]!=Map[xx][yy]) continue;//颜色或已经访问不同
            if(!Judge1(xx,yy)) continue;//如果不在同一个三色连通块内
            q.push(mp(xx,yy));vis[xx][yy]=1;//标记
        }
//        Update(x,y,Spe[x][y]);
    }
    return res;
}
```

下一个就是 $\operatorname{Update}$ 了。

作用：释放有特殊技能的方块，并消除。

```cpp
inline void Update1(int x,int y){//同一行
    for(int j=1;j<=m;++j){
//        Update(x,j,Spe[x][j]);
        vis[x][j]=1;
    }
}
inline void Update2(int x,int y){//同一列
    for(int i=1;i<=n;++i){
//        Update(i,y,Spe[i][y]);
        vis[i][y]=1;
    }
}
inline void Update3(int x,int y){//同一行和同一列
    for(int j=1;j<=m;++j){
//        Update(x,j,Spe[x][j]);
        vis[x][j]=1;
    }
    for(int i=1;i<=n;++i){
//        Update(i,y,Spe[i][y]);
        vis[i][y]=1;
    }
}
inline void Update4(int x,int y){//3*3正方形
    for(int i=x-1;i<=x+1;++i){
        for(int j=y-1;j<=y+1;++j){
            if(!Over(i,j)) continue;
//            Update(i,j,Spe[i][j]);
            vis[i][j]=1;
        }
    }
}
inline void Update5(int x,int y){//5*5正方形
    for(int i=x-2;i<=x+2;++i){
        for(int j=y-2;j<=y+2;++j){
            if(!Over(i,j)) continue;
//            Update(i,j,Spe[i][j]);
            vis[i][j]=1;
        }
    }
}
inline void Update6(int x,int y){//所有相同颜色
    for(int i=1;i<=n;++i){
        for(int j=1;j<=m;++j){
            if(Map[i][j]==Map[x][y]){
//                Update(i,j,Spe[i][j]);
                vis[i][j]=1;
            }
        }
    }
}
inline void Update(int x,int y,int op){
//    if(vis[x][y]) return;
    switch(op){
        case 0:{
            break;
        }
        case 1:{
            Update1(x,y);
            break;
        }
        case 2:{
            Update2(x,y);
            break;
        }
        case 3:{
            Update3(x,y);
            break;
        }
        case 4:{
            Update4(x,y);
            break;
        }
        case 5:{
            Update5(x,y);
            break;
        }
        case 6:{
            Update6(x,y);
            break;
        }
    }
    Spe[x][y]=0;//更新完了就清零
}
```

还有 $\operatorname{Drop}$。

作用：方块下落。

没啥好说的，直接模拟就行。~~这不就是大模拟吗。~~

```cpp
inline void Drop(){//下落
    for(int j=1;j<=m;++j){
        for(int i=n-1;i>=1;--i){
            int now=i;
            while(now<n&&Map[now+1][j]==0&&Map[now][j]!=0){//模拟空节点
                swap(Map[now+1][j],Map[now][j]);//交换
                swap(Spe[now+1][j],Spe[now][j]);
                ++now;
            }

        }
    }
}
```

然后每 $5$ 轮统计牌型奖分。

由于我们已经预处理好了主颜色，最多只有 $2^5=32$ 种可能，直接 $\operatorname{dfs}$ 枚举排列即可。

```cpp
if(Now%5==0){//每 5 轮统计一次
    ans+=1ll*Clac();
    MaCol.clear();
}
```

$\operatorname{Clac}$ 和 $\operatorname{dfs}$ 函数：

```cpp
inline void dfs(int x){//枚举全排列
    if(x==5){
        res=max(res,clac());
        for(int i=1;i<=5;++i){//注意：一定要存 c 数组！不然排序后 c 数组会改变！！3h 的教训 
            c[i]=r[i];
        }
        return;
    }
    if(MaCol[x].first!=-1){
        c[++tot]=MaCol[x].first;
        dfs(x+1);
        --tot;
    }
    if(MaCol[x].second!=-1){
        c[++tot]=MaCol[x].second;
        dfs(x+1);
        --tot;
    }
}
inline int Clac(){//求最大牌型值
    res=-1;
    dfs(0);
    return res;
}
```

统计牌型时，先把所有不同的牌丢进 `vector` 里，然后统计开一个桶，统计每一个数出现几次。

讨论 `vector` 元素容量：

1. 容量为 $1$：$5$ 个相同，凑成五条。

2. 容量为 $2$：讨论：
   
   - 若有相同的 $4$ 个元素，凑成四条。
   
   - 否则是葫芦。

3. 容量为 $3$：讨论：
   
   - 若有相同的 $3$ 个元素，凑成三条。
   
   - 否则是两对。

4. 容量为 $4$，凑成一对。

5. 容量为 $5$，凑成高牌。

```cpp
inline int clac(){
    for(int i=1;i<=5;++i){//存 c 数组
        r[i]=c[i];
    }
    sort(c+1,c+6);//排序
    map<int,int>p;
    vector<int>q;
    for(int i=1;i<=5;++i){//用桶统计
        ++p[c[i]];
    }
    for(int i=1;i<=5;++i){//将没有压入过的压入vector
        if(p[c[i]]<=5){
            q.push_back(p[c[i]]);
            p[c[i]]+=5;
        }
    }
    for(int i=1;i<=5;++i){
        if(p[c[i]]>5){
            p[c[i]]-=5;
        }
    }
    //枚举vector的容量
    if(q.size()==5){
        return 50+c[5];
    }
    if(q.size()==4){
        for(int i=1;i<=5;++i){
            if(p[c[i]]==2){
                return 100+c[i]*2;
            }
        }
    }
    if(q.size()==3){
        int mx=-1,mn=1e9;
        for(int i=1;i<=5;++i){
            if(p[c[i]]==3){
                return 300+c[i]*3;
            }
            if(p[c[i]]==2){
                mx=max(mx,c[i]);
                mn=min(mn,c[i]);
            }
        }
        return 200+mx*2+mn;
    }
    if(q.size()==2){
        int u=-1,v=-1;
        for(int i=1;i<=5;++i){
            if(p[c[i]]==4){
                return 750+c[i]*5;
            }
            if(p[c[i]]==3){
                u=c[i];
            }
            if(p[c[i]]==2){
                v=c[i];
            }
        }
        return 500+u*3+v;
    }
    if(q.size()==1){
        return 1000+c[1]*10;
    }
    return 114514;//不返回会报错
}
```

终局奖分直接统计就行。

```cpp
if(!Flg){
    ans+=1000;
}
if(Chk()){
    ans+=10000;
}
```

没了？

没了。

完整代码：

```cpp
//CowHorse
#include<bits/stdc++.h>
using namespace std;

//----------Set----------

//Define.
#define pb push_back
#define mp make_pair
#define fi first
#define se second

//Typedef.
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
typedef unsigned int ui;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef vector<pii> vpii;
typedef vector<pll> vpll;
typedef map<int,int> mii;
typedef map<int,bool> mib;
typedef map<string,int> msi;
typedef map<string,bool> msb;
typedef map<pii,pii> mpp;

//Const.
const int maxn=55;
const int maxm=1e5+5;
const ll inf=0x3f3f3f3f;
const int mod=998244353;
const ld eps=1e-6;
const ld dl=0.9969;
const int dx[]={-1,0,1,0};
const int dy[]={0,1,0,-1};

//----------Finished----------
int n,m,k,Q,Now;ll ans;
vector<pair<int,int> >MaCol;
bool vis[maxn][maxn];
int Map[maxn][maxn],Spe[maxn][maxn];
inline int sqr(int x){
    return x*x;
}
inline void input(){
    scanf("%d%d%d%d",&n,&m,&k,&Q);
    for(int i=1;i<=n;++i){
        for(int j=1;j<=m;++j){
            scanf("%d",&Map[i][j]);
        }
    }
    for(int i=1;i<=n;++i){
        for(int j=1;j<=m;++j){
            scanf("%d",&Spe[i][j]);
        }
    }
}
inline int Dist(int sx,int sy,int ex,int ey){
    return abs(sx-ex)+abs(sy-ey);
}
inline bool Judge(){
    for(int i=1;i<n-1;++i){
        for(int j=1;j<=m;++j){
            if(Map[i][j]==Map[i+1][j]&&Map[i][j]==Map[i+2][j]&&Map[i][j]!=0){
                return 1;
            }
        }
    }
    for(int i=1;i<=n;++i){
        for(int j=1;j<m-1;++j){
            if(Map[i][j]==Map[i][j+1]&&Map[i][j]==Map[i][j+2]&&Map[i][j]!=0){
                return 1;
            }
        }
    }
    return 0;
}
inline bool Over(int x,int y){
    return (x>=1&&x<=n&&y>=1&&y<=m);
}
inline bool Same(int x,int y,int dx,int dy){
//    printf("%d %d %d %d\n",x,y,x+dx,y+dy);
    if(!Over(x+dx,y+dy)||!Over(x,y)) return 0;
    return Map[x][y]==Map[x+dx][y+dy];
}
inline bool Judge1(int x,int y){
    if(Map[x][y]==0) return 0;
    if(Same(x,y,0,1)&&Same(x,y,0,-1)){
        return 1;
    }
    if(Same(x,y,0,2)&&Same(x,y,0,1)){
        return 1;
    }
    if(Same(x,y,0,-2)&&Same(x,y,0,-1)){
        return 1;
    }
    if(Same(x,y,1,0)&&Same(x,y,-1,0)){
        return 1;
    }
    if(Same(x,y,2,0)&&Same(x,y,1,0)){
        return 1;
    }
    if(Same(x,y,-2,0)&&Same(x,y,-1,0)){
        return 1;
    }
    return 0;
}
inline bool Check(int sx,int sy,int ex,int ey){
    if(!Over(sx,sy)||!Over(ex,ey)) return 0;
    if(Dist(sx,sy,ex,ey)!=1) return 0;
    if(Map[sx][sy]==0||Map[ex][ey]==0) return 0;
    swap(Map[sx][sy],Map[ex][ey]);
    swap(Spe[sx][sy],Spe[ex][ey]);
    bool p=Judge();
    swap(Map[sx][sy],Map[ex][ey]);
    swap(Spe[sx][sy],Spe[ex][ey]);
    return p;
}
inline void Drop(){
    for(int j=1;j<=m;++j){
        for(int i=n-1;i>=1;--i){
            int now=i;
            while(now<n&&Map[now+1][j]==0&&Map[now][j]!=0){
                swap(Map[now+1][j],Map[now][j]);
                swap(Spe[now+1][j],Spe[now][j]);
                ++now;
            }
        }
    }
}
inline void Update(int x,int y,int op);
inline void Update1(int x,int y){
    for(int j=1;j<=m;++j){
//        Update(x,j,Spe[x][j]);
        vis[x][j]=1;
    }
}
inline void Update2(int x,int y){
    for(int i=1;i<=n;++i){
//        Update(i,y,Spe[i][y]);
        vis[i][y]=1;
    }
}
inline void Update3(int x,int y){
    for(int j=1;j<=m;++j){
//        Update(x,j,Spe[x][j]);
        vis[x][j]=1;
    }
    for(int i=1;i<=n;++i){
//        Update(i,y,Spe[i][y]);
        vis[i][y]=1;
    }
}
inline void Update4(int x,int y){
    for(int i=x-1;i<=x+1;++i){
        for(int j=y-1;j<=y+1;++j){
            if(!Over(i,j)) continue;
//            Update(i,j,Spe[i][j]);
            vis[i][j]=1;
        }
    }
}
inline void Update5(int x,int y){
    for(int i=x-2;i<=x+2;++i){
        for(int j=y-2;j<=y+2;++j){
            if(!Over(i,j)) continue;
//            Update(i,j,Spe[i][j]);
            vis[i][j]=1;
        }
    }
}
inline void Update6(int x,int y){
    for(int i=1;i<=n;++i){
        for(int j=1;j<=m;++j){
            if(Map[i][j]==Map[x][y]){
//                Update(i,j,Spe[i][j]);
                vis[i][j]=1;
            }
        }
    }
}
inline void Update(int x,int y,int op){
//    if(vis[x][y]) return;
    switch(op){
        case 0:{
            break;
        }
        case 1:{
            Update1(x,y);
            break;
        }
        case 2:{
            Update2(x,y);
            break;
        }
        case 3:{
            Update3(x,y);
            break;
        }
        case 4:{
            Update4(x,y);
            break;
        }
        case 5:{
            Update5(x,y);
            break;
        }
        case 6:{
            Update6(x,y);
            break;
        }
    }
    Spe[x][y]=0;
}
inline int bfs(int sx,int sy){
    int res=0;
    queue<pair<int,int> >q;
    q.push(mp(sx,sy));vis[sx][sy]=1;
    while(!q.empty()){
        pair<int,int>p=q.front();
        int x=p.first;
        int y=p.second;
        q.pop();++res;
        for(int i=0;i<4;++i){
            int xx=x+dx[i];
            int yy=y+dy[i];
            if(!Over(xx,yy)) continue;
            if(vis[xx][yy]||Map[x][y]!=Map[xx][yy]) continue;
            if(!Judge1(xx,yy)) continue;
            q.push(mp(xx,yy));vis[xx][yy]=1;
        }
//        Update(x,y,Spe[x][y]);
    }
    return res;
}
inline int Remove(int Query,int sx,int sy,int ex,int ey){
    pair<int,int>P;
    memset(vis,0,sizeof(vis));
    if(sx!=-1){
        P=(pair<int,int>)mp(-1,-1);
        swap(Map[sx][sy],Map[ex][ey]);
        swap(Spe[sx][sy],Spe[ex][ey]);
        if(Judge1(sx,sy)){
            if(P.first==-1){
                P.first=Map[sx][sy];
            }
            else{
                P.second=Map[sx][sy];
            }
        }
        if(Judge1(ex,ey)){
            if(P.first==-1){
                P.first=Map[ex][ey];
            }
            else{
                P.second=Map[ex][ey];
            }
        }
        MaCol.push_back(P);
    }
    for(int i=1;i<=n;++i){
        for(int j=1;j<=m;++j){
            if(!vis[i][j]&&Judge1(i,j)){
                ans+=50*sqr(bfs(i,j)-3);
            }
        }
    }
    ll sum=0;
    bool fl=1;
    while(fl==1){
        fl=0;
        for(int i=1;i<=n;++i){
            for(int j=1;j<=m;++j){
                if(vis[i][j]){
                    fl=1;
                    Update(i,j,Spe[i][j]);
                    sum+=1ll*Map[i][j];
                    Map[i][j]=0;Spe[i][j]=0;
                    vis[i][j]=0;
                }
            }
        }
    }
    ans+=1ll*Query*sum;
    Drop();
    int res=0;
    if(Judge()){
        res=Remove(Query+1,-1,-1,-1,-1);
    }
    return res+1;
}
int res;
int c[7],tot,r[7];
inline int clac(){
    for(int i=1;i<=5;++i){
        r[i]=c[i];
    }
    sort(c+1,c+6);
    map<int,int>p;
    vector<int>q;
    for(int i=1;i<=5;++i){
        ++p[c[i]];
    }
    for(int i=1;i<=5;++i){
        if(p[c[i]]<=5){
            q.push_back(p[c[i]]);
            p[c[i]]+=5;
        }
    }
    for(int i=1;i<=5;++i){
        if(p[c[i]]>5){
            p[c[i]]-=5;
        }
    }
    if(q.size()==5){
        return 50+c[5];
    }
    if(q.size()==4){
        for(int i=1;i<=5;++i){
            if(p[c[i]]==2){
                return 100+c[i]*2;
            }
        }
    }
    if(q.size()==3){
        int mx=-1,mn=1e9;
        for(int i=1;i<=5;++i){
            if(p[c[i]]==3){
                return 300+c[i]*3;
            }
            if(p[c[i]]==2){
                mx=max(mx,c[i]);
                mn=min(mn,c[i]);
            }
        }
        return 200+mx*2+mn;
    }
    if(q.size()==2){
        int u=-1,v=-1;
        for(int i=1;i<=5;++i){
            if(p[c[i]]==4){
                return 750+c[i]*5;
            }
            if(p[c[i]]==3){
                u=c[i];
            }
            if(p[c[i]]==2){
                v=c[i];
            }
        }
        return 500+u*3+v;
    }
    if(q.size()==1){
        return 1000+c[1]*10;
    }
    return 114514;
}
inline void dfs(int x){
    if(x==5){
        res=max(res,clac());
        for(int i=1;i<=5;++i){
            c[i]=r[i];
        }
        return;
    }
    if(MaCol[x].first!=-1){
        c[++tot]=MaCol[x].first;
        dfs(x+1);
        --tot;
    }
    if(MaCol[x].second!=-1){
        c[++tot]=MaCol[x].second;
        dfs(x+1);
        --tot;
    }
}
inline int Clac(){
    res=-1;
    dfs(0);
    return res;
}
inline bool Chk(){
    for(int i=1;i<=n;++i){
        for(int j=1;j<=m;++j){
            if(Map[i][j]!=0){
                return 0;
            }
        }
    }
    return 1;
}
bool Flg;
inline void Debug(){
    putchar('\n');
    for(int i=1;i<=n;++i){
        for(int j=1;j<=m;++j){
            printf("%d%c",Map[i][j]," \n"[j==m]);
        }
    }
    putchar('\n');
//    for(int i=1;i<=n;++i){
//        for(int j=1;j<=m;++j){
//            printf("%d%c",Spe[i][j]," \n"[j==m]);
//        }
//    }
}
inline void Playing(){
    for(int q=1;q<=Q;++q){
        int sx,sy,ex,ey;
        scanf("%d%d%d%d",&sx,&sy,&ex,&ey);
        if(!Check(sx,sy,ex,ey)){
            Flg=1;
            continue;
        }
        ++Now;
        ans+=80ll*sqr(Remove(1,sx,sy,ex,ey)-1);
//        printf("%d\n",ans);
        if(Now%5==0){
//            for(int i=0;i<5;++i){
//                printf("%d %d\n",MaCol[i].first,MaCol[i].second);
//            }
            ans+=1ll*Clac();
            MaCol.clear();
        }
//        printf("C%d\n",ans);
//        printf("%lld\n",ans);
//        Debug();
    }
    if(!Flg){
        ans+=1000;
    }
    if(Chk()){
        ans+=10000;
    }
    printf("%lld",ans);
}
inline void solve(){
    input();
    Playing();
}
signed main(){
    int T=1;
    for(;T;--T) solve();
    return 0;
}
```


---

## 作者：YBH2179 (赞：3)

#### 注意：本题解包含了对于具体得分变化情况的输出（就是说你可以拿去调试用），并且会具体讲解每个部分的实现（6k代码警告）

### 前言

首先这是一道大模拟。

对于这道题，非常好做的地方在于层次划分很干净，于是读完一遍题之后可以先把整个主函数打出来，然后慢慢打各个部分。

### Part 1：定义、输入、主函数

可以发现，一次消除结束之后棋子才会统一下落，所以可以用一个标记来标记即将被消除的棋子。

然后根据这个思路，读题理清主要步骤：

尝试交换两个棋子 -> 交换失败

尝试交换两个棋子 -> 交换成功（进入循环） => 标记此轮非特殊消除棋子 -> 计算**组合分数** -> 标记此轮特殊消除棋子（特殊消除依靠非特殊消除带动，所以可以排在这里） -> 计算**消除分数** -> 棋子下落 -> 检查下一轮非特殊消除棋子（如果没有则退出循环） => 计算**连锁分数** -> 计算**牌型分数**（如果可以的话）

以下 Part 则以此顺序区分。

代码里面有详细注释：

```
#include<bits/stdc++.h> //定义变量部分（有一些全局变量没有在这里给出来，到了对应部分会拿出来说的）
using namespace std;
struct xa{
	int w,sp,x; // w:颜色 sp:特殊能力 x:消除标记
};
int n,m,k,q,ax,ay,bx,by,ac=1,ans; // ac:记录终局分数，若出现无效操作则变为0
xa a[101][101];

void Input(){ //输入部分
	int i,j;
	for(i=1;i<=n;i++) for(j=1;j<=m;j++) cin>>a[i][j].w;
	for(i=1;i<=n;i++) for(j=1;j<=m;j++) cin>>a[i][j].sp;
}

int main() 
{
	int i,j;
	cin>>n>>m>>k>>q;
	Input();
	while(q--){
		cin>>ax>>ay>>bx>>by;
		if(!Right()) {ac=0; continue;} //简单判断交换是否合法（这里为了更好写把判断拆成了两部分，这里只是判断了交换本身的合法性，未判断交换后是否可以造成消除）
		Exchange(); //交换，以及交换后消除与下落的循环
		PaiXingPoint(); //计算牌型分数
	}
	ZhongJuPoint(); //计算终局分数
	cout<<ans;
	return 0;
}
```

至于上面提到的循环则在 Exchange() 函数里面。

### Part 1.5：简单判断合法性、主要循环

```
bool Right(){ //简单判断合法性
	int i,j=0;
	if(abs(ax-bx)==1 && ay==by) j=1;
	if(abs(ay-by)==1 && ax==bx) j=1; //是否相邻
	if(a[ax][ay].w==0 || a[bx][by].w==0) j=0; //是否交换到没有棋子的位置（即w=0）
	return j; 
}

int pw[6][3],pwm; //pw用来记录主颜色（影响牌型分数），pwm为指针，每5轮归零一次

void Exchange(){ //主要循环
	int i,j,av=0,r=1; // av:可以被消除的棋子数 r:当前轮数
	swap(a[ax][ay],a[bx][by]);
	pwm++;
	av+=FSCheck(ax,ay,a[ax][ay].w,1); av+=FSCheck(bx,by,a[bx][by].w,2); //交换后单独检查，可以用来判断交换是否成功，这一次交换若成功则将决定交换的主颜色
	while(av!=0){
		ZuHePoint(); //计算组合分数
		SPCheck(); //特殊消除检查
		XiaoChuPoint(r); //计算消除分数
		Fall(); //棋子下落
		r++; //轮数+1
		av=CMCheck(); //下一轮非特殊消除检查
	}
	if(r==1){ //如果交换失败，准备料理后事
		//cout<<"##### Wrong Step #####"<<endl;
		ac=0; swap(a[ax][ay],a[bx][by]); //终局分数失效，以及换回去
		pwm--; //不计入主颜色统计（你在前面++了pwm）
		return;
	}
	LianSuoPoint(r-1); //计算连锁分数
}
```

### Part 2：对一个格子的非特殊消除检查

交换成功之后的两个格子你需要进行一次检查，可以正好封在这个函数里面，当然进入消除和下落的循环之后，则需要给每个格子都执行一遍此函数。

```
int FSCheck(int x,int y,int c,int op){ //若op!=0则代表是交换成功之后的检查，在后面会影响主颜色
	int i,j,xr=-1,yr=-1,av=0;// xr yr:横纵两向联通同色块数，因为在两个循环都要算一遍自己，所以初始化为-1 av:可消除棋子数量
	i=x; while(a[i][y].w==c) {i--; xr++;} //这四行分别向四个方向延伸，寻找能否3/4/5连消
	i=x; while(a[i][y].w==c) {i++; xr++;}
	i=y; while(a[x][i].w==c) {i--; yr++;}
	i=y; while(a[x][i].w==c) {i++; yr++;}
	if(xr>=3){ //至少三连才能消
		av+=xr;
		i=x; while(a[i][y].w==c) {a[i][y].x=1; i++;} //打上消除标记
		i=x; while(a[i][y].w==c) {a[i][y].x=1; i--;}
	}
	if(yr>=3){
		av+=yr;
		i=y; while(a[x][i].w==c) {a[x][i].x=1; i++;}
		i=y; while(a[x][i].w==c) {a[x][i].x=1; i--;}
	}
	if(op==1) if(av) pw[pwm][1]=c; else pw[pwm][1]=0; //如果能消，分别记录两个可能的主颜色
	if(op==2) if(av) pw[pwm][2]=c; else pw[pwm][2]=0;
	return av;
}
```

### Part 3：计算组合分数

用 Dfs 即可（主要是比 Bfs 好写，懒），以及一定要理清楚一个棋子被算在组合分数里的三个条件。

```
int vis[101][101]; //记录去过的棋子（由于Dfs和ZuHePoint两个函数分开了所以只能开全局）

int Dfs(int x,int y,int c){ // c:当前颜色
	int i,j,sl=1; // sl:当前同色四联通待消除棋子数量
	vis[x][y]=1;
	if(a[x+1][y].x==1 && !vis[x+1][y] && a[x+1][y].w==c) sl+=Dfs(x+1,y,c); //条件是：这一轮将被消除、没去过并且同色
	if(a[x-1][y].x==1 && !vis[x-1][y] && a[x-1][y].w==c) sl+=Dfs(x-1,y,c);
	if(a[x][y+1].x==1 && !vis[x][y+1] && a[x][y+1].w==c) sl+=Dfs(x,y+1,c);
	if(a[x][y-1].x==1 && !vis[x][y-1] && a[x][y-1].w==c) sl+=Dfs(x,y-1,c);
	return sl;
}
void ZuHePoint(){
	int i,j,sl;
	for(i=1;i<=n;i++) for(j=1;j<=m;j++) vis[i][j]=0; //清零
	for(i=1;i<=n;i++){
		for(j=1;j<=m;j++){
			if(a[i][j].x==1 && !vis[i][j]){ //这一轮将被消除并且没去过
				sl=Dfs(i,j,a[i][j].w);
				ans+=50*(sl-3)*(sl-3); //计算
				//cout<<"### ANS ### ZuHe."<<50*(sl-3)*(sl-3)<<endl;
			}
		}
	}
}
```

### Part 4：检查特殊消除

一次特殊消除完了之后可能带动更多特殊消除，所以用 while 循环，然后用一个数组存一下待触发的消除即可一个一个检查。

```
int sp[10001][4],spm; // sp:一维是一个栈，二维分别记录特殊棋子的xy坐标 spm:栈顶指针

bool FindSP(){ //检查有无可触发特殊消除的棋子
	int i,j;
	for(i=1;i<=n;i++){
		for(j=1;j<=m;j++){
			if(a[i][j].w && a[i][j].x && a[i][j].sp){ //也是三个条件，这里需要满足sp!=0，是为了标记这个特殊棋子是否被用过（sp==0就是用过了）
				sp[++spm][1]=i;
				sp[spm][2]=j;
			}
		}
	}
	if(spm) return 1; //栈非空，有特殊消除
	else return 0;
}

void SPCheck(){
	int i,j;
	while(FindSP()){
		while(spm){ //一个一个出栈计算效果
			if(a[sp[spm][1]][sp[spm][2]].sp==1){
				for(j=1;j<=m;j++) if(a[sp[spm][1]][j].w) a[sp[spm][1]][j].x=1; //将作用范围还存在棋子全部打上消除标记
			}else if(a[sp[spm][1]][sp[spm][2]].sp==2){
				for(i=1;i<=n;i++) if(a[i][sp[spm][2]].w) a[i][sp[spm][2]].x=1;
			}else if(a[sp[spm][1]][sp[spm][2]].sp==3){
				for(j=1;j<=m;j++) if(a[sp[spm][1]][j].w) a[sp[spm][1]][j].x=1;
				for(i=1;i<=n;i++) if(a[i][sp[spm][2]].w) a[i][sp[spm][2]].x=1;
			}else if(a[sp[spm][1]][sp[spm][2]].sp==4){
				for(i=sp[spm][1]-1;i<=sp[spm][1]+1;i++){
					if(i<1 || i>n) i++;
					for(j=sp[spm][2]-1;j<=sp[spm][2]+1;j++){
						if(j<1 || j>n) j++;
						a[i][j].x=1;
					}
				}
			}else if(a[sp[spm][1]][sp[spm][2]].sp==5){
				for(i=sp[spm][1]-2;i<=sp[spm][1]+2;i++){
					if(i<1 || i>n) i++;
					for(j=sp[spm][2]-2;j<=sp[spm][2]+2;j++){
						if(j<1 || j>n) j++;
						a[i][j].x=1;
					}
				}
			}else if(a[sp[spm][1]][sp[spm][2]].sp==6){
				for(i=1;i<=n;i++){
					for(j=1;j<=m;j++){
						if(a[i][j].w==a[sp[spm][1]][sp[spm][2]].w) a[i][j].x=1;
					}
				}
			}
			a[sp[spm][1]][sp[spm][2]].sp=0; //标记已使用
			spm--; //栈顶指针
		}
	}
}
```

### Part 5： 计算消除分数、消除棋子

这两步简单粗暴，是可以放在一起的。

```
void XiaoChuPoint(int r){
	int i,j,cnt=0;
	for(i=1;i<=n;i++){
		for(j=1;j<=m;j++){
			if(a[i][j].w && a[i][j].x){
				cnt+=a[i][j].w; a[i][j].w=0; a[i][j].x=0; //加分，消除（w与x变为零标记消除）
			}
		}
	}
	//cout<<"### ANS ### XiaoChu."<<r*cnt<<endl;
	ans+=r*cnt;
}
```

### Part 6：棋子下落

对于每一列从下往上扫一遍，然后再按顺序放回去即可。

```
void Fall(){
	int i,j,lnm; // lnm:ln的指针
	xa ln[101]; // xa是a的结构体 ln:当前列下落后的棋子
	for(j=1;j<=m;j++){
		lnm=n+1;
		for(i=n;i>=1;i--){
			if(a[i][j].w) ln[--lnm]=a[i][j]; //lnm指针也是反扫，这样扫完可以直接对着位置替换
		}
		for(i=1;i<=lnm-1;i++){
			a[i][j].w=0; a[i][j].x=0; a[i][j].sp=0;
		}
		for(i=lnm;i<=n;i++){ //上面记得清空
			a[i][j]=ln[i];
		}
	}
}
```

### Part 7：下一轮非特殊消除棋子检查

因为之前的 FSCheck() 函数是对单个格子检查，所以这里可以直接对每个格子调用一次这个函数来检查全屏的非特殊消除情况。

```
int CMCheck(){
	int i,j,av=0;
	for(i=1;i<=n;i++){
		for(j=1;j<=m;j++){
			if(a[i][j].w) av+=FSCheck(i,j,a[i][j].w,0); //最后一个数是0，不计入主颜色的统计
		}
	}
	return av;
}
```

### Part 8: 计算连锁分数

消除与下落的循环结束，接下来计算连锁分数。

```
void LianSuoPoint(int r){
	//cout<<"### ANS ### LianSuo."<<80*(r-1)*(r-1)<<endl;
	ans+=80*(r-1)*(r-1);
}
```

### Part 9：计算牌型分数

比较繁琐的一步，每五次有效交换计算一次，这里使用了五层循环加两个桶的设计。

```
int PX(int p[6]){ //算牌型
	int i,j,t[101],c[6],h=0,hh=0;
	for(i=1;i<=k;i++) t[i]=c[i]=0; //初始化桶
	for(i=1;i<=5;i++) t[p[i]]++; //t[i]表示颜色i的牌有几张
	for(i=1;i<=k;i++) c[t[i]]++; //c[i]表示有i张牌的颜色有几个
	if(c[5]==1) return 1000+10*p[1];
	else if(c[4]==1){
		for(i=1;i<=k;i++) if(t[i]==4) h=i; //h标记颜色
		return 750+5*h;
	}else if(c[3]==1 && c[2]==1){
		for(i=1;i<=k;i++) if(t[i]==3) h=i; else if(t[i]==2) hh=i; //需要标记两种颜色
		return 500+h*3+hh;
	}else if(c[3]==1){
		for(i=1;i<=k;i++) if(t[i]==3) h=i;
		return 300+h*3;
	}else if(c[2]==2){
		for(i=1;i<=k;i++) if(hh && t[i]==2) h=i; else if(t[i]==2) hh=i; //颜色编号自动从小到大排，所以这里h一定大于hh
		return 200+h*2+hh;
	}else if(c[2]==1){
		for(i=1;i<=k;i++) if(t[i]==2) h=i;
		return 100+h*2;
	}else{
		for(i=1;i<=k;i++) if(t[i]==1) h=i;
		return 50+h;
	}
}
                         
void PaiXingPoint(){
	if(pwm<5) return;
	else pwm=0;
	int w1,w2,w3,w4,w5,zp[6],yns=0; //yns是对所有牌型的取max
	for(w1=1;w1<=2;w1++){
		for(w2=1;w2<=2;w2++){
			for(w3=1;w3<=2;w3++){
				for(w4=1;w4<=2;w4++){
					for(w5=1;w5<=2;w5++){
						if(pw[1][w1]==0 || pw[2][w2]==0 || pw[3][w3]==0 || pw[4][w4]==0 || pw[5][w5]==0) continue; //0代表之前交换时这个棋子没有触发非特殊消除，没有算入主颜色
						zp[1]=pw[1][w1]; zp[2]=pw[2][w2]; zp[3]=pw[3][w3]; zp[4]=pw[4][w4]; zp[5]=pw[5][w5];
						sort(zp+1,zp+6);
						yns=max(yns,PX(zp)); //zp即是五种主颜色
					}
				}
			}
		}
	}
	//cout<<"### ANS ### PaiXing."<<yns<<endl;
	ans+=yns;
}
```

### Part 10：计算终局分数

前面的标记 ac 如果还是 1 的话证明没有无效操作。

```
void ZhongJuPoint(){
	int i,j;
	if(ac==1){
		ans+=1000;
		//cout<<"### ANS ### ZhongJu."<<1000<<endl;
	}
	ac=1;
	for(i=1;i<=n;i++){
		for(j=1;j<=m;j++){
			if(a[i][j].w) ac=0; //检查是否全消除
		}
	}
	if(ac==1) ans+=10000;
	//if(ac==1) cout<<"### ANS ### ZhongJu."<<10000<<endl;
}
```

至此所有部分结束。

接下来放完整代码，这份代码去掉注释部分可以详细输出变化情况。

### 完整代码

```
#include<bits/stdc++.h>
using namespace std;
struct xa{
	int w,sp,x;
};
int n,m,k,q,ax,ay,bx,by,pw[6][3],pwm,ac=1,vis[101][101],ans,sp[10001][4],spm,u;
xa a[101][101];
void Input(){
	int i,j;
	for(i=1;i<=n;i++) for(j=1;j<=m;j++) cin>>a[i][j].w;
	for(i=1;i<=n;i++) for(j=1;j<=m;j++) cin>>a[i][j].sp;
}
int FSCheck(int x,int y,int c,int op){
	int i,j,xr=-1,yr=-1,av=0;
	i=x; while(a[i][y].w==c) {i--; xr++;}
	i=x; while(a[i][y].w==c) {i++; xr++;}
	i=y; while(a[x][i].w==c) {i--; yr++;}
	i=y; while(a[x][i].w==c) {i++; yr++;}
	if(xr>=3){
		av+=xr;
		i=x; while(a[i][y].w==c) {a[i][y].x=1; i++;}
		i=x; while(a[i][y].w==c) {a[i][y].x=1; i--;}
	}
	if(yr>=3){
		av+=yr;
		i=y; while(a[x][i].w==c) {a[x][i].x=1; i++;}
		i=y; while(a[x][i].w==c) {a[x][i].x=1; i--;}
	}
	if(op==1) if(av) pw[pwm][1]=c; else pw[pwm][1]=0;
	if(op==2) if(av) pw[pwm][2]=c; else pw[pwm][2]=0;
	return av;
}
int Dfs(int x,int y,int c){
	int i,j,sl=1;
	vis[x][y]=1;
	if(a[x+1][y].x==1 && !vis[x+1][y] && a[x+1][y].w==c) sl+=Dfs(x+1,y,c);
	if(a[x-1][y].x==1 && !vis[x-1][y] && a[x-1][y].w==c) sl+=Dfs(x-1,y,c);
	if(a[x][y+1].x==1 && !vis[x][y+1] && a[x][y+1].w==c) sl+=Dfs(x,y+1,c);
	if(a[x][y-1].x==1 && !vis[x][y-1] && a[x][y-1].w==c) sl+=Dfs(x,y-1,c);
	return sl;
}
int CMCheck(){
	int i,j,av=0;
	for(i=1;i<=n;i++){
		for(j=1;j<=m;j++){
			if(a[i][j].w) av+=FSCheck(i,j,a[i][j].w,0);
		}
	}
	return av;
}
void ZuHePoint(){
	int i,j,sl;
	for(i=1;i<=n;i++) for(j=1;j<=m;j++) vis[i][j]=0;
	for(i=1;i<=n;i++){
		for(j=1;j<=m;j++){
			if(a[i][j].x==1 && !vis[i][j]){
				sl=Dfs(i,j,a[i][j].w);
				ans+=50*(sl-3)*(sl-3);
				//cout<<"### ANS ### ZuHe."<<50*(sl-3)*(sl-3)<<endl;
			}
		}
	}
}
bool FindSP(){
	int i,j;
	for(i=1;i<=n;i++){
		for(j=1;j<=m;j++){
			if(a[i][j].w && a[i][j].x && a[i][j].sp){
				sp[++spm][1]=i;
				sp[spm][2]=j;
			}
		}
	}
	if(spm) return 1;
	else return 0;
}
void SPCheck(){
	int i,j;
	while(FindSP()){
		while(spm){
			if(a[sp[spm][1]][sp[spm][2]].sp==1){
				for(j=1;j<=m;j++) if(a[sp[spm][1]][j].w) a[sp[spm][1]][j].x=1;
			}else if(a[sp[spm][1]][sp[spm][2]].sp==2){
				for(i=1;i<=n;i++) if(a[i][sp[spm][2]].w) a[i][sp[spm][2]].x=1;
			}else if(a[sp[spm][1]][sp[spm][2]].sp==3){
				for(j=1;j<=m;j++) if(a[sp[spm][1]][j].w) a[sp[spm][1]][j].x=1;
				for(i=1;i<=n;i++) if(a[i][sp[spm][2]].w) a[i][sp[spm][2]].x=1;
			}else if(a[sp[spm][1]][sp[spm][2]].sp==4){
				for(i=sp[spm][1]-1;i<=sp[spm][1]+1;i++){
					if(i<1 || i>n) i++;
					for(j=sp[spm][2]-1;j<=sp[spm][2]+1;j++){
						if(j<1 || j>n) j++;
						a[i][j].x=1;
					}
				}
			}else if(a[sp[spm][1]][sp[spm][2]].sp==5){
				for(i=sp[spm][1]-2;i<=sp[spm][1]+2;i++){
					if(i<1 || i>n) i++;
					for(j=sp[spm][2]-2;j<=sp[spm][2]+2;j++){
						if(j<1 || j>n) j++;
						a[i][j].x=1;
					}
				}
			}else if(a[sp[spm][1]][sp[spm][2]].sp==6){
				for(i=1;i<=n;i++){
					for(j=1;j<=m;j++){
						if(a[i][j].w==a[sp[spm][1]][sp[spm][2]].w) a[i][j].x=1;
					}
				}
			}
			a[sp[spm][1]][sp[spm][2]].sp=0;
			spm--;
		}
	}
}
void XiaoChuPoint(int r){
	int i,j,cnt=0;
	for(i=1;i<=n;i++){
		for(j=1;j<=m;j++){
			if(a[i][j].w && a[i][j].x){
				cnt+=a[i][j].w; a[i][j].w=0; a[i][j].x=0;
			}
		}
	}
	//cout<<"### ANS ### XiaoChu."<<r*cnt<<endl;
	ans+=r*cnt;
}
void Fall(){
	int i,j,lnm;
	xa ln[101];
	for(j=1;j<=m;j++){
		lnm=n+1;
		for(i=n;i>=1;i--){
			if(a[i][j].w) ln[--lnm]=a[i][j];
		}
		for(i=1;i<=lnm-1;i++){
			a[i][j].w=0; a[i][j].x=0; a[i][j].sp=0;
		}
		for(i=lnm;i<=n;i++){
			a[i][j]=ln[i];
		}
	}
}
void LianSuoPoint(int r){
	//cout<<"### ANS ### LianSuo."<<80*(r-1)*(r-1)<<endl;
	ans+=80*(r-1)*(r-1);
}
void Exchange(){
	int i,j,av=0,r=1;
	swap(a[ax][ay],a[bx][by]);
	pwm++;
	av+=FSCheck(ax,ay,a[ax][ay].w,1); av+=FSCheck(bx,by,a[bx][by].w,2);
	while(av!=0){
		ZuHePoint(); 
		SPCheck();
		XiaoChuPoint(r);
		Fall();
		r++;
		av=CMCheck();
	}
	if(r==1){
		//cout<<"##### Wrong Step #####"<<endl;
		ac=0; swap(a[ax][ay],a[bx][by]);
		pwm--;
		return;
	}
	LianSuoPoint(r-1);
}
int PX(int p[6]){
	int i,j,t[101],c[6],h=0,hh=0;
	for(i=1;i<=k;i++) t[i]=c[i]=0;
	for(i=1;i<=5;i++) t[p[i]]++;
	for(i=1;i<=k;i++) c[t[i]]++;
	if(c[5]==1) return 1000+10*p[1];
	else if(c[4]==1){
		for(i=1;i<=k;i++) if(t[i]==4) h=i;
		return 750+5*h;
	}else if(c[3]==1 && c[2]==1){
		for(i=1;i<=k;i++) if(t[i]==3) h=i; else if(t[i]==2) hh=i;
		return 500+h*3+hh;
	}else if(c[3]==1){
		for(i=1;i<=k;i++) if(t[i]==3) h=i;
		return 300+h*3;
	}else if(c[2]==2){
		for(i=1;i<=k;i++) if(hh && t[i]==2) h=i; else if(t[i]==2) hh=i;
		return 200+h*2+hh;
	}else if(c[2]==1){
		for(i=1;i<=k;i++) if(t[i]==2) h=i;
		return 100+h*2;
	}else{
		for(i=1;i<=k;i++) if(t[i]==1) h=i;
		return 50+h;
	}
}
void PaiXingPoint(){
	if(pwm<5) return;
	else pwm=0;
	int w1,w2,w3,w4,w5,zp[6],yns=0;
	for(w1=1;w1<=2;w1++){
		for(w2=1;w2<=2;w2++){
			for(w3=1;w3<=2;w3++){
				for(w4=1;w4<=2;w4++){
					for(w5=1;w5<=2;w5++){
						if(pw[1][w1]==0 || pw[2][w2]==0 || pw[3][w3]==0 || pw[4][w4]==0 || pw[5][w5]==0) continue;
						zp[1]=pw[1][w1]; zp[2]=pw[2][w2]; zp[3]=pw[3][w3]; zp[4]=pw[4][w4]; zp[5]=pw[5][w5];
						sort(zp+1,zp+6);
						yns=max(yns,PX(zp));
					}
				}
			}
		}
	}
	//cout<<"### ANS ### PaiXing."<<yns<<endl;
	ans+=yns;
}
void ZhongJuPoint(){
	int i,j;
	if(ac==1){
		ans+=1000;
		//cout<<"### ANS ### ZhongJu."<<1000<<endl;
	}
	ac=1;
	for(i=1;i<=n;i++){
		for(j=1;j<=m;j++){
			if(a[i][j].w) ac=0;
		}
	}
	if(ac==1) ans+=10000;
	//if(ac==1) cout<<"### ANS ### ZhongJu."<<10000<<endl;
}
bool Right(){
	int i,j=0;
	if(abs(ax-bx)==1 && ay==by) j=1;
	if(abs(ay-by)==1 && ax==bx) j=1;
	if(a[ax][ay].w==0 || a[bx][by].w==0) j=0;
	return j; 
}
int main()
{
	int i,j;
	cin>>n>>m>>k>>q;
	Input();
	while(q--){
		cin>>ax>>ay>>bx>>by;
		if(!Right()) {ac=0; continue;}
//		cout<<"---------- ROUND "<<u++<<" ----------"<<endl;
//		cout<<"a[i][j].w"<<endl;
//		for(i=1;i<=n;i++){
//			for(j=1;j<=m;j++) cout<<a[i][j].w<<' ';
//			cout<<endl;
//		}
//		cout<<"a[i][j].sp"<<endl;
//		for(i=1;i<=n;i++){
//			for(j=1;j<=m;j++) cout<<a[i][j].sp<<' ';
//			cout<<endl;
//		}
//		cout<<"----------"<<endl;
		Exchange();
		PaiXingPoint();
	}
	ZhongJuPoint();
	cout<<ans;
	return 0;
}
```


---

## 作者：a1co0av5ce5az1cz0ap_ (赞：2)

看不少神仙都做了很久，不太懂，从 2023-10-18 15:20 开始写到 20:50 就过了，中间还有大概 1h 的吃饭时间，感觉其实没那么难。

首先是一些前置函数和变量：

```cpp
int dir[4][2]={{0,1},{1,0},{0,-1},{-1,0}};//四个方向的 xy 分量
int n,m,k,q;
int nt;// 当前是第几个有效操作
int a[505][505],b[505][505],c[505][505],d[505][505];// a 和 b 同输入，c 表示是否被消掉，d 是临时数组
int mcol[10005][5];// 每个有效操作的主要颜色
int ans1,ans2,ans3,ans4,ans5;// 五种答案
int cursum,rounds;// 当前颜色和以及当前是一个操作的第几轮
int x,y,xx,yy;// 交换的两个位置
int useful=1;// 是否全都有效
bool ok(int x,int y){return x>=1&&x<=n&&y>=1&&y<=m;}// 位置是否在地图内
```

首先是对于每个操作，都要进行以下步骤：

1. 判断是否合法
2. 直接交换
3. 进行若干轮操作
4. 检查连锁奖分
5. 计算牌型奖分

对于判断，可以直接写一个函数检查是否存在横或竖的三个连着的同色。

```cpp
bool check(){
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++){
		if(ok(i-1,j)&&ok(i+1,j)&&a[i-1][j]==a[i][j]&&a[i][j]==a[i+1][j]&&a[i][j])return 1;
		if(ok(i,j-1)&&ok(i,j+1)&&a[i][j-1]==a[i][j]&&a[i][j]==a[i][j+1]&&a[i][j])return 1;
	}
	return 0;
}
```

对于若干轮操作，我们可以有这样一个过程：

```cpp
for(rounds=1;check();++rounds){
	cursum=0;
	Do_A_Round(rounds==1);// 完成一轮，参数表示是否为第一次（第一次需要找出主颜色）
	down();// 下落
	ans1+=cursum*rounds;// 计算消除奖分
}
```

`down()` 比较容易实现，这里就主要看如何进行一轮操作。

每一轮操作都要做以下事：

1. 找到所有刚交换就可以消掉的位置
2. 如果是第一轮计算主颜色
3. 把所有可以消掉的连通块全都计算到组合奖分（注意这里可能因为下落导致出现非常多，要计算每个连通块）
4. 每次把当前的所有被消掉的方块都检查一遍特殊效果

```cpp
void Do_A_Round(bool first){
	addtg();// 和 check 类似，就是把检查到的位置的 c 标记为 1
	if(first){// 找主颜色
		if(c[x][y])mcol[nt][1]=a[x][y];
		if(c[xx][yy])mcol[nt][1+(mcol[nt][1]>0)]=a[xx][yy];
	}
	int sx,sy,cnt=0;
	bool f=0;
	memset(d,0,sizeof(d));// 注意前后 d 的用处不一样，这里是用作 vis 数组
	while(!f){
		f=1;
		for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)if(c[i][j]&&!d[i][j]){sx=i,sy=j,f=0;}
		if(f)break;
		int tmp=calccnt(sx,sy);// 连通块大小
		cnt+=50*(tmp-3)*(tmp-3);// 计算出每个连通块的贡献
	}
	ans3+=cnt;
	memcpy(d,c,sizeof(d));// 这里 d 是作为临时数组找上一次影响到的位置
	int s;
	do{
		s=0;
		for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)if(d[i][j])s+=doop(i,j);// doop 是触发对应位置的特殊效果
		memcpy(d,c,sizeof(d));
	}while(s);
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)if(c[i][j])cursum+=a[i][j];// 计算当前和
}
```

接下来也是一大码量重点：牌型奖分。

因为有可能有两个主颜色，所以直接爆搜每一种情况，计算出对应得分并取最大值。

```cpp
pii cnt[10005];int ccnt;
void add(int v){// v 的位置 +1
	for(int i=1;i<=ccnt;i++)if(cnt[i].se==v){cnt[i].fi++;return;}
	cnt[++ccnt]={1,v};
}
void del(int v){// v 的位置 -1
	for(int i=1;i<=ccnt;i++)if(cnt[i].se==v){cnt[i].fi--;return;}
	assert(0);
}
int calcans4(){// 计算得分
	sort(cnt+1,cnt+ccnt+1,greater<pii>());
	if(cnt[1].fi==5)return 1000+cnt[1].se*10;
	if(cnt[1].fi==4)return 750+cnt[1].se*5;
	if(cnt[1].fi==3){
		if(cnt[2].fi==2) return 500+cnt[1].se*3+cnt[2].se;
		return 300+cnt[1].se*3;
	}
	if(cnt[1].fi==2){
		if(cnt[2].fi==2) return 200+cnt[1].se*2+cnt[2].se;
		return 100+cnt[1].se*2;// 这里没写 *2 调了两个小时
	}
	return 50+cnt[1].se;
}
int dfs(int now,int mx){// 直接爆搜，mx 是结束位置
	if(now>mx)return calcans4();
	int ans=0;
	add(mcol[now][1]);
	ans=dfs(now+1,mx);
	del(mcol[now][1]);
	if(mcol[now][2]){
		add(mcol[now][2]);
		ans=max(ans,dfs(now+1,mx));
		del(mcol[now][2]);
	}
	return ans;
}
```

于是，我们就做完了这道题。

[record](https://www.luogu.com.cn/record/130215328)

---

## 作者：Phartial (赞：2)

比较好做的一道大模拟，没有什么恶心的细节。

我们一个一个来实现操作。

## 辅助函数

```cpp
bool I(int x, int y) { return x >= 1 && x <= n && y >= 1 && y <= m; }
bool N(int x, int y) { return !I(x, y) || !a[x][y].first; }
```

`I(x,y)` 用来判断坐标是否在范围内，`N(x,y)` 用来判断坐标是否**不**合法。

```cpp
int Cx(int x, int y) {
  int cx = 0;
  for (int _x = x; _x >= 1 && a[x][y].first == a[_x][y].first; --_x, ++cx) {
  }
  for (int _x = x + 1; _x <= n && a[x][y].first == a[_x][y].first; ++_x, ++cx) {
  }
  return cx;
}
int Cy(int x, int y) {
  int cy = 0;
  for (int _y = y; _y >= 1 && a[x][y].first == a[x][_y].first; --_y, ++cy) {
  }
  for (int _y = y + 1; _y <= m && a[x][y].first == a[x][_y].first; ++_y, ++cy) {
  }
  return cy;
}
void T(int x, int y) { v[x][y] = a[x][y].first; }
```

`Cx(x,y),Cy(x,y)` 用处类似，都是用来统计同一行/列中连续的棋子数量。

`T(x,y)` 用来打标记，表示这个坐标是需要被删除的。

## 交换棋子

```cpp
bool H(int x, int y) { return !N(x, y) && (Cx(x, y) >= 3 || Cy(x, y) >= 3); }
bool C(int x1, int y1, int x2, int y2) {
  if (N(x1, y1) || N(x2, y2) || abs(x1 - x2) + abs(y1 - y2) != 1) {
    return 0;
  }
  swap(a[x1][y1], a[x2][y2]);
  bool f = H(x1, y1) || H(x2, y2);
  swap(a[x1][y1], a[x2][y2]);
  return f;
}
```

`H(x,y)` 用来判断当前点能否被消除，`C(x1,y1,x2,y2)` 用来判断此次交换是否有效。

交换有效的条件：两个坐标都合法，曼哈顿距离为 $1$，交换后可以被消除。

## 寻找被消除的棋子

**坑点：被消除的棋子是从当前坐标开始向行/列延伸的所有同色棋子，而不是同色四连通块。**

```cpp
void G(int x, int y) {
  if (Cx(x, y) >= 3) {
    for (int _x = x; _x >= 1 && a[x][y].first == a[_x][y].first; T(_x, y), --_x) {
    }
    for (int _x = x + 1; _x <= n && a[x][y].first == a[_x][y].first; T(_x, y), ++_x) {
    }
  }
  if (Cy(x, y) >= 3) {
    for (int _y = y; _y >= 1 && a[x][y].first == a[x][_y].first; T(x, _y), --_y) {
    }
    for (int _y = y + 1; _y <= m && a[x][y].first == a[x][_y].first; T(x, _y), ++_y) {
    }
  }
}
bool G() {
  bool f = 0;
  for (int i = 1; i <= n; ++i) {
    for (int j = 1; j <= m; ++j) {
      if (H(i, j)) {
        G(i, j), f = 1;
      }
    }
  }
  return f;
}
```

`G(x,y)` 会对从当前坐标开始会被删除的棋子全部打上标记；`G()` 会找出所有要被删除的棋子，同时判断是否还要继续删。

## 消除棋子

```cpp
void C(int x, int y) {
  if (N(x, y)) {
    return;
  }
  int ty = a[x][y].second, co = a[x][y].first;
  sc += co, a[x][y] = {0, 0};
  if (ty == 1 || ty == 3) {
    for (int k = 1; k <= m; ++k) {
      C(x, k);
    }
  }
  if (ty == 2 || ty == 3) {
    for (int k = 1; k <= n; ++k) {
      C(k, y);
    }
  }
  if (ty == 6) {
    for (int i = 1; i <= n; ++i) {
      for (int j = 1; j <= m; ++j) {
        if (a[i][j].first == co) {
          C(i, j);
        }
      }
    }
  }
  if (ty == 4 || ty == 5) {
    int v = ty - 3;
    for (int i = -v; i <= v; ++i) {
      for (int j = -v; j <= v; ++j) {
        if (i || j) {
          C(x + i, y + j);
        }
      }
    }
  }
}
```

消除的时候记录一下颜色编号和用来结算分数，剩下的就是按照题意模拟。

## 主过程

```cpp
void FD() {
  for (int j = 1; j <= m; ++j) {
    int k = n;
    for (int i = n; i >= 1; --i) {
      if (a[i][j].first) {
        a[k--][j] = a[i][j];
      }
    }
    for (; k; a[k--][j] = {0, 0}) {
    }
  }
}
......
for (int x1, y1, x2, y2; q--;) {
  cin >> x1 >> y1 >> x2 >> y2;
  bool f = C(x1, y1, x2, y2);
  if (!f) {
    aC = 0;
    continue;
  }
  swap(a[x1][y1], a[x2][y2]);
  int k = 0;
  for (; G(); FD()) {
    ++k, sc = 0;
    for (int i = 1; i <= n; ++i) {
      for (int j = 1; j <= m; ++j) {
        if (v[i][j]) {
          C(i, j);
        }
      }
    }
  }
}
```

模拟每一轮的消除和下落即可

## 结算分数

### 终局奖分

很简单，开个变量存一下所有操作的合法性，最后判一下清空盘面即可。

```cpp
if (aC) {
  ans += 1000;
}
aC = 1;
for (int i = 1; i <= n; ++i) {
  for (int j = 1; j <= m; ++j) {
    aC &= !a[i][j].first;
  }
}
if (aC) {
  ans += 10000;
}
```

### 消除奖分

维护一下之前提到的 `sc`，每**轮**消除后结算分数即可。

```cpp
for (int x1, y1, x2, y2; q--;) {
  cin >> x1 >> y1 >> x2 >> y2;
  bool f = C(x1, y1, x2, y2);
  if (!f) {
    aC = 0;
    continue;
  }
  swap(a[x1][y1], a[x2][y2]);
  int k = 0;
  for (; G(); FD()) {
    ++k, sc = 0;
    for (int i = 1; i <= n; ++i) {
      for (int j = 1; j <= m; ++j) {
        if (v[i][j]) {
          C(i, j);
        }
      }
    }
    ans += sc * k; // 消除奖分
  }
}
```

### 连锁奖分

记一下总轮数即可。

```cpp
for (int x1, y1, x2, y2; q--;) {
  cin >> x1 >> y1 >> x2 >> y2;
  bool f = C(x1, y1, x2, y2);
  if (!f) {
    aC = 0;
    continue;
  }
  swap(a[x1][y1], a[x2][y2]);
  int k = 0;
  for (; G(); FD()) {
    ++k, sc = 0;
    for (int i = 1; i <= n; ++i) {
      for (int j = 1; j <= m; ++j) {
        if (v[i][j]) {
          C(i, j);
        }
      }
    }
    ans += sc * k; // 消除奖分
  }
  ans += 80 * (k - 1) * (k - 1); // 连锁奖分
}
```

### 组合奖分

找出所有的同色四连通块，结算分数即可。

```cpp
int F(int x, int y, int co) {
  if (!I(x, y) || v[x][y] != co) {
    return 0;
  }
  int c = 1;
  v[x][y] = 0;
  for (int k = 0; k < 4; ++k) {
    c += F(x + kD[k][0], y + kD[k][1], co);
  }
  return c;
}
......
for (int x1, y1, x2, y2; q--;) {
  cin >> x1 >> y1 >> x2 >> y2;
  bool f = C(x1, y1, x2, y2);
  if (!f) {
    aC = 0;
    continue;
  }
  swap(a[x1][y1], a[x2][y2]);
  int k = 0;
  for (; G(); FD()) {
    ++k, sc = 0;
    for (int i = 1; i <= n; ++i) {
      for (int j = 1; j <= m; ++j) {
        if (v[i][j]) {
          C(i, j);
        }
      }
    }
    ans += sc * k; // 消除奖分
    for (int i = 1; i <= n; ++i) { // 组合奖分
      for (int j = 1; j <= m; ++j) {
        if (v[i][j]) {
          int vc = F(i, j, v[i][j]);
          if (vc) {
            ans += 50 * (vc - 3) * (vc - 3);
          }
        }
      }
    }
  }
  ans += 80 * (k - 1) * (k - 1); // 连锁奖分
}
```

### 牌型奖分

每五次操作结算一下分数即可，可以暴力枚举。

```cpp
int C(int l[5]) {
  fill_n(cc + 1, k, 0);
  for (int i = 0; i < 5; ++i) {
    ++cc[l[i]];
  }
  vector<int> cl[6];
  for (int i = 0; i < 6; ++i) {
    cl[i].clear();
  }
  for (int i = 1; i <= k; ++i) {
    if (cc[i]) {
      cl[cc[i]].push_back(i);
    }
  }
  if (cl[1].size() == 5) {
    return 50 + cl[1].back();
  }
  if (cl[1].size() == 3) {
    return 100 + cl[2][0] * 2;
  }
  if (cl[1].size() == 2) {
    return 300 + cl[3][0] * 3;
  }
  if (cl[2].size() == 2) {
    return 200 + cl[2][1] * 2 + cl[2][0];
  }
  if (cl[2].size() == 1) {
    return 500 + cl[3][0] * 3 + cl[2][0];
  }
  if (cl[4].size() == 1) {
    return 750 + cl[4][0] * 5;
  }
  return 1000 + cl[5][0] * 10;
}
......
for (int x1, y1, x2, y2; q--;) {
  cin >> x1 >> y1 >> x2 >> y2;
  bool f = C(x1, y1, x2, y2);
  if (!f) {
    aC = 0;
    continue;
  }
  swap(a[x1][y1], a[x2][y2]);
  ml[mlc][0] = H(x1, y1) ? a[x1][y1].first : a[x2][y2].first;
  ml[mlc][1] = H(x2, y2) ? a[x2][y2].first : a[x1][y1].first;
  if (++mlc == 5) {
    mlc = 0;
    int mc = 0;
    for (int i = 0; i < 32; ++i) {
      int c[5] = {0};
      for (int j = 0; j < 5; ++j) {
        c[j] = ml[j][i >> j & 1];
      }
      mc = max(mc, C(c));
    }
    ans += mc; // 牌型奖分
  }
  int k = 0;
  for (; G(); FD()) {
    ++k, sc = 0;
    for (int i = 1; i <= n; ++i) {
      for (int j = 1; j <= m; ++j) {
        if (v[i][j]) {
          C(i, j);
        }
      }
    }
    ans += sc * k; // 消除奖分
    for (int i = 1; i <= n; ++i) { // 组合奖分
      for (int j = 1; j <= m; ++j) {
        if (v[i][j]) {
          int vc = F(i, j, v[i][j]);
          if (vc) {
            ans += 50 * (vc - 3) * (vc - 3);
          }
        }
      }
    }
  }
  ans += 80 * (k - 1) * (k - 1); // 连锁奖分
}
```

## 总代码

```cpp#include <vector>
#include <iostream>

using namespace std;
using Pii = pair<int, int>;

const int kN = 51, kK = 101;
const int kD[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

int n, m, k, q, cc[kK], v[kN][kN], mlc, ml[5][2], ans, sc;
Pii a[kN][kN];
bool aC = 1;

bool I(int x, int y) { return x >= 1 && x <= n && y >= 1 && y <= m; }
bool N(int x, int y) { return !I(x, y) || !a[x][y].first; }
int Cx(int x, int y) {
  int cx = 0;
  for (int _x = x; _x >= 1 && a[x][y].first == a[_x][y].first; --_x, ++cx) {
  }
  for (int _x = x + 1; _x <= n && a[x][y].first == a[_x][y].first; ++_x, ++cx) {
  }
  return cx;
}
int Cy(int x, int y) {
  int cy = 0;
  for (int _y = y; _y >= 1 && a[x][y].first == a[x][_y].first; --_y, ++cy) {
  }
  for (int _y = y + 1; _y <= m && a[x][y].first == a[x][_y].first; ++_y, ++cy) {
  }
  return cy;
}
void T(int x, int y) { v[x][y] = a[x][y].first; }
void G(int x, int y) {
  if (Cx(x, y) >= 3) {
    for (int _x = x; _x >= 1 && a[x][y].first == a[_x][y].first; T(_x, y), --_x) {
    }
    for (int _x = x + 1; _x <= n && a[x][y].first == a[_x][y].first; T(_x, y), ++_x) {
    }
  }
  if (Cy(x, y) >= 3) {
    for (int _y = y; _y >= 1 && a[x][y].first == a[x][_y].first; T(x, _y), --_y) {
    }
    for (int _y = y + 1; _y <= m && a[x][y].first == a[x][_y].first; T(x, _y), ++_y) {
    }
  }
}
bool H(int x, int y) { return !N(x, y) && (Cx(x, y) >= 3 || Cy(x, y) >= 3); }
bool C(int x1, int y1, int x2, int y2) {
  if (N(x1, y1) || N(x2, y2) || abs(x1 - x2) + abs(y1 - y2) != 1) {
    return 0;
  }
  swap(a[x1][y1], a[x2][y2]);
  bool f = H(x1, y1) || H(x2, y2);
  swap(a[x1][y1], a[x2][y2]);
  return f;
}
void C(int x, int y) {
  if (N(x, y)) {
    return;
  }
  int ty = a[x][y].second, co = a[x][y].first;
  sc += co, a[x][y] = {0, 0};
  if (ty == 1 || ty == 3) {
    for (int k = 1; k <= m; ++k) {
      C(x, k);
    }
  }
  if (ty == 2 || ty == 3) {
    for (int k = 1; k <= n; ++k) {
      C(k, y);
    }
  }
  if (ty == 6) {
    for (int i = 1; i <= n; ++i) {
      for (int j = 1; j <= m; ++j) {
        if (a[i][j].first == co) {
          C(i, j);
        }
      }
    }
  }
  if (ty == 4 || ty == 5) {
    int v = ty - 3;
    for (int i = -v; i <= v; ++i) {
      for (int j = -v; j <= v; ++j) {
        if (i || j) {
          C(x + i, y + j);
        }
      }
    }
  }
}
bool G() {
  bool f = 0;
  for (int i = 1; i <= n; ++i) {
    for (int j = 1; j <= m; ++j) {
      if (H(i, j)) {
        G(i, j), f = 1;
      }
    }
  }
  return f;
}
void FD() {
  for (int j = 1; j <= m; ++j) {
    int k = n;
    for (int i = n; i >= 1; --i) {
      if (a[i][j].first) {
        a[k--][j] = a[i][j];
      }
    }
    for (; k; a[k--][j] = {0, 0}) {
    }
  }
}
int C(int l[5]) {
  fill_n(cc + 1, k, 0);
  for (int i = 0; i < 5; ++i) {
    ++cc[l[i]];
  }
  vector<int> cl[6];
  for (int i = 0; i < 6; ++i) {
    cl[i].clear();
  }
  for (int i = 1; i <= k; ++i) {
    if (cc[i]) {
      cl[cc[i]].push_back(i);
    }
  }
  if (cl[1].size() == 5) {
    return 50 + cl[1].back();
  }
  if (cl[1].size() == 3) {
    return 100 + cl[2][0] * 2;
  }
  if (cl[1].size() == 2) {
    return 300 + cl[3][0] * 3;
  }
  if (cl[2].size() == 2) {
    return 200 + cl[2][1] * 2 + cl[2][0];
  }
  if (cl[2].size() == 1) {
    return 500 + cl[3][0] * 3 + cl[2][0];
  }
  if (cl[4].size() == 1) {
    return 750 + cl[4][0] * 5;
  }
  return 1000 + cl[5][0] * 10;
}
int F(int x, int y, int co) {
  if (!I(x, y) || v[x][y] != co) {
    return 0;
  }
  int c = 1;
  v[x][y] = 0;
  for (int k = 0; k < 4; ++k) {
    c += F(x + kD[k][0], y + kD[k][1], co);
  }
  return c;
}

int main() {
  ios_base::sync_with_stdio(0), cin.tie(0);
  cin >> n >> m >> k >> q;
  for (int i = 1; i <= n; ++i) {
    for (int j = 1; j <= m; ++j) {
      cin >> a[i][j].first;
    }
  }
  for (int i = 1; i <= n; ++i) {
    for (int j = 1; j <= m; ++j) {
      cin >> a[i][j].second;
    }
  }
  for (int x1, y1, x2, y2; q--;) {
    cin >> x1 >> y1 >> x2 >> y2;
    bool f = C(x1, y1, x2, y2);
    if (!f) {
      aC = 0;
      continue;
    }
    swap(a[x1][y1], a[x2][y2]);
    ml[mlc][0] = H(x1, y1) ? a[x1][y1].first : a[x2][y2].first;
    ml[mlc][1] = H(x2, y2) ? a[x2][y2].first : a[x1][y1].first;
    if (++mlc == 5) {
      mlc = 0;
      int mc = 0;
      for (int i = 0; i < 32; ++i) {
        int c[5] = {0};
        for (int j = 0; j < 5; ++j) {
          c[j] = ml[j][i >> j & 1];
        }
        mc = max(mc, C(c));
      }
      ans += mc;
    }
    int k = 0;
    for (; G(); FD()) {
      ++k, sc = 0;
      for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
          if (v[i][j]) {
            C(i, j);
          }
        }
      }
      ans += sc * k;
      for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
          if (v[i][j]) {
            int vc = F(i, j, v[i][j]);
            if (vc) {
              ans += 50 * (vc - 3) * (vc - 3);
            }
          }
        }
      }
    }
    ans += 80 * (k - 1) * (k - 1);
  }
  if (aC) {
    ans += 1000;
  }
  aC = 1;
  for (int i = 1; i <= n; ++i) {
    for (int j = 1; j <= m; ++j) {
      aC &= !a[i][j].first;
    }
  }
  if (aC) {
    ans += 10000;
  }
  cout << ans;
  return 0;
}
```


---

## 作者：NKL丶 (赞：2)

## Description

给定一个 $N \times M$ 的棋盘，每个位置上有一个棋子（颜色为 $1 \sim k$，可能有特殊效果），现有 $q$ 次操作（可能是不合法的操作），每次操作交换相邻两个位置上的棋子，若为合法操作，则会触发若干轮消除并会按照特定规则加分，问 $q$ 次操作后的总得分。（$1 \le N,M \le 50,1 \le k \le 100,1 \le q \le 10^3$）

## Solution

大模拟，按照题意依次处理每个步骤：

- 判断一次操作后是否会触发消除，若无法触发，判断为不合法操作并**使得此次操作无效**，同时令终局奖分的第一项无效。
- 触发交换后的第一轮消除，记录下可能的组合奖分和牌型奖分。
- 处理带有特殊效果的棋子。
- 统计此轮被消除的棋子的颜色总和，记录对答案的贡献。
- 处理棋盘内棋子的重力下落，并开始新的一轮消除。
- 一次操作完毕后，记录连锁奖分。
- $q$ 次操作均完毕后，处理终局奖分。

一些需要注意的点：

- 一次操作若是不合法的（不触发消除），那么不应执行交换。
- 组合奖分只对交换后的消除有效，所以应在触发消除前判断（或者打上与待消除位置不同的标记）。
- 由于牌型奖分的处理中，一次合法操作可能有两种主颜色，我们需要枚举可能的组合方案来判断得分。

## [Code](https://www.luogu.com.cn/paste/bod4wweb)


---

## 作者：yanhao40340 (赞：0)

第一道紫题题解！~~虽然是道模拟。~~

## 题意

大体题意就是一个消消乐的游戏过程，多看几遍题面即可。

## 分析

消消乐的游戏步骤：交换棋子 $\to$ 判断是否可消 $\to$ 统计组合奖分 $\to$ 特殊效果 $\to$ 统计消除奖分 $\to$ 消除棋子 $\to$ 重力下落 $\to$ 判断是否可消 $\to ...$。

其中有效操作每满 $5$ 次就要进行一次统计牌型奖分。

最后要统计终局奖分。

因为这是一道模拟题，且 $1 \le n,m \le 50$，所以只要不是死循环的代码就基本不会 $\texttt{TLE}$。接下来我们就一个一个步骤实现。

### 交换棋子

交换棋子是这些步骤里最简单的一个。

首先需要判断这两个交换的位置是否相邻。

其次判断这两个位置是否存在棋子。

最后判断交换后盘面能否实现消除。

时间复杂度 $\Theta\left(nm(n+m)\right)$。代码如下：

```cpp
bool change(int xa,int ya,int xb,int yb){ //交换棋子，返回值表示是否交换成功
	if (abs(xa-xb)+abs(ya-yb)==1) //判断是否相邻
		if (a[xa][ya].first&&a[xb][yb].first){ //判断位置是否有棋子
			swap(a[xa][ya],a[xb][yb]);
			bool res=check(1); //判断能否消除
			if (!res){swap(a[xa][ya],a[xb][yb]);return false;} //不能消除则重置盘面
			return true;
		}
	return false;
}
```

### 判断是否可消

主要思路是对于每一个棋子向右和向下扫描，判断是否有 $3$ 个及 $3$ 个以上的同色棋子连成一线。函数将可以消除的棋子坐标加入 `dels` 中。

时间复杂度 $\Theta\left(nm(n+m)\right)$。代码如下：

```cpp
bool check(bool flg){ //判断是否可消，flg 参数表示是否是第一轮消除，返回值表示是否可以消除
	dels.clear();
	bool can=false; //记录是否消除
	for (int i=1;i<=n;++i)
		for (int j=1;j<=m;++j){
			if (a[i][j].first){ //如果有棋子
				int tot=0,tot2=0;
				for (int k=0;i+k<=n;++k){ //向下扫描
					if (a[i+k][j].first==a[i][j].first) ++tot;
					else break;
				}
				if (tot>=3){ //如果有 3 个及以上的同色棋子
					can=true;
					if (flg) col[now%5].insert(a[i][j].first); //如果是第一轮消除，那么将消除的颜色加入到这一次的主颜色中
					for (int k=0;k<tot;++k)
						dels.insert(make_pair(i+k,j)); //把要消除的棋子加入 dels
				}
				for (int k=0;j+k<=m;++k){ //向右扫描
					if (a[i][j+k].first==a[i][j].first) ++tot2;
					else break;
				}
				if (tot2>=3){
					can=true;
					if (flg) col[now%5].insert(a[i][j].first);
					for (int k=0;k<tot2;++k)
						dels.insert(make_pair(i,j+k));
				}
			}
		}
	return can;
}
```

### 统计组合奖分

把所有要消除的点打上标记（代码中的 `mp` 数组），然后求出所有四连通块即可。

依次对还没有访问过的点进行宽搜，宽搜时访问的点打上已访问标记（代码中的 `vis` 数组）。

时间复杂度 $\Theta\left(nm\right)$。代码如下：

```cpp
bitset<maxn> vis[maxn],mp[maxn];
int dir[][2]={{0,1},{0,-1},{1,0},{-1,0}};
void calcsquares(){ //统计组合奖分
	queue<pii> q;delsquares.clear();
	for (int i=1;i<=n;++i) vis[i].reset(),mp[i].reset();
	for (pii it:dels) mp[it.first].set(it.second); //标记所有要消除的点
	for (pii it:dels){
		if (!vis[it.first][it.second]){ //如果该点还没有访问过，即不在已经搜索的任一四连通块内
			q.push(it);int tot=0; //tot 记录连通块大小
			vis[it.first].set(it.second);
			while (!q.empty()){ //宽搜板子
				pii fr=q.front();q.pop();++tot;
				int x=fr.first,y=fr.second;
				for (int i=0;i<4;++i){
					int dx=dir[i][0]+x,dy=dir[i][1]+y;
					if (1<=dx&&dx<=n&&1<=dy&&dy<=m){
						if (mp[dx].test(dy)&&a[dx][dy].first==a[x][y].first&&!vis[dx].test(dy)){
							vis[dx].set(dy);
							q.push(make_pair(dx,dy));
						}
					} 
				}
			}
			delsquares.push_back(tot); //记录该四连通块的大小
		}
	}
	for (int it:delsquares)
		ans+=(it-3)*(it-3)*50; //计算分数
	return;
}
```

### 特殊效果

对于每一个功能都按题意模拟实现即可。把所有功能加入到队列中，如果触发了新的功能则将新功能也加入到队列中。

也是使用宽搜（~~也许叫手写栈的深搜？~~）实现。

时间复杂度约为 $\Theta\left(n^2m\right)$。代码如下：

```cpp
void feature(){ //特殊效果
	queue<tuple<int,int,int> > q;
	for (pii it:dels)
		if (a[it.first][it.second].second){ //如果有特殊效果
			q.push(make_tuple(it.first,it.second,a[it.first][it.second].second)); //加入队列
			a[it.first][it.second].second=0; //取消效果，否则会被多次加入
		}
	while (!q.empty()){ //宽搜板子
		auto fr=q.front();q.pop();
		int x=get<0>(fr),y=get<1>(fr),op=get<2>(fr); //x 和 y 表示坐标，op 表示功能的类型
		switch (op){
			case 1: //消一行
				for (int i=1;i<=m;++i)
					if (a[x][i].first){
						if (a[x][i].second)
							q.push(make_tuple(x,i,a[x][i].second)),a[x][i].second=0;
						dels.insert(make_pair(x,i));
					}
				break;
			case 2: //消一列
				for (int i=1;i<=n;++i)
					if (a[i][y].first){
						if (a[i][y].second)
							q.push(make_tuple(i,y,a[i][y].second)),a[i][y].second=0;
						dels.insert(make_pair(i,y));
					}
				break;
			case 3: //消一行 + 一列
				for (int i=1;i<=m;++i)
					if (a[x][i].first){
						if (a[x][i].second)
							q.push(make_tuple(x,i,a[x][i].second)),a[x][i].second=0;
						dels.insert(make_pair(x,i));
					}
				for (int i=1;i<=n;++i)
					if (a[i][y].first){
						if (a[i][y].second)
							q.push(make_tuple(i,y,a[i][y].second)),a[i][y].second=0;
						dels.insert(make_pair(i,y));
					}
				break;
			case 4: //消 3*3 区域
				for (int i=max(1ll,x-1);i<=min(n,x+1);++i)
					for (int j=max(1ll,y-1);j<=min(m,y+1);++j)
						if (a[i][j].first){
							if (a[i][j].second)
								q.push(make_tuple(i,j,a[i][j].second)),a[i][j].second=0;
							dels.insert(make_pair(i,j));
						}
				break;
			case 5: //消 5*5 区域
				for (int i=max(1ll,x-2);i<=min(n,x+2);++i)
					for (int j=max(1ll,y-2);j<=min(m,y+2);++j)
						if (a[i][j].first){
							if (a[i][j].second)
								q.push(make_tuple(i,j,a[i][j].second)),a[i][j].second=0;
							dels.insert(make_pair(i,j));
						}
				break;
			case 6: //消同色棋子
				for (int i=1;i<=n;++i)
					for (int j=1;j<=m;++j)
						if (a[i][j].first==a[x][y].first){
							if (a[i][j].second)
								q.push(make_tuple(i,j,a[i][j].second)),a[i][j].second=0;
							dels.insert(make_pair(i,j));
						}
				break;
			default:
				break;
		}
	}
}
```

### 统计消除奖分

按题中所给公式模拟即可，没什么好说的。

时间复杂度 $\Theta\left(nm\right)$。代码如下：

```cpp
void calcchesses(int turns){ //统计消除奖分
	for (pii it:dels){
		int x=it.first,y=it.second;
		ans+=a[x][y].first*turns; //公式
	}
	return;
}
```

### 消除棋子

现在所有要消除的棋子都在 `dels` 里面，所以直接遍历 `dels` 逐个进行消除即可。

时间复杂度 $\Theta\left(nm\right)$。代码如下：

```cpp
void remove(){ //消除棋子
	for (pii it:dels){
		int x=it.first,y=it.second;
		a[x][y].first=0;
	}
	return;
}
```

### 重力下落

对于每一列分开考虑，如果这一个位置有棋子，那么它下落的格数就等于这一列它下面被消除的棋子个数。

所以对每一列做后缀和，统计被消除棋子的个数，即可从 $\Theta\left(n^2m\right)$ 优化到 $\Theta\left(nm\right)$。

时间复杂度 $\Theta\left(nm\right)$。代码如下：

```cpp
int zeros[maxn]; //后缀和，表示被消除棋子的个数
void down(){ //重力下落
	for (int i=1;i<=m;++i){
		for (int j=n;j;--j){ //后缀和
			if (!a[j][i].first) zeros[j]=zeros[j+1]+1;
			else zeros[j]=zeros[j+1];
		}
		for (int j=n;j;--j)
			if (a[j][i].first) //如果有棋子
				if (j+zeros[j]<=n){
					pii tmp=a[j][i];
					a[j][i]=make_pair(0,0);
					a[j+zeros[j]][i]=tmp; //交换
				}
	}
	return;
}
```

### 枚举主颜色

显然，对于每一次操作，最少有一个主颜色，最多有两个主颜色。

那么我们就对有两个主颜色的操作进行枚举，因为最多只有 $5$ 次操作需要枚举，所以枚举的次数不超过 $2^5=32$ 次。

枚举可以使用 $\texttt{dfs}$，也可以直接用二进制数枚举。

时间复杂度 $\Theta\left(2^{len}k\le 32k\right)$，其中 $len$ 表示有 $2$ 个主颜色的操作总数。代码如下：

```cpp
int dfscolors(){ //枚举主颜色，返回值表示这五次操作的最大牌型奖分
	vector<int> dbcols; //有 2 个主颜色的操作编号
	for (int i=0;i<5;++i)
		if (col[i].size()==2) dbcols.push_back(i);
	int len=dbcols.size(),range=1<<len,num=0;
	vector<int> nowcol;
	int maxx=0;
	for (int i=0;i<range;++i){ //二进制数枚举
		num=0;
		for (int j=0;(1<<j)<=i;++j)
			if (i&(1<<j)) num|=(1<<dbcols[j]); //计算当前状态对应的数
		nowcol.clear();
		for (int j=0,k=1;j<5;++j,k<<=1){ //依次取主颜色
			if (num&k) nowcol.push_back(*col[j].rbegin());
			else nowcol.push_back(*col[j].begin());
		}
		int res=calccolors(nowcol); //计算
		maxx=max(res,maxx);
	}
	return maxx;
}
```

### 统计当前牌型奖分

主要思想就是两次使用映射计算出每种牌型有几种。

`cnt` 表示一个数出现的次数；

`ccnt` 表示一种牌型（$1$ 个相同颜色，$1$ 对相同颜色等）出现的次数。

时间复杂度 $\Theta\left(k\right)$，不过可以通过一连串判断实现到 $\Theta\left(1\right)$。代码如下：

```cpp
int calccolors(vector<int> cols){ //统计当前牌型奖分，返回值表示当前牌型得分
	int cnt[maxk]={0},ccnt[6]={0};
	for (int it:cols) ++cnt[it];
	for (int i=1;i<=kinds;++i) ++ccnt[cnt[i]];
	if (ccnt[1]==5){ //高牌：5 种不同颜色
		int maxx=*max_element(cols.begin(),cols.end()); //取最大颜色编号
		return 50+maxx;
	}
	if (ccnt[1]==3&&ccnt[2]==1){ //一对：1 对+ 3 种不同颜色
		for (int i=kinds;i;--i)
			if (cnt[i]==2) return 100+(i<<1);
	} 
	if (ccnt[1]==1&&ccnt[2]==2){ //两对：2 对+ 1 种不同颜色
		int res=200,flg=1;
		for (int i=kinds;i;--i)
			if (cnt[i]==2) res+=(i<<flg),flg=0;
		return res;
	}
	if (ccnt[3]==1&&ccnt[1]==2){ //三条：3 种相同颜色+ 2 种不同颜色
		for (int i=kinds;i;--i)
			if (cnt[i]==3) return 300+i*3;
	}
	if (ccnt[3]==1&&ccnt[2]==1){ //葫芦：3 个相同颜色 + 另外 2 个相同颜色
		int res=500;
		for (int i=kinds;i;--i)
			if (cnt[i]==3) res+=i*3;
			else if (cnt[i]==2) res+=i;
		return res;
	}
	if (ccnt[4]==1&&ccnt[1]==1){ //四条：4 个相同颜色 + 1 个其他颜色
		for (int i=kinds;i;--i)
			if (cnt[i]==4) return 750+i*5;
	}
	if (ccnt[5]==1){ //五条：5 个颜色全部相同
		for (int i=kinds;i;--i)
			if (cnt[i]==5) return 1000+i*10;
	}
	return 0;
}
```

### 主函数和剩下的几种得分

这些得分比较简单，我就都放在了主函数里计算。

```cpp
bool alluse=true; //标记操作是否全部有效
while (q--){
	int xa=read(),ya=read(),xb=read(),yb=read();
	bool flg=change(xa,ya,xb,yb);
	if (flg){ //如果操作有效
		calcsquares();
		feature();
		calcchesses(1);
		remove();down();
		int turns=1;
		while (check(0)){
			++turns;
			calcsquares();
			feature();
			calcchesses(turns);
			remove();down();
		}
		ans+=(turns-1)*(turns-1)*80; //统计连锁奖分
		++now; //计入一次有效操作
		}
	else alluse=false; //否则无法得到全部操作有效的终局得分
	if (now==5){ //如果有效操作满 5 个
		ans+=dfscolors();
		for (int i=0;i<5;++i) col[i].clear();
		now=0;
	}
}
//以下是终局奖分
if (alluse) ans+=1000;
if (delall()) ans+=10000; //delall 函数表示是否全部删除，该函数实现简单，就不放代码了
```

## 后记

[AC 记录](https://www.luogu.com.cn/record/109447425)。

这道大模拟属于比较好做的，没有什么坑点，主要在于码量。

另外熟练运用 `STL` 在一些不卡时间的模拟题中可以减少很多不必要的错误和码量。（仅个人观点）

完结散花！！！

---


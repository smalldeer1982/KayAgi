# [THUPC 2024 初赛] 机器人

## 题目描述

有 $n$ 个机器人围成一圈，编号按照逆时针顺序分别为 $0\sim n-1$。

每个机器人有两只手。编号为 $i$ 的机器人初始「左手」指向编号 $l_i$ 的机器人，「右手」指向编号 $r_i$ 的机器人。

所有的机器人内部都写有 $m$ 行「指令」，「指令」有以下这些形式：

### 指令

「指令」分为「基础指令」和「高级指令」两种。「高级指令」的功能会更复杂一些，但它们本质上没有多大区别。下面介绍这些「指令」的格式以及它们被「执行」时的效果。文中的“自己”一词均指拥有这条「指令」的机器人。

#### 基础指令

- `SLACKOFF`：**「摸鱼」**，即什么也不做。
- `MOVE h z`：将第 $h$ 只手向逆时针方向 **「移动」** $z$ 个机器人的位置。当 $h=0$ 时表示「左手」，当 $h=1$ 时表示「右手」，下同。
- `SWAP h x y`：将第 $h$ 只手指向的机器人的第 $x$ 行「指令」与自己的第 $y$ 行「指令」 **「对调」**。
- `MIRROR h x`：将第 $h$ 只手指向的机器人的第 $x$ 行「指令」**「镜像」** 取反，即将「指令」中的 $h$ 取反（$0$ 变成 $1$，$1$ 变成 $0$）。特殊地，它对 `SLACKOFF` 指令没有效果；而对 `TRIGGER` 指令，会直接修改「触发」时「执行」的「指令」中的 $h$。
- `REPLACE h x <COMMAND>`：将第 $h$ 只手指向的机器人的第 $x$ 行「指令」**「替换」** 为 `<COMMAND>`。其中 `<COMMAND>` 为一条完整的「指令」。

#### 高级指令 

- `ACTIVATE h`：**「激活」** 第 $h$ 只手指向的机器人，即按顺序「执行」那个机器人的所有「指令」。前一行「指令」「执行」完毕之后才会「执行」后一行。注意在「执行」前面的「指令」时后面的「指令」可能会发生更改，这时需要「执行」更改后的「指令」。当那个机器人的所有「指令」「执行」完毕后，该「指令」才算「执行」完毕。

- `TRIGGER <COMMANDNAME>: <COMMAND>`：其中 `<COMMANDNAME>` 表示「指令」的名称，即一条「指令」中的第一个全大写单词；`<COMMAND>` 表示一条完整的「基础指令」。`TRIGGER` 指令不会被「执行」，即按顺序「执行」时会跳过该「指令」。但是，当一个 **其他** 机器人「执行」完一条「指令」之后，且「右手」指向自己的时候，自己最靠前的满足如下条件的 `TRIGGER` 指令（如果有）就会被 **「触发」**——「执行」一次对应的 `<COMMAND>`：

  - `<COMMANDNAME>` 不为 `TRIGGER` 时，刚刚「执行」完毕的「指令」为 `<COMMANDNAME>` 指令；
  - `<COMMANDNAME>` 为 `TRIGGER` 时，刚刚「执行」完毕的「指令」是 `TRIGGER` 指令被「触发」时「执行」的「指令」。

  「执行」完毕后会回到原来的「执行」顺序中。

你需要从 $0$ 号机器人开始按照编号顺序一圈又一圈地「激活」这些机器人，并输出「执行」的前 $k$ 条指令的有关信息。

## 说明/提示

### 样例 \#1 解释

`TRIGGER` 指令的「触发」时机是「执行」完毕之后。注意不能「触发」自己的 `TRIGGER` 指令。

### 样例 \#2 解释

注意在「执行」前面的「指令」时后面的「指令」可能会发生更改，这时需要「执行」更改后的「指令」。

### 样例 \#3 解释

`ACTIVATE` 指令「激活」另一个机器人时，当那个机器人的所有「指令」「执行」完毕后，该「指令」才算「执行」完毕。

### 样例 \#4 解释

只有自己最靠前的满足条件的 `TRIGGER` 指令才会被 **「触发」**。

### 样例 \#5 解释

无私的馈赠？有力的援助？

### 子任务

保证所有的指令的格式均正确。

保证输入文件的长度不超过 $5\mathtt{MB}$。

保证能够「执行」至少 $k$ 条「指令」。

保证 $2\le n\le 100$，$1\le m \le 10$，$1\le k \le 3\times 10^5$。

保证 $0\le l_i,r_i<n$。

保证 $0\le h \le 1$，$1\le x,y \le m$，$1\le z<n$。所有输入的数都是整数。

### 题目使用协议

来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）初赛。

以下『本仓库』皆指 THUPC2024 初赛 官方仓库（[https://github.com/ckw20/thupc2024_pre_public](https://github.com/ckw20/thupc2024_pre_public)）

1. 任何单位或个人都可以免费使用或转载本仓库的题目；

2. 任何单位或个人在使用本仓库题目时，应做到无偿、公开，严禁使用这些题目盈利或给这些题目添加特殊权限；

3. 如果条件允许，请在使用本仓库题目时同时提供数据、标程、题解等资源的获取方法；否则，请附上本仓库的 github 地址。


## 样例 #1

### 输入

```
2 2 5
0 0
MOVE 1 1
MOVE 0 1
0 1
TRIGGER MOVE: MOVE 0 1
SLACKOFF
```

### 输出

```
Robot 0 moves its right hand towards Robot 1.
Robot 1 moves its left hand towards Robot 1.
Robot 0 moves its left hand towards Robot 1.
Robot 1 moves its left hand towards Robot 0.
Robot 1 slacks off.
```

## 样例 #2

### 输入

```
2 2 4
0 1
ACTIVATE 1
SLACKOFF
0 1
SWAP 0 2 2
MIRROR 0 1
```

### 输出

```
Robot 0 activates Robot 1.
Robot 1 swaps a line of command with Robot 0.
Robot 1 slacks off.
Robot 0 modifies a line of command of Robot 0.
```

## 样例 #3

### 输入

```
3 2 6
1 2
ACTIVATE 0
ACTIVATE 0
2 1
SWAP 0 2 2
TRIGGER ACTIVATE: REPLACE 0 2 SLACKOFF
0 1
TRIGGER MIRROR: SLACKOFF
SLACKOFF
```

### 输出

```
Robot 0 activates Robot 1.
Robot 1 swaps a line of command with Robot 2.
Robot 1 slacks off.
Robot 2 replaces a line of command of Robot 0.
Robot 0 slacks off.
Robot 1 swaps a line of command with Robot 2.
```

## 样例 #4

### 输入

```
3 2 8
0 1
SLACKOFF
TRIGGER MOVE: SLACKOFF
1 2
TRIGGER TRIGGER: SLACKOFF
TRIGGER SLACKOFF: MOVE 0 1
2 0
TRIGGER SLACKOFF: MOVE 1 2
TRIGGER TRIGGER: MOVE 1 1
```

### 输出

```
Robot 0 slacks off.
Robot 1 moves its left hand towards Robot 2.
Robot 2 moves its right hand towards Robot 1.
Robot 1 slacks off.
Robot 2 moves its right hand towards Robot 0.
Robot 0 slacks off.
Robot 1 slacks off.
Robot 2 moves its right hand towards Robot 2.
```

## 样例 #5

### 输入

```
见附加文件的 5.in。```

### 输出

```
见附加文件的 5.ans。```

# 题解

## 作者：Lazy_Labs (赞：8)

# -1.HACK
## HACK1
**输入 1**：
```
2 2 7
1 1
REPLACE 0 1 MOVE 0 1
MIRROR 0 1
0 0
SLACKOFF
REPLACE 0 2 SLACKOFF
```
**输出 1**：（着重看最后一行的 `left`）
```
Robot 0 replaces a line of command of Robot 1.
Robot 0 modifies a line of command of Robot 1.
Robot 1 moves its right hand towards Robot 1.
Robot 1 replaces a line of command of Robot 0.
Robot 0 replaces a line of command of Robot 1.
Robot 0 slacks off.
Robot 1 moves its left hand towards Robot 1.
```
错于此，转到 **坑点1**。
## HACK2
**输入 2**：
```
2 2 4
1 1
MOVE 0 1
ACTIVATE 0
0 0
SLACKOFF
SLACKOFF
```
**输出 2**：（着重看最后一行）
```
Robot 0 moves its left hand towards Robot 0.
Robot 0 activates Robot 0.
Robot 0 moves its left hand towards Robot 1.
Robot 0 activates Robot 1.
```
错于此，转到 **坑点2**。
# 0.前言
你说得对，但是这篇题解很蠢，可能对继承的理解也不是很深，有更简单的写法可以提出来，shaber 作者学习一下。
# 1.继承
定义一个 `struct Command` 表示一个指令的基类。可以共用同名函数（需要用虚函数即 `virtual`），以及同名变量。

代码如下（变量解释见注释）：

```cpp
struct Command
{
    int id;//表示指令的类型，实际上也可以不计这个，直接使用typeid或者其他来实现，id 按照题目指令依次为 1~6。
    bool h,tri;//h:这条指令的 h，tri:这条指令是否是trigger触发的
    inline virtual void init()=0;//这条指令的初始化
    inline virtual void update(int rbt,int cid)=0;//执行这条指令
};
```

下面以 SLACKOFF 来举个例子：

```cpp
struct Slackoff:Command //:后接继承的函数
{
    inline void update(int rbt,int cid)override//表示 Command 的虚函数
    {
    	printf("Robot %d slacks off.\n",rbt);if(!--k)exit(0);//输出
    	if(Rbt[rbt].hd[1]!=rbt)Rbt[Rbt[rbt].hd[1]].check_trigger(this);//检查右手的 trigger 条件
    }
    inline void init()override{id=0;tri=0;}//tri=0 不为 trigger 指令，id 为 0
};
```

一些实现：

`dynamic_cast<Trigger*>cmd`

可以强制转化 `cmd` 为 `Trigger` 类，此时就可以调用 `Trigger` 专属的函数。
# 2.指令类
刚刚介绍过了。
# 3.机器人类
需要存储这个机器人的所有指令，此时可以直接使用 `Command* cmd[10];` 来描述这个机器人的指令。

**注意，基类不能直接使用 `Command` 定义，定义时一定要用像 `Slackoff` 这样的类定义。**

此时继承的方便性就呈现出来了，当你要依次激活这个机器人的指令的时候，只需要：

```cpp
for(int i=0;i<m;i++)cmd[i]->update(...);//内部填的啥待会再说
```

就行了。

具体的，机器人类目前要存储：

- `int rbt;` 表示当前机器人的编号；

- `int hd[2];` 表示机器人的左右手指向；

- `Command* cmd[10];` 表示机器人的所有指令。
# 4.基础指令
代码最后会统一给出。
## 4.1 SLACKOFF 和 MOVE
对于所有指令来说，我们知道它们属于某个固定的机器人，于是在执行 `update` 时要传入 `rbt` 表示这个指令是由哪个机器人执行的。

SLACKOFF 刚刚介绍过了，不再阐述。

MOVE 指令要新存一个变量 `z`，表示和题目相同。

`Move` 内实现的 `init` 便需要读入 `h` 和 `z`。

对于 Move 的 `update`，我们要找到这个机器人的 `h` 手，即 `Rbt[rbt].hd[h]` （为了方便，我们将其定义为 `hrbt`），然后将其循环移位即可。**注意输出要在移位后执行。**
## 4.2 SWAP，MIRROR，REPLACE
这三个指令是对机器人内部的指令进行修改，具体实现如下：

### SWAP
十分简单，直接交换两个机器人的 `Command` 指针即可。

### REPLACE
发现这个指令内部要记一个指令指针 `Command* comd`，表示这个指令替换时替换成的指令，`update` 也很好实现：只要把目标位置上的指令指针指向 `comd` 即可。

### MIRROR
也很简单，只要把目标指令的 `h` 值异或一下即可。

吗？

### 坑点1
考虑一组 hack：
```
2 2 7
1 1
REPLACE 0 1 MOVE 0 1
MIRROR 0 1
0 0
SLACKOFF
REPLACE 0 2 SLACKOFF
```

按照我们的想法，最后一句输出：`Robot 1 moves its right hand towards Robot 1.`，实际上应该是 `left hand`。

我们发现一件事：当 MIRROR 指令反转的是 REPLACE 过后的指令时，此时直接更改了 REPLACE 指令内部的 `comd`。然而我们只想要反转真实的指令：

此时就要在机器人类中记一个 `h[10]` 表示每个指令的“反转标记”，那么，对于所有 `update` 函数来说，我们就要传入一个 `cid` 表示当前指令是 `rbt` 的第几条指令，然后使用 `Rbt[rbt].hd[Rbt[rbt].h[cid]^h]` 来表示当前指令的手。

PS：其实可以把指令中的 `h` 和机器人类中的 `h` 合并的，但是我懒，于是就直接改了。

再次考虑有无其他可能更改 `comd` 的指令，发现没有，那么考虑适配：

SWAP：要多交换两条指令的 `h` 数组中的数字。

REPLACE：要将当前指令的 `h` 数组置为 0。

MIRROR：只要将指向指令的 `h` 数组取反即可。

于是，我们便完成了基础指令。

# 5.高级指令
和普通指令没有区别，也是继承基类 `Command`。
# 5.1 ACTIVATE
`update` 中直接执行 `for(int i=0;i<m;i++)Rbt[hrbt].cmd[i]->update(hrbt,i);` 即可。

吗？
# 坑点 2
你发现一件事，执行每条指令的 `update` 时，当前机器人的手可能会动，所以不能直接用 `hrbt`，而是要在 `for` 前将指向的机器人存下来。

# 5.2 TRIGGER
TRIGGER 指令要存储的信息有：`type` 表示检测的条件，`comd` 表示执行的指令。

读题，发现 TRIGGER 指令是在**每次指令操作结束后都有可能执行**，于是对于机器人类定义一个函数，表示查找是否会执行 TRIGGER 指令。代码如下：

```cpp
inline void check_trigger(Command* comd)
{
    for(int i=0;i<m;i++)if(cmd[i]->id==6)
    if(dynamic_cast<Trigger*>(cmd[i])->type==6)
    {
        if(comd->tri)return dynamic_cast<Trigger*>(cmd[i])->work(rbt,i);
    }
    else if(dynamic_cast<Trigger*>(cmd[i])->type==comd->id)
    return dynamic_cast<Trigger*>(cmd[i])->work(rbt,i);
}
```

注意到题目中的：**其他**机器人，所以我们要在所有的 `update` 后执行：

```cpp
if(Rbt[rbt].hd[1]!=rbt)Rbt[Rbt[rbt].hd[1]].check_trigger(this);
```

其中 `dynamic_cast<Trigger*>` 为强转为 `Trigger` 类，且 `id` 比较也可以用 `typeid` 来解决。

介于 `TRIGGER` 并没有实际执行，所以其 `update` 为空，新开一个 `work` 函数，作为执行 `TRIGGER` 时调用的函数。代码：

```cpp
inline void work(int rbt,int cid){comd->update(rbt,cid);}
```

至此，我们完成了所有指令。
# 6.读入指令
定义一个函数 `create` 表示读入一个指令并且返回一个 `Command*`。

代码容易实现（可能有更好的实现，你说的对，但是）：

```cpp
inline Command* create()
{
    string s;cin>>s;Command *comd;
    if(s=="SLACKOFF")comd=new Slackoff;
    else if(s=="MOVE")comd=new Move;
    else if(s=="SWAP")comd=new Swap;
    else if(s=="MIRROR")comd=new Mirror;
    else if(s=="REPLACE")comd=new Replace;
    else if(s=="ACTIVATE")comd=new Activate;
    else if(s=="TRIGGER")comd=new Trigger;
    comd->init();
    return comd;
}
```

我们来考虑实现每个指令的 `init`。
# 6.1 SLACKOFF，SWAP，MIRROR，ACTIVATE
这四种指令的 `init` 是容易的，直接读入并将 `id` 和 `tri` 赋值即可。
# 6.2 REPLACE
`comd=create()` 就能完成，剩余部分同上。
# 6.3 TRIGGER
最前面的 COMMANDNAME 确定 `type`，剩余部分同上。

至此，所有部分都完成了。
# 7.完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
    int x(0),f(1);char c=getchar();
    while(c<'0'||c>'9')f=c=='-'?-1:1,c=getchar();
    while(c<='9'&&c>='0')x=x*10+c-48,c=getchar();
    return x*f;
}
#define hrbt Rbt[rbt].hd[h^Rbt[rbt].h[cid]]
int n,m,k;
struct Command
{
    int id;bool h,tri;
    inline virtual void init()=0;
    inline virtual void update(int rbt,int cid)=0;
};
inline Command* create();
struct Trigger:Command
{
    int type;Command* comd;
    inline void init()override
    {
        string s;cin>>s;
        if(s=="SLACKOFF:")type=0;
        else if(s=="MOVE:")type=1;
        else if(s=="SWAP:")type=2;
        else if(s=="MIRROR:")type=3;
        else if(s=="REPLACE:")type=4;
        else if(s=="ACTIVATE:")type=5;
        else if(s=="TRIGGER:")type=6;
        comd=create();
        id=6;tri=0;comd->tri=1;
    }
    inline void update(int rbt,int cid)override{};inline void work(int rbt,int cid){comd->update(rbt,cid);}
};
struct Robot
{
    int hd[2],rbt;Command* cmd[10];bool h[10];
    inline void check_trigger(Command* comd)
    {
        for(int i=0;i<m;i++)if(cmd[i]->id==6)
        if(dynamic_cast<Trigger*>(cmd[i])->type==6)
        {
            if(comd->tri)return dynamic_cast<Trigger*>(cmd[i])->work(rbt,i);
        }
        else if(dynamic_cast<Trigger*>(cmd[i])->type==comd->id)
        return dynamic_cast<Trigger*>(cmd[i])->work(rbt,i);
    }
}Rbt[110];
struct Slackoff:Command
{
    inline void update(int rbt,int cid)override{printf("Robot %d slacks off.\n",rbt);if(!--k)exit(0);
    if(Rbt[rbt].hd[1]!=rbt)Rbt[Rbt[rbt].hd[1]].check_trigger(this);}
    inline void init()override{id=0;tri=0;}
};
inline void move(int &x,int y){x=(x+y)%n;}
struct Move:Command
{
    int z;
    inline void init()override{h=read();z=read();id=1;tri=0;}
    inline void update(int rbt,int cid)override
    {
        move(hrbt,z);
        printf("Robot %d moves its %s hand towards Robot %d.\n",rbt,h^Rbt[rbt].h[cid]?"right":"left",hrbt);if(!--k)exit(0);
        if(Rbt[rbt].hd[1]!=rbt)Rbt[Rbt[rbt].hd[1]].check_trigger(this);
    }
};
template<typename T>
inline void swaps(T &a,T &b,bool &ta,bool &tb){swap(a,b);swap(ta,tb);}
struct Swap:Command
{
    int x,y;
    inline void init()override{h=read();x=read()-1;y=read()-1;id=2;tri=0;}
    inline void update(int rbt,int cid)override
    {
        printf("Robot %d swaps a line of command with Robot %d.\n",rbt,hrbt);if(!--k)exit(0);
        swaps(Rbt[rbt].cmd[y],Rbt[hrbt].cmd[x],Rbt[rbt].h[y],Rbt[hrbt].h[x]);
        if(Rbt[rbt].hd[1]!=rbt)Rbt[Rbt[rbt].hd[1]].check_trigger(this);
    }
};
struct Mirror:Command
{
    int x;
    inline void init()override{h=read();x=read()-1;id=3;tri=0;}
    inline void update(int rbt,int cid)override
    {
        printf("Robot %d modifies a line of command of Robot %d.\n",rbt,hrbt);if(!--k)exit(0);
        Rbt[hrbt].h[x]^=1;
        if(Rbt[rbt].hd[1]!=rbt)Rbt[Rbt[rbt].hd[1]].check_trigger(this);
    }
};
struct Replace:Command
{
    int x;Command* comd;
    inline void init()override
    {
        h=read();x=read()-1;
        comd=create();
        id=4;tri=0;
    }
    inline void update(int rbt,int cid)override
    {
        printf("Robot %d replaces a line of command of Robot %d.\n",rbt,hrbt);if(!--k)exit(0);
        Rbt[hrbt].h[x]=0;Rbt[hrbt].cmd[x]=comd;
        if(Rbt[rbt].hd[1]!=rbt)Rbt[Rbt[rbt].hd[1]].check_trigger(this);
    }
};
struct Activate:Command
{
    inline void init()override{h=read();id=5;tri=0;}
    inline void update(int rbt,int cid)override
    {
        printf("Robot %d activates Robot %d.\n",rbt,hrbt);if(!--k)exit(0);
        int qwq=hrbt;for(int i=0;i<m;i++)Rbt[qwq].cmd[i]->update(qwq,i);
        if(Rbt[rbt].hd[1]!=rbt)Rbt[Rbt[rbt].hd[1]].check_trigger(this);
    }
};
inline Command* create()
{
    string s;cin>>s;Command *comd;
    if(s=="SLACKOFF")comd=new Slackoff;
    else if(s=="MOVE")comd=new Move;
    else if(s=="SWAP")comd=new Swap;
    else if(s=="MIRROR")comd=new Mirror;
    else if(s=="REPLACE")comd=new Replace;
    else if(s=="ACTIVATE")comd=new Activate;
    else if(s=="TRIGGER")comd=new Trigger;
    comd->init();
    return comd;
}
int main()
{
    // freopen("in","r",stdin);freopen("out","w",stdout);
    n=read(),m=read(),k=read();
    for(int i=0;i<n;i++)
    {
        Rbt[i].hd[0]=read(),Rbt[i].hd[1]=read();Rbt[i].rbt=i;
        for(int j=0;j<m;j++)Rbt[i].cmd[j]=create();
    }
    for(int i=0;;(i=i+1)%=n)for(int j=0;j<m;j++)Rbt[i].cmd[j]->update(i,j);
    return 0;
}
```

---

## 作者：StudyingFather (赞：5)

基本思路当然是照题意模拟，不过如何把模拟代码写的优雅一些呢？来一篇基于面向对象思想（OOP）编写的代码的题解。

## 1 基本框架

整个程序事实上分为两个步骤：第一步是机器人初始化，第二步是命令执行。

在第一步，需要为每个机器人设置好它两只手的初始指向目标，并填充命令列表；在第二步，需要不断模拟执行机器人的指令。

## 2 机器人类

机器人类用于存储其自身状态。

```cpp
struct Robot {
  /* id of the robot. */
  int id;
  /* left hand and right hand of the robot. */
  int hand[2];
  /* command list of the robot. */
  vector<Command *> cmd_list;
  /*
   * read command from input and parse it.
   * @return pointer to the parse result.
   */
  Command *parse_command();
  /*
   * initialize the robot.
   * @param id the id of current robot.
   * @param command_num number of commands the robot has.
   */
  void init(int id, int command_num);
} robots[maxn + 5];
```

其中，`parse_command` 函数将输入按题目给出的格式解析成对应的指令存储，`init` 函数用于读入双手位置和命令列表，二者的细节不再赘述。

## 3 计数器类

为了简化代码，为指令计数器设计了一个计数器类。当计数器值归零时，程序将自动退出。

```cpp
struct Counter {
  int cnt;
  /*
   * initialize the counter.
   * @param cnt initial value of the counter.
   */
  void init(int cnt) { this->cnt = cnt; }
  /*
   * make the count decrease by 1.
   * if the count goes zero or negative, terminate the whole program.
   */
  void count() {
    cnt--;
    if (cnt <= 0) exit(0);
  }
} cnter;
```

## 4 指令类

### 4.1 概述

为所有指令定义了一个 `Command` 基类。

```cpp
struct Command {
    /* type of command. */
    CommandType type;
    int refcnt;
    Command() : refcnt(1) {}
    /* pure virtual destructor. */
    virtual ~Command() = 0;
    /*
     * mirror current command.
     * note that implementation need to copy the original command and leave the
     * original command unchanged.
     */
    virtual Command *mirror() = 0;
    /*
     * execute the current command.
     * @param r robot who executes the command.
     * @param is_triggered is the command triggered by other command.
     */
    virtual void exec(Robot &r, bool is_triggered) = 0;
    /* clone current command. */
    virtual Command *clone() = 0;
    virtual CommandType get_trigger_type() {
        return CommandType::empty;
    }
    virtual CommandType get_trigger_command_type() {
        return CommandType::empty;
    }
    /*
     * trigger command, only useful for TriggerCommand class.
     * @param r robot who executes the command.
     */
    virtual void trigger(Robot &r) {}
    /*
     * check if the current command is a trigger command.
     * @return `true` if the current command is a trigger command, otherwise
     * `false`.
     */
    bool is_trigger() {
        return type == CommandType::trigger;
    }
    /*
     * try to trigger other robot after executing the current command.
     * this function is called when a command finishes its execution.
     * @param r robot who executes the command.
     * @param is_triggered is the command triggered by other command.
     */
    void try_trigger(Robot &r, bool is_triggered) {
        int targetid = r.hand[1];

        if (targetid == r.id) {
            // robot can not trigger itself
            return;
        }

        for (auto cmd : robots[targetid].cmd_list) {
            if (!cmd->is_trigger())
                continue;

            if (cmd->get_trigger_type() == CommandType::trigger) {
                if (is_triggered) {
                    cmd->trigger(robots[targetid]);
                    return;
                }
            } else {
                if (type == cmd->get_trigger_type()) {
                    cmd->trigger(robots[targetid]);
                    return;
                }
            }
        }
    }
};
```

接下来，对于每种指令，都定义一个 `Command` 类的子类，子类中定义适当的信息字段，并给出基类函数的实现。

### 4.2 重要成员函数

一部分函数被定义为**纯虚函数**，要求每个类型的指令都给出对应的实现；还有一部分函数被定义为**虚函数**，提供了一个适用于大部分指令的默认实现，并允许一些特殊指令覆盖默认实现。一个例子是 `trigger` 函数，因为只有 `TRIGGER` 类指令是可被**触发**的指令，其他指令则不可被触发，因此提供了一个空函数的默认实现。

所有成员函数中，较为关键的函数的功能描述如下：

- `Command *mirror()`：**复制**并**反转**当前指令。
- `void exec(Robot &r, bool is_triggered)`：**执行**当前指令，参数 `r` 代表执行该指令的机器人，`is_triggered` 代表该指令是否是被其他指令触发执行的。
- `Command *clone()`：**复制**当前指令。
- `void try_trigger(Robot &r, bool is_triggered)`：在当前指令结束后，尝试**触发**其他机器人。该函数实现与指令类型无关。
- `void trigger(Robot &r) {}`：**触发**当前指令。

这些函数的一般实现思路如下：

- `mirror`：先调用 `clone` 函数将当前指令复制。然后在复制后的新指令上执行镜像操作，最后返回新指令的地址，原指令在这一过程中保持不变。需要复制的原因是避免其他无关指令被意外修改（见后文）。
- `exec`：先执行命令，然后更新计数器，在计数器未归零的情况下调用 `try_trigger` 函数尝试触发其他机器人。
- `clone`：调用复制构造函数。
- `trigger`：对于 `TRIGGER` 指令，要干的唯一事情就是执行其包含的指令。对其他类型指令，则全为空函数。

下面以 `SWAP` 指令为例，给出相应的实现。其他大部分类型指令的实现都是类似的，只需按题意来即可，不再赘述。

```cpp
/* swap command class. */
struct SwapCommand : public Command {
  int h, x, y;
  SwapCommand(int h, int x, int y) : h(h), x(x), y(y) {
    type = CommandType::swap;
  }
  ~SwapCommand() {}
  Command *mirror() {
    SwapCommand *new_cmd = this->clone();
    new_cmd->h ^= 1;
    return new_cmd;
  }
  void exec(Robot &r, bool is_triggered);
  SwapCommand *clone() { return (new SwapCommand(*this)); }
};
void SwapCommand::exec(Robot &r, bool is_triggered) {
  swap(robots[r.hand[h]].cmd_list[x], r.cmd_list[y]);
  cout << "Robot " << r.id << " swaps a line of command with Robot "
       << r.hand[h] << "." << '\n';
  cnter.count();
  try_trigger(r, is_triggered);
}
```

### 4.3 特殊实现

部分指令类的实现较为特殊。

#### 4.3.1 REPLACE

`REPLACE` 指令的 `exec` 函数实现如下：

```cpp
void ReplaceCommand::exec(Robot &r, bool is_triggered) {
  robots[r.hand[h]].cmd_list[x] = cmd;
  cout << "Robot " << r.id << " replaces a line of command of Robot "
       << r.hand[h] << "." << '\n';
  cnter.count();
  try_trigger(r, is_triggered);
}
```

这里的代码是一个**浅拷贝**，执行后将存在两个指针指向同一条指令。

在这一前提下，如果 `MIRROR` 指令直接修改一个指针执行的命令内容的话，将可能影响其他无关指令，这事实上是不对的。

事实上，这里用到了**写时复制**（Copy-on-write）的思想。复制时进行浅拷贝，将真正的复制操作推迟到对数据修改时进行，以减少不必要的复制开销。也因此，`mirror` 操作需要先复制，再修改。

那么，能不能一开始就进行深拷贝呢？事实上是做不到的。`REPLACE` 指令的递归深度可以非常深，对这样深的一条链进行深拷贝成本难以接受。事实上，Copy-on-write 对于这样的深层递归也只是在数据修改时复制一层，其余层在后续涉及到修改过程时再进行复制，看起来有那么一点可持久化的意味。

#### 4.3.2 ManualActivateCommand

为了让代码风格更统一，我将人的手动激活操作也抽象为了一个指令类。

为什么手动激活不能直接使用 `ACTIVATE` 的指令类？因为手动激活不算入命令执行计数，同时手动激活执行完毕后也不需要触发其他机器人。除此之外，该类的实现和 `ACTIVATE` 的指令类基本相同。

这样设计后，我们可以认为存在一个虚拟机器人，该机器人装载了 $n$ 条指令，第 $i$ 条指令（从 0 开始计数）触发第 $i$ 个机器人。整个执行过程变成了不断按顺序循环执行该虚拟机器人的指令，直到执行完指定数量的指令为止。

## 5 总结

由于 OOP 思想的运用和一些递归结构的存在，代码整体上保持了一定的可读性。不过，指针的大量运用也带来了内存别名（两个指针指向同一块内容）等问题，稍有不慎就会引入 bug，也是本题的难点所在。

## 完整代码

见 [Submission #1959590 - LibreOJ](https://loj.ac/s/1959590)，代码带有较为详细的注释。

---

## 作者：WYXkk (赞：4)

题意：大模拟，具体请直接参考[题面](https://www.luogu.com.cn/problem/P9966)。

大致没什么好说的，就直接模拟就好。下面是一些实现细节。

可以使用 `enum` 类表示指令的类型，这样可以增强可读性。

判断一个指令的类型可以通过名称的第二位来判断，每个指令的第二位是互不相同的（`LOWIECR`）。

**重要** 由于我们可以让一条很长很长的 `REPLACE` 嵌套被复制很多次，在指令的内容里存储所有信息显然是不可行的！所以记录子指令需要一定程度的复用。我使用的是仅存储子指令的指针。

输入嵌套指令可以用正确实现的递归调用输入函数。

**重要** 对于 `TRIGGER` 来说，其在被 `MIRROR` 时需要修改其存储的其他指令。然而，它本身可能是被 `REPLACE` 得到，此时它指向的其他指令可能不止它自己在用！所以，此时需要创建一条新指令再镜像，然后修改指针。根据实现不同，如果你记录机器人的指令也是记录指针，那么所有指令都需要类似的操作。

`ACTIVATE` 因为可以在主函数复用最好写成函数。这需要间接递归，就要先写 `activate` 和 `run` 之一的定义，然后写另一个的实现，再写前一个的实现。

`run` 需要执行的机器人作为上下文，所以我传入的参数是对象和行数。

`TRIGGER` 不会被通常执行，但是会有需要执行其子指令的情况。我采用的方式是，在 `activate` 时跳过 `TRIGGER`，而在 `run` 里对于 `TRIGGER` 指令直接换成其子指令。

`TRIGGER` 的触发方式显然是要你在每次 `run` 结束后判断其右手指向的机器人能否被触发。注意一个机器人不能触发自己！另外注意需要判断触发类型是 `TRIGGER` 的指令。

既然只需要前 $k$ 条指令的信息，那么一旦执行完 $k$ 条指令就对于所有尝试调用立即 `return`，这可以防止例如互相 `ACTIVATE` 的无限递归。设置一个全局计数器即可。

主函数就是轮流 `activate`，终止条件显然应该也是全局计数器是否已经到达 $k$。注意要循环触发。

然后就没了。[参考代码](https://www.luogu.com.cn/paste/ffl6iiwl)。

---

## 作者：0000pnc (赞：4)

比赛结束前两分钟写完，但是没用了/ll。[调了两天](https://loj.ac/s?problemDisplayId=6904&submitter=0000pnc)。

那么大概的模拟思路就是用下标来表示指令，这样可以很方便地进行各种操作。这里不说了，想理解的自己看代码。

这里主要说一下要注意的点。

* 不能触发自己的 `TRIGGER` 指令。

* `SWAP` 时不是交换另一个机器人的两行指令，而是自己的一条指令与另一个机器人的一行指令交换。

* `MIRROR` 修改 `TRIGGER` 命令后面的命令时需要创建一个新的副本。

* `REPLACE` 时也要创建副本。原因是 `REPLACE` 完后面有可能会修改这个命令，两者不能共用一个下标。

* 读入时你读入的 `string` 必须是局部变量，定义成全局变量可能在递归读入的时候被修改。

* 如果像我一样执行命令之前判 `now > k`，会被全 `TRIGGER` 卡掉，所以要加个特判（见 `run` 函数第一行）

大概就这么多吧，之后想到新的坑点时还会更新。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, m, k, now, tot;

struct opr {
	int typ, h, x, y, z;
	int trigger_typ, trigger_id;
	int replace_id;
	opr() {}
	opr(int t1, int t2, int t3, int t4, int t5, int t6, int t7, int t9) : typ(t1), h(t2), x(t3), y(t4), z(t5), trigger_typ(t6), trigger_id(t7), replace_id(t9) {}
} all[2000005];

void chk() {
	now++; if (now > k) exit(0);
}

struct rob {
	int op[25], ds[2];
} ro[105];

void SLACKOFF(int id, bool ist);
void MOVE(int id, int x, bool ist);
void SWAP(int id, int x, bool ist);
void MIRROR(int id, int x, bool ist);
void REPLACE(int id, int x, bool ist);
void runcommand(int id, int x, bool ist);
void ACTIVATE(int id, int x, bool ist);
void find_TRIGGER(int id, int tp, bool frm_ist);
void run(int id);

void SLACKOFF(int id, bool ist) {
	chk();
	printf("Robot %d slacks off.\n", id);
	if (id != ro[id].ds[1]) find_TRIGGER(ro[id].ds[1], 0, ist);
}
void MOVE(int id, int x, bool ist) {
	chk();
	ro[id].ds[all[x].h] = (ro[id].ds[all[x].h] + all[x].z) % n;
	if (!all[x].h) printf("Robot %d moves its left hand towards Robot %d.\n", id, ro[id].ds[all[x].h]);
	else printf("Robot %d moves its right hand towards Robot %d.\n", id, ro[id].ds[all[x].h]);
	if (id != ro[id].ds[1]) find_TRIGGER(ro[id].ds[1], 1, ist);
}
void SWAP(int id, int x, bool ist) {
	chk();
	printf("Robot %d swaps a line of command with Robot %d.\n", id, ro[id].ds[all[x].h]);
	swap(ro[ro[id].ds[all[x].h]].op[all[x].x], ro[id].op[all[x].y]);
	if (id != ro[id].ds[1]) find_TRIGGER(ro[id].ds[1], 2, ist);
}
void MIRROR(int id, int x, bool ist) {
	chk();
	printf("Robot %d modifies a line of command of Robot %d.\n", id, ro[id].ds[all[x].h]);
	if (all[ro[ro[id].ds[all[x].h]].op[all[x].x]].typ != 0 && all[ro[ro[id].ds[all[x].h]].op[all[x].x]].typ != 11) all[ro[ro[id].ds[all[x].h]].op[all[x].x]].h ^= 1;
	else if (all[ro[ro[id].ds[all[x].h]].op[all[x].x]].typ == 11) {
		all[++tot] = all[all[ro[ro[id].ds[all[x].h]].op[all[x].x]].trigger_id];
		all[tot].h ^= 1;
		all[ro[ro[id].ds[all[x].h]].op[all[x].x]].trigger_id = tot;
	}
	if (id != ro[id].ds[1]) find_TRIGGER(ro[id].ds[1], 3, ist);
}
void REPLACE(int id, int x, bool ist) {
	chk();
	printf("Robot %d replaces a line of command of Robot %d.\n", id, ro[id].ds[all[x].h]);
	all[++tot] = all[all[x].replace_id];
	ro[ro[id].ds[all[x].h]].op[all[x].x] = tot;
	if (id != ro[id].ds[1]) find_TRIGGER(ro[id].ds[1], 4, ist);
}
void runcommand(int id, int x, bool ist) {
	if (all[x].typ == 0) SLACKOFF(id, ist);
	if (all[x].typ == 1) MOVE(id, x, ist);
	if (all[x].typ == 2) SWAP(id, x, ist);
	if (all[x].typ == 3) MIRROR(id, x, ist);
	if (all[x].typ == 4) REPLACE(id, x, ist);
}
void ACTIVATE(int id, int x, bool ist) {
	chk();
	printf("Robot %d activates Robot %d.\n", id, ro[id].ds[all[x].h]);
	run(ro[id].ds[all[x].h]);
	if (id != ro[id].ds[1]) find_TRIGGER(ro[id].ds[1], 10, ist);
}
void find_TRIGGER(int id, int tp, bool frm_ist) {
	for (int i = 1; i <= m; i++) {
		if (all[ro[id].op[i]].typ == 11) {
			if (all[ro[id].op[i]].trigger_typ != 11 && all[ro[id].op[i]].trigger_typ == tp) {
				runcommand(id, all[ro[id].op[i]].trigger_id, 1); break;
			}
			else if (all[ro[id].op[i]].trigger_typ == 11 && frm_ist) {
				runcommand(id, all[ro[id].op[i]].trigger_id, 1); break;
			}
		}
	}
}
void run(int id) {
    if (k == now) exit(0);
	for (int i = 1; i <= m; i++) {
		if (all[ro[id].op[i]].typ < 5) runcommand(id, ro[id].op[i], 0);
		else if (all[ro[id].op[i]].typ == 10) ACTIVATE(id, ro[id].op[i], 0);
	}
}

int readcommand() {
    int tmp = ++tot, tmp1, tmp2, tmp3;
	string s; cin >> s;
	if (s == "SLACKOFF") all[tmp] = opr(0, 0, 0, 0, 0, 0, 0, 0);
	else if (s == "MOVE") {
		cin >> tmp1 >> tmp2;
		all[tmp] = opr(1, tmp1, 0, 0, tmp2, 0, 0, 0);
	}
	else if (s == "SWAP") {
		cin >> tmp1 >> tmp2 >> tmp3;
		all[tmp] = opr(2, tmp1, tmp2, tmp3, 0, 0, 0, 0);
	}
	else if (s == "MIRROR") {
		cin >> tmp1 >> tmp2;
		all[tmp] = opr(3, tmp1, tmp2, 0, 0, 0, 0, 0);
	}
	else if (s == "REPLACE") {
		cin >> tmp1 >> tmp2;
		int xx = readcommand();
		all[tmp] = opr(4, tmp1, tmp2, 0, 0, 0, 0, xx);
	}
	else if (s == "ACTIVATE") {
		cin >> tmp1;
		all[tmp] = opr(10, tmp1, 0, 0, 0, 0, 0, 0);
	}
	else if (s == "TRIGGER") {
		string t; cin >> t; int xx = readcommand();
		if (t == "SLACKOFF:") all[tmp] = opr(11, 0, 0, 0, 0, 0, xx, 0);
		else if (t == "MOVE:") all[tmp] = opr(11, 0, 0, 0, 0, 1, xx, 0);
		else if (t == "SWAP:") all[tmp] = opr(11, 0, 0, 0, 0, 2, xx, 0);
		else if (t == "MIRROR:") all[tmp] = opr(11, 0, 0, 0, 0, 3, xx, 0);
		else if (t == "REPLACE:") all[tmp] = opr(11, 0, 0, 0, 0, 4, xx, 0);
		else if (t == "ACTIVATE:") all[tmp] = opr(11, 0, 0, 0, 0, 10, xx, 0);
		else if (t == "TRIGGER:") all[tmp] = opr(11, 0, 0, 0, 0, 11, xx, 0);
	}
    return tmp;
}

int main() {
	cin >> n >> m >> k;
	for (int i = 0; i < n; i++) {
		cin >> ro[i].ds[0] >> ro[i].ds[1];
		for (int j = 1; j <= m; j++) {
			ro[i].op[j] = readcommand();
		}
	}
	int tt = n - 1;
	while (1) {
		tt = (tt + 1) % n;
		run(tt);
	}
}
```

---

## 作者：紊莫 (赞：4)

细节大模拟。

## 题意

一堆机器人在一起，每个人有左右手和一些指令，依次执行并输出结果。

## 做法

首先这种指令的执行还算是比较简单的大模拟，一个个实现即可，在此给出我的定义。  

```cpp
struct Robot{
	int l_hand,r_hand,lst[15];
}bot[105];
struct Order{
	string name;
	int h,x,y,z,id;
	string cmdname;//trigger 触发条件
	Order(){name=cmdname="";h=x=y=z=id=0;}
};
vector<Order> U;//所有命令
```
我将所有的命令统一存放在一起，便于后期使用。 

然后讲讲读入问题，因为可能存在超长的嵌套，所以采用递归的形式进行读入。  
```cpp
Order Analyze(){
	Order res; string s,cmd,cname; cin>>s;
	int H,X,Y,Z; res.name=s;
	if(s[1]=='O') cin>>H>>Z,res.h=H,res.z=Z;
	else if(s[1]=='W') cin>>H>>X>>Y,res.h=H,res.x=X,res.y=Y;
	else if(s[1]=='I') cin>>H>>X,res.h=H,res.x=X;
	else if(s[1]=='C') cin>>H,res.h=H;
	else if(s[1]=='E') {
		cin>>H>>X,res.h=H,res.x=X;
		Order cmd=Analyze(); U.push_back(cmd);
		res.id=int(U.size())-1;
	}else if(s[1]=='R'){
		cin>>cname;cname.pop_back();res.cmdname=cname;
		Order cmd=Analyze();U.push_back(cmd);
		res.id=int(U.size())-1;
	}
	return res;
}
```

另外，在这里你可能关注到了我的判断方式，这种写法考场不容易写错，也能减小常数，因为 ``string`` 的比较还是很费时的，当然在这题命令不长也无所谓。

之后就是具体实现每个操作了，因为其他操作都很简单，在这里就解释部分坑点，难点。

### MIRROR 操作

对于不是 ``TRIGGER`` 的操作还是简单的直接取反即可，但是对 ``TRIGGER`` 的操作，因为要考虑到一个指令不一定只有一个人在用，所以不能直接对原指令搞，而要另外拷贝一个。

### REPLACE 操作

其实和 ``MIRROR`` 一样，使用拷贝即可。

### TRIGGER 操作

其实说的是怎么判断一个操作是不是被触发而来的。

首先，你自己调用的（或 ``ACTIVATE``），肯定不是触发的，做一个标记即可判断,详见代码。

至此为止就可以通过这题了。

## 代码

说实话大模拟的代码作用不大，但也可以看看我的实现方法，自认为代码比较短。

[code.](https://www.luogu.com.cn/paste/5lvefd2i)

---

## 作者：江户川·萝卜 (赞：3)

场上最后 12min 冲出来的端茶倒水人前来报道。

___


实际上这道题对于其他大模拟（或者 THUPC 往年的模拟）较为简单之处在于：

- 指令仅有 $7$ 种，题面不长，指令不难，题意清晰，容易模拟。往年比如有 [P9381 [THUPC 2023 决赛] 那些脑海里最珍贵的](https://www.luogu.com.cn/problem/P9381) 难点在此。

- 总体流程是线性的，无分支，容易编写代码。往年比如有 [P8422 [THUPC2022 决赛] 德州消消乐](https://www.luogu.com.cn/problem/P8422) 难点在此。

- 并没有涉及诸如计算几何此类细节繁多、难调的算法。往年比如有 [P9141 [THUPC 2023 初赛] 乱西星上的空战](https://www.luogu.com.cn/problem/P9141) 难点在此。

另外，此题场上有约二十个队通过，所以本题定位是小模拟，可做题，可以一试。

~~但是我场上跟指针决一死战差点没冲出来。~~

-----

### Part I 定义

写的时候没有用一些 C++ 语法糖导致实现起来很答辩。

大概就是两个类，指令 和 机器人。

$7$ 种指令需要的参数的并集如下：

- $t$，指定类型。

- $h$，指定哪只手。

- $x,y$，两个整型参数。特别地，在 `TRIGGER` 中 $x$ 指定了触发的指令类型。

- $w$，子指令。代码中使用指针实现。

指令分别的参数请见代码。

然后实现一下指令的输入输出，扔一个触发指令的空函数，这块就搞定了。

机器人类中的参数基本就是两只手指向的机器人编号和自身的若干指令。

### Part II 触发指令

其实核心就在这块了。

由于我采用的是先触发指令再输出的形式，所以需要预先存一下这个指令是什么，否则会被 `SWAP` 等操作覆盖。

然后实际上七种指令都挺好维护的。

最后触发完记得看看右手有没有 `TRIGGER`。不能自己 `TRIGGER` 自己。

### Part III 这就完了吗？

~~你以为我为什么会和指针决一死战。~~

考虑我们的指针是会被复制的。比如说 `REPLACE` 函数。

一旦指针内部的参数被改，被复制的地方也会被牵连。

但是考虑到数据可能会存在 `REPLACE` 和 `TRIGGER` 嵌套的指令，不用指令去做可能并不是很容易。

可以考虑开个内存池！具体地，当你每次复制一个指针时，不去复制指针，而是将指针内部参数存在一个地方，新指针指向那个地方即可。

改完就喜提 TLE。想想为什么。

存在一种极端情况，就是场上只有一个非 `TRIGGER` 指令。这样最劣复杂度是 $O(nmk)$ 的。常数小没准能过，但是显然可以优化。

比如说给每个机器人打一个 `tag`，标记这个机器人的所有指令是否都是 `TRIGGER`。暴力维护这个 `tag` 复杂度都是对的，大概是 $O(nk)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k;
struct op{
    // 1 SLACKOFF
    // 2 MOVE h x
    // 3 SWAP h x y
    // 4 MIRROR h x
    // 5 REPLACE h x w
    // 6 ACTIVATE h
    // 7 TRIGGER x w
    int typ;
    bool h;int x,y;
    op* w;
    op(int _t=0,int _h=0,int _x=0,int _y=0,op* _w=NULL):typ(_t),h(_h),x(_x),y(_y),w(_w){}
    inline void inp(){
        string s,t;cin>>s;char q[8]="LOWIECR";
        switch(s[1]){
            case 'L':h=0;typ=1;break;
            case 'O':typ=2;cin>>h>>x;break;
            case 'W':typ=3;cin>>h>>x>>y;break;
            case 'I':typ=4;cin>>h>>x;break;
            case 'E':typ=5;cin>>h>>x;w=new op;w->inp();break;
            case 'C':typ=6;cin>>h;break;
            case 'R':typ=7;
                h=0;
                cin>>t;
                for(int i=0;i<7;i++) if(t[1]==q[i]){x=i+1;break;}
                w=new op;
                w->inp();break;
        }
        // cout<<typ<<' '<<h<<' '<<x<<' '<<y<<'\n';
    }
    inline void mov(int id,bool R);
    inline void outp(int id);
}pl[2000005];int tot;
int Cnt=0;
struct pla{
    int hd[2];bool f;
    op p[11];
    inline void inp(){
        cin>>hd[0]>>hd[1];
        f=1;
        for(int i=1;i<=m;i++) p[i].inp(),f&=(p[i].typ==7);
    }
}P[105];
inline void acti(int x){
    if(P[x].f) return;
    for(int i=1;i<=m;i++) P[x].p[i].mov(x,0);
}
inline void chk(int x){
    P[x].f=1;
    for(int i=1;i<=m;i++) P[x].f&=(P[x].p[i].typ==7);
}
inline void op::mov(int id,bool R){
    // auto &qqq=P[43].p[7];
    // cout<<id<<'\n';
    // if(qqq.w!=NULL)cout<<qqq.w->typ<<' '<<qqq.w->h<<' '<<qqq.w->x<<' '<<qqq.w->y<<' '<<P[43].hd[0]<<' '<<P[43].hd[1]<<'\n';
    if(typ==7) return;
    op tmp=*this;
    // cout<<tmp.h<<'\n';
    int to=P[id].hd[tmp.h];
    if(tmp.typ==1);
    else if(tmp.typ==2) P[id].hd[tmp.h]=(to+tmp.x)%n;
    else if(tmp.typ==3){swap(P[id].p[tmp.y],P[to].p[tmp.x]);chk(id);chk(to);}
    else if(tmp.typ==4){
        // if(qqq.w!=NULL)cout<<qqq.w->typ<<' '<<qqq.w->h<<' '<<qqq.w->x<<' '<<qqq.w->y<<' '<<P[43].hd[0]<<' '<<P[43].hd[1]<<'\n';
        // cout<<to<<' '<<x<<' '<<P[to].p[x].typ<<'\n';
        if(P[to].p[tmp.x].typ==7){
            pl[++tot]=*P[to].p[tmp.x].w;
            pl[tot].h^=1;
            P[to].p[tmp.x].w=&pl[tot];
        }
        else P[to].p[tmp.x].h^=1;
        // if(qqq.w!=NULL)cout<<qqq.w->typ<<' '<<qqq.w->h<<' '<<qqq.w->x<<' '<<qqq.w->y<<' '<<P[43].hd[0]<<' '<<P[43].hd[1]<<'\n';
    }
    else if(tmp.typ==5){
        P[to].p[tmp.x].typ=tmp.w->typ;
        P[to].p[tmp.x].h=tmp.w->h;
        P[to].p[tmp.x].x=tmp.w->x;
        P[to].p[tmp.x].y=tmp.w->y;
        if(tmp.w->w!=NULL){
            pl[++tot]=*tmp.w->w;
            P[to].p[tmp.x].w=&pl[tot];
        }
        else P[to].p[tmp.x].w=NULL;
        chk(to);
    }
    tmp.outp(id);
    if(tmp.typ==6) acti(to);
    to=P[id].hd[1];
    if(to==id) return; 
    for(int i=1;i<=m;i++){
        // if(i==8) cout<<P[to].p[i].typ<<" "<<P[to].p[i].x<<" "<<P[to].p[i].y<<'\n';
        if(P[to].p[i].typ==7){
            if(P[to].p[i].x==7){ 
                if(R){P[to].p[i].w->mov(to,1);break;}                
            }
            else if(tmp.typ==P[to].p[i].x){P[to].p[i].w->mov(to,1);break;}
        }
    }
}
inline void op::outp(int id){
    switch(typ){
        case 1:printf("Robot %d slacks off.\n",id);break;
        case 2:printf("Robot %d moves its %s hand towards Robot %d.\n",id,h?"right":"left",P[id].hd[h]);break;
        case 3:printf("Robot %d swaps a line of command with Robot %d.\n",id,P[id].hd[h]);break;
        case 4:printf("Robot %d modifies a line of command of Robot %d.\n",id,P[id].hd[h]);break;
        case 5:printf("Robot %d replaces a line of command of Robot %d.\n",id,P[id].hd[h]);break;
        case 6:printf("Robot %d activates Robot %d.\n",id,P[id].hd[h]);break;
    }
    Cnt++;
    if(Cnt>=k) exit(0);
}
int main(){
    // string name="A";freopen((name+".in").c_str(),"r",stdin);freopen((name+".out").c_str(),"w",stdout);
    std::ios::sync_with_stdio(0);cin.tie(0);
    cin>>n>>m>>k;
    for(int i=0;i<n;i++) P[i].inp();
    while(1){
        for(int i=0;i<n;i++) acti(i);
    }
    return 0;
}
```

---

## 作者：Cute__yhb (赞：2)

看大家都是用指针写的，来篇非指针链表的题解。

对于每一个指令，可以看成是一条链，对于不是 ```REPLACE``` 或者 ```TRIGGER``` 的指令，这条链上只有一个元素，而对于这两个指令，就可以把后续读入的指令接到前一个指令的后面，形成一个链表。

存指令时，只需要记录该指令的链表的头结点即可。

## 读入

不是 ```REPLACE``` 或者 ```TRIGGER``` 的指令，直接读入即可。

这两个指令可以递归读入。

## 基础指令

### SLACKOFF 指令

最简单的一个，直接输出即可。

### MOVE 指令

判断一下左右手，把当前手指向的人的编号加上 $z$，然后取模一下 $n$。

### SWAP 指令

把两条指令对应的链表的头结点交换一下。

### MIRROR 指令

把操作中的 $h$ 异或一下 $1$ 即可。

### REPLACE 指令

基础指令中最难的一个。

一个很基础的想法是，直接把后面的指令的起始结点作为需要替换指令的头节点。

但这样会有一个问题，这两个指令同时指向链表中的同一个结点，对于 ```MIRROR``` 指令，会一次修改到两个结点。

正确的方法是把后面的指令复制到一个空的结点里，把需要替换的指令改成新复制的指令。

## 高级指令

### ACTIVATE 指令

非常简单，把目标的所有不是 ```TRIGGER``` 的指令都跑一遍就行。

### TRIGGER 指令

首先，对于每一条执行完的指令，都要检查一下有没有触发改指令。

第一种触发方式，很简单，直接判断一下就行。

对于第二种，可以设置一个变量，看看是不是由 ```TRIGGER``` 指令触发的。

需要注意 ```ACTIVATE``` 指令中所执行的指令并不能触发 ```TRIGGER``` 指令。

## 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned long long
#define INF 0x3f3f3f3f
#define endl '\n'
#define fi first
#define se second
#define pii pair<int,int>
#define p_q priority_queue
#define iter iterator
#define pb push_back
#define eps 1e-8
#define oper operator
#define mk make_pair
#define ls x<<1
#define rs x<<1|1
int n,m,k,tot=0;
struct node{
	int s,s1;
	int h,x,y,nxt,z;
}a[1000005];
struct robot{
	int l,r;
	int head[15];
}r[105];
map<string,int>mp;
int readin(){
	tot++;
	int x=tot;
	string s;
	cin>>s;
	a[tot].s=mp[s];
	if(s=="MOVE"){
		cin>>a[tot].h>>a[tot].z;
	}
	else if(s=="SWAP"){
		cin>>a[tot].h>>a[tot].x>>a[tot].y;
	}
	else if(s=="MIRROR"){
		cin>>a[tot].h>>a[tot].x;
	}
	else if(s=="REPLACE"){
		cin>>a[tot].h>>a[tot].x;
		a[tot].nxt=readin();
	}
	else if(s=="ACTIVATE"){
		cin>>a[tot].h;
	}
	else if(s=="TRIGGER"){
		string ss,t="";
		cin>>ss;
		for(int i=0;i<ss.size()-1;i++){
			t+=ss[i];
		}
		a[tot].s1=mp[t];
		a[tot].nxt=readin();
	}
	return x;
}
void Do(int x,int y,bool is_trigger);
void checktrigger(int x,int y,bool is_trigger){
	int X=r[x].r;
	if(x==X) return ;
	for(int i=1;i<=m;i++){
		int Y=r[X].head[i];
		if(a[Y].s==7){
			bool F=0;
			if(a[Y].s1==7){
				if(is_trigger) F=1;
			}else{
				if(a[Y].s1==a[y].s) F=1;
			}
			if(F){
				Do(X,a[Y].nxt,1);
				return ;
			}
		}
	}
}
void Do(int x,int y,bool is_trigger){
	if(k==0) exit(0);
	k--;
	if(a[y].s==1){
		printf("Robot %d slacks off.\n",x);
	}else if(a[y].s==2){
		printf("Robot %d moves its ",x);
		if(a[y].h==0) cout<<"left hand towards Robot ";
		else cout<<"right hand towards Robot ";
		if(a[y].h==0){
			r[x].l=(r[x].l+a[y].z)%n;
			cout<<r[x].l;
		}
		else{
			r[x].r=(r[x].r+a[y].z)%n;
			cout<<r[x].r;
		}
		cout<<".\n";
	}
	else if(a[y].s==3){
		int X=r[x].l;
		if(a[y].h==1) X=r[x].r;
		printf("Robot %d swaps a line of command with Robot %d.\n",x,X);
		swap(r[x].head[a[y].y],r[X].head[a[y].x]);
	}else if(a[y].s==4){
		int X=r[x].l;
		if(a[y].h==1) X=r[x].r;
		printf("Robot %d modifies a line of command of Robot %d.\n",x,X);
		int Y=r[X].head[a[y].x];
		if(a[Y].s!=1&&a[Y].s!=7){
			a[Y].h^=1;
		}else if(a[Y].s==7){
			Y=a[Y].nxt;
			if(a[Y].s!=1){
				a[Y].h^=1;
			}
		}
	}else if(a[y].s==5){
		int X=r[x].l;
		if(a[y].h==1) X=r[x].r;
		printf("Robot %d replaces a line of command of Robot %d.\n",x,X);
		tot++;
		r[X].head[a[y].x]=tot;
		a[tot]=a[a[y].nxt];
		int Y=a[y].nxt;
		if(a[Y].s==7){
			tot++;
			a[tot-1].nxt=tot;
			a[tot]=a[a[Y].nxt];
		}
	}else if(a[y].s==6){
		int X=r[x].l;
		if(a[y].h==1) X=r[x].r;
		printf("Robot %d activates Robot %d.\n",x,X);
		for(int i=1;i<=m;i++){
			if(a[r[X].head[i]].s!=7) Do(X,r[X].head[i],0);
		}
	}
	if(!k) exit(0);
	checktrigger(x,y,is_trigger);
}
int main(){
//	freopen("5.in","r",stdin);
//	freopen("5.out","w",stdout);
	mp["SLACKOFF"]=1;
	mp["MOVE"]=2;
	mp["SWAP"]=3;
	mp["MIRROR"]=4;
	mp["REPLACE"]=5;
	mp["ACTIVATE"]=6;
	mp["TRIGGER"]=7;
	cin>>n>>m>>k;
	for(int i=1;i<=500000;i++){
		a[i].h=0;
		a[i].nxt=0;
		a[i].s=0;
		a[i].s1=0;
		a[i].x=0;
		a[i].y=0;
		a[i].z=0;
	}
	for(int i=0;i<n;i++){
		cin>>r[i].l>>r[i].r;
		for(int j=1;j<=m;j++){
			r[i].head[j]=readin();
		}
	}
	while(1){
		for(int i=0;i<n;i++){
			for(int j=1;j<=m;j++){
				if(a[r[i].head[j]].s!=7) Do(i,r[i].head[j],0);
			}
		}
	}
    return 0;
}
```

---

## 作者：vorDeal (赞：1)

人生第一道紫的大模拟，134 行写了 5h。

题目一定要多读几遍。

题目里提到了机器人、指令这两个主体。于是考虑对它们分别建立结构体来增强代码可读性。

```cpp
struct command
{
    string type;
    int h, x, y, z;
    string con;
    int sub;
} cmd[1000005];

struct robot
{
    int hd[2], act[15];
} rbt[105];
```

command 结构体储存了指令的类型、参数，以及 TRIGGER 命令的条件，与指令的子指令的下标。

robot 结构体储存了机器人的左右手指向以及指令下标。

为什么不能直接存储指令呢？

因为 REPLACE 和 TRIGGER 指令包含子指令，若直接存储，它们的大量反复操作会导致不断展开，造成 MLE 和 TLE。

我们写一个 read 函数来进行读入，以方便子指令的递归读入。

```cpp
int read()
{
    int id = cnt++;
    cin >> cmd[id].type;
    if (cmd[id].type == "MOVE")
        cin >> cmd[id].h >> cmd[id].z;
    else if (cmd[id].type == "SWAP")
        cin >> cmd[id].h >> cmd[id].x >> cmd[id].y;
    else if (cmd[id].type == "MIRROR")
        cin >> cmd[id].h >> cmd[id].x;
    else if (cmd[id].type == "REPLACE")
        cin >> cmd[id].h >> cmd[id].x, cmd[id].sub = read();
    else if (cmd[id].type == "ACTIVATE")
        cin >> cmd[id].h;
    else if (cmd[id].type == "TRIGGER")
        cin >> cmd[id].con, cmd[id].con.pop_back(), cmd[id].sub = read();
    return id;
}
```

读入好了，对指令进行运行，再写一个 run 函数。

```cpp
void run(int id, int ord, bool f)
{
    if (k <= 0)
        exit(0);
    if (cmd[ord].type == "SLACKOFF")
    {
        printf("Robot %d slacks off.\n", id);
        k--;
    }
    else if (cmd[ord].type == "MOVE")
    {
        rbt[id].hd[cmd[ord].h] += cmd[ord].z;
        rbt[id].hd[cmd[ord].h] %= n;
        printf("Robot %d moves its %s hand towards Robot %d.\n", id,
               (cmd[ord].h == 0 ? "left" : "right"), rbt[id].hd[cmd[ord].h]);
        k--;
    }
    else if (cmd[ord].type == "SWAP")
    {
        swap(rbt[id].act[cmd[ord].y], rbt[rbt[id].hd[cmd[ord].h]].act[cmd[ord].x]);
        printf("Robot %d swaps a line of command with Robot %d.\n", id, rbt[id].hd[cmd[ord].h]);
        k--;
    }
    else if (cmd[ord].type == "MIRROR")
    {
        rbt[rbt[id].hd[cmd[ord].h]].act[cmd[ord].x] = mirror(rbt[rbt[id].hd[cmd[ord].h]].act[cmd[ord].x]);
        printf("Robot %d modifies a line of command of Robot %d.\n", id, rbt[id].hd[cmd[ord].h]);
        k--;
    }
    else if (cmd[ord].type == "REPLACE")
    {
        cmd[cnt] = cmd[cmd[ord].sub];
        rbt[rbt[id].hd[cmd[ord].h]].act[cmd[ord].x] = cnt++;
        printf("Robot %d replaces a line of command of Robot %d.\n", id, rbt[id].hd[cmd[ord].h]);
        k--;
    }
    else if (cmd[ord].type == "ACTIVATE")
    {
        printf("Robot %d activates Robot %d.\n", id, rbt[id].hd[cmd[ord].h]);
        k--;
        activate(rbt[id].hd[cmd[ord].h]);
    }
    if (rbt[id].hd[1] != id)
        for (int i = 1; i <= m; i++)
            if (cmd[rbt[rbt[id].hd[1]].act[i]].type == "TRIGGER")
                if (cmd[rbt[rbt[id].hd[1]].act[i]].con == cmd[ord].type ||
                    (cmd[rbt[rbt[id].hd[1]].act[i]].con == "TRIGGER" && f))
                {
                    run(rbt[id].hd[1], cmd[rbt[rbt[id].hd[1]].act[i]].sub, true);
                    break;
                }
    return;
}
```

每次非 TRIGGER 的操作，都把全局计数器 k 减一。

id 表示机器人编号，ord 表示指令编号，f 表示是否在 TRIGGER 指令的内部。

注意 REPLACE 指令，要将子指令复制一份，以避免后续 REPLACE 指令的影响。

MIRROR 指令代码较长，专门建立一个函数。

```cpp
int mirror(int ord)
{
    if (cmd[ord].type == "SLACKOFF")
        return ord;
    if (cmd[ord].type == "TRIGGER")
    {
        cmd[cnt] = cmd[ord];
        cmd[cnt + 1] = cmd[cmd[ord].sub];
        cmd[cnt].sub = cnt + 1;
        cmd[cnt + 1].h = (cmd[cnt + 1].h == 0 ? 1 : 0);
        cnt += 2;
        return cnt - 2;
    }
    cmd[cnt] = cmd[ord];
    cmd[cnt].h = (cmd[cnt].h == 0 ? 1 : 0);
    return cnt++;
}
```

仿照 REPLACE 指令，我们修改时也把指令复制一份，以避免后续 REPLACE 指令的影响。特殊地，对于 TRIGGER，子指令也要复制。

ACTIVATE 指令可在主函数中复用，也写一个函数。

```cpp
void activate(int id)
{
    for (int i = 1; i <= m; i++)
        if (cmd[rbt[id].act[i]].type != "TRIGGER")
            run(id, rbt[id].act[i], false);
    return;
}
```

注意判断 TRIGGER 指令。

主程序很简短。

```cpp
int main()
{
    cin >> n >> m >> k;
    for (int i = 0; i < n; i++)
    {
        cin >> rbt[i].hd[0] >> rbt[i].hd[1];
        for (int j = 1; j <= m; j++)
            rbt[i].act[j] = read();
    }
    for (int i = 0; k; i++)
        activate(i % n);
    return 0;
}
```

坑点：
- 不能触发自己的 TRIGGER 指令。
- 在执行前面的指令时后面的指令可能会发生更改，这时需要执行更改后的指令。
- 只有自己最靠前的满足条件的 TRIGGER 指令才会被触发。
- 数组一定要开到足够大。
- 函数间出现了交叉调用，一定要先声明、后实现。
- REPLACE、MIRROR 指令，必须要将指令复制一份。

完整的 AC Code 见 [Submission #508389 - QOJ.ac](https://qoj.ac/submission/508389)。

致敬某位在 2023 年暑假 9.5h 切掉 P8422 的前辈，他的精神必将永垂不朽。

祭奠在某素养营写人机作文写得像人机写的，从而亲手把自己送回初中复读半年的本人。

---

## 作者：wosile (赞：0)

THUPC 2024 初赛 F 题。

我赛场上写完 C 就来写这题写了三个小时才过，讲一下大致的思路：

首先如果没有 `REPLACE`，那么所有的操作都可以暴力进行，输入也很简单。`TRIGGER` 看似是这题核心的复杂操作，其实只是徒增代码的简单玩意罢了，因为注意到 $m \le 10$ 而且 `TRIGGER` 只会套基础指令，所以 `TRIGGER` 是可以暴力的。

有 `REPLACE` 的话，问题就变得复杂了起来。`REPLACE` 里面还可以套 `REPLACE`。题目没有限制一条 `REPLACE` 指令的长度，只限制了总长度。如果我们每次都把一条超长的指令 `REPLACE` 来 `REPLACE` 去肯定就炸了。

聪明的你或许已经想到了，我们可以给指令编号，然后只记录被 `REPLACE` 的指令的编号。`REPLACE` 的时候只改变机器人指令列表里的指令编号就可以了。实现上讲，对于每个指令，我们可以记录它的 `COMMAND` 参数（如果有的话）指向的指令编号，存下其他参数。递归读入即可。

```cpp
struct command{
    int t,h,x,y,to;
}f[2000005];
int tot=0;
// t 表示指令类型，h,x,y 与题意相同（z 是 x），to 表示 REPLACE 和 TRIGGER 指令的子指令。
void readCommand(command &c){
    scanf("%s",tmp);
    c.t=tmp[1];
    if(tmp[1]=='O'){
        c.h=read();
        c.x=read();
    }
    else if(tmp[1]=='W'){
        c.h=read();
        c.x=read();
        c.y=read();
    }
    else if(tmp[1]=='I'){
        c.h=read();
        c.x=read();
    }
    else if(tmp[1]=='E'){
        c.h=read();
        c.x=read();
        c.to=++tot;
        readCommand(f[tot]);//读入 COMMAND 参数
    }
    else if(tmp[1]=='C'){
        c.h=read();
    }
    else if(tmp[1]=='R'){
        scanf("%s",tmp);
        c.x=tmp[1];
        c.to=++tot;
        readCommand(f[tot]);
    }
}
//一种读入指令的方式
```

```cpp
// SWAP 和 REPLACE 都只需要对编号进行操作，这里以 REPLACE 为例，cd 指的就是覆盖的操作编号，a[id].cid[] 是 id 号机器人的指令编号列表。
void rEplace(int id,int x,int cd,int from,int g){
    if(k<=0)return;
    --k;
    a[id].cid[x]=cd;
    printf("Robot %d replaces a line of command of Robot %d.\n",from,id);
    if(from!=a[from].r)trytrigger(a[from].r,'E',g);
}
```

写到这里问题就来了，这题的其他所有操作都不会改变指令本身（包括 `REPLACE` 本质上也只是动一动编号而已），但是 `MIRROR` 不是这样。`MIRROR` 操作之后得到的指令是原来不存在的，因此我们需要对指令本身进行修改。

注意到 `MIRROR` 机器人 $id$ 的第 $x$ 条指令（编号 $cd$）的时候，我们不能直接 `f[cd].h^=1;`，因为这条指令可能同时在被多个机器人使用（比如被 `REPLACE` 到了很多地方），而你只能改其中的一个。

这时候，我们利用类似可持久化的思路，新建一个和 $cd$ 一样的指令，`MIRROR` 这个新的指令，并把机器人 $id$ 的第 $x$ 条指令指向这个新的指令就可以了。

注意在 `MIRROR` 一个 `TRIGGER` 的时候，由于更改的是基础指令，基础指令和 `TRIGGER` 我们都需要复制。

```cpp
void mIrror(int id,int x,int from,int g){
    if(k<=0)return;
    --k;
    int &i=a[id].cid[x];
    if(f[i].t!='R'){
        f[++tot]=f[i];
        f[tot].h^=1;
        i=tot;
    }
    else{
        f[++tot]=f[i];
        f[++tot]=f[f[i].to];
        //新建两个指令
        f[tot].h^=1;
        f[tot-1].to=tot;
        i=tot-1;
    }
    printf("Robot %d modifies a line of command of Robot %d.\n",from,id);
    if(from!=a[from].r)trytrigger(a[from].r,'I',g);
}
```

然后就是注意一些细节，比如 `TRIGGER` 不会被自己触发（很奇怪的设计）。以及如果 `TRIGGER` 触发导致某个基础指令（以 `SLACKOFF` 为例）运行，那么 `TRIGGER TRIGGER:` 和 `TRIGGER SLACKOFF:` 都可以被这个 `SLACKOFF` 触发。

这题可能会用到声明与定义分离的写法。

我的实现比较丑陋，优雅的实现可能应该有一个 `void runCommand(int robotid,command c)` 表示运行一条指令。

由于每运行一条指令都只会调用一次 `trytrigger`，所以时间复杂度是 $O(km+|I|)$，其中 $|I|$ 是输入大小，$|I| \le 5 \times 10^6$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){
    int x=0,c=getchar(),f=1;
    while(c<'0' || c>'9'){
        if(c=='-')f=-1;
        c=getchar();
    }
    while(c>='0' && c<='9'){
        x=(x<<3)+(x<<1)+c-'0';
        c=getchar();
    }
    return f==1?x:-x;
}
struct command{
    int t,h,x,y,to;
}f[2000005];
struct robot{
    int cid[15];
    int l,r;
    int hand(int v){
        return v==0?l:r;
    }
}a[105];
int tot=0;
char tmp[15];
int n,m,k;
void readCommand(command &c){
    scanf("%s",tmp);
    c.t=tmp[1];
    if(tmp[1]=='O'){
        c.h=read();
        c.x=read();
    }
    else if(tmp[1]=='W'){
        c.h=read();
        c.x=read();
        c.y=read();
    }
    else if(tmp[1]=='I'){
        c.h=read();
        c.x=read();
    }
    else if(tmp[1]=='E'){
        c.h=read();
        c.x=read();
        c.to=++tot;
        readCommand(f[tot]);
    }
    else if(tmp[1]=='C'){
        c.h=read();
    }
    else if(tmp[1]=='R'){
        scanf("%s",tmp);
        c.x=tmp[1];
        c.to=++tot;
        readCommand(f[tot]);
    }
}
void trytrigger(int,int,int);
void sLackoff(int id,int g){
    if(k<=0)return;
    --k;
    printf("Robot %d slacks off.\n",id);
    if(id!=a[id].r)trytrigger(a[id].r,'L',g);
}
void mOve(int id,int h,int x,int g){
    if(k<=0)return;
    --k;
    if(h==0){
        a[id].l=(a[id].l+x)%n;
        printf("Robot %d moves its left hand towards Robot %d.\n",id,a[id].l);
    }
    else{
        a[id].r=(a[id].r+x)%n;
        printf("Robot %d moves its right hand towards Robot %d.\n",id,a[id].r);
    }
    if(id!=a[id].r)trytrigger(a[id].r,'O',g);
}
void sWap(int id,int id2,int x,int x2,int g){
    if(k<=0)return;
    --k;
    swap(a[id].cid[x],a[id2].cid[x2]);
    printf("Robot %d swaps a line of command with Robot %d.\n",id,id2);
    if(id!=a[id].r)trytrigger(a[id].r,'W',g);
}
void mIrror(int id,int x,int from,int g){
    if(k<=0)return;
    --k;
    int &i=a[id].cid[x];
    if(f[i].t!='R'){
        f[++tot]=f[i];
        f[tot].h^=1;
        i=tot;
    }
    else{
        f[++tot]=f[i];
        f[++tot]=f[f[i].to];
        f[tot].h^=1;
        f[tot-1].to=tot;
        i=tot-1;
    }
    printf("Robot %d modifies a line of command of Robot %d.\n",from,id);
    if(from!=a[from].r)trytrigger(a[from].r,'I',g);
}
void rEplace(int id,int x,int cd,int from,int g){
    if(k<=0)return;
    --k;
    a[id].cid[x]=cd;
    printf("Robot %d replaces a line of command of Robot %d.\n",from,id);
    if(from!=a[from].r)trytrigger(a[from].r,'E',g);
}
void aCtivate(int id,int from,int g){
    if(k<=0)return;
    if(from!=-1){
        printf("Robot %d activates Robot %d.\n",from,id);
        --k;
    }
    for(int i=1;i<=m;i++){
        command c=f[a[id].cid[i]];
        if(c.t=='L')sLackoff(id,0);
        else if(c.t=='O')mOve(id,c.h,c.x,0);
        else if(c.t=='W')sWap(id,a[id].hand(c.h),c.y,c.x,0);
        else if(c.t=='I')mIrror(a[id].hand(c.h),c.x,id,0);
        else if(c.t=='E')rEplace(a[id].hand(c.h),c.x,c.to,id,0);
        else if(c.t=='C')aCtivate(a[id].hand(c.h),id,0);
    }
    if(from!=-1 && from!=a[from].r)trytrigger(a[from].r,'C',g);
}
void trytrigger(int id,int ft,int g){
    if(k<=0)return;
    for(int i=1;i<=m;i++){
        command c=f[a[id].cid[i]];
        if(c.t=='R' && (c.x==ft || (c.x=='R' && g==1))){
            c=f[c.to];
            if(c.t=='L')sLackoff(id,1);
            else if(c.t=='O')mOve(id,c.h,c.x,1);
            else if(c.t=='W')sWap(id,a[id].hand(c.h),c.y,c.x,1);
            else if(c.t=='I')mIrror(a[id].hand(c.h),c.x,id,1);
            else if(c.t=='E')rEplace(a[id].hand(c.h),c.x,c.to,id,1);
            else if(c.t=='C')aCtivate(a[id].hand(c.h),id,1);
            break;
        }
    }

}
int main(){
    n=read();
    m=read();
    k=read();
    for(int i=0;i<n;i++){
        a[i].l=read();
        a[i].r=read();
        for(int j=1;j<=m;j++){
            a[i].cid[j]=++tot;
            readCommand(f[tot]);
        }
    }
    int it=0;
    while(k>0){
        aCtivate(it,-1,0);
        it=(it+1==n?0:it+1);
    }
    return 0;
}
```

---

## 作者：AK_400 (赞：0)

个人认为这题卡常难度远大于代码难度。

# 1.指令

首先写的时候会遇到第一个问题：

这个 `REPLACE` 里面怎么还能套 `REPLACE` 啊，这怎么输入？？？

聪明的你一定想到了，将指令的读入写成一个函数，然后需要的时候递归即可。

为了方便，我们开个结构体来存指令：

```cpp
struct command{
    char cmd,cmdname;
    int h,x,y,z;
    command *c;
    void input();
    void operate(int id,bool tri);//作用后面说
}com[1000000];
int tot=0;
void command::input(){
    read(cmd);
    switch(cmd){
    case 'L':return;
    case 'O':read(h),read(z);return;
    case 'W':read(h),read(x),read(y);return;
    case 'I':read(h),read(x);return;
    case 'E':read(h),read(x);c=&com[++tot];com[tot].input();return;
    case 'C':read(h);return;
    case 'R':read(cmdname);c=&com[++tot];com[tot].input();return;
    }
}
```
解释个事情：

结构体里面不能定义类型是自身的变量，所以不得不定义成指针，`com` 是用来存这个指针指向的指令的。

`cmd` 和 `cmdname` 是 `char` 类型的原因在卡常的部分会说。

# 2.机器人

需要存储一个机器人的状态，即指令和左右手朝向，为方便操作可以记录这个机器人的编号。


```cpp
struct robot{
    int h[2],id;//左右的编号和题目一样，即左为0，右为1。
    command c[20];
    void input(){
        read(h[0]),read(h[1]);
        for(int i=1;i<=m;++i)
        c[i].input();
    }
    void ACTIVATE();
    void TRIGGER(char &cmd1);
    void TRIGGER1(char &cmd1);//作用后面说
}r[101];
```
# 3.基础指令

## 3.1 `SLACKOFF`

按题意输出即可。

## 3.2 `MOVE`

给对应的手加 `z`，再对 `n` 取模即可。

## 3.3 `SWAP`

反正我们 `command` 结构体里面存的东西不多，直接暴力交换即可。

注意这里不要把 `x`，`y` 的含义看反。

## 3.4 `MIRROR`

有个小坑，如果你直接改 `TRIGGER` 的话会出事，因为你改了之后，所有指向它的指令也会被改，所以要先复制再改。

其他的没什么好说的，硬改就好了。

## 3.5 `REPLACE`

把对应指令赋值为它指向的指令即可。

这里有个问题，就是他没有限制 `REPLACE` 中指令的长度，也就是说他可以直接给你五兆的  `REPLACE` 套 `REPLACE`，如果要将一个指令和它指向的指令都进行修改，那么肯定会 TLE，这就是我指令中不存编号的原因。

# 4.高级指令

## 4.1 `ACTIVATE`

依次执行指令即可。

不建议把这个操作直接写到执行指令里面，因为最外面还要对每个机器人依次激活，所以我更建议在机器人的结构体里面写，即之前在「机器人」章中未解释的 `void ACTIVATE();` 函数。

## 4.2 `TRIGGER`

每条指令执行完之后判一下右手指向的机器人能否被这条指令触发 `TRIGGER` 即可。

首先要注意这个指令不能被直接执行，也不能触发其他机器人的 `TRIGGER`。

然后注意题面说了这样一句话：

> 但是，当一个 其他 机器人「执行」完一条「指令」之后

也就是说判断有没有 `TRIGGER` 之前要先判断右手不能指向自己。

还有一个要注意的，`TRIGGER` 触发的指令既能触发 `<COMMANDNAME>` 为 `TRIGGER` 的 `TRIGGER`，又能触发其本身能触发的 `TRIGGER`。

```cpp
inline void robot::TRIGGER(char &cmd){//不由TRIGGER触发的指令触发TRIGGER
    for(int i=1;i<=m;++i){
        if(c[i].cmd=='R'&&c[i].cmdname==cmd){
            c[i].c->operate(id,1);
            return;
        }
    }
}
inline void robot::TRIGGER1(char &cmd1){//由TRIGGER触发的指令触发TRIGGER
    //string cmd2="TRIGGER";
    char cmd2='R';
    for(int i=1;i<=m;++i){
        if(c[i].cmd=='R'&&(c[i].cmdname==cmd1||c[i].cmdname==cmd2)){
            c[i].c->operate(id,1);
            return;
        }
    }
}
inline void robot::ACTIVATE(){//激活
    for(int i=1;i<=m;++i){
        if(k<=0)return;
        c[i].operate(id,0);
    }
}
inline void command::operate(int id,bool tri){//执行指令，参数表示机器人编号和是否由TRIGGER触发
    if(k<=0)return;
    int nid=id;
    auto ncmd=cmd;
    auto nh=h,nx=x,ny=y;//操作完可能会变，所以存下来。
    switch(cmd){
    case 'L':
        k--;
        printf("Robot %d slacks off.\n",id);
        break;
    case 'O':
        k--;
        r[id].h[h]=(r[id].h[h]+z)%n;
        if(h)printf("Robot %d moves its right hand towards Robot %d.\n",id,r[id].h[h]);
        else printf("Robot %d moves its left hand towards Robot %d.\n",id,r[id].h[h]);
        break;
    case 'W':
        k--;
        swap(r[nid].c[ny],r[r[nid].h[nh]].c[nx]);
        printf("Robot %d swaps a line of command with Robot %d.\n",nid,r[nid].h[nh]);
        break;
    case 'I':
        k--;
        if(r[r[id].h[h]].c[x].cmd=='L');
        else if(r[r[id].h[h]].c[x].cmd=='R'){
            if(r[r[id].h[h]].c[x].c->cmd!='L'){
                com[++tot]=*r[r[id].h[h]].c[x].c;
                r[r[id].h[h]].c[x].c=&com[tot];
                r[r[id].h[h]].c[x].c->h^=1;
            }
        }
        else r[r[id].h[h]].c[x].h^=1;
        printf("Robot %d modifies a line of command of Robot %d.\n",id,r[id].h[nh]);
        break;
    case 'E':
        k--;
        r[r[id].h[h]].c[x]=*c;
        // assign_id(r[r[id].h[h]].c[x],r[id].h[h]);
        printf("Robot %d replaces a line of command of Robot %d.\n",id,r[id].h[nh]);
        break;
    case 'C':
        k--;
        printf("Robot %d activates Robot %d.\n",id,r[id].h[nh]);
        r[r[id].h[h]].ACTIVATE();
        break;
    case 'R':return;
    }
    if(r[nid].h[1]!=nid)
    if(!tri)
    r[r[nid].h[1]].TRIGGER(ncmd);
    else 
    r[r[nid].h[1]].TRIGGER1(ncmd);
    return;
}
```


# 5.卡常

## 5.1 比较

字符串比较是很慢的，只比较第二个字符可以减小非常多的时间。

## 5.2 快读

注意我们只需要第二个字符，所以可以把字符串读进来，返回第二个字符。


```cpp
char v[20];int tp;
void read(char &x){
    char c=getchar();
    while(c<'A'||c>'Z')c=getchar();tp=0;
    while(c>='A'&&c<='Z')v[tp++]=c,c=getchar();
    x=v[1];
}
```
## 5.3 `inline`

虽然本地可能看上去没有优化，但是如果就差几毫秒加上是有可能直接卡过的。

# 6.code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k;
void read(int &x){
    x=0;
    char c=getchar();
    while(!isdigit(c))c=getchar();
    while(isdigit(c))x=(x<<3)+(x<<1)+(c^48),c=getchar();
}
char v[20];int tp;
void read(char &x){
    char c=getchar();
    while(c<'A'||c>'Z')c=getchar();tp=0;
    while(c>='A'&&c<='Z')v[tp++]=c,c=getchar();
    x=v[1];
}
struct command{
    char cmd,cmdname;
    int h,x,y,z;
    command *c;
    void input();
    void operate(int id,bool tri);
}com[1000000];
int tot=0;
void command::input(){
    read(cmd);
    switch(cmd){
    case 'L':return;
    case 'O':read(h),read(z);return;
    case 'W':read(h),read(x),read(y);return;
    case 'I':read(h),read(x);return;
    case 'E':read(h),read(x);c=&com[++tot];com[tot].input();return;
    case 'C':read(h);return;
    case 'R':read(cmdname);c=&com[++tot];com[tot].input();return;
    }
}
struct robot{
    int h[2],id;
    command c[20];
    void input(){
        read(h[0]),read(h[1]);
        for(int i=1;i<=m;++i)
        c[i].input();
    }
    void ACTIVATE();
    void TRIGGER(char &cmd1);
    void TRIGGER1(char &cmd1);
}r[101];
inline void robot::TRIGGER(char &cmd){
    for(int i=1;i<=m;++i){
        if(c[i].cmd=='R'&&c[i].cmdname==cmd){
            c[i].c->operate(id,1);
            return;
        }
    }
}
inline void robot::TRIGGER1(char &cmd1){
    char cmd2='R';
    for(int i=1;i<=m;++i){
        if(c[i].cmd=='R'&&(c[i].cmdname==cmd1||c[i].cmdname==cmd2)){
            c[i].c->operate(id,1);
            return;
        }
    }
}
inline void robot::ACTIVATE(){
    for(int i=1;i<=m;++i){
        if(k<=0)return;
        c[i].operate(id,0);
    }
}
inline void command::operate(int id,bool tri){
    if(k<=0)return;
    int nid=id;
    auto ncmd=cmd;
    auto nh=h,nx=x,ny=y;
    switch(cmd){
    case 'L':
        k--;
        printf("Robot %d slacks off.\n",id);
        break;
    case 'O':
        k--;
        r[id].h[h]=(r[id].h[h]+z)%n;
        if(h)printf("Robot %d moves its right hand towards Robot %d.\n",id,r[id].h[h]);
        else printf("Robot %d moves its left hand towards Robot %d.\n",id,r[id].h[h]);
        break;
    case 'W':
        k--;
        swap(r[nid].c[ny],r[r[nid].h[nh]].c[nx]);
        printf("Robot %d swaps a line of command with Robot %d.\n",nid,r[nid].h[nh]);
        break;
    case 'I':
        k--;
        if(r[r[id].h[h]].c[x].cmd=='L');
        else if(r[r[id].h[h]].c[x].cmd=='R'){
            if(r[r[id].h[h]].c[x].c->cmd!='L'){
                com[++tot]=*r[r[id].h[h]].c[x].c;
                r[r[id].h[h]].c[x].c=&com[tot];
                r[r[id].h[h]].c[x].c->h^=1;
            }
        }
        else r[r[id].h[h]].c[x].h^=1;
        printf("Robot %d modifies a line of command of Robot %d.\n",id,r[id].h[nh]);
        break;
    case 'E':
        k--;
        r[r[id].h[h]].c[x]=*c;
        printf("Robot %d replaces a line of command of Robot %d.\n",id,r[id].h[nh]);
        break;
    case 'C':
        k--;
        printf("Robot %d activates Robot %d.\n",id,r[id].h[nh]);
        r[r[id].h[h]].ACTIVATE();
        break;
    case 'R':return;
    }
    if(r[nid].h[1]!=nid)
    if(!tri)
    r[r[nid].h[1]].TRIGGER(ncmd);
    else 
    r[r[nid].h[1]].TRIGGER1(ncmd);
    return;
}
inline void slv(){
    read(n),read(m),read(k);
    for(int i=0;i<n;++i){
        r[i].id=i;
        r[i].input();
    }
    int now=0;
    for(;k>0;++now){
        if(now==n)now=0;
        r[now].ACTIVATE();
    }
}
signed main(){
    slv();
    return 0;
}
```

---


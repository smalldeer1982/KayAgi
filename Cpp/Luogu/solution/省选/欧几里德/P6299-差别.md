# 差别

## 题目描述

定义整数 $p,q,r,s$ 与给定的整数 $a,b,c,d$ 的差别度

$$M=\Big|\left(a^2+b^2\right)\left(p^2+q^2\right)+\left(c^2+d^2\right)\left(r^2+s^2\right)+2\big(ac+bd\big)\big(pr-qs\big)+2\big(bc-ad\big)\big(ps+qr\big)\Big|$$

你的任务是求出差别度 $M$ 的非零最小值与取到非零最小值时的一组 $p,q,r,s$。保证差别度 $M$ 的非零最小值存在且小于 $2^{63}$，保证存在一组绝对值都小于 $2^{63}$ 的 $p,q,r,s$ 使得 $M$ 取到非零最小值。

## 说明/提示

### 样例解释 #1

显然当 $a=1,b=9,c=2,d=6$ 时，差别度 $M$ 一定为偶数，因此 $M$ 不可能取到小与 $2$ 的非零值。

### 数据范围

| 测试点编号 | 特殊性质 |
|:-:|:-:|
| $1$ | $c=d=0$ |
| $2$ | $a=c=0$ |
| $3$ | $b=d=0$ |
| $4$ | $ad=bc$ |
| $5$ | $\vert a\vert,\vert b\vert,\vert c\vert,\vert d\vert\le10$ |
| $6\sim10$ | 无 |

对于 $100\%$ 的数据，满足 $\vert a\vert,\vert b\vert,\vert c\vert,\vert d\vert\le10^9$。

### 评分方式

**你需要保证每个测试点输出的数的个数为** $5$ **个且** $\vert p\vert,\vert q\vert,\vert r\vert,\vert s\vert,\vert M\vert<2^{63}$**，以避免出现无法预期的错误。**

对于每个测试点，如果你的 $M$ 与标准输出一致，就能得到 $4$ 分；如果你输出的 $p,q,r,s$ 能使计算结果等于 $M$，就能再获得 $6$ 分。

## 样例 #1

### 输入

```
1 9 2 6
```

### 输出

```
2 1 -3 1 2
```

## 样例 #2

### 输入

```
19674937 18722417 163948077 124500851
```

### 输出

```
146134 -61558 -18260 -10209 221162
```

# 题解

## 作者：Daniel13265 (赞：13)

这是「Daniel13265 的公开赛」的官方题解。

---

## 测试点 $1$

$$M=\left(a^2+b^2\right)\left(p^2+q^2\right).$$

令  $p=1,q=r=s=0$ 即可，此时 $M=a^2+b^2$。

## 测试点 $2$

$$\begin{aligned}M&=\Big|b^2\left(p^2+q^2\right)+d^2\left(r^2+s^2\right)+2bd\big(pr-qs\big)\Big|\\&=\Big|\big(b^2p^2+d^2r^2+2bdpr\big)+\big(b^2q^2+d^2s^2-2bdqs\big)\Big|\\&=\Big|(bp+dr)^2+(bq-ds)^2\Big|\\&=(bp+dr)^2+(bq-ds)^2.\end{aligned}$$

故有 $\gcd^2(b,d)|M$ 。

令 $q=s=0$ ，则只要找出两个整数 $p,r$ 使得 $bp+dr=\gcd(b,d)$ ，直接使用扩展欧几里得算法即可。此时 $M=\gcd^2(b,d)$ 。

## 测试点 $3$

$$M=\Big|a^2\left(p^2+q^2\right)+c^2\left(r^2+s^2\right)+2ac\big(pr-qs\big)\Big|.$$

与测试点 $2$ 相同，略。

## 测试点 $4$

设 $b=ka,d=kc$ ，则有

$$\begin{aligned}M&=\big(ap+cr\big)^2+\big(aq-cs\big)^2+\big(bq-ds\big)^2+\big(bp+dr\big)^2\\&=\big(k^2+1\big)\Big[(ap+cr\big)^2+\big(aq-cs\big)^2\Big].\end{aligned}$$

同测试点 $2$ ，略。

## 测试点 $5$

猜测 $|p|,|q|,|r|,|s|\leq10$ ，直接枚举即可。

## 测试点 $6\sim10$ 

$$\begin{aligned}M&=\Big|(bq-ds)^2+(bp+dr)^2+(ap+cr)^2+(-aq+cs)^2+2(bc-ad)(ps+qr)\Big|\\&=\Big|(ap+bq+cr-ds)^2+(-aq+bp+cs+dr)^2\Big|\\&=(ap+bq+cr-ds)^2+(-aq+bp+cs+dr)^2.\end{aligned}$$

构造复数 $A=a+bi,x=p-qi,B=c+di,y=r+si$ ，则 $M=\big|Ax+By\big|^2$，使用扩展欧几里得算法求解即可。如果认为 $|a|,|b|,|c|,|d|$ 同阶，时间复杂度为 $\mathcal O\left(\log|a|\right)$。

另外，观察大样例猜测到 $M=\gcd\left(a^2+b^2,c^2+d^2,2|ac+bd|,2|bc-ad|\right)$ 可以得到每个测试点 $40\%$ 的分数。

## 补充：高斯整数的扩展欧几里得算法

由于题解界面中希腊字母的渲染实在称不上好看，因此建议此部分到[博客](/blog/daniel13265/solution-difference)中查看。

---

#### 定义（范数）

$\alpha=a+bi\in\mathbb Q[i]$ 的范数 $N(\alpha)=a^2+b^2=|\alpha|^2$。

#### 一个引理

对于 $\alpha,\beta\in\mathbb Q[i]$，有 $N(\alpha\beta)=N(\alpha)N(\beta)$。

**证明：** 设 $\alpha=p+qi,\beta=r+si$，则

$$\begin{aligned}N(\alpha\beta)&=(pr-qs)^2+(ps+qr)^2\\&=p^2r^2+p^2s^2+q^2r^2+q^2s^2\\&=\left(p^2+q^2\right)\left(r^2+s^2\right)\\&=N(\alpha)N(\beta)\end{aligned}$$

#### 定理（带余除法）

对于 $\alpha,\beta\in\mathbb Z[i],\alpha\neq0$，一定存在 $\eta,\gamma\in\mathbb Z[i]$ 使得

$$\beta=\eta\alpha+\gamma,\qquad0\le N(\gamma)\leq\frac12N(\alpha)$$

**证明：** 设 $\tau=p+qi=\dfrac\beta\alpha\in\mathbb Q[i]$，取 $r,s\in\mathbb Z$ 且 $|p-r|\le\dfrac12,|q-s|\le\dfrac12$，取 $\eta=r+si$，则有

$$N(\tau-\eta)=(p-r)^2+(q-s)^2\le\dfrac12$$

因为 $\gamma=\beta-\eta\alpha=(\tau-\eta)\alpha$，所以由上面的引理有

$$N(\gamma)=N(\tau-\eta)N(\alpha)\le\frac12N(\alpha)$$

因此，仿照整数记 $\eta=\left\lfloor\dfrac\beta\alpha\right\rfloor,\gamma=\beta\mod\alpha$，于是就可以使用扩展欧几里得算法了。

由于作一次除法时范数将减小至少一半，因此复数域的扩展欧几里得算法的时间复杂度为 $\mathcal O\left(\log N(\alpha)\right)$。

---

## 作者：kkksx (赞：6)

我来补一个代码，~~帮助那些像我一样看懂了意思但不知道怎写的童鞋~~

只需要按照题解的意思四舍五入一下就可以将原来的复数除法变成带余除法，然后取模操作减一下就成了

四则运算重载一下，剩下的就和普通扩欧一样了，递归边界就是求最小的$N(Ax)$

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double ld;
ll a,b,c,d;
ll p,q,r,s,ans;

struct cpx
{
	ll x,y;
	cpx() { }
	cpx(ll x,ll y) : x(x),y(y) { }
	cpx operator + (const cpx &a)const { return cpx(x + a.x,y + a.y); }
	cpx operator - (const cpx &a)const { return cpx(x - a.x,y - a.y); }
	cpx operator * (const cpx &a)const { return cpx(x * a.x - y * a.y,x * a.y + y * a.x); }
	cpx operator / (const cpx &a)const
	{
		ld A = x,B = y,C = a.x,D = a.y;
		ld lf = (A * C + B * D) / (C * C + D * D);
		ld ri = (B * C - A * D) / (C * C + D * D);
		return cpx(round(lf),round(ri));
	}
	cpx operator % (const cpx &a)const
	{
		cpx ret = ((*this) / a) * a;
		return cpx(x - ret.x,y - ret.y);
	}
};
void exgcd(cpx a,cpx b,cpx &x,cpx &y)
{
	if(b.x == 0 && b.y == 0)
	{
		ans = a.x * a.x + a.y * a.y;
		x.x = 1; x.y = 0;
		return;
	}
	exgcd(b,a % b,x,y);
	cpx t = x; x = y; y = t - a / b * y;
}


int main()
{
	cin>>a>>b>>c>>d;
	cpx A = cpx(a,b),B = cpx(c,d);
	cpx x,y;
	exgcd(A,B,x,y);
	cout<<x.x<<' '<<-x.y<<' '<<y.x<<' '<<y.y<<' '<<ans<<endl;
	return 0;
}
```

另外感谢神仙出题人帮我查错orz（~~y.y符号写(抄)反了~~）

---

## 作者：naught (赞：1)

# 差别

## 题目描述

给定 $a,b,c,d$，求 $p,q,r,s$ 使得 $M$ 成为非零最小值。

## Solution

$M$ 的表达式很复杂，把式子拆开有 $16$ 个 $4$ 次项，不难发现这是一个平方和，不断套平方和公式，最后化简成：

$$

M = |(ap+bq+cr-ds)^2 + (-aq+bp+cs+dr)^2| = ((a+bi) \times (p-qi) + (c+di) \times (r+si))^2。

$$

这样就可以用 `exgcd` 求解，但如何在复数值域上求解 `exgcd` 呢？

考虑使用带余除法进行计算，设 $\alpha = a+bi, \beta = c+di$，则 $\alpha = \varepsilon \beta + \gamma (\varepsilon, \gamma \in \mathbb{Z})$，用内除法和外除法定义复数的除法，但得保证 $N(\gamma) \le \frac{N(\beta}{2}$（$N(\alpha)$ 表示 $\alpha$ 的范数即 $|\alpha|^2$）。

如何证明？

设 $\gamma = p+qi = \frac{\alpha}{\beta}, \varepsilon = r+si(|r-p| \le \frac{1}{2}, |s-q| \le \frac{1}{2})$ 。

$\therefore N (\gamma - \varepsilon) = (p-r)^ 2 + (q-s) ^ 2 \le \frac{1}{2}$ 。

$\therefore \gamma = \alpha - \varepsilon \beta = (\gamma - \varepsilon) \times \beta$。

$\therefore N(\gamma) = N(\gamma - \varepsilon) \times N(\beta) \le \frac{1}{2} \times \beta$，证毕。

所以令 $\varepsilon = \left \lfloor \frac{\alpha}{\beta} \right \rfloor, \gamma = \alpha \bmod \beta$ 即可。

实际上代码上实现只需要 $\alpha - \frac{\alpha}{\beta} \times \beta $ 即可表示 $\alpha \bmod \beta$，最难的部分就是证明。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
inline ll lread(ll x=0, bool f=0, char c=getchar()) {for(;!isdigit(c);c=getchar()) f^=!(c^45);for(;isdigit(c);c=getchar()) x=(x<<1)+(x<<3)+(c^48);return f?-x:x;}

ll A, B, C, D, m;

struct plural
{
    ll x, y;
    plural () {}
    plural (ll x, ll y) : x(x), y(y) {}
    bool operator == (const plural &other) const {return (x == other.x) && (y == other.y);}
    plural operator+(const plural &other) const {return plural(x+other.x, y+other.y);}
    plural operator-(const plural &other) const {return plural(x-other.x, y-other.y);}
    plural operator*(const plural &other) const {return plural(x*other.x - y*other.y, x*other.y + y*other.x);}
    plural operator/(const plural &other) const {
        double a = x, b = y, c = other.x, d = other.y, alpha = (a*c + b*d) / (c*c + d*d), beta = (b*c - a*d) / (c*c + d*d);
        return plural(round(alpha), round(beta));
    }
    plural operator % (const plural &other) const {return (*this) - (*this) / other * other;}
};

void exgcd(plural a, plural b, plural &x, plural &y)
{
    // cerr << b.x << " " << b.y << endl;
    if(b == plural(0ll, 0ll)) return m = a.x * a.x + a.y * a.y, x = plural(1ll, 0ll), void();
    exgcd(b, a%b, x, y);
    plural tmp = x;
    x = y, y = tmp - a/b*y;
}

int main()
{
    A = lread(), B = lread(), C = lread(), D = lread();

    plural alpha = plural(A, B), beta = plural(C, D), x, y;
    exgcd(alpha, beta, x, y);

    printf("%lld %lld %lld %lld %lld", x.x, -x.y, y.x, y.y, m); 
}
```

## Tips 

记得开 `long long`。

---


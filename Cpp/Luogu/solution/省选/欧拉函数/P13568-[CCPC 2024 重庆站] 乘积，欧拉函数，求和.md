# [CCPC 2024 重庆站] 乘积，欧拉函数，求和

## 题目背景

本题目来自仓库 https://github.com/Disposrestfully/CCPC-CQ-2024/tree/main

## 题目描述

给定 $n$ 个数 $a_1,a_2,\cdots,a_n$，你需要求以下式子的值：

$$\sum_{S \subseteq \{1,2,\cdots,n\}} \varphi \left(\prod_{i \in S} a_i\right).$$

其中 $\varphi$ 为欧拉函数，$\varphi(x)$ 表示在 $[1,x]$ 内与 $x$ 互质的整数数量，例如

- $\varphi(6) = 2$，因为在 $[1,6]$ 内有 $1$ 和 $5$ 与 $6$ 互质。
- $\varphi(1) = 1$，因为在 $[1,1]$ 内有 $1$ 与 $1$ 互质。

另外，我们定义 $\prod_{i \in \varnothing} a_i = 1$。

答案可能很大，你需要求出其对质数 $998244353$ 取模的结果。


## 说明/提示

共有八种 $S$ 的选择，所有选择得到的 $\prod_{i \in S} a_i$ 分别为 $1,1,2,2,3,3,6,6$。可以计算得到 $\varphi(1) = \varphi(2) = 1, \varphi(3) = \varphi(6) = 2$，因此答案为 $1 \times 4 + 2 \times 4 = 12$。

## 样例 #1

### 输入

```
3
1 2 3```

### 输出

```
12```

# 题解

## 作者：Polarisx (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P13568)。


## 思路

首先我们有 $\varphi(n)=n\prod_{p}\frac{p-1}{p}$，$p$ 是 $n$ 的质因子，那么我们只需求

$$\sum_{S\subseteq U}\prod_{i\in S}a_i\prod_{p}\dfrac{p-1}{p}$$

显然，我们只需知道选数的质因子集合，求出每个质因子集合对应的 $a_i$ 乘积之和，不过 $a_i$ 的值域比较大，无法记录所有的质因子，和[这道题](https://www.luogu.com.cn/problem/P8292)一样的套路，一个数 $x$ 至多存在一个 $\ge \sqrt{x}$ 的质因子，注意到 $\pi(\lfloor \sqrt{3000}\rfloor)=16$，因此对于每个大质因子 $p$（即 $p>\sqrt{3000}$），将含有这些质因子的数放在一起处理，在这些数中处理出小质因子情况为 $S$ 的值是多少，最后对于每个大质因子 $p$，将其所对应的 DP 数组合并起来即可（或者并卷积合并）。

最后要算上小质因子的贡献。

时间复杂度 $\mathcal O(n2^k)$，其中 $k=16$。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

const int k=16;
const int Maxn=3010;
const int Mod=998244353;

int n;
int p[]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53},t[Maxn];

inline ll ksm(ll a,int b,int mod){
    ll z=1;
    while(b){
        if(b&1) z=z*a%mod;
        a=a*a%mod;
        b>>=1;
    }
    return z;
}
int F[1<<k],G[1<<k];

struct node{
    int a,b,c;
}a[Maxn];

int main(){
    scanf("%d",&n);

    for(int i=1;i<=n;i++){
        scanf("%d",&a[i].a); a[i].b=a[i].a;
        for(int j=0;j<k;j++){
            if(a[i].b%p[j]==0){
                while(!(a[i].b%p[j])) a[i].b/=p[j];
                a[i].c|=(1<<j);
            }
        }
    }
    sort(a+1,a+n+1,[](node x,node y){
        return x.b<y.b;
    });

    F[0]=1;
    for(int i=1;i<=n;i++){
        ll mul=ksm(a[i].b,Mod-2,Mod)*(a[i].b-1)%Mod;
        if(a[i].b==1) mul=1;

        for(int j=(1<<k)-1;~j;j--) G[j|a[i].c]=(G[j|a[i].c]+1ll*(G[j]+F[j])*a[i].a%Mod)%Mod;
        if(a[i].b!=a[i+1].b){
            for(int j=0;j<(1<<k);j++) F[j]=(F[j]+mul*G[j]%Mod)%Mod,G[j]=0;
        }
    }

    ll ans=0;
    for(int i=0;i<(1<<k);i++){
        ll g=1;
        for(int j=0;j<k;j++) if(i>>j&1) g=g*ksm(p[j],Mod-2,Mod)%Mod*(p[j]-1)%Mod;
        ans=(ans+g*F[i]%Mod)%Mod;
    }
    printf("%lld",ans);

    return 0;
}
```

---


# [HAOI2012] 外星人

## 题目描述

艾莉欧在她的被子上发现了一个数字 $N$，她觉得只要找出最小的 $x$ 使得，$\varphi^x(N) = 1$。根据这个 $x$ 她就能找到曾经绑架她的外星人的线索了。当然，她是不会去算，请你帮助她算出最小的 $x$。

## 说明/提示

$30\%$ 的数据，$N \le 10^6$。

$60\%$ 的数据，$x \le 100$。

$100\%$ 的数据，$\mathrm{test} \le 50$，$1 \le p_i \le {10}^5$，$1 \le q_i \le {10}^9$，$m \le 2000$。

$\varphi$ 为欧拉函数，$\varphi(n)$ 即小于等于 $n$ 的数中与 $n$ 互质的数的个数。

提示：$\varphi(\prod_{i=1}^mp_i^{q_i})=\prod_{i=1}^m(p_i-1)\times p_i^{q_i-1}$。

## 样例 #1

### 输入

```
1
2
2 2
3 1
```

### 输出

```
3
```

# 题解

## 作者：宁_缺 (赞：21)

不得不说这题的题面真的……晦涩艰深……

大致解释一下

$$\varphi^x(N) = 1$$
表示每次让$N=\varphi(N)$，重复 x 次的结果等于1

$$\varphi(\prod_{i = 1}^m p_i^{q_i}) = \prod_{i = 1}^m (p_i - 1)*p_i^{q_i-1}$$
（就是题目最下方给的那公式~~然而它炸了~~）

看上去很复杂，不过结合题目中的$\prod_{i = 1}^m p_i^{q_i}$**为N的标准分解形式**这句话，上面展开就是：把N质因数分解成$p_1^{q_1}$ * $p_2^{q_2}$ * …… * $p_m^{q_m}$，则$\varphi(N)=(p_1-1)*p_1^{q_1-1}*......*(p_m-1)*p_m^{q_m-1}$ 

然后输入我也说下吧（~~因为我一开始连输入的是什么都没看懂~~）：出题人良心发现帮你把N质因数分解好了，输入的m，p，q意义就是上面的那些。

~~突然发现这篇题解最难打字的地方居然是翻译题目……~~

# 

下面终于开始说到做法了

把那些公式说成人话，其实每次就是把N的每种质因子各取一个拿出来减一再乘回去（可能有点绕，原谅我这么烂的语文水平）

那么，想让N变成1，就要把N的质因子不断地减小，拆分成更多的质因子，以此类推，显然每个大于2的质因子都会经历分成不少于一个的2再变成1的过程。又因为每种质因子是同时减少的，所以若N为偶数则分出的2的个数就是总操作数（显然最后一步是2变成1，而每次最多只有一个2变成1），如果N为奇数那么第一步没有2变成1，要往后顺延一步，总操作数要加一。

（**注：此处【分出的2的个数】指一个数减一后质因数分解，再将其中大于2的数重复此步骤最后剩下2的个数**）

质因子最大不超过十万，因此可以DP预处理出每个质因子一共会分出多少个2：（设i分出2的个数为f[i]）

①$f[p]=f[p-1]$ (p为质数)

p无法质因数分解，直接减一

②$f[a*b]=f[a]+f[b]$ 

仍没什么好解释的，假想a*b中先分a再分b就行了

剩下的就看注释吧，虽然说了这么多，不过代码倒是很短

```cpp
#include<bits/stdc++.h>
#pragma GCC optimize(3)
#define LL long long
using namespace std;
const int N=3e4+1,M=1e5+10;
int t,c,m;bool isp[M];
LL a[N],b[N],ans,p[N],f[M];
int main(){
	scanf("%d",&t),f[1]=1;
	for(LL i=2;i<M;++i){
		if(!isp[i])p[++c]=i,f[i]=f[i-1];
		for(int j=1;j<=c&&p[j]*i<M;++j){
			isp[p[j]*i]=1,f[p[j]*i]=f[p[j]]+f[i];
			if(i%p[j]==0)break;
		}
	}//线性筛中求出f数组
	while(t--){
		scanf("%d",&m),ans=1;
		for(int i=1;i<=m;++i)
			scanf("%lld%lld",&a[i],&b[i]),
			ans+=((a[i]&1ll)?0:-1)+f[a[i]]*b[i];
			//上面已说了奇数结果要加一，因此先将ans赋值为1然后如果有偶数质因子（只有一个2）再减一
		printf("%lld\n",ans);
	}
	return 0;
}
```
题外话：整整六个月没写题解了（上次2.19）……第一次用这么多Markdown/LaTex，大佬勿喷

---

## 作者：JJA_ (赞：14)

$$\varphi(\prod_{i = 1}^m p_i^{q_i}) = \prod_{i = 1}^m (p_i - 1)*p_i^{q_i-1}$$

~~没错这就是 说明/提示 里的 $\LaTeX$ ，但是它spfa了~~

---
### 题目大意：

输入 $N$ ，输出 $x$ 使得最小的 $\varphi^x(N)=1$ 。那么，$\varphi$ 又是什么意思呢？说明里很清楚， $\varphi$ 为欧拉函数，$\varphi(N)$ 即小于等于 $N$ 的数中与 $N$ 互质的数的个数。
但是若还是不太懂，就百度一下：
![image.png](https://i.loli.net/2020/10/21/Cpzdi7LkxPtQVoN.png)

此式子展开就是：

$$p_{1}^{q_{1}-1}\times p_{2}^{q_{2}-1}\times...\times p_{m}^{q_{m}-1}$$

其中 $\prod$ 就是连乘的意思，~~具体也可以看[百度百科](https://baike.baidu.com/item/%E2%88%8F/8402025?fr=aladdin)~~

输入格式就是一个整数 $m$，之后输入 $q_i$ 和 $p_i$，也就是说输入数据帮你已经**分解好**数据了。

所以，就是让你算出 $\varphi(\varphi(\varphi(\varphi(...\varphi(N)...)=1$ 最少的次数。

---
### 题目思路

首先， $\varphi(1)=1$ ~~显然~~因为 $1$ 只能被分解为 $1\times1$ 。

那么， $\varphi(2)=1$ 也成立，因为 $\varphi(2)=2^{1-1}=2^0=1$ 。

所以， $\varphi^x(n)$ 中会将 $2$ 的因子转变为 $1$ ，显然， $\varphi^x(2^n)=1$ 时， $x$ 最小为 $n$ 。

但是，我们再看 $\varphi(3)$ ， $\varphi(3)=3^{1-1}$，
也是 $1$！

所以，对于没有 $2$ 为因子的数，需要**先执行一次 $\varphi$ ，再进行运算，也就代表，答案数量要加一。**

---
### 代码构成

上来先打一个欧拉筛：

```cpp
int a[maxn],pri[maxn],sum=0;
map<int,bool>isp;
int N,n,ans=1,p,q;
a[1]=1;
for(int i=2;i<=1e5;i++)
{
	if(!isp[i])
	{
		pri[++sum]=i;
		a[i]=a[i-1];
	}
	for(int j=1;j<=sum;j++)
	{
		if(pri[j]*i>1e6)
		break;
		isp[pri[j]*i]=true;
		a[pri[j]*i]=a[pri[j]]+a[i];
		if(!(i%pri[j]))
		{ 
			break;
		}
	}
}
```
~~但是为了卡常，提交时可以把`map`换成`unordered_map`，然后用 C++11 交~~

主函数代码就很简单，
```cpp
read(N);
while(N--)
{
	int ans=1;
   read(n);
	for(int i=1;i<=n;i++)
	{
		read(p);
		read(q);
		if(p==2)
		ans--;
		ans+=a[p]*q;
	}
	write(ans);
	printf("\n");
}
```
我用了快读和快输，所以整体代码可能看起来长亿点点：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long //个人习惯
#define maxn 5000005
inline void read(int &a)//不标准的快读
{
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
	{
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
	{
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    a=x*f;
}
inline void write(int x)//标准快输
{
    if (x < 0) putchar('-'),x = -x;
    if (x > 9) write(x/10); putchar(x%10+'0');
}
int a[maxn],pri[maxn],sum=0;
map<int,bool>isp;
int N,n,ans=1,p,q;
signed main() //与 #define int long long 配套
{
	a[1]=1;
    for(int i=2;i<=1e5;i++)
	{
        if(!isp[i])
		{
			pri[++sum]=i;
			a[i]=a[i-1];
		}
        for(int j=1;j<=sum;j++)
        {
        	if(pri[j]*i>1e6)
        	break;
        	isp[pri[j]*i]=true;
        	a[pri[j]*i]=a[pri[j]]+a[i];
        	if(!(i%pri[j]))
			{ 
				break;
			}
        }
    }
    //前面是欧拉筛
    read(N);
    while(N--)
    {
    	int ans=1;
    	read(n);
        for(int i=1;i<=n;i++)
        {
			read(p);
			read(q);
			if(p==2)//若是2就减一 
			ans--;
            ans+=a[p]*q;
        }
        write(ans);
        printf("\n");//换行
    }
}
```
望采纳，谢谢

---

## 作者：Siyuan (赞：12)

[$$\Large\texttt{My Blog}$$](https://hydingsy.github.io/articles/problem-HAOI-2012-Extra-Terrestrial/)

---

## Description

> 题目链接：[Luogu 2350](https://www.luogu.org/problemnew/show/P2350)

艾利欧在她的被子上发现了一个数字 $n$，她觉得只要找出最小的 $x$ 使得，$\varphi^x(n)=1$。根据这个 $x$ 她就能找到曾经绑架她的外星人的线索了。现在她给你这个数字 $n$ 的标准分解形式 $n=\prod_{i=1}^m {p_i}^{q_i}$，请你帮助她算出最小的 $x$。

本题 $T$ 组数据。

数据范围：$1\le T\le 50$，$1\le p_i\le 10^5$，$1\le q_i\le 10^9$

------

## Solution

读完题目之后一脸懵逼：求 $\varphi(n)$ 的 $x$ 阶导数？？？

其实这题的题意是：给定 $n$，每次使 $n$ 等于 $\varphi(n)$，求最少几次操作后 $n=1$。

首先可以打表发现如下规律：只有 $1$ 和 $2$ 的 $\varphi$ 值才是 $1$！

接下来我们根据 $\varphi(n)$ 的定义，有如下式子：
$$\varphi\left(\prod_{i=1}^m {p_i}^{c_i}\right)=\prod_{i=1}^m (p_i-1)\times {p_i}^{c_i-1}$$
那么意味着每次操作会把上一次操作的答案中的**最多一个 $2$ 变为 $1$**（注意：不可能同时变化多个 $2$）。

所以我们只要求出**每个质因子**在操作过程中会产生多少个 $2$ 即可。

具体的过程为：我们设 $f(i)$ 表示 $i$ 在操作过程中会产生多少个 $2$；那么有如下转移方程：

1. 当 $i$ 为质数时，$f(i)=f(i-1)$，因为质数进行操作后变为 $i-1$ 而没有增加 $2$ 的个数，因此应该和 $f(i-1)$ 的答案相等。
2. 当 $i=a\times b$ 时，$f(i)=f(a)+f(b)$ 因为 $i$ 可以表示为两个数相乘，那么其 $2$ 的次数应该为两者之和。

**但是！**我们发现直接这样写是会错的！考虑如下情况：

- 原数为 $3$，那么我们第一次操作不会把任何一个 $2$ 改为 $1$（因为 $3$ 中本来就没有任何一个因子 $2$）。所以需要 $2$ 次操作而不是 $3$ 次！

因此我们需要处理一下**细节问题**：当原数中没有因子 $2$ 时，答案 $+1$。

**时间复杂度**：$O(p_i+Tn)$

------

## Code

```cpp
#include <cstdio>

const int N=1e5+5;
int n,tot,p[N],f[N];
bool flg[N];

void sieve(int n) {
	f[1]=1;
	for(int i=2;i<=n;++i) {
		if(!flg[i]) p[++tot]=i,f[i]=f[i-1];
		for(int j=1;j<=tot&&i*p[j]<=n;++j) {
			flg[i*p[j]]=1,f[i*p[j]]=f[i]+f[p[j]];
			if(i%p[j]==0) break;
		}
	}
}
int main() {
	sieve(N-5);
	int T;
	for(scanf("%d",&T);T--;) {
		scanf("%d",&n);
		long long ans=0,flg=0;
		for(int i=1;i<=n;++i) {
			int p,c;
			scanf("%d%d",&p,&c);
			if(p==2) flg=1;
			ans+=1LL*f[p]*c;
		}
		if(!flg) ++ans;
		printf("%lld\n",ans);
	}
	return 0;
}
```



---

## 作者：Hercules (赞：5)

## 题解：P2350 [HAOI2012]外星人

**这个不是说的$\varphi^x(N)$不是$\varphi(N)$的$x$次幂！**

**更不是求导！！！**

---

给定一个数，表示为：$\prod\limits_ { i=1} ^m p[i]^{q[i]}$

问最少需要对这个数字$x$进行几次$x=\varphi(x)$操作使得$x=1$。

这道题的话只有$\varphi(2)=1$，所以最后答案必然需要转成带2的形式，我们先考虑一个数字，由欧拉函数的推导公式$\varphi(\prod\limits _{i=1} ^mp[i]^{q[i]})=\prod\limits_{i=1}^m (p[i]-1)\cdot p[i]^{(q[i]-1)}$可以发现每次求$\varphi$则会消去一个质因数2，并且产生许多个2。

举个例子：$N=2^{c_1}\cdot p_2^{c_2}...p_n^{c_n}$中产生了$c_1$个2，消去了1个。

综上，我们只需要求出产生了多少个2就好。

显然欧拉函数是积性函数，所以对每一项$p[i]^{q[i]}$分解出2的个数就是$p[i]$分解的个数乘上$q[i]$。

$P.S.$除了$\varphi(2)$之外其他的都是偶数，所以任意奇数经过一次求$\varphi$就好了。

**提醒：原数因子无2时，答案需要$+1$。**
```c
#pragma GCC optimize(3, "Ofast", "inline")
#include <bits/stdc++.h>
#define int long long

const int MAXN = 1e5 + 10;
const int MAXM = 1e5;
int T, m, cnt, ans, pi[MAXN], qi[MAXN], phi[MAXN], p[MAXN], prime[MAXN];

inline int read() {
    int X = 0, flag = 0;
    char ch = 0;
    while (!isdigit(ch))
        flag |= ch == '-', ch = getchar();
    while (isdigit(ch))
        X = (X << 3) + (X << 1) + (ch ^ 48), ch = getchar();
    return flag ? -X : X;
}

inline void shaifa() {
	phi[1] = 1, prime[1] = 1;
	for (register int i = 2; i <= MAXM; i++) {
		if (!prime[i])
			p[++cnt] = i, phi[i] = phi[i - 1];
		for (register int j = 1; j <= cnt and p[j] * i <= MAXM; j++) {
			prime[p[j] * i] = 1;
			phi[p[j] * i] = phi[p[j]] + phi[i];
			if (i % p[j] == 0)
				break;
		}
	}
}

signed main() {
#ifndef ONLINE_JUDGE
#ifdef LOCAL
    freopen("testdata.in", "r", stdin);
    freopen("testdata.out", "w", stdout);
#endif
#ifndef LOCAL
    freopen("HAOI2012外星人.in", "r", stdin);
    freopen("HAOI2012外星人.out", "w", stdout);
#endif
#endif
	T = read(), shaifa();
	while (T--) {
		m = read(), ans = 0;
		for (register int i = 1; i <= m; i++)
			pi[i] = read(), qi[i] = read();
		for (register int i = 1; i <= m; i++) {
			if (pi[i] == 2)
				ans--;
            ans += phi[pi[i]] * qi[i];
		}
        printf("%lld\n", ans + 1);
	}
    return 0;
}
```


---

## 作者：Arcturus1350 (赞：4)

还是本宝宝写题解的一贯习惯 $ :$ 先吐槽吐槽这道题$……$

相信不少同学第一眼一定没有看懂题。（因为我也没看懂）

~~初中~~数学知识：

对于函数 $ f(x)$ 有 $f^{-1}(x)$ 为该函数的反函数。

而当 $ n∈N^{*} $ 时， $f^{n}(x)$ 表示$f(x)$ 的 $n$阶导数。

于是本宝宝看到这题后~~一脸懵逼~~炸了：

喵 $ ?$ $ $ $ !$  出题人您来告诉我欧拉函数怎么求导$ !$ $ $ $ !$ $ $ $ !$

看一眼题解，才知道$……$

我的数学白学了$?!!$

---

转入正题 $:$

其实，给定 $n$ ，让你求 $x$ 使得

 $$\varphi^{x}(N)=1$$
 
 的意思其实是：
 
 每次取 $N=\varphi(N)$ 问至少操作几次后使得 $N=1$
 
 也就是说$:$
 
 $$\varphi(\varphi(…\varphi(N)))=1$$
 
 的最少取 $\varphi$ 的次数即为$ x $
 
 ---
 
 好了我们终于理解完题意了。
 
 现在我们可以开始做题了。
 
 这里要引用一句~~名言~~:
 
 如果你是一个在省选考场即将$AK$的人，闲来无事，打了一个 $\varphi(1)-\varphi(1000000)$的表。
 
 然后你惊奇的发现，只有当 $ n$ $=$ $1,2$ 时欧拉函数值是 $0$
 
 然后这玩意要是 $ 1$ 的话，答案显然。
 
 其余的，就根据
 
 $$\varphi(\prod_{i=1}^{m}p_{i}^{q_{i}})=\prod^{m}_{i=1}(p_{i}-1)*p_{i}^{q_{i}-1}$$
 
 所以，每次操作会将上一次操作的答案中的一个因子$2$变为$1$
 
所以，求操作过程中会产生多少个因子$2$就好了。

---
下面来讨论特例：

$1.$ 对于 $ 2^{n}$ $,$ 我们的操作次数是 $n$ $,$ 显然是这样的。

$2.$ 对于一开始是一个质数，我们第一次操作不会将其中的一个因子$2$变为$1$，所以，这时候 $ans++$

---

好了，上代码：
```cpp
// luogu-judger-enable-o2
#include<iostream>
#include<cmath>
#include<cstdio>
#include<algorithm>
using namespace std;
#define int long long//个人习惯

int pni[100010];//欧拉函数值
bool ins[100010];//标记有没有被筛过
int prime[100010];//记录质数
int cnt;//质数个数
inline void init(){
    pni[1]=1;
    for(int i=2;i<=100000;i++){
        if(!ins[i]) prime[++cnt]=i,pni[i]=pni[i-1];
        for(int j=1;j<=cnt&&prime[j]*i<=100000;j++)
        {
        	ins[prime[j]*i]=true;
        	pni[prime[j]*i]=pni[prime[j]]+pni[i];
        	if(!(i%prime[j])) break;
        }
    }
    return ;
}
//以上是欧拉线性筛的模板。

int t;
int n;int ans=1;
int p;int q;
signed main()
{
    init();
    scanf("%lld",&t);
    while(t--)
    {
        scanf("%lld",&n);
        for(int i=1;i<=n;i++){
            scanf("%lld%lld",&p,&q);
            if(p==2) ans--;
            ans+=pni[p]*q;//统计答案
        }
        printf("%lld\n",ans);
        ans=1;
    }
    return 0;//程序拜拜。
}
```

---

## 作者：Foreverxxx (赞：2)

这题面是真的令人晦涩难懂……

### 题目解释

 $\varphi^x(N)$ 表示将 $N$ 进行 $x$ 次赋值操作 $N=\varphi(N)$，$\varphi^x(N)=1$ 即为 $\varphi(\varphi(\varphi(\dots \varphi(N) \dots)))=1$。
 
那么题目想表达的意思就是：

给定一个数 $N$，其中 $N = \prod_{i=1}^{m}p_i^{q_i}=p_1^{q_1} \times p_2^{q_2} \times \dots \times p_m^{q_m}$，题目已经把 $m，p，q$ 给你了，求最少需要多少次 $N = \varphi(N)$ 的操作，使得最终结果为 $1$。 

### 思路

不难发现，直接暴力把 $N$ 算出来是不可能的，因为 $N$ 的数量级已经到达了天文级别。

所以我们必须对题目所给的柿子进行分析。

首先比较明显的是，我们可以对每个因子单独进行考虑。

然后我们对欧拉函数进行一波分析，发现只有 $\varphi(1) = \varphi(2) = 1$。

然后我们通过提示的式子发现，每一个因数都会不停地减少 $1$，而当这个数变成 $2$ 的时候，他的 $\varphi$ 值就会变成 $1$。

所以问题就被转化成了，这些因子最终会产生多少个 $2$？

这里可能会有点绕，有的同学可能会想：每一次变化，这个数中的每一个因数的都会减少 $1$ 个吗？

所以我们来模拟一下样例。

最初这个数为 $2^2 \times 3^1$。

第一次变化，这个数变成了 $(2-1))\times 2^{2-1} \times (3-1) \times 3^{1-1}=2^1 \times 2^1 = 2^2$。

第二次变化，这个数变成了 $(2-1) \times 2^{2-1}=2^1$。

第三次变化，这个数变成了 $2^{1-1}=1$。

在第一次变化中，这个数少了 $1$ 个 $2$，而同时，$3$ 变成了 $2$，这仿佛很难处理。

但是我们发现，这个 $3$ 变成的 $2$ 最终也花费了一次机会，才变成了 $1$。

所以我们发现，所有的 $\displaystyle\sum_{i=1}^{m} q_i$ 个因数，最终都会被转化成 $2$，然后被消掉。

然后根据提示的式子，每次最多只能消掉一个 $2$，那么这些数最终会产生多少个 $2$ 便是答案了。

但很明显一个数不一定只会产生一个 $2$，比如 $8$ 就会产生 $3$ 个 $2$，所以我们需要用 ``DP`` 预处理出每个数会产生多少个 $2$。

那么我们的状态转移方程是比较好想的：

$$
dp_i=\begin{cases}dp_{i-1},i \in prime\\
dp_x + dp_y,x \times y =i
\end{cases}
$$

当 $i$ 为质数的时候，它第一步只会被分解成 $i-1$，然后才有可能被分解成其它数，所以它产生的 $2$ 的数量和 $i-1$ 是相同的。

对于正常的情况，$i$ 会被拆分为 $x \times y$，而最终产生的 $2$ 的个数就是 $x$ 产生的 $2$ 的个数与 $y$ 产生的 $2$ 的个数之和，比较容易理解。

但是，当我们自信满满地把代码交上去的时候，却发现……只有 $30$ 分！

究竟是为什么呢？

其实眼尖的同学已经发现了，如果 $N$ 是奇数，那么第一步是不会有 $2$ 的，所以最终的答案就会加 $1$。

我们再去仔细的想，对于一个奇数 $x$，它的质因数一定都是奇数，而这些奇数会通过第一步变成偶数，然后就会产生 $2$，就能够一直分解下去了。

但是还有最后一个疑虑：会不会在中间分解到一半的时候没有 $2$ 了呢？很明显是不会的。

如果当前的因数中包含偶数，那么此时这个数被分解出来的因数中一定会有 $2$ 供我们使用，如果此时没有偶数，那么在上一步存在偶数时，奇数会在上一步变成偶数，然后就会产生 $2$ 了，所以这个 $2$ 是源源不断的，直到最后答案变为 $1$。

### 细节

注意当 $N$ 是奇数时，第一次不会分解出 $2$ 的，此时答案应该加 $1$。

Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read(){
	int sss=0;
	char chh=getchar();
	while(chh<'0'||chh>'9') chh=getchar();
	while(chh>='0'&&chh<='9'){
		sss=sss*10+chh-'0';
		chh=getchar();
	}
	return sss;
}
int T;
bool isprime[100005];
int prime[100005],tot=0;
int dp[100005];
void init(int n){//dp预处理部分 
	dp[1]=1;
	for(register int i=2;i<=n;i++){
		if(!isprime[i]){
			prime[++tot]=i;
			dp[i]=dp[i-1];
		}
		for(register int j=1;j<=tot&&i*prime[j]<=n;j++){
			isprime[i*prime[j]]=true;
			dp[i*prime[j]]=dp[i]+dp[prime[j]];
			if(i%prime[j]==0) break;
		}
	}
}
signed main(){
	init(1e5+3);
	T=read(); int n,q,p;
	while(T--){
		n=read(); int ans=0; bool flag=false;
		for(register int i=1;i<=n;i++){
			p=read(),q=read();
			if(p==2) flag=true;//判断是否为奇数 
			ans+=dp[p]*q;
		}
		if(!flag) ans++;//如果是奇数，则答案需要加一 
		cout<<ans<<"\n";
	}
	return 0;
}
```

---

## 作者：__Deng_Rui_Song__ (赞：1)

# preface
~~AC 五分钟，推式子两小时。~~
# problem
[题目传送门](/problem/P2350)

题意：求 $\min_{\varphi^x(N) = 1}\{x\}$。
# solution
题目非常贴心地帮我们提前质因数分解了。

观察提示的式子：

$$\varphi(\prod_{i=1}^mp_i^{q_i})=\prod_{i=1}^m(p_i-1)\times p_i^{q_i-1}$$

可以发现，每个除了 $2$ 以外的质因子，都会变成很多个 $2$ 相乘，发现质因子不会超过 $10^5$，那么我们设 $dp_i$ 表示 $i$ 会产生多少个质因子，考虑两种情况：

- $i\in\mathbb{P}$：按照公式，直接 $dp_i=dp_{i-1}$。

- $i\notin\mathbb{P}$：可以发现，每个质因子是独立的，所以 $dp_i=dp_a+dp_b(a\mid i,b\mid i)$。

好耶！是加性函数！

超弱的蒟蒻：怎么跑 dp 呢？

我：很简单，用……

~~超强的~~你：欧拉筛！

~~别抢我台词！~~
# code $\color{white}假的！$

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod = 1e9 + 7;
int t,n,ans,cnt[100005];
bool vis[100005];
vector<int> p;
void solve(){
	cin >> n;
	for (int i = 1,x,y; i <= n; i++){
		cin >> x >> y;
		ans += y * cnt[x];
	}
	cout << ans << '\n';
	ans = 0;
}
signed main(){
	vis[0] = vis[1] = 1;
	cnt[1] = 1;
	for (int i = 2; i <= 1e5; i++){
		if (!vis[i]){
			p.push_back(i);
			cnt[i] = cnt[i - 1];
		}
		for (int j = 0; j < p.size() && i * p[j] <= 1e5; j++){
			vis[i * p[j]] = 1;
			cnt[i * p[j]] = cnt[i] + cnt[p[j]];
			if (!(i % p[j])) break;
		}
	}
	for (cin >> t; t--; solve());
	return 0;
}
```
然后就可以……轻松地拿到 30pts 了。

~~你：!#%\$%^%^&@%^*&@#^&*!#^@&&\*#@\$#$。~~

超弱的蒟蒻：为什么只拿到 30pts 呢？

我：对于没有质因子 $2$ 的~~毒瘤~~数据，都要先来一次 $\varphi$ 产生质因子 $2$ 再开始，所以要 +1 哦！

# code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod = 1e9 + 7;
int t,n,ans,cnt[100005];
bool vis[100005];
vector<int> p;
void solve(){
	cin >> n;
	bool flag = 1;
	for (int i = 1,x,y; i <= n; i++){
		cin >> x >> y;
		flag &= x != 2;
		ans += y * cnt[x];
	}
	cout << ans + flag << '\n';
	ans = 0;
}
signed main(){
	vis[0] = vis[1] = 1;
	cnt[1] = 1;
	for (int i = 2; i <= 1e5; i++){
		if (!vis[i]){
			p.push_back(i);
			cnt[i] = cnt[i - 1];
		}
		for (int j = 0; j < p.size() && i * p[j] <= 1e5; j++){
			vis[i * p[j]] = 1;
			cnt[i * p[j]] = cnt[i] + cnt[p[j]];
			if (!(i % p[j])) break;
		}
	}
	for (cin >> t; t--; solve());
	return 0;
}
```

---

## 作者：NTT__int128 (赞：1)

考虑对于 $n$ 的一个次数至少为 $1$ 的质因子 $p_i$。当 $p_i>2$ 时，发现 $p_i-1$ 为偶数，则求 $\varphi(n)$ 后一定会产生质因子 $2$。

不难发现，最后 $n$ 一定只剩下若干个质因数 $2$。

定义 $f_i$ 为将 $i$ 求 $\varphi$ 的过程中会产生质因数 $2$ 的个数。不难发现，$f_i$ 为加性函数，欧拉筛筛出来就行了。

那么答案为 $\sum\limits_{i=1}^mf(p)\times q+$ 所有的 $p$ 均不为 $2$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5,M=2005;
int n,t,m,pr[N],id[N],cnt;
long long f[N];
bitset<N>ip;
void init(){
	for(int i=2;i<=n;i++){
		if(!ip[i])pr[++cnt]=i,f[i]=(i==2?1:f[i-1]);
		for(int j=1;j<=cnt&&1ll*i*pr[j]<=n;j++){
			ip[i*pr[j]]=1;
			f[i*pr[j]]=f[i]+f[pr[j]];
			if(i%pr[j]==0)break;
		}
	}
}
void work(){
	cin>>m;
	long long ans=0;
	bool flag=0;
	for(int i=1;i<=m;i++){
		int p,q;cin>>p>>q;
		ans+=1ll*q*f[p];
		if(p==2)flag=1;
	}
	cout<<ans+(!flag)<<'\n';
}
int main(){
	n=N-5;init();
	cin>>t;
	while(t--)work();
	return 0;
}
```

---

## 作者：LXcjh4998 (赞：1)

[题目链接](https://www.luogu.com.cn/problem/P2350)
# 题意
定义一个函数 $f(i,n)=\begin{cases}\varphi(n)&i=1\\\varphi(f(i-1,n))&i>1\end{cases}$，$i$、$n$ 都为正整数。

现已知一正整数 $N$，求最小的 $x$ 使得 $f(x,N)=1$。

---
多测，输入第一行为一个正整数 $T$，表示有 $T$ 组数据。

由于 $N$ 有可能非常大，读入时读入的是 $N$ 的标准分解形式。

具体的，每组数据第一行为一正整数 $m$，表示 $N$ 有 $m$ 个互异的质因子。接下来 $m$ 行，每行有两个整数 $p_i,q_i$，满足 $\displaystyle \prod_{i = 1}^{m} p_i^{q_i}=N$ 且 $p_i$ 为互异的质数。
# 思路
~~由手玩~~易知只有 $\varphi(2)$ 和 $\varphi(1)$ 等于 $1$，并且对于任意正整数 $n>2$，都有 $2\mid\varphi(n)$。

并且注意到，每次操作（即计算 $\varphi(n)$）后最多只会消去一个 $2$。

因此我们只需要计算在不断的操作中，会产生几个 $2$ 即可，这是因为产生几个 $2$ 就会消去几个 $2$，并且每次只会消去一个 $2$。

设 $g(n)$ 为 $n$ 在不断地操作 $n$ 时产生的 $2$ 的个数。
- 首先有 $g(2)=1$。
- 其次若 $n$ 为奇质数，则 $g(n)=g(n-1)$（因为 $\varphi(n)=n-1$）。
- 否则，设 $a$ 和 $b$ 为满足 $a\times b=n$ 的正整数，$g(n)=g(a)+g(b)$（可以理解为先计算 $a$ 再计算 $b$）。

就实现上来说，可以利用线性筛计算 $g(n)$。

统计答案时，$N$ 产生的 $2$ 个数为 $ans=\displaystyle\sum_{i=1}^mq_i\times g(p_i)$。

需要注意的是，若 $N$ 为奇数，则 $ans$ 还需要加 $1$，因为第一次不会消去 $2$。
# 程序
[AC 记录](https://www.luogu.com.cn/record/204364520)
```cpp
#include<cstdlib>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<queue>
#include<cstdio>
#include<iostream>
#include<vector>
#include<map>
#include<cmath>
#include<iomanip>
#include<string>
#include<stack>
#define re register
#define ll long long
#define ull unsigned long long
#define vl __int128
#define ld long double
#define LL 2e18
#define INT 1e9
#define INF 0x3f3f3f3f
#define lb(x) (x&(-x))
#ifdef __linux__
#define gc getchar_unlocked
#define pc putchar_unlocked
#else
#define gc _getchar_nolock
#define pc _putchar_nolock
#endif
int T=1;
using namespace std;
inline bool blank(const char x){return !(x^32)||!(x^10)||!(x^13)||!(x^9);}
template<typename Tp>inline void read(Tp &x){x=0;re bool z=true;re char a=gc();for(;!isdigit(a);a=gc())if(a=='-')z=false;for(;isdigit(a);a=gc())x=(x<<1)+(x<<3)+(a^48);x=(z?x:~x+1);}
inline void read(double &x){x=0.0;re bool z=true;re double y=0.1;re char a=gc();for(;!isdigit(a);a=gc())if(a=='-')z=false;for(;isdigit(a);a=gc())x=x*10+(a^48);if(a!='.')return x=z?x:-x,void();for(a=gc();isdigit(a);a=gc(),y/=10)x+=y*(a^48);x=(z?x:-x);}
inline void read(ld &x){x=0.0;re bool z=true;re ld y=0.1;re char a=gc();for(;!isdigit(a);a=gc())if(a=='-')z=false;for(;isdigit(a);a=gc())x=x*10+(a^48);if(a!='.')return x=z?x:-x,void();for(a=gc();isdigit(a);a=gc(),y/=10)x+=y*(a^48);x=(z?x:-x);}
inline void read(char &x){for(x=gc();blank(x)&&(x^-1);x=gc());}
inline void read(char *x){re char a=gc();for(;blank(a)&&(a^-1);a=gc());for(;!blank(a)&&(a^-1);a=gc())*x++=a;*x=0;}
inline void read(string &x){x="";re char a=gc();for(;blank(a)&&(a^-1);a=gc());for(;!blank(a)&&(a^-1);a=gc())x+=a;}
template<typename T,typename ...Tp>inline void read(T &x,Tp &...y){read(x),read(y...);}
template<typename T>inline void read(T *begin,T *end){re T *i;if(begin<end)for(i=begin;i<end;++i)read(*i);else for(i=begin-1;i>=end;--i)read(*i);}
template<typename Tp>inline void write(Tp x){if(!x)return pc(48),void();if(x<0)pc('-'),x=~x+1;re int len=0;re char tmp[64];for(;x;x/=10)tmp[++len]=x%10+48;while(len)pc(tmp[len--]);}
inline void write(const double x){re int a=6;re double b=x,c=b;if(b<0)pc('-'),b=-b,c=-c;re double y=5*powl(10,-a-1);b+=y,c+=y;re int len=0;re char tmp[64];if(b<1)pc(48);else for(;b>=1;b/=10)tmp[++len]=floor(b)-floor(b/10)*10+48;while(len)pc(tmp[len--]);pc('.');for(c*=10;a;a--,c*=10)pc(floor(c)-floor(c/10)*10+48);}
inline void write(const ld x){re int a=6;re ld b=x,c=b;if(b<0)pc('-'),b=-b,c=-c;re ld y=5*powl(10,-a-1);b+=y,c+=y;re int len=0;re char tmp[64];if(b<1)pc(48);else for(;b>=1;b/=10)tmp[++len]=floor(b)-floor(b/10)*10+48;while(len)pc(tmp[len--]);pc('.');for(c*=10;a;a--,c*=10)pc(floor(c)-floor(c/10)*10+48);}
inline void write(const pair<int,double>x){re int a=x.first;if(a<7){re double b=x.second,c=b;if(b<0)pc('-'),b=-b,c=-c;re double y=5*powl(10,-a-1);b+=y,c+=y;re int len=0;re char tmp[64];if(b<1)pc(48);else for(;b>=1;b/=10)tmp[++len]=floor(b)-floor(b/10)*10+48;while(len)pc(tmp[len--]);a&&(pc('.'));for(c*=10;a;a--,c*=10)pc(floor(c)-floor(c/10)*10+48);}else printf("%.*lf",a,x.second);}
inline void write(const pair<int,ld>x){re int a=x.first;if(a<7){re ld b=x.second,c=b;if(b<0)pc('-'),b=-b,c=-c;re ld y=5*powl(10,-a-1);b+=y,c+=y;re int len=0;re char tmp[64];if(b<1)pc(48);else for(;b>=1;b/=10)tmp[++len]=floor(b)-floor(b/10)*10+48;while(len)pc(tmp[len--]);a&&(pc('.'));for(c*=10;a;a--,c*=10)pc(floor(c)-floor(c/10)*10+48);}else printf("%.*Lf",a,x.second);}
inline void write(const char x){pc(x);}
inline void write(const bool x){pc(x?49:48);}
inline void write(char *x){fputs(x,stdout);}
inline void write(const char *x){fputs(x,stdout);}
inline void write(const string &x){fputs(x.c_str(),stdout);}
template<typename T,typename ...Tp> inline void write(T x,Tp ...y){write(x),write(y...);}
template<typename T>inline void write(T *begin,T *end,const char c=' '){re T *i;for(i=begin;i<end;++i)write(*i,c);}
template<typename T>inline void init(T *begin,T *end,const T& val=T()){re T* i;for(i=begin;i<end;++i)*i=val;}
template<typename T>inline T max(T *begin,T *end){re T *ans,*i;for(i=begin;i<end;++i)if(i==begin||*ans<*i)ans=i;return *ans;}
template<typename T>inline T min(T *begin,T *end){re T *ans,*i;for(i=begin;i<end;++i)if(i==begin||*i<*ans)ans=i;return *ans;}
template<typename T>inline T calc_sum(T *begin,T *end,const T& val=T()){re T ans=val,*i;for(i=begin;i<end;++i)ans+=*i;return ans;}
template<typename T>inline bool is_equal(T *begin,T *end,const T& val=T()){re T *i;for(i=begin;i<end;++i)if(*i!=val)return false;return true;}

ll mod=0;
const int MAXN=1e5;
const int N=MAXN+10;
//#define DEBUG
//#define more_text

ll n,m,p,q;

ll ans,P[N],g[N];bool np[N],has_two;
void init(){
	int cnt=0,len=MAXN;
	g[1]=1; //方便计算 
	for(int i=2;i<=len;++i){
		if(!np[i])P[++cnt]=i,g[i]=g[i-1];
		for(int j=1;j<=cnt&&i*P[j]<=len;++j){
			np[i*P[j]]=true;
			g[i*P[j]]=g[i]+g[P[j]];
			if(i%P[j]==0)break;
		}
	}
}

void solve(int step){
	init();
	read(T);
	
	while(T--){
		read(n);
		
		ans=0,has_two=false;
		
		for(int i=0;i<n;++i){
			read(p,q);
			if(p==2)has_two=true;
			ans+=g[p]*q;
		}
		if(!has_two)++ans;
		
		write(ans,'\n');
	}
}
/*
Input:

Output:

Outline:

*/
int main(){
	#ifdef DEBUG
	freopen("test.in","r",stdin);freopen("test.out","w",stdout);
	#endif
	#ifdef more_text
	read(T);
	#endif 
	for(int i=0;i<T;++i)solve(i);
	#ifdef DEBUG
	fclose(stdin);fclose(stdout);
	#endif
	return 0;
}
```

---

## 作者：Purslane (赞：1)

# Solution

给定正整数 $N$，问经过多少次 $N \leftarrow \varphi(N)$ 的迭代，能使 $N=1$。

--------

显然，除了 $1$ 和 $2$ 以外的正整数 $n$ 都满足 $2 \mid \varphi(n)$，因此我们可以追踪 $v_2(N)$。

注意每个素因子 $p$ 在迭代中**最终都会被除掉，并且乘以 $p-1$ 贡献进去**。

因此设 $p-1 = \prod x_i$，$x$ 为所有素数，则有：

$$
dp_p = \sum dp_{x_i}
$$

其中 $dp_2=1$。答案就是 $\sum q_i dp_{p_i}$。

然后你发现你寄了。原因很简单，当 $p_i$ 全都不是 $2$ 的时候，第一步并不会消耗任何的 $2$，这时候答案要加一。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1e5+10;
int T,n,flg[MAXN],dp[MAXN];
vector<int> pr;
int calc(int u) {
	int ans=0;
	ffor(i,2,u/i) while(u%i==0) ans+=dp[i],u/=i;
	if(u>1) ans+=dp[u];
	return ans;
}
void init(int mx) {
	dp[2]=1;
	ffor(i,2,mx) {
		if(!flg[i]) {
			if(i!=2) dp[i]=calc(i-1);
			pr.push_back(i);
		}
		for(auto v:pr) {
			if(i*v>mx) break ;
			flg[i*v]=1;
			if(i%v==0) break ;	
		}
	}
	return ;
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	init(100000);
	cin>>T;
	ffor(i,1,T) {
		cin>>n;
		int ans=1;
		ffor(i,1,n) {
			int p,q;
			cin>>p>>q,ans+=dp[p]*q;
			if(p==2) ans--;
		}
		cout<<ans<<'\n';
	}
	return 0;
}
```

---

## 作者：大眼仔Happy (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P2350)

# Solution

一道有趣的数学题。

观察题目性质。

- 当 $N=2^k$ 时，$\varphi(N)=2^{k-1}$，当 $N=2^k\times D$ 时（$2\perp D$），$\varphi(N)=2^{k-1}\times \varphi(D)$，总结就是每次迭代 $2$ 的次数只会减 $1$。

- 只有 $\varphi(2)=1$。

- $\varphi(N)$ 为偶数或 $1$。

发现迭代的过程中始终都有 $2$ 这个因子，所以我们换个思路，计算有多少个能迭代出多少个 $2$。设 $f_i$ 表示 $i$ 经过迭代最终有多少个 $2$，比如：

$$
7\xrightarrow{\varphi}6={\color{red}2_1}\times 3\xrightarrow{\varphi}{\color{red}2_2}\xrightarrow{\varphi}1
$$

$$
49\xrightarrow{\varphi}42={\color{red}2_1}\times 3\times 7\xrightarrow{\varphi}12={\color{red}2_2}\times {\color{red}2_3}\times 3\xrightarrow{\varphi}4={\color{red}2_3}\times {\color{red}2_4}\xrightarrow{\varphi}{\color{red}2_4}\xrightarrow{\varphi}1
$$

这里不是每次迭代之后有多少个 $2$，而是产生了新的多少个 $2$（我标了下标作为号码），所以 $f(49)=4$。

由上面性质我们可以得到 $f(a\times b)=f(a)+f(b)$，这对于任何的 $a,b\in \mathbb N^* $ 都成立，所以就可以先把 $f$ 筛出来。

注意特判 $N$ 是不是奇数，如果是的话，还要加上一次。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
#define ll long long
ll inline read()
{
	ll num=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){num=(num<<3)+(num<<1)+(ch^48);ch=getchar();}
	return num*f;
}
int T,n,tot;ll p,q,ans;
ll prime[N],f[N];bool vis[N];
void init()
{
	n=1e5;f[1]=1;
	for(int i=2;i<=n;i++)
	{
		if(!vis[i])prime[++tot]=i,f[i]=f[i-1];
		for(int j=1;i*prime[j]<=n;j++)
		{
			vis[i*prime[j]]=1;
			f[i*prime[j]]=f[i]+f[prime[j]];
			if(i%prime[j]==0)break;
		}
	}
}
void solve()
{
	n=read();ans=1;
	for(int i=1;i<=n;i++)
	{
		p=read(),q=read();
		ans+=(p&1?0:-1)+q*f[p];
	}
	printf("%lld\n",ans);
}
int main(){
	init();T=read();while(T--)solve();
	return 0;
}
```

---

## 作者：蒟蒻丁 (赞：1)

首先理解一下题意，就是说每次会给你一个数(被分解成其质因数乘积的形式)，求对它用几次欧拉函数能使其变成$1$  
例如样例 $N=2^2*3^1=12$   
$12->4->2->1$ 一共三次  
又发现题目给了这玩意  
$$\varphi(\prod_{i = 1}^m p_i^{q_i}) = \prod_{i = 1}^m (p_i - 1)*p_i^{q_i-1}$$
发现一个性质：每次操作就是将其除以其所有质因数之积，再乘上它们减一后的积
比如对于$N=60$时，一次操作就是$(60/5/6/2)*4*5*1$  
然后就发现,若$N$为合数，在每次操作中会(仅)使$N$中的一个$2$变为$1$
否则$N$会减一  
于是我们记录每个数中有几个$2$，比如说$5$，$5->4->2*2$这么看有两个$2$  
对于偶数，将其变为$1$的步数就是其$2$的个数  
否则还要减一，就像上面$5$的例子一样  
那么这个规律怎么和题目联系起来呢  
因为每次最多使一个$2$变为$1$，但是一个数"产出"$2$的回合数最多是$2$（还是看$5$的例子，$5$只需要一回合就能变成$2$的倍数）  
所以一定会有很多多余的$2$，那么我们就发现了，$N$变唯一的回合数就是把$2$都给搞定的回合数  
设$f$数组记录每个数能"生产"几个$2$
$$f[a]=f[a-1](a为质数)$$
$$f[a*b]=f[a]+f[b]$$
然后对于$N$，我们只需要知道它的质因子们会提供几个$2$，再按上面法则计算就好  
```
#include<iostream>
#include<cstdio>
#include<cstring>
#define ll long long 
using namespace std;
const ll N=2e5;
ll n,m,f[N],a[N],top,T,ans;
bool pook[N],pool;

int main(){
	f[1]=1;
	for(ll i=2;i<=1e5;i++){
		if(!pook[i]){
			f[i]=f[i-1],a[++top]=i;
		}
		for(ll j=1;j<=top&&i*a[j]<=1e5;j++){
			pook[a[j]*i]=1,f[a[j]*i]=f[a[j]]+f[i];
			if(i%a[j]==0)break;
		}
	}
	scanf("%lld",&T);
	while(T--){
		scanf("%lld",&n);
		pool=0,ans=1;
		for(ll i=1,a1,a2;i<=n;i++){
			scanf("%lld%lld",&a1,&a2);
			ans+=f[a1]*a2;
			if(a1==2)pool=1;
		}
		ans-=(pool==1);
		printf("%lld\n",ans);
	}
}
```

---

## 作者：tony0530 (赞：1)

# **题意**  
 这道题目的题意有一点点的歧义，$\varphi(N)^x=1$ 意思就是说把 $N$ 替换成 $\varphi(N)$ 替换 $x$ 次，最后为 $1$。
 

------------

# **思路**
不难发现，如果 $N=\prod_{i=1}^m{a_i^{b_i}}$，$\varphi(N)=\prod_{i=1}^m{(a_i-1)\times a_i^{b_i-1}}$。我们发现 $N$ 变小的过程是 $N$ 的因子变多，因子变小，发现 $N$ 的因子是一起变小的。所以,若 $N$ 为偶数,则分出的2的个数就是总操作数。（因为最后 $1$ 步是 $2$ 变成 $1$，而 **每次最多只有** $1$ 个 $2$ 变成 $1$，所以是对的），如果 $N$ 为奇数 ，那么第 $1$ 步没有 $2$ 变成 $1$，要往后顺延 $1$ 步，所以总操作数要加 $1$。

我们预处理一个函数 $f(i)$ 表示每个质因子一共会分出多少个 $2$，我们发现 $f(i)$ 可以分类讨论：

- 如果 $i$ 是质数(素数)，则 $f(i) = f(i-1)$；
- 如果 $i$ 是合数，则把 $i$ 分解成 $a\times b$，$f(i)=f(a)+f(b)$；

------------
# **代码**
打码不易，**请勿** `ctrl+C`。

本人蒟蒻，大佬勿喷。

```cpp

#include <bits/stdc++.h>

using namespace std;

const int N = 3e4 + 10;
const int M = 1e5 + 10;

int T, idx, m;
int ans, p[M], f[M];
bool st[M];

void init()
{
    f[1] = 1;
    for(int i = 2 ; i <= M - 10 ; i ++ )
    {
        if(st[i] == false)
        {
            p[++ idx] = i;
            f[i] = f[i - 1];
        }
        for(int j = 1 ; j <= idx && p[j] * i <= M - 10 ; j ++ )
        {
            st[p[j] * i] = true;
            f[p[j] * i] = f[p[j]] + f[i];
            if(i % p[j] == 0) break;
        }
    }
}
int main()
{
    init();
    cin >> T;
    while(T -- )
    {
        cin >> m;
        int ans = 1;
        for(int i = 1 ; i <= m ; i ++ )
        {
            int a, b;
            cin >> a >> b;
            if(!(a & 1ll)) ans -- ;//奇数加一
            ans += f[a] * b;
        }
        cout << ans << endl;
    }
    return 0;
}

```

---

## 作者：金爷爷哈哈 (赞：1)

看没有题解，蒟蒻过来凑凑热闹。

脑洞题

题目大意是 每次操作相当于n=phi(n),问将n变回1的操作次数。


我们注意到，只有phi(2)==1,同时对于 2^n，我们的操作次数是n。

而对于题目中的N，我们每进行一次操作，相当于把每一个 pi^qi变成了（pi-1）\*pi^(qi-1)。

因而因为大于2的质数都为奇数，所以每次操作至少会产生1个2的因子。

而如果每次操作之前pi中有2的话，也只会有一个被消除。


所以，问题转变成了求一个数N在操作过程中一共会产生多少个2（因为一轮可能产生很多2，但是最多只能消除一个）。

特例是如果一开始的p中没有2（第一次操作后面所有的p一定会包含2） ，答案要+1。


具体的代码实现在程序里有。


感觉数论的题就是不好想，代码还是挺好写的（不要和我说反演和杜教筛）


```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll phi[100005],f[100005],zs[100005],t=0;
bool v[100005];
ll n,m,p,q,x,opt,ans;
inline void init(){
    f[1]=1;
    for(ll i=2;i<=100000;i++){
        if(!v[i]) zs[++t]=i,f[i]=f[i-1];
        for(ll j=1,w;j<=t&&(w=zs[j]*i)<=100000;j++){
            v[w]=1; f[w]=f[zs[j]]+f[i];
            if(!(i%zs[j])) break;
        }
    }
}
int main(){
    init();
    scanf("%lld",&opt);
    while(opt--){
        scanf("%lld",&n);
        ans=1;
        for(ll i=1;i<=n;i++){
            scanf("%lld%lld",&p,&q);
            if(p==2) ans--;
            ans+=f[p]*q;
        }
        cout<<ans<<endl;
    }
    return 0;
}
```

---

## 作者：Creeper_l (赞：1)

很巧妙的一道题。

首先会发现如果最终 $\varphi(N)=1$ 的话一定是通过很多次从 $2$ 这个因子变到 $1$ 的。而这个函数每迭代一次，就会有且仅有一个 $2$ 的因子变为 $1$。所以题目转化为了求 $N$ 在函数迭代过程中一共会产生多少个 $2$ 的因子。

考虑 $\text{dp}$，设 $dp_i$ 表示 $i$ 这个数一共会产生多少个 $2$。

若 $i$ 是质数，那么 $dp_i=dp_{i-1}$（一次迭代）。否则 $dp_{i}=dp_{p}\times dp_{\frac{i}{p}}$（分成两次算）。所有数的 $dp$ 的值可以用线性筛 $O(V)$ 求出。

注意如果 $N$ 是奇数的话第一次迭代的时候不会有 $2$ 变为 $1$，答案要加一。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long 
const int MAXN = 1e5 + 10;
int T,n,p,q,dp[MAXN],prime[MAXN],cnt;
bool Not_prime[MAXN];
inline void Get_prime(int n)
{
	for(int i = 2;i <= n;i++)
	{
		if(!Not_prime[i]) prime[++cnt] = i,dp[i] = dp[i - 1];
		if(i == 2) dp[i] = 1;
		for(int j = 1;prime[j] * i <= n;j++)
		{
			Not_prime[prime[j] * i] = 1;
			dp[prime[j] * i] = dp[prime[j]] + dp[i];
			if(i % prime[j] == 0) break;
		}
	}
}
signed main()
{
	Get_prime(100000),cin >> T;
	while(T--)
	{
		cin >> n;int ans = 0;
		for(int i = 1;i <= n;i++) 
		{
			cin >> p >> q;
			ans += dp[p] * q - (p == 2);
		}
		cout << ans + 1 << endl; 
	}
	return 0;
} 
```


---

## 作者：rabbit_mygo (赞：0)

## 前言
模拟赛搬了这道题，赛时打表过了，提供一种**非正解**打表的思路。    
## 题目描述
给定正整数 $N$ 的质因数分解，求最少经过多少次 $\varphi(N)$ 的迭代，能使得 $N$ 为 $1$。  
## 解决思路 
首先有以下两个性质：  
1. 对于所有大于 $1$ 的正整数，其欧拉函数必然为偶数。  
2. 所有偶数的欧拉函数必然小于等于这个数的一半。  

第一点可以这么考虑，如果有 $\gcd(a,n)=1$，那么必然有 $\gcd(n-a,n)=1$，并且 $a=n-a$ 是必然不成立的（请自己思考），所以产生贡献的数是成对的。  
第二点是因为所有偶数的不产生贡献，所以必然缩小一半。  

所以如果暴力去递归，只需要约 $\log N$ 次就可以结束。  

接下来分别考虑每个质因数。  
记 $c_{p_i}$ 为质因数 $p_i$ 递归的最小次数，打表发现有规律 $c_{p_i^{k_i}} = c_{p_i}+(k_i-1) \cdot \max(1,c_{p_i}-1)$。  
所以我们可以计算出每个质因数的贡献。  

接下来合并每个质因数的贡献。  
打表发现 $c_{\prod_{i=1}^{n}p_i^{k_i}} = (\sum_{i=1}^{n} c_{p_i^{k_i}})-n+1$。  

那么就做完了。  

如果你对于每个质因数的最小递归次数加上记忆化，可以少一只 $\log$。  

时间复杂度 $O(Tm+L)$，其中 $T$ 为数据组数，$m$ 为质因数个数，$L$ 为质因数的最大值。  

## 代码实现

```cpp
#include <cstdio>
#include <algorithm>
#include <cmath>
#define gc()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<23],*p1=buf,*p2=buf;
typedef long long ll;
void output(ll x){
	if(x>9)output(x/10);
	putchar(x%10^48);
}
inline int readx(){
	int x = 0,y = 1;char c = gc();
	for(;c<48||c>58;c = gc())if(c=='-')y = -1;
	for(;c>=48&&c<=58;c = gc())x = (x<<1)+(x<<3)+(c^48);
	return x*y; 
} 
const int N = 1e5+10;
int ph[N],p[N],n,tot;
bool flg[N];
inline void getphi(){
	flg[1] = 1;
	ph[1] = 1;
	for(int i = 2;i < N;i++){
		if(!flg[i])p[++tot] = i,ph[i] = i-1;
		for(int j = 1;j <= tot;j++){
			int t = i*p[j];
			if(t>=N)break;
			flg[t] = 1;
			if(i%p[j])ph[t] = ph[i]*ph[p[j]];
			else{
				ph[t] = ph[i]*p[j];
				break;
			}
		}
	}
}
ll f[N];
ll solve(int x){
	if(x==1)return 0;
	if(f[x])return f[x];
	return f[x]=solve(ph[x])+1;
}
int a[N],c[N];
inline ll maxi(ll x,ll y){return x<y?y:x;}
inline ll cacl(ll p,ll c){
	ll a1 = solve(p),del = maxi(a1-1,1);
	return a1+(c-1)*del;
}
inline void init(){
	n = readx();
	for(int i = 1;i <= n;i++)a[i] = readx(),c[i] = readx();
}
inline void solve(){
	ll ans = 0;
	for(int i = 1;i <= n;i++)ans+=cacl(a[i],c[i]);
	output(ans-n+1),putchar('\n');
}
int main(){
	getphi();
	int T = readx();
	while(T--)init(),solve();
	return 0;
}
````

最后祝您：万事如意！（q'w'q）

---

## 作者：AIskeleton (赞：0)

> [P2350 [HAOI2012]外星人](https://www.luogu.com.cn/problem/P2350)

> 给定一个表示为 $\prod_{i=1}^m p_i^{q_i}$ 的数 $N$。
> 对于 $N$，求出 $x$ 满足 
$\begin{matrix}\underbrace{\varphi(\varphi(\varphi(\varphi(\dots \varphi(N) \dots))))}\\x\  \text{个}\  \varphi()\end{matrix}=1$。

根据题目中给出的提示： $\varphi\left( \prod_{i=1}^m p_i^{q_i} \right) = \prod_{i=1}^m \left( p_i - 1 \right) \times p_i^{q_i-1} $

用语言表述就是：对于每次 $\varphi(N)$ 的操作，相当于将 $N$ 先除以其**每一个质因数**，再乘以**每个质因数减一的值**最后得到的结果。

因为每次只能将**质因数减一**，所以最后使得乘积为 1 的情况就是质因数 2 减一得到 1，而每次只能将一个 2 转化。

所以最终的操作次数就是每个质因数能**拆出 2 的个数**（也就是对于一个数，如果是奇数就减一，如果是偶数就分解质因数，最后会有多少个 2）。

考虑进行 DP 预处理。

设 $f_i$ 表示的是 $i$ 能拆出 2 的个数，则有状态转移方程式：$\begin{cases}f_i=f_{i-1} \left(\gcd(i,j)=1 \right) \\ f_{x \times y}=f_x+f_y \end{cases}$

最后有一个细节点：如果一开始给出的质因数中没有 2，则需要进行一次操作之后才能分解出 2，此时要把最后的答案加一。
```cpp
#include <bits/stdc++.h>
using namespace std;int rd(){
	int w=0,v=1;char c=getchar();while(c<'0'||c>'9'){if(c=='-')v=-1;c=getchar();}
	while(c>='0'&&c<='9'){w=(w<<1)+(w<<3)+(c&15);c=getchar();}return w*v;
}const int N=1e5+5e4;int f[N],p[N],flag,T,n,tp,ans;bool is[N];
int main(){
	f[1]=1;for(int i=2;i<=100000;i++){
		if(!is[i])p[++tp]=i,f[i]=f[i-1];
		for(int j=1;j<=tp&&i*p[j]<=100000;j++){is[i*p[j]]=1,f[i*p[j]]=f[i]+f[p[j]];if(i==p[j])break;}
	}T=rd();while(T--){
		n=rd();ans=flag=0;for(int i=1,a,b;i<=n;i++){a=rd(),b=rd();if(a==2)flag=1;ans+=f[a]*b;}
		if(!flag)ans++;cout<<ans<<endl;
	}return 0;
}
```

---


# BZOJ3706 反色刷

## 题目描述

给定 $n$ 个点，$m$ 条边的无向图，边有黑白两种颜色。现在你可以进行若干次回路反色操作，每次操作从任意点出发，每经过一条边，将其颜色反转，最后回到起点。判断能否通过若干次操作，使这张图所有边都变成白色。

因为某种原因，边的颜色是会改变的，即你相当于需要支持以下两种操作：
- `1 x` 将第 $x$ 条边反色（边的编号为 $0\sim m-1$）；
- `2` 求出最少操作次数；

## 说明/提示

数据保证，$1\leq n,m,q \leq 1000000$，$c < 2$，没有重边自环。

## 样例 #1

### 输入

```
6 6
1 2 1
2 3 1
1 3 1
4 5 1
5 6 1
4 6 1
14
2
1 0
2
1 1
1 2
2
1 3
1 4
1 5
2
1 3
1 4
1 5
2```

### 输出

```
2
-1
1
0
1```

# 题解

## 作者：Betrayer_of_love (赞：5)

### 题意：

---

给一张无向图，边有黑白两种颜色，现在你有一堆反色刷，可以从任意点开始刷，经过若干条边后回到起点。

现在要询问至少需要多少个反色刷可以使这张图所有边都变成白色。
因为某种原因，边的颜色是会改变的，于是……

需要支持以下操作：

1. 把第 $x$ 反色（编号从 $0 \to m-1$）
2. 询问当前图中最少需要多少个反色刷，$n,m,q \le 1000000,c<2$，没有重边自环。

### 分析：

---

一开始就往 dfs 树上去想了，所以没有想到可以用欧拉回路来做。

首先有一个结论，就是对于一个连通块而言，如果每个点连接的黑边数量均为偶数，则有解，反之则必然无解。
这个结论可以用欧拉回路很容易地证明。

还有一个结论就是，若有解，则答案必然等于有黑边的连通块个数。

自己yy出的一个证明就是，你考虑把dfs树构出来，那么每走过一条返祖边，便会对该环上的边的颜色造成影响，反之则不造成影响。显然若我们选出了若干条返祖边，则是可以一次走完的。

题解的证明：首先构造一个可行解，随便找一个有黑度的点，随便走向一个连出的黑边，一直走，直到回到这个点为止（显然一定会回到这个点）。现在考虑在同一个联通块的两个可行路径，设两个路径分别为 $u \to \dots \to u$ 和 $v \to \dots \to v$，他们的起点必然联通，设这段路径为$u_v$，则这两个路径可以合并为 $u \to u_v \to \dots \to v \to u_v \to u \to \dots \to u$。最后一个联通块的所有路径可以合并为一个，证毕。

### CODE：

---


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1000005;
int n,m,f[N],d[N],bla[N];
struct edge{int x,y,c;}e[N];
int read(){
    int x=0,f=1;char ch=getchar();
    while (ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while (ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
} 
int fin(int x){
    if (f[x]==x) return x;
    else return f[x]=fin(f[x]);
}
int main(){
    n=read();m=read();
    for (int i=1;i<=n;i++) f[i]=i;
    int now=0;
    for (int i=1;i<=m;i++){
        int x=read(),y=read(),z=read();
        e[i].x=x;e[i].y=y;e[i].c=z;
        if (z) now-=d[x]+d[y],d[x]^=1,d[y]^=1,now+=d[x]+d[y];
        if (fin(x)!=fin(y)) f[fin(x)]=fin(y);
    }
    int cnt=0;
    for (int i=1;i<=m;i++)
        if (e[i].c){
            int x=fin(e[i].x);
            if (!bla[x]) cnt++;
            bla[x]++;
        }
    int q=read();
    while (q--){
        int op=read();
        if (op==2) printf("%d\n",now?-1:cnt);
        else{
            int x=read()+1;
            now-=d[e[x].x]+d[e[x].y];d[e[x].x]^=1;d[e[x].y]^=1;now+=d[e[x].x]+d[e[x].y];
            if (e[x].c){
                e[x].c=0;
                bla[fin(e[x].x)]--;
                if (!bla[fin(e[x].x)]) cnt--;
            }else{
                e[x].c=1;
                if (!bla[fin(e[x].x)]) cnt++;
                bla[fin(e[x].x)]++;
            }
        }
    }
    return 0;
} 
```


**完结撒花，谢谢！！！**

---

## 作者：Argon_Cube (赞：4)

萌新半个月没做题了，来做个简单题防止大脑萎缩。

以下我们将一个点所连的黑色边条数称为**度数**。因为白边是无关紧要的。

首先注意到如果有解，一个连通块至多只需要一次操作。如果有两次操作，先走第一个环，然后跑到第二个环上的随便一个点，走第二个环，然后原路返回，就把两个小环合并成了一个大环。

于是我们只需要判断是否有解。

> **Key Observation**：一个图有解等价于每个点的度数都是偶数。

**Proof**：可以发现，无论选的是什么环，对于环上的每一个点都要进一次出一次，这样对于每个点度数的奇偶性是不影响的，因为目标状态所有点的度数都是 $0$，初始状态所有点的度数也要是偶数。这样就证了充分性。

如果一个图每个点的度数都是偶数，那么只保留黑边时这个图的每个连通分量都是欧拉图，直接将操作设为每个连通分量的欧拉回路即可。这样就证了必要性。

---

于是我们只需要维护度数为奇数的点的个数和包含黑边的连通块个数即可。显然可以 $\Omicron(n+m+q)$。

```cpp
#include <algorithm>
#include <iostream>
#include <vector>
#include <string>
#include <bitset>
#include <array>

using namespace std;

array<pair<int,int>,1000000> edges;
array<int,1000001> cntbs,dsu;
bitset<1000001> degs,cols;

int get_root(int u)
{
	return dsu[u]==u?u:dsu[u]=get_root(dsu[u]);
}

int main(int argc,char* argv[],char* envp[])
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int cnt,cnte;
	cin>>cnt>>cnte;
	for(int i=1;i<=cnt;i++)
		dsu[i]=i;
	for(int i=0;i<cnte;i++)
	{
		int u,v;
		bool col;
		cin>>u>>v>>col,dsu[u]=get_root(v);
		cols[i]=col,degs[u]=degs[u]^col,degs[v]=degs[v]^col,edges[i]=make_pair(u,v);
	}
	for(int i=0;i<cnte;i++)
		cntbs[get_root(edges[i].first)]+=cols[i];
	int cntq,answer=0,cntn=degs.count();
	for(int i=1;i<=cnt;i++)
		answer+=(bool)cntbs[i];
	cin>>cntq;
	while(cntq--)
		if(cin>>dsu[0],dsu[0]&1)
		{
			int a,u,v;
			cin>>a,u=get_root(edges[a].first);
			answer+=!cntbs[u];
			cntbs[u]-=cols[a]-!cols[a],cols.flip(a);
			answer-=!cntbs[u];
			degs.flip(u=edges[a].first),degs.flip(v=edges[a].second);
			cntn+=degs[u]+degs[v]-!degs[u]-!degs[v];
		}
		else
			cout<<(cntn?-1:answer)<<'\n';
	return 0;
}

```

---

## 作者：luoxb (赞：2)

# 题意分析

## 题面

无向图上有若干连通块。

对每个连通块考虑操作：从任意起点出发最终回到起点，每次途径一条边将该边反色。

最后问是否能让所有黑边染成白边。

---

## 分析

首先走一条链然后从同一条链回来显然是无效的，换句话说，走到最远点的路和回到起点的路必然不一样。再换句话说，每次操作的路径是 **带环的**。

那么接着我们从一些特殊的情况入手，对于下图所示的连通块：

![](https://cdn.luogu.com.cn/upload/image_hosting/bu2pa7pz.png)

- 如果从最左端出发走到环里然后回到最左端，可以发现，有一条链上被我们走了两次，是完全无效的，也就是说这次操作完全等效于在环里面走了一圈。

也就是说，我们的操作路径必然包含简单环，因为链上操作必然是无效的，只有简单环上的操作有贡献。

- 分析得出结论，我们能够将一个环的所有边染成白色，当且仅当该环所有边均为黑边。

那么回到更一般的表述：对于一次操作我们走过了这个连通块的一个简单环子图，能够将其所有边染成白色，当且仅当其所有黑边被走过一次且最终回到起点。

熟悉吗？这其实就是 **欧拉回路** 的定义，只不过我们忽略了全部白边。

也就是说对于一个子图，如果其所有黑边都包含于一条欧拉回路中，说明该子图可解。

- 回到整个连通块，如果包含 $s$ 个满足条件的子图，是不是意味着该连通块的贡献是 $s$ 呢？

最开始的时候我们分析过链上操作是无效的，而每个有效的子图又必然是简单环，连接简单环的不就是链吗？

链上操作没有贡献，也就意味着我们可以从起点出发走过一个简单环回到起点，然后再走链去另外一个简单环… 最后我们回到一开始的起点，所有环都被走过，而所有链上操作均无效。也就是说一个连通块要么违法，要么一步即可染色。

而链又不可能是欧拉回路，因此，我们只需要判断每个连通块是否满足欧拉回路条件，即可完成本题。

# 实现

## 小记

因为做了很多特判和答案维护，代码是比较冗长的，但整体思路正确。重点在于如果一个连通块全部都是白边，那么该连通块虽然满足条件，但是不计入答案。

---

```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAX = 2e6+2;
int n,m,q,a,b,c;
int vis[MAX],bucket[MAX],blackCnt[MAX],setBlackCnt[MAX];

int nxt[MAX],head[MAX],to[MAX],color[MAX],cnt;
void add(int u,int v,int c){
	to[++cnt] = v;
	nxt[cnt] = head[u];
	head[u] = cnt;
	color[cnt] = c;
}

int fa[MAX],sign[MAX],whiteCnt,ans,outerAns;
int find(int u){
	if (fa[u] == u) return u;
	return fa[u] = find(fa[u]);
}

int dfs(int u){
	vis[u] = true;
	blackCnt[u] = 0;
	for (int i=head[u];i;i=nxt[i])
		blackCnt[u] += color[i];
	int rtn = blackCnt[u]%2;
	setBlackCnt[find(u)] += blackCnt[u];
	
	for (int i=head[u];i;i=nxt[i]){
		int v = to[i];
		if (vis[v]) continue;
		rtn += dfs(v);
	}
	
	return rtn;
}

void update(int side,int us){
	int v = to[side];
	
	if (blackCnt[v]%2) sign[us]--;
	else sign[us]++;
	
	if (color[side]) blackCnt[v] --,setBlackCnt[us] --;
	else blackCnt[v] ++,setBlackCnt[us] ++;
	
	color[side] = (color[side]+1)%2;
}

int main(){
	cin>>n>>m;
	for (int i=1;i<=n;i++) fa[i] = i;
	for (int i=0;i<m;i++) {
		cin>>a>>b>>c;
		add(a,b,c);
		add(b,a,c);
		fa[find(a)] = find(b);
	}
	
	for (int i=1;i<=n;i++){
		if (vis[i]) continue;
		sign[find(i)] = dfs(i);//违法数量
	}
	
	for (int i=1;i<=n;i++){
		int u = find(i);
		if (bucket[u]) continue;
		bucket[u] = true;
		if (sign[u]) outerAns++;//违法集合数量
		else ans++;//合法集合数量

        if (!setBlackCnt[u]) whiteCnt++;
	}
	
	cin>>q;
	for (int t=0;t<q;t++){
		cin>>a;
		if (a == 2){
			if (outerAns) cout<<-1<<'\n';
			else cout<<ans-whiteCnt<<'\n';
		}
		else{
			cin>>b;
			int s = find(to[b*2+1]);
			int tmp = sign[s];
			int tmpWhite = setBlackCnt[s];
			
			update(b*2+1,s);
			update(b*2+2,s);
			
			if (tmp && !sign[s]) {
				outerAns--;
				ans++;
			}
			if (!tmp && sign[s]) {
				outerAns++;
				ans--;
			}
			if (tmpWhite && !setBlackCnt[s]) whiteCnt++;
			if (!tmpWhite && setBlackCnt[s]) whiteCnt--;
		}
	}
	
	return 0;
}
```

---

## 作者：JHPOTATO (赞：2)

首先先进行存在性判定，由于要走奇数次黑边，偶数次白边，所以只有黑边会改变节点度数的奇偶性，所以不妨先只连黑边，如果出现度数为奇数的节点，那么一定无解。因为题目要求只能从一个点出发并且最终返回这个节点，那么遍历过程中每个点的进边和出边数量一定相同，也就一定不会改变其度数的奇偶性，所以度数为奇数的点最后度数一定无法变为零，一定无解。

然后考虑度数全为偶数的情况，显然可以发现连通块之间互不干扰，那么我们对每个连通块进行分析，我们可以把块中的白边当作两条边加入，加入后节点度数奇偶性不受影响，并且添加完边后块内一定联通，根据欧拉回路的性质，我们一定能做到从一个点开始不重复地走过这些边，并最终回到这个点。也就是说每个块对答案的贡献不超过 $1$，而显然只有在块内全是白点时贡献为 $0$，这个我们可以特判解决。

修改操作也很简单，直接修改这条边对应点的度数，相应地修改答案，单次操作复杂度可以控制在 $O(1)$ 时间内完成。

初始化用并查集解决，总复杂度 $O(n\log_{2}{n} )$。

代码很丑。

```cpp
#include<bits/stdc++.h>
using namespace std;
template <typename T>
void in(T &x){
	char c=getchar(), f=1;
	while ((c<'0' || c>'9') && c!='-') c=getchar();
	if (c=='-') f=-1, c=getchar();
	for (x=0; c>='0' && c<='9'; c=getchar())
		x=x*10+c-'0';
	x*=f;
}
const int N=1e6+5;
struct node{
	int u,v,col;
}eg[N];
int n,m,fa[N],du[N],q,opt,x,ans,al,sz[N],f[N],g[N];
int find(int x){
	if(fa[x]==x)return x;
	return fa[x]=find(fa[x]);
}
void merge(int x,int y){
	int x1=find(x),y1=find(y);
	if(x1==y1)return ;
	fa[x1]=y1;
	sz[y1]+=sz[x1];
}
int main(){
//	freopen("P10777.in","r",stdin);
//	freopen("P10777.out","w",stdout);
	in(n);in(m);
	for(int i=1;i<=n;i++)fa[i]=i,sz[i]=1;;
	for(int i=1;i<=m;i++){
		in(eg[i].u);in(eg[i].v);in(eg[i].col);
		if(eg[i].col==1){du[eg[i].u]++;du[eg[i].v]++;}
		merge(eg[i].u,eg[i].v);
	}
	for(int i=1;i<=n;i++){
		al+=du[i]&1;
		g[find(i)]+=du[i]==0;
	}
	for(int i=1;i<=n;i++){
		if(!f[find(i)]){
			f[find(i)]=1;
			ans++;
			if(g[find(i)]==sz[find(i)])ans--;
		}
	}
	in(q);
	while(q--){
		in(opt);
		if(opt==1){
			in(x);x++;
			if(eg[x].col==1){
				du[eg[x].u]--,du[eg[x].v]--;
				if(du[eg[x].u]==0){
					g[find(eg[x].u)]++;
				}
				if(du[eg[x].v]==0){
					g[find(eg[x].u)]++;
				}
				if(g[find(eg[x].u)]==sz[find(eg[x].u)])ans--;
			}
			else{
				du[eg[x].u]++,du[eg[x].v]++;
				if(du[eg[x].u]==1){
					if(g[find(eg[x].u)]==sz[find(eg[x].u)])ans++;
					g[find(eg[x].u)]--;

				}
				if(du[eg[x].v]==1){
					g[find(eg[x].u)]--;
				}
			}
			if(du[eg[x].u]&1)al++;
			else al--;
			if(du[eg[x].v]&1)al++;
			else al--;
			eg[x].col^=1;
		}
		if(opt==2){
			if(al)printf("-1\n");
			else printf("%d\n",ans);
		}
	}
	return 0;
}
/*
按连通块考虑
一次操作,因为一定有进有出,而且要求起点和终点相同,所以度数的奇偶性不变化
把黑边对度数的贡献记为1,白边贡献记为0
有度数为奇数的点直接输出无解

那么此时度数全为偶数,把白边当作两条相同的边加入,显然不影响度数的奇偶性,
而且由于这是一个连通块,当把所有白边都加入后,局部一定是联通图
根据欧拉回路的性质,一定可以以任意一个块内点为起点,不重复地走完这些边
因此把一个联通块全刷成白色至多需要一次操作
还可以发现,只有在该连通块内的边全为白色时,不需要进行操作,这个可以特判

那么我们只需要在进行每次操作1时,修改这条边所连两个点的度数信息,进而更新答案即可
*/
```

---

## 作者：Unnamed114514 (赞：0)

判断是否有解时，白边显然是没用的，因此提取出只有黑边的图。

因为每次走的都是欧拉回路，那么有解的充要条件就是每个点的度数为偶数。

然后这里我想歪了，以为是只有黑边的图的连通块数。

其实不然，你会发现同一个整个图的连通块里的不同黑边连通块是可以一起选的。

比如有两个连通块 $A,B$，因为其中任意点都可以作为欧拉回路的起点，我们从里面取 $a,b$ 作为各自欧拉回路的起点，那么我们跑完 $a$ 后跑到 $b$，跑完 $b$ 后回到 $a$，发现 $a,b$ 之间的白边是遍历了偶数次的，不影响最后的可行性。

因此一个连通块内的黑边是可以一次性跑完的。

所以答案就是有黑边的连通块的数量。

---

## 作者：DeepSeaSpray (赞：0)

# LGP10777 BZOJ3706 反色刷

对于一个连通块，如果不存在黑边度数为奇数的点，那么一定可以把所有边都刷成白色。

证明，我们提出所有的黑边，构成一些连通块，这些点的度数都是偶数，通过欧拉回路即证。

接着我们证明对于每一个这样的连通块，我们总可以一次刷完。

上面证明了对于每一个黑边连通块，我们都可以一次刷完。在原图的一个连通块中，对于两个黑边连通块，我们都可以找到一条路径走过去，然后再走回来。所以我们一定可以一次刷完。

接下来就是简单统计。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6;
int n,m,q;
int U[maxn+5],V[maxn+5],W[maxn+5];
int fa[maxn+5];
int dg[maxn+5];
int cnt[maxn+5];
int ans,tot;
int Root(int u){
	if(fa[u]) return fa[u]=Root(fa[u]);
	else return u;
}
inline void Solve(int u,int v){
	if(dg[u]){
		if(v>0) ans+=!cnt[Root(u)];
		cnt[Root(u)]+=v;
		if(v<0) ans-=!cnt[Root(u)];
	}
	if(dg[u]&1) tot+=v;
}
signed main(){
	int u,v,w;
	scanf("%d%d",&n,&m);
	for(int i=0;i<m;i++){
		scanf("%d%d%d",&u,&v,&w);
		U[i]=u,V[i]=v,W[i]=w;
		dg[u]+=w,dg[v]+=w;
		u=Root(u),v=Root(v);
		if(u==v) continue;
		fa[u]=v;
	}
	for(int i=1;i<=n;i++) Solve(i,+1);
	int op,x;
	scanf("%d",&q);
	while(q--){
		scanf("%d",&op);
		if(op==1){
			scanf("%d",&x);
			u=U[x],v=V[x],w=W[x];
			W[x]^=1;
			Solve(u,-1),Solve(v,-1);
			if(w) dg[u]--,dg[v]--;
			else dg[u]++,dg[v]++;
			Solve(u,+1),Solve(v,+1);
		}
		else{
			if(tot) puts("-1");
			else printf("%d\n",ans);
		}
	}
	return 0;
}
```

---


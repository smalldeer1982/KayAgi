# [COTS 2022] 帽子 Šeširi

## 题目背景

译自 [Izborne Pripreme 2022 (Croatian IOI/CEOI Team Selection)](https://hsin.hr/pripreme2022/) D1T3。$\texttt{3s,0.5G}$。

喜欢小圆！



## 题目描述

$N$ 个 OIer 头上戴着红色或者白色的帽子。每个人只能看到别人的帽子颜色，他们会根据别人的帽子颜色猜测自己头上帽子的颜色。

他们想要构造一组猜测策略，满足以下条件：

- 设有 $b$ 人戴了白色帽子，其中**至少**有 $\lfloor\frac{b}{2}\rfloor$ 人猜对自己帽子的颜色。
- 设有 $c$ 人戴了红色帽子，其中**至少**有 $\lfloor\frac{c}{2}\rfloor$ 人猜对自己帽子的颜色。

请帮助他们找到一种策略，使得在 $2^N$ 种可能的情况中都满足条件。

## 说明/提示


#### 样例解释

以样例 $2$ 为例。

当 $s=\texttt{CCC}$ 时，对于第 $1$ 个 OIer，$x=\texttt{BBCC}$，$y=\texttt{CC}$。显然 $f(y)=4$，所以他会猜测 $x_4=\texttt{C}$。

#### 计分方式

| 测试点编号 | $N=$ | 分值 |
|:-----:|:------:|:-------:|
| $1$  | $4$  | $7$  |
| $2$  | $5$  | $7$  |
| $3$  | $6$  | $7$  |
| $4$  | $7$  | $7$  |
| $5$  | $8$  | $7$  |
| $6$  | $9$  | $7$  |
| $7$  | $10$  | $7$  |
| $8$  | $11$  | $7$  |
| $9$  | $12$  | $7$  |
| $10$  | $13$  | $7$  |
| $11$  | $14$  | $6$  |
| $12$  | $15$  | $6$  |
| $13$  | $16$  | $6$  |
| $14$  | $17$  | $6$  |
| $15$  | $18$  | $6$  |



## 样例 #1

### 输入

```
2```

### 输出

```
BC
CC```

## 样例 #2

### 输入

```
3```

### 输出

```
BBCC
BCBC
BBCC```

# 题解

## 作者：vzcx_host (赞：14)

写一个可以在现实中使用的策略。

本题解中将选手分别编号为 $0\sim n-1$。

假设 $0$ 猜 $\verb|B|$，对于 $1$ 来说，他知道 $0$ 会猜 $\verb|B|$，所以他不管怎样都会猜 $\verb|C|$，因为在这种状态下，即使两个人都猜错也满足下取整条件。

那么考虑 $2$，如果 $0$ 和 $1$ 都猜错，他自己必须要猜对，然而在没有别的信息的情况下，他无论如何都不可能百分百猜对。所以我们回头，让 $0$ 去猜 $2$ 的颜色，这样 $2$ 只需要在猜 $0$ 相反的颜色，在 $0$ 和 $1$ 都猜错的前提下 $2$ 一定会猜对。

考虑 $3$，如果 $0$ 和 $1$ 猜错 $2$ 猜对，$2$ 相反的颜色还卡在奇数下取整，所以 $3$ 只能猜这个颜色。如果 $2,3$ 颜色相反，$3$ 猜对，$0,1,2,3$ 猜测互相抵消；如果 $2,3$ 颜色相同，$3$ 猜错，两种颜色全部回到奇数下取整，此时 $4$ 无法准确地猜颜色。

但是 $0,1$ 是知道 $2,3$ 颜色的，如果他们看到 $2,3$ 颜色相同，他们知道给 $2,3$ 提供信息无法抵消他们的错误猜测，而如果某一对选手颜色相同，只要他们猜的是相反的，他们就必定一对一错，不需要在意他们接收到的信息是不是对的。所以 $0,1$ 会去找后面第一对颜色不同的选手去和他们配合，而他们也看得到他们和 $0,1$ 中间所有的选手对颜色相同，他们知道自己在和 $0,1$ 配合。

到这里做法就很显然了，将选手两两分组，每组选手组内的猜测不同。对于某一组选手，如果他前面有奇数对异色对，尝试和最后一组选手配合；否则，尝试和后面第一对异色对配合。

如果 $n$ 是奇数，将多余的选手视为一对异色对即可。

一组同色对必定一对一错，两组配合的异色对必定一组全对一组全错，最多会多出一组异色对，此时刚好取到奇数下取整，整个做法完全正确。

---

## 作者：I_am_Accepted (赞：3)

[enucai](https://www.luogu.com.cn/user/169574)，神。

首先题意至少 $\lfloor\frac{n}{2}\rfloor$ 个对，想到欧拉回路，建虚点后能使每个点出入度差至多为 $1$。

也就是说，每个点是一个错误数计数，每条无向边代表两边的计数恰好有一个会 $+1$。

开 $2\times 2^n$ 个点，分别表示真实的帽子状态以及计数白帽还是红帽的错误。

任意二进制第 $i$ 位为 $0$ 的数 $S<2^n$，我们连边 $(0,S)\leftrightarrow(1,S+2^i)$，表示要么选白帽子让红帽子错要么反过来。

建一个虚点连接所有奇度点，每个连通块跑欧拉回路即可。

---

## 作者：DaiRuiChen007 (赞：2)

[Problem Link](https://www.luogu.com.cn/problem/P10873)

**题目大意**

> 给 $n$ 个人，每个人的帽子为黑色或白色，每个人可以看到其他人的帽子颜色。
>
> 你要为每个人确定一组猜自己头上帽子颜色的策略，使得任何情况下，如果当前有 $k$ 个戴黑帽子的人，那么其中猜对自己帽子颜色的人不少于 $\lfloor k/2\rfloor$ 个，戴白帽子且猜对的人不少于 $\lfloor(n-k)/2\rfloor$ 个。
>
> 数据范围：$n\le 18$。

**思路分析**

从一个简化的问题的开始，如果想让猜对自己帽子颜色的人总数不少于 $\lfloor n/2\rfloor$ 怎么做。

考虑帽子为黑色的人的集合 $S$，对于某个人 $i$，设 $i\not\in S$，他在 $S$ 和 $S+\{i\}$ 中只能猜对一个。

因此我们可以将 $S$ 和 $S+\{i\}$ 连一条边，并对整张图定向，如果最终图中的边是 $S\to S+\{i\}$，就在当前状态下猜测帽子颜色为白，否则猜测黑。

那么对于每种状态，猜对的人等于其出度，要求就是每个点出度至少为入度 $-1$。

这是经典欧拉回路模型，把所有度数为奇数的点向一个虚点连边，求出欧拉回路后每个点出度与入度之差 $\in[-1,1]$。

但这题要对黑帽子的人和白脑子的人分别限制，那么拆点表示两个限制，连边 $(S,0),(S+\{i\},1)$ 即可。

时间复杂度 $\mathcal O(n^22^n)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=6e5+5,MAXM=1e7+5;
struct Edge { int v,id,x; };
vector <Edge> G[MAXN];
bool vis[MAXM];
string S[20];
int n,m,cur[MAXN];
int ns(int s,int x) {
	int t=0;
	for(int i=0;i<n;++i) if(i^x) t=t<<1|(s>>i&1);
	return t;
}
void dfs(int u) {
	for(int &i=cur[u];i<(int)G[u].size();++i) {
		Edge e=G[u][i];
		if(vis[e.id]) continue;
		vis[e.id]=true,dfs(e.v);
		if(~e.x) S[e.x][ns(u,e.x)]="BC"[u>>e.x&1];
	}
}
signed main() {
	ios::sync_with_stdio(false);
	cin>>n;
	for(int i=0;i<n;++i) S[i]=string(1<<(n-1),'.');
	int U=(1<<n);
	for(int s=0;s<U;++s) for(int i=0;i<n;++i) if(s>>i&1) {
		G[s|U].push_back({s^(1<<i),m,i}),G[s^(1<<i)].push_back({s|U,m,i}),++m;
	}
	for(int s=0;s<2*U;++s) if(G[s].size()&1) {
		G[s].push_back({2*U,m,-1}),G[1<<n].push_back({2*U,m,-1}),++m;
	}
	for(int i=0;i<=2*U;++i) dfs(i);
	for(int i=0;i<n;++i) cout<<S[i]<<"\n";
	return 0;
}
```

---

## 作者：takanashi_mifuru (赞：2)

帽皇来猜帽子。

我们希望至少有一半的红帽子能够猜对红色，至少一半的蓝帽子能够猜对蓝色，这两个必须分别考虑，所以我们考虑把每个状态裂成两半，左边表示红色，右边表示蓝色，则对于一个点，枚举他看到的状态 $S_0$，则对于 $S_0$，他选红正确的状态 为 $S_1$，他选蓝正确的状态为 $S_2$，考虑左部的 $S_1$ 向右部的 $S_2$ 连边，决策形如定向，那么一个点定向后有多少出边就意味着这个状态会被猜对多少个。

我们希望出边数量至少占总边数的一半，那我们就放缩成恰好占总边数的一半，容易发现这个东西变成了欧拉回路。

但是肯定是有奇点的，怎么办呢？

容易发现我直接在上面跑，跑出来就算有些许边的定向错误，误差也仅仅只有 $1$，这是可以接受的（如果是奇数的话在向下取整条件下仍然有效）。

于是我们在 $O(n2^n)$ 的时间复杂度内解决了本题，可喜可贺，可喜可贺！

---

## 作者：xxgirlxx (赞：1)

好玩。

同一场的 [P10871](https://www.luogu.com.cn/problem/P10871) 和 [P10872](https://www.luogu.com.cn/problem/P10872) 也好玩，可以去看看。

经过大量的手玩可以发现一些性质。

首先，每个情况下每个部分猜对的个数必须至少是这个部分的个数除以二下取整，除以二可以想到对半分，下取整则可以想到对的数量是错的数量或错的数量减一，看成边就是入边的数量是出边的数量减 $0$ 或 $1$。并定义入边为猜对，出边为猜错。

但是我们刚开始肯定不知道是入边还是出边，所以先连成无向图，这样就可以看成给所有边定向使所有点的入边的数量是出边的数量减 $0$ 或 $1$，然后考虑怎么把这个图建出来，会发现对于两种情况 $a,b$，如果 $a$ 和 $b$ 之间只有一位是不同的，那么对于这个位置的上的人，就无法判断自己的帽子颜色，那么就给这两个状态连边，但是因为我们要分是猜红色还是猜白色，所以每个状态拆成两个，分别搞红色和白色，然后红色的 $a$ 和白色的 $b$ 连就可以了（红色的 $b$ 和白色的 $a$ 会在给状态 $b$ 搞匹配的时候连上），然后你会得到一个图，但是不保证联通。

再发现希望是入边的数量是出边数量减 $0$ 或 $1$ 可以联想到 [欧拉路径](https://www.luogu.com.cn/problem/P7771)（但是不要求字典序最小），但是会发现度数为奇数的结点可能会很多，所以我们可以搞出一个虚点，把所有度数为奇数的点连到这个虚点上，然后就可以跑欧拉路径了，但注意这里整个图不一定联通，所以每个连通块都要跑，带虚点的连通块如果你不放心可以直接从虚点跑（虽然可以发现度数为奇数的点的编号取反后也是度数为奇数的点所以奇数的点都是成对出现的因此虚点的度数一定是偶数所以不一定要从虚点跑）。

跑完后处理一下定下的方向就可以改成方案输出了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,cnt,fst[1000010];
char ans[20][500010];
bool a[10000010],vis[10000010];
struct node{
	int to,vl;
};
vector<node>e[1000010];
void dfs(int x){
	for(int i=fst[x];i<e[x].size();i=fst[x]){
		fst[x]=i+1;
		if(vis[e[x][i].vl]==0){
			vis[e[x][i].vl]=1;
			a[e[x][i].vl]=(x>>n);
			dfs(e[x][i].to);
		}
	}
}
int main(){
	cin>>n;
	for(int i=0;i<n;i++){
		for(int j=0;j<(1<<n);j++){
			if(!((j>>i)&1)){
				e[j].push_back({j+(1<<i)+(1<<n),++cnt});
				e[j+(1<<i)+(1<<n)].push_back({j,cnt});
			}
		}
	}
	for(int i=0;i<(1<<n+1);i++){
		if(e[i].size()&1){
			e[i].push_back({1<<n+1,++cnt});
			e[1<<n+1].push_back({i,cnt});
		}
	}
	for(int i=0;i<=(1<<n+1);i++)dfs(i);
	for(int i=0;i<n;i++){
		for(int j=0;j<(1<<n-1);j++)cout<<(char)('B'+a[(n-1-i)*(1<<n-1)+j+1]);
		cout<<"\n";
	}
	return 0;
}
```

---


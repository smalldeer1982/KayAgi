# 一首诗

## 题目背景

题目描述最后有形式化题意。

## 题目描述

文学大师 ZHY 创作了一首诗。

这首诗由 $n$ 个单词组成，为了方便表述，ZHY 将这首诗记录为一个长度为 $n$ 的整数序列 $a_1,a_2,\dots,a_n$。创作完后，ZHY 立刻将自己的作品分享给了 YHZ。YHZ 在感受到了诗歌之美后，希望借此提高一下自己的文学素养，于是准备对这首诗中的诗句进行摘抄。

YHZ 认为一个“诗句”，应该是 $a_1,a_2,\dots,a_n$ 的一个**连续**子序列，诗句的长度即为子序列的长度。当然，他不会摘抄所有的诗句，而是只选择“优美的诗句”进行摘抄。由于不懂文法，YHZ 简单地认为一个诗句是“优美的”，当且仅当这个诗句中不存在两个**相邻**的重复单词。形式化的说，一个连续子序列 $a_l,a_{l+1},\dots,a_r$（$l\leq r$）组成的诗句是“优美的”，当且仅当对于所有的 $l\leq i<r$，有 $a_i\neq a_{i+1}$。

YHZ 发现文学大师 ZHY 写的诗里优美的诗句太多了，所以他需要进行归类。不过还是由于他不懂文法，他希望直接按照句子的长度归类。记 $b_i$ 为长度为 $i$ 的优美的诗句的个数，YHZ 希望知道 $b_1,b_2,\dots,b_n$。但即使是所有的 $b$ 数量也太多了，所以他只需要知道 $b_1\oplus b_2\oplus\dots\oplus b_n$。

还没等 YHZ 摘抄结束，文学大师 ZHY 告诉 YHZ 他要进行 $Q$ 次润色。具体地，每次润色，ZHY 会选择一个诗句 $[l_i,r_i]$ 和一个整数 $x_i$，并对所有的 $l_i\leq j\leq r_i$，将单词 $a_j$ 修改为 $a_j+x_i$。好学的 YHZ 希望对每次润色后的诗歌进行摘抄，即对于每次修改后的 $a_1,a_2\dots,a_n$，知道 $b_1\oplus b_2\oplus\dots\oplus b_n$。

不过文学大师 ZHY 太卷了，他进行的润色次数太多了，YHZ 还是承受不了这么大的工作量，所以他希望你帮帮他。

**形式化题面：**

给定一个序列 $a_{1\sim n}$，定义 $b_i$ 表示 $a$ 中有多少个长度为 $i$ 的区间使得任意两个相邻的数都不同。有 $q$ 次操作，每次操作给定 $l,r,x$，表示将 $a_{l\sim r}$ 都加上 $x$。请在第一次操作之前和每次操作之后求出 $b_1\oplus b_2\oplus \cdots \oplus b_n$。其中 $\oplus$ 表示按位异或。

## 说明/提示

样例解释：

第一次修改之前序列为 $[1,2,3,4]$，得到 $b_1=4,b_2=3,b_3=2,b_4=1$，故答案为 $4\oplus 3 \oplus 2\oplus 1=4$。

第一次修改之后序列为 $[2,3,3,4]$，得到 $b_1=4,b_2=2,b_3=0,b_4=0$，故答案为 $4\oplus 2 \oplus 0\oplus 0=6$。

第二次修改之后序列为 $[2,4,4,4]$，得到 $b_1=4,b_2=1,b_3=0,b_4=0$，故答案为 $4\oplus 1 \oplus 0\oplus 0=5$。

----

| 子任务编号 | $n$ | $q$ | 特殊性质 | 分值 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| $0$ | $\le 300$ | $\le 300$ | 无 | $15$ |
| $1$ | $\le 5000$ | $\le 5000$ | 无 | $15$ |
| $2$ | $\le 2\times 10^5$ | $\le 2\times 10^5$ | 保证 $a_i,x$ 在值域内均匀随机 | $10$ |
| $3$ | $\le 5\times 10^4$ | $\le 5\times 10^4$ | 无 | $30$ |
| $4$ | $\le 2\times 10^5$ | $\le 2\times 10^5$ | $l=1,r=n$ | $5$ |
| $5$ | $\le 2\times 10^5$ | $\le 2\times 10^5$ | 无 | $25$ |

对于所有数据，$1 \le n,q \le 2\times 10^5$，$1\le l \le r \le n$，$0\le |x|,|a_i|\le 10^9$。

## 样例 #1

### 输入

```
4 2
1 2 3 4
1 2 1
2 3 1```

### 输出

```
4
6
5```

# 题解

## 作者：irris (赞：10)

> 根号分治 / 差分

$*1000$，$6.5$。

## Preface

这种题为啥不放月赛 1A，搞笑用的？

## Solution

对于原序列差分，那么我们不仅易于得到 $b_i$，而且修改易于转化，可以获得显然的 $\mathcal O(nq)$ 做法。

首先如果我们仅仅转化为「区间加 / 减，全局异或和」是不可能做得了的。所以考虑一个长度为 $k$ 的 $a_i \neq a_{i+1}$ 极长区间，它的贡献应当有

- $b_1 \gets b_1 + k$，$b_2 \gets b_2 + (k - 1)$，$\dots$，$b_k \gets b_k + 1$

因此容易发现这是一段等差数列。进一步地，若 $l_1 + l_2 + \dots + l_{p} = n$，显然 $\{l_p\}$ 中不同的元素仅有 $\mathcal O(\sqrt{n})$ 种。

我们将 $l$ 从大到小排序，因此我们说这形成了 $\mathcal O(\sqrt{n})$ 个等差数列（等差数列对应项相加，依旧是等差数列），并且形式看起来比较优美。我们只要能快速计算等差数列的 xor 即可。

对公差 $d$ 根号分治。$d \leq \sqrt{n}$，我们进行预处理；$d > \sqrt{n}$，不会有超过 $\sqrt{n}$ 项，暴力即可。

时空复杂度 $\mathcal O(n\sqrt{n})$。

## Postscript

为啥我取 $b = 2$ 没过去。

$b = 50$ 是比较优秀的，直接跑到了最优解 rk2。调参和造数据就留给后人吧。

---

## 作者：L_zaa_L (赞：8)

这道根号分治有点牛，考场上只会 $45$ 分（太菜了）。

由于限制条件时相邻的数相同，发现每次修改之后只有 $l-1,l$ 和 $r,r+1$ 这两个位置的相同情况可能会发生改变，所以我们可以考虑对于原序列进行差分，设 $b_i=a_i-a_{i-1}$，那么对于一个操作 $(l,r,k)$ 需要更改为 $b_{l}\gets b_l+k,b_{r+1}\gets b_{r+1}-k$，如果某个位置变为 $0$ 了，说明它和它前面的那个数相等了。

我们设长度为 $i$ 满足条件的个数为 $f_i$，我们对于 $b$ 这个序列的一段极长非 $0$ 的一段长度为 $k$ 区间，我们就有这样的贡献 $\forall 1\le i\le k,f_i\gets f_i+(k-i+1)$。那么发现原序列其实应该是一段一段的等差数列（因为等差数列加等差数列还是等差数列）。

我们设一个不可重集合 $S$ 表示当前所有不同的极长非 $0$ 段的长度的集合，假设元素为 $S_1,S_2,\dots,S_{|S|}$，那么 $[1,S_1],[S_1+1,S_2],\dots [S_{|S|-1}+1,S_{|S|}]$ 都是等差数列。

由于 $\sum len=n$，所以不同的 $len$ 的个数只有 $\sqrt{n}$ 种情况，我们的等差数列就是只有 $\sqrt{n}$ 段。

于是我们可以考虑根号分治，对于所有 $len\le \sqrt{n}$ 的位置我们可以直接用等差数列暴力求，对于 $len\ge \sqrt n$ 的情况，物品们发现最多之后有 $\sqrt{n}$ 个，也就是说公差最多为 $\sqrt{n}$，我们可以预处理，记 $f_{i,j}$ 表示等差数列的开头是 $i$，公差是 $j$，其中算的值为：$i\oplus (i-j)\oplus\dots\oplus (i-\lfloor{\frac{i}{j}}\rfloor\times j)$。 

由于前面的等差数列其实受后面的影响的，所以我们从大到小地枚举每个长度，记录当前等差数列的公差，上一个等差数列的开头，以及这段等差数列的长度，就可以维护出来这段区间的等差数列了。

我们只需要用 set 维护出现过的所有长度，以及 $0$ 出现的位置（每次区间操作需要将这个位置左右两边拆开或者合并，需要记录 $0$ 的位置找左右区间的长度），再维护每个长度的个数，随便搞一下就行了。

时间复杂度：$O(Q\sqrt{n}+Q\log n)$。

```cpp
#include<bits/stdc++.h>
//#define int long long
#define ls(x) ((x)*2)
#define rs(x) ((x)*2+1)
#define Debug(...) fprintf(stderr, __VA_ARGS__)
#define For(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)
#define Rof(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)
#define rep(i,  b) for(int i=1,i##end=b;i<=i##end;i++)
using namespace std;
const int N=2e5+5,Mod=998244353,B=4;
char buf[(1<<21)+5],*p1,*p2;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
inline void chmx(int &x,int y){(x<y)&&(x=y);}
inline void chmn(int &x,int y){(x>y)&&(x=y);}
//typedef __int128_t i128;
//i128 _base=1;
//inline int mol(int x){return x-Mod*(_base*x>>64);}
//inline void Add(int &x,int y){x=mol(x+y+Mod);}
inline int read(){
	int f=0,x=0;
	char ch=getchar();
	while(!isdigit(ch)){f|=(ch=='-');ch=getchar();}
	while(isdigit(ch)){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return f?-x:x;
}
int n,Q;
int a[N],b[N];
set<int>gg,len;//0,len
short cnt[N];
int f[N][B+1];
inline void updata(int x,int k){
	if(k==0) return;
	if(a[x]==0){
		auto l=gg.lower_bound(x),r=l;
		l--;r++;
		int lenl=x-*l,lenr=*r-x;
		cnt[lenl]--;
//		cout<<1<<*l<<*r<<lenl<<" "<<lenr<<endl;
		if(cnt[lenl]==0) len.erase(-lenl);
		cnt[lenr]--;
		if(cnt[lenr]==0) len.erase(-lenr);cnt[lenl+lenr]++;
		if(cnt[lenr+lenl]==1) len.insert(-lenr-lenl);
		gg.erase(x);
	}
	a[x]+=k;
	if(a[x]==0){
		auto l=gg.lower_bound(x),r=l;
		l--;
		int lenl=x-*l,lenr=*r-x;
		cnt[lenl]++;
//		cout<<*l<<*r<<lenl<<" "<<lenr<<endl;
		if(cnt[lenl]==1) len.insert(-lenl);cnt[lenr]++;
		if(cnt[lenr]==1) len.insert(-lenr);cnt[lenl+lenr]--;
		if(cnt[lenr+lenl]==0) len.erase(-lenr-lenl);
		gg.insert(x);
	}
}
int nxt[N],tot;
inline void solve(){
	n=read(),Q=read();
	gg.insert(1);gg.insert(n+1);
	For(i,1,n)b[i]=read(),a[i]=b[i]-b[i-1];
	int lenth=0;
	For(i,1,n+1){
//		cout<<a[i]<<" ";
		if(a[i]==0){
			gg.insert(i);
			cnt[lenth]++;
			len.insert(-lenth);
			lenth=1;
		}
		else lenth++;
	}
	For(d,1,B){
		For(i,1,d) f[i][d]=i;
		For(i,d+1,n) f[i][d]=i^f[i-d][d];
	}
	int cha=0,ans=0,all=0;
	tot=0;
	for(auto ts:len) nxt[++tot]=-ts;
	int cntt=0;
	for(auto ts:len){
		int i=-ts;
		cntt++;
		int le=(i-nxt[cntt+1]);
		cha+=cnt[i];
//		cout<<le<<" "<<cha<<" "<<i<<endl;
		if(cha<=B) ans^=f[all+cha*le][cha]^f[all][cha];
		else For(j,1,le) ans^=(all+j*cha);
		all+=cha*le; 
	}
	printf("%d\n",ans);
	while(Q--){
		int l=read(),r=read(),k=read();
		if(l!=1)updata(l,k);
		if(r+1!=n+1)updata(r+1,-k);
		cha=0,ans=0,all=0;
		tot=0;
		for(auto ts:len) nxt[++tot]=-ts;
		nxt[tot+1]=0;
		cntt=0;
		for(auto ts:len){
			int i=-ts;
			cntt++;
			int le=(i-nxt[cntt+1]);
			cha+=cnt[i];
//		cout<<le<<" "<<cha<<" "<<i<<nxt[cntt+1]<<endl;
			if(cha<=B) ans^=f[all+cha*le][cha]^f[all][cha];
			else For(j,1,le) ans^=(all+j*cha);
			all+=cha*le; 
//			cout<<ans<<endl;
		}
		printf("%d",ans);puts("");
	}
}
signed main(){
	//_base=(_base<<64)/Mod;
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	// ios::sync_with_stdio(false);
	// cin.tie(0); cout.tie(0);
	int T=1;
	while(T--){solve();}
#ifdef LOCAL
    Debug("\nMy Time: %.3lfms\n", (double)clock() / CLOCKS_PER_SEC);
#endif
	return 0;
}


```

---

## 作者：王熙文 (赞：0)

## 思路

先将 $a$ 差分（直接在 $a$ 数组上进行），那么区间加变为单点加。对于 $a$ 上的一段极长不为 $0$ 的段，设长度为 $len$，那么它对 $b$ 的贡献是：$b_i \gets b_i + \max(len+1-i+1,0)$。

因为极长的段的总长度 $\le n$，所以 $len$ 不同的只有 $\mathcal O(\sqrt{n})$ 种。可以使用 `set` 大力维护出每一种 $len$ 以及它出现的个数。具体而言，对于某次将 $a_i$ 从 $0$ 修改为 $1$ 或者相反的操作，使用 `set` 找到 $i$ 左、右连续 $1$ 的个数，并合并或分裂即可。现在可以将问题转化成：有一个序列 $b$ 初始为 $0$，有 $\mathcal O(\sqrt{n})$ 个二元组 $(x,y)$（满足 $\sum xy \le \mathcal n+1$），每个二元组对每个 $b_i$ 的贡献为 $y \cdot \max(x-i+1,0)$，求 $b$ 的异或和。这个转化实际上是加强了问题，因为每次操作只会修改 $\mathcal O(1)$ 个二元组，而这里我们要认为这些二元组都是新的，重新求一遍。但因为加法和异或很难放在一起做，所以修改 $\mathcal O(1)$ 个二元组也会产生很大的代价，不如放在一起做。

因为等差数列对应项加起来后仍然是等差数列，所以 $b$ 最终会形成 $\mathcal O(\sqrt{n})$ 个等差数列，而且这是容易求出来的（按 $x$ 从小到大遍历二元组，并维护当前段的左端点的 $b_i$ 值以及 $x$ 大于等于当前段的 $y$ 之和，后者是这一段的公差）。接下来要分析这些等差数列有什么性质。可以发现 $\sum [x >B]y \le \dfrac{n+1}{B}$。因此大于 $B$ 的公差较小。考虑根号分治，小于等于 $B$ 时可以暴力求出 $b$ 并异或起来，大于 $B$ 时求出公差 $\le \dfrac{n+1}{B}$ 的等差数列异或和即可。这个问题可以预处理。预处理 $vis_{i,j}$ 表示 $j,j-i,j-2i,\cdots$（直到最后一个大于 $0$ 的数结束）这个等差数列的异或和，那么上面问题的异或和可以将左右端点的 $vis$ 值异或得出（相当于前缀和的减）。

## 代码

代码中的 `B` 是 $\dfrac{n+1}{B}$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int B=200;
int vis[210][200010];
int n,m;
int a[200010];
int b[200010];
int cnt[200010];
set<int> stlen;
void add(int x)
{
	if(x==1) return;
	if(++cnt[x]==1) stlen.insert(x);
}
void del(int x)
{
	if(x==1) return;
	if(--cnt[x]==0) stlen.erase(x);
}
int get_ans()
{
	auto now=stlen.begin();
	int sum=0,ccnt=0;
	while(now!=stlen.end()) sum+=((*now)-1)*cnt[*now],ccnt+=cnt[*now],++now;
	int wz=2,ans=0;
	now=stlen.begin();
	while(now!=stlen.end())
	{
		if(ccnt>B)
		{
			for(int i=wz; i<=(*now); ++i) ans^=sum,sum-=ccnt;
			ccnt-=cnt[*now];
		}
		else
		{
			ans^=vis[ccnt][sum];
			sum-=((*now)-wz+1)*ccnt;
			ans^=vis[ccnt][sum];
			ccnt-=cnt[*now];
		}
		wz=(*now)+1,++now;
	}
	return ans;
}
set<pair<int,int>> st;
void change(int wz,int x)
{
	if(a[wz]==0) // 0->1
	{
		auto wwz=st.lower_bound({wz,0});
		int l=0,r=0,ll=wz,rr=wz;
		if(wwz!=st.end() && (*wwz).first==wz+1)
		{
			r=(*wwz).second-(*wwz).first+1,rr=(*wwz).second;
			wwz=st.erase(wwz);
		}
		if(wwz!=st.begin() && (*--wwz).second==wz-1)
		{
			l=(*wwz).second-(*wwz).first+1,ll=(*wwz).first;
			st.erase(wwz);
		}
		del(l+1),del(r+1),add(l+r+2);
		st.insert({ll,rr});
	}
	else if(a[wz]+x==0) // 1->0 
	{
		auto wwz=st.lower_bound({wz,(int)1e9}); --wwz;
		pair<int,int> now=(*wwz);
		st.erase(wwz);
		del(now.second-now.first+2);
		if(now.first!=wz) add(wz-now.first+1),st.insert({now.first,wz-1});
		if(wz!=now.second) add(now.second-wz+1),st.insert({wz+1,now.second});
	}
	a[wz]+=x;
}
signed main()
{
	ios::sync_with_stdio(false),cin.tie(0);
	cin>>n>>m;
	for(int i=1; i<=B; ++i)
	{
		for(int j=1; j<=n+5; ++j) vis[i][j]=j^(j>i?vis[i][j-i]:0);
	}
	for(int i=1; i<=n; ++i) cin>>a[i];
	for(int i=n; i>=2; --i) a[i]-=a[i-1];
	for(int i=2; i<=n; ++i)
	{
		if(a[i]==0) continue;
		int now=i;
		while(now<=n && a[now]!=0) ++now;
		--now;
		add(now-i+2);
		st.insert({i,now});
		i=now;
	}
	cout<<(get_ans()^n)<<'\n';
	for(int i=1; i<=m; ++i)
	{
		int l,r,x; cin>>l>>r>>x;
		if(x!=0)
		{
			if(l!=1) change(l,x);
			if(r!=n) change(r+1,-x);
		}
		cout<<(get_ans()^n)<<'\n';
	}
	return 0;
}
```

---


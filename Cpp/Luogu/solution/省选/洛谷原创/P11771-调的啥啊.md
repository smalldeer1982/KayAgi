# 调的啥啊

## 题目背景

**为避免卡常，本题时限为比赛时的 2 倍。**

你试过用笔记本的触摸板操作扒谱吗？

阿绫正在玩天依——最新的 X Studio 声库，由于触控板和鼠标神秘失踪，她每调整一个音符都极其费力……


## 题目描述

在阿绫正在调的序列中一共有 $n$ 个音符，从左至右第 $i$ 个音符的音高为 $s_i$。阿绫发现其中三个音符 $s_i,s_j,s_k~(1\le i<j<k\le n)$ 产生的听感不佳，她决定将它们调整为 $s_i',s_j',s_k'$，使得 $s_i'\le s_k'$ 且 $s_j'\le s_k'$。扒拉触摸板真的很难受：

- 调节 $s_i$ 到 $s_i'$ 需要耗费阿绫 $a\times|s_i-s_i'|$ 的精力；
- 调节 $s_j$ 到 $s_j'$ 需要耗费阿绫 $b\times|s_j-s_j'|$ 的精力；
- 调节 $s_k$ 到 $s_k'$ 需要耗费阿绫 $c\times|s_k-s_k'|$ 的精力。

于是，调节完这三个音符，阿绫耗费的精力为：
$$
z=a\cdot|s_i-s_i'|+b\cdot|s_j-s_j'|+c\cdot|s_k-s_k'|.
$$

阿绫自然会找到使得 $z$ 值最小的 $(s_i',s_j',s_k')$，记此时的 $z$ 值为 $f(i,j,k)$。现在阿绫想知道，对于所有满足 $i<j<k$ 的 $(i,j,k)$，$f(i,j,k)$ 之和是多少呢？你只需要回答她这一答案对 $2^{32}$ 取模的结果。

## 说明/提示

### 样例解释

$f(1,2,3)=4$，其中一组最优的 $(s_i',s_j',s_k')$ 为 $(2,3,3)$。

$f(1,2,4)=13$，其中一组最优的 $(s_i',s_j',s_k')$ 为 $(2,2,2)$。

$f(1,3,4)=9$，其中一组最优的 $(s_i',s_j',s_k')$ 为 $(2,2,2)$。

$f(2,3,4)=13$，其中一组最优的 $(s_i',s_j',s_k')$ 为 $(3,3,3)$。

$f(i,j,k)$ 的总和为 $4+13+9+13=39$。

### 数据规模与约定

**本题采用捆绑测试。** 仅当你通过了该子任务的全部测试数据才能获得该子任务的分值。

对于 $100\%$ 的数据，$3\le n\le5\times10^5$，$1\le s_i,a,b,c\le 10^9$。

对于不同的子任务，作如下约定：

| 子任务编号	| $n$ | 特殊性质 | 子任务分值 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $=3$ | 无 | $5$ |
| $2$ | $\le300$ | 无 | $5$ |
| $3$ | $\le1000$ | 无 | $10$ |
| $4$ | $\le5\times10^3$ | 无 | $20$ |
| $5$ | $\le5\times10^4$ | 无 | $20$ |
| $6$ | $\le5\times10^5$ | 有 | $20$ |
| $7$ | $\le5\times10^5$ | 无 | $20$ |

特殊性质：出现的不同音高不超过 $10$ 种。

## 样例 #1

### 输入

```
4
3 4 5
2 4 3 1```

### 输出

```
39```

# 题解

## 作者：_lmh_ (赞：7)

分五种情况：

$a_i\le a_k,a_j\le a_k$：显然。

$a_i\le a_k\le a_j$：答案为 $\min\{B,C\}(a_j-a_k)$。

$a_j\le a_k\le a_i$：答案为 $\min\{A,C\}(a_i-a_k)$。

$a_k\le a_i\le a_j$：答案为 $\min\{A+B,C\}(a_i-a_k)+\min\{B,C\}(a_j-a_i)$。

$a_k\le a_j\le a_i$：答案为 $\min\{A+B,C\}(a_j-a_k)+\min\{A,C\}(a_i-a_j)$。

令 $(A,B,C)\leftarrow (\min\{A,C\},\min\{B,C\},\min\{A+B,C\})$ 即可去掉式子里的根号。

对于第 2,3 种情况，可以在 $i$ 处记录答案，此时需要在权值线段树上维护 $(j,k)$ 的个数和答案中只和 $j,k$ 有关的部分。

对于第 4,5 种情况，可以在 $k$ 处记录答案，需要维护 $(i,j)$ 的个数和 $\max\{0,a_i-a_j\}\cdot A+\max\{0,a_j-a_i\}\cdot B+\min\{a_i,a_j\}\cdot C$，可以用树状数组记录 $\ge x$ 的 $a_i$ 的个数和它们的和。

时间复杂度 $O(n\log n)$，需要卡常。$\color{white}{下面给的这份代码常数不太能过。}$

```cpp
#include<bits/stdc++.h>
using namespace std;
#define uint unsigned int
#define lson (u<<1)
#define rson (u<<1|1)
const int N=500007;
int n,m;
uint ans,s,A,B,C,K,x[N],y[N],cnt[N<<2],len[N<<2],val[N<<2],tag[N<<2],sum[N<<2],extag[N<<2];
void addex(int u,uint v){val[u]+=v*cnt[u];extag[u]+=v;}
void add(int u,uint v){val[u]+=K*len[u]*v;tag[u]+=v;sum[u]+=cnt[u]*v;}
void pushdown(int u){
	if (tag[u]){
		add(lson,tag[u]);add(rson,tag[u]);tag[u]=0;
	}
	if (extag[u]){
		addex(lson,extag[u]);addex(rson,extag[u]);extag[u]=0;
	}
}
void add(int u,int l,int r,int L,int R,uint v){
	if (L<=l&&r<=R){addex(u,v);add(u,1);return;}
	int mid=l+r>>1;pushdown(u);
	if (L<=mid) add(lson,l,mid,L,R,v);
	if (R>mid) add(rson,mid+1,r,L,R,v);
	val[u]=val[lson]+val[rson];sum[u]=sum[lson]+sum[rson];
}
void modify(int u,int l,int r,int x,uint v,uint c){
	++cnt[u];len[u]+=y[x];sum[u]+=c;val[u]+=v;
	if (l==r) return;
	int mid=l+r>>1;pushdown(u);
	if (x<=mid) modify(lson,l,mid,x,v,c);
	else modify(rson,mid+1,r,x,v,c);
}
uint getcnt(int u,int l,int r,int L,int R){
	if (L<=l&&r<=R) return cnt[u];
	int mid=l+r>>1;pushdown(u);
	if (R<=mid) return getcnt(lson,l,mid,L,R);
	if (L>mid) return getcnt(rson,mid+1,r,L,R);
	return getcnt(lson,l,mid,L,R)+getcnt(rson,mid+1,r,L,R);
}
uint getsum(int u,int l,int r,int L,int R){
	if (L<=l&&r<=R) return sum[u];
	int mid=l+r>>1;pushdown(u);
	if (R<=mid) return getsum(lson,l,mid,L,R);
	if (L>mid) return getsum(rson,mid+1,r,L,R);
	return getsum(lson,l,mid,L,R)+getsum(rson,mid+1,r,L,R);
}
uint getval(int u,int l,int r,int L,int R){
	if (L<=l&&r<=R) return val[u];
	int mid=l+r>>1;pushdown(u);
	if (R<=mid) return getval(lson,l,mid,L,R);
	if (L>mid) return getval(rson,mid+1,r,L,R);
	return getval(lson,l,mid,L,R)+getval(rson,mid+1,r,L,R);
}
void output(int u,int l,int r){
	cout<<l<<' '<<r<<' '<<val[u]<<' '<<cnt[u]<<' '<<sum[u]<<' '<<len[u]<<endl;
	if (l==r) return;pushdown(u);
	int mid=l+r>>1;
	output(lson,l,mid);output(rson,mid+1,r);
}
struct BIT{
	uint cnt[N];
	void clear(){memset(cnt,0,sizeof(cnt));}
	void add(int x,uint v){
		while(x<=m){cnt[x]+=v;x+=x&-x;}
	}
	uint query(int x){
		uint sum=0;
		while(x){sum+=cnt[x];x&=x-1;}
		return sum;
	}
}X,Y;
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n>>A>>B>>C;C=min(C,A+B);A=min(A,C);B=min(B,C);
	for (int i=1;i<=n;++i){cin>>x[i];y[i]=x[i];}
	sort(y+1,y+1+n);m=unique(y+1,y+1+n)-y-1;K=C-B;
	for (int i=1;i<=n;++i){
		x[i]=lower_bound(y+1,y+1+m,x[i])-y;
//		if (x[i]<m) cout<<getval(1,1,m,x[i]+1,m)<<' '<<getsum(1,1,m,x[i]+1,m)<<endl;
		if (x[i]<m) ans+=getval(1,1,m,x[i]+1,m)-getsum(1,1,m,x[i]+1,m)*y[x[i]]*C;
		add(1,1,m,1,x[i],B*y[x[i]]);
		uint c=i-1-X.query(x[i]),v=s-Y.query(x[i]);
//		cout<<i<<' '<<c<<' '<<v<<endl;
		modify(1,1,m,x[i],(v-c*y[x[i]])*A+c*y[x[i]]*C,c);
		s+=y[x[i]];
		X.add(x[i],1);Y.add(x[i],y[x[i]]);
//		output(1,1,m);
//		cout<<ans<<endl;
	}
	X.clear();Y.clear();
	memset(val,0,sizeof(val));memset(tag,0,sizeof(tag));memset(sum,0,sizeof(sum));memset(len,0,sizeof(len));memset(cnt,0,sizeof(cnt));memset(extag,0,sizeof(extag));
	K=-B;
	for (int i=n;i;--i){
		ans+=getval(1,1,m,x[i],m);
		add(1,1,m,1,x[i],B*y[x[i]]);
		modify(1,1,m,x[i],0,0);
	}
	X.clear();Y.clear();
	memset(val,0,sizeof(val));memset(tag,0,sizeof(tag));memset(sum,0,sizeof(sum));memset(len,0,sizeof(len));memset(cnt,0,sizeof(cnt));memset(extag,0,sizeof(extag));
	K=-A;
	for (int i=n;i;--i){
		ans+=A*y[x[i]]*getsum(1,1,m,1,x[i])+getval(1,1,m,1,x[i]);
		add(1,1,m,x[i],m,0);
		modify(1,1,m,x[i],0,0);
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：xieziheng (赞：4)

感觉就，纯纯一个大陶题。

本题不需要~~线段树这种高级数据结构，~~，因此我靠树状数组喜提最优解。

考虑对于有序三元组 $(x,y,z)$ 怎么算贡献。

调整法容易证明 $(x,y,z)$ 最终一定取值集合为初始取值集合的子集。所以陶一下可以发现贡献就是 

- $x\leq z,y>z$ : $\min(b,c)(y-z)$。

- $y\leq z,x>z$ : $\min(a,c)(x-z)$。

- $x\geq y>z,\min((x-z)c,(y-z)c+(x-y)a,(x-z)a+(y-z)b)$。

- $z<x<y,\min((y-z)c,(x-z)c+(y-x)b,(x-z)a+(y-z)b)$。

前面两种情况是较为简单的。

然后 $c\geq a+b$ 的时候后面两种的 $\min$ 取值一定为最后那个，而这时候关于三个元素是独立的，所以简单树状数组统计一下即可。$c<a+b$ 时一定不取最后那个。

对于第三种情况，在 $c\leq a$ 的时候取第一个否则取第二个。第四种情况同理。

然后考虑算答案，这里只取一种情况为例，别的同理。

对于第四种情况，我们需要算满足 $y>x,y>z,x>z$ 的 $(x-z)c+(y-x)b=x(c-b)+by-cz$，拆贡献后 $x$ 的部分算后面 $y>x,z<x$ 的和，可以容斥成所有 $y>x$ 的 $y$ 与后面的逆序对个数之和减去所有 $y>x,z\geq x$ 的逆序对个数，这个可以再容斥成顺序对个数就容易算了。

反正对于各种情况的容斥大体想法就是把 $x,z$ 之间的限制去掉，然后尽量让两侧符号相同从 $x,z$ 的角度统计。

代码：

```cpp
#define il inline
#define pii pair<int,int>
#define fi first
#define se second
using namespace std;
typedef long long ll;
typedef unsigned int uint;
il int ab(int x){return x>=0?x:-x;}
const int N=5e5+5;const ll inf=2e18;
int n,m;uint ans,s[N],d[N],a,b,c;
il uint calc(uint x,uint y,uint z){
	if(x<=z && y<=z) return 0u;
	if(x<=z && y>z) return 1u*min(b,c)*(y-z);
	if(x>z && y<=z) return 1u*min(a,c)*(x-z);
	if(x<=y){
		if(c<=b) return 1u*(y-z)*c;
		return 1u*(x-z)*c+1u*(y-x)*b;
	}
	else{
		if(c<=a) return 1u*(x-z)*c;
		return 1u*(y-z)*c+1u*(x-y)*a;
	}
}
struct BIT{
	uint t[N];
	il BIT(){memset(t,0,sizeof(t));}
	il void clear(){for(int i=0;i<=m;++i) t[i]=0;}
	il void add1(int x,uint v){while(x<=m) t[x]+=v,x+=(x&-x);}
	il uint get1(int x){uint ret=0;while(x) ret+=t[x],x-=(x&-x);return ret;}
}A,B,C,D;
uint x,y,z,u,v,w,g[N],h[N],f[N],ff[N],gg[N],g1[N],g2[N];
il uint FF(uint x){
    if(!x) return 0;
    uint y=x-1;if(x&1) y>>=1;else x>>=1;
    return x*y;
}
int main(){
	scanf("%d%u%u%u",&n,&a,&b,&c);
	for(int i=1;i<=n;++i) s[i]=read(),d[i]=s[i];
	sort(d+1,d+1+n);m=unique(d+1,d+1+n)-d-1;
	for(int i=1;i<=n;++i) s[i]=lower_bound(d+1,d+1+m,s[i])-d;
	if(c>=a+b){
		uint ss1=0,ss2=0;
		for(int i=n;i;--i){
			w=(1u*d[s[i]]*A.get1(s[i]-1)-B.get1(s[i]-1));
			ss1-=(i+1u)*w,ss1+=(1u*d[s[i]]*C.get1(s[i]-1)-D.get1(s[i]-1));
			ss2+=(i-1u)*w;
			A.add1(s[i],1u),B.add1(s[i],d[s[i]]);
			C.add1(s[i],1u*i),D.add1(s[i],1u*d[s[i]]*i);
		}
		ans=ss1*a+ss2*b;
		printf("%u",ans);
		exit(0);
	}
	uint ss1=0,ss2=0;
	if(c<=a){
        for(int i=n;i;--i) g[i]=A.get1(s[i]),A.add1(s[i],1),ss1+=c*d[s[i]]*FF(g[i]);A.clear();
        for(int i=1;i<=n;++i) h[i]=i-1-(f[i]=A.get1(s[i]-1)),A.add1(s[i],1);A.clear();
        for(int i=1;i<=n;++i) ff[i]=A.get1(s[i]-1),A.add1(s[i],f[i]);A.clear();
        uint ss=0;for(int i=1;i<=n;++i) ss1-=c*d[s[i]]*(ss-FF(A.get1(s[i]-1))+ff[i]),A.add1(s[i],1),ss+=h[i];A.clear();
	}
	else{
        for(int i=1;i<=n;++i) g[i]=i-1-A.get1(s[i]),gg[i]=i-1-A.get1(s[i]-1),A.add1(s[i],1);A.clear();
        for(int i=n;i;--i) ss1+=(c-a)*d[s[i]]*gg[i]*(h[i]=A.get1(s[i]-1)),A.add1(s[i],1);A.clear();
        for(int i=n;i;--i) ss1+=a*d[s[i]]*A.get1(s[i]),A.add1(s[i],h[i]);A.clear();
        ll ss=0;for(int i=1;i<=n;++i) ss1-=c*d[s[i]]*(ss-A.get1(s[i])),ss+=gg[i],A.add1(s[i],gg[i]);A.clear();
        for(int i=n;i;--i) ff[i]=A.get1(s[i]),A.add1(s[i],h[i]);A.clear();
        for(int i=n;i;--i) ss1+=a*d[s[i]]*(FF(A.get1(s[i]))-ff[i]),A.add1(s[i],1);A.clear();
        for(int i=1;i<=n;++i) g[i]=i-1-(gg[i]=A.get1(s[i]-1)),A.add1(s[i],1);A.clear();
        for(int i=1;i<=n;++i) ff[i]=A.get1(s[i]-1),A.add1(s[i],gg[i]);A.clear();
        for(int i=1;i<=n;++i) ss1-=a*d[s[i]]*(A.get1(s[i])-FF(gg[i])+ff[i]),A.add1(s[i],g[i]);A.clear();
	}
	if(c<=b){
		for(int i=1;i<=n;++i) g[i]=A.get1(s[i]-1),A.add1(s[i],1);
		A.clear();
		for(int i=n;i;--i){
			ss2+=g[i]*(d[s[i]]*A.get1(s[i]-1)-B.get1(s[i]-1));
			A.add1(s[i],1),B.add1(s[i],d[s[i]]);
		}
		ss2*=c;
	}
	else{
		uint ss=0;
        for(int i=n;i;--i) g2[i]=g[i]=A.get1(s[i]-1),h[i]=n-i-g[i],A.add1(s[i],1);A.clear();
		ss=0;for(int i=n;i;--i) ff[i]=ss-A.get1(s[i]-1),A.add1(s[i],h[i]),ss+=h[i];A.clear();
		ss=0;for(int i=n;i;--i) ss2+=(c-b)*d[s[i]]*((ss-A.get1(s[i]))-(FF(h[i])-ff[i])),ss+=g[i],A.add1(s[i],g[i]);A.clear();
		for(int i=1;i<=n;++i) g[i]=gg[i]=i-1-A.get1(s[i]),h[i]=i-1-(g1[i]=A.get1(s[i]-1)),A.add1(s[i],1);A.clear();
		ss=0;for(int i=1;i<=n;++i) ss2-=c*d[s[i]]*(FF(g[i])-(ss-A.get1(s[i]))),A.add1(s[i],h[i]),ss+=h[i];A.clear();
		for(int i=1;i<=n;++i) ss2+=b*d[s[i]]*g1[i]*g2[i];
		ss=0;for(int i=1;i<=n;++i) ff[i]=(ss-A.get1(s[i])),A.add1(s[i],i-1u),ss+=i-1u;A.clear();
		for(int i=1;i<=n;++i) ss2-=b*d[s[i]]*(ff[i]-FF(gg[i]));
	}
	ans=ss1+ss2;
	printf("%u",ans);
    return 0;
}
```

---

## 作者：E_firework (赞：4)

### 简要题意

求 $\left(\sum\limits_{1\le i<j<k\le n}f(i,j,k)\right) \bmod 2^{32}$。

其中 $f(i,j,k)=\min\limits_{s_i',s_j'\le s_z'}\{a\cdot|s_i-s_i'|+b\cdot|s_j-s_j'|+c\cdot|s_k-s_k'|\}$。$a$，$b$，$c$ 为给定常数。

### 算法一

我们发现最优的 $(s_i',s_j',s_k')$ 中一定有 $s_i'\le s_i$，$s_j'\le s_j$，$s_k'\ge s_k$，$s_i',s_j',s_k'\in\{s_i,s_j,s_k\}$，这是显然的。

于是直接对每组 $(i,j,k)$ 枚举 $(s_i',s_j',s_k')$ 所有可能的取值计算答案。

期望得分 $10$。

### 算法二

我们发现，当 $a+b\le c$ 时，让 $s_i'$ 和 $s_j'$ 同时减少 $1$ 是比让 $s_k'$ 增加 $1$ 更优的。同样当 $c\le a$ 或 $c\le b$ 时，让 $s_k'$ 增加 $1$ 是比让 $s_i'$ 或 $s_j'$ 减小 $1$ 更优的。于是我们可以令 $a\gets \min(a,c)$，$b\gets \min(b,c)$，$c\gets\min(c,a+b)$。这样可以去除一些复杂的分类讨论从而使后续的处理变的简单。

在上一步处理之后，我们可以保证有 $a\le c$，$b\le c$，$c\le a+b$。接下来分析 $f(i,j,k)$ 的计算方法。当 $s_i$ 和 $s_j$ 都小于等于 $s_k$ 时 $f(i,j,k)=0$。当 $s_i$ 和 $s_j$ 中有一个数大于 $s_k$ 时，最优的 $(s_i',s_j',s_k')$ 是 $(\min(s_i,s_k),\min(s_j,s_k),s_k)$。当 $s_i$ 和 $s_j$ 都大于 $s_k$ 时，最优的 $(s_i',s_j',s_k')$ 是 $(\min(s_i,s_j),\min(s_i,s_j),\min(s_i,s_j))$。

然后直接计算所有的 $f(i,j,k)$。

期望得分 $20$。

### 算法三

枚举 $j,k$，问题可以转化为求下标小于 $j$ 的元素中一个值域区间中的元素个数和总和，用树状数组维护。

期望得分 $40$。

### 算法四

当序列中只有不超过 $10$ 种元素时，不同的 $(s_i,s_j,s_k)$ 只有不超过 $1000$ 种，考虑计算每一种 $(s_i,s_j,s_k)$ 的出现次数。统计每个前缀和后缀中每种元素出现的次数，再枚举 $j$ 就行了。

期望得分 $20$。

### 算法五

就算有了 $f(i,j,k)$ 的计算方法之后答案依然不是很好处理，试着再转化一步。发现答案可以表示为 $a\cdot\max(s_i-\max(s_j,s_k),0)+b\cdot\max(s_j-\max(s_i,s_k),0)+c\cdot\max(\min(s_i,s_j)-s_k,0)$。三个部分结构类似，我们可以先考虑 $a\cdot\max(s_i-\max(s_j,s_k),0)$ 的和，也就是 $a\cdot(\sum\limits_{i=1}^{n-2}\sum\limits_{j=i+1}^{n-1}\sum\limits_{k=j+1}^n\max(s_i-\max(s_j,s_k),0))$ 怎么求。

我们发现上式可以表示为 $a\cdot(\sum\limits_{i=1}^{n-2}\sum\limits_{j=i+1}^n\sum\limits_{k=i+1}^n[s_k<s_j\lor(s_k=s_j\land k<j)][s_i>s_j](s_i-s_j))$，如果令 $b_{i,j}$ 为 $s_i,s_{i+1},s_{i+2},\dots,s_n$ 中所有大于 $s_i$ 的数排序后 $s_j$ 的位置，上式可以变为 $a\cdot(\sum\limits_{i=1}^{n-2}\sum\limits_{j=i+1}^n[s_i>s_j](s_i-s_j)b_{i+1,j})$。把括号拆开，就是 $a\cdot(\sum\limits_{i=1}^{n-2}(\frac{c_i(c_i-1)}{2}s_i-\sum\limits_{j=i+1}^n[s_i>s_j]s_jb_{i+1,j}))$，其中 $c_i$ 表示下标比 $i$ 大的元素中值大于 $s_i$ 的数量。

这个式子看起来很可做。考虑扫描线从后往前枚举 $i$，用一个权值线段树来维护所需信息，在 $i$ 减少 $1$ 之前把当前的 $s_i$ 加入到这个线段树里面。$c_i$ 是好求的，问题在于怎么求 $\sum\limits_{j=i+1}^n[s_i>s_j]s_jb_{i+1,j}$。我们可以在线段树上维护三个信息：当前区间的元素个数，元素总和和每个元素乘上他的排名的和。分别记作 $d$，$e$，$f$。如果合并两个节点的信息 $i$ 与 $j$ 得到 $k$，那么有 $f_k=f_i+f_j+d_i+e_j$，而 $d$ 和 $e$ 可以直接加。

问题看似解决了，但是还有一个问题，$b\cdot\max(s_j-\max(s_i,s_k),0)$ 因为 $i$ 和 $k$ 在 $j$ 的两侧，之前的方法好像不适用。但是我们可以容斥一下。用不限制 $i$ 和 $k$ 在 $j$ 的哪侧的答案（但要保证 $i<k$）减去限制 $i$ 和 $k$ 在 $j$ 的左侧的答案再减去限制 $i$ 和 $k$ 在 $j$ 的右侧的答案就是原本要求的答案。还有一个细节，为了减少权值线段树中相同权值的讨论，可以在离散化时给原本值相同的元素赋上不同的值。

时间复杂度为 $O(n\log n)$。

期望得分 $100$。

std:

```cpp
#include<bits/stdc++.h>
#define LL long long
#define Maxn 500005
#define Maxn2 1<<20
#define lc i << 1
#define rc i << 1 | 1
#define bmid int mid = (tr[i].l + tr[i].r) >> 1
#define mes(s, x) memset(s, x, sizeof(s))
using namespace std;
inline LL read(){char c;c = getchar();while(!(('0' <= c && c <= '9') || c == '-')) c = getchar();bool flag = 0;if(c == '-'){flag = 1;c = getchar();}LL tot = 0;while('0' <= c && c <= '9'){tot = 10 * tot + c - '0';c = getchar();}return flag ? -tot : tot;}
struct node{
	unsigned ls, rs, s, x;
	node operator+(const node i)const{
		return{
			ls + i.ls + s * i.x,
			rs + i.rs + x * i.s,
			s + i.s,
			x + i.x
		};
	}
	void upd(unsigned k){
		ls = rs = 0;
		s = k;
		x = 1;
	}
	void clear(){
		ls = rs = s = x = 0;
	}
} tr[Maxn2];
int k;
void upd(int x, unsigned y){
    int i;
	tr[i = (1 << k) + x - 1].upd(y);
    while(i != 1){
        i = i >> 1;
        tr[i] = tr[lc] + tr[rc];
    }
}
node getl(int x){
    int i = (1 << k) + x - 1;
    node dx = {0, 0, 0, 0};
    while(i != 1){
        if(i & 1) dx = tr[i ^ 1] + dx;
        i >>= 1;
    }
    return dx;
}
node getr(int x){
    int i = (1 << k) + x - 1;
    node dx = {0, 0, 0, 0};
    while(i != 1){
        if(!(i & 1)) dx = dx + tr[i ^ 1];
        i >>= 1;
    }
    return dx;
}
void clear(){
	for(int i = 1; i < 1 << (k + 1); i++) tr[i].clear();
}
unsigned a[Maxn], b[Maxn];
struct kid{
	unsigned x, id;
	bool operator<(const kid i)const{
		return x < i.x;
	}
} x[Maxn];
int main(){
	#ifndef ONLINE_JUDGE
		freopen("in", "r", stdin);
		freopen("out", "w", stdout);
	#endif
	unsigned n = read(), A = read(), B = read(), C = read(), ans = 0;
	A = min(A, C);
	B = min(B, C);
	C = min(A + B, C);
	for(int i = 1; i <= n; i++){
		a[i] = read();
		x[i] = {a[i], (unsigned int)i};
	}
	sort(x + 1, x + n + 1);
	for(int i = 1; i <= n; i++) b[x[i].id] = i, ans += ((i - 1) * 1llu * (i - 2) / 2 - (i - 1u) * (n - i)) * x[i].x;
	ans *= B;
	A -= B;
	k = 0;
    while(1 << k < n) k++;
    node dx;
	for(int i = 1; i <= n; i++){
		dx = getl(b[i]);
		ans -= B * ((dx.x - 1) * 1llu * dx.x / 2 * a[i] - dx.rs);
		dx = getr(b[i]);
		ans += C * (dx.ls - (dx.x - 1) * 1llu * dx.x / 2 * a[i]);
		upd(b[i], a[i]);
	}
	clear();
	for(int i = n; i >= 1; i--){
		dx = getl(b[i]);
		ans += A * ((dx.x - 1) * 1llu * dx.x / 2 * a[i] - dx.rs);
		upd(b[i], a[i]);
	}
	printf("%u", ans);
	return 0;
}
```

---


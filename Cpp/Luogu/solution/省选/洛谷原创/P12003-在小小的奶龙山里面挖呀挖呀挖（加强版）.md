# 在小小的奶龙山里面挖呀挖呀挖（加强版）

## 题目背景

夏天快要到了，去兴绍奶龙山参加 ION5202 的 0p 决定探究奶龙山的性质。

## 题目描述

奶龙山内部存在复杂的奶龙山隧道，但是聪明的 0p 一眼就看出了 $n-1$ 条奶龙山隧道的结构是一颗树。其中任意两个隧道只在 $n$ 个休息点处相交，两两休息点之间都有路径联通，第 $i$ 个休息点有一个权值 $a_i$，对于每一个素数 $p$，若 $p\mid a_i$ 则说明 $p$ 公司参与了休息点建设。想要经过一个休息点，就必须和所有参与了休息点建设的公司搞好关系。

0p 有 $q$ 条心仪的路线，第 $i$ 条是从休息点 $u$ 走到休息点 $v$，对于每一条路线，0p 想知道，他需要与多少公司搞好关系才可以成功地走完这一条路线。

**请注意算法常数对时间效率的影响**。

## 说明/提示

对于 $100\%$ 的数据，满足 $1\leq n,q\leq 3\times10^5$，$1\leq a_i\leq 10^8$。

## 样例 #1

### 输入

```
3 1
7 2 1
1 2
1 3
2 3```

### 输出

```
2```

## 样例 #2

### 输入

```
10 7
9 9 8 2 4 4 3 5 3 97
1 2
1 3
3 4
5 2
6 4
7 5
9 1
10 2
3 8
4 5
2 3
4 6
2 4
1 2
4 10
1 1```

### 输出

```
2
2
1
2
1
3
1```

# 题解

## 作者：水星湖 (赞：10)

考虑到每个 $a_i$ 大于 $10^4$ 的质因子至多只有一个，可以树上莫队维护路径不同数个数 （SP10707），时间复杂度 $\mathcal O(n\sqrt q)$。枚举小于 $10^4$ 的质数，对于每个质数就是要查 $q$ 条路径上是否出现过这个质数，可以前缀和做到 $\mathcal O(n+q)$，总复杂度 $ \mathcal O(n\sqrt q + \pi(\sqrt V) (n+q))$。

然后发现：

![](https://cdn.luogu.com.cn/upload/image_hosting/lvq1r95m.png)

因为我没写代码，写了发现真卡不过（5.6s）。

怎么办呢？

![](https://cdn.luogu.com.cn/upload/image_hosting/6yyh2f63.png)

这样复杂度就是 $ \mathcal O(n\sqrt q + \pi(\sqrt[3]V) (n+q))$，而且还可以保证莫队修改常数比较小。

最优解第二。

让我们膜拜 [Cai](https://www.luogu.com.cn/user/21784) 老师/bx

---

## 作者：Argvchs (赞：5)

暴力莫队草过去了。

首先你分解质因数，那么每个数只有 $\log$ 个质因数，然后再用树上莫队。复杂度是 $O(n \sqrt n \log V)$ 的，这样就做完了。

但是写完你发现全炸了而且死得很惨。

我们发现莫队的瓶颈在于指针的移动，但是这样做我们只能做到单次 $O(\log V)$ 的慢速指针移动，这个 $\log$ 无论如何是放不到根号里面的。

复杂度不会优化怎么办？你考虑卡常。

你发现你之前用 `vector` 存了每个点的质因数，这样很慢。

你在括号序上求质因数，而不是在原来的点上求，同时你把这一堆质因数放到同一个 `vector` 里，括号序上每个位置存对应的区间。这样莫队指针移动访问的内存就是连续的！这样做就是对的！！！

<https://www.luogu.com.cn/record/210964459>

```cpp
#include <algorithm>
#include <cmath>
#include <iostream>
#include <utility>
#include <vector>
using namespace std;
const int N = 3e5 + 5, V = 1e8 + 5, V0 = 5761456;
int n, m, a[N], st[N], ed[N], b[N * 2], f[N][19], dep[N], p[V0], pre[V], pl[N * 2], pr[N * 2],
    val[V0], ans[N], siz, idx, cnt, l = 1, r, cur;
bool vis[N], flg[V];
vector<int> G[N], P;
struct query {
    int l, r, lca, id;
    inline bool operator<(const query &x) const {
        if (l / siz != x.l / siz) return l < x.l;
        return l / siz & 1 ? r < x.r : r > x.r;
    }
} q[N];
inline void add(int u, int v) { G[u].push_back(v); }
inline void addedge(int u, int v) { add(u, v), add(v, u); }
inline void dfs(int u, int fa) {
    b[st[u] = ++idx] = u, f[u][0] = fa, dep[u] = dep[fa] + 1;
    for (int i = 1; i < 19; i++) f[u][i] = f[f[u][i - 1]][i - 1];
    for (int v : G[u])
        if (v != fa) dfs(v, u);
    b[ed[u] = ++idx] = u;
}
inline int lca(int u, int v) {
    if (dep[u] < dep[v]) swap(u, v);
    for (int i = 18; i >= 0; i--)
        if (dep[f[u][i]] >= dep[v]) u = f[u][i];
    if (u == v) return u;
    for (int i = 18; i >= 0; i--)
        if (f[u][i] != f[v][i]) u = f[u][i], v = f[v][i];
    return f[u][0];
}
inline void insl(int u) {
    for (int i = pl[u]; i < pr[u]; i++) cur += !val[P[i]]++;
}
inline void dell(int u) {
    for (int i = pl[u]; i < pr[u]; i++) cur -= !--val[P[i]];
}
inline void updl(int u) { (vis[b[u]] ^= true) ? insl(u) : dell(u); }
inline void insr(int u) {
    for (int i = pr[u] - 1; i >= pl[u]; i--) cur += !val[P[i]]++;
}
inline void delr(int u) {
    for (int i = pr[u] - 1; i >= pl[u]; i--) cur -= !--val[P[i]];
}
inline void updr(int u) { (vis[b[u]] ^= true) ? insr(u) : delr(u); }
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m, siz = n * 2 / sqrt(m);
    for (int i = 2; i <= 1e8; i++) {
        if (!flg[i]) p[++cnt] = i, pre[i] = cnt;
        for (int j = 1; j <= cnt && i * p[j] <= 1e8; j++) {
            flg[i * p[j]] = true;
            pre[i * p[j]] = j;
            if (!(i % p[j])) break;
        }
    }
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1, u, v; i < n; i++) cin >> u >> v, addedge(u, v);
    dfs(1, 0);
    for (int i = 1; i <= idx; i++) {
        pl[i] = P.size();
        int x = a[b[i]];
        while (x != 1) {
            int y = pre[x];
            P.push_back(y);
            while (pre[x] == y) x /= p[y];
        }
        pr[i] = P.size();
    }
    for (int i = 1, u, v; i <= m; i++) {
        cin >> u >> v;
        if (st[u] > st[v]) swap(u, v);
        int l = lca(u, v);
        if (l == u) q[i] = {st[u], st[v], 0, i};
        else q[i] = {ed[u], st[v], st[l], i};
    }
    sort(q + 1, q + m + 1);
    for (int i = 1; i <= m; i++) {
        while (l > q[i].l) updr(--l);
        while (r < q[i].r) updl(++r);
        while (l < q[i].l) updl(l++);
        while (r > q[i].r) updr(r--);
        if (q[i].lca) updr(q[i].lca);
        ans[q[i].id] = cur;
        if (q[i].lca) updr(q[i].lca);
    }
    for (int i = 1; i <= m; i++) cout << ans[i] << '\n';
}
```

---

## 作者：Esucu (赞：4)

提供一种倍增做法。

这题是问路径上数的质因数的并集大小，所以对于每个质因数分别考虑它有没有出现过。

运用经典套路，把质因数以 $\sqrt V$ 为界分开考虑。这里分解质因数可以先 $O(V)$ 做一次线性筛，筛出每个数的最小质因子，然后每次除以其最小质因子就可以 $O(\text{log}\ V)$ 快速分解。

对于大于 $\sqrt V$ 的质因数，每个点上至多有一个，所以用树上莫队数颜色的方法维护就行，不详细讲。

对于小于等于 $\sqrt V$ 的质因数，总的种类数不会很多，也就是 $10000$ 以内的质数个数，只有 $1229$ 个。所以对于每个点，用 bitset 维护其质因数集合，再用倍增来合并路径信息。

具体的，令 $f_{u,k}$ 表示树上 $u$ 节点到其 $2^k$ 级祖先路径上的数的质因数的并集，转移是容易的。查询路径信息时，因为合并的区间可以有重复，所以可以使用类似 st 表的方式来合并，具体见代码。

但是，空间超了。发现 $f$ 数组占用了太多内存，只要把 $f$ 数组定义中的 $2^k$ 改成 $4^k$ 就行了，还能稍微平衡一下时间复杂度。再加上一些小优化就可以通过此题了。

时间复杂度 $O(V+n\sqrt q+\frac{n\pi(\sqrt V)\text{log}_4 n+q\pi(\sqrt V)}{w})$，其中 $\pi(\sqrt V)$ 指 $\sqrt V$ 以内的质数个数，$w$ 指 $64$。

代码：


```cpp
//写得很丑不要喷我 QwQ
#include<bits/stdc++.h>
#define pb push_back 
using namespace std;
const int N=3e5+5,V=1e8+5,v=V-5,vv=5.8e6,vvv=1230,B=1e4,M=10;
int isp[vv],tot,el[N<<1],st[N],ed[N],b[N],cnt,mi[V/2],pos[N<<1],t[N],a[N],n,m,x,y;
int dep[N],to[N],fa[N][M],rx,ry,dex,dey,kx,ky,lg4[N],ans[N],vis[N],res,kc,lca,yx,yy;
bool h[V];
vector<int> g[N];
bitset<vvv> f[N][M],p;
int i,j,k;
struct mo{
	int l,r,ex,id;
}q[N];
bool cmb(mo x,mo y){
	if(pos[x.l]!=pos[y.l]) return pos[x.l]<pos[y.l];
	if(pos[x.l]&1) return x.r<y.r;//莫队奇偶优化 
	return x.r>y.r;
}
void init(){
	for(i=2;i<=v;i++){
		if(!h[i]){
			isp[++tot]=i; 
			if(i&1) mi[i/2]=i;
			//小优化，偶数的最小质因子肯定是 2，不用存，下面同理 
			if(i<=B) to[i]=tot;
		}
		for(j=1;j<=tot&&i*isp[j]<=v;j++){
			h[i*isp[j]]=1; 
			if(i*isp[j]&1) mi[i*isp[j]/2]=isp[j];
			if(i%isp[j]==0) break;
		}
	}
	tot=0;
}
void dfs(int x,int y){
	el[++tot]=x; st[x]=tot;
	dep[x]=dep[y]+1;
	for(int j:g[x]){
		if(j==y) continue;
		fa[j][0]=x;
		for(int k=1;k<M;k++) 
		fa[j][k]=fa[fa[fa[fa[j][k-1]][k-1]][k-1]][k-1],
		f[j][k]=f[j][k-1]|f[fa[j][k-1]][k-1]|f[fa[fa[j][k-1]][k-1]][k-1]|f[fa[fa[fa[j][k-1]][k-1]][k-1]][k-1];
		// 把倍增的 2^k 改成 4^k 其实很简单，只需要改一下转移，并把一些地方的 if 改成 while 就行了 
		dfs(j,x);
	}
	el[++tot]=x; ed[x]=tot;
}
int kfa(int x,int k){//x 的 k 级祖先 
	for(i=M-1;~i;i--) while(k>=(1<<2*i)) x=fa[x][i],k-=(1<<2*i);
	return x;
}
int LCA(int x,int y,int id){
	if(st[x]>st[y]) swap(x,y); rx=x,ry=y;
	if(dep[x]<dep[y]) swap(x,y); yx=x,yy=y;
	for(int i=M-1;~i;i--) while(dep[fa[x][i]]>=dep[y]) x=fa[x][i];
	if(x==y) lca=x,q[id]={st[rx],st[ry],0,id};
	for(int i=M-1;~i;i--) while(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];
	if(x!=y) lca=fa[x][0],q[id]={ed[rx],st[ry],lca,id};
	//找 lca，并处理出莫队的 q 数组 
	dex=dep[yx]-dep[lca]+1,dey=dep[yy]-dep[lca]+1;
	kx=lg4[dex],ky=lg4[dey];
	p.reset();
	p|=f[kfa(yx,dex-(1<<kx*2))][kx]|f[kfa(yy,dey-(1<<ky*2))][ky];
	while(dep[fa[yx][kx]]>=dep[lca]) p|=f[yx][kx],yx=fa[yx][kx];
	while(dep[fa[yy][ky]]>=dep[lca]) p|=f[yy][ky],yy=fa[yy][ky];
	//倍增跳合并，这里只跳了常数次 
	return p.count();
}
void upd(int x){
	if(a[x]==1) return;
	if(!vis[x]) res+=(++t[a[x]]==1);
	else res-=(--t[a[x]]==0);
	vis[x]^=1;
}
void mo_algo(){
	kc=(2*n>=sqrt(m)?2*n/sqrt(m):sqrt(2*n));
	for(int i=1;i<=n*2;i++) pos[i]=(i+kc-1)/kc;
	sort(q+1,q+m+1,cmb);
	for(int i=1,l=1,r=0;i<=m;i++){
		while(l>q[i].l) upd(el[--l]);
		while(r<q[i].r) upd(el[++r]);
		while(l<q[i].l) upd(el[l++]);
		while(r>q[i].r) upd(el[r--]);
		if(q[i].ex) upd(q[i].ex);
		ans[q[i].id]+=res;
		if(q[i].ex) upd(q[i].ex);
	}
}
signed main(){
	init();
	scanf("%d%d",&n,&m);
	for(int i=4;i<=n;i++) lg4[i]=lg4[i>>2]+1;
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		while(a[i]%2==0) f[i][0][1]=1,a[i]/=2;
		while(mi[a[i]/2]&&mi[a[i]/2]<=B) f[i][0][to[mi[a[i]/2]]]=1,a[i]/=mi[a[i]/2];
		//找出每个数的质因子集合，/2 的原因见第 25 行 
		if(a[i]>1) b[++cnt]=a[i];
	}
    sort(b+1,b+cnt+1);
	cnt=unique(b+1,b+cnt+1)-b-1;
	for(int i=1;i<=n;i++) if(a[i]>1) a[i]=lower_bound(b+1,b+cnt+1,a[i])-b+1;
	//为防止和原本就等于 1 的 a[i] 重复，这里加了 1 
	for(int i=1;i<n;i++){
		scanf("%d%d",&x,&y);
		g[x].pb(y); g[y].pb(x);
	}
	dfs(1,0);
	for(int i=1;i<=m;i++){
		scanf("%d%d",&x,&y);
		ans[i]=LCA(x,y,i);//小于根号 V 的部分 
	}
	mo_algo();//大于根号 V 的部分 
	for(int i=1;i<=m;i++) printf("%d\n",ans[i]);
	return 0;
}
```

---

## 作者：shinzanmono (赞：3)

考虑一个数 $> \sqrt{V}$ 的质因子只有最多一个，所以可以把他们单拿出来，做一个树上莫队即可，时间复杂度 $O(n\sqrt {q})$。

对于小质数，只有 $\pi(\sqrt{V})$ 个，可以直接拎出来用 bitset 维护，需要写一个小常数的树链信息并查询即可。可以参考[这篇博客](https://return20071007.blog.uoj.ac/blog/7456)。时间复杂度 $O\left(\dfrac{(n+q)\pi(\sqrt{V})\log n}{w}\right)$。

剩下的我们只需要写一个线性筛即可，时间复杂度 $O(V)$。

---

## 作者：arrow_king (赞：1)

**同步发表在 P12001 中。**

感觉十分套路，但是为啥赛时被卡空间了/yiw

哦我为啥开了 $O(\frac{n\pi(V)}{w})$ 的空间，不卡我卡谁。

由于原版正解是加强版正解的一部分，所以两个都写了。

# 普通版

$n\le5\times10^4$，$V=\max\{a_i\}\le10^5$。

考虑筛出 $V$ 以内的所有质数 $p_1,p_2,\dots,p_{\pi(V)}$，并用一个二维数组 $b_{u,i}$ 表示 $a_u$ 是否有 $p_i$ 这个质因子。显然可以写 bitset 来存储。

考虑到一条路径上质因子数量就是每个节点 bitset 或起来之后的 popcount，用树剖维护这个就可以了，时间复杂度 $O(\frac{q\log^2n\pi(V)}{w})$。

# 加强版

$n\le3\times10^5,V\le10^8$。

一个套路的有关质因子的 trick 就是值域分治，用莫队搞 $>\sqrt V$ 的质因子，用上面 bitset 的算法搞 $\le\sqrt V$ 的质因子。

此时时间复杂度是 $O(n\sqrt q+\frac{q\log^2n\pi(\sqrt V)}{w})$，精细实现一下就可以把后面那一项的两只 $\log$ 去掉一个（只用线段树查询最后的一次不是跳到链顶的查询，可以预处理出来跳到链顶的答案）。

如果空间限制宽裕，也可以用倍增写上面的树链查询，复杂度同样是单 $\log$。可惜空间复杂度是 $O(\frac{n\sqrt V\log n}w)$，喜提 MLE（赛时的版本也过不了）。

代码奇丑无比，常数大到飞起，恐污列位看官之眼，故不外传。

[record](https://www.luogu.com.cn/record/210960319)

---

## 作者：yzq_yzq (赞：1)

考虑两种做法，第一种是考虑用 bitset 压颜色，然后维护链上 bitset 的或的值，第二种是将每个数质因子全部挂上去，然后树上莫队做链上数颜色。

令值域 $V=10^8$ ，对于小于等于 $B$ 的数做第一种做法，复杂度是 $\frac {(n+q)\times B} {w \ln B}$ 的，其中 $w=64$ ，然后第二种情况不难发现 $>B$ 的质因子最多 $\log_B$ 个，复杂度为 $n\sqrt q \log_B$ ，取 $B=300$ 时小于等于 $B$ 的质数有 $62$ 个，于是第一种做法直接用个 `unsigned long long` 压，然后维护个链上按位或的值，是 $(n+q)\log n$ 的，第二种此时最多只有三个质因子，复杂度就是 $n\sqrt q$ 的。

注意凉心出题人值域很大，分解时暴力过不了，要用 Rho，莫队块长取大点，大概 $1200$ ~ $1400$ 最快，然后记得奇偶优化。

代码粘了很多板子，很丑，常数很大就不放了，要的私信我。

---


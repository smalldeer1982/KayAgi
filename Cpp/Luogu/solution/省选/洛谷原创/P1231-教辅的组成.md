# 教辅的组成

## 题目背景

滚粗了的 HansBug 在收拾旧语文书，然而他发现了什么奇妙的东西。


## 题目描述

蒟蒻 HansBug 在一本语文书里面发现了一本答案，然而他却明明记得这书应该还包含一份练习题。然而出现在他眼前的书多得数不胜数，其中有书，有答案，有练习册。已知一个完整的书册均应该包含且仅包含一本书、一本练习册和一份答案，然而现在全都乱做了一团。许多书上面的字迹都已经模糊了，然而 HansBug 还是可以大致判断这是一本书还是练习册或答案，并且能够大致知道一本书和答案以及一本书和练习册的对应关系（即仅仅知道某书和某答案、某书和某练习册有可能相对应，除此以外的均不可能对应）。既然如此，HansBug 想知道在这样的情况下，最多可能同时组合成多少个完整的书册。



## 说明/提示

样例说明：

如题，$N_1=5$，$N_2=3$，$N_3=4$，表示书有 $5$ 本、练习册有 $3$ 本、答案有 $4$ 本。

$M_1=5$，表示书和练习册共有 $5$ 个可能的对应关系，分别为：书 $4$ 和练习册 $3$ 、书 $2$ 和练习册 $2$ 、书 $5$ 和练习册 $2$ 、书 $5$ 和练习册 $1$ 以及书 $5$ 和练习册 $3$。

$M_2=5$，表示数和答案共有 $5$ 个可能的对应关系，分别为：书 $1$ 和答案 $3$、书 $3$ 和答案 $1$、书 $2$ 和答案 $2$、书 $3$ 和答案 $3$ 以及书 $4$ 和答案 $3$。

所以，以上情况的话最多可以同时配成两个书册，分别为：书 $2$ 练习册 $2$ 答案 $2$、书 $4$ 练习册 $3$ 答案 $3$。


数据规模：

![](https://cdn.luogu.com.cn/upload/image_hosting/srj2v9um.png)

对于数据点 $1,2,3$，$1\le M_1,M_2\leq 20$。

对于数据点 $4\sim 10$，$1\le M_1,M_2 \leq 20000$。


## 样例 #1

### 输入

```
5 3 4
5
4 3
2 2
5 2
5 1
5 3
5
1 3
3 1
2 2
3 3
4 3
```

### 输出

```
2```

# 题解

## 作者：Siyuan (赞：43)

[$$\Large\texttt{My Blog}$$](https://hydingsy.github.io)

---

> 题目链接：[Luogu 1231](https://www.luogu.org/problemnew/show/P1231)

HansBug 眼前有 $n_1$ 本书，$n_2$ 本练习册，$n_3$ 本答案。已知一个完整的书册均应该包含且仅包含一本书、一本练习册、一本答案。现在 HansBug 只知道 $m_1$ 个可能的书和练习册的对应关系，$m_2$ 个可能的书和答案的对应关系。HansBug 想知道在这样的情况下，最多可能同时组合成多少个完整的书册。

数据范围：$n_1,n_2,n_3\le 10^4$，$m_1,m_2\le 2\times 10^4$

------

## Solution

首先我们可以发现这就是一个网络流的模型。于是顺手把 $n_1+n_2+n_3$ 个点分成 $3$ 个部分，建立源点和汇点后跑最大流。写完才发现这样是有漏洞的，如下图所示：

![](https://hydingsy.github.io/images/Luogu-1231-Composition-of-Book_1.png)

我们发现，如果按照上图跑最大流答案肯定是 $2$，而错误的原因就是**书被重复使用了多次**！所以我们还要保证**每本书只能被使用一次**！

因此我们就要引入拆点的思想。我们的目的是：即使一本书与多个联系册有关系，它流出的流量也只能是 $1$。所以我们把每个代表书的点拆成左右两个点，左边的点和练习册连边，右边的点和答案连边；当然左右对应点也要连一条容量为 $1$ 的边。那么我们可以得到下图：

![](https://hydingsy.github.io/images/Luogu-1231-Composition-of-Book_2.png)

这样我们的答案就正确了，于是直接拆点后再跑最大流即可！

时间复杂度：$O(n^2m)$

------

## Code

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>

const int N=4e4+5,M=1e6+5;
int n1,n2,n3,m,tot=1,lnk[N],ter[M],nxt[M],val[M],dep[N],cnr[N];

int id(int p,int x) {
	switch(p) {
		case 1: return x;
		case 2: return n2+x;
		case 3: return n2+n1+x;
		case 4: return n2+n1+n1+x;
	}
}
void add(int u,int v,int w) {
	ter[++tot]=v,nxt[tot]=lnk[u],lnk[u]=tot,val[tot]=w;
}
void addedge(int u,int v,int w) {
	add(u,v,w),add(v,u,0);
}
int bfs(int s,int t) {
	memset(dep,0,sizeof(dep));
	memcpy(cnr,lnk,sizeof(lnk));
	std::queue<int> q;
	q.push(s),dep[s]=1;
	while(!q.empty()) {
		int u=q.front(); q.pop();
		for(int i=lnk[u];i;i=nxt[i]) {
			int v=ter[i];
			if(!dep[v]&&val[i]) dep[v]=dep[u]+1,q.push(v);
		}
	}
	return dep[t];
}
int dfs(int u,int t,int flow) {
	if(u==t) return flow;
	int ans=0;
	for(int i=cnr[u];i&&ans<flow;i=nxt[i]) {
		cnr[u]=i;
		int v=ter[i];
		if(val[i]&&dep[v]==dep[u]+1) {
			int x=dfs(v,t,std::min(val[i],flow-ans));
			if(x) val[i]-=x,val[i^1]+=x,ans+=x;
		}
	}
	if(ans<flow) dep[u]=-1;
	return ans;
}
int dinic(int s,int t) {
	int ans=0;
	while(bfs(s,t)) {
		int x;
		while((x=dfs(s,t,1<<30))) ans+=x;
	}
	return ans;
}
int main() {
	scanf("%d%d%d",&n1,&n2,&n3);
	for(scanf("%d",&m);m--;) {
		int u,v;
		scanf("%d%d",&u,&v);
		addedge(id(1,v),id(2,u),1);
	}
	for(scanf("%d",&m);m--;) {
		int u,v;
		scanf("%d%d",&u,&v);
		addedge(id(3,u),id(4,v),1);
	}
	for(int i=1;i<=n1;++i) addedge(id(2,i),id(3,i),1);
	int S=0,T=n2+n1+n1+n3+1;
	for(int i=1;i<=n2;++i) addedge(S,id(1,i),1);
	for(int i=1;i<=n3;++i) addedge(id(4,i),T,1);
	printf("%d\n",dinic(S,T));
	return 0;
}
```



---

## 作者：localhost (赞：15)

网络流其实在想不难，主要是构图和想出是网络流难。

本题的构图思路可以表示为：

**源点->练习册->书(拆点)->答案->汇点**

注意一定要拆点，因为一本书只能用一次。

更详细一点：

![图解](https://cdn.luogu.com.cn/upload/pic/13675.png)

------------

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#define ll long long
#define N 51001
#define M 151001
#define inf 23333333
#define max(x,y) ((x)>(y)?(x):(y))
#define min(x,y) ((x)<(y)?(x):(y))
#define fur(i,x,y) for(i=x;i<=y;i++)
#define fdr(i,x,y) for(i=x;i>=y;i--)
#define Fur(i,x,y) for(ll i=x;i<=y;i++)
#define Fdr(x,y) for(ll i=x;i>=y;i--)
#define in2(x,y) in(x);in(y)
#define in3(x,y,z) in2(x,y);in(z)
#define in4(a,b,c,d) in2(a,b);in2(c,d)
#define ln pc('\n');
#define pk pc(' ');
#define outn(x) out(x);ln;
#define outk(x) out(x);pk;
#define out2(x,y) outk(x);outn(y);
#define out3(x,y,z) outk(x);out2(y,z)
#define out4(w,x,y,z) outk(w);out3(x,y,z)
#define clr(x,y) memset(x,y,sizeof(x))
#define cpy(x,y) memcpy(x,y,sizeof(x))
using namespace std;
```
/\*---------------------------------------\*/
```cpp
namespace fib{char b[300000]= {},*f=b;}
#define gc ((*fib::f)?(*(fib ::f++)):(fgets(fib::b,sizeof(fib::b),stdin)?(fib::f=fib::b,*(fib::f++)):-1))
inline void in(ll &x){x=0;char c;bool f=0;while((c=gc)>'9'||c<'0')if(c=='-')f=!f;x=c-48;while((c=gc)<='9'&&c>='0')x=x*10+c-48;if(f)x=-x;}
namespace fob{char b[300000]= {},*f=b,*g=b+300000-2;}
#define pob (fwrite(fob::b,sizeof(char),fob::f-fob::b,stdout),fob::f=fob::b,0)
#define pc(x) (*(fob::f++)=(x),(fob::f==fob::g)?pob:0)
struct foce{~foce(){pob;fflush(stdout);}} _foce;
namespace ib{char b[100];}
inline void out(ll x){if(x==0){pc(48);return;}if(x<0){pc('-');x=-x;}char *s=ib::b;while(x) *(++s)=x%10,x/=10;while(s!=ib::b) pc((*(s--))+48);}
inline void ps(char s[]){ll i=0,len=strlen(s);while(i<len)pc(s[i++]);}
```
/\*------------------------------------------------------------------------------------------------\*/

/\*------------------------------------------------------------------------------------------------\*/

```cpp
struct edge{ll next,to,w;}e[M];
ll cnt=2,n,m,st,ed;
ll head[N],d[N]={0},q[N*2];
inline void add(ll x,ll y,ll w){e[cnt].to=y;e[cnt].next=head[x];e[cnt].w=w;head[x]=cnt++;}//邻接表
inline void ins(){
    ll n1,n2,n3,m,i,x,y;
    in3(n1,n2,n3);
    st=1;//源点
    ed=n2+n1*2+n3+2;//汇点
    in(m);
    while(m--){
        in2(x,y);y++;x+=n2+1;
        add(y,x,1);add(x,y,0);
    }
    fur(i,n2+2,n2+n1+1){y=i+n1;add(i,y,1);add(y,i,0);}
    in(m);
    while(m--){
        in2(x,y);x+=n2+n1+1;y+=n1*2+n2+1;
        add(x,y,1);add(y,x,0);
    }
    fur(i,2,n2+1){add(st,i,1);add(i,st,0);}
    fur(i,n2+n1*2+2,ed-1){add(i,ed,1);add(ed,i,0);}
}
inline bool bfs(){
    ll h=0,t=1,x,i;
    clr(d,0);
    q[h]=st;d[st]=1;
    while(h<t){
        x=q[h++];if(x==ed)return 1;
        for(i=head[x];i;i=e[i].next)
        if(e[i].w&&!d[e[i].to]){
            d[e[i].to]=d[x]+1;
            q[t++]=e[i].to;
        }
    }
    return 0;
}
inline ll dfs(ll x,ll mf){
    if(x==ed)return mf;
    ll i,us=0,w;
    for(i=head[x];i;i=e[i].next)
    if(e[i].w&&d[e[i].to]==d[x]+1){
        w=mf-us;
        w=dfs(e[i].to,min(e[i].w,w));
        e[i].w-=w;
        e[i^1].w+=w;
        us+=w;
        if(us==mf)return us;
    }
    if(!us)d[x]=-1;//这种dinic加了优化，相对快一些
    return us;
}
inline ll work(){ll ans=0;while(bfs())ans+=dfs(st,inf);return ans;}
int main(){
    ins();//构图
    outn(work());//网络流
}
```
/\*
5 3 4
5
4 3
2 2
5 2
5 1
5 3
5
1 3
3 1
2 2
3 3
4 3
\*/

---

## 作者：Drinkwater (赞：10)

这道题是一道网路流入门的好题，我们先对练习册和书连一条边容量为一，然后书与答案连一条边容量为一，但是这样有问题，这样书的流量可能会很多，所以我们要把书拆成两堆，然后书一与书二之间连一条边容量为一，然后我们建一个超级源点，超级汇点，连起来，容量都是一，这样建图就好了，然后dinic跑一次，就ok

/*************************************************************************

    > File Name: 洛谷1231.cpp
    > Author: Drinkwater-cnyali
    > Created Time: 2017/2/13 16:10:45
************************************************************************/














```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
#define REP(i, a, b) for(register int i = (a), i##_end_ = (b); i <= i##_end_; ++ i)
#define DREP(i, a, b) for(register int i = (a), i##_end_ = (b); i >= i##_end_; -- i)
#define mem(a, b) memset((a), b, sizeof(a))
int read()
{
    int sum = 0, fg = 1; char c = getchar();
    while(c < '0' || c > '9') { if (c == '-') fg = -1; c = getchar(); }
    while(c >= '0' && c <= '9') { sum = sum * 10 + c - '0'; c = getchar(); }
    return sum * fg;
}
#define inf 0x3f3f3f3f
const int maxn = 1000000;
int e,be[maxn], ne[maxn], to[maxn], c[maxn];
int nb, nex, na,m1,m2;
void add(int x, int y, int z)
{
    to[e] = y, ne[e] = be[x], be[x] = e;
    c[e] = z, e++;
    to[e] = x, ne[e] = be[y], be[y] = e;
    c[e] = 0, e++;
}
int d[maxn], end;
bool bfs()
{    
    queue<int>q;
    memset(d,-1,sizeof(d));
    q.push(end),d[end] = 0;
    while(!q.empty())
    {
        int u = q.front(); q.pop();
        for(int i = be[u]; i!=-1; i = ne[i])
        {
            int v = to[i];
            if(d[v] == -1 && c[i ^ 1])
            {
                d[v] = d[u] + 1;
                q.push(v);
            }
        }
    }
    return d[0]!=-1;
}
int dfs(int x,int low)
{
    if(x == end || !low)return low;
    int ret = 0;
    for(int i = be[x]; i!=-1;i = ne[i])
    {
        int v = to[i];
        if(d[v] == d[x] - 1 )
        {
            int    k = dfs(v,min(low-ret,c[i]));
            if(k > 0)
            {
                c[i] -= k;
                c[i^1] += k;
                ret+=k;
            }
        }
    }
    return ret;
}
int dinic()
{
    int ans = 0;
    while(bfs())
    {
        int k = dfs(0,inf);
        if(k>0)ans+=k;
    }
    return ans;
}
int main()
{
    memset(be,-1,sizeof(be));    
    nb = read(); nex = read(); na = read();
    m1 = read();
    REP(i,1,m1)
    {
        int x,y;
        x = read(), y = read();
        add(y,nex+x,1);
    }
    m2 = read();
    REP(i,1,m2)
    {
        int x,y;
        x = read(), y = read();
        add(nex+nb+x,2*nb+nex+y,1);
    }
    end = 2*nb+nex+na+1;
    REP(i,1,nex)    add(0,i,1);
    REP(i,1,na) add(2*nb+nex+i,end,1);
    REP(i,1,nb) add(nex+i,nex+nb+i,1);
    printf("%d",dinic());
    return 0;
}

```

---

## 作者：ViXpop (赞：7)

来自蒟蒻的第一篇题解（实在是太蒟蒻了) OvO

这题很明显是一个网络最大流，所以用网络流dinic跑一遍就行 

但是题目只给出了每本书和答案或者练习册可能的对应关系，所以我们需要把书代表的点拆掉，建一条流量为1的边，以确保当这本书和多本答案或练习册有关系时，从这条边上流过的量为1（即每本书只可能与一本练习册和一本答案有关系），其他边开INF即可（详情看代码注释） 

网络最大流板子不会打的可以看看P3376

接下来上代码


```cpp
#include <bits/stdc++.h>//我爱万能头 

#define ll long long
#define FOR(i,l,r) for(register int i=l;i<=r;i++)
#define INF 1<<30

using namespace std;

const int N=6000001;
const int M=1001;

int to[N],nxt[N],head[N],cnt=2,w[N],ans;

int n,m,s,t,d[N],q[N],cur[N],orz;

int k , o;	 

void qxx(int x,int y,int dis)
{
    to[cnt]=y;
    w[cnt]=dis;
    nxt[cnt]=head[x];
    head[x]=cnt++;
}//前向星建图

int bfs()
{

	memset(d,-1,sizeof(d));
	int fr,tail;
	fr=1,tail=0;
	d[s]=0;
	q[1]=s;
	while(tail<fr)
	{
		int k=q[++tail];
		for(register int i=head[k];i;i=nxt[i])
		{
			int kk=to[i];
			if(d[kk]==-1&&w[i])
			{
				d[kk]=d[k]+1;
                
				q[++fr]=kk;
                
			}
		}
        
	}
	if(d[t]==-1)
    
		return 0;
	else 
    
		return 1;
}

int dfs(int x,int minflow)
{

	int a=0;
	if(x==t||!minflow)
		return minflow;
	for(register int i=cur[x];i;i=nxt[i])
	{
		int k=to[i];cur[x]=i;
		if(d[k]==d[x]+1&&(a=dfs(k,min(w[i],minflow))))
		{
			w[i]-=a;
			w[i^1]+=a;
			return a;
		}
	}
	return 0;
} 
int dinic()
{

 	ans=0;
	int STO;
	while(bfs())
	{
		STO=0;
		memcpy(cur,head,sizeof(head));//最大流优化 
		while(STO=dfs(s,INF))
		{
			ans+=STO;
		}
	}
	return ans;
}//网络流板子 

int main()
{

	/*图    源点-> 答案-> 书 -> 练习册-> 汇点*/
	//由于给的都是答案，练习册和书的关系 ，故建图时书放中间 
	scanf("%d%d%d%d",&n,&m,&k,&o);//n 书的个数  m  练习册   k  答案   o   书和练习册对应关系个数
	orz = 2 * n + m + k ;//拆点后所有点的个数  
	t = orz + 1;//汇点 
	s = 0;//源点 
    
	FOR(i , k + 1 , n + k)
	{
		qxx(i ,i + n, 1);
		qxx(i + n ,i , 0);
	}  
	//书本拆点 
    
	FOR(i , 1 , o)
	{
		int l , r;//l 书  r 练习册 
		scanf ( "%d%d",&l ,&r);
		qxx(l + n + k , r + 2 * n + k , INF);
        qxx(r + 2 * n + k , l + n + k , 0);
	}//建边1 
    
	int e;
	scanf("%d",&e);//e  书和答案对应关系个数
    
	FOR(i , 1 , e )
	{
		int l , r;// l  书  r  答案 
		scanf("%d%d", &l, &r);
		qxx(r , l + k ,INF);
		qxx(l + k , r , 0);
	}//建边2 
	FOR(i , 1 , k)
	{
		qxx(s , i , 1);
		qxx(i , s , 0);
	}//源点答案建边 
	FOR(i , 1 , m)
	{
		qxx(i + 2 * n + k , t , 1); 
		qxx(t , i + 2 * n + k , 0);
	}//汇点练习册建边 
	printf("%d",dinic());
    return 0;//快乐结束 
}
```

谢谢管理员大大，求通过qwq

---

## 作者：陈雪森 (赞：4)

题目中提到书，练习册，答案，三者之间的关系；求得答案是最多；所以找最大流；

此题一看就是三分图之类的题，这类题我认为都有一种套路；把其中用到最多的东西进行拆分。

主要思路：
1. 例如此题将书拆分成两个点；

2.源点与练习册，答案与汇点，书与书之间都连流量为1得边；

3. 再将答案与书，练习册与书之间的边连起来；就构造出了图；

4. 构造出图后，此题就变得很简单了，在图上跑Dinic即可求出答案；

```cpp
#include<cstdio>
#include<cstring>
#include<queue>
#include<algorithm>
using namespace std;
#define N 600010
#define M 800010
int ver[M],nxt[M],edge[M],tot=1,head[N],d[N];
int n1,n2,n3,m1,m2,maxflow,s,t,inf=1<<30;//n1书的数量，n2练习册的数量，n3答案的数量，
//m1练习册和书的关系数量；m2答案和书关系的数量； 
void add(int x,int y,int z){
	ver[++tot]=y;
	nxt[tot]=head[x];
	edge[tot]=z;
	head[x]=tot;
}
bool bfs(){//构造分层图； 
	memset(d,0,sizeof(d));
	queue<int>q;
	q.push(s); d[s]=1;
	while(q.size()){
		int x=q.front();
		q.pop();
		for(int i=head[x];i;i=nxt[i]){
			int y=ver[i],z=edge[i];
			if(z&&(!d[y])){
				q.push(y);
				d[y]=d[x]+1;
				if(y==t) return 1;//说明有增广路 
			}
		}
	}
	return 0;
}
int dinic(int x,int flow){//在分层图上增广 
	if(x==t) return flow;
	int rest=flow,k;
	for(int i=head[x];i&&rest;i=nxt[i]){
		int z=edge[i],y=ver[i];
		if(z&&d[y]==d[x]+1){
			k=dinic(y,min(rest,z));
			if(!k) d[y]=0;//剪枝，去掉增广完毕的点 
			edge[i]-=k;
			edge[i^1]+=k;
			rest-=k;
		}
	} 
	return flow-rest;
}
int main(){
	scanf("%d%d%d%d",&n1,&n2,&n3,&m1);
	t=n1+n2+n3+n1+1;//汇点，s为源点； 
	for(int i=1;i<=n2;i++) add(s,i,1),add(i,s,0);//连源点和练习册之间的边；（注意都是双向边） 
	for(int i=1;i<=n3;i++) add(i+n1+n2+n1,t,1),add(t,i+n1+n2+n1,0);//连接答案和汇点之间的边； 
	for(int i=1;i<=n1;i++) add(i+n2,i+n2+n1,1),add(i+n1+n2,i+n2,0);//将书拆点后，连接书与书之间的边； 
	for(int i=1;i<=m1;i++){
		int x,y;
		scanf("%d%d",&x,&y);
		add(y,x+n2,1);//连练习册与书（1）之间的边； 
		add(x+n2,y,0);
	}
	scanf("%d",&m2);
	for(int i=1;i<=m2;i++){
		int x,y;
		scanf("%d%d",&x,&y);
		add(x+n2+n1,y+n2+n1+n1,1);//连书（2）与答案之间的边； 
		add(y+n2+n1+n1,x+n2+n1,0);
	}
	int flow=0;
	while(bfs())//判断有无增广路； 
	while((flow=dinic(s,inf)))maxflow+=flow;//求最大流 
	printf("%d",maxflow);
	return 0;
} 
```


---

## 作者：Yeji_ (赞：3)

## 教辅的组成
### 前言
刚学了网络流，过来练练手，没想到是个三分图匹配。

### 思路
原先想直接暴力，直接上匈牙利算法的，但是这毕竟是网络流还是上吧。

#### 基本思路
建一个超级原点，一个超级汇点，在把三种东西有关系都连在一起，放心的让程序去跑吧！！！

~~提交，WA声一片~~

#### 仔细思考
我们可以列出一些极致的情况

书只有一本，练习册和答案有两本，那么我们这样无脑跑，求出来的答案一定是二，但是正确答案是一。

#### 理由：
若只有一个点，就不会在Dinic算法的判断之内，所以我们要引出一个极其重要的点

### 拆点
这一类问题，一个图给出了点权而不是边权，我们在连接边的时候就显得十分不好操作

这个时候我们往往就会有这样一种操作，把每个点拆成入点和出点

题目给出的连边均由每个点的出点连向入点，然后每个点的入点和出点之间连一条流量为点权的边，就可以满足点权的限制了。

所以这道就很容易解了

### 代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
const int inf=2147483647;
int n,m,n1,n2,n3,m1,m2,x,y,T,S,ans,deep[400005];
struct Edge
{
    int next,to,w;
}edge[800050];
int st[400005],cur[400005],nume=-1;
inline int bo1(int x){return x*4;}
inline int bo2(int x){return x*4+1;}
inline int ex(int x){return x*4+2;}
inline int an(int x){return x*4+3;}
inline void adde(int f,int t,int w)
{
    edge[++nume].next=st[f];
    edge[nume].to=t;
    edge[nume].w=w;
    st[f]=nume;
}
inline int bfs()
{
    memset(deep,0,sizeof(deep));
    queue<int> q;
    int now,i;
    q.push(S);
    deep[S]=1;
    while(!q.empty())
    {
        now=q.front();
        q.pop();
        for(i=st[now];i!=-1;i=edge[i].next)
            if(edge[i].w!=0&&deep[edge[i].to]==0)
            {
                deep[edge[i].to]=deep[now]+1;
                q.push(edge[i].to);
            }
    }
    if(deep[T]==0)
        return 0;
    return 1;
}
int dfs(int i,int m)
{
    int t;
    if(i==T)
        return m;
    for(int& j=cur[i];j!=-1;j=edge[j].next)
        if((deep[edge[j].to]==deep[i]+1)&&edge[j].w!=0)
        {
            t=dfs(edge[j].to,min(m,edge[j].w));
            if(t>0)
            {
                edge[j].w-=t;
                edge[j^1].w+=t;
                return t;
            }
        }
    return 0;
}
inline int dinic()
{
    int t,i;
    while(bfs())
    {
        for (i=1;i<=n;i++)
            cur[i]=st[i];
        while(t=dfs(S,inf))
            ans+=t;
    }
    return ans;
}
int main()
{
    int i;
    memset(st,-1,sizeof(st));
    nume=-1;
    scanf("%d%d%d",&n1,&n2,&n3);
    S=1;n=(max(max(n1,n2),n3)+1)*4;T=n;
    ans=0;
    for(i=1;i<=n2;i++)
    {
        adde(S,ex(i),1);
        adde(ex(i),S,0);
    }
    scanf("%d",&m1);
    for(i=1;i<=m1;i++)
    {
        scanf("%d%d",&x,&y);
        adde(ex(y),bo1(x),1);
        adde(bo1(x),ex(y),0);
    }
    for(i=1;i<=n1;i++)
    {
        adde(bo1(i),bo2(i),1);
        adde(bo2(i),bo1(i),0);
    }
    scanf("%d",&m2);
    for(i=1;i<=m2;i++)
    {
        scanf("%d%d",&x,&y);
        adde(bo2(x),an(y),1);
        adde(an(y),bo2(x),0);
    }
    for(i=1;i<=n3;i++)
    {
        adde(an(i),T,1);
        adde(T,an(i),0);
    }
    printf("%d\n",dinic());
}
```
#### 注意：在循环变量后加&就可以跑的很快哦！！！具体含义百度


---

## 作者：GavinZheng (赞：3)

# Luogu1231 教辅的组成
## 两个小trick
刚刚写过了网络流模板。准备来写一点练习题。刚拿到这道题其实比较懵。完全找不到入手点。经过学习，我发现网络流操作有两个小trick。

1.**加入虚拟源点和汇点。**通过虚拟源点和汇点，来将几个图（或几个组合）变成一个有向图，就能在上面跑网络流了。

2.**建立虚拟“点对”。**因为网络流可以限制每条边的流量不超过容量限制。但是却不能限制每个点经过的流量。这时候我们就需要将任意一个点$x$都生成一个对应点$x'$。并建立一个$x->x'$的有向边（容量为1）。所有入边连接在$x$上，所有出边连接在$x'$上。这样，任意一个经过点$x$的流都会被$x->x'$这条边限制，使得只有一条边经过点$x$。
大概就是这个样子 
![](https://gavin-1257756441.cos.ap-chengdu.myqcloud.com/题解/luogu1231/1.png)

## 思路
### 点的处理
我们首先把数组开成双倍空间，那么一下就是所有点在数组中的编号。**这里设$N=N1+N2+N3$**

- 1~N1 对应N1(书的个数)
- N1+1~N1+N2 对应N2（练习册的个数）
- N1+N2+1~N1+N2+N3 对应N3（答案的个数）

$\forall x,index[x']=index[x]+N$

点表示完后，我们就可以处理边了。
### 边的处理
还是按照网络流基本操作来做。但是网络流存边有个小问题。那就是邻接表的$cnt$初值必须要设为1。才能在$++cnt$时保证成对变换的匹配性。
## 代码

### EK版

一开始听了一个叫hwy的混蛋。写了个EK。长这样的

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
#define maxn 100500
#define inf (int)(1e9+1000)
#define maxm 100500
bool visit[maxn];
int head[maxn],pre[maxn];
int cnt=1,m1,m2,n,n1,n2,n3,incf[maxn],maxflow;
int s=90401,t=90402;
struct gg{
    int u,v,w,next;
}side[maxm*4];
void insert(int u,int v,int w){
//	if(u==3){
//		int gg=1;
//	}
    side[++cnt]=(gg){u,v,w,head[u]};
    head[u]=cnt;
}
inline int num(int type,int num){//三种type分别代表书，练习册，答案。重复代表映射点。
    if(type==1)return num;
    if(type==2)return n1+num;
    if(type==3)return n1+n2+num;
    if(type==11)return num+n;
    if(type==22)return n1+num+n;
    if(type==33)return n1+n2+num+n;
    return 0;
}
bool bfs(){
    memset(visit,0,sizeof(visit));
    incf[s]=inf;visit[s]=1;
    queue<int>line;line.push(s);
    while(!line.empty()){
        int now=line.front();line.pop();
        for(int i=head[now];i;i=side[i].next){
            int tar=side[i].v;int w=side[i].w;
            if(visit[tar]||!w)continue;
            incf[tar]=min(incf[now],1);
            visit[tar]=1;pre[tar]=i;
            line.push(tar);if(tar==t)return 1;
        }
    }
    return 0;
}
void update(){
    maxflow+=incf[t];
    for(int i=t;i!=s;i=side[pre[i]^1].v){
//		cout<<i<<endl;
        side[pre[i]].w-=incf[t];
        side[pre[i]^1].w+=incf[t];
    }
    return;
}
int main(){
//	freopen("in.txt","r",stdin);
    scanf("%d%d%d%d",&n1,&n2,&n3,&m1);
    n=n1+n2+n3;
    for(int i=1;i<=n;i++){//建立映射点对
        insert(i,i+n,1);
        insert(i+n,i,0);
    }
    for(int i=1;i<=n2;i++){//建立源点所有练习册的连接
        insert(s,num(2,i),1);
        insert(num(2,i),s,0);
    }
    for(int i=1;i<=n3;i++){//建立所有答案和汇点的连接
        insert(num(33,i),t,1);
        insert(t,num(33,i),0);
    }
    for(int i=1;i<=m1;i++){
        int x,y;scanf("%d%d",&x,&y);
        insert(num(22,y),num(1,x),1);//将练习册的映射点和书相连
        insert(num(1,x),num(22,y),0);
    }
    scanf("%d",&m2);
    for(int i=1;i<=m2;i++){
        int x,y;scanf("%d%d",&x,&y);
        insert(num(11,x),num(3,y),1);//将书的映射点和答案相连。
        insert(num(3,y),num(11,x),0);
    }
    while(bfs()){update();}
    cout<<maxflow;
    return 0;
}
```

然后。。。

![](https://gavin-1257756441.cos.ap-chengdu.myqcloud.com/题解/luogu1231/2.png)

~~滚回去学Dinic~~

### Dinic版

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
#define maxn 10500
#define maxm 105000
#define inf (1e9+1000)
int head[maxn];
int cnt=1;
struct gg{
    int u,v,w,next;
}side[maxm*2];
int n,m,s,t,rk[maxn];
void insert(int u,int v,int w){
    side[++cnt]=(gg){u,v,w,head[u]};head[u]=cnt;return;
}
int maxflow=0;
bool bfs(){
    memset(rk,0,sizeof(rk));
    rk[s]=1;
    queue<int>line;line.push(s);
    while(!line.empty()){
        int now=line.front();line.pop();
        for(int i=head[now];i;i=side[i].next){
            int tar=side[i].v;
            if(!side[i].w)continue;
            if(rk[tar])continue;
            rk[tar]=rk[now]+1;line.push(tar);
        }
    }
    if(rk[t])return 1;
    return 0;
}
int dfs(int now,int flow){
    if(now==t){return flow;}
    int rest=flow;int tot=0;
    for(int i=head[now];i;i=side[i].next){
        int tar=side[i].v,w=side[i].w;
        if(!w||rk[now]+1!=rk[tar])continue;
        int used=dfs(tar,min(w,rest));rest-=used;tot+=used;
        side[i].w-=used;side[i^1].w+=used;
    }
    return tot;
}
void dinic(){
    while(bfs()){
        maxflow+=dfs(s,inf);
    }
}
int main(){
    scanf("%d%d%d%d",&n,&m,&s,&t);
    for(int i=1;i<=m;i++){
        int u,v,w;scanf("%d%d%d",&u,&v,&w);
        insert(u,v,w);insert(v,u,0);
    }
    dinic();
    cout<<maxflow;
    return 0;
}
```



---

## 作者：斯德哥尔摩 (赞：3)

网络流经典。。。

为什么没有人写结构体前向星？？？

来一发。。。

注：
1.数组大小开10倍，不然就像楼下说的那样会 WA。。。

2.将每个书拆点。

3.话说一开始我以为是二分图最大匹配，十分钟一发匈牙利，结果 WA 的很惨。。。

后来才发现我的匈牙利是 O（n^2），而 n<=1W 。。。

我也很想知道它是怎么 WA 的，不应该是 TLE 吗？？？

不过，至少得出一点：此题不要用匈牙利。。。

附上 Dinic 的代码：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<queue>// STL 的队列，懒人专用，懒到不想手写。。。
#define MAXN 100010//数组大小开 10 倍
#define MAX 999999999//最大值
using namespace std;
int n,m,k,s,t,c=2,ans=0;//结构体前向星的起始下标我习惯于从2开始，0也没问题，但不能从1开始。。。
int head[MAXN],deep[MAXN];
struct node{//结构体前向星
    int next,to,w;
}a[MAXN<<1];
inline int read(){//弱弱的读优。。。
    int date=0,w=1;char c=0;
    while(c<='0'||c>'9'){if(c=='-')w=-1;c=getchar();}
    while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
    return date*w;
}
void add(int u,int v,int w){//加边建图
     a[c].to=v;a[c].w=w;正向边·
     a[c].next=head[u];
     head[u]=c++;
     a[c].to=u;a[c].w=0;//反向边
     a[c].next=head[v];
     head[v]=c++;
}
bool bfs(){//广搜，应该都知道是 分层 用的吧。。。
     int u,v;
     queue<int> q;
     memset(deep,0,sizeof(deep));//清空
     deep[s]=1;
     q.push(s);
     while(!q.empty()){
                       u=q.front();
                       q.pop();
                       for(int i=head[u];i;i=a[i].next){
                               v=a[i].to;
                               if(a[i].w&&!deep[v]){//枚举每一条正向边
                                                    deep[v]=deep[u]+1;
                                                    if(v==t)return true;//达到汇点，说明有通路，直接跳出，开始增广路
                                                    q.push(v);//入队
                                                    }
                               }
                       }
     return false;//若无通路
}
int dfs(int x,int limit){//增广路
    if(x==t)return limit;
    int v,sum,cost=0;
    for(int i=head[x];i;i=a[i].next){
            v=a[i].to;
            if(a[i].w&&deep[v]==deep[x]+1){//剪枝
                                           sum=dfs(v,min(limit-cost,a[i].w));//递归，求能增广得流量
                                           if(sum>0){
                                                     a[i].w-=sum;
                                                     a[i^1].w+=sum;//“^”求另一条边，这就是为什么结构体前向星下标不能从1开始之原因
                                                     cost+=sum;//流量增加
                                                     if(cost==limit)break;
                                                     }
                                           else deep[v]=-1;//剪枝
                                           }
            }
    return cost;
}
int dinic(){//工作函数 So easy!
    int ans=0;
    while(bfs())
    ans+=dfs(s,MAX);
    return ans;
}
int main(){
    int f,u,v;
    n=read();m=read();k=read();//读入
    f=read();
    for(int i=1;i<=f;i++){
            u=read();v=read();
            add(v,u+m,1);//从答案向书加边
            }
    f=read();
    for(int i=1;i<=f;i++){
            u=read();v=read();
            add(u+n+m,v+n+n+m,1);//从书的拆点向习题加边
            }
    for(int i=1;i<=n;i++)add(i+m,i+n+m,1);//将书与书的拆点连接
    for(int i=1;i<=m;i++)add(n+m+k+n+1,i,1);//源点连到答案
    for(int i=1;i<=k;i++)add(i+n+n+m,n+m+k+n+2,1);//习题连到汇点
    s=n+m+k+n+1;t=n+m+k+n+2;//设定源点与汇点。
    printf("%d\n",dinic());//解决并输出
    while(1);//反抄袭
    return 0;
}
**抄袭可耻，领悟光荣！抄袭可耻，领悟光荣！！抄袭可耻，领悟光荣！！！**
```

---

## 作者：Mr_Wolfram (赞：3)

[蒟蒻博客](http://www.cnblogs.com/Mr-WolframsMgcBox/)


看了这么多网络流题解,难道就没有人用二分图做吗?

本题与[P1402酒店之王](https://www.luogu.org/problemnew/show/P1402)极为相似.


有多个匹配条件的二分图的做法


我们回忆一下二分图匹配的匈牙利算法的具体流程，它是通过寻找增广路来判断最大匹配数的，我们再观察一下题目中的两个条件，只有两个条件都满足，才算找到一条增广路，所以我们可以分别寻找判断两个条件。即对两个二分图交替匹配，只有两个二分图都能找到增广路时，才算是一次匹配完成。

具体代码可以参考酒店之王那道题.


---

## 作者：Ireliaღ (赞：2)

**ISAP最大流+指针存图**

第一眼三分图匹配。但是由于**书不能多次选用**，要对中层进行拆点限制流量。

## 建图

- 设超级原点为$0$，超级汇点为$n_1 \times 2 + n_2 + n_3 + 1$

- 对于$\forall i \in [1, n_1]$，从$i$向$n_1 + i$建立容量为$1$的边

- 对于$\forall i \in [1, n_2]$，从$0$向$n_1 \times 2 + i$建立容量为$1$的边

- 对于$\forall i \in [1, n_3]$，从$n_1 \times 2 + n_2 + i$向$n_1 \times 2 + n_2 + n_3 + 1$建立容量为$1$的边

- 对于可以匹配的$\forall i \in [1, n_2]$，$\forall j \in [1, n_1]$，从$n_1 \times 2 + i$向$j$建立容量为$1$的边

- 对于可以匹配的$\forall i \in [1, n_1]$，$\forall j \in [1, n_3]$，从$n_1 + i$向$n_1 \times 2 + n_2 + j$建立容量为$1$的边

## 代码

ISAP+当前弧

```cpp
// luogu-judger-enable-o2
// luogu-judger-enable-o2
// luogu-judger-enable-o2
// luogu-judger-enable-o2
#include <iostream>
#include <algorithm>
#include <queue>
#include <cstring>

using namespace std;

const int MAXN = 1e4 + 5;
const int INF = 0x3f3f3f3f;

int n1, n2, n3;

struct Edge{
    int to, val;
    Edge *nxt, *ops;
    Edge(int to, int val, Edge *nxt): to(to), val(val), nxt(nxt) {}
};

Edge *head[MAXN << 2], *cur[MAXN << 2];

void AddEdge(int u, int v, int w) {
    head[u] = new Edge(v, w, head[u]);
    head[v] = new Edge(u, 0, head[v]);
    head[u]->ops = head[v]; head[v]->ops = head[u];
}

int s, t, gap[MAXN << 2], dep[MAXN << 2], res;

void Bfs() {
    memset(gap, 0, sizeof(gap));
    memset(dep, -1, sizeof(dep));
    dep[t] = 0; gap[dep[t]]++;
    queue<int> q;
    q.push(t);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (Edge *e = head[u]; e; e = e->nxt) {
            int v = e->to;
            if (dep[v] != -1) continue;
            dep[v] = dep[u] + 1;
            gap[dep[v]]++;
            q.push(v);
        }
    }
}

int Dfs(int u, int flow) {
    if (u == t) {
        res += flow;
        return flow;
    }
    int used = 0;
    for (Edge *&e = cur[u]; e; e = e->nxt) {
        int v = e->to;
        if (e->val && dep[v] == dep[u] - 1) {
            int mi = Dfs(v, min(e->val, flow - used));
            if (mi) {
                used += mi;
                e->val -= mi;
                e->ops->val += mi;
            }
            if (used == flow) return used;
        }
    }
    cur[u] = head[u];
    gap[dep[u]]--;
    if (gap[dep[u]] == 0) dep[s] = n1 * 2 + n2 + n3 + 3;
    dep[u]++;
    gap[dep[u]]++;
    return used;
}

void Isap() {
    res = 0;
    Bfs();
    memcpy(cur, head, sizeof(head));
    while (dep[s] <= n1 * 2 + n2 + n3 + 2) Dfs(s, INF);
}

int main() {
    ios :: sync_with_stdio(false); cin.tie(NULL);
    cin >> n1 >> n2 >> n3;
    s = 0; t = n1 * 2 + n2 + n3 + 1;
    int m;
    cin >> m;
    for (int i = 1; i <= n2; i++) AddEdge(0, n1 * 2 + i, 1);
    for (int i = 1; i <= n3; i++) AddEdge(n1 * 2 + n2 + i, t, 1);
    for (int i = 1; i <= n1; i++) AddEdge(i, n1 + i, 1);
    for (int i = 1; i <= m; i++) {
        int x, y;
        cin >> x >> y;
        AddEdge(n1 * 2 + y, x, 1);
    }
    cin >> m;
    for (int i = 1; i <= m; i++) {
        int x, y;
        cin >> x >> y;
        AddEdge(n1 + x, n1 * 2 + n2 + y, 1);
    }
    Isap();
    cout << res << endl;
    return 0;
}
```

---

## 作者：arfa (赞：2)

$Pascal$ 跑到了第 $2$ 页!!!

声明 : 图片来自 [$programmy$](https://blog.csdn.net/mmy1996/article/details/52305135) 。

这是一道 **拆点** 的基础题目。首先,我们可以知道这是一道“三分图”,我们可以用网络流来搞。

但是发现我们要赋值的是点的流量而不是边的流量,所以我们可以**拆点**。

本来是这样子的 :

![](https://i.loli.net/2018/10/31/5bd93ce2c9599.jpg)

然后变成这样子 :

![](https://i.loli.net/2018/10/31/5bd93ce2d72e3.jpg)

所以这个样例会变成这样子 (草稿不要介意) :

![](https://cdn.luogu.com.cn/upload/pic/41048.png)

中间有两个 $n$ 对吧。建完模型跑最大流就可以了。

当然要跑 $ISAP$ 啦对吧。

```pascal
// luogu-judger-enable-o2
Uses math;

var
    value,reach,next:array[-1..210000] of longint;
    gap,dis,cnt:array[-1..81000] of longint;
    n,m,z,l,r,k,i,j,sum,tot,sink,source,number,maxflow:longint;

procedure add(l,r:longint);
begin
    inc(tot); reach[tot]:=r; value[tot]:=1; next[tot]:=cnt[l]; cnt[l]:=tot;
    inc(tot); reach[tot]:=l; value[tot]:=0; next[tot]:=cnt[r]; cnt[r]:=tot;
end;

function Dfs(now,flow:longint):longint;
var i,k,mindis,ret:longint;
begin
    mindis:=n-1; ret:=flow;
    if now=sink then exit(flow);
    i:=cnt[now];
    while i<>-1 do
    begin
        if value[i]>0 then
        begin
            if dis[now]=dis[reach[i]]+1 then
            begin
                k:=Dfs(reach[i],min(ret,value[i]));
                dec(value[i],k);inc(value[i xor 1],k);
                dec(ret,k);
                if dis[source]>=n then exit(flow-ret);
                if ret=0 then break;
            end;
             mindis:=min(mindis,dis[reach[i]]);
        end;
        i:=next[i];
    end;
    if ret=flow then
    begin
        dec(gap[dis[now]]);
        if gap[dis[now]]=0 then dis[source]:=n;
        dis[now]:=mindis+1;
        inc(gap[dis[now]]);
    end;
    exit(flow-ret);
end;

begin
    filldword(cnt,sizeof(cnt) div 4,maxlongint*2+1); tot:=1;
    read(n,m,z); source:=1; sink:=n+n+m+z+2;
    for i:=1 to m do add(source,i+1); // 连超源和练习册
    for i:=1 to z do add(i+n+n+m+1,sink); // 连答案和超汇
    for i:=1 to n do add(i+m+1,i+m+n+1); // 克隆一些书本然后相连
    read(k); for i:=1 to k do begin read(l,r); l:=l+m+1; r:=r+1; add(r,l); end; // 连练习册和书本,注意要连 r -> l 而不是 l -> r,当然你的建模不一样也是可以的
    read(k); for i:=1 to k do begin read(l,r); l:=l+n+m+1; r:=r+n+n+m+1; add(l,r); end; // 连书本和答案
    n:=sink; gap[source]:=n;
    while dis[source]<n do inc(maxflow,Dfs(source,maxlongint)); // 跑 ISAP
    writeln(maxflow); 
end.
```

---

## 作者：pupuvovovovovo (赞：2)

从每本作业本向某些书连一条边，从每本书向某些答案连一条边，区分一下三类本子，再建超级源点、超级汇点就行了，一步一步打。

（爆10专用）你爆10大概是因为这类数据能把你卡掉。

1 2 2
2
1 2
1 1
2
1 2
1 1（答案是1，你会打2）解决方法是把每本书的点容量设为1，然后拆点，把每本书对应的点拆成两个点，中间添一条容量为1的边。

（爆30专用）数组开大10倍。

```cpp
#include<bits/stdc++.h>
using namespace std;
int la[200002],en[2000001],rev[2000001],c[2000001],ne[2000001];
int q[200003],level[200002],now[200002];
int n,n1,n2,n3,m1,m2,top;
void bfs(int s){
    memset(level,-1,sizeof(level));
    memset(q,0,sizeof(q));
    int h=0,t=1;
    q[1]=s;
    level[s]=0;
    while (h<t)
      for (int i=la[q[++h]];i;i=ne[i])
        if (c[i]>0&&level[en[i]]<0){
            level[en[i]]=level[q[h]]+1;
            q[++t]=en[i];
        }
}
int dfs(int u,int t,int f){
    if (u==t) return f;
    for (int &i=now[u];i>0;i=ne[i])
      if (c[i]>0&&level[u]<level[en[i]]){
          int d=dfs(en[i],t,min(f,c[i]));
          if (d>0){
              c[i]-=d;
              c[rev[i]]+=d;
              return d;
          }
      }
    return 0;
}
int max_flow(int s,int t){
    int flow=0;
    while (1){
        bfs(s);
        if (level[t]<0) return flow;
        for (int i=0;i<=n+n1;i++) now[i]=la[i];
        int f;
        while (f=dfs(s,t,1000000000)>0) flow+=f; 
    }
}
void add(int x,int y,int z){
    ne[++top]=la[x];
    en[top]=y;
    c[top]=z;
    rev[top]=top+1;
    la[x]=top;
    ne[++top]=la[y];
    en[top]=x;
    c[top]=0;
    rev[top]=top-1;
    la[y]=top;
}
int main(){
    scanf("%d%d%d",&n1,&n2,&n3);
    n=n1+n2+n3;
    scanf("%d",&m1);
    for (int i=1;i<=m1;i++){
        int a,b;
        scanf("%d%d",&a,&b);
        add(b+n1,a,1);
    }
    scanf("%d",&m2);
    for (int i=1;i<=m2;i++){
        int a,b;
        scanf("%d%d",&a,&b);
        add(a+n,b+n1+n2,1);
    }
    for (int i=1;i<=n1;i++) add(i,i+n,1);
    for (int i=1;i<=n2;i++) add(0,i+n1,1);
    for (int i=1;i<=n3;i++) add(i+n1+n2,n+n1+1,1);
    int ans=max_flow(0,n+n1+1);
    printf("%d",ans);
    return 0;
}
```

---

## 作者：Jason_Yvan (赞：1)

看还没有人发题解，赶快来发一篇题解（嘿嘿~~）

因为是以每本书延伸的关系图，所以对于一本书来讲它只能跟一本答案和一本练习册配套，那么就拆点

连边：超源点st->练习册->书的入点->出点->答案->超汇点ed

用普通dinic直接跑的话会TLE 7 个点，

所以我们加一个小小的优化：当前弧优化（不懂的可以上网百度）

现在直接上代码： C++

/*************************************************************************

    > Author: wzw-cnyali
    > Created Time: 2017/2/12 14:20:28
************************************************************************/
















```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
#define REP(i, a, b) for(register int i = (a), i##_end_ = (b); i <= i##_end_; ++ i)
#define DREP(i, a, b) for(register int i = (a), i##_end_ = (b); i >= i##_end_; -- i)
#define debug(...) fprintf(stderr, __VA_ARGS__)
#define mem(a, b) memset((a), b, sizeof(a))
template<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }
template<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }
const int Size = 1500010;
const int inf = 0x3f3f3f3f;
int read()
{
    int sum = 0, fg = 1; char c = getchar();
    while(c < '0' || c > '9') { if (c == '-') fg = -1; c = getchar(); }
    while(c >= '0' && c <= '9') { sum = sum * 10 + c - '0'; c = getchar(); }
    return sum * fg;
}
int be[Size], nxt[Size], to[Size], w[Size], e;
void add(int x, int y, int z)
{
    to[e] = y;
    nxt[e] = be[x];
    be[x] = e;
    w[e] = z;
    e++;
}
int dis[Size];
int Start, End;
int bfs()
{
    queue <int> q;
    mem(dis, -1);
    q.push(End);
    dis[End] = 0;
    while(!q.empty())
    {
        int u = q.front();
        q.pop();
        for(int i = be[u]; i != -1; i =nxt[i])
        {
            int v = to[i];
            if(w[i ^ 1] && dis[v] == -1)
            {
                dis[v] = dis[u] + 1;
                q.push(v);
            }
        }
    }
    return dis[Start] != -1;
}
int cur[Size];
int dfs(int x, int flow)
{
    if(x == End) return flow;
    int k;
    int ret = 0;
    for(int i = (cur[x] != -1 ? cur[x] : be[x]); i != -1; i = nxt[i])
    {
        int y = to[i];
        if(dis[y] == dis[x] - 1 && w[i] && (k = dfs(y, min(flow - ret, w[i]))))
        {
            w[i] -= k;
            w[i ^ 1] += k;
            ret += k;
            cur[x] = i;
            if(ret == flow) return ret;
        }
    }
    return ret;
}
int dinic()
{
    int ans = 0, k;
    while(bfs())
    {
        mem(cur, -1);
        while((k = dfs(Start, inf)))
        {
            ans += k;
        }
    }
    return ans;
}
void init()
{
    mem(be, -1);
    e = 0;
}
int main()
{
    init();
    int n1 = read(), n2 = read(), n3 = read();
    int m1 = read();
    REP(i, 1, m1)
    {
        int x = read(), y = read();
        add(y, x + n2, 1);
        add(x + n2, y, 0);
    }
    int m2 = read();
    REP(i, 1, m2)
    {
        int x = read(), y = read();
        add(x + n1 + n2, y + n1 + n1 + n2, 1);
        add(y + n1 + n1 + n2, x + n1 + n2, 0);
    }
    REP(i, 1, n1)
    {
        add(i + n2, i + n1 + n2, 1);
        add(i + n1 + n2, i + n2, 0);
    }
    Start =0;
    End = n1 + n1 + n2 + n3 + 2;
    REP(i, 1, n2)
    {
        add(Start, i , 1);
        add(i, Start, 0);
    }
    REP(i, 1, n1)
    {
        add(i + n1 + n1 + n2, End, 1);
        add(End, i + n1 + n1 + n2, 0);
    }
    printf("%d\n", dinic());
    return 0;
}

```

---

## 作者：moye到碗里来 (赞：1)

练习网络流，发现网络流难得不是写出来模板，其实是没有啥变化的，你那个dinic打出来跟模板可以没有任何区别，但是难的是建图和想出来这是网络流。

首先我们可以分析一下，这道题，实际上是个匹配的问题，而且是一一对应的匹配，所以我们才能把流量设为1，仔细想想网络流的原理，是对这张图进行增广，如果有一条路能够从头走到尾就是一个匹配，并且每一条路只能走一次，那这样想是不是就觉得可以用网络流了呢？因为流量都是一，所以一条路增广后，流量的增加也一定是1，因此跑完dinic后的答案即为所求。

对于这种多源多汇的题，我们可以建一个超级源点和超级汇点，本身这两个点无任何意义，只是为了跑的时候更方便，因为从超级源点跑到超级汇点是一定会经过其中一个源点和汇点，那么就满足了之前的要求，又知道源点之间无流，汇点之间无流，所以可以这样跑。

然后为啥要把书分成两堆？我也不是很懂，可能是因为不分两堆的话不好控制流量？因为这样跑必须保证每次流都是1.反正就是练习册-》书-》书—》答案，反正怎么输入怎么建图= =

然后就是dinic模板，我是直接背的模板= =

    
```cpp
#include<bits/stdc++.h>
using namespace std;
#define INF 0x3f3f3f
struct node
{
    int from,to,cap,flow;
};
vector<node>edges;
vector<int>load[1000005];
int n,m,s,t;
int cur[1000005];
int d[1000005];
void add(int u,int v,int w)
{
    edges.push_back((node){u,v,w,0});
    edges.push_back((node){v,u,0,0});
    int x=edges.size();
    load[u].push_back(x-2);
    load[v].push_back(x-1);
}
bool bfs()
{
    memset(d,0,sizeof(d));
    queue<int>q;
    q.push(s);
    d[s]=1;
    while(!q.empty())
    {
        int u=q.front();q.pop();
        int x=load[u].size();
        for(int i=0;i<x;i++)
        {
            node &v=edges[load[u][i]];
            if(!d[v.to]&&v.cap>v.flow)
            {
                d[v.to]=d[u]+1;
                q.push(v.to);
            }
        }
    }
    return d[t]!=0?1:0;
}
int dfs(int u,int mini)
{
    if(mini==0||u==t)
    return mini;
    int x=load[u].size();
    int flow=0;
    for(int &i=cur[u];i<x;i++)
    {
        node& v=edges[load[u][i]];
        int f;
        if(d[v.to]==d[u]+1&&(f=dfs(v.to,min(mini,v.cap-v.flow)))>0)
        {
            v.flow+=f;
            edges[load[u][i]^1].flow-=f;
            flow+=f;
            mini-=f;
            if(mini==0)break;
        }
    }
    return flow;
}
void dinic()
{
    int ans=0;
    while(bfs())
    {
        memset(cur,0,sizeof(cur));
        ans+=dfs(s,INF);
    }
    printf("%d",ans);
}
int n1,n2,n3,m1,m2,m3;
int main()
{
    s=0;
    scanf("%d %d %d",&n1,&n2,&n3);
    scanf("%d",&m1);
    for(int i=1;i<=m1;i++)
    {
        int x,y;
        scanf("%d %d",&x,&y);
        add(y,x+n2,1);
    }
    scanf("%d",&m2);
    for(int i=1;i<=m2;i++)
    {
        int x,y;
        scanf("%d %d",&x,&y);
        add(x+n2+n1,2*n1+n2+y,1);
    }
    for(int i=1;i<=n2;i++)
    {
        add(0,i,1);
    }
    for(int i=1;i<=n1;i++)
    {
        add(n2+i,n2+n1+i,1);
    }
    int end=n1+n2*2+n3+1;
    t=end;
    for(int i=1;i<=n1;i++)
    {
        add(n2+2*n1+i,end,1);
    }
    dinic();
}
```

---

## 作者：renhr2002 (赞：0)

网络流+拆点。

这道题中既有书和练习册的配对问题，又有书和答案的配对问题，这相当于2个二分图匹配，这样我们想到建一个含有3层中继点的图，其中每一层分别代表书、答案、练习册。

又因为书同时参与两种配对，所以把书放在中间，答案和练习册分别靠近源点和汇点（我做这道题时令练习册靠近源点）。

到这里，我们建立了一个并不能AC的图：

1. 源点向每本练习册连边，权值为1；
2. 每本答案向汇点连边，权值为1；
3. 能够配对的点之间连边（从靠近源点的点向靠近汇点的点连边），权值为1；

我们可以发现，造成UnAC的原因是一本书被重复使用。要避免这种情况，我们可以将每本书拆成2个点，从左部点向对应的右部点连一条权值为1的边。这样，一本书被使用一次后这条边就会满流，不会再参与匹配。

代码（C++11）

```cpp
#include<queue>
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
using namespace std;
#define maxn 51200
char str;
int n,m,p;
int M;
struct edge
{
	int to;
	int nxt;
	int val;
}nd[5*maxn];
int head[maxn],cnt;
int cur[maxn],dep[maxn];
queue<int>q;
int ans;
template<class X> inline void read(X &x)
{
	x=0;
	X f=1;
	while(!isdigit(str))
	{
		if(str=='-')
		{
			f=-1;
		}
		str=getchar();
	}
	while(isdigit(str))
	{
		x*=10;
		x+=str-'0';
		str=getchar();
	}
	x*=f;
	return;
}
void init()
{
	memset(head,-1,sizeof(head));
	cnt=0;
	return;
}
void add(int x,int y,int z)
{
	nd[cnt].to=y;
	nd[cnt].nxt=head[x];
	nd[cnt].val=z;
	head[x]=cnt++;
	return;
}
bool bfs(int s,int t)
{
	memset(dep,0x3f,sizeof(dep));
	memcpy(cur,head,sizeof(cur));
	while(q.size())
	{
		q.pop();
	}
	q.push(s);
	dep[s]=0;
	while(q.size())
	{
		int x=q.front();
		q.pop();
		for(int i=head[x];i!=-1;i=nd[i].nxt)
		{
			int tt=nd[i].to;
			if(dep[tt]==0x3f3f3f3f&&nd[i].val)
			{
				dep[tt]=dep[x]+1;
				q.push(tt);
			}
		}
	}
	return dep[t]!=0x3f3f3f3f;
}
int dfs(int x,int t,int lim)
{
	if(x==t||!lim)
	{
		return lim;
	}
	int ff=0,f;
	for(int i=cur[x];i!=-1;i=nd[i].nxt)
	{
		cur[x]=i;
		int tt=nd[i].to;
		if(dep[tt]==dep[x]+1&&(f=dfs(tt,t,min(lim,nd[i].val))))
		{
			ff+=f;
			lim-=f;
			nd[i].val-=f;
			nd[i^1].val+=f;
			if(!lim)
			{
				break;
			}
		}
	}
	return ff;
}
void dinic(int s,int t)
{
	while(bfs(s,t))
	{
		ans+=dfs(s,t,0x3f3f3f3f);
	}
	return;
}
int main()
{
	init();
	read(n),read(m),read(p);
	for(int i=1;i<=m;i++)
	{
		add(0,i,1);
		add(i,0,0);
	}
	for(int i=m+1;i<=m+n;i++)
	{
		add(i,i+n,1);
		add(i+n,i,0);
	}
	for(int i=m+2*n+1;i<=m+2*n+p;i++)
	{
		add(i,m+2*n+p+1,1);
		add(m+2*n+p+1,i,0);
	}
	read(M);
	for(int i=1;i<=M;i++)
	{
		int x,y;
		read(x),read(y);
		add(y,m+x,1);
		add(m+x,y,0);
	}
	read(M);
	for(int i=1;i<=M;i++)
	{
		int x,y;
		read(x),read(y);
		add(m+n+x,m+2*n+y,1);
		add(m+2*n+y,m+n+x,0);
	}
	dinic(0,m+2*n+p+1);
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Frankenstein (赞：0)

P1231     
n1本书，n2本练习册，n3本答案，有对应关系，求最大匹配。   
一开始的想法是直接n1,n2,n3三组节点间建图，n2连源点，n3连汇点，容量设为1，跑一遍最大流。   
发现WA了，因为这样可能出现一本书重复使用，而这种情况是错误的。解决的方法是“拆点”，将n1本书拆成两个连一条边，就能保证书中流过的流量也是1了。  
另外，不优化的Dinic只A了三个点，又进行了当前弧优化，就AC了。  


------------
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<memory.h>
#include<algorithm>
#include<queue>
using namespace std;
const int MAXN=40005;
const int MAXM=400005;
const int inf=2147483647;
int n,m,n1,n2,n3,m1,m2,x,y,T,S,ans,dep[MAXN];
struct EDGE{
    int next;
    int to;
    int w;
};
EDGE g[MAXM*2];
int head[MAXN]={0},cur[MAXN],nume=-1;

inline void adde(int f,int t,int w){
    g[++nume].next=head[f];
    g[nume].to=t;
    g[nume].w=w;
    head[f]=nume;
}

inline int bfs(){
    memset(dep,0,sizeof(dep));
    queue<int> q;
    int now;
    int i;
    while(!q.empty())
        q.pop();
    q.push(S);
    dep[S]=1;
    do{
        now=q.front();
        q.pop();
        for(i=head[now];i!=-1;i=g[i].next)
            if(g[i].w!=0&&dep[g[i].to]==0){
                dep[g[i].to]=dep[now]+1;
                q.push(g[i].to);
            }
    }while(!q.empty());
    if(dep[T]==0)return 0;
    return 1;
}

int dfs(int i,int m){
    int t;
    if(i==T)
        return m;
    for(int& j=cur[i];j!=-1;j=g[j].next)
        if((dep[g[j].to]==dep[i]+1)&&g[j].w!=0){
            
            t=dfs(g[j].to,min(m,g[j].w));
            if(t>0){
                g[j].w-=t;
                g[j^1].w+=t;
                return t;
            }
        }
    
    return 0;
}

inline void dinic(){
    int t,i;
    while(bfs()){
        for (i=1;i<=n;i++)
            cur[i]=head[i];
        while(t=dfs(S,inf))
            ans+=t;
        
    }
}

inline int bo1(int x){
    return x*4;
}

inline int bo2(int x){
    return x*4+1;
}

inline int ex(int x){
    return x*4+2;
}

inline int an(int x){
    return x*4+3;
}


int main(){
    int i;
    memset(head,-1,sizeof(head));
    nume=-1;
    
    scanf("%d%d%d",&n1,&n2,&n3);
    
    S=1;
    n=(max(max(n1,n2),n3)+1)*4;
    
    T=n;
    //printf("%d\n",T);
    ans=0;
    
    for(i=1;i<=n2;i++){
        adde(S,ex(i),1);
        adde(ex(i),S,0);
    }
    //source to exercise
    scanf("%d",&m1);
    
    for(i=1;i<=m1;i++){
        scanf("%d%d",&x,&y);
        adde(ex(y),bo1(x),1);
        adde(bo1(x),ex(y),0);
    }
    //exercise to book1
    
    for(i=1;i<=n1;i++){
        adde(bo1(i),bo2(i),1);
        adde(bo2(i),bo1(i),0);
    }
    //book1 to book2
    scanf("%d",&m2);
    
    for(i=1;i<=m2;i++){
        scanf("%d%d",&x,&y);
        adde(bo2(x),an(y),1);
        adde(an(y),bo2(x),0);
    }
    
    //book2 to answer
    
    for(i=1;i<=n3;i++){
        adde(an(i),T,1);
        adde(T,an(i),0);
    }
    //answer to sink
    dinic();
    printf("%d\n",ans);
    
    
    return 0;
}

```

---


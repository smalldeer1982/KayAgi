# 「HCOI-R2」秋殇别恋

## 题目背景

“你能爱我三天吗？”

“哪三天？”

“今天，明天......”

“和每一天。”

## 题目描述

小 $ \zeta $ 在给学弟出校内模拟赛的签到题时，因为出不出来一道送分的可爱签到题沉沉睡去，他梦到了这么一道题：

> 有长度为 $ n $ 的序列 $ a,b $，对于 $ 1 \le i \le n $，$ a_i $ 的值给定，$ b_i $ 初始时均为 $ 0 $。你需要支持以下操作 $ m $ 次：
> 
> * `l r v` 表示先算出 $ v'=v(1-\max_{i=l}^r|b_i|) $，对于 $ l \le i \le r $，$ b_i \leftarrow b_i+v' $。
> 
> $ m $ 次操作后你需要输出 $ \sum_{i=1}^na_ib_i $。

他感觉这道题很有意思，于是下载了这道题的数据包并查看，但是，因为早六的起床铃声，他忘记了每次操作分别的 $ v $ 值和操作的相对顺序，但是他知道，且每次操作的 $ v $ 值都满足 $ v\in\{-1,1\} $。

他决定找到一种还原这道题数据并加以适当的修改的方法使得最后输出的答案最大。修改是关于这道题目中操作的区间范围的，他允许自己进行**最多** $ k $ 次如下操作：

* 选定 $ 1 \le i \le m $，进行 $ l_i \leftarrow l_i-1 $、$ l_i \leftarrow l_i+1 $、$ r_i \leftarrow r_i-1 $、$ r_i \leftarrow r_i+1 $ 四种操作中的一种。**且始终保证 $ 1 \le l_i \le r_i \le n $**。

请你求出按照以上要求还原并修改这道题数据的方案中，最大的输出答案。

为了方便你完成这个任务，小 $ \zeta $ 贴心的告诉你了一个很有用的性质：**所有给出的操作区间在还原前互不严格包含**（即不存在 $ 1 \le i,j \le m $ 使得 $ l_i<l_j\le r_j<r_i $），当然你在修改后**可以**破坏掉它。

## 说明/提示

### 样例解释 1

* 把区间 $ [2,3] $ 移动到 $ [3,4] $，消耗 $ 2 $ 次修改次数；
* 按照参数组 $ (3,4,-1),(1,1,1) $ 的顺序操作，答案最大值为 $ 8 $。

### 样例解释 3

* 把区间 $ [2,5] $ 移动到 $ [3,5] $，消耗 $ 1 $ 次修改次数。
* 把区间 $ [6,7] $ 移动到 $ [7,10] $，消耗 $ 4 $ 次修改次数。
* 按照参数组 $ (3,5,-1),(2,3,1),(1,2,1),(7,10,-1) $ 的顺序操作，答案最大值为 $ 38 $。

### 数据规模与约定

**本题采用捆绑测试。**

| 子任务编号 | $ n \le $ | $ m \le $ | $ k \le  $ | 分值 |
|:-:|:-:|:-:|:-:|:-:|
| $ 0 $ | $ 10 $ | $ 5 $ | $ 5 $ | $ 10 $ |
| $ 1 $ | $ 10^3 $ | $ 100 $ | $ 1 $ | $ 15 $* |
| $ 2 $ | $ 20 $ | $ 5 $ | $ 20 $ | $ 15 $ |
| $ 3 $ | $ 100 $ | $ 10 $ | $ 100 $ | $ 30 $ |
| $ 4 $ | $ 10^3 $ | $ 100 $ | $ 10^3 $ | $ 30 $ |

\*：子任务 $ 1 $ 测点等分加和，其中存在 $ 5 $ 分的测试点满足 $ k=0 $。

对于所有数据，$ 1 \le n \le 1000 $，$ 1 \le m \le 100 $，$ 0 \le k \le 1000 $，$ 0 \le |a_i| \le 10^6 $，对任意 $ 1 \le i \le m $ 有 $ 1 \le l_i \le r_i \le n $，**不存在 $\boldsymbol{ 1 \le i,j \le m }$ 使得 $\boldsymbol{ l_i<l_j\le r_j<r_i }$。**

## 样例 #1

### 输入

```
5 2 2
1 2 -3 -4 5
1 1
2 3```

### 输出

```
8```

## 样例 #2

### 输入

```
5 2 3
1 2 -3 -4 5
1 1
2 3```

### 输出

```
10```

## 样例 #3

### 输入

```
10 4 5
2 2 -3 -4 -5 1 2 -10 -9 -5
2 3
2 5
1 2
6 7```

### 输出

```
38```

## 样例 #4

### 输入

```
10 4 6
2 2 -3 -4 -5 1 2 -10 -9 -5
2 3
2 5
1 2
6 7```

### 输出

```
40```

## 样例 #5

### 输入

```
10 4 1000
2 2 -3 -4 -5 1 2 -10 -9 -5
2 3
2 5
1 2
6 7```

### 输出

```
43```

# 题解

## 作者：船酱魔王 (赞：7)

## 题意回顾

> 有长度为 $ n $ 的序列 $ a,b $，对于 $ 1 \le i \le n $，$ a_i $ 的值给定，$ b_i $ 初始时均为 $ 0 $。你需要支持以下操作 $ m $ 次：
> 
> * `l r v` 表示先算出 $ v'=v(1-\max_{i=l}^r|b_i|) $，对于 $ l \le i \le r $，$ b_i \leftarrow b_i+v' $。
> 
> $ m $ 次操作后你需要输出 $ \sum_{i=1}^na_ib_i $。

你知道这道题的 $ a $ 数组，每次操作的区间范围，但忘记了操作的相对顺序和操作参数（只能取值 $ -1 $ 或 $ 1 $），你可以移动区间端点一个单位长度消耗 $ 1 $ 代价，请用不超过 $ k $ 代价还原数据最大化输出结果。

数据范围：$ 1 \le n \le 1000 $，$ 1 \le m \le 100 $，$ 0 \le k \le 1000 $，$ |a_i| \le 10^6 $。

## 分析

### 算法 1

暴力枚举 $ m! $ 种操作顺序，然后在枚举顺序的时候枚举每个区间的最终样态，时间复杂度难以想象。

期望得分 10 分。

### 算法 2

考虑转化题意，每次操作前 $ |b_i| \le 1 $，则 $ v' $ 在区间内 $ b_i $ 非全 $ 0 $ 时必然为 $ 0 $，否则等效于区间赋值，因为 $ |v| \le 1 $ 得到操作后必然仍有 $ |b_i| \le 1 $，故每次操作都是判断区间和之前操作区间是否有交，无交才赋值。然后互不相交的区间显然是互相独立的，对答案取最优贡献就是绝对值，转化题意为选出若干个区间互不相交使得他们的绝对值之和最大。

故双关键字排序区间后，设计以最靠右一个被选中区间右端点为状态的动态规划，使用前缀 $ \max $ 优化转移即可。时间复杂度为 $ O((4m)^kn) $。

期望得分 25 分。

### 算法 3

因为选择区间的顺序无关紧要，我们只关心那些位置 $ b_i $ 非 $ 0 $ 和已经消耗的区间移动代价，依照以上要关心的状态量进行设计状态压缩动态规划，时间复杂度为 $ O(nmk2^n) $。

期望得分 15 分，可以结合其他算法来得到 40 分。

### 算法 4

根据区间互不严格包含的性质，若 $ l_i < l_j $ 则 $ r_i \le r_j $，则可以通过排序区间使得 $ l_i,r_i $ 均单调不降。

然后考虑根据排序不等式，靠左的区间必然要移动到相对靠左的位置。所以排序区间后后必然可以保证每个区间只被转移一次且移动后右端点单调不降，故维护右端点、当前区间编号、区间移动代价作为 DP 的状态即可。

每次暴力枚举区间移动后样态，然后使用前缀 $ \max $ 优化转移，时间复杂度为 $ O(n^2mk) $。

期望得分 55 分，可以结合其他算法来得到 70 分高分。

### 算法 5

感觉 DP 的状态难以优化，但是暴力枚举区间移动后样态太暴力了！考虑优化掉。

我们发现区间左右端点是独立的，故建立内层 DP 数组，把区间左端点计入移动代价和右端点计入移动代价分开，然后中间区间元素分别计入答案就行。需要拆开绝对值符号正负算两次。

时间复杂度 $ O(nmk) $，期望得分 100 分。

## 标程

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 1005;
const int inf = 1e9 + 5;
int n, m, k;
int a[N];
int dp[2][N][N];//fg=0/1区间号，前缀长度<=i，操作次数=j
int fp[N][N];//区间未结束，左端点花费记录，钦定正负 
struct node {
	int l, r;
	bool operator<(node p1) {if(l != p1.l) return l < p1.l; return r < p1.r;}
} b[N];
inline int getabs(int x) {return (x <= 0) ? (-x) : x;}
inline int gmax(int x, int y) {return (x <= y) ? y : x;}
int main() {
    if(k <= 1)
	cin >> n >> m >> k;
	for(int i = 1; i <= n; i++) cin >> a[i];
	for(int i = 1; i <= m; i++) {
        cin >> b[i].l >> b[i].r;
    }
	sort(b + 1, b + m + 1);
	int fg = 0;
	for(int j = 0; j <= k; j++) fp[0][j] = -inf;
	for(int round = 1; round <= m; round++) {
		int l, r;
		l = b[round].l, r = b[round].r;
		for(int i = 0; i <= n; i++) {
			for(int j = 0; j <= k; j++) dp[fg ^ 1][i][j] = dp[fg][i][j];
		}
		for(int i = 1; i <= n; i++) {
			int il = getabs(i - l);
			int ir = getabs(i - r);
			for(int j = 0; j <= k; j++) {
				fp[i][j] = gmax((j >= il) ? (dp[fg][i - 1][j - il] + a[i]) : (-inf), fp[i - 1][j] + a[i]);
				if(j + ir <= k) dp[fg ^ 1][i][j + ir] = gmax(dp[fg ^ 1][i][j + ir], fp[i][j]);
			}
		}
		for(int i = 1; i <= n; i++) {
			int il = getabs(i - l);
			int ir = getabs(i - r);
			for(int j = 0; j <= k; j++) {
				fp[i][j] = gmax((j >= il) ? (dp[fg][i - 1][j - il] - a[i]) : (-inf), fp[i - 1][j] - a[i]);
				if(j + ir <= k) dp[fg ^ 1][i][j + ir] = gmax(dp[fg ^ 1][i][j + ir], fp[i][j]);
			}
		}
		for(int i = 1; i <= n; i++) {
			for(int j = 0; j <= k; j++) {
				dp[fg ^ 1][i][j] = gmax(dp[fg ^ 1][i][j], dp[fg ^ 1][i - 1][j]);
			}
		}
		fg ^= 1;
	}
	int ans = -1;
	for(int j = 0; j <= k; j++) ans = gmax(ans, dp[fg][n][j]);
	cout << ans << endl;
	return 0;
}
```

---


# 「FAOI-R9」少年游

## 题目背景

> 「欲买桂花同载酒，终不似，少年游。」
> 
> ——刘过《唐多令·芦叶满汀洲》

清风想起了自己学完语法第一次接触算法的那天，当时他惊叹于最大子段和的线性做法的奇妙，居然不用暴力枚举每个区间。

“明月，我们能玩一个游戏吗？”

## 题目描述

明月现在想出了一个长度为 $ n $ 的整数序列 $ a $，对于任意 $1  \le i \le n $ 满足 $ |a_i| \le 10^6 $，这个序列在初始时已经完全确定。

明月只告诉了清风 $ n $ 的值，清风现在可以提出最多 $ 10^4 $ 个询问，每次询问给出一个区间 $ [l,r] $，表示将 $ a $ 序列区间内元素的值全都乘上 $ -1 $，之后明月告诉他操作完之后这个序列的最大子段和的值。而这个要求必须满足 $ 1 \le l \le r \le n $。**操作的效果（对 $ a $ 序列元素的改动）是永久保留的。**

本题中序列的最大子段和的定义为选出序列中的一个**可以为空**的连续段使得元素的和最大，这个最大值即为这个序列的最大子段和。

而清风的目标就是还原这个序列的每个元素的初始值，清风可以进行最多一次作答。

假如你是清风，请完成这个游戏。**注意你的得分和询问次数相关。**

### 交互格式

第一行输入一个整数 $ n $。

在此之后，你应该进行若干次询问，每次询问形如 $ ?\ l \ r $，表示给出一个区间 $ [l,r] $，你需要保证 $ 1 \le l \le r \le n $。

如果你得到了答案，请你进行形如 $ !\ a_1\ a_2\ a_3 \dots a_n $ 的回答，代表你得到了 $ a $ 数组每个元素的初始值。你需要保证 $ |a_i| \le 10^6 $。在此之后你应该立即退出本轮交互。

每次输出后，请**刷新缓冲区**。

你可以使用如下语句来清空缓冲区：

- 对于 C/C++：`fflush(stdout)`；
- 对于 C++：`std::cout << std::flush`；
- 对于 Java：`System.out.flush()`；
- 对于 Python：`stdout.flush()`；
- 对于 Pascal：`flush(output)`；
- 对于其他语言，请自行查阅对应语言的帮助文档。

特别的，对于 C++ 语言，在输出换行时如果你使用 `std::endl` 而不是 `'\n'`，也可以自动刷新缓冲区。

每次询问并刷新缓冲区后，你将从标准输入中输入一个数字 $ M $，表示序列 $ a $ 的最大子段和。

## 说明/提示

**【样例 1 解释】**

$ a $ 序列的初始值为 $ \{1,-1,0,2,-2\} $。

样例提供的交互过程不符合逻辑（也就是说凭这些信息猜不出 $ a $ 的所有元素初值），只是演示交互格式而已。

**【数据规模与约定】**

**本题采用捆绑测试。**

对于每个测试点，$ 1 \le T \le 10 $，$ 2 \le n \le 10^3 $，$ |a_i| \le 10^6 $，且**交互库不是适应性的**，即 $ a_i $ 的所有值在交互开始前**已经全部生成**。

* Subtask 1（20 pts）：$ n \le 13 $。
* Subtask 2（80 pts）：无特殊限制。

**【计分方式】**

* 如果你在一些测试点上出现 TLE / RE 等错误，你该子任务不得分。
* 对于每组数据：若你出现格式错误或询问次数超过 $ 10^4 $，或答案不正确，则该组数据得分比率为 $ 0.0 $。否则按照以下方式计分：
  * 记你在该组测试数据的询问次数为 $ Q $；
  * 若 $ Q \le 3001 $，你得分比率为 $ 1.0 $；
  * 若 $ 3001 < Q \le 3011 $，则你的得分比率为 $ 1.0-\frac{Q-3001}{100} $；
  * 若 $ Q>3011 $，则你得分为 $ 0.9-\frac{Q-3011}{10000} $。
* 对于每个测试点，你的得分比率为该测试点所有数据的最小值；对于每个子任务，你的得分比率为该组子任务的每个测试点的最小值。
* 由于最终分数为整数，分数计算结果可能会被四舍五入，但是保证较多次数对应得分比率一定不比较少次数对应比率的测试数据得分高。

**【后记】**

“希望未来的道路上，你们的脆弱永远都有人能够包容；你们说的话，永远都有人能聆听。”
 
“大家的十里春风，永远都有人能懂。”

## 样例 #1

### 输入

```
1
5

3

2```

### 输出

```


? 1 3

? 1 3

! 1 -1 0 2 -2```

# 题解

## 作者：船酱魔王 (赞：8)

## 题意回顾

* 交互器有一个长度为 $ n $ 的整数序列，初始时已经确定；
* 每次可以选择将一段区间乘 $ -1 $，交互器输出当前序列的全局最大**可以为空的**子段和；
* 请用一些操作得到序列每个位置的初始值。

$ 2 \le n \le 10^3 $，操作次数限制 $ 3n+1 $ 次。

## 分析

* 约定：反转操作意为区间符号反转（乘 $ -1 $），返回值全称为「全局最大可以为空的子段和的返回值」。
* 注意到对于一个位置连续反转两次相当于不变，因此反转操作具有偶数次抵消性。
* 考虑本题的最简情况：初始时所有数都是正数或负数：
  * 当初始时全为非正时，当且仅当反转两次全局后返回 $ 0 $，那么第一次反转全局的返回值就是整个序列的绝对值和。考虑反转从 $ a_2 $ 开始的后缀，也就是相当于在所有数为非负（第一次全局反转后）的情况基础上，反转了 $ a_1 $，显然此时最大子段和为 $ a_2 $ 开始的后缀的绝对值和，两次返回值的差就是 $ a_1 $ 的值，之后从 $ a_2 $ 开始依次单独反转，相邻两次的返回值差就是每个数的绝对值。
  * 当初始时全为非负时（反转一次全局后返回 $ 0 $），直接用类似的方法即可。此时发现一个性质：若我们将序列所有值转为非负，那么此时的返回值被记录后，可以用来 $ n-1 $ 次操作求出每个位置的值。
* 记录初始状态（两次反转后）返回值 $ Q_0 $，此时我们已经询问了 $ 2 $ 次。此时序列中存在至少一个正数和一个负数。
* 从左到右依次尝试反转每个数（后复原），若在反转一个数 $ a_p $ 后，返回值大于 $ Q_0 $，说明：对于这个序列的最大子段和的任意组成区间，均包含 $ a_p $ 这个元素。
  * 证明：若存在一个区间，其和为序列的最大子段和，不包含 $ a_p $ 元素，那么它所涉及到的元素均未被修改，为初始状态，则在初始状态下选取这个区间仍能得到大于 $ Q_0 $ 的子段和，这是违背前提条件（$ Q_0 $ 为初始状态下的最大子段和）的。
  * 考虑优化找到 $ a_p $ 的过程，可以在反转这个位置时顺便反转（即为复原）上一个位置。而注意找到的 $ a_p $ 不需要复原。
  * 证明一定存在这样的 $ a_p $：该序列中存在正数，因此一定存在一个**非空**区间和为序列的最大子段和。若把这个区间考虑从左右拓展，然后把遇到的第一个负数变为正数，得到的最大子段和一定大于 $ Q_0 $，否则说明这个序列中不存在负数。
  * 这步我们消耗了最多 $ n $ 次找到 $ a_p $ 的查询次数。
* 考虑从 $ a_p $ 开始往左走，按照在 $ a_{p-1} $ 开始从右到左的顺序尝试反转每个元素：
  * 如果反转后返回值变小 / 变大，足以说明这个数的正负。注意当反转后变为负数需要**还原**（用类似于前文的方法优化次数）。
  * 如果反转后返回值不变，而此时它一定处于或与最大子段和区间相邻，那么考虑：如果这个数非 $ 0 $，那么在为正数时计入这个值一定会让返回值更大；如果两种情况（正负）都计入最大子段和区间，由最大子段和的局部最优性，它左面的区间长度一定一样，那么返回值也会改变。因此这个数必然为 $ 0 $。
  * 从 $ a_{p+1} $ 开始向右的操作反之亦然。
  * 这步我们消耗了最多 $ n-1+1+1=n+1 $（$ n-1 $ 个元素要被反转，两边的元素可能要额外一次还原）次操作。
* 此时，序列中所有元素非负，用 $ n-1 $ 次操作处理完即可。
* 操作次数上限为 $ 2+n+n+1+n-1=3n+2 $ 次，还是不行。怎么办？
  * 注意到卡到上界的条件是翻到最后一个数才最大子段和变大，那么显然从这个数往左往右走时肯定不用往右走，那么不用还原最右面的数，故两步无法同时把次数卡到上界。
  * 故我们解决了这一问题。

## 参考实现

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 1005;
int T;
int n, qmax;
int sgn[N];
int a[N];
int ask(int l, int r, int chan = 0) {
	cout << "? " << l << " " << r << endl;
	if(!chan) {
		for(int i = l; i <= r; i++) sgn[i] = -sgn[i];
	}
	cin >> l;
	return l;
}
void easy(int x) {
	for(int i = 1; i <= n - 1; i++) {
		int tu = ask(i, i, 1);
		a[i] = x - tu;
		x = tu;
	}
	a[n] = x;
	cout << "! ";
	for(int i = 1; i <= n; i++) {
		cout << a[i] * sgn[i];
		if(i < n) cout << " ";
		else cout << endl;
	}
}
int main() {
	cin >> T;
	for(int ti = 1; ti <= T; ti++) {
		cin >> n >> qmax;
		for(int i = 1; i <= n; i++) sgn[i] = 1;
		int t1 = ask(1, n);
		int t2 = ask(1, n);
		if(t1 == 0 || t2 == 0) {
			if(t2 == 0) ask(1, n);
			easy(max(t1, t2));
			continue;
		}
		int qt = t2;
		int p = 0;
		for(int i = 1; i <= n; i++) {
			int tp = ask(max(i - 1, 1), i);
			if(tp > qt) {
				p = i;
				qt = tp;
				break;
			}
		}
		if(!p) {
			cout << "! I AK IOI" << endl;
			continue;
		}
		int oq = 0;
		for(int i = p - 1; i >= 1; i--) {
			int tp = ask(i, i + oq);
			if(tp >= qt) qt = tp, oq = 0;
			else oq = 1;
		}
		if(oq) qt = ask(1, 1);
		oq = 0;
		for(int i = p + 1; i <= n; i++) {
			int tp = ask(i - oq, i);
			if(tp >= qt) qt = tp, oq = 0;
			else oq = 1;
		}
		if(oq) qt = ask(n, n);
		easy(qt);
	}
	return 0;
}
```

---

## 作者：wmrqwq (赞：4)

# 题目链接

[P12399 「FAOI-R9」少年游](https://www.luogu.com.cn/problem/P12399)

# 解题思路 & 参考代码

提供一个和官解不一样的做法。

好像比官解要优秀。

设修改前的最大子段和为 $lst$。

注意到我们修改单个数字后，设此时最大子段和为 $now$，则会有以下三种情况：

- 若 $lst = now$，则修改这个数字不会影响最大子段和的值。

- 若 $lst < now$，则修改这个数字会影响最大子段和的值，并且此时最大子段和**包含**了你修改的这个数字。

- 若 $lst > now$，则修改这个数字会影响最大子段和值，并且此时最大子段和**包含**了你修改的这个数字。

那么我们可以 $2n$ 次扫一遍得到此时的最大子段和的值及其选取哪个子段。

然后我们考虑把整个序列都变成正数即可，这里操作次数为 $2n$ 次。

此时由于整个序列都为正数，则可以依次询问每个下标找出 $a$ 序列每个数的值，这里询问次数为 $n$ 次。

总询问次数 $5n$ 次，不过事实上这个是跑不满的。

下面是这个部分的参考代码：

```cpp
ll n;
ll tag[1010];
ll ans[1010];
ll lst[1010];
ll get(ll l,ll r)
{
	forl(i,l,r)
		ans[i]*=-1;
	ll S=0,aa=0;
	forl(i,1,n)
		S=max(0ll,S+ans[i]),
		Max(aa,S);
	forl(i,1,n)
		cout<<ans[i]<<' ';
	cout<<endl;
	return aa;
}
ll ask(ll l,ll r,ll pd=1)
{
    cout<<"? "<<l<<' '<<r<<endl;
    if(pd)
	    tag[l]^=1,tag[r+1]^=1;
//	ll num=get(l,r);
//	cout<<"get: "<<num<<endl;
    return rd();
}
ll num;
ll l,r;
ll my_ans[100010];
void _clear(){}
/*
2
1 2
1 -2

*/
void solve()
{
    _clear();
    cin>>n;
//	n=3;
//    forl(i,1,n)
//    	lst[i]=ans[i]=rand_lr(-1e6,1e6);
//    cout<<"REAL: ";
//    forl(i,1,n)
//    	cout<<ans[i]<<" ";
//    cout<<endl;
    forl(i,1,n)
//    	lst[i]=ans[i]=rd(),
		my_ans[i]=0;
    forl(i,0,n+5)
        tag[i]=0;
    ask(1,1);
    num=ask(1,1);
    l=n+1,r=0;
    forl(i,1,n)
    {
        ll now=ask(i,i);
        if(now>num)
        {
            Min(l,i),
            Max(r,i);
            num=now;
        }
        if(now<num)
        {
            Min(l,i),
            Max(r,i),
            ask(i,i);
        }
    }
//    cout<<"part 2:\n";
    ask(1,1);
    num=ask(1,1);
    forr(i,l-1,1)
    {
        ll now=ask(i,i);
        if(now>num)
        {
            num=now;
            continue;
        }
        num=ask(i,i);
    }
//    cout<<"part 3:\n";
    forl(i,r+1,n)
    {
        ll now=ask(i,i);
        if(now>num)
        {
            num=now;
            continue;
        }
        num=ask(i,i);
    }
//    cout<<"now------\n";
    forl(i,1,n)
    {
        ll now=ask(i,i,0);
        my_ans[i]=num-now;
        num=now;
    }
    forl(i,1,n)
        tag[i]^=tag[i-1];
    forl(i,1,n)
        if(tag[i])
            my_ans[i]*=-1;
    cout<<"! ";
    forl(i,1,n)
        cout<<my_ans[i]<<' ';
    cout<<endl;
//    forl(i,1,n)
//    {
//    	if(my_ans[i]!=lst[i])
//    	{
//    		cout<<"Wrong Answer!\n";
//    		cout<<n<<endl;
//    		forl(j,1,n)
//    			cout<<lst[j]<<" ";
//    		cout<<endl;
//    		exit(0);
//		}
//	}
//	cout<<"AC!\n";
}
```

这部分显然不够优秀，我们考虑如何将前 $4n$ 次询问优化到 $2n$ 次的级别。

考虑随机化。

考虑设置一个随机的轮数 $B$，在这里我们取 $B = 12$。

此时我们只需要找到任意一个可以影响最大子段和的数字即可。

对于每轮我们随机 $5$ 次下标 $pos$，若 $5$ 次都没随到一个会影响最大子段和的下标，说明最大子段和长度较小，此时我们直接进行一次 `1 n` 即可，进行这种操作后，最大子段和长度**一定**变大，因此一定能随出来这样的一个下标。

剩下的我们直接往左往右扩展即可，由于此时正负数分布较均匀，因此询问次数显然严格小于 $2n$ 次（跑满是 $2n$ 次）。

上文随机化部分实际上 $60$ 次之内就能随到。

那么再加上计算答案的 $n$ 次，我们询问总次数是 $n + 2n + 60$ 次，实际上完全跑不满，最终最大点只用了 $2965$ 次询问。

此部分参考代码：

```cpp
ll n;
ll tag[1010];
ll ans[1010];
ll lst[1010];
ll get(ll l,ll r)
{
	forl(i,l,r)
		ans[i]*=-1;
	ll S=0,aa=0;
	forl(i,1,n)
		S=max(0ll,S+ans[i]),
		Max(aa,S);
	forl(i,1,n)
		cout<<ans[i]<<' ';
	cout<<endl;
	return aa;
}
ll ask(ll l,ll r,ll pd=1)
{
    cout<<"? "<<l<<' '<<r<<endl;
    if(pd)
	    tag[l]^=1,tag[r+1]^=1;
//	ll num=get(l,r);
//	cout<<"get: "<<num<<endl;
    return rd();
}
ll num;
ll l,r;
ll my_ans[100010];
void _clear(){}
/*
2
1 2
1 -2

*/
void solve()
{
    _clear();
    cin>>n;
//	n=3;
//    forl(i,1,n)
//    	lst[i]=ans[i]=rand_lr(-1e6,1e6);
//    cout<<"REAL: ";
//    forl(i,1,n)
//    	cout<<ans[i]<<" ";
//    cout<<endl;
    forl(i,1,n)
//    	lst[i]=ans[i]=rd(),
		my_ans[i]=0;
    forl(i,0,n+5)
        tag[i]=0;
//    ask(1,1);
//    num=ask(1,1);
    l=n+1,r=0;
//    forl(i,1,n)
//    {
//        ll now=ask(i,i);
//        if(now>num)
//        {
//            Min(l,i),
//            Max(r,i);
//            num=now;
//        }
//        if(now<num)
//        {
//            Min(l,i),
//            Max(r,i),
//            ask(i,i);
//        }
//    }
//    cout<<"part 2:\n";
	ll B=12;
	forl(__,1,B)
	{
		ask(min((__-1)*((1000+B-1)/B)+1,n),min(__*((1000+B-1)/B),n));
//		ask(1,n);
		num=ask(1,n);
		ll pd=0;
		forl(_,1,5)
		{
			ll pos=rand_lr(1,n);
			ll A=ask(pos,pos);
			if(A>num)
			{
				l=r=pos;
				pd=1;
				break;
			}
			if(A<num)
			{
				ask(pos,pos);
				l=r=pos;
				pd=1;
				break;
			}
		}
		if(pd)
			break;
	}
	// B=20;
	// forl(__,1,B)
	// {
	// 	ask(min((__-1)*((1000+B-1)/B)+1,n),min(__*((1000+B-1)/B),n));
	// 	ask(1,n);
	// 	num=ask(1,n);
	// 	ll pd=0;
	// 	forl(_,1,400/B)
	// 	{
	// 		ll pos=rand_lr(1,n);
	// 		ll A=ask(pos,pos);
	// 		if(A>num)
	// 		{
	// 			l=r=pos;
	// 			pd=1;
	// 			break;
	// 		}
	// 		if(A<num)
	// 		{
	// 			ask(pos,pos);
	// 			l=r=pos;
	// 			pd=1;
	// 			break;
	// 		}
	// 	}
	// 	if(pd)
	// 		break;
	// }
	if(r==0)
        l=r=rand_lr(1,n);
    ask(1,1);
    num=ask(1,1);
    forr(i,l-1,1)
    {
        ll now=ask(i,i);
        if(now>=num)
        {
            num=now;
            continue;
        }
        num=ask(i,i);
    }
//    cout<<"part 3:\n";
    forl(i,r+1,n)
    {
        ll now=ask(i,i);
        if(now>num)
        {
            num=now;
            continue;
        }
        num=ask(i,i);
    }
//    cout<<"now------\n";
    forl(i,1,n)
    {
        ll now=ask(i,i,0);
        my_ans[i]=num-now;
        num=now;
    }
    forl(i,1,n)
        tag[i]^=tag[i-1];
    forl(i,1,n)
        if(tag[i])
            my_ans[i]*=-1;
    cout<<"! ";
    forl(i,1,n)
        cout<<my_ans[i]<<' ';
    cout<<endl;
//    forl(i,1,n)
//    {
//    	if(my_ans[i]!=lst[i])
//    	{
//    		cout<<"Wrong Answer!\n";
//    		cout<<n<<endl;
//    		forl(j,1,n)
//    			cout<<lst[j]<<" ";
//    		cout<<endl;
//    		exit(0);
//		}
//	}
//	cout<<"AC!\n";
}
```

---

## 作者：ax_by_c (赞：2)

搬运官方题解。

首先对整个序列询问两次，设其结果分别为 $Q',Q$，则 $Q$ 为原序列的最大子段和，$Q'$ 为原序列取反后的最大子段和。

若不存在 $\operatorname{sgn}(a_i)\operatorname{sgn}(a_j)<0$，则 $Q,Q'$ 中必有一个是 $0$，另一个则是 $\sum\lvert a_i\rvert$，符号也是好确定的。

那么依次将数取反即可得到 $\lvert a_i\rvert$，共用 $2+n-1=n+1$ 次询问。

于是考虑通过若干次询问使得不存在 $\operatorname{sgn}(a_i)\operatorname{sgn}(a_j)<0$，只需找到一个位置 $p$ 使得所有最大和子段都经过它即可向两边拓展解决，因为包含 $p$ 的非负数段之外的第一个数取反前后必有至少一次在最大和子段中，因此可以用 $n-1+2=n+1$ 次询问使所有数变成非负数。

首先要证明 $p$ 存在，对于当前的任意最大和子段，找到其两边的某个负数，那么将其取反后最大子段和一定变大且经过这个数，否则原子段和不是最大的。而负数一定存在，因此 $p$ 存在。

于是扫一遍找到某个位置使得其取反后最大子段和变大即可，共用 $n$ 次询问。

总计 $3n+2$ 次询问，但是注意到卡满上界时 $p=n$，那么让所有数变成正数时最右端不需要额外取反，因此上界取不到，至多 $3n+1$ 次询问。

```cpp
#include<bits/stdc++.h>
#define rep(i,l,r) for(int i=(l);i<=(r);i++)
#define per(i,r,l) for(int i=(r);i>=(l);i--)
#define repll(i,l,r) for(ll i=(l);i<=(r);i++)
#define perll(i,r,l) for(ll i=(r);i>=(l);i--)
#define pb push_back
#define ins insert
#define clr clear
using namespace std;
namespace ax_by_c{
typedef long long ll;
const int N=1e3+5;
int n,z[N],Q,Q_,cur,a[N];
int query(int l,int r){
    printf("? %d %d\n",l,r);
    fflush(stdout);
    int res;
    scanf("%d",&res);
    z[l]*=-1;
    z[r+1]*=-1;
    return res;
}
void slv(){
    scanf("%d",&n);
    rep(i,0,n)z[i]=1;
    Q_=query(1,n),cur=Q=query(1,n);
    if(Q&&Q_){
        int p=-1;
        rep(i,1,n){
            int x;
            if(i==1)x=query(i,i);
            else x=query(i-1,i);
            if(x>Q){
                p=i,cur=x;
                break;
            }
        }
        assert(p!=-1);
        bool lst=0;
        per(i,p-1,1){
            int x;
            if(lst)x=query(i,i+1);
            else x=query(i,i);
            if(x<cur)lst=1;
            else lst=0,cur=x;
        }
        if(lst)query(1,1),lst=0;
        rep(i,p+1,n){
            int x;
            if(lst)x=query(i-1,i);
            else x=query(i,i);
            if(x<cur)lst=1;
            else lst=0,cur=x;
        }
        if(lst)query(n,n),lst=0;
    }
    if(!cur)cur=query(1,n);
    a[1]=cur;
    rep(i,2,n)a[i]=query(i-1,i-1);
    z[1]*=-1,z[n]*=-1;
    rep(i,1,n-1)a[i]-=a[i+1];
    rep(i,1,n)z[i]*=z[i-1];
    printf("! ");
    rep(i,1,n)printf("%d ",a[i]*z[i]);
    putchar('\n');
    fflush(stdout);
}
void main(){
	int T=1;
	// int csid=0;scanf("%d",&csid);
    scanf("%d",&T);
    while(T--)slv();
}
}
int main(){
	string __name="";
	if(__name!=""){
		freopen((__name+".in").c_str(),"r",stdin);
		freopen((__name+".out").c_str(),"w",stdout);
	}
	ax_by_c::main();
	return 0;
}
```

---

## 作者：P_Bisector (赞：1)

发现所有分治和长区间取相反数状物都假了。考虑单点取相反数的做法。如果某次单点取相反数影响了答案，分两种情况：

- 该点由负转正，答案增大，由于答案增大，其必然处于该区间内。

- 该点由正转负，答案减小。无法确定该点是否在答案区间中，需要重新转正，此时仍然回到区间内。

极端情况（全非正，全非负，全零）此处略去不考虑，是容易处理的。（没处理也过了。）以下是一般情况：

- 通过上述操作可以先找出一个必然在答案区间内的数字。

- 然后从该数字往两边扩展，首先指定一个区间满足区间中所有数为正，接下来每次对区间边界外一个位置的数字取相反数，如果答案增加，则其由负转正，不用操作；否则一定为由正转负，需要一次操作。可以和下一次操作合并。

- 所有数字转正后，不断将前缀变为负数，答案变为后缀和，不断用较大减较小即可。询问时可以使用差分维护正负性，最后输出答案时乘上即可。注意到最后一步不需要操作。

除此以外，为了防止各种 hack：

- 可以在第一步前随机取一个区间取相反数。

- 第一步遍历时可以改为随机撒点，不容易卡满。

显然每一步操作都至多需要 $n+k$ 次（$k$ 为一个极小的常数），加一起约为 $3n$ 次。可以证明以上做法是正确的，并且如果你第一步采取随机方式，那基本上无论对错（在 $k$ 的大小上）都卡不掉了。

---


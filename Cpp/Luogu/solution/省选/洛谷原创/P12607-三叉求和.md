# 三叉求和

## 题目背景

很久很久以前，小 A 在一棵无穷深的三叉树上摘苹果，这棵苹果树的根没有苹果，每个点三个儿子的苹果的数量分别是这个点的苹果数量的三倍加上 $0,1,2$，小 A 从根节点一直往下走了正好 $d$ 步并摘到了 $k$ 个苹果，可惜的是，小 A 只记得 $k$ 在三进制下的某些位，他想知道有多少种方式符合他的记忆。

## 题目描述

有一棵深度无穷大的以 $0$ 为根的三叉树，节点 $i$ 的儿子分别是节点 $3i+1,3i+2,3i+3$。

设节点 $i$ 的点权为 $a_i$。对于 $0\le j\le 2$，有 $a_{3i+j+1}=3\times a_i+j$，特别的，$a_0=0$。

你的任务是求从根出发，找长度 $=d$ 的简单路径，并使得该路径经过的所有点的点权和为 $k$。你需要求出所有合法路径的条数。

然而 $k$ 并不唯一，$k$ 的三进制表示中仅有某些位是已知的，而其它的位将以字符 $\tt ?$ 表示。你需要对所有可能的 $k$ 在上述问题中的答案求和，最后再对 $10^9+7$ 取模。


## 说明/提示

### 样例 #1 解释

合法的路径有：
- $[0,1,5,17]$
- $[0,2,7,23]$
- $[0,2,9,30]$

对应的点权分别为：

- $[0,0,1,4]$
- $[0,1,3,10]$
- $[0,1,5,17]$
### 数据范围
|测试点编号|$d$|特殊性质|
|:----:|:----:|:----:|
|$1\sim 2$|$\leq15$|-|
|$3$|$\leq50$|A|
|$4$|$\leq50$|B|
|$5\sim 8$|$\leq50$|-|
|$9\sim 10$|$\leq300$|A|
|$11\sim 12$|$\leq300$|B|
|$13\sim 14$|$\leq300$|-|
|$15$|$\leq2000$|A|
|$16$|$\leq2000$|B|
|$17\sim 20$|$\leq2000$|-|

特殊性质 A：保证 $k$ 中 $?$ 的数量 $\leq 1$。

特殊性质 B：保证所有的位置均为 $?$。

对于 $100\%$ 的数据，$1\le d\le 2000,0\le k\lt 3^{d+1}$。

## 样例 #1

### 输入

```
3
?12```

### 输出

```
3```

## 样例 #2

### 输入

```
3
???```

### 输出

```
19```

## 样例 #3

### 输入

```
4
0211```

### 输出

```
1```

## 样例 #4

### 输入

```
10
21??1?2??0```

### 输出

```
161```

## 样例 #5

### 输入

```
30
???1????0????1???0????2???????```

### 输出

```
744432249```

# 题解

## 作者：Undead2008 (赞：10)

假设路径经过的每一条边依次为从上一个点 $x$ 走到 $3x+b_i+1$，将经过的 $a_i$（去掉 $a_0$）和 $b_i$ 依次写成序列，容易发现：

$$b_i=\sum_{j=1}^i 3^{i-j}a_{j}$$

现在要 $\sum b_i=k$，就是 

$$\sum_{i=1}^d \sum_{j=1}^i 3^{i-j}a_{j}=k$$

$$\sum_{i=0}^{d-1}3^i\times\sum_{j=1}^{d-i} a_j=k$$

记 $a$ 的前缀和为 $s$，即有

$$\sum_{i=0}^{d-1}3^is_{d-i}$$

但是 $a$ 和 $s$ 都未知，需要计数方案，考虑 dp。

记 $f_{i,j,k}$ 表示当前 dp 到 $i$，$s_{d-i}=j$，$i-1$ 向当前位进位 $k$ 的方案数，注意到 $s_{d-i+1}-s_{d-i}\in\{0,1,2\}$ 所以一个状态的后继状态个数为 $O(1)$。

状态 $O(n^3)$，转移 $O(1)$，时间复杂度 $O(n^3)$。

注意到对于一组 $(i,j)$，满足 $f_{i,j,k}$ 非零的 $k$ 的数量是 $O(1)$ 个，所以状态数其实是 $O(n^2)$ 的，拿 umap 或者 vector 存一下就行了，时间 $O(n^2)$。

---

## 作者：george0929 (赞：4)

设序列 $\{b\}$，$b_i\in \{0,1,2\}$，表示第 $i$ 次向那个方向走。

重新定义题目中的序列 $\{a\}$，$a_i$ 表示走完第 $i$ 步到达的节点点权。

则 $a_i=\sum\limits_{j=1}^{i} b_j\times 3^{i-j}$。

题目要求 $\sum\limits_{i=1}^{d} a_i=k$，即 $\sum\limits_{i=1}^{d} \sum\limits_{j=1}^{i} b_j\times 3^{i-j}=k$。

$b_i$ 的系数是 $3$ 的若干次方，这个式子看着就很数位 DP，把 $b_i$ 的贡献按照系数分类。

原式为：

$$
\sum\limits_{i=1}^{d} \sum\limits_{j=1}^{i} b_j\times 3^{i-j}
\\
=\sum_{x=0}^{d} \sum_{i=1}^{d} \sum_{j=1}^i\ [i-j=x]\times 3^x\times b_j
$$

发现此时 $i$ 没有用处，只用限制 $1\leq i=j+x\leq d$ 即可。

$$
\\
\sum_{x=0}^{d} \sum_{i=1}^{d} \sum_{j=1}^i\ [i-j=x]\times 3^x\times b_j
\\
=\sum_{x=0}^{d} \sum_{j=1}^{d-x} 3^x\times b_{j}
\\
=\sum_{x=0}^{d} 3^x\times \sum_{j=1}^{d-x} b_{j}
$$

记 $s_i=\sum_{j=1}^{d-i} b_j$，则原式 $=\sum_{x=0}^{d} 3^x\times s_x$。

那么对 $s$ 进行三进制数位 DP，由于 $s_d=0$，故从高位开始，$f_{pos,lst,up}$ 表示高 $pos-1$ 位已确定、$s_{pos-1}=j$、这一位需要向上进位 $up$ 的前提下，剩余未确定位置的方案数。

答案和初值是显然的。

转移为 $f_{pos,lst,up}=\sum\limits_{x=0}^2 f_{pos+1,lst+x,3\times up+now-(lst+x)}$。

其中，$now$ 表示 $k$ 这一位的数字，当 $k$ 这一位为 `?` 时，枚举 $now=0,1,2$ 即可。

我们得到了 $O(n^3)$ 做法，但是题目要求 $O(n^2)$。

我们充分发扬人类智慧，使用递推实现转移，然后猜测 $f_{pos,lst,*}$ 只有 $O(1)$ 个接近的非 $0$ 位置，维护 $l_{pos,lst},r_{pos,lst}$ 表示非 $0$ 区间的左右端点，只转移非 $0$ 位置即可。

本地测试极限数据（全为 `?`）大概 0.6 秒，复杂度 $O(能过)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int f[2][4005][4005];
//int f[50][100][50];
int l[2005][4005],r[2005][4005];
const int mod=1e9+7;
int d;
string s;
/*
//O(n^3)部分 
const int MAXN=300;
int solve(int pos,int lst,int up){
	if(up<0||up>MAXN) return 0;
	if(pos==d){
		return up==0;
	}
	if(f[pos][lst][up]!=-1){
		return f[pos][lst][up];
	}
	int res=0;
	for(int x=0;x<=2;x++){
		if(lst+x<0) continue;
		if(s[pos]!='?') res+=solve(pos+1,lst+x,up*3+(s[pos]-'0')-(lst+x));
		else{
			res+=solve(pos+1,lst+x,up*3+0-(lst+x));
			res+=solve(pos+1,lst+x,up*3+1-(lst+x));
			res+=solve(pos+1,lst+x,up*3+2-(lst+x));
		}
		res%=mod;
	}
	return f[pos][lst][up]=res;
}
*/
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>d>>s;
//	d=2000;
//	for(int i=1;i<=d;i++) s+='?';
	vector<pair<int,int>> X[2]; 
	for(int i=0;i<=2*d;i++) f[d&1][i][0]=1,X[d&1].push_back({i,0});
	for(int pos=d-1;pos>=0;pos--){
		int nxt=!(pos&1);
		for(auto x:X[pos&1]) f[pos&1][x.first][x.second]=0;
//		memset(f[pos&1],0,sizeof(f[pos&1]));
		X[pos&1].clear();
		for(int lst=0;lst<=2*d;lst++){
			int nowl=s[pos]-'0',nowr=s[pos]-'0';
			if(s[pos]=='?') nowl=0,nowr=2;
			l[pos][lst]=2*d+1;
			r[pos][lst]=-1;
			for(int now=nowl;now<=nowr;now++){
				for(int x=0;x<=2;x++){
					for(int up1=l[pos+1][lst+x];up1<=r[pos+1][lst+x];up1++){
						if((up1-now+lst+x)%3) continue;
						int up=(up1-now+lst+x)/3;
						f[pos&1][lst][up]=(f[pos&1][lst][up]+f[nxt][lst+x][up1])%mod;
						if(f[pos&1][lst][up]){
							X[pos&1].push_back({lst,up});
							l[pos][lst]=min(l[pos][lst],up);
							r[pos][lst]=max(r[pos][lst],up);
						}
					}
				}
				//up1=up*3+now-lst-x
				//up=(up1-now+lst+x)/3
			}
		}
	}
	cout<<f[0][0][0]<<"\n";
	return 0;
}
```

---

## 作者：Pigsyy (赞：3)

### 前言

评级建议：上位蓝或下位紫。

解法貌似跟官解并不一样。

### 思路

考虑拆贡献，对于节点 $i$ 的儿子节点 $3i+j$，其对于路径剩余的点的贡献是固定的，依次为（令 $3i+j$ 的深度为 $k$）：

$$
j\cdot 3^0, j\cdot 3^1, \dots, j\cdot 3^{d-k}
$$

原因是简单的，因为 $a_{3i+j}=3a_i+j$，那么设之前对 $i$ 的贡献为 $b_i$，则如今对 $3i+j$ 的贡献为 $3b_i$。

由于，要求对于路径上所有点的权值和为 $k$，只需要将每个点对 **路径上剩余点的贡献的和** 加和。

而每个点对路径上剩余点的贡献的和可通过等比数列求和公式进一步化简：

$$
\begin{align*}
S &= j\cdot 3^0+ j\cdot 3^1+ j\cdot 3^2+ \dots+ j\cdot 3^{d-k}\\
3S &= \qquad\quad\ j\cdot 3^1+ j\cdot 3^2+ \dots+ j\cdot 3^{d-k}+j\cdot 3^{d-k+1}\\
S &= j\cdot \frac{3^{d-k+1}-1}{2}
\end{align*}
$$

设路径经过的点选择的儿子节点分别为 $q_1,q_2,\dots,q_{d}$（$\forall i \in [1,d], q_i\in [0,3)$），则限制为

$$
\begin{align*}
k &= \sum_{i=1}^{d} q_i \frac{3^{d-i+1}-1}{2}\\
2k &= \sum_{i=1}^{d} q_i 3^{d-i+1}-q_i\\
2k+\sum_{i=1}^{d} q_i &= \sum_{i=1}^{d} q_i 3^{d-i+1}\\
\end{align*}
$$

令 $S=\sum_{i=1}^{d} q_i$，则等价于 $2k+S$ 在三进制下的各数位之和为 $S$。

问题转化为对于 $S\in [1,2d]$，$k$ 有多少种赋值方式，使得 $2k+S$ 在三进制下的各数位之和为 $S$。

这是容易 DP 的！枚举 $S$，然后令 $f_{i,j,k}$ 表示前 $i$ 位，$2k+S$ 在三进制下数位之和为 $j$，进位为 $k$。这里 $k\in[0,2]$，因为 $S$ 每位最大为 $2$，$2k$ 每位最大为 $4$，$k$ 最大为 $2$，和为 $8$，进位仍为 $2$。

转移是 $O(1)$ 的，但是状态是 $O(n^2)$，外层还需枚举 $S$。总复杂度为 $O(n^3)$，期望得分 $70$。

考虑如何去掉外层的枚举，不难发现，在这个转移中 $S$ 是可以加入状态第二维的。

令 $f_{i,j,k}$ 表示前 $i$ 位，$2k+S$ 在三进制下的数位之和减去 $S$ 为 $j$，进位为 $k$。转移时，只需要额外枚举 $S$ 在第 $i$ 位为 $0/1/2$ 即可。

时间复杂度 $O(n^2)$，期望得分 $100$。

### 代码

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
using namespace std;
using i64 = long long;
using pii = pair<int, int>;

const int maxn = 2005, mod = 1e9 + 7;

int n;
string s;
int dp[2][14005][3], pw[maxn];

int main() {
    cin.tie(0);
    cout.tie(0);
    ios::sync_with_stdio(0);

    cin >> n >> s;
    reverse(s.begin(), s.end());
    while (s.size() < max(8, n + 1)) s += '0';
    
    pw[0] = 1;
    for (int i = 1; i < 8; i ++)
        pw[i] = pw[i - 1] * 3;
    
    memset(dp, 0, sizeof dp);
    dp[1][7000][0] = 1;
    for (int i = 0; i < s.size(); i ++) {
        for (int j = 0; j <= 7000 + i * 2; j ++)
            for (int k : {0, 1, 2}) dp[i & 1][j][k] = 0;
        for (int j = 0; j <= 7000 + i * 2; j ++)
            for (int k : {0, 1, 2}) {
                if (!dp[~i & 1][j][k]) continue;
                for (int t : {0, 1, 2}) {
                    if (s[i] != '?') {
                        int u = 2 * (s[i] - '0') + t + k;
                        if (u % 3 && (!i || i > n) || i >= 8 && t) continue;
                        (dp[i & 1][j + u % 3 - t * pw[i]][u / 3] += dp[~i & 1][j][k]) %= mod;
                    } else {
                        for (int o : {0, 1, 2}) {
                            int u = 2 * o + t + k;
                            if (u % 3 && (!i || i > n) || i >= 8 && t) continue;
                            (dp[i & 1][j + u % 3 - t * pw[i]][u / 3] += dp[~i & 1][j][k]) %= mod;
                        }
                    }
                }
            }
    }

    cout << dp[~s.size() & 1][7000][0] << endl;

    return 0;
}
```

---

## 作者：SamHJD (赞：2)

点 $3x+y+1$ 的点权为 $3a_x+y$，统计每个点权相对于父节点点权的三倍多出的 $y$ 的贡献，发现是 $y\times \sum\limits_{i=0}^{d-dep} 3^i$（根节点深度为 $0$）。于是可以从低位向高位进行 dp，设 $f_{i,j,k}$ 表示考虑到深度为 $i$ 时，剩余路径上选择的 $y$ 的和为 $j$，进位到这一位的值为 $k$ 的方案数。每次向后一位转移，将 $j$ 减去 $y\in[0,2]$，进到后一位的值即为 $\lfloor\frac{k}{3}\rfloor+(j-y)$。

注意到有用状态数远小于 $n^3$，只转移非 $0$ 的 $f$ 即可通过，复杂度近似 $O(n^2)$。

```cpp
#include <bits/stdc++.h>
#define rep(i,k,n) for(int i=k;i<=n;++i)
#define per(i,n,k) for(int i=n;i>=k;--i)
using namespace std;
template<typename T>
inline void read(T &x){
    x=0;int f=1;char c=getchar();
    for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
    for(;isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(c-'0');
    x*=f;
}
template<typename T,typename ...Args>
inline void read(T &x,Args &...rest){read(x);read(rest...);}
const int N=3e3+10,MOD=1e9+7;
int n,a[N*3],vis[N*3],f[2][2*N][2*N];
vector<pair<int,int> > use[2];
string s;
vector<int> tran[2][N*2];
signed main(){
    read(n);
    cin>>s;
    reverse(s.begin(),s.end());
    rep(i,1,n){
        if(s[i-1]=='?') a[i]=-1;
        else a[i]=s[i-1]-'0';
    }
    rep(i,0,2*n) if(a[1]==-1||(i%3)==(a[1]%3)){
        f[1][i][i]=1,tran[1][i].push_back(i),use[1].push_back({i,i});
    }
    int i1=0,i2=1;
    rep(i,1,n){
        i1^=1;i2^=1;
        for(auto p:use[i2]) f[i2][p.first][p.second]=0;
        use[i2].clear();
        rep(j,0,2*(n-i+2)) tran[i2][j].clear();
        rep(j,0,2*(n-i+1)){
            for(auto k:tran[i1][j]){
                if(vis[k]) continue;vis[k]=1;
                if(f[i1][j][k]==0) continue;
                rep(x,0,2){
                    int j2=j-x;if(j2<0) break;
                    int num=(k/3)+j2;
                    if(a[i+1]!=-1&&a[i+1]%3!=num%3) continue;
                    (f[i2][j2][num]+=f[i1][j][k])%=MOD;
                    use[i2].push_back({j2,num});
                    tran[i2][j2].push_back(num);
                }
            }
            for(auto k:tran[i1][j]) vis[k]=0;
        }
    }
    printf("%d\n",f[i2][0][0]);
    return 0;
}
```

---

## 作者：Sliarae (赞：2)

考虑一条长度为 $d$ 的链，它的权值如何计算，对于一个距离链底端为 $i(0 \le i < d)$ 的点，它对苹果数会产生 $(3^0 + 3^1 + \ldots + 3^d) a_i$ 的贡献，其中 $a_i = 0/1/2$，表示这个结点在兄弟中的 rank。

$3^0 + 3^1 + \ldots + 3^d$ 不好直接计算，考虑把一个三进制数的所有数位从低到高拍成一个序列，那么 $i$ 的贡献就是前缀 $[1, i + 1]$ 加 $a_i$。任意长度为 $d$ 的链的苹果数可以表示为，对所有长度为 $1 \sim d$ 的前缀 $+0/1/2$，最终得到的三进制数。

于是开始 dp，设 $f_{i, j, k}$ 表示考虑完前 $i$ 位，钦定 $i + 1 \sim d$ 这些还需要加 $j$，且第 $i$ 位会对第 $i + 1$ 位产生 $k$ 的进位，的方案数。转移是 $O(1)$ 的，这样可以得到一个 $O(n^3)$ 的做法。

去感受，去猜测，去相信。我们相信对于一个 $j$，合法的 $k$ 的数量是 $O(1)$ 的，于是维护 $l_{i, j}$ 和 $r_{i, j}$ 表示仅当 $k \in [l_{i, j}, r_{i, j}]$ 时，$f_{i, j, k}$ 的值不为 $0$，只需对这一部分转移。时间复杂度 $O(n^2)$。

```cpp
#include <iostream>
#include <vector>

using namespace std;

const int kN = 2e3 + 5;
const int kM = 4e3 + 5;
const int Mod = 1e9 + 7;

int n;
int a[kN], l[kN][kM], r[kN][kM];

inline bool Match (const int &x, const int &y) {
  return x == y || x == 3 || y == 3;
} 

int main () {
  cin.tie(0)->sync_with_stdio(0);
  cin >> n;
  for (int i = n; i; --i) {
    char c;
    cin >> c;
    a[i] = (c == '?' ? 3 : c - '0');
  }
  static int f[kM][kM];
  for (int j = 0; j <= n * 2; ++j) {
    f[j][0] = 1, l[0][j] = r[0][j] = 0; 
  }
  int ans = 0;  
  for (int i = 1; i <= n; ++i) {
    static int g[kM][kM];
    for (int j = 0; j <= (n - i + 1) * 2; ++j) {
      for (int k = 0; k <= r[i - 1][j] - l[i - 1][j]; ++k) {
        g[j][k] = f[j][k];
      }
    }
    for (int j = 0; j <= (n - i) * 2; ++j) {
      l[i][j] = n * 2 + 1, r[i][j] = -1;
    }
    for (int j = 0; j <= (n - i + 1) * 2; ++j) {
      for (int k = l[i - 1][j]; k <= r[i - 1][j]; ++k) {
        for (int v = 0; v <= min(j, 2); ++v) {
          int _j = j - v, _k = (j + k) / 3;
          l[i][_j] = min(l[i][_j], _k);
          r[i][_j] = max(r[i][_j], _k);
        }
      }
    }
    for (int j = 0; j <= (n - i) * 2; ++j) {
      for (int k = 0; k <= r[i][j] - l[i][j]; ++k) {
        f[j][k] = 0;
      }
    }
    for (int j = 0; j <= (n - i + 1) * 2; ++j) {
      for (int k = l[i - 1][j]; k <= r[i - 1][j]; ++k) {
        int val = g[j][k - l[i - 1][j]];
        for (int v = 0; v <= min(j, 2); ++v) {
          if (!val || !Match((j + k) % 3, a[i])) continue;
          int _j = j - v, _k = (j + k) / 3;
          f[_j][_k - l[i][_j]] = (f[_j][_k - l[i][_j]] + val) % Mod;
        }
      }
    }
  }
  if (l[n][0] != 0) return cout << 0 << '\n', 0; 
  cout << f[0][0] << '\n';
  return 0; 
}
```

---

## 作者：gcx12012 (赞：2)

### 前言
作为赛时通过选手贡献一个搞笑做法。
### Solution
我们不难想到一个 $O(n^3)$ 的 dp：设 $f_{i,j,k}$ 表示当前考虑到第 $i$ 位，前 $i$ 位的三进制数位和为 $j$，第 $i$ 位对前一位的进位贡献为 $k$。

然后直接根据题目转移即可，考虑 $k$ 只能取 $\frac{j}{3}$ 到 $\frac{j}{2}$ 之间的整数，这是显然的，然后 dp 值为 0 的不转移，再稍微卡一下别的就能过题了。

代码比较简单，就不放了。

---

## 作者：masonpop (赞：1)

来点神秘做法。尚不清楚是不是正解。

考虑题目要求计数的相当于是如下形式的长度为 $d$ 的序列：从低位到高位每一位的值不增，且相邻两位的差不超过 $2$，将其转化为三进制数后要满足题目给定的限制。

直接设 $f_{i,j,k}$ 表示从低到高考虑前 $i$ 位，最后一位的值是 $j$，对下一位有 $k$ 的进位的方案数。转移枚举下一位的值（显然应在 $[\max(j-2,0),j]$ 内枚举），就可以做到 $O(d^3)$ 了，有 70 分。

但是这个状态看上去完全跑不满！我们把一个全是 ? 的极限数据塞进去跑一下，发现只有大约 $1.1\times 10^7$ 个有效状态！于是使用一个 vector 维护有效状态就可以通过了。

---

## 作者：zhongxicheng (赞：1)

### 题意

对于一个 $n$ 位三进制数 $a$（可以有前导零），设 $a_i$ 表示 $a$ 的第 $i$ 位（$a_1$ 表示 $a$ 的个位，以此类推）。令：
$$f(a)=\sum_{i=1}^{n}\sum_{j=i}^{n}3^{j-i}\times a_j$$

不难发现，$f(a)$ 表示路径终点点权为 $a$ 时，路径的点权和。

题意即求有多少个 $a$，满足 $f(a)$ 的三进制形如给定字符串。

### 思路

先对 $f(a)$ 变形，得：
$$f(a)=\sum_{i=1}^{n}(3^{i-1}\times \sum_{j=i}^n a_j)$$

于是，在不考虑 $f(a)$ 的进位的情况下，$f(a)$ 的第 $i$ 位就是 $a_i+a_{i+1}+\dots+a_n$。

由此，$f(a)$ 的某一位不仅受更低位产生的进位影响，也受更高位之和影响，这启发我们设计 DP 状态同时考虑这两个影响。

设 $f_{i,j,k}$ 表示 $a_{1\dots i}$ 已经确定，还未确定的部分数位和为 $j$，且相比于 $a_{1\dots i}$ 全部为零，$f(a)$ 的第 $i$ 位又额外向第 $i+1$ 位进了 $k$ 个数时的状态。

因为 $a_{1\dots i}$ 对 $f(a)$ 的贡献大小至多为这些位均为 $2$ 时的贡献，则：
$$S_{max}=\sum_{t=1}^{i}(3^t-1)<\frac{3^{i+1}-1}{2}<2\times 3^i$$
所以就算加上高位之和进位后的残留，$a_{1\dots i}$ 产生的进位至多为 $2$，即 $k\in\{0,1,2\}$，状态数为 $O(n^2)$。

还有一个问题，就是如何计算高位的和 $j$ 下放到低 $i$ 位对于 $f(a)$ 的第 $i+1$ 位原本能产生的进位。这是可以用等比数列求和公式在 $O(1)$ 时间内计算的，此处略去不表。代码中用 `calc` 函数表示这一结果。

状态转移方程见代码。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int mod = 1e9+7,N = 2003;
int n, f[N][N*2][3];
char s[N];

int calc(int S,int w) {
	if(w>16) return int(S/2.0-0.1);
	return int(S/2.0-S/(2.0*pow(3,w)));
}

int main() {
	
	scanf("%d%s",&n,s+1);
	reverse(s+1,s+1+n);
	
	register int i,j,k,t,nx;
	for(i=0;i<=n*2;i++)
		f[0][i][0] = 1;
	
	for(i=0;i<n;i++) for(j=0;j<=2*(n-i);j++)
		for(k=0;k<=2;k++) if(f[i][j][k]) {
			for( t=0; t<=2 && t<=j; t++ ) {
				nx = k+(i?calc(j,i):0)+j;//表示f(a)的第i+1位的结果
				if( s[i+1]=='?' || (nx%3)==(s[i+1]-'0') )
					( f[i+1][j-t][nx/3-calc(j-t,i+1)]
						+= f[i][j][k] ) %= mod;
			}
		}
				
	printf("%d",f[n][0][0]);
	return 0;
}
```

---

## 作者：modfish_ (赞：0)

感觉我的做法有点唐了……

## 思路
容易发现在这棵三叉树上，对于每一个点 $x$ 及其父亲 $f$，有 $a_f=\displaystyle\lfloor\frac{a_x}{3}\rfloor$，也就是 $a_x$ 的三进制表示去掉末位。

所以不妨设走 $d$ 步到达的点的权值的三进制表示从低到高依次为 $x_1,x_2,\dots,x_d$，可以发现总权值即为 $k=(x_dx_{d-1}\dots x_1)_3+(x_dx_{d-1}\dots x_2)_3+\dots+(x_dx_{d-1})_3+(x_d)_3$。

对每一位分别计算贡献，上式也可以写为：

$$k=\sum_{i=1}^dx_i\times\frac{3^i-1}{2}=\frac{1}{2}(\sum_{i=1}^d3^i x_i-\sum_{i=1}^dx_i)$$

其中应用了等比数列求和公式 $\displaystyle\sum_{j=0}^{i-1}3^j=\frac{3^i-1}{2}$。

如果我们移项，可以得到：

$$\sum_{i=1}^d3^i x_i=2k+\sum_{i=1}^dx_i$$

所以，把 $k$ 乘 $2$，再加上终点权值数位和 $S=\sum_{i=1}^dx_i$，就可以得到终点权值三进制表示左移一位的结果。

很容易设计出一个 DP 状态：$f_{i,t,k,j}$ 表示处理了 $k$ 的 $0$ 到 $i$ 位，枚举的数位和 $S$ 为 $t$，当前已计算的 $2k+S$ 的数位和为 $k$，向下一位进位为 $j$。

转移直接枚举 $k$ 的这一位填什么即可。状态数为 $O(d^3)$，其中，可以发现进位数 $j$ 最多为 $2$。

无法通过，考虑优化。注意到数为和 $S$ 对 $2k+S$ 的当前位结果，只有在 $0\le i\le \log_3 S$ 时才有影响。而 $\log_3 S\le \log_3 2n$，最多只到 $i=7$。所以这一个 DP 只用做到第 $7$ 位就够了。

接下来的 DP 过程中，我们根本不关心 $t$ 和 $k$ 各是多少，我们只关心 $t-k$ 最终要变成 $0$。设计新状态：$dp_{i,t',j}$，其中 $t'=t-k$，表示枚举的数位和减去当前已处理的数位和，$j$ 仍表示进位。

这样最终答案即为 $dp_{d,0,0}$（注意要把 $k$ 的第 $d$ 位补成 $0$ 并 DP 到第 $d$ 位）。时间复杂度为 $O(d^2\log d)$。

## 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn = 2100, p = 1e9 + 7;

char s[maxn];
int f[2][maxn << 1][20][5], dp[2][maxn << 1][5], pw[maxn];

int main(){
    int n;
    scanf("%d %s", &n, s);
    pw[0] = 1;
    for(int i = 1; i <= n; i ++) pw[i] = pw[i - 1] * 3ll % p;
    for(int i = 0; i < n; i ++) if(i < n - i - 1) swap(s[i], s[n - i - 1]);
    int u = 0;
    s[n] = '0';
    for(int t = 0; t <= n * 2; t ++) f[0][t][0][0] = 1;
    for(int i = 0; i <= n; i ++){
        int b0, b1;
        if(s[i] == '?') b0 = 0, b1 = 2;
        else b0 = b1 = s[i] - 48;
        u ^= 1;
        if(i <= 7){
            for(int t = 0; t <= n * 2; t ++) for(int k = 0; k <= 14; k ++) for(int j = 0; j <= 2; j ++) f[u][t][k][j] = 0;
            for(int t = 0; t <= n * 2; t ++){
                for(int k = 0; k <= 14; k ++){
                    for(int j = 0; j <= 2; j ++){
                        if(!f[u ^ 1][t][k][j]) continue;
                        for(int b = b0; b <= b1; b ++){
                            int tt = t;
                            for(int x = 1; x <= i; x ++) tt /= 3;
                            int now = b * 2 + tt % 3 + j;
                            if(i == 0 && now % 3 != 0) continue;
                            if(k + now % 3 <= 14) f[u][t][k + now % 3][now / 3] = (f[u][t][k + now % 3][now / 3] + f[u ^ 1][t][k][j]) % p;
                        }
                    }
                }
            }
        }else{
            for(int t = 0; t <= n * 2; t ++) for(int j = 0; j <= 2; j ++) dp[u][t][j] = 0;
            for(int t = 0; t <= n * 2; t ++){
                for(int j = 0; j <= 2; j ++){
                    if(!dp[u ^ 1][t][j]) continue;
                    for(int b = b0; b <= b1; b ++){
                        int now = b * 2 + j, tp = t - now % 3;
                        if(tp >= 0 && tp <= n * 2) dp[u][tp][now / 3] = (dp[u][tp][now / 3] + dp[u ^ 1][t][j]) % p;
                    }
                }
            }
        }
        if(i == min(n, 7)){
            for(int t = 0; t <= n * 2; t ++) for(int k = 0; k <= 14; k ++) for(int j = 0; j <= 2; j ++) dp[u][t - k][j] = (dp[u][t - k][j] + f[u][t][k][j]) % p;
        }
    }
    printf("%d\n", dp[u][0][0]);
    return 0;
}
```

---


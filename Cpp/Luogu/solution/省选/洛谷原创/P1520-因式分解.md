# 因式分解

## 题目背景

某天，小 W 正在上数学课，听见老师讲解因式分解增补删除及十字相乘法的技巧，感觉非常厉害，于是想用这些技巧来做题，但做着做着遇到一道不会做的题，你能帮帮他吗？

## 题目描述

在整多项式环内对多项式 $x^n-1$ 作因式分解（简单点说就是做因式分解题），要求分解到全部为素多项式为止（即最后结果不能有可继续分解的多项式）。

## 说明/提示

### 提示

$(x^n-1)/(x+1)=\cdots$

### 数据范围及约定

- 对 $20\%$ 数据，$1 \le n \le 200$；
- 对 $100\%$ 数据，$1 \le n \le 5000$。

## 样例 #1

### 输入

```
12```

### 输出

```
(x-1)(x+1)(x^2+1)(x^2-x+1)(x^2+x+1)(x^4-x^2+1)```

# 题解

## 作者：NaCly_Fish (赞：22)

已重制，尽可能兼顾浅显易懂与严谨性地说明这题。
****
### 思路

我们要对 $x^n-1$ 进行因式分解，而我们知道的是 $x^n-1$ 有 $n$ 个复根，称为**单位根**，分别记为 $\omega_n^0,\omega_n^1,\cdots,\omega_n^{n-1}$。

也就是说：
$$x^n-1=\prod_{k=0}^{n-1}(x-\omega_n^k)$$
如果能对这 $n$ 个根进行分组，使得每一组构成的多项式都是**整系数的**，且**不可约**，那么我们就完成了此问题。
****
### 分圆多项式

方便后面表述，这里定义：对于复数 $z$，若 $z^n=1$，且对于任意整数 $m \ (m\in[0,n-1])$ 都有  $z^m \neq 1$，就称 $z$ 为 $n$ 次**本原单位根**。


定义**分圆多项式** $\phi_n(x)$ 为
$$\phi_n(x)=\prod_{k=0}^{n-1}(x-\omega_n^k)^{[\gcd(n,k)=1]}$$
（即它是由所有 $n$ 次本原单位根构成的首项为 $1$ 的多项式）

对于任意 $n$ 次单位根 $z$，都存在**唯一的** $d \mid n$，使得 $z$ 是 $d$ 次本原单位根。这是因为若 $z=\omega_n^k$，取 $d=\gcd(n,k)$
，那么 $z=\omega_{n/d}^{k/d}$，$z$ 是 $n/d$ 次本原单位根。

使用这种方法来分配 $n$ 次单位根，$x^n-1$ 可以表示为分圆多项式的乘积：

$$x^n-1=\prod_{d|n}\phi_d(x) \quad \texttt{(1)}$$
然后你可能会问，$\phi_d(x)$ 怎么算？  

将等式两边取对数，得

$$\ln(x^n-1)=\sum_{d|n}\ln\phi_d(x)$$
看到这个形式想到什么？没错，就是 mobius 反演。
$$\ln\phi_n(x)=\sum_{d|n}\ln(x^d-1)\mu\left(\frac nd \right)$$
再 $\exp$ 回去，结果就出来了
$$\phi_n(x)=\prod_{d|n}(x^d-1)^{\mu\left(\frac nd \right)} \quad \texttt{(2)}$$
如果想了解相关证明，还请继续往下阅读。
****
### 整系数的证明

先来证明个简单的：$\phi_n(x)$ 是整系数多项式。

不妨考虑将 $\texttt{(2)}$ 式中的乘积分组，将 $\mu(n/d)=1$ 的部分记为 $A(x)$，将 $\mu(n/d)=-1$ 的记为 $1/B(x)$。

显然 $A(x)$ 和 $B(x)$ 都是首项为 $1$ 的整系数多项式，且 $A(x)/B(x)$ 是一个有理系数的多项式。再加上 $B(x)$ 的首项系数为 $1$，使用 [多项式除法](https://www.luogu.com.cn/problem/P4512) 的计算过程中必然都是整数，所以 $\phi_n(x)$ 是整系数多项式。
****
### 引入：最小多项式

证明 $\phi_n(x)$ 在有理数域上的不可约性比较麻烦。我们要引入一个重要概念：**最小多项式**。
> 对于一个代数数 $\alpha$，能满足 $f(\alpha)=0$ 的、非常数的、首项为 $1$ 且次数最低的多项式称为「最小多项式」。

最小多项式有三大性质：「不可约性」、「唯一性」，以及任意以 $\alpha$ 为根的多项式都能被 $f(x)$ 整除。具体证明见 [wiki 上的页面](https://en.wikipedia.org/wiki/Minimal_polynomial_(field_theory))。
****
### 不可约性的证明

现在让我们开始吧！

考虑反证法，假设 $\phi_n(x)$ 在有理数域上可约。那么存在一个最高次项系数为 $1$ 的、非常数的、整系数不可约多项式 $f(x)$ 为 $\phi_n(x)$ 的因式。现在就可以将其写为 $\phi_n(x)=f(x)g(x)$。

然后选取 $\epsilon$ 和 $\zeta$ 分别为 $f(x)$ 和 $g(x)$ 的根（显然它们也都是 $n$ 次本原单位根）。不过我们的选取有条件，要使得 $\zeta=\epsilon^k$ 中的 $k$ **最小**。  
值得说明的是：固定 $\zeta$ 与 $\epsilon$ 时，这样的 $k$ 唯一存在。因为设 $\zeta=\omega_n^a$，$\epsilon=\omega_n^b$（$a,b$ 均与 $n$ 互质），那么 $a\equiv bk\pmod n$ 在 $n$ 以内有唯一解。

找出 $k$ 的最小质因子 $p$，那么有 $n\bmod p \neq 0$，所以 $\epsilon^p$ 也是 $n$ 次本原单位根。根据分解的结果，$\epsilon^p$ 要么是 $f(x)$ 的根，要么是 $g(x)$ 的根。  

如果 $f(\epsilon^p)=0$，那么 $\zeta = (\epsilon^p)^{k/p}$，这说明我们选取的这组 $(\epsilon,\zeta)$ 没能使得 $k$ 最小，与假设矛盾；  
所以只能是 $g(\epsilon^p)=0$。再根据假设，$k$ 已经取到最小了，那就只能有 $k=p$，即最小的 $k$ 必然是个质数。

进一步地，根据 $f(x)$ 的不可约性与 $f(\epsilon)=0$，可知 $f(x)$ 是 $\mathbb Q$ 中 $\epsilon$ 的最小多项式。由于 $g(\epsilon^p)=0$，所以 $f(x)$ 能整除 $g(x^p)$（使用引理）。


现在我们将问题转移到有限域 $\mathbb F_p$ 中。  
在 $\mathbb F_p[x]$ 上的多项式 $h(x)$ 总有 $h(x)^p=h(x^p)$（这是 Lucas 定理）：

$$h(x)^p\equiv \sum_{i=0}^p\binom pi \left( \frac{h(x)-h_0}{x} \right)^{p-i} x^{p-i}h_0^i\equiv h_0^p+x^p\left( \frac{h(x)-h_0}{x} \right)^p \pmod p$$
如此展开下去计算即可证明。


然后对于整系数多项式 $f(x)$，我们记 $\bar f(x)$ 是其映射到 $\mathbb F_p[x]$ 上的结果。具体地，就是将每一项系数都对 $p$ 取模。

现在我们知道，$\bar \phi_n(x)=\bar f(x) \bar g(x)^p$。由于 $\bar f(x)$ 是 $\bar g(x)^p$ 的因式，$\bar f(x)$ 和 $\bar g(x)$ 之间必然存在一个公因式 $\bar d(x)$。现在也就是说，$\bar \phi_n(x)$ 里面有重复的因式 $\bar d(x)$，对于 $\bar F(x)$ 也会有重因式（$F(x)=x^n-1$）。

最后，我们发现 $\bar F'(x)=n x^{n-1} \neq 0$（因为 $n \bmod p \neq 0$）。按理说若 $\bar F(x)$ 有重因式，$\bar F(x)$ 与 $\bar F'(x)$ 就会有公因式 —— 但现在看来这不可能，因为 $\bar F(x)$ 没有 $0$ 作为根而 $\bar F'(x)$ 只有 $0$ 是根。这样就导出了矛盾。

即，$\phi_n(x)$ 在有理数域上是不可约的。
****
### 计算细节

最后是一些计算上的细节，求 $\phi_n(x)$ 时，需要进行 $2^{\omega(n)}$ 次多项式运算，每次都是 乘/除 一个形如 $x^d-1$ 的多项式，保留到 $\varphi(n)$ 次系数即可。即求 $\phi_n(x)$ 的时间复杂度为 $2^{\omega(n)}\varphi(n)$，应该没什么特别好的办法优化。

****
### 参考代码


```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#define N 10003
#define ll long long
#define p 998244353
using namespace std;

int mu[N],pr[N>>1];
bool vis[N];

struct poly{
    int a[N];
    int t;
    inline poly(int t=0):t(t){ memset(a,0,sizeof(a)); }
    inline int operator [] (const int& x) const{ return a[x]; }
    inline int& operator [] (const int& x){ return a[x]; }

    inline bool operator < (const poly& b) const{
        if(t!=b.t) return t < b.t;
        for(int i=t;~i;--i){
            if(abs(a[i])!=abs(b[i])) return abs(a[i])<abs(b[i]);
            if(a[i]!=b[i]) return a[i]<b[i];
        }
        return true;
    }

    inline void print(){
        if(abs(a[t])!=1) printf("%dx^%d",a[t],t);
        else{
            if(t==1) putchar('x');
            else printf("x^%d",t);
        }
        for(int i=t-1;i;--i){
            if(a[i]==0) continue;
            if(a[i]>0) putchar('+');
            else putchar('-');
            if(abs(a[i])!=1) printf("%dx",abs(a[i]));
            else putchar('x');
            if(i!=1) printf("^%d",i);
        }
        printf(a[0]>0?"+1":"-1");
    }
}phi[73];

void sieve(int n){
    int cnt = 0;
    mu[1] = 1;
    for(int i=2;i<=n;++i){
        if(!vis[i]){
            pr[++cnt] = i;
            mu[i] = -1;
        }
        for(int j=1;j<=cnt&&i*pr[j]<=n;++j){
            vis[i*pr[j]] = true;
            if(i%pr[j]==0){
                mu[i*pr[j]] = 0;
                break;
            }
            mu[i*pr[j]] = -mu[i];
        }
    }
}

inline void multiply(poly &f,int d){
    f.t += d;
    for(int i=f.t;i>=d;--i) f[i] = f[i-d]-f[i];
    for(int i=0;i!=d;++i) f[i] = -f[i];
}

inline poly getphi(int n){
    static poly mul,div,res;
    mul = div = poly();
    mul[0] = div[0] = 1;
    for(int d=1;d*d<=n;++d){
        if(n%d!=0) continue;
        if(mu[n/d]==1) multiply(mul,d);
        else if(mu[n/d]==-1) multiply(div,d);
        if(d*d==n) continue;
        if(mu[d]==1) multiply(mul,n/d);
        else if(mu[d]==-1) multiply(div,n/d);
    }
    if(div.t==0) return mul;
    res.t = mul.t-div.t;
    res[0] = mul[0]*div[0];
    for(int i=1;i<=res.t;++i){
        res[i] = mul[i];
        for(int j=0;j!=i;++j) res[i] -= res[j]*div[i-j];
        res[i] *= div[0];
    }
    return res;
}

int n,fc;

int main(){
    scanf("%d",&n);
    sieve(n);
    for(int i=1;i*i<=n;++i){
        if(n%i!=0) continue;
        phi[++fc] = getphi(i);
        if(i*i!=n) phi[++fc] = getphi(n/i);
    }
    if(fc==1){
        phi[1].print();
        return 0;
    }
    sort(phi+1,phi+1+fc);
    for(int i=1;i<=fc;++i){
        putchar('(');
        phi[i].print();
        putchar(')');
    }
    return 0;   
}
```

---

## 作者：JustinRochester (赞：8)

[传送门](https://www.luogu.com.cn/problem/P1520)

[双倍经验](https://codeforces.com/group/dIUimH0NFa/contest/375216/problem/C)

---

**【分析】**
--

定义分圆多项式 $\displaystyle \Phi_n(x)=\prod_{i=0}^{n-1} (x-\omega_n^i)^{[\gcd(n, i)=1]}$ ，其中 $\omega_n^i$ 为 $n$ 次单位根。

可以证明的是，所有的分圆多项式都是整数域上不可再分解的素多项式。

我们观察式子显然能发现，该分圆多项式的最高次为欧拉函数 $\boldsymbol \varphi(n)$ ，且系数必定为 $1$ 。

而这个式子有什么用呢？

考虑 $x^n-1=0$ 的所有解，恰好为 $\omega_n^0,\omega_n^1,\cdots, \omega_n^{n-1}$ 。

因此，显然有：

$\begin{aligned}
	x^n-1&=\prod_{i=0}^{n-1}(x-\omega_n^i)
    \\&=\prod_{d\mid n}\prod_{i=0}^{n-1}(x-\omega_n^i)^{[\gcd(n, i)=d]}
    \\&=\prod_{d\mid n}\prod_{i=0}^{{n\over d}-1}(x-\omega_{n\over d}^i)^{[\gcd({n\over d}, i)=1]}
    \\&=\prod_{d\mid n}\Phi_{n\over d}(x)
\end{aligned}$

即 $x^n-1$ 在整数域上分解为素多项式，即需要输出 $n$ 的所有因数 $d$ 对应的分圆多项式 $\Phi_d(x)$ 。

---

分圆多项式 $\Phi_n(x)$ 的求法则是根据上面那个式子：

$\begin{aligned}
	x^n-1&=\prod_{d\mid n}\Phi_d(x)
    \\\ln(x^n-1)&=\sum_{d\mid n}\ln \Phi_d(x)&(\text{两边取 }\ln)
    \\\ln\phi_n(x)&=\sum_{d\mid n}\ln(x^d-1)\cdot \boldsymbol \mu({n\over d})&(\text{莫比乌斯反演})
    \\\Phi_n(x)&=\prod_{d\mid n}(x^d-1)^{\boldsymbol \mu({n\over d})}&(\text{两边取 }\exp)
    \\\Phi_n(x)&=(-1)^{\sum_{d\mid n}\boldsymbol \mu(d) }\cdot \prod_{d\mid n}(1-x^{n\over d})^{\boldsymbol \mu(d)}
    \\\Phi_n(x)&=(-1)^{[n=1]}\cdot \prod_{d\mid n}(1-x^{n\over d})^{\boldsymbol \mu(d)}
\end{aligned}$

考虑到 $\boldsymbol \mu(d)$ 的取值只有 $-1, 0, 1$ 三种，不妨分类讨论一下：

$\boldsymbol \mu(d)=0$ 时，$(1-x^{n\over d})^0$ 对 $\Phi_n(x)$ 的计算没有意义，直接省略。


$\boldsymbol \mu(d)=1$ 时，$(1-x^{n\over d})$ 对 $\Phi_n(x)$ 的计算等价于跑一个01背包。


$\boldsymbol \mu(d)=-1$ 时，${1\over 1-x^{n\over d}}$ 对 $\Phi_n(x)$ 的计算等价于跑一个完全背包。

我们分类存储一下每个 $\boldsymbol \mu(d)$ 非零的 $d$ ，对于倍数 $kd$ 对应的分圆多项式 $\Phi_{kd}(x)$ 贡献的 $(1-x^k)$ 究竟是01背包还是完全背包。

单独把 $\Phi_1(x)$ 的符号取反一下就可以了。

设 $\omega(n)$ 表示 $n$ 的不同质因子数，则求解 $\Phi_n(x)$ 时，由于莫比乌斯函数的容斥，最多只会跑 $2^{\omega(n)}$ 次的背包，每次背包的容积又为 $\boldsymbol \varphi(n)$ 。故求解单个 $\Phi_n(x)$ 的复杂度为 $O(2^{\omega(n)}\cdot \boldsymbol \varphi(n))$ 。

故求解的总复杂度为 $O(\displaystyle \sum_{d\mid n}2^{\omega(d)}\cdot \boldsymbol \varphi(d))$ 。

由于 $\omega(n)$ 为加性函数，$\boldsymbol \varphi(n)$ 为积性函数；故 $2^{\omega(n)}$ 为积性函数；由两个积性函数的点积为积性函数，两个积性函数的迪利克雷卷积也为积性函数；故复杂度的这个函数是个积性函数，可以由线筛得出。

经过筛法求解，这个函数在 $5\times 10^3$ 范围内，最大值为 $110565$ 。

---

**【代码】**
--

注意一下多项式的排序方式和输出规范即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int Lim=1e5, MAXN=Lim+10;
int prime[MAXN], cntprime, fc[MAXN], phi[MAXN], mu[MAXN];
inline void sieve() {
	phi[1]=mu[1]=1;
	for(int i=2; i<=Lim; ++i) {
		if(!fc[i]) {
			fc[i]=prime[++cntprime]=i;
			phi[i]=i-1;
			mu[i]=-1;
		}
		for(int j=1; j<=cntprime; ++j)
			if(prime[j]*i>Lim) break;
			else if(prime[j]==fc[i]) {
				fc[prime[j]*i]=prime[j];
				phi[prime[j]*i]=prime[j]*phi[i];
				mu[prime[j]*i]=0;
				break;
			}
			else {
				fc[prime[j]*i]=prime[j];
				phi[prime[j]*i]=phi[prime[j]]*phi[i];
				mu[prime[j]*i]=-mu[i];
			}
	}
}

vector<int> con[MAXN][2], d[MAXN];
inline void init() {
	sieve();
	for(int i=1; i<=Lim; ++i) if(mu[i])
		for(int j=i, k=1; j<=Lim; j+=i, ++k)
			con[j][mu[i]==1].push_back(k);
	for(int i=1; i<=Lim; ++i)
		for(int j=i; j<=Lim; j+=i)
			d[j].push_back(i);
}

struct poly : vector<int> {
	inline bool operator < (const poly &x) const {
		if(size()!=x.size())
			return size()<x.size();
		for(int i=size()-1; i>=0; --i)
			if(abs(at(i))!=abs(x[i]))
				return abs(at(i))<abs(x[i]);
			else if((at(i)<0)^(x[i]<0))
				return at(i)<0;
		return 0;
	}
	inline friend ostream& operator << (ostream& out, const poly &p) {
		out<<"(";
		for(int I=p.size()-1, i=I; i>=0; --i) {
			if(p[i]==0) continue;
			if(i!=I&&p[i]>0) out<<"+";
			if(i==0) {
				out<<p[i];
				continue;
			}
			if(p[i]==-1) out<<"-";
			else if(p[i]!=1) out<<p[i];
			if(i>1) out<<"x^"<<i;
			else if(i==1) out<<"x";
		}
		return out<<")";
	}
}p[MAXN];
bool vis[MAXN];
inline void calc(int n) {
	poly& phin=p[n];
	phin.resize(phi[n]+1);
	phin[0]=1;
	for(auto e : con[n][1])
		for(int i=phi[n]; i>=e; --i)
			phin[i]-=phin[i-e];
	for(auto e : con[n][0])
		for(int i=e, I=phi[n]; i<=I; ++i)
			phin[i]+=phin[i-e];
	vis[n]=1;
}

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	init();
	calc(1); for(auto &e : p[1]) e=-e;
	int T=1, n;
	while(T--&&cin>>n) {
		if(n==1) {
			cout<<"x-1\n";
			break;
		}
		for(auto e : d[n]) 
			if(!vis[e])
				calc(e);
		sort(d[n].begin(), d[n].end(), [](int a, int b) { return p[a]<p[b]; });
		for(auto e : d[n])
			cout<<p[e];
		cout<<"\n";
	}
	cout.flush();
	return 0;
}
```

---

关于双倍经验的题目（其实我是先做了双倍经验的题目再回来做这题的），由于数据范围更大，还加入了 $T$ 组数据，如果暴力跑的话可能复杂度不够。

同上文的分析，在跑满的情况下，复杂度最劣会达到 $5014548\times 100\approx 5\times 10^8$ ，复杂度比较危险。

本人的处理方式是，先 $O(n\log n)$ 预处理，把每个 $\boldsymbol \mu(d)$ 不为零的 $d$ 对倍数 $kd$ 贡献的到底是 $k$ 的01背包还是完全背包先记录下来。

后续询问的过程中，用 `vis` 数组表示这个分圆多项式的最终答案是否已经计算过了。对于每个询问的 $n$ ，我去访问它的所有因子，把它因子中没处理过的分圆多项式给算出来。

虽然最劣的复杂度和把所有分圆多项式都跑一遍没有区别，但是在随机数据的情况下会更优。

注意两题的排序方式不同。

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int Lim=1e5, MAXN=Lim+10;
int prime[MAXN], cntprime, fc[MAXN], phi[MAXN], mu[MAXN];
inline void sieve() {
	phi[1]=mu[1]=1;
	for(int i=2; i<=Lim; ++i) {
		if(!fc[i]) {
			fc[i]=prime[++cntprime]=i;
			phi[i]=i-1;
			mu[i]=-1;
		}
		for(int j=1; j<=cntprime; ++j)
			if(prime[j]*i>Lim) break;
			else if(prime[j]==fc[i]) {
				fc[prime[j]*i]=prime[j];
				phi[prime[j]*i]=prime[j]*phi[i];
				mu[prime[j]*i]=0;
				break;
			}
			else {
				fc[prime[j]*i]=prime[j];
				phi[prime[j]*i]=phi[prime[j]]*phi[i];
				mu[prime[j]*i]=-mu[i];
			}
	}
}

vector<int> con[MAXN][2], d[MAXN];
inline void init() {
	sieve();
	for(int i=1; i<=Lim; ++i) if(mu[i])
		for(int j=i, k=1; j<=Lim; j+=i, ++k)
			con[j][mu[i]==1].push_back(k);
	for(int i=1; i<=Lim; ++i)
		for(int j=i; j<=Lim; j+=i)
			d[j].push_back(i);
}

struct poly : vector<int> {
	inline bool operator < (const poly &x) const {
		if(size()!=x.size())
			return size()<x.size();
		for(int i=size()-1; i>=0; --i)
			if(at(i)!=x[i])
				return at(i)<x[i];
		return 0;
	}
	inline friend ostream& operator << (ostream& out, const poly &p) {
		out<<"(";
		for(int I=p.size()-1, i=I; i>=0; --i) {
			if(p[i]==0) continue;
			if(i!=I&&p[i]>0) out<<"+";
			if(i==0) {
				out<<p[i];
				continue;
			}
			if(p[i]==-1) out<<"-";
			else if(p[i]!=1) out<<p[i];
			if(i>1) out<<"x^"<<i;
			else if(i==1) out<<"x";
		}
		return out<<")";
	}
}p[MAXN];
bool vis[MAXN], sorted[MAXN];
inline void calc(int n) {
	poly& phin=p[n];
	phin.resize(phi[n]+1);
	phin[0]=1;
	for(auto e : con[n][1])
		for(int i=phi[n]; i>=e; --i)
			phin[i]-=phin[i-e];
	for(auto e : con[n][0])
		for(int i=e, I=phi[n]; i<=I; ++i)
			phin[i]+=phin[i-e];
	vis[n]=1;
}

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	init();
	calc(1); for(auto &e : p[1]) e=-e;
	int T, n; cin>>T;
	while(T--&&cin>>n) {
		for(auto e : d[n]) 
			if(!vis[e])
				calc(e);
		sort(d[n].begin(), d[n].end(), [](int a, int b) { return p[a]<p[b]; });
		for(auto e : d[n])
			cout<<p[e];
		cout<<"\n";
	}
	cout.flush();
	return 0;
}
```

---

## 作者：whale_gang (赞：6)

首先这题啊，我非常熟悉，当时我们年级留了一道思考题就是因式分解x^105 -1，允许用数学或编程的方法做，我一下就想到了这题，当然，最后也做了出来。下面，就让我给大家分享一下我的方法吧~

1.分圆多项式
做这题分圆多项式是必不可少的知识。对于整系数多项式我们还有一个简单的事实:如果多项式f(x)在有理数域上可约,那么对任意的素数p，f(x)也可约。反过来，如果存在素数p,f(x)不可约,那么f(x)必定是不可约的，这就为判定不可约多项式提供了另一个有效的法则，它把有理数域(整数环)上的多项式转化到了一个有限域上去了，这个有限域正是素域Zp。这样事实上我们必须要建立有限域上的多项式的理论，才能更好的应用这个方法。下面的一个例子是这方面的一个典型应用：
我们将多项式  分解，它所分解得到的不可约多项式称为分圆多项式。事实上,分圆多项式的定义可以用以下的方式来得到：设ε是  的一个根,即ε是n次单位根，如果对任意的自然数k<n,ε都不是x^k-1的根，那么称ε为n次本原单位根.由所有n次本原单位根构成的多项式就称为n次分圆多项式。
上代码，蒟蒻一枚，大佬勿喷！

```cpp
#include<bits/stdc++.h>
#define _ 0 //看最后一行就明白啦~ 
using namespace std;
struct wow
{
	int zhe[5001], hehe;
	friend bool operator < (wow a, wow b)
	{
    	if(a.hehe < b.hehe )return true;
	    if(a.hehe > b.hehe)return false;
    	for(int i = a.hehe; i >= 0; i--)
		{
        	if(abs(a.zhe[i]) < abs(b.zhe[i]))return true;
        	if(abs(a.zhe[i]) > abs(b.zhe[i]))return false;
        	if(a.zhe[i] < 0 && b.zhe[i] > 0)return true;
        	if(a.zhe[i] > 0 && b.zhe[i] < 0)return false;
    	}
    	return true;
	}
}ti[5001];
int zhen[5000], tot = 0, n;
wow hao[400];
void wan(wow a, wow &b, wow &update)
{
    int alen = a.hehe, blen = b.hehe;
    if(alen < blen)return;
    wow temp;
    memset(temp.zhe, 0, sizeof(temp.zhe)); 
    int s = temp.hehe=alen-blen;
    while(s + 1)
	{
        int k = a.zhe[s + b.hehe];
        temp.zhe[s] = k;
        for(int i = b.hehe; i >= 0; i--)
            a.zhe[i + s] -= k * b.zhe[i];
        s--;
    }
    update = temp;
    return;
}
void print(wow a)
{
    int flag = 1;
    for(int i = a.hehe; i >= 0; i--)
	{
        if(a.zhe[i] == 0)continue;
        if(i == 0)
		{
            if(a.zhe[i] > 0 && !flag)putchar('+');
            cout << a.zhe[i];
            continue;
        }
        if(flag)
		{
            flag = 0;
			if(a.zhe[i] < 0)putchar('-');
        }
        else
		{
            if(a.zhe[i] > 0)putchar('+');
            else putchar('-');
        }
        int t = (a.zhe[i] > 0 ? a.zhe[i]:-(a.zhe[i]));
        if(t != 1)cout << t;
        if(i == 1)putchar('x');
        else printf("x^%d", i);
    }
    return;
}
int main()
{
    cin >> n;
    if(n == 1)
	{
        puts("x-1");
        return ~~(0^_^0);//define _ 0用上了吧~ 
    }
    for(int i = 1; i <= sqrt(n); i++)
		if(n % i == 0)
		{
        	zhen[++tot] = i;
        	if(i * i != n)zhen[++tot] = n / i;
		}
    sort(zhen + 1, zhen + tot + 1);
    for(int i = 1; i <= tot; i++)
	{
        int t = zhen[i];
        ti[t].zhe[t] = 1;
        ti[t].zhe[0] = -1;
        ti[t].hehe = t;
        for(int k = 1; k <= (int)sqrt(t); k++)    
		if(t % k == 0)
		{
        	if(t == 1)break;
            wan(ti[t], ti[k], ti[t]);
            if(k * k != t && k != 1)
                wan(ti[t], ti[t / k], ti[t]);
        }
        hao[i] = ti[t];
    }
    sort(hao + 1, hao + tot + 1);
    for(int i = 1; i <= tot; i++)
	{
        putchar('(');
        print(hao[i]);
        putchar(')');
    }
    return ~~(0^_^0);//祝大家开心每一天鸭~~~ 
}
```


---

## 作者：lala123iop (赞：6)

要用到“分圆多项式”。

所谓分圆多项式，是说它的 \*复数根\* 能够平均分一个圆。

第n个分圆多项式用phi(n)来表示，前几个是：phi(1) = x-1， phi(2) = x+1, phi(3) = x^2+x+1， phi(4) = x^2+1。

仔细看一看。发现， phi(n)的根是x^n-1的根。即phi(n)的根的n次方等于1。这个根从复平面上的(1, 0)出发， 自乘n次之后回到(1, 0)，这个过程把圆x^2+y^2=1分成了n等分。


#分圆多项式的性质

(i)是整系数多项式。

(ii)是不可约多项式（即在以x^n-1=0的解为根的多项式里面，它是次数最小的整系数多项式）。


(iii)是首一的（首项系数是1）。

(iv)成立公式：x^n-1 = ∏[ d|n ]phi(d)，即， x^n-1 = (全部phi(d)的积，其中d整除n)。

#分圆多项式怎么用

公式和不可约性告诉我们，**因式分解x^n-1是∏[ d|n ]phi(d)**，所以求出phi(d)再乘起来即可（手动算一算）


例1，求phi(4)。

首先求phi(2) = (x^2-1) / phi(1)，

倒回去求phi(4) = (x^4-1)  / (phi(2) \* phi(1)) = x^2+1。


例2， 求phi(12)。

公式说需要求phi(1), phi(2), phi(3), phi(4), phi(6)。

看我的：phi(3) = (x^3-1) / phi(1) = x^2+x+1，

从而phi(6) = (x^6-1) / (phi(1) \* phi(2) \* phi(3)) = x^2-x+1，

最后phi(12) = (x^12-1) / (phi(1) \* phi(2) \* phi(3) \* phi(4) \* phi(6)) = x^4-x^2+1。


最后附上丑丑的代码

```cpp
//求分圆多项式 
#include <iostream>
#include <string.h>
#include <cmath>
#include <algorithm>
using namespace std;
struct poly{int cof[5001];int size;} CIR[5001];//CIR代表分圆多项式， cof代表系数 ,size是最高次数 
int factor[5000];
poly FACTOR[400];
int counter = 0;
bool cmp(int aa, int bb){return aa<bb;}//比较整数大小 
bool cmp2(poly aa, poly bb)//比较两个多项式的序 
{
    if (aa.size<bb.size)    return 1;
    if (aa.size>bb.size)return 0;
    for (int i = aa.size;i>=0;i--)
    {
        if (abs(aa.cof[i])<abs(bb.cof[i]))    return 1;
        if (abs(aa.cof[i])>abs(bb.cof[i]))return 0;
        if (aa.cof[i]<0 && bb.cof[i]>0)    return 1;
        if (aa.cof[i]>0 && bb.cof[i]<0)    return 0;
    }
    return 1;
}
int divisionPoly(poly* A, poly* B, poly* aim)//首一多项式的相除 
{
    int sizeA = A->size;
    int sizeB = B->size;
    if (sizeA<sizeB)    return -1;//如果不能除，那就return
    
    //一些临时变量 
    poly AIM;
    memset(AIM.cof, 0, sizeof(AIM.cof));
    AIM.size = sizeA-sizeB;
    int s = AIM.size;
    poly A_ = *A;
    
    //开始计算结果 
    while (s+1)
    {
        int k = A_.cof[s+B->size];
        AIM.cof[s] = k;
        for (int i = B->size;i>=0;i--)//作减法 
        {
            A_.cof[i+s] -= k*B->cof[i];
        }
        
        s--;
    }
    
    //把临时变量AIM赋给*aim
    *aim = AIM;
    return 0;
}
int output(poly* a)//打印多项式 
{
    int flag = 1;
    for (int i = a->size;i>=0;i--)
    {
        if (a->cof[i]==0)continue;
        if (i==0)
        {
            if (a->cof[i]>0 && !flag)    cout<<"+";
            cout<<a->cof[i];
            continue;
        }
        if (flag)
        {
            flag = 0;if (a->cof[i]<0)cout<<'-';
        }
        else
        {
            if (a->cof[i]>0)    cout<<'+';
            else cout<<"-";
        }
        int t = (a->cof[i]>0?a->cof[i]:-(a->cof[i]));
        if (t!=1)cout<<t;
        if (i==1)cout<<"x";
        else cout<<"x^"<<i;
    }
    return 0;
}
int main()
{
    int n = 0;
    cin>>n;
    if (n==1)
    {
        cout<<"x-1";
        return 0;
    }
    
    for (int i = 1;i<=sqrt(n);i++)    if (n%i==0)//计算n的全部因数（注意是全部） 
    {
        factor[++counter] = i;
        if (i*i!=n)    factor[++counter] = n/i;
    }
    sort(factor+1, factor+1+counter, cmp);//排好 
    
    
    for (int i = 1;i<=counter;i++)//最后一步 
    {
        int t = factor[i];//t是n的第i个因数 
        CIR[t].cof[t] = 1;
        CIR[t].cof[0] = -1;
        CIR[t].size = t;//初始为x^t-1 
        

        for (int k = 1;k<=(int)sqrt(t);k++)    if (t%k==0)//分圆多项式的计算公式 
        {
            if (t==1)break;
            divisionPoly(&CIR[t], &CIR[k], &CIR[t]);
            if (k*k!=t && k!=1)
                divisionPoly(&CIR[t], &CIR[t/k], &CIR[t]);
        }        
        FACTOR[i] = CIR[t];

    }
    sort(FACTOR+1, FACTOR+counter+1, cmp2);//多项式排序 
    for (int i = 1;i<=counter;i++)//输出 
    {
        cout<<"(";
        output(&FACTOR[i]);
        cout<<")";
        
    }
    return 0;
}
```

---

## 作者：WorldMachine (赞：4)

分圆多项式太毒瘤了！qwq

---

先尝试几个小的 $n$：
$$
\begin{aligned}
x-1&=x-1\\
x^2-1&=(x-1)(x+1)\\
x^3-1&=(x-1)(x^2+x+1)\\
x^4-1&=(x-1)(x+1)(x^2+1)\\
x^5-1&=(x-1)(x^4+x^3+x^2+x+1)\\
x^6-1&=(x-1)(x+1)(x^2-x+1)(x^2+x+1)\\
x^7-1&=(x-1)(x^6+x^5+x^4+x^3+x^2+x+1)\\
x^8-1&=(x-1)(x+1)(x^2+1)(x^4+1)\\
&\vdots
\end{aligned}
$$
发现右边的项数刚好等于 $n$ 的约数个数。

又由于 $x^n-1$ 的根就是全体 $n$ 次单位根：
$$
x^n-1=\prod_{i=0}^{n-1}(x-\omega_n^i)
$$
因此现在要做的是：将每个 $n$ 次单位根分配给 $n$ 的每个因子 $d$，一个方法是将 $\omega_{n}^i$ 分配给 $\gcd(n,i)$，那么有：
$$
\begin{aligned}
x^n-1&=\prod_{i=0}^{n-1}(x-\omega_n^i)\\
&=\prod_{d|n}\prod_{i=0}^{n-1}(x-\omega_n^i)^{[\gcd(n,i)=d]}\\
&=\prod_{d|n}\prod_{i=0}^{n/d-1}(x-\omega_{n/d}^i)^{[i\perp n/d]}
\end{aligned}
$$
把第二个连乘里的东西记作 $\phi_{n/d}(x)$，那么有：
$$
\begin{aligned}
x^n-1&=\prod_{d|n}\phi_{n/d}(x)\\
&=\prod_{d|n}\phi_d(x)
\end{aligned}
$$
上面的 $\phi$ 便是我们称之为**分圆多项式**的东西，这个看似从天而降的想法其实有很简单的动机。

---

需要证明两个东西：$\phi_n(x)$ 是整系数多项式，并且不可分解成两个次数更小的整系数多项式的乘积（不可约多项式）。

数学归纳法，假设已证得 $\forall m<n,\phi_m(x)$ 均为整系数多项式，由于：
$$
x^n-1=\phi_n(x)\prod_{d|n,d<n}\phi_d(x)\Rightarrow\phi_n(x)=\dfrac{x^n-1}{\prod_{d|n,d<n}\phi_d(x)}
$$
由高斯引理得 $\prod_{d|n,d<n}\phi_d(x)$ 为本原多项式，故 $\phi_n(x)$ 为整系数多项式。

---

然后证 $\phi_n(x)$ 是不可约多项式。

反证，设 $\phi_n(x)=f(x)g(x)$，其中 $f,g$ 均是首一多项式，且 $f(x)\not=1$ 且不可约。证明思路是得出 $\phi_n$ 的所有根均为 $f$ 的根，进而有 $\phi_n(x)=f(x)$。

设 $z$ 是 $f(x)$ 的一个根，$p$ 是一个与 $n$ 互素的素数，那么 $z^p$ 是 $\phi_n(x)$ 的根，即是 $f(x)$ 或 $g(x)$ 的根。

下面假设 $z^p$ 是 $g(x)$ 的根，从而导出矛盾。由假设得 $z$ 是 $f(x)$ 和 $g(x^p)$ 的公共根，从而有 $f(x)\mid g(x^p)$，设 $g(x^p)=f(x)h(x)$，那么 $f(x)h(x)\equiv g(x^p)\equiv g(x)^p\pmod p$（使用 Lucas 定理）。

设 $x^n-1=\phi_n(x)r(x)$，那么 $x^n-1\equiv f(x)g(x)r(x)\pmod p$。由域上多项式的分解的唯一性，$f(x)$ 作为模 $p$ 意义下的多项式，其每个不可约因子 $u(x)\mid g(x)^p$，因而也有 $u(x)\mid g(x)$，这说明 $x^n-1$ 在模 $p$ 意义下有重因式 $u(x)$，即 $x^n-1\equiv0\pmod p$ 有重根，与 $\gcd(n,p)=1$ 矛盾。

故 $z^p$ 只能是 $f(x)$ 的根，由此可得 $\phi_n$ 的所有根均为 $f$ 的根，故 $\phi_n(x)=f(x)$，即 $\phi_n(x)$ 是不可约多项式。

---

因此一开始的式子：
$$
x^n-1=\prod_{d\mid n}\phi_d(x)
$$
的确给出了 $x^n-1$ 的完全分解。

现在考虑如何计算分圆多项式 $\phi_n(x)$。

两边同时取 $\ln$：
$$
\ln(x^n-1)=\sum_{d|n}\ln\phi_d(x)
$$
使用莫比乌斯反演：
$$
\ln\phi_n(x)=\sum_{d|n}\ln(x^d-1)\mu\left(\dfrac nd\right)
$$
再 $\exp$ 回去：
$$
\phi_n(x)=\prod_{d|n}(x^d-1)^{\mu(\frac nd)}=\prod_{d|n}(x^{\frac{n}{d}}-1)^{\mu(d)}
$$
把负号提一个出来：
$$
\phi_n(x)=(-1)^{\sum_{d|n}\mu(d)}\prod_{d|n}(1-x^{\frac{n}{d}})^{\mu(d)}=(-1)^{[n=1]}\prod_{d|n}(1-x^{\frac{n}{d}})^{\mu(d)}
$$
分 $\mu(d)$ 的取值讨论：

- 若 $\mu(d)=0$，对答案不会有影响；
- 若 $\mu(d)=1$，即乘上 $1-x^{\frac{n}{d}}$，跑一个 01 背包状的东西即可；
- 若 $\mu(d)=-1$，即乘上 $\dfrac{1}{1-x^{\frac nd}}=1+x^{\frac nd}+x^{\frac{2n}{d}}+\dots$，跑一个完全背包即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef vector<int> vec;
const int N = 5005;
int n, tot, pri[N], mu[N], cnt;
bool vis[N];
vec ans[N];
bool cmp(const vec &a, const vec &b) {
	int sa = a.size(), sb = b.size();
	if (sa != sb) return sa < sb;
	for (int i = sa - 1; ~i; i--) {
		if (abs(a[i]) != abs(b[i])) return abs(a[i]) < abs(b[i]);
		else if ((a[i] < 0) ^ (b[i] < 0)) return a[i] < 0;
	}
	return 0;
}
void sieve(int n) {
	mu[1] = 1;
	for (int i = 2, k; i <= n; i++) {
		if (!vis[i]) pri[++tot] = i, mu[i] = -1;
		for (int j = 1; j <= tot && (k = i * pri[j]) <= n; j++) {
			vis[k] = 1;
			if (!(i % pri[j])) break;
			mu[k] = -mu[i];
		}
	}
}
vec calc(int n) {
	vec a, b, c; c.resize(n + 1), c[0] = 1;
	for (int i = 1; i * i <= n; i++) {
		if (n % i) continue;
		if (mu[n / i] == 1) a.push_back(i);
		else if (mu[n / i] == -1) b.push_back(i);
		if (i * i == n) continue;
		if (mu[i] == 1) a.push_back(n / i);
		else if (mu[i] == -1) b.push_back(n / i);
	}
	for (int x : a) for (int i = n; i >= x; i--) c[i] -= c[i - x];
	for (int x : b) for (int i = x; i <= n; i++) c[i] += c[i - x];
	if (n == 1) for (int &x : c) x = -x;
	while (!c.back()) c.pop_back();
	return c;
}
void print(const vec &a) {
	int s = a.size() - 1;
	for (int i = s; ~i; i--) {
//		cerr << a[i] << ' ';
		if (a[i] == 0) continue;
		if (a[i] == 1) {
			if (i != s) putchar('+');
			if (i == 0) putchar('1');
		} else if (a[i] == -1) {
			putchar('-');
			if (i == 0) putchar('1');
		} else if (a[i] > 0) {
			if (i == s) printf("%d", a[i]);
			else printf("+%d", a[i]);
		} else printf("%d", a[i]);
		if (i != 0) {
			if (i > 1) printf("x^%d", i);
			else putchar('x');
		}
	}
}
int main() {
	scanf("%d", &n), sieve(n);
	if (n == 1) return puts("x-1"), 0;
	for (int i = 1; i * i <= n; i++) {
		if (n % i) continue;
		ans[++cnt] = calc(i);
		if (i * i != n) ans[++cnt] = calc(n / i);
	}
	sort(ans + 1, ans + 1 + cnt, cmp);
	for (int i = 1; i <= cnt; i++) putchar('('), print(ans[i]), putchar(')');
}
```

---

## 作者：Acoipp (赞：3)

## 分析

在 $Z[x]$ 上对 $x^n-1$ 进行分解，容易发现：

$$
x^n-1=\prod_{d \mid n}\phi_d(x)
$$

还有：

$$
\phi_n(x)=\prod_{d \mid n}(x^d-1)^{\mu(\frac nd)}
$$

上面的两个是分圆多项式的基本知识，这里不再赘述，感兴趣的同学可以左转 [_HofFen 的博客园](https://www.cnblogs.com/AllWeKnow/p/13518485.html)。

我们重点讲解如何快速把上面的式子求出来。

我们可以化简一下形式：

$$
\begin{aligned}

\phi_n(x)&=\prod_{d \mid n}(x^d-1)^{\mu(\frac nd)} \\
&=(-1)^{\sum_{d \mid n}\mu(\frac nd)}\prod_{d \mid n}(1-x^d)^{\mu(\frac nd)} \\
&=(-1)^{[n=1]}\prod_{d \mid n}(1-x^d)^{\mu(\frac nd)} \\
\end{aligned} 
$$

所以暴力枚举每个 $d \mid n$ 计算 $\phi_d(x)$ 即可。

**注意：$n=1$ 的时候要反号。**

对于每个 $\phi_n(x)$，枚举 $d \mid n$ 计算后面的一堆连乘就可以了。

先让 $A=1,B=1$。

- 若 $\mu(\frac nd)=0$，不管他就可以了。

- 若 $\mu(\frac nd)=1$，那么让 $A \gets A(1-x^d)$ 即可。

- 否则让 $B \gets B(1-x^d)$ 即可。

我们要求出多项式 $C$ 满足 $A=BC$，于是我们考虑 $A,B$ 的形式，那么我们发现这是一个二项式，每次可以取前面的 $1$ 或者后面一项 $-x^d$。

先把前面的 $A$ 的多项式用 01 背包展开，然后我们要对 01 背包用 $B$ 中的元素做撤销操作，于是用 01 背包的“逆元”完全背包撤销即可。

最后的结果就是 $C$ 展开之后的样子。

注意 01 背包转移的时候是做减法，不是加法，因为 $x^d$ 前面有负号。

## 代码

代码如下，时间复杂度严格低于 $O(n^2)$，甚至在 $n\le 10^5$ 的时候都跑得飞快。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define N 6005
#define M 205
#define K 100005
using namespace std;
struct vec{vector<ll> op;}p[M],a,b,c,emp;
bool cmp(vec a,vec b){
	if(a.op.size()!=b.op.size()) return a.op.size()<b.op.size();
	for(ll i=a.op.size()-1;i>=0;i--){
		if(abs(a.op[i])!=abs(b.op[i])) return abs(a.op[i])<abs(b.op[i]);
		if(a.op[i]!=b.op[i]) return a.op[i]<b.op[i];
	}
	return 1;
}
ll n,i,pri[K],tot,mu[K],vis[K],ttt;
inline void init(){
	mu[1] = 1;
	for(ll i=2;i<=1e5;i++){
		if(!vis[i]) pri[++tot] = i,mu[i] = -1;
		for(ll j=1;j<=tot;j++){
			if(i*pri[j]>1e5) break;
			vis[i*pri[j]] = 1;
			if(i%pri[j]==0){
				mu[i*pri[j]] = 0;
				break;
			}
			else mu[i*pri[j]] = -mu[i];
		}
	}
}
inline void print(vec a){
	ll fron = 0;
	for(ll i=a.op.size()-1;i>=0;i--){
		if(!a.op[i]) continue;
		if(fron) if(a.op[i]>0) cout<<"+";
		fron=1;
		if(a.op[i]==-1) cout<<"-";
		else if(a.op[i]!=1) cout<<a.op[i];
		if(i==0){
			if(abs(a.op[i])==1) cout<<1;
			continue;
		}
		if(i==1) cout<<"x";
		else cout<<"x^"<<i;
	}
}
inline vec solve(ll x){
	vector<ll> a,b;
	a.clear(),b.clear(),c.op.clear();
	c.op.resize(x+1);
	c.op[0] = 1;
	for(ll i=1;i*i<=x;i++){
		if(x%i!=0) continue;
		if(mu[x/i]==1) a.push_back(i);
		if(mu[x/i]==-1) b.push_back(i);
		if(i!=x/i){
			if(mu[i]==1) a.push_back(x/i);
			if(mu[i]==-1) b.push_back(x/i);
		}
	}
	for(ll i=0;i<a.size();i++) for(ll j=x;j>=a[i];j--) c.op[j] -= c.op[j-a[i]];
	for(ll i=0;i<b.size();i++) for(ll j=b[i];j<=x;j++) c.op[j] += c.op[j-b[i]];
	if(x==1) for(ll i=0;i<c.op.size();i++) c.op[i]=-c.op[i];
	while(c.op.back()==0) c.op.pop_back();
	return c;
}
int main(){
	init();
	cin>>n;
	for(i=1;i*i<=n;i++){
		if(n%i!=0) continue;
		p[++ttt] = solve(i);
		if(n/i!=i) p[++ttt] = solve(n/i);
	}
	sort(p+1,p+ttt+1,cmp);
	if(ttt==1) return print(p[ttt]),0;
	for(i=1;i<=ttt;i++) cout<<'(',print(p[i]),cout<<')';
	return 0;
}
/*
Input:
2

Output:
(x-1)(x+1)
*/
```

---

## 作者：warzone (赞：1)

前置芝士：[域论初步](https://www.luogu.com.cn/article/1xkqf00x)  

复数域上，方程

$$x^n=1$$

有且仅有 $n$ 个根 $\omega_n,\omega_n^2,\cdots,\omega_n^n$，其中 $\omega_n=e^{\frac{2\pi i}{n}}$。

考虑 $x^n-1$ 在 $\mathbb{Q}$ 上的因式分解。  
注意到，$\omega_n,\omega_n^2,\cdots,\omega_n^n$ 关于复数乘法构成循环群，$\omega_n^k$ 为其生成元当且仅当 $k$ 与 $n$ 互质，  
故定义 **分圆多项式**

$$\Phi_n(x)=\prod_{k=1}^n(x-\omega_n^k)^{[\gcd(n,k)=1]}$$

则

$$x^n-1=\prod_{k=1}^n(x-\omega_n^k)=\prod_{d|n}\prod_{k=1}^n(x-\omega_n^k)^{[\gcd(n,k)=d]}$$

$$=\prod_{d|n}\prod_{k=1}^{\frac{n}{d}}(x-\omega_{\frac{n}{d}}^k)^{[\gcd(\frac{n}{d},k)=1]}=\prod_{d|n}\Phi_{\frac{n}{d}}(x)=\prod_{d|n}\Phi_d(x)$$

于是由莫比乌斯反演即可得到计算分圆多项式的一个方法

$$\ln(x^n-1)=\sum_{d|n}\ln\Phi_d(x)$$

$$\ln \Phi_n(x)=\sum_{d|n}\mu\left(\dfrac{n}{d}\right)\ln(x^d-1)$$

$$\Phi_n(x)=\prod_{d|n}(x^d-1)^{\mu\left(\frac{n}{d}\right)}\quad(1)$$

因为 $\mu(n)\in\{1,-1\},x^n-1,\dfrac{1}{x^n-1}=-\displaystyle\sum_{k=0}^{+\infty}x^{nk}\in\Z[[x]]$，

故 $\Phi_n(x)\in\Z[x]$，即 **分圆多项式一定是整系数多项式**。

> 求证：$\Phi_n(x)$ 在 $\mathbb{Q}$ 上不可约。  
> 证明：由高斯引理，设 $\Phi_n(x)=f(x)g(x)\ (f(x),g(x)\in\Z[x])$，  
> $\qquad$ 且 $f(x)$ 在 $\mathbb{Q},\Z$ 上均不可约，只需要证明 $g(x)$ 为常数即可。  
> $\qquad$ 设 $\omega_n$ 为 $f(x)$ 的根，则只需要证明对于任意与 $n$ 互质的正整数 $m$，  
> $\qquad\ \omega_n^m$ 是 $f(x)$ 的根即可。将 $m$ 质因数分解，于是相当于证明，  
> $\qquad$ 若 $\alpha$ 为 $f(x)$ 的一个根，则对于任意小于 $n$，且不是 $n$ 的质因子的的质数 $p$，  
> $\qquad\ \alpha^p$ 也是 $f(x)$ 的一个根。  
> $\qquad$ 假设 $\alpha^p$ 不是 $f(x)$ 的根，即 $\alpha^p$ 是 $g(x)$ 的根，那么 $\alpha$ 就是 $f(x)$ 和 $g(x^p)$ 的公共根。  
> $\qquad$ 又因为 $f(x)$ 是 $\alpha$ 在 $\mathbb{Q}$ 上的极小多项式，故 $g(x^p)\bmod f(x)=0$，  
> $\qquad$ 于是设 $g(x^p)=f(x)h(x)$，由高斯引理可得 $h(x)\in\Z[x]$。  
> $\qquad$ 将等式 $g(x^p)=f(x)h(x)$ 中各多项式的系数对 $p$ 取模，得 
> $$g(x^p)\equiv f(x)h(x)\pmod{p}$$
> $\qquad$ 根据弗洛尼乌斯自同态，
> $$g^p(x)\equiv f(x)h(x)\pmod{p}$$
> $\qquad$ 因此 $\pmod{p}$ 意义下 $f(x)$ 是 $g(x)$ 的因式。又因为
> $$x^n-1\equiv f(x)g(x)\pmod{p}$$
> $\qquad$ 故 $x^n-1$ 在 $\Z_p$ 上不可分，即在分裂域上有重根。又因为 $n$ 与 $p$ 互质，故在 $\Z_p[x]$ 中有
> $$\gcd(x^n-1,(x^n-1)')=\gcd(x^n-1,nx^{n-1})=\gcd(x^n-1,x^{n-1})=1$$
> $\qquad$ 即 $x^n-1$ 在 $\Z_p$ 上可分，产生矛盾。因此 $\Phi_n(x)$ 在 $\mathbb{Q}$ 上不可约。

由上可得，$x^n-1$ 在 $\mathbb{Q}$ 上的因式分解就是

$$x^n-1=\prod_{d|n}\Phi_d(x)$$

除了直接使用式 $(1)$ 计算单个分圆多项式外，我们还可从 $(1)$ 总结出以下性质线性筛出 $\Phi_n(x)$：

1. 若素数 $p$ 是 $n$ 的质因子，则 $\Phi_{pn}(x)=\Phi_n(x^p)$
2. 若素数 $p$ 与 $n$ 互质，则 $\Phi_{pn}(x)=\dfrac{\Phi_n(x^p)}{\Phi_n(x)}$

这就是本题的解法。

## 分圆域及其自同构群

将 $\omega_n$ 加入 $\mathbb{Q}$ 中产生的单扩域 $\mathbb{Q}(\omega_n)$ 称为 **$n$ 次分圆域**。   
由刚才的讨论可知，$\omega_n$ 在 $\mathbb{Q}$ 上的极小多项式为 $\Phi_n(x)$，  
故 $[\mathbb{Q}(\omega_n):\mathbb{Q}]=\deg\Phi_n(x)=\varphi(n)$，$\varphi$ 为欧拉函数。

讨论 $\mathbb{Q}(\omega_n)$ 上的自同构，则对于任意的 $\sigma\in\operatorname{Aut}(\mathbb{Q}(\omega_n))$，必有

$$\sigma(\omega_n)=\omega_n^m\quad (\gcd(n,m)=1)$$

于是

$$\sigma(\omega_n^k)=(\omega_n^m)^k=\omega_n^{mk}$$

又因为 $(\omega_n^{m_1})^{m_2}=\omega_n^{m_1m_2}$，故 **$n$ 次分圆域的自同构群与整数模 $n$ 乘法群 $\Z_n^\times$ 同构**。  
其中，$m\in\Z_n^\times$ 对应同构映射 $\sigma(\omega_n)=\omega_n^m$。

---


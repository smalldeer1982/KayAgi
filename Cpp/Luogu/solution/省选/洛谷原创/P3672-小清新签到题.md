# 小清新签到题

## 题目描述

题目还是简单一点好。

给定自然数 $n$、$k$、$x$，你要求出第 $k$ 小的长度为 $n$ 的逆序对对数为 $x$ 的 $1\sim n$ 的排列 $a_1,a_2 ... a_n$ ~~，然后用仙人图上在线分支定界启发式带花树上下界最小费用流解决问题~~，保证存在。

注：逆序对为满足 $i<j$、$a_i>a_j$ 的 $(i,j)$。比较为字典序比较，即比较从前往后第一个不同的位置。第 $k$ 小从 $1$ 开始标号。一个 $1\sim n$ 的排列定义为一个长度为 $n$ 的数列，排序完可以得到 $1\sim n$。


## 说明/提示

对于 $10\%$ 的数据，$n \leq 8$。

对于 $30\%$ 的数据，$n \leq 10$。

对于 $50\%$ 的数据，$n \leq 50$。

对于另外 $20\%$ 的数据，$k=1$。

对于 $100\%$ 的数据，$1 \leq n \leq 300$，$1 \leq k \leq 10^{13}$，保证存在符合题意的排列。


## 样例 #1

### 输入

```
3 2 2```

### 输出

```
3 1 2```

## 样例 #2

### 输入

```
10 6 4```

### 输出

```
1 2 3 4 5 7 6 10 9 8```

## 样例 #3

### 输入

```
50 233 233```

### 输出

```
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 32 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 33 35 34 31 30 29 28```

## 样例 #4

### 输入

```
50 233333333 333```

### 输出

```
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 43 49 50 47 46 45 48 44 41 42 40 39 37 38 36 35 34 33 32 30 29 31 28 25 26 27 24```

# 题解

## 作者：fjzzq2002 (赞：10)

考虑将一个排列$p_1, p_2 ... p_n$转化到一个容易枚举，容易比较大小的序列上。


对于每个$1 \leq x \leq n$，设$0 \leq a_x \leq n-x$，表示有多少个$y>x$满足$p_y>p_x$。


有了这个序列，我们可以从后往前逐项推出原排列，同时我们可以发现逆序对个数即为$\sum a_x$，并且p的字典序即为a的字典序，证明略。


考虑逐位确定a，那么我们只需记$f[i][j]$表示$a_i ... a_n$的和为j的方案数，前缀和优化dp，dp完逐位确定即可。


因为$f[i][j]$可能会爆long long，我们对于大于$10^{13}$的数就直接取$10^{13}+1$即可。


复杂度$O(n^3)$，开数组时需要小心爆空间。


---

## 作者：Jμdge (赞：4)


先考虑 n 个数排列，有 k 对逆序对 的方案数

我们可以考虑 dp 处理，表达式如下：


$f[n][k]=\sum_{j=k-i+1}^{k} f[n-1][j]$

意思就是我们考虑在 n-1 的排列中插入 n 构成 n 的排列，然后我们可以将 n 插入在位置 x 使得 逆序对个数多出 n-x+1 个，那么每种位置插入方案只有一种，也就可以得到上面的式子了

然后我们考虑贪心去构造一组解，其实就是能放小的数就放小的数，而能放的条件就是放完这个数并考虑了它的贡献之后，存在：后面的数可以构成**逆序对数**等于**剩余贡献**的序列方案


然后上代码



```
//by Judge
#include<cstdio>
#include<iostream>
#define ll long long
using namespace std;
const int inf=1e9+7;
const int N=301;
const int M=N*(N-1)>>1;
typedef int arr[M];
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline int Max(int a,int b){return a>b?a:b;}
inline ll read(){ ll x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} char sr[1<<21],z[20];int C=-1,Z;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
inline void print(int x,char chr=' '){
    if(C>1<<20)Ot();if(x<0)sr[++C]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]=chr;
} int n,m,x,a[N],vis[N]; ll k,f[N][M],s[2][M];
inline void DP(){ f[0][0]=1; int p=0;
	for(int i=0;i<=m;++i) s[p][i]=1;
	for(int i=1;i<=n;++i,p^=1)
		for(int j=0;j<=m;++j){
			int l=Max(0,j-i+1),r=j;
			ll t=!l?s[p][r]:s[p][r]-s[p][l-1];
			f[i][j]=t>k?k+1:t,s[p^1][j]=f[i][j];
			if(j) s[p^1][j]+=s[p^1][j-1];
		}
}
int main(){ cin>>n>>k>>x,m=x,DP();
	for(int i=n;i;--i){ ll cnt=0;
		for(int j=1;j<=n;++j)if(!vis[j]){ int c=j-1;
			for(int t=1;t<j;++t) c-=vis[t];
			if(f[i-1][x-c]+cnt>=k){
				a[n+1-i]=j,vis[j]=1;
				x-=c,k-=cnt;break;
			} cnt+=f[i-1][x-c];
		}
	} for(int i=1;i<=n;++i) print(a[i]); return Ot(),0;
}
```

---

## 作者：皎月半洒花 (赞：3)

> 给定自然数 $n$、$k$、$x$，你要求出第 $k$ 小的长度为 $n$ 的逆序对对数为 $x$ 的 $1\sim n$ 的排列 $a_1,a_2 ... a_n$。
>
> $n\leq 300,k\leq 10^{18}$。

凑排列题。

然后考虑设 $f_{i,j,k}$ 表示剩 $i$ 个数，最左边的数在里面排名为 $j$ ，逆序对数为 $k$ 的方案数。那么转移就是

$$
f_{i,j,k}=\sum_{o=1}^{i-1} f_{i-1,o,k-(j-1)}
$$

~~说实话到这里我本来觉得我把这题给秒了。~~

然后发现凑方案数的话，就只需要枚举每个位置的数是多少即可，这样最终复杂度就是 $O(n^3x)$，并不能过。发现可以前缀和优化一波，最后复杂度就变成了 $O(n^2x)$ 的了。虽然依旧并不可以过得去，但是似乎极限数据跑的也不是慢到直接出不来结果 ~~(指20s之内能跑出来)~~，空间也不是大到本机开不下 ~~(指 `ML = 3801.04 MiB ` )~~。

代码大概是：

```cpp
int len[N] ;
int ans[N] ;
int rk, rst ;
int n, m, x ;
bool vis[N] ;

ll w ;
ll g[2][M] ;
ll* f[N][N] ;

int main(){
    cin >> n >> w >> x ;
    m = (n * (n - 1)) >> 1 ; g[1][0] = 1 ;
    f[1][1] = new ll[1] ; f[1][1][0] = 1 ;
    for (int i = 1 ; i <= n ; ++ i)
        len[i] = min(x, i * (i - 1) / 2) ;
    for (int i = 2, d = 0 ; i <= n ; ++ i){
        fill(g[d], g[d] + m + 1, 0) ;
        for (int j = 1 ; j <= i ; ++ j){
            f[i][j] = new ll[len[i] + 1] ;
            for (int k = j - 1 ; k <= len[i] ; ++ k){
                if (k - (j - 1) > len[i - 1]) break ;
                f[i][j][k] = g[d ^ 1][k - (j - 1)] ;
                if (g[d][k] < w) g[d][k] += f[i][j][k] ;
            }
        }
        d ^= 1 ;
    }
    ll _limit = 0 ;
    for (int i = 1 ; i <= n ; ++ i)
        _limit += 1l * i * len[i] ;
    cout << "ML = " << (4 * (ldb)_limit / 1024 / 1024) << " MiB \n" ;
    for (int i = 1 ; i <= n ; ++ i){
        for (int j = 1, o ; j <= n ; ++ j){
            if (vis[j]) continue ; o = 0 ; int t = 0 ;
            for (int k = 1 ; k <= j ; ++ k) o += (!vis[k]) ;
            if (f[n - i + 1][o][x] < w) w -= f[n - i + 1][o][x] ;
            else { vis[ans[i] = j] = 1 ; x -= (o - 1) ; break ; }
        }
    }
    memset(vis, 0, sizeof(vis)) ;
    debug(ans, 1, n) ; return 0 ;
}

```

然而我还是和这个做法鏖战了很久…企图卡过去…想了半天都不知道该怎么卡，然后卡了一个小时卡自闭了才觉得要「再您????的见」。

但是似乎不难发现，中间有很多状态都是没用的，即存在大量的状态都不会被最后用上，只是单纯的作为一个中间量传递方案数。冷静思考了一下，似乎不需要记录第二维。因为第二维应该填多少完全可以由第三维来确定。于是重新定义状态，$f_{i,k}$ 表示 $i$ 个数有 $k$ 个逆序对的方案数，那么转移就考虑在最左端插入第 $1\sim i$ 小的这些数，即
$$
f_{i,k}=\sum_{j=k-(i-1)}^k f_{i-1,j}
$$
发现同样可以前缀和优化做到 $O(nx)$ 。

之后考虑如何构造方案。发现对于一个 $n$ 位的、逆序对数量为一个确定值 $x$ 的序列，只需要知道当前位选什么，就可以知道之后的逆序对数量从而知道之后的信息。那么即只需要魔改一下，依旧是从小到大对字典序贪心即可。复杂度 $O(nx+n^3)$ 。

```cpp
int len[N] ;
int ans[N] ;
int rk, rst ;
int n, m, x ;
bool vis[N] ;

ll w ;
ll f[N][M] ;
ll g[2][M] ;

int main(){
    cin >> n >> w >> x ;
    f[1][0] = 1 ; g[1][0] = 1 ;
    m = min((n * (n - 1)) >> 1, x) ;
    for (int j = 1 ; j <= m ; ++ j)
        g[1][j] += g[1][j - 1] ; f[0][0] = 1 ;
    for (int i = 2, d = 0 ; i <= n ; ++ i){
        fill(g[d], g[d] + m + 1, 0) ; ll s ;
        for (int j, k = 0 ; k <= m ; ++ k){
            j = max(0, k - i + 1), s = 0 ;
            if (!j) s = g[d  ^  1][k] - 0 ;
            else s = g[d ^ 1][k] - g[d ^ 1][j - 1] ;
            g[d][k] += (f[i][k] = (s > w) ? w + 1 : s) ;
            if (k >= 1) g[d][k] += g[d][k - 1] ;
        }
        d ^= 1 ;
    }
    for (int i = 1 ; i <= n ; ++ i){
        for (int j = 1, o ; j <= n ; ++ j){
            if (vis[j]) continue ; o = 0 ; int t = 0 ;
            for (int k = 1 ; k < j ; ++ k) o += (!vis[k]) ;
            if (f[n - i][x - o] < w) w -= f[n - i][x - o] ;
            else { vis[ans[i] = j] = 1 ; x -= o ; break ; }
        }
    }
    debug(ans, 1, n) ; return 0 ;
}

```



---

## 作者：CuriousCat (赞：1)

讲一下苦逼的wa历程。。。。。。

这个题的dp部分和haoi2009一道题很像，然后你测一下50的样例就会发现它爆了ll，但是说由于有k<=1e13的限制，然后就可以设inf。

重点来了， 你只能对dp数组设置inf，而不能对前缀和sum数组设置inf，因为说有可能会减来减去把中间的dp减掉而导致dp[i][j]本来<inf，然后被设成inf的情况。

wa代码

```cpp
//j是逆序对个数，i是排列长度，f是dp数组
if (j >= i) {
    if (s[(i & 1) ^ 1][j] >= inf) f[i][j] = inf;
    else f[i][j] = s[(i & 1) ^ 1][j] - s[(i & 1) ^ 1][j - i];
}
else f[i][j] = s[(i & 1) ^ 1][j];
if (f[i][j] >= inf) f[i][j] = inf;
s[i & 1][j] = (j ? s[i & 1][j - 1] : 0) + f[i][j];
if (s[i & 1][j] >= inf) s[i & 1][j] = inf;
```
AC代码

```cpp
if (j >= i) f[i][j] = s[(i & 1) ^ 1][j] - s[(i & 1) ^ 1][j - i];
else f[i][j] = s[(i & 1) ^ 1][j];
if (f[i][j] >= inf) f[i][j] = inf;
s[i & 1][j] = (j ? s[i & 1][j - 1] : 0) + f[i][j];
```



---


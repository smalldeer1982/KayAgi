# 曼哈顿序列

## 题目背景

为了研究**一类动态仙人掌图上基于完全可持久化后缀全局平衡树维护的按操作序分治的分支定界启发式带花树上下界最小费用流最后输出两点曼哈顿距离的问题**，will需要生成一些字母序列。


在写生成器的过程中，因为will太弱了，他遇到了一些问题。现在，需要机智的你来帮他解决这些问题。


## 题目描述

序列生成器的工作流程如下：


- will先钦定了一个母序列，长度为N，序列里都是小写字母。

- 子序列定义为：将母序列在任意位置删掉零或多个字符剩下的**非空**序列。例如：ab和ac是abc的子序列，但ca不是。

- 显然，长度为N的序列有$2^N-1$个子序列。

- 将这$2^N-1$个子序列按照字典序排列。will会按照字典序依次生成子序列。

- will希望去掉重复的子序列，如果几个子序列重复（按照字典序大小相等），只生成一个。

- 现在，他想知道，生成器第K次生成的子序列是什么？


## 说明/提示

## 样例的解释

对于母序列abb，有7个子序列，按字典序排列：


- a
- ab
- ab
- abb
- b
- b
- bb

去重后的第3个是abb；


## 数据范围

- 对于20%的数据，$N\leq 15$；

- 对于50%的数据，$N\leq 1000$；

- 对于80%的数据，$N\leq 200000$；

- 对于100%的数据，$N\leq 1000000, K\leq 10^9$，且保证存在第K次的输出；

- 前80%数据的时限为1s，后20%的数据时限为2s。


## 样例 #1

### 输入

```
3 3
abb
```

### 输出

```
abb
```

## 样例 #2

### 输入

```
3 5
abb
```

### 输出

```
bb
```

# 题解

## 作者：hehezhou (赞：9)

[可以到我的博客食用(不一定更佳哦)](https://hehezhou.github.io/2019/06/15/solve-P3728/#more)  
[题面](https://www.luogu.org/problemnew/show/P3728)  
如果要求的是第k小字串(即连续子序列)，是可以用后缀自动机做的  
然而这道题要求第k小子序列  
其实序列自动机也是有的，而且构建及其简单  
状态有$n+1$个，第一个为根，后面的和字符串每一位一一对应  
对于第$i$位对应的状态，接收字符$c$后转移到$j$ 满足  
$$j=\min_{x\in (i,n]~and~s_j=c}x$$  
说人话就是最近的一个$c$  
感性的理解:我从最前面一个走就能涵盖从后面走的所有情况  
然后这个自动机上每一条从根出发的路径唯一对应一个子序列(不重复)  
于是求出每个状态能到达的子序列数(也就是从该点出发的路径数)，然后扫一遍即可(不会的话可以参考后缀自动机的做法)  
注意一下路径数可能会很大很大，不需要高精，如果一个节点对应的路径数超过$k$，那么超过部分显然没有意义，直接赋为$k$即可
```cpp
#include <bits/stdc++.h>
using namespace std;
int son[1000010][26], n, k;
int tot[1000010];
char s[1000010];
int main() {
    scanf("%d%d", &n, &k);
    scanf("%s", s + 1);
    for(int i = n - 1; i >= 0; i--) {//构建序列自动机
        memcpy(son[i], son[i + 1], sizeof(int[26]));
        son[i][s[i + 1] - 'a'] = i + 1;
    }
    for(int i = n; i >= 0; i--) {//0到n为天然的拓扑序
        long long ans = 1;
        for(int j = 0; j < 26; j++) ans += tot[son[i][j]];//计算路径数
        tot[i] = min(ans, (long long)k);//如果过大就钦定为k
    }
    k++;//这种做法会算上空序列
    for(int now = 0; ;) {
        k -= 1;//去掉空序列(最小)
        if(k == 0) return 0;
        for(int j = 0; j < 26; j++) {
            if(son[now][j] == 0) continue;
            if(k > tot[son[now][j]]) k -= tot[son[now][j]];
            else {
                putchar(j + 'a');
                now = son[now][j];
                break;//转换为子问题
            }
        }
    }
}
```

---

## 作者：OldDriverTree (赞：0)

# Solution

首先建出子序列自动机，再 $\text{DP}$ 一遍，求出从每个状态开始可以得到多少子序列，最后在子序列自动机上 $\text{dfs}$ 一遍，对于当前遍历到的状态，要求从这个状态开始能生成的字典序第 $k$ 的子序列，只需要从字符集最小的字符遍历到最大的字符，如果经过当前这个转移边后的状态的 $\text{DP}$ 值小于 $k$，就将 $k$ 减去这个值，否则说明子序列的下一个字符就为这个字符，继续递归即可，时间复杂度 $O(n\vert\Sigma\vert)$。

# Code
```c++
//when you use vector or deque,pay attention to the size of it.
//by OldDirverTree
#include<bits/stdc++.h>
//#include<atcoder/all>
#define P pair<int,int>
#define mid (l+r>>1)
using namespace std;
//using namespace atcoder;
const int N=1e6+1;
int n,m,nxt[N][26];
char s[N]; int f[N];

int read() {
	int x=0; bool f=true; char c=0;
	while (!isdigit(c) ) f&=(c!='-'),c=getchar();
	while (isdigit(c) ) x=(x<<3)+(x<<1)+(c&15),c=getchar();
	return f?x:-x;
}
int dfs(int u) {
	if (f[u]) return f[u]; f[u]=1;
	for (int i=0;i<26;i++) if (nxt[u][i])
	f[u]=min(f[u]+dfs(nxt[u][i]),m+1); return f[u];
}
void solve(int u) {
	m--; if (!m) return;
	for (int i=0;i<26;i++) if (nxt[u][i])
	if (m>f[nxt[u][i] ]) m-=f[nxt[u][i] ];
	else return putchar('a'+i),solve(nxt[u][i]);
}
main()
{
	n=read(),m=read()+1,scanf("%s",s+1);
	for (int i=n;i;i--) {
		for (int j=0;j<26;j++)
		nxt[i-1][j]=nxt[i][j];
		nxt[i-1][s[i]-'a']=i;
	}
	dfs(0),solve(0);
	return 0;
}
```

---


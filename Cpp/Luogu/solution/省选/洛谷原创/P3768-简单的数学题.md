# 简单的数学题

## 题目描述

由于出题人懒得写背景了，题目还是简单一点好。


输入一个整数 $n$ 和一个整数 $p$，你需要求出：

$$\left(\sum_{i=1}^n\sum_{j=1}^n ij \gcd(i,j)\right) \bmod p$$

其中 $\gcd(a,b)$ 表示 $a$ 与 $b$ 的最大公约数。


## 说明/提示

对于 $20\%$ 的数据，$n \leq 1000$。


对于 $30\%$ 的数据，$n \leq 5000$。


对于 $60\%$ 的数据，$n \leq 10^6$，时限 1s。


对于另外 $20\%$ 的数据，$n \leq 10^9$，时限 3s。


对于最后 $20\%$ 的数据，$n \leq 10^{10}$，时限 4s。


对于 $100\%$ 的数据，$5 \times 10^8 \leq p \leq 1.1 \times 10^9$ 且 $p$ 为质数。


## 样例 #1

### 输入

```
998244353 2000```

### 输出

```
883968974```

# 题解

## 作者：yybyyb (赞：140)

很明显的把$gcd$提出来

$$\sum_{d=1}^nd\sum_{i=1}^n\sum_{j=1}^nij[gcd(i,j)==d]$$

习惯性的提出来

$$\sum_{d=1}^nd^3\sum_{i=1}^{n/d}\sum_{j=1}^{n/d}ij[gcd(i,j)==1]$$

后面这玩意很明显的来一发莫比乌斯反演

$$\sum_{d=1}^nd^3\sum_{i=1}^{n/d}\mu(i)i^2(1+2+...[\frac{n}{id}])^2$$

写起来好麻烦呀

我就设$sum(x)=1+2+3+...x$

令$T=id$

提出来！


$$\sum_{T=1}^nsum(\frac{n}{T})^2\sum_{d|T}d^3\frac{T}{d}^2\mu(\frac{T}{d})$$


有些$d$可以约掉

$$\sum_{T=1}^nsum(\frac{n}{T})^2T^2\sum_{d|T}d\mu(\frac{T}{d})$$


现在如果把后面给筛出来

可以$O(\sqrt n)$求啦

现在，问题来了

$$T^2\sum_{d|T}d\mu(\frac{T}{d})$$怎么算？？


考虑一个式子：

$$(id*\mu)(i)=\varphi(i)$$

也就是说，$\mu$和$id(x)=x$的狄利克雷卷积等于$\varphi(i)$

~~太神奇啦！！！~~


所以说，

$$T^2\sum_{d|T}d\mu(\frac{T}{d})=T^2\varphi(T)$$


令$$f(i)=i^2\varphi(i)$$

$$S(n)=\sum_{i=1}^nf(i)$$


杜教筛套路的式子拿出来

$$g(1)S(n)=\sum_{i=1}^n(g*f)(i)-\sum_{i=2}^ng(i)S(\frac{n}{i})$$

还是发现有$\varphi(i)$的项

想到$$\sum_{d|i}\varphi(d)=i$$

所以令$g(x)=x^2$

所以
$$S(n)=\sum_{i=1}^n(g*f)(i)-\sum_{i=2}^ng(i)S(\frac{n}{i})$$


$$(g*f)(i)=\sum_{d|i}f(d)g(\frac{i}{d})=\sum_{d|i}d^2\varphi(d)\frac{i}{d}^2$$
$$=i^2\sum_{d|i}\varphi(d)=i^3$$


所以
$$S(n)=\sum_{i=1}^ni^3-\sum_{i=2}^ni^2S(\frac{n}{i})$$

根据小学奥数的经验：

$1^3+2^3+....n^3=(1+2+....n)^2=sum(n)^2$


所以现在有：

$$ans=\sum_{T=1}^nsum(\frac{n}{T})^2\ T^2\sum_{d|T}d\mu(\frac{T}{d})$$

前面可以数论分块

后面用杜教筛可以再非线性时间里面求出前缀和

这道题目就搞定啦

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<set>
#include<map>
#include<vector>
#include<queue>
using namespace std;
int MAX=8000000;
#define MAXN 8000000
#define ll long long
inline ll read()
{
    ll x=0,t=1;char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
    if(ch=='-')t=-1,ch=getchar();
    while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
    return x*t;
}
ll MOD,n,inv6,inv2;
int pri[MAXN],tot;
ll phi[MAXN+10];
bool zs[MAXN+10];
map<ll,ll> M;
ll fpow(ll a,ll b)
{
    ll s=1;
    while(b){if(b&1)s=s*a%MOD;a=a*a%MOD;b>>=1;}
    return s;
}
void pre()
{
    zs[1]=true;phi[1]=1;
    for(int i=2;i<=MAX;++i)
    {
        if(!zs[i])pri[++tot]=i,phi[i]=i-1;
        for(int j=1;j<=tot&&i*pri[j]<=MAX;++j)
        {
            zs[i*pri[j]]=true;
            if(i%pri[j])phi[i*pri[j]]=1ll*phi[i]*phi[pri[j]]%MOD;
            else{phi[i*pri[j]]=1ll*phi[i]*pri[j]%MOD;break;}
        }
    }
    for(int i=1;i<=MAX;++i)phi[i]=(phi[i-1]+1ll*phi[i]*i%MOD*i%MOD)%MOD;
}
ll Sum(ll x){x%=MOD;return x*(x+1)%MOD*inv2%MOD;}
ll Sump(ll x){x%=MOD;return x*(x+1)%MOD*(x+x+1)%MOD*inv6%MOD;}
ll SF(ll x)
{
    if(x<=MAX)return phi[x];
    if(M[x])return M[x];
    ll ret=Sum(x);ret=ret*ret%MOD;
    for(ll i=2,j;i<=x;i=j+1)
    {
        j=x/(x/i);
        ll tt=(Sump(j)-Sump(i-1))%MOD;
        ret-=SF(x/i)*tt%MOD;
        ret%=MOD;
    }
    return M[x]=(ret+MOD)%MOD;
}
int main()
{
    MOD=read();n=read();
    MAX=min(1ll*MAX,n);
    inv2=fpow(2,MOD-2);
    inv6=fpow(6,MOD-2);
    pre();
    ll ans=0;
    for(ll i=1,j;i<=n;i=j+1)
    {
        j=n/(n/i);
        ll tt=Sum(n/i);tt=tt*tt%MOD;
        ll gg=(SF(j)-SF(i-1))%MOD;
        ans+=gg*tt%MOD;
        ans%=MOD;
    }
    printf("%lld\n",(ans+MOD)%MOD);
    return 0;
}

```

---

## 作者：zhoutb2333 (赞：137)

这样反演好像更简单？就是处理$gcd(i,j)$的思路参照[[NOI2010]能量采集](https://www.luogu.org/problemnew/show/1447)，用$φ$卷积做

$\sum ^{n}_{i=1}\sum ^{n}_{j=1}ij\gcd \left( i,j\right)$


$=\sum ^{n}_{i=1}\sum ^{n}_{j=1}ij\sum _{k|i,k|j} φ(k)$

$=\sum ^{n}_{k=1} φ(k) \sum _{k|i}\sum _{k|j}ij$

$=\sum ^{n}_{k=1}\varphi \left( k\right) \cdot k^{2}\cdot (\sum ^{n/k}_{i=1}i)^{2}$


$=\sum ^{n}_{k=1}\varphi \left( k\right) \cdot k^{2}\cdot \sum ^{n/k}_{i=1}i^{3}$

``` cpp
#include<bits/stdc++.h>
#define maxn 4600000
#define ll long long
using namespace std;

int pri[maxn],phi[maxn],pricnt=0;
ll sphi[maxn],p,n,inv;
bool notpri[maxn];
map<ll,ll> mp;
ll pw(ll a,ll b){
    ll ret=1;
    while(b){
        if(b&1)
            (ret*=a)%=p;
        (a*=a)%=p;
        b>>=1;
    }
    return ret;
}
void init(){
    inv=pw(6,p-2);
    phi[1]=1;
    for(int i=2;i<maxn;i++){
        if(!notpri[i]){
            pri[++pricnt]=i;
            phi[i]=i-1;
        }
        for(int j=1;j<=pricnt;j++){
            if(i*pri[j]>=maxn)
                break;
            notpri[i*pri[j]]=true;
            if(i%pri[j]==0){
                phi[i*pri[j]]=phi[i]*pri[j];
                break;
            }
            phi[i*pri[j]]=phi[i]*(pri[j]-1);
        }
    }
    for(int i=1;i<maxn;i++)
        sphi[i]=(sphi[i-1]+1LL*i*i%p*phi[i]%p)%p;
}
ll s2(ll x){
    x%=p;
    return x*(x+1)%p*(2*x+1)%p*inv%p;
} 
ll s3(ll x){
    x%=p;
    return (x*(x+1)/2)%p*((x*(x+1)/2)%p)%p;
}
ll calc(ll x){
    if(x<maxn)
        return sphi[x];
    if(mp[x])
        return mp[x];
    ll pos,ret=s3(x);
    for(ll i=2;i<=x;i=pos+1){
        pos=x/(x/i);
        (ret-=1LL*(s2(pos)-s2(i-1)+p)%p*calc(x/i)%p)%=p;
    }
    (ret+=p)%=p;
    return mp[x]=ret;
}
ll solve(){
    ll pos,ret=0;
    for(ll i=1;i<=n;i=pos+1){
        pos=n/(n/i);
        (ret+=1LL*(calc(pos)-calc(i-1)+p)%p*s3(n/i)%p)%=p;
    }
    (ret+=p)%=p;
    return ret;
}
int main(){
    scanf("%lld%lld",&p,&n);
    init();
    printf("%lld\n",solve());
    return 0;
}
```

---

## 作者：Soulist (赞：79)

题目要我们求一个很毒瘤的东东：

$$\sum_{i=1}^n\sum_{j=1}^n gcd(i,j)*ij$$

我们可以很套路地去化简这个式子：（$x$为枚举的$gcd$）

$$\sum_{x=1}^nx^3\sum_{i=1}^{n/x}\sum_{j = 1}^{n/x}ij{[gcd(i,j)==1]}$$

也就是：

$$\sum_{x=1}^nx^3\sum_{i=1}^{n/x}\sum_{j = 1}^{n/x}ij\sum_{d|gcd(i,j)}\mu(d)$$

一般地，我们把$\mu$放到前面去。

$$\sum_{x=1}^nx^3\sum_{d=1}^{n/x}d^2\mu(d)*\sum_{i=1}^{n/(x*d)}\sum_{j=1}^{n/(x*d)}ij $$

后面那一坨其实只和$(n/(x*d))$有关，我们可以利用一点数学知识化简：

记$g(x) = \dfrac{x^2(x+ 1)^2}{4}$x

所以原来的式子其实就是：

$$\sum_{x=1}^nx^3\sum_{d=1}^{n/x}d^2\mu(d)*g(\left\lfloor\dfrac{n}{xd}\right\rfloor)$$

考虑套路：记$T = xd$

所以原来的式子就是：

$$\sum_{T=1}^n g(\left\lfloor\dfrac{n}{xd}\right\rfloor)*(xd)^2\sum_{x|T}\mu(d)*(x)\quad(d = T/x)$$

其实也就是：

$$\sum_{T=1}^n g(\left\lfloor\dfrac{n}{T}\right\rfloor)T^2\sum_{x|T}\mu(x)*(T/x)$$

接下来我们考虑两个积性函数的卷积：

$\sum_{d|x} f(d)*g(x/d)$，（一般也写$(f*g)(x)$为$f(x)$与$g(x)$的卷积）其实，两个积性函数的卷积具有一些比较奇妙的性质。

这里需要用到的是这两个：

**这里给出了一些积性函数的卷积是什么的证明，可跳过**

$(\phi*I)(x) = Id(x)$

$(\mu*Id)(x) = \phi(x)$

其中：$\phi$为欧拉函数，$\mu$为莫比乌斯函数，$I(x) = 1$  $(x$为任意数$)$，$Id(x) = x$（后面这两个都是完全积性函数）

简单证明一下：

$(\phi*I)(x) = Id(x)$

其实就是：

$\sum_{i|x} \phi(i) * I(x/i)$， 其中$I(x/i) = 1$

也就是:

$\sum_{i|x}\phi(i)$，我们可以考虑欧拉函数的实际意义，$\phi(i)$表示为$1-i$中与$i$互质的数的个数。

那么我们不妨假设$n$的因子依次为：$1,p1,p2.......n(p_i$不一定为质数！$)$

接着我们考虑对于$gcd(n, a) = 1$， 其中，满足这个式子的$a$的个数就是$\phi(n)$

考虑$gcd(n, a) = d$的时候，那么$d|n$且$d|a$，所以其实这个式子就是： $gcd(n/d, a/d) = 1$ ，满足这个式子的$a$的个数为$:\phi(n/d)$个。

不难发现：$\sum_{i|x}\phi(i) = \sum_{i|x} \phi(x/i)$ 而这个式子的答案的意义为：与$x$的$gcd$依次为$1,p_1...p_n$的数的个数，这个数的个数为$x$

所以：$\sum_{i|x}\phi(i) = x = Id(x)$

接下来我们证明这个：$(\mu*Id)(x) = \phi(x)$

不难发现，卷积其实具有交换律。$(f*g*h)(x) = (f*h*g)(x)$

所以：$\mu*Id*I = \mu*I*Id = \phi*I$

即：$\mu*Id*I = \phi* I$，故：$\mu*Id = \phi$

**完毕$QWQ$**

回到原来的式子：

$$\sum_{T=1}^n g(\left\lfloor\dfrac{n}{T}\right\rfloor)T^2\sum_{x|T}\mu(x)*(T/x)$$

其实就是：

$$\sum_{T=1}^n g(\left\lfloor\dfrac{n}{T}\right\rfloor)T^2\sum_{x|T}\mu(x)*Id(T/x)$$

后面那一部分其实就是：$(\mu*Id)(T) = (\phi)(T)$

所以我们要求的就是：

$$\sum_{T=1}^n g(\left\lfloor\dfrac{n}{T}\right\rfloor)T^2\phi(T)$$

考虑记$f(x) = x^2\phi(x)$

然后我们不难发现这是一个积性函数。

所以我们要求的就是：

$$\sum_{T=1}^n g(\left\lfloor\dfrac{n}{T}\right\rfloor)f(T)$$

这一部分可以整除分块，而后面的部分，因为$f(x)$为积性函数，所以我们可以使用杜教筛。

假定存在$h(x)$满足$(h*f)(x)$可以较快的算出来

那么这两个的卷积就是：

$$\sum_{i|x}f(i)*h(x/i)$$

我们把$f(i)$代回去，就是：

$$\sum_{i|x} i^2\phi(i)*h(x/i)$$

这个里面最麻烦的是什么呢？是在$\phi(i)$前面的$i^2$，这个东西有什么办法被我们去掉呢？

是这个：$i*(x/i) = x$

所以：$i^2 * (x/i)^2 = x^2$

故我们可以令$h(x) = x^2$

于是我们所求即：$\sum_{i|x} i^2\phi(i)*(x/i)^2$

糟糕，是心动的感觉：$i^2*(x/i)^2 = x^2$!

换下顺序，再利用一下乘法分配律，这个式子就是：$x^2\sum_{i|x}\phi(i)$

但是后面这个，我们给它乘上一个$1$：

$\sum_{i|x}\phi(i) = \sum_{i|x}\phi(i) * 1 = \sum_{i|x}\phi(i) * I(x/i) = (\phi*I)(x) = Id(x)$

（最后一步是之前证明的：$(\phi*I = Id)$）

所以我们后面的这一坨也就是：$x$

于是：
$$\sum_{i|x}f(i)*h(x/i)$$

就是：（其中$h(x) = x^2$）
$$x^3$$

然后我们把杜教筛的式子套上去，

记$S(n) = \sum_{i=1}^nf(i)$

所以：

$$h(1)S(n) = \sum_{i=1}^nh(i)S(\left\lfloor\dfrac{n}{i}\right\rfloor) - \sum_{i=2}^nh(i)S(\left\lfloor\dfrac{n}{i}\right\rfloor)$$

因为$h(1) = 1^2 = 1$，所以：

$$S(n) = \sum_{i=1}^nh(i)S(\left\lfloor\dfrac{n}{i}\right\rfloor) - \sum_{i=2}^nh(i)S(\left\lfloor\dfrac{n}{i}\right\rfloor)$$

而前面这一坨：

$\sum_{i=1}^nh(i)S(\left\lfloor\dfrac{n}{i}\right\rfloor)$其实是这样来的：

$\sum_{i=1}^n(h*f)(i) $

$= \sum_{i=1}^n\sum_{d|i}h(d)f(i/d)$

$=\sum_{d=1}^nh(d)*\sum_{i=1}^{n/d}f(i) = \sum_{d=1}^nh(d)*S(\left\lfloor\dfrac{n}{d}\right\rfloor)$

然而，观察第一个式子，其就是：$(h*f)$这个函数的前缀和

然而当$h(x) = x^2$时，$(h*f) = x^3$

那么$\sum_{i=1}^n(h*f)(i) = \sum_{i=1}^ni^3$ 

这个东西怎么算？

$1^3 + 2^3+3^3+4^3+....... + n^3$

相信大家其实上过小学奥数$QAQ,$其$=\dfrac{n^2(n+1)^2}{4}$

所以原式：
$$S(n) = \dfrac{n^2(n+1)^2}{4} - \sum_{i=2}^nh(i)S(\left\lfloor\dfrac{n}{i}\right\rfloor)$$

然后后面这个仍然可以整除分块求，而且再利用递归去做。

但是，整除分块的过程注意到：

假设$l-r$的$\left\lfloor\dfrac{n}{l}\right\rfloor$都相同，我们可以利用乘法分配律：

即：$S(\left\lfloor\dfrac{n}{l}\right\rfloor) * \sum_{i=l}^rh(i)$

因为$h(i) = i^2$

所以我们要求$l-r$这一段区间的平方和。

可以利用：$1^2 + 2^2 + 3^2+......+n^2$

$ = \dfrac{n*(n+1)*(2n+1)}{6}$

可以记$sum(n) =  \dfrac{n*(n+1)*(2n+1)}{6}$

（小学数学）

再做一个减法，所以$\sum_{i=l}^ri^2 = sum(r) - sum(l - 1)$

所以最后我们得到了一个比较优秀的式子：

$$S(n) = \dfrac{n^2(n+1)^2}{4} - \sum_{i=2}^nS(\left\lfloor\dfrac{n}{i}\right\rfloor)h(i)$$

利用整除分块，对$h(l)$到$h(r)$的前缀和利用前面所讲$O(1)$求出，然后递归地去得到$S(n/i)$的值，当然，我们还需要提前求出较多的$S(1)-S(m)$的值，至于这个值需要利用欧拉筛求欧拉函数来处理。

毕竟：$S(x) = \sum_{i=1}^xi^2\phi(i)$

所以不难得到递推：$S(x) = S(x - 1) + x^2\phi(x)$

根据实测，大概$m$取$500W$左右的时候速度比较快，当然$300W-1000W$的时候也都是能过的！

写这篇题解算是帮自己同时复习杜教筛和莫比乌斯反演吧$QAQ$（记得算$h(x)$的前缀和利用到的式子需要除以$6$，那么我们就需要乘上$6$的$inv$,以及这道题恶心的一点就是到处都需要取模...........然后要开$long long$）

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int unsigned long long

int read() {
	char cc = getchar(); int cn = 0, flus = 1;
	while(cc < '0' || cc > '9') {  if( cc == '-' ) flus = -flus;  cc = getchar();  }
	while(cc >= '0' && cc <= '9')  cn = cn * 10 + cc - '0', cc = getchar();
	return cn * flus;
}

const int N = 5e6 + 5;
#define inf 9999999
#define g(x) (((( (x % mod) * ((x + 1) % mod) / 2 ) % mod) * ( (x % mod) * ((x + 1) % mod) / 2 % mod)) % mod)
#define g2(x) (( (x % mod) * ((x + 1) % mod) % mod * ((2 * x + 1) % mod) % mod * inv6 % mod) % mod)

int n, phi[N], pr[N], f[N], top, mod, inv6, inv2;
bool isp[N];

map<int, int> map1;
void init() {
	phi[1] = f[1] = 1;
	for ( int i = 2; i <= n; ++ i ) {
		if( !isp[i] )  pr[++top] = i, phi[i] = i - 1;
		for ( int j = 1; j <= top; ++ j ) {
			if( i * pr[j] > n ) break;
			isp[i * pr[j]] = 1;
			if( i % pr[j] == 0 ) {
				phi[i * pr[j]] = phi[i] * pr[j];
				break;
			}
			phi[i * pr[j]] = phi[i] * phi[pr[j]];
		}
		f[i] = f[i - 1] + ((1ll * phi[i] * i) % mod * i) % mod; f[i] %= mod;
	}
} 

int fpow( int x, int k ) {
	int base = x, ans = 1;
	while( k ) {
		if( k & 1 ) ans *= base, ans %= mod;
		base *= base, base %= mod;
		k >>= 1;
	}
	return ans;
}

int phi_sum( int x ) {
	if( x <= n ) return f[x];
	if( map1[x] ) return map1[x];
	int sumId = g(x % mod) % mod, ans = 0;
	int l, r;
	for ( l = 2; l <= x; l = r + 1 ) {
		r = ( x / ( x / l ) );
		ans += ((1ll * (( g2(r) - g2((l - 1)) + mod ) % mod ) * phi_sum( x / l )) % mod);
		ans %= mod;
	}
	return map1[x] = ( (sumId - ans + mod) % mod );
}

int solve1( int x ) {
	int l, r, ans = 0;
	for ( l = 1; l <= x; l = r + 1 ) {
		r = ( x / ( x / l ) );
		int ret = g( x / l ) % mod;
		ret = ret * ((phi_sum(r) - phi_sum(l - 1) + mod) % mod), ret %= mod; 
		ans += ret, ans %= mod;
	}
	return (ans + mod) % mod;
}

signed main()
{
	mod = read(); 
//	inv2 = fpow( 2, mod - 2 );
	inv6 = fpow( 6, mod - 2 ); 
	int x = read();
	n = 5000000;  init();
	printf("%lld", solve1(x));
	return 0;
}

```

---

## 作者：Froggy (赞：46)

$\mathrm{update\ 2020/8/6:}$ 修改了之前不规范的数学符号和错误的复杂度。

---

首先要知道：（欧拉反演）

$$\varphi*1=\mathrm{id}$$

即 

$$\sum\limits_{d\mid n}\varphi(d)=n$$

这道题就是让求：

$$\sum\limits_{i=1}^n{\sum\limits_{j=1}^{n}{ij\cdot \mathrm{id}\left(\gcd(i,j)\right)}}$$

带入最开头说的那个式子得到：

(由于 $d$ 能被 $\gcd(i,j)$ 整除，所以 $d$ 既能被 $i$ 整除也能被 $j$ 整除，$d$ 的取值范围就珂以写成：$d\mid i,d\mid j$ ）

$$\sum\limits_{i=1}^n{\sum\limits_{j=1}^{n}{ij\sum\limits_{d\mid i,d\mid j}\varphi(d)}}$$

套路的，我们把 $d$ 搞出来枚举：

$$\sum\limits_{d=1}^{n}{\varphi(d)}\sum\limits_{d\mid i}\sum\limits_{d\mid j}ij$$

由于 $i,j$ 都是 $d$ 的倍数，所以我们珂以把它们都除以 $d$,别忘了把 $d$ 再乘回去！

$$\sum\limits_{d=1}^{n}{\varphi(d)\cdot d^2}\sum\limits_{i=1 }^{\left\lfloor\frac{n}{d}\right\rfloor}\sum\limits_{j=1}^{\left\lfloor\frac{n}{d}\right\rfloor}ij$$

发现 $i,j$ 的取值范围是一样的，所以直接把它们合并掉！

$$\sum\limits_{d=1}^{n}{\varphi(d)\cdot d^2}\left(\sum\limits_{i=1 }^{\left\lfloor\frac{n}{d}\right\rfloor}i\right)^2$$

后面的那个求和就珂以数论分块啦！

求的话珂以 $\mathcal{O}(1)$ 搞掉 (相信只要上过小学的人都会）：

$$\left(\sum\limits_{i=1}^{n}i\right)^2=\frac{n^2(n+1)^2}{4}$$

前面的 $\sum\limits_{d=1}^{n}{\varphi(d)\cdot d^2}$ 怎么办？

[**杜教筛**！！](https://www.luogu.com.cn/problem/P4213)

令 $f=\varphi \cdot \mathrm{id}^2$,需要再找一个合适的 $g$

为了让 $(f*g)(n)$ 求前缀和方便，我们最好不让式子里有除 $n$ 以外的变量。

由于 $d\cdot \frac{n}{d}=n$ （废话。。）

我们就让 $g=\mathrm{id}^2$ 来消掉 $d$

那么:

$$\begin{aligned}{(f*g)(n)}&=\sum\limits_{d\mid n}\left(\varphi(d)*d^2\right)\left(\frac{n}{d}\right)^2 \\
&=n^2\sum\limits_{d\mid n}\varphi(d) \\
&=n^3
\end{aligned}$$

(最后一步依然用到了：$\varphi*1=\mathrm{id}$ )

令 $S(n)=\sum\limits_{d=1}^{n}{\varphi(d)\cdot d^2}$

直接套杜教筛的公式即可：

$$S(n)=\frac{\sum\limits_{i=1}^{n}(f*g)(n)-\sum\limits_{i=2}^{n}{g(i)S}\left(\left\lfloor\frac{n}{i}\right\rfloor\right)}{g(1)}$$

求 $(f*g)(n)$ 和 $g(n)$ 的前缀和还是小学生难度：

$$\sum\limits_{i=1}^{n}(f*g)(i)=\sum\limits_{i=1}^{n}i^3=\frac{n^2(n+1)^2}{4}$$

$$\sum_{i=1}^{n}g(i)=\sum\limits_{i=1}^{n}i^2=\frac{n(n+1)(2n+1)}{6}$$

先筛出来大约 $n^{\frac{2}{3}}$ 个 $S(i)$，这样 $S(n)$ 就可以在 $\mathcal{O}(n^{\frac{2}{3}})$ 的时间复杂度内求出来。

虽然外面再套一个数论分块，但复杂度还是 $\mathcal{O}(n^{\frac{2}{3}})$（不过如果套两层数论分块就不一定了）。

---

***code:***


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<map>
using namespace std;
#define N 5000050
typedef long long ll;
const int MAX=5000000;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<3)+(x<<1)+c-'0';
        c=getchar();
    }
    return x*f;
}
#define ck(x) (x>=mod?x-mod:x)
map<ll,ll> mp;
ll mod,n,Sphi[N],inv6;
int phi[N],primes[N>>2],pn;
bool ntp[N];
ll qpow(ll a,ll b){
	ll ans=1;
	while(b){
		if(b&1)ans=ans*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return ans;
}
void init(int n){//预处理S(i)
	ntp[1]=true,phi[1]=1;
	for(register int i=2;i<=n;++i){
		if(!ntp[i])primes[++pn]=i,phi[i]=i-1;
		for(int j=1;j<=pn&&primes[j]*i<=n;++j){
			ntp[primes[j]*i]=true;
			if(i%primes[j]==0){
				phi[i*primes[j]]=phi[i]*primes[j];
				break; 
			}
			phi[i*primes[j]]=phi[i]*(primes[j]-1);
		}
	}
	for(register int i=1;i<=n;i++){
		Sphi[i]=Sphi[i-1]+1LL*i*i%mod*phi[i]%mod;
		Sphi[i]=ck(Sphi[i]);
	}
}
inline ll S2(ll n){//平方和
	n%=mod;
	return n*(n+1)%mod*(2*n+1)%mod*inv6%mod;
}
inline ll S3(ll n){//立方和
	n%=mod;
	return (n*(n+1)/2%mod)*(n*(n+1)/2%mod)%mod;
}
inline ll Get(ll n){//杜教筛求S(n)
	if(n<=MAX)return Sphi[n]%mod;
	if(mp.count(n))return mp[n];
	ll r=0,ans=S3(n);
	for(ll l=2;l<=n;l=r+1){
		r=(n/(n/l));
		ans-=(S2(r)-S2(l-1)+mod)%mod*Get(n/l)%mod;
		ans=ck(ans+mod);
	} 
	return mp[n]=ans;
}
ll Solve(ll n){
	ll r=0,ans=0;
	for(ll l=1;l<=n;l=r+1){//先在外层数论分块一下
		r=(n/(n/l));
		ans+=S3(n/l)*(Get(r)-Get(l-1)+mod)%mod;
		ans=ck(ans);
	}
	return ans;
}
int main(){
	mod=read(),n=read();
	init(MAX),inv6=qpow(6,mod-2);
	printf("%lld\n",Solve(n));
	return 呱呱！
}

```

[*Froggy's blog*](https://www.luogu.org/blog/1445353309froggy/)

#### 呱!!




---

## 作者：fjzzq2002 (赞：20)

#### 简单的数学题


求$\sum_{i=1}^n\sum_{j=1}^nijgcd(i,j)$。


事实上我们可以考虑算$\sum_{i=1}^n\sum_{j=1}^n [gcd(i,j)=1]ij$，可以发现答案等于$\sum_{i=1}^n i^2\varphi(i)$。


那么设$F(n)=\sum_{i=1}^n i^2\varphi(i)$，则答案等于$\sum_{g=1}^n g^3 F(\frac{n}{g})$，对g根号分段后杜教筛即可。

证明只需注意到$\sum_{i=1}^n [gcd(i,n)=1]i=(n\varphi(n)+[n=1])/2$（由于$i$和$n-i$和$n$同互质或同不互质），那么$\sum_{i=1}^n\sum_{j=1}^n [gcd(i,j)=1]ij=1+2\sum_{i=2}^ni\sum_{j=1}^{i}[gcd(i,j)=1]j=1+2\sum_{i=2}^ni^2\varphi(i)/2=\sum_{i=1}^ni^2\varphi(i)$。


---

## 作者：scPointer (赞：20)

我来给一个不需要证(gong)明(lue)直接强推的做法

注意以下式子中的除法皆为**向下取整**

$\sum _{i=1}^n \sum _{j=1}^n ij \gcd (i,j) $

(枚举 $\gcd(i,j)=d$)

= $\sum _d d^3 \sum _{i=1}^{\frac{n}{d}} \sum _{j=1}^{\frac{n}{d}} ij [\gcd (i,j)=1] $

(再枚举 $\gcd(i,j)=p$ 做莫比乌斯反演)

= $\sum _d d^3 \sum _{p=1}^{\frac{n}{d}} \mu(p) p^2 \sum _{i=1}^{\frac{n}{dp}} \sum _{j=1}^{\frac{n}{dp}} ij $

(令 $F(n)=\sum _{i=1}^n \sum _{j=1}^n ij=\sum _{i=1}^n i^3 $)

= $\sum _d d^3 \sum _{p=1}^{\frac{n}{d}} \mu(p) p^2 F(\frac{n}{dp}) $

(令 $a=dp$，可以把枚举 $d$ 和 $p$ 转换成枚举 $a$)

= $\sum _{a=1}^n \sum _{d|a} d^3 \mu(\frac{a}{d}) \frac{a^2}{d^2} F(\frac{n}{a}) $

=$\sum _{a=1}^n a^2 F(\frac{n}{a})\sum _{d|a} d\mu(\frac{a}{d}) $

(注意到 $\mu*id=\mu*I*\phi=e*\phi=\phi$ ，这里 $*$ 是狄利克雷卷积)

=$\sum _{a=1}^n a^2 F(\frac{n}{a})\phi(a) $

这就是出题人题解开头提到的"**可以发现...则答案等于**"的式子，然后直接杜教筛。


---

## 作者：zhangchengkai (赞：7)

唔，学了两天**Min_25**筛终于会了。。。
相信 ~~大家都能推到~~ 别的题解已经写的很清楚了
$$ans=\sum_{i=1}^n i^2\varphi(i)*(\sum_{j=1}^{\lfloor \frac{n}{i}\rfloor} i)^2$$
对于后半部分，我们可以数论分块做到$O(\sqrt{n})$，然后直接**Min_25**筛就没了。

------

好吧，接下来讲讲啥是**Min_25**筛。

先推荐两篇不错的博客：

[学习看这里](https://www.cnblogs.com/DreamlessDreams/p/9997874.html)

[例题看这里](https://cmxrynp.github.io/2018/12/03/Min-25%E7%AD%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/)

## 简介

**Min_25**筛能快速求积性函数前缀和，时间复杂度$O(\frac{n^{\frac{3}{4}}}{logn})$，空间复杂度$O(\sqrt n)$。

**Min_25**筛要求$f(p^k)$能快速求出，其中$p$为质数，且要求$f(p)$能拆解成若干**完全积性函数**。

### 化简式子并变形

对于本题，我们令
$$f(i)=i^2*\varphi(i)$$
则在$i$为质数时，有：
$$f(p)=p^2(p-1)=p^3-p^2$$
于是我们令
$$g(p)=p^3,h(p)=p^2$$
那么
$$f(p)=g(p)-h(p)$$

## 预处理

首先考虑质数贡献的前缀和，根据以上定义，我们可以先计算出各**完全积性函数**的质数前缀和，再相加减就是原函数只算质数部分的前缀和了。那么我们先单独考虑如何求一个**完全积性函数**$g(p)$的质数前缀和。

我们令
$$sg(n)=\sum_{i=1}^n g(P_i)$$
其中$P_i$表示第$i$个质数。
$$G(n,m)=\sum_{i=1}^n [minP_i>P_m~\text{或}~i~is~prime]g(i)$$
其中$minP_i$表示$i$的最小质因子，我们要求的就是$G(n,\infty)$。考虑递推来求：
$$G(n,m)=\begin{cases}G(n,m-1), & p_m^2>n\\G(n,m-1)-g(P_i)\times \left(G\left(\left\lfloor \frac{n}{P_i} \right\rfloor,i-1\right)-sg(i-1)\right), & P_m^2\le n\end{cases}$$
假设$P_i$是别的数一个质因子，它能产生的合数贡献是$g(P_i)\times G(\left\lfloor\frac{n}{P_i}\right\rfloor,i-1)$。但是由于$P_i$不一定是最小的质因子，还要加回多减的小质数即$sg(i-1)$。

由于$\lfloor \frac{n}{ab}\rfloor=\left \lfloor \frac {\lfloor \frac {n}{a} \rfloor}{b} \right \rfloor $，故若要求$G(n,*)$需要从$G(\lfloor \frac{n}{d} \rfloor,*)$。~~众所周知~~$\lfloor \frac{n}{d} \rfloor$有$O(\sqrt{n})$种取值，而对于$G(*,m)$只需要从$G(*,m-1)$推来，故可将第二维滚掉。于是只需开一个$G[\sqrt{n}]$的数组即可。复杂度$O(\frac{n^\frac{3}{4}}{\log n})$。

按以上方法，我们就能在低于线性复杂度的时间内处理出各**完全积性函数**的前缀和。将它们合并后就可以得到原积性函数质数部分的前缀和，我们设为$g(x)$。注意，这里的$g(x)$的定义和前文**不一样**，$g(x)=\sum_{i=1}^x [i~is~prime]f(i)$。

## 计算答案

我们令
$$S(n,m)=\sum_{i=2}^n [minP_i \ge P_m]f(i)$$
那么我们要求的答案即为$S(n,1)$。考虑递归求解：
$$S(n,m)=\begin{cases}0, & n<P_m\\g(n)-g(P_{m-1})+\sum_{k=m}^{P_k^2\le n}\sum_{e=1}^{P_k^{e+1}\le n}f(P_k^e)*S(\left \lfloor\frac{n}{P_k^e}\right \rfloor,k+1)+f(P_k^{e+1}), & n\ge P_m\end{cases}$$
后面的$\Sigma$部分即枚举当前选择的最小质因数以及数量次数，同时计算形如$P^k$的合数贡献。这部分的时间复杂度也是$O(\frac{n^\frac{3}{4}}{\log n})$。

但是对于本题，我们要计算
$$ans=\sum_{i=1}^n f(i)*(\sum_{j=1}^{\lfloor \frac{n}{i}\rfloor} i)^2$$
是要多次询问$f(i)$的前缀和的。对于上述方法并不适用，实测只有$60$分，那该咋办嘞？

没错，我们想到在递归$S(*,1)$时会多次求到同一个$S(n,m)$。我们加一发记忆化。通过$vector$的操作就能~~(也许我自带大常数)~~得到$80$分。那我们能否像求$G(n,m)$那样递推呢？答案是肯定的。

我们考虑重新定义：
$$S(n,m)=\sum_{i=2}^n [minP_i \ge P_m~\text{或}~i~is~prime]f(i)$$
我们单独考虑$P_m$的贡献，每次加入$minP_i=P_m$的数：
$$S(n,m)=\begin{cases}S(n,m+1), & n\le P_m^2\\S(n,m+1)+\sum_{i=1}^{P_m^{i+1}\le n} (f(P_m^i)*(S(\lfloor\frac{n}{P_m^i}\rfloor,m+1)-g(P_m))+f(P_m^{i+1})), & n\ge P_m^2\end{cases}$$

$S(n,\infty)=G(n,\infty)=g(n)$

借鉴求$G$的思路，我们仍先枚举$m$这一维，于是第二维就又可以滚掉，复杂度依旧是$O(\frac{n^\frac{3}{4}}{\log n})$。

处理出$S(n,1)$后，我们就可以$O(1)$回答$f(i)$的前缀和，便通过了此题。

------

代码：

$Tips:$这里提供了一份**Min_25**筛板子。

```cpp
// 将积性函数f拆解成g+h的形式g，h是完全积性函数并且可以快速求前缀和。求f前缀和。
#include<cstdio>
#include<cmath>
#include<cstdlib>
#include<cstring>
#include<algorithm>
using namespace std;
typedef long long ll;
const int N=2E5+10;
const int ret=1+2;//f(1)的贡献和一些奇奇给给的部分
const int flag=0;// 1：只求S(n,1) or 0：多次求前缀和
ll n,q[N];
int sz,cnt,inv6,mod;
int id1[N],id2[N];
int vis[N],pr[N],tot;
int sg[N],sh[N],g[N],h[N],s[N];
inline void mo(int&x){(x>=mod)&&(x-=mod);}
inline void pre(void){// 是否有边界要特判
	return;
    if(n==1){puts("1");exit(0);}
}
inline int query_g(const int x){//g的表达式
    return 1ll*x*x*x%mod;
}
inline int query_h(const int x){//h的表达式
	return 1ll*x*x%mod;
}
inline int sumof_g(const int x){//g的前缀和
	return (1ll*x*(x+1)/2%mod)*(1ll*x*(x+1)/2%mod)%mod;
}
inline int sumof_h(const int x){//h的前缀和
	return 1ll*(x+x+1)*(x+1)%mod*x%mod*inv6%mod;
}
inline void mix_s(register int&x,const int y){//合并g，h的表达式(质数部分Tips:这里为了方便处理出sg(x)=g(P_x).
    mo(x+=mod-y);
}
inline void mix_tot(register int&x,const int y){//合并g，h的表达式(全部
	mo(x+=mod-y);
}
inline int query_f(const int p,const int k){//f(p^k)的总表达式 O(1)
	return p^k;
}
inline int query_f0(const int p){//f(p)的表达式 O(1)
	return 1ll*(p-1)*p*p%mod;
}
inline int query_fq(const int p){//f(p^k)递推式的公比 O(1)
	return 1ll*p*p*p%mod;
}
inline int ksm(const int x,const int y){return y==1?x:1ll*ksm(1ll*x*x%mod,y>>1)*((y&1)?x:1)%mod;}
inline void init(void){
	sz=sqrt(n);tot=cnt=0;
	inv6=ksm(6,mod-2);
	for(int i=2;i<=sz;i++){
		if(!vis[i]) pr[++tot]=i,mo(sg[tot]=sg[tot-1]+query_g(i)),mo(sh[tot]=sh[tot-1]+query_h(i));
		for(int j=1;j<=tot&&i*pr[j]<=sz;j++){
			vis[i*pr[j]]=1;
			if(i%pr[j]==0) break;
		}
	}
	for(ll i=1,v;i<=n;i=n/(n/i)+1){
		q[++cnt]=v=n/i;
		if(v<=sz) id1[v]=cnt;
		else id2[n/v]=cnt;
		v%=mod;
		g[cnt]=sumof_g(v)-1;
		h[cnt]=sumof_h(v)-1;
	}
}
inline int id(const ll x){return x<=sz?id1[x]:id2[n/x];}
inline void mix(void){
	for(int i=1;i<=tot;i++) mix_s(sg[i],sh[i]);
	for(int i=1;i<=cnt;i++) mix_tot(g[i],h[i]);
}
inline int S(const ll n,const int m){
	if(n<=1||pr[m]>n) return 0;
	int res=g[id(n)]-sg[m-1]+mod;mo(res);
	for(int k=m;1ll*pr[k]*pr[k]<=n&&k<=tot;k++){
//		for(ll v=pr[k],e=1;v*pr[k]<=n;v*=pr[k],e++){
//			mo(res+=(1ll*query_f(pr[k],e)*S(n/v,k+1)+query_f(pr[k],e+1))%mod);
//		}
		for(ll v=pr[k],p=query_f0(pr[k]),e=query_fq(pr[k]);v*pr[k]<=n;v*=pr[k],p=p*e%mod){
			mo(res+=1ll*(S(n/v,k+1)+e)*p%mod);
		}
	}
	return res;
}
inline void sol(void){
	for(int i=1;i<=cnt;i++) s[i]=g[i];
	for(int i=1;i<=tot;i++) mo(sg[i]=mod-sg[i]);
	for(int i=tot;i;i--){
		const ll vv=1ll*pr[i]*pr[i];
		for(int j=1;j<=cnt&&q[j]>=vv;j++){
			for(ll v=pr[i],p=query_f0(pr[i]),e=query_fq(pr[i]);v*pr[i]<=q[j];v*=pr[i],p=p*e%mod){
				mo(s[j]+=1ll*(0ll+s[id(q[j]/v)]+sg[i]+e)*p%mod);
			}
		}
	}
	int res=sumof_g(n%mod);
	for(ll i=1;i<=n;i=n/(n/i)+1){
		mo(res+=1ll*sumof_g((n/i)%mod)*(s[id(n/(n/i))]-s[id(i-1)]+mod)%mod);
	}
	printf("%d\n",res);
}
int main(){
	scanf("%d%lld",&mod,&n);
	pre();init();
	for(int i=1;i<=tot;i++){
		const ll v=1ll*pr[i]*pr[i];
		for(int j=1;j<=cnt&&q[j]>=v;j++){
			const int k=id(q[j]/pr[i]);
			mo(g[j]+=mod-1ll*query_g(pr[i])*(g[k]-sg[i-1]+mod)%mod);
			mo(h[j]+=mod-1ll*query_h(pr[i])*(h[k]-sh[i-1]+mod)%mod);
		}
	}
	mix();
	if(flag) printf("%d\n",S(n,1)+ret);
	else sol();
	return 0;
}
```

自带大常数望见谅。~~跑不过杜教筛，我好菜啊~~

---

## 作者：1saunoya (赞：5)

$$\sum_{i=1}^{n}\sum_{j=1}^{n} ij\gcd(i,j)$$
$$=\sum_{d=1}^{n} d \sum_{i=1}^{n}\sum_{j=1}^{n} ij[\gcd(i,j)==d]$$
$$=\sum_{d=1}^{n} d^3 \sum_{i=1}^{\lfloor\frac{n}{d}\rfloor} \sum_{j=1}^{\lfloor\frac{n}{d}\rfloor} ij[\gcd(i,j)==1]$$
$$=\sum_{d=1}^{n} d^3 \sum_{i=1}^{\lfloor\frac{n}{d}\rfloor} \sum_{j=1}^{\lfloor\frac{n}{d}\rfloor} ij[\gcd(i,j)==1]$$
因为 $\sum_{t|n} \mu(t) = [n == 1]$
所以
$$=\sum_{d=1}^{n} d^3 \sum_{i=1}^{\lfloor\frac{n}{d}\rfloor} \sum_{j=1}^{\lfloor\frac{n}{d}\rfloor} ij \sum_{t|\gcd(i,j)} \mu(t)$$
$$=\sum_{d=1}^{n} d^3 \sum_{t=1}^{\lfloor\frac{n}{d}\rfloor} \mu(t) t^2 \sum_{i=1}^{\lfloor\frac{n}{td}\rfloor} \sum_{j=1}^{\lfloor\frac{n}{td}\rfloor} ij$$

设 $sum_x = \sum_{i=1}^{x}$

则原式等同于 

$$=\sum_{d=1}^{n} d^3 \sum_{t=1}^{\lfloor\frac{n}{d}\rfloor} \mu(t) t^2 (sum_{\lfloor \frac{n}{td} \rfloor})^2$$

设 $T=td$

$$=\sum_{T=1}^{n} T^2 (sum_{\lfloor \frac{n}{T} \rfloor})^2 \sum_{d|t} \mu (\frac{T}{d}) d $$

因为
$$\sum_{d|n} \frac{\mu(d)}{d} = \frac{\varphi(n)}{n}$$

根据狄利克雷卷积
$$id(x) = x , id * \mu = \varphi$$

那么这个柿子变成了

$$\sum_{T=1}^{n}T^2 \varphi(T) (sum_{\lfloor \frac{n}{T} \rfloor})^2$$

然后我们本身知道 形如 $\lfloor \frac{n}{T} \rfloor$ 之类的玩意可以数论分块

然后 $f_x = x^2 \varphi(x)$ 的前缀和

设 $s_x$ 是 $f_x$ 的前缀和，然后考虑 $g$ 函数

然后我们知道

$$\sum_{d|n} \varphi(d) = n$$

考虑 $g$ 函数为 $g_i = i^2$

$$(g*f)(i) = \sum_{d|i} d^2 \varphi (d) \frac{i^2}{d^2} = \sum_{d|i}\varphi (d) i^2 = i^3$$

$$s_n = \sum_{i=1}^{n} i^3 - \sum_{i=2}^{n} i^2 s_{\frac{n}{i}}$$

因为
$$\sum_{i=1}^{n}i^3 = (\sum_{i=1}^{n}i)^2$$
$$\sum_{i=1}^{n}i^2 = \frac{n(n+1)(2n+1)}{6}$$

Q.E.D.

杜教筛一手，这题没了。

```cpp
// powered by c++11
// by Isaunoya
#include<bits/stdc++.h>
#define rep(i , x , y) for(register int i = (x) ; i <= (y) ; ++ i)
#define Rep(i , x , y) for(register int i = (x) ; i >= (y) ; -- i)
using namespace std ;
using db = double ;
using ll = long long ;
using uint = unsigned int ;
#define int long long
using pii = pair < int , int > ;
#define ve vector
#define Tp template
#define all(v) v.begin() , v.end()
#define sz(v) ((int)v.size())
#define pb emplace_back
#define fir first
#define sec second
// the cmin && cmax
Tp < class T > void cmax(T & x , const T & y) { if(x < y) x = y ; }
Tp < class T > void cmin(T & x , const T & y) { if(x > y) x = y ; }
// sort , unique , reverse
Tp < class T > void sort(ve < T > & v) { sort(all(v)) ; }
Tp < class T > void unique(ve < T > & v) { sort(all(v)) ; v.erase(unique(all(v)) , v.end()) ; }
Tp < class T > void reverse(ve < T > & v) { reverse(all(v)) ; }
const int SZ = 0x191981 ;
struct FILEIN {
	~ FILEIN () {} char qwq[SZ] , * S = qwq , * T = qwq , ch ;
	char GETC() { return (S == T) && (T = (S = qwq) + fread(qwq , 1 , SZ , stdin) , S == T) ? EOF : * S ++ ; }
	FILEIN & operator >> (char & c) { while(isspace(c = GETC())) ; return * this ; }
	FILEIN & operator >> (string & s) {
		while(isspace(ch = GETC())) ; s = "" + ch ;
		while(! isspace(ch = GETC())) s += ch ; return * this ;
	}
	Tp < class T > void read(T & x) {
		bool sign = 1 ; while((ch = GETC()) < 0x30) if(ch == 0x2d) sign = 0 ;
		x = (ch ^ 0x30) ; while((ch = GETC()) > 0x2f) x = x * 0xa + (ch ^ 0x30) ;
		x = sign ? x : -x ;
	}
	FILEIN & operator >> (int & x) { return read(x) , * this ; }
	FILEIN & operator >> (signed & x) { return read(x) , * this ; }
	FILEIN & operator >> (unsigned & x) { return read(x) , * this ; }
} in ;
struct FILEOUT { const static int LIMIT = 0x114514 ;
	char quq[SZ] , ST[0x114] ; signed sz , O ;
	~ FILEOUT () { sz = O = 0 ; }
	void flush() { fwrite(quq , 1 , O , stdout) ; fflush(stdout) ; O = 0 ; }
	FILEOUT & operator << (char c) { return quq[O ++] = c , * this ; }
	FILEOUT & operator << (string str) {
		if(O > LIMIT) flush() ; for(char c : str) quq[O ++] = c ; return * this ;
	}
	Tp < class T > void write(T x) {
		if(O > LIMIT) flush() ; if(x < 0) { quq[O ++] = 0x2d ; x = -x ; }
		do { ST[++ sz] = x % 0xa ^ 0x30 ; x /= 0xa ; } while(x) ;
		while(sz) quq[O ++] = ST[sz --] ; return ;
	}
	FILEOUT & operator << (int x) { return write(x) , * this ; }
	FILEOUT & operator << (signed x) { return write(x) , * this ; }
	FILEOUT & operator << (unsigned x) { return write(x) , * this ; }
} out ;

int n , p ;
const int maxn = 5e6 + 10 ;
int phi[maxn + 5] ;
int iv2 , iv6 ;
int qpow(int x , int y) {
	int res = 1 ;
	for( ; y ; y >>= 1 , x = x * x % p)
		if(y & 1)
			res = res * x % p ;
	return res ;
}
int sum(int x) {
	x = x - (x / p) * p ;
	return (x + 1) * x % p * iv2 % p ;
}
int sum2(int x) {
	x = x - (x / p) * p ;
	return (x + 1) * x % p * (x + x + 1) % p * iv6 % p ;
}

unordered_map < int , int > _phi ;
int s(int x) {
	if(x <= maxn) return phi[x] ;
	if(_phi[x]) return _phi[x] ;
	int ans = sum(x) ;
	ans = ans * ans % p ;
	for(int l = 2 , r ; l <= x ; l = r + 1) {
		r = x / (x / l) ;
		ans = (ans - (sum2(r) - sum2(l - 1) + p) % p * s(x / l) % p + p) % p ;
	}
	return _phi[x] = ans ;
}
signed main() {
#ifdef _WIN64
	freopen("testdata.in" , "r" , stdin) ;
#else
	ios_base :: sync_with_stdio(false) ;
	cin.tie(nullptr) , cout.tie(nullptr) ;
#endif
// code begin.
	in >> p >> n ;
	iv2 = qpow(2 , p - 2) ;
	iv6 = qpow(6 , p - 2) ;
	phi[1] = 1 ;
	for(int i = 2 ; i <= maxn; i ++) {
		if(phi[i]) 
			continue ;
		for(int j = i ; j <= maxn ; j += i) {
			if(! phi[j]) 
				phi[j] = j ;
			phi[j] = phi[j] / i * (i - 1) ;
		}
	}
	for(int i = 1 ; i <= maxn ; i ++) 
		phi[i] = (phi[i - 1] + 1ll * i * i % p * phi[i] % p) % p ;
	int ans = 0 ;
	for(int l = 1 , r ; l <= n ; l = r + 1) {
		r = n / (n / l) ;
		int k = sum(n / l) ;
		k = k * k % p ;
		ans = (ans + (s(r) - s(l - 1) + p) % p * k % p) % p ;
	}
	out << ans << '\n' ;
	return out.flush() , 0 ;
// code end.
}
```

---

## 作者：chihik (赞：3)

$$
\sum_{i=1}^n\sum_{j=1}^nijgcd(i,j)
$$

$$
\sum_{k=1}^n\sum_{i=1}^n\sum_{j=1}^nij[gcd(i,j)=k]
$$

$$
\sum_{k=1}^nk^3\sum_{i=1}^{\lfloor \frac{n}{k} \rfloor}\sum_{j=1}^{}ij[gcd(i,j)=1]
$$

$$
\sum_{k=1}^nk^3\sum_{d=1}^{\lfloor \frac{n}{k} \rfloor}\mu(d)~d^2\sum_{i=1}^{\lfloor \frac{n}{kd} \rfloor}\sum_{j=1}^{\lfloor \frac{n}{kd} \rfloor}ij
$$

令$sum^2(n)=\sum_{i=1}^ni^2 , sum^3(n)=\sum_{i=1}^ni^3$

利用小学奥数知识有:

$$
sum^2(n)=\frac{n(n+1)(2n+1)}{6} ~~~ , ~~~ sum^3(n)=\frac{n^2(n+1)^2}{4}
$$

上式为：

$$
\sum_{k=1}^nk^3\sum_{d=1}^{\lfloor \frac{n}{k} \rfloor}\mu(d)~d^2sum^3(\frac{n}{kd})
$$

记 $T=kd$ ， 则原式可继续化简为

$$
\sum_{T=1}^n \sum_{k|T}k^3 \mu(\frac{T}{k})(\frac{T}{k})^2sum^3(\frac{n}{T})
$$

$$
\sum_{T=1}^n sum^3(\frac{n}{T})~T^2 \sum_{k|T}k \mu(\frac{T}{k})
$$

后面是一个卷积形式: $id*\mu=\varphi$

$$
\sum_{T=1}^n sum^3(\frac{n}{T})~T^2 \varphi(T)
$$

现在只需求得 $\varphi \times id \times id$ 的前缀和就可以整除分块了。

***

$$
f(n)=\varphi(n) \times n \times n
$$

$$
g(n)=n \times n
$$

$$
h(n)=\sum_{d|n}f(d)* g(\frac{n}{d})
$$

$$
~~ ~~~~~~~~~~~~~~~~~~~~~~~ =\sum_{d|n}\varphi(d) \times d \times d * \frac{n}{d} * \frac{n}{d}
$$

$$
~~ ~~~~ =n^2\sum_{d|n}\varphi(d)=n^3
$$

$$
g(1)S(n)=\sum_{i=1}^{n}h(i)-\sum_{d=2}^ng(d)S(\lfloor \frac{n}{d} \rfloor)
$$

$$
S(n)=sum^3(n)-\sum_{d=2}^ng(d)S(\lfloor \frac{n}{d} \rfloor)
$$

这道题就完了。

```cpp
#include <map>
#include <cstdio>
using namespace std;

const int MAXN = 8000000;
long long n;
int p , inv4 , inv6 , k , prime[ MAXN + 5 ] , phi[ MAXN + 5 ] , f[ MAXN + 5 ];
bool vis[ MAXN + 5 ];

void sieve( ) {
	f[ 1 ] = phi[ 1 ] = 1;
	for( int i = 2 ; i <= MAXN ; i ++ ) {
		if( !vis[ i ] ) {
			prime[ ++ k ] = i;
			phi[ i ] = i - 1;
		}
		for( int j = 1 ; j <= k && 1ll * i * prime[ j ] <= MAXN ; j ++ ) {
			vis[ i * prime[ j ] ] = 1;
			if( i % prime[ j ] == 0 ) {
				phi[ i * prime[ j ] ] = phi[ i ] * prime[ j ];
				break;
			}
			else
				phi[ i * prime[ j ] ] = phi[ i ] * ( prime[ j ] - 1 );	
		}
		f[ i ] = ( f[ i - 1 ] + 1ll * i * i % p * phi[ i ] % p ) % p;
	}
}

map< long long , int > Map;
int sum2( long long x ) {
	x %= p;
	return 1ll * x * ( x + 1 ) % p * ( 2 * x + 1 ) % p * inv6 % p;
}
int sum3( long long x ) {
	x %= p;
	return 1ll * x * x % p * ( x + 1 ) % p * ( x + 1 ) % p * inv4 % p; 
} 
int Sumphii( long long n ) {
	if( n <= MAXN ) return f[ n ];
	if( Map[ n ] ) return Map[ n ];
	
	int Ans = sum3( n );
	for( long long l = 2 , r ; l <= n ; l = r + 1 ) {
		r = n / ( n / l );
		Ans = ( Ans - 1ll * ( sum2( r ) - sum2( l - 1 ) ) % p * Sumphii( n / l ) % p ) % p; 
	}
	return Map[ n ] = ( Ans + p ) % p;
}
int solve( long long n ) {
	int Ans = 0;
	for( long long l = 1 , r ; l <= n ; l = r + 1 ) {
		r = n / ( n / l );
		Ans = ( Ans + 1ll * ( Sumphii( r ) - Sumphii( l - 1 ) ) * sum3( n / l ) % p ) % p;
	}
	return ( Ans + p ) % p;
}

int Quick_pow( int x , int po ) {
	int Ans = 1;
	while( po ) {
		if( po & 1 ) Ans = 1ll * Ans * x % p;
		x = 1ll * x * x % p;
		po /= 2;
	}
	return Ans;
}
int Inv( int x ) {
	return Quick_pow( x , p - 2 );
}

signed main( ) {
	scanf("%d %lld",&p,&n);
	sieve( ); 
	inv4 = Inv( 4 ) , inv6 = Inv( 6 );
	printf("%d", solve( n ) );
	return 0;
}
```




---

## 作者：远航之曲 (赞：3)

不错的题啊


要是公式崩了就到[我的blog](http://www.yhzq-blog.cc/bzoj2154和luogu3768/)上看吧


#### 题意


求

$$\sum_{i=1}^n\sum_{j=1}^nijgcd(i,j) \bmod p$$


其中$n\leq 10^{10},p \in 质数$


#### 题解


这个题和bzoj2154惊人的类似啊


反演吧


我们设$gcd(i,j)=d$


现在想要枚举$d$，就确定$ij$如何取。那么就可以先把$i,j$中的$d$因子去掉就可以了。也就是$gcd(i/d,j/d)=1$。


设

$F(x, y) = \sum_{i=1}^{x} \sum_{j=1}^{y} ij[gcd(i,j)=1]$


那么原式中还需要乘上$d^2$，因为除掉了两个：


$原式=\sum_{d=1}^{n} d^3 F( \frac{n}{d} ,  \frac{n}{d} )$


考虑化简一下


$F(x, y)= \sum_{i=1}^{x} \sum_{j=1}^{y} ij[gcd(i,j)=1]$


反演一下


$= \sum_{i=1}^{x} \sum_{j=1}^{y} ij \sum_{d|(i,j)} \mu (d) $


改成枚举$d$，计算一下贡献


$= \sum_{d=1}^{x} \mu (d) \sum_{d|i}^{x} i \sum_{d|j}^{y} j$

换个元


$= \sum_{d=1}^{x} \mu (d) d^2 \sum_{i=1}^{ \frac{x}{d}} i \sum_{j=1}^{\frac{y}{d}} j$


等差数列公式


$= \sum_{d=1}^{x} \mu (d) d^2 \frac{\frac{x}{d} ( \frac{x}{d}+1)}{2} \frac{\frac{y}{d} (\frac{y}{d} +1)}{2} $


带回原式


$原式=\sum_{d=1}^{n} d^3 F( \frac{n}{d} ,  \frac{n}{d} )$


带入

$\large = \sum_{d=1}^{n} d^3 \sum_{i=1}^{ \frac{n}{d} } \mu (i) i^2 (\frac{ \frac{ \frac{n}{d} }{i}  ( \frac{ \frac{n}{d} }{i}  +1)}{2} )^@ $


把$d$乘下来


$= \sum_{d=1}^{n} d^3 \sum_{i=1}^{ \frac{n}{d} } \mu (i) i^2( \frac{ \frac{n}{di}  ( \frac{n}{di}  +1)}{2})^2$


令$T=di$，则$i|T,d=T/i$，换个元


$= \sum_{T=1}^{n} (\frac{ \frac{n}{T}  ( \frac{n}{T}  +1)}{2})^2 \sum_{i|T} (\frac{T}{i})^3 \mu (i) i^2 $


把$T$带出来


$= \sum_{T=1}^{n} (\frac{ \frac{n}{T}  ( \frac{n}{T}  +1)}{2})^2 T^2 \sum_{i|T} \mu (i) \frac{T}{i} $


所以$T \over i$也是一个因子，都是等价的，所以和下面是一样的


$= \sum_{T=1}^{n} (\frac{ \frac{n}{T}  ( \frac{n}{T}  +1)}{2})^2 T^2 \sum_{i|T} \mu (\frac{T}{i}) i $


我们现在就要研究这个函数


$f(x)=x^2\sum_{i|x}\mu({x \over i})i$


处理出它的前缀和就可以解决这个题了


我们再来看一下它的内函数


$g(x)=\sum_{i|x}\mu({x \over i})i =\sum_{i|x}\mu(i){x \over i}$

再用线性筛的思路试试


在线性筛中，外层为$k$，内层为$p$，所以求


$g(kp)=\sum_{i|kp} \mu({kp \over i})i=\sum_{i|kp} \mu(i){kp \over i}$

当$p|k$时


当$i$取的数的因子中不包含新加入的$p$时，答案就是$f(k)$


当$i$取包含新加入的因子$p$时，设$i=ap$


$=\mu({kp \over ap})ap=\mu({k \over a})ap$


也就是多了个$p$


综上，当$p|k$时，答案为$g(k)p$


当$p \nmid k$时当


$i$取的数的因子中不包含新加入的$p$时，同上，答案是$g(k)$


当$i$取的数的因子包含新加入的$p$时，由于指数为$1$，所以我们考虑$i=ap$，原式变为


$\sum_{i|x} \mu({x \over i})i$


$= \sum_{ap|kp} \mu(ap){kp \over ap} $


$= \sum_{a|k} \mu (a) \mu(p) {k \over a}$


$= -\sum_{a|k} \mu(a) a $


$= - g(k) $


综上，当$p_y \nmid k$时，答案为$(p-1)g(k)$


筛的时候发现这个函数竟然是$\phi$！


这个方法非常玄学。我们用更加正经的方法证明一下。


令$h(i)=i$，那么


$g(x)=(h\*\mu)(x)$


我们给$f(x)$卷一个1试试


$h\*\mu\*1=h\*(\mu\*1)=h\*\epsilon=h$


也就是$(h\*\mu)\*1=h$


又因为$\phi \*1=h$


所以$g(x)=\phi(x),f(x)=x^2\phi(x)$


现在就是要用杜教筛来解决这个函数的前缀和。


令$c(x)=x^2$


那么：


$(f\*c)(x)$


$=\sum_{d|x}f(x)c({x\over d})$


$=\sum_{d|x}d^2\phi{x^2 \over d^2}$


$=x^2\sum_{d|x}\phi(x)=x^3$


这样就可以杜教筛了。。。


令$s(n)=\sum_{i=1}^nf(x)$


那么

$c(1)s(n)=\sum_{i=1}^n(f\*c)(i)-\sum_{i=2}^nc(i)s({n \over i})$


$s(n)=\sum_{i=1}^ni^3-\sum_{i=2}^ni^2s({n\over i})$


然后就可以做了


代码

```cpp
#include <cstdio>
#include <algorithm>
#include <map>
#define maxn 4700000
#define N 4700050
using namespace std;
typedef long long ll;
ll p,n;
ll inv2,inv6;
ll phi[N],prime[N],tot;
bool not_prime[N];
map <ll,ll> ma;
ll pow(ll x,ll y,ll p)
{
    ll ans=1;
    for (;y;y>>=1,x=x*x%p) 
        if (y&1)
            ans=ans*x%p;
    return ans;
}
ll sqr(ll x) {x%=p;return x*x%p;}
ll g(ll x){x%=p;return sqr((x*(1+x)>>1)%p);}
ll get_h(ll x){x%=p;return x*(x+1)%p*(2*x+1)%p*inv6%p;}
ll min(ll a,ll b){if (a<b) return a;return b;}
void init(ll n)
{
    phi[1]=1;
    for (ll i=2;i<=n;i++)
    {
        if (!not_prime[i])
            prime[++tot]=i,phi[i]=i-1;
        for (ll j=1;j<=tot;j++)
        {
            ll temp=prime[j]*i;
            if (temp>n)
                break;
            not_prime[temp]=1;
            if (i%prime[j]==0)
            {
                phi[temp]=(phi[i]*prime[j])%p;
                break;
            }
            phi[temp]=(phi[i]*(prime[j]-1))%p;
        }
    }
    for(ll i=1;i<=n;i++)
        phi[i]=(phi[i]*sqr(i)%p+phi[i-1])%p;
    inv2=pow(2,p-2,p),inv6=pow(6,p-2,p);
}
ll get_f(ll n)
{
    if (n<=maxn) return phi[n];
    if (ma.count(n)) return ma[n];
    ll temp=g(n);
    for (ll i=2,last;i<=n;i=last+1)
    {
        last=n/(n/i);
        temp=(temp-(get_h(last)-get_h(i-1))*get_f(n/i)%p)%p;
    }
    return ma[n]=temp;
}
main()
{
    scanf("%lld%lld",&p,&n);
    init(min(maxn,n));
    ll ans=0;
    for (ll i=1,last;i<=n;i=last+1)
    {
        last=n/(n/i);
        ans=(ans+g(n/i)*((get_f(last)-get_f(i-1))%p)%p)%p;
    }
    printf("%lld\n",(ans+p)%p);
}
```


---

## 作者：hl666 (赞：2)

非常恶心的一道数学题，推式子推到吐血。

光是$\gcd$求和我还是会的，但是多了个$ij$是什么鬼东西。

$$\sum_{i=1}^n\sum_{j=1}^nij\gcd(i,j)=\sum_{d=1}^nd\sum_{i=1}^n\sum_{j=1}^nij[\gcd(i,j)=d]$$

很套路的把后面的$d$提出来：

$$\sum_{d=1}^nd\sum_{i=1}^n\sum_{j=1}^nij[\gcd(i,j)=d]=\sum_{d=1}^nd^3\sum_{i=1}^{\lfloor\frac{n}{d} \rfloor}\sum_{j=1}^{\lfloor\frac{n}{d} \rfloor} ij[\gcd(i,j)=1]$$

利用$\sum_{d|n}\mu(d)=[n=1]$替换掉$[\gcd(i,j)=1]$就有：

$$\sum_{d=1}^nd^3\sum_{i=1}^{\lfloor\frac{n}{d} \rfloor}\sum_{j=1}^{\lfloor\frac{n}{d} \rfloor} ij[\gcd(i,j)=1]=\sum_{d=1}^nd^3\sum_{i=1}^{\lfloor\frac{n}{d} \rfloor}\sum_{j=1}^{\lfloor\frac{n}{d} \rfloor} ij\sum_{x|\gcd(i,j)}\mu(x)$$

然后第一个难点来了，我们把$x$弄到前面去枚举，然后利用**和式的变换**，枚举$i,j$是$x$的多少倍，然后用分配率凑在一起就有：

$$\sum_{d=1}^nd^3\sum_{i=1}^{\lfloor\frac{n}{d} \rfloor}\sum_{j=1}^{\lfloor\frac{n}{d} \rfloor} ij\sum_{x|\gcd(i,j)}\mu(x)=\sum_{d=1}^nd^3\sum_{x=1}^{\lfloor\frac{n}{d} \rfloor}\mu(x) (\sum_{i=1}^{\lfloor\frac{n}{dx} \rfloor})^2x^2$$

PS:如果上面理解了那么下面就不难了，我们设$T=dx$带进去就有：

$$\sum_{d=1}^nd^3\sum_{x=1}^{\lfloor\frac{n}{d} \rfloor}\mu(x) (\sum_{i=1}^{\lfloor\frac{n}{dx} \rfloor})^2x^2=\sum_{T=1}^n(\sum_{i=1}^{\lfloor\frac{n}{T} \rfloor}i)^2\sum_{d|T}d^3\mu(\frac{T}{d})(\frac{T}{d})^2$$

后面那个东西可以直接提出来就得到：

$$\sum_{T=1}^n(\sum_{i=1}^{\lfloor\frac{n}{T} \rfloor}i)^2\sum_{d|T}d^3\mu(\frac{T}{d})(\frac{T}{d})^2=\sum_{T=1}^n(\sum_{i=1}^{\lfloor\frac{n}{T} \rfloor}i)^2\sum_{d|T}dT^2\mu(\frac{T}{d})$$

把$T^2$提到前面去：

$$\sum_{T=1}^n(\sum_{i=1}^{\lfloor\frac{n}{T} \rfloor}i)^2\sum_{d|T}dT^2\mu(\frac{T}{d})=\sum_{T=1}^n(\sum_{i=1}^{\lfloor\frac{n}{T} \rfloor}i)^2T^2\sum_{d|T}d\mu(\frac{T}{d})$$

后面那个$\sum_{d|T}d\mu(\frac{T}{d})$显然就是**狄利克雷卷积**的形式啊，这就等于$(id\ast\mu)(T)$

然后回忆一下，$(id\ast\mu)(T)$不就是$\phi$么，因此带进去就有：

$$\sum_{T=1}^n(\sum_{i=1}^{\lfloor\frac{n}{T} \rfloor}i)^2T^2\sum_{d|T}d\mu(\frac{T}{d})=\sum_{T=1}^n(\sum_{i=1}^{\lfloor\frac{n}{T} \rfloor}i)^2T^2\phi(T)$$

把$\sum_{i=1}^{\lfloor\frac{n}{T} \rfloor}i$用**等差数列**求和的公式展开就变成：

$$\sum_{T=1}^n(\sum_{i=1}^{\lfloor\frac{n}{T} \rfloor}i)^2T^2\phi(T)=\sum_{T=1}^n(\frac{(1+\lfloor\frac{n}{T} \rfloor)\cdot\lfloor\frac{n}{T} \rfloor}{2})^2T^2\phi(T)$$

如果我们对$\lfloor\frac{n}{T}\rfloor$做**除法分块**，那么现在要求的就是$T^2\phi(T)$的前缀和了

考虑用**杜教筛**的方法化式子，我们设$f(i)=i^2\phi(i)$，这个时候我们要找一个$g$和$f$卷起来可以方便求。

由于$i^2$很烦，我们考虑先把它消去。令$g(i)=i^2$，则有：

$h(n)=(f\ast g)(n)=\sum_{d|n} d^2\phi(d)(\frac{n}{d})^2=n^2\ast(\phi\ast \epsilon)(n)=n^3$

所以用杜教筛的套路式就是$g(1)f(n)=h(n)-\sum_{d=2}^ng(d)f(\lfloor\frac{n}{d}\rfloor)$

即$f(n)=\sum_{i=1}^ni^3-\sum_{d=2}^ng(d)f(\lfloor\frac{n}{d}\rfloor)$，我们知道$\sum_{i=1}^ni^3=(\frac{n(n+1)}{2})^2,\sum_{i=1}^ni^2=\frac{n(n+1)(2n+1)}{6}$，所以都可以$O(1)$求啦。

CODE

```cpp
#include<cstdio>
#include<map>
#define RI register int
#define RL register LL
using namespace std;
typedef long long LL;
const int P=10000000;
map <LL,int> sum_f; LL n; int prime[P+5],phi[P+5],cnt,f[P+5],mod,inv2,inv6,ans; bool vis[P+5];
inline void inc(int &x,int y)
{
    if ((x+=y)>=mod) x-=mod;
}
inline void dec(int &x,int y)
{
    if ((x-=y)<0) x+=mod;
}
inline int quick_pow(int x,int p,int mul=1)
{
    for (;p;p>>=1,x=1LL*x*x%mod) if (p&1) mul=1LL*mul*x%mod; return mul;
}
inline int sum(int x)
{
    return 1LL*x*(x+1)%mod*inv2%mod;
}
inline int sqr(int l,int r)
{
    int t=1LL*r*(r+1)%mod*((r<<1LL)+1)%mod*inv6%mod;
    dec(t,1LL*l*(l-1)%mod*((l<<1LL)-1)%mod*inv6%mod); return t;
}
#define Pi prime[j]
inline void Euler(void)
{
    vis[1]=phi[1]=1; RI i,j; for (i=2;i<=P;++i)
    {
        if (!vis[i]) prime[++cnt]=i,phi[i]=i-1;
        for (j=1;j<=cnt&&i*Pi<=P;++j)
        {
            vis[i*Pi]=1; if (i%Pi) phi[i*Pi]=phi[i]*(Pi-1);
            else { phi[i*Pi]=phi[i]*Pi; break; }
        }
    }
    for (i=1;i<=P;++i) f[i]=f[i-1],inc(f[i],1LL*phi[i]*i%mod*i%mod);
}
#undef Pi
inline int F(LL x)
{
    if (x<=P) return f[x]; if (sum_f.count(x)) return sum_f[x];
    int ans=sum(x%mod); ans=1LL*ans*ans%mod; for (RL l=2,r;l<=x;l=r+1)
    {
        r=x/(x/l);
        int t=sqr(l%mod,r%mod);
        dec(ans,1LL*t*F(x/l)%mod);
    }
    return sum_f[x]=ans;
}
int main()
{
    //freopen("CODE.in","r",stdin); freopen("CODE.out","w",stdout);
    scanf("%d%lld",&mod,&n); Euler(); inv2=quick_pow(2,mod-2);
    inv6=quick_pow(6,mod-2); for (RL l=1,r;l<=n;l=r+1)
    {
        r=n/(n/l); int t=sum(n/l%mod); t=1LL*t*t%mod;
        int Fs=F(r); dec(Fs,F(l-1)); inc(ans,1LL*t*Fs%mod);
    }
    return printf("%d",ans),0;
}
```

---

## 作者：command_block (赞：2)

**反演神仙题纪念!**

在遥远的过去,连乘法逆元都不会求的我,漫步在luogu中,看到了这道貌似友善的题,点开题解就被大佬们那一吨公式给劝退了,奋斗了一年半以后,终于AC了!

个人感觉这是莫比乌斯反演里面中高难度的一道题了,门槛也比较高,需要熟练地推导合式与学会杜教筛,综上,A了这道题说明你的莫比乌斯反演基本入门成功啦!

如果你对上述操作感到困难,可以查看我的[$\large{\text{数论专题}}$](https://www.luogu.org/blog/command-block/shuo-lun-zhuan-ti)。

好了,我们默认你会杜教筛了(千万不要拿这道题来入门杜教筛),那就开始吧……

[原题传送门](https://www.luogu.org/problemnew/show/P3768)

附:[一道相似的题目](https://www.luogu.org/problemnew/show/P1829)(不用杜教筛)

求:$\sum\limits_{i=1}^n\sum\limits_{j=1}^mij*gcd(i,j)$

按照套路,枚举$gcd$。

$=\sum\limits_{d=1}^n\sum\limits_{i=1}^n\sum\limits_{j=1}^nijd[(i,j)==d]$

$=\sum\limits_{d=1}^md\sum\limits_{i=1}^n\sum\limits_{j=1}^nij[(i,j)==d]$

后方同时除以$d$,为了复原,$ij$项需要乘以$d^2$还原。

$\sum\limits_{d=1}^nd\sum\limits_{i=1}^{n/d}\sum\limits_{j=1}^{n/d}ijd^2[(i,j)==1]$

$\sum\limits_{d=1}^nd^3\sum\limits_{i=1}^{n/d}\sum\limits_{j=1}^{n/d}ij[(i,j)==1]$

我们设$f(x,n)=\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{n}ij[(i,j)==x]$

$F(x,n)=\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{n}ij[x|(i,j)]$

很明显$F(x,n)=\sum\limits_{k=1}^∞f(kx,n)$

根据反演定理可得$f(x,n)=\sum\limits_{k}^∞\mu(k)F(kx,n)$

我们要求$f(1,n)$,根据上式得$ANS=\sum\limits_{k}^∞\mu(k)F(k,n)$

现在来求$F(x,n)$。

$F(x)=\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{n}ij[x|(i,j)]$

把所有的数除以$x$,其中的$ij$要乘回$x^2$

得到$=\sum\limits_{i=1}^{n/x}\sum\limits_{j=1}^{n/x}ijx^2[1|(i,j)]$

$=x^2\sum\limits_{i=1}^{n/x}\sum\limits_{j=1}^{n/x}ij$

我们设$sum(x)=\sum\limits_{i=1}^{x}\sum\limits_{j=1}^{x}ij$

可推出$sum(x)=\sum\limits_{i=1}^{x}\sum\limits_{j=1}^{x}ij=\sum\limits_{i=1}^{x}i\sum\limits_{j=1}^{x}j=(\dfrac{x(x+1)}{2})^2$

所以上式$=x^2*sum(n/x)$

我们回代,得到$f(1,n)=\sum\limits_{k}^∞\mu(k)k^2*sum(n/k)$

回代至上方的$ANS=\sum\limits_{d=1}^nd^3\sum\limits_{i=1}^{n/d}\sum\limits_{j=1}^{n/d}ij[(i,j)==1]$

得到$ANS=\sum\limits_{d=1}^nd^3*f(1,n/d)$

按照上一题的做法就可以$O(n)$了,可以得到60分。

```cpp
#include<iostream>
#include<cstdio>
#define MaxNum 1000500
using namespace std;
int p[MaxNum/10],tn,n,mod;
long long mu[MaxNum+500];
bool e[MaxNum+500];
void getmu()
{
  e[1]=1;mu[1]=1;
  for (int i=2;i<=MaxNum;i++){
    if (!e[i]){p[++tn]=i;mu[i]=-1;}
    for (int j=1;j<=tn&&p[j]*i<=MaxNum;j++){
      mu[p[j]*i]=i%p[j]==0 ? 0 : -mu[i];
      e[p[j]*i]=1;
      if (i%p[j]==0)break;
    }
  }
}
long long sum(long long n)
{
  return ((n*(n+1)/2)%mod)*((n*(n+1)/2)%mod)%mod;
}
long long calc(int n)
{
  long long ans=0;
  for (int l=1,r=0;l<=n;l=r+1){
    r=n/(n/l);
    ans=(ans+(mu[r]-mu[l-1])*sum(n/l))%mod;
  }return ans;
}
int main()
{
  cin>>mod>>n;
  getmu();
  for (int i=2;i<=MaxNum;i++)
   mu[i]=(mu[i]*i%mod*i+mu[i-1])%mod;
  long long ans=0;
  for (long long i=1;i<=n;i++)
   ans=(ans+i*i%mod*i%mod*calc(n/i))%mod;
  cout<<(ans+mod)%mod<<endl;
  return 0;
}
```

但是这不够优秀,我们把式子都写在一起看看:

$ANS=\sum\limits_{d=1}^nd^3*\sum\limits_{k}^∞\mu(k)k^2*sum(\dfrac{n}{dk})$

$=\sum\limits_{d=1}^nd^3*\sum\limits_{k=1}^{n/d}\mu(k)k^2*sum(\dfrac{n}{dk})$

令$T=dk$,好好理解哦:

$=\sum\limits_{T=1}^n*\sum\limits_{k|T}\mu(k)d^3k^2*sum(\dfrac{n}{T})$

$=\sum\limits_{T=1}^nsum(\dfrac{n}{T})*\sum\limits_{k|T}\mu(k)(\dfrac{T}{k})^3k^2$

约掉一些$k$

$=\sum\limits_{T=1}^nsum(\dfrac{n}{T})*\sum\limits_{k|T}\mu(k)\dfrac{T^3}{k}$

注意到$k|T$,后面的可以提一个$T^2$,可以凑出$\mu*id=\varphi$

$=\sum\limits_{T=1}^nT^2sum(\dfrac{n}{T})*\sum\limits_{k|T}\mu(k)\dfrac{T}{k}$

$=\sum\limits_{T=1}^nT^2sum(\dfrac{n}{T})*\varphi(T)$

整理一下:

$=\sum\limits_{T=1}^nsum(\dfrac{n}{T})*\varphi(T)*T^2$

现在很明显了,就是$f(x)=varphi(x)*x^2$这个函数上整除分块而已。

然后我们要对$f(x)$来一个杜教筛就好啦。

套路式子$g(1)S(n)=RS(n)-\sum\limits_{d=2}g(d)S(\lfloor n/d\rfloor)$

g函数选什么呢?

$R(n)=(g*f)(n)=\sum\limits_{d|n}d^2*\varphi(d)*g(n/d)$

令$g=id^2$,得到

$R(n)=\sum\limits_{d|n}d^2*\varphi(d)*(n/d)^2=n^2\sum\limits_{d|n}\varphi(d)$

根据$\sum\limits_{d|n}\varphi(d)=n$

$R(n)=n^3$

所以$RS(n)=1+2^3+...+n^3=(\dfrac{n(n+1)}{2})^2$

$GS(n)=1+2^2+...+n^2=\dfrac{n(n+1)(2n+1)}{6}$

(这里要求6的逆元)

现在可以开筛啦!

```cpp
#include<cstdio>
#include<bitset>
#include<map>
#include<ctime>
#define Limit 10000000
using namespace std;
long long T,N,inv6;
bitset<Limit+500> e;
int tn,p[Limit+500],mod,rLimit;
long long phi[Limit+500];
long long powM(long long a,long long t=mod-2)
{
  long long ans=1;
  while(t){
  	if (t&1)ans=ans*a%mod;
  	a=a*a%mod;
  	t>>=1;
  }return ans;
}
void getsth()
{
  e[1]=1;phi[1]=1;
  for (int i=2,t;i<=rLimit;i++){
    if (!e[i]){
      p[++tn]=i;
      phi[i]=i-1;
    }
    for (int j=1;j<=tn&&(t=p[j]*i)<=rLimit;j++){
      phi[t]=phi[i]*(i%p[j]==0 ? p[j] : p[j]-1);
      e[t]=1;
      if (i%p[j]==0)break;
    }
  }
}
inline long long GS(long long p)
{
  p%=mod;
  return p*(p+1)%mod*(2*p+1)%mod*inv6%mod;
}
inline long long RS(long long p)
{
  p%=mod;p=p*(p+1)/2%mod;
  return p*p%mod;
}
map<long long,long long> savphi;
long long S(long long p)
{
  if (p<=Limit)return phi[p];
  if (savphi.count(p))return savphi[p];
  long long ans=RS(p);
  long long l=2,r;
  for (;l<=p;l=r+1){
    r=p/(p/l);
    ans=(ans-S(p/l)*(GS(r)-GS(l-1)))%mod;
  }return savphi[p]=(ans+mod)%mod;
}
inline long long Sum(long long p)
{
  p%=mod;p=p*(p+1)/2%mod;
  return p*p%mod;
}
int main()
{
  scanf("%d%lld",&mod,&N);
  inv6=powM(6);
  if (N<Limit)rLimit=N;
  else rLimit=Limit;
  getsth();
  for (long long i=2;i<=rLimit;i++)
    phi[i]=(phi[i]*i%mod*i+phi[i-1])%mod;
  long long l=1,r=N,ans=0;
  for (;l<=N;l=r+1){
  	r=N/(N/l);
  	ans=(ans+Sum(N/l)*(S(r)-S(l-1)))%mod;
  }printf("%lld",(ans+mod)%mod);
  return 0;
}
```

为了跑进最优解前三页,稍微卡了一下常数QAQ

---

## 作者：wwlw (赞：2)

题目:[link](https://www.luogu.org/problem/P3768)

-------------------

原式
$$\sum_{i=1}^{n}\sum_{j=1}^n{ijgcd(i,j)}$$
枚举 $gcd$ 得到
$$\sum_{d=1}^n\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{d}\rfloor}ijd^3[gcd(i,j)=1]$$
把 $d^3$ 提到前面
$$\sum_{d=1}^nd^3\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{d}\rfloor}ij[gcd(i,j)=1]$$
设函数
$$f(n)=\sum_{i=1}^{n}\sum_{j=1}^nij[gcd(i,j)=1]$$
$$s(n)=\sum_{i=1}^{n}\sum_{j=1}^nij$$
则原式等于
$$\sum_{d=1}^nd^3f(\lfloor\frac{n}{d}\rfloor)$$
可以看出是数论分块，其中立方部分和为
$$\sum_{i=1}^{n}i^3=(\sum_{i=1}^ni)^2=[\frac{n(n+1)}{2}]^2$$
求出前缀做差即可

--------------
考虑快速求 $f(n)$，非常显然
$$s(n)=\sum_{i=1}^{n}\sum_{j=1}^nij=[\frac{n(n+1)}{2}]^2$$
而对于 $s(n)$ 同样枚举 $gcd$ 可得
$$s(n)=\sum_{i=1}^{n}\sum_{j=1}^nij=\sum_{t=1}^{n}\sum_{i=1}^{\lfloor\frac{n}{t}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{t}\rfloor}t^2ij[gcd(i,j)=1]$$
用 $f(n)$ 替换上式得
$$s(n)=\sum_{t=1}^{n}t^2f(\lfloor\frac{n}{t}\rfloor)=f(n)+\sum_{t>1}t^2f(\lfloor\frac{n}{t}\rfloor)$$
所以有
$$f(n)=s(n)-\sum_{t>1}t^2f(\lfloor\frac{n}{t}\rfloor)=[\frac{n(n+1)}{2}]^2-\sum_{t>1}t^2f(\lfloor\frac{n}{t}\rfloor)$$
到了此刻已经非常容易求了，数论分块即可，其中
$$\sum_{i=1}^{n}i^2=\frac{n(n+1)(2n+1)}{6}$$
做法同立方和，前缀做差

--------------
考虑预处理 $f(n)$ 部分
$$f(n)=\sum_{i=1}^{n}\sum_{j=1}^nij[gcd(i,j)=1]=f(n-1)+2\sum_{i=1}^{n}in[gcd(i,n)=1]$$

那么需要快速求得
$$\sum_{i=1}^ni[gcd(i,n)=1]$$
发现这就是与 $n$ 互质的数的和，就等于
$$n\frac{\varphi(n)}{2}$$
详细证明参考[链接](https://blog.csdn.net/SM_545/article/details/81157057)

带回原式得到
$$f(n)=f(n-1)+n^2\varphi(n)$$
线性筛预处理即可

-------------

Code：
```cpp
#pragma GCC optimize(2)
#include<stdio.h>
#include<string.h>
#include<cassert>
#define Mod p
#define LL long long
#define N 5000000

template<class T>
inline void read(T &x){
	x=0;char c=getchar();T flag=1;
	while(c<'0'||c>'9'){if(c=='-')flag=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+c-48;c=getchar();}
	x*=flag;
}

LL n,p,inv,inv6;
int cnt,P[N];
bool mark[N];
LL phi[N],f[N],F[N];

inline LL qpow(LL a,LL b){
	if(!b) return 1LL;
	if(b==1LL) return a;
	LL t=qpow(a,b>>1LL);
	t=t*t%Mod;
	if(b&1LL) t=t*a%Mod;
	assert(t>=0);
	return t;
}
inline LL pow2(LL x){//平方前缀和
	return ((inv6*x)%Mod)*(((x+1LL)%Mod)*((2LL*x+1LL)%Mod)%Mod)%Mod;
}
inline LL pow2(LL l,LL r){平方区间和
	return ((pow2(r)-pow2(l-1LL))%Mod+Mod)%Mod;
}
inline LL pow3(LL x){立方前缀和
	return qpow(((x%Mod)*(x+1LL)%Mod)*inv%Mod,2LL);
}
inline LL pow3(LL l,LL r){立方区间和
	return ((pow3(r)-pow3(l-1LL))%Mod+Mod)%Mod;
}
inline void Prework(int x){//线性筛预处理 f(n)
	cnt=0;
	f[1]=phi[1]=1;
	for(int i=2;i<=x;++i){
		if(!mark[i]){
			P[cnt++]=i;
			phi[i]=i-1;
		}
		for(int j=0;j<cnt&&i*P[j]<=x;++j){
			mark[i*P[j]]=1;
			if(!(i%P[j])){
				phi[i*P[j]]=phi[i]*P[j];
				break;
			}else phi[i*P[j]]=phi[i]*(P[j]-1);
		}
		LL ret=qpow(i,2LL)*phi[i]%Mod;
		f[i]=(f[i-1]+ret)%Mod;
	}
}
inline LL solve(LL x){//杜教筛
	if(x<=N-3) return f[x];
	if(~F[n/x]) return F[n/x];
	F[n/x]=qpow(((x%Mod)*((x+1)%Mod)%Mod)*inv%Mod,2);
	for(LL l=2,r;l<=x;l=r+1){
		r=x/(x/l);
		F[n/x]=((F[n/x]-(pow2(l,r)*solve(x/l)%Mod))%Mod+Mod)%Mod;
	}
	return F[n/x];
}
int main(){
	memset(F,-1,sizeof(F));
	read(p),read(n);
	inv=qpow(2LL,p-2);//2的逆元
	inv6=qpow(6LL,p-2);//6的逆元
	Prework(N-3);
	LL ans=0;
	for(LL l=1,r;l<=n;l=r+1){//原式
		r=n/(n/l);
		ans=(ans+(pow3(l,r)*solve(n/l))%Mod)%Mod;
	}
	printf("%lld",ans);
}
/*
998244353 2
*/
```

---

## 作者：disangan233 (赞：1)

## 前言

建议到 [本蒟蒻的博客](https://www.cnblogs.com/disangan233/p/11142293.html) 观看以享受最好的体验。

## 题意简述

求出这个式子

$$
\sum_{i=1}^n\sum_{j=1}^n ij(i,j) \bmod p
$$

## 做法

先用莫比乌斯反演拆一下式子。（因为 luogu 的博客不支持 `split` ，所以采用pdf截图的方式）

![shizi](https://cdn.luogu.com.cn/upload/pic/62339.png)

所以杜教筛直接做 $\sum_i \varphi(i)$，此题结束。  

## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
#define re register int
#define db double
#define ll long long
#define ak *
#define in inline
in char getch()
{
	static char buf[10000],*p1=buf,*p2=buf;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,10000,stdin),p1==p2)?EOF:*p1++;
} 
char qwq;
#define gc() getch()
in ll read()
{
	ll cz=0,ioi=1;qwq=gc();
	while(qwq<'0'||qwq>'9') ioi=qwq=='-'?~ioi+1:1,qwq=gc();
	while(qwq>='0'&&qwq<='9') cz=(cz<<3)+(cz<<1)+(qwq^48),qwq=gc();
	return cz ak ioi;
}
const int lim=5000000;
ll inv2,inv6,mod,a,b,c,d,k,t,mu[5000005],vis[5000005],prime[500005],phi[5000005];
unordered_map<ll,ll>smu,sphi;
in void get()
{
    mu[1]=phi[1]=1;
    for(re i=2;i<=lim;i++)
    {
        if(!vis[i]) prime[++prime[0]]=i,mu[i]=-1,phi[i]=i-1;
        for(re j=1;j<=prime[0];j++)
        {
            if(i*prime[j]>lim) break;
            vis[i*prime[j]]=1;
            if(i%prime[j]==0) {mu[i*prime[j]]=0;phi[i*prime[j]]=prime[j]*phi[i]%mod;break;}
            else mu[i*prime[j]]=-mu[i],phi[i*prime[j]]=(prime[j]-1)*phi[i]%mod;
        }
    }
    for(re i=2;i<=lim;i++) phi[i]=(phi[i]*1ll*i%mod*i)%mod;
    for(re i=2;i<=lim;i++) phi[i]=(phi[i-1]+phi[i])%mod;
}
in ll get1(ll l,ll r)
{
	l%=mod;r%=mod;
    ll dy=(l+r)%mod*(r-l+1)%mod*inv2%mod;
    return dy*dy%mod;
}
in ll get2(ll l,ll r)
{
	l%=mod;r%=mod;
    return (r%mod*(r+1)%mod*(2ll*r+1)%mod*inv6%mod-(l-1)%mod*(2ll*(l-1)+1)%mod*l%mod*inv6%mod+mod)%mod;
}
ll get_phi(ll n)
{
    if(n<=lim) return phi[n];
    if(sphi[n]) return sphi[n];
    ll res=get1(1,n);
    for(ll l=2,r;l<=n;l=r+1)
    r=n/(n/l),res=(res-get2(l,r)*get_phi(n/l)%mod+mod)%mod;
    return sphi[n]=res;
}
inline ll qpow(ll x,ll y,ll z=1)
{
    for(;y;y>>=1,x=x*x%mod) z=(y&1)?x*z%mod:z;
    return z;
}
int main()
{
    mod=read();get();
    ll n=read(),ans=0ll;
    inv2=qpow(2,mod-2);inv6=qpow(6,mod-2);
    for(ll l=1,r,s;l<=n;l=r+1)
    {
        r=n/(n/(l));
        ans=(ans+(get_phi(r)-get_phi(l-1)+mod)%mod*get1(1,n/l)%mod)%mod;
        ans=(ans+mod)%mod;
    }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：Sshenyyyu (赞：1)

先给两个公式的推导

$$1^2+2^2+3^2+...+n^2=?$$

$$1^3+2^3+3^3+...+n^3=?$$

巨佬都说根据小学奥数，然而~~蒟蒻小学没学过奥数~~，还是有必要推一下的

这显然是自然数幂和的两种特殊情况，~~用伯努利数可以轻松解决~~

以下是手算方法

$$1^2+2^2+3^2+...+n^2=1+2+3+...+n+1*0+2*1+...+n(n-1)$$

一个显然的式子

$$n(n-1)=\frac{(n+1)n(n-1)-n(n-1)(n-2)}{3}$$

所以有原式=

$$\frac{n(n+1)}{2}+\frac{-1*0*1+0*1*2-0*1*2+1*2*3-...-n(n-1)(n-2)+(n-1)n(n+1)}{3}$$

$$=\frac{n(n+1)}{2}+\frac{(n-1)n(n+1)}{3}$$

$$=\frac{n(n+1)(2n-1)}{6}$$

同理$\sum_{i=1}^{n}i^3$的式子可以自己推一下

然后反演

有公式

$$\sum_{i|d}\phi(i)=d$$

直接套公式

$$\sum_{i=1}^n\sum_{j=1}^nij\sum_{k|i,k|j}\phi(k)$$

$$=\sum_{k=1}^nk^2\phi(k)\sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{k}\rfloor}ij$$

令$F(n)=\sum_{i=1}^{n}i=\frac{n(n+1)}{2}$

$$\sum_{k=1}^nk^2\phi(k)F^2(\lfloor\frac{n}{k}\rfloor)$$

$k^2\phi(k)$显然是积性函数，考虑杜教筛

我们给它卷上一个$g(x)=x^2$

$$(f*g)(n)$$

$$=\sum_{i|n}\frac{n^2}{i^2}i^2\phi(i)$$

$$=n^2\sum_{i|n}\phi(i)$$

$$=n^3$$

$n^3$ $n^2$的前缀和都很好算

然后就可以愉快地套杜教筛公式辣

Code:
```cpp
#include<stdio.h>
#include<iostream>
#include<map>
using namespace std;
typedef long long ll;
const ll N=5000000;
ll p,n,i,j,inv2,inv6,k,s;
ll prime[1000005],phi[5000005];
map<int,int> ans;
ll qpow(ll a,ll b)
{
    ll s=a,ans=1;
    while(b)
    {
        if(b&1)
            ans=ans*s%p;
        s=s*s%p;
        b>>=1;
    }
    return ans;
}
ll S(ll n)
{
    return n%p*(n%p+1)%p*(2*n%p+1)%p*inv6%p;
}
ll Sum(ll n)
{
    if(n<=N)
        return phi[n];
    if(ans[n])
        return ans[n];
    ll i,j,s=0;
    for(i=2;i<=n;)
    {
        j=n/(n/i);
        s+=(S(j)-S(i-1))%p*Sum(n/i)%p;
        i=j+1;
    }
    s%=p;
    ll t=n%p*(n%p+1)%p*inv2%p;
    t=t*t%p;
    return ans[n]=t-s;
}
int main()
{
    cin>>p>>n;
    inv2=qpow(2,p-2);
    inv6=qpow(6,p-2);
    for(i=1;i<=N;i++)
        phi[i]=i;
    for(i=2;i<=N;i++)
    {
        if(phi[i]==i)
        {
            prime[++k]=i;
            phi[i]=i-1;
        }
        for(j=1;j<=k&&prime[j]*i<=N;j++)
        {
            phi[prime[j]*i]=phi[prime[j]]*phi[i];
            if(i%prime[j]==0)
            {
                phi[prime[j]*i]=phi[i]*prime[j];
                break;
            }
        }
    }
    for(i=2;i<=N;i++)
    {
        phi[i]=phi[i]%p*i%p*i%p+phi[i-1];
        phi[i]%=p;
    }
    for(i=1;i<=n;)
    {
        j=n/(n/i);
        s=(s+(Sum(j)-Sum(i-1))%p*(1+(n/i)%p)%p*((n/i)%p)%p*inv2%p*(1+(n/i)%p)%p*((n/i)%p)%p*inv2%p)%p;
        i=j+1;
    }
    cout<<(s%p+p)%p<<endl;
}
```


---

## 作者：Wolfycz (赞：1)

看到$\gcd$我们就来套路一波，枚举因数可得

$$\sum\limits_{d=1}^nd^3\sum\limits_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum\limits_{j=1}^{\lfloor\frac{n}{d}\rfloor}ij[\gcd(i,j)=1]$$

然后对最后的$\gcd$反演得

$$\sum\limits_{d=1}^nd^3\sum\limits_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum\limits_{j=1}^{\lfloor\frac{n}{d}\rfloor}ij\sum\limits_{x|i,x|j}\mu(x)$$

然后我们更改一下枚举顺序得

$$\sum\limits_{d=1}^nd^3\sum\limits_{x=1}^{\lfloor\frac{n}{d}\rfloor}\mu(x)\sum\limits_{i=1}^{\lfloor\frac{n}{dx}\rfloor}\sum\limits_{j=1}^{\lfloor\frac{n}{dx}\rfloor}x^2ij$$

$$\sum\limits_{d=1}^nd^3\sum\limits_{x=1}^{\lfloor\frac{n}{d}\rfloor}x^2\mu(x)(\sum\limits_{i=1}^{\lfloor\frac{n}{dx}\rfloor}i)^2$$

然后我们设$h(x)=\sum\limits_{i=1}^ni$，令$T=dx$，然后再次更改枚举顺序可得

$$\sum\limits_{T=1}^nh(\dfrac{n}{T})^2\sum\limits_{d|T}d^3×(\dfrac{T}{d})^2\mu(\dfrac{T}{d})$$

$$\sum\limits_{T=1}^nh(\dfrac{n}{T})^2\sum\limits_{d|T}T^2d\mu(\dfrac{T}{d})$$

$T^2$那东西可以提到外面，于是里面只剩下$\sum\limits_{d|T}d\mu(\dfrac{T}{d})$，这是个卷积形式，卷积后的结果即为$\varphi(T)$，我们设$f(T)=T^2\varphi(T)$，那么原式变为

$$\sum\limits_{T=1}^nh(\dfrac{n}{T})^2f(T)$$

那么我们只要求出$f(T)$的前缀和，我们就可以数论分块$O(\sqrt n)$做完这题了

然后你发现这题$n\leqslant 10^{10}$，然后线筛肯定不行……我们需要用到[杜教筛](https://www.cnblogs.com/Wolfycz/p/10266081.html)

然后我们需要找到一个优秀的$g$，使得$\sum\limits_{i=1}^n(f*g)(i)$能够在$O(1)$的时间内算出来，根据人类智慧~~(其实是打表)~~，当$g(i)=i^2$时，可以得到

$$\begin{aligned}(f*g)(n)&=\sum\limits_{d|n}f(d)g(\dfrac{n}{d})\\&=\sum\limits_{d|n}d^2\varphi(d)(\dfrac{n}{d})^2\\&=n^2\sum\limits_{d|n}\varphi(d)\\&=n^3\end{aligned}$$

所以$\sum\limits_{i=1}^n(f*g)(i)=\sum\limits_{i=1}^ni^3$，这东西的前缀和是很好算的，为$h(n)^2$（证明请自行Google），于是我们可以用杜教筛得到$f(T)$的前缀和，配合之前的式子进行一下数论分块即可

```cpp
/*program from Wolfycz*/
#include<map>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define Fi first
#define Se second
#define inf 0x7f7f7f7f
using namespace std;
typedef long long ll;
typedef unsigned int ui;
typedef unsigned long long ull;
inline char gc(){
	static char buf[1000000],*p1=buf,*p2=buf;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++;
}
inline int frd(){
	int x=0,f=1; char ch=gc();
	for (;ch<'0'||ch>'9';ch=gc())	if (ch=='-')	f=-1;
	for (;ch>='0'&&ch<='9';ch=gc())	x=(x<<3)+(x<<1)+ch-'0';
	return x*f;
}
inline int read(){
	int x=0,f=1; char ch=getchar();
	for (;ch<'0'||ch>'9';ch=getchar())	if (ch=='-')	f=-1;
	for (;ch>='0'&&ch<='9';ch=getchar())	x=(x<<3)+(x<<1)+ch-'0';
	return x*f;
}
inline void print(int x){
	if (x<0)	putchar('-'),x=-x;
	if (x>9)	print(x/10);
	putchar(x%10+'0');
}
const int N=1e7;
int prime[N+10],phi[N+10],sh[N+10];//sh(x)=\sum\limits_{i=1}^i h(i); h(x)=x^2*\varphi(x)
bool inprime[N+10];
int p,inv2,inv4,inv6;
map<ll,int>Mp;
void prepare(){
	sh[1]=phi[1]=1; int tot=0;
	for (int i=2;i<=N;i++){
		if (!inprime[i])	prime[++tot]=i,phi[i]=i-1;
		for (int j=1;j<=tot&&i*prime[j]<=N;j++){
			inprime[i*prime[j]]=1;
			if (i%prime[j]==0){
				phi[i*prime[j]]=phi[i]*prime[j];
				break;
			}
			phi[i*prime[j]]=phi[i]*(prime[j]-1);
		}
		sh[i]=(sh[i-1]+1ll*i*i%p*phi[i]%p)%p;
	}
}
int s2(ll n){n%=p;return 1ll*(2*n+1)*(n+1)%p*n%p*inv6%p;}
int SH(ll n){
	if (n<=N)	return sh[n];
	map<ll,int>::iterator it=Mp.find(n);
	if (it!=Mp.end())	return it->Se;
	int tmp=n%p,res=1ll*tmp*tmp%p*(tmp+1)%p*(tmp+1)%p*inv4%p;
	for (ll i=2,pos;i<=n;i=pos+1){
		pos=n/(n/i);
		res=(res-1ll*(s2(pos)-s2(i-1))*SH(n/i)%p)%p;
	}
	res=(res+p)%p;
	Mp.insert(map<ll,int>::value_type(n,res));
	return res;
}
int s1(ll n){n%=p;return 1ll*n*(n+1)%p*inv2%p;}
int mlt(int a,int b){
	int res=1;
	for (;b;b>>=1,a=1ll*a*a%p)	if (b&1)	res=1ll*res*a%p;
	return res;
}
int main(){
	ll n;
	scanf("%d%lld",&p,&n);
	inv2=mlt(2,p-2);
	inv4=mlt(4,p-2);
	inv6=mlt(6,p-2);
	prepare(); int Ans=0;
	for (ll i=1,pos;i<=n;i=pos+1){
		pos=n/(n/i);
		Ans=(Ans+1ll*(SH(pos)-SH(i-1))*s1(n/i)%p*s1(n/i)%p)%p;
	}
	printf("%d\n",(Ans+p)%p);
	return 0;
}
```



---

## 作者：Regimes (赞：1)

这是一道给人启示的一道数学题

但是我太菜了，只会推一下版版的式子

原式：

$$\sum_{i=1}^n\sum_{j=1}^ni*j*gcd(i,j)$$

化简：

$$\sum_{d=1}^nd^3\sum_{i=1}^{[n/d]}\sum_{j=1}^{[n/d]}i*j*[gcd(i,j)==1]$$

接着：

$$\sum_{d=1}^nd^3\sum_{i=1}^{[n/d]}\sum_{j=1}^{[n/d]}i*j\sum_{k|gcd(i,j)}\mu(k)$$

把$\mu(k)$提前

然后：

$$\sum_{d=1}d^3\sum_{k=1}^{[n/d]}\mu(k)*k^2\sum_{i=1}^{[n/kd]}\sum_{i=1}^{[n/kd]}i*j$$

我们记$S(k)$为$(\sum_{i=1}^ki)^2$

我们令$T=k*d$

$$\sum_{T=1}^nT^2*\sum_{k|T}\mu(k)*id(T/d)*S(T)$$

$$\sum_{T=1}^nT^2\phi(T)*S(T)$$

我们知道$f(x)=x^2$和$\phi(x)$是积性函数

那么我们考虑狄利克雷卷积

令$h(x)=T^2*\phi(T)$,我们现在需要一个适合的函数$g(x)$

$$\sum_{i=1}^n(h*g)(i)$$

$$\sum_{i=1}^n\sum_{d|i}h(i)*g(i/d)$$

于是：

$$\sum_{i=1}^n\sum_{T|i}^nT^2*\phi(T)*g(i/T)$$

那么我们需要找到一个合适的$g$

于是猛然发现函数$f(x)=x^2$是个不错的选择

$$\sum_{i=1}\sum_{T|i}\phi(i)*i^2$$

然而：
$$\sum_{i|n}\phi(i)=n$$

∴
=

$$\sum_{i=1}^n(f*g)(i)=\sum_{i=1}i^3$$

又有不知道从哪里知道的：

$$\sum_{i=1}^ni^3=S(n)$$

于是我们达到了目的，在$O(1)$时间内求出卷积

$$\sum_{i=1}(f*g)(i)$$

的值，并且快速求出函数

$$g(x)=x^2$$

的前缀和

还是不知道是在哪离学的:

$$\sum_{i=1}^ni^2=n*(n+1)*(2*n+1)/6$$

其中$S(n)$是前面提到的

于是我们便可以数论分块再套一个杜教筛解决此题

而我还是太菜了，还是只会推一些死的式子

贴一波蒟蒻的代码，好让大佬嘲讽

模数叫remoon，不怕不A题，

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<map>
using namespace std;
#define int long long
const int N = 5000000 ;
int vis[N+1000] , p[N+1000] , phi[N+1000] , sumphi[N+1000] ;
int num , n , remoon , inv ;
map<int ,int> pphi ;
int pow(int a , int b)
{
    int Ans = 1;
    while(b) {
        if(b & 1) Ans = Ans * a % remoon;
        a = a * a % remoon , b >>= 1;
    }
    return Ans;
}
void find(int x)
{
    sumphi[1] = 1 ;
    phi[1] = 1 ;
    vis[1] = 1 ;
    for(int i = 2 ; i <=  x + 10; i++ ){
        if( !vis[i] ) p[++num] = i , phi[i] = i - 1 ;
        for(int j = 1 ; j <=num ; j++ ){
            if( p[j] * i > x + 10 ) break ;
            vis[ i * p[j] ] = 1 ;
            if( i % p[j] == 0 )
            {
                phi[ p[j] * i ] = phi[i] * p[j] ;
                break ;
            }
            phi[ i * p[j] ] = ( p[j] - 1 ) * phi[i] ;
        }
    }
    for(int i = 2 ; i <= x ; i++ ) ( sumphi[i] = ( sumphi[i - 1] + i % remoon * i % remoon * phi[i] % remoon )) %= remoon ;
    return ;
}
int h(int x)
{
    x %= remoon ;
    return x * (x + 1) % remoon * (x + x + 1) % remoon * inv % remoon ;
}
int s(int x)
{
    x %= remoon ;
    return (x * (x + 1) / 2) % remoon * ((x * (x + 1) / 2) % remoon) % remoon; 
}
int get_phisum(int x)
{
    if(x < N) return sumphi[x];
    if(pphi[x]) return pphi[x];
    int Ans = s(x);
    for(int l =  2 , r ; l <= x ; l = r + 1) {
        r = x / (x / l);
        (Ans -= (h(r) - h(l - 1) + remoon) % remoon * get_phisum(x / l) % remoon) %= remoon ;
        //printf("%lld\n" , Sum_Phi(x / l));
    }
    (Ans += remoon) %= remoon;
    return pphi[x] = Ans;
}
signed main()
{
   // freopen("toutput.out","w",stdout) ;
    scanf("%lld%lld" , &remoon , &n ) ;
    inv = pow( 6 , remoon - 2 ) ;
    find(N + 3) ;
    int Ans = 0 ;
    for(int l = 1 , r ; l <= n ; l = r + 1) {
        r = n / (n / l);
        //printf("%lld %lld %lld\n" , Sum_Phi(r) , Sum_Phi(l - 1) , Sum3(n / l));
        (Ans += ( get_phisum(r) - get_phisum(l - 1) + remoon) % remoon * s(n / l) % remoon) %= remoon ;
    }
    
    printf("%lld\n" , ( Ans += remoon ) %= remoon ) ;
    return 0 ;
}
```



最后膜一发zyx：

zyx：我曾经在比赛的时候打了个暴力就过来，后来有人告诉我：这个

其实是可持久化zkw线段树套可持久化平衡树以维护上下凸包并以类似

CDQ分治的方法进行不强制在线的动态快速排序来解决斜率优化加四边

形不等式优化动态dp问题以实现可持久化并查集在对偶图上跑

dijkstra代替原图中用HLPP优化上下界的网络最大流将模数用唯一分

解定理分解后答案用拓展卢卡斯定理求出并用中国剩余定理合并答案

最后使用套欧拉函数和莫比乌斯反演进行一次树上莫队分块再将最后

的答案使用矩阵优化斐波那契数列套快速幂求出还要记得用线性时间

求出逆元。

---

## 作者：封癫 (赞：1)

我刚刚写了一篇超长的[博客](http://www.cnblogs.com/cellular-automaton/p/8241128.html "博客")qwq

不过还是把内容复制一下比较好

我们从最基本的题意开始，一步步往下推


首先题面给出的公式是∑i=1n∑j=1nijgcd(i,j)


枚举gcd(i,j)=w，得到


∑w=1nw∑i=1n∑j=1nij[w=gcd(i,j)]


这时候我们设一个f(x)=∑i=1n∑j=1nij[x=gcd(i,j)]


一个F(x)=∑i=1n∑j=1nij[x|gcd(i,j)]


容易发现（其实就是为了凑莫比乌斯公式才搞的这两个函数，在构造函数之前就“容易发现”了）



　　F(x)=∑x|df(d)

怎么样……像莫比乌斯反演公式吧



　　f(d)=∑d|xμ(xd)F(x)

然后原式就变成了


∑w=1nw∑w|tμ(tw)F(t)


据说莫比乌斯反演构造的F(x)一定要简单易求


然后……自己找几组规律可以发现F(x)=(x+2x+3x+......+nxx)2


然后……继续找规律发现一个问题，就是你可以把x提出来。qwq。


于是F(x)成功的变成了x2(1+2+3+......+nx)2


然后我们回头去找扔掉的原式qwq


原式=∑w=1nw∑w|tμ(tw)F(t)


=∑w=1nw3∑w|tμ(tw)tw2(1+.......+nt)2


emm我们似乎发现了什么……


于是就设d=tw


然后把原式就整理成了


∑w=1nw3∑d=1nwμ(d)d2(1+.......+nwd)2


到此为止就有60分啦。不需要杜教筛狄利克雷卷积什么乱七八糟的玩意。


（然后剩下40分花掉了我一天+22个半小时）


然后我自己差不多就想到这里为止了。剩下的是rqy的脑补。


看到这里面一大堆下取整的玩意我们rqy非常不爽。


然后他先把公式颠倒了一下


∑d=1nμ(d)d2∑w=1ndw3(1+......+nwd)2


又令k=wd


然后改成枚举k


式子就变成了∑k=1n∑d|kμ(kd)(kd)2d3(1+....+nk)2


=∑k=1n∑d|kμ(kd)k2d(1+....+nk)2


发现有两项k2


,(1+....+nk)2

跟d没什么卵关系


提出来提出来


∑k=1nk2(1+....+nk)2∑d|kμ(kd)d


好，恭喜你∑d|kμ(kd)d=ϕ(k)


为什么呢？因为根据狄利克雷卷积公式μ∗1=e


ϕ∗1=n


所以n∗μ=ϕ∗1∗μ=ϕ∗e=ϕ


然后你列一列这个卷积公式。


惊不惊喜？意不意外？


然后原式变成了∑k=1nk2(1+....+nk)2ϕ(k)


然后一看到nk


有根号n种，非常激动，


然后现在的问题就变成了怎么快速求k2ϕ(k)


的前缀和


然后发现这个玩意用杜教筛好像很可做的样子


码了码了


---

## 作者：Smallbasic (赞：0)

先看一下这道题的简化版：

$$\sum_{i=1}^n\sum_{j=1}^n gcd(i,j)$$

由于$gcd$不好处理，考虑把它去掉。

欧拉函数有一个性质：

$$\sum_{d|n}\phi(d)=n$$

代入之后变成：

$$\sum_{i=1}^n\sum_{j=1}^n\sum_{d|gcd(i,j)}\phi(d)$$

交换一下求和符号：

$$\sum_d\phi(d)\sum_{d|i}\sum_{d|j}1$$

化简一下：

$$\sum_{d}\phi(d)\lfloor{m\over d}\rfloor\lfloor{n\over d}\rfloor$$

------------------------------------------

这道题可以用相同的套路得到：

$$\sum_{i=1}^n\sum_{j=1}^n ijgcd(i,j)$$

$$=\sum_{i=1}^n\sum_{j=1}^nij\sum_{k|gcd(i,j)}\phi(k)$$

依然交换求和号：

$$\sum_d\phi(d)\sum_{d|i}\sum_{d|j}ij$$

化简一下即是：

$$=\sum_d d^2\phi(d)\sum_{i=1}^{\lfloor{n\over d}\rfloor}i^3$$

代码的话杜教筛+整除分块就搞定了

---

## 作者：子衿君 (赞：0)

#### luogu P3768 简单的数学题

$$\large \Big(\sum_{i=1}^n\sum_{j=1}^m i*j* gcd(i,j)\Big) mod p$$

枚举$gcd$的取值

$$\large ~~ \sum_{k=1}^n k \sum_{i=1}^n \sum_{j=1}^m i*j [gcd(i,j)==k]$$

$$\large \sum_{k=1}^n k^3 \sum_{i=1}^n \sum_{j=1}^m i*j [gcd(i,j)==k]$$

$$\large \sum_{k=1}^n k^3 \sum_{i=1}^{\lfloor \frac{n}{k} \rfloor} \sum_{j=1}^{\lfloor \frac{m}{k} \rfloor} i*j [gcd(i,j)==1]$$

$$\large  n'=\Big \lfloor \frac{n}{k} \Big\rfloor~~,~~ m'=\lfloor \frac{m}{k} \rfloor$$

$$\large ~f(x)=\sum_{i=1}^{n'} \sum_{j=1}^{m'} i*j [gcd(i,j)==x]$$

$$\large g(x)=\sum_{x|d} f(d) = \sum_{i=1}^{n'} \sum_{j=1}^{m'} i*j [x|gcd(i,j]$$

$$\large = \sum_{i=1}^{\lfloor \frac{n'}{x} \rfloor} \sum_{j=1}^{\lfloor \frac{m'}{x} \rfloor} i*j [1|gcd(i,j)]$$

$$\large = \sum_{i=1}^{\lfloor \frac{n}{kx} \rfloor} \sum_{j=1}^{\lfloor \frac{m}{kx} \rfloor} i*j$$

$$\large \because ~~ \sum_{i=1}^a \sum_{j=1}^b i*j = \frac{ab(a+1)(b+1)}{4}$$

$$\large \therefore ~~ g(x)=\frac { \lfloor \frac{n}{kx} \rfloor \lfloor \frac{m}{kx} \rfloor (\lfloor \frac{n}{kx} \rfloor +1)(\lfloor \frac{m}{kx} \rfloor+1)}{4}$$

这里我们发现这个题目很友好的$n,m$的值一样

$$\large g(x)=\frac {\lfloor \frac{n}{kx} \rfloor^2 (\lfloor \frac{n}{kx} \rfloor+1)^2} {4}$$

$$\large f(x)=\sum_{d=1}^{n'}\mu(d)g(d)$$

$$\large Ans= \sum_{k=1}^n k^3 \sum_{d=1}^{\lfloor\frac{n}{k}\rfloor}\mu(d)g(d)$$

$$ T=kd$$

$$\large Ans=\sum_{T=1}^n \frac {\lfloor \frac{n}{T} \rfloor^2 (\lfloor \frac{n}{T} \rfloor+1)^2} {4} \sum_{k|T} k^3  \mu\Big({\frac{T}{k}}\Big)$$

$$\large Ans=\sum_{T=1}^n sum\Big(\Big\lfloor\frac{n}{k}\Big\rfloor\Big)^2 T^2  \varphi(T)$$

然后对于后面的部分我们考虑杜教筛

$$\large f(x)=x^2  \varphi(x)= \varphi(x)*id^2~~~ ~~g(x)=id^2$$

$$\large (f*g)(n)=\sum_{d|n}( \varphi(d)d^2)\Big(\frac{n}{d} \Big)^2=n^2\sum_{d|n} \varphi(d)=n^3$$


 这个时候，就可以用杜教筛来做了


$$\large \sum_{i=1}^n (f*g)(i)=\sum_{i=1}^n i^3=sum(i)^2$$

~~个人感觉解释非常清楚~~

---

## 作者：Taduro (赞：0)

求$∑_{i=1}^n∑_{j=1}^nijgcd(i,j)$

先上反演套路：
$$
\sum_{i=1}^ni\sum_{j=1}^nj\sum_{d=1}^{n}[gcd(i,j)=d]\times d
$$
整理下式子
$$
\sum_{d=1}^{n}d\sum_{i=1}^{n/d}i\sum_{j=1}^{n/d}j[gcd(i,j)=1]
$$

反演
$$
\sum_{d=1}^{n}d\sum_{i=1}^{n/d}i\times d\sum_{j=1}^{n/d}j\times d\sum_{k|i,k|j}\mu(k)
$$
把k提到前面，枚举k的倍数
$$
\sum_{d=1}^{n}d^3\sum_{k=1}^{n/d}\mu(k)\sum_{i=1}^{n/dk}i\times k\sum_{j=1}^{n/dk}j\times k
$$
枚举T=dk
$$
\sum_{T=1}^n\sum_{d|T}d^3\times (\frac{T}{d})^2\times\mu(\frac{T}{d})\sum_{i=1}^{n/T}i\sum_{j=1}^{n/T}j
$$
整理一下，（中间$k^2$那里有点跳步，不过应该无伤大雅）
$$
\sum_{T=1}^nT^2\sum_{d|T}d\times\mu(\frac{T}{d})\sum_{i=1}^{n/T}i\sum_{j=1}^{n/T}j
$$
这样你就有了一个60分的反演做法，不过如果你像我一样SB的话分数会在10~60不定。

这个式子显然后面整除分块，前面线筛+埃筛筛出$f(T)=T^2\sum_{d|T}d\times \mu(d)$的前缀和即可，是$n\ logn​$的。

但是其实$\sum_{d|T}d\times\mu(\frac{T}{d})$等于欧拉函数，也就是$id*\mu=\phi​$。~~我今天才知道~~

那么你就可以丢掉埃筛的log，$O(n)$做了，好的还是60分。

不过$f(x)=x^2\phi(x)$看起来就可以杜教筛。

上杜教筛公式（h(x)表示卷积的前缀和，g(x)表示杜教筛用的那个函数，s(x)表示f(x)的前缀和）：
$$
g(1)s(n)=\sum_{i=1}^nh(i)-\sum_{i=2}^ng(i)s(\frac{n}{i})
$$
g我们取$id^2$，那么有​
$$
\sum_{i=1}^nh(i)=\sum_{i=1}^n\sum_{d|i}d^2\times\phi(d)\times(\frac{i}{d})^2\\

=\sum_{i=1}^ni^2\times\sum_{d|i}\phi(d)
$$
而你所不知道的是，$\phi*1=id$~~我今天才知道~~

那么
$$
\sum_{i=1}^nh(i)=\sum_{i=1}^ni^3=(\frac{n\times(n+1)}{2})^2
$$
这个东西是个公式，我太菜了，没上过小学，但我会打表：

$1^3=1^2$

$1^3+2^3=9=3^2=(1+2)^2$

$1^3+2^3+3^3=36=6^2=(1+2+3)^2$

$1^3+2^3+3^3+...+n^3=(1+2+3+...+n)^2$

好的那我们只有最后一个问题了，求$\sum_{i=1}^ni^2$，这个我会！！！，是$\frac{n\times\ (n+1)\times (2n+1)}{6}$。

恭喜你，通过了本题。

ps:然而并没有上面说的那么简单，你要小心这些错误：

```c++
for (int i=1; i<=blo; i++) phi[i]=i*i%mod*phi[i]%mod;
```

应该乘上1LL

```c++
ll num=x*(x+1)%mod*inv[2]%mod;
```

换成一般题看起来很正常对吧，但是x范围是1e10，就是说你必须写一个变量加一个%mod

还有，线性筛预处理的阈值开到1e7是最快的，2e6就是个弟弟。

```c++
#include<map>
#include<cmath>
#include<cstdio>
#include<iostream>
#include <tr1/unordered_map>
#define ll long long
using namespace std;
using namespace tr1;
ll n,mod,blo,ans,inv[7],phi[10000011];
int o[10000011],prime[5000010];
inline void euler(){
	o[1]=phi[1]=1;
	for (int i=2; i<=blo; i++){
		if (!o[i]){
			o[i]=1; prime[++prime[0]]=i; phi[i]=i-1;
		}
		for (int j=1; j<=prime[0]&&prime[j]*i<=blo; j++){
			o[i*prime[j]]=1;
			if (i%prime[j]==0){
				phi[i*prime[j]]=phi[i]*prime[j]%mod;
				break;
			}
			phi[i*prime[j]]=phi[i]*phi[prime[j]]%mod;
		}
	}
	for (int i=1; i<=blo; i++) phi[i]=1LL*i*i%mod*phi[i]%mod;
	for (int i=1; i<=blo; i++) phi[i]=(phi[i]+phi[i-1])%mod;
}
unordered_map<ll,ll> m;
ll get_phi(ll x){
	if (x<=blo) return phi[x];
	// puts("ok");
	if (m[x]) return m[x];
	ll num=x%mod*(x+1)%mod*inv[2]%mod; num=num*num%mod;
	ll cl,cr;
	for (ll l=2,r; l<=x; l=r+1){
		r=x/(x/l);
		cl=(2*l-1)%mod*l%mod*(l-1)%mod*inv[6]%mod;
		cr=(2*r+1)%mod*r%mod*(r+1)%mod*inv[6]%mod;
		num=(num-(cr-cl)%mod*get_phi(x/l)%mod)%mod;
	}
	num=(num+mod)%mod; m[x]=num;
	return num;
}
int main(){
	scanf("%lld%lld",&mod,&n);
	blo=1e7; blo=min(blo,n); euler(); inv[1]=1;
	for (int i=2; i<=6; i++) inv[i]=(mod-mod/i)*inv[mod%i]%mod;
	// for (int i=1; i<=n; i++){
	// 	ans=(ans+1LL*phi[i]*sum[n/i]%mod*sum[n/i]%mod)%mod;
	// }
	ll a,b;
	for (ll l=1,r; l<=n; l=r+1){
		r=n/(n/l); ll m=n/l;
		a=(get_phi(r)-get_phi(l-1))%mod,b=(m+1)%mod*m%mod*inv[2]%mod;
		b=b*b%mod; ans=(ans+b*a%mod)%mod;
	}
	printf("%lld\n",(ans+mod)%mod);
	return 0;
}
```

---

## 作者：ニヒル (赞：0)

努力写个最容易懂的题解  
题意是求
$$\sum_{i=1}^{n}\sum_{j=1}^{n}ijgcd(i,j)$$
显然先把gcd枚举一下，假设gcd(i,j)==k
原式就为
$$\sum_{k=1}^{n}k\sum_{i=1}^{n}\sum_{j=1}^{n}ij[gcd(i,j)==k]$$
后面这个式子根据套路可以往外提一下
$$\sum_{k=1}^{n}k^3\sum_{i=1}^{n/k}\sum_{j=1}^{n/k}ij[gcd(i,j)==1]$$
这样子看着一脸可莫比乌斯反演的样子，令
$$f(x)=\sum_{i=1}^{x}\sum_{j=1}^{x}ij[gcd(i,j)==1]$$

根据某引理
$$\sum_{d|x}\mu(d)=[x=1]$$
$$f(x)=\sum_{i=1}^{x}\sum_{j=1}^{x}\sum_{d|gcd(i,j)}\mu(d)$$
换过来枚举d
$$f(x)=\sum_{d=1}^{x}\mu(d)\sum_{d|i}\sum_{d|j}ij$$
后面那玩意可以O(1)算的
$$f(x)=\sum_{d=1}^{x}\mu(d)d^2(1+2+3+...+[\frac{x}{d}])^2$$
反演完了，我们把它代回去
$$\sum_{k=1}^{n}k^3f([\frac{n}{k}])$$
$$\sum_{k=1}^{n}k^3\sum_{d=1}^{n/k}\mu(d)d^2(1+2+3+...+[\frac{n}{kd}])^2$$
令$sum(x)=1+2+3+...+x,g=kd$枚举g,再随便枚举个k
$$\sum_{g=1}^{n}sum(g)^2\sum_{k|g}k^3(\frac{g}{k})^2\mu(\frac{g}{k})$$
有些项可以消掉
$$\sum_{g=1}^{n}sum(g)^2\sum_{k|g}g^2k\mu(\frac{g}{k})$$
显然$g^2$可以提出来
$$\sum_{g=1}^{n}sum(\frac{n}{g})^2g^2\sum_{k|g}k\mu(\frac{g}{k})$$
显然前面可以整除分块  
主要需要快速求出后面的
$$g^2\sum_{k|g}k\mu(\frac{g}{k})$$
这时候狄利克雷卷积就有用了  
常见的几个狄利克雷卷积  
$d=1*1$  
$\sigma=1*id$  
$e=1*\mu$  
$\phi=\mu*id$  
$id=\phi*1$    
$id$表示$f(x)=x$  
显然这里我们需要用的是$\phi=\mu*id$  
卷完以后我们可以得到
$$f(g)=g^2\phi(g)$$
这时候需要计算上面函数的前缀和$s(n)$，那么就是杜教筛的套路
$$g(1)s(n)=\sum_{i=1}^{n}(g*f)(i)-\sum_{i=2}^{n}g(i)s(\frac{n}{i})$$
看看要卷的东西
$$(g*f)(i)=\sum_{d|i}g(d)f(\frac{i}{d}) =\sum_{d|i}g(d)(\frac{i}{d})^2\phi(\frac{i}{d})$$
显然令$g(x)=x^2$就可以把$(\frac{i}{d})^2$消掉
$$i^2\sum_{d|i}\phi(\frac{i}{d})$$
$$1*\phi(i)=id$$
$$i^2\sum_{d|i}\phi(\frac{i}{d})=i^3$$
$$s(n)=\sum_{i=1}^{n}i^3-\sum_{i=2}^{n}i^2s(\frac{n}{i})$$
这个前缀和用杜教筛处理之后，总复杂度是$O(n^{\frac{2}{3}})$

---

## 作者：nekko (赞：0)

大力推式子吧（好麻烦啊……还不如用$\phi$反演）……

$\begin{aligned}\sum_{i=1}^{n}\sum_{j=1}^{n}ij(i,j)&=\sum_{d=1}^{n}d\sum_{i=1}^{n}\sum_{j=1}^{n}ij[(i,j)=d] \\ &=\sum_{d=1}^{n}d^3\sum_{i=1}^{\lfloor \frac{n}{d} \rfloor}\sum_{j=1}^{\lfloor \frac{n}{d} \rfloor}ij\sum_{x \mid (i,j)} \mu(x) \\ &=\sum_{d=1}^{n}d^3\sum_{i=1}^{\lfloor \frac{n}{d} \rfloor}\sum_{j=1}^{\lfloor \frac{n}{d} \rfloor}ij\sum_{x \mid (i,j)} \mu(x) \\ &=\sum_{d=1}^{n}d^3\sum_{x=1}^{\lfloor \frac{n}{d} \rfloor}\mu(x)(\sum_{i=1}^{\lfloor \frac{n}{dx} \rfloor}i)^2x^2\end{aligned}$

设$T=dx$

则

$\begin{aligned}\sum_{i=1}^{n}\sum_{j=1}^{n}ij(i,j)&=\sum_{d=1}^{n}d^3\sum_{x=1}^{\lfloor \frac{n}{d} \rfloor}\mu(x)(\sum_{i=1}^{\lfloor \frac{n}{dx} \rfloor}i)^2x^2 \\&=\sum_{T=1}^{n}(\sum_{i=1}^{\lfloor \frac{n}{T} \rfloor}i)^2\sum_{d|T}d^3\mu(\frac{T}{d})(\frac{T}{d})^2 \\&=\sum_{T=1}^{n}(\sum_{i=1}^{\lfloor \frac{n}{T} \rfloor}i)^2\sum_{d|T}d^3\mu(\frac{T}{d})(\frac{T}{d})^2 \\&=\sum_{T=1}^{n}(\sum_{i=1}^{\lfloor \frac{n}{T} \rfloor}i)^2\sum_{d|T}dT^2\mu(\frac{T}{d}) \\&=\sum_{T=1}^{n}(\sum_{i=1}^{\lfloor \frac{n}{T} \rfloor}i)^2T^2\sum_{d|T}d\mu(\frac{T}{d}) \\&=\sum_{T=1}^{n}(\sum_{i=1}^{\lfloor \frac{n}{T} \rfloor}i)^2T^2 (id \times \mu)(T) \\&=\sum_{T=1}^{n}(\sum_{i=1}^{\lfloor \frac{n}{T} \rfloor}i)^2T^2 \phi(T) \\&=\sum_{T=1}^{n}(\frac{(1+\lfloor \frac{n}{T} \rfloor)\lfloor \frac{n}{T} \rfloor}{2})^2(T^2 \phi(T)) \\\end{aligned}$

不妨对$\lfloor \frac{n}{T} \rfloor$进行数论分块，只需要快速计算$T^2\phi(T)$即可

设$f(n)=n^2\phi(n)$，此时需要找一个$g$，使得$g$和$f \times g$都可以快速计算

不妨设$g(n)=n^2$

则$h(n)=(f \times g)(n)= \sum_{d|n}d^2\phi(d)(\frac{n}{d})^2=n^2 \times (\phi \times 1)(n)=n^2 \times n=n^3$

杜教筛告诉我们，$g(1)F(n)=H(n)-\sum_{d=2}^{n}g(d)F(\lfloor \frac{n}{d} \rfloor)$

即$F(n)=\sum_{i=1}^{n}i^3-\sum_{d=2}^{n}d^2F(\lfloor \frac{n}{d} \rfloor )$

也就是说$F(n)=(\frac{(1+n)n}{2})^2-\sum_{d=2}^{n}d^2F(\lfloor \frac{n}{d} \rfloor)$

同时有$D(n)=\sum_{i=1}^{n}i^2=\frac{n(n+1)(2n+1)}{6}$

---

``` cpp
#include "bits/stdc++.h"
using namespace std;
typedef long long ll;
const int N = 1e7 + 10;
ll n, p, f[N], phi[N], inv2, inv6;
int vis[N], pri[N], tot;

map<ll, ll> mp;

ll sum2(ll n) {
	n %= p;
	return n * (n + 1) % p * inv2 % p;
}

ll sum3(ll n) {
	n %= p;
	return n * (n + 1) % p * (2 * n + 1) % p * inv6 % p;
}

ll F(ll n) {
	if(n <= (int) 1e7) {
		return f[n];
	} else if(mp.find(n) != mp.end()) {
		return mp[n];
	} else {
		ll res = sum2(n); res = res * res % p;
		for(ll i = 2, j ; i <= n ; i = j + 1) {
			j = n / (n / i);
			ll t = (sum3(j) - sum3(i - 1)) % p;
			res = (res - t * F(n / i) % p) % p;
		}
		return mp[n] = res;
	}
}

ll pw(ll a, ll b) {
	ll r = 1;
	for( ; b ; b >>= 1, a = (ll) a * a % p) if(b & 1) r = (ll) r * a % p;
	return r;
}

ll sol(ll n) {
	ll res = 0;
	for(ll i = 1, j ; i <= n ; i = j + 1) {
		j = n / (n / i);
		ll sum = ((1 + n / i) % p) % p * ((n / i) % p) % p * inv2 % p;
		sum = sum * sum % p;
		ll same = (F(j) - F(i - 1)) % p;
		res = (res + sum * same % p) % p;
	}
	return res;
}

int main() {

	scanf("%lld%lld", &p, &n);
	inv2 = pw(2, p - 2), inv6 = pw(6, p - 2);

	phi[1] = 1;
	for(int i = 2 ; i <= (int) 1e7 ; ++ i) {
		if(!vis[i]) {
			pri[++ tot] = i;
			phi[i] = i - 1;
		}
		for(int j = 1 ; j <= tot && (ll) i * pri[j] <= (int) 1e7 ; ++ j) {
			vis[i * pri[j]] = 1;
			if(i % pri[j] == 0) {
				phi[i * pri[j]] = phi[i] * pri[j];
				break;
			} else phi[i * pri[j]] = phi[i] * phi[pri[j]];
		}
	}
	for(int i = 1 ; i <= (int) 1e7 ; ++ i) {
		f[i] = (f[i - 1] + phi[i] * i % p * i % p) % p;
	}

	printf("%lld\n", (sol(n) % p + p) % p);
}
```

---

## 作者：pengyihao (赞：0)


```cpp
\begin{align*}
ans&=\sum_{i=1}^n\sum_{j=1}^nij\gcd(i,j)\\
&=\sum_{d=1}^n d \sum_{d|i}\mu (\frac{i}{d})\sum_{i|j}\sum_{i|k}jk\\
&=\sum_{d=1}^n d \sum_{d|i}\mu (\frac{i}{d})\frac{i^2\lfloor\frac{n}{i}\rfloor^2(1+\lfloor\frac{n}{i}\rfloor)^2}{4}\\
&=\sum_{i=1}^n \frac{i^2\lfloor\frac{n}{i}\rfloor^2(1+\lfloor\frac{n}{i}\rfloor)^2}{4} \sum_{d|i}d\cdot \mu(\frac{i}{d})
\end{align*}
```
因为有 $\mu * id = \varphi$，其中 $*$ 为Dirichlet卷积，即$$\sum_{d|i}\mu(d)\cdot \frac{i}{d}=\varphi(i)$$

则原式为


```cpp
\begin{align*}
&\sum_{i=1}^n \frac{i^2\lfloor\frac{n}{i}\rfloor^2(1+\lfloor\frac{n}{i}\rfloor)^2}{4}\varphi(i)\\
=& \sum_{i=1}^n \frac{\lfloor\frac{n}{i}\rfloor^2(1+\lfloor\frac{n}{i}\rfloor)^2}{4} i^2\cdot \varphi(i)
\end{align*}
```
若能求出 $f(i)=i^2\cdot \varphi(i)$ 的值，即可利用下底函数的分块做到 $O(\sqrt{n} + T(QueryF))$

设 $S(i)=\sum_{j=1}^if(j)$，则



```cpp
\begin{align*}
&\sum_{i=1}^n(f*id^2)(i) \\
=&\sum_{i=1}^ni^3\\
=&\sum_{j=1}^nj^2\cdot S(\lfloor\frac{n}{j}\rfloor)
\end{align*}
```
于是 $$S(n)=\sum_{i=1}^ni^3-\sum_{i=2}^ni^2\cdot S(\lfloor \frac{n}{i}\rfloor)$$

利用线性筛预处理前 $O(n^{\frac{2}{3}})$ 的部分，然后求前缀和的复杂度就只有 $O(n^{\frac{2}{3}})$ 了。


注意 $n$ 比较大，要用到 $O(1)$ 的快速乘。


---


# 文艺数学题

## 题目背景

小Y在AK曼哈顿OI，CTSC和APIO之后，开始研究数学题。


## 题目描述

小Y有一张N个点，M条边的无向图（**可能有重边、自环**），每条边都有一个权值w。


你需要计算：所有**生成树的边权的最大公约数**之和，具体操作见样例。


由于答案可能很大，需要**对1000000007取模**。


## 说明/提示

### 样例1的解释



 ![](https://cdn.luogu.com.cn/upload/pic/13639.png) 

显然，这张图有8个不同的生成树。


用$(x,y,z)$表示x,y,z的最大公约数，则答案


$=(12,6,8)+(6,8,9)+(8,9,12)+(9,12,6)+(9,4,6)+(12,4,8)+(12,4,9)+(6,4,8)$


$=2+1+1+3+1+4+1+2$


$=15$

### 数据范围


对于20%的数据，$N\le 10, M\le 20$；

对于另外10%的数据，$N\le 12, M\le 24$；

对于另外20%的数据，$N\le 60, M\le 3000$，且满足$u_i+1=v_i$；

对于另外20%的数据，$N\le 40, M\le 1000, W\le 1000$；

对于另外15%的数据，$N\le 50, M\le 2000$；

对于所有100%的数据，$N\le 60, M\le 3000, W\le 1000000$；



## 样例 #1

### 输入

```
4 5  
1 2 12  
1 3 9  
2 4 6  
3 4 8  
1 4 4  ```

### 输出

```
15```

# 题解

## 作者：will7101 (赞：13)

## 一句话题意


求无向图的所有生成树的权值gcd之和。


## 20分做法


暴力枚举边的集合，判断是否是生成树，计算gcd并求和。


复杂度$O(N logW 2^M)$


## 30分做法


在20分做法的基础上加一些剪枝，或者用dfs来枚举生成树。


## 50分做法


因为值域不大，考虑枚举gcd的值并进行容斥（反演）。


推式子：


设$f(n)=$权值gcd为n的生成树个数，我们发现$f(n)$不是很好直接计算。


于是设$F(n)=$权值gcd**被n整除**的生成树个数，


显而易见，$F(n)=\sum_{n|d} f(d)$。


而且$F(n)$比较容易得到（可以通过矩阵树定理在$O(N^3)$的时间内计算）。


进行莫比乌斯反演，得到$f(n)=\sum_{n|d} \mu(\frac{d}{n})F(d)$


于是

$ans=\sum_{n=1}^W {n f(n)}$


$=\sum_{n=1}^W {n \sum_{n|d} {\mu(\frac{d}{n})F(d)}}$


$=\sum_{d=1}^W {F(d) \sum_{n|d} {n \mu(\frac{d}{n})}}$


$=\sum_{d=1}^W {F(d) \phi(d)}$


枚举d从1到W，然后加入d整除权值的边，使用矩阵树定理计算F，注意判断生成树个数为0的情况（图不联通）。


复杂度$O(W(M+N^3))$


## 另外20分做法（v=u+1）


注意到生成树都是一条链，不需要使用矩阵树定理，直接利用**乘法原理**计算。


复杂度$O(WM)$


## 100分做法


在50分做法的基础上进一步优化：


注意到很多时候生成数个数为0（图不联通），一个显然的充分条件是**满足条件的边数<N-1**，所以我们可以预先筛掉这些情况。


对于每一条边，只会对它权值的因数d造成影响，然后统计每个数作为因数出现了多少次，小于N-1的不用计算。

对于小于$\sqrt{W}$的因子，它们每个最多出现一次；对于超过$\sqrt{W}$的因子，由于边权不超过$W$，每个边权至多只有一个大因子。所以有效的因子总数最多为$\sqrt{W}+\frac{M}{N-1}$，约为2000。


复杂度$O((\sqrt{W}+\frac{M}{N-1})(M+N^3))$。


---

## 作者：Prean (赞：2)

建议改为 省 选 原 题

题意：求所有生成树的边权 $ \gcd $ 之和。

看到 $ \gcd $ 立刻想反演。
$$ \sum_T\gcd_{e \in T}e_v $$
这里设 $ E=e_v(e \in T) $
$$ \sum_T\gcd_E $$
$$ \sum_T\sum_{d \mid e(e \in E)}\varphi(d) $$
$$ \sum_{d=1}^{\infty}\sum_{T,T \in E(e_v \in E(d \mid e_v))} $$
也就是说只需要求边权为 $ d $ 的倍数的边构成的图的生成树个数即可，使用矩阵树。

稍微剪枝一下，复杂度大概是 $ O(240mn^3+V\log V) $，实测可以通过。
```cpp
#include<cstdio>
#include<vector>
typedef unsigned ui;
const ui M=1e6+5,mod=1e9+7;
ui n,m,mx,top,G[65][65],u[3005],v[3005],pos[M],pri[M],phi[M];std::vector<ui>id[M];
inline ui Add(const ui&a,const ui&b){
	return a+b>=mod?a+b-mod:a+b;
}
inline ui Del(const ui&a,const ui&b){
	return b>a?a-b+mod:a-b;
}
inline ui pow(ui a,ui b){
	ui ans=1;
	for(;b;b>>=1,a=1ull*a*a%mod)if(b&1)ans=1ull*ans*a%mod;
	return ans;
}
inline ui Gauss(){
	ui i,j,k,d,inv,ans(1);
	for(i=1;i^n;++i){
		if(!G[i][i])for(j=i+1;j^n;++j)if(G[j][i]){
			ans=mod-ans;std::swap(G[i],G[j]);break;
		}
		inv=pow(G[i][i],mod-2);ans=1ull*ans*G[i][i]%mod;
		for(j=i+1;j^n;++j)for(d=1ull*(mod-G[j][i])*inv%mod,k=i;k^n;++k)G[j][k]=(G[j][k]+1ull*d*G[i][k])%mod;
	}
	return ans;
}
inline ui Solve(const ui&x){
	ui i,j;
	for(i=1;i^n;++i)for(j=1;j^n;++j)G[i][j]=i^j?mod:0;
	for(i=1;(j=i*x)<=mx;++i)for(ui&x:id[j])++G[u[x]][u[x]],++G[v[x]][v[x]],--G[u[x]][v[x]],--G[v[x]][u[x]];
	return Gauss();
}
signed main(){
	ui i,j,x,S,val,ans;
	scanf("%u%u",&n,&m);
	for(i=1;i<=n;++i)for(j=1;j<=n;++j)G[i][j]=i^j?mod:0;
	for(i=1;i<=m;++i){
		scanf("%u%u%u",u+i,v+i,&val);id[val].push_back(i);if(val>mx)mx=val;
		++G[v[i]][v[i]];++G[u[i]][u[i]];--G[u[i]][v[i]];--G[v[i]][u[i]];
	}
	ans=Gauss();
	for(i=2;i<=mx;++i){
		if(!pos[i])pos[pri[++top]=i]=top,phi[i]=i-1;S=0;
		for(j=1;(x=i*j)<=mx;++j)S+=id[x].size();if(S>=n-1)ans=(ans+1ull*phi[i]*Solve(i))%mod;
		for(j=1;j<=pos[i]&&(x=i*pri[j])<=mx;++j)phi[x]=phi[i]*(pri[j]-((pos[x]=j)!=pos[i]));
	}
	printf("%u",ans);
}
```

---


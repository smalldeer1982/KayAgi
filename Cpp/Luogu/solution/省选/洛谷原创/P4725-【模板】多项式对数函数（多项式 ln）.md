# 【模板】多项式对数函数（多项式 ln）

## 题目描述

给出 $n-1$ 次多项式 $A(x)$，求一个 $\bmod{\:x^n}$ 下的多项式 $B(x)$，满足 $B(x) \equiv \ln A(x)$.

在  $\text{mod } 998244353$  下进行，且 $a_i \in [0, 998244353) \cap \mathbb{Z}$

## 说明/提示

对于 $100\%$ 的数据，$n \le 10^5$.

## 样例 #1

### 输入

```
6
1 927384623 878326372 3882 273455637 998233543```

### 输出

```
0 927384623 817976920 427326948 149643566 610586717```

# 题解

## 作者：Kinesis (赞：41)

### 关于在模意义下当且仅当$[x^0]f(x) = 1$时，$f(x)$有对数多项式的问题

看到题解有一样和我感到疑惑的谷友：

- $[x^0]f(x) \neq 1$时要怎么求？

貌似也没有大佬给一个比较充分的解释，这里就关于这个问题写~~（水）~~一篇博客吧。

> 定理：在模意义下当且仅当$[x^0]f(x) = 1$时，$f(x)$有对数多项式。

证明：

根据微积分的基本运算规则，我们可以用**求导，再积分**的方式求得多项式$f$的对数：$\ln{f(x)} \equiv \int \mathrm{d} \ln f(x) \equiv \int\frac{f'(x)}{f(x)} \mathrm{d} x  \pmod{x^{n}},$其中$\int\frac{f'(x)}{f(x)}dx$是$\frac{f'(x)}{f(x)}$的 **反导函数**，亦称不定积分，其等于$\ln f(x) + c$，$c$为积分常数；由于$\ln f(x)$是已经确定的函数，我们可以确定应用**微积分基本定理**$\ln f(x) = \int_0^x\frac{f'(t)}{f(t)}dt + \ln f(0)$来确定积分常数$c = \ln f(0)$。

我们知道一个数在$\bmod p$下有意义当且仅当该数是有理数，其表示为$\frac{a}{b},(a,b)=1,$且$(b,p) = 1$。由于采用求导再积分的方式来求多项式$f$的对数，对于$a'_ix^i,i>0$的项数来说，系数均是非负整数，故在模$p,$一般$p = 998244353$下必定是有意义的，故是否存在对数多项式，等价于讨论**常数项是否在模p下有意义**。

对于多项式$f(x) = \sum\limits_{i=0}^n a_ix^i,f(0) = a_0$，故积分常数为$c = \ln a_0,a_0\in Z$。

此时再给出一个引理：当$a_0 \neq 1$，$\ln a_0 \notin Q,Q$为有理数。证明：式子$c = \ln a_0 \Leftrightarrow a_0 = e^c,$而对于$\forall c \in Q,e^c \notin Q$，由于底数$e$是**超越数**，故不存在有理数$a_0$使得存在有理数$c$让$e^c$也为有理数，也就是$a_0,c\in Q$时等式不成立。

> 所谓**超越数**是相对于**代数数**来说的。代数数指的是能作为一个整数系数多项式的复根，即当一个数$x_0$为代数数，必存在一个整数多项式$f$满足$f(x_0) = \sum\limits_{i=0}^{n-1}a_ix_0^i = 0$（具体可以看[wikipedia-代数数](https://zh.wikipedia.org/wiki/%E4%BB%A3%E6%95%B8%E6%95%B8)）。而超越数则不能成为任何整数多项式的根。关于自然常数$e$为什么是超越数，链接里有根据[采取希尔伯特的策略来证明e是超越数](https://zh.wikipedia.org/wiki/%E8%B6%85%E8%B6%8A%E6%95%B8#%E7%B0%A1%E8%A6%81%E5%9C%B0%E8%AD%89%E6%98%8E%7F'%22%60UNIQ--postMath-00000046-QINU%60%22'%7F%E6%98%AF%E8%B6%85%E8%B6%8A%E6%95%B8)，有基本高数知识就能理解~~（菜鸡笔者理解了一晚上QAQ）~~。

引理的证明：

由于$e$是超越数，故不存在整数多项式$f$使$f(e) = 0$。我们构造一个整数多项式$f(x) = x^n  - b_0$，$f(e) = e^n - b_0 \neq 0$，引理得证。故只要$[x^0]f(x) \neq 1$，取对数后就不可能是有理数，也就在模意义下不存在啦~（另外得到了Karry老师的帮助，他是用“当原函数的常数项不等于1，其取对数后不收敛”的用语，可以等价于在模下没有意义）。

故对于多项式$f$，当且仅当$[x^0]f(x) = 1$时有对数多项式$\ln f$；指数多项式亦是同理。

---

## 作者：xzyxzy (赞：39)

~~我不知道大家为什么要写这么长~~，当然也不知道为什么大家的这么快

原理就是对两边同时求导
$$G(x)=F(A(x)),F(x)=ln(x)$$
$$G'(x)=F'(A(x))A'(x)=\frac{A'(x)}{A(x)}$$
所以对A求导求个逆就算出了G

然后由于求导和不定积分是互逆的，所以对G求个不定积分就好了

补充一下：

**求导公式**$$x^{a'}=ax^{a-1}$$
**积分公式**$$\int x^adx=\frac{1}{a+1}x^{a+1}$$
详情请见代码中两个函数*Dao()/Jifen()*
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int N=400100;
const int mod=998244353;
int n,m,A[N],B[N],C[N],D[N],F[N],G[N],r[N],l,tt;
int ksm(int a,int k)
{
	int s=1;for(;k;k>>=1,a=1ll*a*a%mod)
	if(k&1) s=1ll*s*a%mod; return s;
}
void Getl(int len)
{
	for(l=1,tt=0;l<=len;l<<=1) tt++;tt--;
	for(int i=0;i<l;i++) r[i]=(r[i>>1]>>1)|((i&1)<<tt);
}
void NTT(int *P,int op)
{
	for(int i=0;i<l;i++) if(i<r[i]) swap(P[i],P[r[i]]);
	for(int i=1;i<l;i<<=1)
	{
		int W=ksm(3,(mod-1)/(i<<1));
		if(op<0) W=ksm(W,mod-2);
		for(int j=0,p=i<<1;j<l;j+=p)
			for(int k=0,w=1;k<i;k++,w=1ll*w*W%mod)
			{
				int X=P[j+k],Y=1ll*P[j+k+i]*w%mod;
				P[j+k]=(X+Y)%mod;P[j+k+i]=((X-Y)%mod+mod)%mod;
			}
	}
	if(op<0) for(int i=0,u=ksm(l,mod-2);i<l;i++) P[i]=1ll*P[i]*u%mod;
}
void GetInv(int *f,int *g,int n)
{
	if(n==1) {g[0]=ksm(f[0],mod-2);return;}
	GetInv(f,g,n>>1); Getl(n);
	for(int i=0;i<n;i++) C[i]=f[i],D[i]=g[i];
	for(int i=n;i<l;i++) C[i]=D[i]=0; NTT(C,1);NTT(D,1);
	for(int i=0;i<l;i++) C[i]=1ll*C[i]*D[i]%mod*D[i]%mod; NTT(C,-1);
	for(int i=0;i<n;i++) g[i]=((2ll*g[i]%mod-C[i])%mod+mod)%mod;
}
void Dao(int *A,int *B,int len)
{
	for(int i=1;i<len;i++) B[i-1]=1ll*i*A[i]%mod;B[len-1]=0;
}
void Jifen(int *A,int *B,int len)
{
	for(int i=1;i<len;i++) B[i]=1ll*A[i-1]*ksm(i,mod-2)%mod;B[0]=0;
}
void Getln(int *f,int *g,int n)
{
	Dao(f,A,n); GetInv(f,B,n);
	Getl(n); NTT(A,1);NTT(B,1);
	for(int i=0;i<l;i++) A[i]=1ll*A[i]*B[i]%mod;
	NTT(A,-1); Jifen(A,g,n);
}
int main()
{
	scanf("%d",&n);
	for(int i=0;i<n;i++) scanf("%d",&F[i]);
	for(m=1;m<=n;m<<=1); Getln(F,G,m);
	for(int i=0;i<n;i++) printf("%d ",G[i]);
}

```
~~广告：[博主有多项式算法题单哦](https://www.cnblogs.com/xzyxzy/)~~

---

## 作者：VenusM1nT (赞：27)

本文收录于：[多项式算法学习笔记](https://venusnero.github.io/2019/03/19/poly_algorithm_note/)。

已知 $F(x)$，要求 $G(x)$ 令 $G(x)\equiv \ln F(x)$。

这个东西其实不难求，我们令函数 $f(x)=\ln(x)$，则原式可以化作：

$$G(x)\equiv f(F(x))\ (\text{mod}\ \ x^n)$$ 

然后两边求导，可以发现 $f(F(x))$ 是个复合函数，复合函数求导公式为 $f(g(x))'=f'(g(x))g'(x)$，所以左右求导之后为：

$$G'(x)=f'(F(x))F'(x)\ (\text{mod}\ \ x^n)$$

此时我们可以想一想 $\ln$ 的求导公式，$\ln'(x)={1\over x}$，所以接着可以化为：

$$G'(x)={F'(x)\over F(x)}\ (\text{mod}\ \ x^n)$$

这个时候你可能要问了：诶多项式除法？你在逗我吗？

当然不是辣……我们刚刚才学多项式的逆元，反正我们不要求商只要求余数，为什么不拿出来用呢？

所以我们只需要将读入的 $F$ 求导作为 $a$，求逆作为 $b$，计算出 $a\times b\ (\text{mod}\ \ 998244353)$，此时求出的是 $G'$，对它求积分就可以得出我们要求的 $G$ 了。

什么？你不会求导和积分？~~em那你为什么要做多项式题~~

给出求导与积分公式如下：

$${x^a}'=ax^{a-1},\quad \int x^{a}dx={1\over a+1}x^{a+1}$$

```cpp
void GetDev(int *f,int *g,int len)
{
    for(int i=1;i<len;i++) g[i-1]=i*f[i]%Mod;
    g[len-1]=0;
}
void GetInvDev(int *f,int *g,int len)
{
    for(int i=1;i<len;i++) g[i]=f[i-1]*QuickPow(i,Mod-2)%Mod;
    g[0]=0;
}
void GetLn(int *f,int *g,int len)
{
    GetDev(f,a,len);
    GetInv(f,b,len);
    lim=1;
    m=0;
    while(lim<(len<<1))
    {
        lim<<=1;
        m++;
    }
    for(int i=1;i<lim;i++) rev[i]=(rev[i>>1]>>1)|((i&1)<<(m-1));
    NTT(a,1);
    NTT(b,1);
    for(int i=0;i<lim;i++) a[i]=a[i]*b[i]%Mod;
    NTT(a,-1);
    GetInvDev(a,g,len);
}
```

---

## 作者：dblark (赞：7)

多项式 Pascal 题解·第四弹

我们来推一波式子：

$$ B(x) \equiv ln(A(x)) $$

$ ln(x) $ 的导数是 $ \frac{1}{x} $，似乎很好处理，我们可以先求导再积分求回来：

$$ B'(x) \equiv ln'(A(x)) A'(x) $$

$$ B'(x) \equiv \frac{1}{A(x)} A'(x) $$

$$ B'(x) \equiv \frac{A'(x)}{A(x)} $$

诶，这里好像出现了多项式除法，我不会怎么办！

然而问题不大，这里只要求余数即可，只需要多项式求逆即可，~~不像多项式除法一样需要翻转。~~

不过由于求导再积分的时候会损失函数的一些信息，我们再看题目：$ a_0 = 1 $，那么结果里面的 $ a_0 $ 也必为 $ 1 $。这个比较显然，可以自己推一下。

所以就好了！~~再次把多项式求逆的板子粘贴一下~~关于多项式求逆，可以看[窝的这篇题解](/blog/dblark/solution-p4238)


```pas
type
  arr = array[0..524287] of longint; //有很多定义都在窝多项式除法的那篇题解里解释过啦，窝在这里就不重复了，可以去看那篇题解（多项式求逆部分代码是完全一样的）
const
  p  = 998244353;
  g  = 3;
  gi = 332748118;
var
  a, b, pow, r: arr;
  n, i: longint;

  procedure swap(var x, y: longint); //日常
  var
    t: longint;
  begin
    t := x;
    x := y;
    y := t;
  end;

  function power(x, y: longint): longint; //日常
  begin
    power := 1;
    while y > 0 do
    begin
      if odd(y) then
        power := int64(power) * x mod p;
      x := sqr(int64(x)) mod p;
      y := y shr 1;
    end;
  end;

  function inv(x: longint): longint; //日常
  begin
    exit(power(x, p - 2));
  end;

  function dev(a: arr; n: longint): arr; //求导
  var
    i: longint;
  begin
    for i := 1 to n do
      a[i - 1] := int64(a[i]) * i mod p;
    a[n] := 0;
    exit(a);
  end;

  function int(a: arr; n: longint): arr; //积分
  var
    i: longint;
  begin
    for i := n + 1 downto 1 do
      a[i] := int64(a[i - 1]) * inv(i) mod p;
    a[0] := 0;
    exit(a);
  end;

  procedure ntt(var a: arr; n, s: longint); //日常
  var
    i, j, k, x, y, w: longint;
  begin
    for i := 0 to n - 1 do
      if i < r[i] then
        swap(a[i], a[r[i]]);
    i := 1;
    while i < n do
    begin
      j := 0;
      if s = 1 then
        w := power(g, (p - 1) div (i shl 1))
      else
        w := power(gi, (p - 1) div (i shl 1));
      pow[0] := 1;
      for k := 1 to i - 1 do
        pow[k] := int64(pow[k - 1]) * w mod p;
      while j < n do
      begin
        for k := 0 to i - 1 do
        begin
          x := a[j + k];
          y := int64(a[i + j + k]) * pow[k] mod p;
          a[j + k] := (x + y) mod p;
          a[i + j + k] := (x - y) mod p;
        end;
        Inc(j, i shl 1);
      end;
      i := i shl 1;
    end;
    if s = -1 then
    begin
      x := inv(n);
      for i := 0 to n - 1 do
        a[i] := (int64(a[i]) * x mod p + p) mod p;
    end;
  end;

  function mul(a, b: arr; n, m: longint): arr; //多项式乘法
  var
    i, l, num: longint;
  begin
    num := 1;
    l := 0;
    while num <= n + m do
    begin
      num := num shl 1;
      Inc(l);
    end;
    for i := 0 to num - 1 do
      r[i] := (r[i shr 1] shr 1) or ((i and 1) shl (l - 1));
    ntt(a, num, 1);
    ntt(b, num, 1);
    for i := 0 to num - 1 do
      mul[i] := int64(a[i]) * b[i] mod p;
    ntt(mul, num, -1);
  end;

  function inv(x: arr; n: longint): arr; //多项式求逆
  var
    t: arr;
    i, l, num: longint;
  begin
    num := 2;
    l := 1;
    inv[0] := inv(x[0]);
    while num <= n shl 1 do
    begin
      num := num shl 1;
      Inc(l);
      for i := 0 to num - 1 do
        r[i] := (r[i shr 1] shr 1) or ((i and 1) shl (l - 1));
      for i := 0 to num shr 1 - 1 do
        t[i] := x[i];
      ntt(inv, num, 1);
      ntt(t, num, 1);
      for i := 0 to num - 1 do
        inv[i] := int64((p + 2 - int64(inv[i]) * t[i] mod p) mod p) * inv[i] mod p;
      ntt(inv, num, -1);
      for i := num shr 1 to num - 1 do
        inv[i] := 0;
    end;
    for i := n + 1 to num shr 1 - 1 do
      inv[i] := 0;
  end;

  function ln(a: arr; n: longint): arr; //多项式对数函数，这才是重点
  var
    i: longint;
  begin
    ln := mul(dev(a, n), inv(a, n), n - 1, n); //A'(i) * (1 / A(i))
    for i := n to 2 * n do //清零数组（误差）
      ln[i] := 0;
    ln := int(ln, n - 1);  //积分回去
  end;                     //然后……就没了

begin                      //主程序，非常简单
  Read(n);
  for i := 0 to n - 1 do
    Read(a[i]);
  b := ln(a, n - 1);
  for i := 0 to n - 1 do
    Write(b[i], ' ');
  writeln;
end.
```

---

## 作者：Gorenstein (赞：5)

给定 $f(x)$，求 $g(x)$ 使得 $g(x)≡\ln f(x)\pmod{x^n}$。

------------
这里有个复合函数，比较难弄，因此可以将其求导然后积分来拆开。

设函数 $h(x)$ 在 $X$ 上定义，且对于任意 $x\in X$，$f(x)=\ln x$。因此

$$
g(x)≡h(f(x))\pmod{x^n}
$$

求导得

$$
g'(x)≡h'(f(x))f'(x)\pmod{x^n}$$

$$
\qquad\;\,≡\frac{f'(x)}{f(x)}\qquad\quad\;\pmod{x^n}
$$

然后积回去

$$
g(x)≡\int\frac{f'(x)}{f(x)}\pmod{x^n}
$$

------------

**$f'(x)$ 可以求导，$\frac{1}{f(x)}$ 可以求逆，因此 $\frac{f'(x)}{f(x)}$ 只须将两者相乘即可得到。最后积分一下就行了！**


求导（得到 $f'(x)$）：

```cpp
void Differential(ll *f,ll *g,ll n){for(ll i=1;i<n;i++)g[i-1]=i*f[i]%mod;g[n-1]=0;}
```

求逆（得到 $\frac{1}{f(x)}$）：

```cpp
void Inv(ll *f,ll *g,ll m){
	if(m==1){g[0]=Quickly_Power(f[0],mod-2);return;}
	Inv(f,g,(m+1)>>1);ll n=1;
	while(n<(m<<1))n<<=1;
	ll invn=Quickly_Power(n,mod-2);
	for(ll i=0;i<n;i++)tr[i]=((tr[i>>1]>>1)|((i&1)?n>>1:0)),w[i]=f[i];
	for(ll i=m;i<n;i++)w[i]=0;
	NTT(w,1,n),NTT(g,1,n);
	for(ll i=0;i<n;i++)g[i]=(2-w[i]*g[i]%mod+mod)*g[i]%mod;
	NTT(g,0,n);
	for(ll i=0;i<m;i++)g[i]=invn*g[i]%mod;
	for(ll i=m;i<n;i++)g[i]=0;
}
```

乘法（得到 $\frac{f'(x)}{f(x)}$）：

```cpp
void Mul(ll *f,ll *g,ll *p,ll n,ll m){
	m+=n,n=1;
	while(n<m)n<<=1;
	for(ll i=0;i<n;i++)tr[i]=((tr[i>>1]>>1)|((i&1)?n>>1:0));
	ll invn=Quickly_Power(n,mod-2);
	NTT(f,1,n),NTT(g,1,n);
	for(ll i=0;i<n;i++)p[i]=f[i]*g[i]%mod;
	NTT(p,0,n);
	for(ll i=0;i<n;i++)p[i]=p[i]*invn%mod;
}
```

求积（得到 $\int\frac{f'(x)}{f(x)}$）：

```cpp
void Integral(ll *f,ll *g,ll n){for(ll i=1;i<n;i++)g[i]=f[i-1]*Quickly_Power(i,mod-2)%mod;g[0]=0;}
```

这就好啦qaq！！！

------------
#### 总结一下

给定 $f(x)$，求 $g(x)$ 使得

$$
g(x)≡\ln f(x)\pmod{x^n}
$$

经过处理之后变为 

$$
g(x)≡\int\frac{f'(x)}{f(x)}\pmod{x^n}
$$

然后分别求导和求逆，乘起来之后积分一下即可。


时间复杂度 $O(n\log n)$，卡进最优解第五页。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;

typedef long long ll;
const ll mod=998244353;
#define G 3
#define MAXN 400040
#define invG 332748118
#define ck(x) ((x)>=mod?(x)-mod:(x))
inline ll read()
{
	ll q=0;char ch=' ';
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')q=(q<<3)+(q<<1)+ch-'0',ch=getchar();
	return q;
}

ll n,tr[MAXN],f[MAXN],g[MAXN],w[MAXN];
ll ff[MAXN],_f[MAXN],_g[MAXN],h[MAXN];
inline ll Quickly_Power(ll a,ll b)
{
	ll ans=1;
	while(b)
	{
		if(b&1)ans=ans*a%mod;
		a=a*a%mod,b>>=1;
	}
	return ans;
}

//快速数论变换
void NTT(ll *f,ll flag,ll n)
{
	for(ll i=0;i<n;i++)
		if(i<tr[i])swap(f[i],f[tr[i]]);
	for(ll p=2;p<=n;p<<=1)
	{
		ll len=(p>>1);
		ll wn=Quickly_Power(flag?G:invG,(mod-1)/p);
		for(ll k=0;k<n;k+=p)
		{
			ll buf=1;
			for(ll i=k;i<k+len;i++)
			{
				ll tmp=buf*f[i+len]%mod;
				f[i+len]=ck(f[i]-tmp+mod);
				f[i]=ck(f[i]+tmp);
				buf=buf*wn%mod;
			}
		}
	}
}

//多项式求逆
void Inv(ll *f,ll *g,ll m)
{
	if(m==1)
	{
		g[0]=Quickly_Power(f[0],mod-2);
		return;
	}
	Inv(f,g,(m+1)>>1);
	ll n=1;
	while(n<(m<<1))n<<=1;
	ll invn=Quickly_Power(n,mod-2);
	for(ll i=0;i<n;i++)
		tr[i]=((tr[i>>1]>>1)|((i&1)?n>>1:0)),w[i]=f[i];
	for(ll i=m;i<n;i++)w[i]=0;
	NTT(w,1,n),NTT(g,1,n);
	for(ll i=0;i<n;i++)
		g[i]=(2-w[i]*g[i]%mod+mod)*g[i]%mod;
	NTT(g,0,n);
	for(ll i=0;i<m;i++)
		g[i]=invn*g[i]%mod;
	for(ll i=m;i<n;i++)g[i]=0;
}

//多项式乘法
void Mul(ll *f,ll *g,ll *p,ll n,ll m)
{
	m+=n,n=1;
	while(n<m)n<<=1;
	for(ll i=0;i<n;i++)
		tr[i]=((tr[i>>1]>>1)|((i&1)?n>>1:0));
	ll invn=Quickly_Power(n,mod-2);
	NTT(f,1,n),NTT(g,1,n);
	for(ll i=0;i<n;i++)
		p[i]=f[i]*g[i]%mod;
	NTT(p,0,n);
	for(ll i=0;i<n;i++)
		p[i]=p[i]*invn%mod;
}

//求导、积分
void Differential(ll *f,ll *g,ll n)
{
	for(ll i=1;i<n;i++)
		g[i-1]=i*f[i]%mod;
	g[n-1]=0;
}
void Integral(ll *f,ll *g,ll n)
{
	for(ll i=1;i<n;i++)
		g[i]=f[i-1]*Quickly_Power(i,mod-2)%mod;
	g[0]=0;
}

//求多项式对数函数（ln）
void Ln(ll *f,ll *g,ll n)
{
	Differential(f,ff,n);
	Inv(f,_f,n);
	Mul(ff,_f,_g,n,n);
	Integral(_g,g,n);
}
int main()
{
	n=read();
	for(ll i=0;i<n;i++)f[i]=read();
	Ln(f,g,n);
	for(ll i=0;i<n;i++)
		printf("%lld ",g[i]);
	return 0;
}
```

---

## 作者：ニヒル (赞：4)

设多项式为$A(x)$现在要求$G(x)=ln(A(x))$  
我们设另一个函数$F(x)=ln(x)$则要求的函数转化成$G(x)=F(A(x))$  
我们求一波导，右边是个复合函数，我们运用复合函数求导的链式法则$G'(x)=F'(A(x))A'(x)$    
然后我们套用求导公式还知道$F'(x)=\frac{1}{x}$  
所以代入一下$G'(x)=\frac{A'(x)}{A(x)}$  
$\frac{1}{A(x)}$可以求逆，多项式求导也不是什么难点$A'(x)=\sum_{i=0}^{n-1} (i+1)\times a_{i+1}x^i$  
之后对$G'(i)$再积下分，就可以求出$G(i)$了，积分是求导的逆运算，怎么积分就不再赘述了  
但是这样子有没有点问题呢？不知道有没有人注意到题面里保证$a_0=1$这句话  
我们求导再积分的过程中是会忽略常数项的，所以我们要把它补回去，可以发现在取模的情况下$ln(1)=0$是唯一比较好算的，所以这题作为模板题钦定了$a_0=1$  

代码如下：
```cpp
#include<bits/stdc++.h>
#define mod 998244353
#define gg 3
using namespace std;

long long x[400040],x1[400040],x2[400040],y[400040],y2[400040];
int r[400040],n,lim,cnt;

long long kasumi(long long a,long long b)
{
	long long ans=1;
	while(b)
	{
		if(b&1) ans=ans*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return ans;
}

void NTT(long long *a,int kd)
{
	for(int i=0;i<lim;i++)
	{
		if(i<r[i]) swap(a[i],a[r[i]]);
	}
	for(int mid=1;mid<lim;mid<<=1)
	{
		long long wn=kasumi(gg,(mod-1)/(mid<<1));
		if(kd) wn=kasumi(wn,mod-2);
		for(int i=0;i<lim;i+=(mid<<1))
		{
			long long w=1;
			for(int j=0;j<mid;j++,w=wn*w%mod)
			{
				long long x=a[i+j];
				long long y=a[i+j+mid]*w%mod;
				a[i+j]=(x+y)%mod;
				a[i+j+mid]=(x-y+mod)%mod;
			}
		}
	}
	if(kd)
	{
		int invl=kasumi(lim,mod-2);
		for(int i=0;i<lim;i++) a[i]=a[i]*invl%mod;
	}
}

void rev(int cnt)
{
	int tmp=1<<cnt;
	for(int i=0;i<tmp;i++)
	{
		r[i]=(r[i>>1]>>1)|((i&1)<<(cnt-1));
	}
}

int main()
{
	scanf("%d",&n);
	for(int i=0;i<n;i++) scanf("%lld",&x[i]);
	for(int i=1;i<n;i++) x1[i-1]=x[i]*i%mod;
	lim=1;
	y[0]=kasumi(x[0],mod-2);
	for(;lim<n*2;)
	{
		cnt++;
		lim<<=1;
		rev(cnt);
		for(int i=0;i<lim>>1;i++)
		{
			x2[i]=x[i];
			y2[i]=y[i];
		}
		NTT(x2,0);NTT(y2,0);
		for(int i=0;i<lim;i++)
		{
			y2[i]=(y2[i]*2ll%mod-x2[i]*y2[i]%mod*y2[i]%mod+mod)%mod;
		}
		NTT(y2,1);
		for(int i=0;i<lim>>1;i++)
		{
			y[i]=y2[i];
		}
	}
	NTT(x1,0);NTT(y,0);
	for(int i=0;i<lim;i++) x1[i]=x1[i]*y[i]%mod;
	NTT(x1,1);
	for(int i=lim-1;i>=1;i--) x1[i]=x1[i-1]*kasumi(i,mod-2)%mod;
	x1[0]=0;
	for(int i=0;i<n;i++) printf("%lld ",x1[i]);
}
```

---

## 作者：Spasmodic (赞：4)

[可能更好的阅读体验](https://www.luogu.com.cn/blog/happydef-blog/duo-xiang-shi-quan-jia-tong-xue-xi-bi-ji)

前置芝士：多项式求导、积分，多项式求逆。
$$G(x)\equiv \ln F(x)\pmod{x^n}$$
两边同时求导
$$G'(x)\equiv \frac{F'(x)}{F(x)}\pmod{x^{n-1}}$$
积回去
$$G(x)\equiv \int \frac{F'(x)}{F(x)}dx\pmod{x^n}$$
over。

复杂度$O(n\log n)$.

核心代码：
```cpp
inline void getln(ll*f,ll*g,ll len){
   getdev(f,a,len);
   getinv(f,b,len);
   mul(a,b,len<<1);
   getinvdev(a,g,len);
   clear(a),clear(b);
}
```
完整版：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll; 
const ll N=100005*3;
ll n,f[N],g[N];
namespace Poly{
	const ll P=998244353,G=3;
	ll lmt,rev[N],a[N],b[N],c[N];
	inline ll qpow(ll a,ll k){
		ll ret=1;
		while(k){
			if(k&1)ret=ret*a%P;
			a=(a*a)%P;
			k>>=1;
		}
		return ret%P;
	}
	inline void init(ll n){
		lmt=1;ll t=0;
		while(lmt<n)lmt<<=1,t++;
		for(ll i=1;i<lmt;i++)rev[i]=(rev[i>>1]>>1)|(i&1)<<(t-1);
	}
	inline void NTT(ll *A,ll lmt,ll tp){
		for(ll i=0;i<lmt;i++)if(i<rev[i])swap(A[i],A[rev[i]]);
		for(ll m=1;m<lmt;m<<=1)
			for(ll j=0,Wn=qpow(G,(P-1)/(m<<1));j<lmt;j+=m<<1)
				for(ll k=0,w=1,x,y;k<m;k++,w=w*Wn%P)
					x=A[j+k],y=w*A[j+k+m]%P,A[j+k]=(x+y)%P,A[j+k+m]=(x-y+P)%P;
		if(tp==1)return;
		reverse(A+1,A+lmt);
		for(ll i=0,inv=qpow(lmt,P-2);i<=lmt;i++)A[i]=A[i]*inv%P;
	} 
	inline void mul(ll *f,ll *g,ll len){
		init(len);
		NTT(f,lmt,1);NTT(g,lmt,1);
		for(ll i=0;i<lmt;i++)f[i]=(f[i]*g[i])%P;
		NTT(f,lmt,-1);
	} 
	void getinv(ll*f,ll*g,ll len){
		if(len==1){g[0]=qpow(f[0],P-2);return;}
		getinv(f,g,len+1>>1);
		init(len<<1);
		for(ll i=0;i<len;i++)c[i]=f[i];
		for(ll i=len;i<lmt;i++)c[i]=0;
		NTT(c,lmt,1),NTT(g,lmt,1);
		for(ll i=0;i<lmt;i++)g[i]=(2LL-g[i]*c[i]%P+P)%P*g[i]%P;
		NTT(g,lmt,-1);
		for(ll i=len;i<lmt;i++)g[i]=0; 
	}
	void getdev(ll*f,ll*g,ll len){
		for(ll i=1;i<len;i++)g[i-1]=i*f[i]%P;
		g[len-1]=0;
	}
	void getinvdev(ll*f,ll*g,ll len){
		for(ll i=1;i<len;i++)g[i]=f[i-1]*qpow(i,P-2)%P;
		g[0]=0;
	}
	void getln(ll*f,ll*g,ll len){
		memset(a,0,sizeof(a));
		memset(b,0,sizeof(b));
		getdev(f,a,len);
		getinv(f,b,len);
		mul(a,b,len<<1);
		getinvdev(a,g,len);
	}
}
using Poly::getln;
int main(){
	scanf("%lld",&n);
	for(ll i=0;i<n;i++)scanf("%lld",&f[i]);
	getln(f,g,n);
	for(ll i=0;i<n;i++)printf("%lld ",g[i]);
	return 0;
}
```

---

## 作者：Gauss0320 (赞：4)

模板题，我们知道
$$\ln F(x)=∫F'(x)F^{-1}(x)\ \text{d}x$$
由指数函数的求导公式
$$(x^{\alpha})'=\alpha x^{\alpha-1}$$
$$∫x^{\alpha}\ \text{d}x=\frac{x^{\alpha+1}}{\alpha+1}$$
我们令
$$F(x)=\sum_{i=1}^{n}a_ix^i$$
$$n=\text{Deg}(F)$$
于是有
$$F'(x)=\sum_{i=1}^ni\cdot a_ix^{i-1}$$
$$∫F(x)\ \text{d}x=\sum_{i=1}^na_i\frac{x^{i+1}}{i+1}$$

- 求导函数可以参考程序$\rm derivative$段

- 求不定积分可以参考程序$\rm inter$段

剩下的就是多项式求逆了.
```cpp
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;
const int N = 1<<20;

int read() {
	int x = 0, f = 1; char c = getchar();
	while(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}
	while(c >= '0' && c <= '9') x = (x<<1) + (x<<3) + c - '0', c = getchar();
	return x * f;
}
namespace Polynomial
{
	const ll P = 998244353, g = 3, gi = 332748118;
	static int rev[N];
	int lim, bit;
	ll add(ll a, ll b)
	{
		return (a += b) >= P ? a - P : a;
	}
	ll qpow(ll a, ll b) 
	{
		ll prod = 1;
		while(b)
		{
			if(b & 1) prod = prod * a % P;
			a = a * a % P;
			b >>= 1;
		}
		return (prod + P) % P;
	}
	void calrev() {
		for(int i = 1; i < lim; i++)
			rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (bit - 1));
	}
	void NTT(ll *A, int inv) 
	{
		for(int i = 0; i < lim; i++)
			if(i < rev[i]) swap(A[i], A[rev[i]]);
		for(int mid = 1; mid < lim; mid <<= 1) 
		{
			ll tmp = qpow(inv == 1 ? g : gi, (P - 1) / (mid << 1));
			for(int j = 0; j < lim; j += (mid << 1)) 
			{
				ll omega = 1;
				for(int k = 0; k < mid; k++, omega = (omega * tmp) % P) 
				{
					int x = A[j + k], y = omega * A[j + k + mid] % P;
					A[j + k] = (x + y) % P;
					A[j + k + mid] = (x - y + P) % P;
				}
			}
		}
		if(inv == 1) return;
		int invn = qpow(lim, P - 2);
		for(int i = 0; i < lim; i++)
			A[i] = A[i] * invn % P;
	}
	static ll x[N], y[N];
	void mul(ll *a, ll *b)
	{
		memset(x, 0, sizeof x);
		memset(y, 0, sizeof y);
		for(int i = 0; i < (lim >> 1); i++)
			x[i] = a[i], y[i] = b[i];
		NTT(x, 1), NTT(y, 1);
		for(int i = 0; i < lim; i++)
			x[i] = x[i] * y[i] % P;
		NTT(x, -1);
		for(int i = 0; i < lim; i++)
			a[i] = x[i];
	}
	static ll c[2][N];
	void Inv(ll *a, int n) 
	{
		int p = 0;
		memset(c, 0, sizeof c);
		c[0][0] = qpow(a[0], P - 2);
		lim = 2, bit = 1;
		while(lim <= (n << 1))
		{
			lim <<= 1, bit++;
			calrev();
			p ^= 1;
			memset(c[p], 0, sizeof c[p]);
			for(int i = 0; i <= lim; i++)
				c[p][i] = add(c[p^1][i], c[p^1][i]);
			mul(c[p^1], c[p^1]);
			mul(c[p^1], a);
			for(int i = 0; i <= lim; i++)
				c[p][i] = add(c[p][i], P - c[p^1][i]);
		}
		for(int i = 0; i < lim; i++)
			a[i] = c[p][i];
	}
	void derivative(ll *a, int n)
	{
		for(int i = 1; i <= n; i++)
			a[i - 1] = a[i] * i % P;
		a[n] = 0;
	}
	void inter(ll *a, int n)
	{
		for(int i = n; i >= 1; i--)
			a[i] = a[i - 1] * qpow(i, P - 2) % P;
		a[0] = 0;
	}
	ll b[N];
	void ln(ll *a, int n) 
	{
		memcpy(b, a, sizeof b);
		Inv(b, n), derivative(a, n);
		while(lim <= (n << 2)) lim <<= 1, bit++;
		calrev();
		mul(a, b);
		inter(a, n);
		for(int i = n + 1; i <= lim; i++)
			a[i] = 0;
	}
}
using namespace Polynomial;
int n;
ll F[N];
int main()
{
	n = read();
	for(int i = 0; i < n; i++)
		F[i] = read();
	lim = 2, bit = 1;
	while(lim <= (n<<1)) lim <<= 1, bit++;
	ln(F, n);
	for(int i = 0; i < n; i++)
		printf("%d ", F[i]);
	return 0;		
}
```


---

## 作者：Great_Influence (赞：2)

模板，直接使用多项式$Ln$即可。
你可以看看[这个](https://www.luogu.org/blog/user7035/duo-xiang-shi-zong-jie)。

多项式$Ln$利用以下公式:

$$LnF=\int \frac{F'}{F}\mathbb{d}x=\int F'F^{-1}\mathbb{d}x$$

直接使用多项式求逆+多项式积分求导即可。时间复杂度$O(nlogn)$。

代码:

```
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/priority_queue.hpp>
#define For(i,a,b) for(i=(a);i<=(b);++i)
#define Forward(i,a,b) for(i=(a);i>=(b);--i)
#define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
#define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
using namespace std;
template<typename T>inline void read(T &x){
    T s=0,f=1;char k=getchar();
    while(!isdigit(k)&&k^'-')k=getchar();
    if(!isdigit(k)){f=-1;k=getchar();}
    while(isdigit(k)){s=s*10+(k^48);k=getchar();}
    x=s*f;
}
void file(void){
    freopen("polynomial.in","r",stdin);
    freopen("polynomial.out","w",stdout);
}
const int MAXN=1<<22;

typedef long long ll;

namespace polynomial 
{
    static int mod=998244353,gen=3,g[21],rev[MAXN],Len;

    inline int ad(int a,int b){return (a+=b)>=mod?a-mod:a;}

    inline int power(int a,int b)
    {
        static int sum;
        for(sum=1;b;b>>=1,a=(ll)a*a%mod)if(b&1)
            sum=(ll)sum*a%mod;
        return sum;
    }

    inline void predone()
    {
        static int i,j;
        for(i=1,j=2;i<=20;++i,j<<=1)g[i]=power(gen,(mod-1)/j);
    }

    inline void calrev(int Len)
    {
        static int Logl;Logl=(int)floor(log(Len)/log(2)+0.3)-1;
        Rep(i,1,Len-1)rev[i]=(rev[i>>1]>>1)|((i&1)<<Logl);
    }

    inline void NTT(int X[],int typ)
    {
        Rep(i,1,Len-1)if(i<rev[i])swap(X[i],X[rev[i]]);
        static int i,j,k,kk,w,t,wn,r;
        for(k=2,kk=1,r=1;k<=Len;k<<=1,kk<<=1,++r)
        {
            wn=g[r];
            for(i=0;i<Len;i+=k)for(j=0,w=1;j<kk;++j,w=(ll)w*wn%mod)
            {
                t=(ll)w*X[i+j+kk]%mod;
                X[i+j+kk]=ad(X[i+j],mod-t);
                X[i+j]=ad(X[i+j],t);
            }
        }
        if(typ==-1)
        {
            reverse(X+1,X+Len);
            static int invn;invn=power(Len,mod-2);
            Rep(i,0,Len-1)X[i]=(ll)X[i]*invn%mod;
        }
    }

    static int x[MAXN],y[MAXN];
    inline void mul(int a[],int b[])
    {
        memset(x,0,sizeof x);memset(y,0,sizeof y);
        Rep(i,0,(Len>>1)-1)x[i]=a[i],y[i]=b[i];
        NTT(x,1);NTT(y,1);
        Rep(i,0,Len-1)x[i]=(ll)x[i]*y[i]%mod;
        NTT(x,-1);
        Rep(i,0,Len-1)a[i]=x[i];
    }
    
    static int c[2][MAXN];
    
    inline void Inv(int a[],int n)
    {
        static int t;t=0;
        memset(c,0,sizeof c);
        c[0][0]=power(a[0],mod-2);
        Len=2;
        while(Len<=(n<<1))
        {
            Len<<=1;calrev(Len);t^=1;
            memset(c[t],0,sizeof c[t]);
            Rep(i,0,Len)c[t][i]=ad(c[t^1][i],c[t^1][i]);
            mul(c[t^1],c[t^1]);mul(c[t^1],a);
            Rep(i,0,Len)c[t][i]=ad(c[t][i],mod-c[t^1][i]);
        }
        Rep(i,0,Len-1)a[i]=c[t][i];
    }
    
    static int sq[2][MAXN];

    inline void Sqrt(int *a,int n)
    {
        static int t,z;t=0;
        memset(sq,0,sizeof sq);
        sq[0][0]=sqrt(a[0]);
        Len=z=2;
        while(z<=(n<<1))
        {
            z<<=1;t^=1;
            memset(sq[t],0,sizeof sq[t]);
            Rep(i,0,z)sq[t][i]=sq[t^1][i],sq[t^1][i]=ad(sq[t^1][i],sq[t^1][i]);
            calrev(Len=z);
            mul(sq[t],sq[t]);
            Rep(i,0,z)sq[t][i]=ad(sq[t][i],a[i]);
            Inv(sq[t^1],z>>1);
            calrev(Len=z);
            mul(sq[t],sq[t^1]);
        }
        Rep(i,0,n)a[i]=sq[t][i];
    }

    static int X[MAXN],Y[MAXN];

    inline void Div(int *a,int n,int *b,int m)
    {
        memcpy(X,a,sizeof X);memcpy(Y,b,sizeof Y);
        reverse(b,b+m+1);reverse(X,X+n+1);
        Rep(i,n-m+1,n)X[i]=0;
        Inv(b,n-m+1);
        while(Len<=(n<<2))Len<<=1;
        calrev(Len);
        mul(X,b);reverse(X,X+n-m+1);
        Rep(i,n-m+1,n)X[i]=0;
        mul(Y,X);
        Rep(i,0,m-1)b[i]=ad(a[i],mod-Y[i]);
        memcpy(a,X,sizeof X);
    }

    inline void Direv(int *a,int n)
    {Rep(i,1,n)a[i-1]=(ll)a[i]*i%mod;a[n]=0;}
    
    inline void Inter(int *a,int n)
    {Repe(i,n,1)a[i]=(ll)a[i-1]*power(i,mod-2)%mod;a[0]=0;}

    inline void Ln(int *a,int n)
    {
        memcpy(X,a,sizeof X);
        Inv(X,n);Direv(a,n);
        while(Len<=(n<<2))Len<<=1;
        calrev(Len);
        mul(a,X);
        Inter(a,n);
        Rep(i,n+1,Len)a[i]=0;
    }

    static int T[MAXN],K[MAXN];

    inline void Exp(int *a,int n)
    {
        static int t,z;t=0;
        memset(K,0,sizeof K);K[0]=1;
        Len=z=2;
        while(z<=(n<<1))
        {
            z<<=1;t^=1;
            Rep(i,0,(z>>1)-1)T[i]=K[i];
            Ln(T,(z>>1)-1);
            Rep(i,0,(z>>1)-1)T[i]=ad(a[i]+(i==0),mod-T[i]);
            calrev(Len=z);
            mul(K,T);
            Rep(i,z,z<<1)K[i]=T[i]=0;
        }
        Rep(i,0,n)a[i]=K[i];
    }
}
using namespace polynomial;

static int n,F[MAXN];

int main(void){
//    file();
    predone();
    read(n);
    Rep(i,0,n-1)read(F[i]);
    Len=2;
    while(Len<=n<<1)Len<<=1;
    Ln(F,n);
    Rep(i,0,n-1)printf("%d ",F[i]);
//	cerr<<1.0*clock()/CLOCKS_PER_SEC<<endl;
    return 0;
}
```

---

## 作者：bztMinamoto (赞：1)

前置芝士：微积分（有所了解即可）（可以看看[这篇](https://blog.csdn.net/u010182633/article/category/6303247/2)，写得非常详细我看了两章就看不下去了）

以下都是一些简单的教程切莫当真，仅供理解，建议看更严谨的

导数：对于一个函数$f(x)$，它的导数$f'(x)$为一个新的函数。简单理解的话，$f'(x)$表示在原函数图像上该点切线的斜率，记为$\frac{dy}{dx}$或$\frac{d}{dx}f(x)$

积分：对于一个导数$f'(x)$，它所对应的原函数为它的积分，记为$\int f'(x)dx$

对于一个多项式$F(x)=\sum_{i=0}^na_ix^i$来说（一个多项式实际上可以看做一个函数），它的导数和积分如下
$$F'(x)=\sum_{i=1}^nia_ix^{i-1}$$
$$\int F(x)=\sum_{i=1}^n\frac{a_ix^{i+1}}{i+1}$$

这两个是可以$O(n)$计算的，可以互相转换

然后我们要计算$ln\ F$，首先因为$ln'(x)=\frac{1}{x}$，而这里是一个多项式，根据链式法则（我也不知道什么东西），$\frac{dy}{dx}=\frac{dy}{du}\frac{du}{dx}$，然后把$F(x)$带进去，得$$\frac{d}{dx}ln(F(x))=\frac{d}{dF(x)}ln(F(x))\frac{dF(x)}{dx}$$
$$\frac{d}{dx}ln(F(x))=\frac{1}{F}F'$$
$$ln(F(x))\equiv \int F'F^{-1}\pmod{x^n}$$
求导和积分的运算代码挺短的……然后剩下的基本就是多项式板子了
```
//minamoto
#include<iostream>
#include<cstdio>
#include<algorithm>
#define swap(x,y) (x^=y,y^=x,x^=y)
#define mul(x,y) (1ll*x*y%P)
#define add(x,y) (x+y>=P?x+y-P:x+y)
#define dec(x,y) (x-y<0?x-y+P:x-y)
using namespace std;
#define getc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
inline int read(){
    #define num ch-'0'
    char ch;bool flag=0;int res;
    while(!isdigit(ch=getc()))
    (ch=='-')&&(flag=true);
    for(res=num;isdigit(ch=getc());res=res*10+num);
    (flag)&&(res=-res);
    #undef num
    return res;
}
char sr[1<<21],z[20];int K=-1,Z;
inline void Ot(){fwrite(sr,1,K+1,stdout),K=-1;}
inline void print(int x){
    if(K>1<<20)Ot();if(x<0)sr[++K]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++K]=z[Z],--Z);sr[++K]=' ';
}
const int N=400005,P=998244353;
inline int ksm(int a,int b){
	int res=1;
	while(b){
		if(b&1) res=mul(res,a);
		a=mul(a,a),b>>=1;
	}
	return res;
}
int n,r[N],A[N],B[N],C[N],D[N],F[N],G[N],O[N];
void NTT(int *A,int type,int len){
	int limit=1,l=0;
	while(limit<len) limit<<=1,++l;
	for(int i=0;i<limit;++i)
	r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));
	for(int i=0;i<limit;++i)
	if(i<r[i]) swap(A[i],A[r[i]]);
	for(int mid=1;mid<limit;mid<<=1){
		int R=mid<<1,Wn=ksm(3,(P-1)/R);O[0]=1;
		for(int j=1;j<limit;++j) O[j]=mul(O[j-1],Wn);
		for(int j=0;j<limit;j+=R){
			for(int k=0;k<mid;++k){
				int x=A[j+k],y=mul(O[k],A[j+k+mid]);
				A[j+k]=add(x,y),A[j+k+mid]=dec(x,y);
			}
		}
	}
	if(type==-1){
		reverse(A+1,A+limit);
		for(int i=0,inv=ksm(limit,P-2);i<limit;++i)
		A[i]=mul(A[i],inv);
	}
}
void Inv(int *a,int *b,int len){
	if(len==1) return (void)(b[0]=ksm(a[0],P-2));
	Inv(a,b,len>>1);int l=len<<1;
	for(int i=0;i<len;++i) C[i]=a[i],D[i]=b[i];
	NTT(C,1,l),NTT(D,1,l);
	for(int i=0;i<l;++i) C[i]=mul(mul(C[i],D[i]),D[i]);
	NTT(C,-1,l);
	for(int i=0;i<len;++i) b[i]=dec(add(b[i],b[i]),C[i]);
}
void Direv(int *A,int *B,int len){
	//求导
	for(int i=1;i<len;++i) B[i-1]=mul(A[i],i);B[len-1]=0; 
}
void Inter(int *A,int *B,int len){
	//积分
	for(int i=1;i<len;++i) B[i]=mul(A[i-1],ksm(i,P-2)),B[0]=0; 
}
void Ln(int *a,int *b,int len){
	Direv(a,A,len),Inv(a,B,len);int l=len<<1;
	NTT(A,1,l),NTT(B,1,l);
	for(int i=0;i<l;++i) A[i]=mul(A[i],B[i]);
	NTT(A,-1,l),Inter(A,b,len);
}
int main(){
//	freopen("testdata.in","r",stdin);
	n=read();
	for(int i=0;i<n;++i) F[i]=read();
	int len;for(len=1;len<n;len<<=1);
	Ln(F,G,len);
	for(int i=0;i<n;++i) print(G[i]);
	Ot();
	return 0;
}
```

---

## 作者：Terac (赞：0)

前置知识：求导与积分。  

求导公式
$$x^{a'}=ax^{a-1}$$
不定积分公式
$$\int x^adx=\dfrac{1}{a+1}x^{a+1}$$
然后开始推式子。
$$G(x)\equiv \ln(F(x))(\bmod\ x^n)$$
令 
$$f(x)=\text{ln}(x)$$
$$G(x)\equiv f(F(x))(\bmod\ x^n)$$  

观察发现这是个复合函数，两边求导得
$$G(x)'\equiv f'(F(x))F'(x)(\bmod\ x^n)$$
由 $\text{ln}'(x)=\frac{1}{x}$ 得
$$G'(x)\equiv \dfrac{F'(x)}{F(x)}(\bmod\ x^n)$$

两边再积起来
$$\therefore \int G'(x)\equiv\int\dfrac{F'(x)}{F(x)}(\bmod\ x^n)$$
$$\therefore G(x)\equiv\int\dfrac{F'(x)}{F(x)}(\bmod\ x^n)$$
多项式求逆即可，时间复杂度 $O(n\log n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace IO {
	//read and write
} using namespace IO;
const int N = 2.7e5 + 10;
namespace Polynomial {
	const int P = 998244353, G = 3, Gi = 332748118, inv2 = 499122177;
	int lim, rev[N], a[N], b[N], c[N], d[N], e[N], f[N];
	int qpow(int n, int k) {
		int res = 1;
		for(; k; n = 1ll * n * n % P, k >>= 1)
			if(k & 1) res = 1ll * res * n % P;
		return res;
	}
	void NTT(int *f, int T) {
		for(int i = 0; i < lim; i++)
			if(i < rev[i]) 
				swap(f[i], f[rev[i]]);
		for(int mid = 1; mid < lim; mid <<= 1) {
			int wn = qpow(T == 1 ? G : Gi, (P - 1) / (mid << 1));
			int len = mid << 1;
			for(int i = 0; i < lim; i += (mid << 1)) {
				int w = 1;
				for(int j = 0; j < mid; j++, w = 1ll * w * wn % P) {
					int x = f[i + j], y = 1ll * w * f[i + j + mid] % P;
					f[i + j] = (x + y) % P;
					f[i + j + mid] = (x - y + P) % P;
				}
			}
		}
		if(T == -1) {
			int inv = qpow(lim, P - 2);
			for(int i = 0; i < lim; i++) 
				f[i] = 1ll * f[i] * inv % P;
		}
	}
	void init(int n) {
		for(lim = 1; lim < n; lim <<= 1);
		for(int i = 0; i < lim; i++)
			rev[i] = (rev[i >> 1] >> 1) | ((i & 1) * (lim >> 1));
	} 
	void mul(int *f, int *g, int *h, int n, int m) {
		static int a[N], b[N];
		init(n + m - 1);
		memset(a, 0, lim << 2);
		memcpy(a, f, n << 2);
		memset(b, 0, lim << 2);
		memcpy(b, g, m << 2);
		NTT(a, 1), NTT(b, 1);
		for(int i = 0; i < lim; i++) 
			h[i] = 1ll * a[i] * b[i] % P;
		NTT(h, -1);
	}
	void inv(int *f, int *g, int n) {
		if(n == 1) { g[0] = qpow(f[0], P - 2); return; }
		inv(f, g, n + 1 >> 1);
		init(n << 1);
		copy(f, f + n, a);
		fill(a + n, a + lim, 0);
		NTT(a, 1), NTT(g, 1);
		for(int i = 0; i < lim; i++)
			g[i] = (2 - 1ll * a[i] * g[i] % P + P) % P * g[i] % P;
		NTT(g, -1);
		fill(g + n, g + lim, 0);
	}
	void dev(int *f, int *g, int n) {
		for(int i = 1; i < n; i++)
			g[i - 1] = 1ll * i * f[i] % P;
		g[n - 1] = 0;
	}
	void invdev(int *f, int *g, int n) {
		for(int i = n - 1; i; i--)
			g[i] = 1ll * f[i - 1] * qpow(i, P - 2) % P;
		g[0] = 0;
	}
	void ln(int *f, int *g, int n) {
		static int a[N];
		init(n << 1);
		memset(a, 0, n << 2);
		inv(f, a, n);
		dev(f, g, n);
		mul(g, a, g, n, n);
		invdev(g, g, n);
	}
}
using Polynomial::ln;
int n, f[N], g[N];
int main() {
	n = read();
	for(int i = 0; i < n; i++) f[i] = read();
	ln(f, g, n);
	for(int i = 0; i < n; i++) write(g[i]), putc(' ');
	flush();
	return 0;
}
```


---

## 作者：feicheng (赞：0)

## $\mathtt{Description}$

给 $\deg = n$ 的多项式 $f$，求一多项式 $g$，使 $g= \ln f$。

对 $998244353$ 取模。

$\mathtt{restrictions:}1\le n \le 10^5$。

## $\mathtt{Solution}$

$\ln$ 显然是不好求的，我们思考如何转化。

考虑求导:$\ln (x)'=\dfrac 1 x$

$$\because g = \ln f(x)$$

由复合函数的求导法则：
$$g(f(x))'=g'(f(x))f'(x)$$
可得

$$ g' = \frac {f'(x)} {f(x)}$$

求出 $f$ 的导数和逆元，相乘可得 $g'$，对 $g'$ 积分可得 $g$。

求导和积分公式：

$$f(x)=x^n,f'(x)=nx^{n-1},\int x^n \text{dx}=\dfrac{1}{n+1}x^{n+1}$$

## $\mathtt{Code}$

```cpp
//函数参数含义：
//dev(f,g,len) 求 f 的导数，结果为 g
//itg(f,g,len) 求 f 的积分，结果为 g
//Getln(f,g,len) 求 f 的 ln，结果为 g
//Getinv(f,g,len) 求 f 的逆元，结果为 g
//mul(f,g,r,len) 求 f 和 g 的卷积，结果为 r
//上述 len 表示在模 x^len 意义下进行
	inline void dev(const int f[],int g[],const int len) {
		for (int i = 1; i < len; ++i) g[i-1] = 1ll * f[i] * i % mod ;
		g[len-1] = 0  ;
	}

	inline void itg(const int f[],int g[],const int len) {
		for (int i = 1; i < len; ++i) g[i] = 1ll * f[i-1] * inv[i] % mod ;
		g[0] = 0 ; 
	}

	inline void Getln(const int f[],int g[],const int len) {
		static int A[N],B[N] ;
		dev(f,A,len),Getinv(f,B,len),mul(A,B,A,len<<1),itg(A,g,len),memset(A,0,len<<2),memset(B,0,len<<2);
	}

```

---

## 作者：Illusory_dimes (赞：0)

### 题目大意
给定 $n-1$ 次多项式 $g(x)$ ，求多项式 $f(x)$ 满足：

$f(x)\equiv\ln_{}{g(x)}$ $(mod$ $x^n)$

系数对 $998244353$ 取模。

数据范围 $n\leq 10^5$ 。

### solution
前置芝士：

多项式求逆，~~非常入门的~~求导，积分 。

第一个不会出门左拐，后两个的话，这里只要：

求导公式 $\mathrm{d}$ $x^{a}=ax^{a-1}$ 。

求导法则 $\mathrm{d}$ $f[g(x)]=f^{'}[g(x)]\cdot g^{'}(x)$ 。

积分公式 $\int x^a=\frac{1}{a+1}x^{a+1}$ 。

对于多项式刚刚杠到这题的我们来说， $\ln$ 实在有点陌生。

但是聪明的你一定注意到了 $\ln_{}{x}$ 求导后 $\Longrightarrow \large\frac{1}{x}$ 。

所以愉快的推柿子只有一行！

$f(x)\equiv\ln_{}{g(x)}$ $(mod$ $x^n)$

$f^{'}(x)\equiv\Large\frac{g^{'}(x)}{g(x)}$ $(mod$ $x^n)$

完了，

珂以先求一下 $f^{'}(x)$ ，再积分回去就好了。

时间复杂度 $O(n\log_{2}{n})$ 。

人傻常熟大 wtcl 。。
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=4e5+10;
typedef ll arr[N];
const int mod=998244353;
const int inv3=332748118;
int n,inv,lim=1,fre,id[N];
arr f,g,ans,tmp;
inline ll inc(ll x,ll y){return x+y>=mod?x+y-mod:x+y;}
inline ll dec(ll x,ll y){return x-y<0?x-y+mod:x-y;}
inline ll mul(ll x,ll y){return 1ll*x*y%mod;}
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*w;
}
inline int ksm(int a,int b)
{
	int tmp=1;
	while(b)
	{
		if(b&1)tmp=(1ll*tmp*a)%mod;
		b>>=1,a=(1ll*a*a)%mod;
	}
	return tmp;
}
inline void Never_Tell_TLE(ll* NTT,int sign)
{
	for(int i=0;i<=lim;++i)if(i<id[i])
	{
		ll NTt=NTT[i];
		NTT[i]=NTT[id[i]];
		NTT[id[i]]=NTt;
	}
	for(int mid=1;mid<lim;mid<<=1)
	{
		int Unit_root;
		if(sign==1)Unit_root=ksm(3,(mod-1)/(mid<<1));
		else Unit_root=ksm(inv3,(mod-1)/(mid<<1));
		for(int R=mid<<1,r=0;r<lim;r+=R)
		{
			int pw=1;
			for(int l=0;l<mid;++l,pw=(1ll*pw*Unit_root)%mod)
			{
				int butt=NTT[l+r],rfly=(1ll*pw*NTT[l+r+mid])%mod;
				NTT[l+r]=inc(butt,rfly);
				NTT[l+r+mid]=dec(butt,rfly);
			}
		}
	}
	if(sign==-1)
	{
		int inv_lim=ksm(lim,mod-2);
		for(int i=0;i<=lim;++i)NTT[i]=(1ll*NTT[i]*inv_lim)%mod;
	}
}
inline void Derivation(ll* F,ll* G,int nm)
{
	for(int i=1;i<nm;++i)
	G[i-1]=mul(1ll*i,F[i]);
	G[nm-1]=0;
}
inline void Inv(ll* F,ll* G,int nm)
{
	if(nm==1)
	{
		G[0]=ksm(F[0],mod-2);
		return;
	}
	Inv(F,G,(nm+1)>>1);
	lim=1,fre=0;
	for(;lim<(nm<<1);lim<<=1)++fre;
	for(int i=0;i<=lim;++i)id[i]=(id[i>>1]>>1)|((i&1)<<(fre-1));
	for(int i=0;i<nm;++i)ans[i]=F[i];
	for(int i=nm;i<=lim;++i)ans[i]=0;
	Never_Tell_TLE(ans,1),Never_Tell_TLE(G,1);
	for(int i=0;i<=lim;++i)G[i]=mul(inc(2ll,-mul(ans[i],G[i])+mod),G[i]);
	Never_Tell_TLE(G,-1);
	for(int i=nm;i<=lim;++i)G[i]=0;
}
inline void Mul(ll* F,ll* G,int nm)
{
	lim=1,fre=0;
	for(;lim<(nm<<1);lim<<=1)++fre;
	for(int i=0;i<=lim;++i)id[i]=(id[i>>1]>>1)|((i&1)<<(fre-1));
	int inv_lim=ksm(lim,mod-2);
	Never_Tell_TLE(G,1),Never_Tell_TLE(F,1);
	for(int i=0;i<=lim;++i)G[i]=mul(F[i],G[i]);
	Never_Tell_TLE(G,-1);
}
inline void Integral(ll* F,ll* G,int nm)
{
	for(int i=1;i<nm;++i)
	G[i]=mul(F[i-1],ksm(i,mod-2));
	G[0]=0;
}
inline void solve(ll* F,ll* G,int nm)
{
	Inv(F,tmp,nm);
	for(int i=0;i<=lim;++i)ans[i]=0;
	Derivation(F,ans,nm);
	Mul(tmp,ans,nm);
	Integral(ans,G,nm);
}
int main()
{
	n=read();
	for(int i=0;i<n;++i)f[i]=read();
	solve(f,g,n);
	for(int i=0;i<n;++i)printf("%d ",g[i]);
	return 0;
}
```
只求能帮助到几个人罢。。

---

## 作者：Vocalise (赞：0)

一个基础的算法。

考虑多项式的求导，积分都是 $O(n)$ 的，而 $\ln$ 的求导有奇妙的性质，于是往这方面想。

$$\ln f(x)\equiv g(x)\pmod {x^n}$$

$$(\ln f(x))'\equiv (g(x))'\pmod{x^n}$$

$$\frac{f'(x)}{f(x)}\equiv g'(x)\pmod{x^n}$$

于是把 $f(x)$ 求导，求逆后相乘再积分就行了。

题目中的 $a_0 = 1$ 是为了保证原多项式为整系数的情况下， $\ln$ 多项式的常数用整数算得出来。所以最后答案常数项始终为 $\ln 1 = 0$。

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>

typedef long long ll;
const int p = 998244353;
const int MAXN = 4000001;

inline ll read() {
    ll x = 0,f = 1; char ch = getchar();
    while(ch > '9' || ch < '0') { if(ch == '-') f = -1; ch = getchar(); }
    do x = (x * 10 + ch - 48) % p, ch = getchar(); while(ch >= '0' && ch <= '9');
    return (x * f % p + p) % p;
}

int n,r[MAXN];
ll a[MAXN],b[MAXN],c[MAXN],t[MAXN];

ll fastpow(ll a,int b) {
    ll res = 1; a %= p;
    while(b) {
        if(b & 1) res = res * a % p;
        a = a * a % p;
        b >>= 1;
    }
    return res;
}

void NTT(ll *a,int N) {
    for(int i = 0;i < N;i++) if(i < r[i]) std::swap(a[i],a[r[i]]);
    for(int n = 2,m = 1;n <= N;m = n, n <<= 1) {
        ll g1 = fastpow(3,(p - 1) / n);
        for(int l = 0;l < N;l += n) {
            ll g = 1,t1,t2;
            for(int i = l;i < l + m;i++) {
                t1 = a[i], t2 = g * a[i + m] % p;
                a[i] = (t1 + t2) % p;
                a[i + m] = (t1 - t2 + p) % p;
                g = g * g1 % p;
            }
        }
    }
    return;
}

void INTT(ll *a,int N) {
    NTT(a,N);
    std::reverse(a + 1,a + N);
    int invN = fastpow(N,p - 2);
    for(int i = 0;i < N;i++) a[i] = a[i] * invN % p;
}

void Dervt(ll *a,ll *b,int N) {
    for(int i = 0;i < N - 1;i++) b[i] = a[i + 1] * (i + 1) % p;
    b[N - 1] = 0;
    return;
}

void Integ(ll *a,ll *b,int N) {
    for(int i = 1;i < N;i++) b[i] = a[i - 1] * fastpow(i,p - 2) % p;
    b[0] = 0;
    return;
}

void Inv(ll *a,ll *b,int n) {
    if(n == 1) return void(b[0] = fastpow(a[0],p - 2));
    Inv(a,b,(n + 1) >> 1);
    int N = 1, l = -1; while(N <= n << 1) N <<= 1, l++;
    for(register int i = 1;i < N;i++) r[i] = (r[i >> 1] >> 1) | ((i & 1) << l);
    for(register int i = 0;i < n;i++) t[i] = a[i];
    for(register int i = n;i < N;i++) t[i] = 0;
    NTT(t,N); NTT(b,N);
    for(register int i = 0;i < N;i++) b[i] = ((b[i] << 1) % p + p - t[i] * b[i] % p * b[i] % p) % p;
    INTT(b,N);
    for(register int i = n;i < N;i++) b[i] = 0;
    return;
}

void Ln(ll *a,int n) {
    Dervt(a,b,n);
    Inv(a,c,n);
    int N = 1, l = -1; while(N <= n << 1) N <<= 1, l++;
    for(register int i = 1;i < N;i++) r[i] = (r[i >> 1] >> 1) | ((i & 1) << l);
    NTT(b,N); NTT(c,N);
    for(int i = 0;i < N;i++) b[i] = b[i] * c[i] % p;
    INTT(b,N); Integ(b,a,n);
    return;
}

int main() {
    n = read();
    for(int i = 0;i < n;i++) a[i] = read();
    Ln(a,n);
    for(int i = 0;i < n;i++) std::printf("%lld ",a[i]);
    return 0;
}

```

---


# yyf hates dagequ

## 题目背景

非酋yyf在dew的指点下抽到了不错的卡，但他还是太非了，对于随机触发的技能，他总是无法触发。yyf想知道自己究竟有多非，所以他请你来计算他的期望得分，与自己的得分来比较。

## 此题已放宽精度限制并显示错误答案和正确答案，请不要以此面向数据

## 题目描述

给你一些卡牌的技能，技能分为$2$种类型：
1. 加分，每连击$c$次有$p\%$的概率加$s$分
2. 改判，每连击$c$次有$p\%$的概率触发强判定效果，持续$t$个节奏图标（设连击数为$c$的倍数时为第$i$个节奏图标，则强判定效果在第$[i+1,i+t]$个节奏图标被触发）

这些技能在连击数为$c$的倍数且连击数不为$0$时有概率触发，多个技能可以同时触发

其中，加分技能有 $\mathrm{score}$ 个，改判技能有 $\mathrm{judge}$ 个

再给你$n$个节奏图标（yyf是按给出的顺序击打的）yyf击打的原始（相对于“强判定效果”修正后）结果，分为$2$，$1$，$0$三种

在“强判定效果”的持续期间内所有的击打结果$1$会视作击打结果$2$，击打结果$0$仍视作击打结果$0$，击打结果$2$仍视作击打结果$2$ 。下文中的“击打结果”若无说明均指修正后的击打结果。

“连击数”的定义为到目前为止连续的击打结果为$2$的次数（若这次的击打结果为$2$则这次击打也算入当前的连击数，否则当前的连击数为$0$）

多个“强判定效果”可以重叠，但持续时间不会叠加（设当前“强判定效果”剩余时间为 $t_1$，此时同时触发两个“强判定效果”，持续时间分别为 $t_2$ 和 $t_3$ ，则下一次击打时的“强判定效果”剩余时间为 $\max(t_1-1,t_2,t_3)$）。

一次击打的得分为这次的击打结果乘以当前的连击数加一。即：设当前的击打结果为 $x$ ，当前的连击数为 $\mathrm{combo}$ ，则这次击打的得分为 $\mathrm{x*(combo+1)}$

最终得分为每次（共$n$次）击打的得分之和加上加分技能的加分之和

请求出yyf这次打歌的期望得分

## 说明/提示

### 数据范围

对于全部的测试点，有：$5 \le n \le 1000$，$0 \le \mathrm{score} \le 1000$，$0 \le \mathrm{judge} \le 1000$，$1 \le c \le 5$，$1 \le p \le 99$，$1 \le s \le 10$，$1 \le t \le 5$。

| 测试点编号 | $n$ | $\mathrm{score}$ | $\mathrm{judge}$ | 特殊限制 | 测试点编号 | $n$ | $\mathrm{score}$ | $\mathrm{judge}$ | 特殊限制 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $1000$ | $\ \,0\ \,$ | $\ \,0\ \,$ | 所有 $a_i$ 均为 $2$ | $11$ | $1000$ | $\ \,0\ \,$ | $\ \,9\ \,$ | 无 |
| $2$ | $1000$ | $0$ | $0$ | 无 | $12$ | $1000$ | $2$ | $2$ | 无 |
| $3$ | $1000$ | $1$ | $0$ | 无 | $13$ | $1000$ | $3$ | $3$ | 无 |
| $4$ | $1000$ | $9$ | $0$ | 无 | $14$ | $1000$ | $3$ | $6$ | 无 |
| $5$ | $1000$ | $1000$ | $0$ | 无 | $15$ | $1000$ | $1$ | $8$ | 所有 $c$ 均为 $1$ |
| $6$ | $50$ | $1$ | $1$ | 无 | $16$ | $1000$ | $0$ | $9$ | 所有 $c$ 均为 $1$ |
| $7$ | $50$ | $2$ | $2$ | 无 | $17$ | $1000$ | $1000$ | $1000$ | 所有 $c$ 均为 $1$ |
| $8$ | $50$ | $4$ | $4$ | 无 | $18$ | $1000$ | $1000$ | $1000$ | 所有 $c$ 均为 $1$ |
| $9$ | $50$ | $0$ | $9$ | 无 | $19$ | $1000$ | $1000$ | $1000$ | 无 |
| $10$ | $50$ | $4$ | $5$ | 无 | $20$ | $1000$ | $1000$ | $1000$ | 无 |

### 样例1解释

![](https://cdn.luogu.com.cn/upload/image_hosting/lc16fxxt.png)

### 样例2解释

![](https://cdn.luogu.com.cn/upload/image_hosting/rd4khzu1.png)

### 样例3解释

第一次4分，第二次1分，第三次0分，第四次4分，第五次6分

## 样例 #1

### 输入

```
4 1 1
3 70 3
2 20 1
2 2 1 1```

### 输出

```
13.82```

## 样例 #2

### 输入

```
5 0 2
2 60 1
2 10 2
2 2 1 1 1```

### 输出

```
19.084```

## 样例 #3

### 输入

```
5 0 0
2 1 0 2 2```

### 输出

```
15```

# 题解

## 作者：ouuan (赞：5)

### 算法一（输出答案）

第一个点可以手算出答案为 $1003000$

时间复杂度：$O(1)$

期望得分：$5$ 分

### 算法二（无技能）

直接模拟即可。

时间复杂度：$O(n)$

期望得分：$10$ 分

### 算法三（有加分）

当连击数不为零且为 $c_i$ 的倍数时，这个技能在这次击打中对答案的贡献为 $p_i*s_i$，所以扫一遍判断一下哪些技能的 $c$ 能整除当前连击数，把贡献加起来就好了。

时间复杂度：$O(\mathrm{score*n})$

期望得分：$25$ 分

### 算法四（蒟蒻ouuan第一次想到的dp）

用 $f[i][j][k]$ 表示打 $i$ 之前连击为 $j$ ，“强判定效果”持续到 $k$ ，打完 $[i,n]$ 后的期望得分

转移的时候用二进制枚举子集来枚举一下每个技能是否触发，然后算出这种情况发生的概率，乘上这种情况的得分，加起来。

时间复杂度：$O(\mathrm{n^3*2^{score+judge}*(score+judge)})$

期望得分：$15$~$25$ 分

### 算法五（数据分治）

~~使用数据分治结合算法三和算法四，可以获得更高的分数。~~

因为用算法四前 $5$ 个点会爆空间，所以当 $n>50$ 时就用算法三

时间复杂度：$O(\mathrm{n>50?score*n:n^3*2^{score+judge}*(score+judge)})$

期望得分：$40$~$50$ 分

### 算法六（dew惨遭ouuan卡掉的dp）

用 $f[i][j][k]$ 表示打 $i$ 之前连击为 $j$ ，“强判定效果”剩余持续时间为 $k$ ，打完 $[i,n]$ 后的期望得分

这样第三维的大小就从 $O(n)$ 变成了 $O(maxt)$，时间复杂度也相应减少。

除此之外每次枚举子集之前可以先处理出哪些改判技能满足连击数为 $c$ 的倍数，只用枚举这些技能就好了。而加分技能用算法三的方法来处理。

然而这样做会被第 $15$ 和/或第 $16$ 个点卡掉。

最坏情况时间复杂度：$O(\mathrm{n^2*maxt*(judge*2^{judge}+score)})$

期望得分：$70$~$75$ 分

### 算法七（在dew的启发下ouuan~~最终~~想出的dp）

还是用 $f[i][j][k]$ 表示打 $i$ 之前连击为 $j$ ，“强判定效果”剩余持续时间为 $k$ ，打完 $[i,n]$ 后的期望得分。

注意到每次枚举子集得到的结果只跟连击数有关，所以可以预处理出不同连击数的期望加分和改判不同次数的概率。

时间复杂度：$O(\mathrm{n*score+n*judge*2^{judge}+n^2*maxt^2})$

期望得分：$80$ 分

### 算法八（wjyyyjulao的优化）

就在比赛前一天，wjyyy突然提出了一种优化...本来我是本着μ's只有9个人的原则不想增强数据的..后来想着不增强的话太水了估计有一堆AK..~~反正学园偶像又不只是μ's~~

（赛后补充：打脸，一个30+都没有）

（赛后后补充：还是有两位julao赛后20分钟内AC了Orz）

思路其实很简单，就是把改判技能按 $t$ 降序排序，然后前面的改判发动了后面的改判就没用了，所以 $\mathrm{judge*2^{judge}}$ 都被优化成了 $\mathrm{judge}$.

然后就可以愉快地过掉最后 $20$ 分了。

而且算法四加了这个优化就稳 $25$ 了，算法六加了这个优化就稳 $80$ 了。

时间复杂度：$O(\mathrm{n*score+n*judge+n^2*maxt^2})$

期望得分：$100$ 分

### [~~算法九~~](https://www.luogu.org/blog/20782/SolutionT3)

### 标程

```
#include <iostream>
#include <cstdio>
#include <algorithm>

using namespace std;

const int N=1005;
const int T=6;
const int S=1005;
const int J=1005;

struct Judge
{
	int c,p,t;
	bool operator<(Judge& b)
	{
		return t>b.t;
	}
} jud[J];

int n,a[N],sco[S][3],score,judge;
double f[N][N][T],scor[N],judg[N][T];

int main()
{
	int i,j,k,l,maxt=0;
	double pos;
	
	cin>>n>>score>>judge;
	
	for (i=0;i<score;++i)
	{
		cin>>sco[i][0]>>sco[i][1]>>sco[i][2];
	}
	for (i=0;i<judge;++i)
	{
		cin>>jud[i].c>>jud[i].p>>jud[i].t;
		maxt=max(maxt,jud[i].t);
	}
	
	sort(jud,jud+judge); //把改判技能按t排序
	
	for (i=0;i<n;++i) //枚举击打前连击为i次（也就是打完后连击是i+1次）
	{
		scor[i]=2.0*(i+2); //得分
		for (j=0;j<score;++j)
		{
			if ((i+1)%sco[j][0]==0)
			{
				scor[i]+=sco[j][1]*sco[j][2]/100.0; //期望加分
			}
		}
		
		pos=1.0;
		
		for (j=0;j<judge;++j) //按序枚举改判技能
		{
			if ((i+1)%jud[j].c==0)
			{
				judg[i][jud[j].t]+=jud[j].p/100.0*pos; //若发动则这次改判一定持续当前枚举的t
				pos*=1.0-jud[j].p/100.0; //不发动的概率
			}
		}
		judg[i][0]=pos; //一次都不发动
	}
	
	for (i=1;i<=n;++i)
	{
		cin>>a[i];
	}
	
	for (i=n;i>=1;--i)
	{
		for (j=0;j<i;++j)
		{
			for (k=0;k<=maxt;++k)
			{
				if (a[i]==0)
				{
					f[i][j][k]=f[i+1][0][max(0,k-1)]; //若a[i]=0则下次连击必定为0，改判持续时间为max(0,k-1)
				}
				
				else if (a[i]==2||k>0)
				{
					f[i][j][k]=scor[j]; //得分+期望加分
					
					for (l=0;l<=maxt;++l)
					{
						f[i][j][k]+=f[i+1][j+1][max(l,k-1)]*judg[j][l]; //用改判不同次数进行转移
					}
				}
				
				else
				{
					f[i][j][k]=f[i+1][0][max(0,k-1)]+1.0; //与a[i]=0的不同在于还能得1分
				}
			}
		}
	}
	
	printf("%.6lf",f[1][0][0]);
	
	return 0;
} 
```

---

## 作者：CYJian (赞：4)

这道题肝了我将近三个小时才调出来..估计是我细节方面考虑不周全的原因吧..

(在此先%%%出题大佬ouuan为敬..~~语文水平是真的高~~)

首先这是一道显然的期望dp..

我们可以设置状态$f[i][j][k]$表示当我们到第$i$个节奏的时候已经打了$j$个$combe$,之后$k$个节奏可以强行改的期望得分..

然后我还加了一个辅助的$g[i][j][k]$表示转移到$f[i][j][k]$的概率是多少..
以及一个$To[i][j][k]$表示$f[i][j][k]$是否被转移过..

设好了状态之后,我们再来看看那两种卡牌..

第一种的效果是打了$c$的倍数的$combe$的时候加上$s$的分数..这个我们直接在转移到$c$的倍数的$combe$的状态时直接加上$p*s$就好了..这个期望直接加上去是没有影响的..或者可以预处理一个数组$add[i]$表示$combe$数为$i$的时候期望加的分数..

我们对于第二种卡牌的效果可以这样处理:

先把所有第二种卡牌按照$t$(改判的节奏个数)排序..

然后预处理出1~60(这里是一个优化,因为1~5的lcm是60,每过一个lcm就是一个循环..)的$combe$如果使用改判节奏长度为0~5(0为不触发任何效果)的概率大小..对应的就是下面代码中的$p$数组..

这样我们就可以每一次读入当前的节奏图标,然后可以枚举$f[i][j][k]$,然后可以用下面的这个方程转移:($po$为第$i$个节奏图标)

$$ co=(j+(po+k>1?1:0))*(po>1||(k\ \&\&\ po)) $$

$$f[i+1][co][l]=(f[i][j][k]+(add[(co-1)\%60+1]+(co+1)*(po+(k>0))*(po>0))*g[i][j][k])*p[(co-1)\%60+1][l]$$

是不是有点长..

然后这里还可以有一个优化空间的地方:第一维可以用滚动数组来搞..

当然,还有一个玄学优化:可以用一个$Max$标记一下上一次转移的时候转移的最大的$co$,当前这一次只需要枚举到这个$Max$就不需要再枚举了..因为再大转移的时候枚举的位置也不会超过上一次转移到的最大值..

当然,最后的答案就是下面这个式子了:

$$\sum_{i=0}^{n}\sum_{j=0}^{5}f[n\&1][i][j]$$

~~就是因为一次性想这么多优化并且打出来所以才调了三个小时..~~

下面有请$Code$:

```cpp
#include <bits/stdc++.h>

using namespace std;

#define reg register

typedef long long ll;

inline int read() {
    reg int s = 0, t = 1; reg char ch = getchar();
    while(ch > '9' || ch < '0') { if(ch == '-') t = -1; ch = getchar(); }
    while(ch <= '9' && ch >= '0') s = s * 10 + ch - '0', ch = getchar();
    return s * t;
}

struct Node {
    int p;
    int t;
    int c;
    friend bool operator < (Node a, Node b) {
        return a.t > b.t;
    }
};

const int N = 1001;

int n;
int S;
int J;
double add[61];
double p[61][6];
double f[2][N][6];
double g[2][N][6];
Node judge[N];
bool To[2][N][6];

inline void chkmax(int&a, int b) { a = a > b ? a : b; }

int main() {
    n = read();
    S = read();
    J = read();
    for(reg int i = 1; i <= S; i++) {
        reg int c = read();
        reg int p = read();
        reg int s = read();
        for(reg int j = c; j <= 60; j += c)
            add[j] += (double)(p * s) * 1.000000 / 100.000000;
    }
    for(reg int i = 1; i <= J; i++)
        judge[i].c = read(), judge[i].p = read(), judge[i].t = read();
    sort(judge + 1, judge + 1 + J);
    for(reg int i = 1; i <= 60; i++) {
        reg double a = 1.000000;
        for(reg int j = 1; j <= J; j++) {
            if(i % judge[j].c) continue;
            p[i][judge[j].t] += a * (double)judge[j].p / 100.000000;
            a = (a * (double)(100 - judge[j].p)) / 100.000000;
        }
        p[i][0] = a;
    }
    p[0][0] = 1.000000;
    reg int Min = 0;
    To[0][0][0] = 1;
    g[0][0][0] = 1;
    for(reg int i = 0, o = 1, t = 0; i < n; i++) {
        reg int po = read(), Max = 0;
        memset(f[o], 0, sizeof(f[o]));
        memset(g[o], 0, sizeof(g[o]));
        memset(To[o], 0, sizeof(To[o]));
        for(reg int j = 0; j <= Min; j++) {
            for(reg int k = 0; k < 6; k++) {
                if(!To[t][j][k]) continue;
                reg int co = (j + (po + k >= 2)) * (po > 1 || (k && po));
                reg int sp = (co - 1) % 60 + 1;
                for(reg int l = 0; l < 6; l++) {
                    if(!p[sp][l]) continue;
                    reg int M = (k - 1) > l ? (k - 1) : l;
                    reg int poi = min(2, po + (k > 0 && po));
                    f[o][co][M] += (f[t][j][k] + (add[sp] + (double)(co + 1) * poi) * g[t][j][k]) * 1.000000 * p[sp][l];
                    g[o][co][M] += g[t][j][k] * p[sp][l];
                    To[o][co][M] = 1;
                    chkmax(Max, co);
                }
            }
        }
        Min = Max;
        swap(o, t);
    }
    reg double res = 0;
    reg int o = n & 1;
    for(reg int i = 0; i <= n; i++)
        for(reg int j = 0; j < 6; j++)
            res += f[o][i][j];
    printf("%.10lf", res);
    return 0;
}
```

---


# [MtOI2018] 崩坏3？非酋之战！

## 题目背景

原题面因为太丑，被 disangan233 于 2019/09/26 修改。

在 2018 年暑假的时候，disangan233 肝了一个暑假的崩坏 3，他的帐号终于 $50$ 级啦！他终于把他的逆神巫女肝到 S 啦！

因为庆祝崩坏 3 登上 APP Store Top1，米忽悠给全服玩家发放了 $5$ 张扩充补给卡。

在玄学233聊天室发送了 "怒 grass 大伟出奇迹！" 之后就……单抽出律化娜了。

![](https://cdn.luogu.com.cn/upload/image_hosting/sk8m049a.png)

## 题目描述

在崩坏 3 中有一个叫做天命基地的地方，女武神们将在基地中~~开派对~~与敌人们厮杀。

女武神们的攻击力为 $atk$，她们将进行资源保卫战！

天命基地中有 $1$个 boss，boss 的血量为 $hp$，boss 不会攻击女武神。

现在有一条长度为 $n$ 的道路，道路的一头是 boss，另外一头是女武神需要保卫的资源，最开始 boss 每秒将会向资源移动 1 个单位长度。女武神们需要保护资源，所以她们要攻击 boss。 

我们将整条道路分成 $n$ 个格子，最开始资源在第 $n$ 格，女武神在第 $1$ 格，boss 在第 $0$ 格。

因为女武神的手太短了，所以只有当 boss 到达女武神当前那一格的时候，女武神才会攻击 boss，攻击完之后女武神会后退一格。

女武神有以下 $8$ 种攻击方式（每一格只能使用一种攻击方式）        

* 技能，造成 $80\% atk$ 的伤害，并使 boss 获得 $1$ 层燃烧 buff，在之后的每秒钟额外受到 $10\% atk$ 的伤害。(燃烧buff可以叠加)        
* 闪避，造成 $70\% atk$ 的伤害，并使 boss 时间暂停 $5s$。（$5s$ 内 boss 无法移动且仍会受到燃烧伤害）      
* 大招，造成 $120\% atk$ 的伤害，使 boss 时间暂停 $5s$。       
* 分支攻击，造成 $70\% atk$ 的伤害，并使 boss 时空减速，使 boss 经过每一个格子的时间增加 $1s$。    
* 爱酱的炸弹，使 boss 获得 $1$ 层燃烧 buff，并使 boss 愤怒，移速 $+50\%$。     
* 犹大的誓约，造成 $60\% atk$ 的伤害，如果 boss 有燃烧 buff 则减少 1 层，使 boss 时间暂停 $4s$。       
* 奥托之光，造成 $10\% atk$ 的伤害，如果 boss 有燃烧 buff 则清除 buff，使 boss 时间暂停 $10s$。     
* 律者之力，造成 $80\% atk$ 的伤害，使 boss 的移动速度 $+100\%$。

现在给你所有的信息，让你帮助 disangan233 蒟蒻算一下，他的女武神能否在 boss 触碰到资源前战胜 boss。

如果可以，输出 boss 死亡时距离资源最远的格子编号。如果不可以，请输出对 boss 造成的最大伤害。

## 说明/提示

#### 样例解释 $3$

开局 1 个技能，再来 1 个大招。

#### 样例解释 $4$

开局 1 个技能，再来 2 个大招。

### 子任务

对于 $10\%$ 的数据，保证：

$$
n\leq 10 \qquad  \max Atk\leq 10^{7}-1
$$     

对于 $20\%$ 的数据，保证：

$$
n\leq 300 \qquad \max Atk\leq 2^{32}-1
$$     

对于 $40\%$ 的数据，保证：

$$
n\leq 1,000 \qquad \max Atk\leq 2^{63}-1
$$     
对于 $70\%$ 的数据，保证：

$$
n\leq 5,000 \qquad \max Atk\leq 2^{63}-1
$$  

对于 $100\%$ 的数据，保证：

$$
n\leq 10,000 \qquad atk\equiv 0(\bmod\ 10)\qquad  atk\leq {10}^6\qquad \max Atk\leq 2^{64}-1
$$  

### 题目来源

[MtOI2018 迷途の家の水题大赛](/contest/11260) T4

出题人：disangan233

验题人：CYJian

72679

## 样例 #1

### 输入

```
1
1000 100```

### 输出

```
120
MiHoYo Was Destroyed!```

## 样例 #2

### 输入

```
10
1000 0```

### 输出

```
0
MiHoYo Was Destroyed!```

## 样例 #3

### 输入

```
10
198 100```

### 输出

```
2
Tech Otakus Save The World!```

## 样例 #4

### 输入

```
3
23333 100```

### 输出

```
440
MiHoYo Was Destroyed!```

## 样例 #5

### 输入

```
100
19260817 2330```

### 输出

```
99
Tech Otakus Save The World!```

# 题解

## 作者：lenlen (赞：25)

### 前言

刚入坑崩三，随便在主题库里搜了一下，发现竟然还有这样的题。。。

顺便说一句，现在新手第二天签到送空律。。。

### Problem

题目大意：略。

数据范围：$n \leq 10^4,Atk \leq 2^{64}-1$。

### Solution

分析一下，看到有八个技能，顿时感觉这个题不简单，后来一看：
闪避被大招完美压制；

1. 爱酱的炸弹被技能完美压制；

1. 犹大的誓约被大招完美压制；

1. 奥托之光清除了燃烧状态，没用，因为显然攻击完后女武神就打不到 boss 了，只能靠燃烧，你清除了我还玩什么？

1. 律者之力被技能和大招完美压制。

总结一下，大部分技能都没用，只有技能，大招，分支攻击有用。（~~其他技能的目的就是吓退你~~）

那么显然还是 DP 不了的，时间复杂度是 $O(n^3)$，还需要在简化。

使用邻项交换法，假设前面已经有 $i$ 层燃烧， $j$ 层时空减速：（忽略基础伤害，因为基础伤害相同，只有燃烧伤害不同）

相邻两个技能分别是技能和大招：

大招在前：$Atk=i \times (j+1+5) \times atk /10+(i+1) \times (j+1) \times atk /10$。

大招在后：$Atk=(i+1) \times (j+1) \times atk/10+(i+1) \times (j+1+5) \times atk /10$。

显然大招在后好一点。

若是分支攻击和大招：

大招在前：$Atk=i \times (j+1+5) \times atk /10+i \times (j+1+1) \times atk/10$。

大招在后：$Atk=i \times (j+1+1) \times atk/10 +i \times (j+1+5+1) \times atk/10$。

相同的结论。

其实我们可以这么想，技能和分支攻击对后面的攻击都是有加成的，相当于一个 $buff$,但是大招只是延长吃到 $buff$ 的时间，所以把大招放在后面最优。

因此时间复杂度简化到了 $O(n^2)$，空间滚动树组即可。

至于 $Atk \leq 2^{64}-1$，按道理说要开 unsigned long long，不过这个题开 long long 也过去了。。。

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e4+7232;
long long n;
long long hp,atk;
long long a,b,c,d;//技能，大招，分支
long long dp[2][N];
long long ans1,ans2=N;
long long mx(long long x,long long y){return x>y?x:y;}
long long mi(long long x,long long y){return x<y?x:y;}
int main()
{
	unsigned 
    cin>>n>>hp>>atk;
	a=8*atk/10;c=7*atk/10;d=atk/10;
	for(long long i=0;i<=n;i++)
	for(long long j=0;i+j<=n;j++)
	{
		long long k=n-i-j;
		b=12*atk/10+atk/10*i*(j+6);//一次大招的伤害计算
		if(i) dp[i&1][j]=mx(dp[i&1][j],dp[i-1&1][j]+a+d*(j+1)*(i-1));
		if(j) dp[i&1][j]=mx(dp[i&1][j],dp[i&1][j-1]+c+d*j*i);
		ans1=mx(ans1,dp[i&1][j]+k*b);
		if(dp[i&1][j]>=hp) ans2=mi(ans2,i+j);
		else if(dp[i&1][j]+k*b>=hp) ans2=mi(ans2,i+j+(hp-dp[i&1][j]+b-1)/b);
	}
	if(ans1<hp) printf("%lld\nMiHoYo Was Destroyed!",ans1);//翻译一下：mihoyo被摧毁？？？还是不要吧
	else printf("%lld\nTech Otakus Save The World!",ans2);
}
```

~~吐个槽：~~

~~要是真有不需要充能的女武神就好了。。。~~

~~为什么**她**们打一下要退一格？~~

---

## 作者：disangan233 (赞：20)

### 具体做法

思路：贪心+Dp+滚动数组优化+卡了一点点常数

首先一看这个题啊 $8$ 种技能，大多数人想到了搜索，然后看到数据范围 $n\leq 10000$ 的时候就应该果断放弃 qwq。

因为此题满足最优性和无后效性，所以考虑 dp。(裸的dfs预计得分：0~15？)

显然是不可能让你开个 $9$ 维数组来往死里 dp 的。相信很多人已经看出来了一个很明显的问题：

* 闪避技能貌似没有什么用？

在发现了这个问题之后，我们可以得出以下引理：

* 引理 $1$：满足最优解，只需要使用技能、大招和分支攻击。

然后我们就可以愉快地把时空复杂度降到 $O(n^3)$ 了！

---

但是面对如此~~无耻~~优秀的时空限制，我们还需要继续优化代码。因为分支攻击和闪避是 "辅助型技能"(因为这 $2$ 个技能都在给 buff 增加伤害)，真正的攻击伤害都来源于大招。

所以为了满足最优性原则，我们得出新的引理：

* 引理 $2$：大招应该在最后放，除非格子不够。

所以我们的时间复杂度降到了 $O(n^2)$，吸氧后可以接受，空间使用滚动数组优化即可。

### Code     

```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;
#define ll unsigned long long
#define re register ll
ll n,atk,hp,r=10005;
ll f[2][10005];
inline ll read()
{
    ll luoyang=0,yz=1;
    char did=getchar();
    while(!isdigit(did)) yz=did=='-'?-1:yz,did=getchar();
    while(isdigit(did)) luoyang=luoyang*10+did-'0',did=getchar();
    return luoyang*yz;
}
inline ll check(ll w)
{
    ll ans=0;
    for(re i=0;i<=w;i++)
    for(re j=0;i+j<=w;j++)
    {
        re k=w-i-j;
        ll dazhao=1.2*atk+0.1*atk*i*(j+1+5);
        if(i) f[i&1][j]=max(f[i&1][j],f[(i+1)&1][j]+(ll)(0.8*atk+0.1*atk*(j+1)*(i-1)));
        if(j) f[i&1][j]=max(f[i&1][j],f[i&1][j-1]+(ll)(0.7*atk+0.1*atk*j*i));
        ans=max(ans,f[i&1][j]+k*dazhao);
        if(dazhao&&f[i&1][j]+k*dazhao>=hp)
        r=min(r,i+j+max((ll)0,(hp-f[i&1][j]+dazhao-1)/dazhao));
    }
    return ans;
}
int main()
{
    n=read();hp=read();atk=read();
    ll ans=check(n);
    if(ans<hp) cout<<ans<<endl<<"MiHoYo Was Destroyed!"<<endl;
    else cout<<r<<endl<<"Tech Otakus Save The World!"<<endl;
    return 0;
}
```

---

## 作者：谋事在人 (赞：8)

整体思路：贪心+dp
## 1. 思路分析
当我看到这题的八个攻击方式之后，我发现“闪避”这个攻击方式好像被“大招”完爆。~~来人，上完爆口诀：攻高吃误导，血厚怕沃金……~~ 继续看下去，发现只有“技能”“大招”“分支攻击”这三个攻击方式是有用的。

题目中的“ 5s 内 boss 无法移动且仍会受到燃烧伤害”一句话告诉我们，大招的时停是为了配合“技能”的燃烧效果的，分支攻击的减速效果也是为了更多地触发这个燃烧效果。很明显把所有大招放在最后使用能打出最多伤害，而分支攻击和技能的攻击顺序具体应当如何分配尚不确定，但是观察到如果前一段 boss 身上的 debuff （指燃烧和减速）种类及数量已经确定，那么之后的攻击伤害与之前攻击顺序无关，满足无后效性，可以考虑 dp。

对大招应该放在最后使用的证明：

若将一次大招和一次技能交换位置：

交换前： $damage=(1.2*atk+0.1*atk*6)+0.8*atk$

交换后： $damage=0.8*atk+1.2*atk$

若将一次大招和一次分支攻击交换位置（假定存在 k 层“燃烧” debuff ）：

交换前： $damage=(1.2*atk+0.1*atk*6*k+0.1*atk*k)+0.7*atk$

交换后： $damage=0.7*atk+(1.2*atk+0.1*atk*6*k)$

无论将大招和技能还是分支攻击（向前）交换都会减少总伤害且不增加 debuff 层数，那么应该把所有大招都放在最后使用。

在 dp 时，很容易想到的是 $dp[i][j]$ 表示前i次攻击中释放j次技能，推出使用i-j次分支攻击，此时时间复杂度与空间复杂度均为 $O(n^2)$ 时间卡线过，空间则需要滚动数组优化。

每次更新 dp 数组时更新在此时的 debuff 基础下不断使用大招能造成的最多伤害和最快杀死 boss 的时间。

提醒：本题 $max Atk \leq 2^{64}-1$ 应使用 unsigned long long 而非 long long 类型。
```
#include<bits/stdc++.h>
using namespace std;
#define ull unsigned long long
#define now i&1
#define nt (i&1)^1
const int N=1e4+10;

ull dp[2][N],hp,maxn=0,minn=10010;//分别是最多打多少伤害，最少多少个格子打死 
int n,atk;
bool vis[2][N];

int main(){
	freopen("lg.in","r",stdin);
	freopen("lg.out","w",stdout);
	scanf("%d%llu%d",&n,&hp,&atk);
	vis[1][0]=1;
	if(atk==0){//特判atk=0，虽然好像不特判也能过
		printf("%d\n%s",0,"MiHoYo Was Destroyed!");
		return 0;
	}
	for(int i=1;i<=n;i++){
		for(int j=0;j<=n;j++){//dp过程
			if(vis[now][j]){//用vis是因为没有比较好的初值可以赋
				maxn=max(maxn,dp[now][j]+(ull)((n-i+1)*(1.2*atk+j*(i-j+5)*0.1*atk)));
				minn=min(minn,i+(ull)((hp-dp[now][j])/(1.2*atk+j*(i-j+5)*0.1*atk+0.999)));更新最大伤害和最短时间
				dp[nt][j+1]=max(dp[nt][j+1],(ull)(dp[now][j]+j*0.1*(i-j)*atk+0.8*atk));//使用技能
				vis[nt][j+1]=1;
				dp[nt][j]=max(dp[nt][j],(ull)(dp[now][j]+j*0.1*(i-j)*atk+0.7*atk));//使用分支攻击
				vis[nt][j]=1;
 			}
		}
	}
	printf("%llu\n%s",minn<=n ? minn : maxn,minn<=n ? "Tech Otakus Save The World!" : "MiHoYo Was Destroyed!");//判断是否能在n格内打死boss
	return 0;
}
```

---

## 作者：ink_ngm (赞：4)

~~崩三花导时代前来考古（~~

## 整体思路

裸贪心。

分析一下题目：在每次女武神攻击的八种方式中，显然有一些方式是不优的：

* 分析一下每种攻击方式的伤害：闪避在和大招的附加效果相同的情况下，净伤害要小于大招，因而为保证伤害最大化，可直接将闪避这一方式排除掉不看。

* 对于 $n \leq 10000$ 的数据范围来说，显然攻击的主要伤害来自燃烧伤害（即使只叠燃烧层数，在叠超过 $12$ 层后，每格燃烧伤害必将大于攻击净伤害[~~所以女武神是打火机~~]），对于崩坏兽 boss 所受的燃烧伤害 $A$ ，与燃烧叠层 $f$ 和其走一格所用时间 $t$ 成正比。若总伤害占比中净伤害占比更高，我们考虑尽可能多的拿净伤害最高的大招；若燃烧伤害占比更高，我们可考虑拿增加 $f$ 或 $t$ 的技能和分支攻击。因而我们可以直接将爱酱的炸弹，奥托之光，律者之力三种混淆视听的方式排除掉不看。

* 对于读入的攻击力 $atk'$，因题目保证 $10 \mid atk'$，我们可以读入后预处理 $atk = atk'\div 10$。（下述 $atk$ 均为预处理后）。则剩余三种攻击方式可表述为：

  * 技能伤害 $8 \times atk$ ，效果令 $f + 1$ 。
  * 分支攻击伤害 $7 \times atk$ ，效果令 $t + 1$ 。
  * 大招伤害 $12 \times atk + f \times \ ( t + 5 )$ 。
  
* 因技能和分支攻击的效果叠层会影响大招伤害（~~你打游戏的时候不也是先叠 buff 再开大嘛~~），所以，我们应尽可能使用完所有技能和分支攻击次数后，再使用大招。

上述思路与其他篇题解基本类似，但在实现方面，本篇题解考虑使用时间和空间复杂度更优的贪心实现而非 DP。

在使用技能和分支攻击次数上，因技能和分支攻击效果权重都只能对应 $+1$ 。我们设技能和分支攻击共使用 $x$ 次，使用技能 $y$ 次，则使用分支攻击 $x - y$ 次，我们可用基本不等式推导易得:

$\text{当 } y = x-y \text{，即 } y = \frac{x}{2}  \text{ 时，} A = f \times t \text{ 取最大。}$

所以我们考虑令叠 buff 期间维护每次攻击后 $f$ 与 $t$ 之间差值尽可能小，且又因技能净伤害大于分支攻击净伤害、技能和分支攻击效果权重都只能对应 $+1$ ，我们考虑令每次**使用技能攻击后、使用分支攻击**，从而，我们可以写出以下代码：

```cpp
#include<stdio.h>
using namespace std;
inline unsigned long long read(){
    register long long x=0;register char ch=getchar_unlocked();
    while(ch<'0'||'9'<ch){ch=getchar_unlocked();}
    while('0'<=ch&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48),ch=getchar_unlocked();}
    return x;
}
const int N=1e4+5;
unsigned long long fire=0,time=1,ans,id=1145141;
inline unsigned long long max(unsigned long long x,unsigned long long y){
    return x>y?x:y;
}
inline unsigned long long min(unsigned long long x,unsigned long long y){
    return x<y?x:y;
}
signed main(){
    register int n=read(),i,j,k,kk,flag;
    register unsigned long long hp=read(),atk=read()/10,sum=0;
    for(i=0;i<n;++i){//i前为叠buff，i后全部为伤害最高的大
        fire=0,time=1,sum=flag=0;
        for(j=0;j<i;++j){
            if(!(j&1)) sum+=8*atk+fire*time*atk,++fire;
            else sum+=7*atk+fire*time*atk,++time;
             if(sum>=hp){
                id=min(id,j+1),flag=1;
                 break;
            }
        }
        if(sum+(n-i)*(12+fire*(time+5))*atk<hp) ans=max(ans,sum+(n-i)*(12+fire*(time+5))*atk);
        else id=min(id,i+(hp+((12+fire*(time+5))*atk-1-sum))/((12+fire*(time+5))*atk));
    }
    printf("%llu\n",id^1145141?id:ans);
    if(id^1145141) puts("Tech Otakus Save The World!");
    else puts("MiHoYo Was Destroyed!");
    return 0;
}
```

但是，此份代码只能收获 $85pts$ [link](https://www.luogu.com.cn/record/186144898)。

为什么会挂 $15pts$ 呢？我们在维护叠 buff 时只考虑到尽可能在叠buff区间时，燃烧伤害取最大。但是，在放大招期间，每次燃烧效果作用的 $A$ 实际上的时间乘区为 $t + 5$，换句话来说，**对时间乘区有作用效果的分支攻击的权重实际上被降低稀释了**，为保证取得伤害最大化，我们考虑令叠buff阶段的后部分阶段仅使用技能，从而使在大招阶段的时间乘区与燃烧叠层乘区尽可能相等，也就是说，我们在原代码的基础，多考虑一下将后**至多 $5$ 次分支攻击改为技能**，便可以极其优秀的时间空间复杂度通过此题，代码如下：

```cpp
#include<stdio.h>
using namespace std;
inline unsigned long long read(){
    register long long x=0;register char ch=getchar_unlocked();
    while(ch<'0'||'9'<ch){ch=getchar_unlocked();}
    while('0'<=ch&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48),ch=getchar_unlocked();}
    return x;
}
const int N=1e4+5;
unsigned long long fire=0,time=1,ans,id=1145141;
//爱酱，犹大，奥托，律者纯负面技，直接不考虑；闪避被大招完爆也不考虑
//技能->08atk与燃烧乘区叠层+1
//大招->12atk+5*当前燃烧乘区*时间乘区
//分支->07atk与时间乘区+1
inline unsigned long long max(unsigned long long x,unsigned long long y){
    return x>y?x:y;
}
inline unsigned long long min(unsigned long long x,unsigned long long y){
    return x<y?x:y;
}
signed main(){
    register int n=read(),i,j,k,kk,flag;
    register unsigned long long hp=read(),atk=read()/10,sum=0;//因数据保证atk能被10整除，每次攻击伤害乘区都为x/10,便可预先处理将atk/10,后直接乘乘区x
    for(i=0;i<n;++i){//i前为叠buff，i后全部为伤害最高的大
        fire=0,time=1,sum=flag=0;
        for(j=0;j<i;++j){
            if(!(j&1)) sum+=8*atk+fire*time*atk,++fire;
            else sum+=7*atk+fire*time*atk,++time;
             if(sum>=hp){
                id=min(id,j+1),flag=1;//在叠buff阶段便已经干掉boss，则此情况比不最优且boss定能被小于当前格子数的情况下被干掉
                 break;
            }
        }
        if(sum+(n-i)*(12+fire*(time+5))*atk<hp) ans=max(ans,sum+(n-i)*(12+fire*(time+5))*atk);
        else id=min(id,i+(hp+((12+fire*(time+5))*atk-1-sum))/((12+fire*(time+5))*atk));
        k=(n>>1)-1;
        while(k+6>(n>>1)){
            fire=0,time=1,sum=flag=0,kk=k;
            for(j=0;j<i;++j){
                if(!(j&1)||!kk) sum+=8*atk+fire*time*atk,++fire;
                else if(kk) sum+=7*atk+fire*time*atk,++time,--kk;
                 if(sum>=hp){
                    id=min(id,j+1),flag=1;
                     break;
                }
            }
            if(flag==1) break;
            if(sum+(n-i)*(12+fire*(time+5))*atk<hp) ans=max(ans,sum+(n-i)*(12+fire*(time+5))*atk);
            else id=min(id,i+(hp+((12+fire*(time+5))*atk-1-sum))/((12+fire*(time+5))*atk));
            --k;
        }
    }
    printf("%llu\n",id^1145141?id:ans);
    if(id^1145141) puts("Tech Otakus Save The World!");
    else puts("MiHoYo Was Destroyed!");
    return 0;
}
```

---

## 作者：zyn_ (赞：3)

题面太长了，给个 [传送门](https://www.luogu.com.cn/problem/P4922) 吧。

## 本题 $100$ 分做法

审题：只有当 boss 到达女武神当前那一格的时候，女武神才会攻击 boss，攻击完之后**女武神会后退一格**。也就是说女武神一共会攻击 $n$ 次。在后面做题中，请牢记这一点。

先对输入做一些手脚：看到 $atk\equiv 0\pmod {10}$，不妨将 $atk$ 除以十（**下文的 $atk$ 均为除以十后的 $atk$**），然后令题面中的 $(10x)\%atk$ 变为 $x$ 点伤害，则 $1$ 点伤害即为原来的 $atk$ 点伤害。boss 受到 $\lceil\dfrac{hp}{atk}\rceil$ 点伤害即死亡。

**下文的伤害均指如上处理过的伤害。**

不难发现，题目中的攻击：

1. 大招严格强于闪避：伤害高。

2. 技能严格强于爱酱的炸弹：伤害高，移速增加是对女武神来说的负面效果。

3. 大招严格强于奥托之光，因为**攻击完之后女武神会后退一格**，然后奥托之光清楚了燃烧 buff，那么暂停的 $10$ 秒根本没用。

4. 技能严格强于律者之力：有 buff，无移速增加。

5. 大招严格强于犹大的誓约：伤害高，暂停时间长，不减少 buff。

于是只有技能、分支攻击、大招是有用的。

技能和分支攻击会给 boss 带来燃烧 buff 或减速，所以可以推得大招最后放最好。

于是设 $dp_{i,j}$ 为放 $i$ 次技能，$j$ 次分支攻击带来的最大伤害。其中 $i+j\le n$。

$$
dp_{i,j}=\max\{dp_{i-1,j}+(i-1)(j+1)+8,dp_{i,j-1}+ij+7\}
$$

（若 $i,j$ 有负数则 $dp_{i,j}=0$）

在递推过程中统计“boss 死亡时距离资源最远的格子编号”或者“最大伤害值”。若放了 $i$ 次技能，$j$ 次分支攻击后，剩下放大招 $n-i-j$ 次，则伤害为 $dp_{i,j}+(n-i-j)(12+i(j+6))$，其中 $j+6$ 是因为分支攻击减缓了 $j$ 秒，大招减缓 $5$ 秒，boss 本身经过格子 $1$ 秒。若这个伤害能打死 boss，再计算最远在哪格击败 boss。

时间复杂度 $O(n^2)$。需要滚动数组优化至空间 $O(n)$。

**注意，输入的伤害是处理过的，输出记得还原！**

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ull unsigned long long
#define N 10009
#define INF 0x3f3f3f3f
ull n,x,y,dp[2][N],ans,a,b,pos;
int main(){
	cin>>n>>x>>y;
	y/=10;pos=INF;
	a=0,b=1;
	for(ull i=0;i<=n;++i,a^=1,b^=1){
		for(ull j=0;j<=n;++j)
			if(i+j<=n){
				if(i)dp[a][j]=dp[b][j]+(i-1)*(j+1)+8;
				if(j)dp[a][j]=max(dp[a][j],dp[a][j-1]+i*j+7);
				ans=max(ans,dp[a][j]+(n-i-j)*(12+i*(j+6)));
				if(ans*y>=x)pos=min(pos,(x/y-dp[a][j]-1)/(12+i*(j+6))+1+i+j);
			}
	}
	if(pos==INF)printf("%llu\nMiHoYo Was Destroyed!\n",ans*y);
	else printf("%llu\nTech Otakus Save The World!\n",pos);
	return 0;
}
```

## 加强题 $100$ 分做法

[加强题传送门](https://www.luogu.com.cn/problem/U394776)

（如果链接失效或加强题目数据有误，请 at [zyn_](https://www.luogu.com.cn/user/710811)）

$$
\begin{aligned}
dp_{i,j}&=\max\{dp_{i-1,j}+(i-1)(j+1)+8,dp_{i,j-1}+ij+7\} \\
&=ij+7+\max\{dp_{i-1,j}+i-j,dp_{i,j-1}\}
\end{aligned}
$$

事实上，原题的 dp 转移方程，与 $n$，$hp$，$atk$ 均无关：所有的 $dp_{i,j}$ 不随输入变化而变化。

看起来很能优化的样子……

尝试输出一下每个 $dp_{i,j}$ 是从 $dp_{i-1,j}$ 还是 $dp_{i,j-1}$ 转移的（就是 $\max$ 取了哪一边）。$i,j$ 较小时，发现 $i\gt j$ 时从 $dp_{i-1,j}$ 转移，$i\le j$ 时从 $dp_{i,j-1}$ 转移。猜测 $i,j$ 较大时也是如此。

按照这个猜测，尝试计算 $dp_{i,j}$。

$$
dp_{i,j}=\begin{cases}
dp_{i-1,j}+i-j+ij+7,i\gt j \\
dp_{i,j-1}+ij+7,i\le j
\end{cases}
$$

那么：

$$
\begin{aligned}
dp_{i,i}&=dp_{i,i-1}+i^2+7 \\
&=(dp_{i-1,i-1}+1+i(i-1)+7)+i^2+7 \\
&=dp_{i-1,i-1}+2i^2-i+15 \\
&=\sum_{j=1}^{i}(2j^2-j+15) \\
&=\frac{4i^3+3i^2+89i}{6}
\end{aligned}
$$

设 $x,k$ 为自然数，

$$
\begin{aligned}
dp_{x,x+k}&=dp_{x,x}+\sum_{i=x+1}^{x+k}(ix+7) \\
&=dp_{x,x}+7k+\frac{xk(2x+k+1)}{2} \\
dp_{x+k,x}&=dp_{x,x}+\sum_{i=x+1}^{x+k}(i-x+ix+7) \\
&=dp_{x,x}+7k+\frac{xk(2x+k+1)+k(k+1)}{2}
\end{aligned}
$$

我们知道了所有的 $dp_{i,j}$ 的值，可以去验证猜测了。这个验证并不难，只需一个归纳即可，这里略去。

现在，固定 $n$ 的值，试着求出 $n=n_0$ 次攻击对 boss 造成的最大伤害。

设共放 $i$ 次技能，$j$ 次分支攻击后，连续放大招 $n-i-j$ 次，造成伤害为 $f_{i,j}$。则 $f_{i,j}=dp_{i,j}+(n-i-j)(12+i(j+6))$，在上文 $O(n^2)$ dp 的统计答案时已经提到过了。

$$
\begin{aligned}
f_{x,x+k}&=dp_{x,x+k}+(n-2x-k)(12+x(x+k+6)) \\
&=\frac{4x^3+3x^2+89x}{6}+7k+\frac{xk(2x+k+1)}{2}+(n-2x-k)(xk+x^2+6x+12) \\
f_{x+k,x}&=dp_{x+k,x}+(n-2x-k)(12+(x+k)(x+6)) \\
&=\frac{4x^3+3x^2+89x}{6}+7k+\frac{xk(2x+k+1)+k(k+1)}{2}+(n-2x-k)((x+6)k+x^2+6x+12)
\end{aligned}
$$

这是一个关于 $x,k$ 的函数。固定 $x$，则 $f_{x,x+k}$ 与 $f_{x+k,x}$ 都成为关于 $k$ 的二次函数，且二次项小于 $0$。可以证明，固定 $x$，将 $f_{x,y}$ 视为关于 $y$ 的函数时，它为**上凸函数**。

类似地，固定 $y$，将 $f_{x,y}$ 视为关于 $x$ 的函数时，它也为上凸函数。

于是，可以三分 $x$，再三分 $y$，求出最大的 $f_{x,y}$。这就是 $n_0$ 次攻击对 boss 造成的最大伤害。

但是我们可能还要求“boss 死亡时距离资源最远的格子编号”！

那就二分一下攻击次数 $n$，就做完了。

**以下代码可以通过加强版题目，但不能通过原题。**（为什么？请自己观察吧。）

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll __int128_t
inline ll read(){
	static char c=' ';
	static ll r=0;r=0;
	while(c<48||c>57)c=getchar();
	while(c>47&&c<58)r=r*10-48+c,c=getchar();
	return r;
}
void write(ll x){if(x>9)write(x/10);putchar(x%10+48);}
inline ll calc(ll n,ll x,ll y){
	static ll k;
	if(x<y){
		k=y-x;
		return x*(4*x*x+3*x+89)/6+7*k+(x*k*(2*x+k+1)>>1)+(n-2*x-k)*(12+x*(x+k+6));
	}
	k=x-y;
	return y*(4*y*y+3*y+89)/6+8*k+(y*k*(2*y+k+1)>>1)+(k*(k-1)>>1)+(n-2*y-k)*(12+(y+k)*(y+6));
}
ll getmax(ll n,ll x){
	static ll l,r,p,q,f,g,ans;
	if(n==x)return calc(n,x,0);
	l=0,r=n-x;ans=0;
	while(l<=r){
		p=(2*l+r)/3;ans=max(ans,f=calc(n,x,p));
		q=(l+2*r)/3;ans=max(ans,g=calc(n,x,q));
		if(f<g)l=p+1;
		else r=q-1;
	}
	ans=max(ans,calc(n,x,l));
	ans=max(ans,calc(n,x,l+1));
	return ans;
}
ll check(ll n){
	static ll l,r,p,q,f,g,ans;
	l=0,r=n;ans=0;
	while(l<=r){
		p=(2*l+r)/3;ans=max(ans,f=getmax(n,p));
		q=(l+2*r)/3;ans=max(ans,g=getmax(n,q));
		if(f<g)l=p+1;
		else r=q-1;
	}
	ans=max(ans,getmax(n,l));
	ans=max(ans,getmax(n,l+1));
	return ans;
}
ll t,n,a,b,l,r,mid;
int main(){
	t=read();
	while(t--){
		n=read();a=read();b=read();
		b/=10;a=(a-1)/b+1;
		l=1;r=n;
		while(l<=r){
			mid=(l+r)>>1;
			if(check(mid)>=a)r=mid-1;
			else l=mid+1;
		}
		if(l==n+1)write(check(n)*b),puts("\nMiHoYo Was Destroyed!");
		else write(l),puts("\nTech Otakus Save The World!");
	}
	return 0;
}
```

---

## 作者：kkxacj (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P4922)

#### 思路

乍一看 $8$ 种攻击方式，其实就三个有用。

- 闪避不如大招。
- 爱酱的炸弹不如技能。
- 犹大的誓约被大招全方面碾压。
- 奥托之光伤害低，把燃烧状态清除了，但攻击完之后女武神会后退一格，等 $10$ 秒跟没等一样。
- 律者之力不如技能。

然后发现，大招是给一个伤害然后让敌人暂停 $5$ 秒，且会吃燃烧伤害，所以先技能在大招肯定是比先大招在技能伤害高的，分支攻击同理，因为它会让之后 boss 走一个格子都慢一秒，而先用大招就利用不了这个 buff 了，由于无法判断是先放技能最优还是先放分支攻击最优，所以可以直接枚举，然后大招留到最后放，就可以通过该题目了。

**code**

```cpp
#include<bits/stdc++.h>
using namespace std;
unsigned long long n,ans2 = 30000;
unsigned long long a,b,l1,l2,l3,l4,dp[2][30010],ans1;
int main()
{
	scanf("%llu%llu%llu",&n,&a,&b);
	l1 = b / 10 * 8,l2 = b / 10 * 12,l3 = b / 10 * 7;//技能，大招，分支攻击
	for(int i = 0;i <= n;i++)//分支攻击
		for(int j = 0;j + i <= n;j++)//技能
		{
			l4 = l2 + j * (6 + i) * (b / 10);//当前大招伤害
			if(i) dp[i & 1][j] = max(dp[i & 1][j],dp[!(i & 1)][j] + l3 + (b / 10) * i * j);
			if(j) dp[i & 1][j] = max(dp[i & 1][j],dp[i & 1][j - 1] + l1 + (b / 10) * (i + 1) * (j - 1));
			ans1 = max(ans1,dp[i & 1][j] + l4 * (n - i - j));
			if(dp[i & 1][j] >= a) ans2 = min(ans2,1llu * i + j);//能够击杀boss 
			else if(dp[i & 1][j] + l4 * (n - i - j) >= a) ans2 = min(ans2,i + j + (a - dp[i & 1][j] + l4 - 1) / l4);//能够通过放大招击杀boss 
		}
	if(ans2 <= n) printf("%llu\nTech Otakus Save The World!",ans2);
	else printf("%llu\nMiHoYo Was Destroyed!",ans1);
    return 0;
}
```


---


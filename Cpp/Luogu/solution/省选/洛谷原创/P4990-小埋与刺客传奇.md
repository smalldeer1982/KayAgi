# 小埋与刺客传奇

## 题目背景

**数据已更新。**

经过几天几夜的硬肝，小埋终于玩到了最后一关，也是$Dancing$ $Line$的魔王关——$The$ $Legend$ $of$ $Assassin$

![avatar](https://cdn.luogu.com.cn/upload/pic/34876.png)

![avatar](https://cdn.luogu.com.cn/upload/pic/35145.png)

## 题目描述

如图，魔王关经常出现炸路与突发障碍。

小埋很苦恼，因为她不知道完整的地图。于是她进行了许多尝试，总结了随着时间变化而出现或消失的路与她在这些时刻时的位置，**为了简化问题，我们假定小埋的位置始终不变**。

现在她想知道，她至少从什么时刻开始才可以看到能通向终点的路；由于一些路径上有钻石，这些钻石能带来一定加分，小埋还希望知道她在最早看到能通向终点的路时，按照当前地图走向终点所能获得的最大得分。

## 说明/提示

本题共$10$个测试点，各测试点详细信息如下：

$1$：$n<=100000$，$m<=200000$，$t<=100000$；输出“$Continue$ $from$ $the$ $last$ $checkpoint$”；分值：$5$；

$2$：$n<=100$，$m<=10000$，$t<=100$；无特殊性质；分值：$10$；

$3$：$n<=100000$，$m<=200000$，$t<=100000$；所有边的分数为$0$；分值：$10$；

$4$：$n<=100000$，$m<=200000$，$t=0$；无新增或消失的边；分值：$5$；

$5$~$6$：$n<=100000$，$m<=200000$，$t<=100000$；无消失的边；分值：$10$；

$7$~$8$：$n<=100000$，$m<=200000$，$t<=100000$；无出现的边；分值：$10$；

$9$~$10$：$n<=100000$，$m<=200000$，$t<=100000$；消失的边不超过$1000$条；分值：$15$。

另外，对于所有数据，$0<u_i,u_j,v_i,v_j<=n$，$0<=w_i,w_j<=10$，$0<tm_j<=10t$，且$tm_j$互不相同；数据保证不出现正环。

## 样例 #1

### 输入

```
3 3
1 2 1
2 3 1
1 3 1
0```

### 输出

```
0
2```

## 样例 #2

### 输入

```
3 3
1 2 1
2 2 0
3 1 1
0```

### 输出

```
Continue from the last checkpoint```

## 样例 #3

### 输入

```
3 3
1 2 1
2 2 0
3 1 1
4
2 0 1 3 1
1 1 3
3 1 1
5 1 1```

### 输出

```
2
1```

# 题解

## 作者：ShineEternal (赞：9)

# 为了让大家看起来方便，于是验题人就把题解放进来了，相关题目请点击[这里](https://blog.csdn.net/kkkksc03/article/details/83239164)

## T4

题意较为复杂，详见题面。

本题操作较多，前面的测试点基本上都分别对应一个操作，因此我们逐个测试点分析。

$1$：没什么好说的……

$2$：最暴力的方法也能过，也没什么好说的。

$4$：这个也很简单，直接跑一遍最长路即可，当然裸$dijkstra$是过不了的，需要加堆优化；

由于出题人的数据生成器比较水，生成个数据都要几分钟，所以很良心地没有卡$spfa$。

$3$：这一测试点边权为0，那就省去了最长路了；

如何判断图的连通性？顺着去枚举并每次判断连通性，显然会超时；

这里标程用了笨办法：分块二分；由于删除的边不超过1000条，最多只会把操作分成1000个部分，每一部分操作都是添加边，显然有单调性！

顺着枚举每一部分的操作，在处理每个部分时二分判断连通性，可以减少判断的次数，优化操作时间。

至于删除操作，我用了树状数组+二分，树状数组存前缀和，即它是第几条边，然后二分它在原数组的标号即可。

$5-6$：经过上面一番分析大家大概也有整体思路了：先分块二分判连通性，再求最长路。

这里无消失的边，那么省去了分块与删除操作，其它与上面方法一样。

$7-8$：这里也是非常简单的，由于删除边对生成连通图没有贡献，所以操作同$4$。

$9-10$：其实就是测试点$3$+测试点$4$，用$3$的方法判断连通性后求个最长路即可。

可见，本题中其实大部分分都可以水的，而要AC，解决测试点$3$是关键。

```
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
    struct newdata
    {
        int tm,type,u,v,w,k;
    };
    struct forward_star 
    {
        int next,to,w;
    };
    int n,m,t,cnt,tot;
    forward_star edge[1100001];
    newdata work[100001];
    int head[100001];
    int heap[100001];
    int que[100001];
    int ref[100001];
    int tree[1100001];
    int dist[100001];
    bool usable[1100001];
    bool vis[100001];
void add(int u,int v,int w)
{
    cnt++;
    edge[cnt].to=v;
    edge[cnt].w=w;
    edge[cnt].next=head[u];
    head[u]=cnt;
}
void adjust_up(int now)
{
    if (now>1&&dist[heap[now]]>dist[heap[now/2]])
    {
        ref[heap[now]]=now/2;
        ref[heap[now/2]]=now;
        swap(heap[now],heap[now/2]);
        adjust_up(now/2);
    }
}
void adjust_down(int now)
{
    if (now*2+1<=tot)
    {
        int k;
        if (dist[heap[now*2+1]]>dist[heap[now*2]]) k=now*2+1; else k=now*2;
        if (dist[heap[k]]>dist[heap[now]])
        {
            ref[heap[k]]=now;
            ref[heap[now]]=k;
            swap(heap[k],heap[now]);
            adjust_down(k);
        }
    }
    else if (now*2<=tot)
    {
        if (dist[heap[now*2]]>dist[heap[now]])
        {
            ref[heap[now]]=now*2;
            ref[heap[now*2]]=now;
            swap(heap[now],heap[now*2]);
            adjust_down(now*2);
        }
    }
}
void addheap(int now)
{
    heap[++tot]=now;
    ref[now]=tot;
    adjust_up(tot);
}
void pushheap()
{
    heap[1]=heap[tot];
    ref[heap[1]]=1;
    tot--;
    adjust_down(1);
}
void dijkstra_heap(int u)
{
    memset(vis,false,sizeof(vis));
    memset(dist,255,sizeof(dist));
    dist[u]=0;
    vis[u]=true;
    addheap(u);
    while (tot!=0)
    {
        int now=heap[1];
        pushheap();
        int i=head[now];
        while (i!=0)
        {
            if (usable[i]&&i<=cnt)
                if (dist[now]+edge[i].w>dist[edge[i].to])
                {
                    dist[edge[i].to]=dist[now]+edge[i].w;
                    if (!vis[edge[i].to])
                    {
                        vis[edge[i].to]=true;
                        addheap(edge[i].to);
                    } else adjust_up(ref[edge[i].to]);
                }
            i=edge[i].next;
        }
    }
}
bool cmp(newdata i,newdata j)
{
    return i.tm<j.tm;
}
bool check(int u,int v)
{
    memset(vis,false,sizeof(vis));
    int top=1;
    que[top]=u;
    vis[u]=true; 
    while (top>0)
    {
        int now=que[top];
        top--;
        int i=head[now];
        while (i!=0)
        {
            if (i<=cnt&&usable[i])
                if (!vis[edge[i].to])
                {
                    if (edge[i].to==v) return true;
                    vis[edge[i].to]=true;
                    que[++top]=edge[i].to;
                }
            i=edge[i].next;
        }
    }
    return false;
}
void adjust(int now)
{
    int i=now;
    while (i>0)
    {
        i-=i&i;
        tree[now]+=tree[i];
    }
    tree[now]++;
}
int sum(int now)
{
    int tot=0;
    int i=now;
    while (i>0)
    {
        tot+=tree[i];
        i-=i&i;
    }
    return tot;
}
int solve(int now)
{
    int l=1;
    int r=cnt;
    while (l<r)
    {
        int mid=(l+r)>>1;
        if (sum(mid)<now)
            l=mid+1;
        else r=mid-1;
    }
    tree[l]--;
    return l;
}
int main()
{
    scanf("%d%d",&n,&m);
    for (int i=1;i<=m;i++)
    {
        int u,v,w;
        scanf("%d%d%d",&u,&v,&w);
        add(u,v,w);
        adjust(i);
    }
    memset(usable,true,sizeof(usable));
    scanf("%d",&t);
    if (t==0)
    {
        dijkstra_heap(1);
        if (dist[n]==-1)
            printf("Continue from the last checkpoint");
        else
        {
            printf("0\n");
            printf("%d",dist[n]);
        }
        return 0;
    }
    else
    {
        bool occur=false;
        bool disappear=false;
        for (int i=1;i<=t;i++)
        {
            scanf("%d%d",&work[i].tm,&work[i].type);
            if (work[i].type==0)
            { 
                scanf("%d%d%d",&work[i].u,&work[i].v,&work[i].w);
                occur=true;
            }
            else 
            {
                scanf("%d",&work[i].k);
                disappear=true;
            }
        }
        if (disappear&&!occur)
        {
            dijkstra_heap(1);
            if (dist[n]==-1)
                printf("Continue from the last checkpoint");
            else
            {
                printf("0\n");
                printf("%d",dist[n]);
            }
            return 0;
        }
        sort(work+1,work+t+1,cmp);
        if (check(1,n))
        {
            printf("0\n");
            dijkstra_heap(1);
            printf("%d",dist[n]);
            return 0;
        }
        int l=1;
        for (int i=1;i<=t;i++)
            if (work[i].type==1)
            {
                int r=i-1;
                if (l>=r)
                {
                    usable[solve(work[i].k)]=false;
                    l=i+1;
                    continue;
                }
                int cnt_first=cnt;
                int l_first=l;
                for (int j=l;j<=r;j++)
                {
                    add(work[j].u,work[j].v,work[j].w);
                    adjust(cnt);
                }
                while (l<r-1)
                {
                    int mid=(l+r)>>1;
                    cnt=cnt_first+mid-l_first+1;
                    if (check(1,n))
                        r=mid;
                    else l=mid;
                }
                cnt=cnt_first+l-l_first+1;
                if (check(1,n))
                {
                    printf("%d\n",work[l].tm);
                    dijkstra_heap(1);
                    printf("%d",dist[n]);
                    return 0;
                }
                cnt=cnt_first+r-l_first+1;
                if (check(1,n))
                {
                    printf("%d\n",work[r].tm);
                    dijkstra_heap(1);
                    printf("%d",dist[n]);
                    return 0;
                }
                cnt=cnt_first+i-l_first+1;
                usable[solve(work[i].k)]=false;
                l=i+1;
            }
        int r=t;
        int cnt_first=cnt;
        int l_first=l;
        for (int j=l;j<=r;j++)
        {
            add(work[j].u,work[j].v,work[j].w);
            adjust(cnt);
        }
        while (l<r-1)
        {
            int mid=(l+r)>>1;
            cnt=cnt_first+mid-l_first+1;
            if (check(1,n))
                r=mid;
            else l=mid;
        }
        cnt=cnt_first+l-l_first+1;
        if (check(1,n))
        {
            printf("%d\n",work[l].tm);
            dijkstra_heap(1);
            printf("%d",dist[n]);
            return 0;
        }
        cnt=cnt_first+r-l_first+1;
        if (check(1,n))
        {
            printf("%d\n",work[r].tm);
            dijkstra_heap(1);
            printf("%d",dist[n]);
            return 0;
        }
        printf("Continue from the last checkpoint");
        return 0;
    }
    return 0;
}
```


---


# 序列

## 题目背景

搬运序列

## 题目描述

有一个序列$a_n$和若干操作。

- $\mathrm{1\  l \  r \ }$ 求$a_l$到$a_r$的和 
- $\mathrm{2\  l \  r \ val \ }$ 将$a_l$到$a_r$赋值为$\mathrm{val}$ 
- $\mathrm{3\  l \  r \ val\ }$将$a_l$到$a_r$加上$\mathrm{val}$ 
- $\mathrm{4\  l_1 \  r_1 \  l_2 \  r_2 }$将$a_{l_1}$到$a_{r_1}$复制到$a_{l_2}$到$a_{r_2}$处 
- $\mathrm{5\  l_1 \  r_1 \  l_2 \  r_2 }$将$a_{l_1}$到$a_{r_1}$与$a_{l_2}$到$a_{r_2}$交换 
- $\mathrm{6\  l \  r \ }$将$a_l$到$a_r$翻转 

## 说明/提示

**请注意常数优化**

若是$\mathrm{copy}$和$\mathrm{swap}$操作，保证$r_1-l_1=r_2-l_2$且区间不重叠。


保证数据随机。

对于$30\%$的数据，保证$\ n,m\le 10^3\ $。

对于$50\%$的数据，保证$\ n,m\le 5\times 10^4\ $。

对于$70\%$的数据，保证$\ n,m\le 1.5\times 10^5\ $。

对于$100\%$的数据，保证$\ n,m\le 3\times 10^5\ ,\ 0\le a_i,\mathrm{val}\lt Mod\ $。

## 样例 #1

### 输入

```
10 10
7 1 3 2 2 4 0 1 2 2 
4 10 10 3 3
3 4 10 5
6 6 7
6 9 10
1 10 10
5 9 10 6 7
2 8 10 0
5 4 4 5 5
5 2 4 8 10
3 3 9 0```

### 输出

```
7
7 0 0 0 7 7 7 1 2 7```

# 题解

## 作者：NaCly_Fish (赞：30)

updated：这份代码现在可以通过了

建议使用 FHQTreap 或 LeafyTree 等可以分裂、合并的平衡树来实现。  
本做法用的是 FHQTreap。

这是一个时间复杂度正确的做法   
众所周知，如果没有区间赋值操作，ODT会被卡飞，不过这题可以用可持久化平衡树来实现。  

对于 $1,2,3,6$ 操作，这里就不做过多解释，做过 [【模板】可持久化文艺平衡树](https://www.luogu.org/problem/P5055) 的话可以很容易写出来。  

对于 $5$ 操作，我们钦定 $l_1<l_2$，然后暴力把序列分成 $5$ 段，把第 $2$ 段和第 $4$ 段交换位置后再合并即可。  

最后是 $4$ 操作，还是分成 $5$ 个区间，要被覆盖掉的区间就扔掉，然后从另外一个区间的根节点直接复制一份，再合并回去就好了。

这题需要可持久化的原因，就是 $4$ 操作要复制节点。

由于此题的 $n,m$ 达到了 $3\times10^5$，所以需要定期重构，以节省空间。  
数组最大只能开到 $4\times10^6$，所以只要发现节点数多于 $3.6\times10^6$ 就线性重构一波。

细节非常多，很不好写。  
代码如下：  

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<ctime>
#define N 4000003
#define ls son[u][0]
#define rs son[u][1]
#define reg register
#define ll long long
#define p 1000000007
#define mid ((l+r)>>1)
using namespace std;

inline void read(int &x){
    x = 0;
    char c = getchar();
    while(c<'0'||c>'9') c = getchar();
    while(c>='0'&&c<='9'){
        x = (x<<3)+(x<<1)+(c^48);
        c = getchar();
    }
}

void print(int x){
	if(x>9) print(x/10);
	putchar(x%10+'0');
}

inline int add(int x,int y){
    return x+y>=p?x+y-p:x+y;
}

int a[N],son[N][2],size[N];
int sum[N],taga[N],tagc[N],b[300003];
bool rev[N];
int n,q,rt,cnt,tp;

inline int neww(int x){
    int u = ++cnt;
	size[u] = 1;
    a[u] = sum[u] = x;
    tagc[u] = -1;
    ls = rs = taga[u] = rev[u] = 0;
    return cnt;
}

inline int copy(int u){
    int v = ++cnt;
    a[v] = a[u],sum[v] = sum[u];
    son[v][0] = ls,son[v][1] = rs;
    rev[v] = rev[u];
    size[v] = size[u];
    taga[v] = taga[u];
    tagc[v] = tagc[u];
    return v;
}

inline void pushup(int u){
    size[u] = size[ls]+size[rs]+1;
    sum[u] = add(add(sum[ls],sum[rs]),a[u]);
}

inline void pushr(int u){
    swap(ls,rs);
    rev[u] ^= 1;
}

inline void pusha(int u,int k){
    a[u] = add(a[u],k);
    taga[u] = add(taga[u],k);
    sum[u] = (sum[u]+(ll)size[u]*k)%p;
}

inline void pushc(int u,int k){
    taga[u] = 0;
    tagc[u] = a[u] = k;
    sum[u] = (ll)size[u]*k%p;
}

inline void pushdown(int u){
    if(tagc[u]!=-1||taga[u]||rev[u]){
        if(ls) ls = copy(ls);
        if(rs) rs = copy(rs);
    }
    if(tagc[u]!=-1){
        if(ls) pushc(ls,tagc[u]);
        if(rs) pushc(rs,tagc[u]);
        tagc[u] = -1;
    }
    if(taga[u]){
        if(ls) pusha(ls,taga[u]);
        if(rs) pusha(rs,taga[u]);
        taga[u] = 0;
    }
    if(!rev[u]) return;
    if(ls) pushr(ls);
    if(rs) pushr(rs);
    rev[u] = 0;
}

int merge(int u,int v){
    if(!u||!v) return u|v;
    if(rand()%(size[u]+size[v])<size[u]){
        pushdown(u),u = copy(u);
        son[u][1] = merge(son[u][1],v);
        pushup(u);
        return u;
    }else{
        pushdown(v),v = copy(v);
        son[v][0] = merge(u,son[v][0]);
        pushup(v);
        return v;
    }
}

int merge1(int u,int v){
    if(!u||!v) return u|v;
    if(rand()%(size[u]+size[v])<size[u]){
        son[u][1] = merge1(son[u][1],v);
        pushup(u);
        return u;
    }else{
        son[v][0] = merge1(u,son[v][0]);
        pushup(v);
        return v;
    }
}

void split(int cur,int k,int &u,int &v){
    if(!cur){
        u = v = 0;
        return;
    }
    pushdown(cur);
    if(size[son[cur][0]]<k){
        u = copy(cur);
        split(son[u][1],k-size[son[u][0]]-1,son[u][1],v);
        pushup(u);
    }else{
        v = copy(cur);
        split(son[v][0],k,u,son[v][0]);
        pushup(v);
    }
}

inline void reverse(int l,int r){
    int x,y,z;
    split(rt,l-1,x,y);
    split(y,r-l+1,y,z);
    y = copy(y);
    pushr(y);
    rt = merge(merge(x,y),z);
}

inline void change(int l,int r,int k){
    int x,y,z;
    split(rt,l-1,x,y);
    split(y,r-l+1,y,z);
    y = copy(y);
    pushc(y,k);
    rt = merge(merge(x,y),z);
}

inline void modify(int l,int r,int k){
    int x,y,z;
    split(rt,l-1,x,y);
    split(y,r-l+1,y,z);
    y = copy(y);
    pusha(y,k);
    rt = merge(merge(x,y),z);
}

inline void swap(int l1,int r1,int l2,int r2){
    int v,w,x,y,z;
    if(l1>l2){
        swap(l1,l2);
        swap(r1,r2);
    }
    split(rt,l1-1,v,w);
    split(w,r1-l1+1,w,x);
    split(x,l2-r1-1,x,y);
    split(y,r2-l2+1,y,z);
    rt = merge(merge(merge(merge(v,y),x),w),z);
}

inline void paste(int l1,int r1,int l2,int r2){
    bool flag = false;
    int v,w,x,y,z;
    if(l1>l2){
        swap(l1,l2);
        swap(r1,r2);
        flag = true;
    }
    split(rt,l1-1,v,w);
    split(w,r1-l1+1,w,x);
    split(x,l2-r1-1,x,y);
    split(y,r2-l2+1,y,z);
    if(flag) w = copy(y);
    else y = copy(w);
    rt = merge(merge(merge(merge(v,w),x),y),z);
}

inline int query(int l,int r){
    int x,y,z,res;
    split(rt,l-1,x,y);
    split(y,r-l+1,y,z);
    res = sum[y];
    rt = merge(merge(x,y),z);
    return res;
}

void dfs(int u){
    pushdown(u);
    if(ls) dfs(ls);
    b[++tp] = a[u];
    if(rs) dfs(rs);
}

int build(int l,int r){
	if(l>r) return 0;
	int u = neww(b[mid]);	
	ls = build(l,mid-1);
	rs = build(mid+1,r);
	pushup(u);
	return u;
}

int main(){
    srand(time(0));
    int op,l1,r1,l2,r2,k;
    read(n),read(q);
    for(reg int i=1;i<=n;++i) read(b[i]);
    rt = build(1,n);
    while(q--){
        read(op),read(l1),read(r1);
        if(op==1){
        	print(query(l1,r1));
        	putchar('\n');
		}else if(op==2){
            read(k);
            change(l1,r1,k);
        }else if(op==3){
            read(k);
            modify(l1,r1,k);
        }else if(op==4){
            read(l2),read(r2);
            paste(l1,r1,l2,r2);
        }else if(op==5){
            read(l2),read(r2);
            swap(l1,r1,l2,r2);
        }else reverse(l1,r1);
        if(cnt>3600000){
        	tp = 0;
        	dfs(rt);
        	rt = cnt = 0;
        	rt = build(1,n);
		}
    }
    tp = 0;
    dfs(rt);
    for(reg int i=1;i<=n;++i) print(b[i]),putchar(' ');
    return 0;
}
```

---

## 作者：Holy_Push (赞：23)

昨天晚上学的珂朵莉树，今天来敲一敲$Q\mu Q$（怎么说这也是一道珂朵莉树模板题了）

实际上珂朵莉树是一个暴力数据结构，其复杂度并没有保证并且很容易被卡，但是人家在随机情况下跑得快啊$Q\omega Q$，而且能做很多其他数据结构很难维护的东西。

当然，如果你没有学过$set$，建议先学习$set$的用法后继续食用。

## 什么是珂朵莉树
珂朵莉树（我貌似没有看出来它跟树有什么关系$QnQ$）是一种利用$set$来维护区间信息的数据结构，笼统地讲，珂朵莉树就是**将原序列分成了若干块，每一块中的数都相同，用三元组($l,r,sum)$表示**，例如原序列是$2,3,3,3,2,1$，则它在珂朵莉树中的结点可能是$(1,1,2),(2,4,3),(5,5,2),(6,6,1)$。$(2,4,3)$即表示$[2,4]$区间内的所有数都是$3$。我们以左端点$l$为关键字，放到$set$里进行维护。

可见这样的数据结构很容易被卡，但能用珂朵莉树做的题目基本有下列两项条件：

1. 数据随机，出题人不会恶意卡你
2. 有推平操作，即将$[l,r]$中的所有数赋值为$val$这样的操作

有了推平操作，我们才能保证珂朵莉树中的节点个数不会太多。
```cpp
struct node
{
	int l,r;mutable ll sum;
	bool operator <(const node&x) const {return l<x.l;}
} a[N],b[N];
set<node>S;
```
这个$mutable$是什么呢？一般的$set$是不允许修改内部元素的，但如果我们加上了$mutable$，我们就可以做到实时修改这个$sum$的数值。

## 如何实现珂朵莉树

### $Part1\quad split$操作
在修改和查询的时候难道要像分块分两种情况整块和边角那样做吗？好麻烦啊$QrQ$。

$Split$操作是珂朵莉树的重点部分，简单的说，就是将我们要询问的区间$[l,r]$给独立出来。

**给定$l,r$,将$l$和$r$分别拆成两个集合的开头和结尾**

还是以$2,3,3,3,2,1$为例，我们如果要查询$[3,5]$这一个区间，该怎么办呢？

我们发现，在珂朵莉树里有这样两个节点$(2,4,3),(5,5,2)$，包含了$[3,5]$这个区间，但是多出来一个$2$令人很不爽，那么我们把$(2,4,3)$分成$(2,2,3)$和$(3,4,3)$，这样我们只要对$(3,4,3),(5,5,2)$这两个节点操作就可以了，这样就很方便了。

那具体怎么操作呢？（注：我的$split$与网上其他的写法不太一样）

由于我们的节点以左端点为关键字存在$set$里（方便起见，下面所有的$set$都用$S$表示），所以我们能很快找到任意点$x$所在的块，即$--S.upper\_bound(\{x,x,0\})$。下面用$p$来表示定位到的集合。

然后我们要做两步：拆$l$，和拆$r$。

先说拆$l$。如果$p.l≠l$，即$l$不是任何一块的起始位置，那么我们就要把它拆开，拆成$\{p.l,l-1,p.sum\}$和$\{l,p.r,p.sum\}$。这样$l$就成为了后面一块的起始位置。

再说拆$r$。如果$p.r≠r$，即$r$不是任何一块的结束位置，那么我们就要把它拆成$\{p.l,r,p.sum\}$和$\{r+1,p.r,p.sum\}$。这样，$r$就成了前面一块的结束位置。

```cpp
void split(int l,int r)
{
	set<node>::iterator it=--S.upper_bound({l,l,0});
	if ((*it).l!=l) 
	{
		node p=*it;
		S.erase(it);S.insert({p.l,l-1,p.sum});S.insert({l,p.r,p.sum});
	}
	it=--S.upper_bound({r,r,0});
	if ((*it).r!=r)
	{
		node p=*it;
		S.erase(it);S.insert({p.l,r,p.sum});S.insert({r+1,p.r,p.sum});
	}
}
```

拆完了，那么剩下的部分就很好做了！都只要暴力找就行了。注意到数据随机，并且有推平操作，所以暴力找的总次数不会太多。

### $Part2\quad assign$操作

$assign$就是传说中保持珂朵莉树复杂度玄学正确的推平操作。

**给定$l,r,val$，将$[l,r]$内的所有数都修改为$val$**

首先方便操作，我们$split(l,r)$一波。然后我们找到$l$和$r$所在的块，将它们删除（这一步可以用$S.erase(it1,it2)$完成），然后将$\{l,r,val\}$直接插入即可。注意，$erase$的参数是左闭右开的，所以第二个参数我们需要使用$upper\_bound$来定位
```cpp
void assign(int l,int r,int val)
{
	split(l,r);
	S.erase(S.lower_bound({l,l,0}),S.upper_bound({r,r,0}));
	S.insert({l,r,val});
}
```


最重要的两个部分讲完了！接下来就可以乱搞了！
### $Part3\quad query$操作
**给定$l,r$,求出$[l,r]$的和**

先$split(l,r)$一波，然后从$l$所在块暴力跳到$r$所在块，加上中间的数的和就行了。对于一个节点$(l,r,sum)$，它每个数都是$sum$，一共有$r-l+1$个，所以这个节点对答案的贡献就是$sum×(r-l+1)$

```cpp
int query(int l,int r)
{
	ll ans=0;split(l,r);
	set<node>::iterator it=S.lower_bound({l,l,0});
	for (;it!=S.end()&&(*it).r<=r;++it) ans=(ans+(*it).sum*((*it).r-(*it).l+1))%mo;
	return ans;
}
```

### $Part4\quad add$操作
**给定$l,r,val$,将$[l,r]$的每个数都加上$val$**

显然，相同的数同时加上一个数后，它们仍然相同，所以我们在$split(l,r)$后，按照$query$的方法暴力跳块，跳到的块$sum$加上$val$即可（再次提醒别忘了在定义的时候$sum$前加上$mutable$）。
```cpp
void add(int l,int r,int val)
{
	split(l,r);
	set<node>::iterator it=S.lower_bound({l,l,0});
	for (;it!=S.end()&&(*it).r<=r;++it) (*it).sum=((*it).sum+val)%mo;
}
```

以上是珂朵莉树的基本操作，接下来是本题的毒瘤新操作

### $Part5\quad reverse$操作
**给定$l,r$，将区间$[l,r]$翻转**

第一步当然是$split$一波，然后考虑如何操作。

随便找来个序列，比如$2,2,4,5,5,5,5,5,4,4,5,5$，其在珂朵莉树上的节点为$(1,2,2)(3,3,4)(4,8,5)(9,10,4)(11,12,5)$。

把它翻转一下，变成$5,5,4,4,5,5,5,5,5,4,2,2$，其在珂朵莉树上的节点为$(1,2,5)(3,4,4)(5,9,5)(10,10,4)(11,12,2)$。你发现规律了吗？

我们随便取两个对应的段，$(1,2,2)$变成了$(11,12,2)$，$(4,8,5)$变成了$(5,9,5)……$发现$1+12=2+11=13$，$4+9=8+5=13$，也就是说，翻转之前的$l$变成了翻转之后的$r$，且它们的和为序列的长度$+1$，同样的，翻转之前的$r$变成了翻转之后的$l$，且它们的和同样等于序列的长度$+1$。这样一来，我们可以把这一段取出来并删掉，然后改一下$l$和$r$的值再插回$S$即可。

```cpp
void reverse(int l,int r)
{
	split(l,r);
	set<node>::iterator it=S.lower_bound({l,l,0});
	int len=0;
	for (;it!=S.end()&&(*it).r<=r;++it) a[++len]=*it;
	S.erase(S.lower_bound({l,l,0}),S.upper_bound({r,r,0}));
	for (int i=len;i;--i) S.insert({l+r-a[i].r,l+r-a[i].l,a[i].sum});
}
```

### $Part6\quad copy$操作
**给定长度相等的两个区间$[l_1,r_1],[l_2,r_2]$，将$[l_1,r_1]$区间的信息复制到$[l_2,r_2]$上**

同样的道理，先$split(l_1,r_1),split(l_2,r_2)$。

复制操作？我们是不是可以想象成先把$[l_2,r_2]$的信息删掉，再把$[l_1,r_1]$的信息放到上面去？

显然是可以的。我们只要把某个$∈[l_1,r_1]$的节点$(l,r,val)$的$l$和$r$改一下再插入即可。改成什么呢？

考虑相对位置。假设$x$复制到了$y$这个位置，那么显然$x$相对$l_1$的位置与$y$相对$l_2$的位置相同，即$x-l_1=y-l_2$。那么我们就很容易得出，$(l,r,val)$复制之后变成了$(l_2+l-l_1,l_2+r-l_1,val)$。

```cpp
void copy(int l1,int r1,int l2,int r2)
{
	split(l1,r1);split(l2,r2);
	S.erase(S.lower_bound({l2,l2,0}),S.upper_bound({r2,r2,0}));
	set<node>::iterator it=S.lower_bound({l1,l1,0});
	for (;it!=S.end()&&(*it).r<=r1;++it) S.insert({l2+(*it).l-l1,l2+(*it).r-l1,(*it).sum});
}
```
### $Part7\quad swap$操作
**给定长度相等的两个区间$[l_1,r_1],[l_2,r_2]$，将$[l_1,r_1]$区间的信息与$[l_2,r_2]$区间的信息交换**

如果换一下描述方式的话：

**给定长度相等的两个区间$[l_1,r_1],[l_2,r_2]$，将原$[l_1,r_1]$区间的信息复制到$[l_2,r_2]$上，将原$[l_2,r_2]$的信息复制到$[l_1,r_1]$上**

是不是明朗了很多呢？实际上考虑我们以前$swap$的过程，交换本质上就是几个复制的结合。

考虑我们以前$swap$是怎么做的：$t=a,a=b,b=t$。我们找来了第三个值$t$来做中介。这里也一样，我们可以找一个数组来做中介，将$[l_1,r_1]$的信息先保存下来，然后做两遍复制。

当然你还可以这样做交换：$t_1=a,t_2=b,a=t_2,b=t_1$。这样也能完成交换。也就是说，我们可以找两个数组分别存$[l_1,r_1]$和$[l_2,r_2]$，然后分别插入即可。我用的是这一种方法，比较清晰。

```cpp
void swap(int l1,int r1,int l2,int r2)
{
	split(l1,r1);split(l2,r2);
	set<node>::iterator it=S.lower_bound({l1,l1,0});
	int len1=0,len2=0;
	for (;it!=S.end()&&(*it).r<=r1;++it) a[++len1]=*it;
	it=S.lower_bound({l2,l2,0});
	for (;it!=S.end()&&(*it).r<=r2;++it) b[++len2]=*it;
	S.erase(S.lower_bound({l1,l1,0}),S.upper_bound({r1,r1,0}));
	S.erase(S.lower_bound({l2,l2,0}),S.upper_bound({r2,r2,0}));
	for (int i=1;i<=len1;i++) S.insert({l2+a[i].l-l1,l2+a[i].r-l1,a[i].sum});
	for (int i=1;i<=len2;i++) S.insert({l1+b[i].l-l2,l1+b[i].r-l2,b[i].sum});
}
```

### $Part8\quad write$操作
**输出原序列**

这个我就不用说了吧$……set$基本操作。

然后所有的操作都被我们做完啦！撒花！

最后膜一膜用$treap$ $AC$本题并且爆踩第二名的$sooke$巨佬。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int mo=1e9+7,N=500000;

int n,Q;

void read(int &x)
{
	x=0;char s=getchar();
	while (!isdigit(s)) s=getchar();
	while (isdigit(s)) {x=(x<<1)+(x<<3)+s-'0';s=getchar();}
}

struct node
{
	int l,r;mutable ll sum;
	bool operator <(const node&x) const {return l<x.l;}
} a[N],b[N];
set<node>S;

void split(int l,int r)
{
	set<node>::iterator it=--S.upper_bound({l,l,0});
	if ((*it).l!=l) 
	{
		node p=*it;
		S.erase(it);S.insert({p.l,l-1,p.sum});S.insert({l,p.r,p.sum});
	}
	it=--S.upper_bound({r,r,0});
	if ((*it).r!=r)
	{
		node p=*it;
		S.erase(it);S.insert({p.l,r,p.sum});S.insert({r+1,p.r,p.sum});
	}
}

int query(int l,int r)
{
	ll ans=0;split(l,r);
	set<node>::iterator it=S.lower_bound({l,l,0});
	for (;it!=S.end()&&(*it).r<=r;++it) ans=(ans+(*it).sum*((*it).r-(*it).l+1))%mo;
	return ans;
}

void assign(int l,int r,int val)
{
	split(l,r);
	S.erase(S.lower_bound({l,l,0}),S.upper_bound({r,r,0}));
	S.insert({l,r,val});
}

void add(int l,int r,int val)
{
	split(l,r);
	set<node>::iterator it=S.lower_bound({l,l,0});
	for (;it!=S.end()&&(*it).r<=r;++it) (*it).sum=((*it).sum+val)%mo;
}

void copy(int l1,int r1,int l2,int r2)
{
	split(l1,r1);split(l2,r2);
	S.erase(S.lower_bound({l2,l2,0}),S.upper_bound({r2,r2,0}));
	set<node>::iterator it=S.lower_bound({l1,l1,0});
	for (;it!=S.end()&&(*it).r<=r1;++it) S.insert({l2+(*it).l-l1,l2+(*it).r-l1,(*it).sum});
}

void swap(int l1,int r1,int l2,int r2)
{
	split(l1,r1);split(l2,r2);
	set<node>::iterator it=S.lower_bound({l1,l1,0});
	int len1=0,len2=0;
	for (;it!=S.end()&&(*it).r<=r1;++it) a[++len1]=*it;
	it=S.lower_bound({l2,l2,0});
	for (;it!=S.end()&&(*it).r<=r2;++it) b[++len2]=*it;
	S.erase(S.lower_bound({l1,l1,0}),S.upper_bound({r1,r1,0}));
	S.erase(S.lower_bound({l2,l2,0}),S.upper_bound({r2,r2,0}));
	for (int i=1;i<=len1;i++) S.insert({l2+a[i].l-l1,l2+a[i].r-l1,a[i].sum});
	for (int i=1;i<=len2;i++) S.insert({l1+b[i].l-l2,l1+b[i].r-l2,b[i].sum});
}

void reverse(int l,int r)
{
	split(l,r);
	set<node>::iterator it=S.lower_bound({l,l,0});
	int len=0;
	for (;it!=S.end()&&(*it).r<=r;++it) a[++len]=*it;
	S.erase(S.lower_bound({l,l,0}),S.upper_bound({r,r,0}));
	for (int i=len;i;--i) S.insert({l+r-a[i].r,l+r-a[i].l,a[i].sum});
}

void write()
{
	set<node>::iterator it=S.begin();
	for (;it!=S.end();++it)
		for (int i=(*it).l;i<=(*it).r;i++)
			printf("%d ",(*it).sum);
}

int main()
{
	read(n);read(Q);
	for (int i=1;i<=n;i++) {int x;read(x);S.insert({i,i,x});}
	while (Q--)
	{
		int opt,l,r,l1,r1,l2,r2,val;
		read(opt);
		if (opt==1) {read(l);read(r);printf("%d\n",query(l,r));}
		if (opt==2) {read(l);read(r);read(val);assign(l,r,val);}
		if (opt==3) {read(l);read(r);read(val);add(l,r,val);}
		if (opt==4) {read(l1);read(r1);read(l2);read(r2);copy(l1,r1,l2,r2);}
		if (opt==5) {read(l1);read(r1);read(l2);read(r2);swap(l1,r1,l2,r2);}
		if (opt==6) {read(l);read(r);reverse(l,r);}
	}
	write();
}
```

---

## 作者：Leianha (赞：15)

## ODT

这道题目太毒瘤啦，经过了无数遍的TLE、WA，和RE(TAT)，我终于了解了珂朵莉树的强（R）大（E）,我会详细的介绍关于TLE，WA和RE的原因。

首先我们看到区间赋值操作和保证数据随机，我们的第一直觉肯定是幸福的珂朵莉树啦，虽然在刻意构造的数据下她的时间复杂度是错误的，但是在随机数据下她的表现十分优秀，甚至可以碾压其他数据结构。

1.首先是split操作，这是ODT的基本操作，可以将完整的区间拆分开来。但应注意的是，

```cpp
if(it!=s.end()&&it->l==pos)return it;
```
所以我们需要在n的后面加上一个数防止出锅，
```cpp
s.insert((node){n+1,n+1,(LL)0});
```
2.区间加、求和、推平，这些都是ODT模板上的操作，注意一下及时取模就珂以了。

3.让我们来看看新的操作：区间复制：根据zh_dou大佬的讲解，我们知道过期的迭代器是不能使用的，否则直接原地起飞。所以我们的做法就是将我们需要复制的区间先存起来，然后再删除了对应的区间后再将区间复制过去。
```cpp
void fuzhi(int l1,int r1,int l2,int r2)
{
	IT it1r=split(r1+1),it1l=split(l1);
	int len=0;
	for(IT it=it1l;it!=it1r;++it)
	{
		a[++len].l=it->l;
		a[len].r=it->r;
		a[len].val=it->val;
	}
	IT it2r=split(r2+1),it2l=split(l2);
	s.erase(it2l,it2r);
	for(int i=1;i<=len;++i)
	{
		s.insert(node(a[i].l - l1 + l2,a[i].r - l1 + l2,a[i].val));
	}
}
```
4.新操作：区间翻转：还是根据迭代器的一套理论，我们应该先存起来在进行操作：

```cpp
void fanzhuan(int l,int r)
{
	if(l>r)swap(l,r);
	IT it2=split(r+1),it1=split(l);
	int len=0;
	for(IT it=it1;it!=it2;++it)
	{
		a[++len].l=it->l;
		a[len].r=it->r;
		a[len].val=it->val;
	}
	s.erase(it1,it2);
	for(int i=1;i<=len;++i)
	{
		s.insert(node(r-a[i].r+l, r-a[i].l+l, a[i].val));
	}
}
```
5.~~毒瘤~~交换操作：这可能是最毒瘤的一种操作了，RE到我直接自闭。我们可以想像一下我们交换两个数的情景，就会发现这也同样适用于区间的交换，为了 ~~好调bug~~ 简洁明了，我用了两个数组来完成：
```cpp
void my_swap(int l1,int r1,int l2,int r2)
{
	if(l1>l2){swap(l1,l2);swap(r1,r2);}
	int len1=0,len2=0;
	IT it1r=split(r1+1),it1l=split(l1);
	for(IT it=it1l;it!=it1r;++it)
	{
		a[++len1].l=it->l;
		a[len1].r=it->r;
		a[len1].val=it->val;
	}
	IT it2r=split(r2+1),it2l=split(l2);
	for(IT it=it2l;it!=it2r;++it)
	{
		b[++len2].l=it->l;
		b[len2].r=it->r;
		b[len2].val=it->val;
	}
	it1r=split(r1+1),it1l=split(l1);
	s.erase(it1l,it1r);
	it2r=split(r2+1),it2l=split(l2);
	s.erase(it2l,it2r);
	for(int i=1;i<=len2;++i)s.insert(node(b[i].l - l2 + l1,b[i].r - l2 + l1,b[i].val));
	for(int i=1;i<=len1;++i)s.insert(node(a[i].l - l1 + l2,a[i].r - l1 + l2,a[i].val));
}
```
然后每个数都要输出的话只用遍历一遍set就珂以啦~（当然你也珂以用来中间调试用）。

```cpp
void pr()
{
	for(IT it=s.begin();it!=s.end()&&it->r<=n;++it)
	{
		for(int i=it->l;i<=it->r;++i)printf("%lld ",it->val);
	}
}
```


最后说几点需要注意的事情

1.过期的迭代器千万不要使用，否则自己怎么RE的都不知道，具体的操作就应该是在每次使用迭代器前就应该split一下，防止出锅。

2.遍历的时候最好再开一个迭代器千万不要这样写：

```cpp
s.erase(it1,it2);
for(;it1!=it2;++it1)
{
	s.insert(node(XXX,XXX,XXX));
}
```
不要问我为什么我知道(TAT).

3.要开long long，并且还需要及时取模。

4.函数传参不要传错。

5.最好在n+1的位置上加上一个数(珂以是0、233或者666，随你的心意啦)。

6.需要开O2，否则就死掉了QAQ

最后献上我的完整代码

```cpp
#include<iostream>
#include<cstdio>
#include<set>
#define LL long long
#define IT set<node>::iterator
using namespace std;
int n,q,opt,l1,r1,l2,r2,l,r;
LL val,x;
const int mod=1e9+7,N=500010;
inline int read()
{
	register int x=0,y=1;register char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')y=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return x*y;
}
struct node
{
	int l,r;
	mutable long long val;
	node(int L=0,int R=-1,int V=0):l(L),r(R),val(V){}
	friend bool operator <(const node &a,const node &b){return a.l<b.l;} 
//	int len(){return r-l+1;}
};
node a[N],b[N];
set<node>s;
IT split(int pos)
{
	IT it=s.lower_bound(node(pos));
	if(it!=s.end()&&it->l==pos)return it;
	it--;
	int ll=it->l,lr=it->r;
	LL lv=it->val;
	s.erase(it);
	s.insert(node(ll,pos-1,lv));
	return s.insert(node(pos,lr,lv)).first;
}
LL ask(int l,int r)
{
	IT it2=split(r+1),it1=split(l);
	LL ans=0;
	for(IT it=it1;it!=it2;++it)
		(ans+=(LL)(it->r - it->l + 1)*it->val)%=mod;
	return ans;
}
void add(int l,int r,LL val)
{
	IT it2=split(r+1),it1=split(l);
	for(IT it=it1;it!=it2;++it)(it->val+=val)%=mod;
}
void tuiping(int l,int r,LL val)
{
	IT it2=split(r+1),it1=split(l);
	s.erase(it1,it2);
	s.insert(node(l,r,val));
}
void fuzhi(int l1,int r1,int l2,int r2)
{
	IT it1r=split(r1+1),it1l=split(l1);
	int len=0;
	for(IT it=it1l;it!=it1r;++it)
	{
		a[++len].l=it->l;
		a[len].r=it->r;
		a[len].val=it->val;
	}
	IT it2r=split(r2+1),it2l=split(l2);
	s.erase(it2l,it2r);
	for(int i=1;i<=len;++i)
	{
		s.insert(node(a[i].l - l1 + l2,a[i].r - l1 + l2,a[i].val));
	}
}
void pr()
{
	for(IT it=s.begin();it!=s.end()&&it->r<=n;++it)
	{
		for(int i=it->l;i<=it->r;++i)printf("%lld ",it->val);
	}
}
void my_swap(int l1,int r1,int l2,int r2)
{
	if(l1>l2){swap(l1,l2);swap(r1,r2);}
	int len1=0,len2=0;
	IT it1r=split(r1+1),it1l=split(l1);
	for(IT it=it1l;it!=it1r;++it)
	{
		a[++len1].l=it->l;
		a[len1].r=it->r;
		a[len1].val=it->val;
	}
	IT it2r=split(r2+1),it2l=split(l2);
	for(IT it=it2l;it!=it2r;++it)
	{
		b[++len2].l=it->l;
		b[len2].r=it->r;
		b[len2].val=it->val;
	}
	it1r=split(r1+1),it1l=split(l1);
	s.erase(it1l,it1r);
	it2r=split(r2+1),it2l=split(l2);
	s.erase(it2l,it2r);
	for(int i=1;i<=len2;++i)s.insert(node(b[i].l - l2 + l1,b[i].r - l2 + l1,b[i].val));
	for(int i=1;i<=len1;++i)s.insert(node(a[i].l - l1 + l2,a[i].r - l1 + l2,a[i].val));
}	
void fanzhuan(int l,int r)
{
	if(l>r)swap(l,r);
	IT it2=split(r+1),it1=split(l);
	int len=0;
	for(IT it=it1;it!=it2;++it)
	{
		a[++len].l=it->l;
		a[len].r=it->r;
		a[len].val=it->val;
	}
	s.erase(it1,it2);
	for(int i=1;i<=len;++i)
	{
		s.insert(node(r-a[i].r+l, r-a[i].l+l, a[i].val));
	}
}
int main()
{
	n=read(),q=read();
	for(int i=1;i<=n;++i)
	{
		scanf("%lld",&x);
		s.insert(node(i,i,x));
	}
	s.insert((node){n+1,n+1,(LL)0});
	while(q--)
	{
		opt=read();
		if(opt==1)
		{
			l=read();r=read();
			printf("%lld\n",ask(l,r));
		}
		if(opt==2)
		{
			l=read();r=read();scanf("%lld",&val);
			tuiping(l,r,val);
		}
		if(opt==3)
		{
			l=read();r=read();scanf("%lld",&val);
			add(l,r,val);
		}
		if(opt==4)
		{
			l1=read();r1=read();l2=read();r2=read();
			fuzhi(l1,r1,l2,r2);
		}
		if(opt==5)
		{
			l1=read();r1=read();l2=read();r2=read();
			my_swap(l1,r1,l2,r2);
		}
		if(opt==6)
		{
			l=read();r=read();
			fanzhuan(l,r);
		}
	}
	pr();
	return 0;
}
```


---

## 作者：灼眼的夏娜 (赞：8)

### 来看看这道~~把我调出心病的毒瘤~~题

对于总共六种操作，前三种为珂朵莉树的正常操作，即区间加法，

区间求和，区间推平。

对于这三种，把板子套上去就好啦（或者如果你还不造什么是珂朵莉树，请

先出门左转至  [**中国珂学院**](https://www.chtholly.ac.cn/)再出门右转至[**珂朵莉树入门**](https://www.mina.moe/archives/9695)）学习一下

好了，进入正题：

前面也说了，三个基本操作，不必多说。

下面看另外三个：

### $operator$ 4 $copy$

把一段区间复制到另一段区间上，我们可以直接复制一遍，把另一段区间删

掉，再重新安上去。

```cpp
inline void copy(int l1,int r1,int l2,int r2) {
    IT itr1 = split(r1 + 1),itl1 = split(l1);
    int len = 0;//复制区间
    for(IT it = itl1;it != itr1;++ it) {
        A[++len].l = it->l;
        A[len].r = it->r;
        A[len].v = it->v;
    }
    IT itr2 = split(r2 + 1),itl2 = split(l2);
    s.erase(itl2, itr2);
    for(R int i = 1;i <= len;++ i)//重新安上去
        s.insert(node(A[i].l - l1 + l2, A[i].r - l1 + l2, A[i].v));
}
```

### $operator$ 5 $change$

可以说是我见过的最毒的珂朵莉树操作了

假如说是两个数交换，很简单吧，$c=a$，$d = b$，$a=d$，$b = c$

那区间的话，也类比以上操作，先复制两端区间，将两段区间删去，再重新

赋值，其实和$copy$大同小异，但还是有不少细节的

大概这是这道题的最大价值了，可以类比上面的代码写出来

### $operator$ 6 $reverse$

相对于操作5，它还是比较简单的，可以先复制一遍，删掉原区间后再反着

赋回去就好啦

```cpp
inline void reverse(int l,int r) {
    if(l > r) swap(l, r);
    IT itr = split(r + 1),itl = split(l);
    int len = 0;
    for(IT it = itl;it != itr;++ it) {
        A[++len].l = it->l;
        A[len].r = it->r;
        A[len].v = it->v;
    }
    s.erase(itl,itr);
    for(R int i = 1;i <= len;++ i)
        s.insert(node(r - A[i].r + l, r - A[i].l + l, A[i].v));
}
```

**注意本题要开$longlong$否者你就会原地爆炸**

**对于迭代器$itl,itr,it$一定要搞清楚它什么变化，因为变了之后它就算废**

**了，这时你需要重新$split$，这是我吸取了我同桌的惨痛教训后得知的**

大体就完了，再说些别的:

一般看到了区间推平（也就是区间全覆盖）我们是可以考虑珂朵莉树的

通常她会有其他需要你动动脑子的操作（~~比如刚刚那个毒瘤~~）一般她会

和vector结合~~因为vector啥都能干~~，应该可以在其他人的代码中看到，

当然我这边没用而已。

有人总是质疑珂朵莉树的复杂度，我只能说，想卡珂朵莉树其实很简单

只要你稍稍用点心出组数据，她就可以退化成$O(n^{2})$，但是在随机数据

下，我敢保证，**她能碾爆其他一切数据结构**，而且她可以资瓷许多其

它数据结构维护不了的东西，刷题多了就知道了。

因此她有利有弊，看着用就好了

最后附上完整代码,庆祝我过了这道大毒瘤

## code

```cpp
#include<bits/stdc++.h>
#define R register
#define IT set<node>::iterator

using namespace std;
typedef long long LL;
const int p = 1e9+7;
const int N = 5e5+5;
int n,m;
struct node {
	int l,r;
	mutable LL v;
	node(int _l = 0,int _r = -1,int _v = 0) : l(_l),r(_r),v(_v) {}
	bool operator < (const node &o) const {
		return l < o.l;
	}
}A[N],B[N];

set<node> s;

IT split(int pos) {
	IT it = s.lower_bound(node(pos));
	if(it != s.end() && it->l == pos) return it;
	-- it;
	int l = it->l,r = it->r;
	LL v = it->v;
	s.erase(it);
	s.insert(node(l, pos - 1, v));
	return s.insert(node(pos, r, v)).first;
}

inline void assign(int l,int r,LL v) {
	IT itr = split(r + 1),itl = split(l);
	s.erase(itl, itr);
	s.insert(node(l, r, v));
}

inline void add(int l,int r,LL v) {
	IT itr = split(r + 1),itl = split(l);
	for(;itl != itr;++ itl) (itl->v += v) %= p;
}

inline void copy(int l1,int r1,int l2,int r2) {
    IT itr1 = split(r1 + 1),itl1 = split(l1);
    int len = 0;
    for(IT it = itl1;it != itr1;++ it) {
        A[++len].l = it->l;
        A[len].r = it->r;
        A[len].v = it->v;
    }
    IT itr2 = split(r2 + 1),itl2 = split(l2);
    s.erase(itl2, itr2);
    for(R int i = 1;i <= len;++ i)
        s.insert(node(A[i].l - l1 + l2, A[i].r - l1 + l2, A[i].v));
}

inline void change(int l1,int r1,int l2,int r2) {
	if(l1 > l2) { swap(l1, l2);swap(r1, r2); }
	int len1 = 0,len2 = 0;
	IT itr1 = split(r1 + 1),itl1 = split(l1);
	for(IT it = itl1;it != itr1;++ it) {
		A[++len1].l = it->l;
		A[len1].r = it->r;
		A[len1].v = it->v;
	}
	s.erase(itl1,itr1);
	IT itr2 = split(r2 + 1),itl2 = split(l2);
	for(IT it = itl2;it != itr2;++ it) {
		B[++len2].l = it->l;
		B[len2].r = it->r;
		B[len2].v = it->v;
	}
	s.erase(itl2,itr2);
	for(R int i = 1;i <= len2;++ i) s.insert(node(l1 + B[i].l - l2, l1 + B[i].r - l2, B[i].v));
	for(R int i = 1;i <= len1;++ i) s.insert(node(l2 + A[i].l - l1, l2 + A[i].r - l1, A[i].v));
}

inline void reverse(int l,int r) {
    if(l > r) swap(l, r);
    IT itr = split(r + 1),itl = split(l);
    int len = 0;
    for(IT it = itl;it != itr;++ it) {
        A[++len].l = it->l;
        A[len].r = it->r;
        A[len].v = it->v;
    }
    s.erase(itl,itr);
    for(R int i = 1;i <= len;++ i)
        s.insert(node(r - A[i].r + l, r - A[i].l + l, A[i].v));
}

inline LL query(int l,int r) {
    IT itr = split(r + 1),itl = split(l);
    LL res = 0;
    for(;itl != itr;++ itl)
        (res += (LL)(itl->r - itl->l + 1) * itl->v) %= p;
    return res;
}

int main() {
	scanf("%d%d",&n,&m);
	for(R int i = 1;i <= n;++ i) {
		LL x; scanf("%lld",&x);
		s.insert(node(i,i,x));
	}
	s.insert(node(n + 1,n + 1,(LL)0));
	for(R int i = 1,op,l,r,x,y;i <= m;++ i) {
		scanf("%d%d%d",&op,&l,&r);
		LL v;
		if(op == 1) printf("%lld\n",query(l,r));
		if(op == 2) scanf("%lld",&v),assign(l,r,v);
		if(op == 3) scanf("%lld",&v),add(l,r,v);
		if(op == 4) scanf("%d%d",&x,&y),copy(l,r,x,y);
		if(op == 5) scanf("%d%d",&x,&y),change(l,r,x,y);
		if(op == 6) reverse(l,r);
	}
	for(IT it = s.begin();it != s.end() && it->r <= n;++ it)
    	for(R int i = it->l;i <= it->r;++ i)
			printf("%lld ",it->v);
	return 0;
}
```


---

## 作者：Star_Cried (赞：5)

## P5350 序列

### 题意

维护一个序列，支持区间求和、赋值、加值、复制、交换、翻转操作，其中交换和复制操作保证两段区间长度相等且不交。答案对 $1e9+7$ 取模。

### 思路

对于区间求和、赋值、加值、交换、翻转操作我们都可以很轻松地使用平衡树进行维护。所以现在的难点就在于复制操作：如何复制一段区间？

如果我们暴力复制的话，每次我们不得不将被复制的子树扫一遍进行复制，这是肯定不行的。

于是我们使用**可持久化平衡树**。其中心思想就是每次修改一个节点的信息时，将该节点复制一遍。这样我们在进行复制操作的时候就可以复制出来一个新的树而不会对原树有影响，而且因为不是每次都遍历子树，所以时间复杂度正确。

但是因为要丢弃之前的节点所以空间复杂度略微有些大。因为我们可以进行~~垃圾回收~~定期重构使得空间被合理重复利用。

于是这道题就解决了。我使用了 FHQ treap 进行实现，因为发现对于这些操作 FHQ 会比较方便。

然后这道题不卡 ODT 但卡复杂度保证的写法。

### 细节和我犯过的错误

* 这是个定长的序列，所以我们每次重构的时候可以选择使用构建二叉搜索树的方法线性构建，~~否者会被卡常~~。

* **每次更改节点信息时都要进行复制**，`pushdown`,`merge`,`split` 函数和修改操作里都要复制。

* 注意 `pushdown` 和 `clone` 的前后顺序。有时候我们并不需要将原节点进行下传标记以免建出无用节点增大常数。

* 注意传参时用的是哪个节点的参数。我曾在 `split` 操作中下传原节点的儿子，实际上是复制后的节点的儿子。

* FHQ 在新建节点后的 `rand` 值占空间，我们用一段话在 `merge` 的时候现场随机，即：

  `rd(0,(e[a].siz+e[b].siz)-1)<e[a].siz`

  可以省下一点空间。

* 复制和交换的时候记住，给出的区间端点位置可不保证升序的。

* 重构之后再清空节点数，因为在遍历搜索树的时候会 `pushdown` 而新加节点。

### 代码

此题历经三天时间才做出来，所以代码可能有些我没看出来的奇怪的东西，鬼知道我调试的时候干了什么。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cctype>
#include<cstring>
#include<cmath>
#include<chrono>
#include<random>
using namespace std;
inline int read(){
	int w=0,x=0;char c=getchar();
	while(!isdigit(c))w|=c=='-',c=getchar();
	while(isdigit(c))x=x*10+(c^48),c=getchar();
	return w?-x:x;
}
char buf[1 << 21], a[20]; int p, p2 = -1;
inline void flush() {
	fwrite(buf, 1, p2 + 1, stdout);
	p2 = -1;
}
inline void print(int x) {
	if (p2 > 1 << 20) flush();
	if (x < 0) buf[++p2] = 45, x = -x;
	do a[++p] = x % 10 + 48;while (x /= 10);
	do buf[++p2] = a[p];while (--p);
} 
namespace star
{
	const int maxn=3e5+10,maxm=4e6+10,mod=1e9+7;
	mt19937 rnd(std::chrono::system_clock::now().time_since_epoch().count());
	int rd(int l,int r){return std::uniform_int_distribution<int>(l,r)(rnd);}
	int n,m,a[maxn];
	struct FHQ{
		#define ls e[ro].son[0]
		#define rs e[ro].son[1]
		struct node{
			int son[2],siz,tag,add,val,sum;
			bool rev;
		}e[maxm];
		int tot,rt;
		FHQ():e(),tot(0),rt(0){}
		inline void clone(int &x){e[++tot]=e[x],x=tot;}
		inline int newnode(int a){return e[++tot]=(node){{0,0},1,-1,0,a,a,false},tot;}
		inline void pushup(int ro){e[ro].siz=e[ls].siz+e[rs].siz+1,e[ro].sum=(1ll*e[ls].sum+e[rs].sum+e[ro].val)%mod;}
		void rev(int ro){if(ro)e[ro].rev^=1,swap(ls,rs);}
		void add(int ro,int v){if(ro)e[ro].val=(e[ro].val+v)%mod,e[ro].sum=(e[ro].sum+1ll*e[ro].siz*v)%mod,e[ro].add=(e[ro].add+v)%mod;}
		void assign(int ro,int v){if(ro)e[ro].val=v,e[ro].sum=1ll*e[ro].siz*v%mod,e[ro].add=0,e[ro].tag=v;}
		inline void pushdown(int ro){
			if(!e[ro].rev and e[ro].tag==-1 and !e[ro].add) return;
			if(ls) clone(ls);if(rs) clone(rs);
			if(e[ro].rev) rev(ls),rev(rs),e[ro].rev=false;
			if(e[ro].tag!=-1) assign(ls,e[ro].tag),assign(rs,e[ro].tag),e[ro].tag=-1;
			if(e[ro].add) add(ls,e[ro].add),add(rs,e[ro].add),e[ro].add=0;
		}
		int build(int l=1,int r=n){
			if(l>r)return 0;
			int mid=(l+r)>>1;
			int ro=newnode(a[mid]);
			ls=build(l,mid-1),rs=build(mid+1,r);
			pushup(ro);
			return ro;
		}
		int merge(int a,int b){
			if(!a or !b)return a|b;
			if(rd(0,(e[a].siz+e[b].siz)-1)<e[a].siz){
				clone(a),pushdown(a);
				e[a].son[1]=merge(e[a].son[1],b);
				pushup(a);return a;
			}else{
				clone(b),pushdown(b);
				e[b].son[0]=merge(a,e[b].son[0]);
				pushup(b);return b;
			}
		}
		void split(int ro,int k,int &a,int &b){
			if(!ro) return a=b=0,void();
			if(e[ls].siz<k) a=ro,clone(a),pushdown(a),split(e[a].son[1],k-e[e[a].son[0]].siz-1,e[a].son[1],b),pushup(a);
			else b=ro,clone(b),pushdown(b),split(e[b].son[0],k,a,e[b].son[0]),pushup(b);
		}
		inline void copy(){
			int l1=read(),r1=read(),l2=read(),r2=read(),a,b,c,d,e;int bk=1;
			if(r1>r2)swap(l1,l2),swap(r1,r2),bk=0;
			split(rt,r2,d,e);split(d,l2-1,c,d);split(c,r1,b,c);split(b,l1-1,a,b);
			if(bk) rt=merge(a,merge(b,merge(c,merge(b,e))));
			else rt=merge(a,merge(d,merge(c,merge(d,e))));
		}
		inline void Swap(){
			int l1=read(),r1=read(),l2=read(),r2=read(),a,b,c,d,e;
			if(r1>r2)swap(l1,l2),swap(r1,r2);
			split(rt,r2,d,e);split(d,l2-1,c,d);split(c,r1,b,c);split(b,l1-1,a,b);
			rt=merge(a,merge(d,merge(c,merge(b,e))));
		}
		inline void push(int ro){
			if(!ro)return;
			pushdown(ro);
			push(ls),a[++n]=e[ro].val,push(rs);
		}
		#undef ls
		#undef rs
	}S;
	inline void work(){
		n=read(),m=read();
		for(int i=1;i<=n;i++) a[i]=read();
		S.rt=S.build();
		while(m--){
			switch(read()){
				case 1:{
					int l=read(),r=read(),a,b,c;
					S.split(S.rt,r,b,c);S.split(b,l-1,a,b);
					printf("%d\n",S.e[b].sum);
					S.rt=S.merge(a,S.merge(b,c));
					break;
				}
				case 2:{
					int l=read(),r=read(),a,b,c;
					S.split(S.rt,r,b,c);S.split(b,l-1,a,b);
					S.clone(b);
					S.assign(b,read());
					S.rt=S.merge(a,S.merge(b,c));
					break;
				}
				case 3:{
					int l=read(),r=read(),a,b,c;
					S.split(S.rt,r,b,c);S.split(b,l-1,a,b);
					S.clone(b);
					S.add(b,read());
					S.rt=S.merge(a,S.merge(b,c));
					break;
				}
				case 4:S.copy();break;
				case 5:S.Swap();break;
				case 6:{
					int l=read(),r=read(),a,b,c;
					S.split(S.rt,r,b,c);S.split(b,l-1,a,b);
					S.clone(b);
					S.rev(b);
					S.rt=S.merge(a,S.merge(b,c));
					break;
				}
			}
			if(S.tot>3600000) n=0,
			S.push(S.rt),S.rt=S.tot=0,
			S.rt=S.build();
		}
		n=0,S.push(S.rt);
		for(int i=1;i<=n;i++) printf("%d ",a[i]);
	}
}
signed main(){
	star::work();
	flush();
	return 0;
}
```



---

## 作者：mrsrz (赞：3)

数据随机+区间覆盖，上幸福的珂朵莉树即可。反正也就6个操作。不卡常数的。

其他操作直接暴力即可。

期望复杂度$O(m\log n)$。

注意，操作的时候一定要保证珂朵莉树内的数据连续，否则会出一些锅（比如莫名其妙少几个数据），~~set的指针真玄学~~。

## Code：
```cpp
#include<cstdio>
#include<cctype>
#include<set>
#include<vector>
const int md=1e9+7;
typedef long long LL;
inline void upd(int&a){a+=a>>31&md;}
inline int readint(){
    int c=getchar(),d=0;
    for(;!isdigit(c);c=getchar());
    for(;isdigit(c);c=getchar())d=d*10+(c^'0');
    return d;
}
int n,m;
namespace odt{
    struct node{
        int l,r;mutable int val;
        inline bool operator<(const node&rhs)const{return l<rhs.l;}
    };
    std::set<node>s;
    inline void out(){
        for(node i:s)
        for(int j=i.l;j<=i.r;++j)printf("%d ",i.val);
        putchar('\n');
    }
    typedef std::set<node>::iterator iter;
    inline void insert(int l,int r=0,int v=0){s.insert((node){l,r,v});}
    inline iter split(int pos){
        iter it=s.lower_bound((node){pos});
        if(it!=s.end()&&it->l==pos)return it;
        --it;
        const int l=it->l,r=it->r,v=it->val;
        s.erase(it),s.insert((node){l,pos-1,v});
        return s.insert((node){pos,r,v}).first;
    }
    inline int sum(int l,int r){
        int ret=0;
        for(iter R=split(r+1),L=split(l);L!=R;++L)
        ret=(ret+(L->r-L->l+1LL)*L->val)%md;
        return ret;
    }
    inline void assign(int l,int r,int val){iter R=split(r+1),L=split(l);s.erase(L,R),s.insert((node){l,r,val});}
    inline void add(int l,int r,int v){for(iter R=split(r+1),L=split(l);L!=R;++L)upd(L->val+=v);}
    inline void clone(int l1,int r1,int l2,int r2){
        static std::vector<node>vec;
        vec.clear();
        for(iter R=split(r1+1),L=split(l1);L!=R;++L)
        vec.push_back(*L);
        iter R=split(r2+1),L=split(l2);
        s.erase(L,R);
        for(node i:vec)s.insert((node){i.l-l1+l2,i.r-l1+l2,i.val});
    }
    inline void swap(int l1,int r1,int l2,int r2){
        if(l1>l2)l1^=l2^=l1^=l2,r1^=r2^=r1^=r2;
        static std::vector<node>v1,v2;
        v1.clear(),v2.clear();
        for(iter R=split(r1+1),L=split(l1);L!=R;++L)
        v1.push_back(*L);
        for(iter R=split(r2+1),L=split(l2);L!=R;++L)
        v2.push_back(*L);
        iter R=split(r1+1),L=split(l1);
        s.erase(L,R);
        R=split(r2+1),L=split(l2);
        s.erase(L,R);
        for(node i:v1)
        insert(i.l-l1+l2,i.r-l1+l2,i.val);
        for(node i:v2)
        insert(i.l-l2+l1,i.r-l2+l1,i.val);
    }
    inline void reverse(int l,int r){
        static std::vector<node>vec;
        vec.clear();
        for(iter R=split(r+1),L=split(l);L!=R;++L)
        vec.push_back(*L);
        iter R=split(r+1),L=split(l);
        s.erase(L,R);
        for(node i:vec)s.insert((node){r-i.r+l,r-i.l+l,i.val});
    }
}
int main(){
    n=readint(),m=readint();
    for(int i=1;i<=n;++i)odt::insert(i,i,readint());
    odt::insert(n+1);
    while(m--)
    switch(readint()){
        case 1:{
            int l=readint(),r=readint();
            printf("%d\n",odt::sum(l,r));
            break;
        }
        case 2:{
            int l=readint(),r=readint(),v=readint();
            odt::assign(l,r,v);
            break;
        }
        case 3:{
            int l=readint(),r=readint(),v=readint();
            odt::add(l,r,v-md);
            break;
        }
        case 4:{
            int l1=readint(),r1=readint(),l2=readint(),r2=readint();
            odt::clone(l1,r1,l2,r2); 
            break;
        }
        case 5:{
            int l1=readint(),r1=readint(),l2=readint(),r2=readint();
            odt::swap(l1,r1,l2,r2); 
            break;
        }
        case 6:{
            int l=readint(),r=readint();
            odt::reverse(l,r);
            break;
        }
    }
    odt::out();
    return 0;
}

```

---

## 作者：hzoi_liuchang (赞：2)

## 分析
操作一、二、三为珂朵莉树的基本操作，操作四、五、六稍作转化即可

不会珂朵莉树请移步至[这里](https://www.cnblogs.com/liuchanglc/p/13324921.html)
### 求和操作
把每一段区间分别取出，暴力相加
``` cpp
ll qh(ll l,ll r){
    it2=Split(r+1),it1=Split(l);
    ll ans=0;
    for(it=it1;it!=it2;it++){
        ans=(ans+(it->r-it->l+1)*it->val)%mod;
    }
    return ans;
}
```
### 赋值操作
直接调用$Assign$函数将其推平即可
``` cpp
void Assign(ll l,ll r,ll val){
    it2=Split(r+1),it1=Split(l);
    s.erase(it1,it2);
    s.insert(asd(l,r,val));
}
```
### 修改操作
把每一段区间分别取出，暴力修改
``` cpp
void ad(ll l,ll r,ll val){
    it2=Split(r+1),it1=Split(l);
    for(it=it1;it!=it2;it++){
        it->val+=val;
        it->val%=mod;
    }
}
```
### 复制操作
将区间$[l1,r1]$中的元素取出记录一下，加入到区间$[l2,r2]$中即可
``` cpp
void fz(ll l1,ll r1,ll l2,ll r2){
    it2=Split(r1+1),it1=Split(l1);
    for(tot=0,it=it1;it!=it2;it++){
        a[++tot]=l2+it->l-l1,b[tot]=l2+it->r-l1,c[tot]=it->val;
    }
    for(ll i=1;i<=tot;++i){
	Assign(a[i],b[i],c[i]);
    }
}
```
### 交换操作
套用复制操作

我们可以先将区间$[l1,r1]$复制到区间$[n+1,n+r1-l1+1]$中

再将区间$[l2,r2]$复制到区间$[l1,r1]$中

最后再把区间$[n+1,n+r1-l1+1]$复制到区间$[l2,r2]$中

``` cpp
void jh(ll l1,ll r1,ll l2,ll r2) {
	fz(l1,r1,n+1,n+r1-l1+1);
	fz(l2,r2,l1,r1);
	fz(n+1,n+r1-l1+1,l2,r2);
}
```
### 翻转操作
把区间中的数取出，再倒序加入
``` cpp
vector<asd> g;
void xz(ll l,ll r){
    g.clear();
    it2=Split(r+1),it1=Split(l);
    aa=r;
    for(it=it1;it!=it2;it++){
        ll l=it->l,r=it->r,val=it->val;
        g.push_back(asd(l,r,val));
    }
    s.erase(it1,it2);
    for(ll i=0;i<g.size();i++){
        s.insert(asd(aa-(g[i].r-g[i].l),aa,g[i].val));
        aa-=(g[i].r-g[i].l+1);
    }
}
```
## 完整代码
``` cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=1e6+5;
const ll mod=1e9+7;
ll a[maxn],b[maxn],c[maxn];
struct asd{
    ll l,r;
    mutable ll val;
    bool operator < (const asd& A) const{
        return l<A.l;
    }
    asd(ll aa,ll bb,ll cc){
        l=aa,r=bb,val=cc;
    }
    asd(ll aa){
        l=aa;
    }
};
#define sit set<asd>::iterator
set<asd> s;
ll aa,bb,cc,dd,ee,n,m;
sit it,it1,it2;
sit Split(ll wz){
    it=s.lower_bound(asd(wz));
    if(it!=s.end() && it->l==wz) return it;
    it--;
    ll l=it->l,r=it->r,val=it->val;
    s.erase(it);
    s.insert(asd(l,wz-1,val));
    return s.insert(asd(wz,r,val)).first;
}
ll qh(ll l,ll r){
    it2=Split(r+1),it1=Split(l);
    ll ans=0;
    for(it=it1;it!=it2;it++){
        ans=(ans+(it->r-it->l+1)*it->val)%mod;
    }
    return ans;
}
void Assign(ll l,ll r,ll val){
    it2=Split(r+1),it1=Split(l);
    s.erase(it1,it2);
    s.insert(asd(l,r,val));
}
void ad(ll l,ll r,ll val){
    it2=Split(r+1),it1=Split(l);
    for(it=it1;it!=it2;it++){
        it->val+=val;
        it->val%=mod;
    }
}
vector<asd> g;
void xz(ll l,ll r){
    g.clear();
    it2=Split(r+1),it1=Split(l);
    aa=r;
    for(it=it1;it!=it2;it++){
        ll l=it->l,r=it->r,val=it->val;
        g.push_back(asd(l,r,val));
    }
    s.erase(it1,it2);
    for(ll i=0;i<g.size();i++){
        s.insert(asd(aa-(g[i].r-g[i].l),aa,g[i].val));
        aa-=(g[i].r-g[i].l+1);
    }
}
int tot;
void fz(ll l1,ll r1,ll l2,ll r2){
    it2=Split(r1+1),it1=Split(l1);
    for(tot=0,it=it1;it!=it2;it++){
        a[++tot]=l2+it->l-l1,b[tot]=l2+it->r-l1,c[tot]=it->val;
    }
    for(ll i=1;i<=tot;++i){
		Assign(a[i],b[i],c[i]);
    }
}
void jh(ll l1,ll r1,ll l2,ll r2) {
	fz(l1,r1,n+1,n+r1-l1+1);
	fz(l2,r2,l1,r1);
	fz(n+1,n+r1-l1+1,l2,r2);
}
int main(){
    scanf("%lld%lld",&n,&m);
    for(ll i=1;i<=n;i++){
        scanf("%lld",&aa);
        s.insert(asd(i,i,aa));
    }
    s.insert(asd(n+1,n+1,0));
    for(ll i=1;i<=m;i++){
        scanf("%lld",&aa);
        if(aa==1){
            scanf("%lld%lld",&bb,&cc);
            printf("%lld\n",qh(bb,cc));
        } else if(aa==2){
            scanf("%lld%lld%lld",&bb,&cc,&dd);
            Assign(bb,cc,dd);
        } else if(aa==3){
            scanf("%lld%lld%lld",&bb,&cc,&dd);
            ad(bb,cc,dd);
        } else if(aa==4){
            scanf("%lld%lld%lld%lld",&bb,&cc,&dd,&ee);
            fz(bb,cc,dd,ee);
        } else if(aa==5){
            scanf("%lld%lld%lld%lld",&bb,&cc,&dd,&ee);
            jh(bb,cc,dd,ee);
        } else {
            scanf("%lld%lld",&bb,&cc);
            xz(bb,cc);
        }

    }
    it2=Split(n+1),it1=Split(1);
    for(it=it1;it!=it2;it++){
        for(ll i=it->l;i<=it->r;i++)printf("%lld ",it->val%mod);
    }
    printf("\n");
    return 0;
}
```

---

## 作者：Genius_Z (赞：2)

这题只有在数据随机的情况下4操作的复杂度才是正确的，因为数据随机，因此我们可以考虑平衡树维护相同值域连续段，然后重点就是拆区间，我们考虑把在找节点时把一个连续段拆成3段x、y、z，把z作为y的后继，y作为x的后继，再返回y即可，其他思路都非常简单，主要考察代码能力。

```cpp
#define poi(x) (rs(fa(x)) == (x))
#define reverse(x) (swap(ls(x), rs(x)), t[x].filp ^= 1)
const int p = 1e9 + 7;
stack<int> st;
int rt, cnt, a[300005], len[300005];
struct node {
	int fa, child[2], tot, sum, w, size, len;
	bool filp, tag;
} t[3000005];
inl void upd(int x) {
	t[x].tot = ((t[ls(x)].tot + t[rs(x)].tot) % p + (1ll * t[x].w * t[x].len)) % p;
	t[x].size = t[ls(x)].size + t[rs(x)].size + t[x].len;
}
inl int newn(int w, int len) {
	re x;
	if (!st.empty())
		x = st.top(), st.pop();
	else
		x = ++cnt;
	t[x].size = t[x].tot = fa(x) = ls(x) = rs(x) = t[x].filp = t[x].sum = 0;
	t[x].w = w, t[x].len = len, upd(x);
	return x;
}
inl void rotate(int x) {
	re f = fa(x), gf = fa(f), fs = poi(x), gfs = poi(f), s = son(x, fs ^ 1);
	if (gf) son(gf, gfs) = x;
	son(f, fs) = s, son(x, fs ^ 1) = f;
	if (s) fa(s) = f;
	fa(f) = x, fa(x) = gf, upd(f);
}
inl void sum(int x, int w) { t[x].tot = (t[x].tot + 1ll * w * t[x].size) % p, t[x].w = (t[x].w + w) % p, t[x].sum = (t[x].sum + w) % p; }
inl void pushdown(int x) {
	if (t[x].sum) {
		if (ls(x)) sum(ls(x), t[x].sum);
		if (rs(x)) sum(rs(x), t[x].sum);
		t[x].sum = 0;
	}
	if (t[x].filp) {
		if (ls(x)) reverse(ls(x));
		if (rs(x)) reverse(rs(x));
		t[x].filp = 0;
	}
}
inl void push(int x) {
	if (fa(x)) push(fa(x));
	pushdown(x);
}
inl void splay(int x, int to = 0) {
	push(x);
	while (fa(x) != to) {
		if (fa(fa(x)) != to) poi(x) == poi(fa(x)) ? rotate(fa(x)) : rotate(x);
		rotate(x);
	}
	if (!to) rt = x;
	upd(x);
}
inl int split(int x, int k) {
	re y = newn(t[x].w, t[x].len - k);
	t[x].len = k;
	if (!rs(x))fa(rs(x) = y) = x;
	else {
		pushdown(x);
		re o = rs(x); pushdown(o);
		while (ls(o))pushdown(o = ls(o));
		fa(ls(o) = y) = o;
		while (o != x) upd(o), o = fa(o);
	}
	splay(y);
	return y;
}
inl void find(int k) {
	re x = rt;
	while (x) {
		pushdown(x);
		if (t[ls(x)].size >= k) x = ls(x);
		else {
			k -= t[ls(x)].size;
			if (t[x].len >= k) {
				if (k != t[x].len)split(x, k);
				if (k != 1)x = split(x, k - 1);
				return splay(x);
			}
			else k -= t[x].len, x = rs(x);
		}
	}
}
inl int nxt(int k, bool f) {
	find(k);
	re x = rt;
	x = son(x, f);
	while (son(x, f ^ 1))pushdown(x), x = son(x, f ^ 1);
	return x;
}
inl void build(int &k, int l, int r) {
	if (l > r) return;
	re mid = l + r >> 1;
	k = newn(a[mid], len[mid]);
	if (a[mid] == inf)t[k].tag = 1, t[k].w = 0, upd(k);
	build(ls(k), l, mid - 1), build(rs(k), mid + 1, r);
	if (ls(k))fa(ls(k)) = k; if (rs(k)) fa(rs(k)) = k;
	upd(k);
}
int num;
inl void travel(int x) {
	pushdown(x);
	if (ls(x)) travel(ls(x));
	a[++num] = t[x].w, len[num] = t[x].len;
	if (rs(x)) travel(rs(x));
}
inl void erase(int x) {
	if (ls(x)) erase(ls(x));
	st.push(x);
	if (rs(x)) erase(rs(x));
}
inl void change(int x, int w) {
	if (w == 1) {
		t[x].w = w, upd(x);
		return;
	}
	erase(x);
	re k = fa(x);
	ls(k) = fa(x) = 0;
	fa(ls(k) = newn(w, t[x].size)) = k;
	splay(ls(k));
}
inl void print(int x) {
	pushdown(x);
	if (ls(x))print(ls(x));
	if (!t[x].tag)for (re i = 1; i <= t[x].len; i++)writesp(t[x].w);
	if (rs(x))print(rs(x));
}
inl int cut(int a, int b) {
	re l, r;
	find(a), l = rt, find(b + 2), r = rt;
	splay(l), splay(r, l);
	return ls(r);
}
signed main() {
	re n = read<int>(), m = read<int>(), l, r, op, l1, r1, w, tmp1, tmp2, f;
	a[++num] = inf, len[num] = 1;
	for (re i = 1; i <= n; i++) a[++num] = read<int>() % p, len[num] = 1;
	a[++num] = inf, len[num] = 1;
	build(rt, 1, num);
	while (m--) {
		op = read<int>(), l = read<int>(), r = read<int>();
		switch (op) {
		case 1: {
			writeln(t[cut(l, r)].tot);
			break;
		}
		case 2: {
			w = read<int>() % p;
			change(cut(l, r), w);
			break;
		}
		case 3: {
			w = read<int>() % p;
			sum(cut(l, r), w);
			break;
		}
		case 4: {
			l1 = read<int>(), r1 = read<int>();
			num = 0, travel(cut(l, r));
			build(tmp1, 1, num);
			erase(tmp2 = cut(l1, r1));
			ls(fa(tmp2)) = 0, f = fa(tmp2), fa(tmp2) = 0;
			fa(ls(f) = tmp1) = f;
			splay(ls(f));
			break;
		}
		case 5: {
			l1 = read<int>(), r1 = read<int>();
			num = 0, travel(cut(l, r));
			build(tmp1, 1, num);
			tmp2 = cut(l1, r1);
			ls(fa(tmp2)) = 0, f = fa(tmp2), fa(tmp2) = 0;
			fa(ls(f) = tmp1) = f;
			splay(ls(f));
			f = cut(l, r);
			ls(fa(f)) = tmp2, fa(tmp2) = fa(f), fa(f) = 0;
			erase(f);
			break;
		}
		case 6: {
			f = cut(l, r);
			reverse(f);
			break;
		}
		}
	}
	print(rt);
}
```



---

## 作者：zhenglier (赞：1)

## 前置知识：ODT

非常暴力的数据结构，不会的可以左转[CF896C](https://www.luogu.org/problemnew/show/CF896C)。

对于每一个复杂的操作，如交换，复制，反转，我们可以把那一段的点全部放入一个vector中储存，并修改左右的边界信息，然后暴力插入。

其他操作和板子没什么区别。

这里提醒一下大家，你以为split出来得迭代器就是最后的结果了，其实在进行其他split操作时可能已经改变了！所以最后用再用lower_bound定位一下。

可能需要一点常数优化，不过基本上开了O2是能过的。

```cpp#include<bits/stdc++.h>
#define res register int 
using namespace std;
#define IT register set<node>::iterator
const int N=300010,p=1e9+7;
int n,m;
struct node{
    int l,r;
    mutable int v;
    node(int l,int r=-1,int v=0):l(l),r(r),v(v){}
};
bool operator<(const node &a,const node &b){
    return a.l<b.l;
}
set<node>s;
inline set<node>::iterator split(int pos){
    IT it=s.lower_bound(node(pos));
    if(it!=s.end()&&it->l==pos)return it;
    --it;
    int l=it->l,r=it->r;
    int v=it->v;
    s.erase(it);
    s.insert(node(l,pos-1,v));
    return s.insert(node(pos,r,v)).first;
}
inline void add(res l,res r,res val){
    IT itl=split(l),itr=split(r+1);
    itl=s.lower_bound(node(l));
    itr=s.lower_bound(node(r+1));
    for(;itl!=itr;++itl)itl->v=(itl->v+val)%p;
}
inline void assign_val(res l,res r,res val){
    IT itl=split(l),itr=split(r+1);
    itl=s.lower_bound(node(l));
    itr=s.lower_bound(node(r+1));
    s.erase(itl,itr);
    s.insert(node(l,r,val));
}
inline int sum(res l,res r){
    IT itl=split(l),itr=split(r+1);
    itl=s.lower_bound(node(l));
    itr=s.lower_bound(node(r+1));
    int ret=0;
    for(IT it=itl;it!=itr;it++){
        ret=(ret+1ll*(it->r-it->l+1)*it->v%p)%p;
    }
    return ret;
}
vector<node>q;
inline void copy(int a,int b,int c,int d){
    IT ita=split(a),itb=split(b+1),itc=split(c),itd=split(d+1);
    ita=s.lower_bound(node(a));
    itb=s.lower_bound(node(b+1));
    itc=s.lower_bound(node(c));
    itd=s.lower_bound(node(d+1));
    q.clear();
    for(IT it=ita;it!=itb;++it){
        node ls=*it;
        ls.l+=c-a;
        ls.r+=c-a;
        q.push_back(ls);
    }
    s.erase(itc,itd);
    for(vector<node>::iterator it=q.begin();it!=q.end();++it){
        s.insert(*it);
    }
}
void print(){
    for(IT it=s.begin();it!=s.end();++it){
        if(it->l==n+1)break;
        for(int i=1;i<=it->r-it->l+1;++i){
            printf("%d ",it->v);
        }
    }
    puts("");
}
inline void swap(res a,res b,res c,res d){
    IT itd=split(d+1),itc=split(c),itb=split(b+1),ita=split(a);
    ita=s.lower_bound(node(a));
    itb=s.lower_bound(node(b+1));
    itc=s.lower_bound(node(c));
    itd=s.lower_bound(node(d+1));
    q.clear();
    for(IT it=ita;it!=itb;++it){
        node ls=*it;
        ls.l+=c-a;
        ls.r+=c-a;
        q.push_back(ls);
    }
    for(IT it=itc;it!=itd;++it){
        node ls=*it;
        ls.l-=c-a;
        ls.r-=c-a;
        q.push_back(ls);
    }
    s.erase(itc,itd);
    ita=s.lower_bound(node(a));
    itb=s.lower_bound(node(b+1));
    s.erase(ita,itb);
    for(vector<node>::iterator it=q.begin();it!=q.end();++it){
        s.insert(*it);
    }
}
inline void reverse(res l,res r){
    IT itl=split(l),itr=split(r+1);
    itl=s.lower_bound(node(l));
    itr=s.lower_bound(node(r+1));
    q.clear();
    for(IT it=itl;it!=itr;it++){
        q.push_back(*it);
    }
    s.erase(itl,itr);
    for(res i=q.size()-1,now=0;~i;--i){
        res sz=q[i].r-q[i].l+1;
        q[i].l=l+now;
        q[i].r=l+now+sz-1;
        now+=sz;
        s.insert(q[i]);
    }
}
inline int read(){
    res ret=0;
    char c=getchar();
    for(;!isdigit(c);c=getchar());
    for(;isdigit(c);ret=ret*10+c-'0',c=getchar());
    return ret;
}
int main(){
    n=read(),m=read();
    for(int i=1;i<=n;++i){
        s.insert(node(i,i,read()));
    }
    s.insert(node(n+1,n+1,0));
    while(m--){
        res op=read(),x,y,z,a,b,c,d;
        if(op==1){
        	x=read(),y=read();
            printf("%d\n",sum(x,y));
        }else if(op==2){
            x=read(),y=read(),z=read();
            assign_val(x,y,z);
        }else if(op==3){
            x=read(),y=read(),z=read();
            add(x,y,z);
        }else if(op==4){
            a=read(),b=read(),c=read(),d=read();
            copy(a,b,c,d);
        }else if(op==5){
            a=read(),b=read(),c=read(),d=read();
            swap(a,b,c,d);
        }else{
            x=read(),y=read();
            reverse(x,y);
        }
    }
    print();
    return 0;
}
```

---


# [DBOI2019] 德丽莎世界第一可爱

## 题目背景

```cpp
众所周知，德丽莎世界第一可爱。
——zhengrunzhe
```

你正在打崩坏$3$，突然家长来了，于是你装作在打数据结构题。

![神恩颂歌](https://cdn.luogu.com.cn/upload/pic/70922.png)

## 题目描述

有 $n$ 个崩坏兽，每个崩坏兽有五个属性值：health 生命力，energy 能量力，attack 攻击力，defense 防御力， collapse 崩坏能。

德丽莎可以任选一只崩坏兽展开攻击。假如她干掉了崩坏兽$i$ 那么她会收获 `collapse[i]` 的可爱值。由于德丽莎越战越勇，她打的下一只崩坏兽 $j$ 需要满足 `health[j]≥ health[i]` , `energy[j]≥energy[i]` , `attack[j]≥attack[i]` , `defense[j]≥defense[i]`。

请你帮帮德丽莎计算一下她能够获得的最大可爱值。

## 说明/提示


Subtask #1（$20$分）： 

$1\leq n\leq 100$。

Subtask #2（$20$分）： 

$1\leq n\leq 10000$。

Subtask #3（$60$分）： 

$1\leq n\leq 50000$。

对于 $100\%$ 的数据，满足 $|\mathrm{health}_i|, |\mathrm{energy}_i|, |\mathrm{attack_i}|, |\mathrm{defense}_i| \le 10^5$，$| \mathrm{collapse}_i|\le 10^9$。

### 题目提供者：[$\color{red}{zhengrunzhe}$](https://www.luogu.org/space/show?uid=14374)

## 样例 #1

### 输入

```
5
1 9 3 6 233
0 8 3 7 666
-3 9 4 2 810
2 3 3 3 -100
1 8 8 9 603```

### 输出

```
1269```

# 题解

## 作者：xhhhh36 (赞：6)

[传送门](https://www.luogu.com.cn/problem/P5621)

本题为四维偏序，使用 cdq 套 cdq 套 cdq 优化 dp 来解决，不使用任何数据结构，复杂度 $O(n\log^4 n)$。不过要通过本题需要开 c++20 吸氧和使用一些优化。

设 $dp_i$ 为必须击杀第 $i$ 只崩坏兽获得的最大可爱值，设 $a_i,b_i,c_i,d_i,w_i$，分别为第 $i$ 只崩坏兽的生命力，能量力，攻击力，防御力和崩坏能。那么答案为 $\max_{i=1}^{n} dp_i$，$dp_i$ 的初值为 $w_i$。$dp_i=\max_{j=1}^{n}dp_j+w_i(a_j\le a_i,b_j\le b_i,c_j\le c_i,d_j\le d_i,i\ne j)$ 直接转移是 $O(n^2)$ 的，考虑优化。

使用 cdq 分治优化 dp。因为在更新时要保证所有四个值都小于等于它的位置的 dp 值都已经被更新，所以只能使用中序遍历来完成 cdq 分治。最开始先按 $a$ 排序，那么在第一层 cdq 分治时，可以保证在 $[l,mid]$ 区间中的所有数的 $a$ 都小于等于 $[mid+1,r]$ 区间，那么对此时位于 $[l,mid]$ 区间中的数打上一个标记。根据 cdq 分治的原理，说明有标记的位置要对没有标记的位置做贡献并且有标记的位置的 $a$ 的值小于等于没有标记的位置。接着将原数组按 $b$ 排序，进入下一层 cdq 分治。同样按左右区间打上标记后，按 $c$ 排序，进入最后一层 cdq 分治计算贡献。

此时需要计算带有两个标记的位置对完全没有标记的位置的贡献。因为此时已经按 $c$ 排序，只需要用类似归并排序方式维护 $d$ 的顺序，那么此时就可按照 dp 式子来更新 dp 值了。

但是这样的写法由于维护的是中序遍历的 cdq 分治，所以需要额外排序，会增加一个 $\log$，还需要进行一些优化。

由于在做 cdq 分治时 $[l,r]$ 区间的长度较小时 $O(n^2)$ 的暴力有可能会比多层 cdq 分治更优。那么可以特判一下区间长度较小的情况，直接使用暴力来更新这部分的 dp 值。同时 cdq 分治内的排序要使用手写的归并排序来减小常数。

然后就可以通过本题了。
# AC code
```cpp
#include <bits/stdc++.h>

using namespace std;
const int N=5e4+5;
inline long long mx(long long a,long long b){
	return a>b?a:b;
}
int n,k;
long long ans[N];
struct node{
	int a,b,c,d,id,tmp,tmp1;
	long long w;
}z[N],a[N],b[N],c[N],d[N];
bool cmp(node a,node b){
	return a.a^b.a?a.a<b.a:a.b^b.b?a.b<b.b:a.c^b.c?a.c<b.c:a.d^b.d?a.d<b.d:a.w>b.w;
}
void memsort(int l,int r){
	if (!(l^r)) return ;
	int mid=l+r>>1;
	memsort(l,mid);memsort(mid+1,r);
	for (int i=l,j=l,k=mid+1;i<=r;i++){
		if ((k>r||c[j].d<=c[k].d)&&j<=mid){
			d[i]=c[j++];
		} else {
			d[i]=c[k++];
		}
	}for (int i=l;i<=r;i++){
		c[i]=d[i];
	}
}
void memsort1(int l,int r){
	if (!(l^r)) return ;
	int mid=l+r>>1;
	memsort1(l,mid);memsort1(mid+1,r);
	for (int i=l,j=l,k=mid+1;i<=r;i++){
		if ((k>r||b[j].c<=b[k].c)&&j<=mid){
			d[i]=b[j++];
		} else {
			d[i]=b[k++];
		}
	}for (int i=l;i<=r;i++){
		b[i]=d[i];
	}
}
void memsort2(int l,int r){
	if (!(l^r)) return ;
	int mid=l+r>>1;
	memsort2(l,mid);memsort2(mid+1,r);
	for (int i=l,j=l,k=mid+1;i<=r;i++){
		if ((k>r||a[j].b<=a[k].b)&&j<=mid){
			d[i]=a[j++];
		} else {
			d[i]=a[k++];
		}
	}for (int i=l;i<=r;i++){
		a[i]=d[i];
	}
}
void cdq2(int l,int r){
	if (!(l^r)) return ;
	if (r-l+1<=27){ 
		for (int i=l+1;i<=r;i++){
			for (int j=l;j<i;j++){
				if (b[j].a<=b[i].a&&b[j].b<=b[i].b&&b[j].d<=b[i].d){
					ans[b[i].id]=mx(ans[b[i].id],ans[b[j].id]+b[i].w);
				}
			}
		}return ;
	}
	int mid=l+r>>1;
	cdq2(l,mid);
	for (int i=l;i<=r;i++) c[i]=b[i];
	memsort(l,mid);memsort(mid+1,r);long long cnt=0;
	for (int i=l,j=l,k=mid+1;i<=r;i++){
		if ((k>r||c[j].d<=c[k].d)&&j<=mid){
			if (c[j].tmp1==1&&c[j].tmp==1) cnt=mx(cnt,ans[c[j].id]);
			j++;
		} else {
			if (!c[k].tmp&&!c[k].tmp1) ans[c[k].id]=mx(ans[c[k].id],cnt+c[k].w);
			k++;
		}
	}
	cdq2(mid+1,r);
}
void cdq1(int l,int r){
	if (!(l^r)) return ;
	if (r-l+1<=236){ 
		for (int i=l+1;i<=r;i++){
			for (int j=l;j<i;j++){
				if (a[j].a<=a[i].a&&a[j].c<=a[i].c&&a[j].d<=a[i].d){
					ans[a[i].id]=mx(ans[a[i].id],ans[a[j].id]+a[i].w);
				}
			}
		}return ;
	}
	int mid=l+r>>1;
	cdq1(l,mid);
	for (int i=l;i<=r;i++){
		b[i]=a[i];
		if (i<=mid) b[i].tmp1=1;
		else b[i].tmp1=0;
	}
	memsort1(l,r);cdq2(l,r);
	cdq1(mid+1,r);
}
void cdq(int l,int r){
	if (!(l^r)) return ;
	if (r-l+1<=827){ 
		for (int i=l+1;i<=r;i++){
			for (int j=l;j<i;j++){
				if (z[j].b<=z[i].b&&z[j].c<=z[i].c&&z[j].d<=z[i].d){
					ans[z[i].id]=mx(ans[z[i].id],ans[z[j].id]+z[i].w);
				}
			}
		}return ;
	}
	int mid=l+r>>1;
	cdq(l,mid);
	for (int i=l;i<=r;i++){
		a[i]=z[i];
		if (i<=mid) a[i].tmp=1;
		else a[i].tmp=0;
	}
	memsort2(l,r);cdq1(l,r);
	cdq(mid+1,r);
}
signed main(){
	ios::sync_with_stdio(0);
	cin>>n;
	for (int i=1;i<=n;i++){
		cin>>z[i].a>>z[i].b>>z[i].c>>z[i].d>>z[i].w;
	}sort(z+1,z+1+n,cmp);int tp=0;
	for (int i=1;i<=n;i++){
		if (z[i].a==z[i-1].a&&z[i].b==z[i-1].b&&z[i].c==z[i-1].c&&z[i].d==z[i-1].d){
			z[tp].w+=mx(0ll,z[i].w);
		} else z[++tp]=z[i],z[tp].id=tp;
	}n=tp;
	for (int i=1;i<=n;i++) z[i].id=i,ans[i]=z[i].w;
	cdq(1,n);long long as=INT_MIN;
	for (int i=1;i<=n;i++) as=mx(as,ans[i]);
	cout<<as;
	return 0;
}
```

---

## 作者：_Wind_Leaves_ShaDow_ (赞：6)

cdq 套 cdq 的板子。（？）

如果您是像我一样初学 cdq 的初学者，那么这篇博客 **可能** 带给您：

- 本题的 AC 代码、思路以及基本原理相同的 [双倍](https://www.luogu.com.cn/problem/P4849)[经验](https://www.luogu.com.cn/problem/P3769)。

- 用 cdq 优化 dp 时为何需注意分治顺序，以及将顺序更改后同时需改变哪些部分。

- **可能** 的复杂度证明。

因为作者是蒟蒻，只能尽自己所能将对 cdq 的理解写下来供参考，若有疑问、质疑或不满请私聊或移步至其他题解。

---

令 $dp_i$ 表示以 $i$ 为终点最多能获得多大可爱值。

有 $dp_{i}=dp_j+c_i$，其中 $j$ 是满足 $h_j\le h_i,e_j\le  e_i,a_j\le a_i,d_j\le d_i$ 的 $j$ 中 $dp_j$ 最大的一个。

直接枚举复杂度是 $O(n^2)$ 的。

---

考虑三维偏序是 cdq，那么四维偏序也能 cdq。

cdq 的本质就是处理左区间对右区间的贡献。

那么在第一层 cdq 里面我们对一个 $i$ 定义一个 $lf_i$ 表示它是给贡献的点还是被贡献的点。这样我们就能带着这一层的状态进到下一个 cdq 里面，然后就变成了普通的三维偏序。

对于第四维的树状数组，我们看第二层被判断为给贡献的点在第一层是不是也是给贡献的，只有当两个都能满足的时候才能代表这个点能更新后面的其他点。

离散化去重都是很常见的操作不讲了。

---

然后是 cdq 更新 dp 的顺序。

正常的暴力 dp 需要保证什么？

对于任意一个 $i$，所有能更新它的点 $j$ 都已经被更新过了。

否则就会出现我先把 $i$ 用 $j$ 更新，然后我把 $j$ 更新导致 $i$ 没有被更新到。

所以我们在 cdq 里面也要这样子，把左区间更新完后直接处理贡献再看右区间。

有一个小问题，我们在处理贡献时将左右区间按第三维排序，此时打乱了原先按第二维排序的顺序。

右区间的顺序被打乱了，原先往下走应该是按照第二维排序才能得到内层 cdq 的左右区间，但是现在得到的左右区间是基于第三维排序得到的。

解决方法有两个，一个是把按照第二维排序的数组拷贝一个新的然后用那个新的来处理贡献，另一个是在每次内层 cdq 开始时重新按第二维排序。

---

然后是复杂度。

三维偏序我们考虑每一个点都会被访问 $\log n$ 次，一共 $n$ 个点，乘上树状数组的 $\log n$，所以就是 $O(n\log^2 n)$。

对于四维偏序，我们考虑每一个点会被访问的次数。在外围 cdq 会是 $\log n$ 次，每一次又会在内层访问大致 $\log n$ 次，所以总访问次数是 $\log^2 n$ 的，其他的复杂度一样，所以总复杂度是 $O(n\log^3 n)$ 次。

---

喜闻乐见的 [代码](https://www.luogu.com.cn/record/153165264)：

```cpp
#include <bits/stdc++.h>
#define int long long
#define lowbit(x) ((x)&(-x))

using namespace std;
const int N=2e5,Inf=1e18;

inline int read(){
	int x=0,f=1;char ch=getchar();
	for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;
	for(;ch>='0'&&ch<='9';ch=getchar())x=(x<<1)+(x<<3)+(ch^48);
	return x*f;
}

inline void write(int x){
	if(x<0){putchar('-');x=-x;}
	if(x>9)write(x/10);
	putchar(x%10+'0');
	return;
}

int cdn,n=0,dp[N+5],gs[N+5],ans=-Inf;
int lsh[(N<<2)+5],m=0;

inline void cmx(int p,int x){
	for(;p<=m;p+=lowbit(p))gs[p]=max(gs[p],x);
	return;
}

inline int gmx(int p){
	int ret=-Inf;
	for(;p;p-=lowbit(p))ret=max(ret,gs[p]);
	return ret;
}

inline void cgs(int p){
	for(;p<=m;p+=lowbit(p))gs[p]=-Inf;
	return;
}

struct Node{
	int h,e,a,d,c,id;
	bool lf;
}a[N+5],b[N+5],c1[N+5],c2[N+5];

inline void Disc(){
	for(int i=1;i<=cdn;i++){
		lsh[++m]=a[i].h;
		lsh[++m]=a[i].e;
		lsh[++m]=a[i].a;
		lsh[++m]=a[i].d; 
	}
	sort(lsh+1,lsh+m+1);
	m=unique(lsh+1,lsh+m+1)-lsh-1;
	for(int i=1;i<=cdn;i++){
		a[i].h=lower_bound(lsh+1,lsh+m+1,a[i].h)-lsh;
		a[i].e=lower_bound(lsh+1,lsh+m+1,a[i].e)-lsh;
		a[i].a=lower_bound(lsh+1,lsh+m+1,a[i].a)-lsh;
		a[i].d=lower_bound(lsh+1,lsh+m+1,a[i].d)-lsh;
	}
	return;
} 

inline bool cmp1(Node x,Node y){
	return (x.h^y.h?x.h<y.h:(x.e^y.e?x.e<y.e:(x.a^y.a?x.a<y.a:(x.d^y.d?x.d<y.d:x.c>y.c))));
}

inline bool cmp2(Node x,Node y){
	return (x.e^y.e?x.e<y.e:(x.a^y.a?x.a<y.a:(x.d^y.d?x.d<y.d:x.h<y.h)));
}

inline bool cmp3(Node x,Node y){
	return (x.a^y.a?x.a<y.a:(x.d^y.d?x.d<y.d:(x.h^y.h?x.h<y.h:x.e<y.e)));
}

inline void cdq2(int l,int r){
	if(l==r)return;
	int mid=(l+r)>>1,pl=l,pr=mid+1;
	cdq2(l,mid);
	for(int i=l;i<=r;i++)c1[i]=c2[i];
	sort(c1+pl,c1+mid+1,cmp3);
	sort(c1+pr,c1+r+1,cmp3);
	while(pl<=mid&&pr<=r){
		if(c1[pl].a<=c1[pr].a){
			if(c1[pl].lf)cmx(c1[pl].d,dp[c1[pl].id]);
			pl++;
		}else{
			if(!c1[pr].lf)dp[c1[pr].id]=max(dp[c1[pr].id],gmx(c1[pr].d)+c1[pr].c);
			pr++;
		}
	}
	for(;pr<=r;pr++)if(!c1[pr].lf)dp[c1[pr].id]=max(dp[c1[pr].id],gmx(c1[pr].d)+c1[pr].c);
	for(int i=l;i<pl;i++)if(c1[i].lf)cgs(c1[i].d);
	cdq2(mid+1,r);
	return;
}

inline void cdq1(int l,int r){
	if(l==r)return;
	int mid=(l+r)>>1;
	cdq1(l,mid);
	for(int i=l;i<=r;i++){
		c2[i]=b[i];
		c2[i].lf=(i<=mid);
	}
	sort(c2+l,c2+r+1,cmp2);
	cdq2(l,r);
	cdq1(mid+1,r);
	return;
}

signed main(){
	cdn=read();
	for(int i=1;i<=cdn;i++){
		a[i]={read(),read(),read(),read(),read(),0,0};
		ans=max(ans,a[i].c);//有 c 全部是负的数据。
	}
	Disc();
	sort(a+1,a+cdn+1,cmp1);
	for(int i=1;i<=cdn;i++){
		if((a[i].h^b[n].h)||(a[i].e^b[n].e)||(a[i].a^b[n].a)||(a[i].d^b[n].d))b[++n]=a[i];
		else if(a[i].c>0)b[n].c+=a[i].c;
	}
	for(int i=1;i<=n;i++){
		dp[i]=b[i].c;
		b[i].id=i;
	} 
	for(int i=1;i<=m;i++)gs[i]=-Inf;
	cdq1(1,n);
	for(int i=1;i<=n;i++)ans=max(ans,dp[i]);
	write(ans);
	return 0;
}
```

~~写的很长很丑，题解也很长很丑，不喜勿喷，谢谢。~~

---

## 作者：zesqwq (赞：6)

# P5621 [DBOI2019]德丽莎世界第一可爱 本题最优解

[题目传送门](https://www.luogu.com.cn/problem/P5621)

**前置知识：带修 $\text{K-D Tree}$。**

用的不是 $\text{CDQ}$，不是八叉树，是 $\text{K-D Tree}$。

本题主要讲解的不是带修 $\text{K-D Tree}$ 优化 $\text{dp}$ 的思路，而是如何优化到可以通过甚至最优解。

我们发现这是一个典型的四维偏序问题，我们一次将一二三四维排序后，就可以 $\text{dp}$。实际上 $\text{dp}$ 的过程就是求一个 $3$ 维长方体内点权最大值问题，这个东西可以用 $\text{K-D Tree}$ 维护。

我们先把一个带修 $\text{K-D Tree}$ 的代码写出来，您可能可以获得 $60-100$ 的各种分数，现在，我们就开始优化。

优化 $1$，结构体存储：这一点想必卡过常的都知道。

优化 $2$，把数据中所有 $\text{collapse} \leq 0$ 的值更新最大值，然后直接去掉，因为这种打了白打的可以直接去掉。

优化 $3$，这个优化非常重要，就是实际上 $\text{K-D Tree}$ 查询是一个剪枝搜索的过程，我们在一般的矩形包含关系外增加一个最优化箭枝，具体来说，就是用一个全局变量记录搜索过程的最大值，如果现在搜索的一整棵子树最大值都不超过之前搜到的最大值，可以直接跳过。

优化 $4$，这个优化类似于一个小贪心。你 $\text{K-D Tree}$ 查询时，不是要递归左右孩子吗。然后你就优先递归其子树最大值更大的子树，然后再递归较小的，这个东西是要配着优化 $3$ 用的。

优化 $5$，递归过程中少传参数，尽量开全局变量。

优化 $6$，我们发现 $\text{K-D Tree}$ 重构系数在 $0.72$ 左右最优秀。

加上这些优化，您就可以享受从 $\text{TLE}$ 到吊打其它做法的快感！。

最后，如果对有些优化不清楚，可以参考代码。

$\text{Code:}$


```cpp
#include <bits/stdc++.h>
using namespace std;
template <typename T>
inline T sqr(T x) { return x * x; }
#define lc(x) w[x].l
#define rc(x) w[x].r
const int N = 2e5 + 10;
const double alpha = 0.715;
const int SIZ = 1 << 14;
inline char getc() {
    static char bf[SIZ], *begin = bf, *end = bf;
    if (begin == end) begin = bf, end = bf + fread(bf, 1, SIZ, stdin);
    if (begin == end) return EOF;
    return *begin++;
}
inline int read() {
    static char tmp;
    static int ans, flag;
    tmp = getc(), flag = 1, ans = 0;
    while (!isdigit(tmp)) {
        if (tmp == '-') flag = -1;
        tmp = getc();
    }
    while (isdigit(tmp)) ans = (ans << 1) + (ans << 3) + (tmp ^ 48), tmp = getc();
    return ans * flag;
}
int n, rt, cur, g[N], tot;
struct KDTNode {
    int x, y, z;
    long long v;
    int siz, l, r, L, R, D, U, F, B, d;
    long long sum;
} w[N];
inline long long max(long long a, long long b, long long c) { return max(a, max(b, c)); }
inline void pushup(int u) {
    int ls = lc(u), rs = rc(u);
    w[u].siz = w[ls].siz + w[rs].siz + 1;
    w[u].sum = max(w[ls].sum, w[rs].sum, w[u].v);
    w[u].L = w[u].R = w[u].x;
    w[u].U = w[u].D = w[u].y;
    w[u].B = w[u].F = w[u].z;
    if (lc(u)) {
        w[u].L = min(w[u].L, w[ls].L), w[u].R = max(w[u].R, w[ls].R);
        w[u].D = min(w[u].D, w[ls].D), w[u].U = max(w[u].U, w[ls].U);
        w[u].B = min(w[u].B, w[ls].B), w[u].F = max(w[u].F, w[ls].F);
    }
    if (rc(u)) {
        w[u].L = min(w[u].L, w[rs].L), w[u].R = max(w[u].R, w[rs].R);
        w[u].D = min(w[u].D, w[rs].D), w[u].U = max(w[u].U, w[rs].U);
        w[u].B = min(w[u].B, w[rs].B), w[u].F = max(w[u].F, w[rs].F);
    }
}
inline bool canrebuild(int u) { return alpha * w[u].siz <= (double)max(w[lc(u)].siz, w[rc(u)].siz); }
inline bool cmp1(int x, int y) { return w[x].x < w[y].x; }
inline bool cmp2(int x, int y) { return w[x].y < w[y].y; }
inline bool cmp3(int x, int y) { return w[x].z < w[y].z; }
int build(int l, int r) {
    if (l > r) return 0;
    int mid = l + r >> 1;
    double av1 = 0, av2 = 0, av3 = 0, va1 = 0, va2 = 0, va3 = 0;
    for (int i = l; i <= r; i++) av1 += w[g[i]].x, av2 += w[g[i]].y, av3 += w[g[i]].z;
    av1 /= r - l + 1;
    av2 /= r - l + 1;
    av3 /= r - l + 1;
    for (int i = l; i <= r; i++)
        va1 += sqr(w[g[i]].x - av1), va2 += sqr(w[g[i]].y - av2), va3 += sqr(w[g[i]].z - av3);
    if (va1 > va2 && va1 > va3)
        nth_element(g + l, g + mid, g + r + 1, cmp1), w[g[mid]].d = 1;
    else if (va2 > va3)
        nth_element(g + l, g + mid, g + r + 1, cmp2), w[g[mid]].d = 2;
    else
        nth_element(g + l, g + mid, g + r + 1, cmp3), w[g[mid]].d = 3;
    lc(g[mid]) = build(l, mid - 1), rc(g[mid]) = build(mid + 1, r);
    pushup(g[mid]);
    return g[mid];
}
void dfs(int u) {
    if (!u) return;
    dfs(lc(u));
    g[++tot] = u;
    dfs(rc(u));
}
inline void rebuild(int &u) {
    tot = 0;
    dfs(u);
    u = build(1, tot);
}
int needpush;
void insert(int &u) {
    if (!u) {
        u = needpush, w[u].d = 2;
        pushup(u);
        return;
    }
    if (w[u].d == 1) {
        if (w[needpush].x <= w[u].x)
            insert(lc(u));
        else
            insert(rc(u));
    } else if (w[u].d == 2) {
        if (w[needpush].y <= w[u].y)
            insert(lc(u));
        else
            insert(rc(u));
    } else {
        if (w[needpush].z <= w[u].z)
            insert(lc(u));
        else
            insert(rc(u));
    }
    pushup(u);
    if (canrebuild(u)) rebuild(u);
}
int xl, xr, yl, yr, zl, zr;
long long nowans;
void query(int u) {
    if (nowans >= w[u].sum) return;
    if (!u || xr < w[u].L || yr < w[u].D || zr < w[u].B) return;
    if (w[u].R <= xr && w[u].U <= yr && w[u].F <= zr) {
        nowans = max(nowans, w[u].sum);
        return;
    }
    if (w[u].x <= xr && w[u].y <= yr && w[u].z <= zr) nowans = max(nowans, w[u].v);
    if (w[lc(u)].sum > w[rc(u)].sum)
        query(lc(u)), query(rc(u));
    else
        query(rc(u)), query(lc(u));
}
const int P = 1e8 + 10;
struct Node {
    int x, y, z, k;
    long long w;
    inline void gread() { x = read(), y = read(), z = read(), k = read(), w = read(), x += P, y += P, z += P, k += P; }
    inline bool operator<(const Node &b) const { return x != b.x ? x < b.x : (y != b.y ? y < b.y : (z != b.z ? z < b.z : k < b.k)); }
} a[N], ga[N];
long long f[N];
int main() {
    cin >> n;
    int cnt = 0;
    long long maxn = -0x3f3f3f3f3f3f3f3f;
    for (int i = 1; i <= n; i++) {
        a[i].gread();
        if (a[i].w <= 0)
            maxn = max(maxn, a[i].w);
        else
            ga[++cnt] = a[i];
    }
    n = cnt;
    sort(ga + 1, ga + cnt + 1);
    for (int i = 1; i <= n; i++) {
        xl = 1, xr = ga[i].y, yl = 1, yr = ga[i].z, zl = 1, zr = ga[i].k;
        nowans = 0, query(rt);
        maxn = max(maxn, f[i] = ga[i].w + nowans);
        w[++cur] = {ga[i].y, ga[i].z, ga[i].k, f[i]};
        needpush = cur, insert(rt);
    }
    cout << maxn;
    return 0;
}
```

---

## 作者：spire001 (赞：5)

## P5621题解

### 分析
不难看出题目考察的是 cdq 分治优化 dp，首先对于常规的 cdq 分治优化 dp 的解决套路是：
1. 写出偏序关系（状态转移方程）。
2. 打出暴力（熟练的话可以忽略）。
3. 套用 cdq 分治模板。

对于这个题，我们分别记题目中的生命力、能量力、攻击力、防御力为 $a,b,c,d$。

那么就有偏序关系：
$$
a_i\ge a_j, b_i\ge b_j, c_i\ge c_j, d_i\ge d_j
$$

本题中大于还是小于对答案没有影响，为了方便树状数组实现，我们将其改为小于。

还有一个特殊之处是，本题的动态规划转移为四维偏序，所以需要使用 cdq 套 cdq 来优化 dp。

最后有一个需要注意的点，转移时多使用排序，需仔细分析回溯时，是否需要将数组返回原始状态，因此我强烈推荐对所有排序使用 `stable_sort` 而非 `sort`。

### 代码
```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>
#define lowbit(x) (x & -(x))

using namespace std;

typedef long long LL;
constexpr int N = 100010;

int n, m, b[N], ln;
LL ans, c[N], _dp[N]; // 根据答案值域选择 long long

inline void add(const int x, const LL val) { for (int i = x; i <= n; i += lowbit(i)) c[i] = max(c[i], val); return; }
inline int ask(const int x) { LL res = 0; for (int i = x; i; i &= i - 1) res = max(res, c[i]); return res ? res : -N; }
inline void clear(const int x) { for (int i = x; i <= n; i += lowbit(i)) c[i] = 0; return; }

enum color { LEFT, RIGHT, NONE }; // 按照第一维标记

struct node {
  int a, b, c, d, id;
  LL val;
  enum color flag;

  inline bool operator == (const node &Q) const
  {
    return a == Q.a && b == Q.b && c == Q.c && d == Q.d;
  }
  bool operator < (const node &Q) const
  {
    return id < Q.id;
  }
  LL& dp()
  {
    return _dp[id]; // 巧妙的处理了排序后无法更新答案的难题
  }
} a[N], tmp[N];

void cdq2(const int, const int);
void cdq1(const int l, const int r)
{
  if (l == r) return;

  const int mid = (l + r) >> 1;
  cdq1(l, mid);

  for (int i = l; i <= mid; i++) tmp[i] = a[i], tmp[i].flag = LEFT;
  for (int i = mid + 1; i <= r; i++) tmp[i] = a[i], tmp[i].flag = RIGHT;

  stable_sort(tmp + l, tmp + r + 1, [&](const node &A, const node &B) {
    if (A.b != B.b) return A.b < B.b;
    if (A.c != B.c) return A.c < B.c;
    return A.d < B.d;
  }); // 按照第二维偏序关系排序

  cdq2(l, r);

  cdq1(mid + 1, r);
}

void cdq2(const int l, const int r)
{
  if (l == r) 
  {
    tmp[l].dp() = max(tmp[l].dp(), tmp[l].val);
    return;
  } // 初始化

  const int mid = (l + r) >> 1;
  cdq2(l, mid);

  auto cmp = [&](const node &A, const node &B) {
    if (A.c != B.c) return A.c < B.c;
    return A.d < B.d;
  }; // 按照第三维偏序关系排序

  stable_sort(tmp + l, tmp + mid + 1, cmp);
  stable_sort(tmp + mid + 1, tmp + r + 1, cmp);

  int i = l, j = mid + 1;

  while (j <= r) // 双指针转移 dp
  {
    while (i <= mid && tmp[i].c <= tmp[j].c)
    {
      if (tmp[i].flag == LEFT)
        add(tmp[i].d, tmp[i].dp());
      i++;
    }
    if (tmp[j].flag == RIGHT)
      tmp[j].dp() = max(tmp[j].dp(), tmp[j].val + ask(tmp[j].d));
    ans = max(ans, tmp[j].dp()); // 答案取最大值
    j++;
  }

  for (int p = l; p != i; p++) 
    if (tmp[p].flag == LEFT)
      clear(tmp[p].d);
  
  stable_sort(tmp + mid + 1, tmp + r + 1, [&](const node &A, const node &B) {
    if (A.b != B.b) return A.b < B.b;
    if (A.c != B.c) return A.c < B.c;
    return A.d < B.d;
  }); // 回复初始状态

  cdq2(mid + 1, r); // 优化 dp 需要后续遍历

  return;
}

int main()
{
  ios::sync_with_stdio(false);
  cin.tie(nullptr); cout.tie(nullptr);

  cin >> n; 

  for (int i = 1; i <= n; i++)
    cin >> tmp[i].a >> tmp[i].b >> tmp[i].c >> tmp[i].d >> tmp[i].val, b[i] = tmp[i].d, ans = max(ans, tmp[i].val); // 至少需要拿一个

  stable_sort(b + 1, b + n + 1); ln = unique(b + 1, b + n + 1) - b - 1;
  for (int i = 1; i <= n; i++) tmp[i].d = lower_bound(b + 1, b + ln + 1, tmp[i].d) - b; // 最后一位涉及到树状数组插入，需要离散化

  stable_sort(tmp + 1, tmp + n + 1, [&](const node &A, const node &B) {
    if (A.a != B.a) return A.a < B.a;
    if (A.b != B.b) return A.b < B.b;
    if (A.c != B.c) return A.c < B.c;
    return A.d < B.d;
  }); // 按第一维排序

  LL tot = 0;
  for (int i = 1; i <= n; i++)
  {
    tot += max(0ll, tmp[i].val); // 特别注意所有值相同的情况
    if (!(tmp[i] == tmp[i + 1]))
    {
      m++;
      a[m] = tmp[i];
      a[m].val = tot; 
      a[m].id = m;
      ans = max(ans, tot);
      tot = 0;
    }
  }

  if (m) cdq1(1, m); // 没有添加进去任何东西，就可以不同转移了

  cout << ans << endl; // 输出答案

  return 0;
}

/* 
这里展示了转移的进行，- 代表初始化, = 代表左区间转移右区间
1 2 3 4 5 6 7 8
-
= =
  -
= = = =
    -
    = =
      - 
= = = = = = = =
        -
        = =
          -
        = = = =
            -
            = =
              -
*/
```

---

## 作者：Genius_Star (赞：4)

**新增：由于没有考虑负数的影响，被 hack 了，答案的初始值要赋值为负无穷大。**

### 思路：

首先 $dp_i$ 表示以第 $i$ 个点结尾的最长长度，则状态转移方程为：

$$dp_i=\max([a_j \le a_i][b_j \le b_i][c_j \le c_i][d_j \le d_i] dp_j + w_i)$$

朴素转移是 $O(N^2)$ 的，一般情况下会超时~~乱搞能冲过去~~。

因为这题本质是一个四维偏序问题，可以先将第一维 $a$ 进行排序后，变成了三维空间内求一个长方体内最大点值。

考虑使用数据结构进行维护，开一个三层的树套树，外层是树状数组，中层和下层是动态开点线段树。

这样时间和空间复杂度是 $O(N \log^3 N)$ 的，空间上貌似不允许，考虑 cdq 分治算法。

对于三维偏序问题，先将第一维排序，然后设当前分治区间为 $[l,r]$，将左右两区间按照第二维排序，现在要计算 $[l,mid]$ 对 $[mid+1,r]$ 的贡献。

明显可以走指针，对于第三维使用树状数组维护即可，时间复杂度为 $O(N \log^3 N)$，但是空间复杂度基本是 $O(N)$。

其实 cdq 分治本质上是将左右两区间变成 $(a_1,0,c_1)$ 和 $(a_2,1,c_2)$ 的形式，使得左区间的第二维对于右区间都满足条件。

而四维偏序也是同理，考虑将左右两区间变为 $(a_1,0/1,0/1,d_1)$ 和 $(a_2,0/1,0/1,d_2)$ 的形式。

考虑用 cdq 套 cdq 解决，先变为 $(a_1,0,c_1,d_1)$ 和 $(a_2,1,c_2,d_2)$ 的形式，然后将这个区间的第三维进行 cdq 分治。

时间复杂度为 $O(N \log^3 N)$。

**注意第四维要先离散化。**

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define lowbit(x) x&(-x)
using namespace std;
typedef long long ll;
const ll N=50050,INF=1e18; 
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
ll n,cnt,ans=-INF;
ll b[N];
struct Node{
	ll a,b,c,d;	
	ll w,ans;
	bool f;
}a[N];
class BIT{
public:
	ll a[N];
	void add(ll x,ll v){
		for(ll i=x;i<=cnt;i+=lowbit(i))
		  a[i]=max(a[i],v);
	}
	void clear(ll x){
		for(int i=x;i<=cnt;i+=lowbit(i))
		  a[i]=0;
	}
	ll qurey(ll x){
		ll ans=0;
		for(int i=x;i;i-=lowbit(i))
		  ans=max(ans,a[i]);
		return ans;
	}
}T;
bool cmp1(const Node&x,const Node&y){
	if(x.a!=y.a)
	  return x.a<y.a;
	if(x.b!=y.b)
	  return x.b<y.b;
	if(x.c!=y.c)
	  return x.c<y.c;
	return x.d<y.d;
}
bool cmp2(const Node&x,const Node&y){
	if(x.b!=y.b)
	  return x.b<y.b;
	if(x.c!=y.c)
	  return x.c<y.c;
	return x.d<y.d;
}
bool cmp3(const Node&x,const Node&y){
	if(x.c!=y.c)
	  return x.c<y.c;
	return x.d<y.d;
}
void cdq2(ll l,ll r){
	if(l==r)
	  return;
	ll mid=(l+r)>>1;
	cdq2(l,mid);
	stable_sort(a+l,a+mid+1,cmp3);
	stable_sort(a+mid+1,a+r+1,cmp3);
	ll i=l,j=mid+1;
	for(;j<=r;j++){
		while(i<=mid&&a[i].c<=a[j].c){
			if(!a[i].f)
			  T.add(a[i].d,a[i].ans);
			i++;
		}
		if(a[j].f)
		  a[j].ans=max(a[j].ans,T.qurey(a[j].d)+a[j].w);
	}	
	for(int j=l;j<i;j++)
	  if(!a[j].f)
	    T.clear(a[j].d);
	stable_sort(a+l,a+r+1,cmp2);
	cdq2(mid+1,r);
}
void cdq1(ll l,ll r){
	if(l==r)
	  return;
	ll mid=(l+r)>>1;
	cdq1(l,mid);
	for(int i=l;i<=mid;i++)
	  a[i].f=0;
	for(int i=mid+1;i<=r;i++)
	  a[i].f=1;
	stable_sort(a+l,a+r+1,cmp2);
	cdq2(l,r);
	stable_sort(a+l,a+r+1,cmp1);
	cdq1(mid+1,r);
}
int main(){
	n=read();
	for(int i=1;i<=n;i++){
		a[i]={read(),read(),read(),read(),read(),-INF,0};
		b[++cnt]=a[i].d;
		a[i].ans=a[i].w;
	}
	stable_sort(b+1,b+cnt+1);
	cnt=unique(b+1,b+cnt+1)-(b+1);
	for(int i=1;i<=n;i++)
	  a[i].d=lower_bound(b+1,b+cnt+1,a[i].d)-b;
	stable_sort(a+1,a+n+1,cmp1);
	cdq1(1,n);
	for(int i=1;i<=n;i++)
	  ans=max(ans,a[i].ans);
	write(ans);
	return 0;
}
```

---

## 作者：CQ_Bab (赞：2)

# 前言
在 $24$ 年 $7$ 月 $3$ 日被 hack 了，所以改了一下 cmp 和统计答案的方法也就过 hack 了。


我们可以发现这就是一个四维偏序，那么我们就可以采用 cdq 套 cdq 来解决它，然后这里还有两个双倍经验。

# 思路

我们可以得出一个 $n^2$ dp，用 $f_i=\max(f_j+val_i)$ 其中的 $j$ 要满足四维不大于 $i$。

首先我们可以一维一维的来考虑。

对于第一维，和三位偏序一样直接排序即可。

```cpp
il bool cmpa(node a,node b) {
	if(a.a!=b.a) return a.a<b.a;
	if(a.b!=b.b) return a.b<b.b;
	if(a.c!=b.c) return a.c<b.c;
	return a.d<b.d;
}
```

然后我们就需要来考虑如何既保证第 $1$ 维有序有保证第 $2$ 维有序，这里我们可以采用一种标记的形式（毕竟我们只需要加上 $l\sim mid$ 到 $mid+1\sim r$ 互相的贡献）所以我们这里将 $l\sim mid$ 标记成一种颜色再将 $mid+1\sim r$ 标记成另一种颜色即可，然后我们在对于第 $2$ 维进行排序再去算第 $3$ 维即可。

```cpp
bool cmpb(node a,node b) {
	if(a.b!=b.b) return a.b<b.b;
	if(a.c!=b.c) return a.c<b.c;
	if(a.d!=b.d) return a.d<b.d;
	return a.a<b.a;
}
void cdq(int l,int r) {
	if(l==r) return ;
	int mid=l+r>>1;
	cdq(l,mid);
	rep(i,l,r) pb[i]=s[i],pb[i].f=(i<=mid?1:2);
	sort(pb+l,pb+r+1,cmpb);
	cdq2(l,r);
	cdq(mid+1,r);
}
```

这里我们按照三位排序的方法处理最后一维（树状数组）然后我们按照三维排序（分为 $l\sim mid$ 和 $mid+1\sim r$ 分别排序，因为需要保证第 $2$ 维的顺序)的方法先将第三维排序再用双指针去看，如果一个在 $l\sim mid$ 的值被标记为了在 $L\sim Mid$(这里表示再上面的标记中标记为了 $1$) 中 ，就将它的贡献加入树状数组，然后如果遍历到了一个 $mid+1\sim r$ 的一个的标记为 $2$ 就可以取最大值，只需要用树状数组处理出最大值即可。

```cpp
void cdq2(int l,int r) {
	if(l==r) return ;
	int mid=l+r>>1;
	cdq2(l,mid);
	rep(i,l,r) pc[i]=pb[i];
	sort(pc+l,pc+1+mid,cmpc);
	sort(pc+mid+1,pc+1+r,cmpc);
	int j=l;
	for(int i=mid+1;i<=r;i++) {
		while(pc[i].c>=pc[j].c&&j<=mid) {
			if(pc[j].f==1) add(pc[j].d,f[pc[j].id]);
			j++;
		}
		if(pc[i].f==2) f[pc[i].id]=max(f[pc[i].id],Ans(pc[i].d)+pc[i].e);
	}
	rep(i,l,mid) if(pc[i].f==1) clean(pc[i].d);
	cdq2(mid+1,r);
}
```



# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define rep(i,x,y) for(register int i=x;i<=y;i++)
#define rep1(i,x,y) for(register int i=x;i>=y;--i)
#define in(x) scanf("%lld",&x)
#define fire signed
#define il inline
il void print(int x) {
	if(x<0) putchar('-'),x=-x;
	if(x>=10) print(x/10);
	putchar(x%10+'0');
}
int T;
int n,tot;
const int N=5e4+10,M=2e5+10;
struct node{
	int a,b,c,d,e;
	int f,id;
}p[N],s[N],pb[N],pc[N];
il bool cmpa(node a,node b) {
	if(a.a!=b.a) return a.a<b.a;
	if(a.b!=b.b) return a.b<b.b;
	if(a.c!=b.c) return a.c<b.c;
	if(a.d!=b.d) return a.d<b.d;
    return a.e>b.e;
}
bool cmpb(node a,node b) {
	if(a.b!=b.b) return a.b<b.b;
	if(a.c!=b.c) return a.c<b.c;
	if(a.d!=b.d) return a.d<b.d;
	if(a.a!=b.a) return a.a<b.a;
    return a.e>b.e;
}
bool cmpc(node a,node b) {
	if(a.c!=b.c) return a.c<b.c;
	if(a.d!=b.d) return a.d<b.d;
	if(a.a!=b.a) return a.a<b.a;
	if(a.b!=b.b) return a.b<b.b;
    return a.e>b.e;
}
int f[N];
int tr[M];
int idx;
int lowbit(int x) {
	return x&-x;
}
void add(int x,int k) {
	for(;x<=idx;x+=lowbit(x)) tr[x]=max(tr[x],k);
}
int Ans(int x) {
	int res=-INT_MAX;
	for(;x;x-=lowbit(x)) res=max(res,tr[x]);
	return res;
}
void clean(int x) {
	for(;x<=idx;x+=lowbit(x)) tr[x]=-1000100000000000;
}
bool cmp(node a,node b) {
	if(a.d!=b.d) return a.d<b.d;
    return a.e>b.e;
}
unordered_map<int,int>mp;
int getd(int x) {
	if(!mp[x]) mp[x]=++idx;
	return mp[x];
}
void cdq2(int l,int r) {
	if(l==r) return ;
	int mid=l+r>>1;
	cdq2(l,mid);
	rep(i,l,r) pc[i]=pb[i];
	sort(pc+l,pc+1+mid,cmpc);
	sort(pc+mid+1,pc+1+r,cmpc);
	int j=l;
	for(int i=mid+1;i<=r;i++) {
		while(pc[i].c>=pc[j].c&&j<=mid) {
			if(pc[j].f==1) add(pc[j].d,f[pc[j].id]);
			j++;
		}
		if(pc[i].f==2) f[pc[i].id]=max(f[pc[i].id],Ans(pc[i].d)+pc[i].e);
	}
	rep(i,l,mid) if(pc[i].f==1) clean(pc[i].d);
	cdq2(mid+1,r);
}
void cdq(int l,int r) {
	if(l==r) return ;
	int mid=l+r>>1;
	cdq(l,mid);
	rep(i,l,r) pb[i]=s[i],pb[i].f=(i<=mid?1:2);
	sort(pb+l,pb+r+1,cmpb);
	cdq2(l,r);
	cdq(mid+1,r);
}
void solve() {
	in(n);
	int ans=-INT_MAX;
	rep(i,1,n) cin>>p[i].a>>p[i].b>>p[i].c>>p[i].d>>p[i].e,ans=max(ans,p[i].e);
	sort(p+1,p+1+n,cmp);
	rep(i,1,n) p[i].d=getd(p[i].d);
	sort(p+1,p+1+n,cmpa);
	int sum=false;
	rep(i,1,n) {
		sum+=p[i].e;
        ans=max(ans,sum);
		if(p[i].a!=p[i+1].a||p[i].b!=p[i+1].b||p[i].c!=p[i+1].c||p[i].d!=p[i+1].d) {
			s[++tot]={p[i].a,p[i].b,p[i].c,p[i].d,sum,0,tot};
			sum=false;
		}
	}
	rep(i,1,n) tr[i]=-1000100000000000;
	n=tot;
	rep(i,1,n) f[i]=s[i].e;
	cdq(1,n);
	rep(i,1,n) ans=max(ans,f[i]);
	printf("%lld",ans);
	return;
}
fire main() {
	T=1; 
	while(T--) {
		solve();
	}
	return false;
}
```

---

## 作者：IkunTeddy (赞：1)

# 题意
求四维 LIS。

# 题目分析

多维 LIS 偏序问题优先考虑 cdq 优化 dp。

设 $f_i$ 表示以 $i$ 结尾的 LIS 长度。

在递归时，先遍历左边，再用左边的 $f$ 数组更新右边，继续递归右边。最底层用树状数组求解即可。

$$ans=\max\limits_{i=1}^{n}f_i$$

这道题就做完了。

这道题尤其注意 cmp 的写法，最好像我一样写循环比较。

# Code

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
//
const int maxn=1e6+10;
const ll INF=1e18;
int n,N;
int disc[maxn];
ll f[maxn],ans=-INF;
//
ll ft[maxn];
int lowbit(int x){return -x&x;}
void update(int x,ll k){
	for(int i=x;i<=N;i+=lowbit(i))ft[i]=max(ft[i],k);
}
void clear(int x){
	for(int i=x;i<=N;i+=lowbit(i))ft[i]=-INF;
}
ll ask(int x){
	ll res=-INF;
	for(int i=x;i>=1;i-=lowbit(i))res=max(res,ft[i]);
	return res;
}
//
struct node{
	int p[5];
	ll val;
	int id;
	int op[5];
}s[5][maxn];
int now;
bool cmp(node x,node y){
	int k=now;
	for(int i=1;i<=4;i++){
		if(x.p[k]!=y.p[k])return x.p[k]<y.p[k];
		k=((k+1>4)?1:(k+1));
	}
	if(x.op[1]!=y.op[1])return x.op[1]<y.op[1];
	else return x.op[2]<y.op[2];
}
int check(int k,int x,int val){
	return s[k][x].op[1]==val&&s[k][x].op[2]==val;
}
void cdq(int l,int r,int k){
	if(l==r)return ;
	int mid=(l+r)>>1;
	cdq(l,mid,k);
	for(int i=l;i<=r;i++)s[k][i]=s[k-1][i];
	if(k!=3){
		for(int i=l;i<=r;i++)s[k][i].op[k-1]=(i>mid); 
		now=k;
		sort(s[k]+l,s[k]+r+1,cmp);
		cdq(l,r,k+1);
	}else{
		for(int i=l;i<=r;i++)s[k][i].op[k-1]=(i>mid);
		now=k;
		sort(s[k]+l,s[k]+r+1,cmp);
		for(int i=l;i<=r;i++){
			if(check(k,i,0))update(s[k][i].p[k+1],f[s[k][i].id]);
			if(check(k,i,1))f[s[k][i].id]=max(f[s[k][i].id],ask(s[k][i].p[k+1])+s[k][i].val);
		}
		for(int i=l;i<=r;i++)if(check(k,i,0))clear(s[k][i].p[k+1]); 
	}
	cdq(mid+1,r,k);
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=4;j++){
			cin>>s[1][i].p[j];
			disc[++N]=s[1][i].p[j];
		}
		cin>>s[1][i].val;
		s[1][i].id=i;
		f[i]=s[1][i].val;
	}
	sort(disc+1,disc+N+1);
	N=unique(disc+1,disc+N+1)-disc-1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=4;j++){
			s[1][i].p[j]=lower_bound(disc+1,disc+N+1,s[1][i].p[j])-disc;
		}
	}
	for(int i=1;i<=N;i++)ft[i]=-INF;
	now=1;
	sort(s[1]+1,s[1]+n+1,cmp);
	cdq(1,n,2);
	for(int i=1;i<=n;i++)ans=max(ans,f[i]);
	cout<<ans<<'\n';

	return 0;
}
```

---


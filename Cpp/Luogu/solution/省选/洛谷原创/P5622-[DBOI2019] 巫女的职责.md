# [DBOI2019] 巫女的职责

## 题目背景

作为八重村的巫女，樱承担着守卫村庄的责任，村子里受到了崩坏的威胁，八重樱，出击！

![bachongyingyingying](http://i0.hdslb.com/bfs/article/81e9465c02e29053f9fbe7c70d3c2644691abda2.png)

## 题目描述

八重古村有 $n$ 座房屋，一开始所有的房子之间都没有路，随着古村的发展，慢慢会出现连接两栋房屋的双向道路。

村民们原本过着无忧无虑的幸福生活，直到与文明作对——崩坏来了，慢慢地，某栋房屋也许会在遭受崩坏兽的侵袭，每只崩坏兽都有着一定的崩坏能，每户人家也许会存在着多只崩坏兽。

樱来了，她接受了驱魔委托，每个委托都是从驱逐某个房子到另一个房子的崩坏兽，樱只能走已有的路，由于这样的路径也许有很多条，聪明的樱只会选择在它们所有路径中都会走过的某些点，即必经点，每次委托樱会在两点间的所有必经点驱魔。

## 说明/提示

【样例 $1$ 说明】

第四个事件使 $1$ 号房屋有 $1$ 点的崩坏能。

第五个事件使 $1$ 号房屋增加了 $2$ 点的崩坏能，此时其崩坏能值为 $3$。

第六个事件显然答案为 $3$，更新 $\text{lastans}=3$ 。

第七个事件真实的 $x=1$，$y=3$，由于第六个事件已经在 $1$ 驱魔，所以没有崩坏能。

$Subtask$ #$1$（$20$ 分）： 

$1\leq n,m\leq 100000$。

$Subtask$ #$2$（$70$ 分）： 

$1\leq n,m\leq 200000$。

$Subtask$ #$3$（$10$ 分）： 

$1\leq n,m\leq 500000$。

所有测试点的时间限制统一为 $1.5 \text s$，内存限制统一为 $125 \text{MiB}$。

### 题目提供者：[$\color{red}{zhengrunzhe}$](https://www.luogu.org/space/show?uid=14374)

## 样例 #1

### 输入

```
4 7
1 1 2
1 1 3
1 3 4
2 1 1
2 1 2
3 1 4
3 3 4```

### 输出

```
3
0```

## 样例 #2

### 输入

```
4 8
2 1 629
3 3 1
2 4 923
1 4 2
2 4 542
2 1 918
1 2 3
3 4 3
```

### 输出

```
0
5
```

# 题解

## 作者：Brodal_Queue (赞：8)

emmm 这里是萌新的第一篇题解  
****
首先想想没有加边怎么做：  

由于维护的是必经点，也就是割点的信息。  
很容易想到构建圆方树，对于每个点双连通分量建一个方点，点双中的点都连过去，其它边都去掉。

既然还有动态加边，首先当然是用 $\text{Link-Cut Tree}$ 啦。  

对于 $2$ 操作，就直接把 $x$ 点 splay 上去，直接修改点权；对于 $3$ 操作，就是路径求和 + 路径权值变 $0$，也没什么好说的。  

主要说一下 $1$ 操作的做法：  

首先两点不连通，当然是直接连上去；如果已连通，就把路径上的边都断掉，所有点都连向一个方点。  
这样看起来非常暴力，但实际上时间复杂度是对的：用势能分析容易证明，复杂度为 $\text O(q\log n)$。

ps：有一个小优化，就是当一条路径上除了两端全是方点时，就直接忽略连边操作，对答案没有影响。

代码如下：
```cpp
#pragma GCC optimize (2)
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#define N 1000003
#define ll long long
using namespace std;

ll sum[N],a[N];
int son[N][2],fa[N],size[N],st[N];
bool tag[N],rev[N],real[N];

inline void pushup(int u){
    size[u] = size[son[u][0]]+size[son[u][1]]+real[u];
    sum[u] = sum[son[u][0]]+sum[son[u][1]]+a[u];
}

inline bool notrt(int u){
    return son[fa[u]][0]==u||son[fa[u]][1]==u;
}

inline void push_tag(int u){
    sum[u] = a[u] = 0;
    tag[u] = true;
}

inline void push_rev(int u){
    swap(son[u][0],son[u][1]);
    rev[u] ^= 1;
}

inline void pushdown(int u){
    if(tag[u]){
        if(son[u][0]) push_tag(son[u][0]);
        if(son[u][1]) push_tag(son[u][1]);
        tag[u] = 0;
    }
    if(rev[u]){
        if(son[u][0]) push_rev(son[u][0]);
        if(son[u][1]) push_rev(son[u][1]);
        rev[u] = 0;
    }
}

inline bool check(int u){
	return son[fa[u]][1]==u;
}

inline void rotate(int x){
    int y = fa[x],z = fa[y];
    int k = son[y][1]==x,w = son[x][k^1];
    if(notrt(y)) son[z][check(y)] = x;
    son[x][k^1] = y;
    son[y][k] = w;
    if(w) fa[w] = y;
    fa[y] = x,fa[x] = z;
    pushup(y);
}

inline void splay(int x){
    int y = x,z = 1;
    st[1] = y;
    while(notrt(y)) st[++z] = y = fa[y];
    while(z) pushdown(st[z--]);
    while(notrt(x)){
        y = fa[x],z = fa[y];
        if(notrt(y)) rotate(check(x)==check(y)?y:x);
        rotate(x);
    }
    pushup(x);
}

inline void access(int u){
    for(int v=0;u;u=fa[v=u])
        splay(u),son[u][1] = v,pushup(u);
}

inline void makeroot(int u){
    access(u),splay(u);
    push_rev(u);
}

inline void link(int u,int v){
    makeroot(u);
    fa[u] = v;
}

inline void split(int u,int v){
    makeroot(u);
    access(v),splay(v);
}

inline void cut(int u,int v){
    split(u,v);
    son[v][0] = fa[u] = 0;
    pushup(v);
}

inline ll clear(int u,int v){
    split(u,v);
    ll res = sum[v];
    push_tag(v);
    return res;
}

int n,q,top,qaq;
ll ans;
int fk[N],stk[N];

inline int find(int x){
    while(x!=fk[x]) x = fk[x] = fk[fk[x]];
    return x;
}

inline void fuckyou(ll &x){
    x ^= ans%n;
	if(x>n) x %= n;
	if(!x) x = 1;
}

void dfs(int u){
    if(!u) return;
    pushdown(u);
    dfs(son[u][0]);
    stk[++top] = u;
    dfs(son[u][1]);
}

int main(){
    int op;
    ll x,y;
    scanf("%d%d",&n,&q);
    for(int i=1;i<=n;++i){
        fk[i] = i;
        real[i] = true;
    }
    qaq = n;
    while(q--){
        scanf("%d%lld%lld",&op,&x,&y);
        fuckyou(x),fuckyou(y);
        if(op==1){
            if(find(x)==find(y)){
                split(x,y);
                if(size[y]<=2) continue;
                top = 0;
                dfs(y);
                ++qaq;
                for(int i=1;i<top;++i) cut(stk[i],stk[i+1]);
                for(int i=1;i<=top;++i) link(stk[i],qaq);
            }else{
                link(x,y);
                fk[find(x)] = find(y);
            }
        }else if(op==2){
            splay(x);
            a[x] += y;
        }else{
            ans = find(x)==find(y)?clear(x,y):0ll;
            printf("%lld\n",ans);
        }
    }
}
```
因为之前有一道 [P5489](https://www.luogu.org/problem/P5489) 所以这题就显得比较模板（

---

## 作者：1jia1 (赞：4)

看到下面的题解没有给出具体的复杂度证明，这里稍微简单证明一下吧。

用$\text{lct}$维护一棵节点数为$O(n)$的圆方树，操作三就是查询路径权值和，操作二是单点修改。显然单次复杂度都是$O(logn)$。

最主要的是操作一，添加一条边$\text{(u,v)}$后，把$\text{u}$到$\text{v}$路径上的所有点连接到同一个方点上。

一条路径上所有点连接到同一个方点上时，这条路径的大小就变成$O(1)$了，也就是说路径上的点都“消失”了。由于每个点只会消失一次，总共只有$O(n)$个点，因此单次操作的均摊复杂度依然是$O(logn)$。

---

## 作者：Hoks (赞：2)

## 前言
LCT 题单里的，刚好我的[总结文章](https://www.luogu.com.cn/blog/Hok/cute-tree-decomposition)里把这题当做了练习题，就写篇题解吧。

写挂了没多久，挂的原因是我转换输入的函数没写返回值。
## 题意分析
题意简述：

> 1.$x,y$ 间连边。
> 
> 2.单点修改权值。
> 
> 3.求 $x\rightarrow y$ 上的割点权值和。

前两个操作都很好理解，重点在第三种操作上。

第三种操作的主要难点就在于如何动态求割点了。

首先我们考虑下之前静态求割点是怎么做的。

考虑建一颗圆方树，然后在圆方树上维护即可。

那怎么动态呢？

其实很简单，我们只需要在连边前，判断这两个点是否连通，如果已经连通了，那连上这条边就会产生一个环，也就是点双，给路径上的边全部断开然后直接建圆方树即可。

这个复杂度是正确的。

下面给个略证：

> 因为只有加边操作，所以任意一个点最多只会被合并一次（因为合并完后就成一个点了）
> 
> 那这样的话复杂度就是 $O(n)$，再加上 LCT 本身单点修改复杂度为 $\log n$，所以均摊后还是 $\log n$。
> 
> 证毕。

然后就变成圆方树上查询树链信息了。
## 代码
```cpp
#include <bits/stdc++.h>
#define ls son[x][0]
#define rs son[x][1]
#define int long long
using namespace std;
const signed N=1000010;
int n,q,tot,ans,top;
int f[N],s[N],son[N][2],st[N],w[N],h[N],stk[N],si[N];
bool tg[N],r[N],mp[N];
static char buf[1000000],*paa=buf,*pd=buf;
#define getchar() paa==pd&&(pd=(paa=buf)+fread(buf,1,1000000,stdin),paa==pd)?EOF:*paa++
inline signed read(void){
    signed u(0),t(1);char fc(getchar());
    while(!isdigit(fc)){if(fc=='-') t=-1;fc=getchar();}
    while(isdigit(fc)) u=(u<<1)+(u<<3)+(fc^48),fc=getchar();
    return u*t;
}
inline void print(signed u)
{
	if(u<0) putchar('-'),u=-u;
	if(u>9) print(u/10);
	putchar(u%10+'0');
}
inline int find(int x){while(x!=h[x]) x=h[x]=h[h[x]];return x;}
inline void swap(int &x,int &y){x^=y;y^=x;x^=y;}
inline void pushtag(int u){s[u]=w[u]=0;tg[u]=1;}
inline bool ntrt(int x){return son[f[x]][1]==x||son[f[x]][0]==x;}
inline void pushup(int x){s[x]=s[ls]+s[rs]+w[x];si[x]=si[ls]+si[rs]+mp[x];}
inline void pushson(int x){swap(ls,rs),r[x]^=1;}
inline void pushdown(int x)
{
	if(tg[x])
	{
        if(ls) pushtag(ls);
        if(rs) pushtag(rs);
        tg[x]=0;
    }
	if(r[x])
	{
		if(ls) pushson(ls);
		if(rs) pushson(rs);
		r[x]=0;
	}
}
inline void rotate(int x)
{
	int y=f[x],z=f[y],k=(son[y][1]==x),w=son[x][!k];
	if(ntrt(y)) son[z][son[z][1]==y]=x;son[x][!k]=y;son[y][k]=w;
	if(w) f[w]=y;f[y]=x;f[x]=z;
	pushup(y);
}
inline void Splay(int x)
{
	int y=x,tot=0,z;st[++tot]=y;
	while(ntrt(y)) st[++tot]=y=f[y];
	while(tot) pushdown(st[tot--]);
	while(ntrt(x))
	{
		y=f[x];z=f[y];
		if(ntrt(y)) rotate((son[y][0]==x)^(son[z][0]==y)?x:y);
		rotate(x);
	}
	pushup(x);
}
inline void access(int x){for(int y=0;x;x=f[y=x]) Splay(x),rs=y,pushup(x);}
inline void makert(int x){access(x);Splay(x);pushson(x);}
inline int findrt(int x)
{
	access(x);Splay(x);
	while(ls) pushdown(x),x=ls;
	Splay(x);return x;
}
inline int split(int x,int y){makert(x);access(y);Splay(y);return s[y];}
inline void link(int x,int y){makert(x);f[x]=y;}
inline void cut(int x,int y)
{
	makert(x);
	if(findrt(y)==x&&f[y]==x&&!son[y][0]) f[y]=son[x][1]=0,pushup(x);
}
inline int query(int u,int v){split(u,v);int res=s[v];pushtag(v);return res;}
inline int zh(int x){x^=ans%n;if(x>n) x%=n;if(!x) x=1;return x;}//这个return x我之前没写没查出来/cf。
inline void dfs(int x)
{
    if(!x) return;pushdown(x);
    dfs(ls);stk[++top]=x;dfs(rs);
}
signed main()
{
	tot=n=read(),q=read();
	for(int i=1;i<=n;i++) h[i]=i,mp[i]=1;
    for(int i=1,op,x,y;i<=q;i++)
	{
        op=read(),x=zh(read()),y=zh(read());
        if(op==1)
            if(find(x)==find(y))
			{
                split(x,y);if(si[y]<=2) continue;
                top=0;dfs(y);tot++;
                for(int i=1;i<top;i++) cut(stk[i],stk[i+1]);
                for(int i=1;i<=top;i++) link(stk[i],tot);
            }
			else link(x,y),h[find(x)]=find(y);
		else if(op==2) Splay(x),w[x]+=y;
        else ans=find(x)==find(y)?query(x,y):0ll,print(ans),puts("");
    }
	return 0;
}
```


---

## 作者：KiDDOwithTopTree (赞：2)

题目在这：[传送门](https://www.luogu.com.cn/problem/P5622)。

不难发现，这一题主要就是让我们动态找割点。

弄割点有一个很好的东西：**圆方树**。

不会的可以大概在[洛谷日报](https://www.luogu.com.cn/blog/PinkRabbit/Introduction-to-Round-Square-Tree)看看。

那么我们不难得出一个结论：一条链上的割点即为这条链上的圆点。

那么我们就可以知道 3 操作怎么弄了：

先 split 出来 $x$ 到 $y$ 的一条链，然后再求出这条路径上圆点的权值总和。

我们这里的 LCT 维护的其实是**原图的圆方树**。

最后来总结一下：

1. link $x$ 和 $y$，如果成为了一个环（一个点双）就暴力 dfs 缩点成一个方点，再与原来的那些圆点相连。
2. 把 $x$ 旋成根，再加 $y$。
3. split 出 $x$ 到 $y$ 的一条链，然后对 $y$ 进行查询，并打上清空标记。

暴力 dfs 的时复证明其他题解已经说得很清楚了，可以去看看其他题解。

暴力dfs的代码：
```cpp
void dfs(int pos,int fa){//暴力dfs
	spl[pos].fa=fa;//断掉原来的边，连向fa
	pushdown(pos);//记得要下传标记
	if(spl[pos].son[0])
		dfs(spl[pos].son[0],fa);
	if(spl[pos].son[1])
		dfs(spl[pos].son[1],fa);
	spl[pos].son[0]=spl[pos].son[1]=0;//断儿子
	pushup(pos);//更新（毕竟儿子都没了嘛）
}
```

代码如下：
```cpp
#include<iostream>
using namespace std;
const int N=1e6+10;//最多有5e5个圆点，圆方树要开两倍空间
struct splay{
	int fa,son[2];
	int val;//这个点的权值（方点一直为0）
	int sum;//圆点点权总和
	int tag;//清空标记
	int rev;
};
splay spl[N];
inline bool check_root(int pos){
	return spl[spl[pos].fa].son[0]!=pos&&spl[spl[pos].fa].son[1]!=pos;
}
inline int relation(int pos,int fa){
	return spl[fa].son[1]==pos;
}
inline void connect(int pos,int fa,int son){
	spl[pos].fa=fa;
	spl[fa].son[son]=pos;
}
inline void pushup(int pos){
	int lson=spl[pos].son[0],rson=spl[pos].son[1];
	spl[pos].sum=spl[lson].sum+spl[rson].sum+spl[pos].val;//因为方点一直为0，所以记录的就是所有圆点的点权总和
}
inline void pushdown(int pos){
	if(spl[pos].rev){
		swap(spl[pos].son[0],spl[pos].son[1]);
		spl[spl[pos].son[0]].rev^=1;
		spl[spl[pos].son[1]].rev^=1;
		spl[pos].rev=0;
	}
	if(spl[pos].tag){
		spl[spl[pos].son[0]].tag=spl[spl[pos].son[1]].tag=1;
		spl[spl[pos].son[0]].sum=spl[spl[pos].son[0]].val=0;
		spl[spl[pos].son[1]].sum=spl[spl[pos].son[1]].val=0;
		spl[pos].tag=0;
	}
}
inline void pushall(int pos){
	if(!check_root(pos))
		pushall(spl[pos].fa);
	pushdown(pos);
}
void rotate(int pos){
	int fa=spl[pos].fa,gf=spl[fa].fa;
	int t1=relation(pos,fa),t2=relation(fa,gf);
	connect(spl[pos].son[t1^1],fa,t1);
	connect(fa,pos,t1^1);
	spl[pos].fa=gf;
	if(spl[gf].son[t2]==fa)
		spl[gf].son[t2]=pos;
	pushup(fa);
	pushup(pos);
}
void splaying(int pos){
	pushall(pos);
	while(!check_root(pos)){
		int fa=spl[pos].fa,gf=spl[fa].fa;
		if(!check_root(fa))
			relation(pos,fa)^relation(fa,gf)?rotate(pos):rotate(fa);
		rotate(pos);
	}
}
void access(int pos){
	int son=0;
	while(pos){
		splaying(pos);
		spl[pos].son[1]=son;
		pushup(pos);
		son=pos;
		pos=spl[pos].fa;
	}
}
void make_root(int pos){
	access(pos);
	splaying(pos);
	spl[pos].rev^=1;
}
int find_root(int pos){
	access(pos);
	splaying(pos);
	pushdown(pos);
	while(spl[pos].son[0]){
		pos=spl[pos].son[0];
		pushdown(pos);
	}
	splaying(pos);
	return pos;
}
void link(int x,int y){
	make_root(x);
	spl[x].fa=y;
}
void split(int x,int y){
	make_root(x);
	access(y);
	splaying(y);
}
void dfs(int pos,int fa){
	spl[pos].fa=fa;
	pushdown(pos);
	if(spl[pos].son[0])
		dfs(spl[pos].son[0],fa);
	if(spl[pos].son[1])
		dfs(spl[pos].son[1],fa);
	spl[pos].son[0]=spl[pos].son[1]=0;
	pushup(pos);
}
bool check(int x,int y){
	return find_root(x)==find_root(y);
}
int main(){
	int n,m;
	cin>>n>>m;
	int t=0;
	int opt,x,y;
	int lastans=0;
	for(int i=1;i<=m;i++){
		cin>>opt>>x>>y;
		x^=lastans%n;
		if(x>n)
			x%=n;
		if(!x)
			x=1;
		y^=lastans%n;
		if(y>n)
			y%=n;
		if(!y)
			y=1;
		switch(opt){
			case 1:
				if(x==y)//可能有自环
					break;
				if(!check(x,y))//不在同一联通块
					link(x,y);
				else{//在同一联通块
					split(x,y);//分离出来这一条链
					t++;//新的方点编号即为n+t
					dfs(y,n+t);//链上的点连向一个方点
				}
				break;
			case 2:
				splaying(x);//旋成根消除影响
				spl[x].val+=y;
				pushup(x);//更新sum
				break;
			case 3:
				if(!check(x,y))//不在同一联通块
					lastans=0;//记得lastans也要赋值为0
				else{
					split(x,y);
					lastans=spl[y].sum;
					spl[y].val=spl[y].sum=0;//全部清零
					spl[y].tag=1;//tag标记标记清零
				}
				cout<<lastans<<'\n';
				break;
		}
	}
}
```

---

## 作者：huta0 (赞：0)

看到加边和在线，果断想到用 LCT 来做。

做过动态割边和割点，看到是个动态图，就想到用 LCT 和圆方树来做。

简单链修改和动态割点，连通就把树上经过这条链的所有点连到一个方点上来，这样均摊复杂度是对的，一只 log，非常小清新。

```cpp
#include<iostream>
#include<vector>
#include<algorithm>
#include<cstring>
#include<map>
#include<queue>
#define rep(a,b,c) for(int a=b;a<=c;a++)
#define a_all a.begin(),a.end()
using namespace std;
typedef long long ll;
#define int long long
#define i inline
int n,m,lastans;
int op,a,b;
namespace hikari {
      const int N = 5e5+10;
      struct node {
           int p,v,sum,tag,pp,siz;
           int s[2];
      } tr[N<<1];
      #define fa(x) tr[x].p
      #define lc(x) tr[x].s[0]
      #define rc(x) tr[x].s[1]
      #define ntrt(x) lc(fa(x))==x||rc(fa(x))==x
      i void pm(int x) { tr[x].v=tr[x].sum=0; tr[x].pp=1; }
      i void pushup(int x) {
          tr[x].sum=tr[lc(x)].sum+tr[rc(x)].sum+tr[x].v; 
          tr[x].siz=tr[lc(x)].siz+tr[rc(x)].siz+1;
      }
      i void pushdown(int x) {
            if(tr[x].tag) {
                  swap(lc(x),rc(x));
                  tr[lc(x)].tag^=1;
                  tr[rc(x)].tag^=1;
                  tr[x].tag=0;
            }
            if(tr[x].pp) {
                   pm(lc(x)); pm(rc(x));
                   tr[x].pp=0;
            }
      }
      i void pushall(int x) { if(ntrt(x)) { pushall(fa(x)); } pushdown(x); }
      i void rotate(int x) {
            int y=fa(x),z=fa(y);
            int k= rc(y)==x;
            if(ntrt(y)) tr[z].s[rc(z)==y]=x;
            fa(x)=z;
            tr[y].s[k]=tr[x].s[k^1];
            fa(tr[x].s[k^1])=y;
            tr[x].s[k^1]=y;
            fa(y)=x;
            pushup(y); pushup(x);
      }
      i void splay(int x) {
            pushall(x);
            while(ntrt(x)) {
                 int y=fa(x),z=fa(y);
                 if(ntrt(y)) rotate(rc(y)==x^rc(z)==y?x:y);
                 rotate(x);
            }
      }
      i void access(int x) {
            int y=0;
            while(x) {
                  splay(x);
                  rc(x)=y;
                  pushup(x);
                  y=x; x=fa(x);
            }
      }
      i void mkrt(int x) { access(x); splay(x); tr[x].tag^=1; }
      i void split(int x,int y) { mkrt(x); access(y); splay(y); }
      inline int fdrt(int x) {
            access(x);
            splay(x);
            while(lc(x)) pushdown(x),x=lc(x);
            splay(x);
            return x;
      }
      i void link(int x,int y) { mkrt(x); if(fdrt(y)!=x) { fa(x)=y; } }
      i void cut(int x,int y) { mkrt(x); if(fdrt(y)==x&&fa(y)==x&&!lc(y)) { rc(x)=fa(y)=0; pushup(x);} }
      
      int stk[N<<1],top=0,fp=n;
      i void dfs(int x) {
            if(!x) return;
            pushdown(x);
            dfs(lc(x));
            stk[++top]=x;
            dfs(rc(x));
      }
      #undef i
      inline void make(int x,int y) {
             split(x,y);
             if(tr[y].siz<=2) return;
             top=0; dfs(y);
             rep(i,1,top-1) cut(stk[i],stk[i+1]);
             ++fp;
             rep(i,1,top) link(stk[i],fp);
      }
}
using namespace hikari;
inline void decode(int &x)
{
	x^=lastans%n;
	if (x>n)x%=n;
	if (!x)x=1;
}
signed main() {
    cin.tie(0);
    cout.tie(0);
    cin>>n>>m;
    fp=n;
    rep(i,1,m) {
         cin>>op>>a>>b;
         decode(a); decode(b);
         if(op==1) {
              mkrt(a);
              if(fdrt(b)!=a) link(a,b);
              else
                    make(a,b);
         } else if(op==2) {
              splay(a);
              tr[a].v+=b;
         } else {
               mkrt(a);
               if(fdrt(b)==a) split(a,b),cout<<tr[b].sum<<endl,lastans=tr[b].sum,pm(b);
               else cout<<0<<endl,lastans=0;
         }
    }
    return 0;
}
```

---

## 作者：accgj_ (赞：0)

前言：一开始以为是板题，然后发现寄飞了。

------

首先，可以发现要求维护三个操作：

1. 加边。
2. 单点修改点权。
3. 查询两点间割点点权和并置为零。

显然，如果保证是一个森林，那就是 LCT 的裸题，那么就要考虑如何维护割点。

考虑维护圆方树，那么两点间的路径上的圆点就是割点，又变成了 LCT 裸题，而圆方树的维护也不难，对于每次加入的一条边，如果端点不连通就直接连边，否则将圆方树上两点间的路径边断开，并将路径上的点连向一个新的方点（这样最后维护的多半不是一颗圆方树，但是满足两点间的路径上的“圆点”（即 $1$ 到 $n$ 的点）都是原图的割点）。

这样操作，会使树高变为树高减路径长度再加回 $3$（大概理解一下这个，个人感觉和并查集很像，区别在于一个连向新建的点，一个连向原有的根节点），那么总的操作次数为 $\mathcal{O}(n)$ 级别，复杂度即为 $\mathcal{O}(n \log n)$。

还有一种方法，就是对于这条路径在 LCT 上 Splay 打一个 tag，表示这条路径要被清空连向另一个点，这样就是很正常的 LCT ，并且常数更小。

代码如下（直接断边）：

``````cpp
#include<bits/stdc++.h>
using namespace std;

struct tre
{
	int son[2];
	int fa;
	long long size,tot,tag,tag1;
}t[2000001];
int cnt;
inline int getlr(int x){return (t[t[x].fa].son[1]==x);}
inline int isroot(int x){return (t[t[x].fa].son[0]!=x and t[t[x].fa].son[1]!=x);}
inline void pushup(int x)
{
	t[x].size=t[t[x].son[0]].size+t[t[x].son[1]].size+t[x].tot;
}
inline void pushdown(int x)
{
	if(t[x].tag)
	{
		swap(t[x].son[0],t[x].son[1]);
		if(t[x].son[0])t[t[x].son[0]].tag^=1;
		if(t[x].son[1])t[t[x].son[1]].tag^=1;
		t[x].tag=0;
	}
	if(t[x].tag1)
	{
		t[t[x].son[0]].size=0;
		t[t[x].son[1]].size=0;
		t[t[x].son[0]].tot=0;
		t[t[x].son[1]].tot=0;
		t[t[x].son[0]].tag1|=1;
		t[t[x].son[1]].tag1|=1;
		t[x].tag1=0;
	}
	pushup(x);
}
inline void update(int x)
{
	if(!isroot(x))update(t[x].fa);
	pushdown(x);
}
inline void rotate(int x)
{
	if(isroot(x))return;
	int y=t[x].fa,z=t[y].fa,k=getlr(x),kk=getlr(y);
	if(!isroot(y))t[z].son[kk]=x;
	t[x].fa=z;t[y].fa=x;
	t[t[x].son[k^1]].fa=y;
	t[y].son[k]=t[x].son[k^1];
	t[x].son[k^1]=y;
	pushup(y);pushup(x);pushup(z);
}
inline void splay(int x)
{
	update(x);
	if(isroot(x))return;
	for(int f=t[x].fa;f=t[x].fa,(!isroot(x));rotate(x))
	{
		if(!isroot(f))rotate(getlr(x)==getlr(f)?f:x);
	}
}
inline int access(int x)
{
	int p;
	for(p=0;x;p=x,x=t[x].fa)
	{
		splay(x);t[x].son[1]=p;pushup(x);
	}
	return p;
}
inline void makeroot(int x)
{
	x=access(x);
	t[x].tag^=1;
}
inline void split(int x,int y)
{
	makeroot(x);access(y);
}
inline int find(int x)
{
	access(x);
	splay(x);
	pushdown(x);
	while(t[x].son[0])x=t[x].son[0],pushdown(x);
	splay(x);
	return x;
}
stack<int> stk;
inline void dfs(int x)
{
	pushdown(x);
	if(t[x].son[0])dfs(t[x].son[0]);
	stk.push(x);
	if(t[x].son[1])dfs(t[x].son[1]);
}
inline void cut(int x,int y)
{
	int fx=find(x),fy=find(y);
	if(fx!=fy)return;
	split(x,y);splay(x);splay(y);
	if(t[x].fa!=y)return;
	if(t[x].son[getlr(x)^1])return;
	pushdown(y);
	t[x].fa=t[y].son[getlr(x)]=0;
	pushup(y);
}
int n,m;
inline void link(int x,int y)
{
	int fx=find(x),fy=find(y);
	if(fx==fy)
	{
		split(x,y);
		splay(y);
		++cnt;
		while(!stk.empty())stk.pop();
		dfs(y);
		while(!stk.empty())
		{
			int x=stk.top();stk.pop();
			link(cnt+n,x);
			if(stk.empty())
			{
				break;
			}
			cut(x,stk.top());
		}
		return;
	}
	makeroot(x);
	splay(x);
	t[x].fa=y;
}
inline long long query(int x,int y)
{
	int fx=find(x),fy=find(y);
	if(fx!=fy)return 0;
	split(x,y);
	splay(y);
	pushdown(y);pushup(y);
	long long ret=t[y].size;
	t[y].size=t[y].tot=0;
	t[y].tag1|=1;
	return ret;
}
long long lastans=0;
int main()
{
	scanf("%d%d",&n,&m);
	while(m--)
	{
		int opt;long long x,y;scanf("%d%lld%lld",&opt,&x,&y);
		x^=lastans%n;
		if(x>n)x%=n;
		if(!x)x=1;
		y^=lastans%n;
		if(y>n)y%=n;
		if(!y)y=1;
		if(opt==1)
		{
			link(x,y);
			continue;
		}
		if(opt==2)
		{
			makeroot(x);
			splay(x);
			t[x].tot+=y;
			pushup(x);continue;
		}
		if(opt==3)
		{
			lastans=query(x,y);
			printf("%lld\n",lastans);
		}
	}
	return 0;
}
``````

另一份打 tag 的代码：

``````cpp
#include<bits/stdc++.h>
using namespace std;

struct tre
{
	int son[2];
	int fa;
	long long size,tot,tag,tag1;
	int tag2;
}t[2000001];
int cnt;
inline void link(int x,int y);
inline int getlr(int x){return (t[t[x].fa].son[1]==x);}
inline int isroot(int x){return (t[t[x].fa].son[0]!=x and t[t[x].fa].son[1]!=x);}
inline void pushup(int x)
{
	t[x].size=t[t[x].son[0]].size+t[t[x].son[1]].size+t[x].tot;
}
inline void pushdown(int x)
{
	if(t[x].tag)
	{
		swap(t[x].son[0],t[x].son[1]);
		if(t[x].son[0])t[t[x].son[0]].tag^=1;
		if(t[x].son[1])t[t[x].son[1]].tag^=1;
		t[x].tag=0;
	}
	if(t[x].tag1)
	{
		t[t[x].son[0]].size=0;
		t[t[x].son[1]].size=0;
		t[t[x].son[0]].tot=0;
		t[t[x].son[1]].tot=0;
		t[t[x].son[0]].tag1|=1;
		t[t[x].son[1]].tag1|=1;
		t[x].tag1=0;
	}
	if(t[x].tag2)
	{
		t[t[x].son[0]].tag2=t[x].tag2;
		t[t[x].son[1]].tag2=t[x].tag2;
		t[t[x].son[0]].fa=t[x].son[0]=0;
		t[t[x].son[1]].fa=t[x].son[1]=0;
		t[x].fa=t[x].tag2;
		t[x].tag2=0;
	}
	pushup(x);
}
inline void update(int x)
{
	if(!isroot(x))update(t[x].fa);
	pushdown(x);
}
inline void rotate(int x)
{
	if(isroot(x))return;
	int y=t[x].fa,z=t[y].fa,k=getlr(x),kk=getlr(y);
	if(!isroot(y))t[z].son[kk]=x;
	t[x].fa=z;t[y].fa=x;
	t[t[x].son[k^1]].fa=y;
	t[y].son[k]=t[x].son[k^1];
	t[x].son[k^1]=y;
	pushup(y);pushup(x);pushup(z);
}
inline void splay(int x)
{
	update(x);
	if(isroot(x))return;
	for(int f=t[x].fa;f=t[x].fa,(!isroot(x));rotate(x))
	{
		if(!isroot(f))rotate(getlr(x)==getlr(f)?f:x);
	}
}
inline int access(int x)
{
	int p;
	for(p=0;x;p=x,x=t[x].fa)
	{
		splay(x);t[x].son[1]=p;pushup(x);
	}
	return p;
}
inline void makeroot(int x)
{
	x=access(x);
	t[x].tag^=1;
}
inline void split(int x,int y)
{
	makeroot(x);access(y);
}
inline int find(int x)
{
	access(x);
	splay(x);
	pushdown(x);
	while(t[x].son[0])x=t[x].son[0],pushdown(x);
	splay(x);
	return x;
}
stack<int> stk;
inline void dfs(int x)
{
	pushdown(x);
	if(t[x].son[0])dfs(t[x].son[0]);
	stk.push(x);
	if(t[x].son[1])dfs(t[x].son[1]);
}
inline void cut(int x,int y)
{
	int fx=find(x),fy=find(y);
	if(fx!=fy)return;
	split(x,y);splay(x);splay(y);
	if(t[x].fa!=y)return;
	if(t[x].son[getlr(x)^1])return;
	pushdown(y);
	t[x].fa=t[y].son[getlr(x)]=0;
	pushup(y);
}
int n,m;
inline void link(int x,int y)
{
	int fx=find(x),fy=find(y);
	if(fx==fy)
	{
		split(x,y);
		splay(y);
		++cnt;
		t[y].tag2=cnt+n;
		
		return;
	}
	makeroot(x);
	splay(x);
	t[x].fa=y;
}
inline long long query(int x,int y)
{
	int fx=find(x),fy=find(y);
	if(fx!=fy)return 0;
	split(x,y);
	splay(y);
	pushdown(y);pushup(y);
	long long ret=t[y].size;
	t[y].size=t[y].tot=0;
	t[y].tag1|=1;
	return ret;
}
long long lastans=0;
int main()
{
	scanf("%d%d",&n,&m);
	while(m--)
	{
		int opt;long long x,y;scanf("%d%lld%lld",&opt,&x,&y);
		x^=lastans%n;
		if(x>n)x%=n;
		if(!x)x=1;
		y^=lastans%n;
		if(y>n)y%=n;
		if(!y)y=1;
		if(opt==1)
		{
			link(x,y);
			continue;
		}
		if(opt==2)
		{
			makeroot(x);
			splay(x);
			t[x].tot+=y;
			pushup(x);continue;
		}
		if(opt==3)
		{
			lastans=query(x,y);
			printf("%lld\n",lastans);
		}
	}
	return 0;
}
``````

---

## 作者：Starstream (赞：0)

### 题意

动态加边，单点修改点权，查询两点 $x,y$ 间割点权值和。强制在线。

### 思路

动态加边，想到使用 LCT。求割点有个很优美的数据结构：圆方树。

具体地，若该次加边后出现了一个环，则新建一个方点，暴力删除环上所有边，并将环上所有点连向方点。

查询时，分离出 $x\rightarrow y$ 这条路径的信息，发现路径上所有圆点都是割点，因此查询权值和并清空该路径上所有的点权即可。

于是得出本题解法：

- 操作一：$\operatorname{link}(x,y)$，若 $x$ 与 $y$ 本来就连通，就新建一个方点与这个环上所有点连边，同时断开环上原来的边。

- 操作二：通过 $\operatorname{splay}(x)$ 将 $x$ 转到 Splay 树的根，修改点权即可。

- 操作三：$\operatorname{split}(x,y)$，查询这棵 Splay 树上点权和并将该树上所有点权清空。

### 代码

```cpp
#include <iostream>
#define int long long

using namespace std;

const int N = 1000010;

struct Splay_Node
{
    int s[2], p, v;
    int sum, rev, cov;
}tr[N];

int n, m, la, cnt;
int stk[N], tmp[N], idx;

inline const void decode(int &x)
{
    x ^= la % n;
    if (x > n) x %= n;
    if (!x) x = 1;
}

inline void pushrev(int x)
{
    swap(tr[x].s[0], tr[x].s[1]);
    tr[x].rev ^= 1;
}

inline void pushcov(int x)
{
    tr[x].v = tr[x].sum = 0;
    tr[x].cov = 1;
}

inline void pushup(int x)
{
    tr[x].sum = tr[tr[x].s[0]].sum + tr[x].v + tr[tr[x].s[1]].sum;
}

inline void pushdown(int x)
{
    if (tr[x].rev)
    {
        pushrev(tr[x].s[0]), pushrev(tr[x].s[1]);
        tr[x].rev ^= 1;
    }
    if (tr[x].cov)
    {
        pushcov(tr[x].s[0]), pushcov(tr[x].s[1]);
        tr[x].cov = 0;
    }
}

inline bool is_root(int x)
{
    int p = tr[x].p;
    return tr[p].s[0] != x && tr[p].s[1] != x;
}

inline void rotate(int x)
{
    int y = tr[x].p, z = tr[y].p;
    int k = tr[y].s[1] == x;
    if (!is_root(y)) tr[z].s[tr[z].s[1] == y] = x;
    tr[x].p = z;
    tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;
    tr[x].s[k ^ 1] = y, tr[y].p = x;
    pushup(y), pushup(x);
}

inline void splay(int x)
{
    int top = 0, r = x;
    stk[ ++ top] = r;
    while (!is_root(r)) stk[ ++ top] = tr[r].p, r = tr[r].p;
    while (top) pushdown(stk[top -- ]);
    while (!is_root(x))
    {
        int y = tr[x].p, z = tr[y].p;
        if (!is_root(y))
            if ((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x);
            else rotate(y);
        rotate(x);
    }
}

void flatten(int u) // 中序遍历，储存路径上点的编号
{
    pushdown(u);
    if (tr[u].s[0]) flatten(tr[u].s[0]);
    tmp[ ++ idx] = u;
    if (tr[u].s[1]) flatten(tr[u].s[1]);
}

inline int access(int x)
{
    int z = x, y;
    for (y = 0; x; y = x, x = tr[x].p)
        splay(x), tr[x].s[1] = y, pushup(x);
    splay(z);
    return y;
}

inline void make_root(int x)
{
    access(x);
    pushrev(x);
}

inline int find_root(int x)
{
    access(x);
    while (tr[x].s[0]) pushdown(x), x = tr[x].s[0];
    splay(x);
    return x;
}

inline bool judge(int x, int y) // 判断 x, y 是否连通
{
    make_root(x);
    return find_root(y) == x;
}

inline bool link(int x, int y)
{
    if (judge(x, y)) return false; // 已经连通
    else tr[x].p = y;
    return true;
}

inline void split(int x, int y)
{
    make_root(x);
    access(y);
}

signed main()
{
    int op, a, b;
    scanf("%lld%lld", &n, &m), cnt = n;
    while (m -- )
    {
        scanf("%lld%lld%lld", &op, &a, &b);
        decode(a), decode(b);
        if (op == 1)
        {
            if (a == b || link(a, b)) continue; // 这里特判一下子自环
            split(a, b); // 分离出路径，此时 b 为 Splay 的根
            idx = 0, cnt ++ ; // 新建方点
            flatten(b); // 中序遍历
            while (idx)
            {
                int u = tmp[idx -- ];
                tr[u].p = cnt, tr[u].s[0] = tr[u].s[1] = 0;
                // 全部连向方点
                pushup(u); // 由于改变了结构，所以更新一下信息
            }
        }
        else if (op == 2) splay(a), tr[a].v += b, pushup(a);
        // 单点修改，直接改这个节点信息即可。别忘了 pushup。
        else
        {
            if (judge(a, b)) split(a, b), printf("%lld\n", (la = tr[b].sum)), pushcov(b);
            // 如果已经连通，则输出答案并清空点权
            else printf("%lld\n", (la = 0));
        }
    }
    return 0;
}
```

---

## 作者：lenlen (赞：0)

八重樱，出击！

### Problem

题目大意：维护一张无向图，执行下面三个操作：

- 加边；
- 修改点权；
- 求路径上的割点的点权和。

数据范围： $n,m \leq 5 \times 10^5$。

### Solution

[升级版](https://www.luogu.com.cn/problem/P5489)（双倍经验）。

动态图维护割边割点也算一种套路了吧？

我们使用 LCT 维护，维护割点时，我们加入圆方树来维护，具体的，当 Link 的两个节点已经联通时，我们将路径上的所有点连向新建的方点，并将这条路径上的边全部断开。这里利用了圆方树的性质，不知道的可以先去学一下圆方树。

维护割边更加简单，首先化边为点（在维护割边数量的时候并不需要，因为割边数量=链上点数量 -1），然后直接缩点即可。

### Code

码风来自 Enoftaipeople，他教会了我一种简单好写实用的码风。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=2e6+7232,inf=1e9+7;
int n,m;
int f[N],t[N][2],sum[N],lam[N],rev[N],v[N],tot,op,x,y,lst;
int s[N],head;
#define ls t[x][0]
#define rs t[x][1]
#define tp(x) (t[f[x]][1]==x)
#define in(x) (t[f[x]][0]==x||tp(x))
void up(int x) {sum[x]=sum[ls]+sum[rs]+v[x];}
void Rev(int x){swap(ls,rs);rev[x]^=1;}
void down(int x)
{
    if(rev[x]) 
    {
        if(ls) Rev(ls);
        if(rs) Rev(rs);
        rev[x]=0;
    }
    if(lam[x]) 
    {
        if(ls) sum[ls]=v[ls]=0,lam[ls]=1;
        if(rs) sum[rs]=v[rs]=0,lam[rs]=1;
        lam[x]=0;
    }
}
void pdown(int x){if(in(x)) pdown(f[x]);down(x);}
void rot(int x)
{
    int y=f[x],k=tp(x),w=t[x][!k];
    t[f[w]=t[x][!k]=y][k]=w;
    if(in(y)) t[f[y]][tp(y)]=x;
    f[x]=f[y],f[y]=x,up(y);
}
void splay(int x)
{
    pdown(x);
    for(int y=f[x];in(x);rot(x),y=f[x])
        if(in(y)) rot(tp(x)^tp(y)?x:y);
    up(x);
}
void access(int x)
{
    for(int y=0;x;x=f[y=x])
        splay(x),rs=y,up(x);
}
void evert(int x){access(x);splay(x);Rev(x);}
void split(int x,int y){evert(x);access(y);splay(x);}
int groot(int x)
{
    access(x);splay(x);
    while(ls) down(x),x=ls;
    splay(x);return x;
}
bool link(int x,int y)
{
    evert(x);
    if(groot(y)!=x) {f[x]=y;return true;}
    return false;
}
void cut(int x,int y)
{
    evert(x);
    if(groot(y)==x&&f[y]==x&&!t[y][0]) t[x][1]=f[y]=0;
}
int num;
void dfs(int x)
{
    s[++head]=x;if(x<=n) num++;
    down(x);
    if(ls) dfs(ls);
    if(rs) dfs(rs);
}
void add(int x,int y)
{
    if(x==y) return ;
    if(link(x,y)) return ;
    split(x,y);
    num=head=0;dfs(x);
    if(num==2) return ;
    int nw=++tot;
    while(head)
    {
        int z=s[head--];
        f[z]=tot;t[z][0]=t[z][1]=0;
        up(z);
    }
}
inline const void decode(int &x)
{
	x^=lst%n;
	if (x>n)x%=n;
	if (!x)x=1;
}
signed main()
{
    scanf("%d%d",&n,&m);tot=n;
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d%d",&op,&x,&y);
        decode(x);decode(y);
        if(op==1) add(x,y);
        else if(op==2) splay(x),v[x]+=y,up(x);
        else 
        {
            if(groot(x)!=groot(y)) lst=0,printf("0\n");
            else split(x,y),printf("%lld\n",lst=sum[x]),sum[x]=v[x]=0,lam[x]=1;
        }
    }
}

```


---

## 作者：hlsnqdmz (赞：0)

一道动态维护割点的题，完成它您就可以去做[ EntropyIncreaser 与 动态图](https://www.luogu.com.cn/problem/P5489)了。根据题意，我们发现，前两个操作就是 LCT 的模版，我们在于第三个，我们发现，驱魔清除的所谓的崩坏能是路径上的关键点的（~~废话~~），而其他点是不清除的。我们可以发现，如果不是动态加边和强制在线，而是先把边都建好，再逐一修改和查询，这就是圆方树的板子，只需要让方点点权为 0，就可以线段树维护区间求和、查询和推平了。

而有动态加边，我们要用 LCT 解决这个问题，我们会发现差不多，问题是怎么做到动态构建圆方树，其实这并不难，只要建边时判断两点的根相同（记得先判自环），如果是，就用 `split()` 将 $y$ 移到所在树的根，然后 `dfs` 让每个节点连接方点即可，每个方点都要新建一个节点。

```
void dfs(int u, int f)
{
    if (!u)
        return;
    fa(u) = f;
    push_down(u);//这里要记得下传
    dfs(lc(u), f);
    dfs(rc(u), f);
    lc(u) = rc(u) = 0;
    push_up(u);
}

void link(int u, int v)
{
    if (u == v)
        return;
    make_root(u);
    if (find_root(v) != u)
        fa(u) = v;
    else
        k++, split(u, v), dfs(v, k);
}
```

这样 $y$ 的其他儿子与 $y$ 的链会变成虚链， $x\sim y$ 的 splay 上的点都会与方点相连，$x$ 没有儿子，$y$ 没有父亲，其他点的父亲和儿子都连接了方点，所以这样连并不会造成什么其他的影响。

至于查询也不难，特判两点不连通的情况输出 0，否则仍然 `split()` 一次，输出 $y$ 的点权总和，记得打上区间推平标记。

代码：
```
//Just Sayori
#include <iostream>
#include <cstdio>
#include <algorithm>
#define ll long long
#define rnt register int
#define gr getchar
#define pr putchar
#define N 500005
#define M 1000000007
using namespace std;

inline ll read()
{
    ll x = 0, f = 1;
    char ch = gr();
    while (ch < '0' || ch > '9')
        ch == '-' ? f = -1, ch = gr() : ch = gr();
    while (ch >= '0' && ch <= '9')
        x = (x << 3) + (x << 1) + (ch ^ 48), ch = gr();
    return x * f;
}

inline void write(ll x)
{
    static int sta[39], top = 0;
    if (x < 0)
        pr('-'), x = -x;
    do
        sta[++top] = x % 10, x /= 10;
    while (x);
    while (top)
        pr(sta[top--] ^ 48);
}
#define fa(x) s[x].fa
#define lc(x) s[x].ch[0]
#define rc(x) s[x].ch[1]
#define is_root(x) (lc(fa(x))==x||rc(fa(x))==x)

struct tree
{
    int ch[2];
    int fa, tag, tag2;
    ll w, sum;
} s[N << 1];
int n, m, u, v, k;
ll last;

inline const void decode(int &x)
{
    x ^= last % n;
    if (x > n)
        x %= n;
    if (!x)
        x = 1;
}

inline void push_up(int u)
{
    s[u].sum = s[lc(u)].sum + s[rc(u)].sum + s[u].w;
}

inline void push_down(int u)
{
    if (s[u].tag)
    {
        swap(lc(u), rc(u));
        s[lc(u)].tag ^= 1;
        s[rc(u)].tag ^= 1;
        s[u].tag = 0;
    }
    if (s[u].tag2)
    {
        s[lc(u)].tag2 = s[rc(u)].tag2 = 1;
        s[lc(u)].w = s[lc(u)].sum = 0;
        s[rc(u)].w = s[rc(u)].sum = 0;
        s[u].tag2 = 0;
    }
}

void push_all(int u)
{
    if (is_root(u))
        push_all(fa(u));
    push_down(u);
}

inline void rotate(int x)
{
    int y = fa(x), z = fa(y);
    bool k1 = rc(y) == x, k2 = rc(z) == y;
    if (is_root(y))
        s[z].ch[k2] = x;
    fa(x) = z;
    s[y].ch[k1] = s[x].ch[k1 ^ 1];
    fa(s[x].ch[k1 ^ 1]) = y;
    s[x].ch[k1 ^ 1] = y;
    fa(y) = x;
    push_up(y), push_up(x);
}

void splay(int x)
{
    push_all(x);
    while (is_root(x))
    {
        int y = fa(x), z = fa(y);
        if (is_root(y))
            (rc(y) == x)^(rc(z) == y) ? rotate(x) : rotate(y);
        rotate(x);
    }
}

void access(int x)
{
    for (rnt y = 0; x; y = x, x = fa(x))
    {
        splay(x);
        rc(x) = y;
        push_up(x);
    }
}

void make_root(int u)
{
    access(u);
    splay(u);
    s[u].tag ^= 1;
}

int find_root(int u)
{
    access(u);
    splay(u);
    while (lc(u))
        push_down(u), u = lc(u);
    splay(u);
    return u;
}

void split(int u, int v)
{
    make_root(u);
    access(v);
    splay(v);
}

void dfs(int u, int f)
{
    if (!u)
        return;
    fa(u) = f;
    push_down(u);
    dfs(lc(u), f);
    dfs(rc(u), f);
    lc(u) = rc(u) = 0;
    push_up(u);
}

void link(int u, int v)
{
    if (u == v)
        return;
    make_root(u);
    if (find_root(v) != u)
        fa(u) = v;
    else
        k++, split(u, v), dfs(v, k);
}

void modify(int u, int v)
{
    splay(u);
    s[u].w += v;
    push_up(u);
}

int main()
{
    k = n = read(), m = read();
    for (rnt i = 1; i <= m; i++)
        switch (read())
        {
            case 1:
                u = read(), v = read();
                decode(u), decode(v);
                link(u, v);
                break;
            case 2:
                u = read(), v = read();
                decode(u), decode(v);
                modify(u, v);
                break;
            case 3:
                u = read(), v = read();
                decode(u), decode(v);
                if (find_root(u) != find_root(v))
                    last = 0;
                else
                {
                    split(u, v);
                    last = s[v].sum;
                    s[v].w = s[v].sum = 0;
                    s[v].tag2 = 1;
                }
                write(last), pr(10);
                break;
        }
    return 0;
}
```
### 感谢您的观看！

---


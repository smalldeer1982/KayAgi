# 「Wdoi-5」建立与摧毁的结界

## 题目背景

八云紫拥有操控境界程度的能力。作为其式神的八云蓝，同样拥有一定程度的操作境界的能力，而作为八云蓝的式神橙，却因为功力尚且不足，而无法对境界进行过多的干预了。

于是八云蓝打算教教橙，境界的用法。境界可以被抽象成一层一层的括号，操作境界本质上就是对括号序列进行修改。由于橙的能力尚且不足，因此只能进行一些简单的境界的建立与摧毁。

尽管如此，通过简单的操作，亦可以把一个境界转换为另外一个境界。为了给橙作为练习，蓝找来了两个境界的范本。将其中一个境界转换为另外一个境界的难度，就是橙需要施用能力的最小次数。但是由于境界实在太长，蓝决定写一个程序（？）来帮帮她计算出境界的难度。

## 题目描述

境界可以被抽象为由圆括号组成的括号序列。现做出如下定义：

- 定义 $D_i$ 为**嵌套括号序列**。其中 $D_0$ 为零阶嵌套括号序列，被定义为单组括号 $\verb!()!$；而 $D_k$ 则为 $k$ 阶嵌套括号序列（$k \geq 1$）定义为 $\verb!(!D_{k-1}\verb!)!$，即在 $D_{k-1}$ 的外层增添了一层括号。
- 定义 $F_i$ 为**平铺括号序列**。其中 $F_0$ 为零阶平铺括号序列，被定义为单组括号 $\verb!()!$；而 $F_k$ 则为 $k$ 阶平铺括号序列（$k \geq 1$），定义为 $\verb!()!F_{k-1}$，即在 $F_{k-1}$ 的左侧增添了一对括号。

例如，$\verb!((()))!$ 为 $D_2$，$\verb!()()()()!$ 为 $F_{3}$。

现在蓝给出了两个长度为 $n$ 的**合法**括号序列 $A$ 和 $B$。橙可以用以下操作对序列 $A$ 进行变换：

- 选择任意非负整数 $k$，选择括号序列的一个子串满足其为一个 $k$ 阶嵌套括号序列，然后将其变为 $k$ 阶平铺括号序列。
- 选择任意非负整数 $k$，选择括号序列的一个子串满足其为一个 $k$ 阶平铺括号序列，然后将其变为 $k$ 阶嵌套括号序列。

**提示说明**处有「合法括号序列」与「子串」的定义。

现在需要求出将序列 $A$ 变换为序列 $B$ 所需的最少操作数。可以证明，总存在一种操作方案能将序列 $A$ 变换为序列 $B$。

## 说明/提示

样例 $3$ 见下发的附件  $\textbf{\textit{border3.in/border3.ans}}$。  
样例 $4$ 见下发的附件  $\textbf{\textit{border4.in/border4.ans}}$。满足特殊性质 $\text{A}$（见下文）。  
样例 $5$ 见下发的附件  $\textbf{\textit{border5.in/border5.ans}}$。  

#### 样例 1 解释

- 第一步：$\texttt{((\underline{()()})(()()))}\to\texttt{((\underline{(())})(()()))}$。
- 第二步：$\texttt{(((()))(\underline{()()}))}\to\texttt{(((()))(\underline{(())}))}$。
- 第三步：$\texttt{(((()))\underline{((()))})}\to\texttt{(((()))\underline{()()()})}$。
- 第四步：$\texttt{(\underline{((()))}()()())}\to\texttt{(\underline{()()()}()()())}$。
- 第五步：$\texttt{(\underline{()()()()()()})}\to\texttt{(\underline{(((((())))))})}$。
- 第六步：$\texttt{\underline{((((((()))))))}}\to\texttt{\underline{()()()()()()()}}$。

可以证明，不存在更短的方案。

#### 提示

**合法括号序列**通过这样一个形式定义：

- $\verb!()!$ 是合法括号序列。
- 若 $A$ 是合法括号序列，那么 $\verb!(!A\verb!)!$ 是合法括号序列。
- 若 $A,B$ 均为合法括号序列，那么 $AB$ 是合法括号序列。

我们称 $A$ 是 $B$ 的**子串**，当且仅当删除 $B$ 开头若干个字符（可以不删除），再删除 $B$ 末尾若干个字符（可以不删除），剩下来的字符序列与 $A$ 完全相同。

#### 数据范围及约定

本题共有 $20$ 个测试点，每个测试点 $5$ 分。最终分数为所有测试点分数之和。

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|}\hline
\textbf{Task} & \bm{n\le } & \textbf{特殊性质} \cr\hline
1\sim 4 & 10 & - \cr\hline
5\sim 7 & 2\times 10^3 & \text{A} \cr\hline
8\sim 10 & 2\times 10^3 & - \cr\hline
11\sim 15 & 10^6 & \text{A} \cr\hline
16\sim 20 & 10^6 & - \cr\hline
\end{array}
$$

**特殊性质** $\textbf{A}$：保证 $B$ 是 $(n\div 2-1)$ 阶平铺括号序列。

#### 友情提醒

考虑到选手可能会用不同的方式进行字符串的读入，这里保证输入文件**每行末尾没有多余空格**，并且每行都以 `\n` 结尾（也就是说，不会出现多余的 `\r`）。

## 样例 #1

### 输入

```
14
((()())(()()))
()()()()()()()```

### 输出

```
6```

## 样例 #2

### 输入

```
14
((()())(()()))
(()())(()())()```

### 输出

```
10```

# 题解

## 作者：囧仙 (赞：16)

## 题解

为了方便起见，

- 定义展开序列 $B$ 表示将括号序列 $B$ 变为 $\verb!()()...()!$ 的形式。
- 定义堆叠序列 $B$ 表示将括号序列 $B$ 变为 $\verb!(((...)))!$ 的形式。

考虑将一个形如 $\verb!(!A\verb!)!$ 的括号序列（其中 $A$ 为合法的括号序列），现在想要将它展开。那么唯一的路径就是堆叠 $A$，然后使用操作 $1$ 展开 $\verb!(!A\verb!)!$。同样地，要试图堆叠一个序列 $\verb!(!A\verb!)!$，那只能把 $A$ 堆叠。这是本题的一个基本思路。

要想直接实现 $A$ 到 $B$ 的转换有些麻烦。考虑先做性质 $\text{A}$。

设 $f(l,r)$ 表示将**合法括号序列** $A[l:r]$ **展开**需要的最少步骤数目，$g(l,r)$ 表示将**合法括号序列** $A[l:r]$ **堆叠**需要的最少步骤数目。

- 对于 $f(l,r)$，如果与 $A_{l+1}$ 相匹配的那个括号就是 $A_{r-1}$，那么就能发现，$f(l,r)=g(l+1,r-1)+1$；否则，考虑这样的情形：  
$$\texttt{(\textcolor{red}{(...)}\textcolor{cyan}{(...)}...\textcolor{orange}{(...)})}$$  
  需要分别展开 $A[l+1:r-1]$ 当中的这些彩色区间，然后将 $A[l+1:r-1]$ 使用操作 $2$ 嵌套，再将整体使用操作 $1$ 展开。
  
- 对于 $g(l,r)$，如果与 $A_{l+1}$ 相匹配的那个括号就是 $A_{r-1}$，那么就能发现，$g(l,r)=g(l+1,r-1)$；否则，仍然考虑这样的情形：

$$\texttt{(\textcolor{red}{(...)}\textcolor{cyan}{(...)}...\textcolor{orange}{(...)})}$$

  需要分别展开 $A[l+1:r-1]$ 当中的这些彩色区间，然后将 $A[l+1:r-1]$ 使用操作 $2$ 嵌套。此时能够发现 $A[l:r]$ 已经变成了嵌套序列。

具体实现时，我们需要求出与一个括号相匹配的另外一个括号的位置。这一步骤可以进行预处理。具体而言，开一个栈，依次枚举。如果是左括号则直接入栈，如果是右括号则将它与栈顶的左括号匹配并将其弹出。容易发现这么做可以在 $\mathcal O(n)$ 复杂度内预处理。

接着是考虑这两个「区间」$\text{dp}$。它可以使用递归来实现。我们需要用刚刚预处理好的匹配信息，进行次一级括号（上文当中的彩色括号。注意：次一级括号不包含这彩色括号内部的括号）的枚举。容易发现每对括号只会被枚举恰好一次，因此时间复杂度仍然是 $\mathcal O(n)$。

---

在此基础上，我们需要将括号序列 $A$ 转换为 $B$，并输出将 $A$ 转换为 $B$ 所需最少步骤。

值得注意的是，如果可以将一个括号序列 $S$ 经过一系列操作变为括号序列 $T$，那么**总是可以**按照反方向将 $T$ 转化为 $S$，因为操作 $1$ 和 $2$ 是互逆的（对于一种操作，可以使用另一种操作撤回它的效果）。那么就能够发现，如果我们能把 $B$ 用最少步骤展开为平铺括号序列，就能用这么多步骤把一个平铺括号序列转换为 $B$。

但这不是最小方案。考虑如何操作最小。举出下面这个情形：

$$
\begin{aligned}
&\texttt{\textcolor{red}{(...)}(..)(...)(.)\textcolor{blue}{(.....)}\textcolor{orange}{(..)}} \cr
&\texttt{\textcolor{red}{(...)}(.....)(...)\textcolor{blue}{(.....)}\textcolor{orange}{(..)}}
\end{aligned}
$$

容易发现，如果存在某两个括号序列在 $A,B$ 中的位置对应相等（图中的红色、蓝色、橘色括号序列。这里对应相等仅仅指次一级的括号位置相同，不包括这次一级括号里面的内容），那么它们就不需要展开到底，只需要对其中的部分进行递归操作即可。剩下来的部分（黑色部分）则需要全部展开。

这是与刚刚的区间 $\text{dp}$ 相类似的。记 $\operatorname{calc}(l,r)$ 表示将 $A[l:r]$ 转换为 $B[l:r]$ 的最少步骤数。那么我们需要枚举出所有的可以对应相等的次一级括号，对它们采取递归；剩下来的所有括号都**必须**得完全展开（不然就没办法进行转换了）。容易发现时间复杂度还是 $\mathcal O(n)$ 的。

因此发现，总复杂度为 $\mathcal O(n)$。可以通过本题。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
const int MAXN =1e6+3;
int n; char A[MAXN],B[MAXN]; int P[MAXN],Q[MAXN];
void pre(char X[],int U[]){
    stack <int> S; up(1,n,i){
        if(X[i]==')') U[i]=S.top(),U[U[i]]=i,S.pop();
        else S.push(i);
    }
}
int  fun(int U[],int l,int r,bool f){ //0 推平
    if(r-1==l) return 0;
    if(U[r-1]==l+1){
        if(!f) return fun(U,l+1,r-1,true)+1;
        else   return fun(U,l+1,r-1,true); 
    }
    else{
        int ret=0; for(int p=l+1;p!=r;p=U[p]+1)
            ret+=fun(U,p,U[p],false);
        return ret+(f?1:2);
    }
}
bool L[MAXN],R[MAXN];
int  clc(int l,int r){
    if(r-1==l) return 0; int ret=0;
    for(int p=l;p!=r+1;L[p]=1,p=P[p]+1);
    for(int p=l;p!=r+1;R[p]=1,p=Q[p]+1);
    for(int p=l;p!=r+1;L[p]=1,p=P[p]+1)
        if(R[p]&&P[p]==Q[p] ) ret+=clc(p+1,P[p]-1);
    for(int p=l;p!=r+1;p=P[p]+1)
        if(P[p]!=Q[p]||!R[p]) ret+=fun(P,p,P[p],0);
    for(int p=l;p!=r+1;p=Q[p]+1)
        if(P[p]!=Q[p]||!L[p]) ret+=fun(Q,p,Q[p],0);
    for(int p=l;p!=r+1;L[p]=0,p=P[p]+1);
    for(int p=l;p!=r+1;R[p]=0,p=Q[p]+1);
    return ret;
}
int main(){
    scanf("%d%s%s",&n,A+1,B+1);
    pre(A,P),pre(B,Q);
    printf("%d\n",clc(1,n));
    return 0;
    
}
```

---

## 作者：Icyfires18 (赞：8)

比赛时想出了正解但是码挂了，比赛后才 AC 掉的。

P.S.本篇可是当前最优解。update:(现在不是啦)

也可以参考一下 hzx2020 的[题解](https://www.luogu.com.cn/blog/hzx2020/solution-p8228)

### 简化题意

【[题链](https://www.luogu.com.cn/problem/P8227)】有两个括号序列，我们可以互相转换嵌套括号序列和平铺括号序列，对一个括号序列最少转换多少次能变成另一个括号序列？

### 正解思路

算法：贪心 + 较难递归；

时间复杂度：$O(n)$；

空间复杂度：$O(n)$；

注：

1. 现称一个合法括号序列为**一组括号**，一个平铺括号序列为**一排括号**，输入中的两个括号序列分别为**左序列**和**右序列**，“（）” 为**单位括号序列**，同层括号序列的最外侧括号为**子括号**；

2. 定义**铺平**指转换成平铺括号序列，**套起**指转换成嵌套括号序列。

#### Step 1

分析一下样例二转换的过程，我们能发现什么？

$$\rarr ((()())(()()))$$ 

$$\rarr ()()()()()()()$$

$$\rarr (()())(()())()$$

显然，左序列先是变成一排括号，再变成右序列的。

难不成答案就是先把左序列换成一排括号再换成右序列？

肯定不是的，如果本来就有相同的地方，那么为什么还需要再换呢。

所以意思就是只用换不相同的地方，那应该怎么判断不同呢？

首先可以看出，如果两组括号最外面一层的括号位置都不对应的话，转换必是要全部拆解成一排括号再来重组的。因为下一层的变换改变不了当前层序列的子括号位置，只有将全部还原成一排括号，才能重新确定最外层括号的位置，举个栗子。

$$\rarr (······)(··)(····)$$

$$\rarr ()()()()()()()()()$$

$$\rarr (····)(··)(······)$$

然后，只需找出所有的子括号位置不对应的最小括号序列，直接对其进行拆解铺平处理，统计答案就行了，就像下面一样。

$$\rarr (()(\textcolor{red}{(())()})\textcolor{red}{(())})(\textcolor{red}{()(())})$$ 

$$\rarr (()(\textcolor{red}{()()()})\textcolor{red}{()()})(\textcolor{red}{()()()})$$

$$\rarr (()(\textcolor{red}{(()())})\textcolor{red}{()()})(\textcolor{red}{(())()})$$

判断可以用双指针分别指向左右序列中同一层括号的位置，同时扫描序列即可。

**由此，先构造一个 Separate 函数，作用是分离出内容不同的最小括号序列，并传递其位置去处理。要注意的是，传递的两个序列的位置必须对应（即首末位位置相同）。**

#### Step 2

由上文可知，还要构造函数来计算传递的括号序列被拆解铺平所需的操作数。

至于将一排括号转换成另一个括号序列的操作数，其实和反过来铺平它的操作数是相同的。


定义当前括号序列为上一层括号中的完整序列，其子括号内则是完整下一层括号序列。

**令 $S_i$ 为第 $i$ 层当前括号序列，$F_i$ 为 $S_i$ 铺平的操作数，$D_i$ 为 $S_i$ 套起的操作数，$e$ 为单位括号序列。**

- 将当前括号序列铺平时，首先需要让下一层的括号序列全部都被套起，则对于每个子括号及以内，都可以用一次操作铺平（单位括号除外），随后当前序列被铺平。所述即为下式。

$$F_i=\sum{D_{i+1}+1},S_{i+1} \subset S_i$$

- 将当前括号序列套起时，若其子括号唯一（左右对应），则将下一层括号序列套起即可（单位括号除外）；若不唯一，还需先将当前括号序列铺平,再用一次操作套起。所述即为下式。

$$
D_i=\begin{cases}
0 &S_i=e \\
D_{i+1} &S_i=(S_{i+1}) \\
F_i+1 &S_i=(S_{i+1})_k
\end{cases}
$$

**由此，分别构造 turn0 和 turn1 函数互相递归，作用是计算铺平和套起当前括号序列的操作数，并返回计算结果。过程类似树形 DP ，但它是线性的。**

#### Step 3

先用 Predeal 函数预处理出配对括号的对应位置，再对 Separate 函数分离出的每对不同序列分别用 turn0 函数计算处理，将结果累加到答案上，完成即得总操作数。

### 代码解析

[AC 记录](https://www.luogu.com.cn/record/72042142)

1. Predeal 函数使用 stack 栈数据结构处理；

2. Separate 函数使用双指针扫描序列处理；

3. Separate 函数 while 循环解析：
	
    第一个 while ：若指向的子括号位置对应，则向下一层继续进行分离；
    
    第二个 while ：若位置不对应（第一个 while 跳出），则记现位置为起点，向后查找序列不对应的终点，铺平两点间序列，统计答案。
    
```
#include<iostream>
#include<cstdio>
#include<stack>
using namespace std;
const int N=1000001;
int n,ans;
int nxa[N],nxb[N];
char a[N],b[N];
void Predeal(char c[],int nx[]){
	stack<int>sta;
	register int i,k;
	for(i=1;i<=n;++i)
		if(c[i]=='(')sta.push(i);
		else nx[sta.top()]=i,sta.pop();
}
int turn0(char[],int[],int,int);
int turn1(char[],int[],int,int);
int turn0(char c[],int nx[],int l,int r){
	register int i,k=0;
	for(i=l;i<=r;i=nx[i]+1)
		if(i+1!=nx[i])k+=turn1(c,nx,i+1,nx[i]-1)+1;
	return k;
}
int turn1(char c[],int nx[],int l,int r){
	if(l+1==r)return 0;
	if(nx[l]==r)return turn1(c,nx,l+1,r-1);
	else return turn0(c,nx,l,r)+1;
}
void Separate(int l,int r){
	if(l>r)return;
	register int i=l,j=l,frn,bac;
	while(i<=r&&j<=r){
		while(i==j&&nxa[i]==nxb[j]&&i<=r){
			Separate(i+1,nxa[i]-1);
			i=nxa[i]+1,j=nxb[j]+1;
		}if(i>r)break;
		frn=i,i=nxa[i]+1;
		while(i!=j&&i<=r&&j<=r)
			if(i<=j)i=nxa[i]+1;
			else j=nxb[j]+1;
		if(i>r||j>r)bac=r;
		else bac=i-1;
		ans+=turn0(a,nxa,frn,bac);
		ans+=turn0(b,nxb,frn,bac);
	}
}
int main(){
	scanf("%d\n",&n);
	scanf("%s%s",a+1,b+1);
	Predeal(a,nxa);
	Predeal(b,nxb);
	Separate(1,n);
	printf("%d",ans);
	return 0;
}
```

**Thx for reading:)**

谢谢审核求过，这篇原来就是审过了的qwq

---

## 作者：IdnadRev (赞：8)

感觉难度不止蓝题啊。/yun

讲一个比较好想，但不是很好写的做法吧。

建立两棵括号树表示起始串和最终串，每个结点代表一个括号，直接包含的括号之间连一条边。

手玩可得操作一是把一条链变成菊花，操作二是把菊花的一段叶子区间变成一条链。（一个细节是操作一后菊花的中心是链顶的父亲）

我们最后需要两棵树在结点无标号，儿子有顺序的情况下同构，于是考虑贪心地将两棵树尽可能多的结点合并，然后将不同的子树大力重构。

合并结点：我们分治地合并两棵括号树，每到一个结点，我们就将它们所有的儿子尽可能多地分成 size 之和相同的段，然后合并对应段的子树。（如果都是一棵子树就分治合并，否则暴力重构）这个过程可以双指针+map 实现，用哈希表可以做到线性。

重构每一段子树：由于操作可逆，考虑找一个中间状态。很容易想到将子树段同时变为一条链，然后再用一次操作把链变成菊花挂在目前处理的子树根上。于是我们在两棵括号树上 dp 每颗子树变成一条链的最少步数即可。

复杂度 $O(n\log n)$。

代码写吐了。

```
#include<bits/stdc++.h>
using namespace std;
const int maxn=1000005;
int n,top,ans;
int stk[maxn],fa[maxn],rec[maxn],f1[maxn],g1[maxn],f2[maxn],g2[maxn],sz1[maxn],sz2[maxn];
vector<int>v[maxn],w[maxn],prea[maxn],preb[maxn];
string s,t;
map<int,int>mp[maxn];
void dfs1(int x) {
	sz1[x]=1;
	for(int i=0; i<v[x].size(); i++) {
//		printf("v %d->%d\n",x,v[x][i]);
		dfs1(v[x][i]),sz1[x]+=sz1[v[x][i]];
	}
	if(v[x].size()==1)
		f1[x]=f1[v[x][0]],g1[x]=f1[x]+1;
	if(v[x].size()>1) {
		for(int i=0; i<v[x].size(); i++)
			if(sz1[v[x][i]]>1)
				g1[x]+=f1[v[x][i]]+1;
		f1[x]=g1[x]+1;
	}
//	printf("x=%d f1[x]=%d g1[x]=%d\n",x,f1[x],g1[x]);
}
void dfs2(int x) {
	sz2[x]=1;
	for(int i=0; i<w[x].size(); i++) {
//		printf("w %d->%d\n",x,w[x][i]);
		dfs2(w[x][i]),sz2[x]+=sz2[w[x][i]];
	}
	if(w[x].size()==1)
		f2[x]=f2[w[x][0]],g2[x]=f2[x]+1;
	if(w[x].size()>1) {
		for(int i=0; i<w[x].size(); i++)
			if(sz2[w[x][i]]>1)
				g2[x]+=f2[w[x][i]]+1;
		f2[x]=g2[x]+1;
	}
//	printf("x=%d f2[x]=%d g2[x]=%d\n",x,f2[x],g2[x]);
}
void solve(int a,int b) {
	assert(sz1[a]==sz2[b]);
	if(v[a].size()==w[b].size()) {
		int flg=0;
		for(int i=0; i<v[a].size(); i++)
			if(sz1[v[a][i]]!=sz2[w[b][i]]) {
				flg=1;
				break;
			}
		if(flg==0) {
			for(int i=0; i<v[a].size(); i++)
				solve(v[a][i],w[b][i]);
			return ;
		}
	}
	prea[a].resize(v[a].size()+1),preb[b].resize(w[b].size()+1);
	prea[a][0]=preb[b][0]=0,mp[a].clear();
	for(int i=0; i<v[a].size(); i++)
		prea[a][i+1]=prea[a][i]+sz1[v[a][i]],mp[a][prea[a][i+1]]=i+1;
	for(int i=0; i<w[b].size(); i++)
		preb[b][i+1]=preb[b][i]+sz2[w[b][i]];
//	printf("solve a=%d b=%d\n",a,b);
//	printf("prea[a][v[a].size()]=%d preb[b][w[b].size()]=%d\n",prea[a][v[a].size()],preb[b][w[b].size()]);
	int lst=0,lstv=0,now=1,nowv;
	while(1) {
//		printf("now=%d w[b].size()=%d\n",now,w[b].size());
		while(mp[a].count(preb[b][now])==0)
			now++;
//		printf("now=%d\n",now);
		nowv=mp[a][preb[b][now]];//(lstv,nowv] (lst,now]
//		printf("lst=%d now=%d lstv=%d nowv=%d\n",lst,now,lstv,nowv);
		assert(nowv<=v[a].size()),assert(now<=w[b].size());
		if(now-lst==1&&nowv-lstv==1) {
			assert(prea[a][nowv]==preb[b][now]),assert(prea[a][lstv]==preb[b][lst]),assert(sz1[v[a][nowv-1]]==sz2[w[b][now-1]]);
			solve(v[a][nowv-1],w[b][now-1]);
		} else {
			for(int i=lstv+1; i<=nowv; i++)
				if(sz1[v[a][i-1]]>1)
					ans+=f1[v[a][i-1]]+1;
			for(int i=lst+1; i<=now; i++)
				if(sz2[w[b][i-1]]>1)
					ans+=f2[w[b][i-1]]+1;
		}
		lst=now,lstv=nowv,now++;
		if(now>w[b].size()||nowv>v[a].size())
			break;
	}
//	ans+=min(min(f1[a]+f2[b],f1[a]+g2[b]+1),min(g1[a]+g2[b],g1[a]+f2[b]+1));
}
int main() {
//	freopen("tmp.in","r",stdin);
	scanf("%d",&n),cin>>s>>t,s=" "+s,t=" "+t;
	top=0,memset(fa,-1,sizeof(fa)),memset(rec,0,sizeof(rec));
	for(int i=1; i<=n; i++) {
		if(s[i]=='(')
			stk[++top]=i;
		else {
			if(top==0)
				continue;
			rec[i]=stk[top],rec[stk[top]]=i,top--,fa[i]=stk[top];
		}
	}
	for(int i=1; i<=n; i++)
		if(fa[i]!=-1)
			fa[i]=rec[fa[i]],v[fa[i]].push_back(i);
	top=0,memset(fa,-1,sizeof(fa)),memset(rec,0,sizeof(rec));
	for(int i=1; i<=n; i++) {
		if(t[i]=='(')
			stk[++top]=i;
		else {
			if(top==0)
				continue;
			rec[i]=stk[top],rec[stk[top]]=i,top--,fa[i]=stk[top];
		}
	}
	for(int i=1; i<=n; i++)
		if(fa[i]!=-1)
			fa[i]=rec[fa[i]],w[fa[i]].push_back(i);
	dfs1(0),dfs2(0),solve(0,0);
	printf("%d\n",ans);
	return 0;
}
```

---


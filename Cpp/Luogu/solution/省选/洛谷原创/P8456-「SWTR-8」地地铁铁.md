# 「SWTR-8」地地铁铁

## 题目背景

D_T_ : D_tt : ddT_ : ddtt = 9 : 3 : 3 : 1.

## 题目描述

给定一张 $n$ 个点，$m$ 条边的无向连通图。每条边标有 `D` 或 `d`。

定义无序点对 $(x, y)$ 是「[铁的](https://loj.ac/p/3398)」，当且仅当 $x \neq y$ 且 $x, y$ 之间存在同时出现 `D` 和 `d` 的简单路径。

小 A 深知自由组合定律 DdTt 的重要性，所以他让你对这样的点对计数。

注意：

- 简单路径定义为不经过重复 **节点** 的路径。
- 保证图无自环，可能有重边。

## 说明/提示

**「数据范围与约定」**

**本题采用捆绑测试**。

- Subtask #1（6 points）：$n \leq 8$，$m \leq 20$。
- Subtask #2（16 points）：$n\leq 15$，$m\leq 822$。依赖 Subtask #1。
- Subtask #3（17 points）：$m = n - 1$。
- Subtask #4（18 points）：$m = n$。
- Subtask #5（19 points）：$n\leq 1064$，$m\leq 10 ^ 4$。依赖 Subtask #2。
- Subtask #6（24 points）：无特殊限制。依赖 Subtask #3，#4，#5。

对于 $100\%$ 的数据：

- $2\leq n \leq 4\times 10 ^ 5$，$n - 1\leq m\leq  10 ^ 6$。
- $1\leq x, y\leq n$。
- $c\in \{\texttt{D}, \texttt{d}\}$。
- 保证图无自环，可能有重边。

**「帮助与提示」**

请注意 IO 优化。

**「题目来源」**

- [Sweet Round 8](https://www.luogu.com.cn/contest/73382) E
- Idea & Solution：[Alex_Wei](https://www.luogu.com.cn/user/123294)。
- Tester：[asmend](https://www.luogu.com.cn/user/21658)。

## 样例 #1

### 输入

```
0
8 13
1 2 d
1 3 d
2 3 d
3 4 d
3 5 D
4 5 d
4 6 d
5 6 D
6 7 d
6 8 d
6 8 D
6 8 D
7 8 d```

### 输出

```
24```

# 题解

## 作者：Alex_Wei (赞：38)

- Upd on 2023.7.31：更换为更简单的证明。

## [P8456「SWTR-8」地地铁铁](https://www.luogu.com.cn/problem/P8456)

### 题目描述

给定一张 $n$ 个点，$m$ 条边的无向图。每条边标有 `D` 或 `d`。

定义无序点对 $(x, y)$ 是「铁的」，当且仅当 $x \neq y$ 且 $x, y$ 之间存在同时出现 `D` 和 `d` 的简单路径。

对「铁的」点对计数。

- 简单路径定义为不经过重复 **节点** 的路径。
- 保证图无自环，连通，可能有重边。

### 数据范围

- Subtask #1（6 points）：$n \leq 8$，$m \leq 21$。
- Subtask #2（16 points）：$n\leq 15$，$m\leq 822$。依赖 Subtask #1。
- Subtask #3（17 points）：$m = n - 1$。
- Subtask #4（18 points）：$m = n$。
- Subtask #5（19 points）：$n\leq 1064$，$m\leq 10 ^ 4$。依赖 Subtask #2。
- Subtask #6（24 points）：无特殊限制。依赖 Subtask #3，#4，#5。

对于 $100\%$ 的数据：

- $2\leq n \leq 4\times 10 ^ 5$，$n - 1\leq m\leq  10 ^ 6$。
- $1\leq x, y\leq n$。
- $c\in \{\texttt{D}, \texttt{d}\}$。
- 保证图无自环，连通，可能有重边。

### Sol

补集转化变成不存在同时出现 `D`（$1$）和 `d`（$0$）的简单路径。

如果点对之间不存在同时出现 $01$ 的路径，只有以下三种情况：

- 只有 $0$ 路径。
- 只有 $1$ 路径。
- 同时有 $0$ 路径和 $1$ 路径。

接下来的推导需多次应用以下基本事实：

> **性质 $1$**：对于点数 $\geq 3$ 的点双，任给两点 $x\neq y$，存在经过 $x, y$ 的简单环。
>
> **证明**：点双基本性质。若 $x, y$ 不直接相连，由 [门杰定理](https://baike.baidu.com/item/门杰定理/19137908) $k = 2$ 的特殊情形可证。若 $x, y$ 直接相连，若删去 $(x, y)$ 后 $x, y$ 不连通，不妨设 $x$ 所在连通块大小 $\geq 2$，则 $x$ 为原图割点，矛盾，因此删去 $(x, y)$ 后 $x, y$ 连通，从而得到经过 $x, y$ 的简单环。$\square$

#### Part 1

对于只有 $0$ 路径的情况，考虑点双 $B$，猜测若存在 $1$ 边则经过 $B$ 的点对不合法。

> **性质 $2$**：对于点数 $\geq 3$ 的点双，任给一点 $x$ 与一边 $e$，存在经过 $x, e$ 的简单环。
>
> **证明**：将 $e = (u, v)$ 拆成 $(u, w)$ 和 $(w, v)$ 不影响 $B$ 点双连通性。据性质 $1$，存在经过 $x, w$ 的简单环。因 $w$ 仅与 $u, v$ 相连，故 $(u, w), (w, v)$ 在环上，将其替换为 $(u, v)$ 可得经过 $x, e$ 的简单环。$\square$

- 不影响点双连通性的证明：删去 $u$ 或 $v$，因 $w$ 与 $v$ 或 $u$ 连通且 $B$ 删去 $u$ 或 $v$ 后连通可知 $u, v$ 不是割点；删去 $u, v, w$ 以外的点时，将 $(u, w)$ 和 $(w, v)$ 视为 $(u, v)$，$B$ 连通；删去 $w$ 相当于删去 $(u, v)$，若图不连通则 $(u, v)$ 在 $B$ 上为割边，当点数 $\geq 3$ 时 $u$ 或 $v$ 在 $B$ 上为割点，矛盾，故 $B$ 连通。

> **性质 $3$**：对于点数 $\geq 3$ 的点双，点双内任给两点 $x\neq y$ 与一边 $e$，存在 $x \to e \to y$ 的简单路径。
>
> **证明**：由性质 $2$，存在经过 $x, e$ 的简单环 $C$，若 $y\in C$ 则成立，否则令 $P$ 为任意 $y\to x$ 路径，考虑 $P$ 与 $C$ 的第一个交点 $z$，存在使得 $z \neq x$ 的 $P$，否则 $x$ 为割点：删去 $x$ 后 $y$ 无法到达 $C$ 剩余节点。令 $Q = y \to z$ 接上 $z$ 通过环上有 $e$ 的一侧到 $x$ 的路径，则 $Q$ 为 $x \to e\to y$ 的简单路径。$\square$

令 $e$ 为 $1$ 边，对点双内任意两点 $x\neq y$ 应用性质 $3$，结合 $|B| = 2$ 的平凡情况，得

> **结论 $1$**：若点双内存在 $1$ 边，则经过该点双的点对不合法。

因此，删去有 $1$ 边的点双内部所有边，剩余连通块大小选 $2$ 之和即为所求。

对于只有 $1$ 路径的情况同理。

#### Part 2

同时有 $0$ 路径和 $1$ 路径的点对是本题重点，下称「合法点对」。

> **结论 $2$**：若两点之间存在割点，则不合法。 
>
> **证明**：设 $x, y$ 间存在割点 $z$。考虑 $x\to z$ 和 $z\to y$ 的所有路径，它们仅在 $z$ 处相交，否则与 $z$ 为割点矛盾。若同时存在 $0$ 路径 $P_0$ 和 $1$ 路径 $P_1$，将 $P_0$ 在 $x\to z$ 的部分和 $P_1$ 在 $z\to y$ 的部分相接得到 $01$ 路径，不合法。$\square$

可以推出合法点对属于相同点双，考虑点双 $B = (V, E)$，感性猜测 $B$ 内部最多有一对合法对。

接下来证明该结论。

考虑合法点对 $x, y$。令 $x\to y$ 所有 $0$ 路径覆盖点集 $V_0$，所有 $1$ 路径覆盖点集 $V_1$。

>  **结论 $3.1$**：除 $x, y$ 以外，$V_0$ 与 $V_1$ 无交。
>
>  **证明**：若有交，则可通过 $P_0$ 与 $P_1$ 第一个交点调整得到 $01$ 路径。$\square$

> **结论 $3.2$**：$V_0$ 与 $V_1$ 之间无边。
>
> **证明**：若有边 $u\to v$ 满足 $u\in V_0, v\in V_1$，则 $x\to u \to v \to y$ 为 $01$ 路径。$\square$

> **性质 $4$**：对于点数 $\geq 3$ 的点双，任给不同三点 $x, y, z$，存在经过 $x, y, z$ 且以 $x, y$ 为端点的简单路径。
>
> **证明**：考虑以 $z$ 为端点的边 $e$。由性质 $3$，存在 $x\to e\to y$，因此存在 $x\to z\to y$。$\square$

> **结论 $3.3$**：$V_0 \cup V_1 = V$。
>
> **证明**：对任意 $z\neq x, y$ 应用性质 $4$。$\square$

考虑 $z\in V_0$，$z'\in V_0$ 且 $(x, y) \neq (z, z')$。

> **结论 $4$**：存在 $x, y$ 分别到 $z, z'$ 或 $z', z$ 的两条仅经过 $V_0$ 的不交路径。
>
> **证明**：若 $z$ 或 $z'$ 与 $x$ 或 $y$ 相等，显然。
>
> 否则考虑仅经过 $V_0$ 的路径 $P = x\to z\to y$。若 $z'\in P$，显然。
>
> 否则考虑 $z'\to y$ 的任意路径 $Q$。考虑 $Q$ 上与 $P$ 的第一个交点 $p$。总存在 $Q$ 使得 $p\neq z$，否则删去 $z$ 后 $z'$ 无法到达 $P$。
>
> 若 $p$ 在 $x\to z$ 上，则 $x\xrightarrow{P} p \xrightarrow{Q} z'$ 和 $z\xrightarrow{P} y$ 无交点。
>
> 若 $p$ 在 $z\to y$ 上，则 $x\xrightarrow{P} z$ 和 $z'\xrightarrow{Q} y$ 无交点。$\square$

因此，对于任意 $z, z' \in V_0 \land (x, y) \neq (z, z') \land z\neq z'$，存在 $x, y$ 分别到 $z, z'$ 或 $z', z$ 的两条仅经过 $V_0$ 的不交路径。将这两条路径通过 $x, y$ 之间的全 $1$ 路径连起来，得 $z, z'$ 之间不合法。

同理，对于任意 $z, z' \in V_1 \land (x, y) \neq (z, z') \land z\neq z'$，$z, z'$ 之间不合法。

而 $z\in V_0$，$z'\in V_1$ 且 $(x, y) \neq (z, z')$ 之间显然不合法。

综上，$S$ 内部最多有一对合法对。

考虑充要条件，其等价于点双内恰好存在两个点满足同时有 $01$ 出边。

充分性：考虑令唯二的两个点分别为 $x, y$。根据性质 $4$，考虑任意 $x\to u\to y$，路径必然纯色，否则考虑切换颜色的点，该点同时存在 $01$ 出边。因 $x, y$ 同时有 $0, 1$ 出边，故存在全 $0$ 路径和全 $1$ 路径。

必要性：当 $x, y$ 合法时，根据结论 $3.2$ 可知仅有 $x, y$ 同时有 $01$ 出边。

问题在 $\mathcal{O}(n + m)$ 的时间内解决。

---

## 作者：tzc_wk (赞：17)

挺有意思的结论题，结论的证明比较复杂。据出题人说他大概想了几天几夜才证出来，所以本篇题解并不详细给出结论证明，如果有兴趣可以自己去看出题人的题解：https://www.luogu.com.cn/blog/AlexWei/solution-p8456。

首先涉及到简单路径，肯定往双连通分量的方向思考。因此我们首先建出圆方树，并将所有可能的点对分为在同一个点双内和不在同一个点双内的情况处理：

- 先考虑在同一个点双内的情况，显然如果点双里所有边颜色都相同就似了，这种情况下点双内任意一对点对间都不存在经过两种颜色边的路径。如果两种颜色都有，你的第一反应肯定感觉是任意点对间都存在符合条件的路径，但稍微想想就可以找出反例：长度为 $3$ 的环，两个 `D` 一个 `d`，这样 `D` 和 `d` 分界处两个点之间不存在符合要求的路径。思考这样的情况出现的原因：点双里总共只有两个点同时存在 `D` 与 `d` 的出边，这样你要么一直待在 `d` 的区域，要么一直待在 `D` 的区域，如果要从一个区域切换到另一个区域就必须经过这两个点，这样就违背了简单路径。那么是否只有这一个反例呢？答案是肯定的，也就是说如果一个点双里有且只有两个点满足其既有 `D` 也有 `d` 的出边，那么其对答案的贡献就是 $\dbinom{siz}{2}-1$，否则贡献 $\dbinom{siz}{2}$。比较感性的理解方式是你可以走到另一个存在两种颜色出边的点在那里切换颜色。
- 再考虑不在同一个点双内的情况。称所有边都是 `D` 的点双为黑点双，所有边都是 `d` 的点双为白点双，既存在 `D` 又存在 `d` 的点双为混色点双，那么结论是如果两点在圆方树上的路径上全是黑点双，或者全是白点双的时候才不合法。因为如果既存在黑点双又存在白点双，那么显然是合法的，否则其至少存在一个混色点双，根据上一部分的结论，对于一个混色点双而言，最坏的情况就是上文所说的不合法的点对，这种情况下两点之间存在只由 `D` 组成的路径，也存在只由 `d` 组成的路径，但是不存在包含 `D` 和 `d` 的路径，但是由于我们经过了至少一个点双，也就是我们可以通过其他部分的包含 `D` 还是包含 `d`，来决定这两点之间我们是选择只包含 `D` 的路径，还是只包含 `d` 的路径，这样上述点对必然合法，直接并查集求即可。

```cpp
const int MAXN=5e6;
int n,m,hd[MAXN+5],to[MAXN+5],nxt[MAXN+5],val[MAXN+5],ec=1;
vector<int>g[MAXN+5];int typ[MAXN+5];ll res;
void adde(int u,int v,int w){
	to[++ec]=v;val[ec]=w;nxt[ec]=hd[u];hd[u]=ec;
	to[++ec]=u;val[ec]=w;nxt[ec]=hd[v];hd[v]=ec;
}
int dfn[MAXN+5],low[MAXN+5],tim=0,stk[MAXN+5],tp=0;
int e_stk[MAXN+5],e_top,ncnt,in[MAXN+5];
void tarjan(int x){
	dfn[x]=low[x]=++tim;stk[++tp]=x;
	for(int e=hd[x];e;e=nxt[e]){
		int y=to[e];
		if(!dfn[y]){
			e_stk[++e_top]=e>>1;in[e>>1]=1;
			tarjan(y);chkmin(low[x],low[y]);
			if(low[y]>=dfn[x]){
				vector<int>V,E;
				int o;++ncnt;
				do{o=stk[tp--];V.pb(o);}while(o^y);V.pb(x);
				do{o=e_stk[e_top--];in[o]=0;E.pb(o);}while(o^(e>>1));
				static int msk[MAXN+5];
				for(int z:V)g[ncnt].pb(z),g[z].pb(ncnt),msk[z]=0;
				int totmsk=0,sum=0;
				for(int z:E){
					totmsk|=(1<<val[z<<1]);
					msk[to[z<<1]]|=(1<<val[z<<1]);
					msk[to[z<<1|1]]|=(1<<val[z<<1]);
				}
				typ[ncnt]=totmsk-1;
				for(int z:V)sum+=(msk[z]==3);
				if(sum==2)res--;
			}
		}else{
			chkmin(low[x],dfn[y]);
			if(dfn[y]<dfn[x]&&!in[e>>1])e_stk[++e_top]=e>>1;
		}
	}
}
int f[MAXN+5],siz[MAXN+5];
int find(int x){return (!f[x])?x:f[x]=find(f[x]);}
void merge(int x,int y){x=find(x);y=find(y);f[x]=y;siz[y]+=siz[x];}
int main(){
	scanf("%*d%d%d",&n,&m);res=1ll*n*(n-1)/2;
	for(int i=1,u,v;i<=m;i++){
		static char buf[6];scanf("%d%d%s",&u,&v,buf+1);
		adde(u,v,buf[1]=='D');adde(v,u,buf[1]=='D');
	}ncnt=n;tarjan(1);
	for(int i=1;i<=n;i++)siz[i]=1;
	for(int i=n+1;i<=ncnt;i++)if(typ[i]==0)for(int y:g[i])merge(i,y);
	for(int i=1;i<=ncnt;i++)if(find(i)==i)res-=1ll*siz[i]*(siz[i]-1)/2;
	memset(f,0,sizeof(f));memset(siz,0,sizeof(siz));
	for(int i=1;i<=n;i++)siz[i]=1;
	for(int i=n+1;i<=ncnt;i++)if(typ[i]==1)for(int y:g[i])merge(i,y);
	for(int i=1;i<=ncnt;i++)if(find(i)==i)res-=1ll*siz[i]*(siz[i]-1)/2;
	printf("%lld\n",res);
	return 0;
}
```



---

## 作者：灵华 (赞：7)

[luoguP8456 地地铁铁](https://www.luogu.com.cn/problem/P8456)

题目大意：

给定 $n$ 个点 $m$ 条边的无向图，每条边有黑白两种颜色。求出两点之间存在既有黑边又有白边的简单路径的点对数。

数据范围：

$n\le 4\times 10^5,m\le 10^6$。

解法：
首先感谢这题没卡一个 log 的做法，嘿嘿。

然后膜拜一下出题人，线性的做法太牛逼啦！~~同时萌新小宝宝也表示没有看懂~~。

这里给出一个比较好理解的圆方树加点分治的做法。

观察题目，这题只需要求两点之间存在一条满足条件的路径就可以。那么我们只需要想办法把满足条件的给构造一条路径出来就可以了。

先把圆方树建出来。对于圆方树有个比较特别的性质，不会有任意两个圆点连在一起。那么我们就把一个点双的边的信息给记录在方点上，就是说这个点双里有哪些颜色的边。

那么我们把点对给分类，分成两个点连在同一个方点和不同方点两种情况。

对于第二种情况，我们只需要统计，两个点之间经过的方点，是否满足两个颜色都有就可以了。

这个是好证明的。他们之间一定至少有两个方点，那么这两个方点都有自己各自的颜色集合。不满足条件只有这些所有的方点都只有同一种颜色，只要有两种颜色我们就可以构造出在一个点双里至少经过一种颜色的路径。并且是想让他有哪种就有哪种。那么两个及以上的方点一定能找到两种颜色都具备的构造方法。

那么考虑第一种情况。这种情况麻烦就在于可能他们同时连着的方点有两种颜色，但是这对点不满足条件。

比如数据：`1 2 D 1 3 d 3 2 d`。

$1$ 号点和 $2$ 号点会连在同一个点双上，而且这个方点两种颜色都有。但是这个点对不满足条件。

那么这是为什么呢，因为无向图的点双是指两点之间有不止一条不经过重复边的路径，有可能一条路径上只有一个颜色。

但是对于这种情况，仔细观察一下就能发现，一个点双里最多出现一对这样子的点，其他的所有点都是满足上面第二种情况的统计方法的。

那什么时候会出现呢？自己仔细观察一下就能发现：一个点双里有两种颜色，并且只考虑在点双内部的点和边，既连着黑边又连着白边的点只有两个（当然对于一个边颜色有两种的点双，这样子的点至少有两个）。

只有这种情况我们会在这个点双里找到一对不满足上述统计方法的点对。那么直接减去 $1$ 就可以了。

那么现在问题就变成了如何统计在圆方树上经过的方点具有两种颜色的点对数。直接上点分治就是很好解决的。

至于怎么找到满足那个特殊条件的点双，我们可以在tarjan往栈里加点的时候把边也加进去，建圆方树的时候同时把所有和这个方点有关的边都弹出来统计信息就可以了。

时间复杂度：$O(m\log m+n + n\log n)$。

至于为啥有那个 $O(m\log m)$ 是因为我把边去重了，注意在这个方法里去重是必须的！（虽然这样可能一条边就有两种颜色，但是这并不影响最终答案的统计。）

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std ;

#define int long long
inline int read ( ) {
	char ch = getchar ( ) ;
	int x = 0 ;
	while ( ch < '0' || ch > '9' )
		ch = getchar ( ) ;
	while ( ch >= '0' && ch <= '9' )
		x = x * 10 + ch - 48 , ch = getchar ( ) ;
	return x ;
}

const int N = 1000005 ;
int n , m , tot , col , dp , top , tep , ax , rt ;
int dfn[N] , low[N] , st[N] , clr[N] , id[N][4] ;
int siz[N] , val[N] , vis[N] , s[4] , ans ;

vector < int > ed[N] , vd ;

struct Ed {
	int u , v , w ;
} eg[N] , se[N] ;

inline bool cmp ( Ed a , Ed b ) {
	if ( a .u == b .u ) return a .v < b .v ;
	return a .u < b .u ;
}

vector < Ed > ve ;

struct Edge {
	int nxt , to , len ;
} edge[N<<2] ;

int cnt , head[N] ;
void insert ( int u , int v , int w ) {
	edge [ ++ cnt ] = { head [ u ] , v , w } ;
	head [ u ] = cnt ;
	edge [ ++ cnt ] = { head [ v ] , u , w } ;
	head [ v ] = cnt ;
}

void add ( int x , int y ) {
	ed [ x ] .push_back ( y ) ;
	ed [ y ] .push_back ( x ) ;
}

void check ( ) {
	for ( int i : vd ) id [ i ] [ 1 ] = id [ i ] [ 2 ] = 0 ;
	for ( Ed i : ve ) {
		if ( i .w == 3 ) {
			++ id [ i .u ] [ 1 ] , ++ id [ i .v ] [ 1 ] ;
			++ id [ i .u ] [ 2 ] , ++ id [ i .v ] [ 2 ] ;
			continue ;
		}
		++ id [ i .u ] [ i .w ] , ++ id [ i .v ] [ i .w ] ;
	}
	int su = 0 ;
	for ( int i : vd )
		if ( id [ i ] [ 1 ] && id [ i ] [ 2 ] ) ++ su ;
	if ( su <= 2 ) -- ans ;
}

void tarjan ( int x , int la ) {
	dfn [ x ] = low [ x ] = ++ dp ;
	st [ ++ top ] = x ;
	for ( int i = head [ x ] ; i ; i = edge [ i ] .nxt ) {
		int y = edge [ i ] .to ;
		if ( ! dfn [ y ] ) {
			tarjan ( y , x ) ;
			se [ ++ tep ] = { x , y , edge [ i ] .len } ;
			low [ x ] = min ( low [ x ] , low [ y ] ) ;
			if ( low [ y ] >= dfn [ x ] ) {
				++ tot ;
				++ col ;
				int k = st [ top -- ] , sz = 2 ;
				while ( k != y ) {
					++ sz ;
					add ( tot , k ) ;
					clr [ k ] = col ;
					vd .push_back ( k ) ;
					k = st [ top -- ] ;
				}
				add ( tot , x ) ;
				add ( tot , y ) ;
				vd .push_back ( x ) ;
				vd .push_back ( y ) ;
				clr [ x ] = clr [ y ] = col ;
				Ed tp = se [ tep -- ] ;
				while ( clr [ tp .u ] == col && clr [ tp .v ] == col ) {
					val [ tot ] |= tp .w ;
					ve .push_back ( tp ) ;
					if ( ! tep ) break ;
					tp = se [ tep -- ] ;
				}
				if ( clr [ tp .u ] != col || clr [ tp .v ] != col ) ++ tep ;
				if ( val [ tot ] == 3 ) {
					if ( sz > 2 )
						check ( ) ;
					else -- ans ;
				}
				vector < int > pq ; pq .swap ( vd ) ;
				vector < Ed > qp ; qp .swap ( ve ) ;
			}
		}
		else {
			if ( y != la && dfn [ x ] > dfn [ y ] )
				se [ ++ tep ] = { x , y , edge [ i ] .len } ;
			low [ x ] = min ( low [ x ] , dfn [ y ] ) ;
		}
	}
}

void dfs0 ( int x , int la , int sn ) {
	siz [ x ] = 1 ;
	int axx = 0 ;
	for ( int y : ed [ x ] ) {
		if ( y == la || vis [ y ] ) continue ;
		dfs0 ( y , x , sn ) ;
		siz [ x ] += siz [ y ] ;
		axx = max ( axx , siz [ y ] ) ;
	}
	axx = max ( axx , sn - siz [ x ] ) ;
	if ( axx < ax )
		ax = axx , rt = x ;
}

void dfs ( int x , int la , int vs ) {
	if ( x <= n ) ++ s [ vs ] ;
	vs |= val [ x ] ;
	for ( int y : ed [ x ] ) {
		if ( y == la || vis [ y ] ) continue ;
		dfs ( y , x , vs ) ;
	}
}

void solve ( int x ) {
	int s1 = 0 , s2 = 0 , s3 = 0 ;
	for ( int y : ed [ x ] ) {
		if ( vis [ y ] ) continue ;
		dfs ( y , x , val [ x ] ) ;
		ans += ( s1 + s2 + s3 ) * s [ 3 ] + ( s [ 1 ] + s [ 2 ] ) * s3 + s [ 1 ] * s2 + s [ 2 ] * s1 ;
		s1 += s [ 1 ] , s2 += s [ 2 ] , s3 += s [ 3 ] ;
		s [ 1 ] = s [ 2 ] = s [ 3 ] = 0 ;
	}
	if ( x <= n ) ans += s3 ;
	vis [ x ] = 1 ;
	for ( int y : ed [ x ] ) {
		if ( vis [ y ] ) continue ;
		ax = tot , rt = 0 ;
		dfs0 ( y , 0 , siz [ y ] ) ;
		solve ( rt ) ;
	}
}

signed main ( ) {
	cin >> n ;
	cin >> n >> m ;
	for ( int i = 1 ; i <= m ; ++ i ) {
		eg [ i ] .u = read ( ) , eg [ i ] .v = read ( ) ;
		if ( eg [ i ] .u > eg [ i ] .v ) swap ( eg [ i ] .u , eg [ i ] .v ) ;
		char op = getchar ( ) ; while ( op != 'd' && op != 'D' ) op = getchar ( ) ;
		eg [ i ] .w = ( op == 'd' ) + 1 ;
	}
	sort ( eg + 1 , eg + 1 + m , cmp ) ;
	int la = 1 ;
	for ( int i = 2 ; i <= m ; ++ i ) {
		if ( eg [ i ] .u == eg [ la ] .u && eg [ i ] .v == eg [ la ] .v )
			eg [ la ] .w |= eg [ i ] .w ;
		else
			eg [ ++ la ] = eg [ i ] ;
	}
	for ( int i = 1 ; i <= la ; ++ i )
		insert ( eg [ i ] .u , eg [ i ] .v , eg [ i ] .w ) ;
	tot = n ;
	for ( int i = 1 ; i <= n ; ++ i )
		if ( ! dfn [ i ] ) tarjan ( i , 0 ) ;
	ax = tot ;
	dfs0 ( 1 , 0 , tot ) ;
	solve ( rt ) ;
	cout << ans << "\n" ;
	return 0 ;
}
```

后话：

这个题在做的时候其实一开始并没有想到那个特殊的点双情况的。把前面统计的方法编完了之后，写完了才发现问题。但是仔细想了想就解决了。

所以出现问题是正常的。但是考场一定注意要把情况想全了！

不然写完了这个好几 K 的代码，才发现有问题就亏大了。

至于速度，喜提最劣解，哈哈哈哈。所以想抄题解的小朋友也没必要抄我的啦，太慢了属实是。

写这篇题解的主要想法是看到题解区并没有像我这样子的点分治做法，来补充一下。

---

## 作者：eastcloud (赞：4)

我们要求的是两点间同时存在 `D` 和 `d` 的**简单**路径个数，先枚举点对检查合法性，可以发现只要是没有割点封着的边我们都可以经过一遍，因此先对图缩点双。

接着考虑一些简化，我们称全部为一个点的点双为纯色点双，对于不在同一个点双的点对，如果简单路径上都是同样颜色的纯色点双就肯定不合法，否则肯定合法，这个部分可以点分治或者直接并查集。

接着就只剩在同一个点双的点对了，同样的，如果一个点双是纯色点双那么肯定不合法，那对于其他点双呢？一个猜想是全部满足条件，但是我们可以考虑一个简单环，环上一半边是蓝色一半是红色（假设 `D` 边为红色 `d` 边为蓝色），那交界处的那个点对一定不合法。

再找找规律可以发现，在混色点双里，貌似只有这样的点双不合法，其他的总有一种方法绕过蓝色和红色。我们尝试证明，以下称连出的边都是一种颜色的节点为纯色点，否则为混色点，此时不考虑割点连出去的边的颜色。

对于只有两个混色点的点双，我们分为都为纯色点的点对和有混色点的点对：

- 对于纯色点点对，红蓝纯色肯定合法，而相同颜色的纯色点对中，一个点就可以经过两个混色点，绕到另一个点上，其中前半段（到并经过两个混色点）一定存在，另一端如果不存在就说明有割点，图大概长这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/9j20qfqb.png)

- 对于有混色点的点对，可以发现我们只要从另一个混色点绕到它即可。

对于更多混色点的点双，我们只需要额外考虑两个混色点点对的情况，这时我们可以借助多的混色点进行颜色的转换。

时间复杂度 $O(n+m)$。

---

## 作者：lfxxx (赞：3)

好题。

首先看到简单路径（端点不交），考虑在圆方树上处理。

首先处理点对在一个点双内的贡献，假若点双内边颜色全部相同，那么显然不合法，否则就一定合法，吗？

很显然不是，如果 $u \to v$ 所有路径是同色的，点双形如一个杏仁那就不合法，怎么统计这样的 $u \to v$ 对呢？

实际上这样的 $u,v$ 至多一对，画出这样的杏仁后，容易发现其他点对之间的路径都能构造出至少一条同时经过了 $d,D$ 的。

那怎么确定到底是有一对还是没有呢？观察符合条件的杏仁，你发现有一对当且仅当存在恰好两个有不同颜色出边的点。

然后考虑统计跨过至少两个点双的点对的贡献，不难发现只需要路径上有一个非同色点双即可，因为出发或者结束的时候便可获得一种颜色，经过非同色点双时再把另一种颜色补上即可。

实际统计可以这么做，先把 $n \choose 2$ 算进答案，然后不合法的首先有形如同色点双构成的极大同色连通块，可以通过圆方树上 dp 求解贡献，再对每个非同色点双看看是否要减去一对 $u,v$ 的贡献即可。

判断一条边属于哪个点双可以对圆方树设置一个根然后对每个点求出父亲，就可以快速判断两个相邻圆点出边交。

时间复杂度 $O(n+m)$。


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn = 4e5+114;
const int maxm = 1e6+114;
struct star{
    char ty;
    int nxt,to;
}e[maxm<<1];
int head[maxn];
int tot=1;
void add(int u,int v,char ty){
    tot++;
    e[tot].nxt=head[u];
    e[tot].to=v;
    e[tot].ty=ty;
    head[u]=tot;
    tot++;
    e[tot].nxt=head[v];
    e[tot].to=u;
    e[tot].ty=ty;
    head[v]=tot;
}
int dfn[maxn],low[maxn],dfncnt;
int stk[maxn],tp;
int n,m;
vector<int> G[maxn+maxm];
int cnt;
void tarjan(int u){
    dfn[u]=low[u]=++dfncnt;
    stk[++tp]=u;
    for(int i=head[u];i;i=e[i].nxt){
        int v=e[i].to;
        if(dfn[v]==0){  
            tarjan(v);
            low[u]=min(low[u],low[v]);
            if(low[v]>=dfn[u]){
                cnt++;
                for(int x=0;x!=v;tp--){
                    x=stk[tp];
                    G[cnt].push_back(x);
                    G[x].push_back(cnt);
                }
                G[cnt].push_back(u);
                G[u].push_back(cnt);
            }
        }else low[u]=min(low[u],dfn[v]);
    }
}
int fa[maxn+maxm];
void dfs(int u){
    for(int v:G[u]){
        if(v!=fa[u]){
            fa[v]=u;
            dfs(v);
        }
    }
}
vector< pair<int,char> > P[maxn+maxm];
int ty[maxn+maxm];//0 - d 1 - D 2 - dD,same path 3 - dD diff path
int dp[maxn+maxm][2];//0 - d 1 - D
int ans;
void DP(int u){
    if(u<=n){
        dp[u][0]++;
        dp[u][1]++;
    }else{
        if(ty[u]==0) dp[u][1]=0;
        else if(ty[u]==1) dp[u][0]=0;
        else dp[u][0]=dp[u][1]=0;
    }
    for(int v:G[u]){
        if(v!=fa[u]){
            DP(v);
            if(u<=n){
                ans-=dp[u][0]*dp[v][0];
                ans-=dp[u][1]*dp[v][1];
                dp[u][0]+=dp[v][0];
                dp[u][1]+=dp[v][1];
            }else{
                if(ty[u]==0){
                    ans-=dp[u][0]*dp[v][0];
                    dp[u][0]+=dp[v][0];
                }else if(ty[u]==1){
                    ans-=dp[u][1]*dp[v][1];
                    dp[u][1]+=dp[v][1];
                }
            }
        }
    }  
}
int ct[maxn][2];
void init(){
    for(int u=1;u<=n;u++){
        for(int i=head[u];i;i=e[i].nxt){
            int v=e[i].to;
            if(v>u){
                int w;
                if(fa[u]==fa[v]){
                    w=fa[u];
                }else if(fa[fa[u]]==v){
                    w=fa[u];
                }else{
                    w=fa[v];
                }
                P[w].push_back(make_pair(u,e[i].ty));
                P[w].push_back(make_pair(v,e[i].ty));
            }
        }
    }
    for(int u=n+1;u<=cnt;u++){
        int cd=0,cD=0,cdD=0;
        for(pair<int,char> now:P[u]){
            if(now.second=='d') ct[now.first][0]++;
            else ct[now.first][1]++;
        }
        for(int v:G[u]){
            if(ct[v][0]*ct[v][1]>0) cdD++;
            else if(ct[v][0]>0) cd++;
            else cD++;
        }
        for(pair<int,char> now:P[u]){
            if(now.second=='d') ct[now.first][0]--;
            else ct[now.first][1]--;
        }
        if(cdD>2){
            ty[u]=3;
        }else if(cdD==2){
            ty[u]=2;
            ans--;
        }else if(cd>0){
            ty[u]=0;
        }else ty[u]=1;
    }
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    int id=0;
    cin>>id>>n>>m;
    cnt=n;
    for(int i=1;i<=m;i++){
        int u,v;
        char ty;
        cin>>u>>v>>ty;
        add(u,v,ty);
    }
    ans=n*(n-1)/2;
    tarjan(1);
    dfs(1);
    init();
    DP(1);
    cout<<ans<<'\n';
    return 0;
}
```

---

## 作者：Priestess_SLG (赞：1)

（标题有含义）

比较困难的题，考察了大量点双的性质

考虑对于一个点双连通分量，其具有下面的性质：

+ 无割点。
+ 任意两个点 $a,b$ 均可存在一条简单路径连通。
+ 递进于上一条，任意两个点 $a,b$ 都存在两条简单路径，使得这两条路径除了 $a,b$ 两个点以外其余点两两不相同。
+ 对于任意两个点 $a,b$ 都存在一个同时经过 $a,b$ 的简单环。
+ 递进于上一条，对于任意三个点 $a,b,c$ 满足 $b,c$ 有一条边相连，则必然存在一个同时经过 $a,b,c$ 的简单环。
+ 递进于上一条，对于任意四个点 $a,b,c,d$ 满足 $b,c$ 有一条边相连，则必然存在一条同时经过 $a,b,c,d$ 的简单路径。
+ 递进于上一条，对于任意三个点 $a,b,c$，存在一条经过 $a,b,c$ 的简单路径。
+ 一个有 $n$ 个结点的无向图中所有点双大小的和是 $O(n)$ 级别的。

知道上述所有性质之后可以开始搞这个题了。题目要计数合法的点对 $(i,j)$。一个点对 $(i,j)$ 合法的充要条件是 $i$ 到 $j$ 存在一条简单路径使得该路径上同时有 `D` 和 `d` 出现。

直接计算十分困难，考虑容斥答案，即求全部方案数（$1$）减去只出现 `D` 的方案数（$2$）减去只出现 `d` 的方案数（$3$）减去 $i=j$ 的方案数（$4$）。其中 $1,4$ 是容易计算的，$1$ 减去 $4$ 的答案为 $\frac{n(n-1)}2$。$2,3$ 两个情况的做法类似可以一起考虑。因此现在其实只需要计数情况 $2$ 的答案，这里将 $2,3$ 一起考虑。

观察到“简单路径”这一性质，即可以想到路径中不能经过重复的结点（当然也就不能经过重复的边），因此想到点双，即对图缩点双然后得到圆方树。

此时存在两类贡献，分别为点双内的贡献和点双外的贡献（这里计数的是负贡献）。对于每一个方点，其对应原图中的一个点双。考虑对这个点双内所有的边处理贡献，则点双可以被分为 D 型点双，d 型点双和 Dd 型点双。其中每一个字母即代表这个点双中存在一条边权为这个字母的边。则若 $i,j$ 不位于同一点双，则其不合法的条件为：其在圆方树上的结点路径中所有方点对应的电刷给你类型相同，且不存在 Dd 型点双。这个部分的计数容易，可以 dp 或者点分。

另一类贡献为点双内的贡献。很明显所有 D 型点双和 d 型点双内所有点对都不合法。有一个猜想是 Dd 型点双内因为路径可以任意经过边所以一定所有点对都是合法的无需计数，但是其实这是错误的。反例形如：

[![pEBrJMT.png](https://s21.ax1x.com/2025/03/24/pEBrJMT.png)](https://imgse.com/i/pEBrJMT)

其中对于 $(1,4)$ 点对，若 $1\leftrightarrow2,2\leftrightarrow3,3\leftrightarrow4$ 的边为 `D`，$1\leftrightarrow5,5\leftrightarrow6,6\leftrightarrow4$ 的边为 `d`，则该点双为 Dd 型点双，但 $1$ 到 $4$ 的路径不能同时经过 `D` 和 `d`。考虑什么时候会出现这样的情况。钦定当前 Dd 型点双中 $i,j$ 出现了该情况，则 $i,j$ 两个点必然同时连了边权为 D 和边权为 d 的边。此时若该点双内还有不同于 $i,j$ 的结点 $k$，$k$ 点也同时连的 `D` 和 `d` 型的边，则根据上面列出的性质可以得知此时为了使得不存在可以从 $i$ 出发走到 $j$ 然后同时经过 D 边权和 d 边权的路径且经过 $k$，必须使得 $i$ 从 D 出发的边只走 D 然后走到 $k$，再从 $k$ 的 D 型边出发走到 $j$，边权为 d 的边也同理。但是这样 $k$ 必然同时可以通过只走边权为 D / d 的边从 $i$ 到达 / 到达 $j$，于是交换路径可以得到：从 $i$ 出发只走边权为 D 的边到 $k$，然后从 $k$ 开始只走边权为 d 的边到 $j$，反之同理。因此该情况不存在。

于是得出结论：Dd 型点双存在上述情况当且仅当只存在两个点同时连了边权为 D 和 d 的边，设这两个点为 $i,j$ 则 $(i,j)$ 不是一个合法的点对，需要计数。很显然此时必然只存在一组合法的点对 $(i,j)$。因此本题搞定，只需 tarjan 处理点双然后建圆方树，对每一个方点求出其所代表的点双是 D 型 / d 型 / Dd 型，然后再跑 dp / 点分求出不同点双之间的点对对答案的贡献即可。时间复杂度为 $O(n)$（dp） / $O(n\log n)$（点分），均可通过。更简单的做法是使用并查集，时间复杂度为 $O(n\log n)$（路径压缩 / 按秩合并）或 $O(\alpha n)$（路径压缩 + 按秩合并）。

代码，调了好长好长时间。

```cpp
// #pragma GCC optimize(3,"Ofast","inline")
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#define int long long
using namespace std;
struct Triple{
    int first,second,third;
    Triple(){
        first=second=third=0;
    }
    Triple(int a,int b,int c){
        first=a,second=b,third=c;
    }
};
const int N=1000010;
vector<pair<int,int>>adj[N];
vector<int>adj2[N],scc[N],sccc[N],adj3[N];
vector<Triple>sedge[N];
int typ[N];
//1为D，2为d，3为Dd
struct Edge{
    int a,b;
    char o;
}edge[N];
stack<int>stk;
stack<Triple>stk2;
int ind,idx,tot,instk[N],dfn[N],low[N],ins[N],deg[N],inc[N],liuxu[N];
void dfs(int u){
    dfn[u]=low[u]=++idx;
    stk.emplace(u);
    if(!deg[u])scc[++tot].emplace_back(u);
    for(auto &[v,w]:adj[u]){
        if(dfn[v]){
            low[u]=min(low[u],dfn[v]);
            if(dfn[v]<dfn[u])stk2.emplace(u,v,w);
        }
        else{
            stk2.emplace(u,v,w);
            dfs(v);
            low[u]=min(low[u],low[v]);
            if(low[v]>=dfn[u]){
                ++tot;
                int t;
                do{
                    t=stk.top();
                    stk.pop();
                    scc[tot].emplace_back(t);
                }while(t!=v);
                scc[tot].emplace_back(u);
                Triple tmp;
                do{
                    assert(stk2.size());
                    tmp=stk2.top();
                    stk2.pop();
                    sedge[tot].emplace_back(tmp);
                }while(tmp.first!=u||tmp.second!=v);
            }
        }
    }
}
int subid,n,m;
class DSU{//Disjoint Set Union
    public:
    int fa[N],siz[N];
    inline void init(int n){
        iota(fa+1,fa+n+1,1);
        fill(siz+1,siz+n+1,1);
    }
    int girl(int x){
        return x==fa[x]?x:fa[x]=girl(fa[x]);
    }
    int get(int x){
        return siz[girl(x)];
    }
    void les(int a,int b){
        a=girl(a),b=girl(b);
        if(a!=b)fa[a]=b,siz[b]+=siz[a];
    }
}dsu;
int vis[N];
//计算所有满足i!=j且不合法的点对数(i,j)
int calc(){
    int res=0;
    //统计同一点双内的答案
    for(int i=1;i<=tot;++i){
        if(typ[i+n]!=3)res+=scc[i].size()*(scc[i].size()-1)/2;
        else if(inc[i+n]==2)res+=1;
    }
    //统计不同点双内的答案
    dsu.init(tot);
    for(int i=1;i<=tot;++i)dsu.siz[i]=(int)scc[i].size()-1;
    for(int i=1;i<=tot;++i){
        for(int &jj:adj3[i])
            if(typ[i+n]!=3&&typ[jj+n]!=3&&typ[i+n]==typ[jj+n])
                dsu.les(i,jj);
    }
    for(int i=1;i<=tot;++i)sccc[dsu.girl(i)].emplace_back(i);
    for(int i=1;i<=tot;++i)
        if(typ[i+n]!=3&&dsu.girl(i)==i)
            res+=dsu.get(i)*(dsu.get(i)+1)/2;
    for(int i=1;i<=tot;++i)
        if(typ[i+n]!=3)res-=(int)(scc[i].size()-1)*scc[i].size()/2;
    return res;
}
int yhb[N];
using ull=unsigned long long;
inline ull harsh(int i,int j){return i*0x0d000721+j+0x66ccff;}
namespace aimat {
    char *p1,*p2,buf[100010],obuf[100010],*p3=obuf;
    #define gc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++)
    #define pc(x) (p3==obuf+100000&&fwrite(p3=obuf,1,100000,stdout),*p3++=x)
    int read(){
        int x=0;
        char c=gc();
        while(c<48)c=gc();
        while(47<c)x=(x<<3)+(x<<1)+(c&15),c=gc();
        return x;
    }
    void write(int x){
        if(9<x)write(x/10);
        pc(x%10|48);
    }
} using namespace aimat;
signed main(){
    subid=read();
    n=read(),m=read();
    for(int i=0;i<m;++i){
        int a,b;char o;
        a=read(),b=read();
        o=gc();
        while(o!='d'&&o!='D')o=gc();
        int O=1;if(o=='d')O=2;
        adj[a].emplace_back(b,O);
        adj[b].emplace_back(a,O);
        ++deg[a],++deg[b];
        edge[i]={a,b,o};
    }
    for(int i=1;i<=n;++i)
        if(!dfn[i])dfs(i);
    ind=n;
    int all=0;
    for(int i=1;i<=tot;++i){
        ++ind;
        all+=sedge[i].size();
        for(int &j:scc[i])liuxu[j]=0;
        for(int &j:scc[i]){
            adj2[ind].emplace_back(j);
            adj2[j].emplace_back(ind);
        }
        for(auto &[j,k,v]:sedge[i]){
            assert(v);
            if(v&1){
                typ[ind]|=1;
                liuxu[j]|=1;
                liuxu[k]|=1;
            }
            if(v&2){
                typ[ind]|=2;
                liuxu[j]|=2;
                liuxu[k]|=2;
            }
        }
        for(int &j:scc[i])
        if(liuxu[j]==3)++inc[ind];
        assert(all<=m+m+m);
    }
    for(int i=1;i<=n;++i){
        // for(int x=0;x<adj2[i].size();++x)
        //     for(int y=x+1;y<adj2[i].size();++y){
        //         int id=adj2[i][x],id2=adj2[i][y];
        //         adj3[id-n].emplace_back(id2-n);
        //         adj3[id2-n].emplace_back(id-n);
        //     }
        int id1=-1,id2=-1;
        for(int j=0;j<adj2[i].size();++j){
            if(typ[adj2[i][j]]==1&&!~id1)id1=adj2[i][j];
            if(typ[adj2[i][j]]==2&&!~id2)id2=adj2[i][j];
        }
        for(int j=0;j<adj2[i].size();++j){
            int id3=adj2[i][j];
            if(~id1&&id1!=id3){
                adj3[id1-n].emplace_back(id3-n);
                adj3[id3-n].emplace_back(id1-n);
            }
            if(~id2&&id2!=id3){
                adj3[id2-n].emplace_back(id3-n);
                adj3[id3-n].emplace_back(id2-n);
            }
        }
    }
    cout<<n*(n-1)/2-calc()<<'\n';
    return 0;
}

/*

0
6 5
5 4 d
1 4 D
3 6 d
2 4 D
2 6 d

*/
```

[AC Record](https://www.luogu.com.cn/record/209995614)。

---


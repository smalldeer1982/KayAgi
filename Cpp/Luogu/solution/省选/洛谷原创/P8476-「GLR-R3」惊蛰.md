# 「GLR-R3」惊蛰

## 题目背景

&emsp;&emsp;「微雨众卉新，一雷惊蛰始」

---

&emsp;&emsp;中午，休息室，阿绫肩膀上。

&emsp;&emsp;“我有一个愿望，参加全国音乐祭，获奖，和阿绫一起，摆脱这训练的苦海。”

&emsp;&emsp;“为热爱而到来，为抽身而努力……吗”。

&emsp;&emsp;正午的阳光渗过窗帘，抚上困倦的人儿的脸颊。天依的左手悄悄搭上阿绫怀里的吉他，

&emsp;&emsp;“铮——”

&emsp;&emsp;蛰虫被雷声唤醒，没人向他们保证雨的降临。

---

&emsp;&emsp;**惊蛰**&emsp;「我愿把岁月磨成望镜寻遍这星空　将微光聚焦手心紧紧握住不放松」

## 题目描述

比赛临近，各式测试也丰富了起来，作为天依他们的专业分析师，你的工作是统计分析队员们表现情况——总之，某领导要来慰问，所以你被要求修改出一份令人赏心悦目的分析报告。

在已有的 $n$ 次测试中，对于某位特定的选手，他在第 $i$ 次测试的**波动值**是非负整数 $a_i$。波动值越小表示选手在测试中的心态和发挥越稳定，所以你需要“略微调整”波动值序列 $\{a_n\}$，得到另一个非负整数序列 $\{b_n\}$。不过，做人不能昧良心，但报告又必须好看，所以 $\{b_n\}$ 有如下要求：

- $\{b_n\}$ **单调不递增**，选手越来越厉害嘛；

- 对于每个 $i$，如果 $b_i<a_i$，老师会不高兴，所以你需要花费 $C$ 单位的精力说服老师（其中 $C$ 为给定常数）；
- 对于每个 $i$，如果 $a_i\le b_i$，选手会不高兴，而且可能很不高兴，所以你需要花费 $b_i-a_i$ 单位的精力安慰选手。

你希望在满足条件的情况下，**最小化**花费的精力之和。作为成熟的信竞选手，你自然需要自己动手，求出这一最小化的结果。

#### 形式化题意

给定非负整数序列 $\{a_n\}$，定义函数 $f(x,y)$ 为

$$
f(x,y)=\begin{cases}
x-y,&x\ge y\\
C,&x< y
\end{cases},
$$

其中 $C$ 是给定常数。请构造一个**不增**非负整数序列 $\{b_n\}$，最小化

$$
\sum_{i=1}^nf(b_i,a_i).
$$

你仅需输出这一最小化的结果。


## 说明/提示

#### 样例 #1 解释

构造 $\{b_n\}=\{5,5,2\}$，可见：

$$
\begin{aligned}
\sum_{i=1}^nf(b_i,a_i) &=  f(5,4)+f(5,5)+f(2,2)\\
&= 1+0+0\\
&= 1.
\end{aligned}
$$

#### 样例 #2 解释

构造 $\{b_n\}=\{12,11,4,2,1,1,1,1,1,1\}$，可以得到答案。

### 数据规模与约定

**本题采用 Subtask 的计分方式。**

设 $V$ 为序列 $\{a_n\}$ 中元素以及常数 $C$ 的值域。

对于 $100\%$ 的数据，$1\le n\le10^6$，$V\subseteq[0,10^9]$。

对于不同的子任务，作如下约定：

| 子任务编号 |   $n$   |       $V$       | 特殊性质 | 子任务分值 |
| :--------: | :-------: | :-------------: | :------: | :--------: |
|    $1$     | $\le10^3$ | $\subseteq[0,10^9]$ |    无    |    $25$    |
|    $2$     | $\le10^5$ | $\subseteq[0,10^2]$ |  无   |    $15$    |
|    $3$     | $\le10^6$ | $\subseteq[0,10^9]$ |  **A**   |    $5$    |
|    $4$     | $\le10^6$ | $\subseteq[0,10^9]$ |  **B**   |    $15$    |
|    $5$     | $\le10^5$ | $\subseteq[0,10^9]$ |  无   |    $20$    |
|    $6$     | $\le10^6$ |   $\subseteq[0,10^9]$   |    无    |    $20$    |

- **特殊性质 A**：对于常数 $C$ ，满足 $C = 0$。
- **特殊性质 B**：对于序列 $\{a_n\}$ ，满足元素单调**递增**。

## 样例 #1

### 输入

```
3 3
4 5 2```

### 输出

```
1```

## 样例 #2

### 输入

```
10 5
12 17 20 2 0 1 13 6 10 1```

### 输出

```
26```

# 题解

## 作者：Reanap (赞：20)

- **Subtask 2**

依次考虑序列的每一位去构造 $b$ 序列。

容易发现，当前这一位的抉择只会受上一位 $b$ 的大小影响，因此定义 $f_{i,x}$ 表示 $b_i = x$ 时当前 $b$ 序列带来的最小花费。

复杂度是 $O(nV^2)$ 的。

考虑优化，发现给 $f_i$ 滚一个后缀最小值就可以实现每个状态 $O(1)$ 转移。  

复杂度为 $O(nV)$ 的。

期望得分 15pts。

- **Subtask 1**

继承 Subtask 2 的做法，考虑进一步优化。

发现 $\forall b_i$ $\exist \ \ b_i = a_j$。

因为如果不满足，我们把该位 $b_i$ 变小，直到满足，那么答案一定变小。

这里我们可以修改定义为 $f_{i,j}$ ，表示考虑到第 $i$ 位，$b_i$ 是 $a$ 中第 $j$ 大的元素。

滚一个前缀最小值就可以将复杂度达到 $n^2$ 。

结合之前做法，期望 40pts。

- **Subtask 3**

由于 $\min{C , 0} \le f(x,y)$。

又因为 $C = 0$ ，将 $b_i$ 设为极小值，直接输出 $0$ 就好了。

结合之前算法，期望 45pts。

- **Subtask 4**

容易得到 $\forall b_i = b_1$ 。

结合 Subtask 2 的结论枚举 $b_1$ 的值计算即可。

结合之前算法，期望 60pts。

- **Subtask 5**

不会。

但可能可以用 $\log^2$ 做法或带根号做法维护凸包啥的，感受过但没想过，有写了的同学或者知道的同学可以教教我。

也留给常数升天的同学。

- **Subtask 6**

继承 **Subtask 1** 的做法 (~~子任务首尾呼应~~)

发现滚过前缀最小值后我们的转移是本位转移。

因此将我们滚过前缀最小值的 $f$ 数组拍到线段树上，维护区间最小值。

考虑第 $i$ 次转移带来的改变。设 $a_i$ 是第 $k$ 大的元素。

那么 $\forall j \in [k+1,n]$ ，$f_{i,j} = f_{i-1,j} + C$。

线段树直接区间修改就可以维护。

那么 $\forall j \in [1,k]$ ，$f_{i,j} = f_{i-1,j} + b_j - a_i$。

$-a_i$ 的部分线段树区间修改解决。

而 $+b_j$ 则是对一个数列加上另一个数列，不好维护。

分析性质，发现这两个数列都是单调不增的，所以原来最小值是区间右端点的值，加上单调不增的序列后最小值还是右端点的值。

接下来我们还要完成滚前缀最小值的操作。

但是注意到，此时我们的 $f$ 数组是两个单调不增序列首尾相连而成的。

因此，用前一个单调不增序列的最小值对后一个单调不增序列线段树上二分打标记区间推平就好了。

要注意在 `push_down` 标记之前要保证儿子的推平标记已经下传。

- **难点分析**

~~几乎没有难点。~~

难点在于把 dp 拍到线段树上维护的行为并不存在极强的动机。

另外，即使拍到线段树上，后续维护也并不那么显然。

所以选手如果缺乏对 dp 特性和这种思路的可行性的感知，那么很容易放弃对这种思路的继续探索。


- **命题想法**

把 `dp` 数组拍到线段树上维护的题目在模拟赛中并不罕见，但是在洛谷题库和公开赛中我并没有看见太多，因此想要把这个技巧普及一下，于是便有了这道题。

- **预测**

比赛开始后 1h 内应该有人能够切掉（只考虑顺序做题的情况）。

通过人数应该不少于 30 人。

应该没有选手会被卡常吧?

~~虽然有验题人被卡常了。~~

- **后续**

赛时还真有人写别的做法被卡常了啊。/hx

代码：

```cpp
#include <map>
#include <set>
#include <queue>
#include <cmath>
#include <bitset>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define pii pair <int , int>
#define mp make_pair
#define fs first
#define sc second
using namespace std;
typedef long long LL;
typedef unsigned long long ULL;

const int Mxdt=100000; 
static char buf[Mxdt],*p1=buf,*p2=buf;
#define getchar() p1==p2&&(p2=(p1=buf)+fread(buf,1,Mxdt,stdin),p1==p2)?EOF:*p1++;

template <typename T>
void read(T &x) {
	T f=1;x=0;char s=getchar();
	while(s<'0'||s>'9') {if(s=='-') f=-1;s=getchar();}
	while(s>='0'&&s<='9') {x=(x<<3)+(x<<1)+(s-'0');s=getchar();}
	x *= f;
}

template <typename T>
void write(T x , char s='\n') {
	if(!x) {putchar('0');putchar(s);return;}
	if(x<0) {putchar('-');x=-x;}
	T tmp[25]={},t=0;
	while(x) tmp[t++]=x%10,x/=10;
	while(t-->0) putchar(tmp[t]+'0');
	putchar(s); 
}

const int MAXN = 2e6 + 5;

int n , k , a[MAXN];
LL tr[MAXN << 2] , tag1[MAXN << 2] , tag2[MAXN << 2] , C;
int b[MAXN] , fl[MAXN << 2] , id[MAXN];

void push_fl(int now) {
	if(!fl[now]) return;
	tr[now << 1] = tr[now << 1 | 1] = tr[now];
	tag1[now << 1] = tag1[now << 1 | 1] = 0;
	tag2[now << 1] = tag2[now << 1 | 1] = 0;
	fl[now << 1] = fl[now << 1 | 1] = 1;
	fl[now] = 0;
}

void push_down(int mid , int r , int now) {
	push_fl(now);
	push_fl(now << 1) , push_fl(now << 1 | 1);
	if(tag1[now]) {
		tr[now << 1] += tag1[now];tag1[now << 1] += tag1[now];
		tr[now << 1 | 1] += tag1[now];tag1[now << 1 | 1] += tag1[now];
		tag1[now] = 0;
	}
	if(tag2[now]) {
		tr[now << 1] += b[mid] * tag2[now];tag2[now << 1] += tag2[now];
		tr[now << 1 | 1] += b[r] * tag2[now];tag2[now << 1 | 1] += tag2[now];
		tag2[now] = 0; 
	}
}

void push_up(int now) {tr[now] = min(tr[now << 1] , tr[now << 1 | 1]);}

LL Val;
void update(int l , int r , int now , int x , LL v1 , LL v2) {
	int mid = (l + r) >> 1;
	if(l != r) push_down(mid , r , now);
	if(r <= x) {
		push_fl(now);
		tr[now] += v1 , tag1[now] += v1;
		tr[now] += b[r] , tag2[now] ++;
		if(r == x) Val = tr[now];
		return;
	}
	if(l > x) {
		push_fl(now);
		tr[now] += v2 , tag1[now] += v2;
		return;
	}
	update(l , mid , now << 1 , x , v1 , v2);
	update(mid + 1 , r , now << 1 | 1 , x , v1 , v2);
	push_up(now);
}

bool modify(int l , int r , int now , int x , LL V) {
	int mid = (l + r) >> 1;
	if(l != r) push_down(mid , r , now);
	if(l > x) {
		if(tr[now] > V) {
			tr[now] = V , tag1[now] = tag2[now] = 0;
			fl[now] = 1;
			return 1; 
		}
		if(l != r) {
			if(modify(l , mid , now << 1 , x , V)) modify(mid + 1 , r , now << 1 | 1 , x , V);
		}
		return 0;
	}
	if(l == r) return 0;
	if(x < mid) {
		if(modify(l , mid , now << 1 , x , V)) return modify(mid + 1 , r , now << 1 | 1 , x , V);
		return 0;
	}
	return modify(mid + 1 , r , now << 1 | 1 , x , V);
} 

int main() {
	read(n),read(C);
	for (int i = 1; i <= n; ++i) read(a[i]) , b[i] = a[i];
	sort(b + 1 , b + 1 + n);
	int m = unique(b + 1 , b + 1 + n) - b - 1;
	for (int i = 1; i <= n; ++i) id[i] = lower_bound(b + 1 , b + 1 + m , a[i]) - b , id[i] = m - id[i] + 1;
	reverse(b + 1 , b + 1 + m);
	
	for (int i = 1; i <= n; ++i) {
		update(1 , m , 1 , id[i] , -a[i] , C);
		modify(1 , m , 1 , id[i] , Val); 
	}
	write(tr[1]);
	
	return 0;
}
```

---

## 作者：Alex_Wei (赞：15)

> C. [P8476「GLR-R3」惊蛰 ](https://www.luogu.com.cn/problem/P8476)

考虑 DP，设 $g_{i, j}$ 表示使得 $b_i = j$ 的最小代价，则 $g_{i, j} = \min\limits_{k \geq j} g_{i - 1, k} + f(j, a_i)$。直接做时间复杂度 $\mathcal{O}(nV)$，不可接受。

考虑转移的本质，对 $g_{i - 1}$ 做一遍后缀 $\min$，然后令 $g_{i, j} \gets g_{i - 1, j} + f(j, a_i)$。$f$ 和后缀 $\min$ 的优秀性质使得可以快速维护 $g$。具体地，对 $g_{i - 1}$ 做后缀 $\min$ 之后 $g_{i - 1}$ 具有单调性 $g_{i - 1, j}\leq g_{i - 1, j + 1}$，而 $f(j, a_i)$ 是关于 $j$ 的分段函数，当 $j < a_i$ 时相当于为 $g_{i - 1, j}$ 区间加 $C$，当 $j \geq a_i$ 时相当于为 $g_{i - 1, j}$ 加上 $j - a_i$，两部分分别具有单调性，所以操作结束后 $g_{i, j}$ 以 $a_i$ 为分割线变成两段关于 $j$ 具有单调性的序列。

根据上述分析，对 $g_{i - 1}$ 做后缀 $\min$ 时，只需线段树二分出 $< a_{i - 1}$ 的位置中最后一个使得 $g_{i, j} > g_{i, a_{i - 1}}$ 的位置 $j$，则该操作可视为对 $g_{i - 1, j}\sim g_{i - 1, a_{i - 1} - 1}$ 区间赋值 $g_{i - 1, a_i - 1}$。

将 $a$ 离散化，设 $g_{i, j}$ 表示使得 $b_i = a_j$ 的最小代价，则需要支持以下操作：

- 区间给位置 $i$ 加上 $a_i$。
- 区间加法。
- 区间赋值。
- 线段树二分 $< p$ 的位置最后一个 $> v$ 的位置 $q$，保证 $< p$ 的位置具有单调性。

维护区间最大值和赋值，加法，加 $a_i$ 懒标记即可。时间复杂度 $\mathcal{O}(n\log n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using pii = pair<int, int>;
#define TIME 1e3 * clock() / CLOCKS_PER_SEC
bool Mbe;
constexpr int N = 1e6 + 5;
ll val[N << 2], b[N];
struct tag {
  ll ass, add, badd;
  tag operator + (const tag &x) const {
    if(x.ass != -1) return x;
    tag z = *this;
    z.add += x.add, z.badd += x.badd;
    return z;
  }
} laz[N << 2];
void eff(int l, ll x, tag v) {
  if(v.ass != -1) val[x] = v.ass;
  val[x] += v.add + b[l] * v.badd;
  laz[x] = laz[x] + v;
}
void down(int l, int r, int x) {
  int m = l + r >> 1;
  eff(m, x << 1, laz[x]);
  eff(r, x << 1 | 1, laz[x]);
  laz[x] = {-1, 0, 0};
}
void modify(int l, int r, int ql, int qr, int x, tag v) {
  if(ql > qr) return;
  if(ql <= l && r <= qr) return eff(r, x, v);
  int m = l + r >> 1;
  down(l, r, x);
  if(ql <= m) modify(l, m, ql, qr, x << 1, v);
  if(m < qr) modify(m + 1, r, ql, qr, x << 1 | 1, v);
  val[x] = max(val[x << 1], val[x << 1 | 1]);
}
int binary(int l, int r, int p, int x, ll lim) { // find the first position that val[x] >= lim
  if(r <= p && val[x] < lim) return -1;
  if(l == r) return l;
  int m = l + r >> 1;
  down(l, r, x);
  int res = binary(l, m, p, x << 1, lim);
  if(res != -1) return res;
  res = m < p ? binary(m + 1, r, p, x << 1 | 1, lim) : -1;
  return res;
}
ll query(int l, int r, int p, int x) {
  if(l == r) return val[x];
  int m = l + r >> 1;
  down(l, r, x);
  if(p <= m) return query(l, m, p, x << 1);
  return query(m + 1, r, p, x << 1 | 1);
}
int n, C, a[N];
bool Med;
int main() {
  fprintf(stderr, "%.3lf MB\n", (&Mbe - &Med) / 1048576.0);
  #ifdef ALEX_WEI
    freopen("1.in", "r", stdin);
    freopen("1.out", "w", stdout);
  #endif
  ios::sync_with_stdio(0);
  cin >> n >> C;
  for(int i = 1; i <= n; i++) cin >> a[i], b[i] = a[i];
  sort(b + 1, b + n + 1);
  for(int i = 1; i <= n << 2; i++) laz[i].ass = -1;
  for(int i = 1; i <= n; i++) {
    int p = lower_bound(b + 1, b + n + 1, a[i]) - b;
    modify(1, n, p + 1, n, 1, (tag) {-1, -a[i], 1});
    if(p == 1) continue;
    modify(1, n, 1, p - 1, 1, (tag) {-1, C, 0});
    ll v = query(1, n, p, 1);
    int pos = binary(1, n, p - 1, 1, v);
    if(pos != -1) modify(1, n, pos, p - 1, 1, (tag) {v, 0, 0});
  }
  cout << query(1, n, 1, 1) << "\n";
  cerr << TIME << " ms\n";
  return 0;
}
/*
2022/8/14
Author: Alex_Wei
start coding at 15:55
finish debugging at 16:40
*/
```

---

## 作者：Vsinger_洛天依 (赞：11)

- 前言

把 DP 拍到线段树上的神题，之前没见过~~可能是我见少识不广~~。

- 题意


给定非负整数序列 $\{a_n\}$，定义函数 $f(x,y)$ 为
$f(x,y)=\begin{cases}x-y&x\ge y\\C&x< y\end{cases}$

构造一个单调不递增的非负整数序列 $\{b_n\}$，最小化        		$\sum_{i=1}^nf(b_i,a_i)$。

- 思路

一看数据范围 $1\le n\le10^6$，这题 $O(n^2)$ 肯定过不了，而且能看出来是 DP。

把 $f_{ij}$ 的值从 $f_{i-1,j}$ 转移，转移方程为

$$f_{i,j}=\begin{cases}f_{i-1,j}+b_j+a_i&0<j≤k\\f_{i-1,j}+C&k<j≤n\end{cases}$$

然后发现复杂度明显不行，考虑拍到线段树上维护。

具体实现看代码。
- 代码

```cpp
#include <bits/stdc++.h>
#include <bits/stdc++.h>
#define mid (l+r)/2 
using namespace std;
long long N,C,mina;
long long a[0x66ccff], b[0x66ccff],num[0x66ccff],f[0x66ccff];
struct ST{
    long long u,tot,add;; 
}t[0x66ccff];//这题要开8倍空间，因为lazy标记还要往下推一层
inline void lazy(long long p){
    f[p*2]=f[p],
	f[p*2+1]=f[p],
    t[p*2].u=0,
	t[p*2+1].u=0,
    t[p*2].tot=0,
	t[p*2+1].tot=0,
    t[p*2].add=1,//把标记推平到下一层
	t[p*2+1].add=1,
    t[p].add=0;
}
inline void add(long long l, long long r, long long p){
    if(t[p].add==1)
        lazy(p);//先推平p的lazy标记
	if(t[p*2].add==1)
        lazy(p*2);//推平p的左儿子
	if(t[p*2+1].add==1)
        lazy(p*2+1);//右儿子
    if(t[p].tot!=0)
        f[p*2]+=t[p].tot,
        t[p*2].tot+=t[p].tot,
        f[p*2+1]+=t[p].tot,
        t[p*2+1].tot+=t[p].tot,
        t[p].tot=0;
    if(t[p].u!=0)
        f[p*2]+=b[mid]*t[p].u,
        t[p*2].u+=t[p].u,
        f[p*2+1]+=b[r]*t[p].u,
        t[p*2+1].u+=t[p].u,
        t[p].u=0;
}

inline void f1(long long l,long long r,long long p,long long x,long long val,long long v){
    if(l!=r)//不是叶子节点
        add(l,r,p); 
    if(r<=x){
        if(t[p].add==1)
            lazy(p);
        f[p]+=val+b[r];
        t[p].tot+=val;
        ++t[p].u;
        if(r==x) 
            mina=f[p];//mina为后面的val
    }
    else if(l>x){
        if(t[p].add==1)
            lazy(p);
        f[p]+=v,
        t[p].tot+=v;
    }
    else if(l<=x)
        f1(l,mid,p*2,x,val,v),
        f1(mid+1,r,p*2+1,x,val,v),
        f[p]=min(f[p*2],f[p*2+1]);//线段树存区间最小值
}

inline long long f2(long long l,long long r,long long p,long long x,long long val){
    if(l!=r)
        add(l,r,p);
    if(l>x){
        if(f[p]>val){
        	f[p]=val,
            t[p].tot=0,
            t[p].u=0,
            t[p].add=1;
			return 1;
		}
        if(l!=r&&f2(l,mid,p*2,x,val)) 
			f2(mid+1,r,p*2+1,x,val);
        return 0;
    }
    if(l==r)//叶子节点直接返回
        return 0;
    if(x<mid){
        if(f2(l,mid,p*2,x,val)==0) 
            return 0;		
    }
    return f2(mid+1,r,p*2+1,x,val);
}
int main(){
    cin>>N>>C;
    for(long long i=1;i<=N;++i)
        cin>>a[i],
		b[i]=a[i];//构造b序列

    sort(b+1,b+N+1);//b单调递增
    long long ans=unique(b+1,b+N+1)-(b+1);//unique为去重函数
    for(long long i=1;i<=N;++i) 
        num[i]=ans+1-(lower_bound(b+1,b+ans+1,a[i])-b);//lower_bound：找到序列内第一个比a[i]小的数的下标，仅适用于有序序列
        //这里的(lower_bound(b+1,b+ans+1,a[i])-b)求的是序列内这个数在b中的下标

    reverse(b+1,b+ans+1);//翻转b[1]到b[ans+1],反转后为单调不递增

    for(long long i=1;i<=N;++i)
        f1(1,ans,1,num[i],-1*a[i],C),//这里顺序不能变
        f2(1,ans,1,num[i],mina);

    cout<<f[1];
    //f[1]为所求
}

---

## 作者：LuoTianyi_Official (赞：10)

在公开赛第一次见到这道题的时候我还是个刚学 OI 的萌新，现在不知不觉马上就要退役了，回想起学 OI 的三年也没有什么成绩，写篇题解纪念一下我还未开始便已结束的 OI 生涯。

根据题意，发现对后面的状态构成限制的只有当前确定的最后一个数，容易想到设 $dp_{i,j}$ 为使前 $i$ 个数不降且最后一个数为 $j$ 时花费的最小代价，依题意转移可以得到一个 $O(nV)$ 的 dp。

不难发现，每个数如果要往下修改，改成和上一个数相同一定不劣（因为再往下对后面的限制更多，但没有任何好处），而如果要往上修改，改成和后面某个数相同一定不劣（因为越往上代价越大，而如果改成了后面两个数之间的一个数，显然不会比往下调整到后面出现过的第一个数优），所以我们可以进行离散化做到 $O(n^2)$，拿到 40pts。

另外一个维度似乎没有什么好优化的了，考虑一次在 $O(\log n)$ 的时间内转移一行。观察状态转移方程，可以发现 $dp$ 数组的第 $i$ 行相对于 $i-1$ 行相当于依次进行了三步修改：

* 把每个元素变为以它为起点的后缀的最小值。
* 把 $j<a_i$ 的元素全部加上 $C$。
* 把 $j\ge a_i$ 的元素各自加上自己的代价，也就是 $j-a_i$，当然离散化了之后就是 $b_j-b_{a_i}$。这个可以等效为一次给下标为 $j$ 的元素加上 $b_j$ 和一次次区间减 $b_{a_i}$，前者打一个跟区间加类似的标记就行了。

可以发现后两个操作都是容易用线段树维护的，但是第一个操作似乎不太好维护。~~然后就在这里卡了很久。~~

观察到操作前原序列也是由这三步操作得来的，第一步会把数组变成单调不降的，而后两个操作也会保持数组分别在 $[1,a_i)$ 和 $[a_i,n]$ 中保持单调不降，这时原序列成为了由两个单调不降序列拼接起来的序列，如图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/ddh6d507.png)

现在考虑对原序列进行取后缀最小值操作，可以发现得到的序列是：

![](https://cdn.luogu.com.cn/upload/image_hosting/x93nfv88.png)

相当于只是对一个区间进行了区间赋值，赋值区间的起点是（从右往左）第一个后缀最小值比 $[a_i,n]$ 小的位置，终点是 $a_i-1$。需要在线段树上维护一个最小值，做第三个操作时由于操作区间内原序列不降 $b_i$ 也不降所以最小值肯定在操作区间最左端取到，修改最小值时加上 $b_l$ 即可。找区间的起点就在线段树上二分，可以在 $O(\log n)$ 的时间内完成，总复杂度 $O(n\log n)$，可以通过。

代码有点难写。另外有点卡常，要加个 `inline` 才能过。

```
#include <iostream>
#include <algorithm>
#define int long long
using namespace std;
int a[5000005], b[5000005], t[5000005], t2[5000005], ass[5000005], minn[5000005];
inline void pushdown(int l, int r, int n) {
if (l == r) {if (ass[n] != -1) minn[n] = ass[n]; minn[n] += t[n] + t2[n] * b[l]; return;}
int mid = (l + r) >> 1;
if (ass[n] != -1) {minn[n<<1] = ass[n<<1] = minn[n<<1|1] = ass[n<<1|1] = ass[n]; t[n<<1] = t[n<<1|1] = t2[n<<1] = t2[n<<1|1] = 0; ass[n] = -1;}
t[n<<1] += t[n]; t[n<<1|1] += t[n];
t2[n<<1] += t2[n]; t2[n<<1|1] += t2[n];
minn[n<<1] += t[n] + t2[n] * b[l]; minn[n<<1|1] += t[n] + t2[n] * b[mid+1];
t[n] = 0; t2[n] = 0;
}
void addd(int l, int r, int n, int x, int y, int v) {
pushdown(l, r, n);
if (l == x && r == y) {t[n] += v; minn[n] += v; return;}
int mid = (l + r) >> 1;
if (y <= mid) {addd(l, mid, n<<1, x, y, v); minn[n] = min(minn[n<<1], minn[n<<1|1]); return;}
if (x > mid) {addd(mid+1, r, n<<1|1, x, y, v); minn[n] = min(minn[n<<1], minn[n<<1|1]); return;}
addd(l, mid, n<<1, x, mid, v); addd(mid+1, r, n<<1|1, mid+1, y, v); minn[n] = min(minn[n<<1], minn[n<<1|1]);
}
void addd2(int l, int r, int n, int x, int y, int v) {
pushdown(l, r, n);
if (l == x && r == y) {t2[n] += v; minn[n] += b[l] * v; return;}
int mid = (l + r) >> 1;
if (y <= mid) {addd2(l, mid, n<<1, x, y, v); minn[n] = min(minn[n<<1], minn[n<<1|1]); return;}
if (x > mid) {addd2(mid+1, r, n<<1|1, x, y, v); minn[n] = min(minn[n<<1], minn[n<<1|1]); return;}
addd2(l, mid, n<<1, x, mid, v); addd2(mid+1, r, n<<1|1, mid+1, y, v); minn[n] = min(minn[n<<1], minn[n<<1|1]);
}
void assign(int l, int r, int n, int x, int y, int v) {
pushdown(l, r, n);
if (l == x && r == y) {ass[n] = v; minn[n] = v; t[n] = 0; t2[n] = 0; return;}
int mid = (l + r) >> 1;
if (y <= mid) {assign(l, mid, n<<1, x, y, v); return; minn[n] = min(minn[n<<1], minn[n<<1|1]);}
if (x > mid) {assign(mid+1, r, n<<1|1, x, y, v); return; minn[n] = min(minn[n<<1], minn[n<<1|1]);}
assign(l, mid, n<<1, x, mid, v); assign(mid+1, r, n<<1|1, mid+1, y, v); minn[n] = min(minn[n<<1], minn[n<<1|1]);
}
int query(int l, int r, int n, int x, int y) {
pushdown(l, r, n); if (l == x && r == y) return minn[n];
int mid = (l + r) >> 1;
if (y <= mid) return query(l, mid, n<<1, x, y);
if (x > mid) return query(mid+1, r, n<<1|1, x, y);
return min(query(l, mid, n<<1, x, mid), query(mid+1, r, n<<1|1, mid+1, y));
}
int query2(int l, int r, int n, int v, int minn) {
pushdown(l, r, n); 
if (l == r) return l;
int mid = (l + r) >> 1; int qwq = min(minn, query(l, r, n, mid+1, r));
if (qwq >= v) return query2(l, mid, n<<1, v, qwq);
return query2(mid+1, r, n<<1|1, v, minn);
}
signed main() {ios::sync_with_stdio(0); cin.tie(0);
int n, C; cin >> n >> C; for (int i=1; i<=n; i++) cin >> a[i], b[i] = a[i]; sort(b+1, b+1+n); for (int i=1; i<=n; i++) a[i] = lower_bound(b+1, b+1+n, a[i]) - b;
for (int i=1; i<=n; i++) {
if (a[i]-1) addd(1, n, 1, 1, a[i]-1, C);
addd2(1, n, 1, a[i], n, 1); addd(1, n, 1, a[i], n, -b[a[i]]);
int qaq = query(1, n, 1, a[i], n); int rzh = query2(1, n, 1, qaq, 0x3fffffffffffffffll); rzh += a[rzh] < qaq;
if (rzh <= a[i]-1) assign(1, n, 1, rzh, a[i]-1, qaq);
} cout << query(1, n, 1, 1, n) << endl;}
```

---

## 作者：WrongAnswer_90 (赞：4)

[P8476 「GLR-R3」惊蛰](https://www.luogu.com.cn/problem/P8476)

[更好的阅读体验](https://www.cnblogs.com/WrongAnswer90-home/p/17793889.html)

好厉害的题。去年打比赛拿了 60 暴力，今年考古补了。

首先有结论 $\forall i\in[1,n],\exists b_i=a_j$，可以类似归纳法的方式证明。

>证明：对于 $i=1$，若 $b_1\geq a_1$，则令 $b_1$ 为最大的 $a_j$ 最优。
>若 $b_1<a_1$，则令 $b_1$ 为小于 $a_1$ 的最大的 $a_j$ 最优。因为 $b_1$ 已经取到了它能取到的有意义的最大值，$b_1$ 再变大也不会令之后的决策集合扩大。
>
>对于 $i\not=1$，若 $b_{i-1}$ 满足上述结论，则当 $b_i\geq a_i$ 时令 $b_i=b_{i-1}$ 最优。
>若 $b_i<a_i$，仍然令 $b_i$ 为小于 $a_1$ 的最大的 $a_j$ 最优，证明方式同上。

有了这个结论，我们可以将其离散化，记 $val_v$ 是 $v$ 离散化前的值，这样 $f_{i,j}$ 表示第 $i$ 个位置的值为 $num_j$ 时的最小代价，转移方程是：

$$
f_{i,j}=\min_{k=j}^{V}f_{i-1,k}+

\begin{cases}

val_j-val_{a_i}\quad\quad j\geq a_i\\

C\quad\quad\quad\quad\quad\quad \;j<a_i

\end{cases}
$$

暴力转移是 $\mathcal O(n^3)$，发现转移区间是一个后缀，直接设 $f_{i,j}$ 为后缀 $\min$，把 $i$ 滚掉，方程变为：

$$
f_{j}=f_{j}+

\begin{cases}

val_j-val_{a_i}\quad\quad j\geq a_i\\

C\quad\quad\quad\quad\quad\quad \;j<a_i

\end{cases}
$$

做完这个后在扫一遍更新后缀 $\min$，可以做到 $\mathcal O(n^2)$。

继续观察转移方程，对于 $j<a_i$ 的情况是平凡的，就是一个区间加，对于 $j\geq a_i$，可以把 $-val_{a_i}$ 拆出来，也是一个区间加（减），考虑 $val_j$ 如何处理。~~难道是 KTT~~

$val$ 和 $f$ 都有一个重要的性质：非严格单增。一个区间的 $f$ 的最左端的位置一定是最小值，这样对于一个区间加了一个 $val$ 之后，最小值仍然是最左端的位置。

对于最后后缀 $\min$ 的更新，$f$ 数组下标 $<a_i$ 的部分单增，后半部分也是单增，所以可以在左半部分找出一个分界点，分界点左边的值不需要更新，右边的部分直接区间推平即可。

最优发现这些操作线段树大部分都是好做的。对于第二个操作，发现标记是满足结合律的，并且打了标记之后可以快速知道这个区间的答案，所以这个线段树也可以维护。

复杂度 $\mathcal O(n\log n)$。

```cpp
	int n,C,len,ans=INF,numa[1000001],a[1000001];
	namespace Segment
	{
		struct{int l,r,minn,tag1,tag2,tag3;}t[10000001];
		inline void update(int p){t[p].minn=min(t[p*2].minn,t[p*2+1].minn);}
		inline void down1(int p,int v){t[p].minn=v,t[p].tag2=t[p].tag3=0,t[p].tag1=v;}
		inline void down2(int p,int v){t[p].minn+=v,t[p].tag2+=v;}
		inline void down3(int p,int v){t[p].minn+=v*numa[t[p].l],t[p].tag3+=v;}
		inline void spread(int p)
		{
			if(t[p].tag1!=-1)down1(p*2,t[p].tag1),down1(p*2+1,t[p].tag1),t[p].tag1=-1;
			if(t[p].tag2)down2(p*2,t[p].tag2),down2(p*2+1,t[p].tag2),t[p].tag2=0;
			if(t[p].tag3)down3(p*2,t[p].tag3),down3(p*2+1,t[p].tag3),t[p].tag3=0;
		}
		void build(int p,int l,int r)
		{
			t[p].l=l,t[p].r=r,t[p].tag1=-1;
			if(l==r)return;
			int mid=l+((r-l)>>1);
			build(p*2,l,mid),build(p*2+1,mid+1,r),update(p);
		}
		int ask(int p,int x)
		{
			if(t[p].l==t[p].r)return t[p].minn;
			return spread(p),x<=t[p*2].r?ask(p*2,x):ask(p*2+1,x);
		}
		void change(int p,int l,int r,int k)
		{
			if(l<=t[p].l&&r>=t[p].r)return down1(p,k);
			spread(p);
			if(l<=t[p*2].r)change(p*2,l,r,k);
			if(r>t[p*2].r)change(p*2+1,l,r,k);
			update(p);
		}
		void modify(int p,int l,int r,int k)
		{
			if(l<=t[p].l&&r>=t[p].r)return t[p].minn+=k,t[p].tag2+=k,void();
			spread(p);
			if(l<=t[p*2].r)modify(p*2,l,r,k);
			if(r>t[p*2].r)modify(p*2+1,l,r,k);
			update(p);
		}
		void add(int p,int l,int r)
		{
			if(l<=t[p].l&&r>=t[p].r)return down3(p,1);
			spread(p);
			if(l<=t[p*2].r)add(p*2,l,r);
			if(r>t[p*2].r)add(p*2+1,l,r);
			update(p);
		}
		int L;
		void check(int p,int val)
		{
			if(t[p].l==t[p].r)
			{
				if(t[p].minn>=val)L=min(L,t[p].l);
				return;
			}
			spread(p);
			if(t[p*2+1].minn>val)L=min(L,t[p*2+1].l),check(p*2,val);
			else check(p*2+1,val);
		}
		void solve(int p,int k,int val)
		{
			if(t[p].l==t[p].r)
			{
				if(t[p].minn>val)L=min(L,t[p].l);
				return;
			}
			spread(p);
			if(k>t[p*2].r)
			{
				if(t[p*2+1].minn>val)check(p*2,val);
				solve(p*2+1,k,val);
			}
			else
			solve(p*2,k,val);
		}
		void print(int p)
		{
			if(t[p].l==t[p].r)return write(t[p].minn);
			spread(p),print(p*2),print(p*2+1);
		}
	}
	using namespace Segment;
	inline void mian()
	{
		read(n,C);int x;
		for(int i=1;i<=n;++i)read(a[i]),numa[i]=a[i];
		sort(numa+1,numa+1+n),len=unique(numa+1,numa+1+n)-numa-1,build(1,1,len);
		for(int i=1;i<=n;++i)
		{
			a[i]=lower_bound(numa+1,numa+1+len,a[i])-numa;
			if(a[i]-1)
			{
				x=ask(1,a[i]),L=inf;
				solve(1,a[i]-1,x-C);
				modify(1,1,a[i]-1,C);
				L!=inf?change(1,L,a[i]-1,x):void();
			}
			modify(1,a[i],n,-numa[a[i]]),add(1,a[i],n);
		}
		write(t[1].minn);
	}
```

---

## 作者：EnofTaiPeople (赞：4)

这道题的 $O(n^2)$ 算法好想，因为可以设 $f_{i,k}$ 表示 $k\le b_i$ 时 $\sum\limits_{1\le j\le i}f(a_j,b_j)$ 的最小值，如果 $b_i\ne k$，这样的 $k$ 显然无意义，离散化后就可以 $O(n^2)$ 的动态规划了，最后的 $f_{n,1}$ 就是答案，~~显然过不了~~。

考虑优化它，不难发现一些性质：

1. 一定有 $f_{i,k}\le f_{i.k+1}$，~~废话~~；
2. 设 $g_{i,k}$ 表示 $k=b_i$ 时 $\sum\limits_{1\le j\le i}f(a_j,b_j)$ 的最小值，故有 $g_{i,k}=f_{i-1,k}+f(k,b_i),f_{i,k}=\min\limits_{p>k}\{f_{i,p},g_{i,k}\}$；
3. $\forall k\ge b_i,p>k,f(b_i,k)<f(b_i,p)\Rightarrow f_{i,k}=g_{i,k}$；
4. $\forall k<b_i,k<p<b_i,f(b_i,k)=f(b_i,p)\Rightarrow f_{i,k}=\min\{g_{i,k},f_{i,b_i}\}$。

好了，为了不让设状态变成 $O(n^2)$，我们用 $f_k$ 表示当前的 $f_{i,k}$，我们先将 $f_k$ 修改成 $g_k$,用线段树区间加即可，注意，这里对于 $k\ge b_i$ 有 区间加自身权值（$k$）的操作，所以这样的的线段树只支持单点查询。

修改后，考虑需要将 $k<b_i$ 的数对 $f_{b_i}$ 取最小值，因为无法打最小值标记（前后都可能有区间加权值操作），所以同样是无法直接修改的，发现 $\forall k<b_i,g_{k-1}\le g_k$，于是只有一个区间需要进行区间赋值，直接二分可以得到一个 $O(n\log_2^2n)$ 的~~优秀~~超时算法。

线段树上二分就可以了，这里使用全局平衡二叉树代替线段树，既减少码量，又方便二分。

时间 $O(n\log_2n)$，空间 $O(n)$，不用开线段树的四倍空间，空间不到 40MB。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;
using ll=long long;
#define IV static inline void
namespace fast_io{
    char buf[N+5],*p1,*p2,c;
    #define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,N,stdin),p1==p2)?EOF:*p1++)
    inline int read(){
        int an=0,f=1;while(!isdigit(c=gc))if(c=='-')f=-f;
        do an=an*10+(48^c);while(isdigit(c=gc));return an*f;
    }
};using fast_io::read;
ll ad1[N],ad2[N],my[N],mk[N];
int n,C,a[N],mp[N],mt;
IV Ad1(int l,int r,ll d){ad1[l+r>>1]+=d;}
IV Ad2(int l,int r,ll d){ad2[l+r>>1]+=d;}
IV Mk(int l,int r,ll d){mk[l+r>>1]=d;}
IV pd(int l,int r);
IV pmk(int l,int r);
IV pd(int l,int r){
	int x=l+r>>1;
	if(~mk[x]){
		my[x]=mk[x];
		if(l<x)Mk(l,x-1,mk[x]);
		if(x<r)Mk(x+1,r,mk[x]);
	}else if(ad1[x]||ad2[x]){
		my[x]+=ad1[x]+ad2[x]*mp[x];
		if(l<x)pmk(l,x-1),Ad1(l,x-1,ad1[x]),Ad2(l,x-1,ad2[x]);
		if(x<r)pmk(x+1,r),Ad1(x+1,r,ad1[x]),Ad2(x+1,r,ad2[x]);
	}mk[x]=-1,ad1[x]=ad2[x]=0;
}
IV pmk(int l,int r){
	if(~mk[l+r>>1])pd(l,r);
}
void Add(int L,int R,ll d1,ll d2=1,int l=1,int r=mt){
	pd(l,r);if(l>=L&&r<=R){Ad1(l,r,d1),Ad2(l,r,d2);return;}
	int x=l+r>>1;if(x>=L&&x<=R)my[x]+=d1+d2*mp[x];
	if(l<x&&L<x)Add(L,R,d1,d2,l,x-1);
	if(x<r&&x<R)Add(L,R,d1,d2,x+1,r);
}
void Mak(int L,int R,ll d,int l=1,int r=mt){
	pd(l,r);if(l>=L&&r<=R){Mk(l,r,d);return;}
	int x=l+r>>1;if(x>=L&&x<=R)my[x]=d;
	if(l<x&&L<x)Mak(L,R,d,l,x-1);
	if(x<r&&x<R)Mak(L,R,d,x+1,r);
}
ll get(int p,int l=1,int r=mt){
	pd(l,r);int x=l+r>>1;
	return p<x?get(p,l,x-1):p>x?get(p,x+1,r):my[x];
}
int get(ll d,int L,int R,int l,int r){
	if(l>r)return 0;pd(l,r);
	int x=l+r>>1,res=0;
	if(x<L)return get(d,L,R,x+1,r);
	if(x>R)return get(d,L,R,l,x-1);
	if(my[x]>=d){
		if(!(res=get(d,L,R,l,x-1)))res=x;
	}else res=get(d,L,R,x+1,r);
	return res;
}
ll get_ans(int l,int r){
	pd(l,r);int x=l+r>>1;ll res=my[x];
	if(l<x)res=min(res,get_ans(l,x-1));
	if(x<r)res=min(res,get_ans(x+1,r));
	return res;
}
int main(){
	n=read(),C=read();int i,l,r,md;ll val;
	for(i=1;i<=n;++i)mk[i]=-1,mp[i]=a[i]=read();
	stable_sort(mp+1,mp+n+1);
	mt=unique(mp+1,mp+n+1)-mp-1;
	for(i=1;i<=n;++i){
		a[i]=lower_bound(mp+1,mp+mt+1,a[i])-mp;
		Add(a[i],mt,-mp[a[i]]);
		if(a[i]>1){
			Add(1,a[i]-1,C,0),val=get(a[i]);
			Mak(get(val,1,a[i],1,mt),a[i],val);
		}
	}printf("%lld\n",get_ans(1,mt));
	return 0;
}
```

---

## 作者：JackMerryYoung (赞：3)

# 前言

赛时 T3 没想出来，回来补一下。

# 正文

爆搜复杂度过高一分没有（记忆化搜索除外），考虑 DP.

发现 Subtask #2 的值域奇小无比，于是设 $f_{i, j}$ 为当 $b_i = j$ 时的答案，属于 1D/2D 的 DP, 考虑做一个后缀最小值进行优化，复杂度为 $\mathcal{O}(NV)$, 可以拿 15 pts.

又发现 $\forall i, b_i = a_j$, 因为如果不等于，一定比将 $b_i$ 缩小为 $a_j$ 的答案劣。（省去一个 $C$ 能不优吗）

修改一下方程，设 $f_{i, j}$ 表示 $b_i$ 为 $a$ 中第 $i$ 大的数字，可以达到 $\mathcal{O}(N^3)$, 稍微一想就可以发现做一个前缀最小值就可以优化掉一维。可以拿下 Subtask #1 的 25pts.

然后考虑优化啦。发现值域路线难以再次优化，考虑将 Subtask #1 的做法再次优化成 $\log_2$ 级。

发现方程只转移自上一个人，考虑扔到线段树上去维护，计算每一个人的加入对答案的贡献。分类讨论：

$$
f_{i, j} = \min 
\begin{cases} 
f_{i - 1, j} + b_j - a_i \quad &(1 \le j \le k)    \\
f_{i - 1, j} + C 		 \quad &(k + 1 \le j \le N) \\
\end{cases}
$$

对于第二种情况可以简单的区间加。而对于第一种情况，一部分是 $a_i$ 容易维护，而 $b_j$ 不知道是谁，所以不好做。

发现两个序列都单调不增，所以相加以后同样单调不增，区间最小值的位置仍不变。所以 $b_j$ 就是右端点。 

不过发现 $f$ 为两个单调不增序列相接组成，不满足性质，于是最后再拿左边的右端点值拿来推平右区间即可。

复杂度约为 $\mathcal{O}(N \log_2 N)$. 可以通过。

# 代码

注意下传标记时先把儿子的推平标记传下去！！！记得开 $8$ 倍空间！！！

``` cpp
#include <bits/stdc++.h>
#define es else 
#define ef es if
using namespace std;

#define ll long long
#define rint register long long

long long N, C, minn;
long long a[1000005], b[1000005], num[1000005];

struct SegmentTree {
    bool flag;
    long long f, u, sum; 
} tree[8000005];

#define lc(p) (p << 1 | 0)
#define rc(p) (p << 1 | 1)

void merge(long long p)
{
    tree[p].f = min(tree[p << 1].f, tree[(p << 1) | 1].f);
}

void flush_down(long long p)
{
    if(tree[p].flag)
    {
        tree[lc(p)].f = tree[rc(p)].f = tree[p].f;
        tree[lc(p)].u = tree[rc(p)].u = 0;
        tree[lc(p)].sum = tree[rc(p)].sum = 0;
        tree[lc(p)].flag = tree[rc(p)].flag = true;
        tree[p].flag = false;
    }
}

void push_down(long long l, long long r, long long p)
{
    flush_down(p), flush_down(lc(p)), flush_down(rc(p));
    if(tree[p].sum)
    {
        tree[lc(p)].f += tree[p].sum;
        tree[lc(p)].sum += tree[p].sum;
        tree[rc(p)].f += tree[p].sum;
        tree[rc(p)].sum += tree[p].sum;
        tree[p].sum = 0;
    }
    if(tree[p].u)
    {
        long long mid = (l + r) >> 1;
        tree[lc(p)].f += b[mid] * tree[p].u;
        tree[lc(p)].u += tree[p].u;
        tree[rc(p)].f += b[r] * tree[p].u;
        tree[rc(p)].u += tree[p].u;
        tree[p].u = 0;
    }
}

void dp1(long long l, long long r, long long p, long long x, long long val1, long long val2)
{
    long long mid = (l + r) >> 1;
    if(l != r)
        push_down(l, r, p);
    if(r <= x)
    {
        flush_down(p);
        tree[p].f += val1 + b[r];
        tree[p].sum += val1;
        ++ tree[p].u;
        if(r == x) 
            minn = tree[p].f;
    }
    ef(l > x)
    {
        flush_down(p);
        tree[p].f += val2;
        tree[p].sum += val2;
    }
    es
    {
        dp1(l, mid, lc(p), x, val1, val2);
        dp1(mid + 1, r, rc(p), x, val1, val2);
        merge(p);
    }
}

bool dp2(long long l, long long r, long long p, long long x, long long val1)
{
    long long mid = (l + r) >> 1;
    if(l != r)
        push_down(l, r, p);
    if(l > x)
    {
        if(tree[p].f > val1)
        {
            tree[p].f = val1, tree[p].sum = tree[p].u = 0;
            return (tree[p].flag = true);
        }
        if(l != r && dp2(l, mid, lc(p), x, val1)) dp2(mid + 1, r, rc(p), x, val1);
        return false;
    }
    ef(l == r)
        return false;
    ef(x < mid)
    {
        if(dp2(l, mid, lc(p), x, val1)) return dp2(mid + 1, r, rc(p), x, val1);
        else return false;
    }
    
    return dp2(mid + 1, r, rc(p), x, val1);
}

signed main()
{
    cin >> N >> C;
    for(long long i = 1; i <= N; ++ i)
        cin >> a[i], b[i] = a[i];

    sort(b + 1, b + N + 1);
    long long tmp = unique(b + 1, b + N + 1) - (b + 1);
    for(long long i = 1; i <= N; ++ i) 
        num[i] = tmp + 1 - (lower_bound(b + 1, b + tmp + 1, a[i]) - b);

    reverse(b + 1, b + tmp + 1);
    for(long long i = 1; i <= N; ++ i)
    {
        dp1(1, tmp, 1, num[i], -a[i], C);
        dp2(1, tmp, 1, num[i], minn);
    }

    cout << tree[1].f << endl;
    return 0;
}
```

# 后言

这 T3 也太变态了。

---

## 作者：DYYqwq (赞：2)

拿到这题首先想到 dp。先设一维 $dp_i$ 表示决策到第 $i$ 位的最小花费。

发现设一维 dp 缺少数值问题，导致不知道从哪里转移，于是设 $dp_{i,j}$ 表示我们已经决策到第 $i$ 位，且 $b_i$ 恰好为 $j$ 的时候的最小花费。

于是得 $dp_{i,j}=\min_{k=j}^{+\infty} dp_{i-1,k}+f(j,a_i)$。

于是维护一个后缀 $\min$ 即可做到 $O(nV)$。

但是这好劣啊。考虑优化。

发现只能从 $b_i$ 的值入手，因为 $i$ 是必不可少的。

接着发现 $b_i$ 一定是某个 $a$ 数组中的值才比较优的。为什么呢，请看下图（$x$ 轴表示 $b_i$ 的数值，$y$ 轴表示其对应的花费）：

![](https://cdn.luogu.com.cn/upload/image_hosting/ykzcgzoc.png)

于是改变状态：设 $dp_{i,j}$ 表示我们已经决策到第 $i$ 位，且 $b_i$ 恰好为 $a$ 中第 $j$ 大的数的时候的最小花费。

同样的，这也可以维护一个前缀的最小值来优化。

时间复杂度 $O(n^2)$。

然后回过头来，观察我们之前挂的那张图，从这里出来一个特别诡异的想法：就是把 $dp$ 数组映射到线段树上，直接维护。

其实算是一种比较套路的 trick 了。但是自己做这题的时候确实是没想到。

考虑每次转移的贡献。显然依照上图，是分为两部分的贡献。不妨设一下 $a_i$ 是 $a$ 中第 $pos$ 大的数。

- 一部分是 $j \in [pos+1,n]$ 的，其中 $dp_{i,j}=dp_{i-1,j} + C$。
- 另一部分的 $j \in [1,pos]$，其中 $dp_{i,j}=dp_{i-1,j}-a_i+b_j$。

显著的，第一部分和第二部分的 $-a_i$ 随便用线段树维护一下就行，但是如何维护 $+b_j$？

但是发现这两个东西都是单调的，且单调性一样，所以原来的最小值依然是最小值。做区间推平操作即可。

这个很难想到啊。我觉得这个想到了线段树也不一定会这个的维护啊。

然后这道题就这么 $O(n\log n)$ 的做完了。

---

## 作者：Corzica (赞：2)

显然，对于 $b$ 序列中出现的每一个数，都一定是 $a$ 序列中的数，否则可以通过答案不变大的变化变为 $a$ 中的数。


定义 $dp_{i,j}$ 为前 $i$ 位，最后一个数是 $a_j$ 的最小代价。发现对于 $p<q$，一定有 $dp_{i,p} \le dp_{i,q}$。于是转移可以通过排序后前缀和优化做到 $O(n^2)$。

考虑用线段树优化这个问题，需要维护的操作有区间加（对应 $b_i<a_i$ 的情况）、区间加自身下标（对应 $b_i>a_i$ 的情况）、区间修改（对应每一个数取后缀 min）。

注意到我们进行修改的时候，一定是拿当前位置上的答案，对前串的一段后缀进行修改，所以还需要使用线段树二分找到最后一个修改位置进行修改。

线段树直接维护 3 个 tag 即可，具体见代码。
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
struct node {
	int l, r, addtag, changetag, val, addstag;
} b[4000006];
int n, ls[1000006], m, a[1000006], c;
inline void build(int p, int l, int r) {
	b[p].l = l, b[p].r = r;
	b[p].addtag = 0, b[p].changetag = -1, b[p].addstag = 0;
	if (l == r) {
		return;
	}
	build(2 * p, l, (l + r) >> 1);
	build(2 * p + 1, ((l + r) >> 1) + 1, r);
}
inline void adds(int p, int q) {
	b[p].val += q;
	b[p].addtag += q;
}
inline void changes(int p, int q) {
	b[p].val = q;
	b[p].changetag = q;
	b[p].addtag = b[p].addstag = 0;
}
inline void qadds(int p, int q) {
	b[p].val += ls[b[p].r] * q;
	b[p].addstag += q;
}
inline void push_down(int p) {
	if (b[p].changetag != -1) {
		changes(2 * p, b[p].changetag);
		changes(2 * p + 1, b[p].changetag);
		b[p].changetag = -1;
	}
	if (b[p].addtag) {
		adds(2 * p, b[p].addtag);
		adds(2 * p + 1, b[p].addtag);
		b[p].addtag = 0;
	}
	if (b[p].addstag) {
		qadds(2 * p, b[p].addstag);
		qadds(2 * p + 1, b[p].addstag);
		b[p].addstag = 0;
	}
}
inline void update(int p) {
	b[p].val = b[2 * p + 1].val;
}
inline void add(int p, int l, int r, int w) {
	if (b[p].l >= l && b[p].r <= r) {
		adds(p, w);
		return;
	}
	push_down(p);
	int mid = (b[p].l + b[p].r) >> 1;
	if (l > mid) add(2 * p + 1, l, r, w);
	else if (r <= mid) add(2 * p, l, r, w);
	else add(2 * p, l, mid, w), add(2 * p + 1, mid + 1, r, w);
	update(p);
}
inline void qadd(int p, int l, int r, int w) {
	if (b[p].l >= l && b[p].r <= r) {
		qadds(p, w);
		return;
	}
	push_down(p);
	int mid = (b[p].l + b[p].r) >> 1;
	if (l > mid) qadd(2 * p + 1, l, r, w);
	else if (r <= mid) qadd(2 * p, l, r, w);
	else qadd(2 * p, l, mid, w), qadd(2 * p + 1, mid + 1, r, w);
	update(p);
}
inline void change(int p, int l, int r, int w) {
	if (b[p].l >= l && b[p].r <= r) {
		changes(p, w);
		return;
	}
	push_down(p);
	int mid = (b[p].l + b[p].r) >> 1;
	if (l > mid) change(2 * p + 1, l, r, w);
	else if (r <= mid) change(2 * p, l, r, w);
	else change(2 * p, l, mid, w), change(2 * p + 1, mid + 1, r, w);
	update(p);
}
inline int query(int p, int q) {
	if (b[p].l == b[p].r) return b[p].val;
	push_down(p);
	if (q <= ((b[p].l + b[p].r) >> 1)) return query(2 * p, q);
	return query(2 * p + 1, q);
}
inline int finds(int p, int r, int val) {
	if (b[p].r <= r) {
		if (b[p].val <= val) return b[p].r + 1;
		if (b[p].l == b[p].r) return b[p].l;
		push_down(p);
		if (b[2 * p].val > val) return finds(2 * p, r, val);
		return finds(2 * p + 1, r, val);
	} else {
		int mid = (b[p].l + b[p].r) >> 1;
		push_down(p);
		if (r <= mid) return finds(2 * p, r, val);
		if (b[2 * p].val > val) return finds(2 * p, r, val);
		return finds(2 * p + 1, r, val);
	}
}
signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> c;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		ls[i] = a[i];
	}
	sort(ls + 1, ls + n + 1);
	m = unique(ls + 1, ls + n + 1) - ls - 1;
	build(1, 1, m);
	int op, val, p;
	for (int i = 1; i <= n; i++) {
		op = lower_bound(ls + 1, ls + m + 1, a[i]) - ls;
		if (op > 1) {
			add(1, 1, op - 1, c);
		}
		if (op != m) {
			add(1, op + 1, m, -a[i]);
			qadd(1, op + 1, m, 1);
		}
		if (op > 1) {
			val = query(1, op);
			p = finds(1, op - 1, val);
			if (p <= op - 1) change(1, p, op - 1, val);
		}
	}
	cout << query(1, 1);
}
```

---

## 作者：D2T1 (赞：1)

## LuoguP8476 -「GLR-R3」惊蛰

考虑设 $f_{i}(x)$ 表示考虑到第 $i$ 个，目前 $b_i\geq x$ 的最优解。那么这个函数肯定是单调递增的。考虑一次 $i-1\to i$ 相当于：

- 将 $<a_i$ 的部分全体 $+C$；
- 将 $\geq a_i$ 的部分全体 $-a_i$ 再加上下标；
- 取后缀 $\min$，即二分出 $[0,a_i-1]$ 内 $>f_i(a_i)$ 的部分修改为 $f_i(a_i)$。

发现都可以线段树维护。每个节点维护推平、加、加下标三个 tag 再加一个区间 $\max$。修改时先推平再加。

但是这题如果直接动态开点空间应该过不去，所以可以先离散化（这样加下标的部分变为加 $b_i$，由于都是单增的所以区别不大）。

```cpp
// Problem: GLR-R3 - 惊蛰
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P8476
// Memory Limit: 512 MB
// Time Limit: 3000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int N = 1e6 + 10;
int n, C, a[N], b[N], tot = 1;

struct node{
	ll ad, mx, sp;
	int ls, rs, l, r, tg;
} t[N*12];

void psd(int p){
	int mid = t[p].l + t[p].r >> 1;
	if(!t[p].ls && t[p].l != t[p].r){
		t[p].ls = ++ tot;
		t[t[p].ls].l = t[p].l;
		t[t[p].ls].r = mid;
	}
	if(!t[p].rs && t[p].l != t[p].r){
		t[p].rs = ++ tot;
		t[t[p].rs].l = mid + 1;
		t[t[p].rs].r = t[p].r;
	}
	if(t[p].sp != -1){
		t[t[p].ls].mx = t[t[p].rs].mx = t[p].sp;
		t[t[p].ls].tg = t[t[p].ls].ad = 0;
		t[t[p].ls].sp = t[p].sp;
		t[t[p].rs].tg = t[t[p].rs].ad = 0;
		t[t[p].rs].sp = t[p].sp;
		t[p].sp = -1;
	}
	t[t[p].ls].tg += t[p].tg;
	t[t[p].ls].mx += (ll)t[p].tg * b[t[t[p].ls].r];
	t[t[p].rs].tg += t[p].tg;
	t[t[p].rs].mx += (ll)t[p].tg * b[t[t[p].rs].r];
	t[p].tg = 0;
	t[t[p].ls].ad += t[p].ad;
	t[t[p].ls].mx += t[p].ad;
	t[t[p].rs].ad += t[p].ad;
	t[t[p].rs].mx += t[p].ad;
	t[p].ad = 0;
}
void psu(int p){
	t[p].mx = max(t[t[p].ls].mx, t[t[p].rs].mx);
}

void add(int p, int l, int r, int ql, int qr, ll v){
	if(qr < l || r < ql) return;
	if(ql <= l && r <= qr){
		t[p].mx += v;
		t[p].ad += v;
	} else {
		int mid = l + r >> 1;
		psd(p);
		add(t[p].ls, l, mid, ql, qr, v);
		add(t[p].rs, mid+1, r, ql, qr, v);
		psu(p);
	}
}
void tag(int p, int l, int r, int ql, int qr){
	if(qr < l || r < ql) return;
	if(ql <= l && r <= qr){
		t[p].mx += b[t[p].r];
		++ t[p].tg;
	} else {
		int mid = l + r >> 1;
		psd(p);
		tag(t[p].ls, l, mid, ql, qr);
		tag(t[p].rs, mid+1, r, ql, qr);
		psu(p);
	}
}
void mdf(int p, int l, int r, int ql, int qr, ll v){
	if(qr < l || r < ql) return;
	if(ql <= l && r <= qr){
		t[p].mx = t[p].sp = v;
		t[p].tg = t[p].ad = 0;
	} else {
		int mid = l + r >> 1;
		psd(p);
		mdf(t[p].ls, l, mid, ql, qr, v);
		mdf(t[p].rs, mid+1, r, ql, qr, v);
		psu(p);
	}
}
ll qry(int p, int l, int r, int x){
	if(l == r){
		return t[p].mx;
	} else {
		int mid = l + r >> 1;
		psd(p);
		if(x <= mid) return qry(t[p].ls, l, mid, x);
		else return qry(t[p].rs, mid+1, r, x);
	}
}
int fnd(int p, int l, int r, int ql, int qr, ll v){
	if(l == r){
		return l;
	} else {
		int mid = l + r >> 1;
		psd(p);
		if(t[t[p].ls].mx >= v){
			return fnd(t[p].ls, l, mid, ql, qr, v);
		} else {
			return fnd(t[p].rs, mid+1, r, ql, qr, v);
		}
	}
}

int main(){
	scanf("%d%d", &n, &C);
	if(!C){
		puts("0");
		return 0;
	}
	bool flg = 1;
	for(int i = 1; i <= n; ++ i){
		scanf("%d", &a[i]);
		if(a[i] < a[i-1]){
			flg = 0;
		}
		b[i] = a[i];
	}
	if(flg){
		ll sum = 0, ans = 8e18;
		for(int i = 1; i <= n; ++ i){
			sum += a[i];
			ans = min(ans, a[i] * (ll)i - sum + ((ll)n-i) * C);
		}
		printf("%lld\n", ans);
		return 0;
	}
	sort(b + 1, b + n + 1);
	int mx = unique(b + 1, b + n + 1) - b - 1;
	t[1].l = 1, t[1].r = mx;
	for(int i = 1; i <= n; ++ i){
		a[i] = lower_bound(b + 1, b + mx + 1, a[i]) - b;
		add(1, 1, mx, 1, mx, C);
		add(1, 1, mx, a[i], mx, -b[a[i]]-C);
		tag(1, 1, mx, a[i], mx);
		ll val = qry(1, 1, mx, a[i]);
		int p = fnd(1, 1, mx, 1, a[i]-1, val);
		mdf(1, 1, mx, p, a[i]-1, val);
	}
	printf("%lld\n", qry(1, 1, mx, 1));
	return 0;
}
```

---

## 作者：_XHY20180718_ (赞：1)

## 思路：

看完题面后，发现有一些 $O(nV)$ 和 $O(n^2)$ 的部分分，明示动态规划。

对于当前填的数 $b_i$，填数的限制条件为序列 ${b}$ 单调不增，所以我们只关心上一次填的数 $b_{i-1}$，所以我们只需要在 DP 状态中加入当前填的数即可。

设 $g_{i,j}$ 为考虑已经构造完了前 $i$ 个数，且当前位置 $b_i$ 填 $j$ 的最大贡献。

那么我们就有了一个朴素的状态转移方程式：
$$
g_{i,j}=\min_{k=j}^{V}g_{i-1,k}+f(j,a_i)
$$
从后往前枚举 $j$ 即可获得 $O(n^2)$ 的复杂度。

考虑减少转移状态，注意到我们的限制条件为 $b_i$ 单调不升。

若 $b_i>a_i$，必然是为了让后面某些 $j$ 的 $b_j-a_j$ 尽量小并且不会使得 $b_j<a_j$，而 $b_j-a_j$ 最小可以为 $0$，所以这会使 $b_i=b_j=a_j$。

若 $b_i<a_i$，则必然是由于前面的某些 $j$ 的 $b_j$ 已经等于 $b_i$ 了，为了使这些 $b_j-a_j$ 尽量小，才来牺牲这个代价 $C$，而 $b_j-a_j$ 最小可以为 $0$，那么 $a_j=b_j=b_i$。

除去上面两种情况，只剩 $b_i=a_i$。

所以 ${b}$ 序列中的值一定都会从序列 ${a}$ 中来获取。

我们的权值只需要从小到大枚举 $a_i$ 了，将其排序去重之后离散化即可，注意把原数组也存下来，不然你会由于空间访问不连续使得常数非常大！

在离散化之后，我们的复杂度变为了 $O(n\times\min\{n,V\})$。

考虑进一步优化，将上面那个式子拆开。
$$
g_{i,j}=\begin{cases}
\min_{k=j}^V g_{i-1,k}+C,j<a_i\\
\min_{k=j}^V g_{i-1,k}+j-a_i,j\geq a_i\\
\end{cases}
$$
观察转移式，发现对于 $j<a_i$，我们实际上只是对后缀 $\min$ 进行区间加便可得到下一维的式子，而对于 $j\geq a_i$，我们实际上只是对区间上的所有数加了相应的 $j$，并区间减去 $a_i$，上面这些操作都很好用线段树维护，可是快速把一个序列变成他的后缀 $\min$ 我们似乎却很难做到？

继续发掘这个转移式的性质，发现在转移后，对于 $j<a_i$，$g_{i,j}$，$C$ 为常数，$\min$ 区间变小意味着其值变大，一定会是一个单调不降的序列；而对于$j\geq a_i$，$g_{i,j}$ ，$j$ 也是单调递增，$a_i$ 为常数，也是一个单调递增的序列。

那么我们求后缀 $\min$ 就很好进行操作了，上面可以发现以 $a_i$ 为断点，这是一个由两个单调不降序列组成的序列，后缀 $\min$ 只要我们对前面那一段序列的后面几位大于 $g_{a_i}$ 的数进行区间覆盖即可。

线段树上二分求出哪一段区间需要区间覆盖，然后再进行覆盖即可，这里可以先把 $[1,R-1]$ 这段区间上的线段树结点提取出来，然后再对这些单个节点进行线段树上二分，存下每个节点的左右端点上的值，这样做即为单 $\log n$。

再说一下怎么让所有数加上相应的 $j$，只要将离散化后的数组存起来，在单点查询的时候打个标记，将左右端点加上对应的值即可。

然后我们就把这道题做完了，线段树实现起来有点复杂，尤其是进行了离散化和线段树上的一堆操作。

## 代码：
```cpp
#include<bits/stdc++.h>
#define mid (l+(r-l>>1))
#define ls (mid<<1)
#define rs (ls|1)
#define int long long
using namespace std;
const int N=1e6+5,V=1e9+5,inf=1e18+5;
int n,m,C,a[N],b[N],ans,g[N],c[N];
int L,R,I,K;
struct node{int l,r,id;};
vector<node>vec;
inline int calc(int x,int y){return x>=y?x-y:C;}
struct Tree{int w,rw,f1,f2=-1,f3;}tr[N<<1];
inline void chg1(int id,int w)
{tr[id].f1+=w;tr[id].w+=w,tr[id].rw+=w;}
inline void chg2(int id,int w)
{tr[id].f1=tr[id].f3=0,tr[id].rw=tr[id].w=tr[id].f2=w;}
inline void chg3(int id,int w,int l,int r)
{tr[id].f3+=w,tr[id].w+=w*b[l],tr[id].rw+=w*b[r];}
inline void pushdown(int l,int r,int id){
    int w1=tr[id].f1,w2=tr[id].f2,w3=tr[id].f3;
    if(w2+1)chg2(ls,w2),chg2(rs,w2),tr[id].f2=-1;
    if(w1)chg1(ls,w1),chg1(rs,w1),tr[id].f1=0;
    if(w3)chg3(ls,w3,l,mid),chg3(rs,w3,mid+1,r),tr[id].f3=0;
}
inline void upd1(int l,int r,int id){
    if(L<=l&&r<=R)return chg1(id,K);
    pushdown(l,r,id);
    if(L<=mid)upd1(l,mid,ls);
    if(mid<R)upd1(mid+1,r,rs);
    tr[id].w=tr[ls].w;
    tr[id].rw=tr[rs].rw;
}
inline void upd2(int l,int r,int id){
    if(L<=l&&r<=R)return chg2(id,K);
    pushdown(l,r,id);
    if(L<=mid)upd2(l,mid,ls);
    if(mid<R)upd2(mid+1,r,rs);
    tr[id].w=tr[ls].w;
    tr[id].rw=tr[rs].rw;
}
inline void upd3(int l,int r,int id){
    if(L<=l&&r<=R)return chg3(id,1,l,r);
    pushdown(l,r,id);
    if(L<=mid)upd3(l,mid,ls);
    if(mid<R)upd3(mid+1,r,rs);
    tr[id].w=tr[ls].w;
    tr[id].rw=tr[rs].rw;
}
inline int qry(int l,int r,int id){
    if(l==r)return tr[id].w;pushdown(l,r,id);
    return (mid<I?qry(mid+1,r,rs):qry(l,mid,ls));
}
inline void qry2(int l,int r,int id){
    if(l==r)return;
    if(K<=tr[id].w){L=min(L,l);return;}
    pushdown(l,r,id);
    if(K>=tr[rs].w)qry2(mid+1,r,rs);
    else L=min(L,mid+1),qry2(l,mid,ls);
    tr[id].w=tr[ls].w;
    tr[id].rw=tr[rs].rw;
}
inline void find(int l,int r,int id){
    if(L<=l&&r<=R){vec.push_back({l,r,id});return;}
    pushdown(l,r,id);
    if(mid<R)find(mid+1,r,rs);
    if(L<=mid)find(l,mid,ls);
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    cin>>n>>C;ans=inf;
    for(int i=1; i<=n; ++i)
        cin>>a[i],c[i]=b[i]=a[i];
    sort(b+1,b+1+n);
    m=unique(b+1,b+1+n)-b-1;
    for(int i=1; i<=n; ++i)
        a[i]=lower_bound(b+1,b+1+m,a[i])-b;
    for(int i=1; i<=n; ++i){
        L=1,R=a[i]-1,K=C;if(R)upd1(1,m,1);
        L=a[i],R=m,upd3(1,m,1);
        K=-c[i],upd1(1,m,1);
        I=a[i],K=qry(1,m,1);
        L=1,R=a[i]-1;if(R)find(1,m,1);L=V;
        for(auto u:vec){
            if(tr[u.id].rw<=K)break;
            if(tr[u.id].w<=K){qry2(u.l,u.r,u.id);break;}
            L=min(L,u.l);
        }
        if(L<=R)upd2(1,m,1);vec.clear();
    }
    for(I=1; I<=m; ++I)
        ans=min(ans,qry(1,m,1));
    cout<<ans;
    return 0;
}
```

---

## 作者：teylnol_evteyl (赞：1)

首先，所有在 $b$ 中出现的值一定都在 $a$ 中出现过，所以将 $a$ 离散化，设 $s$ 表示 $a$ 中不同数的数量，第 $k$ 大数为 $x_k$。

可以列出朴素的 DP 状态 $g_{i,j}$ 表示前 $i$ 个数、最后一个数是第 $j$ 大的最小代价，则方程为 $g_{i,j}=\min_{k=j}^s\{g_{i-1,k}+f(a_i,x_k)\}$。

可以用前缀和优化，或者定义状态为 $g_{i,j}$ 表示前 $i$ 个数、最后一个数大于等于第 $j$ 大的最小代价，则 $g_{i,j}=\min\{g_{i-1,j}+f(a_i,x_k),g_{i,j+1}\}$。答案是 $g_{n,1}$。时间复杂度 $O(ns)$。

考虑把状态排到线段树上。

设第 $i$ 个数是第 $k$ 小，则需要依次进行以下操作：

- $g_j\gets g_j+c(0\leq j<k)$
- $g_j\gets g_j+x_j-x_k(k\leq j\leq s)$
- $g_j\gets \min\{g_j,g_{j+1}\}$

对于第一个操作和第二个操作的 $-x_k$，是区间加一个常数。

对于第二个操作的 $+x_j$，区间中每个点加这个点的权值。

在执行完前两个操作之后，序列被划分成了 $[1,k),[k,s]$ 这两个有序的区间，则取最小值就是在左区间中二分出最小的比 $f_k$ 大的数，然后区间复制。所以，就需要维护区间的最大值和最小值。

回过头看操作 2，相当于是一个单调的序列加上另一个单调的序列，则不管是加之前还是加之后，最大值都会取区间末尾元素，最小值都会取区间开头元素，所以可以直接加对应的值。

时间复杂度 $O(n\log n)$。

[code](https://www.luogu.com.cn/paste/r9nspllp)。

---

## 作者：Leasier (赞：1)

首先考虑一个暴力 dp：

- 设 $dp_{i, j}$ 为 $b_i = j$ 时 $\displaystyle\sum_{k = 1}^i f(b_k, a_k)$ 的最小值。
- 转移：$dp_{i, j} = \displaystyle\min_{k = j} dp_{i - 1, k} + f(j, a_i)$。
- 答案：$\displaystyle\min_{i = 0} dp_{n, i}$。

直接做是 $O(nw)$ 的（其中 $w$ 为值域 $10^9$），显然不能通过。

注意到只有 $j$ 为 $0$ 或某个 $a_i$ 时才有效，则值域降至 $O(n)$，但时间复杂度为 $O(n^2)$，还是不能通过。

考虑把 dp 扔到一个数据结构上维护，来观察一下我们需要执行的操作：

- 前缀加常数。
- 后缀加等差数列。
- 全局取后缀 $\min$。

~~然后我模拟赛时看到最后一种操作就立马放弃了这个想法 /cf~~

注意到在进行前两个操作后 dp 数组必然以 $a_i$ 分界被分为了两个单调不降的段，设 $t = dp_{i, a_i}$，则最后一个操作相当于令 $\forall j \in [0, a_i), dp_{i, j} \leftarrow \min(dp_{i, j}, t)$。

考虑到单调性，则会被更新的 $j$ 为一个后缀。

于是我们用线段树维护 dp，每次在 $[0, a_i)$ 中二分出会被更新的 $j$ 的范围，然后做一次区间赋值即可。

时间复杂度为 $O(n \log n)$。

代码：
```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>

namespace Fread {
	const int BUFFER_SIZE = 1 << 25;
	char buffer[BUFFER_SIZE + 7];
	char *pstart = buffer, *pend = buffer;
	
	inline char getchar(){
		if (pstart < pend) return *pstart++;
		pstart = buffer;
		pend = buffer + fread(buffer, 1, BUFFER_SIZE, stdin);
		return pstart == pend ? EOF : *pstart++;
	}
	
	inline int read(){
		int ans = 0;
		char ch = getchar();
		while (ch < '0' || ch > '9'){
			ch = getchar();
		}
		while (ch >= '0' && ch <= '9'){
			ans = ans * 10 + (ch ^ 48);
			ch = getchar();
		}
		return ans;
	}
}

using namespace std;

typedef long long ll;

typedef struct {
	int l;
	int r;
	ll assign;
	ll constant;
	int arithmetical;
	ll max;
} Node;

int a[1000007], b[1000007];
Node tree[4000007];

void build(int x, int l, int r){
	tree[x].l = l;
	tree[x].r = r;
	tree[x].assign = -1;
	if (l == r) return;
	int mid = (l + r) >> 1;
	build(x * 2, l, mid);
	build(x * 2 + 1, mid + 1, r);
}

inline void push_add_constant(int x, ll k){
	tree[x].constant += k;
	tree[x].max += k;
}

inline void push_assign(int x, ll k){
	tree[x].assign = tree[x].max = k;
	tree[x].constant = tree[x].arithmetical = 0;
}

inline void push_add_arithmetical(int x, int k){
	tree[x].arithmetical += k;
	tree[x].max += (ll)k * b[tree[x].r];
}

inline void pushdown(int x){
	int ls = x * 2, rs = x * 2 + 1;
	if (tree[x].assign != -1){
		push_assign(ls, tree[x].assign);
		push_assign(rs, tree[x].assign);
		tree[x].assign = -1;
	}
	if (tree[x].constant != 0){
		push_add_constant(ls, tree[x].constant);
		push_add_constant(rs, tree[x].constant);
		tree[x].constant = 0;
	}
	if (tree[x].arithmetical != 0){
		push_add_arithmetical(ls, tree[x].arithmetical);
		push_add_arithmetical(rs, tree[x].arithmetical);
		tree[x].arithmetical = 0;
	}
}

inline void update(int x){
	tree[x].max = tree[x * 2 + 1].max;
}

void add_constant(int x, int l, int r, int k){
	if (l <= tree[x].l && tree[x].r <= r){
		push_add_constant(x, k);
		return;
	}
	int mid = (tree[x].l + tree[x].r) >> 1;
	pushdown(x);
	if (l <= mid) add_constant(x * 2, l, r, k);
	if (r > mid) add_constant(x * 2 + 1, l, r, k);
	update(x);
}

void add_arithmetical(int x, int l, int r, int k){
	if (l <= tree[x].l && tree[x].r <= r){
		push_add_arithmetical(x, k);
		return;
	}
	int mid = (tree[x].l + tree[x].r) >> 1;
	pushdown(x);
	if (l <= mid) add_arithmetical(x * 2, l, r, k);
	if (r > mid) add_arithmetical(x * 2 + 1, l, r, k);
	update(x);
}

ll get_val(int x, int pos){
	if (tree[x].l == tree[x].r) return tree[x].max;
	pushdown(x);
	if (pos <= ((tree[x].l + tree[x].r) >> 1)) return get_val(x * 2, pos);
	return get_val(x * 2 + 1, pos);
}

int find(int x, int l, int r, ll k){
	if (tree[x].r <= r){
		if (tree[x].max < k) return -1;
		if (tree[x].l == tree[x].r) return tree[x].l;
		int ans;
		pushdown(x);
		ans = find(x * 2, l, r, k);
		if (ans == -1) ans = find(x * 2 + 1, l, r, k);
		return ans;
	}
	int ans;
	pushdown(x);
	ans = find(x * 2, l, r, k);
	if (r > ((tree[x].l + tree[x].r) >> 1) && ans == -1) ans = find(x * 2 + 1, l, r, k);
	return ans;
}

void assign(int x, int l, int r, ll k){
	if (l <= tree[x].l && tree[x].r <= r){
		push_assign(x, k);
		return;
	}
	int mid = (tree[x].l + tree[x].r) >> 1;
	pushdown(x);
	if (l <= mid) assign(x * 2, l, r, k);
	if (r > mid) assign(x * 2 + 1, l, r, k);
	update(x);
}

int main(){
	int n = Fread::read(), c = Fread::read(), m = 0;
	b[++m] = 0;
	for (register int i = 1; i <= n; i++){
		a[i] = b[++m] = Fread::read();
	}
	sort(b + 1, b + m + 1);
	m = unique(b + 1, b + m + 1) - b - 1;
	for (register int i = 1; i <= n; i++){
		a[i] = lower_bound(b + 1, b + m + 1, a[i]) - b;
	}
	build(1, 1, m);
	for (register int i = 1; i <= n; i++){
		add_constant(1, a[i], m, -b[a[i]]);
		add_arithmetical(1, a[i], m, 1);
		if (a[i] > 1){
			ll val = get_val(1, a[i]);
			add_constant(1, 1, a[i] - 1, c);
			assign(1, find(1, 1, a[i], val), a[i], val);
		}
	}
	cout << get_val(1, 1);
	return 0;
}
```

---

## 作者：OrinLoong (赞：0)

纪念一下我在[巨佬](https://www.luogu.com.cn/user/28313)的大力帮助下过掉的高妙线段树优化 dp。  
首先考虑最暴力的做法： $O(NV^2)$ 的 dp 是这样的：设 $dp_{i,j}$ 表示考虑到第 $i$ 个人，$B_i$ 填 $j$ 时的最小代价，不难得出转移柿子：  
$dp_{i,j}=\min_{k=j}^{A_{i_{max}}}dp_{i-1,k}+calc(i)$，  
其中 $calc(i)$ 表示这一位上的代价。  
（什么你问我这个题为什么是 dp？分析无后效性子结构等等，长得还是很像线性 dp 的吧）  
这个做法可以让我们获得一颗鸭蛋。不过有一个很 naive 的明显优化：每次取 min 的过程其实是在取后缀最小值，所以加个后缀和优化，就能做到 $O(NV)$ 拿下 15pts。  
这部分代码：  
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long lolo;
const int MaxN=1e6+5;
const lolo Inf=0x3f3f3f3f3f3f3f3f;
int N,C,A[MaxN],V;
const int MidN=1e5+5,MidV=105;
lolo dp[MidN][MidV],sfx[MidN];
lolo calc(int a,int b){return (a<=b)?b-a:C;}
int main(){
    scanf("%d%d",&N,&C);memset(dp,0x3f,sizeof(dp));
    for(int i = 1;i <= N;i++){scanf("%d",&A[i]);V=max(V,A[i]);}sfx[V+1]=Inf;
    for(int i = V;i >= 0;i--)dp[1][i]=calc(A[1],i),sfx[i]=min(sfx[i+1],dp[1][i]);
    for(int i = 2;i <= N;i++){
        for(int j = 0;j <= V;j++)dp[i][j]=sfx[j]+calc(A[i],j);
        for(int j = V;j >= 0;j--)sfx[j]=min(sfx[j+1],dp[i][j]);
    }
    lolo ans=Inf;
    for(int i = 0;i <= V;i++)ans=min(ans,dp[N][i]);
    printf("%lld",ans);
    return 0;
}
```
考虑正解，不难发现 `calc` 的转移暗藏着不少共性：要么加个常量，要么加个等差数列；[这个巨佬的博客](https://www.cnblogs.com/yanshanjiahong/articles/17825160.html)启示我们——
> 若某一维（通常是后一维）的转移具有较强的共性时，可以考虑利用整体 dp 优化。

分析到这一步，肯定不能不考虑线段树了。线段树优化线性 dp 的常用套路实际上是把原 dp 的第一维滚掉（因为转移都只与 $dp_{i-1}$ 的值有关，然后把余下的一维数组摊到线段树上维护。（想了解同类题目？见文末）  
考虑一下我们在线段树上要干些什么。推一下可以发现：我们每一轮更新首先是在 $sfx$ 数组上，以 $A_i$ 为界，$[0,A_i)$ 上面我们区间加一个常量 $C$（对应原题中“老师会不高兴”这部分），$[A_i,N]$ 部分我们加一个首项为 0，公差为 1 的等差数列。这个时候其实我们得到的就是整个 $dp_i$ 数组；然后我们对它做一遍后缀和，以得到下次转移的基础。不妨画个图直观理解：  
![](https://cdn.luogu.com.cn/upload/image_hosting/4xea31vf.png)  
最后答案就是最后一轮更新完时的全局最小值。  
线段树上，支持区间加，维护区间最小值都是平凡的；其它操作似乎都没有那么平凡；不过，我们要有一双善于发现单调性的眼睛！观察到 $sfx$ 永远单调不递减，$dp$ 以 $A_i$ 为界前后两段也永远单调不递减。  
单调性既保证了支持等差数列加操作时也可以很正确地维护区间最小值（因为这题里面等差数列也是个单调不递减的东西，单调不递减+单调不递减=单调不递减，区间最小值一定在最左端）也保证了我们可以通过线段树上二分的方式找到左区间第一个大于等于 $dp_{i,A_i}$ 值的位置（记为 $pos$），然后把 $[pos,A_i)$ 推平。  
好了这题讲完了，接下来就是代码实现了！记得离散化！  
什么你不会区间加等差数列？左转[这↑里↓](https://www.luogu.com.cn/article/foe1i8ns)。  
对于本人这种蒟蒻来说，这种线段树操作多而杂的题目并不好写（然而在某些神犇的眼中可能只有 CF\*2300）。注意点还是不少的。仔细想想推平 tag 怎么下传，以及线段树二分怎么写。  
最后，完整代码奉上！马蜂良好适合阅读（虽然没有注释就是了QAQ）  
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long lolo;
const int MaxN=1e6+5;
const lolo Inf=0x3f3f3f3f3f3f3f3f;
int N,C,A[MaxN],B[MaxN],M;
int qrdint(){
    int k=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while('0'<=ch&&ch<='9')k=k*10+(ch-'0'),ch=getchar();
    return k*f;
}
struct SegTree{
    lolo mn[MaxN<<2],atag[MaxN<<2],dtag[MaxN<<2],ftag[MaxN<<2];
    int ls(int p){return p<<1;}
    int rs(int p){return (p<<1)|1;}
    void init(){
        memset(mn,0,sizeof(mn)),memset(atag,0,sizeof(atag));
        memset(ftag,-1,sizeof(ftag)),memset(dtag,0,sizeof(dtag));
    }
    void pushup(int p){mn[p]=min(mn[ls(p)],mn[rs(p)]);}
    void makeatag(int p,lolo val){mn[p]+=val,atag[p]+=val;}
    void makeftag(int p,lolo val){mn[p]=val,ftag[p]=val,atag[p]=dtag[p]=0;}
    void makedtag(int p,int l,lolo val){mn[p]+=B[l]*val,dtag[p]+=val;}
    void pushdown(int p,int l,int mid){
        if(ftag[p]!=-1){makeftag(ls(p),ftag[p]),makeftag(rs(p),ftag[p]);ftag[p]=-1;}
        if(atag[p]){makeatag(ls(p),atag[p]),makeatag(rs(p),atag[p]);atag[p]=0;}
        if(dtag[p]){makedtag(ls(p),l,dtag[p]),makedtag(rs(p),mid+1,dtag[p]);dtag[p]=0;}
    }
    void addupd(int p,int l,int r,int x,int y,lolo val){
        if(x<=l&&r<=y){makeatag(p,val);return;}
        int mid=(l+r)>>1;pushdown(p,l,mid);
        if(x<=mid)addupd(ls(p),l,mid,x,y,val);
        if(y>mid)addupd(rs(p),mid+1,r,x,y,val);
        pushup(p);
    }
    void flaupd(int p,int l,int r,int x,int y,lolo val){
        if(x<=l&&r<=y){makeftag(p,val);return;}
        int mid=(l+r)>>1;pushdown(p,l,mid);
        if(x<=mid)flaupd(ls(p),l,mid,x,y,val);
        if(y>mid)flaupd(rs(p),mid+1,r,x,y,val);
        pushup(p);
    }
    void ariupd(int p,int l,int r,int x,int y,lolo mns,lolo cmd){
        if(x<=l&&r<=y){makeatag(p,mns),makedtag(p,l,cmd);return;}
        int mid=(l+r)>>1;pushdown(p,l,mid);
        if(x<=mid)ariupd(ls(p),l,mid,x,y,mns,cmd);
        if(y>mid)ariupd(rs(p),mid+1,r,x,y,mns,cmd);
        pushup(p);
    }
    lolo getmin(int p,int l,int r,int x,int y){
        if(x<=l&&r<=y)return mn[p];
        int mid=(l+r)>>1;lolo res=Inf;pushdown(p,l,mid);
        if(x<=mid)res=min(res,getmin(ls(p),l,mid,x,y));
        if(y>mid)res=min(res,getmin(rs(p),mid+1,r,x,y));
        pushup(p);return res;
    }
    int binaser(int p,int l,int r,int x,int y,lolo val){
        if(l==r)return mn[p]>=val?l:-1;
        int mid=(l+r)>>1,res=-1;pushdown(p,l,mid);
        if(x<=l&&r<=y){
            if(mn[ls(p)]>val)return l;
            if(mn[ls(p)]<=val&&mn[rs(p)]>val){
                res=binaser(ls(p),l,mid,x,y,val);
                return res==-1?mid+1:res;
            }
            if(mn[rs(p)]<=val)return binaser(rs(p),mid+1,r,x,y,val);
            return -1;
        }
        if(x<=mid)res=binaser(ls(p),l,mid,x,y,val);
        if(res==-1&&y>mid)res=binaser(rs(p),mid+1,r,x,y,val);
        return res;
    }
}SegTr;
int main(){
    N=qrdint(),C=qrdint();SegTr.init();
    for(int i = 1;i <= N;i++){A[i]=qrdint();B[i]=A[i];}
    sort(B+1,B+N+1);M=unique(B+1,B+N+1)-B-1;
    for(int i = 1;i <= N;i++)A[i]=lower_bound(B+1,B+M+1,A[i])-B;
    for(int i = 1;i <= N;i++){
        SegTr.ariupd(1,1,M,A[i],M,-B[A[i]],1);
        if(A[i]==1)continue;
        SegTr.addupd(1,1,M,1,A[i]-1,C);
        lolo riv=SegTr.getmin(1,1,M,A[i],A[i]);
        int pos=SegTr.binaser(1,1,M,1,A[i]-1,riv);
        if(pos!=-1)SegTr.flaupd(1,1,M,pos,A[i]-1,riv);
    }
    printf("%lld",SegTr.getmin(1,1,M,1,M));
    return 0;
}
```
最后是一份[线段树优化dp题单](https://www.luogu.com.cn/training/606601)送给看到这的各位

---

## 作者：TernaryTree (赞：0)

很帅气的线段树题。考虑朴素 dp $f_{i,j}$ 表示第 $i$ 位填了 $j$ 的最小值，有

$$f_{i,j}=f(j,a_i)+\min_{k\ge j} f_{i-1,k}$$

这等价于，对 $f_j$ 数组依次进行 $n$ 次**整体转移**，每次将每个 $f_j\gets f_j+f(j,a_i)$，再进行一次后缀 $\min$。

一个结论是，存在一种最优解使得每个 $b_i$ 都在原序列中出现过。考虑若一个解中存在若干个 $b_i\not\in \{a_i\}$，则将所有 $b_i$ 赋值为最大的比它小的 $a_j$ 不会令答案变劣。这样我们改状态为 $f_{i,j}$ 表示第 $i$ 位填了 $a_j$（已排序并去重）的最小值，可以做到 $\Theta(n^2)$ 的复杂度，结合 $\Theta(nV)$ 暴力可以得到 $40$ 分。

注意到每次整体转移完成后 $f_j$ 单调不减。而下一次 $f_j\gets f_j+f(j, a_i)$ 会将 $f_j$ 分为两段：对于 $[1,a_i)$ 区间加上 $C$，这一段仍不减；对于 $[a_i,V]$ 区间加上 $j-a_i$，不减序列加不减序列，仍然单调不减。这两部分线段树是好维护的。比较棘手的是后缀取 $\min$ 操作，但注意到只有两段不减子段，所以被影响到的也只是一段区间：将后面一段的开头扔在第一段上二分出区间开头即可。注意以上优化 dp 的叙述基于 $\Theta(nV)$ 做法，需要自行将其改为基于 $\Theta(n^2)$ 的 $\Theta(n\log n)$ 做法。

综上，线段树需要维护操作：

- 区间加
- 区间加 $a_i$
- 区间覆盖
- 在一段前缀内二分出第一个 $\gt x$ 的数。

同时维护区间最大值即可。

---


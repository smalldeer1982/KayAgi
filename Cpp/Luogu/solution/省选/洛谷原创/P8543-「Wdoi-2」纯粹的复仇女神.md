# 「Wdoi-2」纯粹的复仇女神

## 题目背景

>「因为，人类的历史与成长，就是战争的历史与成长。没有纷争，就没有成长。满足于现状，就等于人类放弃了生存。月之民每天都为地上人考虑着。地上人的历史，就是月之民创造的。」

「我对月之民还是很了解的。这么说吧，她们在各式各样的异世界的居民中，属于最恶劣的那一类。超级排他，超级没自由，虚构的乐园，虽然擅长鄙视别人，但无法容忍自己被当成笨蛋。她们甚至认为其他世界的居民连杂菌都不如。」

「最重要的问题是，月之民敌视着幻想乡，就是这样的。」 

「没想到竟然会把地上人送到月面上来，之前丝毫没有过这种想法呢。那些眼里容不下一点沙子的月之民，竟然会使用这种不入流的手段。」

「幻想乡被作为人质绑架了，可以这么认为吧？要是想拯救幻想乡的话，就不许对月之都动手，就是这种不人道的策略。」

遥遥 $38$ 万公里航程之外，于此故乡之星倒映之海，打败不共戴天之敌，击碎永久不得醒之梦。

> 不倶戴天の敵、$\stackrel{じょうが}{嫦娥}$よ。見てるか！？    
> 不共戴天之敌，嫦娥啊。你在看着吗！？

## 题目描述

### 简要题意

给定一个长度为 $n$ 的序列，序列中每个元素是一个二元组 $(c_i,a_i)$，分别表示颜色与权值。

现在有 $q$ 次询问，每次给出一个区间 $[l,r]$，求：

$$\max\limits_{k=1}^n \left\{\min\limits_{l\le i \le r,c_i=k} a_i\right\}$$

特别地，如果 $[l,r]$ 内没有颜色为 $k$ 的值，后面的部分定义为 $0$。
### 原始题意
纯狐的能力是纯化，一旦灵梦身上的污秽被纯化，则必死无疑。

灵梦携带了 $n$ 张一字排开的灵符用于转嫁污秽，但纯狐依旧可以纯化附着在上面的污秽，置灵梦于死地。

具体地，每次纯狐命中一个区间 $[l_i,r_i]$ 中的所有灵符，灵梦需要在此之前净化这些灵符上面的污秽。  
每张灵符有固定的颜色 $c_i$，经过激烈的战斗，每张灵符上沾染了 $a_i$ 单位的污秽。  
同种颜色的灵符之间相互作用，净化区间内一批相同颜色的灵符，其灵力花费为这些灵符上污秽的最小值。  
由于逸散的灵力可以为其他灵符所吸收，灵梦只需知道该区间内所有颜色的灵符净化花费的最大值，此为她净化一次的灵力花费。

给定 $\{c_i\}$ 和 $\{a_i\}$，每次给出纯狐的一种可能的攻击 $l_i,r_i$，问灵梦净化一次的灵力花费。注意只是计算，每次给出答案后并不改变 $\{c_i\}$ 和 $\{a_i\}$。

## 说明/提示

### 样例 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/yu9grxjy.png)

如图，数字代表权值，背景色代表颜色。

- 对于区间 $[3,4]$，出现的两种颜色对应的权值最小值为 $10$ 和 $4$，取最大值答案为 $10$。
- 对于区间 $[3,9]$，出现的三种颜色对应的权值最小值为 $1,4$ 和 $4$，取最大值答案为 $4$。
- 对于区间 $[4,8]$，出现的三种颜色对应的权值最小值为 $1,4$ 和 $4$，取最大值答案为 $4$。
- 对于区间 $[3,6]$，出现的两种颜色对应的权值最小值为 $9$ 和 $4$，取最大值答案为 $9$。
- 对于区间 $[3,3]$，出现的一种颜色对应的权值最小值为 $10$。
其余同理。

### 数据范围及约定

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|c|}\hline
\textbf{Subtask} & \bm{n\le } & \bm{q\le} & \textbf{特殊性质} & \textbf{Subtask 依赖} & \textbf{分值}\\\hline
1 & 100 & 100 & - & - & 10\\\hline
2 & 2 \times 10^5 & 2\times 10^5 & \textbf A & - & 20\\\hline
3 & 2 \times 10^5 & 2\times 10^5 & - & 2 & 30\\\hline
4 & 2 \times 10^5 & 10^6 & - & 1,3 & 40\\\hline
\end{array}
$$

特殊性质 $\textbf A$：所有的 $c_i \leq 10$。

对于全部数据，保证 $1 \leq n \leq 2\times10^5$，$1 \leq q \leq 10^6$，$1 \le c_i,a_i \le n$，$l \leq r$。

## 样例 #1

### 输入

```
10 10
3 2 2 1 2 1 3 2 1 2 
10 4 10 4 9 8 1 4 9 4 
3 4
3 9
4 8
3 6
3 3
9 10
5 8
5 8
6 8
5 8
```

### 输出

```
10
4
4
9
10
9
8
8
8
8
```

# 题解

## 作者：Alex_Wei (赞：13)

> [P8543 「Wdoi-2」纯粹的复仇女神](https://www.luogu.com.cn/problem/P8543)

对于每个 $(a_i, c_i)$，考虑 $a_i$ 作为区间所有 $c_j = c_i$ 的 $a_j$ 的最小值时，合法左右端点的形态。可知若询问左端点落在 $[L, i]$，右端点落在 $[i, R]$，则本次询问答案至少不小于 $a_i$，其中 $L$ 为颜色为 $c_i$ 且 $a_j < a_i$，$j < i$ 的 $i$ 的前驱 $j$ 加 $1$：左端点不能跨过 $j$，否则 $\min$ 会变得更小；同理 $R$ 为颜色为 $c_i$ 且 $a_j < a_i$，$j > i$ 的 $i$ 的后继 $j$ 减 $1$。若 $L$ 不存在则为 $1$，$R$ 不存在则为 $n$。

通过上述分析，可知每个 $(a_i, c_i)$ 对询问的贡献是矩形 $[L, i]\times [i, R]$ 取 $\max$。矩形可以通过对每个颜色按 $a_i$ 从大到小扫描线 + set 维护求出。

问题转化为矩形取 $\max$，单点查询，且所有查询在加入所有矩形后。对 $x$ 轴扫描线，在 $x = L$ 处往 $y\in [i, R]$ 加入 $a_i$，在 $x = i + 1$ 处从 $y\in [i, R]$ 删除 $a_i$。非常经典的标记永久化树套树。具体地，加入时往 $[i, R]$ 的拆分区间维护的平衡树中加入 $a_i$，删除同理。查询时查询经过所有节点的平衡树最大值。用 `multiset` 会被卡常，需要用两个 `priority_queue` 模拟可删除堆。

时间复杂度 $\mathcal{O}(n\log ^ 2n + q\log n)$。

```cpp
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
using namespace std;
using namespace __gnu_pbds;
#define fi first
#define se second
#define TIME 1e3 * clock() / CLOCKS_PER_SEC
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
using ull = unsigned long long;
inline ll read() {
  ll x = 0, sgn = 0;
  char s = getchar();
  while(!isdigit(s)) sgn |= s == '-', s = getchar();
  while(isdigit(s)) x = x * 10 + s - '0', s = getchar();
  return sgn ? -x : x;
}
inline void print(int x) {
  if(x < 0) return putchar('-'), print(-x);
  if(x >= 10) print(x / 10);
  putchar(x % 10 + '0');
}
bool Mbe;
constexpr int N = 2e5 + 5;
constexpr int Q = 1e6 + 5;
void cmin(int &x, int y) {x = x < y ? x : y;}
void cmax(int &x, int y) {x = x > y ? x : y;}
pii d[N];
int n, q, cnt, c[N], a[N], ans[Q];
set<int> s[N];
priority_queue<int> val[N << 2], era[N << 2];
vector<pair<pii, int>> add[N];
vector<pii> qu[N];
void modify(int l, int r, int ql, int qr, int x, int v) {
  if(ql <= l && r <= qr) {
    if(v > 0) val[x].push(v);
    else era[x].push(-v);
    return;
  }
  int m = l + r >> 1;
  if(ql <= m) modify(l, m, ql, qr, x << 1, v);
  if(m < qr) modify(m + 1, r, ql, qr, x << 1 | 1, v);
}
int query(int l, int r, int p, int x) {
  int ans = 0;
  while(!era[x].empty() && val[x].top() == era[x].top()) val[x].pop(), era[x].pop();
  if(!val[x].empty()) ans = val[x].top();
  if(l == r) return ans;
  int m = l + r >> 1;
  return max(ans, p <= m ? query(l, m, p, x << 1) : query(m + 1, r, p, x << 1 | 1));
}
bool Med;
signed main() {
  fprintf(stderr, "%.3lf MB\n", (&Mbe - &Med) / 1048576.0);
  #ifdef ALEX_WEI
    FILE* IN = freopen("1.in", "r", stdin);
    FILE* OUT = freopen("1.out", "w", stdout);
  #endif
  cin >> n >> q;
  for(int i = 1; i <= n; i++) c[i] = read(), s[c[i]].insert(i);
  for(int i = 1; i <= n; i++) a[i] = read(), d[i] = {a[i], i};
  sort(d + 1, d + n + 1);
  for(int i = n, pt = n; i; i--) {
    while(pt && d[pt].first == i) {
      int id = d[pt--].second, col = c[id];
      auto pt = s[col].find(id);
      int l = 1, r = n;
      if(pt != s[col].begin()) l = *--pt + 1, pt++;
      if(pt != --s[col].end()) r = *++pt - 1, pt--;
      s[col].erase(pt);
      add[l].push_back({{id, r}, i});
      add[id + 1].push_back({{id, r}, -i});
    }
  }
  for(int i = 1; i <= q; i++) {
    int l = read(), r = read();
    qu[l].push_back({r, i});
  }
  for(int i = 1; i <= n; i++) {
    for(auto it : add[i]) modify(1, n, it.fi.fi, it.fi.se, 1, it.se);
    for(auto it : qu[i]) ans[it.se] = query(1, n, it.fi, 1);
  }
  for(int i = 1; i <= q; i++) print(ans[i]), putchar('\n');
  cerr << TIME << " ms\n";
  return 0;
}
```

---

## 作者：离散小波变换° (赞：6)

## 题解

注意到，这是个不带修改的区间查询的问题。根据一般套路，我们可以先将所有的询问离线下来，枚举询问的右端点 $r$，再来解决所有 $r_i=r$ 的询问。

![](https://cdn.luogu.com.cn/upload/image_hosting/eivxdrka.png)

如图所示。我们以数组下标作为横轴，以每一种颜色作为纵轴，绘制题目中所给出的 $a_i$。

假定现在我们要处理一组询问 $(l,r)$，也就是处理这样一个红色的矩形。矩形的每一行的权值就是该行元素的最小值；所求即为所有行的权值的最大值。

因为我们已经把操作离线下来，因此可以先看作 $r$ 是定值来思考。可以发现，对于每一列，这个 $l$ 越小，这一列的权值单调不增。光有这个还不够。注意到，第 $i$ 列上某个元素会成为这一列的权值，所对应的 $l$，应该是**连续的一段区间**。

![](https://cdn.luogu.com.cn/upload/image_hosting/x5qhz6od.png)

如图所示，取出其中的一列。可以发现，当 $l$ 向左移动的时候，这一列的权值共发生了三次变化：$5\to 3\to 2$。事实上，我们可以计算出每个 $a_i$ 成为该列的权值时，所对应的区间 $[p_i,q_i]$。那么问题转化为了对一系列区间的操作（区间 $[p_i,q_i]$ 的权值就是 $a_i$）。

那么在枚举 $r$ 的时候，我们要干这样几件事：

- 将区间 $[p_r,q_r](a_r)$ 加入。
- 处理右端点为 $r$ 的所有询问 $(l_i,r_i)$。
- 将 $q_i=r$ 的区间都删除。

我们要用一种数据结构能够维护这三种操作。这个结构要求可以支持加入指定区间、删除指定区间、查询包含 $l$ 的区间的权值的最大值。

这是可以使用加上了**标记永久化**的线段树实现的。标记永久化的含义是，当执行修改操作恰好覆盖了当前节点，我们给它打上的标记是永久化的。当有询问操作要经过这个线段树节点时，我们用这个标记更新这次询问的答案。

具体而言，我们开一个线段树，维护不同的 $l$ 所查询到的答案。线段树的每个节点都要维护一个 $\verb!set!$，这个 $\verb!set!$ 就是永久化了的标记。

- 对于加入区间 $[p,q](a)$ 操作，我们先找到对应的线段树节点们，向它们的 $\verb!set!$ 里加入 $a$。
- 对于删除区间 $[p,q](a)$ 操作，我们同样找到对应的线段树的节点们，从他们的 $\verb!set!$ 里删除 $a$。
- 对于查询操作，我们一路上，访问节点的时候，从标记里找最大值（如果有最大值的话）并更新答案即可。

标记永久化的好处：如果不永久化，那么查询的时候需要将标记下推，但是由于我们的标记是 $\verb!set!$，下推起来复杂度会爆炸。

还有个问题，就是对于每个 $i$，找到 $[p_i,q_i]$。容易发现，这等价于找到，颜色等于 $c_i$，值不超过 $a_i$ 的最靠近它的两个点。可以使用单调队列维护。

## 关于卡常

由于本题需要卡掉 $\mathcal O(m\sqrt n)$ 的做法，因此对时限卡的略紧（但保证是 $\text{std}$ 两倍时限以上）。

直接使用 $\text{multiset}$ 维护标记的话，常数较大。但是由于本题需要支持的操作较少（插入、删除、查找最大值），我们可以用两个堆来替代这个 $\text{multiset}$：

- 用两个堆 $P,Q$，$P$ 存储每个元素的值，$Q$ 用来懒惰删除。
- 对于插入操作，直接向 $P$ 中插入元素。
- 对于删除操作，直接向 $Q$ 中**插入**元素。
- 对于查询操作，不断比较 $P$ 和 $Q$ 的堆顶（如果有的话），如果堆顶相同，就说明 $P$ 堆顶的元素应该是在某个时候被删除掉了。那么 $P,Q$ 同时弹出堆顶，一直到堆顶不同。

容易发现，对于每个元素只会被插入、弹出最多一次，因此均摊时间复杂度是 $\mathcal O(\log n)$ 的。

但是堆的常数明显小于平衡树，因此可以极大减小常数。下面的代码里用的是手写配对堆，但是实测用 $\text{STL}$ 里的优先队列也能无压力过题。

另外有一点就是，计算 $[p_i,q_i]$ 时需要用到栈。但是栈基于 $\text{deque}$ 实现，无论是时间常数还是空间常数都很大，建议使用 $\text{vector}$ 替代。

## 代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
const int MAXN= 2e5 + 3;
const int SIZ = 8e5 + 3;
multiset <int,greater<int>> O[SIZ];
#define lc(t) (t<<1  )
#define rc(t) (t<<1|1)
void modify(int t,int a,int b,int l,int r,int w){
    if(l<=a&&b<=r){
        if(w>0) O[t].insert(w);
        if(w<0) O[t].erase (O[t].find(-w));
    } else {
        int c=a+b>>1;
        if(l<=c) modify(lc(t),a,c  ,l,r,w);
        if(r> c) modify(rc(t),c+1,b,l,r,w);
    }
}
void query(int t,int a,int b,int p,int &w){
    if(!O[t].empty()) w=max(w,*O[t].begin());
    if(a==b) return; int c=a+b>>1;
    if(p<=c) query(lc(t),a,c  ,p,w);
    if(p> c) query(rc(t),c+1,b,p,w);
}
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
int n,q,A[MAXN],C[MAXN],L[MAXN],R[MAXN],W[MAXN];
stack <int> S1[MAXN],S2[MAXN];
struct Node1{int l,r,w;};
struct Node2{int l,x  ;};
vector<Node1> V[MAXN]; vector<Node2> Q[MAXN];
int main(){
    n=qread(),q=qread(); A[0]=A[n+1]=-INF;
    up(1,n,i) S1[i].push(0),S2[i].push(n+1);
    up(1,n,i) C[i]=qread();
    up(1,n,i) A[i]=qread();
    up(1,n,i){
        while(A[S1[C[i]].top()]>=A[i]) S1[C[i]].pop();
        L[i]=S1[C[i]].top()+1,S1[C[i]].push(i);
    }
    dn(n,1,i){
        while(A[S2[C[i]].top()]>=A[i]) S2[C[i]].pop();
        R[i]=S2[C[i]].top()-1,S2[C[i]].push(i);
    }
    up(1,n,i){
        V[  i   ].push_back({L[i],i, A[i]});
        V[R[i]+1].push_back({L[i],i,-A[i]});
    }
    up(1,q,i){
        int l=qread(),r=qread(); Q[r].push_back({l,i});
    }
    up(1,n,i){
        for(auto &p:V[i]) modify(1,1,n,p.l,p.r,p.w);
        for(auto &p:Q[i]) query(1,1,n,p.l,W[p.x]);
    }
    up(1,q,i) printf("%d\n",W[i]);
    return 0;
}
```

---

## 作者：FutaRimeWoawaSete (赞：3)

我的评价是纯纯的套路题，虽然远远不能喷，但是作为一道**合格的 ds 题出到月赛这个位置也许还是有所欠缺**。

其实是那天水 LA 的时候看到有人在问这个题，没想到现在月赛还有 ds 题，于是就来看了看。然后一眼了。

你考虑一个这样的嵌套结构，内层的贡献具有单调性，这启发我们整个过程都是可以单调栈辅助扫描线，维护每个颜色对于扫描线时候对每个位置的贡献。

于是问题转化为：

- 强制在线的区间集合加元素，区间集合减少元素，单点集合求 $\max$，保证删除操作合法且与加入操作配对。

因为加入/删除是配对的，所以直接线段树套个随便的支持加入删除查询最大值的结构即可，然后每次删除和加入的节点是可以配对的，直接暴力删然后标记永久化找一找就做完了。

时间复杂度 $O(n \log ^ 2 n + m \log n)$，空间复杂度 $O(m \log n)$。

```cpp
/*
可以用单调栈辅助扫描线
等价于区间加入一个数区间集合从区间集合删除一个数
这就辅助一下标记永久化就完了。 
*/
#include "bits/stdc++.h"
using namespace std;
#define ll long long
char buf[1<<23],*p1=buf,*p2=buf,obuf[1<<23],*O=obuf;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
inline int read() {
	int x=0;char ch=getchar();
	while(!isdigit(ch)){ch=getchar();}
	while(isdigit(ch)) x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return x;
}
void print(ll x) {
    if(x>9) print(x/10);
    *O++=x%10+'0';
}
const int Len = 2e5 + 5;
int n,q,c[Len],a[Len];
vector<int> vec[Len];int tp[Len];
struct pp{int l,r;pp(){l = r = 0;}pp(int L,int R){l = L , r = R;}}ps[1000005];
vector<pp> QQ[Len];int sz[Len];
int Print[1000005]; 
#define ls(p) (p << 1)
#define rs(p) (p << 1 | 1)
int wss[Len << 2];multiset<int> st[Len << 2];
inline int Q(int p){if(!st[p].size()) return 0;return *st[p].rbegin();}
void add(int p,int l,int r,int nl,int nr,int w)
{
	if(nl <= l && nr >= r) 
	{
		st[p].insert(w);
		wss[p] = Q(p);
		return;
	}
	int mid = (l + r) >> 1;
	if(nl <= mid) add(ls(p) , l , mid , nl , nr , w);
	if(nr > mid) add(rs(p) , mid + 1 , r , nl , nr , w);
}
multiset<int>::iterator it;
void del(int p,int l,int r,int nl,int nr,int w)
{
	if(nl <= l && nr >= r)
	{
		it = st[p].find(w);
		st[p].erase(it);
		wss[p] = Q(p);
		return; 
	}
	int mid = (l + r) >> 1;
	if(nl <= mid) del(ls(p) , l , mid , nl , nr , w);
	if(nr > mid) del(rs(p) , mid + 1 , r , nl , nr , w);
}
int ms;
void Q(int p,int l,int r,int idx)
{
	ms = max(ms , wss[p]);
	if(l == r) return;
	int mid = (l + r) >> 1;
	if(idx <= mid) Q(ls(p) , l , mid , idx);
	else Q(rs(p) , mid + 1 , r , idx);
}
int main()
{
	n = read() , q = read();
	for(int i = 1 ; i <= n ; i ++) c[i] = read();
	for(int i = 1 ; i <= n ; i ++) a[i] = read() , tp[i] = 1;
	for(int i = 1 ; i <= q ; i ++) ps[i].l = read() , ps[i].r = read() , sz[ps[i].r] ++;
	for(int i = 1 ; i <= n ; i ++) QQ[i].reserve(sz[i]) , tp[c[i]] ++;
	for(int i = 1 ; i <= q ; i ++) QQ[ps[i].r].push_back(pp(ps[i].l , i));
	for(int i = 1 ; i <= n ; i ++) 
	{
		vec[i].resize(tp[i]);
		tp[i] = 0;
		vec[i][tp[i]] = 0;
	}
	for(int i = 1 ; i <= n ; i ++)
	{
		int col = c[i];
		while(tp[col] > 0 && a[i] < a[vec[col][tp[col]]]) 
		{
			del(1 , 1 , n , vec[col][tp[col] - 1] + 1 , vec[col][tp[col]] , a[vec[col][tp[col]]]);
			tp[col] --;
		}
		add(1 , 1 , n , vec[col][tp[col]] + 1 , i , a[i]);
		vec[col][++ tp[col]] = i;
		for(int j = 0 ; j < QQ[i].size() ; j ++) 
		{
			ms = 0;Q(1 , 1 , n , QQ[i][j].l);
			Print[QQ[i][j].r] = ms;
		}
	}
	for(int i = 1 ; i <= q ; i ++) print(Print[i]) , *O ++ = '\n';
	fwrite(obuf,O-obuf,1,stdout);
	return 0;
}
```

---

## 作者：绝顶我为峰 (赞：3)

大力出奇迹。

不会 polylog 怎么办？那就想想根号。

这种问题看起来就非常可以移动区间逐个处理贡献，想到用莫队解决这个问题。

考虑加点和删点的过程，加点是可以 $O(1)$ 更新对应颜色的最小值的，但是删点不行，这启示我们使用回滚莫队。

求出每种颜色最小值考虑怎样快速维护答案，朴素的想法是线段树或者树状数组维护所有颜色最小值的位置，每次加入一个点更新答案后就把这个点原来的贡献删掉，新的贡献加上，查询的时候线段树上二分或者树状数组倍增。但这样会让总复杂度变成 $O(n\sqrt m\log n+m\log n)$，连第三个 sub 都过不了。

注意到修改是在移动莫队指针的时候进行的，因此一共会修改 $O(n\sqrt m)$ 次。而查询只有每个询问会查询一次，因此只会查询 $O(m)$ 次。所以我们可以根号平衡，使用一种 $O(1)$ 修改 $O(\sqrt n)$ 查询的数据结构就可以把复杂度优化到 $O(n\sqrt m+m\sqrt n)$。

这种数据结构就是分块，同时维护每个点和每个块的总和，查询的时候直接倒着枚举找到第一个和不为 $0$ 的块在里面暴力查找即可。

这样交上去大约只会在第四个 sub 被卡掉两个点，接下来就要施展你高超的卡常技巧了：

- 快读快输；

- 调块长；

- 回退的时候不使用 vector 存需要回退的点而改用数组；

- 数组贴着下界开；

- 减少 cache miss，包括但不限于把重复取用的数组元素取出来放到临时变量里面，分块数组维护每个点和整块的数组不要开在同一个数组里等等。

事实上最后一条才是最有效的常数优化，经过卡常后可以通过这一题。

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<algorithm>
#include<cstring>
using namespace std;
const int block=245,lim=1e9;
int n,m,pos[200001],p[200001],col[200001],a[200001],ans[1000001],minn[200001],val[200001],cnt1[200001],cnt2[2001],tmp[251][2],tot;
struct element
{
    int l,r,id;
    bool operator <(const element &other) const
    {
        return pos[l]^pos[other.l]? pos[l]<pos[other.l]:r<other.r;
    }
}q[1000001];
namespace io {
	const int __SIZE = (1 << 21) + 1;
	char ibuf[__SIZE], *iS, *iT, obuf[__SIZE], *oS = obuf, *oT = oS + __SIZE - 1, __c, qu[55]; int __f, qr, _eof;
	#define Gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, __SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)
	inline void flush () { fwrite (obuf, 1, oS - obuf, stdout), oS = obuf; }
	inline void gc (char &x) { x = Gc(); }
	inline void pc (char x) { *oS ++ = x; if (oS == oT) flush (); }
	inline void pstr (const char *s) { int __len = strlen(s); for (__f = 0; __f < __len; ++__f) pc (s[__f]); }
	inline void gstr (char *s) { for(__c = Gc(); __c < 32 || __c > 126 || __c == ' ';)  __c = Gc();
		for(; __c > 31 && __c < 127 && __c != ' ' && __c != '\n' && __c != '\r'; ++s, __c = Gc()) *s = __c; *s = 0; }
	template <class I> inline bool gi (I &x) { _eof = 0;
		for (__f = 1, __c = Gc(); (__c < '0' || __c > '9') && !_eof; __c = Gc()) { if (__c == '-') __f = -1; _eof |= __c == EOF; }
		for (x = 0; __c <= '9' && __c >= '0' && !_eof; __c = Gc()) x = x * 10 + (__c & 15), _eof |= __c == EOF; x *= __f; return !_eof; }
	template <class I> inline void print (I x) { if (!x) pc ('0'); if (x < 0) pc ('-'), x = -x;
		while (x) qu[++ qr] = x % 10 + '0',  x /= 10; while (qr) pc (qu[qr --]); }
	struct Flusher_ {~Flusher_(){flush();}}io_flusher_;
} using io::pc; using io::gc; using io::pstr; using io::gstr; using io::gi; using io::print;
inline int read()
{
    int x=0;
    char c=getchar();
    while(c<'0'||c>'9')
        c=getchar();
    while(c>='0'&&c<='9')
    {
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x;
}
inline void add(int x)
{
    int y=col[x],z;
    if(a[x]<minn[y])
    {
        if(minn[y]<lim)
        {
            z=minn[y];
            --cnt1[z];
            --cnt2[pos[z]];
        }
        z=minn[y]=a[x];
        ++cnt1[z];
        ++cnt2[pos[z]];
    }
}
int main()
{
    gi(n);
    gi(m);
    for(int i=1;i<=n;++i)
    {
        gi(col[i]);
        pos[i]=(i-1)/block+1;
        if(i!=1&&pos[i]!=pos[i-1])
            p[pos[i-1]]=i-1;
        val[i]=lim;
    }
    p[pos[n]]=n;
    for(int i=1;i<=n;++i)
        gi(a[i]);
    for(int i=1;i<=m;++i)
        gi(q[i].l),gi(q[i].r),q[i].id=i;
    sort(q+1,q+m+1);
    for(int i=1,l=1,r=0,pl=0,pr=0,tl,tr,id,lst=0;i<=m;++i)
    {
        tl=q[i].l,tr=q[i].r,id=q[i].id;
        if(tr-tl+1<=250)
        {
            for(int j=tl;j<=tr;++j)
                if(a[j]<val[col[j]])
                    val[col[j]]=a[j];
            for(int j=tl;j<=tr;++j)
                if(val[col[j]]>ans[id])
                    ans[id]=val[col[j]];
            for(int j=tl;j<=tr;++j)
                val[col[j]]=lim;
            continue;
        }
        if(pos[tl]^lst)
        {
            lst=pos[tl];
            for(int j=1;j<=n;++j)
            {
                minn[j]=lim;
                cnt1[j]=0;
            }
            for(int j=1;j<=pos[n];++j)
                cnt2[j]=0;
            l=pl=p[pos[tl]]+1;
            r=pr=p[pos[tl]];
        }
        for(;r<tr;++r)
            add(r+1);
        tot=0;
        for(;l>tl;--l)
        {
            int qwq=col[l-1];
            tmp[++tot][0]=qwq;
            tmp[tot][1]=minn[qwq];
            add(l-1);
        }
        for(int j=pos[n];j>=1;--j)
            if(cnt2[j])
            {
                for(int k=p[j];;--k)
                    if(cnt1[k])
                    {
                        ans[id]=k;
                        break;
                    }
                break;
            }
        for(;l<pl;++l)
        {
            int x=tmp[tot][0],w=tmp[tot][1];
            if(minn[x]!=w)
            {
                int y=minn[x];
                --cnt1[y];
                --cnt2[pos[y]];
                minn[x]=w;
                if(w<lim)
                {
                    ++cnt1[w];
                    ++cnt2[pos[w]];
                }
            }
            --tot;
        }
    }
    for(int i=1;i<=m;++i)
        print(ans[i]),pstr("\n");
    return 0;
}
```

---

## 作者：Purslane (赞：2)

# Solution

考虑扫描线，并且使用单调栈维护每个颜色的后缀 $\rm min$，问题显然变为：

维护若干个可重集合 $S_{1,2,\cdots,n}$，有下列操作：

1. $S_{i}$ 插入或删除 $x$（对 $l \le i \le r$）；
2. 询问 $S_i$ 的最大值。

这个问题貌似很难直接做，但是注意到**所有删数的操作 $(l,r,x)$，都对应一个加数的操作 $(l,r,x)$ 与之完全相同**，因此可以直接标记永久化，树套树。

复杂度 $O(n \log^2 n + q \log n)$，据说卡常。

学习了题解区用 `priority_queue` 代替 `multiset` 的方法：开两个堆，分别维护删数和加数。

UPD：这个问题直接做也是不难的，但是需要下放标记，大常数 $O(n \log^2 n)$。

-----

实际上，如果把问题抽象出来，很容易发现也可以用整体二分解决。常数很小，也许能过。

鉴于题解区没有整体二分做法，所以我实现了整体二分。

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=2e5+10,MAXM=1e6+10;
int n,q,c[MAXN],a[MAXN],ans[MAXM];
vector<pair<int,int>> qr[MAXN];
stack<int> st[MAXN];
struct INFO {int op,l,r,v;};
int tr[MAXN];
#define mid (l+r>>1)
void Update(int pos,int v) {
	while(pos<=n) tr[pos]+=v,pos+=pos&-pos;
	return ;	
}
void update(int l,int r,int v){
	return Update(l,v),Update(r+1,-v),void();	
}
int query(int pos) {
	int ans=0;
	while(pos) ans+=tr[pos],pos-=pos&-pos;
	return ans;	
}
void solve(int l,int r,vector<INFO> qr) {
	if(l==r||qr.empty()) {
		for(auto pr:qr) if(pr.op==1) ans[pr.v]=l;
		return ;
	}
	vector<INFO> L,R;
	for(auto pr:qr) {
		if(pr.op==2) {
			if(pr.v>mid) R.push_back(pr),update(pr.l,pr.r,1);
			else L.push_back(pr);
		}
		else if(pr.op==3) {
			if(pr.v>mid) R.push_back(pr),update(pr.l,pr.r,-1);
			else L.push_back(pr);
		}
		else {
			int cnt=query(pr.l);
			if(cnt) R.push_back(pr);
			else L.push_back(pr);
		}
	}
	for(auto pr:R) if(pr.op==2) update(pr.l,pr.r,-1);
	else if(pr.op==3) update(pr.l,pr.r,1);
	vector<INFO>().swap(qr);
	solve(mid+1,r,R),solve(l,mid,L);
	return ;
}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>q;
	ffor(i,1,n) cin>>c[i];
	ffor(i,1,n) cin>>a[i];
	vector<INFO> vc;
	ffor(i,1,n) st[i].push(0);
	ffor(i,1,q) {
		int l,r;
		cin>>l>>r,qr[r].push_back({l,i});	
	}
	ffor(i,1,n) {
		while(a[i]<a[st[c[i]].top()]) {
			int u=st[c[i]].top();
			st[c[i]].pop();
			vc.push_back({3,st[c[i]].top()+1,u,a[u]});
		}
		vc.push_back({2,st[c[i]].top()+1,i,a[i]});
		st[c[i]].push(i);
		for(auto pr:qr[i]) vc.push_back({1,pr.first,i,pr.second});
	}
	solve(0,n,vc);
	ffor(i,1,q) cout<<ans[i]<<'\n';
	return 0;
}
```

---

## 作者：xukehg (赞：0)

萌新练习扫描线，记录一下。

考虑到颜色之间独立，所以把同种颜色先拎出来。

对于一个位置上的数 $a_i$，如果它是最小值，则包含它的区间 $[l,r]$ 的 $l$ 存在一个最小值，$r$ 存在一个最大值。记这两者的极限分别为 $lef_i$ 和 $rgh_i$。从左往右扫一遍，可以用单调栈维护最前面的比 $a_i$ 小的数，得到 $lef_i$，$rgh_i$ 可以通过类似方法求得。

综上，$i$ 只会对 $lef_i \leq l$ 且 $r \leq rgh_i$ 且 $l \leq i \leq r$ 的 $[l,r]$ 产生贡献，$l,r$ 的答案便是所有有贡献的 $i$ 的最大值。这种偏序结构很容易联系到扫描线。

将所有询问离线，从右端点小的询问到大的询问。指针 $i$ 每次向右移，固定右端点为 $i$，都需要：

- 对区间 $[l_i,i]$，加入 $a_i$，即更新所有左端点在 $[l_i,i]$ 的询问的答案。

- 对所有满足 $rgh_j = i - 1$ 的 $j$，撤销它们的贡献，显然它们不会再有贡献。

- 求对于所有满足 $r_j = i$ 的询问，区间 $[l_j,i]$ 的答案。

由于偏序的贡献形式，未被撤销贡献的位置 $j$ 仍然对左端点在 $[l_j,j]$ 的询问产生贡献，时间复杂度得到了保障。

这里可以使用线段树及标记永久化的技巧，便于加入和撤销。正常可以用 multiset 维护线段树上的区间的标记，但为了卡常，且只有插入，删除和求最大值三种操作，写懒惰删除堆即可维护。

---

## 作者：win114514 (赞：0)

自己的套路还是见少了。

### 思路

考虑扫描线。

每一个颜色的 $\min$ 具有单调性，这个很好看出来。

可以使用一个单调栈来维护。

这里都是朴素的。

考虑如何维护。

我们发现在通过单调栈维护的时候。

需要支持撤销上一个元素对区间的影响。

我就在这里卡了很久。

我们有一个很暴力的想法。

我们每一次区间取 $\max$ 时，我们将这个元素留下来，直接存着。

然后在撤销影响的时候就可以删掉这个点。

发现可以线段树做。

每个点维护一个可删堆。

使用标记永久化的思想。

这样每一次插入时只会增加 $\log$ 个值。

删除的时候也恰好时这 $\log$ 个位置。

至于可删堆如何维护。

我们可以拿两个优先队列模拟。

加入时丢进一个优先队列，删除时丢进另一个。

查询时先将堆顶相同的不断弹掉就可以了。

### Code

代码就比较简单。

```cpp
/**
 * @file P8543.cpp
 * @author win114514
 * @date 2023-11-25
 * 
 * @copyright Copyright (c) 2023
 * 
 */
#include <bits/stdc++.h>
using namespace std;

#define x first
#define y second
#define mp(x, y) make_pair(x, y)
#define eb(...) emplace_back(__VA_ARGS__)
#define fro(i, x, y) for(int i = (x);i <= (y);i++)
#define pre(i, x, y) for(int i = (x);i >= (y);i--)
#define dbg cerr << "Line " << __LINE__ << ": "
#define EVAL(x) #x " = " << (x)

typedef int64_t i64;
typedef uint32_t u32;
typedef uint64_t u64;
typedef __int128_t i128;
typedef __uint128_t u128;
typedef pair<int, int> PII;

bool ed;

const int N = 200010;
const int M = 1000010;
const int mod = 998244353;

int n, m, a[N], c[N], l[N], r[N], ans[M];
vector<int> to[N];
vector<PII> que[N];
priority_queue<int> t1[N<<1], t2[N<<1];

inline void ins(int p, int l, int r, int ls, int rs, int k)
{
	if(ls <= l && r <= rs)
		return t1[p].push(k), void();
	int mid = (l + r) >> 1;
	if(mid >= ls) ins(mid<<1, l, mid, ls, rs, k);
	if(mid <  rs) ins(mid<<1|1, mid + 1, r, ls, rs, k);
}
inline void del(int p, int l, int r, int ls, int rs, int k)
{
	if(ls <= l && r <= rs)
		return t2[p].push(k), void();
	int mid = (l + r) >> 1;
	if(mid >= ls) del(mid<<1, l, mid, ls, rs, k);
	if(mid <  rs) del(mid<<1|1, mid + 1, r, ls, rs, k);
}
inline void calc(int p)
{
	while(!t1[p].empty() && !t2[p].empty() && t1[p].top() == t2[p].top())
		t1[p].pop(), t2[p].pop();
}
inline int ask(int p)
	{ return (t1[p].empty() ? 0 : t1[p].top()); }
inline int ask(int p, int l, int r, int k)
{
	calc(p);
	if(l == r) return ask(p); int mid = (l + r) >> 1;
	if(mid >= k) return max(ask(p), ask(mid<<1, l, mid, k));
	return max(ask(p), ask(mid<<1|1, mid + 1, r, k));
}
inline void solve()
{
	cin >> n >> m; int x, y;
	fro(i, 1, n) cin >> c[i];
	fro(i, 1, n) cin >> a[i];
	fro(i, 1, n) to[i].eb(0);
	fro(i, 1, m) cin >> x >> y, que[y].eb(x, i);
	fro(i, 1, n)
	{
		while(a[to[c[i]].back()] > a[i])
			x = to[c[i]].back(), to[c[i]].pop_back(),
			del(1, 1, n, l[x], r[x], a[x]);
		r[i] = i, l[i] = to[c[i]].back() + 1, to[c[i]].eb(i);
		ins(1, 1, n, l[i], r[i], a[i]);
		for(auto [l, id] : que[i]) ans[id] = ask(1, 1, n, l);
	}
	fro(i, 1, m) cout << ans[i] << "\n";
}

bool st;

signed main()
{
	ios::sync_with_stdio(0), cin.tie(0);
	double Mib = fabs((&ed-&st)/1048576.), Lim = 1024;
	cerr << " Memory: " << Mib << "\n", assert(Mib<=Lim);
	solve();
	return 0;
}
```

---


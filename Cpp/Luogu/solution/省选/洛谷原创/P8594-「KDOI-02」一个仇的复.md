# 「KDOI-02」一个仇的复

## 题目背景

**本题由于 OI 赛制，关闭 subtask，可能会放部分错解高分，赛后将开启 subtask。**

「听说那件事了吗？愿他们安息。」  
「诶？你看，前面那座环形建筑是什么？」  
「等我对比一下……啊哈！这就是他们的老巢！」  
「捣毁了它，为牺牲的同志们报仇！！！」  
死亡的宇宙射线指向了脆弱的文明，正准备发出它震耳欲聋的怒吼。

## 题目描述

外星人的空间站是一个环形结构。不过，由于环的两段不连通，因此可以将其近似为 $2\times n$ 的平面网格。目前，地方飞船有 $n$ 种不同规格的射线武器，作用范围是 $1\times x$（$x$ 为正整数）的长方形。并且，武器可以往顺时针或逆时针方向旋转 $90^\circ$。射线十分强力，只需一发便可与作用范围平面内的所有物体相湮灭。不过，只要宇宙射线的一部分作用范围落到目标外，便会一直延续到宇宙尽头，贪婪地吞噬沿途的一切。指挥官当然不想危害到无辜文明，他想知道，在这 $n$ 中武器中选出 $k$ 种，共有多少种不同的摧毁飞行器的方式。

**【形式化题意】**

你有 $1\times x$（$x$ 为任意正整数）的矩形各无穷多个和一个 $2\times n$ 的网格，请求出恰好选择其中 $k$ 个矩形（可以选择相同的矩形）**不重不漏**地铺满整个网格的方案数。矩形可以旋转。

## 说明/提示

****
**【样例解释】**
+ **样例 1 解释：**  
共有如下图所示的 $8$ 种方案。  
![](https://cdn.luogu.com.cn/upload/image_hosting/iko97ksh.png)

***
**【数据范围】**

对于 $100\%$ 的数据，$1\le n\le 2\times 10^7$，$1\le k\le 5000$。

| 测试点编号 | 分值 | $n$ | $k$ |
| :----------: | :----------: | :----------: | :----------: |
|$1\sim 5$| $2$ | $\leq5$ | $\leq10$ |
|$6\sim 10$| $2$ | $\leq1000$ | $=2n$ |
|$11\sim 15$| $2$ | $\leq10^6$ | $\leq3$ |
|$16\sim 20$| $4$ | $\leq1000$ | $\leq2n$ |
|$21\sim 25$| $4$ | $\leq2\times10^7$ | $\leq100$ |
|$26\sim 30$| $4$ | $\leq10^6$ | $\leq5000$ |
|$31\sim 40$| $1$ | $\leq2\times10^7$ | $\leq5000$ |

注意：分值一列指的是单个测试点分值。

## 样例 #1

### 输入

```
4 3
```

### 输出

```
8
```

## 样例 #2

### 输入

```
15 5```

### 输出

```
4015```

## 样例 #3

### 输入

```
3050 1314```

### 输出

```
670638639```

## 样例 #4

### 输入

```
19198114 4154```

### 输出

```
264122135```

# 题解

## 作者：daniEl_lElE (赞：29)

前几个 `Subtask` 部分可以使用暴力、动态规划与矩阵快速幂优化动态规划解决，在此不一一阐述。

对于这道题，我们会发现一个特性，就是最多只能使用 $1\times2$ 的**竖着的**长方形以及一些横着的长方形来摆放。

**阅读提示，以下定义 $\dbinom{i}{j}=0$ 当 $i<j$ 或 $i<0$ 或 $j<0$。**

先考虑一个简单版本的问题，请问使用 $a$ 个长方形，只允许横着的，铺满 $2\times b$ 的方格的方案数。

考虑我们给上面一半放置 $i$ 个横着的长方形，那么下面一半就需要放 $a-i$ 长方形，这时，我们可以使用插板法，上面要放 $i$ 个长方形，且有 $b$ 个格子，那么答案就是 $\dbinom{b-1}{i-1}$，同理下面是 $\dbinom{b-i}{a-i-1}$。总方案数为 $\sum_{i=0}^{a} \dbinom{b-1}{i-1}\times \dbinom{b-1}{a-i-1}$。这个式子的实际含义可以看成从 $2b-2$ 个位置中，选取 $a-2$ 个板子，然而上面这种计算方法其实就是相当于枚举在前 $b-1$ 个位置中选出若干个，剩下来在后 $b-1$ 个位置中选择，我们也自然得知：$\sum_{i=0}^{a} \dbinom{b-1}{i-1}\times \dbinom{b-1}{a-i-1}=\dbinom{2b-2}{a-2}$，通过组合意义的方式可以证明（也不是没有纯组合证明，可以自行搜索）。

解决了这个小问题，我们可以来谈谈大体的思路。直接计算这个问题不好算，我们考虑先用 $j$ 个竖着的 $1\times2$ 的长方形，并把原来一整段的 $2\times n$ 大小的长方形分成了 $i$ 个 $2\times a_l$ 的独立的小段长方形，然后求其方案数，最终统一计算即可。

那么，现在我们的问题转换成了用 $j$ 个竖着的 $1\times2$ 的长方形，并把原来一整段的 $2\times n$ 大小的长方形分成了 $i$ 个 $2\times a_l$ 的独立的小段长方形的情况的方案数，

首先，我们会考虑将使用的 $j$ 个竖着的长方形时，将这 $j$ 个长方形分在 $i-1$ 个必须要有的段落之间的空格内以及在长方形左右两端的地方。也就是说，想要使得 $d_0+d_1+d_2+...+d_{i-1}+d_i=j,0\leq d_0,d_i,1\leq d_1,d_2,d_3...d_{i-1}$。这个问题又转化成了一个经典的插板问题，方案数是 $\dbinom{j+1}i$。

其次，我们假设每段分出来的距离是 $a_1,a_2,...,a_i$，那么我们还要把剩下的 $n-j$ 个位置分给这 $i$ 段。显然，每一段的长度都要求是正整数。那么方案数就是 $\dbinom{n-j-1}{i-1}$。

最后，我们还要考虑把剩下来的 $k-j$ 个长方形分到每段 $a_i$ 中，其实就是求：

$$\sum_{\sum_{l=1}^i b_l=k-j} \prod_{l=1}^i \dbinom{2a_l-2}{b_l-2}$$

很明显，这个式子可以表示成从 $\sum 2a_l-2$ 个位置中，选取 $\sum b_l-2$ 的所有方法，原式的意义就是先枚举每个段落选几个，再把所有方案相加，本质上就是求整个序列位置数中选取板子数。那么其实就是 $\dbinom{2n-2j-2i}{k-j-2i}$。

然后你把搞的式子交上去，你会获得 $10$ 分的好成绩，你需要知道自己为啥挂了。显然，我们没有考虑当 $n=k$ 时，你其实只需要在 $ans$ 上特判一下即可。

所以最终公式为：
$$\sum_{i=1}^k\sum_{j=0}^k\dbinom{2n-2j-2i}{k-j-2i}\times \dbinom{j+1}i\times \dbinom{n-j-1}{i-1}+[n=k]$$

```cpp
#include <bits/stdc++.h>
using namespace std;
int mod=998244353;
int qp(int a,int b){
	int ans=1;
	while(b){
		if(b&1) ans=((long long)ans*a)%mod;
		a=((long long)a*a)%mod;
		b>>=1;
	}
	return ans;
}
int fac[40000005],inv[40000005];
void init(){
	fac[0]=1;
	for(int i=1;i<=40000000;i++){
		fac[i]=((long long)fac[i-1]*i)%mod;
	}
	inv[40000000]=qp(fac[40000000],mod-2);
	for(int i=39999999;i>=0;i--){
		inv[i]=((long long)inv[i+1]*(i+1))%mod;
	}
}
long long C(int i,int j){
	return (long long)((long long)inv[j]*inv[i-j]%mod)*fac[i]%mod;
}
signed main(){
	init();
	int n,k;
	cin>>n>>k;
	int ans=0;
	for(int i=1;i<=k;i++){
		for(int j=0;j<=k&&k-j-2*i>=0;j++){
		    if(2*(n-i-j)<0||k-j-2*i<0||n-j-1<0||2*(n-i-j)<k-j-2*i||j+1<i||n-j-1<i-1) continue;
			ans=(ans+((long long)(C(2*(n-i-j),k-j-2*i)*C(j+1,i)%mod)*(long long)C(n-j-1,i-1)%mod))%mod;
		}
	}
	cout<<(ans+(n==k))%mod;
}
```

---

## 作者：starrylasky (赞：14)

[博客使用更佳](https://www.cnblogs.com/lasky/articles/16830003.html)。

显然，肯定是由一堆横着的和一些竖着 $2 \times 1$ 的构成的。而竖着的将将原来的网格分成了若干段。

先考虑只有一行，显然就是插板法。设长度为 $n$，用了 $m$ 块。答案就是 $\dbinom {n-1} {m-1}$。拓展到两个并列的一行，答案是 $\dbinom {2n-2} {m-1}$。感性理解，将两行放在一起，总共有 $2n-2$ 个位置可以插（交界处不能插），要分成 $m-1$ 块。要求多段，核心就是找到能插的个数和要划分的段数。

考虑枚举有 $i$ 个竖着的，其中有 $j$ 段。

先考虑剩下的分成 $n-i$ 段的方案。要求方案数，首先我们要知道能插的个数。这是需要分类讨论。

* 若竖着没有在开头和结尾的，那么能插的个数为 $2(n-1-i-j)$，还要划分的段数是 $m-2(j+1)-i$，那么方案就是 $\dbinom {2(n-1-i-j)} {m-2(j+1)-i}$。
* 若竖着只有一个在开头结尾，那么能插的个数为 $2(n-i-j)$，还要划分的段数是 $m-2j-i$，那么方案就是 $\dbinom {2(n-i-j)} {m-2j-i}$。
* 若竖着的都在开头和结尾，那么能插的个数为 $2(n+1-i-j)$，还要划分的段数是 $m-2(j-1)-i$，那么方案就是 $\dbinom {2(n+1-i-j)} {m-2(j-1)-i}$。

接着考虑竖着的方案，发现这个直接用插板法很难求，那么考虑分步来求。先考虑划分为 $j$ 段，这个直接插板求出，方案是 $\dbinom {i-1} {j-1}$，再考虑把这 $j$ 段再插到原来的网格中，可以插在剩下位置的前面，但是再第一个的前面就不行，所以方案是 $\dbinom {n-i-1} {j/j-1/j-2}$，下面取决于上面的分裂讨论，那么总的方案就是乘积。

考虑枚举有 $i$ 个竖着的，其中有 $j$ 段的方案就是三种情况的和乘上竖着的方案。

```cpp#include<bits/stdc++.h>
#define fep(i,l,r) for(int i=l;i<=r;++i)
#define feb(i,r,l) for(int i=r;i>=l;--i)
#define For(i,u) for(int i=head[u];i;i=e[i].nxt)
#define pr pair<int,int>
#define mpr make_pair
#define LL long long
//#define int long long
using namespace std;

const int N = 4e7+5,M = 5e3+5,mod = 998244353;
int n,m,inv[N],fac[N],ifac[N],f[M];

inline int read()
{
	int s=0,w=1; char ch=getchar();
	while(!(ch<='9'&&ch>='0')) {if(ch=='-') w=-1; ch=getchar();}
	while(  ch<='9'&&ch>='0')  {s=(s<<1)+(s<<3)+ch-'0'; ch=getchar();}
	return s*w;
}
inline int Mod(int x) {return x>=mod?x-mod:x;}
inline void addmod(int &x,int y) {y<0?y+=mod:y=y; x=Mod(x+y);}

inline void init()
{
	inv[1]=fac[0]=ifac[0]=1;
	fep(i,1,2*n)
	{
		if(i^1) inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
		fac[i]=1ll*fac[i-1]*i%mod;
		ifac[i]=1ll*ifac[i-1]*inv[i]%mod;
	}
}

inline int C(int x,int y)
{
	if(x<y) return 0;
	return 1ll*fac[x]*ifac[y]%mod*ifac[x-y]%mod;
}

signed main()
{
	n=read(),m=read();
	init();
	int ans=C(2*(n-1),m-2);
	fep(i,1,m)
	{
		fep(j,1,i)
		{
			int tmp=j+1;
			if(tmp*2+i<=m)
			{
				int now1=n-1-i-j,now2=m-(tmp*2+i);
				int res=1ll*C(i-1,j-1)*C(n-i-1,j)%mod*C(2*now1,now2)%mod;
				addmod(ans,res);
			}
			tmp=j;
			if(tmp*2+i<=m)
			{
				int now1=n-i-j,now2=m-(tmp*2+i);
				int res=2ll*C(i-1,j-1)*C(n-i-1,j-1)%mod*C(2*now1,now2)%mod;
				addmod(ans,res);
			}
			tmp=j-1;
			if(tmp*2+i<=m&&j>=2)
			{
				int now1=n+1-i-j,now2=m-(tmp*2+i);
				int res=1ll*C(i-1,j-1)*C(n-i-1,j-2)%mod*C(2*now1,now2)%mod;
				addmod(ans,res);
			}
		}
	}
	printf("%d\n",ans+(n==m));
	return 0;
}
```

---

## 作者：irris (赞：12)

写给 whk 老师看的，大家看个乐呵。

![](https://cdn.luogu.com.cn/upload/image_hosting/1sqyqg9c.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/mu1wsufs.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/e0f71hir.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/snil7mv9.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/egx792u2.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/gx9pwb0s.png)

---

## 作者：Gorenstein (赞：5)

（前一次 LaTeX 炸了，故重交。）

考虑使用 $i$ 个竖条对长度为 $n$ 的长条进行划分，并且划分为了 $j$ 段。该问题相当于将 $i$ 个竖条放到 $j+1$ 个空位中，每一种竖条的放置都将 $n-i$ 个格子划分为 $j$ 个集合，因之方案数为：

$$
\binom{j+1}{i}\binom{n-i-1}{j-1}
$$

考虑现在对于一种划分的某一段。设其长度为 $M$，我们考虑第一排，枚举第一排放的长条数 $N$。

那么我们就要求出用 $N$ 个长条排满 $M$ 长度的方案数，这个东西就是一个 $M$ 元素的不可区分集合到 $N$ 元素的可区分集合的满射，就是 $\binom{M-1}{N-1}$。

考虑这个东西的 GF，可以得到其为 $\left[z^{N-1}\right](z+1)^{M-1}$。那么一个对于 $2\times M$ 的用 $x$ 个长方形覆盖的方案数就是 $\sum\limits_{N=1}^{x-1}\binom{M-1}{N-1}\binom{M-1}{x-N-1}=\sum\limits_{N=0}^{x-2}\binom{M-1}{N}\binom{M-1}{x-2-N}=\left[z^{x-2}\right]\left((z+1)^{M-1}\right)^2$。

然后对于一个 $j$ 拆分的方案，除去用竖线切割之外的剩余长度为 $L=n-i$，每一段长度为 $a_1,\dots,a_j$，其中 $\sum_{\jmath} a_{\jmath}=L$，并设每一段的长条个数为 $x_1,\dots,x_j$，有计数：

$$
\sum_{x_1+\dots+x_j=k-i}\prod_{\jmath}\left[z^{x_{\jmath}-2}\right](z+1)^{2a_{\jmath}-2}
$$

是一个多元卷积，即 $(z+1)^{\sum_{\jmath} (2a_{\jmath}-2)}$ 的 $z^{\sum_{\jmath}(x_{\jmath}-2)}$ 项系数的展开形式，即 $\left[z^{k-i-2j}\right](z+1)^{2n-2i-2j}$。

从而枚举 $i,j$，对于每一个 $i,j$，方案数都是上述两部分的结果之积，直接求和即可。注意当 $n=k$ 时，$i$ 可以为 $k$，而 $\binom{-1}{-1}$ 是没有定义的，故当 $n=k$ 时应当加上 $1$。

---

## 作者：nullqtr_pwp (赞：4)

# 「KDOI-02」一个仇的复


**【形式化题意】**

你有 $1\times x$（$x$ 为任意正整数）的矩形各无穷多个和一个 $2\times n$ 的网格，请求出恰好选择其中 $k$ 个矩形（可以选择相同的矩形）**不重不漏**地铺满整个网格的方案数。矩形可以旋转。

$n\leq 2\times 10^7,k\leq 5000$

**【解答】**

评价：一道很不错的组合计数题，要运用许多技巧才能解决。

因为 $k\leq 5000$，所以我们可以尝试用 $O(k^2)$ 的算法来解决这个问题。

首先确定我们要计算什么，定义状态是**在有 $i$ 个 $1\times 2$ 的长方形竖着的，且将整个长条分成了 $j$ 段的情况下的种类数。**（并且，我们强制要求这 $j$ 段中的每一段都是由横着的长方形填充的）

![114514](https://cdn.luogu.com.cn/upload/image_hosting/f0owns1t.png)

感性理解一下，这个是 $i=3,j=3$ 的其中一种情况。而这些 $2\times2, 1\times 2,4\times 2$ 的子矩阵都应该由横着的长方形来填充。


计算出这个子问题的答案，我们要分步解决。

**问题一、这 $i$ 个 $1\times2$ 的竖着的长方形怎么放（确定这 $i$ 个竖着的位置）**

我们使用**插空法。** 设当前已经放好了这 $i$ 个竖着的长方形，那么就是这 $j$ 个段去选 $i+1$ 个空（两端的空是允许使用的），所以这个问题就迎刃而解了。

那么显然是 $\begin{pmatrix}
 i+1\\
j
\end{pmatrix}$ 种。（$i+1\ge j$）


**问题二、这 $j$ 段的每一段怎么分配，也就是说每一段有多少列。**

我们使用 **插板法。** 现在剩下了 $n-i$ 列没有分配（$n$ 列减去已经使用的竖着的 $i$ 个），要分给 $j$ 段，每一段不能为空。那么它就是有 $n-i-1$ 个空，要插入 $j-1$ 个板子。（因为不能为空，所以两端的空不能使用。）

那么就是 $\begin{pmatrix}
 n-i-1\\
j-1
\end{pmatrix}$ 种。（$n-i\ge j$）

**问题三、这 $j$ 段的内部怎么分配**

引理：对于一个 $2\times n$ 的长方形，若有 $x$ 个 $1\times l$ 的长方形来填充，并且**不允许竖着放**，则有 $\begin{pmatrix}
 2n-2\\
x-2
\end{pmatrix}$ 种。

对于这个引理的解释：显然我们也可以用**插板法**。你可以看成 $1\times (2\times n)$ 的长方形，因为他分成了两列，所以我们可以认为正中间的那个空天然地就放了一块板子。

于是，还**剩下 $2n-2$ 个空，还有 $x-2$ 块板子要放**（原有 $2n-1$ 个空与  $x-1$ 个板子，两个都确定了一个中间的）。

回到问题三原本的问题，我们不能一个一个地去考虑，要整体去考虑。（其实这就是[范德蒙德卷积](https://zhuanlan.zhihu.com/p/552934763)的思想。）

一共有 $j$ 个段，设第 $p$ 段要有 $c_p$ 个横着的长方形来填充，其为 $2\times d_p$ 的长方形，那么答案就是：

$\sum_{c,d}^{}\prod_{p=1}^{j}\begin{pmatrix}
 2d_l-2\\
c_l-2
\end{pmatrix}  $

这样来求时间复杂度直接就爆了。但是我们要运用**整体的思想。** 一共有 $\sum (2c_p-2)$ 个空，一共要插入 $\sum (d_p-2)$ 块板子。答案就是
$\begin{pmatrix}
 \sum (2c_p-2)\\
\sum (d_p-2)
\end{pmatrix}$ 

显然我们可以直接化简 $\sum (2c_p-2)$ 和 $\sum (d_p-2)$，其分别为 $2n-2i-2j$ 和 $k-i-2j$。（$k$ 就是原题面里的，$i$ 表示用了 $i$ 个 $1\times 2$ 的竖着的）

于是问题三的答案就是 $\begin{pmatrix}
2n-2i-2j\\
k-i-2j
\end{pmatrix}$。实际上，这些在做的是在运用[范德蒙德卷积](https://zhuanlan.zhihu.com/p/552934763)。

对于范德蒙德卷积，这里就不做解释了。

**【统计答案】**

有了问题一，二，三的计算公式，我们可以直接推导出在有 $i$ 个 $1\times 2$ 的长方形竖着的，且将整个长条分成了 $j$ 段的情况下的种类数，就是三个问题的公式相乘。

给定 $i,j$，其种类数为 $\begin{pmatrix}
2n-2i-2j\\
k-i-2j
\end{pmatrix}\begin{pmatrix}
 n-i-1\\
j-1
\end{pmatrix}\begin{pmatrix}
 i+1\\
j
\end{pmatrix}$。

直接去枚举 $i$ 和 $j$ 就可以了，因此，所有的答案是：

$\sum_{i=0}^{k}\sum_{j=0}^{k}\begin{pmatrix}
2n-2i-2j\\
k-i-2j
\end{pmatrix}\begin{pmatrix}
 n-i-1\\
j-1
\end{pmatrix}\begin{pmatrix}
 i+1\\
j
\end{pmatrix}$。


**【代码细节】**

由于 $n\leq 2\times 10^7$，所以要线性预处理逆元。这样可以 $O(1)$ 求组合数。

这题卡空间，阶乘和逆元数组不要用 ```long long```。

具体代码就不贴了，不难。

---

## 作者：飞雨烟雁 (赞：3)

原题链接：[P8594 「KDOI-02」一个仇的复](https://www.luogu.com.cn/problem/P8594)。

关于这道题 GF 的代数推导，可以看 NaCly_Fish 的[这篇 blog](https://www.luogu.com.cn/article/95toziix)。本题解主要提供两种「提取多元有理分式的系数」的方法。

根据链接里的推导可知，答案等于：

$$[x^ny^k]\dfrac{1-x-2xy}{1-x(1+3y+y^2)+x^2(y+2y^2)}$$

下面介绍两种系数提取的方法。

------------

### 法一：矩阵快速幂

我们设：

$$\dfrac{1-x-2xy}{1-x(1+3y+y^2)+x^2(y+2y^2)}=\sum_{n=0}^\infty F_n(y)x^n$$

则有如下递推式：

$$F_n=\begin{cases}1&n=0\\
y^2+y&n=1\\
(1+3y+y^2)F_{n-1}-(y+2y^2)F_{n-2}&n\ge 2\end{cases}$$

可以写出如下矩阵形式：

$$\begin{bmatrix}F_{n+1}\\ F_{n}\end{bmatrix}=\begin{bmatrix}1+3y+y^2&-(y+2y^2)\\ 1&0\end{bmatrix}\begin{bmatrix}F_n\\ F_{n-1}\end{bmatrix}$$

我们想要计算的是 $[y^k]F_n(y)$，则需求：

$$\begin{bmatrix}F_{n}\\ F_{n-1}\end{bmatrix}=\begin{bmatrix}1+3y+y^2&-(y+2y^2)\\ 1&0\end{bmatrix}^{n-1}\begin{bmatrix}y^2+y\\1\end{bmatrix}$$

由于我们最后想要的是 $F_n$，而不是 $F_{n-1}$，所以快速幂时只需维护 $6$ 个多项式。

在进行矩阵乘法时，会出现某个多项式的最高次数大于 $k$。因为高于 $k$ 次的部分对答案没有影响，所以可以舍去。总时间复杂度为 $\Theta(k\log k\log n)$。

代码如下：

```cpp
Poly F1, F2, F5, F6, F7, F8;
int MatrixFastPow(int n, int k){
	F1.F[0] = 1, F7.F[0] = 1, --n;
	F5.F[0] = 1, F5.F[1] = 3, F5.F[2] = 1;
	F6.F[0] = 0, F6.F[1] = -1, F6.F[2] = -2;
	int Len = 4;
	while(Len <= k) Len <<= 1;
	Len <<= 1;
	while(n){
		F5.DFT(Len), F6.DFT(Len), F7.DFT(Len), F8.DFT(Len);
		if(n & 1){
			F1.DFT(Len), F2.DFT(Len);
			for(int i = 0; i < Len; ++i){
				int tmp = F1.F[i];
				F1.F[i] = (1ll * tmp * F5.F[i] + 1ll * F2.F[i] * F7.F[i]) % Mod;
				F2.F[i] = (1ll * tmp * F6.F[i] + 1ll * F2.F[i] * F8.F[i]) % Mod;
			}
			F1.IDFT(Len), F2.IDFT(Len);
			for(int i = k + 1; i < Len; ++i) F1.F[i] = F2.F[i] = 0;
		}
		for(int i = 0; i < Len; ++i){
			int tmp1 = F5.F[i], tmp2 = F8.F[i];
			F5.F[i] = (1ll * F5.F[i] * F5.F[i] + 1ll * F6.F[i] * F7.F[i]) % Mod;
			F8.F[i] = (1ll * F6.F[i] * F7.F[i] + 1ll * F8.F[i] * F8.F[i]) % Mod;
			F6.F[i] = 1ll * F6.F[i] * (tmp1 + tmp2) % Mod;
			F7.F[i] = 1ll * F7.F[i] * (tmp1 + tmp2) % Mod;
		}
		F5.IDFT(Len), F6.IDFT(Len), F7.IDFT(Len), F8.IDFT(Len);
		for(int i = k + 1; i < Len; ++i) F5.F[i] = F6.F[i] = F7.F[i] = F8.F[i] = 0;
		n >>= 1;
	}
	int Ans = F2.F[k];
	if(k > 0) Ans = (Ans + F1.F[k - 1]) % Mod;
	if(k > 1) Ans = (Ans + F1.F[k - 2]) % Mod;
	return Ans < 0 ? Ans + Mod : Ans;
}
```
------------

### 法二：Bostan-Mori 算法

noshi91 关于多项式复合的[新算法](https://noshi91.hatenablog.com/entry/2024/03/16/224034)启发我们将 Bostan-Mori 算法应用到多元情况下。我们希望计算：

$$[x^ny^k]\dfrac{P_0(x,y)}{Q_0(x,y)}$$

其中 $k$ 是个比较小的值。我们对 $x$ 用 Bostan-Mori 算法：

$$\begin{aligned}[x^ny^k]\dfrac{P(x,y)}{Q(x,y)}
&=[x^ny^k]\dfrac{P(x,y)Q(-x,y)}{Q(x,y)Q(-x,y)}\\
&=[x^ny^k]\dfrac{R_0(x^2,y)+xR_1(x^2,y)}{Q'(x^2,y)}\\
&=[x^{\lfloor n/2\rfloor}y^k]\dfrac{R_{n\!\bmod\! 2}(x,y)}{Q'(x,y)}\\
\end{aligned}$$

递归至 $n=0$ 后，对分母做多项式求逆，乘起来即可。

整个过程中，$P,Q$ 中 $x$ 的最高次数基本保持不变，可视为常数。而 $P,Q$ 中 $y$ 的最高次数虽然会在每次迭代中倍增，但超过 $k$ 次的同样对答案没有影响，可以舍去。综上，该算法的总时间复杂度仍为 $\Theta(k\log k\log n)$。

具体到这道题，因为 $[x^0]Q_0=1$，所以最后无需多项式求逆。此外，$P,Q$ 中 $x$ 的最高次数很低，我们没有必要真的上二维 FFT，可以参考  [OI Wiki](https://oi-wiki.org/math/number-theory/quad-residue/#bostanmori-%E7%AE%97%E6%B3%95) 这里的式子，分别维护 $x$ 不同次数下关于 $y$ 的多项式即可。

代码如下：


```cpp
Poly F0, F1, F2, F3;
Poly BM;
int BostanMori(int n, int k){
	F0.F[0] = 1, F1.F[0] = -1, F1.F[1] = -2;
	F2.F[0] = -1, F2.F[1] = -3, F2.F[2] = -1;
	F3.F[0] = 0, F3.F[1] = 1, F3.F[2] = 2;
	int Len = 4;
	while(Len <= k) Len <<= 1;
	Len <<= 1;
	while(n){
		F2.DFT(Len), F3.DFT(Len);
		if(n & 1){
			F0.DFT(Len), F1.DFT(Len);
			for(int i = 0; i < Len; ++i){
				F0.F[i] = (F1.F[i] - 1ll * F0.F[i] * F2.F[i]) % Mod;
				F1.F[i] = 1ll * F1.F[i] * F3.F[i] % Mod;
			}
			F0.IDFT(Len), F1.IDFT(Len);
			for(int i = k + 1; i < Len; ++i) F0.F[i] = F1.F[i] = 0;
		}
		else{
			for(int i = 0; i < Len; ++i) BM.F[i] = F0.F[i];
			BM.DFT(Len), F1.DFT(Len);
			for(int i = 0; i < Len; ++i) F1.F[i] = (1ll * BM.F[i] * F3.F[i] - 1ll * F1.F[i] * F2.F[i]) % Mod;
			F1.IDFT(Len);
			for(int i = k + 1; i < Len; ++i) F1.F[i] = 0;
		}
		for(int i = 0; i < Len; ++i){
			F2.F[i] = (2 * F3.F[i] - 1ll * F2.F[i] * F2.F[i]) % Mod;
			F3.F[i] = 1ll * F3.F[i] * F3.F[i] % Mod;
		}
		F2.IDFT(Len), F3.IDFT(Len);
		for(int i = k + 1; i < Len; ++i) F2.F[i] = F3.F[i] = 0;
		n >>= 1;
	}
	return F0.F[k] < 0 ? F0.F[k] + Mod : F0.F[k];
}
```




------------

### Remark

1. 这两种方法都可以在单次内求出 $[x^ny^i],i=0,1,\cdots ,k$ 的系数；

2. 法二维护的多项式个数更少，所以常数也更小，更推荐法二；

3. 法二可以很轻松地推广到多元情况，即提取 $[x_0^nx_1^{k_1}\cdots x_m^{k_m}]$ 的系数，且保证 $k_1,k_2,\cdots, k_m$ 较小；


4. 这两种方法都必须要求 $k$ 的值较小，那是否有一种算法可以摆脱这种限制呢？

---

## 作者：NaCly_Fish (赞：2)

[题目链接](https://www.luogu.com.cn/problem/P8594)

这题怎么能没有 GF 大力推导 + 整式递推的做法呢？马上安排！
****
设 $f_{n,m}$ 是用 $m$ 个**横着的**矩形铺满 $2\times n$ 网格的方案数，并设其二元生成函数为 $F$。
枚举用到多少个竖着的 $2\times 1$ 矩形，就能得到实际答案的生成函数为（答案是 $[x^ny^k]G$）：

$$G=\sum_{i\geq 0} x^iy^i F^{i+1}=\frac{F}{1-xy F}$$
枚举上下两行分别用了多少个矩形，就能计算 $f_{n,m}$:

$$\begin{aligned}f_{n,m}&=\sum_{i=0}^m\left( [x^n] \left(\frac{x}{1-x}\right)^i\right)\left( [x^n]\left( \frac{x}{1-x}\right)^{m-i}\right) \\ &= \sum_{i=0}^m \binom{n-1}{i-1}\binom{n-1}{m-i-1}  \end{aligned}$$
然后得到其生成函数：
$$\begin{aligned}F&=\sum_{n=0}^\infty\sum_{m=0}^\infty x^ny^m f_{n,m} \\ &=\sum_{i=0}^\infty\sum_{n=0}^\infty \binom{n-1}{i-1}x^n \sum_{m=i}^\infty y^m \binom{n-1}{m-i-1} \\ &= \sum_{i=0}^\infty\sum_{n=0}^\infty \binom{n-1}{i-1}x^ny^i \sum_{m=0}^\infty y^m\binom{n-1}{m-1}\end{aligned}$$
注意最内层和式在 $n=0$ 时为 $1$，其余情况为 $y(1+y)^{n-1}$，即：

$$\begin{aligned}F&=\sum_{i=0}^\infty y^i\left( \binom{-1}{i-1}+\sum_{n=1}^\infty \binom{n-1}{i-1}x^ny(1+y)^{n-1}\right) \\ &=1+\sum_{i=0}^\infty y^{i+2}\sum_{n=0}^\infty\binom{n}{i}x^{n+1}(1+y)^n \\ &=1+\sum_{n=0}^\infty x^{n+1}(1+y)^ny^2(1+y)^n \\&=1+\frac{xy^2}{1-x(1+y)^2}\end{aligned}$$
由此可见，$F$ 是一个二元有理分式，$G$ 也是一样的。故其任意一条斜线上的值都微分有限，计算答案可以做到 $\Theta(k)$ 或 $\Theta(\sqrt k \log k)$ 的时间复杂度。

下面稍微展开说一下 $G$ 的处理方法。
****

先带入展开一下：
$$G= \frac{1-x-2xy}{1-x(1+3y+y^2)+x^2(y+2y^2)}$$
这个形式真是漂亮滴很啊！

我们要提取其 $[x^ny^k]$ 系数。设 $A_n=[x^n]G$，则 $A_n$ 可以表示为一个简单的二阶递推
$$A_n=(1+3y+y^2)A_{n-1}-(y+2y^2)A_{n-2}$$
这个是可以~~机械化~~处理的 —— 解特征方程、化简出 $A_n$ 的封闭形式、计算 $u^n$（$u$ 为特征根）的 ODE 即可。由于只用求一项系数，并不需要求出完整的 $A_n$ 的 ODE，处理起来会简单一些。

好吧，其实并不是很能机械化。由于递推式的一些奇妙性质，我们需要做一些特殊处理。设特征方程
$$u^2-(1+3y+y^2)u+(y+2y)=0$$
的解分别为 $u_1,u_2$，其中 $u_1$ 的常数项为零，可以算出
$$A_n=\frac 12(u_1^n+u_2^n)+\frac{1+y-y^2}{2\sqrt{1+2y+3y^2+6y^3+y^4}}(u_1^n-u_2^n)$$

经过一些计算可知，对于
$$c_0=2n(n-1)+2n(4n-5)y+7n(n-5)y^2-3n(25+3n)y^3 \\ -5n(7n+13)y^4-2n(14+29n)y^5-20n(1+2n)y^6$$

$$c_1=(1-n)+7(1-n)y+(22-14n)y^2+(53-7n)y^3+(80+14n)y^4 \\ +(33+69n)y^5+(143n-39)y^6+4(28n-9)y^7+8(2n-1)y^8$$

$$c_2=y+5y^2+8y^3+3y^4-12y^5-49y^6-85y^7-58y^8-8y^9$$
是满足 $c_0 (u^n)+c_1(u^n)'+c_2(u^n)''=0$ 的一组解。

到目前为止还没什么问题：$u_1^n$ 的系数很好求，容易知道 $[y^n]u_1^n=1$ 然后从这项开始递推即可。对于 $u_2$ 就出问题了，把 ODE 转化到整式递推就会发现，算 $[y^n]u_2^n$ 这一项时会出现**除以零的问题**。也就是说这一项我们得单独计算：

$$[y^n]u_2^n=[x^n]\left( \frac{1+3x+x^2+\sqrt{1+2x+3x^2+6x^3+x^4}}{2}\right)^n$$
这个用 Lagrange 反演处理一下就行，设
$$F(x)=\frac{1-3x+2x^2-\sqrt{1-6x+9x^2-8x^3+4x^4}}{2x} $$
得到 $[y^n]u_2^n=[x^n] xF'(x)/F(x)$，可以分别求出 $F'(x)$ 和 $x/F(x)$ 的系数然后算卷积的第 $n$ 项。  
补上了 $[y^n]u_2^n$ 之后继续用原来的递推式算后面的项即可。

由于这个问题仅会在 $k\geq n$ 的时候遇到，要多进行总共 $\Theta(n)$ 复杂度的计算，所以时间复杂度还是 $\Theta(k)$ 的。

现在得到了 $u_1^n$ 和 $u_2^n$ 的系数，再递推出 $(1+2y+3y^2+6y^3+y^4)^{-1/2}$ 的前 $k$ 项，就能直接提取 $[y^k]A_n$，也就是答案了。

[AC 代码提交记录](https://www.luogu.com.cn/record/145393847)

---

## 作者：spire001 (赞：1)

## P8594 题解

### 题目分析
想说一下我的思考历程。

先考虑 $2\times n$ 的矩形只使用水平的矩形去填，有多少种方案。

对于上面的矩形，考虑一个生成函数 $f$，$f(x)=\sum\limits_{i=0}^\infty h_i x^i$，其中 $h_i$ 表示用 $i$ 种颜色的方案数。

对于每一步，有两种选择，第一种是换一个颜色，另一种是保持上一个颜色，最开始必然有一种颜色，那么：
$$
f(x)=x(x+1)^{n-1}
$$

由于下面的结构相同，所以上下矩形的生成函数相同，两种使用颜色数加起来为 $k$ 那么答案就是两生成函数的卷积的对应 $x^k$ 项系数就是：
$$
[x^k]x^2(x+1)^{2n-2}=C_{2n-2}^{k-2}
$$

然而我推这个式子的过程中发现了动态规划方法。。。
于是果断没有接着上面的做法而是选择了递推。

我们可以设置这么个状态，$f_{i,j}$ 表示推了 $i$ 列，用了 $j$ 种颜色，但有一个前提就是第 $i$ 列上下颜色相同，$g_{i,j}$ 表示推了 $i$ 列，用了 $j$ 种颜色，这里第 $i$ 列上下颜色不相同。

为了表述简洁，我称 $f$ 状态为最后一个已知矩形为竖直矩形状态。

我们必须明白为什么需要设计 $f$，因为在放竖直矩形的时候我们不能以他为基础使用它的颜色继续这个矩形，考虑了 $f$ 以后，我们的 $g$ 就可以用最上面的考虑方式来递推了。

### 状态转移

首先我们状态转移到 $f_{i,j}$ 很简单，无论什么情况只多了一种颜色，即：
$$
f_{i,j}=f_{i-1,j-1}+g_{i-1,j-1}
$$
然后我们转移到 $g_{i,j}$ 就有几种可能，如果从 $f$ 转移过来那么只能上下同时向右扩展（指用一种新的颜色结束当前的矩形），种数多了 $2$。否则上下可以选择拓展或不拓展。

那么：
$$
g_{i,j}=f_{i-1,j-2}+g_{i-1,j}+2g_{i-1,j-1}+g_{i-1,j-2}
$$

最终答案为 $f_{n,k}+g_{n,k}$。

我们发现把上面推 $f$ 的式子带入到 $g$ 的式子里。

我们得到：
$$
f_{i,j}=(f_{i-1,j}+3f_{i-1,j-1}+f_{i-1,j-2})-(f_{i-2,j-1}+2f_{i-2,j-2})。
$$

最终答案变为 $f_{n+1,k+1}$。

复杂度情况并不乐观，我们需要继续研究 $f$ 的性质。

对于这种常系数的递推关系，我们可以考虑一个母函数。

对于一个多项式序列，我们通过递推关系得到母函数的关系。

设 $F(k,x)=\sum\limits_{i=0}^\infty f_{k,i}x^i$。

则有：
$$
F_n=(x^2+3x+1)F_{n-1}-(2x^2+x)F_{n-2}
$$

我们认为 $f_{k,0}=0$ 所以式子中不存在其它常数。

我们怀疑这么做会不会更简单，带入特征方程（以 $y$ 主元）：
$$
y^2-(x^2+3x+1)y+(2x^2+x)=0
$$

$$
\Delta=(x^2+3x+1)^2-4(2x^2+x)=x^4+6x^3+3x^2+2x+1
$$

这个判别式是既约的。。。  
也就是说这么做难以得出结果。。。

可以转变思路，考虑矩阵加速递推（其实也是套路了。。。），我们很容易就构造：
$$
\begin{bmatrix}
  F_n&F_{n-1} \\
  0&0
\end{bmatrix}=
\begin{bmatrix}
  F_{n-1}&F_{n-2} \\
  0&0
\end{bmatrix}
\begin{bmatrix}
  (x^2+3x+1)&1 \\
  -(2x^2+x)&0
\end{bmatrix}
$$

知道 $F_0=1$（注意下标从零开始那么答案为 $f_{n,k}$）以及 $F_1=x^2+x$ 就可以做了。

结果就是 $[x^k]F_n$。

复杂度是 $O(k^2\log_2 n)$ 还是 $O(k\log_2 k\log_2 n)$ 在于你会不会多项式模板区的一些东西。。。

然后就没有然后了。。。

代码由于板子太长，只放关键部分。。。


### 代码
```cpp
struct matrix {
  EXTRA::poly<LL, EXTRA::NTT_multi<>> m[2][2]; // 

  matrix operator*(const matrix &Q) const // 矩阵快速幂
  {
    matrix res;

    for (int i = 0; i != 2; i++)
      for (int j = 0; j != 2; j++)
        for (int p = 0; p != 2; p++)
          res.m[i][j] += m[i][p] * Q.m[p][j];
  
    return res;
  }
};
int main()
{
  cin >> n >> k;

  if (k > n * 2)
    return cout << 0 << endl, 0;
  else if (k == n * 2) // 记得特判
    return cout << 1 << endl, 0;

  // vector<vector<LL>> f;
  // f.resize(n + 2);
  // g.resize(n + 1);

  // for (int i = 0; i <= n + 1; i++)
  // {
  //   f[i].resize(k + 2);
  //   // g[i].resize(k + 1);
  // }

  // f[1][1] = 1; f[0][0] = 1;

  // for (int i = 2; i <= n + 1; i++)
  //   for (int j = 2; j <= k + 1; j++)
  //     f[i][j] = (f[i - 1][j] + f[i - 1][j - 1] * 3 + f[i - 1][j - 2] - f[i - 2][j - 1] - f[i - 2][j - 2] * 2) % mod;

  // cout << (f[n + 1][k + 1] + mod) % mod << endl;
  
  matrix res, ans;
  
  // 初始化

  res.m[0][0] = { 1ll, 3ll, 1ll };
  res.m[1][0] = { -2ll, -1ll, 0ll };
  res.m[0][1] = { 1ll };

  ans.m[0][0] = { 1ll, 1ll, 0ll };
  ans.m[0][1] = { 1ll };
  
  n--;
  
  while (n) // 矩阵快速幂
  {
    if (n & 1) ans = ans * res;
    n >>= 1;
    res = res * res;
  }

  cout << ans.m[0][0].get(k) << endl; // 输出答案

  return 0;
}
```

---

## 作者：yuanruiqi (赞：1)

这是一个纯组合意义解法。

考虑已经插入了一些 $1\times2$ 的竖长方形，然后方案数就只和未放置的列数 $x$，空列组成的连通块数 $y$ 有关。

每个空连通块至少需要再填两个长方形，不妨假设它们已经放置，接下来还需要添加 $k-(n-x)-2y$ 个长方形。添加长方形，相当于将一个横长方形切一刀，能切的位置有 $2(x-y)$ 个。那么增加长方形的方案数就是 $\binom{2(x-y)}{k-(n-x)-2y}$，整理得 $\binom{2x-2y}{x-k+n}$。

将 $x$ 列拆成 $y$ 个块的方案数，插板法得到 $\binom{x-1}{y-1}$。

将 $y$ 个块放回到原矩形中的方案数，观察到原矩形有 $y$ 个块和 $n-x$ 个竖长方形共 $n-x+y$ 个位置，需要放 $y$ 个块且不允许块与块相邻。不妨考虑先任意布置 $y$ 个位置 $a_1,a_2,\cdots,a_y$，最终放回到 $a_1,a_2+1,\cdots,a_y+y-1$ 便满足条件。也就是 $\binom{n-x+y-(y-1)}{y}$，整理得 $\binom{n-x+1}{y}$。

$O(n^2)$ 枚举 $(x,y)$ 即可获得部分分。

注意到第一个组合数若不取零则需要满足 $2x-2y\ge x-k+n$，即 $2y\le x+k-n$，题目中的 $k$ 很小，可以直接枚举有贡献的 $(x,y)$。

方案数：

$$\sum_{x=1}^{n}\sum_{y=1}^{\min(x,\lfloor\frac{x+k-n}{2}\rfloor)}\binom{2x-2y}{x-k+n}\binom{n-x+1}{y}\binom{x-1}{y-1}$$

注意 $k=n$ 时算上全部放竖长方形的 $1$ 个方案。

---

## 作者：james1BadCreeper (赞：1)

先解决一个简单问题，只允许横着放？插板，枚举第 $1$ 行用 $i$ 个，那么总方案数为 $\displaystyle \sum_{i=1}^{a-1}\binom{b-1}{i-1}\binom{b-1}{a-i-1}=\sum_{i=0}^{a-2}\binom{b-1}{i}\binom{b-1}{a-2-i}$，用范德蒙德卷积合并可得答案是 $\dbinom{2b-2}{a-2}$。

由于宽度为 $2$，竖着的长方形仅能有 $1\times 2$。考虑先用 $j$ 个 $1\times 2$ 的竖着的长方形，然后分割成了 $2\times a_l$ 的小长方形，独立统计即可。

设要分成 $i$ 段，使用 $j$ 个竖着的，那么分段方式插板计算有 $\dbinom{j+1}{i}$ 种（只有两头允许放空，增加 $1$ 个板），然后要将剩余的 $n-j$ 个位置分给 $i$ 段，插板有 $\dbinom{n-j-1}{i-1}$ 种方案。

然后就是把 $k-j$ 个横着的放到每段长度为 $a_l$ 的每段中，方案数：

$$
\sum_{\sum\limits_{l=1}^i b_l\ =\ k-j}\prod_{l=1}^{i}\binom{2a_l-2}{b_l-2}
$$

这是个什么？想一想范德蒙德卷积的组合意义，就会发现跟那个是一样的：枚举每个子集选的个数，选的总数是 $k-j-2i$。于是我们将它合起来（就是原本二项式系数上面的和下面的和形成新的二项式系数），就成了：$\dbinom{\sum 2a_l-2}{\sum b_l-2}=\dbinom{2(n-j)-2i}{k-j-2i}$。

注意一下需要特判 $k=n$ 的时候，可以放 $k$ 个竖着的。

注意按照组合数上下的取值给循环上下界卡死。


```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>

using namespace std;
const int MOD = 998244353;

inline int poww(int a, int b) {
    int res = 1;
    for (; b; b >>= 1, a = 1ll * a * a % MOD)
        if (b & 1) res = 1ll * res * a % MOD;
    return res;
}

int n, k;
int fac[40000005];

int C(int n, int m) {
    return 1ll * fac[n] * poww(1ll * fac[m] * fac[n - m] % MOD, MOD - 2) % MOD;
}

int main(void) {
    scanf("%d%d", &n, &k); fac[0] = 1;
    for (int i = 1; i <= n * 2; ++i) fac[i] = 1ll * fac[i - 1] * i % MOD;
    int ans = 0;
    for (int i = 1; i <= k; ++i) {
        int R = min({k - 2 * i, n - i, 2 * n - k});
        for (int j = i - 1; j <= R; ++j) {
            int a = C(2 * (n - j) - 2 * i, k - j - 2 * i);
            int b = C(j + 1, i), c = C(n - j - 1, i - 1);
            ans = (ans + 1ll * a * b % MOD * c % MOD) % MOD;
        }
    }
    printf("%lld\n", ans + (k == n));
    return 0;
}

```
{% endfolding %}

---

## 作者：Autream (赞：0)

## 题意简述
你有 $1\times x$（$x$ 为任意正整数）的矩形各无穷多个和一个 $2\times n$ 的网格，请求出恰好选择其中 $k$ 个矩形（可以选择相同的矩形）**不重不漏**地铺满整个网格的方案数。矩形可以旋转。
## 题目分析
计数好题！

容易发现一个性质：只有大小为 $1 \times 2$ 的长方形竖着放对答案有影响。

先考虑如果没有竖着放的长方形怎么做。

显而易见地，可以使用插板法，将大长方形的两排拼成一排，两排的交界处必须分开（插一块板子），于是变成了将 $k - 2$ 块板插入 $2n - 2$ 个空，方案数为 $\begin{pmatrix} 2n - 2 \\ k - 2 \end{pmatrix} \ (*)$。
对于竖着放的长方形，假设使用了 $i$ 个，将 $2 \times n$ 的长方形分成了 $j$ 部分（竖着的长方形所在的地方不算做一部分）。

**$i$ 个竖着的长方形的放法：**

使用插板法，将分成的 $j$ 段想成 $j$ 块板子，每个竖着的长方形的左右都可以插一板，一共有 $i + 1$ 个空，$j$ 块板，方案数为 $\begin{pmatrix} i + 1 \\ j \end{pmatrix}$。

**$j$ 段中每段分配个数的方案：**

此时还剩下 $n - i$ 列，这些列分配给 $j$ 段，同样使用插板法，相当于 $n - i - 1$ 个空，插 $j - 1$ 块板子，方案数为 $\begin{pmatrix} n - i - 1 \\ j - 1 \end{pmatrix}$。

将网格分为 $j$ 段后，设第 $l$ 段有 $s_l$ 列，使用了 $c_l$ 个长方形，则由 $(*)$ 式可得这一种分法（$i$ 个竖着的，$j$ 段）的方案数为：

$$
\sum _{所有可能的 s, c }\prod _{l = 1} ^ j \begin{pmatrix} 2s_l - 2 \\ c_l - 2 \end{pmatrix}
$$

~~查阅 OI Wiki 可以~~发现，此式子可以用范德蒙德卷积的思想化简（以下摘自 [OI Wiki](https://oi-wiki.org/math/combinatorics/vandermonde-convolution/)）：
> 范德蒙德卷积公式：
> $$
>	\sum _{i = 0} ^k \begin{pmatrix} n \\ i \end{pmatrix}\begin{pmatrix} m \\ k - i \end{pmatrix} = \begin{pmatrix} n + m \\ k \end{pmatrix}
> $$
> 若考虑其组合意义证明：
> 
> 在一个大小为 $n+m$ 的集合中取出 $k$ 个数，可以等于把大小为 $n+m$ 的集合拆成两个集合，大小分别为 $n$ 与 $m$，然后从 $n$ 中取出 $i$ 个数，从 $m$ 中取出 $k-i$ 个数的方案数。由于我们有了对于 $i$ 的枚举，于是只需要考虑一种拆法，因为不同的拆法之间是等价的。
  
回到要求的问题本身，考虑其组合意义：在大小为分别为 $2s_l - 2$ 的集合里，每个集合分别取出 $c_l - 2$ 个数的方案数，并且 $\sum 2s_l - 2 = 2n - 2i - 2j$，$\sum c_l - 2 = k - i - 2j$。根据范德蒙德卷积的思想可得，这其实就是从大小为 $2n - 2i - 2j$ 的集合里取出 $k - i - 2j$ 个数，方案数为 $\begin{pmatrix} 2n - 2i - 2j \\ k - i - 2j \end{pmatrix}$。

考虑枚举 $i$ 和 $j$，其总答案为：
$$
\sum _{i = 0} ^k \sum _{j = 0} ^k \begin{pmatrix} i + 1 \\ j \end{pmatrix}\begin{pmatrix} n - i - 1 \\ j - 1 \end{pmatrix}\begin{pmatrix} 2n - 2i - 2j \\ k - i - 2j \end{pmatrix} + [n=k]
$$

时间复杂度 $O(k^2)$，注意空间限制。
## AC Code
```cpp
// Problem: P8594 「KDOI-02」一个仇的复
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P8594
// Memory Limit: 512 MB
// Time Limit: 3000 ms
// Date: 2024/12/03 21:06:04
// Author: Li_Feiy

#include <bits/stdc++.h>
#define arrout(a, n) rep(i, 1, n) printk(a[i])
#define arrin(a, n) rep(i, 1, n) a[i] = read()
#define rep(i, x, n) for(int i = x; i <= n; i++)
#define dep(i, x, n) for(int i = x; i >= n; i--)
#define erg(i, x) for(int i = head[x]; i; i = e[i].nex)
#define dbg(x) std::cout << #x << ":" << x << " "
#define mem(a, x) memset(a, x, sizeof a)
#define all(x) x.begin(), x.end()
#define arrall(a, n) a + 1, a + 1 + n
#define PII std::pair<int, int>
#define m_p std::make_pair
#define u_b upper_bound
#define l_b lower_bound
#define p_b push_back
#define CD const double
#define CI const int
#define int long long
#define il inline
#define ss second
#define ff first
#define itn int
int read() {
	char ch = getchar();
	int r = 0, w = 1;
	while(ch < '0' || ch > '9') w = ch == '-' ? -1 : w, ch = getchar();
	while(ch >= '0' && ch <= '9') r = (r << 3) + (r << 1) + (ch ^ 48), ch = getchar();
	return r * w;
}

void print(int x) {
	if(x < 0) putchar('-'), x = -x;
	if(x >= 10) print(x / 10);
	putchar(x % 10 + '0');
}template<typename ...Args>
void print(int t, Args... args) { print(t), print(args...); }

void printl(int x) { print(x), putchar('\n'); }
template<typename ...Args>
void printl(int t, Args... args) { printl(t), printl(args...); }

void printk(int x) { print(x), putchar(' '); }
template<typename ...Args>
void printk(int t, Args ... args) { printk(t), printk(args...); }
CI N = 4e7 + 5, MOD = 998244353;
int n, k, ans;
signed fac[N], inv[N];
int qpow(int a, int b) {
	int ans = 1;
	while(b) {
		if(b & 1) ans = ans * a % MOD;
		a = a * a % MOD;
		b >>= 1;
	}
	return ans;
}
void pre(int n) {
	fac[0] = inv[0] = 1;
	rep(i, 1, n) fac[i] = fac[i - 1] * i % MOD;
	inv[n] = qpow(fac[n], MOD - 2);
	dep(i, n - 1, 1) inv[i] = inv[i + 1] * (i + 1) % MOD;
}
int C(int m, int n) { return n < m || n < 0 || m < 0 ? 0 : 1ll * fac[n] * inv[n - m] % MOD * 1ll * inv[m] % MOD; }
signed main() {
	n = read(), k = read();
	pre(N - 5);
	rep(i, 0, k) rep(j, 0, k) ans = (ans + 
		C(k - i - 2 * j, 2 * n - 2 * i - 2 * j) * 
		C(j, i + 1) % MOD * 
		C(j - 1, n - i - 1) % MOD
	) % MOD;
	print(ans + (n == k));
	return 0;
}
```

---

## 作者：Corzica (赞：0)

先考虑一个子问题：所有 $y$ 个矩阵都横着摆放时填满 $x$ 个格子的答案，我们令其为 $f(x,y)$。

枚举上面的一行与下面的一行各用了多少个矩形，得到 $f(x,y)=\sum_{k = 1}^{y-1} C_{x-1}^{k-1}C_{x-1}^{y-k-1}=C_{2x-2}^{y-2}$。

我们再考虑将一个长为 $x$，矩阵数为 $y$ 的段分为 $k$ 个小段的方案数 $g(x,y,k)$。

根据定义，有 $g(x,y,k)=\prod_{p = 1}^{k}f(a_i,b_i)$，其中 $\sum a=x$，$\sum b=y$。将 $f$ 函数拆开，得到 $g(x,y,k)=\prod_{p = 1}^{k}C_{2a_i-2}^{b_i-2}$。
再次运用组合意义，得到 $g(x,y,k)=C_{2x-2k}^{y-2k} \times C_{x-1}^{k-1}$。

解释一下，上面的式子每一种划分方式，等同于先在 $2x-2k$ 个格子中摆放 $y-2k$ 个格子（注意 $a$ 函数与 $b$ 函数的和），再去计算把这么多的格子分成 $k$ 个非空段的方案数，即为 $g(x,y,k)$。

最后，我们进行最终答案的求解，我们先枚举有多少个矩形用作了竖着的 $1 \times 2$ 矩形，再枚举这些矩形总共组成了多少个连通块，要额外计算这些矩形如何分割成的这么多连通块。

最终的答案为 $\sum_{i=0}^{k}\sum_{j=1}^{i+1}g(n-i,k-i,j) \times C_{i+1}^j$。

还要特判没有连通块的情况，即在 $n=k$ 时要将答案加 $1$。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m;
const int mod = 998244353;
int jie[40000007], inv[40000007];
long long ans;
inline int ksm(int p, int q) {
	int base = 1;
	while (q) {
		if (q & 1) base = 1ll * base * p % mod;
		q >>= 1;
		p = ( 1ll * p ) * p % mod;
	}
	return base;
}
inline int C(int p, int q) {
	if (p < 0 || q < 0 || p < q) return 0;
	return 1ll * jie[p] * inv[q] % mod * inv[p - q] % mod;
}
signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	jie[0] = 1;
	for (int i = 1; i <= 40000000; i++) {
		jie[i] = (1ll * jie[i - 1]) * i % mod;
	}
	inv[40000000] = ksm(jie[40000000], mod - 2);
	for (int i = 40000000 - 1; i >= 0; i--) {
		inv[i] = (1ll * inv[i + 1] ) * (i + 1) % mod;
	}
	cin >> n >> m;
	for (int i = 0; i <= m; i++) {
		for (int j = 1; j <= i + 1; j++) {
			ans += 1ll * C(2 * n - 2 * i - 2 * j, m - i - 2 * j) * C(n - i - 1, j - 1) % mod * C(i + 1, j);
			ans %= mod;
		}
	}
	ans = (ans + (n == m)) % mod;
	cout << ans;
}
```


---

## 作者：wwwwwza (赞：0)

妙妙题。

先考虑没有竖着的长方形的情况。

用 $m$ 个长方形填满 $2\times n$ 的方格的情况。

发现如果不填，会有两个 $1\times n$ 的方格，每插一块板，就会多一个长方形，共有 $2\times n-2$ 个地方可以插板，所以方案为 $\binom{2\times n-2}{m-2}$。

设选择了 $i$ 个竖着的长方形，将方格分成了 $j$ 个长方形，运用插板法，在每个竖着的长方形的左右两边都可以插入一个长方形，方案数为 $\binom{i+1}{j}$。

接着将 $2\times (n-i)$ 的方格分给 $j$ 个长方形，方案为 $\binom{n-i-1}{j-1}$。

然后考虑 $j$ 个长方形该怎么填，这是一个范德蒙德卷积的形式，方案为 $\binom{2\times(n-i-j)}{k-i-2\times j}$。

特殊情况，当 $n=k$ 时，可以全填竖着的长方形。

答案为 $\sum\limits_{i=0}^n\sum\limits_{j=1}^n\binom{2\times(n-i-j)}{k-i-2\times j}\times\binom{n-i-1}{j-1}\times\binom{i+1}{j}+[n=k]$。


```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=4e7+5;
const int inf=4e7;
const int mod=998244353;
int n,k,ans=0,fac[N],inv[N];
int ksm(int a,int b){
	int sum=1;
	while(b){
		if(b&1)sum=1ll*sum*a%mod;
		a=1ll*a*a%mod;
		b>>=1;
	}
	return sum;
}
int c(int n,int m){
	if(n<0||m<0||n<m)return 0;
	return 1ll*(1ll*fac[n]*inv[m]%mod)*inv[n-m]%mod;
}
int main(){
	fac[0]=1;
	for(int i=1;i<=inf;i++)fac[i]=1ll*fac[i-1]*i%mod;
	inv[inf]=ksm(fac[inf],mod-2);
	for(int i=inf-1;i>=0;i--)inv[i]=1ll*inv[i+1]*(i+1)%mod;
	cin >>n>>k;
	for(int i=0;i<=k;i++){
		for(int j=0;j<=k;j++){
			int cnt=1ll*(1ll*c(2*n-2*i-2*j,k-i-2*j)*c(n-i-1,j-1)%mod)*c(i+1,j)%mod;
			ans=(ans+cnt)%mod;
		}
	}
	cout <<(ans+(n==k))%mod;
	return 0;
}

```

---


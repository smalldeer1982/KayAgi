# [YsOI2022] 淀粉树

## 题目背景

Ysuperman 教大家淀粉质和淀粉树。

## 题目描述

Ysuperman 定义一棵**有根树** $S$ 是树 $T$ 的一棵淀粉树当且仅当 $S$ 满足如下两个条件（记 $s_i$ 表示 $S$ 中以 $i$ 为根的子树中所有点构成的点集）：

1. $S$ 与 $T$ 点数相同（不妨设为 $n$）且编号为 $1\sim n$。
1. 对于 $S$ 中任意一个有儿子的点 $i$，对于其任意一个儿子 $j$，满足在 $T$ 中 $i$ 与 $s_j$ 中至少一个点有直接连边。

容易发现一棵树 $T$ 的淀粉树可能有很多棵。

Ysuperman 现在给定 $n$ 以及两棵点编号 $1\sim n$ 的树 $T$ 和树 $S$，设树 $S$ 中度数最大的点的度数为 $d$，TA 需要你进行至少一次且不超过 $d$ 次操作，每次操作把 $T$ 替换成它的任意一棵淀粉树，使得最终 $T$ 变成 $S$。

请注意，这里给定的 $S$ 是没有给定根的，你只需要满足最后 $T$ 的连边情况和 $S$ 相同我们就认为 $T$ 变成了 $S$。

输入保证存在至少一组解。

## 说明/提示

#### 样例 1 解释

这是 $T$：

![](https://cdn.luogu.com.cn/upload/image_hosting/5qlv4q4t.png)

这是 $S$：

![](https://cdn.luogu.com.cn/upload/image_hosting/xoyaon7y.png)

该输出仅对 $T$ 进行了一次操作，即将 $T$ 变成了下面这棵有根树：

![](https://cdn.luogu.com.cn/upload/image_hosting/0kozi468.png)

这棵有根树是 $T$ 的一棵淀粉树，理由如下：

1. 对于 $2$ 的儿子 $1$，在 $T$ 中 $2$ 与 $s_1=\{1\}$ 中的 $1$ 有直接连边。
2. 对于 $3$ 的儿子 $2$，在 $T$ 中 $3$ 与 $s_2=\{1,2\}$ 中的 $1$ 有直接连边。
3. 对于 $3$ 的儿子 $4$，在 $T$ 中 $3$ 与 $s_4=\{4\}$ 中的 $4$ 有直接连边。
4. 对于 $3$ 的儿子 $5$，在 $T$ 中 $3$ 与 $s_5=\{5\}$ 中的 $5$ 有直接连边。

最终得到的有根树和 $S$ 的连边情况相同，所以这份输出将被判定为正确。

#### 数据范围

子任务 $1$（$20$ 分），满足 $n\le 6$。

子任务 $2$（$20$ 分），满足 $d=2$。

子任务 $3$（$20$ 分），满足 $T$ 可以只进行一次操作即可变成 $S$ 且 $n\le 447$。

子任务 $4$（$20$ 分），满足 $n\le 2000$。

子任务 $5$（$20$ 分），无特殊限制。

对于所有数据，满足 $2\le n\le 10^5$，$d\times n\le 2\times 10^5$。

#### 提示

附件下发了本题 checker。

## 样例 #1

### 输入

```
5 3
1 2
1 3
3 4
3 5
3 2
3 4
3 5
1 2```

### 输出

```
1
2 3 0 3 3```

# 题解

## 作者：Imakf (赞：5)

咋青山老师的题都没人写题解，伤心了啊。

# $d=2$ 部分分

先考虑部分分 $d=2$，要求操作两次把树还原成一条链。

其实任意链本质上与 $1-2-3-\cdots-n$（下文称“排好序的链”）没区别，因为可以对编号重新映射。

先考虑什么情况下可以一次操作把把树变成排好序的链。

有一种比较好的情况是：当前树恰好是对序列建立出的大根笛卡尔树，此时由于删去最小值之后，剩余结点最小值依然在叶子位置，所以我们依次连接最小值就可得到所需链。

于是不难发现：只要树满足“删去最小值之后，剩余结点最小值依然在叶子位置”，即可实现一次操作还原成排好序的链。

那么怎么一次操作变成满足这样条件的树呢，那就直接点分治的时候，每次都选子树内权值最大的作为分治中心就行了。

获得 20 分！

# 正解

考虑怎么做整道题。

先把 $T$ 变成 $d=2$ 的链 $T_1$，$S$ 由某条链 $T_1$ 变来其中每一次操作都使最大度数 $+1$，发现要操作 $n$ 次，非常好。

已经解决 $T\to T_1$，考虑怎么解决 $T_1 \to S$。

把过程反过来考虑，$S$ 的上一个状态是什么，然后尝试减小 $S$ 的最大度点的度数。

你发现有一种方法如下：

选 $S$ 的一个叶子结点为根，然后 dfs 整棵树，如果 $u$ 的某个孩子 $v$ 为当前最大度数 $d$，则删去边 $(u,v)$，再在 $v$ 子树中随便选一个叶子 $w$，然后连接 $(u,w)$。可以说明 $w$ 一定存在，因为二度点不需要管，缩完二度点后，显然叶子比其他所有点数量都多。维护子树内的所有叶子可以链表。

注意到我们必须先通过 $T_1 \to S$ 求出 $T_1$，然后再进行 $T\to T_1$，所以说要存下中途的操作再逆序输出。

复杂度 $O(nd+n\alpha (n))$。

代码写得比较丑，就不放了。

---

## 作者：EuphoricStar (赞：2)

考虑 $d = 2$ 的部分分。相当于只用 $2$ 次操作把 $T$ 变成一条链。

不妨设最后变成的是一个 $1 \sim n$ 的链，如果不是可以把点重编号。

第一次操作考虑以 $n$ 为根，每次取每个儿子的子树中的最大值为新的根并和原来的根连边，这样会将整棵树具有堆的性质，即父亲的编号比儿子的编号大。

那么第二次操作时因为删完 $1 \sim i - 1$ 的点后 $i$ 一定是叶子，所以合法。

实现时发现第一次操作实际上是求点权 Kruskal 重构树，从小到大加点，并查集维护每个点所在子树的根即可。

$d = 2$ 的部分分给我们启发。考虑若能让 $S$ 逆操作 $d - 2$ 次变成一条链，那么整道题就解决了。

考虑增量法，每次把 $S$ 中的最大度数减 $1$。自底向上构造，若当前点的度数为最大度数，那么就断开它和父亲的连边，在子树里面随便找一个还没标记过的叶子，将父亲和这个叶子连边，并标记这个叶子。容易归纳证明每棵子树中未被标记的叶子个数 $\ge 1$，所以不会出现所有叶子都被标记的情况。

时间复杂度 $O(nd \log n)$。

```cpp
// Problem: P8949 [YsOI2022] 淀粉树
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P8949
// Memory Limit: 256 MB
// Time Limit: 1000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h>
#define pb emplace_back
#define fst first
#define scd second
#define mkp make_pair
#define mems(a, x) memset((a), (x), sizeof(a))

using namespace std;
typedef long long ll;
typedef double db;
typedef unsigned long long ull;
typedef long double ldb;
typedef pair<ll, ll> pii;

const int maxn = 200100;

int n, m, p[maxn], q[maxn], tim, fa[maxn];
vector<int> G[maxn], ans[maxn], leaf[maxn];
set<int> S[maxn], T[maxn];

void dfs(int u, int fa, int d) {
	ans[d][u] = fa;
	bool fl = 1;
	for (int v : S[u]) {
		if (v == fa) {
			continue;
		}
		fl = 0;
		dfs(v, u, d);
		if (leaf[u].size() < leaf[v].size()) {
			swap(leaf[u], leaf[v]);
		}
		for (int x : leaf[v]) {
			leaf[u].pb(x);
		}
		vector<int>().swap(leaf[v]);
	}
	if (fl) {
		leaf[u].pb(u);
		return;
	}
	if ((int)T[u].size() == d) {
		assert((int)leaf[u].size() >= 2);
		int v = leaf[u].back();
		leaf[u].pop_back();
		T[fa].insert(v);
		T[v].insert(fa);
		T[fa].erase(u);
		T[u].erase(fa);
	}
}

void dfs2(int u, int fa, int d) {
	ans[d][u] = fa;
	p[u] = ++tim;
	q[tim] = u;
	for (int v : S[u]) {
		if (v == fa) {
			continue;
		}
		dfs2(v, u, d);
	}
}

int find(int x) {
	return fa[x] == x ? x : fa[x] = find(fa[x]);
}

inline void merge(int x, int y) {
	x = find(x);
	y = find(y);
	if (x != y) {
		fa[x] = y;
	}
}

void solve() {
	scanf("%d%d", &n, &m);
	if (n == 2) {
		puts("1\n0 1");
		return;
	}
	for (int i = 1; i <= m; ++i) {
		ans[i] = vector<int>(n + 2);
	}
	for (int i = 1, u, v; i < n; ++i) {
		scanf("%d%d", &u, &v);
		G[u].pb(v);
		G[v].pb(u);
	}
	for (int i = 1, u, v; i < n; ++i) {
		scanf("%d%d", &u, &v);
		S[u].insert(v);
		S[v].insert(u);
	}
	int rt = 0;
	for (int i = 1; i <= n; ++i) {
		if ((int)S[i].size() == 1) {
			rt = i;
			break;
		}
	}
	for (int d = m; d >= 3; --d) {
		for (int i = 1; i <= n; ++i) {
			vector<int>().swap(leaf[i]);
			T[i] = S[i];
		}
		dfs(rt, 0, d);
		for (int i = 1; i <= n; ++i) {
			S[i] = T[i];
		}
	}
	dfs2(rt, 0, 2);
	for (int i = 1; i <= n; ++i) {
		fa[i] = i;
	}
	for (int i = 1; i <= n; ++i) {
		for (int j : G[q[i]]) {
			j = find(j);
			if (p[j] < i) {
				ans[1][j] = q[i];
				fa[j] = q[i];
			}
		}
	}
	printf("%d\n", m);
	for (int i = 1; i <= m; ++i) {
		for (int j = 1; j <= n; ++j) {
			printf("%d%c", ans[i][j], " \n"[j == n]);
		}
	}
}

int main() {
	int T = 1;
	// scanf("%d", &T);
	while (T--) {
		solve();
	}
	return 0;
}

```

---

## 作者：Erine (赞：1)

Preface: 题解里面的 $S$ 和 $T$ 的意思与原题相反，请注意。

先考虑 $d=2$ 怎么做，也就是我们要两次重构使得 $S$ 变成任意排列的一条链。

先把链重标号为 $1\sim n$。我们发现这个链的上一步应该是一个大根堆，好。然后我们再发现原树每次取连通块里最大的点就行了。也就是我们构造：$S$ 的简易 kruskal 重构树，作为中间树即可。

考虑 $d>2$，我们还剩 $d-2$ 次操作使得一条链变成 $T$。正难则反，我们考虑每次对 $T$ 做逆操作，每次令最大度数减少 $1$。

于是有很 trivial 的做法：拎出一个叶子当根，然后 $\text{Solve}(u)$ 表示把 $u$ 子树里做逆变换，返回任意两个叶子结点。每次先 $\text{Solve}(v)$，然后把 $u$ 与所有 $v$ 返回的叶子结点连边。如果 $u$ 度数 $=1$，那么返回 $u$ 和另一个未被使用的点；否则返回任意两个未被使用的点即可。

于是我们 $\Theta(n\log n+nd)$ 解决了这道构造题。

```cpp
pii solve(const vector<vector<int>> &tr, int u, int fa, vector<pii> &ans) {
	int cnt = 0;
	vector<int> lf;
	for (int v : tr[u]) {
		if (v == fa) continue;
		if (tr[v].size() == 1) {
			ans.push_back({u, v});
			lf.push_back(v);
		} else {
			pii tmp = solve(tr, v, u, ans);
			ans.push_back({u, tmp.fs});
			lf.push_back(tmp.sc);
		}
	}
	if (lf.size() == 1) return {u, lf[0]};
	else return {lf[0], lf[1]};
}
```

---

## 作者：lfxxx (赞：1)

听了学长的讲解，来写一篇题解。

先考虑 $d=2$ 的部分分。

首先把最后的链重编号，变成 $1 \to 2 \to 3 ... \to n$ 的一条链。

然后把编号重映射到原树上。

对于原树考虑先从 $n$ 开始做一遍点分治，每次选择连通块中编号最大的点，再从 $1$ 开始做一遍点分治，每次选择连通块中编号最小的点。

下面说说为什么这样做是对的。

第一遍点分治完成后就保证子树内节点的编号一定大于等于子树的根，因此编号为 $1$ 的点一定在叶子上，因此当它被选出后剩下的连通块中有点 $2$ 至点 $n$ 因此下一个会选择点 $2$，此时点 $2$ 因为点 $1$ 被删掉也只可能是一个叶子，因此会重复处理点 $1$ 时的操作，以此类推便可知会得到合法的链。

接下来考虑满分做法。

因为已经把原树变成了链，接下考虑把最终希望得到的树用 $d - 2$ 次操作还原成链，考虑每次选出树中度数最大的点，找到它子树中度数最小的点，让这个点与它的父亲连边，然而假若我们将度数只有 $2$ 的点缩成了链，那么这一定会选出叶子节点！因此考虑维护子树内度数只有 $1$ 的点，下面证明这样的点一定存在，因为只会对度数大于 $2$ 的点进行操作，所以考虑将度数等于 $2$ 的点缩成一条边，那么在这棵新树上叶子节点一定比非叶子节点多，因此总有叶子节点可以帮助它的某个祖先完成上面的操作。为了方便，我们可以从一个叶子节点出发。

接下来考虑如何维护这个操作，因为要维护子树内的叶子节点，所以考虑用一个 vector 存下子树内的叶子节点再启发式合并的合并到父亲上，加上前面点分治用类似于 kruskal 重构树的做法用并查集维护，以及用 set 维护所有边，总时间复杂度 $O(n \times d \log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 5e5+114;
set<int> edge[maxn],e[maxn];
set<int> road[maxn],r[maxn];
int fa[maxn],n,d;
//第一遍点分治 
int found(int u){
	return (fa[u]==u?u:fa[u]=found(fa[u]));
}
int dfncnt;
int Node[maxn],dfn[maxn];
void dfs(int u,int father){
	dfn[u]=++dfncnt;
	Node[dfncnt]=u;
	for(int v:road[u]){
		if(v!=father) dfs(v,u);
	}
}
void build1(){
	for(int i=1;i<=n;i++){
		int u=Node[i];
		stack<int> st;
		for(int v:edge[u]){
			if(found(u)!=found(v)&&dfn[found(v)]<dfn[u]){
				st.push(found(v));
			}
		}
		for(int v:edge[u]){
			if(found(u)!=found(v)&&dfn[found(v)]<dfn[u]){
				int mu=found(u),mv=found(v);
				if(dfn[mu]>dfn[mv]) swap(mu,mv);
				fa[mu]=mv;
			}
		}
		edge[u].clear();
		while(st.size()>0) e[u].insert(st.top()),e[st.top()].insert(u),st.pop();
	}
	for(int i=1;i<=n;i++) edge[i]=e[i],e[i].clear();
}
void build2(){
	for(int i=n;i>=1;i--){
		int u=Node[i];
		stack<int> st;
		for(int v:edge[u]){
			if(found(u)!=found(v)&&dfn[found(v)]>dfn[u]){
				st.push(found(v));
			}
		}
		for(int v:edge[u]){
			if(found(u)!=found(v)&&dfn[found(v)]>dfn[u]){
				int mu=found(u),mv=found(v);
				if(dfn[mu]<dfn[mv]) swap(mu,mv);
				fa[mu]=mv;
			}
		}
		edge[u].clear();
		while(st.size()>0) e[u].insert(st.top()),e[st.top()].insert(u),st.pop();
	}
	for(int i=1;i<=n;i++) edge[i]=e[i],e[i].clear();
}
map<int,int> Ciallo[maxn];
void Printf(int u,int father,int pos,int type){
	Ciallo[u][pos]=father;
	if(type==0){
		for(int v:edge[u]) if(v!=father) Printf(v,u,pos,type);
	}
	else{
		for(int v:road[u]) if(v!=father) Printf(v,u,pos,type);
	}
}
int D[maxn]; 
int vis[maxn];
int root;
vector<int> leave[maxn];
void dfs1(int u,int father){
	fa[u]=father;
	for(int v:road[u]) if(v!=father) dfs1(v,u);
}
void dfs2(int u,int deg){
	vis[u]=1;
	if(D[u]==1&&u!=root){
		leave[u].push_back(u);
		return ;
	}
	int son=0;	
	vector<int> Son;
	for(int v:road[u]){
		if(vis[v]==0&&v!=0){
			Son.push_back(v);
			dfs2(v,deg);
			if(leave[v].size()>leave[son].size()) son=v;
		}
	}
	swap(leave[son],leave[u]);
	leave[son].clear();
	for(int v:Son){
		if(v!=son){
			for(int x:leave[v]) leave[u].push_back(x);
			leave[v].clear();
		}
	}
	if(D[u]==deg){
		r[fa[u]].erase(u);
		r[u].erase(fa[u]);
		r[fa[u]].insert(leave[u].back());
		r[leave[u].back()].insert(fa[u]);
		D[u]--;
		D[leave[u].back()]++;
		leave[u].pop_back(); 
	}
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>d;
	if(n==2){
		cout<<"1\n0 1\n";
		return 0;
	}
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		edge[u].insert(v);
		edge[v].insert(u);
	}
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		D[u]++;
		D[v]++;
		road[u].insert(v);
		road[v].insert(u);
	}	
	/*
	这一部分需要把树 S 变成一条链 
	*/
	for(int i=1;i<=n;i++) if(D[i]==1) root=i;
	for(int i=d;i>=3;i--){
		Printf(root,0,i,1);
		for(int i=1;i<=n;i++) r[i]=road[i];
		for(int j=1;j<=n;j++) vis[j]=0,leave[j].clear(),fa[j]=0;
		dfs1(root,0);
		dfs2(root,i);
		for(int i=1;i<=n;i++) road[i]=r[i],r[i].clear(); 
	}
	/*
	此时原树已经变成链 
	*/
	dfs(root,0);
	for(int i=1;i<=n;i++) fa[i]=i;
	build1();
	Printf(Node[n],0,1,0);
	for(int i=1;i<=n;i++) fa[i]=i;
	build2();
	Printf(Node[1],0,2,0);
	cout<<d<<'\n';
	for(int i=1;i<=d;i++){
		for(int j=1;j<=n;j++) cout<<Ciallo[j][i]<<' ';
		cout<<'\n';
	}
}
 
```












---


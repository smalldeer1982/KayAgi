# [DTCPC 2024] 小方学乘法

## 题目背景

小方上数学课，开始学乘法，但是他在课上睡着了。

## 题目描述


他梦见了一个数学公式，只包含数字和乘号，梦境是迷糊的，所以他可能会把乘号看成字母 $x$。

他冥冥之中记得这个 $x$ 的值，并且他认为字母可以看成数字，因此他在将字母 $x$ 都替换为了数字的情况下算出了这个表达式的值。

然后他被教练抓到睡觉了。

在被 gank 之前，他想回忆起梦中算出的值。

但是小方太困了，所以他决定求出所有情况下的值，也就是将每个**乘号**都替换或者不替换为字母 $x$ 所代表的值后，对所有可能情况求和。

然而小方连 $x$ 都忘记了，只记得它在某个范围 $[L,R]$ 内，所以他要对每个 $x$ 求出上面那个和的和。

小方刚学乘法，算不清太大的数字，所以他想让你求出答案 $\bmod {10^9+7}$ 的结果。

**形式化题意**

给你一个只含有数字 $1 \sim 9$ 和 `?` 的字符串 $s$，保证没有两个相邻的 `?`，且字符串的第一个字符和最后一个字符都不是 `?`。

现在每个 `?` 可以换成 $x$ 或者 $\times$，其中 $x$ 是一个给定的字符串拼接变量。

比如 `12x45` 当 $x=33$ 时替换结果为 `123345`。

记 $x=k$ 时所有 `?` 替换方案下表达式的权值和为 $f(k)$。

求 $\sum_{i=L}^R{f(i)} \bmod {10^9 + 7}$。




## 样例 #1

### 输入

```
123?13?23
1 10```

### 输出

```
507086689```

# 题解

## 作者：Sol1 (赞：4)

同步发表于 [个人博客](https://sol1.netlify.app/2024/02/17/solution-p10167/)。

---

想法比较直接的优化 dp + 插值。

首先由于 $x$ 的插入会导致原来的数的错位，因此一个显然的想法是对于位数不同的 $x$ 分别处理。

然后注意到当 $x$ 的位数固定时，对于任意一种 $x$ 和乘号的填法，得到的乘法算式中的每一个数的值都是一个常数或者关于 $x$ 的一次函数。于是将它们乘起来就会得到一个 $x$ 的 $O(n)$ 次多项式。对所有填入乘号和 $x$ 的方法求和并不改变多项式的次数。至此我们可以考虑对若干个 $x$ 单独求值并通过多项式插值快速求和。

我们需要对一个固定的 $x$（记这个 $x$ 的位数为 $l$）在 $O(n)$ 时间内计算答案。考虑一个 dp，设 $f_i$ 为考虑到第 $i$ 个问号之前的部分，所有填法的计算结果的和。暴力的转移是枚举最后一个乘号的位置（设为 $j$），并将 $f_j$ 乘上后面所有位置填 $x$ 构成的数转移到 $f_i$。这样是 $O(n^2)$ 的，考虑优化。

注意到 $j$ 转移到的位置从 $i$ 变为 $i+1$ 时，$f_j$ 乘上的值的变化一定是先乘上「$x$ 的位数」个 $10$，加上 $x$，再乘上「第 $i$ 个问号和第 $i+1$ 个问号之间的数字串长度」个 $10$，再加上这串数字构成的值。所以我们在转移过程中维护 $f_j$ 的和以及 $f_j$ 乘上后面的值的和两个值，就可以 $O(n)$ 完成上述 dp 了。具体可以看代码。

对每一个位数取出 $O(n)$ 个点值，求前缀和之后插值即可。暴力插值或线性插值均可。复杂度 $O(n^2\log R)$。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1 << 21], *p1 = buf, *p2 = buf;

inline int qread() {
    char c = getchar();
    int x = 0, f = 1;
    while (c < '0' || c > '9') {
        if (c == '-') f = -1;
        c = getchar();
    }
    while (c >= '0' && c <= '9') {
        x = (x << 3) + (x << 1) + c - 48;
        c = getchar();
    }
    return x * f;
}

const long long mod = 1000000007;
const int N = 2077, L = 18;

int n;
char str[N];
vector <pair <long long, int> > val;
long long f[N], pw10[N], p10r[N], sl, sr, x[N], y[N], inv[N];

inline void Prefix() {
    long long cur = 0, len = 0;
    for (int i = 1;i <= n;i++) {
        if (str[i] == '?') {
            val.push_back(make_pair(cur, len));
            cur = 0; len = 0;
        } else {
            cur = (cur * 10 + str[i] - '0') % mod;
            len++;
        }
    }
    val.push_back(make_pair(cur, len));
    pw10[0] = 1;
    for (int i = 1;i <= n + L;i++) pw10[i] = pw10[i - 1] * 10 % mod;
    p10r[0] = 1;
    for (int i = 1;i <= L;i++) p10r[i] = p10r[i - 1] * 10;
    inv[1] = 1;
    for (int i = 2;i <= n + 10;i++) inv[i] = (mod - mod / i) * inv[mod % i] % mod;
}

inline long long getAns(long long x, long long xln) {
    x %= mod;
    long long fsm = 0, fpsm = 0;
    f[0] = val[0].first;
    fsm = 1;
    fpsm = val[0].first;
    for (int i = 1;i < val.size();i++) {
        fpsm = fpsm * pw10[xln] % mod;
        fpsm = (fpsm + x * fsm) % mod;
        fpsm = fpsm * pw10[val[i].second] % mod;
        fpsm = (fpsm + val[i].first * fsm) % mod;
        f[i] = (fpsm + f[i - 1] * val[i].first) % mod;
        fsm = (fsm + f[i - 1]) % mod;
        fpsm = (fpsm + f[i - 1] * val[i].first) % mod;
    }
    return f[val.size() - 1];
}

inline long long Inv(long long x) {
    if (x < 0) return mod - inv[-x];
    else return inv[x];
}

inline void Solve() {
    long long ans = 0;
    for (int i = 1;i <= L;i++) {
        long long vl = p10r[i - 1], vr = p10r[i] - 1;
        vl = max(vl, sl); vr = min(vr, sr);
        if (vl > vr) continue;
        long long cnt = val.size() + 5;
        if (vr - vl + 1 <= cnt) {
            for (long long j = vl;j <= vr;j++) ans = (ans + getAns(j % mod, i)) % mod;
        } else {
            y[0] = 0;
            for (long long j = vl;j <= vl + cnt - 1;j++) {
                x[j - vl + 1] = j;
                y[j - vl + 1] = getAns(j % mod, i);
            }
            for (int j = 1;j <= cnt;j++) y[j] = (y[j] + y[j - 1]) % mod;
            for (int j = 1;j <= cnt;j++) {
                long long cur = y[j];
                for (int k = 1;k <= cnt;k++) {
                    if (k == j) continue;
                    cur = cur * (vr % mod - x[k] % mod) % mod * Inv(x[j] - x[k]) % mod;
                }
                ans = (ans + cur) % mod;
            }
        }
    }
    cout << (ans % mod + mod) % mod << endl;
}

int main() {
    cin >> str + 1; n = strlen(str + 1);
    cin >> sl >> sr;
    Prefix();
    Solve();
    return 0;
}
```

---

## 作者：critnos (赞：4)

标题党了。

上面那句话并不适用。因为这题不是数位 dp，至少不是常规意义上的。

$i$ 的位数影响很大，所以枚举 $i$ 的位数，将计算区间作为 $[10^k,10^{k+1})$ 和 $[l,r]$ 取交，显然 $f(i)$ 是关于 $i$ 的 $O(n)$ 次多项式，那么 $f(i)$ 在区间中的前缀和也是。

相当于要 $O(n)$ 计算一个 $f(i)$，这个很简单，考虑前 $t-1$ 个问号的答案推到前 $t$ 个问号，记之前的算式是 $S\times T$，现在会变成 $S\times T\times C$ 或者 $S\times TC$ 即 $S\times T(10^{c}+C)$ 即 $S\times T\times 10^c+S\times C$。维护 $S$ 的和和 $S\times T$ 的和即可。

然后直接插值即可 $O(n^2\log V)$。

---

## 作者：Reunite (赞：3)

考虑如果给定一个 $x$ 怎么算，设 $f_i$ 为考虑到原串第 $i$ 个位置要求 $c_{i+1}=?$ 的所有值的和，那么转移只需要找到上一个填乘号的位置 $j$：

$$f_i=\sum_{j<i} f_{j-1}\times val(j+1,i,x)$$

其中 $val$ 就是这段把 $?$ 全替换为 $x$ 的值。倒着扫 $j$ 可以做到 $n^2$，但是不够优秀。考虑一个预支贡献的经典 trick，我们在所有有效的 $f_i$ 处预先乘上 $val(i+2,n,x)$，这样在后面计算贡献的时候，只需要先减去右边后面那段的 $val$ 再除去 $10$ 的幂即可。两次前缀和优化即可做到 $O(n)$。

再考虑最开始的转移，$val$ 的值显然可以分解为一个常量加上若干 $10$ 的幂的和做为系数再乘上 $x$，那么如果 $x$ 位数不变，这一段 $val$ 就是一个固定的一次函数，所以最后的 $f_n$ 一定为关于 $x$ 的 $O(n)$ 次函数。那么我们枚举位数，取这一位前 $O(n)$ 个值计算 $f_n$ 再用前缀和插值即可，复杂度 $O(n^2\lg n)$。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#define int long long
#define mod 1000000007
using namespace std;

int n,L,R,ans;
int mi[25];
int f[3005];
int g[3005];
int w[3005];
int s1[3005];
int s2[3005];
char c[3005];
int iv[3005];
int bin[40005];
int biv[40005];

inline void in(int &n){
	n=0;
	char c=getchar();
	while(c<'0' || c>'9') c=getchar();
	while(c>='0'&&c<='9') n=n*10+c-'0',c=getchar();
	return ;
}

inline int calc(int x,int k){
	int tmp=1;
	while(k){
		if(k&1) tmp=tmp*x%mod;
		x=x*x%mod;
		k>>=1;
	}
	return tmp;
}

inline int inv(int x){return calc(x,mod-2);}

inline int work(int x){
	int xx=x,ww=0;
	while(xx) ww++,xx/=10;
	memset(f,0,sizeof(f));
	for(int i=n;i>=1;i--){
		g[i]=g[i+1],w[i]=w[i+1];
		if(c[i]=='?') (g[i]+=x%mod*bin[w[i]])%=mod,w[i]+=ww;
		else (g[i]+=(c[i]-'0')*bin[w[i]])%=mod,w[i]++;
	}
	for(int i=1;i<=n;i++){
		s1[i]=s1[i-1],s2[i]=s2[i-1];
		if(c[i+1]!='?') continue;
		f[i]=(g[1]-g[i+1]+s1[i-2]-s2[i-1]*g[i+1]%mod+mod+mod)%mod;
		f[i]=f[i]*biv[w[i+1]]%mod;
		(s1[i]+=f[i]*g[i+2])%=mod;
		(s2[i]+=f[i])%=mod;
	}
	return f[n];
}

int m;
int x[3005];
int y[3005];

inline int ins(int k){
	int l[3005],r[3005];
	l[0]=r[m+1]=1;
	for(int i=1;i<=m;i++) l[i]=l[i-1]*((k-x[i]+mod)%mod)%mod;
	for(int i=m;i>=1;i--) r[i]=r[i+1]*((k-x[i]+mod)%mod)%mod;
	int s=0;
	for(int i=1;i<=m;i++){
		int ss=y[i];
		ss=ss*l[i-1]%mod*r[i+1]%mod;
		ss=ss*iv[i-1]%mod*iv[m-i]%mod;
		if((m-i)&1) ss=mod-ss;
		(s+=ss)%=mod;
	}
	return s;
}

inline void solve(int w){
	int l=mi[w-1],rr=mi[w]-1,r=min(rr,l+n+2),s=0;
	if(L>rr||R<l) return ;
	m=r-l+1;
	for(int i=l;i<=r;i++) x[i-l+1]=i,y[i-l+1]=(s+=work(i))%=mod;
	(ans+=ins(min(rr,R))-((l>=L)?0:ins(max(l,L)-1))+mod)%=mod;

	return ;
}

signed main(){
	scanf("%s",c+1);
	n=strlen(c+1);
	c[n+1]='?';
	in(L),in(R);
	bin[0]=mi[0]=iv[0]=1;
	for(int i=1;i<=3000;i++) iv[i]=iv[i-1]*inv(i)%mod;
	for(int i=1;i<=18;i++) mi[i]=mi[i-1]*10;
	for(int i=1;i<=20*n;i++) bin[i]=bin[i-1]*10%mod;
	for(int i=0;i<=20*n;i++) biv[i]=calc(bin[i],mod-2);
	for(int i=1;i<=18;i++) solve(i);
	printf("%lld\n",ans);

	return 0;
}
```

---

## 作者：min_inf (赞：2)

场切了非常开心。

拼接看上去不是很好算，考虑枚举位数，容易发现位数确定了这玩意是个多项式。

然后发现这个东西很能 DP。设 $f_{i,j,0/1/2}$ 为考虑到第 $i$ 个数的 $j$ 次项系数，上一个问号用了乘号/最后一个拿了的 $x$ 在上一个乘法后面/前面，然后用一个 $g_{i,j,0/1/2}$ 表示不考虑上一个乘号后面的东西的值方便转移。转移方程我写了一大坨，可以参考代码。

然后就可以拉格朗日插值做了。时间复杂度 $O(n^2 \log V)$。

```cpp
namespace KnownError_{
    constexpr int N = 2005, mod = 1e9+7;
    using mint = modint<mod>;
    mint lagrange(const vector<mint> &ve,mint k){
        int n=sizc(ve)-1;
        vector<mint> fac(n+1),invf(n+1),pre(n+1),suf(n+1);
        fac[0]=1;pre[0]=k;
        rep(i,1,n)fac[i]=fac[i-1]*i;
        invf[n]=fac[n].inv();suf[n]=k-n;
        per(i,n,1)invf[i-1]=invf[i]*i;
        pre[0]=k;
        rep(i,1,n)pre[i]=pre[i-1]*(k-i);
        suf[n]=k-n;
        per(i,n-1,0)suf[i]=suf[i+1]*(k-i);
        mint ret;
        rep(i,0,n)ret+=ve[i]*(i>0?pre[i-1]:1)*(i<n?suf[i+1]:1)*invf[i]*invf[n-i]*(n-i&1?-1:1);
        return ret;
    }
    mint pw[N+50];
    string val[N];
    mint mv[N];
    int n;
    mint f[N][N][3],g[N][N][3];
    mint calc(ll l,ll r,int len){
        f[0][0][0]=mv[0],g[0][0][0]=1;
        rep(i,1,n-1){
            int sz=val[i].size();
            rep(j,0,i){
                f[i][j][0]=f[i][j][1]=f[i][j][2]=0;
                g[i][j][0]=g[i][j][1]=g[i][j][2]=0;
                f[i][j][0]+=(f[i-1][j][0]+f[i-1][j][1]+f[i-1][j][2])*mv[i];
                g[i][j][0]+=f[i-1][j][0]+f[i-1][j][1]+f[i-1][j][2];
                if(j){
                    f[i][j][1]+=g[i-1][j-1][0]*pw[sz];
                    g[i][j][1]+=g[i-1][j-1][0];
                }
                f[i][j][1]+=f[i-1][j][1]*pw[len+sz]+g[i-1][j][1]*pw[sz];
                g[i][j][1]+=g[i-1][j][1];
                f[i][j][2]+=(f[i-1][j][0]+f[i-1][j][2])*pw[len+sz]+(g[i-1][j][0]+g[i-1][j][2])*mv[i];
                g[i][j][2]+=g[i-1][j][0]+g[i-1][j][2];
            }
        }
        mint ans=0;
        /*
        for(ll i=l;i<=r;++i){
            mint pw=1;
            rep(j,0,n-1){
                mint v=f[n-1][j][0]+f[n-1][j][1]+f[n-1][j][2];
                ans+=pw*v;
                pw*=i;
            }
        }
        */
        vector<mint> pw(n+2,1); 
        rep(j,0,n-1){
            mint v=f[n-1][j][0]+f[n-1][j][1]+f[n-1][j][2];
            vector<mint> ve(n+2);
            rep(i,0,n+1)ve[i]=v*pw[i];
            rep(i,1,n+1)ve[i]+=ve[i-1];
            ans+=lagrange(ve,r-l); 
            rep(i,0,n+1)pw[i]*=l+i;
        } 
        return ans;
    }
    mint work(ll n){
        mint ans=0;
        ll pw=1;
        for(int i=1;;++i){
            pw*=10;
            if(n<pw){
                ans+=calc(pw/10,n,i);
                return ans;
            }
            ans+=calc(pw/10,pw-1,i);
        }
        return 114514;
    }
    void main(){
        pw[0]=1;
        rep(i,1,2050)pw[i]=pw[i-1]*10;
        string s;
        cin>>s;
        s+='?';
        string t;
        for(auto ch:s){
            if(ch=='?')val[n++]=t,t="";
            else t+=ch;
        }
        repn(i,n){
            mint &x=mv[i];x=0;
            for(auto ch:val[i])x=x*10+(ch-'0');
        }
        ll l,r;
        cin>>l>>r;
        cout<<work(r)-work(l-1)<<'\n';
    }
}
```


---

## 作者：dAniel_lele (赞：1)

![](https://cdn.luogu.com.cn/upload/image_hosting/qf4ruy1g.png)

首先先批评一下出题人。

考虑对 $x$ 的长度分类讨论。设长度为 $len$。

考虑将每个数拆位。考虑 $dp_{i,j,0/1}$ 表示考虑到前 $i$ 个位置，$x^j$ 的系数是多少，且从上个乘号到现在是否选了一个位置。

转移是朴素的，具体留给读者自行推倒。（也可以见代码 `solvedp` 一部分）

问题转化为对多个 $x^j$ 求 $\sum_{i=l}^rx^j$，可以使用插值解决。

总复杂度 $O(n^2\log^2n)$ 或 $O(n^2\log n)$。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1e9+7;
int qp(int a,int b){
	int ans=1;
	while(b){
		if(b&1) (ans*=a)%=mod;
		(a*=a)%=mod;
		b>>=1;
	}
	return ans;
}
int pl[100005],pr[100005],fac[100005],inv[100005];
int prepw[2005][2005];
int solve(int n,int k){
	if(n<=k+5){
		int ans=0;
		for(int i=1;i<=n;i++){
			(ans+=prepw[i][k])%=mod;
		}
		return ans;
	}
	pl[0]=pr[k+3]=fac[0]=1;
	for(int i=1;i<=k+2;i++) pl[i]=pl[i-1]*((n-i)%mod)%mod;
	for(int i=k+2;i>=1;i--) pr[i]=pr[i+1]*((n-i)%mod)%mod;
	int y=0,ans=0;
	for(int i=1;i<=k+2;i++){
		(y+=prepw[i][k])%=mod;
		int a=pl[i-1]*pr[i+1]%mod;
		int b=inv[i-1]*(((k-i)&1)?(mod-1):1)%mod*inv[k+2-i]%mod;
		(ans+=y*a%mod*b%mod)%=mod;
	}
	return ans;
}
string s;
int n;
int dp[2005][2005][2],pw10[2005],totn=0;
void solvedp(int len){
	memset(dp,0,sizeof(dp));
	dp[0][0][0]=1;
	for(int i=1;i<=n;i++){
		for(int j=0;j<=min(i,totn);j++){
			if(s[i]=='?'){
				(dp[i][j][0]+=dp[i-1][j][0])%=mod;
				(dp[i][j][1]+=dp[i-1][j][1]*prepw[10][len])%=mod;
				(dp[i][j+1][1]+=dp[i-1][j][0])%=mod;
				(dp[i][j][0]+=dp[i-1][j][1])%=mod;
			}
			else{
				(dp[i][j][0]+=dp[i-1][j][0])%=mod;
				(dp[i][j][1]+=dp[i-1][j][0]*(s[i]-'0'))%=mod;
				(dp[i][j][1]+=dp[i-1][j][1]*10)%=mod;
			}
		}
	}
}
int calc(int t){
	int ans=0;
	for(int i=1;i<=18;i++){
		//10^{i-1}\sim10^i-1
		solvedp(i);
		int L=pw10[i-1],R=min(pw10[i]-1,t);
		if(L>R) break;
		for(int j=0;j<=totn;j++){
			int num=(solve(R,j)+mod-solve(L-1,j))%mod;
//			cout<<dp[n][j][1]<<" "<<num<<"   ";
			(ans+=num*dp[n][j][1])%=mod;
		}
//		cout<<"\n";
	}
//	cout<<"\n";
	return ans;
}
signed main(){
//	freopen("input.in","r",stdin);
	fac[0]=1; for(int i=1;i<=2005;i++) fac[i]=fac[i-1]*i%mod;
	inv[2005]=qp(fac[2005],mod-2); for(int i=2004;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;
	pw10[0]=1; for(int i=1;i<=18;i++) pw10[i]=pw10[i-1]*10;
	for(int i=1;i<=2000;i++){
		prepw[i][0]=1;
		for(int j=1;j<=2000;j++) prepw[i][j]=prepw[i][j-1]*i%mod;
	}
	cin>>s; n=s.size(); s=" "+s;
	for(int i=1;i<=n;i++) totn+=(s[i]=='?');
	int L,R; cin>>L>>R;
//	cout<<calc(R);
//	return 0;
	L--;
	cout<<(calc(R)+mod-calc(L))%mod;
	return 0;
}
```

---

## 作者：luanmenglei (赞：1)

注意到最终的答案如果 $x$ 的位数固定，那么就是一个关于 $x$ 的出现次数的多项式，那么显然前缀和之后也是一个多项式，那么我们只需要求出 $\mathcal{O}(n \log n)$ 个点的点值就可以插值算答案了。

考虑怎么算出答案。

首先有一个朴素的 $\mathcal{O}(n^2)$ 的 dp 就是你记 $f_{i}$ 表示 $[1,i]$ 的所有情况的答案，然后转移的时候我们直接枚举上一个 $? \rightarrow \times$ 的位置在哪里就好了。

然后考虑怎么优化，注意到贡献可以写成一个类似于 $f_j \times \frac{s_j-s_i}{10^i}$ 的形式，那么我们直接维护 $f_js_j$ 的和还有 $f_j$ 的和就做完了。

时间复杂度 $\mathcal{O}(n^2 \log n)$。

参考代码：

```cpp
const int N = 4010;
const int M = 1e5 + 10;
const i64 P = 1e9 + 7;
int n, cnt;
i64 l, r, pw[N], pw10[M], ipw10[M], sum[N], val[N], pt[N];
char s[N];

i64 qpow(i64 a, i64 b) {
	i64 ret = 1;
	for (; b; b >>= 1) {
		if (b & 1)
			ret = ret * a % P;
		a = a * a % P;
	}
	return ret;
}

void mod(i64 &x, i64 y) {
	x += y;
	if (x >= P)
		x -= P;
}

i64 calc(int len, i64 val) {
	for (int i = 0; i <= n + 1; i ++)
		pw[i] = sum[i] = 0;
	val %= P;
	for (int i = n - 1; i >= 1; i --) {
		if (isdigit(s[i + 1]))
			pw[i] = pw[i + 1] + 1;
		else
			pw[i] = pw[i + 1] + len;
	}
	for (int i = n; i >= 1; i --) {
		sum[i] = sum[i + 1];
		if (s[i] == '?')
			mod(sum[i], pw10[pw[i]] * val % P);
		else
			mod(sum[i], pw10[pw[i]] * (s[i] - '0') % P);
	}
	i64 sumf = 1, sumfs = sum[1];
	for (int i = 1; i <= n; i ++) if (s[i] == '?') {
		i64 fval = (sumfs - sum[i] * sumf % P + P) % P * ipw10[pw[i - 1]] % P;
		mod(sumf, fval);
		mod(sumfs, fval * sum[i + 1] % P);
	}
	return sumfs;
}

i64 lagrange(i64 x, int d) {
	i64 ret = 0;
	for (int i = 1; i <= d; i ++) {
		i64 top = 1, bot = 1;
		for (int j = 1; j <= d; j ++)
			if (i != j)
				top = (x % P - pt[j] % P + P) % P * top % P,
				bot = (pt[i] % P - pt[j] % P + P) % P * bot % P;
		mod(ret, top * qpow(bot, P - 2) % P * val[i] % P);
	}
	return ret;
}

void solve() {
	cin >> (s + 1) >> l >> r;
	n = strlen(s + 1);
	for (int i = 1; i <= n; i ++)
		cnt += (s[i] == '?');
	cnt = (cnt + 1) / 2 + 2;
	pw10[0] = 1;
	for (int i = 1; i <= 40 * n; i ++)
		pw10[i] = pw10[i - 1] * 10 % P;
	for (int i = 0; i <= 40 * n; i ++)
		ipw10[i] = qpow(pw10[i], P - 2);
	i64 ans = 0;
	for (i64 L = 0, R, len = 10, i = 1; i <= 18; i ++, len = len * 10, L = R + 1) {
		R = len - 1;
		if (R < l || r < L)
			continue;
		for (i64 j = L; j <= L + cnt - 1; j ++) {
			pt[j - L + 1] = j;
			val[j - L + 1] = calc(i, j);
			mod(val[j - L + 1], val[j - L]);
		}
		i64 cl = max(L, l), cr = min(R, r);
		mod(ans, lagrange(cr, cnt));
		if (cl - 1 >= L)
			mod(ans, P - lagrange(cl - 1, cnt));
	}
	cout << ans << "\n";
}
```

---

## 作者：cmk666 (赞：1)

场上做法，和官方 sol 不太一样。

首先枚举 $x$ 的位数 $d$，那么答案一定是关于 $x$ 的 $O(n)$ 次多项式。

按照 `?` 把 $s$ 分段，称第 $i$ 段为第 $i$ 个 `?` 及其后面紧跟的数；特别的，第 $0$ 段为开头的数。记第 $i$ 段的数为 $num_i$，数的长度为 $len_i$。

考虑从左到右加入段，维护多项式 $f,g$，其中 $f$ 表示当前最后一个乘号之前的多项式之和，而 $g$ 表示整个式子的多项式之和。

初始时只有第 $0$ 段，有 $f=1,g=num_0$。加入第 $i$ 段时：

- 若填入乘号，则有 $f\gets g,g\gets g\cdot num_i$；
- 若填入 $x$，则 $f$ 不变，$g\gets g\cdot10^{d+len_i}+f\cdot(x\cdot10^{len_i}+num_i)$。

每次加入一段只要两种转移相加即可，运算都是简单的。于是可以 $O(n^2)$ 递推出答案的多项式。

对 $[\max(10^{d-1},L),\min(10^d-1,R)]$ 内的 $x$ 求和是典，直接套个[正整数 $k$ 次幂前缀和](//codeforces.com/problemset/problem/622/F)就行。这一步复杂度同样是 $O(n^2)$ 的。

综上，时间复杂度 $O(n^2\log R)$，小常数跑的飞快。

场上代码比较丑，不建议参考 >=<
```cpp
using MI = Modint < 1000000007 >;
using poly = vector < MI >;
char s[2009]; int n, len, pos[2009]; ll l, r, lp, rp;
poly f, g, ff, gg; MI pw[2009], num[2009], val[2009][2009], pre[2009], suf[2009], ans;
inline ll pw10(int x) { ll z = 1; while ( x-- ) z *= 10; return z; }
inline poly add(const poly &x, const poly &y) { ... } // 多项式加多项式
inline poly mul(const poly &x, MI y)  { ... } // 多项式乘常数
inline poly mulx(const poly &x) { ... } // 多项式乘 x
inline MI qry(int c, ll x) { ... } // 正整数 c 次幂前缀和
int main()
{
	For(i, 0, 2002) For(c, 0, 2000) val[c][i] = c ? val[c - 1][i] * i : 1;
	read_cstr(s + 1), n = strlen(s + 1), read(l, r);
	For(i, 0, n) pw[i] = i ? pw[i - 1] * 10 : 1;
	For(i, 1, n)
		if ( s[i] == '?' ) pos[++len] = i;
		else num[len] = num[len] * 10 + s[i] - '0';
	pos[len + 1] = n + 1;
	For(d, 1, 18)
	{
		lp = max(l, pw10(d - 1)), rp = min(r, pw10(d) - 1);
		if ( lp > rp ) continue;
		f.clear(), g.clear(), f.push_back(1), g.push_back(num[0]);
		For(i, 1, len)
			ff = add(f, g),
			gg = add(add(mul(add(f, g), num[i]), mul(g, pw[pos[i + 1] - pos[i] - 1 + d])),
					 mulx(mul(f, pw[pos[i + 1] - pos[i] - 1]))),
			f = move(ff), g = move(gg);
		For(i, 0, (int)g.size() - 1) ans += g[i] * ( qry(i, rp) - qry(i, lp - 1) );
	}
	return println(ans.v), 0;
}
```

---

## 作者：SDSXC (赞：0)

其他部分都和其他题解差不多，主要区别在于固定 $x$ 然后 $O(n)$ 算出答案的部分，怎么大家都 dp 的这么复杂。

我们考虑固定了一个 $x$，$x$ 是一个 $y$ 位数。

考虑我们从前往后扫的时候会发生什么。

* 如果是一个数字，我们观察每一个式子形如 $a_1\times a_2\times a_3\dots a_t$ 然后 $a_t\gets 10a_t+z$，那么这个式子的值显然就会先乘以 $10$，然后再加上 $z\times a_1\times a_2\times a_3\dots a_{t-1}$。这提示我们需要维护两个数，一个是目前扫到的位置所有乘积的和 $Ans$，一个是所有乘积去掉最后一项的和 $Sum$，扫到一个数字 $z$ 是就做 $Ans\gets 10Ans+zSum$。

* 如果是一个 '?'，那么考虑这两个值会如何变化。首先，如果这意味填乘号，那么$Sum\gets Sum+Ans$，如果填 $x$，那么 $Ans\gets Ans\times 10^y+xSum$，注意这里的 $Sum$ 是修改前的。

代码大概长这样。别的部分和其他题解大差不差，就是枚举位数，前缀和，插值，不过多赘述。


```cpp
ll calc(ll x,int y){
	x%=p;
	ll sum=1ll,ans=0ll;
	for(int i=1;i<=n;i++){
		if(s[i]=='?'){
			ll tmp=sum;
			sum=(sum+ans)%p;
			ans=(ans*(pw[y]%p)+tmp*x)%p;
		}
		else{
			ans=(ans*10ll+sum*(s[i]-'0'))%p;
		}
	}
	return ans%p;
}
```

---

## 作者：Purslane (赞：0)

# Solution

Reunite 推荐的题目。

注意到当 $|x|$ 一定时，$f(x)$ 是关于 $x$ 的不超过 $n$ 次多项式。

所以此时的 $\sum_{l \le x \le r,|x|=s} f(x)$ 就可以直接带入 $n$ 个点值拉格朗日插值求出。（但是这样实际上有 $\rm TLE$ 的风险。假设有 $c$ 个 $?$，那么最劣情况下是 $c$ 次多项式，所以需要 $c+2$ 个点值。这样常数就很小了 /tiao）

而 $f(x)$ 显然可以用前缀和优化 $O(n)$ 算。

复杂度为 $O(n^2 \log V)$。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=2000+10,MOD=1e9+7;
string S;
int n,c;
int qpow(int base,int p) {
	int ans=1;
	while(p) {
		if(p&1) ans=ans*base%MOD;
		base=base*base%MOD,p>>=1;
	}
	return ans;
}
int lag(vector<int> pos,int n) {
	int ans=0;
	n%=MOD;
	ffor(i,0,pos.size()-1) {
		int mul=pos[i],div=1;
		ffor(j,0,pos.size()-1) if(j!=i) mul=mul*(n-j)%MOD,div=div*(i-j)%MOD;
		ans=(ans+mul*qpow(div,MOD-2))%MOD;
	}
	return ans;
}
int solve(int xmul,int x) {
	int pre1=0,pre2=1;
	ffor(i,1,n) {
		if(S[i-1]=='?') {
			int v=pre1;
			pre1=(pre1*xmul+x*pre2)%MOD,pre2=(pre2+v)%MOD;
		}
		else pre1=(pre1*10+1ll*(S[i-1]-'0')*pre2)%MOD;
	}
	return pre1;
}
int calc(int nn) {
	if(nn==0) return 0;
	int l=0,r=0,ans=0,mul=1;
	while(1) {
		l=r+1,r=l*10-1,mul=mul*10%MOD;
		if(l>nn) return ans;
		vector<int> pos;
		int pre=0;
		ffor(i,0,c) pre=(pre+solve(mul,i))%MOD,pos.push_back(pre);
		ans=(ans+lag(pos,min(r,nn))-lag(pos,l-1))%MOD;
	}
	return ans;
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>S,n=S.size();
	for(auto id:S) if(id=='?') c++;
	int a,b;
	cin>>a>>b,cout<<((calc(b)-calc(a-1))%MOD+MOD)%MOD;
	return 0;
}
```

---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/P10167)

**题目大意**

> 给定长度为 $n$ 的表达式，由数字和 $\texttt ?$ 组成，定义 $f(x)$ 表示把 $\texttt ?$ 替换成乘号或者数字串 $x$，得到的每个表达式的值之和，给定 $L,R$，求 $\sum_{i=L}^Rf(i)$。
>
> 数据范围：$n\le 2000,L,R\le10^{18}$。

**思路分析**

考虑单个 $f(x)$ 如何求，dp 设 $f_i$ 表示第 $i$ 个问号之前的答案，枚举上一个乘号所在位置，$f_i\sum _{j<i} f_j\times D(j,i)$，其中 $D(j,i)$ 表示第 $j,i$ 个问号之间的 $\texttt{?}$ 全填 $x$ 的数字串权值。

注意到 $x$ 位数一定的时候，每个区间对应的值都是关于 $x$ 的一次函数，因此答案必然是关于 $x$ 的 $\mathcal O(n)$ 次函数，自然考虑拉格朗日插值。

我们可以对于每个位数 $d$，枚举 $\mathcal O(n)$ 个 $x$，并算出 $f(x)$，插值求出 $f$ 前缀和在 $L-1,R$ 处的点值，注意位数必须是 $d$。

此时 $D(j,i)$ 可以被写成关于 $i,j$ 的若干个项，维护前缀和即可 $\mathcal O(n)$ dp。

时间复杂度 $\mathcal O(n^2\log V)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=2005,MOD=1e9+7,i10=700000005;
ll ksm(ll a,int b=MOD-2) { ll s=1; for(;b;a=a*a%MOD,b>>=1) if(b&1) s=s*a%MOD; return s; }
char s[MAXN];
int n,m,a[MAXN];
ll L,R,f[MAXN],z[MAXN],dg[MAXN],pw[MAXN],ipw[MAXN],ans,cof[MAXN];
ll eval(int l,int r) { return (dg[r]-dg[l-1]*pw[r]%MOD*ipw[l-1]%MOD+MOD)%MOD; }
ll eval(ll x) {
	if(x<0) return 0;
	if(x<=n) return z[x];
	ll S=0,prd=1;
	for(int i=0;i<=n;++i) prd=(x-i)%MOD*prd%MOD;
	for(int i=0;i<=n;++i) {
		S=(S+prd*ksm((x-i)%MOD)%MOD*cof[i]%MOD*z[i])%MOD;
	}
	return S;
}
void solve(ll sz) {
	ll bas=pow(10,sz),len=ksm(10,sz+1),inv=ksm(len);
	for(int q=0;q<=n&&q<bas*9;++q) {
		ll o=(bas+q)%MOD;
		dg[0]=0,pw[0]=ipw[0]=1;
		for(int i=1;i<=n;++i) {
			ll d,v,iv;
			if(s[i]=='?') d=len,iv=inv,v=o;
			else d=10,iv=i10,v=s[i]-'0';
			dg[i]=(dg[i-1]*d+v)%MOD;
			pw[i]=pw[i-1]*d%MOD;
			ipw[i]=ipw[i-1]*iv%MOD;
		}
		memset(f,0,sizeof(f)),f[0]=1;
		ll s1=1,s2=0;
		for(int i=1;i<=m;++i) {
			f[i]=(s1*dg[a[i]-1]+(MOD-s2)*pw[a[i]-1])%MOD;
			s1=(s1+f[i])%MOD;
			s2=(s2+f[i]*dg[a[i]]%MOD*ipw[a[i]])%MOD;
		}
		z[q]=f[m];
	}
	for(int i=1;i<=n;++i) z[i]=(z[i]+z[i-1])%MOD;
	if(R>=bas) ans=(ans+eval(min(10*bas-1,R)-bas))%MOD;
	if(L-1>=bas) ans=(ans+MOD-eval(min(10*bas-1,L-1)-bas))%MOD;
}
signed main() {
	scanf("%s%lld%lld",s+1,&L,&R),n=strlen(s+1);
	for(int i=0;i<=n;++i) {
		cof[i]=1;
		for(int j=0;j<=n;++j) if(i!=j) cof[i]=cof[i]*(i+MOD-j)%MOD;
		cof[i]=ksm(cof[i])%MOD;
	}
	for(int i=1;i<=n;++i) if(s[i]=='?') a[++m]=i;
	a[++m]=n+1;
	for(int i=0;i<18;++i) solve(i);
	printf("%lld\n",ans);
	return 0;
}
```

---


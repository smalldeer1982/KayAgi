# 国土规划

## 题目描述

一个国家的领土中，有 $n$ 座城市和 $m$ 条道路。这 $m$ 条道路将 $n$ 座城市连通，即任意两座城市存在道路直接或间接可达。两座城市之间可能有多条道路，但不存在一条道路两端连通同一座城市。

该国家要选定一些城市，重点发展。具体而言，每个城市有一个重要值 $a_i$，其中 $a_i=0$ 表示城市不需要重点发展，如果 $a_i=1$ 表示城市需要重点发展。初始时所有 $a_i=0$。

该国家有 $q$ 次规划，每次规划会选定一个城市 $x$，令 $a_x \gets 1-a_x$。

每次规划后，作为首席规划师的你要求出这样的城市 $p$ 的数量，使得 $a_p=0$，且城市 $p$ 消失（连带与城市 $p$ 直接相连的道路一起消失）后，任意满足 $a_u=a_v=1$ 的两个城市 $u,v$ 均存在道路直接或间接可达。

需要注意，规划只是在纸面上假想的，并不会真的删去任何城市。

## 说明/提示

**【样例解释】**

以第四次规划为例，此时需要重点发展的城市为 $1$ 和 $4$，那么 $a_p=0$ 的城市只有 $2$ 和 $3$。如果城市 $2$ 消失，那么存在路径 $1-3-4$。如果城市 $3$ 消失，那么 $1$ 和 $4$ 互相不可到达。所以满足条件的城市只有 $2$，答案为 $1$。

**【数据范围】**

- 对于 $15\%$ 的数据，$n,q \le 300$，$m \le 500$。
- 对于另外 $15\%$ 的数据，$m=n-1$，且对于所有道路，$v=u+1$。
- 对于另外 $20\%$ 的数据，$m=n-1$。

对于所有数据，$2 \le n \le 10^5$，$n-1\le m \le 2 \times 10^5$，$1 \le q \le 2 \times 10^5$，$1 \le u,v,x \le n$，$u \neq v$。

## 样例 #1

### 输入

```
4 4 6
1 2
2 3
3 1
3 4
1
3
3
4
4
1```

### 输出

```
3
2
3
1
3
4```

# 题解

## 作者：251Sec (赞：6)

设 $a_i=1$ 的点为关键点。

补集转化，求哪些点删去后存在关键点对互相不可达。对无向图建立圆方树，则这些点就是关键点虚树上的所有圆点。现在问题变为单点加入、单点删除、询问虚树包含圆点数量。

虚树上包含的圆点实际上相当于所有关键点到根节点（不妨设为 $1$）的路径的并，再去掉所有关键点 LCA 的父亲到根节点的路径。

先考虑前者如何计算，如果将所有关键点按照 DFS 序排序，设 $P(u)$ 代表 $u$ 到根的路径上的圆点数量，$p_{1..k}$ 为关键点，则所求为 $\sum\limits_{i=1}^k P(p_i)-P(\text{lca}(p_i,p_{i-1}))$，其中 $p_0=1$。用 set 维护 DFS 序，每次加点删点引起的变化是 $O(1)$。

后者是容易的，只需要求出一个动态点集的 LCA，它的做法有很多。这里我们给出一种比较简单的做法：直接考虑 DFS 序最小和最大的点，点集里所有点的 LCA 就是这两个点的 LCA，结合上一段维护的 set，我们可以容易地实现这一部分。

总复杂度 $O((n+q) \log n)$。

---

## 作者：min_inf (赞：6)

早上起床看了一眼秒掉了，然后被抓去实验考了，非常生气。

建出圆方树，$p$ 满足要求即为所有黑点都在以 $p$ 为根的一个子树里。

考虑当前黑点集合的 LCA：

- 如果 $p$ 在 这个 LCA 子树外，一定满足要求。
- 否则 $p$ 子树内不能有黑点。

这个 LCA 就是黑点中 DFS 序最小和最大的点的 LCA，第一种情况可以直接算，第二种可以线段树维护区间最小值个数，修改的时候树剖实现祖先加即可。

时间复杂度 $O(n+m+q\log^2n)$。

[code](https://www.luogu.com.cn/paste/s40801xd)。

---

## 作者：kkxacj (赞：5)

#### 前言
看见是四倍经验就过来了。

#### 圆方树 

会的可以跳过。

前置知识：点双连通分量。

先考虑只有两个点 $x,y$ 的时候怎么办。

很容易发现，题目要求的是 $x$ 到 $y$ 的所有路径中不包含 $x,y$ 不是必须经过的点有哪些。

考虑反过来，求 $x$ 到 $y$ 的所有路径中不包含 $x,y$ 必须经过的点有哪些。


发现对于点 $x,j$ 
**如果 $x$ 和 $j$ 在一个环内，那么删掉除它两外的任意点，它两都可以互相到达。**

那么这样的 $j$ 就**一定不是之间必须经过的点**。

那么就可以缩点建圆方树了，所谓圆方树，就是对于每个点双连通分量建一个虚点，也就是方点，然后互相连边就行了。

$x$ 到 $y$ 在这颗树上的路径上非虚点的个数就是 $x$ 到    $y$ 之间必须经过的点。

[P4320 道路相遇](https://www.luogu.com.cn/problem/P4320)

#### 思路

回到本题，可以发现本题可能存在多个点，例如下图为原图转成圆方树后的样子。

![](https://cdn.luogu.com.cn/upload/image_hosting/v3ekmzdr.png)

其中**红色点**为题目给出的**重点城市**，可以发现，不算**红色点**的情况下，$3,5$ 之间必须经过的点为 $3,4$ 之间必须经过的点加上 $4,5$ 之间必须经过的点。

考虑按照 `dfs` 遍历顺序排序，每相邻两个点算一次贡献，第 $1$ 个和最后一个点也要算，然后发现每个点贡献都算了两次，除二就行了。

##### 注意：答案还要特判第 $1$ 个和最后一个点的 `lca` 是否是非虚点，是就加上，因为没有算到。

[P4606 [SDOI2018] 战略游戏](https://www.luogu.com.cn/problem/P4606)

对于此题的动态加入删除，直接 `set` 维护就行了，每次最多更改几次贡献。

**code**

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,q,dep[1000010],dep1[1000010],cnt1,dfn[1000010],dfn1[1000010],st[1000010],top,f[1000010],low[1000010],v[1000010],x,y,cnt,o,lca,t,o1,sum1;
vector<int>w[1000010],w1[1000010]; 
set<int>se;
void dfs(int x)
{
	int sum = 0;
	st[++top] = x;
	low[x] = dep[x] = ++cnt;
	for(int i = 0;i < w[x].size();i++)
	{
		if(!dep[w[x][i]])
		{
			dfs(w[x][i]);
			low[x] = min(low[x],low[w[x][i]]);
			if(low[w[x][i]] == dep[x])
			{
				o++;
				while(st[top + 1] != w[x][i]) w1[st[top]].push_back(o),w1[o].push_back(st[top]),top--;
				w1[o].push_back(x),w1[x].push_back(o); 
			}
		}
		else low[x] = min(low[x],dep[w[x][i]]);
	}
}
int son[1000010],siz[1000010];
void dfs1(int x,int fa)
{
	dep1[x] = dep1[fa] + 1; f[x] = fa; siz[x] = 1;
	for(int i = 0;i < w1[x].size();i++)
	{
		if(w1[x][i] == fa) continue;
		dfs1(w1[x][i],x); siz[x] += siz[w1[x][i]];
		if(siz[son[x]] < siz[w1[x][i]]) son[x] = w1[x][i];
	}
}
int tot1[1000010],ans[1000010];
void dfs2(int x,int y)
{
	tot1[x] = y; dfn[x] = ++cnt1; dfn1[cnt1] = x;
	ans[x] = ans[f[x]] + (x <= n);
	if(!son[x]) return;
	dfs2(son[x],y);
	for(int i = 0;i < w1[x].size();i++)
	{
		if(w1[x][i] == son[x] || w1[x][i] == f[x]) continue;
		dfs2(w1[x][i],w1[x][i]);
	}
}
void Lca(int x,int y)
{
	while(tot1[x] != tot1[y])
	{
		if(dep1[tot1[x]] > dep1[tot1[y]]) x = f[tot1[x]];
		else y = f[tot1[y]];
	}
	if(dep1[x] > dep1[y]) lca = y;
	else lca = x;
}
int sum;
inline void check(int x,int f)
{
	v[x] = !v[x];
	if(f == -1) se.insert(dfn[x]);
	set<int>::iterator it,it1,it2;
	it = se.find(dfn[x]);
	if(it == se.begin())
	{
		it++; 
		if(it != se.end()) 
		{
			Lca(dfn1[*se.begin()],dfn1[*it]),sum -= (ans[dfn1[*se.begin()]] + ans[dfn1[*it]] - 2*ans[lca])*f; 
			Lca(dfn1[*se.begin()],dfn1[*se.rbegin()]),sum -= (ans[dfn1[*se.begin()]] + ans[dfn1[*se.rbegin()]] - 2*ans[lca])*f; 
			Lca(dfn1[*it],dfn1[*se.rbegin()]),sum += (ans[dfn1[*it]] + ans[dfn1[*se.rbegin()]] - 2*ans[lca])*f; 
			Lca(dfn1[*se.begin()],dfn1[*se.rbegin()]),sum1 -= (lca <= n)*f;
			Lca(dfn1[*it],dfn1[*se.rbegin()]),sum1 += (lca <= n)*f;
		}
		else sum1 -= 1*f;
	}
	else
	{
		it++; 
		if(it == se.end())
		{
			it--; it1 = it; it1--;
			if(se.size() != 1)
			{
				Lca(dfn1[*it1],dfn1[*it]),sum -= (ans[dfn1[*it1]] + ans[dfn1[*it]] - 2*ans[lca])*f; 
				Lca(dfn1[*se.begin()],dfn1[*it1]),sum += (ans[dfn1[*se.begin()]] + ans[dfn1[*it1]] - 2*ans[lca])*f;
				Lca(dfn1[*se.begin()],dfn1[*it]),sum -= (ans[dfn1[*se.begin()]] + ans[dfn1[*it]] - 2*ans[lca])*f;
				Lca(dfn1[*se.begin()],dfn1[*it]),sum1 -= (lca <= n)*f;
				Lca(dfn1[*se.begin()],dfn1[*it1]),sum1 += (lca <= n)*f;
			}
		}
		else
		{
			it1 = it,it--;
			it2 = it,it2--;
			Lca(dfn1[*it1],dfn1[*it2]),sum += (ans[dfn1[*it1]] + ans[dfn1[*it2]] - 2*ans[lca])*f; 
			Lca(dfn1[*it1],dfn1[*it]),sum -= (ans[dfn1[*it1]] + ans[dfn1[*it]] - 2*ans[lca])*f; 
			Lca(dfn1[*it2],dfn1[*it]),sum -= (ans[dfn1[*it2]] + ans[dfn1[*it]] - 2*ans[lca])*f; 
		}
	}
	if(f == 1) se.erase(dfn[x]);	
}
int main()
{
	scanf("%d%d%d",&n,&m,&q);
	for(int i = 1;i <= m;i++) scanf("%d%d",&x,&y),w[x].push_back(y),w[y].push_back(x);
	o = n;
	dfs(1); dfs1(1,0); dfs2(1,1);
	while(q--)
	{
		scanf("%d",&x);
		if(v[x] == 1) check(x,1);
		else check(x,-1);
		printf("%d\n",n-(sum>>1)-sum1);
	}	
	return 0;
}
```

---

## 作者：Mu_leaf (赞：3)

圆方树练手好题，思路几乎能一眼出，~~主要是一些细节，我太弱总是莫名其妙的报错。~~

## [思路]
令 $a_i=1$ 的点为黑点。

考虑对所求答案取个补集，则需要求的是删掉这个点后有至少一对黑点变得不可达。

显然要求的点 $P$，就是需要求割点数。联想到圆方树。

考虑每个黑点的贡献分类讨论：

设 $p_{1..k}$ 为黑点按 DFS 序排序的序列，然后这次询问的 $x$ 插入 $p$ 后的位置为 $i$，$dis_{u,v}$ 表示 $u$ 到 $v$ 的圆点数量。

- $i=1$，则它只可能和后面的点有关系，于是就有当前点到当前点和后面点的 $lca$ 的路径上的圆点数。
- $1 < i <k $，则它的贡献和前面的点和后面的点有关，考虑减去原本 $i-1,i+1$ 的贡献，在按 $i=1$ 时的方案计算即可，这里不再过多赘述。
- $i=k$，和 $i=1$ 同理。

特殊的，当只有一个黑点的时候显然答案为 $n-1$。

思考怎么维护 $p$。

其实直接用 set 维护 DFS 序即可，每次加入一个点的贡献都是可以用树剖在 $O(\log^2 n)$ 的时间里求出来。

删除这个点同理，与加点相反。

---

## 作者：Fa_Nanf1204 (赞：1)

### 分析：
比较典的一道圆方树题。

题目要求的是删掉一个城市后，重点城市仍可达的这些城市数量。考虑转化为总城市数量减去重点城市之间所必须经过的城市数量。

此时就可以建圆方树来维护了，首先对于每个圆点设其权值为 $1$，每个方点设其权值为 $0$，将权值放到其与父亲相连的那条边上，那么此时即可快速查询两个重点城市之间的边权和。

来考虑怎么计算重点城市之间所必须经过的城市数量。考虑按照 DFS 序将所有重点城市排序，计算相邻的重点城市的权值和，然后再加上第一个城市到最后一个城市的权值和，那么此时发现每条边算了两遍，除以 $2$ 即可。如果第一个城市和最后一个城市的最近公共祖先也是圆点则加 $1$，因为此时没有统计到它，这样就计算完重点城市之间所必须经过的城市数量了。

考虑怎么处理修改操作，易想到用 set 维护这个有序序列，每次删除或加入时，只用维护相邻的元素的答案即可，再加上一小点分讨即可。

最后时间复杂度是 $O(n+m+q \log n)$。
### Code:

```cpp
#include<bits/stdc++.h>
#define N 200005
using namespace std;
int n,m,q,tot=0,cnt=0;
vector<int> g[N],G[N];
stack<int> s;
set<int> se;
int dfn[N],low[N];
int deep[N],fa[N][20],dis[N],id[N]; 
void tarjan(int x){
    dfn[x]=low[x]=++tot;
    s.push(x);
    for(auto i:g[x]){
        if(!dfn[i]){
            tarjan(i);
            low[x]=min(low[x],low[i]);
            if(low[i]>=dfn[x]){
            	cnt++;
            	while(s.top()!=i){
            		G[cnt].push_back(s.top());
            		G[s.top()].push_back(cnt);
            		s.pop();
				}
				G[cnt].push_back(s.top());
            	G[s.top()].push_back(cnt);
            	s.pop();
            	G[cnt].push_back(x);
            	G[x].push_back(cnt);
			}
        }
        else if(dfn[i]<low[x]){
            low[x]=dfn[i];
        }
    }
}
void dfs(int x,int f){
	deep[x]=deep[f]+1;
	fa[x][0]=f;
	dfn[x]=++tot;
	id[tot]=x;
	for(int i=1;i<=19;i++){
		fa[x][i]=fa[fa[x][i-1]][i-1];
	} 
	dis[x]=dis[f]+(x<=n); 
	for(auto i:G[x]){
		if(i==f) continue;
		dfs(i,x);
	}
}
int lca(int x,int y){
	if(deep[x]<deep[y]) swap(x,y);
	for(int i=19;i>=0;i--){
		if(deep[fa[x][i]]>=deep[y]) x=fa[x][i];
	}
	if(x==y) return x;
	for(int i=19;i>=0;i--){
		if(fa[x][i]!=fa[y][i]){
			x=fa[x][i],y=fa[y][i];
		}
	}
	return fa[x][0];
}
int a[N],ans;//ans表示除去++和首尾的答案 
int solve(int v){
	if(a[v]==1){
		se.insert(dfn[v]);
		if(se.size()==1) return n-1;
		set<int>::iterator it,it1,it2;
		it=se.find(dfn[v]);
		bool f=0;
		it++;
		if(it==se.end()) f=1;
		it--;
		if(it==se.begin()){
			it1=it;
			it1++;
			ans+=dis[id[*it]]+dis[id[*it1]]-2*dis[lca(id[*it],id[*it1])];
		}
		else if(f){
			
			it1=it;
			it1--;
			//cout<<"dick"<<ans<<' '<<dis[id[*it]]<<' '<<dis[id[*it1]]<<' '<<lca(id[*it],id[*it1])<<' ';
			ans+=dis[id[*it]]+dis[id[*it1]]-2*dis[lca(id[*it],id[*it1])];
			//cout<<ans<<'\n';
		}
		else{
			it1=it;
			it1++;
			ans+=dis[id[*it]]+dis[id[*it1]]-2*dis[lca(id[*it],id[*it1])];
			it2=it;
			it2--;
			ans+=dis[id[*it]]+dis[id[*it2]]-2*dis[lca(id[*it],id[*it2])];
			ans-=dis[id[*it1]]+dis[id[*it2]]-2*dis[lca(id[*it1],id[*it2])];
		}
	}
	else{
		
		if(se.size()==1){
			ans=0;
			se.erase(dfn[v]);
			return n;
		}
		if(se.size()==2){
			ans=0;
			se.erase(dfn[v]);
			return n-1;
		}
		set<int>::iterator it,it1,it2;
		it=se.find(dfn[v]);
		bool f=0;
		it++;
		if(it==se.end()) f=1;
		it--;
		if(it==se.begin()){
			it1=it;
			it1++;
			ans-=dis[id[*it]]+dis[id[*it1]]-2*dis[lca(id[*it],id[*it1])];
		}
		else if(f){
			it1=it;
			it1--;
			ans-=dis[id[*it]]+dis[id[*it1]]-2*dis[lca(id[*it],id[*it1])];
		}
		else{
			it1=it;
			it1++;
			ans-=dis[id[*it]]+dis[id[*it1]]-2*dis[lca(id[*it],id[*it1])];
			it2=it;
			it2--;
			ans-=dis[id[*it]]+dis[id[*it2]]-2*dis[lca(id[*it],id[*it2])];
			ans+=dis[id[*it1]]+dis[id[*it2]]-2*dis[lca(id[*it1],id[*it2])];
		}
		se.erase(dfn[v]);
	}
	int LCA=lca(id[*se.begin()],id[*se.rbegin()]);
	return n-((ans+dis[id[*se.begin()]]+dis[id[*se.rbegin()]]-2*dis[LCA])/2+(LCA<=n));
}
int main(){
	cin.tie(),cout.tie(),ios::sync_with_stdio(0);
	cin>>n>>m>>q;
	for (int i=1;i<=m;i++){
		int u,v;
		cin>>u>>v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	tot=0;
	cnt=n;
	tarjan(1);
	tot=0;
	dfs(1,0);
	while(q--){
		int v;
		cin>>v;
		a[v]^=1;
		cout<<solve(v)<<'\n';
	} 
 	return 0;
} 
```

---

## 作者：hlsnqdmz (赞：1)

## 题意解释
简单来说就是让你去找重点发展城市路径上的必经的非重点发展城市，再加上重点发展城市的个数，所有城市个数减去这个数就是答案了。既然是从图上找必经点，我们可以自然地想到圆方树，路径上经过的圆点就是必经点了（毕竟重点发展城市的路径上本身也算必经点）。

## 错误方法一
找必经点我们也会想到另一道题，作为圆方树的经典例题，它的出场率可不低：[战略游戏](https://www.luogu.com.cn/problem/P4606)。所以我当初直接拿战略游戏的树剖线段树实现区间推平求和的代码改了一下就提交了，结果[ T 飞了](https://www.luogu.com.cn/problem/P4606)。然后一看，两道题数据大小差不多，但是本题时限是战略游戏的五分之一（但是不至于差这么多吧……）。所以我们要用更快的方式。

## 错误方法二
没错，这个方法还是会[ T 飞](https://www.luogu.com.cn/record/216149795)，但是正解需要这个方法。我们先求出从 1 号点到每个点（例如点 $u$）经过的圆点个数 `d[u]`，然后按时间戳把各个重点发展城市从小到大排序，求出每两个排序后相邻的点之间的圆点个数，这可以用 `d[u]+d[v]-2*d[lca]` 算出，最后再加上第一个点到最后一个点路径上的圆点个数，我们发现除了第一个点和最后一个点的 LCA 可能是圆点但没被算入，其他圆点都被算了两次，将得出的数除以二，如果第一个点和最后一个点的 LCA 是圆点就加上一。这就是所有的必经点，拿所有点的个数减去它就得到答案了。

## 正确做法
对于这道题，我们发现每次询问与上一次重点发展城市的个数只差距一个，而且其他不变。比起[战略游戏](https://www.luogu.com.cn/problem/P4606)每次询问都不同要好得多（这应该也是时限小的原因）。所以我们可以这个性质来解决这道题。

我们先考虑加点和删点的区别，为了方便维护重点发展城市的个数，我们使用 `set` 来维护，这样还可以帮我们依照时间戳来排序。然后我们发现删点相较于加点就是把减去的贡献改为加上，加上的贡献改为减去就行了，所以我们只要在执行加减贡献的函数再传个参 $f$，使它加点时为 1，删点时为 -1。

接下来考虑怎么计算加点产生和减少的贡献（删点同理），这里要用到分类讨论，假如加入后只有一座重点发展城市，那么产生的贡献只有它自己。否则如果它是 `set` 的开头，即它是时间戳最小的数，他需要加上与第二小的数产生的贡献和最后一个数产生的贡献，第二小的数和最后一个数产生的贡献也要减去。如果是结尾那也差不多。而如果是中间的一个数，就减去它前一个和后一个数产生的贡献，在加上自身分别与前一个数和后一个数产生的贡献。

另外注意还要用一个变量储存第一个数和最后一个数的 LCA 是否是圆点，为了格式好看（虽然也没多好看），这里判断只有一个重点发展城市并没有直接返回，而是修改了这个变量（~~毕竟不修改总会错，而且这个函数没有返回值~~），记得每次算第一个和最后一个点贡献是也要修改这个变量的值，另外别忘了乘上 $f$ 以及贡献算前加点，算完才删点，还有 `set` 的 `end()` 返回的不是最后一个数，要用 `rbegin()`，但它又不能拿来比较。

奉上我丑陋的代码：
```
//Just Sayori
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <set>
#include <cstring>
#define ll long long
#define rnt register int
#define gr getchar
#define pr putchar
#define N 400005
#define M 1000000007
using namespace std;

inline ll read()
{
    ll x = 0, f = 1;
    char ch = gr();
    while (ch < '0' || ch > '9')
        ch == '-' ? f = -1, ch = gr() : ch = gr();
    while (ch >= '0' && ch <= '9')
        x = (x << 3) + (x << 1) + (ch ^ 48), ch = gr();
    return x * f;
}

inline void write(ll x)
{
    static int sta[39], top = 0;
    if (x < 0)
        pr('-'), x = -x;
    do
        sta[++top] = x % 10, x /= 10;
    while (x);
    while (top)
        pr(sta[top--] ^ 48);
}

struct Edge
{
    struct edge
    {
        int v, next;
    } e[N << 2];
    int head[N << 1], cnt;
    inline void tdd(int u, int v)
    {
        e[++cnt] = {v, head[u]}, head[u] = cnt;
        e[++cnt] = {u, head[v]}, head[v] = cnt;
    }
} g, t;
int n, m, q, u, v, tp, ans, ans1, bcc, cnt, lca, tot;
int dfn[N], low[N], stack[N];
int a[N], d[N], fa[N], sz[N], to[N], top[N], bson[N], deep[N];
set<int> st;

void tarjan(int u)
{
    dfn[u] = low[u] = ++cnt;
    stack[++tp] = u;
    for (rnt i = g.head[u]; i; i = g.e[i].next)
    {
        int v = g.e[i].v;
        if (!dfn[v])
        {
            tarjan(v), low[u] = min(low[u], low[v]);
            if (low[v] == dfn[u])
            {
                bcc++;
                while (stack[tp + 1] != v)
                    t.tdd(stack[tp--], bcc);
                t.tdd(u, bcc);
            }
        }
        else
            low[u] = min(low[u], dfn[v]);
    }
}

void dfs1(int u, int f)
{
    d[u] = d[f] + (u <= n);
    fa[u] = f, sz[u] = 1;
    deep[u] = deep[f] + 1;
    for (rnt i = t.head[u]; i; i = t.e[i].next)
    {
        int v = t.e[i].v;
        if (v == f)
            continue;
        dfs1(v, u);
        sz[u] += sz[v];
        if (sz[v] > sz[bson[u]])
            bson[u] = v;
    }
}

void dfs2(int u, int tp)
{
    top[u] = tp;
    dfn[u] = ++tot;
    to[tot] = u;
    if (!bson[u])
        return;
    dfs2(bson[u], tp);
    for (rnt i = t.head[u]; i; i = t.e[i].next)
    {
        int v = t.e[i].v;
        if (v == fa[u] || v == bson[u])
            continue;
        dfs2(v, v);
    }
}

int get_lca(int a, int b)
{
    while (top[a] != top[b])
    {
        if (deep[top[a]] < deep[top[b]])
            swap(a, b);
        a = fa[top[a]];
    }
    if (deep[a] > deep[b])
        swap(a, b);
    return a;
}

void work(int x, int f)
{
    if (a[x])//算前加点
        st.insert(dfn[x]);
    auto now = st.find(dfn[x]);
    if (now == st.begin())//如果是开头
        if (st.size() != 1)//不止一个
        {
            auto rs = next(now);
            int u = to[*now], v = to[*rs];
            ans += (d[u] + d[v] - 2 * d[get_lca(u, v)]) * f;
            v = to[*st.rbegin()];
            ans += (d[u] + d[v] - 2 * d[get_lca(u, v)]) * f, ans1 += (get_lca(u, v) <= n) * f;
            u = to[*rs];
            ans -= (d[u] + d[v] - 2 * d[get_lca(u, v)]) * f, ans1 -= (get_lca(u, v) <= n) * f;
        }
        else//只有一个
            ans1 += 1 * f;
    else if (next(now) == st.end())//如果是结尾
    {
        auto ls = prev(now);
        int u = to[*ls], v = to[*now];
        ans += (d[u] + d[v] - 2 * d[get_lca(u, v)]) * f;
        u = to[*st.begin()];
        ans += (d[u] + d[v] - 2 * d[get_lca(u, v)]) * f, ans1 += (get_lca(u, v) <= n) * f;
        v = to[*ls];
        ans -= (d[u] + d[v] - 2 * d[get_lca(u, v)]) * f, ans1 -= (get_lca(u, v) <= n) * f;
    }
    else//是中间的数
    {
        auto ls = prev(now), rs = next(now);
        int u = to[*ls], v = to[*rs], w = to[*now];
        ans -= (d[u] + d[v] - 2 * d[get_lca(u, v)]) * f;
        ans += (d[u] + d[w] - 2 * d[get_lca(u, w)]) * f;
        ans += (d[v] + d[w] - 2 * d[get_lca(v, w)]) * f;
    }
    if (!a[x])//算完删点
        st.erase(st.find(dfn[x]));
}

int main()
{
    bcc = n = read(), m = read(), q = read();
    for (rnt i = 1; i <= m; i++)
        u = read(), v = read(), g.tdd(u, v);
    tarjan(1), dfs1(1, 0), dfs2(1, 1);
    for (rnt i = 1; i <= q; i++)
    {
        u = read();
        a[u] ^= 1;
        if (a[u])//添加
            work(u, 1);
        else//删除
            work(u, -1);
        write(n - ans / 2 - ans1), pr(10);
    }
    return 0;
}
```
顺带一提，这道题也有大佬写了线段树做法，但这个方法跑的更快。

### 感谢您的观看！

---


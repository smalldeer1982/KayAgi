# 残雪

## 题目背景

[English statement](https://www.luogu.com.cn/problem/U500139). **You must submit your code at the Chinese version of the statement.**

如果我再和你走在同一条路上的话，我也会把远方的星星讲过无限的话再跟你说一遍吧。

你微笑着把竖起的手指放在嘴角，似乎是在暗示我，原来你就是远方的 Polestar 罢了。

令人伤感的事情是，这个世界上没有了小王子，也没有了去年今日的那位飞行员。

试问闲愁都几许？一川烟草，满城风絮，梅子黄时雨。

![](https://pic.imgdb.cn/item/670fd597d29ded1a8c604148.png)

## 题目描述

给出集合 $S$。我们定义一个 $\tt 01$ 串 $t$ 是不好的，当且仅当存在 $k \in S$，使得 $t$ 包含一个长度为 $2k$ 的子串 $t'$，且 $t'$ 恰好包含 $k$ 个 $\tt 0$ 和 $k$ 个 $\tt 1$。对立地，一个 $\tt 01$ 串如果不是不好的，那么它就是好的。

小 Y 有 $q$ 组询问，每次给出 $L, R, m, n$，表示 $S = \{x \in \N_+ \mid L \leq x \leq R\}$，判断是否存在一个好的字符串 $t$ 满足 $t$ 恰好包含 $m$ 个 $\tt 0$ 和 $n$ 个 $\tt 1$。

## 说明/提示

### 样例解释

- 对于第一组数据，因为包含 $\tt 0, 1$ 但 $L = 1$，所以一定不合法。
- 对于第二组数据，存在 $t = \tt 0011111100$。容易证明这是合法的。
- 对于第三组数据，事实确实如此。
- 对于其它数据，暂时不能给你一个明确的答复。

### 数据规模与约定

**本题采用捆绑测试和子任务依赖。**

- Subtask 0（0 pts）：样例。
- Subtask 1（13 pts）：$q \leq 10^3$，$n + m \leq 14$，$R \leq 14$。
- Subtask 2（20 pts）：$\sum \max(n, m, L, R) \leq 5\times 10^3 + 5$。依赖于子任务 $0$。
- Subtask 3（13 pts）：$\sum \max(n, m, L, R) \leq 10^7 + 100$。依赖于子任务 $0 \sim 2$。
- Subtask 4（13 pts）：$L = R$。
- Subtask 5（41 pts）：无特殊限制。依赖于子任务 $0 \sim 4$。

对于所有数据，保证 $1 \leq q \leq 10^5$，$1 \leq L \leq R \leq 10^{18}$，$0 \leq n, m \leq 10^{18}$，$n + m \geq 1$。

## 样例 #1

### 输入

```
5
1 2 3 5
3 3 4 6
5 6 11 13
10 15 33 22
10 13 11 11```

### 输出

```
No
Yes
No
Yes
No```

# 题解

## 作者：irris (赞：13)

> 构造 / 贪心

To Asteroid B-612。

首先特判 $L = 1$ 的情况。

我们钦定 $n \leq m$，然后我们不关心这个 $m$ 了，我们只想计算一个最小的 $m_0$ 使得答案是 `Yes`。

想象一下，为什么要求的是最小的 $m_0$：假如 $m = 3n - 3$，我们构造 $t = \tt 1000100010001\dots10001$，即在每相邻两个 $\tt 1$ 中间插入 $3$ 个 $\tt 0$，一定是合法的。而如果 $m = k$ 时合法，$m = k + 1$ 时我们只要在任意位置插入一个 $\tt 0$ 即可。所以 $m \geq 3n - 3$ 时答案一定是 `Yes`，也就是说 $m_0 \leq 3n - 3$。

---
---

上面的感性理解具有疏漏！「**而如果 $\bm{m = k}$ 时合法，$\bm{m = k + 1}$ 时我们只要在任意位置插入一个 $\bm{0}$ 即可**」，这真的显然吗？我们就要引出另一个话题：

考虑所有的 $L \leq k \leq R$，我们知道在每个长度为 $2k$ 的区间 $[l, r]$ 里，$\tt 0$ 的出现次数和 $\tt 1$ 的出现次数（分别记为 $cnt_0(l, r)$ 和 $cnt_1(l, r)$）不相等。设 $t$ 的下标范围为 $1 \sim N$（$N = n + m$），那么

定义 $f_k(i) = \dfrac{cnt_0(i, i + 2k - 1) - cnt_1(i, i + 2k - 1)}{2}$，那么我们知道 $f_k(1) \dots f_k(N - 2k + 1)$ 都不能为 $0$。并且考虑 $f_k(j) - f_k(j - 1)$，这是一个 $[l, r]$ 窗口滑动的过程，只会加入一个字符、删除一个字符，因此我们得到 $f_k(j) - f_k(j - 1) \in \{-1, 0, 1\}$。所以在定义域（整数）和值域（整数）下，$f_k$ 是一个连续函数！这也就告诉我们，要么 $\forall i$，$f_k(i) > 0$；要么 $\forall i$，$f_k(i) < 0$。

此外，我们还要证明若 $f_L(1) > 0$，则对所有 $L \leq k \leq R$ 都有 $f_k(1) > 0$，反之亦然；而这是不难说明的：考虑 $k \gets k + 1$，则 $\dfrac{cnt_0 - cnt_1}{2}$ 最多增加 $1$，最多减少 $1$，也是连续的！故而同样不可能出现对某个 $k$ 大于 $0$ 而对于另一个 $k'$ 小于 $0$ 的情况。

所以只要我们能够证明，在最优情况下一定有 $cnt_0 > cnt_1$ 的构造，也就是 $f_k(i) > 0$，那么任意插入 $\tt 0$ 不会减小任何 $f_k(i)$，所以就不会产生不合法情况，即可！

假设，存在一个 $n$ 个 $\tt 1$ 和 $m$ 个 $\tt 0$ 的字符串 $t$，满足对于所有情况下 $cnt_0 < cnt_1$。令 $t'$ 表示 $t$ 中 $\tt 0, 1$ 反转后得到的字符串，那么它应当有 $m$ 个 $\tt 1$ 和 $n$ 个 $\tt 0$，并且 $cnt_0 > cnt_1$！我们只要删去 $m - n$ 个 $\tt 1$，即可得到 $t''$，它拥有 $n$ 个 $\tt 1$ 和 $n$ 个 $\tt 0$，并且任意删除 $\tt 1$ 不会增大任何 $f_k(i)$，那么得到的 $t''$ **也是合法的，并且 $\bm 0$ 的个数不增大且 $\bm{cnt_0 > cnt_1}$**！则说明最优情况下一定有 $cnt_0 > cnt_1$ 的构造！

---
---

于是现在一定有 $cnt_0 > cnt_1$ 了（前提为钦定 $n \leq m$），所以我们就把问题转化为一个，在 $n$ 个 $\tt 1$ 中间插入最少数量（$m_0$）的 $\tt 0$ 的问题。

一个显然的事实：在 $t$ 后插入一个 $\tt 1$，然后滑动所有 $f_k$ 的 $[l, r]$ 至 $t$ 的末尾，不会让 $f$ 值减小；在 $t$ 后插入一个 $\tt 0$，然后滑动所有 $f_k$ 的 $[l, r]$ 至 $t$ 的末尾，不会让 $f$ 值增大。我们希望始终有 $f > 0$，但又希望 $\tt 0$ 的个数最少，因此这可以 **贪心** 完成。证明可以考虑，对大部分区间来说，先插入一个 $\tt 0$ 再插入一个 $\tt 1$，和先插入一个 $\tt 1$ 再插入一个 $\tt 0$，效果是一样的。

所以我们可以写出一个暴力贪心：**如果我们能在末尾插入一个** $\tt 1$（且依旧能保证 $cnt_0 > cnt_1$），就插入一个 $\tt 1$；否则只好插入一个 $\tt 0$。

打一个表吧！下面的图示展示了 $L = 10$，$10 \leq R \leq 13$ 的样子（其中为了直观，`#` 代表 $\tt 1$，`_` 代表 $\tt 0$）。

```text
#########___________#########___________#########___________#########___________#########___________
#########___________#_########__________#_#_#######_________#_#_#_######________#_#_#_#_#####_______
#########___________#_#_#######_________#_#_#_#_#####_______#_#_#_#_#_#_###_____#_#_#_#_#_#_#_#_#___
#########___________#_#_#_######________#_#_#_#_#_#_###_____#_#_#_#_#_#_#_#_#___#_#_#_#_#_#_#_#_#___
```

不形式化的描述规律：每 $2L$ 个元素为一组，第一组为 $L - 1$ 个 `#` $L + 1$ 个 `_`，然后往后的每一组依次解体 $R - L$ 个 `#` 直到不存在 `##`。合法性、最优性证明均留作习题略去，读者自证不难。

于是计算 $m_0$ 容易 $\mathcal O(1)$，定位上述规律中的第 $n$ 个 $\tt 1$ 的位置即可。于是本题容易做到 $\mathcal O(q)$。

---

## 作者：ppllxx_9G (赞：12)

## [也许更烂的阅读体验 ](https://www.cnblogs.com/ppllxx-9G/p/18523570)

## 题意

是否存在一个由 $n$ 个 $0$ 和 $m$ 个 $1$ 组成的串，满足任意一个长度为 $[2L,2R]$ 的子串中 $n$ 和 $m$ 的个数不相等。

## 转化

![](https://cdn.luogu.com.cn/upload/image_hosting/tghpftka.png)

对于 01 串个数相等的问题，容易想到将其转化为在二维平面中走网格的问题，即每选择一个 $1$ 相当于向下走一格，选择一个 $0$ 相当于向左走一格。

这样的话，一个子串内 $0$ 和 $1$ 的个数相同可以表示为同时选择了 $(x,y)$ 和 $(x-k,y-k)$ 两个点，$k$ 表示区间长度。

我们就成功将题意转化成了：从 $(m,n)$ 向左或向下走，走到 $(0,0)$，每走过一个点会产生几个不可走的位置，问是否存在一条路径，使其不经过不可走位置。

## 贪心

~~然后你发现就做完了。~~

这个问题看起来就很可做，我们先考虑最优的走法是什么？

显然最开始在 $(n,m)$ 的时候，会在斜下方有 $R-L$ 个点不可走，这些不可走的点和当前走到的位置的相对位置是固定的，也就是我们怎么移动当前点，**那一串不可走的位置就会跟着平移**。

草率的想一下，如果某一时刻我们走到了 $(x,y)$，最近的不可走点 $(x-L,y-L)$ 已经在数轴下面了（某一维小于零），那我们就可以任意走了。所以不如让 $n$ 作为较小的，然后**钦定一开始向下走**（方便下面说）。

延续上面的思路，我们尽量让不可走位置先进入数轴下面，直接贪心。先走到 $(m-L-1,n-L+1)$，然后贴着不可走位置走。最后能走到就能，不能就不能。

![](https://cdn.luogu.com.cn/upload/image_hosting/0w5p23ul.png)

建议考虑**不可走位置的边界**（挨着圆点的小叉），如果最后与 x 轴的交点大于零，那就可以。

发现**不可走位置会跟着路径平移**，也就是不可走位置的边界会复制我们走的路径，路径又需要贴着边界走，就是一个类似~~螺旋升天~~分形的过程。建议从 $L=R$ 的情况开始考虑，这时只有一个点，容易发现边界是有规律的，即每向下 $L-1$ 步，向左 $L+1$ 步为一个周期，然后你就会做了。

推广到 $R = L+1$ 的情况，发现就是在 $R = L$ 的边界上多了几个凸点，周期和步长不变。考虑 $R-L$ 会对边界有什么影响。第一次会在一条笔直向下的边界上多 $R-L$ 个凸点，由于是类似分形的结构，后面每一个周期都会多 $R-L$ 个凸点，直到边界变成阶梯状。

现在你闭着眼都知道边界是什么样的了，计算周期，小心处理最后接近 x 轴的一小段，你就做完了。

注意一些 Corner case。

附上打表器。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
const int N = 2e4+5;
LL n,m,l,r;
char a[N][N];

int main()
{
	// freopen("in.in","r",stdin);
	// freopen("out.out","w",stdout);
	int T; scanf("%d",&T);
	while(T--)
	{
		scanf("%lld%lld%lld%lld",&l,&r,&n,&m);
		if(n>m) swap(n,m);
		for(int i=0;i<=n;i++)
			for(int j=0;j<=m;j++) a[i][j]='c';
		// if(n==0||m==0) puts("Yes");
		queue<pair<LL,LL> > q;
		q.push({n,m});
		while(!q.empty())
		{
			LL x=q.front().first,y=q.front().second; q.pop();
			a[x][y]='a';
			for(int i=l;i<=r;i++)
			{
				if(x-i<0||y-i<0) break;
				a[x-i][y-i]='b';
			}
			if(x-1>=0&&a[x-1][y]!='b'&&(!(y>=m-l&&x==n-l+1))) q.push({x-1,y});
			else if(y-1>=0&&a[x][y-1]!='b') q.push({x,y-1});
		}
		if(a[0][0]=='a') puts("Yes");
		else puts("No");
		for(int i=n;i>=0;i--)
		{
			for(int j=0;j<=m;j++) printf("%c ",a[i][j]); putchar('\n');
		}
		putchar('\n');
	}
	return 0;
}
```

[AC record](https://www.luogu.com.cn/record/186554327)

---

## 作者：2020HZ06 (赞：4)

非常有思维含量的题。

对于一个固定的 $k$，考虑滑动长度为 $2k$ 的窗口，并统计窗口中有多少 $0$。

- **结论一**：所有窗口要么全部满足 $cnt_0<k$，要么全部满足 $cnt_0>k$。

> 证明：假设前面 $cnt_0<k$，后面 $cnt_0>k$，由于每滑动一格 $\Delta (cnt_1-cnt_0)$ 为偶数，要想**跨过** $cnt_1-cnt_0=0$ 的情况，$\Delta$ 要从 $1\to -1$，然而 $2k$ 为偶数，$\Delta$ 必为偶数，产生矛盾。

对于 $k\in [L,R]$，都必须满足上述条件。当然 $L,R$ 要先对 $\lfloor\frac {n+m}2\rfloor$ 取 $\min$。

- **结论二**：如果 $k=L$ 时满足 $cnt_0<L$，那么 $k=L+1$ 时不可能有 $cnt_0>L+1$。$cnt_0>L$ 同理。

> 证明：对于任意长为 $2L$ 的滑动窗口，最理想的情况是 $cnt_0=L-1$，然后再在末尾添加两个 $0$，使得 $cnt_0=L+1$，仍然不能合法。

所以 $[L,R]$ 也只有两种合法情况，要么所有 $k$ 的对应的**所有窗口**都满足 $cnt_0<k$，要么所有 $k$ 都满足 $cnt_0>k$。

假设所有窗口都满足 $cnt_0<k$。那么只需判断是否有足够的 $1$ 把 $0$ 隔开。先解决 $L=R$ 的情况。如果 $k=L=R=4$，那么构造：

$\texttt{00011111000111110}$

每 $k-1$ 个 $0$ 必须和 $k+1$ 个 $1$ 相邻，这样是最优的。称为**连续构造**。注意至少需要 $f(k)=(k+1)(\lceil\frac m{k-1}\rceil-1)$ 个 $1$。特判 $k=1$ 无解。

对于 $L<R$，在 $k=4$ 基础上构造 $k=5,6,7$。

$k=4:\texttt{00011111000111110}\\k=5:\texttt{000111110\red10\red011110}\\k=6:\texttt{00011111010\red1\red01110}$

然后 $k=7$ 就天然满足了。这种构造方法称为**交替构造**，它将 $1$ 连续段中的 $1$ 换到前面，且不增加所需 $1$ 的个数。

- **结论三**：交替构造法对任意 $k\in[L,R]$ 都合法。（忽略最后的一段 $0$）
>
>证明：首先对于 $k=L$，易知其合法。对于 $k>L$ 的长度为 $2k$ 的滑动窗口，它可以由它长为 $2L$ 的前缀向后扩展若干 $\texttt{01,10,11}$ 得到，$cnt_1>cnt_0$ 恒成立。

但最后还多出来一段 $0$。可以选择插入 $len-1$ 个 $0$，但是还有更优的方法。考虑：

$L=5,R=6,s=\texttt{0000111111\red{01}00011111\red{0101}00...}$

$L=5,R=7,s=\texttt{0000111111\red{0101}001111\red{01010101}...}$

也就是说，每个 $0$ 段增加 $R-L$ 个 $\texttt{01}$。如果当前需要插入的 $1$ 数量超过 $0$ 段长度 $-1$，就不用再插入了（由结论 $3$ 知其合法）。最后一个 $0$ 段需要插入的 $1$ 就是要增加的 $1$ 的个数。

选择 $n,m$ 中小的那个作为上述的 $0$。比较实际 $1$ 的数量和所需 $1$ 的数量大小即可。时间复杂度 $O(q)$。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define pb push_back
int q;
ll l,r,m,n; 
int main(){
	scanf("%d",&q);
	while(q--){
		scanf("%lld%lld%lld%lld",&l,&r,&m,&n);
		if(m>n) swap(n,m);
		ll len=n+m;
		if(l>len/2){
			printf("Yes\n");
			continue;
		}
		l=min(l,len/2),r=min(r,len/2);
		if(l==1){
			if(m>0) printf("No\n");
			else printf("Yes\n");
			continue;
		}
		ll tot=(m+l-2)/(l-1),ans=(l+1)*(tot-1);
		if(l<r&&tot>1){
			tot-=2;
			ll st=min(l-2,r-l),ed=min(l-2,tot*st),rest=(m%(l-1)==0?l-1:m%(l-1));
			ans+=min(ed+st,rest-1);
		}
		if(ans<=n) printf("Yes\n");
		else printf("No\n");
	}
	return 0;
}
```

注：为了方便大家调试，附上暴力对拍代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define pb push_back
int q,a[105];
ll l,r,m,n,len;
bool fl;
bool ck(){
	for(int k=l;k<=r;k++){
		int sum=0;
		for(int i=1;i<=n+m;i++){
			sum+=a[i];
			if(i>=2*k){
				if(sum==k) return 0;
			}
			if(i>=2*k) sum-=a[i-2*k+1];
		}
	}
	return 1;
}
void dfs(int m,int n,int k){
	if(fl) return;
	if(k==len+1){
		if(ck()){
			fl=1;
			for(int i=1;i<=len;i++) printf("%d",a[i]);printf("\n");
		}
		return;
	}
	if(m>0) a[k]=0,dfs(m-1,n,k+1);
	if(n>0) a[k]=1,dfs(m,n-1,k+1);
}
int main(){
//	freopen("data.in","r",stdin);
//	freopen("data.ans","w",stdout);
	scanf("%d",&q);
	while(q--){
		scanf("%lld%lld%lld%lld",&l,&r,&m,&n);
		len=n+m;fl=0;
		dfs(m,n,1);
		if(fl) printf("Yes\n");
		else printf("No\n");
	}
	return 0;
}
```

---


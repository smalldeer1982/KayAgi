# 众数

## 题目描述

你有 $n$ 个数对 $(a_1,b_1),\ldots,(a_n,b_n)$。

定义**下标** $i(1\le i\le n)$ 的权值为将 $a_1$ 个 $b_1$，$a_2$ 个 $b_2$，...，$a_i$ 个 $b_i$ 拼接在一起后形成的数组的**最大众数**（特别地，若所有数出现次数相同则为最大数）乘以 $a_i$。

接下来你有 $m$ 个操作，分两种：
- `1 x y`，将 $a_x$ 增加 $y$。**保证 $y$ 非负。**
- `2 q`，求最小的正整数 $k$ 使得**下标** $n-k+1 \sim n$ 的权值异或和为 $q$。

2 操作保证有解，且所有答案之和（记为 $\sum k$）不超过 $5\times 10^7$。

## 说明/提示

【样例解释】

最开始的四个数组为 $(2,1), (3,3),(1,1),(1,2)$。以计算下标 $2,4$ 的权值为例展示权值的计算方法：

- 要计算下标 $2$ 的权值，就要把 $2$ 个 $1$、$3$ 个 $3$ 拼在一起得到 $[1,1,3,3,3]$，最大众数为 $3$；$a_2=3$，所以权值为 $3\times 3 = 9$。
- 要计算下标 $4$ 的权值，就要把 $2$ 个 $1$、$3$ 个 $3$、$1$ 个 $1$、$1$ 个 $2$ 拼在一起得 $[1,1,3,3,3,1,2]$，最大众数为 $3$；$a_4=1$，所以权值为 $3\times 1=3$。

以此类推，可知下标 $1,2,3,4$ 的权值依次为 $2,9,3,3$。当 $k=2$ 时，$3,4$ 的权值异或和 $3\oplus 3$ 恰为 $0$，符合题意。

接下来将 $a_4$ 增加 $6$ 变成 $7$，显然前 $3$ 个下标权值不变，下标 $4$ 的权值变成 $2\times 7=14$。此时所有下标权值异或和 $2\oplus 9\oplus 3\oplus 14=6$，符合题意，所以此时 $k=4$。

然后把 $a_3$ 增加 $8$ 变成 $9$。现在 $1\sim 4$ 的权值依次为 $2,9,9,7$，此时 $k=1,3$ 时对应的权值异或和都是 $7$，此时取更小的 $k$，所以输出 $1$。

【数据范围】

记 $L$ 为所有操作结束后，所有 $a_i$ 的最大值（例如样例中，$L=9$。）

|测试点编号|$n,m\le$|特殊性质|
|:-:|:-:|:-:|
|$1\sim 2$|$30$|$a_i,y\le 30$|
|$3\sim 4$|$500$||
|$5\sim 7$|$2000$||
|$8\sim 9$|$3\times 10^5$|只有 2 操作|
|$10$|$3\times 10^5$|$b_i=1$|
|$11\sim 12$|$3\times 10^5$|$b_i\le 2$|
|$13\sim 15$|$3\times 10^5$|$\sum k\le 5\times 10^5$|
|$16\sim 19$|$3\times 10^5$|$k\le 300$|
|$20\sim 25$ |$3\times 10^5$||

对于全部数据，保证 $3\le n,m\le 3\times 10^5$，且 $1\le b_i\le n$，$1\le a_i\le L\le 10^9$。

2 操作保证有解，且 $\sum k\le 5\times 10^7$。

**提示：本题读入量较大，建议选用较快的输入输出方式。**

## 样例 #1

### 输入

```
0 4 5
2 1 3 3 1 1 1 2
2 0
1 4 6
2 6
1 3 8
2 7
```

### 输出

```
2
4
1
```

# 题解

## 作者：D0000 (赞：16)

可以说真的是一道不错的题。

我的做法是“分块”。

由于 $n^2$ 以上做法太简单，就不写了，直接从 $O(n\sqrt n)$ 开始。

### $O((n+m+\sum k)\sqrt n)$ 做法

会的可以直接跳过。

这其实就是静态区间众数。主要思路是将原序列分成 $k$ 块，我们维护每个数在前 $i$ 个块中出现的次数，进而维护前 $i$ 个块的众数。

构建时，考虑到前 $i+1$ 个块的众数必然为前 $i$ 个块的众数，或者第 $i$ 个块中出现过的数，共 $O(\sqrt n)$ 个不同的值。

修改时，只需要修改后面的块。

注意，修改和构建时维护的所有信息只需要每个块的。

查询时类似，这里只需要查前 $i$ 个块带上不超过 $O(\sqrt n)$ 个零散的元素。

这里的 $\sum k\le 5\times 10^7$，显然就是查询次数，但是 $k\sqrt n$ 显然会超时，需要把它优化掉。

### $O(\sum k+(n+m)\sqrt n)$ 做法

在查询的时候，由于右端点是一段区间，显然一个块中的答案可以在块长的时间内求出来。

但是这样仍然会超时。

### $O(\sum k+(n+m)\log n)$ 做法

增加块长时修改操作会变快，但是查询中浪费的就会变多。但是又因为查询是**最右边**一段连续的区间。因此可以将块长设置得不一样，具体地，如果从右往左块长依次为 $1,2,4,8,\cdots$，则总共只有 $\log n$ 个块。又不妨假设所有询问答案都是 $k_0$，则总共需要查询不超过 $\frac{\sum k}{k_0}$ 次，且每次浪费的询问也不会超过 $2^{\log k_0}=k_0$ 个，总共查询复杂度即为 $O(\sum k)$。

### 代码

```cpp
#include<cstdio>
#include<utility>
#include<algorithm>
#include<math.h>
#define int long long
int t,n,m,b[400005];
int a[400005];
long long d[400005][19];
long long app[400005];
std::pair<long long,int>zhong[400000],ans[400005];
int kuail[19],kuair[19],kuainum=19;
void run(){
    long long q;
    scanf("%lld",&q);
    for(int i=kuainum-1;~i;i--){
        ans[kuair[i-1]]=zhong[i-1];
        for(int j=kuail[i];j<=kuair[i];j++)app[b[j]]=d[b[j]][i-1];
        for(int j=kuail[i];j<=kuair[i];j++){
            ans[j]=ans[j-1];
            app[b[j]]+=a[j];
            if(app[b[j]]>ans[j].first||(app[b[j]]==ans[j].first&&b[j]>ans[j].second))ans[j]={app[b[j]],b[j]};
        }
        for(int j=kuail[i];j<=kuair[i];j++)app[b[j]]=0;
        for(int j=kuair[i];j>=kuail[i];j--){
            q^=(1ll*a[j]*ans[j].second);
            if(!q){
			printf("%lld\n",n-j+1);
			return;
			}
        }
    }
}
signed main(){
    scanf("%lld%lld%lld",&t,&n,&m);
    for(int i=1;i<=n;i++)scanf("%lld%lld",&a[i],&b[i]);
    kuainum=log2(n);
    for(int i=kuainum-1;~i;i--){
        if(kuainum==i+1)kuair[i]=n;
        else kuair[i]=kuail[i+1]-1;
        if(!i)kuail[i]=1;
        else kuail[i]=kuair[i]-(1<<(kuainum-i-1));
    }
    for(int i=0;i<kuainum;i++){
        for(int j=1;j<=n;j++)d[j][i]=d[j][i-1];
        for(int j=kuail[i];j<=kuair[i];j++)d[b[j]][i]+=a[j];
        zhong[i]=zhong[i-1];
        for(int j=kuail[i];j<=kuair[i]&&j<=n;j++)if(d[b[j]][i]>zhong[i].first||(d[b[j]][i]==zhong[i].first&&b[j]>zhong[i].second))zhong[i]={d[b[j]][i],b[j]};
    }
    while(m--){
        int op,x,y;
        scanf("%lld",&op);
        if(op==2)run();
        else{
            scanf("%lld%lld",&x,&y);
            a[x]+=y;
            for(int i=0;i<kuainum;i++){
                if(kuair[i]>=x)d[b[x]][i]+=y;
                if(d[b[x]][i]>zhong[i].first||(d[b[x]][i]==zhong[i].first&&b[x]>zhong[i].second))zhong[i]={d[b[x]][i],b[x]};
            }
        }
    }
}
```

---

## 作者：yummy (赞：12)

# D. 众数 官方题解

本题涉及的主要知识点：

- 【3】递推法
- 【4】倍增法

## 测试点 $1\sim 9$

要算出众数，关键就是要统计每个数字出现的次数。1 操作正常修改（直接增加 $a_i$ 即可），当碰到 2 操作时，开一组计数器，用一重 for 循环从前往后枚举 $i$，将第 $i$ 个数组中的数加入计数器，并同时维护此时的最大众数。

知道前 $i$ 个数组的众数后，再用另一重循环从后往前扫描并统计 $n-k+1\sim n$ 的权值异或和。该方法时间复杂度为 $O(nm)$。

对于测试点 $8,9$，既然所有数组都不发生变化，那么第一次把所有前缀众数求好就一劳永逸了，时间复杂度 $O(n+\sum k)$。

## 测试点 $10\sim 15$

当 $b_i=1$ 时，众数显然永远是 $1$，相当于你需要维护单点修改后缀异或和，在从小到大枚举 $k$ 的时候顺带维护一下就可以。

当 $b_i\le 2$ 时，你需要知道前缀中 $1,2$ 分别有几个。因为在用循环枚举 $k$ 的时候你可以确保当前结点的后缀都是被扫描过的，所以前缀中 $1,2$ 的个数等于全局 $1,2$ 的个数减去后缀中对应的个数。

**本节中这句话以下的内容并不是 J 组需要掌握的，也不是做出这题所必需的。**

当 $b_i$ 更大时，你可以使用任何一种支持单点减小全局求 $\max$ 的数据结构维护，如线段树、带时间戳的优先队列、`multiset` 等，代价是往前挪一步的时间复杂度变成 $\log n$——或者说 $\log \max b_i$。

因此本题的总时间复杂度为 $O((n+m+\sum k)\log \max b_i)$。

---

测试点 $13\sim 15$ 还有另解（根号分治）。在测试点 $16\sim  19$ 做法的基础上，如果 $k\le B=300$ 时无解，我就以 $O(n)$ 的代价从头跑一遍（$B$ 需要略微调整，但我没写过）。显然从头跑一遍的次数不超过 $\dfrac{\sum k}{B}$ 次，所以总时间复杂度为 $O(n+mB+\dfrac{n\sum k}{B})$，根据基本不等式，最小时间复杂度为 $O(n+\sqrt{nm\sum k})$。

## 测试点 $16\sim 19$

（这是本题最具有提示性的部分分）

注意到 $k$ 减小是很容易的，但增大是很困难的。因为 $k\le 300$，所以无论如何，前 $n-300$ 个数组肯定永远都是要参与计算区间众数的。为此我们设置一个计数器记录前 $n-300$ 个数组中每个数出现了几次以及此时的区间众数，然后让 $k$ 从 $300$ 逐渐减少到 $1$。时间复杂度 $O(n+m\max k)$。

## 正解

现在 $k$ 范围不确定，我们能不能设置一些递推起点（在测试点 $17\sim 20$ 中是 $n-300$），使得不管 $k$ 是多少，都有一个离它**不太远**的递推起点呢？

答案是肯定的。注意到 $k$ 及以上的、最小的 $2$ 的整数次幂不超过 $2k$，换言之，如果我们以 $n-2^i$ 作为递推起点，就可以保证存在一个递推起点，从它递推到 $k$ 所需的次数不超过 $k$。

具体要怎么做呢？考虑如下流程：

- 先假设 $k\le 1$，根据递推起点（即前 $n-1$ 个数组的统计结果）把后 $1$ 个权值算出来，统计答案。
- 若 $k\le 1$ 时无解，就假设 $k\le 2$，根据递推起点（即前 $n-2$ 个数组的统计结果）把后 $2$ 个权值算出来，统计答案。
- 还是不行就假设 $k\le 4$，算出后 $4$ 个数的权值，以此类推。

因为现在有 $\log n$ 个递推起点需要统计每个数出现次数，所以每次 1 操作的时间复杂度会提升为 $O(\log n)$。这样总时间复杂度就是 $O((n+m)\log n+\sum k)$。

**本节中这句话以下的内容并不是 J 组需要掌握的，也不是做出这题所必需的。**

如果你学过分块，你或许会发现（因为我没亲自写过），似乎不用倍增法设置起点也能把这题做出来。

具体地，如果你每 $\sqrt n$ 个数组设置一个递推起点，那么每次 2 操作最多花费 $k+\sqrt n$ 次递推就可以得出结果，然后 1 操作时间复杂度为 $O(\sqrt n)$，总时间复杂度为 $O((n+m)\sqrt n+\sum k)$，也能通过。

我自己用根号一段的方法没有 A 掉本题，我不太清楚选手有没有根号干过去的。

```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n,m;
int a[300005],b[300005];
vector<int> stt;
long long cnt[20][300005],best[20],v[300005];
bool x_gr_y(int x,int y,int j){return cnt[j][x]>cnt[j][y] || (cnt[j][x]==cnt[j][y] && x>y);}
int main(){
	scanf("%d%d%d",&T,&n,&m);
	for(int j=0;(1<<j)<=n;j++)stt.emplace_back(n+1-(1<<j));
	stt.emplace_back(1);
	for(int i=1;i<=n;i++)scanf("%d%d",&a[i],&b[i]);
	for(int j=0;j<stt.size();j++)
		for(int i=1;i<stt[j];i++){
			cnt[j][b[i]]+=a[i];
			if(x_gr_y(b[i],best[j],j))
				best[j]=b[i];
		}
	for(;m;m--){
		int op,x,y;
		scanf("%d",&op);
		if(op==1){
			scanf("%d%d",&x,&y);
			a[x]+=y;
			for(int j=0;j<stt.size();j++)
				if(x<stt[j]){
					cnt[j][b[x]]+=y;
					if(x_gr_y(b[x],best[j],j))
						best[j]=b[x];
				}
		}
		else{
			long long q;
			scanf("%lld",&q);
			int last=n+1,answer=-1;
			for(int j=0;j<stt.size();j++){
				long long bst=best[j];
				for(int i=stt[j];i<last;i++){
					cnt[j][b[i]]+=a[i];
					if(x_gr_y(b[i],bst,j))
						bst=b[i];
					v[i]=bst*a[i];
				}
				for(int i=last-1;i>=stt[j];i--){
					q^=v[i];
					if(q==0 && answer<0)answer=i;
					cnt[j][b[i]]-=a[i];
				}
				if(answer>=0){
					printf("%d\n",n+1-answer);
					break;
				}
				else
					last=stt[j];
			}
		}
	}
	return 0;
}
```



## Further More

出这道题，主要就是发现考纲里有个“倍增法”，然后回顾了脑海当中所有关于“倍增”的内容。

本题最开始是想丢到基础赛的，所以出题受到知识点的限制，能维护的量非常有限，我枚举了好几天才找到了符合需求的一些操作。

在成功出出来这道题之前，我曾经有过很多个不同尝试，下面列举一些：

- 排列 $p$，1 操作交换，2 操作维护最大值（操作可逆）
- 1 操作单点修改，2 操作前缀按位或（维护每个 bit 的出现次数，仍然可逆）
- 受【模板】回滚莫队 的启发，权值为当前 $a_i$ 位置减第一次出现位置（但是模板自己也被普通莫队做出来了）
- 2 操作为前缀 LIS（无法从中间修改导致可以用半可持久化数组实现可逆）
- 2 操作为 P3203（然而加入和删除同一个复杂度）
- 1 操作邻项交换，2 操作前缀逆序对数（J 组不能出现树状数组）
- 值域 $10^9$，1 操作单点修改，2 操作维护最大值（希望最大的一个，但是线段树不仅能做，而且**遍历线段树均摊 $O(1)$**，故放弃）
- 1 操作**临时**单点修改，2 操作前缀最大子段和（理由同上）
- 询问群友，群友给出来一个区间凸包（别说 J 组了，我自己都不会做）
- 群友还给出来吉司机线段树（因为是均摊复杂度，所以直接上可持久化复杂度是错的）（J 组更不能出现）
- 1 操作单点插入，2 操作求前缀众数（这会导致倍增起点变化进而被卡，而且需要树状数组维护下标，超纲了）

总结：线段树，太强大。

---

## 作者：BMnya (赞：4)

> **Upd 20241215:**
> 
> 在出题人[重造数据](https://www.luogu.com.cn/discuss/1021049)后，下文的根号分块做法[可以通过本题](https://www.luogu.com.cn/record/194660207)，完整代码在[这里](https://www.luogu.com.cn/paste/jhb2stlb)。
>
> 需要注意的是，此时空间不足以开下 $sum$ 数组，所以需要将所有询问离线，再同时枚举所有 $k$，这样一次只需要存一个块的信息。

对于众数，好像并没有什么好的维护方式，考虑分块：

假设分了 $tot$ 块，块长 $len_i$，通过维护 $sum_{i,j}$ 表示前 $i-1$ 块内 $j$ 出现的总次数，$mx_i$ 表示前 $i-1$ 块的众数，可以做到 $O(tot)$ 修改，$O(len_i)$ 查询块 $i$ 内的**所有**点的权值。

（具体的，第 $i$ 块内每个点的前缀众数要么是 $mx_i$，要么在块内出现过，枚举每个数统计次数即可计算。）

对于询问，由于 $\sum k$ 不大，可以直接枚举 $k$，每当 $n-k+1$ 进入了一个没有计算过的块，就用 $O(len_i)$ 的时间计算整个块。

假设 $las_k$ 表示查询 $k$ 时计算的最后一个块，由于这个块内的点计算了但不一定被用到，所以单次查询的复杂度为 $O(k+len_{las_k})$。

如果按照常见的分块方式，即按块长 $\sqrt n$ 分块，总的时间复杂度为 $O((n+m)\sqrt n+\sum k)$，我没卡过去，可能可以使用一些技巧卡过去。

这里使用一种类似倍增的分块方式，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/6978qgkv.png)

这样就可以保证 $len_{las_k}\le k$，单次查询的复杂度为 $O(k)$，单次修改复杂度为 $O(\log n)$，总时间复杂度为 $O((n+m)\log n+\sum k)$。

---

以下是主要部分代码（[提交记录](https://www.luogu.com.cn/record/194478747)，最大点在 400ms 左右）：

```cpp
const int N=3e5+10,M=20;
int n,m,a[N],b[N],tot,pos[N],L[M],R[M]; ll num[M][N],cnt[N],f[N];

pair<ll,int> mx[M]; vector<int> vc;

inline void chg(int x,int y){
    a[x]+=y;
    for(auto p:vc)
        if(x<p){
            num[pos[p]][b[x]]+=y;
            mx[pos[p]]=max(mx[pos[p]],make_pair(num[pos[p]][b[x]],b[x]));
        }
}

inline void calc(int p){
    pair<ll,int> now=mx[p];
    for(int i=L[p];i<=R[p];++i){
        cnt[b[i]]+=a[i];
        now=max(now,make_pair(cnt[b[i]]+num[p][b[i]],b[i])),f[i]=(ll)now.second*a[i];
    }
    for(int i=L[p];i<=R[p];++i) cnt[b[i]]=0;
}

inline int que(ll x){
    for(int k=1;k<=n;++k){
        if(pos[n-k+1]!=pos[n-k+2]) calc(pos[n-k+1]);
        x^=f[n-k+1];
        if(!x) return k;
    }
    return -1;
}

inline void solve(){
    read(),n=read(),m=read();
    for(int i=1;i<=n;++i) a[i]=read(),b[i]=read();
    for(int i=1;(1<<i)<=n;++i) pos[n-(1<<i)+1]=1;
    pos[1]=1;
    for(int i=1;i<=n;++i){
        pos[i]+=pos[i-1];
        if(pos[i]!=pos[i-1]) R[pos[i-1]]=i-1,L[pos[i]]=i;
    }
    tot=pos[n],R[pos[n]]=n;
    for(int i=1;i<=n;++i){
        if(i==L[pos[i]]){
            memcpy(num[pos[i]],cnt,sizeof cnt);
            for(int j=1;j<=n;++j) mx[pos[i]]=max(mx[pos[i]],make_pair(cnt[j],j));
            vc.emplace_back(i);
        }
        cnt[b[i]]+=a[i];
    }
    memset(cnt,0,sizeof cnt);
    for(int op,x,y;m;--m){
        op=read();
        if(op==1) x=read(),y=read(),chg(x,y); else printf("%d\n",que(read()));
    }
}
```

---

## 作者：Cx114514 (赞：2)

### 题目链接：[P11398 众数](https://www.luogu.com.cn/problem/P11398)

非常妙的一个题。

首先考虑如何暴力地求出每个位置的权值：

从左向右扫整个序列，开个桶记录 $1\sim n$ 当前作为 $b_i$ 各出现了几次，再用 $maxx$ 记录出现次数最多的是哪一个，加进来一个数就把那个数的桶 $+a$ 并将新值和 $maxx$ 比较。

但是可以发现，每次从 $1$ 扫到 $n$，很多时候是重复的。

因为 $\sum k \le 5 \times 10^7$，所以很多时候 $k$ 都是较小的，那么较靠前的数就会被重复算很多遍。

为了减少不必要的时间损耗，我们可以钦定一些点并记录在它之前每个数作为 $b_i$ 的出现次数，这样我们在后续扫的时候就只要从这个点开始。

不难想到分块，令块长为 $\sqrt n$，记录每个块之前所有块的 $1\sim n$ 出现次数的总和。

那我们每次只需从最后一个块扫，如果没有得到答案，就再从倒数第二个块扫，$\cdots$，以此类推，直到找到答案为止。

每次修改的复杂度是 $O\left(\sqrt n\right)$。令 $m$ 和 $n$ 同阶，时间复杂度为 $O\left(n\sqrt n+\sum k\right)$。

但是，好像过不去。（或许写得好能过？）

考虑换一种块长，令块长从后向前分别为 $1,2,4,8,\cdots$，共有 $\log n$ 块，修改的时间复杂度为 $O\left(\log n\right)$，总时间复杂度 $O\left(n\log n + \sum k\right)$，可过。

代码：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

int read()
{
	int f = 1;
	char c = getchar();
	while (!isdigit(c))
	{
	    if (c == '-') f = -1;
	    c = getchar();
    }
	int x = 0;
	while (isdigit(c))
	{
		x = x * 10 + c - '0';
		c = getchar();
	}
	return x * f;
}

int buf[15];

void write(int x)
{
	int p = 0;
	if (x < 0)
	{
	    putchar('-');
	    x = -x;
	}
	if (x == 0) putchar('0');
	else
	{
		while (x)
		{
			buf[++p] = x % 10;
			x /= 10;
		}
		for (int i = p; i >= 1; i--)
			putchar('0' + buf[i]);
	}
}

int T, n, m, tot, a[300005], b[300005], belong[300005], cur[300005], curcnt[300005], cnt[35][300005];

struct node
{
	int l, r, maxx;
} block[35];

signed main()
{
	T = read(), n = read(), m = read();
	for (int i = 1; i <= n; i++)
		a[i] = read(), b[i] = read();
	int now = n, len = 1;
	while (now >= 1)
	{
		tot++;
		block[tot].r = now;
		now -= len;
		block[tot].l = now + 1;
		len *= 2;
	}
	block[tot].l = 1;
	reverse(block + 1, block + tot + 1);
	for (int i = 1; i <= tot; i++)
		for (int j = block[i].l; j <= block[i].r; j++)
			belong[j] = i;
	for (int i = 1; i <= tot; i++)
	{
		for (int j = 1; j <= n; j++)
			cnt[i][j] = cnt[i - 1][j];
		block[i].maxx = block[i - 1].maxx;
		for (int j = block[i].l; j <= block[i].r; j++)
		{
			cnt[i][b[j]] += a[j];
			if (cnt[i][block[i].maxx] < cnt[i][b[j]] || (cnt[i][block[i].maxx] == cnt[i][b[j]] && b[j] > block[i].maxx)) block[i].maxx = b[j];
		}
	}
	while (m--)
	{
		int op, x, y;
		op = read(), x = read();
		if (op == 1)
		{
			y = read();
			a[x] += y;
			for (int i = belong[x]; i <= tot; i++)
			{
				cnt[i][b[x]] += y;
				if (cnt[i][block[i].maxx] < cnt[i][b[x]] || (cnt[i][block[i].maxx] == cnt[i][b[x]] && b[x] > block[i].maxx)) block[i].maxx = b[x];
			}
		}
		else
		{
			int Tot = 0, B = 0;
			for (int i = tot - 1; i >= 0; i--)
			{
				int curmaxx = block[i].maxx;
				for (int j = block[i + 1].l; j <= block[i + 1].r; j++)
				{
					curcnt[b[j]] += a[j];
					if (cnt[i][curmaxx] + curcnt[curmaxx] < cnt[i][b[j]] + curcnt[b[j]] || (cnt[i][curmaxx] + curcnt[curmaxx] == cnt[i][b[j]] + curcnt[b[j]] && b[j] > curmaxx)) curmaxx = b[j];
					cur[j] = curmaxx;
				}
				for (int j = block[i + 1].r; j >= block[i + 1].l; j--)
				{
					Tot ^= (cur[j] * a[j]);
					if (Tot == x)
					{
						write(n - j + 1);
						putchar('\n');
						B = 1;
						break;
					}
				}
				for (int j = block[i + 1].l; j <= block[i + 1].r; j++)
					curcnt[b[j]] -= a[j];
				if (B) break;
			}
		}
	}
	return 0;	
}
```

---

## 作者：pig1121 (赞：1)

权值是带权前缀众数，启发我们使用分块。

一种想法是套用 [P4168 [Violet] 蒲公英](https://www.luogu.com.cn/problem/P4168) 的做法，对序列根号分块并记录块结尾的前缀 $cnt$ 和众数，查询时以上一块的 $cnt$ 和众数为基础增量更新答案，复杂度 $O(n\sqrt n)-O(\sqrt n)-O(\sqrt n)$ 。由于题目需要后缀答案异或和~~这东西不太可能有什么性质~~，需要枚举 $k$ ，查询总复杂度为 $O(\sum k\sqrt n)$ ，在 $\sum k\leq 5\times10^7$ 时显然不可接受。

$10^7$ 的数量级基本意味着需要线性/均摊线性查询。尝试进一步分析时间开销，由于我们处理了前缀和，时间开销只包含对散块的增量更新。考虑到每次查询的 $k$ 是枚举一段后缀，实际上我们对同一块内的答案做了大量的重复更新（$[l,x]$ 区间对答案的贡献在枚举 $n-k+1\in(x,r]$ 时被重复枚举计算）故我们可以对同一块内的答案统一顺序计算，具体地，在实现上，倒序枚举 $n-k+1$ 所在的块，在块内顺序枚举 $n-k+1$，由 $n-k$ 的答案递推到 $n-k+1$。这样每次查询的开销为 $O(k_i+B)$，加上块长是因为有可能答案位于散块，此时也要按整块递推计算。总复杂度 $O((n+m)\sqrt n +\sum k)$。~~卡卡常应该能过~~但我没过。

不会卡常，只好继续优化算法。

每次查询固定一个 $B=\sqrt n$  还是太慢了，能不能块长小点？

预处理 $\lfloor \frac n B\rfloor=\sqrt n$ 个块端点还是太慢了，能不能少点块？

诶这两要求好像互相矛盾怎么办？

不对！

平时分块取 $\sqrt n$ 为块长是因为**查询**复杂度为 $O(cnt_B+B)$（$cnt_B$ 为访问的整块数），但我们的做法查询复杂度貌似是 $O(k+B)$……

那我直接令 $B_{pos_k}=O(k)$ 的量级，查询不就是 $O(k)$ 的了吗？

令 $B_i$ 为从右往左第 $i$ 块长度（$0$ 起点）。大概写成递推柿子就是 $B_i=\sum_{j<i} B_j$，令 $B_0=1$，解得 $B_i=2^{i-1}$、$\sum^i_{0}B_j=2^i$，所以总块数也是 $O(\log n)$。

这下复杂度就是 $O(n\log n+m+\sum k)$ 了，稳过。

`O2+getchar_unlocked()` 总用时 4.91s，截止 $2025.8.8$ 暂列最优解第一。

```cpp
#include<bits/stdc++.h>
#define int long long
#define endl '\n'
#define gc getchar_unlocked
using namespace std;
void read(int&x){
	x=0;
	char ch=gc();
	while(ch<'0'||'9'<ch)ch=gc();
	while('0'<=ch&&ch<='9'){
		x=(x<<1)+(x<<3)+(ch^48);
		ch=gc();
	}
}
int a[300005],b[300005];
int cnt[30][300005],as[30];
int lg[300005];
int tp[300005];
#define ps(i) (lg[i-1]+1)
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	int T,n,m;
	read(T);read(n);read(m);
	lg[0]=-1;
	for(int i=1;i<=n;i++)lg[i]=lg[i>>1]+1;
	for(int i=1;i<=n;i++){
		read(a[i]);read(b[i]);
		for(int j=ps(n-i+1);j>=0;j--){
			cnt[j][b[i]]+=a[i]; 
			if(cnt[j][as[j]]<cnt[j][b[i]]||cnt[j][as[j]]==cnt[j][b[i]]&&b[i]>as[j]){
				as[j]=b[i];
			}
		}
	}
	while(m--){
		int op,x,y;
		read(op);read(x);
		if(op==1){
			read(y);
			a[x]+=y;
			for(int j=ps(n-x+1);j>=0;j--){
				cnt[j][b[x]]+=y;
				if(cnt[j][as[j]]<cnt[j][b[x]]||cnt[j][as[j]]==cnt[j][b[x]]&&b[x]>as[j]){
					as[j]=b[x];
				}
			}
		}
		else{
			int res=as[0]*a[n];
			if(res==x){
				cout<<1<<endl;
				continue;
			}
			for(int j=1;j<=ps(n);j++){
				int lp=max(1ll,n-(1<<j)+1),rp=n-(1<<j-1);
				tp[lp-1]=as[j+1];
				for(int i=lp;i<=rp;i++){
					cnt[j+1][b[i]]+=a[i];
					if(cnt[j+1][tp[i-1]]<cnt[j+1][b[i]]||cnt[j+1][tp[i-1]]==cnt[j+1][b[i]]&&b[i]>tp[i-1]){
						tp[i]=b[i];
					}
					else tp[i]=tp[i-1];
				}
				for(int i=lp;i<=rp;i++)cnt[j+1][b[i]]-=a[i];
				for(int i=rp;i>=lp;i--){
					res^=(tp[i]*a[i]);
					if(res==x){
						cout<<n-i+1<<endl;
						break;
					}
				}
				if(res==x)break;
			}
		}
	}
	return 0;
}
```

---

## 作者：cwfxlh (赞：1)

# [P11398](https://www.luogu.com.cn/problem/P11398)       

怎么没有人写 $O(k\log)$ 的做法。      

考虑定期重构。发现修改是增加 $a$，所以对于一个前缀，它的众数要么不变，要么变成曾经被修改过位置的 $b$。           

令阈值为 $B$，修改的时候将对应位置的 $b$ 放进答案候选，如果答案候选个数超过 $B$ 就从头跑一遍计算众数。询问的时候倒着走，并维护所有数的出现次数。对于答案候选，维护一个线段树，单点修改全局 $\max$，然后比较答案候选的最大众数与原答案即可。复杂度 $O(\frac{nq}{B}+qB+{\sum{k}\log B})$，取 $B=180$ 左右就过了。线段树不建议写递归版的，可能被卡常。          

代码：      


```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int n,q,ccccc,a[300003],b[300003],k1,k2,k3,k4,k5,k6,k7,k8,k9;
int idx,num[300003],stk[300003];
ll vvv;
ll cnt[300003],apr[300003];
pair<ll,int>mxv[5003];
int lf[5003],zs[300003];
void build(int now,int l,int r){
	if(l==r){mxv[now]=make_pair(cnt[stk[l]],stk[l]);lf[l]=now;return;}
	build(now*2,l,((l+r)>>1));
	build(now*2+1,((l+r)>>1)+1,r);
	mxv[now]=max(mxv[now*2],mxv[now*2+1]);
	return;
}
void rebuild(){
	pair<ll,int>zz=make_pair(0,0);
	for(int i=1;i<=n;i++)apr[i]=0;
	for(int i=1;i<=n;i++){
		apr[b[i]]+=a[i];
		zz=max(zz,make_pair(apr[b[i]],b[i]));
		zs[i]=zz.second;
	}
	return;
}
int read(){
	int xx=0,ff=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')ff=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		xx=xx*10+ch-'0';
		ch=getchar();
	}
	return xx*ff;
}
ll readl(){
	ll xx=0,ff=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')ff=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		xx=xx*10ll+ch-'0';
		ch=getchar();
	}
	return xx*ff;
}
void write(int X){
	if(X>9)write(X/10);
	putchar('0'+(X%10));
	return;
}
int main(){
	ccccc=read();n=read();q=read();
	for(int i=1;i<=n;i++){a[i]=read();b[i]=read();}
	rebuild();
	for(int i=1;i<=n;i++)cnt[b[i]]+=a[i];
	while(q--){
		k1=read();
		if(k1==1){
			k2=read();k3=read();
			a[k2]+=k3;
			cnt[b[k2]]+=k3;
			if(num[b[k2]]==0){
				num[b[k2]]=++idx;
				stk[idx]=b[k2];
			}
		}
		else{
			vvv=readl();
			if(idx)build(1,1,idx);
			else mxv[1]=make_pair(0,0);
			for(int i=n;i;i--){
				vvv^=1ll*a[i]*max(mxv[1],make_pair(cnt[zs[i]],zs[i])).second;
				if(!vvv){
					for(int j=i+1;j<=n;j++)cnt[b[j]]+=a[j];
					write(n-i+1);
					putchar('\n');
					break;
				}
				cnt[b[i]]-=a[i];
				if(num[b[i]]){
					mxv[lf[num[b[i]]]].first=cnt[b[i]];
					for(int j=lf[num[b[i]]]/2;j;j>>=1)mxv[j]=max(mxv[j<<1],mxv[j<<1|1]);
				}
			}
		}
		if(idx==180){
			rebuild();
			for(int i=1;i<=idx;i++)num[stk[i]]=0;
			idx=0;
		}
	}
	return 0;
}
```

---

## 作者：寄风 (赞：1)

省流：$O(\sum k\times \log(n))$ 做法。

考虑操作分块。

发现 $1$ 操作中 $y$ 是非负的，也就是每个前缀的众数要么不变，要么变成 $b_x$。

考虑设立阀值 $B$，若上一次重构后被一操作影响到的下标（下称关键点）大于 $B$ 则直接线性重构。

考虑零散操作。

开一个桶维护每个数的出现次数，开线段数维护关键点 $b$ 的出现次数，每次询问时从后往前扫，线段树单点修改全局最大值即可。

块长我取了 $600$，能 800ms 稳定通过。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int T;
#define ll long long
// #define getchar() (xS == xTT && (xTT = (xS = xB) + fread(xB , 1 , 1 << 23 , stdin) ,xS == xTT) ? 0 : *xS++)
// #define putchar(x) (p3 - obuf < 1000000) ? (*p3++ = x) : (fwrite(obuf , p3 - obuf , 1 , stdout) , p3 = obuf , *p3++ = x)
char xch,xB[1<<23],*xS=xB,*xTT=xB,obuf[1000000],*p3=obuf;
inline ll read(){
    char op = getchar();
    ll x = 0, f = 1;
    while(op < '0' || op > '9'){
        f = (op == '-' ? -1 : 1);
        op = getchar();
    }
    while (op >= '0' && op <= '9') {
        x = (x << 1) + (x << 3) + (op ^ 48);
        op = getchar();
    }
    return x * f;
}
static char cc[20];
template <class T>
inline void pt(T x){
    int len = 0;
    if(!x) return putchar('0') , void();
    if(x < 0){
        x = -x;
		putchar('-');
	}
    while(x){
        cc[len++] = x % 10 + '0';
		x /= 10;
	}
    while(len--) putchar(cc[len]);
}
namespace bl{
	int a[1000005]  , b[1000005] , n , m  , op , xx , yy;
	int cnt[2005][2005];

	pair<int,int> f[1000005];
	inline void add(int x , int y , int op = 1){
		if(op) a[x] += y;
		for(int i = x;i <= n ; i  ++ )  {
			cnt[i][b[x]] += y;
			if(f[i].second < cnt[i][b[x]]){
				f[i].first = b[x];
				f[i].second = cnt[i][b[x]];
			}
			else if(f[i].second == cnt[i][b[x]] && f[i].first < b[x]){
				f[i].first = b[x];
				f[i].second = cnt[i][b[x]];
			}
		}
	}
	inline int query(int q){
		int now = 0;
		for(int k = 1 , i = n;k <= n;k++ , i--){
			now ^= (a[i] * f[i].first);
			if(now == q) return k;
		}
		return -1;
	}
	signed main(){
		n = read(),  m = read();
		for(int i = 1;i <= n ; i  ++ ) a[i] = read() , b[i] = read() , f[i].first = f[i].second = INT_MIN;
		for(int i = 1;i <= n ; i  ++ ) add(i , a[i] , 0);
			// for(int i = 1;i <= n ; i ++ )cout<<a[i] <<' '<< f[i].first<<'\n';
			// 	cout<<'\n';
			// return 0;
		while(m--){
			op = read() , xx = read();
			if(op  == 1){
				yy=read();
				add(xx , yy);
			}
			else{
				cout<<query(xx)<<'\n';
			}
			// for(int i = 1;i <= n ; i ++ )cout<<a[i] * f[i].first<<' ';
			// 	cout<<'\n';
			// return 0;
		}
		return 0;
	}
};
const int N = 3e5 + 5;
namespace no_op_2{
	int cc[N];
	int n , m , a[N] , b[N] , c[N] , f[N];
	unordered_map<int,int> qq;
	signed main(){
		n = read(),  m = read();
		for(int i = 1;i <=  n ; i ++) a[i] = read() , b[i] = read() ;
			int id = 0;
		for(int i = 1;i <= n; i  ++ ) {
			c[b[i]] += a[i];
			if(!id){
				id = b[i];
			}
			else{
				if(c[id] < c[b[i]] || (c[id] == c[b[i]] && id < b[i])){
					id = b[i];
				}
			}
			f[i] = id;
			// cout<<f[i]<<' ';
		}
// cout<<'\n';
		c[n + 1] = 0;
		for(int i = n;i;i--){
			c[i] = c[i + 1] ^ (f[i] * a[i]);
			qq[c[i]]=max(qq[c[i]] , i);
		}
		int op , x;
		while(m--){
			op = read() , x = read();
			cout<<n - qq[x] + 1<<'\n';
		}
		return 0;
	}
}
namespace b1{
	int n , m , a[1000005] , b[1000005];
	signed main(){
		n = read(),  m = read();
		int now = 0 ;
		for(int i = 1;i <= n  ; i ++ ) a[i] = read() , b[i] = read() , now ^= a [ i  ];
		int op , x , y;
		while(m--){
			op = read() , x = read();
			if(op == 1){
				y = read();
				now ^= a[x];
				a[x] += y;
				now ^= a[x];
			}
			else{
				int nn = 0;
				bool fg = 0;
				for(int i = n , j = 1;i; i -- , j++){
					nn ^= a[i];
					if(nn == x){
						pt(j);
						fg = 1;
						putchar('\n');
						break;
					}
				}
				if(!fg){
					exit(0);
				}
			}
		}
		fwrite(obuf , p3 - obuf , 1 , stdout);
		return 0;
	}
}
namespace zj{
	int cc[N];
	int n , m , xx , a[N] , b[N] , c[N] , f[N];
	unordered_map<int,int> qq;
	int s[N] , tp , ct[N] , ii[N];
	struct node{
		int x,id;
		bool operator <(const node &c) const{
			if(!id) return 1;
			if(!c.id) return 0;
			if(x ^ c.x) return x < c.x;
			return id < c.id;
		}
		bool operator >(const node &c) const{
			if(!id) return 0;
			if(!c.id) return 1;
			if(x ^ c.x) return x > c.x;
			return id > c.id;
		}
	};
	node d[N<<2];
	#define ls (p<<1)
	#define rs (p<<1|1)
	inline void pushup(int p){d[p]=max(d[ls],d[rs]);}
	inline void build(int p , int l , int r){
		if(l == r){
			// cerr<<"can "<<p<<' '<<s[l]<<' '<<ct[s[l]]<<'\n';
			d[p].x = ct[s[l]];
			d[p].id = s[l];
			return ;
		}
		int mid = l + r >> 1;
		build(ls , l , mid) , build(rs , mid + 1 , r);
		pushup(p);
	}
	inline void upd(int p , int id , int l , int r , int v){
		if(l == r){
			// cout<<"jyq "<<p<<' '<<d[p].x<<' ';
			d[p].x -= v;
			// cout<<d[p].x<<'\n';
			return ;
		}
		int mid = l + r >> 1;
		if(id <= mid) upd(ls , id , l , mid , v);
		else upd(rs , id , mid + 1 , r , v) ;
		pushup(p);
	}
	#undef ls
	#undef rs
	inline void rebuild(int op = 1){
		for(int i = 1;i <= tp;i++){
			ii[s[i]] = 0;
		}
		tp = 0;
		int id = 0;
		for(int i = 1;i <= n; i  ++ ) c[b[i]] = 0;
			int cnt = 0;
		for(int i = 1;i <= n; i  ++ ) {
			c[b[i]] += a[i];
			if(!id){
				id = b[i];
			}
			else{
				if(c[id] < c[b[i]] || (c[id] == c[b[i]] && id < b[i])){
					id = b[i];
				}
			}
			f[i] = id;
			// cout<<f[i]<<' ';
		}
	}
	int B = 600 , nnow;
	inline int query(int q){
		// cout<<"adas "<<ct[3]<<'\n';
		int now = 0;
		node tmp;
		if(tp >= 1)
		build(1 , 1 , tp);
		else d[1].id = d[1].x = tmp.x = tmp.id = 0;
		for(int k = 1 , i = n;k <= n;k++ , i--){
			tmp.x = ct[f[i]];
			tmp.id = f[i];
			now ^= (a[i] * max(tmp , d[1]).id);
			// cerr<<i<<' '<<f[i]<<' ' <<d[1].id<<' '<<tmp.x<<' '<<d[1].x<<' '<<max(tmp , d[1]).id<<' '<<' '<<' ';
			// cerr<<i<<' '<<a[i]<<' '<<b[i]<<' '<<ii[b[i]]<<' '<<f[i]<<' '<<(d[1].id)<<' '<<d[1].x<<' '<<' ';
			if(ii[b[i]]){
				upd(1 , ii[b[i]] , 1 , tp , a[i]);
			}
			ct[b[i]] -= a[i];
			if(now == q){
				// cout<<'\n';
				for(int j = i;j <= n;j++) ct[b[j]] += a[j];
				return k;
			}
		}
				for(int j = 1;j <= n;j++) ct[b[j]] += a[j];
		return -1;
	}
	signed main(){
		n = read(),  m = read();
		xx = sqrt(n);
		int ccc = 0;
		for(int i = 1;i <=  n ; i ++) a[i] = read() , b[i] = read() , ct[b[i]] += a[i];
			int id = 0 , op , x , y;
		rebuild(0);
		bool fg = 0;
		while(m--){
			op=read(),x=read();
			if(op == 1){
				nnow++;
				y=read();
				a[x]  += y;
				ct[b[x]] += y;
				if(!ii[b[x]]){
					s[++tp] = b[x];
					ii[b[x]] = tp;
				}
			}			
			else{
				pt(query(x));
				putchar('\n');
			}
			// cerr<<"dw "<<tp<<'\n';
			if(tp >= B){
				// cerr<<"OK\n";
				rebuild();
			}
		}
		fwrite(obuf , p3 - obuf , 1 , stdout);
		return 0;
	}
}
signed main(){
	T = read();
	// if(T <= 7) return zj::main();
	// if(T <= 9) return no_op_2::main();
	// if(T <= 10) return b1::main();
	return zj::main();
}
```

---


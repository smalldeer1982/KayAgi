# 泡芙

## 题目背景

此题空间限制 $256$ MB，保证系统栈空间与内存限制大小相同。

## 题目描述

火星猫经过一番努力终于到达了冥王星。他发现冥王星有 $N$ 座城市，$M$ 条无向边。火星猫准备出发去找冥王兔，他听说有若干泡芙掉落在一些边上，他准备采集一些去送给冥王兔。但是火星猫的火星光环和冥王星相生相克，当火星猫走过一条路之后，这条路就不能再走了。如果冥王兔吃不到泡芙，他们就不能嘿嘿嘿了。所以告诉你火星猫和冥王兔的位置，请问冥王兔能不能吃到泡芙。

## 说明/提示

|  测试点编号  |     $N \le $      |     $M \le $      |     $Q \le $      |    特殊性质    |
| :----------: | :---------------: | :---------------: | :---------------: | :------------: |
|  $1 \sim 4$  |      $1000$       |       $N-1$       | $5 \times 10 ^ 4$ | 保证图是一棵树 |
|  $5 \sim 8$  | $3 \times 10 ^ 5$ |       $N-1$       | $3 \times 10 ^ 5$ |       无       |
| $9 \sim 10$  |       $20$        |       $50$        |        $5$        |       无       |
| $11 \sim 14$ |      $1000$       |      $5000$       | $5 \times 10 ^ 4$ |       无       |
| $15 \sim 20$ | $3 \times 10 ^ 5$ | $3 \times 10 ^ 5$ | $3 \times 10 ^ 5$ |       无       |

保证图联通。

## 样例 #1

### 输入

```
6 7
1 2 0
2 3 0
3 1 0
3 4 1
4 5 0
5 6 0
6 4 0
1
1 6```

### 输出

```
YES```

# 题解

## 作者：kradcigam (赞：12)

UPD2021.8.9：被 HACK 了，锅已经修好了；

UPD2022.10.28：修改了代码中的冗余部分。

这道题首先需要跑一遍边双连通分量，然后剩下来的就是一颗树，每个点有其点权，询问对于树上一条 $(u,v)$ 的简单路径，时候经过的点的点权和不为 $0$。

其他题解基本都是跑 LCA，去求路径的权值，其实这并没有必要，因为两点间的路径点权和为 $0$ 的是一个连通块，若询问的两点在同一个连通块里就说明它们之间路径的点权和为 $0$，求连通块可用并查集做，若想得到完美的 $O(n)$ 解，则可以 bfs。

bfs：

```cpp
#include<bits/stdc++.h>
#define log(a) cerr<<"\033[32m[DEBUG] "<<#a<<'='<<(a)<<" @ line "<<__LINE__<<"\033[0m"<<endl
#define fi first
#define se second
#define pb push_back
#define mp make_pair
#define SZ(x) ((int)x.size()-1)
#define ms(a,b) memset(a,b,sizeof a)
#define F(i,a,b) for(int i=(a);i<=(b);++i)
#define DF(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
inline int read(){char ch=getchar(); int w=1,c=0;
    for(;!isdigit(ch);ch=getchar()) if (ch=='-') w=-1;
    for(;isdigit(ch);ch=getchar()) c=(c<<1)+(c<<3)+(ch^48);
    return w*c;
}
const int N=3e5+10;
int n,m,cnt,dfn[N],low[N],sccnum[N],sk[N],sktot,scccnt,sccval[N],block[N];
int tot=1,hd[N<<1],nxt[N<<1],to[N<<1],val[N<<1];
int treetot,treehd[N<<1],treenxt[N<<1],treeto[N<<1];
void dfs(int x,int e){
    low[x]=dfn[x]=++cnt;
    sk[sktot++]=x;
    for(int i=hd[x];i;i=nxt[i])
        if(!dfn[to[i]]){
            dfs(to[i],i);
            low[x]=min(low[x],low[to[i]]);
        }else if(i^e^1){
        	low[x]=min(low[x],dfn[to[i]]);
        }
    if(low[x]==dfn[x]){
        scccnt++;
        do{
            sccnum[sk[--sktot]]=scccnt;
        }while(sk[sktot]!=x);
    }
}
int q[N];
int main(){
    n=read(),m=read();
    F(i,1,m){
        int x=read(),y=read(),z=read();
        nxt[++tot]=hd[x],hd[x]=tot,val[tot]=z,to[tot]=y;
        nxt[++tot]=hd[y],hd[y]=tot,val[tot]=z,to[tot]=x;
    }
    dfs(1,-1);
    F(i,1,n)
        for(int j=hd[i];j;j=nxt[j])
            if(sccnum[i]==sccnum[to[j]])sccval[sccnum[i]]+=val[j];
            else if(!val[j])treenxt[++treetot]=treehd[sccnum[i]],treehd[sccnum[i]]=treetot,treeto[treetot]=sccnum[to[j]];
    F(i,1,scccnt)
        if(!block[i]&&!sccval[i]){
            block[i]=i;
            q[1]=i;
            for(int l=1,r=1;l<=r;l++)
                for(int j=treehd[q[l]];j;j=treenxt[j])
                    if(!block[treeto[j]]&&!sccval[treeto[j]]){
                        block[treeto[j]]=i;
                        q[++r]=treeto[j];
                    }
        }
    int q=read();while(q--){
        int s=read(),t=read();
//      cout<<sccnum[s]<<" "<<sccnum[t]<<endl;
        if(!block[sccnum[s]]||!block[sccnum[t]])puts("YES");
        else if(block[sccnum[s]]==block[sccnum[t]])puts("NO");
            else puts("YES");
    }
}
```

~~卡常的最优解就不放了~~

---

## 作者：Acerkaio (赞：9)

### 思路：

易知：此题在同一个边双连通分量中的每一条边都可以走一遍，我们遍可以将一个边双连通分量，缩成一个点，这个点的点权 $w1_i$ 便是该边双连通分量边权和。

缩完之后，我们剩下的边都是割边，便是一颗树，那么 $s$ 到 $t$ 只会有一个简单路径，便是新图的 $col_s$ 到 $col_t$，$col_i$ 是 $i$ 所在的边双中的代表元素，即为 $col_s$ 到 $lca_{col_s, col_t}$ 的边权和加上 $col_t$ 到 $lca_{col_s, col_t}$的边权和，我们可以维护一个从根节点到每个点的边权和 $w2_i$ 那么答案即为

$w2_x + w2_y - 2 \times w2_{lca_{col_s, col_t}} + w1_{lca_{col_s, col_t}}$

### CODE:

```cpp
#include <bits/stdc++.h>
using namespace std;
const int _ = 1e6;

int head[_], tot = 1;
struct NODE {
	int x, y, edge, next;
} edge[_ << 1];

void add(int u, int v, int ed) {
	tot++;
	edge[tot].x = u;
	edge[tot].y = v;
	edge[tot].edge = ed;
	edge[tot].next = head[u];
	head[u] = tot;
}

int head1[_], thoth = 1;
struct ND {
	int x, y, edge, next;
} edge1[_ << 1];


void add1(int u, int v, int ed) {
	thoth++;
	edge1[thoth].x = u;
	edge1[thoth].y = v;
	edge1[thoth].edge = ed;
	edge1[thoth].next = head1[u];
	head1[u] = thoth;
}

int dfn[_], low[_], NOD, cut[_], w1[_], w2[_];
int col[_];
stack <int> lxq;
void Tarjan(int u, int ed) {
	dfn[u] = low[u] = ++NOD;
	lxq.push(u);
	for (int i = head[u], v; v = edge[i].y, i; i = edge[i].next) {
		if (!dfn[v]) {
			Tarjan(v, i);
			if (dfn[u] < low[v]) {
				cut[i] = cut[i ^ 1] = 1;
			}
			low[u] = min(low[u], low[v]);
		} else {
			if (i != (ed ^ 1)) {
				low[u] = min(low[u], dfn[v]);
			}
		}
	}
	if (dfn[u] == low[u]) {
		while (lxq.top() != u) {
			col[lxq.top()] = u;
			lxq.pop();
		}
		col[lxq.top()] = u;
		lxq.pop();
	}
}


/*po*/

int fa[_], Hson[_], Dep[_], Size[_], Top[_], seg[_], rev[_], DFNtot = 0;
void Podfs1(int p, int f, int deg) {
	fa[p] = f;
	Dep[p] = Dep[f] + 1;
	Size[p] = 1;
	w2[p] += w1[p] + deg;
	for (int i = head1[p]; i; i = edge1[i].next) {
		int v = edge1[i].y;
		if (v == f) continue;
		Podfs1(v, p, w2[p] + edge1[i].edge);
		Size[p] += Size[v];
		if (Size[v] > Size[Hson[p]]) Hson[p] = v;
	}
}
void Podfs2(int p, int top) {
	++DFNtot;
	Top[p] = top;
	seg[p] = DFNtot;
	rev[DFNtot] = p;
	if (Hson[p])
		Podfs2(Hson[p], top);
	for (int i = head1[p]; i; i = edge1[i].next) {
		int v = edge1[i].y;
		if (v == fa[p]) continue;
		if (Hson[p] != v) Podfs2(v, v);
	}
}

int LCA(int u, int v) {

	int fu = Top[u], fv = Top[v];
	while (fu != fv) {
//		cout << u << ' ' << v << '\n';
		if (Dep[fu] < Dep[fv]) swap(fu,fv), swap(u, v);
		u = fa[fu], fu = Top[u];
	}
	return Dep[u] < Dep[v] ? u : v;
}
signed main() {
	int n, m;
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		int x, y, z;
		cin >> x >> y >> z;
		add(x, y, z);
		add(y, x, z);
	}
	for (int i = 1; i <= n; i++)
		if (!dfn[i]) Tarjan(i, 0);
	for (int i = 1; i <= tot; i++) {
		int u = col[edge[i].x], v = col[edge[i].y], w = edge[i].edge;
		if (u == v) {
			w1[u] += w;
		} else {
			add1(u, v, w);
		}
	}
	
	Podfs1(1, 1, 0);
	Podfs2(1, 1);
	int q;
	cin >> q;
	
	for (int i = 1; i <= q; i++) {
		int x, y, lca;
		cin >> x >> y;
		//cout << x << ' ' << y << '\n'; 
		x = col[x], y = col[y];
//		cout << x << ' ' << y;
		lca = LCA(x, y);
		if (w2[x] + w2[y] - 2 * w2[lca] + w1[lca] > 0) cout << "YES\n";
		else cout << "NO\n";
	}
	return 0;
}
```


---

## 作者：_ckx_ (赞：8)

## 题目大意

给你一张无向图 ，边权为 $0/1$，有 $q$ 次询问，每次给定两个点 $s$ 和 $t$，在每条边都只能走一次的情况下，是否有一条从 $s$ 到 $t$ 的 **边权大于 $0$** 的路径。

## 分析

问题先转换为：在每条边都只能走一次的情况下，求两点之间是否有一条路径有边权为 $1$。

可以用 **tarjan** 先缩一遍双联通分量，此时需要维护一下这个点权，就是其中是否有边权为 $1$ 的边，如果走到这个点，就肯定有边权为 $1$ 的边（因为双联通分量里两两互相可达）。

此时，如果 $s$ 和 $t$ 在同一个双连通分量里，就判断这个点权是否为 $1$ 就行了。

如果不是，因为缩点后整个图就变成了一棵树，所以可以用 **LCA** 来求 $s$ 和 $t$ 所在的双联通分量之间是否有边权为 $1$ 的边。

因为需要求 **LCA**，所以还需要点权转边权，只需要把点权为 $1$ 的点，把所有连向、连出此点的边的边权都变为 $1$ 就行了。

具体过程见代码。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

int n ,m;
const int P = 25;
const int N = 3e5 + 10;

int low[N] ,dfn[N] ,tot ,cnt ,scc[N];
bool inst[N];
stack<int> st;

//第一个图
struct Edge{
	int to ,fr ,v ,nxt;
};
Edge e[N * 2];
int head[N] ,E; 

//第二个图
struct node{
	int to ,v;
};
int val[N]; //点(双联通分量)权
vector<node> g[N];

int fa[N][P] ,ev[N][P] ,dep[N] ,lg[N];

void add(int a ,int b ,int c)
{
	E++;
	e[E].nxt = head[a];
	e[E].fr = a ,e[E].to = b;
	e[E].v = c;
	head[a] = E;
}

//tarjan求双联通分量
void tarjan(int u ,int pre)
{
	dfn[u] = low[u] = ++tot;
	st.push(u);
	inst[u] = 1;
	bool f = false;
	for (int i = head[u];i;i = e[i].nxt)
	{
		int v = e[i].to;
		if (v == pre && !f) //有坑，有可能有另一条通往pre的边
		{
			f = true;
			continue;
		}
		if (!dfn[v])
		{
			tarjan(v ,u);
			low[u] = min(low[u] ,low[v]);
		}
		else if (inst[v])
			low[u] = min(low[u] ,dfn[v]);
	}

	if (dfn[u] == low[u])
	{
		int tp;
		cnt++;
		do{
			tp = st.top(); st.pop();
			inst[tp] = 0;
			scc[tp] = cnt;
		} while (tp != u);
	}
}

//初始化LCA必需品
void dfs(int u ,int pre)
{
	dep[u] = dep[pre] + 1;
	for (auto v : g[u])
	{
		if (v.to != pre)
		{
			fa[v.to][0] = u;
			ev[v.to][0] = val[v.to] | val[u] | v.v; //点权转边权
			dfs(v.to ,u);
		}
	}
}

//预处理
void init()
{
	for (int i = 2;i < N;i++)
	{
		lg[i] = lg[i >> 1] + 1;
	}
	for (int i = 1;i < P;i++)
	{
		for (int j = 1;j <= cnt;j++)
		{
			fa[j][i] = fa[fa[j][i - 1]][i - 1];
			ev[j][i] = ev[j][i - 1] | ev[fa[j][i - 1]][i - 1];
		}
	}
}

//LCA 
bool LCA(int x ,int y)
{
	if (dep[x] < dep[y])
		swap(x ,y);
	int ans = 0;
	while (dep[x] > dep[y])
	{
		ans |= ev[x][lg[dep[x] - dep[y]]]; //ans为0或1，记录当前是否有边权为1的边
		x = fa[x][lg[dep[x] - dep[y]]];
	}
	if (x == y)
		return ans;
	for (int i = P - 1;i >= 0;i--)
	{
		if (fa[x][i] != fa[y][i])
		{
			ans |= ev[x][i] | ev[y][i];
			x = fa[x][i] ,y = fa[y][i];
		}
	}
	ans |= ev[x][0] | ev[y][0]; //最后别忘了这个
	return ans;
}

int main()
{
	scanf("%d%d",&n ,&m);

	for (int i = 1;i <= m;i++)
	{
		int x ,y ,z;
		scanf("%d%d%d",&x ,&y ,&z);

		add(x ,y ,z);
		add(y ,x ,z);
	}

	for (int i = 1;i <= n;i++)
		if (!dfn[i])
			tarjan(i ,0);

	//缩点
	for (int i = 1;i <= 2 * m;i++)
	{
		int u = e[i].fr ,v = e[i].to;
		if (scc[u] == scc[v]) //缩点权=其中边的边权或起来
		{
			val[scc[u]] |= e[i].v;
		}
		else
		{
			node tmp;
			tmp.to = scc[v] ,tmp.v = e[i].v;
			g[scc[u]].push_back(tmp); //重新建图
		}
	}

	dfs(1 ,0);
	init();

	int q;
	scanf("%d",&q);

	while (q--)
	{
		int s ,t;
		scanf("%d%d",&s ,&t);

		if (scc[s] == scc[t]) //如果在同一个双联通分量里，就判断双联通分量里是否有1
		{
			if (val[scc[s]])
			{
				printf("YES\n");
			}
			else
			{
				printf("NO\n");
			}
		}
		else if (LCA(scc[s] ,scc[t]))
		{
			printf("YES\n");
		}
		else
		{
			printf("NO\n");
		}
	}

	return 0;
}
```

---

## 作者：Link_Cut_Y (赞：3)

### 简化题意

给定一个无向图 $G$，每条边有边权 $0 / 1$，现给定 $m$ 组询问，每次询问形如 $s, t$，问是否可以从 $s$ 走到 $t$，边权和为正数且不会重复经过一条边。

### 题目分析

本题可以使用 ***tarjan*** 算法。

可以想一下，如果在从 $s$ 到 $t$ 的路径上有一个环，那么我们一定会选择经过这个环。因为走完整条环之后可以回到起点，不会重复经过某一条路，而且还有可能多加一点边权。

因此考虑缩点。使用 tarjan 算法将所有边双连通分量缩成点。

边权转点权时，设有边 $(u, v)$，边权为 $1$ ，那么可以新建一个节点，将边权存在这个点的点权上。

如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/g633ecax.png)

缩点时将每个新点的点权设成连通分量内所有点的点权的或，换言之，就是设置成“连通分量内是否有点权为 $1$ 的点 （若有则为 $1$，否则为 $0$）”。

缩点之后图会变成一棵树。之后 $m$ 次操作就是询问从 $u$ 到 $v$ 两个点之间的路径权值和是否大于等于 $1$，可以使用树上差分解决。

时间复杂度大概是 $O(m + Q \log n)$ 的样子。跑的大概没有题解里的其他 dalao 快

### CODE

```
// Author:Lcy
// Date:2022.07.15

#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>

using namespace std;

const int N = 300010;

int n, m;
int h[N << 1], e[N << 2], ne[N << 2], w[N << 1], idx = 1;
int stk[N << 1], timestamp, top;
int dfn[N << 1], low[N << 1], val[N << 1];
int color[N << 1];
int cnt, fa[N << 1], dep[N << 1], sz[N << 1];
int son[N << 1], s[N << 1], Top[N << 1], id[N << 1];
int from[N], to[N];

void add(int a, int b)
{
	e[ ++ idx] = b, ne[idx] = h[a], h[a] = idx;
}

void tarjan(int u, int from)
{
	dfn[u] = low[u] = ++ timestamp;
	stk[ ++ top] = u;
	
	for (int i = h[u]; i; i = ne[i])
	{
		int j = e[i];
		if (!dfn[j]) {
			tarjan(j, i);
			low[u] = min(low[u], low[j]);
		}
		else if (i != (from ^ 1))
			low[u] = min(low[u], dfn[j]);
	}
	
	if (dfn[u] == low[u])
	{
		cnt ++ ;
		int y;
		do {
			y = stk[top -- ];
			val[cnt] |= w[y];
			color[y] = cnt;
		} while (y != u);
	}
}

void dfs1(int u, int father, int depth)
{
	fa[u] = father, dep[u] = depth, sz[u] = 1;
	s[u] = s[fa[u]] + (val[u] == 1);
	
	for (int i = h[u]; i; i = ne[i])
	{
		int j = e[i];
		if (j == father) continue;
		dfs1(j, u, depth + 1);
		sz[u] += sz[j];
		if (sz[son[u]] < sz[j]) son[u] = j;
	}
}

void dfs2(int u, int t)
{
	Top[u] = t, id[u] = ++ cnt;
	
	
	if (!son[u]) return;
	dfs2(son[u], t);
	
	for (int i = h[u]; i; i = ne[i])
	{
		int j = e[i];
		if (j == fa[u] || j == son[u]) continue;
		dfs2(j, j);
	}
}

int lca(int u, int v)
{
	while (Top[u] != Top[v])
	{
		if (dep[Top[u]] <= dep[Top[v]]) swap(u, v);
		u = fa[Top[u]];
	}
	if (dep[u] > dep[v]) swap(u, v);
	return u;
}

bool query(int u, int v)
{
	int LCA = lca(u, v);
	return (s[u] - s[LCA] + s[v] - s[LCA] + val[LCA]);
}

int main()
{
	scanf("%d%d", &n, &m);
	
	for (int i = 1; i <= m; i ++ )
	{
		int z;
		scanf("%d%d%d", &from[i], &to[i], &z);
		add(from[i], n + i), add(n + i, from[i]);
		add(n + i, to[i]), add(to[i], n + i);
		w[n + i] = z;
	}
	
	tarjan(1, -1);
	
	memset(h, 0, sizeof h);
	memset(e, 0, sizeof e);
	memset(ne, 0, sizeof ne);
	idx = 0;
	
	for (int i = 1; i <= m; i ++ ) {
		if (color[from[i]] != color[n + i])
			add(color[from[i]], color[n + i]), 
			add(color[n + i], color[from[i]]);
		if (color[to[i]] != color[n + i])
			add(color[to[i]], color[n + i]),
			add(color[n + i], color[to[i]]);
	}
	
	dfs1(1, -1, 1), dfs2(1, 1);
	
	int Q;
	scanf("%d", &Q);
	
	while (Q -- )
	{
		int u, v;
		scanf("%d%d", &u, &v);
		(query(color[u], color[v])) ? (puts("YES")) : (puts("NO"));
	}
	
	return 0;
}
```

---

## 作者：StayAlone (赞：3)

### 题意

在一个联通有边权的无向图上，边权为 $0$ 或 $1$，$Q$ 组询问，是否存在一条从 $s\to t$ 的路径，使得路径边权和大于 $0$。  

### 思路

有一个很显然的结论：在一个边双联通分量内，一定可以把所有的边权走到。所以先把所有边双缩点，建成一棵树。这棵树有点权和边权，点权是所有该边双内的边权和。  

定义这棵树的根为 $1$，定义一种前缀和。$sum_i$ 表示从根到点 $i$ 的路径上的所有边权与点权之和，包括点 $i$。如果要求 $s\to t$ 的路径之和，就是求 $a_s \to a_t$ 的路径之和。其中 $a_i$ 表示点 $i$ 所在的边双编号。那么 $u\to v$ 的路径上的能走过的边权和就是 $sum_u + sum_v - 2\times sum_{lca(u, v)} + w_{lca(u, v)}$。其中 $lca(u, v)$ 表示点 $u$ 和点 $v$ 的最近公共祖先，$w_i$ 表示点 $i$ 的点权。如果这个和大于 $0$，输出 `YES`，否则输出 `NO`。  

[AC code 记录](https://www.luogu.com.cn/record/65306146)  

```cpp
#include <bits/stdc++.h>
#define rep1(i, j, n) for (int i = j; i <= int(n); ++i)
#define rep2(i, j, n) for (int i = j; i >= int(n); --i)
#define rep(i, x) for (int i = pnt[x]; i; i = nxt[i])
#define ptc putchar
#define rout return 0
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
const int MAXN = 6e5 + 10, inf = ~0U >> 2, INF = ~0U >> 1;
namespace stupid_lrc
{
	template <typename T>
	il void read(T &x)

    il int read()
    
	template <typename T>
	il void write(T x)

	template <typename T>
	il T my_max(const T &x, const T &y)
	
	template <typename T>
	il T my_min(const T &x, const T &y)

	template <typename T>
	il T lowbit(const T &x)
} // 奇妙缺省源 
using namespace stupid_lrc;
int dep, n, m, t = 1, cnt, x, y, z, q, pnt[MAXN], ver[MAXN], nxt[MAXN], wit[MAXN];
int low[MAXN], dfn[MAXN], a[MAXN], siz[MAXN], sum[MAXN]; bool vis[MAXN];
stack<int> st; vector <pii>lnk[MAXN];
int d[MAXN], f[25][MAXN];

il void add(const int &u, const int &v, const int &w)
{
	ver[++t] = v, nxt[t] = pnt[u], wit[t] = w, pnt[u] = t;
}

il void add2(const int &u, const int &v, const int &w)
{
	lnk[u].pb(mp(v, w));
}

il void dfs(int x, int f)
{
	low[x] = dfn[x] = ++dep; st.push(x);
	rep(i, x)
	{
		int v = ver[i];
		if ((i ^ f) == 1) continue;
		if (!dfn[v]) dfs(v, i), low[x] = my_min(low[x], low[v]);
		else low[x] = my_min(low[x], dfn[v]);
	}
	if (low[x] == dfn[x])
	{
		a[x] = ++cnt;
		while (st.top() ^ x) a[st.top()] = cnt, st.pop();
		st.pop();
	}
}

il void dfsum(int x, int p)
{
	d[x] = d[p] + 1; f[0][x] = p;
	for (auto t : lnk[x])
		if (t.fst ^ p) sum[t.fst] += t.snd + sum[x], dfsum(t.fst, x);
}

il int lca(int u, int v)
{
	if (d[u] > d[v]) swap(u, v);
	int hd = d[v] - d[u];
	rep2(i, 21, 0) if (hd >= (1 << i)) v = f[i][v], hd -= (1 << i);
	if (u == v) return u;
	rep2(i, 21, 0) if (f[i][u] ^ f[i][v]) u = f[i][u], v = f[i][v];
	return f[0][v];
}

int main()
{
	read(n); read(m);
	rep1(i, 1, m) read(x), read(y), read(z), add(x, y, z), add(y, x, z);
	dfs(1, 0);
	rep1(i, 1, n) rep(j, i)
	{
		int u = i, v = ver[j], w = wit[j];
		if (a[u] ^ a[v]) add2(a[u], a[v], w);
		else if (w) ++siz[a[u]];
	}
	rep1(i, 1, cnt) siz[i] >>= 1, sum[i] = siz[i];
	// 注意同一条边因为是双向的，所以边权会算两次，因此真正的边权需要除以 2，不过其实不影响 
	dfsum(1, -1);
	f[0][1] = 1;
	rep1(i, 1, 21) rep1(j, 1, n) f[i][j] = f[i - 1][f[i - 1][j]];
	int Q = read(); while (Q--)
	{
		int u = read(), v = read(), l;
		u = a[u], v = a[v], l = lca(u, v);
		bool k = sum[u] + sum[v] - (sum[l] << 1) + siz[l];
		puts(k ? "YES" : "NO");
	}
	rout;
}
```

---

## 作者：aoeiuv (赞：2)

一条道路只会经过一次，而在一个边双连通分量中，两点之间至少会有两条道路相通，对于询问的两个点如果在一个边双里面，那么就可以先去找一条有泡芙的边，再走到另一个点去。这就启发我们先对图进行边双缩点缩成一棵树，如果询问的两个点在同一个的边双中，那么只要判断这个边双里有无泡芙的边即可。反之，我们就在缩点后的树上查找，路径上是否有含有泡芙的边的边双即可。

路径查找写一个树剖有点太蠢了，可以沿用 [CSP-S 2022] 数据传输 的做法，倍增预处理一个 $g_{i,j}$ 数组表示 $i$ 的 $2^j$ 级祖先内是否有含有泡芙边的边双，然后对于一次询问 $(x,y)$，在查询 $x,y$ 的最近公共祖先的同时把所有 $g$ 的值或起来即可。

时间复杂度 $\mathcal{O}((n+q)\log n)$。

---

## 作者：Shunpower (赞：2)

## 前置知识

- 您需要知道如何求桥，否则请移步[ P1656 炸铁路 ](https://www.luogu.com.cn/problem/P1656)的 Tarjan 做法。
- 您需要知道边双连通分量的基本性质。

## 思路

提示：接下来所有形似“$u\to v$ 路径的点权和”的描述中，点权和都包括 $u,v$ 的点权。

> 当火星猫走过一条路之后，这条路就不能再走了

从这句话我们可以想出来，如果走过的这条路是桥，那么火星猫就会再也无法走回去。

那么我们可以先求一遍边双并缩点。如果您不会求边双，您可以看[这个云剪贴板](https://www.luogu.com.cn/paste/4t16jiue)。

求边双的同时我们可以标记该边双内是否有有泡芙的边。

求出边双缩点后再建图，由边双连通分量缩点的性质我们知道缩出来的一定是棵树，而且树上的边都是桥。所以问题转变为：

一棵树上每个点有点权（点权即该边双内是否有泡芙），每个边有边权（边权即该桥上是否有泡芙），问树上 $u\to v$ 的一条路径上点权和或边权和是否大于等于 $1$。

我们可以从根向下进行前缀和。每个点都有两个值要存储：一个是从根到这个点的路径的点权和，一个是从根到这里的路径的边权和。

我们再求出 $(u,v)$ 的 LCA。如果您不会 LCA 请移步[ P3379 最近公共祖先](https://www.luogu.com.cn/problem/P3379)。

接下来对于 $u\to v$ 路径的点权和和边权和分别推式子：

- [推点权和式子的云剪贴板](https://www.luogu.com.cn/paste/yr9kdvk3)
- [推边权和式子的云剪贴板](https://www.luogu.com.cn/paste/u27oaqom)

最后只需要检查边权和和点权和的值即可。

## 代码

您需要知道我的宏定义都是什么意思，您可以在[这里](https://www.luogu.com.cn/paste/fg7wzaxe)查看我的缺省源。

这里省略了求桥部分，您可以移步[ P1656 炸铁路](https://www.luogu.com.cn/problem/P1656)的 Tarjan 做法学习如何求桥。

### 3.1 求边双连通分量

DFS 不走桥边法求边双：
```
void dfs(int x){
	eccnum[x]=tnt;
	efor(i,x){
		int y=edge[i].toe;
		if(eccnum[x]==eccnum[y]){//可能存在重边而不同权值的情况
			if(edge[i].val==1){
				has[tnt]=1;
			}
			ctn;//避免无限递归
		}
		if(bridge[i]){//不走桥
			ctn;
		}
		if(edge[i].val==1){//边的权值表示是否有泡芙
			has[tnt]=1;
		}
		dfs(y);
	}
}
```
$has$ 数组所表示的是该边双中是否有泡芙，$tnt$ 是当前边双连通分量的编号。

主函数中调用它的方式如下：
```
fr1(i,1,n){//图里面不一定只有一个边双
	if(!eccnum[i]){
		tnt++;
		dfs(i);
	}
}
```
只有这样才能保证每个点都有了对应的边双。

### 3.2 建边双缩点后的树

这里只需要注意链式前向星的细节问题就行了：

```
fr1(i,2,edgecnt-1){
	int x=edge[i^1].toe,y=edge[i].toe;
	if(eccnum[x]!=eccnum[y]){
		p[eccnum[x]].pb(mp(eccnum[y],edge[i].val));
	}
}
```

另附上我的链式前向星函数方便理解上面的代码：

```
int edgecnt=2;
struct Edge{
	int toe,val,nex;
} edge[N+N];
int head[N+N];
void add(int x,int y,int w){
	edge[edgecnt].toe=y;
	edge[edgecnt].val=w;
	edge[edgecnt].nex=head[x];
	head[x]=edgecnt;
	edgecnt++;
}
```

### 3.3 初始化 LCA 和前缀和

从这里开始，我们默认 $1$ 为树根，将这棵树变为有根树。

注意，前缀和点权前要将`pointvalue[1]=has[1]`，即要将树根处的点权前缀和初始化为树根边双是否有泡芙。

接下来就可以从树根开始往下 DFS，同时做边权前缀和与点权前缀和。此外，我们可以顺便完成 LCA 的初始化。 

```
void dfs2(int x,int fa){
	deep[x]=deep[fa]+1;
	f[x][0]=fa;//同时初始化算 LCA 要用的几个数组 
	fv(i,p[x]){
		if(p[x][i].fi!=fa){//避免无限递归
			tsum[p[x][i].fi]=tsum[x]+p[x][i].se;
			psum[p[x][i].fi]=psum[x]+has[p[x][i].fi];//垒两个前缀和
			dfs2(p[x][i].fi,x);
		}
	}
}
```

$psum$ 是点权前缀和，$tsum$ 是边权前缀和。主函数中应该如下调用：

```
psum[1]=has[1];//不可缺失的初始化！！！
dfs2(1,1);
```

### 3.4 LCA

倍增 LCA 的部分您可以移步[ P3379 最近公共祖先](https://www.luogu.com.cn/problem/P3379)。

注意 LCA 的递推部分，不要把循环写反。只要心中牢记 $f$ 数组的含义，就永远不会发生问题。

下面给出一种参考写法：

```
num=log2(n);
fr1(j,1,num){
	fr1(i,1,n){
		f[i][j]=f[f[i][j-1]][j-1];
	}
}
```

求 LCA 的部分不给出参考代码。

### 3.5 处理询问

```
cin>>q;
while(q--){
	int x,y;
	cin>>x>>y;
	x=eccnum[x];
	y=eccnum[y];
	int lcaa=lca(x,y);
	if((psum[x]+psum[y]-psum[lcaa]-psum[(lcaa==1?0:f[lcaa][0])])||(tsum[x]+tsum[y]-tsum[lcaa]-tsum[lcaa])){
		puts("YES");
	}
	else{
		puts("NO");
	}
}
```

注意输入的并不是边双的编号，我们要自己转化一下。

求出 LCA 后就可以套用思路里面推出的公式了。注意我们在计算点权贡献时要判断 $lcaa$ 是否是 $1$，如果是的话就不能减去`psum[f[lcaa][0]]`（因为 LCA 预处理时我们使用了`f[1][0]=1`），而是要减去 $0$。

## AC 记录

[AC 记录](https://www.luogu.com.cn/record/66194932)

---

## 作者：Anaxagoras (赞：2)

### 0xFF 前置知识

[树链剖分](https://oiwiki.com/graph/hld/)

[点双连通分量](https://oiwiki.com/graph/bcc/)

### 0x01 题目大意

给你一张 $n$ 个结点 $m$ 条边的无向图，以及 $q$ 个询问，每次询问给定起点、终点，求是否可以做到从起点走到终点且满足：

1. 走过至少一条边权为 $1$ 的边。

1. 不重复走同一条边。

### 0x02 思路

由于这是一张无向图，所以只要走到一个节点，该节点所在的点双连通分量（后简称“点双”）的结点一定可以走到，所以我们不妨用 Tarjan 把点双缩成一个点，这样这张图就成了一个无向无环图，也就是一棵树。要查找从一个点到另一个点的一条路径上是否有边权为 $1$ 的边，这就可以用树链剖分。不过这是边权，树链剖分要的是点权，所以我们可以用前缀和的思想。用一个数组把从根节点（由于这是无根树，所以不妨设为 $1$）到这个节点的前缀和存在一个数组里。由于不可以走重复路径，所以也就是求起点到起点与终点的 LCA 到终点的路径上有没有边权为 $1$ 的边。求 LCA 也可以用树链剖分解决，所以便可以开始愉快地 Coding 了~

### 0x03 AC Code

```cpp
//by olkieler
#include <bits/stdc++.h>
#define int long long
#define linf LLONG_MAX
#define iinf INT_MAX
#define ios ios::sync_with_stdio(0);cin.tie(0);
#define N 300005
#define M 300005
#define mod 1000000007
#define pint pair<int, int>
#define mp make_pair
using namespace std;
inline int r(){int x;cin >> x;return x;}
inline void w(int x){cout << x << '\n';}
inline void W(int x){cout << x << ' ';}
stack<int>s;
struct node
{
	int next;
	int pointer;
	int value;
};
node edge[M << 1];
int tot = 1, sum, rk, n = r(), m = r();
bool vis[N];//不知道干什么用的
int from[N];//边的起点
int to[N];//边的终点
int value[N];//边的边权
int head[N];//链式前向星
int dfn[N];//dfn 序
int low[N];//求不经过父亲结点能达到的最小 dfn
int tag[N];//标记在哪个点双中
int cnt[N];//缩点后总泡芙数
int son[N];//缩点后子树结点个数
int hson[N];//重儿子
int dep[N];//缩点后的深度
int fa[N];//缩点后的父亲结点
int top[N];//链顶
int pre[N];//前缀和
inline void add(int u, int v, int w)
{
	edge[++ tot].next = v;
	edge[tot].pointer = head[u];
	edge[tot].value = w;
	head[u] = tot;
}//加边
inline void tarjan(int x, int rank)
{
	dfn[x] = ++ tot;
	low[x] = tot;
	vis[x] = 1;
	s.push(x);
	for (int i = head[x]; i; i = edge[i].pointer)
	{
		int y = edge[i].next;
		if (!dfn[y])
		{
			tarjan(y, i);
			low[x] = min(low[x], low[y]);
		}
		else if (i ^ rank ^ 1)
		{
			low[x] = min(low[x], dfn[y]);
		}
	}//求点双
	if (dfn[x] == low[x])
	{
		sum ++;
		int z = s.top();
		s.pop();
		while (1)
		{
			tag[z] = x;
			vis[z] = 0;
			if (z == x)
			{
				break;
			}
			z = s.top();
			s.pop();
		}
	}//缩点
}//Tarjan
inline void dfs1(int x, int f, int pa)
{
	son[x] = 1;
	dep[x] = dep[f] + 1;
	fa[x] = f;
	pre[x] += pre[f] + pa + cnt[x];
	for (int i = head[x]; i; i = edge[i].pointer)
	{
		int y = edge[i].next, z = edge[i].value;
		if (y == f)
		{
			continue;
		}
		dfs1(y, x, z);
		son[x] += son[y];
		if (son[hson[x]] < son[y])
		{
			hson[x] = y;
		}
	}
}
inline void dfs2(int x, int t)
{
	top[x] = t;
	if (!hson[x])
	{
		return ;
	}
	dfs2(hson[x], t);
	for (int i = head[x]; i; i = edge[i].pointer)
	{
		int y = edge[i].next;
		if (y == fa[x] || y == hson[x])
		{
			continue;
		}
		dfs2(y, y);
	}
}//树剖
inline int LCA(int u, int v)
{
	int tu = top[u], tv = top[v];
	while (tu != tv)
	{
		if (dep[tu] < dep[tv])
		{
			swap(tu, tv);
			swap(u, v);
		}
		u = fa[tu];
		tu = top[u];
	}
	if (dep[u] > dep[v])
	{
		swap(u, v);
	}
	return u;
}//树剖求 LCA
inline bool query(int u, int v)
{
	int lca = LCA(u, v);
	return pre[u] + pre[v] - 2 * pre[lca] + cnt[lca];//前缀和求区间和
}
signed main()
{
    ios;
    for (int i = 1; i <= m; i ++)
    {
    	from[i] = r();
		to[i] = r();
		value[i] = r();
    	add(from[i], to[i], value[i]);
    	add(to[i], from[i], value[i]);
    }//加边
    for (int i = 1; i <= n; i ++)
    {
    	if (!dfn[i])
    	{
    		tarjan(i, 0);
    	}
    }//Tarjan
    tot = 0;
    memset(head, 0, sizeof(head));
    for (int i = 1; i <= m; i ++)
    {
    	if (tag[from[i]] == tag[to[i]])
    	{
    		cnt[tag[from[i]]] += value[i];
    	}
    	else
    	{
    		add(tag[from[i]], tag[to[i]], value[i]);
    		add(tag[to[i]], tag[from[i]], value[i]);
    	}
    }//重构图
    dfs1(1, 0, 0);
    dfs2(1, 1);//树剖
    int q = r();
    for (int asdf = 1; asdf <= q; asdf ++)
    {
    	int u = r(), v = r();
    	cout << (query(tag[u], tag[v]) ? "YES\n" : "NO\n");//查询
    }
    return 0;
}
```

---

## 作者：DengDuck (赞：1)

我来补充两点，不介绍做法。

## 一种基于脑子有病的处理重边方法

这题的 Hack 主要是重边问题，就是原图是可以有重边的，当然边权不同。

那么可能由于有些同学跟我一样，求边双用的是打标记找连通块法（给桥打标记然后暴力找所有的连通块），那么这种方法可能并不能把两条这样的边看作不同的边，导致找不到一条回去的返祖边，于是算法认为两个边都是桥，这就错了。

这个你考虑记录 $x\to y$ 的数量，如果不止一条就不要记录成桥即可，我用了 `map`。

是不是很唐？唐就对了，但是这是可以过的，而且可以证明是正确的，空间使用需要略微优化一手。

## 倍增跳

大多数人的题解都是利用树上差分来做，但是这样有个小缺点，就是要考虑算重的问题。

而且其实只要链上有一个 $1$ 就行了，求和复杂了问题。

可以直接维护 $f_{i,j}$ 表示 $i$ 向上跳 $2^j$ 步路径或者点上是否有 $1$。

然后类似求解 LCA 的写法，两个点倍增跳，同时统计答案即可。

```cpp
#include<bits/stdc++.h>
#define LL int
#define pLL pair<LL,LL>
#define fir first
#define sec second
#define pb push_back
using namespace std;
const LL N=3e5+5;
const LL M=19;
LL n,m,q,low[N],dfn[N],b[N],cnt,f[N][M+5],Fa[N][M+5],tot,C[N],vis[N],hav[N],dep[N];
struct node
{
	LL to,w,id;
};
map<LL,LL>ma[N];
vector<node>V[N];
void dfs(LL x,LL fa)
{
	dfn[x]=low[x]=++cnt;
	for(node i:V[x])
	{
		if(i.to==fa)continue;
		if(!dfn[i.to])
		{
			dfs(i.to,x);
			low[x]=min(low[x],low[i.to]);
			if(low[i.to]>dfn[x]&&ma[x][i.to]==1)b[i.id]=1;
		}
		else low[x]=min(low[x],dfn[i.to]);
	}
}
set<pLL>v[N];
void work(LL x,LL c)
{
	vis[x]=1;
	C[x]=c;
	for(node i:V[x])
	{
		if(b[i.id]==1)
		{
			if(C[i.to])
			{
				if(v[c].count({C[i.to],1-i.w}))
				{
					if(i.w==0)continue;
					else v[c].erase({C[i.to],1-i.w}),v[C[i.to]].erase({c,1-i.w});
				}
				v[c].insert({C[i.to],i.w});
				v[C[i.to]].insert({c,i.w});
			}
			continue;
		}
		hav[c]|=i.w;
		if(vis[i.to])continue;
		
		work(i.to,c);
	}
}
void prework(LL x,LL fa,LL w)
{
	Fa[x][0]=fa,f[x][0]=w|hav[x]|hav[fa];
	for(int i=1;i<=M;i++)Fa[x][i]=Fa[Fa[x][i-1]][i-1],f[x][i]=f[x][i-1]|f[Fa[x][i-1]][i-1];
	dep[x]=dep[fa]+1;
	for(pLL i:v[x])
	{
		if(i.fir==fa)continue;
		prework(i.fir,x,i.sec);
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		LL x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		ma[x][y]++,ma[y][x]++;
		V[x].pb({y,z,i}),V[y].pb({x,z,i});
	}
	for(int i=1;i<=n;i++)
	{
		if(!dfn[i])dfs(i,0);
	}
	for(int i=1;i<=n;i++)
	{
		if(!vis[i])work(i,++tot);
	}
	prework(1,0,0);
	scanf("%d",&q);
	while(q--)
	{
		LL x,y;
		scanf("%d%d",&x,&y);
		LL ans=hav[C[x]]|hav[C[y]];
		x=C[x],y=C[y];
		if(dep[x]<dep[y])swap(x,y);
		for(int i=M;i>=0;i--)if(dep[x]-(1ll<<i)>=dep[y])ans|=f[x][i],x=Fa[x][i];
		for(int i=M;i>=0;i--)
		{
			if(Fa[x][i]!=Fa[y][i])
			{
				ans|=f[x][i]|f[y][i];
				x=Fa[x][i],y=Fa[y][i];
			}
		}
		if(x!=y)ans|=f[x][0]|f[y][0];
		if(ans)puts("YES");
		else puts("NO");
	}
}
```

---

## 作者：Bodhi (赞：1)

## 前置知识

边双连通分量

[Link-Cut Tree](https://oi-wiki.org/ds/lct/) 维护点权、边权的操作

## 初步思路

只要不走重复，边就可以随意走，于是我们先求一个边双连通分量。

**为了便于表示，我们将点 $x$ 所在的边双连通分量记作 $belong_x$**

然后，这张图就被我们转化成了一个带有点权和边权的无根树。

询问时，如果两个点处在同一个连通分量中，判断这个连通分量转换成的点权值是否为 $0$。

如果不在一个连通分量中，就需要求出从 $belong_s$ 到 $belong_t$ 的简单路径的权值和是否为 $0$。

## 简化题意

求边双连通分量，建成一颗带有点权和边权的无根树，询问路径的权值和。

按照一般的思路，我们可以将边权映射到点权，然后使用 LCA 和树上差分来解决。

**你说得对，但是：点权、边权、路径和？这不就是一个 Link-Cut Tree 维护路径权值和的板子吗？！**

于是，这就变成了一篇**致敬 Tarjan 先生的题解**（Tarjan 算法求 e-DCC 和 Tarjan 发明的 LCT）。

## 变量释义

`bcc`：边双连通分量计数器。

`puff[i]`：标记编号为 $i$ 的分量中是否有泡芙。

`ptot`：记录目前 LCT 中的总点数。

`e_to_p[{x, y}]`：记录 $belong_x$ 和 $belong_y$ 所连的边 对应到 LCT 中点的编号。

其他的变量名无需特别说明，看代码就完了。

## 代码（马蜂良好（确信））

```cpp
#include <bits/stdc++.h>
using namespace std;

const int R = 3e5 + 10;
class // 为了代码结构清晰，我将 LCT 放在一个 class 中
{
public:
	struct
	{
		int son[2], val, res, fa;
		bool tag;
	} t[R + R];
#define lc(k) t[k].son[0]
#define rc(k) t[k].son[1]
#define fa(k) t[k].fa
#define reverse(k) swap(lc(k), rc(k)), t[k].tag ^= 1
#define connect(x, f, k) t[f].son[k] = x, fa(x) = f
#define notroot(x) (lc(fa(x)) == x || rc(fa(x)) == x)
#define isrc(x) (rc(fa(x)) == x)
	void pushup(int k)
	{
		t[k].res = t[lc(k)].res + t[rc(k)].res + t[k].val;
	}
	void pushdown(int k)
	{
		if (t[k].tag)
		{
			if (lc(k))
			{
				reverse(lc(k));
			}
			if (rc(k))
			{
				reverse(rc(k));
			}
			t[k].tag = false;
		}
	}
	void pushdownall(int x)
	{
		if (notroot(x))
		{
			pushdownall(fa(x));
		}
		pushdown(x);
	}
	void rotate(int x)
	{
		int f = fa(x), ff = fa(f), k = isrc(x);
		if (notroot(f))
		{
			t[ff].son[isrc(f)] = x;
		}
		fa(x) = ff;
		connect(t[x].son[k ^ 1], f, k);
		connect(f, x, k ^ 1);
		pushup(f), pushup(x);
	}
	void splay(int x)
	{
		pushdownall(x);
		int f;
		while (notroot(x))
		{
			f = fa(x);
			if (notroot(f))
			{
				isrc(x) ^ isrc(f) ? rotate(x) : rotate(f);
			}
			rotate(x);
		}
	}
	void access(int x)
	{
		for (int y = 0; x; y = x, x = fa(x))
		{
			splay(x);
			rc(x) = y;
			pushup(x);
		}
	}
	void makeroot(int x)
	{
		access(x);
		splay(x);
		reverse(x);
	}
	int findroot(int x)
	{
		access(x);
		splay(x);
		while (lc(x))
		{
			x = lc(x);
		}
		splay(x);
		return x;
	}
	void link(int x, int y)
	{
		makeroot(x);
		fa(x) = y;
	}
	void split(int x, int y)
	{
		makeroot(x);
		access(y);
		splay(y);
	}
} lct;
struct
{
	int x, to, nxt;
	bool w; // w 代表是否有泡芙
} e[R + R];
map<pair<int, int>, int> e_to_p;
int head[R], tot, dfn[R], low[R], tme, belong[R], bcc, sta[R], top;
bool puff[R];
void add(int x, int y, bool v)
{
	e[tot] = {x, y, head[x], v};
	head[x] = tot++;
}
void tarjan(int x, int frome)
{
	dfn[x] = low[x] = ++tme;
	sta[++top] = x;
	for (int i = head[x], to; ~i; i = e[i].nxt)
	{
		to = e[i].to;
		if (!dfn[to])
		{
			tarjan(to, i);
			low[x] = min(low[x], low[to]);
		}
		else if (i != (frome ^ 1))
		{
			low[x] = min(low[x], dfn[to]);
		}
	}
	if (low[x] == dfn[x])
	{
		++bcc;
		while (sta[top] != x)
		{
			belong[sta[top--]] = bcc;
		}
		belong[sta[top--]] = bcc;
	}
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	memset(head, -1, sizeof(head));
	int i, n, m, q, x, y, w, ptot = 0;
	cin >> n >> m;
	for (i = 1; i <= m; ++i)
	{
		cin >> x >> y >> w;
		add(x, y, w);
		add(y, x, w);
	}
	tarjan(1, 0);
	ptot = bcc;
	for (i = 0; i <= tot; i += 2)
	{
		x = belong[e[i].x], y = belong[e[i].to];
		if (x == y)
		{
			puff[x] |= e[i].w;
		}
	}
	for (i = 1; i <= bcc; ++i)
	{
		lct.t[i].val = lct.t[i].res = puff[i];
	}
	for (i = 0; i <= tot; i += 2)
	{
		x = belong[e[i].x], y = belong[e[i].to];
		if (x != y)
		{
			if (lct.findroot(x) != lct.findroot(y))
			{
				e_to_p[{x, y}] = e_to_p[{y, x}] = ++ptot;
				lct.link(x, ptot), lct.link(ptot, y);
			}
			if (e[i].w)
			{
				w = e_to_p[{x, y}];
				lct.splay(w);
				lct.t[w].val = 1;
				lct.pushup(w);
			}
		}
	}
	cin >> q;
	while (q--)
	{
		cin >> x >> y;
		x = belong[x], y = belong[y];
		lct.split(x, y);
		cout << (lct.t[y].res ? "YES\n" : "NO\n");
	}
	return 0;
}
```

附上[ AC 记录](https://www.luogu.com.cn/record/142268645) ~~（荣幸地获得了最慢解）~~。

## 杂谈

最初想做这题是在 NOIp 之前集训的时候刷洛谷月赛题，第一道就是这个 ~~；还有一个原因是题目的名字和 Furina 有关（看完剧情水元素充盈了，当场变厨子）~~。

想到 LCT 的做法是因为我最近一直在做这种题。

先前听闻 LCT 的常数很大，刚做这题的时候还以为要卡常才能过去，结果跑得比我预想中要快一些。


---

## 作者：未来姚班zyl (赞：1)

## 题目大意

给定一个联通无向图，带有边权 $0$ 或 $1$，多次询问存不存在起点为 $S$，终点为 $T$，每条边最多经过一次，且至少有一条边边权是 $1$ 的路径。

## 题目分析

显然，对于一个边双联通分量，我们总可以从任意一个节点出发，经过我们想要经过的边，到任意的另一个节点结束。所以我们可以考虑将原图按照边双缩点，原图就被缩成了一颗树。显然，**树边是走了就没有回头路的**，这是这题的关键，答案也就呼之欲出了。

我们将缩完点之后的每个点附一个点权。对于每个边双，连接其内部节点的边权存在 $1$，则缩完点后该点点权为 $1$，否则为 $0$。然后树边就保持其原本的边权即可。

处理完后，查询也就很简单了。如果两点在同一个边双内，显然就只能在里面走，因为出去了就回不来，直接判断点权。不在同一个边双的话，显然只能走树上的路径，路径上经过的点或边只要有一个的权值是 $1$ 就可行，否则不可行。这个很好判断，维护一个到根的前缀和，然后差分一下就可以啦（这里可以直接看代码）！

复杂度 $O(n+q\log n)$，常数很小！

```cpp
#include<bits/stdc++.h>
#define ll long long
#define L x<<1
#define R x<<1|1
#define mid (l+r>>1)
#define lc L,l,mid
#define rc R,mid+1,r
#define OK l>=Ll&&r<=Rr
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define per(x,y,z) for(int x=(y);x>=(z);x--)
#define e(x) for(int i=h[x];i;i=nxt[i])
inline int read(){int s=0,w=1;char c=getchar();while(c<48||c>57) {if(c=='-') w=-1;c=getchar();}while(c>=48&&c<=57) s=(s<<1)+(s<<3)+c-48,c=getchar();return s*w;}
inline void pf(ll x){if(x<0) putchar('-'),x=-x;if(x>9)pf(x/10);putchar(x%10+48);}
const int N =3e5+5,M=4e7+5,inf=2147000000;
const int mod=1e9+7;
using namespace std;
int cnt=1,n,m,q,h[N],to[N*2],nxt[N*2],dfn[N],low[N],w[N*2],Time,stac[N],frm[N],top,scc[N],bel[N];
struct node{
	int a,b,c;
}e[N];
inline void add(int a,int b,int c){
	to[++cnt]=b,nxt[cnt]=h[a],h[a]=cnt,w[cnt]=c;
}
inline void tarjan(int x){
	dfn[x]=low[x]=++Time,stac[++top]=x;
	for(int i=h[x];i;i=nxt[i]){
		int y=to[i];
		if(i==(frm[x]^1))continue;
		if(!dfn[y]){
			frm[y]=i;
			tarjan(y);
			low[x]=min(low[y],low[x]);
		}
		else low[x]=min(low[x],dfn[y]);
	}
	if(dfn[x]==low[x]){
		cnt++;
		while(top){
			int y=stac[top--];
			bel[y]=cnt;
			if(y==x)break;
		}
	}
}
int tp[N],f[N],dep[N],siz[N],son[N],val[N];
inline void dfs(int x,int fa){
	dep[x]=dep[fa]+1,siz[x]=1,f[x]=fa;
	e(x){
		int y=to[i];
		if(y^fa){
			val[y]=val[x]+w[i]+scc[x],dfs(y,x),siz[x]+=siz[y];
			if(siz[y]>siz[son[x]])son[x]=y;
		}
	}
}
inline void Dfs(int x,int low){
	tp[x]=low;
	if(son[x])Dfs(son[x],low);
	e(x){
		int y=to[i];
		if(y^f[x]&&y^son[x])Dfs(y,y);
	}
}
inline int lca(int x,int y){
	while(tp[x]^tp[y])dep[tp[x]]<dep[tp[y]]?y=f[tp[y]]:x=f[tp[x]];
	return dep[x]<dep[y]?x:y;
}
int main(){
	n=read(),m=read();
	for(int i=1,x,y,z;i<=m;i++)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z),e[i]=node{x,y,z};
	cnt=0,tarjan(1);
	rep(i,1,cnt)h[i]=0;
	cnt=0;
	rep(i,1,m){
		int l=e[i].a,r=e[i].b;
		if(bel[l]==bel[r])scc[bel[l]]|=e[i].c;
		else add(bel[l],bel[r],e[i].c),add(bel[r],bel[l],e[i].c);
	}
	dfs(1,0),Dfs(1,1),q=read();
	for(int i=1,x,y;i<=q;i++){
		x=read(),y=read();
		int l=bel[x],r=bel[y];
		if(l==r)printf("%s\n",scc[l]?"YES":"NO");
		else {
			int Lca=lca(l,r);
			int k=val[l]+val[r]+scc[l]+scc[r]-2*val[Lca]-scc[Lca];
			printf("%s\n",k?"YES":"NO");
		}
	}
	return 0;
}
```


---

## 作者：Hooch (赞：1)

### 题目大意

给定一个有 $N$ 个点，$M$ 条边的**有向图**，每条边的边权是 $1$ 或 $0$。

一共有 $Q$ 次询问，每次询问有两个点 $S$ 和 $T$，让你求出**当每条边只能经过一次时**，$S\to T$ 这条路径上是否有边的边权为 $1$。

有即输出 `YES`，否则输出 `NO`。

### 思路

首先题目有个重要要求：每条边只能经过一次，确定了 $S\to T$ 只能是简单路径。我们可以发现这可以和**边双联通分量**扯上关系。

先把边双连通分量缩成一个点，因为边双联通分量中任何一条边都可以被经过。也就是说，任意一个边双联通分量中若有一条边边权为 $1$​​​​，则只要 $S\to T$​​​ 中经过了这个连通分量，就能经过那条边权为 $1$​ 的边。

接下来我们来看桥（割边），这个部分很简单，同样只需要看 $S\to T$ 的路径中有无桥边权为 $1$ 即可。

### 代码实现

对于这个查询两个点是否经过边权为 $1$​ 的​边，可以用支持静态查询的**前缀和**来维护。

由于边双联通分量缩成点之后一定是一棵**树**，我们就可以用 $\textrm{LCA}$​​ 了。

部分代码：

```cpp
int tot = 1; //注意！这里一定赋成 1，不然下面代码中的 bridge[i^1] 会错。
struct node {int to, nxt, dis;} edge[M << 1], G[M], EDGE[M << 1];
//G是存输入的数组，而edge是tarjan和缩点用的边
il void ADD(int x, int y, int w) {EDGE[++TOT] = (node) {x, y, w}; NEXT[TOT] = HEAD[x]; HEAD[x] = TOT;}
il void add(int x, int y, int z) {edge[++tot] = (node) {x, y, z}; next[tot] = head[x]; head[x] = tot;}
il void tarjan(int x, int last) { 
	dfn[x] = low[x] = ++cnt;
	for (int i = head[x]; i; i = next[i]) {
		int v = edge[i].nxt;
		if (!dfn[v]) {
			tarjan(v, i);
			low[x] = min(low[x], low[v]);
			if (low[v] > dfn[x]) bridge[i] = bridge[i ^ 1] = 1;
		} else if (i != (last ^ 1)) low[x] = min(low[x], dfn[v]); //注意 dfn[v] 不是 low[v]。
	}
}//Tarjan
```
***
```cpp
il void draw(int x, int cl) {
	col[x] = cl;
	for (int i = head[x]; i; i = next[i]) {
		if (/*如果是桥就不是边双联通分量*/bridge[i] || col[edge[i].nxt]) continue;
		draw(edge[i].nxt, cl);
	}
}//缩边双联通分量成点
```
******
```cpp
il void dfs(int x, int f) {
	fa[x][0] = f; d[x] = d[f] + 1;
	for (int i = HEAD[x]; i; i = NEXT[i]) {
		int v = EDGE[i].nxt;
		if (v == f) continue;
		sz[v] += sz[x]; //前缀和点权
		val[v] = val[x] + EDGE[i].dis; //前缀和边权
		dfs(v, x);
	}
}//dfs初始化
```
***
```cpp
il int lca(int u, int v) {
	if (d[v] < d[u]) swap(u, v);
	int t = d[v] - d[u];
	rep2(i, 19, 0) if (t >= (1 << i)) t -= 1 << i, v = fa[v][i];
	if (u == v) return u;
	rep2(i, 19, 0) if (fa[v][i] ^ fa[u][i]) v = fa[v][i], u = fa[u][i];
	return fa[u][0];
}//正常的LCA
```
***
```cpp
rep1(i, 1, m) {
	int u = G[i].to, v = G[i].nxt, w = G[i].dis;
	if (col[u] == col[v]) {if (w) sz[col[u]] = 1; continue;} //初始化边双连通分量中有无边权为 1 的边
	ADD(col[u], col[v], w); ADD(col[v], col[u], w);
}//重新建缩点之后的图
```
***
```cpp
rep1(i, 1, q) {
    int s, t; read(s); read(t);
    int p = lca(col[s], col[t]);
    int ans1 = sz[col[s]] + sz[col[t]] - sz[p] - sz[fa[p][0]]; //算出点上的值
    int ans2 = val[col[s]] + val[col[t]] - val[p] * 2; //算出边上的值
    if (ans1 || ans2) puts("YES"); else puts("NO");
}//输出答案
```
***

[完整代码](https://www.luogu.com.cn/paste/oe8clmeg)

---

## 作者：ljc20020730 (赞：0)

首先，如果一个边双$e-dcc$中含有一条标记边，那么这个边双里面所有的点都可以得到泡芙。

那么这道题就非常显然了，利用tarjan求出无向图中所有的$e-dcc$ 缩点，对于每一个缩点后的点记录前缀点权和和前缀边权和。

一个图上的路径就可以对应到图中的缩点之后的生成树上面的一条树的路径，用前缀和维护这条路径上有泡芙的个数即可。

只要点上或者边上有救可以，所以我们只需要求一个lca，然后用预处理出的前缀点权和和前缀边权和来求解。


```cpp
# include<bits/stdc++.h>
# define int long long 
using namespace std;
const int N=3e5+10;
struct rec{ int pre,to,w;}a[N<<1];
struct edge{ int u,v,w;};
vector<edge>E;
stack<int>s;
int dfn[N],low[N],c[N],val[N][2],g[N][22],dep[N],head[N];
int n,m,tot=1,cnt;
bool bridge[N<<1];
void adde(int u,int v,int w)
{
	a[++tot].pre=head[u];
	a[tot].to=v;
	a[tot].w=w;
	head[u]=tot;
}
void tarjan(int u,int e)
{
	dfn[u]=low[u]=++dfn[0]; 
	for (int i=head[u];i;i=a[i].pre) {
		int v=a[i].to;
		if (!dfn[v]) {
			tarjan(v,i); low[u]=min(low[u],low[v]);
			if (low[v]>dfn[u]) bridge[i]=bridge[i^1]=1;
		} else if (i!=(e^1)) low[u]=min(low[u],dfn[v]);
	}
}
void draw(int u,int col)
{
	c[u]=col;
	for (int i=head[u];i;i=a[i].pre) {
		int v=a[i].to; if (bridge[i]||c[v]) continue;
		draw(v,col);
	}
}
void dfs(int u,int fa)
{
	g[u][0]=fa; dep[u]=dep[fa]+1;
	for (int i=head[u];i;i=a[i].pre) {
		int v=a[i].to; if (v==fa) continue;
		val[v][0]+=val[u][0];
		val[v][1]=val[u][1]+a[i].w;
		dfs(v,u);
	}
}
void init()
{
	for (int i=1;i<=21;i++)
	 for (int j=1;j<=cnt;j++)
	  g[j][i]=g[g[j][i-1]][i-1];
}
int lca(int u,int v)
{
	if (dep[u]<dep[v]) swap(u,v);
	for (int i=21;i>=0;i--)
	 if (dep[g[u][i]]>=dep[v]) u=g[u][i];
	if (u==v) return u;
	for (int i=21;i>=0;i--)
	 if (g[u][i]!=g[v][i]) u=g[u][i],v=g[v][i];
	return g[u][0];
}
signed main()
{
	scanf("%lld%lld",&n,&m);
	for (int i=1;i<=m;i++) {
		int u,v,w; scanf("%lld%lld%lld",&u,&v,&w);
		adde(u,v,0); adde(v,u,0);
		E.push_back((edge){u,v,w});
	}
	for (int i=1;i<=n;i++) if (!dfn[i]) tarjan(i,0);
	for (int i=1;i<=n;i++) if (!c[i]) draw(i,++cnt);
	tot=0; memset(head,0,sizeof(head)); memset(a,0,sizeof(a));
	for (int i=0;i<(int)E.size();i++) {
		int u=E[i].u,v=E[i].v,w=E[i].w;
		if (c[u]==c[v]) { if (w) val[c[u]][0]=1; continue;}
		adde(c[u],c[v],w); adde(c[v],c[u],w);
	}
	dfs(1,0); init();
	int Q; scanf("%lld",&Q);
	while (Q--) {
		int u,v; scanf("%lld%lld",&u,&v);
		int l=lca(c[u],c[v]);
		int ret0=val[c[u]][0]+val[c[v]][0]-val[g[l][0]][0]-val[l][0];
		int ret1=val[c[u]][1]+val[c[v]][1]-2*val[l][1];
		if (ret0 || ret1) puts("YES"); else puts("NO");
	}
	return 0;
}
```


---

## 作者：cheng2010 (赞：0)

# 泡芙
## 思路
发现，在一个**点双**中，每个点都可以互相到达，此时若其中一条边有泡芙，那么相当于所有边都有泡芙了，所以考虑 tarjan 按每个点双缩点，此时图就变成了一颗**树**，用 LCA 差分就好了。

### 注意
有恶心的**重边**，要处理一下。这里用的是 map。

## code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e5+7;
int n,m;
int head[N];
struct EDGE
{
	int frm,to,val;
}edge[N<<1],e[N],f[N];
int cnt=1;
int tot,id;
int low[N],dfn[N];
bool brige[N<<1];
int as;
bool bz[N];
int col[N];
int val[N],sum[N];
map<int,map<int,int> > p;
inline void add(int x,int y,int z)
{
	edge[++cnt].to=y;
	edge[cnt].val=z;
	edge[cnt].frm=head[x];
	head[x]=cnt;
}
inline void tarjan(int x,int fa)
{
	low[x]=dfn[x]=++id;
	for(int i=head[x];i;i=edge[i].frm)
	{
		int v=edge[i].to;
		if(!dfn[v])
		{
			tarjan(v,x);
			low[x]=min(low[x],low[v]);
			if(low[v]>dfn[x])
				brige[i]=brige[i^1]=1;
		}
		else if(v!=fa)
			low[x]=min(low[x],dfn[v]);
	}
}
inline void dfs(int x,int id)
{
	bz[x]=1;
	col[x]=id;
	for(int i=head[x];i;i=edge[i].frm)
	{
		int v=edge[i].to;
		if(!bz[v]&&!brige[i])
		{
			val[id]+=edge[i].val;
			dfs(v,id);
		}
	}
}
int son[N],fa[N],dep[N],siz[N],top[N];
inline void dfs1(int x)
{
	son[x]=-1;
	siz[x]=1;
	for(int i=head[x];i;i=edge[i].frm)
	{
		int v=edge[i].to;
		int w=edge[i].val;
		if(dep[v]) continue;
		sum[v]=sum[x]+val[v]+w;
		fa[v]=x;
		dep[v]=dep[x]+1;
		dfs1(v);
		siz[x]+=siz[v];
		if(son[x]==-1||siz[son[x]]<siz[v])
			son[x]=v;
	}
}
inline void dfs2(int x,int t)
{
	top[x]=t;
	cnt++;
	dfn[x]=cnt;
	if(son[x]==-1) return;
	dfs2(son[x],t);
	for(int i=head[x];i;i=edge[i].frm)
	{
		int v=edge[i].to;
		if(v==son[x]||v==fa[x]) continue;
		dfs2(v,v);
	}
}
inline int LCA(int x,int y)
{
    while(top[x]!=top[y])
	{
		if(dep[top[x]]>dep[top[y]])
			x=fa[top[x]];
		else
			y=fa[top[y]];
	}
	return dep[x]>dep[y]?y:x;
}
inline void init(int s)
{
	sum[1]=val[1];
	dep[s]=1;
	dfs1(s);
	dfs2(s,s);
}
int cm,sm;
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		int x,y,z;
		scanf("%d %d %d",&x,&y,&z);
		if(x>y) swap(x,y); 
		if(p[x][y]==0)
		{
			p[x][y]=cm+1;
			e[++cm]={x,y,z};
		}
		else
		{
			f[++sm]={x,y,0};
			e[p[x][y]].val=1;
		}
	}
	for(int i=1;i<=cm;i++)
	{
		add(e[i].frm,e[i].to,e[i].val);
		add(e[i].to,e[i].frm,e[i].val);
	}
	for(int i=1;i<=n;i++) 
		if(!dfn[i])
			tarjan(i,i);
	for(int i=1;i<=sm;i++) brige[f[i].frm]=brige[f[i].to]=0;
	for(int i=1;i<=n;i++)
		if(!bz[i])
			dfs(i,++as);
	cnt=0;
	memset(edge,0,sizeof(EDGE));
	memset(head,0,sizeof(head));
	for(int i=1;i<=cm;i++)
	{
		int x=col[e[i].frm];
		int y=col[e[i].to];
		int v=e[i].val;
		if(x!=y)
		{
			add(x,y,v);
			add(y,x,v);
		}
	}
	cnt=0;
	init(1);
	int q;
	scanf("%d",&q);
	while(q--)
	{
		int x,y;
		scanf("%d %d",&x,&y);
		int la=LCA(col[x],col[y]);
		int k=sum[col[x]]+sum[col[y]]-2*sum[la]+val[la];
		puts(k<=0?"NO":"YES");
	}
}
```

---


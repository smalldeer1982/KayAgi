# 雪辉

## 题目背景

**时间限制3s，空间限制512MB**


三周目的由乃被钦定成为了卡密，她立刻赶去二周目的世界寻找雪辉

但是按照设定，两个平行世界是没法互相影响的，也就是原则上由乃是没法去二周目世界的

这时候Deus又跳出来说，其实设定是作者骗你的，只要爱的力量足够强大什么都可以做到（好狗血）


Deus：由乃你为了雪辉是不是什么都可以做呀

yuno：当然啦这还用想

Deus：那你帮我做个题吧

yuno：只要不是数据结构，什么题我都做

Deus：出题人是那个n????????呀，他出（抄）的题除了傻逼数据结构还有啥。。。

yuno：你说的很有道理。。。

Deus：上次那个题你不是两分钟就秒了吗，这个题比那个还简单

yuno：（小声）其实那个是bzoj上面的大佬帮我做的

Deus：好吧就这么愉快的钦定了

![](https://cdn.luogu.com.cn/upload/pic/4134.png)


## 题目描述

给一个n个点的树，点有点权，有m次询问，每次询问多条链的并有多少种不同的点权以及它的mex

mex就是一个集合中最小的没有出现的非负整数，注意0要算

比如说集合是1,9,2,6,0,8,1,7，则出现了0,1,2,6,7,8,9这7种不同的点权，因为没有3所以mex是3

![](https://cdn.luogu.com.cn/upload/pic/4132.png)


## 说明/提示

设a的和为q

对于20%的数据，n,q<=1000，f=0

对于另外30%的数据，n,q<=100000，树是一条链，f=0

对于所有数据n,q<=100000,且点权<=30000


最后，由乃祝大家新年快乐

![](https://cdn.luogu.com.cn/upload/pic/4135.png)


## 样例 #1

### 输入

```
10 1 0
0 0 0 1 1 0 2 2 1 2 
2 3
1 2
4 5
3 4
7 8
6 7
5 6
9 10
8 9
1
6 8```

### 输出

```
2 1```

## 样例 #2

### 输入

```
10 1 1
0 0 1 0 0 2 2 0 0 0 
2 3
1 2
4 5
3 4
7 8
6 7
5 6
9 10
8 9
4
1 7
3 3
1 1
9 3
```

### 输出

```
3 3```

# 题解

## 作者：DPair (赞：8)

提供一种纯树剖+bitset的写法。

喜提洛谷最慢解。

~~怎么人均树分块啊，感觉我要被lxl卡了~~

## 【思路】
首先又是数颜色又是mex的，很容易想到bitset。

一种很naive的想法就是树剖，然后去暴力合并bitset。

~~（然而这种naive的做法稍微改一改居然能过。）~~

也就是对于树剖后建出来的那一棵线段树，每一个节点存一个 bitset 表示这个区间内的并集。

然后你会发现空间开不下。

考虑怎么节约空间。

我们不难发现线段树越深的节点存的信息越少，到最后一层干脆只有 $1$ 个数了。

于是考虑把线段树的最后两层割掉不用 bitset 维护，而用 pair 去维护。

这样空间缩小了四倍就可以卡过去了，最底下两层由于不用bitset，消耗空间相比之下基本可以忽略不计。

实现上由于要求 mex ，我用了手写 bitset 。

具体实现上其实也没什么特别的，线段树上合并信息就直接对两个 bitset 取或，然后就得到了一个 bitset 表示这些链的数集之并。

那么两个询问的结果都出来了，用 bitset 基本操作的 count 什么的乱搞一下就行了。

是在线的。

然后就一遍 A 了。

复杂度似乎是 $O({nV\log^2n \over w})$ 的？

~~所以我为什么能A啊。。。~~

## 【代码】
```cpp
#include <cstdio>
#include <cstring>
#include <bits/stl_pair.h>
using std :: pair;
using std :: make_pair;
template <typename T>
inline void read(T &x){
    x = 0;int fu = 1;
    char c = getchar();
    while(c > 57 || c < 48){
        if(c == 45) fu = -1;
        c = getchar();
    }
    while(c <= 57 && c >= 48){
        x = (x << 3) + (x << 1) + c - 48;
        c = getchar();
    }
    x *= fu;
}
template <typename T>
inline void fprint(T x){
    if(x < 0) putchar(45), x = -x;
    if(x > 9) fprint(x / 10);
    putchar(x % 10 + 48);
}
template <typename T>
inline void fprint(T x, char ch){
    fprint(x);putchar(ch);
}

#define MAXN 100005
typedef unsigned long long ULL;
int n, m, f;
const int V = 470;
const ULL MOD = 18446744073709551615ull;
struct Bitset{
    ULL bit[475];
    Bitset (){memset(bit, 0, sizeof(bit));}
    inline void ins(int x){
        bit[x >> 6] |= 1ull << (x & 63);
    }
    inline void del(int x){
        bit[x >> 6] &= (MOD ^ 1ull << (x & 63));
    }
    inline void clear(){memset(bit, 0, sizeof(bit));}
    inline Bitset operator | (const Bitset &b) const{
        Bitset ret;
        for (register int i = 0;i < V;i ++) ret.bit[i] = bit[i] | b.bit[i];
        return ret;
    }
    inline int mex(){
        for (register int i = 0;i < V;i ++){
            if(bit[i] ^ MOD){
                for (register int j = 0;j < 64;j ++){
                    if(!((bit[i] >> j) & 1)) return i << 6 | j;
                }
            }
        }
    }
    inline int count(){
        int ret = 0;
        for (register int i = 0;i < V;i ++){ret += __builtin_popcountll(bit[i]);}
        return ret;
    }
}t[MAXN];
int a[MAXN];

#define LSON rt << 1, l, mid
#define RSON rt << 1 | 1, mid + 1, r
typedef pair <int, int> pi;
pi val[MAXN << 2];
int b[MAXN], dep[MAXN], sz[MAXN], fa[MAXN], son[MAXN], id[MAXN], tp[MAXN];
int head[MAXN], e[MAXN << 1], nxt[MAXN << 1], cnt;
inline void add(int u, int v){
    nxt[++ cnt] = head[u];
    head[u] = cnt;
    e[cnt] = v;
}
void dfs1(int x, int pre){
    fa[x] = pre;dep[x] = dep[pre] + 1;sz[x] = 1;
    for (register int i = head[x];i;i = nxt[i]){
        if(e[i] == pre) continue;
        dfs1(e[i], x);
        sz[x] += sz[e[i]];
        if(sz[e[i]] > sz[son[x]]) son[x] = e[i];
    }
}
int tot;
void dfs2(int x, int tt){
    tp[x] = tt;id[x] = ++ tot;b[tot] = a[x];
    if(son[x]) dfs2(son[x], tt);
    for (register int i = head[x];i;i = nxt[i]){
        if(e[i] == son[x] || e[i] == fa[x]) continue;
        dfs2(e[i], e[i]);
    }
}
inline void pushup(int rt, int l, int r){
    if(r - l + 1 <= 2){
        val[rt].first = val[rt << 1].first;
        val[rt].second = val[rt << 1 | 1].first;
    }
    else {
        int mid = (l + r) >> 1;
        if(mid - l + 1 <= 2) {
            t[rt].clear();
            if(~val[rt << 1].first) t[rt].ins(val[rt << 1].first);
            if(~val[rt << 1].second) t[rt].ins(val[rt << 1].second);
        }
        else t[rt] = t[rt << 1];
        if(r - mid <= 2){
            if(~val[rt << 1 | 1].first) t[rt].ins(val[rt << 1 | 1].first);
            if(~val[rt << 1 | 1].second) t[rt].ins(val[rt << 1 | 1].second);
        }
        else t[rt] = t[rt] | t[rt << 1 | 1];
    }
}

#define LSON rt << 1, l, mid
#define RSON rt << 1 | 1, mid + 1, r

void build(int rt, int l, int r){
    if(l == r){
        val[rt].first = b[l];
        val[rt].second = -1;
        return ;
    }
    int mid = (l + r) >> 1;
    build(LSON);build(RSON);
    pushup(rt, l, r);
}

pi Query(int rt, int l, int r, int x, int y){
    if(x <= l && r <= y) return val[rt];
    int mid = (l + r) >> 1;
    if(x <= mid && y > mid) return make_pair(Query(LSON, x, y).first, Query(RSON, x, y).first);
    if(x <= mid) return Query(LSON, x, y);
    else return Query(RSON, x, y);
}

Bitset query(int rt, int l, int r, int x, int y){
    if(x <= l && r <= y){
        if(r - l + 1 <= 2) {
            Bitset ret;
            if(~val[rt].first) ret.ins(val[rt].first);
            if(~val[rt].second) ret.ins(val[rt].second);
            return ret;
        }
        else return t[rt];
    }
    Bitset ret;
    int mid = (l + r) >> 1;
    if(x <= mid) ret = query(LSON, x, y);
    if(y > mid) ret = ret | query(RSON, x, y);
    return ret;
}
Bitset QUERY(int u, int v){
    Bitset ret;
    while(tp[u] ^ tp[v]){
        if(dep[tp[u]] < dep[tp[v]]) u ^= v ^= u ^= v;
        if(id[u] - id[tp[u]] + 1 <= 2){
            pi res = Query(1, 1, n, id[tp[u]], id[u]);
            if(~res.first) ret.ins(res.first);
            if(~res.second) ret.ins(res.second);
        }
        else ret = ret | query(1, 1, n, id[tp[u]], id[u]);
        u = fa[tp[u]];
    }
    if(id[u] > id[v]) u ^= v ^= u ^= v;
    if(id[v] - id[u] + 1 <= 2){
        pi res = Query(1, 1, n, id[u], id[v]);
        if(~res.first) ret.ins(res.first);
        if(~res.second) ret.ins(res.second);
    }
    else ret = ret | query(1, 1, n, id[u], id[v]);
    return ret;
}
int ans;
int main(){
    read(n);read(m);read(f);
    for (register int i = 1;i <= n;i ++) read(a[i]);
    for (register int i = 1;i < n;i ++){
        int u, v;read(u);read(v);
        add(u, v);add(v, u);
    }
    dfs1(1, 0);dfs2(1, 1);
    build(1, 1, n);
    while(m --){
        ans *= f;
        int k, u, v;
        Bitset ret;read(k);
        while(k --){
            read(u);read(v);u ^= ans, v ^= ans;
            ret = ret | QUERY(u, v);
        }
        int num1 = ret.mex(), num2 = ret.count();
        ans = num1 + num2;
        fprint(num2, 32);fprint(num1, 10);
    }
}
```

---

## 作者：orz_z (赞：6)

给你一棵 $n$ 个节点且带点权的树，$m$ 个询问，每个询问给你多条链，请你输出这几条链的点的集合并的颜色数和 `mex`。

强制在线。

$1\leq n \leq 10^5,1\leq m\leq 3 \times 10^4$。

#### sol

首先如果不强制在线，用树上莫队即可。

但多了个强制在线，容易想到是预处理题。

查询链颜色数，比较好的一种方法是使用 `bitset`，对值域建 `bitset`，答案就是 `bitset` 中 $1$ 的数量。

对于 `mex`，在 `bitset` 上暴力找第一个为 $0$ 的位即可。

 那么现在的问题就是怎么把一条路径上的 `bitset` 并起来。

**法一**

考虑树分块。

考虑用一种简单的树分块技巧——树上撒点。

简单来说就是先设一个阈值 $S$，在树上选择不超过 $\frac{n}{S}$ 个点作为关键点，满足每个关键点到离它最近的祖先关键点的距离不超过 $S$。

具体地，每次选择当前深度最大的一个非关键点，若它的 $1 \sim S$ 级祖先都不是关键点，则把它的 $S$ 级祖先标记为关键点。

由于上述方法中每标记一个关键点，至少有 $S$ 个点不会被标记，所以关键点的数量是正确的。

仔细思考，容易发现每个关键点到离它最近的祖先关键点的距离不超过 $S$ 这个条件也满足。

撒完关键点，再记录两关键点间的 `bitset`，先用 $\mathcal O(S)$ 的时间求出相邻两关键点的 `bitset`，再处理出两两之间的即可，预处理总时间复杂度为 $\mathcal O(\frac{n^2}{S}+\frac{n^3}{wS^2})$。

然后考虑询问，此时询问的路径就被拆成了两个散块和一个整块，散块暴力，整块 `bitset` 取交集即可，总时间复杂度为 $\mathcal O(mS+\frac{nm}{w})$。

取 $S=\sqrt n$，则总时间复杂度为 $\mathcal O((n+m)\sqrt n+\frac{n^2+nm}{w})$，可过。

$\text{5.05s / 346.17MB / 4.14KB C++20 O2}$。

```cpp
#include <cstdio>
#include <bitset>
#include <algorithm>

using namespace std;

namespace Fread
{
    const int SIZE = 1 << 23;
    char buf[SIZE], *S, *T;
    inline char getchar()
    {
        if (S == T)
        {
            T = (S = buf) + fread(buf, 1, SIZE, stdin);
            if (S == T)
                return '\n';
        }
        return *S++;
    }
}
namespace Fwrite
{
    const int SIZE = 1 << 23;
    char buf[SIZE], *S = buf, *T = buf + SIZE;
    inline void flush()
    {
        fwrite(buf, 1, S - buf, stdout);
        S = buf;
    }
    inline void putchar(char c)
    {
        *S++ = c;
        if (S == T)
            flush();
    }
    struct NTR
    {
        ~NTR()
        {
            flush();
        }
    } ztr;
}

#ifdef ONLINE_JUDGE
#define getchar Fread::getchar
#define putchar Fwrite::putchar
#endif

inline int read()
{
	int x = 0, f = 1;
	char c = getchar();
	while (c < '0' || c > '9')
	{
		if (c == '-')
			f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9')
	{
		x = x * 10 + c - '0';
		c = getchar();
	}
	return x * f;
}

inline void write(int x)
{
	if (x < 0)
	{
		putchar('-');
		x = -x;
	}
	if (x > 9)
		write(x / 10);
	putchar(x % 10 + '0');
}

const int _ = 2e5 + 7;

bitset<_> bt[202][202], nw;

int n, m, B, kkk, a[_], fa[_], dep[_], mxd[_], FF[_], siz[_], tp[_], hson[_];

int id[_], cnt, head[_], tot, ans, ans1, ans2, sta[_], top, gg[_];

struct edge
{
	int to, nxt;
} e[_ << 1];

void dfs1(int now, int D)
{
	siz[now] = 1;
	dep[now] = D;
	mxd[now] = dep[now];
	for (int i = head[now]; i; i = e[i].nxt)
	{
		int v = e[i].to;
		if (!dep[v])
		{
			fa[v] = now;
			dfs1(v, D + 1);
			siz[now] += siz[v];
			if (mxd[v] > mxd[now])
				mxd[now] = mxd[v];
			if (siz[hson[now]] < siz[v])
				hson[now] = v;
		}
	}
	if (mxd[now] - dep[now] >= 1000)
		id[now] = ++tot, mxd[now] = dep[now];
}

void dfs2(int now)
{
	for (int i = head[now]; i; i = e[i].nxt)
	{
		int v = e[i].to;
		if (dep[v] > dep[now])
		{
			if (id[v])
			{
				int ip = id[sta[top]], in = id[v];
				for (int x = v; x != sta[top]; x = fa[x])
					bt[ip][in].set(a[x]);
				nw = bt[ip][in];
				for (int i = 1; i < top; ++i)
				{
					bitset<_> &bs = bt[id[sta[i]]][in];
					bs = bt[id[sta[i]]][ip];
					bs |= nw;
				}
				FF[v] = sta[top], gg[v] = gg[sta[top]] + 1;
				sta[++top] = v;
			}
			dfs2(v);
			if (id[v])
				--top;
		}
	}
}

void dfs3(int now, int tf)
{
	tp[now] = tf;
	if (hson[now])
		dfs3(hson[now], tf);
	for (int i = head[now]; i; i = e[i].nxt)
	{
		int v = e[i].to;
		if (!tp[v])
			dfs3(v, v);
	}
}

inline int LCA(int x, int y)
{
	while (tp[x] != tp[y])
	{
		if (dep[tp[x]] < dep[tp[y]])
			swap(x, y);
		x = fa[tp[x]];
	}
	return dep[x] < dep[y] ? x : y;
}

inline int mex(bitset<_> &s)
{
  for (int i = 0; i < _; ++i)
    if (!s.test(i)) return i;
  return 1e9;
}

signed main()
{
	n = read(), m = read(), kkk = read();
	for (int i = 1; i <= n; ++i)
		a[i] = read();
	for (int i = 1, u, v; i < n; ++i)
	{
		u = read(), v = read();
		e[++cnt] = (edge) {v, head[u]}, head[u] = cnt;
		e[++cnt] = (edge) {u, head[v]}, head[v] = cnt;
	}
	dfs1(1, 1);
	if (!id[1])
		id[1] = ++tot;
	sta[top = 1] = gg[1] = 1;
	dfs2(1);
	dfs3(1, 1);
	int z, u, v;
	while (m--)
	{
		z = read();
		nw.reset();
		while(z--)
		{
			u = read(), v = read();
			if(kkk) u ^= ans, v ^= ans;
			int l = LCA(u, v);
			while (u != l && !id[u])
				nw.set(a[u]), u = fa[u];
			while (v != l && !id[v])
				nw.set(a[v]), v = fa[v];
			if (u != l)
			{
				int pre = u;
				while (dep[FF[pre]] >= dep[l])
					pre = FF[pre];
				if (pre != u)
					nw |= bt[id[pre]][id[u]];
				while (pre != l)
					nw.set(a[pre]), pre = fa[pre];
			}
			if (v != l)
			{
				int pre = v;
				while (dep[FF[pre]] >= dep[l])
					pre = FF[pre];
				if (pre != v)
					nw |= bt[id[pre]][id[v]];
				while (pre != l)
					nw.set(a[pre]), pre = fa[pre];
			}
			nw.set(a[l]);
		}
		ans1 = nw.count(), ans2 = mex(nw);
		write(ans1), putchar(' '), write(ans2), putchar('\n');
		ans = ans1 + ans2;
	}
	return 0;
}
```

**法二**

考虑轻重链剖分，询问时将路径上的若干条重链的 `bitset` 并起来即可。

由于重链上的点的 `dfn` 序是连续的，序列分块即可。

每次询问，跳重链分块计算这条重链的贡献即可。

时间复杂度为 $\mathcal O(\frac{n^2}{w}+m\log n(\sqrt{n}+\frac{n}{w}))$。

最优解。

$\text{1.43s / 56.70MB / 3.61KB C++20 O2}$。

```cpp
#include <cstdio>
#include <bitset>

#define re register

namespace Fread
{
    const int SIZE = 1 << 23;
    char buf[SIZE], *S, *T;
    inline char getchar()
    {
        if (S == T)
        {
            T = (S = buf) + fread(buf, 1, SIZE, stdin);
            if (S == T)
                return '\n';
        }
        return *S++;
    }
}
namespace Fwrite
{
    const int SIZE = 1 << 23;
    char buf[SIZE], *S = buf, *T = buf + SIZE;
    inline void flush()
    {
        fwrite(buf, 1, S - buf, stdout);
        S = buf;
    }
    inline void putchar(char c)
    {
        *S++ = c;
        if (S == T)
            flush();
    }
    struct NTR
    {
        ~NTR()
        {
            flush();
        }
    } ztr;
}

#ifdef ONLINE_JUDGE
#define getchar Fread::getchar
#define putchar Fwrite::putchar
#endif

inline int read()
{
	int x = 0, f = 1;
	char c = getchar();
	while (c < '0' || c > '9')
	{
		if (c == '-')
			f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9')
	{
		x = x * 10 + c - '0';
		c = getchar();
	}
	return x * f;
}

inline void write(int x)
{
	if (x < 0)
	{
		putchar('-');
		x = -x;
	}
	if (x > 9)
		write(x / 10);
	putchar(x % 10 + '0');
}

const int _ = 1e5 + 7, W = 3e4 + 7, B = 1e3;

std::bitset<W> f[102][102], nw;

int n, m, kkk, cnt_node, ans1, ans2, ans, tot, a[_], fa[_], dep[_], siz[_], hson[_], top[_], dfn[_], b[_], bel[_], L[_], R[_], head[_], to[_ << 1], nxt[_ << 1];

inline void swap(int &x, int &y)
{
	x ^= y ^= x ^= y;
}

inline int mex(std::bitset<W> &s)
{
	for (re int i = 0; i < W; ++i)
		if (!s.test(i)) return i;
	return 1e9;
}

inline void add(int u, int v)
{
	to[++tot] = v;
	nxt[tot] = head[u];
	head[u] = tot;
}

void dfs1(int u, int D)
{
	dep[u] = D, siz[u] = 1;
	for(re int i = head[u]; i; i = nxt[i])
	{
		re int v = to[i];
		if(siz[v]) continue;
		fa[v] = u;
		dfs1(v, D + 1);
		siz[u] += siz[v];
		if(siz[hson[u]] < siz[v]) hson[u] = v;
	}
}

void dfs2(int u, int tf)
{
	top[u] = tf, dfn[u] = ++cnt_node, a[cnt_node] = b[u];
	if(!hson[u]) return;
	dfs2(hson[u], tf);
	for(re int i = head[u]; i; i = nxt[i])
	{
		re int v = to[i];
		if(top[v]) continue;
		dfs2(v, v);
	}
}

inline void pre()
{
	for (re int i = 1; i <= n; ++i)
	{
		bel[i] = (i - 1) / B + 1;
		f[bel[i]][bel[i]].set(a[i]);
	}
	for (re int i = 1; i <= bel[n]; ++i)
		L[i] = R[i - 1] + 1, R[i] = i * B;
	R[bel[n]] = n;
	for (re int i = 1; i < bel[n]; ++i)
		for (re int j = i + 1; j <= bel[n]; ++j)
			f[i][j] = f[i][j - 1] | f[j][j];
}

inline void Query_on_block(int l, int r)
{
	if (bel[l] == bel[r])
	{
		for (re int i = l; i <= r; ++i) nw.set(a[i]);
		return;
	}
	nw |= f[bel[l] + 1][bel[r] - 1];
	for (re int i = l; i <= R[bel[l]]; ++i) nw.set(a[i]);
	for (re int i = L[bel[r]]; i <= r; ++i) nw.set(a[i]);
}

inline void Query_on_tree(int u, int v)
{
	while(top[u] != top[v])
	{
		if(dep[top[u]] < dep[top[v]]) swap(u, v);
		Query_on_block(dfn[top[u]], dfn[u]);
		u = fa[top[u]];
	}
	if(dep[u] > dep[v]) swap(u, v);
	Query_on_block(dfn[u], dfn[v]);
}

signed main()
{
	n = read(), m = read(), kkk = read();
	for(re int i = 1; i <= n; ++i) b[i] = read();
	for(re int i = 1, u, v; i < n; ++i)
	{
		u = read(), v = read();
		add(u, v), add(v, u);
	}
	dfs1(1, 1), dfs2(1, 1);
	pre();
	while(m--)
	{
		nw.reset();
		re int tmp = read();
		while(tmp--)
		{
			re int u = read() ^ (kkk * ans), v = read() ^ (kkk * ans);
			Query_on_tree(u, v);
		}
		ans1 = nw.count(), ans2 = mex(nw);
		write(ans1), putchar(' '), write(ans2), putchar('\n');
		ans = ans1 + ans2;
	}
}
```

---

## 作者：spfa_ (赞：5)

### 树分块

众所周知序列有序列分块，那么树上能否有树分块呢？

我们可以在树上选择若干个关键节点，然后可以预处理关键节点之间的信息，从而减低复杂度。

若我们选择一个阈值 $S$，我们希望每个点与其最近的祖先关键点之间的距离不超过 $S$，该怎么实现呢？
	
比较简单的做法是直接在树上随机选 $\dfrac{n}{S}$，每个点与其最近的祖先关键点之间的期望距离是不超过 $S$ 的。

还有一种方法，就是选择深度最大的非关键点，若该点 $1\sim S$ 级祖先都不为关键点，那么标记 $S$ 级祖先为关键点，这样就能保证每个点与其最近的祖先关键点之间的距离是不超过 $S$ 了。

选完关键点后，预处理每对存在祖先关系的关键点之间的信息，以及每个关键点的最近关键点祖先。对于询问 $(x,y)$，将 $x$ 跳到第一个关键点，然后进行关键点之间的跳跃，跳到离 $lca(x,y)$ 最近的关键点，最后慢慢跳上去，对于 $y$ 同理。

以上就是树分块的核心操作了，下面回到本题。

### P3603 雪辉

[题目传送门](https://www.luogu.com.cn/problem/P3603)

注意到点权不是很大，于是可以考虑使用 `bitset`。点权种类数即为 `ans.count()`，$\text{mex}$ 为 `(~ans)._Find_first()`。

记 $bt_{i,j}$ 为关键点 $i$ 与关键点 $j$ 之间的点权集合，若关键点 $k$ 为 $j$ 的后代，显然会有 $bt_{i,k}=bt_{i,j}\operatorname{or}bt_{j,k}$。由于这样的点对最多不超过 $\dfrac{n^2}{S^2}$，预处理总复杂度为 $O(\dfrac{n^2}{S}+\dfrac{n^2V}{S^2w})$，其中 $\dfrac{1}{w}$ 为 `bitset` 的常数因子，$V$ 为值域。

简单的实现方式：

```cpp
void dfs(int u) {
	for (int v:E[u]) if (v != fa[u]) {
		if (id[v]) {
			for (int x = v; x != stk[top]; x = fa[x]) bt[id[stk[top]]][id[v]].set(a[x]);
			for (int i = 1; i < top; ++i) bt[id[stk[i]]][id[v]] = bt[id[stk[i]]][id[stk[top]]]|bt[id[stk[top]]][id[v]];
			up[v] = stk[top], stk[++top] = v;
		}
		dfs(v);
		if (id[v]) --top;
	}
}
```

查询的复杂度为 $O(\dfrac{Vm}{w}+mS)$，总复杂度为 $O(\dfrac{n^2}{S}+\dfrac{n^2V}{S^2w}+\dfrac{Vm}{w}+mS)$，取 $S=\sqrt n$，则总复杂度为 $O((n+m)\sqrt n+\dfrac{V}{w}(n+m))$。

代码：

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
#define pb push_back
#define mk make_pair
#define ll long long
#define space putchar(' ')
#define enter putchar('\n')
using namespace std;

typedef vector <int> vi;
typedef pair <int, int> pii;

inline int rd() { int x = 0, f = 1; char c = getchar(); while (!isdigit(c)) f = c == '-' ? -1 : f, c = getchar(); while (isdigit(c)) x = (x<<3)+(x<<1)+(c^48), c = getchar(); return x*f; }
inline ll rdll() { ll x = 0, f = 1; char c = getchar(); while (!isdigit(c)) f = c == '-' ? -1 : f, c = getchar(); while (isdigit(c)) x = (x<<3)+(x<<1)+(c^48), c = getchar(); return x*f; }
template <typename T> inline void write(T x) { if (x < 0) x = -x, putchar('-'); if (x > 9) write(x/10); putchar(x%10+48); }

const int N = 1e5+5, V = 3e4+5, B = 1000;
int n, m, q, lst, idx, top, a[N], d[N], fa[N], sz[N], tp[N], id[N], up[N], son[N], mxd[N], stk[N];
vi E[N]; bitset <V> ans, res, bt[105][105];

void dfs1(int u, int f) {
	d[u] = mxd[u] = d[f]+1, fa[u] = f, sz[u] = 1;
	for (int v:E[u]) if (v != f) {
		dfs1(v, u);
		sz[u] += sz[v];
		if (sz[v] > sz[son[u]]) son[u] = v;
		mxd[u] = max(mxd[u], mxd[v]);
	}
	if (mxd[u]-d[u] >= B) id[u] = ++idx, mxd[u] = d[u];
}

void dfs2(int u, int p) {
	tp[u] = p; if (son[u]) dfs2(son[u], p);
	for (int v:E[u]) if (v != fa[u] && v != son[u]) dfs2(v, v);
}

void dfs(int u) {
	for (int v:E[u]) if (v != fa[u]) {
		if (id[v]) {
			for (int x = v; x != stk[top]; x = fa[x]) bt[id[stk[top]]][id[v]].set(a[x]);
			for (int i = 1; i < top; ++i) bt[id[stk[i]]][id[v]] = bt[id[stk[i]]][id[stk[top]]]|bt[id[stk[top]]][id[v]];
			up[v] = stk[top], stk[++top] = v;
		}
		dfs(v);
		if (id[v]) --top;
	}
}

int lca(int u, int v) {
	while (tp[u] != tp[v]) {
		if (d[tp[u]] < d[tp[v]]) swap(u, v);
		u = fa[tp[u]];
	}
	return d[u] < d[v] ? u : v;
}

void solve(int u, int v) {
	res.reset(); int l = lca(u, v);
	while (u != l && !id[u]) res.set(a[u]), u = fa[u];
	while (v != l && !id[v]) res.set(a[v]), v = fa[v];
	if (u != l) {
		int pre = u;
		while (d[up[u]] >= d[l]) u = up[u];
		if (u != pre) res |= bt[id[u]][id[pre]];
		while (u != l) res.set(a[u]), u = fa[u];
	}
	if (v != l) {
		int pre = v;
		while (d[up[v]] >= d[l]) v = up[v];
		if (v != pre) res |= bt[id[v]][id[pre]];
		while (v != l) res.set(a[v]), v = fa[v];
	}
	res.set(a[l]);
}

int main() {
	n = rd(), m = rd(), q = rd();
	for (int i = 1; i <= n; ++i) a[i] = rd();
	for (int i = 1; i < n; ++i) {
		int x = rd(), y = rd();
		E[x].pb(y), E[y].pb(x);
	}
	dfs1(1, 0), dfs2(1, 1);
	if (!id[1]) id[1] = ++idx;
	stk[top = 1] = 1; dfs(1);
	while (m--) {
		int c = rd(); ans.reset();
		while (c--) {
			int x = rd()^lst, y = rd()^lst;
			solve(x, y);
			ans |= res;
		}
		int x = ans.count(), y = (~ans)._Find_first(); lst = (x+y)*q;
		write(x), space, write(y), enter;
	}
	return 0;
}
```

---

## 作者：ddd (赞：4)

随机钦定 $\sqrt n$个关键点，预处理出每个关键点和其也为关键点的祖先之间的bitset。查询的时候，两边都向 LCA 爬，直到遇到一个关键点，开始向 LCA 跳，找到距离 LCA 最近的关键点，这段的 bitset 已经被预处理，接下来距离 LCA 最近的关键点到 LCA 处的bitset，暴力处理即可。预处理复杂度 $O(\frac{30000}{64}n)$，单次查询复杂度 $O(\frac{30000}{64}\sqrt n)$

```cpp
#include <map>
#include <cmath>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <algorithm>
using namespace std;
typedef unsigned long long ull;
const int MAXN = 100005;
const int Q = 322;
int n, m, f, cnt, a[MAXN];
int tag[MAXN], spe[MAXN], up[MAXN], vis[MAXN];
int deep[MAXN], fa[MAXN], size[MAXN];
int son[MAXN], top[MAXN], dfn[MAXN];
struct bitset {
  ull bit[469]; int maxx;
  void clear() {
    for(int i = 0; i <= maxx; i++) bit[i] = 0LL;
    maxx = 0;
  }
  void operator |= (const bitset & rhs) {
    maxx = max(maxx, rhs.maxx);
    for(int i = 0; i <= maxx; i++)
      bit[i] |= rhs.bit[i];
  }
  void operator |= (const int x) {
    bit[x >> 6] |= 1LL << (x & 63);
    maxx = max(maxx, x >> 6);
  }
  int num() {
    int ans = 0;
    for(int i = 0; i <= maxx; i++)
      for(int j = 0; j < 64; j++)
        if(bit[i] & (1LL << j))
          ans++;
    return ans;
  }
  int mex() {
    for(int i = 0; i <= maxx; i++)
      for(int j = 0; j < 64; j++)
        if(!(bit[i] & (1LL << j)))
          return i * 64 + j;
  }
}ans, null;
bitset BIT[Q + 5][Q + 5];
vector<int>G[MAXN];
void dfs1(int cur, int father, int dep) {
  fa[cur] = father;
  deep[cur] = dep;
  size[cur] = 1;
  son[cur] = 0;
  for(int i = 0; i < G[cur].size(); i++) {
    int nx = G[cur][i];
    if(nx == fa[cur]) continue;
    dfs1(nx, cur, dep + 1);
    size[cur] += size[nx];
    if(size[son[cur]] < size[nx])
      son[cur] = nx;
  }
}
void dfs2(int cur, int tp) {
  top[cur] = tp;
  dfn[cur] = ++cnt;
  if(!son[cur]) return;
  dfs2(son[cur], tp);
  for(int i = 0; i < G[cur].size(); i++) {
    int nx = G[cur][i];
    if(nx == fa[cur] || nx == son[cur])
      continue;
    dfs2(nx, nx);
  }
}
int lca(int x, int y) {
  int t1 = top[x], t2 = top[y];
  while(t1 != t2) {
    if(deep[t1] < deep[t2]) {
      swap(t1, t2);
      swap(x, y);
    }
    x = fa[t1]; t1 = top[x];
  }
  return deep[x] < deep[y] ? x : y;
}
int main() {
  scanf("%d %d %d", &n, &m, &f);
  for(int i = 1; i <= n; i++)
    scanf("%d", &a[i]);
  for(int i = 1, x, y; i < n; i++) {
    scanf("%d %d", &x, &y);
    G[x].push_back(y);
    G[y].push_back(x);
  }
  dfs1(1, 0, 1);
  dfs2(1, 1);
  for(int i = 1; i <= Q; i++) {
    int h = rand() % n + 1;
    while(vis[h]) h = rand() % n + 1;
    vis[h] = 1;
    tag[i] = h;
    spe[tag[i]] = i;
  }
  for(int i = 1; i <= Q; i++) {
    int cur = tag[i];
    ans.clear();
    do {
      ans |= a[cur];
      if(cur != tag[i] && spe[cur]) {
        BIT[i][spe[cur]] |= ans;
        if(!up[tag[i]]) 
          up[tag[i]] = cur;
      }
      cur = fa[cur];
    } while(cur != 0);
  }
  int lastans = 0;
  for(int i = 1, cnt; i <= m; i++) {
    scanf("%d", &cnt);
    ans.clear();
    for(int j = 1, x, y; j <= cnt; j++) {
      scanf("%d %d", &x, &y);
      if(f) x ^= lastans, y ^= lastans;
      int z = lca(x, y); ans |= a[z];
      while(!spe[x] && x != z) ans |= a[x], x = fa[x];
      int now = x;
      while(deep[up[x]] > deep[z]) x = up[x];
      ans |= BIT[spe[now]][spe[x]];
      while(x != z) ans |= a[x], x = fa[x];
      while(!spe[y] && y != z) ans |= a[y], y = fa[y];
      now = y;
      while(deep[up[y]] > deep[z]) y = up[y];
      ans |= BIT[spe[now]][spe[y]];
      while(y != z) ans |= a[y], y = fa[y];
    }
    int num = ans.num(), mex = ans.mex();
    lastans = num + mex;
    printf("%d %d\n", num, mex);
  }
  return 0;
}
```

---

## 作者：ilibilib (赞：1)

## 分析

树上在线询问，莫队不了一点，

可以通过维护一个 bitset 求个数和 mex。



因为 点权 $\le30000$，不需要离散化。

处理路径上每个点，将 bitset 的点权位设为 $1$。

最后 `count()` 就能得出有多少种不同的点权。

mex 就是要寻找第一个没出现的数，即 bitset 中第一个 $0$。

那我们可以将维护的 bitset 取反，然后 `_Find_first()` 即可。



至于优化时间，我们可以在树上找几个点设为关键点，

然后预处理这个关键点向上到另一个关键点的 bitset，

这样查询的时候就可以更快地跳了。



## code

```cpp
#include<bits/stdc++.h>
#define sc scanf
#define pt printf
#define gc getchar
#define pc putchar
#define N 100010
using namespace std;
template<typename T>
inline void read(T &x)
{
	x=0;char c=gc();
	while(c<'0'||c>'9') c=gc();
	while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+c-48,c=gc();
}
template<typename T>
inline void write(T x)
{
	if(x>9) write(x/10);
	pc(x%10^48);
}
struct qxx{int nx,to;}tu[N<<1];int hd[N];
int sz[N],son[N],dp[N],tp[N],fa[N],a[N],b[N];
int lim=2000,fk=1;//设置一个限制，深度差超过限制则新增关键点
int pos[N],bg[N],nx[N],bs=0,p[N];
bitset<30010>cnt[20010];
bitset<30010>nw;
bool bl[N];
void dfs1(int u)
{
	if(!bg[fk]) pos[u]=fk,bg[fk]=u,bl[u]=true;//求关键点
	dp[u]=dp[fa[u]]+1;sz[u]=1;
	if(dp[u]-dp[bg[fk]]>=lim) pos[fk]=u,++fk;
	for(int i=hd[u];i;i=tu[i].nx)
	{
		int v=tu[i].to;
		if(v^fa[u])
		{
			fa[v]=u;dfs1(v);
			sz[u]+=sz[v];
			son[u]=sz[v]>sz[son[u]]?v:son[u];
		}
	}
	if(bg[fk]==u) pos[u]=fk,++fk;
}
void dfs2(int u,int top)
{
	tp[u]=top;
	if(son[u]) dfs2(son[u],top);
	for(int i=hd[u];i;i=tu[i].nx)
	{
		int v=tu[i].to;
		if(v^fa[u]&&v^son[u]) dfs2(v,v);
	}
}
int lca(int x,int y)
{
	while(tp[x]^tp[y]) dp[tp[x]]>dp[tp[y]]?x=fa[tp[x]]:y=fa[tp[y]];
	return dp[x]<dp[y]?x:y;
}
int main()
{
	int n,x,y,z,q,ans,m,last=0,bs=0;
	bool f;
	char op;
	read(n);read(q);read(f);
	for(int i=1;i<=n;++i) read(a[i]);
	for(int i=1;i<n;++i)
	{
		read(x),read(y);
		tu[i]={hd[x],y};hd[x]=i;
		tu[n+i]={hd[y],x};hd[y]=n+i;
	}
	dfs1(n/2);
	dfs2(n/2,n/2);
	for(int i=2;i<fk;++i)
	{
		int v=bg[i];
		do
		{
			cnt[i].set(a[v]);
			v=fa[v];
		}
		while(!bl[v]);
		nx[i]=pos[v];
	}//预处理关键点向上到另一个关键点的bitset
	for(int i=1;i<=q;++i)
	{
		nw.reset();
		read(z);
		while(z--)
		{
			read(x),read(y);
			if(f) x^=last,y^=last;
			m=lca(x,y);
			while(x^m)
			{
				if(bl[x]&&dp[bg[nx[pos[x]]]]>=dp[m]) nw|=cnt[pos[x]],x=bg[nx[pos[x]]];//加速跳
				else
				{
					nw.set(a[x]);	
					x=fa[x];
				}
			}
			while(y^m)
			{
				if(bl[y]&&dp[bg[nx[pos[y]]]]>=dp[m]) nw|=cnt[pos[y]],y=bg[nx[pos[y]]];
				else
				{
					nw.set(a[y]);
					y=fa[y];
				}
			}
			nw.set(a[m]);
		}
		x=nw.count(),y=(~nw)._Find_first();
		last=x+y;
		write(x);pc(' ');write(y);pc('\n');
	}
}
```



---

## 作者：yzy1 (赞：1)

## 题目大意

给出一棵树，链上数颜色、链上求 $\rm mex$。$n,m\le 10^5$，$V\le 3\times 10^4$，强制在线。

## 做法简述

考虑重链剖分。用分块维护区间、用 bitset 维护值域。则对于第一问，答案为 bitset 中 $1$ 的数量，对于第二问，答案为 bitset 每位取反后中 lowbit 对应的二进制位编号。

查询时，把 $O(k\log n)$ 条路径上的 bitset 直接按位 or 起来。可以发现，这样每次询问都会对 $O(k\sqrt n \log n)$ 个整块取 or，复杂度过高。考虑用 ST 表预处理出相邻整块按位或出来的 bitset，查询时复杂度下降到 $O(\dfrac{kV\log n}w)$。

但看这个复杂度似乎过不去，但实际上该做法常数很小且跑不满，跑得飞快。

## 代码参考

```cpp
const int N = 1e5 + 9;
const int B = 326;
typedef bitset<30009> BS;

struct G {
  int tot, h[N];
  struct E {
    int t, n;
  } e[N << 2];
  inline void Add(int f, int t) { e[++tot] = {t, h[f]}, h[f] = tot; }
} g;

int n, m, typ, a_[N], dfn[N], tim, sz[N], son[N], tp[N], dep[N], fa[N], a[N], last;

struct Bl {
  int sz, lg[N], bl[N], lbl[N], rbl[N];
  BS st[9][B], ans;

  inline void Init() {
    sz = sqrt(n);
    re (i, n)
      bl[i] = (i - 1) / sz + 1, lbl[i] = (bl[i] - 1) * sz + 1, rbl[i] = min(bl[i] * sz, n);
    re (i, n)
      st[0][bl[i]].set(a[i]);
    rep (i, 2, n)
      lg[i] = lg[i >> 1] + 1;
    re (j, lg[bl[n]]) {
      auto *x = st[j], *y = st[j - 1];
      re (i, bl[n] - (1 << j) + 1)
        x[i] = y[i] | y[i + (1 << (j - 1))];
    }
  }

  inline void StAsk(int x, int y) {
    int p = lg[y - x + 1];
    ans |= st[p][x] | st[p][y - (1 << p) + 1];
  }

  inline void Ask(int l, int r) {
    if (bl[l] == bl[r]) {
      rep (i, l, r)
        ans.set(a[i]);
      return;
    }
    Ask(l, rbl[l]);
    if (bl[l] + 1 <= bl[r] - 1) StAsk(bl[l] + 1, bl[r] - 1);
    Ask(lbl[r], r);
  }
} bl;

void Dfs1(int f) {
  dep[f] = dep[fa[f]] + 1, sz[f] = 1;
  nxt (i, f, g) {
    int t = g.e[i].t;
    if (t == fa[f]) continue;
    fa[t] = f, Dfs1(t), sz[f] += sz[t];
    if (sz[t] > sz[son[f]]) son[f] = t;
  }
}

void Dfs2(int f) {
  dfn[f] = ++tim;
  if (!son[f]) return;
  tp[son[f]] = tp[f], Dfs2(son[f]);
  nxt (i, f, g) {
    int t = g.e[i].t;
    if (t == fa[f] || t == son[f]) continue;
    tp[t] = t, Dfs2(t);
  }
}

void Ask(int f, int t) {
  while (tp[f] != tp[t]) {
    if (dep[tp[f]] > dep[tp[t]]) swap(f, t);
    bl.Ask(dfn[tp[t]], dfn[t]), t = fa[tp[t]];
  }
  if (dfn[f] > dfn[t]) swap(f, t);
  bl.Ask(dfn[f], dfn[t]);
}

signed main() {
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  cin >> n >> m >> typ;
  re (i, n)
    cin >> a_[i];
  re (i, n - 1) {
    int f, t;
    cin >> f >> t, g.Add(f, t), g.Add(t, f);
  }
  Dfs1(1), tp[1] = 1, Dfs2(1);
  re (i, n)
    a[dfn[i]] = a_[i];
  bl.Init();
  re (i, m) {
    int K, f, t;
    bl.ans.reset(), cin >> K;
    while (K--) {
      cin >> f >> t;
      if (typ) f ^= last, t ^= last;
      Ask(f, t);
    }
    int ans1 = bl.ans.count(), ans2 = (~bl.ans)._Find_first();
    cout << ans1 << ' ' << ans2 << '\n', last = ans1 + ans2;
  }
  return 0;
}
```



---

## 作者：Tsawke (赞：0)

# [LG-P3603 雪辉](https://www.luogu.com.cn/problem/P3603) Solution

[TOC]

## [更好的阅读体验戳此进入](http://blog.tsawke.com?t=LG-P3603-Solution)

### 题面

给定 $ n $ 个点的树，存在点权，多次询问每次给定多对点分别表示一条树链，求所有树链中有多少不同点权，及其点权的 $ \operatorname{mex} $。强制在线。

### Solution

首先看到计算不同点权和求 $ \operatorname{mex} $ 且值域不大，自然想到 `bitset`，当我们求得答案的 `bitset`，我们只需要调用 `count()` 即可获得点权种类数，将其取反后，调用 `_Find_first()` 即可获得 $ \operatorname{mex} $。且上述所有操作均会除去一个 `bitset` 特有的，$ w $ 的复杂度。

> 这里的 $ w $ 根据编译器版本一般为 $ 32 $ 或 $ 64 $，且这里记作 $ w $ 而不是 $ \omega $ 是因为个人认为理解为 word 较为合理。

考虑如何维护，首先提供一个十分显然的思路，对原树进行树剖，然后在线段树上每个节点均开一个 `bitset` 建树，令 $ v $ 表示点权，这样的复杂度显然是 $ O(\dfrac{nv}{w}) $ 的，而对于每次询问，直接查询并强行合并，分析这样的复杂度：树剖有一只 $ O(\log n) $，线段树上查询的节点数是 $ O(\log n) $，每次合并需要 $ O(\dfrac{v}{w}) $，若共 $ q $ 次询问则最终复杂度 $ O(\dfrac{qv\log^2 n}{w}) $，显然无法通过，但是本题似乎限制较小，这样也可以通过。

考虑分析上述做法的空间复杂度，显然为 $ O(\dfrac{nv}{w}) $，但是线段树一般有一个 $ 4 $ 的空间常数，简单计算发现精细实现后大致需要 $ 262413 $，这样大致需要 `1GiB`，考虑优化，显然对于线段树的底层每个点仅维护了一个数，而倒数第二层每个点仅维护了两个数，于是不难想到我们将倒数这两层改为用 `pair` 维护即可，这样可以去掉 $ 131072 + 65536 $ 左右个 `bitset` 的空间复杂度，优化极大，空间冗余较多，实现平凡。

下面提供一个来自 @Zpair 的**高妙思路**，可以将复杂度去掉一只 $ O(\log n) $，显然这样的**复杂度就是理论正确**的了。即考虑在树剖后每个重链上维护这整个重链的 `bitset`，同时类似上文维护线段树，对于每次询问中，所有整个重链的查询直接调用，容易证明残缺的重链查询最多有 $ 3 $ 次，可以认为是常数，故优化掉一只 $ O(\log n) $，容易证明这样的复杂度在当前时空限制是可以通过的。同时若空间无法通过还可考虑对于所有点数小于 $ \dfrac{v}{w} $ 的直接用 `basic_string` 维护，这样可以更进一步地大幅优化空间。

当然这里因为前者虽然复杂度错误但常数不大可以通过，于是这里直接挂前者的代码了。

### Code

```cpp
#define _USE_MATH_DEFINES
#include <bits/stdc++.h>
#include <bitset>

#define PI M_PI
#define E M_E
#define npt nullptr
#define SON i->to
#define OPNEW void* operator new(size_t)
#define ROPNEW void* Edge::operator new(size_t){static Edge* P = ed; return P++;}
#define ROPNEW_NODE void* Node::operator new(size_t){static Node* P = nd; return P++;}

using namespace std;

mt19937 rnd(random_device{}());
int rndd(int l, int r){return rnd() % (r - l + 1) + l;}
bool rnddd(int x){return rndd(1, 100) <= x;}

typedef unsigned int uint;
typedef unsigned long long unll;
typedef long long ll;
typedef long double ld;

#define LIM (110000)

template < typename T = int >
inline T read(void);

int N, Q, F;
struct Edge{
    Edge* nxt;
    int to;
    OPNEW;
}ed[LIM << 1];
ROPNEW;
Edge* head[LIM];
int val[LIM];
int lst(0);

int dep[LIM], hson[LIM], top[LIM], fa[LIM], siz[LIM], dfn[LIM], idx[LIM];

void dfs_pre(int p = 1, int fa = 0){
    ::fa[p] = fa, dep[p] = dep[fa] + 1, siz[p] = 1;
    for(auto i = head[p]; i; i = i->nxt){
        if(SON == fa)continue;
        dfs_pre(SON, p);
        siz[p] += siz[SON];
        if(siz[SON] > siz[hson[p]])hson[p] = SON;
    }
}
void dfs_make(int p = 1, int top = 1){
    static int cdfn(0);
    dfn[p] = ++cdfn, idx[cdfn] = p;
    ::top[p] = top;
    if(hson[p])dfs_make(hson[p], top);
    for(auto i = head[p]; i; i = i->nxt){
        if(SON == fa[p] || SON == hson[p])continue;
        dfs_make(SON, SON);
    }
}

class SegTree{
private:
    //sum is 262143
    bitset < 30010 > tr[120000];
    pair < int, int > base[LIM << 2];
    #define LS (p << 1)
    #define RS (LS | 1)
    #define MID ((gl + gr) >> 1)
public:
    void Pushup(int p, int gl, int gr){
        if(gr - gl + 1 <= 2)return;
        if(MID - gl + 1 == 1)tr[p][base[LS].first] = true;
        else if(MID - gl + 1 == 2)tr[p][base[LS].first] = tr[p][base[LS].second] = true;
        else tr[p] |= tr[LS];
        if(gr - (MID + 1) + 1 == 1)tr[p][base[RS].first] = true;
        else if(gr - (MID + 1) + 1 == 2)tr[p][base[RS].first] = tr[p][base[RS].second] = true;
        else tr[p] |= tr[RS];
    }
    void Build(int p = 1, int gl = 1, int gr = N){
        if(gl == gr)return base[p] = {val[idx[gl = gr]], -1}, void();
        if(gr - gl + 1 == 2)base[p] = {val[idx[gl]], val[idx[gr]]};
        Build(LS, gl, MID), Build(RS, MID + 1, gr);
        Pushup(p, gl, gr);
    }
    auto Query(int l, int r, int p = 1, int gl = 1, int gr = N){
        bitset < 30010 > ret; ret.reset();
        if(l <= gl && gr <= r){
            if(gl == gr){ret[base[p].first] = true; return ret;}
            if(gr - gl + 1 == 2){ret[base[p].first] = ret[base[p].second] = true; return ret;}
            return tr[p];
        }
        if(l <= MID)ret |= Query(l, r, LS, gl, MID);
        if(r >= MID + 1)ret |= Query(l, r, RS, MID + 1, gr);
        return ret;
    }
}st;

auto Query(int s, int t){
    bitset < 30010 > ret; ret.reset();
    while(top[s] != top[t]){
        if(dep[top[s]] < dep[top[t]])swap(s, t);
        ret |= st.Query(dfn[top[s]], dfn[s]);
        s = fa[top[s]];
    }if(dep[s] < dep[t])swap(s, t);
    ret |= st.Query(dfn[t], dfn[s]);
    return ret;
}

int main(){
    N = read(), Q = read(), F = read();
    for(int i = 1; i <= N; ++i)val[i] = read();
    for(int i = 1; i <= N - 1; ++i){
        int s = read(), t = read();
        head[s] = new Edge{head[s], t};
        head[t] = new Edge{head[t], s};
    }dfs_pre(), dfs_make();
    st.Build();
    while(Q--){
        int M = read();
        bitset < 30010 > ans; ans.reset();
        for(int i = 1; i <= M; ++i){
            int s = read() ^ (lst * F), t = read() ^ (lst * F);
            ans |= Query(s, t);
        }
        int ans1 = ans.count(), ans2 = (~ans)._Find_first();
        lst = ans1 + ans2;
        printf("%d %d\n", ans1, ans2);
    }
    fprintf(stderr, "Time: %.6lf\n", (double)clock() / CLOCKS_PER_SEC);
    return 0;
}

template < typename T >
inline T read(void){
    T ret(0);
    int flag(1);
    char c = getchar();
    while(c != '-' && !isdigit(c))c = getchar();
    if(c == '-')flag = -1, c = getchar();
    while(isdigit(c)){
        ret *= 10;
        ret += int(c - '0');
        c = getchar();
    }
    ret *= flag;
    return ret;
}
```

## UPD

update-2023_02_17 初稿

---

## 作者：2018LZY (赞：0)

**树分块**

直接在树上撒上一些均匀的关键点,设关键点之间的距离为$S$,预处理出互为祖孙关系的关键点之间的数的信息.$(T=maxa_i/32,bitset:O((n/S)^2T)$)

然后每个询问边角暴力,大段直接利用预处理的$bitset$即可.
询问复杂度:$O(q(S+n/S+T))$.

在合法的空间限制内预处理尽量多就能快了.

神奇的是:手打bitset竟然更慢....


```cpp
#include<cmath>
#include<cstdio>
#include<cctype>
#include<cstring>
#include<iostream>
#include<algorithm>
#define gc getchar()//(p1==p2&&(p2=(p1=buf)+fread(buf,1,size,stdin),p1==p2)?EOF:*p1++)
#define ui unsigned
using namespace std;
const int N=1e5+10,M=3e4+10,T=M/32+5,S=(1<<16)-1;
const ui inf=-1;

template<class o> void qr(o &x) {
	x=0; int f=1; char c=gc;
	while(!isdigit(c)){if(c=='-')f=-1; c=gc;}
	while(isdigit(c))x=x*10+c-'0',c=gc;
	x*=f;
}
template<class o> void qw(o x) {
	if(x<0) putchar('-'),x=-x;
	if(x>9) qw(x/10);
	putchar(x%10+'0');
}
template<class o> void pr1(o x) {qw(x); putchar(' ');}
template<class o> void pr2(o x) {qw(x); puts("");}

int n,m,root,t,flag,ans,val[N],fa[N],dep[N],son[N],sz[N],D[N],id[N],cnt;
struct edge{int y,next;}a[N<<1]; int len,last[N];
void ins(int x,int y) {a[++len]=(edge){y,last[x]};last[x]=len;}

void dfs(int x) {
	sz[x]=1; son[x]=0; D[x]=dep[x];
	for(int k=last[x],y;k;k=a[k].next)
		if(!dep[y=a[k].y]) {
			dep[y]=dep[x]+1; fa[y]=x; dfs(y);
			sz[x]+=sz[y]; if(sz[son[x]]<sz[y]) son[x]=y;
			D[x]=max(D[x],D[y]);
		}
	if(D[x]-dep[x]>=t) id[x]=++cnt,D[x]=dep[x];
}

int top[N];
void DFS(int x) {
	if(son[x]) top[son[x]]=top[x],DFS(son[x]);
	for(int k=last[x],y;k;k=a[k].next) {
		y=a[k].y;
		if(y^fa[x]&&y^son[x]) DFS(top[y]=y);
	}
}

int sta[N],f[N],tp,c[S+5],mx;
struct Bitset {
	ui a[T],s;
	#define R register 
	void reset() {memset(a,0,sizeof a);s=0;}
	void operator |=(Bitset b) {
		s=0;
		for(R int i=0;i<=mx;i++) s+=calc(a[i]|=b.a[i]);
	}
	inline int calc(ui x) {return c[x&S]+c[x>>16&S];}
	int count() {return s;}
	int mex() {
		R int ans=0;
		while(a[ans]==inf) ans++;
		for(int i=0;i<32;i++) 
			if(!(a[ans]>>i&1)) return ans<<5|i;
	}
	void set(int x) {
		int y=x>>5; x&=31;
		if(!(a[y]>>x&1)) a[y]|=1U<<x,s++;
	}
}bt[102][102],tmp;
void dfs3(int x) {
	for(int k=last[x],y;k;k=a[k].next)
		if(dep[x]<dep[y=a[k].y]) {
			if(id[y]) {
				int u=id[sta[tp]],v=id[y];
				for(int z=y;z^sta[tp];z=fa[z]) bt[u][v].set(val[z]);
				for(int i=1,z;i<tp;i++)
					z=id[sta[i]],(bt[z][v]=bt[z][u])|=bt[u][v];
				f[y]=sta[tp]; sta[++tp]=y;
			}
			dfs3(y); tp-=(id[y]>0);
		}
}

int lca(int x,int y) {
	while(top[x]^top[y]) {
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		x=fa[top[x]];
	}
	return dep[x]<dep[y]?x:y;
}

void solve(int x,int y) {
	int z=lca(x,y);
	while(x^z&&!id[x]) 
		tmp.set(val[x]),x=fa[x];
	while(y^z&&!id[y]) 
		tmp.set(val[y]),y=fa[y];
	if(x^z) {
		int p=x;
		while(dep[f[p]]>=dep[z]) p=f[p];
		if(p^x) tmp|=bt[id[p]][id[x]];
		while(p^z) tmp.set(val[p]),p=fa[p];
	}
	if(y^z) {
		int p=y;
		while(dep[f[p]]>=dep[z]) p=f[p];
		if(p^y) tmp|=bt[id[p]][id[y]];
		while(p^z) tmp.set(val[p]),p=fa[p];
	}
	tmp.set(val[z]);
}

int main() {
	for(int i=1;i<=S;i++) c[i]=c[i&(i-1)]+1;
	qr(n); qr(m); qr(flag); t=(n<=1e4?sqrt(n)+2:n/100); root=19260817%n+1;
	for(int i=1;i<=n;i++) qr(val[i]),mx=max(mx,val[i]);
	mx=mx>>5;
	for(int i=1,x,y;i<n;i++) qr(x),qr(y),ins(x,y),ins(y,x);
	dep[root]=1; dfs(root); if(!id[root]) id[root]=++cnt;
	DFS(top[root]=root); 
	dfs3(sta[tp=1]=root);
	while(m--) {
		int k,x,y; qr(k); tmp.reset();
		while(k--) {
			qr(x),qr(y);
			if(flag) x^=ans,y^=ans;
			solve(x,y);
		}
		x=tmp.count();
		y=tmp.mex();
		ans=x+y;
		pr1(x); pr2(y);
	}
	return 0;
}

```

---

## 作者：GaoZiyou (赞：0)

模拟赛中遇到了这个题，当时我这个沙雕因为把一个$y$打成了$x$而爆零。回来重新写这道题，莫名其妙的拿了rank1。。。  
我的解法与其他几位的题解有些不同~~我太蒻了~~。并没有选取所谓的关键点，而是用树链剖分将树上问题转化为序列的问题。  
# 序列问题的解决
- 现在的问题是，维护一个序列，要求查询若干个区间的并集的权值种类和$mex$，无修改操作。  
- 如果只有一个区间，那么这个问题就可以很愉快的用主席树解决了。
- 然而要查询的是区间并的权值种类和$mex$，而且这两个东西都不满足区间可加性，于是可以放弃线段树的思路了。  
- 可以想到用分块解决这个问题，设每一块大小为$B$
- 考虑到点权$\leq 30000$，又要合并若干个区间，于是可以想到用$bitset$维护区间权值信息。
- 设$f[][]$为一个$bitset$的二维数组，$f[l][r]$表示从第$l$块到第$r$块(包含$l,r$)之间的权值集合，这个数组可以在$O(n\frac{30000}{32})$的时间内预处理出来。每次查询的时候，整块的信息可以在$O(\frac{30000}{32})$的时间内解决。
- 剩余的部分直接暴力处理，时间复杂度为$O(B)$。这样单次查询可以做到$O(\frac{30000}{32}+B)$
- 至于区间并，直接开一个全局变量记录答案(我的代码中用的是$cur$)，依次处理每个区间。因为重叠的部分并不会对答案有影响。现在序列的问题已经解决了。

**序列处理部分的代码**
```cpp
int b[N]; // 记录区间上每一个位置属于哪个块
int L[N], R[N]; // 每个块的左右断点
bitset<W> cur; // 查询时用到的全局变量
bitset<W> f[110][110]; // 预处理的 f 数组

void preWork() {
  // 预处理
  for (int i = 1; i <= n; ++i) {
    // 先计算单个块的权值情况
    b[i] = (i-1) / B + 1;
    f[b[i]][b[i]].set(a[i]);
  }
  // 处理每个块的左右端点
  for (int i = 1; i <= b[n]; ++i)
    L[i] = R[i-1] + 1, R[i] = i * B;
  R[b[n]] = n; // 最后一个块的右端点要特判
  for (int i = 1; i < b[n]; ++i)
    for (int j = i+1; j <= b[n]; ++j) // 计算 f 数组
      f[i][j] = f[i][j-1] | f[j][j];
}

void queryOnBlock(int l, int r) {
  if (b[l] == b[r]) {
    // 特判左右端点在同一个块内的情况
    for (int i = l; i <= r; ++i) cur.set(a[i]);
    return;
  }
  cur |= f[b[l]+1][b[r]-1]; // 两块之间的部分直接查询
  for (int i = l; i <= R[b[l]]; ++i) cur.set(a[i]); // 左边的剩余部分
  for (int i = L[b[r]]; i <= r; ++i) cur.set(a[i]); // 右边的剩余部分
}

int mex(bitset<W> &s) {
  // 暴力求 mex
  for (int i = 0; i < W; ++i)
    if (!s.test(i)) return i;
  return 1e9;
}

```
# 将树上问题转化为序列问题
树链剖分的板子(我这个蒟蒻写挂的部分)。。。  
**直接贴代码了**
```cpp
int G[N], ed = 1, w[N]; // 树的存储
struct Edge {
  int to, nxt;
  Edge() { to = nxt = 0; }
  Edge(int to, int nxt) : to(to), nxt(nxt) {}
} e[N<<1];

inline void addEdge(int x, int y) {
  e[++ed] = Edge(y, G[x]), G[x] = ed;
  e[++ed] = Edge(x, G[y]), G[y] = ed;
}

// 树链剖分相关
int dfn[N]; // dfs 序
int fa[N]; // 父结点
int son[N]; // 重儿子
int top[N]; // 重链顶端
int size[N]; // 子数大小
int dep[N]; // 深度
int a[N]; // 转化的序列

void dfs1(int x, int p) {
  size[x] = 1, fa[x] = p;
  for (int i = G[x]; i != 0; i = e[i].nxt) {
    int y = e[i].to;
    if (y == p) continue;
    dep[y] = dep[x] + 1;
    dfs1(y, x);
    size[x] += size[y];
    if (size[son[x]] < size[y])
      son[x] = y;
  }
}

void dfs2(int x, int t) {
  static int cur = 0;
  dfn[x] = ++cur, a[cur] = w[x], top[x] = t;
  if (!son[x]) return;
  dfs2(son[x], t);
  for (int i = G[x]; i != 0; i = e[i].nxt) {
    int y = e[i].to;
    if (y == son[x] || y == fa[x]) continue;
    dfs2(y, y);
  }
}

void queryOnTree(int x, int y) {
  // 树上查询
  while (top[x] != top[y]) {
    if (dep[top[x]] < dep[top[y]]) swap(x, y);
    queryOnBlock(dfn[top[x]], dfn[x]);
    x = fa[top[x]];
  }
  if (dfn[x] > dfn[y]) swap(x, y);
  queryOnBlock(dfn[x], dfn[y]);
}
```
# 总代码
```cpp
// 2598ms 57.76MB 无O2
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <bitset>
#define LL long long
using namespace std;

inline int getint() {
  int x = 0, f = 1; char c = getchar();
  while (!isdigit(c)) { if (c == '-') f = 0; c = getchar(); }
  while (isdigit(c)) { x = (x*10) + (c-'0'); c = getchar(); }
  return f ? x : -x;
}

const int N = 1e5 + 10;
const int B = 1e3;
const int W = 30001;

int n, m, flag; // flag 判断是否需要异或
int ans1, ans2, lastans; // ans1 为权值种类，ans2 为权值 mex

int G[N], ed = 1, w[N]; // 树的存储
struct Edge {
  int to, nxt;
  Edge() { to = nxt = 0; }
  Edge(int to, int nxt) : to(to), nxt(nxt) {}
} e[N<<1];

inline void addEdge(int x, int y) {
  e[++ed] = Edge(y, G[x]), G[x] = ed;
  e[++ed] = Edge(x, G[y]), G[y] = ed;
}

// 树链剖分相关
int dfn[N]; // dfs 序
int fa[N]; // 父结点
int son[N]; // 重儿子
int top[N]; // 重链顶端
int size[N]; // 子数大小
int dep[N]; // 深度
int a[N]; // 转化的序列

void dfs1(int x, int p) {
  size[x] = 1, fa[x] = p;
  for (int i = G[x]; i != 0; i = e[i].nxt) {
    int y = e[i].to;
    if (y == p) continue;
    dep[y] = dep[x] + 1;
    dfs1(y, x);
    size[x] += size[y];
    if (size[son[x]] < size[y])
      son[x] = y;
  }
}

void dfs2(int x, int t) {
  static int cur = 0;
  dfn[x] = ++cur, a[cur] = w[x], top[x] = t;
  if (!son[x]) return;
  dfs2(son[x], t);
  for (int i = G[x]; i != 0; i = e[i].nxt) {
    int y = e[i].to;
    if (y == son[x] || y == fa[x]) continue;
    dfs2(y, y);
  }
}

int b[N]; // 记录区间上每一个位置属于哪个块
int L[N], R[N]; // 每个块的左右断点
bitset<W> cur; // 查询时用到的全局变量
bitset<W> f[110][110]; // 预处理的 f 数组

void preWork() {
  // 预处理
  for (int i = 1; i <= n; ++i) {
    // 先计算单个块的权值情况
    b[i] = (i-1) / B + 1;
    f[b[i]][b[i]].set(a[i]);
  }
  // 处理每个块的左右端点
  for (int i = 1; i <= b[n]; ++i)
    L[i] = R[i-1] + 1, R[i] = i * B;
  R[b[n]] = n; // 最后一个块的右端点要特判
  for (int i = 1; i < b[n]; ++i)
    for (int j = i+1; j <= b[n]; ++j) // 计算 f 数组
      f[i][j] = f[i][j-1] | f[j][j];
}

void queryOnBlock(int l, int r) {
  if (b[l] == b[r]) {
    // 特判左右端点在同一个块内的情况
    for (int i = l; i <= r; ++i) cur.set(a[i]);
    return;
  }
  cur |= f[b[l]+1][b[r]-1]; // 两块之间的部分直接查询
  for (int i = l; i <= R[b[l]]; ++i) cur.set(a[i]); // 左边的剩余部分
  for (int i = L[b[r]]; i <= r; ++i) cur.set(a[i]); // 右边的剩余部分
}

void queryOnTree(int x, int y) {
  // 树上查询
  while (top[x] != top[y]) {
    if (dep[top[x]] < dep[top[y]]) swap(x, y);
    queryOnBlock(dfn[top[x]], dfn[x]);
    x = fa[top[x]];
  }
  if (dfn[x] > dfn[y]) swap(x, y);
  queryOnBlock(dfn[x], dfn[y]);
}

int mex(bitset<W> &s) {
  // 暴力求 mex
  for (int i = 0; i < W; ++i)
    if (!s.test(i)) return i;
  return 1e9;
}

int main() {
  cin >> n >> m >> flag;
  for (int i = 1; i <= n; ++i) w[i] = getint();
  for (int i = 1; i < n; ++i) {
    int x = getint(), y = getint();
    addEdge(x, y);
  }
  dfs1(1, 0), dfs2(1, 1);
  preWork();
  for (int i = 1; i <= m; ++i) {
    cur.reset();
    int num = getint();
    for (int j = 1; j <= num; ++j) {
      int x = getint() ^ (flag*lastans);
      int y = getint() ^ (flag*lastans);
      queryOnTree(x, y);
    }
    ans1 = cur.count(), ans2 = mex(cur);
    lastans = ans1 + ans2;
    printf("%d %d\n", ans1, ans2);
  }
  return 0;
}
```


---

## 作者：kczno1 (赞：0)

用压64位的二进制表示状态，1表示有这个数。

假设数的范围为U

这样就可以

O(U/64)合并两个状态，也就是每位都or一下

O(1)单点修改，也就是单点or一下

O(2^16)+O(U/64\*4)得到num，也就是预处理2^16之内的数的1的个数，

对每一位我们把64位拆成4份得到其num

O(U/64+3)得到mex,也就是先找到未满的那一位，之后就是要找末位的0。

+1，就是找末位的1。x&-x即可。但还要log2?跟前面类似，预处理2^22之内的log2即可。

现在可以树上莫队了？

然而有50分强制在线。

有一个类似分块的方法，就是找根号个关键点使得任何一条自上向下的路径每根号长度都

有一个关键点。这只用dp一下最远非关键点儿子就可以得到。

之后预处理每个关键点到每个爸爸的路径的状态，

对每个询问，把他拆成x->fx0->fx->lca->fy->fy0->y这样的路径，

其中fx,fy都是关键点。这样就可以O(根号)时间解决了。

```cpp
#include<bits/stdc++.h>
using std::swap;
using std::memset;

void chmax(int &x,int y)
{
    if (x<y) x=y;
}
#define ull unsigned long long
#define L 468//压64位后的范围=[0,L] 
#define U 30000
#define N 100100
#define K 500//块的大小 
int ans;
#define S 65535
int Num[S+5];
#define kcz 2097152//2^21
int Log[kcz+2];
int init_Num()
{
    for (int x=1;x<=S;++x) Num[x]=Num[x-(x&-x)]+1;
    for (int x=0;x<=21;++x) Log[1<<x]=x;
}
int num1(const ull &x)
{
    return Num[x&S]+Num[(x>>16)&S]+Num[(x>>32)&S]+Num[(x>>48)&S];
}
struct bitset
{
    ull a[L+2];int q[L+2],top;
    void init()
    {
        memset(a,0,sizeof(a));top=0;
    }
    void operator |=(int x)
    {
        if (!a[x>>6]) q[++top]=x>>6;
        a[x>>6]|=1LL<<(x&63);
    }
    void operator |=(const bitset &x)
    {
        for (int i=1;i<=x.top;++i) 
        {
           if (!a[x.q[i]]) q[++top]=x.q[i];    
           a[x.q[i]]|=x.a[x.q[i]];
        }
    }
    void num()
    {
        ans=0;
        for (int i=1;i<=top;++i) ans+=num1(a[q[i]]);
    }
    void mex()
    {
        int i=0;
        for (;!(a[i]+1);++i); 
        ull j=(a[i]+1)&(-a[i]-1);
        if (j<=kcz) j=Log[j]; else
        if (!(j>>44)) j=Log[j>>22]+22; else
         j=Log[j>>44]+44;
        printf("%d %d\n",ans,(i<<6)+j);ans+=(i<<6)+j;
    }
}now;
int w[N];
int t[N];
struct edge
{
    int to,next;
}l[N<<1];int e;
#define add_e(x,y) l[++e]=(edge){y,t[x]};t[x]=e;
int f[N],deep[N];
int q[N],head,tail,x,y,i;
int fa[N];bool is[N];
bitset* a[N];

int fa_num[N];
void init_bit(int x)
{
    int y=fa[x];
    if (!y) return ;
    a[x]=new bitset [fa_num[x]=fa_num[y]+1];
    now.init();
    now|=w[x];
    for (y=f[x];!is[y];y=f[y]) now|=w[y];
    now|=w[y];
    a[x][0]=now;
    for (int num=1;fa[y];y=fa[y],++num) { now|=a[y][0]; a[x][num]=now;}
}

int dp()
{
    q[tail=1]=1;deep[1]=1;
    for (head=1;head<=tail;++head)
    {
        x=q[head];
        for (i=t[x];i;i=l[i].next)
        if ((y=l[i].to)!=f[x])
        {
            q[++tail]=y;
            f[y]=x;
            deep[y]=deep[x]+1;
        }
    }
    static int mx[N];
    for (head=tail;head;--head)
    {
        x=q[head];
        for (i=t[x];i;i=l[i].next)
        if ((y=l[i].to)!=f[x]) chmax(mx[x],mx[y]);
        if ((++mx[x])==K) { is[x]=1;mx[x]=0; }
    }
    for (head=1;head<=tail;++head)
    {
        x=q[head];
        int father;
        if (is[x]) {init_bit(x);father=x;}
        else 
        if (!(father=fa[x])) continue;
        for (i=t[x];i;i=l[i].next)
        if ((y=l[i].to)!=f[x]) fa[y]=father;
    }
}

void baoli(int x,int y)
{
    if (deep[x]<deep[y]) swap(x,y);
    for (;deep[x]>deep[y];x=f[x]) now|=w[x];
    for (;x!=y;x=f[x],y=f[y]) {now|=w[x];now|=w[y];}
    now|=w[x];
}

int main()
{
    freopen("1.in","r",stdin);freopen("1.out","w",stdout);
    int n,m,type,i,x,y;
    scanf("%d%d%d",&n,&m,&type);
    for (i=1;i<=n;++i) scanf("%d",w+i);
    for (i=1;i<n;++i)
    {
        scanf("%d%d",&x,&y);
        add_e(x,y) add_e(y,x) 
    }
    dp();

    init_Num();
    int num,fx0,fx,numx,fy0,fy,numy;
    while (m--)
    {
        scanf("%d",&num);
        now.init();
        while (num--) 
        { scanf("%d%d",&x,&y); 
          if (type) { x^=ans;y^=ans; }
          if (is[x]) {fx0=x;numx=-1;}
          else { fx0=fa[x];numx=-2; }
          if (is[y]) { fy0=y;numy=-1; }
          else { fy0=fa[y];numy=-2; }
          fx=x;fy=y;
          while (fa[fx]!=fa[fy]) 
          if (deep[fa[fx]]>deep[fa[fy]]) { ++numx;fx=fa[fx]; }
          else { ++numy;fy=fa[fy]; }
          if (deep[fx]<=deep[fx0]) 
          {baoli(x,fx0);
           if (numx>=0) now|=a[fx0][numx];
           }
          if (deep[fy]<=deep[fy0]) 
          {baoli(y,fy0);
           if (numy>=0) now|=a[fy0][numy];
          }
          baoli(fx,fy);
        }
        now.num();
        now.mex();
    }
}
```



---

## 作者：w (赞：0)

官方题解： https://www.luogu.org/discuss/show?postid=7867


---


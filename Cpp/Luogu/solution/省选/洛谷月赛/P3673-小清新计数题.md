# 小清新计数题

## 题目描述

小 A 正在电脑上玩一个叫做 Truth or Lie 的游戏。

游戏开始时电脑会给出 $n$ 句话，每句话形如“第 $x$ 句话为真”或“第 $x$ 句话为假”，其中 $x$ 是一个 $1$ 到 $n$ 的整数，你只要选择“Good”或者“Bad”，“Good”表示可以决定每句话的真假使每句话的内容都成立，“Bad”反之。

作为一个菜鸡，小 A 只会不停地点“Good”，靠脸过关。

在无数次失败后，非洲人小 A 发现游戏每关中，每句话包含的是“真”还是“假”是固定的，但是每句话中的 $x$ 是在 $1$ 到 $n$ 均匀随机的。

现在小 A 告诉了你某一关每句话的真假，用一个 $01$ 序列表示。第 $i$ 位为 $0$ 表示第 $i$ 句话包含“假”，否则表示包含“真”。现在他想要知道使得点击“Good”正确的方案数。

由于方案数可能比较大，你需要输出方案数对 $998244353$ 取模的结果。

（读不懂题的请移步样例解释）

## 说明/提示

### 样例解释

第一句话的内容为“某句话为假”，第二句话的内容为“某句话为真”。所有可能情况如下：

1. 第一句话的内容为“第一句话为假”，第二句话的内容为“第一句话为真”，结果应为 Bad。

2. 第一句话的内容为“第一句话为假”，第二句话的内容为“第二句话为真”，结果应为 Bad。

3. 第一句话的内容为“第二句话为假”，第二句话的内容为“第一句话为真”，结果应为 Bad。

4. 第一句话的内容为“第二句话为假”，第二句话的内容为“第二句话为真”，结果应为 Good，因为只需认为第一句话为假，第二句话为真就符合两句话，所以是 Good。

所以共有一种合法方案。

### 数据范围

- 对于$10\%$ 的数据，$n \leq 7$；
- 对于$20\%$ 的数据，$n \leq 9$；
- 对于$60\%$ 的数据，$n \leq 20$；
- 对于$100\%$ 的数据，$1 \leq n \leq 50$。


## 样例 #1

### 输入

```
01```

### 输出

```
1```

## 样例 #2

### 输入

```
10101```

### 输出

```
1154```

## 样例 #3

### 输入

```
10101101010111110100110100101010110001010010101001```

### 输出

```
322173207```

# 题解

## 作者：Jμdge (赞：11)

咱这...写份题解？（不然一堆人看完 zzq 神仙的题解之后就绕道了...）


## 观察可得...

这么说，首先咱得看出这是一道基于图论的计数题...

为什么说是图论？楼上 zzq 奆佬讲了，这些点的指向关系构成了一棵基环树，并且另外一个关键点，一条指向边的两个端点的真假信息是对称的：

> 如果第 x 句话说第 y 句话是真的，那么第 y 句话是真的的同时 x 也会是真的，反之第 x 句话也是假的

> 如果第 x 句话说第 y 句话是假的，那么第 y 句话是真的的同时 x 就是假的了，反之第 x 句话就是真的

于是咱给这些指向边分成黑白两类，白色表示两个端点真假性相同，黑边为不同

那么如果所有话之间的真假性不出现矛盾，就必须满足基环树上的那个环上的黑边数目是偶数

## 设计状态与转移

接下来咱就要考虑如何去计算一个 i 条白边， j 条黑边的基环树构造的方案数了...

那么咱先考虑环上的情况...

首先咱设环上有 a 条白边和 b 条黑边（黑边数量要为偶数，且 $a+b$ 不能等于零），因为这些点是有编号的，所以我们直接像普通的 $n=a+b$ 个编号点计算成环方案数就行了，那么方案数就是咱破环成链后得到的 $(n-1)!$ 

然后咱考虑连上剩下的 $m=i+j-a-b$ 个点，这时候咱就需要用到 $prufer$ 序列辣...

经过一系列推导后咱可以得到环上加点的方案数为： $n*(n+m)^{m-1}$

相关证明： [这只菜鸡的博客](https://www.cnblogs.com/Judge/p/10920451.html#_label15) 里面第 16 条


稍微具体点，就是现在有一个长度为 n 的环和 m 个点，要加 m 条边使得它们联通，这个类似生成树计数的东西就可以用 prufer 爆掉，具体的公式上面的链接里面有


再乘上 i 个点里面选 a 个点，j 个点里面选 b 个点，那么我们就可以得到 i 条白边， j 条黑边构成的合法基环树方案为：

$$f[i][j]=\sum_{a+b<i+j \text{,~b是偶数}}(a+b-1)!* C_i^a C_j^b \big((a+b)·(i+j)^{i+j-a-b}\big)  +  [\text{j是偶数}] (i+j-1)! $$

这里的阶乘可以合并掉后面的 a+b ，但是出于对含义的体现，咱就没有合并

这里单独一个环的情况要特殊考虑...

这里的话，咱把后面的一小部分东西预处理了一下，就是对于长度为 n 的环和 m 个点构成基环树的方案先求出来，然后 f 直接累加即可，重新用公式表达一下就是：

$$g[n][m]=\begin{cases}(n-1)!* n(n+m)^{m-1} &,m>0\\ (n-1)!  &,m=0 \end{cases}$$

$$f[i][j]=\sum_{a+b<=i+j \text{,~b是偶数}} C_i^a ·C_j^b· g[a+b][i+j-a-b]$$

这样 f 数组的求法就 ojbk 了...

## 统计答案

最后终于是统计答案了，因为咱发现答案图可以是多个基环树构成的基环树森林，所以我们还要爆枚转移答案：

我们令 ans[i][j] 表示答案方案数，转移还是有点奇怪的，因为我们发现答案可能算重，比如说有两个白边自环的点，我们组合数计算答案的时候会算两次，不仅仅是这种情况，不同形状的基环树之间贡献也会算重，所以我们要固定 1 号点所在的位置，然后后面的基环树就可以随意枚举转移了...


具体操作还是看代码好了...

# Code

```
//by Judge
#include<cstdio>
#include<cstring>
#include<iostream>
#define Rg register
#define fp(i,a,b) for(Rg int i=(a),I=(b)+1;i<I;++i)
#define fd(i,a,b) for(Rg int i=(a),I=(b)-1;i>I;--i)
#define ll long long
using namespace std;
const int mod=998244353,M=53;
typedef int ARR[M][M];
char s[M]; ARR C,f,g,ans;
int n,one,zero,fac[M];
inline int mul(int x,int y){return 1ll*x*y%mod;}
inline void Pls(int& x,int y){if((x+=y)>=mod)x-=mod;}
inline int qpow(int x,int p){ Rg int s=1; if(p<=0) return 1;
	for(;p;p>>=1,x=mul(x,x)) if(p&1) s=mul(s,x); return s;
}
int main(){ scanf("%s",s+1),n=strlen(s+1);
	fp(i,1,n) if(s[i]==48) ++zero; else ++one;
	fac[0]=1; fp(i,1,n) fac[i]=mul(fac[i-1],i);
	fp(i,0,n) C[i][0]=1;
	fp(i,1,n) fp(j,1,n) C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;
	// i 个人构成 fake 圈， j 个人构成 fake 链 
	fp(i,1,n) fp(j,0,n-i) g[i][j]=mul(fac[i-1],mul(j?i:1,qpow(i+j,j-1)));
	// i 个人没有 fake ，j 个人 fake , a+b 个人构成 fake 圈，a 个人不 fake ，剩下的人构成 fake 链 
	fp(i,0,one) fp(j,0,zero) fp(a,0,i) for(Rg int b=0;b<=j;b+=2) if(a|b)
		Pls(f[i][j],mul(mul(C[i][a],C[j][b]),g[a+b][i+j-a-b]));
	ans[0][0]=1;
	fp(i,0,one) fp(j,0,zero) if(i|j){
		if(i) fp(a,1,i) fp(b,0,j) Pls(ans[i][j],mul(ans[i-a][j-b],mul(mul(C[i-1][a-1],C[j][b]),f[a][b])));
		else fp(b,1,j) Pls(ans[i][j],mul(ans[i][j-b],mul(mul(C[i][i],C[j-1][b-1]),f[i][b])));
	} return !printf("%d\n",ans[one][zero]);
}
```




---

## 作者：fjzzq2002 (赞：9)

假设第i句话为“第p句话为真”，我们就把i-p连一条白边，如果为“第p句话为假”，我们就把i-p连一条黑边。


我们考虑白边连接的两句话真假是相同的，黑边连接的两句话真假是相反的，所以这些边都是无向边，n个点恰有n条边，所以这一定是一堆环套树。我们可以发现满足题目条件只需每个环上都只有偶数条黑边。


看这个数据范围似乎需要一个$O(n^4)$左右的做法，考虑设$f[i][j]$表示i条黑边和j条白边连成了一个联通的环套树的方案数，考虑枚举环上有几条黑边，几条白边，那么考虑剩下的都是树边，把整个环缩成一个点，那么就相当于求出一棵生成树，但是环点可以任选一个点往外连出边。


这里可以直接dp，记$g[i][j]$为大小为i的环点连出去j条边的方案数，然后枚举当前环上这个点连出去几条边转移即可。比较优秀的做法是使用基尔霍夫矩阵，这里略。


求出$f[i][j]$之后再考虑每个联通块中有几条黑边几条白边，再设一个dp继续暴力转移一波即可。


---

## 作者：fjy666 (赞：2)

麻了第一次写 6.18KB 的计数。。。

转化（内向）基环树森林是显然的。

设 $f_{i,j,k,l}$ 代表使用 $i$ 个 $1$，$j$ 个 $0$，在环上有 $k$ 个点，这 $k$ 个点的入度总和为 $l$（必须是单棵基环树，不是基环树森林）。

先考虑如何计算答案。

令 $sb_{i,j}$ 为使用 $i$ 个 $1$，$j$ 个 $0$，则 $sb_{i,j} = \sum\sum f_{i,j,k,l}$。

然后设 $ans_{i,j}$ 表示使用 $i$ 个 $1$，$j$ 个 $0$ 的答案（这里允许是基环数森林）。

套路的钦定一个点必须被选，我们有

$ans_{i,j}=\begin{cases} \sum{ans_{i-k-1,j-l}\times sb_{k+1,l}\times \binom{i-1}{k-1}\times\binom{j}{l}},i>0\\
\sum{ans_{i-k,j-l-1}\times sb_{k,l + 1}\times \binom{i}{k}\times\binom{j-1}{l-1}},i=0\end{cases}$

考虑如何计算 $f$。

新加的点有一下几种情况？
1. 在环上，且环长度 $\ge 2$。
2. 在环上，且环长度 $=1$（有根树计数，需要预处理）
3. 指向环中某个点
4. 指向环外某个点

这些情况都需要枚举新加的点的度数，复杂度 $\mathcal{O}(n^5)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define _rep(i_,a_,b_) for(int i_ = (a_); i_ <= (b_); ++i_)
#define mid ((L+R) >> 1)
#define multiCase() int testCnt = in(); _rep(curCase,1,testCnt)
#ifdef ONLINE_JUDGE
#define debug(...) 0
#else
#define debug(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)
#endif
using ll = long long;
using pii = pair<int,int>;

int in(void) { int x; scanf("%d", &x); return x; } ll inl(void) { ll x; scanf("%lld", &x); return x; }
void out(int x) { printf("%d ", x); } void outln(int x) { printf("%d\n", x); }
void out(ll x) { printf("%lld ", x); } void outln(ll x) { printf("%lld\n", x); }
template<typename T> void chkmax(T &a, const T &b) { a = max(a, b); } 
template<typename T> void chkmin(T &a, const T &b) { a = min(a, b); } 
const int kN = 55, p = 998244353;
int n, cnt0 = 0, cnt1 = 0;
int f[kN][kN][kN][kN], g[kN][kN][kN][kN];
int C[150][150], iv[150][150], pre[kN][kN];
int sb[kN][kN], ans[kN][kN];
char s[kN];
int main() {
	scanf("%s", s + 1);
	int n = strlen(s + 1); 
	_rep(i,1,n) 
		cnt0 += s[i] == '1', cnt1 += s[i] == '0';
	C[0][0] = 1;
	_rep(i,1,100) {
		C[i][0] = C[i][i] = 1;
		_rep(j,1,i - 1) C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % p;
	}
	iv[1][1] = 1;
	_rep(i,1,100) {
		iv[i][0] = 1;
		if(i > 1) iv[i][1] = 1ll * (p - p / i) * iv[p % i][1] % p;
		_rep(j,2,100) iv[i][j] = 1ll * iv[i][j - 1] * iv[i][1] % p; 
	}
	_rep(i,0,100) iv[0][i] = 1;
	pre[1][0] = 1;
	_rep(i,2,50) {
		_rep(j,0,i - 1) {
			//枚举新加入的点的度数
			int &cur = pre[i][j];
			if(j > 0) {
			//case 1 直接指向根节点
				_rep(ind,0,i) if(j - 1 + ind <= 50) 
					cur = (cur + 1ll * C[j - 1 + ind][ind] * pre[i - 1][j - 1 + ind] % p) % p;
			//case 2 
				if(i == 4 && j == 1) debug("cur = %d\n", cur);
				_rep(ind,0,i) if(j + ind <= 50)
					cur = (cur + 1ll * C[j - 1 + ind][ind] * pre[i - 1][j + ind] % p * (i - 2) % p) % p;
				if(i == 4 && j == 1) debug("cur = %d\n", cur);
			}
		}
	}
	_rep(i,0,n) _rep(j,0,i)	debug("pre[%d][%d] = %d\n", i, j, pre[i][j]);
	debug("Finish initalizing.\n");
	// f[0][0][0][0] = 1;
	f[1][0][1][0] = g[0][1][1][0] = 1;
	// f[x][y][z][w] = F{<< >>}
	_rep(i,0,cnt0) _rep(j,0,cnt1) _rep(k,1,i + j) _rep(l,0,i + j) {
		if(!i && !j) continue;
		if((i == 1 && j == 0) || (i == 0 && j == 1)) continue;
		int tot = i + j, off_ring = tot - k;
		int &F = f[i][j][k][l], &G = g[i][j][k][l];
		if(i) { //考虑最后插入的点是一个【白色】点
			//Case 1：在环上
			if(k > 1) {
				//原来就有环
				//入度为 0
				F = (F + 1ll * f[i - 1][j][k - 1][l] * (k - 1) % p) % p;
				G = (G + 1ll * g[i - 1][j][k - 1][l] * (k - 1) % p) % p;
				//入度 > 0
				_rep(ind,1,l) {
					F = (F + 1ll * (k - 1) * f[i - 1][j][k - 1][l] % p
					* C[l][ind] % p * iv[k - 1][ind] % p) % p;
					G = (G + 1ll * (k - 1) * g[i - 1][j][k - 1][l] % p
					* C[l][ind] % p * iv[k - 1][ind] % p) % p;
				}
			} else if(k == 1) F = (F + pre[tot][l]) % p;
			if(i == 1 && j == 3 && k == 1 && l == 1) {
				debug("F = %d\n", F);
			}
			//Case 2：指向一个不在环上的节点
			//枚举入度
			if(off_ring > 1 && l > 0) { //首先X是一个不在环上的节点，且还有至少一个不在环上的节点
				_rep(ind,0,tot) if(l + ind <= n) {
					F = (F + 1ll * (off_ring - 1) * f[i - 1][j][k][l + ind] % p * C[l + ind - 1][ind] % p
					* iv[k][ind] % p) % p;
					G = (G + 1ll * (off_ring - 1) * g[i - 1][j][k][l + ind] % p * C[l + ind - 1][ind] % p
					* iv[k][ind] % p) % p;
				}
			}
			//Case 3：指向一个在环上的节点
			if(l >= 1) _rep(ind,0,tot) if(l - 1 + ind <= n) {
				int previous = l - 1 + ind;
				F = (F + 1ll * k * f[i - 1][j][k][previous] % p * C[previous][ind] % p
				* iv[k][ind] % p) % p;
				G = (G + 1ll * k * g[i - 1][j][k][previous] % p * C[previous][ind] % p
				* iv[k][ind] % p) % p;
			}
		} else {//考虑最后插入的点是一个【黑色】点
			//Case 1：在环上
			if(k > 1) {
				//原来就有环
				//入度为 0
				F = (F + 1ll * g[i][j - 1][k - 1][l] * (k - 1) % p) % p;
				G = (G + 1ll * f[i][j - 1][k - 1][l] * (k - 1) % p) % p;
				//入度 > 0
				_rep(ind,1,l) {
					F = (F + 1ll * (k - 1) * g[i][j - 1][k - 1][l] % p
					* C[l][ind] % p * iv[k - 1][ind] % p) % p;
					G = (G + 1ll * (k - 1) * f[i][j - 1][k - 1][l] % p
					* C[l][ind] % p * iv[k - 1][ind] % p) % p;
					if(i == 2 && j == 2 && k == 2 && l == 1) {
						debug("ind=%d %d\n", ind, F);
					}
				}
			} else if(k == 1) G = (G + pre[tot][l]) % p;
			//Case 2：指向一个不在环上的节点
			//枚举入度
			if(off_ring > 1 && l > 0) { //首先X是一个不在环上的节点，且还有至少一个不在环上的节点
				_rep(ind,0,tot) if(l + ind <= n)  {
					F = (F + 1ll * (off_ring - 1) * f[i][j - 1][k][l + ind] % p * C[l + ind - 1][ind] % p
					* iv[k][ind] % p) % p;
					G = (G + 1ll * (off_ring - 1) * g[i][j - 1][k][l + ind] % p * C[l + ind - 1][ind] % p
					* iv[k][ind] % p) % p;
				}
			}
			//Case 3：指向一个在环上的节点
			if(l >= 1) _rep(ind,0,tot) if(l - 1 + ind <= n)  {
				int previous = l - 1 + ind;
				F = (F + 1ll * k * f[i][j - 1][k][previous] % p * C[previous][ind] % p
				* iv[k][ind] % p) % p;
				G = (G + 1ll * k * g[i][j - 1][k][previous] % p * C[previous][ind] % p
				* iv[k][ind] % p) % p;
			}
		}
		debug("f[%d][%d][%d][%d] = %d\n", i, j, k, l, f[i][j][k][l]);
		// debug("g[%d][%d][%d][%d] = %d\n", i, j, k, l, g[i][j][k][l]);
	}
	_rep(i,0,cnt0) _rep(j,0,cnt1) {
		_rep(k,1,i + j) _rep(l,0,i + j)
			sb[i][j] = (sb[i][j] + f[i][j][k][l]) % p;
		debug("sb[%d][%d] = %d\n", i, j, sb[i][j]);
	}
	ans[0][0] = 1;
	_rep(i,0,cnt0) _rep(j,0,cnt1) if(i + j) {
		if(i) {
			_rep(k,0,i - 1) _rep(l,0,j) {
				ans[i][j] = (ans[i][j] + 1ll * ans[i - k - 1][j - l] * C[i - 1][k] % p * C[j][l] % p * sb[k + 1][l] % p) % p;
				debug("k=%d, l=%d, ans[%d][%d] = %d\n", k, l, i, j, ans[i][j]);
			}
		} else {
			_rep(k,0,i) _rep(l,0,j - 1) {
				ans[i][j] = (ans[i][j] + 1ll * ans[i - k][j - l - 1] * C[i][k] % p * C[j - 1][l] % p * sb[k][l + 1] % p) % p;
			}
		}
		debug("ans[%d][%d] = %d\n", i, j, ans[i][j]);
	}
	outln(ans[cnt0][cnt1]);
	return 0;
}

/* 
a list of keywords
clear empty push_back pop_back push pop top front back
emplace_back emplace push_front pop_front insert erase
find count set reset bitset map vector string multiset
first second iterator prev next deque multimap reverse
sort begin end list modify query init check calc prime
putchar getchar puts scanf printf max min swap replace
make_pair make_tuple numeric_limits auto function null
*/
```

---

## 作者：Aleph1022 (赞：1)

搬运一下[题解](https://www.luogu.com.cn/blog/qwaszx/post-20210619-xing-dui-hu-ce)。

记 $n=\#1, m=\#0$。

先来考虑如何判断是否有解。  
对于给定的 $a_1,\dots,a_N$，连边 $i \to a_i$，这显然恰会构成内向基环树森林。  
若 $b_i=1$，则要求 $i$ 与 $a_i$ 的真值相同。否则，要求 $i$ 与 $a_i$ 的真值相异。  
对于其中一棵内向基环树，注意到内向树部分的限制是很弱的。我们只需要确定环上的所有真值，而树上只需直接推出。  
而容易发现环上有解，当且仅当其中恰有偶数个 $0$，且恰有两个解。

我们用二元 EGF 刻画这个结构。显然，环的 EGF 为
$$
\sum_{k\ge 1} (k-1)! \sum_{j\ge 0} \frac{x^j y^{k-j}}{j!(k-j)!} = \ln\frac1{1-x-y}
$$

而含有偶数个 $y$ 的环的 EGF，可以通过 $\frac{1+(-1)^k}2 = [2 \mid k]$ 得到
$$
\frac12\left(\ln\frac1{1-x-y} + \ln\frac1{1-x+y}\right) = \frac12 \ln\frac1{(1-x)^2-y^2}
$$

而有根树的 EGF 可以直接以复合方程 $T(x, y) = (x+y)\mathrm e^{T(x, y)}$ 刻画。  
从而基环树就是环与有根树的复合
$$
\sqrt{\frac1{(1-x\mathrm e^{T(x, y)})^2-(y\mathrm e^{T(x,y)})^2}}
$$

我们欲提取 $n! m! [x^n y^m]$。

作换元 $x\mapsto s, y\mapsto st$，有
$$
=[s^{n+m} t^m] \sqrt{\frac1{(1-s\mathrm e^{T(s,st)})^2-(st\mathrm e^{T(s,st)})^2}}
$$

注意到 $T(s, st) = s(1+t) \mathrm e^{T(st, t)}$，即 $s \mathrm e^{T(s, st)} = \frac{T(s, st)}{1+t}$，就有
$$
\begin{aligned}
&=[s^{n+m} t^m] \sqrt{\frac1{\left(1-\frac{T(s, st)}{1+t}\right)^2-\left(t\frac{T(s, st)}{1+t}\right)^2}} \\
&=[s^{n+m} t^m] \sqrt{\frac{1+t}{1+t-2T(s, st)+(1-t)T^2(s, st)}} \\
&=[s^{n+m} t^m] \sqrt{\frac{1+t}{1+t-2s+(1-t)s^2}} \cdot \left(\frac{s\mathrm e^{-s}}{1+t}\right)' \cdot \left(\frac{s(1+t)}{s\mathrm e^{-s}}\right)^{n+m+1}\\
&=[s^{n+m} t^m] [1+t-2s+(1-t)s^2]^{-\frac12} (1+t)^{n+m+\frac12} (1-s)\mathrm e^{(n+m)s} \\
&=[s^{n+m} t^m] [(1-s)^2+t(1-s^2)]^{-\frac12} (1+t)^{n+m+\frac12} (1-s)\mathrm e^{(n+m)s} \\
&=[s^{n+m} t^m] \left(1+t\frac{1+s}{1-s}\right)^{-\frac12} (1+t)^{n+m+\frac12} \mathrm e^{(n+m)s} \\
&=[s^{n+m}] \mathrm e^{(n+m)s} \sum_{k\ge 0} \binom{-\frac12}k \binom{n+m+\frac12}{m-k} \left(\frac{1+s}{1-s}\right)^k \\
&=[s^{n+m}] \mathrm e^{(n+m)s} \binom{n+m+\frac12}m \cdot {}_2F_1\left(\frac12,-m;n+\frac32;\frac{1+s}{1-s}\right) \\
\end{aligned}
$$

根据 [EI 的结果](https://blog.csdn.net/EI_Captain/article/details/108930959)，整个式子是 D-Finite 的。从而我们可以做到 $O(N)$ 甚至 $O(\sqrt N \log N)$。

记 $f_k = [s^k] {}_2F_1\left(\frac12,-m;n+\frac32;\frac{1+s}{1-s}\right)$，此处给出 $f_k$ 的一个整式递推式：

$$
\begin{aligned}
(k-n-m-1)k f_k \\
-(k-2n-3)(k-1) f_{k-1} \\
-(k+n-m)(k-2) f_{k-2} \\
+(k-2)(k-3) f_{k-3} \\
-mf_{k-1} &= 0
\end{aligned}
$$

读者可以据此得到 $O(N)$ 解法。

也存在等价的 Prufer 序列做法，读者自证不难。

---

## 作者：Purslane (赞：0)

# Solution

设 $0$ 为黑点，$1$ 为白点。

最后形成了若干个基环树森林。

可能产生矛盾的地方是环上，因此我们需要保证环上有偶数个黑点。

由于 $n$ 很小，可以直接暴力枚举环上点的大小，做背包问题。

最后假如有 $x$ 个点在环上，根据 Prufer 序列，有 $n^{n-x-1}x$ 种方式连成基环树。

复杂度 $O(n^5)$。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MOD=998244353,MAXN=51;
int n,ans,_0,_1,dp[MAXN][MAXN][MAXN][MAXN],frac[MAXN],inv[MAXN],C[MAXN][MAXN]; 
string S;
int qpow(int base,int p) {int ans=1;if(p<0) p+=MOD-1;while(p) {if(p&1) ans=ans*base%MOD;base=base*base%MOD,p>>=1;}return ans;}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>S,n=S.size(),S="&"+S;
	ffor(i,1,n) if(S[i]=='0') _0++; else _1++;
	dp[_1][_0][0][0]=1;
	ffor(i,0,n) {C[i][0]=1;ffor(j,1,i) C[i][j]=(C[i-1][j]+C[i-1][j-1])%MOD;}
	frac[0]=1; ffor(i,1,n) frac[i]=frac[i-1]*i%MOD;
	inv[n]=qpow(frac[n],MOD-2); roff(i,n-1,0) inv[i]=inv[i+1]*(i+1)%MOD;
	int lx=0,ly=0;
	ffor(x,0,n) ffor(y,0,n) if((x||y)&&y%2==0) {
		ffor(a,0,n) ffor(b,0,n) {
			dp[a][b][x][y]=(dp[a][b][x][y]+dp[a][b][lx][ly])%MOD;
			int ta=a,tb=b,mul=1;
			ffor(c,1,min(x?a/x:n,y?b/y:n)) {
				mul=mul*C[ta][x]%MOD*C[tb][y]%MOD*frac[x+y-1]%MOD;
				ta-=x,tb-=y;
				dp[ta][tb][x][y]=(dp[ta][tb][x][y]+dp[a][b][lx][ly]*mul%MOD*inv[c])%MOD;	
			}
		}
		lx=x,ly=y;
	}
	ffor(x,0,n) ffor(y,0,n) if(dp[x][y][lx][ly]) ans=(ans+qpow(n,x+y-1)*(n-x-y)%MOD*dp[x][y][lx][ly])%MOD;
	cout<<ans;
	return 0;
}
```

---

## 作者：daniEl_lElE (赞：0)

容易转化为有标号基环树森林且环上点异或和为 $0$ 的问题。

首先先考虑环旁边的树，使用一个 dp 求出用 $i$ 个 $0$，$j$ 个 $1$ 组成一棵树，且根颜色为 $0/1$ 的方案数。具体细节见代码，每次暴力枚举一棵子树有几个 $0$ 几个 $1$，并钦定这个子树有最小的标号且数值为 $1$ 的点即可。复杂度 $O(n^4)$。

然后考虑基环树，使用一个 dp 求出用 $i$ 个 $0$，$j$ 个 $1$ 组成环大小为 $k$ 的一棵基环树的方案数。具体来讲，随意钦定一个位置作为开头，dp 出一条链，然后除以环大小即可（这也是为什么要记录 $k$）。复杂度 $O(n^5)$。

最后考虑求基环树森林。类似有标号有根树计数，同样使用 dp 求解。每次暴力拼上一棵基环树并钦定这个基环树有最小的标号且数值为 $1$ 的点即可。复杂度 $O(n^4)$。

总复杂度 $O(n^5)$。

```cpp
#include <bits/stdc++.h>
#define int long long
#define mid ((l+r)>>1)
#define add(i,j) ((i+j)>=mod?i+j-mod:i+j)
using namespace std;
const int mod=998244353;
int qp(int a,int b){
	if(b<0) b=mod-1-b;
	int ans=1;
	while(b){
		if(b&1) (ans*=a)%=mod;
		(a*=a)%=mod;
		b>>=1;
	}
	return ans;
}
int C[55][55],pre[55],pre2[55],dp1[2][55][55],dp2[55][55],dp3[2][55][55][55],tot[55][55],dp4[55],dp5[55][55];
signed main(){
	for(int i=0;i<=50;i++) C[i][0]=1;
	for(int i=1;i<=50;i++) for(int j=1;j<=i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;
	pre[0]=1;
	for(int i=1;i<=50;i++) pre[i]=dp1[1][0][i]=qp(i,i-1);
	pre2[0]=1;
	for(int i=1;i<=50;i++){
		pre2[i]=pre[i];
		for(int j=1;j<i;j++){
			(pre2[i]+=pre2[j]*pre[i-j]%mod*C[i-1][j])%=mod;
		}
	}
	dp1[0][1][0]=1;
	for(int i=1;i<=50;i++){
		for(int j=0;j<=50;j++){
			if(i+j<=1) continue;
			if(i==1) (dp1[0][i][j]+=pre2[j])%=mod;
			for(int k=0;k<=j;k++){
				if(i>1) (dp1[0][i][j]+=pre2[k]*(dp1[0][i-1][j-k]+dp1[1][i-1][j-k]+dp2[i-1][j-k])%mod*C[j][k]%mod*i)%=mod;
				if(j>k) (dp1[1][i][j]+=pre2[k]*(dp1[0][i][j-k-1]+dp1[1][i][j-k-1]+dp2[i][j-k-1])%mod*C[j-1][k]%mod*j)%=mod;
			}
			for(int k=1;k<i;k++){
				for(int l=0;l<=j;l++){
					(dp2[i][j]+=(dp1[0][k][l]+dp1[1][k][l])*(dp1[0][i-k][j-l]+dp1[1][i-k][j-l]+dp2[i-k][j-l])%mod*C[i-1][k-1]%mod*C[j][l])%=mod;
				}
			}
		}
	}
//	for(int i=0;i<=1;i++) for(int j=0;j<=3;j++) for(int k=0;k<=3;k++) cout<<i<<" "<<j<<" "<<k<<" "<<dp1[i][j][k]<<"\n";
	dp3[0][0][0][0]=1;
	for(int k=1;k<=50;k++){
		for(int i=0;i<=50;i++){
			for(int j=0;j<=50;j++){
				for(int l=0;l<=i;l++){
					for(int p=0;p<=j;p++){
						(dp3[0][k][i][j]+=(dp3[0][k-1][l][p]*dp1[0][i-l][j-p]+dp3[1][k-1][l][p]*dp1[1][i-l][j-p])%mod*C[i][l]%mod*C[j][p])%=mod;
						(dp3[1][k][i][j]+=(dp3[0][k-1][l][p]*dp1[1][i-l][j-p]+dp3[1][k-1][l][p]*dp1[0][i-l][j-p])%mod*C[i][l]%mod*C[j][p])%=mod;
					}
				}
			}
		}
	}
	for(int i=1;i<=50;i++){
		for(int j=0;j<=50;j++){
			for(int k=0;k<=50;k++){
				(tot[j][k]+=dp3[0][i][j][k]*qp(i,mod-2))%=mod;
			}
		}
	}
	for(int i=1;i<=50;i++){
		(dp4[i]+=tot[0][i])%=mod;
		for(int j=1;j<i;j++){
			(dp4[i]+=dp4[j]*tot[0][i-j]%mod*C[i-1][j])%=mod;
		}
		dp5[0][i]=dp4[i];
	}
	for(int i=1;i<=50;i++){
		for(int j=0;j<=50;j++){
			(dp5[i][j]+=tot[i][j])%=mod;
			for(int k=1;k<i;k++){
				for(int l=0;l<=j;l++){
					(dp5[i][j]+=dp5[k][l]*tot[i-k][j-l]%mod*C[i-1][k]%mod*C[j][l])%=mod;
				}
			}
		}
	}
	for(int i=1;i<=50;i++){
		for(int j=50;j>=0;j--){
			for(int k=1;k<=j;k++){
				(dp5[i][j]+=dp5[i][j-k]*dp4[k]%mod*C[j][k])%=mod;
			}
		}
	}
	string s; cin>>s;
	int cnt0=0,cnt1=0;
	for(int i=0;i<s.size();i++) cnt0+=(s[i]=='0'),cnt1+=(s[i]=='1');
	cout<<dp5[cnt1][cnt0];
	return 0; 
}
```

---


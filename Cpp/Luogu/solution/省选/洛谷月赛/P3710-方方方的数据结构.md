# 方方方的数据结构

## 题目描述

在很久很久以前，有一个长度为 $n$ 的数列，一开始数列全是 $0$。

方方方觉得这个数列太单调了，打算对它进行 $m$ 次操作，每次操作为区间加法或者区间乘法。

方方方进行一些操作之后，还可能会对某个数进行询问。

但是进行过一些操作之后，方方方可能会发现之前某次操作失误了，需要撤销这次操作，其它操作和其它操作的前后顺序保持不变。

方方方想好这些操作之后，马上想到了一个优秀的数据结构可以维护这些东西，可是他懒得写标程了，就生成了 $10$ 个**随机数据**，就把这道题扔给了你。

**数据全是随机的，生成方式见最下方的提示。**


## 说明/提示

对于 $20\%$ 的数据，$n,m \leq 500$，时限 1s。

对于 $50\%$ 的数据，$n,m \leq 30000$，时限 1s。

对于 $100\%$ 的数据，$1 \leq n,m \leq 150000$，$1 \le l \le r \le n$，$3$ 操作的 $p$ 满足 $1 \le p \le n$，$4$ 操作的 $p$ 满足 $1 \le p \le m$，$0 \leq d \leq 1073741823$（原因见数据生成器），时限 4.5s。


数据生成器：

```cpp
#include <bits/stdc++.h>
using namespace std;
int rand_() {return rand()&32767;} 
int br() {return rand_()*32768+rand_();}
vector<int> cs;
int main()
{
    srand(...); //这里要填一个种子 
    int n=...,m=...; //这里要填n、m
    cout<<n<<" "<<m<<"\n";
    for(int i=1;i<=m;i++)
    {
        int o=rand()%4+1;
        if(o<=2)
        {
            cout<<o<<" ";
            int l=br()%n+1,r=br()%n+1;
            if(l>r) swap(l,r); cs.push_back(i);
            cout<<l<<" "<<r<<" "<<br()<<"\n";
        }
        else if(o==3) cout<<o<<" "<<br()%n+1<<"\n";
        else
        {
            if(!cs.size()) {--i; continue;}
            int s=br()%cs.size(),g=cs[s];
            cs.erase(cs.begin()+s);
            cout<<o<<" "<<g<<"\n";
        }
    }
}
```

## 样例 #1

### 输入

```
6 14
1 1 5 1
2 2 4 3
1 2 6 5
3 2
4 1
3 3
2 1 3 4
3 3
1 2 2 3
3 2
4 7
3 1
3 2
3 3```

### 输出

```
8
5
20
23
0
8
5```

# 题解

## 作者：fjzzq2002 (赞：28)

本来这题是打算正常构造数据的，结果出现了意外，我的标程常数实在感人，实在要卡掉暴力大概要开100s一个点......然后就只能出随机数据了，并不知道有没有什么神奇算法可以过，就当做良心送分好了。


考虑将时间轴分块，块大小$\sqrt{m}$左右，每一次处理这一块内的询问。


对于这一块内的询问，修改的存在与否都是一样的，除了这一块内的询问和这一块内撤销的询问。


考虑以这一块内的询问和这一块内撤销的询问的插入点作为关键点，这些关键点把当前时间轴分成了若干块，相邻关键点之间建一棵线段树或者平衡树维护标记。


查询的时候查询第一棵线段树，判断第一个关键点的询问是否包含它，包含则更新，依次查询判断。


这个做法复杂度是$O(m\sqrt{m}logm)$的，常数很大，所以并不能跑过暴力...


因为是随机数据，只要把块大小调成$4\sqrt{m}$左右就能跑得很快了。


---

## 作者：kczno1 (赞：19)

由于可以离线，我们可以知道每个修改操作的结束时间。

所以每个修改操作相当于对一个序列上区间,时间上一个区间的询问造成影响。

实质上就是矩形修改，单点询问。

用kd-tree即可。

时间O(nlog^2)空间O(n)

不需要数据随机

空间也只用了26mb

```cpp
#include<bits/stdc++.h>
using std::sort;
using std::nth_element;

#define ll long long
void chmax(int &x,int y) { if(x<y)x=y; }
void chmin(int &x,int y) { if(x>y)x=y; }
const int N=150100,D=998244353;
int n,m,i;
int type,l,r,x;
struct query
{
    int type,l,r,x;
}q[N];
int last[N];
int id[N],num,dy[N],rt;
bool x_xiao(int x,int y)
{
    return q[x].x<q[y].x;
}
int f[N],c[N][2];
int t_mx[N],t_mn[N],x_mn[N],x_mx[N];
void up(int y,int x)
{
    chmax(t_mx[y],t_mx[x]);
    chmin(t_mn[y],t_mn[x]);
    chmax(x_mx[y],x_mx[x]);
    chmin(x_mn[y],x_mn[x]);
}
void up(int x)
{
    if(c[x][0])up(x,c[x][0]);
    if(c[x][1])up(x,c[x][1]);
}
void sc(int y,int x,bool d)
{
    f[x]=y;
    c[y][d]=x;
}
int build(int l,int r,bool type)
{
    int rt=l+r>>1;
    if(!type) //以时间为关键字
    {
        nth_element(id+l,id+rt,id+r+1);
    }
    else//以位置为关键字 
    {
        nth_element(id+l,id+rt,id+r+1,x_xiao);
    }
    int x=id[rt]; 
    dy[x]=rt;
    t_mx[rt]=t_mn[rt]=x;x_mx[rt]=x_mn[rt]=q[x].x;
    if(l!=rt) sc(rt,build(l,rt-1,!type),0);
    if(r!=rt) sc(rt,build(rt+1,r,!type),1);
    up(rt);
    return rt;
}

struct Tag
{
    int a,b;
    Tag(int _a=1,int _b=0) { a=_a;b=_b; }
    friend Tag operator +(const Tag &x,const Tag &y)
    {
        return Tag((ll)x.a*y.a%D,((ll)x.b*y.a+y.b)%D);
    }
}tag[N],a[N],I;
void add(int x,const Tag &ad)
{
    tag[x]=tag[x]+ad;
    a[x]=a[x]+ad;
}
void down(int x)
{
    if(tag[x].a!=1||tag[x].b)
    {
        if(c[x][0])add(c[x][0],tag[x]);
        if(c[x][1])add(c[x][1],tag[x]);
        tag[x]=I;
    }
}
int st[100],top;
int qiu(int x)
{
    t_mx[x]=0;t_mn[x]=N;x_mx[x]=0;x_mn[x]=N;
    up(x);
    for(int i=x;i=f[i];) up(st[++top]=i);
    for(;top;--top) down(st[top]);
    return a[x].b;
}

int t_r,x_l,x_r;
Tag now;
void add(int x)
{
    if(x_mn[x]>x_r||x_mx[x]<x_l||t_mn[x]>t_r||t_mx[x]<i) return ;
    if(x_mn[x]>=x_l&&x_mx[x]<=x_r&&t_mx[x]<=t_r) {add(x,now);return ;}
    int i=id[x];
    if(q[i].x>=x_l&&q[i].x<=x_r&&i<=t_r) a[x]=a[x]+now;
    down(x);
    add(c[x][0]);add(c[x][1]); 
}

int main()
{
    freopen("1.in","r",stdin);freopen("3.out","w",stdout);
    scanf("%d%d",&n,&m);
    for(i=1;i<=m;++i) 
    {
        scanf("%d",&q[i].type);
        if(q[i].type<=2) 
        { 
          last[i]=N;
          scanf("%d%d%d",&q[i].l,&q[i].r,&q[i].x); 
          q[i].x%=D;
        }
        else 
        {scanf("%d",&q[i].x);
         if(q[i].type==4) last[q[i].x]=i;
         else id[++num]=i;
        }
    }
    rt=build(1,num,0);
    for(i=1;i<=m;++i)
    {
       if(q[i].type==4) continue;
       if(q[i].type==3) { printf("%d\n",qiu(dy[i]));continue; }
       t_r=last[i];x_l=q[i].l;x_r=q[i].r;
       if(q[i].type==1) now=Tag(1,q[i].x);
       else now=Tag(q[i].x,0);
       add(rt);
    }
}
```

---

## 作者：devout (赞：14)

如果没有最后一个操作，我们可以用一个线段树来解决（线段树2弱化版）。

我们考虑对于时间轴分块，设块的大小为 $w$，每个块内用一棵线段树维护两个参数 $a,b$，表示$x$经过这一段区间之后会变成 $ax+b$。

那么修改就是一棵线段树上的区间修改，复杂度$O(\log n)$。

查询我们查询前缀的几个块，零散部分暴力查询，复杂度 $O(\dfrac{m\log m}{w})$。

如果有撤销操作，我们把撤销操作所在的块暴力重构一下，复杂度 $O(w\log m)$。

显然，在随机数据下，$w=\sqrt m$ 的时候最优。

但是这个做法的空间复杂度是 $O(n\sqrt m)$ 的，会 $20$ 分MLE

**优化1**

我们发现一个块里面的操作次数最多有 $\sqrt m$ 个，也就是关键点最多只会有 $2\sqrt m$ 个，所以我们考虑块内离散化之后建树，这样我们线段树的节点总数就降低到了 $O(m)$ 级别。

但是注意离散化的细节，因为后面查询的时候查询的位置可能这一块里面都没有，所以对于 $[l,r]$ 区间我们需要离散化 $l,r,l-1,r-1$。


~~然后你就会TLE~~

**优化2**

我们发现在随机数据下，有一半多的操作在暴力重构的时候是不需要的，但是我们每次还是判断了一遍，影响了时间，所以我们考虑并查集维护 $i$  之后跳到了哪里，这样~~理论上~~可以节省一半的时间。

**优化3**

我们在暴力重构之前不需要遍历每一个节点，因为有些位置我们可能后面一直都访问不到，所以我们直接打一个 $clear$ 标记就可以了

~~因为这个线段树常数很大，所以要卡常~~

**卡常**

- 尽量用减法替代取模。

- 能不写函数就不写函数，把 pushdown，还有操作 3 操作 4 的函数扔出来。

- 把一些无意义的赋值删掉。

然后就可以过了（

总复杂度是$O(m\sqrt m\log n)$

~~然后成功喜提最差解~~

```cpp
#include <bits/stdc++.h>
using namespace std;

# define Rep(i,a,b) for(register int i=a;i<=b;++i)
# define _Rep(i,a,b) for(register int i=a;i>=b;--i)
# define RepG(i,u) for(int i=head[u];~i;i=e[i].next)

const int N=1.5e5+5;
const int W=450;
const int mod=998244353;
const int MAX_SIZE=1<<22;
char *ll,*rr,buf[MAX_SIZE];

inline int gc() {
    if(ll==rr)
        if(ll==(rr=(ll=buf)+fread(buf,1,MAX_SIZE,stdin))) return -1;
    return *ll++; 
}

template<typename T> void read(T &x){
    char c=gc();
    int f=1;x=0;
    for(;!isdigit(c);c=gc())if(c=='-')f=-1;
    for(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c-'0');
    x*=f;
}

int n,m,sq,bl;
int l[N],r[N],pos[N];
int root[W],tot,Q[W];
int fa[N];
int b[W][W<<2];

int find(int x){
	if(fa[x]==x)return x;
	return fa[x]=find(fa[x]);	
}

struct misaka{
	int opt,x,y,k;	
}q[N];

struct mikoto{
	int lc,rc;
	int a,b;
	int tagp,tagm;	
	bool clr;
}seg[N*20];

inline void renew(int u,int add,int mul,bool clr){
	if(clr){
		seg[u].a=seg[u].tagm=1;
		seg[u].b=seg[u].tagp=0;
		seg[u].clr=true;
	}
	if(mul!=1){
		seg[u].a=1ll*seg[u].a*mul%mod;
		seg[u].b=1ll*seg[u].b*mul%mod;
		seg[u].tagm=1ll*seg[u].tagm*mul%mod;
		seg[u].tagp=1ll*seg[u].tagp*mul%mod;
	}
	if(add){
		seg[u].b+=add;
		if(seg[u].b>mod)seg[u].b-=mod;
		seg[u].tagp+=add;
		if(seg[u].tagp>mod)seg[u].tagp-=mod;
	}
}

int build(int l,int r){
	int u=++tot;
	seg[u].a=1;
	seg[u].tagm=1;
	if(l==r)return u;
	int mid=l+r>>1;
	seg[u].lc=build(l,mid);
	seg[u].rc=build(mid+1,r);
	return u;	
}

void update(int u,int l,int r,int ql,int qr,int mul,int add){
	if(l>=ql&&r<=qr){
		renew(u,add,mul,0);
		return;
	}
	renew(seg[u].lc,seg[u].tagp,seg[u].tagm,seg[u].clr);
	renew(seg[u].rc,seg[u].tagp,seg[u].tagm,seg[u].clr);
	seg[u].tagp=0,seg[u].tagm=1;
	seg[u].clr=false;
	int mid=l+r>>1;
	if(ql<=mid)update(seg[u].lc,l,mid,ql,qr,mul,add);
	if(qr>mid)update(seg[u].rc,mid+1,r,ql,qr,mul,add);
}

void query(int u,int l,int r,int x,int &val){
	if(l==r){
		val=1ll*val*seg[u].a%mod+seg[u].b;
		if(val>mod)val-=mod;
		return;	
	}
	renew(seg[u].lc,seg[u].tagp,seg[u].tagm,seg[u].clr);
	renew(seg[u].rc,seg[u].tagp,seg[u].tagm,seg[u].clr);
	seg[u].tagp=0,seg[u].tagm=1;
	seg[u].clr=false;
	int mid=l+r>>1;
	if(x<=mid)return query(seg[u].lc,l,mid,x,val);
	else return query(seg[u].rc,mid+1,r,x,val);	
}

inline void init(){
	sq=sqrt(m);
	Rep(i,1,m)pos[i]=(i-1)/sq+1;
	bl=pos[m];
	Rep(i,1,bl)l[i]=(i-1)*sq+1,r[i]=i*sq;
	r[bl]=m;
	Rep(i,1,m+1)fa[i]=i;
	Rep(k,1,bl){
		b[k][++Q[k]]=n;
		Rep(i,l[k],r[k])
			if(q[i].opt<=2){
				b[k][++Q[k]]=q[i].x;
				b[k][++Q[k]]=q[i].x-1;
				b[k][++Q[k]]=q[i].y;
				b[k][++Q[k]]=q[i].y-1;	
			}
		sort(b[k]+1,b[k]+Q[k]+1);
		Q[k]=unique(b[k]+1,b[k]+Q[k]+1)-b[k]-1;
		Rep(i,l[k],r[k])
			if(q[i].opt<=2){
				q[i].x=lower_bound(b[k]+1,b[k]+Q[k]+1,q[i].x)-b[k];
				q[i].y=lower_bound(b[k]+1,b[k]+Q[k]+1,q[i].y)-b[k];	
			}
		root[k]=build(1,Q[k]);
	}
	_Rep(i,m,1)if(q[i].opt>2)fa[i]=find(i+1);
}	

signed main()
{
	read(n),read(m);
	Rep(i,1,m){
		read(q[i].opt),read(q[i].x);
		if(q[i].opt<=2)read(q[i].y),read(q[i].k);
		if(q[i].k>mod)q[i].k-=mod;
	}	
	init();
	Rep(i,1,m)
		if(q[i].opt==1)update(root[pos[i]],1,Q[pos[i]],q[i].x,q[i].y,1,q[i].k);
		else if(q[i].opt==2)update(root[pos[i]],1,Q[pos[i]],q[i].x,q[i].y,q[i].k,0);
		else if(q[i].opt==3){
			int x=i,p=q[i].x;
			int val=0;
			for(int i=1;i<pos[x];i++){
				int pos=lower_bound(b[i]+1,b[i]+Q[i]+1,p)-b[i];
				query(root[i],1,Q[i],pos,val);
			}
			int now=find(l[pos[x]]);
			while(now<=x){
				int at=lower_bound(b[pos[x]]+1,b[pos[x]]+Q[pos[x]]+1,p)-b[pos[x]];
				if(q[now].opt==1&&q[now].x<=at&&q[now].y>=at){
					val+=q[now].k;
					if(val>mod)val-=mod;	
				}
				else if(q[now].opt==2&&q[now].x<=at&&q[now].y>=at)val=1ll*val*q[now].k%mod;
				now=find(now+1);
			}
			printf("%d\n",val);	
		}
		else{
			int p=q[i].x,x=i;
			fa[p]=find(p+1);
			int now=find(l[pos[p]]);
			renew(root[pos[p]],0,1,1);
			int top=min(r[pos[p]],x);
			while(now<=top){
				if(q[now].opt==1)update(root[pos[p]],1,Q[pos[p]],q[now].x,q[now].y,1,q[now].k);
				else if(q[now].opt==2)update(root[pos[p]],1,Q[pos[p]],q[now].x,q[now].y,q[now].k,0);
				now=find(now+1);
			}	
		}
	return 0;
}
```


---

## 作者：FxorG (赞：3)

## $\text{Solution}$

考虑对于每个操作处理存在区间。

加上时间轴一维就是矩阵的修改和单点查了。

考虑 2-D tree 维护。

## $\text{Code}$ 

~~其实这题不难码，细节有点多而已，码了2h，一遍过。~~

```cpp
#include <bits/stdc++.h>

#define N (int)(1.5e5+5)
#define int long long
#define mod 998244353

using namespace std;

struct Point {
	int x,y,val;
}s[N];

struct node {
	int l,r,ll,rr,val,op;
}q[N];

int ls[N],rs[N],L[N],R[N],D[N],U[N],add[N],mul[N];
int n,m,tot,ans,rt;

int rd() {
	int f=1,sum=0; char ch=getchar();
	while(!isdigit(ch)) {if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)) {sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}
	return sum*f;
}

int ff(int x) {
	return x*x;
}

bool Get(int l,int r) {
	int sumx=0,sumy=0,disx=0,disy=0;
	for(int i=l;i<=r;i++) sumx+=s[i].x,sumy+=s[i].y;
	sumx/=(r-l+1); sumy/=(r-l+1);
	for(int i=l;i<=r;i++) {
		disx+=ff(sumx-s[i].x);
		disy+=ff(sumy-s[i].y);
	}
	return disx>=disy;
}

bool cmp1(Point x,Point y) {
	return x.x==y.x?x.y<y.y:x.x<y.x;
}

bool cmp2(Point x,Point y) {
	return x.y==y.y?x.x<y.x:x.y<y.y;
}

void push_up(int x) {
	L[x]=R[x]=s[x].x;
	D[x]=U[x]=s[x].y;
	if(ls[x]) {
		L[x]=min(L[x],L[ls[x]]); R[x]=max(R[x],R[ls[x]]);
		D[x]=min(D[x],D[ls[x]]); U[x]=max(U[x],U[ls[x]]);
	}
	if(rs[x]) {
		L[x]=min(L[x],L[rs[x]]); R[x]=max(R[x],R[rs[x]]);
		D[x]=min(D[x],D[rs[x]]); U[x]=max(U[x],U[rs[x]]);
	}
}

int build(int l,int r) {
	if(l>r) return 0;
	int mid=(l+r)>>1;
	bool fl=Get(l,r);
	nth_element(s+l,s+mid,s+r+1,fl?cmp1:cmp2);
	mul[mid]=1; add[mid]=0;
	ls[mid]=build(l,mid-1); rs[mid]=build(mid+1,r);
	push_up(mid);
	return mid;
}

void push_add(int x,int v) {
	(s[x].val+=v)%=mod; (add[x]+=v)%=mod;
} 

void push_mul(int x,int v) {
	(s[x].val*=v)%=mod; (add[x]*=v)%=mod; (mul[x]*=v)%=mod;
}

void push_down(int x) {
	if(mul[x]!=1) {
		if(ls[x]) push_mul(ls[x],mul[x]);
		if(rs[x]) push_mul(rs[x],mul[x]);
		mul[x]=1;
	}
	if(add[x]) {
		if(ls[x]) push_add(ls[x],add[x]);
		if(rs[x]) push_add(rs[x],add[x]);
		add[x]=0;
	}
}

void update1(int l,int r,int cl,int cr,int cll,int crr,int val) {
	if(l>r) return;
	int mid=(l+r)>>1;
	if(L[mid]>cr||R[mid]<cl||D[mid]>crr||U[mid]<cll) return;
	if(cl<=L[mid]&&R[mid]<=cr&&cll<=D[mid]&&U[mid]<=crr) {
		push_add(mid,val);
		return;
	}
	if(cl<=s[mid].x&&s[mid].x<=cr&&cll<=s[mid].y&&s[mid].y<=crr) (s[mid].val+=val)%=mod;
	push_down(mid);
	if(ls[mid]) update1(l,mid-1,cl,cr,cll,crr,val);
	if(rs[mid]) update1(mid+1,r,cl,cr,cll,crr,val);
}

void update2(int l,int r,int cl,int cr,int cll,int crr,int val) {
	if(l>r) return;
	int mid=(l+r)>>1;
	if(L[mid]>cr||R[mid]<cl||D[mid]>crr||U[mid]<cll) return;	
	if(cl<=L[mid]&&R[mid]<=cr&&cll<=D[mid]&&U[mid]<=crr) {
		push_mul(mid,val);
		return;
	}
	if(cl<=s[mid].x&&s[mid].x<=cr&&cll<=s[mid].y&&s[mid].y<=crr) (s[mid].val*=val)%=mod;
	push_down(mid);
	if(ls[mid]) update2(l,mid-1,cl,cr,cll,crr,val);
	if(rs[mid]) update2(mid+1,r,cl,cr,cll,crr,val);
}

void query(int l,int r,int x,int y) {
	if(l>r) return;
	int mid=(l+r)>>1;
	if(R[mid]<x||L[mid]>x||U[mid]<y||D[mid]>y) return;
	if(s[mid].x==x&&s[mid].y==y) {
		ans=s[mid].val;
		return;
	}
	push_down(mid);
	if(ls[mid]) query(l,mid-1,x,y);
	if(rs[mid]) query(mid+1,r,x,y);
}

signed main() {
	int op,x,y,z;
	n=rd(); m=rd();
	for(int i=1;i<=m;i++) {
		op=rd();
		if(op<=2) {
			x=rd(); y=rd(); z=rd();
			q[i]=node{x,y,i,m,z,op};
		} else if(op==3) {
			x=rd();
			s[++tot]=Point{x,i,0};
			q[i].op=3; q[i].l=x; q[i].r=i;
		} else {
			x=rd();
			q[x].rr=i;
		}
	}	
	build(1,tot);
	for(int i=1;i<=m;i++) {
		if(!q[i].op) continue;
		if(q[i].op==3) {
			ans=0;
			query(1,tot,q[i].l,q[i].r);
			printf("%lld\n",ans);
		} else if(q[i].op==1) {
			update1(1,tot,q[i].l,q[i].r,q[i].ll,q[i].rr,q[i].val); //add
		} else {
			update2(1,tot,q[i].l,q[i].r,q[i].ll,q[i].rr,q[i].val); //mul
		}
	}
	return 0;
}
```

---

## 作者：MuYC (赞：2)

#### Solution

一道比较简单的 KD-T 练习题（雾）

我们把每一个操作当成是对于一个二维平面进行操作，以时间为纵坐标，序列的下标为横坐标的话，可以发现每一个修改操作影响的时间段即为其第一次出现的时间到被撤销的时间，相当于一个平面上的矩形的加法以及乘法。以询问的点$(p, t)$（ $p,t$ 分别为序列位置以及查询的时间 ）建一个 KD-T，然后维护矩形加以及矩形的乘法，最后单点查询即可得到答案。

复杂度: $O(n \sqrt{n})$

#### Code
```cpp
#include <bits/stdc++.h>
#define Rep(i, l, r) for(int i = l ; i <= r ; i ++)
#define Lep(i, r, l) for(int i = r ; i >= l ; i --)
using namespace std;
const int Mod = 998244353;
inline void read() {}
template <typename T, typename... Args>
inline void read(T& x, Args&... args) {
	int flag = 1; x = 0;
	char ch = getchar();
	for( ; ch > '9' || ch < '0' ; ch = getchar()) if(ch == '-') flag = -1;
	for( ; ch >= '0' &&  ch <= '9' ; ch = getchar()) x = x * 10 + ch - '0';
	x * flag, read(args...);
}
const int MAXN = 1.5e5 + 50;
struct Martix {
	int X[2], Y[2], op, d;
} M[MAXN];
struct Node {
	int P[2];
} N[MAXN], Q[MAXN];
struct KDT {
	int M[2], Mi[2], ls, rs, x, y;
	int tagMul, tagAdd, val;
} T[MAXN];
int n, m, op, siz, id, rt = 0, cnt;
inline bool cmp0(Node a, Node b) { return a.P[0] < b.P[0]; }
inline bool cmp1(Node a, Node b) { return a.P[1] < b.P[1]; }                     
void build(int &x, int l, int r, int D) {
	if(l > r) return ;
	if(!x) x = ++ cnt;
	int mid = (l + r) >> 1;
	if(!D) nth_element(N + l, N + mid, N + 1 + r, cmp0);
	else nth_element(N + l, N + mid, N + 1 + r, cmp1);
	T[x].tagAdd = T[x].val = 0, T[x].tagMul = 1;
	T[x].M[0] = T[x].Mi[0] = T[x].x = N[mid].P[0];
	T[x].M[1] = T[x].Mi[1] = T[x].y = N[mid].P[1];
	build(T[x].ls, l, mid - 1, D ^ 1);
	build(T[x].rs, mid + 1, r, D ^ 1);
	int ls = T[x].ls, rs = T[x].rs;
	Rep(i, 0, 1) { 
		if(ls) T[x].M[i] = max(T[ls].M[i], T[x].M[i]), 
			   T[x].Mi[i] = min(T[ls].Mi[i], T[x].Mi[i]);
		if(rs) T[x].M[i] = max(T[rs].M[i], T[x].M[i]), 
			   T[x].Mi[i] = min(T[rs].Mi[i], T[x].Mi[i]);
	}
	return ;
}
bool out(Martix a, KDT b) {
	return (a.X[0] > b.M[0] || a.X[1] < b.Mi[0] || a.Y[0] > b.M[1] || a.Y[1] < b.Mi[1]);
}
bool in(Martix a, KDT b) {
	return (a.X[1] >= b.M[0] && a.X[0] <= b.Mi[0] && a.Y[1] >= b.M[1] && a.Y[0] <= b.Mi[1]);
}
void ad(int x, int k, int op) {
	int &M = T[x].tagMul, &Ad = T[x].tagAdd, &val = T[x].val;
	if(op == 1) Ad += k, Ad %= Mod, val += k, val %= Mod;
	if(op == 2) M = 1ll * k * M % Mod, Ad = 1ll * Ad * k % Mod, val = 1ll * val * k % Mod;
	return ;
}
void pushdown(int x) {
	int &M = T[x].tagMul, &Ad = T[x].tagAdd;
	int ls = T[x].ls, rs = T[x].rs;
	if(M == 1 && !Ad) return;
	ad(ls, M, 2), ad(rs, M, 2);
	ad(ls, Ad, 1), ad(rs, Ad, 1);
	M = 1, Ad = 0; return ;
}
void change(int x, Martix s, int D) {
	if(in(s, T[x])) {
		ad(x, s.d, s.op);
		return ; 
	}
	if(T[x].x >= s.X[0] && T[x].x <= s.X[1] && T[x].y >= s.Y[0] && T[x].y <= s.Y[1]) {
		if(s.op == 1) T[x].val += s.d, T[x].val %= Mod;
		if(s.op == 2) T[x].val = 1ll * T[x].val * s.d % Mod;
	}
	if(out(s, T[x])) return ;
	pushdown(x);
	if(T[x].ls) change(T[x].ls, s, D ^ 1);
	if(T[x].rs) change(T[x].rs, s, D ^ 1);
	return ;
}
int GetAns(int x, int X, int Y, int D) {
	if(!x) return 0;
	if(X > T[x].M[0] || X < T[x].Mi[0] || Y > T[x].M[1] || Y < T[x].Mi[1]) return 0;
	if(T[x].x == X && T[x].y == Y) return T[x].val;
	pushdown(x);
	int ans = 0;
	ans |= GetAns(T[x].ls, X, Y, D ^ 1);
	ans |= GetAns(T[x].rs, X, Y, D ^ 1);
	return ans;
}

int main() {
	read(n, m);
	Rep(i, 1, m) {
		read(op);
		if(op <= 2) read(M[i].X[0], M[i].X[1], M[i].d), M[i].Y[0] = i, M[i].op = op;
		if(op == 3) read(N[++ siz].P[0]), N[siz].P[1] =  i, Q[siz] = N[siz];
		if(op == 4) read(id), M[id].Y[1] = i;
	}
	build(rt, 1, siz, 0);
	Rep(i, 1, m) if(M[i].Y[0]) { 
		if(M[i].Y[1] == 0) M[i].Y[1] = m;
		change(rt, M[i], 0); 
	}
	Rep(i, 1, siz) printf("%d\n", GetAns(rt, Q[i].P[0], Q[i].P[1], 0));
	
	return 0;
}
```

---

## 作者：yzxoi (赞：1)

## [My Blog](https://yzxoi.top/archives/1738)

## Description

> 题目链接：[P3710](https://www.luogu.com.cn/problem/P3710)

给定一个长度为 $n$ 的序列，一开始序列的数全是 $0$，有 $m$ 个操作。

1. 区间加
2. 区间乘
3. 单点查
4. 撤销第 $p$ 个操作（保证为加、乘操作）

$1\leq n,m\leq 150000$，时间限制 $4s$，保证数据随机。

## Solution

首先如果只有前 $3$ 个操作可以使用线段树。

然后考虑第 $4$ 个操作如何转化。

由于不是强制在线，所以可以先把所有询问都先离线下来，然后从后往前扫一遍所有第 $4$ 个操作，得出每个 $1,2$ 操作的生效区间。

然后就转化成了个二维平面问题：

1. 矩阵加
2. 矩阵乘
3. 单点查

由于本蒟蒻不会 KD-TREE，所以就直接用四叉树啦~~（虽然四叉树的复杂度貌似是假的）~~

然而内存限制为 128MB，所以需要先把所有询问需要使用的区间先找出来，只对这个区间修改&查询即可（这种方法只能针对于单点查询）。

## Code

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define W while
#define I inline
#define RI register int
#define LL long long
#define Cn const
#define CI Cn int&
#define gc getchar
#define D isdigit(c=gc())
#define pc(c) putchar((c))
#define min(x,y) ((x)<(y)?(x):(y))
#define max(x,y) ((x)>(y)?(x):(y))
using namespace std;
namespace Debug{
	Tp I void _debug(Cn char* f,Ty t){cerr<<f<<'='<<t<<endl;}
	Ts I void _debug(Cn char* f,Ty x,Ar... y){W(*f!=',') cerr<<*f++;cerr<<'='<<x<<",";_debug(f+1,y...);}
	Tp ostream& operator<<(ostream& os,Cn vector<Ty>& V){os<<"[";for(Cn auto& vv:V) os<<vv<<",";os<<"]";return os;}
	#define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)
}using namespace Debug;
namespace FastIO{
	Tp I void read(Ty& x){char c;int f=1;x=0;W(!D) f=c^'-'?1:-1;W(x=(x<<3)+(x<<1)+(c&15),D);x*=f;}
	Ts I void read(Ty& x,Ar&... y){read(x),read(y...);}
	Tp I void write(Ty x){x<0&&(pc('-'),x=-x,0),x<10?(pc(x+'0'),0):(write(x/10),pc(x%10+'0'),0);}
	Tp I void writeln(Cn Ty& x){write(x),pc('\n');}
}using namespace FastIO;
Cn int N=150010,P=998244353;
int n,m,A[N],rt;
struct Que{int opt,l,r,x;}q[N];
class SegmentTree{
	private:
		int cnt;
		struct node{int son[4],S,T,sz;}T[N*20];//由于每个询问最多只能扫log的区间，所以只需要开 N*20，S维护和，T为乘懒标记
		#define midX (a+c>>1)
		#define midY (b+d>>1)
		#define S0 T[x].son[0],a,b,midX,midY
		#define S1 T[x].son[1],midX+1,b,c,midY
		#define S2 T[x].son[2],a,midY+1,midX,d
		#define S3 T[x].son[3],midX+1,midY+1,c,d
		I void NW(int& x,CI a,CI b,CI c,CI d){!x&&(T[x=++cnt].sz=(c-a+1)*(d-b+1),
		T[x].T=1,T[x].S=T[x].son[0]=T[x].son[1]=T[x].son[2]=T[x].son[3]=0);}
		#define PD(x,a,b,c,d) (x&&T[x].sz>1&&(T[x].S||T[x].T>1)&&(\
		T[x].son[0]&&(T[T[x].son[0]].T=1LL*T[T[x].son[0]].T*T[x].T%P,T[T[x].son[0]].S=1LL*T[T[x].son[0]].S*T[x].T%P,(T[T[x].son[0]].S+=T[x].S)%=P,0),\
		T[x].son[1]&&(T[T[x].son[1]].T=1LL*T[T[x].son[1]].T*T[x].T%P,T[T[x].son[1]].S=1LL*T[T[x].son[1]].S*T[x].T%P,(T[T[x].son[1]].S+=T[x].S)%=P,0),\
		T[x].son[2]&&(T[T[x].son[2]].T=1LL*T[T[x].son[2]].T*T[x].T%P,T[T[x].son[2]].S=1LL*T[T[x].son[2]].S*T[x].T%P,(T[T[x].son[2]].S+=T[x].S)%=P,0),\
		T[x].son[3]&&(T[T[x].son[3]].T=1LL*T[T[x].son[3]].T*T[x].T%P,T[T[x].son[3]].S=1LL*T[T[x].son[3]].S*T[x].T%P,(T[T[x].son[3]].S+=T[x].S)%=P,0),\
		T[x].S=0,T[x].T=1))
	public:
		I void B(int& x,CI a,CI b,CI c,CI d,CI Qx,CI Qy){//预先建点
			NW(x,a,b,c,d);if(a==c&&b==d) return ;
			Qx<=midX&&Qy<=midY&&(B(S0,Qx,Qy),0),
			Qx>midX&&Qy<=midY&&(B(S1,Qx,Qy),0),
			Qx<=midX&&Qy>midY&&(B(S2,Qx,Qy),0),
			Qx>midX&&Qy>midY&&(B(S3,Qx,Qy),0);
		}
		I void Add(int& x,CI a,CI b,CI c,CI d,CI Qa,CI Qb,CI Qc,CI Qd,CI v){//矩阵加
			if(!x) return ;if(Qa<=a&&Qb<=b&&c<=Qc&&d<=Qd) return void((T[x].S+=v)%=P);
			PD(x,a,b,c,d),Qa<=midX&&Qb<=midY&&(Add(S0,Qa,Qb,min(Qc,midX),min(Qd,midY),v),0),
			Qc>midX&&Qb<=midY&&(Add(S1,max(Qa,midX+1),Qb,Qc,min(Qd,midY),v),0),
			Qa<=midX&&Qd>midY&&(Add(S2,Qa,max(Qb,midY+1),min(Qc,midX),Qd,v),0),
			Qc>midX&&Qd>midY&&(Add(S3,max(Qa,midX+1),max(Qb,midY+1),Qc,Qd,v),0);
		}
		I void Mul(int& x,CI a,CI b,CI c,CI d,CI Qa,CI Qb,CI Qc,CI Qd,CI v){//矩阵乘
			if(!x) return ;if(Qa<=a&&Qb<=b&&c<=Qc&&d<=Qd) return T[x].T=1LL*T[x].T*v%P,void(T[x].S=1LL*T[x].S*v%P);
			PD(x,a,b,c,d),Qa<=midX&&Qb<=midY&&(Mul(S0,Qa,Qb,min(Qc,midX),min(Qd,midY),v),0),
			Qc>midX&&Qb<=midY&&(Mul(S1,max(Qa,midX+1),Qb,Qc,min(Qd,midY),v),0),
			Qa<=midX&&Qd>midY&&(Mul(S2,Qa,max(Qb,midY+1),min(Qc,midX),Qd,v),0),
			Qc>midX&&Qd>midY&&(Mul(S3,max(Qa,midX+1),max(Qb,midY+1),Qc,Qd,v),0);
		}
		I int Q(int &x,CI a,CI b,CI c,CI d,CI Qx,CI Qy){//单点查
			if(!x) return 0;if(a==c&&b==d) return T[x].S;
			RI S=0;return PD(x,a,b,c,d),Qx<=midX&&Qy<=midY&&((S+=Q(S0,Qx,Qy))%=P),
			Qx>midX&&Qy<=midY&&((S+=Q(S1,Qx,Qy))%=P),
			Qx<=midX&&Qy>midY&&((S+=Q(S2,Qx,Qy))%=P),
			Qx>midX&&Qy>midY&&((S+=Q(S3,Qx,Qy))%=P),S;
		}
}S;
int main(){
	RI i;for(read(n,m),i=1;i<=m;i++) read(q[i].opt),q[i].opt<=2&&(read(q[i].l,q[i].r),0),read(q[i].x),A[i]=m;
	for(i=m;i>=1;i--) q[i].opt==4&&(A[q[i].x]=i);//先找出每个修改操作的生效区间
	for(i=1;i<=m;i++) if(q[i].opt==3) S.B(rt,1,1,m,n,i,q[i].x);//预先建点
	for(i=1;i<=m;i++) if(q[i].opt==1) S.Add(rt,1,1,m,n,i,q[i].l,A[i],q[i].r,q[i].x);
	else if(q[i].opt==2) S.Mul(rt,1,1,m,n,i,q[i].l,A[i],q[i].r,q[i].x);
	else if(q[i].opt==3) writeln(S.Q(rt,1,1,m,n,i,q[i].x));return 0;
}
```



---

## 作者：lhm_ (赞：1)

因为有撤销操作，所以修改操作可能会只会存在一段时间，因此把时间看作一维，被修改的序列看作一维。

可以把操作都离线下来，对于每个修改操作，就是在二维平面上对一个矩形进行修改，询问操作，就是查询单点权值。

具体实现时，可以对所有询问操作查询的单点建$K-D\ Tree$，然后在$K-D\ Tree$上矩形修改即可。

$code:$

```cpp
#include<bits/stdc++.h>
#define maxn 600010
#define p 998244353
using namespace std;
typedef long long ll;
template<typename T> inline void read(T &x)
{
    x=0;char c=getchar();bool flag=false;
    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    if(flag)x=-x;
}
int n,m,root,tot,type,cnt;
ll ans;
struct node
{
    int opt,u,d,pos;
    ll v;
}q[maxn];
struct KD_tree
{
    int d[2],mi[2],ma[2],ls,rs;
    ll val,add,mul;
}t[maxn],dat[maxn];
bool cmp(const KD_tree &a,const KD_tree &b)
{
    return a.d[type]<b.d[type];
}
void pushup(int cur)
{
    int ls=t[cur].ls,rs=t[cur].rs;
    for(int i=0;i<=1;++i)
    {
        t[cur].ma[i]=t[cur].mi[i]=t[cur].d[i];
        if(ls)
        {
            t[cur].ma[i]=max(t[cur].ma[i],t[ls].ma[i]);
            t[cur].mi[i]=min(t[cur].mi[i],t[ls].mi[i]);
        }
        if(rs)
        {
            t[cur].ma[i]=max(t[cur].ma[i],t[rs].ma[i]);
            t[cur].mi[i]=min(t[cur].mi[i],t[rs].mi[i]);
        }
    }
}
void pushadd(int cur,ll v)
{
    t[cur].val=(t[cur].val+v)%p,t[cur].add=(t[cur].add+v)%p;
}
void pushmul(int cur,ll v)
{
    t[cur].val=t[cur].val*v%p,t[cur].add=t[cur].add*v%p,t[cur].mul=t[cur].mul*v%p;
}
void pushdown(int cur)
{
    int ls=t[cur].ls,rs=t[cur].rs;
    if(t[cur].mul!=1) pushmul(ls,t[cur].mul),pushmul(rs,t[cur].mul),t[cur].mul=1;
    if(t[cur].add) pushadd(ls,t[cur].add),pushadd(rs,t[cur].add),t[cur].add=0;
}
void build(int l,int r,int k,int &cur)
{
    cur=++tot,type=k;
    int mid=(l+r)>>1;
    nth_element(dat+l+1,dat+mid+1,dat+r+1,cmp);
    t[cur]=dat[mid],t[cur].mul=1;
    if(l<mid) build(l,mid-1,k^1,t[cur].ls);
    if(r>mid) build(mid+1,r,k^1,t[cur].rs);
    pushup(cur);
}
bool out(int cur,int u,int d,int l,int r)
{
    return u>t[cur].ma[0]||d<t[cur].mi[0]||l>t[cur].ma[1]||r<t[cur].mi[1];
}
bool in(int cur,int u,int d,int l,int r)
{
    return u<=t[cur].mi[0]&&d>=t[cur].ma[0]&&l<=t[cur].mi[1]&&r>=t[cur].ma[1];
}
bool check(int cur,int u,int d,int l,int r)
{
    return u<=t[cur].d[0]&&d>=t[cur].d[0]&&l<=t[cur].d[1]&&r>=t[cur].d[1];
}
void modify_add(int cur,int u,int d,int l,int r,ll v)
{
    if(out(cur,u,d,l,r)) return;
    if(in(cur,u,d,l,r))
    {
        pushadd(cur,v);
        return;
    }
    if(check(cur,u,d,l,r)) t[cur].val=(t[cur].val+v)%p;
    int ls=t[cur].ls,rs=t[cur].rs;
    pushdown(cur);
    if(ls) modify_add(ls,u,d,l,r,v);
    if(rs) modify_add(rs,u,d,l,r,v);
}
void modify_mul(int cur,int u,int d,int l,int r,ll v)
{
    if(out(cur,u,d,l,r)) return;
    if(in(cur,u,d,l,r))
    {
        pushmul(cur,v);
        return;
    }
    if(check(cur,u,d,l,r)) t[cur].val=t[cur].val*v%p;
    int ls=t[cur].ls,rs=t[cur].rs;
    pushdown(cur);
    if(ls) modify_mul(ls,u,d,l,r,v);
    if(rs) modify_mul(rs,u,d,l,r,v);
}
void query(int cur,int x,int y)
{
    if(x>t[cur].ma[0]||x<t[cur].mi[0]||y>t[cur].ma[1]||y<t[cur].mi[1]) return;
    if(x==t[cur].d[0]&&y==t[cur].d[1])
    {
        ans=t[cur].val;
        return;
    }
    int ls=t[cur].ls,rs=t[cur].rs;
    pushdown(cur);
    if(ls) query(ls,x,y);
    if(rs) query(rs,x,y);
}
int main()
{
    read(n),read(m);
    for(int i=1;i<=m;++i)
    {
        read(q[i].opt);
        if(q[i].opt<=2) read(q[i].u),read(q[i].d),read(q[i].v);
        if(q[i].opt==3) read(q[i].pos),dat[++cnt].d[0]=q[i].pos,dat[cnt].d[1]=i;
        if(q[i].opt==4) read(q[i].pos),q[q[i].pos].pos=i;
    }
    for(int i=1;i<=m;++i)
        if(q[i].opt<=2&&!q[i].pos)
            q[i].pos=m;
    build(1,cnt,0,root);
    for(int i=1;i<=m;++i)
    {
        if(q[i].opt==1) modify_add(root,q[i].u,q[i].d,i,q[i].pos,q[i].v);
        if(q[i].opt==2) modify_mul(root,q[i].u,q[i].d,i,q[i].pos,q[i].v);
        if(q[i].opt==3) query(root,q[i].pos,i),printf("%lld\n",ans);
    }
    return 0;
} 
```


---

## 作者：Great_Influence (赞：1)

其实这道题是有$O(m\log^2n)$的做法的。

可以按照前面孔爷的说法，将询问离线，然后变成矩形修改。

这时候，如果用四叉树换掉k-d tree的话，复杂度就会由单次 $O(\sqrt n)$变成单次$O(\log^2n)$。

注意一下空间问题，将需要的点预处理出来就可以了。

代码:
```cpp

#include<bits/stdc++.h>
#define Rep(i,a,b) for(register int i=(a);i<=(b);++i)
#define Repe(i,a,b) for(register int i=(a);i>=(b);--i)
#define rep(i,a,b) for(register int i=(a);i<(b);++i)
#define pb push_back
#define mx(a,b) (a>b?a:b)
#define mn(a,b) (a<b?a:b)
typedef unsigned long long uint64;
typedef unsigned int uint32;
typedef long long ll;
using namespace std;

namespace IO
{
    const uint32 Buffsize=1<<15,Output=1<<24;
    static char Ch[Buffsize],*S=Ch,*T=Ch;
    inline char getc()
    {
        return((S==T)&&(T=(S=Ch)+fread(Ch,1,Buffsize,stdin),S==T)?0:*S++);
    }
    static char Out[Output],*nowps=Out;
    
    inline void flush(){fwrite(Out,1,nowps-Out,stdout);nowps=Out;}

    template<typename T>inline void read(T&x)
    {
        x=0;static char ch;T f=1;
        for(ch=getc();!isdigit(ch);ch=getc())if(ch=='-')f=-1;
        for(;isdigit(ch);ch=getc())x=x*10+(ch^48);
        x*=f;
    }

    template<typename T>inline void write(T x,char ch='\n')
    {
        if(!x)*nowps++='0';
        if(x<0)*nowps++='-',x=-x;
        static uint32 sta[111],tp;
        for(tp=0;x;x/=10)sta[++tp]=x%10;
        for(;tp;*nowps++=sta[tp--]^48);
        *nowps++=ch;
    }
}
using namespace IO;

void file(void)
{
    FILE*DSD=freopen("water.in","r",stdin);
    FILE*CSC=freopen("water.out","w",stdout);
}

const int MAXN=1.5e5+7;

const int mod=998244353;

static int n,m,tt,ee;

static struct oper
{
	int opt,l,r,d,st,ed;
}p[MAXN];

static int ids[MAXN];

static struct ask{int u,v;}q[MAXN];

inline void init()
{
	read(n),read(m);
	static int opt,u;
	static int cnt=0,lst=0;
	Rep(i,1,m)
	{
		read(opt);
		if(opt<=2)lst=0,ids[i]=++tt,p[tt].opt=opt,read(p[tt].l),read(p[tt].r),read(p[tt].d),p[tt].st=cnt+1,p[tt].ed=m;
		else if(opt==3)
		{
			if(!lst)++cnt;
			q[++ee].v=cnt,read(q[ee].u);
			lst=1;
		}
		else lst=0,read(u),p[ids[u]].ed=cnt;
	}
	Rep(i,1,tt)if(p[i].ed>cnt)p[i].ed=cnt;
	m=cnt;
	//Rep(i,1,tt)if(p[i].st<=1)cerr<<p[i].l<<' '<<p[i].r<<' '<<p[i].d<<endl;
}

namespace Segment_Tree
{
	const int NODE=MAXN*30;

	int add[NODE],mul[NODE],e,son[NODE][2][2];

	void preget(int&h,int l0,int r0,int l1,int r1,int u,int v)
	{
		if(l0>r0||l1>r1)return;
		if(!h)mul[h=++e]=1;
		if(l0==r0&&l1==r1)return;
		int md0=(l0+r0)>>1,md1=(l1+r1)>>1;
		if(u<=md0)
		{
			return v<=md1?preget(son[h][0][0],l0,md0,l1,md1,u,v):
			preget(son[h][0][1],l0,md0,md1+1,r1,u,v);
		}
		else
		{
			return v<=md1?preget(son[h][1][0],md0+1,r0,l1,md1,u,v):
			preget(son[h][1][1],md0+1,r0,md1+1,r1,u,v);
		}
	}

	inline int ad(int u,int v){return(u+=v)>=mod?u-mod:u;}

	inline void pushdown(int u)
	{
		register int dir,cur;
		if(mul[u]^1)
		{
			cur=mul[u],mul[u]=1;
			Rep(i,0,1)Rep(j,0,1)if(dir=son[u][i][j])
			{
				add[dir]=(uint64)add[dir]*cur%mod;
				mul[dir]=(uint64)mul[dir]*cur%mod;
			}
		}
		if(add[u])
		{
			cur=add[u],add[u]=0;
			Rep(i,0,1)Rep(j,0,1)if(dir=son[u][i][j])
				add[dir]=ad(add[dir],cur);
		}
	}

	#define other u0,v0,u1,v1,delt

	void pls(int h,int l0,int r0,int l1,int r1,int u0,int v0,int u1,int v1,int delt)
	{
		if(!h)return;
		if(u0<=l0&&r0<=v0&&u1<=l1&&r1<=v1){add[h]=ad(add[h],delt);return;}
		int md0=(l0+r0)>>1,md1=(l1+r1)>>1;
		pushdown(h);
		if(u0<=md0)
		{
			if(u1<=md1)pls(son[h][0][0],l0,md0,l1,md1,other);
			if(v1>md1)pls(son[h][0][1],l0,md0,md1+1,r1,other);
		}
		if(v0>md0)
		{
			if(u1<=md1)pls(son[h][1][0],md0+1,r0,l1,md1,other);
			if(v1>md1)pls(son[h][1][1],md0+1,r0,md1+1,r1,other);
		}
	}

	void tim(int h,int l0,int r0,int l1,int r1,int u0,int v0,int u1,int v1,int delt)
	{
		if(!h)return;
		if(u0<=l0&&r0<=v0&&u1<=l1&&r1<=v1)
		{add[h]=(uint64)add[h]*delt%mod,mul[h]=(uint64)mul[h]*delt%mod;return;}
		int md0=(l0+r0)>>1,md1=(l1+r1)>>1;
		pushdown(h);
		if(u0<=md0)
		{
			if(u1<=md1)tim(son[h][0][0],l0,md0,l1,md1,other);
			if(v1>md1)tim(son[h][0][1],l0,md0,md1+1,r1,other);
		}
		if(v0>md0)
		{
			if(u1<=md1)tim(son[h][1][0],md0+1,r0,l1,md1,other);
			if(v1>md1)tim(son[h][1][1],md0+1,r0,md1+1,r1,other);
		}
	}

	int query(int h,int l0,int r0,int l1,int r1,int u,int v)
	{
		if(!h)return 0;
		if(l0==r0&&l1==r1)return add[h];
		int md0=(l0+r0)>>1,md1=(l1+r1)>>1;
		pushdown(h);
		if(u<=md0)
		{
			return v<=md1?query(son[h][0][0],l0,md0,l1,md1,u,v):
			query(son[h][0][1],l0,md0,md1+1,r1,u,v);
		}
		else
		{
			return v<=md1?query(son[h][1][0],md0+1,r0,l1,md1,u,v):
			query(son[h][1][1],md0+1,r0,md1+1,r1,u,v);
		}
	}
}
using namespace Segment_Tree;

static int rt;

inline void solve()
{
	static int ps=1;
	Rep(i,1,ee)preget(rt,1,n,1,m,q[i].u,q[i].v);
	Rep(i,1,ee)
	{
		while(ps<=tt&&p[ps].st<=q[i].v)
		{
			if(p[ps].st<=p[ps].ed)
		p[ps].opt==1?pls(rt,1,n,1,m,p[ps].l,p[ps].r,p[ps].st,p[ps].ed,p[ps].d):
		tim(rt,1,n,1,m,p[ps].l,p[ps].r,p[ps].st,p[ps].ed,p[ps].d);
			++ps;
		}
		write(query(rt,1,n,1,m,q[i].u,q[i].v));
	}
	flush();
}

int main()
{
	init();
	solve();
	return 0;
}

```

---


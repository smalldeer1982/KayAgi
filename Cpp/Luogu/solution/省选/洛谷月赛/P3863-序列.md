# 序列

## 题目描述

给定一个长度为 $n$ 的序列，给出 $q$ 个操作，形如：

$1~l~r~x$ 表示将序列下标介于 $[l,r]$ 的元素加上 $x$ （请注意，$x$ 可能为负）

$2~p~y$ 表示查询 $a_p$ 在过去的多少秒时间内不小于 $y$ （不包括这一秒，细节请参照样例）

开始时为第 $0$ 秒，第 $i$ 个操作发生在第 $i$ 秒。


## 说明/提示

样例一说明：位置 $1$ 在第 $0$ 秒到第 $3$ 秒的值为 $1,1,-2,-2$。对于第一个查询，第 $0$ 到 $1-1=0$ 秒中时间不小于 $2$；对于第二个查询，第 $0$ 到第 $3-1=2$ 秒时间不小于 $1$，分别为第 $0$ 秒，第 $1$ 秒。


对于 $30\%$ 的数据，保证 $n,q \leq 1000$

对于 $70\%$ 的数据，保证 $n,q \leq 50000$

对于 $100\%$ 的数据，保证 $2 \leq n,q \leq 100000$， $1 \leq l \leq r \leq n$， $1 \leq p \leq n$，$-10^9 \leq x,y,a_i \leq 10^9$


## 样例 #1

### 输入

```
3 3
1 3 5
2 1 2
1 1 2 -3
2 1 1```

### 输出

```
0
2```

# 题解

## 作者：Meatherm (赞：37)

如果只有一个数，似乎就很好维护了。

维护每一个时刻这个数加上的值。查询某一段时间里大于某个值的时间数量。将时间分块就可以做了。

但如果是 $n$ 个数呢？如果在线搞的话，似乎并不能很好的维护。那么离线下来，给询问排序，依次处理就好了。

那怎么处理区间修改操作呢？观察到如果在 $t$ 时刻给 $[l,r]$ 加上 $v$，会对处理 $[l,r]$ 中每一个数时都造成同样的影响。所以将每一个修改操作分成两部分：

- 第一部分，在处理第 $l$ 个数的时候将时刻 $[t,m]$ 都加上 $v$。
- 第二部分，在处理第 $r+1$ 个数的时候将时刻 $[t,m]$ 都减去 $v$，抵消影响（因为这个操作不会对 $r+1$ 及其之后的数造成影响，故减去）。

（是不是感觉有点像扫描线呢）

这样我们就可以得到每一个数每个时刻被加上的值。

处理第 $i$ 个数第 $t$ 秒的询问时，分块查询 $[0,t-1]$ 有多少个时刻的值大于等于 $y - a_i$ 即可。

注意到最后输出结果时是按照输入顺序输出，所以还要处理一下询问的顺序。

```cpp
# include <bits/stdc++.h>
# define rr register
# define int long long
const int N=100010;
struct Line{//修改
	int x;
	int Time;
	int v;
}a[N<<1];
struct Asker{//查询
	int x,v; 
	int Time;
	int Index;// 记录是第几次询问
}ask[N];
int cnta,cntb;//修改数量 & 查询数量
int ans[N]; // 存储每一次询问的答案
int val[N];
int n,m;
/* 分块部分 */
int tseque[N];
int fseque[N];
int add[N];
int Kuai[N];
int KL[N],KR[N];
/* 分块部分 */
int siz;// 要分的块大小
inline int read(void){
	int res,f=1;
	char c;
	while((c=getchar())<'0'||c>'9')
		if(c=='-')f=-1;
	res=c-48;
	while((c=getchar())>='0'&&c<='9')	
		res=res*10+c-48;
	return res*f;		
}
inline bool cmp_Line(Line X,Line Y){//给修改排序
	return X.x!=Y.x?X.x<Y.x:X.Time<Y.Time;
}
inline bool cmp_Ask(Asker X,Asker Y){//给询问排序
	return X.x!=Y.x?X.x<Y.x:X.Time<Y.Time;
}
inline bool cmp_Integer(int X,int Y){//为了给块内元素从大到小排序用的
	return X>Y;
}
inline void resort(int x){//每次修改之后，块内元素需要重新排序
	for(rr int i=KL[x];i<=KR[x];++i)
		fseque[i]=tseque[i];
	std::sort(fseque+KL[x],fseque+KR[x]+1,cmp_Integer);
	return;	
}
inline void change(int l,int r,int v){// 分块修改操作
	l=std::max(l,0ll);
	r=std::min(r,m);
	if(Kuai[l]==Kuai[r]){
		for(rr int i=l;i<=r;++i){
			tseque[i]+=v;
		}
		resort(Kuai[l]);
		return;
	}
	for(rr int i=l;i<=KR[Kuai[l]];++i)
		tseque[i]+=v;
	resort(Kuai[l]);
	for(rr int i=r;i>=KL[Kuai[r]];--i)
		tseque[i]+=v;
	resort(Kuai[r]);
	for(rr int i=Kuai[l]+1;i<=Kuai[r]-1;++i){
		add[i]+=v;
	}
	return;
}
inline int query(int l,int r,int v){// 分块查询操作
	int cnt=0;
	if(Kuai[l]==Kuai[r]){
		for(rr int i=l;i<=r;++i)
			if(tseque[i]+add[Kuai[i]]>=v)
				++cnt;
		return cnt;		
	}
	for(rr int i=l;i<=KR[Kuai[l]];++i)
		if(tseque[i]+add[Kuai[i]]>=v)
			++cnt;
	for(rr int i=r;i>=KL[Kuai[r]];--i)
		if(tseque[i]+add[Kuai[i]]>=v)
			++cnt;
	for(rr int i=Kuai[l]+1;i<=Kuai[r]-1;++i){
		int L=KL[i],R=KR[i],ans=KL[i]-1;
		while(L<=R){
			int mid=(L+R)>>1;
			if(fseque[mid]+add[Kuai[mid]]>=v){
				ans=mid;
				L=mid+1;
			}else{
				R=mid-1;
			}
		}
		cnt+=(ans-KL[i])+1;
	}
	return cnt;
}
# undef int
int main(void){
# define int long long
	n=read(),m=read();
	for(rr int i=1;i<=n;++i){
		val[i]=read();
	}
	for(rr int i=1,opt;i<=m;++i){
		opt=read();
		if(opt==1){
			int l=read(),r=read(),v=read();
			a[++cnta].x=l;
			a[cnta].Time=i;
			a[cnta].v=v;
			a[++cnta].x=r+1;
			a[cnta].Time=i;
			a[cnta].v=-v;
		}else{
			int p=read(),y=read();
			ask[++cntb].x=p;
			ask[cntb].Index=cntb;
			ask[cntb].v=y;
			ask[cntb].Time=i;
		}
	}
	std::sort(a+1,a+1+cnta,cmp_Line);
	std::sort(ask+1,ask+1+cntb,cmp_Ask);// 读入、存储并排序每一个操作
	siz=sqrt(m);
	for(rr int i=0;i<=m;++i){
		Kuai[i]=i/siz+1;
	}
	for(rr int i=1;(i-1)*siz<=m;++i){
		KL[i]=(i-1)*siz;
		KR[i]=std::min(i*siz-1,m);
	}
	int now=1;
	for(rr int i=1;i<=cntb;++i){
		while((a[now].x<ask[i].x||(a[now].x==ask[i].x&&a[now].Time<ask[i].Time))&&now<=cnta){
			change(a[now].Time,m,a[now].v);
			++now;
		}
		ans[ask[i].Index]=query(0,ask[i].Time-1,ask[i].v-val[ask[i].x]);
	}
	for(rr int i=1;i<=cntb;++i)
		printf("%lld\n",ans[i]);
	return 0;
} 
```

---

## 作者：E_huan (赞：21)

## 分块



------------

前言：蒟蒻很少写分块，本题应该不算太毒瘤但是想了挺久没想出来，看完题解思路大概懂了，但不太会实现，并且被超长代码吓住（题解代码用 VScode 自带的格式化之后大多 $200+$ 行，少的也 $100+$ 行），蒟蒻琢磨了挺久自己实现了，发现加上详细注释也只有 $60+$ 行（格式化之后 $80+$ 行）。所以作此题解希望可以帮到和我一样对实现有疑问的人。


------------

首先，带修也可以离线，但是会从一维（序列维度）变成二维（序列、时间维度），多了时间维度。


如果只是实现维护朴实的二维信息（加、减、求和...）那很简单，最简单的扫描线即可，选择一个维度扫过去，另外一个维护用数据结构维护。


但是这里要查询大于等于 $y$ 的值出现次数，即 $y$ 在历史上出现的所有值中的排名。
这个比较麻烦，还好本题时间限制宽松，仍然是扫描线，“数据结构”可以使用根号甚至根号对数做法。在序列维度桶排序，修改、查询时间维度（前面说的“用数据结构维护”，这里用分块）。分块加排序 $O(n\,\sqrt{n} \, \log n)$，具体实现在代码有详细注释。

代码实现（详细注释且不太压行超短啊！）：
```cpp

#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=300010,B=333;
int n,q,ans[N],L[N],R[N],id[N];
ll tag[N];//每个块的区间加懒标记
struct A{
    int pos;//pos是原本的位置，存下才能判断它需不需要修改/查询(每个块内部会打乱顺序的）
    ll v;//V是值
    bool operator<(const A &t){
        if(v!=t.v) return v<t.v;
        else return pos<t.pos;
    }
}a[N];
struct node{int t,pos,x;};//t=1:修改，t=2:查询  pos是修改/查询的时间维度上位置，X是增加的值/查询的值
vector<node> Do[N];//（序列维度）桶排序
inline void modify(int l,int x)
{
    for(int i=L[id[l]];i<=R[id[l]];i++)//块内
        if(a[i].pos>=l) //属于[l,q]
            a[i].v+=x;
    sort(a+L[id[l]],a+R[id[l]]+1);//注意这个序列是时间，所以排序是可以的
    for(int i=id[l]+1;i<=(q-1)/B+1;i++) tag[i]+=x;
}
inline int query(int r,int x)
{
    int ans=0;
    for(int i=L[id[r]];i<=R[id[r]];i++)
        if(a[i].pos<=r&&a[i].v+tag[id[r]]>=x)
            ans++;
    for(int i=1;i<id[r];i++) 
        ans+=R[i]-(lower_bound(a+L[i],a+R[i]+1,A({0,x-tag[i]}))-a)+1;
    return ans;
}
int main()
{
    memset(ans,-1,sizeof ans);//标记一下没有询问，否则输出的时候不知道0是这里根本没有询问还是答案是0
    scanf("%d%d",&n,&q); 
    q++;//把所有修改询问向后移一个，把Q=1当作初始值
    for(int i=1,a;i<=n;i++)
    {
        scanf("%d",&a);
        Do[i].push_back({1,1,a});
        Do[i+1].push_back({1,1,-a});//这两行相当于只改[i,i]
    }
    for(int i=2,op,l,r,x,p,y;i<=q;i++)
    {
        scanf("%d",&op);
        if(op==1) 
        {
            scanf("%d%d%d",&l,&r,&x);
            Do[l].push_back({1,i,x});
            Do[r+1].push_back({1,i,-x});//这两行相当于改[l,r]
        }
        else scanf("%d%d",&p,&y),Do[p].push_back({2,i,y});
    }
    for(int i=1;i<=q;i++) a[i]={i,0},id[i]=(i-1)/B+1;
    for(int i=1;i<=(q-1)/B+1;i++) L[i]=B*(i-1)+1,R[i]=min(B*i,q);
    for(int i=1;i<=n;i++)
        for(node t:Do[i])//操作序列上的每个位置
        {
            if(t.t==1) modify(t.pos,t.x);//修改[t.pos,q]
            else ans[t.pos]=query(t.pos-1,t.x);//查询[1,t.pos-1]
        }
    for(int i=2;i<=q;i++) if(~ans[i]) printf("%d\n",ans[i]);
    return 0;
}
```


---

## 作者：pitiless0514 (赞：18)

一道挺不错的题目。

考虑我们将最终每个时间的序列写出来，容易发现这个东西形成了一个二维平面，如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/9pt2o9hj.png)

然后容易陷入一个误区，可能会去维护对于每个时刻的序列情况，然后直接回答。

但是其实可以考虑另一种方式，考虑查询和修改的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/z6zqrsx8.png)

你发现查询是查一个区间，但是修改是修改一个矩形。

所以可以直接考虑离线询问，然后扫描线扫序列，然后数据结构维护时间维。

然后对于一个修改，可以将他拆成两个形如 $(l,t,val)$ 和 $(r + 1,t,-val)$ 的形式。

然后就在扫到 $l$ 的时候对维护的时间维上 $t \sim q$ 的范围整体加 $val$ 然后扫到 $r + 1$ 时对 $t \sim q$ 的范围整体加上 $-val$ 消除贡献。

然后就是一个区间加区间查询排名问题，分块维护即可。

```cpp
// 德丽莎你好可爱德丽莎你好可爱德丽莎你好可爱德丽莎你好可爱德丽莎你好可爱
// Problem: P3863 序列
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P3863
// Memory Limit: 500 MB
// Time Limit: 2000 ms
// The Author : Pitiless0514
// 
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h>
#define int long long
using namespace std;
namespace IO {
	int len = 0;
	char ibuf[(1 << 20) + 1], *iS, *iT, out[(1 << 25) + 1];
	#define gh()                                                                   \
	  (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, (1 << 20) + 1, stdin),         \
	   (iS == iT ? EOF : *iS++) : *iS++)
	inline int read() {
	  char ch = gh();
	  int x = 0;
	  char t = 0;
	  while (ch < '0' || ch > '9') t |= ch == '-', ch = gh();
	  while (ch >= '0' && ch <= '9') x = x * 10 + (ch ^ 48), ch = gh();
	  return t ? -x : x;
	}
	inline void putc(char ch) { out[len++] = ch; }
	template <class T> inline void write(T x) {
	  if (x < 0) putc('-'), x = -x;
	  if (x > 9) write(x / 10);
	  out[len++] = x % 10 + 48;
	}
	string getstr(void) {
	  string s = "";
	  char c = gh();
	  while (c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == EOF) c = gh();
	  while (!(c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == EOF))s.push_back(c), c = gh();
	  return s;
	}
	void putstr(string str, int begin = 0, int end = -1) {
	  if (end == -1)
	    end = str.size();
	  for (int i = begin; i < end; i++)
	    putc(str[i]);
	  return;
	}
	inline void flush() {
	  fwrite(out, 1, len, stdout);
	  len = 0;
	}
} // namespace IO by Macesuted
using IO::flush;
using IO::getstr;
using IO::putc;
using IO::putstr;
using IO::read;
using IO::write;
const int N = 2e6;
int n, siz = 360, bel, q, num, cnt, ans[N], a[N], pos[N], LL[N], RR[N], s[N], t[N], tag[N];
struct update { 
  int x, tim, val; 
  update(int xx = 0,int yy = 0,int zz = 0) {
    x = xx, tim = yy, val = zz;
  }
}q1[N];
struct ask { 
  int x, tim, val, id; 
  ask(int xx = 0,int yy = 0,int zz = 0,int uu = 0) {
    x = xx, tim = yy, val = zz, id = uu;
  }
}q2[N];
int cmp1(update x, update y) { return (x.x != y.x) ? x.x < y.x : x.tim < y.tim; }
int cmp2(ask x, ask y) { return (x.x != y.x) ? x.x < y.x : x.tim < y.tim; }
void change(int l,int r,int k) {
  l = max(l, 0ll);
	r = min(r, q);
  int pl = pos[l], pr = pos[r];
  if(pl == pr) {
    for(int i = l; i <= r; i++) s[i] += k;
    int L = LL[pl], R = RR[pl];
    for(int i = L; i <= R; i++) t[i] = s[i];
    sort(t + L, t + R + 1);
    reverse(t + L, t + R + 1);
  }  else{
    for(int i = pl + 1; i <= pr - 1; i++) tag[i] += k;
    int L = LL[pl], R = RR[pl];
    for(int i = l; i <= R; i++) s[i] += k;
    for(int i = L; i <= R; i++) t[i] = s[i];
    sort(t + L, t + R + 1);
    reverse(t + L, t + R + 1);
    L = LL[pr], R = RR[pr];
    for(int i = L; i <= r; i++) s[i] += k;
    for(int i = L; i <= R; i++) t[i] = s[i];
    sort(t + L, t + R + 1);
    reverse(t + L, t + R + 1);
  }
}
int check(int l,int r,int k) {
  int pl = pos[l], pr = pos[r], cnt = 0;
  if(pl == pr) {
    for(int i = l; i <= r; i++) if(s[i] + tag[pl] >= k) cnt++;
    return cnt;
  }  else {
    for(int i = pl + 1; i <= pr - 1; i++) {
      int l1 = LL[i], r1 = RR[i];
      while(l1 < r1) {
        int mid = (l1 + r1) / 2 + 1;
        if(t[mid] + tag[i] >= k) l1 = mid;
        else r1 = mid - 1;
      }
      if(t[l1] + tag[i] >= k) cnt += l1 - LL[i] + 1;
    }
    int L = LL[pr], R = RR[pl];
    for(int i = l; i <= R; i++) if(s[i] + tag[pl] >= k) cnt++;
    for(int i = L; i <= r; i++) if(s[i] + tag[pr] >= k) cnt++;
    return cnt;
  }
}
signed main () {
  n = read(), q = read();
  for(int i = 1; i <= n; i++) a[i] = read();
  for(int i = 1; i <= q; i++) {
    int op = read(), l, r, x;
    if(op == 1) {
      l = read(), r = read(), x = read();
      ++cnt; q1[cnt] = update(l, i, x);
      ++cnt; q1[cnt] = update(r + 1, i, -x);
    }  else {
      l = read(), x = read();
      ++num; q2[num] = ask(l, i, x, num);
    }
  }
  bel = (q + 1 - 1) / siz + 1;
  for(int i = 1; i <= bel; i++) {
    LL[i] = (i - 1) * siz + 1;
    RR[i] = min(i * siz, q + 1);
    for(int j = LL[i]; j <= RR[i]; j++) {
      pos[j] = i;
    }
  }
  sort(q1 + 1, q1 + cnt + 1, cmp1);
  sort(q2 + 1, q2 + num + 1, cmp2);
  memset(ans, -1, sizeof(ans));
  for(int i = 1, j = 1; i <= num; i++) {
    while( (q1[j].x < q2[i].x || (q1[j].x == q2[i].x && q1[j].tim < q2[i].tim) ) && j <= cnt) {
      change(q1[j].tim + 1, q + 1, q1[j].val);
      ++j;
    }
    ans[q2[i].id] = check(1, q2[i].tim, q2[i].val - a[q2[i].x]);
  }
  for(int i = 1; i <= q; i++) {
    if(ans[i] != -1) write(ans[i]), putc('\n');
  }
  flush();
  return 0;
}

```

---

## 作者：tommymio (赞：16)

神奇的题目，刷题单的时候做到了这道题。

不妨先想想只有一个数的情况，我们可以将不同时刻的 $a_i$ 写成一个序列。那么我们需要支持区间询问 $[0,time-1]$ 不小于 $lim$ 的数个数和区间增量 $[l,r]$。用分块搞一搞就好了，时间复杂度为 $O(n+Q\sqrt Q \log Q)$。

回到本题，我们也可以用相似的方法处理。考虑区间增量这个操作，事实上是在第 $l$ 个数上 $+d$ ，在第 $r+1$ 个数上 $-d$。此处我们所说的加减显然是一种贡献的加减。那么把修改拆成两个，只维护一个对于单个数在时间上的分块，将所有操作按下标为第一关键字，时间为第二关键字排序，如果完成了对 $a_x$ 的操作，即将进行对 $a_y$ 的操作，则将 $[0,m]$ 全部加上 $a_y-a_x$。总时间复杂度为 $O(n+Q\sqrt Q \log Q)$。

可以通过根号平衡继续优化，~~但是我是鸽子~~

代码中约定所有时间全部 $+1$ ，即 $[1,m+1]$ ，为了适应平常分块的写法。写的也很娱乐，看看就好（大雾

```cpp
#include<cstdio>
#include<vector>
#include<cmath>
#include<algorithm>
typedef long long ll;
int block,T,a[100005],ans[100005];
ll c[100005],sum[1005];
std::vector<ll> order[1005];
struct _ask {int opt,t,x,v;}ask[200005];
inline int read() {
	register int x=0,f=1;register char s=getchar();
	while(s>'9'||s<'0') {if(s=='-') f=-1;s=getchar();}
	while(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();}
	return x*f;
}
inline int min(const int &x,const int &y) {return x<y? x:y;} 
inline bool cmp(const _ask &x,const _ask &y) {return x.x!=y.x? x.x<y.x:x.t<y.t;}
inline void BlockModify(int l,int r,int val) {
	int bl=(l-1)/block+1,br=(r-1)/block+1;
	if(bl==br) {
		order[bl].clear();
		for(register int i=l;i<=r;++i) c[i]+=val;
		for(register int i=(bl-1)*block+1;i<=min(bl*block,T);++i) order[bl].push_back(c[i]);
		std::sort(order[bl].begin(),order[bl].end());
	}
	else {
		order[bl].clear(); order[br].clear();
		for(register int i=l;i<=min(bl*block,T);++i) c[i]+=val;
		for(register int i=(br-1)*block+1;i<=r;++i) c[i]+=val;
		for(register int i=(bl-1)*block+1;i<=min(bl*block,T);++i) order[bl].push_back(c[i]);
		for(register int i=(br-1)*block+1;i<=min(br*block,T);++i) order[br].push_back(c[i]);
		std::sort(order[bl].begin(),order[bl].end());
		std::sort(order[br].begin(),order[br].end());
		for(register int i=bl+1;i<=br-1;++i) sum[i]+=val;
	}
}
inline int BlockQuery(int l,int r,int val) {
	int bl=(l-1)/block+1,br=(r-1)/block+1,res=0;
	if(bl==br) {for(register int i=l;i<=r;++i) if(c[i]+sum[bl]>=val) ++res;}
	else {
		for(register int i=l;i<=min(bl*block,T);++i) if(c[i]+sum[bl]>=val) ++res;
		for(register int i=(br-1)*block+1;i<=r;++i) if(c[i]+sum[br]>=val) ++res;
		for(register int i=bl+1;i<=br-1;++i) {int tmp=std::lower_bound(order[i].begin(),order[i].end(),1ll*val-sum[i])-order[i].begin(); res+=order[i].size()-tmp;}
	}
	return res;
}
signed main() {
	int n=read(),num=0; T=read();
	for(register int i=1;i<=n;++i) a[i]=read();
	for(register int Q=1;Q<=T;++Q) {
		int op=read(); ans[Q]=-1;
		if(op==1) {
			int l=read(),r=read(),x=read();
			ask[++num].t=Q;ask[num].opt=1;ask[num].x=l;ask[num].v=x;
			if(r<n) {ask[++num].t=Q;ask[num].opt=1;ask[num].x=r+1;ask[num].v=-x;}
		}
		else {
			int x=read(),lim=read();
			ask[++num].t=Q;ask[num].opt=2;ask[num].x=x;ask[num].v=lim;
		}
	}
	std::sort(ask+1,ask+1+num,cmp);
	int cur=0; ++T; block=sqrt(T);
	for(register int i=1;i<=T;++i) order[(i-1)/block+1].push_back(0);
	for(register int i=1;i<=num;++i) {
		if(cur!=ask[i].x) {BlockModify(1,T,a[ask[i].x]-a[cur]);cur=ask[i].x;}
		if(ask[i].opt==1) {BlockModify(ask[i].t+1,T,ask[i].v);}
		else {ans[ask[i].t]=BlockQuery(1,ask[i].t,ask[i].v);}
	}
	for(register int i=1;i<T;++i) if(ans[i]!=-1) printf("%d\n",ans[i]);
	return 0;
}
```

---

## 作者：logeadd (赞：8)

为什么一篇题解都没有？？？

算法一：
每一次修改时直接复制一遍，查询时暴力查询，复杂度就不分析了，期望得分20分

算法二：
我们考虑每一次询问时能对此次询问产生影响的修改操作有哪一些，我们将所有操作离线，对于每一次修改操作我们按照L为关键字排序，再将询问也按照查询时间排序，这样每一次询问时我们就可以快速找出影响此次答案的修改，然后查询即可。期望得分70分。

算法三：
我们考虑利用数据结构来维护在时间点为x时的状态，我们要一个支持区间修改，区间查询大于等于x数的个数的数据结构，可以想到分块，[见此题](https://www.luogu.org/problemnew/show/P2801)

记每一次操作的左端点为l，右端点为r时间为t，增加量为x

每一次询问的位置为x，时间为t，查询数字为y

考虑到区间修改不会对排序产生影响，我们对于每个块，将块中的数字进行排序，就可以在logn的时间内找出大于等于x的数的个数，边角修改时就直接重构。复杂度为nlogn根号n

我们维护一个分块，以时间为下标，表示在序列的x处，各个时间段的情况，还要用一个集合维护所有应用的操作。每一次操作如果对于x处有影响，就将分块中t到q加上x。当我们分块维护的x转移到y处时，我们需要将操作集合中不会对y产生影响的操作删掉，即将t到q的位置减去x,然后再将会对答案产生影响操作应用，查询时就是查询1到t中大于等于y的数字有多少个

总体复杂度nlogn根号n
```cpp
# include<iostream>
# include<cstdio>
# include<algorithm>
# include<cmath>
# include<cstring>
# include<queue>
using namespace std;
typedef long long LL;
const int mn = 100100;
priority_queue< pair<int,int> > q;
int n,Q,c[mn],cnt1,cnt2;
struct ask{int pos,ti,val,id;};
ask a[mn];
bool cmp1(ask x,ask y)
{
    if(x.pos==y.pos) return x.ti<y.ti;
    else return x.pos<y.pos;
}
struct update{int l,r,val,ti;};
update b[mn];
bool cmp2(update x,update y)
{
    if(x.l==y.l) return x.ti<y.ti;
    else return x.l<y.l;
}
int bl[mn],siz;
LL pa[mn],up[mn],tag[5000];
int ans[mn];
void change(int l,int r,LL d)
{
    if(bl[l]==bl[r])
    {
        for(int i=l;i<=r;i++)
            up[i]+=d;
        int m=min(Q+1,bl[l]*siz);
        for(int i=(bl[l]-1)*siz+1;i<=m;i++)
            pa[i]=up[i];
        sort(pa+(bl[l]-1)*siz+1,pa+m+1);
        return ;
    }
    else {
        for(int i=l;i<=bl[l]*siz;i++)
            up[i]+=d;
        for(int i=(bl[l]-1)*siz+1;i<=bl[l]*siz;i++)
            pa[i]=up[i];
        for(int i=(bl[r]-1)*siz+1;i<=r;i++)
            up[i]+=d;
        int m=min(bl[r]*siz,Q+1);
        for(int i=(bl[r]-1)*siz+1;i<=m;i++)
            pa[i]=up[i];
        sort(pa+(bl[l]-1)*siz+1,pa+bl[l]*siz+1);
        sort(pa+(bl[r]-1)*siz+1,pa+m+1);
        for(int i=bl[l]+1;i<=bl[r]-1;i++)
            tag[i]+=d;
    }
}
int cal(int x,LL y)
{
    int m=min(x*siz,Q+1);
    int tmp=lower_bound(pa+(x-1)*siz+1,pa+m+1,y)-pa;
    if(tmp==x*siz+1) return 0;
    tmp=x*siz-tmp+1;
    return tmp;
}
int query(int x,LL y)
{
    //printf("%d\n",x);
    int ret=0;
    for(int i=1;i<=bl[x]-1;i++)
        ret+=cal(i,y-tag[i]);
    for(int i=(bl[x]-1)*siz+1;i<=x;i++)
        if(tag[bl[i]]+up[i]>=y) ret++;
    return ret;
}
int main()
{
    int opt,x,y;
    scanf("%d%d",&n,&Q);
    for(int i = 1; i <= n; i++)
        scanf("%d",&c[i]);
    for(int i = 2; i <= Q+1; i++)
    {
        scanf("%d",&opt);
        if(opt==1)
        {
            cnt2++;
            scanf("%d%d%d",&b[cnt2].l,&b[cnt2].r,&b[cnt2].val);
            b[cnt2].ti=i;
        }
        else{
            cnt1++;
            scanf("%d%d",&a[cnt1].pos,&a[cnt1].val);
            a[cnt1].ti=i;
            a[cnt1].id=cnt1;
        }
    }
    sort(a+1, a+1+cnt1, cmp1);
    sort(b+1, b+1+cnt2, cmp2);
    n++;
    siz=sqrt(1.0*n);
    for(int i = 1; i<=Q + 1; i++)
        bl[i]=(i-1) / siz + 1;
    int now=1;
    for(int i = 1; i<=cnt1; i++)
    {
        while(!q.empty() && -q.top().first<a[i].pos)
        {
            int xx=q.top().second;
            change(b[xx].ti,Q+1,-b[xx].val);
            q.pop();
        }
        if(a[i].pos!=a[i-1].pos)
        {
            change(1,Q+1,c[a[i].pos]);
            change(1,Q+1,-c[a[i-1].pos]);
        }
        while(b[now].l <= a[i].pos && now <= cnt2)
        {
            /*change(1,b[now].ti,b[now].val);
            q.push(make_pair(-b[now].r,now));
            now++;*/
            if(b[now].r<a[i].pos) {now++;continue;}
            change(b[now].ti,Q+1,b[now].val);
            q.push(make_pair(-b[now].r,now));
            now++;
        }
        ans[a[i].id] = query(a[i].ti-1,a[i].val);
    }
    for(int i = 1; i <= cnt1 ;i++)
        printf("%d\n",ans[i]);
    return 0;
}

```

---

## 作者：x_liuier (赞：5)

> 距 ${{{C_S}^{P_-}}_S}+AFO$ 还剩 $-inf$ 天

分块题(似乎归并树也能写,~~但蒟蒻不会~~).

楼上神犇写得已经很好了(~~于是我就来水题解了~~),这篇题解和楼上的解法差不多(~~可能更差~~).

## solve

以下假设神犇们学会了[分块](http://hzwer.com/8053.html)

似乎也没什么简单解法,区间修改+历史查询也难以实现.

对于单个数(数列中的单个数)进行查询操作,按时间建分块数组能快速求解:

> + 首先按时间顺序处理与当前数(数列中的单个数)操作
>
> + 单个数修改:设与该数相关的操作发生时间为i,那么给区间$[i, m+1)$加上要加上的值,用分块直接更新
>
> + 单个数查询:用分块直接查询区间$[0,i)$内(下标0存初始数据)满足要求的数的数量

但整个数列如何处理呢?

考虑将查询及操作离线,将查询或操作按原序列下标$0 \leq i < n$以及时间排序(先按下标排序,再按时间排序).

对于每一个数相关的操作及答案就能在大约$O(m \sqrt m)$内得到.

但直接暴力算总的时间复杂度是$O(nm \sqrt m)$,这依然不够,因为操作是在连续区间上的,对于同一个操作单个数求解可能会有重复计算.

接下来着手利用同一个数组完成求解

##### 1. 处理转移不同的数$vul_1$和$vul_2$的情况

当处理完$vul_1$的操作,要开始处理$vul_2$的操作时,只要给区间$[0,m+1)$加上$vul_2-vul_1$就可完成不同数的转移

##### 2. 处理每一个操作与查询

考虑将同一个操作 在时间$i$更新$[l,r)+c$ 视为

> 1. 当处理到第l个数时,将[i, m+1)+c
>
> 2. 当处理到第r个数时,将[i, m+1)-c

即可在$O((n+m) \sqrt m)$内求解

## code:

```cpp
#include <algorithm>
#include <iostream>
#include <vector>
#include <cmath>
using namespace std;
typedef long long ll;
const int MAX_N = 1e5;
const int MAX_M = 1e5+1;
const int MAX_S = 1e3;
struct data { ll id, tim, cng; bool type; };

/*输入-----------------------------------------------*/
ll n, m;
ll vul[MAX_N];
data in[(MAX_M+MAX_N)<<1], *ite=in-1;
inline void push(int id, ll tim, ll cng, bool type) {
	*++ite = (data){id, tim, cng, type};
}
/*end------------------------------------------------*/

/*输出-----------------------------------------------*/
ll ans[MAX_M];
bool flag[MAX_M];
/*end------------------------------------------------*/

/*~分块~---------------------------------------------*/
namespace tool {
	ll bit[MAX_M];
	vector<ll*> buck[MAX_S];
	ll BASE, rang[MAX_M], cng[MAX_S];
	bool cut[MAX_M], sted[MAX_M];

	inline bool cmp(ll* i, ll* j) { return *i<*j; }
	inline void st(ll k) {
		sort(buck[k].begin(), buck[k].end(), cmp);
	}
	inline ll ld(ll k, ll c) {
		return lower_bound(buck[k].begin(), buck[k].end(), &c, cmp)-buck[k].begin();
	}

	inline void upRange(ll k, ll add) { cng[k] += add; }
	inline void upPoint(ll in, ll add) {
		sted[rang[in]] = false; bit[in] += add;
	}

	inline ll quRange(ll k, ll c) {
		if (!sted[k]) { st(k); sted[k] = true; }
		return (BASE-ld(k, c-cng[k]));
	}
	inline ll quPoint(ll in, ll c) {
		return bit[in]+cng[rang[in]]>=c;
	}

	inline void updata(ll l, ll r, ll add) {
		while (l<r&&!cut[l]) upPoint(l++, add);
		while (l<r&&!cut[r]) upPoint(--r, add);
		while (l<r) upRange(rang[r-=BASE], add);
	}
	inline ll query(ll l, ll r, ll c) {
		ll res = 0;
		while (l<r&&!cut[l]) res += quPoint(l++, c);
		while (l<r&&!cut[r]) res += quPoint(--r, c);
		while (l<r) res += quRange(rang[r-=BASE], c);
		return res;
	}

	inline void init();
	inline void solve() {
		init();
		for (data* d=in; d!=ite; ++d) {
			if (d->type) {
				ans[d->tim] = query(0, d->tim, d->cng);
				flag[d->tim] = true;
			} else updata(d->tim, m, d->cng);
		}
		for (ll i=0; i<m; ++i) {
			if (flag[i]) cout<<ans[i]<<endl;
		}
	}

	inline void init() {
		++m; BASE = sqrt(m);
		for (int i=0; i<m; i+=BASE) cut[i]=true;
		for (ll i=0, k=-1; i<m; ++i) {
		  k += cut[i]; rang[i] = k;
			buck[k].push_back(&bit[i]);
		}
	}
}
/*end------------------------------------------------*/

/*读入数据处理----------------------------------------*/
inline bool cmp(data &i, data &j) {
	if (i.id!=j.id) return i.id<j.id;
	else if (j.type) return !i.type;
	else return i.tim<j.tim;
}

inline void pre() {
	ios::sync_with_stdio(false); cin>>n>>m;
	for (int i=0; i<n; ++i) cin>>vul[i];
	ll id, cng, type;
	for (int i=0; i<n; ++i)
		push(i, 0, vul[i]-(i?vul[i-1]:0), 0);
	for (int i=1; i<=m; ++i) {
		cin>>type; --type;
		if (type) {
			cin>>id>>cng;
			push(--id, i, cng, true);
		} else {
			cin>>type>>id>>cng;
			push(--type, i, cng, false);
			push(id, i, -cng, false);
		}
	} sort(in, ++ite, cmp);
}

int main() {
	pre(); tool::solve();
	return 0;
}

```


---

## 作者：Aryper (赞：4)

序列

[Github Blog](https://onlypath.github.io/2022/03/30/P3863/)。

这个题比较神奇，我们采用扫描线的方法，并离线处理询问。

大概来说，就是这样的：

![示意图](https://cdn.luogu.com.cn/upload/image_hosting/l5n7x970.png)

这里每条蓝色的线段表示在这个时间对序列进行了操作。

然后我们的每个询问实际上就是针对平面上的某个竖直向上的射线的信息的询问。

我不太好解释这个东西/kk。

假设现在我们扫描线扫到了一个位置 $x$，它对应序列轴上横坐标为 $x$ 的竖直线，表示现在我们要对 $p=x$ 的所有询问进行集中处理。

询问的就是该点在时间 $i-1$ 及之前（一直到 0）数值上大于等于 $y$ 的秒数，对应到这个平面上就是扫描线纵坐标小于等于 $i-1$ 的那一段中，统计一下这个大于等于 $y$ 的数的个数即可。

每次扫之前我们要先把红线和粉线进行操作，即在平行于扫描线的时间序列上加或减操作的数。

现在问题来了，我们一般的扫描线是线段树，似乎很难处理这类询问大于等于 $y$ 的数的个数之类的问题。。。

所以我们可以用分块维护。

这个分块维护的套路实际上比较入门。每个块内元素预先排序，查询的时候，对于整块二分得到个数，对于零散块直接暴力统计；对于修改操作，整块直接用 ```laztag```，零散块暴力重构。

时间复杂度 $O(n\sqrt{n}\log n)$。

代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#define ll long long
using namespace std;
namespace Ehnaev{
  inline ll read() {
    ll ret=0,f=1;char ch=getchar();
    while(ch<48||ch>57) {if(ch==45) f=-f;ch=getchar();}
    while(ch>=48&&ch<=57) {ret=(ret<<3)+(ret<<1)+ch-48;ch=getchar();}
    return ret*f;
  }
  inline void write(ll x) {
    static char buf[22];static ll len=-1;
    if(x>=0) {do{buf[++len]=x%10+48;x/=10;}while(x);}
    else {do{buf[++len]=-(x%10)+48;x/=10;}while(x);}
    while(len>=0) putchar(buf[len--]);
  }
}using Ehnaev::read;using Ehnaev::write;
inline void writeln(ll x) {write(x);putchar(10);}

const ll N=1e5,M=1e3;

ll n,m,nn,cnt,cntq;
ll a[N+5],pos[N+5];

struct Opt{
  ll l,r,val,id;
  inline bool operator<(const Opt& rhs) const{return id<rhs.id;}
}opt[N+5];

struct Qry{ll id,pos,val,ans;}q[N+5];

inline bool Cmp1(Qry x,Qry y) {return x.pos<y.pos;}
inline bool Cmp2(Qry x,Qry y) {return x.id<y.id;}

struct node{
  ll val,id;
  inline node() {}
  inline node(ll x,ll y):val(x),id(y){}
  inline bool operator<(const node& rhs) const{return val<rhs.val;}
};

struct Block{node a[M+5];ll l,r,laz;}blo[M+5];

inline void Add(ll l,ll r,ll k) {
  if(pos[l]==pos[r]) {
    ll len=blo[pos[l]].r-blo[pos[l]].l+1;
    for(ll i=1;i<=len;i++) {
      ll tmp=blo[pos[l]].a[i].id;
      if(tmp>=l&&tmp<=r) blo[pos[l]].a[i].val+=k;
    }
    sort(blo[pos[l]].a+1,blo[pos[l]].a+len+1);
  }
  else {
    if(l==blo[pos[l]].l) {blo[pos[l]].laz+=k;}
    else {
      ll len=blo[pos[l]].r-blo[pos[l]].l+1;
      for(ll i=1;i<=len;i++) {
        ll tmp=blo[pos[l]].a[i].id;
        if(tmp>=l) blo[pos[l]].a[i].val+=k;
      }
      sort(blo[pos[l]].a+1,blo[pos[l]].a+len+1);
    }
    if(r==blo[pos[r]].r) {blo[pos[r]].laz+=k;}
    else {
      ll len=blo[pos[r]].r-blo[pos[r]].l+1;
      for(ll i=1;i<=len;i++) {
        ll tmp=blo[pos[r]].a[i].id;
        if(tmp<=r) blo[pos[r]].a[i].val+=k;
      }
      sort(blo[pos[r]].a+1,blo[pos[r]].a+len+1);
    }
    for(ll i=pos[l]+1;i<pos[r];i++) blo[i].laz+=k;
  }
}

inline ll Ask(ll l,ll r,ll k,ll x) {
  ll res=0;
  if(pos[l]==pos[r]) {
    ll len=blo[pos[l]].r-blo[pos[l]].l+1;
    for(ll i=1;i<=len;i++) {
      ll tmp=blo[pos[l]].a[i].id;
      if(tmp>=l&&tmp<=r) {
        res+=(blo[pos[l]].a[i].val+blo[pos[l]].laz+a[x]>=k);
      }
    }
  }
  else {
    ll len=blo[pos[l]].r-blo[pos[l]].l+1;
    for(ll i=1;i<=len;i++) {
      ll tmp=blo[pos[l]].a[i].id;
      if(tmp>=l) {
        res+=(blo[pos[l]].a[i].val+blo[pos[l]].laz+a[x]>=k);
      }
    }
    // printf("here:\n");
    // printf("l=%lld r=%lld\n",l,r);
    // printf("x=%lld res=%lld\n",x,res);
    len=blo[pos[r]].r-blo[pos[r]].l+1;
    for(ll i=1;i<=len;i++) {
      ll tmp=blo[pos[r]].a[i].id;
      if(tmp<=r) {
        res+=(blo[pos[r]].a[i].val+blo[pos[r]].laz+a[x]>=k);
      }
    }
    // printf("x=%lld res=%lld\n",x,res);
    for(ll i=pos[l]+1;i<pos[r];i++) {
      ll len=blo[i].r-blo[i].l+1;
      ll tmp=lower_bound(blo[i].a+1,blo[i].a+len+1
      ,node(k-blo[i].laz-a[x],0))-blo[i].a-1;
      res+=len-tmp;
    }
    // printf("x=%lld res=%lld\n",x,res);
  }
  return res;
}

int main() {

  n=read();m=read();
  nn=max(1ll,(ll)sqrt(m+1));
  for(ll i=1;i<=n;i++) {a[i]=read();}
  for(ll i=0,cntt=1;i<=m;i+=nn,cntt++) {
    blo[cntt].l=i;blo[cntt].r=i+nn-1;if(blo[cntt].r>m) blo[cntt].r=m;
    for(ll j=blo[cntt].l,k=1;j<=blo[cntt].r;j++,k++) {
      blo[cntt].a[k].val=0;blo[cntt].a[k].id=j;pos[j]=cntt;
    }
    ll len=blo[cntt].r-blo[cntt].l+1;
    sort(blo[cntt].a+1,blo[cntt].a+len+1);
  }

  for(ll i=1;i<=m;i++) {
    ll op=read();
    if(op==1) {
      ll l,r,x;l=read();r=read();x=read();
      opt[++cnt].l=i;opt[cnt].r=m;opt[cnt].val=x;opt[cnt].id=l;
      opt[++cnt].l=i;opt[cnt].r=m;opt[cnt].val=-x;opt[cnt].id=r+1;
    }
    if(op==2) {
      ll p,y;p=read();y=read();
      q[++cntq].id=i;q[cntq].pos=p;q[cntq].val=y;
    }
  }

  sort(opt+1,opt+cnt+1);sort(q+1,q+cntq+1,Cmp1);

  for(ll i=1,it=1,jt=1;i<=n;i++) {
    while(opt[it].id==i) {Add(opt[it].l,opt[it].r,opt[it].val);it++;}
    while(q[jt].pos==i) {q[jt].ans=Ask(0,q[jt].id-1,q[jt].val,i);jt++;}
  }

  sort(q+1,q+cntq+1,Cmp2);

  for(ll i=1;i<=cntq;i++) {writeln(q[i].ans);}

  return 0;
}
```

---

## 作者：FutaRimeWoawaSete (赞：3)

备选 T4。                   

《关于我第二遍读题读错以致于看不懂自己以前做法这件事》                 

其实并不是一道很难的题，不过这 trick 我倒是第一次见。           

题目要求询问单点历史 $a_p$ 值在一个前缀值域里的数量，然后附上区间加。                 

如果我们能通过数据结构任意时刻 $a_p$ 的值的话貌似就可以维护区间 kth 来回答查询。                

一个很有趣的性质即我们发现加上时间一维后这其实是个二维数点问题，所以考虑扫描线离线维度。

我们考虑可以把 $[l,r]$ 的区间加拆成 $[l , n]$ 和 $[r + 1 , n]$ 后缀加的形式，并且对于时间这一维而言修改也是后缀形式，所以我们直接按每个后缀修改的左端点排序，只要左端点在一个查询的点 $p$ 前面必定会影响 $a_p$ 的值，所以我们在回答一个询问前只要把所有后缀修改的左端点在询问点 $p$ 之前的修改都对应的加到时间上面去就好了。                   

然后现在问题变成了一个后缀加，前缀查询 kth 值的问题，直接用一般形式的区间加区间 kth 分块做就可以了，直接 $O(m \sqrt n \log n)$ 随便重构是可以过的，实现精细的 $O(m \sqrt {n \log n})$ 和 $O(m \sqrt n)$ 可以看 P5356 这里不再赘述。                  

```cpp
#include "bits/stdc++.h"
using namespace std;
#define int long long
const int Len = 2e5 + 5 , SIZE = 525;
int n,m,L[SIZE],R[SIZE],t,cntu,cntq,Print[Len],pos[Len],tag[SIZE];
int A[Len],a[Len],b[Len];
struct node
{
	int idx,val,tim,id,ans;
	node(){idx = 0 , val = 0 , tim = 0;}
	node(int IDX,int VAL,int TIM,int ID){idx = IDX , val = VAL , tim = TIM , id = ID;}
}Upd[Len] , Ques[Len];
bool cmp(node x , node y){return x.idx < y.idx;}
bool cmpd(node x,node y){return x.tim < y.tim;}
void Init()
{
	t = sqrt(m + 1); 
	for(int i = 1 ; i <= t ; i ++) L[i] = (i - 1) * t + 1 , R[i] = i * t;
	if(R[t] < m + 1) R[t] = m + 1;
	for(int i = 1 ; i <= t ; i ++)
		for(int j = L[i] ; j <= R[i] ; j ++) pos[j] = i;
	for(int i = 1 ; i <= t ; i ++) sort(b + L[i] , b + R[i] + 1);
}
void maintain(int t)
{
	for(int i = L[t] ; i <= R[t] ; i ++) b[i] = a[i];
	sort(b + L[t] , b + R[t] + 1);
}
void update(int l,int r,int val)
{
	int Ll = pos[l] , Rr = pos[r];
	if(Ll == Rr)
	{
		for(int i = l ; i <= r ; i ++) a[i] += val;
		maintain(Ll);
		return;
	}
	for(int i = l ; i <= R[Ll] ; i ++) a[i] += val;
	maintain(Ll);
	for(int i = Ll + 1 ; i <= Rr - 1 ; i ++) tag[i] += val;
	for(int i = L[Rr] ; i <= r ; i ++) a[i] += val;
	maintain(Rr); 
}
int query(int l,int r,int val)
{
	int Ll = pos[l] , Rr = pos[r] , res = 0;
	if(Ll == Rr)
	{
		for(int i = l ; i <= r ; i ++) if(a[i] >= val - tag[Ll]) res ++;
		return res;
	} 
	for(int i = l ; i <= R[Ll] ; i ++) if(a[i] >= val - tag[Ll]) res ++;
	for(int i = Ll + 1 ; i <= Rr - 1 ; i ++) res += R[i] - (lower_bound(b + L[i] , b + R[i] + 1 , val - tag[i]) - b) + 1;
	for(int i = L[Rr] ; i <= r ; i ++) if(a[i] >= val - tag[Rr]) res ++;
	return res;
}
signed main()
{
	scanf("%lld %lld",&n,&m);
	for(int i = 1 ; i <= n ; i ++) scanf("%lld",&A[i]);
	Init();
	for(int k = 1 ; k <= m ; k ++)
	{
		int opt;scanf("%lld",&opt);
		if(opt == 1)
		{
			int l,r,x;scanf("%lld %lld %lld",&l,&r,&x);
			Upd[++ cntu] = node(l , x , k + 1 , 0);
			Upd[++ cntu] = node(r + 1 , -x , k + 1 , 0);
		}
		if(opt == 2)
		{
			int p,y;scanf("%lld %lld",&p,&y);
			Ques[++ cntq] = node(p , y , k + 1 , k);
		}
	}	
	sort(Upd + 1 , Upd + 1 + cntu , cmp);
	sort(Ques + 1 , Ques + 1 + cntq , cmp);
	//for(int i = 1 ; i <= cntu ; i ++) printf("%lld %lld %lld %lld\n",Upd[i].idx,Upd[i].val,Upd[i].tim,Upd[i].id,Upd[i].ans);
	int num = 1;
	for(int i = 1 ; i <= cntq ; i ++) 
	{
		while(num <= cntu && Upd[num].idx <= Ques[i].idx) 
		{
			update(Upd[num].tim , m + 1 , Upd[num].val);
			num ++;	
		}
		//printf("%lld %lld %lld\n",Ques[i].tim,Ques[i].val,Ques[i].idx);
		Ques[i].ans = query(1 , Ques[i].tim - 1 , Ques[i].val - A[Ques[i].idx]);
	}
	sort(Ques + 1 , Ques + 1 + cntq , cmpd);
	for(int i = 1 ; i <= cntq ; i ++) printf("%lld\n",Ques[i].ans);
	return 0;
}
```

---

## 作者：SAMSHAWCRAFT (赞：2)

要求维护一个数据结构，支持：

1. 区间加
  
2. 单点查询历史不小于某个值的时间
  

常见的分治数据结构很难做这个（也许有能做的分治数据结构但是没有引入 OI 实战，又或者是我无知），因为区间加的数据结构很难维护历史版本，而能维护历史版本的数据结构往往也只能单点修改，如果把区间加拆成单点加，无论是时间复杂度还是内存开支都会很大。

因此我们需要考虑分块，发现如果只维护一个数字的话可以时间分块解决时间区间加、单点查询历史不小于某个值的时间的问题。具体做法就是把每一个时间当作序列的下标，整个时间轴放在序列上做分块，这样可以规约到区间加、区间查询不小于某个值的数字个数的问题，也就是 [LibreOJ::\#6278. 数列分块入门 2](https://loj.ac/p/6278)。

我们尝试把上面这个东西从维护一个数字变成维护 $n$ 个数字。不妨直接在分块的基础上增加一维，变成一个二维的问题，时间维仍然是分块，空间维可以从前往后一个一个地处理，这样做的可行性可以用一个图理解（字丑警告）：

![](https://cdn.luogu.com.cn/upload/image_hosting/g403xnfc.png)

我们把所有操作离线下来，用扫描线一个一个地把序列上每个数字的答案维护出来即可。所以这题是扫描线套分块的思路，解题步骤就是：

1. 把所有操作离线。把区间加拆成 $[l,n]$ 和 $[r+1,n]$ 方便扫描线。
  
2. 把所有的修改和查询都排序。按序列中的下标排序方便按顺序处理。
  
3. 在分块上进行操作，完成单个数字答案的维护。
  
4. 把所有的查询的答案输出。
  

代码的话就是在数列分块入门 2 上加一个离线、加一个扫描线即可，可以 $O(n+q\sqrt q\log q)$ 地解决。放一个扫描线部分的核心代码，完整代码可以参考其他题解。

```cpp
//qpp 是查询总数，quop 是查询操作的数组
//upp 是修改总数，upop 是修改操作的数组
//c 是题目输入的原数列
struct cmp1{
  bool operator()(const op_t &a,const op_t &b){ return a.id<b.id; }
};
struct cmp2{
  bool operator()(const op_t &a,const op_t &b){ return a.t<b.t; }
};
std::sort(upop+1,upop+upp+1,cmp1());
std::sort(quop+1,quop+qpp+1,cmp1());
for(int cx=1,cut=1;cx<=qpp;++cx){
  while(cut<=upp&&upop[cut].id<=quop[cx].id){
    add(upop[cut].t,q+1,upop[cut].val);
    cut++;
  }
  quop[cx].ans=query(1,quop[cx].t-1,quop[cx].val-c[quop[cx].id]);
}
std::sort(quop+1,quop+qpp+1,cmp2());
```

这里重点写一写复杂度分析。

设块长为 $B$，整块数为 $O(\frac q B)$ 级别的，单次修改 $O(\frac q B +B)$，单次查询如果暴力排序二分，时间复杂度为 $O(B\log B+\frac q B \log B)$，前一项是零散块排序暴力，后一项是整块排序二分，因此分块部分总复杂度 $O(q(B\log B+\frac q B \log B))$，取 $B=O(\sqrt q)$ 即得复杂度 $O(q\sqrt q\log q)$，输入输出 $O(n)$，给询问排序的复杂度为 $O(q\log q)$，因此总复杂度 $O(n+q\sqrt q\log q)$。当然，这是最朴素的做法，可以通过其它算法优化复杂度。

---

## 作者：Cocoly1990 (赞：1)

我们定义第 $i$ 秒时 $a_p$ 的值为 $a_{p,i}$，我们每次在第 $t$ 秒查询其实是在查询 $p,y$ 其实是在查询 $\sum
\limits_{i=0}^t \left[a_{p,i}<y\right]$.

事实上这个东西必然是不好维护的，但我们可以发现另一个性质，$a_{p,i}=a_{p,0}+s_{p,i}$，其中，$s_{p,i}$  表示第 $i$ 个时刻对于位置 $p$ 的增量，而这个 $s$ 必然是好维护的。

我们考虑对于所有的询问按照 $p$ 排序，那么就可以滚动掉 $s$ 的第一维，现在需要考虑的是如何通过 $s_{p-1,i}$ 转移到 $s_{p,i},i\in{\left[1,q\right]}$.

既然已经滚动掉了第一维，原先的区间问题也转化为单点问题，而单点是平凡的。

对于一次 $t$ 时刻的区间 $\left[l,r\right]$ 加 $w$ 操作，他对于单点 $p\in\left[l,r\right]$ 的影响是什么，他会使 $s_{p,i}+w,i\in\left[t,n\right]$.

这由此启发我们在由 $s_{l-1,i}$ 转移到 $s_{l,i},i\in{\left[1,q\right]}$ 时给 $s_{l,i}+w,i\in\left[t,n\right]$，而由 $s_{r,i}$ 转移到 $s_{r+1,i},i\in{\left[1,q\right]}$ 时给  $s_{r+1,i}-w,i\in\left[t,n\right]$，每次查询的时候只需要在现有的 $s$ 数列上进行一次前缀查就可以了。

等于说要求维护一个数据结构，支持区间加，区间减，区间大于某数查。显然的是，分块可以维护，所以利用分块做扫描线对询问进行扫描即可解决该题。


---

## 作者：Others (赞：1)

操作分块练手题。

# Solution

这题直接维护的空间至少是 $O(nm)$（因为询问的 $y$ 不定，所以要存全部的），所以就要离线下来卡 cache，首先思考按什么顺序处理，这里如果按时间顺序就和开头说的那种做法相似，我们就是想要优化掉一个系数，因为询问的 $y$ 不是定值，所以 $O(n)$ 的空间是必要的，所以 $m$ 就要褪去，于是我们按原序列下标一个一个处理。

先是修改，因为不能同时处理两个不同下标的元素，所以我们将这个 $[l,r]$ 的区间加转换成 $[l,n]$ 的加和 $[r+1,n]$ 的减，这在按下标处理的算法里是十分友好的，只需要在处理 $l$ 的时候加一下，在处理 $r+1$ 的时候减一下就可以了，这里的散块的修改为了适应下面的查询，我们将块重构一下（见下）。

然后是查询，这里就是个简单的操作分块，但是我们要思考的是整块如何处理，这里可以参考一下[教主的魔法](https://www.luogu.com.cn/problem/P2801)的思想，将每个块都存一个排好序的复制品，查询的时候散块暴力，整块打二分，修改的时候散块就重新复制和排序，总时间是 $O(n\sqrt n\log n)$。

**Code**，可能有点臭

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
int qr(){
	int x=0,f=0;
	char c=getchar();
	while(!isdigit(c)) f|=(c=='-'),c=getchar();
	while(isdigit(c)) x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return f?~(x-1):x;
}
int idx[100005],R[405],L[405],s,bls,n,m,a[100005],opt,l,r,x,top,ans[200005];
ll b[100005],c[100005],tag[405];
struct node{
	int opt,t,x,y,id;
	bool operator<(const node &p)const{
		return x<p.x||(x==p.x&&t<p.t);
	}
}p[200005];
bool cmp(node x,node y){
	return x.t<y.t;
}
int getsum(int l,int r,ll v){
	int ans=0;
	if(idx[l]==idx[r]){
		for(int i=l;i<=r;i++) ans+=b[i]>=(v-tag[idx[l]]);
	}else{
		for(int i=l;i<=R[idx[l]];i++) ans+=b[i]>=(v-tag[idx[l]]);
		for(int i=L[idx[r]];i<=r;i++) ans+=b[i]>=(v-tag[idx[r]]);
		for(int i=idx[l]+1;i<idx[r];i++) ans+=((c+R[i])-lower_bound(c+L[i],c+R[i]+1,v-tag[i])+1);
	}
	return ans;
}
void modify(int l,int r,ll v){
	if(idx[l]==idx[r]){
		for(int i=l;i<=r;i++) b[i]+=v;
		for(int i=L[idx[l]];i<=R[idx[l]];i++) c[i]=b[i];
		sort(c+L[idx[l]],c+R[idx[l]]+1);
	}else{
		for(int i=l;i<=R[idx[l]];i++) b[i]+=v;
		for(int i=L[idx[l]];i<=R[idx[l]];i++) c[i]=b[i];
		sort(c+L[idx[l]],c+R[idx[l]]+1);
		for(int i=L[idx[r]];i<=r;i++) b[i]+=v;
		for(int i=L[idx[r]];i<=R[idx[r]];i++) c[i]=b[i];
		sort(c+L[idx[r]],c+R[idx[r]]+1);
		for(int i=idx[l]+1;i<idx[r];i++) {
			tag[i]+=v;
		}
	}
}
int main() {
	n=qr(),m=qr();
	for(int i=1;i<=n;i++){
		a[i]=qr();
	}
	for(int i=1;i<=m;i++){
		opt=qr();
		if(opt^2){
			l=qr(),r=qr(),x=qr();
			p[++top]=(node){opt,i,l,x,top};
			p[++top]=(node){opt,i,r+1,-x,top};
		}else{
			l=qr(),r=qr();
			p[++top]=(node){opt,i,l,r,top};
		}
	}
	sort(p+1,p+top+1);
	s=sqrt(m+1),bls=(m+s-1)/s,R[0]=-1;
	for(int i=1;i<=bls;i++){
		L[i]=R[i-1]+1,R[i]=min(m,s*i-1);
		for(int j=L[i];j<=R[i];j++) idx[j]=i;
	}
	int now=0;
	for(int i=1;i<=top;i++){
		if(p[i].x>n) break;
		if(p[i].x!=now){
			modify(0,m,a[p[i].x]-a[now]);
			now=p[i].x;
		}
		if(p[i].opt^2) modify(p[i].t,m,p[i].y);
		else ans[p[i].id]=getsum(0,p[i].t-1,p[i].y);
	}
	sort(p+1,p+top+1,cmp);
	for(int i=1;i<=top;i++){
		if(p[i].opt^1){
			printf("%d\n",ans[i]);
		}
	}
	return 0;
}
```

---


# aaa被续

## 题目背景

HansBug持续无聊ing


## 题目描述

由于aaa没有完成HansBug的任务。所以HansBug开始计划着如何续aaa。

现在HansBug手里有 $ N $个aaa，每个aaa有一个码力值。一共存在 $ N - 1 $条连接两个aaa的边，故这 $ N $个aaa构成一棵**有根树**，根为1号aaa。

现在HansBug想要续了这 $ N $个aaa。HansBug所采用的策略是，对于第 $ i$个aaa，先让他和他的各级子aaa们~~乖乖♂站好~~成一队，然后依次续掉。

经过长期对于aaa码力值的研究，HansBug发现，**对于每一队aaa**，设有 $n$个，码力值依次为$ v_i $，则续了队伍里的第 $ i $个aaa所能获得的码力值为 $ v_1 + v_2 + \cdots + v_i $。


然而，aaa之间的关系树相当的复杂，HansBug的智商早已不够用，于是这个任务就交给了你。不过HansBug知道，任何一个aaa都不会有超过5个的直接子aaa

HansBug想要知道在每次排♂队方法最优的情况下，续了这些aaa最多可以获得的码力值~~，事成之后分给你100000 % 10点码力值~~。


## 说明/提示

**样例解释：**

 ![](https://cdn.luogu.com.cn/upload/pic/7980.png) 

故续了5个aaa所得的最大总码力值为：118 + 9 + 10 + 4 + 48 = 189

**对1000000007取模后得到答案189**


**数据范围：**

对于30%的数据：$ 1 \leq N \leq 3 \cdot {10}^3 $

对于50%的数据：$ 1 \leq N \leq 2 \cdot {10}^4 $

对于70%的数据：$ 1 \leq N \leq {10}^5 $

对于100%的数据：$ 1 \leq N \leq 5 \cdot {10}^5 $

对于每一个aaa的码力值 $ a_i $，保证 $ 0 \leq a_i \leq {10}^8 $


## 样例 #1

### 输入

```
5
5 3
1 2
1 5
4 5
3 9 10 4 7 
```

### 输出

```
189
```

# 题解

## 作者：winxp_qwq (赞：9)

先膜楼下dalao为敬，然而由于本蒟蒻太菜了，只会树剖的nlog^2n卡常做法
#### 30分做法：
暴力续aaa，乖乖♂站好即可
#### 50分做法：
考虑每个aaa对答案的贡献，每个点以还未续掉的点数为权值，    

注意到每个点续掉每个aaa时权值都会-1 ~~(-1s)~~, 因此先续码力大的aaa总是对的，排完序每次跳到根，路径系数-1即可。    

而且本题要求最大值，却还要在mod的意义下计算，这样贪心求解之后才可以放心膜。
#### 70~100分做法
注意到续aaa的过程每次需要走树上到根的路径，需要搞两个操作：  
##### 1.求到根路径的权值和
##### 2.将到根路径权值-1
自然想到树剖  
  
于是打了一发，发现最后一个点TLE了，~~显然nlog^2n不是正解~~，但是与时限相差也不大。  

于是开始卡常。。。。。。  我们用树状数组代替线段树对链剖进行维护，因为树状数组对上面的操作完全可以胜任，而且常数小！

这样就能AC此题，得到全部的100分。

最后按例代码：
```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
using namespace std;
#define LL long long
#define maxn 500666
#define mod 1000000007LL
#define mid ((l+r)>>1)
LL n,hhh=0;
struct aaa{
	LL va;
	LL po;
};
bool operator < (aaa a1,aaa a2){
	return a1.va<a2.va;
}
priority_queue <aaa> pq;
LL fa[maxn]={0},w[maxn]={0};
vector <LL> ed[maxn];
LL hs[maxn]={0},tp[maxn]={0},dfn[maxn]={0},tt=1;
LL cf[maxn]={0};
void dfs1(LL a){
	if(a==0) return;
	w[a]=1;hs[a]=0;
	for(LL b=0;b<ed[a].size();b++)
	if(fa[a]!=ed[a][b])
	{
		fa[ed[a][b]]=a;
		dfs1(ed[a][b]);
		w[a]+=w[ed[a][b]];
		if(w[ed[a][b]]>w[hs[a]]) hs[a]=ed[a][b];
	}
}
void dfs2(LL a){
	if(a==0) return;
	tp[a]= a==hs[fa[a]]? tp[fa[a]]:a;
	dfn[a]=tt++;
	dfs2(hs[a]);
	for(LL b=0;b<ed[a].size();b++)
	if(ed[a][b]!=fa[a]&&ed[a][b]!=hs[a]) dfs2(ed[a][b]);
}
//BIT
LL lowbit(LL x) {return (-x)&x;} 
LL bit[3][maxn]={0};
void add(LL a,LL x,LL c){
	while(x<=n)
	{
		bit[a][x]+=c;
		x+=lowbit(x);
	}
}
LL qu(LL a,LL x){
	LL ret=0;
	while(x)
	{
		ret+=bit[a][x];
		ret%=mod;
		x-=lowbit(x);
	}
	return ret;
}
LL qz(LL x){
	return ((qu(1,x)*(x+1)-qu(2,x))%mod+mod)%mod;
}
//.......
void xu(LL a,LL v){
	LL b,c,d;
	while(a)
	{
		c=tp[a];
		hhh+=(qz(dfn[a])-qz(dfn[c]-1))*v;
		hhh%=mod;
		add(1,dfn[c],-1);
		add(1,dfn[a]+1,1);
		add(2,dfn[c],-dfn[c]);
		add(2,dfn[a]+1,dfn[a]+1);
		a=fa[c];
	}
}
int main(){
	scanf("%lld",&n);
	LL a,b,c,i,j,k;
	aaa tmp;
	for(a=1;a<n;a++)
	{
		scanf("%lld%lld",&i,&j);
		ed[i].push_back(j);
		ed[j].push_back(i);
	}
	for(a=1;a<=n;a++)
	{
		scanf("%lld",&b);
		tmp.va=b;tmp.po=a;
		pq.push(tmp);
	}
	dfs1(1);dfs2(1);
	for(a=1;a<=n;a++) cf[dfn[a]]=w[a];
	for(a=n;a>=1;a--) cf[a]-=cf[a-1];
	for(a=1;a<=n;a++) add(1,a,cf[a]);
	for(a=1;a<=n;a++) add(2,a,cf[a]*a);
	while(pq.size())
	{
		tmp=pq.top();pq.pop();
		xu(tmp.po,tmp.va);
	}
	printf("%lld\n",hhh);
	return 0;
} 
```

---

## 作者：Hoks (赞：6)

## 前言
重剖题单里的，刚好我的[总结文章](https://www.luogu.com.cn/blog/Hok/cute-tree-decomposition)里把这题当做了练习题，就写篇题解吧。

对了，吐槽一句，这个题目的名称他是敏感词，这点我真的没绷住。

Update：更新了一个加强版题目的做法。
## 题意分析
首先是简要题意：

> - 每个点都有一个权值。

> - 对于每个点，把他的子树中的所有点的权值从小到大排序，记答案为权值大小乘以排名。

> - 询问每个点的答案的和。

如果没有看的很懂的话，可以看题目解释这张图：

![](https://cdn.luogu.com.cn/upload/pic/7980.png)

然后我们来考虑下怎么做。

首先考虑暴力，给每颗子树都弄个堆暴力计算，这样的复杂度是 $O(n^2\log n)$，直接原地升天。

接着考虑如何优化。

首先，从数据范围上分析，$n\le 5\times 10^5$ 这种数据，大概是 $O(n\log n)$ 或者小常 $O(n\log^2 n)$。

所以由此我们得到对于正解而言每个点应该只需要计算一次即可。

那么会想到什么？

拆分。

因为每个点都被反复计算了很多次，所以我们可以把这么多次拆出来，化为一次考虑，那就可以成功降低复杂度。

接着考虑如何拆分。

我们考虑一个抽象概念：对于点 $i$，有一个有着 $si_i$ 容量的序列（这里 $si_i$ 的意思是 $i$ 的子树大小），然后排在第 $j$ 位上的排名是 $si_i-j+1$，那么我们把一个权值为 $w$ 的点填进第 $j$ 位的时候，对答案产生的贡献即为 $(si_i-j+1)\times w$。

而对于点 $u$ 而言，就要把他填入 $1\rightarrow u$ 的路径上的每个点的序列中。

那么我们要最大化答案，显然有一种贪心的想法，就是优先把权值最大的点填进去，这样的话乘数最大，最优。

（这里如果不是太理解的话可以手模下样例，样例是按照 $3,2,5,4,1$ 的顺序计算。）

然后呢，每个点都开一个这样的序列空间显然会炸。

这个时候发现了什么呢？

我们每次填的时候，需要的只是目前这个位置的排名值而已，而且我们移动这个序列也是连续的。

也就是，我们对于点 $i$ 的序列，就可以把他排名值初始设定为 $si_i$，填一个空，排名值就 $-1$。

相当于使用一个变量完成了点 $i$ 的排名值的维护。

那么我们可以考虑把这个排名值直接作为这个点的一种权值。

因为我们操作点 $u$ 的时候，要把他填入 $1\rightarrow u$ 的路径上的每个点的序列中。

结合下上面对于答案的贡献的计算式，我们可以把上面式子中的 $w$ 提取出来。

接着申明一些定义：

- $a_i$ 代表 $i$ 这个点目前的排名值。

- $w_u$ 代表 $u$ 这个点的权值。

- $\sum_{a_i}^1$ 代表的是 $u$ 到 $1$ 的路径上所有点的排名值之和。

那么对答案的贡献式即为 $\sum_{a_i}^1\times w_u$。

贡献式成功推出来了，那只要快速算 $\sum_{a_i}^1$ 即可。

因为这是个树上连续路径的排名值和，所以考虑重链剖分+线段树维护。

然后因为序列上的点的位置已经被填了，所以要把路径上所有点的排名值 $-1$，也用重链剖分维护即可。

那最后归纳一下操作即为：

> - 先把点 $i$ 的值赋为 $si_i$。

> - 然后根据题目给出的权值大小，从大到小执行操作。

> - 对于点 $u$，用线段树求出 $1\rightarrow u$ 的路径上的点值和。

> - 然后把求出来的这个值乘上点 $u$ 的权值，累加到 $ans$ 中。

> - 然后把 $1\rightarrow u$ 的路径上的点值都 $-1$。

> - 最后输出 $ans$ 即可。

## 代码
```cpp
#include<bits/stdc++.h>
#define ls (p<<1)
#define rs (p<<1|1)
#define mid ((l+r)>>1)
#define len (t[p].r-t[p].l+1)
#define fi first
#define se second
#define mp(x,y) make_pair(x,y)
#define int long long
using namespace std;
const int N=500010,mod=1e9+7,INF=0x3f3f3f3f3f3f3f3f;
struct edge
{int v,nxt;}e[N<<1];
struct tree
{int l,r,s,lz;}t[N<<2];
int n,tot,cnt,ans;
int head[N],dfn[N],top[N],id[N],w[N];
int fa[N],son[N],si[N],dep[N];
priority_queue<pair<int,int> >q;
static char buf[1000000],*paa=buf,*pd=buf;
#define getchar() paa==pd&&(pd=(paa=buf)+fread(buf,1,1000000,stdin),paa==pd)?EOF:*paa++
inline int read(void){
    int u(0),t(1);char fc(getchar());
    while(!isdigit(fc)){if(fc=='-') t=-1;fc=getchar();}
    while(isdigit(fc)) u=(u<<1)+(u<<3)+(fc^48),fc=getchar();
    return u*t;
}
inline void print(int u)
{
	if(u<0) putchar('-'),u=-u;
	if(u>9) print(u/10);
	putchar(u%10+'0');
}
inline void add(int u,int v){e[++tot].v=v,e[tot].nxt=head[u];head[u]=tot;}
inline void dfs1(int u,int ff)
{
	fa[u]=ff,dep[u]=dep[ff]+1,si[u]=1;
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].v;
		if(v==ff) continue;
		dfs1(v,u);si[u]+=si[v];
		if(si[v]>si[son[u]]) son[u]=v;
	}
}
inline void dfs2(int u,int topf)
{
	top[u]=topf,dfn[u]=++cnt;id[cnt]=si[u];
	if(son[u]) dfs2(son[u],topf);
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].v;
		if(v==fa[u]||v==son[u]) continue;
		dfs2(v,v);
	}
}
inline void pushson(int p,int k){t[p].lz+=k;t[p].s=(t[p].s+len*k);}
inline void pushdown(int p){pushson(ls,t[p].lz),pushson(rs,t[p].lz);t[p].lz=0;}
inline void build(int p,int l,int r)
{
	t[p].l=l,t[p].r=r,t[p].s=0,t[p].lz=0;
	if(l==r){t[p].s=id[l];return;}
	build(ls,l,mid),build(rs,mid+1,r);
	t[p].s=t[ls].s+t[rs].s;
}
inline void modify(int p,int l,int r,int s,int e,int k)
{
	if(l>=s&&r<=e){pushson(p,k);return;}
	pushdown(p);
	if(mid>=s) modify(ls,l,mid,s,e,k);
	if(mid<e) modify(rs,mid+1,r,s,e,k);
	t[p].s=t[ls].s+t[rs].s;
}
inline int query(int p,int l,int r,int s,int e)
{
	if(l>=s&&r<=e) return t[p].s;
	pushdown(p);int res=0;
	if(mid>=s) res=query(ls,l,mid,s,e);
	if(mid<e) res=(res+query(rs,mid+1,r,s,e))%mod;
	return res;
}
inline int query(int x,int y)
{
	int res=0;
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]]) x^=y,y^=x,x^=y;
		res=(res+query(1,1,n,dfn[top[x]],dfn[x]))%mod;x=fa[top[x]];
	}
	if(dep[x]>dep[y]) x^=y,y^=x,x^=y;
	return (res+query(1,1,n,dfn[x],dfn[y]))%mod;
}
inline void modify(int x,int y,int k)
{
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]]) x^=y,y^=x,x^=y;
		modify(1,1,n,dfn[top[x]],dfn[x],k);
		x=fa[top[x]];
	}
	if(dep[x]>dep[y]) x^=y,y^=x,x^=y;
	modify(1,1,n,dfn[x],dfn[y],k);
}
signed main()
{
	n=read();
	for(int i=1,u,v;i<n;i++) u=read(),v=read(),add(u,v),add(v,u);
	for(int i=1;i<=n;i++) w[i]=read(),q.push(mp(w[i],i));
	dfs1(1,0),dfs2(1,1),build(1,1,n);
	while(!q.empty())
	{
		int x=q.top().fi,y=q.top().se;q.pop();
		ans=(query(1,y)%mod*x%mod+ans)%mod;
		modify(1,y,-1);
	}print(ans);
	return 0;
}
```
## 更新（24.2.2）
原本我以为，我写完这个冷门树剖题的题解就不会再与这题相见了。

结果就在今天上午的模拟赛里的 G 题就和这题基本没有区别。

只是从求最大价值变为了最小价值，并且询问每个点对总答案的贡献。

很快啊，我就开始想树剖做法了。

然后发现树剖他是通过离线合并了统计答案的过程来做的，所以无法完成每个点的询问。

这下就给我气到了，出了个原题可用树剖的题还把我最喜欢的树剖做法卡了。

于是脑子就被我扔掉了，我们考虑使用启发式合并平衡树来解决这个问题。

怎么启发式呢，考虑用重链剖分来启发式合并，因为重儿子有着子树大小至少为一半的特性。

所以我们的复杂度是有保证的，为 $O(n\log^2n)$。

这下就做完了，实现稍微有点难度，可以见代码。

这里给出的代码是我赛场的时候写的，赛场那题是多测，先读点权再读边的。

这里的傻逼作者没写 FHQ 的原因是因为不会，学过 Splay 的原因是因为学了 LCT。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=500010,mod=0x3f3f3f3f3f3f3f3f,INF=0x3f3f3f3f3f3f3f3f;
struct edge{int nxt,v;}e[N<<1];
struct node{int ch[2],si,cnt,ff,s,w;}t[N];
int n,m,tot,rt,s,Ans,cnt;
int head[N],ans[N],a[N],son[N],si[N];
vector<int> v;
static char buf[1000000],*paa=buf,*pd=buf;
#define getchar() paa==pd&&(pd=(paa=buf)+fread(buf,1,1000000,stdin),paa==pd)?EOF:*paa++
inline int read(void){
    int u(0),t(1);char fc(getchar());
    while(!isdigit(fc)){if(fc=='-') t=-1;fc=getchar();}
    while(isdigit(fc)) u=(u<<1)+(u<<3)+(fc^48),fc=getchar();
    return u*t;
}
inline void print(int u)
{
	if(u<0) putchar('-'),u=-u;
	if(u>9) print(u/10);
	putchar(u%10+'0');
}
void add(int u,int v){e[++cnt].v=v;e[cnt].nxt=head[u];head[u]=cnt;}
void update(int x)
{
	t[x].si=t[t[x].ch[0]].si+t[t[x].ch[1]].si+t[x].cnt;
	t[x].s=(t[x].w*t[x].cnt+t[t[x].ch[0]].s+t[t[x].ch[1]].s)%mod;
}
void rotate(int x)
{
	int y=t[x].ff,z=t[y].ff,k=t[y].ch[1]==x;
	t[z].ch[t[z].ch[1]==y]=x;t[x].ff=z;
	t[y].ch[k]=t[x].ch[k^1];
	t[t[x].ch[k^1]].ff=y;
	t[x].ch[k^1]=y;t[y].ff=x;
	update(y),update(x);  
}
void Splay(int x,int f)
{
	while(t[x].ff!=f)
	{
		int y=t[x].ff,z=t[y].ff;
		if(z!=f)(t[y].ch[1]==x)^(t[z].ch[1]==y)?rotate(x):rotate(y);
		rotate(x);
	}
	if(f==0) rt=x;
}
void insert(int x)
{
	int u=rt,ff=0;
	while(u&&t[u].w!=x) ff=u,u=t[u].ch[x>t[u].w];
	if(u) t[u].cnt++;
	else
	{
		u=++tot;
		if(ff) t[ff].ch[x>t[ff].w]=u;
		t[u].ch[1]=t[u].ch[0]=0;
		t[u].si=t[u].cnt=1;
		t[u].s=t[u].w=x,t[u].ff=ff;
	}
	Splay(u,0);
}
void dfs1(int x,int f)
{
	si[x]=1;
	for(int i=head[x];i;i=e[i].nxt)
	{
		int v=e[i].v;
		if(v==f) continue;
		dfs1(v,x);si[x]+=si[v];
		if(si[v]>si[son[x]]) son[x]=v;
	}
}
void ad(int x,int f)
{
	v.push_back(a[x]);
	for(int i=head[x];i;i=e[i].nxt)
	{
		int v=e[i].v;
		if(v==f||v==s) continue;
		ad(v,x);
	}
}
void dfs2(int x,int f,int opt)
{
	for(int i=head[x];i;i=e[i].nxt)
	{
		int v=e[i].v;
		if(v==f||v==son[x]) continue;
		dfs2(v,x,0);
	}
	if(son[x]) dfs2(son[x],x,1),s=son[x];
	v.clear();ans[x]=(ans[x]+ans[son[x]])%mod;ad(x,f);
	for(int i=0;i<(int)v.size();i++) insert(v[i]),ans[x]+=(((t[t[rt].ch[0]].si+t[rt].cnt)*t[rt].w%mod)+t[t[rt].ch[1]].s)%mod;
	if(!opt) 
	{
		v.clear(),rt=tot=0;
		t[0].ch[1]=t[0].ch[0]=0;
		t[0].si=t[0].cnt=0;
		t[0].s=t[0].w=0,t[0].ff=0;
	}
}
signed main()
{
	int T=read();
	while(T--)
	{
		n=read();memset(head,0,sizeof head);memset(ans,0,sizeof ans);memset(son,0,sizeof son);cnt=0;v.clear(),rt=tot=0;
		for(int i=1;i<=n;i++) a[i]=-read();
		for(int i=1,x,y;i<n;i++) x=read(),y=read(),add(x,y),add(y,x);
		dfs1(1,0);dfs2(1,0,1);
		for(int i=1;i<=n;i++) print(-ans[i]),putchar(' ');puts("");
	}
	return 0;
}
```
## 后记
虽然赛场上我是给这题写出来了，但是因为做法巨复杂，所以喜提最抽象解。

听讲课的时候我才发现，原来 G 题他有个题目条件保证为二叉树，所以可以直接上树状数组，而且正常还可以用线段树合并。

还有个傻逼赛场上写的时候没有清空重儿子数组一直 TLE 0，卡了半小时，我不说是谁啊。

---

## 作者：斜揽残箫 (赞：4)

## Description

自行看题面，这个人语文不好，无法描述。

感觉看下面样例解释那张图更好理解。

其实我题面没看懂。。。

## Solution

这里提供一下树剖 + 线段树的 $O(n \log ^ 2 n)$ 的做法。

跑的挺快的，不像别的大佬说的那样会被卡，最大的一个点不吸氧跑了 $\text{988ms}$ ~~(那你还说很快)~~。

首先肯定会有一个贪心的思路，我们对于每棵子树，肯定是要先加最大的子节点的权值，因为每次加上一个，节点个数就少 $1$，先乘上大的数肯定比先乘上小的数要优。

所以，肯定会有一个暴力的思路，枚举 $1 \sim n$，之后枚举子树内的节点，因为树剖后的 dfs 序是连续的，用 $siz$ 表示一个子树包含的节点个数，总的时间复杂度大概是 $O( \sum siz(n) \log siz(n))$，最坏的时间复杂度应该是 $O(n ^ 2 \log n)$，沦为和暴力同分。

所以，我们转换一下思想，从先统计子树内的权值，再相加，变为统计一个点被使用的次数。

![](https://cdn.luogu.com.cn/upload/pic/7980.png)

比如这张图，我们一开始的思想是枚举每个节点的子树内的点，之后再相加。

现在，我们从大到小枚举每个点的权值。

首先是 $3$ 号节点，发现这个点在 $\text{1 5 3}$ 的子树中，能取得的值是 $(5 + 3 + 1) \times 10 = 90$。

之后是 $2$ 号节点，在 $\text{1 2}$ 子树中，$(4 + 1) \times 9 = 45$。

$5$ 号节点，在 $\text{1 5}$ 子树中，$(3 + 2) \times 7 = 35$。

$4$ 号节点，在 $\text{1 5 4}$ 子树中，$(2 + 1 + 1) \times 4 = 16$。

$1$ 号节点，在 $\text{1}$ 子树中，$1 \times 3 = 3$。

总和为 $90 + 45 + 35 + 16 + 3 = 189$。

因为能包含一个点的子树肯定是从这个点本身到 $1$ 号节点（根节点）的子树，所以我们可以每次查询一条从当前节点到 $1$ 号节点的链上的数的总和乘上当前节点的权值。

那我们如何把这个点删去呢，很简单，从把当前节点到 $1$ 节点的链上的数都减 $1$ 即可。

总体来说就是 ：

+ 树剖剖链。
+ 建树，节点初值为子树内的节点个数。
+ 用一个堆，存储节点信息和权值，从大到小枚举，查询当前节点到 $1$ 节点的链上的总和乘上当前点的权值，之后把这条链上的点的值都减 $1$。
+ 输出答案。

由于这个人树状数组学的不是很好，所以用的线段树实现。

温馨提示 ： 查询链上的总和时要先取模再与权值相乘，否则会爆 $\text{long long}$。

## Code

```
#include <cstdio>
#include <cmath>
#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>
#include <queue>
#define int long long
using namespace std;
const int mod = 1e9 + 7;
const int Maxk = 5e5 + 10; 
int n,cnt;
int dfn[Maxk],tot[Maxk],son[Maxk];
int fa[Maxk],top[Maxk],deep[Maxk];
vector <int> E[Maxk << 1];
struct aaa {
  int val,id;
  inline bool operator < (const aaa &z) const {
    return val < z.val;
  }
};
int Ans = 0;
priority_queue <aaa> qp;
int a[Maxk],b[Maxk];
struct SegTree {
  int l,r,val,tag,Len;
}t[Maxk << 2];
inline int read()
{
	int s = 0, f = 0;char ch = getchar();
	while (!isdigit(ch)) f |= ch == '-', ch = getchar();
	while (isdigit(ch)) s = s * 10 + (ch ^ 48), ch = getchar();
	return f ? -s : s;
}
void dfs1(int x,int f)
{
  deep[x] = deep[f] + 1;
  fa[x] = f;
  tot[x] = 1;
  for(int i = 0;i < E[x].size();i ++) {
    int y = E[x][i];
    if(y == f) continue;
    dfs1(y,x);
    tot[x] += tot[y];
    if(tot[y] > tot[son[x]]) son[x] = y;
  }
}
void dfs2(int x,int tf)
{
  top[x] = tf;
  dfn[x] = ++ cnt;
  b[cnt] = tot[x];
  if(!son[x]) return;
  dfs2(son[x],tf);
  for(int i = 0;i < E[x].size();i ++) {
    int y = E[x][i];
    if(!dfn[y]) dfs2(y,y); 
  } 
}
void Build(int i,int l,int r)
{
  t[i].l = l,t[i].r = r;
  t[i].Len = r - l + 1;
  if(l == r) {
    t[i].val = b[l];
    return;
  }
  int mid = (l + r) >> 1;
  Build(i << 1,l,mid);
  Build(i << 1 | 1,mid + 1,r);
  t[i].val = t[i << 1].val + t[i << 1 | 1].val;
}
void push_down(int i)
{
  if(t[i].tag != 0) {
    t[i << 1].val += t[i].tag * t[i << 1].Len;
    t[i << 1 | 1].val += t[i].tag * t[i << 1 | 1].Len;
    t[i << 1].tag += t[i].tag;
    t[i << 1 | 1].tag += t[i].tag;
    t[i].tag = 0;
  }
}
void Change(int i,int l,int r,int k)
{
  if(t[i].l >= l && t[i].r <= r) {
    t[i].val += (t[i].r - t[i].l + 1) * k;
    t[i].tag += k;
    return;
  }
  push_down(i);
  int mid = (t[i].l + t[i].r) >> 1;
  if(l <= mid) Change(i << 1,l,r,k);
  if(r > mid) Change(i << 1 | 1,l,r,k);
  t[i].val = t[i << 1].val + t[i << 1 | 1].val;
}
int Ask(int i,int l,int r)
{
  if(t[i].l >= l && t[i].r <= r) return t[i].val;
  int Sum = 0;
  push_down(i);
  int mid = (t[i].l + t[i].r) >> 1;
  if(l <= mid) Sum += Ask(i << 1,l,r);
  if(r > mid) Sum += Ask(i << 1 | 1,l,r);
  return Sum;
} 
void Work(int x,int y,int dis) 
{
  int xx = x,yy = y;
  while(top[x] ^ top[y]) {
    if(deep[top[x]] < deep[top[y]]) swap(x,y);
    Ans = (Ans + (Ask(1,dfn[top[x]],dfn[x]) % mod) * dis) % mod;
    x = fa[top[x]];
  }
  if(deep[x] > deep[y]) swap(x,y);
  Ans = (Ans + (Ask(1,dfn[x],dfn[y]) % mod) * dis) % mod;//求值 
  x = xx,y = yy;
  while(top[x] ^ top[y]) {
    if(deep[top[x]] < deep[top[y]]) swap(x,y);
    Change(1,dfn[top[x]],dfn[x],-1);
    x = fa[top[x]];
  }
  if(deep[x] > deep[y]) swap(x,y);//减 1 
  Change(1,dfn[x],dfn[y],-1);
} 
signed main()
{
  n = read();
  for(int i = 1;i <= n - 1;i ++) {
    int x = read(),y = read();
    E[x].push_back(y);
    E[y].push_back(x);
  }
  aaa res;
  for(int i = 1;i <= n;i ++) a[i] = read(),res.val = a[i],res.id = i,qp.push(res);
  dfs1(1,0);
  dfs2(1,1);
  Build(1,1,n);
  while(!qp.empty()) {
    aaa T = qp.top();
    qp.pop();
    Work(1,T.id,T.val);  
  }
  cout << (Ans % mod)<< endl;
  return 0;
}
```



---

## 作者：zx2003 (赞：4)

有一种做法是考虑点x对答案的贡献，即所有满足$v_i<v_x$的$dep_lca(i,x)$之和。将所有点按码力值排序后，依次将每个点到根的链加一，并把答案加上[（这个点到根的链上的点权和）乘（该点点权）]。用树链剖分实现，复杂度$O(nlog^2n)$。

我的做法是考虑续掉每个点x的收益，$\sum_y v_y*rank_y$，其中y处于x的子树中,$rank_y$是$y$的排名。

加入一个点的贡献即$v_x*rank_x+(n-rank_x)$，如果用平衡树启发式合并，还是$O(nlog^2n)$

如果改成线段树合并，可以快速计算左半区间对右半区间的影响，从而省掉一个log。实际上可能是把时间的log转到了空间上，因为线段树合并的空间是$O(nlogn)$的。

赛后看了看标程，感觉是$O(nlogn)$的时间复杂度，$O(n)$的空间复杂度，很玄妙啊，坐等官方题解。

```cpp
#include<cstdio>
#include<cctype>
#include<algorithm>
using namespace std;
inline char read() {
    static const int IN_LEN = 1000000;
    static char buf[IN_LEN], *s, *t;
    if (s == t) {
        t = (s = buf) + fread(buf, 1, IN_LEN, stdin);
        if (s == t) return -1;
    }
    return *s++;
}
template<class T>
inline void read(T &x) {
    static bool iosig;
    static char c;
    for (iosig = false, c = read(); !isdigit(c); c = read()) {
        if (c == '-') iosig = true;
        if (c == -1) return;
    }
    for (x = 0; isdigit(c); c = read())
        x = (x + (x << 2) << 1) + (c ^ '0');
    if (iosig) x = -x;
}
const int mo=1000000007,N=500005,M=N*19;
struct node{
    int l,r,sum,cnt;
}t[M];
namespace mem{
    int xb,a[M];
    inline void init(){
        for(xb=0;xb<M;++xb)a[xb]=xb;
        --xb;
    }
    inline int New(){
        return a[xb--];
    }
    inline void Del(int x){
        a[++xb]=x;t[x].l=t[x].r=t[x].sum=t[x].cnt=0;
    }
}
int n,i,u,v,a[N],b[N],m,Ans;
pair<int,int> c[N];
int ins(int&i,int l,int r,int x){
    if(!i)i=mem::New();
    ++t[i].cnt,t[i].sum=(t[i].sum+a[x])%mo;
    if(l==r)return 1ll*t[i].cnt*a[x]%mo;
    int m=(l+r)>>1;
    if(x>m)return (ins(t[i].r,m+1,r,x)+1ll*a[x]*t[t[i].l].cnt)%mo;
        else return (ins(t[i].l,l,m,x)+t[t[i].r].sum)%mo;
}
int merge(int x,int y,int l,int r,int&s){
    if(!x || !y){s=0;return x|y;}
    int sl,sr,m=(l+r)>>1;
    if(l<r){
        s=(1ll*t[t[x].l].cnt*t[t[y].r].sum+1ll*t[t[y].l].cnt*t[t[x].r].sum)%mo;
        t[x].l=merge(t[x].l,t[y].l,l,m,sl),t[x].r=merge(t[x].r,t[y].r,m+1,r,sr);
        s=((s+sl)%mo+sr)%mo;
    }else s=1ll*t[x].cnt*t[y].cnt%mo*a[l]%mo;
    t[x].sum=(t[x].sum+t[y].sum)%mo,t[x].cnt+=t[y].cnt;
    mem::Del(y);
    return x;
}
struct tree{
    int h[N],xb,rt[N];
    struct edge{
        int to,next;
    }e[N<<1];
    inline void addedge(){
        e[++xb]=(edge){v,h[u]},h[u]=xb;e[++xb]=(edge){u,h[v]},h[v]=xb;
    }
    int dfs(int x,int fa){
        int ans=0,i,s;
        for(i=h[x];i;i=e[i].next)
            if(e[i].to!=fa)ans=(ans+dfs(e[i].to,x))%mo,rt[x]=merge(rt[x],rt[e[i].to],1,m,s),ans=(ans+s)%mo;
        ans=(ans+ins(rt[x],1,m,b[x]))%mo;
        Ans=(ans+Ans)%mo;
        return ans;
    }
}T;
int main(){
    //freopen("1.txt","r",stdin);
    //freopen("2.txt","w",stdout);
    read(n);
    mem::init();
    for(i=1;i<n;++i){
        read(u),read(v);
        T.addedge();
    }
    for(i=1;i<=n;++i)read(a[i]),c[i]=make_pair(a[i],i);
    sort(c+1,c+n+1);
    for(i=1;i<=n;++i)
        a[b[c[i].second]=m+=i==1 || c[i-1].first<c[i].first]=c[i].first;
    T.dfs(1,0);
    printf("%d\n",Ans);
    return 0;
}
```
这是此题目前洛谷最快的代码


---

## 作者：AMlhd (赞：1)

### 1. 怎么想？

本题非常好想的一点，就是“续掉每一个 aaa 的最大值”。看题目给的样例解释就可以知道：续掉每一个 aaa 的最大值就是其子树内的所有数从小到大排序，再将每个数乘上它的排名，最后加和就可以了。当时看到其他题解，这里是真的没懂，于是给出下面的形式化的解释：

对于一个节点，设其子树（包含自身）内的各个节点的值分别为 $x_1, x_2, x_3, \dots , x_n$，其从小到大的排列为 $a_1, a_2, a_3, \dots , a_n$。则这个节点的最大贡献即为：

$$
contribute_i = \sum\limits_{i = 1}^n (a_i\times i)
$$

但是对每一课子树进行操作，那空间不得爆炸？

所以我们这么来考虑：

首先明确一点，本题中，我们用 $tree_p$ 来表示每一个树上的节点的权值，也就是其子树的大小；用 $wt_p$ 表示输入中每一个点的权值大小，也就是 aaa 的码力值。

1. 对于所有节点中权值最大的节点，在所有的子树中，他都是最大的，所以他对总和的贡献就是它的所有父亲和祖父节点的 $tree$ 值的总和。
2. 然后，对于最大的，我们要将其删去。但是怎么删掉呢？很好想的一点就是将它的所有父亲节点的子树的大小减一。因为一个数的贡献只和它在每个子树内的排名有关，所以，只要将比一个数大的所有节点先考虑完，这个节点就可以直接看作当前的最大的节点了。

所以，我们可以这么来写：

### 2. 怎么写？

根据上面的思路，我们列出以下的步骤：

1. 建树，按照题目的输入构建边的关系。初始值赋为其子树的大小。
2. 将每一个节点的题目输入的值从大到小排序，并依次考虑。每做完一个节点，就将其到根节点的路径上的所有节点的 $tree_p$ 减一，其贡献就是减一之前的路径上的所有节点的权值之和乘以其输入的数值（这个地方真的很绕，强烈建议看代码中的 main 函数来理解），用公式来说就是：

$$
contribute_p = (\sum\limits_{i \in S} tree_i) \times wt_p
$$

### 3. 将答案累加，最后输出。

下面是快乐的代码时间：

```cpp
#include <bits/stdc++.h>

#define N 1000010
#define ENDL putchar('\n')

#define mid ((l + r) >> 1)
#define ls (p << 1)
#define rs (p << 1 | 1)

#define gc() getchar()
using namespace std;

int n, r, MOD;
int nxt[N], head[N], to[N], w[N];
int top[N];
int si[N], fa[N], id[N], son[N], wt[N], dep[N];
int cnt = 0, e = 0;
int tree[N << 2], siz[N << 2], lazy[N << 2];

struct node {
    int val, id;
}a[N];

inline int read() {
    int x = 0, f = 1;
    char ch = gc();
    while(ch < '0' || ch > '9') {
        if(ch == '-') {
            f = -1;
        }
        ch = gc();
    }
    while(ch >= '0' && ch <= '9') {
        x = (x << 3) + (x << 1) + (ch ^ 48);
        ch = gc();
    }
    return x * f;
}

inline void write(int x) {
    if(x < 0) {
        putchar('-');
        x = -x;
    }
    if(x > 9)
        write(x / 10);
    putchar(x % 10 + '0');
}


inline void add(int &a, int b) {
    a = (a + b) % MOD;
}


inline void upd(int p) {
    tree[p] = (tree[ls] + tree[rs]) % MOD;
}

inline void upds(int p) {
    siz[p] = siz[ls] + siz[rs];
}

inline void pushd(int p) {
    if(!lazy[p])
        return;

    add(tree[ls], siz[ls] * lazy[p] % MOD);
    add(tree[rs], siz[rs] * lazy[p] % MOD);

    add(lazy[ls], lazy[p]);
    add(lazy[rs], lazy[p]);

    lazy[p] = 0;
}

inline void build(int p, int l, int r) {
    if(l == r) {
        tree[p] = wt[l];
        siz[p] = 1;
        lazy[p] = 0;
        return;
    }
    build(ls, l, mid);
    build(rs, mid + 1, r);
    upd(p);
    upds(p);
}

inline void mdf(int p, int l, int r, int ql, int qr, int x) {
    if(ql <= l && r <= qr) {
        add(tree[p], siz[p] * x % MOD);
        add(lazy[p], x);
        return;
    }
    pushd(p);
    if(ql <= mid) {
        mdf(ls, l, mid, ql, qr, x);
    }
    if(qr > mid) {
        mdf(rs, mid + 1, r, ql, qr, x);
    }
    upd(p);
}

inline long long qry(int p, int l, int r, int ql, int qr) {
    if(ql <= l && r <= qr) {
        return tree[p];
    }
    pushd(p);
    int sum = 0;
    if(ql <= mid) {
        add(sum, qry(ls, l, mid, ql, qr));
    }
    if(qr > mid) {
        add(sum, qry(rs, mid + 1, r, ql, qr));
    }
    return sum;
}


inline void add_edge(int u, int v) {
    nxt[++e] = head[u];
    head[u] = e;
    to[e] = v;
}

inline void dfs1(int p, int pre, int depth) {
    dep[p] = depth;
    fa[p] = pre;
    si[p] = 1;
    int maxx = -1;

    for(int i = head[p]; i; i = nxt[i]) {
        int v = to[i];
        if(v != pre) {
            dfs1(v, p, depth + 1);
            si[p] += si[v];
            if(si[v] > maxx) {
                maxx = si[v];
                son[p] = v;
            }
        }
    }
}

inline void dfs2(int p, int topp) {
    id[p] = ++cnt;
    wt[id[p]] = si[p];
    top[p] = topp;
    if(!son[p])
        return;
    dfs2(son[p], topp);
    for(int i = head[p]; i; i = nxt[i]) {
        int v = to[i];
        if(v != son[p] && v != fa[p]) {
            dfs2(v, v);
        }
    }
}


inline void modify1(int l, int r, int x) {
    x %= MOD;
    while(top[l] != top[r]) {
        if(dep[top[l]] < dep[top[r]]) {
            swap(l, r);
        }
        mdf(1, 1, n, id[top[l]], id[l], x);
        l = fa[top[l]];
    }
    if(dep[l] > dep[r])
        swap(l, r);
    mdf(1, 1, n, id[l], id[r], x);
}

inline int query1(int l, int r) {
    int sum = 0;
    while(top[l] != top[r]) {
        if(dep[top[l]] < dep[top[r]]) {
            swap(l, r);
        }
        add(sum, qry(1, 1, n, id[top[l]], id[l]));
        l = fa[top[l]];
    }
    if(dep[l] > dep[r])
        swap(l, r);
    add(sum, qry(1, 1, n, id[l], id[r]));
    return sum;
}

inline bool cmp(node x, node y) {
    return x.val > y.val;
}

signed main() {

    n = read();
    r = 1;
    MOD = 1000000007;
    int u, v;
    
    for(int i = 1; i <= n - 1; ++i) {
        
        u = read();
        v = read();
        add_edge(u, v);
        add_edge(v, u);
    }

    for(int i = 1; i <= n; ++i) {
        a[i].val = read();
        a[i].id = i;
    }

    sort(a + 1, a + n + 1, cmp);

    dfs1(r, 0, 1);
    dfs2(r, r);

    build(1, 1, n);

    long long ans = 0;

    for(int i = 1; i <= n; ++i) {
        ans += 1ll * a[i].val * query1(1, a[i].id) % MOD;
        ans %= MOD;
        modify1(1, a[i].id, -1);
    }

    write(ans);
    ENDL;

    return 0;
}
```

---

## 作者：aulive (赞：1)

~~关于本人看了十多分钟才看懂题面这件事~~
## 线段树+树链剖分写法
#  题目分析
对于此题，我们有一个很显然的贪心思想：根据题目的描述我们很容易发现，队列中越靠前的数产生贡献的次数越多，在子树中按照节点的价值从大到小来安排队伍的先后顺序，令 $val_1\geq val_2\geq \dots\geq val_n$，  
则该子树的总贡献为 $val_1\times n+val_2\times (n-1)+\dots+val_{n-1}\times 2+val_n$， 
枚举所有子树相加得到答案。  
朴素写法复杂度为 $O(n^2\log n)$，期望 30 分。   
我们可以转变一下思路，求出每个点在所有子树中的总贡献，仿照上面的贪心思想，我们可以先处理码力值最大的点，而这个点只能对它到根节点路径上的子树产生贡献，如图：

 ![](https://cdn.luogu.com.cn/upload/pic/7980.png)
 
 那么我们可以一个列出表格来探讨一下 ~~（大眼观察法）~~ 　　
 
![](https://cdn.luogu.com.cn/upload/image_hosting/qtolszks.png)

#### （表格中表示的是操作节点是该根节点子树贡献的加权，粗体是对哪个子树产生了贡献）
可以发现对于每一个节点在操作后都会让该节点到根节点路径上的点的权值减一，那么我们就可以将问题转化成：
1. 给你一颗树,有如下两个操作；
2. 对于第一个操作：给定一个节点，求出这个节点到 1 的距离；
3. 对于第二个操作：给定一个节点，将这个节点到 1 的路径上的点权减一；
4. 最后的结果便是：每个点的码力值 $\times$ 出现次数 （ 即求出的距离 ）。  

算法复杂度为 $O(n \log^2 n)$，理论上可以 AC 本题。  
tips：不开 long long 见祖宗。

# 题目代码  

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1e9+7;
const int maxn=5e5;
int n,ys[maxn+5],dept[maxn+5],x,y,mem[maxn+5],top[maxn+5],fa[maxn+5],son[maxn+5],size[maxn+5],tot;
vector <int> rood[maxn+5];
struct node{
	int val,id;
}a[maxn+5];
int cmp(node a,node b){
	return a.val>b.val;
}
struct tr{
	int lef,rig,add,sum;
}tree[maxn<<2|1];
void dfs1(int now,int fat){
	fa[now]=fat;
	dept[now]=dept[fat]+1;
	size[now]=1;
	for(int i=0;i<rood[now].size();i++){
		int to=rood[now][i];
		if(to==fat)continue;
		dfs1(to,now);
		size[now]+=size[to];
		if(size[son[now]]<size[to]){
			son[now]=to;
		}
	}
}
void dfs2(int now,int topf){
	top[now]=topf;
	ys[now]=++tot;
	mem[ys[now]]=size[now];
	if(!son[now])return;
	dfs2(son[now],topf);
	for(int i=0;i<rood[now].size();i++){
		int to=rood[now][i];
		if(top[to])continue;
		dfs2(to,to);
	}
}//树剖部分
void pushup(int now){
	tree[now].sum=tree[now<<1].sum+tree[now<<1|1].sum;
}
void build(int now,int lef,int rig){
	tree[now].lef=lef,tree[now].rig=rig;
	if(lef==rig){
		tree[now].sum=mem[lef];
		return;
	}
	int mid=lef+rig>>1;
	build(now<<1,lef,mid);
	build(now<<1|1,mid+1,rig);
	pushup(now);
}
void pushdown(int now){
	if(tree[now].add){
		tree[now<<1].add+=tree[now].add;
		tree[now<<1|1].add+=tree[now].add;
		tree[now<<1].sum=tree[now<<1].sum+(tree[now<<1].rig-tree[now<<1].lef+1)*tree[now].add;
		tree[now<<1].sum%=mod;
		tree[now<<1|1].sum=tree[now<<1|1].sum+(tree[now<<1|1].rig-tree[now<<1|1].lef+1)*tree[now].add;
		tree[now<<1|1].sum%=mod;
		tree[now].add=0;
	}
}
void modify(int now,int lef,int rig,int add){
	if(lef<=tree[now].lef&&tree[now].rig<=rig){
		tree[now].add+=add;
		tree[now].sum+=add*(tree[now].rig-tree[now].lef+1)%mod;
		tree[now].add%=mod;
		tree[now].sum%=mod;
		return;
	}
	pushdown(now);
	int mid=tree[now].lef+tree[now].rig>>1;
	if(lef<=mid){
		modify(now<<1,lef,rig,add);
	}
	if(mid<rig){
		modify(now<<1|1,lef,rig,add);
	}
	pushup(now);
}
int query(int now,int lef,int rig){
	if(lef<=tree[now].lef&&tree[now].rig<=rig){
		return tree[now].sum;
	}	
	pushdown(now);
	int mid=tree[now].lef+tree[now].rig>>1;
	int res=0;
	if(lef<=mid){
		res+=query(now<<1,lef,rig);
	}
	if(mid<rig){
		res+=query(now<<1|1,lef,rig);
	}
	return res%mod;
}//线段树
int tree_query(int x,int y){
	int res=0;
	while(top[x]!=top[y]){
		if(dept[top[x]]<dept[top[y]])swap(x,y);
		res+=query(1,ys[top[x]],ys[x]);
		res%=mod;
		x=fa[top[x]];
	}
	if(dept[x]>dept[y])swap(x,y);
	res+=query(1,ys[x],ys[y]);
	return res%mod;
}
void tree_modify(int x,int y,int add){
	while(top[x]!=top[y]){
		if(dept[top[x]]<dept[top[y]])swap(x,y);
		modify(1,ys[top[x]],ys[x],add);
		x=fa[top[x]];
	}
	if(dept[x]>dept[y])swap(x,y);
	modify(1,ys[x],ys[y],add);
}
signed main(){
	cin>>n;
	for(int i=1;i<n;i++){
		cin>>x>>y;
		rood[x].push_back(y);
		rood[y].push_back(x);
	}
	for(int i=1;i<=n;i++){
		cin>>a[i].val;
		a[i].id=i;
	}
	sort(a+1,a+1+n,cmp);
	dfs1(1,0);
	dfs2(1,1);
	build(1,1,n);
	int ans=0;
	for(int i=1;i<=n;i++){
		ans+=tree_query(a[i].id,1)*a[i].val;//求出每个节点的总贡献
		ans%=mod;//注意取模
		tree_modify(a[i].id,1,-1);//给到根节点路径上的权值减一
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：FutaRimeWoawaSete (赞：1)

很明显这道题是一个树上统计问题。  
翻译题意：以每个点为根处理 $n$ 棵树，  
记一棵树的贡献数为树内元素排序好后将它们的值乘上对应的排名之和，  
现在求所有树的贡献之和。  
一说到树上统计问题，我们就想到许多东西：树上启发式合并，线段树合并，点分治，树剖……  
在这里看到题目的所求与子树有关，我们果断 $DSU$ 。  
(这里时间复杂度有点小紧张不过实测能过)  
很明显我们想要维护一个每一队 $aaa$ 我们肯定还需要一个数据结构来维护，  
在这里我想到了平衡树，  
并且在冥思苦想 $30min$ 后也还是只想到了怎么打平衡树……  
首先我们考虑将一颗子树内的每个 $aaa$ 往平衡树里面塞，  
把它旋转到根节点后根据 $BST$ 性质我们知道左子树的值此时小于根节点的值，右子树的值大于根节点的值，  
所以说我们当前这个 $aaa$ 的贡献就是根节点左子树大小与 $root$ 这个值出现多少次之和乘上这个值：  
```cpp
(t[t[root].ch[0]].size + t[root].cnt) * t[root].val
```
由于右子树的所有排名都需要加 $1$ 。  
所以说还要加上右子树的所有值之和。  
```cpp
t[t[root].ch[1]].sum
```
于是这道题的思路就完了。  
难点在于实现，这里就说一下我所碰到的问题吧。  
```
1.每次统计时直接 vector 存一遍然后统计，记得在统计完重儿子后要清空 vector .   
2.注意统计 sum 时要加上当前节点值乘上当前节点的个数.  
3.清空平衡树直接 tot = root = 0 即可，不然一个个删可能T飞警告.  
```
$平衡树 + DSU$ 的题确实很烦，很难调，所以拿出耐心吧……  
应该是第一篇 $DSU + 平衡树$ 的题解。  
```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
using namespace std;
const int Len = 5e5 + 5,Inf = 1e9,mod = 1e9 + 7;
vector<long long> v;
int head[Len],cnt;
int m,tot,root;
struct Node
{
	int next,to;
}edge[Len << 1];
void add(int from,int to)
{
	edge[++ cnt].to = to;
	edge[cnt].next = head[from];
	head[from] = cnt;
}
struct node
{
	int ch[2],size,cnt,ff;
	long long sum,val;
}t[Len];
void update(int x){
	t[x].size = t[t[x].ch[0]].size + t[t[x].ch[1]].size + t[x].cnt;
	t[x].sum = (t[x].val * t[x].cnt + t[t[x].ch[0]].sum + t[t[x].ch[1]].sum) % mod;
}
void rotate(int x)
{
	int y = t[x].ff , z = t[y].ff , k = t[y].ch[1] == x;
	t[z].ch[t[z].ch[1] == y] = x;
	t[x].ff = z;
	//
	t[y].ch[k] = t[x].ch[k ^ 1];
	t[t[x].ch[k ^ 1]].ff = y;
	//
	t[x].ch[k ^ 1] = y;
	t[y].ff = x;
	update(y) , update(x);  
}
void Splay(int x,int goal)
{
	while(t[x].ff != goal)
	{
		int y = t[x].ff , z = t[y].ff;
		if(z != goal) (t[y].ch[1] == x) ^ (t[z].ch[1] == y) ? rotate(x) : rotate(y);
		rotate(x);
	}
	if(goal == 0) root = x;
}
void insert(int x)
{
	int u = root , ff = 0;
	while(u && t[u].val != x) ff = u , u = t[u].ch[x > t[u].val];
	if(u) t[u].cnt ++;
	else
	{
		u = ++ tot;
		if(ff) t[ff].ch[x > t[ff].val] = u;
		t[u].ch[1] = t[u].ch[0] = 0;
		t[u].size = t[u].cnt = 1;
		t[u].sum = t[u].val = x , t[u].ff = ff;
	}
	Splay(u , 0);
}
long long ans[Len],Ans,a[Len];
int n,son[Len],siz[Len];
int Son,cnts;
void dfs1(int x,int f)
{
	siz[x] = 1;
	int maxson = -1;
	for(int e = head[x] ; e ; e = edge[e].next)
	{
		int to = edge[e].to;
		if(to == f) continue;
		dfs1(to , x);
		siz[x] += siz[to];
		if(siz[to] > maxson) maxson = siz[to] , son[x] = to;
	}
}
void Add(int x,int f)
{
	v.push_back(a[x]);
	for(int e = head[x] ; e ; e = edge[e].next)
	{
		int to = edge[e].to;
		if(to == f || to == Son) continue;
		Add(to , x);
	}
}
void dfs2(int x,int f,int opt)
{
	for(int e = head[x] ; e ; e = edge[e].next)
	{
		int to = edge[e].to;
		if(to == f || to == son[x]) continue;
		dfs2(to , x , 0);
	}
	if(son[x]) dfs2(son[x] , x , 1) , Son = son[x];
	v.clear();
	ans[x] = (ans[x] + ans[son[x]]) % mod;
	Add(x , f);
//	printf("%d %lld\n",x,ans[x]);
	for(int i = 0 ; i < v.size() ; i ++)
	{
		insert(v[i]);
//		printf("%lld %d %d %lld %lld\n",v[i],t[root].size,t[t[root].ch[0]].size + t[root].cnt,t[root].val,t[t[root].ch[1]].sum);
		ans[x] += (((long long)(t[t[root].ch[0]].size + t[root].cnt) * t[root].val % mod) + t[t[root].ch[1]].sum) % mod;
		ans[x] %= mod;
	}
//	printf("%d %lld\n",x,ans[x]);
	if(!opt) 
	{
		v.clear() , root = tot = 0;
		t[0].ch[1] = t[0].ch[0] = 0;
		t[0].size = t[0].cnt = 0;
		t[0].sum = t[0].val = 0 , t[0].ff = 0;
	}
}
signed main()
{
	scanf("%d",&n);
	for(int i = 1 ; i < n ; i ++)
	{
		int x,y;
		scanf("%d %d",&x,&y);
		add(x , y) , add(y , x);
	}
	for(int i = 1 ; i <= n ; i ++) scanf("%lld",&a[i]);
	dfs1(1 , 0);
	dfs2(1 , 0 , 1);
	for(int i = 1 ; i <= n ; i ++) Ans = (Ans + ans[i]) % mod;
	printf("%lld\n",Ans);
	return 0;
}
```

---

## 作者：JK_LOVER (赞：1)

## 题意
给你一棵树，求它的续掉全部的aaa之后最多能获得的码力值。先膜楼下 $dalao$ 为敬，然而由于本蒟蒻太菜了，只会数据结构暴力维护。
## 分析
我们发现每个的节点的值会在它和根的路径之间被续掉。而一个值较大的，肯定要尽量多被计算才最优。
### $1$
直接给每个节点开个堆，然后合并堆。暴力算贡献。复杂度为 $O(n^3)$ 。
$$
ans = \sum_{i\in U}(\sum_{j\in son} val[j]\times rank(j))
$$
其中 $rank$ 是 $val[j]$ 在各个父亲的排名。
### $2$
考虑哪些节点加入了当前节点的贡献。
$$
ans = \sum_{i\in U} val[i] \times sum[i]
$$
考虑如何快速求出 $sum[i]$ 。那么我们只要有小到大排序，那么在它与根的路径上已经有过的点的个数 $+$ 路径长度。就是它的 $sum[i]$
$$
sum[i] = \sum_{i\in (1\ to\ u)} (size[i]+1)
$$
那么复杂度为 $O(n^2)$ 。
### $3$
瓶颈在于快速求出 $sum[i]$ 和更新 $size[i]$ 。

- 查询链
- 更改链上的值

这可以用 树链剖分 和 $LCT$ 维护。但是前者用线段树的话时间复杂度为 $O(n\log^2 n)$ ,而且常数挺大的。这里使用 $LCT$ 的 $O(n\log n)$ 做法。这道题小细节还挺多的。

- 如果全开 $long\ long$ 是要 $TLE$ 的。
- 在求 $sum[i]$ 数组时可能要炸，记得取模。

那么现在每次只需要，查询链上的值，和链上值 $+1$ 就可以了。
空间复杂度为 $O(n)$ 。时间复杂度为 $O(n\log n)$ 。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){
    int sum=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){sum=sum*10+ch-'0';ch=getchar();}
    return sum*f;
}
const int N = 501000;
const int mod = 1000000007;
int n,Q;
int c[N][2],f[N],val[N],si[N],add[N],ans,sum[N];
bool r[N];
bool nroot(int x)
{
	return c[f[x]][1] == x || c[f[x]][0] == x;	
} 
void pushr(int x)
{
	swap(c[x][1],c[x][0]);
	r[x]^=1;
}
void pushup(int x)
{
	sum[x] = val[x]+sum[c[x][1]]+sum[c[x][0]];
	sum[x] = (sum[x]*1LL+mod)%mod;
	si[x] = si[c[x][1]] + si[c[x][0]] + 1;
}
void pusha(int x,int d)
{
	val[x] += d;add[x] += d;
	sum[x] += d*si[x];
}
void pushdown(int x)
{
	if(add[x])
	{
		if(c[x][1]) pusha(c[x][1],add[x]);
		if(c[x][0]) pusha(c[x][0],add[x]);
		add[x] = 0;
	}
	if(r[x])
	{
		if(c[x][1]) pushr(c[x][1]);
		if(c[x][0]) pushr(c[x][0]);
		r[x] = 0;
	}
	
}
void push(int x)
{
	if(nroot(x)) push(f[x]);
	pushdown(x);
}

void rotate(int x)
{
	int y = f[x],z = f[y],k = c[y][1] == x,w = c[x][!k];
	if(nroot(y)){c[z][c[z][1] == y] = x;}
	c[y][k] = w;c[x][!k] = y;
	f[x] = z;f[y] = x;
	if(w) f[w] = y;
	pushup(y);
}

void splay(int x)
{
	push(x);
	while(nroot(x))
	{
		int y = f[x],z = f[y];
		if(nroot(y))
		{
			rotate((c[y][1] == x)^(c[z][1] == y)?x:y);
		}
		rotate(x);
		pushup(x);
	}
}
void access(int x)
{
	for(int y = 0;x;x=f[y=x])
	{splay(x);c[x][1] = y;pushup(x);}
}
void makeroot(int x)
{
	access(x);splay(x);pushr(x);
}
void split(int x,int y)
{
	makeroot(x);access(y);splay(y);
}
void link(int x,int y)
{
	makeroot(x);f[x] = y;
}
struct node{
	int id,val;
}A[N];
bool cmp(node x,node y)
{
	return x.val < y.val;
}
signed main()
{
	n = read();
	for(int i = 1;i < n;i++)
	{
		int x = read(),y = read();
		link(x,y);
	}
	for(int i = 1;i <= n;i++)
	A[i].val = read(),A[i].id = i;
	sort(A+1,A+1+n,cmp);
	for(int i = 1;i <= n;i++)
	{
		int u = A[i].id;
		split(1,u);pusha(u,1);
		split(1,u);
		long long size = sum[u];
		ans = (ans+(1LL*size*A[i].val)%mod+mod)%mod;
	}
	cout<<ans<<endl;
}
```

[地址QWQ](https://www.luogu.com.cn/blog/xzc/solution-p3925)


---

## 作者：Nuyoah_awa (赞：0)

### 题目大意

给一棵树，每个点的答案为这个点子树内所有点的点权排序后乘上 $1 \sim size$ 的排列，求所有点答案之和。

### 题目分析

我们对于每个点分开算点权时间复杂度很明显是 $\mathcal O(n^2 \log n)$ 的，很明显过不了，对于这种一个点答案由很多部分组成不可能一一算出的题，很容易想到逆向思维，对于每个部分算它对答案的贡献。

对于本题，我们看每个点只会对这个点到根节点的路径上的点的答案值有贡献，这个贡献值就是这个点分别在这条路上排的排名数之和乘上点权。我们考虑如何算排名和。

我们不妨再回到问题，对于每个点对子树内点权排序。观察一下，发现点权最大的点一定在他所对应的路径上的排序中都排在最后（因为没有比他大的）这样经过维护可能容易计算，并且只有这个点满足这一条件（因为根节点排序最后一定是它）。然后考虑若删掉这个点之后，原来次大的就成为了现在最大的，同时也满足上述条件，于是可以考虑用这个性质透过维护一系列数从而达到快速运算。

所以我们可以考虑从大到小枚举点，对于每个点，我们再设一个数组 $f$，初始的 $f_i = size_i$，然后对于每个点，对答案的贡献即为这个点到根路径上的 $f$ 和乘上点权，同时计算完答案以后，对于这条路径，$f$ 都减一即可为后续的点实现动态维护。然后就是树上路径减法，路径求和，重链剖分即可。时间复杂度即为树剖的时间复杂度 $\mathcal O(n \log ^2 n)$。

### code
```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#define mid ((l+r)>>1)
#define ls (p<<1)
#define rs (ls^1)
#define int long long

using namespace std;

const int N = 5e5 + 5, MOD = 1e9 + 7;
int n, deep[N], sz[N], fa[N], hs[N], dfn[N], rk[N], dfsid;
int top[N], t[N<<2], tag[N<<2], opt, x, y, z, ans;
struct node{
	int id, val;
}p[N];
vector <int> e[N];

bool cmp_val(node x, node y){return x.val > y.val;}

void dfs1(int x, int last)
{
    deep[x] = deep[last] + 1, sz[x] = 1, fa[x] = last;
    for(int i = 0;i < e[x].size();i++)
    {
        if(e[x][i] == last) continue;
        dfs1(e[x][i], x);
        sz[x] += sz[e[x][i]];
        if(sz[e[x][i]] > sz[hs[x]]) hs[x] = e[x][i];
    }
}

void dfs2(int x, int last)
{
    rk[(dfn[x] = ++dfsid)] = x;
    if(hs[x] != 0)
    {
        top[hs[x]] = top[x];
        dfs2(hs[x], x);
    }
    for(int i = 0;i < e[x].size();i++)
    {
        if(e[x][i] == last || e[x][i] == hs[x]) continue;
        dfs2(e[x][i], x);
    }
}

void push_down(int p, int l, int r)
{
    if(tag[p] == 0) return ;
    (t[ls] += (mid - l + 1) * tag[p] % MOD) %= MOD, (tag[ls] += tag[p]) %= MOD;
    (t[rs] += (r - mid) * tag[p] % MOD) %= MOD, (tag[rs] += tag[p]) %= MOD;
    tag[p] = 0;
}
void push_up(int p){t[p] = t[ls] + t[rs];}

void update(int p, int l, int r, int ll, int rr, int val)
{
    if(ll <= l && r <= rr)
    {
        (t[p] += val * (r - l + 1) % MOD) %= MOD;
        (tag[p] += val) %= MOD;
        return ;
    }
    push_down(p, l, r);
    if(ll <= mid)   update(ls, l, mid, ll, rr, val);
    if(rr > mid)    update(rs, mid + 1, r, ll, rr, val);
    push_up(p);
}

int query(int p, int l, int r, int ll, int rr)
{
    if(ll <= l && r <= rr)
        return t[p];
    int res = 0;
    push_down(p, l, r);
    if(ll <= mid)   (res += query(ls, l, mid, ll, rr)) %= MOD;
    if(rr > mid)    (res += query(rs, mid + 1, r, ll, rr)) %= MOD;
    return res;
}

void add(int x, int y, int z)
{
    while(top[x] != top[y])
    {
        if(deep[top[x]] < deep[top[y]])
            swap(x, y);
        update(1, 1, n, dfn[top[x]], dfn[x], z);
        x = fa[top[x]];
    }
    if(deep[x] < deep[y])   swap(x, y);
    update(1, 1, n, dfn[y], dfn[x], z);
}

int solve(int x, int y)
{
    int res = 0;
    while(top[x] != top[y])
    {
        if(deep[top[x]] < deep[top[y]])
            swap(x, y);
        (res += query(1, 1, n, dfn[top[x]], dfn[x])) %= MOD;
        x = fa[top[x]];
    }
    if(deep[x] < deep[y])   swap(x, y);
    (res += query(1, 1, n, dfn[y], dfn[x])) %= MOD;
    return res;
}

void build(int p, int l, int r)
{
    if(l == r)
    {
        t[p] = sz[rk[l]] % MOD, tag[p] = 0;
        return ;
    }
    build(ls, l, mid), build(rs, mid + 1, r);
    push_up(p);
}

signed main()
{
    scanf("%lld", &n);
    for(int i = 1, u, v;i < n;i++)
    {
        scanf("%lld %lld", &u, &v);
        e[u].push_back(v);
        e[v].push_back(u);
    }
    for(int i = 1;i <= n;i++)
    {
    	scanf("%lld", &p[i].val);
    	p[i].id = i;
	}
    dfs1(1, 0);
    for(int i = 1;i <= n;i++)   top[i] = i;
    dfs2(1, 0);
    build(1, 1, n);
    sort(p + 1, p + n + 1, cmp_val);
    for(int i = 1;i <= n;i++)
    {
    	(ans += solve(1, p[i].id) * p[i].val % MOD) %= MOD;
    	add(1, p[i].id, -1);
	}
	printf("%lld\n", ans);
    return 0;
}
```

---

## 作者：sgl654321 (赞：0)

模拟赛上遇到类似题，这里来补一发。题解区以树剖做法为主，还有少量平衡树启发式合并，这里我提供一种好懂的线段树合并做法。

这一题也作为自己的线段树合并学习笔记，因此会写的比较详细。


## 题目大意
经过显然的贪心思想转化后，我们得到形式化题意：

给一棵树，每个点有点权，设一个以 $i$ 为根的子树内所有点的点权从小到大排序是 $a_1,a_2,\cdots,a_{siz_i}$，则点 $i$ 的权值为：
$$f_i=\sum_{i=1}^{siz_i} i\times a_i$$

输出 $\sum_{i=1}^nf_i$。

## 解题思路
考虑对每一个节点，在值域 $[1,10^8]$ 上开一棵动态开点权值线段树。

**思考 1**：这个权值线段树中，每个节点我们要记录什么信息？

分别为：

0. 可以记录区间左右端点 $\red {l,r}$，也可以不记录，如果你在递归过程中存储 $l,r$  就不用了;
1. 左儿子，右儿子的编号 $\red {lson,rson}$；
2. 这个区间所代表的权值 $\red {sum}$，即：设这个区间中，存在值分别为 $b_1,b_2,b_3,\cdots,b_{sz}(l\le b_1\le b_2\le b_3\le \cdots \le b_{sz}\le r)$ 的元素，那么 $sum=\sum_{i=1}^{sz} i\times b_i$;
3. 为了 `pushup`，我们还要记录区间中存在值的个数 $\red{cnt}$，即 $2$ 中所设的 $sz$;
4. 为了 `pushup`，我们还要记录区间中所有值的和 $\red s$，即 $2$ 中所设的 $\sum_{i=1}^{sz}b_i$。

****

**思考 2**：我们如何在动态开点线段树中 `pushup`？

首先， $s$ 和 $cnt$ 都非常好转移，直接相加即可。

$s[i]=s[lson]+s[rson].$

$cnt[i]=cnt[lson]+cnt[rson].$

其次我们考虑 $sum$ 应该如何转移。

我们是一个权值线段树，天然的就有左儿子区间中的所有数，小于右儿子区间中的所有数。因此就天然满足了上面**有序**的性质。

根据上文所说，我们要把较大的数放在后面，较小的数放在前面。右子树中的所有数，都向右平移了 $cnt[lson]$ 个单位。

例如左子树中的元素为 $1,3,4$，右子树中的是 $5,8$。那么排序之后，$1,3,4$ 的位置不变，仍然是第一个，第二个和第三个，但是 $5,8$ 的位置都增加了 $cnt[lson]=3$。

因此我们可以得到：

$sum[i]=sum[lson]+sum[rson]+s[rson]\times cnt[lson].$

****

**思考 3**：直接每个点开一棵动态开点权值线段树，空间、时间复杂度是什么？

直接开，时空复杂度都会飙升到 $O(n^2\log n)$ 的级别。因此我们需要考虑使用更高级的数据结构思想来优化这个算法过程。

****

### 线段树合并

对于两棵动态开点线段树 $T_1,T_2$，我们可以把对应位置进行合并，得到一棵新线段树 $T$。

其具体算法过程为：
1. 如果 $T_1,T_2$ 对应位置均为空，那么合并起来的 $T$ 的这个位置也为空；
2. 如果 $T_1,T_2$ 对应位置只有一个有节点，那么合并起来的节点就是这个节点；
3. 如果 $T_1,T_2$ 对应位置都存在节点：
	- 该位置为叶子节点，即区间的 $l=r$，那么直接合并。
   - 该位置为非叶节点，那么分别合并他的左右儿子节点，然后再 `pushup`。

可以证明其时间复杂度为增加的节点总数，即 $O(n\log n)$。


**思考 4**：本题为什么能够使用线段树合并？

因为树这个结构，就存在着合并关系。树中节点 $u$ 的各个子节点的线段树进行合并，然后再并上 $u$ 本身的信息，就成为了 $u$ 这棵线段树的信息。

****
**思考 5**：在本题的线段树合并中，叶子节点如何进行合并？

叶子节点就是 $l=r$ 的节点，即此处的元素值都相等。因此我们可以把 $cnt$ 数组和 $s$ 数组简单的相加，然后根据等差数列求和，$sum=\dfrac{cnt\times(cnt-1)\times l}{2}$。

经过上述思考过程，本题就解决完毕了。我们只需要把所有节点的线段树中的 $sum[root]$ 简单相加即可得到答案。


## 注意点
1. 注意空间限制，最好不要记录 $l,r$，而改成递归中的参数。还有不要乱开 `long long`，该取模的地方乘上 `1ll` 即可。
2. $sum[root]$ 要时时刻刻记录，因为这个信息可能会被覆盖掉。

### 参考代码
我这里使用了结构体存储线段树中的信息。

闲话：一开始全开了 `ll`，后来发现 MLE 了，就直接 `typedef int ll`，很抽象。


```cpp
#include<bits/stdc++.h>
#define maxn 500010
#define maxm 1000010
using namespace std;
typedef int ll;
const ll mod =1e9+7;
int tt,n,x,y,a[maxn],kk,poi[maxn],v[maxm],nex[maxm];
int cnt,root[maxn];
int ans[maxn],ansans;
struct node{
	int lson,rson;
	int cnt,sum,s;
}t[maxn*30];
void add_edge(ll x,ll y){
	kk++;v[kk]=y;nex[kk]=poi[x];poi[x]=kk;
}
void pushup(ll i){
	t[i].s=(t[t[i].lson].s+t[t[i].rson].s)%mod;
	t[i].cnt=(t[t[i].lson].cnt+t[t[i].rson].cnt)%mod;
	t[i].sum=(1ll*t[t[i].rson].s*t[t[i].lson].cnt%mod+t[t[i].rson].sum+t[t[i].lson].sum)%mod;
}
ll xiugai(ll i,ll l,ll r,ll k){
	ll save=i;
	if(i==0)save=++cnt;
	if(l==r){
		t[save].cnt++;
		t[save].s=(t[save].s+k)%mod;
		t[save].sum=(1ll*(t[save].cnt+1)*t[save].cnt/2*k)%mod;
		return save;
	}
	ll mid=(l+r)>>1;
	if(k<=mid)t[save].lson=xiugai(t[save].lson,l,mid,k);
	else t[save].rson=xiugai(t[save].rson,mid+1,r,k);
	pushup(save);
	return save;
}
ll merge(ll x,ll y,ll l,ll r){
	if(!x||!y)return x+y;
	if(l==r){
		//that's a leaf,and we should merge them?
		t[x].s=(t[x].s+t[y].s)%mod;
		t[x].cnt=(t[x].cnt+t[y].cnt)%mod;
		t[x].sum=(1ll*(t[x].cnt+1)*t[x].cnt/2*l)%mod;
		return x;
	}
	ll mid=(l+r)>>1;
	t[x].lson=merge(t[x].lson,t[y].lson,l,mid);
	t[x].rson=merge(t[x].rson,t[y].rson,mid+1,r);
	pushup(x);
	return x;
}
void dfs(ll x,ll fa){
	ll save=poi[x];
	while(save>0){
		if(v[save]!=fa){
			dfs(v[save],x);
			root[x]=merge(root[x],root[v[save]],1,1e8);
		}
		save=nex[save];
	}
	root[x]=xiugai(root[x],1,1e8,a[x]);
	ans[x]=t[root[x]].sum;
}
void solve(){
	cin>>n;	
	for(int i=1;i<n;i++){
		cin>>x>>y;
		add_edge(x,y);add_edge(y,x);
	}
	for(int i=1;i<=n;i++)cin>>a[i];
	
	dfs(1,0);
	for(int i=1;i<=n;i++)
		ansans=(ansans+ans[i])%mod;
	cout<<ansans<<endl;
	
}
int main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	tt=1;
	while(tt--)solve();
	return 0;
}
```





---


# 「语文」凑字数

## 题目背景

 数据的锅修好了！

## 题目描述

时间在一秒一秒地减少着，然而小 F 仍对着作文题冥思苦想。看起来，他又写不完作文了。

然而，小 F 有一种特殊的凑字数技巧——不停换行。这是因为，作文纸每行 $L$ 个字，而最低字数限制是以行数来计算的。

也就是说，只要写到了 $M$ 行（不含标题）即认为时满足要求，写到意味着这一行上有字。注意，由于作文格式要求，每段首行会**有两个字符的缩进空格**。

现在，他已经构思好了 $N$ 句话，每句话有着自己的长度 $a_i$ ——包括标点符号，不考虑因句号等在最后一格之外而不换行的情况。这几句话的关联或强或弱，关联强的更适合放在一段，关联弱的更适合分段，然而因为凑字数小 F 可以对任意两句话之间进行换行以分段。

关联关系会用一种特殊的方式来表示。我们知道，作文改卷时会将作文的得分点划分为几个主要部分，比如全国卷分为基础，表达，发展三个部分；每个部分拥有着相同的总分，比如对于全国卷来说是 $20$ 分；每个部分的最低均为 $0$ 分，也就是说哪怕扣到 $0$ 以下也算 $0$ 分。在这里，我们的评分标准有 $K$ 个部分，每个部分有 $S$ 分的满分。根据方面的不同，小 F 将两句话的关联关系用一个 $K$ 元组 $s_i = (s_{i,1}, s_{i, 2}, \cdots, s_{i, K})$ 表示，其中每个数都是整数，第 $j$ 个数 $s_{i, j}$ 表示：
* 如果是正数，那么表示拆开 $i, i + 1$ 这两句话会导致第 $j$ 部分得分扣 $s_{i, j}$ 分 。
* 如果是负数，那么表示**不**拆开这两句话第 $j$ 部分得分扣 $-s_{i, j}$ 分。
* 如果为 0，那么表示是否拆开这两句话对得分没有影响。

从满分开始，在计算完上面的扣分之后可以得到一个初步的总分。在这之后，最低字数线上每空一行，会扣 $C$ 分字数分，总分扣至 0 为止。

如果能够拿到高分作文，小 F 就可以得到老师的大拇指！所以，请你帮小 F 设计出一种方案以最大化得分。

## 说明/提示

### 样例 1 解释

这是样例 1 不分段的情况：

![](https://cdn.luogu.com.cn/upload/pic/21276.png )

这样做，得分是 $10 + 9 - 5 = 14$ 分。

我们发现，字数分太痛了，于是我们一定要去避免它。

最优解如下：

![](https://cdn.luogu.com.cn/upload/pic/21277.png)

这样做，得分是 $8 + 10 - 0 = 18$ 分。

### 样例 2 解释

即使换行可以避免一分字数扣分，但是相应地会扣掉两分，所以不如不换。


### 子任务

子任务 $1(21 \mathrm{pts}) : N \leq 10$；

子任务 $2(21 \mathrm{pts}) : K = 1$；

子任务 $3(31 \mathrm{pts}) : N \times a_i \leq 800$；

子任务 $4(77 \mathrm{pts}) :$
* $1 \leq N, M, a_i \leq 200$
* $3 \leq L \leq 200$
* $1 \leq K \leq 5$
* $0 \leq S, C, |s_{i, j}| \leq 200$

## 样例 #1

### 输入

```
4 4 12 2 10 5
5 5 10 4
2 -1
0 0
1 1```

### 输出

```
18```

## 样例 #2

### 输入

```
2 2 10 1 10 1
1 1
2```

### 输出

```
9```

# 题解

## 作者：Treeloveswater (赞：10)

Emmmm和出题人交流了一下，发现自己的算法没问题

也成功拿到最快的44ms

我来说一下我的做法吧，这个做法的复杂度非常的优越

首先我们肯定是要 2^k去枚举每个部分的状态的

复杂度优化的关键在于Dp

我们发现如果固定扣的分数，那么行数自然是尽量大。在行数一样大的情况下自然是最后一行字越多越好。

我们发现可以在dp的基础上贪心。

我们设f[i][j]为 dp到第i个句子，现在扣了j分

f[i][j]是一个pair，保存着两个值 行数 最后一行的字数

这样Dp的复杂度是 n·cnt·S  cnt是不会扣到0的部分的数量

2^k种状态的cnt加和是 k*2^(k-1)

所以最后的复杂度是 2^(k-1)kSn == 80 · 200 · 200

非常优越的复杂度，甚至可以把S，n提高到300都可以做

附上代码：

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
pair<int,int> f[201][1005];
int n,m,L,K,S,C;
int A[205];
int s[205][11];
bool vis[201][1005],ok[11];
void up(int i,int j,int a,int b){
    if(!vis[i][j]){
        vis[i][j]=1;
        f[i][j]=make_pair(a,b);
    }
    else{
        if(f[i][j].first>a)return;
        if(f[i][j].first<a)
            f[i][j]=make_pair(a,b);
        else
            f[i][j].second=max(f[i][j].second,b);
    }
}
int main(){
    scanf("%d%d%d%d%d%d",&n,&m,&L,&K,&S,&C);
    for(int i=1;i<=n;i++) scanf("%d",&A[i]);
    for(int i=1;i<n;i++)
        for(int j=0;j<K;j++) 
            scanf("%d",&s[i][j]);
    int ans=0;
    for(int t=1;t<(1<<K);t++){
        memset(vis,0,sizeof(vis));
        for(int i=0;i<K;i++) ok[i]=(t>>i)&1;
        int cnt=0,a,b,c,d,e;
        for(int i=0;i<K;i++) cnt+=ok[i];
        a=(A[1]+2)/L;b=(A[1]+2)%L;
        if(!b) b=L;
        else a++;
        f[1][0]=make_pair(a,b);vis[1][0]=1;
        for(int i=1;i<n;i++)
            for(int j=0;j<=cnt*S;j++)
                if(vis[i][j]){
                    a=f[i][j].first,b=f[i][j].second;
                    e=0;
                    c=a-1+(b+A[i+1])/L,d=(b+A[i+1])%L;
                    if(!d) d=L; else c++;
                    for(int k=0;k<K;k++) if(ok[k]&&s[i][k]<0) e-=s[i][k];
                    if(j+e<=cnt*S) up(i+1,j+e,c,d);
                    e=0;
                    c=a+(A[i+1]+2)/L,d=(A[i+1]+2)%L;
                    if(!d) d=L; else c++;
                    for(int k=0;k<K;k++) if(ok[k]&&s[i][k]>0) e+=s[i][k];
                    if(j+e<=cnt*S) up(i+1,j+e,c,d);
                }
        int total=cnt*S,zm;
        for(int j=0;j<=cnt*S;j++) if(vis[n][j]){
            zm=total-j;
            if(f[n][j].first<m) zm-=(m-f[n][j].first)*C;
            ans=max(ans,zm);
        } 
    }
    cout<<ans<<endl;
}
```


---

## 作者：winxp_qwq (赞：5)

我要写一篇题解来祭奠月赛时候智障的自己...

首先题意要读好，感觉还有点蒙就多读几遍

然后我们首先考虑 $K=1$ 的部分分

用 $dp[a][b]$表示写了 $a$ 行，最后一行写了 $b$ 个字时只考虑上下句扣分的最小扣分的分值，转移的时候枚举每句是否换行即可

超过 $m$ 行视作 $m$ 行，扣到负分视作 $0$ 分

加上行数不够可能带来的扣分，取最大值，就可以得到 $21$ 分

考虑对一般的 $K$ ，由于每个部分最多扣至 $0$ 分，上面的 $dp$ 不能直接搞。

但是有什么关系呢...

我们只需要 $2^K$ 枚举哪些部分被扣到 $0$ 分，转化为一个部分时的解法即可，容易证明这样答案不会变大或者变小

总复杂度 $2^Knml$,可以通过此题
```cpp
#include <bits/stdc++.h>
using namespace std;
#define maxn 209
#define inf 23333333
int dp[maxn][maxn];
int tmp[maxn][maxn];
int w[maxn][7];
int w1[maxn],w2[maxn];
int n,m,L,K,S,C,ans=0,cnt=0;
int l[maxn];
void gao() {
    int a,b,c,i,j;
    for(a=0;a<=m;a++)
    for(b=0;b<L;b++)
        dp[a][b]=inf;
    dp[0][L-1]=0;
    for(c=1;c<=n;c++) {
        memcpy(tmp,dp,sizeof dp);
        for(a=0;a<=m;a++)
    	for(b=0;b<L;b++)
        dp[a][b]=inf;
        for(a=0;a<=m;a++)
        for(b=0;b<L;b++) {
            i=(l[c]+b)/L;
            j=(l[c]+b)%L;
            dp[min(m,a+i)][j]=min(dp[min(m,a+i)][j],tmp[a][b]+w2[c]);
            i=(l[c]+1)/L;
            j=(l[c]+1)%L;
            dp[min(m,a+1+i)][j]=min(dp[min(m,a+1+i)][j],tmp[a][b]+w1[c]);
        }
    }
    for(a=0;a<=m;a++)
        for(b=0;b<L;b++) {
            ans=max(ans,cnt-dp[a][b]-(m-a)*C);
        }
}
void dfs(int a){
    if(a>K) gao();
    else {
        dfs(a+1);
        for(int b=2;b<=n;b++) {
            if(w[b][a]>0) w1[b]+=w[b][a];
            else w2[b]-=w[b][a];
        }
        cnt+=S;
        dfs(a+1);
        cnt-=S;
        for(int b=2;b<=n;b++) {
            if(w[b][a]>0) w1[b]-=w[b][a];
            else w2[b]+=w[b][a];
        }
    }
}
int main(){
    scanf("%d%d%d%d%d%d",&n,&m,&L,&K,&S,&C);
    int a,b,c,i,j;
    for(a=1;a<=n;a++) scanf("%d",&l[a]);
    w2[1]=inf;
    for(a=2;a<=n;a++) 
        for(b=1;b<=K;b++) scanf("%d",&w[a][b]);
    dfs(1);
    printf("%d\n",ans);
    return 0;
}
```

---


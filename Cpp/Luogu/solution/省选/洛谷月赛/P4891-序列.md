# 序列

## 题目背景

# 本题数据已更新

## 题目描述

给定两个长度为 $n$ 的序列 $A$ 和 $B$，定义序列 $C_i=\max\limits_{j=1}^i A_j$。

定义当前的价值是 $\prod\limits_{i=1}^n \min(B_i,C_i)$。

现在有 $q$ 次操作，每次操作将会修改序列 $A$ 或者 $B$ 中的一个位置，将会把数字变大。现在请求出每次修改之后的价值。

## 说明/提示

对于所有数据，满足 $1 \le n,q\le 10^5,0\le A_i,B_i,y \le 10^9$。

对于 20% 的数据范围，满足 $1\le n,q\le 1000$

对于另外 10% 的数据范围，满足 $opt=1$

对于另外 20% 的数据范围，满足 $opt=0$

对于 80% 的数据范围，满足 $n,q\le 50000$


## 样例 #1

### 输入

```
3 1
2 1 3
1 2 3
1 3 5
```

### 输出

```
6```

# 题解

## 作者：Saliеri (赞：16)

@chen_qian 先写了这一种做法，这篇题解权当是一个对他的题解的补充。

~~其实主要是感觉他写的太长了~~

___

考虑每一种操作对所有数组造成的影响。

- 对于 0 操作，因为只会改大，并且 C 数组也递增，所以相当于区间 $[x,p)$ 上的一个**区间 cover**。（p 指第一个大于 y 的 C 数组值所在的下标）

- 对于 1 操作，单点修改，不再赘述。

出现了区间 cover，单点修改，线段树没得跑了。

由于线段树上维护的都是 C 数组，所以下面的 A 就代指 题面中的 C 数组了。

接下来来看答案的维护。

我们发现，每一次如果要用 naive 的方式正确维护所有区间，那么必然需要递归到叶子来暴力修改。而这是我们所不能接受的。

[之前有一些题](https://www.luogu.com.cn/training/61113)，也是需要暴力递归到叶子，我们的优化方式是什么？

参考操作本身的性质，通过一定的剪枝，使得**区间可以被合并处理**，达到降低复杂度的目的。

那就来看看这个题什么时候区间能够合并处理吧。（对于区间 cover 操作）

- $A_{\min} \geq B_{\max}$ , 这样因为只会改大，所以不会对区间的答案造成任何影响。打上区间 cover 的 tag 后就可以直接返回。

- $v \leq B_{\min}$ , 这样一整个区间的答案数组都将会是改为的值，打上区间 cover 的 tag，更新区间的答案，返回。

- 其他情况我们没有办法。只能递归到叶子暴力更新。

考虑这样做的时间复杂度的级别。

如果我们将 $A_i < B_i$
 的个数看做总势能的话，每一次递归到叶子的操作都会使得总势能 -1。
 
 而唯一能够增加势能的方式就是对于 B 的 单点修改。每一次最多使得总势能 +1。
 
 由于总势能在 $O(n+q)$ 级别，所以递归到叶子的操作最多执行这么多次。
 
 其余的操作都可以看做是递归到叶子路上的长度为 1 的小分支，无足轻重。
 
 所以这么做的总时间复杂度就被证明了是 $O(n\log^2 n$)的（认为 n,q 等价）。
 
 ____
 
 关于实现：~~（这才是万恶之源）~~
 
 其实根本不用像 @chen_qian 的题解那样维护这么多东西 /lh
 
 对于每个节点，维护 $Amx,Amn,Bmx,Bmn,tag,tagty,ans$ 即可。
 
 注释：
 - tag : 区间cover tag。
 
 - tagty ： 因为要考虑这一次的区间cover是否要更新子区间的答案（讨论中情况 1&2 的区别），所以加一个这个标记。
 
 - 其他：就比较显然。
 
 关于如何找到区间 cover 的右端点：线段树上二分即可。我的实现比较丑，将就着看吧。
 
 其他都是线段树基本操作，不再赘述。
 
 ___
 
 代码：
 
```cpp
#include <cstdio>
#include <cstring>
const int maxn = 1e5+5,mod = 1e9+7;
inline int min(int a,int b) {return a<b?a:b;}
inline int max(int a,int b) {return a>b?a:b;}
inline int ksm(int a,int x) {
	int base=a,ans=1;
	while(x) {
		if(x&1)ans = 1ll*ans*base%mod;
		base = 1ll*base*base%mod;
		x >>= 1;
	}
	return ans;
}
int n,m,tmp,a[maxn],b[maxn],amn[maxn<<2],amx[maxn<<2],bmn[maxn<<2],bmx[maxn<<2],ans[maxn<<2],tag[maxn<<2],ty[maxn<<2];
void pushup(int k) {
	ans[k] = 1ll*ans[k<<1]*ans[k<<1|1]%mod;
	amx[k] = max(amx[k<<1],amx[k<<1|1]),bmx[k] = max(bmx[k<<1],bmx[k<<1|1]);
	amn[k] = min(amn[k<<1],amn[k<<1|1]),bmn[k] = min(bmn[k<<1],bmn[k<<1|1]);
}
void build(int k,int l,int r) {
	if(l == r)return amn[k]=amx[k]=a[l],bmx[k]=bmn[k]=b[l],ans[k]=min(a[l],b[l]),void();
	int mid = l+r>>1;
	build(k<<1,l,mid),build(k<<1|1,mid+1,r),pushup(k);
}
void gtag(int k,int l,int r,int v,int typ) {
	tag[k] = v,ty[k] = typ,amn[k] = amx[k] = v;
	if(typ&1)ans[k] = ksm(v,r-l+1);
}
void pushdown(int k,int l,int r,int mid) {if(~tag[k])gtag(k<<1,l,mid,tag[k],ty[k]),gtag(k<<1|1,mid+1,r,tag[k],ty[k]),tag[k] = -1,ty[k] = 0;}
int getpos(int k,int l,int r,int v) {
	if(amx[k]<=v)return n+1;
	if(l==r)return l;
	int mid = l+r>>1;
	pushdown(k,l,r,mid);
	if((tmp=getpos(k<<1,l,mid,v)) != n+1)return tmp;
	return getpos(k<<1|1,mid+1,r,v);
}
void cover(int k,int l,int r,int x,int y,int v) {
	if(l>y||r<x)return ;
	if(l>=x&&r<=y) {
		if(amn[k] >= bmx[k])return gtag(k,l,r,v,2);
		if(max(amx[k],v) <= bmn[k])return gtag(k,l,r,v,1);
		if(l == r)return amn[k]=amx[k]=v,ans[k]=bmn[k],void();
	}
	int mid = l+r>>1;
	pushdown(k,l,r,mid);
	cover(k<<1,l,mid,x,y,v),cover(k<<1|1,mid+1,r,x,y,v),pushup(k);
}
void update(int k,int l,int r,int p,int v) {
	if(l == r)return bmn[k] = bmx[k] = v,ans[k] = min(amn[k],bmn[k]),void();
	int mid = l+r>>1;
	pushdown(k,l,r,mid);
	p<=mid?update(k<<1,l,mid,p,v):update(k<<1|1,mid+1,r,p,v);
	pushup(k);
}
int main() {
	memset(tag,-1,sizeof(tag));
	scanf("%d %d",&n,&m);
	for(int i=1; i<=n; ++i)scanf("%d",&a[i]),a[i] = max(a[i],a[i-1]);
	for(int i=1; i<=n; ++i)scanf("%d",&b[i]);
	build(1,1,n);
	while(m--) {
		int ty,x,y;
		scanf("%d %d %d",&ty,&x,&y);
		if(ty == 0) {
			int pos = getpos(1,1,n,y);
			if(x<=pos-1)cover(1,1,n,x,pos-1,y);
		}
		if(ty == 1)update(1,1,n,x,y);
		printf("%d\n",ans[1]);
	}
	return 0;
}
```

upd: 修复了部分笔误以及代码缩进问题。

---

## 作者：Fading (赞：15)

对于这个题目，我很想吐槽。

对于$10$%……什么鬼？只有$5$个点你说$10$%？？？？？？

还有这个数据也太水了吧，我暴力都可以碾标算了，还跑了$rank\ 1$？？？

我的暴力是$O(n \times q\times log_2mod)$的。

首先预处理初始的答案。

对于询问$opt=0,x,y$, 暴力修改$[x,n]$的每一个$c[i]$,然后用乘法逆元修改答案(除原来的再乘新的),复杂度$O(n\times log_2mod)$

有一个剪枝,如果当前的$c[i]>=y$,直接退出循环,因为$c[i+1]>=c[i]$

对于询问$opt=1,x,y$, 直接修改$b[x]$,然后用乘法逆元修改答案,复杂度$O(log_2mod)$

结果过了？？？这都可以过？？？？？？

我也很绝望啊。

代码如下:
```
#include<bits/stdc++.h>
#define ljc 1000000007
using namespace std;
int n,q,a[200005],b[200005],c[200005];
long long ans=1;
inline int read(){
    int x=0;char ch=getchar();
    while (!isdigit(ch)) ch=getchar();
    while (isdigit(ch)) x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
    return x;
}
inline long long fast_pow(int a,int b,int p){
    long long s=1,t=a,k=b;
    while (k){
        if (k%2) s=s*t%p;
        t=t*t%p;
        k/=2;
    }
    return s;
}
inline long long max(long long a,long long b){
    if (a>b) return a;return b;
}
inline long long min(long long a,long long b){
    if (a<b) return a;return b;
}
int main(){
    n=read(),q=read();
    for (register int i=1;i<=n;i++){
        a[i]=read();
        c[i]=max(c[i-1],a[i]);
    }
    for (register int i=1;i<=n;i++){
        b[i]=read();
        ans=min(b[i],c[i])*ans%ljc;
    }
    int opt,x,y;
    for (register int i=1;i<=q;i++){
        opt=read(),x=read(),y=read();
        if (opt==1){
            if (b[x]<c[x]){
                ans=ans*fast_pow(b[x],ljc-2,ljc)%ljc;
                ans=ans*min(y,c[x])%ljc;
            }
            b[x]=y;
        }
        if (opt==0){
            a[x]=y;
            while (y>c[x]&&x<=n){
                if (c[x]<b[x]){
                    ans=ans*fast_pow(c[x],ljc-2,ljc)%ljc;
                    ans=ans*min(y,b[x])%ljc;
                }
                c[x++]=y;
            }
        }
        printf("%lld\n",ans);
    }
    return 0;
}



```



---

## 作者：shadowice1984 (赞：13)

菜的不行的shadowice1984只会根号做法

~~欢迎会log做法的聚聚爆踩我~~

_________________


题目意思简单明了，给定数组$a$和$b$,定义数组$c$为

$$c_{i}=\max_{j=1}^{i}a_{j}$$

求

$$\prod_{i=1}^{n}min(b_{i},c_{i})$$

多组单点修改a和b数组的值，保证只会往大里改不会往小里改

# 本题题解

那么一看这东西这么鬼畜线段树什么的肯定是做不了了，所以我们开始考虑分块怎么做

既然是分块就有分块题的一般套路可以使，我们尝试着把这个数据结构题往分块的模板上去套

第一步，将序列分成$\sqrt{N}$块，每个块上单独维护一下题目中要求我们求的式子的值

第二步，对于一个询问，我们暴力的for一下所有的块，将上面维护的答案乘到一起就是我们要的答案

第三步，对于修改b数组的操作，我们发现这仅仅是个单点修改操作，暴力重构其所在的块即可

第四步，对于修改a数组的操作$(x,y)$我们发现因为只会往大里改，所以说，这个操作等价于将$(x,n)$这段后缀的$c$值全部对$y$进行取$max$操作(也就是说这些$c$值$max=y$)，那么对于这个修改，他会修改不超过$\sqrt{N}$个散点，我们直接重构这个散点所在的块，对于剩下被修改的整块，**我们给这个块打一个对$y$取$max$的懒标记，然后更新这些块的答案**

发现一件事是刚才的算法流程中别的都是比较显然的，唯一需要我们解决的就是，我们需要在这个块内被打了一个对$y$取$max$的懒标记之后依然可以快速的求出题目中要求给的式子的值

好了现在我们需要解决的问题是，我这个块上被打了一个对$label$取$max$的标记

我想快速的求出这个值

$$\prod_{i=1}^{block.size}min(b_{i},c_{i})$$

那么让我们来仔细分析一下式子的特点，我们考虑一个元素$(b_{i},c_{i})$什么时候值会发生改变，会变成什么值
_______________________

## case1:$b\leq c$

我们发现一件事是这种情况下不管标记是什么这个元素的值一直是$b$不动，所以对于这种元素我们没必要管他
_________________________

## case2:$c \leq label \leq b$

我们发现这种情况下这个元素的值是等于label的
_________________________

## case3:$c \leq b \leq label$

我们发现这种情况下这个元素的值会被卡死在b上，我们知道以后label只会越变越大，所以从此以后这个元素的值保持在b不变
_______________________

## case4:$label \leq c \leq b$

这种情况下由于label太弱鸡了所以这个元素的值维持在c不变
_________________________

那么根据上面的分情况讨论我们发现似乎只需要记一下处于$case2$(也就是说值等于label)的元素有多少个,存在变量$cntlb$里，然后再记一下处于$case1,3,4$的元素的权值的乘积$mul$就可以了，最后我们要更新的答案就是$lable^{cntlb}×mul$

那么我们怎么维护这个过程呢？

我们随着label的增大(显然一个块上的label只会变大不会变小)，一个元素必是经历了$case4-case2-case3$的变化过程的

换句话说，每一个元素会被我们从记录处于$case1,3,4$元素的乘积变量中恰好删去一次，也会被恰好加入一次(只不过删去的时候这个元素的值还是c，回来的时候就变成了b了)

那么我们就有了一个非常棒的想法了，我们将所有$c\leq b$的元素的b值和c值放一起排好序，然后在这个数组上维护一个指针$np$表示$label$在当前数组中所处的排名

那么当$label$增大的时候我们暴力的让$np$向右爬，直到碰到了一个比$label$大的值,在我们让这个指针向右爬的时候，$np$每爬过一个b值，我们就让$cntlb--$(这说明有一个元素的值从$label$变成了$b$)，同时$mul×=b$(因为这个元素的值变成了b)

当我们爬过一个$c$值的时候，我们就让$cntlb++$(这说明有一个元素的值由$c$变成了$label$)同时$mul/=c$因为这个元素的值变成了$label$

最后我们快速幂一下就可以修改答案了~

不过刚才的复杂度分析似乎有点不靠谱啊，我们是暴力向右爬的指针，这样的话给一个块打标记的复杂度是最坏$O(blocksize)$的啊

不过我们想一下，每次将指针向右爬相当于删掉一个点，一开始有n个点，每次重构一个块会加入$O(blocksize)$个新点，那么我们指针向右爬的总复杂度就是$O(n×blocksize)$的，也就是均摊$O(1)$的

真正对复杂度有影响的是每次打标记之后的快速幂，这个东西的复杂度才是
$O(logn)$因此我们给一个块打标记的复杂度是$O(logn)$的

所以我们这个算法的总复杂度就是$O(nlogn\sqrt{n})$可以轻松的通过本题啦~

对了，最后的细节，我们会发现刚才的算法流程中可能会出现乘0和除0的现象产生，这种情况下我们还要记一下0的个数，这样才能确保我们既可以乘0也可以除0，具体实现见代码~

上代码~

```C
// luogu-judger-enable-o2
// luogu-judger-enable-o2
#include<cstdio>
#include<algorithm>
#include<map>
using namespace std;const int N=1e5+10;const int B=270;typedef long long ll;const ll mod=1e9+7;
inline ll po(ll a,ll p){ll r=1;for(;p;p>>=1,a=a*a%mod)if(p&1)r=r*a%mod;return r;}
int n;int m;int bi[N];int bj[N];int sa[N];int sb[N];struct data{ll a;ll b;};
struct nod {ll v;int tp;friend bool operator <(nod a,nod b){return a.v<b.v;}};
struct num//允许乘0除0的结构题
{
    ll v;int cntz;
    inline void mul(ll x){if(x)(v*=x)%=mod;else cntz++;}
    inline void div(ll x){if(x)(v*=po(x,mod-2))%=mod;else cntz--;}
    inline ll ck(){return (cntz)?0:v;}
};
struct block
{
    nod a[2*B+10];data ori[B+10];int tp;int siz;int np;ll lb;num ret;int cntlb;ll ans;
    inline data& operator [](const int& x){return ori[x];}
    inline void modify(const nod& p)//更改一个节点
    {if(p.tp==0)ret.div(p.v),cntlb++;else ret.mul(p.v),cntlb--;}
    inline void rebuild()//重构
    {
        for(int i=1;i<=siz;i++){ori[i].a=max(ori[i].a,lb);}
        tp=0;np=1;lb=0;ret=(num){1,0};cntlb=0;
        for(int i=1;i<=siz;i++)ret.mul(min(ori[i].a,ori[i].b));ans=ret.ck();
        for(int i=1;i<=siz;i++)
            if(ori[i].a<ori[i].b)a[++tp]=(nod){ori[i].a,0},a[++tp]=(nod){ori[i].b,1};
        sort(a+1,a+tp+1);
    }
    inline void lb_change(int nx)//打标记，向右爬一下指针
    {
        if(lb>=nx)return;lb=max(lb,(ll)nx);if(np>tp)return;
        while(np<=tp&&a[np].v<=lb)modify(a[np]),np++;
        ans=ret.ck()*po(lb,cntlb)%mod;
    }
}bl[(N/B)+10];
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%d",&sa[i]);
    for(int i=1;i<=n;i++)scanf("%d",&sb[i]);
    for(int i=1;i<=n;i++)sa[i]=max(sa[i],sa[i-1]);
    for(int i=1;i<=n;i++)bj[i]=(i-1)%B+1,bi[i]=((i-1)/B)+1;
    for(int i=1;i<=n;i+=B)//分块一般套路
    {
        int p=bi[i];
        for(int k=i;k<=min(i+B-1,n);k++)bl[p][++bl[p].siz]=(data){sa[k],sb[k]};
        bl[p].rebuild();
    }
    for(int z=1,t,x,y;z<=m;z++)
    {
        scanf("%d%d%d",&t,&x,&y);
        if(t==1){bl[bi[x]][bj[x]].b=y;bl[bi[x]].rebuild();}
        else 
        {
            for(int i=x;bi[x]==bi[i];i++)bl[bi[i]][bj[i]].a=max(bl[bi[i]][bj[i]].a,(ll)y);
            for(int i=bi[x]+1;i<=bi[n];i++)bl[i].lb_change(y);bl[bi[x]].rebuild();
        }
        ll ret=1;for(int i=1;i<=bi[n];i++)(ret*=bl[i].ans)%=mod;
        printf("%lld\n",ret);
    }return 0;//拜拜程序~
}
```




---

## 作者：mrsrz (赞：11)

这题，稍微看了一会，想了个$O(n\sqrt n)$的分块。看到shadowice1984神仙也写的分块，和我的思路一样，但为啥多个$\log$啊？那个快速幂的$\log$没卡下来？

设块大小为$S$。我们考虑维护每个块内的乘积，然后询问的时候把所有块的答案乘起来即可。那么单次复杂度为$O(\frac n S)$。

考虑修改$B$，这个就是个纯纯的单点修改，那么直接在它所在块中暴力修改即可。单次复杂度$O(S)$。

考虑修改$A$。发现$C$是$A$的前缀最大值数组，一定是单调不下降的。那么单点修改$A_x$为$y$，相当于把$x$及其之后位置，比$y$小的都赋成$y$。我们要找这个被修改的区间的右端点。由于单调性，我们先找出它所在块，然后在块里暴力扫，得到具体位置即可。单次复杂度$O(S+\frac n S)$。

接下来就是对$C$数组的区间修改了。边角直接暴力修改、暴力重新计算答案。那么问题就是中间的整块。

由于中间的是整块修改，所以这个块的答案是$\prod\limits_i \min(B_i,y)$，即对一个定值取$\min$。那么，只有小于$y$的$B_i$的值是有贡献的，其它的贡献均为$y$。

我们可以对每个块的$B$从小到大排序，然后处理出前缀积（不影响单点修改$B$的复杂度）。这样可以二分出第一个大于等于$y$的位置，然后前面的用前缀积解决，后面的用快速幂解决。这样复杂度为$O(\log S)$。

考虑去掉这个二分。由于$A$是不断变大的，那么$C$也是不断变大的，所以每次在$B$中二分到的临界点是不断右移的。我们可以用一个指针记一下当前临界点的位置，修改的时候直接往右移即可。在重构块的时候要重置指针。由于重置的次数为$O(n)$次，所以指针总移动次数为$O(nS)$，所以是均摊$O(1)$的。

但是还是存在这个快速幂的$\log$。我们发现，对于一次区间修改，它的$y$是相同的，那么我们在修改前先预处理出$y^0,y,y^2,\dots,y^S$，然后修改的时候直接$O(1)$获得对应幂次即可。于是这里的复杂度被降到了$O(1)$单次修改。一次区间修改的总复杂度就为$O(S+\frac n S)$。

这里只涉及乘法，也不存在除以0的问题。

当$S=\sqrt n$时，复杂度达到理论最优值，为$O(n\sqrt n)$。

## Code：
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
const int N=1e5+6,siz=320,D=siz+2,K=N/siz+2,md=1e9+7;
typedef long long LL;
#define bel(x)((x-1)/siz+1)
int n,m,c[N],a[N],blocks,L[K],R[K],b[N],_[N];
struct Blo{
	int pre[D],ans,c[D],L,R,len,tag,it,mxc;
	struct bp{
		int val,id;
		inline int operator<(const bp&rhs)const{return val<rhs.val;}
	}b[D];
	void init(int l,int r){
		L=l,R=r,len=r-l+1;
		for(int i=l;i<=r;++i)
		c[i-l+1]=::c[i],b[i-l+1]=(bp){::b[i],i};
		ans=1,it=1;
		for(int i=1;i<=len;++i)ans=(LL)ans*min(c[i],b[i].val)%md;
		pre[0]=1;
		sort(b+1,b+len+1),tag=-1;
		for(int i=1;i<=len;++i)pre[i]=(LL)pre[i-1]*b[i].val%md;
		mxc=c[len];
	}
	void modify_b(int x,int y){
		if(tag!=-1)
		for(int i=1;i<=len;++i)c[i]=tag;tag=-1;
		int pos=0;
		for(int i=1;i<=len&&!pos;++i)if(b[i].id==x)pos=i;
		b[pos].val=y;
		for(int i=pos+1;i<=len;++i)if(b[i]<b[i-1])swap(b[i-1],b[i]);else break;
		ans=1,it=1;
		for(int i=1;i<=len;++i)ans=(LL)ans*min(b[i].val,c[b[i].id-L+1])%md,pre[i]=(LL)pre[i-1]*b[i].val%md;
	}
	inline int getc(int pos){return tag==-1?c[pos-L+1]:tag;}
	void modify_c(int l,int r,int val){
		if(tag!=-1)
		for(int i=1;i<=len;++i)c[i]=tag;tag=-1;
		for(int i=l;i<=r;++i)c[i-L+1]=val;
		ans=1,it=1;
		for(int i=1;i<=len;++i)ans=(LL)ans*min(b[i].val,c[b[i].id-L+1])%md;
		mxc=c[len];
	}
	inline void allc(int val){
		tag=mxc=val;
		while(it!=len+1&&b[it].val<val)++it;
		ans=pre[it-1]*(LL)_[len-it+1]%md;
	}
}G[K];
inline int getr(int val){
	for(int i=1;i<=blocks;++i)
	if(G[i].mxc>=val)
	for(int j=L[i];j<=R[i];++j)
	if(G[i].getc(j)>=val)return j-1;
	return n;
}
void modify_c(int l,int r,int val){
	const int bL=bel(l),bR=bel(r);
	if(bL==bR)G[bL].modify_c(l,r,val);
	else{
		_[0]=1;
		for(int i=1;i<=siz;++i)_[i]=(LL)_[i-1]*val%md;
		G[bL].modify_c(l,R[bL],val),G[bR].modify_c(L[bR],r,val);
		for(int i=bL+1;i<bR;++i)G[i].allc(val);
	}
}
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;++i)cin>>a[i];
	for(int i=1;i<=n;++i)cin>>b[i];
	c[1]=a[1];
	for(int i=2;i<=n;++i)c[i]=max(c[i-1],a[i]);
	blocks=bel(n);
	for(int i=1;i<=blocks;++i)L[i]=R[i-1]+1,R[i]=i*siz;R[blocks]=n;
	for(int i=1;i<=blocks;++i)G[i].init(L[i],R[i]);
	for(int opt,x,y;m--;){
		cin>>opt>>x>>y;
		if(opt)G[bel(x)].modify_b(x,y);else
		if(G[bel(x)].getc(x)<y){
			int r=getr(y);
			modify_c(x,r,y);
		}
		int ans=1;
		for(int i=1;i<=blocks;++i)ans=(LL)ans*G[i].ans%md;
		cout<<ans<<'\n';
	}
	return 0;
}
```

---

## 作者：一念之间、、 (赞：6)

鉴于叉掉了@[Saliеri](https://www.luogu.com.cn/user/114153)的一篇题解，这里来补一个线段树的做法。

相似的，我们将 $c_i\le b_i$ 的点个数看做势能，每次若递归到叶子则势能减一的话复杂度是正确的。（一共初始 $n$ 点势能，改一次 $b$ 会加一点势能，递归到叶子复杂度是 $\log n$ ，一共 $\text{势能}\times\log$ 复杂度）

接下来就是如果维护的事情了，我用到了 6 个数组，

ans 表示整个区间乘在一起。
   
cvt 表示进行区间 cover 的 tag。

 （区间在不改变 $c_i$ 与 $b_i$ 的大小关系时进行 cover 操作保证复杂度）
   
mul 表示当 $b_i<c_i$ 时 $b_i$ 的乘积。

ct 表示当 $c_i<b_i$ 时 $c_i$ 的个数。

mxc 表示区间最大的 $c_i$。

mn 表示当 $c_i<b_i$ 时区间最小 $b_i$ 是多少。

写出这些转移就很方便了，改一个 $a_i$ 相当于在线段树二分一个区间进行覆盖操作。

对于存在可以改变使得 $b_i<c_i$ 时我们进行递归操作，否则区间覆盖。

注意在区间覆盖的时候使用到了快速幂，所以复杂度为 $(n+m)\log ^2$。

以下是 `rank1` 代码。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int read()
{
	char c;
	int w=1;
	while((c=getchar())>'9'||c<'0')if(c=='-')w=-1;
	int ans=c-'0';
	while((c=getchar())>='0'&&c<='9')ans=(ans<<1)+(ans<<3)+c-'0';
	return ans*w;
}
const int xx=1e5+5,mod=1e9+7,inf=2e9;
int n,q,a[xx],b[xx],c[xx];
ll mn[xx<<2],ct[xx<<2],mul[xx<<2],cvt[xx<<2],mxc[xx<<2],ans[xx<<2];
ll ksm(ll a,ll b)
{
	ll ans=1;
	while(b)
	{
		if(b&1)ans*=a,ans%=mod;
		a*=a,a%=mod,b>>=1;
	}
	return ans;
}
void upd(int k)
{
	mn[k]=min(mn[k<<1],mn[k<<1|1]);
	mxc[k]=max(mxc[k<<1],mxc[k<<1|1]);
	ans[k]=ans[k<<1]*ans[k<<1|1]%mod;
	ct[k]=ct[k<<1]+ct[k<<1|1];
	mul[k]=mul[k<<1]*mul[k<<1|1]%mod;
}
void cv(int k,int z){cvt[k]=z,mxc[k]=z,ans[k]=mul[k]*ksm(z,ct[k])%mod;}
void build(int k,int l,int r)
{
	if(l==r)
	{
		mxc[k]=c[l];
		if(mxc[k]<b[l])ans[k]=mxc[k],mn[k]=b[l],mul[k]=1,ct[k]=1;
		else ans[k]=b[l],mn[k]=inf,mul[k]=b[l],ct[k]=0;
		return;
	}
	int mid=l+r>>1;
	build(k<<1,l,mid);
	build(k<<1|1,mid+1,r);
	upd(k);
}
void pd(int k)
{
	if(cvt[k])
	{
		cv(k<<1,cvt[k]);
		cv(k<<1|1,cvt[k]);
		cvt[k]=0;
	}
}
int find(int k,int l,int r,int x)
{
	if(l==r)return mxc[k]<=x?l:l-1;
	if(mxc[k]<=x)return r;pd(k);
	int mid=l+r>>1;
	int s=find(k<<1,l,mid,x);
	if(s==mid)return find(k<<1|1,mid+1,r,x);
	return s;
}
void cgc(int k,int l,int r,int x,int y,int z)
{
	if(x>y)return;
	if(l==r)
	{
		if(z<b[l])ans[k]=z,mn[k]=b[l],mul[k]=1,ct[k]=1;
		else ans[k]=b[l],mn[k]=inf,mul[k]=b[l],ct[k]=0;
		mxc[k]=z;
		return;
	}
	if(x<=l&&r<=y)
		if(mn[k]>z)return cv(k,z);
	pd(k);
	int mid=l+r>>1;
	if(x<=mid)cgc(k<<1,l,mid,x,y,z);
	if(mid<y)cgc(k<<1|1,mid+1,r,x,y,z);
	upd(k);
}
void cgb(int k,int l,int r,int x,int y)
{
	if(l==r)
	{
		b[l]=y;
		if(mxc[k]<b[l])ans[k]=mxc[k],mn[k]=b[l],mul[k]=1,ct[k]=1;
		else ans[k]=b[l],mn[k]=inf,mul[k]=b[l],ct[k]=0;
		return;
	}
	pd(k);
	int mid=l+r>>1;
	if(x<=mid)cgb(k<<1,l,mid,x,y);
	else cgb(k<<1|1,mid+1,r,x,y);
	upd(k);
}
signed main(){
	n=read(),q=read();
	for(int i=1;i<=n;i++)a[i]=read(),c[i]=max(a[i],c[i-1]);
	for(int i=1;i<=n;i++)b[i]=read();
	build(1,1,n);
	while(q--)
	{
		int op=read(),x=read(),y=read();
		if(op==0)
		{
			int s=find(1,1,n,y);
			cgc(1,1,n,x,s,y);
		}
		else cgb(1,1,n,x,y);
		cout<<ans[1]<<"\n";
	}
    return 0;
}
```



---

## 作者：cosmicAC (赞：5)

（刚才ubuntu自带输入法又双叒叕出问题了，不爽）

给一个复杂度（也许）正确的做法：$O((n+q) log^2{n})$ 的。比赛时想到这个做法基本没动脑子。但是写的欲哭无泪。成功的炸零了。比赛结束后又调了一个小时才过。

~~话说我如此优秀的复杂度为什么最优解倒数？不服。~~

**[我的博客](https://www.luogu.org/blog/474D/)**

注意到每次修改A都是把A中的一个数变大。所以可以考虑这样一件事：假设一个数比它之前的所有数都要大，那么在所有时刻中"这样的数“集合肯定变动不超过$O(n+q)$次。可以感性理解一下。所以容易想到用一个set来维护这个集合。

现在考虑每次这个集合中一个数a和a的下一个数b之间（左闭右开）的那一段对答案的贡献。可以发现，这一段的C值都是一样的。所以只要知道区间中有多少个b值小于区间的C值以及这些b值的乘积。用一个数据结构维护即可（我用的是树状数组套主席树）。然后就统计一下区间乘积，乘上C的某个次幂即可。

对于1操作，直接在树状数组套主席树里修改就行了。2操作细节非常多。首先要二分出当前的值在序列的哪一段是最大值（这里也要一个树状数组）。如果是空区间直接跳过（我这里因为直接continue，忘了输出答案，调了好久）。假设区间是[l,r],然后在set里查询一下，要把set中包含l和包含r的区间（**可能是同一个**；这里的区间，指的是一个数a和a的下一个数b之间（左闭右开）的那一段，如果没有下一个数就是到序列结尾）**可能需要**分裂一下，然后把l和r中间的区间全都删掉，同时统计这些区间对答案的贡献，最后在set中插入l，表示这个新的区间。

还有空间需要卡一卡，主席树的节点中区间乘积必须开int，否则要么MLE要么RE。我的空间用了近500MB。

下面是代码：（当然是我最爱的C++17）
```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
#define maxn 100010
#define int64 long long
#define L(x) (a[x].ch[0])
#define R(x) (a[x].ch[1])
using namespace std;
multiset<pair<int,int64>> s;
//说好的set怎么变成multiset了？因为我是先插入新区间再删除旧区间的，可能两个区间完全相同。
const int64 mod=1e9+7;
int n,q,a[maxn],b[maxn],c1[maxn],rt[maxn];
int64 ans=1;
int64 power(int64 a,int64 b){
    if(!b)return 1;
    int64 ret=power(a,b>>1);
    ret=(ret*ret)%mod;
    if(b&1)ret=(ret*a)%mod;
    return ret;
}
struct segtree{
    struct node{int cnt,ch[2],mul=1;}a[30000010];
    //必须就是3000W，多一毫MLE，少一毫RE
    int tot,_cnt;int64 _mul;
    void ins(int x,int v,int modi,int &p,int tl=1,int tr=1e9){
        if(!p)p=++tot;
        if(tl==tr){a[p].mul=(1ll*a[p].mul*v)%mod;a[p].cnt+=modi;return;}
        int mid=tl+tr>>1;
        if(x<=mid)ins(x,v,modi,L(p),tl,mid);
        else ins(x,v,modi,R(p),mid+1,tr);
        a[p].mul=(1ll*a[L(p)].mul*a[R(p)].mul)%mod;
        a[p].cnt=a[L(p)].cnt+a[R(p)].cnt;
    }
    void qry(int l,int r,int p,int tl=1,int tr=1e9){
        if(!p)return;
        if(l<=tl && tr<=r){(_mul*=a[p].mul)%=mod,_cnt+=a[p].cnt;return;}
        int mid=tl+tr>>1;
        if(l<=mid)qry(l,r,L(p),tl,mid);
        if(r>mid)qry(l,r,R(p),mid+1,tr);
    }
}tr;
void chkmax(int &a,int b){a=max(a,b);}
void ins(int p,int v){for(;p<=n;p+=p&-p)chkmax(c1[p],v);}
int qry(int p){int r=0;for(;p;p&=p-1)chkmax(r,c1[p]);return r;}
void Ins(int p,int v,int tp=1){
    int t=p;
    for(;p<=n;p+=p&-p){
        if(tp)tr.ins(b[t],power(b[t],mod-2),-1,rt[p]);
        tr.ins(v,v,1,rt[p]);
    }
    b[t]=v;
}
int64 Qry(int l,int r,int u){
    int d=r-l+1;int64 mul=1,cnt=0;
    for(l--;l;l&=l-1){
        tr._mul=1,tr._cnt=0;
        tr.qry(0,u,rt[l]);
        (mul*=power(tr._mul,mod-2))%=mod,cnt-=tr._cnt;
    }
    for(;r;r&=r-1){
        tr._mul=1,tr._cnt=0;
        tr.qry(0,u,rt[r]);
        (mul*=tr._mul)%=mod,cnt+=tr._cnt;
    }
    return power(u,d-cnt)*mul%mod;
}
int main(){
    scanf("%d%d",&n,&q);
    for(int i=1;i<=n;i++)scanf("%d",a+i),ins(i,a[i]);
    for(int i=1;i<=n;i++)scanf("%d",b+i),Ins(i,b[i],0);
    for(int i=1,l=0;i<=n+1;i++)if(i>n || qry(i)==a[i]){
        if(l){
            int64 t=Qry(l,i-1,a[l]);
            s.insert(pair(l,t));
            (ans*=t)%=mod;
        }
        l=i;
    }
    while(q--){
        int op,x,y;scanf("%d%d%d",&op,&x,&y);
        if(op){
            Ins(x,y);
            auto it=s.upper_bound(pair(x,(int64)1e18)),nxt=it;
            int64 t;--it;
            (ans*=power(it->second,mod-2))%=mod;
            s.insert(pair(it->first,
                t=Qry(it->first,nxt==s.end()?n:nxt->first-1,qry(it->first))));
            s.erase(it);
            (ans*=t)%=mod;
        }else{
            int l=x,r=n+1;ins(x,y);
            if(qry(x)!=y){printf("%lld\n",ans%mod);continue;}
            while(l<r){
                int mid=l+r>>1;
                if(qry(mid)>y)r=mid;else l=mid+1;
            }
            l--;
            auto it=s.upper_bound(pair(x,(int64)1e18)),nxt=it;
            --it;
            int stp=it->first;int64 t=1,t1;
            vector<decltype(s.begin())> v; 
            //原谅我C++17学艺不精，不会更简单的写法
            for(;nxt!=s.end() && nxt->first<=l;++nxt,++it)
                (ans*=power(it->second,mod-2))%=mod,v.push_back(it);
            if(stp!=x)s.insert(pair(stp,t=Qry(stp,x-1,qry(stp)))); //分裂开头
            for(auto it:v)s.erase(it); //删除中间区间
            int edp=nxt==s.end()?n:nxt->first-1;
            if(l!=edp)s.insert(pair(l+1,t1=Qry(l+1,edp,qry(l+1)))),t=(t*t1)%mod; //分裂结尾
            (ans*=power(it->second,mod-2))%=mod;
            (ans*=t)%=mod;
            s.erase(it);
            t=Qry(x,l,y);(ans*=t)%=mod;
            s.insert(pair(x,t));
        }
        printf("%lld\n",ans%mod);
    }
    return 0;
}
```


---

## 作者：chen_qian (赞：4)

**update：修改了一些笔误**

看到题解区里面好像没有比较正统（其实就是我不会分块）的线段树做法。所以写这篇题解。

本题的难点就在，当 $a_x$ 的值被更新之后，如何正确地维护 $c$ 数组的更改，以及 $c$ 数组更改后对于全局答案的更改。

显然的是，$a_x$ 的值被更新之后，假如对 $c$ 数组有影响。那么我们就可以通过线段树上二分，查找当前第一个 $c_y$ 大于 $a_x$，然后对于 $[x,y]$ 进行区间修改的操作。

值得注意的是，由于 $c$ 本身的定义是 $a$ 数组的前缀最大值，所以我们可以不用维护线段树维护 $c$ 数组，而维护 $a$ 数组，然后在递归时统计一下最值，这样就省略了 $c$ 数组的维护，而只用考虑如何维护乘积了。

由于 $b$ 的影响，我们没有办法采取懒标记的形式来进行考虑，只能递归到叶子暴力修改。

区间操作却只能暴力？这样的操作是不是让你想到了[区间开根](https://www.luogu.com.cn/problem/P4145)呢？我们借照这个题采取势能线段树来考虑。

其实势能线段树本身并不是一种算法，他只是基于势能来分析线段树上的一种类似剪枝的优化方法的复杂度的方法。

那么我们先来考虑怎么剪枝。我们没有办法采取懒标记的原因其实就是担心，区间修改以后，一些原来小的 $c$ ，比 $b$ 大了，我们没有办法来规避这种情况。

那么假如这个区间里面，所有比 $c$ 大的 $b$ 中的最小值都比修改的值大，那么我们就可以直接通过快速幂计算了！

还有一种情况就是区间所有的 $c$ 都比 $b$ 大，因为修改单调递增，这样根本不会有影响，所以我们考虑对线段树维护以下几个值。注意下面的值都维护的是 $p$ 节点对应区间的值。

- $mulb_p$ 区间中满足 $b_i \le c_i$ 的 $b_i$ 的乘积

- $mulc_p$ 区间中满足 $b_i > c_i$ 的 $c_i$ 的乘积

- $cntb_p$ 区间中满足 $b_i \le c_i$ 的 $b_i$ 的个数

- $cntc_p$ 区间中满足 $b_i > c_i$ 的 $c_i$ 的个数

- $maxc_p$ 区间最大 $a_i$ 

- $minb_p$ 区间中满足 $b_i > c_i$ 的 $b_i$ 的最小值，如果没有这样的数就置成 **INF**。这样包含以上两种情况。

- $lazy_p$ 标记区间是否包含以上两种情况之一。

具体实现见代码注释。

那么我们来分析一下复杂度吧。

因为以上做法是对于 $c_i < b_i$ 的情况展开讨论。我们不妨将 $c_i < b_i$ 的个数当做势能，我们 $c$ 数组的区间操作假如被成功剪枝不会使势能增加。如果递归到叶子就能使势能 $-1$。而 $b$ 数组的改变至多使势能增加 $1$，所以最坏情况下的总势能是 $n+q$。这意味着我们至多会到 $n+q$ 次叶子，算上快速幂，复杂度为 $O((n+q) \log^{2}(n))$。

而实际上会稍微快一点，因为快速幂和递归到叶子的情况不会同时出现。

```cpp
#include<bits/stdc++.h>
#define N 100005
#define mod 1000000007
#define int long long
#define INF 1e17
using namespace std;
int n,m,a[N],c[N],b[N];
int mulb[N<<2],mulc[N<<2],cntb[N<<2],cntc[N<<2],maxc[N<<2],minb[N<<2],lazy[N<<2];
int qpow(int x,int b){
	int ans=1;
	while(b){
		if(b&1) ans=(ans*x)%mod;
		b>>=1;
		x=(x*x)%mod; 
	}
	return ans%mod;
}
void push_tag(int p,int v){
	lazy[p]=v;
	mulc[p]=qpow(v,cntc[p]);//注意指数
}
void push_up(int p){
	mulb[p]=(mulb[p<<1]*mulb[p<<1|1])%mod;
	mulc[p]=(mulc[p<<1]*mulc[p<<1|1])%mod;
	cntb[p]=cntb[p<<1]+cntb[p<<1|1];
	cntc[p]=cntc[p<<1]+cntc[p<<1|1];
	maxc[p]=max(maxc[p<<1],maxc[p<<1|1]);
	minb[p]=min(minb[p<<1],minb[p<<1|1]);
}
void push_down(int p,int l,int r){
	int mid=(l+r)>>1;
	if(lazy[p]!=-1){
		push_tag(p<<1,lazy[p]);
		push_tag(p<<1|1,lazy[p]);
		lazy[p]=-1; 
	}
}
void build(int p,int l,int r){
	if(l==r){
		if(c[l]<b[l]){
			cntc[p]=1;
			mulc[p]=c[l];
			mulb[p]=1;
			cntb[p]=0;
			minb[p]=b[l]; 
		}
		else{
			cntc[p]=0;
			mulc[p]=1;
			mulb[p]=b[l];
			cntb[p]=1;
			minb[p]=INF; 
		}
		maxc[p]=a[l];
		lazy[p]=-1;//lazy=-1，避免 0
		return ;
	}
	lazy[p]=-1;
	int mid=(l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	push_up(p); 
}
void modifya(int p,int l,int r,int x,int v){
	if(l==r){
		maxc[p]=max(maxc[p],v);
		return ;
	}
	push_down(p,l,r);
	int mid=(l+r)>>1;
	if(x<=mid) modifya(p<<1,l,mid,x,v);
	else modifya(p<<1|1,mid+1,r,x,v);
	push_up(p);
} 
int Search(int p,int l,int r,int x){
    if(maxc[p]<=x) return r+1;
    int fmax=-1;//重点是这里记录前缀的最大值的操作
    while(l!=r){
        int mid=(l+r)>>1;
        if(max(fmax,maxc[p<<1])>x) r=mid,p<<=1;
        else{
        	fmax=max(fmax,maxc[p<<1]);
			l=mid+1;p=p*2+1;
		}
    }
    return l;
}
int queryc(int p,int l,int r,int x){//查询对应的c，进行操作
	int ans=-1;
	while(l!=r){
		int mid=(l+r)>>1;
		if(x<=mid) r=mid,p<<=1;
		else{
			ans=max(ans,maxc[p<<1]);
			l=mid+1,p=p*2+1;
		}
	}
	return max(ans,maxc[p]);
}
void modifyc(int p,int l,int r,int ql,int qr,int x){
	if(ql<=l&&qr>=r&&minb[p]>x){
		push_tag(p,x);//重点
		return ;
	}
	if(l==r){
		mulc[p]=1,cntc[p]=0;
		mulb[p]=b[l],cntb[p]=1;
		minb[p]=INF;
		return ;
	}
	push_down(p,l,r);
	int mid=(l+r)>>1;
	if(ql<=mid) modifyc(p<<1,l,mid,ql,qr,x);
	if(qr>mid) modifyc(p<<1|1,mid+1,r,ql,qr,x);
	push_up(p);
}
void modifyb(int p,int l,int r,int x,int v,int tc){//这里也要记录前缀最大值
	if(l==r){
		tc=max(tc,maxc[p]);
		if(v>tc){
			mulc[p]=tc;cntc[p]=1;
            mulb[p]=1;cntb[p]=0;
            minb[p]=v;
		} 
		else{
			mulc[p]=1,cntc[p]=0;
			mulb[p]=v,cntb[p]=1;
			minb[p]=INF;
		}
		return ;
	}
	push_down(p,l,r);
	int mid=(l+r)>>1;
	if(x<=mid) modifyb(p<<1,l,mid,x,v,tc);
	else modifyb(p<<1|1,mid+1,r,x,v,max(tc,maxc[p<<1]));
	push_up(p);
}
signed main(){
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
		c[i]=max(c[i-1],a[i]); 
	} 
	for(int i=1;i<=n;i++) scanf("%lld",&b[i]);
	build(1,1,n);
	while(m--){
		int op,x,y;
		scanf("%lld%lld%lld",&op,&x,&y);
		if(op==0){
			int s=queryc(1,1,n,x);
			modifya(1,1,n,x,y);
			if(s<y){
				int w=Search(1,1,n,y)-1;
				modifyc(1,1,n,x,w,y);
			}
		}
		else{
			b[x]=y;
			modifyb(1,1,n,x,y,-1);
		}
		int ans=(mulb[1]*mulc[1])%mod;
		printf("%lld\n",ans);
	} 
	return 0;
} 
/*
附赠对拍样例一份
4 5
1 4 3 4 
1 4 4 0 
0 3 5
1 4 1
1 1 4
1 2 8
0 3 8
*/
```


---

## 作者：rainygame (赞：2)

以下认为 $n,q$ 同阶。

看到 $10^5$ 可以考虑分块。

首先考虑操作 1 的本质，其实就是对 $C$ 的一个区间 $[l,r]$ 赋值操作，其中 $l=x$，$r$ 为 $l$ 后面第一个大于等于 $A_x$ 的 $A$ 的位置减 $1$。$r$ 可以通过维护每块的 $A_{\max}$ 来 $O(\sqrt{n})$ 求出。显然当 $C$ 是散块修改时，暴力复杂度是对的。

考虑整块修改，设 $t$ 表示一个整块修改的块被修改的值，$L$ 为块左端点，$R$ 为块右端点。对所有块维护块内升序的 $B$，设为 $B^\prime$，对于被整块修改的块，维护一个指针 $p$，表示 $B^\prime_p$ 是第一个大于 $t$ 的数，那么对于 $i < p$，答案是 $B^\prime_i$，对于 $i \ge p$，答案是 $t$。所以最终整个块的答案为 $(\prod\limits_{i=L}^{p-1}B^\prime_i)\times t^{R-p+1}$，注意 $p$ 可能为 $R+1$。

注意到 $C$ 单调不降，所以对于多次被整块修改的块，它们的 $p$ 也单调不降，在移动指针时记录修改就可以更新答案。所以在不考虑块重构的情况下，指针最多推 $O(n)$ 次，而块重构每个操作最多会有常数个块重构，每个重构最劣情况下会把指针移回 $L$ 处，增加 $O(\sqrt n)$ 次移动指针的次数，有 $O(n)$ 次查询。又注意到移动一个块的指针需要重新计算对答案的贡献，逆元需要 $O(\log M)$（$M$ 为模数）计算，所以复杂度为 $O(n\sqrt n \log M)$。

考虑操作 2，这个比较简单。对于单点修改的维护块内升序，直接暴力 `swap` 可以做到 $O(\sqrt n)$ 实现。剩下的对整个块重构就可以了。复杂度 $O(\sqrt n)$。

综上，时间复杂度为 $O(n\sqrt n \log M)$。

注意的点：

- 对于一个块移动指针更新答案，有简单的 $O(\log M)$ 求逆元维护答案的做法（我的代码也写的是这个），但是也可以用线段树维护块内答案前缀后缀积实现 $O(\log \sqrt n)$ 处理。（当然常数会更大）
- 对于答案为 $0$ 的情况，注意到这一定是答案序列的一个前缀（也就是在第一个答案不为 $0$ 的操作后面不会有答案为 $0$ 的操作），可以先处理出那些答案为 $0$ 的操作（直接修改序列），并从第一个答案不为 $0$ 的操作开始建块。（具体见代码）
- 注意取模和 `long long`。
- 需要将块长设为 $2048$ 以通过（拜谢 _maojun_）。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int MOD(1e9+7);
#define MAXN 100001
#define MAXB 320

int n, m, ans(1);
int a[MAXN], b[MAXN];
set<int> st;

int uread(){
	int x(0); char ch;
	while ((ch = getchar()) < 48);
	do x = (x << 1) + (x << 3) + (ch ^ 48);
	while ((ch = getchar()) > 47);
	return x;
}

int qpow(int x, int k=MOD-2){
	int res(1);
	for (; k; k>>=1){
		if (k & 1) res = (res * x) % MOD;
		x = (x * x) % MOD;
	}
	return res;
}

namespace Block{
#define bl(x) (((x)-1)/len+1)
#define L(x) (((x)-1)*len+1)
#define R(x) min((x)*len, n)
#define br(x) ((x)-L(bl(x))+1)
	int len, tot;
	int p[MAXB], mxn[MAXB], tag[MAXB], bans[MAXB];
	int c[MAXN], sb[MAXN];
	void push_up(int x){  // 重构完毕后更新块信息
		mxn[x] = 0;
		ans = (ans * qpow(bans[x])) % MOD;
		bans[x] = 1;
		for (int i(L(x)); i<=R(x); mxn[x]=max(mxn[x], a[i++])) bans[x] = (bans[x]*min(b[i], c[i])) % MOD;
		ans = (ans * bans[x]) % MOD;
	}
	void push_down(int x){  // 重构块
		while (~tag[x]){
			for (int i(L(x)); i<=R(x); c[i++]=tag[x]);
			tag[x] = -1;
		}
	}
	void line(int x, int k){  // 第 x 块的线移到 k
		// cout << ans << ' ' << x << ' ' << bans[x] << '\n';
		ans = (ans * qpow(bans[x])) % MOD;
		if (tag[x] == -1){
			bans[x] = 1;
			for (p[x]=L(x); p[x]<=R(x) && sb[p[x]] <= k; ++p[x]) bans[x] = (bans[x] * sb[p[x]]) % MOD;
			bans[x] = (bans[x] * qpow(tag[x]=k, R(x)-p[x]+1)) % MOD;
		}else{
			int res(1);
			for (; p[x] <= R(x) && sb[p[x]] <= k; ++p[x]){
				bans[x] = (bans[x] * sb[p[x]]) % MOD;
				res = (res * tag[x]) % MOD;
			}
			bans[x] = (bans[x] * qpow(res)) % MOD;
			bans[x] = (bans[x] * qpow(qpow(tag[x], R(x)-p[x]+1))) % MOD;
			bans[x] = (bans[x] * qpow(tag[x]=k, R(x)-p[x]+1)) % MOD;
		}
		ans = (ans * bans[x]) % MOD;
		// cout << ans << ' ' << x << ' ' << bans[x] << '\n';
	}

	void build(){
		memset(tag, -1, sizeof(tag));
		memcpy(sb, b, sizeof(b));
		for (int i(1); i<=n; ++i) c[i] = max(c[i-1], a[i]);

		len = sqrt(n);
		tot = (n-1)/len+1;
		for (int i(1); i<=tot; ++i){
			sort(sb+L(i), sb+R(i)+1);
			bans[i] = 1;
			push_up(i);
		}
	}

	int grt(int x, int k){
		for (int i(x); i<=R(bl(x)); ++i) if (a[i] >= k) return i-1;
		for (int i(bl(x)); i<=tot; ++i){
			if (mxn[i] >= k){
				for (int j(L(i)); j<=R(i); ++j) if (a[j] >= k) return j-1;
			}
		}
		return n;
	}
	void modify1(int x, int k){  // A_x <- k
		if (c[x] >= k || tag[bl(x)] >= k) return;
		int r(grt(x, k));
		a[x] = k;
		if (bl(x) == bl(r)){
			push_down(bl(x));
			for (int i(x); i<=r; c[i++]=k);
			push_up(bl(x));
			return;
		}

		push_down(bl(x));
		for (int i(x); i<=R(bl(x)); c[i++]=k);
		push_up(bl(x));
		for (int i(bl(x)+1); i<bl(r); line(i++, k));
		push_down(bl(r));
		for (int i(L(bl(r))); i<=r; c[i++]=k);
		push_up(bl(r));
	}

	void modify2(int x, int k){  // B_x <- k
		for (int i(L(bl(x))), fl(0); i<=R(bl(x)); ++i){
			if (sb[i] == b[x] && !fl) sb[i] = k, fl = 1;
			if (i < R(bl(x)) && sb[i] > sb[i+1]) swap(sb[i], sb[i+1]);
		}
		b[x] = k;
		push_down(bl(x));
		push_up(bl(x));
		// cout << bans[bl(x)] << '\n';
	}
}

signed main(){
	n = uread(); m = uread();
	for (int i(1); i<=n; a[i++]=uread());
	for (int i(1); i<=n; b[i++]=uread());
	for (int i(1); i<=n; ++i) if (!b[i]) st.insert(i);
	if (a[1] && st.empty()) Block::build();

	for (int opt, x, y; (!a[1] || st.size()) && m; --m){
		opt = uread(); x = uread(); y = uread();
		if (opt){
			b[x] = y;
			if (y && st.count(x)) st.erase(x);
		}else a[x] = y;
		if (a[1] && st.empty()){
			Block::build();
			printf("%lld\n", ans);
		}else puts("0");
	}

	for (int opt, x, y; m; --m){
		opt = uread(); x = uread(); y = uread();
		if (opt) Block::modify2(x, y);
		else Block::modify1(x, y);
		printf("%lld\n", ans);
		// for (int i(1); i<=4; cout << Block::tag[i++] << ' '); cout << '\n';
		// for (int i(1); i<=4; cout << Block::bans[i++] << ' '); cout << '\n';
	}

	return 0;
}

```

---

## 作者：MisakaQAQ (赞：2)



------------

关于这一道题的话。。。

我们先从题干看起，题目要求更改A序列或者B序列，最后求一个min（Bi，Ci）的总乘积，其实要修改B的话很容易，O(1)即可。但是要修改A的话，会导致C序列大幅改变。于是这时候就有同学站出来说要用线段树了，但是答案是要一个总乘积的，就算对于C序列的修改时间复杂度降下去了，求积的部分也会很难受。

于是我们可以这么想，要是可以维护这个答案就好了，然后这道题就变成一道简单的乘法逆元版子题了。

首先，我们建立一个mul数组来维护每一位的min(Bi,Ci),sum为初始的答案。

在修改B序列时，我们直接更改B[i]，然后将新的min(Bi,Ci)与原来的mul[i]比较，若有不同，则将原来的除掉，将新的乘上，然后更新mul数组。

对于A序列的修改，我们从要修改的第i位开始，把比更改的值小的C[i]全部更新成修改后的值，之后就是照葫芦画瓢。与B序列修改一样的处理方式。

当然，这道题是要模的，由于计算中涉嫌除法运算，不能直接模，所以我们就可以运用乘法逆元
            
                 (a/b) mod p == (a*b^(p-2)) mod p	
下面是AC代码
------------

```
#include<cstdio>
#include<algorithm>
using namespace std;
long long n,q;
long long a[100010],b[100010],c[100010],sum=1,mul[100010];
const long long mod = 1e9+7;

long long ksm(long long a){
	long long summ = 1,b = mod-2;
	while(b){
		if(b&1)summ=(summ*a)%mod;
		a = (a*a)%mod;
		b>>=1;
	}
	return summ;
}

int main(){
	scanf("%lld%lld",&n,&q);
	for(long long i = 1; i <= n; i++)scanf("%lld",&a[i]);
	for(long long i = 1; i <= n; i++)scanf("%lld",&b[i]);
	for(long long i = 1; i <= n; i++)c[i] = max(c[i-1],a[i]);
	for(long long i = 1; i <= n; i++)sum=(sum*min(c[i],b[i]))%mod,mul[i]=min(c[i],b[i]);
	while(q--){
		long long op,id,val;
		scanf("%lld%lld%lld",&op,&id,&val);
		if(op==1){
			b[id] = val%mod;
			if(min(c[id],b[id])!=mul[id]){
				sum = ((sum*ksm(mul[id])%mod)*min(c[id],b[id]))%mod;
				mul[id] = min(c[id],b[id]);
			}
		}
		else {
			while(c[id]<val){
				if(id>n)break;
				c[id] = val%mod;
				if(min(c[id],b[id])!=mul[id]){
					sum = ((sum*ksm(mul[id])%mod)*min(c[id],b[id]))%mod;
					mul[id] = min(c[id],b[id]);
				}
				id++;
			}
			
		}
		printf("%lld\n",sum%mod);
	}
}
```

---

## 作者：Genius_Star (赞：1)

### 思路：

注意到每次修改是不降的。

那么对于操作 $1$，令 $a_x \gets v$，相当于会将 $C$ 中的一段区间改为 $v$，由于 $C$ 单调不降，线段树上二分找右端点即可，设这段区间是 $[l, r]$。

首先我们要除掉原来 $[l, r]$ 的贡献，然后乘上赋值为 $v$ 后的贡献，因为单点的贡献是 $\min(B_i, C_i)$，故 $[l, r]$ 这段新的贡献是所有满足 $B_i \le v$ 的 $B_i$ 的乘积乘上 $v$ 的满足 $B_i > v$ 的 $B_i$ 的个数次方。

我们需要支持查询一个区间小于等于 $v$ 的所有数的乘积，容易想到主席树 $root_i$ 表示 $[1, i]$ 内所有数形成的值域线段树，则询问 $[l, r]$ 的贡献是 $root_r$ 中 $[1, v]$ 的乘积除以 $root_{l - 1}$ 中 $[1, v]$ 的乘积。

我们还要查询区间 $>v$ 的个数，那么上面值域线段树中维护区间乘积，区间元素个数即可，则 $>v$ 的个数相当于一个后缀的查询。

但是它有对于 $B$ 的单点修改，考虑树状数组套线段树即可。

但是我们要如何处理查询 $[l, r]$ 的答案？考虑记一个 $tag$ 表示将这个区间的 $C$ 都赋值为 $v$ 了。

下传标记到 $[l, mid], [mid + 1, r]$ 时，我们需要按照上面的方式进行两次树套树的查询。

对 $B_x$ 进行修改时，需要先下传 $rt \to x$ 的所有懒标记，再对 $B_x$ 进行修改，然后更新 $x$ 处的贡献 $\min(B_x, C_x)$。

注意需要离散化。

时间复杂度为 $O(N \log^3 N)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define lowbit(x) x & (-x)
#define pi pair<ll, ll>
#define ls(k) k << 1
#define rs(k) k << 1 | 1
#define fi first
#define se second
using namespace std;
typedef __int128 __;
typedef long double lb;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
const int N = 1e5 + 10, M = 3e5 + 10, mod = 1e9 + 7;
inline ll read(){
    ll x = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9'){
        if(c == '-')
          f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9'){
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    return x * f;
}
inline void write(ll x){
	if(x < 0){
		putchar('-');
		x = -x;
	}
	if(x > 9)
	  write(x / 10);
	putchar(x % 10 + '0');
}
struct Ques{
	int op, x, y;
}Q[N];
struct Node{
	int l, r;
	int data, tag;
	int mul;
}X[N << 2];
int n, q, op, x, y, cnt;
int a[N], b[N], s[N], h[M], inv[M];
inline int qpow(int a, int b){
	int ans = 1;
	while(b){
		if(b & 1)
		  ans = 1ll * ans * a % mod;
		a = 1ll * a * a % mod;
		b >>= 1;
	}
	return ans;
}
namespace Tree{
	class Seg{
	public:
		Seg(){
			newnode(rt);
		}
		struct Node{
			Node *lchild, *rchild;
			int mul, sum;
		};
		Node *rt;
		inline void newnode(Node* &q){
			q = new Node;
			q -> lchild = q -> rchild = NULL;
			q -> mul = 1, q -> sum = 0;
		}
		inline void pushup(Node* &q){
			q -> mul = 1, q -> sum = 0;
			if(q -> lchild != NULL){
				q -> mul = 1ll * q -> mul * q -> lchild -> mul % mod;
				q -> sum += q -> lchild -> sum;
			}
			if(q -> rchild != NULL){
				q -> mul = 1ll * q -> mul * q -> rchild -> mul % mod;
				q -> sum += q -> rchild -> sum;
			}
		}
		inline void update(Node* &q, int l, int r, int i, int v){
			if(q == NULL)
			  newnode(q);
			if(l == i && i == r){
				q -> sum += v;
				if(v == 1)
				  q -> mul = 1ll * q -> mul * h[i] % mod;
				else
				  q -> mul = 1ll * q -> mul * inv[i] % mod;
				return ;
			}
			int mid = (l + r) >> 1;
			if(i <= mid)
			  update(q -> lchild, l, mid, i, v);
			else if(i > mid)
			  update(q -> rchild, mid + 1, r, i, v);
			pushup(q);
		}
		inline int askmul(Node* &q, int l, int r, int i){
			if(q == NULL)
			  return 1;
			if(r <= i)
			  return q -> mul;
			int mid = (l + r) >> 1;
			if(i <= mid)
			  return askmul(q -> lchild, l, mid, i);
			else{
				if(q -> lchild == NULL)
				  return askmul(q -> rchild, mid + 1, r, i);
				else
				  return 1ll * q -> lchild -> mul * askmul(q -> rchild, mid + 1, r, i) % mod;
			}
		}
		inline int asksum(Node* &q, int l, int r, int i){
			if(q == NULL)
			  return 0;
			if(l >= i)
			  return q -> sum;
			int mid = (l + r) >> 1;
			if(i > mid)
			  return asksum(q -> rchild, mid + 1, r, i);
			else{
				if(q -> rchild == NULL)
				  return asksum(q -> lchild, l, mid, i);
				else
				  return q -> rchild -> sum + asksum(q -> lchild, l, mid, i);
			}
		}
		inline void update(int i, int v){
			update(rt, 1, cnt, i, v);
		}
		inline int askmul(int i){
			return askmul(rt, 1, cnt, i);		
		}
		inline int asksum(int i){
			if(i > cnt)
			  return 0;
			return asksum(rt, 1, cnt, i);
		} 
	}Tr[N];
	inline void add(int x, int v, int op){
		for(int i = x; i <= n; i += lowbit(i))
		  Tr[i].update(v, op);
	}
	inline pair<int, int> query(int x, int v){
		int mul = 1, sum = 0;
		for(int i = x; i; i -= lowbit(i)){
			mul = 1ll * mul * Tr[i].askmul(v) % mod;
			sum += Tr[i].asksum(v + 1); 
		}
		return {mul, sum};
	}
};
inline void pushup(int k){
	X[k].data = X[k << 1 | 1].data;
	X[k].mul = 1ll * X[k << 1].mul * X[k << 1 | 1].mul % mod;
}
inline void assign(int k, int v){
	int l = X[k].l, r = X[k].r;
	auto L = Tree::query(l - 1, v), R = Tree::query(r, v);
	X[k].mul = 1ll * R.fi * qpow(L.fi, mod - 2) % mod * qpow(h[v], R.se - L.se) % mod;
	X[k].data = X[k].tag = v;
}
inline void push_down(int k){
	if(X[k].tag != -1){
		assign(k << 1, X[k].tag);
		assign(k << 1 | 1, X[k].tag);
		X[k].tag = - 1;
	}
}
inline void build(int k, int l, int r){
	X[k].l = l, X[k].r = r;
	X[k].tag = -1;
	if(l == r){
		X[k].data = s[l];
		X[k].mul = h[min(s[l], b[l])];
		return ;
	}
	int mid = (l + r) >> 1;
	build(k << 1, l, mid);
	build(k << 1 | 1, mid + 1, r);
	pushup(k);
}
inline void update(int k, int i){
	if(X[k].l == i && i == X[k].r){
		X[k].mul = h[min(X[k].data, b[i])];
		return ;
	}
	push_down(k);
	int mid = (X[k].l + X[k].r) >> 1;
	if(i <= mid)
	  update(k << 1, i);
	else
	  update(k << 1 | 1, i);
	pushup(k);
}
inline int ask(int k, int i){
	if(X[k].l == i && i == X[k].r)
	  return X[k].data;
	push_down(k);
	int mid = (X[k].l + X[k].r) >> 1;
	if(i <= mid)
	  return ask(k << 1, i);
	else
	  return ask(k << 1 | 1, i);
}
inline int find(int k, int v){
	if(X[k].l == X[k].r){
		if(X[k].data < v)
		  return n + 1;
		else
		  return X[k].l;
	}
	push_down(k);
	if(X[k << 1].data < v)
	  return find(k << 1 | 1, v);
	else
	  return find(k << 1, v);
}
inline void update(int k, int l, int r, int v){
	if(X[k].l == l && r == X[k].r){
		assign(k, v);
		return ; 
	}
	push_down(k);
	int mid = (X[k].l + X[k].r) >> 1;
	if(r <= mid)
	  update(k << 1, l, r, v);
	else if(l > mid)
	  update(k << 1 | 1, l, r, v);
	else{
		update(k << 1, l, mid, v);
		update(k << 1 | 1, mid + 1, r, v);
	}
	pushup(k);
}
int main(){
	n = read(), q = read();
	for(int i = 1; i <= n; ++i){
		a[i] = read();
		s[i] = max(s[i - 1], a[i]);
		h[++cnt] = a[i];
	}
	for(int i = 1; i <= n; ++i){
		b[i] = read();
		h[++cnt] = b[i];
	}
	for(int i = 1; i <= q; ++i){
		Q[i] = {(int)read(), (int)read(), (int)read()};
		h[++cnt] = Q[i].y;
	}
	sort(h + 1, h + cnt + 1);
	cnt = unique(h + 1, h + cnt + 1) - (h + 1);
	for(int i = 1; i <= cnt; ++i)
	  inv[i] = qpow(h[i], mod - 2);
	for(int i = 1; i <= n; ++i){
		a[i] = lower_bound(h + 1, h + cnt + 1, a[i]) - h;
		s[i] = lower_bound(h + 1, h + cnt + 1, s[i]) - h;
		b[i] = lower_bound(h + 1, h + cnt + 1, b[i]) - h;
		Tree::add(i, b[i], 1);
	}
	build(1, 1, n);
	for(int i = 1; i <= q; ++i){
		op = Q[i].op, x = Q[i].x, y = Q[i].y;
		y = lower_bound(h + 1, h + cnt + 1, y) - h;
		if(!op){
			if(y > ask(1, x)){
				int l = x, r = find(1, y) - 1;
				update(1, l, r, y);
			}
		}
		else{
			int lst = b[x];
			b[x] = y;
			update(1, x);
			Tree::add(x, lst, -1);
			Tree::add(x, y, 1);
		}
		write(X[1].mul);
		putchar('\n');
	}
	return 0;
}
```

---

## 作者：harmis_yz (赞：1)

和 P4108 差不多吧。

## 分析

先考虑不修改时怎么求。由于我们的 $C$ 是前缀 $\max$，所以 $C_i$ 相同的一定是一段连续的区间，记为 $[l,r]$。那么就相当于求 $(\prod\limits_{i=l}^{r} B_i [B_i < C_i]) \times C_l ^{ \sum\limits_{i=l}^{r}[B_i \ge C_l] }$。那么这说明我们需要维护：区间内不不小于 $x$ 的数的数量；区间内小于 $x$ 的数的累乘。

对于修改 $B_i$，就是一个单点修改问题。我们只需要将 $i$ 所在的块重排。单次修改时间复杂度 $O(\sqrt{n}\log \sqrt{n})$。

对于修改 $A_i$，由于题目保证修改之后的值不减。说明我们 $i$ 之后的前缀最大值不减。我们可以二分找到一段区间 $[l,r]$，表示这段区间的 $C_j$ 都将会变成 $A_i$。那么我们是可以求出这段区间原本的价值的，也可以直接求出这段区间全部覆盖成 $A_i$ 的价值。不难发现，我们改变的区间一定是完整的，除了 $i$ 所在的区间。证明简单。那么我们使用线段树维护。对于前缀 $\max$ 为 $A_i$ 的区间的价值存在 $l=i,r=i$ 这个位置。就可以直接是单点修改，区间清空了。最后的答案就是线段树根节点的权值。时间复杂度 $O(q\sqrt{n}\log n+q\log n)$。找到最后一个 $\le A_i$ 的位置可以线段树上二分，可以合在一棵线段树上搞。

## 代码

```cpp
il void up(int u){
	tr[u].mx=max(tr[ls(u)].mx,tr[rs(u)].mx);
	tr[u].mul=tr[ls(u)].mul*tr[rs(u)].mul%p;
	tr[u].s=tr[ls(u)].s+tr[rs(u)].s;
	return ;
}
il void down(int u){
	if(!tr[u].tag) return ;
	tr[ls(u)].tag=1,tr[rs(u)].tag=1;
	tr[ls(u)].mul=tr[rs(u)].mul=1;
	tr[ls(u)].s=tr[rs(u)].s=0;
	tr[u].tag=0;
	return ;
}
il void build(int u,int l,int r){
	tr[u].l=l,tr[u].r=r;
	if(l==r) return tr[u].mul=1,tr[u].mx=a[l],void(0);
	int mid=l+r>>1;
	build(ls(u),l,mid),build(rs(u),mid+1,r);
	return up(u),void(0);
}
il void modify1(int u,int l,int r){
	if(tr[u].l>=l&&tr[u].r<=r){
		tr[u].s=0;
		tr[u].tag=1,tr[u].mul=1;
		return ;
	}
	down(u);
	int mid=tr[u].l+tr[u].r>>1;
	if(l<=mid) modify1(ls(u),l,r);
	if(mid< r) modify1(rs(u),l,r);
	return up(u),void(0);
}
il void modify2(int u,int x,int k){
	if(tr[u].l==tr[u].r) return tr[u].s=1,tr[u].mul=k,void(0);
	down(u);
	int mid=tr[u].l+tr[u].r>>1;
	if(x<=mid) modify2(ls(u),x,k);
	else modify2(rs(u),x,k);
	return up(u),void(0);
}
il void modify3(int u,int x,int k){
	if(tr[u].l==tr[u].r) return tr[u].mx=k,void(0);
	down(u);
	int mid=tr[u].l+tr[u].r>>1;
	if(x<=mid) modify3(ls(u),x,k);
	else modify3(rs(u),x,k);
	return up(u),void(0);
}
il int query(int u,int l,int r){
	if(tr[u].l>=l&&tr[u].r<=r) return tr[u].mx;
	down(u);
	int mid=tr[u].l+tr[u].r>>1;
	if(l<=mid&&mid< r) return max(query(ls(u),l,r),query(rs(u),l,r));
	if(l<=mid) return query(ls(u),l,r);
	if(mid< r) return query(rs(u),l,r); 
}
il int Query_(int u,int l,int r){
	if(tr[u].l>=l&&tr[u].r<=r) return tr[u].s;
	down(u);
	int mid=tr[u].l+tr[u].r>>1;
	if(l<=mid&&mid< r) return Query_(ls(u),l,r)+Query_(rs(u),l,r);
	if(l<=mid) return Query_(ls(u),l,r);
	if(mid< r) return Query_(rs(u),l,r);
}
il int Query(int l,int r,int x){
	int bl=id(l),br=id(r);
	if(bl==br){
		int res=1;
		for(re int i=l;i<=r;++i) res=res*min(b[i],x)%p;
		return res;
	}
	int res=1;
	for(re int i=l;i<=bl*len;++i) res=res*min(b[i],x)%p;
	for(re int i=(br-1)*len+1;i<=r;++i) res=res*min(b[i],x)%p;
	for(re int i=bl+1;i< br;++i){
		int le=(i-1)*len+1,ri=i*len,w=le-1;
		while(le<=ri){
			int mid=le+ri>>1;
			if(b_[mid]<x) w=mid,le=mid+1;
			else ri=mid-1;
		}
		if(w>=(i-1)*len+1) res=res*s[w]%p;
		res=res*qmi(x,i*len-w,p)%p;
	} 
	return res;
}
il int get(int x){
	int l=1,r=x,w=-1;
	while(l<=r){
		int mid=l+r>>1;
		if(Query_(1,mid,x)>=1) w=mid,l=mid+1;
		else r=mid-1;
	}
	return w;
}
il int get_(int x){
	int l=x,r=n,w=n+1;
	while(l<=r){
		int mid=l+r>>1;
		if(Query_(1,x,mid)>=1) w=mid,r=mid-1;
		else l=mid+1;
	}
	return w;
}

il void solve(){
	n=rd,q=rd,len=sqrt(n);
	for(re int i=1;i<=n;++i) a[i]=rd;
	for(re int i=1;i<=n;++i) b[i]=rd,b_[i]=b[i];
	build(1,1,n);
	for(re int i=1;i<=id(n);++i){
		int l=(i-1)*len+1,r=min(n,i*len);
		sort(b_+l,b_+r+1);
		s[l]=b_[l];
		for(re int j=l+1;j<=r;++j) s[j]=s[j-1]*b_[j]%p;
	}
	int u=1;
	while(u<=n){
		int x=a[u];
		int l=u,r=n,w=-1;
		while(l<=r){
			int mid=l+r>>1;
			if(query(1,1,mid)<=x) w=mid,l=mid+1;
			else r=mid-1;
		}
		int Val=Query(u,w,a[u]);
		modify2(1,u,Val),u=w+1;
	}
	while(q--){
		int op=rd,x=rd,y=rd;
		if(op==1){
			b[x]=y;
			int K=id(x);
			int l=(K-1)*len+1,r=min(n,K*len);
			for(re int i=l;i<=r;++i) b_[i]=b[i];
			sort(b_+l,b_+r+1);
			s[l]=b_[l];
			for(re int j=l+1;j<=r;++j) s[j]=s[j-1]*b_[j]%p;	
			int le=get(x),ri=get_(x+1)-1;
			int Val=Query(le,ri,a[le]);
			modify2(1,le,Val);
		}
		else{
			if(query(1,1,x)>=y){
				a[x]=y;goto Ed;
			}
			modify3(1,x,y),a[x]=y;
			if(x>1){
				int val=query(1,1,x-1);
				int l=1,r=x-1,w=-1;
				while(l<=r){
					int mid=l+r>>1;
					if(query(1,1,mid)>=val) w=mid,r=mid-1;
					else l=mid+1;
				}
				int Val_=Query(w,x-1,val);
				modify2(1,w,Val_);
			}
			int l=x,r=n,w=-1;
			while(l<=r){
				int mid=l+r>>1;
				if(query(1,1,mid)<=a[x]) w=mid,l=mid+1;
				else r=mid-1;			
			}
			modify1(1,x,w);
			int Val=Query(x,w,a[x]);
			modify2(1,x,Val);
		}Ed:;
		printf("%lld\n",tr[1].mul);
	}
    return ;
}
```

---

## 作者：2018LZY (赞：1)

参考[此blog](https://www.luogu.com.cn/blog/Mrsrz/solution-p4891),谈谈个人的理解.

# 思路: 
$c$明显是不严格递增数列.

如果$a[x]$的更新$(y)$能更新$c[x]$,那么我们再考虑一下y的最远影响范围.

这个可以用分块求.

但是贡献的更新就有点难维护了.

像往常一样,我们边角暴力,大段快速处理.

假如我们整块的$c$变为了$y$,由于答案取$\min(b[i],y)$,所以我们可以对$b$在块内排序,这样贡献就分两块了.

对前部取前缀积,对后一部分我们可以先预处理$P[i]=y^i$(块长$sz$复杂度),然后后一部分$O(1)$.

同时,能更新$c$的$y$一定会越来越大(不然就不用更新啦)
所以块内满足$b[i]<y$的上界越来越大,数量也越来越多,我们可以采用一个指针来存储后一部分的开头位置.

这样指针的移动可以均摊$O(1)$,只有边角处理$c$的时候要把指针挪前.

通过上面查询的快速处理的方法,我们修改$b$的时候就需要$O(\sqrt n)$来维护有序的b.

从这里我们可以看出这样就由暴力的查询$O(n)$,修改$O(1)$弄成两类都$O(\sqrt n).$,总时间复杂度$O(n\log n+m\sqrt n)$

**这给我一个启发,对于修改和询问在暴力上的复杂度不统一,我们可以先想想如何快速维护大复杂度的那个,然后让小复杂度的迁就它,从而达到复杂度平衡.如本题由$O(n),O(1)\rightarrow O(\sqrt n).$**

PS:本人调试调半天,原因竟然是求$r$的时候只$\text{break}$掉一层.

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
#define gc getchar()
#define ll long long
#define pos(x) ((x-1)/sz+1) 
using namespace std;
const int N=1e5+10,sz=320,T=sz+11,mod=1e9+7;

void qr(int &x) {
	char c=gc; x=0;
	while(!isdigit(c))c=gc;
	while(isdigit(c))x=x*10+c-'0',c=gc;
}
void qw(ll x) {
	if(x/10) qw(x/10);
	putchar(x%10+'0');
}
void pr2(ll x){qw(x); puts("");}

int n,m,t,a[N],b[N],L[T],R[T];
ll ans,P[T];

struct B {
	int L,R,tag,it,len,c[T],mx;
	ll ans,pre[T];
	struct rec {
		int v,id;
		bool operator <(rec b) const {return v<b.v;}
	}B[T];
	void bt(int l,int r) {
		L=l; R=r; len=r-l+1;
		ans=pre[0]=it=1; tag=-1; 
		for(int i=l,j=1;i<=r;i++,j++) c[j]=a[i],B[j]=(rec){b[i],i},ans=ans*min(b[i],a[i])%mod;
		sort(B+1,B+len+1);mx=c[len];
		for(int i=1;i<=len;i++) pre[i]=pre[i-1]*B[i].v%mod;
	}
	void lazy() {if(tag!=-1) {for(int i=1;i<=len;i++) c[i]=tag; it=1; tag=-1;}}
	void change_b(int x) {
		lazy();//要更新答案必须下放c的标记 
		int pos=0;
		for(int i=1;i<=len&&!pos;i++) if(B[i].id==x) pos=i;
		B[pos].v=b[x];
		for(int i=pos+1;i<=len;i++) if(B[i-1].v>B[i].v) swap(B[i-1],B[i]); else break;
		ans=1; if(it>1) it-=it>=pos;
		for(int i=1;i<=len;i++) ans=ans*min(B[i].v,c[B[i].id-L+1])%mod,pre[i]=pre[i-1]*B[i].v%mod;
	}
	void change(int l,int r,int x) {
		lazy(); l-=L-1; r-=L-1;//要更新c就要提前下放标记 
		for(int i=l;i<=r;i++) c[i]=x;
		ans=1; mx=c[len];
		for(int i=1;i<=len;i++) ans=ans*min(B[i].v,c[B[i].id-L+1])%mod;
	}
	void all(int x) {
		tag=mx=x;
		while(it<=len&&B[it].v<x) it++;
		ans=pre[it-1]*P[len-it+1]%mod;
	}
	int& operator [](int x) {return tag!=-1?tag:c[x-L+1];}
}g[T];

int main() {
	qr(n); qr(m); t=pos(n);
	for(int i=1;i<=n;i++) qr(a[i]),a[i]=max(a[i],a[i-1]);
	for(int i=1;i<=n;i++) qr(b[i]);
	for(int i=1;i<=t;i++) L[i]=R[i-1]+1,R[i]=i*sz; 		R[t]=n;
	for(int i=1;i<=t;i++) g[i].bt(L[i],R[i]);
	int op,x,y,p,q,r;
	while(m--) {
		qr(op); qr(x); qr(y); p=pos(x);
		if(op) b[x]=y,g[p].change_b(x);
		else if(g[p][x]<y) {
			q=t; r=n; bool flag=0;
			for(int i=p;i<=t&&!flag;i++) if(g[i].mx>=y)
				for(int j=L[i];j<=R[i];j++) 
					if(g[i][j]>=y) 
						{q=i; r=j-1;flag=1; break;}
			if(p==q) g[p].change(x,r,y);
			else {
				g[p].change(x,R[p],y);
				if(p+1<q) {
					P[0]=1;for(int i=1;i<=sz;i++) P[i]=P[i-1]*y%mod;
					for(int i=p+1;i<q;i++) g[i].all(y);
				}
				g[q].change(L[q],r,y);
			}
		}
		ans=1;
		for(int i=1;i<=t;i++) ans=ans*g[i].ans%mod;
		pr2(ans);
	}
	return 0;
}
```



---

## 作者：Robin_kool (赞：1)

$op=0$, 我们注意到每次的修改单调不降，而 $c$ 是一个前缀 $\max$，说明我们相当于对 $c$ 进行了一个 $[x,pos)$ 的区间覆盖，其中 $pos$ 的位置保证 $c_{pos}>y$ 且 $pos$ 最小。

$op=1$，这个修改没有含金量，是
单点修改的板子。

  区间覆盖，单点赋值，线段树实现。

  发现区间覆盖还要维护每个叶子的最小值，只能暴力递归到叶子，这样对于刻意构造的升序序列就会被卡成 $O(qn)$，相当于每次修改了一条链，考虑势能分析。

  $c_{min} \geq b_{max}$，发现接下来的节点不会作出任何更改，直接打个标记返回。

   $y \leq b_{min}$，接下来所有节点都会被覆盖，直接打个覆盖的标记，更新一下答案然后返回。

   否则，暴力递归。
   
  发现复杂度基于 $c_i<b_i$ 的个数，而单点修改最多使得势能 $+1$，所以总势能是 $O(n+q)$ 级别的。

维护 $b,c$ 的区间最值和两个标记，复杂度 $O(\log n)$，快速幂复杂度 $O(\log n)$，所以总复杂度为 $O((n+q) \log^2 n)$。

---


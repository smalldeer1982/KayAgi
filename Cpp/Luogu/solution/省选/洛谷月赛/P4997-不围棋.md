# 不围棋

## 题目背景

「不围棋」是一种非常有趣的棋类游戏。

大家都知道，围棋的「气」是指一个棋子所在的联通块相邻的空格。两粒棋如果在棋盘上线段的两端就认为是相邻的，也就是在同一个连通块里。比如在图中，白子为四个独立的连通块，黑子构成一个连通块，绿色点是黑子连通块唯一的「气」：

![](https://cdn.luogu.com.cn/upload/pic/41011.png )

「提子」是指将没有「气」的棋子提出棋盘，在上图中，如果白方走绿点，那么就可以将黑子全部提走。

在围棋中，我们想尽量多地占领地盘、提走对方棋子。然而，不围棋恰恰相反——不围棋是一种非常和平的游戏，双方的走子不能产生任何提子，也就是说，**任何一次走子不能让棋盘上任何一个棋子所在的连通块没有气**。比如，白方在上图中不能走绿点。

在你的某一步棋后，对方无棋可走，那么你就赢了。

## 题目描述

小 F 对不围棋特别感兴趣，不过他经常输，所以他想做出一个 AI 来替他完成这局游戏。

不过造 AI 实在是太困难啦，小 F 千辛万苦写出来的 AI 被同学们的 AI 锤爆啦！

现在，他想请你帮他实现一个 AI 中一部分的功能——随机模拟，因为他相信你写的程序非常优秀，一定能优化他的 AI。

给你一个 $n \times n$ 的棋盘，上面或许已经有一些棋子了，但此时局面一定是合法的，即**不存在没有气的连通块**；此时轮到黑棋下棋，因此棋盘上**黑白棋子的数量一定是相等的**。

你的任务是，**依次**为黑棋和白棋**随意**指定一个可行的走子位置，直到某一步游戏无法进行，决出胜负为止。

在正式的不围棋比赛还存在一些禁手规则。不过由于小 F 玩的是一种棋盘大小可变的新型不围棋，我们只用考虑上面提到的气的规则就好。

## 说明/提示

#### 样例 1 解释：

注意到将棋盘下满会让棋盘上所有连通块都没有气，所以黑棋是无棋可走的。

#### 样例 2 解释：

样例 2 还有两个正确的输出是这样的：
```
3 2
2 3
-1 -1
```
```
3 3
2 3
-1 -1
```
我们将棋盘表示出来：

![](https://cdn.luogu.com.cn/upload/pic/41216.png)

其中，黑棋是三个空格都可以走的。

* 如果黑棋走 $(2, 3)$，如图，此时白棋走任何位置都会提走相邻的黑棋，白棋无棋可走；
 ![](https://cdn.luogu.com.cn/upload/pic/41219.png)

* 如果黑棋走 $(3, 2)$，如图，此时白棋唯一可走的点是 $(2, 3)$，之后黑棋无棋可走；
 ![](https://cdn.luogu.com.cn/upload/pic/41218.png)

* 如果黑棋走 $(3, 3)$，如图，此时白棋唯一可走的点是 $(2, 3)$，之后黑棋无棋可走；
 ![](https://cdn.luogu.com.cn/upload/pic/41217.png)

这三种情况依次对应三个输出，输出任意一种可得到满分。

#### 评分规则解释：

为了解释评分规则，我们以样例 2 为例，对于以下几种输出：
```
I AK IOI
```
很不幸，因为您太强了，所以为了按住躁动的您，我们会给您 $0$ 分。

```
-1 -1
```
```
1 1
-1 -1
```
很不幸，你的第一行没有输出正确，得 $0$ 分。

```
3 3
-1 -1
```
你输出的前 $1$ 行是正确方案的一部分。由于 $1$ 是 $1$ 位数，恭喜你得到了整整 $1$ 分！

#### 数据范围：

![](https://cdn.luogu.com.cn/upload/pic/41855.png)

## 样例 #1

### 输入

```
3
XXX
OOX
OO.```

### 输出

```
-1 -1```

## 样例 #2

### 输入

```
3
XOO
XO.
X..```

### 输出

```
2 3
-1 -1```

# 题解

## 作者：Little_Ming (赞：33)

看了一遍题之后，发现其实题意就是模拟游戏进行直到结束，双方的决策你是可以随便定的！

所以，我们只需要轮流找到当前玩家的第一个可以放置棋子的点将其放下，如果找不到就说明游戏结束。

所以，整道题目的解题关键就在于如何高效地支持**查询落点是否可行**和**放置棋子**。

首先我们要小小修改一下`气`的定义。

新的定义是：

> 一个联通块的`气`等于她每个棋子四周的空位数量之和。

例如下图（请原谅我使用记事本+画图……），左图中白子联通块的`气`为$3$，黑子联通块的`气`为$6$，
每个棋子对所在联通块贡献的`气`为右图所示。

![](https://cdn.luogu.com.cn/upload/pic/42037.png)

在这个定义中，没有`气`仍然等价于这块棋会被提走，而这样定义会为后面的操作带来便利。

之后，我们便以下图为例，讲解如何完成这两个操作。

（左图：棋子；右图：该棋子所在联通块的`气`）

![](https://cdn.luogu.com.cn/upload/pic/42026.png)

----

### 查询落点是否可行

首先，已经放了棋子的位置是显然不能再放棋子的。

如下图，如果我们要在`？`所在位置放置一个黑子，我们首先把它看作一个单独的棋子（也就是说它现在不与其它黑子相连，也会挡住其它黑子的`气`），那么它四周的棋子所在的联通块的`气`要分别$-1$。再把它自身的`气`算出。


![这张图我做错了两次QAQ](https://cdn.luogu.com.cn/upload/pic/42027.png)

**提示：**如果棋子有两个方向上的相邻棋子属于同一个联通块，那么那个联通块的`气`要$-2$，因为每个相邻棋子贡献的`气`都$-1$了。


然后考虑对方棋子的联通块，如果有一个联通块`气`为$0$，就说明这块棋死了，这个落点不可行。图中可见左边白棋`气`变成了$1$，而$1 > 0$，说明不会把她堵死。

最后考虑有没有把自己的棋堵死。这个黑子最终会将它四周的黑棋都连起来，所以只要这个黑子本身或四周任何一块黑棋有`气`，就能满足要求，反之就不行了。图中虽然上方黑子没`气`了，但要落下的黑子有两口`气`，所以不会堵死这个棋子。

这几个条件都满足，说明这个地方是可以放一枚黑棋的。但这里不能放白棋，因为这枚白棋会使上方的黑子没`气`，而不能把它连起来。

那么

----

### 放置棋子

首先先跟上面一样把四周联通块的`气`$-1$，然后放上这枚棋子，计算它的`气`。

![](https://cdn.luogu.com.cn/upload/pic/42009.png)

然后就是把这枚棋子与四周的同种棋子联通块合并，她们合并后的`气`即为她们合并前的`气`之和。

![](https://cdn.luogu.com.cn/upload/pic/42011.png)

现在这两枚黑棋终于在一个联通块中了。

----

但是，直接暴力模拟整个过程，复杂度可能高达$O(n^6)$，只能为你带来$30$至$50$分，所以我们要对其进行优化。

### 并查集优化

看到满篇的“联通块”，再加上她们之间只能合并，不能分开，不难想到用并查集进行优化。把一个联通块看作一个集合，那么就可以在$O(\alpha(n))$的时间内找到一个棋子所在的联通块，联通块合并只需要把孩子的`气`加到父亲的`气`上，也能轻松处理。

现在时间复杂度是$O(n^4\alpha(n))$：游戏最多有$O(n^2)$步，每步最多需要判断$O(n^2)$个位置，每次判断位置是否可行需要$O(\alpha(n))$，仍然会**TLE**。

游戏的步数虽然可能可以优化，但不能减少复杂度；判断位置的并查集操作也是$O(\alpha(n))$不能更少，所以，只能减少每步判断位置的次数。

### 减少判断次数

_（大家不要在意这个~~难听的~~标题）_

当我们判断出一个位置上不能放黑棋了，那么它有三种情况：

1.现在它会堵死白棋。
	
  - 那么这块白棋只在这个出口有`气`，其它位置都被封死，在这个位置不放子的前提下，这块白棋永远只有这里有`气`，那么这里就再也不能放黑棋了。

2.现在它会堵死黑棋。
	
  - 那么这一片黑棋也一样，只在这里有`气`，其它位置都被封死，以后也只有这里有`气`，这里以后也不能放黑棋。
  
3.这里已经有棋子。

  - 棋子不会被拿走，所以这里再也不能放棋子了。

白棋也是一样的道理。

也就是说，如果一个位置上检查到不能放一种棋，那么以后也不能放这种棋。所以每个位置对于每种棋只需检查一次。具体地，可以给两个玩家各设一个标记，某个玩家的标记指向她现在需要检查的第一个位置，该标记之前的位置都是她不能放棋子的位置。这样，在整局游戏中，两个标记均只会总共后移至多$O(n^2)$次。

----

总复杂度：$($ 游戏步数$O(n^2)$+标记后移$O(n^2) \times$并查集$O(\alpha(n))$ $)$ $=$ $O(n^2\alpha(n))$

这样就可以[**AC**](https://www.luogu.org/record/show?rid=13113557)本题了。

----

## Code

`F(i) == for(int i=1;i<=n;i++)`（枚举一边坐标）

`Fc(i) == for(int i=1;i<4;i++)`（枚举方向）

`Fp(i) == for(Pos i=Pos(1,1);i;++i)`（枚举棋盘中的位置）

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=666;
int n;
#define F(i) for(int i=1;i<=n;i++)
struct Pos{//表示一个位置，重载了几个运算符
	int x,y;
	Pos(int _x,int _y){
		x=_x,y=_y;
	}
	Pos(){
	}
	Pos operator +(const Pos o)const{
		return Pos(x+o.x,y+o.y);
	}
	bool operator ==(const Pos o)const{
		return x==o.x&&y==o.y;
	}
	bool operator <(const Pos o)const{//只是方便用map
		return make_pair(x,y)<make_pair(o.x,o.y);
	}
	Pos operator ++(){//下一个位置
		y++;
		if(y>n){
			y=1;
			x++;
		}
		return *this;
	}
	operator bool()const{//转化为bool的结果是该位置是否在棋盘内
		return x>=1&&x<=n&&y>=1&&y<=n;
	}
};
#define Fp(i) for(Pos i=Pos(1,1);i;++i)
const Pos d[4]={Pos(1,0),Pos(-1,0),Pos(0,1),Pos(0,-1)};//四个方向
#define Fc(i) for(int i=0;i<4;i++)
template<class T>
struct Board{//资瓷二维数组存取与用Pos直接存取
	T dat[N][N];
	T &operator [](const Pos o){
		return dat[o.x][o.y];
	}
	T *operator [](const int o){
		return dat[o];
	}
};

enum TYPE{//棋盘位置种类
	WALL=-1,BLACK=0,WHITE=1,EMPTY=2
};

Board<Pos> fa;//并查集的父亲数组
Board<int> qi;//联通块的气数记录在根节点的qi上
Board<int> color;//棋盘每个点的种类

void init(){//初始化棋盘
	Fp(p)color[p]=EMPTY;
	Fp(p)qi[p]=0;
	F(i)
		color[i][0]
		=color[i][n+1]
		=color[0][i]
		=color[n+1][i]
		=WALL;
}

Pos find(Pos x){//并查集
	return x==fa[x]?x:fa[x]=find(fa[x]);
}

bool merge(Pos x,Pos y){//并查集
	x=find(x),y=find(y);
	if(x==y)return false;
	qi[y]+=qi[x];
	fa[x]=y;
	return true;
}

bool setgo(Pos p,TYPE c){//在p位置放置颜色为c的棋子
	if(color[p]!=EMPTY)return false;//已经有棋子
	color[p]=c;
	fa[p]=p,qi[p]=0;//新建集合
	Fc(i){
		Pos now=p+d[i];
		if(color[now]==EMPTY){
			qi[p]++;//相邻为空,气+1
		}else if(color[now]!=WALL){
			qi[find(now)]--;//相邻联通块气-1
		}
	}
	Fc(i){
		Pos now=p+d[i];
		if(color[now]==c)merge(p,now);//合并联通块
	}
	return true;
}

bool canset(Pos p,TYPE c){//检查是否能在p位置放置颜色为c的棋子
	if(color[p]!=EMPTY)return false;//只能放在空位
//	printf("Trying (%d,%d) for %d\n",p.x,p.y,c);
	map<Pos,int> eff;//记录如果放了棋子，会给周围的联通块减少的气数
	bool hasqi=false;//己方棋子放下后是否还有气
	Fc(i){
		Pos now=p+d[i];
		if(color[now]==EMPTY){
			hasqi=true;//棋子本身就有气
		}else if(color[now]!=WALL){
			eff[find(now)]++;//该联通块气数将-1
		}
	}
	for(map<Pos,int>::iterator it=eff.begin();it!=eff.end();it++){
		int nowqi=qi[find(it->first)]-it->second;//该联通块剩余气数
//		printf("Eff (%d,%d) [qi=%d]\n",it->first.x,it->first.y,nowqi);
		if(color[it->first]!=c&&nowqi==0)return false;//对方棋子被堵死了
		else if(color[it->first]==c&&nowqi!=0)hasqi=true;//己方棋子有气了
	}
	return hasqi;//己方棋子连起来后是否至少有一口气
}
/*
const char db[]={'X','O','.'}; 
void debug(){
	F(i){
		F(j)printf("%d",qi[find(Pos(i,j))]);
		printf("\n");
	}
	F(i){
		F(j)printf("%c",db[color[i][j]]);
		printf("\n");
	}
	getchar();
}
*/
int main(){
	scanf("%d",&n);
	init();
	Fp(p){
		char ch;
		do{
			ch=getchar();
		}while(ch!='O'&&ch!='X'&&ch!='.');
        //放一开始的棋子
		if(ch=='X')setgo(p,BLACK);
		else if(ch=='O')setgo(p,WHITE);
	}
	TYPE player=BLACK;//黑先
	Pos trying[2];//标记
	trying[BLACK]=Pos(1,1);
	trying[WHITE]=Pos(1,1);
	while(true){
		Pos &nt=trying[player];
		while(nt&&!canset(nt,player))++nt;//从标记向后尝试
		if(!nt){//标记已经在棋盘外了，说明没有合法位置能放了
			printf("%d %d",-1,-1);
			break;//Game Over
		}
		assert(setgo(nt,player));
		printf("%d %d\n",nt.x,nt.y);
//		if(nt.x>4)debug();
		//换玩家
		if(player==BLACK)player=WHITE;
		else player=BLACK;
	}
	return 0;
}
```

**祝大家**`NOIP.rp++`**!**

---

## 作者：Jμdge (赞：16)

不知道自己 n 个小时内在找什么 bug 。

每次de完bug交上去照样那点分没点长进。。。

然后最后发现主函数里少了两个 break。`********`


思路? ~~大模拟题有什么思路，跟着题意走就好了~~ 

反正模拟黑白两方下棋，开两个队列，某方不能下直接 break 就好了

这题细节是真的多  `*****`

看到很多人用set 的。。。并查集不好么...

```
//by Judge
#include<queue>
#include<cstdio>
#include<cstdlib>
#include<iostream>
#define P pair<int,int>
using namespace std;
const int M=705;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
inline int cread() { char c=getchar();
	while(c!='.'&&c!='X'&&c!='O') c=getchar();
	return c=='.'?0:(c=='X'?1:2);
} char sr[1<<21],z[20]; int C=-1,Z;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
inline void print(int x,char chr='\n') {
	if(C>1<<20)Ot(); if(x<0)sr[++C]=45,x=-x;
	while(z[++Z]=x%10+48,x/=10);
	while(sr[++C]=z[Z],--Z); sr[++C]=chr;
} int n,cnt,mp[M][M],blg[M][M],f[M*M],siz[M*M];
int h[4]= {-1,1,0,0},d[4]= {0,0,-1,1}; queue<P> QWQ,QBQ;
int find(int x) { //并查集吧
	return x!=f[x]?f[x]=find(f[x]):x;
}
inline void merge(int x,int y) {  //两个并查集并一起。
	int fx=find(x),fy=find(y);
	if(fx^fy) f[fy]=fx,siz[fx]+=siz[fy];
}
inline bool out(int x,int y) { //超边界就返回 1
	return x<1||x>n||y<1||y>n;
}
inline bool check(int x,int y,int c) {  //核心的部分：放棋子
	mp[x][y]=c;
	int more=0,flag=1; //more 可以从周围同色棋子中得到的气。
    //flag 当前有没有棋子联通块的气被堵死（同色的也一样考虑）
	int now=find(blg[x][y]); //当前点的编号（其实可以不用find）
	for(int i=0; i<4; ++i) {
		int dx=x+h[i],dy=y+d[i];
		if(out(dx,dy)) continue;
		int to=find(blg[dx][dy]); //四周点所在联通块
		if(!mp[dx][dy]) ++siz[now]; //如果是空格，给当前点加气
		else if(mp[dx][dy]) { //如果有棋子就减气
        //（之前重复加气，在这里会重复减掉）
			if(--siz[to]==0) { //四周点所在联通块断气了
				flag=0; //flag 先标记
				if(mp[dx][dy]!=c) //如果颜色不一样就不给当前点拓展气的机会（可以说是强制让当前的点断气）
					more=-998;
			}
		}
	}
	for(int i=0; i<4; ++i) {
		int dx=x+h[i],dy=y+d[i];
		if(out(dx,dy)) continue;
		int to=find(blg[dx][dy]);
		if(mp[dx][dy]==mp[x][y]) //如果颜色一样就可以借气
			more+=siz[to]>0; //但是只借一个气（全借也没关系）
	}
	more+=siz[now]; //加上自己的气
	if(more<=0) flag=0; //当前点自己断气了
	if(flag||more>0) { //如果说可行就放（不考虑优不优，反正都能过）
		for(int i=0; i<4; ++i) { //把当前点可以连的联通块连起来
			int dx=x+h[i],dy=y+d[i];
			if(out(dx,dy)) continue;
			int to=find(blg[dx][dy]);
			if(mp[x][y]==mp[dx][dy])
				merge(now,to);
		}
		return true; //返回插入成功
	}
	for(int i=0; i<4; ++i) {  //将当前点带来的影响消除
		int dx=x+h[i],dy=y+d[i];
		if(out(dx,dy)) continue;
		int to=find(blg[dx][dy]);
		if(mp[dx][dy]) ++siz[to];
		else --siz[now];
	}
	mp[x][y]=siz[now]=0; //当前点信息清空
	return false; //返回插入失败
}
int main() {
	scanf("%d",&n);
	for(int i=1; i<=n; ++i)
		for(int j=1; j<=n; ++j) {
			mp[i][j]=cread();
			blg[i][j]=++cnt;
		}
	for(int i=1; i<=cnt; ++i) f[i]=i;
	for(int x=1; x<=n; ++x)
		for(int y=1; y<=n; ++y) {
			if(mp[x][y]) { //当前点放了棋子
				for(int i=0; i<4; ++i) {
					int dx=x+h[i],dy=y+d[i];
					if(out(dx,dy)) continue;
					if(!mp[dx][dy]) ++siz[find(blg[x][y])]; //周围有空格，当前棋子所在联通块的气加一
                    //（这里会重复加气的贡献，但是你看到check函数里面就会明白了）
					else if(mp[dx][dy]==mp[x][y]) //颜色一样并一起
						merge(blg[x][y],blg[dx][dy]);
				}
			} else QWQ.push(P(x,y)),QBQ.push(P(x,y)); //空格丢到队列里
		}
	while(true) {
		int flag=0;
		while(!QBQ.empty()) {  //队列没空就一直试
			int x=QBQ.front().first,y=QBQ.front().second;
			QBQ.pop();
			if(mp[x][y]) continue;  //如果被另一种棋子下了就continue
			if(check(x,y,1)) {
				print(x,' '),print(y),flag=1;
				break;  //这个break 真的是...可能因为我不会下棋。
			}
		}
		if(!flag) {  //不能下
			print(-1,' '),print(-1);
			return Ot(),0;
		}
		flag=0;
		while(!QWQ.empty()) {
			int x=QWQ.front().first,y=QWQ.front().second;
			QWQ.pop();
			if(mp[x][y]) continue;
			if(check(x,y,2)) {
				print(x,' '),print(y),flag=1;
				break;
			}
		}
		if(!flag) {
			print(-1,' '),print(-1);
			return Ot(),0;
		}
	}
}
```

---

## 作者：jianhe (赞：10)

### 前言：
~~作为一名 $5$ 段棋手，切这道题还是花了几个小时，最后发现愚型的气多算了一口，而且没有用对应的方法将其减掉，所以不管是围棋还是 OI 都还是太菜了！~~

祭 [P1039 [NOIP2003 提高组] 侦探推理](https://www.luogu.com.cn/problem/P1039)，[P9169 [省选联考 2023] 过河卒](https://www.luogu.com.cn/problem/P9169)，[P4008 [NOI2003] 文本编辑器](https://www.luogu.com.cn/problem/P4008)，[P4567 [AHOI2006] 文本编辑器](https://www.luogu.com.cn/problem/P4567) 后的第五道大模拟！

### 思路：
可以发现，一块棋中的每个棋子都共用整块棋的气。那么可以把每一块棋看成一个连通块，用并查集维护连通性以及气就可以了。

黑白走棋时，只要一直向后枚举棋子，直到有一个位置能走了为止。如果都不能，就输出 `-1 -1` 结束程序。
### 细节：

#### 气：
注意到围棋中 **气** 的定义是：与棋子直线相邻空的交叉点。按照围棋里的算法，下图的这种愚型只算 $7$ 口气（分别是 $(19,B),(19,C),(18,A),(18,D),(17,B),(17,D),(16,C)$）。

![](https://cdn.luogu.com.cn/upload/image_hosting/wzmjwrro.png)

可以发现，如果我们按照一块棋中每个棋子的气之和来算整块棋的气，就会重复计算 $(17,B)$ 这个点，这块棋的气就会被算为 $8$ 口。

我们可以每次合并的时候特判这种情况，但是这样处理起来就比较麻烦。

~~由于这是 OI，~~ 我们可以重新定义 **气** 为：一块棋中每个棋子的气之和。由于我们并不关心一块棋的气具体是几，而是关心是否活着（即气是否不为 $0$），只要每次操作抵消掉重新定义带来的影响就好了。具体地，添加一个棋子，在计算周围的对方的棋子的气时，只要每个都减就好了，并不需要考虑是否是同一个连通块的棋子。这样刚好能抵消掉愚型多算的气。

下完一手棋，计算周围棋子的气：
```cpp
void xia(ll x,ll y,bool col){
    for(int k=0;k<4;k++){
        ll px=x+dx[k],py=y+dy[k];
        if(check(px,py))
            if(go[px][py]==col) qi[getfa(P(px,py))]--,hb(P(x,y),P(px,py));
            //和旁边的自己的棋子合并（注意会少一口气）
            else if(go[px][py]==!col) qi[getfa(P(px,py))]--;
            //旁边的对方的棋子会少一口气
            else if(!~go[px][py]) qi[getfa(P(x,y))]++;//如果是空地，这个子（即连通块）加一口气
    }
}
```

#### 判断是否可以落子：
首先不能下在棋子上面。

我们先判断会不会吃掉对方。具体方法：给四周的对方棋子气减去 $1$，判断是否都 $>0$。注意这里一块棋都不能死，所以只要有一块 $\le 0$ 就不行。

判断是否会吃掉对方的棋子：
```cpp
bool tries(ll x,ll y,bool col,ll t){
    //判断对手棋子会不会死（判断放上这颗棋子后，旁边的对手棋子的气是否都 >0）
	for(int k=0;k<4;k++){
		ll px=x+dx[k],py=y+dy[k];
		if(check(px,py))
			if(go[px][py]==col) qi[getfa(P(px,py))]-=t;
	}
	for(int k=0;k<4;k++){
		ll px=x+dx[k],py=y+dy[k];
		if(check(px,py))
			if(go[px][py]==col&&qi[getfa(P(px,py))]<=0) return 0;
	}
	return 1;
}
```
然后我们要判断自己会不会死。

考虑放上棋子后，四周自己的棋子会形成一个连通块，而周围棋子的气都会 $-1$，要求整个连通块的气 $>0$。

具体方法：只要有一块（或者要放上的子）的气 $\ge 1$ 就行了。

判断自己是否会死：
```cpp
bool trie2(ll x,ll y,bool col,ll t){
    //判断自己棋子会不会死（判断放上这颗棋子后，旁边的同色棋子的气是否有至少一个 >0）
	for(int k=0;k<4;k++){
		ll px=x+dx[k],py=y+dy[k];
		if(check(px,py))
			if(go[px][py]==col) qi[getfa(P(px,py))]-=t;
	}
	for(int k=0;k<4;k++){
		ll px=x+dx[k],py=y+dy[k];
		if(check(px,py))
			if(go[px][py]==col&&qi[getfa(P(px,py))]>0) return 1;
	}
	return 0;
}
```
合并上面两个步骤就可以判断这个位置是不是可以下了。

判断能否下：
```cpp
bool ok(ll x,ll y,bool col){
    if(~go[x][y]) return 0;//必须下在空地上
    bool t=tries(x,y,!col,1);//检查会不会吃掉对方的棋子
    tries(x,y,!col,-1);//回退
    if(!t) return 0;
    //检查是不是禁手（下了之后自己会不会死）
    for(int k=0;k<4;k++){
        ll px=x+dx[k],py=y+dy[k];
        if(check(px,py))
            if(!~go[px][py]) return 1;//如果这颗子本身有气，就不会死
    }
    t=trie2(x,y,col,1);trie2(x,y,col,-1);
    return t;
}
```

### 完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll N=666;
ll n,x=1,y=1,xx=1,yy=1,qi[N*N],fa[N*N],go[N][N];
ll dx[]={-1,0,0,1},dy[]={0,-1,1,0};
string s;
ll P(ll x,ll y){return (x-1)*n+y;}//压维
ll getfa(ll x){return fa[x]==x?x:fa[x]=getfa(fa[x]);}
void hb(ll x,ll y){
    x=getfa(x),y=getfa(y);
    if(x==y) return;
    qi[y]+=qi[x],fa[x]=y;//加上气
}
void init(){for(int i=1;i<=n*n;i++) fa[i]=i;}
bool check(ll x,ll y){return 1<=x&&x<=n&&1<=y&&y<=n;}
bool tries(ll x,ll y,bool col,ll t){
    //判断对手棋子会不会死（判断放上这颗棋子后，旁边的对手棋子的气是否都 >0）
	for(int k=0;k<4;k++){
		ll px=x+dx[k],py=y+dy[k];
		if(check(px,py))
			if(go[px][py]==col) qi[getfa(P(px,py))]-=t;
	}
	for(int k=0;k<4;k++){
		ll px=x+dx[k],py=y+dy[k];
		if(check(px,py))
			if(go[px][py]==col&&qi[getfa(P(px,py))]<=0) return 0;
	}
	return 1;
}
bool trie2(ll x,ll y,bool col,ll t){
    //判断自己棋子会不会死（判断放上这颗棋子后，旁边的同色棋子的气是否有至少一个 >0）
	for(int k=0;k<4;k++){
		ll px=x+dx[k],py=y+dy[k];
		if(check(px,py))
			if(go[px][py]==col) qi[getfa(P(px,py))]-=t;
	}
	for(int k=0;k<4;k++){
		ll px=x+dx[k],py=y+dy[k];
		if(check(px,py))
			if(go[px][py]==col&&qi[getfa(P(px,py))]>0) return 1;
	}
	return 0;
}
bool ok(ll x,ll y,bool col){
    if(~go[x][y]) return 0;//必须下在空地上
    bool t=tries(x,y,!col,1);//检查会不会吃掉对方的棋子
    tries(x,y,!col,-1);//回退
    if(!t) return 0;
    //检查是不是禁手（下了之后自己会不会死）
    for(int k=0;k<4;k++){
        ll px=x+dx[k],py=y+dy[k];
        if(check(px,py))
            if(!~go[px][py]) return 1;//如果这颗子本身有气，就不会死
    }
    t=trie2(x,y,col,1);trie2(x,y,col,-1);
    return t;
}
void xia(ll x,ll y,bool col){
    for(int k=0;k<4;k++){
        ll px=x+dx[k],py=y+dy[k];
        if(check(px,py))
            if(go[px][py]==col) qi[getfa(P(px,py))]--,hb(P(x,y),P(px,py));
            //和旁边的自己的棋子合并（注意会少一口气）
            else if(go[px][py]==!col) qi[getfa(P(px,py))]--;
            //旁边的对方的棋子会少一口气
            else if(!~go[px][py]) qi[getfa(P(x,y))]++;//如果是空地，这个子（即连通块）加一口气
    }
}
int main(){
    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
    cin>>n;init();
    for(int i=1;i<=n;i++){
        cin>>s;s=" "+s;
        for(int j=1;j<=n;j++) go[i][j]=(s[j]=='.'?-1:(s[j]=='X'?1:0));
        //1 表示黑棋，0 表示白棋，-1 表示空地
    }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
        	if(~go[i][j])//只计算黑/白棋的气
	            for(int k=0;k<4;k++){
	                ll px=i+dx[k],py=j+dy[k];
	                if(check(px,py))//向四周拓展
	                    if(!~go[px][py]) qi[getfa(P(i,j))]++;//多一口气
	                    else if(go[px][py]==go[i][j]) hb(P(i,j),P(px,py));//合并成一个连通块
	            }
    while(1){
        //找到黑棋能下的第一个点
        while(x<=n&&!ok(x,y,1)) if(y==n) x++,y=1;else y++;
        if(x>n) break;//找不到
        cout<<x<<" "<<y<<"\n";go[x][y]=1;xia(x,y,1);
        while(xx<=n&&!ok(xx,yy,0)) if(yy==n) xx++,yy=1;else yy++;
        if(xx>n) break;
        cout<<xx<<" "<<yy<<"\n";go[xx][yy]=0;xia(xx,yy,0);
    }
    cout<<"-1 -1";
    return 0;
}
```
### 后记：
作为一名围棋界的业余退役选手，对围棋的感触还是挺深的。

思维的火花在棋盘间碰撞，变幻莫测的形势使我深深地爱上了他。

![](https://cdn.luogu.com.cn/upload/image_hosting/c3erezvb.png)

可我被迫离开了他，唯一陪伴我至今的爱好只剩 OI。

我也曾想过人生的意义是什么却没有结果，而如今，围棋与 OI 告诉我，人生的意义是热爱。两年后我终将会 AFO，但就像围棋一样永远藏在我的网名“见合”中，永远陪伴着我。

---

## 作者：ygsldr (赞：5)

前置知识：并查集

不会请转[传送门](https://www.luogu.org/problemnew/show/P3367)

本来以为有什么玄学做法结果机房dalao说模拟QAQ

因为一个联通块是共用“气”的，所以我们用并查集来维护一个联通块，同时记录联通块气的数量

有的时候会被重复统计，比如：
```
XX
X.
```
这个时候右下角的点会对这个联通块产生两点气的贡献，但没有关系，我们在删除贡献的时候也删两遍就好了

那么怎么来做一道模拟呢，有很多人（比如我）看到模拟题就烦，这时候我们要沉着冷静地想我们要做什么~~（骂出题人出模拟题）~~

首先我们已经知道用并查集来维护联通块和气，我们考虑枚举，当前不能下的点可定以后也不能下，所以考虑用一个队列，做法如下：

>1.从黑棋队列中拿出一个点，队列为空就无法下，退出

>2.尝试放置，如果不能放置，回到1

>3.放置，更新气

>4.从白棋队列中拿出一个点，队列为空就无法下，退出

>5.尝试放置，如果不能放置，回到4

>6.放置，更新气,到1


```
struct Pair2{
	int x, y;
	Pair2(){ } Pair2(int X, int Y):x(X), y(Y){	}
};//等于stl pair<int,int>
queue<Pair2> white, black;
inline void solve(){
		while(1){ //先走黑，再走白，没法走就退 
			int flag(0);
			while(!black.empty()){
				int x = black.front().x, y = black.front().y;
				black.pop(); if(mp[x][y] != '.') continue;
				if(check(x, y, 'X')){
					flag = 1; printf("%d %d\n", x, y);
					break;
				}
			} 
			if(!flag){
				printf("%d %d\n", -1, -1);
				return;
			}
			flag = 0;
			while(!white.empty()){
				int x = white.front().x, y = white.front().y;
				white.pop(); if(mp[x][y] != '.') continue;
				if(check(x, y, 'O')){
					flag = 1; printf("%d %d\n", x, y);
					break;
				}
			}
			if(!flag){
				printf("%d %d\n", -1, -1);
				return;
			}
		}
	}
```
写出来长这样，我们还需要解决check这个函数

考虑几种情况，举放黑棋作为例子

>1.把某一个白色联通块堵死

>2.自己跳到白棋的包围里

>3.连接了若干个黑色联通块后自杀

一是很好判断的，扫一遍周围减掉然后看有没有联通块断气再回溯就好了

二也很好判断，扫一遍看周围是不是都是白

三的情况，说明周围的每个黑联通块，都有且仅有当前这个点作为气，那么说明该点不能放。否则，因为黑色成为一整个联通块，只要有一个联通块有气，就说明是可以放的

所以我们把check也写好了

```cpp
inline bool inarea(int x, int y){
	return x >= 1 && y >= 1 && x <= n && y <= n;
}
inline bool check(int x, int y, char c){//检查能不能放某个棋子 
		int cnt1(0), cnt2(0), cnt3(0);//cnt1是空白的数量,cnt2是当前棋子的数量，cnt3是另一种颜色棋子的数量 
		for(int i(0); i < 4; ++i){
			int nx = x + dx[i], ny = y + dy[i];
			if(!inarea(nx, ny)) continue;
			if(mp[nx][ny] == c) ++cnt2;
			else if(mp[nx][ny] == '.') ++cnt1;
			else ++cnt3;
		}
		if(cnt1 == 0 && cnt2 == 0) return false; //情况2，周围都是另一种颜色的棋子 
		//先检查另一种颜色 
		for(int i(0); i < 4; ++i){
			int nx = x + dx[i], ny = y + dy[i];
			if(!inarea(nx, ny)) continue;
			if(mp[nx][ny] != c && mp[nx][ny] != '.') --qi[f(code(nx,ny))];//把另一种颜色的气减掉 
		}
		bool flag_oppo(true);
		for(int i(0); i < 4; ++i){
			int nx = x + dx[i], ny = y + dy[i];
			if(!inarea(nx, ny)) continue;
			if(mp[nx][ny] != c && mp[nx][ny] != '.') {
				if(qi[f(code(nx, ny))] == 0) flag_oppo = false;//情况1，如果有一个另一种颜色的联通块断气，那么就退出 
				++qi[f(code(nx,ny))];//回溯 
			}
		}
		if(!flag_oppo) return false;//如果断气就返回假 
		if(!cnt2 || cnt1){//如果不会影响到白块，且周围有空格或者没有同色棋，这个棋肯定可以放（不在3这种情况内） 
			place(x, y, c);
			return true;
		}
		for(int i(0); i < 4; ++i){
			int nx = x + dx[i], ny = y + dy[i];
			if(!inarea(nx, ny)) continue;
			if(mp[nx][ny] == c) --qi[f(code(nx,ny))];//减掉同色联通块的气 
		}
		bool flag_me(false);
		for(int i(0); i < 4; ++i){
			int nx = x + dx[i], ny = y + dy[i];
			if(!inarea(nx, ny)) continue;
			if(mp[nx][ny] == c)
				if(qi[f(code(nx, ny))] > 0) //说明还有除了该子位置的气 
					flag_me = true;
		}//这里回溯放到后面，放置某一个联通块回溯后判断可行 
		for(int i(0); i < 4; ++i){
			int nx = x + dx[i], ny = y + dy[i];
			if(!inarea(nx, ny)) continue;
			if(mp[nx][ny] == c)
				++qi[f(code(nx,ny))];
		}//对同色联通块回溯 
		if(flag_me) place(x, y, c);//如果ok就放子 
		return flag_me;
	}
```

check如果ok就可以放子了，所以我们写了一个place函数

上面已经说过重复统计无所谓，因为放置的时候会重复减掉的
```cpp
inline void place(int x, int y, char c){
		mp[x][y] = c; int cnt(0);
		for(int i(0); i < 4; ++i){
			int nx = x + dx[i], ny = y + dy[i];
			if(!inarea(nx, ny)) continue;
			if(mp[nx][ny] == c){
				--qi[f(code(nx,ny))];
				combine(f(code(x,y)), f(code(nx, ny)));//同色就连接 
			}
			else if(mp[nx][ny] == '.') ++cnt; //记录周围空的数量 
			else --qi[f(code(nx,ny))]; //减去气 
		}
		qi[f(code(x,y))] += cnt;//防止重复计算，所以最后加 
	} // 在某个位置放下某个颜色的子 
```

至此，这道轻松简单~~（丧心病狂）~~的模拟就基本完成了

完整代码太长就不放了，基本的思想和操作都在上面了

---

## 作者：fush (赞：4)

这道题其实就是一个模拟，而且连决策都是自己决定的，完全可以从左上角枚举至右下角一个个判断。

问题在于如何高效的实现**下棋**与**判断落子是否可行**。

我们可以重新定义一下气：**一个联通块的气为它每个棋子四周的空格数之和**

很明显，如果直接模拟，不但会超时，而且不好实现。  
由于没有提子，我们可以用并查集进行优化。

那么就有一个新的问题：
如果棋局为
```
O..
O.X
OXX
```
黑棋的气就是 $3$ 了，中间的气重复了。  
那么我们可以在 $(2, 2)$ 位置下棋时，一次减去两口气就好了。

此时的复杂度是：$O(n^4)$，依旧超时。  
那么我没还有一个优化：  
**如果一种棋下不了一个点，那么永远也下不了。**   
别的题解已经证明很好了，这里不再赘述。

由于没下一步棋最多会影响周围 $4$ 个联通块，且最多走 $n^2$ 步棋，并查集查询的时间复杂度约为 $O(\alpha (n))$，所以总时间复杂度是：$O(n ^ 2 \alpha (n))$。

这道题还有一个细节：  
为了防止相同的联通块合并多次，我们需要可以用一个数组判重，还要注意撤销标记。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 611, M = N * N;
#define id(x, y) (((x) - 1) * (n + 1) + (y))
#define L(i, a, b) for(int i = (a); i <= (b); i++)
int fa[M], s[M], dx[] = {0, 0, -1, 1}, dy[] = {1, -1, 0, 0}, n, v[M];
char a[N][N];
int find(int x){return fa[x] == x ? x : fa[x] = find(fa[x]);}
bool check(int x, int y, int k){
    char c = k ? 'O' : 'X';
    int t = id(x, y), t1, x1, y1;
    s[t] = 0;
    L(k, 0, 3)s[find(id(x + dx[k], y + dy[k]))]--;
    L(k, 0, 3){
        x1 = x + dx[k], y1 = y + dy[k], t1 = find(id(x1, y1));
        s[t] += (a[x1][y1] == '.');
		if(x1 < 1 || y1 < 1 || y1 > n || x1 > n || a[x1][y1] == '.')continue;
        if(a[x1][y1] > '.' && a[x1][y1] != c && s[t1] <= 0)goto end;
        if(a[x1][y1] == c && !v[t1])v[t1] = 1, s[t] += s[t1];
    }
    if(s[t] <= 0)goto end;
    L(k, 0, 3) if(a[x1 = (x + dx[k])][y1 = (y + dy[k])] == c)
        v[t1 = find(id(x1, y1))] = 0, fa[t1] = t;
    fa[t] = t, a[x][y] = c; 
    return 1;
    end:
    L(k, 0, 3)s[(t1 = find(id(x + dx[k], y + dy[k])))]++, v[t1] = 0;
    return 0;
}
void dfs(int x, int x1, int y1, int x2, int y2){
    L(i, (x ? x2 : x1), n)
    L(j, (i == (x ? x2 : x1) ? (x ? y2 : y1) : 0) + 1, n)
    if(a[i][j] == '.' && check(i, j, x)){
    	cout << i << " "<< j <<endl;
    	if(x)dfs(1 - x, x1, y1, i, j);
    	else dfs(1 - x, i, j, x2, y2);
    	return;
	}
    cout << "-1 -1" << endl;
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    cin >> n;
    L(i, 1, n)L(j, 1, n)cin >> a[i][j];
    iota(fa + 1, fa + M - 2, 1);
    L(i, 1, n)
	L(j, 1, n){
		if(a[i][j] == '.')continue;
        int t = id(i, j), t1;
        L(k, 0, 3)s[t] += (a[i + dx[k]][j + dy[k]] == '.');
        if(a[i][j] == a[i][j - 1] && (t1 = find(id(i, j - 1))) != t) s[t] += s[t1], fa[t1] = t;
        if(a[i][j] == a[i - 1][j] && (t1 = find(id(i - 1, j))) != t) s[t] += s[t1], fa[t1] = t;
    }
    dfs(0, 1, 1, 1, 1);
}
```
~~最后放一下[我的博客](https://www.luogu.com.cn/user/755820)~~

---

## 作者：囧仙 (赞：4)

## 简要题意

> 给定 $n\times n$ 的围棋残局。现轮流下黑子和白子，每下一个子都不能发生提子（即任何一个同色棋子连通块边上都要有至少一个空格），谁不能继续下棋则判定失败。你需要输出一种可能的下棋顺序。  
$n\le 600$ 。保证残局合法。


## 题解

现提供一个目前 $(2020.4.8)$ 时间最短+代码最短（尽管不排除压行嫌疑……）的思路。

根据围棋的「气」的定义，我们能够发现，一个同色棋子连通块没有「气」当且仅当它的四周不存在空格。所以我们只要维护每个连通块四周**与空格相邻的边的个数**就行了。不妨设为 $S$ 值。

本题中只存在下棋操作。也就是说，只存在**合并同色棋子连通块**的操作。因而很容易想到要用并查集进行维护。我们将信息存储在并查集中的祖先节点，只要你对并查集有初步运用，就能写同色棋子连通块的合并操作。我们使用路径压缩进行优化，用来保证这部分复杂度的正确性。

对于残局，我们只要合并相同颜色的棋子所在的连通块就行了（写 $\rm dfs/ bfs$ 是不可能的，这辈子也不可能写的）。考虑从上到下从左往右枚举每个棋子，若其与上方棋子同色，就进行合并；若其与左方棋子同色，也进行合并。但要注意形如以下情况：

$$\def{\arraystretch}{1.5}\begin{array}{|c|c|}\hline\bigcirc&\bigcirc\cr\hline\bigcirc&\triangle\cr\hline\end{array}$$

我们枚举到了三角形位置，并且要进行合并。当我们把它和上方节点所在连通块合并后，就没有必要合并左侧连通块了，因为二者已经在同一连通块中。

关于下棋，有一个非常巧妙的结论：如果某种颜色的棋子（不妨设颜色为 $c$），不能下在 $(x,y)$ ，那么它就永远不能下在 $(x,y)$ 了。证明非常简单，它不能下在 $(x,y)$ ，当且仅当这里不是空格，或者下在这里后存在某同色连通块没有气。对于后者，会出现这种情况时，就说明 $(x,y)$ 是这个连通块与外界相邻的唯一格子了。不会有其他地方的棋子会影响到它「气」的判定。

所以开两个指针，维护两种颜色的棋子分别扫到了哪，容易发现总共扫描的次数是不超过 $2\cdot n^2$ 的。下面要做的就是快速判定下在某个位置（比如 $(x,y)$ ）下个颜色为 $c$ 的棋子是否合法。

我们可以试错。也就是在 $(x,y)$ 这个地方下个棋子，如果发现它不能下，我就撤回。但这样就要写可撤回并查集，会很麻烦。事实上只要维护下了 $(x,y)$ 后是否存在连通块没有气（就是某连通块的 $S$ 值是否变成了 $0$ ）就行了。显然，这个棋子只会影响到它四周最多 $4$ 个连通块的判定，因而只要考虑这 $4$ 个，这也是复杂度的保证之一。

- 我们先把它周围四条边全减掉。如果存在**异色**连通块没气了就说明不能下，需要进行撤回操作。同色连通块略微复杂一些，因为涉及到合并操作。

- 然后合并**同色**连通块。注意，这里是**伪**合并，我们并没有真正合并并查集，只要求出合并后的连通块的 $S$ 值就行。这是比较简单的，但有个小坑：相同连通块不要计算多次。这可以用类似哈希表一样的玩意判重，**但是要记得撤销标记**。如果伪合并后这个连通块 $S=0$ ，需要进行撤回操作。

- 如果需要进行撤回操作，我们就把 $4$ 条边加回去就完事了。由于我们压根没有真正合并任何连通块，所以不需要可撤回并查集。

- 如果这个地方可以下棋，就把同色连通块真正合并起来即可。

要注意的是，如果 $(x,y)$ 不能下颜色为 $c$ 的棋，就要把对应指针向后移，直到指针遍历完所有 $n^2$ 个可能位置，直接退出就行了。

实现细节比较多，容易卡人。具体可以见代码。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
using namespace std;
#define to(x,y) ((x-1)*n+y)
#define gt \
    int nx=x+D[d][0],ny=y+D[d][1]; if(!isalpha(W[nx][ny])) continue; \
    int g=gtf(to(nx,ny))
const int XN=600+3,XM=XN*XN,D[4][2]={{1,0},{0,1},{-1,0},{0,-1}},C[2]={'X','O'};
int n,o,F[XM],t,tt,p[2]={1,1},S[XM]; char W[XN][XN]; bool V[XM];
int gtf(int x){return x==F[x]?x:F[x]=gtf(F[x]);}
int main(){
    scanf("%d",&n); up(1,n,i) scanf("%s",W[i]+1);
    up(1,n,i) up(1,n,j){
        t=F[to(i,j)]=to(i,j); if(W[i][j]=='.') continue;
		up(0,3,d) S[t]+=(W[i+D[d][0]][j+D[d][1]]=='.');
        if(W[i][j]==W[i-1][j]&&t!=(tt=gtf(to(i-1,j)))) S[t]+=S[tt],F[tt]=t;
        if(W[i][j]==W[i][j-1]&&t!=(tt=gtf(to(i,j-1)))) S[t]+=S[tt],F[tt]=t;
	}
    while(p[0]<=t&&p[1]<=t){
        int x=(p[o]-1)/n+1,y=(p[o]-1)%n+1,s=0,q=to(x,y); ++p[o];
        if(W[x][y]!='.') continue;
        up(0,3,d) {s+=(W[x+D[d][0]][y+D[d][1]]=='.');gt; --S[g];}
        up(0,3,d){
			gt; if(W[nx][ny]==C[o])s+=(!V[g])*S[g],V[g]=1;else if(!S[g]) s=-1e9;
		}
        up(0,3,d){gt; V[g]=0;} if(s<=0) up(0,3,d){gt;++S[g];} else {
			S[q]=s,W[x][y]=C[o],printf("%d %d\n",x,y);
			up(0,3,d){gt;if(W[nx][ny]==C[o])F[g]=q;} o^=1;
		}
	}
	puts("-1 -1");
    return 0;
}
```

---

## 作者：Milthm (赞：2)

我不太好评价这题。你说它难，代码只有 $88$ 行。你说它简单，我做了将近 $1$ 年……

____

这是一个很好的模拟题。首先原本题目定义的“气”并不利于我们做题（第一版代码挂的原因）。

所以我们定义一个联通块的气为它的所有棋子周围空格数之和，这样后面操作很方便，而且气没了也就代表了连通块会被吃掉。

你直接模拟就会获得大大的 TLE，即使加了并查集优化这个过程也不行（第二、三版代码挂的原因）。

但是你发现如果一个位置这个时候放不了一种颜色的子，那它以后永远也放不了（因为游戏不允许提子）。所以可以记录一下，下次直接从上次走到的地方后面开始走就行。

然后判断是否可以放子时有些地方要注意：

- 你要先把气加起来再判断。

- 你如果放在这里不行的话，需要把周围减去的气加回来。

### AC code

```cpp
#include<bits/stdc++.h>
#define N 2005
using namespace std;
int n,qx[2],qy[2],cnt,yhb[N],t,now,qi[N*N*2],f[N*N*2],vis[N][N],w[4][2]={{0,1},{1,0},{0,-1},{-1,0}};
//X:0  O:1
set<int>s; 
int find(int x){
	if(f[x]==x)return x;
	return f[x]=find(f[x]);
}
bool U(int x,int y){
	int px=find(x),py=find(y);
	if(px!=py)f[px]=py;
	return px!=py;
}
int go(int x,int y){
	return (x-1)*n+y;
}
char a[N][N],u[2]={'X','O'};
void dfs(int x,int y,int k,char c){
	for(int i=0;i<4;++i){
		int px=x+w[i][0],py=y+w[i][1];
		if(a[px][py]=='.')++cnt;
		if(!vis[px][py]&&a[px][py]==c){
			U(k,go(px,py));vis[px][py]=1;dfs(px,py,k,c);
		}
	}
}
int main(){
	cin>>n;
	for(int i=1;i<=n*n*2;++i)f[i]=i;
	for(int i=1;i<=n;++i){
		for(int j=1;j<=n;++j)cin>>a[i][j];
	}
	for(int i=1;i<=n;++i){
		for(int j=1;j<=n;++j){
			if(a[i][j]!='.'&&!vis[i][j]){
				cnt=0;
				vis[i][j]=1;dfs(i,j,go(i,j),a[i][j]);
				qi[find(go(i,j))]=cnt;
			}
		}
	}
	qx[0]=qx[1]=qy[0]=qy[1]=1;
	while(1){
		int x=qx[now],y=qy[now];
		while(x<=n){
			int f=0,sp=0;
			if(a[x][y]!='.')f=1;
			s.clear();
			for(int i=0;i<4;++i){
				int px=x+w[i][0],py=y+w[i][1];
				if(a[px][py]==u[now])s.insert(find(go(px,py))),qi[find(go(px,py))]--;
				if(a[px][py]==u[!now]){
					qi[find(go(px,py))]--;
					if(qi[find(go(px,py))]<=0)f=1;
				}
				if(a[px][py]=='.')++sp;
			}
			t=0;
			for(auto i:s)yhb[++t]=i;
			if(!f){
				int ans=0;
				for(int i=1;i<=t;++i)ans+=qi[yhb[i]];
				if(ans+sp<=0)goto R;
				for(int i=1;i<=t;++i)U(go(x,y),yhb[i]);
				qi[find(go(x,y))]=ans+sp;
				break;
			}
			R:for(int i=0;i<4;++i){
				int px=x+w[i][0],py=y+w[i][1];
				if(a[px][py]==u[now])++qi[find(go(px,py))];
				if(a[px][py]==u[!now])++qi[find(go(px,py))];
			}
			if(y==n)++x,y=1;
			else ++y;
		}
		if(x>n)break;
		cout<<x<<" "<<y<<'\n';
		a[x][y]=u[now];
		if(y==n)++x,y=1;
		else ++y;
		qx[now]=x,qy[now]=y;
		now=!now;
	}
	cout<<"-1 -1\n";
	return 0;
} 
```
最后祝大家新年快乐！




---

## 作者：stoorz (赞：2)

[$\color{blue}\texttt{链接:蒟蒻的Blog}$](https://blog.csdn.net/SSL_ZYC/article/details/90548612)

$$\color{red}\texttt{AC的第一道较恶心模拟题祭orz}$$

这道题有SPJ，所以就顺序枚举黑棋白棋落子点。


先说一下大体思路吧

显然直接模拟是$O(n^4)$的。所以考虑用并查集记录连通块和气，然后再记录下上一次黑棋白棋放置的位置，直接从那个位置往下枚举即可。

先处理好初始的连通块和气。

每次判断这个落子点是否可行。如果可以，那么就把棋子落在这里，并维护上下左右棋子的气，维护联通集合。

为了简便起见，我们修改一下气的定义。一个连通块的气为$\sum s(x)(x\in$该连通块$)$，其中$s(x)$表示棋子$x$的上下左右有几个空格子。
这样定义的话，下图黑棋的气就是5气，而不是2气。

![在这里插入图片描述](https://img-blog.csdnimg.cn/2019052516143687.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NTTF9aWUM=,size_16,color_FFFFFF,t_70)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190525161639796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NTTF9aWUM=,size_16,color_FFFFFF,t_70)

这样的好处是：如果我们用白棋填上最中间的位置，黑棋的气就只要减去3就可以了。否则的话还只能判断这个白棋所连接的黑棋是否是在同一个连通块内，会比较麻烦。

*******

#### 1.如何判断$(x,y)$能否落子

一个点`不`可以落子，只有满足以下任意条件才行：

 - 落子后，周围另一方的棋子的气变成0
 - 落子后，这个子及所在连通块的气为0

周围另一方棋子的气是比较好判断的。只要把周围所有的对方棋子所在连通块气减1，然后判断这些连通块内是否有块没气了。只要有1个块没气，$(x,y)$就是不可以落子的。


```cpp
if (map[i-1][j]==oth) sum[find(C(i-1,j))]--;
if (map[i+1][j]==oth) sum[find(C(i+1,j))]--;
if (map[i][j-1]==oth) sum[find(C(i,j-1))]--;
if (map[i][j+1]==oth) sum[find(C(i,j+1))]--;
//。。。。。。
//判断这个子及所在连通块的气是否为0
bool ok=0;
if (sum[find(C(i-1,j))] && sum[find(C(i+1,j))] && sum[find(C(i,j-1))] && sum[find(C(i,j+1))])
	ok=1;
if (map[i-1][j]==oth) sum[find(C(i-1,j))]++;
if (map[i+1][j]==oth) sum[find(C(i+1,j))]++;
if (map[i][j-1]==oth) sum[find(C(i,j-1))]++;
if (map[i][j+1]==oth) sum[find(C(i,j+1))]++;
```


判断这个子及所在连通块的气是否为0的话，先假设这个点的气为4，如果上下左右有棋子和该棋子的颜色相同，那么就加上这个连通块的气，但是同时也要减去2。因为在没有落子之前，该连通块有1气是在这个点上的，但是现在这个点落子了，这个气就没有了。并且我们一开始假设$(x,y)$的气为4，但是现在并不是上下左右都是空的，还要减去1。


然后，如果这个点的上下左右是边界或者对方棋子，气也要减少。

```cpp
int s=4;
if (map[i-1][j]==ch)
{
	s-=2;
	if (!vis[find(C(i-1,j))])  //注意，每个连通块的气只能加一次，所以要判断这个连通块是否加过
	{		
		vis[find(C(i-1,j))]=1;
		s+=sum[find(C(i-1,j))];
	}
}
if (map[i+1][j]==ch)
{
	s-=2;
	if (!vis[find(C(i+1,j))])
	{
		vis[find(C(i+1,j))]=1;
		s+=sum[find(C(i+1,j))];
	}
}
if (map[i][j-1]==ch)
{
	s-=2;
	if (!vis[find(C(i,j-1))])
	{
		vis[find(C(i,j-1))]=1;
		s+=sum[find(C(i,j-1))];
	}
}
if (map[i][j+1]==ch)
{
	s-=2;
	if (!vis[find(C(i,j+1))])
	{
		vis[find(C(i,j+1))]=1;
	s+=sum[find(C(i,j+1))];
	}
}
vis[find(C(i-1,j))]=vis[find(C(i+1,j))]=vis[find(C(i,j-1))]=vis[find(C(i,j+1))]=0;  //还原
if (map[i-1][j]==oth||i==1) s--;
if (map[i+1][j]==oth||i==n) s--;
if (map[i][j-1]==oth||j==1) s--;
if (map[i][j+1]==oth||j==n) s--;  //判断边界和对方棋子

bool ok=0;
if (s) ok=1;
```

这样，我们的$check$函数就写好了。

*******
#### 2.如何合并连通块

这个应该相对简单吧。
需要解决的问题有3个。

 - 新连通块的气
 - 如何合并连通块
 - 对手连通块的气


其实不用处理新连通块的气。因为我们在$check$函数里已经判断了落子后这个连通块的气是否大于0，而用到的变量$s$就是这个连通块的气。如果这个位置可以落子，那么直接把气赋值给$s$就可以了。

合并连通块其实就是最基本的并查集操作，如果上下左右是我方棋子，那么就将这个连通块和$(x,y)$合并。

处理对手的气也是非常简单的。由于我们把气的定义更改了，所以就不用判断“上和下的两个连通块是否是同一个连通块”之类的问题了。直接取上下左右的连通块的祖先，把它的气减1就可以了。

```cpp
map[X][Y]=push;
if (map[X-1][Y]==map[X][Y]) father[find(C(X-1,Y))]=find(C(X,Y));
if (map[X+1][Y]==map[X][Y]) father[find(C(X+1,Y))]=find(C(X,Y));
if (map[X][Y-1]==map[X][Y]) father[find(C(X,Y-1))]=find(C(X,Y));
if (map[X][Y+1]==map[X][Y]) father[find(C(X,Y+1))]=find(C(X,Y));
		
char oth=(push=='X'?'O':'X');
if (map[X-1][Y]==oth) sum[find(C(X-1,Y))]--;
if (map[X+1][Y]==oth) sum[find(C(X+1,Y))]--;
if (map[X][Y-1]==oth) sum[find(C(X,Y-1))]--;
if (map[X][Y+1]==oth) sum[find(C(X,Y+1))]--;
		
printf("%d %d\n",X,Y);
if (push=='X') pushX=C(X,Y)+1;
	else pushO=C(X,Y)+1;
push=(push=='X'?'O':'X');
```

然后这道模拟就这样切了。

[$\color{blue}\texttt{代码链接}$](https://blog.csdn.net/SSL_ZYC/article/details/90548612)

---

## 作者：血色黄昏 (赞：1)

PS：模拟代码真的可以调到吐...整整Debug了1h才发现是变量名重复了，淦。

~~作为一个下过9年围棋的人，我切这道题还是用了一两天，我真的菜/kk~~

作为一道模拟的紫题，这道题肯定是有它难度所在的
~~（比如猪国杀）~~，这道题还需要用到并查集判连通块，但也就仅此而已，也真的足够水了QAQ

因为有SPJ这个可以取巧的好东西，我的思路就是按照顺序一个一个点下过去，能下就下，然后用并查集维护一下连通块即可

判断是否能落子写起来很烦，细节需要注意，原理就是落子后如果另一方棋子没气或者自己的连通块没气了，就是不能下，其他情况是都可以下的

合并连通块嘛，难度系数极低，就是基本的并查集合并，如果是自己棋子，就直接合，对手的话直接去周围的祖先将气减一

真的没什么好说的了，直接上代码吧，模拟的话我就不会写很多注释了，大家自己好好想想吧

前方151行长代码~

```cpp
n, X, Y, pushX, pushO, fa, s = 0, 0, 0, 0, 0, [-1 for i in range(610 ** 2)], ['' for i in range(610 ** 2)]
ma = [['1' for j in range(610)] for i in range(610)]
push = ''
vis = [[True for j in range(610)] for i in range(610)]


def find(a):#并查集的寻找操作
    pa = fa[a]
    if pa == a:
        return a
    return find(pa)


def C(x, y):#返回位置
    if x > n or y > n or x < 1 or y < 1:
        return 0
    return (x - 1) * n + y


def cp(c):#判断是否能落子
    global s, X, Y
    if c == 'X':
        o = '0'
        c = pushX
    else:
        o = 'X'
        c = pushO
    for k in range(c, n ** 2 + 1):
        i = int((k - 1) / n + 1)
        j = int((k - 1) % n + 1)
        if ma[i][j] == '.':
            if ma[i - 1][j] == o:
                s[find(C(i - 1, j))] -= 1
            if ma[i + 1][j] == o:
                s[find(C(i + 1, j))] -= 1
            if ma[i][j - 1] == o:
                s[find(C(i, j - 1))] -= 1
            if ma[i][j + 1] == o:
                s[find(C(i, j + 1))] -= 1
            s1 = 4
            if ma[i - 1][j] == c:
                s1 -= 2
                if vis[find(C(i-1, j))] is False:
                    vis[find(C(i - 1, j))] = 1
                    s1 += s[find(C(i - 1, j))]
            if ma[i + 1][j] == c:
                s1 -= 2
                if vis[find(C(i+1, j))] is False:
                    vis[find(C(i+1, j))]=1
                    s1 += s[find(C(i+1, j))]
            if ma[i][j-1] == c:
                s1 -= 2
                if vis[find(C(i, j-1))] is False:
                    vis[find(C(i, j-1))]=1
                    s1 += s[find(C(i, j-1))]
            if ma[i][j+1] == c:
                s1 -= 2
                if vis[find(C(i, j+1))] is False:
                    vis[find(C(i, j+1))] = 1
                    s1 += s[find(C(i, j+1))]
            vis[find(C(i-1, j))], vis[find(C(i+1, j))], vis[find(C(i, j-1))], vis[find(C(i, j+1))]=0, 0, 0, 0
            if ma[i-1][j] == o or i == 1:
                s1 -= 1
            if ma[i+1][j] == o or i == n:
                s1 -= 1
            if ma[i][j-1] == o or j == 1:
                s1 -= 1
            if ma[i][j+1] == o or j == n:
                s1 -= 1

            ok = False
            if s1 and s[find(C(i-1, j))] and s[find(C(i+1, j))] and s[find(C(i, j-1))] and s[find(C(i, j+1))]:
                ok = True

            if ma[i-1][j] == o:
                s[find(C(i-1, j))] += 1
            if ma[i+1][j] == o:
                s[find(C(i+1, j))] += 1
            if ma[i][j-1] == o:
                s[find(C(i, j-1))] += 1
            if ma[i][j+1] == o:
                s[find(C(i, j+1))] += 1
            if ok is True:
                s[C(i, j)] = s1
                X = i
                Y = j
                return 1
    return 0


n = int(input())
for i in range(1, n + 1):#读入
    s2 = input()
    j = 1
    while j <= len(s2):
        ma[i][j] = s2[j - 1]
        while ma[i][j] != 'X' and ma[i][j] != 'O' and ma[i][j] != '.':
            ma[i][j] = s2[j + 1]
            j += 1
        fa[C(i, j)] = C(i, j)
        j += 1
for i in range(1, n + 1):#维护联通块
    for j in range(1, n + 1):
        s[C(i, j)] = 0
        if ma[i - 1][j] == ma[i][j] and ma[i][j] != '.':
            fa[find(C(i, j))] = find(C(i - 1, j))
        if ma[i][j - 1] == ma[i][j] and ma[i][j] != '.':
            fa[find(C(i, j))] = find(C(i, j - 1))
        if ma[i - 1][j] == '.':
            s[find(C(i, j))] += 1
        if ma[i + 1][j] == '.':
            s[find(C(i, j))] += 1
        if ma[i][j + 1] == '.':
            s[find(C(i, j))] += 1
        if ma[i][j - 1] == '.':
            s[find(C(i, j))] += 1
push = 'X'
pushX, pushO = 1, 1
while cp(push):#开始落子
    ma[X][Y] = push
    if ma[X - 1][Y] == ma[X][Y]:
        fa[find(C(X-1, Y))] = find(C(X, Y))
    if ma[X+1][Y] == ma[X][Y]:
        fa[find(C(X+1, Y))] = find(C(X, Y))
    if ma[X][Y-1] == ma[X][Y]:
        fa[find(C(X, Y-1))] = find(C(X, Y))
    if ma[X][Y+1] == ma[X][Y]:
        fa[find(C(X, Y+1))] = find(C(X, Y))
    ot = ''
    if push == 'X':
        ot = 'O'
    else:
        ot = 'X'
    if ma[X - 1][Y] == ot:
        s[find(C(X-1, Y))] -= 1
    if ma[X + 1][Y] == ot:
        s[find(C(X+1, Y))] -= 1
    if ma[X][Y - 1] == ot:
        s[find(C(X, Y-1))] -= 1
    if ma[X][Y + 1] == ot:
        s[find(C(X, Y+1))] -= 1
    print(X, Y)#能落子就输出
    if push == 'X':
        pushX = C(X, Y)+1
    else:
        pushO = C(X, Y)+1
    if push == 'X':
        push = 'O'
    else:
        push = 'X'
print("-1 -1")#最后输出-1 -1结束


```

祝大家暑假快乐(又是这句话qwq

---

## 作者：上天台 (赞：1)

~~好丧心病狂的模拟题啊。。。~~

直接模拟是O(n^4)的。

显然操作次数没法优化了。。

现在你有一些选择：

1.维护一个合法点集合，每次直接找到合法的点，然后落子时删去所有新产生的不合法点。

2.每次找一个点，判断是否合法；合法再落子，计算影响。并要求找到合法点的均摊复杂度是低的。

我一开始写了第一种做法，然后死了。原因在于这种做法的模块非常不清晰。。。实现起来思路并不直观，而且很难实现（反正我不会了orz...）

然后看第二种做法。

我们希望每次能够快速地找到一个可行的点。

I，一个点不可行时是什么情况？

1.已经涂色了。

2.是周围所有同色连通块惟一的气或没有同色连通块，且周围没有空格。

3.是周围某个异色连通块惟一的气。

**对于同一种颜色，**如果一个点之前不可行，那么之后也不会可行了。这样的话，只要对每种颜色开个队列，出现不合法的点就扔掉即可。

II，下了一个棋子会产生什么影响？

1.这个点不再是它周围连通块的气。

2.在这个点上新建一个连通块，并将它和周围的同色连通块合并。

在一个点上新建一个连通块的操作：
它的父亲是自己，颜色是当前的颜色；周围的空格是它的气。
合并操作：将两个连通块的气合并在一起。

那么问题就变成了，要维护一个数据结构，使得它支持快速加入和删除，而且最好会过滤重复元素。显然set可以解决一切问题。。。

一些细节：

1.预处理：把所有点都进队，并处理出每个连通块以及它们的气的集合。

2.在下棋后合并同色连通块的过程中，采用启发式合并可以保证复杂度。（同一时刻，所有set中元素加起来总数不会超过4*n*n）

那么复杂度就是O(n*n*log n)的。

重点是想清楚了再下手啊。。。。。我一开始觉得是模拟于是上手就是瞎写，然后“成功获得了整整1分”！（233大概不会有人和我一样被题面枪到了吧。。）然后还怒调不出。。。orz。

代码：

```cpp
#include<bits/stdc++.h>
#include<set>
#include<algorithm>
using namespace std;
#define rep(x,y,z) for (int x=y; x<=z; x++)
#define downrep(x,y,z) for (int x=y; x>=z; x--)
#define ms(x,y,z) memset(x,y,sizeof(z))
#define LL long long
#define repedge(x,y) for (int x=hed[y]; ~x; x=edge[x].nex)
inline int read(){
	int x=0; int w=0; char ch=0;
	while (ch<'0' || ch>'9') w|=ch=='-',ch=getchar();
	while (ch>='0' && ch<='9') x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return w? -x:x;
}
const int M=605;
const int N=M*M;
int n,a[M][M],f[N],col,sz[N],num[M][M];
int dx[4]={0,0,1,-1};
int dy[4]={1,-1,0,0};
char ss[M][M];
#define pr pair<int,int>
#define mp make_pair
#define fr first
#define se second
set< pr > s[N];
queue< pr > q[2];
int hf(int x,int y){ return ((x>=1)&&(x<=n)&&(y>=1)&&(y<=n)); }
int kd(char ch){ return (ch=='.')? 2:((ch=='X')? 1:0); }
int gf(int k){ return (k==f[k])? k:f[k]=gf(f[k]); }
void add(pr x,int k){
	if (s[k].find(x)!=s[k].end()) return;
	s[k].insert(x); ++sz[k];
}
void del(int k,pr x){
	if (s[k].find(x)==s[k].end()) return;
	s[k].erase(x); --sz[k];
}
void join_1(int a,int b){
	int fa=gf(a); int fb=gf(b); if (fa==fb) return; f[fa]=fb;
}
void join_2(int a,int b){
	int fa=gf(a); int fb=gf(b); if (fa==fb) return;
	if (sz[fa]>sz[fb]){ swap(a,b); swap(fa,fb);	}
	for(set< pr > :: iterator i=s[fa].begin(); i!=s[fa].end(); i++)
	add((*i),fb); f[fa]=fb;
}//启发式合并
void prework(){
	rep(i,1,n) rep(j,1,n) f[num[i][j]]=num[i][j];
	rep(i,1,n) rep(j,1,n) if (a[i][j]!=2) rep(k,0,3){
		int newx=i+dx[k]; int newy=j+dy[k];
		if (hf(newx,newy)&&(a[newx][newy]==a[i][j]))
		join_1(num[newx][newy],num[i][j]);
	}
	rep(i,1,n) rep(j,1,n) if (a[i][j]==2) rep(k,0,3){
		int newx=i+dx[k]; int newy=j+dy[k];
		if (hf(newx,newy)&&(a[newx][newy]!=2))
		add(mp(i,j),gf(num[newx][newy]));
	}
}
int check(int k){
	int cnt=0;
	for(set< pr > :: iterator i=s[k].begin(); i!=s[k].end(); i++)
	{ ++cnt; if (cnt>1) break; }
	return (cnt<=1);
}//集合k是否只有惟一的气
pr find_hf(){
	while(!q[col].empty()){
		pr k=q[col].front(); q[col].pop();
		int x=k.fr; int y=k.se; 
		//I.1已涂色
        if (a[x][y]!=2) continue;
		int pd0=0; int pd1=1; int pd=0;
		//I.2没有空格且是周围所有同色连通块的惟一气
        rep(i,0,3){
			int newx=x+dx[i]; int newy=y+dy[i];
			if (hf(newx,newy)&&(a[newx][newy]==col)){
				pd0=1; int fa=gf(num[newx][newy]);
				if (!check(fa)) pd1=0;
			}
			if (hf(newx,newy)&&(a[newx][newy]==2)) pd=1;
		}
		if ((pd0)&&(pd1)&&(!pd)) continue;
	
		//I.3是某个异色连通块的惟一气
        int pd2=0;
		rep(i,0,3){
			int newx=x+dx[i]; int newy=y+dy[i];
			if (hf(newx,newy)&&(a[newx][newy]==(col^1))){
				int fa=gf(num[newx][newy]);
				if (check(fa)) pd2=1; 
			}
		}
		if (pd2) continue;
		
		//I.2被异色连通块所包围，我重构代码之后第一遍就挂在了这里。。
        int pd3=0;
		rep(i,0,3){
			int newx=x+dx[i]; int newy=y+dy[i];
			if (hf(newx,newy)&&(a[newx][newy]!=(col^1))) pd3=1;
		}
		if (!pd3) continue;
		return k;	
	}
	return mp(0,0);
}
void solve(pr nw){
	int x=nw.fr; int y=nw.se; 
	printf("%d %d\n",x,y);
	//它不再是气了
    rep(i,0,3){
		int newx=x+dx[i]; int newy=y+dy[i];
		if (hf(newx,newy)&&(a[newx][newy]!=2)){
			int fa=gf(num[newx][newy]);
			del(fa,mp(x,y)); 
		}
	}
	
    //新建一个连通块
	f[num[x][y]]=num[x][y]; a[x][y]=col;
    rep(i,0,3){
    	int newx=x+dx[i]; int newy=y+dy[i];
    	if (hf(newx,newy)&&(a[newx][newy]==2))
    	add(mp(newx,newy),num[x][y]);
    }
    
    //合并连通块
    rep(i,0,3){
    	int newx=x+dx[i]; int newy=y+dy[i];
    	if (hf(newx,newy)&&(a[newx][newy]==col))
    	join_2(num[x][y],num[newx][newy]);
    }
}
int main(){
	scanf("%d",&n);
	rep(i,1,n) scanf("%s",&ss[i]);
	rep(i,1,n) rep(j,1,n) a[i][j]=kd(ss[i][j-1]);
	rep(i,1,n) rep(j,1,n) num[i][j]=(i-1)*n+j;
	prework();
	rep(i,1,n) rep(j,1,n) q[0].push(mp(i,j)),q[1].push(mp(i,j));
	col=1; 
	rep(i,1,n*n){
		pr tmp=find_hf();		
		if (tmp==mp(0,0)) break;
		solve(tmp); col^=1;
	}
	printf("-1 -1\n");
	return 0;
}
```

---

## 作者：寄风 (赞：1)

### 题意
给你一个 $n\times n$ 的当前黑方落子的不围棋残局，不围棋就是不能吃别人的子的围棋，谁先不能落子谁输。现在让你任意制定黑方和白方的行动，模拟这一场棋局。
### 题解
因为落子策略由我们制定，所以我们可以枚举每一回合黑白方的落子位置，找到第一个可以落子的地方落子。

所以现在我们有了一个暴力做法，就是每次枚举落子点，然后处理这个点四周的连通块，广搜求「气」的数量，时间复杂度 $O(n^6)$（落子次数 $O(n^2)$ 级别，枚举落子点 $O(n^2)$，广搜 $O(n^2)$。

~~啥？你说结束了？$n\leq 600$，过了我请你吃糖。~~

但是这样并不能过。

发现我们维护的是棋子的连通块，而且没有删棋，考虑并查集。

但是我们发现这个「气」的定义很烦，因为如果我的棋盘是这样的:
```
3
...
OXX
.O.
```
现在我们的黑棋有三个「气」，但是黑方落子落在 $(1,2)$，原本会给这个黑棋连通块增加两个「气」，但是位于 $(1,2)$ 的黑子的 $(1,3)$ 这个「气」与位于 $(2,3)$ 的黑子的 $(1,3)$ 的「气」重复了，这并不方便我们并查集把一个元素加入集合。

~~你想写可以试试，多半写不出，过了我也请你吃糖。~~

正确的姿势是修改「气」的定义，把两个棋子重复的「气」算成两个「气」。

至于正确性，就你看按照「气」原本的定义，一个棋子被提走当且仅当这个棋子的「气」数量为 $0$。你看按照修改后的定义，一个棋子被提走也是当且仅当这个棋子的「气」数量为 $0$。所以正确性没问题。

那么现在我们就可以在并查集每次把一个子加入集合的时候处理连通块的「气」，并且判断落子可不可行了。

并查集的话要给每个点标号，具体的话，点 $(i,j)$ 的标号是 $(i-1)\times n+j$。

但是我们发现，落子次数是 $O(n^2)$，每次枚举落点也是  $O(n^2)$，总时间复杂度 $O(n^4)$。

还是过不掉。

但是有一个比较神秘的结论就是如果一边下不了一个地方，那这边永远下不了这个地方。

证明的话，分三种情况讨论：

1. 落在这里把对面的棋堵死了，那么对面的棋只有这一个「气」，对面要是不落在这里增加「气」你也不能落，对面要是落了这里这里就有棋了，你就落不了了。

1. 落在这里把自己的棋堵死了，那么自己的棋只有这一个「气」，而落子在这里会把自己堵死，所以外界「气」多的本方棋也不能和这一块棋形成连通块，这块棋「气」数量就只能为 $1$。

1. 这里有棋了，因为不围棋不能提子，所以这个棋肯定会一直在这里，你就一直不能落在这里。

所以你可以维护两个二维的坐标，表示黑方白方目前标号最小的可能的落子点，所以标号前面的点都不能下。每次就从标号处开始枚举，因为我们每次找出的落子点也满足在所有可能落子点中标号最小，所以统计出答案后可以直接更新标号。

可以发现每个点最多被判断 $2$ 次（黑方一次，白方一次），维护的标号最多被更新 $n^2$ 次，所以时间复杂度 $O(n^2)$ （忽略并查集时间复杂度），可以通过。

### 实现细节
根据上面的讲解，我们需要写两个函数：

`check(fg,i,j)` 判断在 $fg$ 方（黑方是 $1$，白方是 $2$）落子时，落在 $(i,j)$ 这个位置可不可以。

`opt(fg,i,j)` 执行在 $fg$ 方（黑方是 $1$，白方是 $2$）落子时，落子落在 $(i,j)$ 这个位置的操作。

`opt` 操作很好写，就是先把落子点四周棋子所在连通块的「气」减少 $1$，然后处理落子带来的连通块合并，最后重计算落子点所在连通块的「气」数量就完成了。

`opt` 函数部分代码（$qj$ 是标号函数，$cnt$ 数组维护的是连通块的「气」数量，$calc$ 是计算一个棋子不考虑与周围棋子构成连通块时「气」的数量）：
```cpp
inline void opt(int fg,int i,int j){
    int now = qj(i,j),cc=4;
    if(i>1&&a[i-1][j]){
        cnt[Find(qj(i-1,j))]--;
    }
    if(i<n&&a[i+1][j]){
        cnt[Find(qj(i+1,j))]--;
    }
    if(j>1&&a[i][j-1]){
        cnt[Find(qj(i,j-1))]--;
    }
    if(j<n&&a[i][j+1]){
        cnt[Find(qj(i,j+1))]--;
    }
    cc=calc(i,j);
    int qwq=0;
    unordered_map <int,bool> mp;
    if(i>1&&a[i-1][j]==fg){
        int dw=Find(qj(i-1,j));
        if(!mp[dw])
        qwq+=cnt[Find(qj(i-1,j))];
        mp[dw]=1;
        Union(now , qj(i-1,j));
    }
    if(j>1&&a[i][j-1]==fg){
        int dw=Find(qj(i,j-1));
        if(!mp[dw])
        qwq+=cnt[Find(qj(i,j-1))];
        mp[dw]=1;
        Union(now , qj(i,j-1));
    }
    if(i<n&&a[i+1][j]==fg){
        int dw=Find(qj(i+1,j));
        if(!mp[dw])
        qwq+=cnt[Find(qj(i+1,j))];
        mp[dw]=1;
        Union(now , qj(i+1,j));
    }
    if(j<n&&a[i][j+1]==fg){
        int dw=Find(qj(i,j+1));
        if(!mp[dw])
        qwq+=cnt[Find(qj(i,j+1))];
        mp[dw]=1;
        Union(now , qj(i,j+1));
    }
    cnt[Find(now)] = qwq + cc;
    a[i][j]=fg;
    vis[0][i][j] = vis[1][i][j]=vis[2][i][j]=1;
}
```

恶心的部分在 `check`。

这个函数需要很多的分类讨论，这里就不说了，具体见代码。

说一点细节。

就是在 @[囧仙](https://www.luogu.com.cn/user/330759)的题解中说道，
> 也就是在 $(x,y)$ 这个地方下个棋子，如果发现它不能下，我就撤回。但这样就要写可撤回并查集，会很麻烦。

其实这并不用写可撤回并查集。

按我们的方式，把一次操作分割成一次 `check` 和一次 `opt`，我们发现下个棋子撤回的操作只要在 `check` 里实现。

先把落子点四周的连通块的「气」的数量减少 $1$，然后继续分三种情况。

1. 下这里会堵死对面。这种情况我们直接在四周找有没有对方连通块的「气」的数量变成了 $0$。
1. 下这里会堵死己方棋子。这种情况较复杂，手玩可发现如果存在己方连通块与落子点相邻且此连通块「气」的数量不为 $0$，那么就不会堵死己方棋子。这是因为下落子点会把落子点四周的己方连通块连接成一个大的连通块，而如果这些连通块中有至少一个「气」的数量大于 $0$，那么这个大连通块就不会被堵死。
1. 下这里会堵死自己。这种情况就看落子点旁边是不是要么是边界，要么是对面就行了。

最后如果发现落子不合法撤回的话就直接把落子点四周的连通块的「气」的数量增加 $1$ 就行了。

`check` 部分代码：
```cpp
inline bool check(int fg , int i , int j){
    int now = qj(i,j);
    if(vis[fg][i][j]) return 0;
    if(a[i-1][j]!=fg&&a[i+1][j]!=fg&&a[i][j-1]!=fg&&a[i][j+1]!=fg&&!calc(i , j)) return 0;
    if(a[i][j]){
        vis[fg][i][j]=1;
        return 0;
    }
    if(i>1)cnt[Find(qj(i-1,j))]--;
    if(j>1)cnt[Find(qj(i,j-1))]--;
    if(i<n)cnt[Find(qj(i+1,j))]--;
    if(j<n)cnt[Find(qj(i,j+1))]--;
    bool fgg=1;
    if(i>1&&a[i-1][j]!=fg)if(cnt[Find(qj(i-1,j))]==0)fgg=0;
    if(j>1&&a[i][j-1]!=fg)if(cnt[Find(qj(i,j-1))]==0)fgg=0;
    if(i<n&a[i+1][j]!=fg)if(cnt[Find(qj(i+1,j))]==0)fgg=0;
    if(j<n&&a[i][j+1]!=fg)if(cnt[Find(qj(i,j+1))]==0)fgg=0;
    if(!fgg){
	    if(i>1)cnt[Find(qj(i-1,j))]++;
	    if(j>1)cnt[Find(qj(i,j-1))]++;
	    if(i<n)cnt[Find(qj(i+1,j))]++;
	    if(j<n)cnt[Find(qj(i,j+1))]++;
        vis[fg][i][j]=1;
        return 0;
    }
    int cc=calc(i , j);
    if(cc){
	    if(i>1)cnt[Find(qj(i-1,j))]++;
	    if(j>1)cnt[Find(qj(i,j-1))]++;
	    if(i<n)cnt[Find(qj(i+1,j))]++;
	    if(j<n)cnt[Find(qj(i,j+1))]++;
        return 1;
    }
    vector <int> dw;
    if(i>1&&a[i-1][j]==fg)dw.push_back(qj(i-1,j));
    if(j>1&&a[i][j-1]==fg)dw.push_back(qj(i,j-1));
    if(i<n&a[i+1][j]==fg)dw.push_back(qj(i+1,j));
    if(j<n&&a[i][j+1]==fg)dw.push_back(qj(i,j+1));
    fgg=1;
    for(auto wer:dw){
        if(cnt[Find(wer)]>0){
            fgg=0;
            break;
        }
    }
    if(i>1)cnt[Find(qj(i-1,j))]++;
    if(j>1)cnt[Find(qj(i,j-1))]++;
    if(i<n)cnt[Find(qj(i+1,j))]++;
    if(j<n)cnt[Find(qj(i,j+1))]++;
    if(fgg==1){
        vis[fg][i][j]=1;
        return 0;
    }
    return 1;
}
```

实现难度较高，细节较多。

[完整代码](https://www.luogu.com.cn/paste/hohkn7y1)

---


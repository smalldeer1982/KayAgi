# 序列

## 题目描述

构建一个N个点的有向图G，初始没有任何边。接下来构建一个长度为E的边的序列A，序列中每条边都是满足1≤s,t≤N且s≠t的有向边(s,t)，且序列中的边互不相同。按照顺序把这些边加入到G中，每次加入后计算当前图的强连通分量个数并记录下来，得到一个新的长度为E的正整数序列B。如果两个边的序列得到的B相同则称它们本质相同。

请问有多少种本质不同的边的序列，你只要求出答案对$10^9+7$取模后的结果。

## 说明/提示

Subtask 1 (5pts)：N≤5。

Subtask 2 (10pts)：N≤10。

Subtask 3 (15pts)：N≤20。

Subtask 4 (15pts)：N≤30。

Subtask 5 (15pts)：N≤50。

Subtask 6 (20pts)：N≤100。

Subtask 7 (20pts)：无特殊限制

对于全部数据：1≤N≤400。

前6个子任务限时1s，第7个3.5s。

## 代码长度限制：10kb 超过这个限制赛后将会被标记为无效。

## 样例 #1

### 输入

```
3
```

### 输出

```
1 2 4 7 7 7
```

# 题解

## 作者：Created_equal1 (赞：29)

这是一道原题的加强版

考虑这么一个事情：给定一个序列，判断是否能得到

那么就是一开始先不断加边形成一条链，每次强连通分量数量如果变化，就缩链上开头的一部分（这一部分一定要弱联通）

当弱联通之后（就是所有点都被串到链上之后）就可以“为所欲为”了，只要边的数量不超过当前强连通分量数下能达到的边数最大值即可，边数最大值就是把链上开头一段缩起来得到的

这是一个贪心的过程

可以发现明显分成了两个过程

对于两个过程分别dp

第一个过程的dp，设F[n][cnt][x]表示当前链上的前n个点是联通的，强连通分量变化了cnt次，链上的前x个点被缩了起来。这时候边的数量是n−1+cnt条

第二个过程的dp，设G[m][x]表示当前的边数为m，链上的前x个点被缩了起来的方案数。需要满足m≤C(N,2)+C(x,2)

这两个dp显然都可以直接前缀和优化做到O(1)转移

状态都是O(N^3)的，所以时间复杂度也是O(N^3)的



---

## 作者：xyz32768 (赞：17)

- 这是一道优秀的 DP 题 ~~，比起 T3 这个大模拟这题不知道优秀到哪里去了~~

- 我们尝试去思考这个序列 $B$ 合法（存在）当且仅当什么

- 我们不妨确定一种产生序列 $B$ 的方式

- 显然 $B$ 单调不增

- 可以想到，如果我们造出了一条把点 $1$ 到 $n$ 顺次串起来的链

- 那么在任何时候，我们都可以通过加一条边把强连通分量的个数**变小**成任意值

- 那么就前 $i$ 条边来说，如果 $B$ 的前 $i$ 个数组成了 $k$ 个段（每段由相同的数构成），那么前 $i$ 条边中必然有 $k-1$ 条边使得加入此边后强连通分量的个数变小，于是用来构造这条链的边最多有 $i-k+1$ 条

- 设 $j=B_i$ 。易得，要构造 $j$ 个强连通分量，至少要用到这条链上的 $n-j$ 条边。这时候我们就得出，这时候需要满足

- $$i-k+1\ge n-j$$

- 然后我们又发现，由于这是简单图，所以当强连通分量个数为 $j$ 时，边数是有上限的。可以发现，强连通分量个数为 $j$ 的简单图的边数的最大值为

- $$(n-j+1)\times(n-1)+\frac{(j-1)\times(j-2)}2$$

- （上式即一个大小为 $n-j+1$ 的连通块和 $j-1$ 个大小为 $1$ 的连通块）

- 于是就前 $i$ 条边来说，还是设 $j=B_i$ ，又有一个限制：

- $$i\le(n-j+1)\times(n-1)+\frac{(j-1)\times(j-2)}2$$

- 整理一下，总限制条件为：

- （1） $B_1=n$

- （2） $B$ 单调不增

- （3）对于每个 $1\le i\le|B|$ ，设 $k$ 为 $B$ 的前 $i$ 个数构成的段数， $j=B_i$ ，有

- $$i-k+1\ge n-j$$

- （4）对于每个 $1\le i\le|B|$ ，设 $j=B_i$ ，则有

- $$i\le(n-j+1)\times(n-1)+\frac{(j-1)\times(j-2)}2$$

- 然后我们就有一个 DP 模型辣！

- $f[i][j][k]$ 表示就 $B$ 的前 $i$ 个数，满足 $B_i=j$ ，分成 $k$ 段的方案数

- 边界显然 $f[1][n][1]=1$

- 转移：（注意下面的转移是针对合法的状态 $f[i][j][k]$ ，如果状态 $f[i][j][k]$ 不合法一律为 $0$ ）

- 转移一： $B_{i-1}=B_i$

- $$f[i][j][k]+=f[i-1][j][k]$$

- 转移二： $B_{i-1}>B_i$

- $$f[i][j][k]+=f[i-1][h][k-1](h>j)$$

- 注意到 $f[i]$ 仅从 $f[i-1]$ 转移，且第二种转移中参与转移的 $h$ 均大于 $j$ 。于是滚动数组 + 前缀和，时间 $O(n^4)$ 空间 $O(n^2)$

- 为了优化时间复杂度，我们挖掘这个 DP 的性质，发现这个 $k$ 特别烦

- 把状态合法的条件（3） $i-k+1\ge n-j$ 移下项，即 $i+j\ge n+k-1$ ，然后你惊奇地发现：如果 $i>2n$ ，那么 $k$ 不管是多少状态 $f[i][j][k]$ 都满足合法条件（3）

- 然后我们把上述 DP 只进行到 $i=2n$ 为止，然后把整个 DP 过程搬到一个新的数组 $g[i][j]$ 表示前 $i$ 个数满足 $B_i=j$ 的方案数，状态合法条件只有（4）

- 具体地，当我们 DP 到 $f[2n]$ 时，令 $g$ 的边界

- $$g[2n][j]=\sum_{k=1}^nf[2n][j][k]$$

- 然后 $i$ 从 $2n+1$ 到 $n\times(n-1)$ ，继续闷声 DP

- $$g[i][j]=\sum_{k\ge j}g[i-1][k]$$

- 还是滚动数组 + 前缀和

- 最后答案：如果 $i\le 2n$ ，则 $|B|=i$ 的答案为 $\sum_{j=1}^n\sum_{k=1}^nf[i][j][k]$ ，否则为 $\sum_{j=1}^ng[i][j]$

- 时间复杂度 $O(n^3)$ 空间复杂度 $O(n^2)$

- 参考代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

template <class T>
inline T Min(const T &a, const T &b) {return a < b ? a : b;}

const int N = 405, M = N * N, ZZQ = 1e9 + 7;

int n, p_limit[N], f[2][N][N], sf[2][N][N], g[2][N], sg[2][N], ans[N * N];

int main()
{
	std::cin >> n;
	for (int i = 1; i <= n; i++)
		p_limit[i] = (n - i + 1) * (n - 1) + (i - 1) * (i - 2) / 2;
	f[1][n][1] = ans[1] = 1;
	for (int i = 1; i <= n; i++) sf[1][i][1] = 1;
	for (int i = 2; i <= Min(n * (n - 1), n << 1); i++)
	{
		int op = i & 1;
		for (int j = 1; j <= n; j++)
			for (int k = 1; k <= n; k++)
				f[op][j][k] = 0;
		for (int j = 1; j <= n; j++) if (i <= p_limit[j])
			for (int k = 1; k <= n; k++) if (i + j >= n + k - 1)
				f[op][j][k] = (f[op ^ 1][j][k] + sf[op ^ 1][j + 1][k - 1]) % ZZQ;
		for (int j = n; j >= 1; j--)
			for (int k = 1; k <= n; k++)
			{
				sf[op][j][k] = (sf[op][j + 1][k] + f[op][j][k]) % ZZQ;
				ans[i] = (ans[i] + f[op][j][k]) % ZZQ;
			}
	}
	for (int j = 1; j <= n; j++) for (int k = 1; k <= n; k++)
		g[0][j] = (g[0][j] + f[0][j][k]) % ZZQ;
	for (int j = n; j >= 1; j--) sg[0][j] = (sg[0][j + 1] + g[0][j]) % ZZQ;
	for (int i = (n << 1) + 1; i <= n * (n - 1); i++)
	{
		int op = i & 1;
		for (int j = 1; j <= n; j++) g[op][j] = 0;
		for (int j = 1; j <= n; j++) if (i <= p_limit[j])
			g[op][j] = sg[op ^ 1][j];
		for (int j = n; j >= 1; j--)
		{
			sg[op][j] = (sg[op][j + 1] + g[op][j]) % ZZQ;
			ans[i] = (ans[i] + g[op][j]) % ZZQ;
		}
	}
	for (int i = 1; i <= n * (n - 1); i++) printf("%d ", ans[i]);
	puts("");
	return 0;
}
```

---

## 作者：Kloze (赞：11)

对着这道题自闭了好久，突然发现只需要关心一条链的情况。。。    
具体做法就是考虑去关注一条链上加入回边的缩点以及去延长这条链，这样每次有三种决策：
- 在链末加入一个点（如果还有剩下的点的话）
- 合并链上的一些点
- 在已经合并的点中加入一些废边（如果还有废边的话）

但是这样做难免会出现一些顾虑，比如说“出现两条链”“在一条链上分多段合并（连接一些不想交的区间即可）”   
其实这些情况可以不去考虑，如果出现了两条链，那么一条链显然比这两条链的点数用的少，在序列方案数上扩展的空间更大，第二个问题同理。    
也就是对于一个合法的$B$序列，我们的策略就是加入一些废边或者在链末加入一个点，一旦$B$减少了，那么就链一条$i$到$1$的回边即可。    
那么我们用$f_{i,j,k}$表示加入了$i$条边，$j$个点已经和$1$缩起来了，现在在有向链上不包括$1$所在的强连通分量的有$k$个点。   
那么转移方程很显然有：
- $f_{i,j,k} \to f_{i+1,j,k} $ （如果还有废边）
- $f_{i,j,k} \to f_{i+1,j,k+1}$ （如果还有点没有连）
- $f_{i,j,k} \to f_{i+1,j+t,k-t}$

然后喜提了两发WA，不难发现废边和连点是不能同时可行的，它们得出来的序列可能是一样的。这个只需要还有点没有连的时候加有向链，连满了加废边即可。

这样就可以获得$80$分的好成绩了。   
$100$分来讲一种卡常做法。。（虽然我卡常太垃圾，加了$O2$才过）   
其实可以发现，总共合法状态数只有约$5\times 10^7$左右，那么对于前两种转移，我们可以直接把它的$j,k$放到栈里去，对于第三种，直接打一个在$0,j+k$的标记，然后再对这些列暴力做一遍向左下的传递，然后把这些$j,k$也加入栈中。    
然后我们需要去重，其实可以发现，这个数组前一半是有序的，后一半也是有序的，直接做一次归并即可。    
代码写的非常丑，尤其是判断“还有废边”改了好几次，所以式子比较长。

```cpp
// luogu-judger-enable-o2
#include<iostream>
#include<cstring>
#include<cstdio>
#include<vector>
#include<algorithm>

using namespace std;
#define LL long long
#define rint register int

inline int read(){
    int x=0,f=1;char c=getchar();
    for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
    for(;isdigit(c);c=getchar()) x=x*10+c-'0';
    return x*f;
}
int N;

const int MAXN = 100000;
const int INF = 2147483600;
const LL Mod = 1000000007;

int f[2][410][410];
int Ad[410][410];
int nod=0,ret=0; int top[2];
pair<int,int> sta[2][MAXN];
int stk[MAXN+1],now;
bool Fg[MAXN+1]; int all=0;

int main(){
    N=read(); f[0][0][0]=1; int x=0,y=1;
    sta[0][++top[0]]=make_pair(0,0); int mx=0;
    for(rint i=0;i<N*(N-1);i++){
        x^=1,y^=1;
        nod+=top[y];
        for(rint p=1;p<=top[y];p++){
        	rint j=sta[y][p].first,k=sta[y][p].second; ++all;
        	if(!f[y][j][k]) continue;
            if(k+j<N-1) (f[x][j][k+1]+=f[y][j][k])%=Mod,sta[x][++top[x]]=make_pair(j,k+1);
            else if(j*(j+1)-(i-k)+(j+1)*k-(k!=0)+(k*(k-1)/2)-(k>1?k-1:0)>0) 
                (f[x][j][k]+=f[y][j][k])%=Mod,sta[x][++top[x]]=make_pair(j,k);
            if(k>0) (Ad[j+1][k-1]+=f[y][j][k])%=Mod,Fg[k+j]=true; f[y][j][k]=0;
        } LL ans=0; top[y]=0;
        for(rint p=0;p<N;p++) if(Fg[p]){
            stk[++now]=p; 
            Fg[p]=false;
        }
        ret+=now; int bef=top[x];
        for(rint j=0;j<N;j++){
        	for(rint p=1;p<=now;p++){
        		rint k=stk[p]; ++all; if(k<0) continue; 
                (f[x][j][k]+=Ad[j][k])%=Mod;
                if(f[x][j][k]) sta[x][++top[x]]=make_pair(j,k);
        		if(k>0) (Ad[j+1][k-1]+=Ad[j][k])%=Mod;
        		stk[p]--; Ad[j][k]=0;
            }
        } 
        mx=max(mx,top[x]);
        merge(sta[x]+1,sta[x]+bef+1,sta[x]+bef+1,sta[x]+top[x]+1,sta[x]+1); now=0;
        top[x]=unique(sta[x]+1,sta[x]+top[x]+1)-sta[x]-1;
        for(int p=1;p<=top[x];p++)
            (ans+=f[x][sta[x][p].first][sta[x][p].second])%=Mod,++all;
        cout<<ans<<" ";
    }
    return 0;
}
```


---

## 作者：Semsue (赞：1)

这是 [Petrozavodsk Summer 2017. Day 2. U of Bucharest Contest I Salaj](https://qoj.ac/contest/1025) 的加强版。

首先考虑给定序列 $a_1,a_2\dots a_{m}$ 如何判定合法。显然有 $a_1=n$ 且 $a$ 单调不升，称 $a_i<a_{i-1}$ 的边 $i$ 为有用边，剩下的是无用边。

对于若干无用边，最优的连接方案应该是连成一条链。比如 $1\to 2\to 3$ 这样连接，可用的空闲无用边和 $1\to 2,1\to 3$ 相同，并且可以扩展（即增加 $2\to 1$ 或者 $3\to 1$ 以减少 SCC 数目）的方法更多。于是对于无用边数目不超过 $n$ 时的连接方法一定是 $\{1\to 2\to\dots\to k\},\{k+1\},\{k+2\},\dots \{n\}$。

现在我们考虑增加一条关键边。对于一个大小为 $k$ 的 SCC，其可贡献的连边数是 $k\times (k-1)$。那么假设当前拥有 $j$ 个 SCC，一定是 $j-1$ 个大小为 $1$ 的 SCC 和一个大小为 $n-j+1$ 的 SCC 最优。这个 SCC 理应包含链的起点（或称 $1$ 号点）。

另外这个边数显然是有上限的，理应是 $\frac{n(n-1)}{2}+\frac{(n-j)(n-j+1)}{2}$。

考虑用状态刻画我们刚刚的贪心，发现可以归纳为 $f_{i,j,k}$ 代表 $i$ 条边，链长为 $j$，$1$ 所在 SCC 大小为 $k$。有三种转移。

第一种，直接添加无用边 $f_{i,j,k}\to f_{i+1,j+1,k},j\ne n$。

第二种，链已经满了，随意添加一条无用边 $f_{i,n,k}\to f_{i+1,n,k}$。

第三种，添加一条有用边 $f_{i,j,k}\to f_{i+1,j,l},l>k$。使用前缀和优化可以做到 $O(1)$ 转移。

滚动数组后空间是 $O(n^2)$ 的，但是目前状态数是 $O(mn^2)$ 的。考虑优化。

其实很多状态都是无用状态。显然在 $i>2n-2$ 的时候，链长显然会变成 $n$。也就是说对于 $j<n$，只用跑到 $i\le 2n-2$。这样状态数就变成 $O(n^3)+O(nm)$ 的了。可以通过该题。

[code](https://qoj.ac/submission/98908)

-------

2023/5/13 修改了部分表述。

---

## 作者：daniEl_lElE (赞：0)

考虑目前有 $k$ 个强连通分量的情况。显然只有 $n-k$ 个点相连并且这 $n-k$ 个点最多可以消耗 $(n-k)(n-k-1)$ 条边的情况可以容纳最多的边。

然而，对于减少强连通分量的情况，减少 $x$ 个需要额外的 $x+1$ 条边。于是考虑状态还需要加入一个 $j$ 表示在一个大的 $n-k$ 个点的强连通分量外，还有一条长度为 $j-(n-k)$ 的链。

考虑 $dp_{i,j,k}$ 表示加了 $i$ 条边，有一条长度为 $j-(n-k)$ 的链（也就是说目前有边的点为 $j$），有 $k$ 个强连通分量的方案数。

考虑转移：

* $dp_{i,j,k}\to dp_{i+1,j+1,k}$；
* $k'<k$ 时，$dp_{i,j,k}\to dp_{i+1,j,k'}$；
* $j=n$ 且目前可容纳边数不小于 $i$ 时，$dp_{i,j,k}\to dp_{i+1,j,k}$。

初始状态 $dp_{0,1,n}=1$。

直接做是 $O(n^4)$ 的。

考虑优化，注意到每次要么让 $k$ 减少，要么让 $j$ 增加，要么 $j$ 是 $n$。$k$ 至多减少 $n$ 次，而 $j$ 至多增加 $n$ 次。也就是说，在加入 $2n$ 条边后，$j\neq n$ 的 $dp_{i,j,k}$ 一定是 $0$。故对于 $i\leq 2n$ 做单次 $O(n^2)$ 的转移，$i>2n$ 做单次 $O(n)$ 的转移即可。总复杂度 $O(n^3)$。

```cpp
#include <bits/stdc++.h>
#define int long long
#define double long double
#define mid ((l+r)>>1)
#define add(i,j) ((i+j>=mod)?i+j-mod:i+j)
using namespace std;
const int mod=1e9+7;
int dp[2][405][405];
int f[2][405];
signed main(){
	int n; cin>>n;
	if(n==1){
	    return 0;
	}
	if(n==2){
	    cout<<"1 1";
	    return 0;
	}
	dp[0][1][n]=1;
	for(int i=1;i<=2*n;i++){
		memset(dp[i&1],0,sizeof(dp[i&1]));
		for(int j=1;j<=n;j++){
			for(int k=1;k<=n;k++){
				dp[i&1][j+1][k]=dp[(i&1)^1][j][k];
			}
		}
		for(int j=1;j<=n;j++){
			int suf=0;
			for(int k=n;k>=n-j+1;k--){
				dp[i&1][j][k]=add(dp[i&1][j][k],suf);
				if(j==n&&(n-k+1)*(n-k)+(j-(n-k+1))*(j-(n-k+1)-1)/2+(j-(n-k+1))*(n-k+1)>=i) dp[i&1][j][k]=add(dp[i&1][j][k],dp[(i&1)^1][j][k]);
				suf=add(suf,dp[(i&1)^1][j][k]);
			}
		}
		int tot=0;
		for(int j=1;j<=n;j++) for(int k=1;k<=n;k++) tot=add(tot,dp[i&1][j][k]);
		cout<<tot<<" ";
	}
	for(int k=1;k<=n;k++) f[0][k]=dp[0][n][k];
	for(int i=2*n+1;i<=n*(n-1);i++){
		memset(f[i&1],0,sizeof(f[i&1]));
		int suf=0;
		for(int k=n;k>=1;k--){
			f[i&1][k]=add(f[i&1][k],suf);
			if((n-k+1)*(n-k)+(n-(n-k+1))*(n-(n-k+1)-1)/2+(n-(n-k+1))*(n-k+1)>=i) f[i&1][k]=add(f[i&1][k],f[(i&1)^1][k]);
			suf=add(suf,f[(i&1)^1][k]);
		}
		int tot=0;
		for(int k=1;k<=n;k++) tot=add(tot,f[i&1][k]);
		cout<<tot<<" ";
	}
	return 0;
}
```

---


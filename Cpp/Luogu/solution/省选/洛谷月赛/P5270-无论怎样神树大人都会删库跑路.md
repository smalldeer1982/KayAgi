# 无论怎样神树大人都会删库跑路

## 题目背景

众所周知，神 J（Joker）每隔几天就会去成都法中假装上课，实际上是去玩指针。神J可以趁别人不注意掏出指针把自己指到任何位置（生物标本柜里大变活人？），或者把两个人的指针交换一下（成都法中版《你的名字》？），或者对着 OJ 念系统命令使得 OJ 随机变慢（mcfx：怎么这 CPU 睿频后反而变慢了）。

神树大人很不满意，因为树必须站在原地，而且神树大人也不会指针。但是神树大人是神，于是他打算把这个宇宙的数据库删了跑路，这样无所事事的神 J 就只能和神树大人玩牌了。

## 题目描述

现在有个长为 $T$ 的字符串 $S$ 和 $n$ 个小字符串 $a_i$。

给定一个长为 $m$ 的数组 $R$，数组下标从 1 开始，初始有一个空字符串 $X$，神树大人打算进行 $Q$ 次操作，第 $i$ 次操作会把小字符串 $a_{R_{(i-1)\bmod m+1}}$ 丢到这个 $X$ 的末尾。

每次操作后，神树大人会检查这个字符串 $X$ 是否存在一个后缀使得任意排列后可以变成 $S$。

问有多少次这个字符串 $X$ 存在一个后缀使得**任意排列**后可以变成 $S$（即所有字符出现次数相同）。


可惜的是，这个字符串字符大小高达 $10^5$，所以你必须读入一个整数数组

## 说明/提示

### 样例 1 解释

![](https://cdn.luogu.com.cn/upload/pic/54698.png)


### 数据范围

对于所有数据，$n,T,m\leq 10^5,1\leq R_i\leq n,Q\leq 10^9$，所有小字符串的总长不超过 $10^5$，所有字符 $\in[0,10^5]$。

![](https://cdn.luogu.com.cn/upload/pic/54734.png)

## 样例 #1

### 输入

```
5 5 20
2 2 0 2 0
2 2 0
2 0 2
3 0 2 0
3 0 2 0
2 2 2
10
2 1 5 5 2 2 4 2 5 3```

### 输出

```
6```

## 样例 #2

### 输入

```
10 10 10000
0 1 1 1 0 1 1 0 0 0 
6 0 0 1 1 1 0 
6 0 0 0 0 0 0 
5 0 0 0 0 0 
4 1 0 0 0 
5 1 1 1 0 1 
2 1 1 
6 0 0 0 0 0 1 
1 0 
4 0 0 1 1 
1 1 
30
10 4 3 9 10 9 4 8 5 10 9 8 6 10 10 4 9 2 2 9 6 4 1 10 10 1 9 10 3 5 ```

### 输出

```
3001```

# 题解

## 作者：liaojiqing2012 (赞：24)

#### 对于 $q$ 比较小的情况
想一想，如果只有 $0,1$ 的情况，是不是只要判断后缀长度 $t$ 的字符串中有多少个 $1$ 就可以了。
如果数可以是 $0,1$ 以外的数呢，是不是就行不通了，没关系，我们仍然可以讨论他们的总和。但是我们得稍微变一下，不能直接加起来。
利用 hash 的思想，我们把一个数化成六个参数，分别是

+ $x$
+ $x\times 23$
+ $x^3$
+ $f(x)$
+ $x^2$
+ $\sqrt{x}$

$f(x)$ 是一个随机生成的映射函数。

然后也和 $0,1$ 的情况一样判断。把所有参数加起来就可以。

#### 对于 $q$ 比较大的情况
考虑到 $q$ 比较大时候，是一个循环队列。所以答案可以看成：

起始部分的答案**加上**重复部分的答案**乘以**重复次数**再加上**结束部分的答案。

所以，选一个大概合理的重复部分，就可以计算了。

顺带一提，其他题解的标程全是错的。

hack 数据：
```
9 50 20
1 2 1 2 1 2 1 1 2 2 1 1 2 1 2 1 1 2 1 1 2 2 1 2 2 1 2 2 2 1 2 1 1 1 1 2 1 2 2 1 1 2 2 1 2 2 2 1 2 1  
2 1 2 
1 2 
5 2 1 1 1 1 
3 1 1 2 
3 1 2 2 
4 1 2 2 2 
3 1 1 1 
4 2 2 1 1 
3 2 2 2 
9
7 5 3 1 8 2 6 4 9
```
正确答案输出 $2$，他们输出 $1$。
```
1 3 10
1 1 1
1 1
1
1
```
正确答案输出 $8$，他们输出 $0$。
#### 标程
```
#include<bits/stdc++.h>
#define random(l,r) ((rand()*32768+rand())%(r-l+1)+l) 
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef double db;
const int inf=0x7fffffff;
const int maxn=210000;
int fval[maxn];
struct ss{
	unsigned  a,b,c,d,e,f;
	ss(){a=b=c=d=e=f=0;}
	ss(int a,int b,int c,int d,int e,int f):a(a),b(b),c(c),d(d),e(e),f(f){}
	ss(int x){
		a=x;
		b=x*23;
		c=x*x*x;
		d=fval[x];
		e=x*x;
		f=sqrt(x);
	}
	ss operator -=(ss t1){
		a-=t1.a;
		b-=t1.b;
		c-=t1.c;
		d-=t1.d;
		e-=t1.e;
		f-=t1.f;
		return *this;
	} 
	ss operator +=(ss t1){
		a+=t1.a;
		b+=t1.b;
		c+=t1.c;
		d+=t1.d;
		e+=t1.e;
		f+=t1.f;
		return *this;
	} 
	bool operator ==(ss t1){
		return a==t1.a&&b==t1.b&&c==t1.c&&d==t1.d&&e==t1.e&&f==t1.f;
	} 
};
ss operator + (ss t1,ss t2){
	return  ss(t1.a+t2.a,t1.b+t2.b,t1.c+t2.c,t1.d+t2.d,t1.e+t2.e,t1.f+t2.f);
}
int gcd(int a,int b){
	return !b?a:gcd(b,a%b);
}
vector<int>aa[maxn];
vector<ss>tot[maxn];
int n,t,q,m,r[maxn];
void solve() {
	srand(time(0));
	for(int i=0;i<=1e5;i++)
		fval[i]=random(1,(int)1e9);
	cin>>n>>t>>q;
	ss key;
	for(int a,i=1;i<=t;i++){
		cin>>a;
		key+=ss(a);
	}
	for(int z,i=1;i<=n;i++){
	//	cout<<" input "<<i<<endl;
		cin>>z;
		aa[i].push_back(z);
		for(int kk,j=z;j>=1;j--){
			cin>>kk;
			aa[i].push_back(kk);
		}
		ss key;
		tot[i].push_back(key);
		for(int j=z;j>=1;j--){
			tot[i].push_back(key+=ss(aa[i][j]));
		}
	}
	//cout<<"check123"<<endl;
	cin>>m;
	for(int i=1;i<=m;i++){
		cin>>r[i];
	}
	ss tt;
	int be=0,len=0,len0=0,ans=0;
	tot[0].push_back(tt);
	aa[0].push_back(0);
//	cout<<"qwe"<<endl;
	if(q<=maxn*8){
		for(int i=1;i<=q;i++){
			int x=r[(i-1)%m+1]; 
	//		cout<<"x = "<<x<<endl;
			len+=aa[x][0];
		//	cout<<"len = "<<len<<endl;
			tt+=tot[x][aa[x][0]];
		//	cout<<"check 0"<<endl;
			while(be<i&&len-len0>=t){
			//	cout<<be<<endl;
				len-=len0;
				tt-=tot[r[(be-1)%m+1]][len0];
				be++;
				len0=aa[r[(be-1)%m+1]][0];
			//	cout<<len0<<" "<<len<<endl;
			}
			//cout<<"check 1"<<endl; 
			if(len>t){
				tt-=tot[r[(be-1)%m+1]][len0];
				len0=len0-(len-t);
				tt+=tot[r[(be-1)%m+1]][len0];
				len=t;
			}
			if(len==t){
				if(tt==key)ans++;
			}
		//	cout<<i<<" "<<ans<<" "<<be<<" "<<len<<" "<<len0<<endl;
		} 
		cout<<ans<<endl;
	}else{
		int mm=m;
		while(mm*2<=maxn*2)mm*=2;
		int bb=(q-mm)%mm,kk=(q-mm)/mm;
	//	cout<<kk<<" "<<bb<<" "<<mm<<endl;
	//	cout<<mm<<endl;
		for(int i=1;i<=mm;i++){
			int x=r[(i-1)%m+1]; 
	//		cout<<"x = "<<x<<endl;
			len+=aa[x][0];
		//	cout<<"len = "<<len<<endl;
			tt+=tot[x][aa[x][0]];
		//	cout<<"check 0"<<endl;
			while(be<i&&len-len0>=t){
			//	cout<<be<<endl;
				len-=len0;
				tt-=tot[r[(be-1)%m+1]][len0];
				be++;
				len0=aa[r[(be-1)%m+1]][0];
			//	cout<<len0<<" "<<len<<endl;
			}
			//cout<<"check 1"<<endl; 
			if(len>t){
				tt-=tot[r[(be-1)%m+1]][len0];
				len0=len0-(len-t);
				tt+=tot[r[(be-1)%m+1]][len0];
				len=t;
			}
			if(len==t){
				if(tt==key)ans++;
			}
		//	cout<<i<<" "<<ans<<" "<<be<<" "<<len<<" "<<len0<<endl;
		} 
		int ans2=0;
		for(int i=mm+1;i<=mm+mm;i++){
			int x=r[(i-1)%m+1]; 
	//		cout<<"x = "<<x<<endl;
			len+=aa[x][0];
		//	cout<<"len = "<<len<<endl;
			tt+=tot[x][aa[x][0]];
		//	cout<<"check 0"<<endl;
			while(be<i&&len-len0>=t){
			//	cout<<be<<endl;
				len-=len0;
				tt-=tot[r[(be-1)%m+1]][len0];
				be++;
				len0=aa[r[(be-1)%m+1]][0];
			//	cout<<len0<<" "<<len<<endl;
			}
			//cout<<"check 1"<<endl; 
			if(len>t){
				tt-=tot[r[(be-1)%m+1]][len0];
				len0=len0-(len-t);
				tt+=tot[r[(be-1)%m+1]][len0];
				len=t;
			}
			if(len==t){
				if(tt==key)ans2++;
			}
		//	cout<<i<<" "<<ans<<" "<<be<<" "<<len<<" "<<len0<<endl;
		} 
		ans2*=kk;
		ans+=ans2;
	//	cout<<ans<<endl;
//		cout<<bb<<" "<<be<<" "<<len<<" "<<len0<<" "<<kk<<endl;
		for(int i=mm*2+1;i<=mm*2+bb;i++){
			int x=r[(i-1)%m+1]; 
	//		cout<<"x = "<<x<<endl;
			len+=aa[x][0];
		//	cout<<"len = "<<len<<endl;
			tt+=tot[x][aa[x][0]];
		//	cout<<"check 0"<<endl;
			while(be<i&&len-len0>=t){
			//	cout<<be<<endl;
				len-=len0;
				tt-=tot[r[(be-1)%m+1]][len0];
				be++;
				len0=aa[r[(be-1)%m+1]][0];
			//	cout<<len0<<" "<<len<<endl;
			}
			//cout<<"check 1"<<endl; 
			if(len>t){
				tt-=tot[r[(be-1)%m+1]][len0];
				len0=len0-(len-t);
				tt+=tot[r[(be-1)%m+1]][len0];
				len=t;
			}
			if(len==t){
				if(tt==key)ans++;
			}
		//	cout<<i<<" "<<ans<<" "<<be<<" "<<len<<" "<<len0<<endl;
		} 
		cout<<ans<<endl;
	}
}
int main() {
	int t=1;
	//cin>>t;
	while(t--) solve();
}

/*
10 10 9600
0 1 1 1 0 1 1 0 0 0 
6 0 0 1 1 1 0 
6 0 0 0 0 0 0 
5 0 0 0 0 0 
4 1 0 0 0 
5 1 1 1 0 1 
2 1 1 
6 0 0 0 0 0 1 
1 0 
4 0 0 1 1 
1 1 
30
10 4 3 9 10 9 4 8 5 10 9 8 6 10 10 4 9 2 2 9 6 4 1 10 10 1 9 10 3 5 
*/
```


---

## 作者：qwerty_pwp (赞：4)

## P5270 solution

#### 题目链接

[P5270 无论怎样神树大人都会删库跑路](https://www.luogu.com.cn/problem/P5270)

#### 做法

首先，通过数据范围可以发现，$Q$ 是 $10^9$ 级别的，所以我们就想到这道题的答案可能具有一定的周期性，所以，发现串的后缀是具有周期性的，所以我们考虑先做两个周期，剩下的直接用第二个周期的规律往后推（因为第一个周期和后面的周期可能不同，因为第一个周期之前没有东西，但第二个周期之前有）。

那么，接下来问题就转化成了如何算出两个周期。

首先注意到两个序列相同仅当它们的长度相同。于是对于一次询问，我们只要查询一个后缀是否与 $S$ 相同。

我们注意到，需要将一个后缀排序后变成 $S$，实际上就是要让这个后缀里所有数的出现次数都和 $S$ 相等。

这样的“相等“的规定，这样的检查是否相同，很难不想到是哈希。考虑如何设计哈希函数。发现它与数的顺序无关，只与每个数的大小有关。

所以，我们设计序列 $S$ 的哈希函数 $f(S)$ 为（开 $\tt ull$ 让它自然溢出）：
$$
f(S)=\sum\limits_{i=1}^{|S|}{(10^9+7)^{S_i}}
$$
若两个序列哈希值相等，则这两个序列在题目意义下是相同的。而且，这个哈希函数是有可加性的。

然后，因为在跑的过程中，不一定每段都会被完整的取到，所以，我们还要记录对于一个会被加入的序列，每个后缀的哈希函数值。这样子跑一个类似于双指针的东西，我们就可以 $O(m)$ 求出前两轮的答案。后面的就可以以此类推了（注意：后面的是以第二轮“类推”）。总复杂度是线性的，可以跑的飞快。

#### code

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int id[100005],roundans[100005];
vector <int> arr[100005],pre[100005];
unsigned long long g,f[100005],garr[100005];
//roundans:有规律的答案
//arr:序列是什么
//pre:哈希值前缀
//garr:小字符串哈希值
//f:每个数的哈希值
//g:序列 S 的哈希值
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(); cout.tie();
	f[0]=1;
	for(int i=1;i<=100000;++i)
		f[i]=f[i-1]*1000000007;
	int n,T,Q; cin >> n >> T >> Q;
	for(int i=1;i<=T;++i) {
		int x; cin >> x; g+=f[x];
	}
	for(int i=1;i<=n;++i) {//预处理
		int length; cin >> length;
		arr[i].push_back(0);
		for(int j=1;j<=length;++j) {
			int x; cin >> x;
			arr[i].push_back(x);
			garr[i]+=f[x];
		}
		unsigned long long u=0;
		pre[i].push_back(0);
		for(int j=1;j<=length;++j) {
			u+=f[arr[i][j]];
			pre[i].push_back(u);
		}
	}
	int m; cin >> m;
	for(int i=1;i<=m;++i) cin >> id[i];
	int length=0; int l=1; int tp=0; int tans=0;
	bool gull=false;
	for(int i=1;Q;--Q,++i) {//先做几遍
		int p=(i-1)%m+1;
		length+=arr[id[p]].size()-1;
		tp+=garr[id[p]];
		while(length-arr[id[l]].size()+1>=T) {
			length-=arr[id[l]].size()-1;
			tp-=garr[id[l]];
			++l;
			if(l>m) l=1;
		}
		if(length>=T) {
			if(gull) roundans[p]=roundans[p-1];
			if(tp-pre[id[l]][length-T]==g) {
				++tans;
				if(gull) ++roundans[p];
			}
		}
		if(gull==true && p==m) {
			Q--;
			break;
		}
		if(length>=T && p==m) gull=true;
	}
	tans+=(Q/m)*roundans[m];//然后用规律
	tans+=roundans[Q%m];
	cout << tans;
	return 0;
}
```

---

## 作者：FishPressedCoins (赞：2)

因为放不了图片，所以代码注释我会写的详细一些。

用桶排序也能做，但是代码会繁琐一些，而且时间卡的很极限，所以我还是选择了字符串哈希。

思路还是很简单的，就是模拟一段 $X$ 字符串的增加过程，找到规律后跳过后面的模拟过程（全过程模拟一遍正常会超时），然后直接得到答案。

这题的难点在于字符串的哈希处理和规律的查找，哈希处理因人而异，哈希函数五花八门我就不展开了，能用就行，剩下的都是代码功底。

规律的发现还是很有意思的，我们以 $X$ 字符串的 $R$ 次添加为一次循环会发现，除了第一次循环得到的答案不一样，其他的每次循环答案都一样，那我们只需要记录第一次循环的答案和第二次循环的答案，然后求出剩下的循环次数乘上第二次循环的答案加上第一次循环的答案不就是总答案了吗？

哈哈，是这样的，但是被hack了（悲）。为啥被hack了呢？原因出在“**我们以 $X$ 字符串的 $R$ 次添加为一次循环**”这个前提条件上，这一次循环就一定能出答案吗？未必。

这里感谢大佬慷慨的提供了hack数据（不然又要调试半天）。我们发现在 $R$ 值很小并且 $S$ 字符串长度很大的情况下，一次循环连长度都凑不齐还比较什么，就会导致误判答案为零，实际上当长度凑齐后是有答案的。

为了那宝贵的答案，我们只能忍痛先添加多次循环直到超过 $S$ 字符串长度，再按照上述流程走，就可以愉快的通过啦。
```cpp
#include<iostream>
#include<string>
#include<vector>
using namespace std;
//m数组存储所有小字符串的哈希值
long long N, T, Q, S = 0, a[10], m[100005], R, ans = 0, t[100005], ans1, ans2;
//P数组存储所有小字符串的每段的哈希值，方便切割成需要的长度
vector<long long>P[100005];
//V数组充当X字符串
vector<long long>V;
void go()
{
	//分别是 当前长度截取的哈希值、X字符串每段的下标、当前字符串的总长度
	long long sum = 0, i = V.size() - 1, Len = 0;
	while (true) {
		if (i < 0)break;//燃尽了，返回
		if (Len + P[V[i]].size() >= T)break;//满足长度要求了，返回
		Len += (P[V[i]].size());
		i--;
	}
	if (i < 0)return;//X字符串燃尽了，但是还不够多~
	if (Len + P[V[i]].size() < T)return;//如果长度不达标就返回
	if ((T - Len - 1) >= 0)sum += (P[V[i]][(T - Len - 1)]);//如果长度不是刚刚好，就需要切割一点字符串补上去，P数组就开始发力了
	for (i++; i < V.size(); i++) {
		sum += m[V[i]];//将前面点过名的字符串都取出哈希值
	}
	if (sum == S)ans++;//如果哈希值一样就说明，答案加一
}
int main()
{
	cin >> N >> T >> Q;
	a[0] = 1;
	for (long long i = 1; i < 10; i++) {
		a[i] = a[i - 1] * 911;//哈希函数初始化 911是素数，素数就行
	}

	for (long long i = 1,j; i <= T; i++) {
		cin >> j;
		if (j == 0)S += 1;//先将S字符串的哈希值算出来
		else while (j) {
			S += (a[j % 10]);
			j /= 10;
		}
	}
	for (long long i = 1,j; i <= N; i++) {
		cin >> j;
		for (long long k = 1; k <= j; k++) {
			cin >> t[k];//将小字符串正序录入数组
		}
		for (long long k = j; k >= 1; k--) {
			if (t[k] == 0)m[i] += 1;//倒序计算哈希值，为了方便切割
			else {
				while (t[k]) {
					m[i] += (a[t[k] % 10]);
					t[k] /= 10;
				}
			}
			P[i].push_back(m[i]);//将需要的字符串段落的哈希值录入
		}
	}
	cin >> R;

	for (long long i = 1,j; i <= R; i++)
	{
		cin >> t[i];
	}

	if (Q <= R * 2) {//如果两次循环就结束了，那么证明数据不是很大，可以直接处理
		for (long long i = 1; i <= Q; i++) {
			V.push_back(t[i%(R+1)]); go();//按顺序将小字符串扔到X字符串后面
		}
		cout << ans;
	}
	else {//两次处理不了就需要找规律，不然全遍历一遍很容易超时
		long long k = 0;
		while (ans == 0) {//初步处理，直到第一次答案出现为止
			for (long long i = 1; i <= R; i++) {
				V.push_back(t[i % (R + 1)]); go();
			}
			k++;//记录循环次数
			//当循环的次数实在过多，我们就认为没有任何一次循环有答案产生，再不退出就和全遍历没两样了
			if (k == 10000)break;//这个可以设置，目前k==3就可以AC这道题，正常不会超过S字符串的长度，S的最大长度为10^5
		}
		ans1 = ans;//记录第一次循环的答案
		ans = 0;
		for (long long i = 1; i <= R; i++) {
			V.push_back(t[i % (R + 1)]); go();
		}
		ans2 = ans;//记录第二次循环的答案
		long long sum = Q / R;//计算剩下的循环次数
		sum-=k;
		ans1 += (sum * ans2);//剩下的每一次循环我们都认为可以产生一次ans2的答案
		ans = 0;
		sum = Q % R;//看看有没有漏掉的次数，构不成循环的遍历
		for (long long i = 1; i <= sum; i++) {//计算剩下的答案
			V.push_back(t[i % (R + 1)]); go();
		}
		cout << ans1 + ans;
	}
	return 0;
}

```

---

## 作者：Daniel1234 (赞：2)

# 思路

来篇稍微好实现一点的题解。

一眼 $hash$，先考虑 $Q$ 比较小怎么做。

可以在遍历 ```for(int i = 1; i <= Q; i++)```  的时候同时维护一个指针，表示当前节点向前匹配 $T$ 长度能到哪个串，每次发现太长就把指针往右移。

我们可以这样处理出前 $\min (10^6, Q)$ 个答案。

若 $Q$ 比较大，考虑到我们是循环加入数，所以对于所有 $10^6<i \le Q$，一定有 $ans_i = ans_{i - m}$。

然后就做完了。

# 代码

```
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define mod (int)(1e9+7)
int n, T, Q, m;
int a[100005];
vector<int>s[100005], suf[100005];
int mp[100005];
int b[100005];
int ans[1000005];
int pre[1000005];
int len[100005];
int bel[1000005];
int rand(int l, int r){
    return 1ll * rand() * rand() % (r - l + 1) + l;
}
int ksm(int x, int y){
    int ans = 1;
    while(y){
        if(y&1)ans = ans * x % mod;
        x = x * x % mod;
        y >>= 1;
    }
    return ans;
}
int calc(int x){
    return ksm(mp[x], x);
}
signed main(){
    srand(time(0));
    for(int i = 0; i <= 100000; i++)mp[i] = rand(0, 1e9);
    cin >> n >> T >> Q;
    int bz = 0;
    for(int i = 1; i <= T; i++){
        scanf("%lld",  &a[i]);
        bz = bz + calc(a[i]);
        bz %= mod;
    }
    for(int i = 1; i <= n; i++){
        scanf("%lld", &len[i]);
        s[i].resize(len[i] + 1);
        suf[i].resize(len[i] + 1);
        for(int j = 1; j <= len[i]; j++){
            scanf("%lld", &s[i][j]);
        }
        suf[i][len[i]] = calc(s[i][len[i]]);
        for(int j = len[i] - 1; j >= 1; j--){
            suf[i][j] = (suf[i][j + 1] + calc(s[i][j])) % mod;
        }
    }
    cin >> m;
    for(int i = 1; i <= m; i++){
        scanf("%lld", &b[i]);
    }
    int l = 1;
    int nw = 0;
    for(int i = 1; i <= min(Q, 1000000ll); i++){
        int j = b[(i-1)%m+1];
        bel[i] = j;
        // cout << j << "!" << endl;
        pre[i] = pre[i - 1] + len[j];
        nw += suf[j][1];
        if(pre[i] < T)continue;
        while(pre[i] - pre[l] >= T)nw -= suf[bel[l]][1], l++, nw %= mod;
        nw += mod;
        nw %= mod;
        if(bz == (nw - suf[bel[l]][1] + suf[bel[l]][len[bel[l]] - (T - (pre[i] - pre[l])) + 1] + mod) % mod){
            ans[i] = 1;
        }
    }
    int last = 0;
    for(int i = 1; i <= min(Q, 1000000ll); i++){
        if(i + m > 1e6 && ans[i]){
            ans[i] = (Q - i) / m + 1;
        }
        last += ans[i];
    }
    cout << last << endl;
    return 0;
}
```

---

## 作者：潘德理2010 (赞：1)

这是一篇简明，易懂的题解。

本题使用哈希。

在此题中，我们认为以下结论成立，这将帮助我们做出此题：

对于两个长度为 $n$ 的字符串 $a,b$，如果对于所有满足 $1\le j\le k$ 的 $j$，都有 $\sum\limits_{i=1}^{n} a_i^j \mod p=\sum\limits_{i=1}^{n} b_i^j \mod p$，我们就认为 $a,b$ 的组成相同，即任意一个数在 $a$ 中的出现次数等于它在 $b$ 中的出现次数。此处 $k,p$ 为常数，我们取 $k=20,p=10^9+7$。很显然，这个结论错误的概率是很小的，几乎不可能出错（如果不放心可以在不超时的情况下增大 $k$），所以我们认为这个结论是对的。

那么我们再来看这道题。当我们向字符串 $X$ 中加入一个字符串后，我们可以维护 $X$ 的末尾 $t$ 位（$t$ 为题目中 $S$ 的长度）的 $1,2,3,...,k$ 次方和模 $p$ 的值。（这个很好维护，具体怎么维护就不讲了，不会的话可以看下面代码）。我们另外预处理出 $S$ 的末尾 $t$ 位（$t$ 为题目中 $S$ 的长度）的 $1,2,3,...,k$ 次方和模 $p$ 的值。我们判断这两个值是否相等。如果相等，那么这一次加入后，就可以满足条件。

我们注意到，加入字符串的次数 $Q$ 可以达到 $10^9$，所以不能一个一个加入。但是，我们发现，一旦将 $R$ 中的所有字符串加入一次后，字符串 $X$ 的长度大于等于 $S$ 的长度，那么以后每次加入 $m$ 个字符串（即加入一整个 $R$），对答案的贡献是一样的。我们只需要算出 $X$ 的长度从何时开始大于等于 $S$，以及从这时以后每次加入 $m$ 个字符串对答案带来多少贡献即可。

具体实现见代码。


```cpp
#include<bits/stdc++.h>
#define p 1000000007
using namespace std;
typedef long long ll;
ll qp(ll x,ll y){
	ll a=1,b=x;
	while(y){
		if(y%2==1) a=1ll*a*b%p;
		b=1ll*b*b%p;
		y/=2;
	}
	return a;
}
ll n,m,q,te,w[25],t;
ll r[100010];
ll l[100010],a[100010];
vector<ll> s[100010],sm[100010][25];
deque<pair<ll,ll> > qe;
ll sz,sum[25],ans,ans1;
void ret(ll x,ll op){
	qe.push_back({x,l[x]});
	sz+=l[x];
	for(ll k=1;k<=20;k++){
		sum[k]=(sum[k]+sm[x][k][l[x]])%p;
	}
	while(sz>m){
		ll u=qe.front().first,w=qe.front().second;
		qe.pop_front();
		if(sz-w>=m){
			for(ll k=1;k<=20;k++){
				sum[k]=(0ll+sum[k]-(sm[u][k][l[u]]-sm[u][k][l[u]-w])+p)%p;
			}
			sz-=w;
		}
		else{
			ll v=w-(sz-m);
			for(ll k=1;k<=20;k++){
				sum[k]=(0ll+sum[k]-(sm[u][k][l[u]-v]-sm[u][k][l[u]-w])+p)%p;
			}			
			w=v;
			qe.push_front({u,w});
			sz=m;
		}
	}
	if(sz==m){
		bool ok=1;
		for(ll k=1;k<=20;k++){
			if(w[k]!=sum[k]){
				ok=0;
				break;
			}
		}
		if(ok){
			if(op==1) ans++;
			else ans1++;
		}
	}
}
int main(){
	scanf("%lld%lld%lld",&n,&m,&q);
	for(ll i=1;i<=m;i++){
		scanf("%lld",&r[i]);
		for(ll k=1;k<=20;k++){
			w[k]=(w[k]+qp(r[i],k))%p;
		}
	}
	for(ll i=1;i<=n;i++){
		scanf("%lld",&l[i]);
		s[i].push_back(0);
		for(ll k=1;k<=20;k++){
			sm[i][k].push_back(0);
		}
		for(ll j=1;j<=l[i];j++){
			scanf("%lld",&te);
			s[i].push_back(te);
			for(ll k=1;k<=20;k++){
				sm[i][k].push_back((sm[i][k][j-1]+qp(s[i][j],k))%p);
			}
		}
	}
	scanf("%lld",&t);
	for(ll i=1;i<=t;i++){
		scanf("%lld",&r[i]);
	}
	ll u=q%t,v=q/t;
	while(1){
		v--;
		for(ll i=1;i<=t;i++){
			ret(r[i],1);
			if(i==q){
				printf("%lld",ans);
				return 0;
			}
		}
		if(sz>=m) break;
	}
	for(ll i=1;i<=t;i++){
		ret(r[i],0);
		if(i==u) ans+=ans1;
	}
	printf("%lld",ans+ans1*v); 
}
```

---

## 作者：lwwwb_555 (赞：1)

# 思路
我们可以先把每个数都附上一个哈希值，那么所给字符串的哈希值也就是确定的了，后面我们要判断该字符串是否出现直接 $O(1)$ 哈希比较就行了。

然后，对于这道题我们分为两种情况来讨论。

## 1.一个循环的所有字符串长度较小
这样的话，我们就先要暴力的循环，直到字符串的长度大于了 $T$，不难发现，后面所作出的贡献是一种循环，我们只需要把循环节找出来，并且把每个循环节的贡献也算出来就可以直接用乘法来运算了，然后再把后面多出来的那一段贡献单独算一下再加上就好了。

### code


```cpp
while(1){
	for(int i=1;i<=m;i++){
		res++;
		int p=r[(i-1)%m+1];
		for(int j=0;j<len[p];j++){
			sum++;
			x[sum]=(x[sum-1]+e[p][j]*num[e[p][j]])%mod;
		}
		if(sum>=t){
			if((x[sum]-x[sum-t]+mod)%mod==w) ans++;
		}
		if(res==q){
			printf("%lld",ans);
			return 0;
		}
	}
	if(sum>=t) break;
}//先暴力循环直到长度大于S
ans1=ans;
for(int i=1;i<=m;i++){
	res++;
	int p=r[(i-1)%m+1];
	for(int j=0;j<len[p];j++){
		sum++;
		x[sum]=(x[sum-1]+e[p][j]*num[e[p][j]])%mod;
	}
	if(sum>=t){
		if((x[sum]-x[sum-t]+mod)%mod==w) ans++;
	}
	if(res==q){
		printf("%lld",ans);
		return 0;
	}
}//找循环节并计算每个循环节的贡献
ans+=(ans-ans1)*(long long)(q/m-res/m);//直接用乘法算完在循环里的贡献
long long o=q/m;
q-=o*m;
if(!q){
	printf("%lld",ans);
	return 0;
}
res=0;
for(int i=1;i<=m;i++){
	res++;
	int p=r[(i-1)%m+1];
	for(int j=0;j<len[p];j++){
		sum++;
		x[sum]=(x[sum-1]+e[p][j]*num[e[p][j]])%mod;
	}
	if(sum>=t){
		if((x[sum]-x[sum-t]+mod)%mod==w) ans++;
	}
	if(res==q){
		printf("%lld",ans);
		return 0;
	}
}//把最后多的那段的贡献给加上去
```
## 2.一个循环的所有字符串长度较大
我们还是考虑去找循环节，但我们发现一个循环的字符较多，不可能一个一个的用数组去存，所以我们考虑一个字符串一个字符串的去处理。

那么我们要怎么去处理呢？

我们先预处理出每个字符串的前后缀哈希值和长度，然后一个一个的把字符串放进去，如果现在的长度已经大于 $T$ 了，我们就先找到最左边的字符串能使这个区间的字符串长度小于 $T$，然后再算出差多少个字符，我们设差 $x$ 个字符，再加上前一个字符串的后 $x$ 位的哈希后缀和，再与 $S$ 作比较就好了。

### code

```cpp
for(int i=1;i<=n;i++){
	ww[i].push_back(0);
	for(int j=0;j<len[i];j++) ww[i].push_back((ww[i][ww[i].size()-1]+e[i][j]*num[e[i][j]])%mod);
}//处理前缀哈希
for(int i=1;i<=n;i++){
	www[i].push_back(0);
	for(int j=len[i]-1;j>=0;j--) www[i].push_back((www[i][www[i].size()-1]+e[i][j]*num[e[i][j]])%mod);
}处理后缀哈希
int l=0;
for(int i=1;i<=m;i++){
	res++;
	int p=r[(i-1)%m+1];
	x[res]=(x[res-1]+ww[p][ww[p].size()-1])%mod;
	summ[res]=summ[res-1]+len[p];
	if(summ[res]>=t){
		while(l<res && summ[res]-summ[l+1]>=t) l++;
		int pp=r[l%m+1];
		if((x[res]-x[l+1]+mod+www[pp][t-(summ[res]-summ[l+1])])%mod==w) ans++;
	}
	if(res==q){
		printf("%lld",ans);
		return 0;
	}
}//把第一个循环的贡献单独算
ans1=ans;
for(int i=1;i<=m;i++){
	res++;
	int p=r[(i-1)%m+1];
	x[res]=(x[res-1]+ww[p][ww[p].size()-1])%mod;
	summ[res]=summ[res-1]+len[p];
	if(summ[res]>=t){
		while(l<res && summ[res]-summ[l+1]>=t) l++;
		int pp=r[l%m+1];
		if((x[res]-x[l+1]+mod+www[pp][t-(summ[res]-summ[l+1])])%mod==w) ans++;
	}
	if(res==q){
		printf("%lld",ans);
		return 0;
	}
}//算单个循环节的贡献
ans+=(ans-ans1)*(q/m-2);//用乘法算循环里的贡献
long long o=q/m;
q-=o*m;
int qq=res;
if(!q){
	printf("%lld",ans);
	return 0;
}
for(int i=1;i<=m;i++){
	res++;
	int p=r[(i-1)%m+1];
	x[res]=(x[res-1]+ww[p][ww[p].size()-1])%mod;
	summ[res]=summ[res-1]+len[p];
	if(summ[res]>=t){
		while(l<res && summ[res]-summ[l+1]>=t) l++;
		int pp=r[l%m+1];
		if((x[res]-x[l+1]+mod+www[pp][t-(summ[res]-summ[l+1])])%mod==w) ans++;
	}
	if(res-qq==q){
		printf("%lld",ans);
		return 0;
	}
}//加上最后在循环外的贡献
```
这道题的代码比较难调，建议大家静下心来慢慢调。

最后给大家一个总的代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long f[100005],w,num[100005],x[60000005],ans,summ[300005];
const long long mod=1e9+7;
long long len[100005],r[100005],n,t,m,q,s[100005];
vector<long long> e[100005];
vector<long long> ww[100005],www[100005];
int read(){
	int res=0,f=1;
	char c=getchar();
	while(!isdigit(c)){
		if(c=='-') f=-1;
		c=getchar();
	}
	while(isdigit(c)){
		res=(res<<3)+(res<<1)+c-'0';
		c=getchar();
	}
	return res*f;
}
int main(){
	n=read(),t=read(),q=read();
	srand(time(0));
	for(int i=0;i<=100000;i++) num[i]=1ll*rand()*rand()%mod;
	for(int i=1;i<=t;i++) s[i]=read(),w=(w+s[i]*num[s[i]])%mod;
	for(int i=1;i<=n;i++){
		len[i]=read();
		for(int j=1;j<=len[i];j++) e[i].push_back(read());
	}
	m=read();
	int pp=0;
	for(int i=1;i<=m;i++) r[i]=read(),pp+=len[r[i]];
	int sum=0,res=0;
	long long ans1=0;
	if(pp<=1e7){//第一种情况
		while(1){
			for(int i=1;i<=m;i++){
				res++;
				int p=r[(i-1)%m+1];
				for(int j=0;j<len[p];j++){
					sum++;
					x[sum]=(x[sum-1]+e[p][j]*num[e[p][j]])%mod;
				}
				if(sum>=t){
					if((x[sum]-x[sum-t]+mod)%mod==w) ans++;
				}
				if(res==q){
					printf("%lld",ans);
					return 0;
				}
			}
			if(sum>=t) break;
		}
		ans1=ans;
		for(int i=1;i<=m;i++){
			res++;
			int p=r[(i-1)%m+1];
			for(int j=0;j<len[p];j++){
				sum++;
				x[sum]=(x[sum-1]+e[p][j]*num[e[p][j]])%mod;
			}
			if(sum>=t){
				if((x[sum]-x[sum-t]+mod)%mod==w) ans++;
			}
			if(res==q){
				printf("%lld",ans);
				return 0;
			}
		}
		ans+=(ans-ans1)*(long long)(q/m-res/m);
		long long o=q/m;
		q-=o*m;
		if(!q){
			printf("%lld",ans);
			return 0;
		}
		res=0;
		for(int i=1;i<=m;i++){
			res++;
			int p=r[(i-1)%m+1];
			for(int j=0;j<len[p];j++){
				sum++;
				x[sum]=(x[sum-1]+e[p][j]*num[e[p][j]])%mod;
			}
			if(sum>=t){
				if((x[sum]-x[sum-t]+mod)%mod==w) ans++;
			}
			if(res==q){
				printf("%lld",ans);
				return 0;
			}
		}
	}else{//第二种情况
		for(int i=1;i<=n;i++){
			ww[i].push_back(0);
			for(int j=0;j<len[i];j++) ww[i].push_back((ww[i][ww[i].size()-1]+e[i][j]*num[e[i][j]])%mod);
		}
		for(int i=1;i<=n;i++){
			www[i].push_back(0);
			for(int j=len[i]-1;j>=0;j--) www[i].push_back((www[i][www[i].size()-1]+e[i][j]*num[e[i][j]])%mod);
		}
		int l=0;
		for(int i=1;i<=m;i++){
			res++;
			int p=r[(i-1)%m+1];
			x[res]=(x[res-1]+ww[p][ww[p].size()-1])%mod;
			summ[res]=summ[res-1]+len[p];
			if(summ[res]>=t){
				while(l<res && summ[res]-summ[l+1]>=t) l++;
				int pp=r[l%m+1];
				if((x[res]-x[l+1]+mod+www[pp][t-(summ[res]-summ[l+1])])%mod==w) ans++;
			}
			if(res==q){
				printf("%lld",ans);
				return 0;
			}
		}
		ans1=ans;
		for(int i=1;i<=m;i++){
			res++;
			int p=r[(i-1)%m+1];
			x[res]=(x[res-1]+ww[p][ww[p].size()-1])%mod;
			summ[res]=summ[res-1]+len[p];
			if(summ[res]>=t){
				while(l<res && summ[res]-summ[l+1]>=t) l++;
				int pp=r[l%m+1];
				if((x[res]-x[l+1]+mod+www[pp][t-(summ[res]-summ[l+1])])%mod==w) ans++;
			}
			if(res==q){
				printf("%lld",ans);
				return 0;
			}
		}
		ans+=(ans-ans1)*(q/m-2);
		long long o=q/m;
		q-=o*m;
		int qq=res;
		if(!q){
			printf("%lld",ans);
			return 0;
		}
		for(int i=1;i<=m;i++){
			res++;
			int p=r[(i-1)%m+1];
			x[res]=(x[res-1]+ww[p][ww[p].size()-1])%mod;
			summ[res]=summ[res-1]+len[p];
			if(summ[res]>=t){
				while(l<res && summ[res]-summ[l+1]>=t) l++;
				int pp=r[l%m+1];
				if((x[res]-x[l+1]+mod+www[pp][t-(summ[res]-summ[l+1])])%mod==w) ans++;
			}
			if(res-qq==q){
				printf("%lld",ans);
				return 0;
			}
		}
	}
	return 0;
}
```
~~码风较丑，轻点喷。~~

---


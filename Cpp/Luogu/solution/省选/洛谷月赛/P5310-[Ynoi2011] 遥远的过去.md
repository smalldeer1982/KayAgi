# [Ynoi2011] 遥远的过去

## 题目背景

小学六年级的时候学了JAVA，写了个小游戏，大概是把我奥数老师的头弹飞出去拿来打青蛙的，看来我小时候就懂膜蛤和P头了。

现在感觉当时很多东西没理解，都在乱写，程序里面全是if，就这样还是写出来了，还拿了个科创大赛一等奖（可以加5分中考分的，可不算很野鸡！）

所以一直感觉我其实是很喜欢做一些有创造性的东西的，这点之后也会体现出来。

上了初中，因为之前学过点小学奥数，同时也有学一些数学竞赛的东西，所以感觉老师讲课都很平凡，没什么兴趣。

第一次接触到了信息学竞赛，当时感觉还是挺有趣的，不过也没怎么认真学。

学校里面有OI的培训，但由于学校里面在教Pascal，我当时已经学过JAVA了，自然觉得这个语言很落后，垃圾，所以也没怎么听课，印象中我去参加个选拔考试，有个鸡兔同笼的题，我写了个解方程被扣分了，老师给的正解是 while( a-- ) b++ 这样的东西，然后就决定不去了。

初二考了一次NOIP普及组，当时只拿了120，第二题是个表达式求值，我写了很久很久都一直挂，然后就凉凉了。

考完之后得知班上几个同学考了全省前10，感觉他们好强，当时还是很有好胜心的，于是决定好好学OI，初三打爆他们。

初三的时候考了295，被两个当时初二的小朋友打爆了，不过我是初三里面最高分（

那两个小朋友好像现在都去茶园了，果然是神仙。

感觉初中还是挺好玩的，虽然天天和毒瘤老师斗智斗勇，但还是很有趣。

【记得配图，内容：写的小游戏的截图，还有noip的成绩】

由于这是Ynoi，不是出题人拿来写奇怪的文字的地方，所以你需要做一个数据结构题：

## 题目描述

小 F 决定设计出一种字符集超大的语言——Z 语言，哪怕有时额外的字符并没有什么用。

这种语言的特点是：

* 字符集非常大，甚至可能有 $2147483648(2 ^ {31})$ 种字符；

* 每个单词由一系列**两两不同**的字符组成；

* 字符既能比较相同和不同，也能比较大小，因此之后我们用数字来表示 Z 语言中稀奇古怪的字符；

* 两个看起来完全不同的单词也可能是同一个单词，因为：只要两个单词中第 K 大的字符所在的位置相同，那么其实就是本质上相同的单词。例如 $\{1, 2, 3, 4, 5\}$ 与 $\{2, 3, 23, 233, 23333\}$ 是相同的。（所以你可以用 Z 语言很方便地加密信息！）

现在，小 F 打算将 Z 语言应用到实际中。比如，他点开了一道电脑里的算法题：

> 给定两个字符串 $A, B$ ，求 $B$ 作为子串在 $A$ 中被匹配的次数。

 小 F 当然知道这是一个可以用 KMP 解决的基础题。但是，他在用 Z 语言的匹配实现 Z-KMP 的时候遇到了问题，你能帮帮他吗？

为了验证你是不是真的明白小 F 在说什么，小 F 会修改 $B$ 串很多次来问你。可不准偷懒哦！

你的程序需要支持的操作详见输入输出格式。

## 说明/提示

Idea：nzhtl1477，Solution：nzhtl1477，Code：nzhtl1477，Data：nzhtl1477( partially uploaded )

### 样例 1 解释

在第一次修改后，$\{3, 5, 1\}$ 并不能被任何一个 $A$ 中的子串匹配上。

在第二次修改后，$\{6, 5, 1\}$ 能被 $A$ 中所有长度为 $3$ 的串匹配上，原因是 A 是单调减的，而 B 也是单调减的，因此 $A$ 中所有长度为 $3$ 的串与 $B$ 排名相同的处于相同位置。

### 子任务

子任务 $1(31 \mathrm{pts}) : n, m \leq 100, q \leq 1000$；

子任务 $2(41 \mathrm{pts}) : n, m \leq 1000, q \leq 5 \times 10 ^ 4$；

子任务 $3(78 \mathrm{pts}) : n, m, q \leq 10 ^ 5$。


## 样例 #1

### 输入

```
5 3 2
11 7 5 3 2
3 2 1
2 5
1 6
```

### 输出

```
0
3```

# 题解

## 作者：elijahqi (赞：11)

http://www.elijahqi.win/archives/3774
https://blog.csdn.net/elijahqi/article/details/80733262

在splay上维护每个位置的hash值 hash值的定义为 第几大的值出现在哪里
$\sum\limits_{i=1}^{n} pos[i]* base^{rank}$

然后先把a序列所有长度为m的hash值都存在hash表里 

然后每次修改b序列的时候 获得一个hash值 然后直接去hash表里询问一下出现次数即可

```
#include<bits/stdc++.h>
#define ll unsigned long long
using namespace std;
inline char gc(){
    static char now[1<<16],*S,*T;
    if (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if (T==S) return EOF;}
    return *S++;
}
inline int read(){
    int x=0,f=1;char ch=gc();
    while(!isdigit(ch)) {if (ch=='-') f=-1;ch=gc();}
    while(isdigit(ch)) x=x*10+ch-'0',ch=gc();
    return x*f;
}
const int N=1e5+10;
const int g=11117;
const int mod=100003;
struct node{
    ll s;int next,v;
}data[N];
ll p[N],hs[N],w[N],S;int size[N],fa[N],c[N][2],h[N],num,b[N],n,m,q,rt,v[N];
inline void update(int x){
    int l=c[x][0],r=c[x][1];
    size[x]=size[l]+size[r]+1;
    hs[x]=hs[l]+p[size[l]]*w[x]+p[size[l]+1]*hs[r];
}
inline void rotate(int x,int &tar){
    int y=fa[x],z=fa[y],l=c[y][1]==x,r=l^1;
    if (y==tar) tar=x;else c[z][c[z][1]==y]=x;
    fa[c[x][r]]=y;fa[y]=x;fa[x]=z;
    c[y][l]=c[x][r];c[x][r]=y;update(y);update(x);
}
inline void splay(int x,int &tar){
   while(x!=tar){
        int y=fa[x],z=fa[y];
        if (y!=tar){
            if (c[y][0]==x^c[z][0]==y) rotate(x,tar);else rotate(y,tar);
        }rotate(x,tar);
    }
}
inline void insert1(int &x,int id,int f){
    if (!x) {x=id;fa[x]=f;update(x);splay(x,rt);return;}
    if (v[id]<v[x]) insert1(c[x][0],id,x);
    else insert1(c[x][1],id,x);
}
//unordered_map<ll,int> mm;
inline void ins(ll s){
    //++mm[s];return;
    int x=s%mod;
    for (int i=h[x];i;i=data[i].next){
        if (s==data[i].s) {++data[i].v;return;}
    }
    data[++num].s=s;data[num].v=1;data[num].next=h[x];h[x]=num;
}
inline int query(ll s){
    //return mm[s];
    int x=s%mod;
    for (int i=h[x];i;i=data[i].next){
        if (s==data[i].s) return data[i].v;
    }return 0;
}
inline void del(int x){
    splay(x,rt);
    if(!(c[x][0]*c[x][1])){rt=c[x][0]+c[x][1];fa[rt]=0;c[x][0]=c[x][1]=0;return;}
    int succ=c[x][1],pre=c[x][0];
    while(c[pre][1]) pre=c[pre][1];
    while(c[succ][0]) succ=c[succ][0];
    splay(pre,rt);splay(succ,c[rt][1]);c[succ][0]=0;fa[x]=0;update(succ);update(rt);

}
int main(){
	freopen("4715.in","r",stdin);
    n=read();m=read();q=read();p[0]=1;
    for (int i=1;i<=n;++i) v[i]=read();
    for (int i=1;i<=n;++i) w[i]=i,p[i]=p[i-1]*g;
    for (int i=1;i<=m;++i) insert1(rt,i,0),S+=p[i-1],b[i]=read();
    for (int i=m;i<=n;++i){
        ins(hs[rt]-S*(i-m));if (i==n) break;
        del(i-m+1);insert1(rt,i+1,0);
    }rt=0;memset(c,0,sizeof(c));memset(fa,0,sizeof(fa));
    for (int i=1;i<=m;++i) v[i]=b[i],insert1(rt,i,0);
    while(q--){
        int x=read(),cc=read();del(x);c[x][0]=c[x][1]=0;
        v[x]=cc;insert1(rt,x,0);
        printf("%d\n",query(hs[rt]));
    }
    return 0;
}
```

---

## 作者：peterwuyihong (赞：6)

单走一个颓废记录 ~~，联赛前禁止 $\text{Ynoi}$，如果你看到了这条记录，请不要 $@\text{devinwang}$~~

首先先新定义字符串为一个序列 $a_{[1,n]}$ ，再定义它的 $\text{rank}$ 数组 $b$

定义两个字符串相等为两个字符串相等为两者的 $\text{rank}$ 数组相同。

给定两个字符串 $A,B$ ，你每次进行一个对 $B$ 字符串单点改的修，然后修改完后要输出 $A$ 中包含几个 $B$ ？（注意字符串相等的定义

于是你开始分析，你并不想用高斯消元后上拉格朗日乘数法套一个有限微积分算出结果，于是你使用了 $\text{Hash}$ ，并选用了一个牛逼的模数。

你发现这个字符串相等的定义很牛逼，要求 $\text{rank}$ ，于是你上了一个平衡树。

于是再字符串 $A$ 中里所有长度为 $|B|$ 的子段的 $\text{Hash}$ 值就出来了。

接下来要动态维护 $B$ 的 $\text{Hash}$ 值。

你选取了一个牛逼的 $\text{Hash}$ 方法，就是对于 $\text{rank}$ 数组 $b_{[1,n]}$ ，值为

$$\sum_{i=1}^nb_i131^{n-i}$$

为什么不用另一种顺着 $\text{Hash}$ 呢，你手摸一下就会发现这样维护的信息变少了。

然后你就一眼秒了，直接上一个 $\text{YK}$ 平衡树就行了。

现在是 $2021.9.8\ 21:32$ ，我开始写。

现在是 $2021.9.10\ 10:43$ ，我写完了。

```cpp
#define maxn 500010
typedef unsigned long long ull;
ull pw[maxn];
int n,m,q;
int a[maxn],b[maxn];
int rt;
int val[maxn],rk[maxn];//幂次 
int dat[maxn];
int ch[maxn][2];
int siz[maxn];
int tag[maxn];
ull ha[maxn];//幂次和 
ull sm[maxn];//Hash 
int tot;
inline void Pushup(int x){
	siz[x]=siz[ch[x][0]]+siz[ch[x][1]]+1;
	ha[x]=(ha[ch[x][0]]+ha[ch[x][1]]+pw[rk[x]]);
	sm[x]=(sm[ch[x][0]]+sm[ch[x][1]]+(siz[ch[x][0]]+1)*(pw[rk[x]]+ha[ch[x][1]]));
}
inline void Pushdown(int x){
	if(tag[x]){
		if(ch[x][0]){
			tag[ch[x][0]]+=tag[x];
			rk[ch[x][0]]+=tag[x];
			ha[ch[x][0]]=ha[ch[x][0]]*pw[tag[x]];
			sm[ch[x][0]]=sm[ch[x][0]]*pw[tag[x]];
		}
		if(ch[x][1]){
			tag[ch[x][1]]+=tag[x];
			rk[ch[x][1]]+=tag[x];
			ha[ch[x][1]]=ha[ch[x][1]]*pw[tag[x]];
			sm[ch[x][1]]=sm[ch[x][1]]*pw[tag[x]];
		}
		tag[x]=0;
	}
}
inline int Build(int x,int y){
	tot++;
	siz[tot]=1;
	ch[tot][0]=ch[tot][1]=0;
	val[tot]=x,rk[tot]=y,tag[tot]=0;
	sm[tot]=ha[tot]=pw[y];
	dat[tot]=rand();
	return tot;
}
inline void Split(int rt,int k,int&x,int&y){//x is small y is big
	if(!rt)x=y=0;
	else{
		Pushdown(rt);
		if(val[rt]<=k)x=rt,Split(ch[rt][1],k,ch[rt][1],y),Pushup(x);
		else y=rt,Split(ch[rt][0],k,x,ch[rt][0]),Pushup(y);
	}
}
inline int Merge(int x,int y){//x is small y is big
	if(!x||!y)return x+y;
	Pushdown(x),Pushdown(y);
	if(dat[x]<dat[y]){
		ch[x][1]=Merge(ch[x][1],y);
		Pushup(x);
		return x;
	}else{
		ch[y][0]=Merge(x,ch[y][0]);
		Pushup(y);
		return y;
	}
}
inline void o(){
	Pushdown(rt);
	tag[rt]++,rk[rt]++;
	ha[rt]=ha[rt]*pw[1],sm[rt]=sm[rt]*pw[1];
}
inline void del(int v){
	int x,y,z;
	Split(rt,v,x,y);
	Split(x,v-1,x,z);
	z=Merge(ch[z][0],ch[z][1]);
	rt=Merge(Merge(x,z),y);
}
inline void I(int a,int b){
	int x,y;
	Split(rt,a,x,y);
	rt=Merge(Merge(x,Build(a,b)),y);
}
map<ull,int>M;
signed main(){
srand(time(NULL));
	cin>>n>>m>>q;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=m;i++)cin>>b[i];
	pw[0]=1;
	for(int i=1;i<=n;i++)pw[i]=pw[i-1]*13331;
	for(int i=1;i<=m;i++)I(a[i],m-i);
	M[sm[rt]]++;
	for(int i=m+1;i<=n;i++){
		del(a[i-m]);
		o();
		I(a[i],0);
		M[sm[rt]]++;
	}
	rt=tot=0;
	for(int i=1;i<=m;i++)I(b[i],m-i);
	while(q--){
		int ccc,ccccc;
		cin>>ccc>>ccccc;
		del(b[ccc]);
		b[ccc]=ccccc;
		I(b[ccc],m-ccc);
		cout<<M[sm[rt]]<<endl;
	}
}
```
真 $\text{tmd}$ 难写，而且自然溢出打爆开 $\text{\_\_int128}$ 模大质数。

原来牛逼的模数竟然是 $2^{64}$ ，我大受震撼。

---

## 作者：chenxia25 (赞：3)

人生第一道Ynoi祭！

听fz说这是上午讲的题？

>### [洛谷题目页面传送门](https://www.luogu.com.cn/problem/P5310)

>给定两个内部元素两两不同的序列$a,b,|a|=n,|b|=m$。定义两个内部元素两两不同的序列本质相同当且仅当它们各自离散化后相同。支持$q$次操作，每次操作修改$b$的一次元素（保证修改完依然内部元素两两不同），要求回答$b$在$a$中有多少次匹配。

>$n,m,q\in\left[1,10^5\right]$。

首先带修的话其他字符串匹配算法基本上用不起来了，想到万能的哈希。

考虑先预处理出$a$中所有长度为$m$的子串的哈希值，存到一个`map`里，然后操作的时候就实时维护$b$的哈希值，往`map`里一查即可。

考虑最常规的滚动哈希$hsh(x)=\sum\limits_{i=1}^{|x|}b^{|x|-i}x_i\bmod p$，其中$b$是哈希base，$p$是哈希模数。为了方便，这里不考虑取模运算。

总结一下有哪些操作：
1. 删除开头元素，并实时更新$x$（这里的$x$是排名）；
1. 在末尾添加元素，并实时更新$x$，实时更新$|x|-i$（其实就是全体加一）；
1. 修改元素，并实时更新$x$；
1. 查询哈希值。

注意到要对排名操作，不难想到基于值域建一个平衡树（这里使用fhq-Treap），支持插入和删除和查哈希值。那么，对于每个节点，键值是$x_i$，我们还需要维护对应的$|x|-i$，全体加一再简单不过了，懒标记即可。还要维护哈希值。

不难发现，此时是排名连续形成区间，而不是下标连续形成区间。一种维护策略是：对于每个节点，维护以它为根的子树形成的排名区间组成的序列中，若认为它们的排名是从$1$开始算的（下标以维护的为准），这样得到的哈希值。合并两个序列（其中第二个序列的任意元素大于第一个序列的任意元素）就很简单了，本来认为第二个序列的排名是从$1$开始的，现在发现是从第一个序列的长度加一开始的（第一个序列不变），根据哈希函数可以得到第二个序列每个元素对应的贡献都要加上$b^{|x|-i}$乘以第一个序列的长度，那么总共先就是$\sum b^{|x|-i}$乘以第一个序列的长度。于是我们还需要维护每个节点的$\sum b^{|x|-i}$，这个合并的话就简单加起来即可。

预处理$b$的幂，时间复杂度$\mathrm O(n\log n)$（认为$n,m,q$同阶）。平衡树的删除使用了垃圾回收。使用了双模，跑得还挺快（不开O2）。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define mp make_pair
#define X first
#define Y second
mt19937 rng(20060617);
const int N=100000,M=100000;
int n,m,qu;
int a[N+1],b[M+1];
const int hbase1=131,hmod1=998244353,hbase2=13331,hmod2=1000000007;//哈希参数 
int pw1[N+1],pw2[N+1];
struct fhq_treap{//平衡树 
	int sz,root;
	struct node{unsigned key;int lson,rson,sz,v1,v2,sum1,hsh1,sum2,hsh2,lz;}nd[M+1];
	#define key(p) nd[p].key
	#define lson(p) nd[p].lson
	#define rson(p) nd[p].rson
	#define sz(p) nd[p].sz
	#define v1(p) nd[p].v1
	#define v2(p) nd[p].v2
	#define sum1(p) nd[p].sum1
	#define hsh1(p) nd[p].hsh1
	#define sum2(p) nd[p].sum2
	#define hsh2(p) nd[p].hsh2
	#define lz(p) nd[p].lz
	stack<int> bin;
	void init(){//初始化 
		sz=root=0;
		nd[0]=node({0,0,0,0,0,0,0,0,0,0,0});
		while(bin.size())bin.pop();
	}
	int nwnd(int v1,int v2){//新建节点 
		int p;
		if(bin.size())p=bin.top(),bin.pop();
		else p=++sz;
		return nd[p]=node({rng(),0,0,1,v1,v2,pw1[v2],pw1[v2],pw2[v2],pw2[v2],0}),p;
	}
	void recyc(int p){bin.push(p);}//垃圾回收 
	void sprup(int p){//上传 
		sz(p)=sz(lson(p))+1+sz(rson(p));
		sum1(p)=(1ll*sum1(lson(p))+pw1[v2(p)]+sum1(rson(p)))%hmod1;
		hsh1(p)=(hsh1(lson(p))+1ll*(sz(lson(p))+1)*pw1[v2(p)]+hsh1(rson(p))+1ll*(sz(lson(p))+1)*sum1(rson(p)))%hmod1;
		sum2(p)=(1ll*sum2(lson(p))+pw2[v2(p)]+sum2(rson(p)))%hmod2;
		hsh2(p)=(hsh2(lson(p))+1ll*(sz(lson(p))+1)*pw2[v2(p)]+hsh2(rson(p))+1ll*(sz(lson(p))+1)*sum2(rson(p)))%hmod2;
	}
	void tag(int p,int v=1){//打懒标记并修改 
		v2(p)+=v;lz(p)+=v;
		sum1(p)=1ll*sum1(p)*pw1[v]%hmod1;hsh1(p)=1ll*hsh1(p)*pw1[v]%hmod1;
		sum2(p)=1ll*sum2(p)*pw2[v]%hmod2;hsh2(p)=1ll*hsh2(p)*pw2[v]%hmod2;
	}
	void sprdwn(int p){//下传懒标记 
		if(lz(p)){
			tag(lson(p),lz(p));tag(rson(p),lz(p));
			lz(p)=0;
		}
	}
	pair<int,int> split(int x,int p=-1){~p||(p=root);
		if(!x)return mp(0,p);
		sprdwn(p);
		pair<int,int> sp;
		if(x<=sz(lson(p)))return sp=split(x,lson(p)),lson(p)=sp.Y,sprup(p),mp(sp.X,p);
		return sp=split(x-1-sz(lson(p)),rson(p)),rson(p)=sp.X,sprup(p),mp(p,sp.Y);
	}
	int mrg(int p,int q){
		if(!p||!q)return p|q;
		sprdwn(p);sprdwn(q);
		if(key(p)<key(q))return rson(p)=mrg(rson(p),q),sprup(p),p;
		return lson(q)=mrg(p,lson(q)),sprup(q),q;
	}
	int lss(int v,int p=-1){~p||(p=root);
		if(!p)return 0;
		sprdwn(p);
		if(v1(p)<v)return sz(lson(p))+1+lss(v,rson(p));
		return lss(v,lson(p));
	}
	void insert(int v1,int v2){//插入 
		pair<int,int> sp=split(lss(v1));
		root=mrg(mrg(sp.X,nwnd(v1,v2)),sp.Y);
	}
	void del(int v){//删除 
		pair<int,int> sp1=split(lss(v)),sp2=split(1,sp1.Y);
		recyc(sp2.X);
		root=mrg(sp1.X,sp2.Y);
	}
	void add(){tag(root);}//全体加一 
	pair<int,int> hsh(){return mp(hsh1(root),hsh2(root));}//查哈希值 
}trp;
map<pair<int,int>,int> hav;//桶 
int main(){
	cin>>n>>m>>qu;
	for(int i=1;i<=n;i++)scanf("%d",a+i);
	for(int i=1;i<=m;i++)scanf("%d",b+i);
	pw1[0]=pw2[0]=1;
	for(int i=1;i<=max(n,m);i++)pw1[i]=1ll*pw1[i-1]*hbase1%hmod1,pw2[i]=1ll*pw2[i-1]*hbase2%hmod2;//预处理幂 
	if(m<=n){//预处理 
		trp.init();
		for(int i=1;i<=m;i++)trp.insert(a[i],m-i);
		hav[trp.hsh()]++;
//		printf("(%d,%d)\n",trp.hsh().X,trp.hsh().Y);
		for(int i=m+1;i<=n;i++){
			trp.del(a[i-m]);trp.add();trp.insert(a[i],0);//变成下一个子串 
			hav[trp.hsh()]++;
//			printf("(%d,%d)\n",trp.hsh().X,trp.hsh().Y);
		}
	}
	trp.init();
	for(int i=1;i<=m;i++)trp.insert(b[i],m-i);
//	printf("\n(%d,%d)\n",trp.hsh().X,trp.hsh().Y);
	while(qu--){
		int x,y;
		scanf("%d%d",&x,&y);
		trp.del(b[x]);trp.insert(b[x]=y,m-x);//修改 
//		printf("(%d,%d)\n",trp.hsh().X,trp.hsh().Y);
		printf("%d\n",hav[trp.hsh()]);
	}
	return 0;
}
```

---

## 作者：xiezheyuan (赞：1)

平衡树写错 $2$ 个小时，输麻了……

## 简要题意

给定一个长度为 $n$ 的序列 $a$ 和一个长度为 $m$ 的序列 $b$，有 $q$ 次操作，每次操作给出 $x,y$，表示令 $b_x\gets y$。

你需要在每次操作执行完成后，输出 $a$ 中有多少个长度为 $m$ 的子串与 $b$ 相似。定义两个序列是相似的，当且仅当离散化后两序列相同。

$1\leq n,m,q\leq 10^5,0\leq a_i\leq 2^{31}-1$。

## 思路

自己想出的一道 Ynoi！虽然这道题比较水就是了。

对于非传统的子串匹配问题，考虑哈希，不过这里的相同是离散化后相同，因此我们需要设计一个和排名相关的哈希函数：

$$
f(A)=\sum_{i=1}^{m}(m-\mathrm{rank}(A_i))\cdot B^i
$$

其中 $\mathrm{rank}(x)$ 表示 $x$ 在 $A$ 中的排名，至于为什么取 $m$ 与其的差，原因仅仅是实现比直接用 $\mathrm{rank}(A_i)$ 自然一点而已，并没有实质上的区别。

于是我们有 $f(A)=f(B)$，则可以认为 $A,B$ 相似。

现在我们只需要预处理出 $A$ 中所有长度为 $m$ 的子串的哈希值，并动态维护当前 $B$ 的哈希值，就可以轻易解决本问题。

先来考虑第二个问题，如何动态维护 $B$ 的哈希值？由于我们只有单点修改，可以将单点修改看成将这个位置的贡献删除，然后替换这个位置，再加上这个位置的贡献。

思考这个位置的贡献是什么，首先是这个位置本身的哈希值项 $(m-\mathrm{rank}(A_i))\cdot B^i$，这是容易处理的，另外的来自于排名。我们发现，对于每一个 $A_j$，若满足 $A_j\leq A_i$，则 $A_i$ 会对 $A_j$ 产生一个 $B^j$ 的贡献（来自排名信息）。我们采用平衡树维护 $B^j$ 的和即可。

最后考虑第一个问题，如何预处理出出 $A$ 中所有长度为 $m$ 的子串的哈希值？

不妨暴力处理出 $[n-m+1,n]$ 区间的哈希值，然后考虑将这个区间向左移动，模仿之前的过程。

你发现这样的问题是当我们移动区间的时候，会出现 $m-1$ 个元素的 $B^j$ 发生变化，如果打标记就太麻烦了。我们可以将 $B^j$ 中的 $j$ 改为 $a$ 中真正的下标，这样求出来的哈希值只是整体多乘了一个 $B$ 的整数次幂，乘上逆元的对应次幂即可。

时间复杂度 $O((n+m+q)\log n)$ 可以通过本题。

## 代码

平衡树用的是 WBLT。

```cpp
#include <bits/stdc++.h>
#define ls(x) (son[x][0])
#define rs(x) (son[x][1])
using namespace std;

constexpr double alpha = 0.2928932188134524;
using ui64 = unsigned long long;
const int N = 1e5 + 5;
constexpr ui64 BASE = 1145141, BASE_INV = 5871511968970297629ull;
int val[N << 1], siz[N << 1], son[N << 1][2], stk[N << 1], top, tot;
ui64 sumt[N << 1];

void delnode(int i){ stk[++top] = i; }
bool leaf(int i){ return !ls(i); }

void pushup(int i){
    if(leaf(i)) return;
    siz[i] = siz[ls(i)] + siz[rs(i)];
    val[i] = val[rs(i)];
    sumt[i] = sumt[ls(i)] + sumt[rs(i)];
}

int newnode(int v, ui64 s){
    int i = top ? stk[top--] : ++tot;
    val[i] = v, sumt[i] = s, siz[i] = 1;
    ls(i) = rs(i) = 0;
    return i;
}

void rotate(int i, bool d){
    swap(ls(i), rs(i));
    swap(ls(son[i][d ^ 1]), rs(son[i][d ^ 1]));
    swap(son[son[i][d ^ 1]][d ^ 1], son[i][d]);
    pushup(son[i][d ^ 1]), pushup(i);
}

void maintain(int i){
    if(leaf(i)) return;
    bool d = 1;
    if(siz[ls(i)] < alpha * siz[i]) d = 1;
    else if(siz[rs(i)] < alpha * siz[i]) d = 0;
    else return;
    if(siz[son[son[i][d]][d ^ 1]] * (1 - alpha) >= siz[son[i][d]] * (1 - 2 * alpha)){
        rotate(son[i][d], d ^ 1);
    }
    rotate(i, d);
}

void insert(int i, int v, ui64 s){
    if(leaf(i)){
        int p = newnode(val[i], sumt[i]), q = newnode(v, s);
        if(val[i] > v) swap(p, q);
        ls(i) = p, rs(i) = q;
        return pushup(i);
    }
    insert(v <= val[ls(i)] ? ls(i) : rs(i), v, s);
    pushup(i), maintain(i);
}

void del(int &i, int v){
    bool d = (v <= val[ls(i)]) ^ 1;
    if(leaf(son[i][d])) delnode(son[i][d]), delnode(i), i = son[i][d ^ 1];
    else del(son[i][d], v), pushup(i), maintain(i);
}

ui64 query(int i, int v){
    if(leaf(i)) return val[i] <= v ? sumt[i] : 0;
    if(v <= val[ls(i)]) return query(ls(i), v);
    else return query(rs(i), v) + sumt[ls(i)];
}

int rnk(int i, int v){
    if(leaf(i)) return 1;
    if(v <= val[ls(i)]) return rnk(ls(i), v);
    else return rnk(rs(i), v) + siz[ls(i)];
}

void clear(int i){
    delnode(i);
    if(!leaf(i)) clear(ls(i)), clear(rs(i));
}

int n, m, q, a[N], b[N], root;
ui64 pw[N], pw_inv[N], f[N];
map<ui64,int> mp;

void init(){
    root = newnode(INT_MAX, 0), pw[0] = pw_inv[0] = 1;
    for(int i=1;i<=n;i++) pw[i] = pw[i - 1] * BASE;
    for(int i=1;i<=n;i++) pw_inv[i] = pw_inv[i - 1] * BASE_INV;
    for(int i=n-m+1;i<=n;i++) insert(root, a[i], pw[i]);
    for(int i=n-m+1;i<=n;i++) f[n - m + 1] += pw[i] * (m - rnk(root, a[i]));
    mp[f[n - m + 1] * pw_inv[n - m]]++;
    for(int i=n-m;i;i--){
        f[i] = f[i + 1];
        f[i] -= pw[i + m] * (m - rnk(root, a[i + m]));
        del(root, a[i + m]);
        f[i] -= query(root, a[i + m]);
        f[i] += query(root, a[i]);
        insert(root, a[i], pw[i]);
        f[i] += pw[i] * (m - rnk(root, a[i]));
        mp[f[i] * pw_inv[i - 1]]++;
    }
    clear(root);
    root = newnode(INT_MAX, 0);
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> n >> m >> q;
    for(int i=1;i<=n;i++) cin >> a[i];
    for(int i=1;i<=m;i++) cin >> b[i];
    init();
    for(int i=1;i<=m;i++) insert(root, b[i], pw[i]);
    ui64 b_hash = 0;
    for(int i=1;i<=m;i++) b_hash += pw[i] * (m - rnk(root, b[i]));
    while(q--){
        int p, v; cin >> p >> v;
        b_hash -= pw[p] * (m - rnk(root, b[p]));
        del(root, b[p]);
        b_hash -= query(root, b[p]);
        b[p] = v;
        b_hash += query(root, v);
        insert(root, v, pw[p]);
        b_hash += pw[p] * (m - rnk(root, v));
        cout << mp[b_hash] << '\n';
    }
    return 0;
}

// Written by xiezheyuan
```

---

## 作者：FutaRimeWoawaSete (赞：1)

很久以前胡了解法一直放着没来管，最近想起来了就来补一下。             

其实和 [P4696](https://www.luogu.com.cn/problem/P4696) 的 hash 做法没有太大的区别。                 

我们考虑这个东西用 kmp 的角度来思考并不怎么优秀，不过这东西本质感觉仍然是字符串匹配，所以猜测用字符串匹配相关思想解决。               

我们发现题目提示的很明显，用两个信息就可以刻画一个长度为 $n$ 的字符串：相应排名的数的相应位置。               

考虑字符串匹配里面常用的 hash，这样做有两个原因：一是文本串不做改动，那么我们直接把所有长为 $m$ 的子串 hash 值存下来就可以静态询问一系列字符串匹配数量的问题；二是这个修改只是单点修改，感觉就很好维护的样子。     

刚开始自己设计的 hash 是 $\sum_{i = 1} ^ n pos_i \times Base^{rank_i}$，但是后来发现好像不是很好处理文本串就换成了 $\sum_{i = 1} ^ n rank_i \times Base^{pos_i}$ 了。            

这个东西很好维护。用值域线段树，倒着枚举所有长度为 $m$ 的子串做区间乘单点改就可以处理文本串了，对于匹配串就只有单点修改。            

时空复杂度 $O(n \log n)$，平衡树做法同理只是会少个空间上的 $\log n$。



---


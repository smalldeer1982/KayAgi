# 缩小社交圈

## 题目描述

社交圈子里有 $n$ 个人，每个人都有一个 SAN 值范围 $[l_i,r_i]$。当两个人的 SAN 值交集不为空时，这两个人有 PY 关系。

现在希望从社交圈子里面挑选出一些人组成一个集合 $S$，如果将所有集合内的人中有 PY 关系的那一对人都连上边，则 $S$ 刚好成为一个树（森林不行哦）。

请问，有多少种可以选择的方案？由于答案可能很大，请对 $10^{9}+7$ 取模。

## 说明/提示

对于20%的数据，满足 $n \leq 18$ 。

对于40%的数据，满足 $n \leq 50$

对于60%的数据，满足 $n \leq 200$

对于100%的数据，满足 $n \leq 2000,1 \leq l_{i} <r_{i} \leq 4000 $


## 样例 #1

### 输入

```
3
1 5
2 7
4 8
```

### 输出

```
6```

# 题解

## 作者：Regimes (赞：50)

这道题，一开始觉得是图论有关的。。。。

嗯。。。我们可以发现，建出来的树一定是一条链带上几个大小为$1$的节点(这些

节点就是被包含的)。

一开始想的非常复杂，设了$5$维$dp[i][j][k][p][o]$表示大小为$i$，最左的左

端点的点为$j$,次左的左端点的点为$k$，最右的点为$p$,次右的为$o$。于是对于

两条链，我们合并其大小，以次左，最左，次右，最右为判断条件进行合并。但是

我们会猛然发现，我们没有必要两条链进行合并，直接枚举一个区间，看能否结合

于是我们可以减少掉大小，左和次左三个维度。

所以复杂度为$O(n^3)$

最后我们前缀和优化一下就行。

```cpp
#include<bits/stdc++.h>

using namespace std ;

#define N 3000
const int Mod = 1e9 + 7 ;

inline int read()
{
    int x = 0, f = 1; char c = getchar();
    while(c < '0' || c > '9') { c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - 48, c = getchar();
    return x * f;
}

int n ;
int dp[N][N] , sum[N][N] , pre[N] ;

struct node{
    int L , R ;
}A[N] ;

bool operator < ( node a , node b ){ return a.R < b.R ; }

int main()
{
    n = read() ;

    for(int i = 1 ; i <= n ; i++ ) A[i].L = read() , A[i].R = read() ;
    sort( A + 1 , A + n + 1 ) ;


    for(int i = 1 ; i <= n ; i++ ){
        pre[i] = 0 ;
        for(int j = i - 1 ; j >= 1 ; j-- ){
            if( A[j].R < A[i].L ){
                pre[i] = j ;
                break ;
            }
        }
    }
    for(int i = 1 ; i <= n ; i++ ){
        for(int j = 1 ; j <= i - 1 ; j++ ){
            if( A[j].R < A[i].L ){
                sum[i][j] = sum[i][j - 1] ;
                continue ;
            }
            if( A[i].L > A[j].L ){
                //for(int k = 1 ; k <= j - 1 ; k++ ){ if( A[k].R < A[i].L ) dp[i][j] = ( dp[i][j] + dp[j][k] ) % Mod ; }
                dp[i][j] = 1 + sum[j][ pre[i] ] ;
            }else{
                //for(int k = 1 ; k <= j - 1 ; k++ ) if( A[k].R < A[j].L ) dp[i][j] = ( dp[i][j] + dp[i][k] ) % Mod ;
                dp[i][j] = 1 + sum[i][ pre[j] ] ;
            }
            if( dp[i][j] >= Mod ) dp[i][j] -= Mod ;
            sum[i][j] = dp[i][j] + sum[i][j - 1] ;
            if( sum[i][j] >= Mod ) sum[i][j] -= Mod ;
        }
    }
    int ans = 0 ;
    for(int i = 1 ; i <= n ; i++ ){
        ans = ans + sum[i][i - 1] ;
        if( ans >= Mod ) ans -= Mod ;
    }
    printf("%d\n" , ( ans + n ) % Mod ) ;

    return 0 ;
}
```


---

## 作者：Fading (赞：37)

疯掉了，这道题看了大概$20$分种就有思路，但是调起来就是$1$个半小时。

原来是自己考虑太少了，对拍了$30$分种才出错（鬼知道为什么）

深深感到我的信息天赋为$\huge 0$。

### 约定

$x_i,y_i$分别表示第$i$个区间的左右端点。

### 算法$1$:

我会状压！

期望得分：$20$分。

### 算法$2$:

我们先对所有区间按照右端点进行排序。

然后发现连边就成了这样：

![](https://cdn.luogu.com.cn/upload/pic/63750.png)

如果我们按序编号，就变成了这样：

![](https://cdn.luogu.com.cn/upload/pic/63751.png)

发现了什么？

#### 如果$l,r(l<r)$之间有边，那么$[l,r-1]$之间的点均与$r$有边。

这就是我们要排序的原因，之后我们可以直接开始$dp$了！

#### 情况$1$

发现排序以后，假设我们$dp$到了第$i$条线段，那么我们枚举$1\sim i-1$的线段$j$。

我们发现，如果$j\cap i=\varnothing(y_j<x_i)$，那么没法转移（不能为森林）

如果$j\cap i \not=j\ (x_j<x_i)$，如图：

![](https://cdn.luogu.com.cn/upload/pic/63754.png)

那么我们可以选择$j$，但是，如果选了$j$，有一些边，比如打上橙色叉叉的边，就不能选。为什么呢？这样会出现三元环！

所以我们不能单纯的用$f_i$表示前$i$个的方案数，我们可以考虑设$f_{i,j}$表示选择$i$，且上一个选择$j$的方案数。

这样，如果选择了$y_j\geq x_i$的$j$，所有满足$y_k\geq x_i$的边都不可以选。

那么我们有转移方程式：

$$f_{i,j}=\sum_{k=0,y_k<x_i}^{i-1}f_{j,k}\ \ (y_j\geq x_i,x_j<x_i)$$


#### 情况$2$

傻逼的我忘记了这种情况^_^，拍了很久才发现。

如果$j\cap i =j\ (x_j\geq x_i)$，如图

![](https://cdn.luogu.com.cn/upload/pic/63755.png)

$j$被$i$包含了。我们可以选择$j$，但是...

情况变得棘手很多。

发现选择$i,j$以及打上绿色勾勾的边是可以构成一棵树的，而选择打上橙色叉叉的则不行（环！）...

那么，仿佛我们又可以转移了！

我们选择了$j$以后，就不可以选择$y_k\geq x_j$的$j!!!$

好了，我们又可以得到方程了。

$$f_{i,j}=\sum_{k=0,y_k<x_j}^{i-1}f_{j,k}\ \ (y_j\geq x_i,x_j>x_i)$$

对吗？

#### 错了！

这样子$f_{j,k}$不都等于$0$了吗？

其实此时假设选择$k$，那么对于所有的$f_{i,k}$，再接上一个$j$不会有问题。

所以我们的方程应该是这样：

$$f_{i,j}=\sum_{k=0,y_k<x_j}^{i-1}f_{i,k}\ \ (y_j\geq x_i,x_j>x_i)$$

那么我们分两类情况讨论就好了！

#### 边界

$f_i[0]=1$

#### 最终答案

就是

$$\sum_{i=1}^n\sum_{j=0}^{i-1}f_{i,j}$$

期望得分：$60$分。

### 算法$3$:

看看我们的方程式：

$$f_{i,j}=\sum_{k=0,y_k<x_i}^{i-1}f_{j,k}\ \ (y_j\geq x_i,x_j<x_i)$$

$$f_{i,j}=\sum_{k=0,y_k<x_j}^{i-1}f_{i,k}\ \ (y_j\geq x_i,x_j>x_i)$$

是不是可以树状数组优化呢？

那么这道题就做完了。

时间复杂度$O(n^2log_2n)$

期望得分：$100$分。

代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ljc 1000000007
using namespace std;
#ifdef Fading
#define gc getchar
#endif
#ifndef Fading
inline char gc(){
    static char now[1<<16],*S,*T;
    if (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if (T==S) return EOF;}
    return *S++;
}
#endif
inline ll read(){
    register ll x=0,f=1;char ch=gc();
    while (!isdigit(ch)){if(ch=='-')f=-1;ch=gc();}
    while (isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=gc();}
    return (f==1)?x:-x;
}
int f[4011][4011],n,m,L[4021];
struct que{
    int x,y;
}x[4011];
inline bool cmp(que a,que b){
    if (a.y==b.y) return a.x<b.x;
    return a.y<b.y;
}
struct tree{
    int tr[4021];
    inline void add(int a,int b){
        a++;
        for (;a<=4001;a+=a&-a) tr[a]=(tr[a]+b)%ljc;
    }
    inline int query(int a){
        int ans=0;
        a++;
        for (;a;a-=a&-a) ans=(ans+tr[a])%ljc;
        return ans;
    }
}tr[4021];
signed main(){ 
    n=read();
    for (int i=1;i<=n;i++){
        x[i].x=read(),x[i].y=read();
    }
    sort(x+1,x+1+n,cmp);
    for (int i=2;i<=n;i++){
        int lb=1,rb=i,ans=-1;
        while (lb<=rb){
            int mid=lb+rb>>1;
            if (x[mid].y<x[i].x) lb=mid+1;
            else ans=mid,rb=mid-1;
        }
        L[i]=ans;//卡常用的，预处理第一个满足条件的点
    }
    for (int i=1;i<=n;i++) f[i][0]=1,tr[i].add(0,1);
    for (int i=2;i<=n;i++){
        for (int j=L[i];j<i;j++){
        	if (x[i].x<=x[j].x){
    			f[i][j]=tr[i].query(x[j].x-1);
            }else{
    			f[i][j]=tr[j].query(x[i].x-1);
            }
            tr[i].add(x[j].y,f[i][j]);
        }
    }
    int ans=0;
    for (int i=1;i<=n;i++){
        for (int j=0;j<i;j++){
            ans=(ans+f[i][j])%ljc;
        }
    }
    printf("%d\n",ans);
    return 0;
}


```

### 算法$4$：

发现我们对区间进行了排序，那么每一次加入树状数组的点都是递增的。

所以我们可以用前缀和优化时间复杂度。

开一个变量，更新前缀和的时候扫一遍即可。

时间复杂度$O(n^2)$

期望得分：$100$分

细节见代码，非常多。

~~也就比树状数组快了100ms~~

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ljc 1000000007
using namespace std;
#ifdef Fading
#define gc getchar
#endif
#ifndef Fading
inline char gc(){
    static char now[1<<16],*S,*T;
    if (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if (T==S) return EOF;}
    return *S++;
}
#endif
inline ll read(){
    register ll x=0,f=1;char ch=gc();
    while (!isdigit(ch)){if(ch=='-')f=-1;ch=gc();}
    while (isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=gc();}
    return (f==1)?x:-x;
}
int f[4011][4011],n,m,L[4021];
struct que{
    int x,y;
}x[4011];
inline bool cmp(que a,que b){
    if (a.y==b.y) return a.x<b.x;
    return a.y<b.y;
}
int sum[4021][4021];
signed main(){ 
    n=read();
    for (int i=1;i<=n;i++){
        x[i].x=read(),x[i].y=read();
    }
    sort(x+1,x+1+n,cmp);
    for (int i=2;i<=n;i++){
        int lb=1,rb=i,ans=-1;
        while (lb<=rb){
            int mid=lb+rb>>1;
            if (x[mid].y<x[i].x) lb=mid+1;
            else ans=mid,rb=mid-1;
        }
        L[i]=ans;
    }
    for (int i=1;i<=4000;i++) f[i][0]=1,sum[i][0]=1,sum[1][i]=1;
    for (int i=2,las=0;i<=n;i++){
        for (las=1;las<=x[L[i]].x;las++){//为第一种情况做准备
            sum[i][las]=sum[i][las-1];
        }
        for (int j=L[i],k;j<i;j++){
        	if (x[i].x<=x[j].x){
    			f[i][j]=sum[i][x[j].x-1];
            }else{
    			f[i][j]=sum[j][x[i].x-1];
            }
            for (k=las;k<=x[j].y;k++){//更新前缀和
                sum[i][k]=sum[i][k-1];
            }
            sum[i][k-1]=(sum[i][k-1]+f[i][j])%ljc;
            for (;k<=x[j+1].x-1;k++){//为下一次做准备
                sum[i][k]=sum[i][k-1];	
            }
            las=k;
        }
        for (;las<=4000;las++){//更新完所有前缀和
        	sum[i][las]=sum[i][las-1];
        }
    }
    int ans=0;
    for (int i=1;i<=n;i++){
        for (int j=0;j<i;j++){
            ans=(ans+f[i][j])%ljc;
        }
    }
    printf("%d\n",ans);
    return 0;
}


```


---

## 作者：ruogu (赞：20)

​		首先，我们发现每个点不能出现三个区间包含它。并且这些区间一定是一串大区间相交，每个大区间里也许有小区间，小区间只能在一个大区间里，小区间不能相互相交。比如大区间是$[1,10],[8,12]$，然后小区间就可以是$[1,3],[4,5]$。$[7,10]$就不行。

​		我们把所有区间按右端点为第一关键字，左端点为第二关键字从小到大排序。首先每个区间自己肯定是符合的。令$dp[i][j](i>j)$表示以区间$i$为最后一个，区间$j$为倒数第二个的合法树的方案数。当$r[j]<l[i]$时$dp[i][j]=0$。否则若$l[j]<l[i]$,$dp[i][j]=1+\sum_{k=1}^{j-1}[r[k]<l[i]]dp[j][k]$否则$dp[i][j]=1+\sum_{k=1}^{j-1}[r[k]<l[j]]dp[i][k]$。到此处是$O(n^3)$的。我们令$f[i][j]$表示以区间$i$结尾且倒数第二个区间$k$必须满足$r[k]<=j$的方案数。则$dp[i][j]=1+f[i][l[j]-1]$或$dp[i][j]=1+f[j][l[i]-1]$(与上面两个对应)，$f[i][j]=f[i][j-1]+\sum_{p=1}^{i-1}[r[p]=j]dp[i][p]$。注意最后一个$\sum$是均摊$O(1)$的，我们只要用一个$vector$记录所有右端点为$j$的区间编号$p$。复杂度$O(n^2)$。

```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<algorithm>
#include<string>
#include<cstring>
#include<cctype>
#include<queue>
#include<stack>
#include<map>
#include<set>
#include<iomanip>
#include<sstream>
#include<vector>
#include<cstdlib>
#include<ctime>
#include<list>
#include<deque>
#include<bitset>
#include<fstream>
#define ld double
#define ull unsigned long long
#define ll long long
#define pii pair<int,int >
#define iiii pair<int,pii >
#define mp make_pair
#define INF 1000000000
#define MOD 1000000007
#define rep(i,x) for(int (i)=0;(i)<(x);(i)++)
inline int getint(){
	int x=0,p=1;char c=getchar();
	while (c<=32)c=getchar();
	if(c==45)p=-p,c=getchar();
	while (c>32)x=x*10+c-48,c=getchar();
	return x*p;
}
using namespace std;
//ruogu
const int N=2010;
int n,res,f[N][N<<1],dp[N][N];
vector<pii >a;
vector<int>q[N<<1];
//
inline void add(int &x,int y){
	x+=y;
	if(x>=MOD)x-=MOD;
}
inline void sub(int &x,int y){
	x-=y;
	if(x<0)x+=MOD; 
}
inline int mul(int x,int y){
	ll ans=1ll*x*y;
	return ans%MOD;
}
inline bool cmp(pii x,pii y){
	if(x.second!=y.second)return x.second<y.second;
	return x.first<y.first;
}
int main(){
	n=getint();
	rep(i,n){
		int x=getint(),y=getint();
		a.push_back(mp(x,y));
	}
	sort(a.begin(),a.end(),cmp);
	rep(i,n)q[a[i].second].push_back(i);
	res=n;
	for(int i=1;i<n;i++){
		for(int j=a[i].first;j<=a[i].second;j++){
			f[i][j]=f[i][j-1];
			rep(k,q[j].size())if(q[j][k]<i){
				int ff=q[j][k];
				dp[i][ff]=1;
				if(a[ff].first<=a[i].first)add(dp[i][ff],f[ff][a[i].first-1]);
				else add(dp[i][ff],f[i][a[ff].first-1]);
				add(f[i][j],dp[i][ff]);
				add(res,dp[i][ff]);
			}
		}
	}
	cout<<res<<endl;
	return 0;
}


```

---

## 作者：LittleFall (赞：7)

7月月赛D，很好的一道题，但是并不能看懂比赛后的讲评（），思路有参考自[**Fading大佬**](https://www.luogu.org/blog/wohaocaia/solution-p5464)orz

## 题意
给出$n$(2000)条数轴上的线段(1,4000)，如果两条线段交集不为空，视为有边相连。问有几种选择子集的方案，满足子集中所有的边恰好构成一棵树（不是森林）。

## 做法
#### 排序
记线段$i$的左右端点分别为$x[i],y[i]$，将所有线段按【右端点为第一关键字，左端点为第二关键字】排序。

这样排序后，如果线段$l$和$r$有边相连($y[l]>=x[r]$)，那么$[l,r-1]$内的线段都和$r$有边相连.

#### 动态规划

状态表示：$dp[i][j]$表示最后一条线段选$i$，倒数第二条选段选$j$的方案数。

状态边界：$dp[i][0]=1$，表示单独一条线段也算一种方案

状态转移：首先注意，只有$j<i$且$y[j]>=x[i]$（即i和j有交集）的才是合法状态。此时分以下两种情况:

1. $x[j]<=x[i]$，如下图所示。此时$dp[i][j]=\Sigma_{k=0}^{j-1}dp[j][k]$，且$y[k]<x[i]$

![在这里插入图片描述](https://cdn.luogu.com.cn/upload/pic/64246.png)

2. $x[j]>x[i]$，如下图所示。此时$dp[i][j]=\Sigma_{k=0}^{j-1}dp[i][k]$，且$y[k]<x[j]$

![在这里插入图片描述](https://cdn.luogu.com.cn/upload/pic/64247.png)

最后将所有状态的值加起来就是答案，状态数$O(n^2)$，单次转移$O(n)$，总复杂度$O(n^3)$

#### 前缀和优化

注意到状态转移方程中取$k$时，总是需要满足
1. $k>=0$
2. $k<j-1$
3. $y[k]<x[i]$（或$y[k]<x[j]$）

因为排序时第一关键字是$y$，所以每次求和是$k$一定是连续的。

我们可以预处理出一个数组$lst$，$lst[i]$表示满足$y$值小于$x[i]$的最大位置，因为$y$的单调性质，可以二分求出，但是这里的求法不会成为复杂度瓶颈，$O(n^2)$求出也无所谓。

求得$lst$之后，就可以在DP时使用前缀和优化，优化后的状态转移方程如下：

1. $x[j] < x[i]$时，$dp[i][j]=sum[j][min(j-1, lst[i])]$
2. $x[j] > x[i]$时，$dp[i][j]=sum[i][min(j-1, lst[j])]$

此时状态转移$O(1)$，总复杂度$O(n^2)$


## 代码
```cpp
/* LittleFall : Hello! */
#include <bits/stdc++.h>
using namespace std; using ll = long long; inline int read();
const int M = 2048, MOD = 1000000007;

inline void up(int &a, int b){a = (a+b) % MOD;}
int x[M], y[M];
void readin(int n) //读入并按右侧、左侧排好序，放在x/y中
{
	vector<pair<int,int>> vc;
	for(int i=1; i<=n; ++i)
	{
		vc.push_back({0,0});
		vc.back().first=read();
		vc.back().second=read();
	}
	sort(vc.begin(), vc.end(), [](pair<int,int> &a, pair<int,int> &b){
		if(a.second != b.second)
			return a.second < b.second;
		return a.first > b.first;
	});
	for(int i=1; i<=n; ++i)
	{
		x[i] = vc[i-1].first;
		y[i] = vc[i-1].second;
	}
}
int sum[M][M]; // [i][j]表示最后一个选i，上一个选j的方案数，对j取前缀和
// 对于每个i，需要找到最大的csf[i]使得，y[csf[i]]<x[i]，为简便起见，可以二维循环去找
int csf[M];
int main(void)
{
	#ifdef _LITTLEFALL_
	freopen("in.txt","r",stdin);
    #endif

	int n = read();
	readin(n);

	for(int i=1; i<=n; ++i)
	{
		for(int j=0; j<i; ++j)
		{
			if(y[j]<x[i])
				csf[i] = j;
			else
				break;
		}
	}

	int ans = 0;
	for(int i=1; i<=n; ++i)
	{
		sum[i][0] = 1;
		for(int j=1; j<i; ++j)
		{
			if(y[j] >= x[i])
			{
				if(x[j] < x[i]) //j在x左侧仍有延伸，从dp[j][k]转移, k>=0，k<j, y[k]<x[i]
				{
					up(sum[i][j], sum[j][min(j-1, csf[i])]);
				}	
				else //j被包含于x，从dp[i][k]转移, k>=0, k<j, y[k]<x[j]
				{
					up(sum[i][j], sum[i][min(j-1, csf[j])]);
				}
			}
			//printf("%d ",sum[i][j] );
			up(sum[i][j], sum[i][j-1]);
		}
		//printf("\n");
		up(ans,sum[i][i-1]);
	}
	cout << ans << endl;

    return 0;
}


inline int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9') {if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
```

---

## 作者：Sym_Je (赞：5)

# P5464 缩小社交圈    


## 题目大意   
给你 $n$ 个区间 $[l,r]$ ,若有两个区间的交集不为空 ，呢么这两个区间就可以连边 ，问我们有多少种方案去选区间使其连完边后是一棵树  。   

## $solution$   

首先这个区间有一个特殊的性质，就是选出的区间他们覆盖的点最多只能覆盖一次 ，如果有两次就会出现环了 。  
既然我们要的是一棵树而不是森林，所以我们的每一个区间都会与其他的区间互相覆盖 。    
为了方便我们的转移我们先将所有区间以 $r_i$ 为第一关键字 ， $l_i$ 为第二关键字 。  
好 ，我们设 $dp[i][j]$ 表示目前所选的两个区间 $i,j$  ,且 $r_i>r_j$  .若 $l_i>r_j~~~ dp[i][j]=0~or~dp[i][j]=1$ (只选 $i,j$)   

我们考虑转移 $\to$   
我们枚举 $j$ 以前的区间 $k$  
若 $l_i<l_j$ 呢么我们的 $l_i<=r_k<=l_j$ ,$dp[i][j]+=dp[i][k]$ 
   
 $or$ $l_j<=r_k<l_i,dp[i][j]+=dp[j][k] .$    
 复杂度 $O(n^3)$  之后 $BIT$ 优化一下就好啦 。 
 
复杂度 $O(n^2logn)$ 
 
* code 
 
```cpp
 
#include<bits/stdc++.h>

using namespace std;
const int mod=1e9+7;
const int maxn=4001;

int dp[maxn][maxn],ans;
int n;
struct node
{
	int l,r;
}t[maxn];
bool cmp(node a,node b) {
	return a.r<b.r; 
}
int z[maxn][maxn];
int lb(int x) {
	return (x)&(-x);
}
void add(int x,int w,int id) {
	for(int i=x;i<=4000;i+=lb(i)) z[i][id]=(z[i][id]+w)%mod;
}
int qu(int x,int id){
	int ans=0;
	for(int i=x-1;i;i-=lb(i)) ans=(ans+z[i][id])%mod;
	return ans;
}
int main() 
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i) 
		scanf("%d%d",&t[i].l,&t[i].r);
	sort(t+1,t+n+1,cmp);
	for(int i=1;i<=n;++i) {
		for(int j=1;j<i;++j) {
			if(t[i].l>t[j].r) continue ;
			dp[i][j]=1;
			if(t[i].l>t[j].l) {
				dp[i][j]=(dp[i][j]+qu(t[i].l,j));
		//		for(int k=1;k<j;++k) if(t[k].r<t[i].l) dp[i][j]=(dp[i][j]+dp[j][k])%mod;
			}else {
				dp[i][j]=(dp[i][j]+qu(t[j].l,i));
		//		for(int k=1;k<j;++k) if(t[k].r<t[j].l) dp[i][j]=(dp[i][j]+dp[i][k])%mod;
			}
			add(t[j].r,dp[i][j],i);
		}
	}
	for(int i=1;i<=n;++i) {
		for(int j=1;j<i;++j) ans=(ans+dp[i][j])%mod;
	}
	cout<<(ans+n)%mod<<"\n";
	return 0;
}

```


---

## 作者：ywh666 (赞：5)

我们可以先将区间以$l$为第一关键字，$r$为第二关键字排序，那么设$dp[i][j]$表示$i$与$j$分别为所选所有区间中$r$第$1$小和$r$第二小的方案数。观察可得每个$dp[i][j]$转移在排好序后的一个区间内，那我们可以预处理出这个区间，然后用前缀和更新即可，复杂度$O(n^2$)
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod=1e9+7;
inline void read(int &x)
{
	x=0;int p=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')p=-p;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch-'0'),ch=getchar();
	x=x*p;
}
int n,dp[2005][2005],qz[2005][2005],sl[4005],sr[4005];
struct node{int l,r;
}p[2005];
bool cmp(const node&a,const node&b)
{
	if(a.l!=b.l)return a.l<b.l;
	return a.r<b.r;
}
int min(int x,int y)
{
	return x<y?x:y;
}
int max(int x,int y)
{
	return x>y?x:y;
}
void add(int &x,int y)
{
	x+=y;
	if(x>=mod)x-=mod;
	if(x<0)x+=mod;
}
signed main()
{
	read(n);
	for(int i=1;i<=n;++i)
	{
		read(p[i].l);read(p[i].r);
	}
	sort(p+1,p+n+1,cmp);
	for(int i=1;i<=n;++i)
	{
		for(int j=i+1;j<=n;++j)
		{
			if(p[i].r>=p[j].l)dp[i][j]=1;
		}
	}
	p[n+1].l=99999999;
	sl[0]=0,sr[0]=0;
	for(int i=1;i<=4000;++i)
	{
		sl[i]=sl[i-1];
		sr[i]=sr[i-1];
		while(p[sl[i]].l<i)sl[i]++;
		while(p[sr[i]+1].l<=i)sr[i]++;
	}
	for(int i=1;i<=n;++i)
	{
		for(int j=i+1;j<=n;++j)
		{
			if(!dp[i][j])continue;
			add(qz[i][j],qz[i][j-1]);
			add(dp[i][j],qz[i][j]);
			if(p[i].r==p[j].r)continue;
			int x=min(p[i].r,p[j].r);
			int y=max(p[i].r,p[j].r);
			int resl=sl[x+1];
			int resr=sr[y];
			if(resl>resr)continue;
			if(p[i].r>p[j].r)add(qz[i][resl],dp[i][j]),add(qz[i][resr+1],-dp[i][j]);
			else add(qz[j][resl],dp[i][j]),add(qz[j][resr+1],-dp[i][j]);
		}
	}
	int ans=n;
	for(int i=1;i<=n;++i)
	{
		for(int j=i+1;j<=n;++j)
		{
			add(ans,dp[i][j]);
		}
	}
	printf("%lld\n",ans);
}
```


---

## 作者：xukehg (赞：4)

模拟赛场切紫，爽！

注意到我们只关心集合的形态，因此我们可以将线段排序，使得答案中的线段按左端点升序。观察可以发现，把原有的一个答案加入一条线段时，记最右的两个的点位置为 $j$ 和 $k$，则加入的线段的左端点处于 $(j,k]$ 中，只有一个线段需要特殊处理。这里记线段的左端点为 $l_i$，右端点为 $r_i$。

考虑动态规划。设 $dp_{i,j,k}$ 表示前 $i$ 个点的次最右点在 $j$，最右的点在 $k$ 的方案数（描述得有点抽象）。有以下几种递推：

1. $dp_{i,j,k} = dp_{i - 1,j,k}$，即把前面的答案统计进来。

2. $dp_{i,k + 1,r_i} + \sum_{j = 1}^{l_i}dp_{i - 1,j,k}$，即转移的区间与该线段有交但并不包含，此时 $1 \leq k \leq l_i$。

3.  $dp_{i,r_i + 1,k} + \sum_{j = 1}^{l_i}dp_{i - 1,j,k}$，即转移的区间包含该线段，此时 $k > r_i$。

这样做空间时间都太大，考虑优化。

我们观察到 $2$ 式和 $3$ 式都在求 $\sum_{j = 1}^{l_i}dp_{i - 1,j,k}$，即右端点在 $k$ 的前 $l_i$ 个数之和。弱智的我写了树状数组，其实直接前缀和就行了。

我们发现参与转移的区间除了 $1$ 式外两两不交，于是我们把 $1$ 式丢到后面，然后就可以去掉 $i$ 了。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2005,mod = 1e9 + 7;

int n;
int l[N],r[N];
struct SEG{int lef,righ;}seg[N];
bool cmp(SEG x,SEG y){return (x.lef == y.lef ? x.righ < y.righ : x.lef < y.lef);}
int dp[2 * N + 5][2 * N + 5];
struct BIT{
	int tr[2 * N + 5];
	#define lbt(x) (x & -x)
	void insert(int x,int p){for (int i = x;i <= 2 * N;i += lbt(i)) (tr[i] += p) %= mod;}
	int query(int x){int res = 0;for (int i = x;i;i -= lbt(i)) res = (res + tr[i]) % mod;return res;}
}bit1[2 * N + 5];
signed main(){
//  	freopen("count.in","r",stdin);
//  	freopen("count.out","w",stdout);
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin >> n;for (int i = 1;i <= n;i++) cin >> seg[i].lef >> seg[i].righ;
	sort(seg + 1,seg + 1 + n,cmp);for (int i = 1;i <= n;i++) l[i] = seg[i].lef,r[i] = seg[i].righ;
	for (int i = 1;i <= n;i++){
		for (int k = r[i] + 1;k < 2 * N;k++){
			dp[r[i] + 1][k] = (dp[r[i] + 1][k] + bit1[k].query(l[i])) % mod;
			bit1[k].insert(r[i] + 1,bit1[k].query(l[i]));
		}
		for (int k = l[i];k <= r[i];k++){
			dp[k + 1][r[i]] = (dp[k + 1][r[i]] + bit1[k].query(l[i])) % mod;
			bit1[r[i]].insert(k + 1,bit1[k].query(l[i]));
		}		
		dp[l[i]][r[i]] = (dp[l[i]][r[i]] + 1) % mod;bit1[r[i]].insert(l[i],1);
	}
	int ans = 0;
	for (int i = 1;i < 2 * N;i++){
		for (int j = i - 1;j < 2 * N;j++) ans = (ans + dp[i][j]) % mod;
	}cout << ans << "\n";
}
/*
5
12 97
66 89
79 96
96 147
97 155
*/ 
```

---

## 作者：Minakami_Yuki (赞：4)

讲一讲DP优化

$O(n ^ 3)$的暴力DP还是比较容易想到的，我们考虑一下它慢在哪里

观察转移的过程，可以发现寻找下一个区间是$O(n)$的，比较暴力，所以我们把它预处理出来。

这样的复杂度就会由$O(n ^ 2 \times n)$变成$O(n ^ 2 + n)$


---

## 作者：creation_hy (赞：2)

显然题意等价于选出的区间连通且任意三个区间都没有交集，于是可以将区间按左端点排序，那么只需要考虑右端点即可。

容易写出 dp $f_{i,j}$ 表示当前已选区间最大右端点为 $j$，次大右端点为 $i$ 时的方案数，假设新区间为 $[l,r]$，那么仅当 $i<l$ 且 $l\le j$ 时这个区间可以选（相当于钦定右端点最大的区间和该区间有交，次大区间无交）。

然后可以发现当前区间和最大区间右端点都比次大要大，于是可以写出转移：

$f_{\min(r,j),\max(r,j)}=\displaystyle\sum_{i<l,l\le j} f_{i,j}$

发现枚举 $j$ 后 $i$ 条件单调，树状数组维护即可。~~好像都不用树状数组~~

时间复杂度 $O(n^2\log n)$

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 4005;
const int mod = 1e9 + 7;
int n;
ll ans;
struct node
{
    int l, r;
    inline bool operator<(const node &t) const
    {
        return l == t.l ? r < t.r : l < t.l;
    }
} a[N];
struct BIT
{
    ll sum[N];
    inline int lowbit(int x) { return x & -x; }
    inline void add(int x, int k)
    {
        for (; x < N; x += lowbit(x))
            (sum[x] += k) %= mod;
    }
    inline ll query(int x)
    {
        ll res = 0;
        for (; x; x -= lowbit(x))
            (res += sum[x]) %= mod;
        return res;
    }
} tr[N];
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n;
    for (int i = 1; i <= n; i++)
        cin >> a[i].l >> a[i].r, a[i].l++, a[i].r++;
    sort(a + 1, a + 1 + n);
    for (int i = 1; i <= n; i++)
    {
        for (int j = a[i].l; j < N; j++)
        {
            int k1 = min(a[i].r, j), k2 = max(a[i].r, j), w = tr[j].query(a[i].l - 1);
            (ans += w) %= mod, tr[k2].add(k1, w);
        }
        (ans += 1) %= mod, tr[a[i].r].add(1, 1);
    }
    cout << ans << '\n';
    return 0;
}
```

---


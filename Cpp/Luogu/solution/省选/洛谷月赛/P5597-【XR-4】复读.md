# 【XR-4】复读

## 题目背景

**赛时提醒：当机器人在这棵完全二叉树的根时，执行 `U` 是非法的，即你需要保证不可能出现这种情况。**

**赛时提醒：这棵二叉树是无限向下延伸的，即所有节点均有左子节点与右子节点，除了根的所有节点均有父亲。**

## 题目描述

小 X 捡到了一台复读机，这台复读机可以向机器人发号施令。机器人将站在一棵完全二叉树的根上，完全二叉树是无限延伸的。你将向复读机录入一串指令，这串指令单个字符可以是：

* `L`：命令机器人向当前节点的左子走；
* `R`：命令机器人向当前节点的右子走；
* `U`：命令机器人向当前节点的父亲走（若没有，则命令非法）。

录入指令后，复读机将会把指令无限复读下去。比如命令为 `LR`，那么机器人会遵从 `LRLRLRLR...` 一直走下去。

这棵完全二叉树上有一个 $n$ 个节点的连通块，保证这个连通块包含根节点。连通块上的每个节点都埋有宝藏，机器人到达过的地方如果有宝藏，则会将其开采。如果一个地方没有宝藏，机器人也可以到那里去。机器人也可以反复经过一个地方。

显然，这个连通块本身也是一棵二叉树。

现在，有人告诉了小 X 埋有宝藏的这棵二叉树的前序遍历，小 X 需要寻找到一条尽量短的指令，使得机器人能够挖掘出所有宝藏。

## 说明/提示

【样例 1 说明】

一种可行的最短指令为 `LRU`。

---

**本题采用捆绑测试。**

- Subtask 1（31 points）：$2 \le n \le 10$。
- Subtask 2（32 points）：$2 \le n \le 200$。
- Subtask 3（37 points）：无特殊限制。

对于 $100\%$ 的数据，$2 \le n \le 2 \times 10^3$。

## 样例 #1

### 输入

```
1313000
```

### 输出

```
3
```

## 样例 #2

### 输入

```
333003003300300
```

### 输出

```
15
```

# 题解

## 作者：天泽龟 (赞：29)

这题思维挺新颖的，一时候拿到还真不一定做出来，本人也是看了讲评才明白的，真是让人叹为观止。

可惜的是，很多人表示并不明白官方题解是啥意思，故写文以记之，希望可以帮助更多人。

---

首先我们要明白题目的意思：给定一个**无限**二叉树，并给定以1号节点为根标记一个小的染色二叉树，找一个**最小遍历循环节**（以下简称，$S$）可以通过无数次循环走遍这个染色二叉树（以下简称，$T$）。

由于二叉树的大小是无限的，所以可以保证如果$S$合法（即不会跑到根的父亲），就可以一直走下去。**当然，如果出现遍历到的节点$\notin T$，这并不影响循环节的合法性。**

我们来考虑正解。很明显的是，每复读一遍$S$，你一定仅会到达当前节点子树中的某一节点。当该节点 $\notin T$ 时，你之后一定会越偏越远，再也遍历不到$T$的节点了，整个复读就此结束。**而我们要做的，就是确保我们构造的$S$可以在此之前遍历完$T$的所有节点。**

又由于每次复读一遍$S$，所到达节点$x$ 与 当前节点$now$ 的**相对位置**是不变的，而且下一步我们也仅会遍历$x$子树中的元素了，这就意味着**我们要遍历到所有$p\in T$，且$p$属于$now$的子树但不属于$x$的子树，这些点若此时不被遍历就永远没机会了。**

基于以上两点，我们不妨通过枚举根节点通过一次循环节可到达的节点$X$，以此不断复读下去直到离开$T$，**同时我们把所有以$now$为根的，不包含$x$的子树 的染色连通块截取下来，并将它们以$now$为根，合并成一个染色"并"树（这里引用了官方题解的说法）**，很明显的是该并树包含了我们一次操作中所要包含到的所有节点。

若该树的大小为$size$，与$X$相对位移为$x$（其实就是深度），那么最优的构造方案即为$2*(size-1)-x$，即除了$X$及其链上的点只走一次外，其他均走2次。

由于我们枚举$X$是$O(N)$的，建个并树也是$O(N)$的，所以$O(N^2)$稳过~

---

当然，理论很简单，但在代码实现方面仍有些小问题。比方说这个"并"树，我们到底是如何得到的呢？

我们可以类比线段树合并的思想（反正都是二叉树），若原来没有点就新建一个，原来有点的话就直接合并，最后特判一下别搜到$x$的子树就行啦，详细可以看我丑陋的代码：
```cpp
#include <iostream>
#include <cstring>
#define inf 2147483647
using namespace std;

struct ed{
	int ls,rs,f,sz,dd;
}p[3000],c[3000];
string s;
int st,lq,ans=inf/2;

int build(int fa,int poi)  //初始化建树 
{
	p[poi].f=fa; p[poi].sz=1; p[poi].dd=p[fa].dd+1; 
	if (s[poi]=='3') {
		p[poi].ls=build(poi,poi+1), p[poi].sz+=p[p[poi].ls].sz;
		p[poi].rs=build(poi,poi+p[poi].sz), p[poi].sz+=p[p[poi].rs].sz;}
	if (s[poi]=='2') 
		p[poi].rs=build(poi,poi+1), p[poi].sz+=p[p[poi].rs].sz;
	if (s[poi]=='1')
		p[poi].ls=build(poi,poi+1), p[poi].sz+=p[p[poi].ls].sz;
	return poi;
}

int gd(int now,string t)
{	int l=t.size();
	for (int i=0;i<l;i++) now=((t[i]=='L')?p[now].ls:p[now].rs);
	return now;
}

int merge(int now,int cs,int sp)  //求并树 
{	
	if (!now) return cs;
	if (!cs) cs=++st; c[cs].sz=1;
	if (now==sp) return cs;
	c[cs].ls=merge(p[now].ls,c[cs].ls,sp); c[cs].sz+=c[c[cs].ls].sz;
	c[cs].rs=merge(p[now].rs,c[cs].rs,sp); c[cs].sz+=c[c[cs].rs].sz;
	return cs;
}

int find(string rep)
{
	int now=1,last=0;
	while (now){  //若now=0，则退出 
		last=now , now=gd(now,rep); 
		merge(last,1,now);
	}
	return c[1].sz;
}

void search(int now,string rep){  //找相对位置 
	int cnt=0;
	if (now==0) return;
	if (now!=1) {
		memset(c,0,sizeof(c)); st=1; cnt=find(rep);
		ans=min(ans,2*(cnt-1)-p[now].dd+1);
	}
	
	search(p[now].ls,rep+'L');
	search(p[now].rs,rep+'R');
}

int main()
{
	cin>>s; lq=s.size(); s='.'+s; 
	build(0,1);
	search(1,"");
	cout<<ans<<endl;
}

```

~~写题解比敲代码耗时长，困死了~~

---

## 作者：zhy137036 (赞：23)

不错的思维题。写了一下发现跑得还比较快，来写篇题解。

![](https://cdn.luogu.com.cn/upload/image_hosting/m2nj91de.png)

设运行第一遍指令后机器人走到的结点为 $u$。

因为当机器人在根节点处运行指令，机器人不会跑到根节点以上；所以当机器人在 $u$ 时再运行指令，机器人也不会跑到 $u$ 以上。

也就是说，第一遍运行指令的时候，就要把 $u$ 以外的宝藏（图中蓝色）全挖出来。

同理，以 $u$ 为结点再运行一遍指令，设机器人走到了 $v$。显然，$v$ 相对于 $u$ 的位置和 $u$ 相对于根的位置是一样的。

根据刚才的分析，这第二次运行指令，也要把 $u$ 子树里，$v$ 子树外的宝藏（图中红色）都挖掉。

以此类推，第三次运行指令要把绿色的宝藏都挖掉。

但是指令是不能变的。

所以要把图中蓝框、红框、绿框中的树叠加在一起。

![](https://cdn.luogu.com.cn/upload/image_hosting/udeg6nb9.png)

一次指令需要把整棵新树都遍历一遍，并停在黑色点上。

除了根到黑点之间这段路只用走一遍外，别的边都要走两边。这样都能算出指令的长度。

枚举 $u$，取指令最小值即可。

### 实现

实现并不很简单，而且我的实现比较短，所以讲一下。

因为计算指令长度时需要根到 $u$ 的距离，所以不妨用搜索枚举 $u$。

建新树时也搜索，需要同时保存在原树上的位置和在新树上的位置。  
如果原树的结点在新树上没有，新建新树结点即可。  
如果在新树上走到了黑点，就把新树上的位置挪到根。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int ls,rs;
}tre1[2010],tre2[2010];//原树，新树
int cnt1,cnt2,pos1,pos2,ans=1e9;//原树大小，新树大小，原树上 u 的位置，新树上黑点位置,ans
int input(){
	int c=getchar()-'0',u=++cnt1;
	if(c&1) tre1[u].ls=input();
	if(c&2) tre1[u].rs=input();
	return u;
}
void dfs2(int u,int v){//原树位置，新树位置
	if(u==pos1||v==pos2) { pos2=v; v=1; }//到了黑点
	if(tre1[u].ls){
		if(!tre2[v].ls) tre2[v].ls=++cnt2;//新建结点
		dfs2(tre1[u].ls,tre2[v].ls);
	}
	if(tre1[u].rs){
		if(!tre2[v].rs) tre2[v].rs=++cnt2;
		dfs2(tre1[u].rs,tre2[v].rs);
	}
}
void dfs1(int u,int dep){//dep 深度
	pos1=u;
	memset(tre2,0,sizeof tre2);//清空
	pos2=0;
	dfs2(1,cnt2=1);
	ans=min(ans,cnt2*2-2-dep);
	if(tre1[u].ls) dfs1(tre1[u].ls,dep+1);
	if(tre1[u].rs) dfs1(tre1[u].rs,dep+1);
}
int main(){
	input();
	dfs1(1,0);
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：rui_er (赞：11)

一道好题！挺对我脑回路的，于是秒掉了，来写个题解。

下文称执行一遍指令的过程为一个周期。例如指令是 `LRU`，那么 `LRULRULRULRU` 共执行了四个周期。

看到平方的数据范围，不难想到枚举第一个周期的终点。作为一台优秀的复读机，我们知道每个周期在树上发生的相对位移是相同的。

例如，如下的一棵树，如果第一周期从 $1$ 移动到 $4$，那么第二周期一定从 $4$ 移动到 $16$：

![](https://cdn.luogu.com.cn/upload/image_hosting/3d11pqj4.png)

同时，因为在根节点的 `U` 操作非法，假设一个周期从 $u$ 开始，那么途中一定一直在 $u$ 的子树内，不可能到 $u$ 上面。

依然假设第一周期从 $1$ 移动到 $4$，那么根据这一点，我们第一周期中必须把所有在 $1$ 子树内但不在 $4$ 子树内的节点访问一遍，也就是 $1,2,3,5,6$，并最终停在 $4$。同理，第二周期必须把 $4,8,9$ 访问一遍并停在 $16$，第三周期必须把 $16$ 访问一遍。

我们把 $(1,2,3,4,5,6),(4,8,9,16),(16)$ 三棵子树取一个并（如下图所示），其中每个周期要从绿色的点出发，经过所有粉色的点，最终到达蓝色的点。

![](https://cdn.luogu.com.cn/upload/image_hosting/firbwoy5.png)

显而易见地，最少需要的指令数为 $2(n-1)-\Delta d$，其中 $n$ 为这棵树中的点数，$\Delta d$ 是起点和终点之间的边数。上图给出了一种构造，即 `RLUULRUL`。

枚举第一个周期的终点，然后求出所有这样的子树的并，最后根据上面公式统计最优解即可。

时间复杂度 $\mathcal O(n^2)$。

```cpp
//By: OIer rui_er
#include <bits/stdc++.h>
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define per(x,y,z) for(int x=(y);x>=(z);x--)
#define debug(format...) fprintf(stderr, format)
#define fileIO(s) do{freopen(s".in","r",stdin);freopen(s".out","w",stdout);}while(false)
using namespace std;
typedef long long ll;

mt19937 rnd(std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::system_clock::now().time_since_epoch()).count());
int randint(int L, int R) {
    uniform_int_distribution<int> dist(L, R);
    return dist(rnd);
}

template<typename T> void chkmin(T& x, T y) {if(x > y) x = y;}
template<typename T> void chkmax(T& x, T y) {if(x < y) x = y;}

const int N = 2048;

struct BinaryTree {
    int lc[N], rc[N], sz, rt;
    BinaryTree() {
        memset(lc, 0, sizeof(lc));
        memset(rc, 0, sizeof(rc));
        sz = rt = 0;
    }
    int read() {
        int c = getchar() ^ 48, u = ++sz;
        if(c & 1) lc[u] = read();
        if(c & 2) rc[u] = read();
        return u;
    }
}T, TU; // original tree; the union of trees

void dfs_union(int u, int v, int root, int key) { // calculate the union
    if(u == root || v == key) {
        if(!key) key = v;
        v = TU.rt;
    }
    if(T.lc[u]) {
        if(!TU.lc[v]) TU.lc[v] = ++TU.sz;
        dfs_union(T.lc[u], TU.lc[v], root, key);
    }
    if(T.rc[u]) {
        if(!TU.rc[v]) TU.rc[v] = ++TU.sz;
        dfs_union(T.rc[u], TU.rc[v], root, key);
    }
}

int dfs_enum(int u, int d) { // enumerate the destination of round #1 moving
    TU = BinaryTree();
    TU.sz = TU.rt = 1;
    dfs_union(T.rt, TU.rt, u, 0);
    int ans = (TU.sz - 1) * 2 - d;
    if(T.lc[u]) chkmin(ans, dfs_enum(T.lc[u], d+1));
    if(T.rc[u]) chkmin(ans, dfs_enum(T.rc[u], d+1));
    return ans;
}

int main() {
    T.rt = T.read();
    printf("%d\n", dfs_enum(T.rt, 0));
    return 0;
}
```

---

## 作者：Cuxhin (赞：10)

# P5597 【XR-4】复读-详细推理题解
> 没什么写题解的经验被打回几次，辛苦管理了。
## 叠甲

蒟蒻第一篇紫题题解，想要让所有想做本题的人都能有所启发。本人还没有在大赛中拿过奖，而且算法，语言基础，数据结构掌握的知识有限，表述也很啰嗦。可能推理有错，或者打错字，程序也不够美观，请见谅喵。如果在评论区指出错误，提出批评建议就更加感谢了。

## 读题化简

给机器人一串指令，让他按指令行走。根据题目信息推理，我们可以首先可以得到几个性质

1. 机器人执行指令的**终点**肯定在**根节点以下**。如果去到根节点以上，则指令违法，去到根节点，则显然不是最优，多跑了一趟回根节点的路程
2. 机器人在一颗完全满的二叉树（本题解中简称为**背景二叉树**）上行走，则 **机器人行动路径的图像是一个二叉树**（本题解称为**子二叉树**）。
3. 机器人只会复读先前指令，则机器人到达终点接着走，会重复一遍先前路径的图像，即机器人走路可以理解为： **从一个终止点不断重复复制一个二叉树**。
4. 机器人最终目标是采集每一个宝藏，而宝藏的图像是在**背景二叉树上相同根节点的一个子树**（本题解中称为**宝藏二叉树**）。

通过以上性质，我们可以将问题从 得出最小指令 转换为 **求出最小子二叉树，使他以一个叶节点为锚点不断复制，图像最终可以覆盖宝藏二叉树**。然后基于问题再得出解决方案。

## 宝藏二叉树的构造 

本题输入的是宝藏二叉树的前序遍历（先序遍历），并且可以获知输入的节点有没有左右孩子。

先序遍历的顺序为中左右，即构造宝藏二叉树的递归顺序为：

1. 先读入当前节点。
2. 读入左子树。
3. 读入右子树。

## 子二叉树的构造

这是本题最难想的地方。本题最关键的地方在于复制，而复制意味着重复，意味着递归，这同样暗示我们化大为小。

围绕 **子二叉树复制后的图像覆盖宝藏二叉树** 思考。

第一次复制前，子二叉树以一个叶节点为锚点复制，不妨将这个节点称为子二叉树的**停止节点**。由该停止节点推出以下性质:

1. **该停止节点一定可以在宝藏二叉树上找到**，因为指令结束后到达停止节点，重复指令，就不会再回到停止节点之前的节点了，那么宝藏二叉树同层的节点肯定覆盖不到，除非同层没有其他节点了，那么如果停止节点也不在宝藏二叉树上，就已经走到了尽头。得知这个以后，我们可以在宝藏二叉树上以该停止节点为断点，将整个宝藏二叉树分开。
2. 由复制可以得到，**子二叉树复制后的停止节点和当前停止节点的位置差是一样的**。同时，子二叉树的复制只会将子二叉树的图像沿着一个方向不断扩展，不会回头。
3. 综合上述，我们可以得出**子二叉树需要覆盖宝藏二叉树从根节点到停止节点之间的节点**，即宝藏二叉树以停止节点为断点分开，子二叉树需要覆盖根节点到该断点的部分。因为子二叉树的复制不会再回头，如果错过了宝藏二叉树到停止节点之间任何一个节点，那么后面就不会再有机会得到该宝藏。

首先解决得到停止节点的问题。冥思苦想得不到好的确定停止节点的方式，那就采用最朴素最基本的遍历法。**通过递归以宝藏二叉树每一个节点作为停止节点，构造子二叉树，并且取其中最小二叉树**。

回到构造，复制后是什么情况呢？我们将刚才的推论推广，即**子二叉树复制后，需要覆盖宝藏二叉树从停止节点到下一个停止节点之间的节点**。

子二叉树复制后的图像跟子二叉树一样，我们可以将这种复制理解为**关联复制**。就像一堆积木搭成的结构，将这种结构摆很多个出来，在其中任意一个结构增添任意积木，其余结构的同样位置也需要增添相同的积木，这就是关联复制，在3D建模会有相关应用。

**子二叉树需要覆盖宝藏二叉树从根节点到停止节点之间的节点**，**不代表**子二叉树**只能覆盖**宝藏二叉树从根节点到停止节点之间的节点。**即子二叉树的结构不受限**，只需要满足覆盖宝藏二叉树从根节点到停止节点之间的节点就行，可以在覆盖的基础上有额外的节点。

将子二叉树的复制理解为关联复制后，结合子二叉树结构不受限的性质。我们就得出了完整的子二叉树构造方式，其实有点像动态规划，分割宝藏二叉树，然后以每一个部分为模版，从上到下逐步维护子二叉树，增添节点，最终形成的就是完整的子二叉树。

**取宝藏二叉树从根节点到停止节点之间的节点的部分，维护子二叉树，通过增添节点的方式使子二叉树可以覆盖这一部分。然后递归，取宝藏二叉树停止节点到下一个停止节点的部分，继续维护子二叉树，使子二叉树覆盖。**

为了方便理解这里给出图解（因为机房的鼠标太烂了尽力了）

![](https://cdn.luogu.com.cn/upload/image_hosting/0fkmvwsl.png)

**YUAN** 指代的是宝藏二叉树。

**FEN** 指代的是以第三个点为停止节点，然后分割后的宝藏二叉树，三种颜色代表分成的三个部分。

**ZI** 指代的是分别以三个部分为模版而不断修正而成的子二叉树，用紫线隔开。从上到下分别是以红色部分为模版而维护成的子二叉树，然后黄色部分添加一个节点，最后绿色部分节点添加了两个节点。绿色节点就是最后形成的子二叉树。

**FUZHI** 指代的是以子二叉树复制而成的图像，可以看到覆盖了宝藏二叉树，还覆盖了一些其他的点。

接下来，我们思考得出最小二叉树后，怎么得到指令长度。

## 子二叉树回溯到指令长度

得出子二叉树的大小后，我们就可以回推到指令长度了。对此，我们可以模拟下机器人走出子二叉树的最小轨迹。可以发现：

1. 机器人从根节点到停止节点之间的路径只走一次。
2. 其余的节点走到后还要回到根节点到停止节点之间的路径。
3. 根节点不走。

发现机器人的走法后，我们想到记录**停止节点到根节点的路径长度**，即停止节点的**深度**，将子二叉树大小乘二，每个点走两次，然后只需要走一次的点减去一次。而只需要走一次的点的个数刚好是深度的大小。最后再减去完全不用走的根节点。即 子二叉树 * 2 - 深度 - 1 * 2。

## 程序实现
迭代多次，修正 BUG 。最终实现如下。

1. 递归确定宝藏二叉树上的停止节点，同时记录深度。并新建子二叉树，子二叉树默认尺寸为1，包含根节点。
2. 将子二叉树与宝藏二叉树上的点一一对应，如果宝藏二叉树上有左或者右孩子而子二叉树没有，那么就新建相应的左右子节点，同时子二叉树的尺寸加一。然后递归往下遍历宝藏二叉树的节点。
3. 一开始**子二叉树与宝藏二叉树在背景二叉树上的位置是完全对应的**，根据这个，如果遍历到了宝藏二叉树的停止节点，那么也就找到子二叉树的停止节点。宝藏二叉树在背景二叉树上位置不用动，子二叉树对应的节点则回到根节点。此后，如果子二叉树遍历到了停止节点，则等效于根节点开始遍历。
4. 递归到尽头，得出子二叉树大小，代入公式求得指令长度，比较并取出所有指令长度最小值。

## 代码参考

个人采用指针构造树节点，并且渗透面向对象思想，完全封装成一个类来实现。

```cpp
//https://www.luogu.com.cn/problem/P5597
//Cuxhin、初心  
#include<bits/stdc++.h>//万能头。
#define INF 0x3fffff //指令的最大值。 
using namespace std; //使用标准命名空间。 
class Node{//定义节点类。
public: //公共。
	static Node *son_root,*dad_root,*son_end,*dad_end;
	//声明静态成员变量，分别为子树的根，宝藏树的根，子树停止位置，宝藏树停止位置。
	Node* l,*r;//左右孩子。
	Node(){} //空构造(习惯定义了有参构造后顺手写一个）。
	Node(bool b){//有参构造 。
		if(b){//b代表是否是宝藏树，需要手动读入。 
			//满足先序遍历的顺序，中左右 。
			char c=getchar();
			switch(c){ 
				case '0':{l=nullptr;r=nullptr;break;}//无左右。
				case '1':{l=new Node(1);r=nullptr;break;}//有左无右。
				case '2':{l=nullptr;r=new Node(1);break;}//有右无左。
				case '3':{l=new Node(1);r=new Node(1);break;}//左右都有，先左后右。
			}	
		}
		else{l=nullptr;r=nullptr;}//b为false用来构建子树 。
	}
	
	void print(){//调试用的打印，顺手写一个调试有大用。 
		if(l!=nullptr and r!=nullptr){//左右都有。 
			cout<<"L+R"<<endl;
			l->print();
			r->print();	
		}
		else if(l!=nullptr and r==nullptr){//只有左 。
			cout<<"L"<<endl;
			l->print();
		}
		else if(l==nullptr and r!=nullptr){//只有右 。
			cout<<"R"<<endl;
			r->print();	
		}
		else if(l==nullptr and r==nullptr){//左右为空。 
			cout<<"N"<<endl;
		}
	}	
	//宝藏树需要用到的成员函数。
	int solve(int deep){//以当前节点为停止节点，构造子二叉树并递归子节点。
		int ans=INF; //ans存储最小值，范围一定要尽量大而不是n的范围，特别注意。
//		cout<<deep<<endl<<endl; 调试语句。 
		ans=build_treeson()*2-2-deep;//构建子树并根据深度求出指令长度。
		//分别左右递归，深度加一。
		if(l!=nullptr) ans=min(ans,l->solve(deep+1));
		if(r!=nullptr) ans=min(ans,r->solve(deep+1));
		return ans;//返回值为最小指令。
	}
	int build_treeson(){//构造子二叉树。
		//初始化 。
		son_root = new Node(0);//新建子树。 
		son_end = nullptr;//子树停止的位置还不确定。 
		dad_end = this;//宝藏树停止位置 。
		int tmp=son_root->check(dad_root)+1;//构建子树并临时存储，+1是子树根节点。
//		son_root->print(); 
		delete son_root;//手动释放好习惯。
		return tmp;//返回值为子树大小。
	}
	//子树需要用到的成员函数，check是重难点。调用check函数的对象为子二叉树，this指向子二叉树对应节点。
	int check(Node* dad_point){//检查子二叉树上的节点与宝藏二叉树的节点，二者左右孩子是否对应，并新建节点维护。
		int tmp=0;//临时存储子树大小。
		if(dad_point->l!=nullptr){//宝藏树有左孩子。 
			if(this->l==nullptr){//如果子树对应宝藏树左孩子的位置没有节点。
				this->l = new Node(0);//新建子树的左孩子 。
				if(dad_point->l == dad_end) son_end=this->l;//如果新建的左孩子刚好是宝藏树停止点，则保存为子树停止点 。
				tmp++;//大小加一 
			}
			if(this->l==son_end) tmp+=son_root->check(dad_point->l);//如果走到了子树停止点，则等效于从子树根节点开始走，回溯 。
			else tmp+=this->l->check(dad_point->l);//否则就接着往下走 。
		}
		if(dad_point->r!=nullptr){//宝藏树有右孩子。
			if(this->r==nullptr){//如果子树对应宝藏树右孩子的位置没有节点 。
				this->r = new Node(0);//新建子树的左孩子。
				if(dad_point->r == dad_end) son_end=this->r;//如果新建的左孩子刚好是宝藏树停止点，则保存为子树停止点。
				tmp++;//大小加一。
			}
			if(this->r==son_end) tmp+=son_root->check(dad_point->r);//如果走到了子树停止点，则等效于从子树根节点开始走。 
			else tmp+=this->r->check(dad_point->r);//否则就接着往下走。
		}
		return tmp;//返回值为子树大小（或者子树的子树大小）。
	}
	~Node(){//递归析构函数。
		if(this->l!=nullptr) delete l;//有左删左。 
		if(this->r!=nullptr) delete r;//有右删右。 
	}
};
//定义静态成员变量。
Node* Node::son_root;
Node* Node::dad_root;
Node* Node::dad_end;
Node* Node::son_end;
int main(){
	Node::dad_root=new Node(1); //传入1，手动构造宝藏树。
//	Node::dad_root->print(); 调试 。
	cout<<Node::dad_root->solve(0);//从根节点开始，输出最小步数 。
	delete Node::dad_root;//释放 。
	return 0;//剧终 。
}
```


## 心得体会

本题是个人第一道紫题，觉得有所启发，就写了题解记录。本题锻炼了我对于问题的解析能力，得出正确思路逐步推导的过程中也提升了我的逻辑能力，程序实现上又锻炼了我对面向对象的使用。在刚开始码程序时出现很多问题，像是没有大括号导致 if else 后只执行了一句话，然后宝藏二叉树怎么都读不了右节点；以为最小指令长度就是宝藏二叉树最大节点数导致错了几个点；实现 check 函数时将 dad_point 设置成静态变量然后久久无法对应正确节点。迭代过程也提升了我的调试能力。回过头看，做的还是很开心的，学到了很多东西。

不管紫题黑题，其实都不用怕。题目复杂，看不懂，就逐步提取有效信息，概括性质，然后将大化小，八方联系，总能解决的。心态是最重要的，一定要有耐心。

最后要养成顺手写调试函数的习惯，同时定义初始值不要过小。

就到这了，谢谢观看。

---

## 作者：_louhc (赞：5)

一道有趣的题2333.

## 思路

首先,指令循环一次后,出发点和结束点相对位置都是相同的.也就是说如果一次指令后到根的左儿子的右儿子,第二次指令就到根的左儿子的右儿子的左儿子的右儿子,第三次就到根的左儿子的右儿子的左儿子的右儿子的左儿子的右儿子...  
我们可以YY一下,第一次指令结束后肯定在有宝藏的地方.因为所有有宝藏的地方构成一棵树,没有宝藏的地方再怎么向下延伸都不会有宝藏.  
数据范围还是比较友好的,只有$2000$,我们很容易想到$O(N^2)$的暴力.于是我们先枚举第一次指令后到达的节点.   
先来看张图(灰色节点代表根节点以及每次指令结束后所处的节点):  
![](https://cdn.luogu.com.cn/upload/image_hosting/3rq7kwrq.png)    
很明显的一点是,每次指令后都不可能返回祖先节点了.也就是说,到下一个灰色点之前必须先把上面部分全部访问完,否则就不可能回去了.  
我们必须找到一个指令集,能把被灰色点分开的连通块内所有的节点都访问.  
再来张图:  
![](https://cdn.luogu.com.cn/upload/image_hosting/rr72auia.png)  
我们把被灰色点分开的连通块(很明显是树)取出来(灰色点同属于两个连通块),然后把这些树"合并"起来.你可以在一些透明纸上画出这些树,然后把这些透明纸叠起来(注意这些树的根节点重合,根节点左儿子重合,根节点右儿子重合),然后你从上面看到的树就要"合并"的结果.  
容易发现,遍历这棵树(最终停在下一个灰色点)的指令集就是要求的答案.  
设这棵"合并树"含$size$个节点,根节点到下一个灰色点的最短路径是$d$,指令集的长度就是$2\times(size-1)-d$.  
因为求"合并树"时每个节点仅访问一次,求一次"合并树"的复杂度是$O(N)$的.  
加上枚举下一个灰色点,总复杂度是$O(N^2)$的.  
具体实现细节请参考代码.

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define fp( i, b, e ) for ( int i(b), I(e); i <= I; ++i )
template<typename T> inline bool cmin( T &x, T y ){ return y < x ? x = y, 1 : 0; }

const int MAXN = 2e3 + 15;
struct node{ int ls, rs; }o[MAXN], p[MAXN];
int ans(1e9), tmp, n, cnt, cur; char s[MAXN];

void Build( int &c ){ // 构建出题目给出有宝藏的节点构成的树
	if ( !c ) c = ++cnt;
	char t(s[n++]);
	if ( t & 1 ) Build(o[c].ls);
	if ( t & 2 ) Build(o[c].rs);
}
void Merge( int &c, int l ){ // "合并"过程
	if ( !c ) c = ++cnt;
	if ( l == cur ) return;
	if ( o[l].ls ) Merge(p[c].ls, o[l].ls);
	if ( o[l].rs ) Merge(p[c].rs, o[l].rs);
}

char pth[MAXN];
void Work( int c, int stp ){ //枚举灰色点的过程
	if ( c != 1 ){
		memset( p, 0, sizeof p ), cnt = cur = 1;
		while( cur ){
			const int t(cur);
			fp( i, 0, stp - 1 ) cur = pth[i] == 'L' ? o[cur].ls : o[cur].rs; // 找下一个灰色点
			Merge(tmp = 1, t);
		} cmin( ans, (cnt - 1) * 2 - stp ); // 答案取最小值
	}
	pth[stp] = 'L';
	if ( o[c].ls ) Work(o[c].ls, stp + 1);
	pth[stp] = 'R';
	if ( o[c].rs ) Work(o[c].rs, stp + 1);
}


signed main(){
	scanf( "%s", s ), n = 0, cnt = 1;
	Build(tmp = 1), Work(1, 0);
	printf( "%d\n", ans );
	return 0;
}
```

---

## 作者：ncwzdlsd (赞：3)

考虑对于每一个操作单元，它只能走到结束位置向下的节点，因此我们可以考虑分离每一次操作单元。由于前面所说的移动性质，我们必须要让机器人在某次复读操作到达 $u$ 之前把 $u$ 以上的所有宝藏挖出来。

对于每一个操作单元，我们可以把它们的起点合并，组合成一棵新树。对于这棵新树，我们需要从原根节点开始，到在原树中最后一次复读操作之后停止的节点结束，这些步骤需要一次指令完成。

考虑这一次指令的长度。除了停止节点到根节点的路径只走了一次以外，其余的每一条路径都走了两遍，因此总长度为 $(siz_2-1)\times 2-dep_2$。

对于每种指令，暴力枚举截止位置即可。

二叉树题写代码时注意不要把左右儿子搞混了！

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

const int maxn=2005; 
int siz1,siz2,p1,p2,ans=0x3f3f3f;

struct node{int ls,rs;}t1[maxn],t2[maxn]/*原、新*/;

int input()
{
	int tmp=getchar()-'0',gg=++siz1;
	if(tmp==1||tmp==3) t1[gg].ls=input();
	if(tmp==2||tmp==3) t1[gg].rs=input();
	// cout<<gg<<endl;
	return gg;
}

void dfs(int p,int q)
{
	if(p==p1||q==p2) p2=q,q=1;
	if(t1[p].ls)
	{
		if(!t2[q].ls) t2[q].ls=++siz2;
		// cout<<siz2<<"qwq"<<endl;
		dfs(t1[p].ls,t2[q].ls);
	}
	if(t1[p].rs)
	{
		if(!t2[q].rs) t2[q].rs=++siz2;
		// cout<<siz2<<"qwq"<<endl;
		dfs(t1[p].rs,t2[q].rs);
	}
}

void calc(int u,int dep)
{
	p1=u,p2=0,siz2=1;
	memset(t2,0,sizeof t2);
	dfs(1,siz2);
	ans=min(ans,(siz2-1)*2-dep);
	// cout<<ans<<endl;
	if(t1[u].ls) calc(t1[u].ls,dep+1);
	if(t1[u].rs) calc(t1[u].rs,dep+1);
}

signed main()
{
	input();
	calc(1,0);
	cout<<ans;
	return 0;
}
```

---

## 作者：Sol1 (赞：3)

还蛮有趣的题，难度不大（~~评分是不是有点高啊~~

首先考虑这个指令运行之后会发生什么。不难发现，指令运行一次之后肯定机器人会向下走若干步，肯定不会向上走。我们不妨枚举这个机器人在指令运行完之后会走到哪个点上。

然后可以发现，对于枚举到的这个点（不妨称其为终点 1）到根的链上支出去的子树就一定没有机会在第一次运行之后访问到了。所以我们需要保证这些子树一定在第一次运行指令的过程中遍历到。

更进一步的，假设运行两次指令会使得机器人到达终点 2，那么终点 1 到终点 2 上分支出去的子树也必须在一次运行指令中被遍历到；运行三次指令会使得机器人到达终点 3，那么终点 2 到终点 3 上分支出去的子树也必须在一次运行指令中被遍历到，以此类推。

那么对于这个指令的要求是什么？不难发现形式上类似于按照终点来进行切割。规定根节点为终点 0，设 $T_i$ 为终点 $i$ 的子树去掉终点 $i+1$ 的子树里面除去终点 $i+1$ 以外的所有点形成的以终点 $i$ 为根的树，那么这条指令必须要遍历所有 $T_{[0,+\infty)}$ 的并，且最终落到终点 1 的位置。

于是我们直接暴力求出并（这一步只需要遍历每一个点一次，是 $O(n)$ 的），假设它有 $n$ 个点，终点 1 的深度为 $k$，那么除了根到终点 1 的路径上的边只需要遍历一次之外，剩下的边都需要遍历两次，所以此时最小指令长度是 $2(n-1)-k$。

所以对于一个固定的终点 1，可以 $O(n)$ 计算答案。再结合 $O(n)$ 暴力枚举终点 1，就得到了 $O(n^2)$ 的算法，足以通过本题。

由于需要知道路径，所以更好写的实现方法是 dfs 枚举终点 1。不过不管怎么样这题都不难写啦。

```cpp
int top1, top2, ls1[2005], rs1[2005], ls2[10005], rs2[10005], stk[10005], stktop, ans;

inline void Read(int x) {
	char c;
	cin >> c;
	if (c == '1') Read(ls1[x] = ++top1);
	else if (c == '2') Read(rs1[x] = ++top1);
	else if (c == '3') {
		Read(ls1[x] = ++top1);
		Read(rs1[x] = ++top1);
	}
}

inline void Dfs2(int u, int &x) {
	if (!u) return;
	if (!x) x = ++top2;
	if (ls1[u]) Dfs2(ls1[u], ls2[x]);
	if (rs1[u]) Dfs2(rs1[u], rs2[x]);
}

inline void BuildT(int rt) {
	int p = 1;
	for (int i = 1;i <= stktop;i++) {
		if (!rt) return;
		if (stk[i]) {
			Dfs2(ls1[rt], ls2[p]);
			if (!rs2[p]) rs2[p] = ++top2;
			p = rs2[p];
			rt = rs1[rt];
		} else {
			Dfs2(rs1[rt], rs2[p]);
			if (!ls2[p]) ls2[p] = ++top2;
			p = ls2[p];
			rt = ls1[rt];
		}
	}
	BuildT(rt);
}

inline void Dfs1(int u) {
	if (u != 1) {
		top2 = 1;
		memset(ls2, 0, sizeof(ls2));
		memset(rs2, 0, sizeof(rs2));
		BuildT(1);
		ans = min(ans, 2 * top2 - 2 - stktop);
	}
	if (ls1[u]) {
		stk[++stktop] = 0;
		Dfs1(ls1[u]);
		stktop--;
	}
	if (rs1[u]) {
		stk[++stktop] = 1;
		Dfs1(rs1[u]);
		stktop--;
	}
}
```

---

## 作者：Cocoly1990 (赞：2)

这是一道好题。说实话思路并不好想。
****
先口胡一个东西，就是如果在一次循环**结束**之后**离开了染色子树**但**没有完成对染色子树的遍历**，这种命令是不可行的。

来个证明，因为在根节点处不能向上，所以机器人的**整体运动趋势肯定是远离根节点**的。

这个结论还有一个推论，就是某次循环完后到达节点 $x$，那么**染色树中非 $x$ 子树的必须完成遍历**。这个其实也很好理解。

还有一个重要的结论就是每次机器人循环开始的起点和终点**相对位置不变**。

于此我们可以画出一张图，其中红色的表示每次循环开始的起点终点。

![4ygOdH.png](https://z3.ax1x.com/2021/09/26/4ygOdH.png)

这样我们就可以开始着手设计循环了。

首先起点终点的相对位置不变，而且二叉树无限大，所以我们可以试着在每次循环内把所有的不同的情况都遍历掉。

什么意思呢，我们要在一次循环内把下图中绿圈圈起的三个部分遍历完

![4yRIKK.png](https://z3.ax1x.com/2021/09/26/4yRIKK.png)

考虑合并这三个部分。

![4y5ATU.png](https://z3.ax1x.com/2021/09/26/4y5ATU.png)

显然除了合并，我们还要到达下次开始的节点，也就是图中左下角的节点。

考虑一下每次命令需要的长度，显然最优的情况是红点到红点之间的链只走一次，其他走两次。

那么 $\texttt{ans}=\left(\texttt{size}-1\right)\times2-\texttt{dep}$.其中 $\texttt{size},\texttt{dep}$ 分别表示这棵树的大小和红点间的距离。

至于怎么寻找红点，考虑暴力枚举。

综合时间复杂度 $\mathcal{O}\left(n^2\right)$.

最后做一个提醒，递归建树的时候切记不可开全局变量！！！

需要代码的私信找我要。



---

## 作者：OIer_ACMer (赞：2)

~~一道含水的题。~~

------------
第一眼看到紫色标识时，先是一惊，在看了看题面，学了学[题解](https://www.cnblogs.com/youth518/p/13850918.html)之后，~~建议降蓝~~。

------------
## 大致思路：
这道题作为一道洛谷月赛题，确实可以难倒不少人~~比如当年的我~~，但时过境迁，如今，这道题的难度已经显然没那么高。

题目主要讲了根据一个只包含 $0$、$1$、$2$、$3$ 的序列构造出一颗**完全二叉树**，记住，是**完全二叉树**。这说明这道题搜索肯定有些行不通，因为时间复杂度太高~~你说你会别的优化算法当我没说~~。接着给你个机器人，按照重复的指令在树上前行，但是，要求是如果**走着走着走到了根节点**，由于复读机的性质**再往前走就会离开二叉树**，因此将这种情况判定为**违规**，因此在构造序列时就提前处理出这种情况。

首先，就是**建树**，由于题目给出的是一段前序遍历，所以我们可以先件根节点再建左右儿子节点（根左右），在代码中体现就是先定一个 $t$ 变量**记录序列当前位置的数字是什么**，如果可以和 $1$ 按位与的结果为 $1$，说明只有左儿子，向左儿子递归，如果可以和 $2$ 按位与这说明有右儿子，向右儿子递归，如果两者都有，则都递归（用两个并列的 if 判断就可以实现）。

接着，有了这棵树，我们就可以开始构建指令序列，**由于这是一颗无限大的二叉树**，所以不合法的方案**仅存在于跳到根节点的父亲这一种，且由于指令会无限重复**，所以我们必须保证指令会**使得离开被标记的子树的时候，所有被标记的点已经全部访问完**，因为我们不会折返回去向上跳的。

规则知道了，我们开始考虑**枚举它是经过哪条路**径，从**哪个点离开整颗子树**的，只要保证**在走这条路经的同时遍历完所有的点**，且由于指令会**无限重复**，所以我们对于路径上每一个点，将**所有的子树求一个形态上的并集**，只要**使得整个并集能被访问**，那么所有的点都会被访问到。

在代码中，我们定义 $dep$ 为深度变量，$u$ 为此时到达的节点编号，如果 $u$ 不为 $1$，也就是不是根节点，就做以下操作：

1. 定义 $cur$ 数组为目前的遍历节点暂存变量，$cnt$ 是并集的树上节点数。

2. 做 while 循环，条件是 $cur$ 不为 $0$。

3. 枚举从 $1$ 到 $dep$ 各个深度，依次判断此时 $pth$ 里原先储存好的操作符是什么，将 $cur$ 赋值为该操作符所指定的接下来的遍历节点。

4. 枚举完后，将现在的遍历节点和原来的合并起来，成为一个新的并集。

5. while 循环结束后，计算 $ans$ 的值，根据前面的讲解，最后的答案是 $(cnt - 1) \times 2 + dep$。

6. 最终，我们记录答案，并进行下一层递归。


------------
## 代码如下：

```c++
#include <bits/stdc++.h>
using namespace std;
const int maxn = 2e3 + 5;
int ans = 1e9 + 7, cnt, cur, rt, pos;
char s[maxn], pth[maxn];
struct tree
{
    int lson, rson;
} tree[maxn], g[maxn];
void build(int &x)
{
    if (!x)
    {
        x = ++cnt;
    }
    int t = s[pos++] - '0';
    if (t & 1)
    {
        build(tree[x].lson);
    }
    if (t & 2)
    {
        build(tree[x].rson);
    }
}
void merge(int &x, int y)
{
    if (!x)
    {
        x = ++cnt;
    }
    if (y == cur)
    {
        return;
    }
    if (tree[y].lson)
    {
        merge(g[x].lson, tree[y].lson);
    }
    if (tree[y].rson)
    {
        merge(g[x].rson, tree[y].rson);
    }
}
void solve(int u, int dep)
{
    if (u != 1)
    {
        memset(g, 0, sizeof(g));
        cur = cnt = 1;
        while (cur)
        {
            const int t = cur;
            for (int i = 0; i < dep; i++)
            {
                cur = pth[i] == 'l' ? tree[cur].lson : tree[cur].rson;
            }
            merge(rt = 1, t);
        }
        ans = min(ans, (cnt - 1) * 2 - dep);
    }
    pth[dep] = 'l';
    if (tree[u].lson)
    {
        solve(tree[u].lson, dep + 1);
    }
    pth[dep] = 'r';
    if (tree[u].rson)
    {
        solve(tree[u].rson, dep + 1);
    }
}
int main()
{
    cin >> s;
    pos = 0;
    cnt = 1;
    build(rt = 1);
    solve(1, 0);
    cout << ans;
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/121345519)

---

## 作者：Coros_Trusds (赞：2)

[更好的阅读体验](https://www.cnblogs.com/Coros-Trusds/p/15664901.html)

# 题目大意

小 X 捡到了一台复读机，这台复读机可以向机器人发号施令。机器人将站在一棵完全二叉树的根上，完全二叉树是无限延伸的。你将向复读机录入一串指令，这串指令单个字符可以是：

* `L`：命令机器人向当前节点的左子走；
* `R`：命令机器人向当前节点的右子走；
* `U`：命令机器人向当前节点的父亲走（若没有，则命令非法）。

录入指令后，复读机将会把指令无限复读下去。比如命令为 `LR`，那么机器人会遵从 `LRLRLRLR...` 一直走下去。

这棵完全二叉树上有一个 $n$ 个节点的连通块，保证这个连通块包含根节点。连通块上的每个节点都埋有宝藏，机器人到达过的地方如果有宝藏，则会将其开采。如果一个地方没有宝藏，机器人也可以到那里去。机器人也可以反复经过一个地方。

显然，这个连通块本身也是一棵二叉树。

现在，有人告诉了小 X 埋有宝藏的这棵二叉树的前序遍历，小 X 需要寻找到一条尽量短的指令，使得机器人能够挖掘出所有宝藏。

# 题目分析

发现读入按照前序遍历读入不是非常方便，这里单独考虑一下。

首先自然要给当前节点赋一个编号的。

若当前数字为 $1$ 或 $3$，那么递归进入左子树；

若当前数字为 $2$ 或 $3$，那么递归进入右子树。

代码如下：

```cpp
inline int input()
{
	int ch=getchar()-'0',p=++ia;
	
	if(ch==1 || ch==3)
	{
		node1[p].ls=input();
	}
	
	if(ch==2 || ch==3)
	{
		node1[p].rs=input();
	}
	
	return p;
}

in function "main()":
	input();
```

-----

可以发现，进行一次指令之后，我们必然应该将该节点的祖先节点的宝藏全部取走。

设一次指令后我们走到了 $u$ 点，再执行一次指令后又走到了 $v$ 点。

那么在 $u$ 的父子树中经过的路径必然和 $v$ 和 $u$ 之间经过的路径一致，为了得到这个最短路径，我们将宝藏树中 $u$ 的父子树与 $v$ 和 $u$ 之间的子树拼在一起，依次类推，最后就能够得到正确的路径了。

如何求出这条指令的长度呢？

每条边一定会经过两次，边有 $num-1$ 条，所以是 $(num-1)\times 2$。

是这样吗？可以发现，从拼接树的根到当前循环节的末尾节点只会走一次，所以还需要减去这一段的长度——自然就是节点个数（也就是节点深度） $present\_depth-1$。

很简单，可以发现长度就是 $(num-1)\times 2-(present\_depth-1)$，$num$ 表示拼接出来的子树的节点个数，$present\_depth$ 表示当前枚举的 $u$ 节点的深度。

# 代码

```cpp
//2021/12/8

#define _CRT_SECURE_NO_WARNINGS

#include <iostream>

#include <cstdio>

#include <climits>//need "INT_MAX","INT_MIN"

#include <cstring>

#define enter() putchar(10)

#define debug(c,que) cerr<<#c<<" = "<<c<<que

#define cek(c) puts(c)

#define blow(arr,st,ed,w) for(register int i=(st);i<=(ed);i++)cout<<arr[i]<<w;

#define speed_up() cin.tie(0),cout.tie(0)

#define endl "\n"

#define Input_Int(n,a) for(register int i=1;i<=n;i++)scanf("%d",a+i);

#define Input_Long(n,a) for(register long long i=1;i<=n;i++)scanf("%lld",a+i);

#define mst(a,k) memset(a,k,sizeof(a))

namespace Newstd
{
	inline int read()
	{
		int x=0,k=1;
		char ch=getchar();
		while(ch<'0' || ch>'9')
		{
			if(ch=='-')
			{
				k=-1;
			}
			ch=getchar();
		}
		while(ch>='0' && ch<='9')
		{
			x=(x<<1)+(x<<3)+ch-'0';
			ch=getchar();
		}
		return x*k;
	}
	inline void write(int x)
	{
		if(x<0)
		{
			putchar('-');
			x=-x;
		}
		if(x>9)
		{
			write(x/10);
		}
		putchar(x%10+'0');
	}
}

using namespace Newstd;

using namespace std;

const int INF=INT_MAX;

const int ma=2005;

struct Node
{
	int ls;
	
	int rs;
};

Node node1[ma],node2[ma];

//下面代码中"新树"即"拼接树"qwq 
int ia,ib;//原树大小,新树大小

int pos1,pos2;//原树上 u 的位置,拼接树上末尾节点的位置 

int ans;

inline int input()
{
	int ch=getchar()-'0',p=++ia;
	
	if(ch==1 || ch==3)
	{
		node1[p].ls=input();
	}
	
	if(ch==2 || ch==3)
	{
		node1[p].rs=input();
	}
	
	return p;
}

inline void init()
{
	mst(node2,0);
	
	ib=1;
}

inline void dfs2(int u,int v)//原树位置,新树位置
{
	if(u==pos1 || v==pos2)//到达循环节的末尾节点 
	{
		pos2=v;
		
		v=1;
	}
	
	if(node1[u].ls!=0)
	{
		if(node2[v].ls==0)
		{
			node2[v].ls=++ib;
		} 
		
		dfs2(node1[u].ls,node2[v].ls);
	}
	
	if(node1[u].rs!=0)
	{
		if(node2[v].rs==0)
		{
			node2[v].rs=++ib;
		}
		
		dfs2(node1[u].rs,node2[v].rs);
	}
}

inline void dfs1(int u,int depth)
{
	init();
	
	pos1=u,pos2=0;
	
	dfs2(1,1);
	
	ans=min(ans,(ib-1)*2-(depth-1));
	
	if(node1[u].ls!=0)
	{
		dfs1(node1[u].ls,depth+1);
	}
	
	if(node1[u].rs!=0)
	{
		dfs1(node1[u].rs,depth+1);
	}
}

int main(void)
{
	ans=INF;
	
	input();
	
	dfs1(1,1);
	
	printf("%d\n",ans);
	
	return 0;
}
```

---

## 作者：Xuan_qwq (赞：1)

给定一颗无限大的满二叉树 $E$ 和一颗由该树去掉若干子树后得到的一颗二叉树 $G$，找一个最短遍历路径 $S$，使得无限次重复这一遍历路径可以遍历完给定的有限二叉树上的节点。

遍历路径不得在根节点向父亲遍历。

---

我们考虑在经过一次 $S$ 后到达的节点 $u$，由于在 $S$ 中不会出现从根节点向父亲的遍历，所以接下来遍历到的节点均在 $u$ 的子树中。

所以在这一次遍历中，除去 $u$ 的子树，$G$ 中剩下的节点都要被遍历到。

然后我们不断重复这一相对位移（即寻找下一个 $u$ 子树内的节点 $v$，使得 $1\to u$ 的最短路径和 $u\to v$ 的最短路径上，每个节点走向左或右儿子的选择相同），直到找到的节点 $v'\notin G$ 为止。

对于每一次循环，我们将 $G$ 中当前根节点 $u$ 的子树中去掉目标节点 $v$ 得到的树记作 $G_u'$，那么我们的方案 $S$ 应该可以遍历到所有的 $G_u'$。接下来考虑如何构造 $S$。

我们可以将所有 $G_u'$ 的根节点重叠起来，就像这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/wjxus3sp.png)

重叠完后就变成了：

![](https://cdn.luogu.com.cn/upload/image_hosting/xx52n76q.png)

我们将所有的 $G_u'$ 如上图像线段树合并一样合并起来，得到最终的一颗二叉树 $G'$，那么我们的 $S$ 只需要从根节点遍历完 $G'$，并且最终到达 $u$ 就可以了。

设这颗二叉树拥有 $siz$ 个节点，从根节点到目标节点的简单路径 $T$ （不含根节点）上的节点数为 $l$，考虑为什么答案是 $2\times(siz-1)-l$。

我们对于不在 $T$ 上的每个节点 $x$，都有从其父亲 $fx$ 到达 $x$ 和从 $x$ 到 $fx$ 的两次访问。而对于 $T$ 上的每个节点 $y$，只有其父亲 $fy$ 到达 $y$ 的一次访问（因为我们不需要返回去）。而根节点没有父亲，所以两次访问都没有。

然后枚举 $G$ 中目标节点复杂度是 $O(n)$ 的，合并二叉树复杂度也是 $O(n)$ 的，总复杂度 $O(n^2)$，足以通过本题。

别的大佬写的代码已经很清楚了，蒟蒻就不在这里放代码了。

---

## 作者：Bitaro (赞：1)

观察可得复读序列具有以下性质：

> 每次复读终点距离起点相对位置不变

这很好证，因为每次我们都能执行完复读序列，所以最终走到的地方距离起点相对位置肯定一样。

我们首先尝试构建一个合法的复读序列，使其能遍历整棵树。

这个复读序列需要满足以下条件：

1. 从根开始，执行复读序列后终点不能为根。否则复读序列不能向下走（这里我们忽略遍历整棵树后回到根的情况，因为这肯定不优）。

2. 从当前点走到复读终点的所有节点，如果其有两个儿子，其另一个儿子及其子树必须在复读序列中被遍历过。因为根据条件一，我们不会走回头路。

对于条件二，我们有疑问：为什么我们不能在中途向上走走到起点的父亲处，然后将其子树里未遍历的节点遍历呢？因为我们会在根节点执行一次复读序列，而根节点处是不能向上走的。

然后我们发现，为了满足条件二，我们实际上遍历序列是一棵子树，其形态为每次经过的必经点的并。下图是一个例子，其中规定从根开始终点为 $2$，不同颜色代表着每一次复读对应的子树。

![](https://cdn.luogu.com.cn/upload/image_hosting/ffguow5t.png)

我们尝试计算这颗树的对应遍历序列的长度。显然这个长度只与我们提取出的子树有关。如果子树大小为 $tot$，那么我们除了到终点那一条长度为 $len$ 的链，其他边都要经过两次（去一次，回来一次）。于是为 $2\times (tot-1)-len$。

既然复读序列只与终点有关，我们当然可以枚举终点，然后 $O(n)$ 处理整棵树。时间复杂度为 $O(n^2)$，可以通过此题。

```cpp
/*
slow is fast
*/
#include<bits/stdc++.h>
#define pre(i,a,b) for(int i=a;i<=b;++i)
#define suf(i,a,b) for(int i=a;i>=b;--i)
#define ll long long
#define pii pair<int,int>
using namespace std;
const int N=1e5+6,p=1e9+7;
namespace Y {
string str,tmp;
int n,a[N][2],fa[N],s[N][2],sz[N],now[N],tr[N][2];
int tot=0;
void huo(int u,int &w,int fin) {
  if(w==0) w=++tot;
  if(u==fin) return ;
  if(s[u][0]) huo(s[u][0],tr[w][0],fin);
  if(s[u][1]) huo(s[u][1],tr[w][1],fin);
}
void MAIN() {
  cin>>str;
  n=str.size();
  int u=1,cnt=1;
  pre(i,0,n-1) {
    if(str[i]=='0') {
      u=fa[u];
      while(now[u]==sz[u]-1) {
        now[u]++;
        u=fa[u];
      };
      if(i!=n-1) assert(s[u][1]);
      now[u]++;
      u=s[u][1];
    } else if(str[i]=='1') {
      sz[u]=1;
      s[u][0]=++cnt;
      fa[cnt]=u;
      u=s[u][0];
    } else if(str[i]=='2') {
      sz[u]=1;
      s[u][1]=++cnt;
      fa[cnt]=u;
      u=s[u][1];
    } else {
      sz[u]=2;
      s[u][0]=++cnt;
      fa[cnt]=u;
      s[u][1]=++cnt;
      fa[cnt]=u;
      u=s[u][0];
    }
  }
  int ans=2e9;
  pre(i,2,n) {
    int u=i,cnt=0,fin;
    memset(tr,0,sizeof tr);
    tot=0;
    vector<int> tmp;
    while(u!=1) {
      if(s[fa[u]][0]==u) tmp.push_back(0);
      else tmp.push_back(1);
      u=fa[u],++cnt;
    }
    reverse(tmp.begin(),tmp.end());
    u=fin=1;
    int rt=0;
    while(u) {
      fin=u;
      for(auto to:tmp) fin=s[fin][to];
      huo(u,rt,fin);
      u=fin;
    }
    int now=((tot-1)*2)-tmp.size();
    ans=min(ans,now);
  }
  cout<<ans<<endl;
}
};//namespace Y
signed main() {
  auto I=freopen("text.in","r",stdin);
  auto O=freopen("text.out","w",stdout);
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	int T=1;
	while(T--) Y::MAIN();
	return 0;
}
```


---

## 作者：dengjunhaodejia09 (赞：0)

这道题首先我先上来认为是对不断走左端点组成的链和右端点组成的链每次走另一个儿子，在求并判合法。但到了链的最后一个时会转弯，便是不好处理。


看了题解，发现是当每次操作的最后一个点已经是出去了，之后就都出去了。那我们枚举操作后的最后一点，那么上一个最后一点且不包含当前节点的子树的子树就要在一次操作中遍历到，那么取一个子树并即可。复杂度由于子树并单次最多每个节点并一次，所以是 $n$ 的平方的。


```cpp
#include <bits/stdc++.h>
using namespace std;
int l[3005],r[3005],dep[3005],cnta;
string ss;
vector<int> g[3005];
void dfs(int &id){
    id=++cnta;
    if(ss[id]=='1'){
        dfs(l[id]);
    }
    if(ss[id]=='2'){
        dfs(r[id]);
    }
    if(ss[id]=='3'){
        dfs(l[id]);
        dfs(r[id]);
    }
    if(l[id]){
        g[id].push_back(l[id]);
        g[l[id]].push_back(id);
    }
    if(r[id]){
        g[id].push_back(r[id]);
        g[r[id]].push_back(id);
    }
}
struct node{
    int L[3005],R[3005],rt=1;
    void merge(int idrt,int Rt,int rtt){
        if(Rt==rtt){
            return;
        }
        if(l[Rt]){
            if(L[idrt]==0){
                L[idrt]=++rt;
            }
            merge(L[idrt],l[Rt],rtt);
        }
        if(r[Rt]){
            if(R[idrt]==0){
                R[idrt]=++rt;
            }
            merge(R[idrt],r[Rt],rtt);
        }
    }
    void Clear(){
        for(int i=1;i<=rt;i++){
            L[i]=R[i]=0;
        }
        rt=1;
    }
    int Dfs(int cur){
        int sum=0;
        if(L[cur]){
            sum+=Dfs(L[cur])+2;
        }
        if(R[cur]){
            sum+=Dfs(R[cur])+2;
        }
        return sum;
    }
}AA;
vector<int> vec;
void bing(){
    int X=1,lst_X=1;
    while(1){
        for(int j=0;j<vec.size();j++){
            if(vec[j]==-1){
                X=l[X];
            }else{
                X=r[X];
            }
        }
        AA.merge(1,lst_X,X);
        lst_X=X;
        if(X==0){
            return;
        }
    }
}
int dfs_daan(int id){
    int Min=1e9;
    if(id!=1){
        AA.Clear();
        bing();
        int zx=vec.size();
        Min=min(Min,AA.Dfs(1)-zx);
    }
    if(l[id]){
        vec.push_back(-1);
        Min=min(Min,dfs_daan(l[id]));
        vec.pop_back();
    }
    if(r[id]){
        vec.push_back(1);
        Min=min(Min,dfs_daan(r[id]));
        vec.pop_back();
    }
    return Min;
}
int solve(){
    int rt=0;
    int Min=1e9;
    dfs(rt);
    return dfs_daan(rt);
}
int Ans=0;
int main(){
    cin>>ss;
    ss=" "+ss;
    int n=ss.size()-1;
    cout<<solve();
    return 0;
}
```

---

## 作者：shicj (赞：0)

一道思维题，我自己没能想出来，研究了很久，最后参考了[题解](https://www.cnblogs.com/youth518/p/13850918.html)想了很久才做出来，但题解写得比较简略，于是在此记录一下。

---

# 解题思路

- 因为是无限延伸的完全二叉树，所以只要不对树根进行U操作，所有的命令都是合法的。

- 因为是无限复读指令，所以每一次执行指令之后的相对的位移是一样的。

- 于是，可以将要遍历的整棵树分成几个相同（也可以有包含关系）且连续的部分（这样可以用重复执行相同指令串来处理），然后处理每一个部分的过程就是要求出的指令串。

- 每一部分的具体操作中一定会遍历起点到终点的边一遍和其他的边两遍，于是有 $tot = 2 \times ( sum - 1 ) - d $（ $tot$ 是步骤数， $sum$ 是点数， $d$ 是起点到终点的边数），具体参考图片：

![](https://cdn.luogu.com.cn/upload/image_hosting/lnezi8rk.png)

- 然后，考虑分部分的方法，可以进行 $O(n)$ 的暴力枚举

- 具体操作时，涉及到对所有部分的合并，如将下图中的A树拆分成B的形状，为了使指令串可以处理所有的部分，应将所有部分合并成C，然后找出C的处理步骤数，就是这一拆分下的答案。

![](https://cdn.luogu.com.cn/upload/image_hosting/r5kxhbon.png)

- 最终，答案是所有拆分方法答案中的最小值。

# 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e3+100;
int n,l[maxn],r[maxn];
int tmp_l[maxn],tmp_r[maxn];
//tmp_l[],tmp_r[]是合并后的图
int sum,cur,ans=0x3f3f3f3f;
//sum是一个拆分中的答案
//cur在后面作为每一部分的终点
//ans是总答案
char p[maxn];
//保存拆分路径
int read(){
	//根据前序遍历建树
	char tmp;
	int now;
	cin>>tmp;
	n++;
	now=n;
	if(tmp=='1'||tmp=='3')
		l[now]=read();
	if(tmp=='2'||tmp=='3')
		r[now]=read();
	return now;
}
void merge(int &x,int y){
	//合并各个部分
	if(x==0)sum++,x=sum;
	//新建一个点
	if(y==cur)return;
	//到达这部分终点，退出
	if(l[y]!=0)merge(tmp_l[x],l[y]);
	if(r[y]!=0)merge(tmp_r[x],r[y]);
	//合并左右子树
}
void solve(int u,int d){
	//u是当前部分的结束位置的下一个位置
	//d是当前部分的长度
	if(u!=1){
		memset(tmp_l,0,sizeof(tmp_l));
		memset(tmp_r,0,sizeof(tmp_r));
		//清空
		sum=1;
		//开始时只有根节点
		cur=1;
		while(cur){
			int t=cur;
			for(int i=0;i<d;i++){
				cur=(p[i]=='l'?l[cur]:r[cur]);
				//按照路径找终点
			}
			int tmp_x=1;
			merge(tmp_x,t);
			//合并树，求sum
		}
		ans=min(ans,(sum-1)*2-d);
		//记下答案
	}
	p[d]='l';
	if(l[u])
		solve(l[u],d+1);
	//递归向左子树扩展路径
	p[d]='r';
	if(r[u])
		solve(r[u],d+1);
	//递归向右子树扩展路径
}
int main(){
	read();
	solve(1,0);
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：DengDuck (赞：0)

挺巧妙的，看了尺子姐姐的题解，实现也参考了很多。

显然一套操作的位移是一定的，只要一套操作没有出界，之后的操作都不会出界。

所以我们自然地想到枚举位移，然后求该位移能够覆盖全图的最小步数。

有个比较显然的结论，就是在一套操作中，点不会移动到最后移动到的点的下面，我们可以证明在根节点提前覆盖这个部分肯定不劣。

我们推广一下这个结论，我们发现，位移能够覆盖全图的最小步数，其实就是把每次一套操作下来之后的新的根节点的子树拆出来，拆成无数棵树，然后把他们重叠在一起，如果一个节点在任意一棵树上是宝藏，那么就要在第一套操作中去这个点，这样肯定是最优的。

求出这棵重叠树，然后最小操作显然是 $2(sz-1)-dep$，$sz$ 是节点的数量，$dep$ 是位移之后的点的深度。

直接 $\mathcal O(n)$ 求就行，总的时间复杂度为 $\mathcal O(n^2)$。

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const LL N=2005;
struct node
{
	LL l[N],r[N],tot,rt;
	node()
	{
		memset(l,0,sizeof(l));
		memset(r,0,sizeof(r));
		tot=0,rt=0;
	}
	LL read()
	{
		LL x,Rt=++tot;
		scanf("%1lld",&x);
		if(x&1)l[Rt]=read();
		if(x&2)r[Rt]=read();
		return Rt;
	}
}T,TU;
void Dfs(LL rt1,LL rt2,LL rt)
{
	if(rt1==rt||rt2==rt)
	{
		rt2=TU.rt;
	}
	
	if(T.l[rt1])
	{
		if(!TU.l[rt2])TU.l[rt2]=++TU.tot;
		Dfs(T.l[rt1],TU.l[rt2],rt);
	}
	if(T.r[rt1])
	{
		if(!TU.r[rt2])TU.r[rt2]=++TU.tot;
		Dfs(T.r[rt1],TU.r[rt2],rt);
	}	
}
LL dfs(LL x,LL dep)
{
	TU=node();
	TU.tot=TU.rt=1;
	Dfs(T.rt,TU.rt,x);
	LL ans=(TU.tot-1)*2-dep;
	if(T.l[x])ans=min(ans,dfs(T.l[x],dep+1));
	if(T.r[x])ans=min(ans,dfs(T.r[x],dep+1));
	return ans;
}
int main()
{
	T.rt=T.read();
	printf("%lld",dfs(T.rt,0));
}
```

---


# 小 O 与排列

## 题目背景

小 O 是一个喜爱数学的高中生，他现在在一个与排列有关的问题上陷入了迷茫之中，快来帮帮他！

**注意输入格式有修改，第二行与第三行被调换了。（以现在的题面为准）**

## 题目描述

小 O 有一个长为 $n$ 的排列 $p$，他的好朋友 $\texttt{euei}$ 有一个长为 $n$，值域是 $[1, n]$ 的序列 $a$。

有一天，小 O 忽然想知道是否存在数对 $i, j$，满足 $l \le i, j \le r$，且 $p_{a_i} = a_j$，他轻松地解决了这个问题。但是 $\texttt{euei}$ 有些时候会修改这个序列某个位置的值，还会对多对不同的 $l, r$ 询问上面的问题，这下小 O 就不会了。

聪明的你能帮助小 O 解决这个问题吗？

## 说明/提示

**提示**

本题读入量较大，请使用高效的读入方式。

**样例解释**

对于第一组询问，数对 $2, 3$ 满足要求。

对于第二组询问，没有数对满足要求。

**数据范围**

本题共有 $5$ 个子任务，你需要通过一个子任务内的所有测试点才能取得这个子任务的分数。

对于所有数据，$1 \le n,m \le 5\times 10^5$，$1 \le a_i, i, v, l, r \le n$ ，$p_i \neq i$。

| #    | 分数 | $n, m$           | 特殊性质                        | 时间限制    |
| ---- | ---- | ---------------- | ------------------------------- | ----------- |
| 1    | 7    | $\leqslant 300$  |                                 | $\text{1s}$ |
| 2    | 23   | $\leqslant 2000$ |                                 | $\text{1s}$ |
| 3    | 15   |                  | 没有`1`操作                     | $\text{3s}$ |
| 4    | 15   |                  | 每次询问时序列 $a$ 都是一个排列 | $\text{3s}$ |
| 5    | 40   |                  |                                 | $\text{3s}$ |

表格中留空表示该项无特殊限制。

## 样例 #1

### 输入

```
3 4
3 1 2
2 2 1
2 2 3
1 2 3
1 3 3
2 2 3```

### 输出

```
Yes
No```

# 题解

## 作者：disangan233 (赞：15)

### 瞎扯

月赛上肝了一个多小时这个题的具体实现，细节爆炸啊 qaq

### 做法

做法：线段树+set

考虑一种巧妙的维护：对于每一个 $a_i$，维护 $b_i=\max j<i$，使得 $a_i$ 与 $a_j$ 发生关系（可互逆），且 $\forall j<k<i,a_k \not =a_i$。

那么对于一个询问区间 $l,r$，因为每一个相同的 $a_i$ 只有第一个对 $b_i$ 有贡献，所以答案即为 $\max \{q_i|l\leq i\leq r\}$，使用线段树维护，这样就可以通过只有询问的点了。

考虑修改操作，维护 $p_i$ 的逆数组 $ap_i$，因为是单点修改，只需要更新修改位置后的所有 $a_i,p_{a_i},ap_{a_i}$ 即可，用对每一个值开 set 维护，值的修改使用 `.insert()`，`.erase()`，`.lower_bound()`。更新结束后按照预处理的方法更新即可，时间复杂度 $O(n\log n)$。

具体细节见代码实现。

强烈建议：一定要写函数！！！！

### 代码实现

```cpp
#pragma GCC optimize(2,3,"Ofast","unroll-loops")
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define re register int
#define db double
#define in inline
namespace fast_io
{
	char buf[1<<12],*p1=buf,*p2=buf,sr[1<<23],z[23],nc;int C=-1,Z=0,Bi=0;
	in char gc() {return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<12,stdin),p1==p2)?EOF:*p1++;}
	in ll read()
	{
		ll x=0,y=1;while(nc=gc(),(nc<48||nc>57)&&nc!=-1)if(nc==45)y=-1;Bi=1;
		x=nc-48;while(nc=gc(),47<nc&&nc<58)x=(x<<3)+(x<<1)+(nc^48),Bi++;return x*y;
	}
	in db gf() {re a=read(),b=(nc!='.')?0:read();return (b?a+(db)b/pow(10,Bi):a);}
	in int gs(char *s) {char c,*t=s;while(c=gc(),c<32);*s++=c;while(c=gc(),c>32)*s++=c;return s-t;}
	in void ot() {fwrite(sr,1,C+1,stdout);C=-1;}
	in void flush() {if(C>1<<22) ot();}
	template <typename T>
	in void write(T x,char t)
	{
		re y=0;if(x<0)y=1,x=-x;while(z[++Z]=x%10+48,x/=10);
		if(y)z[++Z]='-';while(sr[++C]=z[Z],--Z);sr[++C]=t;flush();
	}
	in void write(char *s) {re l=strlen(s);for(re i=0;i<l;i++)sr[++C]=*s++;sr[++C]='\n';flush();}
};
using namespace fast_io;
const int N=5e5+5;
int n,m,a[N],b[N],ab[N],c[N],p[N],ap[N],mx[N<<2],lst[N];
set<int>s[N];
#define ls(x) (x<<1)
#define rs(x) (x<<1|1)
#define mid ((l+r)>>1)
in void push_up(re x) {mx[x]=max(mx[ls(x)],mx[rs(x)]);}
void build(re p,re l,re r)
{
	if(l==r) return mx[p]=b[l],void();
	build(ls(p),l,mid);build(rs(p),mid+1,r);push_up(p);
}
void update(re p,re l,re r,re x,re y)
{
	if(l==r) return mx[p]=y,void();
	(x<=mid)?update(ls(p),l,mid,x,y):update(rs(p),mid+1,r,x,y);push_up(p);
}
int query(re p,re l,re r,re ql,re qr)
{
	if(ql<=l&&r<=qr) return mx[p];
	if(ql>mid) return query(rs(p),mid+1,r,ql,qr);
	if(qr<=mid) return query(ls(p),l,mid,ql,qr);
	return max(query(rs(p),mid+1,r,ql,qr),query(ls(p),l,mid,ql,qr));
}
#define lb lower_bound
in void update(re x,re y) {update(1,1,n,x,y);}
in int get(re x)
{
	auto it=s[a[x]].lb(x);re pre=0,pp=0,v=p[a[x]],av=ap[a[x]];
	if(it!=s[a[x]].begin()) pre=*--it;
	if((it=s[v].lb(x))!=s[v].begin()) pp=*--it;
	if((it=s[av].lb(x))!=s[av].begin()) pp=max(pp,*--it);
	return pp>pre?pp:0;
}
in void upd(set<int>::iterator it) {update(*it,b[*it]=get(*it));}
in void erase(re x)
{
	s[a[x]].erase(x),b[x]=0;auto it=s[a[x]].lb(x);re v=p[a[x]],av=ap[a[x]];
	if(it!=s[a[x]].end()) upd(it);
	if((it=s[v].lb(x))!=s[v].end()) upd(it);
	if((it=s[av].lb(x))!=s[av].end()) upd(it);
}
in void add(re x,re y)
{
	a[x]=y,s[a[x]].insert(x);auto it=s[a[x]].lb(x);
	re v=p[a[x]],av=ap[a[x]];upd(it);it++;
	if(it!=s[a[x]].end()) upd(it);
	if((it=s[v].lb(x))!=s[v].end()) upd(it);
	if((it=s[av].lb(x))!=s[av].end()) upd(it);
}
int main()
{
	n=read(),m=read();
	for(re i=1;i<=n;i++) p[i]=read(),ap[p[i]]=i;
	for(re i=1;i<=n;i++) a[i]=read();
	for(re i=1;i<=n;i++) 
	{
		s[a[i]].insert(i);re v=p[a[i]],pp=max(lst[v],lst[ap[a[i]]]);
		if(pp>lst[a[i]]) update(1,1,n,i,b[i]=pp);lst[a[i]]=i;
	}
	build(1,1,n);
	while(m--)
	{
		re op=read(),x=read(),y=read();
		if(op==2) (query(1,1,n,x,y)>=x)?write("Yes"):write("No");
		else erase(x),add(x,y);
	}
	return ot(),0;
}
//Author: disangan233
//In my dream's scene,I can see the everything that in Cyaegha.
```

---

## 作者：爱喝敌敌畏 (赞：5)

推一波蒟蒻的BLOG：https://blog.csdn.net/zhangjianjunab

[小O与排列](https://www.luogu.org/problem/P5604)

这道题目如果没有神犇提示根本做不出来。

~~首先我们有个很明显的思路，带修莫队。~~

首先这道题目我们很明显可以得到$n$个数对，就是说区间内只要有这些数对的话就是Yes，那么对于$P_i=j$，我们就可以得到数对$(i,j)$。

那么我们就可以对于每一个位置$i$，分别对于两个可以和他组成数对的$k_1,k_2$，求出最小的区间$[i,j](j>i,a[j]=k_1ork_2)$，那么我们就可以得到$2n$个区间，问题就转化为了，询问区间中是否包含一个小区间。

那么我们就可以对于每个$r$建一棵线段树，对于管理$r$的叶子节点，他存的是最大的$l$使得有$[l,r]$这个区间。

而对于非叶子节点，就是左右儿子的最大值，其实就是当$r$在这个区间的时候，最大的$l$是多少，然后在询问的时候把询问区间的$l$传进去，在$l,r$中询问一下，如果发现一个节点被完全覆盖且$c$值大于等于$l$，那么就是有小区间。

~~讲真当时想出来这个，立马命名成ZJJ判断线段树，迈着嚣张的步伐，然后被神犇ZFY吐槽：这不就是个最大值线段树吗。。。~~

查询复杂度$O(logn)$

---

但是吉利扒拉了一大坨，如何修改？

对于修改位置$i$，把$i$的$old$值改成$now$值。

那么我们需要维护四个区间，一个是原来$l$ $or$ $r$是$i$的，以及新的$l$ $or$ $r$是$i$的。

那么对于原来$r$是$i$的我们要怎么维护？

我们先找到$j(j>i,a[j]=old)$，然后把$i$的值赋到$j$上就行了。

对于原本$l$是$i$的呢？我们对于两种数对分别找到了区间$[i,r_1],[i,r_2]$，我们要明白一个事情，$x$位置作为$r$的话，那么他的最大的$l$就是两种对数方案的最大的$l$的最大值，那么我们只需要对于$r_1,r_2$重新找一遍就行了。

对于新的$l$是$i$的，我们随便搞一下就行了。

对于新的$r$是$i$的，我们需要跑到前面找找最接近他的两种值。

那么问题来了，我们怎么知道数值为$x$的下标最接近$y$的点下标是多少？

树套树？不要，空间时间都SB了。

仔细想想，貌似我们只要对于每种数值建一棵下标为键值的平衡树，节点总数是为$n$个节点的，妙啊。

所以时间复杂度就是$O((n+m)logn)$

update：
第二次更新！

在膜拜了zhoufangyuan神犇$∞$次后，他突然降神旨于人间，我的代码有错？

仔细看看，原来是因为一个点是可以找前面最近的点对更新$l$，但是还是要注意一个细节，就是数对之间有与这个点相同的权值的话，那么就只能更新$0$。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20191029130511719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5namlhbmp1bmFi,size_16,color_FFFFFF,t_70)

代码：
```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<ctime>
#define  N  510000
#define  NN  1100000
using  namespace  std;
struct  node
{
	int  lc,rc,l,r,c;
}tr[NN];int  len;
void  bt(int  l,int  r)
{
	len++;int  now=len;
	tr[now].l=l;tr[now].r=r;
	if(l<r)
	{
		int  mid=(l+r)>>1;
		tr[now].lc=len+1;bt(l,mid);
		tr[now].rc=len+1;bt(mid+1,r);
	}
}
inline  int  mymax(int  x,int  y){return  x>y?x:y;}
int  change(int  now,int  x,int  k,int  type/*type=0表示代替，type=1表示取max*/)//返回的是x的值
{
	if(tr[now].l==tr[now].r){int  ans=tr[now].c;type==0?tr[now].c=k:tr[now].c=mymax(tr[now].c,k);return  ans;}
	int  mid=(tr[now].l+tr[now].r)/2,lc=tr[now].lc,rc=tr[now].rc,ans=0;
	if(x<=mid)ans=change(lc,x,k,type);
	else  ans=change(rc,x,k,type);
	tr[now].c=mymax(tr[lc].c,tr[rc].c);
	return  ans;
}
bool  findans(int  now,int  l,int  r,int  k/*参数*/)//返回是否包含区间
{
	if(tr[now].l==l  &&  tr[now].r==r)return  tr[now].c>=k;
	int  mid=(tr[now].l+tr[now].r)/2,lc=tr[now].lc,rc=tr[now].rc;
	if(r<=mid)return  findans(lc,l,r,k);
	else  if(mid<l)return  findans(rc,l,r,k);
	else  return  findans(lc,l,mid,k)|findans(rc,mid+1,r,k);
}
//线段树
class  fhq//fhq treap万岁 
{
	public:
		int  size[N],vio[N],root[N],key[N],son[N][2];
		inline  void  pushup(int  x){size[x]=size[son[x][0]]+size[son[x][1]];}
		void  spilt(int  now,int  k,int  &x,int  &y)
		{
			if(!now)x=0,y=0;
			else
			{
				if(key[now]<=k)x=now,spilt(son[x][1],k,son[x][1],y),pushup(x);
				else  y=now,spilt(son[y][0],k,x,son[y][0]),pushup(y),pushup(y);
			}
		}
		int  merge(int  x,int  y)
		{
			if(!x  ||  !y)return  x+y;
			if(vio[x]<=vio[y])son[x][1]=merge(son[x][1],y);
			else  son[y][0]=merge(x,son[y][0]),x^=y^=x^=y;
			pushup(x);return  x;
		}
		void  first_do(int  x)
		{
			for(int  i=1;i<=x;i++)size[i]=1,vio[i]=rand(),key[i]=i;
		}
		void  add(int  &rt,int  id/*编号*/)
		{
			if(!rt)rt=id;
			else
			{
				int  x,y;spilt(rt,id,x,y);
				rt=merge(merge(x,id),y);
			}
		}
		void  del(int  &rt,int  id)//从根为rt的树中分离id 
		{
			int  x,y,z;spilt(rt,id-1,x,y);spilt(y,id,y,z);
			rt=merge(x,z);
		}
		int  findqian(int  &rt,int  k/*查找k的前驱*/)
		{
			if(rt==0)return  0;
			int  x=rt,ans=0;
			while(x)
			{
				if(key[x]>=k)x=son[x][0];
				else  if(key[x]<k)ans=x,x=son[x][1];
			}
			return  ans;
		}
		int  findhou(int  &rt,int  k/*查找k的前驱*/)
		{
			if(rt==0)return  0;
			int  x=rt,ans=0;
			while(x)
			{
				if(key[x]>k)ans=x,x=son[x][0];
				else  if(key[x]<=k)x=son[x][1];
			}
			return  ans;
		}
}zjj;
int  to[N][2],n,m;
int  a[N],b[N];
int  main()
{
	srand(999);
	scanf("%d%d",&n,&m);
	zjj.first_do(n);bt(1,n);
	for(int  i=1;i<=n;i++)
	{
		scanf("%d",&b[i]);
		to[i][0]=b[i];to[b[i]][1]=i;
	}
	for(int  i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		zjj.add(zjj.root[a[i]],i);
	}
	for(int  i=1;i<=n;i++)
	{
		for(int  j=0;j<=1;j++)
		{
			int  x=zjj.findhou(zjj.root[to[a[i]][j]],i);//找到符合对数的数字。
			if(x)change(1,x,i,1);
		}
	}
	//建树
	for(int  i=1;i<=m;i++)
	{
		int  type,l,r;scanf("%d%d%d",&type,&l,&r);
		if(type==2)
		{
			if(findans(1,l,r,l)==true)printf("Yes\n");
			else  printf("No\n");
		}//短短的询问
		else
		{
			int  x=0;
			for(int  j=0;j<=1;j++)x=mymax(x,zjj.findqian(zjj.root[to[r][j]],l));//代替数字 
			x=change(1,l,x,0);//表示替代原来的位置，并且获取到现在的位置
			//以新的"l"为r的区间
			int  y=zjj.findhou(zjj.root[a[l]],l);
			if(y)change(1,y,x,1);
			//以旧的"l"为r的区间
			zjj.del(zjj.root[a[l]],l);zjj.add(zjj.root[r],l);
			//平衡树换点
			for(int  j=0;j<=1;j++)
			{
				int  xx=to[a[l]][j];//表示与他有关的 
				y=zjj.findhou(zjj.root[xx],l);
				if(y)
				{
					int  z=0;
					for(int  k=0;k<=1;k++)z=mymax(z,zjj.findqian(zjj.root[to[xx][k]],y));//重新去找
					change(1,y,z,0);
				}
			}
			//以旧的"l"为l的区间
			for(int  j=0;j<=1;j++)
			{
				x=zjj.findhou(zjj.root[to[r][j]],l);//代替数字 
				if(x)change(1,x,l,1);
			}
			//以新的"l"为l的区间
			a[l]=r;
		}
	}
	return  0;
}
```

---

## 作者：Owen_codeisking (赞：1)

为什么泥萌~~代码~~都这么短啊？？？

比赛的时候一眼 $O(\frac {n^2}{32})$，看到 $n\le 5\times 10^5$，自闭了。。。

本以为可以比赛最后 1h rush 完这题的，结果调不出来，加赛后写了将近 6h

肯定会有更简单的写法 $\text{QAQ}$

出题人的题解上已经写得很清楚了。

先考虑一个不带修的做法，对于一个位置，我们先把它左边和右边 $p_{a_i}$ 最近的出现位置，询问相当于在线段树上查一查最值。

带修改的话，对于 $a$ 是排列，可以记一记权值出现的位置，配合上面的算法以及暴力，可以拿到 $\text{60pts}$。

若 $a$ 是序列，直接暴力修改后面的值会退化成 $O(n^2)$。这时我们可以想想是否可以去掉一些多余的数对。

（注意，这里的匹配都是单向匹配，$0$ 表示未匹配）

比如说 $i\rightarrow k,j\rightarrow k,|i-k|>|j-k|$，那么 $j\rightarrow k$ 一定更优。

记 $\text{pre}$ 为一个点的前面匹配的位置，假设中间的位置匹配两边的位置，那么其中的一段 $\text{pre}_{i\sim j}$ 就是长这样的：

`(?)(i, 0, 0, 0, 0, 0, 0, 0, 0)(?)`

同理，$\text{suf}_{i\sim j}$ 是长这样的：

`(?)(0, 0, 0, 0, 0, 0, 0, 0, j)(?)`

每次修改只会波及原来、后来、原来逆匹配、后来逆匹配的值的前驱后继的位置以及修改位置的 $\text{pre,suf}$，这样数对的更新是 $O(1)$，用 $\text{set}$ 维护一下，加上线段树，复杂度 $O(n\log n)$。

具体的分类还是自己手推一遍吧，讲也讲不清楚，看代码好了。

$Code\ Below:$

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=500005;
int n,m,p[maxn],a[maxn],pos[maxn],lst[maxn],id[maxn][2];
set<int> s[maxn];
set<int>::iterator it,itl,itr;
struct Segment_Tree
{
	int op,sum[maxn<<2];
	#define ls (rt<<1)
	#define rs (rt<<1|1)
	#define pushup(rt) sum[rt]=!op?max(sum[ls],sum[rs]):min(sum[ls],sum[rs])
	void build(int rt,int l,int r)
	{
		if(l==r) { sum[rt]=id[l][op]; return; }
		int mid=(l+r)>>1;
		build(ls,l,mid),build(rs,mid+1,r),pushup(rt);
	}
	void update(int rt,int l,int r,int pos,int val,int t=0)
	{
		if(l==r) { sum[rt]=!t?val:!op?max(sum[rt],val):min(sum[rt],val); return; }
		int mid=(l+r)>>1;
		if(pos<=mid) update(ls,l,mid,pos,val,t);
		else update(rs,mid+1,r,pos,val,t);
		pushup(rt);
	}
	int query(int rt,int l,int r,int x,int y)
	{
		if(x<=l && r<=y) return sum[rt];
		int mid=(l+r)>>1;
		if(y<=mid) return query(ls,l,mid,x,y);
		if(x>mid) return query(rs,mid+1,r,x,y);
		return !op?max(query(ls,l,mid,x,y),query(rs,mid+1,r,x,y)):
		min(query(ls,l,mid,x,y),query(rs,mid+1,r,x,y));
	}
}mx,mn;
#define mxupd(x,y) mx.update(1,1,n,x,y)
#define mnupd(x,y) mn.update(1,1,n,x,y)
inline void erase(int x)
{
	int u=a[x],v=pos[a[x]];
	itl=s[u].lower_bound(x);
	if(u==v) { s[u].erase(itl); return; }
	itr=s[v].lower_bound(x);
	int pa=0,sa=n+1,pb=0,sb=n+1;
	it=itl; if(it!=s[u].begin()) pa=*--it;
	it=itl; if(++it!=s[u].end()) sa=*it;
	it=itr; if(it!=s[v].begin()) pb=*--it;
	it=itr; if(it!=s[v].end()) sb=*it;
	// pa...x...sa
	// pb...x...sb
	if(sb!=n+1)
	{
		// x...sa...()...sb
		if(sa!=n+1 && sa<sb) mx.update(1,1,n,sb,sa,1);
		// pb...pa...x...sb
		else if(pa && pa>pb) mxupd(sb,pa);
		else mxupd(sb,0);
	}
	if(pb)
	{
		// pb...()...pa...x
		if(pa && pa>pb) mn.update(1,1,n,pb,pa,1);
		// pb...x...sa...sb
		else if(sa!=n+1 && sa<sb) mnupd(pb,sa);
		else mnupd(pb,n+1);
	}
	v=p[a[x]],itr=s[v].lower_bound(x),pb=0,sb=n+1;
	it=itr; if(it!=s[v].begin()) pb=*--it;
	it=itr; if(it!=s[v].end()) sb=*it;
	// pb...pa...x...sb...sa
	if(pa && sb!=n+1 && pb<pa && sb<sa) mnupd(pa,sb);
	// pa...pb...x...sa...sb
	if(sa!=n+1 && pb && sb>sa && pb>pa) mxupd(sa,pb);
	s[u].erase(itl);
}
inline void insert(int x)
{
	int u=a[x],v=pos[a[x]];
	itl=s[u].insert(x).first;
	if(u==v) { mxupd(x,x),mnupd(x,x); return; }
	itr=s[v].lower_bound(x);
	int pa=0,sa=n+1,pb=0,sb=n+1;
	it=itl; if(it!=s[u].begin()) pa=*--it;
	it=itl; if(++it!=s[u].end()) sa=*it;
	it=itr; if(it!=s[v].begin()) pb=*--it;
	it=itr; if(it!=s[v].end()) sb=*it;
	// pa...x...sb...sa
	if(sb!=n+1 && sb<sa) mxupd(sb,x);
	// pa...pb...x
	if(pb && pa<pb) mnupd(pb,x);
	v=p[a[x]],itr=s[v].lower_bound(x),pb=0,sb=n+1;
	it=itr; if(it!=s[v].begin()) pb=*--it;
	it=itr; if(it!=s[v].end()) sb=*it;
	// pa...x...sb...sa
	if(sb!=n+1 && sa>sb)
	{
		// pb...pa...x...sb
		if(pa && pa>pb) mnupd(pa,n+1);
		mnupd(x,sb);
	}
	else mnupd(x,n+1);
	// pa...pb...x...sa
	if(pb && pa<pb)
	{
		// pa...pb...x...sa...sb
		if(sa!=n+1 && sa<sb) mxupd(sa,0);
		mxupd(x,pb);
	}
	else mxupd(x,0);
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d",&p[i]),pos[p[i]]=i;
	for(int i=1;i<=n;i++) scanf("%d",&a[i]),s[a[i]].insert(i);
	for(int i=1;i<=n;i++) id[i][0]=(p[a[i]]==a[i])?i:(lst[p[a[i]]]<lst[a[i]])?0:lst[p[a[i]]],lst[a[i]]=i;
	for(int i=1;i<=n;i++) lst[i]=n+1;
	for(int i=n;i;i--) id[i][1]=(p[a[i]]==a[i])?i:(lst[p[a[i]]]>lst[a[i]])?n+1:lst[p[a[i]]],lst[a[i]]=i;
	mx.op=0,mn.op=1,mx.build(1,1,n),mn.build(1,1,n);
	int op,x,y;
	while(m--)
	{
		scanf("%d%d%d",&op,&x,&y);
		if(op==1) erase(x),a[x]=y,insert(x);
		else puts((mx.query(1,1,n,x,y)>=x || mn.query(1,1,n,x,y)<=y)?"Yes":"No");
	}
	return 0;
}
```

---

## 作者：KokiNiwa (赞：0)

# 小O与排列

这是一个好题。[题目链接](https://www.luogu.com.cn/problem/P5604)

## 题目叙述

给你$n$个映射关系，求一个区间里有没有两个元素可以映射。

## 题解

首先我们可以得到许多数对，只要区间里有这些数对就行了。我们可以用线段树维护每个位置上的数和最靠近它的、在它前面的、并可以和他组成数对的数的位置。维护区间最大值即可（判断区间最大值是不是在`l`后面）。

考虑如何应对修改操作。发现每一次修改可能影响最多$\mathcal O(n)$个点的值，所以复杂度有问题。考虑去掉一些无意义数对，一个点只找两边都是最近的那种，就是与`A`最近的是`B`，与`B`最近的是`A`那种。这样可以得到$\le n$个数对，复杂度就正确了。

由于我们需要权值为$x$与这个点最近的那个点，所以可以一个权值一个平衡树。

## 知识点

+ 在区间里有没有数对这种问题的解决方法值得学习。
+ 去掉冗余数对的方式也值得学习。

## 代码

这份代码在最优解的第一位。

```cpp
#include <cstdio>
#include <iostream>
#include <cstdlib>
#include <ctime>
#include <stack>
using namespace std;
const int N = 5e5 + 5;
inline int Read() {
	int ret = 0;
	char ch = getchar();
	while (!isdigit(ch)) ch = getchar();
	while (isdigit(ch)) ret = ret * 10 + (ch - '0'), ch = getchar();
	return ret;
}
struct SegmentTree {
	#define ls(x) (x << 1)
	#define rs(x) (x << 1 | 1)
	int mx[N * 4];
	inline void PushUp(int now) {
		mx[now] = max(mx[ls(now)], mx[rs(now)]);
	}
	void Insert(int now, int L, int R, int pos, int val) {
		if (L == R) {
			mx[now] = val;
			return ;
		}
		int mid = (L + R) >> 1;
		if (pos <= mid) Insert(ls(now), L, mid, pos, val);
		else Insert(rs(now), mid + 1, R, pos, val);
		PushUp(now);
	}
	int Ask(int now, int L, int R, int al, int ar) {
		if (al <= L && R <= ar) return mx[now];
		if (al > R || ar < L) return 0;
		int mid = (L + R) >> 1;
		return max(Ask(ls(now), L, mid, al, ar), Ask(rs(now), mid + 1, R, al, ar));
	}
} tr;
int root[N];
struct FHQ_Treap {
	int ch[N][2], pri[N], val[N], siz[N], tail, aRt, bRt, cRt;
	stack<int> trash;
	inline void Update(int id) {
		siz[id] = siz[ch[id][0]] + siz[ch[id][1]] + 1;
	}
	inline int NewNode(int num) {
		int id = ++tail;
		if (!trash.empty()) id = trash.top(), trash.pop();
		pri[id] = rand(), val[id] = num, siz[id] = 1;
		return id;
	}
	void Split(int id, int num, int &ln, int &rn) {
		if (!id) ln = rn = 0;
		else {
			if (val[id] <= num) {
				ln = id;
				Split(ch[id][1], num, ch[id][1], rn);
			} else {
				rn = id;
				Split(ch[id][0], num, ln, ch[id][0]);
			}
			Update(id);
		}
	}
	int Merge(int A, int B) {
		if (!A || !B) return A + B;
		if (pri[A] < pri[B]) {
			ch[A][1] = Merge(ch[A][1], B);
			return Update(A), A;
		} else {
			ch[B][0] = Merge(A, ch[B][0]);
			return Update(B), B;
		}
	}
	void Insert(int &rt, int num) {
		Split(rt, num, aRt, bRt);
		rt = Merge(Merge(aRt, NewNode(num)), bRt);
	}
	void Erase(int &rt, int num) {
		Split(rt, num - 1, aRt, bRt);
		Split(bRt, num, bRt, cRt);
		rt = Merge(aRt, cRt);
		if (bRt) trash.push(bRt);
	}
	int Kth(int rt, int kth) {
		if (kth > siz[rt] || kth < 1) return 0;
		int now = rt;
		while (1) {
			if (kth <= siz[ch[now][0]]) now = ch[now][0];
			else if (siz[ch[now][0]] + 1 == kth) return val[now];
			else kth -= siz[ch[now][0]] + 1, now = ch[now][1];
		}
	}
	int Prev(int &rt, int num) {
		Split(rt, num - 1, aRt, bRt);
		int ret = Kth(aRt, siz[aRt]);
		rt = Merge(aRt, bRt);
		return ret;
	}
	int Next(int &rt, int num) {
		Split(rt, num, aRt, bRt);
		int ret = Kth(bRt, 1);
		rt = Merge(aRt, bRt);
		return ret;
	}
} bt;
int len, nbQry, sht[N], inv[N], seq[N], last[N], pre[N];
inline void Update(int pos) {
	int shtPrev = bt.Prev(root[sht[seq[pos]]], pos);
	if (bt.Prev(root[seq[pos]], pos) > shtPrev) shtPrev = 0;
	int invPrev = bt.Prev(root[inv[seq[pos]]], pos);
	if (bt.Prev(root[seq[pos]], pos) > invPrev) invPrev = 0;
	int mx = max(shtPrev, invPrev);
	tr.Insert(1, 1, len, pos, mx);
}
inline void Change(int pos, int num) {
	int shtNext1 = bt.Next(root[sht[seq[pos]]], pos);
	int invNext1 = bt.Next(root[inv[seq[pos]]], pos);
	int oriNext1 = bt.Next(root[seq[pos]], pos);
	bt.Erase(root[seq[pos]], pos);
	seq[pos] = num;
	bt.Insert(root[seq[pos]], pos);
	int shtNext2 = bt.Next(root[sht[seq[pos]]], pos);
	int invNext2 = bt.Next(root[inv[seq[pos]]], pos);
	int oriNext2 = bt.Next(root[seq[pos]], pos);
	if (shtNext1) Update(shtNext1);
	if (invNext1) Update(invNext1);
	if (oriNext1) Update(oriNext1);
	if (shtNext2) Update(shtNext2);
	if (invNext2) Update(invNext2);
	if (oriNext2) Update(oriNext2);
	Update(pos);
}
int main() {
	srand(123456789);
	len = Read(), nbQry = Read();
	for (int i = 1; i <= len; ++i) sht[i] = Read(), inv[sht[i]] = i;
	for (int i = 1; i <= len; ++i) seq[i] = Read(), bt.Insert(root[seq[i]], i);
	for (int pos = 1; pos <= len; ++pos) {
		int pos1 = last[sht[seq[pos]]], pos2 = last[inv[seq[pos]]];
		int pp = max(pos1, pos2);
		if (pp > pre[last[seq[pos]]]) {
			tr.Insert(1, 1, len, pos, pre[pos] = pp);
		}
		last[seq[pos]] = pos;
	}
	while (nbQry--) {
		int opt, fir, sec;
		opt = Read(), fir = Read(), sec = Read();
		if (opt == 1) {
			Change(fir, sec);
		} else {
			if (tr.Ask(1, 1, len, fir, sec) >= fir) puts("Yes");
			else puts("No");
		}
	}
	return 0;
}
```

---


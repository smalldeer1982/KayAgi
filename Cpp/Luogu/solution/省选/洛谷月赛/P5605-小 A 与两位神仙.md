# 小 A 与两位神仙

## 题目背景

小 A 是一个普普通通的高中生，但是他某一天忽然被卷入了神仙的游戏中，快来帮帮他！

## 题目描述

某一天，小 A 正走在放学回家的路上，忽然遇见了两个神仙造梦者和杰瑞米，祂们一看到小 A 就说要和小 A 玩游戏，小 A 被笼罩在金光中，莫名其妙就答应了祂们的要求。

这个游戏的规则是这样的：两个神仙先选定一个正整数 $m$，保证 $m$ 是一个奇质数 $p$ 的正整数次幂。然后进行 $n$ 轮游戏，每轮中造梦者选定一个正整数 $x$，杰瑞米选定一个正整数 $y$，保证 $(x, m) = 1, (y, m) = 1$，即 $x$ 与 $m$ 互质，$y$ 与 $m$ 互质，接下来询问小 A 是否存在非负整数 $a$ 使得 $x^a \equiv y \pmod{m}$。

神仙们说小 A 只有在每一轮游戏中都回答正确才能回到正常的生活中，不得已之下他只好求助于聪明的你。


## 说明/提示

**样例解释**

$1^a \equiv 1 \not \equiv 4 \pmod {9}$。

$2^6 \equiv 64 \equiv 1 \pmod {9}$。

$7^2 \equiv 49 \equiv 4 \pmod {9}$。

**数据范围**

本题共 $7$ 个子任务，你需要通过一个子任务内的所有测试点才能取得这个子任务的分数。

对于所有数据满足 $1\le n\le 2\times 10^4$，$3\le m \le 10^{18}$，$1 \le x, y < m$ 。

| #    | 分数 | $n$                      | $m$                 | 特殊性质1 | 时间限制 |
| ---- | ---- | ------------------------ | ------------------- | --------- | --------- |
| 1    | 3    | $\le 5$            | $\le 10^6$    | ×         |  1s |
| 2    | 37   | $\le 5$            | $\le 10^9$    | ×         | 1s |
| 3    | 22   | $= 1$                    | $\le 10^{18}$ | ×         | 1s |
| 4    | 13   | $\le 100$          | $\le 10^{18}$ | √         | 1s |
| 5    | 10   | $\le 100$          | $\le 10^{18}$ | ×         | 1s |
| 6    | 5   | $\le 2000$         | $\le 10^{18}$ | ×         | 1s |
| 7    | 10   | $\le 2\times 10^4$ | $\le 10^{18}$ | ×         | 3s |

特殊性质1：令 $m = p^{a}$，则 $p$ 是在 $[3, 10^{18}]$ 等概率选取的一个素数。

**提示**

本题可以使用 `__int128`。

## 样例 #1

### 输入

```
9 3
1 4
2 1
7 4```

### 输出

```
No
Yes
Yes```

## 样例 #2

### 输入

```
29788562298698657 10
4623623705787050 4128735493476588
29371111781967946 19402395181570597
23313713550468151 18155134012955455
654639695903289 323875358727922
15727861955653242 26658913688488667
10815360622718474 4625834559167483
10836636083182170 10347869939717751
8972909638986721 1887397472131862
23442032136521081 29735793306181382
325363900801763 6960017105353559
```

### 输出

```
Yes
No
No
Yes
Yes
Yes
No
Yes
Yes
No
```

# 题解

## 作者：双管荧光灯 (赞：20)

神仙题。。。。。。

首先指标肯定是求不出来的，BSGS肯定不能想

我们两边分别取以原根为底数的离散对数，方程可化为：

$$alog_gx \equiv log_gy$$

令$log_gx=x',log_gy=y'$

则有方程

$$ax' \equiv y'(mod\ \phi(m))$$

可化为：

$$ax'-b\phi(m) \equiv y'$$

根据裴蜀定理，则$gcd(x',\phi(m))|y'$，而这等价于$gcd(x',\phi(m))|gcd(y',\phi(m))$

所以现在关键就是求$gcd(x',\phi(m))$

我们找到$x$的阶$a$，即最小的$a$使得$x^a \equiv 1 (mod\ m)$

令$x=g^i$（其实这里的$i$就是$x'$)，则有$g^{ia} \equiv 1 (mod\ m)$

因为$g$的阶是$\phi(m)$，所以$phi(m)|ia$

设$ia=k\phi(m)$，由于a是最小的整数使得k也为整数，所以可以得出$a=\frac{lcm(i,\phi(m))}{i}$，因此$a=\phi(m)/gcd(\phi(m),i)$

所以$gcd(\phi(m),i)=\frac{\phi(m)}{a}$

这样就求出$gcd(x',\phi(m))$了，对$y'$也同理

所以求出阶就可以快速判断，使用试除法即可在log时间内求出

感谢@rushcheyo神仙的指导QwQ

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rg register
#define RP(i,a,b) for(register int i=a;i<=b;++i)
#define DRP(i,a,b) for(register int i=a;i>=b;--i)
#define fre(z) freopen(z".in","r",stdin),freopen(z".out","w",stdout)
typedef long long ll;
typedef double db;
#define lll __int128
template<class type_name> inline type_name qr(type_name sample)
{
    type_name ret=0,sgn=1;
    char cur=getchar();
    while(!isdigit(cur))
        sgn=(cur=='-'?-1:1),cur=getchar();
    while(isdigit(cur))
        ret=(ret<<1)+(ret<<3)+cur-'0',cur=getchar();
    return sgn==-1?-ret:ret;
}

ll max_factor;

inline ll gcd(ll a,ll b)
{
    if(b==0)
        return a;
    return gcd(b,a%b);
}

inline ll qp(ll x,ll p,ll mod)
{
    ll ans=1;
    while(p)
    {
        if(p&1)
            ans=(lll)ans*x%mod;
        x=(lll)x*x%mod;
        p>>=1;
    }
    return ans;
}

inline bool mr(ll x,ll b)
{
    ll k=x-1;
    while(k)
    {
        ll cur=qp(b,k,x);
        if(cur!=1 && cur!=x-1)
            return false;
        if((k&1)==1 || cur==x-1)
            return true;
        k>>=1;
    }
    return true;
}

inline bool prime(ll x)
{
    if(x==46856248255981ll || x<2)
        return false;
    if(x==2 || x==3 || x==7 || x==61 || x==24251)
        return true;
    return mr(x,2)&&mr(x,61);
}

inline ll f(ll x,ll c,ll n)
{
    return ((lll)x*x+c)%n;
}

inline ll PR(ll x)
{
    ll s=0,t=0,c=1ll*rand()%(x-1)+1;
    int stp=0,goal=1;
    ll val=1;
    for(goal=1;;goal<<=1,s=t,val=1)
    {
        for(stp=1;stp<=goal;++stp)
        {
            t=f(t,c,x);
            val=(lll)val*abs(t-s)%x;
            if((stp%127)==0)
            {
                ll d=gcd(val,x);
                if(d>1)
                    return d;
            }
        }
        ll d=gcd(val,x);
        if(d>1)
            return d;
    }
}
long long p,o,fa[105],num;
inline void fac(ll x)
{
	if(x<2)
		return;
    if(prime(x))
    {
    	fa[++o]=x;
      	return;
    }
    ll p=x;
    while(p>=x)
        p=PR(x);
    fac(p),fac(x/p);
}
long long m,tot,x,y,phi,i,j;
int main()
{
	cin>>m>>tot;
	fac(m);
	p=fa[1];
	phi=m/p*(p-1);
	num=o;
	--o;
	fac(p-1);
	sort(fa+1,fa+1+o);
	while(tot--)
	{
		scanf("%lld %lld",&x,&y);
		ll tmp=phi;
		for(i=1;i<=o;)
		{
			for(j=i;j<=o&&fa[i]==fa[j];j++)
			{
				if(qp(x,tmp/fa[i],m)==1)
					tmp/=fa[i];
				else
					break;
			}
			for(;j<=o&&fa[i]==fa[j];j++);
			i=j;
		}
		ll t=phi;
		for(i=1;i<=o;)
		{
			for(j=i;j<=o&&fa[i]==fa[j];j++)
			{
				if(qp(y,t/fa[i],m)==1)
					t/=fa[i];
				else
					break;
			}
			for(j=i;j<=o&&fa[i]==fa[j];j++);
			i=j;
		}
		tmp=phi/tmp;
		t=phi/t;
		if(t%tmp==0)
			puts("Yes");
		else
			puts("No");
	}
}
```


---

## 作者：小粉兔 (赞：19)

### 题意简述：

给定正整数 $m$，保证 $m = p^k$（$p \in \mathbb{P} \backslash \{ 2 \}$，$k \ge 1$，$m \le {10}^{18}$）。

接下来给出 $n$ 组独立的询问，每组询问给定两个正整数 $x, y$（$1 \le x, y < m$ 且 $x, y \perp m$），询问是否存在非负整数 $a$ 满足 $x^a \equiv y \pmod{m}$。

### 题解：

因为 $m$ 是奇质数的次幂，所以一定存在**原根** $g$（满足 $g$ 的 $0$ 到 $\varphi(m) - 1$ 次幂可以组成模 $m$ 的简化剩余系，即不重复不遗漏地遍历了所有可能的值）。

记 $\mathrm{ind}_g\,a$ 为满足 $g^k \equiv a \pmod{m}$，且 $0 \le k < \varphi(m)$ 的 $k$，即 $a$ 模 $m$ 对原根 $g$ 的**指标**。可以看作是以 $k$ 为自变量的 $f_g(k) = g^k \bmod m$ 的反函数。

关于指标有运算法则：$\mathrm{ind}_g(ab) \equiv \mathrm{ind}_g\,a + \mathrm{ind}_g\,b \pmod{\varphi(m)}$，相当于对数函数，可以把模意义下的乘法化乘为加。

同时我们有集合 $S_a = \{ a^0, a^1, a^2, a^3, \ldots \}$ 为 $a$ 的次幂组成的集合。显然集合内的数的指标均是 $\mathrm{ind}_g\,a$ 的倍数（模 $\varphi(m)$ 意义下）。

不难发现有 $|S_a| = \dfrac{\varphi(m)}{\gcd(\mathrm{ind}_g\,a, \varphi(m))}$，且 $S_a$ 中的数的指标都是 $\gcd(\mathrm{ind}_g\,a, \varphi(m))$ 的倍数。

特别地，$S_a$ 的大小被称为 $a$ 模 $m$ 的**阶**，记作 $\mathrm{ord}\,a$，同时它也等价于满足 $a^k \equiv 1 \pmod{m}$ 的最小正整数 $k$。

说了这么多，结合上述结论，可以得到：若存在非负整数 $a$ 满足 $x^a \equiv y \pmod{m}$ 当且仅当 $\mathrm{ord}\,b \mid \mathrm{ord}\,a$。

接下来转化为求阶的问题。阶都是 $\varphi(m)$ 的因数，将 $\varphi(m)$ 分解质因数并试除即可。

使用 Pollard-Rho 算法分解质因数，快速幂时需要使用 `__int128`。

时间复杂度为期望 $\mathcal{O}(\mathcal{T}(\mathrm{Pollard-Rho}) + n \: \omega(m) \log m)$，代码如下：

```cpp
#include <cstdio>
#include <cmath>
#include <random>
#include <chrono>
#include <algorithm>

std::mt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count());
template<typename T> inline T range(T l, T r) { return std::uniform_int_distribution<T>(l, r)(rng); }

typedef long long LL;
typedef __int128 LLL;

inline LL qPow(LL b, LL e, LL m) {
	if (!m) {
		#define Lim 0x3f3f3f3f3f3f3f3f
		LL a = 1;
		for (; e; e >>= 1, b = Lim / b >= b ? b * b : Lim)
			if (e & 1) a = Lim / a >= b ? a * b : Lim;
		return a;
		#undef Lim
	}
	LL a = 1;
	for (; e; e >>= 1, b = (LLL)b * b % m)
		if (e & 1) a = (LLL)a * b % m;
	return a;
}
inline LL Abs(LL x) { return x < 0 ? -x : x; }
LL Gcd(LL a, LL b) { return b ? Gcd(b, a % b) : a; }

LL Mod, Phi, Prime; int Alpha;
inline LL KthRt(LL X, int K) {
	LL V = pow(X, 1. / K);
	while (qPow(V, K, 0) <= X) ++V;
	while (qPow(V, K, 0) > X) --V;
	return V;
}
void Get(LL X) {
	Alpha = 1;
	for (int i = 2; i <= 59; ++i) if (qPow(KthRt(X, i), i, 0) == X) Alpha = i;
	Prime = KthRt(X, Alpha);
}

LL Prs[65]; int Prc;
inline bool MillerRabin(LL x, LL b) {
	LL k = x - 1;
	while (k) {
		LL cur = qPow(b, k, x);
		if (cur != 1 && cur != x - 1) return 0;
		if (k & 1 || cur == x - 1) return 1;
		k >>= 1;
	} return 1;
}
inline bool isPrime(LL x) {
	if (x == 46856248255981ll || x < 2) return 0;
	if (x == 2 || x == 3 || x == 7 || x == 61 || x == 24251) return 1;
	return MillerRabin(x, 2) && MillerRabin(x, 3) && MillerRabin(x, 7) && MillerRabin(x, 61) && MillerRabin(x, 24251);
}
inline LL Func(LL x, LL b, LL m) { return ((LLL)x * x + b) % m; }
inline LL PollardRho(LL x) {
	LL s = 0, t = 0, c = range(1ll, x - 1), val = 1;
	int stp = 0, goal = 1;
	for (goal = 1; ; goal <<= 1, s = t, val = 1) {
		LL d;
		for (stp = 1; stp <= goal; ++stp) {
			t = Func(t, c, x);
			val = (LLL)val * Abs(t - s) % x;
			if (stp % 127 == 0)
				if ((d = Gcd(val, x)) > 1) return d;
		}
		if ((d = Gcd(val, x)) > 1) return d;
	}
}
void Factorize(LL Num) {
	if (isPrime(Num)) { Prs[++Prc] = Num; return ; }
	LL d = Num;
	while (d == Num) d = PollardRho(Num);
	Factorize(d), Factorize(Num / d);
}

inline LL ord(LL x) {
	LL ans = Phi;
	for (int i = 1; i <= Prc; ++i) if (qPow(x, ans / Prs[i], Mod) == 1) ans /= Prs[i];
	return ans;
}

int main() {
	int Q;
	scanf("%lld%d", &Mod, &Q);
	Get(Mod);
	Phi = Mod / Prime * (Prime - 1);
	Factorize(Phi);
	std::sort(Prs + 1, Prs + Prc + 1);
	int T = 0, cnt = 0; LL lst = 0;
	for (int i = 1; i <= Prc; ++i) {
		if (Prs[i] != lst) {
			if (lst) {
				int k = 31 - __builtin_clz(cnt);
				Prs[++T] = qPow(lst, cnt - (1 << k) + 1, 0);
				for (int j = 1; j <= k; ++j) Prs[++T] = qPow(lst, 1 << (k - j), 0);
			}
			lst = Prs[i], cnt = 0;
		} ++cnt;
	} {
		int k = 31 - __builtin_clz(cnt);
		Prs[++T] = qPow(lst, cnt - (1 << k) + 1, 0);
		for (int j = 1; j <= k; ++j) Prs[++T] = qPow(lst, 1 << (k - j), 0);
	} Prc = T;
//	printf("Phi = %lld = ", Phi);
//	for (int i = 1; i <= Prc; ++i) printf("%lld%s", Prs[i], i == Prc ? "\n" : " * ");
	while (Q--) {
		LL A, B;
		scanf("%lld%lld", &A, &B);
		A = ord(A), B = ord(B);
		puts(A % B ? "No" : "Yes");
	}
	return 0;
}
```

---

## 作者：Alex_Wei (赞：6)

> I. [P5605 小 A 与两位神仙](https://www.luogu.com.cn/problem/P5605)
>
> [数论学习笔记](https://www.cnblogs.com/alex-wei/p/Number_Theory.html)。

前置知识：[Pollard-rho & Miller-Rabin](https://www.cnblogs.com/alex-wei/p/Number_Theory_II.html)。

注意到模数 $p$ 是奇质数的幂，存在原根 $g$。

尝试将 $x$ 和 $y$ 表示成 $g ^ X$ 和 $g ^ Y$ 的形式，则根据欧拉定理，$x ^ a \equiv y\pmod p$ 等价于方程 $Xa\equiv Y\pmod {\varphi(p)}$。

根据裴蜀定理，后者存在解的充要条件是 $\gcd(X, \varphi(p)) \mid Y$，这等价于 $\gcd(X, \varphi(p)) \mid \gcd(Y, \varphi(p))$。

根据阶的性质 $\delta_p(g ^ k) = \dfrac {\delta_p(g)}{\gcd(\delta_p(g), k)}$，我们发现 $\delta_p(x) = \dfrac {\varphi(p)} {\gcd(\varphi(p), X)}$（其实这很好理解，在长为 $\varphi(p)$ 的环上每一步走 $X$ 长度，则需要 $\dfrac {\varphi(p)}{\gcd(\varphi(p), X)}$ 步才能回到原来的位置 ），因此该条件又等价于 $\delta_p(y)\mid \delta_p(x)$。

直接 $\mathrm{polylog}$ 求阶即可，在最开始需要使用 Pollard-rho 分解 $\varphi(p)$，时间复杂度 $\mathcal{O}(n\log ^ 2p + p ^ {0.25})$。

通过本题，我们得到这样的结论：对于奇质数的幂 $p$ 和 $x, y\perp p$，$x ^ a\equiv y\pmod p$ 有解当且仅当 $\delta_p(y)\mid \delta_p(x)$。

- 根据阶的性质，对于 $a = k\delta_p(x)$，必然有 $x ^ a \equiv 1\pmod p$。因此考虑首先令 $a = \varphi(p)$，然后对于 $\varphi(p)$ 的每个质因子 $q$，用 $a$ 不断试除 $q$ 直到 $a$ 无法整除 $q$ 或 $x ^ {\frac a q} \not\equiv 1\pmod p$。

```cpp
#include <bits/stdc++.h>
using namespace std;
mt19937 rnd(time(0));
int rd(int l, int r) {return rnd() % (r - l + 1) + l;}
long long ksm(__int128 a, long long b, long long p) {
	long long s = 1;
	while(b) {
		if(b & 1) s = s * a % p;
		a = a * a % p, b >>= 1;
	}
	return s;
}
bool Miller_Rabin(long long n) {
	if(n < 3 || n % 2 == 0) return n == 2;
	long long r = n - 1, d = 0;
	while(r & 1 ^ 1) r >>= 1, d++;
	for(int i = 1; i <= 15; i++) {
		long long a = rd(0, 1e9) % (n - 2) + 2, v = ksm(a, r, n);
		if(v == 1) continue;
		for(int j = 0; j <= d; j++) {
			if(j == d) return 0;
			if(v == n - 1) break;
			v = (__int128) v * v % n;
		}
	}
	return 1;
}
long long Pollard_rho(long long n) {
	long long c = rd(0, 1e9) % (n - 1) + 1, s = 0, t = 0, prod = 1;
	for(int i = 1; ; s = t, i <<= 1)
		for(int j = 1; j <= i; j++) {
			t = ((__int128) t * t + c) % n, prod = (__int128) prod * abs(s - t) % n;
			if((j % 127 == 0 || j == i) && __gcd(prod, n) > 1) return __gcd(prod, n);
		}
}

map <long long, bool> mp;
void factorize(long long n) {
	if(n == 1) return;
	if(Miller_Rabin(n)) return mp[n] = 1, void();
	long long p = Pollard_rho(n);
	while(p == n) p = Pollard_rho(n);
	while(n % p == 0) n /= p;
	factorize(p), factorize(n);
}
long long m, T, phi, x, y, dx, dy;
int main() {
	cin >> m >> T, factorize(m);
	phi = m / mp.begin() -> first * (mp.begin() -> first - 1);
	mp.clear(), factorize(phi);
	while(T--) {
		cin >> x >> y, dx = dy = phi;
		for(auto it : mp) {
			while(dx % it.first == 0 && ksm(x, dx / it.first, m) == 1) dx /= it.first;
			while(dy % it.first == 0 && ksm(y, dy / it.first, m) == 1) dy /= it.first;
		}
		if(dx % dy) puts("No");
		else puts("Yes");
	}
	return 0;
}
```

---

## 作者：Corzica (赞：4)

题目中保证了 $m$ 是一个奇质数 $p$ 的正整数次幂，已就意味着 $m$ 一定存在原根。设这个原根为 $g$。

众所周知，乘法可以通过原根转化为加法。这里我们再设 $a,b$ 分别为最小的正整数满足 $g^a \equiv x \pmod m, g^b \equiv y \pmod m$。

题目中的条件也就化为了存在正整数 $q$，满足 $pa \equiv b \pmod {\varphi(m)}$。根据裴蜀定理，等价于 $(a,\varphi(m)) \mid b$，显然可化为 $(a,\varphi(m)) \mid (b,\varphi(m))$。

又众所周知的是，$\delta_m(x)=\varphi(m)/(a,\varphi(m)),\delta_m(y)=\varphi(m)/(b,\varphi(m))$，所以我们只需要判断是否有 $\delta_m(y) \mid \delta_m(x)$ 即可。

关于快速求阶，用 Pollard-Rho 分解 $\varphi(m)$ 的质因数，然后依次确定每一个质因数上的指数即可。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
int c[15];
ll maxn;
const __int128 ONE = 1;
inline ll ksm(ll p, ll q, ll mod) {
	if (q == 1) return p;
	if (q == 0) return 1;
	if (q & 1) return ONE * p * ksm(ONE * p * p % mod, q >> 1, mod) % mod;
	return ksm(ONE * p * p % mod, q >> 1, mod);
}
bool check(ll p, ll u, ll s, ll q) {
	ll get = ksm(q, u, p);
	if (get == 1) return 1;
	int t = 1;
	while (t <= s) {
		if ((get == p - 1)) break;
		get = ONE * get * get % p;
		t++;
	}
	if (t > s) return 0;
	return 1;
}
ll gcd(ll p, ll q) {
	if (!q) return p;
	return gcd(q, p % q);
}
bool miller_rabin(ll p) {
	if (p < 3 || !(p & 1)) return (p == 2);
	if (p <= 40) {
		for (int i = 0; i <= 11; i++) if (c[i] == p) return 1;
		return 0;
	}
	ll u = p - 1, s = 0;
	while (!(u & 1)) {
		u >>= 1;
		s++;
	}
	for (int i = 0; i <= 11; i++) {
		if (!check(p, u, s, c[i])) return 0;
	}
	return 1;
}
inline ll f(ll p, ll q, ll mod) {
	return (ONE * p * p + q) % mod;
}
inline ll aabs(ll p) {
	if (p < 0) return -p;
	return p;
}
inline ll PR(ll p) {
	if (p == 4) return 2;
	ll t = 0, c = rand() % (p - 3) + 3, s = rand() % (p - 3) + 3;
	t = s;
	int step = 0, goal = 1;
	ll val = 1;
	s = f(s, c, p), t = f(f(t, c, p), c, p);
	for (goal = 1; s != t; goal = min(goal << 1, 128)) {
		val = 1;
		for (step = 1; step <= goal; ++step) {
			val = ONE * val * aabs(t - s) % p;
			if (!val) break;
			s = f(s, c, p), t = f(f(t, c, p), c, p);
		}
		ll d = __gcd(val, p);
		if (d != 1) return d;
	}
	return p;
}
ll a[1005], cnt, b[1005];
void fac(ll p) {
	if (miller_rabin(p) || p == 1) {
		a[++cnt] = p;
		return;
	}
	ll q = PR(p);
	while (q >= p) {
		q = PR(p);
	}
	while (!(p % q)) {
		p /= q;
	}
	fac(p), fac(q);
}
ll n, t;
signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	srand((unsigned int)time(0));
	c[0] = 2;
	c[1] = 3;
	c[2] = 5;
	c[3] = 7;
	c[4] = 11;
	c[5] = 13;
	c[6] = 17;
	c[7] = 19;
	c[8] = 23;
	c[9] = 29;
	c[10] = 31;
	c[11] = 37;
	ll p, q;
	cin >> n >> t;
	fac(n);
	sort(a + 1, a + cnt + 1);
	ll m = n / a[cnt] * (a[cnt] - 1);
	cnt = 0;
	fac(m);
	sort(a + 1, a + cnt + 1);
	cnt = unique(a + 1, a + cnt + 1) - a - 1;
	ll op = m;
	for (int i = 1; i <= cnt; i++) {
		if (a[i] == 1) continue;
		while (op % a[i] == 0) {
			b[i]++, op /= a[i];
		}
	}
	while (t--) {
		cin >> p >> q;
		ll ans = 1, aans = 1;
		for (int i = 1; i <= cnt; i++) {
			ll op = m / a[i];
			for (int j = b[i] - 1; j >= 0; j--, op /= a[i]) {
				if (ksm(p, op, n) != 1) {
					for (int k = 1; k <= j + 1; k++) ans *= a[i];
					break;
				}
			}
		}
		for (int i = 1; i <= cnt; i++) {
			ll op = m / a[i];
			for (int j = b[i] - 1; j >= 0; j--, op /= a[i]) {
				if (ksm(q, op, n) != 1) {
					for (int k = 1; k <= j + 1; k++) aans *= a[i];
					break;
				}
			}
		}
		if (ans % aans == 0) {
			cout << "Yes\n";
		} else {
			cout << "No\n";
		}
	}
}
```

---

## 作者：UKE_Automation (赞：1)

### P5605 小 A 与两位神仙

[$\text{Link}$](https://www.luogu.com.cn/problem/P5605)

题目就是让我们求一个离散对数，用 BSGS 直接求的话复杂度是 $O(n\sqrt m)$，显然过不了，我们需要寻找另外的办法。

发现题目中保证 $m=p^{\alpha}$，这让我们联想到原根，因为此时 $m$ 是必定有原根的。有原根对应就有了指标，所以我们对 $x^a\equiv y\pmod m$ 两边同时取指标可得 $a\gamma(x)\equiv \gamma(y)\pmod{\varphi(m)}$。那么这个同余方程有解当且仅当 $\gcd(\gamma(x),\varphi(m))\mid \gamma(y)$，它等价于 $\gcd(\gamma(x),\varphi(m))\mid \gcd(\gamma(y),\varphi(m))$。

接下来我们需要利用原根和阶的性质，根据阶的性质 $\delta_m(a^k)=\dfrac{\delta_m(a)}{\gcd(\delta_m(a),k)}$ 可知：
$$
\begin{aligned}
\delta_m(x)=\delta_m(g^{\gamma(x)})=\frac{\delta_m(g)}{\gcd(\delta_m(g),\gamma(x))}=\frac{\varphi(m)}{\gcd(\varphi(m),\gamma(x))}\\

\delta_m(y)=\delta_m(g^{\gamma(y)})=\frac{\delta_m(g)}{\gcd(\delta_m(g),\gamma(y))}=\frac{\varphi(m)}{\gcd(\varphi(m),\gamma(y))}
\end{aligned}
$$
那么由于 $\gcd(\gamma(x),\varphi(m))\mid \gcd(\gamma(y),\varphi(m))$，有 $\frac{\varphi(m)}{\gcd(\varphi(m),\gamma(y))}\mid \frac{\varphi(m)}{\gcd(\varphi(m),\gamma(x))}$，也就是 $\delta_m(y)\mid \delta_m(x)$。那么原方程有解就等价于这个条件，我们只需要求出这两个阶即可。

求阶的方法并不难，根据阶的性质可以知道，$\delta_m(x)\mid \varphi(m)$，而 $\varphi(m)=(p-1)p^{\alpha-1}$，所以我们用 Pollard-Rho 和 Miller-Rabin 分解质因数，然后利用试除法直接求出阶即可。

```cpp
#include <bits/stdc++.h>
#define il inline
#define int long long
#define ll __int128

using namespace std;

const int Maxn = 2e5 + 5;
const int Inf = 2e9;
const int Mod = 1e9 + 7;
il int qpow(int a, int b, int P = Mod) {int res = 1; for(; b; a = (ll)a * a % P, b >>= 1) if(b & 1) res = (ll)res * a % P; return res;}
template <typename T> il void chkmax(T &x, T y) {x = (x >= y ? x : y);}
template <typename T> il void chkmin(T &x, T y) {x = (x <= y ? x : y);}
template <typename T>
il void read(T &x) {
	x = 0; char ch = getchar(); bool flg = 0;
	for(; ch < '0' || ch > '9'; ch = getchar()) flg = (ch == '-');
	for(; ch >= '0' && ch <= '9'; ch = getchar()) x = (x << 1) + (x << 3) + (ch ^ 48);
	flg ? x = -x : 0;
}
template <typename T>
il void write(T x, bool typ = 1) {
	static short Stk[50], Top = 0;
	x < 0 ? putchar('-'), x = -x : 0;
	do Stk[++Top] = x % 10, x /= 10; while(x);
	while(Top) putchar(Stk[Top--] | 48);
	typ ? putchar('\n') : putchar(' ');
}
il void IOS() {ios::sync_with_stdio(0); cin.tie(0), cout.tie(0);}
il void File() {freopen("in.txt", "r", stdin); freopen("out.txt", "w", stdout);}
bool Beg;

int m, n, x, y;
int prim[15] = {0, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41};

bool Miller_Rabin(int x) {
	if(x == 2) return 1;
	int t = x - 1, k = 0;
	while(!(t & 1)) t >>= 1, k++;
	for(int i = 1; i <= 13; i++) {
		if(x == prim[i]) return 1;
		int a = qpow(prim[i] % x, t, x), nxt;
		for(int j = 1; j <= k; j++) {
			nxt = (ll)a * a % x;
			if(nxt == 1 && a != 1 && a != x - 1) return 0;
			a = nxt;
		}
		if(a != 1) return 0;
	}
	return 1;
}

mt19937_64 rnd(time(0));
int F(int x, int c, int n) {
	return ((ll)x * x % n + c) % n;
}

int Pollard_Rho(int n, int c) {
	int a, b, i = 1, k = 2, val = 1;
	a = rnd() % (n - 1) + 1, b = a;
	while(1) {
		a = F(a, c, n);
		val = (ll)val * abs(a - b) % n;
		if(i % 127 == 0) {
			int d = __gcd(val, n);
			if(d > 1) return d;
		}
		if(a == b) return n;
		if(++i == k) {
			k <<= 1; b = a;
			int d = __gcd(val, n);
			if(d > 1) return d;
		}
	}
}

int fac[Maxn], tot;
void Div(int x) {
	if(x == 1) return ;
	if(Miller_Rabin(x)) {
		fac[++tot] = x;
		return ;
	}
	int p = x;
	while(p >= x) p = Pollard_Rho(x, rnd() % (x - 1) + 1);
	Div(p), Div(x / p);
}

bool End;
il void Usd() {cerr << (&Beg - &End) / 1024.0 / 1024.0 << "MB " << (double)clock() * 1000.0 / CLOCKS_PER_SEC << "ms\n"; }
signed main() {
	read(m), read(n);
	Div(m); int phi = (fac[1] - 1) * (m / fac[1]);
	tot = 0; Div(phi);
	sort(fac + 1, fac + tot + 1); tot = unique(fac + 1, fac + tot + 1) - fac - 1;
	while(n--) {
		int x, y;
		read(x), read(y);
		int px = phi, py = phi;
		for(int i = 1; i <= tot; i++) {
			while(px % fac[i] == 0 && qpow(x, px / fac[i], m) == 1) px /= fac[i];
			while(py % fac[i] == 0 && qpow(y, py / fac[i], m) == 1) py /= fac[i];
		}
		if(px % py) puts("No");
		else puts("Yes");
	}
    Usd();
	return 0;
}
```

---

## 作者：ShiRoZeTsu (赞：1)

题意简述：给定一个 $m = p^k$，其中 $p$ 是一个奇素数。每次询问给定 $x, y$，保证 $\gcd(x, m) = 1, \gcd(y, m) = 1$，求是否存在 $a$，满足：
$$
x^a \equiv y \pmod m
$$

$$
 \ 
$$

**前置知识：Pollard-Rho**

### 阶与原根

**阶**：最小的使得 $a^k \equiv 1 \pmod m$ 成立的 $k$ 即为 $a$ 在模 $m$ 意义下的阶。记为 $\delta_m(a) = k$。

若 $a$ 与 $m$ 不互质，那么这个阶不存在；否则由**欧拉定理**不难得知 $\delta_m(a)$ 一定 $\leq \varphi(m)$，因为此时 $a^{\varphi(m)} \equiv 1 \pmod m$。

实际上这个 $\delta_m(a)$ 就是 $a$ 的幂的最小循环节。

**原根**： 若有 $\delta_m(a) = \varphi(m)$，我们称 $a$ 为 $m$ 的一个原根。

$$
 \ 
$$

说了阶和原根，那么和这道题有什么关系呢？

实际上，对于题目的条件，有这样一条性质：

- 若有 $\gcd(x, m) = 1$，则一定存在 $a$ 满足 $x \equiv g^a \pmod {m}$，其中 $g$ 是 $m$ 的一个原根。

也就是说比一个数小的，与它互质的数，一定能用它原根（如果有）的某个幂表示出来。

怎么去理解这一条呢？

首先由欧拉函数的定义，比 $m$ 小且与其互质的数一共有 $\varphi(m)$ 个。

然后 $g$ 是 $m$ 的一个原根，表明 $g^a$（$0 \leq a < \varphi(m)$）在模 $m$ 意义下一共有 $\varphi(m)$ 种不同的取值（因为此时 $g$ 幂的最小循环节达到上限 $\varphi(m)$）。

接下来，考虑有一个 $g^a$（$0 \leq a < \varphi(m)$），我们只要能证明 $\gcd(g^a, m) = 1$ 就行了。

这一点是很显然的，因为有 $g^a \times g^{\varphi(m)-a} \equiv 1 \pmod m$，也就是说 $g^a$ 在模 $m$ 意义下存在**逆元**，那么它们一定互质。

由于 $g^a$ 取值有 $\varphi(m)$ 种，且均与 $m$ 互质，因此这个性质成立。

$$
 \ 
$$

回到这道题，我们知道 $\gcd(x, m) = 1, \gcd(y, m) = 1$，所以一定存在 $b, c$，满足：
$$
\begin{aligned}
x \equiv g^b \pmod m \\
y \equiv g^c \pmod m \\
\end{aligned}
$$
其中 $g$ 是 $m$ 的一个原根。由于 $m = p^k$，所以原根一定存在。

因此题中的式子可以转换成：
$$
g^{ab} \equiv g^c \pmod m
$$
由于 $g^{\varphi(m)} \equiv 1 \pmod m$，所以 $g^p \equiv g^{p \bmod \varphi(m)} \pmod m$。

也就是说：
$$
ab \equiv c  \pmod {\varphi(m)}
$$
即：
$$
ab + \lambda \varphi(m) = c
$$


只要该方程有解，那么就符合题意。

$$
 \ 
$$


运用**裴蜀定理**，我们知道方程有解的条件是 $\gcd(b, \varphi(m)) | c$。

然后怎么转化这个条件呢，我们不妨考虑 $b$ 与 $\varphi(m)$ 之间的关系。

我们将 $g$ 的幂，这个长度为 $\varphi(m)$ 的循环节想象成一个环，那么每个 $g^b$ 就相当于在环上走长度为 $b$ 的一步。

那么这样一步一步地走，走多远能走到起点呢？不难想到应该是 ${\rm lcm}(b, \varphi(m))$。

此时走了多少步呢？因为每一步长度为 $b$，所以走的步数就是 $\frac{{\rm lcm}(b, \varphi(m))}{b}$。

$$
 \ 
$$


哎？等等，这不就是**阶**吗？

也就是说 $g^b$ 的幂的最小循环节，就是 $\frac{{\rm lcm}(b, \varphi(m))}{b}$，因为走了这些步之后，$g^b$ 回到了出发点。也就是说：
$$
(g^b)^{\frac{{\rm lcm}(b, \varphi(m))}{b}} \equiv 1 \pmod m
$$
所以 $\frac{{\rm lcm}(b, \varphi(m))}{b}$ 就是 $x = g^b$ 在模 $m$ 意义下的阶，即：
$$
\frac{{\rm lcm}(b, \varphi(m))}{b} = \delta_m(x)
$$
化一化这个 ${\rm lcm}$：
$$
\begin{aligned}
\frac{\frac{b \times \varphi(m)}{\gcd(b, \varphi(m))}}{b} & = \delta_m(x) \\
\frac{\varphi(m)}{\gcd(b, \varphi(m))} & = \delta_m(x) \\
\gcd(b, \varphi(m)) & = \frac{\varphi(m)}{\delta_m(x)} \\
\end{aligned}
$$
所以回到上面的条件：
$$
\gcd(b, \varphi(m)) | c \iff \frac{\varphi(m)}{\delta_m(x)} | \ c
$$
然后你发现右面这个 $c$ 太丑陋了，和左边的阶一点也不般配。实际上 $c$ 也可以化成与 $\varphi(m)$ 的 $\gcd$ 的形式，也就是说：
$$
\gcd(b, \varphi(m)) | c \iff \gcd(b, \varphi(m)) | \gcd(c, \varphi(m))
$$
这是因为，$\gcd(b, \varphi(m))$ 一定是 $\varphi(m)$ 的因数，所以他们之间是等价的。

然后把 $\gcd$ 都换一下：
$$
\frac{\varphi(m)}{\delta_m(x)} | \frac{\varphi(m)}{\delta_m(y)}
$$
 也就是：
$$
\delta_m(y) | \delta_m(x)
$$
条件就转化完了。
$$
 \ 
$$
所以只要能快速求出阶即可解决问题。

现在我们只要求出 $\varphi(m)$ 以及它所有的质因数就可以了。这个可以用 `Pollard-Rho`。

`Pollard-Rho` 的时间复杂度为 $\mathcal{O}(\sqrt[4]{m})$，一共 $T$ 组数，单次求阶复杂度为 $\mathcal{O}(\omega(m) \log m)$。

总时间复杂度 $\mathcal{O}(\sqrt[4]{m} + T\omega(m) \log m)$。

$$
 \ 
$$


Code:

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <ctime>
#include <algorithm>
using namespace std;
typedef long long ll;

int n, tot;
int test[] = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37 } ;
ll m, phi;
ll p[105];

//这里是 Pollard_Rho 板子

ll gcd(ll a, ll b) {
	if(!b) return a;
	return gcd(b, a%b);
}

inline ll f(ll a, ll c, ll mod) { return ((__int128)a * a + c) % mod; }

inline ll fpm(ll a, ll k, ll mod) {
	ll res = 1;
	while(k) {
		if(k&1) res = (__int128)res * a % mod;
		a = (__int128)a * a % mod;
		k >>= 1;
	}
	return res;
}

inline bool check(ll a, ll p) {
	ll d = p-1, g = fpm(a, d, p);
	if(g != 1) return false;
	while((d&1)^1) {
		d >>= 1;
		if((g = fpm(a, d, p)) == p-1) return true;
		else if(g != 1) return false;
	}
	return true;
}

inline bool isp(ll x) {
	if(x > 40) {
		for(int i = 0; i < 12; i++)
			if(!check(test[i], x)) return false;
		return true;
	}
	for(int i = 0; i < 12; i++)
		if(test[i] == x) return true;
	return false;
}

inline ll pollard_rho(ll x) {
	ll val = 1, s = 0, t = 0, c = 1ll * rand() % (x-1) + 1;
	for(int goal = 1; ; goal <<= 1, s = t, val = 1) {
		for(int stop = 1; stop <= goal; stop++) {
			t = f(t, c, x);
			val = (__int128) val * abs(s-t) % x;
			if(stop % 127 == 0) {
				ll d = gcd(val, x);
				if(d > 1) return d;
			}
		}
		ll d = gcd(val, x);
		if(d > 1) return d;
	}
}

void frac(ll x) {
	if(x == 1) return;
	//max log
	if(isp(x)) { p[++tot] = x; return; }
	ll p = x;
	while(p == x) p = pollard_rho(x);
	while(x%p == 0) x /= p;
	frac(p); frac(x);
}

inline ll del(ll a) {
	int cnt;
	ll ans = 1, pm;
	for(int i = 1; i <= tot; i++) {
		cnt = 0; pm = phi;
		while(pm%p[i] == 0) pm /= p[i], cnt++;
		//for 循环枚举阶在这个质因数上最小的次数
		for(ll px = 1; cnt; px *= p[i], cnt--)
			if(fpm(a, pm*px, m) > 1)
				ans *= p[i];
	}
	return ans;
}

int main() {
	srand(time(NULL));

	scanf("%lld %d", &m, &n);
	frac(m);
	//先找到 m 唯一的那个质因数

	phi = m / p[1] * (p[1] - 1);
	//然后算出 phi 值
	tot = 0;
	frac(phi);
	sort(p+1, p+1+tot);
	tot = unique(p+1, p+1+tot) - p - 1;
	//给 phi 分解质因数，用来求阶
	//get phi factors

    ll x, y;
	for(int i = 1; i <= n; i++) {
		scanf("%lld %lld", &x, &y);
		y = del(y), x = del(x);
		if(x%y) printf("No\n");
		else printf("Yes\n");
	}
	return 0;
}
```

$$
 \ 
$$

在写这道题的时候还没有学过原根和 Pollard-Rho 算法，在看了许多大佬的讲解后才看懂，所以来写这篇题解做一个总结与细节的分析，使用了尽可能简单的语言。希望可以帮到你。

感谢阅读！有不到之处敬请指正。



---

## 作者：OIer_Automation (赞：0)

题目是幂的形式，但不能直接用 bsgs，并且 $m$ 可以写成 $p^\alpha$ 的形式，于是可以考虑原根。设 $m$ 的原根为 $g$，那么因为 $\gcd(x,m)=\gcd(y,m)=1$，于是有 $x=g^{\text{ind}_gx},y=g^{\text{ind}_gy}$，于是方程可以改写为
$$
\begin{aligned}x^a\equiv y\pmod m&\Rightarrow (g^{\text{ind}_gx})^a\equiv g^{\text{ind}_{g}y}\pmod m\\&\Rightarrow g^{a\text{ind}_gx}\equiv g^{\text{ind}_gy}\pmod m\\&\Rightarrow a\text{ind}_gx\equiv \text{ind}_gy\pmod{\varphi(m)}\\&\Rightarrow a\text{ind}_gx+\lambda\varphi(m)=\text{ind}_gy \end{aligned}
$$
根据裴蜀定理可以得到方程有解当且仅当 $\gcd(\text{ind}_gx,\varphi(m))|\text{ind}_gy$，考虑到只有一边 $\gcd$ 较为难看，因为 $\gcd(\text{ind}_gx,\varphi(m))|\varphi(m)$，所以可以推出 $\gcd(\text{ind}_gx,\varphi(m))|\gcd(\text{ind}_gy,\varphi(m))$。考虑如何化简 $\gcd$，考虑 $g$ 关于 $m$ 的简化剩余系是一个 $\varphi(m)$ 的环，而 $g^{\text{ind}_gx}$ 相当于一次走 $\text{ind}_gx$ 步，那么第一次走会到原点需要走 $\dfrac{\text{lcm}(\text{ind}_gx,\varphi(m))}{\text{ind}_gx}$ 步，考虑这个内容的意义，不难发现这个答案即为 $\text{ord}_mx$，也就是 $x$ 的阶。同时，我们化简 $\text{lcm}$ 得到 $\dfrac{\text{lcm}(\text{ind}_gx,\varphi(m))}{\text{ind}_gx}=\dfrac{\varphi(m)}{\gcd(\text{ind}_gx,\varphi(m))}$，也就是 $\gcd(\text{ind}_gx,\varphi(m))=\dfrac{\varphi(m)}{\text{ord}_mx}$，到这里我们可以把式子进一步写作
$$
\gcd(\text{ind}_gx,\varphi(m))|\gcd(\text{ind}_gy,\varphi(m))\Rightarrow\frac{\varphi(m)}{\text{ord}_mx}|\frac{\varphi(m)}{\text{ord}_my}\Rightarrow \text{ord}_my|\text{ord}_mx
$$
因此只需要求出 $\text{ord}_mx$ 即可快速求解，这个内容可以在快速分解 $\varphi(m)$ 的质因子后用试除法做到 $O(\omega(m)\log m)$。求出 $\varphi(m)$ 需要得知 $m$ 具体由哪一个 $p$ 组成，包括快速分解大数质因子，都可以使用 Pollard-Rho 算法做到 $O(m^{0.25})$，因此总复杂度是 $O(m^{0.25}+T\omega(m)\log m)$。 

```cpp
#include <bits/stdc++.h>
using namespace std;
#define il inline
#define ll long long
#define LL __uint128_t

const int test[]={2,3,5,7,11,13,17,19,23,29,31,37};

int n,tot;
ll m,prm,phi;
ll fac[20];
mt19937_64 Rnd(time(0)+20100511);

il ll Qpow(ll a,ll b,ll p){ll res=1;for(;b;b>>=1,a=(LL)a*a%p)if(b&1)res=(LL)res*a%p;return res;}
il bool Check(int a,ll p){
	ll d=p-1,tmp=Qpow(a,d,p);
	if(tmp!=1)return true;
	for(;!(d&1);){
		if(d>>=1,(tmp=Qpow(a,d,p))==p-1)return false;
		if(tmp!=1)return true;
	}
	return false;
}
il bool MR(ll p){
	if(p>40){
		for(int a:test)if(Check(a,p))return false;
		return true;
	}
	for(int a:test)if(a==p)return true;
	return false;
}
il ll f(ll x,ll c,ll n){return ((LL)x*x+c)%n;}
il ll PR(ll x){
	ll s=0,t=0,c=Rnd()%(x-1)+1,val,d;
	for(int tmp=1;val=1;tmp<<=1,s=t){
		for(int stp=1;stp<=tmp;stp++){
			t=f(t,c,x),val=(LL)val*abs(t-s)%x;
			if(!(stp&127))if((d=__gcd(val,x))>1)return d;
		}
		if((d=__gcd(val,x))>1)return d;
	}
}
il ll Prm(ll x){
	if(MR(x))return x;
	ll d1=x,d2;
	for(;d1==x;d1=PR(x));
	return d1<=(d2=x/d1)?Prm(d1):Prm(d2);
}
il void Divs(ll x){
	if(x==1)return ;
	if(MR(x))return fac[++tot]=x,void();
	ll d1=x,d2=x;
	for(;d1==x;d1=PR(x));for(;!(d2%d1);d2/=d1);
	Divs(d1),Divs(d2);
}
il ll Ord(ll a){ll res=phi;for(int i=1;i<=tot;i++)for(;!(res%fac[i])&&Qpow(a,res/fac[i],m)==1;res/=fac[i]);return res;}

int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>m>>n,prm=Prm(m),phi=m/prm*(prm-1),Divs(phi),sort(fac+1,fac+1+tot),tot=unique(fac+1,fac+1+tot)-fac-1;
	for(ll x,y;n--;)cin>>x>>y,x=Ord(x),y=Ord(y),cout<<(x%y?"No\n":"Yes\n");
}
```

---

## 作者：__O_v_O__ (赞：0)

想要理解原根，你需要先了解阶。

#### 定义

我们把满足 $a^x\equiv 1\pmod{m}$ 的最小正整数 $x$ 称为 $a$ 模 $m$ 的阶，记作 $\delta_m(a)$。

显然 $a\perp m$ 是 $\delta_m(a)$ 存在的充要条件，于是下面假设 $a\perp m$。

#### 性质

1. $a^0,a^1,\cdots,a^{\delta_m(a)}$ 在模 $m$ 下一定互不相同。

>**证明：**
>
>使用反证法，假设 $1\le x<y<\delta_m(a)$，且 $a^x\equiv a^y\pmod{m}$。
>
>那么 $a^{y-x}\equiv 1\pmod{m}$，而 $y-x<\delta_m(a)$，说明 $\delta_m(a)$ 不是最小循环节，矛盾。

2. $a^x\equiv 1\pmod{m}$ 当且仅当 $\delta_m(a)\mid x$。

>**证明：**
>
>感性理解：$x$ 是 $\delta_m(a)$ 的整数倍，说明 $a$ 的次方跳了整数个循环，模 $m$ 一定还是 $1$。
>
>$x$ 不是 $\delta_m(a)$ 的整数倍，说明跳到 $1$ 之后还跳了几步，且没有到达下一个 $1$。因为每个循环 $\delta_m(a)$ 都不同，所以模 $m$ 一定不是 $1$。

3. $\delta_m(a^k)=\frac{\delta_m(a)}{\gcd(\delta_m(a),k)}$。

>**证明：**
>
>考虑一个数自身相乘时，它的阶如何变化。如果我们将模 $m$ 下 $a$ 的幂次看成一个长为 $\delta_m(a)$ 的环，那么 $a$ 的幂次相当于在环上每次跳一步，$a^k$ 的幂次相当于在环上每次跳 $k$ 步。手模一下即可。

4. $\delta_m(ab)=\delta_m(a)\delta_m(b)$ 当且仅当 $\delta_m(a)\perp\delta_m(b)$。

#### 求法

显然，如果 $x$ 为 $\delta_m(a)$ 的倍数，那么必然有 $a^x\equiv 1\pmod{m}$。

因为阶都是 $\varphi(m)$ 的因数，于是考虑令 $t=\varphi(m)$，枚举 $\varphi(m)$ 的因数 $p$，用 $t$ 不断试除 $p$ 直到 $t$ 不整除 $p$ 或者 $a^{\frac{t}{p}}\not\equiv 1\pmod{m}$。

最后剩下的 $t$ 就是得到的阶。

---

有了阶的基础，现在让我们进入原根的学习。

#### 定义

若 $\delta_m(a)=\varphi(m)$，则称 $a$ 为模 $m$ 的原根。并不是所有数都有原根。

#### 性质

1. **原根判定定理**

$a$ 是 $m$ 的原根，当且仅当对任意 $\varphi(m)$ 的质因子 $p$，均有 $a^{\frac{\varphi(m)}{p}}\not\equiv 1\pmod{m}$。

>**证明：**
>
>还是用反证法。假设存在一个 $k$，使得它满足上面的条件，却不是 $m$ 的原根。
>
>于是，$k$ 的阶应满足 $\delta_m(k)<\varphi(m)$ 且 $\delta_m(k)\mid\varphi(m)$，所以存在 $\varphi(m)$ 的质因子 $p$ 满足 $\delta_m(k)\mid\frac{\varphi(m)}{p}$。
>
>而根据阶的性质 $a^{\delta_m(k)}\equiv 1\pmod{m}$，于是 $a^{\frac{\varphi(m)}{p}}\equiv a^{\delta_m(k)}\equiv 1\pmod{m}$，矛盾。

2. **原根存在定理**

$m$ 有原根当且仅当 $m=2,4,p^a,2p^a$，其中 $p$ 是奇质数。

3. **原根个数定理**

若正整数 $m$ 有原根，则原根个数为 $\varphi(\varphi(m))$。

4. **最小原根的范围**

任何有原根的数，最小原根一定不超过 $O(m^{0.25})$ 数量级。

#### 求法

根据原根判定定理和最小原根的范围，我们可以预处理每个数的最小质因子后 $O(m^{0.25}w(m)\log m)$ 求出某数的最小原根，从而求出它的所有原根。

---

上面的内容其实是在为本题的解法做铺垫。接下来我们来了解一下原根的用处。

它应用的关键是一个性质：原根的若干次幂在模 $m$ 意义下取遍了所有与 $m$ 互质的数。于是我们在考虑解与模数互质且模数存在原根的同余方程时可以用原根的若干次幂代替未知数，在求解高次剩余时非常有用。

看这道题：根据题目条件，$m$ 存在原根 $g$。因为 $x$ 与 $m$ 互质，而 $g$ 的次方刚好可以取到所有与 $m$ 互质的数，所以必然存在 $g^{X}\equiv x\pmod{m}$。同理设 $g^{Y}\equiv y\pmod{m}$。

所以式子变为 $g^{Xa}\equiv g^{Y}\pmod{m}$，所以 $Xa\equiv Y\pmod{\varphi(m)}$。根据裴蜀定理，它有解当且仅当 $\gcd(X,\varphi(m))\mid Y$，这等价于 $\gcd(X,\varphi(m))\mid\gcd(Y,\varphi(m))$。

又因为 $\delta_m(x)=\frac{\delta_m(g)}{\gcd(\delta_m(g),X)}$，所以条件又等价于 $\delta_m(y)\mid\delta_m(x)$。直接使用上面的方法求阶即可。需要使用 Pollard-Rho。

**AC code:**

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define lll __int128
int m,n,x,y,s[2000001],nu,ph;
int gcd(int x,int y){
	if(!y)return x;
	return gcd(y,x%y);
}
int pw(int a,int b,int p){
	int an=1;
	while(b){
		if(b&1)an=(lll)an*a%p;
		a=(lll)a*a%p,b>>=1;
	}
	return an;
}
bool mr(int x){//Miller-Rabin
	if(x<2)return 0;
	if(x==2||x==3)return 1;
	int t=0,k=x-1;
	while(!(k&1))k>>=1,t++;
	for(int i=1;i<=8;i++){
		int a=rand()%(x-2)+2;
		int b=pw(a,k,x);
		bool fl=0;
		if(b==1)continue;
		for(int j=0;j<t;j++){
			if(b==x-1)break;
			else b=(lll)b*b%x;
		}
		if(b!=x-1)return false;
	}
	return true;
}
int f(int x,int c,int p){
	return ((lll)x*x%p+c)%p;
}
int pr(int x){//Pollard-Rho
	int s=0,t=0,v=1,c=rand()%(x-1)+1;
	for(int li=1;;li*=2,s=t,v=1){
		for(int q=1;q<=li;q++){
			t=f(t,c,x);
			v=(lll)v*abs(t-s)%x;
			if(q%127==0){
				int d=gcd(v,x);
				if(d>1)return d;
			}
		}
		int d=gcd(v,x);
		if(d>1)return d;
	}
}
void fa(int x){//分解质因数
	if(x<2)return;
	if(mr(x)){
		s[++nu]=x;
		return;
	}
	int p=x;
	while(p>=x)p=pr(x);
	while(!(x%p))x/=p;
	fa(x),fa(p);
}
int ca(int x){//试除
	int an=ph;
	for(int i=1;i<=nu;i++){
		int no=s[i];
		while(1){
			if(an%no||pw(x,an/no,m)!=1)break;
			an/=no;
		}
	}
	return an;
}
signed main(){
	ios::sync_with_stdio(0);
	srand(time(0));
	cin>>m>>n,fa(m);
	ph=(lll)m*(s[1]-1)/s[1];
	fa(ph);
	while(n--){
		int x,y;cin>>x>>y;
		if(ca(x)%ca(y)==0)cout<<"Yes\n";
		else cout<<"No\n";
	}
	return 0;
}
```

---

## 作者：HappyJaPhy (赞：0)

- [推销博客](https://www.luogu.com.cn/blog/ImDustSans/solution-p5605)
- [P5605 小 A 与两位神仙](https://www.luogu.com.cn/problem/P5605)
# 题意
- 给定 $x$、$y$ 和 $m$，其中 $m=p^n,n\in \mathbb{N+},p\ge3$，问同余方程 $x^a\equiv y\pmod m$ 是否有非负整数解。

# 分析
## 前置芝士
- [Pollard_rho](https://www.luogu.com.cn/problem/P4718)
- [原根](https://oi-wiki.org/math/number-theory/primitive-root/)

## 化简
- 对这种指数型的同余方程是很难解决的，我们要先把它转化成线性的同余方程。原式很讨人厌的一点就是 $x$、$y$ 和 $a$ 并不在同一个层次上，但是把 $a$ 降下来很难 ~~（主要是我不会）~~，因此想到将 $x$ 和 $y$ 升到幂的位置上，由此联想到原根。根据原根的存在性判定我们知道 $m$ 存在原根。令 $g$ 为 $m$ 的一个原根，$i_x$ 表示使 $g^i\equiv x\bmod m$ 成立的 $i$ 值，于是有
$$x^a\equiv y\pmod m$$
等价于
$$g^{i_xa}\equiv g^{i_y}\pmod m$$
等价于
$$i_xa\equiv i_y\pmod {\varphi(m)}$$
- 这是一个线性同余方程，但是我们并不知道 $i_x$ 和 $i_y$ 的值具体为多少，所以这里需要进一步转化。上式等价于
$$\gcd(i_x,\varphi(m))\mid\gcd(i_y,\varphi(m))$$
再由 $\large\delta_m(x)=\delta_m(g^{i_x})=\frac{\varphi(m)}{\gcd(i_x,\varphi(m))}$ 可转化为
$$\frac{\varphi(m)}{\delta_m(x)}\mid\frac{\varphi(m)}{\delta_m(y)}$$
等价于
$$\delta_m(y)\mid\delta_m(x)$$
- 于是原来的问题就转化为求解 $\delta_m(x)$ 和 $\delta_m(y)$ 了，这就简化很多了，可以直接求解。

## 求解
- 求欧拉函数很简单，有多种解法，由于这里仅需要 $m$ 这一个数的 $\varphi$ 值，所以直接用 $\varphi(p^k)=p^k-p^{k-1}$ 求解即可。对于 $\delta_m(x)$，利用 $\delta_m(x)\mid\varphi(m)$ 的性质直接对 $\varphi(m)$ 进行质因数分解，一一试除即可。
- 还有，下面代码用了 `(__int128)` 的乘法不用会爆 long long，会导致各种错误，~~我为了这个也就调了 3 个小时而已吧，后面实在不行就照着 Alex_Wei 大佬的代码重改了一遍才发现，血泪教训~~。
- 还有，求 $\varphi(m)$ 的值我最初是用的 $O(\sqrt n)$ 的单个求法的，交上去 TLE 了之后才意识到会时间爆炸，参考 Alex_Wei 大佬的代码后改用分解质因数的方法（也就是上面说的做法），这种做法的复杂度是 $O(n^{\frac{1}4})$，快了不少（~~求完之后记得清空统计质因数的 map，调这玩意花了 30 分钟~~）。

# AC 代码
```cpp
#include <bits/stdc++.h>
#define int long long
#define inf 1e9
using namespace std;
int n, m, phi, x, y;
map<int, bool> mp;

inline void read(int &x) {
	char ch = x = 0;
	int m = 1;
	while (ch < '0' || ch > '9') {
		ch = getchar();
		if (ch == '-')
			m *= -1;
	}
	while (ch >= '0' && ch <= '9') {
		x = (x << 1) + (x << 3) + ch - 48;
		ch = getchar();
	}
	x *= m;
	return ;
}

int seed;
inline int rnd(int x) {
	int a = rand() % 1145 + 1;
	x *= a;
	x ^= x << 13;
	x ^= x >> 7;
	x ^= x << 17;
	x /= a;
	return abs(x);
}

int gcd(int a, int b) {
	if (b == 0) return a;
	return gcd(b, a % b);
}

inline int ksmi(__int128 a, int b, int mod) {
	int s = 1;
	while (b) {
		if (b & 1) s = a * s % mod;
		a = a * a % mod;
		b >>= 1;
	}
	return s;
}

inline bool mr(int n) {
	if (n < 3 || n % 2 == 0) return n == 2;
	int r = n - 1, d = 0;
	while ((r & 1) == 0) {
		r >>= 1;
		d++;
	}
	int a, v;
	for (int i = 1; i <= 20; i++) {
		a = seed = rnd(seed);
		a = a % (n - 2) + 2;
		v = ksmi(a, r, n);
		if (v == 1) continue;
		for (int j = 0; j <= d; j++) {
			if (j == d) return 0;
			if (v == n - 1) break;
			v = (__int128)v * v % n;
		}
	}
	return 1;
}

inline int pol(int n) {
	int s = 0, t = 0, now = 1, c = seed = rnd(seed);
	c = c % (n - 1) + 1;
	int k = 1;
	while (1) {
		for (int j = 1; j <= k; j++) {
			t = ((__int128)t * t + c) % n;
			now = (__int128)now * abs(s - t) % n;
			if ((j % 127 == 0 || j == k) && gcd(now, n) > 1) return gcd(now, n);
		}
		s = t;
		k <<= 1;
	}
}

void fac(int n) {
	if (n == 1) return;
	if (mr(n)) {
		mp[n] = 1;
		return ;
	}
	int p = n;
	while (p == n) p = pol(n);
	while (n % p == 0) n /= p;
	fac(p);
	fac(n);
	return ;
}

signed main() {
	srand((unsigned)time(0));
	seed = rand() * rand();
	read(m), read(n);
	fac(m);
	int pri = mp.begin() -> first;
	phi = m - (m / pri);
	mp.clear();
	fac(phi);
	int ordx, ordy, now;
	while (n--) {
		read(x), read(y);
		ordx = ordy = phi;
		for (auto it : mp) {
			now = it.first;
			while (ordx % now == 0 && ksmi(x, ordx / now, m) == 1) ordx /= now;
			while (ordy % now == 0 && ksmi(y, ordy / now, m) == 1) ordy /= now;
		}
		if (ordx % ordy) printf("No\n");
		else printf("Yes\n");
	}
	return 0;
}
```


---


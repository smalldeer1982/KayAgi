# [加油武汉] 传染病研究

## 题目描述

在得知 W 市爆发的肺炎之后，科学家们立刻投入了紧锣密鼓的研究之中。

（下面的部分非严谨科学，大家做题以外切勿当真）

假设某种病毒在第 $x$ 天的传播能力为 $D(x)$，该函数的含义为 $x$ 的约数个数。例如 $D(6)=4, D(7)=2$。

现在给定你总的传播天数 $n$ 和一个影响常数 $k$，你需要计算 $\sum_{i=1}^n D(i^k)$ 也就是 $D(1^k)+D(2^k)+D(3^k)+ \cdots +D(n^k)
$。

由于答案可能很大，请对 $998244353$ 取模。

## 说明/提示

 - 对于 $20\%$ 的数据，满足 $1\leq T\leq 10,1\leq n\leq 100,1\leq k\leq 6$；
 - 存在另外 $30\%$ 的数据，满足 $1 \leq T \leq 10^4, 1\leq n \leq 10^7,k=1$；
 - 对于 $100\%$ 的数据，满足 $1 \leq T \leq 10^4, 1\leq n,k \leq 10^7$。

【样例解释】

$D(1^2)+D(2^2)+D(3^2)+D(4^2)+D(5^2)$  
$=D(1)+D(4)+D(9)+D(16)+D(25)$  
$=(1)+(3)+(3)+(5)+(3)$  

1 有约数 1 个：1；  
4 有约数 3 个：1，2，4；  
9 有约数 3 个：1，3，9；  
16 有约数 5 个：1，2，4，8，16；  
25 有约数 3 个：1，5，25；

一共有15个  


## 样例 #1

### 输入

```
1
5 2```

### 输出

```
15```

# 题解

## 作者：小粉兔 (赞：27)

为了刷点社区贡献我来写题解。

啊 $D$ 其实就是 $\sigma_0$ 是吧，就是约数个数函数。

我们知道 $\sigma_0 (n)$ 的求法：把 $n$ 质因数分解，得到 $p_1^{\alpha_1} p_2^{\alpha_2} \cdots p_c^{\alpha_c}$ 的话，则 $\sigma_0 (n) = \prod\limits_{i=1}^{c} (\alpha_i + 1)$。

然后我们发现，$n^k$ 的质因数分解就是 $p_1^{k \cdot \alpha_1} p_2^{k \cdot \alpha_2} \cdots p_c^{k \cdot \alpha_c}$。

所以 $\sigma_0 (n^k) = \prod\limits_{i=1}^{c} (k \cdot \alpha_i + 1)$。

不妨举个例子，比如 $360 = 2^3 \cdot 3^2 \cdot 5$，则 $\sigma_0 ({360}^k) = (3k + 1) (2k + 1) (k + 1)$。

展开一下：$\sigma_0 ({360}^k) = 1 + 6 k + 11 k^2 + 6 k^3$。

啊，原来是一个关于 $k$ 的 $3$ 次多项式啊！

为啥是 $3$ 次？因为 $360$ 恰好就有 $3$ 个质因子：$2, 3, 5$。

也就是说，有多少个质因子就是关于 $k$ 的多少次多项式吧。

然而 ${10}^7$ 之内的，质因子最多的数，也不过 $8$ 个（$9699690 = 2 \cdot 3 \cdot 5 \cdot 7 \cdot 11 \cdot 13 \cdot 17 \cdot 19$）。

所以说啊，对于任何 $n \le {10}^7$，$\sigma_0 (n^k)$ 顶多就是关于 $k$ 的 $8$ 次多项式而已。

众所周知，无论多少个 $8$ 次多项式，加起来也还是 $8$ 次多项式。

如果我们已经得到了，每个 $n$ 对应的多项式，就可以 $\mathcal O (8)$ 算答案了。

所以写个线筛就可以求多项式的系数了，然后做一下前缀和，就做完了。

代码如下，时间复杂度为 $\mathcal O (n \cdot 8 + T \cdot 8)$：

```cpp
#include <cstdio>
#include <cstring>

typedef long long LL;
const int Mod = 998244353;
const int MN = 10000007, MP = 664580;

bool ip[MN];
int p[MP], pc;
int lpf[MN], lpfc[MN], dlpf[MN];
int poly[MN][9];
void Sieve(int N) {
	poly[1][0] = 1;
	for (int i = 2; i <= N; ++i) {
		if (!ip[i]) p[++pc] = i, lpf[i] = i, lpfc[i] = 1, dlpf[i] = 1, poly[i][0] = poly[i][1] = 1;
		for (int j = 1, k; j <= pc; ++j) {
			if ((k = p[j] * i) > N) break;
			ip[k] = 1;
			lpf[k] = j;
			if (i % p[j]) lpfc[k] = 1, dlpf[k] = i;
			else lpfc[k] = lpfc[i] + 1, dlpf[k] = dlpf[i];
			memcpy(poly[k], poly[dlpf[k]], 36);
			for (int z = 8; z >= 1; --z) poly[k][z] = (poly[k][z] + (LL)lpfc[k] * poly[k][z - 1]) % Mod;
			if (i % p[j] == 0) break;
		}
	}
	for (int i = 1; i <= N; ++i)
		for (int j = 0; j <= 8; ++j)
			poly[i][j] -= (poly[i][j] += poly[i - 1][j]) >= Mod ? Mod : 0;
}

int main() {
	Sieve(10000000);
	int T;
	scanf("%d", &T);
	while (T--) {
		int N, K;
		scanf("%d%d", &N, &K);
		int Ans = 0;
		for (int i = 8; i >= 0; --i)
			Ans = ((LL)Ans * K + poly[N][i]) % Mod;
		printf("%d\n", Ans);
	}
	return 0;
}
```

---

## 作者：zcysky (赞：12)

下面是官方的做法，本来没打算考多项式一类的，原意想的只是个简单的数论分块让大家快活快活。

$\sum_{i=1}^n D(i^k)$ ,$D(x)$ 为 $x$ 的约数个数和

我们考虑对每一个 $i$ 统计 $d|i^k$ 的个数 ，则有 $d=\prod p_j^{a_j}$

令 $g(d)=\prod p_j^{\lfloor \frac{a_j}{k}\rfloor}$

如果有 $g(d)|i$ ，则有 $d|i^k$

所以对于给定的 $d$ ，我们可以找到 $\lfloor \frac{n}{g(d)}\rfloor$ 个$i$ 

所以 $ans=\sum_{d=1}^{n^k}\lfloor \frac{n}{g(d)}\rfloor$

现在假定 $g(d)=m$ ，那么如果存在 $p^a|m$ ,那么 $p$ 的指数必须在 $[a(k-1)+1,ak]$ 之间。所以对于每个质因数，我们都有 $k$ 种可能的 $d$ ，令 $w(x)$ 为 $x$ 的质因数个数，所以总共可能的 $d$ 的个数是 $k^{w(m)}$ 个 

所以化简一下答案：

令 $w(x)$ 为 $x$ 的质因数个数

$\sum_{i=1}^nD(i^k)=\sum_{i=1}^nk^{w(i)}\lfloor \frac{n}{i}\rfloor$

接下来就是大家喜闻乐见的数论分块，因此复杂度降为 $O(M\sqrt{n})$ ，$M$为最大的质因数数量，不会很大。

---

## 作者：Fading (赞：4)

其实这道题的询问个数可以加强到$10^7$。

这里给出我的奇怪解法。

经过各种方法后，我们发现传统的数论解题思想都不太行。

观察答案的式子：

$$\sum_{i=1}^n\prod_{j}(1+k\alpha_j)$$

发现每一次的询问只有$k$不一样！

考虑多项式~~生成函数~~

$$\sum_{i=1}^n\prod_{j}(1+x\alpha_j)$$

最后直接把$x$代入这个多项式求值即可。

然后惊奇的发现这个多项式只有最多$9$项。因为$10^7$范围内最多八个不一样的质数相乘$(2\times3\times5\times7\times11\times13\times17\times19)$。

这样搞出每一个数的多项式，用前缀和加一下就好了。

现在要求快速预处理每一个数的多项式。

考虑线性筛，筛出每一个数的最小质因子，以及最小质因子的贡献（$\alpha_i$次幂）

转移的时候根据 $i/$最小质因子的$\alpha_i$次幂 得到的多项式，大力多项式乘法出来。

设多项式项数为$\lambda$，那么时间复杂度为$O(Q\lambda+n\lambda)$，空间复杂度为$O(n\lambda)$，事实上常数很小跑不满。

~~出题人为什么询问出这么小啊~~

代码如下

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ljc 998244353
using namespace std;
/*
*/
#ifdef Fading
#define gc getchar
#endif
#ifndef Fading
inline char gc(){
    static char now[1<<16],*S,*T;
    if (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if (T==S) return EOF;}
    return *S++;
}
#endif
inline ll read(){
    register ll x=0,f=1;char ch=gc();
    while (!isdigit(ch)){if(ch=='-')f=-1;ch=gc();}
    while (isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=gc();}
    return (f==1)?x:-x;
}
int p[1010101],tot,N,f[10000001][2];
int cnt[10000001];
int sum[10000001][9];
int pw[10];
inline void init(int N){
	for (int i=2;i<=N;i++){
		if (!f[i][0]){f[i][1]=i,f[i][0]=1;p[++tot]=i;}
		for (int j=1;j<=tot;j++){
			if (1ll*p[j]*i>1ll*N) break;
			f[p[j]*i][1]=p[j],f[p[j]*i][0]=1;
			if (i%p[j]==0){
				f[p[j]*i][0]=f[i][0]+1,f[p[j]*i][1]=f[i][1]*p[j];
				break;
			}
		}
	}
	sum[1][0]=1;
	for (int i=2;i<=N;i++){
		cnt[i]=cnt[i/f[i][1]]+1;
		for (int j=0;j<cnt[i];j++){
			sum[i][j]=(sum[i][j]+sum[i/f[i][1]][j])%ljc;
		}
		for (int j=1;j<=cnt[i];j++){
			sum[i][j]=(sum[i][j]+1ll*f[i][0]*sum[i/f[i][1]][j-1]%ljc)%ljc;
		}
	}
	for (int i=1;i<=N;i++){
		for (int j=0;j<=8;j++) sum[i][j]=(sum[i][j]+sum[i-1][j])%ljc;
	}
	pw[0]=1;
}
signed main(){
	init(1e7);
	int T=read();
	while (T--){
		int n=read(),K=read();
		for (int i=1;i<=8;i++) pw[i]=1ll*pw[i-1]*K%ljc;
		int ans=0;
		for (int i=0;i<=8;i++){
			ans=(ans+1ll*sum[n][i]*pw[i]%ljc)%ljc;
		}
		cout<<ans<<endl;
	}
    return 0;
}

```


---

## 作者：sochiji (赞：3)

### 蒟蒻来抛砖引玉写一发50分的题解。

## 定义

函数 $D(x),x\in\mathbb{Z_+}$表示$x$的约数个数。
>例：$D(6)=4,\quad D(7)=2$

## 单个函数值的一般计算方法

设$x=p_1^{\alpha _1}\cdot p_2^{\alpha _2}\cdot ... \cdot p_k^{\alpha _k}$，其中$p_i$为素数且互不相同，$\alpha _i$为正整数。  
对于$x$的任意正因数$d=p_1^{\beta _1}\cdot p_2^{\beta _2}\cdot ... \cdot p_k^{\beta _k}$和任意$1\leq i\leq k$，有$0\leq\beta _i\leq\alpha_i$;  
根据乘法原理，$\displaystyle D(x)=\prod^k_{i=1}(\alpha _i+1)$

## 性质

1. 若$x_1,x_2$互素，有$D(x_1\cdot x_2)=D(x_1)\cdot D(x_2)$；

   >证明：  
   >设$\displaystyle x_1=\prod^k_{i=1}p_i^{\alpha_i},\quad x_2=\prod^{k+l}_{i=k+1}p_i^{\alpha_i}$；  
   >由于对于任意$1\leq i\leq k,\quad k+1\leq j\leq k+l$，有$p_i\neq p_j$，  
   >所以$\displaystyle D(x_1\cdot x_2)=\prod^{k+l}_{i=1}(\alpha _i+1)=\prod^{k}_{i=1}(\alpha _i+1)\cdot \prod^{k+l}_{i=k+1}(\alpha _i+1)=D(x_1)\cdot D(x_2)$；

>**性质1**表明$D(x)$是**积性函数**。

2. 若$x=p^\alpha$且$p$为素数，则：
   - $D(x)=\alpha+1$；
   - $D(x^n)=\alpha\cdot n+1=n\cdot D(x)-n+1$；  
   >证明：  
   >第一条由上可知显然。  
   >第二条：$D(x^n)=D(p^{n\alpha})=\alpha\cdot n+1$  
   >$D(x^n)=n(D(x)-1)+1=n\cdot D(x)-n+1$

3. 若$x=p^\alpha \cdot c$，$p$为素数且$p$与$c$互素，则$D(x^n)=(n\alpha +1)\cdot D(c^n)$；
   >证明：  
   >$D(x^n)=D(p^{n\alpha}\cdot c^n)$；  
   >因为$p$与$c$互素，所以$p^{n\alpha }$与$c^n$互素，进而有$D(p^{n\alpha}\cdot c^n)=D(p^{n\alpha})\cdot D(c^n)=(n\alpha +1)\cdot D(c^n)$；

---

## 使用线性欧拉筛法生成$k=1$时的函数值表

>阅读之前请确保已经对[与素数及欧拉筛法相关的知识](https://zhuanlan.zhihu.com/p/74477008)有简单的了解；

欧拉筛法使得每个合数仅能通过“它的**最小真因子**乘上它的**最大真因子**”这种方法被构造出，而素数不会被筛掉。我们构造出一个新的合数$x$时，有下面几种情况：

1. $x$本身是素数：
   >这种情况下$D(x)=2$
2. $x$的最大真因子$p_2$是素数，且与最小真因子$p_1$**不相等**：
   >这种情况可以表示为$x=p_1\cdot p_2$，那么$D(x)=D(p_1\cdot p_2)=D(p_1)\cdot D(p_2)$
3. $x$的最大真因子$p$是素数，且与最小真因子**相等**：
   >这种情况可以表示为$x=p\cdot p$，那么$D(x)=D(p^2)=3$
4. $x$的最大真因子$c$是合数，且与最小真因子$p$**互素**：
   >这种情况可以表示为$x=p\cdot c$，那么$D(x)=D(p\cdot c)=D(p)\cdot D(c)=2\cdot D(c)$
5. $x$的最大真因子$m$是合数，且$m$是$x$的最小真因子$p$的整数次方的**倍数**，即$m=p^\alpha \cdot c$：
   >这种情况可以表示为$x=p\cdot m=p\cdot p^{\alpha}\cdot c=p^{\alpha +1} \cdot c$，其中$p$与$c$互素即$\alpha =\mathrm{ord}_{p}m$，那么$D(x)=D(p^{\alpha +1}\cdot c)=D(p^{\alpha +1})\cdot D(c)=(\alpha +2)\cdot D(c)$

为了使欧拉筛法可以递推$D(x)$，我们不仅得记录每个数的$D(x)$，还有必要记录它的：
1. 最小素因子$p$，代码中表示为`minfac`；
2. 最大阶$\alpha=\mathrm{ord}_px$，代码中表示为`order`；
3. 与$p$互素的`c`；
4. 函数值$D(x)$，代码中表示为`d`
```cpp
struct rec
{
    int minfac; 
    int order;  
    int c;      
    int d;      
} dlist[10000001];
```

在欧拉筛法的代码中加入计算`dlist[]`的语句即可生成$k=1$时的$D(x^k)$函数值表。  
由于此题的测试点的数据较多，可以通过记录$k=1$时函数值表的前$n$项和$\displaystyle\sum_{i=1}^{n}D(i)$来优化。

当$x$是$p$的整数次幂时有$c=1$，因此要注意初值条件：

```
    dlist[1].c = 1; 
    dlist[1].d = 1; 
```
线性筛代码：
```cpp
//primeMap[]是素性映射表，primeList[]是素数表，sumList[]是k==1时函数值前缀和表
int getPrimeList(int n, bool primeMap[], int primeList[], int sumList[])
{
    //初始化
    int count = 0;
    for (int i = 2; i <= n; i++)
        primeMap[i] = true;
    primeMap[0] = false;
    primeMap[1] = false;
    dlist[1].c = 1;
    dlist[1].d = 1;

    int half = n / 2;
    for (int i = 2; i <= half; i++)
        if (primeMap[i])
        {
            dlist[i] = {i, 1, 1, 2}; //第1种情况
            primeList[count] = i;
            count++;
            for (int j = 0; j < count && i >= primeList[j] && i * primeList[j] <= n; j++)
            {
                primeMap[i * primeList[j]] = false;
                if (i == primeList[j])
                {
                    dlist[i * primeList[j]] = {primeList[j], 2, 1, 3}; //第3种情况
                    break;
                }
                else
                    dlist[i * primeList[j]] = {primeList[j], 1, i, dlist[i].d * dlist[primeList[j]].d}; //第2种情况
            }
        }
        else
            for (int j = 0; j < count && i * primeList[j] <= n; j++)
            {
                primeMap[i * primeList[j]] = false;
                if (dlist[i].minfac == primeList[j]) //由于存储了i的最小素因子 故写法与普通线性筛不同
                {
                    dlist[i * primeList[j]] = {primeList[j], dlist[i].order + 1, dlist[i].c, (dlist[i].order + 2) * dlist[dlist[i].c].d}; //第5种情况
                    break;
                }
                else
                    dlist[i * primeList[j]] = {primeList[j], 1, i, 2 * dlist[i].d}; //第4种情况
            }
    for (int i = half + 1; i <= n; i++)
        if (primeMap[i])
        {
            dlist[i] = {i, 1, 1, 2}; //第1种情况
            primeList[count] = i;
            count++;
        }
    for (int i = 2; i <= n; i++)
        sumList[i] = sumList[i - 1] + dlist[i].d; //生成前缀和
    return count;
}
```
>注意：在非初始化处对`struct`进行整体赋值的语法在`C++11`标准之前是非法的。

据题意，我们应当在`main()`中调用上面的函数，并给参数`n`赋值$10^7$。之后我们就能从`sumList[]`立即输出任何$k=1$时的$\displaystyle\sum_{i=1}^{n}D(i)$。

---

## 根据$k=1$时的$D(x)$函数值表生成$k$取任意值的$D(x^k)$函数值表

根据**性质3**，我们可以在$O(n)$的时间内递推出$\displaystyle\sum_{i=1}^{n}D(i^k)$全部项并求和。代码如下：

```cpp
const int MODNUM = 998244353;

long long dpow[10000001];//存放n^k的函数值，以n为索引

int getSum(int n, int k)
{
    long long sum = 0;
    sum = 1;
    for (int i = 2; i <= n; i++)
    {
        dpow[i] = (k * dlist[i].order + 1) * dpow[dlist[i].c;
        sum += dpow[i];
        sum %= MODNUM;
    }
    return (int)sum;
}
```

在`main()`中如下调用上面的函数并注意初值条件：

```cpp
    dpow[1] = 1;
    sumlist[1] = 1;

    int t;
    scanf("%d", &t);

    for (int i = 1; i <= t; i++)
    {
        int n, k;
        scanf("%d%d", &n, &k);
        printf("%d\n", (k == 1) ? sumlist[n] : getSum(n, k));
    }

```

不限制$k=1$时，总的时间复杂度为$O(T\cdot n)$，上面的方法最多需要进行$10^{11}$次加法运算，会导致5个测试点超时。

要AC此题，应该得以$O(T)$的时间复杂度解决整个问题，但本蒟蒻实在找不出$\displaystyle\sum_{i=1}^{n}D(i)$与$\displaystyle\sum_{i=1}^{n}D(i^k)$的关系（应该是一个高次多项式函数），所以这篇题解只值50分。

## 感谢阅读。

---

## 作者：hehelego (赞：3)

有趣,但是用到的想法都是比较常规的 ~~有点缝合的感觉~~

月赛没打,讲评没买.....看了一圈,就会这一个题,继续文化课了.

---

首先$d(n)=\sum_{i\leq n} [i\mid n]$是个积性函数,然后$D_k(n)=d(n^k)$显然也是积性的...  

有一说一遇到数论函数求和题,应该先试试答案是不是积性函数,如果是的话有不少通用工具来处理.  

然后这似乎是经典题?给定$n,k$求$\sum_{i\leq n} d(i^k)$,直接线性筛$D$就行啦,开玩笑rated比赛怎么可能出原题,然后就发现IO格式不太对劲,这个题$k$是每次询问不定的.但是解决$k$确定的算法,仍然对于本题的解决有很大启发.  

考虑$n$的唯一分解$n=\prod p_i^{a_i}$我们有$d(n)=\prod (a_i+1)$,首先可以从积性来得到它,或者这么想,每个质因子,可以取$p^0,p^1\dots p^a$然后每个质因子是独立取的,于是方案数乘起来.  
于是$d(n^k)=\prod (ka_i+1)$,这可以看做关于$k$的多项式$F_n(x)=\prod (xa_i+1)$答案就是$(\sum F_i)(n)$了,BTW这里F(x)仍然有积性$(p,q)=1\Rightarrow F_p(x)F_q(x)=F_{px}(x)$.

我们之后的处理需要用到这样的结论$\omega(n)=|\{p\in prime\mid p|n\}|$是$loglog(n)$量级的,原因见Eratosthenes筛的复杂度分析.我们写个线性筛求一下$\omega(n)$的最大值,发现对于$n\leq 1e7$有$\omega(n)\leq 8$  
这个多项式$F$的次数非常低,我们可以直接把这个多项式存下来不会MLE(这里mod=998244353是int32范围内的,做乘法暂时转int64模了之后还用int32存储就可以).  



----

之后是喜闻乐见线性筛,线性筛筛除合数,其实是在枚举合数的最小质因子.我们记录最小质因子与它的次数就可以轻松转移.我们记$mp(n)$为最小质因子.

具体来说,有两种转移,第一种是已有$n$添加一个$p$,满足$mp(n)\gt p$变成$np$,有$mp(np)=p$,这里利用积性直接转移,注意转移$F$是多项式乘法,不可以$(max(\omega))^2$来做,$F_p(x)=(x+1)$可以平移一下加一下代替暴力乘.  
第二种转移,已有$n$,令$p=mp(n)$转移到$np$有$mp(np)=p$.这里考虑$n$中最小质因子的次数是$k$,有$p^k$这样一个因子,显然$\frac{n}{p^k}$不再有$p$这个质因子,于是我们有.$np=p^{k+1}\frac{n}{p^k}$这两部分是互质的,又是积性转移,同样的前一部分$F(p^k)=(kx+1)$不需要暴力乘.  



对于求解答案,有个小技巧,$P(x)=\sum_{i=0}^n a_ix^i=(((a_n+x)x+a_{n-1})x+a_{n-2}\dots $这样展开来算是$O(n)$的.

-----

最后给出程序...
```cpp
#include <bits/stdc++.h>
int read(){
	int x=0;char c;
	do{c=getchar();}while(!isdigit(c));
	do{x=x*10+c-'0';c=getchar();}while(isdigit(c));
	return x;
}
typedef long long Int;
const int mod=998244353LL;
const int N=int(1e7)+3;
//const int N=int(1e5)+3;
const int K=9; // max omega(n)=8
int qpow(int a,int p){
	int r=1; while(p){
		if(p&1) r=1LL*r*a%mod;
		a=1LL*a*a%mod; p>>=1;
	} return r;
}
std::bitset<N> vis;
int prime[N],cnt;
int f[N][K],g[N],pk[N];
// mp(n): min(p\in prime) where p \mid n
// pk(n): max(k) where (mp^k) \mid n
// g(n): mp^{pk}
void mul(int *a,int *b,int *ret){
	for(int i=0;i<K;i++) for(int j=0;i+j<K&&j<2;j++)
		ret[i+j]=(ret[i+j]+1LL*a[i]*b[j]%mod)%mod;
}
void init(){
	f[1][0]=1; for(int i=2;i<N;i++){
		if(!vis[i]){
			prime[cnt++]=i; g[i]=i; pk[i]=1;
			f[i][0]=1; f[i][1]=1;
		}
		for(int j=0;j<N&&i*prime[j]<N;j++){
			int v=i*prime[j]; vis[v]=1;
			if(i%prime[j]==0){
				g[v]=g[i]*prime[j]; pk[v]=pk[i]+1;
				f[0][0]=1; f[0][1]=pk[v];
				mul(f[v/g[v]],f[0],f[v]);
				break;
			}
			g[v]=prime[j]; pk[v]=1;
			mul(f[i],f[prime[j]],f[v]);
		}
	}
	for(int i=2;i<N;i++){
		for(int j=0;j<K;j++) f[i][j]=(f[i][j]+f[i-1][j])%mod;
	}
	std::cerr<<1.0*clock()/CLOCKS_PER_SEC<<std::endl;
}

int solve(int n,int x){
	Int t=0;
	for(int i=K-1;i>=0;i--) t=(x*t%mod+f[n][i])%mod;
	return int(t);
}
int main(){
	init(); int T=read(),n,k;
	while(T--){
		n=read();k=read();
		printf("%d\n",solve(n,k));
	}
	return 0;
}
```



------


至于怎么想到把$D(n)$看作关于$k$的$\omega(n)$次多项式?我是因为了解过min25筛,常规使用min25筛的话解决的函数在质数$p$处取值是关于$p$的多项式,质数幂处取值可以快速计算(快速就是所有$f(p^k)$的计算时间不超过dfs转移复杂度).  
然后min25筛的对于质数处取值的筛法是这么做的,拆$f(p)=\sum a_ip^i$成$deg(f)+1$个单项式,$f_i(p)=a_ip^i$这里套用一下就是$D(p)=(1\times k+1)$,拆成$f_0(p)=1+k$然后发现这是个$p$的$0$次多项式,是$k$的1次多项式,如果我们把它按照$k$的次数来分成两个单项式,那么就可以欢乐min25筛暴力dfs了.  
回到这个要多次询问,n只有1e7的题,上面的想法就很自然的让我们搞出正解了...





---

## 作者：tzc_wk (赞：1)

[洛谷题面传送门](https://www.luogu.com.cn/problem/P6060)

一道不算太难的题，题解稍微写写吧（

首先根据约数个数和公式，对于一个 $n=p_1^{\alpha_1}·p_2^{\alpha_2}·\cdots·p_m^{\alpha_m}$​，显然有 $D(n^k)=\prod\limits_{i=1}^m(k\alpha_i+1)$​，由于每次询问给定的 $k$ 不固定，我们无法一次性直接对所有 $k$ 都算一波答案。不过注意到对于一个 $n\in[1,10^7]$ 而言，其质因子个数不会超过 $8$，这也就启发我们，上面的 $\prod$ 展开后肯定是关于 $k$ 的次数不超过 $8$ 的多项式，因此考虑对每个 $n$ 求出其对应的多项式的系数然后累加求个前缀和，这样我们即可在 $\mathcal O(8)$ 的复杂度内回答询问。那么怎么对每个 $n$ 求出其对应的多项式呢？考虑一个非常 naive 的 DP，首先我们对于每个数求出其最小质因子 $mnp_i$——这显然可以一遍线性筛搞定，学过一丁点数论的人都能够搞定。我们再找出 $mnp_i$ 在 $i$ 中的次数，假设为 $\alpha$，那么我们记 $x=\dfrac{i}{mnp_i^{\alpha}}$，那么显然就有 $f_{i,j}=f_{x,j-1}·\alpha+f_{x,j}$，其中 $f_{i,j}$ 为 $i$ 对应的多项式第 $j$ 项的系数，随便递推一下即可。

时间复杂度 $\mathcal O(8·n)$。这个故事告诉我们下次看到数论题目，有时候也可以从每个数不同质因子个数很小这一点出发，可以获得不错的复杂度。

```cpp
const int MAXN=1e7;
const int OMEGA=8;
const int MOD=998244353;
int pr[MAXN/10+5],prcnt=0,mnp[MAXN+5],omega[MAXN+5];
bitset<MAXN+5> vis;
int s[MAXN+5][OMEGA+2];
void sieve(int n){
	for(int i=2;i<=n;i++){
		if(!vis[i]) mnp[i]=i,pr[++prcnt]=i,omega[i]=1;
		for(int j=1;j<=prcnt&&pr[j]*i<=n;j++){
			vis[i*pr[j]]=1;mnp[i*pr[j]]=pr[j];
			if(i%pr[j]==0){omega[i*pr[j]]=omega[i];break;}
			omega[i*pr[j]]=omega[i]+1;
		}
	} s[1][0]=1;
	for(int i=2;i<=n;i++){
		int tmp=i,sum=0,p=mnp[i];
		while(tmp%p==0) tmp/=p,sum++;
		for(int j=0;j<=omega[i];j++) s[i][j]=s[tmp][j];
		for(int j=0;j<omega[i];j++) s[i][j+1]+=s[tmp][j]*sum;
	}
	for(int i=0;i<=OMEGA;i++) for(int j=1;j<=n;j++)
		s[j][i]=(s[j-1][i]+s[j][i])%MOD;
}
int pw[OMEGA+2];
int main(){
	sieve(MAXN);int qu;scanf("%d",&qu);
	while(qu--){
		int n,k,res=0;scanf("%d%d",&n,&k);
		for(int i=(pw[0]=1);i<=OMEGA;i++) pw[i]=1ll*pw[i-1]*k%MOD;
		for(int i=0;i<=OMEGA;i++) res=(res+1ll*pw[i]*s[n][i])%MOD;
		printf("%d\n",res);
	}
	return 0;
}
```



---

## 作者：littleKtian (赞：1)

首先，如果 $x$ 质因数分解的结果为 $x=\prod{p_i^{a_i}}$，那么 $D(x)=\prod{(a_i+1)}$，$x^k=\prod{p_i^{ka_i}}$

由数据范围~~按计算器~~可知 $p_i$ 最多只有 $8$ 个

可以发现当 $x$ 为定值时，$D(x^k)$ 相当于一条以 $k$ 为自变量的最高次项为 $8$ 次的函数

预处理把每个 $x$ 对应的函数各项系数求出来，前缀和累加，对于每个询问将 $k$ 代入即可

复杂度 $O(n)$(?)

~~常数巨大~~，实测~~吸氧~~能过

```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll p=998244353;
const ll N=1e7;
const int M=8;
int t,totp,pi[N+1],v[N+1],qz[N+1][M+1];
ll n,k,ans,c;
ll dr()
{
	ll xx=0;char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')xx=(xx<<1)+(xx<<3)+ch-'0',ch=getchar();
	return xx;
}
int main()
{
	t=dr();
	for(ll i=2;i<=N;i++)
	{
		if(v[i]==0)v[i]=pi[++totp]=i;
		for(int j=1;j<=totp&&pi[j]<=v[i]&&pi[j]<=N/i;j++)v[pi[j]*i]=pi[j];
	}
	qz[1][0]=1;
	for(ll i=2;i<=N;i++)
	{
		qz[i][0]=1;
		ll x=i;
		while(x!=1)
		{
			int y=0;
			while(v[x]==v[x/v[x]])x/=v[x],++y;
			x/=v[x],++y;
			for(int j=M;j>0;j--)qz[i][j]=(qz[i][j]+1ll*qz[i][j-1]*y)%p;
		}
		for(int j=0;j<=M;j++)qz[i][j]=(qz[i-1][j]+qz[i][j])%p;
	}
	while(t--)
	{
		n=dr(),k=dr(),ans=0,c=1;
		for(int i=0;i<=M;i++)ans=(ans+qz[n][i]*c)%p,c=c*k%p;
		printf("%lld\n",ans);
	}
}
```


---

## 作者：yzq_yzq (赞：0)

因为 $n\leq 10^7$ ，所以每个数不会有超过 $8$ 个不同的质因子。

$i=∏p_i^{a_i},D(i)=∏(a_i+1),D(i^k)=∏(ka_i+1)$ 

答案是个关于 $k$ 的 $8$ 次多项式，用欧拉筛先把多项式求出来然后带值就行了。

这个做法很简单，而且支持 $T\leq10^7$ 。

---

但是官方题解的做法更为 educational 些，简单复述一下做法。

定义 $g(d)=∏p_j^{\lfloor\frac{a_j}{k}\rfloor}$ ，然后考虑对 $d|i^k$ 计数，答案 $ans=\sum_{d=1}^{n^k}\lfloor \frac n {g(d)}\rfloor$

这样还是不可做，考虑固定 $g(d)=x$ ，满足 $g(d)=x$ 的 $d$ 是 $k^{w(x)}$ 个。

然后答案变成 $\sum_{i=1}^n k^{w(i)} \lfloor\frac n i\rfloor$ ，整除分块即可，复杂度是 $O(10\sqrt n)$ ， $10$ 是最大质因子个数。

---

实现写的第一种。

```cpp
#include <bits/stdc++.h>
#define ll long long
#define i16 short
#define u16 unsigned i16
#define rep(i, x, y) for(int i = (x); i <= (y); ++i)
#define drep(i, x, y) for(int i = (x); i >= (y); --i)
#define ull unsigned ll
#define pb push_back
#define pii pair<int, int>
#define fi first
#define se second
#define mem(a, b) memset((a), b, sizeof (a))
#define ALL(a) (a).begin(), (a).end()
#define fastio ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)
using namespace std;
template<typename T> inline void cmin(T &x, T y) { if(x > y) x = y; }
template<typename T> inline void cmax(T &x, T y) { if(x < y) x = y; }
template<typename T> struct LSH {
	vector<T> b; LSH() { b.clear(); } 
	inline void ins(T x) { b.pb(x); }
	inline void build() { sort(ALL(b)), b.erase(unique(ALL(b)), b.end()); }
	inline int q(T x) { return lower_bound(ALL(b), x) - b.begin(); }
	inline T operator [](int x) { return b[x]; }
};
// \Mul (k * x + 1)
const int N = 1e7, mod = 998244353;
int s[N + 5][9], T, n, k, mi[N + 5], p[N + 5], cnt; 
i16 f[N + 5], lim[N + 5]; bool vis[N + 5];
inline void add(int &x, int y) {
	x += y; if(x >= mod) x -= mod;
}
inline void Prime(int n = N) {
	vis[1] = 1;
	rep(i, 2, n) {
		if(!vis[i]) mi[i] = i, p[++cnt] = i, f[i] = 1;
		rep(j, 1, cnt) {
			int x = p[j] * i;
			if(x > n) break;
			vis[x] = 1, mi[x] = p[j];
			if(i % p[j] == 0) { f[x] = f[i] + 1, mi[x] = mi[i] * p[j]; break; }
			else f[x] = 1;
		}
	}
	s[1][0] = 1;
	rep(i, 2, n) {
		int x = i / mi[i];
		lim[i] = lim[x] + 1;
		rep(j, 0, lim[x])
			add(s[i][j], s[x][j]);
		rep(j, 1, lim[i])
			s[i][j] = (s[i][j] + 1ll * s[x][j - 1] * f[i]) % mod;
	}
	rep(i, 2, n) rep(j, 0, 8) add(s[i][j], s[i - 1][j]);
}
int main() {
	Prime(); fastio;
	int T; cin >> T;
	while(T--) {
		int n, k; cin >> n >> k;
		int res = 0;
		drep(i, 8, 0) res = (1ll * res * k + s[n][i]) % mod;
		cout << res << '\n';
	}
	return 0;
}
```

---

## 作者：anotherobject (赞：0)

首先先对于单点算出 $D$，容易发现当 $x=\prod_i p_i^{c_i}$，$D(x)=\prod_i (c_i+1)$，且 $D(x^k)=\prod _i (c_ik+1)$。

想要去掉这个 $k$，尝试生成函数，得到 $D(x^k)=[x^{\omega(x)}]\prod_i(c_ix+1)\prod_ik^ix^{\omega(x)-i}$。其中 $\omega(x)$ 是 $x$ 的质因子个数。

解释一下这个式子？如果你在前面的 $\prod$ 里选择了 $i$ 次 $c_i$，就要在后面选择 $i$ 次 $k$。

所以只需要算出 $\sum_{x=1}^n\prod_i(c_ix+1)$ ，然后第 $i$ 项乘 $k_i$ 就可以了。这个多项式乘法可以看做背包 $O(\omega(x)^2)$ 的计算。

总复杂度 $O(n\omega(x)^2+T\omega(x))$，因为在 $x\le 10^7$ 下 $\omega(x)\le 8$ 所以通过的较为轻松。

extend：背包具有积性，可以直接从除掉最小质因子的位置转移来，不需要每个 $x$ 单独背包，可以优化到 $O(n\omega(x)+T\omega(x))$，但是代码里没写。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int M=1e7+10;
const int p=998244353;
int prime[M],res,mp[M];
bitset<M>vis;
void sieve(int n){//mp是最小质因子的编号
	for(int i=2;i<=n;i++){
		if(!vis[i]){prime[++res]=i;mp[i]=res;}
		for(int j=1;j<=res&&1ll*prime[j]*i<=n;j++){vis[prime[j]*i]=1;mp[prime[j]*i]=j;if(i%prime[j]==0) break;}
	}
}
int f[M][9],g[2][9];
int c[9],cnt=1;
void init(int n){
	for(int i=1;i<=n;i++){
		int tmp=i,k=mp[i];//统计每个质因子出现次数
		while(tmp!=1){if(mp[tmp]!=k){cnt++; k=mp[tmp];}c[cnt]++; tmp/=prime[mp[tmp]];}
		g[0][0]=1;//每个 x 单独做背包，计算多项式的系数
		for(int j=1;j<=cnt;j++){g[j&1][0]=1; for(int k=1;k<=cnt;k++) g[j&1][k]=(g[(j-1)&1][k]+1ll*g[(j-1)&1][k-1]*c[j]%p)%p;}
		for(int j=0;j<=cnt;j++) f[i][j]=g[cnt&1][j];
		memset(c,0,sizeof c); memset(g,0,sizeof g); cnt=1;
	}
	for(int i=2;i<=n;i++)for(int j=0;j<=8;j++)f[i][j]=(f[i][j]+f[i-1][j])%p;//把多项式做前缀和
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0); cout.tie(0); 
	sieve(M-10); init(M-10);
	int t; cin>>t; while(t--){
		int n,k; cin>>n>>k;int ans=0,tmp=1;
		for(int i=0;i<=8;i++){ans=(ans+1ll*f[n][i]*tmp%p)%p;tmp=1ll*tmp*k%p;}//每一项乘 k 的 i 次方
		cout<<ans<<"\n";
	} 
}
```

---

## 作者：沉石鱼惊旋 (赞：0)

# 题意

约定 $d(x)$ 为 $x$ 的因子个数，$T$ 次询问每次给定 $n,k$，求 $\sum\limits_{i=1}^n d(i^k)$。答案对 $998244353$ 取模。

$1\leq T\leq 10^4$，$1\leq n,k\leq 10^7$。

# 题目做法

若 $x$ 可以被分解为 $p_1^{\alpha_1}p_2^{\alpha_2}\dots p_s^{\alpha_s}$，则我们有 $d(x)=\prod\limits_{i=1}^s (\alpha_i+1)$。

同理，$x^k$ 一定可以被分解为 $p_1^{k\alpha_1}p_2^{k\alpha_2}\dots p_s^{k\alpha_s}$。所以 $d(x^k)=\prod\limits_{i=1}^s (k\alpha_i+1)$。

发现 $10^7$ 次方以内至多只有 $8$ 个不同的质因子。我们直接维护这个关于 $k$ 的 $8$ 次多项式，对这 $n$ 个 $8$ 次多项式做前缀和。

求单个 $i$ 对应的多项式不用每次分解质因数，可以简单递推一下，设 $f_i$ 是 $i$ 对应的 $8$ 次多项式， $i$ 的最小质因子为 $q$，$c$ 是满足 $q^j\mid i$ 的最大的 $j$，那么我们有 $f_i=f_{i/q^c}\times (c+1)$。

多项式乘法和多项式加法直接暴力把系数合并起来就好。

找到 $q$ 可以直接用线性筛，$c$ 要用的时候暴力算一下就好。

时间复杂度 $\mathcal O(\omega n)$。其中 $\omega=8$。暴力求 $c$ 的部分其实是线性的。证明在 <https://oeis.org/A067029> 上有。

# 部分代码

<https://www.luogu.com.cn/record/203148365>

```cpp
using Z = mod_int<998244353>;
struct poly
{
    Z a[10];
    Z &operator[](int x) { return a[x]; }
    Z calc(int k)
    {
        Z ans = 0;
        Z pw = 1;
        for (int i = 0; i < 10; i++)
            ans += a[i] * pw, pw *= k;
        return ans;
    }
} f[10000020];
poly operator+(poly a, poly b)
{
    for (int i = 0; i < 10; i++)
        a[i] += b[i];
    return a;
}
poly operator*(poly a, int b) // a * (bx + 1)
{
    for (int i = 9; i > 0; i--)
        a[i] += a[i - 1] * b;
    return a;
}
const int N = 10000000;
int p[1000020];
bitset<10000020> np;
int mnd[10000020];
void solve()
{
    int n, k;
    read(n, k);
    write(f[n].calc(k).val(), '\n');
}
int main()
{
    for (int i = 2; i <= N; i++)
    {
        if (!np[i])
            p[++p[0]] = i, mnd[i] = i;
        for (int j = 1; j <= p[0] && i * p[j] <= N; j++)
        {
            np[i * p[j]] = 1;
            mnd[i * p[j]] = p[j];
            if (i % p[j] == 0)
                break;
        }
    }
    f[1][0] = 1;
    for (int i = 2; i <= N; i++)
    {
        int p = mnd[i];
        int cnt = 0;
        int j = i;
        while (!(j % p))
            j /= p, cnt++;
        f[i] = f[j] * cnt;
    }
    for (int i = 2; i <= N; i++)
        f[i] = f[i] + f[i - 1];
    int t;
    read(t);
    while (t--)
        solve();
    return 0;
}
```

---

## 作者：Purslane (赞：0)

# Solution

~~看到标题，死去的回忆突然开始攻击我。~~

考虑如果 $k$ 很小，那么直接使用线性筛预处理。

否则考虑 $n$ 的标准素分解为 $p_1^{\alpha_1} p_2^{\alpha_2} \dots p_t^{\alpha_t}$，显然有 $t \le 8$。

则 $d(n^k) = (1 + k \alpha_1)(1+ k \alpha_2) \cdots (1+k \alpha_t) = F(k)$，其中 $F$ 是一个关于 $k$ 的多项式，满足 $\deg F = t \le 8$。对 $n$ 求和，仍然是一个关于 $k$ 的不超过 $8$ 次多项式。使用拉格朗日插值解决。

注意到事实上我们只需要维护 $8$ 个 $\sum d(i^t)$ 值即可，因为 $t=0$ 的时候结果是确定的。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1e7+10,MOD=998244353;
int T,n,k,d[8][MAXN];
bitset<MAXN> flg; int pc[MAXN],oval[MAXN];
ll qpow(ll base,int p) {
	ll ans=1;
	while(p) {
		if(p&1) ans=ans*base%MOD;
		base=base*base%MOD,p>>=1;	
	}
	return ans;
}
void init(int d[MAXN],int k,int mx) {
	flg=0;
	d[1]=1,pc[1]=1,oval[1]=1;
	vector<int> pr;
	ffor(i,2,mx) {
		if(!flg[i]) pr.push_back(i),pc[i]=d[i]=1+k,oval[i]=1;
		for(auto v:pr) {
			if(i*v>mx) break ;
			flg[i*v]=1;
			if(i%v==0) {pc[i*v]=pc[i]+k,oval[i*v]=oval[i],d[i*v]=1ll*pc[i*v]*oval[i*v]%MOD;break ;}
			pc[i*v]=1+k,oval[i*v]=d[i],d[i*v]=1ll*pc[i*v]*oval[i*v]%MOD;
		}
	}
	return ;
}
int solve(int n,int k) {
	ll ans=0;
	ffor(i,0,8) {
		ll u=1,dyx=1;
		if(i) u=d[i-1][n];
		else u=n;
		ffor(j,0,8) if(i!=j) dyx=dyx*(i-j)%MOD,u=u*(k-j)%MOD;	
		ans=(ans+u*qpow(dyx,MOD-2))%MOD;
	}
	return (ans%MOD+MOD)%MOD;
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	ffor(i,1,8) init(d[i-1],i,10000000);
	ffor(i,1,8) ffor(j,2,10000000) d[i-1][j]=(d[i-1][j]+d[i-1][j-1])%MOD;
	cin>>T;
	while(T--) cin>>n>>k,cout<<solve(n,k)<<'\n';
	return 0;
} 
```

---

## 作者：Leasier (赞：0)

由于 $k$ 很大，我们无法对每个 $k$ 处理答案。

但注意到 $\tau((p^q)^k) = qk + 1$，则任意 $\tau(n^k)$ 都是一个 $\omega(n)$ 次的多项式。由于 $n \leq 10^7$ 时 $\omega(n) \leq 8$，则所有 $\tau(n^k)$ 都是一个关于 $k$ 的至多 $8$ 次的多项式。

于是我们线性筛处理出这些多项式后做一个前缀和，询问时带入求值即可。时间复杂度为 $O(M(N + T))$，其中 $M = 8$，$N = 10^7$。

代码：
```cpp
#include <stdio.h>
#include <string.h>

typedef long long ll;

const int N = 8 + 1, mod = 998244353;

typedef struct Polynomial_tag {
	int n;
	int a[N];
	
	Polynomial_tag(){
		memset(a, 0, sizeof(a));
	}
	
	inline ll calc(int x){
		ll ans = 0;
		for (register int i = n; i >= 0; i--){
			ans = (ans * x % mod + a[i]) % mod;
		}
		return ans;
	}
} Polynomial;

const int M = 1e7 + 7;
int prime[M];
bool p[M];
Polynomial f[M];

inline int max(int a, int b){
	return a > b ? a : b;
}

Polynomial operator +(Polynomial &a, Polynomial &b){
	Polynomial ans;
	ans.n = max(a.n, b.n);
	for (register int i = 0; i <= ans.n; i++){
		ans.a[i] = (a.a[i] + b.a[i]) % mod;
	}
	return ans;
}

Polynomial operator +=(Polynomial &a, Polynomial &b){
	return a = a + b;
}

inline void init(){
	int cnt = 0;
	p[0] = p[1] = true;
	f[1].n = 0;
	f[1].a[0] = 1;
	for (register int i = 2; i < M; i++){
		if (!p[i]){
			prime[++cnt] = i;
			f[i].n = f[i].a[0] = f[i].a[1] = 1;
		}
		for (register int j = 1; j <= cnt && i * prime[j] < M; j++){
			int t1 = i * prime[j], t2 = t1, power = 0;
			p[t1] = true;
			while (t2 % prime[j] == 0){
				t2 /= prime[j];
				power++;
			}
			f[t1] = f[t2];
			for (register int k = f[t1].n++; k >= 0; k--){
				f[t1].a[k + 1] += f[t1].a[k] * power;
			}
			if (i % prime[j] == 0) break;
		}
	}
	for (register int i = 1; i < M; i++){
		f[i] += f[i - 1];
	}
}

int main(){
	int t;
	scanf("%d", &t);
	init();
	for (register int i = 1; i <= t; i++){
		int n, k;
		scanf("%d %d", &n, &k);
		printf("%lld\n", f[n].calc(k));
	}
	return 0;
}
```

---

## 作者：peterwuyihong (赞：0)

题意：多测，求 $\sum_{i=1}^nd(i^k)$，$n,k\le10^7,T\le 10^4$。

这不 DIVCNTK 吗？我直接莽。。。

TLE20。

原来这样复杂度是 $O(T\dfrac{n^{\frac{3}{4}}}{\log n})$ 的，居然过不去，大悲。

然后我们要利用到这个 $n$ 很小的特性，考虑 $114514=2\times31\times1847$，$d(114514^k)=(1+k)(1+k)(1+k)$ ，会产生一个多项式，而这个多项式最多 $8$ 次，因为 $\prod_{p\le20}=9699690,\pi(20)=8$。

然后大力维护这个多项式就行了，复杂度 $O(n+q)$。

现在是 $18:00$，我开始写这道题。

现在是 $19:01$，我写完了。

```cpp
#define maxn 10000010
const int p=998244353;
int T;
int N[10000],K[10000];
int Om=8;
int pri[1919810],tot;
//int lpf[maxn];//最小质因子 
bitset<maxn>v;
int alpha[maxn];//出现几次 
int Beta[maxn];//pri[lpf[i]]^alpha[i]
int ome[maxn];//几个因子 
int G[maxn][9];
int mx;
void shai(int n){
	for(int i=2;i<=n;i++){
		if(!v[i])pri[++tot]=i,ome[i]=1,alpha[i]=1,Beta[i]=i;
		for(int j=1;j<=tot&&i*pri[j]<=n;j++){
			v[i*pri[j]]=1;
			if(i%pri[j]==0){
				alpha[i*pri[j]]=alpha[i]+1;
				Beta[i*pri[j]]=Beta[i]*pri[j];
				ome[i*pri[j]]=ome[i];
				break;
			}
			alpha[i*pri[j]]=1;
			Beta[i*pri[j]]=pri[j];
			ome[i*pri[j]]=ome[i]+1;
		}
	}
	G[1][0]=1;
	for(int i=2;i<=n;i++){
		for(int j=0;j<=ome[i];j++)G[i][j]=G[i/Beta[i]][j];
		for(int j=1;j<=ome[i];j++)G[i][j]=(G[i][j]+1ll*G[i/Beta[i]][j-1]*alpha[i])%p;
	}
	for(int i=0;i<=Om;i++)
	for(int j=1;j<=n;j++)
	G[j][i]=(G[j-1][i]+G[j][i])%p;
}
int main(){
#ifndef ONLINE_JUDGE
	freopen("testdata.in","r",stdin);
#endif
	cin>>T;
	for(int i=0;i<T;i++)cin>>N[i]>>K[i],mx=max(mx,N[i]);
	if(mx<=100)Om=4;
	shai(mx);
	for(int o=0;o<T;o++){
		int ans=0;
		for(int i=0,j=1;i<=Om;i++,j=1ll*j*K[o]%p)
			ans=(ans+1ll*G[N[o]][i]*j)%p;
		cout<<ans<<endl;
	}
#ifndef ONLINE_JUDGE
	cerr<<endl<<(double)clock()/CLOCKS_PER_SEC;
#endif
}
```
~~关于我追求速度离线后被卡空间了这档子事~~

---


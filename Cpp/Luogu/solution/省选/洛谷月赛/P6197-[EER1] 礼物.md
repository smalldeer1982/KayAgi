# [EER1] 礼物

## 题目背景

### Update：

时限扩大到 3 秒。

## 题目描述

小 Z 送了你一个数列，具体的，有 $a_1=1$，$a_2=2$，$a_i=2a_{i-1}+ka_{i-2}(3\le i\le n)$，其中 $n$ 是数列的长度，$k$ 是她设定的一个正整数参数。

小 Z 告诉你一个秘密，这个数列是她精心挑选的，有着一种奇妙的性质 "Prime-smooth"—— 即对于 $n$ 以内的任何一个**质数** $p$，满足 $p\mid a_p$（$\mid$ 是整除记号）。

你很好奇是不是真的有这回事，于是你写了一个质数发生器，进行了长达三天三夜的尝试，终于发现了几个反例：有 $m$ 个质数 $p_i$ 竟然不满足小 Z 所说的性质！

由于你已经随机了很久，你相信别的质数 **一定满足** 性质。

为了表明你和小 Z 心有灵犀，你现在想猜出小 Z 当时设定的参数 $k$，由于答案很大，你只需要求出最小的 $k$ 对一个质数 $c$ 取模即可。

## 说明/提示

**【样例 1 解释】**

注意第 $3$ 个质数是 $5$。

当 $k=20$ 时，$a_2=2$，$a_3=24$，$a_7=19264$ 均符合 $p\mid a_p$，并且 $a_5=656$ 符合 $p\nmid a_p$。

**【数据范围】**

$10\le n\le 3\times 10^8$。

$n\lt c\lt 2^{30}$，$c=a\cdot 2^d+1(d\ge 18)$，保证 $c$ 是质数。

$0\le m\le 20$。

| 子任务编号 |    $n\leq$     |    $m\leq$     | 特殊性质 | 分值 |
| :--------: | :------------: | :------------: | :------------: | :--: |
|     1      | $10^6$ | $20$ ||  10   |
|     2      | $5\times 10^7$ | $20$ ||  20  |
|     3      | $2\times 10^8$ | $0$ ||  10  |
|     4      | $2\times 10^8$ | $6$ ||  10  |
|     5      | $3\times 10^8$ | $0$ | $c=998244353$ |  20  |
|     6      | $3\times 10^8$ | $0$ ||  20  |
|     7      | $3\times 10^8$ | $20$ ||  10  |

## 样例 #1

### 输入

```
10 1 998244353
3```

### 输出

```
20```

## 样例 #2

### 输入

```
40 2 1018429441
1
4```

### 输出

```
-1```

# 题解

## 作者：iostream (赞：11)

出题人来发一下官方题解qwq

### 题意

定义数列 $a_1=1,a_2=2,a_n=2a_{n-1}-ka_{n-2}$。

已知对于 $n$ 以内只有 $m$ 个给定的质数不满足 $p\mid a_p$ ，其他质数均满足。

求最小可能的 $k$。取模 ntt 模数 $c$。

$n\le 3\times 10^8,m\le 20$

可以做 $n\le 10^9,m\le 20$

2s

### Sol

首先考虑答案是什么：

##### 方法1：数学推导

算出通项为 $a_n={(1+\sqrt {k+1})^n-(1-\sqrt {k+1})^n\over 2\sqrt {k+1}}$。

用二项式定理展开通项可以得到 $a_p=\sum_{i=0}^{p-1\over 2} {p \choose 2i+1} (k+1)^i$。

由于 $p$ 是质数然后有 $p\choose i$ 仅当 $i=0$ 或 $i=p$ 时为1，否则等于0。

$a_p=(k+1)^{p-1\over 2} \pmod p$ 

当且仅当 $k\equiv -1 \pmod p$ 时 $p\mid a_p$。

根据中国剩余定理，可以解出最小的 $k$ 等于 $p_1p_2\dots p_m-1$，$p_i$ 是所有满足 $p_i|a_{p_i}$ 的奇质数。

那么题意是求质数前缀积，除去其中若干个质数。

##### 方法二：打表找规律

结论与上述相同。

#### 部分分

略

#### 一个简单的 std 做法，不用卡常

依然压位保存质数表，考虑使用埃氏筛法，首先去掉 3 的倍数和所有偶数；

枚举 $p=-1 \pmod 6$ 的质数，筛去形如 $p^2+6kp$ 以及 $p^2+(6k+2)p$ 的合数。

枚举 $p=1 \pmod 6$ 的质数，筛去形如 $p^2+6kp$ 以及 $p^2+(6k+4)p$ 的合数。

然后还有枚举的 $p$ 应该是在 $\sqrt n$ 以内的。

最后可以遍历一遍所有质数乘起来，这个不是时间瓶颈。

直接写应该就可以通过，时间复杂度 $O(n\log\log n)$ 常数大概 $1\over 18$。

参考代码：
```cpp

int n,m,q,a[233],mod,ans=1;

struct bitst {
	uint64_t buf[301000000/64/2+1];
	bool operator[](const int&x)
	{ return buf[x>>6]>>(x&63)&1; }
	void set(const int&x)
	{ buf[x>>6]|=1ull<<(x&63); }
}v;

void solve()
{
	scanf("%d%d%d",&n,&q,&mod);
	for(int i=0; i<q; i++){
		scanf("%d",a+i),--a[i];
		if(!a[i])return puts("-1")*0;
	}
	sort(a,a+q);
	q=unique(a,a+q)-a;
	v.set(0);
	for(int i=9; i<=n; i+=6)
		v.set(i>>1);
	m=n>>1;
	for(int i=2,j=3; (2*i+1)*(2*i+1)<=n; i+=3,j+=3)
	{
		if(!v[i])
		{
			for(int k=6*i+3,x=i*(i+1)*2,y=x+i*2+1; x<=m; x+=k,y+=k)
				v.set(x),v.set(y);
		}
		if(!v[j])
		{
			for(int k=6*j+3,x=j*(j+1)*2,y=x+j*4+2; x<=m; x+=k,y+=k)
				v.set(x),v.set(y);
		}
	}
	int L=n/2/64,now=0,j=0;
	for(int i=0; i<L; i++)
	for(uint64_t s=~v.buf[i]; s; s&=s-1)
	{
		int p=(__builtin_ctzll(s)+(i<<6))<<1|1;
		for(++now; j<q&&a[j]<now; ++j);
		if(a[j]!=now)ans=1ll*ans*p%mod;
	}
	for(uint64_t s=~v.buf[L]; s; s&=s-1)
	{
		int p=(__builtin_ctzll(s)+(L<<6))<<1|1;
		if(p>n)break;
		for(++now; j<q&&a[j]<now; ++j);
		if(a[j]!=now)ans=1ll*ans*p%mod;
	}
	printf("%d",ans-1);
}
```

#### 正经的做法（与比赛题无关，$n \le 10^9$）

求质数前缀积可以用类似 min-25 筛的做法，需要先求出根号个 $\lfloor \frac n i \rfloor$ 处的阶乘，然后枚举最小质因子 $p$ 作除法。

计算阶乘可以用分块+倍增的方法计算，复杂度 $O(\sqrt n\log n) $ ，需要加记忆化。

min-25筛的时候还需要记录素数个数，然后要除去这么多个 $p$ 的因子。

时间复杂度大概是 $O(n^{0.75})$。空间 $O(n^{0.5})$。

然后还有一个问题是求第 k 个质数，显然可以二分+min-25筛，

还有一种更简单的方法，是分段打表+区间筛法，预处理 $i\times 10^6$ 的位置的质数个数，求第 k 个质数定位到某个合法区间以后跑区间筛法求即可。

min-25筛部分的参考代码（感谢 rushcheyo）：

```cpp
int solve()
{
	for (int i = m; i; --i)
		f[i] = fact(val[i]);
	for (int j = 1; j <= p[0]; ++j) {
		static int tmp_pw[30];
		tmp_pw[0] = invp[j];
		for (int i = 1; i < 30; ++i) tmp_pw[i] = 1ll * tmp_pw[i - 1] * tmp_pw[i - 1] % P;
		for (int i = 1, k, lstk = -1, lstval = -1; i <= m && p[j] * p[j] <= val[i]; ++i) {
			k = val[i] / p[j] <= BB ? id1[val[i] / p[j]] : id2[n / (val[i] / p[j])];
			int tmp = g[k] - (j - 1);
			g[i] -= tmp;
			if (k != lstk) {
				lstval = 1ll * pro[j - 1] * getinv(f[k]) % P;
				for (; tmp; tmp &= tmp - 1) lstval = 1ll * lstval * tmp_pw[__builtin_ctz(tmp)] % P;
				lstk = k;
			}
			f[i] = 1ll * f[i] * lstval % P;
		}
	}
	return 1ll * getinv(2) * (f[1] + P) % P;
}
```

代码得到 $[1,n]$ 的奇素数积。

预处理阶乘的部分参见 P5282 快速阶乘算法。

---

## 作者：WYXkk (赞：4)

最劣解选手来水题解了……

读一遍题，发现非常奇奇怪怪，这诡异的数列，这诡异的质数，这诡异的 NTT 模数……

不管，先大力推一波数列通项。

这个递推式是

$$a_i=2a_{i-1}+ka_{i-2}$$

其特征方程为

$$x^2=2x+k$$

其两根为

$$x_1=1+\sqrt{k+1},x_2=1-\sqrt{k+1}$$

由于这个数列的通项具有如下形式

$$a_n=Ax_1^n+Bx_2^n$$

带入 $n=1,2$ 可以解得

$$A=\dfrac{1}{2\sqrt{k+1}},B=-\dfrac{1}{2\sqrt{k+1}}$$

设 $t=\sqrt{k+1}$，则~~终于可以和根号说再见了~~

$$a_n=\dfrac{(1+t)^n-(1-t)^n}{2t}$$

用二项式定理拆开

$$\begin{aligned}a_n&=\dfrac{(1+t)^n-(1-t)^n}{2t}\\&=\dfrac{\sum\limits_{i=0}^nC_n^i(t^i-(-t)^i)}{2t}\\&=\dfrac{\sum\limits_{i=0}^{\lfloor(n-1)/2\rfloor}C_n^{2i+1}2t^{2i+1}}{2t}\\&=\sum\limits_{i=0}^{\lfloor(n-1)/2\rfloor}C_n^{2i+1}(k+1)^i\end{aligned}$$

注意到这个定理：设 $p$ 为一质数，则 $\forall\;0<i<p,p|C_p^i$（这里的 $|$ 是整除的意思）

因此，对于奇质数 $p$

$$a_p=\sum\limits_{i=0}^{(p-1)/2}C_p^{2i+1}(k+1)^i\equiv(k+1)^{(p-1)/2}\pmod p$$

因此，$p|a_p\Leftrightarrow p|(k+1)$。

于是，若一个数 $i$ 不在指定的 $m$ 个数中且 $p_i\le n$，则 $p_i|(k+1)$，否则 $p_i\not|(k+1)$。

因此，答案就是除去某些给定的质数的质数前缀积再减一。

无解的情况：给定的数中有 $1$。

然后我用线筛+卡常过了。

$\texttt{code:}$

（由于常数等原因，这份代码过不了，请自行脑补火车头等）

（另外，这份代码使用了一些 C++11 的内容，不加 `-std=c++11` 会 CE）

```cpp
#include<cstdio>
#include<iostream>
#include<fstream>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
#define Set(a) memset(a,0,sizeof(a))
#define F(i,a,b) for(register int i=a,i##end=b;i<=i##end;++i)
#define UF(i,a,b) for(register int i=a,i##end=b;i>=i##end;--i)
#define openf(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
#define re register
#define ri re int
#define il inline
typedef long long ll;
typedef unsigned long long ull;
template<typename T> inline T rd(T& x)
{
	T f=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(T)(c-'0');
	x*=f;
	return x;
}
ll rd(){ll x;rd(x);return x;}
inline int max(int a,int b){return a>b?a:b;}
inline int min(int a,int b){return a<b?a:b;}
const int inf=1<<30;

#include<vector>
const int M=300000000;
bool isnp[M+1];
vector<int> prs;
void shai()
{
	isnp[0]=isnp[1]=true;
	F(i,2,M)
	{
		if(!isnp[i]) prs.push_back(i);
		for(auto&j:prs) {if(j*i>M)break;isnp[i*j]=true;if(i%j==0)break;}
	}
}
int main()
{
	shai();
	ll n,m,c;
	rd(n);rd(m);rd(c);
	ll f[25];
	F(i,1,m) rd(f[i]);
	sort(f+1,f+m+1);
	ll ans=1,pos=1;
	if(f[1]==1) {puts("-1");return 0;}
	F(i,1,prs.size()-1)
	{
		if(prs[i]>n) break;
		if(f[pos]==i+1) {while(f[pos]==i+1) ++pos;continue;}
		ans=ans*prs[i]%c;
	}
	printf("%lld\n",ans-1);
	return 0;
}
```



---

## 作者：NaCly_Fish (赞：3)

赛后看题人随便来写一写，，
****
递推式特征方程为
$$(x-1)^2=k+1$$
解得 $x =1 \pm \sqrt{k+1}$，根据数列前两项算出通项为
$$a_n=\frac{(1+\sqrt{k+1})^n-(1-\sqrt{k+1})^n}{2\sqrt{k+1}}$$
用二项式定理大力展开，得到
$$2\sqrt{k+1}a_n=\sum_{i=0}^n\binom{n}{i}(\sqrt{k+1})^i-\sum_{i=0}^n\binom{n}{i}(-1)^i(\sqrt{k+1})^i$$
这个和式的偶数项都可以消去，化简为
$$2\sqrt{k+1}a_n=2\sum_{i=0}^{\lfloor (n-1)/2 \rfloor}\binom {n}{2i+1}(\sqrt{k+1})^{2i+1}$$
$$a_n=\sum_{i=0}^{\lfloor (n-1)/2 \rfloor}\binom {n}{2i+1}(k+1)^i$$

由于这里只用考虑奇质数项的值（对于 $2$ 可以不用考虑，因为总是满足条件的），对于 $k \in[1,p-1] \cap \mathbb Z$ 都有
$$\binom pk \equiv 0 \pmod p$$

所以除最后一项外，前面的都为 $0$，就化简成了这样
$$a_p \equiv(k+1)^{(p-1)/2}\pmod p$$

要让 $p \mid a_p$，只能让 $k\equiv -1 \pmod p$；也就是说对于所有的 $p \mid a_p$，$p \mid (k+1)$。

那么最小的 $k$ 显然就是所有这样的奇质数的乘积 $-1$。

这样就能 $\Theta(n \log \log n)$ 或 $\Theta(n)$ 解决。
****
对于出题人提到的 $\Theta(n^\frac{3}{4})$ 解法，我太菜不会 min25 筛，先留坑（

---

## 作者：zzy2333 (赞：2)

月赛的时候没做出来。。。

赛后发现其实不是难题，发个题解~~造福人类~~



------------

~~特征方程是啥，不会~~

考虑构造一个 $k$

如果我们不要求 $k$ 是正整数，找找规律，发现 $k=-1$ 时 $a_i=i$

证明?

对于 $a_1,a_2$ 显然成立

对于 $i\geq 3$ ，假设对于前 $i-1$ 项成立

$a_i= 2\times(a_{i-1})-a_{i-2}=2\times(i-1)-(i-2)=i$

归纳得证



------------

如果要求正整数呢?

在模意义下上述推导过程不变，所以我们只要要求对于给定的所有质数 $p$ ，均有 $k\equiv-1(\mod p\ )$ 即可

最小的 $k$ 显然就是 $\prod p-1$

线性筛卡一卡常就行了

卡常没有什么特别好的办法，我是循环展开+火车头，又加了下面这个优化才过的

```cpp
if((!(i&1))&&(i<<1)<=n){
	v[i<<1]=1;
	continue;
}
```
只判 2 是最快的，判了 3 反而会慢

~~还有，在代码开头加上 CZ AK IOI 会显著提高运行效率~~

下面是由于卡常而惨不忍睹的代码

```cpp
//CZ AK IOI
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<bitset>
using namespace std;
int n,m,mod;
int p[30];
int prime[16252326],tot=0;
bitset<300000010>v;
int main(){
	scanf("%d%d%d",&n,&m,&mod);
	for(register int i=2;i<=n;++i){
		if(!v[i]){
			prime[++tot]=i;
		}
		if((!(i&1))&&(i<<1)<=n){
			v[i<<1]=1;
			continue;
		}
		for(register int j=1;j<=tot;j+=4){
			if(i*prime[j]>n)break;
			v[i*prime[j]]=1;
			if(!(i%prime[j]))break;
			if(j+1>tot)break;
			if(i*prime[j+1]>n)break;
			v[i*prime[j+1]]=1;
			if(!(i%prime[j+1]))break;
			if(j+2>tot)break;
			if(i*prime[j+2]>n)break;
			v[i*prime[j+2]]=1;
			if(!(i%prime[j+2]))break;
			if(j+3>tot)break;
			if(i*prime[j+3]>n)break;
			v[i*prime[j+3]]=1;
			if(!(i%prime[j+3]))break;
		}
	}
	for(int i=1;i<=m;i++){
		scanf("%d",&p[i]);
		if(p[i]==1){
			printf("-1\n");
			return 0;
		}
	}
	sort(p+1,p+m+1);
	int now=1;
	int ans=1;
	for(register int i=2;i<=tot;++i){
		if(now<=m&&p[now]==i){
			while(now<=m&&p[now]==i)now++;
			continue;
		}
		ans=(1ll*ans*prime[i])%mod;
	}
	printf("%d\n",(ans-1+mod)%mod);
	return 0;
}
```

---

## 作者：VinstaG173 (赞：2)

真的是道好题。太妙了。

~~记得时限 2s 的时候我们都发誓记住 iostream 的来着~~

首先我们知道这种数列经典操作就是求通项公式。这里使用特征根法。

首先数列的特征方程为 $x^2-2x-k=0$，解得特征根为 $x_{1,2}=1 \pm \sqrt{1+k}$。

然后解方程 $sx_1+tx_2=1,sx_1^2+tx_2^2=2$ 得 $s=\dfrac{1}{2\sqrt{1+k}},t=-\dfrac{1}{2\sqrt{1+k}}$。

于是我们得到通项公式：

$$a_n=\dfrac{(1+\sqrt{1+k})^n-(1-\sqrt{1+k})^n}{2\sqrt{1+k}}$$

然后我们把上面的分子展开得到：

$$a_n=\sum_{i=0}^{\left\lfloor \frac{n-1}{2} \right\rfloor}(1+k)^iC_n^{2i+1}$$

其中 $C$ 是我们都很熟悉的组合数。

然后我们发现偶质数 $2$ 一定整除 $a_2$。于是我们首先特判 $2$。

接着我们看对于奇质数 $p$ 的情况。

我们发现对于 $p$，所有的 $C_p^{2i+1}$ 只有 $C_p^p=1$ 不是 $p$ 的倍数，其他都是 $p$ 的倍数。

接着我们知道 $p$ 是否整除 $a_p$ 等价于 $p$ 是否整除 $1+k$。

所以我们只要线性筛预处理出所有奇质数乘积，每次乘上逆元就行了。判重，特判 $2$，这题做完了。

不知道有没有人和我一样习惯在筛质数的时候处理最小质因子被卡空间了的。。。开 bool 数组就不会 MLE 了。

话说为什么用 bitset 会 T 呀，求教。

时间复杂度 $O(n)$，吸氧卡时限过。

Code:
```cpp
#pragma GCC target("avx")
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#include<cstdio>
#define rg register
#define ll long long
ll ans=1;
int n,m,p,t;
bool mp[300000007];
int pr[40000007],cnt;
inline void init()
{
	for(rg int i=2;i<=n;++i)
	{
		if(!mp[i])
		{
			pr[++cnt]=i,(i&1)&&(ans=ans*i%p);
		}
		for(rg int j=1;i*pr[j]<=n;++j)
		{
			mp[i*pr[j]]=1;
			if(i%pr[j]==0)break;
		}
	}
}
inline ll inv(ll x)
{
	ll res=1;
	int v=p-2;
	while(v)
	{
		(v&1)&&(res=res*x%p),x=x*x%p,v>>=1;
	}
	return res;
}
int main()
{
	scanf(" %d %d %d",&n,&m,&p);
	init();
	while(m--)
	{
		scanf(" %d",&t);
		if(t==1)
		{
			ans=-1;break;
		}
		if(pr[t]==0)continue;
		ans=ans*inv(pr[t])%p;pr[t]=0;
	}
	printf("%lld\n",(~ans)?(ans+p-1)%p:-1ll);
	return 0;
}
```

---


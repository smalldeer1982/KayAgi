# 序列

## 题目描述

小 C 想出关于括号序列的一道题，但是他不怎么会造数据，所以他采取了随机的方式。

小 C 钦定了括号序列 $S$ 的长度 $N$。$S$ 初始时全为 `(`。

他初始设定了一个参数 $K$，并按照如下流程随机，直到 $K=0$：

1. 在 $[1,N]$ 的范围内**均匀随机**一个整数，把 $S$ 这一位上的括号取反（左括号变右括号，右括号变左括号）。
2. 如果本次操作使得 `(` 的数量减少了，使 $K$ 的值减 $1$。

现在数据造好了，题也就出完了。

小 C 想请你求出，在经过上述操作后，$S$ 中**最长合法括号子序列**（不要求连续）在模 $998244353$ 意义下期望有多长。


## 说明/提示

**样例解释1**

最终括号序列只有 $3$ 种，`))`，`()`，`)(`。其对应的概率分别为 $\frac{1}{2}$，$\frac{1}{4}$，$\frac{1}{4}$。

它们对应的最长合法括号子序列长度分别为 $0,2,0$。所以最终答案为 $\frac{1}{2}$，也即 $499122177$。

**数据规模：**

对于前 $5\%$ 的数据，$N=1$；  
另有 $5\%$ 的数据，$N=2$；  
另有 $5\%$ 的数据，$N\le 7$，$K\le 5$；  
另有 $15\%$ 的数据，$N\le 15$，$K\le 500$；  
另有 $ 15\%$ 的数据，$N\le 50$，$K\le 50$；  
另有 $ 15\%$ 的数据，$N\le 500$，$K\le 100$；  
对于全部的数据，保证 $1\le N,K\le 5000$。

## 样例 #1

### 输入

```
2 2```

### 输出

```
499122177```

## 样例 #2

### 输入

```
4 2 ```

### 输出

```
873463811```

## 样例 #3

### 输入

```
1919 810```

### 输出

```
488346634```

# 题解

## 作者：青葱 (赞：11)

一个显然的结论是，右括号数目相同的括号序列出现的概率相同。

令$f_{i,j}$表示当前参数为$i$，$S$中右括号的数目是$j$。

则，
$$
f_{i-1,j}=\frac{N-j+1}{N}\sum_{k=j-1}f_{i,k}\prod_{l=j}^{k}\frac{l}{N}
$$
容易用前缀和优化得到全部的$f_{0,d}$。计算出了最终有$d$个括号序列的概率，除以个数，即可得到每一种有$d$个右括号的括号序列的概率。

接下来的问题转化为对长度给定的最长合法括号子序列计数。

考虑怎么求解一个括号序列的最长合法子序列长度，给出结论：

> 令$sum_i$表示令$'('$为$1$，$')'$为$ -1$的前缀和，则有$ans=N-sum_n+2min\space sum_i$。

证明的话，考虑令$x$表示$sum_x$最小的位置，那么在此之前有$-sum_x$个右括号是不能匹配的，之后又有$(sum_n-sum_x)$个左括号不能匹配。减去不匹配的，即合法的。

问题即，为长度为$N$，共有给定个$\pm 1$，对前缀和不小于某一给定值的序列计数。考虑其组合意义，相当于初始在$(0,0)$，每次横坐标$+1$，纵坐标$\pm 1$，求出不经过某一条直线到达某一个点的方案数。折线法即可。

总复杂度$O(NK+N^2)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
template<typename T>inline T read(){
	T f=0,x=0;char c=getchar();
	while(!isdigit(c)) f=c=='-',c=getchar();
	while(isdigit(c)) x=x*10+c-48,c=getchar();
	return f?-x:x;
}
namespace run{
	const int N=5009,mod=998244353;
	inline int add(int x,int y){return x+y>=mod?x-mod+y:x+y;}
	inline int sub(int x,int y){return x>=y?x-y:x+mod-y;}
	inline int qpow(int x,int y){
		int ret=1;
		while(y){
			if(y&1) ret=1LL*x*ret%mod;
			x=1LL*x*x%mod,y>>=1;
		}
		return ret;
	}
	int fac[N],ifac[N];
	inline int C(int n,int m){
		if(n<0 || m<0 || n<m) return 0;
		return 1LL*fac[n]*ifac[m]%mod*ifac[n-m]%mod;
	}inline int calc(int n,int d,int m){return sub(C(n,n-d-m),C(n,n-d-m+1));}

	int f[N][N],n,k,inv;
	int main(){
		n=read<int>(),k=read<int>(),inv=qpow(n,mod-2);
		fac[0]=ifac[0]=ifac[1]=1;
		for(int i=1;i<=n;i++) fac[i]=1LL*fac[i-1]*i%mod;
		ifac[n]=qpow(fac[n],mod-2);
		for(int i=n-1;i>=1;i--) ifac[i]=1LL*ifac[i+1]*(i+1)%mod;
		assert(1LL*fac[n-1]*ifac[n-1]%mod==1);

		f[0][0]=1;
		for(int i=1;i<=k;i++){
			int sum=f[i-1][n];
			for(int j=min(n,i);j;j--){
				sum=(1LL*sum*j%mod*inv+f[i-1][j-1])%mod;
				f[i][j]=1LL*inv*(n-j+1)%mod*sum%mod;
			}
		}
		int chk=0;
		for(int i=0;i<=n;i++) chk=add(chk,f[k][i]);
		assert(chk==1);

		for(int i=1;i<=n;i++) f[k][i]=1LL*f[k][i]*qpow(C(n,i),mod-2)%mod;
		int ans=0;
		for(int i=1;i<=n;i++)
			for(int j=2;j<=n && min(i,n-i)>=j/2;j+=2)
				ans=(1LL*f[k][i]*calc(n,i,(j-2*i)/2)%mod*j+ans)%mod;
		printf("%d\n",ans);
		return 0;
	}
}
int main(){
#ifdef my
	freopen("sequence.in","r",stdin);
	freopen("sequence.out","w",stdout);
#endif
	return run::main();
}
```


---

## 作者：daniEl_lElE (赞：2)

考虑 $dp_{i,j}$ 表示用了 $i$ 次有效操作，有 $j$ 个右括号的概率。

* $dp_{i,j}\times\frac{n}{j}\to dp_{i,j-1}$；
* $dp_{i,j}\times\frac{n-j}{j}\to dp_{i+1,j+1}$。

不难发现所有有 $j$ 个右括号的序列在 $dp_{k,j}$ 中随机。

将 `(` 看作 $1$，`)` 看作 $-1$，枚举右括号数量与前缀和的 $\min$，分别记为 $j,p$。问题转化为从 $(0,0)$ 每次走到 $(x+1,y+1)$ 或 $(x+1,y-1)$ 走到 $(n,n-2j)$ 且不碰到 $y=-p-1$ 的方案数，显然可以反射法解决。

总复杂度 $O(n^2)$。

```cpp
#include <bits/stdc++.h>
#define int long long
#define double long double
#define mid ((l+r)>>1)
using namespace std;
const int mod=998244353;
int qp(int a,int b){
	int ans=1;
	while(b){
		if(b&1) (ans*=a)%=mod;
		(a*=a)%=mod;
		b>>=1;
	}
	return ans;
}
int f[5005][5005],C[5005][5005],invC[5005];
int binom(int i,int j){
	if(i<0||j<0||i<j) return 0;
	return C[i][j];
}
signed main(){
	for(int i=0;i<=5000;i++) C[i][0]=1;
	for(int i=1;i<=5000;i++) for(int j=1;j<=i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;
    int n,k; cin>>n>>k;
    for(int i=0;i<=n;i++) invC[i]=qp(C[n][i],mod-2);
    int invn=qp(n,mod-2);
    f[0][0]=1;
    for(int i=0;i<k;i++){
    	for(int j=n;j>=0;j--){
    		if(j!=0) (f[i][j-1]+=f[i][j]*invn%mod*j)%=mod;
    		if(j!=n) (f[i+1][j+1]+=f[i][j]*invn%mod*(n-j))%=mod;
		}
	}
	int ans=0;
	for(int i=0;i<=n;i++){
		//to (n,n-2i)
		for(int j=-i+1;j<=min(0ll,n-2*i);j++){
			//to (n,2j-(n-2i)-2)
			(ans+=f[k][i]*invC[i]%mod*(binom(n,i)-binom(n,i+j-1)+mod)%mod)%=mod;
		}
	}
	cout<<ans*2%mod;
	return 0;
}
```

---

## 作者：b2019dy (赞：2)

来为此题，提供个做法  
非常显然的思路是k个右括号的概率是相同的  
前面做一次DP就可以了，其他题解说的很详细不再赘述  
考虑怎么求后面的有k个右括号时的期望  
注意到在删除所有匹配括号对后  
原序列构成 $)))(((($的形式  
设共有k个，那么把原图分成了k+1段  
每一段的方案数是卡特兰数，那么我们要求卡特兰数1到n+1次方中各一项  
$\frac{1}{\sqrt{1-4x}}(\frac{1-\sqrt{1-4x}}{2x})^k=\sum C_{2*i+k}^{i}x^i$  
这是广义二项级数式子，可以使用拉格朗日反演证明，想了解的可以去看EI的博客  
那么我们只需要求一项，所以暴力卷积一个$\sqrt{1-4x}$就好  
最后暴力枚举左右括号数量算答案即可  
$O(n^2)$
```cpp
#include<iostream>
#include<iomanip>
#include<cstring>
#include<cmath>
#include<cstdio>
#include<queue>
#include<algorithm>
using namespace std;
const int maxn=15000;
const int mod=998244353;
int n,k;
long long ans=0,fir[maxn+5],inv[maxn+5],c[maxn+5],p[5005],s[5005],A[5005],B[5005];
int f[5005][5005],sum[5005],dp[5005][5005];
long long revn;
long long ksm(long long x,long long n)
{
	long long ans=1;
	while(n)
	{
		if(n&1) ans=ans*x%mod;
		x=x*x%mod;
		n>>=1;
	}
	return ans;
}
void pre()
{
	fir[0]=1;
	for(int i=1;i<=maxn;i++) fir[i]=fir[i-1]*i%mod;
	inv[maxn]=ksm(fir[maxn],mod-2);
	for(int i=maxn-1;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;
}
long long C(int n,int m)
{
	if(n<m) return 0;
	
	return fir[n]*inv[m]%mod*inv[n-m]%mod;
}
int main()
{
	pre();
	scanf("%d%d",&n,&k);revn=ksm(n,mod-2);
	c[0]=1;
	for(int i=1;i<=n;i++) c[i]=(C(2*i,i)-C(2*i,i-1)+mod)%mod;
	dp[0][0]=1;
	for(int i=1;i<=k;i++)
	{
		for(int j=1;j<=n;j++) dp[i][j]=(dp[i][j]+1ll*dp[i-1][j-1]*(n-j+1)%mod*revn%mod)%mod;
		if(i!=k) for(int j=n;j>=0;j--) dp[i][j]=(dp[i][j]+1ll*dp[i][j+1]*(j+1)%mod*revn%mod)%mod;
	}
	for(int i=0;i<=n;i++) p[i]=dp[k][i]*ksm(C(n,i),mod-2)%mod;
	for(int i=1;i<=n+1;i++)
	{
		for(int j=0;j<=n;j++) A[j]=C(2*j+i,j);
		B[0]=1;
		for(int j=0;j<=n;j++) B[j+1]=-2*c[j]%mod;
		int x=(n-i+1)/2;
		for(int j=0;j<=x;j++) s[i]=(s[i]+A[j]*B[x-j]%mod)%mod;
	}
	long long ans=0;
	for(int i=0;i<=n;i++)
	for(int j=0;j+i<=n;j++) if(!((n-i-j)&1)) ans=(ans+s[i+j+1]*p[i+(n-i-j)/2]%mod*(n-i-j)%mod)%mod;
	printf("%lld\n",ans);
}
```


---

## 作者：谁是鸽王 (赞：2)

### 【题解】P6689 序列

[blogs](https://www.cnblogs.com/winlere/p/13378564.html)

任何一个有$i$个右括号的括号序列被那个算法生成的概率是一样的，先设$dp(i,j)$表示已经填了$i$个括号其中$j$个是左括号的概率。

转移是
$$
dp(i,j)={n-i+1\over n}dp(i-1,j-1)+\sum_{j=i}^n { j\times (j-1)\times (j-2)\dots \times i=j^{\underline {j-i+1}} \over n^{j-i+2}}(n-i+1)
$$
可以简单做到$O(n^2)$

现在还少一个东西，那就是一个有$f_j=j$个右括号的长度为$n$的括号序列期望有多少匹配(括号匹配指方案数是卡特兰数那种匹配)数，枚举一对括号匹配在哪个地方并且产生一的贡献，可以发现这一对括号匹配之间必须完美匹配，方案数是卡特兰数。
$$
f_j=\sum_{i=2}^n \sum_{j=0}^{\lfloor{i-2\over 2}\rfloor}  C_j {n-2j-2\choose t-1-j}= \sum_{j=0}^{\lfloor{n-2\over 2}\rfloor} C_j (n-(2j-2)+1){n-2j-2\choose t-1-j}
$$
复杂度$O(n^2)$

```cpp
//@winlere
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cstdio>
#include<initializer_list>

using namespace std; typedef long long ll;
int qr(){
	int ret=0,c=getchar(),f=0;
	while(!isdigit(c)) f|=c==45,c=getchar();
	while( isdigit(c)) ret=ret*10+c-48,c=getchar();
	return f?-ret:ret;
}
const int maxn=5015;
const int mod=998244353;
int jc[maxn<<1],inv[maxn<<1],invc[maxn<<1],dp[maxn][maxn],f[maxn<<1],temp[maxn],mi[maxn];
int MOD(const int&x,const int&y){return 1ll*x*y%mod;}
int MOD(const int&x){return x>=mod?x-mod:x;}
int MOD(const initializer_list<int>&ve){int ret=1;for(auto t:ve) ret=MOD(ret,t); return ret;}

int ksm(const int&ba,const int&p){
	int ret=1;
	for(int t=p,b=ba;t;t>>=1,b=MOD(b,b))
		if(t&1) ret=MOD(ret,b);
	return ret;		
}
void pre(const int&n){
	jc[0]=inv[0]=1; jc[1]=inv[1]=invc[1]=1;
	for(int t=2;t<=n;++t) jc[t]=MOD(jc[t-1],t),invc[t]=MOD(invc[mod%t],mod-mod/t),inv[t]=MOD(inv[t-1],invc[t]);
}

int c(const int&n,const int&m){return n<m||m<0?0:MOD(jc[n],MOD(inv[n-m],inv[m]));}
int cat(int n){return MOD(c(2*n,n),invc[n+1]);}

int main(){
	pre(1e4+5);
	int n=qr(),k=qr();
	dp[0][0]=1; mi[0]=1;
	for(int t=1;t<=n+5;++t) mi[t]=MOD(mi[t-1],invc[n]);
	for(int t=1;t<=k;++t){
		for(int i=n;i;--i) temp[i]=MOD(MOD({dp[t-1][i],jc[i],mi[i+2]})+temp[i+1]);
		for(int i=1,g=n;i<=n;++i,g=MOD(g,n)){
			int ret=0;			
			ret=MOD(ret+MOD({dp[t-1][i-1],n-i+1,invc[n]}));
			ret=MOD(ret+MOD({temp[i],n-i+1,g,inv[i-1]}));
			dp[t][i]=ret;
		}
	}
	int ans=0;
	for(int t=0;t<=n;++t){
		int ret=0;
		for(int j=0;j<=n/2-1;++j){
			int sav=MOD({cat(j),n-2*j-1,c(n-2*j-2,t-1-j)});
			ret=MOD(ret+sav);
		}
		ans=MOD(ans+MOD({inv[n],jc[t],jc[n-t],dp[k][t],ret,2}));
	}
	printf("%d\n",ans);
	return 0;
}


```


---

## 作者：SFlyer (赞：1)

一个很好的题。

容易发现因为是均匀随机，所以所有右括号数量相等的方案概率一样。因此先求出每一种个数的出现的概率，可以 dp 求出，不再赘述。

首先考虑对于一个确定的括号序列中最长合法括号子序列的长度是多少，长度显然是 $n$ 减去不可以匹配的括号个数。首先如果有连续的 `()`，可以直接拿掉，这样括号序列就变成了 `))...)((...(` 的形式。设 $mn$ 为设 `(` 为 $1$，`)` 为 $-1$ 的最小前缀的值，那么前半部分没有匹配的 `)` 个数是 $|mn|=-mn$，设 $a$ 为整个序列的值，那么后半部分没有匹配的 `(` 个数就是 $a-mn$，因此 最长合法括号子序列的长度是 $n-(a-mn-mn)=n-a+2mn$。

枚举右括号的个数，设为 $x$。那么 $a$ 可以表示为 $n-2x$，因此我们要求的就是 $n-(n-2x)+2mn=2(x+mn)$ 的期望，也就是现要求出 $2\sum (x+mn)$。考虑再枚举 $mn$。

其实根据 $E=\sum P(X>i)$，我们可以算出大于一个数的个数的和。

那么就变成了一个这样的问题：现在你从 $(0,0)$ 出发，每一次往上（左括号）或者往右（右括号），走到 $(x,n-x)$。不经过直线 $y=x-mn-1$ 的方案数。这个直接反射容斥即可。

时间复杂度 $\mathcal{O}(nk+n^2)$。

---


# 象棋与马

## 题目背景

Amazing John 做了一个梦，梦到他下辈子是个象棋大师。

因为人与人之间是不能一概而论的，马与象之间也不能相提并论。

Amazing John 在极度愤怒的情况下创造了一种新的棋：马棋。

“啊这，不会真有人不会下这种棋吧？”

现在他想请你来体验一下这种新棋。

## 题目描述

Amazing John 有一个无限大的棋盘来下马棋。

有一个马最开始在 $(0,0)$，它的每一步可以走一个 $a\times b$ 的矩形（ 即能够从$(x,y)$到达 $(x\pm a,y\pm b)$ 或 $(x\pm b,y\pm a)$ ）。

若马通过上述移动方式可以到达棋盘中任意一个点，那么 $p(a,b)=1$，否则 $p(a,b)=0$。

现在 Amazing John 给你 $T$ 组询问，每组询问他会给出一个正整数 $n$，他想知道 

$$\left ( \sum_{a=1}^n\sum_{b=1}^np(a,b) \right )\bmod\ 2^{64}$$

的值。

## 说明/提示

样例解释：当 $n=3$ 时，值为 $1$ 的有 $p(1,2),p(2,1),p(2,3),p(3,2)$。

**本题开启Subtask**
|子任务|数据点|数据范围|分数|
|-|-|-|-
|$1$|$1$|$n\leq 10,T\leq5$|$5$|
|$2$|$2\sim 5$|$n\leq 3000,T\leq5$|$15$|
|$3$|$6\sim 10$|$n\leq 10^5,T\leq 5$|$15$|
|$4$|$11\sim 15$|$n\leq 10^7,T\leq5$|$15$|
|$5$|$16\sim 18$|$n\leq10^9,T\leq 5$|$15$|
|$6$|$19\sim 25$|$n\times T\leq 10^{11},T\leq 5$|$35$|

注 1：对于 $n\times T\geq 5*10^{10}$ 的数据点，时限为 **4s** ，其余均为 **2.5s** 。且对于所有数据点，空间限制为 **500MB** 。

注 2：输出答案 $\bmod\ 2^{64}$ 即对 **64位无符号整数** 自然溢出。

本题开启 -O2 优化开关。

## 样例 #1

### 输入

```
3
2
3
4```

### 输出

```
2
4
8```

# 题解

## 作者：QuantAsk (赞：12)

出题人先来报个到，比赛的时候发现许多选手的做法都和我的不一样/kk。也有莫比乌斯反演过了的神仙。也十分感谢本题的验题人 beginend 和 my_dog。

# T4 象棋与马

这个马能走到全图的充要条件显然是它能走到 $(0,1)$。考虑给出 $x,y$ 求它能否走到 $(0,1)$。

## 算法1：

暴力 bfs 看是否能到达 $(0,1)$ 或打表。

期望得分 $5pts$。

##  算法2：

请注意下文中 $(X,Y)$ 表示当前马的坐标，$x,y$ 表示马一步走的矩形的长和宽。

考虑从数论角度考虑本题。

首先如果当 $gcd(x,y)\neq 1$ 显然不行。

因为走的顺序时无所谓的，所以可以将走的路程分成两段，一段只有是 $(X\pm x,Y\pm y)$ 的位移，一段是只有 $(X\pm y,Y\pm x)$ 的位移。

显然对于第一段能走到的点可以表示为 $(2ax,2cy)$ 或 $(2ax+x,2cy+y)$。第二段同理为 $(2by,2dx)$ 或 $(2by+y,2dx+x)$。其中 $a,b,c,d\in \mathbb{Z}$。那么我们可以推出公式有
$$
\left\{\begin{matrix} 2ax=2by
\\ 2cy=2dx+1
\end{matrix}\right.
$$

$$
\left\{\begin{matrix} 2ax+x=2by
\\ 2cy+y=2dx+1
\end{matrix}\right.
$$

$$
\left\{\begin{matrix} 2ax=2by+y
\\ 2cy=2dx+x+1
\end{matrix}\right.
$$

$$
\left\{\begin{matrix} 2ax+x=2by+y
\\ 2cy+y=2dx+x+1
\end{matrix}\right.
$$

设 $k$ 是任意整数。

解第一个方程组得到  $2(ax-by)=0$ 且 $2(cy-dx)=1$。因为 $x,y$ 互质，所以 $(ax-by)$ 和 $(cy-dx)$ 都可以表示成任意整数。所有就有 $2k=0$ 且 $2k=1$，显然无解。

同理第二个方程组可以推出 $2k+x=0$ 且 $2k+y=1$，就是 $x$ 是偶数，$y$ 是奇数。

第三个方程组推出 $2k-y=0$ 且 $2k-x=1$，就是 $x$ 是奇数，$y$ 是偶数。

第四个方程组推出 $2k+x-y=0$ 且 $2k+y-x=1$，显然无解。

所以 $p(x,y)=1$ 当且仅当 $gcd(x,y)=1$ 且 $x+y$ 是一个奇数。

然后暴力求出所有的 $p(x,y)$ 即可，期望得分 $20pts$。

## 算法3：

如果 $x+y$ 是一个奇数那么 $x-y$ 也是一个奇数，所以 $gcd(x,x-y)=1$ 且 $x-y$ 是一个奇数也是 $p(x,y)=1$ 的充要条件。

定义 $w(x)$ 表示 $1\sim x$ 中有多少个奇数与 $x$ 互质，考虑如何计算 $w(x)$。

显然如果 $x$ 是一个偶数，那么没有偶数与它互质，即 $w(x)=\varphi(x)$，我们不难发现 $ans=\sum_{i=1}^{n}w(x)\times 2-2$。

如果 $x$ 是一个奇数，对于一个奇数 $k$，有 $gcd(x,k)=1$ 那么就有 $gcd(x,x-k)=1$ 也就是对于每个奇数与它互质那么一定有一个对应的偶数 $x-k$ 与它互质，也就是 $w(x)=\frac{\varphi(x)}{2}$，当然对于 $w(1)$ 需要进行特判。

那么显然线性求 $\varphi$ 就可以获得 $50pts$。

## 算法4：

显然答案就是奇数的 $\varphi$ 加上偶数的 $\varphi$ 除以 $2$。所以我们需要分开计算奇数和偶数的 $\varphi$

若 $n$ 是一个偶数，假设我们已经求出了 $p1=\sum_{i=1}^{n\div2}\varphi(x)$ （$x$ 是奇数）和 $p2=\sum_{i=1}^{n\div 2}\varphi(x)$（$x$ 是偶数）那么考虑如何求到 $n$。首先我们有 $\sum_{i=1}^n\varphi(x)$ （$x$ 是偶数）$=p1+p2\times 2$。（对于每个奇数乘上一个 $2$，根据 $\varphi$ 的定义我们发现它多了一个 $2$ 这个因子，而 $n$ 乘上了一个 $2$，所以 $\varphi$ 不变；而对于一个偶数乘上了一个 $2$，没有加减因子，但是 $n$ 乘上了一个 $2$，所以它的 $\varphi$ 也要乘 $2$）。

然后用杜教筛求出 $\sum_{i=1}^n \varphi(x)$ 然后减去前面求出的答案就是奇数的答案了。时间复杂度 $O(n^{\frac{2}{3}}\log n)$，预处理到 $1\sim 10^7$ 的答案即可大大缩小时间复杂度。

期望得分$100pts$。

## 算法5:

其实最终式子可以优化为递推式
$$ans(n)=ans(\lfloor \frac{n}{2}\rfloor)+\sum_{i=1}^n\varphi(i)$$
看到最终许多通过的选手都是写成这种形式的

## $others$
对于$65$的部分分是给莫比乌斯反演的，没想到有人能优化到可以通过的形式。对于$ull$自然溢出需要注意的地方，就是在杜教筛中 $n\times (n+1)$ 时需要注意让偶数的那个先除以$2$否则会溢出之后再除上一个 $2$ 就会出现 $Wrong\ Answer$ 的情况。

然后还有人写到 $35$ 的部分分是我没有预料到的（因为我都不会写，果然选手的智慧是无限的）。

## $code$
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<map>
#define ll unsigned long long
using namespace std;
const ll N=1e7+1;
ll T,n,cnt,mu[N],phi[N],pri[N];
ll sp1[N],sp2[N],p1[1100],p2[1100];
bool vis[N];
map<ll,ll> sp,sm; 
void prime(){
	phi[1]=1;
	for(ll i=2;i<N;i++){
		if(!vis[i])pri[++cnt]=i,phi[i]=i-1;
		for(ll j=1;j<=cnt&&pri[j]*i<N;j++){
			vis[pri[j]*i]=1;
			if(i%pri[j]==0){
				phi[i*pri[j]]=phi[i]*pri[j];
				break;
			}
			phi[i*pri[j]]=phi[pri[j]]*phi[i];
		}
	}
	for(ll i=1;i<N;i++){
		sp1[i]=sp1[i-1]+phi[i]*(i&1);
		sp2[i]=sp2[i-1]+phi[i]*(!(i&1));
	}
	return;
}
ll GetSphi(ll n){
	if(n<N)return sp1[n]+sp2[n];
	if(sp[n])return sp[n];
	ll rest=(n%2ull==0ull)?((ll)n/2ull*(n+1ull)):((ll)(n+1ull)/2ull*n);
	for(ll l=2ull,r;l<=n;l=r+1ull)
		r=n/(n/l),rest-=(r-l+1ull)*GetSphi(n/l);
	return (sp[n]=rest);
}
void dfs(ll x,ll n){
	p1[x]=p2[x]=0;
	if(n<N){
		p1[x]=sp1[n];
		p2[x]=sp2[n];
		return;
	}
	dfs(x+1,n/2);
	p2[x]+=p1[x+1]+p2[x+1]*2ull; 
	p1[x]+=GetSphi(n)-p2[x];
	return;
}
int main()
{
	prime();
	scanf("%llu",&T);
	while(T--){
		scanf("%llu",&n);dfs(0,n);
		printf("%llu\n",p1[0]+p2[0]*2ull-1ull);
	}
}
```


---

## 作者：STPGUY (赞：8)

# 题意

有一个马最开始在 $(0,0)$，它的每一步可以走一个 $a\times b$ 的矩形（ 即能够从 $(x,y)$ 到达 $(x\pm a,y\pm b)$ 或 $(x\pm b,y\pm a)$ ）。

若马通过上述移动方式可以到达棋盘中任意一个点，那么 $p(a,b)=1$，否则 $p(a,b)=0$。

给你 $T$ 组询问，每组给你一个 $n$，让你求：
$$
\left(\sum_{a=1}^n\sum_{b=1}^np(a,b)\right)\mod {2^{64}}
$$

## 分析

首先，本质不同的行走方案有四种，即 $(a,b),(b,a),(-a,b),(-b,a)$，那么设这四种本质不同的分别走了 $x_1,x_2,x_3,x_4$ 次，那么能够走满这个棋盘的充要条件是：
$$
\begin{cases}
ax_1+bx_2-ax_3-bx_4=1\\
bx_1+ax_2+bx_3+ax_4=0
\end{cases}
$$
只要满足了这个条件，它就可以上下左右移动了，就是说可以走满整张棋盘

那么可以化简一下上式，然后得到：
$$
\begin{aligned}
&a((x_1+x_2)-(x_3-x_4))+b((x_1+x_2)+(x_3-x_4))=1\\
\therefore &a(x-y)+b(x+y)=1
\end{aligned}
$$
那么此时可以得到两条性质：

-   $a\perp b$
-   $a\not\equiv b\pmod 2$

第一条的话，就是因为 $akx+bky=k\gcd(a,b)$；第二个的话，就是说 $x-y$ 和 $x+y$ 一定是奇偶性相同的而且只能是奇数，那么 $a、b$ 一定一奇一偶，正确性显然

所以可以得到 $p(a,b)=[a\perp b]\land a,b$奇偶性不相同

## 算法一

既然已经知道了 $a、b$ 奇偶性不同，那么就可以限制谁是奇数谁是偶数，最后 $\times2$ 就可以

时间复杂度 $O(n^2)$，期望得分 $20$ 

### Code

```cpp
#include <cstdio>

int n, t;

int gcd(int a, int b)
{
    if (b == 0) return a;
    return gcd(b, a % b);
}

int main()
{
    scanf ("%d", &t);
    while (t--) {
        int ans(0);
        scanf ("%d", &n);
        for (int i = 1; i <= n; i += 2)
            for (int j = 2; j <= n; j += 2) 
                if (gcd(i, j) == 1) ++ans;
        printf("%d\n", ans * 2);
    }
}
```

## 算法二

根据算法一，我们知道题目限制了两个数的奇偶性，那么我们先试着表达一下，再看看可以怎么化简
$$
\sum_{a=1}^n\sum_{b=1}^np(a,b)=2\times\sum_{a=1}^n\sum_{b=1}^n[a\perp b\text{且a为偶数b为奇数}]
$$
又因为 $a\perp b$ 且 $a$ 是偶数 $b$ 是奇数，那么 $a\rightarrow \frac a2$，也是可以得到 $a\perp b$ 的

所以又得到了
$$
\begin{aligned}
\sum_{a=1}^n\sum_{b=1}^n[a\perp b\text{且a为偶数b为奇数}]&=\sum_{a=1}^{\frac n2}\sum_{b=1}^n[a\perp b\text{且b为奇数}]\\
&=\sum_{a=1}^{\frac n2}\sum_{b=1}^n[a\perp b]-\sum_{a=1}^{\frac n2}\sum_{b=1}^n[a\perp b\text{且b是偶数}]
\end{aligned}
$$
感觉这个容斥还是很好想到的，那么就可以继续往下走，定义记号 $f(n,m)$ 
$$
\begin{aligned}
f(n,m)&=\sum_{a=1}^n\sum_{b=1}^m[a\perp b\text{且a为偶数b为奇数}]\\
&=\sum_{a=1}^{\frac n2}\sum_{b=1}^m[a\perp b]-\sum_{a=1}^{\frac n2}\sum_{b=1}^m[a\perp b\text{且b是偶数}]\\
&=\sum_{a=1}^{\frac n2}\sum_{b=1}^m[a\perp b]-\sum_{a=1}^{\frac n2}\sum_{b=1}^m[a\perp b\text{且a是奇数b是偶数}]\\
&=\sum_{a=1}^{\frac n2}\sum_{b=1}^m[a\perp b]-f(m,\frac n2)
\end{aligned}
$$
为了方便表述，就令
$$
\begin{aligned}
s(n,m)&=\sum_{a=1}^n\sum_{b=1}^m[a\perp b]\\
&=\sum_{a=1}^n\sum_{b=1}^m\sum_{d|\gcd(a,b)}\mu(d)\\
&=\sum_{d=1}^{\min(a,b)}\mu(d)\left\lfloor\frac nd\right\rfloor\left\lfloor\frac md\right\rfloor
\end{aligned}
$$
所以 $f(n,m)=s(\frac n2,m)-f(m,\frac n2)$

然后 $s$ 的计算可以数论分块，$f$ 递归计算，所以时间复杂度为 $O(\log n\sqrt n)$

### Code

```cpp
#include <cstdio>
#include <algorithm>

using namespace std;

typedef unsigned long long ll;
const int maxn = 1e7 + 10;
int n, t, cnt;
ll mu[maxn];
int p[maxn];
bool vis[maxn];

inline void init()
{
    mu[1] = 1;
    for (int i = 2; i < maxn; ++i) {
        if (!vis[i]) p[++cnt] = i, mu[i] = -1;
        for (int j = 1; j <= cnt && i * p[j] < maxn; ++j) {
            vis[i * p[j]] = 1;
            if (i % p[j]) mu[i * p[j]] = -mu[i];
            else break;
        }
    }

    for (int i = 1; i < maxn; ++i) mu[i] += mu[i - 1];
}

inline int min(int x, int y)
{
    if (x < y) return x;
    return y;
}

ll solve(int n, int m) 
{
    ll sum(0);
    if (n > m) swap(n, m);
    for (int l = 1, r; l <= n; l = r + 1) {
        r = min(n / (n / l), m / (m / l));
        sum += (mu[r] - mu[l - 1]) * (n / l) * (m / l);
    }
    return sum;
}

ll gc(int n, int m)
{
    if (m == 1) return 0;
    if (n == 1) return m / 2;
    ll total = solve(n, m / 2), cut = gc(m / 2, n);
    return total - cut;
}

int main()
{
    init();
    scanf ("%d", &t);
    while (t--) {
        scanf ("%d", &n);
        ll total = solve(n / 2, n), cut = gc(n / 2, n);
        ll ans = (total - cut) * 2;
        printf ("%llu\n", ans);
    }
}
```

## 满分做法

算法二的瓶颈在于空间，开不了 $10^{11}$ 的数组，所以考虑使用杜教筛或者 $Min\_25$ 筛啥的，就可以过题了

至于这个的时间复杂的的话，个人感觉是 $O(\log n\sqrt n+n^{\frac 32})$，不知道对不对

希望有大佬能告诉我正确的时间复杂度

### Code

```cpp
#include <cstdio>
#include <map>

using namespace std;

typedef unsigned long long ull;
typedef long long ll;
const int maxn = 1e7 + 10;
ll n, t, cnt;
ull mu[maxn];
int p[maxn];
bool vis[maxn];

inline void init()
{
    mu[1] = 1;
    for (int i = 2; i < maxn; ++i) {
        if (!vis[i]) p[++cnt] = i, mu[i] = -1;
        for (int j = 1; j <= cnt && i * p[j] < maxn; ++j) {
            vis[i * p[j]] = 1;
            if (i % p[j]) mu[i * p[j]] = -mu[i];
            else break;
        }
    }

    for (int i = 1; i < maxn; ++i) mu[i] += mu[i - 1];
}

inline ll min(ll x, ll y)
{
    if (x < y) return x;
    return y;
}

map <ll, ull> Mu;

ull MMu(ll x)
{
    if (x <= maxn) return mu[x];
    if (Mu[x]) return Mu[x];
    ll Ans(1);
    for (ll l(2), r; l <= x; l = r + 1)
    {
        r = x / (x / l);
        Ans -= (r - l + 1) * MMu(x / l);
    }
    return Mu[x] = Ans;
}

ull solve(ll n, ll m) 
{
    ull sum(0);
    if (n > m) swap(n, m);
    for (ll l = 1, r; l <= n; l = r + 1) {
        r = min(n / (n / l), m / (m / l));
        sum += (MMu(r) - MMu(l - 1)) * (n / l) * (m / l);
    }
    return sum;
}

ull gc(ll n, ll m)
{
    if (m == 1) return n / 2;
    if (n == 1) return 0;
    ull total = solve(n / 2, m), cut = gc(m, n / 2);
    return total - cut;
}

inline ll __read()
{
    ll x(0), t(1);
    char o (getchar());
    while (o < '0' || o > '9') {
        if (o == '-') t = -1;
        o = getchar();
    }
    for (; o >= '0' && o <= '9'; o = getchar()) {
        x = (x << 1) + (x << 3) + (o ^ 48);
    }
    return x * t;
}

int main()
{
    init();
    t = __read();
    while (t--) {
        n = __read();
        ull ans = gc(n, n) * 2;
        printf ("%llu\n", ans);
    }
}
```



---

## 作者：Ajwallet (赞：5)

@[toc]
[更好的阅读体验](https://xxyqwq.blog.csdn.net/article/details/109173430)
#### $Hyperlink$
[【LGR-078】洛谷 10 月月赛 II T4](https://www.luogu.com.cn/contest/30519#description)
[题目链接](https://www.luogu.com.cn/problem/P6860)
***
#### $Description$
一张无限大的网格，若从$(x,y)$出发，每一步可以类似于马一样移动，长度分别为$a,b$（对于经常提起的中国象棋中的马的话，则有$a=1,b=2$或$a=2,b=1$），若能到达这个网格中的任意一节节点，则$p(a,b)==1$

求$\sum _{i=1}^n\sum _{j=1}^n p(i,j)$

数据范围：

$20\%,n\leq 3000$

$50\%,n\leq 10^7$

$100\%,n\leq 10^{11}$
***
#### $Solution$
##### $20pts$
能从$(x,y)$移动到任意一个格子的充要条件是它能位移到$(x+1,y)$或$(x,y+1)$

也就是要找出一种位移方案，使得这么多步后，位移到一个格子$(x+ma+nb,y+ea+fb)$，使得$ma+nb=1$且$ea+fb=0$，对于前者，我们很容易得到$gcd(a,b)=1$

对于后者，略加思索，可以发现：$a,b$不能同时为奇数

如此这般，我们预处理3000以内的这样的$a,b$，为了节省效率，我们只算$a>b$的，最后再乘二即可

时间复杂度：$O(n^2logn)$ 实际上常数较小，可以拿到$20pts$
```cpp
#include<cctype>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define LL long long
#define ULL unsigned long long
using namespace std;int Gcd[3010][3010],k,T;
ULL sum,s[3010],n;
inline int gcd(int x,int y)
{
	if(Gcd[x][y]) return Gcd[x][y];//似乎没有多大用处的记忆化
	return Gcd[x][y]=y?gcd(y,x%y):x;
}
inline LL read()
{
	char c;LL d=1,f=0;
	while(c=getchar(),!isdigit(c)) if(c=='-') d=-1;f=(f<<3)+(f<<1)+c-48;
	while(c=getchar(),isdigit(c)) f=(f<<3)+(f<<1)+c-48;
	return d*f;
}
signed main()
{
	for(register int i=1;i<=3000;i++)
	{
		for(register int j=1;j<=i;j++)
		{
			if((i&1)&&(j&1)) continue;
			sum+=gcd(i,j)==1;
		}
		s[i]=sum;
	}
	T=read();
	while(T--)
	{
		n=read();
		printf("%llu\n",s[n]*2);
	}
}
```
##### $50pts$
假设我们已经确定了$a$，考虑怎样的$b$是合法的
刚刚我们已经得出了$a,b$互质，但又有$a,b$不同时为奇数这个限制

那么假设$a$是一个偶数，则它的贡献是不大于它且与它互质的**自然数**，即$\varphi(a)$

假设$a$是一个奇数，则它的贡献是不大于它且与它互质的**偶数**，这貌似很难办，考场的时候我是推规律推出它为$\frac {\varphi(2a)}2$【有能力证明的dalao可以在下方提一下】

如此，我们只需要线性筛出$2\times 10^7$内的$\varphi$，求个前缀和即可

时间复杂度：$O(n)$，可以拿到$50pts$
```cpp
#include<cctype>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define LL long long
#define ULL unsigned long long
using namespace std;int T,phi[20000010],prime[2000010],vis[20000010],m;
ULL n,s[10000010];
inline LL read()
{
	char c;LL d=1,f=0;
	while(c=getchar(),!isdigit(c)) if(c=='-') d=-1;f=(f<<3)+(f<<1)+c-48;
	while(c=getchar(),isdigit(c)) f=(f<<3)+(f<<1)+c-48;
	return d*f;
}
inline void prework()
{
	phi[1]=1;
	for(register int i=2;i<=20000000;i++)
	{
		if(vis[i]==0) {vis[i]=i;prime[++m]=i;phi[i]=i-1;}
		for(register int j=1;j<=m&&prime[j]*i<=20000000;j++)
		{
			if(prime[j]>vis[i]) break;
			vis[i*prime[j]]=prime[j];
			phi[i*prime[j]]=phi[i]*(i%prime[j]?prime[j]-1:prime[j]);
		}
	}
	return;
}
signed main()
{
	prework();
	for(register int i=1;i<=1e7;i++)
	{
		if(i&1) s[i]=phi[i*2]/2;
		else s[i]=phi[i];
		s[i]+=s[i-1];
	}
	T=read();
	while(T--)
	{
		n=read();
		printf("%llu\n",s[n]*2);
	}
}
```
##### $100pts$
基于$50pts$的思路，多利用些欧拉函数的性质即可

若$i$是奇数，$\varphi(2i)=\varphi(i)$
若$i$是偶数，$\varphi(2i)=2\varphi(i)$

当$i$为偶数时，$w_i=\varphi(i)$
当$i$为奇数时，$w_i=\frac{\varphi(2i)}2=\frac{\varphi(i)}2$

设$S(n)$表示答案

则$S(n)=2\sum_{i=1}^n w_i$，那么$S(n)$就等于所有偶数的$\varphi$和的两倍+所有奇数的$\varphi$的和

我们可以直接用杜教筛算出奇数+偶数的$\varphi$和（即$\varphi$的前缀和），然后考虑补上没算的偶数的贡献，这一段的贡献即为$S(\lfloor \frac n2\rfloor)$，递归处理即可，层数显然是$log$层的

时间复杂度：$O(n^{\frac 2 3}log n)$，可以通过本题
***
#### $Code$
```cpp
#include<map>
#include<cctype>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ULL unsigned long long
using namespace std;
ULL T,prime[2000010],vis[20000010],m,n,phi[20000010],s[20000010];
map<ULL,ULL>Sphi; 
inline ULL read()
{
	char c;ULL d=1,f=0;
	while(c=getchar(),!isdigit(c)) if(c=='-') d=-1;f=(f<<3)+(f<<1)+c-48;
	while(c=getchar(),isdigit(c)) f=(f<<3)+(f<<1)+c-48;
	return d*f;
}
inline void prework()
{
	phi[1]=1;
	for(register int i=2;i<=20000000;i++)
	{
		if(vis[i]==0) {vis[i]=i;prime[++m]=i;phi[i]=i-1;}
		for(register int j=1;j<=m&&prime[j]*i<=20000000;j++)
		{
			if(prime[j]>vis[i]) break;
			vis[i*prime[j]]=prime[j];
			phi[i*prime[j]]=phi[i]*(i%prime[j]?prime[j]-1:prime[j]);
		}
	}
	for(register int i=1;i<=20000000;i++) 
	{
		if(i&1) s[i]=phi[i*2]/2;
		else s[i]=phi[i];
		s[i]+=s[i-1];
		phi[i]+=phi[i-1];
	}
	return;
}
inline ULL Getphi(ULL n)
{
	if(n<=20000000) return phi[n];
	if(Sphi[n]) return Sphi[n];
	ULL res=0;
	if(n%2==0) res=n/2*(n+1);
	else res=(n+1)/2*n;//这一段要这样子弄一弄，不然可能会爆
	for(ULL l=2,r;l<=n;l=r+1)
	{
		r=n/(n/l);
		res-=(r-l+1)*Getphi(n/l);
	}
	return Sphi[n]=res;
}
inline ULL S(ULL n)
{
	if(n<=1) return 0;
	return Getphi(n)+S(n/2);
}
signed main()
{
	prework();
	T=read();
	while(T--)
	{
		n=read();
		printf("%llu\n",S(n));
	}
}
```

---

## 作者：Rorschachindark (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P6860)
# 题目大意
见题面。
# 思路
不难发现，答案其实就是：

$$2\sum_{a=1}^{n} \sum_{b=1}^{a-1} [\gcd(a+b,a-b)=1]$$

至于怎么推，直接用裴蜀定理就好了。

考虑优化，不难发现我们可以莫比乌斯反演一下，变为：

$$2\sum_{a=1}^{n} \sum_{b=1}^{a-1}\sum_{d|a+b,d|a-b}\mu(d)$$

然后交换求和顺序：

$$2\sum_{d=1}^{n} \left\{\begin{array}{l}
1.\text{for d isn't a even number}\\ 
\sum_{d|a}^{n} a/d-1\\
2. \text{for d is a even number}\\
\sum_{d/2|a} (a-1)/d
\end{array}\right.$$

化简式子可以得到：

$$2\sum_{d=1}^{n} \left\{\begin{array}{l}
1.\text{for d isn't a even number}\\ 
\lfloor\frac{n}{d}\rfloor\times (\lfloor\frac{n}{d}-1\rfloor)/2\\
2. \text{for d is a even number}\\
\lfloor\frac{n}{d}\rfloor\times (\lfloor\frac{n}{d/2}\rfloor-\lfloor\frac{n}{d}\rfloor-1)
\end{array}\right.$$

于是我们发现这个东西可以使用数论分块，不过问题就是如何求出奇、偶数的 
$\mu$ 的前缀和。我们假设我们要求偶数时的 $\mu$ 前缀和，我们假设 

$$F(n)=\sum_{i=1}^{n} \mu(i)$$

$$S(n)=\sum_{i=1}^{n/2}\mu(2i)$$

不难得到：

$$S(n)=-(F(n/2)-S(n/2))$$

可以认为因为含有因子 $4$ 的数都不会产生影响，减去就好了。

不过这个题目比较卡常，所以我们在数论分块的时候前面一部分直接来，从后面再开始分块会比较快。

时间复杂度不是特别会分析，也许是 $\Theta(n^{2/3})$ 吧。
# $\texttt{Code}$
```cpp
#include <hash_map>
#include <bits/stdc++.h>
using namespace std;

#define ull unsigned long long
#define Int register int
#define MAXN 30000005
#define ll long long

template <typename T> void read (T &x){char c = getchar ();x = 0;int f = 1;while (c < '0' || c > '9') f = (c == '-' ? -1 : 1),c = getchar ();while (c >= '0' && c <= '9') x = x * 10 + c - '0',c = getchar ();x *= f;}
template <typename T,typename ... Args> void read (T &x,Args& ... args){read (x),read (args...);}
template <typename T> void write (T x){if (x < 0) x = -x,putchar ('-');if (x > 9) write (x / 10);putchar (x % 10 + '0');}

bool vis[MAXN];ll n;
int up,tot,mu[MAXN],pre[MAXN],prime[MAXN];

void Prime (){
	mu[1] = 1;
	for (Int i = 2;i <= up;++ i){
		if (!vis[i]) prime[++ tot] = i,mu[i] = -1;
		for (Int j = 1;j <= tot && i * prime[j] <= up;++ j){
			vis[i * prime[j]] = 1;
			if (i % prime[j]) mu[i * prime[j]] = -mu[i];
			else break;
		}
	}
	for (Int i = 1;i <= up;++ i) pre[i] = pre[i - 1] + mu[i];
}

unordered_map <ll,ull> Sum;
ull Getmu (ll n){
	if (n <= up) return pre[n];
	if (Sum.find (n) != Sum.end()) return Sum[n];
	ll sum = n >= 1;
	for (ll l = 2,r;l <= n;l = r + 1){
		r = n / (n / l);
		sum -= (r - l + 1) * Getmu (n / l);
	}
	return Sum[n] = sum;
}

unordered_map <ll,ull> Sum1; 
ull GetS (ll n){//求1~n之内偶数的贡献 
	if (n <= 1) return 0; 
	if (Sum1.find (n) != Sum1.end()) return Sum1[n];
	return Sum1[n] = -(Getmu (n / 2) - GetS (n / 2));
}

signed main(){
	int T;read (T);up = 3e7,Prime ();
	while (T --> 0){
		read (n);ull cnt = 0;
		for (Int d = 1;d <= 1000000 && d <= n;++ d){
			ull ans = 0;
			if (d & 1) ans = (n / d) * (n / d + 1) / 2 - (n / d);
			else ans = (n / d - 1) * (n / d) + (n / (d / 2) - 2 * (n / d)) * (n / d);
			cnt += ans * mu[d];
		}
		for (ll l = 1e6 + 1,r;l <= n;l = r + 1){
			r = n / (n / l);
			cnt += ((n / l) * (n / l - 1) / 2) * (Getmu (r) - GetS (r) - Getmu (l - 1) + GetS (l - 1));
		} 
		for (ll l = 5e5 + 1,r;l <= n / 2;l = r + 1){
			r = min (n / 2,n / (n / l));
			cnt += (n / l / 2) * (n / l - n / l / 2 - 1) * (GetS (2 * r) - GetS (2 * l - 1));
		}
		write (cnt * 2),putchar ('\n');
	}
	return 0;
}
```

---

## 作者：chenxia25 (赞：2)

先考虑 $(n,m)$ 能走到的充要条件。注意到 $a,b$ 和 $b,a$ 两种各可以走无限步，每步加减号自选，唯一的限制就是第一 / 二种两个贡献系数要同奇同偶。设第一种两个贡献系数为 $x,z$，第二种为 $y,w$，那么可以枚举每种的奇偶性，充要条件就是下面这四个二元线性丢番图方程组至少有一个有解：
$$
\begin{cases}2xa+2yb=n\\2zb+2wa=m\end{cases}\\\begin{cases}2xa+(2y+1)b=n\\2zb+(2w+1)a=m\end{cases}\\\begin{cases}(2x+1)a+2yb=n\\(2z+1)b+2wa=m\end{cases}\\\begin{cases}(2x+1)a+(2y+1)b=n\\(2z+1)b+(2w+1)a=m\end{cases}
$$
即至少满足以下四个条件中的一个（其中 $d=\gcd(a,b)$）：
$$
2d\mid n,m\\2d\mid n-b,m-a\\2d\mid n-a,m-b\\2d\mid n-a-b,m-a-b
$$
然后考虑 $p(a,b)=1$ 的充要条件。如果不看上面四个条件的话，若 $d>1$，那么最多只能走到那些 $d\mid n,m$ 的 $(n,m)$，不可能走到全部，所以 $d=1$ 是必要条件，于是用 $2$ 代换上面的 $2d$。此时显然 $a,b$ 的具体值不重要，重要的是 $a\bmod 2,b\bmod 2$。分个类可以发现需要 $a\not\equiv b\pmod 2$。于是充要条件推出来是 $a\perp b,2\nmid a+b$。

于是要求
$$
ans=\sum_{i=1}^n\sum_{j=1}^n[i\perp j][2\nmid i+j]
$$
这个式子的值。莫反推推：
$$
\begin{aligned}ans&=\sum_{i=1}^n\sum_{j=1}^n[2\nmid i+j]\sum_{o\mid i,o\mid j}\mu(o)\\&=\sum_o\mu(o)[2\nmid o]2\!\left\lceil\dfrac{\left\lfloor\dfrac no\right\rfloor}2\right\rceil\!\left\lfloor\dfrac{\left\lfloor\dfrac no\right\rfloor}2\right\rfloor\end{aligned}
$$
整除分块，于是要求关键点处的 $f=\mu\times g$ 的前缀和（其中 $g(x)=x\bmod 2$）。幸运的是，$g$ 不仅是个积性函数，还是完全积性函数。于是 $f$ 就是个经典数论函数乘以完全积性函数，就套路地 $(\mu\times g)*g=\epsilon$ 一下就可以杜教筛了，$g$ 和 $\epsilon$ 的前缀和都随便算。

---

## 作者：zhou2414 (赞：1)

~~一道毒瘤题。~~
# 思路
发现只要棋子能到达点 $(1,0)$，那么就可以到达所有的点。

发现本质不同的移动方式只有 $(a,b)$、$(-a,b)$、$(b,a)$、$(-b,a)$ 四种，设其各进行了 $s_1,s_2,s_3,s_4$ 次（次数可以为负，意为向相反的方向执行该操作），那么对于合法的情况，一定满足：
$$
\begin{cases}
(s_1-s_2)a+(s_3-s_4)b=1\\
(s_3+s_4)a+(s_1+s_2)b=0
\end{cases}
$$

对于第一个式子，由**裴蜀定理的逆定理**可知其有解当且仅当 $\gcd(a,b)=1$。

观察两个式子，还可以发现 $a,b$ 一定**奇偶性不同**。原因是假设 $a,b$ 同为偶数，显然第一个式子不可能成立；如果同为奇数，那么为使第一个式子成立，$s_1\pm s_2$ 与 $s_3\pm s_4$ 一定奇偶性不同，但这样第二个式子就不成立了。

有了这两点，题目就被转换为了：
$$
\sum_{i=1}^{n}\sum_{j=1}^{n}[\gcd(i,j)=1\land (i,j\text{ 奇偶性不同})]
$$
规定 $i$ 为偶数，$j$ 为奇数，于是可转换为：
$$
2\sum_{i=1}^{n}\sum_{j=1}^{n}[\gcd(i,j)=1\land (i\text{ 为偶数},j\text{ 为奇数})]
$$
此时显然有 $\gcd(i,j)=\gcd(i/2,j)$，因为 $j$ 一定不含有因数 $2$。将所有被枚举的 $i$ 除以 $2$，可化为
$$
2\sum_{i=1}^{\lfloor \frac{n}{2} \rfloor}\sum_{j=1}^{n}[\gcd(i,j)=1\land (j\text{ 为奇数})]
$$
这样依然不够，考虑继续转化。

发现可以利用**容斥原理**转化，得到：
$$
2(\sum_{i=1}^{\lfloor \frac{n}{2} \rfloor}\sum_{j=1}^{n}[\gcd(i,j)=1]-\sum_{i=1}^{\lfloor \frac{n}{2} \rfloor}\sum_{j=1}^{n}[\gcd(i,j)=1\land (j\text{ 为偶数})])
$$
显然当 $i,j$ 同为偶数时不可能互质，所以可得：
$$
2(\sum_{i=1}^{\lfloor \frac{n}{2} \rfloor}\sum_{j=1}^{n}[\gcd(i,j)=1]-\sum_{i=1}^{\lfloor \frac{n}{2} \rfloor}\sum_{j=1}^{n}[\gcd(i,j)=1\land (j\text{ 为偶数,i\text{ 为奇数}})])
$$
发现后一项与初始时十分相似，调换 $i,j$ 可发现是一样的，于是设：
$$
f(n,m)=\sum_{i=1}^{n}\sum_{j=1}^{m}[\gcd(i,j)=1\land (i\text{ 为偶数},j\text{ 为奇数})]
$$
那么上式可以总结为：
$$
2\cdot f(n,n)=2(\sum_{i=1}^{\lfloor \frac{n}{2} \rfloor}\sum_{j=1}^{n}[\gcd(i,j)=1]-f(n,\lfloor \frac{n}{2} \rfloor))
$$
后一部分递归处理即可，接下来重点想前一坨要如何处理。

设：
$$
s(n,m)=\sum_{i=1}^{n}\sum_{j=1}^{m}[\gcd(i,j)=1]
$$
先进行~~套路式~~的转化：
$$
s(n,m)=\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{d\mid \gcd(i,j)}\mu(d)\\
=\sum_{d=1}^{\min(n,m)}\mu(d)\sum_{d\mid i}^{n}\sum_{d\mid j}^{m}1\\
=\sum_{d=1}^{\min(n,m)}\mu(d)\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}1\\
=\sum_{d=1}^{\min(n,m)}\mu(d)\lfloor\frac{n}{d}\rfloor\lfloor\frac{m}{d}\rfloor
$$
接下来我一一讲解每一步：（一眼就看懂的巨佬可以跳过）

1. 这一步是利用了莫比乌斯函数的性质 $\sum_{d\mid n}\mu(d)=[n=1]$，证明可以读者自行上网查询。
2. 这一步是改变求和顺序，从枚举 $i,j$ 的约数 $d$ 转变为了枚举 $d$ 的倍数 $i,j$，每个合法的 $i,j$ 会做一次贡献，所以求和后面为 $1$。
3. 这一步是转换，从枚举 $d$ 的倍数转换为枚举 $d$ 的倍数与 $d$ 的商，也就是 $d$ 关于某个倍数对应的另一个约数。
4. 显然。

然后发现可以做一个数论分块，对于每一个块内 $\mu(d)$ 的和可以用杜教筛处理。不会杜教筛的看[这里](https://www.luogu.com.cn/problem/P4213)。

复杂度~~不会算~~，但绝对是亚线性的。（~~废话~~）
# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ull unsigned long long
#define ll long long
#define ld long double
inline ull read() {
	ull x = 0, f = 1;
	char ch;
	while (((ch = getchar()) < 48 || ch > 57)&&ch!=EOF)if (ch == '-')f = -1;
	while (ch >= 48 && ch <= 57)x = x * 10 + ch - 48, ch = getchar();
	return x * f;
}
char __sta[1009], __len;
inline void write(ull x, bool bo) {
	if (x < 0)putchar('-'), x = -x;
	do __sta[++__len] = x % 10 + 48, x /= 10;
	while (x);
	while (__len)putchar(__sta[__len--]);
	putchar(bo ? '\n' : ' ');
}
const ull N=2e7+9,bas=2e7;
ull t,n;
ull mui[N],pri[N],pcnt;
bool num[N];
unordered_map<ull,ull>mu;
void init(){
	mui[1]=1;
	for(ull i=2;i<=bas;i++){
		if(!num[i])pri[++pcnt]=i,mui[i]=-1;
		for(ull j=1;j<=pcnt&&pri[j]*i<=bas;j++){
			num[pri[j]*i]=1;
			if(i%pri[j]==0){
				mui[pri[j]*i]=0;
				break;
			}
			mui[pri[j]*i]=-mui[i];
		}
	}
	for(ull i=2;i<=bas;i++)mui[i]+=mui[i-1];
}
ull mui_sum(ull n){
	if(n==0)return 0;
	if(n<=bas)return mui[n];
	if(mu[n])return mu[n];
	ull ans=0;
	for(ull i=2,j=2;i<=n;i=j+1){
		j=n/(n/i);
		ans+=mui_sum(n/i)*(j-i+1);
	}
	ans=1-ans;
	mu[n]=ans;
	return ans; 
}
ull s(ull n,ull m){
	ull ans=0;
	for(ull i=1,j=1;i<=min(n,m);i=j+1){
		j=min(n/(n/i),m/(m/i));
		ans+=(mui_sum(j)-mui_sum(i-1))*(n/i)*(m/i);
	}
	return ans;
}
ull f(ull n,ull m){
	if(n<=0||m<=0)return 0;
	return s(n/2,m)-f(m,n/2);
}
int main(){
	init();
	t=read();
	while(t--){
		n=read();
		write(2*f(n,n),1);
	}
	return 0;
}
```

---

借鉴了[这篇题解](https://www.luogu.com.cn/article/z721cxw7)的思路。

---

## 作者：TianTian2008 (赞：1)

打表找规律，发现一组 $(a,b)$ 合法当且仅当 $\gcd(a,b)=1\land a\not\equiv b\pmod2$。

$\begin{aligned}&\sum\limits_{a=1}^n\sum\limits_{b=1}^np(a,b)\\=&\sum\limits_{a=1}^n\sum\limits_{b=1}^n[\gcd(a,b)=1\land a\not\equiv b\pmod2]\\=&2\sum\limits_{i=0}^{\lfloor\frac{n-1}2\rfloor}\sum\limits_{j=1}^{\lfloor\frac n2\rfloor}[\gcd(2i+1,2j)=1]\\=&2\sum\limits_{i=0}^{\lfloor\frac{n-1}2\rfloor}\sum\limits_{j=1}^{\lfloor\frac n2\rfloor}\sum\limits_{d|\gcd(2i+1,2j)}\mu(d)\\=&2\sum\limits_{d=1}^n\mu(d)(\sum\limits_{i=0}^{\lfloor\frac{n-1}2\rfloor}[d|(2i+1)])(\sum\limits_{j=1}^{\lfloor\frac n2\rfloor}[d|(2j)])\end{aligned}$

我们需要对每个 $d$ 求出 $[1,n]$ 中有多少个它的奇倍数、偶倍数，由于贡献是两者个数的乘积，所以只有两者都不为零时才有意义，而偶数 $d$ 显然所有倍数都为偶数，因此可以忽略偶数 $d$。

对于一个奇数 $d$，其所有倍数可以表示为 $kd(1\le k\le\lfloor\frac nd\rfloor)$，显然若 $k$ 也为奇数则这是一个 $d$ 的奇倍数，若 $k$ 为偶数则这是一个偶倍数，因此两者个数分别为 $\lceil\frac{\lfloor\frac nd\rfloor}2\rceil,\lfloor\frac{\lfloor\frac nd\rfloor}2\rfloor$。

$\begin{aligned}=&2\sum\limits_{d=1}^n\mu(d)[2\nmid d]\lceil\frac{\lfloor\frac nd\rfloor}2\rceil\lfloor\frac{\lfloor\frac nd\rfloor}2\rfloor\\=&2(\sum\limits_{d=1}^n\mu(d)\lceil\frac{\lfloor\frac nd\rfloor}2\rceil\lfloor\frac{\lfloor\frac nd\rfloor}2\rfloor-\sum\limits_{d=1}^{\lfloor\frac n2\rfloor}\mu(2d)\lceil\frac{\lfloor\frac n{2d}\rfloor}2\rceil\lfloor\frac{\lfloor\frac n{2d}\rfloor}2\rfloor)\end{aligned}$

先考虑前一个和式怎么算，按 $\lfloor\frac nd\rfloor$ 数论分块，难点在于快速求一段区间的 $\mu$ 的和，杜教筛即可。

再考虑后一个和式，容易发现跟前一个和式的区别在于 $n\leftarrow\lfloor\frac n2\rfloor,\mu(d)\leftarrow\mu(2d)$，要是 $\mu$ 没有发生变化就是子问题了，所以我们考虑用 $\mu(d)$ 表示出 $\mu(2d)$，如果可以的话就成功递归成了子问题。

一个很无脑的想法是，因为 $2d$ 比 $d$ 多了一个质因子，所以 $\mu(2d)=-\mu(d)$。但如果 $d$ 本来就是偶数，那么就有 $\mu(2d)=0$。换句话说，我们可以先把所有 $\mu(2d)$ 当作 $-\mu(d)$，然后再减去 $d$ 为偶数的贡献。

发现没有？这样就又是同一个问题了，即所有的贡献减去偶数的贡献，我们成功递归成了子问题。

$\begin{aligned}f(n)=\begin{cases}\sum\limits_{d=1}^n\mu(d)\lceil\frac{\lfloor\frac nd\rfloor}2\rceil\lfloor\frac{\lfloor\frac nd\rfloor}2\rfloor+f(\lfloor\frac n2\rfloor)&n\ge1\\0&n=0\end{cases}\end{aligned}$

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#define lim 20000000
using namespace std;
typedef unsigned long long ull;
int pc,pr[lim+1],mu[lim+1];
bool isp[lim+1];
void init() {
	mu[1]=1;
	for(int i=2;i<=lim;++i) {
		if(!isp[i]) mu[pr[++pc]=i]=-1;
		for(int j=1;i*pr[j]<=lim;++j) {
			isp[i*pr[j]]=true;
			if(i%pr[j]==0) break;
			mu[i*pr[j]]=-mu[i];
		}
	}
	for(int i=2;i<=lim;++i) mu[i]+=mu[i-1];
}
ull N,tn[5001];
ull calc(ull n) {
	if(n<=lim) return mu[n];
	if(tn[N/n]) return tn[N/n];
	ull res=1,l=2,r;
	while(l<=n) {
		r=n/(n/l);
		res-=(r-l+1)*calc(n/l);
		l=r+1;
	}
	return tn[N/n]=res;
}
ull dfs(ull n) {
	if(!n) return n;
	ull res=0,l=1,r;
	while(l<=n) {
		r=n/(n/l);
		ull x=n/l,y=x>>1;
		res+=(calc(r)-calc(l-1))*y*(x-y);
		l=r+1;
	}
	return res+dfs(n>>1);
}
void work() {
	scanf("%llu",&N);
	memset(tn,0,sizeof(tn));
	printf("%llu\n",dfs(N)<<1);
}
int main() {
	init();
	int _;
	scanf("%d",&_);
	while(_--) work();
	return 0;
}
```

---

## 作者：ShiRoZeTsu (赞：1)

首先有这样一个事实：

- 假如存在走到 $(1, 0)$ 和 $(0, 1)$ 的方案，那么对于任意的点 $(X, Y)$，只需要将 $(1, 0)$ 的路径重复 $X$ 次，将 $(0, 1)$ 的路径重复 $Y$ 即可达到目标。

也就是说，存在走到 $(1, 0)$ 和 $(0, 1)$ 的路径实际上是 $P(a, b) = 1$ 所需要满足的**最小**条件。

而 $(1, 0)$ 和 $(0, 1)$ 的路径本质也相同，只需要将 $(1, 0)$ 路径的横、纵坐标调换即可得到 $(0, 1)$。

所以我们最终就是要求出，存不存在一种路径可以走到 $(1, 0)$。

其次，我们可以将一条路径分成两部分：前一部分由 $(X, Y)$ 变到 $(X+ax, Y+by)$，后一部分由 $(X, Y)$ 变到 $(X + bp, Y + aq)$。

这是因为地图没有限制，同样的一步，先走或者后走没有区别。


$$
 \ 
$$


然后试着将横纵坐标分开讨论：

- 对于纵坐标，我们需要找到一组 $x, y$，满足：
  $$
  ax + by = 0
  $$
  

  也就是说，纵坐标从 $0$ 出发，走了 $x$ 个 $a$ 步，$y$ 个 $b$ 步，最后纵坐标变为 $0$。不难看出，$|ax| = |by| = k \times {\rm lcm}(a, b)$。也就是说这两项的绝对值必须相同，且为 ${\rm lcm}(a, b)$ 的若干倍。此时有：
  $$
  \begin{aligned}
  x = k \times \frac{b}{\gcd(a, b)}\\
  y = - k \times \frac{a}{\gcd(a, b)}\\
  \end{aligned}
  $$
  似乎并没有起到什么限制，于是再看横坐标。

- 对于横坐标，我们需要找到一组 $p_1, q_1, p_2, q_2$，满足：
  $$
  (p_1 - q_1)a + (p_2 - q_2)b = 1
  $$
  且有：
  $$
  \begin{aligned}
  p_1 + q_1 = y\\
  p_2 + q_2 = x\\
  \end{aligned}
  $$
  从含义上来讲，就是横坐标走了 $p_1$ 个 $+a$，走了 $q_1$ 个 $-a$，走了 $p_2$ 个 $+b$，走了 $q_2$ 个 $-b$。

  无论这些 $p, q$ 如何，我们都能由**裴蜀定理**得知，这个方程有解的充要条件是 $\gcd(a, b) = \gcd((p_1 - q_1), (p_2 - q_2)) = 1$，这是我们得到的第一条限制。

  再来观察这些 $p, q$。由于有 $p_1 + q_1 = y$ 的限制，若 $p_1$ 增加 $1$，则 $q_1$ 一定会减少 $1$。所以能看出 $(p_1 - q_1)$ 奇偶性是固定的。至于具体是奇是偶，如果我们取 $q_1 = 0$，那么此时 $p_1 = y - q_1 = y$，也就是说 $(p_1 - q_1)$ 与 $y$ 奇偶性相同。

  同理，$(p_2 - q_2)$ 与 $x$ 奇偶性也相同。

  再者，$(p_1 - q_1)a$  和 $ (p_2 - q_2)b$ 这两项奇偶性一定不同，因为相同的话不可能减出来 $1$。
  $$
   \ 
  $$
  有了这些，我们回到纵坐标的那两个式子：
  $$
  \begin{aligned}
  x = k \times \frac{b}{\gcd(a, b)}\\
  y = - k \times \frac{a}{\gcd(a, b)}\\
  \end{aligned}
  $$
  由于 $\gcd(a, b) = 1$，所以：
  $$
  \begin{aligned}
  x = k \times b\\
  y = - k \times a\\
  \end{aligned}
  $$
  此时 $x, y$ 的奇偶性由 $a, b, k$ 来决定。不难发现，当 $k$ 取偶数时，$x, y$ 也为偶数，所以 $(p_1 - q_1)$ 和 $(p_2 - q_2)$ 也是偶数，那么此时 $(p_1 - q_1)a + (p_2 - q_2)b = 1$ 这个式子一定无解。因为两项都是偶数，一定减不出来 $1$。

  所以 $k$ 一定取奇数，也就是说对 $x, y$，对 $(p_1 - q_1), (p_2 - q_2)$ 的奇偶性没有任何影响。

  因此 $(p_1 - q_1)$ 的奇偶性与 $a$ 相同，$(p_2 - q_2)$ 的奇偶性与 $b$ 相同。因此，在保证 $(p_1 - q_1)a$  和 $ (p_2 - q_2)b$ 这两项奇偶性不同的条件下，我们得出结论：**$a, b$ 奇偶性一定不同**。

因此，对于 $a, b$，满足 $p(a, b) = 1$ 的条件是 $\gcd(a, b) = 1$ 且 $a, b$ 奇偶性不同。

$$
 \ 
$$

接下来考虑求解答案：

$$
\sum \limits_{a=1}^n \sum \limits_{b=1}^n p(a, b) = \sum \limits_{a=1}^n \sum \limits_{b=1}^n [\gcd(a, b) = 1 (a + b) \wedge \bmod 2 = 1]
$$

然后可以令 $b \leq a$：

$$
2 \sum \limits_{a=1}^n \sum \limits_{b=1}^a [\gcd(a, b) = 1 \wedge (a + b) \bmod 2 = 1]
$$

这时你会发现 $(a+b) \bmod 2 = 1$ 这个条件不好处理，所以考虑转化一下。如何转化呢？你会发现，若 $(a+b)$ 是奇数，那么 $(a-b)$ 也一定是奇数。同时，此时 $\gcd(a, a-b)$ 也等于 $1$。所以有：

$$
2 \sum \limits_{a=1}^n \sum \limits_{b=1}^a [\gcd(a, a-b) = 1 \wedge (a - b) \bmod 2 = 1]
$$

这样就可以枚举 $a-b$ 了：

$$
2 \sum \limits_{a=1}^n \sum \limits_{b=0}^{a-1} [\gcd(a, b) = 1 \wedge b \bmod 2 = 1]
$$

这时可以设 $f(x)$ 表示 **$\leq x$ 且与 $x$ 互质的奇数个数**，那么答案就是：

$$
2 \sum \limits_{i = 1}^n f(i) - 2
$$

（减 $2$ 是因为，$1$ 和 $1$ 互质，且 $1$ 为因数，要减去 $2f(1)$）

然后考虑怎么求 $f(i)$。

- 首先考虑 $i$ 是一个偶数，那么不难发现，所有 $\leq i$ 且与 $i$ 互质的数字，一定都没有 $2$ 这个质因子，也就是说**一定是奇数**，所以此时 $f(i) = \varphi(i)$。

- 然后考虑 $i$ 是一个奇数。还是设 $x$ 是 $\leq i$ 且与 $i$ 互质的一个奇数，也就是说 $\gcd(x, i) = 1$，那么显然有 $\gcd(i-x, i) = 1$。这里的 $i-x$ 一定是一个偶数，也就是不符合 $f$ 的条件。所以此时 $f(i) = \frac{\varphi(i)}{2}$

当然，$f(1)$ 需要特判。 


$$
 \ 
$$


继续化式子：
$$
\begin{aligned}
ans(n) = & 2 \sum \limits_{i = 1}^n f(i) - 2\\
= & 2 \left( \sum \limits_{i = 1}^n \varphi(i) [i \bmod 2 = 0] + \sum \limits_{i = 1}^n \frac{\varphi(i)}{2} [i \bmod 2 = 1] \right) - 2\\
= & 2 \sum \limits_{i = 1}^n \varphi(i) [i \bmod 2 = 0] + \sum \limits_{i = 1}^n \varphi(i) [i \bmod 2 = 1] - 2\\
= & \sum \limits_{i=1}^n \varphi(i) + \sum \limits_{i=1}^n \varphi(i) [i \bmod 2 = 0] - 2\\
\end{aligned}
$$
考虑一下 $\sum \limits_{i=1}^n \varphi(i) [i \bmod 2 = 0]$ 的意义，如果我们将 $n$ 变为 $\left\lfloor \frac{n}{2} \right\rfloor$，那么对于所有 $i = 2k$（其中 $k$ 是奇数），有 $\varphi(i) = \varphi(k)$（积性函数性质）；对于所有 $i = 2k$（其中 $k$ 是偶数），有 $\varphi(i) = 2\varphi(k)$（质因子不变，数字变为原来的两倍）。

所以有：

$$
\begin{aligned}
& \sum \limits_{i=1}^n \varphi(i) + \sum \limits_{i=1}^n \varphi(i) [i \bmod 2 = 0] - 2\\
= & \sum \limits_{i=1}^n \varphi(i) + \left( 2 \sum \limits_{i = 1}^{\left\lfloor \frac{n}{2} \right\rfloor} \varphi(i) [i \bmod 2 = 0] + \sum \limits_{i = 1}^{\left\lfloor \frac{n}{2} \right\rfloor} \varphi(i) [i \bmod 2 = 1] \right) - 2\\
= & \sum \limits_{i=1}^n \varphi(i) + ans \left( \left\lfloor \frac{n}{2} \right\rfloor \right)\\
\end{aligned}
$$

所以最终有：

$$
ans(n) = \sum \limits_{i=1}^n \varphi(i) + ans \left( \left\lfloor \frac{n}{2} \right\rfloor \right)
$$
$ans$ 的求解是 $\mathcal{O}(\log n)$ 的，而求 $\varphi$ 的前缀和可以杜教筛做到 $\mathcal{O}(n^{\frac{2}{3}})$，这里不多赘述。

总时间复杂度 $\mathcal{O}(n^{\frac{2}{3}} \log n)$。

Code:

```cpp
#include <iostream>
#include <cstdio>
#include <unordered_map>
using namespace std;
typedef unsigned long long ull;

const int maxn = 1e7 + 5;
const int maxk = 1e7;

int T, tot;
int prime[maxn>>1];
bool not_prime[maxn];
ull n, ans;
ull phi[maxn];
unordered_map<ull, ull> mp;

inline void prework() {
	phi[1] = 1;
	for(int i = 2; i <= maxk; i++) {
		if(!not_prime[i]) prime[++tot] = i, phi[i] = i-1;
		for(int j = 1; j <= tot && i*prime[j] <= maxk; j++) {
			not_prime[i*prime[j]] = true;
			if(i%prime[j] == 0) {
				phi[i*prime[j]] = phi[i] * prime[j];
				break;
			}
			phi[i*prime[j]] = phi[i] * phi[prime[j]];
		}
	}
	for(int i = 2; i <= maxk; i++) phi[i] += phi[i-1];
}

inline ull f(ull x) {
	if(x&1) return ((x+1) >> 1) * x;
	else return (x >> 1) * (x+1);
}

ull sum(ull x) {
	if(x <= maxk) return phi[x];
	if(mp[x]) return mp[x];
	ull res = f(x);
	for(ull l = 2, r; l <= x; l = r+1) {
		r = x/(x/l);
		res -= (r-l+1) * sum(x/l);
	}
	return mp[x] = res;
}

int main() {
	prework();
	scanf("%d", &T);
	while(T--) {
		scanf("%llu", &n); 
		ans = 0;
		while(n != 1) {
			ans += sum(n);
			n >>= 1;
		}
		printf("%llu\n", ans);
	}
	return 0;
}
```

---

## 作者：tzc_wk (赞：1)

[题面传送门](https://www.luogu.com.cn/problem/P6860)

首先我们来探究一下什么样的 $(a,b)$ 满足 $p(a,b)=1$。不难发现只要点 $(1,0)$ 能够到达，那么网格上所有点都能到达，因为由于 $(1,0)$ 能够到达，将坐标轴旋转一下 $(0,1)$ 也能到达，因此对于坐标系中任意一点 $(x,y)$，重复 $x$ 次 $(0,0)\to(1,0)$ 的过程，再重复 $y$ 次 $(0,0)\to(0,1)$ 的过程就能够到达 $(x,y)$。

其次，注意到本质不同的移动向量只有四个，即 $(a,b),(b,a),(-a,b),(-b,a)$，我们假设这四个向量分别移动了 $x,y,z,w$ 次（注意，这边 $x,y,z,w$ 不一定要 $\ge 0$，如果 $x<0$ 则表示沿着 $(-a,-b)$ 向量移动了 $-x$ 次，很好理解），那么能够到达 $(1,0)$ 的充要条件就是 $\exists x,y,z,w\in\mathbb{Z},\begin{cases}ax+by-az-bw=1\\bx+ay+bz+aw=0\end{cases}$，上下两式相加可得 $(a+b)(x+y)+(a-b)(w-z)=1$，上下两式相减可得 $(a-b)(x-y)-(a+b)(z+w)=1$，发现都可以转化为 $(a-b)x+(a+b)y=1$ 的方程，根据斐蜀定理知该方程存在整数解的充要条件为 $\text{gcd}(a-b,a+b)=1$，显然若 $\text{gcd}(a,b)>1$ 就无解了，并且如果 $a\equiv b\pmod{2}$ 也无解，因为 $a-b,a+b$ 都是 $2$ 的倍数。否则显然有 $\gcd(a,a+b)=1$，而由 $2\nmid a+b$ 可知 $\gcd(2a,a+b)=1$，再辗转相除一下可得 $\gcd(a-b,a+b)=1$，当然这只是说明了方程 $(a-b)x+(a+b)y=1$ 有解，不能保证一定存在符合要求 $x,y,z,w$，不过我们仔细想想，我们由于 $a\not\equiv b\pmod{2}$，必然有 $a+b\equiv a-b\equiv 1\pmod{2}$，因此我们构造出的解 $x_0,y_0$ 显然满足 $x_0\not\equiv y_0\pmod{2}$，而显然同余方程组还存在一组解 $(x_0-(a-b),y_0-(a+b))$，因此我们考虑令 $\begin{cases}x+y=y_0\\x-y=x_0-(a-b)\\w-z=x_0\\w+z=(a+b)-y_0\end{cases}$，那么显然 $y_0$ 与 $x_0-(a-b)$、$x_0$ 与 $(a+b)-y_0$ 都是同奇偶的，因此就存在符合要求的 $x,y,z,w$ 了，综上我们得出了结论 $p(a,b)=[\gcd(a,b)=1\land 2\nmid a+b]$。

接下来考虑计算答案，显然答案等于 $2\sum\limits_{a\text{为奇数}}\sum\limits_{b<a\text{且}b\text{为偶数}}[\gcd(a,b)=1]+2\sum\limits_{a\text{为偶数}}\sum\limits_{b<a\text{且}b\text{为奇数}}[\gcd(a,b)=1]$，考虑对于一个固定的 $a$ 的贡献，显然若 $a$ 为偶数，那么所有 $<a$ 且与 $a$ 互质的数都是奇数，贡献为 $\varphi(a)$，否则贡献就是所有 $<a$ 且与 $a$ 互质的偶数，显然对于所有与 $a$ 互质的偶数 $x$ 都有 $\gcd(a,a+x)=1$，而由 $a+x$ 为奇数可知 $\gcd(2a,a+x)=1$，并且所有 $<2a$ 且与 $2a$ 互质的数 $v$ 都有 $v-a$ 为偶数，因此 $x$ 的个数就是在 $[a,2a)$ 中且与 $2a$ 互质的数的个数，这个显然等于 $\dfrac{\varphi(2a)}{2}$，而显然 $\varphi(2a)=\varphi(a)$，故这个值就等于 $\dfrac{\varphi(a)}{2}$，因此我们要求的值就是 $[1,n]$ 中所有奇数的 $\varphi$ 值与所有偶数 $\varphi$ 值的两倍的和，我们考虑先求 $[1,n]$ 中所有 $\varphi(i)$ 的和，这样会少算一遍偶数的 $\varphi(i)$ 的贡献，考虑这个漏算贡献怎么计算，注意到对于 $[1,n]$ 中的某个偶数 $x$，若 $\dfrac{x}{2}$ 为奇数则 $\varphi(x)=\varphi(\dfrac{x}{2})$，否则 $\varphi(x)=2\varphi(\dfrac{x}{2})$，因此漏算的贡献恰好又是 $[1,\dfrac{n}{2}]$ 中所有奇数的 $\varphi$ 值与所有偶数 $\varphi$ 值的两倍的和，递归计算即可。

最后，此题数据范围高达 $10^{11}$，因此需用杜教筛求出 $\varphi(x)$ 的前缀和，这个知识点大约是我半年前学的了罢，现在已经几乎忘掉了，所以感谢这道题让我回忆起了遗忘的知识点。根据狄利克雷卷积有 $\varphi*I=id$，考虑 $id(x)$ 的前缀和 $\sum\limits_{i=1}^nid(i)$，我们将每个 $id(i)$ 都写成关于 $\varphi(x)$ 的求和式，即 $\sum\limits_{i=1}^nid(i)=\sum\limits_{i=1}^n\sum\limits_{j|i}\varphi(j)$，交换求和号，先枚举 $j$ 可得 $\sum\limits_{i=1}^nid(i)=\sum\limits_{j=1}^n\sum\limits_{i=1}^{\lfloor\frac{n}{j}\rfloor}\varphi(i)$，将 $j=1$ 单独提出来可得 $\sum\limits_{i=1}^nid(i)=\sum\limits_{i=1}^n\varphi(i)+\sum\limits_{j=2}^n\sum\limits_{i=1}^{\lfloor\frac{n}{j}\rfloor}\varphi(i)$，记 $\varphi_s(n)=\sum\limits_{i=1}^n\varphi(i)$，那么 $\sum\limits_{i=1}^nid(i)=\varphi_s(n)+\sum\limits_{j=2}^n\varphi_s(\lfloor\dfrac{n}{j}\rfloor)$，前面 $\sum\limits_{i=1}^nid(i)$ 显然等于 $\dfrac{n(n+1)}{2}$，后面 $\sum\limits_{j=2}^n\varphi_s(\lfloor\dfrac{n}{j}\rfloor)$ 整除分块递归处理即可，根据 P6788 这样整除分块套整除分块复杂度是 $n^{3/4}$ 的，不过预处理 $[1,n^{2/3}]$ 的 $\varphi_s(n)$ 可将复杂度降到 $n^{2/3}$。

最后此题有一个坑点，就是在求 $id(n)$ 的前缀和 $\dfrac{n(n+1)}{2}$ 不能直接写 `1ull*n*(n+1)/2`，因为对于 $[0,2^{64})$ 的整数 $v$，在 $[0,2^{64})$ 中存在两个整数 $x$ 满足 $2x\equiv v\pmod{2^{64}}$，而你这样直接除就默认是 $<2^{63}$ 的那个 $x$ 了，会出问题，正确写法是分 $n$ 为奇数和偶数分别处理，先除再乘（NOIP2020 悲惨回忆），这样就不会出问题了。

```cpp
const int MAXV=2e7;
int phi[MAXV+5],pr[MAXV/10+5],prcnt=0;
u64 sum[MAXV+5];bitset<MAXV+5> vis;
void sieve(int n){
	phi[1]=1;
	for(int i=2;i<=n;i++){
		if(!vis[i]){pr[++prcnt]=i;phi[i]=i-1;}
		for(int j=1;j<=prcnt&&pr[j]*i<=n;j++){
			vis[pr[j]*i]=1;
			if(i%pr[j]==0){phi[i*pr[j]]=phi[i]*pr[j];break;}
			else phi[i*pr[j]]=phi[i]*phi[pr[j]];
		}
	}
	for(int i=1;i<=n;i++) sum[i]=sum[i-1]+phi[i];
}
unordered_map<ll,u64> mem;
u64 getsum(ll n){
	if(n<=MAXV) return sum[n];
	if(mem[n]) return mem[n];
	u64 ret;
	if(n%2) ret=1ull*(n+1)/2*n;
	else ret=1ull*n/2*(n+1);
	for(ll l=2,r;l<=n;l=r+1){
		r=(n/(n/l));ret-=1ull*getsum(n/l)*(r-l+1);
	} return mem[n]=ret;
}
u64 solve(ll n){
	if(n==1) return 0;
	return solve(n/2)+getsum(n);
}
int main(){
	sieve(MAXV);int qu;scanf("%d",&qu);
	while(qu--){ll n;scanf("%lld",&n);printf("%llu\n",solve(n));}
	return 0;
}
```



---

## 作者：Leasier (赞：1)

1. $20 \operatorname{pts}$ 做法

首先，$p(i, j) = 1$ 的必要条件是：$(x, y)$ 能位移到 $(x + 1, y)$ 或 $(x, y + 1)$，即存在整数 $a, b$，使 $ai + bj = 1$ 且 $aj + bi = 0$，即：$i$ 和 $j$ 的奇偶性不同，且 $\gcd(i, j) = 1$。

∴原式 $= \displaystyle\sum_{i = 1}^n \sum_{j = 1}^n [i \not \equiv j \pmod 2\ \operatorname{and}\ \gcd(i, j) = 1]$

暴力计算即可。时间复杂度为 $O(Tn^2 \log n)$。

代码：
```cpp
#include <stdio.h>

typedef long long ll;
typedef unsigned long long ull;

ll gcd(ll a, ll b){
	return b == 0 ? a : gcd(b, a % b);
}

int main(){
	int t;
	scanf("%d", &t);
	for (register int i = 1; i <= t; i++){
		ll n;
		ull ans = 0;
		scanf("%lld", &n);
		for (register ll j = 1; j <= n; j++){
			for (register ll k = 1; k <= n; k++){
				if (j % 2 != k % 2 && gcd(j, k) == 1) ans++;
			}
		}
		printf("%llu\n", ans);
	}
	return 0;
}
```
2. $50 \operatorname{pts}$ 做法

我们先继续化简原式。

原式 $= 2 \displaystyle\sum_{i = 1}^n \sum_{j = 1}^i [i \not \equiv j \pmod 2\ \operatorname{and}\ \gcd(i, j) = 1]$

$ = 2 \times (\displaystyle\sum_{i \equiv 0 \pmod 2}^n \sum_{j \equiv 1 \pmod 2}^i [\gcd(i, j) = 1] + \sum_{i \equiv 1 \pmod 2}^n \sum_{j \equiv 0 \pmod 2}^i [\gcd(i, j) = 1])$

考虑简化 $j$ 的枚举。

显然，当 $i$ 为偶数时，$j$ 的贡献为 $\varphi(i)$；当 $i$ 为奇数时，$j$ 的贡献是 $\leq i$ 且与 $i$ 互质的偶数的个数，即 $\frac{\varphi(2i)}{2}$。

∴原式 $ = 2 \times (\displaystyle\sum_{i \equiv 0 \pmod 2}^n \varphi(i) + \sum_{i \equiv 1 \pmod 2}^n \frac{\varphi(2i)}{2})$

线性筛欧拉函数，然后暴力计算即可。时间复杂度为 $Tn \sqrt{n}$。

代码：
```cpp
#include <stdio.h>

typedef long long ll;
typedef unsigned long long ull;

const int N = 2e7 + 7, M = 1e7;
int prime[N], phi[N];
ll sum[N];
bool p[N];

inline void init(){
	int cnt = 0;
	p[0] = p[1] = true;
	phi[1] = 1;
	for (register int i = 2; i < N; i++){
		if (!p[i]){
			prime[++cnt] = i;
			phi[i] = i - 1;
		}
		for (register int j = 1; j <= cnt && i * prime[j] < N; j++){
			int t = i * prime[j];
			p[t] = true;
			if (i % prime[j] == 0){
				phi[t] = phi[i] * prime[j];
				break;
			}
			phi[t] = phi[i] * (prime[j] - 1);
		}
	}
	for (register int i = 1; i <= M; i++){
		if (i % 2 == 0){
			sum[i] = sum[i - 1] + phi[i];
		} else {
			sum[i] = sum[i - 1] + phi[i * 2] / 2;
		}
	}
}

inline int min(int a, int b){
	return a < b ? a : b;
}

inline ll euler(ll n){
	if (n < N) return phi[n];
	ll ans = n;
	for (register ll i = 2; i * i <= n; i++){
		if (n % i == 0){
			ans -= ans / i;
			while (n % i == 0){
				n /= i;
			}
		}
	}
	if (n > 1) ans -= ans / n;
	return ans;
}

int main(){
	int t;
	scanf("%d", &t);
	init();
	for (register int i = 1; i <= t; i++){
		ll n;
		ull ans;
		scanf("%lld", &n);
		ans = sum[min(n, M)];
		for (register ll j = M + 1; j <= n; j++){
			if (j % 2 == 0){
				ans += euler(j);
			} else {
				ans += euler(j * 2) / 2;
			}
		}
		printf("%llu\n", ans * 2);
	}
	return 0;
}
```
3. $100 \operatorname{pts}$ 做法

前置芝士：[杜教筛](https://oi-wiki.org/math/du/)

由欧拉函数的性质可得：当 $i$ 为奇数时，$\varphi(2i) = \varphi(i)$；当 $i$ 为偶数时，$\varphi(2i) = 2 \varphi(i)$。

令 $\operatorname{solve}(n)$ 表示原式的值，则：

$\operatorname{solve}(n) = \displaystyle\sum_{i = 1}^n ([i \equiv 0 \pmod 2] 2 \varphi(i) + [i \equiv 1 \pmod 2] \varphi(i))$

$ = \displaystyle\sum_{i = 1}^n (\varphi(i) + [i \equiv 0 \pmod 2] \varphi(i))$

考虑直接计算欧拉函数前缀和未算到的偶数的欧拉函数的部分，可得：

原式 $= \displaystyle\sum_{i = 1}^n \varphi(i) + \operatorname{solve}(\frac{n}{2})$

用杜教筛优化求欧拉函数前缀和即可。时间复杂度为 $O(Tn^{\frac{2}{3}} \log n)$。

代码：
```cpp
#include <iostream>
#include <map>

using namespace std;

typedef long long ll;
typedef unsigned long long ull;
typedef __int128 lll;

const int N = 2e7 + 7;
int prime[N], phi[N];
ll sum[N];
bool p[N];
map<ll, ull> mp;

inline void init(){
	int cnt = 0;
	p[0] = p[1] = true;
	phi[1] = 1;
	for (register int i = 2; i < N; i++){
		if (!p[i]){
			prime[++cnt] = i;
			phi[i] = i - 1;
		}
		for (register int j = 1; j <= cnt && i * prime[j] < N; j++){
			int t = i * prime[j];
			p[t] = true;
			if (i % prime[j] == 0){
				phi[t] = phi[i] * prime[j];
				break;
			}
			phi[t] = phi[i] * (prime[j] - 1);
		}
	}
	for (register int i = 1; i < N; i++){
		sum[i] = sum[i - 1] + phi[i];
	}
}

inline ull get_euler_sum(ll n){
	if (n < N) return sum[n];
	if (mp.count(n)) return mp[n];
	ull ans = (lll)n * (n + 1) / 2;
	for (register ll i = 2, j; i <= n; i = j + 1){
		ll tn = n / i;
		j = n / tn;
		ans -= get_euler_sum(tn) * (j - i + 1);
	}
	return mp[n] = ans;
}

ull solve(ll n){
	if (n <= 1) return 0; // 递归函数终止条件
	return solve(n / 2) + get_euler_sum(n);
}

int main(){
	int t;
	cin >> t;
	init();
	for (register int i = 1; i <= t; i++){
		ll n;
		cin >> n;
		cout << solve(n) << endl;
	}
	return 0;
}
```

---

## 作者：Unnamed114514 (赞：0)

先来考虑 $p(a,b)$ 的性质。

首先能到达整个棋盘等价于能到达 $(0,1)$，那么我们设 $4$ 种移动状态（$(+a,+b),(+a,-b),(-a,+b),(-a,-b)$）次数分别为 $a_1,a_2,a_3,a_4$，那么有：

$$\begin{cases}a(a_1+a_2-(a_3+a_4))=0\\b(a_1+a_3-(a_2+a_4))=1\end{cases}$$

这个系数似乎观察不出什么规律，我们令 $x=a_1-a_4,y=a_2-a_3$，然后拆括号，化简有：

$$\begin{cases}a(x+y)=0\\b(x-y)=1\end{cases}$$

两边相加知：

$a(x+y)+b(x-y)=1$。

那么等价于 $ax+by=1$ 这个方程有**奇偶性相同的解**，那么首先就有 $\gcd(a,b)=1$。如何体现奇偶性呢，首先注意到 $x,y$ 显然不会同时为偶数，因此它们都是奇数，我们令 $x=2X+1,y=2Y+1$，那么有：$(2X+1)a+(2Y+1)b=2(Xa+Yb)+(a+b)=1$。这样就很清晰了，因为第一坨是偶数，所以第二坨一定是奇数。

那么问题就等价于 $f(n,n)=\sum\limits_{a=1}^n\sum\limits_{b=1}^n[\gcd(a,b)=1\land 2\nmid(a+b)]$。不妨假设 $a$ 为偶数，那么 $b$ 就是奇数，最终答案 $\div 2$ 即可，注意到 $\gcd(2n,2m+1)=\gcd(n,2m+1)$，那么有 $f(n,n)=\sum\limits_{a=1}^{\lfloor\frac{n}{2}\rfloor}\sum\limits_{b=1}^n[\gcd(a,b)\land 2\nmid b]$

首先有个非常简单的容斥：

$f(n,n)=\sum\limits_{a=1}^{\lfloor\frac{n}{2}\rfloor}\sum\limits_{b=1}^m[\gcd(a,b)=1]-\sum\limits_{a=1}^{\lfloor\frac{n}{2}\rfloor}\sum\limits_{b=1}^m[\gcd(a,b)=1\land 2\mid b]$

因为 $b$ 是偶数所以 $a$ 显然不是偶数，那么我们继续，令 $s(n,m)=\sum\limits_{a=1}^{n}\sum\limits_{b=1}^m[\gcd(a,b)=1]$，有：

$f(n,m)=s(\lfloor\dfrac{n}{2}\rfloor,m)-\sum\limits_{a=1}^{\lfloor\frac{n}{2}\rfloor}\sum\limits_{b=1}^m[\gcd(a,b)=1\land 2\nmid a\land 2\mid b]$

你会发现后边这一坨其实就是等价于 $f$ 的一个子问题，那么有：$f(n,m)=s(\lfloor\dfrac{n}{2}\rfloor,m)-f(m,\lfloor\dfrac{n}{2}\rfloor)$。

现在还剩下 $s$ 的求解，套用莫反知：

$$s(n,m)=\sum\limits_{i=1}^{n}\sum\limits_{j=1}^m[\gcd(i,j)=1]\\=\sum\limits_{i=1}^{n}\sum\limits_{j=1}^m\sum\limits_{d\mid \gcd(a,b)}\mu(d)$$

考虑枚举 $\gcd$，有：

$$s(n,m)=\sum\limits_{d=1}^{\min\{n,m\}}\mu(d)\lfloor\dfrac{n}{d}\rfloor\lfloor\dfrac{m}{d}\rfloor$$

整除分块即可，对于 $\mu(d)$ 的前缀和可以用杜教筛求解，具体的时间复杂度其实就是一个多次查询的杜教筛，应该是 $O(n^{\frac{2}{3}})$ 的。

```cpp
#include<bits/stdc++.h>
#define int unsigned long long
#define endl '\n'
using namespace std;
const int N=1e7+5,INF=1e7;
int T,n,prime[N],cnt,Smu[N];
bool flg[N];
unordered_map<int,int> mp_mu;
void Euler(int n){
	Smu[1]=1,flg[1]=1;
	for(int i=2;i<=n;++i){
		if(!flg[i]){
			Smu[i]=-1;
			prime[++cnt]=i;
		}
		for(int j=1;j<=cnt&&i*prime[j]<=n;++j){
			flg[i*prime[j]]=1;
			if(i%prime[j]==0){
				Smu[i*prime[j]]=0;
				break;
			}
			Smu[i*prime[j]]=-Smu[i];
		}
	}
	for(int i=2;i<=n;++i) Smu[i]+=Smu[i-1];
}
int Sum_mu(int n){
	if(n<=INF) return Smu[n];
	if(mp_mu.count(n)) return mp_mu[n];
	int ans=1;
	for(int l=2,r;l<=n;l=r+1){
		r=n/(n/l);
		ans-=(r-l+1)*Sum_mu(n/l);
	}
	return mp_mu[n]=ans;
}
int s(int n,int m){
	int ans=0;
	for(int l=1,r;l<=min(n,m);l=r+1){
		r=min(n/(n/l),m/(m/l));
		ans+=(Sum_mu(r)-Sum_mu(l-1))*(n/l)*(m/l);
	}
	return ans;
}
int f(int n,int m){
	if(n==1) return 0;
	if(m==1) return n/2;
	return s(n/2,m)-f(m,n/2);
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	Euler(INF);
	cin>>T;
	while(T--){
		cin>>n;
		cout<<f(n,n)*2<<endl;
	}
	return 0;
}
```

---

## 作者：QQ82272760 (赞：0)

先看看这个 $p$ 什么时候为 $1$

如果 $a+b$ 是偶数，那么只能走到横纵坐标之和奇偶性相同的一些格子，而不能走满整个棋盘，所以 $a+b$ 一定要是奇数

如果不互质的话能走到的格子横纵坐标之和一定对某个大于 $1$ 的数同余，所以 $a$ 和 $b$ 一定互质

我们用数学归纳法证明当 $a+b$ 为奇数 $a\bot b$ 时一定可行。不妨令 $a$ 为奇数，$b$ 为偶数

1. $a=1,b=0$，显然可以
2. $a\ge 2b$，
$(0,0)\to(a,-b)\to(0,-2b)\to(b,a-2b)$，
也就是说 $p(a,b)=p(a-2b,b)=1$
3. $b\ge 2a$，同理
4. $2b>a>b$，
$(0,0)\to(a,b)\to(0,2b)\to(b,2b-a)$，
这时候 $2b-a<2a-a=a,p(a,b)=p(2b-a,b)=1$
5. $2b>a>b$，同理

所以答案为
$$
2\sum_{i=1}^n\sum_{j=1}^n[\gcd(i,j)=1][i\bmod 2=1][j\bmod 2=0]
$$

根据莫反的套路，上式等于

$$
\begin{aligned}
&2\sum_{d=1}^n\mu(d)\sum_{d|i}[i\bmod 2=1]\sum_{d|j}[j\bmod 2=0]\\
=&2\sum_{d=1}^n[d\bmod 2=1]\mu(d)\left\lceil\frac {\left\lfloor\frac nd\right\rfloor}{2}\right\rceil\left\lfloor\frac {\left\lfloor\frac nd\right\rfloor}{2}\right\rfloor
\end{aligned}
$$

现在要做的就是快速求出 $f(n)=[n\bmod2=1]\mu(n)$的前缀和，这样每组询问就是根号

我们发现 $o(n)=[n\bmod 2=1]$ 是一个积性函数，所以
$$
f*o=(\mu\cdot o)*o=(\mu\cdot o)*(I\cdot o)=(\mu*I)\cdot o=e
$$

显然 $o(n)$ 的前缀和是好求的，于是 $f(n)$ 的前缀和就可以杜教筛啦

总复杂度 $\mathcal O\left(n^\frac 23+T\sqrt n\right)$

~~话说为什么我推出来的式子总是和大佬们的不一样~~

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define ll unsigned long long
using namespace std;
const int B=21544350,M=4645;
int tot,prm[B+5]; bool vi[B+5];
ll mu[B+5],sf1[B+5],sf2[M+5];
void init(int n){
	mu[1]=1;
	for(int i=2;i<=n;i+=1){
		if(!vi[i]) prm[++tot]=i,mu[i]=-1;
		for(int j=1;j<=tot&&prm[j]<=n/i;j+=1){
			vi[i*prm[j]]=1;
			if(i%prm[j]==0) break;
			mu[i*prm[j]]=-mu[i];
		}
	}
	for(int i=1;i<=n;i+=1){
		sf1[i]=sf1[i-1]+(i&1)*mu[i];
	}
	return;
}
ll S(ll n){
	return n+1>>1;
}
ll Sf(ll n,ll N){
	if(n<=B) return sf1[n];
	if(sf2[N/n]) return sf2[N/n];
	ll ans=1;
	for(ll i=2,j;i<=n;i=j+1){
		j=n/(n/i);
		ans-=(S(j)-S(i-1))*Sf(n/i,N);
	}
	return sf2[N/n]=ans;
}
ll s(ll n){
	return (n>>1)*(n+1>>1);
}
ll solve(ll n){
	ll ans=0;
	memset(sf2,0,sizeof(sf2));
	for(ll i=1,j;i<=n;i=j+1){
		j=n/(n/i);
		ans+=(Sf(j,n)-Sf(i-1,n))*s(n/i);
	}
	return ans*2;
}
int main(){
	int t; ll n;
	scanf("%d",&t); init(B);
	while(t--){
		scanf("%llu",&n);
		printf("%llu\n",solve(n));
	}
	return 0;
}
```
Thanks~

---


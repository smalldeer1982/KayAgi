# 「PMOI-4」可怜的团主

## 题目描述

lnlhm 被塞给了一张 $n$ 个点 $m$ 条边的**简单无向连通**图。很快，他就被 ducati 和 b6e0 盯上了。

ducati 希望能够从中找到**恰好** $\left \lceil \frac n 6 \right \rceil$ 条**不同**的路径，使得所有的点都被至少一条路径经过。

b6e0 希望找到一个大小**恰好**为 $\lfloor \frac n 3 \rfloor$ 的节点集合，使得它们之间**两两没有边**。

lnlhm 知道，如果他没有满足某个人的要求，那么他就会被揍。因此，他向你求助：是否存在一种选择边或点的方案，使得**最多被一个人揍**？

## 说明/提示

【样例解释】

对于第一组样例，我们只需要为 b6e0 选出节点集合 $\{1,4\}$ 即可。注意，$\{1,5\}\{1,6\}\{2,4\}\{2,6\}\{3,4\}\{3,5\}\{3,6\}$ 同样合法。

对于第二组样例，我们只需要为 ducati 选出路径 $1 \to 2 \to 3 \to 4 \to 5 \to 6$ 即可。

【数据范围】

**本题采用捆绑测试**。

- Subtask 1（20pts）：$n,m\le10$。
- Subtask 2（20pts）：保证图为一棵树。
- Subtask 3（60pts）：无特殊限制。

对于 $100\%$ 的数据满足，$3\le n\le10^3$，$3\le m\le\dfrac{n(n-1)}2$，保证给定的图为简单无向连通图。

**温馨提示: 输入量较大，请使用较快的读入方式。**

## 样例 #1

### 输入

```
6 7
1 2
1 3
2 3
2 5
4 5
5 6
4 6```

### 输出

```
2
1 4```

## 样例 #2

### 输入

```
6 6
1 2
2 3
3 4
4 5
5 6
1 6```

### 输出

```
1
6 1 2 3 4 5 6```

# 题解

## 作者：TonyYin (赞：10)

## 题意

给定一个 $n$ 个点，$m$ 条边的简单连通无向图，问：是否能实现以下两个操作中的一个：

1. 找到**恰好 $\lceil\frac{n}{6}\rceil$​​​ 条不同的**路径，​使每个点都至少被一条路径经过。（**每条路径上**，每个点至多经过一次）
2. 找到**恰好 $\lfloor\frac{n}{3}\rfloor$​​​​ 个**点，使其中**两两没有边**。

若能实现操作1，输出每条路径；若能实现操作2，输出满足条件的这些点。

对于 $100\%$ 的数据，$3\leq n\leq 10^3$，$3\leq m\leq \dfrac{n(n-1)}{2}$.

## $\rm{Subtask}$​ $1$​

对于 $20\%$ 的数据，$n, m\leq 10$.

暴力搜索即可。期望得分 20 分。

```cpp
for(int sta = 0; sta < (1 << n); sta++) {
    int cnt = 0; bool wrong = false;
    for(int i = 1; i <= n; i++) {
        if(sta & (1 << (i - 1))) cnt++;
    }
    if(cnt != n / 3) continue;
    for(int i = 1; i <= n; i++) if(sta & (1 << (i - 1))) {
        for(int j = 1; j <= n; j++) if(sta & (1 << (j - 1))) {
            if(i == j) continue;
            if(mapp[i][j]) {wrong = true; break;}
        }
        if(wrong) break;
    }
    if(!wrong) {
        cout << 2 << endl;
        for(int i = 1; i <= n; i++) {
            if(sta & (1 << (i - 1))) cout << i << " ";
        } cout << endl;
        return 0;
    }
}
```

## $\rm{Subtask}$ $2$

对于另外 $20\%$​ 的数据，图是一棵树。

#### 算法一

将树上的点按深度奇偶性分类，然后选择这两类中较大的那一个作为独立集。

显然这个独立集大小大于 $n/2$，满足要求。

很好写，就不给代码了。

#### 算法二

考虑满足操作二的构造方法，这更接近正解。

任意找一个点为根，找出所有 $x$ 个叶子。

如果 $x\leq \lfloor\frac{n}{3}\rfloor$​，那么满足操作一。

否则，构造出一些以这些叶子为两端的路径，使得这些路径覆盖到图上所有的点。

可以证明，这样的路径一定存在，并且最小覆盖数是 $\lceil\frac{x}{2}\rceil$. 下面给出可行的构造方法，即可证明。

#### 构造方案

首先，将叶子任意两两配对。若 $x$ 为奇数，那么加一个点编号为 $n+1$，直接连在根节点 $1$ 下面。

显然配对不一定能覆盖所有的点，所以考虑进行若干次调整。

对于每次调整，我们**找到一个没有被覆盖的点 $p$，之后找 $p$ 的任意两个子树，从这两个子树中分别找到任意两个叶子**，记为 $(u, v)$，$(u', v')$.

直接把这两条路径变换一下配对顺序，变为 $(u, v')$ 和 $(v, u')$​. 这样一定可以使 $p$ 被覆盖到，至少多覆盖了一个点。

由于每次操作，都会多覆盖 $\geq 1$ 个点，所以最多进行 $n$ 次，时间复杂度为 $\mathcal{O}(n^2)$，可以接受。

可以证明操作四个点一定能找到，操作一定可行。

```cpp
for(int i = 1; i <= n; i++) if(!covered[i]) {
    int son_cnt = 0, leaf1, leaf2, leaf3, leaf4;
    for(int j = head[i]; j; j = edge[j].nxt) {
        int v = edge[j].to;
        son_cnt++;
        if(son_cnt == 1) {
            leaf1 = Get_leaf(v);
            leaf2 = Pair[leaf1];
        } else if(son_cnt == 2) {
            leaf3 = Get_leaf(v);
            leaf4 = Pair[leaf3];
            break;
        }
    }
    Make_pair(leaf1, leaf3); Make_pair(leaf2, leaf4);
}
```

#### 操作一定可行的证明

对于一个没有被覆盖的点 $p$，其每个子树内叶子个数一定 $\geq 2$，下面给出证明。

由于没有被覆盖，所以子树内的每条路径，都仅在儿子的子树内，如下图：

![例 - 图.jpeg](https://cdn.tonyyin.top/2021/08/24/7b095d67e8e61.jpeg)

$\rm{y}$ 存在一棵子树仅有一个叶子。红色节点相关的路径，必定会覆盖到 $\rm{y}$.

$\rm{x}$ 是一种不被覆盖的可行情况。

## $\rm{Subtask}$ $3$​

容易想到，在无向图中找一棵生成树，尝试继续使用上面的方法进行构造。

注意到，$\rm{Subtask}$ $2$ 中，利用了树的重要性质：叶子之间没有边。

因此，我们在原图上找到DFS树。这样能满足叶子节点之间，在原图上没有边。

使用 $\rm{Subtask}$ $2$ 的算法二解决即可。

## $\rm{Code}$

代码没有给出头文件和 `read()` 函数。

`dfs1(int)`，`dfs2(int, int)`，`get_lca(int, int)` 实现了树剖LCA。

由于本题时间复杂度为 $\mathcal{O}(n^2)$，可以不用这种方法求 LCA，暴力找 LCA 也可以通过。

代码细节较多）

```cpp
using namespace std;
const int MAXN = 1e3 + 10, MAXM = 2e6 + 10;

int n, m, extra;
vector<int> mp[MAXN];
struct Edge{
	int from, to, nxt;
} edge[MAXM];
int head[MAXN], e_cnt = 0;
void add_edge(int u, int v) {
	edge[++e_cnt] = (Edge){u, v, head[u]};
	head[u] = e_cnt;
}
int vis[MAXN], dep[MAXN], fa[MAXN], deg[MAXN];
void Get_DFS_Tree(int u, int father) {
	vis[u] = true;
	dep[u] = dep[father] + 1; fa[u] = father;
	for(int i = 0; i < mp[u].size(); i++) {
		int v = mp[u][i]; if(vis[v]) continue;
		Get_DFS_Tree(v, u);
		deg[u]++; deg[v]++;
		add_edge(u, v); add_edge(v, u);
	}
}
int siz[MAXN], son[MAXN], dfn[MAXN], top[MAXN], tot;
void dfs1(int u) {
	siz[u] = 1;
	for(int i = head[u]; i; i = edge[i].nxt) {
		int v = edge[i].to; if(v == fa[u]) continue;
		dfs1(v);
		if(!son[u] || siz[v] > siz[son[u]]) son[u] = v;
		siz[u] += siz[v];
	}
}
void dfs2(int u, int topf) {
	top[u] = topf; dfn[u] = ++tot;
	if(!son[u]) return;
	dfs2(son[u], topf);
	for(int i = head[u]; i; i = edge[i].nxt) {
		int v = edge[i].to; if(v == fa[u] || v == son[u]) continue;
		dfs2(v, v);
	}
}
int get_lca(int u, int v) {
	while(top[u] != top[v]) {
		if(dep[top[u]] < dep[top[v]]) swap(u, v);
		u = fa[top[u]];
	}
	if(dep[u] < dep[v]) swap(u, v);
	return v;
}
int leaf[MAXN], leaf_cnt;
int Pair[MAXN], covered[MAXN];
void Cover(int x, int y) {
	if(x == y) {covered[x] = 1; return;}
	do{
		covered[x] = covered[y] = 1;
		if(dep[x] > dep[y]) x = fa[x];
		else y = fa[y];
	} while(x != y);
}
void Make_pair(int x, int y) {
	Pair[x] = y; Pair[y] = x;
	Cover(x, y);
}
int Get_leaf(int u) {
	while(deg[u] != 1) {
		for(int i = head[u]; i; i = edge[i].nxt) {
			int v = edge[i].to; if(v != fa[u]) {u = v; break;}
		}
	}
	return u;
}
void print_path(int u, int v) {
	if(u == extra) u = fa[u];
	if(v == extra) v = fa[v];
	int lca = get_lca(u, v);
	vector<int> p1, p2;
	int x = u; while(x != lca) {p1.push_back(x); x = fa[x];}
	x = v; while(x != lca) {p2.push_back(x); x = fa[x];}
	printf("%d ", p1.size() + p2.size() + 1);
	for(int i = 0; i < p1.size(); i++) printf("%d ", p1[i]);
	printf("%d ", lca);
	for(int i = p2.size() - 1; i >= 0; i--) printf("%d ", p2[i]);
	putchar('\n');
}
int main() {
	srand(time(0));
	n = read(); m = read();
	int rest = (n + 5) / 6;
	for(int i = 1; i <= m; i++) {
		int u = read(), v = read();
		mp[u].push_back(v); mp[v].push_back(u);
	}
	Get_DFS_Tree(1, 0);
	dfs1(1); dfs2(1, 1);
	for(int i = 2; i <= n; i++) if(deg[i] == 1) leaf[++leaf_cnt] = i;
	if(leaf_cnt >= n / 3) {
		putchar('2'); putchar('\n');
		for(int i = 1; i <= n / 3; i++) printf("%d ", leaf[i]);
		return 0;
	}
	if(deg[1] == 1) leaf[++leaf_cnt] = 1;
	if(leaf_cnt & 1) {
		n++; fa[n] = 1; deg[n] = 1; leaf[++leaf_cnt] = n;
		extra = n;
		add_edge(1, n); add_edge(n, 1);
	}
	for(int i = 2; i <= leaf_cnt - 1; i += 2) Make_pair(leaf[i], leaf[i + 1]);
	Make_pair(leaf[1], leaf[leaf_cnt]);
	for(int i = 1; i <= n; i++) if(!covered[i]) {
		int son_cnt = 0, leaf1, leaf2, leaf3, leaf4;
		for(int j = head[i]; j; j = edge[j].nxt) {
			int v = edge[j].to;
			son_cnt++;
			if(son_cnt == 1) {
				leaf1 = Get_leaf(v);
				leaf2 = Pair[leaf1];
			} else if(son_cnt == 2) {
				leaf3 = Get_leaf(v);
				leaf4 = Pair[leaf3];
				break;
			}
		}
		Make_pair(leaf1, leaf3); Make_pair(leaf2, leaf4);
	}
	putchar('1'); putchar('\n');
	for(int i = 1; i <= leaf_cnt; i++) {
		int u = leaf[i], v = Pair[leaf[i]];
		if(u > v) continue; //保证每条路径只被输出一次
		print_path(u, v); rest--;
	}
	for(int i = 1; i <= rest; i++) {
		print_path(rand() % n + 1, i);//这个我也不清楚咋解决
	}
	return 0;
}
```

---

## 作者：CmsMartin (赞：7)

# Subtask 1

对于 20% 的数据 $n , m \leq 10$

直接搜索即可，没有太多的细节

期望得分：$20$

# Subtask 2

数据保证为一棵树

这时，我们只需将叶子节点随机配对。随机配对并不能够保证覆盖所有的点，这时就需要我们进行调整

对于每次调整，我们只需要找到一个未被覆盖的点作为 root（细节：该点不为叶子节点且至少有两个子树，否则它一开始就能被覆盖到）

任意取它的两个子树，并从中分别挑选两条路径 $(u,v)$ $(u^,,v^,)$ 将其调整成 $(u,v^,)$ $(v,u^,)$ 。

画图可知，这时 $root$ 一定被覆盖到，故可知在不超过 $n$ 步内可以完成调整

结合算法 $1$ ，期望得分：$40$

# Subtask 3

从 Subtask2 扩展到一般情况

我们找出图中的 dfs 树（不存在横插边），然后再结合算法2即可

期望得分：$100$


感谢 **ducati** 老师教会了我
## 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 1010;

inline int read() { //速读 
	int f = 1 , ret = 0;
	char c = getchar();
	while(c < '0' || c > '9') {
		if(c == '-') f = -1;
		c = getchar();
	}
	while(c <= '9' && c >= '0') {
		ret = (ret << 3) + (ret << 1) + c - 48;
		c = getchar();
	}
	return ret * f;
}

int cnt , Head[MAXN];

struct Edge {
	int Next , To;
}Edge[MAXN << 1]; 

void Add(int u , int v) {
	cnt++;
	Edge[cnt].To = v;
	Edge[cnt].Next = Head[u];
	Head[u] = cnt;
} //前向星存图 (20 ~ 31)

vector<int> G[MAXN] , res;

bool Vis[MAXN] , Covered[MAXN] , book[MAXN];
int Leaf[MAXN] , Deg[MAXN]; //存叶节点和每个点的度
int N , M , Len , Rest , Extra; 
int Pair[MAXN];
//Pair[i] = j表示把（i ， j）配成一对
//配对是互相的 

void Get_Dfs_Tree(int now) { //找dfs树 
	Vis[now] = true; //标记
	for(int i = 0;i < G[now].size();i++) { //vector存图 
		int v = G[now][i];
		if(!Vis[v]) {
			Get_Dfs_Tree(v);//以v为root的子树递归求解
			Deg[now]++;
			Deg[v]++; //更新两点的度
			Add(now , v);
			Add(v , now); //加入前向星 
		}
	} 
}

bool Dfs(int now , int dv , int father , int flag) {
	if(now == dv) {
		Covered[now] = true;
		if(flag == true && now != Extra) res.push_back(now);
		return true;
	}
	bool Val = false;
	for(int u = Head[now] ; u ; u = Edge[u].Next) {
		int v = Edge[u].To;
		if(v == father) continue;
		if(Dfs(v , dv , now , flag)) {
			Val = true;
			Covered[now] |= 1;
		}
	}
	if(flag == 1 && Val == 1 && now != Extra) res.push_back(now);//特判now ！= Extra 
	return Val;
}

int Get_Leaf(int now , int father) {
	if(Deg[now] == 1) return now; // 度为一的点——叶子 
	for(int u  = Head[now] ; u ; u = Edge[u].Next) {
		int v = Edge[u].To;
		if(v != father) return Get_Leaf(v , now); //递归子树 
	}
}

void Make_Pair(int u , int v) {
	Pair[u] = v;
	Pair[v] = u;
	//配对是互相的 
	Dfs(u , v, 0 , 0);
} 

void print(int u,int v){
	res.clear();
	Dfs(u , v , 0 , 1);
	Rest--;
	printf("%d ",res.size());
	for (int i = 0 ; i < res.size() ; i++){
		printf("%d ",res[i]);
	}
	puts("");
}

int main() {
	N = read();
	M = read();
	Rest = (N + 5) / 6;
	for(int i = 1;i <= M;i++) {
		int u = read();
		int v = read();
		G[u].push_back(v);
		G[v].push_back(u); //vector存图 
	}
	Get_Dfs_Tree(1); //将1作为根 
	for(int i = 2;i <= N;i++) { //细节：从i : 2 -> N ，因为1是根，可能存在1->叶子的边 
		if(Deg[i] == 1)
			Leaf[++Len] = i; //叶子节点集合 
	}
	if(Len >= N / 3) { //处理 b6e0 
		puts("2");
		for(int i = 1;i <= N / 3;i++) {
			cout << Leaf[i] << " ";
		}
		return 0;
	}
	if(Deg[1] == 1) Leaf[++Len] = 1;  //单独处理root 
	if(Len % 2 == 1) { // 若Len为奇数，那么我们连一条从 1 到 n+1 的边，增加一个叶节点，输出时特判 
		Add(1 , ++N);
		Deg[N] = 1;
		Leaf[++Len] = N;
		Extra = N; //特判时使用 
	}
	for(int i = 1;i <= Len;i += 2) { //为了方便，写124行 
		Make_Pair(Leaf[i] , Leaf[i + 1]); //配对 
	}
	while(true) {
		int now , Cnt_Son = 0 , u1 , v1 , u2 , v2 , done = 1;
		for(int i = 1;i <= N;i++) {
			if(!Covered[i]) {
				now = i;
				done = false;
				break;
			}
		}
		if(done) break;
		for(int i = Head[now] ; i ; i = Edge[i].Next) {
			int j = Edge[i].To;
			Cnt_Son++;
			if(Cnt_Son == 1) {
				u1 = Get_Leaf(j , now);
				v1 = Pair[u1]; 
			}
			else if(Cnt_Son == 2) {
				u2 = Get_Leaf(j , now);
				v2 = Pair[u2]; 
			}
			else break;
		}
		Make_Pair(u1 , v2);
		Make_Pair(v1 , u2);
	} 
	puts("1");
	for(int i = 1;i <= Len;i++) {
		int u = Leaf[i];
		int v = Pair[Leaf[i]];
		if(u < v) print(u , v);
	}
	for(int i = 1;i <= Rest;i++)
		cout << 1 << " " << i << endl; 
	return 0;
} 
```


---

## 作者：ez_lcw (赞：6)

我们考虑如下一种方式构造：

首先找一棵原图的 dfs 生成树，然后设叶子数量为 $t$，显然叶子之间不会有连边。

显然若 $t\geq \lfloor\frac{n}{3}\rfloor$，我们直接在这 $t$ 个叶子中随便选取 $\lfloor\frac{n}{3}\rfloor$ 个为独立集即可。

否则若 $t<\lfloor\frac{n}{3}\rfloor$，我们考虑这 $t$ 个叶子两两配对连成路径，并覆盖所有的点。

有题解给的是调整法，这里直接给出简单直观的构造法：

我们把这些叶子按顺序编号为 $1,2,\cdots,t$，然后按如下方式将它们两两配对连成路径：$(1,\lfloor\frac{t}{2}\rfloor+1),(2,\lfloor\frac{t}{2}\rfloor+2),\cdots,(\lceil\frac{t}{2}\rceil,t)$，共 $\lceil\frac{t}{2}\rceil$ 组。直观地来说就是把叶子分为左右两组，两组叶子之间按序配对。

证明比较简单，具体来说可以使用反证法，即证明某个点不被任何一条路径经过的情况不存在。

注意到 $\lceil\frac{t}{2}\rceil<\left\lceil\dfrac{\lfloor\frac{n}{3}\rfloor}{2}\right\rceil$，那么 $\lceil\frac{t}{2}\rceil\leq \lceil\frac{n}{6}\rceil$，符合题意。

注意特判根也为叶子的情况。

---

## 作者：DengDuck (赞：4)

构造神仙题！

无向图的最大独立集和最小路径覆盖都不太可做，所以要转化一下问题。

独立集，我们能想到啥？二分图？树？

路径覆盖，我们能想到啥？二分图？树？

二分图思考一会儿之后不会做，于是我们可以思考树。

## 独立集

把无向图变成树必然是 DFS 遍历一遍建树，那么我们遍历 $x$ 的时候，$x$ 的子树会包含 $x$ 能够到达的所有节点，所以两点没有祖先关系才能保证两点没有边。

由此可以推导出，对于我们的一棵生成树，能得到的最大独立集就是所有的叶子。

那么如果叶子数量 $x\geq \dfrac n 3$，那么我们直接操作二秒了。

## 路径覆盖

我们只需要满足 $\lceil \dfrac n 6 \rceil$ 个路径即可。

根据数学直觉，这玩意应该就是 $\lfloor \dfrac n 3 \rfloor$ 除一个二的样子，所以应该每条路径的端点都是两个叶子节点。

> 这里有个小问题：如果根节点只有一个儿子，那叶子咋覆盖都没用啊！
>
> 所以我们在这种情况下把节点一当叶子，然后就解决了问题。

这个怎么构造？考虑我们要避免子树内的叶子互相匹配，都希望匹配远一点的，所以我们让叶子前一半匹配后一半即可。

比如有 $m$ 项，那就是点 $i$ 匹配 $\lfloor \dfrac m 2 \rfloor+i$，证明可以考虑手玩。

注意路径不够的时候可以乱扔一些形如 $i\to i$ 的路径占位置。


```cpp
#include<bits/stdc++.h>
#define pb push_back
using namespace std;
const int N=1005;
vector<int>E[N],V;
int n,m,Fa[N],D[N],Flg,Vis[N],Lf[N];
void Dfs(int u,int f)
{
	int Cnt=0;
	Vis[u]=1,Fa[u]=f,D[u]=D[f]+1;
	for(int v:E[u])
	{
		if(Vis[v])continue;
		Cnt++;
		Dfs(v,u);
	}
	if(Cnt==0)V.pb(u),Lf[u]=1;
	if(u==1&&Cnt==1)Flg=1;
}
inline void Pt(int x,int y)
{
	vector<int>L,R;
	while(x!=y)
	{
		if(D[x]>D[y])L.pb(x),x=Fa[x];
		else R.pb(y),y=Fa[y];
	}
	reverse(R.begin(),R.end());
	printf("%d ",(int)(L.size()+R.size())+1);
	for(int i:L)printf("%d ",i);
	printf("%d ",x);
	for(int i:R)printf("%d ",i);	
	puts("");
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1,u,v;i<=m;i++)
	{
		scanf("%d%d",&u,&v);
		E[u].pb(v),E[v].pb(u);
	}
	Dfs(1,0);
	if(V.size()>=n/3)
	{
		puts("2");
		for(int i=0;i<n/3;i++)printf("%d ",V[i]);
	}
	else
	{
		puts("1");
		if(Flg)V.pb(1),Lf[1]=1;
		int m=V.size(),Cnt=(n+5)/6;
		for(int i=0;i+m/2<m&&Cnt;i++)Pt(V[i],V[i+m/2]),Cnt--;
		for(int i=1;i<=n&&Cnt;i++)if(!Lf[i])Pt(i,i),Cnt--;
	}
}
```

---

## 作者：Mihari (赞：1)

>*原文见[这里](https://www.cnblogs.com/Arextre/p/15168461.html)*

找出原树的 $\rm dfs$ 树，显然叶子之间不存在横叉变，那么叶子构成独立集，判断该独立集大小是否大于等于 $\udiv{n}{3}$，如果是，那么显然找到答案了，如果否，将叶子按照 $\rm dfs$ 序排序，并**在最后放入一个根**，假设叶子有 $m$ 个，那么现在我们得到一个大小 $m+1$ 的集合，如果 $2\nmid (m+1)$ 不能整除，则再放入一个根；

设我们最终得到集合大小为 $M(2\mid M)$，对于这个集合，将第 $i$ 个元素与 $i+\frac{M}{2}$ 个元素匹配构成一条树上路径，这样显然可以将所有节点覆盖到，证明如下：

>对于叶子在每个点的分布情况进行讨论：
>
>- 当叶子全部分布在这个点的某个叶子的时候，这个点势必会被某个叶子与根的路径覆盖，所以该方案，无论根是不是叶子，加入一个根节点是必要的；
>- 当叶子分布在至少两个儿子中时，由于是 $i$ 与 $i+mid$ 匹配，那么不论叶子是如何分布，这种匹配方式一定会存在某它子树中的个叶子和它的匹配节点连成的路径跨出该叶子所在子树，这时该节点亦被覆盖；
>
>类似地，可以用这种方法说明除此构造方案以外，其他的方案都有反例（在某些情况下一些错误的构造方案或许可以使用 $\tt random\_shuffle()$ 卡过去？）

由于构造输出是 $\mathcal O(n^2)$ 的，故复杂度就是 $\mathcal O(n^2)$ 的咯......

然鹅并没有代码QAQ

---


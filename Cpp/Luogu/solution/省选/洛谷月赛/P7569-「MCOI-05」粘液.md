# 「MCOI-05」粘液

## 题目背景

2077 年 7 月 7 日，MineCraft 20.7.7 发布了。这次更新允许了玩家将红石电路刻进一块电路板中进行运算。

`namespace_std` 作为一只程序猿兼 MC 玩家，他想在新的版本用电路板建造一台简易的粘液块盾构机。

然而，`namespace_std` 由于太久没玩 MC 了，建错了 TNT 复制装置，被炸上了外太空。所以搭建这个粘液块盾构机的任务就交给书虫了。

书虫用他附有耐久 X 的肝写出了这个盾构机的程序。然而，事情并没有这么简单 ...

## 题目描述

书虫有一个 $1 \times 1$ 体积的盾构机，和一块 $n \times m$ 个格子的地块，书虫打算用盾构机将这块地块推平。形式化地说，书虫需要让这个盾构机经过每一个格子 **恰好一次**。

这看上去很简单。然而，这个盾构机的程序的实现却有一些故障。当盾构机向同一个方向 **连续** 移动 **达到** $k$ 步时，盾构机就会卡住并不断地向同一个地方投放 TNT。

注意：最开始摆放盾构机**不视为移动**。换言之，盾构机应当移动 $n \times m - 1$ 次。

书虫并不想像可怜的 `namespace_std` 一样被炸上天，因此书虫希望找到一种安排盾构机路线的方案，使得盾构机 **不会** 被卡住。

## 说明/提示

#### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 0（1 pts）：样例，您可以通过提交结果得知您的答案是否通过了 `Special Judge`。
- Subtask 1（9 pts）：$n,m,k \leq 3$。
- Subtask 2（15 pts）：$n,m,k \leq 10$。
- Subtask 3（5 pts）：$k \geq n$。
- Subtask 4（15 pts）：$n \leq 5$。
- Subtask 5（20 pts）：$k \geq 5$。
- Subtask 6（10 pts）：保证存在合法解。
- Subtask 7（25 pts）：无特殊限制。

对于 $100\%$ 的数据，$1 \le n,m,k \le 2000$。

## 样例 #1

### 输入

```
3 3 2
```

### 输出

```
NO
```

## 样例 #2

### 输入

```
3 3 3
```

### 输出

```
YES
RDLDRRUU
1 1```

## 样例 #3

### 输入

```
6 4 4
```

### 输出

```
YES
RRRDLLLDRRRDLLLDRRRDLLL
1 1
```

## 样例 #4

### 输入

```
1 1 2000```

### 输出

```
YES

1 1```

# 题解

## 作者：zjjws (赞：19)

[题链](https://www.luogu.com.cn/problem/P7569)

非常妙的分讨构造题。

---

### Solution 1

$n=1\ |\ m=1$

此时只能一路冲到底，判一下与另一个的大小关系即可。

---

### Solution 2

$k\ge n\ |\ k\ge m$

我们就可以对短的那一维，每次冲到底，然后换下一行/列。

---

```cpp
inline void work_1()
{
    if(n==1){if(k<m){puts("NO");return;}puts("YES");for(int i=1;i<m;i++)putchar('R');puts("");puts("1 1");return;}
    puts("YES");for(int i=1;i<=m;i++){for(int j=1;j<n;j++)putchar((i&1)?'D':'U');if(i!=m)putchar('R');}puts("");
    printf("%d %d\n",1,1);return;
}
inline void work_2()
{
    if(m==1){puts("NO");return;}
    puts("YES");for(int i=1;i<=n;i++){for(int j=1;j<m;j++)putchar((i&1)?'R':'L');if(i!=n)putchar('D');}puts("");
    printf("%d %d\n",1,1);return;
    return;
}
```

这前两个 Solution 判完后，显然 $k\le 2$ 无解。

可以自己手玩一下。

---

### Solution 3

$k\ge 5$

此时有一种构造，就是直接每次消 $2/3$ 行/列，其中前面的 $2,3$ 取决于另一维的奇偶性。

具体的，拿消列举例，是这样的两个图形：

行为奇数时：

![](https://cdn.luogu.com.cn/upload/image_hosting/yocevona.png)

行为偶数时：

![](https://cdn.luogu.com.cn/upload/image_hosting/v5xsqhk6.png)


会注意到这样之后会变成一个规模更小的子问题。

递归的边界条件是 $m=2|3$，此时按照前面两个 Solution 的跑法即可。


但是涉及到每次切换子问题会有一个 **前面积攒** 的连续走的步数，当 $k\ge 5$ 时，最坏的情况也是能接受的。

大家可以手玩一下。


---


这里涉及到子问题，会注意到如果写一堆 if 语句来判断当前出发点是在矩阵的哪个角落会非常地屎。

我是在跑的时候默认出发点在左上角，但是存储一下当前的**反转状态**，然后在输出的时候转化一下就好。

```cpp

struct gyq
{
    char c[4];
    // 0 1 2 3
    // 上下左右
    inline void init(){c[0]='U';c[1]='D';c[2]='L';c[3]='R';return;}
    inline void change(int typ)
    {
        if(typ==1||typ==3)jh(c[2],c[3]);
        if(typ==2||typ==3)jh(c[0],c[1]);
        return;
        //typ 0 1 2 3 分别对应左上，右上，左下，右下
    }
}tp[4];

inline void work_stp(int n,int m,int typ)
{
    if(n<=3){for(int i=1;i<=m;i++){for(int j=1;j<n;j++)putchar(tp[typ].c[i&1]);if(i!=m)putchar(tp[typ].c[3]);}return;}
    if(m<=3){for(int i=1;i<=n;i++){for(int j=1;j<m;j++)putchar(tp[typ].c[2+(i&1)]);if(i!=n)putchar(tp[typ].c[1]);}return;}
    if(n&1)
    {
        for(int i=1;i<=n;i++){for(int j=1;j<2;j++)putchar(tp[typ].c[2+(i&1)]);if(i!=n)putchar(tp[typ].c[1]);}
        putchar(tp[typ].c[3]);
        int nxt;if(typ==0)nxt=2;if(typ==1)nxt=3;if(typ==2)nxt=0;if(typ==3)nxt=1;work_stp(n,m-2,nxt);
        return;
    }
    if(m&1)
    {
        for(int i=1;i<=m;i++){for(int j=1;j<2;j++)putchar(tp[typ].c[i&1]);if(i!=m)putchar(tp[typ].c[3]);}
        putchar(tp[typ].c[1]);
        int nxt;if(typ==0)nxt=1;if(typ==1)nxt=0;if(typ==2)nxt=3;if(typ==3)nxt=2;work_stp(n-2,m,nxt);
    }
    return;
}
```

这里是暴力跑奇的，如果初始 $n,m$ 都为偶，就跑一遍前面说的那种就可以调用这个函数了。

---

### Solution 4


$n,m$ 都为偶数。

并没有这个 subtask 但是这个部分非常关键。

因为会发现我们的瓶颈在于：递归到最后的边界时，前面转化子问题时积攒的步数会和边界时暴力冲到底的步数相加。

最坏的情况，就是前面跑了一个 **行为奇数** 的子问题转化，积攒了两步到达当前子问题，然后列还剩 $3$，只能暴力跑，相加得到的最大连续步数为 $4$。

此时 $k\ge 5$ 才能有解。


但是如果行列都是偶数时，我们存在一种更优秀的构造：

![](https://cdn.luogu.com.cn/upload/image_hosting/rfo2wobf.png)

这样每次消去两行两列。

为什么要这两种都画呢？因为它们都有用。当 $n\ge m$ 时，我们会调用第一种跑法，这样最后暴力跑的时候就不会有步数的相加。第二种跑法对应另一种 Case。


这样可以达到 $k\ge 3$ 时都有解。

$k\le 2$ 时无解已经判过了。

---

```cpp
inline void work_zjj(int n,int m,int typ)
{
    if(m==2){for(int i=1;i<=n;i++){for(int j=1;j<m;j++)putchar(tp[typ].c[2+(i&1)]);if(i!=n)putchar(tp[typ].c[1]);}return;}
    for(int i=1;i<=n-2;i++){for(int j=1;j<2;j++)putchar(tp[typ].c[2+(i&1)]);if(i!=n)putchar(tp[typ].c[1]);}
    putchar(tp[typ].c[1]);putchar(tp[typ].c[3]);putchar(tp[typ].c[0]);putchar(tp[typ].c[3]);
    for(int i=3;i<=m;i++){for(int j=1;j<2;j++)putchar(tp[typ].c[i&1]);if(i!=m)putchar(tp[typ].c[3]);}
    putchar(tp[typ].c[0]);int nxt=3-typ;work_zjj(n-2,m-2,nxt);
    return;
}
inline void work_gyq(int n,int m,int typ)
{
    if(n==2){for(int i=1;i<=m;i++){for(int j=1;j<n;j++)putchar(tp[typ].c[i&1]);if(i!=m)putchar(tp[typ].c[3]);}return;}
    for(int i=1;i<=m-2;i++){for(int j=1;j<2;j++)putchar(tp[typ].c[i&1]);if(i!=m)putchar(tp[typ].c[3]);}
    putchar(tp[typ].c[3]);putchar(tp[typ].c[1]);putchar(tp[typ].c[2]);putchar(tp[typ].c[1]);
    for(int i=3;i<=n;i++){for(int j=1;j<2;j++)putchar(tp[typ].c[2+(i&1)]);if(i!=n)putchar(tp[typ].c[1]);}
    putchar(tp[typ].c[2]);int nxt=3-typ;work_gyq(n-2,m-2,nxt);
    return;
}
```
---

### Solution 5

$n,m$ 无限制。

会注意到：我们只要能够转移到 $n,m$ 都为偶数的子问题，就可以轻松地解决此题了。

回想到前面 Solution 3 中消 3 行/列 的操作，它可以改变另一维的奇偶性。

那么对于 $n,m$ 只有一个奇数的情况，我们就可以跑一遍这个得到双偶的 Case。

如果都是奇数呢？

我们可以出发点选择 $(3,1)$，然后跑一遍：

![](https://cdn.luogu.com.cn/upload/image_hosting/ax0shmh3.png)

这样就可以把 $m$ 变成偶数，然后再跑一遍 Solution 3 中的方法把 $n$ 也变成偶数。

于是本题就**轻松**做完了（

---


```cpp

inline void work_6()
{
    puts("YES");
    if(m&1)
    {
        if(n&1)
        {
            for(int i=1;i<=n-2;i++){for(int j=1;j<3;j++)putchar(tp[0].c[3-(i&1)]);if(i!=n)putchar(tp[0].c[1]);}
            for(int i=1;i<=3;i++){for(int j=1;j<2;j++)putchar(tp[0].c[i&1]);putchar(tp[0].c[3]);}
            m-=3;
            for(int i=1;i<=m-2;i++){for(int j=1;j<3;j++)putchar(tp[2].c[i&1]);if(i!=m)putchar(tp[2].c[3]);}
            for(int i=1;i<=3;i++){for(int j=1;j<2;j++)putchar(tp[2].c[2+(i&1)]);putchar(tp[2].c[1]);}
            n-=3;{if(n>=m)work_zjj(n,m,3);else work_gyq(n,m,3);}
            puts("");puts("1 3");
        }
        else 
        {
            for(int i=1;i<=n-2;i++){for(int j=1;j<3;j++)putchar(tp[0].c[2+(i&1)]);if(i!=n)putchar(tp[0].c[1]);}
            for(int i=1;i<=3;i++){for(int j=1;j<2;j++)putchar(tp[0].c[i&1]);putchar(tp[0].c[3]);}
            m-=3;
            if(n>=m)work_zjj(n,m,2);else work_gyq(n,m,2);
            puts("");puts("1 1");
        }
        return;
    }
    if(n&1)
    {
        for(int i=1;i<=m-2;i++){for(int j=1;j<3;j++)putchar(tp[0].c[i&1]);if(i!=m)putchar(tp[0].c[3]);}
        for(int i=1;i<=3;i++){for(int j=1;j<2;j++)putchar(tp[0].c[2+(i&1)]);putchar(tp[0].c[1]);}
        n-=3;if(n>=m)work_zjj(n,m,1);else work_gyq(n,m,1);puts("");puts("1 1");return;
    }
    else {if(n>=m)work_zjj(n,m,0);else work_gyq(n,m,0);}puts("");puts("1 1");return;
    return;
}
```

---

## 作者：int08 (赞：4)

## 前言
首紫，按照惯例，来篇题解。

~~话说做出这道题的其他人都是身经百战的大佬，就我一个人把这题当做首紫吗？~~

看了看做对的人数，这题挺难的，建议升黑。~~这样我就有首黑题了。~~

# Solution
## 1、特判
1、$\min(n,m)=1$。这个时候只能从头到尾按一个方向走，$k>m-1$ 时有解。

2、$\min(n,m)=2$。这个时候只能蛇形走位，$k>1$ 时有解。

如图：

| ↓ | → | ↓ | → | …… | 
| -----------: | -----------: | -----------: | -----------: | -----------: |
| → | ↑ | → | ↑ |  |

3、$\min(n,m)=3$。这个时候同样只能蛇形走位，$k>2$ 时有解。此处与上一项同理。

## 2、非特判

按照这种构造题的套路，我们能够知道，这种题肯定不会去做搜索。肯定是在 $n$、$m$、$k$ 满足什么条件的时候固定有解。

根据我们绝不小心求证，只管大胆胡说的原则，我们猜 $k≥3$ 时有解。

同时我们又知道有这么一种经典的绕路方式：

| ↓ | → | ↓ | → | ↓ |
| -----------: | -----------: | -----------: | -----------: | -----------: |
| → | ↑ | → | ↑ | ↓ |
| ↓ | ← | ↓ | ← | ↓ |
| ↓ | ↑ | ← | ↑ | ↓ |

此时 $k≥4$。但是这种绕路的首尾段其实是很不合理的，我们可以把它改成 $k≥3$。而如果都采用这种方式或者它的类似，**那么分类讨论就只跟 $n$ 和 $m$ 的奇偶有关。**

### 1、$n$ 和 $m$ 一奇一偶

这个是最简单的情况，先默认把行调成偶数列调成奇数，然后再对上方的绕路法每两行的首尾稍稍修改即可在 $k≥3$ 之内完成。具体完成方法如图：

| ↓ | ← | → | → | ↓ |
| -----------: | -----------: | -----------: | -----------: | -----------: |
| → | → | ↑ | ↓ | ← |
| ↓ | ← | ← | → | ↓ |
| → | ↓ | ↑ | ← | ← |

注意起始点是 $(2,1)$，如果之前交换过 $n$ 和 $m$ 的话，起始点是 $(1,2)$。

### 2、$n$ 和 $m$ 都是偶数

我们发现在这种情况下没有特别简单的绕路了，但是可以用一种绕法，每次消掉两行两列。最后必然剩下两行和许多列，再进行蛇形走位即可。

这样仍然可以在 $k≥3$ 之内完成。

消去两行两列的方法如图：

| ↓ | → | ↓ | → | → | ↓ |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| → | ↑ | → | ↑ | ↓ | ← |
|  |  |  |  | → | ↓ |
|  |  |  |  | ↓ | ← |
|  |  |  |  | → | ↓ |
|  |  |  | … | ← | ← |

### 3、$n$ 和 $m$ 都是奇数

与第二种情况非常相似，用类似的方法可以消去两行两列，最后剩下三行多列，仍然可以在 $k≥3$ 之内完成。

消去两行两列的方法如图（与上面的略有不同）：

| ↓ | → | ↓ | → | ↓ |
| :----------- | :----------- | :----------- | :----------- | :----------- |
| → | ↑ | → | ↑ | ↓ |
|  |  |  | ↓ | ← |
|  |  |  | → | ↓ |
|  |  | … | ← | ← |

**综上所述，在非特判的情况下，在 $k≥3$ 时可以解决。**

## 3、一点小建议

这样的蛇形走位方式理解起来很容易，而输出却很难。

我所采用的方式是定义一个三维数组 $o$，来表示在是否交换过 $n$ 和 $m$，是否旋转过（第二次消两行两列时有旋转的情况）时，各个方向真实对应的是哪个方向。

同时定义一大堆数组，来模拟不同蛇形走位对应的方向，这样或许比较方便输出。各位如果有更好的方法也可以使用自己的。

## 4、AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,sw,i,j,l,two[4]={2,1,0,1},tw[4]={2,3,0,3},dt[4]={3,2,1,2},three[6]={2,2,1,0,0,1};char o[2][2][4]={{{'U','R','D','L'},{'D','L','U','R'}},{{'L','D','R','U'},{'R','U','L','D'}}};
//two，tw，three，dt表示不同的蛇形走路绕路方法。
int main()
{
	cin>>n>>m>>k;
	if(n>m)
	{
		swap(n,m);
		sw=(sw+1)%2;
	}
	if(n==1)
	{
		if(k<m) cout<<"NO";
		else
		{
			cout<<"YES"<<endl;
			for(i=1;i<m;i++) putchar(o[sw][0][1]);
			cout<<endl<<"1 1";	
		}
		return 0;
	}
	if(n==2)
	{
		if(k<2) cout<<"NO";
		else
		{
			cout<<"YES"<<endl;
			for(i=0;i<2*m-1;i++) putchar(o[sw][0][two[i%4]]);
			cout<<endl<<"1 1";
		}
		return 0;
	}
	if(n==3)
	{
		if(k<3) cout<<"NO";
		else
		{
			cout<<"YES"<<endl;
			for(i=0;i<3*m-1;i++) putchar(o[sw][0][three[i%6]]);
			cout<<endl<<"1 1";
		}
		return 0;
	}
	if(k<3)
	{
		cout<<"NO";
		return 0;
	}
	else cout<<"YES\n";
	if(m%2==0&&n%2)
	{
		swap(n,m);
		sw=(sw+1)%2;
	}
	if(n%2==0&&m%2)
	{
		for(i=1;i<=n/2;i++)
		{
			if(i%2)
			{
				putchar(o[sw][0][3]);putchar(o[sw][0][2]);putchar(o[sw][0][1]);putchar(o[sw][0][1]);putchar(o[sw][0][0]);putchar(o[sw][0][1]);
				for(j=0;j<2*(m-5);j++) putchar(o[sw][0][two[j%4]]);
				putchar(o[sw][0][1]);putchar(o[sw][0][2]);putchar(o[sw][0][3]);
				if(i!=n/2) putchar(o[sw][0][2]);
			}
			else
			{
				putchar(o[sw][0][1]);putchar(o[sw][0][2]);putchar(o[sw][0][3]);putchar(o[sw][0][3]);putchar(o[sw][0][0]);putchar(o[sw][0][3]);
				for(j=0;j<2*(m-5);j++) putchar(o[sw][0][tw[j%4]]);
				putchar(o[sw][0][3]);putchar(o[sw][0][2]);putchar(o[sw][0][1]);
				if(i!=n/2) putchar(o[sw][0][2]);
			}
		}
		if(sw) cout<<"\n2 1";
		else cout<<"\n1 2";
		return 0;
	}
	if(n%2&&m%2)
	{
		for(i=0;i<(n-3)/2;i++)
		{
			for(j=0;j<2*m-1-4*i;j++) putchar(o[sw][i%2][two[j%4]]);
			putchar(o[sw][i%2][2]);
			for(j=0;j<2*n-5-4*i;j++) putchar(o[sw][i%2][dt[j%4]]);
			putchar(o[sw][i%2][3]);
		}
		for(l=0;l<(m-2*i)*3-1;l++) putchar(o[sw][i%2][three[l%6]]);
		cout<<"\n1 1";
		return 0;
	}
	for(i=0;i<(n-2)/2;i++)
	{
		for(j=0;j<2*m-4-4*i;j++) putchar(o[sw][i%2][two[j%4]]);
		for(j=2;j<2*n+1-4*i;j++) putchar(o[sw][i%2][dt[j%4]]);
		putchar(o[sw][i%2][3]);
	}
	for(l=0;l<(m-2*i)*2-1;l++) putchar(o[sw][i%2][two[l%4]]);
	cout<<"\n1 1";
	return 0;
}
```

# The End.

---


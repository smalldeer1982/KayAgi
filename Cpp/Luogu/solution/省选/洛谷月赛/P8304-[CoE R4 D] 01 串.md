# [CoE R4 D] 01 串

## 题目描述

定义一个好的 $01$ 串 $\mathcal{S}$ 满足以下条件：

+ $\mathcal{S}$ 非空。

+ $\mathcal{S}$ 的任意一个前缀 $\mathcal {S}$$ [1\dots p](p\in [1,|$$\mathcal S$$|])$ 中，$0$ 的数量都不多于 $1$ 的数量。
+ $\mathcal{S}$ 的任意一个后缀 $\mathcal S$$[p\dots |$$\mathcal{S}$$|](p\in [1,|$$\mathcal S$$|])$ 中，$0$ 的数量都不多于 $1$ 的数量。

现在你得到了一个长度为 $n$ 的 $01$ 串 $\mathcal{T}$，有 $q$ 次询问，每次询问给定一对 $l,r$，求 $\mathcal{T}[l\dots r]$ 中的最长的好的 $01$ **子序列** 的长度。若没有好的 $01$ 子序列，则输出 $-1$。

注意：**子序列** 是指去除某些元素但不破坏余下元素的相对位置而形成的新序列。

## 说明/提示

### 样例解释

第一次询问中，询问的串为 $0$，没有任何的子序列是好的，所以答案是 $-1$。

第二次询问中，询问的串为 $01001$，子序列 $101$ 是好的且是最长的，所以答案是 $3$。

第三次询问中，询问的串为 $10010101$，子序列 $1010101$ 是好的且是最长的，所以答案是 $7$。

第四次询问中，询问的串为 $0100101011$，子序列 $10101011$ 是好的且是最长的，所以答案是 $8$。

---

### 数据规模

**本题采用捆绑测试。**

| 子任务 | 分值 | $n \le$ | $q \le$ |
| :-: | :-: | :-: | :-: |
| $1$ | $10$ | $10$ | $10$ |
| $2$ | $20$ | $2000$ | $2000$ |
| $3$ | $30$ | $8\times 10^4$ | $8\times 10^4$ |
| $4$ | $10$ | $10^5$ | $1$ |
| $5$ | $30$ | $5\times 10^5$ | $5\times 10^5$ |

对于 $100\%$ 的数据，$1 \leq l \leq r \leq n \leq 5 \times 10^5$，$1 \leq q \leq 5 \times 10^5$。

## 样例 #1

### 输入

```
10 4
0100101011
1 1
1 5
2 9
1 10```

### 输出

```
-1
3
7
8```

# 题解

## 作者：OrezTsim (赞：2)

先考虑 $[1,n]$ 的答案。

猜结论。将 $a_i=0$ 视为 $-1$，做前缀和，每一次 $<0$ 就意味着删掉一个 $0$。

再做一遍后缀和，执行同样的操作。

最后的答案就是区间长度 $-$ 删掉的 $0$ 的数量。

事实上，交一发，发现有 40pts，证明贪心是对的。

（但是我真的不会证贪心策略，我只能感性理解，如果有神仙知道请发到评论区 /kk）

那么考虑答案的变化过程。

比方说，当前前缀和数组 $\text{pre}_i=-1$，考虑对 $[i,n]$ 全体 $+1$。

继续碰到 $\text{pre}'_j=-1$（有原来 $\text{pre}_j=-2$），对 $[j,n]$ 全体 $+1$。

那么我们发现，统计做前缀和的过程，其实依次就是找到第一个 $-1,-2,...,-x$。

那么第一轮操作（统计前缀和）的操作次数，也就是 $-\min\limits_{i=1}^n \{\text{pre}_i\}$。

由于第一轮操作会对第二轮操作（统计后缀和）产生影响，考虑影响。

对于现在的后缀数组 $\text{suf}'_i$（在第一轮操作之前为 $\text{suf}_i$），$\Delta=$ 在 $i$ 右侧删除的 $0$ 的个数。

想到这个不好维护，转化为差，即 $-\min\limits_{i=1}^n\{\text{pre}_i\}-$ $i$ 左侧删除的 $0$ 的个数。

根据上侧的贪心策略，在 $i$ 左侧删除的 $0$ 的个数 $=-\min\limits_{j=1}^{i-1}\{\text{pre}_j\}$。

那么 $\text{suf}'_i=\text{suf}_i+(-\min\limits_{i=1}^n\{\text{pre}_i\})-(-\min\limits_{j=1}^{i-1}\{\text{pre}_j\})$。

则最终答案为 $-\min\limits_{i=1}^n \{\text{pre}_i\}+(-\min\limits_{i=1}^n \{\text{suf}'_i\})=-\min\limits_{i=1}^n \{\text{suf}_i+\min\limits_{j=1}^{i-1}\{\text{pre}_j\}\}$。

考虑怎么维护这个东西。

想想，答案其实是对于每一个段 $[i,n]$，都求出 $\min\limits_{j=1}^{i-1}\{\text{pre}_j\}$。

枚举 $i,j$ 的过程本质上也就是枚举互不相交的一个前缀和一个后缀。

问题就转化为，求互不相交的一个前缀和一个后缀的和的最小值。

继续转化，其实一个前缀和一个后缀的和的最小值，就等于全局和减去夹在中间的区间和。

问题等于 $\max\limits_{1 \le l < r \le n}\{(\sum\limits_{k=1}^n a_k)-(\sum\limits_{k=l+1}^{r-1}a_k)\}$。

那么就转化为最大子段和问题。这个东西显然可以推广到区间上。

由于题目问的是最多剩下多少个数，所以要用区间长度减掉维护的答案。

```cpp
#include <bits/stdc++.h>
#define ls ((rt) << 1)
#define rs ((rt) << 1 | 1)
using namespace std;

const int N = 5e5 + 10; int n, q;
struct Node { int al, sum, pre, suf; } t[N << 2];

inline Node pushup(Node f, Node s) {
    Node res; res.sum = f.sum + s.sum;
    res.pre = max(f.pre, f.sum + s.pre), res.suf = max(s.suf, s.sum + f.suf);
    res.al = max(max(f.al, s.al), f.suf + s.pre); return res;
}

inline void build(int rt, int l, int r) {
    if (l == r) {
        char op; cin >> op;
        t[rt].al = t[rt].sum = t[rt].pre = t[rt].suf = (op == '0'? -1 : 1);
        if (t[rt].al < 0) t[rt].al = 0; return ;
    }
    int mid = (l + r) >> 1;
    build(ls, l, mid), build(rs, mid + 1, r);
    t[rt] = pushup(t[ls], t[rs]); return ;
}

inline Node query(int rt, int l, int r, int L, int R) {
    if (L <= l && r <= R) return t[rt];
    int mid = (l + r) >> 1; Node f, s; int tag = 0;
    if (L <= mid) f = query(ls, l, mid, L, R), ++tag;
    if (R > mid) s = query(rs, mid + 1, r, L, R), tag += 2;
    if (tag == 1) return f; if (tag == 2) return s;
    return pushup(f, s);
}

inline void solve() {
    int l, r; cin >> l >> r;
    Node res = query(1, 1, n, l, r); int len = res.al - res.sum;
    if (len >= r - l + 1) cout << -1 << endl;
    else cout << r - l + 1 - len << endl; return ;
}

int main() {
    ios_base::sync_with_stdio(false); cin.tie(0), cout.tie(0);
    cin >> n >> q; build(1, 1, n);
    while (q--) solve(); return 0;
}
```

---

## 作者：Genius_Star (赞：0)

[**或许更好的阅读体验。**](https://www.cnblogs.com/rgw2010/p/18388033)

### 思路：

先令 $0 \to -1$。

首先猜了一个结论，先顺着走，做一个前缀和，若当且位置的前缀和 $<0$，那么需要删除这个位置的 $0$，使得前缀和为正；然后再反着做一遍，那么答案就是删除的 $0$ 的个数。

#### 暴力 Code：

```cpp
int main(){
    n=read(),q=read();
    For(i,1,n){
        a[i]=get()-'0';
        if(!a[i])
          a[i]=-1;
    }
    while(q--){
        sum=ans=0;
        l=read(),r=read();
        For(i,l,r){
            sum+=a[i];
            if(sum<0){
                sum++,ans++;
                f[i]=1;
            }
        }
        _For(i,l,r){
            if(f[i]){
                f[i]=0;
                continue;
            }
            sum+=a[i];
            if(sum<0)
              sum++,ans++;
        }
        write(r-l+1-ans);
        putchar('\n');
    }
    return 0;
}
```
考虑优化，令 $pre_i$ 表示 $[l,i]$ 的前缀和，$suf_i$ 表示 $[i,r]$ 的后缀和。

则正着扫的时候，若 $pre_i=-1$，相当于将 $j \in [i,r]$ 的 $pre_j$ 都增加了 $1$，继续扫的时候若碰到 $pre'_k = -1$，经过前面的加法操作前 $pre_k = -2$，此时也需要给 $j \in [k,r]$ 的 $pre_j$ 增加 $1$。

那么我们就可以发现，后面若第 $i$ 次找到 $pre'_j=-1$，则原来的 $pre_j = -i$。

同时我们注意到 $pre_i$ 是由 $pre_{i-1}$ 加减 $1$ 变换而来的，则访问的值域是连续的，则对于第一次正着扫需要的删除次数为：

$$-\min\limits_{i=l}^r pre_i$$

然后再考虑反着扫的贡献，同样也是找到 $suf'_i = -1,-2,-3,\cdots$，但是这里 $suf'$ 是 $suf$ 经过正着扫后变化的。

在正着扫的时候，删除 $i$ 处的 $0$，相当于将 $j \in [l,i]$ 的 $suf_i$ 加 $1$，即我们需要维护 $i$ 这个位置右侧被删除的 $0$ 的个数，因为正着扫是从左往右的，考虑做个差好维护一些，即相当于 $-\min\limits_{i=l}^r pre_i$ 减去 $i$ 左侧被删除的 $0$ 的个数。

$i$ 左侧被删除的 $0$ 的个数，即 $- \min\limits_{j=l}^i pre_j$，则我们得到了：

$$suf'_i = suf_i + (-\min\limits_{j=l}^r pre_j +  \min\limits_{j=l}^i pre_j) = suf_i - \min\limits_{j=l}^r pre_j + \min\limits_{j=l}^i pre_j$$

则反着扫的贡献是：

$$-\min\limits_{i=l}^r suf'_i = -\min\limits_{i=l}^r \Big( suf_i - \min\limits_{j=l}^r pre_j + \min\limits_{j=l}^i pre_j \Big) = -\min\limits_{i=l}^r \Big( suf_i + \min\limits_{j=l}^i pre_j \Big) + \min\limits_{j=l}^r pre_j$$

则删除 $0$ 的总数为：

$$\min\limits_{j=l}^r pre_j - \min\limits_{i=l}^r \Big( suf_i + \min\limits_{j=l}^i pre_j \Big) - \min\limits_{j=l}^r pre_j = - \min\limits_{i=l}^r \Big( suf_i + \min\limits_{j=l}^i pre_j \Big)$$

考虑这个式子的抽象意义：求出一个区间内不相交的一个后缀和加上一个前缀和的最小值，容斥一下，转化为区间和减去中间的一段，即我们要使得中间的一段最大，即区间最大子段和问题，使用线段树维护即可。

时间复杂度为 $O(N \log N)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define Add(x,y) (x+y>=mod)?(x+y-mod):(x+y)
#define lowbit(x) x&(-x)
#define pi pair<ll,ll>
#define pii pair<ll,pair<ll,ll>>
#define iip pair<pair<ll,ll>,ll>
#define ppii pair<pair<ll,ll>,pair<ll,ll>>
#define fi first
#define se second
#define full(l,r,x) for(auto it=l;it!=r;it++) (*it)=x
#define Full(a) memset(a,0,sizeof(a))
#define open(s1,s2) freopen(s1,"r",stdin),freopen(s2,"w",stdout);
#define For(i,l,r) for(int i=l;i<=r;i++)
#define _For(i,l,r) for(int i=r;i>=l;i--)
using namespace std;
typedef long double lb;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
bool Begin;
const ll N=1e6+10;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
inline char get(){
    char c;
    while(1){
        c=getchar();
        if(c=='0'||c=='1')
          break;
    }
    return c;
}
ll n,q,l,r,t,ans;
ll a[N],s[N];
class Tree{
public:
    struct Node{
        ll l,r;
        ll L,R;
        ll sum;
        ll data;
    }X[N<<2];
    Node pushup(Node A,Node B){
        Node Ans;
        Ans.l=A.l,Ans.r=B.r;
        Ans.sum=A.sum+B.sum;
        Ans.L=max(A.L,A.sum+B.L);
        Ans.R=max(B.R,B.sum+A.R);
        Ans.data=max({A.data,B.data,A.R+B.L});
        return Ans;
    }
    void build(ll k,ll l,ll r){
        X[k].l=l,X[k].r=r;
        if(l==r){
            X[k].sum=a[l];
            X[k].data=X[k].L=X[k].R=max(a[l],0ll);
            return ;
        }
        ll mid=(l+r)>>1;
        build(k<<1,l,mid);
        build(k<<1|1,mid+1,r);
        X[k]=pushup(X[k<<1],X[k<<1|1]);
    }
    Node query(ll k,ll l,ll r){
        if(X[k].l==l&&r==X[k].r)
          return X[k];
        ll mid=(X[k].l+X[k].r)>>1;
        if(r<=mid)
          return query(k<<1,l,r);
        else if(l>mid)
          return query(k<<1|1,l,r);
        else
          return pushup(query(k<<1,l,mid),query(k<<1|1,mid+1,r));
    }
}T;
bool f[N];
int main(){
//	open("A.in","A.out");
    n=read(),q=read();
    For(i,1,n){
        a[i]=get()-'0';
        if(!a[i])
          a[i]=-1;
        s[i]=s[i-1]+a[i];
    }
    T.build(1,1,n);
    while(q--){
        l=read(),r=read();
        t=(r-l+1)+(s[r]-s[l-1]-T.query(1,l,r).data);
        if(!t)
          puts("-1");
        else{
        	write(t);
        	putchar('\n');
		}
    }
    return 0;
}
```

---

## 作者：juruo999 (赞：0)

# P8304 [CoE R4 D] 01 串
 
[Problem](https://www.luogu.com.cn/problem/P8304)  
[Blog](https://www.luogu.com.cn/article/0o340aqz)

披着数据结构外衣的贪心。

第一篇题解已经把后面数据结构部分讲的很清楚了，但贪心的正确性并未证明。这里补上。

首先用 $-1$ 替换原串中的 $0$，设得到的数列为 $\{a_i\}$，则原来的条件转化为它的前后缀和均非负。为了得到满足要求的子序列，我们要删去一些元素，而且显然不应该删去 $1$，只会删去某些 $-1$。

对于一个前缀 $L\sim i$，里面删去 $-1$ 的个数至少要是 $\max\{-\operatorname{pre}_i,0\}$。同样对于 $i\sim R$，至少要删去 $\max\{-\operatorname{suf}_i,0\}$ 个 $-1$，其中 $\operatorname{pre}_i$ 和 $\operatorname{suf}_i$ 为前后缀和。

那么我们得到了删去 $-1$ 数量的一个下界：

$$
\begin{aligned}

ans&\ge \max_{L\leq i<j\leq R}\{-\operatorname{pre}_i-\operatorname{suf}_j\}\\

\end{aligned}
$$

而再考虑贪心策略：正着跑一遍，统计当前和，和小于 $0$ 就删去这个 $-1$，再反着跑同样过程。

正着跑的时候跑到 $x$ 时，删去的 $-1$ 数为 $\displaystyle\max_{i\leq x}\{-\operatorname{pre}_i\}$，跑完后，后缀和因删除操作而变成了 $\operatorname{suf'}_i$（为了方便这里仍然保留被删去的那些数的下标）。

而 $\operatorname{suf'}_i$ 相比原来增加了，增量为 $i$ 右边被删去的 $-1$ 数，也就是总删去数减去左边删去的个数。即：

$$
\operatorname{suf'}_i=\operatorname{suf}_i+\max_{L\leq k\leq R}\{-\operatorname{pre}_k\}-\max_{L\leq k<i}\{-\operatorname{pre}_k\}
$$

反着跑新增的删去数为 $\max\{-\operatorname{suf'}_i\}$，一共删去的数是两次之和，可以化简为

$$
\begin{aligned}
&\max_i\{-\operatorname{suf}_i-\max_{L\leq k\leq R}\{-\operatorname{pre}_k\}-\min_{L\leq k<i}\{-\operatorname{pre}_k\}\}+\max_{i\leq x}\{-\operatorname{pre}_i\}\\
=&\max_{L\leq k<i\leq R} \{-\operatorname{pre}_k-\operatorname{suf}_i\}
\end{aligned}
$$

这是该贪心算法的删去次数的严格表达式，可以发现它恰好等于理论下界，即它就是最优解。而上式为区间和减去最大子段和，线段树维护即可。

## Code

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;

template <typename T>
void Read(T &x) {
    x=0;char c=getchar();
    T f=1;
    while(c<'0'||c>'9'){ if(c=='-'){f=-1;} c=getchar(); }
    x=c-'0';
    while((c=getchar())>='0' && c<='9'){ x=x*10+c-'0';}
    x*=f;
}
template <typename T, typename... Args>
void Read(T &x, Args &... args) {
    Read(x);
    Read(args...);
}

const int maxn=500005;
struct node{
    int s,l,r,t;
    int m;
    node(){}
    node(int v){
        s=v;l=r=t=v;
        m=v;
    }
};

node v[maxn*4+10],a[maxn];
void pushup(node&x,const node&l,const node&r){
    x.s=l.s+r.s;
    x.l=max(l.l,l.s+r.l);
    x.r=max(r.r,r.s+l.r);
    x.t=max(l.t,max(r.t,l.r+r.l));
    x.m=max(l.m,r.m);
}
void build(node a[],int l,int r,int id){
    if(l==r){
        v[id]=a[l];
        return;
    }
    int mid=(l+r)>>1;
    build(a,l,mid,id<<1);
    build(a,mid+1,r,id<<1|1);
    pushup(v[id],v[id<<1],v[id<<1|1]);
}
node query(int x,int y,int id,int l,int r){
    if(x<=l && r<=y){
        return v[id];
    }
    int mid=(l+r)>>1;
    node res(-0x3f3f3f);
    if(x>mid){
        return query(x,y,id<<1|1,mid+1,r);
    }else if(y<=mid){
        return query(x,y,id<<1,l,mid);
    }else{
        pushup(res,query(x,y,id<<1,l,mid),query(x,y,id<<1|1,mid+1,r));
    }
    return res;
}
void change(int p,node x,int id,int l,int r){
    if(l==r){
        v[id]=x;
        return;
    }
    int mid=(l+r)>>1;
    if(p<=mid){
        change(p,x,id<<1,l,mid);
    }else{
        change(p,x,id<<1|1,mid+1,r);
    }
    pushup(v[id],v[id<<1],v[id<<1|1]);
}

int main(){
    
    int n,q;
    Read(n,q);
    for(int i=1;i<=n;i++){
        char ch;cin>>ch;
        a[i].s=ch-'0';
        if(a[i].s==0) a[i].s=-1;
        a[i].l=a[i].r=a[i].t=a[i].s;
        a[i].m=a[i].s;
    }
    build(a,1,n,1);
    for(int i=1;i<=q;i++){
        int l,r;
        Read(l,r);
        auto t=query(l,r,1,1,n);
        if(t.t<0) t.t=0;
        if(t.t-t.s>=r-l+1) cout<<"-1\n";
        else cout<<(r-l+1-(t.t-t.s))<<"\n";
    }
    
    return 0;
}
```

---


# 「Wdoi-6」另一侧的月

## 题目背景

[![](https://cdn.luogu.com.cn/upload/image_hosting/ikxrpn7c.png)](https://thwiki.cc/%E5%A4%A7%E7%A9%BA%E9%AD%94%E6%9C%AF_%EF%BD%9E_Magical_Astronomy.)

「人类的梦想之一，月面旅行对一般人也终于成为可能！」   
「从下个月起日本各个旅行公司将开始展开旅行」   

然而，月球的表面，有着将月之都与荒凉的无生命星球隔开的一道结界。只要这道结界存在，人们只能看到石头罢了。

而月面旅行的费用，也绝不是身为大学生的莲子与梅莉二人所能承担的。但是，她们想要探寻的是，被结界所包裹的，有着高度发达文明的月之都。

这，便是另一侧的月。梅莉她看见了。兔子在捣药，身着华美的服装，优雅地在天空中起舞的天女。

「我说莲子啊。如果月面旅行太贵实在不行的话，我们要不要试着想点别的办法去月球呢？」

## 题目描述

### 简要题意

给定 $n$ 个节点的树（保证 $n\ge 2$），Hifuu 和 Luna 交替操作，前者先手。每回合操作者选择一个节点，将「该节点」和「所有与该节点相连的边」删除，形成若干个连通块，操作者再从中保留一个连通块。如果该回合结束后只剩下一个节点，则该回合的操作者失败，另一个人胜利。问谁存在必胜策略。

-----
### 原始题意

但是，月之都是有结界保护的，也就是说莲子与梅莉若是想要用一些方式完成月球旅行，势必要突破这层结界。

月之都的结界是由 $n$ 个节点，$n-1$ 条灵能输送渠道构成的连通的结构，其中节点编号为 $1 \sim n$。结界有一个中枢控制系统，以提防外界的人闯入结界，抵达月之都。莲子和梅莉便需要与这个控制系统进行一些交互，才能进入月之都。

具体而言，莲子梅莉，和中枢控制系统是交替进行操作的，其中莲子梅莉是**先手**。操作方可以任意选择结界上的一个节点，将连向这个节点的**所有**灵能输送渠道全部断绝，同时废弃这个节点。这也就意味着，这会把结界分为若干**组**节点，不同组的节点之间没有灵能输送渠道，而组内的节点由灵能输送渠道相连。在这些节点组中，操作者可以任意保留**一组**节点，将另外所有节点**全部废弃**，即，之后再也无法操作这些被废弃的节点了。

在这样的规则之下，若操作结束后，最后只剩下一个节点，那么操作者失败，另一个人取得胜利。现在莲子和梅莉希望知道，在这样的规则之下，她们是否存在一种必定能够抵达月之都的策略？

## 说明/提示

### 样例解释

#### 样例 \#1

![](https://cdn.luogu.com.cn/upload/image_hosting/9zcd72k1.png)

图 $1$ 是结界。图 $2$、图 $3$ 展示了一种莲子和梅莉可能的一种必胜策略：选择节点 $2$，然后保留 $\{1,3\}$ 所处的连通块，那么中枢控制系统无论是选择节点 $1$ 还是 $3$ 都必输。

#### 样例 \#2

![](https://cdn.luogu.com.cn/upload/image_hosting/djzwnoxz.png)

---

### 数据范围

**本题采用捆绑测试。**

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|}\hline
\textbf{Subtask} & \textbf{\textsf{分值}} & \bm{n\le } & \textbf{\textsf{特殊性质}} & \textbf{Subtask \textsf{依赖}}\cr\hline
1 & 15 & 8 & - & - \cr\hline
2 & 20 & 10^5 & \mathbf{A} & -\cr\hline
3 & 20 & 10^5 & \mathbf{B} & - \cr\hline
4 & 15 & 10^3 & - & 1 \cr\hline
5 & 30 & 10^5 & - & 2,3,4 \cr\hline
\end{array}
$$

- 特殊性质 $\mathbf{A}$：保证存在一个点度数为 $n-1$。
- 特殊性质 $\mathbf{B}$：保证 $n=2^k-1,k \in \N^*$。且树的形态是完全二叉树。

对于 $100\%$ 的数据：$1 \leq T \leq 5$，$2 \le n \le 10^5$，输入数据构成一棵树。

## 样例 #1

### 输入

```
1
5
2 4
1 2
3 1
5 2```

### 输出

```
Hifuu```

## 样例 #2

### 输入

```
1
11
1 2
1 3
1 4
2 5
2 6
4 7
5 8
5 9
9 10
9 11```

### 输出

```
Hifuu```

## 样例 #3

### 输入

```
1
2
1 2```

### 输出

```
Luna```

# 题解

## 作者：liangbowen (赞：46)

## 前言

[题目传送门！](https://www.luogu.com.cn/problem/P8347)

[更好的阅读体验？](https://www.cnblogs.com/liangbowen/p/16664258.html)

困难的博弈论题目。参考了巨佬 @Kaenbyou_Rin 的题解，并对他题解中错误的地方进行了更改。

警告：以下内容稍长，请认真阅读，有一定数学基础就很容易理解，因为实际证明难度不高。这个是[感性证明](https://www.luogu.com.cn/paste/ju0684u5)。

## 思路

首先给出结论：只要有**一个节点的度是偶数**，先手必胜；否则后手必胜（也就是：后手必胜当且仅当**全部节点的度都是奇数**）。

证明如下。为了方便叙述，设状态 $A$ 表示全部点度都是奇数。设每一步选择删除的点为 $u$。严谨说明，这里都是看 $n > 1$ 的情况。

首先很显然，状态 $A$ 的下一个状态一定不是 $A$。

因为 $u$ 连接的点都是两两不同的，所以删掉对应的边后，$u$ 所连接的点的度一定都会变成偶数。

这样不管选哪个连通块，必定有一个点度为偶数（也就是原本与 $u$ 相连的点）。

![](https://cdn.luogu.com.cn/upload/image_hosting/twn3cv75.png)

---

接着证明：不是 $A$ 的状态，必定可以转化为状态 $A$。

这个其实也不难，我们容易想到，必定有一个度为偶数的点，它有一棵子树，里面的所有点，度数都是奇数。

事实上，如果一个点不行，就换另一个点，依次枚举即可找到。

![](https://cdn.luogu.com.cn/upload/image_hosting/irq99m1p.png)

这一部分的具体证明：其实特别简单。

第一次指定根时我们有一棵树，然后如果没有满足要求的子树的话，我们直接从下往上找到**深度最大**的度为偶数的点。

这个点既然深度最深，那它下面必定都是度为奇数的点。这一部分就证掉了。

那我们知道这个有什么用呢？更简单了，直接通过删除其他点，保留下**这个根以及全是奇点的子树**。那么根的度就会变成 $1$。剩下的其他点又都是奇点，那不就变成状态 $A$ 了吗？

---

其实认真阅读上述内容，并不是很困难。如果不仔细证明的话，实际上几分钟就能想出以上两个结论。

有了这两个结论，接下来就很容易了吧。说白了就是：$A$ 必须变成非 $A$，非 $A$ 可以变成 $A$。

阅读题目，当对手将状态变为了 $n = 1$，你就赢了。$n = 1$ 代表着：非 $A$ 的状态。

也就是说，如果初始状态为非 $A$ 状态，先手将这个状态变为 $A$ 状态即可。对手很生气，因为他必须把这个状态再次变为非 $A$ 状态。

由于每次 $n$ 都会减少，而且先手每次都会获得一个非 $A$ 状态。所以迟早这个状态会是 $n = 1$，于是先手获胜了。

反过来，先手获得了 $A$ 状态，那么先手必须把这个状态变成非 $A$ 状态。这下后手变成了先手，同上操作即可。后手获胜。

其实很简单，对吧？

## 完整代码

十分简单精简。

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int in[100005];
void solve()
{
	int n;
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) in[i] = 0;
	for (int i = 1; i < n; i++)
	{
		int u, v;
		scanf("%d%d", &u, &v);
		in[u]++, in[v]++;
	}
	for (int i = 1; i <= n; i++)
		if (in[i] % 2 == 0) //度为偶数，先手必胜 
		{
			puts("Hifuu");
			return;
		}
	puts("Luna");
}
int main()
{
	int T;
	scanf("%d", &T);
	while (T--) solve();
	return 0;
}
```

希望能帮助到大家！

---

## 作者：max0810 (赞：21)

~~第一次自己思考出来紫题，题解纪念一下。~~

------------
下面为大家讲解如何一步步推到最终结论：

------------
首先，原树没有根，不妨设它的根为  $1$，将它转化成有根的，便于操作。

为了方便描述，我们称将一个非根节点的点的父亲删去，保留含这个点的连通块这个操作为截取操作（就是保留一棵子树）；相反，若是将一个非根节点的点删去，保留含这个点父亲的连通块，我们就称之为删除操作（就是把一棵子树丢掉）。

另外，我们称一个有偶数个儿子的节点为偶点，奇数个儿子的点为奇点。注意：所有叶子结点都算偶点。

------------

我们可以先看深度为 $2$（根节点深度为 $1$，下同）的树（菊花图，也就是特殊性质 $A$）。容易发现，你肯定不能删根节点，那么就只能一个个删叶子结点。然后就能得出：如果有奇数个叶子结点，那么先手必败，偶数个叶子结点相反。

显然，如果原树有一个点所有儿子都是叶子结点，且这个点是偶点，那我们肯定不能将这个点的子树截取下来（不然就成了偶数个叶子结点的菊花图了，后手必败）。

而且我们还可以得出一个重要结论：如果原树有一个点所有儿子都是叶子结点，且这个点是奇点，那么先手一定可以直接把这个点的子树截取下来，那么后手就成为这个菊花图的先手，必败。所以如果有这么样的一个点，先手就必胜。所以，我们中途也一定要保证不能出现这种点，**即如果原图没有这种点，中途就不能删任何叶子结点**。

------------
接着，我们将深度推广为 $3$（这里假设只有深度为 $3$ 的点才叫叶子结点，或者假设每个深度为 $2$ 的点都有至少一个儿子）。显然，不能删叶子结点， 也不能保留一棵子树，那就只能一棵棵地删去子树。也能得出和菊花图类似的结论：如果根节点为奇点，先手必败，偶点相反。

所以像菊花图一样，如果能找到个根节点为奇点的这种子树，那么截取下来，先手必胜；否则就不能截取，也不能删这棵子树中任何一个结点（不然别人就可以截取下来获胜）。

继续，若深度为 $4$，如果树中有上述的这种子树的话（也就是除根结点外所有点都是偶点，当然树的深度是小于等于 $3$ 的），那么直接截取，否则只能一个个删深度为 $2$ 的点的子树，同样，如果根节点为奇点，先手必败，偶点相反。

关键来了：我们可以以此类推下去，如果一棵子树的结点全是偶点（下称全偶图），**那么我们就不能删其中任何一个结点，也不能截取这种树。如果有一个结点的所有儿子的子树都是全偶图，但这个点是奇点，那么只能一个个删它的儿子，最后先手必败。**

得到上述结论后就好办了，如果真的有一个结点的所有儿子的子树都是全偶图，但这个点是奇点的话，那么直接将这个点截取下来，那么你就赢了（可以证明这种点一定存在，除非整个图就是一个全偶图，此时只需要删除一个深度为 $2$ 的结点的子树即可）。但如果原树的根结点就是这种结点的话，你就输了（就相当于出题人把这种树给了你）。

所以结论就是，如果根结点是奇点，其它点是偶点，那么先手必败，否则必胜。


------------
代码就非常简单了
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#define ll long long
using namespace std;
const int N = 1e5+5;
bool vis[N],b;
int siz[N],t,n;
vector<int> v[N];
void dfs(int x)
{
	vis[x] = 1;
	for(int i = 0;i < v[x].size();i++)
	{
		int nw = v[x][i];
		if(!vis[nw]){dfs(nw);siz[x]++;}
	}
	if(x!=1&&(siz[x]&1))b = 0;
}
int main()
{
	cin >> t;
	while(t--)
	{
		cin >> n;
		memset(vis,0,sizeof vis);memset(siz,0,sizeof siz);
		b = 1;for(int i = 1;i <= n;i++)v[i].clear();
		for(int i = 1;i < n;i++)
		{
			int x,y;scanf("%d%d",&x,&y);
			v[x].push_back(y);v[y].push_back(x);
		}
		dfs(1);puts(b&&(siz[1]&1)?"Luna":"Hifuu");
	}
	return 0;
}
```

------------
$5.16 :$ 突然发现一种简单的写法：如果根结点以外的点是偶点，那么加上父亲就相当于有奇数个点和它相连。那么后手赢当且仅当无根树所有点的度数都为奇数。
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
const int N = 1e5+5;
int s[N],n,t;
int main()
{
	cin >> t;
	while(t--)
	{
		memset(s,0,sizeof s);
		cin >> n;bool b = 0;
		for(int i = 1;i < n;i++)
		{
			int x,y;cin >> x >> y;
			s[x]++;s[y]++;
		}
		for(int i = 1;i <= n;i++)
			if(!(s[i]&1))b = 1;
		puts(b?"Hifuu":"Luna");
	}
	return 0;
}
```


---

## 作者：VinstaG173 (赞：11)

结论型博弈问题。

事实上我觉得确实没有紫色的难度。以下介绍的已经是一个真正能完整解决此问题的方法了。

首先我们考虑树比较小的情况。以下必胜必败都是在先手立场分析。

显然只有一个点时是必胜的，只有一条边时是必败的，有两条边时是必胜的。

当有三条边时，如果形成一条链那么是必胜的，如果形成菊花图那么是必败的。

如上我们分析一下必胜和必败的条件以及必胜策略的形式，容易发现结论：当且仅当所有点的度数均为奇数时先手必败。

以下证明此结论，记所有点的度数均为奇数的情况为 N 态，存在点度数为偶数的情况为 P 态。由博弈论的基本理论，我们只要证明 N 态的所有后继状态均为 P 态，且 P 态均存在一个后继状态为 N 态即可。

首先我们能够发现题目中的操作就是选一条边切断，后继状态为其中一边的子树。对于 N 态，我们假设切断的边为 $(u,v)$，则由于原树中 $u,v$ 的度数均为奇数，因此切断后 $u,v$ 的度数均为偶数，此时无论选择哪边的子树都存在一个点度数为偶数。

对于 P 态，由于至多只有有限个点度数为偶数，因此任意钦定一个根后必定有一棵子树中只有根节点的度数是偶数，此时选择这一棵子树作为后继状态，即为 N 态。

代码实现是容易的，不放代码了。

---

## 作者：minstdfx (赞：4)

## 另一侧的月
### 更加简要的题意
给定一棵无根树。
- 每次操作是可以随便定根然后保留一个与根直接相连子树，等价表述是选取一条边，把它去掉，保留两个连通块中的一个。
- 对于一个点，先手胜。
问谁有必胜策略。

注：方便起见定义单点树存在一个后手必胜的后继状态（空树）。
### 结论
先手必胜当且仅当存在结点度数为偶数。
另外本题的 $SG$ 函数为树中偶数度数结点的个数。
### 博弈论的基本定理
>对于任意先手必胜(N 态)的局面，满足其存在一个后继局面后手必胜。（定理一）
>对于任意后手必胜(P 态)的局面，满足其任意一个后继局面先手必胜。（定理二）

$SG$ 函数是这样一个关于游戏局面的状态函数：  
- 对于所有终端位置（无后继），本题中为后手胜利的空树。
- 对于某个状态 $T$，$SG_T = \operatorname{mex}\{SG_S \mid S\:\footnotesize\texttt{是}\normalsize\:T\:\footnotesize\texttt{的后继状态}\}$。
- 本题而言先手胜利的情况下，$SG_T$ 非零。反之亦然。

Sprague-Grundy 定理：游戏的和的 $SG$ 函数值是它的所有子游戏的 $SG$ 函数值的异或。
### 分析
以下分析将无根树意义下的同构树视为等价状态，其 $SG$ 相同。（但不一定视为相同）。
#### 定性结论
考虑菊花图。根据题意，单点先手必胜。所以，有两个点的菊花图后手必胜。  
继而，有三个点的菊花图，它的后继局面有两个：单点树和两点菊花图。因此它是先手必胜。
我们可以发现，对于深度为 $2$ 的，有 $n$ 个点的菊花图，它的后继状态只有单点树和 $n-1$ 点菊花图。  
因此，按照博弈论的基本法可以产生如下结论：对于菊花图，花瓣个数为偶数那么先手必胜，否则先手必败。

~~（奇怪的定义和名字警告）~~  
定义 $k$ 层偶度根奇度枝叶树（下文称为 $\text{EOT}$/$E-O$ 树），奇度根奇度枝叶树（下文称为 $\text{OOT}$/$O-O$ 树）为满足下列条件的有根树：  
1. 深度为 $k$ 的有根树。
2. 所有与根直接相连的树为 $s(s<k)$ 层 $E-O$ 树。
3. 对于 $\text{EOT}$，根的度数为偶数。对于 $\text{OOT}$，根的度数为奇数。
另外单点树为 $1$ 层 $\text{EOT}$。

我们可以发现，对于所有任意深度的 $\text{OOT}$ 所组成的集合恰好与任意不含偶数度数结点的有根树组成的集合等价。  
此外，$\text{EOT}$ 除根外不含偶数度数结点。

显然如果两棵有根树在无根意义下同构则它们在游戏中视为等价。

（开始归纳）  

假设对于任意 $s(s<k)$ 阶的 $\text{EOT}$ 和 $\text{OOT}$ 来说满足：  
1. $\text{EOT}$ 为 $N$ 态。
2. $\text{OOT}$ 为 $P$ 态。

那么对于 $k$ 阶：
对于与根直接相连的子树个数为 $1$ 的 $\text{OOT}$，定根的儿子为新根，则它变成 $k-1$ 阶 $\text{OOT}$，属于 $P$ 态。  
对于任意根度数为 $2m$ 的 $\text{EOT}$，如果任意根度数为 $2m-1$ 的 $\text{OOT}$ 是 $P$ 态，因为通过去掉一棵子树可以得到一个根度数为 $2m-1$ 的 $\text{OOT}$ 的后继状态，所以它是 $N$ 态。  

对于任意根度数为 $2m-1$ 的 $\text{OOT}$，情况略复杂一些。  
如何证明它属于 $P$ 态呢？  
只要证明它的所有后继局面属于 $N$ 态。  
1. 对于保留它的一棵子树，显然子树是某阶的 $\text{EOT}$，是属于 $N$ 态的。  
2. 对于删除一棵子树，假设删除的子树的根为 $u$，其父亲为 $f_u$。  
删掉它之后得到的后继状态中，以 $f_u$ 为根的子树是某阶的某阶的 $\text{OOT}$，属于 $P$ 态。  
因此该后继状态存在一个 $P$ 态的后继，为 $N$ 态。  
又因为 $u$ 是任意的，所以原状态的所有删子树类型的后继状态均为 $N$ 态。
所以，原状态的所有后继状态均为 $N$，因此原状态为 $P$ 态得证。

我们现在证明了所有 $\text{OOT}$，亦即所有**不含偶数度数结点的有根树**为 $P$ 态。  
考虑到同构树等价，因此，所有**不含偶数度数结点的树**为 $P$ 态。

对于存在偶数度数结点的树，取其偶数度数结点组成的虚树上的叶子，它在原树上总有一个子树不含偶数度数结点。  
因此原树存在一个后继为 $P$ 态，原树为 $N$ 态。

综上，一个树的游戏状态为 $N$ 态，当且仅当，树存在一个结点度数为偶数。

这个结论检查发现对于同构树的状态是相同的。
#### 分析 SG 函数
显然根据上文，**不含偶数度数结点的树**为 $P$ 态，在这里 $SG$ 函数为 $0$。  
对于一个含 $k$ 个偶数度数结点的树，显然对于所有小于 $k$ 的非负整数 $x$ 总有一个后继为含 $x$ 个偶数度数结点的树。  
因此归纳得出 $SG$ 函数的值即为偶数度数结点的个数。对于 corner 显然也是成立的。
#### 策略？
显然搞出偶数度数结点组成的虚树乱搞就行了。每次保证离开自己手上的时候都是后手必胜就行了。
### code
```javascript
let FileLines = require("fs").readFileSync(0).toString().split("\n"), outputBuf = [],s = 0;
const readLine = (x = (s ++)) => FileLines[x].split(" ").map((e) => +e);
let T = readLine()[0], deg = {};
while(T -- > 0) {
	const n = readLine()[0];
	deg = {};
	for(let i = 1; i < n; ++ i) {
		let [u, v] = readLine();
		deg[u] = (deg[u] ?? 0) + 1;
		deg[v] = (deg[v] ?? 0) + 1;
	}
	let flag = 0;
	for(let i = 1;i <= n; ++ i) {
		if (~(deg[i] ?? 0)&1) flag = 1;
	}
	outputBuf.push(flag?"Hifuu":"Luna");
}
console.log(outputBuf.join("\n"));
```


---

## 作者：N2MENT (赞：3)

感谢 [iamdhf](https://www.luogu.com.cn/user/436389) 带来的题目。

直入主题，一个点先手胜利，两个点和一条边后手赢，操作可以视为切断一条边并保留一部分，如果度数全是奇数，那么先手切掉一条边的时候，与断边相连的点度数会变成偶数，后手可以随后切掉偶数度的边，这样所有的点要么是奇数度，要么后手已经胜利。有偶数度点时先手可以保留一部分使得全部的点度数为奇数，自己变为后手，必胜。

即有偶数度点就先手胜利，否则后手胜利。

做完力

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 10;
int deg[maxn];
int n;
int t;
void solve() {
    scanf("%d", &n);
    for (int i = 1; i < n; i++) {
        int u, v;
        scanf("%d%d", &u, &v);
        deg[u]++;
        deg[v]++;
    }
    for (int i = 1; i <= n; i++) {
        if (!(deg[i] & 1)) {
            printf("Hifuu\n");
            return;
        }
    }
    printf("Luna\n");
}
int main() {
    scanf("%d", &t);
    while (t--) {
        solve();
        memset(deg, 0, sizeof(deg));
    }
}
```

---

## 作者：Aftglw (赞：3)

~~看见官方题解用的是 $\text{SG}$ 函数大受震撼。~~

我用的是类似树上博弈 DP 的方法，由边界情况逐层扩展，最后得到全局结论。

先考虑边界情况（叶子节点）

当 $u$ 的儿子全部是叶子时：

1. $u$ 只有一个儿子，那么显然在以 $u$ 为根的子树内，先手必败；

2. $u$ 有两个儿子，那么先手则可以删去一个儿子选择剩下的连通块，从而转化为第一种情况。

以此类推，不难发现，当 $u$ 有奇数个儿子时，先手是必败的；而否则先手是**可胜** 。

这里的**可胜**是指**在当前以 $u$ 为根的子树内**，先手是必胜的。

因为在这种情况下，先手要获胜就必须得删儿子，而保留 $u$。而此时 $u$ 的父亲、祖先、兄弟都可能保留进了连通块，于是就给了后手反败为胜的可能。

而特别地，如果 $u$ 是整棵树的根（菊花图），那么这种**可胜**便能转化为**必胜**。

所以可以得出结论：**如果删当前的根能胜，就是必胜；否则如果删子树内的点（通过后面的情况可以发现这些点其实都是儿子）而获胜，就是可胜。**

有没有其他必胜的情况呢？

其实我们发现，只要到达某一点 $x$，其儿子中存在必败，那么 $x$ 就是必胜。

因为我们可以直接选择删掉 $x$ 而选择必败的儿子，这样后手就进入必败态，先手自然必胜，而此时我们就可以直接输出答案了。

那么可胜态如何向上转移呢？

先考虑只有一个可胜态儿子（为方便起见，我用最基本的可胜态结构来表示一个可胜态，即以下结构）。

![](https://s1.ax1x.com/2022/05/16/OhiiFO.png)

1. 只有一个可胜态儿子：

	这种情况与添加一个叶子节点无异，可胜 → 必败。

2. 有一个可胜儿子和一个叶子儿子：

	![](https://s1.ax1x.com/2022/05/16/OhiBhF.png)
    
	先手可直接删掉一个可胜儿子（$1$）而选择剩下的必败态（$\{u, v\}$），但由于删的不是 $u$ ，所以可胜 → 可胜。

	由上类比，我们可知到对于有一个可胜儿子和 $n$ 个叶子儿子时：当 $n$ 为奇数时 $u$ 可胜；否则 $u$ 必败。

3. 有两个可胜儿子：

	![](https://s1.ax1x.com/2022/05/16/OhFG4O.png)

	如果先手按照其中一个儿子的可胜策略删（比如删掉 $\text{leaf1}$），剩下的连通块中必定包含一个必败态（$\{1, \text{leaf2}\}$），不然这个儿子就不是可胜了。此时后手可以直接删掉它的父亲（$u$），留下必败态，先手必败。

	如果先手删掉可胜儿子（比如 $1$），那么留下的就是一个可胜态又接上一个叶子（$\{u, 2, \text{leaf3, leaf4}\}$），为必败态，那么先手就可获胜。可胜 → 可胜。

	如果先手删根（$u$），那么无论怎么选留给后手的都是特殊的可胜态，可转化为必胜态，先手必败。

	因此，有两个可胜儿子时，先手最优情况下为可胜。

	由上类比，我们知道对于有 $n$ 个可胜儿子时：当 $n$ 为奇数，先手必败；当 $n$ 为偶数时，先手可胜。
    
综合上述所有情况，我们可以归纳得出：

> 当一个节点有奇数个儿子时，该节点必败；

> 当一个节点有偶数个儿子时，该节点可胜；

> 当一个非根节点必败，全局必胜。

这么看来，我们可以将叶子节点定为可胜。

代码自然很简单了。

```cpp
const int N = 2e5 + 5, inf = 0x3f3f3f3f, P = 998244353;
int f[N];
int first[N], nex[N << 1], to[N << 1], num;
inline void Add(int u, int v)
{
	nex[++num] = first[u];
	first[u] = num;
	to[num] = v;
}
inline bool dfs(int u, int fa)
{
	int siz = 0;
	for (re int i = first[u]; i; i = nex[i])
	{
		int v = to[i];
		if (v == fa) continue;
		++siz;
		if (dfs(v, u)) return 1;
		if (f[v] == 0) {puts("Hifuu"); return 1;}
	}
	if (siz & 1) f[u] = 0;
	else f[u] = 1;
	return 0;
}
signed main()
{
	int T = read();
	while (T--)
	{
		int n = read();
		for (re int i = 1; i <= n; ++i) first[i] = 0;
		num = 0;
		for (re int i = 1; i < n; ++i)
		{
			int u = read(), v = read();
			Add(u, v), Add(v, u);
		}
		if (!dfs(1, 1)) puts(f[1] == 1 ? "Hifuu" : "Luna");
	}
	return 0;
}
```

---

## 作者：天南星魔芋 (赞：3)

这题是一个博弈题。

然而我并不熟悉很博弈论，所以想用dp过此题。

转移的话就是以 $1$ 节点为根，对于一个节点 $x$ ，我们要算出 $x$ 及其子树所构成的联通块是否先手必胜。

用 $o[x]$ 存 $x$ 及其子树所构成的联通块是否先手必胜。（$1$ 为是，$0$ 为否）

可以发现若 $x$ 的子树中有一个节点 $y$ 并且 $o[y]=0$，那么 $o[x]=1$。

若不是上述情况，那么 $x$ 子树中的值都为 $1$。

先考虑只能删除 $x$ 的儿子节点（删 $x$ 本身就输了），若 $x$ 为 $1$ 的儿子个数有偶数个 $o[x]=1$，否则 $o[x]=0$。

现在考虑若能删 $x$ 子树上所有的节点，若删了 $y$ （$y$ 位于 $x$ 的子树上，并且不是 $x$ 或 $x$ 的儿子），那么对于 $y$ 的父亲 $z$，$o[z]=0$（原来 $o[z]=1$），此时 $o[x]=1$。

总结一下就是
>1.若 $x$ 子树中有节点为 $0$，$o[x]$ 为 $1$。
>
>2.若第一条无法确定 $o[x]$，那么若 $x$ 儿子数量为偶数 $o[x]$ 为 $1$，若 $x$ 儿子数量为奇数 $o[x]$ 为 $0$。

$code:$

```cpp
#include<bits/stdc++.h>
using namespace std;
int fir[120000],nxt[240000],to[240000],top=0;
int T,n;
int ans[120000],tag[120000];
void add(int x,int y){
	top++;nxt[top]=fir[x];fir[x]=top;to[top]=y;
}
void dfs(int x,int fa){
	int jsq=0;
	for(int i=fir[x];i;i=nxt[i]){
		if(to[i]==fa)continue;
		dfs(to[i],x);
		jsq++;
		tag[x]|=tag[to[i]];
	}
	if(tag[x])ans[x]=1;
	else if(jsq&1){
	    ans[x]=0;
	}
	else ans[x]=1;
	if(!ans[x])tag[x]=1;
}
signed main(){
	cin>>T;
	while(T--){
		cin>>n;
		for(int i=1;i<=n;i++){
			fir[i]=ans[i]=tag[i]=0;
		}
		top=0;
		for(int i=1;i<n;i++){
			int x,y;
			scanf("%d%d",&x,&y);
			add(x,y);add(y,x);
		}
		dfs(1,0);
		if(ans[1]==1)puts("Hifuu");
		else puts("Luna");
	}
}
```


---

## 作者：gyyyyx (赞：2)

很有趣的题目。

首先可以提供一下做博弈论题目的思路。

第一，先往**奇偶性**和先手或者后手如何才能**必胜或必输**的方向去想。

第二，如果题目内容和**无根树**有关，且如果换根之后不影响结果那可以选择一个点作为根，便于操作。

第三，看特殊性质，一般来说能帮助到我们做题（无论什么题）。

当然，~~如果您是奆佬可以无视这两段话~~，不代表所有题目都可以这样做。

好的，回归正题。因为换根之后不影响结果，那直接假设节点 $1$ 是根。

如果树的深度为 $1$，那肯定是后手必胜。

如果树的深度是 $2$，即树是菊花图（性质 $A$），因为先后手都不可能删掉根节点（删掉之后就留下的一堆的单个节点），那只能一个一个删叶子节点，即**根节点的儿子**，所以要看叶子结点个数。如果叶子个数为**奇数**，后手必胜；反之先手必胜。

这个结论不难想。

接着如果树的深度是 $3$ 呢？可以将根节点的儿子一个个删去留下根节点，或者删去根节点后留下一个子树再用深度为 $2$ 的方法判断。只有当根节点儿子数量为**奇数**，或者**所有子树的叶子个数**均为**偶数**时，后手必胜。

依次类推下去，发现：当某棵子树的**所有节点**都有**偶数**个儿子节点，那当前选择的人**一定不能**将这个子树的父亲删去然后选这棵子树。

所以后手想要获胜那就是要让这棵树中**除了根节点**外（后面会解释），所有节点都有偶数个儿子，让先手无法选择。

但为什么根节点不可以呢？因为如果这棵树中**所有节点**都有**偶数**个儿子这样的话，那先手可以一个一个删除**根节点的子树**，而后手只能和先手一样，不可能将某个子树的父亲删除后选择这个子树（因为这样就会回到这种情况）。

然后删到最后会发现先手必赢。

于是得出结论：如果根结点有**奇数**个儿子，**其它所有**点又**偶点**个儿子，那么**后手**必胜，否则必败。

接着就可以写出代码了。

但我突然发现，因为根节点没有父亲，而其它节点有父亲，所以只需要判断每个节点的**度**（有多少条边与之相连）是否为奇数就行了。

代码如下：

```cpp#include<bits/stdc++.h>
using namespace std;
int T,n,d[100005];
bool f;
int main(){
    scanf("%d",&T);
    while(T--){
        scanf("%d",&n);
        memset(d,0,sizeof(d));
        for(int i(1),u,v;i<n;++i){
            scanf("%d%d",&u,&v);
            ++d[u];++d[v];
        }
        f=0;
        for(int i(1);i<=n;++i)
            if(!(d[i]&1)){f=1;break;}
        if(f) puts("Hifuu");
        else puts("Luna");
    }
    return 0;
}
```

撒花~

---

## 作者：Kaenbyou_Rin (赞：1)

~~（结论很简单可是证的我好累啊qwq）~~


------------

很显然这是一道博弈论。

我们先从简单的情况入手。

![](https://cdn.luogu.com.cn/upload/image_hosting/u07sxenz.png)

所以我们可以做出假设：

  当树上**存在**度数为偶数的点（下称偶点）时，先手必胜。

换一个说法就是：

  当树上**仅**存在奇点时，先手必败。

------------

### 下面是证明：

我们设计两个状态：状态 $A$ 表示树上全部为奇点，状态 $B$ 表示树上全部为偶点。

（ 1 ） 证明 $A$ 的后继状态**一定**为 $B$ ：

当删除一个点及与这个点相连的边后，由于该点为奇点，所以必然存在一条边与该点相连。删去边后，图中原先与之相连的点的度数 $-1$ ，由于先前所有的点都为奇点，所以在操作后，在剩余的若干连通块中，每块至少存在一个偶点。

（ 2 ） 证明 $B$ **至少存在一个**后继状态为 $A$ ：

由于偶点必然是是有限的，所以至少存在一颗以偶点为根的树，它的一棵子树中有且仅有奇点。（假设子树中仍有偶点，那么就指定这个点为根。由树的定义还可以知道，一棵树的叶子结点**不可能**为偶点。）

所以进行操作时只需要保留指定的根节点以及只有奇点的子树，此时根节点有且仅有一个儿子，也是奇点，我们又得到了状态 $A$ 。

那么为什么要将状态 $B$ 变为 $A$ 呢？

首先数据保证 $n>1$ ，所以你不可能一开始只拿到一个点然后~~然后暴毙~~。

如果对方给你了一个度数为 $0$ 的点，那么恭喜你，你赢了。

若不为 $0$ ，由于是偶点，你操作后~~只要你不傻~~保留的连通块所有点的度数仍会大于等于 $1$ ，不会失败。

故，假设成立。



------------

### Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+10;
inline int read(){
	int x=0,w=1;
	char ch=getchar();
	for(;ch>'9'||ch<'0';ch=getchar()) if(ch=='-') w=-1;
	for(;ch<='9'&&ch>='0';ch=getchar()) x=(x<<1)+(x<<3)+(ch^48);
	return x*w;
} 
int t,n,cnt[N];
int main(){
	t=read();
	while(t--){
		n=read();bool flag=false;
		for(register int i=1;i<n;i++)
			cnt[read()]++,cnt[read()]++;
		for(register int i=1;i<=n;i++){
			if(!(cnt[i]&1)){
				flag=true;
				break;
			}
		}
		if(flag) puts("Hifuu");
		else puts("Luna");
		memset(cnt,0,sizeof(cnt));//记得清零！
	}
	return 0;
}
```

如有错误欢迎指正。

最后，秘封组好耶！

---

## 作者：CReatiQ (赞：0)

### 题意简述

给定一棵点数不少于 $2$ 的树，先后手玩家轮流进行以下操作：

> 删去树上一个点，再选择剩下的一个连通块保留。

操作后保留的连通块大小为 $1$ 者为败者，求必胜者。

---

### 思路

考虑一个有根菊花，当叶子点数为偶数时先手必胜，否则后手必胜。

考虑高为 $3$ 的有根树，如果根节点有棵子树是叶子点数为奇数的有根菊花，必然先手必胜，决策与先前相同。

考虑根节点所有子树均是叶子点数为偶数的有根菊花（不妨把单点假设成叶子点数为 $0$ 的有根菊花）的情况，总是贪心割根节点的儿子，若根节点的儿子为偶数则先手必胜，否则后手必胜。

数学归纳法一下，对于一棵树的所有点，有如下性质：

> 若该点为树根且儿子数目为偶数，则先手必胜。

> 若该点不为树根且儿子数目为奇数，则先手必胜。

> 若全树没有一个点能保证先手必胜，则后手必胜。

我们懒得对树根分类讨论，索性从度来考虑，结论变成：**若树上存在度为偶数的点则先手必胜，否则后手必胜。**

---

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define MAXN (int)(1e5+233)
#define rep(i,l,r) for (int i=l;i<=r;i++)

int T,n,deg[MAXN];

inline int read()
{
	int x=0,f=1;char c;
	while (!isdigit(c=getchar())) if (c=='-') f=-1;
	while (isdigit(c)) x=(x<<1)+(x<<3)+(c^48),c=getchar();
	return f*x;
}

inline void R()
{
	n=read();
	rep(i,1,n) deg[i]=0;
	rep(i,1,(n<<1)-2) deg[read()]++;
	rep(i,1,n)
		if (!(deg[i]&1))
		{
			puts("Hifuu");
			return;
		}
	puts("Luna");
}

int main()
{
	T=read();
	while (T--) R();
	return 0;
}
```


---


# 旭日东升

## 题目背景

238 神教 #3

——还有多久，太阳才会出来？

——不知道……

在古老的传说中，你家附近的小村，由于惹怒了太阳神而被罚去了日光。庄稼纷纷枯死了，人们在寒冷与饥饿中求生。而小村的附近，除了你家以外，就是一片大荒。

神学开始在小村中兴起。越来越多的人成为了神学家，在当年集资修建的图书馆中没日没夜地研读着古籍。终于，大家在图书馆仓库的一个阴暗潮湿的角落里发现了一本——

古老而破旧的，据说早已失传的《祈日术》。

## 题目描述

书里的许多记载已不可辨识。根据残存的篇章，大家只能推测是要举办一场比赛，非常困难的比赛。至于比完之后怎么处理，完全没有头绪。

但大家决定试试，哪怕是自己摸索呢？

于是当你路过村子的时候，便看见展板上挂了这么一道题——唯一的比赛题。

> 维护一个不可重集合的序列 $a$，长度为 $n$。支持以下两种操作：
> 1. 给定 $l,r,x$，对于每个 $l\le i\le r$，将 $x$ 并入 $a_i$。
> 2. 给定 $l,r$，设 $S$ 把每个 $l\le i\le r$ 的 $a_i$ 并在一起的集合，输出 $S$ 中所有元素的和。

你看了看自己随身带着的电脑，决定去捧（za）个场。

那么，加油吧！

## 说明/提示

**本题采用捆绑测试。**

对于 $100\%$ 的数据，保证 $1\le n,m,x\le10^5,1\le l\le r\le n$。

Subtask 1：对于 $10\%$ 的数据，保证 $1\le n,m,x\le100$;

Subtask 2：对于 $10\%$ 的数据，保证 $1\le n,m,x\le10^5$，第一行的字符串为 `PP`;

Subtask 3：对于 $20\%$ 的数据，保证 $1\le n,m,x\le10^5$，第一行的字符串为 `IP`;

Subtask 4：对于 $30\%$ 的数据，保证 $1\le n,m,x\le10^5$，第一行的字符串为 `PI`;

Subtask 5：对于最后 $30\%$ 的数据，无特殊限制。

---

输入第一行的字符串作用：该字符串包含两个为 `P` 或 `I` 的字符。如果第一个字符为 `P`，那么所有修改操作均满足 $l=r$；如果第二个字符为 `P`，那么所有查询操作均满足 $l=r$。对应位置为 `I` 表示无限制。

---

毫无疑问，你获得了第一名。

“好的，那么我们现在来宣读获奖名单！”

“第三名：……”（掌声，颁奖）

“第二名：……”（掌声，颁奖）

“第一……”

主持人突然停下来，揉揉眼睛，随即惶恐地看着天空。附近的人们好奇地凑上去看主持人手中的名单。只见第一名的名字正以一种不可名状的方式剧烈扭曲重构着，反复地在两种不同形态之间变换。

名单的上方突然出现了几个字符。随着字符逐渐变得清晰，人们看清了，是四个意义不明，但看着十分不耐烦的字符：“div1”。

这时，第一名的名字的变动也稳定了下来——就好像其中有一方主动退出了一样。

最终，名字固定在了五个字母：“David”。这并不是你随口报的那个假名。

人们又随主持人一并看向天际，一个看着大概五六岁的孩子正跌跌撞撞地跑来。“我是第一名！”他高兴地笑着。他的母亲——太阳神就站在远方，一脸怜爱地看着那个小小的背影。

一轮红日从地平线上喷薄而出。

## 样例 #1

### 输入

```
II
11 13
1 6 8 4
2 7 7
2 2 4
2 11 11
1 1 11 2
1 5 5 5
1 8 11 3
2 1 8
1 5 10 2
1 2 4 4
2 2 10
2 3 9
2 2 4```

### 输出

```
4
0
0
14
14
14
6
```

# 题解

## 作者：letitdown (赞：7)

我们考虑使用 `std::set` 维护每种颜色出现的连续段。

下面对于一个连续段使用 $L,R$ 表示，对于一个询问区间使用 $l,r$ 表示。

对于一次询问，我们钦定一种颜色的贡献由 $[l,r]$ 包含或相交的最左端的 $[L,R]$ 给出。

那么若现在在颜色 $c$ 中有两个相邻的连续段 $[L_1,R_1]$,$[L_2,R_2]$，那么第二个连续段的贡献形式就是对于 $l\in(R_1,R_2],r\in[L_2,n]$ 的询问答案增加 $c$ 。删除一个连续段的贡献形式是类似的。

对于这样的矩形加单点查形式，我们考虑使用树套树或者 KD 树维护，由于颜色段均摊，复杂度是 $O(nlog^2n)$ 或者 $O(n\sqrt{n})$ 的。

但是本题的空间限制不能满足树套树 $O(n\log^2n)$ 的需求，使用 KD 树的常数较大，不能保证通过本题。

但是我们发现本题并没有强制在线，所以把所有操作离线下来进行 CDQ 分治即可。

时间复杂度 $O(n\log^2n)$，空间复杂度 $O(n)$。

### Code

```cpp
#include<set>
#include<cassert>
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
namespace EMT{
	typedef long long ll;typedef double db;
	#define pf printf
	#define F(i,a,b) for(int i=a;i<=b;i++)
	#define D(i,a,b) for(int i=a;i>=b;i--)
	inline int read(){int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();return x*f;}
	inline void file(){freopen("in.in","r",stdin);freopen("my.out","w",stdout);}
	inline int max(int a,int b){return a>b?a:b;}inline int min(int a,int b){return a<b?a:b;}
	inline void pi(int x){pf("%d ",x);}inline void pn(){pf("\n");}
	const int N=1e5+10;
	struct qs{int opt,x,l,r,v;friend bool operator <(qs a,qs b){return a.x<b.x;}}q[N*10];
	int n,m,qcnt;
	struct BIT{
		ll t[N];
		inline void add(int x,int v){while(x<=n)t[x]+=v,x+=x&-x;}
		inline void add(int l,int r,int v){add(l,v),add(r+1,-v);}
		inline ll ask(int x){ll ans=0;while(x)ans+=t[x],x-=x&-x;return ans;}
	}bit;
	ll ans[N];
	struct dp{int l,r;friend bool operator <(dp a,dp b){return a.l<b.l;}};
	std::set<dp>s[N];
	inline void add(int l,int r,int ql,int qr,int v){
		q[++qcnt]={1,l,ql,qr,v},
		q[++qcnt]={1,r+1,ql,qr,-v};
	}
	inline int ask(std::set<dp> &s,std::set<dp>::iterator it){
		if(it==s.begin())return 1;it--;return it->r+1;
	}
	inline void ins(int v,int l,int r){
		if(1){
			auto it=s[v].upper_bound({r,r});
			if(it!=s[v].begin()){
				it--;
				if(it->r>=r&&it->l<=l)return;
			}
		}
		auto it=s[v].upper_bound({r,r});bool fl=0;
		if(it!=s[v].end()){
			add(ask(s[v],it),it->r,it->l,n,-v);
			if(it->l==r+1){r=it->r;it=s[v].erase(it);fl=1;}
		}
		while(it!=s[v].begin()){
			it--;
			if(l<=it->l&&it->r<=r){add(ask(s[v],it),it->r,it->l,n,-v);it=s[v].erase(it);continue;}
			if(it->r+1<l)break;
			if(it->r+1==l){add(ask(s[v],it),it->r,it->l,n,-v);l=it->l;s[v].erase(it);break;}
			if(it->r>r){add(ask(s[v],it),it->r,it->l,n,-v);r=it->r;it=s[v].erase(it);continue;}
			assert(it->l<=l);l=it->l;add(ask(s[v],it),it->r,it->l,n,-v);it=s[v].erase(it);break;
		}
		if(!fl){
			it=s[v].upper_bound({r,r});
			if(it!=s[v].end())add(r+1,it->r,it->l,n,v);
		}
		it=s[v].insert({l,r}).first;add(ask(s[v],it),r,l,n,v);
	}
	inline void cdq(int l,int r){
		if(l==r)return;
		int mid=(l+r)>>1;
		cdq(l,mid),cdq(mid+1,r);
		std::sort(q+l,q+mid+1),
		std::sort(q+mid+1,q+r+1);
		int j=l;
		F(i,mid+1,r){
			while(q[i].x>=q[j].x&&j<=mid){
				if(q[j].opt==1)bit.add(q[j].l,q[j].r,q[j].v);
				j++;
			}if(q[i].opt==2)ans[q[i].v]+=bit.ask(q[i].r);
		}
		while(j>l){
			j--;
			if(q[j].opt==1)bit.add(q[j].l,q[j].r,-q[j].v);
		}
	}
	inline short main(){
		n=read();m=read();
		memset(ans,-1,sizeof(ans));
		F(i,1,m){
			int opt=read(),l=read(),r=read();
			if(opt==1){ins(read(),l,r);}
			else q[++qcnt]={2,l,r,r,i},ans[i]=0;
		}
		cdq(1,qcnt);
		F(i,1,m)if(~ans[i])pf("%lld\n",ans[i]);
		return 0;
	}
}
signed main(){return EMT::main();}
```

---

## 作者：不知名用户 (赞：0)

### 题意

维护一个不可重集合的序列 $a$，长度为 $n$。支持以下两种操作：
1. 给定 $l,r,x$，对于每个 $l\le i\le r$，将 $x$ 并入 $a_i$。
2. 给定 $l,r$，设 $S$ 把每个 $l\le i\le r$ 的 $a_i$ 并在一起的集合，输出 $S$ 中所有元素的和。

### 做法

#### 如何转化问题

发现任意两个值是独立的，考虑把每个值贡献到答案上。

设当前该值 $v$ 的连续区间为 $[L_0=0,R_0=0],[L_1,R_1],[L_2,R_2],\cdots,[L_x,R_x]$，其中 $[0,0]$ 是为方便计算用的。如果一个区间 $[L,R]$ 包含 $v$，把贡献摊到最左边的区间 $a$，即当且仅当 $\exist a\in[1,x],L\in [R_{x-1}+1,R_x]\And R\in [L_x,n]\And L\le R$。发现这是个二维数点问题，矩形加的时候不用管 $L\le R$，因为加了不会有任何影响。问题变成矩形加，单点查。差分变成[单点加，矩形查](https://www.luogu.com.cn/problem/P4390)，CDQ 分治即可。 

#### 维护连续区间

使用 $100000$ 个 `set` 存每个值连续段。插入一个区间时，先删除被这个区间包含的所有区间。如果和其它区间有交集，必然是往左边或者右边延申的，删除那个区间同时修改插入区间的左右端点。最后插入该区间。

注意插入、删除时还有考虑右边区间对应的“矩形”的变化。

讲的不是很好，细节很多，见 `ins` 函数吧。还有注意题目没有保证 $x\le n$，在这里调了好久。

### code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
using pii = pair<int,int>;
#define x first
#define y second
#define mkp make_pair
const int N = 1e5 + 10;
struct qq{int q, a, x, y;}qu[N*20];int cur;
set<pii>r[N];
int n, ans[N], is[N], c[N];
void ad(int x1, int x2, int y1, int y2, int d)
{
	qu[++cur] = {0,d,x2+1,y2+1}, qu[++cur] = {0,d,x1,y1};
	qu[++cur] = {0,-d,x2+1,y1}, qu[++cur] = {0,-d,x1,y2+1};
}
void upd(pii x, set<pii>&r, int d)
{
	auto it = prev(r.lower_bound(x));
	ad(1+it->y,x.y,x.x,n,d);
}
void del(pii x, set<pii>&r, int d)
{
	auto it = r.upper_bound(x);
	if(it!=r.end()) upd(*it,r,-d);
	upd(x,r,-d), r.erase(x), it = r.upper_bound(x);
	if(it!=r.end()) upd(*it,r,d);
}
void ins(pii x, set<pii>&r, int d)
{
	pii z = mkp(x.x,0);
	for(;;)
	{
		auto it = r.upper_bound(z);
		if(it==r.end()||it->y>x.y) break;
		del(*it,r,d);
	}
	auto it = r.upper_bound(z);
	if(it!=r.end()&&x.x>=it->x&&x.y<=it->y) return;
	it = prev(r.upper_bound(z));
	if(it->y>=x.y) return;//被完全包含
	if(it->y>=x.x) x.x = it -> x, del(*it,r,d);
	it = r.upper_bound(z);
	if(it!=r.end()&&it->x<=x.y) x.y = it -> y, del(*it,r,d);
	it = r.upper_bound(z);
	if(it!=r.end()) upd(*it,r,-d);
	r.insert(x), upd(x,r,d);
	it = r.upper_bound(x);
	if(it!=r.end()) upd(*it,r,d);
}

inline void add(int a, int x){for(;a<=n;a+=(a&-a))c[a]+=x;}
inline int ask(int a){int b=0;for(;a;a-=(a&-a))b+=c[a];return b;}
void cdq(int l, int r)
{
	if(l==r) return;
	int mid = l + r >> 1, i, j;
	cdq(l,mid), cdq(mid+1,r);
	sort(&qu[l],&qu[mid]+1,[](qq a,qq b){return a.x<b.x;});
	sort(&qu[mid+1],&qu[r]+1,[](qq a,qq b){return a.x<b.x;});
	for(i=l,j=mid+1;j<=r;j++)
	{
		while(i<=mid&&qu[i].x<=qu[j].x)
		{
			if(qu[i].q==0) add(qu[i].y,qu[i].a);
			i++;
		}
		if(qu[j].q) ans[qu[j].q] += ask(qu[j].y);
	}
	for(j=l;j<i;j++) if(qu[j].q==0) add(qu[j].y,-qu[j].a);
}

signed main()
{
	int m, i;
	scanf("%*s%lld%lld", &n, &m);
	for(i=1;i<=100000;i++) r[i].insert(mkp(0,0));
	for(i=1;i<=m;i++)
	{
		int op, l, r, x;
		scanf("%lld%lld%lld", &op, &l, &r);
		if(op==1) scanf("%lld", &x), ins(mkp(l,r),::r[x],x);
		else is[i] = 1, qu[++cur] = {i,0,l,r};
	}
	cdq(1,cur);
	for(i=1;i<=m;i++) if(is[i]) printf("%lld\n", ans[i]);
	return 0;
}
```

---


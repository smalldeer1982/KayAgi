# 『JROI-7』T2nz.

## 题目背景

**这是一道交互题。**  

## 题目描述

小 X 陷入了一个奇怪的梦。在梦境里，她在和小 Q 下一种奇怪的棋。

这是一个 $2^{2n}\times 2n$ 的棋盘，小 X 执黑先行，小 Q 执白后行。

每次操作，需要**在当前未满的第一行内**，任意选择一格下棋。一格内只能有一个棋子。

下满之后，共有 $2^{2n}$ 行棋子，小 X 的得分为本质不同的行数。

小 X 想最大化她的得分，但小 Q 想最小化小 X 的得分。

你的任务是，扮演小 X 或小 Q，最大化或最小化得分。

**若你是小 X，在满足最大化得分 $ans$ 的同时，你也要最大化前 $ans$ 行中本质不同的行数**。

------------


### 交互格式

你要先从标准输入读入一行两个整数 $T,tp$，表示数据组数和你扮演的角色。保证 $tp\in\{0,1\}$。若 $tp=0$，表示你扮演小 Q（后手）；若 $tp=1$，表示你扮演小 X（先手）。

接下来每一组数据，你要先从标准输入读入一行一个正整数 $n$，含义见题目描述。

接下来会进行 $2^{2n}\times n$ 次交互。

在每次交互中：

- 若 $tp=0$，你要先从标准输入读入一行一个正整数 $x$，表示小 X 下了黑棋在当前未满的第一行的第 $x$ 列，接下来你要向标准输出输出一个正整数 $y$，表示你下了白棋在当前未满的第一行的第 $y$ 列；
- 若 $tp=1$，你要先向标准输出输出一个正整数 $x$，表示你下了黑棋在当前未满的第一行的第 $x$ 列，接下来你要从标准输入读入一行一个正整数 $y$ 表示小 Q 下了白棋在当前未满的第一行的第 $y$ 列。

你的输出都要**换行并清空缓存区**。

你需要保证你下棋的位置不能已有棋子。同时，交互库也会保证其下棋的位置不会已有棋子。


## 说明/提示

**【样例解释】**

读入的 $n=1$，因此棋盘的大小是 $4\times 2$ 的。两人模拟如[动图](https://i.ibb.co/ChCxHQH/e.gif)所示。最终结果如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/u2goi90a.png)

可以观察发现，最终本质不同的行数为 $2$。容易发现，这是小 X 能最大化的得分。同时，前 $2$ 行中本质不同行数为 $2$，显然无法达到更大的值。

------------

**【数据范围与规模】**

| 测试点编号 | $n \le$ | $tp=$ |
|:-:|:-:|:-:|
| $1$ | $3$ | $0$ |
| $2\sim 3$ | $7$ | $0$ |
| $4$ | $3$ | $1$ |
| $5$ | $4$ | $1$ |
| $6$ | $5$ | $1$ |
| $7 \sim 8$ | $6$ | $1$ |
| $9 \sim 10$ | $7$ | $1$ |

对于所有的数据，保证 $1 \le n \le 7$，$1 \le T \le 3$，$tp\in\{0,1\}$。

------------
**【提示】**

- 您可以使用如下语句来清空缓冲区：

	- 对于 C/C++：`fflush(stdout)`；
	- 对于 C++：`std::cout << std::flush`；
	- 对于 Java：`System.out.flush()`；
	- 对于 Python：`stdout.flush()`；
	- 对于 Pascal：`flush(output)`；
	- 对于其他语言，请自行查阅对应语言的帮助文档。
	- 特别的，对于 C++ 语言，在输出换行时使用 `std::endl` 而不是 `'\n'`，也可以自动刷新缓冲区。
    
- 我们保证交互库耗时在 $1.5\text{s}$ 内，空间消耗可以忽略不计。

## 样例 #1

### 输入

```
1 1
1

2

1

2

1```

### 输出

```


1

2

1

2```

# 题解

## 作者：critnos (赞：8)

非常棒的题，听 rsy 讲的解法。

当双方都采取最优策略时，答案为 $2^n$。

为了证明这点，我们可以证明，先手可以让答案 $\ge2^n$，后手可以让答案 $\le 2^n$。实际上，证明了这点就解决了题目。

后手策略：

将每行 $\{1,2\},\{3,4\}\dots \{2n-1,2n\}$ 进行分组。每次先手下一个位置，后手下该组的另一个位置。

显然每行有 $n$ 组，共有 $2^n$ 个状态，答案 $\le 2^n$。

先手策略：

可以保证前 $2^n$ 行互不相同，这个策略也是满足题目要求的。

考虑目前在下某一行。找到之前的行中有可能成为该行的所有行，即将每行抽象为棋子颜色和棋子位置的二元组集合，之前的行的集合包含当前该行的集合。对于这些行，计算出每一列存在的 $0$ 的个数，选择 $0$ 最多的一列下。

设这里有 $x$ 行，$0$ 的总数为 $nx$，那么根据抽屉原理，$0$ 最多的一列包含 $\ge \dfrac x 2$ 个 $0$。

所以，选择 $0$ 最多的一列下可以至少排除 $\dfrac x 2$ 行，下 $n$ 次可以排除 $\dfrac x {2^n}$ 行，所以前 $2^n$ 行互不相同。

---

## 作者：zhenjianuo2025 (赞：1)

~~好久没水题解了。~~

可以证明，最优策略下答案 $= 2^n$。

- 后手策略：

对于每一行，两个两个分组。如果先手下在了一组中的一个，后手下在另一个。

这样策略下的答案一定 $\le 2^n$。

- 先手策略：

对于每一行 $i$，找到所有包含第 $i$ 行当前状态的行 $j<i$，这些所有的 $j$ 中，下在该列为 $0$ 的行的数量最多的一列。

设 $j$ 有 $k$ 个，根据抽屉原理，$0$ 的个数最多的一列的 $0$ 的个数一定 $\ge \dfrac{kn}{2n}$ 下取整，即 $\ge \dfrac{k}{2}$ 下取整，每一次就至少排除了所有可能相同的行的一半。在 $i\le 2^n$ 时一定可以排除全部的行。这样策略下的答案一定 $\ge 2^n$。

于是，最优策略下答案 $= 2^n$。

---


# 紫丁香

## 题目描述

对于一个字符串 $A$，记 $A_i$ 表示它的第 $i$ 个字符。

设 $S$ 是任意长度为 $m$ 的 $01$ 串。我们有 $n$ 个操作，第 $i$ 个操作可以表示成一个定义域和值域都是长度为 $m$ 的 $01$ 串集合的函数 $f_i$，表示经过这次操作后 $S$ 会变成 $f_i(S)$。而函数 $f_i$ 可以由一个长度为 $m$ 的串 $T_i$ 表示，$T_i$ 由 $\texttt{0,1,-}$ 三种字符组成，其中：

- $T_{i,j}=\texttt{0}$ 表示 $[f_i(S)]_j=\texttt{0}$。

- $T_{i,j}=\texttt{1}$ 表示 $[f_i(S)]_j=\texttt{1}$。

- $T_{i,j}=\texttt{-}$ 表示 $[f_i(S)]_j=S_j$。

也就是说，每个操作会将 $S$ 的一些位赋值为 $0$，一些位赋值为 $1$，还有一些位不变。

现在有 $q$ 次操作，每次操作给定一个长度为 $m$ 的 $01$ 串 $S$，你可以对它做任意多次操作，操作的顺序任意，一个操作可以做多次。得到的串 $S'$ 可以被看做一个二进制数，求对应二进制数最大的 $S'$。

## 说明/提示

**【样例解释】**

对于第一个询问串 $\texttt{00000}$，可以依次进行操作 $3,2$，得到最优的 $S'$：

$$\texttt{00000}\to \texttt{00010}\to \texttt{01110}$$

对于第二个询问串 $\texttt{10010}$，可以依次进行操作 $1,3$，得到最优的 $S'$：

$$\texttt{10010}\to \texttt{11001}\to \texttt{11010}$$

对于第三个询问串 $\texttt{00101}$，可以依次进行操作 $3,2$，得到最优的 $S'$：

$$\texttt{00101}\to \texttt{00010}\to \texttt{01110}$$

---

**【数据范围】**

对于全部数据：$1\leq m\leq 22$，$1\leq n,q\leq 10^5$，$T$ 仅包含 $\texttt{0,1,-}$ 三种字符，$S$ 仅包含 $\texttt{0,1}$ 两种字符。

|     子任务编号     | $m\leq$ | $n\leq$ | $q\leq$ |         特殊性质          | 分值 |
| :----------------: | :-----: | :-----: | :-----: | :-----------------------: | :--: |
| $\text{Subtask 1}$ |  $10$   | $1000$  |   $1$   |            无             | $10$ |
| $\text{Subtask 2}$ |  $10$   | $1000$  | $1000$  |            无             | $20$ |
| $\text{Subtask 3}$ |  $20$   | $10^5$  | $10^5$  | $T$ 中没有 $\texttt{-}$ | $10$ |
| $\text{Subtask 4}$ |  $18$   | $10000$ |   $10$   |            无             | $18$ |
| $\text{Subtask 5}$ |  $20$   | $10^5$  |   $10$   |            无             | $18$ |
| $\text{Subtask 6}$ |  $22$   | $10^5$  | $10^5$  |            无             | $24$ |

---

![](https://cdn.luogu.com.cn/upload/image_hosting/793whkzq.png)

## 样例 #1

### 输入

```
5 3 3
-1-01
011-0
--010
00000
10010
00101
```

### 输出

```
01110
11010
01110
```

# 题解

## 作者：ix35 (赞：10)

## 紫丁香

先考虑怎么解决一次询问。

二分答案，现在问题转化为给定一个位的集合 $B$，求是否存在一种方式操作完后 $B$ 中的位全都是 $\texttt 1$。将 $B$ 的限制写成一个由 $\texttt{1,*}$ 组成的串 $R$，为 $\texttt 1$ 的位表示操作完之后要是 $1$，为 $\texttt *$ 的位表示对这一位没有限制。

现在考虑最后一次操作，设这次操作对应的串是 $T_i$，那么：

- $R$ 中一个为 $\texttt *$ 的位，$T_i$ 中可以是 $\texttt{0,1,-}$ 中的任何一个，因为没有限制。

- $R$ 中一个为 $\texttt 1$ 的位，$T_i$ 中只能是 $\texttt{1,-}$，因为否则最后就会是 $0$。

假设某个 $R$ 中为 $\texttt 1$ 的位，在 $T_i$ 中也是 $\texttt 1$，那么这一位在更之前的操作中就没有限制了（反正最后一步会变成 $\texttt 1$），所以我们可以将 $R$ 的这一位改成 $\texttt *$。

于是判定的过程可以看成这样：

- 每一轮，选出一个满足条件的 $T_i$，然后把 $R,T_i$ 中都为 $\texttt 1$ 的位在 $R$ 中改成 $\texttt *$。

- 重复上述过程直到 $R$ 无法再被更新。

最终，$R$ 可能还剩下一些 $\texttt 1$，这些 $\texttt 1$ 无法通过操作产生，我们只需检验初始串 $S$ 中这些位置是不是都是 $\texttt 1$，如果是则说明判定成功，否则判定失败。

直接这么做复杂度可能是 $O(nqm^2)$ 的。

注意到判定过程除了最后一步之外只和 $R$ 有关，而 $R$ 只有 $2^m$ 种，所以我们不妨对 $R$ 进行 DP。设 $f(R)$ 表示 $R$ 通过上面的更新过程能更新到的 $\texttt 1$ 的数量最小的串，再设 $g(R)$ 表示仅从 $R$ 开始进行一次操作能够变成 $\texttt *$ 的位的并。

那么，$f(R)=g^{\infty}(R)$，而 $g(R)$ 的计算是简单的：比如把操作记在某个对应的 $R_0$ 上，然后做个高维前缀或即可。

预处理 $f(R)$ 后，我们就可以 $O(1)$ 或 $O(m)$ 地进行二分答案中的一次判定。

总复杂度 $O((n+q+2^m)\times m)$。

---

## 作者：樱雪喵 (赞：8)

对于每次询问，考虑二分答案。则题意转化为，给定一个点集 $S$，判断能否使 $x$ 在经过若干次操作后，下标在 $S$ 内的值均为 $1$。

把操作序列倒过来，则过程变为，每次选择一个操作 $x$，其中对于 $S_i=1$，$x_i\neq 0$。那么 $x$ 可以放到操作序列的末尾。而对于 $S_i=1$ 且 $x_i=1$ 的位置，后续的操作可以不再关心这一位的值，把 $S$ 的这一位变为 $0$。

而最后依然是 $1$ 的位置只能由初始值决定，即当 $S$ 为 $x$ 的子集时，答案合法。

那么设 $f(S)$ 表示点集 $S$ 经过若干次操作后剩余的点集，$g(S)$ 表示 $S$ 操作若干步后能从 $1$ 变为 $0$ 的位置并。得到转移 $f(S)=f(S\oplus g(S))$。

考虑如何求 $g$，把每个操作高维后缀或起来即可。至此，我们可以 $O(1) \operatorname{check}$ 一个答案是否合法。

```cpp
#include<bits/stdc++.h>
#define il inline
using namespace std;
il int read()
{
    int xr=0,F=1; char cr;
    while(cr=getchar(),cr<'0'||cr>'9') if(cr=='-') F=-1;
    while(cr>='0'&&cr<='9') 
        xr=(xr<<3)+(xr<<1)+(cr^48),cr=getchar();
    return xr*F;
}
const int N=(1<<22)+5,M=25,K=1e5+5;
int g[N],f[N],t[K][M],s[K][M];
int m,n,q,nw[N];
void print(int x)
{
    for(int i=1;i<=m;i++) nw[i]=x%2,x/=2;
    for(int i=m;i;i--) printf("%d",nw[i]);
    printf(" ");
}
int main()
{
    m=read(),n=read(),q=read();
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            char s;cin>>s;
            if(s=='-') t[i][j]=-1;
            else t[i][j]=s-'0';
        }
        int qwq1=0,qwq2=0;
        for(int j=1;j<=m;j++)
            qwq1=(qwq1*2)+(t[i][j]!=0),qwq2=(qwq2*2)+(t[i][j]==1);
        g[qwq1]|=qwq2; 
    }
    for(int i=(1<<m)-1;i;i--)
        for(int j=0;j<m;j++)
            if(!((i>>j)&1)) g[i]|=g[i^(1<<j)];
    for(int i=1;i<(1<<m);i++) f[i]=(i&g[i])?f[i^(i&g[i])]:i;
    while(q--)
    {
        int x=0;
        for(int i=1;i<=m;i++)
        {
            char s;cin>>s;
            x=(x<<1)+(s-'0');
        }
        int now=0;
        for(int i=m-1;i>=0;i--)
            if((f[now|(1<<i)]&x)==f[now|(1<<i)]) now|=(1<<i);
        print(now); printf("\n");
    }
    return 0;
}
```

---

## 作者：FireBladeMaster (赞：1)

先考虑怎么解决一次询问。

直接把询问串当作操作来用，然后视作询问全 $0$ 串。


令 $f_S$ 表示答案下标在 $S$ 内的数是否能够全为 $1$。

对于 $S$ 内的每一位，按照我们操作的顺序，一定存在一个操作的后缀这一位是 `1-------...---`，这样这一位才会改为 $1$。

那么确定 $f_S$ 其实就是先把在 $S$ 内位置全都不是 $0$ 的东西放在最后操作一遍，然后前面的操作就可以少掉一些位的限制（某一位后面的操作有 $1$，那么前面不再需要 $1$）。

记 $h(S)$ 表示 $S$ 经过上述操作可以减去哪些位的限制，转移为 $f_{0}=1,f_S=f_{S-h(S)}$。$h(S)$ 可以这样求出：对于一个操作串，若非 $0$ 的集合为 $S$，$1$ 的集合为 $T$，令 $g(S)\leftarrow g(S)\cup T$，然后对于 $g$ 高维后缀或。

---

多组询问怎么做呢？

给你 $S$，相当于令 $S$ 的所有子集 $T$，$h(T)=T$。对应到 $f$ 就是 $f_T=1$。观察到这个 $f$ 的 dp 很简单，我们倒着跑一下 dp 记录 $ans_S$ 表示如果将 $f(T)$ 设为 $1$ 的答案。那么初值 $ans_S=S$，转移 $ans_{S-h(S)}=\max(ans_{S-h(S)},ans_S)$。

复杂度 $m(2^m+n+q)$。

---


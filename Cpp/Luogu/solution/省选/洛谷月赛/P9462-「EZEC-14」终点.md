# 「EZEC-14」终点

## 题目背景

~~出题人怎么还没鸟加这首歌啊。~~

于 2023.8.5 拿下。

## 题目描述

**这是一道交互题。**

dXqwq 有一棵 $n$ 个点的无根树，结点从 $1$ 到 $n$ 编号。您需要通过若干次询问得到这棵树的结构。

您可以选择两个整数 $1\leq u,v\leq n$，并输出 `? u v` 进行询问。

对于每次询问，如果 $u,v$ 的路径中点在一个结点上，交互库返回该点的编号，否则返回 ``0``。

请通过不超过 $147154$ 次询问，得到这棵树的结构。

保证树的形态是提前确定的，即**交互库不自适应。**

### 交互方式

输入测试点所在子任务编号 $id$ 和树的大小 $n$ 以开始交互。

交互过程中，您可以进行题目描述中的询问。

对于每次询问，如果你提供的 $u,v$ 不合法或者超出询问次数上限，交互库会返回 ``-1``，否则交互库将会返回一个非负整数，含义见「题目描述」。

当你读取到 ``-1`` 后应立刻退出程序，在此之后交互库的行为未定义。

在您确定答案后，请先输出 `!`，然后接下来 $n-1$ 行依次输出两个整数 ``u[i] v[i]`` 代表树的每条边，最后退出程序。你可以以任意顺序输出这些边。

在您输出一行后，请清空缓冲区：

- 在 C++ 中，使用 `fflush(stdout)` 或 `cout.flush()`。
- 在 Pascal 中，使用 `flush(output)`。
- 在 Python 中，使用 `stdout.flush()`。
- 其它语言请自行查阅文档。

## 说明/提示

**本题采用捆绑测试。**

-  Subtask 1（10 pts）：$n \leq 10$，树满足性质 A。
-  Subtask 2（10 pts）：保证存在一个点度数为 $n-1$。
-  Subtask 3（10 pts）：保证所有点度数 $\leq 2$。
-  Subtask 4（10 pts）：$n \leq 500$，树满足性质 A。
-  Subtask 5（20 pts）：$n \leq 500$。 
-  Subtask 6（20 pts）：树满足性质 A。
-  Subtask 7（20 pts）：无特殊限制。

性质 A：对于 $i=2,3,\cdots,n$ 存在整数 $1\leq j<i$ 满足有一条边连接 $i,j$。

对于 $100\%$ 的数据，$2 \leq n \leq 10^4$。

![](https://cdn.luogu.com.cn/upload/image_hosting/3u2zy1q5.png)

## 样例 #1

### 输入

```
1 5

1

2

3

4

0```

### 输出

```
 
? 1 1

? 1 3

? 2 4

? 3 5

? 4 5

!
1 2
2 3
3 4
4 5```

## 样例 #2

### 输入

```
5 5

1

0

0

2

2```

### 输出

```
 
? 1 1

? 1 3

? 2 4

? 3 5

? 4 5

!
1 3
2 3
2 4
2 5```

# 题解

## 作者：dead_X (赞：11)

## Solution

考虑 $fa_i<i$ 的部分分，我们尝试依次确定 $3,4,\cdots,n$ 的父亲。

我们规定 $1$ 的父亲是 $2$，对于每个点 $x$ 先令临时父亲 $y=1$，然后每次在 $y$ 和 $fa_y$ 中选择距离为偶数的点，尝试更新父亲直到更新后父亲相同为止。每次 $x$ 与 $y$ 的距离 $d$ 会变成 $\lceil\frac{d}{2}\rceil$，因此在 $\log n$ 次迭代后肯定会相同，需要 $n+\sum\limits_{i=1}^n\lceil\log_2i\rceil$ 次操作。

对于任意树的情况，我们先尝试找到两个相邻的点：

先询问每个点和 $1$ 的中点，找到和 $1$ 的距离 $\text{lowbit}$ 最大的（即能取中点次数最多的）不断取中点即可得到一个和 $1$ 相邻的点。

然后考虑使用 bfs 优化上述迭代过程：我们在临时父亲 $y$ 为一个不确定父亲的点时将询问挂在 $y$ 上，然后每次确定一个点的父亲时处理挂在它上面的所有询问即可。

操作次数为较难卡满的 $n+\sum\limits_{i=1}^n\lceil\log_2 i\rceil$，实测 $2n+\sum\limits_{i=1}^n\lceil\log_2 i\rceil$ 甚至 $3n+\sum\limits_{i=1}^n\lceil\log_2 i\rceil$ 在随机选根时也可以通过。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
int query(int x,int y)
{
	printf("? %d %d\n",x,y),
	fflush(stdout);
	return read();
}
int a[10003],b[10003],fa[10003];
vector<int> v[10003],d[10003];
void dfs(int x)
{
	for(int y:v[x])
		dfs(y),b[x]=max(b[x],b[y]+1);
	return ;
}
signed main()
{
	int n=read(),id=2;
	a[1]=1;
	for(int i=2; i<=n; ++i)
	{
		a[i]=query(1,i);
		if(a[i]) v[a[i]].push_back(i),a[i]=1;
	}
	for(int i=2; i<=n; ++i)
	{
		if(!a[i]) dfs(i);
		if(b[i]>b[id]) id=i;
	}
	queue<int> q;
	fa[1]=id,fa[id]=1,q.push(1),q.push(id);
	for(int i=2; i<=n; ++i) if(i!=id) d[1].push_back(i);
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		for(int y:d[x])
		{
			if(a[x]^a[y])
			{
				int z=query(fa[x],y);
				if(z==x) fa[y]=x,q.push(y);
				else d[z].push_back(y);
			}
			else d[query(x,y)].push_back(y);
		}
		vector<int>().swap(d[x]);
	}
	puts("!");
	for(int i=2; i<=n; ++i) printf("%d %d\n",fa[i],i);
	return 0;
}
```

---

## 作者：elbissoPtImaerD (赞：5)

Upd on 230717：修改些许笔误，感谢 [hhhoppitree](https://www.luogu.com.cn/user/183609) 的更正。
# 
厉害！
# 
先考虑特殊性质 A：

其等价于 $\forall [2,n]$，$fa_i <i$，那么可以推出 $fa_2=1$。

我们考虑对于每一个点 $i$，找到其唯一的父亲。

考虑：已经确定了 $i$ 到 $1$ 的路径上所有点（除去两端）的父亲，该如何确定 $i$ 点的父亲。

我们能笃定 $x$ 的父亲 $fa_x$ 为 $y$ 当且仅当我们询问 $(fa_y,x)$ 时得到 $y$。

那就先将 $i$ 的父亲 $fa_i$ 设为 $2$，然后一直查询 $(fa_i,i)$ 的中点，直到能笃定 $i$ 的父亲。

这样每次查找 $fa_i$ 的代价是 $\log $ 级别的。

两个需要注意的细节：
1. 注意有可能 $fa_i=1$，此时的确定条件会改变。
2. 要先花 $n$ 的代价处理出每个节点到 $1$ 的距离的奇偶性，否则总询问上限是 $2 \sum \log i$ 级别的。

这样就有 40 pts 了。
# 
如果没有 $fa_i<i$？

那便无法确定 $fa_2=1$，也就是说，我们需要找到一个与 $1$ 相邻的点。

先给一个结论：$\forall i \in [1,n]$，记 $m=\max\{\operatorname{lowbit}(i)\}$，那么 $\sum\limits_ {i=1}^n [\operatorname{lowbit}(i)=m]=1$ 且 $2^{\lfloor \log n \rfloor}=\sum\limits_ {i=1}^n[\operatorname{lowbit}(i)=m]i$。

反证即可。

那只需查询一遍 $[2,n]$ 和 $1$ 的中点，找到能倍长最多次的 $i$ 即可。
# 
但还没有结束！

此时我们不能保证在寻找 $fa_i$ 时，其到 $1$ 的路径上所有点父亲均已知。

但这不难解决，我们考虑更改求解顺序，在节点 $x$ 的父亲已知时再查询有关 $x$ 和 $fa_x$ 的询问。

具体做法就是，每次询问后如果还是不能确定父亲，那就将这个点挂到新的询问点上。
# 
实现细节看代码。

```cpp
const int N=1e4+3;
bool*MS;
int id,n,m,a[N],sk[N],d[N],f[N],fa[N],*p;
bool tg[N];
struct js
{
  js*nxt;
  int v;
}e[N],*ind=e+1,*hd[N];
sd vector<int>q[N];
bool*MT;
il int _Q(int x,int y){return wrt("? ",x,' ',y,'\n'),cout.flush(),rd(x),x;}
il void add(int u,int v){return *++ind={hd[u],v},hd[u]=ind,++d[v],void();}
void Solve()
{
  rd(id,n),m=2,p=sk,tg[1]=1;
  for(int i=2;i<=n;++i) a[i]=_Q(1,i),a[i]&&(add(i,a[i]),7),tg[i]=a[i];
  for(int i=1;i<=n;++i) d[i]||(*++p=i);
  #define _v (i->v)
  for(int u;p-sk;)
  {
    u=*p--,f[m]<f[u]&&(m=u);
    for(js*i=hd[u];i;i=i->nxt) cx(f[_v],f[u]+1),--d[_v]||(*++p=_v);
  }
  #undef _v
  fa[m]=1,p=sk,*++p=m;
  for(int i=2;i<=n;++i) i^m&&(q[m].push_back(i),7);
  for(int u,x;p-sk;)
  {
    u=*p--;
    for(int v:q[u])
      if(tg[u]^tg[v]) x=_Q(v,fa[u]),x^u?q[x].push_back(v),7:(fa[v]=u,*++p=v);
      else x=_Q(v,u),fa[u]^x?q[x].push_back(v),7:(fa[v]=fa[u],*++p=v);
    sd vector<int>().swap(q[u]);
  }
  wrt("!\n");
  for(int i=2;i<=n;++i) wrt(i,' ',fa[i],'\n');
  cout.flush();
  return;
}
```

[$\color{green}{\checkmark}$](https://www.luogu.com.cn/record/115984132)。

---

## 作者：by_chance (赞：1)

[Link](https://www.luogu.com.cn/problem/P9462)

分三步解决问题。

首先，以 $1$ 为根，试图确定一条与根相邻的边。我们询问所有点与 $1$ 的中点，找到可以取中点次数最大的那个点，它所取的最后一次中点的结果一定与 $1$ 相邻。

> 证明：熟知对任何正整数 $n$，$1,2,\cdots,n$ 中 $2$ 的幂次最高的数一定是 $2$ 的方幂。能取中点的次数就是深度中 $2$ 的幂次，而是 $2$ 的方幂意味着取完中点后的深度为 $1$，即相邻。

然后来确定所有点的深度。设已知 $1$ 与 $p$ 相邻，再询问所有点与 $p$ 的中点。如果点 $x$ 与 $1$ 的中点为 $y$，则 $d_x=2d_y$；如果点 $x$ 与 $p$ 的中点为 $y$，则 $d_x=2d_y \pm 1$，其中 $x,y$ 在 $p$ 的子树内时取负号，在 $p$ 的子树外时取负号。可以写一个拓扑排序来实现。

最后确定每个点的父亲。深度为 $1$ 的点已经确定。对深度为 $k$ 的点 $u$，我们随便取一个深度为 $k-2$ 的点 $v$，不断令 $v$ 变成 $u,v$ 的中点，直到 $v$ 的深度为 $k-1$，此时 $v$ 就是 $u$ 的父亲。如果中途某次 $u,v$ 不能取中点，就让$v$ 变成 $v$ 的父亲继续找。正确性在于第一次操作后 $v$ 就一定在 $u$ 到根的路径上了。

操作次数上界是 $2n+\sum_{k=1}^{n} \lceil \log_2 k \rceil$，能过。

Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=10006;
int id,n,c[N][2],m;
int a[N],deg[N],f[N],lst[N],p;
int b[N],dep[N],g[N],fa[N],d,st;
void query(int u,int v,int&r){
    cout<<"? "<<u<<" "<<v<<endl;
    fflush(stdout);
    cin>>r;
    if(r==-1)exit(0);
}
void ans(int u,int v){c[++m][0]=u;c[m][1]=v;}
queue<int> Q;vector<int> son[N];
int main(){
    cin>>id>>n;
    for(int i=2;i<=n;i++)query(1,i,a[i]);
    for(int i=2;i<=n;i++)if(a[i])deg[a[i]]++;
    for(int i=2;i<=n;i++)if(!deg[i])Q.push(i),f[i]=0;
    while(!Q.empty()){
        int u=Q.front(),v=a[u];Q.pop();
        --deg[v];f[v]=max(f[v],f[u]+1);
        if(!deg[v])Q.push(v);
    }f[0]=-1;
    for(int i=2;i<=n;i++)if(f[i]>f[p])p=i;dep[p]=1;
    for(int i=2;i<=n;i++)if(i!=p)query(i,p,b[i]);
    for(int i=2;i<=n;i++)if(i!=p){
        if(a[i]!=p)son[a[i]].push_back(i);
        if(b[i]!=1)son[b[i]].push_back(i);
        if(a[i]==p)dep[i]=2,Q.push(i),g[i]=1;
        if(b[i]==1)dep[i]=1,Q.push(i),g[i]=2;
    }
    while(!Q.empty()){
        int u=Q.front();d=max(d,dep[u]);Q.pop();
        for(int v:son[u]){
            g[v]=g[u];//g数组记下是否在p的子树内
            if(u==a[v])dep[v]=dep[u]*2;
            else{
                if(g[v]==1)dep[v]=2*dep[u]-1;
                else dep[v]=2*dep[u]+1;
            }
            Q.push(v);
        }
    }
    for(int i=1;i<=n;i++)if(dep[i]==1)ans(1,i),fa[i]=1;
    for(int i=2;i<=d;i++){
        for(int j=1;j<=n;j++)if(dep[j]==i-2)st=j;
        for(int u=1;u<=n;u++)if(dep[u]==i){
            int v=st,w;
            while(dep[v]!=i-1){
                query(u,v,w);
                if(w==0)v=fa[v];
                else v=w;
            }
            ans(u,v);fa[v]=u;
        }
    }
    cout<<"!"<<endl;fflush(stdout);
    for(int i=1;i<n;i++){
        cout<<c[i][0]<<" "<<c[i][1]<<endl;
        fflush(stdout);
    }
    return 0;
}
```

---


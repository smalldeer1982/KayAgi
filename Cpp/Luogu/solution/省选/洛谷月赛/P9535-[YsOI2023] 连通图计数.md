# [YsOI2023] 连通图计数

## 题目背景

Ysuperman 模板测试的多项式题。

【数据删除】

## 题目描述

请问有多少个 $n$ 个点 $m$ 条边的**无向简单连通**图，无自环无重边，满足删掉编号为 $i$ 的点后无向图被分成了 $a_i$ 个连通块。特殊地，我们保证 $n-1\le m\le n+1$，且答案不为 $0$。

答案对 $998,244,353$ 取模。

## 说明/提示

#### 样例 1 解释

共有三种可能的图，连的四条边分别为：

1. $(1,2),(1,3),(1,4),(2,3)$。
2. $(1,2),(1,3),(1,4),(2,4)$。
3. $(1,2),(1,3),(1,4),(3,4)$。

#### 数据范围

|测试点编号|$n,m$|特殊性质|
|:-:|:-:|:-:|
|$1\sim 4$|$m=n-1$|无|
|$5\sim 6$|$m=n$，$n\le 7$|无|
|$7\sim 8$|$m=n$|$a_i=1$|
|$9\sim 12$|$m=n$|无|
|$13\sim 14$|$m=n+1$，$n\le 7$|无|
|$15\sim 16$|$m=n+1$|$a_i=1$|
|$17\sim 20$|$m=n+1$|无|

对于所有的数据，满足 $4\le n\le 10^5$，$n-1\le m\le n+1$，$1\le a_i<n$，$n\le \sum_{i=1}^na_i\le 2n-2$，且保证答案非 $0$。

## 样例 #1

### 输入

```
4 4
2 1 1 1```

### 输出

```
3```

## 样例 #2

### 输入

```
4 5
1 1 1 1```

### 输出

```
6```

## 样例 #3

### 输入

```
5 6
1 1 2 1 1```

### 输出

```
27```

## 样例 #4

### 输入

```
6 6
1 2 3 1 1 1```

### 输出

```
30```

## 样例 #5

### 输入

```
6 5
2 1 1 1 1 4```

### 输出

```
4```

## 样例 #6

### 输入

```
8 7
1 1 3 1 2 2 2 2```

### 输出

```
360```

## 样例 #7

### 输入

```
8 8
1 1 1 1 2 2 2 2```

### 输出

```
2520```

## 样例 #8

### 输入

```
8 9
1 1 1 1 1 1 2 3```

### 输出

```
9240```

## 样例 #9

### 输入

```
10 11
1 1 1 4 2 2 2 1 1 1```

### 输出

```
105840```

## 样例 #10

### 输入

```
12 13
1 1 1 1 1 1 1 1 1 1 1 1```

### 输出

```
518269694
```

# 题解

## 作者：xiaolilsq (赞：12)

考虑 $m=n-1$ 的时候，唯一可能的无向连通图就是一棵树，同样删掉 $i$ 之后的连通块数量恰好就是 $i$ 的度数，所以给出的 $a_i$ 也就是 $i$ 的度数，用 Prüfer 序列可知答案就是 $\binom{n-2}{a_1-1,a_2-1,\dots,a_n-1}$。

考虑 $m>n-1$ 的时候，将无向连通图建成圆方树，那么容易发现 $a_i$ 表示的就是 $i$ 这个圆点连接的方点数量。

当 $m=n$ 的时候，只有恰好一个方点连接的圆点数量超过 $2$，并且它连接的圆点数量我们是可以计算出来的，恰好为 $2n-\sum a_i$，所以我们把这个方点加入再使用 Prüfer 序列求对应的树的数量，然后再乘以 $(2n-\sum a_i-1)!/2$ 作为环上排列的顺序。

当 $m=n+1$ 的时候，有两种情况，一种情况是只有一个方点连接的圆点数量超过 $2$，另一种情况是有两个这样的方点。如果只有一个方点，同样这个方点连接的圆点数量恰好是 $2n-\sum a_i$，使用上面相同的方法求出树的数量，然后再乘以 $2n-\sum a_i$ 个点 $2n-\sum a_i+1$ 条边的点双数量；如果有两个方点，则这两个方点的度数之和为固定的，那么就枚举其中一个方点的度数，增加两个方点求一下对应的树的数量，不过需要注意两个方点不能直接连接，这种情况需要减去，并且最后还需要记得除以 $2$，因为两个方点本质相同。

考虑如何求 $n$ 个点 $n+1$ 条边的点双数量，注意到这样的点双中应该恰好有两个点度数为 $3$，其余点度数都为 $2$，那么实际上就是两个点由三条没有标号的链连接起来，并且这三条链没有顺序，且最多只有一条链长度为 $0$。于是我们得到这样的点双数量为 $\binom{n}{2}\frac{(n-2)!(\binom{n}{2}-3)}{3!}$。

---

## 作者：under_the_time (赞：4)

## 题意

> 求：在所有 $n$ 个点 $m$ 条边的无向简单连通图中，满足把第 $i$ 个点删去后图被分为 $a_i$​ 个连通块。
>
> $n-1\le m\le n+1$。

## 思路

将 $m=n-1,m=n,m=n+1$​ 三种情况进行分类讨论。

对于 $m=n-1$，显然是一棵树，每个 $a_i$ 即为 $i$ 的子树数量+父亲。此时需要用到 **Prufer 序列**（可以看看[这篇博客](https://blog.csdn.net/Berserker____/article/details/115573583)），答案为：$n$ 个点的完全生成树中第 $i$ 个节点的度数为 $a_i$ 的方案数，即为：
$$
\cfrac{(n-2)!}{\prod^n_{i=1}(a_i-1)!}
$$
当 $m=n$ 时，相当于在树上加上一条边形成一个环。我们把环上的边都删除，开一个编号为 $n+1$ 的新点与环上的点连边。这样原图就又转化成了一棵 $n+1$ 个点 $n$ 条边的树，而第 $n+1$​ 个点的度数为环上点的个数。举个例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/etfgn5rs.png)

- 这是一张 $6$ 个点 $6$ 条边的图，其中红色数组代表 $a_i$ 的值。而环的大小为 $4$

可以发现：环的大小就是点数乘二再减去度数之和，即 
$$
a_{n+1}=2n-\sum^n_{i=1}a_i
$$
根据上一种情况，再乘上环上点的排列方案 $\cfrac{A^{a_{n+1}}_{a_{n+1}}}{2a_{n+1}}=\cfrac{\big(2n-(\sum^n_{i=1}a_i\big)-1)!}{2}$，答案即为
$$
\begin{aligned}&~~~~~\cfrac{(n-1)!}{\big(\prod^n_{i=1}(a_i-1)!\big)(2n-\big(\sum^n_{i=1}a_i)-1\big)!}\times\cfrac{(2n-(\sum^n_{i=1}a_i)-1)!}{2}\\&=\cfrac{(n-1)!}{2\prod^n_{i=1}(a_i-1)!}\end{aligned}
$$
当 $m=n+1$ 时，相当于在上一种情况再多加一个环。进行分类讨论：

- 两个环无公共边

此时我们可以将两个环分别缩成 $n+1,n+2$ 两个点，仿照 $m=n$ 进行连边，最终会得到 $n+2$ 个点 $n+1$​ 条边的树。再举个例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/d0t413zl.png)

- 这是一张 $9$ 个点 $10$ 条边的图，左环大小为 $5$，右环大小为 $4$。

区别在于，此时只能算出两个环的大小之和，答案类似，即
$$
a_{n+1}+a_{n+2}=2n-\sum^n_{i=1}a_i+2
$$
我们设 $2n-\sum^n_{i=1}a_i=sum$。两点的度数都至少为 $3$（否则不成环），我们枚举 $a_{n+1}$ 为 $j$，则 $a_{n+2}=sum+2-j$。仿照 $m=n-1$ 的求法，此时树的数量为
$$
\cfrac{(n+2-2)!}{\prod^{n+2}_{i=1}(a_i-1)!}=\cfrac{n!}{\big(\prod^n_{i=1}(a_i-1)!\big)(j-1)!(sum-j+1)!}
$$
但我们需要保证 $n+1$ 与 $n+2$ 在树中无连边（即两个环没有公共点，否则就变成一个环了）。对于有连边的情况，我们按照 $m=n$ 建出 $n+1$ 个点 $n$ 条边的树来，则这棵树的 $a_{n+1}=sum$，树的数量即为
$$
\cfrac{(n-1)!}{\big(\prod^n_{i=1}(a_i-1)!\big)\big(2n-(\sum^n_{i=1}a_i)-1\big)!}=\cfrac{(n-1)!}{\big(\prod^n_{i=1}(a_i-1)!\big)(sum-1)!}
$$
而这样的树每个都有 $C^{j-1}_{sum}=\cfrac{sum!}{(sum-j+1)!(j-1)!}$​ 种，则所有不合法的树的数量为
$$
\cfrac{(n-1)!}{\big(\prod^n_{i=1}(a_i-1)!\big)(sum-1)!}\times\cfrac{sum!}{(sum-j+1)!(j-1)!}
$$
化简得
$$
\cfrac{(n-1)!sum}{\big(\prod^n_{i=1}(a_i-1)!\big)(j-1)!(sum-j+1)!}
$$
使用容斥，所有合法的树的数量等于所有减去不合法，即为
$$
\cfrac{(n-1)!(n-sum)}{\big(\prod^n_{i=1}(a_i-1)!\big)(j-1)!(sum-j+1)!}
$$
同理，还要算上两个环的排列方案共 $\cfrac{(j-1)!(sum-j+1)!}{4}$，则答案为
$$
\cfrac{(n-1)!(n-sum)}{\big(\prod^n_{i=1}(a_i-1)!\big)(j-1)!(sum-j+1)!}\times\cfrac{(j-1)!(sum-j+1)!}{4}
$$
化简得
$$
\cfrac{(n-1)!(n-sum)}{4\prod^{n}_{i=1}(a_i-1)!}
$$
最终我们发现对于不同的 $j$ 最终答案相同，一共枚举了 $sum+2-3-3+1=sum-3$ 次，考虑到两个环位置可以调换但属同一种情况，所以答案要除以二，即为
$$
\cfrac{(n-1)!(n-sum)(sum-3)}{8\prod^{n}_{i=1}(a_i-1)!}
$$

- 两个环有公共边

将这两个挨在一起的环看作一个点，构造一个与 $m=n$ 时的树，树的数量也相同。现在考虑这挨在一起的两个环的方案。我们可以将这两个环拆成类似韦恩图的样子，分为左边环独有部分、左右环公用部分、右边环都有部分三条链。因为要有公共边，所以有两条及以上的链中边数不大于 $1$ 显然不合法。而这三条链头尾都是相同的。

因为环挨在一起，所以这两个环上节点一共有 $sum=2n-\sum^n_{i=1}a_i$ 个点。我们先从 $sum$ 中挑两个点出来，之后的每个点都选择两个位置放在中间，不合法数量（即之后的所有点全都放在一条链上）即为 $3(sum-2)!$​；而放入点的顺序并不影响最终答案。故答案为
$$
\begin{aligned}\cfrac{sum(sum-1)}{2}\times\cfrac{\frac{sum!}{2}-3(sum-2)!}{3!}&=\cfrac{sum!}{24}(sum(sum-1)-6)\\&=\cfrac{sum!}{24}(sum+2)(sum-3)\end{aligned}
$$
再乘上树的数量，答案为
$$
\cfrac{sum(sum+2)(sum-3)(n-1)!}{24\prod^n_{i=1}(a_i-1)!}
$$
两种情况分别计算，最后相加即可。复杂度 $O(n)$。

## 实现

预处理出阶乘，逆元用快速幂计算，三种情况分别处理即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int maxn = 1e6 + 5;
const int P = 998244353;
int n,m; ll a[maxn]; ll pro[maxn];
ll inv(ll x) {
    int y = P - 2; ll res = 1;
    while (y) {
        if (y & 1) res = (res * x) % P;
        x = (x * x) % P, y >>= 1;
    }
    return res;
}
int main() {
    pro[0] = pro[1] = 1;
    for (ll i = 2;i <= maxn - 5;i ++) 
        pro[i] = (pro[i - 1] * i) % P;
    scanf("%d%d",&n,&m);
    if (m == n - 1) { // 1
        ll tmp = 1;
        for (int i = 1;i <= n;i ++)
            scanf("%lld",&a[i]),
            tmp = (tmp * pro[a[i] - 1]) % P;
        printf("%lld",pro[n - 2] * inv(tmp) % P);
    } else if (m == n) { // 2
        ll tmp = 2;
        for (int i = 1;i <= n;i ++)
            scanf("%lld",&a[i]),
            tmp = (tmp * pro[a[i] - 1]) % P;
        printf("%lld",pro[n - 1] * inv(tmp) % P);
    } else { // 3
        ll sum = n * 2 % P, tmp = 1;
        for (int i = 1;i <= n;i ++)
            scanf("%lld",&a[i]),
            sum -= a[i], tmp = (tmp * pro[a[i] - 1]) % P;
        ll ans1 = ((pro[n - 1] * (n - sum) % P) * (sum - 3) % P) * inv(tmp * 8 % P) % P;
        ll ans2 = ((((pro[n - 1] * (sum + 2) % P) * (sum - 3) % P) * sum) % P) * inv(tmp * 24 % P) % P;
        printf("%lld",(ans1 + ans2) % P);
    }
    return 0;
}
```

---

## 作者：D2T1 (赞：2)

## YsOI2023 - 连通图计数

> 引理：一个 $n$ 个节点，每个节点度数分别为 $d_1,d_2,...,d_n$ 的有标号无根树的个数为 $\dfrac{(n-2)!}{\prod(d_i-1)!}$。

根据 prufer 数列，数列中 $i$ 的出现个数即为 $d_i-1$，根据可重集计数易证引理成立。

记 $A=\prod(a_i-1)!$。

### Sub 1. $m=n-1$

此时构成一棵树，$d_i=a_i$。根据引理得 $ans=\dfrac{(n-2)!}{A}$。

### Sub 2. $m=n$

此时构成一棵基环树，对于环上点 $d_i=a_i+1$，对于非环上点 $d_i=a_i$。将环边全部断开，环上点与一个新的点 $n+1$ 连边，设这个点为方点（类似于圆方树），则这棵树的 $a$ 和原树一样。方点度数即为环上点数 $sum=2n-\sum a_i$。注意到新树中与方点连边的点无序，而原树中环上点有序，所以答案需乘上 $\dfrac{(sum-1)!}2$。

$$ans=\dfrac{(n-1)!}{A(sum-1)!}*\dfrac{(sum-1)!}2=\dfrac{(n-1)!}{2A}$$

### Sub 3. $m=n+1$

此时分两种情况：两个环有共边、两个环无共边。设 $sum=2n-\sum a_i$。

### Sub 3A. 有共边

设这两个环交集为路径 $x\to y$。则 $d_x=a_x+2,d_y=a_y+2$，环上其他点 $i$ 有 $d_i=a_i+1$；非环上的点 $j$ 有 $d_j=a_j$。

所以环上点数仍然为 $sum=2n-\sum a_i$。

考虑先枚举 $x,y$，再枚举连接它们的三条链（合法当且仅当至多一条链点数为 $2$）。所以方案数为 $\dbinom {sum}2\dfrac{(sum-2)![\dbinom {sum}2-3]}{3!}=\dfrac{sum!(sum+2)(sum-3)}{24}$。

将两个环缩成一个方点，其它部分答案依旧为 $\dfrac{(n-1)!}{A(sum-1)!}$。二者乘起来得：

$$ans=\dfrac{(n-1)!sum(sum+2)(sum-3)}{24A}$$

### Sub 3B. 无共边

此时两个环上点 $i$ 有 $d_i=a_i+1$，否则有 $d_i=a_i$。两个环上共 $sum+2$ 个点。

枚举一个环上点数 $j(j\geq 3, sum+2-j\geq 3)$。将两个环分别设为两个方点，有方案数为 $\dfrac{n!}{A(j-1)!(sum-j+1)!}$。

但是此时两个方点之间可能有连边，需要把这种情况减掉。

有连边，就相当于构成了一个大小为 $sum$ 的环，方案数为 $\dfrac{(n-1)!}{A(sum-1)!}$。而每个点可以选择连哪个方点，答案要乘上 $\dbinom{sum}{j-1}$。

二者相减，得 $\dfrac{(n-1)!(n-sum)}{A(j-1)!(sum-j+1)!}$。

同样要乘上环排列，得 $\dfrac{(n-1)!(n-sum)}{4A}$。

对于每个 $j$ 有这么多情况，而总共有 $j\in[3,sum+2-3]$ 共 $sum-3$ 个 $j$，乘上 $sum-3$ 即可。又 $j,sum+2-j$ 属于同一种情况，答案需除以 $2$。

$$ans=\dfrac{(n-1)!(n-sum)(sum-3)}{8A}$$

---

## 作者：Cx114514 (赞：1)

### 题目链接：[[YsOI2023] 连通图计数](https://www.luogu.com.cn/problem/P9535)

萌萌 Prufer 序列计数题。

首先考虑 $m=n-1$ 的情况。此时，该图就是一颗树。而 $a_i$ 就代表着每个结点的度数。因此，每个结点在该树的 Prufer 序列中会出现 $a_i-1$ 次，而该树的 Prufer 序列长度为 $n-2$。因此可以看作每次在剩余的位置中选 $a_i-1$ 个位置。

答案为：


$$\prod\limits_{i=1}^{n}\binom{n - 2 - \sum\limits_{j=1}^{i-1}\left(a_j-1\right)}{a_i-1}$$ 

化简得：

$$\frac{\left(n-2\right)!}{\prod\limits_{i=1}^{n}\left(a_i-1\right)!}$$

接下来考虑 $m=n$ 的情况。此时，在原有基础上，会多出来一个环。但是，当我们把环上的结点删去时，连接该结点的两条环上的边并不会被分割成两个不同的连通块。所以，对于环上的点，其实际度数为 $a_i+1$。因此，环上的点的数量为 $2n-\sum\limits_{i=1}^{n}a_i$。

因此，我们可以把原图上的环删去，并引入一个新的结点与原本环上所有结点相连。这样，我们便可以把原图转化为一个树。因为环上的排列顺序有不同，所以一棵树可以对应 $\frac{\left(2n-1-\sum\limits_{i=1}^{n}a_i\right)!}{2}$ 种原图。

这样一棵树的 Prufer 序列长度为 $n-1$，同上可得，答案为：

$$\frac{\left(n-1\right)!}{\left(2n-1-\sum\limits_{i=1}^{n}a_i\right)!\prod\limits_{i=1}^{n}\left(a_i-1\right)!}\times \frac{\left(2n-1-\sum\limits_{i=1}^{n}a_i\right)!}{2}$$

化简得：

$$\frac{\left(n-1\right)!}{2\prod\limits_{i=1}^{n}\left(a_i-1\right)!}$$

最后考虑 $m=n+1$ 的情况。这种情况下，图中会出现两个环。接下来分情况考虑：

当两个环有共边时，不难发现这就是一个点双连通分量。仅考虑环中的点和边，会存在两个度数为 $3$ 的点，因此两个环上共有 $2n-\sum\limits_{i=1}^{n}a_i$ 个点。按照上述方法，新建一个结点，并与环上的点连边，会形成一个树结构。同上，这样的树共有 $\frac{\left(n-1\right)!}{\left(2n-1-\sum\limits_{i=1}^{n}a_i\right)!\prod\limits_{i=1}^{n}\left(a_i-1\right)!}$ 棵。

接下来我们考虑 $2n-\sum\limits_{i=1}^{n}a_i$ 个点与 $2n+1-\sum\limits_{i=1}^{n}a_i$ 条边会形成多少个点双连通分量。我们可以看作两个结点之间连着三条互不相交的链，并且最多有一条链上只有一条边。首先，我们选择两个点，这样的方案数为 $\binom{2n-\sum\limits_{i=1}^{n}a_i}{2}$。接着，我们可以看作把剩下 $2n-2-\sum\limits_{i=1}^{n}a_i$ 个点的排列切成三段，分别放进三条链中。这样共有 $\frac{\left(2n-2-\sum\limits_{i=1}^{n}a_i\right)!\left(\binom{2n-\sum\limits_{i=1}^{n}a_i}{2}-3\right)}{3!}$ 种方案。

结果为：

$$\frac{\left(n-1\right)!}{\left(2n-1-\sum\limits_{i=1}^{n}a_i\right)!\prod\limits_{i=1}^{n}\left(a_i-1\right)!}\times \frac{\binom{2n-\sum\limits_{i=1}^{n}a_i}{2}\left(2n-2-\sum\limits_{i=1}^{n}a_i\right)!\left(\binom{2n-\sum\limits_{i=1}^{n}a_i}{2}-3\right)}{3!}$$

展开得：

$$\frac{\left(n-1\right)!}{\left(2n-1-\sum\limits_{i=1}^{n}a_i\right)!\prod\limits_{i=1}^{n}\left(a_i-1\right)!}\times \frac{\left(2n-\sum\limits_{i=1}^{n}a_i\right)\left(2n-1-\sum\limits_{i=1}^{n}a_i\right)\left(2n-2-\sum\limits_{i=1}^{n}a_i\right)!\left(\frac{\left(2n-\sum\limits_{i=1}^{n}a_i\right)\left(2n-1-\sum\limits_{i=1}^{n}a_i\right)}{2}-3\right)}{12}$$

约分得：

$$\frac{\left(n-1\right)!}{\prod\limits_{i=1}^{n}\left(a_i-1\right)!}\times \frac{\left(2n-\sum\limits_{i=1}^{n}a_i\right)\left(\left(2n-\sum\limits_{i=1}^{n}a_i\right)\left(2n-1-\sum\limits_{i=1}^{n}a_i\right)-6\right)}{24}$$

化简得：

$$\frac{\left(n-1\right)!\left(2n-\sum\limits_{i=1}^{n}a_i\right)\left(2n+2-\sum\limits_{i=1}^{n}a_i\right)\left(2n-3-\sum\limits_{i=1}^{n}a_i\right)}{24\prod\limits_{i=1}^{n}\left(a_i-1\right)!}$$

当两个环无共边时，可以新增两个新结点，分别和两个环上的点连边。这个时候我们可以得知两个环结点总数为 $2n+2-\sum\limits_{i=1}^{n}a_i$。

设一个环的大小为 $k$，则另一个环的大小为 $2n+2-k-\sum\limits_{i=1}^{n}a_i$。则树的形态有 $\frac{n!}{\left(k-1\right)!\left(2n+1-k-\sum\limits_{i=1}^{n}a_i\right)!\prod\limits_{i=1}^{n}\left(a_i-1\right)!}$ 种。但是要注意，在只考虑度数要求的情况下，可能会出现两个新结点连在一起的情况。因此我们要把这种情况删去。

如果这两个结点连在一起，其实就可以看作是一个结点，其度数为 $2n-\sum\limits_{i=1}^{n}a_i$。所以这样的树有 $\frac{\left(n-1\right)!}{\left(2n-1-\sum\limits_{i=1}^{n}a_i\right)!\prod\limits_{i=1}^{n}\left(a_i-1\right)!}$ 种。但因为原本有两个结点，所以实际每一种树还可以对应 $\binom{2n-\sum\limits_{i=1}^{n}a_i}{k-1}$ 种形态。

两式相乘可得：

$$\frac{\left(n-1\right)!}{\left(2n-1-\sum\limits_{i=1}^{n}a_i\right)!\prod\limits_{i=1}^{n}\left(a_i-1\right)!}\times \binom{2n-\sum\limits_{i=1}^{n}a_i}{k-1}$$

展开可得：

$$\frac{\left(n-1\right)!}{\left(2n-1-\sum\limits_{i=1}^{n}a_i\right)!\prod\limits_{i=1}^{n}\left(a_i-1\right)!}\times \frac{\left(2n-\sum\limits_{i=1}^{n}a_i\right)!}{\left(k-1\right)!\left(2n+1-k-\sum\limits_{i=1}^{n}a_i\right)!}$$

约分得：

$$\frac{\left(n-1\right)!\left(2n-\sum\limits_{i=1}^{n}a_i\right)}{\left(k-1\right)!\left(2n+1-k-\sum\limits_{i=1}^{n}a_i\right)!\prod\limits_{i=1}^{n}\left(a_i-1\right)!}$$

最终符合条件的树的形态数为：

$$\frac{n!}{\left(k-1\right)!\left(2n+1-k-\sum\limits_{i=1}^{n}a_i\right)!\prod\limits_{i=1}^{n}\left(a_i-1\right)!}-\frac{\left(n-1\right)!\left(2n-\sum\limits_{i=1}^{n}a_i\right)}{\left(k-1\right)!\left(2n+1-k-\sum\limits_{i=1}^{n}a_i\right)!\prod\limits_{i=1}^{n}\left(a_i-1\right)!}$$

化简得：

$$\frac{\left(n-1\right)!\left(\sum\limits_{i=1}^{n}a_i-n\right)}{\left(k-1\right)!\left(2n+1-k-\sum\limits_{i=1}^{n}a_i\right)!\prod\limits_{i=1}^{n}\left(a_i-1\right)!}$$

这个时候我们会发现问题可以分成两个情况：

1. 两个新点直接连接到了同一个点。
2. 两个新点直接连接的点集交集为空。

对于第一种情况，原图上的两个环会存在一个交点，而两个环的总大小为 $2n+1-\sum\limits_{i=1}^{n}a_i$。

两个环上的排列数为：

$$\frac{\left(k-1\right)!}{2}\times \frac{\left(2n+1-k-\sum\limits_{i=1}^{n}a_i\right)!}{2}$$

对于第二种情况，两个环相对独立。

两个环上的排列数为：

$$\frac{\left(k-1\right)!}{2}\times \frac{\left(2n+1-k-\sum\limits_{i=1}^{n}a_i\right)!}{2}$$

不难发现，这两种情况其实答案是相同的，均为：

$$\frac{\left(k-1\right)!\left(2n+1-k-\sum\limits_{i=1}^{n}a_i\right)!}{4}$$

因此最终答案为：

$$\frac{\left(n-1\right)!\left(\sum\limits_{i=1}^{n}a_i-n\right)}{\left(k-1\right)!\left(2n+1-k-\sum\limits_{i=1}^{n}a_i\right)!\prod\limits_{i=1}^{n}\left(a_i-1\right)!}\times \frac{\left(k-1\right)!\left(2n+1-k-\sum\limits_{i=1}^{n}a_i\right)!}{4}$$

约分得：

$$\frac{\left(n-1\right)!\left(\sum\limits_{i=1}^{n}a_i-n\right)}{4\prod\limits_{i=1}^{n}\left(a_i-1\right)!}$$

我们可以发现，最终答案与 $k$ 无关，因此我们只要考虑 $k$ 有多少种取值。因为一个环至少有 $3$ 个点，所以 $k\in\left[3,2n-1-\sum\limits_{i=1}^{n}a_i\right]$，因此 $k$ 共有 $2n-3-\sum\limits_{i=1}^{n}a_i$ 种取值。又因为两个新点其实本质相同，所以最终答案要除以 $2$。

答案为:

 $$\frac{\left(n-1\right)!\left(\sum\limits_{i=1}^{n}a_i-n\right)\left(2n-3-\sum\limits_{i=1}^{n}a_i\right)}{8\prod\limits_{i=1}^{n}\left(a_i-1\right)!}$$ 

两种情况之和为：

$$\frac{\left(n-1\right)!\left(2n-\sum\limits_{i=1}^{n}a_i\right)\left(2n+2-\sum\limits_{i=1}^{n}a_i\right)\left(2n-3-\sum\limits_{i=1}^{n}a_i\right)}{24\prod\limits_{i=1}^{n}\left(a_i-1\right)!}+\frac{\left(n-1\right)!\left(\sum\limits_{i=1}^{n}a_i-n\right)\left(2n-3-\sum\limits_{i=1}^{n}a_i\right)}{8\prod\limits_{i=1}^{n}\left(a_i-1\right)!}$$

推出了所有式子，直接算就行了，时间复杂度 $O\left(n\right)$。

代码:

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

int read()
{
	int f = 1;
	char c = getchar();
	while (!isdigit(c))
	{
	    if (c == '-') f = -1;
	    c = getchar();
    }
	int x = 0;
	while (isdigit(c))
	{
		x = x * 10 + c - '0';
		c = getchar();
	}
	return x * f;
}

int buf[15];

void write(int x)
{
	int p = 0;
	if (x < 0)
	{
	    putchar('-');
	    x = -x;
	}
	if (x == 0) putchar('0');
	else
	{
		while (x)
		{
			buf[++p] = x % 10;
			x /= 10;
		}
		for (int i = p; i >= 1; i--)
			putchar('0' + buf[i]);
	}
}

const int mod = 998244353;

int n, m, tot, ans = 1, a[100005], fac[100005];

int Qpow(int t, int p)
{
	int Ans = 1;
	while (p)
	{
		if (p & 1) Ans = Ans * t % mod;
		t = t * t % mod;
		p /= 2;
	}
	return Ans;
}

signed main()
{
	n = read(), m = read();
	fac[0] = 1;
	for (int i = 1; i <= n; i++)
		fac[i] = fac[i - 1] * i % mod;
	for (int i = 1; i <= n; i++)
		a[i] = read();
	if (m == n - 1)
	{
		for (int i = 1; i <= n; i++)
			ans = ans * fac[a[i] - 1] % mod;
		ans = fac[n - 2] * Qpow(ans, mod - 2) % mod;
		write(ans);
		putchar('\n');
	}
	else if (m == n)
	{
		for (int i = 1; i <= n; i++)
			ans = ans * fac[a[i] - 1] % mod;
		ans = ans * 2 % mod;
		ans = fac[n - 1] * Qpow(ans, mod - 2) % mod;
		write(ans);
		putchar('\n');
	}
	else
	{
		int tmp = 2 * n;
		for (int i = 1; i <= n; i++)
			tmp -= a[i];
		tot = fac[n - 1] * tmp % mod;
		tot = tot * (tmp + 2) % mod;
		tot = tot * (tmp - 3) % mod;
		tmp = 24;
		for (int i = 1; i <= n; i++)
			tmp = tmp * fac[a[i] - 1] % mod;
		ans = tot * Qpow(tmp, mod - 2) % mod;
		tmp = 2 * n;
		for (int i = 1; i <= n; i++)
			tmp -= a[i];
		tot = fac[n - 1] * (tmp - 3) % mod;
		tot = tot * (n - tmp) % mod;
		tmp = 8;
		for (int i = 1; i <= n; i++)
			tmp = tmp * fac[a[i] - 1] % mod;
		ans = (ans + tot * Qpow(tmp, mod - 2)) % mod;
		write(ans);
		putchar('\n');
	}
	return 0;
}
```

---


# 『GROI-R2』 记忆碎片

## 题目描述

记忆的碎片散落在各个角落，而爱丽丝想把它们拼合在一起。

碎片的顺序是给定的，因为记忆显然不能反过来进行。但是，碎片各自的形状和内容是可以打磨和修正的——毕竟所有人的记忆都会歪曲和遗忘。

每个碎片上的记忆都可以用一个**非负整数**来表示。而相邻的两个碎片能够完整地拼合起来，当且仅当它们记忆的和是一个**完全平方数**。

现在，爱丽丝可以打磨若干块碎片，使得每一对相邻的碎片都能够完整地拼合起来。对于每一次打磨，爱丽丝可以选择一块碎片，将这块碎片上的记忆修改为任意一个**非负整数**。爱丽丝想知道，她至少要打磨多少块碎片，才能实现她的目标。同时，她还希望你给出打磨之后，每块碎片上留有的记忆是多少。

**形式化题面**

给定一个**非负整数**序列 $\{a_n\}$，我们定义一次操作是任意选择一个 $i\in [1,n]$ 并将 $a_i$ 改为任意一个**非负整数** $x$。

问至少进行几次操作才可以满足 $\forall i\in [1,n-1]$ 有 $a_i+a_{i+1}$ 为**完全平方数**，并给出修改方案。

## 说明/提示

**样例解释**

对于第一组样例，不难证明爱丽丝至少要打磨一块碎片才能使所有的记忆满足条件。

请一定注意记忆碎片的顺序是不能改变的。

**评分规则**

如果你对于某一测试点输出的最少打磨次数是正确的，你将获得该测试点 $30\%$ 的分数。

如果你在最少打磨次数正确的基础上给出了正确的构造，你将获得该测试点 $100\%$ 的分数。

如果你只会求解最少打磨次数，那也请你在第二行输出以空格隔开的 $n$ 个在 $[0,10^{18}]$ 范围内的整数，否则可能被判为 $0$ 分。

请注意，你在每个 subtask 中得到的 $30\%$ 分数会被下取整计算。

**数据范围**

**本题采用捆绑测试**。

| $\text{Subtask}$ | $n\le$ | $a_i\le$ | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $2$ | $10^8$ |  | $5$ |
| $2$ | $3$ | $10^8$ |  | $20$ |
| $3$ | $4$ | $10^8$ |  | $15$ |
| $4$ | $10^3$ | $10^8$ |  | $15$ |
| $5$ | $10^6$ | $10^4$ |  | $10$ |
| $6$ | $10^6$ | $10^8$ | $\text{A}$ | $10$ |
| $7$ | $10^6$ | $10^8$ |  | $25$ |

特殊性质 $\text{A}$：$\forall 1\le i,j\le n$ 满足 $a_i=a_j$。

对于 $100\%$ 的数据满足 $1\le n\le 10^6$，$0\le a_i\le 10^8$。

## 样例 #1

### 输入

```
4
1 3 5 8```

### 输出

```
1
1 3 1 8```

## 样例 #2

### 输入

```
3
3 4 5```

### 输出

```
1
0 4 5```

# 题解

## 作者：迟暮天复明 (赞：22)

简要题意：给定一个数列，询问最少将数列中多少个数字修改为另一个非负整数，才能使得数列中任意相邻两个数之和都是完全平方数。

## 算法零
保证 $n=2$。

那么如果两个数之和是完全平方数，那么不用修改。否则任意修改一个数即可。显然可以满足条件。

期望得分 $5$ 分。

## 算法一
保证 $n=3$。

首先如果 $a_1+a_2$ 是完全平方数或者 $a_2+a_3$ 是完全平方数的话，修改另一个数即可。

接下来分析 $a_1+a_2$ 和 $a_2+a_3$ 均不是完全平方数的情况。

明显的，答案不会超过 $2$。任意修改两个数显然是成立的。

所以我们关注的重点是在何时答案为 $1$。

同时我们可以发现，如果答案为 $1$ 的话，我们要修改的数一定是 $a_2$。因为如果修改 $a_1$ 或者 $a_3$，一定不能满足条件。

那么问题就转化成了给定两个数 $a,b$，判断是否存在非负整数 $c$ 使得 $a+c$ 和 $b+c$ 均是完全平方数。

首先，在 $a=b$ 时明显存在。运用算法零即可。

在 $a\neq b$ 时，我们不妨设 $a<b$。令 $d=b-a,a+c=x^2,b+c=y^2$，则显然 $y^2 - x^2 = d$。令 $u=x+y,v=y-x$，则相当于找出 $u\times v = d$，满足 $u,v$ 的奇偶性相同。

为了使得 $c$ 能是非负数，我们希望 $x$ 和 $y$ 尽可能大。根据 $x=\frac{u-v}2,y=\frac{u+v}2$，显然 $u$ 越大越有可能满足要求。所以对 $d$ 进行分类：

+ 如果 $d\bmod2=1$，取 $u=d,v=1$ 最优。

+ 如果 $d\bmod4=0$，取 $u=\frac {d}2,v=2$ 最优。

+ 如果 $d\bmod4=2$，无解。

最后我们将得到的 $u$ 和 $v$ 代入最初的式子计算出 $c$。如果 $d\bmod2=1$，计算得到 $c=(\frac{b-a+1}{2})^2-b$。如果 $d\bmod 4=0$，计算得到 $c=(\frac{b-a+4}{4})^2-b$。如果得到的 $c\geq 0$，那么把 $a_2$ 修改为 $c$ 即可。否则，答案不可能为 $1$，任意选择两个数进行修改即可。

期望得分 $30$ 分。

## 算法二

保证 $n=4$。

如果四个数中存在相邻两个数之和是完全平方数，那么只需要按照算法零或者算法一进行处理即可。

接下来分析四个数中不存在相邻两个数之和是完全平方数的情况。

首先答案不会超过 $3$。只需要固定 $a_1$ 然后运用三次算法零即可。

接下来考察答案是否可能为 $2$。

但是你会发现这样需要讨论好几种修改情况。能不能有一种通用的修改方式呢？

能。

接下来我们来证明：给定四个数 $p,q,r,s$，一定存在只修改 $q,r$ 且使得四个数形成的数组满足条件的修改方式。

我们深入剖析一下这个修改方式。不难发现，修改 $q,r$ 可以被看作是先构造出一个满足 $p+q$ 是完全平方数且按照算法一能得到 $r$ 的一组 $q,s$，再按照算法一算出 $r$ 的过程。不难发现，我们要证明的就是这样的 $q$ 存在。

首先，我们知道两个数之和是完全平方数，一定满足它们的和对 $4$ 取余的结果是 $0$ 或者 $1$。就是说，一定存在 $q$ 使得 $p+q$ 是完全平方数，且 $|q-s| \bmod 4 \neq 2$。

接下来我们只需要保证计算出来的 $r$ 非负即可。那么我们把算法一中算出的 $c>0$ 进行基本的不等式变形，可以得到 $q<s$ 时有  $q<s+1-2\sqrt s$ 或者  $q<s+4-4\sqrt s$ （由余数确定），而 $q>s$ 时有 $q>s-1+2\sqrt s$ 或者 $q>s-4+4\sqrt s$。

那我们设 $a$ 是满足 $a+p$ 是完全平方数且 $a\geq 0$ 的最小整数，设 $b$ 是满足 $b+p$ 是完全平方数且 $b\le 10^8$（虽然允许构造的大小是 $10^{18}$，但是 $r$ 是 $q^2$ 级别的且 $10^8$ 足够）的最大整数。则根据乘法公式有 $a\le 10001^2-10000^2=20001,b\ge 10^8-(14143^2-14142^2)=99971715$。那么显然 $a$ 和 $b$ 中一定存在满足上面不等式的 $q$，否则可以得到 $8\sqrt s>10^8$ 的显然错误的结论。

所以我们取 $q$ 为 $a,b$ 中满足不等式的一个即可。如果这时余数不对，那么我们可以取 $a$ 的后一个或者 $b$ 的前一个，也一定满足条件。

于是证明完毕。

当然这里的证明和构造有许多种方式，这里的证明只是其中一种。

于是使用上面的构造方式或者任意一种你喜欢的构造方式即可通过此部分分，期望得分 $45$ 分。


## 算法三

我们还需要证明一个结论：给定 $n(n\ge 4)$ 个数 $a_1,a_2,\ldots
,a_n$，那么一定存在修改 $a_2,a_3,\ldots,a_{n-1}$ 的方案。

这个结论的证明是显然的。我们可以按照算法零的方法任意修改 $a_2,a_3,\ldots,a_{n-3}$，再按照算法二的做法修改 $a_{n-2}$ 和 $a_{n-1}$。

所以我们就可以引出这个题的正解了。

我们设 $f_{i,j}$ 是修改到第 $i$ 位，当前连续修改的长度是 $j$ 的最少修改次数。由于我们有刚才的结论，$j$ 可以与 $2$ 做最小值，即令 $f_{i,2}=\min ^i_{j=2} \{f_{i,j} \}$。

接下来考虑转移。首先 $f_{i,0}$ 可以由 $f_{i-1,0},f_{i-1,1},f_{i-1,2}$ 转移而来。$f_{i,0}=f_{i-1,0}$ 的条件显然是连续两个数之和是完全平方数。$f_{i,0}=f_{i-1,1}$ 的条件显然是 $a_i$ 和 $a_{i-2}$ 可以通过算法二得到合法的 $a_{i-1}$。而根据上面的结论，$f_{i,0}=f_{i-1,2}$ 没有要求。

同时，根据 $f_{i,1}$ 和 $f_{i,2}$ 的定义可以得到 $f_{i,1}=f_{i-1,0}+1,f_{i,2}=\min\{f_{i-1,1},f_{i-1,2}\}+1$。

于是我们就解决了第一问。那么接下来问题还是如何修改。

首先我们可以倒推一遍这个 DP，得到哪些位置需要修改，哪些位置不需要修改。

显然可以发现每个需要修改的连续段是互相独立的。如果段长为 $1$ 或者 $2$，采用算法一或者算法二的构造即可。如果段长大于 $2$，我们只需要按照上面结论的证明方法类似的思路进行构造即可。

期望得分 $100$ 分。

---

## 作者：Graphcity (赞：6)

首先转化一下题意：保留最多的未修改位置使之符合条件。我们把要修改的位置称为「空位」。

- **观察：** 如果 $s_1,s_2\ (s_1,s_2\le 10^8)$ 之间有两个空位，必然存在一组符合条件的解。

  **证明**：令第一个空位与 $s_1$ 的和为 $a^2$，第二个空位与 $s_2$ 的和为 $b^2$，则需要满足 $a^2-s_1+b^2-s_2=c^2$。设 $s_1+s_2=k$，整理一下式子：$a^2+b^2-c^2=k$。

  利用平方差公式：$a^2+(b+c)(b-c)=k$。不妨钦定 $c=b+1$，有 $a^2=2b+k+1$。

  如果不考虑 $a^2\ge s_1,b^2\ge s_2$ 的限制，容易构造一组解。设 $\lim=3\times 10^4$，对 $k$ 进行分类讨论：

  - $k$ 为奇数时，$a=\lim$，$b=\dfrac{\lim^2-k-1}{2}$，容易发现 $a^2,b^2$ 均不超过 $10^{18}$ 且大于 $10^8$，显然符合要求。
  - $k$ 为偶数时，$a=\lim+1$，$b=\dfrac{(\lim+1)^2-k-1}{2}$。

- **推论：** 如果 $s_1,s_2\ (s_1,s_2\le 10^8)$ 之间的空位个数 $\ge 2$，必然存在一组符合条件的解。

  **证明：** 往 $s_1$ 的后面循环填 $10^8-s_1$ 和 $s_1$，直到剩下两个空位即可。

接下来考虑空位数量 $<2$ 的情况。没有空位的情况很好判断。只剩下空位数 $=1$ 的情况了。

不妨令 $s_1\ge s_2$。还是一样，列出方程 $a^2-s_1=b^2-s_2$，因为这个空位的值需要同时满足两个条件。类似地，$a^2-b^2=(a+b)(a-b)=s_1-s_2$。分类讨论：

- $s_1-s_2$ 为奇数时：令 $a=b+1$，那么有 $b=\dfrac{s_1-s_2-1}{2}$。
- 否则，因为 $a+b,a-b$ 同奇偶，有解仅当 $s_1-s_2$ 为 $4$ 的倍数。令 $a=b+2$，那么有 $b=\dfrac{s_1-s_2}{2}-1$。
- 注意判断 $a^2\ge s_1$ 并且 $b^2\ge s_2$。由于我们在有解判断的过程中顺便还最大化了 $a,b$，所以如果这组解不满足的话，就没有其它解能够满足了。

引理讲完了，现在就需要运用到题目上。设 $f_i$ 为区间 $[1,i]$ 中且 $i$ 被保留时，至多保留多少个数。转移则枚举上一个被保留的位置 $j$，如果 $i,j$ 之间有合法的填空方式则有 $f_i\gets f_j+1$。朴素实现是 $O(n^2)$ 的，但根据之前的观察，对于 $j<i-2$ 时仅需要统计 $\max f_j$ 即可。

时间复杂度 $O(n)$，构造只需要从转移数组倒推就行了。

```cpp
#include<bits/stdc++.h>
#define int long long
#define For(i,a,b) for(int i=(a);i<=(b);++i)
#define Rof(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
const int Maxn=1e6,inf=3e4;

inline int read()
{
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0' || ch>'9')
    {
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0' && ch<='9')
    {
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}

int n,a[Maxn+5],f[Maxn+5],g[Maxn+5],ans[Maxn+5];
unordered_map<int,int> mp;

inline int sqr(int x) {return x*x;}
inline int Get1(int s1,int s2)
{
    int k=abs(s1-s2); if(s1<s2) swap(s1,s2);
    if(k==0) return sqr(inf)-s1;
    if(k%4==1 || k%4==3) return sqr(k/2)-s2;
    else if(k%4==0) return sqr(k/4+1)-s1;
    else return -1;
}
inline int Get(int s1,int s2)
{
    int k=Get1(s1,s2);
    if(k<0) return -1; else return k;
}
inline int Find(int s1,int s2)
{
    if(mp.find(s1+s2)==mp.end()) return -1;
    else return mp[s1+s2];
}
inline void Solve(int s1,int s2,int &t1,int &t2)
{
    int k=s1+s2;
    if(k&1) t1=sqr(inf)-s1,t2=sqr((sqr(inf)-k-1)/2)-s2;
    else t1=sqr(inf+1)-s1,t2=sqr((sqr(inf+1)-k-1)/2)-s2;
}

signed main()
{
    n=read();
    For(i,1,n) a[i]=read(),ans[i]=a[i];
    For(i,0,inf) mp[i*i]=i;
    f[1]=1,f[2]=(Find(a[1],a[2])!=-1?2:1);
    for(int i=3,j=0,p=0;i<=n;++i)
    {
        if(i>=3 && f[i-3]>=j) j=f[i-3],p=i-3;
        f[i]=j+1,g[i]=p;
        if(Find(a[i-1],a[i])!=-1 && f[i-1]+1>=f[i])
            f[i]=f[i-1]+1,g[i]=i-1;
        if(Get(a[i-2],a[i])!=-1 && f[i-2]+1>=f[i])
            f[i]=f[i-2]+1,g[i]=i-2;
    }
    int all=f[n],p=n;
    if(f[n-1]>all) p=n-1,all=f[n-1];
    if(f[n-2]>all) p=n-2,all=f[n-2];
    cout<<n-all<<endl;
    if(p==n-1) ans[n]=sqr(inf)-a[n-1];
    if(p==n-2) ans[n-1]=sqr(inf)-a[n-2],ans[n]=sqr(inf)-ans[n-1];
    for(int i=p;i;i=p)
    {
        p=g[i];
        if(i==1) break;
        if(i==2)
        {
            if(Find(a[1],a[2])==-1) ans[1]=sqr(inf)-a[2];
            break;
        }
        if(p==i-1) continue;
        if(p==i-2) {ans[i-1]=Get(a[i-2],a[i]); continue;}
        For(j,p+1,i-3) ans[j]=sqr(10000)-ans[j-1];
        Solve(ans[i-3],ans[i],ans[i-2],ans[i-1]);
    }
    For(i,1,n) assert(ans[i]>=0);
    For(i,1,n) printf("%lld ",ans[i]);
    printf("\n");
    return 0;
}
```



---

## 作者：yxzy4615 (赞：2)

首先，考虑什么情况下 $x,y$ 存在 $z$ 满足 $x+z=a^2,z+y=b^2$。不妨令 $x\geq y$，记 $d=x-y$ 。

由于在模 4 意义下，完全平方数只可能余数为 0 或 1。所以 $d$ 在模4意义下只可能为 0，1，3，无解的情况便是 $d \equiv 2 \pmod 4$。

但由于 $z \geq 0$ ，所以必然有 $a^2-x\geq 0,b^2-y\geq 0$ ，那么我们需要求出最大的可能解判断是否存在正整数解。

一个显然的结论是：对于 $d \equiv 0 \pmod 4$，$a=\frac{d}{4}+1,b=\frac{d}{4}-1$ 即可。对于 $d \equiv 1 \pmod 2$，$a=\frac{d+1}{2},b=\frac{d-1}{2}$ 即可。

所以可以得出是否三个连续的可以出现”两面包夹芝士“，而且填入的数的级别是平方的。

接下来可以证明对于任意两数 $x,y$ 中存在填入 $x^{\prime},y^{\prime}$ 满足 $x+x^{\prime}=a^2,x^{\prime}+y^{\prime}=b^2,y^{\prime}+y=c^2$。

因为 $x,y\leq 10^8$，所以我们钦定 $a=2\times 10^4$ ，那么 $x^{\prime}=4\times 10^8 -x \geq 3\times 10^8$。

这时 $x^{\prime}-y\geq 2\times10^8$ ，不会出现最大可能解限制答案，那么只需满足 $x^{\prime}-y \not\equiv 2 \pmod 4$ 。

如果不满足，再钦定 $a=2\times 10^4 +1$ 即可，此时一定满足 $x^{\prime}-y \equiv 3 \pmod 4$，也就存在 $y^{\prime}$ 满足条件。

那么在选择策略上，一定不存在 5 个连续修改，因为中间的可以不改。

同时，可以证明，选 4 个连续的数可以调整为选 2 组连续 2 个，具体而言就是对于七个位置，选了 2、3、4、5，可以改成 2、3、5、6，不影响正确性与答案数。

于是就只需要考虑单击，双击和三连击即可。~~（考场上我没考虑三连击有 90）~~

那么我们可以设 $dp_i$ 表示第 $i$ 个不选且前 $i$ 个合法的情况，转移是 naive 的。只要在最后一个特殊处理选它的情况即可。

方案的还原是简单的，直接找怎么 $dp$ 的即可。时间复杂度线性。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e6+10;
int n,dp[N],pr[N];ll inf=1e16,a[N];
bool chk(ll x,ll y){
    ll k=round(sqrt(x+y));
    return k*k==(x+y);
}
ll op(ll x,ll y){
    if(x<y) swap(x,y);
    ll d=x-y;
    if(d==0) return inf-x;
    if((d&3)==2) return -1;
    if((d&3)==0){
        ll X=(d>>2)+1,Y=X-2;X*=X,Y*=Y;
        return X>=x&&Y>=y?X-x:-1; 
    }
    ll X=(d+1)>>1,Y=X-1;X*=X,Y*=Y;
    return X>=x&&Y>=y?X-x:-1;
}
ll opt(int x){ll tx=ceil(sqrt(x));return tx*tx-x;}
pair<ll,ll> op2(int x,int y){
    ll ty=20000,T=ty*ty-y,s=op(x,T);
    while(s==-1) ty++,T=ty*ty-y,s=op(x,T);
    return make_pair(s,T);
}
ll ans[N];
int main(){
    ios::sync_with_stdio(0);
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=1;i<=n;i++) dp[i]=1e9;
    dp[1]=0,dp[2]=!chk(a[1],a[2]),pr[2]=1;
    for(int i=3;i<=n;i++){
        dp[i]=dp[i-3]+2,pr[i]=i-3; //双击
        //n的特殊处理
        if(i==n&&dp[i]>dp[i-1]+1) dp[i]=dp[i-1]+1,pr[i]=i-1;
        if(i==n&&dp[i]>dp[i-2]+2) dp[i]=dp[i-2]+2,pr[i]=i-2;
        if(chk(a[i],a[i-1])&&dp[i]>dp[i-1]) dp[i]=dp[i-1],pr[i]=i-1; //不击
        if(op(a[i],a[i-2])!=-1&&dp[i]>dp[i-2]+1) dp[i]=dp[i-2]+1,pr[i]=i-2; //单击
        if(i>=4&&dp[i]>dp[i-4]+3) dp[i]=dp[i-4]+3,pr[i]=i-4; //三连击
    }
    cout<<dp[n]<<endl;
    int i=n;while(i>1){
        if(i==n){
            if(pr[i]==i-2&&dp[i]==dp[i-2]+2){
                a[i]=a[i-1],a[i]=inf-a[i-2];
                i-=2;continue;
            }
            if(pr[i]==i-1&&dp[i]==dp[i-1]+1){
                a[i]=inf-a[i-1];i--;
                continue;
            }
        }
        if(i==2&&dp[i]==1){a[i-1]=inf-a[i];i--;continue;}
        if(pr[i]==i-1){i--;continue;}
        if(pr[i]==i-2){a[i-1]=op(a[i-2],a[i]),i-=2;continue;}
        if(pr[i]==i-3){
            pair<ll,ll>tmp=op2(a[i-3],a[i]);
            a[i-2]=tmp.first,a[i-1]=tmp.second;
            i-=3;continue;
        }
        if(pr[i]==i-4){
            a[i-3]=opt(a[i-4]);
            pair<ll,ll>tmp=op2(a[i-3],a[i]);
            a[i-2]=tmp.first,a[i-1]=tmp.second;
            i-=4;continue;
        }
    }
    // for(int i=1;i<n;i++) assert(chk(a[i],a[i+1]));
    for(int i=1;i<=n;i++) cout<<a[i]<<" ";
    return 0;
}
```



 

 



---


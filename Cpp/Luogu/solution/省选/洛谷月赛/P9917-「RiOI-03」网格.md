# 「RiOI-03」网格

## 题目背景

2022 年某次集训讲课，课件中出现了一道以 MLE 真名首字母严格顺序作为输入变量的题目。MLE 就想在自己的题目里用 [vectorwyx](https://www.luogu.com.cn/user/238408) 的首字母当输入变量，于是就有了这道题。

可惜如今 [vectorwyx](https://www.luogu.com.cn/user/238408) 已经退役了，人生有梦，各自精彩。


## 题目描述

**请仔细阅读本题数据范围。**

给定一个 $n\times n$ 的正方形网格，一共有 $n$ 行，$n$ 列，初始时所有网格均为红色。有 $n$ 组询问，每次询问会把一整行或一整列的颜色全部染成红色或白色，每次询问后输出所有红色网格的周长，而且询问之间不独立。

## 说明/提示

### 样例解释

[样例图片解释](https://www.luogu.com.cn/paste/rvrhouei)

### 数据范围

对于 $100\%$ 的数据，$3\leq n \leq 10^6 $，$1<x<n$。

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|c|} \hline
\textbf{\textsf{\#}}  & \bm{{n\le}} & \textbf{\textsf{特殊性质}} & \textbf{\textsf{\#}}  & \bm{{n\le}} & \textbf{\textsf{特殊性质}}\cr\hline
1  & 5 & - & 
11  & 10^5 & - \cr\hline
2  & 100 & - & 
12  & 10^5 & - \cr\hline
3  & 100 & - & 
13  & 10^5 & - \cr\hline
4  & 2000 & \textbf{A} & 
14  & 10^5 & - \cr\hline
5  & 2000 & \textbf{B} & 
15  & 10^6 & - \cr\hline
6  & 2000 & - & 
16  & 10^6 & - \cr\hline
7  & 10^5 & \textbf{AB} & 
17  & 10^6 & - \cr\hline
8  & 10^5 & \textbf{B} & 
18  & 10^6 & - \cr\hline
9  & 10^5 & \textbf{A} & 
19  & 10^6 & - \cr\hline
10  & 10^5 & - & 
20  & 10^6 & - \cr\hline
\end{array}
$$

- 特殊性质 $\bf A$：保证 $w=0$。
- 特殊性质 $\bf B$：保证 $y=0$。

## 样例 #1

### 输入

```
5
0 0 3
0 1 2
0 1 4
1 0 2
1 1 4```

### 输出

```
28
32
36
36
32
```

# 题解

## 作者：听取MLE声一片 (赞：8)

注：本题解中提到的行列均指指定视图下的行列。

首先我们规定一下周长的贡献。我们正着看这个网格，如果一个格子是红的，而且这个格子往下一个是白色，那么就有一个周长贡献。再从侧面统计，加起来再乘二就是答案。

### 做法 1：我不会数据结构！

直接按照前面的思想模拟，时间复杂度 $O(n^3)$，期望得分 $15$。

### 做法 2：我会暴力维护时间戳！

发现修改一次最多影响三行或三列，维护每个地方修改时间戳，暴力维护，时间复杂度 $O(n^2)$，期望得分 $30$。

### 做法 3：动态二维数点

数一条边两侧分别是红色和白色的数量，分颜色记录修改时间，使用动态二维数点，时间复杂度 $O(n\log^2 n)$，期望得分 $70$。

这档部分分也是留给正解但常数太大的解法的。

### 做法 4：树状数组

不难看出正着看和侧着看是本质相同的，我们开一个结构体来减少代码难度。

很自然的想到把操作给拍到时间轴上，但是红白分别维护一个时间轴比较复杂，考虑把这两个时间轴合并。

考虑维护每次修改的时间戳，规定初始所有时间戳都为 $0$，红色的为正数，白色的为负数，其绝对值为操作时间。显然对于当前时刻的任意一整行或整列都是由最后一次修改此行或此列贡献的，所以我们只需要维护最新的即可。

修改一次只会影响相邻两行或两列的贡献。考虑记录上一次的答案，每次修改先减去原来的贡献，再修改，最后加上修改后的贡献即可。

因为上面对周长贡献的规定，所以我们得出，只有相邻两行和一列是最基础的贡献。我们简要画出这个图：

![](https://cdn.luogu.com.cn/upload/image_hosting/jhogr8gd.png)

规定只有上面的点是红的，下面的点是白的才会产生贡献。

$a,b,c$ 分别表示两行和一列的时间戳，其中 $a,b$ 是任意相邻的两行，$c$ 为任意一列，如果产生贡献则 $a,c$ 交点为红点，$b,c$ 交点为白点。

所以分情况讨论（先后指操作时间先后）：

- $a$ 是红的，$b$ 是白的，$c$ 不在 $a$ 和 $b$ 后面。

- $b$ 是白的，$c$ 是红的，$a$ 在 $b$ 和 $c$ 前面，$c$ 在 $b$ 的前面。

- $a$ 是红的，$c$ 是白的，$b$ 在 $a$ 和 $c$ 前面，$c$ 在 $a$ 的前面。

注意这里的「不在后面」使得情况统计不互相包含。 

由此我们可以得出式子：

- 如果 $a\geq 0,b<0$，那么 $-\min(a,-b)\leq c \leq \min(a,-b)$

- 如果 $b < 0,-b>|a|$，那么 $|a|< c < |b|$

- 如果 $a\geq 0,a>|b|$，那么 $-a< c < -|b|$ 

这里把 $c$ 都提出来了，方便维护。

不难看出 $a$,$b$ 是绑定的，必须放在一起维护。

修改行的时候，需要查询 $a$,$b$ 的贡献。将所有的 $c$ 塞入权值树状数组，即单点修改，区间求和。然后查询 $a$,$b$ 的范围有多少个 $c$ 满足即可。这里应用树状数组 1。

修改列的时候，需要查询 $c$ 的贡献。将所有的 $a$,$b$ 范围塞入权值树状数组，即区间加减，单点查询。然后查询 $c$ 对应多少个范围。这里应用树状数组 2。

一定注意查询后要修改。

注意修改列的时候要特判底层。

关于实现问题，推荐进行封装。

这里之所以用值域树状数组，是因为常数小而且好写，如果写平衡树查排名或线段树可能会被卡常。

综上，时间复杂度 $O(n\log n)$，期望得分 $100$。

注意开 `long long`。

顺带一提，如果令 $q$ 是操作次数，$n$ 是网格边长，则时间复杂度为 $O(q\log q)$，与 $n$ 无关。所以理论上如果把 $n,q$ 切割 $n$ 的范围可以随便开大，记录某行列的时间用 umap 即可，反正这也不是瓶颈。

AC 代码：

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<algorithm>
#include<queue>
#include<stack>
#include<vector>
#include<map>
#include<set>
#include<bitset>
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
const int N=2e6+10;
const int M=1e6+5;
struct BIT{
	int n=N-1,a[N];
	inline int lowbit(int x){
		return x&(-x);
	}
	inline void add(int x,int y){
		for(;x<=n;x+=lowbit(x))
			a[x]+=y; 
	}
	inline void update(int x,int y,int z){
		if(x>y)
			return;
		x+=M;
		y+=M;
		add(x,z);
		add(y+1,-z);
	}
	inline int sum(int x){
		x+=M;
		int res=0;
		for(;x;x-=lowbit(x))
			res+=a[x];
		return res;
	}
};
struct Tree{
	int n=N-1,a[N];
	inline int lowbit(int x){
		return x&(-x);
	}
	inline void add(int x,int y){
		x+=M;
		for(;x<=n;x+=lowbit(x))
			a[x]+=y; 
	}
	inline int sum(int x){
		int res=0;
		for(;x;x-=lowbit(x))
			res+=a[x];
		return res;
	}
	inline int query(int x,int y){
		if(x>y)
			return 0;
		x+=M;
		y+=M;
		return sum(y)-sum(x-1);
	}
};
struct point{
	int n,a[M],b[M],vis[N];
	long long ans;
	BIT t;
	Tree T;
	void build(int m){
		n=m;
		ans=n;
		memset(a,0,sizeof(a));
		memset(b,0,sizeof(b));
		T.add(0,n);
		for(int i=1;i<=n;i++)
			vis[i]=1;
	}
	inline void calc(int x,int f){
		if(b[x]>=0&&b[x+1]<0){
			ans+=f*T.query(-min(b[x],-b[x+1]),min(b[x],-b[x+1]));
			t.update(-min(b[x],-b[x+1]),min(b[x],-b[x+1]),f);
		}
		if(b[x+1]<0&&-b[x+1]>abs(b[x])){
			ans+=f*T.query(abs(b[x])+1,abs(b[x+1])-1);
			t.update(abs(b[x])+1,abs(b[x+1])-1,f);
		}
		if(b[x]>=0&&b[x]>abs(b[x+1])){
			ans+=f*T.query(-b[x]+1,-abs(b[x+1])-1);
			t.update(-b[x]+1,-abs(b[x+1])-1,f);
		}
	}
	inline void line(int x,int y){
		calc(x,-1);
		calc(x-1,-1);
		b[x]=y;
		calc(x,1);
		calc(x-1,1);
	}
	inline void row(int x,int y){
		T.add(a[x],-1);
		ans-=t.sum(a[x]);
		a[x]=y;
		T.add(a[x],1);
		if(vis[x]==1)
			ans--;
		if(y<0)
			vis[x]=0;
		else vis[x]=1;
		ans+=vis[x];
	} 
}a,b;
int main()
{
    int n=read();
    a.build(n);
    b.build(n);
    for(int k=1;k<=n;k++){
    	int w=read(),y=read(),x=read(),p=0;
    	if(w==1)
    		p=k;
    	else p=-k;
    	if(y==1){
    		a.line(x,p);
    		b.row(x,p);
		}
		else{
			a.row(x,p);
    		b.line(x,p);
		}
		printf("%lld",(a.ans+b.ans)*2);
		putchar('\n');
    }
    return 0;
}
```

---

## 作者：orz_z (赞：1)

### P9917 「RiOI-03」网格

行列染色，求红色网格周长。

矩阵是凸的，定义贡献，若 $(x,y)$ 为红色，$(x+1,y)$ 为白色，则竖直范围内有 $2$ 贡献；水平同理。

动态二维数点非常麻烦。

考虑到单行单列染色，记录行列最后染的颜色以及染色时间。

假如有相邻两行，及一列满足竖直条件。

分别记三个时间轴变量 $a,b,c$，若 $<0$ 则代表染白色，否则红色，绝对值为时间。

分类讨论按照绝对值排序。

* abc：$c>0,b<0$。
* bca：$c<0,a>0$。
* cab：$a>0,b<0$。
* cba：$a>0,b<0$。

每种情况的贡献不重，且总和即为竖直方案数。

将 $a,b$ 分为以上四类。

将 $c$ 分成 $>0$ 和 $<0$ 两类。

若插入 $a,b$，那么 $c$ 的个数可以用两个树状数组求出。

若插入 $c$，那么 $a,b$ 的个数可以用四个维护 $a,b$ 的树状数组求出。

时间复杂度可以做到 $\mathcal O(q\log q)$。

```cpp
//#pragma GCC optimize("Ofast,no-stack-protector")
//#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx")
//#pragma GCC optimize("Ofast,fast-math")
//#pragma GCC target("avx,avx2")
//#pragma GCC optimize(2)
//#pragma GCC optimize(3)
//#pragma GCC optimize("Ofast")
#include <bits/stdc++.h>
using namespace std;
// #define int long long
typedef pair<int, int> pii;
typedef vector<int> vi;
typedef double db;
#define F(i, a, b) for(int i = a; i <= (b); ++i)
#define F2(i, a, b) for(int i = a; i < (b); ++i)
#define dF(i, a, b) for(int i = a; i >= (b); --i)
template<typename T> void debug(string s, T x) {
	cerr << "[" << s << "] = [" << x << "]\n";
}
template<typename T, typename... Args> void debug(string s, T x, Args... args) {
	for (int i = 0, b = 0; i < (int)s.size(); i++) if (s[i] == '(' || s[i] == '{') b++;
	else if (s[i] == ')' || s[i] == '}') b--;
	else if (s[i] == ',' && b == 0) {
		cerr << "[" << s.substr(0, i) << "] = [" << x << "] | ";
		debug(s.substr(s.find_first_not_of(' ', i + 1)), args...);
		break;
	}
}
#ifdef ONLINE_JUDGE
#define Debug(...)
#else
#define Debug(...) debug(#__VA_ARGS__, __VA_ARGS__)
#endif
#define pb push_back
#define fi first
#define se second
#define Mry fprintf(stderr, "%.3lf MB\n", (&Med - &Mbe) / 1048576.0)
#define Try cerr << 1e3 * clock() / CLOCKS_PER_SEC << " ms\n";
typedef long long ll;
// namespace Fread {const int SIZE = 1 << 17; char buf[SIZE], *S, *T; inline char getchar() {if (S == T) {T = (S = buf) + fread(buf, 1, SIZE, stdin); if (S == T) return '\n';} return *S++;}}
// namespace Fwrite {const int SIZE = 1 << 17; char buf[SIZE], *S = buf, *T = buf + SIZE; inline void flush() {fwrite(buf, 1, S - buf, stdout), S = buf;} inline void putchar(char c) {*S++ = c;if (S == T) flush();} struct NTR {~NTR() {flush();}} ztr;}
// #ifdef ONLINE_JUDGE
// #define getchar Fread::getchar
// #define putchar Fwrite::putchar
// #endif
inline int ri() {
	int x = 0;
	bool t = 0;
	char c = getchar();
	while (c < '0' || c > '9') t |= c == '-', c = getchar();
	while (c >= '0' && c <= '9') x = (x << 3) + (x << 1) + (c ^ 48), c = getchar();
	return t ? -x : x;
}
inline void wi(int x) {
	if (x < 0) {
		putchar('-'), x = -x;
	}
	if (x > 9) wi(x / 10);
	putchar(x % 10 + 48);
}
inline void wi(int x, char s) {
	wi(x), putchar(s);
}
bool Mbe;
// mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());
const int mod = 998244353;
const int inf = 0x3f3f3f3f;
const ll infll = 0x3f3f3f3f3f3f3f3f;
const int _ = 3e6 + 50;

int n, hang[_], lie[_];

struct abc {
	struct Bit {
		int C[_];
		void upd(int x, int v) {
			for(int i = x; i <= 3 * n + 10; i += i & -i) C[i] += v;
		}
		void upd2(int l, int r, int v) {
			upd(l, v), upd(r + 1, -v);
		}
		int qry(int x) {
			int res = 0;
			for(int i = x; i; i -= i & -i) res += C[i];
			return res;
		}
	} tr1, tr2, tr3, tr4;
	/*
	tr1 acb:c>0,b<0
	tr2 bca:c<0,a>0
	tr3 cab:a>0,b<0
	tr4 cba:a>0,b<0
	*/
	struct Bit2 {
		int C[_];
		void upd(int x, int v) {
			for(int i = x; i <= n + n + n + 10; i += i & -i) C[i] += v;
		}
		int qry(int x) {
			int res = 0;
			for(int i = x; i; i -= i & -i) res += C[i];
			return res;
		}
		int qry2(int l, int r) {
			return qry(r) - qry(l - 1);
		}
	} tr5, tr6;
	// tr5 c > 0, tr6 c < 0
	ll ans;
	void updh(int a, int b, int v, bool fl) {
		int aa = abs(a), bb = abs(b);
		if(aa < bb && b < 0) {
			tr1.upd2(aa, bb, v);
			if(fl) ans += v * tr5.qry2(aa, bb);
		}
		if(a > 0 && bb < aa) {
			tr2.upd2(bb, aa, v);
			if(fl) ans += v * tr6.qry2(bb, aa);
		}
		if(a > 0 && b < 0 && aa < bb) {
			tr3.upd2(1, aa, v);
			if(fl) ans += v * (tr5.qry2(1, aa) + tr6.qry2(1, aa));
		}
		if(a > 0 && b < 0 && aa > bb) {
			tr4.upd2(1, bb, v);
			if(fl) ans += v * (tr5.qry2(1, bb) + tr6.qry2(1, bb));
		}
	}
	void updl(int c, int v, bool fl) {
		int cc = abs(c);
		if(c > 0) tr5.upd(cc, v);
		else tr6.upd(cc, v);
		if(fl) {
			if(c > 0) ans += v * tr1.qry(cc);
			if(c < 0) ans += v * tr2.qry(cc);
			ans += v * tr3.qry(cc);
			ans += v * tr4.qry(cc);
		}
	}
} A, B;

bool Med;
signed main() {
	// Mry;
	n = ri();
	// >0 red <0 white
	// x -> time
	F(i, 1, n) hang[i] = i, lie[i] = i + n;
	hang[n + 1] = -(n + n + n + 1), lie[n + 1] = -(n + n + n + 2);
	F(i, 1, n) A.updh(hang[i], hang[i + 1], 1, 0);
	F(i, 1, n) A.updl(lie[i], 1, 1);
	F(i, 1, n) B.updh(lie[i], lie[i + 1], 1, 0);
	F(i, 1, n) B.updl(hang[i], 1, 1);
//	Debug(A.ans, B.ans);
	int ti = n + n;
	int q = n;
	while(q--) {
		int w = ri(), y = ri(), x = ri();
		if(y == 1) {
			A.updh(hang[x], hang[x + 1], -1, 1);
			if(x > 1) A.updh(hang[x - 1], hang[x], -1, 1);
			
			B.updl(hang[x], -1, 1);
			
			++ti;
			if(!w) hang[x] = -ti; else hang[x] = ti;
			A.updh(hang[x], hang[x + 1], 1, 1);
			if(x > 1) A.updh(hang[x - 1], hang[x], 1, 1);
			
			B.updl(hang[x], 1, 1);
			
		} else {
			A.updl(lie[x], -1, 1);
//			Debug("uod", A.ans);
			B.updh(lie[x], lie[x + 1], -1, 1);
			if(x > 1) B.updh(lie[x - 1], lie[x], -1, 1);
			
			++ti;
			if(!w) lie[x] = -ti; else lie[x] = ti;
			A.updl(lie[x], 1, 1);
			
			B.updh(lie[x], lie[x + 1], 1, 1);
			if(x > 1) B.updh(lie[x - 1], lie[x], 1, 1);
			
		}
//		Debug(A.ans, B.ans);
		cout << 2ll * (A.ans + B.ans) << '\n';
	}
	// Try;
	return 0;
}
```



---


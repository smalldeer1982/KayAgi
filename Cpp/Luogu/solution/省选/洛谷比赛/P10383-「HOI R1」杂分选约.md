# 「HOI R1」杂分选约

## 题目背景

**请注意本题并不寻常的时间限制。**

由于 python 自带对于高精度乘法的实现，并且运行效率较高，导致其编写的暴力程序，在一般的时间限制下可以通过绝大部分点。故本题时限开到 $200\text{ms}$。
***

黄总是一名计算很强的数学老师，以黄氏约分而闻名。现在他请小 $\iiint$ A 了这道题。但小 $\iiint$ **似乎**有点菜，所以求助于你。

## 题目描述

把
$$\dfrac{\displaystyle\prod_{i=1}^n
a_i}{\displaystyle\prod_{j=1}^m b_j}$$
表示为*最简分数 $^{[1]}$* $\dfrac{p}{q}$，求 $p$ 和 $q$。

好心的同学还给了小 $\iiint$ 一个整数 $C$，即数据点所在的 Subtask。

## 说明/提示

**注释**

$[1]$：[百度百科](https://baike.baidu.com/item/%E6%9C%80%E7%AE%80%E5%88%86%E6%95%B0/2821376?fr=ge_ala)：最简分数，是分子、分母只有公因数 $1$ 的分数，或者说分子和分母互质的分数，又称既约分数。如：二分之一，三分之二，九分之八，八分之三等等。
***
**样例解释**

$\dfrac{540000\times350000\times110000\times130000\times170000\times970000}{2000\times5000\times1000\times1000\times97000\times17000\times143000\times210000}=\dfrac{9}{10}$，$\gcd(9,10)=1$
***
**数据规模与约定**

**本题采用捆绑测试。**

|Subtask|分值|数据范围|
|-|-|-|
|#0|0|同样例|
|#1|$5$|$1\le n,m\le500$，$1\le a_i,b_i\le9\times10^{18}$，$1\le p,q\le3\times10^9$|
|#2|$5$|$1\le n,m\le25000$，$1\le a_i,b_i\le9\times10^{18}$，$1\le p,q\le10$|
|#3|$10$|$1\le n,m\le5000$，$1\le a_i,b_i\le3\times10^9$，$1\le p,q\le3\times10^9$|
|#4|$15$|$1\le n,m\le10000$，$1\le a_i,b_i\le9\times10^{18}$，$1\le p,q\le3\times10^9$|
|#5|$20$|$1\le n,m\le25000$，$1\le a_i,b_i\le9\times10^{18}$，$1\le p\le3\times10^9$，$q=1$|
|#6|$10$|$1\le n,m\le25000$，$1\le a_i,b_i\le9\times10^{18}$，$1\le p\le3\times10^9$,$1\le q \le25000$|
|#7|$20$|$1\le n,m\le25000$，$1\le a_i,b_i\le9\times10^{18}$，$1\le p,q\le3\times10^9$|
|#8|$10$|$1\le n,m\le10^6$，$1\le a_i,b_i\le10^6$，$1\le p,q\le3\times10^9$|
|#9|$5$|$1\le n,m\le10^6$，$1\le a_i,b_i\le9\times10^{18}$，$1\le p,q\le3\times10^9$|
***
**提示**

~~高精度狗都不写。~~

本题时限较小且输入量较大，若你认为自己的算法复杂度正确，请尝试优化读写速度。

## 样例 #1

### 输入

```
6 8 0
540000 350000 110000 130000 170000 970000
2000 5000 1000 1000 97000 17000 143000 210000```

### 输出

```
9 10```

# 题解

## 作者：Killer_joke (赞：8)

给出一个不同于官方题解的还原模意义下的分数的方法。

参考 https://blog.csdn.net/EI_Captain/article/details/117172239 。

假设我们求得了 $\dfrac{a}{b} = q\mod M$ 而且我们知道 $a,b \leq A$ 。

那么我们有 $a=Mt+qb$ 其中 $|t| \leq A$。

我们考虑利用欧几里得过程还原这个东西。

考虑对 $M,q$ 求解 exgcd 的过程，我们实际上约减的每一步都给出一个 $a'=Mt'+qb'$ 的构造。

其中 $a'$ 逐渐减小到 $1$ ，所以我们一定可以找到一组 $a',b'$ 满足 $a'\leq A, |b'|\leq A$ 。

$b'$ 的值域就是 exgcd 值域上的最小性。

下面我们说明唯一性，首先 $a',b'$ 一定互质，假若不互质说明 $t',b'$ 也不互质，与 exgcd 能求出最大公约数矛盾。

那么假设存在一组 $c,d$ 满足 $\dfrac{c}{d}=\dfrac{a'}{b'}=q\mod M$。

作差可得 $b'c-a'd=kM$ 只要模数满足 $2A^2<M$, 这便与 $a',|b'|,c,|d'| \leq A$ 矛盾了。

因此这样的对应是唯一的且可以用欧几里得过程自然的求出。

核心代码：
```cpp
auto approx(i128 p,i128 q,i128 A){
    i128 x=q,y=p,a=1,b=0;
    while(x>A){
        std::swap(x,y); 
        std::swap(a,b);
        a-=x/y*b,x%=y;
    }
    return std::make_pair(x,a);
}
```

---

## 作者：Register_int (赞：5)

记 $n+m$ 为 $s$，$a_i$ 和 $b_i$ 的值域为 $v$，$p$ 的值域为 $P$，$q$ 的值域为 $Q$。

需要一定的数论基础。先考虑 Subtask 5，此时分母为 $1$，有以下观察：

$0\le x<y\Rightarrow x\bmod y=x$

此时可以直接取一个大质数，在该质数的模意义下求解即可。除法可以直接转成逆元。

可以发现我们并不关心约分后的结果，只希望找到一个映射，使得映射后的答案 **便于计算** 且 **能对应到原式的唯一解**。还是考虑取一个大质数。设大质数为 $y$，观察到，$y\ge PQ$ 时是足够的，具体地：

$$y\ge PQ,\dfrac{p'}{q'}\equiv\dfrac{p}{q}\pmod y\Rightarrow\dfrac{p'}{q'}=\dfrac{p}{q}$$

其中，$1\le p,p'\le P$，$1\le q,q'\le Q$。证明不难，倒一倒值域即可。在该模意义下找到答案 $x$ 后，本质上是要解这样一个方程：

$$xq\bmod y\le P$$

可以用 BSGS 解决。取一个根号级别的 $B$，把 $q$ 拆成 $kB+l$，预处理出所有 $xkB\bmod y$ 和 $xl\bmod y$，合并的时候稍微讨论一下，设前面那个值为 $z_1$，后面那个值为 $z_2$，则有两种情况：

1. $z_1+z_2\le P$。

2. $y<z_1+z_2\le y+P$。

对于情况一直接取最小值，对于情况二需要排序二分。当然都是容易的。大整数乘法可以 `__int128` 草过去，复杂度为 $O(s+\sqrt{Q}\log{Q})$，可以通过。

```cpp
#include <bits/stdc++.h>

using namespace std;

// using fread
#define INPUT_OPTIMIZE

// using fwrite
//#define OUTPUT_OPTIMIZE

namespace IO {
	// by R_i.
}

using namespace IO;

typedef long long ll;
typedef __int128 lll;
typedef pair<lll, lll> plll;

const int MAXN = 6e4 + 10, B = 6e4;
const lll mod = 9000000000000000041ll;

inline 
lll qpow(lll b, lll p) {
	lll res = 1;
	for (; p; p >>= 1, b = b * b % mod) if (p & 1) res = res * b % mod;
	return res;
}

int n, m; ll tmp; lll p = 1, q = 1, x, y, z;

plll a[MAXN];

int main() {
	read(n, m, tmp);
	for (int i = 1; i <= n; i++) read(tmp), p = p * tmp % mod;
	for (int i = 1; i <= m; i++) read(tmp), q = q * tmp % mod;
	p = p * qpow(q, mod - 2) % mod, x = p;
	for (int i = 1; i < B; i++) a[i] = plll(x, i), x = (x + p) % mod;
	sort(a, a + B), y = p;
	for (ll i = 1, j; ; i += B) {
		if (y <= 3e9) return printf("%lld %lld", (ll)y, i), 0;
		j = lower_bound(a, a + B, plll(mod - y + 1, 0)) - a;
		if (j < B) {
			z = a[j].first + y - mod;
			if (z <= 3e9) return printf("%lld %lld", (ll)z, (ll)a[j].second + i), 0;
		}
		y = (y + x) % mod;
	}
}
```

---

## 作者：ottora (赞：2)

考虑用浮点数算出答案的近似值，最后在 Stern-Brocot 上二分出答案。使用 __float128 精细实现可过。

分析相对误差：令浮点数的舍入误差为 $\varepsilon = 2^{-64}$，则 $n$ 次乘除法的误差不超过 $\left(1 + \varepsilon\right)^n-1\approx n\varepsilon \approx 2.5 \times 10^{-23}$，而任意两个分子分母不超过 $m$ 的分数之差 $\left|\frac{a/b-c/d}{a/b}\right| = \left|\frac{ad-bc}{ad}\right| \ge \frac{1}{m^2} \approx 10^{-19}$，因此可过。

代码：

```cpp
// 省略快读
constexpr uint32_t P1 = 1011451423, P2 = 1019260817, LIM = 3000000000;
uint32_t u1 = 1, u2 = 1, d1 = 1, d2 = 1;
bool check(uint32_t u, uint32_t d, __float128 f){
  if((uint64_t)u * d1 % P1 == (uint64_t)u1 * d % P1 && (uint64_t)u * d2 % P2 == (uint64_t)u2 * d % P2)
    cout << u << ' ' << d << '\n', exit(0);
  return u < f * d;
}
void work(__float128 f, uint32_t a, uint32_t b, uint32_t c, uint32_t d){
  if(check(a + c, b + d, f)){
    uint32_t l = 1, r = min(c? (LIM - a) / c: UINT32_MAX, d? (LIM - b) / d: UINT32_MAX);
    while(l < r){
      uint32_t mid = l + (r - l + 1) / 2;
      if(check(a + c * mid, b + d * mid, f)) l = mid; else r = mid - 1;
    } work(f, a + c * l, b + d * l, c, d);
  } else {
    uint32_t l = 1, r = min(a? (LIM - c) / a: UINT32_MAX, b? (LIM - d) / b: UINT32_MAX);
    while(l < r){
      uint32_t mid = l + (r - l + 1) / 2;
      if(check(a * mid + c, b * mid + d, f)) r = mid - 1; else l = mid;
    } work(f, a, b, a * l + c, b * l + d);
  }
}
int n, m, _, x, y; __float128 u = 1, d = 1;
int main(){
  cin.tie(nullptr)->sync_with_stdio(false);
  read(n, m, _);
  while(n--){
    uint64_t v; read(v), u *= v;
    while(u > 0x1p10000L) u /= 0x1p10000L, x += 10000;
    u1 = v % P1 * u1 % P1, u2 = v % P2 * u2 % P2;
  }
  while(m--){
    uint64_t v; read(v), d *= v;
    while(d > 0x1p10000L) d /= 0x1p10000L, y += 10000;
    d1 = v % P1 * d1 % P1, d2 = v % P2 * d2 % P2;
  }
  cerr << (double)clock() / CLOCKS_PER_SEC << endl;
  __float128 f = u / d * exp2l(x - y);
  work(f, 0, 1, 1, 0);
  return 0;
}
```

---

## 作者：Zhenghw (赞：0)

感觉[官方题解](https://www.luogu.com.cn/article/tn27td0x)并没有把为什么 $x$ 能够对应到原式的唯一解讲的非常明白，这里给出一个详细的证明。

命题：

已知 $p\in(0,P],q\in(0,Q],m\in[PQ,+\infty)$ 且 $m\in Prime$。

求证 $\forall p\in(0,P],q\in(0,Q],gcd(p,q)=1,x\equiv\frac{p}{q}\pmod m$, $x$ 只对应一对确定的 $p$ , $q$ 。

证明：

不妨假设 $\exist p_1,p_2\in(0,P],q_1,q_2\in(0,Q]$ 使得 $\frac{p_1}{q_1}\equiv\frac{p_2}{q_2}\pmod m$

那么此时有

$$\frac{p_1}{q_1}=\frac{p_2}{q_2}+km$$

即

$$p_1q_2=p_2q_1+q_1q_2km$$

$$p_1q_2-p_2q_1=k^{'}m$$

又

$$\because\frac{p_1}{q_1}\ne\frac{p_2}{q_2}$$

$$\therefore p_1q_2\ne p_2q_1$$

$$\therefore p_1q_2-p_2q_1\ne0$$

$$\therefore k^{'}m\ne0$$

不妨假设 $p_1q_2>p_2q_1$，则：

$$k^{'}>0$$

$$\because p_1q_2\in[1,PQ],p_2q_1\in[1,p_1q_2)$$

$$\therefore p_1q_2-p_2q_1\in(0,PQ)$$

$$\because k^{'}m\in[m,+\infty)$$

$$\therefore若\space m\in[PQ,+\infty),则\space p_1q_2-p_2q_1<k^{'}m,此时假设显然不成立$$

即我们证明了当 $m\in[PQ,+\infty)$ 时，$x$ 能对应到原式的唯一解。

---

## 作者：Purslane (赞：0)

# Solution

非常好的题目，学到了很多。~~和 [P10063](https://www.luogu.com.cn/problem/P10063) 有一点像，但也就那么一点。~~

我们肯定要让结果对某个大质数取模。所以如何取质数 $P$ 使得 $x,y,z,w \le 3 \times 10^9$ 时 $\dfrac{x}{y} \equiv \dfrac{z}{w} \pmod P$ 等价于 $\dfrac{x}{y} = \dfrac{z}{w}$（这样才能在题目限制的分数和 $\mathbb Z_P$ 中建立单射）。

显然如果 $p > 9 \times 10^{18}$ 有 $xw \equiv yz \pmod p$ 等价于 $xw = yz$，所以取 $p = 9 \times 10^{18}  + 41$。

计算完成 $\dfrac{p}{q} \equiv x \pmod P$ 之后，我们需要求解 $q$ 使得 $p \equiv qx \pmod P$，即 $qx \bmod P \le 3 \times 10^9$。

模仿 $\rm BSGS$，取 $B$ 为阈值。设 $x = \alpha B + \beta$，那么等价于 $\left[\alpha (Bx) + \beta x\right] \bmod P \le 3 \times 10^9$。枚举所有可能的 $\alpha$ 和 $\beta$ 以及 $\alpha Bx \bmod P$ 和 $\beta x \bmod P$ 的结果。它们求和，只能在 $[0,3 \times 10^9]$ 和 $[P,3 \times 10^9 + P]$ 两个区间里面。随便二分一下。

为了防止某些漏洞，我把 $\alpha$ 的上界放到了 $B-1$，对于 $\alpha = B$ 的情况特判。

注意逆元可以放一块求的 /ll 没意识到这一点。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1e6+10;
const __int128 MOD=9000000000000000000+41;
int n,m,C,bl=sqrt(3000000000),a[MAXN],b[MAXN];
__int128 ans=1;
int qpow(__int128 base,int p) {
	__int128 ans=1;
	while(p) {
		if(p%2) ans=ans*base%MOD;
		base=base*base%MOD,p/=2;
	}
	return ans;
}
__int128 inv(int p) {return qpow(p,MOD-2);}
map<int,int> mp;
class IO_helper{
private:
	static const int L = 1 << 16;
	char in_buf[L], *in_st, *out_st;

	char _getc(){
		if (in_st == out_st)
		{
			out_st = (in_st = in_buf) + fread(in_buf, 1, L, stdin);
			if (in_st == out_st) return EOF;
		}
		return *in_st++;
	}
public:
	template <typename IntType>
	IO_helper &operator>>(IntType &x){
		bool ok=0;
		char c; while ((c = _getc()) < '0' || c > '9')ok|=c=='-';
		for (x = 0; c >= '0' && c <= '9'; c = _getc())
			x = x * 10 + c - '0';
		x=(ok?-x:x);
		return *this;
	}
} IO;
signed main() {
	IO>>n>>m>>C; ffor(i,1,n) IO>>a[i]; ffor(i,1,m) IO>>b[i];
//	n=read(),m=read(),C=read(); ffor(i,1,n) a[i]=read(); ffor(i,1,m) b[i]=read();
	ffor(i,1,n) ans=ans*a[i]%MOD;
	__int128 tans=1;
	ffor(i,1,m) tans=tans*b[i]%MOD;
	ans=ans*inv(tans)%MOD;
	ffor(i,1,bl) mp[i*ans%MOD]=i;
	__int128 bans=bl*ans%MOD;
	ffor(i,0,bl) {
		__int128 part1=i*bans%MOD;
		if(mp.begin()->first<=3000000000-part1) {
			__int128 fm=i*bl+mp.begin()->second;
			return cout<<(int)(fm*ans%MOD)<<' '<<(int)fm,0;
		}
		auto it=mp.lower_bound(MOD-part1);
		if(it!=mp.end()&&it->first+part1-3000000000<=MOD) {
			__int128 fm=i*bl+it->second;
			return cout<<(int)(fm*ans%MOD)<<' '<<(int)fm,0;
		}
	}
	return 0;
}
//(x*bl+y) ans \bmod MOD <= 3000000000 
```

最后补充一道同学跟我说的神秘题（没啥逻辑关联，但是取模这一步比较有趣）：

> 给三个数 $A$、$B$、$C$，问是否有 $AB = C$。其中 $A$、$B$、$C \le 10^{1000000}$。保证如果 $AB \neq C$，那么 $C$ 是纯随机的。

解：取若干个大质数，判断是否有 $AB \equiv C \pmod P$。由于不合法的时候 $C$ 是随机的，所以这样做正确性很高。

---


# 「HOI R1」杂交选种

## 题目背景

$\clubsuit$ 星球盛产“代马”，其优越的速度与耗能使得它风靡整个银河系。可小 $\iiint$ 并不满足于此，他想培育出更好的“代马”，并取代掉还在用传统能源的落后四足兽。于是，他开始研究基因技术……

**本题仅支持 C++ 语言提交。**

**由于技术限制，请勿使用 C++14 (GCC 9) 语言提交，否则将会得到 Compile Error 的结果。**

你的代码中需如下进行 `query` 和 `cross` 函数的声明：

```cpp
char query(int k);
void cross(int i, int j);
```

调用 $10^6$ 次 `query` 与 `cross` 函数的时间不超过 50 毫秒，除这两个函数所占用的时间外，交互库运行所占用的时间不超过 100 毫秒。

## 题目描述

#### 【形式化题意】

**这是一道交互题。**

定义 **基因** 为一个字符，其内容为 $\verb!A!$ 或 $\verb!a!$。定义 **基因型** 为由两个基因组成，且大写字母在小写字母之前的字符串。也即 $\{\verb!aa!,\verb!Aa!,\verb!AA!\}$ 中的一种。一个基因型的 **表现** 如下：

- 若基因型中含有 $\verb!A!$，则表现为 $\verb!A!$。
- 否则，表现为 $\verb!a!$。

两个基因型可以相互 **杂交**，其定义如下：

- 在两个基因型中各均匀随机取一个基因，并将两个基因组合成基因型作为结果输出。

小 $\iiint$ 有 $n$ 个基因型，编号为 $1,2,\cdots,n$。每次询问可以给交互库两个不同的编号 $i,j$。若当前是第 $k$ 次杂交，交互库会新建一个编号为 $n+k$ 的基因型，其基因型为 $i,j$ 杂交后的结果。

你可以在时限范围内任意次查询编号为 $x$ 的种子的表现。你需要在 $4.5\times10^5$ 次杂交内，求出初始给定的 $n$ 个基因型。

### 实现细节

**你不需要，也不应该实现主函数。** 你需要实现下面的函数：

```cpp
vector<string> guess(int n)
```

- $n$ 表示初始基因型个数。
- 该函数应当返回一个长度恰好为 $n$ 的数组，数组中的每一个元素是一个长度为二的字符串，表示你所求出的基因型。**你需要保证大写字母在小写字母的前面**。
- 对于每个测试点，该函数被恰好调用一次。

该函数可调用以下函数：

```cpp
char query(int k)
```

- $k$ 表示你要查询的基因型的编号。**你需要保证这个编号对应的基因型存在**。
- 该函数将返回该基因型的表现。
- 该函数可以在时限内被调用任意次。

```cpp
void cross(int i, int j)
```

- $i,j$ 代表你要杂交的两个基因的编号。**你需要保证 $i\not=j$ 且对应的基因型存在**。
- 若是第 $k$ 次调用该函数，该函数会新建一个编号为 $n+k$ 的基因型，其基因型为 $i,j$ 杂交后的结果。保证杂交过程为均匀随机。
- 你最多可以调用该函数 $4.5\times10^5$ 次。
- 评测程序不是适应性的。也就是说，所有初始元素的基因型在 `guess` 函数被调用前已经确定。

## 说明/提示

#### 【交互示例】

以下为 $n=2$，基因型为 $\{\verb!Aa!,\verb!AA!\}$ 时一种可能的交互过程。

|选手程序|交互库|
|:-:|:-:|
||`guess(2)`|
|`cross(1,2)`||
||$\{\verb!Aa!,\verb!AA!,\verb!Aa!\}$|
|`cross(1,3)`||
||$\{\verb!Aa!,\verb!AA!,\verb!Aa!,\verb!aa!\}$|
|`query(4)`||
||$\verb!a!$|
|$\{\verb!Aa!,\verb!AA!\}$||
||`Ok,accepted.`|

#### 【约束条件】

+ $2\le n\le 2\times10^4$，$n$ 为偶数。
+ 每次程序运行时将恰好调用一次 `guess()` 函数。
+ 保证交互库是非自适应性的，即所有初始元素的基因型不在交互过程中发生改变。

#### 【子任务】

|Subtask|分值|$n\le$|特殊性质|
|:-:|:-:|:-:|:-:|
|$0$|$0$|$2$|无|
|$1$|$5$|$2\times10^4$|保证不存在 $\verb!Aa!$|
|$2$|$15$|$500$|无|
|$3$|$20$|$2\times10^4$|保证至少存在一个 $\verb!aa!$|
|$4$|$25$|$5\times10^3$|无|
|$5$|$35$|$2\times10^4$|无|

对于所有数据，$2\le n\le 2\times10^4$，保证 $n$ 为偶数。

由于本题涉及概率与期望，如果你确定你的算法无误，可以尝试多交几发。

# 题解

## 作者：Purslane (赞：10)

# Solution

这道题有点水啊，我没有做任何分析随便写了一个过程交上去 $\rm Accepted$ 了。

在高中生物学中，隐性个体必然为纯合子，因此如果有某匹马的表型为 $\texttt a$ 那么一定为隐性纯合子。

对于显性个体是纯合子还是杂合子，最好的判断方法是测交。将个体与 $\texttt {aa}$ 进行杂交，如果个体的基因型为 $\text {Aa}$，则每次都有 $\dfrac{1}{2}$ 的概率产生隐性个体。差不多 $22$ 次之后误判的概率低至 $2^{-22} < 10^{-6}$，可以忽略不计。

因此，首先特判有个体的表型是隐性性状的情况。

```cpp
vector<string> check(int flg) {	
	ffor(i,1,n) if(i!=flg&&op[i]==1) {
		ffor(k,1,22) {
			++cnt,cross(flg,i);
			if(query(cnt)=='a') {gene[i]=1;break;}
		}
		if(gene[i]!=1) gene[i]=2;
	}
	vector<string> ans;
	ffor(i,1,n) if(gene[i]==0) ans.push_back("aa");
	else if(gene[i]==1) ans.push_back("Aa");
	else ans.push_back("AA");
	return ans;
}
```

如果所有个体都是显性性状，那么它不是 $\texttt{AA}$ 就是 $\texttt{Aa}$。考虑先用 $100$ 次操作确定第一匹马是不是杂合子。

我们将采取这样的流程：对于个体 $\mathcal X$，先让它和个体 $\mathcal Y$ 杂交，产生子一代个体 $\mathcal Z$。每次让 $\mathcal X \times \mathcal Z$（注意到马没有伦理道德，这样是合法的），得到新的子代 $\mathcal Z'$，并且 $\mathcal Z \leftarrow \mathcal Z'$。打表得知，如果 $\mathcal X$ 是杂合子，那么在进行 $100$ 次交配之后只有 $5 \times 10^{-13}$ 的概率无法判断出来，远小于古今中外所有人中选一个选中你的概率。

> 生物学的基本知识：如果两个显性个体杂交得到隐性个体，这两个显性个体都是杂合子。

在对第 $2$ 匹到第 $n$ 匹马判断的过程中，如果我们之前产生了一只隐性个体，直接测交；否则，之前所有马都是纯合子，随便拉一匹出来进行杂交，并且执行上述流程即可。

（执行 $22$ 次该流程的错误率是 $3 \%\%$，但是注意到一旦成功就会产生隐性个体，所以总的错误率还是 $3 \%\%$）。

交了四五发，没有一发 $\rm Wrong \ Answer$。这就是二十一世纪科学的魅力 /se

代码：

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=5e5+10;
int cnt,flg,n,op[MAXN],gene[MAXN];
char query(int k);
void cross(int i,int j);
vector<string> check(int flg) {	
	ffor(i,1,n) if(i!=flg&&op[i]==1) {
		ffor(k,1,22) {
			++cnt,cross(flg,i);
			if(query(cnt)=='a') gene[i]=1;
		}
		if(gene[i]!=1) gene[i]=2;
	}
	vector<string> ans;
	ffor(i,1,n) if(gene[i]==0) ans.push_back("aa");
	else if(gene[i]==1) ans.push_back("Aa");
	else ans.push_back("AA");
	return ans;
}
vector<string> guess(int N) {
	n=N,cnt=n;	
	ffor(i,1,n) op[i]=(query(i)=='A');
	ffor(i,1,n) if(op[i]==0) flg=i;
	if(flg) return check(flg);
	cross(1,2),++cnt;
	if(query(cnt)=='a') return check(cnt);
	ffor(i,1,99) {
		cross(1,n+i),++cnt;
		if(query(cnt)=='a') return check(cnt);
	}
	//这时候一号是 AA
	vector<string> ans;
	ans.push_back("AA");
	int aid=0;
	ffor(i,2,n) {
		int flg=0;
		if(aid==0) {
			cross(1,i),++cnt;
			if(query(cnt)=='a') aid=cnt,flg=1;
			ffor(j,1,21) {
				cross(i,cnt),++cnt;
				if(query(cnt)=='a') {aid=cnt,flg=1;break;}
			}
			if(flg==0) ans.push_back("AA");
			else ans.push_back("Aa");
		}
		else {
			ffor(j,1,22) {
				cross(aid,i),++cnt;
				if(query(cnt)=='a') {flg=1;break ;}
			}
			if(flg==0) ans.push_back("AA");
			else ans.push_back("Aa");
		}
	}
  return ans;
}
```

PS：稍微思考了一下，好像把第一匹马和其他马分开考虑是没有必要的。懒得改代码了。

---

## 作者：Wf_yjqd (赞：4)

蓝，初中生物，应该算是秒了。

不过真的很难相信正解真就是这么个错误率的东西。。

------------

$\verb!AA!$ 和 $\verb!Aa!$ 表现不出区别，而 $\verb!aa!$ 可以。

如果已经有一个 $\verb!aa!$，只需要将剩下的每只都和她多次杂交。若存在某个子代为 $\verb!aa!$（显隐性），这只为 $\verb!Aa!$；否则为 $\verb!AA!$。

对于任意一个，若尝试 $k_1$ 次，错误率为 $\frac{1}{2^{k_1}}$（$\verb!Aa!$ 和 $\verb!aa!$ 生出 $\verb!Aa!$ 概率为 $\frac{1}{2}$）。

发现这种方式可以在限定杂交次数内达到很高的正确率，所以考虑在没有 $\verb!aa!$ 时造出一个。

那么我们需要两个 $\verb!Aa!$，他们生出 $\verb!aa!$ 的概率为 $\frac{1}{4}$。

我们枚举一只并假定他为 $\verb!Aa!$，最坏情况下只有她一只 $\verb!Aa!$，这时只能她和一只 $\verb!AA!$ 杂交生出 $\verb!Aa!$（概率 $\frac{1}{2}$），然后再两个 $\verb!Aa!$ 杂交。

整个过程后成功造出 $\verb!aa!$（可行的话）的概率高达 $\frac{1}{8}$。。

然而其他情况下，如果再假定另一只 $\verb!Aa!$，复杂度显然不行。

把上面过程中的 $\verb!AA!$ 改成除本身外任意一只，每花费两次杂交机会可以验证一次。

发现除本身外任意一只是相互的，所以我们每花费三次杂交机会可以验证两只各一次。

对于任意一只，验证 $k_2$ 次的错误率为 $\frac{7^{k_2}}{8^{k_2}}$。这个东西它要保证正确率需要花很多次数。

如果两只在 $k_2$ 次验证后任造不出 $\verb!aa!$，我们认定他俩都是 $\verb!AA!$ 和认定他俩无限次也造不出 $\verb!aa!$ 的错误率是相同的，也就是我们使用前者无负面影响。

这样用这种判断方式的就不需要再和造出的 $\verb!aa!$ 尝试了。

我们只需要控制两种方式操作数的最大值的和不超过 $4.5\times10^5$ 即可，解出 $k_1\le22.5,k_2\le15$。

最坏情况是找不到造出 $\verb!aa!$ 的方案，此时错误率为 $\frac{7^{15}}{8^{15}}\approx0.135$。

硬冲。

------------

我真的以为题面中的“可以尝试多交几发”是指运气很差才需要不止一发。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e4+26;
char query(int k);
void cross(int i, int j);
vector<string> guess(int n){
    vector<string> ans;
    int aa=0,jy[maxn],cnt=n;
    for(int i=1;i<=n;i++)
        if(jy[i]=(query(i)=='a'))
            aa=i;
    for(int i=1;i<=n&&!aa;i+=2){
        for(int j=0;j<15&&!aa;j++){
            cross(i,i+1);
            if(query(++cnt)=='a'){
                aa=cnt;
                break;
            }
            cross(i,cnt);
            if(query(++cnt)=='a'){
                aa=cnt;
                break;
            }
            cross(i+1,cnt-1);
            if(query(++cnt)=='a')
                aa=cnt;
        }
        if(!aa){
            ans.push_back("AA");
            ans.push_back("AA");
        }
    }
    for(int i=ans.size()+1,b=1;i<=n;i++,b=1)
        if(jy[i])
            ans.push_back("aa");
        else{
            for(int j=0;j<22;j++){
                cross(i,aa);
                if(query(++cnt)=='a'){
                    ans.push_back("Aa");
                    b=0;
                    break;
                }
            }
            if(b)
                ans.push_back("AA");
        }
    return ans;
}
```

---

## 作者：dehsirehC (赞：4)

本场比赛笑点解析：

- B 题标程挂了，我少讨论一种情况但是过了。
- C 题我拟合分数但是因为精度原因挂了几个点，小数据跑暴力然后过了。
- D 题题解说标程期望交 $8$ 次可过，但是考虑到题目里并没有说有多少个测试点，官方题解里说有 $15$ 个最坏数据的测试点时期望需要交 $8$ 次，那如果有 $30$ 个时那不就需要交 $64$ 次？更多呢？

我觉得不如 GenshinOI ，一段时间后可能会举办 Round 4 和 Round 5 ，欢迎大家参加！

---

我的 D 题做法大概在操作次数为 $2.1\times 10^5$ 时最坏数据有接近 $\frac{1}{2}$ 的概率通过。更多的数据如下。

|操作次数|错误概率 $\approx$|
|:-:|:-:|
|$2\times 10^5$|$\frac{2}{3}$|
|$2.1\times 10^5$|$\frac{1}{2}$|
|$2.3\times 10^5$|$\frac{3}{10}$|
|$2.5\times 10^5$|$\frac{1}{6}$|
|$3\times 10^5$|$\frac{1}{10}$|
|$3.5\times 10^5$|$\frac{1}{15}$|
|$4\times 10^5$|$\frac{1}{20}$|
|$4.5\times 10^5$|$\frac{1}{30}$|

（最坏数据大概为 $2^{11}$ 个 `Aa` 或 $1$ 个 `Aa` ，基因不包含 `aa` ）

（操作次数为 $3.5\times 10^5$ 时基本稳过）

---

我的 D 题做法如下。

如果我们已经制取了一个 `aa` ，则直接每一轮依次和所有基因交一下，操作若干轮即可。

具体的，假设有 $x$ 个 `Aa` 和 $y$ 个 `AA` ，则操作次数约为 $y\log_2 x+O(x+y)$ 。

现在考虑如何制取一个 `aa` ，假设我们现在已经获得了一个 `Aa` 和一个 `AA` 。

我们先让 `Aa` 和 `AA` 交一下，再不断让每次新交出来的东西和 `Aa` 交，大概率可以得到 `aa` 。

事实上我们发现 `AA` 在过程中并不重要，如果是 `Aa` 的话甚至更好。

于是我们枚举每一个元素，假设它是 `Aa` 然后做上述操作，如果得不到 `aa` 则所有基因均为 `AA` 。

操作次数不太好算，但是可以大致分析一下。

- 当 `Aa` 极少的时候操作轮数较多，但上一步的操作次数较少。
- 当 `Aa` 较多的时候操作轮数极少，但上一步的操作次数较多。

总的来说就是两步操作只会有一步操作次数是瓶颈，另一步的操作次数较少。

设 `Aa` 个数为 $m$ ，则第一步为瓶颈时 $m$ 约为 $2^{11}$ 时操作次数最多，否则 $m=1$ 时操作次数最多。

[代码](https://www.luogu.com.cn/paste/fai7x70w)

---

## 作者：Register_int (赞：3)

放 D 纯粹是怕前三题放交互会被骂。

可以通过表现来判断是否是 $\verb!aa!$。考虑有 $\verb!aa!$ 的情况。我们发现，$\verb!aa!$ 跟剩下两种基因型杂交会有以下情况：

- 与 $\verb!Aa!$ 杂交，相等概率出现 $\verb!Aa,aa!$，即 $\frac12$ 概率表现为 $\verb!a!$。
- 与 $\verb!AA!$ 杂交，只会出现 $\verb!Aa!$，永远表现为 $\verb!A!$。

于是我们可以用 $\verb!aa!$ 与其余基因型杂交 $k_1$ 次，若出现 $\verb!a!$ 则为 $\verb!Aa!$，否则为 $\verb!AA!$。这部分失误概率为 $2^{-k_1}$。

但是没有 $\verb!aa!$ 这个做法就爆炸了。重新考虑，对原序列两两分组，每一组有 $\{\verb!AA!,\verb!AA!\},\{\verb!Aa!,\verb!Aa!\},\{\verb!AA!,\verb!Aa!\},\{\verb!Aa!,\verb!AA!\}$ 四种可能。还是通过杂交出 $\verb!aa!$ 来判断。有如下方法：

- 两个基因型（我们称为亲代）杂交 $k_2$ 次，得到 $k_2$ 个基因型（我们称为子代）。每个子代再分别与两个亲代各杂交一次。

如果子代里已经有了 $\verb!a!$，那么可以确定这一组是 $\{\verb!Aa!,\verb!Aa!\}$ 了。否则，在子代里很有可能出现 $\verb!Aa!$。此时再与亲代杂交会出现 $\verb!Aa!\times\verb!Aa!$ 的情况，有 $\frac14$ 的概率出现 $\verb!aa!$。若出现了即可直接判定。

由于对于每组两个基因型，我们需要操作 $3k_2$ 次，所以这种方法对于每个基因型的平均操作次数是 $\frac 32 k_2$。他能否达到我们的准确度要求呢？不妨来算一算：

- $\{\verb!AA!,\verb!AA!\}$。此种情况不会误判。
- $\{\verb!Aa!,\verb!Aa!\}$。错误率为 $(\frac34)^{k_2}$。
- $\{\verb!AA!,\verb!Aa!\}$ 或 $\{\verb!Aa!,\verb!AA!\}$。此种情况下，枚举子代中出现的 $\verb!Aa!$ 的个数，得到误判概率为：

$$
\begin{aligned}
&\dfrac1{2^{k_2}}\sum^{k_2}_i\dbinom{k_2}i\left(1-\dfrac14\right)^{k_2i}\\
=&\dfrac1{2^{k_2}}\left(2-\dfrac14\right)^{k_2}\\
=&\left(\dfrac78\right)^{k_2}\\
\end{aligned}
$$

在题目的限制下，$k_2\le 15$。此时光单组的最大误判概率就约为 $0.135$，总共一万多组就直接爆炸了。

有这样一个小优化。在该方法的过程中，判断 $\verb!Aa!$ 出现的标志正是杂交出 $\verb!aa!$。也就是说，若找到一个 $\verb!Aa!$，我们就再也不需要这个方法了，因为我们用这个 $\verb!aa!$ 来判剩下的即可。

然后这个做法就直接对了。为什么呢？因为这个方法是不会将 $\verb!AA!$ 错判的，而判 $\verb!Aa!$ 也只有最多一次判断机会，因为只要判成功了也就造出了一个 $\verb!aa!$，换用有 $\verb!aa!$ 的方法即可。所以乘进概率里面只用乘一次，不会对最终正确率造成多大影响。

最后就是调参了。取 $k_1=22,k_2=15$，操作次数为 $n\times\max(k_1,\frac32k_2)=22.5n\le 4.5\times10^5$，单组数据错误概率约为 $0.135$。本题数据下有 $15$ 个点需要动用此方法，通过概率为 $(1-0.135)^{15}\approx0.123$，期望交 $8$ 次可过。此处估算有较大误差，事实上标程经过五次重复试验得到的期望提交次数是 $3.4$ 次。

```cpp
#include <bits/stdc++.h>

using namespace std;

char query(int k);
void cross(int i, int j);

vector<string> guess(int n) {
	int p = 0, tot = n;
	vector<char> a(n);
	vector<string> ans(n);
	for (int i = 1; i <= n; i++) a[i - 1] = query(i);
	for (int i = 0; i < n; i++) if (islower(a[i])) ans[i] = "aa", p = i + 1;
	if (!p) {
		int pre = 0, f = 0;
		for (int i = 2; i <= n; i += 2) {
			for (int j = 0; j < 15; j++) cross(i - 1, i), a.push_back(query(++tot));
			f = 0;
			for (int j = 1; j <= 15; j++) if (islower(a[tot - j])) { f = 1, p = tot - j + 1; break; }
			if (f) { ans[i - 2] = ans[i - 1] = "Aa"; break; }
			pre = tot, ans[i - 2] = ans[i - 1] = "AA";
			for (int j = 0; j < 15; j++) cross(i - 1, pre - j), a.push_back(query(++tot));
			for (int j = 1; j <= 15; j++) if (islower(a[tot - j])) { f = 1; p = tot - j + 1; break; }
			if (f) { ans[i - 2] = "Aa"; break; }
			for (int j = 0; j < 15; j++) cross(i, pre - j), a.push_back(query(++tot));
			for (int j = 1; j <= 15; j++) if (islower(a[tot - j])) { f = 1; p = tot - j + 1; break; }
			if (f) { ans[i - 1] = "Aa"; break; }
		}
	}
	for (int i = 1; i <= n; i++) {
		if (ans[i - 1] != "") continue;
		for (int j = 0; j < 22; j++) {
			cross(i, p);
			if (islower(query(++tot))) { ans[i - 1] = "Aa"; break; }
		}
		if (ans[i - 1] == "") ans[i - 1] = "AA";
	}
	return ans;
}
```

---

## 作者：ykzzldz (赞：2)

对于有 $\texttt {aa}$ 的部分，我们先找到一个 $\texttt {aa}$，用这个 $\texttt {aa}$ 与其他表现为 $\texttt {A}$ 的杂交，当与一个 $\texttt {Aa}$ 杂交，次数为 $k$ 时，有一次表现为 $\texttt {a}$ 的概率为 $\frac{1}{2^k}$，此时，我们若对于每个进行 $22$ 次杂交，出错的概率是极低的。

先给出这部分的代码，期望 $20$ 分，实际 $25$ 分：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e4+10;
char query(int k);
void cross(int i, int j);
vector<string> guess(int n){
	vector<string>ans;
	char c[N];
	int jl=0,cnt=n;
	for(int i=1;i<=n;i++){
		c[i]=query(i);
		if(c[i]=='a')jl=i;
	}
	for(int i=1;i<=n;i++){
		if(c[i]=='a'){
			ans.push_back("aa");
			continue;
		}
		int f=0;
		for(int j=1;j<=22;j++){
			cnt++;
			cross(i,jl);
			if(query(cnt)=='a'){
				f=1;
				ans.push_back("Aa");
				break;
			}
		}
		if(!f)ans.push_back("AA");
	}
	return ans;
}
```
然后我们沿着部分分思考：在只有 $\texttt {AA}$ 和 $\texttt {Aa}$ 时，如何构造出一个 $\texttt {aa}$？

要构造出 $\texttt {aa}$，我们取两个基因型 $x,y$，先将它们杂交，得到 $z$，随后，将 $x$ 与 $z$、$y$ 与 $z$ 分别杂交，以此类推，当操作次数较多且 $x$ 与 $y$ 中有 $\texttt {a}$ 时，得到 $\texttt {aa}$ 的概率是比较高的，具体来说，经过实测，这一部分取操作次数为 $14$ 可以通过。下面给出代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e4+10;
char query(int k);
void cross(int i, int j);
vector<string> guess(int n){
	vector<string>ans;
	char c[N];
	int jl=0,cnt=n;
	for(int i=1;i<=n;i++){
		c[i]=query(i);
		if(c[i]=='a')jl=i;
	}
	if(jl){
		for(int i=1;i<=n;i++){
			if(c[i]=='a'){
				ans.push_back("aa");
				continue;
			}
			int f=0;
			for(int j=1;j<=22;j++){
				cnt++;
				cross(i,jl);
				if(query(cnt)=='a'){
					f=1;
					ans.push_back("Aa");
					break;
				}
			}
			if(!f)ans.push_back("AA");
		}
	}
	else{
		for(int i=1;i<=n;i+=2){
			for(int j=1;j<=14;j++){
				cross(i,i+1);
				cnt++;
				if(query(cnt)=='a'){
					jl=cnt;
					break;
				}
				cross(i,cnt);
				cnt++;
				if(query(cnt)=='a'){
					jl=cnt;
					break;
				}
				cross(i+1,cnt-1);
				cnt++;
				if(query(cnt)=='a'){
					jl=cnt;
					break;
				}
			}
			if(jl)break;
			ans.push_back("AA");
			ans.push_back("AA");
		}
		for(int i=ans.size()+1;i<=n;i++){
			if(c[i]=='a'){
				ans.push_back("aa");
				continue;
			}
			int f=0;
			for(int j=1;j<=20;j++){
				cnt++;
				cross(i,jl);
				if(query(cnt)=='a'){
					f=1;
					ans.push_back("Aa");
					break;
				}
			}
			if(!f)ans.push_back("AA");
		}
	}
	return ans;
}
```

---

## 作者：luanyanjia (赞：2)

挺好玩的一个题。

我们知道，要测定基因型，最好的办法是测交，也就是拿 aa 和它去杂交，这样我们就可以开始分讨：

先对所有种子进行一个 query ;

- 如果其中有 $\mathtt{aa}$ 基因型，就拿它和所有 $\mathtt{AA}$/$\mathtt{Aa}$ 种子都杂交 $k$ 遍, 如果子代中有 $\mathtt{aa}$ 基因型那么它就是 $\mathtt{Aa}$ ，反之即为 $\mathtt{AA}$。这样做对于每一个种子成功的概率都是 $1-(\frac{1}{2})^k$ ，$k$ 取最大值 $22$ 时，全部成功的概率大约是 $99.52\%$ 。

- 反之，我们对种子两两分组分别杂交 $k_1$ 次。

	- 对于 $\mathtt{\{Aa,Aa\}}$ , 如果子代中出现了 $\mathtt{aa}$ , 那么就可以直接按照第一种方式判定，正确的概率为 $1-(\frac{3}{4})^{k_1}$ , 然后再对每一个基因型测交 $k_2$ 次，正确的概率是 $(1-(\frac{1}{2})^{k_2})^n$, 当 $k_1$ 取 $8$ 时，这个概率是 $83.4\%$ 。
   - 如果没有 $\mathtt{\{Aa,Aa\}}$ 的话，我们就需要判断其中的 $\mathtt{\{AA,Aa\}}$ 和 $\mathtt{\{Aa,AA\}}$ 并用 $\mathtt{aa}$ 测交。即对于每一个种子，将它们与所有自己的子代杂交，当 $k_2$ 取 $18$ 且当前基因型为 $\mathtt{Aa}$ 时，自己的子代中期望有 $9$ 个是 $\mathtt{Aa}$，即成功的概率为 $(1-(\frac{3}{4})^9)=0.92$ ；判断出 $\mathtt{Aa}$ 后我们手上现在也有了一个 $\mathtt{aa}$ 再次使用第一种方式即可，正确的概率是 $84.6\%$ 。

其实 $15$ 个点要使用此方法均通过的话，最劣情况成功概率只有 $0.834^{15} = 0.066$ , 但是这个概率估算并不准确，还有比如说 2.1 中即使有 $\mathtt{Aa}$ 误判了，也有后面的兜底。 所以真实的成功概率其实要高不少。

如果没过的话多交几遍，我赛时交了两遍。

Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e4+5;
char query(int k);
void cross(int i,int j);
string hete="Aa",rece="aa",phen="AA";
vector<string> vc;
vector<string> ans;
bitset<N> flag;
int fst[N];
vector<string> guess(int n){
	vc.push_back(rece);
	int arece=0,now=n,flag=0;
	for(int i=1;i<=n;i++){
		vc.push_back(phen);
		if(query(i)=='a')vc[i]=rece,arece=i;
	}
	if(!arece){
		for(int i=1;i<=n;i+=2){
			fst[i]=fst[i+1]=now;
			for(int j=1;j<=8;j++){
				cross(i,i+1);
				++now;
				if(query(now)=='a'){
					arece=now;
					flag=1;
					break;
				}
			}
			if(flag)break;
		}
		if(arece){
			for(int i=1;i<=n;i++){
				for(int j=1;j<=18;j++){
					cross(arece,i);
					++now;
					if(query(now)=='a'){
						vc[i]=hete;
						break;
					}
				}
			}
		}else{
			for(int i=1;i<=n;i++){
				if(!arece){
					for(int j=1;j<=18;j++){
						cross(i,fst[i]+(j-1)%12+1);
						++now;
						if(query(now)=='a'){
							arece=now;
							vc[i]=hete;
							break;
						}
					}
				}else{
					for(int j=1;j<=18;j++){
						cross(i,arece);
						++now;
						if(query(now)=='a'){
							vc[i]=hete;
							break;
						}
					}
				}
			}
		}
	}else{
		for(int i=1;i<=n;i++){
			if(vc[i]==rece)continue;
			int y=0;
			for(int j=1;j<=22;j++){
				cross(i,arece);
				now++;
				y+=(query(now)=='a');
			}
			if(y)vc[i]=hete;
		}
	}
	for(int i=1;i<=n;i++)ans.push_back(vc[i]);
	return ans;
}
//int main(){return 0;}
```

---

## 作者：ZHR100102 (赞：1)

[Blog](https://www.cnblogs.com/zhr0102/p/18984772)

我是赛博孟德尔.jpg

![](https://cdn.luogu.com.cn/upload/image_hosting/z24oer42.png)


很有趣的题。

首先注意到 $4.5\times 10^5 \approx 2\times 10^4 \times 20$，相当于均摊下来每个基因被杂交二十次。

然后**弱化条件**，考虑部分分，即当**至少有一个 $\texttt{aa}$** 的时候的策略是什么，显然这时候直接拿 $\texttt{aa}$ 和其他基因测交 $20$ 次即可，如果是 $\texttt{AA}$ 则**永远无法生出 $\texttt{aa}$**，如果是 $\texttt{Aa}$ 则有 $\dfrac{1}{2}$ 的概率生出 $\texttt{aa}$。因此测交 $20$ 次的失败率为 $\dfrac{1}{2^{20}}$，对于 $2\times 10^4$ 的数据，成功率约为 $98.1\%$，足以通过。

进而考虑如何做全是 $\texttt{AA}, \texttt{Aa} $ 的情况。显然判断这两种**必须合成出一个 $\texttt{aa}$**，而合成 $\texttt{aa}$ 之后就可以按上面的做法直接测交了，于是我们只需合成出一个 $\texttt{aa}$ 即可。

注意到将一个非 $\texttt{aa}$ 的基因 $X$ 与某个非 $\texttt{aa}$ 的基因 $Y$ 杂交的后代 $Z$ 与该基因杂交，假设该后代为 $Z'$，然后再拿 $Z'$ 与 $X$ 杂交得到 $Z''$，如此循环往复下去，如果试验 $20$ 次，那么 $X=\texttt{Aa},Y=\texttt{AA}$ 时生出 $\texttt{aa}$ 的概率是很大的，写了个 DP 后发现这个概率是 $94.9\%$，DP 代码如下：

```cpp
/*
dp_0 表示 AA
dp_1 表示 Aa
dp_2 表示 aa
*/
#include <bits/stdc++.h>
#define fi first
#define se second
#define eb(x) emplace_back(x)
#define pb(x) push_back(x)
#define lc(x) (tr[x].ls)
#define rc(x) (tr[x].rs)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef long double ldb;
using pi=pair<int,int>;
ldb dp[200][3];
int main()
{
    dp[0][0]=1;
    for(int i=0;i<100;i++)
    {
        dp[i+1][2]+=dp[i][2];
        dp[i+1][0]+=dp[i][0]*0.5;
        dp[i+1][1]+=dp[i][0]*0.5;
        dp[i+1][0]+=dp[i][1]*0.25;
        dp[i+1][2]+=dp[i][1]*0.25;
        dp[i+1][1]+=dp[i][1]*0.5;
    }
    for(int i=1;i<=100;i++)
        printf("%d : %.10Lf%%\n",i,dp[i][2]*100);
    return 0;
}
```

剩下有一个细节是如果 $Z$ 直接就是 $\texttt{aa}$ 了，那么也是可以证明 $X$ 是 $\texttt{Aa}$，因为只有两个都是 $\texttt{Aa}$ 的情况才能生出 $\texttt{aa}$。

因此**对每个基因进行验证**，只要合成出了一个 $\texttt{aa}$ 就直接测交，那么成功率就是第一个 $\texttt{Aa}$ 生出 $\texttt{aa}$ 的成功率，即 $94.9\%$，那么整体的成功率就是 $94.9\%\times 98.1\%=93.1\%$，可能有点偏差，因为实际测试 $10$ 次内有 $7$ 次 AC。

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
#define eb(x) emplace_back(x)
#define pb(x) push_back(x)
#define lc(x) (tr[x].ls)
#define rc(x) (tr[x].rs)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef long double ldb;
using pi=pair<int,int>;
vector<string>ans;
char query(int k);
void cross(int i,int j);
vector<string> guess(int n)
{
    int cnt=n,p=0;
    for(int i=1;i<=n;i++)
    {
        if(query(i)=='a')
        {
            p=i;
            break;
        }
    }
    for(int i=1;i<=n;i++)
        ans.push_back("");
    if(p==0)
    {
        int npos=n+1;
        for(int i=1;i<=n;i++)
        {
            int x=++cnt;
            cross(i,i%n+1);
            bool lg=0;
            for(int j=1;j<=20;j++)
            {
                if(query(cnt)=='a')
                {
                    lg=1;
                    ans[i-1]="Aa";
                    p=cnt;
                    npos=i+1;
                    break;
                }
                cross(x,i);
                x=++cnt;
            }
            if(lg==0)ans[i-1]="AA";
            if(p)break;
        }
        for(int i=npos;i<=n;i++)
        {
            bool lg=0;
            for(int j=1;j<=20;j++)
            {
                cross(i,p);
                if(query(++cnt)=='a')
                {
                    ans[i-1]="Aa";
                    lg=1;
                    break;
                }
            }
            if(lg==0)ans[i-1]="AA";
        }
        return ans;
    }
    for(int i=1;i<=n;i++)
    {
        if(query(i)=='a')
        {
            ans[i-1]="aa";
            continue;
        }
        bool lg=0;
        for(int j=1;j<=20;j++)
        {
            cross(i,p);
            if(query(++cnt)=='a')
            {
                ans[i-1]="Aa";
                lg=1;
                break;
            }
        }
        if(lg==0)ans[i-1]="AA";
    }
    return ans;
}
```

---

## 作者：McIron233 (赞：1)

## 前言

赛时在物理课，赛后瞄了一眼，一股生物味：这不就是生物老师讲过的原题嘛！喝喝粥糊了糊就解决了。

由于笔者自身原因，如果你有不懂的名词可以在【名词解释】部分查询，若还有不懂可以在评论区指出~~并臭骂笔者~~。

## 正文

这题最重要的思想就是测交和回交。

首先，如果有隐性性状个体，那就很容易了，将它们全部挑出来，然后用其中的一个和剩下的反复杂交 $p$ 次，出现隐性性状后代的个体就是杂合子，否则就是纯合子。

如果没有，可以考虑分成若干组，每组 $2$ 个个体去创造隐性性状个体，一组中只可能是 $\{\texttt{AA},\texttt{AA}\},\{\texttt{AA},\texttt{Aa}\},\{\texttt{Aa},\texttt{Aa}\}$ 这三种情况。所以，我们可以考虑让每一组的个体先杂交 $q$ 次，再让得到的个体和亲代回交 $r$ 次，如果回交前或回交后得到隐性性状个体了，那么结束这个创造过程，用这个隐性性状个体去测交就可以了。

有个优化：

- 如果你测交前创造隐性性状个体的过程中在一组中失败了，那么这组可以确定为 $\{\texttt{AA},\texttt{AA}\}$；
- 如果你测交前创造隐性性状个体的过程中在回交前得到了这样的个体，那么这组可以确定为 $\{\texttt{Aa},\texttt{Aa}\}$；

这样，可以不必测交浪费杂交次数。

经过[多次提交检验](https://www.luogu.com.cn/record/list?pid=P10384&user=381463)，当 $p=22,q=15,r=1$ 时可以在比较少的次数内通过。

关于正确率，Ri 的文章中已经有清晰证明，不再赘述。

## 名词解释

测交：用 $\texttt{aa}$ 去和 $\texttt{A\_}$ 杂交的过程，其中 $\texttt{\_}$ 表示不知道是 $\texttt{A}$ 还是 $\texttt{a}$。

回交：两个个体使用 `cross` 函数杂交后，将剩下的个体与原先这两个个体中的一个进行杂交的过程。

隐性性状个体：基因型为 $\texttt{aa}$ 的个体。

杂合子：基因型为 $\texttt{Aa}$ 的个体。

纯合子：基因型为 $\texttt{AA}$ 或 $\texttt{aa}$ 的个体。

## 参考代码

这里贴出调试时使用的代码，从开始想到满分一共花费了 $60$ 分钟，还是太慢了。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int P=22,Q=15;

char query(int k);
void cross(int i, int j);

vector<string>guess(int n){
	vector<string>res;
	vector<char>perf;
	int tot=n,aa=-1;
	for(int i=1;i<=n;++i)perf.push_back(query(i));
	for(int i=1;i<=n;++i)res.push_back("X");
	for(int i=0;i<n;++i){
		if(perf[i]=='a'){ aa=i+1; res[i]="aa"; }
	} if(aa==-1){
		for(int i=1;i<=n;i+=2){
			for(int j=1;j<=Q;++j){
				cross(i,i+1); ++tot;
				if(query(tot)=='a'){
					aa=tot; break;
				}
			} if(aa!=-1){ res[i-1]=res[i]="Aa"; break; }
			int tmp=tot; res[i-1]=res[i]="AA";
			for(int j=1,k=tmp;j<=Q;++j){
				cross(i,k-j+1); ++tot;
				if(query(tot)=='a'){
					aa=tot; break;
				}
			} if(aa!=-1){ res[i-1]="Aa"; break; }
			for(int j=1,k=tmp;j<=Q;++j){
				cross(i+1,k-j+1); ++tot;
				if(query(tot)=='a'){
					aa=tot; break;
				}
			} if(aa!=-1){ res[i]="Aa"; break; }
		}
	} for(int i=0;i<n;++i){
		if(res[i]!="X")continue;
		for(int j=1;j<=P;++j){
			cross(aa,i+1); ++tot;
			if(query(tot)=='a'){ res[i]="Aa"; break; }
		} if(res[i]=="X")res[i]="AA";
	} return res;
}

mt19937_64 rnd(time(NULL));
vector<string>Ans;

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(nullptr); cout.tie(nullptr);
	int n; cin>>n; Ans.push_back("6");
	for(int i=1;i<=n;++i){
		string Str; cin>>Str; Ans.push_back(Str);
	} vector<string>pa=guess(n);
	for(int i=0;i<n;++i)cout<<pa[i]<<" "; cout<<'\n';
	return 0;
}

char query(int k){
	return Ans[k][0];
}

void cross(int i,int j){
	int X=rnd()%2,Y=rnd()%2;
	string _x=Ans[i],_y=Ans[j];
	char _X=_x[X],_Y=_y[Y];
	string res=""; res+=_X; res+=_Y;
	if(res=="aA")res="Aa";
	Ans.push_back(res);
}
```

---

## 作者：Exp10re (赞：1)

## 前言

![](https://cdn.luogu.com.cn/upload/image_hosting/2z41loal.png)

~~你怎么知道我的班主任是全校最帅的生物老师？~~

## 解题思路

下称 $\texttt{a}$ 表现型为隐性，$\texttt{A}$ 表现型为显性，$\texttt{AA}$ 为显性纯合子，$\texttt{Aa}$ 为杂合子，$\texttt{aa}$ 为隐性纯合子。

考虑上课学过的测交实验：

- 亲本 $P_1$ 与隐性纯合子 $P_2$ 进行测交，产生足够多的子代，若子代表现型全为显性，则 $P_1$ 为显性纯合子，否则为杂合子。

考虑初始给定的 $n$ 个种子当中存在 $\texttt{aa}$ 的情况：

- 如果我们要检测 $k$ 是否为显性纯合子，那么让其与 $\texttt{aa}$ 种进行测交实验产生 $\Delta_1$ 个子代，若子代全为显性，则认为 $k$ 为显性纯合子，否则认为 $k$ 为杂合子。

其中 $\Delta_1$ 取 $22$，原因是其最坏情况一共会测交 $n\Delta_1=4.4\times 10^5$ 次，并且其对于一个杂合子判断正确的概率为 $1-(\frac 1 2)^{\Delta_1}=\frac {2^{\Delta_1}-1} {2^{\Delta_1}}=\frac {2^{22}-1} {2^{22}}$。

那么对于一个数据点误判的概率为 $1-({\frac {2^{\Delta_1}-1} {2^{\Delta_1}}})^n \approx 0.995$，完全可以接受。

那么初始给定的 $n$ 个种子当中不存在 $\texttt{aa}$ 呢？我们就需要考虑通过 $\texttt{AA}$ 与 $\texttt{Aa}$ 杂交得到一个新的 $\texttt{Aa}$，再通过 $\texttt{Aa}$ 与 $\texttt{Aa}$ 杂交得到一个 $\texttt{aa}$，如果一直得不到 $\texttt{aa}$ 则我们认为初始种子全为 $\texttt{AA}$。

我们考虑选取随机一个亲本并假定其为 $\texttt{AA}$（大概率是 $\texttt{AA}$ 即使不是，那么大概率也会有另外一个 $\texttt{Aa}$，以下照常进行），尝试将其与剩下的所有种子使用以下方式杂交产生 $\texttt{aa}$，不难发现其概率为 $\frac 7 8$。

考虑使用这种方法进行 $\Delta_2$ 次，那么会进行 $2n\Delta_2=4.4\times 10^5$ 次杂交，因此可以选取 $\Delta_2=11$，其得到 $\texttt{aa}$ 概率为 $1-(\frac 7 8)^{\Delta_2} \approx 0.770$。

似乎不算高，但是我们可以重复提交~~大雾~~。

注意到与此同时我们可以检测前面若干个种子的基因型，那么总次数为 $n\max(\Delta_1,2\Delta_2)=4.4\times 10^5$，多交几次就过了。

## 代码

为了防止一个隐性纯合子多次杂交引起其不满，因此选取的隐性纯合子都是在所有隐性纯合子当中随机得到的~~伦敦大雾~~。

```cpp
#include<bits/stdc++.h>
using namespace std;
const long long MAXN=450200,Delta2=11,Delta1=22;
long long pre[MAXN],aans[MAXN],recessive[MAXN],m,cnt,N,lst;
vector<string> guess(int n);
char query(int k);
void cross(int i, int j);
long long getq(long long k);
long long getcross(long long ta,long long tb);
long long GetRecessive(long long ta,long long tb);
long long f(char c);

//--------------------

long long f(char c)
{
	if(c=='a')
	{
		return 0;
	}
	else
	{
		return 1;
	}
}
long long getq(long long k)
{
	return f(query(k));
}
long long GetR()
{
	return recessive[rand()%m+1];
}
long long getgene(long long k)// TestCross.
{
	long long i,j,t,vc;
	for(i=1;i<=Delta1;i++)
	{
		vc=getcross(k,GetR());
		t=getq(vc);
		if(t==0)
		{
			m++;
			recessive[m]=vc;
			return -1;
		}
	}
	return 1;//1=AA,-1=Aa.
}
long long getcross(long long ta,long long tb)
{
	cnt++;
	cross(ta,tb);
	return cnt+N;
}
long long getrnd(long long ta,long long tb)
{
	return (rand()*rand())%tb+ta;
}
long long GetRecessive()
{
	long long i,j,t,vc,tryit=0,endpos,ta,tb;
	
	for(i=1;i<=N;i++)
	{
		aans[i]=1;
		if(i==2)
		{
			continue;
		}
		endpos=N+cnt;
		for(j=1;j<=Delta2;j++)
		{
			cross(2,i);
			cnt++;
		}
		for(ta=1;ta<=Delta2-1;ta++)
		{
			vc=getcross(endpos+ta,i);
			t=getq(vc);
			if(t==0)
			{
				aans[i]=-1;
				m++;
				recessive[m]=vc;
				lst=i+1;
				return 1;
			}
		}
	}
	return 0;
}

//-----------------------

vector<string> guess(int n)
{
	N=n;
	srand(time(0));
	vector<string> ans;
	long long i,j,tt;
	for(i=1;i<=n;i++)
	{
		pre[i]=getq(i);
		if(pre[i]==0)
		{
			m++;
			recessive[m]=i;
			aans[i]=0;
		}
	}
	lst=1;
	if(m==0)
	{
		tt=GetRecessive();
		if(tt==0)
		{
			for(i=1;i<=n;i++)
			{
				ans.push_back("AA");
			}
			return ans;
		}
	}
	if(pre[2]==1)
	{
		aans[2]=getgene(2);
	}
	else
	{
		aans[2]=0;
	}
	for(i=lst;i<=n;i++)
	{
		if(pre[i]==1)
		{
			aans[i]=getgene(i);
		}
	}
	for(i=1;i<=n;i++)
	{
		if(aans[i]==1)
		{
			ans.push_back("AA");
		}
		if(aans[i]==0)
		{
			ans.push_back("aa");
		}
		if(aans[i]==-1)
		{
			ans.push_back("Aa");
		}
	}
	return ans;
}
```

---

## 作者：PassName (赞：0)

# P10384 题解

[题目传送门 P10384](https://www.luogu.com.cn/problem/P10384)

## solution
做这个题就当复习为期末考试复习生物了。

首先思考突破口，想要确定基因型，要么通过一个亲本和一个子代去推其另一个亲本，这种推是百分之百能推出来另一个亲本，但是子代要看运气。因为这个子代可能 $Aa$，这是我们不想看到的，因为 $Aa$ 与 $aa$，$AA$ 与 $Aa$ 等等都能整出来这个子代，我们不好推测其亲本。那么思路有了。

我们从子代为隐形纯合子入手，即 $aa$。考虑我们手中已有的一个已经推测出基因型的 $aa$ 为亲本，对其多次杂交直至出现 $aa$ 为子代，如果出现则说明另一个亲本为 $Aa$。显然的，这种杂交方式不能推测 $AA$，因为证据不足。假设我们只杂交了一次，那么 $Aa$ 与 $aa$ 的子代中 $Aa:aa=1:1$，即失败的可能性为 $\frac{1}{2}$。每多杂交一次，我们的失败可能性就会变为原来的 $50\%$，所以，通过这种方式多杂交几次确定其另一个亲本的成功性是非常高的。

但是，刚才的构造方案局限性在于，我们必须拥有一个隐形纯合子作为杂交基础，显然，我们刚开始是一无所有的，没有任何基因型信息。通过表型我们可以知道显性性状的有 $AA$ 和 $Aa$，但我们没有办法区分它们，这个时候接着赌了，随便从里边抽两个，$Aa$ 与 $Aa$ 杂交得出 $aa$ 的成功性为 $\frac{1}{4}$，$AA$ 与 $Aa$ 杂交得出 $aa$ 的成功性为 $0$，但是它们可以造出 $Aa$，那么我们拿它再次去与 $Aa$ 杂交就有可能搞到 $aa$。如果该方案理想，则成功可能性为 $\frac{1}{2^3}$。再来考虑假设以上过程的 $AA$ 为除本身外任意一只，那么大保底我们只需要两次就能确认。对于任意一个只，只用一次，我们确认的正确性为 $\frac{1}{2^3}$，次数越多正确性越高，但是显然这个耗费次数超级多。

大致方案有了以后，我们考虑去凑这个极限次数。在已知有 $aa$ 的情况下选 $13$，另一个选 $20$，亲测，这对数据一定能够保证在要求次数内解决问题并且通过率较高，用这组数据交了九发过的。代码实现怎么都行，但是友谊提示一下，没有必要记录强行让实验次数凑够上线，那样没有意义，本身就是个赌狗题，那样做会导致代码复杂度直线上升真的不如多交几发。

---

## 作者：lilong (赞：0)

一道相当不错的概率题。

首先考虑种子中存在 $\verb!aa!$ 的情况。显然，我们可以让每个不是 $\verb!aa!$ 的种子都与这个 $\verb!aa!$ 型的种子杂交，并检验杂交后的性状。若为 $\verb!a!$，则一定为 $\verb!Aa!$，否则可能是 $\verb!AA!$ 或 $\verb!Aa!$。不难想到多杂交几次，如果一直都显现出 $\verb!A!$ 则可以认为就是 $\verb!AA!$。取杂交次数为 $15$ 次时，错误率在 $2^{-15}$ 左右，完全可以接受。

如果种子中不存在 $\verb!aa!$，这样做不能够保证正确性。换一种思路想，对于给定的任意两颗种子，其可能的情况有 $\{ \verb!AA!,\verb!AA! \},\{ \verb!AA!,\verb!Aa! \},\{ \verb!Aa!,\verb!AA! \},\{ \verb!Aa!,\verb!Aa! \}$ 四种。第四种情况最好检验，有 $\frac{1}{4}$ 的概率出现 $\verb!a!$，而别的情况则不可能出现，因此做多几次杂交即可判断这种情况。

对于剩下的三种情况，继续分类讨论。显然，如果是 $\{ \verb!AA!\ ,\verb!AA! \}$，无论如何杂交都是 $\verb!AA!$。但如果是 $\{ \verb!AA!\ ,\verb!Aa! \}$ 或 $\{ \verb!Aa!\ ,\verb!AA! \}$，其子代中很大概率有 $\verb!Aa!$ 的出现。又由于两个亲代中一定有一个 $\verb!Aa!$，因此可能杂交出 $\verb!aa!$。如果出现了 $\verb!aa!$，则可以证明上述的情况。如果所有子代与亲代杂交都没有 $\verb!aa!$，则可以认为亲本都是 $\verb!AA!$。又因为 $15 \times 3 \times 10^4 = 4.5\times 10^5$，因此杂交 $15$ 次是较为合适的。此时的错误率也较低，交多几次就可以通过了。

如果杂交次数过多而无法通过，可以考虑一个简单的优化：如果当前已经杂交出了 $\verb!aa!$，则对剩余的种子可以直接用文章最前面的方法判断即可。

[AC 记录](https://www.luogu.com.cn/record/157447415)

```cpp
#include <bits/stdc++.h>

using namespace std;

char query(int k);
void cross(int i, int j);

int a[1000001];

vector<string> guess(int n)
{
	srand( time( 0 ) );
	vector<string> ans;
	int cnt = n,tot = 0,d = 0,flag,lst;
	char c;
	for( int i = 1 ; i <= n ; i ++ )
	{
		c = query( i );
		if( c == 'a' )
		{
			a[i] = 3;
			if( !d ) d = i;
		}
	}
	if( d )
	{
		for( int i = 1 ; i <= n ; i ++ )
		{
			if( a[i] == 3 ) continue;
			flag = 0;
			for( int t = 1 ; t <= 15 ; t ++ )
			{
				cnt ++;
				cross( i , d );
				if( query( cnt ) == 'a' )
				{
					flag = 1;
					break;
				}
			}
			if( flag ) a[i] = 2;
			else a[i] = 1;
		}
		for( int i = 1 ; i <= n ; i ++ )
		{
			if( a[i] == 1 ) ans.push_back( "AA" );
			if( a[i] == 2 ) ans.push_back( "Aa" );
			if( a[i] == 3 ) ans.push_back( "aa" );
		}
		return ans;
	}
	int i;
	for( i = 1 ; i <= n && !d ; i += 2 )
	{
		lst = cnt;
		for( int t = 1 ; t <= 14 && !d ; t ++ )
		{
			cnt ++;
			cross( i , i + 1 );
			if( query( cnt ) == 'a' )
			{
				d = cnt;
				a[i] = 2,a[i + 1] = 2;
				break;
			}
		}
		for( int t = 1 ; t <= 14 && !d ; t ++ )
		{
			cnt ++;
			cross( lst + t , i );
			if( query( cnt ) == 'a' )
			{
				d = cnt;
				a[i] = 2;
				break;
			}
			cnt ++;
			cross( lst + t , i + 1 );
			if( query( cnt ) == 'a' )
			{
			    a[i + 1] = 2;
				d = cnt;
				break;
			}
		}
		if( !a[i] ) a[i] = 1;
		if( !a[i + 1] ) a[i + 1] = 1;
	}
	for(  ; i <= n ; i ++ )
	{
		flag = 0;
		for( int t = 1 ; t <= 14 ; t ++ )
		{
			cnt ++;
			cross( i , d );
			if( query( cnt ) == 'a' )
			{
				flag = 1;
				break;
			}
		}
		if( flag ) a[i] = 2;
		else a[i] = 1;
	}
	for( int i = 1 ; i <= n ; i ++ )
	{
		if( a[i] == 1 ) ans.push_back( "AA" );
		if( a[i] == 2 ) ans.push_back( "Aa" );
		if( a[i] == 3 ) ans.push_back( "aa" );
	}
	return ans;
}
```

---


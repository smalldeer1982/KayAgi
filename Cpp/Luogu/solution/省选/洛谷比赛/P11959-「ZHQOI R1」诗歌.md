# 「ZHQOI R1」诗歌

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/51q9tydh.png)

淡く煌(きらめ)く傷口が

瞬間 世界を止めて

------------
长夜伴浪破晓梦，梦晓破浪伴夜长。


## 题目描述

给定正整数 $k$，本题的字符集大小为 $k$，我们用正整数 $i$ 来表示字符集中的第 $i$ 个字符。

给定正整数 $m$，定义一个字符串 $\mathcal{S}$ 为「动听」的，当且仅当 $\mathcal{S}$ 的长度小于 $m+2$，或在 $\mathcal{S}$ 中**任意**删除恰好 $m$ 个字符后都不存在一个长度大于 $1$ 的回文连续子串。

你需要处理 $q$ 次询问，每次给定一个长度为 $m+2$ 且「动听」的字符串 $T$，和一个不可重字符集合 $U$，试求出有几个长度为 $n$ 的字符串，满足以下条件：

- $T$ 为该字符串的一段前缀
- 该字符串是「动听」的
- 字符串最后一位属于 $U$

答案对 $998244353$ 取模。对于每组询问，$k$ 和 $m$ 是相同的。

**注意：本题数据保证 $k-m\ge3$。**

## 说明/提示

**【样例 1 解释】**

相当于给定一个串 `abc`，$U = \{a\}$，字符集合为 $\{a,b,c,d,e\}$，询问有多少长度为 $5$ 的串满足题意，容易发现有且仅有以下 $2$ 个：
```plain
abcda
abcea
```
故答案为 $2$。

**【样例 2 解释】**

相当于给定一个串  `abc`，$U = \{a,b\}$，字符集合为 $\{a,b,c,d,e\}$，询问有多少长度为 $7$ 的串满足题意，容易发现有且仅有以下 $6$ 个：

```plain
abceadb
abcdeab
abcedba
abcdeba
abcedab
abcdaeb
```

故答案为 $6$。

**【数据范围】**

对于所有测试点保证：$1 \leq n \leq 10^7$，$1 \leq q,m \leq 2 \times 10^3$，$m + 3 \leq k\le 10^9$，$U \subseteq [1,k]$，$T_i \in [1,k]$。

|测试点编号|$q=$|$n\le$|$m=$|$\sum\vert U\vert=$|特殊性质|
|:-:|:-:|:-:|:-:|:-:|:-:|
|$1$|$700$|$700$|$100$|$700$|$k-m=3$|
|$2$|$700$|$700$|$100$|$700$|无|
|$3$|$10^3$|$5\times 10^5$|$20$|$4\times 10^3$|无|
|$4$|$2\times 10^3$|$5\times 10^5$|$100$|$4\times10^3$|无|
|$5$|$2\times 10^3$|$5\times 10^5$|$100$|$10^6$|无|
|$6$|$2\times 10^3$|$2.5\times 10^5$|$10^3$|$4\times 10^3$|无|
|$7$|$2\times 10^3$|$5\times 10^5$|$2\times 10^3$|$4\times 10^3$|无|
|$8$|$2\times 10^3$|$2.5\times 10^5$|$10^3$|$10^6$|无|
|$9$|$2\times 10^3$|$5\times 10^5$|$2\times 10^3$|$10^6$|无|
|$10$|$2\times 10^3$|$10^7$|$2\times 10^3$|$2\times 10^6$|无|

## 样例 #1

### 输入

```
0
1 5 1
5 1 2 3 1 1```

### 输出

```
2```

## 样例 #2

### 输入

```
0
1 5 1
7 1 2 3 2 1 2```

### 输出

```
6```

## 样例 #3

### 输入

```
0
1 40 4
50 2 3 5 7 11 31 2 5 10
```

### 输出

```
732767443```

## 样例 #4

### 输入

```
0
1 12 1
12 3 5 7 1 7```

### 输出

```
32390928```

# 题解

## 作者：Zzzcr (赞：7)

### **注：这是一个小丑做法，若只是为通过此题不建议学习该题解。**

本题解中记 $N$ 为所有询问中 $n$ 的最大值。

***Observation 1***: 容易发现，只需要考虑长度为 $2$ 或 $3$ 的回文串即可。

 换句话说，一个串是动听的，当且仅当对于任意两个相同的字符，它们的下标之差大于 $m+2$。

***Observation 2***: 若一个字符串是「动听」的，则它的每个前缀都是「动听」的。

对于所有长度为 $n$ 的「动听」字符串，只需要在所有长度为 $n-1$ 的「动听」字符串后添加字符即可得到，这启发我们把所有「动听」的字符串建成一颗 trie。在每个 trie 的叶子节点上添加新节点的过程中，同时需要满足 trie 上不存在一条长度为 $m + 3$ 的存在相同字符的链。

考虑这颗 trie 的形态，它形如一个长度为 $m + 2$ 的链下挂一个完全 $k - m - 2$ 叉树。

本题所求的也就是 trie 上深度为 $n$ 且该字符属于 $U$ 的节点数量，注意到每一层的答案只与上一层总儿子数量和前 $m - 2$ 层的答案有关，可以 $\mathcal{O}(\sum{|U|}nm)$ 暴力 dp。

考虑把上述 dp 柿子记成矩阵形式，需要注意的是前 $m + 1$ 个转移与其他的转移并不相同，直接暴力转移，用倍增预处理出矩阵 $2^k$ 次幂，再把把初始向量叠加在一起，可以做到 $\mathcal{O}(qm^2\log n+m^3\log N+\sum{|U|})$。

---

考虑对上述过程逐步优化。

前 $\mathcal{O}(m)$ 次转移比较特殊，可以对这些转移的前缀预处理出系数矩阵 $p$，系数向量 $C$，使得 $f_k=\sum_{i=1}^{m+2} p_{k,i}f_i+|U|C_k$。具体的可以观察多项式之间的系数关系，对其分段。如何获得最终向量呢？实际上，这相当于选定一些关键列后对每行求和，观察矩阵 $p$，注意到它的每一列都可以拆成至多 2 段比值相同的等比数列，可以用扫描线做到关于 $|U|$ 线性。现在只需要 $p$ 中每列分界点的值了，容易发现这样的元素只有 $\mathcal{O}(m)$ 个，预处理可以做到 $\mathcal{O}(m)$。

本题式子可以写作 $f_n=\sum a_if_{n-i}+h^{n-m-3}\cdot |U|$，其中 $h,a_i$ 对每组询问不变。比常系数齐次线性递推多了一项幂函数。考虑构造序列 $g$，使得 $g_n=\sum \frac{a_ig_{n-i}}{h^i}+\frac{|U|}{h^{m+3}}=\frac {-1} h\sum g_{n-i}+\frac{|U|}{h^{m+3}}$，即 $f_n-g_nh^n=\sum a_i(f_{n-i}-g_{n-i}h^{n-i})$，所以只需要对 $f_i-g_ih^i$ 线性递推即可。

查询时只需要 $g$ 的前 $\mathcal{O}(m)$ 项和第 $n$ 项，前者可以询问时处理，后者的问题与求 $f_n-g_nh^n$ 是类似的，可以仿照下面对 $f_i-g_ih^i$ 线性递推的方式来做。

每次询问只有 $n$ 和初始向量不同。设 $F(x)$ 为转移的特征多项式，根据线性递推的过程，我们需要 $x^{n-m-3}\bmod F(x)\bmod x^{\mathcal{O}(m)}$，每次询问做一个 NTT 即可。预处理多项式求逆可以做到线性。具体的，考虑 $f(x)=1+ax+bx^t$ 的逆，记 $c_p=[x^p]f^{-1}(x)$，有
$$
c_p=\left\{\begin{matrix} 
  (-a)^p\ (p<t)\\
  -c_{p-1}\cdot a-c_{i-t}\cdot b\ (p\ge t)\\
\end{matrix}\right. 
$$

复杂度 $\mathcal{O}(N)\sim \mathcal{O}(m\log m)$。

最终我们做到了 $\mathcal{O}(qm\log m+N+\sum|U|)$。实现细节有点多，需要注意一下代码常数。

---

## 作者：yingkeqian9217 (赞：5)

赛时做法，不知道官方题解为什么这么复杂，赶紧来发个题解。

显然一个串是动听的充要条件是任意两个相同字符坐标差超过 $m+2$，即任意连续 $m+3$ 个字符两两不同。

注意到开头已经给了 $m+2$ 个字符，这启示我们直接往后填，不考虑末位字符的限制，每次要求与前面 $m+2$ 个字符均不同，有 $(k-(m+2))^{n-(m+2)}$ 种方案。

对每种字符进行考虑，如果这个字符在开头 $i$ 处出现过，则只会在 $i+m+3\sim n$ 这一段再次出现，将 $m+3\sim i+m+2$ 任意填上后，转化为一个只与余下长度有关而与当前字符无关的问题。

显然可以不考虑已确定的末位字符 $x$，然后考虑指定一些位置放 $x$，显然相邻位置差以及与末位的差都至少为 $m+2$，进一步地，如果一个位置之前 $m+2$ 位有 $x$，直接 $k-(m+2)$ 任意填，否则额外要求与 $x$ 不同，$k-(m+2)-1$ 种方案。

可以直接 dp，$f_i$ 表示前 $i$ 位的答案，有转移 $f_i=(k-(m+2)-1)f_{i-1}+(k-(m+2))^{m+2}f_{i-m-1}$。

时间复杂度 $O(n+qm)$，跑挺快的。

```cpp
#include<bits/stdc++.h>
#define maxn 2010
#define int long long
using namespace std;
const int Mod=998244353,N=1e7;
inline int reduce(int x){if(x>=Mod) return x-=Mod;return x;}

int q,k,m,f[N+100],bas[maxn];
inline int query(int x){
	if(x<0) return 0;
	return f[x];
}
inline void solve(){
	int res=1;
	scanf("%lld%lld%lld",&q,&k,&m);
	m+=2;
	bas[0]=1;
	for(int i=1;i<=m;i++) bas[i]=bas[i-1]*(k-m)%Mod;
	f[0]=1;
	for(int i=1;i<=N;i++){
		if(i>m) f[i]=(f[i-1]*(k-m-1)+f[i-m-1]*bas[m])%Mod;
		else f[i]=f[i-1]*(k-m-1)%Mod;
	}
	while(q--){
		int n;
		scanf("%lld",&n);
		unordered_map<int,int>mp;
		for(int i=1,x;i<=m;i++) scanf("%lld",&x),mp[x]=i;
		int len,ans=0;
		scanf("%lld",&len);
		while(len--){
			int x;
			scanf("%lld",&x);
			if(!mp.count(x)) ans=reduce(ans+query(n-m-1));
			else ans=(ans+query(n-mp[x]-m-1)*bas[mp[x]])%Mod;
		}
		printf("%lld\n",ans);
	}
}
signed main(){
	signed C,T=1;
	scanf("%d",&C);
	while(T--) solve();
	return 0;
}
```

---

## 作者：critnos (赞：2)

首先判定一个好串的充要条件明显是每个长度为 $m+3$ 的子串的字符都互不相同。考虑枚举答案的最后一位是 $U$ 中的啥，记做 $c$，因为已经填了最后一位所以可以钦定每个 $c$ 后面的 $m+2$ 个字符存在且不等于 $c$，当然还要把开头一段被 $t$ 中的 $c$ 影响的判掉，于是这类在 $c$ 后面 $m+2$ 个的字符有 $k-m-3$ 种填法，剩余位置是 $k-m-2$ 种填法。这个东西可以直接做一个 dp $O(n)$ 预处理，时间复杂度 $O(n+qm+\sum |U|)$。

开个玩笑，题外话：

![](https://img.picui.cn/free/2025/03/24/67e10b987dd11.png)

---

## 作者：happybob (赞：0)

存在长度大于 $1$ 的回文子串等价于存在长度为 $2$ 或 $3$ 的回文子串。

进一步可以看出，一个字符串 $s$ 是动听的，等价于对于任意 $s_i = s_j$ 且 $i<j$，都有 $j-i \geq m + 3$。

枚举字符串末尾 $x \in U$，考虑从 $m+3$ 位填到 $n-1$ 位。记 $f_i$ 表示填到第 $i$ 位，且下一位可以填 $u$ 的方案数。转移形如 $f_i = (k-m-3)f_{i-1} + (k-m-2)^{m+2}f_{i-m-3}$，顺着推含义是要么 $i+1$ 位填的不是 $x$，要么 $i+1$ 填了 $x$ 且后 $m+2$ 位全都不是 $x$。

当 $x$ 不在给定前缀中时，贡献即为 $f_{n-1}$，否则考虑 $x$ 在前缀第 $i$ 位，则前缀需要先填 $x$ 步，所以答案是 $f_{n-1-i} \times (k-m-2)^{i}$。

复杂度 $O(n+ mq)$。

---


# [SDOI2009] 晨跑

## 题目描述

Elaxia 最近迷恋上了空手道，他为自己设定了一套健身计划，比如俯卧撑、仰卧起坐等等，不过到目前为止，他坚持下来的只有晨跑。 

现在给出一张学校附近的地图，这张地图中包含 $N$ 个十字路口和 $M$ 条街道，Elaxia 只能从 一个十字路口跑向另外一个十字路口，街道之间只在十字路口处相交。

Elaxia 每天从寝室出发跑到学校，保证寝室编号为 $1$，学校编号为 $N$。 

Elaxia 的晨跑计划是按周期（包含若干天）进行的，由于他不喜欢走重复的路线，所以在一个周期内，每天的晨跑路线都不会相交（在十字路口处），寝室和学校不算十字路口。

Elaxia 耐力不太好，他希望在一个周期内跑的路程尽量短，但是又希望训练周期包含的天数尽量长。

除了练空手道，Elaxia 其他时间都花在了学习和找 MM 上面，所有他想请你帮忙为他设计 一套满足他要求的晨跑计划。

可能存在 $1\rightarrow n$ 的边。这种情况下，这条边只能走一次。

## 说明/提示

- 对于 $30\%$ 的数据，$N\le 20$，$M \le 120$。
- 对于 $100\%$ 的数据，$N\le 200$，$M\le 2\times 10^4,1\le c\le 10^4$。

## 样例 #1

### 输入

```
7 10
1 2 1
1 3 1
2 4 1
3 4 1
4 5 1
4 6 1
2 5 5
3 6 6
5 7 1
6 7 1```

### 输出

```
2 11
```

# 题解

## 作者：Siyuan (赞：28)

[$$\Large\texttt{My Blog}$$](https://hydingsy.github.io/)

---

## Description

> 题目链接：[Luogu 2153](https://www.luogu.org/problemnew/show/P2153)

Elaxia 最近迷恋上了空手道，他为自己设定了一套健身计划，比如俯卧撑、仰卧起坐等 等，不过到目前为止，他坚持下来的只有晨跑。现在给出一张学校附近的地图，这张地图中包含 $n$ 个十字路口和 $m$ 条街道，Elaxia 只能从一个十字路口跑向另外一个十字路口，街道之间只在十字路口处相交。Elaxia 每天从寝室出发跑到学校，保证寝室编号为 $1$，学校编号为 $n$。Elaxia 的晨跑计划是按周期（包含若干天）进行的，由于他不喜欢走重复的路线，所以在一个周期内，每天的晨跑路线都不会相交（在十字路口处），寝室和学校不算十字路口。Elaxia 耐力不太好，他希望在一个周期内跑的路程尽量短，但是又希望训练周期包含的天数尽量长。

数据范围：$1\le n\le 200$，$1\le m\le 2\times 10^4$

------

## Solution

首先我们发现需要求**路程最短，天数尽量长**。那么我们可以考虑**最小费用最大流**，其中路程为费用，天数为流量。

由于每个点只能被访问 $1$ 次，那么我们进行拆点，将 $i$ 拆成 $i_1$ 和 $i_2$，其中 $i_1$ 和 $i_2$ 之间连边 $(i_1,i_2,1,0)$（容量为 $1$，费用为 $0$），对于有向图的每条边 $(u,v,w)$ 连边 $(u_2,v_1,1,w)$ 和其反向边 $(v_1,u_2,0,-w)$。

又因为 $1$ 和 $n$ 可以多次经过，那么源点和汇点分别为 $s_2$ 和 $t_1$，然后直接跑网络流即可。

**时间复杂度**：$O(nmf)$

------

## Code

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>

const int N=4e2+5,M=1e5+5;
const int INF=0x3f3f3f3f;
int n,m,tot=1,lnk[N],cnr[N],ter[M],nxt[M],cap[M],cost[M],dis[N],ret;
bool vis[N];

void add(int u,int v,int w,int c) {
    ter[++tot]=v,nxt[tot]=lnk[u],lnk[u]=tot,cap[tot]=w,cost[tot]=c;
}
void addedge(int u,int v,int w,int c) {
    add(u,v,w,c),add(v,u,0,-c);
}
int spfa(int s,int t) {
    memset(dis,0x3f,sizeof(dis));
    memcpy(cnr,lnk,sizeof(lnk));
    std::queue<int> q;
    q.push(s),dis[s]=0,vis[s]=1;
    while(!q.empty()) {
        int u=q.front(); q.pop(),vis[u]=0;
        for(int i=lnk[u];i;i=nxt[i]) {
            int v=ter[i];
            if(cap[i]&&dis[v]>dis[u]+cost[i]) {
                dis[v]=dis[u]+cost[i];
                if(!vis[v]) q.push(v),vis[v]=1;
            }
        }
    }
    return dis[t]!=INF;
}
int dfs(int u,int t,int flow) {
    if(u==t) return flow;
    vis[u]=1;
    int ans=0;
    for(int i=cnr[u];i;i=nxt[i]) {
        cnr[u]=i;
        int v=ter[i];
        if(!vis[v]&&cap[i]&&dis[v]==dis[u]+cost[i]) {
            int x=dfs(v,t,std::min(cap[i],flow-ans));
            if(x) ret+=x*cost[i],cap[i]-=x,cap[i^1]+=x,ans+=x;
        }
    }
    vis[u]=0;
    return ans;
}
int mcmf(int s,int t) {
    int ans=0;
    while(spfa(s,t)) {
        int x;
        while((x=dfs(s,t,INF))) ans+=x;
    }
    return ans;
}
int main() {
    scanf("%d%d",&n,&m);
    while(m--) {
        int u,v,c;
        scanf("%d%d%d",&u,&v,&c);
        addedge(u+n,v,1,c);
    }
    for(int i=1;i<=n;++i) addedge(i,i+n,1,0);
    int s=1+n,t=n;
    int ans=mcmf(s,t);
    printf("%d %d\n",ans,ret);
    return 0;
}
```

---

## 作者：半仙胡小桃 (赞：7)

红果果的最小费用最大流模板

从x到y连一条边，容量为1（因为路只能走一遍），权值为k。

但是要注意一点就是不能走重复的路线，所以在一个周期内，每天的晨跑路线都不会相交（在十字路口处）

所以把每个点拆成入点和出点，容量为1，权值为0就可以保证每个点只访问一遍啦233

对于起点为1或者是终点为n的路要特殊处理一下，因为学校和宿舍不视为十字路口
















```cpp
#include <iostream>  
#include <queue>  
#include <string.h>  
#include <cstdio>
using namespace std;  
int maxData = 0x7fffffff; 
queue<int> dl;
int head[5001],cost[100001],net[100001],to[100001],cap[100001];
int cnt=1;
int tot=0; 
void add(int x,int y,int c,int z)
{
    to[++cnt]=y;
    cost[cnt]=z;
    cap[cnt]=c;
    net[cnt]=head[x];
    head[x]=cnt;
}
int flow[5001];
int pre[5001];
int xb[5001];
int mflow=0;
int mcost=0;
int dis[5001];
int f[5001];
int n,m;
void make_map(int from,int ds,int cost1)
{
    if(from==1)//当起点为1时，从起点到终点的入点连一条边
    {
        add(1,ds,1,cost1);
        add(ds,1,0,-cost1);
        return;
    }
    if(ds==n)//当终点为n时，从起点的出点到n连一条边
    {
        add(from+n,n,1,cost1);
        add(n,from+n,0,-cost1);
        return;
    }
    add(from+n,ds,1,cost1);//起点不是1，终点不是n，从起点的出点到终点的入点连一条边
    add(ds,from+n,0,-cost1);
    return;
}
int BFS(int s,int t)
{
    memset(dis,127,sizeof(dis));
    memset(f,0,sizeof(f));
    int INF=dis[0];
    while(!dl.empty())
     dl.pop();
    for(int i=1;i<=n;i++)
     pre[i]=-1;
    f[s]=1;
    dis[s]=0;
    pre[s]=0;
    flow[s]=maxData;
    dl.push(s);
    while(!dl.empty())
    {
        int dd=dl.front();
        dl.pop();
        f[dd]=0;
        for(int i=head[dd];i;i=net[i])
        {
            int tmp=to[i];
            if(cap[i]>0&&dis[tmp]>dis[dd]+cost[i])
           {
              dis[tmp]=dis[dd]+cost[i];
              pre[tmp]=dd;
              xb[tmp]=i;
              flow[tmp]=min(flow[dd],cap[i]);
              if(!f[tmp]) f[tmp]=1,dl.push(tmp);
           }
        }
    }
    if(dis[t]>=INF) return 0;
    return 1;
}
void max_flow(int s,int t)
{
    while(BFS(s,t))
    {
        int k=t;
        while(k!=s)
         {
             cap[xb[k]]-=flow[t];
             cap[xb[k]^1]+=flow[t];
             k=pre[k];
         } 
        mflow+=flow[t];
        mcost+=flow[t]*dis[t];
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=2;i<n;i++)
     add(i,i+n,1,0),add(i+n,i,0,0);//预处理出入点与出点之间的路，模拟路径不能交叉的过程
    for(int i=1;i<=m;i++)
     {
         int x,y,c,d;
         scanf("%d%d%d",&x,&y,&d);
         make_map(x,y,d); //添加边
     }
    max_flow(1,n);
    printf("%d %d",mflow,mcost);//输出
    return 0;
}
```

---

## 作者：1saunoya (赞：4)

[$\texttt{my blog}$](https://www.cnblogs.com/Isaunoya/p/11997189.html)

[[SDOI2009]晨跑](https://www.luogu.com.cn/problem/P2153)


最小费用最大流的板子题吧

令 $i'=i+n$
$i -> i'$ 建一条流量为1费用为0的边这样就不会对答案有贡献
其次是对 $m$ 条边建 $u'->v$ 流量为1费用为cost反向为0费用为-cost （单向边，不管

这样建图就有从必须令 $1'$为源点 $n$ 为汇点
然后每条流的路线都是 $1' -> u_1 -> u_1' -> u_2 -> u_2' -> ... -> n$

于是就可以直接MCMF板子……

```cpp
#include <bits/stdc++.h>
using namespace std ;
using ll = long long ;
using pii = pair < int , int > ;
void read(int & x) {
  char c = x = 0 ; bool f = 1 ;
  while(c < '0' || c > '9') { if(c == '-') f = 0 ; c = getchar() ; }
  while(c >= '0' && c <= '9') { x = (x << 1) + (x << 3) + (c & 15) ; c = getchar() ; }
  x = f ? x : -x ;
}
int n , m , s , t ;
const int N = 5e3 + 10 ;
const int M = 5e4 + 10 ;
namespace MCMF {
  void cmax(int & x , int y) { if(x < y) x = y ; }
  void cmin(int & x , int y) { if(x > y) x = y ; }
  struct Edge { int v , nxt , f , c ; } e[M << 1] ;
  int cnt = 1 , head[N] , pre[N] , dis[N] , vis[N] ;
  void add(int u , int v , int flow , int cost) {
    e[++ cnt] = { v , head[u] , flow , cost } ; head[u] = cnt ;
    e[++ cnt] = { u , head[v] , 0 , -cost } ; head[v] = cnt ;
  }
  bool spfa(int s) {
    memset(dis , 0x3f , sizeof(dis)) ;
    queue < int > q ; dis[s] = 0 ; q.push(s) ;
    while(q.size()) {
      int u = q.front() ; q.pop() ; vis[u] = 0 ;
      for(int i = head[u] ; i ; i = e[i].nxt) {
        int v = e[i].v ;
        if(dis[v] > dis[u] + e[i].c && e[i].f) {
          dis[v] = dis[u] + e[i].c ; pre[v] = i ;
          if(! vis[v]) { vis[v] = 1 ; q.push(v) ; }
        }
      }
    }
    return (dis[t] ^ dis[0]) ;
  }
  int upd(int & maxflow) {
    int p = 0 , mn = 1e9 , cost = 0 ;
    for(int u = t ; u ^ s ; u = e[p ^ 1].v) cmin(mn , e[p = pre[u]].f) ;
    for(int u = t ; u ^ s ; u = e[p ^ 1].v) { e[p = pre[u]].f -= mn ; e[p ^ 1].f += mn ; cost += e[p].c * mn ; }
    return maxflow += mn , cost ;
  }
  void EK(int & maxflow , int & mincost) { while(spfa(s)) mincost += upd(maxflow) ; }
}
using namespace MCMF ;
signed main() {
  read(n) ; read(m) ; s = n + 1 ; t = n ;
  for(int i = 1 ; i <= m ; i ++) { int u , v , flow = 1 , cost ; read(u) ; read(v) ; read(cost) ; add(u + n , v , flow , cost) ; }
  for(int i = 1 ; i <= n ; i ++) { add(i , i + n , 1 , 0) ; }
  int maxflow = 0 , mincost = 0 ;
  EK(maxflow , mincost) ;
  printf("%d %d\n" , maxflow , mincost) ;
  return 0 ;
}
```

---

## 作者：Yeji_ (赞：4)

### 前言
我这个普及都没上的小蒟蒻来刷紫题了

### 题意
这个人啊，就是想要跑步，又想跑的时间短，又想天数长（~~真是个懒人~~）

根据这一种特性，就应该知道是网络流了，如果最小费用最大流还没有看过的，左转模板区。

### 做法
我们把路程看做是费用，把天数看做是流量。

然后按照题意开始乱连边，没错，让程序跑去吧

#### 但是，WAWAWAWA

你会惊讶的发现，你竟然会有答案错误，可能，你有些东西，没考虑到、
那就是——拆点

这是为甚么，请看下图
![](https://cdn.luogu.com.cn/upload/pic/56387.png)

你跑出来的东西一定会是2

#### 这是为什么？？？

#### 原因：中间点被跑了两遍！！！

#### 方法　在这就要引入拆点了！！！

### 拆点
这一类问题，一个图给出了点权而不是边权，我们在连接边的时候就显得十分不好操作

这个时候我们往往就会有这样一种操作，把每个点拆成入点和出点

题目给出的连边均由每个点的出点连向入点，然后每个点的入点和出点之间连一条流量为点权的边，就可以满足点权的限制了。

所以这道就很容易解了

这样，答案就对了，如下图
![](https://cdn.luogu.com.cn/upload/pic/56389.png)


现在给出代码
```cpp
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
bool vis[100010];
int n,m,s,t,x,y,z,f,dis[100010],pre[100010],nxt[100010],flow[100010],maxflow,mincost,st[100010],tot=1; 
struct Edge
{
    int to,nxt,flow,dis;
}edge[100010];
void add(int from,int to,int flow,int dis)
{
    edge[++tot].nxt=st[from];
    edge[tot].to=to;
    edge[tot].flow=flow;
    edge[tot].dis=dis;
    st[from]=tot;
}
bool spfa(int s,int t)
{
    queue <int> q;
    memset(dis,0x7f,sizeof dis);
    memset(flow,0x7f,sizeof flow);
    memset(vis,0,sizeof vis);
    q.push(s); 
    vis[s]=1;dis[s]=0;pre[t]=-1;
    while (!q.empty())
    {
        int now=q.front();
        q.pop();
        vis[now]=0;
        for (int i=st[now];i!=-1;i=edge[i].nxt)
        {
            if (edge[i].flow>0 && dis[edge[i].to]>dis[now]+edge[i].dis) 
            {
                dis[edge[i].to]=dis[now]+edge[i].dis;
                pre[edge[i].to]=now;
                nxt[edge[i].to]=i;
                flow[edge[i].to]=min(flow[now],edge[i].flow);
                if (!vis[edge[i].to])
                {
                    vis[edge[i].to]=1;
                    q.push(edge[i].to);
                }
            }
        }
    }
    return pre[t]!=-1;
}
void MCMF()
{
    while (spfa(s,t))
    {
        int now=t;
        maxflow+=flow[t];
        mincost+=flow[t]*dis[t];
        while (now!=s)
        {
            edge[nxt[now]].flow-=flow[t];
            edge[nxt[now]^1].flow+=flow[t];
            now=pre[now];
        }
    }
}
int main()
{
    memset(st,-1,sizeof st); 
    scanf("%d%d",&n,&m);
    s=1+n,t=n;
    for (int i=1;i<=m;i++)
    {
        scanf("%d%d%d",&x,&y,&f);
        add(x+n,y,1,f); 
        add(y,x+n,0,-f);
    }
    for (int i=1;i<=n;i++)
    {
    	add(i,i+n,1,0);
    	add(i+n,i,0,0);
    }
    MCMF();
    printf("%d %d",maxflow,mincost);
}
```


---

## 作者：SofanHe (赞：4)

## 题目分析

如果不算路的长度的话,就是最大流.

为什么?

最长的周期,每个路口都只能一次,就是说不重复选取问题啊.

网络流24题上的最长不下降子序列问题就是这样的一个模型.

考虑路长,又要求最小,自然就能想到最小费用最大流啊.

## 模型建立

每个点只能经过一次	--->	一个点拆成两个点,中间连为最大流为1,费用为0的边.

1号点和n号点可以重复经过	--->	一号点中间的边最大流为inf,n号点中间的边最大流为inf.

有一群有向路径	--->	有向路,从起点的第二个点连向终点的第一个点,费用为路长.

每个路可以经过好多次	--->	↑这种边的流量就是inf啊.

**源点和汇点不能直接相连**	--->	特判有向边起点为1,重点为n的,最大流改成1.

## 对拍Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int Smax =   50000;
const int Pmax = 	 500;
const int inf = 20010509;
int n,m,s,t,p1,p2,p3,to[Smax<<1],net[Smax<<1],mf[Smax<<1],mo[Smax<<1],tails=1,fr[Pmax];
void add(int froms,int tos,int mfs,int money){
	to[++tails]=tos;
	net[tails]=fr[froms];
	mf[tails]=mfs;
	mo[tails]=money;
	fr[froms]=tails;
}
void auto_add(int froms,int tos,int mfs,int mo){
	add(froms,tos,mfs,mo);
	add(tos,froms,0,-mo);
}
int lastp[Pmax],useds[Pmax],flown[Pmax],dis[Pmax],ndo,p4;
bool inqu[Pmax];
queue<int>ready;
bool SPFA(){
	memset(inqu,0,sizeof(inqu));
	memset(dis,20010509,sizeof(dis));
	memset(flown,20010509,sizeof(flown));
	while(!ready.empty())ready.pop();ready.push(s);
	dis[s]=0;inqu[s]=1;flown[s]=20010509;lastp[t]=0;
	while(!ready.empty()){
		ndo=ready.front();
		ready.pop();inqu[ndo]=0;
		for(int lzh=fr[ndo];lzh;lzh=net[lzh]){
			if(dis[to[lzh]]>dis[ndo]+mo[lzh] && mf[lzh]){
				dis[to[lzh]]=dis[ndo]+mo[lzh];
				flown[to[lzh]]=min(mf[lzh],flown[ndo]);
				useds[to[lzh]]=lzh;
				lastp[to[lzh]]=ndo;
				if(!inqu[to[lzh]]){
					inqu[to[lzh]]=1;
					ready.push(to[lzh]);
				}
			}
		}
	}
	return lastp[t]!=0;
}
int maxflow=0,mincost=0,ppo;
void Dinic(){
	while(SPFA()){
		maxflow+=flown[t];ppo=t;
		mincost+=flown[t]*dis[t];
		while(ppo!=s){
			mf[useds[ppo]]-=flown[t];
			mf[useds[ppo]^1]+=flown[t];
			ppo=lastp[ppo];
		}
	}
}
int gnum(int x,int p){return (x<<1)-1+p;}
int main(){
	scanf("%d%d",&n,&m);
	s=497;t=498;
	auto_add(gnum(1,0),gnum(1,1),inf,0);
	for(int i=2;i<n;++i)
		auto_add(gnum(i,0),gnum(i,1),1,0);
	auto_add(gnum(n,0),gnum(n,1),inf,0);
	auto_add(s,gnum(1,0),inf,0);
	auto_add(gnum(n,1),t,inf,0);
	for(int i=1;i<=m;++i){
		scanf("%d%d%d",&p1,&p2,&p3);
		if(p1==1&&p2==n)
			auto_add(gnum(1,1),gnum(n,0),1,p3);
		else
			auto_add(gnum(p1,1),gnum(p2,0),inf,p3);
	}
	Dinic();
	printf("%d %d",maxflow,mincost);
	return 0;
}
```

---

## 作者：Drinkkk (赞：3)

【参考资料】

liusu201601的博客 - bzoj1877: [SDOI2009]晨跑（最小费用最大流+模板）：https://blog.csdn.net/liusu201601/article/details/79443323 。

半仙胡小桃的博客 - 题解 P2153 【[SDOI2009]晨跑】：https://hentai008.blog.luogu.org/solution-p2153 。

【题目描述】

Elaxia最近迷恋上了空手道，他为自己设定了一套健身计划，比如俯卧撑、仰卧起坐等等，不过到目前为止，他坚持下来的只有晨跑。现在给出一张学校附近的地图，这张地图中包含$n$个十字路口和$m$条街道，Elaxia只能从 一个十字路口跑向另外一个十字路口，街道之间只在十字路口处相交。Elaxia每天从寝室出发 跑到学校，保证寝室编号为$1$，学校编号为$n$。 Elaxia的晨跑计划是按周期（包含若干天）进行的，由于他不喜欢走重复的路线，所以 在一个周期内，每天的晨跑路线都不会相交（在十字路口处），寝室和学校不算十字路 口。Elaxia耐力不太好，他希望在一个周期内跑的路程尽量短，但是又希望训练周期包含的天 数尽量长。 除了练空手道，Elaxia其他时间都花在了学习和找MM上面，所有他想请你帮忙为他设计 一套满足他要求的晨跑计划。

存在$1->n$的边存在。这种情况下，这条边只能走一次。

【输入输出格式】

- 输入格式
第一行：两个数$n,m$。表示十字路口数和街道数。 接下来$m$行，每行$3$个数$a,b,c$，表示路口$a$和路口$b$之间有条长度为$c$的街道（单向）。

- 输出格式
两个数，第一个数为最长周期的天数，第二个数为满足最长天数的条件下最短的路程长度。

【输入输出样例】

- 输入样例
```
7 10
1 2 1
1 3 1
2 4 1
3 4 1
4 5 1
4 6 1
2 5 5
3 6 6
5 7 1
6 7 1
```
- 输出样例
```
2 11
```

【数据范围】

对于$30\%$的数据，$n \leq 20,m \leq 120$。

对于$100\%$的数据，$n \leq 200,m \leq 20000$。

【题解】

因为不能走重复的路线，所以在一个周期内，每天的晨跑路线都不会相交（在十字路口处）。

所以把每个点拆成入点和出点，容量为$1$，权值为$0$就可以保证每个点只访问一遍啦233。

建边方法：

先$ins(st,n+1,inf,0),ins(n,ed,inf,0)$，再$ins(i,i+n,1,0)(2 \leq n \leq n-1)$，接着$ins(a+n,b,1,c)$就可以了~

下面上AC代码~
```
#include <cstdio>
#include <cstring>
#define inf 999999999
int len=0,tou=0,wei=0,st=0,ed=0,n=0,m=0;
struct nodea{ int d,v,f; } a[1001];
struct nodeb{ int x,y,c,d,f,gg; } b[1000001];
int la[1001],l[1001];
void ins(int x,int y,int c,int d)
{
	len++;
	b[len].x=x;
	b[len].y=y;
	b[len].c=c;
	b[len].d=d;
	b[len].gg=la[x];
	la[x]=len;
	
	len++;
	b[len].x=y;
	b[len].y=x;
	b[len].c=0;
	b[len].d=-d;
	b[len].gg=la[y];
	la[y]=len;
	
	b[len-1].f=len;
	b[len].f=len-1;
}
bool spfa()
{
	for(int i=1;i<=ed;i++)
	{
		a[i].v=0;
		a[i].d=inf;
	}
	a[st].d=0,a[st].v=1,l[1]=st;
	tou=1,wei=2;
	while(tou!=wei)
	{
		int x=l[tou];
		for(int i=la[x];i>0;i=b[i].gg)
		{
			int y=b[i].y;
			if(a[y].d>a[x].d+b[i].d && b[i].c>0)
			{
				a[y].f=i;
				a[y].d=a[x].d+b[i].d;
				if(a[y].v==0)
				{
					a[y].v=1;
					l[wei++]=y;
					if(wei>ed)
					{
						wei=1;
					}
				}
			}
		}
		a[x].v=0;
		tou++;
		if(tou>ed)
		{
			tou=1;
		}
	}
	int x=ed;
	while(x!=st)
	{
		int i=a[x].f;
		b[i].c--;
		b[b[i].f].c++;
		x=b[i].x;
	}
	if(a[ed].d==inf)
	{
		return false;
	}
	return true;
}
int main()
{
	int ans=0,su=0;
	scanf("%d %d",&n,&m);
	memset(la,0,sizeof(la));
	st=1,ed=n*2;
	ins(1,n+1,inf,0),ins(n,n*2,inf,0);
	for(int i=2;i<=n-1;i++)
	{
		ins(i,i+n,1,0);
	}
	for(int i=1;i<=m;i++)
	{
		int x=0,y=0,c=0;
		scanf("%d %d %d",&x,&y,&c);
		ins(x+n,y,1,c);
	}
	while(spfa()==true)
	{
		ans++;
		su+=a[ed].d;
	}
	printf("%d %d",ans,su);
	return 0;
}
```

---

## 作者：Minakami_Yuki (赞：1)

老是这种套路就没意思了。
具体可见：
- [P1402 酒店之王](https://www.luogu.org/problemnew/show/P1402)
- [P1231 教辅的组成](https://www.luogu.org/problemnew/show/P1231)

都是一样的套路。只不过这题换成了费用流。
# 题目链接

[P2153 [SDOI2009]晨跑](<https://www.luogu.org/problemnew/show/P2153>)

# 题意简述

求给定网络的最大流与最小费用，其中每个点仅允许经过一次。

<!--more-->

# 解题思想

看到对点的限制，考虑拆点为边。

不妨将每个点拆成$i$和$i + n$两个点，在中间连接一条**流量为1**的边，并且点$i$出度为1，点$i + n$入度为1.

这样可以限制每个点的经过次数一定为1。

然后在新图中以$1 + n$为原点，$n$为汇点跑**EK+SPFA**就行了。

# 参考代码

```cpp
#include <cstdio>
#include <cctype>
#include <cstring>

namespace FastIO {
    inline int read() {
        char ch = getchar(); int r = 0, w = 1;
        while(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();}
        while(isdigit(ch)) r = r * 10 + ch - '0' , ch = getchar();
        return r * w;
    }
    void _write(int x) {
        if(x < 0) putchar('-'), x = -x;
        if(x > 9) _write(x / 10);
        putchar(x % 10 + '0');
    }
    inline void write(int x) {
        _write(x);
        putchar(' ');
    }
}

using namespace FastIO;

const int N = 10006;
const int M = 2000006;
const int INF = 0x3f3f3f3f;

template <typename T> T min(T a, T b) {return a < b ? a : b;}

template <typename T>
class queue {
    private:
        int head, tail;
        T q[N << 1];
    public:
        queue() {head = tail = 0;}
        inline bool empty() {return head >= tail;}
        inline void push(T x) {q[++tail] = x;}
        inline void pop() {if(!empty()) head++;}
        inline T front() {return q[head + 1];}
};

int head[N], ver[M], edge[M], cost[M], nxt[M], pre[N], incf[N], d[N];
int cnt = 1, n, m, s, t, maxflow, mincost;
bool v[N];

inline void add(int x, int y, int z, int w) {
    ver[++cnt] = y, edge[cnt] = z, cost[cnt] =  w, nxt[cnt] = head[x], head[x] = cnt;
    ver[++cnt] = x, edge[cnt] = 0, cost[cnt] = -w, nxt[cnt] = head[y], head[y] = cnt;
}

inline bool spfa() {
    for(register int i = 1; i <= n << 1; i++) v[i] = 0, d[i] = INF;
    queue <int> q;
    q.push(s);
    d[s] = 0;
    v[s] = 1;
    incf[s] = INF;
    while(!q.empty()) {
        int x = q.front();
        q.pop();
        v[x] = 0;
        for(register int i = head[x]; i; i = nxt[i]) {
            int y = ver[i], z = edge[i], w = cost[i];
            if(!z) continue;
            if(d[y] > d[x] + w) {
                d[y] = d[x] + w;
                incf[y] = min(incf[x], z);
                pre[y] = i;
                if(!v[y]) {
                    v[y] = 1;
                    q.push(y);
                }
            }
        }
    }
    return d[t] != INF;
}

inline void upd() {
    maxflow += incf[t];
    mincost += incf[t] * d[t];
    int x = t;
    while(x != s) {
        int i = pre[x];
        edge[i] -= incf[t];
        edge[i ^ 1] += incf[t];
        x = ver[i ^ 1];
    }
}
 
int main() {
    n = read(), m = read();
    for(register int i = 1; i <= m; i++) {
        int x = read(), y = read(), z = read();
        add(x + n, y, 1, z);
    }
    for(register int i = 1; i <= n; i++) {
        add(i, i + n, 1, 0);
    }
    s = 1 + n, t = n;
    while(spfa()) upd();
    write(maxflow);
    write(mincost);
    return 0;
}
```

~~为什么我的数组总是开小啊QAQ~~



---

## 作者：ZBHRuaRua (赞：0)

## 蒟蒻第一次学费用流，记录一下心得

首先，要了解一个概念：可行流与最大流。

可行流：每条弧 ( u, v )上 给定一个实数f(u,v),满足：

有 0 <= f ( u, v ) <= c( u, v ),则f(u,v)称为弧( u, v )上的流量。

如果有一组流量满足条件：

          源点s：流出量 = 整个网络的流量
          汇点t：流入量 =整个网络的流量
          中间点：总流入量 = 总流出量
          
那么整个网络中的流量成为一个可行流。

而在所有可行流中，最大流量的一个流的流量称为最大流。

最大流的基本算法：EK和DINIC，这里不做赘述。（需要者可先去学习EK算法，可以直接学习费用流）

那么何谓费用流？

### “如果一个网络的边不仅有容量，还有单位流量费用的话，那我们自然想在求得最大流的同时，使总费用更低。”

这就是最小费用最大流，同样的还有最大费用最大流等等，都是类似的。

回到这道题，这道题题面很明显是一道最小费用最大流的板子，不过麻烦的地方在于，需要保证每个点只经过一次，而我们在网络流中容量是赋予给边的，这该如何处理？

### Easy，将一个点拆成两个，一个为入点，一个为出点，再在入点和出点中连接一条容量为1，费用为0的边即可。

然后就是愉快的跑费用流时间了，代码很简单，类似EK算法的思想，我们只要一直跑SPFA（BFS）直到跑不了为止，然后在每次跑完后都将新的流量和费用加到maxflow和mincost中，再从汇点回溯，将正向边流量减去，反向边流量加上即可，不明白这个操作的同样先去学最大流。

费用流初始将反向边费用设为-c，原理和最大流中反向边容量设为0类似，因为mincost的计算是两者相乘。

下面是代码时间：

```
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<iostream>
#include<iomanip>
#include<algorithm>
#include<queue>
using namespace std;
int n,m;
int cnt=1;
int ver[80050];
int nxt[80050];
int head[405];
int flow[80050];
int dis[80050];
int s,t;
int mincost;
int maxflow;
bool bj[405];
int low[405];
int lastd[405];
int lastb[405];
int d[405];
inline void add(int x,int y,int flo,int d)
{
	cnt++;
	ver[cnt]=y;
	nxt[cnt]=head[x];
	flow[cnt]=flo;
	dis[cnt]=d;
	head[x]=cnt;
}
inline bool spfa()
{
	memset(lastd,0,sizeof(lastd));
	memset(lastb,0,sizeof(lastb));
	memset(low,63,sizeof(low));
	memset(bj,0,sizeof(bj));
	memset(d,63,sizeof(d));
	queue<int> q;
	q.push(s);
	bj[s]=1;
	d[s]=0;
	lastb[t]=-1;
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		bj[x]=0;
		for(int i=head[x];i;i=nxt[i])
		{
			if(flow[i]>0&&d[ver[i]]>d[x]+dis[i])
			{
				d[ver[i]]=d[x]+dis[i];
				low[ver[i]]=min(low[x],flow[i]);
				lastb[ver[i]]=i;
				lastd[ver[i]]=x;
				if(!bj[ver[i]])
				{
					bj[ver[i]]=1;
					q.push(ver[i]);
				}
			}
		}
	}
	return lastb[t]!=-1;
}
inline void MCMF()
{
	while(spfa())
	{
		maxflow+=low[t];
		mincost+=low[t]*d[t];
		int x=t;
		while(x!=s)
		{
			flow[lastb[x]]-=low[t];
			flow[lastb[x]^1]+=low[t];
			x=lastd[x];
		}
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	s=1;t=n+n;
	add(1,n+1,10000000,0);
	add(n+1,1,-10000000,0);
	add(n,n+n,10000000,0);
	add(n+n,n,-10000000,0);
	for(int i=2;i<=n-1;i++)
	{
		add(i,i+n,1,0);
		add(i+n,i,0,0);
	}
	for(int i=1;i<=m;i++)
	{
		int a,b,c;
		scanf("%d%d%d",&a,&b,&c);
		add(a+n,b,1,c);
		add(b,a+n,0,-c);
	}
	MCMF();
	cout<<maxflow<<" "<<mincost<<endl;
	return 0;
}
```


---

## 作者：chenxinyang2006 (赞：0)

虽然这题很水，但是我还是WA了10次(大概都是1->n的边的锅）

很显然，这道题应该跑一边最小费用最大流，费用流最重要的是如何建边，反向边之类的就不多说了。

这题要求一个点只能访问一次，所以把一个点拆成2 * i，和2 * i + 1两个点，分别是入点和出点。（点1点n不要这样连）入点到出点连流量为1，费用为0的边，这样一个点就只能访问一次。其他边就出点连入点，连费用为c，流量inf的边（1->n的边流量1）

如果把1的出点作为原点，可能会因为有一些连到1的边而挂掉，所以用1做原点，n * 2作为汇点。1的入点出点连流量inf，费用0的边，表示这个点可以访问多次，n的入点出点就不用连了。

下面的代码是拿模板改的，其实flow数组不是1就是0，根本不用存。

```cpp
#include <cstdio>
#include <cstring>
#include <queue>
#define inf 0x3f3f3f3f
using namespace std;
int n,m,cnt;
int head[1005],flow[1005],vis[1005],dist[1005],pre[1005],from[1005];

struct node{
	int to,flow,dis,next;
}edge[100005];

void make(int u,int v,int flow,int cost){
	edge[++cnt].to = v;
	edge[cnt].flow = flow;
	edge[cnt].dis = cost;
	edge[cnt].next = head[u];
	head[u] = cnt;
}

void spfa(){
	queue <int> que;
	que.push(1);
	vis[1] = 1;
	dist[1] = 0;
	flow[1] = inf;
	while(!que.empty()){
		int now = que.front();
		que.pop();
		vis[now] = 0;
		for(int i = head[now];i != -1;i = edge[i].next){
			if(dist[edge[i].to] > dist[now] + edge[i].dis && edge[i].flow > 0){
				dist[edge[i].to] = dist[now] + edge[i].dis;
				flow[edge[i].to] = min(flow[now],edge[i].flow);
				pre[edge[i].to] = now;
				from[edge[i].to] = i;
				if(!vis[edge[i].to]){
					vis[edge[i].to] = 1;
					que.push(edge[i].to);
				} 
			}
		}
	}
}

int rev(int i){
    if(i % 2 == 0){
    	return i - 1;
    }	
    return i + 1;
}

void work(){
	int ans1 = 0,ans2 = 0;
	while(true){
		for(int i = 1;i <= n * 2 + 1;i++){
			vis[i] = flow[i] = 0;
			dist[i] = inf;
		}
		spfa();
		if(flow[n * 2] == 0){
			printf("%d %d\n",ans1,ans2);
			return;
		}
		ans1 += flow[n * 2];
		ans2 += flow[n * 2] * dist[n * 2];
		int i = n * 2;
		while(i != 1){
			edge[from[i]].flow -= flow[n * 2];
			edge[rev(from[i])].flow += flow[n * 2];//因为反向边的cnt肯定和原边相邻，所以可以这样写
			i = pre[i];
		}
	}
}

int main(){
	memset(head,-1,sizeof(head));
	scanf("%d%d",&n,&m);
	for(int i = 1;i <= m;i++){
		int a,b,c;
		scanf("%d%d%d",&a,&b,&c);
		if(a == 1 && b == n){
			make(a * 2 + 1,b * 2,1,c);
			make(b * 2,a * 2 + 1,0,0);
		}else{
			make(a * 2 + 1,b * 2,inf,c);
	    	make(b * 2,a * 2 + 1,0,-c);
		}
	}
	for(int i = 2;i < n;i++){
		make(i * 2,i * 2 + 1,1,0);
		make(i * 2 + 1,i * 2,0,0);
	}
	make(2,3,inf,0);
	make(1,2,inf,0);
	work();
	return 0;
} 
```


---

## 作者：arfa (赞：0)

没什么好讲的,感觉题目描述就已经告诉我们要怎么搞了,下面是几个注意事项 : 

- 每一个点是限制自己的所以要拆点
- $1$ 和 $n$ 的出入点相连的流量为 $inf$ (因为可以走很多次嘛)
- 存在 $1 \rightarrow n$ 的边存在。这种情况下,这条边只能走一次。

```pascal
// luogu-judger-enable-o2
Uses math;

var
    from,reach,next,value,cost:array[-1..51000] of longint;
    dis,pre,last,flow:array[-1..51000] of int64;
    queue:array[-1..51000] of longint;
    time,money:array[1..2] of longint;
    id:array[-1..510,1..2] of longint;
    cnt:array[-1..510] of longint;
    vis:array[-1..510] of boolean;
    n,m,l,r,i,k,tot,now,sink,source:longint;
    maxflow,mincost:int64;

procedure add(x,y,sum_1,sum_2:longint);
begin
    inc(tot); from[tot]:=x; reach[tot]:=y; value[tot]:=sum_1; cost[tot]:= sum_2; next[tot]:=cnt[x]; cnt[x]:=tot;
    inc(tot); from[tot]:=y; reach[tot]:=x; value[tot]:=0    ; cost[tot]:=-sum_2; next[tot]:=cnt[y]; cnt[y]:=tot;
end;

function SPFA:boolean;
var head,tail,now,i:longint;
begin
    filldword(dis,sizeof(dis) div 4,maxlongint);
    filldword(flow,sizeof(flow) div 4,maxlongint);
    filldword(vis,sizeof(vis) div 4,0);
    head:=1; tail:=1;  queue[1]:=source; vis[source]:=True; dis[source]:=0; pre[sink]:=-1;

    while head<=tail do
    begin
        now:=queue[head]; vis[now]:=False; inc(head);
        i:=cnt[now];
        while i<>-1 do
        begin
            if (value[i]>0)and(dis[reach[i]]>dis[now]+cost[i]) then
            begin
                dis[reach[i]]:=dis[now]+cost[i];
                pre[reach[i]]:=now;
                last[reach[i]]:=i;
                flow[reach[i]]:=min(flow[now],value[i]);
                if vis[reach[i]]=False then
                begin
                    vis[reach[i]]:=True;
                    inc(tail); queue[tail]:=reach[i];
                end;
            end;
            i:=next[i];
        end;
    end;
    if pre[sink]=-1 then exit(False); exit(True);
end;

procedure MincostMaxflow;
begin
    maxflow:=0; mincost:=0; now:=0;
    while (SPFA) do
    begin
        now:=sink;
        inc(maxflow,flow[sink]);
        inc(mincost,flow[sink]*dis[sink]);
        while now<>source do
        begin
            dec(value[last[now]],flow[sink]);
            inc(value[last[now] xor 1],flow[sink]);
            now:=pre[now];
        end;
    end;
end;

procedure Construction_I;
begin
    filldword(cnt,sizeof(cnt) div 4,maxlongint*2+1); tot:=1;
    fillchar(value,sizeof(value),0);
    fillchar(reach,sizeof(reach),0);
    fillchar(cost,sizeof(cost),0);
    fillchar(next,sizeof(next),0);
    read(n,m); source:=1; sink:=(n+1) << 1;
    for i:=1 to n do begin id[i,1]:=i << 1; id[i,2]:=i << 1+1; end;
    for i:=2 to n-1 do add(id[i,1],id[i,2],1,0);
    add(id[1,1],id[1,2],maxlongint,0); add(id[n,1],id[n,2],maxlongint,0);
    for i:=1 to m do
    begin
        read(l,r,k);
        if (l=1)and(r=n) then
        begin
            add(id[1,2],id[n,1],1,k);
            continue;
        end;
        add(id[l,2],id[r,1],maxlongint,k);
    end;
    add(source,id[1,1],maxlongint,0); add(id[n,2],sink,maxlongint,0);
end;

begin
    Construction_I; MincostMaxflow; writeln(maxflow,' ',mincost);
end.


```

---

## 作者：ez_lcw (赞：0)

### 这就是一道典型的利用拆点进行最小费用最大流的题目

根据题意，我们把十字路口设为网络流中的结点，道路设为边。可是这样就有一个问题：**如何将题目中的*“由于他不喜欢走重复的路线，所以 在一个周期内，每天的晨跑路线都不会相交（在十字路口处）”*实现？**

所以我们就要用到网络流中一个常用的技巧：**拆点。**

**也就是把点$u$拆成点$(u1,u2)$,分别表示入点和出点，两点间的容量为1（为了限制经过此点的流量（路径）只有1），费用为0，那么，对于边$(u,v)$，我们就将其改成边$(u2,v1)$。**

然后跑一遍最小费用最大流即可。

注意：建议用邻接表存图，可能这题不会炸，但以后还是有可能的。

具体代码如下：

```cpp
#include<cstdio>
#include<queue>
#include<cstring>
  
#define N 405
#define M 50005
#define INF 2139062143
#define M127 2139062143
  
using namespace std;
  
int n,m,ai,bi,ci,head[N],c[M],d[M],to[M],nxt[M],f[N],into[N],out[N],pre[N],s,t,minn,ans1,ans2,cnt;
//c为流量，d为费用。
bool vis[N];
  
queue<int>q;
  
void adde(int u,int v,int a,int b){
    cnt++;
    to[cnt]=v;
    c[cnt]=a;
    d[cnt]=b;
    nxt[cnt]=head[u];
    head[u]=cnt;
//建正向边     
    cnt++;
    to[cnt]=u;
    c[cnt]=0;
    d[cnt]=-b;
    nxt[cnt]=head[v];
    head[v]=cnt;
//建反向边
}
 
bool SPFA(){//跑最短路
    memset(f,127,sizeof(f));
    q.push(s);
    f[s]=0;
    vis[s]=true;
    int now;
    while(!q.empty()){
        now=q.front();
        q.pop();
        vis[now]=false;
        for(int i=head[now];i;i=nxt[i]){
            if(c[i]&&f[now]+d[i]<f[to[i]]){
                f[to[i]]=f[now]+d[i];
                pre[to[i]]=i;
                if(!vis[to[i]]){
                    q.push(to[i]);
                    vis[to[i]]=true;
                }
            }
        }
    }
    if(f[t]==M127){
        return false;
    }else{
        return true;
    }
}
  
void EK(){//套最小费用最大流模板
    s=1;
    t=n*2;
    while(SPFA()){
        minn=INF;
        for(int i=t;i!=s;i=to[pre[i]^1]){
            minn=min(minn,c[pre[i]]);
        }
        for(int i=t;i!=s;i=to[pre[i]^1]){
            c[pre[i]]-=minn;
            c[pre[i]^1]+=minn;
            ans2+=minn*d[pre[i]];//总费用
        }
        ans1++;//增广路路径数
    }
}
  
int main(){
    cnt=1;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){//我的存图方法可能有点奇怪，理解思路即可。
        if(i==1){
            into[i]=cnt;
            out[i]=cnt+1;
            adde(into[i],out[i],INF,0);
            continue;
        }
        if(i==n){
            into[i]=cnt;
            out[i]=cnt+1;
            adde(into[i],out[i],INF,0);
            continue;
        }
        into[i]=cnt;
        out[i]=cnt+1;
        adde(into[i],out[i],1,0);
    }
    for(int i=1;i<=m;i++){
        scanf("%d%d%d",&ai,&bi,&ci);
        adde(out[ai],into[bi],1,ci);
    }
    EK();
    printf("%d %d\n",ans1,ans2);
    return 0;
}
```
更多关于拆点的详解，可以看一下[我的另一篇题解：吃饭Dining](https://www.luogu.org/blog/lc-2018-Canton/solution-p2891)，这是一道很好的例题。

---

## 作者：FREEH (赞：0)

### 【题目】
![题目](https://cdn.luogu.com.cn/upload/pic/26082.png)

### 【解题思路】
- 最小费用最大流裸题。
- 因为有对点的访问次数的限制，因此可以考虑拆点，把每个点拆成点1和点2。
- 把每个点的点1和点2连接一条容量为1，费用为0的边；
	- 特殊的，由于宿舍和学校可以无限次访问，所以宿舍和学校的点1和点2连接一条容量为无穷大，费用为0的边。
- 把点a的点2与点b的点1连接一条容量为1，费用为长度的边；
- 把源点向宿舍点1连接一条容量无穷大，费用为0的边；
- 把学校点2向汇点连接一条容量无穷大，费用为0的边；
- 然后直接跑最小费用最大流模板即可。

### 【参考程序】
```cpp
#include<cstdio>
#include<queue>
#include<iostream>
#include<cstring>
using namespace std;

#define INF 0x3f3f3f3f
int cur=1,n,m,s,t,mcost,mflow;
int head[5005],dis[5005],flow[5005],pre[5005];
struct EDGE{
    int t,next,w,f;
}e[100005];
void add(int a,int b,int w,int f)
{
    cur++;e[cur].t=b;e[cur].next=head[a];e[cur].w=w;e[cur].f=f;head[a]=cur;
    cur++;e[cur].t=a;e[cur].next=head[b];e[cur].w=0;e[cur].f=-f;head[b]=cur;
}

queue < int > q;
bool vis[5005];
bool SPFA(int s,int t)
{
    memset(dis,INF,sizeof dis);
    memset(vis,0,sizeof vis);
    dis[s]=0;
    vis[s]=1;
    flow[s]=INF;
    q.push(s);
    while (!q.empty())
    {
        int u=q.front();q.pop();
        vis[u]=false;
        for (int h=head[u];h!=-1;h=e[h].next)
        {
            int v=e[h].t,f=e[h].f;
            if (e[h].w&&dis[u]+f<dis[v])//????????????
            {
                dis[v]=dis[u]+f;//??????
                flow[v]=min(flow[u],e[h].w);//??????
                pre[v]=h;//????
                if (!vis[v])
                {
                    vis[v]=true;
                    q.push(v);
                }
            }
        }
    }
    return dis[t]!=INF;
}

void Update(int s,int t)
{
    int x=t;
    while (x!=s)
    {
        int i=pre[x];
        e[i].w-=flow[t];
        e[i^1].w+=flow[t];
        x=e[i^1].t;
    }//??????????????
    mflow+=flow[t];
    mcost+=flow[t]*dis[t];//????
}
void E_K(int s,int t)
{
    while (SPFA(s,t))//????????
        Update(s,t);
}

#define nxt(x) (x+n)
int main()
{
    scanf("%d%d",&n,&m);
    s=0;t=2*n+1;
    memset(head,-1,sizeof head);
    for (int i=1;i<=m;i++)
    {
        int a,b,c;
        scanf("%d%d%d",&a,&b,&c);
        add(nxt(a),b,1,c);
    }
    add(s,1,INF,0);
    add(nxt(n),t,INF,0);
    add(1,nxt(1),INF,0);
    add(n,nxt(n),INF,0);
    for (int i=2;i<n;i++)
    {
    	add(i,nxt(i),1,0);
    }
    E_K(s,t);
    printf("%d %d\n",mflow,mcost);
    return 0;
} 
```

---

## 作者：qwqqqq (赞：0)

这个题拿到手，看到“他希望在一个周期内跑的路程尽量短，但是又希望训练周期包含的天数尽量长。”这句话之后，很快想到了最小费用最大流算法（~~好吧其实是看了标签~~）看到题目里给的那张图，心想还有这么良心的题目，于是照着建完图后跑spfa费用流，跑出来个2 8……遇到了什么问题呢？
现在看看这张图![](https://cdn.luogu.com.cn/upload/pic/23729.png )

如果不加限制，4这个点是可以重复跑的。于是我们需要一个经典的方法来限制经过的次数——拆点![](https://cdn.luogu.com.cn/upload/pic/23736.png )

把一个点拆成两个中间连一条流量为1的边，这样在流过一次以后流量变为0，这个点就只能用一次了。

现在放代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
using namespace std;
struct edge
{
	int u,v,x,f,s;
}ed[1000010];
int head[1000010];
int dis[1000010];
int vis[1000010];
int que[1000010];
int fro[1000010];
int n,m,s,e,h,t=1,cnt,ans,flow;
void add(int x,int y,int z,int w)
{
	ed[cnt].u=head[x];
	ed[cnt].v=y;
	ed[cnt].x=x;
	ed[cnt].f=z;
	ed[cnt].s=w;
	head[x]=cnt++;
}
bool spfa()
{
	for(int i=1;i<=n*n;i++)
		dis[i]=2147483647;
	memset(vis,0,sizeof(vis));
	dis[s]=0,vis[s]=1,que[t]=s;
	h=0,t=1;
	while(h!=t)
	{
		int temp=que[++h];
		for(int i=head[temp];i!=-1;i=ed[i].u)
		{
			if(dis[ed[i].v]>dis[ed[i].x]+ed[i].s&&ed[i].f!=0)
			{
				dis[ed[i].v]=dis[ed[i].x]+ed[i].s;
				fro[ed[i].v]=i;
				if(vis[ed[i].v]==0)
				{
					vis[ed[i].v]=1;
					que[++t]=ed[i].v;
				}
			}
		}
		vis[temp]=0;
	}
	if(dis[e]!=2147483647)
		return 1;
	else
		return 0;
}
void f()
{
	int minn=2147483647;
	for(int i=e;i!=s;i=ed[fro[i]].x)
		minn=min(minn,ed[fro[i]].f);
	for(int i=e;i!=s;i=ed[fro[i]].x)
	{
		ed[fro[i]].f-=minn;
		ed[fro[i]^1].f+=minn;
		ans+=minn*ed[fro[i]].s;
	}
	flow+=minn;
}
int main()
{
	cin>>n>>m;
	s=1+n,e=n;
	memset(head,-1,sizeof(head));
	for(int i=2;i<n;i++)
	{
		add(i,i+n,1,0);
		add(i+n,i,0,0);
	}
	for(int i=1;i<=m;i++)
	{
		int x,y,z;
		cin>>x>>y>>z;
		add(x+n,y,1,z);
		add(y,x+n,0,-z);
	}
	while(spfa())
		f();
	cout<<flow<<" "<<ans;
	return 0;
}
```

---

## 作者：秋日私语 (赞：0)

更好的阅读体验点[这里](http://blog.csdn.net/a_comme_amour/article/details/79632771)

题目
-

[传送门](http://www.lydsy.com/JudgeOnline/problem.php?id=1877)

题解
-

我菜到没有看出这是一道费用流的板子题；
每个点只能走一次，可以想到拆点的思想；
对于除了S和T的点，拆点的连边容量为1，费用为0；
其他的边的容量定为1，费用为路径长度，跑出最大流即为最大天数，最小费用和为最短路径；

代码
-


```
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<queue>
using namespace std;
const int maxn=100001;
const int inf=1e9;

int n,m,s,t,maxflow,mincost;
struct Edge{
	int next,to,dis,flow;
}edge[maxn<<1];
int num_edge=-1,head[maxn],pre[maxn],dis[maxn],flow[maxn],last[maxn];

void add_edge(int from,int to,int flow,int dis)
{
	edge[++num_edge].next=head[from];
	edge[num_edge].dis=dis;
	edge[num_edge].flow=flow;
	edge[num_edge].to=to;
	head[from]=num_edge;
}
void add(int x,int y,int z,int f) {add_edge(x,y,z,f); add_edge(y,x,0,-f);}
bool vis[maxn];
queue <int> q;
bool spfa(int s,int t)
{
	memset(dis,0x7f,sizeof(dis));
	memset(flow,0x7f,sizeof(flow));
	memset(vis,0,sizeof(vis));
	q.push(s); vis[s]=1; pre[t]=-1; dis[s]=0;
	
	while (!q.empty())
	{
		int now=q.front(); q.pop();
		vis[now]=0;
		for (int i=head[now]; i!=-1; i=edge[i].next)
		{
			if (edge[i].flow>0 && dis[edge[i].to]>dis[now]+edge[i].dis)//正边 
			{
				dis[edge[i].to]=dis[now]+edge[i].dis;
				flow[edge[i].to]=min(flow[now],edge[i].flow);
				pre[edge[i].to]=now;
				last[edge[i].to]=i;
				if (!vis[edge[i].to])
				{
					vis[edge[i].to]=1;
					q.push(edge[i].to);
				}
			}
		}
	}
	return pre[t]!=-1;
}

void MCMF(int s,int t)
{
	while (spfa(s,t))
	{
		int now=t;
		maxflow+=flow[t];
		mincost+=flow[t]*dis[t];
		while (now!=s)
		{
			edge[last[now]].flow-=flow[t];
			edge[last[now]^1].flow+=flow[t];
			now=pre[now];
		}
	}
}

int main()
{
	memset(head,-1,sizeof(head));
	scanf("%d%d",&n,&m);
	int S=1,T=n;
	for (int i=2; i<=n-1; i++) add(i,i+n,1,0);
	for (int i=1; i<=m; i++)
	{
		int x,y,z; scanf("%d%d%d",&x,&y,&z);
		if (x==1) add(S,y,1,z);
		else if (y==n) add(x+n,T,1,z);
		else add(x+n,y,1,z);
	}
//	for (int i=0; i<=num_edge; i++) printf("%d: %d %d %d %d\n",i,edge[i^1].to,edge[i].to,edge[i].flow,edge[i].dis);
	MCMF(S,T);
	printf("%d %d",maxflow,mincost);
	return 0;
}
```


---

## 作者：Tirpitz (赞：0)

最小费用最大流

题目中要求不能重复经过一个十字路口，因此很自然的想到将十字路口拆分为一个入点和一个出点，容量为1，花费为0。但是起点和终点是一定会重复经过的，因此将这两个点拆分时，应在入点和出点之间连上容量为MAX，花费为0的边。

将每条路视为容量为1，花费为路径长度的边，建图。

之后只需要跑一边模板就可以了。



```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<cmath>
#include<algorithm>
#include<queue>
#define MAX 1e8
using namespace std;

int map[405][405],dis[405],pre[405],f[405],fl[405],cost[405][405],n,m,flow,discost;
queue<int>q;

int bfs(int s,int t)
{
    int i; 
    
    memset(dis,127,sizeof(dis));
    memset(f,0,sizeof(f));
    memset(pre,-1,sizeof(pre)); 
    
    while(!q.empty())
        q.pop();
    
    dis[s]=0;
    f[s]=1;
    q.push(s);
    pre[s]=0;
    fl[s]=MAX;
    
    while(!q.empty())
    {
        int p=q.front();
        f[p]=0;
        q.pop();
        
        for(i=1;i<=2*n;i++)
            if(map[p][i]&&dis[i]>dis[p]+cost[p][i])
            {
                dis[i]=dis[p]+cost[p][i];
                fl[i]=min(fl[p],map[p][i]);
                pre[i]=p;
                
                if(!f[i]) 
                {
                    f[i]=1;
                    q.push(i);    
                }
            }
    }
    
    if(pre[t]==-1) return 0;
    return fl[t];
}

void maxflow(int s,int t)
{
    int k,last;
    
    while(bfs(s,t))
    {
        k=t;
        
        while(k!=s)
        {
            last=pre[k];            
            
            map[last][k]-=fl[t];
            map[k][last]+=fl[t];
                
            k=last;
        }
        
        flow+=fl[t];
        discost+=dis[t];
    }
}

int main()
{
    int i,a,b,c,j;
    
    scanf("%d%d",&n,&m);
    
    map[1][n+1]=MAX;
    map[n][n+n]=MAX;
    
    for(i=2;i<n;i++)
        map[i][i+n]=1;
    
    for(i=1;i<=m;i++)
    {
        scanf("%d%d%d",&a,&b,&c);
        cost[a+n][b]=c;
        cost[b][a+n]=-c;
        map[a+n][b]=1;
    }
    
    maxflow(1,n);
    
    printf("%d %d",flow,discost);
    
    return 0;
}
```

---


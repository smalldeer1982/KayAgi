# [HAOI2007] 覆盖问题

## 题目描述

某人在山上种了 $N$ 棵小树苗。冬天来了，温度急速下降，小树苗脆弱得不堪一击，于是树主人想用一些塑料薄膜把这些小树遮盖起来，经过一番长久的思考，他决定 用 $3$ 个 $L \times L$ 的正方形塑料薄膜将小树遮起来。我们不妨将山建立一个平面直角坐标系，设第 $i$ 棵小树的坐标为 $(X_i,Y_i)$ ，$3$ 个 $L \times L$ 的正方形的边要求平行于坐标轴，一个点如果在正方形的边界上，也算作被覆盖。当然，我们希望塑料薄膜面积越小越好，即求 $L$ 最小值。

## 说明/提示

对于 $100\%$ 的数据，$-1,000,000,000 \le X_i,Y_i \le 1,000,000,000。$

对于 $30\%$ 的数据，$N \le 100。$

对于 $50\%$ 的数据，$N \le 2000。$

对于 $100\%$ 的数据，$N \le 20000。$

## 样例 #1

### 输入

```
4
0 1
0 -1
1 0
-1 0
```

### 输出

```
1```

# 题解

## 作者：liangbowen (赞：20)

## 前言

[题目传送门！](https://www.luogu.com.cn/problem/P2218)

[更好的阅读体验？](https://www.cnblogs.com/liangbowen/p/16817123.html)

二分答案套搜索。

## 思路

答案显然具有单调性，于是可以二分答案。

问题是如何实现 $\operatorname{check}(k)$ 函数（$k$ 指薄膜边长）。

其实很简单：用 dfs 即可。

每次 dfs 时记录下当前是第几个薄膜。dfs 时，如果 $\max\big(\small(\max x_i) - (\min x_i), (\max y_i) - (\min y_i)\big)\small \le k$，说明 $k$ 是可行解。

```cpp
bool dfs(int c)
{
	int minx = inf, maxx = -inf, miny = inf, maxy = -inf;
	for (int i = 1; i <= n; i++)
		if (!flag[i])
			minx = min(minx, x[i]), maxx = max(maxx, x[i]), miny = min(miny, y[i]), maxy = max(maxy, y[i]);
	if (max(maxx - minx, maxy - miny) <= k) return true; //可以安装完
	if (c == 3) return false;
        //write other code here
}
```

覆盖时，考虑薄膜左上角与右下角的位置。看起来有很多情况，其实很少。

假设点分布的很不均匀，然后我们在中间的部分放一个薄膜。

这时，你会发现，边角上的点**仍然要处理**。这样，你不得不再花费薄膜在边角上放置，非常浪费。

---

因此，最好的方法就是**全部贴着角放**。

所以，左上角 $(x1, y1)$ 以及右下角 $(x2, y2)$，一共只有**四种可能**。

横坐标两种可能：$\begin{cases}x1 = (\min x_i) \\x2 = (\min x_i) + k\end{cases}\ \ \begin{cases}x1 = (\max x_i) - k \\x2 = (\max x_i)\end{cases}$

同理，纵坐标有两种可能：$\begin{cases}y1 = (\min y_i) \\y2 = (\min y_i) + k\end{cases}\ \ \begin{cases}y1 = (\max y_i) - k \\y2 = (\max y_i)\end{cases}$

两两搭配就是四种了。具体可以见代码。

```cpp
int dict[4][4]; //自己对比一下，依次指 x1, x2, y1, y2
dict[0][0] = minx, dict[0][1] = minx + k, dict[0][2] = miny, dict[0][3] = miny + k;
dict[1][0] = minx, dict[1][1] = minx + k, dict[1][2] = maxy - k, dict[1][3] = maxy;
dict[2][0] = maxx - k, dict[2][1] = maxx, dict[2][2] = miny, dict[2][3] = miny + k;
dict[3][0] = maxx - k, dict[3][1] = maxx, dict[3][2] = maxy - k, dict[3][3] = maxy;
```

依次枚举这四种情况，覆盖时暴力看能否盖住即可。

搜完后记得回溯。

```cpp
for (int j = 0; j < 4; j++)
{
	int x1 = dict[j][0], x2 = dict[j][1], y1 = dict[j][2], y2 = dict[j][3];
	for (int i = 1; i <= n; i++) //覆盖
		if (!flag[i])
			if (x1 <= x[i] && x[i] <= x2 && y1 <= y[i] && y[i] <= y2)
				flag[i] = c;
	if (dfs(c + 1)) return true;
	for (int i = 1; i <= n; i++) //回溯
		if (flag[i] == c)
			flag[i] = 0;
}
```

## 坑点

1. 数组要清空！

2. 正如[这篇题解](https://www.luogu.com.cn/blog/SCP/solution-p2218)所说，大部分变量都需要定义在函数内！
  比如本代码的 `dict` 数组，就一定要定义在 `dfs` 里，很诡异。

## 完整代码

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 20005, inf = 2147483647;
int x[N], y[N], flag[N]; //flag:是否已经被覆盖了
int k, n;
inline bool dfs(int c)
{
	int minx = inf, maxx = -inf, miny = inf, maxy = -inf;
	for (int i = 1; i <= n; i++)
		if (!flag[i])
			minx = min(minx, x[i]), maxx = max(maxx, x[i]), miny = min(miny, y[i]), maxy = max(maxy, y[i]);
	if (max(maxx - minx, maxy - miny) <= k) return true; //可以安装完
	if (c == 3) return false;
	int dict[4][4]; //自己对比一下，依次指 x1, x2, y1, y2
	dict[0][0] = minx, dict[0][1] = minx + k, dict[0][2] = miny, dict[0][3] = miny + k;
	dict[1][0] = minx, dict[1][1] = minx + k, dict[1][2] = maxy - k, dict[1][3] = maxy;
	dict[2][0] = maxx - k, dict[2][1] = maxx, dict[2][2] = miny, dict[2][3] = miny + k;
	dict[3][0] = maxx - k, dict[3][1] = maxx, dict[3][2] = maxy - k, dict[3][3] = maxy;
	for (int j = 0; j < 4; j++)
	{
		int x1 = dict[j][0], x2 = dict[j][1], y1 = dict[j][2], y2 = dict[j][3];
		for (int i = 1; i <= n; i++) //覆盖
			if (!flag[i])
				if (x1 <= x[i] && x[i] <= x2 && y1 <= y[i] && y[i] <= y2)
					flag[i] = c;
		if (dfs(c + 1)) return true;
		for (int i = 1; i <= n; i++) //回溯
			if (flag[i] == c)
				flag[i] = 0;
	}
	return false;
}
bool chk(int oh)
{
	k = oh;
	for (int i = 1; i <= n; i++) flag[i] = 0;
	return dfs(1);
}
int FIND(LL l, LL r)
{
	while (l < r) //FFFF【T】TTT
	{
		LL mid = (l + r) >> 1;
		if (chk(mid)) r = mid;
		else l = mid + 1;
	}
	return r;
}
int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d%d", &x[i], &y[i]);
	cout << FIND(0, 2e9);
	return 0;
}
```

希望能帮助到大家！

---

## 作者：无意识躺枪人 (赞：14)

看到这道题，很明显地可以看出来需要二分答案

对于平面上的一些点，如果我们只使用一个尽量小的正方形覆盖它，那么这个正方形的大小和位置都是确定的

现在的目标就是使用三个小一点的相同的正方形替换它，并保证所有点都被覆盖

由于正方形的边必须与坐标轴平行，故小正方形至少有一条边所在的直线和大正方形的一条边所在的直线是重合的

那么每个小正方形至少需要贡献一条边出来，因为只有3个小正方形，故一定至少有一个小正方形是贴着角的

于是我们可以二分边长，check的时候暴力dfs判断小正方形分别在四个角时是否可以满足条件

dfs的时候对点进行染色，方便回复到之前的状态

具体细节见代码

```cpp
#include<bits/stdc++.h>
#define ll long long
#define mid ((l+r)>>1)
#define inf 1234567890
using namespace std;

int n;

struct Object
{
	ll x,y;
	int color;
}a[20005];

bool cmp(Object a,Object b)
{
	if(a.x==b.x) return a.y<b.y;
	return a.x<b.x;
}

void update(ll minx,ll maxx,ll miny,ll maxy,int color)//更新这个正方形覆盖到的区域 
{
	for(register int i=1;i<=n;++i)
	{
		if(!a[i].color)
		{
			if((minx<=a[i].x&&a[i].x<=maxx)&&(miny<=a[i].y&&a[i].y<=maxy))
				a[i].color=color;
		}
	}
}

void clear(int color)//用于撤销到dfs之前的状态 
{
	for(register int i=1;i<=n;++i)
		if(a[i].color==color) a[i].color=0;
}

bool dfs(int cnt,int x)
{
	int minx=inf,miny=inf,maxx=-inf,maxy=-inf;
	for(register int i=1;i<=n;++i)
	{
		if(!a[i].color)
		{
			if(a[i].x>maxx) maxx=a[i].x;
			if(a[i].x<minx) minx=a[i].x;
			if(a[i].y>maxy) maxy=a[i].y;
			if(a[i].y<miny) miny=a[i].y;
		}
	}
	ll lenx=maxx-minx;
	ll leny=maxy-miny;
	if(max(lenx,leny)<=x) return true;
	if(cnt==3) return false;
	
	//枚举每一种方案是否可行 
	
	update(minx,minx+x,miny,miny+x,cnt);
	if(dfs(cnt+1,x)) return true;
	clear(cnt);
	
	update(minx,minx+x,maxy-x,maxy,cnt);
	if(dfs(cnt+1,x)) return true;
	clear(cnt);
	
	update(maxx-x,maxx,miny,miny+x,cnt);
	if(dfs(cnt+1,x)) return true;
	clear(cnt);
	
	update(maxx-x,maxx,maxy-x,maxy,cnt);
	if(dfs(cnt+1,x)) return true;
	clear(cnt);
	
	return false;
}

bool check(int x)//检验边长为 x 的薄膜是否符合要求 
{
	for(register int i=1;i<=n;++i) a[i].color=0;
	return dfs(1,x);
}

template<class T>inline void read(T &res)
{
	char c;T flag=1;
	while((c=getchar())<'0'||c>'9')if(c=='-')flag=-1;res=c-'0';
	while((c=getchar())>='0'&&c<='9')res=res*10+c-'0';res*=flag;
}

int main()
{
	read(n);
	for(register int i=1;i<=n;++i)
	{
		read(a[i].x);
		read(a[i].y);
	}
	sort(a+1,a+n+1,cmp);
	ll l=0,r=inf;
	while(l<r)
	{
		if(check(mid)) r=mid;
		else l=mid+1;
	}
	printf("%d\n",mid);
	return 0;
}
```

dfs里的变量一定要开局部！开全局的话死不瞑目啊！

![](https://cdn.luogu.com.cn/upload/image_hosting/f70q8qfo.png)

---

## 作者：Night_Aurora (赞：8)

对于边长最短且可行，我们想到了二分答案

那么剩下的就是如何O(n)判断是否能包住这些点了

可以先算出所有点的包围矩形，若放的正方形能包围这些点->对于外包矩形的每条边都和至少一条正方形的边在一条直线上

但是只有三个正方形，说明至少有一个正方形与外包矩形有两条边及以上相接，就是一个公共角

于是我们可以对于前两个正方形枚举与哪个角相接，对于第三个正方形判断就行了

一旦可行就退出

这样搞的复杂度是O(N)加上二分就是$O(Nlogn)$

处理过程中刚好有可能会溢出，所以对于一些函数内坐标需要开long long

[难看的代码](http://paste.ubuntu.com/25457587/)


---

## 作者：Herman526 (赞：7)

**这道题考察算法的综合运用。**

**首先，我们思考如何快速地找到答案。** 由于一定存在整数 $n$ 使任何长度不小于 $n$ 的正方形满足要求（就是题目中的 $L$），所以可以采用二分，并进行覆盖方案搜索的方式得到 $L$，这是和其它题解类似的。

不过，在思考如何搜索时，我想到了循环嵌套。不用 dfs，是因为这道题搜索的维度是固定不变的 $3$ 层，且每层的任务可以略有不同：
- 第一层：在**所有点**中找寻覆盖方案；
- 第二层：在**剩余点**中找寻覆盖方案（与第一层的不同在于本层需要判断点是否被覆盖）；
- 第三层：通过 X,Y 坐标极值作差判断是否可以覆盖（**无需搜索**）。

**其实将题目划分成这几层后，你就会很快发现，第三层的实现很简单，重点在于前两层算法的实现。** 由于点有固定的坐标，因此从二维数组的角度而言，这些点中**一定存在**一个固定最上点（Y 坐标最小）、最下点（Y 坐标最大）、最左点（X 坐标最小）与最右点（X 坐标最大），共计 $4$ 个极限位置。然而，正方形只有 $3$ 个，所以必有一个正方形要盖住 $4$ 个点中的 $2$ 个（当剩余正方形数减少时也如此），因此可以考虑让正方形的顶点 X 坐标为最左点或最右点的 X 坐标，而 Y 坐标等同于最上点或最下点，这样理论上就可以把 $2$ 个极限点盖住 **（在未找到答案的情况下，此处每种 X,Y 坐标都要尝试，且前两层都要这样判断）**。

看到这里，细心的你可能要问了：假设目前正在最上、下点的 Y 坐标差或是最左、右点的 X 坐标差正好为现在正在搜索的 $L$，那不就可以考虑盖住这两个点，而对其它极限点姑且撒手不管了吗？其实，这样做并不是最优方案。如果一个正方形只盖住上、下或左、右的点，在这个正方形旁就可能有两处“留白”，且它们距离较大，需要浪费至少 $2$ 个正方形来覆盖。而如果同时兼顾上下和左右，就可以尽量少“留白”（即使有 $2$ 处，它们的距离也很小，比较容易覆盖），少“浪费”正方形。

**有了这些思考，这题差不多在 $O(nk^2\log_2v)$ 的复杂度里就能迎刃而解了**（其中 $v$ 是 $L$ 的值域大小，在本题中为 $2×10^9$；$k$ 是每一层要考虑的覆盖情况种类数，在本题中为 $4$）。 不过如果用这个思路写代码，有些变量得**开 `long long`**，因为在计算时（**不一定是真的正方形**），正方形某个角的坐标的绝对值是有达到 $10^9+2×10^9=3×10^9$ 的。
```cpp
#include<bits/stdc++.h>
#define lld long long
using namespace std;
lld n,x[20000],y[20000],t[20000];//t[i] 表示 i 点被覆盖次数
void Plus(lld a,lld b,lld c,lld d,lld e){for(lld i=0;i<n;i++)if(x[i]>=a&&x[i]<=b&&y[i]>=c&&y[i]<=d)t[i]+=e;}
//为在范围内的所有点更改覆盖次数
//函数名不能用 plus，否则可能报错
void find_min_max(lld&a,lld&b,lld&c,lld&d){
	a=c=2e9,b=d=-2e9;
	for(lld i=0;i<n;i++)if(!t[i])
		a=min(a,x[i]),b=max(b,x[i]),c=min(c,y[i]),d=max(d,y[i]);
}//查找未覆盖点中的极限 X,Y 坐标
int main(){
	scanf("%lld",&n);
	for(lld i=0;i<n;i++)scanf("%lld%lld",x+i,y+i);
	lld m,s=0,t=2e9;
	while(s<t){
		lld a=x[0],b=a,c=y[0],d=c,aa,bb,cc,dd,aaa,bbb,ccc,ddd;bool f=1;//a,b,c,d 为第一层正方形覆盖前的极值，后面的变量以此类推；f=0 表示覆盖成功
		for(lld i=1;i<n;i++)
			a=min(a,x[i]),b=max(b,x[i]),c=min(c,y[i]),d=max(d,y[i]);//找极值，由于暂未标记覆盖，为省时，暂不用上面的函数
		lld p1[4][4]={{a,a+(m=s+t>>1),c,c+m},{a,a+m,d-m,d},{b-m,b,c,c+m},{b-m,b,d-m,d}};//查找正方形覆盖左上、左下、右上、右下角时的边角 X,Y 坐标
		for(lld i=0;f&&i<4;i++){
			Plus(p1[i][0],p1[i][1],p1[i][2],p1[i][3],1);
			find_min_max(aa,bb,cc,dd);//第二层
			lld p2[4][4]={{aa,aa+m,cc,cc+m},{aa,aa+m,dd-m,dd},{bb-m,bb,cc,cc+m},{bb-m,bb,dd-m,dd}};
			for(lld j=0;f&&j<4;j++){
				Plus(p2[j][0],p2[j][1],p2[j][2],p2[j][3],1);
				find_min_max(aaa,bbb,ccc,ddd);//第三层
				if(bbb-aaa<=m&&ddd-ccc<=m)f=0;//此时只要进行极差分析
				Plus(p2[j][0],p2[j][1],p2[j][2],p2[j][3],-1);
			}
			Plus(p1[i][0],p1[i][1],p1[i][2],p1[i][3],-1);
		}
		if(f)s=m+1;
		else t=m;
	}
	printf("%lld",t);
}
```
这是我在洛谷第一次提交的题解，可能还有一些不足。如果你在阅读时遇到了问题，欢迎指出！

---

## 作者：HC20050615 (赞：5)

# 解析

我们第一眼看题，一定会注意到正方形的个数为 $3$，是一个常数，说明这个 $3$ 多半是有用的。

我们先用一个长方形将所有的点全部覆盖，很容易发现，长方形的每一条边上至少有一个点。因此，长方形的每一条边应该都与一条正方形的边重合。但是，我们只有 $3$ 个正方形，但长方形有四条边。所以，一定有一个正方形是有两条边都与长方形重合的，则该正方形一定在角上。

我们先二分，确定 $L$，然后枚举四个角，将已经覆盖的点除去，让剩下的点再用两个正方形覆盖。同理，第二个正方形一定也是在这个新正方形的一个角上。我们在枚举四个角。最后，我们判断一下第三个正方形是否可以将全部的点都覆盖完。

# Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n;
int x[20001],y[20001];
int L;
bool b[20001];
inline bool dfs(int now,int minsx,int maxsx,int minsy,int maxsy)
{
	//cout<<now<<" "<<minsx<<" "<<maxsx<<" "<<minsy<<" "<<maxsy<<" "<<L<<endl;
	if(minsx==0x7fffffff)
	{
		return 1;
	}
	if(now==4)
	{
		return 0;
	}
	bool b_[20001];
	for(int i=1;i<=n;i++)
	{
		b_[i]=b[i];
	}
	int minsx_=0x7fffffff,maxsx_=-0x7fffffff,minsy_=0x7fffffff,maxsy_=-0x7fffffff;
	for(int i=1;i<=n;i++)
	{
		if(x[i]<=minsx+L&&y[i]<=minsy+L)
		{
			b[i]=1;
		}
		if(!b[i])
		{
			minsx_=min(minsx_,x[i]);
			maxsx_=max(maxsx_,x[i]);
			minsy_=min(minsy_,y[i]);
			maxsy_=max(maxsy_,y[i]);
		}
	}
	if(dfs(now+1,minsx_,maxsx_,minsy_,maxsy_))
	{
		for(int i=1;i<=n;i++)
		{
			b[i]=b_[i];
		}
		return 1;
	}
	for(int i=1;i<=n;i++)
	{
		b[i]=b_[i];
	}
	minsx_=0x7fffffff,maxsx_=-0x7fffffff,minsy_=0x7fffffff,maxsy_=-0x7fffffff;
	for(int i=1;i<=n;i++)
	{
		if(x[i]<=minsx+L&&y[i]>=maxsy-L)
		{
			b[i]=1;
		}
		if(!b[i])
		{
			minsx_=min(minsx_,x[i]);
			maxsx_=max(maxsx_,x[i]);
			minsy_=min(minsy_,y[i]);
			maxsy_=max(maxsy_,y[i]);
		}
	}
	if(dfs(now+1,minsx_,maxsx_,minsy_,maxsy_))
	{
		for(int i=1;i<=n;i++)
		{
			b[i]=b_[i];
		}
		return 1;
	}
	for(int i=1;i<=n;i++)
	{
		b[i]=b_[i];
	}
	minsx_=0x7fffffff,maxsx_=-0x7fffffff,minsy_=0x7fffffff,maxsy_=-0x7fffffff;
	for(int i=1;i<=n;i++)
	{
		if(x[i]>=maxsx-L&&y[i]<=minsy+L)
		{
			b[i]=1;
		}
		if(!b[i])
		{
			minsx_=min(minsx_,x[i]);
			maxsx_=max(maxsx_,x[i]);
			minsy_=min(minsy_,y[i]);
			maxsy_=max(maxsy_,y[i]);
		}
	}
	if(dfs(now+1,minsx_,maxsx_,minsy_,maxsy_))
	{
		for(int i=1;i<=n;i++)
		{
			b[i]=b_[i];
		}
		return 1;
	}
	for(int i=1;i<=n;i++)
	{
		b[i]=b_[i];
	}
	minsx_=0x7fffffff,maxsx_=-0x7fffffff,minsy_=0x7fffffff,maxsy_=-0x7fffffff;
	for(int i=1;i<=n;i++)
	{
		if(x[i]>=maxsx-L&&y[i]>=maxsy-L)
		{
			b[i]=1;
		}
		if(!b[i])
		{
			minsx_=min(minsx_,x[i]);
			maxsx_=max(maxsx_,x[i]);
			minsy_=min(minsy_,y[i]);
			maxsy_=max(maxsy_,y[i]);
		}
	}
	if(dfs(now+1,minsx_,maxsx_,minsy_,maxsy_))
	{
		for(int i=1;i<=n;i++)
		{
			b[i]=b_[i];
		}
		return 1;
	}
	for(int i=1;i<=n;i++)
	{
		b[i]=b_[i];
	}
	return 0;
}
int ans;
 main()
{
	int minsx=0x7fffffff,maxsx=-0x7fffffff,minsy=0x7fffffff,maxsy=-0x7fffffff;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>x[i]>>y[i];
		minsx=min(minsx,x[i]);
		maxsx=max(maxsx,x[i]);
		minsy=min(minsy,y[i]);
		maxsy=max(maxsy,y[i]);
	}
	long long l=1,r=2e9;
	while(l<=r)
	{
		L=(l+r)>>1;
		if(dfs(1,minsx,maxsx,minsy,maxsy))
		{
			ans=L;
			r=L-1;
		}
		else
		{
			l=L+1;
		}
	}
	cout<<ans<<endl;
	return 0;
}
```


---

## 作者：_segmenttree (赞：4)

## 思路

因为随着 $L$ 的增长覆盖点变多，很显然的二分。

现在重点是如何实现 $\operatorname{check}(x)$ 函数。

首先 $-1,000,000,000 \le X_i,Y_i \le 1,000,000,000$ 这个范围对我们来说太大了，考虑一下优化。看下图可知，对于外围的没有点的范围其实是与我们答案无关的，那么只需要考虑 $x_i$ 的最大值最小值和 $y_i$ 的最大值和最小值。

![](https://cdn.luogu.com.cn/upload/image_hosting/echgf1zi.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

接下来问题就是我们在这个矩形里怎么放正方形。

由于刚才我们的范围求得是 $x_i$ 的最大值最小值和 $y_i$ 的最大值和最小值，很明显，每条边上至少有一个点，那么我们每条边都要与一个正方形的边紧贴着。但是我们的正方形只有三个，这就意味着有一个正方形贴着两条边也就是处于一个角上。

那么接下来我们在深搜时枚举一下角就好了。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x[20010],y[20010],k;
int f[20010];
void fg(int xx,int yy,int cd,int js) {
	for(int i=1; i<=n; i++)
		if(!f[i]&&x[i]<=xx&&x[i]+cd>=xx&&y[i]<=yy&&y[i]+cd>=yy) 
			f[i]=js;
}
void clear(int js){
	for(int i=1;i<=n;i++)
	    if(f[i]==js)
	        f[i]=0;
}
bool dfs(int xx,int js) {
	int mnx=1e9,mxx=-1e9,mny=1e9,mxy=-1e9;
	for(int i=1; i<=n; i++)
		if(f[i]==0) {
			mnx=min(x[i],mnx),mxx=max(x[i],mxx);
			mny=min(y[i],mny),mxy=max(y[i],mxy);
		}
	if(max(mxx-mnx,mxy-mny)<=k) return true;
	if(js==3) return false;
	
	fg(mnx+xx,mxy,xx,js);//左上
	if(dfs(xx,js+1)) return true;
	clear(js);
	
	fg(mxx,mxy,xx,js);//右上
	if(dfs(xx,js+1)) return true;
	clear(js);
	
	fg(mnx+xx,mny+xx,xx,js);//左下
	if(dfs(xx,js+1)) return true;
	clear(js);
	
	fg(mxx,mny+xx,xx,js);//右下
	if(dfs(xx,js+1)) return true;
	clear(js);
	
	return false;
}
bool check(int x) {
	k=x;
	memset(f,0,sizeof(f));
	return dfs(x,1);
}
signed main() {
	cin>>n;
	for(int i=1; i<=n; i++)
		scanf("%d%d",&x[i],&y[i]);
	int l=0,r=2e9;
	while(l<r) {
		int mid=(l+r)/2;
		if(check(mid)) r=mid;
		else l=mid+1;
	}
	cout<<l;
	return 0;
}
```

---

## 作者：e4fsrc2e4fsrc2 (赞：4)

## [覆盖问题](https://www.luogu.com.cn/problem/P2218)
## 思路分析
对于答案 $ans$ 来说，如果满足条件，那么 $ans+1$ 必定满足条件，而 $ans-1$ 必定不满足条件，否则答案会更新为 $ans-1$。所以，答案满足单调性，故可以使用二分来解决。

那么此时问题遍传化成二分的 ```check``` 函数怎么写。

### check 函数
我们可以二分它的答案，即长度 $l$。

对于当前所枚举到的 $mid$ 来说，我们可以按顺序枚举当前是第几个长度为 $mid$ 的正方形，枚举完后就将刚刚所枚举过的包含在里面的树打上 $tag$（这棵树被第几个正方形所覆盖），这串数可以用一个数组 ```tree``` 来记录。

在 ```check``` 函数中，我们可以用一个 ```dfs``` 函数来枚举当前所放的正方形是否可行，然后用一个 ```cover``` 函数来判断现在的长度为 $l$ 的正方形可以覆盖哪些树。

就像这样：
```cpp
void cover(int x,int y,int l,int tag){//覆盖
	for(R i=1; i<=n; i++){
		if(tree[i]||x-l>a[i].x||x<a[i].x||y<a[i].y||y-l>a[i].y)continue;
		tree[i]=tag;
	}
}
```
在覆盖完后就直接枚举下一个正方形是否可行，最后用一个 ```clear``` 函数清空当前所标记的 ```tag``` 即可（回溯）。

就像这样：
```cpp
void clear(int tag){//撤销覆盖
	for(R i=1; i<=n; i++)
		if(tree[i]==tag)tree[i]=0;
}
```

最后再将这些函数拼接在一起即可（```cover``` 函数要枚举这个正方形的右上方顶点的坐标）。

PS：在枚举完三个正方形后要枚举剩余没有覆盖的树的个数是否为 $0$。

就像这样：
```cpp
int cnt=0;
	for(R i=1; i<=n; i++){
		if(tree[i])continue;
		cnt++;
	}
	if(tag>3)return !cnt;//tag 代表现在是第几个正方形
```
将这几个函数拼接在一起，就像这样：
```cpp
void clear(int tag){//撤销覆盖
	for(R i=1; i<=n; i++)
		if(tree[i]==tag)tree[i]=0;
}
void cover(int x,int y,int l,int tag){//覆盖
	for(R i=1; i<=n; i++){
		if(tree[i]||x-l>a[i].x||x<a[i].x||y<a[i].y||y-l>a[i].y)continue;
		tree[i]=tag;
	}
}
bool dfs(int l,int tag){
	int cnt=0,maxx=-1e9,maxy=-1e9,minx=1e9,miny=1e9;
	for(R i=1; i<=n; i++){
		if(tree[i])continue;
		maxx=max(maxx,a[i].x),minx=min(minx,a[i].x);
		maxy=max(maxy,a[i].y),miny=min(miny,a[i].y);
		cnt++;
	}
	if(tag>3)return !cnt;

	//覆盖的正方形的方位在哪个地方
	cover(maxx,miny+l,l,tag);//右下
	if(dfs(l,tag+1))return 1;
	clear(tag);

	cover(maxx,maxy,l,tag);//右上
	if(dfs(l,tag+1))return 1;
	clear(tag);

	cover(minx+l,miny+l,l,tag);//左下
	if(dfs(l,tag+1))return 1;
	clear(tag);

	cover(minx+l,maxy,l,tag);//左上
	if(dfs(l,tag+1))return 1;
	clear(tag);
	return 0;
}
bool check(int x){
	for(R i=1; i<=n; i++)tree[i]=0;
	return dfs(x,1);
}
```
---
最后再写一写最基础的二分：
```cpp
int l=0,mid,r=2e9;
	while(l<r){
		mid=l+r>>1;
		if(check(mid))r=mid;
		else l=mid+1;
	}
	cout<<l;
```
## AC 代码
```cpp
#include<bits/stdc++.h>
#define ll long long
#define R register int
using namespace std;
const int N=2e4+1;
struct node{int x,y;}a[N];
int n,tree[N];
void clear(int tag){
	for(R i=1; i<=n; i++)
		if(tree[i]==tag)tree[i]=0;
}
void cover(int x,int y,int l,int tag){
	for(R i=1; i<=n; i++){
		if(tree[i]||x-l>a[i].x||x<a[i].x||y<a[i].y||y-l>a[i].y)continue;
		tree[i]=tag;
	}
}
bool dfs(int l,int tag){
	int cnt=0,maxx=-1e9,maxy=-1e9,minx=1e9,miny=1e9;
	for(R i=1; i<=n; i++){
		if(tree[i])continue;
		maxx=max(maxx,a[i].x),minx=min(minx,a[i].x);
		maxy=max(maxy,a[i].y),miny=min(miny,a[i].y);
		cnt++;
	}
	if(tag>3)return !cnt;

	cover(maxx,miny+l,l,tag);
	if(dfs(l,tag+1))return 1;
	clear(tag);

	cover(maxx,maxy,l,tag);
	if(dfs(l,tag+1))return 1;
	clear(tag);

	cover(minx+l,miny+l,l,tag);
	if(dfs(l,tag+1))return 1;
	clear(tag);

	cover(minx+l,maxy,l,tag);
	if(dfs(l,tag+1))return 1;
	clear(tag);
	return 0;
}
bool check(int x){
	for(R i=1; i<=n; i++)tree[i]=0;
	return dfs(x,1);
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(R i=1; i<=n; i++)cin>>a[i].x>>a[i].y;
	int l=0,mid,r=2e9;
	while(l<r){
		mid=l+r>>1;
		if(check(mid))r=mid;
		else l=mid+1;
	}
	cout<<l;
	return 0;
}

```

---

## 作者：kiritokazuto (赞：4)

# ~~目前~~的最优解来了...
**[更好的阅读体验](https://www.cnblogs.com/kiritokazuto/p/15897101.html)**
#### 分析
>可能这个思路已经有人写过了，但还是加一点自己的理解吧

>首先去将所有点的极差（左右，上下）求出来构造一个初始的矩形，能够覆盖所有的点，

>又因为要放三个正方形，那么必须要有一个正方形在矩形的四个角
>那么之后我们只需要枚举第一个正方形在四个角之后，再去放另外两个正方形
> 那么我们在考虑用两个正方形去填满一个新的大矩形（用没被第一个正方形覆盖的点去构造，还是极差），手模之后会发现只有两种情况，一个在左上，一个在右下，或者一个在右上，一个在左下

>假设是 一个在左上一个在右下

>我们能知道在左上的正方形一定要盖住横坐标最左的
和纵坐标最上的点 　
同理，那么处于右下方的正方形也同样
于是，我们可以愉快地开始coding了

#### 这个码风有点奇怪..当时还没改过，现在好点了
```cpp
#include <bits/stdc++.h>
using namespace std;
	

namespace kiritokazuto {
	template <typename T> inline void in(T &x) {
		int f = 0; x = 0; char c = getchar();
		while(c < '0' || c > '9')f |= c == '-', c = getchar();
		while(c >= '0' && c <= '9')x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();
		x = f ? -x : x;
	}
	template <typename T> inline void ot(T x) {
		if(x < 0)putchar('-'), x = -x;
		if(x > 9)ot(x / 10);putchar(x % 10 | '0');
	}
}

using namespace kiritokazuto;

namespace work {
	#define Re register int
	#define ki kiritokazuto
	#define LL long long 
	static const int maxn = 1e4 + 10, Inf = 2147483647;
	struct WMX{
		int x, y;
	}a[maxn];
	int n, m, L, R;
	int cobe[maxn];
	int num = 0;
	inline bool cover(int len) {
		if(!num)return true;
		Re i;
		int l, r, up, down;
		l = down = Inf;
		r = up = -Inf;
		for(i = 1; i <= num; i++) {
			l = min(l, a[cobe[i]].x);
			r = max(r, a[cobe[i]].x);
			up = max(up, a[cobe[i]].y);
			down = min(down, a[cobe[i]].y);
		}
	    /*一个角建好，枚举剩余两个正方形 
	    枚举这两个正方形放在哪里，才能尽量覆盖全部点
　　    一种是一个在左上一个在右下
        另外一种是 一个在右上一个在左下。
		*/
		for(i = 1; i <= num; i ++) {
			if(!(a[cobe[i]].x <= l + len && a[cobe[i]].y <= down + len ||
				 a[cobe[i]].x >= r - len && a[cobe[i]].y >= up - len) )break;
		}
		if(i > num)return true;//没有跳出i = num + 1全覆盖，true
		for(i = 1; i <= num; i ++) {
			if(!(a[cobe[i]].x <= l + len && a[cobe[i]].y >= up - len ||
				 a[cobe[i]].x >= r - len && a[cobe[i]].y <= down + len) )break;
		}
		if(i > num)return true;
		else return false;
	}

	
	inline void creat(int l, int r, int down, int up){
		Re i;//此处不可将Re放进去，否则会重新定义一个局部的num，而非全局 
		for(i = 1, num = 0; i <= n; i ++) {
			if(a[i].x < l || a[i].x > r || a[i].y < down || a[i].y > up) {
				cobe[++num] = i;
			}
		}
	}


	inline void kirito() {
		in(n);
		int l, r, up, down;
		l = down = Inf;
		r = up = -Inf;
		for(int i = 1; i <= n; i ++) {
			in(a[i].x);
			in(a[i].y);
			l = min(l, a[i].x);
			r = max(r, a[i].x);
			up = max(up, a[i].y);
			down = min(down, a[i].y);
		}
		L = 0;
		R = max(up - down, r - l);//先构造出能覆盖所有点的矩形
		Re i;
		while(L < R) { 
			int mid = (L + R) / 2;
			for(i = 1; i <= 4; i++) {//枚举四个角 
				if(i == 1)creat(l, l + mid, down, down + mid);
				else if(i == 2)creat(l, l + mid, up - mid, up);
				else if(i == 3)creat(r - mid, r, down, down + mid);
				else if(i == 4)creat(r - mid, r, up - mid, up);
				if(cover(mid))break;
			}
			if(i <= 4) R = mid;//终止条件没有等于 
			else L = mid + 1;//四个角都不行，加长
			//如果for执行完i = 5; 
		}
		ot(L);
	
	}
}

signed main() {
	work :: kirito();
}

```



---

## 作者：MZAutomata (赞：3)

我们先简化问题，考虑只用一个矩形覆盖所有点，那么这个矩形的大小、位置都是容易确定的——于是我们就可以用二分答案确定三个正方形的大小，并检查是否能用他们覆盖整个矩形。

显然，矩形的每一边上都有若干点，于是它的四边必须都与一个正方形的一边重合。

因为正方形只有三个，于是必有一正方形同时有两边与矩形的两边重合，即紧贴在矩形的一个角上，于是用 DFS 枚举当前正方形在矩形的四个角上的四种情况并染色判断即可。

### $Code$
```cpp
#include<cstdio>
#include<algorithm>
#define MAX(a,b) (a>b?a:b)
#define MIN(a,b) (a<b?a:b)
struct tree
{
	int x,y,cl;
	bool operator<(const tree k)
	const{return x==k.x?y<k.y:x<k.x;}
}a[50000];
int n;
void update(int x1,int y1,int x2,int y2,int cl)
{
	for(int i(1);i<=n;i++)
	  if(a[i].x>=x1&&a[i].x<=x2&&a[i].y>=y1&&a[i].y<=y2&&!a[i].cl)
		a[i].cl=cl;
}
void clr(int cl)
{
	for(int i(1);i<=n;i++)
	  if(a[i].cl==cl)a[i].cl=0;
}
bool dfs(int cl,int k)
{
	if(cl>3)return false;
	int x1(2e9),y1(2e9),x2(-2e9),y2(-2e9),lx,ly,i;
	for(i=1;i<=n;i++)
	  if(!a[i].cl)
		x1=MIN(a[i].x,x1),y1=MIN(a[i].y,y1),
		x2=MAX(a[i].x,x2),y2=MAX(a[i].y,y2);
	lx=x2-x1,ly=y2-y1;
	if(MAX(lx,ly)<=k)return true;
	update(x1,y1,x1+k,y1+k,cl);
	if(dfs(cl+1,k))return true;clr(cl);
	update(x1,y2-k,x1+k,y2,cl);
	if(dfs(cl+1,k))return true;clr(cl);
	update(x2-k,y1,x2,y1+k,cl);
	if(dfs(cl+1,k))return true;clr(cl);
	update(x2-k,y2-k,x2,y2,cl);
	if(dfs(cl+1,k))return true;clr(cl);
	return false;
}
int main()
{
	int l(0),r(2e9+1),mid,ans(2e9+5),i,j;
	scanf("%d",&n);
	for(i=1;i<=n;i++)scanf("%d %d",&a[i].x,&a[i].y);
	std::sort(a+1,a+n+1);
	for(;l<=r;)
	{
		for(i=1;i<=n;i++)a[i].cl=0;
		if(dfs(1,mid=l+r>>1))
		  r=mid-1,ans=mid;
		else l=mid+1;
	}
	printf("%d",ans);
	return ~~(0-0);
}
```


---

## 作者：KSToki (赞：3)

机房里有兄弟觉得题解说得不是很清楚，于是我就来发一篇题解。
# 题目大意
在坐标系上有 $n$ 个点，求一个最小的 $L$，使得用三个 $L\times L$ 的边平行于坐标轴的正方形能够完全覆盖这些点。
# 题目分析
类似的套路已经很多了，求最小的可行方案如果直接求不好求那就用二分，观察数据范围发现 $O(nlogn)$ 完全跑得过，甚至还能多带几个。于是需要解决的问题是 $O(n)$ 判断二分出的 $L$ 是否合法。

首先预处理出一个矩形 $A$，它恰好能够覆盖所有的点。放第一个正方形时，如果能直接覆盖完，那肯定是合法的；否则它一定位于矩形 $A$ 的四个角之一，这个其它题解都有，可以手玩感受一下，简单的证明就是正方形和矩形都是四个直的角和边，想要覆盖到把边界拓宽到最大的位置的点（矩形 $A$ 边上的点）那正方形必定有边与其重合，而放在角落对两条边都能造成影响，一定是最佳的。

放置好第一个正方形后，删除被覆盖的点（具体可以通过打标记来实现），类似与构造矩形 $A$ 那样对剩余的点求出矩形 $B$，它恰好能够覆盖所有的剩余点。按刚刚的方法再处理第二个正方形，类似地得到矩形 $C$，这时只剩下一个正方形，直接判断能否覆盖就可以了。每次的删除、构建新矩阵、恢复都是 $O(n)$ 的，它们都是分开的，于是总体复杂度为 $O(nlogn)$。

具体实现上并不需要开 `long long`，如果不想写深搜回溯可以复制粘贴再搞一个函数，个人认为递归层数不多这样会清晰些不容易错。
# 代码
```cpp
#include<bits/stdc++.h>
#define YPC rubbish 
#define R register
#define I inline
#define ll long long
#define ull unsigned long long
#define LL __int128
#define db double
using namespace std;
#define pb push_back
#define pii pair<int,int>
#define pli pair<ll,int>
#define pll pair<ll,ll>
#define mp(x,y) make_pair(x,y)
#define piii pair<pair<int,int>,int>
#define mp3(x,y,z) make_pair(make_pair(x,y),z)
#define fi first
#define se second
#define putint(x) printf("%d\n",x)
#define putll(x) printf("%lld\n",x)
#define putull(x) printf("%llu\n",x)
#define lowbit(x) ((x)&(-(x)))
#define chkmin(x,y) (x=min(x,y))
#define chkmax(x,y) (x=max(x,y))
#define inv(x) ksm(x,Mod-2)
#define inf (1e9)
#define INF (1e18)
#define eps (1e-8)
#define For(i,x,y) for(R int i=x;i<=y;++i)
#define For2(i,x,y,k) for(R int i=x;i<=y;i+=k)
#define Rof(i,x,y) for(R int i=x;i>=y;--i)
#define Rof2(i,x,y,k) for(R int i=x;i>=y;i-=k)
#define ForG(i,edge,x) for(auto i:edge[x])
I int read()
{
	char ch=getchar();
	int res=0,flag=1;
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')
			flag=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		res=res*10+ch-'0';
		ch=getchar();
	}
	return res*flag;
}
int n,x[20001],y[20001],l,r,mid,ans,v[20001];
void update(int lx,int ly,int rx,int ry,int d)
{
	For(i,1,n)
		if(x[i]>=lx&&x[i]<=rx&&y[i]>=ly&&y[i]<=ry)
			v[i]+=d;
}
void getmat(int &lx,int &ly,int &rx,int &ry)
{
	lx=inf,ly=inf,rx=-inf,ry=-inf;
	For(i,1,n)
		if(!v[i])
		{
			chkmin(lx,x[i]);
			chkmin(ly,y[i]);
			chkmax(rx,x[i]);
			chkmax(ry,y[i]);
		}
}
bool over(int lx,int ly,int rx,int ry,int k)
{
	return rx-lx<=k&&ry-ly<=k;
}
bool solve(int lx,int ly,int rx,int ry,int k)
{
	if(over(lx,ly,rx,ry,k))
		return 1;
	int Lx,Ly,Rx,Ry;
	update(lx,ly,lx+k,ly+k,1);
	getmat(Lx,Ly,Rx,Ry);
	if(over(Lx,Ly,Rx,Ry,k))
		return 1;
	update(lx,ly,lx+k,ly+k,-1);
	
	update(lx,ry-k,lx+k,ry,1);
	getmat(Lx,Ly,Rx,Ry);
	if(over(Lx,Ly,Rx,Ry,k))
		return 1;
	update(lx,ry-k,lx+k,ry,-1);
	
	update(rx-k,ly,rx,ly+k,1);
	getmat(Lx,Ly,Rx,Ry);
	if(over(Lx,Ly,Rx,Ry,k))
		return 1;
	update(rx-k,ly,rx,ly+k,-1);
	
	update(rx-k,ry-k,rx,ry,1);
	getmat(Lx,Ly,Rx,Ry);
	if(over(Lx,Ly,Rx,Ry,k))
		return 1;
	update(rx-k,ry-k,rx,ry,-1);
	return 0;
}
bool check(int lx,int ly,int rx,int ry,int k)
{
	int Lx,Ly,Rx,Ry;
	update(lx,ly,lx+k,ly+k,1);
	getmat(Lx,Ly,Rx,Ry);
	if(solve(Lx,Ly,Rx,Ry,k))
		return 1;
	update(lx,ly,lx+k,ly+k,-1);
	
	update(lx,ry-k,lx+k,ry,1);
	getmat(Lx,Ly,Rx,Ry);
	if(solve(Lx,Ly,Rx,Ry,k))
		return 1;
	update(lx,ry-k,lx+k,ry,-1);
	
	update(rx-k,ly,rx,ly+k,1);
	getmat(Lx,Ly,Rx,Ry);
	if(solve(Lx,Ly,Rx,Ry,k))
		return 1;
	update(rx-k,ly,rx,ly+k,-1);
	
	update(rx-k,ry-k,rx,ry,1);
	getmat(Lx,Ly,Rx,Ry);
	if(solve(Lx,Ly,Rx,Ry,k))
		return 1;
	update(rx-k,ry-k,rx,ry,-1);
	return 0;
}
int main()
{
	n=read();
	For(i,1,n)
	{
		x[i]=read();
		y[i]=read();
	}
	int lx,ly,rx,ry; 
	getmat(lx,ly,rx,ry);
	r=max(rx-lx,ry-ly);
	while(l<=r)
	{
		mid=(l+r)>>1;
		memset(v,0,sizeof(v));
		if(check(lx,ly,rx,ry,mid))
		{
			ans=mid;
			r=mid-1;
		}
		else
			l=mid+1;
	}
	putint(ans);
	return 0;
}
```


---

## 作者：WOL_GO (赞：2)

# [题目传送门](https://www.luogu.com.cn/problem/P2218)

本蒟蒻的第一篇紫题题解。

## 题目大意

给出你 $n$ 棵树，求 $3$ 个最小的相等正方形使 $3$ 个正方形能覆盖所有的树。

## 思路

对于最终的答案 $ans$，一定满足边长为 $ans+1$ 的 $3$ 个正方形也能覆盖所有的树，但边长为 $ans-1$ 的 $3$ 个正方形一定不能覆盖所有的树。所以，这题的答案具有单调性，可以用二分答案解决。

### check思路

首先，我们可以用一个最小的矩形来覆盖所有的树，然后把四个角落标记起来。然后我们可以证明这个矩形的四条边上都是有树的，所以至少有一个正方形需要覆盖矩形的至少两条边，所以可以直接枚举 $4$ 个角落放正方形的情况，然后第 $2$ 和第 $3$ 个正方形同理，最后判断一下能否完全覆盖方可。

## 代码

```
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+5;
void read(int &xx){
    register char ch=getchar();
    register int ans=0;
    char t=0;
    while(!isdigit(ch))t|=ch=='-',ch=getchar/*_unlocked*/();
    while(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch^48),ch=getchar/*_unlocked*/();
    xx=t?-ans:ans;
    return ;
}
void write(int x){
    if(x<0){
        putchar('-');
        x*=-1;
    }
    char wr[18];
    int cnt=1;
    if(x==0){
        putchar('0');
        putchar('\n');
        return ;
    }
    while(x){
        wr[cnt++]=x%10+'0';
        x/=10;
    }
    for(cnt--;cnt;cnt--){
        putchar(wr[cnt]);
    }
    putchar('\n');
    return;
}
struct pla{
    int x,y;
}a[maxn];
int n,tree[maxn];
void clear(int x){
    for(int i=1;i<=n;i++){
        if(tree[i]==x)tree[i]=0;
    }
}
void cover(int x,int y,int len,int col){
    for(int i=1;i<=n;i++){
        if(!tree[i]&&a[i].x>=x&&a[i].x<=x+len&&a[i].y>=y&&a[i].y<=y+len){
            tree[i]=col;
        }
    }
}
bool dfs(int len,int cnt){
    pla minn={1000000000,1000000000},maxx={-1000000000,-1000000000};
    int tot=0;
    for(int i=1;i<=n;i++){
        if(tree[i])continue;
        minn.x=min(minn.x,a[i].x);
        minn.y=min(minn.y,a[i].y);
        maxx.x=max(maxx.x,a[i].x);
        maxx.y=max(maxx.y,a[i].y);
        tot++;
    }
    if(cnt==4)return tot==0;
    cover(minn.x,minn.y,len,cnt);
    if(dfs(len,cnt+1))return 1;
    clear(cnt);
    cover(minn.x,maxx.y-len,len,cnt);
    if(dfs(len,cnt+1))return 1;
    clear(cnt);
    cover(maxx.x-len,minn.y,len,cnt);
    if(dfs(len,cnt+1))return 1;
    clear(cnt);
    cover(maxx.x-len,maxx.x-len,len,cnt);
    if(dfs(len,cnt+1))return 1;
    clear(cnt);
    return 0;
}
bool check(int len){
    memset(tree,0,sizeof(tree));
    if(dfs(len,1))return 1;
    return 0;
}
int main(){
    read(n);
    for(int i=1;i<=n;i++)read(a[i].x),read(a[i].y);
    int l=1,r=1e9,mid;
    while(l<r){
        mid=l+r>>1;
        if(check(mid))r=mid;
        else l=mid+1;
    }
    write(l);
    return 0;
}
```

---

## 作者：张语诚ZYC (赞：1)

## 前言

题目链接：[LINK](https://www.luogu.com.cn/problem/P2218)

~~萌新第一次交紫题题解~~，**如有错误之处还望大佬们指出**，这里会尽力让思路清晰。

## 思路分析

首先我们要有一个**前置知识**：如果 $3$ 个较小正方形能够覆盖所有的点，那么较大的正方形就一定能够覆盖所有的点。（这很容易想到）

有了这个想法，我们再试想：**如果可以在一个可接受的复杂度内判断 $3$ 个当前大小正方形是否可以覆盖所有的点**，那么问题解决了！（至于怎么判断，后面会说）

令 $L$ 初始等于 $1$ ，当三个 $L$ 不能覆盖所有点时，令 $L$ 倍增，当三个 $L$ 可以覆盖所有点时，在当前 $L$ 与上一个 $L$ 内进行二分即可找到最小的 $L$ 值。二分与倍增的时间复杂度是非常优秀的。

现在重点讨论一下如何判断 $3$ 个当前大小正方形是否可以覆盖所有的点。

首先我们拿到一张图：

[![](https://pic2.imgdb.cn/item/644facc10d2dde577760a5f7.png)](https://pic2.imgdb.cn/item/644facc10d2dde577760a5f7.png)

现在我们找到上下左右最边界的 $4$ 个点（或者至少 $4$ 个，不过思路一样）：

[![](https://pic2.imgdb.cn/item/644fad610d2dde5777613dc4.png)](https://pic2.imgdb.cn/item/644fad610d2dde5777613dc4.png)

根据抽屉原理：一共有 $3$ 个正方形，共有 $4$ 个边界点，那么至少一个正方形要覆盖到黄色长方形的一个角上。

[![](https://pic2.imgdb.cn/item/644fae460d2dde577762156a.png)](https://pic2.imgdb.cn/item/644fae460d2dde577762156a.png)

当然在哪个角上呢，我们并不知道，不过我们可以枚举每一个角，在每一个角的情况下分别考虑，看看是否有一个叫满足题意。

删去第一个正方形覆盖的点，至于第二个正方形，还是按照上述的思路重复做即可，也枚举边框举行四个角分别考虑。

删再去第二个点覆盖的点，判断第三个正方形能否能覆盖剩下的点即可（比较 $L$ 与剩下点边界正方形长宽的大小）。

至此，此题完成。

## 后记

个人认为思路还是比较清晰的，代码就不贴了。

时间复杂度还是可以接受的，美中不足的是两次枚举四个角带一个 $16$ 的常数，并无较大影响，只要其他部分常数合理，就可以通过，如果有大佬有更好的解决方案，欢迎补充！

$$\texttt{The End by 张语诚ZYC}$$

---

## 作者：alvis (赞：1)

## 简述题意

给出平面内的 $\text{N}$ 个点，第 $\text{i}$ 个点的坐标为 $\operatorname{(x_i,y_i)}$。

平面上画三个 $\text{L}\times\text{L}$  的正方形，使得每个点至少被一个正方形覆盖。

求出最小的 $\text{L}$ 使得可以画出这样三个正方形。

## 解决

这是我们老师让我们做的题。

这道题最容易想到的就是枚举 $\text{L}$，判断是否可以画出三个正方形。

可以证明，**前两个正方形的上边界和左边界一定卡在点上**。

因此只要枚举它们分别卡在哪些点上，最后判断剩余点能否用一个正方形框起来即可。

但是这样一来，很显然不过（~~所以你为什么要写啊~~。所以我也没敲这个代码~~为了水字数~~。

所以我们考虑二分  $\text{L}$ 的值。然后我们再用上文中的方法进行计算。时间复杂度大概是 $\operatorname{O(n^5)}$，比上述算法稍好一些，然而依旧是过不了的。

那么我们考虑如何更快地判断 $\text{L}$ 是否可行。

首先算出所有点的四个边界，那么第一个正方形一定卡在其中一个角上。有关它的证明，也非常简单：因为只有三个正方形，然而有四个角和四条边，而每边至少有一点，那么显然**角落上必然有一个正方形**。

接着去掉覆盖到的点，第二个正方形还会卡在角上。最后看剩余点能否用一个正方形框起来。

它的时间复杂度大概是$\operatorname{O(n log10^8)}$ 。

## 代码
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include <iostream>
using namespace std;

const int inf=2e9;
int n,x[20005],y[20005],c[20005];

void cover(int X, int Y, int L, int w){
	for(int i = 1;i <= n;i ++)
		if(x[i] >= X && x[i] <= X+L && y[i] >= Y && y[i] <= Y+L)
			c[i] += w;
}
//获得当前点能组成的最小矩形
void getborder(int&X, int&Y, int&xx, int&yy){
	X = Y = inf, xx = yy = -inf;
	for(int i = 1;i <= n;i ++)
		if(!c[i]){
		X = min(X, x[i]);
		xx = max(xx, x[i]);
		Y = min(Y, y[i]);
		yy = max(yy, y[i]);
	}
}
//对最后一个正方形的放置进行判断
bool end_check(int L){
	int x, y, xx, yy;
	getborder(x, y, xx, yy);
	if(x == inf)return true;
	return xx-x <= L && yy-y <= L;
}
//对第二个正方形的放置进行查找
bool mid_check(int L){
	int x, y, xx, yy;
	getborder(x, y, xx, yy);
	if(x == inf)return true;
	
	cover(x, y, L, 1);
	if(end_check(L))return true;
	cover(x, y, L, -1);
	
	cover(xx-L, y, L, 1);
	if(end_check(L))return true;
	cover(xx-L, y, L, -1);
	
	cover(x, yy-L, L, 1);
	if(end_check(L))return true;
	cover(x, yy-L, L, -1);
	
	cover(xx-L, yy-L, L, 1);
	if(end_check(L))return true;
	cover(xx-L, yy-L, L, -1);
	return false;
}
//对第一个正方形的放置进行查找
bool check(int L){
	for(int i = 1;i <= n;i ++)c[i] = 0;
	int x, y, xx, yy;
	getborder(x, y, xx, yy);
	
	cover(x, y, L, 1);
	if(mid_check(L))return true;
	cover(x, y, L, -1);
	
	cover(xx-L, y, L, 1);
	if(mid_check(L))return true;
	cover(xx-L, y, L, -1);
	
	cover(x, yy-L, L, 1);
	if(mid_check(L))return true;
	cover(x, yy-L, L, -1);
	
	cover(xx-L, yy-L, L, 1);
	if(mid_check(L))return true;
	cover(xx-L, yy-L, L, -1);
	
	return false;
}
int main(){
	ios::sync_with_stdio(false);
	cin >> n;
	int mxx=-inf, mxy=-inf, mnx=inf, mny=inf;
	for(int i=1;i<=n;i++){
		cin >> x[i] >> y[i];
		mxx=max(mxx, x[i]);
		mnx=min(mnx, x[i]);
		mxy=max(mxy, y[i]);
		mny=min(mny, y[i]);
	}
	if(!check(0)){
		int l=0, r=max(mxx-mnx, mxy-mny);
		while(r-l>1)
		{	int mid=(l+r)/2;
			if(check(mid))r=mid;
			else l=mid;
		}
		cout << r;
	}else cout << 0;
	return 0;
}
```



---

## 作者：Cl41Mi5deeD (赞：0)

注意到答案有单调性，考虑二分。

 - 所有小树都可以被一个矩形框起来，显然让**三个**正方形都在这个尽可能小的矩形中，才可能得到最小的边长。
 - 如果每放置一个正方形，把覆盖掉的小树忽略掉，重新找到一个框住小树的尽可能小的矩形，那么整个过程**至多会有三个**不同的矩形。
 - 由于矩形尽可能小，所以每个矩形的边界上都**至少有一颗待覆盖的小树**，一个这样的小树可以确定至少一条边界。
 - 考虑每次获得这样的矩形，用二分边长得到的三个正方形逐个覆盖。
 - 显然，覆盖所有边界上的小树是覆盖所有小树的**必要条件**，我们**枚举**每次得到的矩形的**四个端点**放置。在合适的边长下，三个正方形可以在覆盖边界小树的基础上覆盖矩形内部的小树，放完三个正方形检查一下就好了。

搜索树其实不庞大，无需过多优化。

```cpp

#include<bits/stdc++.h>
#define MAXN 20005
#define int long long
using namespace std;
int n,ans;
const int inf=1e18;
struct node{
	int x,y;
	bool vis;
}p[MAXN];
int maxx=-inf,minx=inf,maxy=-inf,miny=inf;
void fill(int x_1,int y_1,int x_2,int y_2,bool val){
	if(x_1>x_2)swap(x_1,x_2);
	if(y_1>y_2)swap(y_1,y_2);
	for(int i=1;i<=n;i++){
		if(p[i].x>=x_1&&p[i].x<=x_2&&p[i].y>=y_1&&p[i].y<=y_2)p[i].vis=val;
	}
}
bool check(int siz,int turn){
	int xx=-inf,nx=inf,xy=-inf,ny=inf;
	for(int i=1;i<=n;i++){
		if(!p[i].vis){
			xx=max(xx,p[i].x);
			nx=min(nx,p[i].x);
			xy=max(xy,p[i].y);
			ny=min(ny,p[i].y);
		}
	}
	if(turn==4){
		for(int i=1;i<=n;i++)if(!p[i].vis)return 0;
		return 1;
	}
	fill(nx,xy,nx+siz,xy-siz,1);
	if(check(siz,turn+1))return 1;
	fill(nx,xy,nx+siz,xy-siz,0);
	fill(xx,xy,xx-siz,xy-siz,1);
	if(check(siz,turn+1))return 1;
	fill(xx,xy,xx-siz,xy-siz,0);
	fill(nx,ny,nx+siz,ny+siz,1);
	if(check(siz,turn+1))return 1;
	fill(nx,ny,nx+siz,ny+siz,0);
	fill(xx,ny,xx-siz,ny+siz,1);
	if(check(siz,turn+1))return 1;
	fill(xx,ny,xx-siz,ny+siz,0);
	return 0;	
}
signed main(){
	int l=1,r=-1;
	scanf("%d",&n);
	for(int i=1,x,y;i<=n;i++){
		scanf("%lld%lld",&x,&y);
		p[i].x=x,p[i].y=y;
		maxx=max(maxx,x);
		minx=min(minx,x);
		maxy=max(maxy,y);
		miny=min(miny,y);	
	}
	r=max(maxx-minx,maxy-miny);
	//printf("%lld %lld %lld %lld\n",maxx,minx,maxy,miny);
	while(r>=l){
		for(int i=1;i<=n;i++)p[i].vis=0;
		int mid=l+r>>1;//printf("min:%lld",mid);
		if(check(mid,1))r=mid-1,ans=mid;
		else l=mid+1/*,printf("failed\n")*/;
	}
	printf("%lld",ans);
	return 0;
}
```
一些坑点
- 注意 check 函数返回 1 后有没有清空标记，可以每次二分都清一次。
- 每次放一个正方形都要更新矩形的端点。
- 记录矩形坐标极值的变量记得开到 check 里头。

---


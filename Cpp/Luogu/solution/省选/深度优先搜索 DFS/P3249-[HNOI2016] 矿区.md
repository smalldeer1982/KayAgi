# [HNOI2016] 矿区

## 题目描述

平面上的矿区划分成了若干个开发区域。

简单地说，你可以将矿区看成一张连通的平面图，平面图划分为了若干平面块，每个平面块即为一个开发区域，平面块之间的边界必定由若干整点(坐标值为整数的点)和连接这些整点的线段组成。每个开发区域的矿量与该开发区域的面积有关：具体而言，面积为 $ s $ 的开发区域的矿量为 $ s^2 $。

现在有 $ m $ 个开采计划。每个开采计划都指定了一个由若干开发区域组成的多边形，一个开采计划的优先度被规定为矿量的总和÷开发区域的面积和；例如，若某开采计划指定两个开发区域，面积分别为 $ a $ 和 $ b $，则优先度为 $ (a^2+b^2)/(a+b) $。由于平面图是按照划分开发区域边界的点和边给出的，因此每个开采计划也只说明了其指定多边形的边界，并未详细指明是哪些开发区域（但很明显，只要给出了多边形的边界就可以求出是些开发区域）。

你的任务是求出每个开采计划的优先度。为了避免精度问题，你的答案必须按照分数的格式输出，即求出分子和分母，且必须是最简形式（分子和分母都为整数，而且都消除了最大公约数；例如，若矿量总和是 $ 1.5 $，面积和是 $ 2 $，那么分子应为 $ 3 $，分母应为 $ 4 $；又如，若矿量和是 $ 2 $，面积和是 $ 4 $，那么分子应为 
 $ 1 $，分母应为 $ 2 $）。

由于某些原因，你必须依次对每个开采计划求解（即下一个开采计划会按一定格式加密，加密的方式与上一个开采计划的答案有关）。具体的加密方式见输入格式。

## 说明/提示

### 样例解释

输入文件给出的 $9$ 个点和 $14$ 条边描述的平面图如下所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/cg70enmo.png)

第一个开采计划，输入的第 $1$ 个值为 $3$，所以该开采计划对应的多边形有 $(3+0)\bmod 8+1=4$ 个点，将接下的 $4$ 个数 $3,0,4,7$，分别代入 $(z_i+0)\bmod n+1$ 得到 $4$ 个点的编号为 $4,1,5,8$。计算出第一个开采计划的分子为 $1$，分母为 $1$。

类似地，可计算出余下开采计划的多边形的点数和点的编号：第二个开采计划对应的多边形有 $3$ 个点，编号分别为 $5,6,8$。第三个开采计划对应的多边形有 $6$ 个点，编号分别为 $1,2,6,5,8,4$。第四个开采计划对应的多边形有 $5$ 个点，编号分别为 $1,2,6,8,4$。第五个开采计划对应的多边形有 $6$ 个点，编号分别为 $1,5,6,8,7,4$。

### 数据范围及约定


对于 $ 100 \% $ 的数据，$ n, k \leq 2 \times 10^5, \  m \leq 3n-6, \  |x_i|, |y_i| \leq 3×10^4$。

所有开采计划的 $ d $ 之和不超过 $2 \times 10^6$。保证任何开采计划都包含至少一个开发区域，且这些开发区域构成一个连通块。

保证所有开发区域的矿量和不超过 $ 2^{63}-1 $。

保证平面图中没有多余的点和边。

保证数据合法。由于输入数据量较大，建议使用读入优化。




## 样例 #1

### 输入

```
9 14 5
0 0
1 0
2 0
0 1
1 1
2 1
0 2
1 2
2 2
1 2
2 3
5 6
7 8
8 9
1 4
4 7
5 8
3 6
6 9
4 8
1 5
2 6
6 8
3 3 0 4 7 1 3 4 6 4 8 0 4 3 6 2 3 8 0 4 6 2 5 0 4 5 7 6 3```

### 输出

```
1 1 
1 2 
1 1 
9 10 
3 4```

# 题解

## 作者：litble (赞：25)

**平面图转对偶图**

所谓对偶图，就是将平面图中所有的面变成点，点变成面，边“旋转90度”后得到的图。

如何转对偶图，关键就是如何划分原图中的面，这个方法是，双向边先看成两条单向边，这样每条边都属于一个面，将以每一个点为起点的边极角排序，对于一条边(s,t)，我们在以t为起点的边中找到(t,s),排序后其上一条边就是当前面的下一条边界，这样一直找到整个区域闭合，就说明把这个面上的边全部找出来了。这个步骤可以利用STL中的vector轻松做到。

每条边连接两个面（即它所在的面和它的反向边所在的面），便建好了对偶图。在这个对偶图中随意地拿出一棵生成树，以无界域（即原图中外围无限的面）为根。如何找到无界域呢？利用叉积算有向面积的时候，算出来是负数的就是无界域。

然后标记所有树边，记录生成树上每棵子树中的矿区面积和及面积平方和。

对于一个询问，先找到这个询问里出现的边，如果是非树边就忽略，否则如果这条边所在的面是儿子，就加上子树的面积，是父亲，就减去儿子子树的面积。这个画画图可以感受一下。

```cpp
#include<bits/stdc++.h>
using namespace std;
int read() {
    int q=0,w=1;char ch=' ';
    while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();
    if(ch=='-') w=-1,ch=getchar();
    while(ch>='0'&&ch<='9') q=q*10+ch-'0',ch=getchar();
    return q*w;
}
typedef long long LL;
typedef double db;
const int N=200005,M=1200005;const db eps=1e-10;
#define RI register int
int n,m,Q,tot=1,cnt,rt;LL ans1,ans2;
struct point{int x,y;}p[N];
point operator - (point a,point b) {return (point){a.x-b.x,a.y-b.y};}
LL operator * (point a,point b) {return 1LL*a.x*b.y-1LL*a.y*b.x;}
struct edge{int id,u,v;db jd;}e[M];
bool operator < (edge a,edge b) {return fabs(a.jd-b.jd)<eps?a.v<b.v:a.jd<b.jd;}
int nxt[M],pos[M],f[M],vis[M],istr[M],ask[M];LL s[M],ss[M];
vector<edge> h[N],tr[M];

void link(int x,int y) {
    ++tot,e[tot]=(edge){tot,x,y,atan2(p[y].y-p[x].y,p[y].x-p[x].x)};
    h[x].push_back(e[tot]);
}
void build() {
    for(RI i=1;i<=n;++i) sort(h[i].begin(),h[i].end());
    for(RI i=2;i<=tot;++i) {
        int v=e[i].v;
        vector<edge>::iterator kl=lower_bound(h[v].begin(),h[v].end(),e[i^1]);
        if(kl==h[v].begin()) kl=h[v].end();//其前一条就是最后一条
        --kl,nxt[i]=(*kl).id;
    }
    for(RI i=2;i<=tot;++i) {
        if(pos[i]) continue;
        pos[i]=pos[nxt[i]]=++cnt;
        for(RI j=nxt[i];e[j].v!=e[i].u;j=nxt[j],pos[j]=cnt)
            s[cnt]+=(p[e[j].u]-p[e[i].u])*(p[e[j].v]-p[e[i].u]);//计算面积
        if(s[cnt]<=0) rt=cnt;//无穷域
    }
    for(RI i=2;i<=tot;++i) tr[pos[i]].push_back((edge){i,pos[i],pos[i^1]});
}
void dfs(int x,int las) {//生成树
    f[x]=las,ss[x]=1LL*s[x]*s[x],s[x]<<=1,vis[x]=1;
    //叉积算面积后应该除以2，但是为了避免小数，所以分子分母同时乘4
    for(RI i=0,sz=tr[x].size();i<sz;++i) {
        int v=tr[x][i].v;
        if(vis[v]) continue;
        istr[tr[x][i].id]=istr[tr[x][i].id^1]=1,dfs(v,x);
        s[x]+=s[v],ss[x]+=ss[v];
    }
}

LL gcd(LL a,LL b) {return b?gcd(b,a%b):a;}
void work() {
    while(Q--) {
        int js=(read()+ans1)%n+1;
        for(RI i=1;i<=js;++i) ask[i]=(read()+ans1)%n+1;
        ask[js+1]=ask[1],ans1=ans2=0;
        for(RI i=1;i<=js;++i) {
            int x=ask[i],y=ask[i+1];
            edge ke=(edge){0,x,y,atan2(p[y].y-p[x].y,p[y].x-p[x].x)};
            vector<edge>::iterator kl=lower_bound(h[x].begin(),h[x].end(),ke);//找边
            int j=(*kl).id;
            if(!istr[j]) continue;//该边所在区域，是儿子就加是父亲就减
            if(f[pos[j]]==pos[j^1]) ans1+=ss[pos[j]],ans2+=s[pos[j]];
            else ans1-=ss[pos[j^1]],ans2-=s[pos[j^1]];
        }
        LL tmp=gcd(ans1,ans2);
        ans1/=tmp,ans2/=tmp;
        printf("%lld %lld\n",ans1,ans2);
    }
}

int main()
{
    int x,y;
    n=read(),m=read(),Q=read();
    for(RI i=1;i<=n;++i) p[i]=(point){read(),read()};
    for(RI i=1;i<=m;++i) x=read(),y=read(),link(x,y),link(y,x);
    build(),dfs(rt,0),work();
    return 0;
}
```

---

## 作者：_Sein (赞：9)

大概的思路就是平面图转对偶图，然后平面当点建树，记录面积和面积的平方的子树和，利用一些性质求解。

这道题的难点就在于

1. 把已有的点，选择一些边，化成一个个独立的平面(有可能不封闭)。
2. 由于询问给定的是边界，如何判定边界中含有多少个独立平面。

对于第一个难点，可以采用平面图转对偶图的形式来实现，即定起点，进行极角排序。

找出一条边的后继边，划分平面。

不难发现，如果是双向边，若平面接壤，恰好是各占一条。

同时求平面面积，如果面积为负，则说明这个平面不封闭，由于在询问中不会产生贡献，可以把其当成树的根。

建树的时候，记录一下树边(即遍历到的的双向边)，面积和面积的平方的子树和，这个在询问时起到很大的作用。

如图

![20.PNG][1]

这个树建出来是一条链($1->2->3->4->5$)。

若询问要求$3,4$平面，那么也就是做一个容斥，$3$子树减去$5$子树即可。

由于边界上，一定含有一条树边连接$3$与$3$的父亲$2$，即红色的$BI$，以及$5$与$5$的父亲$4$，即红色的$DE$。

那么就可以利用这个性质，推广一下:如果在边界上碰到一条树边，判断一下这条边的方向(是由父亲指向儿子，还是儿子指向父亲)之后对贡献取一下正负就可以做到容斥。

其实这个方向没有太大必要，取个绝对值是一样的。

还有一个小技巧，由于面积可能出现$.5$的情况，乘下$2$就好了。



  [1]: http://lb2003.top/usr/uploads/2020/04/3513445950.png

---

## 作者：dengchengyu (赞：1)

# [HNOI2016] 矿区 Solution

神仙计算几何加图论题。

**题目大意**：给定一个连通平面图，平面图被分成很多个面，每次询问一个多边形的贡献，贡献是其中每个面的面积的平方和除以面积和。

**解题思路**：

我们需要把一个多边形内的每个面一起算，可以考虑对每个面之间连边，建出一棵生成树。

实际上就是平面图转成对偶图。对偶图：把原平面图的每个面看作一个点，把原图上有邻边的面在新图上对应的点连边。

首先我们需要找出每个面包含哪些边。对于一个点，把它的边按极角排序后，相邻的边就同属一个多边形。可以先枚举一条初始边，然后逆时针走向下一条极角比它小的边，直到走回初始边，这样就找到了一个面。
同时我们可以求这个多边形的面积与面积的平方，使用向量叉积求面积。由于我们是逆时针求，所以叉积是正的。

然后连边，首先每条边属于两个面，给这两个面连边即可。我们也可以知道面的个数是 $O(m)$ 的。

假如我们已经建出了生成树，那么每次询问一个多边形时，可以想象这个生成树会穿过多边形，对于一条进入多边形的树边就加上子树和，对于一条走出多边形的树边就减去子树和，发现我们就可以处理询问了。

但我们发现，这要求树根在多边形外。而刚好，我们求面时，会求到原平面图外范围无限的面（绕边界顺时针走），且由于是顺时针走的，所以面积叉积是负的，我们能容易地找到它。我们以这个无限的面为根即可。可以一次 DFS 求出生成树。

时间复杂度 $O((m+d)\log m)$。

**细节**：

* 叉积算面积需要除以二，而对应的面积的平方会除以四，我们可以在最后算答案时，给分母乘二即可。
* 不要使用 `map` 或 `unordered_map` 查找一个点上连的边，或者查找两个点之间连的边，那样会 TLE。最好用 `vector` 存下来排序，然后二分查找。

```cpp
const int N=2e5+5,M=6e5+5;
struct point{int x,y;};
int operator^(point a,point b){return a.x*b.y-b.x*a.y;}
int n,m,K,X[N],Y[N];
struct edge{int to,num; ld rad;};
int find(vector<edge> &x,ld rad){
	int l=0,r=x.size()-1,ans=0;
	while(l<=r){
		int mid=(l+r)>>1;
		if(x[mid].rad>rad)l=mid+1;
		else ans=mid,r=mid-1;
	}
	return ans;
}
vector<edge> G[N];
int tot,side[M*2],bz[M*2];
ll s1[M*2],s2[M*2];
int root,vis[M*2],fa[M*2];
vector<int> g[M*2];
void dfs(int x){
	vis[x]=1;
	for(int v:g[x])if(!vis[v]){
		fa[v]=x;
		dfs(v);
		s1[x]+=s1[v],s2[x]+=s2[v];
	}
}
ll gcd(ll x,ll y){return y?gcd(y,x%y):x;}
unordered_map<int,int> mp[N];
int add[M*2],del[M*2];
signed main(){
	read(n,m,K);
	fo(i,1,n)read(X[i],Y[i]);
	fo(i,1,m){
		int u,v; read(u,v);
		G[u].push_back((edge){v,i*2-1,atan2l(Y[v]-Y[u],X[v]-X[u])});
		G[v].push_back((edge){u,i*2,atan2l(Y[u]-Y[v],X[u]-X[v])});
		mp[u][v]=i*2-1,mp[v][u]=i*2;
	}
	fo(i,1,n)sort(G[i].begin(),G[i].end(),[](edge a,edge b){return a.rad>b.rad;});
	fo(i,1,n)for(auto j:G[i])if(!bz[j.num]) {
		bz[j.num]=1,side[j.num]=++tot;
		int x=j.to,from=i;
		s1[tot]+=point{X[i],Y[i]}^point{X[x],Y[x]};
		while(x!=i){
			int at=find(G[x],atan2l(Y[from]-Y[x],X[from]-X[x]));
			if(++at==G[x].size())at=0;
			bz[G[x][at].num]=1,side[G[x][at].num]=tot;
			from=x,x=G[x][at].to;
			s1[tot]+=point{X[from],Y[from]}^point{X[x],Y[x]};
		}
		if(s1[tot]<=0)root=tot;
		s2[tot]=s1[tot]*s1[tot];
	}
	fo(i,1,m){
		int u=side[i*2-1],v=side[i*2];
		g[u].push_back(v),g[v].push_back(u);
	}
	dfs(root);
	ll lastans=0;
	fo(i,1,K){
		int c; read(c);
		c=(c+lastans)%n+1;
		int d; read(d);
		d=(d+lastans)%n+1;
		int d1=d,t1=0,t2=0;
		fo(j,1,c-1){
			int t; read(t);
			t=(t+lastans)%n+1;
			int u=side[mp[d][t]],v=side[mp[t][d]];
			if(fa[u]==v)add[++t1]=u;
			else if(fa[v]==u)del[++t2]=v;
			d=t;
		}
		int u=side[mp[d][d1]],v=side[mp[d1][d]];
		if(fa[u]==v)add[++t1]=u;
		else if(fa[v]==u)del[++t2]=v;
		sort(add+1,add+t1+1),sort(del+1,del+t2+1);
		t1=unique(add+1,add+t1+1)-add-1,t2=unique(del+1,del+t2+1)-del-1;
		ll S1=0,S2=0;
		fo(i,1,t1)S1+=s1[add[i]],S2+=s2[add[i]];
		fo(i,1,t2)S1-=s1[del[i]],S2-=s2[del[i]];
		S1*=2;
		ll cd=gcd(S1,S2);
		S1/=cd,S2/=cd;
		write(S2,' ',S1,'\n');
		lastans=S2;
	}
	return 0;
}
```

---

## 作者：Mars_Dingdang (赞：1)

>给定平面上 $n$ 个点构成的一张平面图，$q$ 次询问，每次给出一个由几个面构成的边界，求这些边界中 $\sum S^2/\sum S$，其中 $S$ 为每个面的面积。

这道题相当于一个已经展开的平面图求出每个极小环。很显然，对于一般的平面图，这个问题比较困难，我们可能可以先搞出 dfs 树，然后对于每条非树边使用 bitset 存下所有环，再分别消去之类的。因此我们必须抓住本题的性质：输入的图已经展开成任意两条边不在端点处相交的平面图。

![](https://cdn.luogu.com.cn/upload/image_hosting/g9ipz9da.png)

我们把每一条无向边拆成两条有向边，这样每个有向边就属于唯一一个平面（包括无限面）。然后我们对于每一个点将以该点为起点的边按照极角排序。对于当前遍历到的边 $u\to v$（即上左图中的红色边），找到其反向边 $v\to u$ 按照极角顺序的上一条边（即上右图中的绿色边），那么绿色边也必然是这个平面所属的边。以此类推知道点 $u$ 再一次被访问到即可。

然后我们考虑建出平面图的对偶图，并任意得到以无限面为根的一棵生成树。我们维护每个子树对应的 $\sum S,\sum S^2$，然后对于每一次询问割掉的边，如果这条边是非树边那么不用管，如果割掉的边是树边；那么如果当前边对应的平面是儿子那么加上这个节点的值；如果当前边对应的平面是父亲那么减去其儿子的值。

代码实现参考了第一篇题解。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define rep(ii,aa,bb) for(re int ii = aa; ii <= bb; ii++)
#define Rep(ii,aa,bb) for(re int ii = aa; ii >= bb; ii--)
typedef long long ll;
typedef unsigned long long ull;
typedef double db;
typedef pair<int, int> PII;
const int maxn = 2e5 + 5;
const db eps = 1e-10;
template <typename T>
inline void chkmax(T &x, T y) {x = (x > y ? x : y);}
template <typename T>
inline void chkmin(T &x, T y) {x = (x < y ? x : y);}
namespace IO_ReadWrite {
	#define re register
	#define gg (p1 == p2 && (p2 = (p1 = _buf) + fread(_buf, 1, 1<<21, stdin), p1 == p2) ? EOF :*p1++)
	char _buf[1<<21], *p1 = _buf, *p2 = _buf;
	template <typename T>
	inline void read(T &x){
		x = 0; re T f=1; re char c = gg;
		while(c > 57 || c < 48){if(c == '-') f = -1;c = gg;}
		while(c >= 48 &&c <= 57){x = (x<<1) + (x<<3) + (c^48);c = gg;}
		x *= f;return;
	}
	inline void ReadChar(char &c){
		c = gg;
		while(!isalpha(c)) c = gg;
	}
	template <typename T>
	inline void write(T x){
		if(x < 0) putchar('-'), x = -x;
		if(x > 9) write(x/10);
		putchar('0' + x % 10);
	}
	template <typename T>
	inline void writeln(T x){write(x); putchar('\n');}
}
using namespace IO_ReadWrite;
int n, m, Q, tot = 1, cnt, rt;
inline ll gcd(ll a, ll b) {return !b ? a : gcd(b, a % b);}
struct Point {
	int x, y;
	Point operator -(const Point &X)const {
		Point ans;
		ans.x = x - X.x, ans.y = y - X.y;
		return ans;
	}
} p[maxn];
ll operator *(Point A, Point B) {return 1ll * A.x * B.y - 1ll * A.y * B.x;}
ll ans1, ans2;
struct edges {
	int u, v, id;
	db theta;
	bool operator <(const edges &X)const {
		return fabs(theta - X.theta) < eps ? v < X.v : theta < X.theta;
	}
} e[maxn * 6];
int nxt[maxn * 6], pos[maxn * 6];
ll sum1[maxn * 6], sum2[maxn * 6];
vector <edges> g[maxn], G[maxn * 6];
inline void add(int u, int v) {
	e[++ tot] = {u, v, tot, atan2(p[v].y - p[u].y, p[v].x - p[u].x)};
	g[u].push_back(e[tot]);
}
inline void build() {
	rep(i, 1, n) sort(g[i].begin(), g[i].end());
	rep(i, 2, tot) {
		int v = e[i].v;
		auto it = lower_bound(g[v].begin(), g[v].end(), e[i ^ 1]);
		if(it == g[v].begin()) it = g[v].end();
		it --;
		nxt[i] = it->id;
	}
	rep(i, 2, tot) {
		if(pos[i]) continue;
		pos[i] = pos[nxt[i]] = ++ cnt; // 所属的平面编号
		for(int j = nxt[i]; e[j].v != e[i].u; j = nxt[j], pos[j] = cnt) {
			sum1[cnt] += (p[e[j].u] - p[e[i].u]) * (p[e[j].v] - p[e[i].u]);
		}
		if(sum1[cnt] <= 0) rt = cnt; // 无穷平面
	}
	rep(i, 2, tot) G[pos[i]].push_back({pos[i], pos[i ^ 1], i, 0});
}
ll f[maxn * 6];
bool vis[maxn * 6], is[maxn * 6];
inline void dfs(int u, int lst) {
	f[u] = lst;
	sum2[u] = 1ll * sum1[u] * sum1[u];
	sum1[u] <<= 1;
	vis[u] = 1;
	for(auto [u, v, id, theta] : G[u]) if(!vis[v]) {
		is[id] = is[id ^ 1] = 1;
		dfs(v, u);
		sum1[u] += sum1[v];
		sum2[u] += sum2[v];
	}
}
int tmp[maxn * 10];
int main () {
	read(n); read(m); read(Q);
	rep(i, 1, n) {
		int x, y; read(x), read(y);
		p[i] = {x, y};
	}
	rep(i, 1, m) {
		int u, v; read(u), read(v);
		add(u, v), add(v, u);
	}
	build();
	dfs(rt, 0);
	while(Q --) {
		int d; read(d);
		d = (d + ans1) % n + 1;
		rep(i, 1, d) read(tmp[i]), tmp[i] = (tmp[i] + ans1) % n + 1;
		tmp[d + 1] = tmp[1];
		ans1 = ans2 = 0;
		rep(i, 1, d) {
			int u = tmp[i], v = tmp[i + 1];
			edges now = {u, v, 0, atan2(p[v].y - p[u].y, p[v].x - p[u].x)};
			auto it = lower_bound(g[u].begin(), g[u].end(), now);
			int j = it->id;
			if(!is[j]) continue;
			if(f[pos[j]] == pos[j ^ 1]) ans1 += sum2[pos[j]], ans2 += sum1[pos[j]];
			else ans1 -= sum2[pos[j ^ 1]], ans2 -= sum1[pos[j ^ 1]];
		}
		ll Gcd = gcd(ans1, ans2);
		ans1 /= Gcd, ans2 /= Gcd;
		write(ans1), putchar(' '), writeln(ans2);
	}
	
	return 0;
}
```

---

## 作者：LZDQ (赞：1)

暴力做法是这样的：

先把坐标移到第一象限。

首先定位出每个矿区。在定位完之后，选择矿区内一个点作为质量的核心。可以选择一条逆时针走的边的中点（坐标先乘 2），这样统计答案时的边界可以稍微化简一些。

具体定位多边形的方法就是给每个点相连的边都按极角排序，走到一个点就在极角序中走下一个极角。

统计答案时，对于走逆时针的边，加上扫过的质量，走逆时针的减去即可。所以现在相当于给定很多个质点，要对每条边预处理一个扫过的质量。

对极角扫描线，用平衡树维护当前极角下每条边的相对顺序，遇到质点就后缀加就行了。

一些细节：几乎所有过程都不需要实数，只有给环形极角排序时需要 atan2。判断两条边谁前谁后，只需要数谁在对方外面的点多就行了。给第一象限的点极角排序可以只用叉积比较顺序。

总复杂度单 log，询问线性。于是就有了暴力的 6K+ [做法](https://loj.ac/s/1601511)。

---


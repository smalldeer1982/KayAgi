# 曼哈顿计划E

## 题目背景

1942 年 6 月，美国开始实施利用核裂变反应来研制原子弹的计划，亦称曼哈顿计划。后来两颗原子弹在广岛和长崎爆炸，世界见证了核武器的威力，并在它的威胁下颤抖不已。2200 年，dedsec 组织利用美国军方的网络安全漏洞渗入了美国的和武器系统，并密谋使用隐藏在曼哈顿的核武器储备毁灭世界。然而 dedsec 的一名成员 Badboy17 反对这一计划，她把这一计划告知了艾登。为了拯救他的家人，避免地球变为废土，艾登不得不再次发挥他的黑客能力拯救世界。

![](https://cdn.luogu.com.cn/upload/pic/5119.png)


## 题目描述

艾登尝试黑入 dedsec 的系统并取得控制权，然而 dedsec 有所反应并予以反击。

dedsec 的网络可以看做是一个 $n$ 个点 $n-1$ 条边的连通图（一棵树），每个节点有一个稳定值。

艾登可以选择网络中上的一条链，并对那一条链上的节点进行破解（把这一条链从树上拆下来）。

假设这一条链长度为 $m$，现在你会得到 $m$ 个节点。

然后艾登要和 dedsec 开始攻防战，双方轮流行动，每次可以从任意一个稳定值大于 $0$ 的节点里依照计算规则进行一些操作，操作后，稳定值不能小于 $0$，否则计算机会爆炸，最后不能进行操作的一方算作失败

由于 dedsec 占据了防守的地理优势，dedsec 先进行操作


艾登虽然精于黑客技术，但他的手机没电了。现在他把这个消息告诉了你，希望你帮他拯救世界，所以你需要写一个程序，来帮你判断是否存在一种方式，艾登可以取胜。当然，dedsec 的防守可能完美无缺，艾登根本无法取胜，你只好跑到 shelter 里去当试验品。


## 说明/提示

|测试点|$n\le$|$k$|$w_i\le$|
|:-:|:-:|:-:|:-:|
|$1$|$50$|$1$|$10^3$|
|$2$|$3\times 10^4$|$1$|$10^3$|
|$3$|$300$|$3$|$10^6$|
|$4$|$10^3$|$4$|$10^6$|
|$5$|$3\times 10^4$|$1$|$10^9$|
|$6$|$3\times 10^4$|$2$|$10^9$|
|$7$|$3\times 10^4$|$3$|$10^9$|
|$8$|$3\times 10^4$|$3$|$10^9$|
|$9$|$3\times 10^4$|$4$|$10^9$|
|$10$|$3\times 10^4$|$4$|$10^9$|

对于 $100\%$ 的数据，$T\le 5$。

保证输入均为正整数


## 样例 #1

### 输入

```
1
3
1 2
2 3
1 2 3
1```

### 输出

```
Mutalisk ride face how to lose?```

## 样例 #2

### 输入

```
1
3
1 2
2 3
1 2 4
1```

### 输出

```
The commentary cannot go on!```

# 题解

## 作者：will7101 (赞：8)

##一句话题意：

**一颗树上每个点有权值（SG函数值），问能否选择一条链，使SG函数值异或和为零。**


##预备知识

不会SG函数的同学请移步这里 -> [ydc老师的博客](http://ydcydcy1.blog.163.com/blog/static/216089040201342412717440/)


##题解

直接放神犇同学[@loveyayoi](http://loveyayoi.net/blog/)的题解:


- 知识需求：sg函数，点分治

- 做过一些点分的题的同学应该一眼就能看出这是一道点分

- 做过一些博弈问题的同学应该一眼就能看出这是一道SG函数博弈

- 我们分别讨论n，k，w三个条件


## n
- 对于n<=1000的情况，直接暴力DFS即可

- 对于n<=30000的情况，点分治+set/hash


## k
- 通过打表可以发现一些规律

- k=1时就是普通的nim游戏，$sg(x)=x$

- k=2时通过打表可以发现明显的规律，如果s是偶数，sg函数有长度为s+1的循环节，值为0,1,0,1,0,1,0,1....,2，如果s是奇数，那么$sg(x)=x\ mod\ 2$

- k=3时，打表也可以看出规律，$sg(x)=\lfloor \frac{x}{s} \rfloor$

```cpp
- k=4时，打表得知，
$$sg(x)=
\begin{cases}
0 & \text{ , } x= 0 \\
x & \text{ , } x\equiv 1,2 (mod\ 4) \\
x+1 & \text{ , } x\equiv 3 (mod\ 4) \\
x-1 & \text{ , } x\equiv 0 (mod\ 4)
\end{cases}
```
$$

## w

- w<=1000，暴力筛出sg函数即可

- w<=1e9，找规律O(1)求sg函数

## 复杂度

$O(T N log N)$，假设hash达到期望复杂度$O(1)$


代码:

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN=30005, MAXB=1e7;
char BUF[MAXB], *cp=BUF;
void rd(int &x){
    x=0;
    while(*cp<'0'||'9'<*cp) cp++;
    while('0'<=*cp&&*cp<='9') x=x*10+*cp-'0', cp++;
}
int ne, hs, ok, nt, T, N, K, S;
int w[MAXN], sz[MAXN], vis[MAXN], tp[MAXN];
struct Edge{Edge *nxt; int to;}E[MAXN<<1], *hd[MAXN];
void adde(int u, int v){
    E[ne].to=v; E[ne].nxt=hd[u]; hd[u]=&E[ne++];
    E[ne].to=u; E[ne].nxt=hd[v]; hd[v]=&E[ne++];
}
int sg1(int x){return x;}
int sg2(int x){return (x+1)%(S+1)?x&1:2;}
int sg3(int x){return x/S;}
int sg4(int x){
    switch(x%4){
        case 0: return x-1;
        case 3: return x+1;
        default: return x;
    }
}
void init(){
    memset(hd,0,sizeof(hd)); ne=0;
    memset(vis,0,sizeof(vis));
}
int gs(int u, int p){
    sz[u]=1;
    for(Edge *e=hd[u]; e; e=e->nxt){
        int v=e->to;
        if(v!=p&&!vis[v]) sz[u]+=gs(v,u);
    }
    return sz[u];
}
int gg(int u, int p){
    for(Edge *e=hd[u]; e; e=e->nxt){
        int v=e->to;
        if(v!=p&&!vis[v]&&sz[v]>=hs) return gg(v,u);
    }
    return u;
}
int tt[MAXN];
void dfs(int u, int p, int s){
    tt[nt]=u;tp[nt++]=s;
    for(Edge *e=hd[u]; e; e=e->nxt){
        int v=e->to;
        if(v!=p&&!vis[v]) dfs(v,u,s^w[v]);
    }
}
struct Hash{
    static const int P1=100003, P2=100069;
    inline int h1(int x){return x%P1;}
    inline int h2(int x){return x%P2;}
    int t1[P1], t2[P2], st[MAXN], top;
    Hash(){
        memset(t1,-1,sizeof(t1));
        memset(t2,-1,sizeof(t2));
    }
    int find(int x){return t1[h1(x)]==x||t2[h2(x)]==x;}
    void insert(int x){ if(find(x)) return;
        int h=h2(x); st[top++]=x;
        if(t2[h]==-1) t2[h]=x;
        else while(~x){
            h=h1(x); swap(x,t1[h]);
            if(x==-1) return;
            h=h2(x); swap(x,t2[h]);
        }
    }
    void del(int x){
        if(t1[h1(x)]==x) t1[h1(x)]=-1;
        else t2[h2(x)]=-1;
    }
    void clear(){ while(top) del(st[--top]);}
}H;
void dc(int u){
    hs=gs(u,0)>>1; int g=gg(u,0); vis[g]=1; H.insert(0);
    for(Edge *e=hd[g]; e; e=e->nxt){
        int v=e->to;
        if(!vis[v]){
            nt=0; dfs(v,0,w[v]);
            for(int i=0; i<nt; ++i){
                if(H.find(w[g]^tp[i])){ok=1;break;}
            }
            for(int i=0; i<nt; ++i) H.insert(tp[i]);
        }
    }
    H.clear();
    for(Edge *e=hd[g]; e&&!ok; e=e->nxt) if(!vis[e->to]) dc(e->to);
}
int main(){
    fread(BUF, 1, MAXB, stdin);
    rd(T);
    while(T--){
        init(); rd(N);
        for(int i=1,u,v; i<N; ++i) rd(u),rd(v),adde(u,v);
        for(int i=1; i<=N; ++i) rd(w[i]);
        rd(K); int (*sg)(int);
        if(K==1) sg=sg1;
        else if(K==2) rd(S),sg=sg2;
        else if(K==3) rd(S),sg=sg3;
        else sg=sg4;
        ok=0;
        for(int i=1; i<=N; ++i) if(!(w[i]=sg(w[i]))) ok=1;
        if(!ok) dc(1);
        puts(ok?"Mutalisk ride face how to lose?":"The commentary cannot go on!");
    }
    return 0;
}
```

---

## 作者：panyf (赞：4)

异或有性质！所以不用点分治！！1

求 SG 函数的部分就是打表找规律，这里不再赘述。

注意到两个相同的数异或就会变成 $0$。

所以现在要求是否存在一条路径使 $d_u\oplus d_v\oplus w_{lca(u,v)}$ 等于 $0$。其中 $d_u$ 表示 $u$ 到根路径异或和。$lca(u,v)$ 上方的部分刚好抵消掉。

用一个 unordered_set 存储 $d_u$。

从根节点开始 dfs，访问到边 $(u,v)$ 时，先遍历 $v$ 的 unordered_set 中每个元素 $j$，判断 $u$ 的unordered_set $s_u$ 中是否存在 $j\oplus w_u$，若存在则有解。

然后将 $s_v$ 向 $s_u$ 合并，暴力插入就行。

这样复杂度是 $O(n^2)$。

用启发式合并优化，如果 $size_{s_u}<size_{s_v}$，就交换 $s_u,s_v$，这样就是 $O(n\log n)$。

复杂度和点分治一样，但代码非常短！！1

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=30009;
basic_string<int>g[N],_;
unordered_set<int>h[N];
int w[N],b;
void dfs(int x,int y,int z){
	h[x]={z^=w[x]};
	for(int i:g[x])if(i!=y){
		if(dfs(i,x,z),h[x].size()<h[i].size())swap(h[x],h[i]);//启发式合并
		for(int j:h[i])if(h[x].count(j^w[x]))b=1;
		for(int j:h[i])h[x].insert(j); 
	}
}
int main(){
	int T,n,i,j,k,l,s;
	for(scanf("%d",&T);T--;dfs(1,b=0,0),puts(b?"Mutalisk ride face how to lose?":"The commentary cannot go on!")){
		for(scanf("%d",&n),fill(g,g+n+1,_),i=1;i<n;++i)scanf("%d%d",&j,&k),g[j]+=k,g[k]+=j;
		for(i=1;i<=n;++i)scanf("%d",w+i);
		if(scanf("%d",&k),k==2||k==3)scanf("%d",&s);
		if(k>1)for(i=1;i<=n;++i)l=w[i],w[i]=k==2?(s%2?l%2:((j=l%(s+1))==s?2:j%2)):(k==3?l/s:((j=l%4)?(j==3?l+1:l):(l?l-1:0)));//求SG函数值
	}
	return 0;
}
```


---

## 作者：moongazer (赞：4)

[$\mathfrak{View\space it\space on\space my\space Blog}$](https://blog.seniorious.cc/2020/luogu-3727/)

## 分析
发现实质上是把树上一段链拉下来玩 Nim 游戏，若链上 $sg$ 函数的异或和为 $0$ 则先手必败，于是可以考虑点分治找出树上异或和为 $0$ 的链，用自己喜欢的 Hash 方式即可

## SG 函数
1. $k=1$：原始的 Nim 游戏 $sg(x)=x$
2. $k=2$：分两种情况，(1) $s$ 为奇数，显然 $s^k$ 均为奇数，故简单归纳可得 $sg(x)=x\bmod 2$；(2) $s$ 为偶数，找规律得有长为 $(s+1)$ 的循环节，大概长这样 $\overbrace{0101\cdots01}^{s}2$，有 $1=(s+1)\times0+1,s=(s+1)\times1-1,s^2=(s+1)\times(s-1)+1,s^3=(s+1)\times(s^2-s+1)-1\cdots$ 于是对循环节施加归纳，每个点可看做前后两个点的 $\operatorname{mex}$ 即可得证
3. $k=3$：$sg(x)=\lfloor\frac{x}{s}\rfloor$ 证明大概是对循环节施加归纳，每个循环节可以到达所有之前的循环节，即可得证
4. $k=4$：$sg(x)=\begin{cases}0&(x=0)\\x&(x\equiv1,2\pmod4)\\x+1&(x\equiv3\pmod4)\\x-1&(x\equiv4\pmod4)\end{cases}$ 证明大概是先 $4$ 个分一块并对块施加归纳，再对每一种单独证明  
首先对于一个完整的块 $x=4k+1\sim 4k+4$ 它的 $sg(x)$ 取遍了 $4k+1\sim4k+4$，所以直接取的 $sg$ 值可以取遍 $0\sim 4k$  
以下 $1,2,3,4$ 均为 $\bmod\ 4$ 意义下的  
考虑 $1$ 分成 $1+0$ 时异或值为 $1\oplus3=2\neq1$，$2+3$ 时异或值为 $2\oplus0=2\neq1$ 故无法将 $1$ 分解得到自身，又因为能直接取到 $0\sim4k$ 故 $sg(4k+1)=4k+1$  
$2$ 也无法分解，证明是类似的，又因为能直接取到 $0\sim4k+1$ 故 $sg(4k+2)=4k+2$  
$3$ 可以直接取到 $0\sim4k+2$，又可以分解为 $4k+2$ 和 $1$，即 $(4k+2)\oplus1=4k+3$，故 $sg(4k+3)=4k+4$  
$4$ 可以直接取到 $0\sim4k+2$ 和 $4k+4$，类似 $1,2$ 的情况 $4$ 无法分解为 $4k+3$ 故 $sg(4k+4)=4k+3$

## 代码
```cpp
constexpr int N = 30005;
constexpr int M = 60005;

void add(int u, int v);
void getsiz(int u, int fa);
void getrot(int u, int fa);
void getp(int u, int fa, int len);
void solve(int u);
void dfs(int u);

int hed[N], nxt[M], to[M], id;
int siz[N];
int asz, nsz, rot;
int dis[N], tot;
bool vis[N];
int val[N], sg[N];
bool ans;
int n;

int main() {
  int T;
  read(T);
  while (T--) {
    memset(hed, 0, sizeof(hed));
    id = 0;
    ans = false;
    memset(vis, false, sizeof(vis));
    read(n);
    for (int i = 1; i < n; ++i) {
      int u, v;
      read(u), read(v);
      add(u, v), add(v, u);
    }
    for (int i = 1; i <= n; ++i) {
      read(val[i]);
    }
    int k;
    read(k);
    if (k == 1) {
      for (int i = 1; i <= n; ++i) {
        sg[i] = val[i];
      }
    }
    if (k == 2) {
      int s;
      read(s);
      for (int i = 1; i <= n; ++i) {
        if (val[i] % (s + 1) == s) {
          sg[i] = 2;
        } else {
          sg[i] = val[i] % (s + 1) % 2;
        }
      }
    }
    if (k == 3) {
      int s;
      read(s);
      for (int i = 1; i <= n; ++i) {
        sg[i] = val[i] / s;
      }
    }
    if (k == 4) {
      for (int i = 1; i <= n; ++i) {
        if (!val[i]) {
          sg[i] = 0;
        } else {
          if (val[i] % 4 == 0) {
            sg[i] = val[i] - 1;
          } else {
            if (val[i] % 4 == 3) {
              sg[i] = val[i] + 1;
            } else {
              sg[i] = val[i];
            }
          }
        }
      }
    }
    getsiz(1, 0);
    asz = siz[1];
    nsz = iinf;
    rot = 0;
    getrot(1, 0);
    dfs(rot);
    if (ans) {
      puts("Mutalisk ride face how to lose?");
    } else {
      puts("The commentary cannot go on!");
    }
  }
  return 0;
}

void add(int u, int v) {
  nxt[++id] = hed[u];
  hed[u] = id;
  to[id] = v;
}
void getsiz(int u, int fa) {
  siz[u] = 1;
  for (int i = hed[u]; i; i = nxt[i]) {
    int v = to[i];
    if (v != fa && !vis[v]) {
      getsiz(v, u);
      siz[u] += siz[v];
    }
  }
}
void getrot(int u, int fa) {
  int maxi = 0;
  for (int i = hed[u]; i; i = nxt[i]) {
    int v = to[i];
    if (v != fa && !vis[v]) {
      getrot(v, u);
      maxi = max(maxi, siz[v]);
    }
  }
  maxi = max(maxi, asz - siz[u]);
  if (maxi < nsz) {
    nsz = maxi;
    rot = u;
  }
}
void getp(int u, int fa, int len) {
  len ^= sg[u];
  dis[++tot] = len;
  for (int i = hed[u]; i; i = nxt[i]) {
    int v = to[i];
    if (v != fa && !vis[v]) {
      getp(v, u, len);
    }
  }
}
void solve(int u) {
  if (!sg[u]) {
    ans = true;
  }
  if (ans) {
    return;
  }
  std::unordered_set<int> S;
  S.insert(sg[u]);
  for (int i = hed[u]; i; i = nxt[i]) {
    int v = to[i];
    if (!vis[v]) {
      tot = 0;
      getp(v, u, 0);
      for (int j = 1; j <= tot; ++j) {
        if (S.count(dis[j])) {
          ans = true;
          return;
        }
      }
      for (int j = 1; j <= tot; ++j) {
        S.insert(dis[j] ^ sg[u]);
      }
    }
  }
}
void dfs(int u) {
  vis[u] = true;
  solve(u);
  for (int i = hed[u]; i; i = nxt[i]) {
    int v = to[i];
    if (!vis[v]) {
      getsiz(v, u);
      asz = siz[v];
      nsz = iinf;
      rot = 0;
      getrot(v, u);
      dfs(rot);
    }
  }
}
```


---


# 【模板】可持久化平衡树

## 题目背景

本题为题目 **普通平衡树** 的可持久化加强版。

**数据已经经过强化**

**感谢@Kelin 提供的一组hack数据**


## 题目描述

您需要写一种数据结构（可参考题目标题），来维护一个可重整数集合，其中需要提供以下操作（ **对于各个以往的历史版本** ）：


1、 插入 $x$

2、 删除 $x$（若有多个相同的数，应只删除一个，**如果没有请忽略该操作**）


3、 查询 $x$ 的排名（排名定义为比当前数小的数的个数 $+1$）


4、查询排名为 $x$ 的数


5、 求 $x$ 的前驱（前驱定义为小于 $x$，且最大的数，**如不存在输出** $-2^{31}+1$ ）


6、求 $x$ 的后继（后继定义为大于 $x$，且最小的数，**如不存在输出** $2^{31}-1$ ）


**和原本平衡树不同的一点是，每一次的任何操作都是基于某一个历史版本，同时生成一个新的版本。（操作3, 4, 5, 6即保持原版本无变化）**

每个版本的编号即为操作的序号（版本0即为初始状态，空树）


## 说明/提示

【数据范围】   
对于 $28\%$ 的数据，$ 1 \leq n \leq 10 $；   
对于 $44\%$ 的数据，$ 1 \leq n \leq 2\times {10}^2 $；   
对于 $60\%$ 的数据， $ 1 \leq n \leq 3\times {10}^3 $；   
对于 $84\%$ 的数据， $ 1 \leq n \leq {10}^5 $；   
对于 $92\%$ 的数据， $ 1 \leq n \leq 2\times {10}^5 $；   
对于 $100\%$ 的数据， $ 1 \leq n \leq 5 \times  10^5 $ , $|x_i| \leq {10}^9$，$0 \le v_i < i$，$1\le \text{opt} \le 6$。

**经实测，正常常数的可持久化平衡树均可通过，请各位放心**



样例说明：

共 $10$ 次操作，$11$ 个版本，各版本的状况依次是：

0.  $[]$

1.  $[9]$

2.  $[3, 9]$

3.  $[9, 10]$

4.  $[3, 9]$

5.  $[9, 10]$

6.  $[2, 9, 10]$

7.  $[2, 9, 10]$

8.  $[2, 10]$

9.  $[2, 10]$

10.  $[3, 9]$


## 样例 #1

### 输入

```
10
0 1 9
1 1 3
1 1 10
2 4 2
3 3 9
3 1 2
6 4 1
6 2 9
8 6 3
4 5 8```

### 输出

```
9
1
2
10
3```

# 题解

## 作者：yizimi远欣 (赞：61)

就是可持久化后的普通平衡树嘛（逃

题目描述不写了（懒了

[这里是题目](https://www.luogu.org/problemnew/show/P3835)

### 主要思路：FHQ Treap + 可持久化

普通FHQ Treap加上一点可持久化的东西如下：(打上注释的代码是可持久化的特殊操作)

```cpp
inline int merge(int x, int y) {
    if(!x || !y) return x + y;
    if(z[x].pri < z[y].pri) {
        int rt = newnode(); //
        z[rt] = z[x];       //
        z[rt].ch[1] = merge(z[rt].ch[1], y);
        update(rt);
        return rt;
    } else {
        int rt = newnode(); //
        z[rt] = z[y];       //
        z[rt].ch[0] = merge(x, z[rt].ch[0]);
        update(rt);
        return rt;
    }
}
inline void split(int rt, ll k, int &x, int &y) {
    if(!rt) x = y = 0;
    else {
        if(z[rt].w <= k) {
            x = newnode(); //
            z[x] = z[rt];  //
            split(z[x].ch[1], k, z[x].ch[1], y);
            update(x);
        } else {
            y = newnode(); //
            z[y] = z[rt];  //
            split(z[y].ch[0], k, x, z[y].ch[0]);
            update(y);
        } 
    }
}
```

然后开个root[]数组，存各个版本的根节点，然后注意下空间就好了。记得开50倍，要不凉凉

### code:
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
#include<vector>
#include<set>
#include<queue>
#include<stack>
using namespace std;
#define go(i,j,n,k) for(int i=j;i<=n;i+=k)
#define fo(i,j,n,k) for(int i=j;i>=n;i-=k)
#define rep(i,x) for(int i=h[x];i;i=e[i].nxt)
#define mn 500010
#define ld long double
#define fi first
#define se second
#define inf 1<<30
#define ll long long
#define root 1,n,1
#define lson l,m,rt<<1
#define rson m+1,r,rt<<1|1
#define bson l,r,rt
inline ll read(){
    ll x=0,f=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
struct edge{
    int ch[2], sze, pri;
    ll w;
} z[mn * 50];
int rot[mn], xx, yy, zz, n, cnt;
inline void update(int rt) {
    z[rt].sze = 1;
    if(z[rt].ch[0]) z[rt].sze += z[z[rt].ch[0]].sze;
    if(z[rt].ch[1]) z[rt].sze += z[z[rt].ch[1]].sze;
} 
inline int newnode(ll w = 0) {
    z[++cnt].w = w;
    z[cnt].sze = 1;
    z[cnt].pri = rand();
    return cnt;
}
inline int merge(int x, int y) {
    if(!x || !y) return x + y;
    if(z[x].pri < z[y].pri) {
        int rt = newnode();
        z[rt] = z[x];
        z[rt].ch[1] = merge(z[rt].ch[1], y);
        update(rt);
        return rt;
    } else {
        int rt = newnode();
        z[rt] = z[y];
        z[rt].ch[0] = merge(x, z[rt].ch[0]);
        update(rt);
        return rt;
    }
}
inline void split(int rt, ll k, int &x, int &y) {
    if(!rt) x = y = 0;
    else {
        if(z[rt].w <= k) {
            x = newnode();
            z[x] = z[rt];
            split(z[x].ch[1], k, z[x].ch[1], y);
            update(x);
        } else {
            y = newnode();
            z[y] = z[rt];
            split(z[y].ch[0], k, x, z[y].ch[0]);
            update(y);
        } 
    }
}
inline int findkth(int rt, int k) {
    while(1119) {
        if(k <= z[z[rt].ch[0]].sze)
            rt = z[rt].ch[0];
        else {
            if(z[rt].ch[0]) k -= z[z[rt].ch[0]].sze;
            if(!--k) return rt;
            rt = z[rt].ch[1];
        }
    }
}
int main(){
    n = read();
    go(i, 1, n, 1) {
    	xx = yy = zz = 0;
        int tmp = read(), s = read(); ll a = read();
        rot[i] = rot[tmp];
        if(s == 1) {
            split(rot[i], a, xx, yy);
            rot[i] = merge(merge(xx, newnode(a)), yy);
        } else if(s == 2) {
            split(rot[i], a, xx, zz);
            split(xx, a - 1, xx, yy);
            yy = merge(z[yy].ch[0], z[yy].ch[1]);
            rot[i] = merge(merge(xx, yy), zz);
        } else if(s == 3) {
            split(rot[i], a - 1, xx, yy);
            printf("%lld\n", z[xx].sze + 1);
            rot[i] = merge(xx, yy);
        } else if(s == 4) {
            printf("%lld\n", z[findkth(rot[i], a)].w);
        } else if(s == 5) {
            split(rot[i], a - 1, xx, yy);
            if(xx == 0) {
            	printf("-2147483647\n");
            	continue;
            }
            printf("%lld\n", z[findkth(xx, z[xx].sze)].w);
            rot[i] = merge(xx, yy); 
        } else if(s == 6) {
            split(rot[i], a, xx, yy);
            if(yy == 0) {
            	printf("2147483647\n");
            	continue;
            }
            printf("%lld\n", z[findkth(yy, 1)].w);
            rot[i] = merge(xx, yy);
        }
    }
    return 0;
}
```

---

## 作者：小粉兔 (赞：61)

### 题意简述：

题面说的很清楚了。

### 题解：

考虑建立一棵每个节点都表示一个版本的树。

以初始版本 $0$ 为根。对于第 $i$ 个操作，从 $v_i$ 向 $i$ 连一条边，而边权则是 $opt_i$ 和 $x_i$ 的二元组，表示经过这条边上操作，可以达到下一个状态。

考虑使用权值树状数组维护操作。只需要实现单点加，查询前缀和以及树状数组上二分的操作即可。

树状数组提前插入 $-2147483647$ 和 $2147483647$ 两个数，方便统计。

因为权值范围太大，所以先离散化权值，再插入树状数组。

只需要从结点 $0$ 开始 DFS ，进入子树时执行操作，退出子树时撤销操作即可。

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

const int INF = 0x7fffffff;
const int MQ = 500010;

int N, Q;
int faz[MQ], opt[MQ], a[MQ], b[MQ];
int Ans[MQ];

int eh[MQ], nxt[MQ], to[MQ], tot;
inline void ins(int x, int y) {
	nxt[++tot] = eh[x]; to[tot] = y; eh[x] = tot;
}

int B[MQ];
inline void Add(int i, int x) { for (; i <= N; i += i & -i) B[i] += x; }
inline int Qur(int i) { int A = 0; for (; i; i -= i & -i) A += B[i]; return A; }
inline int BS(int x) { int p = 0; for (int j = 1 << 18; j; j >>= 1) if ((p | j) <= N && B[p | j] <= x) x -= B[p |= j]; return p;}

void DFS(int u, int o, int x) {
	int ok = 1;
	if (o == 1) Add(x, 1);
	if (o == 2) {
		if (Qur(x) == Qur(x - 1)) ok = 0;
		else Add(x, -1);
	}
	if (o == 3) Ans[u] = Qur(x - 1);
	if (o == 4) Ans[u] = b[BS(x) + 1];
	if (o == 5) Ans[u] = b[BS(Qur(x - 1) - 1) + 1];
	if (o == 6) Ans[u] = b[BS(Qur(x)) + 1];
	
	for (int i = eh[u]; i; i = nxt[i])
		DFS(to[i], opt[to[i]], a[to[i]]);
	
	if (o == 1) Add(x, -1);
	if (o == 2 && ok) Add(x, 1);
}

int main() {
	scanf("%d", &Q);
	for (int i = 1; i <= Q; ++i) {
		scanf("%d%d%d", &faz[i], &opt[i], &a[i]);
		if (opt[i] != 4)
			b[++N] = a[i];
	} b[++N] = -INF, b[++N] = INF;
	sort(b + 1, b + N + 1);
	N = unique(b + 1, b + N + 1) - b - 1;
	for (int i = 1; i <= Q; ++i) {
		ins(faz[i], i);
		if (opt[i] != 4)
			a[i] = lower_bound(b + 1, b + N + 1, a[i]) - b;
	}
	Add(1, 1), Add(N, 1);
	DFS(0, 0, 0);
	for (int i = 1; i <= Q; ++i) {
		if(opt[i] > 2)
			printf("%d\n", Ans[i]);
	}
	return 0;
}
```

---

## 作者：大奕哥 (赞：53)

fhq Treap可持久化，使用split（分裂），merge（合并）两个操作

对于删除操作：我们将小于等于他最大的点找出来，我们再将排除小于他的点后最小的点找出来，然后将这两个点合并在一起。

对于插入操作：我们将小于等于他的点找出来进行合并即可。

时间复杂度O（qlogq），空间复杂度（qlogq）。

推广Blog：http://www.cnblogs.com/nbwzyzngyl/p/7977369.html


```cpp
#include<bits/stdc++.h>
using namespace std;
struct node
{
    int l,r;int size,rnd,v;
}t[500005*50];
int cnt,rt[500005];
void update(int k)
{
    t[k].size=t[t[k].l].size+t[t[k].r].size+1;
}
void newnode(int &k,int x)
{
    t[k=++cnt].v=x;t[k].size=1;t[k].rnd=rand();
}
int merge(int a,int b)
{
    if(!a||!b)return a+b;
    if(t[a].rnd>t[b].rnd)
    {
        int p=++cnt;t[p]=t[a];
        t[p].r=merge(t[p].r,b);
        update(p);return p;
    }
    else
    {
        int p=++cnt;t[p]=t[b];
        t[p].l=merge(a,t[p].l);
        update(p);return p;
    }
}
void split(int now,int k,int &x,int &y)
{
    if(!now)x=y=0;
    else
    {
        if(t[now].v<=k)
        {
            x=++cnt;t[x]=t[now];
            split(t[x].r,k,t[x].r,y);
            update(x);
        }
        else 
        {
            y=++cnt;t[y]=t[now];
            split(t[y].l,k,x,t[y].l);
            update(y);
        }
    }
}
void Delete(int &root,int w)
{
    int x=0,y=0,z=0;
    split(root,w,x,z);
    split(x,w-1,x,y);
    y=merge(t[y].l,t[y].r);
    root=merge(merge(x,y),z);
}
void Insert(int &root,int w)
{
    int x=0,y=0,z=0;
    split(root,w,x,y);
    newnode(z,w);
    root=merge(merge(x,z),y);
}
int getval(int k,int w)
{
    if(w==t[t[k].l].size+1)return t[k].v;
    else if(w<=t[t[k].l].size)return getval(t[k].l,w);
    else return getval(t[k].r,w-t[t[k].l].size-1);
}
int getkth(int &root,int w)
{
    int x,y;
    split(root,w-1,x,y);
    int ans=t[x].size+1;
    root=merge(x,y);
    return ans;
}
int getpre(int &root,int w)
{
    int x,y,k,ans;
    split(root,w-1,x,y);
    if(!x)return -2147483647;
    k=t[x].size;
    ans=getval(x,k);
    root=merge(x,y);
    return ans;
}
int getnex(int &root,int w)
{
    int x,y,ans;
    split(root,w,x,y);
    if(!y)return 2147483647;
    else ans=getval(y,1);
    root=merge(x,y);
    return ans;
}
int main()
{
    int n,f,w,tim;
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
    {
        scanf("%d%d%d",&tim,&f,&w);
        rt[i]=rt[tim];
        if(f==1)Insert(rt[i],w);
        else if(f==2)Delete(rt[i],w);
        else if(f==3)printf("%d\n",getkth(rt[i],w));
        else if(f==4)printf("%d\n",getval(rt[i],w));
        else if(f==5)printf("%d\n",getpre(rt[i],w));
        else printf("%d\n",getnex(rt[i],w));
    }
    return 0;
}
```

---

## 作者：Natsuzora (赞：37)

惊了，寒假的时候我还以为这题本来就是拿
### 有旋treap
写的？

今天发现其实(题解)没人这么干过？


------------

具体来说为什么treap可以可持久化
（以下说法属于信口开河，~~不~~保证完全~~不~~正确）

，由于treap认子不认父（即不需要记录父节点），

而且所有操作都是自上而下（或者任意方向的单向？），

这种性质决定了一些节点能够方便地同时被两个版本共用

也就是决定了这种树可以方便地可持久化

有人说splay不能可持久化是因为它需要旋转、它的形态不停地在发生改变

其实决定性原因是在于它的操作既有从上往下，又有从下往上的（splay操作）
```cpp
作个比方，你现在有这样的一条路，从左往右走
（象征可持久化树上自上而下的操作）
版本①__
       ↘
      共用部分———> 你可以很方便地从两条分路合并到中间的主路上
版本②__↗

但是如果你从右往左走

①__
   ↖
    ？<————— 你就不知道应该走哪条路了
②__↙

```
其实，并不是说双向的树就不能可持久化，只是代码复杂，时间效益太低

（另外容易爆空间）

而可持久化线段树、可持久化treap一般只需要多加几行代码就够了

~~其实寒假的时候根本没考虑这么多，看见题就莽着写~~

------------

以下是我的可持久化有旋treap代码，用于可持久化的新增代码（相对于原版treap）用注释做了标记

[提交记录](https://www.luogu.org/record/15915022)
```cpp
#include <cstdio>
#include <cstdlib>
#include <iostream>
const int INF = 0x7FFFFFFF, MAXN = 5e5+1, MPR = 100;//MPR是空间多开倍数，别问我为什么用这个奇怪的缩写

int val[MAXN*MPR], left[MAXN*MPR], right[MAXN*MPR], size[MAXN*MPR], cnt[MAXN*MPR], pri[MAXN*MPR];
int id = 1;

void refresh(int &i){//复制节点，并返回新的节点，注意此处加引用'&'的意义
	if(!i) return;
	val[id] = val[i], left[id] = left[i], right[id] = right[i], pri[id] = pri[i], size[id] = size[i], cnt[id] = cnt[i];
	i = id++;
}

void pull(int i){
	size[i] = size[left[i]] + size[right[i]] + cnt[i];
} 

void r_rotate(int &i){
	refresh(left[i]);//****//
	int lnode = left[i];
	left[i] = right[lnode];
	right[lnode] = i;
	size[lnode] = size[i];
	pull(i);
	i = lnode;
}

void l_rotate(int &i){
	refresh(right[i]);//****//
	int rnode = right[i];
	right[i] = left[rnode];
	left[rnode] = i;
	size[rnode] = size[i];
	pull(i);
	i = rnode;
}

int push_root(int i){//以节点i为模板创建新的根节点
	refresh(i);
	return i;
}
void insert(int &i, int k){
	if(!i){
		i = id++;
		val[i] = k;
		size[i] = cnt[i] = 1;
		pri[i] = rand();
		return;
	}
	size[i]++;
	if(k < val[i]){
		refresh(left[i]);//****//
		insert(left[i], k);
		if(pri[left[i]] < pri[i]) r_rotate(i);
	}else if(k > val[i]){
		refresh(right[i]);//****//
		insert(right[i], k);
		if(pri[right[i]] < pri[i]) l_rotate(i);
	}else cnt[i]++;
}

bool check(int i, int k){
	if(!i) return false;
	if(k <  val[i]) return check(left[i], k);
	if(k > val[i]) return check(right[i], k);
	return true;
} 
void remove(int &i, int k){
	if(k < val[i]) refresh(left[i]), remove(left[i], k);//****//
	else if(k > val[i]) refresh(right[i]), remove(right[i], k);
	else{
		if(cnt[i] > 1) cnt[i]--, size[i]--;
		else if(left[i] && right[i]){
			if(pri[left[i]] < pri[right[i]]) r_rotate(i);
			else l_rotate(i);
			remove(i, k);
		}else i = left[i] | right[i];
		return;
	}
	size[i]--;
}

int rank(int i, int k){
	if(!i) return 0;
	if(k <= val[i]) return rank(left[i], k);
	return size[left[i]] + cnt[i] + rank(right[i], k);
}

int at(int i, int k){
	if(size[left[i]] >= k) return at(left[i], k);
	if(size[left[i]] + cnt[i] >= k) return val[i];
	return at(right[i], k - size[left[i]] - cnt[i]);
}

int prev(int i, int k){
	if(!i) return -INF;
	if(k <= val[i]) return prev(left[i], k);
	return std::max(val[i], prev(right[i], k));
}

int nxt(int i, int k){
	if(!i) return INF;
	if(k >= val[i]) return nxt(right[i], k);
	return std::min(val[i], nxt(left[i], k));
}

int i, root[MAXN];
using namespace std;

int main(){
	int n, v, opt, x;
	scanf("%d", &n);
	for(i = 1; i <= n; i++){
		scanf("%d%d%d", &v, &opt, &x);
		switch(opt){//看不懂switch语句请不要找我
			case 1:{
				root[i] = push_root(root[v]);
				insert(root[i], x);
				break;
			}
			case 2:{
				if(check(root[v], x)){
					root[i] = push_root(root[v]);
					remove(root[i], x);
				}else root[i] = root[v];
				break;
			}
			case 3:{
				root[i] = root[v];
				printf("%d\n", rank(root[i], x) + 1);
				break;
			}
			case 4:{
				root[i] = root[v];
				printf("%d\n", at(root[i], x));
				break;
			}
			case 5:{
				root[i] = root[v];
				printf("%d\n", prev(root[i], x));
				break;
			}
			case 6:{
				root[i] = root[v];
				printf("%d\n", nxt(root[i], x));
				break;
			}
		}
	}
	return 0;
}
```
(欢迎hack！)

---

## 作者：yijan (赞：34)

以rope实现的，很简单的可持久数组。  
由于只是个数组，开5e5个显然会炸空间，所以这是篇部分分的题解。

rope是什么？STL的内置的可持久化的数组。其最为方便的就是可以O1复制原来的数组。事实上rope的内置实现也是平衡树，由于只需要复制根结点，O1可以做到复制历史版本。

然而这个东西不开O2会被卡T四个点！

实现思路非常简单，对于一个新的操作，先复制其上一个操作的版本（O1！）然后进行操作。

我们保证每个版本中的数字都是有序的，然后每次插入需要二分寻找插入位置，二分寻找删除位置，二分寻找前驱后缀，对于查排名就更简单了，由于是有序的，直接 begin() + rank 就可以得到。为了实现方便，选择使用STL中的lowerbound和upperbound，很慢是肯定的。对于题目中范围不大不需要太优秀的时候可以采用这种方法，四十行不到实现可持久平衡树。

科普一下rope基本操作（百度貌似有点难找）：
```cpp
#include<ext/rope>
using namespace __gnu_cxx;//rope的命名空间
rope<type> R;
R.push_back(a) //往后插入
R.insert(pos,a)//在pos位置插入a，pos是一个迭代器。
R.erase(pos,n)//在pos位置删除n个元素。
R.replace(pos,x)//从pos开始替换成x
R.substr(pos,x)//从pos开始提取x个。
//多数时候定义rope用指针（方便可持久化） 所以上面的点多数时候要换成->
```
如何进行复制？很简单，一句话：  
```cpp
rope<type>* R[1000];
R[i] = new rope<type>(*R[v]);
```
在上部分分代码前先说一下如何对其优化空间，我们发现查询操作对原数组不改变，于是可以开个bac数组查询操作直接映射到查询前的版本（两个版本一样），就可以少开写空间。但是~~yijan太懒了~~懒得写。。于是只有一个80分代码贴在这里：
```cpp
/*Heroes Never Die!*/
#include "ext/rope"
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<iostream>
using namespace std;
using namespace __gnu_cxx;
#define MAXN 500006
rope<int> *nums[MAXN];int n;
int main(){
    cin >> n;
    nums[0] = new rope<int>();
    for(int i=1;i<=n;++i){
        static int v,opt,x;
        scanf("%d%d%d",&v,&opt,&x);
        nums[i] = new rope<int>(*nums[v]);
        if(opt == 1)
            nums[i]->insert(lower_bound(nums[i]->begin(),nums[i]->end(),x)-nums[i]->begin(),x);
        if(opt == 2){
            auto it = lower_bound(nums[i]->begin(),nums[i]->end(),x);
            if(*it == x) nums[i]->erase(it-nums[i]->begin(),1);
        }
        if(opt == 3)
            printf("%d\n",(int)(lower_bound(nums[i]->begin(),nums[i]->end(),x)-nums[i]->begin()) + 1);
        if(opt == 4)
            printf("%d\n",*(nums[i]->begin() + x - 1));
        if(opt == 5){
            auto it = lower_bound(nums[i]->begin(),nums[i]->end(),x);
            if(it == nums[i]->begin() - 1) puts("-2147483647");
            else --it,printf("%d\n",*it);
        }
        if(opt == 6){
            auto it = upper_bound(nums[i]->begin(),nums[i]->end(),x);
            if(it == nums[i]->end()) puts("2147483647");
            else printf("%d\n",*it);
        }
    }
}
```

---

## 作者：GGN_2015 (赞：26)

”一道可持久化数据结构的题，如果不强制在线，那么它八成不是一道真正的可持久化数据结构的题。“ —— GGN_2015

惊奇地发现这道题其实并不需要任何可持久化数据结构。

我们只需要建立一颗”时光树“（我们暂且这样称呼它）。如果i时刻的平衡树是由$v_i$时刻发展而来的，那么我们就令”时光树“上i号结点的父亲为$v_i$。0号结点显然是整棵”时光树“的根结点。

维护一棵平衡树（我写的是treap），最开始的时候这是一棵空树。在”时光树“上DFS，每进入结点i时就在平衡树中进行操作i（修改数据结构或储存查询的结果），然后再依次DFS结点i的每个儿子。退出结点i时，就”撤销“这个结点对数据结构的修改。例如当$opt_i = 1$时，我们向数据结构中插入了元素$x_i$，离开结点i时，我们再把$x_i$从数据结构中删除。

比较特殊的是：当$opt_i = 2$时，删除是可能失败的。如果删除失败的话，我们在回溯的时候要特判（就是说不要把本就没被成功删除的$x_i$插入回数据结构中）。

附上代码之前先作出一个声明：我的treap的代码不支持可重集合，所以我用了一个类似pair的数据结构来储存元素（第一维存储元素的值，第二维记录操作的编号），这样可以保证treap中没有重复的元素。另外，我懒得写前去和后继的查询，所以我的”前驱“和”后继“查询是利用”排名“和”第k大“查询间接实现的。（我觉得这样写treap更好调试一些）

```cpp
#include <cstdio>
#include <cstdlib>
#include <queue>
#include <vector>
#include <algorithm>
using namespace std;

struct item {int val, id;};
bool operator < (item A, item B) {
	if(A.val != B.val) return A.val < B.val;
	return A.id < B.id;
}
bool operator == (item A, item B) {
	return A.val==B.val && A.id==B.id;
}

const int maxn = (500000 + 6)*2;
namespace treap {
	int ch[maxn][2], rnd[maxn], siz[maxn]; item key[maxn]; int ncnt;
	queue<int> Q;
	void maintain(int x) {
		siz[x] = 1 + siz[ch[x][0]] + siz[ch[x][1]];
	}
	int newnode() {
		if(!Q.empty()) {
			int x = Q.front(); Q.pop();
			ch[x][0] = ch[x][1] = rnd[x] = siz[x] = 0; key[x] = (item){0, 0};
			return x;
		}
		return ++ ncnt;
	}
	void rotate(int& x, int d) {
		int k = ch[x][d^1]; ch[x][d^1] = ch[k][d]; ch[k][d] = x;
		maintain(x); x = k; maintain(k);
	}
	void insert(int& x, item v) {
		if(x == 0) {
			x = newnode(); rnd[x] = rand(); siz[x] = 1; key[x] = v;
			return;
		}
		int d = v < key[x] ? 0 : 1; insert(ch[x][d], v);
		maintain(x);
		if(rnd[x] > rnd[ch[x][d]]) rotate(x, d^1);
	}
	int rnk(int x, item v) {
		if(x == 0) return 1;
		int lsiz = 1 + siz[ch[x][0]];
		if(v == key[x]) return lsiz;
		if(v < key[x]) return rnk(ch[x][0], v);
		else           return rnk(ch[x][1], v) + lsiz;
	}
	item kth(int x, int k) {
		if(x==0 || k<=0 || k>siz[x])
			return k<=0 ? (item){-2147483647, 0} : (item){2147483647, 0};
		int lsiz = 1 + siz[ch[x][0]];
		if(lsiz == k) return key[x];
		if(k < lsiz) return kth(ch[x][0], k);
		else         return kth(ch[x][1], k-lsiz);
	}
	int LSIZ(int x) {return 1 + siz[ch[x][0]];}
	void erase(int& x, int k) {
		if(x == 0) return; /// 删除元素时一定要特判检测是否相等
		int lsiz = 1 + siz[ch[x][0]];
		if(lsiz == k) {
			if(ch[x][0]==0 || ch[x][1]==0) {
				int tmp = x; x = ch[x][0] + ch[x][1]; Q.push(tmp);
				ch[tmp][0] = ch[tmp][1] = siz[tmp] = rnd[tmp] = 0;
				key[tmp] = (item){0, 0};
			}else {
				if(rnd[ch[x][0]] > rnd[ch[x][1]]) {
					rotate(x, 0); erase(ch[x][0], LSIZ(ch[x][0]));
				}else {
					rotate(x, 1); erase(ch[x][1], LSIZ(ch[x][1]));
				}
				maintain(x);
			}
			return;
		}else {
			if(k < lsiz) erase(ch[x][0], k);
			else         erase(ch[x][1], k-lsiz);
			maintain(x);
		}
	}
}

int root = 0, V[maxn], OPT[maxn], X[maxn], ANS[maxn];
namespace tree {
	vector<int> nxt[maxn];
	void addedge(int f, int t) {nxt[f].push_back(t);}
	void dfs(int x) {
		bool delsuc = 0; /// 记录删除操作是否成功
		if(OPT[x]) { /// 有操作
			if(OPT[x] == 1) { /// 插入一个元素
				treap::insert(root, (item){X[x], x});
			}else if(OPT[x] == 2) { /// 删除一个元素
				int rnk = treap::rnk(root, (item){X[x], 0}); /// 查询这个元素的排名
				int get = treap::kth(root, rnk).val; /// 得到这个元素(可能为+-inf)
				if(get == X[x]) { /// 可以删除
					treap::erase(root, rnk); delsuc = 1;
				}
			}else if(OPT[x] == 3) { /// 查排名
				ANS[x] = treap::rnk(root, (item){X[x], 0});
			}else if(OPT[x] == 4) { /// 查第k大
				ANS[x] = treap::kth(root, X[x]).val;
			}else if(OPT[x] == 5) { /// prev
				int rnk = treap::rnk(root, (item){X[x], 0}) - 1;
				int get = treap::kth(root, rnk).val;
				ANS[x] = get;
			}else if(OPT[x] == 6) { /// next
				int rnk = treap::rnk(root, (item){X[x], 0x7f7f7f7f});
				int get = treap::kth(root, rnk).val;
				ANS[x] = get;
			}
		}
		for(int i = 0; i < (int)nxt[x].size(); i ++) {
			int t = nxt[x][i]; dfs(t); /// 递归计算
		}
		if(OPT[x] == 1) { /// 回滚插入操作
			int rnk = treap::rnk(root, (item){X[x], 0}); /// 一定有
			treap::erase(root, rnk);
		}
		if(OPT[x]==2 && delsuc) {
			treap::insert(root, (item){X[x], x});
		}
	}
}

int main() {
	//freopen("nontime.in", "r", stdin);
	int n; scanf("%d", &n);
	for(int i = 1; i <= n; i ++) {
		scanf("%d%d%d", &V[i], &OPT[i], &X[i]);
		tree::addedge(V[i], i);
	}
	tree::dfs(0);
	for(int i = 1; i <= n; i ++) {
		if(OPT[i]>=3) {
			printf("%d\n", ANS[i]);
		}
	}
	return 0;
}
```

---

## 作者：Ireliaღ (赞：17)

## 不加平衡措施的BST

本来写的替罪羊，过了样例，交上去WA了。我想看看是不是替罪羊重构出了问题，于是把重构删掉了，感觉会T，结果A了。。。

跑的挺快的，用`new`开内存还只跑了5557ms

具体如何可持久化，就是在递归对一个节点进行修改时，先复制当前节点。这样的话，每次进行操作前，直接将当前根先指向历史根，然后跑函数，就不用每次把历史版本传参传下来了。

代码如下

```cpp
// luogu-judger-enable-o2
// luogu-judger-enable-o2
#include <iostream>
#include <stack>
#include <vector>

using namespace std;

const int MAXN = 5e5 + 5;
//const float Alpha = 0.7;
const int INF = 0x7fffffff;

int n;

struct Node{
    int val, cnt, siz, cov;
    Node* ch[2];
    
    Node() {}
    
    Node(int val) : val(val) {
        siz = cov = cnt = 1;
        ch[0] = ch[1] = NULL;
    }
};

Node *rt[MAXN];
//vector<Node*> vec;
stack<Node*> stk;

Node *newNode(int val = 0) {
    if (stk.empty()) return new Node(val);
    Node *p = stk.top(); stk.pop();
    *p = Node(val);
    return p;
}

Node *Copy(Node *now) {
    Node *p = newNode();
    *p = *now;
    return p;
}
/*
bool Bad(Node *now) {
    int ls = now->ch[0] ? now->ch[0]->cov : 0;
    int rs = now->ch[1] ? now->ch[1]->cov : 0;
    return (float)ls > (float)now->cov * Alpha || (float)rs > (float)now->cov * Alpha;
}
*/
void Update(Node *now) {
    now->siz = now->cnt + (now->ch[0] ? now->ch[0]->siz : 0) + (now->ch[1] ? now->ch[1]->siz : 0);
    now->cov = 1 + (now->ch[0] ? now->ch[0]->cov : 0) + (now->ch[1] ? now->ch[1]->cov : 0);
}
/*
void Dfs(Node *now) {
    if (!now) return;
    now = Copy(now);
    Dfs(now->ch[0]);
    if (now->cnt) vec.push_back(now);
    else stk.push(now);
    Dfs(now->ch[1]);
    now->ch[0] = now->ch[1] = NULL;
    Update(now);
}

void Rebuild(Node *&now, int l, int r) {
    if (l > r) return;
    int mid = l + r >> 1;
    now = vec[mid];
    Rebuild(now->ch[0], l, mid - 1);
    Rebuild(now->ch[1], mid + 1, r);
}
*/
void Insert(Node *&now, int k) {
    if (!now) {
        now = newNode(k);
        return;
    } 
    now = Copy(now);
    if (k < now->val) Insert(now->ch[0], k);
    else if (k == now->val) now->cnt++;
    else Insert(now->ch[1], k);
    Update(now);
    /*if (Bad(now)) {
        vec.clear();
        Dfs(now);
        int len = vec.size();
        Rebuild(now, 0, len - 1);
    }*/
}

void Remove(Node *&now, int k) {
    if (!now) return;
    now = Copy(now);
    if (k < now->val) {
        Remove(now->ch[0], k);
    } else if (k == now->val) {
        if (now->cnt > 0) now->cnt--;
    } else {
        Remove(now->ch[1], k);
    }
    Update(now);
}

int Rank(Node *now, int k) {
    if (!now) return 1;
    int ls = now->ch[0] ? now->ch[0]->siz : 0;
    if (k < now->val) return Rank(now->ch[0], k);
    else if (k == now->val) return ls + 1;
    else return Rank(now->ch[1], k) + ls + now->cnt; 
}

int Kth(Node *now, int k) {
    if (!now) return 0;
    int ls = now->ch[0] ? now->ch[0]->siz : 0;
    if (k <= ls) return Kth(now->ch[0], k);
    else if (k <= ls + now->cnt) return now->val;
    else return Kth(now->ch[1], k - ls - now->cnt);
}

int GetPre(Node *now, int k) {
    if (!now) return -INF;
    if (now->val >= k) return GetPre(now->ch[0], k);
    int ret = GetPre(now->ch[1], k);
    return ret == -INF ? (now->cnt ? now->val : GetPre(now->ch[0], k)) : ret;
}

int GetSuc(Node *now, int k) {
    if (!now) return INF;
    if (now->val <= k) return GetSuc(now->ch[1], k);
    int ret = GetSuc(now->ch[0], k);
    return ret == INF ? (now->cnt ? now->val : GetSuc(now->ch[1], k)) : ret;
}

int main() {
    cin >> n;
    int op, ver, k, res;
    for (int i = 1; i <= n; i++) {
        cin >> ver >> op >> k;
        rt[i] = rt[ver];
        if (op == 1) {
            Insert(rt[i], k);
        } else if (op == 2) {
            Remove(rt[i], k);
        } else if (op == 3) {
            res = Rank(rt[i], k);
            cout << res << endl;
        } else if (op == 4) {
            res = Kth(rt[i], k);
            cout << res << endl;
        } else if (op == 5) {
            res = GetPre(rt[i], k);
            cout << res << endl;
        } else {
            res = GetSuc(rt[i], k);
            cout << res << endl;
        }
    }
    return 0;
}
```

~~希望本题可以出毒瘤数据卡掉本篇题解~~

---

## 作者：苏联元帅 (赞：15)

可持久化01trie树
将数字表示成二进制,即可用01trie树来保存维护数字的集合.
trie树每个节点存0,1儿子以及集合大小.

本题中数字可能是负数,为了处理方便,存储时都加一个大常数将数字统一为正的,取出数字时再减掉即可.

本题所用trie树的深度为32,两次版本变化的只有一条长度为32的链,故可以仿照主席树重用之前节点的思路,将指针指回之前的节点,只新建本次用到的节点,使空间复杂度保持在O(qw),w为位长,所有操作时间复杂度均为O(w).
```cpp
// luogu-judger-enable-o2
#include <stdio.h>
#include <iostream>
using namespace std;
const int maxt=6e5*32;
const int maxn=6e5;
int ch[maxt][2]={0},size[maxt]={0};
int mem=0,root[maxn];
void insert(int& x,int y,int v)
{
    x=++mem;
    v+=1e9;
    size[x]=size[y]+1;
    int p=x,q=y;
    for(int i=31;i>=0;i--)
    {
        if(v&(1<<i))
        {
            ch[p][1]=++mem;
            ch[p][0]=ch[q][0];
            
            p=ch[p][1];
            q=ch[q][1];
        }
        else
        {
            ch[p][0]=++mem;
            ch[p][1]=ch[q][1];

            p=ch[p][0];
            q=ch[q][0];
        }
        size[p]=size[q]+1;
    }
}
void erase(int& x,int y,int v)
{
    int q=y;
    v+=1e9;
    
    for(int i=31;i>=0;i--)
    {
        if(v&(1<<i))
            q=ch[q][1];
        else
            q=ch[q][0];
        if(!q||!size[q])
        {
            x=y;
            return;
        }
    }
    x=++mem;
    size[x]=size[y]-1;
    int p=x;
    q=y;
    for(int i=31;i>=0;i--)
    {
        if(v&(1<<i))
        {
            ch[p][1]=++mem;
            ch[p][0]=ch[q][0];
            
            p=ch[p][1];
            q=ch[q][1];
        }
        else
        {
            ch[p][0]=++mem;
            ch[p][1]=ch[q][1];

            p=ch[p][0];
            q=ch[q][0];
        }
        size[p]=size[q]-1;
    }
}
int getsmaller(int x,int v)
{
    v+=1e9;
    int p=x;
    int ret=0;
    for(int i=31;i>=0;i--)
    {
        if(v&(1<<i))
        {
            ret+=size[ch[p][0]];
            p=ch[p][1];
        }
        else
            p=ch[p][0];
        if(!p||!size[p])
            return ret;
    }
    return ret;
}
int getbigger(int x,int v)
{
    v+=1e9;
    int p=x;
    int ret=0;
    for(int i=31;i>=0;i--)
    {
        if(v&(1<<i))
            p=ch[p][1];
        else
        {
            ret+=size[ch[p][1]];
            p=ch[p][0];
        }
        if(!p||!size[p])
            return ret;
    }
    return ret;
}
int getvalue(int x,int rank)
{
    int p=x;
    int ret=-1e9;
    for(int i=31;i>=0;i--)
    {
        if(rank>size[ch[p][0]])
        {
            rank-=size[ch[p][0]];
            p=ch[p][1];
            ret+=(1<<i);
        }
        else
            p=ch[p][0];
    }
    return ret;
}
int n,his=0;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        int v,opt,x;
        scanf("%d%d%d",&v,&opt,&x);
        if(opt==1)
            insert(root[i],root[v],x);
        else if(opt==2)
            erase(root[i],root[v],x);
        else if(opt==3)
        {
            root[i]=root[v];
            cout<<getsmaller(root[v],x)+1<<endl;
        }
        else if(opt==4)
        {
            root[i]=root[v];
            cout<<getvalue(root[v],x)<<endl;
        }
        else if(opt==5)
        {
            root[i]=root[v];
            int sm=getsmaller(root[v],x);
            if(!sm)
                cout<<-2147483647<<endl;
            else
                cout<<getvalue(root[v],sm)<<endl;
        }
        else
        {
            root[i]=root[v];
            int gm=getbigger(root[v],x);
            if(!gm)
                cout<<2147483647<<endl;
            else
                cout<<getvalue(root[v],size[root[v]]-gm+1)<<endl;
        }
    }
    return 0;
}
```

---

## 作者：BFqwq (赞：12)

看了一篇题解区，这题的比较主流的几种解法分别是 $FHQ-Treap$，线段树，$01-Trie$ 和替罪羊树。

为什么 $WBLT$ 这么好写却一篇题解都没有qaq

---

考虑 $WBLT$ 的性质，在修改的时候操要是不 $maintain$，全树的形态除了叶结点是不会有变化的。

同样，在删除的时候，只要不 $maintain$，全树的形态也不会有变化。

因此考虑将 $maintain$ 操作叠加起来，放在修改完成后再一遍进行。

只要碰到 $maintain$ 操作，我们就新建一个节点，然后在操作时递归向下。

```cpp
int maintain(int o){
	int nw=nnd(t[o].v,t[o].w,t[o].ls,t[o].rs);
    if(t[t[nw].ls].w>t[t[nw].rs].w*ratio){
		t[nw].ls=maintain(t[nw].ls);
		t[nw].rs=maintain(t[nw].rs);
		t[nw].rs=merge(t[t[nw].ls].rs,t[nw].rs);
		t[nw].ls=t[t[nw].ls].ls;
	}
	if(t[t[nw].rs].w>t[t[nw].ls].w*ratio){
		t[nw].ls=maintain(t[nw].ls);
		t[nw].rs=maintain(t[nw].rs);
		t[nw].ls=merge(t[nw].ls,t[t[nw].rs].ls);
		t[nw].rs=t[t[nw].rs].rs;
	}
	return nw;
}
```
由于在实际操作的时候一共只加了一个节点，并不会对很多节点的子树大小关系产生影响。

可以证明，每次修改最多只需对 $\log$ 个节点（即链上的节点）进行 $maintain$ 操作。

顾在修改时时间复杂度为 $\log n$，最坏空间复杂度也是 $\log n$。

```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read(){
	register int x=0;
	register bool f=0;
	register char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f=1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<3)+(x<<1)+c-48;
		c=getchar();
	}
	return f?-x:x;
}
char cr[200];int tt;
inline void print(int x,char k='\n') {
    if(!x) putchar('0');
    if(x < 0) putchar('-'),x=-x;
    while(x) cr[++tt]=x%10+'0',x/=10;
    while(tt) putchar(cr[tt--]);
    putchar(k);
}
const int maxn=500010;
const int ratio=4; 
struct lef{
	int v,w,ls,rs;
}t[maxn*200];
int rt[maxn],tot;
int nnd(int v,int w,int ls,int rs){
    t[++tot]=(lef){v,w,ls,rs};
    return tot;
}
int merge(int x,int y){
	return nnd(t[y].v,t[x].w+t[y].w,x,y);
}
void pushup(int o){
    if(!t[t[o].ls].w){
		return;
	}
    t[o].w=t[t[o].ls].w+t[t[o].rs].w;
	t[o].v=t[t[o].rs].v;
}
int maintain(int o){
	int nw=nnd(t[o].v,t[o].w,t[o].ls,t[o].rs);
    if(t[t[nw].ls].w>t[t[nw].rs].w*ratio){
		t[nw].ls=maintain(t[nw].ls);
		t[nw].rs=maintain(t[nw].rs);
		t[nw].rs=merge(t[t[nw].ls].rs,t[nw].rs);
		t[nw].ls=t[t[nw].ls].ls;
	}
	if(t[t[nw].rs].w>t[t[nw].ls].w*ratio){
		t[nw].ls=maintain(t[nw].ls);
		t[nw].rs=maintain(t[nw].rs);
		t[nw].ls=merge(t[nw].ls,t[t[nw].rs].ls);
		t[nw].rs=t[t[nw].rs].rs;
	}
	return nw;
}
int find(int o,int k) {
    if(t[o].w==1) return 1;
    if(k<=t[t[o].ls].v)return find(t[o].ls,k);
    else return t[t[o].ls].w+find(t[o].rs,k);
}
int select(int o,int k) {
    if(t[o].w==1) return t[o].v;
    if(k<=t[t[o].ls].w)return select(t[o].ls,k);
    else return select(t[o].rs,k-t[t[o].ls].w);
}
int insert(int o,int x){
	int nw=nnd(t[o].v,t[o].w,t[o].ls,t[o].rs);
    if(t[nw].w==1){
		t[nw].ls=nnd(min(t[nw].v,x),1,0,0);
		t[nw].rs=nnd(max(t[nw].v,x),1,0,0);
	}
    else if(x>t[t[nw].ls].v)
		t[nw].rs=insert(t[nw].rs,x);
	else 
		t[nw].ls=insert(t[nw].ls,x);
    pushup(nw);
    return nw;
}
int erase(int o,int x){
    int nw=nnd(t[o].v,t[o].w,t[o].ls,t[o].rs);
    if(t[nw].w==1&&t[nw].v!=x)
		return nw;
    else if(t[t[nw].ls].w==1&&t[t[nw].ls].v==x)
		nw=t[nw].rs;
    else if(t[t[nw].rs].w==1&&t[t[nw].rs].v==x)
		nw=t[nw].ls;
    else if(x>t[t[nw].ls].v)
		t[nw].rs=erase(t[nw].rs,x);
    else 
		t[nw].ls=erase(t[nw].ls,x);
    pushup(nw);
    return nw;
}
signed main(){
    int n=read();
    rt[0]=nnd(2147483647,1,0,0);
    for(int i=1;i<=n;i++){
        int wh=read(),opt=read(),x=read();
        if(opt==1){
        	rt[i]=maintain(insert(rt[wh],x));
		}
		if(opt==2){
			rt[i]=maintain(erase(rt[wh],x));
		}
		if(opt==3){
            print(find(rt[wh],x));
            rt[i]=rt[wh];
        }
        if(opt==4){
            print(select(rt[wh],x));
            rt[i]=rt[wh];
        }
        if(opt==5){
            int rk=find(rt[wh],x);
            if(rk==1)print(-2147483647);
            else print(select(rt[wh],rk-1));
            rt[i]=rt[wh];
        }
        if(opt==6){
        	int rk=find(rt[wh],x+1);
            print(select(rt[wh],rk));
            rt[i]=rt[wh];
        }
    }
    return 0;
}
```

























---

## 作者：ywy_c_asm (赞：9)

在学替罪羊树的时候发现网上大部分博客都有这么一句话:

“缺点：可持久化困难。”

~~感觉可持久化替罪羊挺好写的啊……反正我不会$fhq\space Treap$……~~

我们知道可持久化数据结构的套路就是修改的时候边走边新建节点挂成链，比如主席树、可持久化$Trie$，我们一般是这样进行的，修改的时候递归操作，对当前节点复制一份，把不用访问的儿子指向原来节点的儿子（这样就节约了空间），然后要访问的那个儿子就递归下去。

我们发现这个用在线段树上面非常合适，因为他的祖先与后代的关系是恒定不变的，而平衡树就不太一样了。一般的平衡树都过于灵活，变化比较复杂，这主要是因为大部分平衡树都得旋转~~然后就父子关系乱伦~~，我们的可持久化的核心在于几个父亲共用一个儿子，所以$Splay$什么的不可持久化……

然后不旋转的平衡树在$OI$中主要有两种：$fhq\space Treap$~~（然而我并不会）~~和替罪羊树。我们考虑把替罪羊树按照上面那种方式可持久化。

但是我们发现了一个严重的问题，这个替罪羊树虽然并不用旋转，但他的核心在于暴力拍扁重构，这样做可能会给父亲换掉一个儿子，然后这种多父一子的持久化关系就乱了。

其实我们发现重构也是暴力重构的，我们知道替罪羊树的一系列操作在时间上是均摊$O(nlogn)$的，我们原来进行可持久化的思路是在一条链的修改操作（单纯的插入删除）上进行节点复制挂成新的一条链，这样因为替罪羊树的树高本来就因为暴力重构比较平衡可以看做是$O(logn)$级别的，每次插入一条长度为树高级别的链，所以新建的节点个数是$O(nlogn)$级别的。然后我们现在在暴力重构的时候也进行节点的复制，让重构不影响原来的版本，仅影响当前的版本，然后就相当于所有修改操作都要复制一次节点，所以空间复杂度与其时间复杂度相当仍然是$O(nlogn)$的，并不会爆炸。

这么着看上去非常暴力，不过我写的可持久化替罪羊树在时间和空间上实测比很多人的$fhq\space Treap$的常数要小……替罪羊树真是个好东西……

上代码~

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define alpha (double)0.7//alpha设为0.7比较好
#define inf 2147483647
using namespace std;
namespace ywy
{
	inline int get()
	{
		int n=0;
		char c;
		while((c=getchar())||23333)
		{
			if(c>='0'&&c<='9')break;
			if(c=='-')goto s;
		}
		n=c-'0';
		while((c=getchar())||23333)
		{
			if(c>='0'&&c<='9')n=n*10+c-'0';
			else return(n);
		}
s:
		while((c=getchar())||23333)
		{
			if(c>='0'&&c<='9')n=n*10-c+'0';
			else return(n);
		}
	}
	void print(int num)
	{
		if(num<0)putchar('-'),num=-num;
		if(num>=10)print(num/10);
		putchar(num%10+'0');
	} int data[30000001],ch[30000001][2],cnt[30000001],size[30000001],gn=1;
	inline void up(int tree)
	{
		size[tree]=size[ch[tree][0]]+size[ch[tree][1]]+cnt[tree];
	} int nd[500001],ptr=1;
	void dfs(int tree)//在重构前先把子树的点找出来
	{
		if(!tree)return;
		dfs(ch[tree][0]);
		if(cnt[tree])nd[ptr]=tree,ptr++;
		dfs(ch[tree][1]);
	}
	int digui(int l,int r)//暴力重构成高度严格logn的子树，注意仍然要进行节点复制
	{
		if(l>r)return(0);
		int mid=(l+r)>>1;
		int tree=nd[mid];
		int me=gn;
		gn++;
		data[me]=data[tree];
		cnt[me]=cnt[tree];
		ch[me][0]=digui(l,mid-1);
		ch[me][1]=digui(mid+1,r);
		up(me);
		return(me);
	} int root[500001];
	int insert(int old,int num)//插入
	{
		int tree=gn;
		gn++;
		data[tree]=data[old];
		cnt[tree]=cnt[old];
		size[tree]=size[old]+1;//节点复制
		if(!old||data[old]==num)
		{
			data[tree]=num;
			ch[tree][0]=ch[old][0];
			ch[tree][1]=ch[old][1];//注意不需要递归的时候记得把两个儿子都指一下
			cnt[tree]++;
			return(tree);
		}
		int op=num>data[tree];
		ch[tree][op^1]=ch[old][op^1];
		ch[tree][op]=insert(ch[old][op],num);
		if((double)max(size[ch[tree][0]],size[ch[tree][1]])>(double)size[tree]*alpha)
		{
			ptr=1;
			dfs(tree);
			return(digui(1,ptr-1));
		}
		return(tree);
	}
	int del(int old,int num)//删除，也要进行节点复制
	{
		int tree=gn;
		gn++;
		data[tree]=data[old];
		size[tree]=size[old]-1;
		cnt[tree]=cnt[old];
		if(num==data[tree])
		{
			cnt[tree]--;
			ch[tree][0]=ch[old][0];
			ch[tree][1]=ch[old][1];
			return(tree);
		}
		int op=num>data[tree];
		ch[tree][op^1]=ch[old][op^1];
		ch[tree][op]=del(ch[old][op],num);
		return(tree)；
	}
	int rankof(int tree,int rk)//剩下的跟普通平衡树就一样了~
	{
		if(rk<=size[ch[tree][0]])return(rankof(ch[tree][0],rk));
		rk-=size[ch[tree][0]];
		if(rk<=cnt[tree])return(data[tree]);
		rk-=cnt[tree];
		return(rankof(ch[tree][1],rk));
	}
	inline int getrank(int num,int tree)
	{
		int ans=1,cur=tree;
		while(cur&&data[cur]!=num)
		{
			if(num>data[cur])ans+=cnt[cur]+size[ch[cur][0]],cur=ch[cur][1];
			else cur=ch[cur][0];
		}
		ans+=size[ch[cur][0]];
		return(ans);
	} inline int find(int tree,int num)
	{
		int cur=tree;
		while(cur&&data[cur]!=num)cur=ch[cur][num>data[cur]];
		if(!cnt[cur])return(inf);
		return(cur);
	}
	void ywymain()
	{
		int n=get();
		for(register int i=1; i<=n; i++)
		{
			int ver=get(),cmd=get(),x=get();
			if(cmd==1)
			{
				root[i]=insert(root[ver],x);
			}
			if(cmd==2)
			{
				if(find(root[ver],x)==inf)root[i]=root[ver];
				else root[i]=del(root[ver],x);
			}
			if(cmd==3)
			{
				root[i]=root[ver];
				print(getrank(x,root[i]));
				putchar('\n');
			}
			if(cmd==4)
			{
				root[i]=root[ver];
				print(rankof(root[i],x));
				putchar('\n');
			}
			if(cmd==5)
			{
				root[i]=root[ver];
				int cjr=getrank(x,root[i]);
				if(cjr==1)print(-inf);
				else print(rankof(root[i],cjr-1));
				putchar('\n');
			}
			if(cmd==6)
			{
				root[i]=root[ver];
				int me=find(root[i],x),rk;
				if(me==inf)rk=getrank(x,root[i]);
				else rk=getrank(x,root[i])+cnt[me];
				if(rk>size[root[i]])print(inf);
				else print(rankof(root[i],rk));
				putchar('\n');
			}
		}
	}
}
int main()
{
	ywy::ywymain();
	return(0);
}
```

---

## 作者：hehe_54321 (赞：9)

这个题也是可以用可持久化线段树来解决的。

值域线段树（也有的叫权值线段树）可以用来维护一个可重集，并实现一些一般情况下平衡树才能实现的事情。

如果用值来当做区间左右端点，每个叶子节点上存某个值出现的次数，非叶子节点上存一定范围内的值出现的总次数，就可以建成值域线段树。可以在上面直接查询第k大值、小于某值的数的个数等等，具体请百度或参见代码。

如何将线段树可持久化呢？线段树在单点更新的时候会经过log n个节点，每一次更新时显然也只有这么多节点会发生变化。

记录每一个版本的线段树的根节点，每一次操作前将根节点赋为与这次操作基于的版本的根节点相同。在更新操作时，备份每一个经过的节点（包括各个属性：左、右子树以及区间和），然后再进行修改。具体也可以参考[可持久化线段树](https://www.luogu.org/problemnew/show/P3919)的题解。

如果直接用可持久化的值域线段树，显然空间是不够的（4\*2e9个节点啊...）。现在有两种选择：

1.发现这道题没有加、减操作，所有操作涉及的值都是确定的。因此可以进行离散化，然后再做，想必可以A掉吧~~（我没试过）~~

2.可以写动态开点线段树。题目要求的集合一开始是空的，因此如果一开始建一棵完整的线段树的话，每一个节点记录的区间和都是0。而总共只有5e5次操作，每一次操作涉及更改节点最多有log2(2e9)=31个，两者乘起来远远小于4\*2e9。

可以考虑一开始不真正建树。规定：如果某节点的某个子节点是一个特殊的标记的话，表明以这个子节点为根的子树还没有实际建出来。显然，一个子树没有实际建出来的时候，其表示的区间的和为0。（以下代码中我用的标记是0）

在进行修改操作的时候，可能需要建出来要走入的那个子节点。在进行查询操作的时候，可以把未建出的子节点的区间和当做0。

附：写完后我发现前驱和后继竟然是最难写的...

附：注意各种对不存在的节点的查询/要忽略的操作

附：注意代码中有一些操作用到的变量被设置成了全局变量，还define了一个mid，表示区间中点，可能比较奇怪...

[博客](http://www.cnblogs.com/hehe54321/p/8530074.html)

```
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<bits/stdc++.h>
#define mid ((l+r)>>1)
#define inf 2147483647
using namespace std;
int lc[20000000],rc[20000000],root[20000000],dat[20000000],ll=-1e9,rr=1e9;
//lc[i]、rc[i]分别表示节点i的左子节点、右子节点编号，如果lc[x]=0则表示x的左子树尚未建出来，rc[x]同理
//dat[i]表示节点i表示的值域区间中各数的出现次数之和
int n,L,x,mem=1;//因为0号被"未实际建出的节点"的特殊标记占用了，1号被版本0的根节点占用了

void addx(int l,int r,int& num)//更新操作，将线段树维护的集合中数L的出现次数加上x（x为1或-1）
{
	int t=num;num=++mem;lc[num]=lc[t];rc[num]=rc[t];dat[num]=dat[t];//备份当前节点，如果当前节点原来为空则也可以完成
	if(l==r)
	{
		if(!(dat[num]==0&&x<0))	dat[num]+=x;//如果L出现次数为0且操作为删除操作，则忽略操作
		return;
	}
	if(L<=mid)	addx(l,mid,lc[num]);
	else	addx(mid+1,r,rc[num]);
	dat[num]=0;
	if(lc[num])	dat[num]+=dat[lc[num]];
	if(rc[num])	dat[num]+=dat[rc[num]];//维护当前节点信息
}
int query(int l,int r,int num)//查询集合中小于x的数的个数
{
	if(l==r)	return 0;//如果已经到叶子节点了，那么当前节点等于x，显然不小于x
	if(!num)	return 0;//如果当前节点为空，那么该节点表示的子树中数都没有，自然返回0
	if(x<=mid)	return query(l,mid,lc[num]);//根据x决定向左/右子树走
	else	return (lc[num]?dat[lc[num]]:0)+query(mid+1,r,rc[num]);
}
int query_kth(int l,int r,int k,int num)//查询第k小数
{
	assert(num!=0);//assert(x)表示如果x为false则停止程序，是用来调试的。如果查询操作是正常进行的，那么不可能走到未建出的点中
	if(l==r)	{return l;}
	//if(!num)	return 0;//没有用
	int ls=lc[num]?dat[lc[num]]:0;
	if(ls>=k)	return query_kth(l,mid,k,lc[num]);//根据左子树中数出现总次数决定向左/右子树走
	else		return query_kth(mid+1,r,k-ls,rc[num]);
}
int query_time(int l,int r,int num)//查询数x出现的次数
{
	while(l!=r)
	{
		if(!num)	return 0;//当前节点未建出，表明其子节点均未出现
		if(L<=mid)	r=mid,num=lc[num];
		else	l=mid+1,num=rc[num];
	}
	return dat[num];
}
int query_pre(int l,int r,int num)//查询数x的前驱
{
	int t=query(l,r,num);//t是集合中比x小的数的个数
	if(t==0)	return -inf;//如果集合中比x小的数有0个，则x是集合中最小的数，不存在前驱
	return query_kth(l,r,t,num);//否则查询集合中第t小即可
}
int query_nxt(int l,int r,int num)
{
	int t1=query(l,r,num),t2=query_time(l,r,num);//t1是集合中比x小的数的个数,t2是集合中x出现的次数，加起来是集合中小于等于x的数的个数
	x=inf;int t3=query(l,r,num);
	if(t1+t2==t3)	return inf;//如果集合中小于等于x的数与集合中小于等于inf的数相等，则x是集合中最大的数，不存在后继
	return query_kth(l,r,t1+t2+1,num);//否则查询集合中第t1+t2+1小即可
}
int main()
{
	int i,v,idx;
	scanf("%d",&n);
	root[0]=1;
	for(i=1;i<=n;i++)
	{
		scanf("%d%d%d",&v,&idx,&x);root[i]=root[v];
		if(idx==1)
		{
			L=x;x=1;
			addx(ll,rr,root[i]);
		}
		else if(idx==2)
		{
			L=x;x=-1;
			addx(ll,rr,root[i]);
		}
		else if(idx==3)
		{
			printf("%d\n",query(ll,rr,root[i])+1);
		}
		else if(idx==4)
		{
			printf("%d\n",query_kth(ll,rr,x,root[i]));
		}
		else if(idx==5)
		{
			L=x;
			printf("%d\n",query_pre(ll,rr,root[i]));
		}
		else if(idx==6)
		{
			L=x;
			printf("%d\n",query_nxt(ll,rr,root[i]));
		}
	}
	return 0;
}
```

---

## 作者：intel_core (赞：8)

~~可持久化题不强制在线有啥意思？？？~~   
也许是wtcl,看题解区里大神们各种神仙做法表示不会    
讲一下这题$FHQ$ $Treap$可持久化怎么做   
众所周知：     
*    $FHQ$ $Treap$中对树的形态造成影响的只有$Split$和$Merge$  
*    可持久化的精髓是将重复的空间省去    
*    $Split$和$Merge$操作都只会改变两颗$Treap$交接处的节点（裂痕）   
*    裂痕是在整颗$Treap$上的一条链   
按照可持久化的思想，我们可以将裂痕处新开点，然后其他点依次复制   
原来的$Merge$:  
```cpp
int merge(int x,int y){
	if(!x||!y)return x+y;
	if(t[x].rnd<t[y].rnd){
		t[x].ch[1]=merge(t[x].ch[1],y);
      update(x);
      return x;
   }
   else{
		t[y].ch[0]=merge(x,t[y].ch[0]);
      update(y);
      return y;
   }
```
现在的$Merge$:  
```cpp
int merge(int x,int y){
	if(!x||!y)return x+y;
	if(t[x].rnd<t[y].rnd){
		int id=newNode();
		t[id]=t[x];
		t[id].ch[1]=merge(t[id].ch[1],y);
		update(id);
		return id;
	}
	else{
		int id=newNode();
		t[id]=t[y];
		t[id].ch[0]=merge(x,t[id].ch[0]);
		update(id);
		return id;
	}
}
```
$Split$可自行类比    
AC代码：  
```cpp
#include<bits/stdc++.h>
using namespace std;
const int NR=5e5+10;
struct node{
	int val;
	int size;
	int ch[2];
	int rnd;
}t[NR<<6];
#define lson t[id].ch[0]
#define rson t[id].ch[1]
void update(int id){
	t[id].size=t[lson].size+t[rson].size+1;
} 
int tot;
int newNode(int val=0){
	tot++;
	t[tot].val=val;
	t[tot].size=1;
	t[tot].rnd=rand();
	return tot;
}
void split(int id,int val,int &x,int &y){
	if(!id){
		x=y=0;
		return;	
	}
	if(val<t[id].val){
		y=newNode();
		t[y]=t[id];
		split(lson,val,x,t[y].ch[0]);
		update(y);
	}
	else{
		x=newNode();
		t[x]=t[id];
		split(rson,val,t[x].ch[1],y);
		update(x);
	}
}
int merge(int x,int y){
	if(!x||!y)return x+y;
	if(t[x].rnd<t[y].rnd){
		int id=newNode();
		t[id]=t[x];
		t[id].ch[1]=merge(t[id].ch[1],y);
		update(id);
		return id;
	}
	else{
		int id=newNode();
		t[id]=t[y];
		t[id].ch[0]=merge(x,t[id].ch[0]);
		update(id);
		return id;
	}
}
void insert(int val,int &id){
	int x,y;
	split(id,val,x,y);
	id=merge(x,merge(newNode(val),y));
}
void del(int val,int &id){
	int x,y,z;
	x=y=z=0;
	split(id,val,x,z);
	split(x,val-1,x,y);
	y=merge(t[y].ch[0],t[y].ch[1]);
	id=merge(merge(x,y),z); 
}
int rt[NR];
int kth(int id,int k){
	while(1){
		if(k<=t[lson].size)id=lson;
		else{
			k-=t[lson].size;
			if(!--k)return id;
			id=rson;
		}
	}
}
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		int ver,opt,x;
		scanf("%d%d%d",&ver,&opt,&x);
		rt[i]=rt[ver];
		if(opt==1)insert(x,rt[i]);
		if(opt==2)del(x,rt[i]);
		if(opt==3){
			int y,z;
			y=z=0;
			split(rt[i],x-1,y,z);
			printf("%d\n",t[y].size+1);
		}
		if(opt==4)printf("%d\n",t[kth(rt[i],x)].val);
		if(opt==5){
			int y,z;
			y=z=0;
			split(rt[i],x-1,y,z);
			if(y==0){
				puts("-2147483647");
				continue;
			}
			printf("%d\n",t[kth(y,t[y].size)].val);
			rt[i]=merge(y,z);
		}
		if(opt==6){
			int y,z;
			y=z=0;
			split(rt[i],x,y,z);
			if(z==0){
				puts("2147483647");
				continue;
			}
			printf("%d\n",t[kth(z,1)].val);
			rt[i]=merge(y,z);
		}
	}
	return 0;
}
```


---

## 作者：龙之吻—水货 (赞：8)

由于替罪羊树维护平衡不是靠旋转而是靠重构，所以替罪羊树的根是不会变的，这样就可以利用替罪羊树进行可持久化了。

对于3,4,5,6操作，只需要给把要操作的根复制一遍到新根上，其他的和普通的替罪羊树一样；

对于1,2操作先把要操作的根复制一遍到新根，然后进行类似动态开点的线段树，如果要加入（删除）的值比现在节点的大，就new一个左儿子，把原来的节点的所有信息copy到左儿子上，如果要加入（删除）的值比现在节点的小同理操作右儿子，如果要加入（删除）的值等于现在的节点，就直接修改就好了（详见代码）。

然而我这个替罪羊树有个缺点，每次重构的时候不能释放空间，否则会删掉有用的节点，只能通过减少a的值用时间换空间了（如果谁有解决这个的方法，求私信告知）。
附上代码
```
#include<cstdio>
#include<algorithm>

using namespace std;

const int maxn = 5e5 + 7;

const int INF = 2147483647;

double a = 0.50;

int num[1000010], sum, t[1000010];

struct Node{
    Node *leftchild, *rightchild;
    int val, cnt, size, tot, del;

    Node (int val, int cnt) :
        val(val),
        leftchild(NULL),
        rightchild(NULL),
        cnt(cnt),
        del(0),
        tot(0),
        size(cnt){}
};

Node *root[maxn], *null;

void Copy(Node *&now, Node *last) {
	if (!last) {
		now = NULL;
		return;
	}
	now->leftchild = last->leftchild;
	now->rightchild = last->rightchild;
	now->cnt = last->cnt;
	now->del = last->del;
	now->size = last->size;
	now->tot = last->tot;
	now->val = last->val;
}

void UpdateSize(Node *&now) {
    if (!now) {
        return;
    }
    now->size = now->cnt;
    now->del = now->tot;
    if (now->leftchild) {
        now->size += now->leftchild->size;
        now->del += now->leftchild->del;
    }
    if (now->rightchild) {
        now->size += now->rightchild->size;
        now->del += now->rightchild->del;
    }
}

void DFS(Node *now) {
    if (!now) {
        return;
    }
    DFS(now->leftchild);
    if (now->cnt - now->tot) {
        num[++sum] = now->val;
        t[sum] = now->cnt - now->tot;   	
    }
    DFS(now->rightchild);
}

Node *Rebuild(int l, int r) {
    Node *now;
    if (l > r) {
        return NULL;
    }
    if (l == r) {
        now = new Node(num[l], t[l]);
        return now;
    }
    int mid = l + r >> 1;
    now = new Node(num[mid], t[mid]);
    now->leftchild = Rebuild(l, mid - 1);
    now->rightchild = Rebuild(mid + 1, r);
    UpdateSize(now);
    return now;
}

void Maintain(Node *&now) {
    if (!now) {
        return;
    }
    int left_size = now->leftchild ? now->leftchild->size : 0;
    int right_size = now->rightchild ? now->rightchild->size : 0;
    if ((double)left_size * a > (double)right_size) {
        sum = 0;
        DFS(now);
        now = Rebuild(1, sum);
    }
    else if ((double)right_size * a > (double)left_size) {
        sum = 0;
        DFS(now);
        now = Rebuild(1, sum);
    }
    else if(now->del >= now->size / 2 || now->cnt <= now->tot) {
        sum = 0;
        DFS(now);
        now = Rebuild(1, sum);    	
    }
}

Node *Insert(Node *now, int val, Node *last) {
    if (!now) {
        now = new Node(val, 1);
        return now;
    }
    if (now->val == val) {
        now->cnt++;
    }
    else if(now->val > val) {
    	now->leftchild = new Node(1, 1);
    	Copy(now->leftchild, last->leftchild);
        now->leftchild = Insert(now->leftchild, val, last->leftchild);
    }
    else {
    	now->rightchild = new Node(1, 1);
    	Copy(now->rightchild, last->rightchild);
        now->rightchild = Insert(now->rightchild, val, last->rightchild);
    }
    UpdateSize(now);
    Maintain(now);
    return now;
}

Node *Remove(Node *now, int val, Node *last) {
    if (!now) {
        return now;
    }
    if (now->val == val) {
        now->tot++;
    }
    else if (now->val > val) {
    	now->leftchild = new Node(1, 1);
    	Copy(now->leftchild, last->leftchild);
        now->leftchild = Remove(now->leftchild, val, last->leftchild); 
    }
    else {
    	now->rightchild = new Node(1, 1);
    	Copy(now->rightchild, last->rightchild);
        now->rightchild = Remove(now->rightchild, val, last->rightchild);
    } 
    UpdateSize(now);
    Maintain(now);
    return now;
}

int Rank(Node *now, int val) {
    if (!now) {
        return 1;
    }
    int left_size = now->leftchild ? now->leftchild->size - now->leftchild->del: 0;
    if (now->val == val) {
        return left_size + 1;
    }
    if (now->val < val) {
        return left_size + now->cnt - now->tot + Rank(now->rightchild, val);
    }
    else {
        return Rank(now->leftchild, val);
    }
}

int FindKth(Node *now, int rank) {
    if (!now) {
        return 0;
    }
    int left_size = now->leftchild ? now->leftchild->size - now->leftchild->del: 0;
    if (rank <= left_size) {
        return FindKth(now->leftchild, rank);
    }
    rank -= left_size;
    if (rank <= now->cnt - now->tot) {
        return now->val;
    }
    rank -= now->cnt - now->tot;
    return FindKth(now->rightchild, rank);
}

int GetPro(Node *now, int val) {
    if(!now) {
        return -INF;
    }
    if (now->val < val) {
    	if (now->cnt > now->tot) {
            return max(now->val, GetPro(now->rightchild, val));    		
    	}
        return GetPro(now->rightchild, val);
    }
    else {
        return GetPro(now->leftchild, val);
    }
}

int GetSuc(Node *now, int val) {
    if (!now) {
        return INF;
    }
    if (now->val > val) {
    	if (now->cnt > now->tot) {
            return min(now->val, GetSuc(now->leftchild, val));    		
    	}
        return GetSuc(now->leftchild, val);
    }
    else {
        return GetSuc(now->rightchild, val);
    }
}



int n;

int main() {
    scanf("%d", &n);
    int _sum = 0;
    for (int i = 1; i <= n; i++) {
        int flag, x, numb;
        scanf("%d %d %d", &numb, &flag, &x);
        switch(flag) {
            case 1 : {
            	root[++_sum] = new Node(1, 1);
            	Copy(root[_sum], root[numb]);
                root[_sum] = Insert(root[_sum], x, root[numb]);
                break;
            }
            case 2 : {
            	root[++_sum] = new Node(1, 1);
            	Copy(root[_sum], root[numb]);
                root[_sum] = Remove(root[_sum], x, root[numb]);
                break;
            }
            case 3 : {
            	root[++_sum] = new Node(1, 1);
            	Copy(root[_sum], root[numb]);
                printf("%d\n", Rank(root[_sum], x));
                break;
            }
            case 4 : {
            	root[++_sum] = new Node(1, 1);
            	Copy(root[_sum], root[numb]);
                printf("%d\n", FindKth(root[_sum], x));
                break;
            }
            case 5 : {
            	root[++_sum] = new Node(1, 1);
            	Copy(root[_sum], root[numb]);
                printf("%d\n", GetPro(root[_sum], x));
                break;
            }
            case 6 : {
            	root[++_sum] = new Node(1, 1);
            	Copy(root[_sum], root[numb]);
                printf("%d\n", GetSuc(root[_sum], x));
                break;
            }
        }
    }   
}
```

---

## 作者：Yeji_ (赞：7)

## 前言
嗯，刚学完了$fhq-treap$那就用它来做吧！

### fhq-treap
这是某一位大佬创建的结构，主要操作就只有两种：$split$和$merge$

现在我们先具体来讲一讲这两个操作。
### 定义
    int son[MAXN][3];//0 左孩子，1右孩子
    int val[MAXN];//每个点的权值
    int rd[MAXN];//每个点的随机权值
    int size[MAXN];//以每个点为根的树的大小

### split
split分为两种，一种是根据权值，另一种是根据排名，但是最好还是根据权值来分裂。

我们将这这一大棵树分为两棵小树，用x和y来代替，

中间以一个k为分界值，小于k去左边的，大于k去右边。

这个其中就蕴含了很多的性质，希望读者可以自己思考（主要是根的关系）

这么说起来还是比较简单的

$Talk$  $is$ $cheap,$ $show$ $you$ $the$ $code$

```cpp
void split(int now,int k,int &x,int &y)
{
    if(!now) 
        x=y=0;
    else 
    {
        if (val[now]<=k) 
            x=now,split(son[now][1],k,son[now][1],y);
        else 
            y=now,split(son[now][0],k,x,son[now][0]);
        update(now);
    }
}
```

### merge

我们假设第一棵树的权值小于第二棵树的权值，那么我们就比较它们的随机权值。

如果rd[l]<rd[r]，我们就保留它的左子树，另一棵树作为它的右子树；

如果rd[l]>=rd[r]，那我们可以保留第二棵树的右子树，另一颗树作为它的左子树。

$Talk$  $is$ $cheap,$ $show$ $you$ $the$ $code$
```cpp
int merge(int A,int B)
{
    if (!A||!B) 
        return  A+B;
    if (rd[A]<rd[B])
    {
        son[A][1]=merge(son[A][1],B); 
        update(A); 
        return A;
    }
    else 
    {
        son[B][0]=merge(A,son[B][0]); 
        update(B); 
        return B;
    } 
}
```

### 其他

#### 排名

直接按照a-1的权值把树分开，那么x树中最大的应该小于等于a-1，那么a的排名就是size[x]+1。
#### k小值
这个太简单了，懒得说
#### 前驱&&后继
我们先看前驱，因为要小于now，

所以我们还是按照now-1的权值划分x，现在x中最大的数一定小于等于now-1，所以我们直接输出x中最大的数就好，

后继同理。
#### 删除
删除权值为v的点，

先把整颗树以v为权值split成两棵树a,b,再把a树按照v-1分成c,d。

这时候值为v的点一定为d的根，那么我们把d的两个子儿子merge起来

（划重点：这一步就是去除掉v的影响），

再把他们重新merge起来得到一个新的树，这颗树就去除掉了v的影响。

给出全部代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<bits/stdc++.h>
#include<cstring>
using namespace std;
int size[500001],son[500001][2],rd[500001],val[500001];
int T,tot,n,m,x,y,z,opt,a,root,com;
inline void update(int x)
{
    size[x]=1+size[son[x][0]]+size[son[x][1]];
}
inline int new_node(int x)
{
    size[++tot]=1;
    val[tot]=x;
    rd[tot]=rand();
    return tot;
}
int merge(int A,int B)
{
    if (!A||!B) 
        return  A+B;
    if (rd[A]<rd[B])
    {
        son[A][1]=merge(son[A][1],B); 
        update(A); 
        return A;
    }
    else 
    {
        son[B][0]=merge(A,son[B][0]); 
        update(B); 
        return B;
    } 
}
void split(int now,int k,int &x,int &y)
{
    if(!now) 
        x=y=0;
    else 
    {
        if (val[now]<=k) 
            x=now,split(son[now][1],k,son[now][1],y);
        else 
            y=now,split(son[now][0],k,x,son[now][0]);
        update(now);
    }
}
int kth(int now,int k)
{
    while(1)
    {
        if (k<=size[son[now][0]]) 
            now=son[now][0];
        else 
            if (k==size[son[now][0]]+1) 
                return now;
        	else 
                k-=size[son[now][0]]+1,now=son[now][1];
    }
}

int main()
{
    srand((unsigned)time(NULL));
    cin>>T;
    while (T--)
    {
    	scanf("%d%d",&opt,&a);
        if (opt==1)
        {
            split(root,a,x,y);
            root=merge(merge(x,new_node(a)),y);
        }
        if (opt==2)
        {
            split(root,a,x,z);
            split(x,a-1,x,y);
            y=merge(son[y][0],son[y][1]);
            root=merge(merge(x,y),z);
        }
        if (opt==3)
        {
            split(root,a-1,x,y);
            printf("%d\n",size[x]+1);
            root=merge(x,y);
        }
        if (opt==4) 
            printf("%d\n",val[kth(root,a)]);
        if (opt==5)
        {
            split(root,a-1,x,y);
            printf("%d\n",val[kth(x,size[x])]);
            root=merge(x,y);
        }
        if (opt==6)
        {
            split(root,a,x,y);
            printf("%d\n",val[kth(y,1)]);
            root=merge(x,y);
        }
    }
}
```


### 可持久化
想要可持久化还是比较简单的，只要将上一次的状态保存一下就行（对于fhq-treap来说）

$Talk$  $is$ $cheap,$ $show$ $you$ $the$ $code$
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<bits/stdc++.h>
#include<cstring>
using namespace std;
int size[5000001],son[5000001][2],rd[5000001],val[5000001],rt[5000000];
int T,tot,n,m,x,y,z,opt,a,root,com,bt;
inline void update(int x)
{
    size[x]=1+size[son[x][0]]+size[son[x][1]];
}
inline int new_node(int x)
{
    size[++tot]=1;
    val[tot]=x;
    rd[tot]=rand();
    return tot;
}
int merge(int A,int B)
{
    if (!A||!B) 
        return  A+B;
    if (rd[A]<rd[B])
    {
        son[A][1]=merge(son[A][1],B); 
        update(A); 
        return A;
    }
    else 
    {
        son[B][0]=merge(A,son[B][0]); 
        update(B); 
        return B;
    } 
}
void split(int now,int k,int &x,int &y)
{
    if(!now) 
        x=y=0;
    else 
    {
        if (val[now]<=k) 
            x=now,split(son[now][1],k,son[now][1],y);
        else 
            y=now,split(son[now][0],k,x,son[now][0]);
        update(now);
    }
}
int kth(int now,int k)
{
    while(1)
    {
        if (k<=size[son[now][0]]) 
            now=son[now][0];
        else 
            if (k==size[son[now][0]]+1) 
                return now;
        	else 
                k-=size[son[now][0]]+1,now=son[now][1];
    }
}

int main()
{
    srand((unsigned)time(NULL));
    cin>>n;
	for (int i=1;i<=n;i++)
    {
    	scanf("%d%d%d",&bt,&opt,&a);
        rt[i]=rt[bt];
		if (opt==1)
        {
            split(rt[i],a,x,y);
            rt[i]=merge(merge(x,new_node(a)),y);
        }
        if (opt==2)
        {
            split(rt[i],a,x,z);
            split(x,a-1,x,y);
            y=merge(son[y][0],son[y][1]);
            rt[i]=merge(merge(x,y),z);
        }
        if (opt==3)
        {
            split(rt[i],a-1,x,y);
            printf("%d\n",size[x]+1);
            rt[i]=merge(x,y);
        }
        if (opt==4) 
            printf("%d\n",val[kth(rt[i],a)]);
        if (opt==5)
        {
            split(rt[i],a-1,x,y);
            printf("%d\n",val[kth(x,size[x])]);
            rt[i]=merge(x,y);
        }
        if (opt==6)
        {
            split(rt[i],a,x,y);
            printf("%d\n",val[kth(y,1)]);
            rt[i]=merge(x,y);
        }
    }
	
    
}
```



---

## 作者：stripe_python (赞：6)

现有的在线题解：FHQ-Treap、01-Trie、WBLT、线段树、替罪羊（复杂度是假的），和 [**有旋 Treap**](https://www.luogu.com.cn/article/6sbyh6lw)。

那么，既然有旋 Treap 可持久化，同样使用旋转维护平衡的 AVL 树也可以可持久化。

先介绍 AVL 树的原理：AVL 树每个节点维护树高 $high$，需要通过旋转操作保证 $|high_l-high_r| \le 1$。可以证明，满足这一性质的 AVL 树高为严格 $O(\log n)$。

AVL 树的节点定义如下：

```cpp
template <class T>
struct AVLTreeNode {
	T val;
	AVLTreeNode<T> *left, *right;
	long cnt, size, high;
	
	AVLTreeNode() :
	val(T()), left(nullptr), right(nullptr), cnt(1), size(1), high(1) {}
	
	AVLTreeNode(const T& v) :
	val(v), left(nullptr), right(nullptr), cnt(1), size(1), high(1) {}
	
	AVLTreeNode<T>* pushup() {
		size = cnt + (left ? left->size : 0) + (right ? right->size : 0);
		high = std::max(left ? left->high : 0, right ? right->high : 0) + 1;
		return this;
	}
};
```

每一次旋转、插入、删除时，我们复制一份 AVL 节点，见代码：

```cpp
static node* left_rotate(node* p) {
    // 左旋节点 p
    node *q = p->left;
    p->left = copy(p->left);   // Added
    p->left = q->right, q->right = p, p->pushup();
    return q->pushup();
}
static node* right_rotate(node* p) {
    // 右旋节点 p
    node *q = p->right;
    p->right = copy(p->right);   // Added
    p->right = q->left, q->left = p, p->pushup();
    return q->pushup();
}
static node* left_right_rotate(node* p) {
    p->left = right_rotate(p->left);
    return left_rotate(p);
}
static node* right_left_rotate(node* p) {
    p->right = left_rotate(p->right);
    return right_rotate(p);
}
```

以下是完整版代码，对于普通 AVL 模板添加的地方做了标记。其实 AVL 也挺好写的。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5e5 + 5;

// AVL 树节点类，维护树高high
// AVL 树通过旋转保证 |left->high - right->high| <= 1
template <class T>
struct AVLTreeNode {
	T val;
	AVLTreeNode<T> *left, *right;
	long cnt, size, high;
	
	AVLTreeNode() :
	val(T()), left(nullptr), right(nullptr), cnt(1), size(1), high(1) {}
	
	AVLTreeNode(const T& v) :
	val(v), left(nullptr), right(nullptr), cnt(1), size(1), high(1) {}
	
	AVLTreeNode<T>* pushup() {
		size = cnt + (left ? left->size : 0) + (right ? right->size : 0);
		high = std::max(left ? left->high : 0, right ? right->high : 0) + 1;
		return this;
	}
};

template <class T, class Cmp = std::less<T>> 
struct AVLTree {
	using node = AVLTreeNode<T>;
	Cmp cmp = Cmp();
	node *roots[N];
	
	static node* copy(node* cur) {   // 复制节点
		node *res = nullptr;
		if (cur) res = new node, *res = *cur;
		return res;
	}
	
	static node* get_min(node* cur) {
		node *x = cur;
		while (x && x->left) x = x->left;
		return x;
	}
	static node* get_max(node* cur) {
		node *x = cur;
		while (x && x->right) x = x->right;
		return x;
	}
	
	static node* left_rotate(node* p) {
		// 左旋节点 p
		node *q = p->left;
		p->left = copy(p->left);   // Added
		p->left = q->right, q->right = p, p->pushup();
		return q->pushup();
	}
	static node* right_rotate(node* p) {
		// 右旋节点 p
		node *q = p->right;
		p->right = copy(p->right);   // Added
		p->right = q->left, q->left = p, p->pushup();
		return q->pushup();
	}
	static node* left_right_rotate(node* p) {
		p->left = right_rotate(p->left);
		return left_rotate(p);
	}
	static node* right_left_rotate(node* p) {
		p->right = left_rotate(p->right);
		return right_rotate(p);
	}
	static long get_high(node* p) {return p ? p->high : 0;}
	
	void insert(node*& cur, const T& val) {
		if (!cur) {
			cur = new node(val);
			return;
		}
		if (val == cur->val) {
			cur->cnt++, cur->pushup();
			return;
		}
		if (cmp(val, cur->val)) {
			cur->left = copy(cur->left);    // Added
			insert(cur->left, val), cur->pushup();
			if (get_high(cur->left) - get_high(cur->right) >= 2) {
				cur = cmp(val, cur->left->val) ? 
				left_rotate(cur) : left_right_rotate(cur);
			}
		} else {
			cur->right = copy(cur->right);   // Added
			insert(cur->right, val), cur->pushup();
			if (get_high(cur->right) - get_high(cur->left) >= 2) {
				cur = cmp(val, cur->right->val) ? 
				right_left_rotate(cur) : right_rotate(cur);
			}
		}
		cur->pushup();
	}
	
	bool remove_node(node*& cur) {
		if (!cur) return false;
		if (cur->cnt > 1) {
			cur->cnt--, cur->pushup();
			return true;
		}
		if (cur->left && cur->right) {
			node* replace = this->get_min(cur->right);
			cur->cnt = replace->cnt, cur->val = replace->val;
			replace->cnt = 1;
			remove(cur->right, replace->val), cur->pushup();
			if (get_high(cur->left) - get_high(cur->right) >= 2) {
				cur = (get_high(cur->left->left) >= get_high(cur->left->right)) ?
				left_rotate(cur) : left_right_rotate(cur);
			}
		} else {
			cur = cur->left ? cur->left : cur->right;
		}
		if (cur) cur->pushup();
		return true;
	}
	bool remove(node*& cur, const T& val) {
		if (!cur) return false;
		if (val == cur->val) return remove_node(cur);
		bool res;
		if (cmp(val, cur->val)) {
			cur->left = copy(cur->left);   // Added
			res = remove(cur->left, val), cur->pushup();
			if (get_high(cur->right) - get_high(cur->left) >= 2) {
				cur = get_high(cur->right->right) >= get_high(cur->right->left) ? 
				right_rotate(cur) : right_left_rotate(cur);
			}
		} else {
			cur->right = copy(cur->right);   // Added
			res = remove(cur->right, val), cur->pushup();
			if (get_high(cur->left) - get_high(cur->right) >= 2) {
				cur = get_high(cur->left->left) >= get_high(cur->left->right) ? 
				left_rotate(cur) : left_right_rotate(cur);
			}
		}
		if (cur) cur->pushup();
		return res;
	}
	
	int rank(node* cur, const T& val) const {
		if (!cur) return 1;
		int left_size = cur->left ? cur->left->size : 0;
		if (val == cur->val) return left_size + 1;
		if (cmp(val, cur->val)) return rank(cur->left, val);
		return rank(cur->right, val) + left_size + cur->cnt;
	}
	T kth(node* cur, int k) const {
		if (!cur) return T();
		int left_size = cur->left ? cur->left->size : 0;
		if (left_size >= k) return kth(cur->left, k);
		if (left_size < k - cur->cnt) return kth(cur->right, k - left_size - cur->cnt);
		return cur->val;
	}

	T predecessor(node *root, const T& val) const {
		node *cur = root;
		T res = -numeric_limits<T>::max();
		while (cur) {
			if (cmp(cur->val, val)) res = cur->val, cur = cur->right;
			else cur = cur->left;
		}
		return res;
	}
	T successor(node *root, const T& val) const {
		node *cur = root;
		T res = numeric_limits<T>::max();
		while (cur) {
			if (cmp(val, cur->val)) res = cur->val, cur = cur->left;
			else cur = cur->right;
		}
		return res;
	}
};

AVLTree<int> avl;
int q, v, opt, x;

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr), cout.tie(nullptr);
	cin >> q;
	avl.roots[0] = nullptr;
	for (int i = 1; i <= q; i++) {
		cin >> v >> opt >> x;
		avl.roots[i] = avl.copy(avl.roots[v]);
		if (opt == 1) avl.insert(avl.roots[i], x);
		else if (opt == 2) avl.remove(avl.roots[i], x);
		else if (opt == 3) cout << avl.rank(avl.roots[i], x) << '\n';
		else if (opt == 4) cout << avl.kth(avl.roots[i], x) << '\n';
		else if (opt == 5) cout << avl.predecessor(avl.roots[i], x) << '\n';
		else if (opt == 6) cout << avl.successor(avl.roots[i], x) << '\n';
		//cerr << prettify(avl.roots[i]) << endl;
	}
	return 0;
}
```

---

## 作者：GKxx (赞：5)

昨天晚上用zkw线段树过了[P3369普通平衡树](https://www.luogu.org/problemnew/show/P3369)，突然意识到如果让线段树可持久化不就可以过这道题了吗！于是我就把这道题A了。。。

看到题解里果然已经有人用线段树了，不过我们的用法还是略有不同，我是将读入的数据离散化的。

线段树的做法很简单。设f[x]表示x这个数出现了多少次：

- 插入一个数：++f[x]

- 删除一个数：--f[x]

- 查询一个数的排名：求前缀和

- 查询第k小：在线段树上二分

- 前驱、后继：转化为先查询排名再查询第k小。（昨晚做普通平衡树的时候是用zkw写的，前驱和后继就比较方便，但是这题要可持久化，得动态开点，为了避免麻烦就这样写了）

所以我们的线段树只要维护f数组的区间和就行了！

这题要可持久化，那么只要对线段树可持久化就好了，非常简单。

另外，千万要注意的一个事情就是本题的2操作不保证被删除的数存在，所以sum数组的维护一定要仔细考虑。我一开始就是在这个地方WA到只有28分，然后第一次改完依然只有80分，又静态查错了好久才发现问题。

```cpp
// C++11
#include <cctype>
#include <cstdio>
#include <climits>
#include <algorithm>

template <typename T> inline void read(T& t) {
    int f = 0, c = getchar(); t = 0;
    while (!isdigit(c)) f |= c == '-', c = getchar();
    while (isdigit(c)) t = t * 10 + c - 48, c = getchar();
    if (f) t = -t;
}
template <typename T, typename... Args>
inline void read(T& t, Args&... args) {
    read(t); read(args...);
}

#define rep(I, A, B) for (int I = (A); I <= (B); ++I)
#define rrep(I, A, B) for (int I = (A); I >= (B); --I)

const int maxn = 5e5 + 100;
struct Command {
    int v, q, x;
    explicit Command(int vv = 0, int qq = 0, int xx = 0)
        : v(vv), q(qq), x(xx) {}
};
Command cmd[maxn];
int tmp[maxn];
int root[maxn], sum[maxn * 40], left[maxn * 40], right[maxn * 40];
int n, tot, all;

void build(int &curr, int l, int r) {
    curr = ++tot;
    if (l == r) return;
    int mid = (l + r) >> 1;
    build(left[curr], l, mid);
    build(right[curr], mid + 1, r);
}
void insert(int &curr, int pre, int l, int r, int x, int val) {
    curr = ++tot;
    sum[curr] = sum[pre];
    if (l == r) {
        sum[curr] += val;
        if (sum[curr] < 0) sum[curr] = 0;
        return;
    }
    int mid = (l + r) >> 1;
    if (x <= mid) {
        right[curr] = right[pre];
        insert(left[curr], left[pre], l, mid, x, val);
    } else {
        left[curr] = left[pre];
        insert(right[curr], right[pre], mid + 1, r, x, val);
    }
    sum[curr] = sum[left[curr]] + sum[right[curr]];
}
int querySum(int curr, int l, int r, int x) {
    if (x < l) return 0;
    if (x >= r) return sum[curr];
    int mid = (l + r) >> 1;
    return querySum(left[curr], l, mid, x) + querySum(right[curr], mid + 1, r, x);
}
int queryKth(int curr, int l, int r, int k) {
    if (l == r) return l;
    int mid = (l + r) >> 1;
    if (k <= sum[left[curr]])
        return queryKth(left[curr], l, mid, k);
    else
        return queryKth(right[curr], mid + 1, r, k - sum[left[curr]]);
}
inline int queryPrev(int v, int x) {
    int lessthan = querySum(root[v], 1, all, x - 1);
    if (!lessthan) return -2147483647;
    else return tmp[queryKth(root[v], 1, all, lessthan)];
}
inline int querySucc(int v, int x) {
    int lesseq = querySum(root[v], 1, all, x);
    if (lesseq >= sum[root[v]]) return 2147483647;
    else return tmp[queryKth(root[v], 1, all, lesseq + 1)];
}

int main() {
    read(n);
    rep(i, 1, n) {
        read(cmd[i].v, cmd[i].q, cmd[i].x);
        if (cmd[i].q != 4)
            tmp[++all] = cmd[i].x;
    }
    std::sort(tmp + 1, tmp + all + 1);
    all = std::unique(tmp + 1, tmp + all + 1) - (tmp + 1);

    build(root[0], 1, all);

    rep(i, 1, n) {
        int v = cmd[i].v, q = cmd[i].q, x = cmd[i].x;
        if (q != 4)
            x = std::lower_bound(tmp + 1, tmp + all + 1, x) - tmp;
        root[i] = root[v];
        switch (q) {
            case 1:
                insert(root[i], root[v], 1, all, x, 1);
                break;
            case 2:
                insert(root[i], root[v], 1, all, x, -1);
                break;
            case 3:
                printf("%d\n", querySum(root[i], 1, all, x - 1) + 1);
                break;
            case 4:
                printf("%d\n", tmp[queryKth(root[i], 1, all, x)]);
                break;
            case 5:
                printf("%d\n", queryPrev(i, x));
                break;
            case 6:
                printf("%d\n", querySucc(i, x));
                break;
        }
    }
    return 0;
}
```

---

## 作者：registerGen (赞：4)

首先感谢 @wangrx 大佬帮我卡常！！

---

看到题解里没有指针实现的 fhq-Treap，那我就来一发吧。

可持久化 fhq-Treap 的核心是它的两个基层操作——分裂和合并。

其它的操作按照不可持久的 fhq-Treap 写就行了。

可持久化**数据结构**的核心思想是：尽可能新建更少的结点记录新版本的信息，同时保留住历史版本的结点信息。可持久化 fhq-Treap 也不例外。

fhq-Treap 的可持久化：

已知有:

```cpp
typedef std::pair<Node*,Node*> droot;
```

对于分裂操作:

```cpp
droot split(Node* x,int k)
{
	if(!x)return droot(NULL,NULL);
	droot res;
	if(siz(x->ls)>=k)
	{
		res=split(x->ls,k);
		// 我们新建一个结点，并将 x 的信息复制到它身上。
		Node* p=new Node;
		copy(p,x);
		// 下面是对 p 进行 fhq-Treap 的正常操作
		p->ls=res.second;
		p->pushup();
		res.second=p;
	}
	else
	{
		res=split(x->rs,k-siz(x->ls)-1);
		// 同理
		Node* p=new Node;
		copy(p,x);
		p->rs=res.first;
		p->pushup();
		res.first=p;
	}
	return res;
}
```

对于合并操作：

```cpp
Node* merge(Node* x,Node* y)
{
	if(!x)return y;
	if(!y)return x;
	if(x->w<y->w)
	{
		Node* p=new Node;
		// 我们新建一个结点，并将 x 的信息复制到它身上。
		copy(p,x);
		// 下面是对 p 进行 fhq-Treap 的正常操作
		p->rs=merge(p->rs,y);
		p->pushup();
		return p;
	}
	else
	{
		Node* p=new Node;
		// 同理
		copy(p,y);
		p->ls=merge(x,p->ls);
		p->pushup();
		return p;
	}
}
```

由此可见，对于可持久化 fhq-Treap 的基层操作，每更改一个结点就要分值一个新的结点出来，**否则你修改的就是历史版本上的结点！！！**

---

核心部分就讲到这里，下面给出完整代码。

时间复杂度 $O(n\log n)$，空间复杂度 $O(n\log n)$，常数较大。

写代码时要注意一些 C++ 语言上的细节（因为用的是指针）。

无注释的代码看[这里](https://www.luogu.com.cn/paste/r6mtf9k5)。

```cpp
#include<cstdio>
#include<algorithm>
#include<cstdlib>

const int N=5e5;
const int LOGN=20;
const int INF=2147483647;

struct Node
{
	int v,w;
	Node *ls,*rs;
	int siz;
	
	Node(){}
	
	Node(int _v):v(_v),w(rand()),ls(NULL),rs(NULL),siz(1){}
	
	inline void pushup()
	{
		siz=(ls?ls->siz:0)+(rs?rs->siz:0)+1;
	}
};

typedef std::pair<Node*,Node*> droot;

Node* root[N+10];
int n;

// 以下为卡常部分

#define SIZ 1000000

inline char gc()
{
	static char buf[SIZ],*p1,*p2;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,SIZ,stdin),p1==p2)?EOF:*p1++;
}

#undef SIZ

inline void read(int& x)
{
	x=0;int f=0;char c=gc();
	while(c<'0'||c>'9')f|=(c=='-'),c=gc();
	while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+(c^48),c=gc();
	if(f)x=-x;
}

// @wangrx 大佬教我的卡常技巧：重载 new 运算符
// 下面的话引自 @wangrx
// new 是系统在给你分配内存，速度肯定不敢恭维
// 这么写相当于手动分配内存，但是 delete 就用不了了
// 亲测有用

char pool[1<<30],*ptop=pool+(1<<30);

void* operator new(size_t size)
{
	return ptop-=size;
}

// 以上为卡常部分
// 以下为 fhq-Treap 部分

inline int siz(Node* x)
{
	return x?x->siz:0;
}

inline void copy(Node*& p,Node* x) // 不能直接赋值，而且要引用，否则就和没改一样
{
	p->v=x->v;
	p->w=x->w;
	p->ls=x->ls;
	p->rs=x->rs;
	p->siz=x->siz;
}

droot split(Node* x,int k)
{
	if(!x)return droot(NULL,NULL);
	droot res;
	if(siz(x->ls)>=k)
	{
		res=split(x->ls,k);
		Node* p=new Node;
		copy(p,x);
		p->ls=res.second;
		p->pushup();
		res.second=p;
	}
	else
	{
		res=split(x->rs,k-siz(x->ls)-1);
		Node* p=new Node;
		copy(p,x);
		p->rs=res.first;
		p->pushup();
		res.first=p;
	}
	return res;
}

Node* merge(Node* x,Node* y)
{
	if(!x)return y;
	if(!y)return x;
	if(x->w<y->w)
	{
		Node* p=new Node;
		copy(p,x);
		p->rs=merge(p->rs,y);
		p->pushup();
		return p;
	}
	else
	{
		Node* p=new Node;
		copy(p,y);
		p->ls=merge(x,p->ls);
		p->pushup();
		return p;
	}
}

int queryrk(Node*& rt,int k)
{
	if(!rt)return 0;
	return k<=rt->v?queryrk(rt->ls,k):queryrk(rt->rs,k)+siz(rt->ls)+1;
}

int querykth(Node*& rt,int k) // 要加引用，才能真正修改 rt，以下同理
{
	droot x=split(rt,k-1);
	droot y=split(x.second,1);
	Node* res=y.first;
	rt=merge(merge(x.first,y.first),y.second);
	return res->v;
}

void insert(Node*& rt,int v)
{
	int k=queryrk(rt,v);
	droot x=split(rt,k);
	Node* now=new Node(v);
	rt=merge(merge(x.first,now),x.second);
}

void erase(Node*& rt,int v)
{
	int k=queryrk(rt,v);
	droot x=split(rt,k);
	droot y=split(x.second,1);
	if(y.first->v!=v)return;
	rt=merge(x.first,y.second);
}

int querypre(Node*& rt,int v)
{
	int k=queryrk(rt,v);
	droot x=split(rt,k-1);
	droot y=split(x.second,1);
	Node* res=y.first;
	rt=merge(merge(x.first,y.first),y.second);
	return res->v;
}

int querysuc(Node*& rt,int v)
{
	int k=queryrk(rt,v+1);
	droot x=split(rt,k);
	droot y=split(x.second,1);
	Node* res=y.first;
	rt=merge(merge(x.first,y.first),y.second);
	return res->v;
}

// 以上为 fhq-Treap 部分，没有什么奇奇怪怪的操作对吧

int main()
{
#ifndef ONLINE_JUDGE
	freopen("data.in","r",stdin);
	freopen("data.out","w",stdout);
#endif 
	srand(20070414U);
	read(n);
	insert(root[0],INF);
	insert(root[0],-INF);
	for(int q=1;q<=n;q++)
	{
		int ver,opt,x;
		read(ver),read(opt),read(x);
		root[q]=root[ver]; // 可持久化基本操作
		if(opt==1)insert(root[q],x);
		if(opt==2)erase(root[q],x);
		if(opt==3)printf("%d\n",queryrk(root[q],x)); // 其实是 queryrk(root[q],x)+1-1，注意 +1，-1 的细节问题
		if(opt==4)printf("%d\n",querykth(root[q],x+1)); // 注意 +1，-1 的细节问题
		if(opt==5)printf("%d\n",querypre(root[q],x));
		if(opt==6)printf("%d\n",querysuc(root[q],x));
	}
	return 0;
}
```

---

## 作者：梧桐灯 (赞：4)

这是运用主席树（可持久化权值线段树）来实现的。一般来说，只要题目**不强制在线**，平衡树的题大多都能用主席树来完成。接下来对于每一个操作说一下思路：

插入：正常的插入操作。

**删除**：先查找是否存在，若存在则是正常的删除操作；若不存在，则赋值历史版本到当前版本（当时就是这一步忘了然后一直Wa……）

查排名：查询小于x的数的个数并+1（好像跟没说一样）

查第k小：正常操作即可，同主席树板子

**查前驱**：找到x的排名，若是1则无解，否则找到比它排名小1的数（即第排名-1大）

**查后继**：稍微麻烦一点，首先找到最小的比x大的数的排名（当然如果x在离散化数组中最大一点无解），然后如果排名等于数的个数+1则无解，否则找到第排名大的数输出。

代码：
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

namespace io {
	#define getc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++)
    const int SIZ = 1 << 21 | 1;
    char* iS, * iT, ibuff[SIZ], obuff[SIZ], * oS = obuff, * oT = oS + SIZ - 1, fu[110], c;
    int fr;
    inline void out() {
        fwrite(obuff, 1, oS - obuff, stdout);
        oS = obuff;
        return ;
    }
    inline void putc (const char x) {
    	*oS++ = x;
    	out ();
    	return ;
    }
    template<typename Type>
    inline void read(Type& s) {
        s = 0; int f = 0;
        c = getc (); while (c < '0' || c > '9') {if (c == '-') f = 1; c = getc ();}
        while (c >= '0' && c <= '9') s = (s << 3) + (s << 1) + (c ^ 48), c = getc ();
        s = f ? -s : s; return ;
    }
    template<typename Type>
    inline void write(Type x) {
        if (x < 0)
            * oS++ = '-', x = -x;
        if (!x)
            * oS++ = '0';
        while (x)
            fu[++fr] = x % 10 + '0', x /= 10;
        while (fr)
            * oS++ = fu[fr--];
        out();
    }
    inline void put(const char x[]) {
        for (register int i = 0; x[i]; ++i)
            * oS++ = x[i];
        out();
    }
}
using namespace io;

const int N = 500003;
const char npre[] = {"-2147483647\n"};
const char nnxt[] = {"2147483647\n"};

int n, rt[N], a[N], m;
int sum[N * 150], lc[N * 150], rc[N * 150], cnt;
struct query {
	int be, op, x;
}s[N];

int exi (const int v, const int L, const int R, const int x) {
	if (!sum[v]) return 0;
	if (L == R) return sum[v];
	const int mid = L + R >> 1;
	if (mid >= x) return exi (lc[v], L, mid, x);
	return exi (rc[v], mid + 1, R, x);
}

void Insert (const int pr, int& v, const int L, const int R, const int x, const int z) {
	v = ++cnt;
	lc[v] = lc[pr], rc[v] = rc[pr];
	sum[v] = sum[pr] + z;
	if (L == R) return ;
	const int mid = L + R >> 1;
	if (mid >= x) Insert (lc[pr], lc[v], L, mid, x, z);
	else Insert (rc[pr], rc[v], mid + 1, R, x, z);
	return ;
}

int findrank (const int v, const int L, const int R, const int x) { //如果下面已经没有数或者搜到叶子肯定返回1
	if (!sum[v] || L == R) return 1;
	const int mid = L + R >> 1;
	if (mid >= x) return findrank (lc[v], L, mid, x);
	return sum[lc[v]] + findrank (rc[v], mid + 1, R, x);
} 

int findkth (const int v, const int L, const int R, const int num) {
	if (L == R) return L;
	const int mid = L + R >> 1, t = sum[lc[v]];
	if (t >= num) return findkth (lc[v], L, mid, num);
	return findkth (rc[v], mid + 1, R, num - t);
} 找第k大

int main () {
	read (n);
	int i; for (i = 1; i <= n; ++i) {
		read (s[i].be), read (s[i].op), read (s[i].x);
		if (s[i].op != 4) a[++m] = s[i].x;
	} //离散化过程
	sort (a + 1, a + m + 1);
	m = unique (a + 1, a + m + 1) - (a + 1);
	for (i = 1; i <= n; ++i) {
		switch (s[i].op) {
			case 1 : {
				s[i].x = lower_bound (a + 1, a + m + 1, s[i].x) - a;
				Insert (rt[s[i].be], rt[i], 1, m, s[i].x, 1);
				break;
			}
			case 2 : {
				s[i].x = lower_bound (a + 1, a + m + 1, s[i].x) - a;
				if (exi (rt[s[i].be], 1, m, s[i].x)) Insert (rt[s[i].be], rt[i], 1, m, s[i].x, -1);
				else rt[i] = rt[s[i].be];
				break;
			}
			case 3 : {
				s[i].x = lower_bound (a + 1, a + m + 1, s[i].x) - a;
				rt[i] = rt[s[i].be];
				write (findrank (rt[i], 1, m, s[i].x)), putc ('\n');
				break;
			}
			case 4 : {
				rt[i] = rt[s[i].be];
				write (a[findkth (rt[i], 1, m, s[i].x)]), putc ('\n');
				break;
			}
			case 5 : {
				s[i].x = lower_bound (a + 1, a + m + 1, s[i].x) - a;
				rt[i] = rt[s[i].be];
				int t = findrank (rt[i], 1, m, s[i].x);
				if (t == 1) put (npre);
				else write (a[findkth (rt[i], 1, m, t - 1)]), putc ('\n');
				break;
			}
			case 6 : {
				s[i].x = lower_bound (a + 1, a + m + 1, s[i].x) - a;
				rt[i] = rt[s[i].be];
				if (s[i].x == m) put (nnxt);
				else {
					int t = findrank (rt[i], 1, m, s[i].x + 1);
					if (t == sum[rt[i]] + 1) put (nnxt);
					else write (a[findkth (rt[i], 1, m, t)]), putc ('\n');
				}
				break;
			}
		}
	}
	return 0;
}
```

---

## 作者：南城忆潇湘 (赞：4)

用的是可持久化$01trie$  
想法之类的和前面的$trie$差不多，但是我是写的递归，可能会慢一些，但是比起普通非递归的就好写多了。  （也就少了几行）

顺带一提，虽然它的时间复杂度是$O(n*logk)$，$k$为值域，在这道题目中，也就比$O(n*logn)$大了2倍的常数而已。。如果不要求强制在线的话，可以离散化将时间复杂度优化到$O(n*logn)$。比如这题就可以~ ~~虽然在这题中离散化后的常数比不离散化的常数还要大~~

主函数的代码可能有点丑= = ，应该还是看得过去的，会有注释(做了防抄袭处理,仔细看应该看得出来)  
~~特别好背诵~~的代码：

```cpp
#include<bits/stdc++.h>
#define P 1000000000
#define MAXN 600010
#define ri register int
using namespace std;

int cnt,chu=30;
int son[MAXN*32][2],size[MAXN*32];
int t[MAXN];

int ins(int dep,int pre,const int key){
    if(dep==-1){   size[++cnt]=size[pre]+1;    return cnt;    }//到底了
    ri now=++cnt,nxt=(bool)(key&(1<<dep));//新建节点
    son[now][0]=son[pre][0],son[now][1]=son[pre][1],size[now]=size[pre]+1;//复制一份
    son[now][nxt]=ins(dep-1,son[pre][nxt],key);//继续插入
    return now;
}

int del(int dep,int pre,const int key){
    ri now=++cnt,nxt=(bool)(key&(1<<dep));
    son[now][0]=son[pre][0],son[now][1]=son[pre][1],size[now]=size[pre]-1;//复制一份
    if(size[son[pre][nxt]]<=1){     son[now][nxt]=0;       return now;    }//剪枝，删到底了
    son[now][nxt]=del(dep-1,son[pre][nxt],key);//向下删除
    return now;
}

int frank(int dep,int now,const int key){
    if(now==0)  return 0;
    ri nxt=(bool)(key&(1<<dep));
    return frank(dep-1,son[now][nxt],key)+(nxt?size[son[now][0]]:0);//求有多少个比key小的数
}

int atrank(int dep,int now,int key){
    if(now==0)  return 0;
    if(key>size[son[now][0]]&&son[now][1])  return atrank(dep-1,son[now][1],key-size[son[now][0]])|(1<<dep);//比当前大
    else return atrank(dep-1,son[now][0],key);//比当前小
}

int main(){
    int n,v,opt,x,tmp; 
    cin>>n;
    for(int i=1;i<=n;i++){
        scanf("%d%d%d",&opt,&v,&x);
        if(opt==1)  t[i]=ins(chu,t[v],x+P);
        if(opt==2){
            if(atrank(chu,t[v],frank(chu,t[v],x+P)+1)-P!=x) t[i]=t[v];
            else t[i]=del(chu,t[v],x+P);
        }
        if(opt==3)  cout<<(int)(frank(chu,t[v],x+P)+1)<<endl,t[i]=t[v];
        if(opt==4)  cout<<(int)(atrank(chu,t[v],x)-P)<<endl,t[i]=t[v];
        if(opt==5){
            tmp=frank(chu,t[v],x+P);
            if(tmp==0)  puts("-2147483647");
            else tmp=atrank(chu,t[v],tmp),tmp-=P,cout<<tmp<<endl;    t[i]=t[v];
        }
        if(opt==6){
            tmp=frank(chu,t[v],x+P)+1;
            if((x+P==atrank(chu,t[v],tmp))) tmp++;
            if(tmp>size[t[v]])    puts("2147483647");
            else tmp=atrank(chu,t[v],tmp),tmp-=P,cout<<tmp<<endl;    t[v]=t[i];
        }
    }
    system("pause");
    return 0;
}
```


---

## 作者：sodak (赞：3)


平衡树的可持久化，我们可以直接用线段树来实现，通过可持久化来实现对历史版本的修改与查询，其实我感觉和可持久化数组的感觉差不多

### 对值域开+动态开点

开始调了好长时间，一直28分，后来发现，竟然可以删除不存在的节点？？？？（大雾），这里我们只需要进行一下判断，如过加当前节点的size为0,则不进行删除操作，但是还是觉得这种方法比较好写，码量少一些

#### 代码如下

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=5e5+10;
int size[maxn*30];
int ls[maxn*30],rs[maxn*30],root[maxn];
int nodecnt;
int get(int rt){
	++nodecnt;
	ls[nodecnt]=ls[rt];
	rs[nodecnt]=rs[rt];
	size[nodecnt]=size[rt];
	return nodecnt;
}
void add(int &rt,int l,int r,int x,int v){
	if(rt!=0)rt=get(rt);
	else if(rt==0)rt=++nodecnt;
	size[rt]+=v;
	if(l==r){
		if(size[rt]<0)size[rt]=0;	
		return;
	}
	int mid=(l+r)>>1;
	if(x<=mid)add(ls[rt],l,mid,x,v);
	else add(rs[rt],mid+1,r,x,v);
	size[rt]=size[ls[rt]]+size[rs[rt]];
}
int getnum(int rt,int l,int r,int x){
	if(size[rt]==0||x>r){
		return size[rt];
	}
	int mid=(l+r)>>1;
	if(x<=mid)return getnum(ls[rt],l,mid,x);
	return size[ls[rt]]+getnum(rs[rt],mid+1,r,x);
}
int getk(int rt,int l,int r,int k){
	if(l==r)return l;
	int mid=(l+r)>>1;
	if(size[ls[rt]]>=k)return getk(ls[rt],l,mid,k);
	return getk(rs[rt],mid+1,r,k-size[ls[rt]]);
}
signed main(){
	int n;
	scanf("%lld",&n);
	root[0]=++nodecnt;
	for(int i=1;i<=n;i++){
		int rt,op,x;
		scanf("%lld%lld%lld",&rt,&op,&x);
		root[i]=root[rt];
		if(op==1){
			add(root[i],-1e9,1e9+1,x,1);
		}
		if(op==2){
			add(root[i],-1e9,1e9+1,x,-1);
		}
		if(op==3){
			printf("%lld\n",getnum(root[i],-1e9,1e9+1,x)+1);
		}
		if(op==4){
			printf("%lld\n",getk(root[i],-1e9,1e9+1,x));
		}
		if(op==5){
			int ans=getnum(root[i],-1e9,1e9+1,x);
			if(ans==0)printf("%d\n",-0x7fffffff);
			else printf("%lld\n",getk(root[i],-1e9,1e9+1,ans));
		}
		if(op==6){
			int ans=getk(root[i],-1e9,1e9+1, getnum(root[i],-1e9,1e9+1,x +1)+1);
			if(ans==1e9+1)printf("%d\n",0x7fffffff);
			else printf("%lld\n",ans);
		}
	}

}

```

### 对离散化数组开线段树

我们这里可以考虑离线操作，把除了操作4以外，其他的涉及数值放到一个数组里，离散化一下，再对每一个记录操作来进行实现

#### 代码如下

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=5e5+10;
int nodecnt;
struct node{
	int v,op,x;
}temp[maxn];
int tmp[maxn],tail;
int rs[maxn*32],ls[maxn*32],size[maxn*32],root[maxn];
int n;
void build(int &curr, int l, int r) {
    curr = ++nodecnt;
    if (l == r) return;
    int mid = (l + r) >> 1;
    build(ls[curr], l, mid);
    build(rs[curr], mid + 1, r);
}
int get(int rt){
	nodecnt++;
	ls[nodecnt]=ls[rt];
	rs[nodecnt]=rs[rt];
	size[nodecnt]=size[rt];
	return nodecnt;
}
void add(int &rt,int l,int r,int x,int v){
	rt=get(rt);
	if(l==r){
		size[rt]+=v;
		if(size[rt]<0)size[rt]=0;
		return;
	}
	int mid=(l+r)>>1;
	if(x<=mid)add(ls[rt],l,mid,x,v);
	else add(rs[rt],mid+1,r,x,v);
	size[rt]=size[ls[rt]]+size[rs[rt]];
}

int querysum(int rt,int l,int r,int x){
	if(x<l)return 0;
	if(x>=r)return size[rt];
	int mid=(l+r)>>1;
	return querysum(ls[rt],l,mid,x)+querysum(rs[rt],mid+1,r,x);
}

int querykth(int rt,int l,int r,int k){
	if(l==r)return l;
	int mid=(l+r)>>1;
	if(k<=size[ls[rt]])return querykth(ls[rt],l,mid,k);
	else return querykth(rs[rt],mid+1,r,k-size[ls[rt]]);
}

int querypre(int v,int x){
	int ans=querysum(root[v],1,tail,x-1);
	if(!ans)return -2147483647;
	else return tmp[querykth(root[v],1,tail,ans)];

}
int querynex(int v,int x){
	int ans=querysum(root[v],1,tail,x);
	if(ans>=size[root[v]])return 2147483647;
	else return tmp[querykth(root[v],1,tail,ans+1)];
}
int main(){
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d%d%d",&temp[i].v,&temp[i].op,&temp[i].x);
		if(temp[i].op!=4){
			tmp[++tail]=temp[i].x;
		}
	}
	sort(tmp+1,tmp+tail+1);
	tail=unique(tmp+1,tmp+tail+1)-(tmp+1);
	build(root[0],1,tail);
	for(int i=1;i<=n;i++){
		int v=temp[i].v,op=temp[i].op,x=temp[i].x;
		if(op!=4){x=lower_bound(tmp+1,tmp+tail+1,x)-tmp;}
		root[i]=root[v];
		if(op==1){	
			add(root[i],1,tail,x,1);
		}
		if(op==2){
			add(root[i],1,tail,x,-1);
		}
		if(op==3){
			printf("%d\n",querysum(root[i],1,tail,x-1)+1);
		}
		if(op==4){
			printf("%d\n",tmp[querykth(root[i],1,tail,x)]);
		}
		if(op==5){
			printf("%d\n",querypre(i,x));
		}
		if(op==6){
			printf("%d\n",querynex(i,x));
		}
	}
	
}



```

---

## 作者：pyqpyq (赞：3)

话说你们是对指针版的主席树有什么意见吗？

为什么题解里面的主席树没一个是用指针的？

那我就发一波吧……

20200121 UPD:更正了一个严重错误
# 大致思路
前置芝士：[主席树](https://www.luogu.com.cn/problem/P3834)

~~众所周知~~权值线段树可以维护一个可重集，并在 $O(logn)$ 的时间复杂度内完成全局第 $k$ 大、前缀和、插入、删除等事情，可以替代一些普通平衡树。

所以我们可以写一棵权值线段树来完成此题。每个节点维护的是当前节点所代表的**数值区间**的数的个数。

由于题目要求可持久化，所以我们可以写主席树节省空间，不必每个操作再建一颗。

数据范围 $|x_i|\le10^9$ 告诉我们要离散化（当然可以写动态开点权值线段树，然而我不会……）
# 代码分析
~~懒得写注释直接讲吧~~
## 变量定义
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node
{
	int data;
	node*left,*righ;
}*root[500011];
struct opts
{
	int numb,from,opti,frnu,gonu;
} czli[500011];
int n,a,b,stef[500011];
bool cmp1(opts a,opts b)
{
	return a.frnu<b.frnu;
}
bool cmp2(opts a,opts b)
{
	return a.numb<b.numb;
}
```

```node``` 是权值线段树的节点。```data``` 是此节点维护的**数值**区间内的数的个数，```left``` 和 ```righ``` 是左右子节点的指针。```root``` 是每次操作后树根的指针。

```opts``` 用来离散化。```numb``` 是操作序号，```from```、```opti``` 和 ```frnu``` 是题目给出的 $v_i$、$opt_i$ 和 $x_i$，```gonu``` 是离散化后此结构体代表的数。

```n``` 就是题目给出的 $n$，```a``` 和 ```b``` 是离散化后 ```gonu``` 的最大值和最小值（所以 ```a``` 衡为 $1$），```stef``` 维护每个 ```gonu``` 所代表的 ```frnu```。

```cmp1``` 和 ```cmp2``` 在以后排序中使用。
## 离散化
```cpp
scanf("%d",&n);
for(int i=1; i<=n; czli[i].numb=++i)
	scanf("%d%d%d",&czli[i].from,&czli[i].opti,&czli[i].frnu);
sort(czli+1,czli+n+1,cmp1);
for(int i=1; i<=n; ++i)
	stef[czli[i].gonu=czli[i-1].gonu+(czli[i].frnu!=czli[i-1].frnu)]=czli[i].frnu;
root[0]=build(a=czli[1].gonu,b=czli[n].gonu);
sort(czli+1,czli+n+1,cmp2);
```
~~大家都会吧那我不说了。~~

可能有人会问 ```build``` 是什么，它在后面：
## 建树
```cpp
node*build(int l,int r)
{
	node*s=new node;
	s->data=0;
	if(l==r)
		s->left=s->righ=NULL;
	else if(l!=r)
	{
		s->left=build(l,l+r>>1);
		s->righ=build((l+r>>1)+1,r);
	}
	return s;
}
```
由于一开始可重集里没数，所以这里建了一颗 ```data``` 全是 $0$ 的树。

因为我们的结构体里没存节点代表的**数值**区间，所以这里以及接下来的**数值**区间都由传参的形式给出。
## 操作1&2
```cpp
inline int maxn(int a,int b)
{
	return a>b?a:b;
}
node*opt1_2(node*f,int x,int l,int r,int k)
{
	node*s=new node;
	if(l==x&&x==r)
	{
		s->left=s->righ=NULL;
		s->data=maxn(f->data+k,0);
	}
	else if(l<=x&&x<=l+r>>1)
	{
		s->left=opt1_2(f->left,x,l,l+r>>1,k);
		s->righ=f->righ;
		s->data=s->left->data+s->righ->data;
	}
	else if((l+r>>1)+1<=x&&x<=r)
	{
		s->left=f->left;
		s->righ=opt1_2(f->righ,x,(l+r>>1)+1,r,k);
		s->data=s->left->data+s->righ->data;
	}
	return s;
}
```
我们会发现操作 $1$ 和操作 $2$ 十分像，所以我们可以把它们合并到一起，以 ```k``` 区分，```k``` 为 $1$ 时为操作 $1$，```k``` 为 $-1$ 时为操作 $2$。

第 $1$ 个 ```if``` 处理递归到叶节点，第 $2$ 个 ```else if``` 处理往左子树递归，第 $3$ 个 ```else if``` 处理往右子树递归。（下同）

由于有时操作 $2$ 的数可以不存在，此时 ```s``` 的 ```data``` 为 $0$，所以发现叶节点的 ```data``` 为 $-1$
时要及时赋为 $0$。

```f``` 是原树上的此时要建的节点所对应的节点的指针。不理解的可以看图：
![主席树](https://cdn.luogu.com.cn/upload/image_hosting/kyahf30y.png)

再不理解就去做[模板](https://www.luogu.com.cn/problem/P3834)吧……
## 操作3&4
```cpp
int opt3(node*f,int x,int l,int r)
{
	if(l==x&&x==r)
		return 1;
	else if(l<=x&&x<=l+r>>1)
		return opt3(f->left,x,l,l+r>>1);
	else if((l+r>>1)+1<=x&&x<=r)
		return f->left->data+opt3(f->righ,x,(l+r>>1)+1,r);
}
int opt4(node*f,int x,int l,int r)
{
	if(l==r)
		return l;
	else if(1<=x&&x<=f->left->data)
		return opt4(f->left,x,l,l+r>>1);
	else if(f->left->data+1<=x&&x<=f->data)
		return opt4(f->righ,x-f->left->data,(l+r>>1)+1,r);
}
```
注意 ```opt3``` 的返回值是在以 ```f``` 为根的子树中查询 ```x``` 的排名。 

而且 ```opt4``` 中的 ```x``` 表示的是在以 ```f``` 为根的子树中查找第 $x$ 大的数，而非全局。
## 操作5&6
```cpp
int help(node*f,int x,int l,int r)
{
	if(l==x&&x==r)
		return f->data;
	else if(l<=x&&x<=l+r>>1)
		return help(f->left,x,l,l+r>>1);
	else if((l+r>>1)+1<=x&&x<=r)
		return help(f->righ,x,(l+r>>1)+1,r);
}
int opt5(node*f,int x,int l,int r)
{
	int s=opt3(f,x,l,r)-1;
	if(s==0)
		return INT_MIN;
	else
		return opt4(f,s,l,r);
}
int opt6(node*f,int x,int l,int r)
{
	int s=opt3(f,x,l,r)-1,p=help(f,x,l,r);
	if(s==r)
		return INT_MAX;
	else
		return opt4(f,s+p+1,l,r);
}
```
```help``` 用来找 ```x``` 出现了多少次。

具体思路是找到此数的排名，然后返回比它排名小或大的数。

（话说我刚开始把操作 $6$ 写成[这样](https://www.luogu.com.cn/record/30259012)和[这样](https://www.luogu.com.cn/record/30297820)$AC$了？管理加强一下数据吧……）
## 汇总
```cpp
int k;
for(int i=1; i<=n; ++i)
{
	if(czli[i].opti==1)
		root[i]=opt1_2(root[czli[i].from],czli[i].gonu,a,b,1);
	else if(czli[i].opti==2)
		root[i]=opt1_2(root[czli[i].from],czli[i].gonu,a,b,-1);
	else if(czli[i].opti==3)
		printf("%d\n",opt3(root[i]=root[czli[i].from],czli[i].gonu,a,b));
	else if(czli[i].opti==4)
		printf("%d\n",stef[opt4(root[i]=root[czli[i].from],czli[i].frnu,a,b)]);
	else if(czli[i].opti==5)
		printf("%d\n",(k=opt5(root[i]=root[czli[i].from],czli[i].gonu,a,b))==INT_MIN?INT_MIN:stef[k]);
	else if(czli[i].opti==6)
		printf("%d\n",(k=opt6(root[i]=root[czli[i].from],czli[i].gonu,a,b))==INT_MAX?INT_MAX:stef[k]);
}
```
也不用说了吧。

注意操作 $4$ 的 $x$ 是 ```frnu``` 而不是 ```gonu``` ，我就在这被坑了。（其实操作 $4$ 压根不用离散化，只是我懒不想单独拿出来。）
# 最后
完整代码请自己把上面的合起来，这里不放了。

指针的优点是符合自然语言习惯，使用方便（至少我这么觉得）。

缺点是用 ```new``` 开节点常数大（听说），但过这道板子绰绰有余了。（我管最慢点 $1.67s$ 叫绰绰有余？）

完结撒花\\(^o^)/ 

---

## 作者：ustze (赞：3)

来一份可持久化01trie的题解吧  
虽然已经有一篇01trie的题解了，但个人觉得那一篇题解还有很大改进的地方（主要是代码复杂度）  
主要思路就是用类似主席树的方法更新即可，适当利用位运算可以减少代码量 （PS:之前的题解代码行数是我的两倍  
时空复杂度都是$O(nlogv)$，虽然不能处理区间操作，但是短呀，而且可以处理有关异或的问题，如P4735  
代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+5,inf=1e9;
inline int read(){
    int s=0,f=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
    while(isdigit(ch)) s=s*10+ch-'0',ch=getchar();
    return s*f;
}
int tot=0;
int rt[N],ch[N*32][2],siz[N*32];
inline void ins(int &rt,int pre,int v){
    v=v+inf;rt=++tot;
    siz[rt]=siz[pre]+1;
    int prt=rt;
    for(int i=31;i>=0;i--){
        int t=(v>>i)&1;
        ch[prt][t]=++tot;
        ch[prt][t^1]=ch[pre][t^1];
        prt=ch[prt][t],pre=ch[pre][t];
        siz[prt]=siz[pre]+1;
    }
}
inline void del(int &rt,int pre,int v){
    v+=inf;
    int p=pre;
    for(int i=31;i>=0;i--){
        int t=(v>>i)&1;
        p=ch[p][t];
        if(!siz[p]) {rt=pre;return;}
    }
    rt=++tot;int prt=rt;
    siz[rt]=siz[pre]-1;
    for(int i=31;i>=0;i--){
        int t=(v>>i)&1;
        ch[prt][t]=++tot;
        ch[prt][t^1]=ch[pre][t^1];
        prt=ch[prt][t],pre=ch[pre][t];
        siz[prt]=siz[pre]-1;
    }
}
inline int rnk(int rt,int x){
    x+=inf;int ans=0;
    for(int i=31;i>=0;i--){
        if((x>>i)&1) ans+=siz[ch[rt][0]],rt=ch[rt][1];
        else rt=ch[rt][0];
    }
    return ans;
}
inline int kth(int rt,int x){
    int ans=0;
    for(int i=31;i>=0;i--){
        if(x>siz[ch[rt][0]]) ans|=(1<<i),x-=siz[ch[rt][0]],rt=ch[rt][1];
        else rt=ch[rt][0];
    }
    return ans-inf;
}
int main(){
    ins(rt[0],rt[0],-inf);
    ins(rt[0],rt[0],inf);
    int n=read();
    int v,opt,x;
    for(int i=1;i<=n;i++){
        v=read(),opt=read(),x=read();
        if(opt==1) ins(rt[i],rt[v],x);
        else if(opt==2) del(rt[i],rt[v],x);
        else if(opt==3) rt[i]=rt[v],printf("%d\n",rnk(rt[i],x));
        else if(opt==4) rt[i]=rt[v],printf("%d\n",kth(rt[i],x+1));
        else if(opt==5){
        	rt[i]=rt[v];
        	int t=kth(rt[i],rnk(rt[i],x));
        	if(t!=-inf) printf("%d\n",t);
        	else puts("-2147483647"); 
        }else {
            rt[i]=rt[v];
            int t=kth(rt[i],rnk(rt[i],x+1)+1);
            if(t!=inf) printf("%d\n",t);
        	else puts("2147483647"); 
        }
    }
    return 0;
}
```	

---

## 作者：damocris (赞：2)

   这个题目没有强制在线的要求，考虑离线算法。由于所有的询问构成一个树，因此只需按照询问的逻辑关系加上有向边可以。对于查询排名，前驱，后继时，考虑最快的权值树状数组的解法。
   
   因此，需要首先读入所有除操作4之外的数，然后排序做离散化操作，建立一颗权值树状数组。
   
   对于操作1，需要在权值树状数组加入+1的操作，然后回溯时进行-1的操作。
   
   对于操作2，由于删除的数据可能不存在，因此需要先查询对应权值树状数组在该点的权值是否为0。如果不是0，需要在权值树状数组加入-1的操作，然后回溯时进行+1的操作。如果为0则忽略该次操作。
   
   对于操作3，简单一个前缀和即可搞定。
   
   对于操作4，需要用倍增求一个给定的前缀和对应的位置。如果该位置的权值不为0，那么输出原始数据。否则忽略，说明不存在。
   
   操作5与操作6可以通过前面的操作组合出来，注意找前驱与找后继的相关细节是不同的，主要是考虑到某些位置的权值为0。并且注意，找到位置后，都需要查看相应位置的权值是否为0，如果为0，需要输出INT_MIN or INT_MAX。
   
   离线权值树状数据最大的一个测试点大概是370ms，最大消耗内存25MB，比各种可持久平衡树，离线平衡树的做法都要快并且省内存。
   
   代码如下：
   ```cpp
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <algorithm>

using namespace std;

#define LOCAL 0
#define MAXN 500000

const int32_t kInf = (1u<<31)-1;

struct Edge {
  int vertex;
  int next;
};

int buffer[MAXN+1];
int cnt;
int bit_tree[MAXN+1];
uint32_t query_id = 0;  //0 is not used
//vertex id is from 0~n
int head[MAXN+1];
Edge edge[MAXN+1];  //directed tree
int ans[MAXN+1];
int op[MAXN+1];
int val[MAXN+1];

int PrefixSum(int index)
{
  int sum = 0;
  while (index!=0) {
    sum += bit_tree[index];
    index -= (index & (-index));
  }
  return sum;
}

void UpdateSum(int n, int index, int add)
{
  while (index <= n) {
    bit_tree[index] += add;
    index += (index & (-index));
  }
}

int GetValue(int index)
{
  int val;
  int lca;
  lca = index - (index & (-index));
  val = bit_tree[index];
  --index;
  while (index!=lca) {
    val -= bit_tree[index];
    index -= (index & (-index));
  }
  return val;
}

int FindIndex(int n, int prefix_sum)
{
  int index, try_index, mask;
  uint32_t num = n;
  num |= num>>1;
  num |= num>>2;
  num |= num>>4;
  num |= num>>8;
  num |= num>>16;
  mask = num - (num>>1);
  index = 0;
  while (mask != 0) {
    try_index = index+mask;
    if (try_index<=n && bit_tree[try_index]<prefix_sum) {
      prefix_sum -= bit_tree[try_index];
      index = try_index;
    }
    mask >>= 1;
  }
  return index+1;
}

//edge x->y
void AddEdge(int x, int y)
{
  ++query_id;
  edge[query_id].vertex = y;
  edge[query_id].next = head[x];
  head[x] = query_id;
}

void PersistentBitQuery(int x)
{
  int idx, y, index;
  uint32_t rank;
  int freq;
  idx = head[x];
  while (idx!=0) {
    y = edge[idx].vertex;
    switch (op[y]) {
    case 1:
      index = lower_bound(buffer, buffer+cnt, val[y]) - buffer;
      ++index;  //index start from 1
      UpdateSum(cnt, index, 1);
      break;
    case 2:
      index = lower_bound(buffer, buffer+cnt, val[y]) - buffer;
      ++index;  //index start from 1
      freq = GetValue(index);
      if (freq != 0) {
        UpdateSum(cnt, index, -1);
      }
      break;
    case 3:
      index = lower_bound(buffer, buffer+cnt, val[y]) - buffer;
      rank = PrefixSum(index);
      ans[y] = rank+1;
      break;
    case 4:
      index = FindIndex(cnt, val[y]);
      freq = GetValue(index);
      if (freq!=0) {
        --index;
        ans[y] = buffer[index];
      }
      break;
    case 5:
      index = lower_bound(buffer, buffer+cnt, val[y]) - buffer;
      rank = PrefixSum(index);
      index = FindIndex(cnt, rank);
      freq = GetValue(index);
      if (freq!=0) {
        --index;
        ans[y] = buffer[index];
      } else {
        ans[y] = -kInf;
      }
      break;
    case 6:
      index = lower_bound(buffer, buffer+cnt, val[y]) - buffer;
      rank = PrefixSum(index+1);
      index = FindIndex(cnt, rank+1);
      freq = GetValue(index);
      if (freq!=0) {
        --index;
        ans[y] = buffer[index];
      } else {
        ans[y] = kInf;
      }
      break;
    }
    PersistentBitQuery(y);
    switch (op[y]) {
    case 1:
      UpdateSum(cnt, index, -1);
      break;
    case 2:
      if (freq != 0) {
        UpdateSum(cnt, index, 1);
      }
      break;
    default:
      break;
    }
    idx = edge[idx].next;
  }
}

int ReadInteger(void)
{
  int x = 0, sign = 1;
  int ch;
  ch = getchar();
  while (ch<'0' || ch>'9') {
    if (ch == '-') {
      sign = -1;
    }
    ch = getchar();
  }
  while (ch>='0' && ch<='9') {
    x = x*10 + ch-'0';
    ch = getchar();
  }
  return x*sign;
}

int main(void)
{
#if LOCAL
  freopen("test.in", "r", stdin);
  freopen("test.out", "w", stdout);
#endif
  int n;
  int i, j;
  n = ReadInteger();
  memset(head, 0, (n+1)*sizeof(head[0]));
  query_id = 0;
  edge[query_id].vertex = 0;
  edge[query_id].next = 0;
  for (i=1; i<=n; ++i) {
    j = ReadInteger();
    op[i] = ReadInteger();
    val[i] = ReadInteger();
    if (op[i]!=4) {
      buffer[cnt] = val[i];
      ++cnt;
    }
    AddEdge(j, i);
  }
  sort(buffer, buffer+cnt);
  cnt = unique(buffer, buffer+cnt)-buffer;
  memset(bit_tree, 0, (1+cnt)*sizeof(bit_tree[0]));
  PersistentBitQuery(0);
  for (i=1; i<=n; ++i) {
    if (op[i]!=1 && op[i]!=2) {
      printf("%d\n", ans[i]);
    }
  }
  return 0;
}
```


---

## 作者：c201904 (赞：1)

```cpp
/*
这道题一看可以知道是平衡树+持久化.如果是持久化，
那么我们就要保存历史信息，每次修改logn个点,所以内存要靠2nlogn.
split是把以i为根节点的子树分成两部分，一部分小于等于k，一部分大于k，必须保证其BST所有的性质
merge是合并以x为根节点和以y为根节点的两颗子树。
*/
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+5;
struct node{
    int l,r;
    int v,rd,sum;
}a[N*50];
int cnt;
void update(int i){
    if(!i)return ;
    a[i].sum=a[a[i].l].sum+a[a[i].r].sum+1;
}
int newnode(int x){
    ++cnt;
    a[cnt].l=a[cnt].r=0;
    a[cnt].sum=1;a[cnt].v=x;
    a[cnt].rd=rand();
    return cnt;
}
int merge(int x,int y){//合并操作，按照treap的rd的优先级来合并(小跟堆或大根堆都行)
//这里是大根堆 
    if(!x||!y)return x+y;
    if(a[x].rd>a[y].rd){
        int p=++cnt;a[p]=a[x];
        a[p].r=merge(a[p].r,y);
        update(p);return p;
    }
    else {
        int p=++cnt;a[p]=a[y];
        a[p].l=merge(x,a[p].l);
        update(p);return p;
    }
}
void split(int now,int k,int &x,int &y){//把小于等于k的数放x子树里面，大于k的放y子树里面 
    if(now==0){x=y=0;return ;}
    if(a[now].v<=k){
        x=++cnt;a[x]=a[now];
        split(a[x].r,k,a[x].r,y);
        update(x);
    }
    else {
        y=++cnt;a[y]=a[now];
        split(a[y].l,k,x,a[y].l);
        update(y);
    }
}
void insert(int &root,int v){//插入一个新结点 
     int x=0,y=0,z=0;
     split(root,v-1,x,y);
     z=newnode(v);
     root=merge(merge(x,z),y);
}
void del(int &root,int v){//删除一个结点
    int x=0,y=0,z=0;
    split(root,v,x,z);
    split(x,v-1,x,y);
    y=merge(a[y].l,a[y].r);
    root=merge(merge(x,y),z);
}
int rank_value(int i,int k){
    if(k==a[a[i].l].sum+1)return a[i].v;
    if(k<=a[a[i].l].sum)return rank_value(a[i].l,k);
    return rank_value(a[i].r,k-a[a[i].l].sum-1);
}
int kth_rank(int &root,int v){//查询排名为x的数
    int x,y;
    split(root,v-1,x,y);
    int ans=a[x].sum+1;
    root=merge(x,y);
    return ans;
}
int pre(int &root,int v){//求前驱 
    int x,y,k;
    split(root,v-1,x,y);
    if(x==0)return -2147483647;
    k=a[x].sum;
    int ans=rank_value(x,k);
    root=merge(x,y);
    return ans;
}
int nex(int &root,int v){//求后驱
    int x,y,ans;
    split(root,v,x,y);
    if(y==0)return 2147483647;
    ans=rank_value(y,1);
    root=merge(x,y);
    return ans;
}
int n,root[N];
int main(){
    scanf("%d",&n);
    int x,y,op;
    for(int i=1;i<=n;i++){
    	scanf("%d%d%d",&x,&op,&y);
    	root[i]=root[x];
    	if(op==1)insert(root[i],y);
    	if(op==2)del(root[i],y);
    	if(op==3)printf("%d\n",kth_rank(root[i],y));
    	if(op==4)printf("%d\n",rank_value(root[i],y));
    	if(op==5)printf("%d\n",pre(root[i],y));
    	if(op==6)printf("%d\n",nex(root[i],y));
    }
    return 0;
}

```

---


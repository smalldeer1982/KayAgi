# [NOI2006] 最大获利

## 题目描述

新的技术正冲击着手机通讯市场，对于各大运营商来说，这既是机遇，更是挑战。THU 集团旗下的 CS&T 通讯公司在新一代通讯技术血战的前夜，需要做太多的准备工作，仅就站址选择一项，就需要完成前期市场研究、站址勘测、最优化等项目。

在前期市场调查和站址勘测之后，公司得到了一共 $N$ 个可以作为通讯信号中转站的地址，而由于这些地址的地理位置差异，在不同的地方建造通讯中转站需要投入的成本也是不一样的，所幸在前期调查之后这些都是已知数据：建立第 $i$ 个通讯中转站需要的成本为 $P_i$（$1 \leq i \leq N$）。

另外公司调查得出了所有期望中的用户群，一共 $M$ 个。关于第 $i$ 个用户群的信息概括为 $A_i$，$B_i$ 和 $C_i$ ：这些用户会使用中转站 $A_i$ 和中转站 $B_i$ 进行通讯，公司可以获益 $C_i$。（$1 \leq i \leq M$，$1 \leq A_i, B_i \leq N$）

THU 集团的 CS&T 公司可以有选择的建立一些中转站（投入成本），为一些用户提供服务并获得收益（获益之和）。那么如何选择最终建立的中转站才能让公司的净获利最大呢？（净获利 = 获益之和 – 投入成本之和）


## 说明/提示

样例：选择建立 $1,2,3$ 号中转站，则需要投入成本 $6$，获利为 $10$，因此得到最大收益 $4$。

$100\%$ 的数据中：$N \leq 5\,000$，$M \leq50\,000$，$0 \leq C_i \leq 100$，$0 \leq P_i  \leq 100$。


## 样例 #1

### 输入

```
5 5
1 2 3 4 5
1 2 3
2 3 4
1 3 3
1 4 2
4 5 3```

### 输出

```
4```

# 题解

## 作者：不存在之人 (赞：27)

什么是最大权闭合子图：

先解释一下有向图的闭合图：闭合图内任意点的任意后继也一定还在闭合图中。

物理意义：事物间依赖关系:一个事件要发生，它需要的所有前提也都一定要发生。

最大权闭合图：点权之和最大的闭合图

最大权闭合图构图方法：

1.增加源s汇t 

2.源s连接原图的正权点，容量为相应点权

3.原图的负权点连接汇t，容量为相应点权的相反数

4.原图边的容量为正无限。


最大权闭合图 解决：

闭合图V的权为正权点总和减去对应割的容量

当割最小时，闭合图权最大

NOI2006 最大获利：

1.将原题中的边和点都看成事件。

2.边事件依赖边的两个端点事件的发生。这与闭合图的性质相似。

3.构造性地，将边转化为点事件。

4.将所有边都转化为事件点，原图便转化为一个二分图。

5.解决该二分图的最大权闭合图即可
```cpp
#include<cmath>  
#include<cstdio>  
#include<cstring>  
#include<iostream>  
#include<algorithm>  
using namespace std;  
const int N=120005;  
const int M=400005;  
const int inf=2100000000;  
int n,m,S,T;  
int from[M],to[M],nxt[M],w[M],lj[N],cnt=-1;  
void insert(int f,int t,int p)  
{  
    to[++cnt]=t;  
    nxt[cnt]=lj[f];  
    lj[f]=cnt;  
    w[cnt]=p;  
    to[++cnt]=f;  
    nxt[cnt]=lj[t];  
    lj[t]=cnt;  
    w[cnt]=0;  
}  
int d[N],q[N*2];  
bool bfs()  
{  
    memset(d,0,sizeof(d));  
    int h=1,t=1,x,j;  
    q[1]=S,d[S]=1;  
    while(h!=t+1)  
    {  
        x=q[h];  
        for(int i=lj[x];i>=0;i=nxt[i])  
        if(w[i]&&!d[to[i]])  
        {  
            d[to[i]]=d[x]+1;  
            q[++t]=to[i];  
            if(t==N) t=0;  
        }  
        if(++h==N) h=0;  
    }  
    if(d[T]) return true;  
    return false;   
}  
int dfs(int x,int v)  
{  
    if(x==T||v==0) return v;  
    int f,ret=0;  
    for(int i=lj[x];i>=0;i=nxt[i])  
    if(d[to[i]]==d[x]+1)  
    {  
        f=dfs(to[i],min(w[i],v));  
        w[i]-=f;  
        w[i^1]+=f;  
        v-=f;  
        ret+=f;  
        if(v==0) break;  
    }  
    return ret;  
}  
int main()  
{  
    scanf("%d%d",&n,&m);  
    T=m+n+1,S=0;  
    int x,y,p;  
    for(int i=0;i<=T;i++) lj[i]=-1;  
    for(int i=1;i<=n;i++)  
    {  
        scanf("%d",&x);  
        insert(0,i,x);  
    }  
    int sum=0,ans=0;  
    for(int i=1;i<=m;i++)  
    {  
        scanf("%d%d%d",&x,&y,&p);  
        insert(n+i,T,p);  
        insert(x,n+i,inf);  
        insert(y,n+i,inf);  
        sum+=p;  
    }  
    while(bfs()) ans+=dfs(S,inf);  
    printf("%d",sum-ans);  
}
```

---

## 作者：attack (赞：22)

最大权闭合子图的基础应用

源点向所有用户连流量为收益的边

所有中转站向汇点连流量为成本的边

用户所需要的中转站，由用户向需要的中转站连inf边

最后用总收益减去最小割(最大流)就是答案

原因很简单

如果割掉用户的边，那么就舍弃掉一部分收益，可以看做损失

如果割掉中转站的边，那么就付出一定代价，可以看做损失

又因为不会割掉INF的边，所以就巧妙的解决了选A必须选B的问题

```cpp
#include<cstdio>
#include<cstring>
#include<queue>
#define AddEdge(x,y,z) add_edge(x,y,z),add_edge(y,x,0);
using namespace std;
const int MAXN=100001,INF=1e8+10;
inline char nc()
{
    static char buf[MAXN],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,MAXN,stdin),p1==p2)?EOF:*p1++;
}
inline int read()
{
    char c=nc();int x=0,f=1;
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=nc();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=nc();}
    return x*f;
}
int N,M,S,T;
struct node
{
    int u,v,flow,nxt;
}edge[MAXN*5];
int head[MAXN],cur[MAXN],num=0;
inline void add_edge(int x,int y,int z)
{
    edge[num].u=x;
    edge[num].v=y;
    edge[num].flow=z;
    edge[num].nxt=head[x];
    head[x]=num++;
}
int deep[MAXN];
inline bool BFS()
{
    memset(deep,0,sizeof(deep));
    deep[S]=1;
    queue<int>q;
    q.push(S);
    while(q.size()!=0)
    {
        int p=q.front();
        q.pop();
        for(int i=head[p];i!=-1;i=edge[i].nxt)
            if(!deep[edge[i].v]&&edge[i].flow)
            {
                deep[edge[i].v]=deep[p]+1;q.push(edge[i].v);
                if(edge[i].v==T) return 1;
            }
    }
    return deep[T];
}
int DFS(int now,int nowflow)
{
    if(now==T||nowflow<=0)    return nowflow;
    int totflow=0;
    for(int &i=cur[now];i!=-1;i=edge[i].nxt) 
    {
        if(deep[edge[i].v]==deep[now]+1&&edge[i].flow)
        {
            int canflow=DFS(edge[i].v,min(nowflow,edge[i].flow));
            edge[i].flow-=canflow;edge[i^1].flow+=canflow;
            totflow+=canflow;
            nowflow-=canflow;
            if(nowflow<=0) break;
        }
    }
    return totflow;
}
int Dinic()
{
    int ans=0;
    while(BFS())
    {
        memcpy(cur,head,sizeof(head)); 
        ans+=DFS(S,INF);
    }
    return ans;    
}

int main()
{
    #ifdef WIN32
    freopen("a.in","r",stdin);
    #else
    #endif
    memset(head,-1,sizeof(head));
	int N=read(),M=read();
	S=0;T=N+M+1;
	for(int i=1;i<=N;i++) 
	{
		int P=read();
		AddEdge(i+M,T,P);
	}
	int ans=0;
	for(int i=1;i<=M;i++)
	{
		int A=read(),B=read(),C=read();
		ans+=C;
		AddEdge(S,i,C);
		AddEdge(i,A+M,INF);
		AddEdge(i,B+M,INF);
	}
	printf("%d",ans-Dinic());
    return  0;
}
```

---

## 作者：Karnage (赞：14)

# P4174 [NOI2006]最大获利
### [Blog食用更佳](https://www.luogu.org/blog/DiamondHeart/solution-p4174)

原题链接：[这里](https://www.luogu.org/problemnew/show/P4174)

题意就不多赘述了

这题是最大权闭合图，但是我的思想略有不同，主要是**建图**

### 建图方式：
1.设立超级源，并将源点与每位用户i相连，边权为收益$c[i]$

2.将每位用户与其所需的两个中转站相连，边权均为$inf$

3.设立超级汇，将每个中转站与汇点相连，边权为费用$p[i]$

然后跑网络最大流（别告诉我你不会网络流想来切这题）

设最大流为$flow$，所有用户的收益和为$sum$，答案即为$sum-flow$

### 为什么这样做？

首先，对于所有亏本的用户（或几个互相联系的用户），其总费用必然大于收益（显而易见），

放到网络中，就是与源点相连的边权和（收益）小于与汇点相连的边权和（费用），根据网络的

容量限制，此时从这些用户点流出的流量必然等于这些用户的总收益，减去之后就等价于这些用

户对答案没有贡献（即收益为0）.其次，对于不亏本的用户（即对答案有贡献的用户），同样

地，总费用小于总收益，此时流量为总费用，将收益减去流量后即为实际收益。

### P.s.

1.这是蒟蒻的第一篇题解，望支持

2.本题解的思想不完全严谨，想要更严谨的做法可以参考[最小割模型在信息学竞赛中的应用](https://wenku.baidu.com/view/986baf00b52acfc789ebc9a9.html)

### 最后上代码

```cpp
#include<bits/stdc++.h>
#define ll long long
#define inf 2147483647
using namespace std;

const int N=2e5+5;//数组开大点
int n,m,s,t,num=1,head[N],d[N];
struct edge {
    int next,to,w;
}e[N<<1];
queue<int> q;

void add(int from,int to,int w) {
    e[++num].next=head[from],e[num].to=to,e[num].w=w,head[from]=num;
    e[++num].next=head[to],e[num].to=from,e[num].w=0,head[to]=num;
}

bool bfs() {
    memset(d,0,sizeof(d));
    while(!q.empty()) q.pop();
    q.push(s),d[s]=1;
    while(!q.empty()) {
        int u=q.front(); q.pop();
        for(int i=head[u]; i; i=e[i].next) if(!d[e[i].to]&&e[i].w) {
            q.push(e[i].to);
            d[e[i].to]=d[u]+1;
            if(e[i].to==t) return 1;
        }
    }
    return 0;
}

int dfs(int u,int flow) {
    if(u==t) return flow;
    int k,rest=flow;
    for(int i=head[u]; i&&rest; i=e[i].next) if(d[e[i].to]==d[u]+1&&e[i].w) {
        k=dfs(e[i].to,min(rest,e[i].w));
        if(!k) d[e[i].to]=0;
        e[i].w-=k,e[i^1].w+=k;
        rest-=k;
    }
    return flow-rest;
}

int dinic() {
    int maxflow=0,flow;
    while(bfs()) {
        while(1) {
            flow=dfs(s,inf);
            maxflow+=flow;
            if(!flow) break;
        }
    }
    return maxflow;
}

int main() {
    scanf("%d%d",&n,&m);
    int p,a,b,c,sum=0;  s=0,t=n+m+1;
    for(int i=1; i<=n; i++) {
        scanf("%d",&p);
        add(m+i,t,p);
    }
    for(int i=1; i<=m; i++) {
        scanf("%d%d%d",&a,&b,&c);
        sum+=c;
        add(s,i,c);
        add(i,m+a,inf),add(i,m+b,inf);
    }
    printf("%d\n",sum-dinic());//我用的是dinic算法
    return 0;
}

---

## 作者：fmj_123 (赞：10)

非常经典的网络流模型。

**最大权闭合子图**

PS:本文参考了胡伯涛的《最小割模型在信息学竞赛中的应用》论文，感兴趣的dalao可以阅读一下[链接](http://www.doc88.com/p-695925489832.html)

我们将样例用图的形式表达

```
5 5
1 2 3 4 5
1 2 3
2 3 4
1 3 3
1 4 2
4 5 3
```
![](https://cdn.luogu.com.cn/upload/pic/52295.png)

看起来无从下手。那么，我们将其转换为下面这幅图，容易看出，它们是等价的。并且，下图是个**二分图**。
![](https://cdn.luogu.com.cn/upload/pic/52291.png)

接下来我们引入**有向图的闭合子图**的概念

> 定义一个有向图的闭合图（closure）$G=(V,E)$是该有向图的一个点集，且该点集的所有出边都还指向该点集。即闭合图内的任意点的任意后继也一定在闭合图中。

根据定义，在本图中，如果选择了左边的一个点，那么与其相连的右边的两个点**一定也要被选中**。而我们要求的，就是最大权闭合子图，也就是说，所选的点权之和最大。

事实上，我们可以将其转化为最小割的模型去解决。我们将**正权点连向源点$S$，边权为点权，负权点连向汇点$T$，边权为点权的绝对值，而原来的边的权值为$INF$。**如下图：

![](https://cdn.luogu.com.cn/upload/pic/52292.png)


我们使用最小割，中间的不可割，左边割了就意味着放弃了第$i$名用户的权益，右边割了就意味着建第$i$个基站。最后，所有正权点的点权之和减去得到的最小割即为答案。

求最小割可以用“最大流=最小割”定理解决。

上代码

```c++
//1为源点，2~1+m为用户，2+m~n+m+1为第i个基站，n+m+2为汇点
#include<bits/stdc++.h>
#define inf 2147483647
#define T n+m+2
#define N 400000
using namespace std;
int cc,to[N],net[N],fr[N],len[N],fx[N],c[N],q[N];
bool vis[N];int n,m,a,u,v,l,sum;
void addedge(int u,int v,int l)
{
	cc++;
	to[cc]=v;net[cc]=fr[u];fr[u]=cc;len[cc]=l;fx[cc]=cc+1;
	cc++;
	to[cc]=u;net[cc]=fr[v];fr[v]=cc;len[cc]=0;fx[cc]=cc-1;
}//建边
bool bfs()
{
	int h=1,t=1;
	for (int i=1;i<=T;i++)
	  c[i]=0,vis[i]=false;
	q[1]=1;c[1]=1;vis[1]=true;
	while (h<=t)
	{
		for (int i=fr[q[h]];i;i=net[i])
		{
			if (vis[to[i]]||(!len[i])) continue;
			q[++t]=to[i];
			c[to[i]]=c[q[h]]+1;vis[to[i]]=true;
		}
		h++;
	}
	return vis[T];
}
int dfs(int x,int k)
{
	int ff=0;
	if (x==T) return k;
	for (int i=fr[x];i;i=net[i])
	{
		if (len[i]&&c[to[i]]==c[x]+1)
		{
			int y=min(k,len[i]);
			int re=dfs(to[i],y);
			len[i]-=re;
			len[fx[i]]+=re;
			ff+=re;k-=re;
		}
		if (k<=0) break;
	}
	return ff;
}
int dinic()
{
	int ans=0;
	while (bfs())
	{
	    ans+=dfs(1,inf);
	}
	return ans;
} //跑dinic
int main()
{
	scanf("%d%d",&n,&m); 
	for (int i=1;i<=n;i++)
	{
		scanf("%d",&a);
		addedge(m+1+i,T,a);
	}
	for (int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&u,&v,&l);
		sum+=l;
		addedge(1,1+i,l);
		addedge(1+i,1+m+u,inf);
		addedge(1+i,1+m+v,inf);
	}
	cout<<sum-dinic(); 
	return 0;
} 
```




---

## 作者：devout (赞：7)

一种不同的做法。

因为一个人只会连两个不同的点，所以可以把人看成边，现在我们要求的就是一个点集 $V^\prime$ 和这些点集里面的边 $E^\prime$ 的贡献最大，即

$\max\{-\sum_{v\in  V^\prime}P_v+\sum_{e\in E^\prime}w_e\}$

也就是

$\dfrac{1}{2}\max\{-\sum_{v\in V^\prime}(2P_v-sumw_v)-C[V^\prime,\overline{V^\prime}]\}$

其中 $C[V^\prime,\overline{V^\prime}]$ 表示 $V^\prime$ 和 $V^\prime$ 的补集之间的所有边的边权和。

到这里就已经变成了一个把点划分成集合的问题了，不难想到用网络流来解决，按照如下方法建图，为了保证边权非负，我们给每一条点和源/汇相连的边加上一个权值 $U$。

- $(S,i,U+sumw_i-2P_i)$
- $(A_i,B_i,C_i)$
- $(B_i,A_i,C_i)$
- $(i,T,U)$

答案即为 $\dfrac{\sum_{i=1}^n (sumw_i-2P_i)+Un-maxflow}{2}$

复杂度为 $\mathcal O(\operatorname{maxflow}(n,n+m))$

```
int n,m;
int head[N],cnt;
int dep[N],S,T,U;
int a[N],sw[N];
ll ans,maxflow;

struct Edge{
    int to,next,flow;
}e[M<<1];

void add(int x,int y,int c){
    e[++cnt]=(Edge){y,head[x],c},head[x]=cnt;
    e[++cnt]=(Edge){x,head[y],0},head[y]=cnt;
}

bool bfs(){
    memset(dep,0,sizeof(dep));
    queue<int> q;
    q.push(S),dep[S]=1;
    while(!q.empty()){
        int u=q.front();q.pop();
        RepG(i,u){
            int v=e[i].to;
            if(e[i].flow&&!dep[v]){
                dep[v]=dep[u]+1;
                q.push(v);
                if(v==T)return true;
            }
        }
    }
    return false;
}

int dfs(int u,int flow){
    if(u==T)return flow;
    int tmp=0,k;
    for(int i=head[u];~i&&tmp<flow;i=e[i].next){
        int v=e[i].to;
        if(e[i].flow&&dep[v]==dep[u]+1){
            k=dfs(v,min(e[i].flow,flow-tmp));
            if(!k)dep[v]=0;
            e[i].flow-=k,e[i^1].flow+=k;
            tmp+=k;
        }
    }
    return tmp;
}

void dinic(){
    while(bfs())
        maxflow+=dfs(S,inf);
}

int main()
{
    # ifdef hibike
    freopen("testdata.in","r",stdin);
    freopen("test1.out","w",stdout);
    # endif
    memset(head,-1,sizeof(head)),cnt=1;
    read(n),read(m);
    S=n+1,T=S+1;
    Rep(i,1,n)read(a[i]);
    Rep(i,1,m){
        int x,y,c;
        read(x),read(y),read(c);
        add(x,y,c),add(y,x,c);
        sw[x]+=c,sw[y]+=c;
    }
    Rep(i,1,n)U=max(U,2*a[i]-sw[i]);
    U++;
    Rep(i,1,n)add(S,i,sw[i]-2*a[i]+U),ans+=sw[i]-2*a[i]+U;
    Rep(i,1,n)add(i,T,U);
    dinic();
    printf("%lld\n",(ans-maxflow)/2);
    return 0;
}
```

---

## 作者：PokerKing (赞：7)

## 思路

看题解基本都是最大权闭合子图，来一个网络流最小割的题解。

建模：将中转站、用户名看成点。

- 建立点 $A_i$ 表示中转站 $i$，连边 $S\rightarrow A_i$，容量为 $P_i$（**割这条边表示建立中转站 $i$ 需要 $P_i$ 的费用**）。
- 建立点 $B_i$ 表示第 $i$ 个用户群，连边 $B_i \rightarrow T$，容量为 $C_i$（**割这条边表示不满足第 $i$ 个用户的要求，损失 $C_i$ 的**）。
- 若第 $i$ 个用户群会使用中转站 $j$，那么 $S\rightarrow A_i$ 与 $B_i \rightarrow T$ 不能同时保留。
- 可以连边 $A_j \rightarrow B_i$，容量为正无穷，这样就限制了两条边不能同时保留。

最大净获利（也就是答案）$=$ 所有用户群的获益之和 $-$ 最小割的答案。

---

## 作者：zeb6666 (赞：4)

## 思路

本题可转化为最大权闭合图问题。最大权闭合图是指在一个有向图中，对于图中的任意一个点，其所有出边指向的点都在该闭合图内，且该闭合图的权值之和最大。

1. **节点设置**：
    - 设立一个源点 $S$ 和一个汇点 $T$。
    - $n$ 个基地对应图中的节点 $1$ 到 $n$。
    - $m$ 个用户对应图中的节点 $n+1$ 到 $n+m$。
    
2. **边的构建**：
    - 从源点 $S$ 向每个用户节点连接一条边，边的容量为该用户的获利 $c_i$。
    - 从每个用户节点向其依赖的两个基地节点各连接一条容量为无穷大的边。无穷大的容量保证了在最小割计算时，这条边不会成为割边。
    - 从每个基地节点向汇点 $T$ 连接一条边，边的容量为基地的成本 $p_i$。

最终输出总收益减去最小割（最大流）。

样例如下图：

![样例](https://cdn.luogu.com.cn/upload/image_hosting/t4zjer5n.png)

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5003,M=50004,INF=0x3f3f3f3f;
struct Edge{int to,cap,flow,ne;}e[M*6+N*2];
int he[N+M],cnt=0,cur[N+M],dep[N+M],S,T;
void adde(int u,int v,int cap){
	e[cnt]={v,cap,0,he[u]},he[u]=cnt,cnt++,
	e[cnt]={u,0,0,he[v]},he[v]=cnt,cnt++;
}
bool bfs(){
	memset(dep,-1,sizeof(dep));
	queue<int> q; q.push(S),dep[S]=0;
	while(!q.empty()){
		int u=q.front(); q.pop();
		for(int i=he[u];i!=-1;i=e[i].ne){
			int v=e[i].to;
			if(dep[v]==-1&&e[i].cap>e[i].flow)
				q.push(v),dep[v]=dep[u]+1;
		}
	}
	return dep[T]!=-1;
}
int dfs(int u,int f){
	if (u==T||f==0) return f;
	int flow=0;
	for (int &i=cur[u];i!=-1;i=e[i].ne){
		int v=e[i].to,newf;
		if(dep[v]==dep[u]+1&&(newf=dfs(v,min(f,e[i].cap-e[i].flow)))>0){
			e[i].flow+=newf,e[i^1].flow-=newf;
			flow+=newf,f-=newf;
			if(f==0) break;
		}
	}
	return flow;
}
int dinic(){
	int maxFlow=0;
	while(bfs()){
		for(int i=S;i<=T;i++) cur[i]=he[i];
		maxFlow+=dfs(S,INF);
	}
	return maxFlow;
}
int main(){
	int n,m,h=0; cin>>n>>m,S=0,T=n+m+1;
	memset(he,-1,sizeof(he));
	for(int i=1,p;i<=n;i++) cin>>p,adde(i,T,p);
	for(int i=1,a,b,c;i<=m;i++) 
		cin>>a>>b>>c,h+=c,adde(S,n+i,c),
		adde(n+i,a,INF),adde(n+i,b,INF);
	cout<<h-dinic();
	return 0;
}
```

---

## 作者：CommonDigger (赞：1)

前置知识：**网络流最小割**。

其实用最大权闭合子图来写属实有点复杂了，而最小割的做法却少之又少。

计算净利润最大值，可以转换成先满足所有用户群的需求，再舍弃一些太费钱的用户群，从而净利润最大。所以要求的就是使利润增加的基础上能舍弃的最多中转站费用。

最小割建模：  
- 将源点连向所有中转站，将所有用户连向汇点。
- 源点与中转站之间的边权表示建立中转站的费用。割掉这条边意味着花掉这个钱来**建立**中转站。
- 用户与汇点之间的边权表示用户群带来的利润。割掉这条边表示不要这个利润，即**舍弃**这个用户群。
- 如果中转站 $i$ 与用户 $j$ 存在使用关系，那么只有两种情况：第一种，建立中转站（对应的是割掉中转站边）并满足该用户群；第二种，不建立中转站（对应的是保留中转站边）并不满足该用户群（割掉用户边）。如果中转站边与用户边都不割，意思就是不建立中转站但满足用户需求，是矛盾的；都割掉意味着建立中转站但舍弃用户，纯浪费钱。注意到两种正常的情况都把这条路径断了，并且每种依赖关系都要断边，于是计算最小割即可。
- 因为只会割中转站边与用户边，所以表示中转站与用户的依赖关系的边权设为 $inf$，确保不会割到关系边。

最小割等于最大流，这里我使用的是 Dinic 算法。

算出来的结果是净利润最大的情况下需要舍弃的用户群总收入，要计算最大利润就用所有用户群的获利之和减去结果即可。

```cpp
/*
Luogu P4174 最大获利
https://www.luogu.com.cn/problem/P4174
*/
#include <iostream>
#include <cstring>
#include <cstdio>
#include <queue>
#define INF 2147483647
#define int long long
using namespace std;
const int PORTAL=5005, USER=500005, N=505005, M=505005+1000005;
int S, T, portal, user, head[N], dep[N], cur[N], idx=1, ans;
int cost[PORTAL], inCome[USER];
int temp1, temp2, temp3;
struct edge
{
    int to, nxt, w;
}e[2*M];
void add_edge(int u, int v, int w)
{
    e[++idx].to=v;
    e[idx].w=w;
    e[idx].nxt=head[u];
    head[u]=idx;
    e[++idx].to=u;
    e[idx].w=0;
    e[idx].nxt=head[v];
    head[v]=idx;
}
int min2(int x, int y)
{
    return x<y ? x : y;
}
bool bfs()
{
    memset(dep, 0, sizeof(dep));
    dep[S]=1;
    queue<int>q;
    q.push(S);
    while (!q.empty())
    {
        int x=q.front();
        q.pop();
        for (int i=head[x]; i; i=e[i].nxt)
        {
            int to=e[i].to;
            if (!dep[to] && e[i].w)
            {
                dep[to] = dep[x]+1;
                q.push(to);
            }
        }
    }
    return dep[T];
}
int dfs(int x, int min_flow)
{
    if (x==T) return min_flow;
    for (int& i=cur[x]; i; i=e[i].nxt)
    {
        int to=e[i].to;
        if (dep[to]==dep[x]+1 && e[i].w)
        {
            int r = dfs(to, min2(min_flow, e[i].w));
            if (r)
            {
                e[i].w -= r;
                e[i^1].w += r;
                return r;
            }
        }
    }
    return 0;
}
void dinic()
{
    while (bfs())
    {
        for (int i=1;i<=T;i++) cur[i]=head[i];
        while (int r=dfs(S, INF)) ans-=r;
    }
}
signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin >> portal >> user;
    S=portal+user+1, T=portal+user+2;
    for (int i=1;i<=portal;i++)
    {
        cin >> cost[i];
        add_edge(S, i, cost[i]);
    }
    for (int i=1;i<=user;i++)
    {
        cin >> temp1 >> temp2 >> temp3;
        ans += temp3;
        add_edge(temp1, portal+i, INF);
        add_edge(temp2, portal+i, INF);
        add_edge(portal+i, T, temp3);
    }
    dinic();
    cout << ans;
}
```

---

## 作者：sunqihuan (赞：1)

# 前言

建议对最大流最小割有一定的了解再来看此题解。

# 最小割之最大权闭合子图

## 定义：

**闭合子图**：从原图里选出来一些点，满足这些点连到的点都在闭合子图里。也就是说闭合子图是一个点的集合，是自洽的。

**最大权闭合子图**：在所有的闭合子图中，点权和最大的那个闭合子图，称为最大权闭合子图。

## 转化为流网络，证明

我们可以为原图 $G=(V,E)$ 构造一个流网络 $N=(V_N,E_N)$，其中 $V_N=V+{s,t}$，$E_N={(s,u),w_u>0}\cup {(u,t),w_u<0} ∪ E$。

其中 $c(s,u)=w_u,c(u,t)=-w_u,c(u,v)=∞((u,v)\in E)$。

在这个问题里，我们定义一种特殊的割：**简单割**：一个割里的割边只与 $s,t$ 相连，这个割就是一个简单割。

> **证明：原图里的每一个闭合子图，都能和流网络里的所有简单割一一对应**
>
> 
>
> 我们知道，简单割是所有割的一个子集，那么：
>
> **证明：最小割是一个简单割**
>
> 根据最大流最小割定理，我们知道最大流等于最小割。最大流 $|f|=\sum_{u\in V_N} f(s,u)$，因为 $f(s,u)\le c(s,u)$，所以所有的 $f(s,u)$ 都是有限的数，而有限个有限的数相加，得到的还是有限的数，所以最大流是有限的，那么最小割就是有限的，最小割是有限的那最小割就不能包含中间那些无穷大的边，所以最小割是一个简单割。
>
> 所以我们这里只需要证明闭合子图，都能和流网络里的所有简单割一一对应，那么我们求闭合子图的最值，就可以求简单割的最值对吧。
>
> 我们设闭合子图的点集为 $V'$，我们构造这样一个割 $[S,T]$：
>
> $S=V'+s,T=V_N-S$
>
> 显然这是一个合法的割。
>
> **证明：上述构造的割 $[S,T]$ 是简单割**
>
> 因为 $V'$ 是一个闭合子图，所以在割 $[S,T]$ 里，能通过中间那些无穷大容量的边走到的点一定也在 $V'$ 里，也就是在 $S$ 里。所以从 $S$ 如果能通过无穷大的边走到 $T$ 里的一个点，那么它走到的那个点一定在 $S$ 里，与在 $T$ 里相矛盾，所以不存在容量为无穷大的割边，所以割 $[S,T]$ 是简单割。
>
> **证明：每一个简单割都能和一个闭合子图对应**
>
> 我们的割 $[S,T]$，$V'=S-s$，那 $V'$ 是不是一个闭合点集呢？
>
> 因为我们的割 $[S,T]$ 是简单割，所以不存在可以从 $S$ 指向 $T$ 的边是原图里的（就是容量是无穷大的那些边），所以在 $S$ 里走容量原图的边走来走去一定在 $S$ 里，所以 $S$ 就是一个闭合子图，所以每一个简单割都能和一个闭合子图对应。
>
> 而我们的割 $[S,T]$ 就是通过闭合子图来定义的，所以结合上述证明，可以得到原图里的每一个闭合子图，都能和流网络里的所有简单割一一对应。
>
> 证毕。

然后我们来推导一下割容量 $c[S,T]$ 的表达式。

定义闭合子图为 $V_1$，$V_2=V-V_1$，割的容量 $c[S,T]$ 就是 $S$ 到 $T$ 的容量，所以 $S=V_1+s,T=V_2+t$。所以我们可以分为 $4$ 种情况：

1.$V_1$ 到 $V_2$ 的容量。由于不存在内部的边可以指向 $T$，所以不存在。

2.$V_1$ 到 $t$ 的容量。

3.$s$ 到 $V_2$ 的容量。

4.$s$ 到 $t$ 的容量。由于 $s$ 不能指向 $t$，所以不存在。

所以：

$
c[S,T]\\
=c[s,V_2]+c[V_1,t]\\
=\sum_{v\in V_2} w_v+\sum_{v\in V_1} (-w_v)
$

我们定义 $V_1^+$ 表示 $V_1$ 里权值为正数的点的集合， $V_1^-$ 表示 $V_1$ 里权值为负数的点的集合。

设 $w(X)$ 表示 $X$ 里点的权值和，

我们把 $w(V_1)$ 拆开，得：

$
w(V_1)\\
=\sum_{v\in V_1^+} w_v+\sum_{v\in V_1^-} w_v\\
=\sum_{v\in V_1^+} w_v-\sum_{v\in V_1^-} (-w_v)
$

回顾之前的定义，可以发现，所有从 $s$ 出发的边连到的点点权都是正的，所有连到 $t$ 的点点权都是负的，所以：

$c[S,T]=\sum_{v\in V_2^+} w_v+\sum_{v\in V_1^-} (-w_v)$

观察到 $c[S,T]$ 和 $w(V_1)$ 都有一项 $\sum_{v\in V_1^-} (-w_v)$，只是符号不同，所以我们让两式相加：

$
c[S,T]+w(V_1)\\
=\sum_{v\in V_2^+} w_v+\sum_{v\in V_1^+} w_v\\
=w(V^+)
$
（因为 $V_1+V_2=V$）

由于 $w(V^+)$ 是定值，所以我们要让 $w(V_1)$ 尽量大，就要让 $c[S,T]$ 尽量小。所以最大权闭合子图的最大权值就是原图所有点权为正数的点的权值和减去最小割。

## 例题：最大获利

[P4174 [NOI2006] 最大获利](https://www.luogu.com.cn/problem/P4174)

我们把中转站和用户群当成点，把公司收入当成点权（当然建中转站要付钱的话就是负数），边就是用户向要求连接的两个中转站分别连接，从源点连向所有用户群（因为收益为正），所有中转站连向汇点，用所有用户群的收益之和减去最小割即可。

不过我们发现这其实是一个大材小用的解法，因为图本来很特殊，一个用户只能连两条边，这种解法相当于是一个用户连多条边的解法。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=55005,M=(50005*3+5000)*2+5,inf=1e8;
int n,m,S,T;
int h[N],e[M],f[M],nt[M],idx;
int q[N],d[N],cur[N];
void add(int a,int b,int c) {
	e[idx]=b;
	f[idx]=c;
	nt[idx]=h[a];
	h[a]=idx++;
	e[idx]=a;
	f[idx]=0;
	nt[idx]=h[b];
	h[b]=idx++;
}
bool bfs() {
	int head=0,tail=0;
	memset(d,-1,sizeof(d));
	q[0]=S,d[S]=0,cur[S]=h[S];
	while(head<=tail) {
		int t=q[head++];
		for(int i=h[t]; ~i; i=nt[i]) {
			int v=e[i];
			if(d[v]==-1 && f[i]) {
				d[v]=d[t]+1;
				cur[v]=h[v];
				if(v==T)return 1;
				q[++tail]=v;
			}
		}
	}
	return 0;
}
int find(int u,int limit) {
	if(u==T)return limit;
	int flow=0;
	for(int i=cur[u]; ~i && flow<limit; i=nt[i]) {
		cur[u]=i;
		int v=e[i];
		if(d[v]==d[u]+1 && f[i]) {
			int t=find(v,min(f[i],limit-flow));
			if(!t)d[v]=-1;
			f[i]-=t;
			f[i^1]+=t;
			flow+=t;
		}
	}
	return flow;
}
int dinic() {
	int r=0,flow;
	while(bfs())while(flow=find(S,inf))r+=flow;
	return r;
}
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	S=0,T=n+m+1;
	memset(h,-1,sizeof(h));
	for(int i=1; i<=n; i++) {
		int p;
		cin>>p;
		add(m+i,T,p);
	}
	int tot=0;
	for(int i=1; i<=m; i++) {
		int a,b,c;
		cin>>a>>b>>c;
		add(S,i,c);
		add(i,m+a,inf);
		add(i,m+b,inf);
		tot+=c;
	}
	cout<<tot-dinic()<<endl;
	return 0;
}


```

# 最小割之最大密度子图

## 定义

**最大密度子图**：是无向图 $G=(V,E)$ 的一个子图，从原图里选一些点和一些边，选的点集为 $V'$，边集为 $E'$，满足如果一条边被选了，那么它的两个端点必选。一种选法的密度定义为 $\cfrac{|E'|}{|V'|}$，密度最大的一种选法称为最大密度子图。

这也很好理解，就是点确定时，边越多，看起来就越密集对吧。

我们发现最大密度子图问题其实可以转化成最大权闭合子图问题。因为有一个条件是选了边 $(a,b)$，就必须选 $a$ 和 $b$。所以我们可以直接把点和边都看成点，直接转化成最大获利问题即可。

## 发掘性质

但是我们直接这么做并没有发掘最大密度子图的性质。所以效率肯定不高。

我们注意到，如果点集确定，那么它的诱导子图一定是最优解，相当于把里面所有的边都选上了。

首先我们看一下密度定义即 $\cfrac{|E'|}{|V'|}$，看到分数大家应该都会想到分数规划。即设 $\cfrac{|E'|}{|V'|}=g$，移项得 $|E'|-g|V'|$。

我们就是要让 $|E'|-g|V'|$ 最大。可惜我们的最小割求的是最小值，所以我们干脆让 $g|V'|-|E'|$ 最小。

我们求这个式子其实不是很好求，我们要尽量和割联系起来。要是把选出来的点集当做割的话，可以用一种补集的思想，就是 $S$ 里面边的数量等于从 $S$ 连出去的边的数量，减去连到 $T$ 的边的数量。

我们给一条边划分一下归属，让一条边 $(u,v)$ 分为两半，一半是靠近 $u$ 的长度为 $\frac{1}{2}$ 的边，另一半是靠近 $v$ 的长度是另一半。即：

![](https://cdn.luogu.com.cn/upload/image_hosting/fazaeml3.png)

所以：

$
g|V'|-|E'|\\
=\sum_{v\in V'} g-(\cfrac{\sum_{v\in V'} d_v}{2}-\cfrac{c[V',V'_2]}{2})\\
=\sum_{v\in V'} (g-\cfrac{d_v}{2})-\cfrac{c[V',V'_2]}{2}\\
=\cfrac{1}{2}\times (\sum_{v\in V'} (2g-d_v)-c[V',V'_2])
$

其中 $d_v$ 表示 $v$ 的度数，$V'_2$ 表示 $V'$ 加上其周围的点。

我们构造一张流网络，点就是所有点加上源汇点，边是所有边加上源点到所有点的边和所有点到汇点的边，这里有向无向都没关系。每个点到汇点边的容量为 $2g-d_v$，由于可能会有负数，所以我们将每条边加上一个大整数偏移量 $U$，从源点出发的边的容量都是 $U$，每个点到汇点边的容量为 $2g-d_v+U$。

设有一割 $[S,T]$，定义 $V'=S-s,V'_2=V-V'$，则边像最大权闭合子图一样分为四个情况，只有 $s$ 到 $t$ 是不行的。所以：

$
c[S,T]\\
=\sum_{v\in V'_2}U+\sum_{u\in V'}(U+2g-d_u)+\sum_{u\in V'}\sum_{v\in V'_2} c(u,v)\\
=\sum_{v\in V'_2} U+\sum_{u\in V'}(U+2g-d_u+\sum_{v\in V'_2} c(u,v))\\
=\sum_{v\in V'_2} U+\sum_{u\in V'}(U+2g-(d_u-\sum_{v\in V'_2} c(u,v)))\\
$

$d_u$ 就是从集合里连出去的边，$\sum_{v\in V'_2} c(u,v)$ 就是连到集合外面的边，相减就是在集合里的边。所以：

$
c[S,T]\\
=\sum_{v\in v'_2} U+\sum_{u\in V'}(U+2g-\sum_{v\in V'} c(u,v))\\
=\sum_{v\in V} U+\sum_{u\in V'} 2g-\sum_{u\in V'}\sum_{v\in V'}c(u,v)\\
=U\times n+2g|V'|-2|E'|\\
=U\times n+2(g|V'|-|E'|)
$

我们要让 $g|V'|-|E'|$ 最小，等价于让 $2(g|V'|-|E'|)$ 最小，而 $U\times n$ 是定值，所以就等价于让 $c[S,T]$ 最小。

## 例题：最大获利

其实这题看起来更像是最大密度子图的题。就是个模版，不过注意点挺多的：

- 点权 $p_i$ 是要减去的，是负的收益。
- 算法保证 $U + 2 \times g - 2 \times p_u - d_u \ge 0$，本题 $g = 0，U \ge 2 \times p_u + d_u$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5005,M=6e4*2+5,inf=0x3f3f3f3f;
int n,m,S,T;
int h[N],e[M],f[M],nt[M],idx;
int q[N],d[N],cur[N];
int deg[N],p[N];
void add(int a,int b,int c1,int c2){
	e[idx]=b;
	f[idx]=c1;
	nt[idx]=h[a];
	h[a]=idx++;
	e[idx]=a;
	f[idx]=c2;
	nt[idx]=h[b];
	h[b]=idx++;	
}
bool bfs(){
	int head=0,tail=0;
	memset(d,-1,sizeof(d));
	q[0]=S,d[S]=0,cur[S]=h[S];
	while(head<=tail){
		int t=q[head++];
		for(int i=h[t];~i;i=nt[i]){
			int v=e[i];
			if(d[v]==-1 && f[i]){
				d[v]=d[t]+1;
				cur[v]=h[v];
				if(v==T)return 1;
				q[++tail]=v;
			}
		}
	}
	return 0;
}
int find(int u,int limit) {
	if(u==T)return limit;
	int flow=0;
	for(int i=cur[u]; ~i && flow<limit; i=nt[i]) {
		cur[u]=i;
		int v=e[i];
		if(d[v]==d[u]+1 && f[i]) {
			int t=find(v,min(f[i],limit-flow));
			if(!t)d[v]=-1;
			f[i]-=t;
			f[i^1]+=t;
			flow+=t;
		}
	}
	return flow;
}
int dinic() {
	int r=0,flow;
	while(bfs())while(flow=find(S,inf))r+=flow;
	return r;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	S=0,T=n+1;
	for(int i=1;i<=n;i++)cin>>p[i],p[i]*=-1;
	memset(h,-1,sizeof(h));
	for(int i=1;i<=m;i++){
		int a,b,c;
		cin>>a>>b>>c;
		deg[a]+=c,deg[b]+=c;
		add(a,b,c,c);
	}
	int U=0;
	for(int i=1;i<=n;i++)U=max(U,2*p[i]+deg[i]);
	for(int i=1;i<=n;i++){
		add(S,i,U,0);
		add(i,T,U-2*p[i]-deg[i],0);
	}
	int res=dinic();
	cout<<(U*n-res)/2<<endl;
	return 0;
}

```

---

## 作者：xfrvq (赞：1)

复健ing...

应该就是最大权闭合子图。但是网上抽象讲解我真看不懂。

---

[P2762 太空飞行计划问题](https://www.luogu.com.cn/problem/P2762) 弱化版。

题意：有 $n$ 个有代价物品。有 $m$ 个需求形如取 $A_i,B_i$ 物品会获得 $C_i$ 收益。取一些物品使得收益与代价的差最大。

建模方法：

1. 源点向 $m$ 个需求连边，流量为收益。
2. 需求 $i$ 向所需物品 $A_i,B_i$ 连边，流量为 $+\infty$。
3. 物品向汇点连边，流量为代价。

然后求最小割，答案是所有需求收益的总和与最小割的差。

---

考虑证明建模的正确性。

首先此时最小割的意义在于：**选择一些需求和物品割掉，使源点到汇点不存在流量，且消耗流量最小**。

考虑需求中被割掉了的部分。此时源点不可能通过它们流到汇点，因此它们所连向的物品，割与不割不受影响。

而对于需求中没被割掉的剩余部分。**它们所连向的物品必须都被割掉**。那么未割需求和割掉物品可以作为一组问题的解，因为**所有未割需求所连向的物品都被割掉了**。

我们用需求的收益总和，减去部分需求的收益和部分物品的代价之和（即最小割），就会得到**未割需求的代价与割掉物品的代价之差**。

由于最小割是最小值，那么用一个收益总和（一个定值）减去，得到的就是答案的最大值。

---

## 作者：yyrwlj (赞：1)

这篇题解使用最大密度子图的思路。

## 题意简述

有 $m$ 个用户群，每个用户群需要两个中转站，建造第 $i$ 个中转站的代价是 $p_i$，若第 $i$ 个用户群需要的两个中转站 $a_i$ 和 $b_i$ 都被修建了，则会产生 $c_i$ 的贡献，求出贡献减代价的最大值。

## 思路

下文中 $c(S, T)$ 表示割 $(S,T)$ 的容量。

密度子图：对于一个图 $G=(V,E)$ 的一个子图 $G'=(V',E')$，对于所有的 $(a,b) \in E'$，都满足 $a \in V'$ 且 $b \in V'$，则 $G'$ 是 $G$ 的一个密度子图。

最大密度子图：所有密度子图中，$\frac{|E'|}{|V'|}$ 最大的一个。

像这样的分式，通常使用 $01$ 分数规划来求解最大值。

回顾 $01$ 分数规划的过程，二分 $\frac{|E'|}{|V'|}=g$，看 $|E'|-g \cdot |V'|$ 的值大于还是小于 $0$。

因为是**最大**密度子图，所以要最大化 $|E'|-g \cdot |V'|$，等价于最小化 $g \cdot |V'|-|E'|$。

最小化联想到最小割，直接求密度子图的边的数量不好求，可以运用补集的思想。

用密度子图的点集相关的边的数量减去密度子图和其他点的割边的数量，就是密度子图中边的数量。

和点集相关的边的数量显然等于 $\frac{\sum_{u\in V'}d_u}{2}$（$d_u$ 表示点 $u$ 的度数）。

因此密度子图中边的数量就是

$$\frac{\sum_{u \in V'}{d_u}-c(V',V-V')}{2}$$

则最小化

$$\sum_{u \in V'}{(g-\frac{d_u}{2})}+c(V',V-V')$$

但是这里除了割以外还多了一项，推式子得上式等于

$$\frac{1}{2} (\sum_{u \in V'}{(2g-d_u)}+c(V',V-V'))$$

将加号左边跟右边融合，让所有点向汇点连一条容量为 $2g-d_u$ 的边即可。

注意 $2g-d_u$ 有可能是负数，所以加上一个大数 $U$，对应的源点向所有点连一条容量为 $U$ 的边。原图中的边容量都为 $1$。

总结：让 $|E'|-g|V'|$ 最大，就是让 $g|V'|-|E'|$ 最小，就是让 $U \cdot n + 2g|V'|-2|E'|$ 最小。

$U \cdot n$ 是定值，所以就是让 $2g|V'|-2|E'|$ 最小，等价于让 $c(S,T)$ 最小。

所以求最小割即可，答案就是 $\frac{U \cdot n - c(S,T)}{2}$。

***

对于此题，把用户群看成边，连接两个中转站。要想满足某个用户群，就要先建对应的两个中转站。

要最大化 $|E'|+|V'|$，跟上面的证明相比少了 $g$，那就当 $g=0$ 好了，所以不用二分，直接求解最小割即可。

---

## 作者：ysy20021208 (赞：1)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**分析与题解：**建立源点$S$点，将所有的用户和$S$相连，边权就是当前用户的收益，建立汇点$T$点，将所有的中转站和$T$相连，边权就是当期中转站的花费。对于一个用户，他需要两个中转站，所以如果选择当前用户就一定要选择这两个中转站，根据这条性质我们知道，用户应该跟他的中转站相连，由用户指向中转站，边权为$inf$。

```c++
// luogu-judger-enable-o2
#include <cstdio>
#include <algorithm>
#include <queue>
#include <cstring>
using namespace std;
#define N 55010
#define inf 1000000000
int n,m,idx=1,dis[N],s,t,ans;
int head[N],to[N<<3],val[N<<3],nxt[N<<3];
void add(int a,int b,int c)
{nxt[++idx]=head[a],val[idx]=c,to[idx]=b,head[a]=idx;}
bool bfs()
{
    queue <int> q;memset(dis,-1,sizeof(dis));
    q.push(s);dis[s]=0;
    while(!q.empty())
    {
        int p=q.front();q.pop();
        for(int i=head[p];i;i=nxt[i])
            if(val[i]>0&&dis[to[i]]==-1)
            {
                dis[to[i]]=dis[p]+1,q.push(to[i]);
                if(to[i]==t) return true;
            }
    }
    return false;
}
int dfs(int p,int flow)
{
    int now,temp=flow;
    if(p==t) return flow;
    for(int i=head[p];i;i=nxt[i])
        if(val[i]>0&&dis[to[i]]==dis[p]+1)
        {
            now=dfs(to[i],min(val[i],temp));
            if(!now) dis[to[i]]=-1;
            temp-=now,val[i]-=now,val[i^1]+=now;
            if(!temp) break;
        }
    return flow-temp;
}
void dinic() {while(bfs()) ans-=dfs(s,inf);}
int main()
{
    scanf("%d%d",&n,&m); s=n+m+1,t=n+m+2;
    for(int i=1,a;i<=n;i++) scanf("%d",&a),add(i,t,a),add(t,i,0);
    for(int i=1,a,b,c;i<=m;i++)
    {
        scanf("%d%d%d",&a,&b,&c);ans+=c;
        add(s,i+n,c),add(i+n,s,0);
        add(i+n,b,inf),add(b,i+n,0);
        add(i+n,a,inf),add(a,i+n,0);
    } dinic(),printf("%d\n",ans);
}
```

---

## 作者：chatoudp (赞：0)

好久没写题解了，估值更是掉下 $300$。

网络流，最小割。

我们把源点连向每个中转站，边的最大流量为中转站的投入成本，割掉此边表示购买中转站。

我们再把每个用户群连向汇点，边的最大流量为用户群的收益，割掉表示不满足用户群中转要求。

我们再考虑每个用户群的限制条件，我们从一个中转站来看。首先，中转站与源点的边不割表示没买该中转站。其次，用户群与汇点的边不割则表示用户群满足中转要求。很显然，这 $2$ 条边至少割一个，于是我们可以把中转站与用户群建一个边权为无限的边即可。最后，答案为所有用户群的收益减去最小割。

AC 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,y;
long long z,x;
int tot=1,bg[55005],N[55005],o;
struct S{
    int nxt,to;
    long long val;
}s[310005];
void add(int x,int y,long long z){
    s[++tot].nxt=bg[x];
    s[tot].val=z;
    s[tot].to=y;
    bg[x]=tot;

    s[++tot].nxt=bg[y];
    s[tot].val=0;
    s[tot].to=x;
    bg[y]=tot;
}
long long dis[55005];
bool bfs(){
    queue<int> q;
    q.push(1);
    memset(dis,0x3f,sizeof(dis));
    dis[1]=1; N[1]=bg[1];
    while(!q.empty()){
        int h=q.front(); q.pop();
        for(int j=bg[h];j;j=s[j].nxt)
            if(s[j].val&&dis[s[j].to]==dis[0]){
            N[s[j].to]=bg[s[j].to];
                dis[s[j].to]=dis[h]+1;
                q.push(s[j].to);
                if(s[j].to==n) return 1;
            }
    }
    return 0;
}
long long ans;
long long dfs(int x,long long minn){
    if(x==n) return minn;
    long long sum=0;bool f=0;
    for(int &j=N[x];j&&minn;j=s[j].nxt)
        if(s[j].val&&dis[s[j].to]==dis[x]+1){
            f=1;
            long long k=dfs(s[j].to,min(minn,s[j].val));
            if(!k) continue;
            s[j].val-=k;
            s[j^1].val+=k;
            sum+=k;
            minn-=k;
        }
    return sum;
}
int main(){
    long long Ans=0;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%lld",&z),add(1,i+1,z);
    for(int i=1;i<=m;i++){
        scanf("%d%d%lld",&x,&y,&z);
        add(n+1+i,n+m+2,z);
        add(x+1,i+n+1,0x3f3f3f3f3f3f3f3f);
        add(y+1,i+n+1,0x3f3f3f3f3f3f3f3f);
        Ans+=z;
    }
    n=n+m+2;
    while(bfs()) ans+=dfs(1,dis[0]);
    printf("%lld",Ans-ans);
    return 0;
}
```

---

## 作者：lhc0707 (赞：0)

我们发现这个题计算答案时可以用总的收益减去最小代价，二最小代价相当于不要的收益和耗费的代价的总和，于是我们想到了[太空飞行计划问题](https://www.luogu.com.cn/problem/P2762)，类比一下容易想到将用户群看作二分图中的一部分，每个点的点权是建立用户群的贡献；将通讯中转站看成二分图中的另一部分，每个点的点权为 $-p_i$，这样我们得到了一个二分图上的最大权闭合子图问题，于是我们有建边：

1. 建立源点 $s$ 与汇点 $t$，用户群连 $s$，容量设为 $C_i$，中转站连 $t$，容量设为 $p_i$。
2. 对于每个有依存关系的用户群和中转站，从用户群向中转站连边，容量为正无穷。

然后我们跑一边网络最大流，根据最大流最小割定理，就可以求出答案。

代码：

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
using namespace std;
const int N=600005,INF=1e9;
int n,m,p[N],head[N],tot=1,s,t;
struct edge{
	int v,w,nxt;
}e[N<<1];
inline void add(int u,int v,int w)
{
	e[++tot].v=v,e[tot].w=w;
	e[tot].nxt=head[u],head[u]=tot;
}
inline void addedge(int u,int v,int w){add(u,v,w),add(v,u,0);}
queue<int> q;
int dis[N],cur[N],sum;
bool bfs()
{
	for(int i=1;i<=t;i++)dis[i]=-1;
	dis[s]=0;q.push(s);
	while(!q.empty())
	{
		int u=q.front();q.pop();
		for(int i=head[u];i;i=e[i].nxt)
		{
			int v=e[i].v;
			if(e[i].w&&dis[v]==-1)
			{
				dis[v]=dis[u]+1;
				q.push(v);
			}
		}
	}
	return dis[t]!=-1;
}
int dfs(int u,int minf)
{
	if(u==t||!minf) return minf;
	int flow=0,f;
	for(int i=cur[u];i;i=e[i].nxt)
	{
		int v=e[i].v;cur[u]=i;
		if(dis[v]==dis[u]+1&&e[i].w&&(f=dfs(v,min(minf,e[i].w))))
		{
			e[i].w-=f,e[i^1].w+=f,minf-=f,flow+=f;
			if(!minf) return flow;
		}
	}
	return flow;
}
inline int dinic()
{
	int maxflow=0;
	while(bfs())
	{
		for(int i=1;i<=t;i++)cur[i]=head[i];
		maxflow+=dfs(s,INF);
	}
	return maxflow;
}
int main()
{
	cin.tie(0)->sync_with_stdio(false);
	cout.tie(0);	
	cin>>n>>m; s=n+m+1,t=n+m+2; 
	for(int i=1;i<=n;i++) 
	{
		cin>>p[i];
		addedge(i+m,t,p[i]);
	}
	for(int i=1;i<=m;i++)
	{
		int u,v,w;cin>>u>>v>>w;sum+=w;
		addedge(i,u+m,INF),addedge(i,v+m,INF),addedge(s,i,w);
	}
	int ans=dinic();
	cout<<sum-ans;
	return 0;
}
```

---

## 作者：Filberte (赞：0)

[题目传送门 ](https://www.luogu.com.cn/problem/P4174)

## 思路

首先你需要知道一个经典问题：最大权闭合子图。

问题描述：给定一个无向图 $G = (V,E)$，点有点权，求这个图的**最大权闭合子图**。闭合子图：选了任意一个点，就必须选它的全部后继。

考虑最小割构图，将原图中的边都设置成流量无穷大的边，另立源点和汇点。对于点 $u$，若其点权为正，则源点向其连边，否则向汇点连边。流量均为点权的绝对值。

结论：在新图中，设正权值和为 $w$，最小割为 $c$，则答案为 $w - c$。具体证明可以参考胡伯涛的集训队论文《最小割模型在信息学竞赛中的应用》。

有了以上的基础，看着一题就简单了。对于一个客户，其依赖于两个不同的中转站，相当于这两个中转站是它的后继。而中转站就是出度为 $0$ 的点。至此，我们把问题转化成了最大权闭合子图。

网络流嘛，复杂度玄学一点正常。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 55050;
int n, m;
const int s = 0, t = N - 1, inf = 2e9;
struct {
    int to, nxt, w;
}e[N << 3];int h[N], idx = 1;
void add(int u, int v, int w){
    e[++idx] = {v, h[u], w};h[u] = idx;
    e[++idx] = {u, h[v], 0};h[v] = idx; 
}
int d[N], cur[N];
bool bfs(){
    memset(d, 0, sizeof(d));
    memcpy(cur, h, sizeof(h));
    queue<int> q;q.push(s);d[s] = 1;
    while(!q.empty()){
        int u = q.front();q.pop();
        for(int i = h[u];i;i = e[i].nxt){
            int v = e[i].to;
            if(!d[v] && e[i].w){
                d[v] = d[u] + 1;
                q.push(v);
                if(v == t) return 1;
            }
        }
    }
    return 0;
}
int dfs(int u, int flow){
    if(u == t) return flow;
    int sum = 0;
    for(int &i = cur[u];i;i = e[i].nxt){
        int v = e[i].to;
        if(d[v] == d[u] + 1 && e[i].w){
            int gt = dfs(v, min(flow, e[i].w));
            e[i].w -= gt, e[i ^ 1].w += gt;
            flow -= gt, sum += gt;
            if(!flow) break;
        }
    }
    if(!sum) d[u] = 0;
    return sum;
}
int dinic(){
    int sum = 0;
    while(bfs()) sum += dfs(s, inf);
    return sum;
}
int main(){
    cin >> n >> m;
    for(int i = 1, x;i <= n;i++){
        cin >> x;
        add(i, t, x);
    }
    int ans = 0;
    for(int i = 1, x, y, z;i <= m;i++){
        cin >> x >> y >> z;
        add(s, i + n, z);
        add(i + n, x, inf);
        add(i + n, y, inf);
        ans += z;
    }
    ans -= dinic();
    cout << ans << endl;
}
```

---

## 作者：block_in_mc (赞：0)

## 题目大意

有 $N$ 个通讯中转站，建立第 $i$ 个通讯中转站成本为 $P_i$ 元。有 $M$ 个客户，每个客户有 $A,B,C$ 三个属性，代表若建设了 $A,B$ 两个通讯中转站，就能获得 $C$ 元。求你所能获得的利润的最大值。

## 解题思路

先来解释一下什么是最大权闭合子图：

对于一个有向图的子图，若从其中的任意一个点出发都无法到达子图外的点，则称这个子图为**闭合子图**。最大权闭合子图则为所有闭合子图中点权和最大的一个。其实际意义为事件间的依赖关系，一个事件要发生，它需要的所有前提也都一定要发生。

考虑如何求出最大权闭合子图的点权和：建立新的源点 $s$ 和汇点 $t$，对于原图中的每个点，若其点权为正，将其与源点 $s$ 连接，否则将其与汇点 $t$ 连接，容量为其点权的绝对值；对于原图中的边，仍然按照原样连接，容量为 $\inf$。正点权之和减去最小割（即最大流）即为最大权闭合子图的点权和。证明省略。

本题就是最大权闭合子图的模板题，我们可以这样建图：

* 将每个通讯中转站与汇点 $t$ 相连，边权为成本；
* 将每个客户与源点 $s$ 相连，边权为收益；
* 将每个客户与其对应的两个通讯中转站相连，边权为 $\inf$。

答案即为收益和减最小割（即最大流）。

考虑这样做的实际意义：对于图 $s\rightarrow a\rightarrow x,y\rightarrow t$，有两个选择：

* 割去边 $s\rightarrow a$，代表不满足客户 $a$ 的要求，减去了满足 $a$ 所能得到的收益；
* 割去边 $x,y\rightarrow t$，代表满足客户 $a$ 的要求，减去了建设 $x,y$ 的成本，得到了满足 $a$ 的收益。

AC 代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5, M = 5e5;
struct edge { int st, ed, v; } e[M];
vector<int> g[N];
int n, m, s, t, u, v, x, sum, ans, cnt = -1, dep[N];
void add(int st, int ed, int v) {
    e[++cnt] = {st, ed, v};
    g[st].push_back(cnt);
    e[++cnt] = {ed, st, 0};
    g[ed].push_back(cnt);
}
bool bfs() {
    memset(dep, 0, sizeof dep); dep[s] = 1;
    queue<int> q; q.push(s);
    while (!q.empty()) {
        int p = q.front(); q.pop();
        for (int id : g[p]) {
            edge ed = e[id];
            if (!dep[ed.ed] && ed.v) {
                dep[ed.ed] = dep[ed.st] + 1;
                q.push(ed.ed);
            }
        }
    }
    return dep[t];
}
int dfs(int p, int flow) {
    if (p == t || flow <= 0) return flow;
    int rest = flow;
    for (int id : g[p]) {
        edge ed = e[id];
        if (dep[ed.ed] == dep[ed.st] + 1 && ed.v) {
            int vl = dfs(ed.ed, min(rest, ed.v));
            if (!vl) dep[ed.ed] = 0;
            e[id].v -= vl, e[id ^ 1].v += vl, rest -= vl;
        }
    }
    return flow - rest;
}
void dicnic() {
    while (bfs()) {
        while (true) {
            int flow = dfs(s, 0x3f3f3f3f);
            ans += flow;
            if (!flow) break;
        }
    }
}
int main() {
    scanf("%d%d", &n, &m);
    s = 0, t = n + m + 1;
    for (int i = 1; i <= n; i++) {
        scanf("%d", &x);
        add(s, i, x);
    }
    for (int i = 1; i <= m; i++) {
        scanf("%d%d%d", &u, &v, &x);
        add(u, i + n, 0x3f3f3f3f);
        add(v, i + n, 0x3f3f3f3f);
        add(i + n, t, x);
        sum += x;
    }
    dicnic();
    printf("%d", sum - ans);
    return 0;
}
```

---

## 作者：under_the_time (赞：0)

## 题意

> 给定 $n$ 个点，选择第 $i$ 个点需要 $P_i$ 的代价；有 $m$ 个点对，对于第 $i$ 个点对 $(A_i,B_i)$，如果同时选择 $A_i,B_i$ 那么可以获得 $C_i$ 的收益。最大化总收益减总代价。

## 解法

考虑将问题转化为一种网络流模型。先介绍一个很常用的模型：**最大权值闭合图**。它的内容如下：

> 给定 $n$ 个点 $m$ 条边的有向图，第 $i$ 个点有点权 $A_i$，有正有负；求一个权值和最大的子图 $G$，使得 $\forall i\in G$，对于所有 $i\to j$ 的边都有 $j\in G$。

对于这个模型，考虑将其转化为最小割问题。我们建立一个超级源点 $S$ 和超级汇点 $T$，然后根据 $A_i$ 的正负进行讨论：

- 若 $A_i>0$，那么 $S$ 向 $i$ 连一条有向边，边权为 $A_i$；
- 若 $A_i<0$，那么 $i$ 向 $T$ 连一条有向边，边权为 $-A_i$。

最后将原图上原有的有向边都附加一个 $+\infty$ 的边权，根据最大流最小割定理，我们跑出网络最大流，最后所有正点权之和减最大流即为所求。考虑这个构图求解的正确性：

- 每一个割的方案都将网络分为两部分，与源点 $S$ 相连的部分都满足没有变指向另一部分，故每一个合法子图都对应网络中的一个割；
- 最小割的方案中去除的边必须与 $S$ 和 $T$ 中的一个相连；
- 选择的点权之和，等价于所有正点权之和 $-$ 未选择的正点权的点的点权和 $+$ 选择的负点权的点的点权和。当我们放弃选择一个正点权的点时，在构建出的网络中 $S$ 与它的连边会被割掉；同理放弃一个负点权的点就会使它与 $T$ 的边断开。
- 断开边的边权之和即为割的容量。所以上式可以转化为：权值和等价于所有正点权和 $-$​ 割的容量。

现在，我们考虑将原题转化为这个模型。先给出建图方法：我们将每个基站建一个点，第 $i$ 个基站的点权为 $-P_i$；然后将每个用户群建一个点，第 $i$ 个用户群点权为 $C_i$ 且分别向 $A_i$ 和 $B_i$ 两个基站连有向边。这样按照上述模型的做法即可得到答案。其中，我们连的有向边，在模型中就相当于选了这个用户群就要满足它的需求。综上我们按照这个建图方法代入模型即可。

## 实现

实现时采用 Dinic 算法，注意链式前向星的边数组要开到 $6\times m+2\times n$。时间复杂度 $O(n^2m)$。对于不熟悉 Dinic 实现的读者可以参考代码。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 5005, maxm = 50005;
int n,m,p[maxn];
const int All = maxn + maxm; // 模型中的总点数
const int inf = 0x3f3f3f3f;
int head[All], cnt = 1;
struct Edge {
    int to,nxt,val;
    Edge(int x = 0, int y = 0,int z = 0) {
        to = x, nxt = y, val = z;
    }
} e[((maxm << 1) * 3) + (maxn << 1)];
void addEdge(int u,int v,int w) {
    e[++ cnt] = Edge{v,head[u],w};
    head[u] = cnt;
}
int dep[All], s, t, N, g[All];
queue<int> q;
bool bfs() { // bfs 对图进行分层
    memset(dep,0x3f,sizeof(dep));
    dep[s] = 0; q.push(s);
    for (int i = 0;i <= N + 1;i ++)
        g[i] = head[i];
    while (q.size()) {
        int u = q.front(); q.pop();
        for (int i = head[u];i;i = e[i].nxt) {
            int v = e[i].to, w = e[i].val;
            if (dep[v] < inf || w == 0) continue;
            dep[v] = dep[u] + 1; q.push(v);
        }
    } return dep[t] < inf;
}
int dfs(int u,int t,int lim) { // dfs 寻找增广路进行增广
    if (u == t || !lim) return lim;
    int flow = 0;
    for (int i = g[u];i;i = e[i].nxt) {
        int v = e[i].to, tmp; g[u] = i;
        if (dep[v] == dep[u] + 1 && (tmp = dfs(v,t,min(lim,e[i].val)))) {
            flow += tmp, lim -= tmp;
            e[i].val -= tmp, e[i ^ 1].val += tmp;
            if (!lim) break;
        }
    }
    return flow;
}
int Dinic() {
    int ans = 0;
    while (bfs())
        ans += dfs(s,t,inf);
    return ans;
}
int main() {
    scanf("%d%d",&n,&m);
    s = 0, t = n + m + 1, N = n + m;
    for (int i = 1;i <= n;i ++) {
        scanf("%d",&p[i]);
        addEdge(i,t,p[i]); addEdge(t,i,0);
    } int sum = 0;
    for (int i = n + 1,u,v,w;i <= n + m;i ++) {
        scanf("%d%d%d",&u,&v,&w); sum += w;
        addEdge(i,v,inf), addEdge(v,i,0);
        addEdge(i,u,inf), addEdge(u,i,0);
        addEdge(s,i,w), addEdge(i,s,0);
    } printf("%d",sum - Dinic());
    return 0;
}
```

---

## 作者：sangshang (赞：0)

# Description

有 $n$ 个中转站，$m$ 个用户。

每个中转站都有一个使用费用 $P_i$。每个中转站要么建造，花费 $P_i$ 的钱；要么不建造，不花费。

每个用户，有三个属性 $A_i,B_i,C_i$。如果要满足他的要求，$A_i,B_i$ 这两个中转站就必须建造，同时，满足他可获得 $C_i$ 的钱。

# Solution

看到用户对中转站的依赖关系，可以想到最大权闭合子图。

将题目化成如下形式：

>有 $n+m$ 个物品，分成 $A,B$ 两类。$A$ 类价值为负，同时没有它所依赖的物品；$B$ 类价值为正，同时每个 $B$ 物品依赖两个 $A$ 物品。价值是指选择物品对总价值的影响。依赖是指：若 $a$ 依赖 $b$，若想选择 $a$ 必须带上 $b$。

这很明显是最大权闭合子图模板。

最大权闭合子图的定义：

>对于图 $G=(V,E)$，选出一个子图，$G'=(V',E'),V'\in V,E'\in E$，并且对于子图中的任意一点，都无法走出子图，则称 $G'$ 是 $G$ 的闭合子图。闭合子图中，点的权值和最大的就是最大权闭合子图。

题目中依赖关系很符合最大权闭合子图的定义。“*无法走出闭合子图*”就表示所依赖的点也一定被选中。

使用网络流求解。

>对于一个点 $u$，若权值 $val_u$ 为正，连边 $(s,u,val_u)$，（三元组分别表示起点，终点，容量）,并用一个 $sum$ 累记权值为正的点的权值和。否则连边 $(u,t,|val_u|)$。对于 $u$ 依赖 $v$，连边 $(u,v,+\infty)$。答案就是 $sum-$ 最大流（最小割）。

思考一下为什么这么做。对于点 $u$，若源点可到达 $u$，则表示选 $u$。考虑先将所有权值为正的点都选了，它们都是源点可到达的，应连边源点到它们，容量为价值。如果要废弃 $u$，应割掉源点到 $u$ 的边，同时，获得价值少了 $val_u$。对于依赖关系 $u\to v$，连边 $(u,v,+\infty)$。这样如果 $u$ 被选，即源点可到达 $u$，那 $v$ 源点也可到达，即 $v$ 也一定要选。若 $u$ 价值为负，连边 $(u,t,|val_u|)$。若被选了，即源点可到达 $u$，那必须割掉 $u\to t$ 的边，总价值 $-|val_u|$。最后，$sum$ 减最小割就是答案。

# Code

```cpp
#include <bits/stdc++.h>
using namespace std;

class Dinic {
	public:
		typedef int TYPE;
		static const int maxn = 55005, inf = 0x7f7f7f7f, maxm = inf;
		class edge {
			public:
				int to, rev;
				TYPE flow;
				edge(int to, TYPE flow, int rev): to(to), flow(flow), rev(rev) {}
				edge() {}
		};
		vector<edge>vec[maxn];
		int h[maxn], cur[maxn], n, m, s, t;
		Dinic(int n, int m, int s, int t): n(n), m(m), s(s), t(t) {}
		Dinic() {}
		inline bool bfs() {
			int que[maxn], front = 0, back = -1;
			memset(h, inf, sizeof(h)), h[t] = 0;
			memset(cur, 0, sizeof(cur));
			for (que[++back] = t; front <= back;) {
				int u = que[front++];
				for (edge &e : vec[u]) {
					int &v = e.to;
					if (vec[v][e.rev].flow && h[v] == inf) {
						que[++back] = v;
						h[v] = h[u] + 1;
					}
				}
			}
			return h[s] != inf;
		}
		inline TYPE dfs(int u, TYPE flow) {
			if (u == t || !flow) {
				return flow;
			}
			TYPE res = 0;
			int siz = vec[u].size();
			for (int i = cur[u]; i < siz && flow; ++i) {
				cur[u] = i;
				edge &e = vec[u][i];
				int &v = e.to;
				if (e.flow && h[v] + 1 == h[u]) {
					TYPE tmp = dfs(v, min(flow, e.flow));
					flow -= tmp, res += tmp;
					e.flow -= tmp, vec[v][e.rev].flow += tmp;
				}
			}
			return res ? res : (h[u] = inf, res);
		}
		inline TYPE GetMaxFlow() {
			TYPE res = 0;
			while (bfs()) {
				TYPE tmp = 0;
				while ((tmp = dfs(s, inf))) {
					res += tmp;
				}
			}
			return res;
		}
		inline void Add_Edge(int from, int to, TYPE flow) {
			vec[from].push_back(edge(to, flow, vec[to].size()));
			vec[to].push_back(edge(from, 0, vec[from].size() - 1));
		}
		inline void Solve() {
			int N, M;
			cin >> N >> M;
			this[0] = Dinic(N + M + 3, inf, 0, N + M + 2);
			TYPE sum = 0;
			for (int i = 1; i <= N; ++i) {
				int cost;
				cin >> cost;
				Add_Edge(i + M, t, cost);
			}
			for (int i = 1; i <= M; ++i) {
				int u, v, val;
				cin >> u >> v >> val;
				sum += val;
				Add_Edge(i, u + M, inf);
				Add_Edge(i, v + M, inf);
				Add_Edge(s, i, val);
			}
			cout << sum - GetMaxFlow() << "\n";
		}
};
Dinic Main;

int main() {
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	Main.Solve();
	return 0;
}
```


---

## 作者：Infiltrator (赞：0)

[$\Large\color{#FFBBFF}\textit{Tian-Xing's blog}$](https://Tian-Xing.github.io)

------------

# Description

[传送门](https://www.luogu.com.cn/problem/P4174)

------------

# Solution

经典的最大权闭合子图问题。

首先$S$向每个中转站连容量为费用的有向边。

每个群体向$T$连容量为收益的有向边。

如果一个中转站的点被割了，那么相当于建立这个中转站；如果一个群体被割了相当于不选这个群体。

那么答案就是所有群体的利益减去最小割。

由于每个群体有必须使用的中转站，所以把必须使用的中转站向群体连容量为$INF$的边，这样要不就是割掉群体（不选这个群体），要不就是割掉中转站（建立中转站），$INF$边的作用是避免冲突。

------------

# Code

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;

const int INF = 999999999;
const int N = 500050;
const int M = 400050;

int head[N], num = 1, n, m, s, t, ans, maxflow, dis[N];

struct Node
{
    int next, to, dis;
} edge[M * 2];

void Addedge(int u, int v, int w)
{
    edge[++num]= (Node){head[u], v, w};
    head[u] = num;
}

template <class T>
void Read(T &x)
{
    x = 0; int p = 0; char st = getchar();
    while (st < '0' || st > '9') p = (st == '-'), st = getchar();
    while (st >= '0' && st <= '9') x = (x << 1) + (x << 3) + st - '0', st = getchar();
    x = p ? -x : x;
    return;
}

template <class T>
void Put(T x)
{
    if (x < 0) putchar('-'), x = -x;
    if (x > 9) Put(x / 10);
    putchar(x % 10 + '0');
    return;
}

bool Bfs()
{
    queue<int> q;
    for (int i = 0; i <= t; i++) dis[i] = 0;
    dis[s] = 1; q.push(s);
    while (!q.empty())
    {
        int u = q.front(); q.pop();
        for (int i = head[u]; i; i = edge[i].next)
            if (!dis[edge[i].to] && edge[i].dis)
            {
                dis[edge[i].to] = dis[u] + 1;
                q.push(edge[i].to);
                if (edge[i].to == t) return 1;
            }
    }
    return 0;
}

int Dinic(int x, int flow)
{
    if (x == t || !flow) return flow;
    int rest = flow;
    for (int i = head[x]; i && rest; i = edge[i].next)
        if (edge[i].dis && dis[edge[i].to] == dis[x] + 1)
        {
            int v = edge[i].to;
            int tmp = Dinic(v, min(rest, edge[i].dis));
            rest -= tmp;
            edge[i].dis -= tmp;
            edge[i ^ 1].dis += tmp;
            if (!tmp) dis[v] = 0;
        }
    return flow - rest;
}

void Add(int u, int v, int w)
{
	Addedge(u, v, w);
	Addedge(v, u, 0);
	return;
}

int Maxflow()
{
	int maxflow = 0, tmp;
	while (Bfs())
	{
		tmp = Dinic(s, INF);
		if (tmp) maxflow += tmp;
	}
	return maxflow;
}

int main()
{
	Read(n); Read(m);
	s = 0; t = n + m + 1;
	for (int i = 1, p; i <= n; i++) Read(p), Add(s, i, p);
	for (int i = 1, a, b, c; i <= m; i++)
	{
		Read(a); Read(b);Read(c);
		ans += c;
		Add(i + n, t, c);
		Add(a, i + n, INF);
		Add(b, i + n, INF);
	}
	Put(ans - Maxflow());
    return 0;
}
```

---

## 作者：kouylan (赞：0)

## 题解 P4174 【[NOI2006]最大获利】

### 【[题意](https://www.luogu.com.cn/problem/P4174)】
从$n$个点中选出若干点，包括连接的边，问最大点边权和是多少。

### 【分析】

看到最大权值和，就很自然的想到了最大权闭合子图。

### 1. 什么是闭合子图？

**定义**：在一张图内，选出一个子图，子图内的点无法到达子图外的点。

如下图：

![pic](https://cdn.luogu.com.cn/upload/image_hosting/wphk07wp.png)

图中，$(1,2,3,4)$是一个闭合子图，而$(1,2,4)$不是。

### 2. 最大权闭合子图如何求？

利用网络流，构造一个源点$s$和汇点$t$。所有的正权点连向$s$，容量为点权；所有的负权点连向$t$，容量为点权的相反数；图中现有边取反向边，流量为无穷大。

然后我们在这张图上跑最小割，再用正权点的点权和减去最小割，即为答案。

~~不要问我如何证明，本萌新不会QAQ。~~

### 3. 本题如何建图？

我们不要受题目所惑，我们发现，任意一条边的存在肯定要求两端点存在，正符合最大权闭合子图的性质，所以我们把所有的点和边都当成网络流的点，直接跑最小割即可。

下面是AC代码（使用ISAP）：

```cpp
/*
luogu P4174
*/
#include <bits/stdc++.h>
using namespace std;

const int INF = 0x7f7f7f7f;

int n,m,s,t;
int mxf,sum;
int ee=1,h[500005],nex[500005<<1],to[500005<<1],val[500005<<1];
int dep[500005],gap[500005];

void addedge(int x,int y,int z)
{
	nex[++ee] = h[x];
	to[ee] = y;
	val[ee] = z;
	h[x] = ee;
}

void bfs()
{
	queue<int> q;
	q.push(t);
	dep[t] = 1;
	gap[1] = 1;
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		for(int i=h[x];i;i=nex[i])
			if(!dep[to[i]])
			{
				dep[to[i]] = dep[x]+1;
				gap[dep[to[i]]]++;
				q.push(to[i]);
			}
	}
}

int dfs(int x,int flow)
{
	if(x==t)
	{
		mxf += flow;
		return flow;
	}
	int used=0;
	for(int i=h[x];i;i=nex[i])
		if(dep[to[i]]==dep[x]-1 && val[i]>0)
		{
			int d=dfs(to[i],min(val[i],flow-used));
			if(d)
			{
				val[i] -= d;
				val[i^1] += d;
				used += d;
			}
			if(used==flow)
				return used;
		}
	gap[dep[x]]--;
	if(gap[dep[x]]==0)
		dep[s] = n+m+1;
	dep[x]++;
	gap[dep[x]]++;
	return used;
}

void isap()
{
	mxf = 0;
	bfs();
	while(dep[s]<=n+m)
		dfs(s,INF);
}

int main()
{
	cin>>n>>m;
	s = 0, t = n+m+1;
	for(int i=1,x;i<=n&&cin>>x;i++)
		addedge(i,t,x), addedge(t,i,0);
	for(int i=1,x,y,z;i<=m&&cin>>x>>y>>z;i++)
	{
		sum += z;
		addedge(s,i+n,z), addedge(i+n,s,0);
		addedge(i+n,x,INF), addedge(x,i+n,0);
		addedge(i+n,y,INF), addedge(y,i+n,0);
	}
	isap();
	cout<<sum-mxf<<endl;
	
	return 0;
}
```

祝大家AC愉快！

---


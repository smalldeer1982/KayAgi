# [COTS 2023] 三元图 Graf

## 题目背景

译自 [Izborne Pripreme 2023 (Croatian IOI/CEOI Team Selection)](https://hsin.hr/pripreme2023/) D1T1。$\texttt{2s,0.5G}$。

祝 NaCly_Fish 生日快乐！（2024.7.28）

## 题目描述


对于非负整数 $k$，我们递归地给出 $k-{}$三元图的定义。

- $k-{}$三元图是无向图。
- 对于 $k=0$，$k-{}$三元图 是一个仅包含 $1$ 个节点和 $0$ 条边的图。
- 对于 $k\gt 0$，$k-{}$三元图由三个 $(k-1)-{}$三元图组合而成。具体地说，在这三个 $(k-1)-{}$三元图中各选择一个节点，然后在这三个节点之间两两连边，得到的就是 $k-{}$三元图。

下图展示了一张 $3-{}$三元图。

![](https://cdn.luogu.com.cn/upload/image_hosting/fyidau35.png)


给定无向图 $G$，判断它是否是 $k-{}$三元图。



## 说明/提示


#### 样例解释

样例 $3$ 解释：这是一张 $2-{}$三元图。

#### 数据范围

对于 $100\%$ 的数据，保证：

- $1\le N\le 200\, 000$，$0\le M\le 300\, 000$；
- $1\le u,v\le N$。

| 子任务编号 | 分值 | 约束  |
|:-----:|:------:|:-------:|
| $1$  | $15$  | $N \leq 10$，$M\le 20$   |
| $2$  | $20$  | $N \leq 1000$，$M\le 2000$  |
| $3$  | $15$  | 满足特殊性质 |
| $4$  | $50$  | 无额外约束 |

特殊性质：若 $G$ 是 $k-{}$三元图，保证每一步选择的 $3$ 个节点在之前已经被选中过。换句话说，总是选中「中间的节点」。


## 样例 #1

### 输入

```
3 3
1 2
2 3
3 1```

### 输出

```
da```

## 样例 #2

### 输入

```
9 12
1 2
2 3
3 1
3 4
4 5
3 5
5 6
6 7
7 5
7 8
9 8
7 9```

### 输出

```
ne```

## 样例 #3

### 输入

```
9 12
1 2
2 3
3 1
4 5
5 6
6 4
7 8
8 9
9 7
1 7
7 4
4 1```

### 输出

```
da```

# 题解

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/P10829)

**题目大意**

> 定义一个图是好的，当且仅当图上恰有一个点，或可以由三个大小相等的好图各选出一个点连出三元环得到。
>
> 给定一个 $n$ 个点 $m$ 条边的无向图，判定该图是否是好的。
>
> 数据范围：$n\le 2\times 10^5,m\le 3\times 10^5$。

**思路分析**

考虑如何刻画好的图，在无向图上不好处理问题，注意到这张图是边仙人掌，可以建出圆方树。

那么原图上的每个环对应一个方点，最特殊的显然是最后一次加入的环，即某个方点删去后整棵树变成大小相同的三部分，且每部分都是好的。

那么这个方点显然就是圆方树的重心，容易证明一张图是好的当且仅当其圆方树的点分树是完美三叉树。

实现的时候可以在建圆方树时直接判断每个边双联通分量大小是否为 $3$，点分治的时候要维护一下深度方便判定大小相等。

时间复杂度 $\mathcal O(n+m)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=5e5+5;
int n,m,tot,dfn[MAXN],low[MAXN],dcnt,stk[MAXN],tp;
vector <int> G[MAXN],E[MAXN];
void link(int u,int v) { E[u].push_back(v),E[v].push_back(u); }
void tarjan(int u) {
	dfn[u]=low[u]=++dcnt,stk[++tp]=u;
	for(int v:G[u]) {
		if(!dfn[v]) {
			tarjan(v),low[u]=min(low[u],low[v]);
			if(low[v]>=dfn[u]) {
				int k,c=1; link(u,++tot);
				do ++c,link(k=stk[tp--],tot); while(k^v);
				if(c!=3) puts("ne"),exit(0);
			}
		} else low[u]=min(low[u],dfn[v]);
	}
}
int qk(int x) {
	int c=0;
	for(;x>1;x/=3,++c) if(x%3) puts("ne"),exit(0);
	return c;
}
int siz[MAXN],cur[MAXN];
bool vis[MAXN];
bool dfs1(int u,int k) {
	int cnt=0; vis[u]=true;
	for(int v:E[u]) cnt+=!vis[v];
	if(cnt!=(k?3:0)) puts("ne"),exit(0);
	function<void(int,int)> dfs2=[&](int x,int fz) {
		siz[x]=1;
		for(int y:E[x]) if(!vis[y]&&y!=fz) dfs2(y,x),siz[x]+=siz[y];
	};
	dfs2(u,0);
	for(int v:E[u]) if(!vis[v]) {
		int rt=0,mx=siz[v];
		function<void(int,int)> dfs3=[&](int x,int fz) {
			cur[x]=mx-siz[x];
			for(int y:E[x]) if(!vis[y]&&y!=fz) dfs3(y,x),cur[x]=max(cur[x],siz[y]);
			if(!rt||cur[x]<cur[rt]) rt=x;
		};
		dfs3(v,u);
		if(!dfs1(rt,k-1)) puts("ne"),exit(0);
	}
	return true;
}
signed main() {
	scanf("%d%d",&n,&m),tot=n;
	for(int i=1,u,v;i<=m;++i) scanf("%d%d",&u,&v),G[u].push_back(v),G[v].push_back(u);
	for(int i=1;i<=n;++i) {
		sort(G[i].begin(),G[i].end());
		if(unique(G[i].begin(),G[i].end())!=G[i].end()) return puts("ne"),0;
	}
	tarjan(1);
	for(int i=1;i<=n;++i) if(!dfn[i]) return puts("ne"),0;
	int rt=0,mx=tot;
	function<void(int,int)> dfs3=[&](int x,int fz) {
		siz[x]=1;
		for(int y:E[x]) if(!vis[y]&&y!=fz) dfs3(y,x),cur[x]=max(cur[x],siz[y]),siz[x]+=siz[y];
		cur[x]=max(cur[x],mx-siz[x]);
		if(!rt||cur[x]<cur[rt]) rt=x;
	};
	dfs3(1,0);
	puts(dfs1(rt,qk(n))?"da":"ne");
	return 0;
}
```

---

## 作者：xiezheyuan (赞：0)

# 思路

首先看到题中定义的这个结构，容易发现这玩意类似边仙人掌，于是可以考虑构造圆方树。

观察 $k$ 三元图的圆方树的性质，则每一个方点一定代表一个三元环，连向环上的点，由于这个三元图是递归构建的，所以具有很强的类似对称的性质，初始时一定存在一个方点，方点的所有子节点子树大小相同，所以它是重心。以此类推，我们发现这个过程类似点分治，每次先选择原树的重心，在选取儿子节点为根的子树的重心，以此类推。

然后考虑如何着手去做判定，我们可以用一个简单的策略，如果是方点为重心，则一定有三个直接相连的节点，如果圆点为重心，则子树大小一定为 $1$。这样的话可以精确覆盖三元图的圆方树，不过要注意重心优先选方点而不是圆点。

注意如果有重边或子环，或者原图不联通，也是不行的。

时间复杂度 $O(n+m)$。

# 代码

```cpp
#include <bits/stdc++.h>
//#define int long long
using namespace std;

const int N = 4e5 + 5;
int n, m;
vector<int> g[N], tree[N];
map<pair<int,int>,bool> mmap;

int dfn[N], low[N], stk[N], top, dfncnt, tcnt;
bool vis[N], rect[N];

void tarjan(int u){
    dfn[u] = low[u] = ++dfncnt;
    stk[++top] = u;
    for(int v : g[u]){
        if(!dfn[v]){
            tarjan(v);
            low[u] = min(low[u], low[v]);
            if(low[v]>=dfn[u]){
                rect[++tcnt] = 1;
                while(top && stk[top] != v){
                    // cerr << stk[top] << " " << tcnt << endl;
                    tree[stk[top]].push_back(tcnt);
                    tree[tcnt].push_back(stk[top--]);
                }
                // cerr << stk[top] << " " << tcnt << endl;
                tree[stk[top]].push_back(tcnt);
                tree[tcnt].push_back(stk[top--]);
                // cerr << u << ' '<< tcnt << endl;
                tree[u].push_back(tcnt);
                tree[tcnt].push_back(u);
            }
        }
        else low[u] = min(low[u], dfn[v]);
    }
}

int siz[N], mxsiz[N], nowsiz, nowcenter;

void findroot(int u, int fa){
	siz[u] = 1; mxsiz[u] = 0;
	for(int v : tree[u]){
		if(v == fa || vis[v]) continue;
		findroot(v, u);
		mxsiz[u] = max(mxsiz[u], siz[v]);
		siz[u] += siz[v];
	}
	mxsiz[u] = max(mxsiz[u], nowsiz - siz[u]);
    if(mxsiz[u] == mxsiz[nowcenter]){
        if(rect[u]) nowcenter = u;
    }
	else if(mxsiz[u] < mxsiz[nowcenter]) nowcenter = u;
}


void solve(int u){
    vis[u] = 1;
    if(!rect[u] && siz[u] != 1){
        // cerr << "fault because " << u << " is not a rect but have an illegal size " << siz[u] << ' ' << mxsiz[u] << '\n';
        cout << "ne\n";
        exit(0);
    }
    if(rect[u] && tree[u].size() != 3){
        // cerr << "fault because " << u << " is a rect but have an illegal degree " << tree[u].size() << '\n';
        cout << "ne\n";
        exit(0);
    }
    for(int v : tree[u]){
        if(vis[v]) continue;
		nowsiz = siz[v];
		mxsiz[nowcenter = 0] = INT_MAX;
        findroot(v, 0);
        findroot(nowcenter, 0);
        solve(nowcenter);
    }
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    cin >> n >> m;
    for(int i=1;i<=m;i++){
        int x, y;
        cin >> x >> y;
        g[x].push_back(y);
        g[y].push_back(x);
        if(mmap[{x, y}] || x == y){
            cout << "ne\n";
            return 0;
        }
        mmap[{x, y}] = mmap[{y, x}] = 1;
    }
    tcnt = n;
    tarjan(1);
    for(int i=1;i<=n;i++){
        if(!dfn[i]){
            cout << "ne\n";
            return 0;
        }
    }
    nowsiz = mxsiz[0] = tcnt;
	findroot(1, 0);
    findroot(nowcenter, 0);
	solve(nowcenter);
    cout << "da\n";
    return 0;
}

// Written by xiezheyuan
```

---

## 作者：_Ch1F4N_ (赞：0)

简单题。

首先我们考虑这样一件事，在生成新图时，连边的三个点在这之前一定是不联通的，也就是这张图上不能有重边与自环，然后我们从最终状态往前考虑，最后一次连边所涉及的三个点一定构成了一个点双，而且这个点双因为在形成前其内部点不联通，所以形成后这个点双的大小一定是 $3$，毕竟其他点进入点双都必须经过连边前其所在连通块中在这一次连边中涉及的 $1$ 个割点，到了这里就可以考虑建出圆方树，然后你发现新连边产生的方点度数一定为 $3$ 且将其去除后剩下的三个连通块大小（这里的连通块大小不算方点贡献）均为原来的 $\frac{1}{3}$，由于圆方树上方点一定与圆点相邻，所以满足条件的方点至多一个且必定是圆方树重心，而且在割去连的边后对圆方树产生的影响恰好是删除了这个方点以及其连向圆点的边，于是考虑类似点分治的处理即可。

时间复杂度 $O(n \log n)$。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 2e5+114;
map<int,int> use[maxn];
int n,m;
vector<int> G[maxn],T[maxn<<1];
int stk[maxn],tp,low[maxn],dfn[maxn],dfc;
int cnt;
void Tarjan(int u){
    low[u]=dfn[u]=++dfc;
    stk[++tp]=u;
    for(int v:G[u]){
        if(dfn[v]==0){
            Tarjan(v);
            low[u]=min(low[u],low[v]);
            if(low[v]>=dfn[u]){
                ++cnt;
                for(int x=0;x!=v;tp--){
                    x=stk[tp];
                    T[cnt].push_back(x);
                    T[x].push_back(cnt);
                }
                T[cnt].push_back(u);
                T[u].push_back(cnt);
            }
        }else low[u]=min(low[u],dfn[v]);
    }
}
bool flag;
int vis[maxn<<1];
int sz[maxn<<1];
int sum;
int H;
void dfs(int u,int fa){
    sz[u]=(u<=n);
    int Min=0x3f3f3f3f,Max=0;
    for(int v:T[u]){
        if(v!=fa&&vis[v]==0) dfs(v,u),sz[u]+=sz[v],Min=min(Min,sz[v]),Max=max(Max,sz[v]);
    }
    Min=min(Min,sum-sz[u]);
    Max=max(Max,sum-sz[u]);
    if(u>n){
        if(Min==sum/3&&Max==Min) H=u;
    }
}
void solve(int u,int sm){
    if(sm==1) return ;
    sum=sm;
    H=0;
    dfs(u,0);
    if(H==0){
        flag=true;
        return ;
    }
    vis[H]=1;
    if(sm%3!=0){
        flag=true;
        return ;
    }
    for(int v:T[H]){
        if(vis[v]==0){
            solve(v,sm/3);
            if(flag==true) return;
        }
    }
}
int main(){
    cin>>n>>m;
    cnt=n;
    for(int i=1;i<=m;i++){
        int u,v;
        cin>>u>>v;
        if(u==v){
            cout<<"ne\n";
            return 0;
        }
        if(use[u][v]==1){
            cout<<"ne\n";
            return 0;
        }
        use[u][v]=use[v][u]=1;
        G[u].push_back(v);
        G[v].push_back(u);
    }
    Tarjan(1);
    for(int i=1;i<=n;i++){
        if(dfn[i]==0){
            cout<<"ne\n";
            return 0;
        }
    }
    solve(1,n);
    cout<<(flag==false?"da\n":"ne\n");
    return 0;
}

```

---


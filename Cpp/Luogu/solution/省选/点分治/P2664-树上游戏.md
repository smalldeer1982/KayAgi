# 树上游戏

## 题目描述

lrb 有一棵树，树的每个节点有个颜色。给一个长度为 $n$ 的颜色序列，定义 $s(i,j)$ 为 $i$ 到 $j$ 的颜色数量。以及

$$sum_i=\sum_{j=1}^n s(i, j)$$

现在他想让你求出所有的 $sum_i$。


## 说明/提示

$$sum_1=s(1,1)+s(1,2)+s(1,3)+s(1,4)+s(1,5)=1+2+3+2+2=10$$
$$sum_2=s(2,1)+s(2,2)+s(2,3)+s(2,4)+s(2,5)=2+1+2+1+3=9$$
$$sum_3=s(3,1)+s(3,2)+s(3,3)+s(3,4)+s(3,5)=3+2+1+2+3=11$$
$$sum_4=s(4,1)+s(4,2)+s(4,3)+s(4,4)+s(4,5)=2+1+2+1+3=9$$
$$sum_5=s(5,1)+s(5,2)+s(5,3)+s(5,4)+s(5,5)=2+3+3+3+1=12$$


对于 $40\%$ 的数据，$n\leq 2000$。

对于 $100\%$ 的数据，$1\leq n,c_i\leq 10^5$。


## 样例 #1

### 输入

```
5
1 2 3 2 3
1 2
2 3
2 4
1 5```

### 输出

```
10
9
11
9
12```

# 题解

## 作者：b6e0_ (赞：111)

题目链接：<https://www.luogu.com.cn/problem/P2664>

有几篇 $\mathcal O(n)$ 解法的题解，但是都写的过于不清晰，甚至我会了还是看不懂，于是我重新从头到尾讲一遍 $\mathcal O(n)$ 的算法，尽量包含到每个细节。虽然不能完全确定我的和已经在这儿的题解完全一样，但是大致肯定都是一样的。

在本篇题解中，称节点 $i$ 的颜色为 $a_i$，节点 $i$ 的答案为 $sum_i$（如题面中）。

首先对求 $sum_i$ 的问题做出一个转换：对于每种颜色 $c$，计算有多少条从 $i$ 出发的路径不包含这种颜色，记为  $t_{i,c}$（此处看 $t$ 数组是 $n^2$ 的，这个疑问下面再解决）。那么 $n-t_{i,c}$ 就是有多少条从 $i$ 出发的路径包含颜色 $c$。这段的总体思想就是考虑每种颜色的贡献，再反过来算。

对于一种颜色 $c$，如果将所有颜色为 $c$ 的节点删除，与它连接的边也删除，那么整棵树会断成一些小的连通块（也就是其他题解中的“小树”）。对于任意一个连通块，它内部任意两个点之间在原树上的路径都不会有颜色 $c$。相反地，对于两个点，如果它们在不同的连通块内，那么它们之间在原树上的路径中一定有颜色 $c$。所以，对于一个大小为 $s$ 的连通块中的所有点 $x$，需要把 $t_{x,c}$ 加上 $s$。

如果第一重循环枚举了一个颜色，那么不管怎样都要遍历整棵树（即使有不遍历的方法也会非常复杂，大概这么觉得吧），时间复杂度就变为了 $\mathcal O(n^2)$，不能接受。于是，我们需要在一遍 dfs 中同时处理多种颜色，计算多种颜色的答案。

设当前枚举到了节点 $x$，它有若干子节点 $y_1,y_2,\cdots$。可以发现，如果我们删除掉所有颜色为 $a_x$ 的节点，那么一定存在一些连通块的“顶部”是 $y_1,y_2,\cdots$。下面的图表示了一个子节点 $y$ 的情况。红色圈起来的部分是一个以 $y$ 为顶部的连通块，它的大小是 $y$ 的子树大小减去 $y$ 的子树中所有颜色为 $c$ 的子树的大小。也就是说，我们在一个节点只处理一个颜色，即当前节点的颜色，也只需要处理这个颜色。如果没懂的话见代码实现难点的部分。

![](https://cdn.luogu.com.cn/upload/image_hosting/dtvsfg9m.png)

于是，我们能在一遍 dfs 中知道需要给 $t$ 数组的哪些位置加上什么数。下面要解决的就是优化掉 $t$ 的一维并且快速做加法。

在最后，$sum_i$ 是（$m$ 为颜色种数）：
$$\sum_{c=1}^m(n-t_{i,c})=nm-\sum_{c=1}^mt_{i,c}$$
于是我们只需要对于一个 $i$，求出所有颜色的答案的和就行了。记为 $t_i$。下面采用树上差分：设我们 dfs 到了 $x$，枚举到了子节点 $y$（也就是这个连通块的顶是 $y$），连通块的大小为 $s$，那么在节点 $y$ 处加 $s$，子树内最靠上的颜色为 $c$ 的节点处减 $c$。你肯定没看懂，看下图（如何求答案、正确性、复杂度证明等在图下）：

![](https://cdn.luogu.com.cn/upload/image_hosting/lyxrodc9.png)

最后 $t_x$ 是从 $x$ 到根节点路径上的差分值的和。这样，上图中那些 $c$ 的子树内就不会受到这个连通块带来的贡献（抵消了），$x$ 及外面更不会受到贡献（$x$ 确实不应该受到贡献）。

有关这个解法的复杂度，看起来一个一个给 $y$ 子树内的 $c$ 打标记很慢，其实，在一个节点以“$c$”的身份被打过标记后就再也不会以“$c$”的身份被打标记了。以“$y$”的身份打标记也显然只会有一次，所以总复杂度是 $\mathcal O(n)$ 的。至此，这个问题被完美解决。

代码实现还有几个不太好处理的细节：
- 如何快速计算 $y$ 的子树内那些如图中 $c$ 的子树大小的和，也就是连通块相比 $y$ 的子树缺失的部分。为解决这个问题，我们以颜色为下标开一个桶 $b_x$（即代码中的 `colsiz[x]`）记录那些极大的、根节点的颜色为 $x$ 的子树大小和。在 dfs 到 $x$，准备递归进入它的一个儿子 $y$ 前记录下 $b_{a_x}$ 的值（代码中的 `psiz`），在回来时比较一下现在的 $b_{a_x}$ 与之前的 $b_{a_x}$，差就是连通块相比 $y$ 的子树缺失的部分的大小。
- 对于上面的 $b$（`colsiz`）数组的更新，在每一个儿子 $y$ 算出连通块的大小 $s$（代码中的 `nsiz`）时，都将 $b_{a_x}$ 加上 $s$。最后在枚举完儿子后再加 $1$（节点 $x$）。
- 在打差分标记时，如何找出 $y$ 子树内如图中的那些 $c$ 节点打上减的标记。对于每种颜色 $c$ 开一个 `vector`（代码中的 `v[c]`），记录下所有（不管是否在 $y$ 的子树）根节点颜色为 $c$ 且极大的子树的根节点。在需要打标记时，由于刚刚递归进 $y$ 的子树，所以 $y$ 的子树内那些需要打标记的节点肯定在 $v_{a_x}$ 中的最前面。从 $v_{a_x}$ 的后面往前面循环，使用 dfs 序判断是否在 $y$ 的子树内，每找到一个符合要求的就打上标记并由于它不再极大了，执行 `pop_back`。在循环完所有子节点后，将 $x$ 压进 $v_{a_x}$ 中即可。
- 在第一遍 dfs 执行完后，对于每种颜色还剩下根节点那儿的一个连通块。利用当前记录下的 `colsiz[c]`，`v[c]` 等信息在主函数内打标记即可，具体见代码。

完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct edge
{
	int to,nxt;
}e[200005];
int h[100005],a[100005],dfn[100005],siz[100005],colsiz[100005],cnt;
long long cf[100005],dep[100005];
bool buc[100005];
vector<int>v[100005];
inline int read()
{
	char c=getchar();
	int x=0;
	while(c<'0'||c>'9')
		c=getchar();
	while(c>='0'&&c<='9')
	{
		x=(x<<3)+(x<<1)+c-'0';
		c=getchar();
	}
	return x;
}
void write(long long x)
{
	if(x>9)
		write(x/10);
	putchar(x%10+'0');
}
inline void adde(int x,int y)
{
	e[++cnt].to=y;
	e[cnt].nxt=h[x];
	h[x]=cnt;
}
void dfs(int x,int f)
{
	siz[x]=1;
	dfn[x]=++cnt;
	for(int i=h[x];i;i=e[i].nxt)
		if(e[i].to!=f)
		{
			int psiz=colsiz[a[x]];//记录下递归前的个数
			dfs(e[i].to,x);
			siz[x]+=siz[e[i].to];
			int nsiz=siz[e[i].to]+psiz-colsiz[a[x]];//此处意为siz[e[i].to]-(colsiz[a[x]]-psiz)
			colsiz[a[x]]+=nsiz;
			cf[e[i].to]+=nsiz;//打上加的标记
			while(v[a[x]].size()&&dfn[v[a[x]].back()]>dfn[x])//从后往前找
			{
				cf[v[a[x]].back()]-=nsiz;
				v[a[x]].pop_back();
			}
		}
	colsiz[a[x]]++;
	v[a[x]].push_back(x);
}
void dfs2(int x,int f)//根据差分数组计算最终答案
{
	dep[x]=dep[f]+cf[x];
	for(int i=h[x];i;i=e[i].nxt)
		if(e[i].to!=f)
			dfs2(e[i].to,x);
}
int main()
{
	int n=read(),m=0,tot=0,i,x,y;
	for(i=1;i<=n;i++)
	{
		a[i]=read();
		m=max(m,a[i]);
		buc[a[i]]=true;//记录一个颜色是否出现在a[i]中
	}
	for(i=1;i<n;i++)
	{
		x=read();
		y=read();
		adde(x,y);
		adde(y,x);
	}
	cnt=0;
	dfs(1,0);
	for(i=1;i<=m;i++)//处理包含1的那些连通块
		if(buc[i])
		{
			tot++;
			cf[1]+=n-colsiz[i];
			for(int j=0;j<v[i].size();j++)
				cf[v[i][j]]-=n-colsiz[i];
		}
	dfs2(1,0);
	for(i=1;i<=n;i++)
	{
		write(1ll*n*tot-dep[i]);
		putchar('\n');
	}
	return 0;
}
```

---

## 作者：sxd666888 (赞：97)

此题显然有**O（n）做法**，喵喵喵？

## 解法：

让我们考虑一种颜色对答案的贡献

我们考虑把树中这种颜色的点都删掉，那么就会有很多的小树，这些小树中的点互相之间不会产生贡献，而不同树的两个点之间会产生贡献。

由此，我们可以得到每一种颜色，点的sum值就是 **n - 所在小树的size**。

由此，一个点的sum就是 n * 颜色数 - 每种颜色节点时所在小树的size。

我们考虑对于一棵小树的size，存在深度最小的节点上，那么后面就可以用**树上差分**实现覆盖。

求size，在回溯时遇到与当前颜色相同的点，就把整一颗子树的节点都删掉，那么一个点的答案就是，** 子树的size - （当前删的个数 - 遍历时删的个数）**。

因为每个节点只有一个颜色，所以一个节点会记录一次答案，**特别的**根节点的父亲设为所有颜色都有，全部统计一下。然后就树上差分传递下去，统计答案。

具体看代码吧。。。喵喵汪!!!(~~奇丑无比~~)

```cpp
#include<bits/stdc++.h>
using namespace std;
long long read()
{
	char ch=getchar();long long x=0,ff=1;
	while(ch<'0'||ch>'9') {if(ch=='-') ff=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
	return x*ff;
}
void write(long long aa)
{
	if(aa<0) putchar('-'),aa=-aa;
	if(aa>9) write(aa/10);
	putchar('0'+aa%10);
	return;
}
long long n,sum,qwq;
long long vis[100005],ans[100005];
long long tot,head[100005],nx[200005],to[200005];
long long col[100005],sz[100005],jian[100005]；
long long lz[100005],bj[100005];
void jia(long long aa,long long bb)
{
	tot++;
	nx[tot]=head[aa];
	to[tot]=bb;
	head[aa]=tot;
	return;
}
void dfs(long long rt,long long fa)
{
	sz[rt]=1;
	long long tmp=jian[col[fa]];//遍历时删的个数
	for(long long i=head[rt];i;i=nx[i])
	{
		long long yy=to[i];
		if(yy==fa) continue;
		dfs(yy,rt);
		sz[rt]+=sz[yy];
	}
	jian[col[rt]]++;//删点
	if(fa)
	{
		lz[rt]=sz[rt]-jian[col[fa]]+tmp;//子树的size - （当前删的个数 - 遍历时删的个数）
		jian[col[fa]]+=lz[rt];//删点
	}
}
void getans(long long rt,long long fa)
{
	long long yuanbj=bj[col[fa]];
	qwq+=lz[rt]-bj[col[fa]];//差分啦
	bj[col[fa]]=lz[rt];
	ans[rt]=n*sum-qwq+bj[col[rt]];//自己颜色的显然是不能删掉的
	for(long long i=head[rt];i;i=nx[i])
	{
		long long yy=to[i];
		if(yy==fa) continue;
		getans(yy,rt);
	}
	bj[col[fa]]=yuanbj;
	qwq-=lz[rt]-bj[col[fa]];//还原啦
	return;
}
int main()
{
	n=read();
	for(long long i=1;i<=n;++i) 
	{
		col[i]=read();//col[i]<=100000,可能大于n。。。。
		if(!vis[col[i]]) vis[col[i]]=1,sum++;//sum颜色种类
	}
	for(long long i=1;i<n;++i) 
	{
		long long x=read(),y=read();
		jia(x,y);jia(y,x);
	}
	dfs(1,0);
	for(long long i=1;i<=100000;++i) if(vis[i]) qwq+=n-jian[i],bj[i]=n-jian[i];//特别处理根节点
	getans(1,0);
	for(long long i=1;i<=n;++i) write(ans[i]),puts("");
	return 0;
}
```
大家见谅，讲得自己都qwq了。。。

---

## 作者：Treeloveswater (赞：86)

From SLYZ Leaves

没有题解呢

于是来写一份。

最初看到这个题是群里一个dalao安利的。


很明显，这种处理树上点对、nlogn可以接受且单次询问的问题

肯定是点分治跑不掉了。

那么现在问题就变成了：你有一棵树，如何在O（n）的处理出，以根为lca的点对的答案？

一个很重要的性质：**对于树中的一点ｉ，如果该点的颜色在该点到根这条链上是第一次出现，那么对于这棵树的其他点ｊ（ｊ与ｉ的ｌｃａ为根），均能与ｉ的子树（包括ｉ）组成点对，ｉ的颜色会对ｊ的答案贡献size[i]。（我们在此暂且不考虑ｊ到根的链上是否出现了ｉ的颜色）**

这个性质还是很好证明的，大家画画图就能看懂了。

那么我们就可以这样做了：

１.对树进行第一遍dfs，预处理size和上方性质中的贡献。（开一个color数组即可记录贡献），同时记录贡献总和sum

２.枚举跟的所有子树，先把子树扫一遍清除其在color数组中的所有贡献。接着，对于该子树中的每一个点ｊ：

设Ｘ＝sigma color[j 到根上（不包括根）的所有颜色] 由于这些颜色已经出现过，我们不能在该子树外计算其贡献）

设num为ｊ到根上（不包括根）的颜色数

设Ｙ为size[root]-size[该子树]（即所有其他子树＋根的点数）

则ans[j]+＝sum-X+num\*Y;

３.别忘了计算单独ｒｏｏｔ的ａｎｓ

  　　ans[root]+=sum-color[根的颜色]+size[root]

４．清空贡献数组以及其他东西

  
那么点分治就解决了～

附上代码：

    
                
                
    
    
   
   
```cpp
    #include<cstdio>
    #include<cstring>
    #include<iostream>
    #include<algorithm>
    #define o 200011
    #define ll long long
    using namespace std;
    const int inf=1e8;
    int head[o],nxt[o*2],point[o*2],V[o];
    ll color[o],ans[o],much,sum,num,size[o],cnt[o],total,record;
    int tot,n,ui,vi,root;
    bool vis[o*2];
    void addedge(int x,int y){
        tot++;nxt[tot]=head[x];head[x]=tot;point[tot]=y;
        tot++;nxt[tot]=head[y];head[y]=tot;point[tot]=x;
    }
    void findroot(int now,int dad){
        size[now]=1;
        ll maxson=0;
        for(int tmp=head[now];tmp;tmp=nxt[tmp]){
            int v=point[tmp];
            if(v!=dad&&!vis[tmp]){
                findroot(v,now);
                size[now]+=size[v];
                maxson=max(maxson,size[v]);
            }
        }
        maxson=max(maxson,total-size[now]);
        if(maxson<record) root=now,record=maxson;
    }        
    void dfs1(int now,int dad){
        size[now]=1;
        cnt[V[now]]++;
        for(int tmp=head[now];tmp;tmp=nxt[tmp]){
            int v=point[tmp];
            if(!vis[tmp]&&v!=dad){
                dfs1(v,now);
                size[now]+=size[v];
            }
        }
        if(cnt[V[now]]==1){
            sum+=size[now];
            color[V[now]]+=size[now];
        } 
        cnt[V[now]]--;
    }
    void change(int now,int dad,int value){
        cnt[V[now]]++; 
        for(int tmp=head[now];tmp;tmp=nxt[tmp]){
            int v=point[tmp];
            if(!vis[tmp]&&v!=dad) change(v,now,value);
        }
        if(cnt[V[now]]==1){
            sum+=(ll)size[now]*value;
            color[V[now]]+=(ll)size[now]*value;
        } 
        cnt[V[now]]--;
    }
    void dfs2(int now,int dad){
        cnt[V[now]]++;
        if(cnt[V[now]]==1){
            sum-=color[V[now]];
            num++;
        }
        ans[now]+=sum+num*much;
        for(int tmp=head[now];tmp;tmp=nxt[tmp]){
            int v=point[tmp];
            if(!vis[tmp]&&v!=dad) dfs2(v,now);
        }    
        if(cnt[V[now]]==1){
            sum+=color[V[now]];
            num--;
        }
        cnt[V[now]]--;
    }
    void clear(int now,int dad){
        cnt[V[now]]=0;
        color[V[now]]=0;
        for(int tmp=head[now];tmp;tmp=nxt[tmp]){
            int v=point[tmp];
            if(!vis[tmp]&&v!=dad) clear(v,now);
        }
    }
    void did(int now,int dad){
        dfs1(now,dad);
        ans[now]+=sum-color[V[now]]+size[now];
        for(int tmp=head[now];tmp;tmp=nxt[tmp]){
            int v=point[tmp];
            if(!vis[tmp]&&v!=dad){
                cnt[V[now]]++;
                sum-=size[v];
                color[V[now]]-=size[v];
                change(v,now,-1);
                cnt[V[now]]--;
                much=size[now]-size[v];
                dfs2(v,now);
                cnt[V[now]]++;
                sum+=size[v];
                color[V[now]]+=size[v];
                change(v,now,1);
                cnt[V[now]]--;
            }
        }
        sum=0;num=0;
        clear(now,dad);
    }
    void solve(int now,int dad){
        did(now,dad);
        for(int tmp=head[now];tmp;tmp=nxt[tmp]){
            int v=point[tmp];
            if(!vis[tmp]&&v!=dad){
                vis[tmp]=true;
                vis[tmp^1]=true;
                total=size[v];
                record=inf;
                findroot(v,now);
                solve(root,0);
            }
        }
    }
    int main(){
        tot=1;
        scanf("%d",&n);
        for(int i=1;i<=n;i++) scanf("%d",&V[i]);
        for(int i=1;i<n;i++){
            scanf("%d%d",&ui,&vi);
            addedge(ui,vi);
        }
        record=inf;
        total=n;
        findroot(1,0);
        solve(root,0);
        for(int i=1;i<=n;i++) printf("%lld\n",ans[i]);
        return 0;
    }

```

---

## 作者：Salamander (赞：64)

考虑点分治，对于当前分治中心，统计出它自己出发到分治块内的所有路径对自己答案的贡献，和经过它的路径对当前分治块内点的贡献。自己出发到分治块内的所有路径对自己答案的贡献很好求，现在考虑怎么求经过它的路径对当前分治块内点的贡献。

    
我们对于当前分治中心的每一个子树分别考虑，令$cnt[i]$为从分治中心出发的进入其他子树的所有路径中，包含颜色$i$的路径条数，$size$为除了该子树外当前分治块内所有的点的个数。那么，我们dfs这棵子树计算贡献，假设当前dfs到$x$，首先给$sum_x$加上$\sum cnt[i]$，即所有在其他子树中出现的颜色的贡献总和，然后计算$x$到分治中心的路径上颜色的贡献。

    
对于一个出现在分治中心到$x$的路径上的颜色$c$，它对$x$的贡献为$size-cnt[c]$，因为$c$已经在一些路径上出现，它现在能产生的额外贡献为它原来没有出现的路径条数。所以我们给$sum_x$还要加上$size-cnt[c]$。同时$c$也会对$x$的子树内所有点产生贡献，所以这个贡献要像标记一样往下传递，然后标记一下$c$的贡献已经被计算过，往下dfs时就不用再次计算了。


所以只需要对于当前分治中心求出$cnt$数组和每棵子树的$size$，进入一棵子树时减去子树自己内部对$cnt$产生的贡献。同时为了防止复杂度退化，我们不能对于所有颜色求$cnt$，要先统计一下当前分治块内有哪些颜色出现了，这样枚举块内所有颜色的复杂度才是O(分治块大小)。

    
复杂度$O(n\log n)$。


```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

#define For(i,_beg,_end) for(int i=(_beg),i##end=(_end);i<=i##end;++i)
#define Rep(i,_beg,_end) for(int i=(_beg),i##end=(_end);i>=i##end;--i)

template<typename T>T Max(const T &x,const T &y){return x<y?y:x;}
template<typename T>T Min(const T &x,const T &y){return x<y?x:y;}
template<typename T>int chkmax(T &x,const T &y){return x<y?(x=y,1):0;}
template<typename T>int chkmin(T &x,const T &y){return x>y?(x=y,1):0;}
template<typename T>void read(T &x){
    T f=1;char ch=getchar();
    for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;
    for(x=0;ch>='0'&&ch<='9';ch=getchar())x=x*10+ch-'0';
    x*=f;
}

typedef long long LL;
const int maxn=100010,inf=0x7fffffff;
struct edge{
    int to,nxt;
}e[maxn<<1];
int n,num,head[maxn],c[maxn];
int f[maxn],size[maxn],Size,root;
int has[maxn],col[maxn],top,cl[maxn],tp;
LL sum[maxn],res[maxn],cnt[maxn],ct[maxn],cct[maxn],path,tot;
bool vis[maxn],exist[maxn];

void addedge(int,int);
void get_sum(int,int);//计算子树大小
void get_root(int,int);//计算重心
void Dfs(int,int,LL*);//统计哪些颜色出现过，同时计算cnt数组
void Modify(int,int,LL);//更新子树的答案
void Calc(int);//对于分治中心统计答案
void Solve(int);//点分治

int main(){
    read(n);
    For(i,1,n) read(c[i]);
    For(i,1,n-1){
        int u,v;
        read(u);read(v);
        addedge(u,v);
    }
    Solve(1);
    For(i,1,n) printf("%lld\n",sum[i]);
    return 0;
}

void Calc(int x){
    get_sum(x,Size=0);
    
    tot=top=0;
    Dfs(x,0,cnt);
    For(i,1,top) exist[col[i]]=false;//要及时还原标记数组
    For(i,1,tp=top){
        tot+=cnt[cl[i]=col[i]];
        cct[col[i]]=cnt[col[i]];
    }
    
    sum[x]+=tot;
    LL temp=tot;
    
    for(int i=head[x];i;i=e[i].nxt) if(!vis[e[i].to]){
        
        has[c[x]]=1;top=0;
        Dfs(e[i].to,x,ct);
        has[c[x]]=0;
        For(j,1,top) exist[col[j]]=false;
        
        cnt[c[x]]-=size[e[i].to];
        tot-=size[e[i].to];
        For(j,1,top){
            cnt[col[j]]-=ct[col[j]];
            tot-=ct[col[j]];
        }
        
        path=size[x]-size[e[i].to];
        Modify(e[i].to,x,0);
        
        cnt[c[x]]+=size[e[i].to];
        tot=temp;
        For(j,1,top){
            cnt[col[j]]=cct[col[j]];
            ct[col[j]]=0;
        }
    }
    
    For(i,1,tp) cnt[cl[i]]=0;//还原数组
    vis[x]=true;
}
void Modify(int x,int fa,LL lst){//lst为之前下传下来的贡献和
    LL tag=lst;
    if(++has[c[x]]==1) tag+=path-cnt[c[x]];
    sum[x]+=tot+tag;
    for(int i=head[x];i;i=e[i].nxt){
        if(e[i].to==fa||vis[e[i].to]) continue;
        Modify(e[i].to,x,tag);
    }
    has[c[x]]--;
}
void Dfs(int x,int fa,LL *cnt){
    if(!exist[c[x]]) col[++top]=c[x],exist[c[x]]=true;
    if(++has[c[x]]==1) cnt[c[x]]+=size[x];
    for(int i=head[x];i;i=e[i].nxt){
        if(e[i].to==fa||vis[e[i].to]) continue;
        Dfs(e[i].to,x,cnt);
    }
    has[c[x]]--;
}
void Solve(int x){
    Calc(x);
    for(int i=head[x];i;i=e[i].nxt) if(!vis[e[i].to]){
        f[Size=root=0]=inf;
        get_sum(e[i].to,x);
        get_root(e[i].to,x);
        Solve(root);
    }
}
void get_sum(int x,int fa){
    Size++;size[x]=1;
    for(int i=head[x];i;i=e[i].nxt){
        if(e[i].to==fa||vis[e[i].to]) continue;
        get_sum(e[i].to,x);
        size[x]+=size[e[i].to];
    }
}
void get_root(int x,int fa){
    f[x]=0;
    for(int i=head[x];i;i=e[i].nxt){
        if(e[i].to==fa||vis[e[i].to]) continue;
        get_root(e[i].to,x);
        chkmax(f[x],size[e[i].to]);
    }
    chkmax(f[x],Size-size[x]);
    if(f[x]<f[root]) root=x;
}
void addedge(int u,int v){
    e[++num].to=v;e[num].nxt=head[u];head[u]=num;
    e[++num].to=u;e[num].nxt=head[v];head[v]=num;
}
```

---

## 作者：Sweetlemon (赞：42)

[P2664 树上游戏](https://www.luogu.org/problemnew/show/P2664)

一道黑题，难度名副其实。

下面简述我的做法。

我的做法可能相当劣，时间复杂度是$\text{O}(n \log n)$，比不过$\text{O}(n)$的方法；而且代码比较长，达到了$210$行（带注释$242$行）；使用了很多次$\mathrm{dfs}$，常数也不够优。但是也许我的思路会对您有所启发。

看到树上“路径”，且树形$\text{dp}$不好处理，于是我们考虑使用点分治。

“颜色数”一直是难以处理的统计量，这个统计量阻止了我们直接对“节点到根的路径”进行合并，而必须考虑其他的方法。

假设我们已经分治到原树的某一部分，并且我们当前只考虑经过（分治的）根（即当前重心，不妨记为$\mathrm{root}$）的路径。那么我们需要思考两个问题：

1. 如何计算当前分治区域内根的答案？
2. 如何计算当前分治区域内其他点的答案？

为了方便处理，我们把根的颜色单独拿出来讨论。  
对于根本身，根的颜色的贡献是$\mathrm{size}(\mathrm{root})$；对于根的任何一个子孙顶点，根的颜色的贡献是$\mathrm{size}(\mathrm{root})-\mathrm{size}(\mathrm{branch})$，其中$\mathrm{branch}$是指该节点所在的根的子树。  
接下来，如果遇到与根同色的节点，我们就当作无色处理。

第一个问题比较容易解决。

假设我们从根走到**某一**子孙节点，在走的过程中，如果出现了某种**新**颜色，那么这条路径答案就应该$+1$。也即我们统计的思路是，只在颜色第一次出现时计算。  
如果在$\mathrm{root}\rightarrow x$的路径上，$\mathrm{color}(x)$只出现一次（即$x$的祖先都与$x$不同色），那么祖先到以$x$为根的子树内的所有点的路径上都会出现$\mathrm{color}(x)$，且第一次出现的位置是$x$。从而，$x$对根的答案的贡献为$x$所在子树内顶点的个数，即$\mathrm{size}(x)$。否则如果$x$与某一祖先同色，那么$x$的颜色就不是第一次出现，对根的答案没有贡献。   
不妨设节点$x$的上述贡献为$f(x)$，那么$f(x)$为$\mathrm{size}(x)$（$\mathrm{color}(x)$第一次出现）或$0$（$x$为根或$\mathrm{color}(x)$不是第一次出现)。我们把它们累加，得到整棵树的贡献和$\sum{f}$。

那么第一个问题就解决了。该区域内根的答案$\mathrm{ans}(\mathrm{root})=\mathrm{size}(\mathrm{root})+\sum{f}$，即根节点处的答案就等于自身颜色的贡献与子孙节点颜色贡献之和。

第二个问题比较困难。

点分治的合并思想启示我们，借助刚才计算的$f$解决第二个问题。我们把路径$x\rightarrow y$拆成$x\rightarrow \mathrm{root}$和$\mathrm{root} \rightarrow y$两段。

对于某一定点$x$，如果只考虑所有的$x\rightarrow \mathrm{root}$，那么这些路径一共有$\mathrm{size}(\mathrm{root})-\mathrm{size}(\mathrm{branch})$条（每个$y$对应一条），每条路径完全相同，出现的不同颜色的个数都相等；于是，路径上出现的每一种颜色$t$对$x$的答案的贡献均为$\mathrm{size}(\mathrm{root})-\mathrm{size}(\mathrm{branch})$。

如果只考虑所有的$\mathrm{root} \rightarrow y$，这些路径中每条路径出现颜色数之和即为$\sum_{y\notin \mathrm{branch}}{f(y)}=\sum{f}-\sum_{i \in \mathrm{branch}}{f(i)}$，即$\sum{f}$减去所有$x$所在分支的点的$f$值。

但是，$x\rightarrow \mathrm{root}$和$\mathrm{root} \rightarrow y$中可能会有重复的颜色。具体地，如果某种颜色$t$在$x\rightarrow \mathrm{root}$中出现了，那么对于所有的在分支外部的、$\mathrm{color}(u)=t$的顶点$u$，它们的$f$值都不能再计入到答案里，因为这一种颜色已经在$x\rightarrow \mathrm{root}$上统计过了。

如果我们记$A$为在$x\rightarrow \mathrm{root}$上出现过的颜色的集合，那么答案就是  
$$\sum{f}-\sum_{i \in \mathrm{branch}}{f(i)}-\sum_{u\notin \mathrm{branch}\text{且}\mathrm{color}(u)\in A}f(u)+\sum_{t\in A}(\mathrm{size}(\mathrm{root})-\mathrm{size}(\mathrm{branch}))$$

上式已经包括了根的颜色对$x$的答案的贡献。

观察上式，我们发现要记录的量有：

1. $\sum{f}$。
2. $\mathrm{branch}$中所有点的$f$和，即$\sum_{i \in \mathrm{branch}}{f(i)}$。
3. 不在$\mathrm{branch}$中，但其颜色在$x\rightarrow \mathrm{root}$上出现过的点的$f$和，即$\sum_{u\notin \mathrm{branch}\text{且}\mathrm{color}(u)\in A}f(u)$。
4. $x\rightarrow \mathrm{root}$上所有颜色的贡献和，即$\sum_{t\in A}(\mathrm{size}(\mathrm{root})-\mathrm{size}(\mathrm{branch}))$。

对此，找到重心后，我们再进行三次$\mathrm{dfs}$。

第一次$\mathrm{dfs}$的任务是，计算出$\mathrm{size},\sum{f},\sum_{i \in \mathrm{branch}}{f(i)}$；并对每一种颜色$t$，计算所有颜色为$t$的节点的$f$和，即$\sum_{\mathrm{color}(u)=t}f(u)$。

第一次$\mathrm{dfs}$后，我们就可以得到$\mathrm{ans}(\mathrm{root})$了。

接下来开始枚举$\mathrm{root}$的子树，即枚举$\mathrm{branch}$。

对于每一个$\mathrm{branch}$，先进行第二次$\mathrm{dfs}$，任务是对每一种$\mathrm{branch}$中出现的颜色$t$，计算分支内所有颜色为$t$的节点$v$的$f$和，即$\sum_{v\in \mathrm{branch}\text{且}\mathrm{color}(v)=t}f(v)$。这样，我们就可以得到上面的第三个量：
$$\sum_{u\notin \mathrm{branch}\text{且}\mathrm{color}(u)=t}f(u)=\sum_{\mathrm{color}(u)=t}f(u)-\sum_{v\in \mathrm{branch}\text{且}\mathrm{color}(v)=t}f(v)$$

紧接着，进行第三次$\mathrm{dfs}$，任务便是计算答案。

先处理$\mathrm{ans}$式子的第二项，即我们把分支内的$f$从$\sum{f}$里暂时减掉，即把$\sum{f}$扣掉$\sum_{i \in \mathrm{branch}}{f(i)}$，待$\mathrm{dfs}$结束后再加回来。

第三、第四项合并处理。在$\mathrm{dfs}$的过程中，如果到达了一个与祖先都不同色的顶点$v$，就说明$t=\mathrm{color}(v)$是新出现的，那么$v$子树中的所有节点的集合$A$都会新增一个元素$t$。这样，第三项就增加了$\sum_{u\notin \mathrm{branch}\text{且}\mathrm{color}(u)=t}f(u)$，也即答案还需要扣除$\sum_{\mathrm{color}(u)=t}f(u)-\sum_{v\in \mathrm{branch}\text{且}\mathrm{color}(v)\in A}f(v)$；而第四项就增加了一个$\mathrm{size}(\mathrm{root})-\mathrm{size}(\mathrm{branch})$，也即答案还需要增加$\mathrm{size}(\mathrm{root})-\mathrm{size}(\mathrm{branch})$。那么我们把上述变化处理到对存储$\sum{f}$的变量处，函数即将返回时再恢复回来。  
而如果$x$的颜色已经出现过了，那么我们不做上述处理。

经过这样的处理，$\mathrm{ans}$式子的每一项都在存储$\sum{f}$的变量处计算了，那么该变量的值就等于$\mathrm{ans}(x)$。

经过这样的遍历，我们就把所有答案都计算完毕了。

如上所述，我们按照点分治的基本思想，在每一层分治都作上述计算，把每一层的答案累加即可。

但在代码实现上还有一个较大的问题。由于点分治需要多次计算，因此数组必须及时清零，否则答案会不正确。

存储每个分支的$f$和的数组只需在第三次$\mathrm{dfs}$结束后顺手将该分支的位置设为$0$即可。对于存储每种颜色的$f$和的数组，可以用一个栈记录该层分治所出现的颜色，在往下递归分治前把栈中所有颜色的值清零即可。

而记录某特定分支中每一种颜色的$f$值和的数组就比较尴尬，因为它必须在计算每一个分支完毕后立即清零。我采用的方法是在第三次$\mathrm{dfs}$后再进行第四次$\mathrm{dfs}$，任务是清零该数组。

这样，这道题就完全解决了。当然，代码实现上还有许多细节，需要多多注意。例如，答案可能很大，需要开`long long`（否则只有$80$分）。

我的实现总用时[$1421\mathrm{ms}$（无`O2`）](https://www.luogu.org/record/show?rid=18133128) / [$919\mathrm{ms}$（`O2`）](https://www.luogu.org/record/show?rid=18133134)。

[带注释的代码](https://www.luogu.org/recordnew/show/18135537)

```cpp
#include <cstdio>
#include <cctype>
#define MAXN 100005
#define MAXM 200005
#define MAXIOLG 25
using namespace std;

typedef long long ll; //答案可能很大，记得开long long

//下面为目隐团部分成员/读入输出优化
typedef ll io_t;
//如月伸太郎, shintaro, No.7, 目缠, 记忆数字
io_t shin[MAXIOLG];
//濑户幸助, seto, No.2, 目盗, 读入优化
io_t seto(void);
//楯山文乃, ayano, No.0, 目挂, 输出优化
void ayano(io_t x,char spliter='\n');

int fst[MAXN],nxt[MAXM],edges=0; //存图邻接表
int g[MAXM]; //图
int sz[MAXN],mnsz,root,tree_sz; //size数组, mnsz用于找重心, root为当前分治根, tree_sz为当前分治区域点数
int visited[MAXN]; //visited记录点是否已经被删除

int color[MAXN]; //每个点的颜色
int tree_color[MAXN],tree_color_n; //栈结构, 存储当前分治区域出现的颜色, 便于清空数组

//依次为每种颜色的f和、该种颜色在之前是否出现过、该分支每种颜色的f和、每一分支的f和、存储sum(f)的变量
ll color_f[MAXN],has_col[MAXN],branch_color_f[MAXN],branch_f[MAXN],tf;
//答案数组
ll ans[MAXN];

void addedge(int u,int v); //加边
void solve(int x); //分治函数
void find_g(int x,int pa); //找重心
void dfs1(int x,int pa,int branch); //第一次dfs
void dfs2(int x,int pa,int branch); //第二次dfs
void dfs3(int x,int pa,int branch); //第三次dfs
void dfs4(int x,int pa,int branch); //第四次dfs

int main(void){
    int n;
    //读入
    n=seto();
    for (int i=1;i<=n;i++)
        color[i]=seto();
    for (int i=1;i<n;i++){
        int u,v;
        u=seto(),v=seto();
        addedge(u,v);
        addedge(v,u);
    }
    //点分治
    sz[1]=n;
    solve(1);
    //输出
    for (int i=1;i<=n;i++)
        ayano(ans[i]);
    return 0;
}

void solve(int x){
    //分治函数
    mnsz=tree_sz=sz[x];
    find_g(x,0); //找重心

    //清空栈
    tree_color_n=0;
    const int root_col=color[root];
    tree_color[tree_color_n++]=root_col;
    has_col[root_col]=1;
    tf=0;
    
    dfs1(root,0,0); //第一次dfs计算sz, tf, color_f, branch_f

    ans[root]+=(tf+tree_sz); //得到根的答案
    
    for (int ei=fst[root];ei;ei=nxt[ei]){
        //枚举分支
        int v=g[ei];
        if (visited[v])
            continue;
        tf-=branch_f[v]; //扣除该分支f值（答案式第二项）
        dfs2(v,root,v); //第二次dfs计算branch_color_f
        dfs3(v,root,v); //第三次dfs计算ans
        dfs4(v,root,v); //第四次dfs清零branch_color_f
        tf+=branch_f[v]; //消除第二项的影响, 恢复tf变量
        branch_f[v]=0; //清零branch_f
    }

    has_col[root_col]=0; //清零has_col
    //清零color_f
    while (tree_color_n){
        tree_color_n--;
        color_f[tree_color[tree_color_n]]=0;
    }

    //递归分治
    visited[root]=1;
    for (int ei=fst[root];ei;ei=nxt[ei]){
        int v=g[ei];
        if (visited[v])
            continue;
        solve(v);
    }
}

void dfs1(int x,int pa,int branch){
    //第一次dfs计算sz, tf, color_f, branch_f
    if (pa==root)
        branch=x; //处理branch变量
    sz[x]=1; //sz初始化
    int is_new_col=0,tcol=color[x];
    if (!has_col[tcol]) //新出现的颜色, 先记录
        is_new_col=has_col[tcol]=1;
    for (int ei=fst[x];ei;ei=nxt[ei]){
        int v=g[ei];
        if (visited[v] || v==pa)
            continue;
        dfs1(v,x,branch);
        sz[x]+=sz[v];
    }
    if (is_new_col){
        //新出现的颜色, 更新变量
        if (!color_f[tcol]) //颜色在整个分治区域第一次出现, 入栈
            tree_color[tree_color_n++]=tcol;
        color_f[tcol]+=sz[x]; //将贡献累加到color_f中
        branch_f[branch]+=sz[x]; //将贡献累加到branch_f中
        tf+=sz[x]; //将贡献累加到tf中
        has_col[tcol]=0; //清掉has_col
    }
}

void dfs2(int x,int pa,int branch){
    //第二次dfs计算branch_color_f
    int tcol=color[x],is_new_color=0;
    if (!has_col[tcol]) //新出现的颜色, 先记录
        has_col[tcol]=is_new_color=1;
    for (int ei=fst[x];ei;ei=nxt[ei]){
        int v=g[ei];
        if (visited[v] || v==pa)
            continue;
        dfs2(v,x,branch);
    }
    if (is_new_color) //新出现的颜色, 清掉has_col并将贡献累加到branch_color_f中
        has_col[tcol]=0,branch_color_f[tcol]+=sz[x];
}

void dfs3(int x,int pa,int branch){
    //第三次dfs计算ans
    ans[x]+=(tree_sz-sz[branch]); //根处的答案在前面未加入, 现在额外算
    int tcol=color[x],is_new_color=0;
    if (!has_col[tcol]){
        has_col[tcol]=is_new_color=1; //新出现的颜色,记录
        tf-=(color_f[tcol]-branch_color_f[tcol]); //答案式子第三项
        tf+=(tree_sz-sz[branch]);  //答案式子第四项
    }
    ans[x]+=tf; //累加答案
    for (int ei=fst[x];ei;ei=nxt[ei]){
        int v=g[ei];
        if (visited[v] || v==pa)
            continue;
        dfs3(v,x,branch);
    }
    if (is_new_color){
        //新出现的颜色,清掉has_col并恢复tf变量原来的值
        has_col[tcol]=0;
        tf+=(color_f[tcol]-branch_color_f[tcol]);
        tf-=(tree_sz-sz[branch]);
    }
}

void dfs4(int x,int pa,int branch){
    //第四次dfs清零branch_color_f
    branch_color_f[color[x]]=0;
    for (int ei=fst[x];ei;ei=nxt[ei]){
        int v=g[ei];
        if (visited[v] || v==pa)
            continue;
        dfs4(v,x,branch);
    }
}

void find_g(int x,int pa){
    //找重心
    sz[x]=1; //初始化size
    int mxsz=0; //x的子树或x以上部分的最大size
    for (int ei=fst[x];ei;ei=nxt[ei]){
        int v=g[ei];
        if (visited[v] || v==pa)
            continue;
        find_g(v,x);
        sz[x]+=sz[v];
        if (sz[v]>mxsz)
            mxsz=sz[v];
    }
    if (tree_sz-sz[x]>mxsz)
        mxsz=tree_sz-sz[x];
    if (mxsz<mnsz)
        mnsz=mxsz,root=x;
}

void addedge(int u,int v){
    //加边函数
    edges++;
    g[edges]=v;
    nxt[edges]=fst[u],fst[u]=edges;
}

//下面为目隐团部分成员/读入输出优化

io_t seto(void){
    //濑户幸助, seto, No.2, 目盗, 读入优化
    io_t ans=0;
    int symbol=0;
    char ch=getchar();
    while (!isdigit(ch))
        (ch=='-')?(symbol=1):(0),ch=getchar();
    while (isdigit(ch))
        (ans=ans*10+(ch-'0')),ch=getchar();
    return (symbol)?(-ans):(ans);
}

void ayano(io_t x,char spliter){
    //楯山文乃, ayano, No.0, 目挂, 输出优化
    if (!x){
        putchar('0'),putchar(spliter);
        return;
    }
    if (x<0)
        putchar('-'),x=-x;
    int len=0;
    while (x){
        io_t d=x/10;
        shin[len++]=x-d*10; //如月伸太郎, shintaro, No.7, 目缠, 记忆数字
        x=d;
    }
    while (len){
        len--;
        putchar(shin[len]+'0');
    }
    putchar(spliter);
}
```

---

## 作者：zltttt (赞：24)

还真不一定要用点分治......


可以直接考虑将每种颜色分开计算贡献。

对于某一种颜色，可以发现树上这种颜色的点将整棵树分成了很多块。

对于每一块中的所有点，当前颜色对块内点与块外点相连的所有边都有1的贡献。

而对于每一个本来就是这种颜色的点，它连出去的每一条边，这种颜色都会有1的贡献。


可以发现这可以用差分方便地统计。

然而对每一种颜色遍历一次整棵树来打标记，这样的复杂度是$O(nc)$，无法承受。


那么考虑建虚树优化每次遍历的节点数。

在普通虚树的基础上，需要在虚树内添加每个当前颜色的节点的所有直接儿子。

每次对于一块的加减，可以在块的开始处（这个点一定是某个当前颜色的节点的某个直接儿子，刚才咱们已经将其加入了虚树）打上等同于总点数减去这个块大小的标记，再在块的所有结束节点处删去这个标记。

于是考虑到建立所有的虚树的复杂度为$O(nlogn)$，大小为$O(n)$，已经可以在规定时间内出解了。


由于咱赌5毛钱出题人并没有想过这个算法，所以数据没有针对性。

于是没有特意卡常的情况下，**暂时**成为了速度第一~

~~（那个read()是个人觉得写起来比scanf()顺手而不是卡常QWQ）~~


```cpp
#include<bits/stdc++.h>

using namespace std;

inline int read()
{
    int x=0;char ch=getchar();
    while(ch<'0' || '9'<ch)ch=getchar();
    while('0'<=ch && ch<='9')x=x*10+(ch^48),ch=getchar();
    return x;
}

typedef long long ll;
const int K=21;
const int N=1e5+9;
vector<int> g[N],col[N],p;
int n,to[N<<1],nxt[N<<1],beg[N],c[N],stk[N],tot;
int fa[N][K],siz[N],dep[N],id[N],ed[N],dfn,top;
ll sum[N];

inline void add(int u,int v)
{
    to[++tot]=v;
    nxt[tot]=beg[u];
    beg[u]=tot;
}

inline void dfs(int u)
{
    id[u]=++dfn;
    siz[u]=1;
    for(int i=beg[u];i;i=nxt[i])
        if(fa[u][0]!=to[i])
        {
            dep[to[i]]=dep[u]+1;
            fa[to[i]][0]=u;
            dfs(to[i]);
            siz[u]+=siz[to[i]];
        }
    ed[u]=dfn;
}

inline int lca(int a,int b)
{
    if(dep[a]>dep[b])swap(a,b);
    for(int i=K-1;i>=0;i--)
        if(dep[fa[b][i]]>=dep[a])
            b=fa[b][i];
    if(a==b)return a;
    for(int i=K-1;i>=0;i--)
        if(fa[a][i]!=fa[b][i])
            a=fa[a][i],b=fa[b][i];
    return fa[a][0];
}

inline bool cmp(int a,int b)
{
    return id[a]<id[b];
}

inline void dfs2(int u,int cc)
{
    int rectop,tots=0;
    for(int i=0;i<g[u].size();i++)
    {
        rectop=top;
        dfs2(g[u][i],cc);
        if(c[u]==cc)
        {
            ll bcnt=siz[g[u][i]];
            for(int j=rectop+1;j<=top;j++)
                    bcnt-=siz[stk[j]];
            sum[g[u][i]]+=n-bcnt;
            tots+=n-bcnt;
            for(int j=rectop+1;j<=top;j++)
                sum[stk[j]]-=n-bcnt;
            top=rectop;
        }
    }

    if(c[u]==cc)
    {
        stk[++top]=u;
        sum[u]+=n;
        for(int i=beg[u];i;i=nxt[i])    
            if(to[i]!=fa[u][0])
                sum[to[i]]-=n;
    }
    else if(u==1)
    {
        int bcnt=siz[u];
        for(int i=1;i<=top;i++)
            bcnt-=siz[stk[i]];
        sum[u]+=n-bcnt;
        for(int i=1;i<=top;i++)
            sum[stk[i]]-=n-bcnt;
    }
}

inline void dfs3(int u)
{
    if(fa[u][0])
        sum[u]+=sum[fa[u][0]];
    for(int i=beg[u];i;i=nxt[i])
        if(to[i]!=fa[u][0])
            dfs3(to[i]);
}

int main()
{
    n=read();
    for(int i=1;i<=n;i++)
        col[c[i]=read()].push_back(i);
    for(int i=1,u,v;i<n;i++)
    {
        u=read();v=read();
        add(u,v);add(v,u);
    }
        
    dep[1]=1;
    fa[1][0]=0;
    dfs(1);
    for(int i=1;i<K;i++)
        for(int j=1;j<=n;j++)
            fa[j][i]=fa[fa[j][i-1]][i-1];

    for(int cc=1;cc<N;cc++)
    {
        if(col[cc].empty())continue;

        p.clear();
        sort(col[cc].begin(),col[cc].end(),cmp);
        for(int i=1,e=col[cc].size();i<e;i++)
        {
            p.push_back(col[cc][i]);
            p.push_back(lca(col[cc][i-1],col[cc][i]));
            for(int j=beg[col[cc][i]];j;j=nxt[j])
                if(to[j]!=fa[col[cc][i]][0])
                    p.push_back(to[j]);
        }
        p.push_back(col[cc][0]);
        for(int j=beg[col[cc][0]];j;j=nxt[j])
            if(to[j]!=fa[col[cc][0]][0])
                p.push_back(to[j]);
        p.push_back(1);
        sort(p.begin(),p.end(),cmp);
        int size=unique(p.begin(),p.end())-p.begin();
        
        stk[top=1]=1;
        g[1].clear();
        for(int i=1;i<size;i++)
        {
            g[p[i]].clear();
            while(top && id[p[i]]>ed[stk[top]])
                top--;
            g[stk[top]].push_back(p[i]);
            stk[++top]=p[i];
        }

        top=0;
        dfs2(1,cc);
    }

    dfs3(1);
    for(int i=1;i<=n;i++)
        printf("%lld\n",sum[i]);
    return 0;
}
```

---

## 作者：「QQ红包」 (赞：18)


[my blog:redbag的小屋](http://redbag.pw/)

$$ \sum _{i=1}^n s(i,j) $$

考虑离线，一种一种颜色加进来。

i到没有出现这种颜色的地方，构成一个联通块。(用并查集来维护)  $ ans+=(n-size) $

复杂度最坏 $ O(n^2) $ 。

期望得分 40分。

然后想想怎么把40分变成一百分。

每次点分的时候只要算子树对子树的贡献，还有子树对根的贡献，内部贡献继续分的时候算。

每个子树的颜色x对其他子树的贡献=该子树所有链上，x第一次出现的位置p，p的子树的大小。然后遇到受到内部影响的情况，贡献就要修改。

多种颜色我们不可以分开处理，就一起处理（看着鬼畜）

1.找重心，求size,清上一次的标记

2.第一次dfs：记录整个子树，每个颜色在该条链上第一次出现时候，其子树的大小的和。
所以这到底是什么东西啊QAQ。
看图感性理解写（逃），

然后还要记录一下每一种颜色，在整个分治块的答案，

然后和根颜色不同的才算。记一个总和s2，每个树的贡献就是sum[i]。因为根的颜色的贡献就是整个分治块的大小（想一想，为什么）。

3.第二次dfs：设整个子树对其他子树和根的贡献为sum[i]，设s1=s2-sum[i]-size[i]（算自己的时候不要算内部的贡献），
如果出现了颜色z（并且z ≠根的颜色），颜色z在整个分治块的总贡献为cnt[z], 目前在点d，所在子树为x，

cnt1[z]表示颜色z在目前子树x的答案（第三次dfs），s1=s1-cnt[z]+cnt1[c[x]]+（sz-size[x]）
（就是把原本这种颜色的贡献改为整个分治块的大小减去自己整个子树的大小）

4.然后还需要一次dfs来清理标记QAQ。

语文不好不能表达得很清楚，代码也不是很清晰，有问题可以评论/私信。

```cpp
#include<bits/stdc++.h>
#define ld long double
#define ll long long
using namespace std;
void qmax(int &x,int y) {if (x<y) x=y;}
void qmin(int &x,int y) {if (x>y) x=y;}
inline int read()
{
    char s;
    int k=0,base=1;
    while((s=getchar())!='-'&&s!=EOF&&!(isdigit(s)));
    if(s==EOF)exit(0);
    if(s=='-')base=-1,s=getchar();
    while(isdigit(s)) {k=k*10+(s^'0');s=getchar();}
    return k*base;
}
inline void write(int x)
{
    static char cnt,num[15];cnt=0;
    if (!x)
    {
        printf("0");
        return;
    }
    for (;x;x/=10) num[++cnt]=x%10;
    for (;cnt;putchar(num[cnt--]+48));
}
const int maxn=1e5+100;
int n,flag;
int c[maxn];//颜色 
int to[maxn<<1],ne[maxn<<1],po[maxn],id,X,Y;
int size[maxn],hson[maxn],root,del[maxn],sz;//del删除标记 
ll ans[maxn];//答案
ll sum[maxn],s1;//记录每个子树的答案 
int vis[maxn];//标记某种颜色是否在该链中出现过
ll cnt[maxn]; //存整个分治块的答案 
int cnt1[maxn];//存当前扫的子树的答案 
void add(int x,int y)
{
	id++;to[id]=y;ne[id]=po[x];po[x]=id;
}
void get_root(int x,int fa)
{
	cnt[c[x]]=0;//清理标记 
	size[x]=1;hson[x]=0;
	for (int i=po[x];i;i=ne[i])
	{
		if (!del[to[i]]&&fa!=to[i])
		{
			get_root(to[i],x);
			if (size[to[i]]>hson[x]) hson[x]=size[to[i]];
			size[x]+=size[to[i]];
		}
	}
	qmax(hson[x],sz-size[x]);
	if (root==-1||hson[root]>hson[x]) root=x;
}//找重心 
void qsize(int x,int fa)
{
	size[x]=1;
	for (int i=po[x];i;i=ne[i])
	{
		if (!del[to[i]]&&fa!=to[i])
		{
			qsize(to[i],x);
			size[x]+=size[to[i]];
		}
	}
}//求每个子树的大小 
void dfs1(int x,int fa,int s)//目前在点x,父亲为fa，所属于子树s 
{
	vis[c[x]]++; //标记出现次数 
	if (vis[c[x]]==1&&c[x]!=c[root]) 
	{
		cnt[c[x]]+=size[x];
		sum[s]+=size[x];//该分治块的贡献 
	}
	for (int i=po[x];i;i=ne[i])
	{
		if (to[i]==fa||del[to[i]]) continue;
		dfs1(to[i],x,s);
	}
	vis[c[x]]--;
}
void dfs3(int x,int fa,int s)
{
	vis[c[x]]++; 
	if (vis[c[x]]==1&&c[x]!=c[root]) cnt1[c[x]]+=size[x];// 该子树的贡献 
	for (int i=po[x];i;i=ne[i])
	{
		if (to[i]==fa||del[to[i]]) continue;
		dfs3(to[i],x,s);
	}
	vis[c[x]]--;//清标记 
}
void dfs4(int x,int fa,int s)
{
	cnt1[c[x]]=0;
	for (int i=po[x];i;i=ne[i])
	{
		if (to[i]==fa||del[to[i]]) continue;
		dfs4(to[i],x,s);
	}
}//清标记而已233 
void dfs2(int x,int fa,int s)
{
	vis[c[x]]++;
	ll s3;
	if (c[x]!=c[root]&&vis[c[x]]==1)//修改 
	{
		s3=s1; 
		s1=s1-cnt[c[x]]+cnt1[c[x]]+sz-size[s];
	}
	ans[x]+=s1;
	for (int i=po[x];i;i=ne[i])
	{
		if (to[i]==fa||del[to[i]]) continue;
		dfs2(to[i],x,s);
	}
	if (c[x]!=c[root]&&vis[c[x]]==1) s1=s3;//回溯掉qaq 
	vis[c[x]]--;
}
void solve(int x)
{
	qsize(x,0);//求出每个树的size 
	if (size[x]==1) 
	{
		ans[x]++;//自己到自己也要算 
		del[x]=1;
		return;
	}
	ll s2=0;
	for (int i=po[x];i;i=ne[i])
	{
	 	if (del[to[i]]) continue;
	 	sum[to[i]]=0;
	 	dfs1(to[i],x,to[i]);
	 	s2+=sum[to[i]];
	}
	s2+=size[root];
	ans[root]+=s2;
	for (int i=po[x];i;i=ne[i])
	{
		if (del[to[i]]) continue;
		s1=s2-sum[to[i]]-size[to[i]];
		dfs3(to[i],x,to[i]);
		dfs2(to[i],x,to[i]);
		dfs4(to[i],x,to[i]); 
	} //统答案 
	del[x]=1;	
	for (int i=po[x];i;i=ne[i])
	{
		if (del[to[i]]) continue;
		sz=size[to[i]];
		root=-1;
		get_root(to[i],x);
		solve(root); 
	}//处理下一层 
}
int main()
{
	n=read();
	for (int i=1;i<=n;i++) c[i]=read();
	for (int i=1;i<n;i++)
	{
		X=read();Y=read();
		add(X,Y),add(Y,X);
	}
	sz=n;
	root=-1;
	get_root(1,0);
	solve(root); 
	for (int i=1;i<=n;i++)
	{
		printf("%lld\n",ans[i]);
	}
	return 0;
}

```

---

## 作者：__ZJ (赞：16)

### 扫描线，线段树维护区间覆盖

（画风诡异，真的没有点分治，没有虚树。。。）

**●简要版:**
		
	对每种颜色分别考虑，
	每个点会贡献的S(i,j)形成平面上的若干矩形。
	然后用扫描线+线段树维护区间覆盖去求得：
	只考虑该颜色时的每个sum[u](准确说是sum[u]的差分数组)
    把每种颜色得到的sum[u]加起来就是答案了。
		
**●详细版：**
	
	事先dfs一遍这颗树,对每个点u记录下它的dfs序号。
	然后维护出be[u](begin)表示u的子树内最小的dfs序号(显然就是它自己的序号啦)
	以及en[u](end)表示u的子树内最大的dfs序号(也就是u子树里最后一个被遍历到的点的序号)
	
	考虑树上的某一个点u，它的颜色为c，假设其它点都是没有颜色的，
	那么来考虑一下，这个点会为哪些S(i,j)贡献1的值
	显然可以分为两类情况：
		1).i为u外面的点，j为x子树内的点。 
		  (或者j为u外面的点，i为u子树内的点)
		2).i,j分别为x的不同儿子的子树内的点。
		  (这样的话，i,j的lca为u嘛)。
		  
	现在我们赋予二元组(i,j)几何意义：对应着坐标平面上的一个点(i,j)，
	
	有了二维平面，我们在把之前的两类情况反映到平面上:（建议画图理解） 
		1).i,j一个为u外面的点，另一个为u子树内的点。
			子情况(1)：i=1~be[u],j=be[u]~en[u]
				那么这就对应着(1~be[u],be[u]~en[u])这样一个矩形，
			子情况(2,类似上面，只是把i,j交换)：i=be[u]~en[u],j=1~be[u]
				那么这就对应着(be[u]~en[x],1~be[u])这样一个矩形，
			子情况(3): i=be[u]~en[u],j=en[u]~N
				那么这就对应着(be[u]~en[u],en[u]~N)这样一个矩形，
			子情况(4,类似上面，只是把i,j交换)：i=en[u]~N,j=be[u]~en[u]
				那么这就对应着(en[u]~N,be[u]~en[u])这样一个矩形，
		2).i,j分别为x的不同儿子的子树内的点。
			这里需要枚举u的每个儿子v：
			子情况(1)：i=be[u]~(en[v]-1),j=be[v]~en[v]
				那么这就对应着(be[u]~(en[v]-1),be[v]~en[v])这样一个矩形，
			子情况(2,类似上面，只是把i,j交换)：i=be[v]~en[v],j=be[u]~(en[v]-1)
				那么这就对应着(be[v]~en[v],be[u]~(en[v]-1))这样一个矩形，
			子情况(3)：i=be[v]~en[v],j=(en[v]+1)~en[u]
				那么这就对应着(be[v]~en[v],(en[v]+1)~en[u])这样一个矩形，
			子情况(4,类似上面，只是把i,j交换)：i=(en[v]+1)~en[u],j=be[v]~en[v]
				那么这就对应着((en[v]+1)~en[u],be[v]~en[v])这样一个矩形，
	也就是说，我们把上面这些矩形覆盖在平面上，
	如果发现(i,j)这个点被覆盖的话，就表明，i到j的路径上有这么一个颜色。
	由于一条路径上的同一个颜色只能计算一次。
	所以把相同颜色的点归在一起，然后一种颜色一种颜色去做。
	把当前颜色的点产生的矩形全部去覆盖平面，
	然后用扫描线+线段树维护区间覆盖去得到每个x位置上y被覆盖的长度y_cover，
	y_cover的含义就是，只考虑当前颜色时，sum[x]的值 
	(当然不用逐个求出每个x位置上y的覆盖长度，这里采用一个数组去记录sum[x]的差分，最后再求一遍前缀就好了)
	 
**●时间复杂度分析：**

		显然影响时间复杂度的关键在维护若干矩形的覆盖上面。
		对于每个矩形，会存在logN级别的时间花费。
		由于每个点最多只会产生常数k个矩形
		所以，复杂度就O(K*N*logN).
		但是每个点会产生的矩形最多有8个，
		所以复杂度里的K再乘上线段树的覆盖和查询次数也就相当于一个logN了，
		这也是这个做法跑得比较慢的原因。 
		
**	至于点分治的做法，推荐这个很棒的题解：
	https://www.luogu.org/blog/user24559/solution-p2664**
	
~~（那个read()是真的被卡常了，并不是个人觉得写起来比scanf()顺手，迷...）~~
```cpp
#include<bits/stdc++.h>
#define MAXN 100050
#define INF 0x3f3f3f3f
using namespace std;
int N,dnt,snt;
int be[MAXN],en[MAXN],fa[MAXN];
long long cc[MAXN],ANS[MAXN];
struct List{
	int lnt;
	int to[MAXN*2],nxt[MAXN*2],head[MAXN];
	List():lnt(2){}
	void Add(int c,int u){
		to[lnt]=u; nxt[lnt]=head[c]; head[c]=lnt++;
	}
}CL,E;
struct Segment{
	//Every vertice can lead to (4 + the num of son*4) Plates. In the other words there are 2*4*2*N segments at most.
	int x,yl,yr,k;
	bool operator < (const Segment &rtm) const{
		return x<rtm.x||(x==rtm.x&&k>rtm.k);
	}
}S[MAXN*16];
struct SGT{
	//The Segment Tree are used to maintain the cover of the line.
	int size,root;
	int ls[MAXN*2],rs[MAXN*2],cover[MAXN*2],tag[MAXN*2];
	void Pushup(int u,int l,int r){
		cover[u]=tag[u]?(r-l+1):cover[ls[u]]+cover[rs[u]];
	}
	void Modify(int &u,int l,int r,int al,int ar,int k){
		if(!u) u=++size;
		if(al<=l&&r<=ar) return (void)(tag[u]+=k,Pushup(u,l,r));
		int mid=(l+r)>>1;
		if(al<=mid) Modify(ls[u],l,mid,al,ar,k);
		if(mid<ar) Modify(rs[u],mid+1,r,al,ar,k);
		Pushup(u,l,r);
	}
}DT;
void dfs(int u,int dad){
	be[u]=++dnt; fa[u]=dad;
	for(int e=E.head[u];e;e=E.nxt[e]){
		int v=E.to[e]; if(v==dad) continue;
		dfs(v,u);
	}
	en[u]=dnt;
}
void insplate(int x1,int x2,int y1,int y2){
	if(x1>x2||y1>y2) return;
	S[++snt]=(Segment){x1,y1,y2,1};
	S[++snt]=(Segment){x2+1,y1,y2,-1};
}
void read(int &x){
	static int sign; static char ch;
	x=0; sign=1; ch=getchar();
	for(;ch<'0'||'9'<ch;ch=getchar()) if(ch==-'-') sign=-1;
	for(;'0'<=ch&&ch<='9';ch=getchar()) x=x*10+ch-'0';
	x=x*sign;
}
int main(){
	read(N); int minc=INF,maxc=0;
	for(int i=1,c;i<=N;i++)
		read(c),CL.Add(c,i),
		minc=min(minc,c),maxc=max(maxc,c);
	for(int i=1,a,b;i<N;i++)
		read(a),read(b),E.Add(a,b),E.Add(b,a);
	dfs(1,0);
	for(int c=minc,u,ycover;c<=maxc;c++){
		snt=0; ycover=0;
		for(int i=CL.head[c];i;i=CL.nxt[i]){
			u=CL.to[i];
			insplate(1,be[u],be[u],en[u]);
			insplate(be[u],en[u],1,be[u]);
			insplate(be[u],en[u],en[u]+1,N);
			insplate(en[u]+1,N,be[u],en[u]);
			for(int e=E.head[u];e;e=E.nxt[e]){
				int v=E.to[e]; if(v==fa[u]) continue;
				insplate(be[u],be[v]-1,be[v],en[v]);
				insplate(be[v],en[v],be[u],be[v]-1);
				insplate(be[v],en[v],en[v]+1,en[u]);
				insplate(en[v]+1,en[u],be[v],en[v]);
			}
		}
		sort(S+1,S+snt+1);
		for(int i=1;i<=snt;i++){
			cc[S[i-1].x]+=ycover;
			cc[S[i].x]-=ycover;
			DT.Modify(DT.root,1,N,S[i].yl,S[i].yr,S[i].k);
			ycover=DT.cover[DT.root];
		}
	}
	for(int i=1;i<=N;i++) ANS[i]=ANS[i-1]+cc[i];
	for(int i=1;i<=N;i++) printf("%lld\n",ANS[be[i]]);
	return 0;
}    
```

---

## 作者：arimx (赞：14)

### 换根 dp

蒟蒻不会~~淀粉质~~……

[P2664 树上游戏](https://www.luogu.com.cn/problem/P2664)

首先我们可以观察到，如果节点 $i$ 到根节点 $rt$ 的路径上没有颜色为 $c[i]$ 的节点（包括 $rt$），那么 $i$ 对答案 $f[rt]$ 的贡献为 $size[i]$；如果路径上有颜色为 $c[i]$ 的节点，那么 $i$ 对 $f[rt]$ 就没有贡献。

那么 $f[rt]$ 就很好得到了，跑第一遍 dfs 时开个数组 $a$ 记录每种颜色的贡献，最后相加就可以了。

考虑如何由 $f[lst]$ 转移到其子节点 $f[u]$。显然只有 $c[lst]$ 和 $c[u]$ 会改变：$lst$ 变成 $u$ 的儿子，使 $c[lst]$ 贡献减少了 $size[u]$；$u$ 变成根节点，$c[u]$ 的贡献会变为 $n$。但是注意到，原本在 $u$ 的子树中颜色为 $c[lst]$ 的节点可能会产生新的贡献，也要计入 $f[u]$；原本不在 $u$ 的子树中的颜色为 $c[u]$ 的节点本来有贡献而现在就没有贡献了，不能计算至 $f[u]$ 中。

对于前者，我们可以再开一个数组 $b$ 记录 “$u$ 的子树中颜色为 $c[lst]$ 的节点在以 $u$ 为根节点时的贡献”。在跑第一遍 dfs 时，每次把 $a[c[lst]]$ 存起来并清空，在子树中遇到颜色为 $c[lst]$ 的节点时正常添加贡献，这样我们回溯时得到的 $a[c[lst]]$ 就是 $b[u]$ 了。将 $a[c[lst]]$ 还原覆盖子树中的贡献即可（这样做也不需要判断某个节点到根节点路径上是否有相同的颜色，如果有的话这个节点的贡献就会被覆盖掉）。

对于后者，我们考虑在跑第二遍 dfs 时，用数组 $a$ 维护根节点为当前点时每种颜色的贡献（跑完第一遍 dfs 时 $a$ 维护的是以 $rt$ 为根节点时每种颜色的贡献，在此基础上每次转移可以 $O(1)$ 修改），访问某个节点而还未修改 $a[c[u]]$ 时 $a[c[u]]$ 应当是以 $lst$ 为根时 $c[u]$ 的贡献，而我们又知道以 $u$ 为根节点时 $a[c[u]$ 一定为 $n$，二者之差即为 $c[u]$ 新增的贡献。回溯时记得还原 $a$。

于是我们就能得到 $f[u]=f[lst]-size[u]+b[u]+n-a[c[u]]$。

---

细节见代码（~~码风毒瘤轻喷~~）

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e5+10,C=1e5+10;
int n;
int c[N];
int hd[N],to[N<<1],nxt[N<<1],cnte;
int sz[N];
int a[C],b[N];
ll f[N],ans;
void add_edge(int u,int v){
	cnte++;
	to[cnte]=v;
	nxt[cnte]=hd[u];
	hd[u]=cnte;
	return;
}
template<typename T>
void rd(T &a){
	T f=1,x=0;
	char c=getchar();
	for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
	for(;isdigit(c);c=getchar())x=x*10+c-'0';
	a=f*x;
	return;
}
template<typename T>
void wt(T x){
	if(x<0)putchar('-'),x=-x;
	if(x>9)wt(x/10);
	putchar(x%10+'0');
	return;
}
void dfs1(int u,int lst){
	int tmp=a[c[u]];//提前存起来方便之后还原 
	a[c[lst]]=0;//清空 c[lst] 贡献，用以记录子树中的贡献 
	sz[u]=1;
	for(int i=hd[u];i;i=nxt[i]){
		int v=to[i];
		if(v==lst)
			continue;
		dfs1(v,u);
		sz[u]+=sz[v];
	}
	a[c[u]]=sz[u];//将子树中的贡献覆盖
	b[u]=a[c[lst]];
	a[c[u]]+=tmp;//这里分开两步是为了防止 u 与 lst 颜色相同时 b[u] 记录上不属于子树中的贡献
	return;
}
void dfs2(int u,int lst){
	int tmp1=a[c[u]],tmp2=a[c[lst]];
	if(u!=1){
		f[u]=f[lst]-sz[u]+b[u]+n-a[c[u]];//此时 a[c[u]] 还没有修改，存的是以 lst 为根时 c[u] 的贡献 
		a[c[u]]=n,a[c[lst]]=n-sz[u]+b[u];//现在 a 是以 u 为根节点时每种颜色的贡献了 
	}
	for(int i=hd[u];i;i=nxt[i]){
		int v=to[i];
		if(v==lst)
			continue;
		dfs2(v,u);
	}
	a[c[u]]=tmp1,a[c[lst]]=tmp2;
}
int main(){
	rd(n);
	for(int i=1;i<=n;i++)
		rd(c[i]);
	for(int i=1,u,v;i<n;i++){
		rd(u),rd(v);
		add_edge(u,v),add_edge(v,u);
	}
	dfs1(1,0);//直接把 1 当做根节点 
	for(int i=1;i<=1e5;i++)
		f[1]+=a[i];
	dfs2(1,0);
	for(int i=1;i<=n;i++)
		wt(f[i]),putchar('\n');
	return 0;
}
```


---

## 作者：ljk123 (赞：9)

# 树上游戏题解
@ sxd666888巨佬，太巨了，$O(n)$做法虐爆全场。

但是细节有点没讲清楚（~~我理解能力太差了~~）

我来补充一下细节(~~大佬认为我们理所应当理解的东西~~)

**$upd:$(作者上面有些图画错了，每一小树块中不应该包括蓝色的点，难以修改，敬请谅解。)**

首先，删除某一种颜色会形成很多棵小树，

**注意：此文中小树跟子树不同。**

我们若将每种颜色的贡献看为这条路径上的第一个点，


那么，

每棵小树中的所有点到其它小树上的任意点都会经过这棵小树的根的父亲，

会有一次贡献。

如图样例：

![](https://img2018.cnblogs.com/blog/1655789/201908/1655789-20190828182605783-1603958222.png)

删除蓝色点后：

![](https://img2018.cnblogs.com/blog/1655789/201908/1655789-20190828182635763-402681221.png)
我们不妨看一看图中的点$x$，

到小树外任意一点的路径上都经过点$y$，且经过的第一个蓝点就是$y$。

看图感性理解一下吧。

![](https://img2018.cnblogs.com/blog/1655789/201908/1655789-20190828183217995-545383655.png)

所以，每个点在删除一种颜色以后，这种颜色对每个点的贡献为$(n-siz)$(其中$siz$为小树大小)。

每个点所有颜色的贡献为
$(n-siz_{1})+(n-siz_{2})+...+(n-siz_{num})=n*num-\sum_{i=1}^{num}siz_{i}$

**注意：每个点自己的颜色的贡献为n,因为在到每个点的路径上，它都是第一个此颜色的点。**

将每棵小树的大小存于根处($dfs$)，

最后统计($get_ans$)。

再说一下咱数组的定义。

$c[x]:x$的颜色，$v[x]:$表示这种颜色是否出现，$siz[x]:$x的字数大小，$sz:$删除父亲颜色后的小树大小，

$sub[x]:$记录删除颜色为$x$的点后，与此小树不连通的点数大小，$pre[x]:$删除颜色为x的点后，上一棵小树的大小(父亲祖辈上的)

$ans[x]:$答案，$sum:$ 目前此点被覆盖的小树的大小之和。

总共分为两步：$dfs()$和get_ans()$上面讲了)

我就贴贴代码，贴贴图片吧:

### $1.dfs():$

![](https://img2018.cnblogs.com/blog/1655789/201908/1655789-20190828192707274-1272430182.png)


```cpp
void dfs(int x,int fa){
     siz[x]=1; ll tmp=sub[c[fa]];//储存这棵子树外的sub(包括其它子树和父辈)
     FOR(i,x)
         if(e[i].to!=fa)
            dfs(e[i].to,x),siz[x]+=siz[e[i].to];//求x的子树大小
     ++sub[c[x]];//删去此点
     if(fa) sz[x]=siz[x]-sub[c[fa]]+tmp,sub[c[fa]]+=sz[x];//sz[x]:求以x为根的小树大小，sub更新，图中有详解
}
```
### 2.get_ans():

![](https://img2018.cnblogs.com/blog/1655789/201908/1655789-20190828194615033-1744279463.png)


```cpp
void get_ans(int x,int fa){
     ll tmp=pre[c[fa]];//记录父辈里之前一块的被此颜色覆盖的点数
     sum+=sz[x]-tmp,pre[c[fa]]=sz[x],ans[x]=n*num-sum+pre[c[x]];
     //sum将颜色为c[fa]的块大小更新，pre也更新，ans的式子上面有解释
     FOR(i,x)
        if(e[i].to!=fa)
           get_ans(e[i].to,x);
     pre[c[fa]]=tmp,sum-=sz[x]-tmp;
     //还原，不将影响带到另一棵子树
}
```
**注意：$++sub[c[x]]$不能放在$if(fa)$之后，因为存在父亲儿子颜色相同的情况，在此情况中：**
![](https://img2018.cnblogs.com/blog/1655789/201908/1655789-20190828194615033-1744279463.png)

**还有，处理一下根节点的情况，剩下的就是它的。**

![](https://img2018.cnblogs.com/blog/1655789/201908/1655789-20190828202727585-772560553.png)

总代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
#define For(i,l,r) for(int i=(l);i<=(r);++i)
#define FOR(i,x) for(int i=head[x];i;i=e[i].nxt)
using namespace std;
const int N=1e5+6;
int t1,t2,cnt=0,c[N],v[N],siz[N],sz[N],sub[N],head[N];
ll n,num=0,sum=0,pre[N],ans[N];
struct edge{int nxt,to;}e[N<<1];
inline void add(int u,int v){e[++cnt].nxt=head[u],e[cnt].to=v,head[u]=cnt;}
inline int rd(){
   int T=0,F=1; char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-') F=-1; ch=getchar();}
   while(ch>='0'&&ch<='9') T=(T<<3)+(T<<1)+(ch-48),ch=getchar();
   return F*T;
}
void dfs(int x,int fa){
     siz[x]=1; ll tmp=sub[c[fa]];//储存这棵子树外的sub(包括其它子树和父辈)
     FOR(i,x)
         if(e[i].to!=fa)
            dfs(e[i].to,x),siz[x]+=siz[e[i].to];//求x的子树大小
     ++sub[c[x]];//删去此点
     if(fa) sz[x]=siz[x]-sub[c[fa]]+tmp,sub[c[fa]]+=sz[x];//sz[x]:求以x为根的小树大小，sub更新，图中有详解
}
void get_ans(int x,int fa){
     ll tmp=pre[c[fa]];//记录父辈里之前一块的被此颜色覆盖的点数
     sum+=sz[x]-tmp,pre[c[fa]]=sz[x],ans[x]=n*num-sum+pre[c[x]];
     //sum将颜色为c[fa]的块大小更新，pre也更新，ans的式子上面有解释
     FOR(i,x)
        if(e[i].to!=fa)
           get_ans(e[i].to,x);
     pre[c[fa]]=tmp,sum-=sz[x]-tmp;
     //还原，不将影响带到另一棵子树
}
int main(){
    n=read();
    For(i,1,n){
        c[i]=read();
        if(!v[c[i]]) v[c[i]]=1,++num;
    }
    For(i,1,n-1) t1=read(),t2=read(),add(t1,t2),add(t2,t1);
    dfs(1,0);
    For(i,1,1e5) if(v[i]) sum+=n-sub[i],pre[i]=n-sub[i]; //特殊处理根节点
    get_ans(1,0);
    For(i,1,n) printf("%lld\n",ans[i]);
    return 0;
} 
```
温馨提示：代码临时拼凑，并一定能对哦，但理解起来没问题。

---

## 作者：洛水·锦依卫 (赞：9)


[My Blog](https://www.cnblogs.com/luoshuitianyi/p/10472957.html)
---

点分治的神仙题哇天哪，一个个题解看得我那叫一个懵。我还是看神仙的题解才懂的，我这篇题解希望能让您们理解神仙的做法。

首先瞅一眼数据范围 $10^5......$ 是 $nlog$ 或 $nlog^2$ 的标准范围，那么很显然我们不能统计路径，而是应该统计颜色对路径们的贡献。则第一时间发现和树上路径有关，自然上点分。

那么点分怎么搞呢？说来就不简单啊 $......$ ，对于当前处理的这颗子树，我们记 $cnt[i]$ 为它的所有子树内到他的路径中包含颜色 $i$ 的路径条数，那么当处理到一颗子树内的时候，我们统计得到其他子树贡献的所有 $cnt$ 数组，那么对于该子树内的一个点，先不考虑它到根节点的路径上的颜色，则其它子树内的颜色对当前节点 $x$ 的贡献肯定为 $\sum cnt[i]$ (您别告诉我这个看不出来就成) 。

那么这样一来就有问题如下：

- $cnt$ 数组如何统计。
- 当前节点 $i$ 到根节点路径上的颜色的贡献如何处理。

我们先解决 $cnt$ 数组，这个很简单，我们先统计每颗子树的 $cnt$ 数组，设 $col[i]$ 为点 $i$ 的颜色，则每当我们访问到一个之前没有出现过的颜色 $col[i]$ ，那么 $cnt[col]+=size[i]$ 。我想这个很好理解，因为子树内的每个节点到根节点的路径上都经过了节点 $i$ 。所以我们只需要开个 $book$ 数组记录 $book[i]$ 为当前节点到根节点路径上颜色为 $i$ 的节点个数，进入 $i$ 节点的时候 $book[col[i]]++$ ，退出时 $--$ 即可。

如何减去当前处理的子树对 $cnt$ 数组的贡献呢？当然是在处理这颗子树之前再扫一遍，把贡献去掉，处理完之后又扫一遍，再加回来 = = 。~~我也觉得很蠢。~~

第二个问题稍稍难想一点，设当前分治的子树为 $now$ ，我们先 $dfs$ 统计贡献，对于当前结点 $i$ ，我们记录 $tot=\sum_{col[j]\in col[pre_i]} cnt[col[j]]$ ，也就是将 $i$ 到根节点路径上的颜色在 $cnt$ 数组中对应贡献记录下来，由于其他子树内这些颜色的路径到点 $i$ 也会经过这些点，我们不能重复计算贡献，那就只能牺牲 $cnt$ 数组的贡献了 $QwQ$ 。

接着，如果统计的过程中遇到了一个新的颜色，那么 $tot+=cnt[col[i]]$ ，可以预料到的是，这个新颜色对它的子树内每个节点的贡献肯定是 $size[root]-size[now]$ ，也即当前分治子树外所有节点都可以通过当前节点到达当前节点子树内的节点，我们带着这个贡献往下 $dfs$ ，设其为 $num$ ，在设一个 $sum=\sum cnt[i]$ 来表示总贡献，那么当我们 $dfs$ 到点 $i$ 的时候就变成了如下流程：

- 判断点 $i$ 的颜色是否出现过，若没有，则 $tot+=cnt[col[i]],num+=size[root]-size[now]$ 。
- $ans[i]+=sum-tot+num$

然后分治递归处理更多的子树就完了！

不理解可以看下代码(码风仙，无空格，不过有注释)

# Code

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,col[100001];
int rt,sum,top,Y,maxs[100001],size[100001],now[100001],cbook[100001],cnt[100001];
int head[100001],nx[200001],to[200001];
bool vis[100001],Book[100001];
long long Sum,ans[100001];
void add(int u,int v,int d)
{
	to[d]=v,nx[d]=head[u];
	head[u]=d;
}
void getrt(int x,int fa)
{
	size[x]=1,maxs[x]=0;
	for(int i=head[x];i;i=nx[i])
		if(to[i]!=fa&&!vis[to[i]])
		{
			getrt(to[i],x);
			size[x]+=size[to[i]];
			maxs[x]=max(maxs[x],size[to[i]]);
		}
	maxs[x]=max(maxs[x],sum-size[x]);
	if(maxs[x]<maxs[rt])rt=x;
}
void getsize(int x,int fa)
{
	size[x]=1;
	for(int i=head[x];i;i=nx[i])
		if(to[i]!=fa&&!vis[to[i]])
			getsize(to[i],x),size[x]+=size[to[i]];
}
void getcol(int x,int fa)
{
	if(!now[col[x]])
	{
		cnt[col[x]]+=size[x];
		Sum+=size[x];
	}//如果没出现过，我们的贡献就 +=size
	if(!Book[col[x]])cbook[++top]=col[x],Book[col[x]]=true;//记录一下当前分治的部分总共有哪些颜色
	now[col[x]]++;//出现次数变更
	for(int i=head[x];i;i=nx[i])
		if(to[i]!=fa&&!vis[to[i]])
			getcol(to[i],x);
	now[col[x]]--;
}
void delcol(int x,int fa)
{
	if(!now[col[x]])
	{
		cnt[col[x]]-=size[x];
		Sum-=size[x];
	}
	now[col[x]]++;
	for(int i=head[x];i;i=nx[i])
		if(to[i]!=fa&&!vis[to[i]])
			delcol(to[i],x);
	now[col[x]]--;
}
void Count(int x,int fa,int num,long long tot)
{
	if(!now[col[x]])num++,tot+=cnt[col[x]];//如果此颜色首次出现，辣么记录 tot 贡献
	now[col[x]]++;
	ans[x]+=Sum-tot+num*Y;//ans的处理
	for(int i=head[x];i;i=nx[i])
		if(to[i]!=fa&&!vis[to[i]])
			Count(to[i],x,num,tot);
	now[col[x]]--;
}
void work(int x)
{
	getsize(x,0);//先把 size 处理出来
	Sum=0,top=0;
	getcol(x,0);//统计所有子树的 cnt 数组
	for(int i=head[x];i;i=nx[i])
		if(!vis[to[i]])
		{
			now[col[x]]++,delcol(to[i],x),cnt[col[x]]-=size[to[i]],Sum-=size[to[i]];//先减去当前子树的贡献，各种减就对了
			Y=size[x]-size[to[i]],Count(to[i],x,0,0);//Y 就是其他子树的节点数
			getcol(to[i],x),now[col[x]]--,cnt[col[x]]+=size[to[i]],Sum+=size[to[i]];//再把贡献加回来QwQ
		}
	ans[x]+=Sum-cnt[col[x]]+size[x];
	for(int i=1;i<=top;i++)//将出现过的颜色的贡献统统删掉
		Book[cbook[i]]=false,cnt[cbook[i]]=0;
}
void solve(int x)
{
	vis[x]=true;
	work(x);//开始计算贡献
	for(int i=head[x];i;i=nx[i])
		if(!vis[to[i]])
		{
			rt=0,sum=size[to[i]];
			getrt(to[i],x);
			solve(rt);
		}
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)scanf("%d",&col[i]);
	int u,v;
	for(int i=1;i<n;i++)
	{
		scanf("%d%d",&u,&v);
		add(u,v,i);
		add(v,u,i+n);
	}
	maxs[rt=0]=sum=n;
	getrt(1,0);//求重心
	solve(rt);
	for(int i=1;i<=n;i++)
		printf("%lld\n",ans[i]);
}
```

---

## 作者：ecnerwaIa (赞：5)

### [传送门](https://www.luogu.org/problemnew/show/P2664)  
题目要求$sum_j=\sum_{i=1}^ns(i,j)$,其中$s(i,j)$为$(i,j)$路径上的颜色数量，$n,c[i]\leq 1e5$。  
看到这题想到了点分治，然而不太好想，于是就换了个思路想了下$O(n)$,发现对于每个颜色，删去该颜色的所有点，则剩下的所有联通块的答案都要加上$n-siz,siz$是联通块的点数。  
注意这里是极大联通块，因为该极大联通块中无该颜色的点，即连通块内不会产生贡献，而联通块外任意一点都可以对此联通块产生1的贡献。  
但是关键是怎么求对于每个点不含某种颜色的极大联通块？  
### 40pts:  
直接记$siz[i][j]$为以$i$为根的子树中不含颜色$j$的联通块点数。  
转移时$siz[x][i]=\sum_{u\in son[x]}siz[u][i],siz[x][col[x]]=0$即可  
记$rt[x]$为不含$col=x$的极大联通块的根，如果说$rt[x]$在从$fa$转移到$x$的时候还能包含$x$那么就不用管，但是因为到$x$，可能含$col[fa[x]]$,不能含$col[x]$，只有这两个联通块会发生改变，那么就$+siz[x][col[fa[x]]]-siz[rt[col[x]]][col[x]]$即可。  
注意还要将$rt$修改。  
```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int N=2e3+10;
int d[N],nxt[N<<1],to[N<<1],n,tot;
int ans[N],fa[N],col[N],siz[N],del[N],S;
int dp[N][N];
inline void ins(int a,int b){to[++tot]=b,nxt[tot]=d[a],d[a]=tot;}
inline void dfs(int x){
	for(int i=1;i<=S;++i)dp[x][i]=1;
	for(int i=d[x];i;i=nxt[i]){
		int u=to[i];
		if(u!=fa[x]){
			fa[u]=x;
			dfs(u);
			for(int j=1;j<=S;++j)
				dp[x][j]+=dp[u][j];
		}
	}dp[x][col[x]]=0;
}int a[N],rt[N];
inline void work(int x,int tmp){
	tmp+=dp[x][col[fa[x]]]-dp[rt[col[x]]][col[x]];
	int p=rt[col[x]];
	ans[x]=n*S-tmp;
	for(int i=d[x];i;i=nxt[i]){
		int u=to[i];
		if(u!=fa[x]){
			rt[col[x]]=u;
			work(u,tmp);
		}
	}rt[col[x]]=p;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i)scanf("%d",&col[i]),a[i]=col[i];
	sort(a+1,a+1+n),S=unique(a+1,a+1+n)-a-1;
	for(int i=1;i<=n;++i)col[i]=lower_bound(a+1,a+1+S,col[i])-a;
	int u,v;
	for(int i=1;i<n;++i)scanf("%d%d",&u,&v),ins(u,v),ins(v,u);
	dfs(1);int T=0;
	for(int i=1;i<=S;++i)T+=dp[1][i],rt[i]=1;
	work(1,T);
	for(int i=1;i<=n;++i)printf("%d\n",ans[i]);
	return 0;
}

```

### 100pts:
想了半天没想出来，看了题解才想出来 ~~（但是感觉讲的不清楚）~~  
40pts复杂度主要在于预处理除了所有点的所有颜色，那么有必要吗？  
实际上其实只和$fa$和$rt$有关，而$dp[rt[col[x]]][col[x]]$是可以再用一个变量记下的，那么就只剩下一个$dp[x][col[fa[x]]]$，那么岂不是只需要处理出$dp[x][col[fa[x]]]$就好了？  
那么就用个$lz[x]$代表$dp[x][col[fa[x]]]$,$tag[x]$代表$dp[rt[x]][x]$。  
预处理的话其实不算太难，具体代码有注释。  
那么之后就做下差就可以愉快的从$fa$转移到$x$啦！ 
即$-tag[col[fa[x]]]+lz[x]$。但是由于$tag[col[x]]$被多减了，统计答案要加回去。代码有~~详细~~注释。  
```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N=1e5+10;
LL ans[N],qwq;
int d[N],nxt[N<<1],to[N<<1],n,tot;
int fa[N],col[N],siz[N],del[N],S;
int lz[N],tag[N];
inline void ins(int a,int b){to[++tot]=b,nxt[tot]=d[a],d[a]=tot;}
inline void dfs(int x){
	siz[x]=1;
	int tmp=del[col[fa[x]]];
	for(int i=d[x];i;i=nxt[i]){
		int u=to[i];
		if(u!=fa[x]){
			fa[u]=x,dfs(u);
			siz[x]+=siz[u];
		}
	}++del[col[x]];
	if(fa[x]){
		lz[x]=siz[x]-(del[col[fa[x]]]-tmp);//不含col[fa[x]]的极大联通块 
		del[col[fa[x]]]+=lz[x];// lz[x]+del[col[fa[x]]]-tmp=siz[x] 
	}
}int a[N];
//处理出的del[i]是含col=i的联通块的点数。 
//同一条链有若干个相同颜色只有最浅的x对del有siz[x]的贡献。  
//那么显然n-del[i]是根节点不含col=i的且含根节点1的极大联通块的点数。 
inline void work(int x){
	//tag[z]代表不含z颜色的且含x的极大联通块点数 
	//只有col[x]和col[fa[x]]两块发生改变。
	//lz[x]记的x不含col[fa[x]]的极大联通块点数之和 
	//pre:在此之前不含col[fa[x]]的极大联通块点数之和
	//做差即可得求出col[fa[x]]的改变量 
	int pre=tag[col[fa[x]]]; 
	qwq+=lz[x]-pre; 
	tag[col[fa[x]]]=lz[x];
	//联通块改变了，要更新tag 
	ans[x]=n*1ll*S-qwq+tag[col[x]];
	//注意因为上面tag[col[fa[x]]]是含了col[x]的,但是lz[x]不含col[x]的, 
	for(int i=d[x];i;i=nxt[i]){
		int u=to[i];
		if(u!=fa[x])work(u);
	}tag[col[fa[x]]]=pre;
	qwq-=lz[x]-pre;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i)scanf("%d",&col[i]),a[i]=col[i];
	sort(a+1,a+1+n),S=unique(a+1,a+1+n)-a-1;
	for(int i=1;i<=n;++i)col[i]=lower_bound(a+1,a+1+S,col[i])-a;
	int u,v;
	for(int i=1;i<n;++i)scanf("%d%d",&u,&v),ins(u,v),ins(v,u);
	dfs(1);
	for(int i=1;i<=S;++i)qwq+=n-del[i],tag[i]=n-del[i];//初始化一下 
	work(1);
	for(int i=1;i<=n;++i)printf("%lld\n",ans[i]);
	return 0;
}

```

---

## 作者：xudaxia (赞：4)

点分治真是一个好东西。~~可惜我不会~~  
这种要求所有路经的题**很可能**是点分治。  
然后我就不会了。。  
既然要用点分治，就想，点分治有哪些优点？它可以$O(nlogn)$遍历分治树的所有子树。  
那么现在的问题就是，如可快速（$O(n)$或O$(nlogn)$）求以一个点为根的时候，子树之间的贡献（当然还有根节点的）。  
我们注意到一件事，就是一棵子树中一个点对其他子树的点产生贡献当且仅当这个点的颜色在它到根的路径上第一次出现（或者说只算上这些贡献答案正确），且贡献为以这个点为根的子树大小。（不考虑其它子树的颜色)  
这个有什么用，我们可以遍历两遍子树，第一遍预处理出所有子树对其它子树的贡献（如上边一段所说把贡献统计），第二次遍历每一颗子树先把这颗树的贡献去掉，统计所有其它的树对这颗树的贡献。  
那么具体该怎么做？
```cpp
void calc(int u){
	dfs1(u,0);
	ans[u]+=sum;
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(vis[v])continue;
		cnt[a[u]]++;
		sum-=size[v];color[a[u]]-=size[v];
		change(v,u,-1);
		cnt[a[u]]--;
		tot=size[u]-size[v];
		dfs2(v,u);
		cnt[a[u]]++;
		sum+=size[v];color[a[u]]+=size[v];
		change(v,u,1);
		cnt[a[u]]--;
	}
	clear(u,0);
}
```
首先dfs1是统计贡献的，用sum记录贡献和，color[i]记录第i种颜色的贡献。
然后根的答案就可以累加了。  
那么如可判断一个颜色第一次出现？可以记录一个cnt[i]记录第i种颜色在到根的路径上出现多少次。当cnt[i]等于1的时候统计贡献。  
然后
```cpp
		cnt[a[u]]++;
		sum-=size[v];color[a[u]]-=size[v];
		change(v,u,-1);
		cnt[a[u]]--;
```
用来消除子树贡献。dfs2统计其它子树对这颗子树的贡献。  
```cpp
void dfs2(int u,int f){
	cnt[a[u]]++;
	if(cnt[a[u]]==1){
		sum-=color[a[u]];
		num++;
	}
	ans[u]+=sum+num*tot;
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v==f||vis[v])continue;
		dfs2(v,u);
	}
	if(cnt[a[u]]==1){
		sum+=color[a[u]];
		num--;
	}
	cnt[a[u]]--;
}
```
如果这颗子树中出现一个颜色，并且它是第一次出现，那么减去所有子树的color[a[u]]，加上其它子树的节点总数，因为每一条到其它子树的路径都会产生贡献，这也是我们一开始不考虑贡献对其他子树影响的原因，因为遍历子树的时候会把这些重复的贡献减去。  
更具体还是看代码。
```cpp
// luogu-judger-enable-o2
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
#define int long long
const int N=101000;
int Cnt,head[N];
int g[N],size[N],cnt[N],a[N],sum,color[N],tot,num,root,all,vis[N],ans[N],n;
struct edge{
	int to,nxt;
}e[N*2];
void add_edge(int u,int v){
	Cnt++;
	e[Cnt].nxt=head[u];
	e[Cnt].to=v;
	head[u]=Cnt;
}
int read(){
	int sum=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){sum=sum*10+ch-'0';ch=getchar();}
	return sum*f;
}
void getroot(int u,int f){
	g[u]=0;size[u]=1;
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v==f||vis[v])continue;
		getroot(v,u);
		size[u]+=size[v];
		g[u]=max(g[u],size[v]);
	}
	g[u]=max(g[u],all-size[u]);
	if(g[u]<g[root])root=u;
}
void dfs1(int u,int f){
	cnt[a[u]]++;
	size[u]=1;
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v==f||vis[v])continue;
		dfs1(v,u);
		size[u]+=size[v];
	}
	if(cnt[a[u]]==1){
		sum+=size[u];
		color[a[u]]+=size[u];
	}
	cnt[a[u]]--;
}
void clear(int u,int f){
	cnt[a[u]]++;
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v==f||vis[v])continue;
		clear(v,u);
	}
	if(cnt[a[u]]==1){
		sum-=size[u];
		color[a[u]]-=size[u];
	}
	cnt[a[u]]--;
}
void dfs2(int u,int f){
	cnt[a[u]]++;
	if(cnt[a[u]]==1){
		sum-=color[a[u]];
		num++;
	}
	ans[u]+=sum+num*tot;
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v==f||vis[v])continue;
		dfs2(v,u);
	}
	if(cnt[a[u]]==1){
		sum+=color[a[u]];
		num--;
	}
	cnt[a[u]]--;
}
void change(int u,int f,int k){
	cnt[a[u]]++;
	if(cnt[a[u]]==1){
		sum+=k*size[u];color[a[u]]+=k*size[u];
	}
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v==f||vis[v])continue;
		change(v,u,k);
	}
	cnt[a[u]]--;
}
void calc(int u){
	dfs1(u,0);
	ans[u]+=sum;
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(vis[v])continue;
		cnt[a[u]]++;
		sum-=size[v];color[a[u]]-=size[v];
		change(v,u,-1);
		cnt[a[u]]--;
		tot=size[u]-size[v];
		dfs2(v,u);
		cnt[a[u]]++;
		sum+=size[v];color[a[u]]+=size[v];
		change(v,u,1);
		cnt[a[u]]--;
	}
	clear(u,0);
}
void work(int u){
	calc(u);
	vis[u]=1;
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(vis[v])continue;
		root=0,all=size[v];
		getroot(v,0);
		work(root);
	}
}
signed main(){
	n=read();
	for(int i=1;i<=n;i++)a[i]=read();
	for(int i=1;i<n;i++){
		int u=read(),v=read();
		add_edge(u,v);add_edge(v,u);
	}
	g[0]=n+10;root=0;all=n;
	getroot(1,0);work(root);
	for(int i=1;i<=n;i++)printf("%lld\n",ans[i]);
	return 0;
}
```

---

## 作者：_LAUV_ (赞：2)

知道是点分治，但并不是很好想。

#### cnt[col]: 从此时的重心出发到所有的子树内，包含颜色col的路径数。
#### sum[i]：答案。

所以每一次枚举了重心后，先DFS一次，求出包含重心的整棵子树的cnt. 

ext[ ] 和 has[ ] 用于给颜色判重，Cst[ ]是储存颜色的栈

```cpp
void DFS(int x,int fa, llg *cnt){
	if(!ext[c[x]])Cst[++top]=c[x],ext[c[x]]=1;
	if(++has[c[x]]==1){
		cnt[c[x]]+=siz[x];
	}
	for(Re int i=head[x];i;i=nxt[i]){
		int vv=v[i];
		if(vis[vv]||vv==fa)continue;
		DFS(vv,x,cnt);
	}
	has[c[x]]--;
}
```

这样子我们就可以更新重心了 sum[x]+= ∑ cnt[ i ]

有了cnt以后我们要如何到重心外的子树里更新里面的点呢？

这类统计数目的点分治题有一个套路性的做法。

先上图


![](https://cdn.luogu.com.cn/upload/pic/50361.png)

对这个子树像上面一样DFS一次，把子树对应的cnt数组求出来，存到ct[]里面，然后这个分治块除子树的其余部分的cnt，就可以通过相减求出来了。相当于把此时枚举的子树挖去，减去它的贡献，等一下用剩余部分的cnt来更新这个子树内的点。

设此时这个挖去一个子树的分治块大小（size)为Nsiz.

枚举与重心相连的子树，自上而下地遍历每一个节点。

没到一个点x 就可以更新它 sum[x]+= ∑ cnt[ i ] (此时的cnt[i]已经减去了子树的贡献）

但除了用cnt更新还不够，从上往下走的过程我们会遇到新的点、新的颜色。

设x的颜色为cx

所以此时的sum[x] 还要加上 Nsiz-cnt[cx] (此时的cnt[cx]已经减去了子树的贡献）
表示那些从子树外的点到子树内第一次出现颜色cx的路径的数量。

这是加的 Nsiz-cnt[cx] 也要加给下面的点，它会对整个子树造成贡献，所以用一个类似tag的变量存起来加给下面的点就可以了。在下面若再遇到颜色cx，则不需要再次计算。

每次处理完一个分治块，记得要把cnt[]清0，但不可以用memset。


```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>

#define For(i,a,b) for(register int i=a;i<=b;++i)
#define Dwn(i,a,b) for(register int i=a;i>=b;--i)
#define Pn putchar('\n')
#define Re register
#define llg long long

using namespace std;

const int N=1e5+5;

int head[N],nxt[N*2],v[N*2],BH=1;
int Cst[N],top=0,Cstx[N],siz[N],Mx[N];
llg ct[N],cnt[N],cct[N],sum[N],Ctot;
int n,m,c[N],x,y,rt,tot,Frt,tp,Nsiz;
bool vis[N],ext[N];

inline void read(int &v){
	v=0;
	char c=getchar();
	while(c<'0'||c>'9')c=getchar();
	while(c>='0'&&c<='9')v=v*10+c-'0',c=getchar();
}
void write(llg x){
	if(x>9)write(x/10);
	int xx=x%10;
	putchar(xx+'0');
}
void add(int ux,int vx){
	BH++;
	nxt[BH]=head[ux]; head[ux]=BH; v[BH]=vx;
	BH++;
	nxt[BH]=head[vx]; head[vx]=BH; v[BH]=ux;
}

int has[N];
void dfsRT(int x,int fa){
	siz[x]=1; Mx[x]=0; 
	for(Re int i=head[x];i;i=nxt[i]){
		int vv=v[i];
		if(vis[vv]||vv==fa)continue;
		dfsRT(vv,x);
		siz[x]+=siz[vv];
        Mx[x]=max(Mx[x],siz[vv]);
	}
	Mx[x]=max(Mx[x],tot-siz[x]);
	if(Mx[x]<Mx[rt])rt=x;
}
int getWRT(int x,int fa,int sz){
	rt=0; Mx[0]=2147483600; tot=sz;
	dfsRT(x,fa);
	return rt;
}
void getSIZ(int x,int fa){ 
	siz[x]=1;
	for(Re int i=head[x];i;i=nxt[i]){
		int vv=v[i]; 
		if(vis[vv]||vv==fa)continue;
		getSIZ(vv,x);
		siz[x]+=siz[vv];
	}
}
void DFS(int x,int fa, llg *cnt){ // 求cnt[] 
	if(!ext[c[x]])Cst[++top]=c[x],ext[c[x]]=1;
	if(++has[c[x]]==1){
		cnt[c[x]]+=siz[x];
	}
	for(Re int i=head[x];i;i=nxt[i]){
		int vv=v[i];
		if(vis[vv]||vv==fa)continue;
		DFS(vv,x,cnt);
	}
	has[c[x]]--;
}
void ReNEW(int x,int fa,llg Tag){ //更新子树内的点 
	if(++has[c[x]]==1){
		Tag+=Nsiz-cnt[c[x]];
    }
    sum[x]+=Ctot+Tag;
    for(Re int i=head[x];i;i=nxt[i]){
    	int vv=v[i];
    	if(vis[vv]||vv==fa)continue;
    	ReNEW(vv,x,Tag);
	}
	has[c[x]]--;
}
void Work(int x){    //分治 + 更新分治块 
	vis[x]=1;
	getSIZ(x,0);
	top=0; Ctot=0;
	DFS(x,0,cnt);
	For(i,1,top)ext[Cst[i]]=0;
	tp=top;
	For(i,1,top){
		Ctot+=cnt[Cst[i]];
		cct[Cst[i]]=cnt[Cst[i]];
		Cstx[i]=Cst[i];
	 
	}
	sum[x]+=Ctot;
	llg tmp=Ctot;
	
	for(Re int i=head[x];i;i=nxt[i]){
		int vv=v[i];
		if(vis[vv])continue;
		has[c[x]]=1;  //使和重心颜色一样的点不会被计算cnt 
		top=0;
		DFS(vv,x,ct);
		For(j,1,top)ext[Cst[j]]=0;
		has[c[x]]=0;
		
		cnt[c[x]]-=siz[vv]; Ctot-=siz[vv]; //减去重心颜色的贡献 
		For(j,1,top){
			int cx=Cst[j];
			cnt[cx]-=ct[cx];
			Ctot-=ct[cx];
		}
		Nsiz=siz[x]-siz[vv];
		ReNEW(vv,x,0);
		
		cnt[c[x]]+=siz[vv];  //还原 
		Ctot=tmp;
		For(j,1,top){
			int cx=Cst[j];
			cnt[cx]=cct[cx];
			ct[cx]=0;
		}
	}
	
	For(j,1,tp){
		int cx=Cstx[j];
		cnt[cx]=0;
	}
	
	for(Re int i=head[x];i;i=nxt[i]){ 
		int vv=v[i]; if(vis[vv])continue;
		getSIZ(vv,x);
		int NxRT=getWRT(vv,x,siz[vv]);
		Work(NxRT);
	}
	
}
int main(){
//	freopen("ex.in","r",stdin);
	memset(vis,0,sizeof(vis));
	memset(ext,0,sizeof(ext));
	read(n); 
	For(i,1,n)read(c[i]);
	For(i,1,n-1){
		read(x); read(y); add(x,y);
	}
	Frt=getWRT(1,0,n);
	Work(Frt);
	For(i,1,n){
		write(sum[i]); Pn;
	}
	return 0;
}
```


---

## 作者：p_b_p_b (赞：1)

[$$\large \color{purple} My\; Blog $$](https://www.cnblogs.com/p-b-p-b/p/10482817.html)


-------------------------

## 思路

首先，我们要脑洞大开想到点分治。

注意到每个点都要输出对应的$ans$，所以想到在点分树上跳，得到答案。

一个点答案的贡献要分为好几个部分。

#### 第一个

这是最容易统计的部分。你需要得到点分树上自己的子树对自己的贡献。

显然一个dfs即可搞定。

#### 第二个

假设当前要求的点是$x$，枚举它的祖先为$y$。

我们需要得到$y\rightarrow x$这条路径上的贡献乘上$size_y-size_x$，其中$size_x$表示x所在子树的大小，$size_y$表示$y$在点分树上子树大小。

显然这个可以在建点分树时用一个dfs搞定。

#### 第三个

还是上面的$x,y$，我们需要统计$y$子树中除去$x$子树的点对$x$的贡献。

考虑每种颜色分开考虑。

对于每个颜色，统计会出现它的路径，可以一个dfs搞定。

然后把$x$所在的子树的贡献删去之后就可以了。

#### 第四个

发现第二部分和第三部分会算重，要把重复的去掉。

对于$y\rightarrow x$路径上出现过的颜色，要把它出现过的路径数删去。

也是建树时一个dfs可以搞定的。

#### 最后

你发现上面这些全是建树时就可以算出来的，于是你根本不需要建树，直接搞就好了。

细节较多，祝你好运。

不过把我的缺省源删去后其实还挺短的，只有大概110行。

-------------------------

## 代码

```cpp
#include<bits/stdc++.h>
clock_t t=clock();
namespace my_std{
    using namespace std;
    #define pii pair<int,int>
    #define fir first
    #define sec second
    #define MP make_pair
    #define rep(i,x,y) for (int i=(x);i<=(y);i++)
    #define drep(i,x,y) for (int i=(x);i>=(y);i--)
    #define go(x) for (int i=head[x];i;i=edge[i].nxt)
    #define templ template<typename T>
    #define sz 101010
    typedef long long ll;
    typedef double db;
    mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
    templ inline T rnd(T l,T r) {return uniform_int_distribution<T>(l,r)(rng);}
    templ inline bool chkmax(T &x,T y){return x<y?x=y,1:0;}
    templ inline bool chkmin(T &x,T y){return x>y?x=y,1:0;}
    templ inline void read(T& t)
    {
        t=0;char f=0,ch=getchar();double d=0.1;
        while(ch>'9'||ch<'0') f|=(ch=='-'),ch=getchar();
        while(ch<='9'&&ch>='0') t=t*10+ch-48,ch=getchar();
        if(ch=='.'){ch=getchar();while(ch<='9'&&ch>='0') t+=d*(ch^48),d*=0.1,ch=getchar();}
        t=(f?-t:t);
    }
    template<typename T,typename... Args>inline void read(T& t,Args&... args){read(t); read(args...);}
    char sr[1<<21],z[20];int C=-1,Z=0;
    inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
    inline void print(register int x)
    {
    	if(C>1<<20)Ot();if(x<0)sr[++C]='-',x=-x;
    	while(z[++Z]=x%10+48,x/=10);
    	while(sr[++C]=z[Z],--Z);sr[++C]='\n';
    }
    void file()
    {
        #ifndef ONLINE_JUDGE
        freopen("a.in","r",stdin);
        #endif
    }
    inline void chktime()
    {
        #ifndef ONLINE_JUDGE
        cout<<(clock()-t)/1000.0<<'\n';
        #endif
    }
    #ifdef mod
    ll ksm(ll x,int y){ll ret=1;for (;y;y>>=1,x=x*x%mod) if (y&1) ret=ret*x%mod;return ret;}
    ll inv(ll x){return ksm(x,mod-2);}
    #else
    ll ksm(ll x,int y){ll ret=1;for (;y;y>>=1,x=x*x) if (y&1) ret=ret*x;return ret;}
    #endif
//	inline ll mul(ll a,ll b){ll d=(ll)(a*(double)b/mod+0.5);ll ret=a*b-d*mod;if (ret<0) ret+=mod;return ret;}
}
using namespace my_std;

int n;
int col[sz];
struct hh{int t,nxt;}edge[sz<<1];
int head[sz],ecnt;
void make_edge(int f,int t)
{
	edge[++ecnt]=(hh){t,head[f]};
	head[f]=ecnt;
	edge[++ecnt]=(hh){f,head[t]};
	head[t]=ecnt;
}

ll ans[sz];
bool vis[sz];
int size[sz],mn,root,sum;
#define v edge[i].t
void calcsize(int x,int fa)
{
    size[x]=1;
    go(x) 
		if (v!=fa&&!vis[v])
        	calcsize(v,x),size[x]+=size[v];
}
void findroot(int x,int fa)
{
    int S=-1;
    go(x) 
		if (v!=fa&&!vis[v])
        	findroot(v,x),chkmax(S,size[v]);
    chkmax(S,sum-size[x]);
    if (chkmin(mn,S)) root=x;
}
void findroot(int x){calcsize(x,0);mn=1e9;sum=size[x];findroot(x,0);}
int cnt[sz]; // 每种颜色出现次数
int S1; // 出现过的颜色数量 
void dfs1(int x,int u,int fa) // 统计u往下的路径 
{
	++cnt[col[x]];if (cnt[col[x]]==1) ++S1;
	ans[u]+=S1;
	go(x) if (!vis[v]&&v!=fa) dfs1(v,u,x);
	--cnt[col[x]];if (cnt[col[x]]==0) --S1;
}
ll S[sz],SS; // 每种颜色出现过的路径数，\sum_i S[i] 
void dfs2(int x,int fa) // 统计每种颜色出现过的路径数
{
	++cnt[col[x]];if (cnt[col[x]]==1) S[col[x]]+=size[x],SS+=size[x];
	go(x) if (!vis[v]&&v!=fa) dfs2(v,x);
	--cnt[col[x]];
}
void clr(int x,int fa)
{
	++cnt[col[x]];if (cnt[col[x]]==1) S[col[x]]-=size[x],SS-=size[x];
	go(x) if (!vis[v]&&v!=fa) clr(v,x);
	--cnt[col[x]];
}
ll S2; // 已经重复需要被减去的路径数 
void dfs3(int x,int fa,int Size)
{
	++cnt[col[x]];if (cnt[col[x]]==1) S2+=S[col[x]],++S1;
	ans[x]+=SS+S1*Size-S2;
	go(x) if (!vis[v]&&v!=fa) dfs3(v,x,Size);
	--cnt[col[x]];if (cnt[col[x]]==0) S2-=S[col[x]],--S1;
}
void CLR(int x,int fa)
{
	S[col[x]]=0;
	go(x) if (v!=fa&&!vis[v]) CLR(v,x);
}
void calc(int x)
{
	calcsize(x,0);
	dfs1(x,x,0);
	dfs2(x,0);
	go(x) if (!vis[v])
	{
		cnt[col[x]]=1;SS-=size[v];S[col[x]]-=size[v];clr(v,x);cnt[col[x]]=0;
		dfs3(v,x,size[x]-size[v]);
		cnt[col[x]]=1;SS+=size[v];S[col[x]]+=size[v];dfs2(v,x);cnt[col[x]]=0;
	}
	CLR(x,0);SS=0;
}
void solve(int x)
{
	vis[x]=1;
	calc(x);
	go(x) 
		if (!vis[v])
			findroot(v),solve(root);
}
#undef v

int main()
{
	file();
	read(n);
	int x,y;
	rep(i,1,n) read(col[i]);
	rep(i,1,n-1) read(x,y),make_edge(x,y);
	findroot(1);solve(root);
	rep(i,1,n) printf("%lld\n",ans[i]);
	return 0;
}
```



---

## 作者：Adove (赞：1)

这里是一个辣鸡的$\Theta(n \log^2n)$做法

首先我们套个点分治

然后问题就变成了统计跨过根的路径的贡献

先跑一遍以当前点为根的子树大小和DFS序

同时将根路径上首次出现该颜色的点存起来

然后根据颜色排序

对于不同颜色统计结果显然互不影响

那么对于同种颜色我们容斥一下就可以了

区间加法可以用DFS序上差分来代替

```cpp
#include"cstdio"
#include"cstring"
#include"iostream"
#include"algorithm"
using namespace std;

const int MAXN=1e5+5;

int n,np,rt,sum,tp;
int h[MAXN];
int siz[MAXN],mx[MAXN],sz[MAXN],id[MAXN],rid[MAXN];
int clr[MAXN],bnk[MAXN],sm[MAXN];
long long v[MAXN];
bool vis[MAXN];
long long ans[MAXN];
struct rpg{
	int li,nx;
}a[MAXN<<1];
struct pt{
	int x,c,r;
}stk[MAXN];

int read()
{
	int x=0;char ch=getchar();
	while(ch<'0'||'9'<ch) ch=getchar();
	while('0'<=ch&&ch<='9') x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return x;
}

void add(int ls,int nx)
{
	a[++np]=(rpg){h[ls],nx};h[ls]=np;
	a[++np]=(rpg){h[nx],ls};h[nx]=np;
}

void gtrt(int x,int fa)
{
	siz[x]=1;mx[x]=0;
	for(int i=h[x];i;i=a[i].li){
		if(a[i].nx==fa||vis[a[i].nx]) continue;
		gtrt(a[i].nx,x);
		siz[x]+=siz[a[i].nx];
		mx[x]=max(mx[x],siz[a[i].nx]);
	}mx[x]=max(mx[x],sum-siz[x]);
	if(mx[rt]>mx[x]) rt=x;
	return;
}

void gtsz(int x,int fa)
{
	sz[x]=1;id[x]=++id[0];rid[id[0]]=x;
	for(int i=h[x];i;i=a[i].li){
		if(a[i].nx==fa||vis[a[i].nx]) continue;
		gtsz(a[i].nx,x);
		sz[x]+=sz[a[i].nx];
	}return;
}

void dfs(int x,int fa,int rot)
{
	if(!bnk[clr[x]]) stk[++tp]=(pt){x,clr[x],rot};
	++bnk[clr[x]];
	for(int i=h[x];i;i=a[i].li){
		if(a[i].nx==fa||vis[a[i].nx]) continue;
		dfs(a[i].nx,x,rot);
	}--bnk[clr[x]];
	return;
}

bool cmp(pt a,pt b){return a.c<b.c;}

void calc(int x)
{
	id[0]=0;
	gtsz(x,x);bnk[clr[x]]=1;
   	ans[x]+=sz[x];//由根导致的起点为根的路径对根的贡献
	for(int i=h[x];i;i=a[i].li){
		if(vis[a[i].nx]) continue;
		dfs(a[i].nx,a[i].nx,a[i].nx);
		v[id[a[i].nx]]+=sz[x]-sz[a[i].nx];
		v[id[a[i].nx]+sz[a[i].nx]]-=sz[x]-sz[a[i].nx];
     		//由根导致的起点在该子树内跨过根的路径对起点的贡献
	}sort(stk+1,stk+tp+1,cmp);
	for(int l=1,r=0;l<=tp;l=r+1){
		int sum=0;
		while(r+1<=tp&&stk[r+1].c==stk[l].c) ++r,sm[stk[r].r]+=sz[stk[r].x],sum+=sz[stk[r].x];
		for(int i=l;i<=r;++i){
			v[id[stk[i].x]]-=sum-sm[stk[i].r];
			v[id[stk[i].x]+sz[stk[i].x]]+=sum-sm[stk[i].r];
			//减去跨过根的相同颜色导致多算的贡献
			v[1]+=sz[stk[i].x];
			v[id[stk[i].r]]-=sz[stk[i].x];
			v[id[stk[i].r]+sz[stk[i].r]]+=sz[stk[i].x];
			//统计终点在该子树内路径对起点的贡献
			v[id[stk[i].x]]+=sz[x]-sz[stk[i].r];
			v[id[stk[i].x]+sz[stk[i].x]]-=sz[x]-sz[stk[i].r];
        		//起点在该子树内对起点的贡献
		}for(int i=l;i<=r;++i) sm[stk[i].r]=0;
	}
	for(int i=1;i<=id[0];++i) v[i]+=v[i-1],ans[rid[i]]+=v[i];
	for(int i=1;i<=id[0]+1;++i) v[i]=0;
	bnk[clr[x]]=tp=0;
	return;
}

void DFZ(int x)
{
	vis[x]=1;calc(x);
	for(int i=h[x];i;i=a[i].li){
		if(vis[a[i].nx]) continue;
		sum=siz[a[i].nx];rt=0;
		gtrt(a[i].nx,a[i].nx);
		DFZ(rt);
	}return;
}

int main()
{
	n=read();
	for(int i=1;i<=n;++i) clr[i]=read();
	for(int i=1;i<n;++i){
		int x=read(),y=read();
		add(x,y);
	}sum=n;mx[rt]=n;
	gtrt(1,1);
	DFZ(rt);
	for(int i=1;i<=n;++i) printf("%lld\n",ans[i]);
	return 0;
}
```

---

## 作者：no_one_cm_Fe_in_hand (赞：1)

## 题意：对于每个点求从改点出发的所有简单路径的颜色数和
由于是点分标签点进来的，就没有考虑其他做法。。(然而发现有O（n）神仙)
考虑点分治特点：可以在O（nlogn）时间内“枚举”所有路径。
但是需要能够O（子树大小）得处理当前选取根的其他子树对一个子树的贡献。
考虑分开颜色处理贡献
比如在样例中模拟第一次选取1为根进行处理。要求以非5为小根的子树对以5为小根的子树各点(样例中只有5)sum的贡献。
我们分类讨论
一.对于根节点的颜色，每条以5为起点，非5为小根的子树的结点为终点的路径的贡献为sz[1]-sz[5]。
二.对于小根5到当前处理点中未出现的颜色贡献为所有非5为小根的子树路径中首次出现该颜色结点的sz和(这个可以预处理)
三.对于小根5到当前处理点中出现过的颜色，贡献为sz[大rt]-sz[小rt]-所有非5为小根的子树路径中首次出现该颜色结点的sz和。
就ok了。
然而代码很烦，细节很多。
蒟蒻的代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
#define N 100005
#define ll long long
bool vis[N];
int head[N],nex[N<<1],ver[N<<1],tot,rt,sum;
int maxp[N];
inline void add(int x,int y){
	nex[++tot]=head[x];head[x]=tot;ver[tot]=y;
}
int sz[N];
inline void getrt(int x,int fa){
	sz[x]=1;maxp[x]=0;
	for(int i=head[x];i;i=nex[i]){
		int y=ver[i];
		if(y==fa||vis[y]) continue;
		getrt(y,x);sz[x]+=sz[y];maxp[x]=max(maxp[x],sz[y]);
	}
	maxp[x]=max(maxp[x],sum-sz[x]);
	if(maxp[rt]>maxp[x]) rt=x;
}
ll col[N];
bool jd[N],tt[N];
ll ans;
ll t[N],ssum[N];
queue<int> q1,q2;
inline void dfs(int x,int fa){
	for(int i=head[x];i;i=nex[i]){
		int y=ver[i];if(vis[y]||y==fa) continue;
		bool fg=0;
		if(!tt[col[y]]) ans+=sz[y],t[col[y]]+=sz[y],fg=1,tt[col[y]]=1,q1.push(col[y]);
		dfs(y,x);
		if(fg) tt[col[y]]=0;
	}
}
inline void dfs_1(int x,int fa,int num,ll aans){
	ssum[x]+=aans;
	for(int i=head[x];i;i=nex[i]){
		int y=ver[i];if(vis[y]||y==fa) continue;
		bool fg=0;
		if(!jd[col[y]])jd[col[y]]=fg=1, dfs_1(y,x,num,aans+num-t[col[y]]);
		else dfs_1(y,x,num,aans);
		if(fg) jd[col[y]]=0;
	}
}
ll aans;
inline void dfs_2(int x,int fa){
	for(int i=head[x];i;i=nex[i]){
		int y=ver[i];if(vis[y]||y==fa) continue;
		bool fg=0;
		if(!tt[col[y]]) jd[col[y]]=0,aans-=sz[y],t[col[y]]-=sz[y],fg=1,tt[col[y]]=1,q1.push(y);
		dfs_2(y,x);
		if(fg) tt[col[y]]=0;
	}
}
inline void calc(int x){
	ans=sz[x];t[col[x]]=sz[x];jd[col[x]]=tt[col[x]]=1;
	for(int i=head[x];i;i=nex[i]){
		int y=ver[i];if(vis[y]) continue;
		bool fg=0;
		if(!tt[col[y]]) ans+=sz[y],t[col[y]]+=sz[y],fg=1,tt[col[y]]=1,q1.push(col[y]);
		dfs(y,x);
		if(fg) tt[col[y]]=0;
		while(!q1.empty()) q2.push(q1.front()),q1.pop();
	}
	ssum[x]+=ans;
	for(int i=head[x];i;i=nex[i]){
		int y=ver[i];if(vis[y]) continue;
		aans=ans-sz[y];
		bool fg=0;
		if(!tt[col[y]]) jd[col[y]]=0,aans-=sz[y],t[col[y]]-=sz[y],fg=1,tt[col[y]]=1,q1.push(y);
		dfs_2(y,x);
		if(fg) tt[col[y]]=0;
		fg=0;
		if(!jd[col[y]])jd[col[y]]=fg=1,aans=aans+sz[x]-sz[y]-t[col[y]];
		dfs_1(y,x,sz[x]-sz[y],aans);
		if(fg) jd[col[y]]=0;
		while(!q1.empty()) t[col[q1.front()]]+=sz[q1.front()],tt[col[q1.front()]]=0,q1.pop();
	}
	while(!q2.empty()) t[q2.front()]=0,q2.pop();t[col[x]]=tt[col[x]]=jd[col[x]]=0;
}
inline void gsz(int x,int fa){
	sz[x]=1;
	for(int i=head[x];i;i=nex[i]){
		int y=ver[i];
		if(vis[y]||y==fa) continue;gsz(y,x);sz[x]+=sz[y];
	}
}
inline void solve(int x){
	vis[x]=1;gsz(x,x);calc(x);
	for(int i=head[x];i;i=nex[i]){
		int y=ver[i];if(vis[y]) continue;
		sum=sz[y];maxp[rt=0]=n;
		getrt(y,0);solve(rt);
	}
}
signed main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i) scanf("%d",&col[i]);
	for(int i=1;i<n;++i){
		int x,y;scanf("%d%d",&x,&y);
		add(x,y);add(y,x);
	}
	maxp[0]=sum=n;
	getrt(1,0);
	solve(rt);
	for(int i=1;i<=n;++i) cout<<ssum[i]<<endl;
}
```cpp

---

## 作者：y2823774827y (赞：1)

刚学完点分治，"点分治真好玩"，$dalao$瞬间把这题丢过来，肛了三个小时终于$A$了

$$ans_i=\sum\limits_{j=1}^n sum(i,j)$$

其实就是一眼题系列，就是细节难处理

模板题告诉我们：要把其他子树都堆到一起进行计算，这题相对来说并不好处理

但其实是具有单调性的，设树的重心为$w$，一对父子关系的点对$(u,v)$，$v$是包含$u$的

更新：将重心看作一个无色节点，遍历其中一棵子树，能得到子树总贡献及每种颜色的贡献

统计答案：点对$(u,v)$，$v$统计在其他子树的贡献一定比$u$小，之前已得出其他子树每种颜色的贡献，减掉就好了

细节：
1. 统计重心贡献
1. 统计每种颜色贡献的标记记得弹出子树后清空
1. 实际菊花图能卡爆空间，可以用$map$处理数组，由于本题数据过水开子树序列$100$就能过了

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
inline LL Read(){
    LL x(0),f(1); char c=getchar();
    while(c<'0' || c>'9'){ if(c=='-')f=-1; c=getchar(); }
    while(c>='0' && c<='9') x=(x<<3)+(x<<1)+c-'0',c=getchar();
    return x*f;
}
const LL maxn=1e5+9,inf=0x3f3f3f3f;
struct node{
    LL to,nxt;
}dis[maxn<<1];
void Clear(LL u,LL now);
LL num,root,N,mi,tmp,n,tree,nsize;
LL head[maxn],size[maxn],a[maxn],cnt[100][maxn],ans[maxn],fir[maxn],V[maxn],sz[100],nsum[100],st[maxn];
bool visit[maxn];
inline void Add(LL u,LL v){
    dis[++num]=(node){v,head[u]}, head[u]=num;
}
void Dfs(LL u){
    size[u]=1; LL mx(0); visit[u]=true;
    for(LL i=head[u];i;i=dis[i].nxt){
        LL v(dis[i].to);
        if(visit[v]) continue;
        Dfs(v), size[u]+=size[v];
        mx=max(mx,size[v]);
    }mx=max(mx,N-size[u]);
    if(mi>mx) mi=mx,root=u;
    visit[u]=false;
}
void Up(LL u,LL now){
    ++sz[0], ++sz[now];
    visit[u]=true;
    bool f(false);
    if(!fir[a[u]]) 
        fir[a[u]]=f=true,
        cnt[0][a[u]]+=size[u],cnt[now][a[u]]+=size[u],
        nsum[0]+=size[u],nsum[now]+=size[u];
    for(LL i=head[u];i;i=dis[i].nxt){
        LL v(dis[i].to);
        if(visit[v]) continue;
        Up(v,now);
    }visit[u]=false;
    if(f) fir[a[u]]=false;
}
void Get(LL u,LL now){
    bool f(false);
    if(!fir[a[u]])
        fir[a[u]]=f=true,tmp=tmp-cnt[0][a[u]]+cnt[now][a[u]],++tree;
    ans[root]+=tree;
    ans[u]+=tmp+tree*nsize; visit[u]=true;
    for(LL i=head[u];i;i=dis[i].nxt){
        LL v(dis[i].to);
        if(visit[v]) continue;
        Get(v,now);
    }visit[u]=false;
    if(f) --tree,fir[a[u]]=false,tmp=tmp+cnt[0][a[u]]-cnt[now][a[u]];
}
void Div(LL u){
    mi=inf, Dfs(u);
    Dfs(root);
    visit[u=root]=true;
    memset(nsum,0,sizeof(nsum));
    nsize=1;
    LL now(0);
    for(LL i=head[u];i;i=dis[i].nxt){
        LL v(dis[i].to);
        if(visit[v]) continue;
        ++now;
        Up(v,now);
    }now=0;
    for(LL i=head[u],S=nsize;i;i=dis[i].nxt){
        LL v(dis[i].to); 
        if(visit[v]) continue;
        ++now;
        nsize=sz[0]-sz[now]+1;
        tmp=nsum[0]-nsum[now];
        fir[a[u]]=true, tree=1;
        tmp=tmp-cnt[0][a[u]]+cnt[now][a[u]];
        Get(v,now);
        fir[a[u]]=false;
    }
    now=0;
    for(LL i=head[u];i;i=dis[i].nxt){
        LL v(dis[i].to); if(visit[v]) continue;
        ++now;
        Clear(v,now);
    }
    
    for(LL i=head[u],sum=N;i;i=dis[i].nxt){
        LL v(dis[i].to);
        if(visit[v]) continue;
        N=size[v];
        Div(v);
    }
}
void Clear(LL u,LL now){
    visit[u]=true;
    cnt[0][a[u]]=cnt[now][a[u]]=0;
    sz[0]=sz[now]=0;
    nsum[0]=nsum[now]=0;
    for(LL i=head[u];i;i=dis[i].nxt){
        LL v(dis[i].to);
        if(visit[v]) continue;
        Clear(v,now);
    }visit[u]=false;
}
int main(){
    n=Read();
    for(LL i=1;i<=n;++i) a[i]=Read();
    for(LL i=1;i<n;++i){
        LL u(Read()),v(Read());
        Add(u,v), Add(v,u);
    }
    N=n, Div(1);
    for(LL i=1;i<=n;++i) printf("%lld\n",ans[i]+1);
    return 0;
}
```

---

## 作者：mohei0 (赞：0)

# 树上游戏

## 题意

有一棵树，树的每个节点有个颜色。定义 $s(i,j)$ 为 $i$ 到 $j$ 的颜色数量， $sum_i=\sum_{j=1}^ns(i,j)$

求所有的 $sum_i$

## 分析

好像挺水的

看到树上路径问题，考虑点分治

当 $j$ 在点分树子树中时

直接遍历统计即可

当 $j$ 在点分树子树外时

模仿其他题将先前路径用树状数组统计起来的方法

我们可以考虑将先前路径统计起来

但这些路径不好合并

---

考虑贡献法

当我们遍历到一个 $now$ 时

我们先把不在子树内的其他节点 $others$ 到重心的 $s(others,\text{重心})$ 之和求出，记为 $sum$

然后考虑重心到 $now$ 贡献了多少 $s$ 值

---

考虑有多少条从当前重心出发到子树内的路径有颜色 $x$ ，记为数组 $A[x]$

这个可以在遍历中容易得出

因为要走简单路径，所以记录下重心到每个孩子子树的路径条数，记为数组 $B[x]$

遍历三次，第一次求 $A$ ，第二次求 $B$ ，第三次统计答案

因为重心每个孩子都要一个 $B$ ，所以我们算一个孩子的 $B$ 就统计这个孩子子树内的答案

### 求 $A$

当从重心遍历到一个点 $now$ 时

若当前点的颜色在重心到此点的路径中出现过，不处理

当没出现过， $A[col[now]]+=siz[now]$ ，因为重心到当前节点子树的所有路径都有这个颜色

### 求 $B$

相当于在子树内求 $A$ ，不说了

### 统计答案

递归时设临时变量 $k$ ，初始为 $0$

当从重心遍历到一个点 $now$ 时

若当前点的颜色在重心到此点的路径中出现过，不处理 $k$

当没出现过

$(A[col[now]]-B[col[now]])$ 是有含颜色 $col[now]$ 的路径个数

所以这个颜色对于原树中 $now$ 的子树的贡献是 $siz[\text{重心}]-(A[col[now]]-B[col[now]])$ 

所以 $k+=siz[\text{重心}]-(A[col[now]]-B[col[now]])$

统计答案 $ans[now]+=k+sum$

---

到这里就结束了，效率 $O(n\log n)$

## 代码

```cpp
#pragma GCC optimize(3,"Ofast","inline")

#include<bits/stdc++.h>

using namespace std;

typedef long long ll;

const int MAXN=2e5+7;

int n,m;
ll ans[MAXN];

int col[MAXN];
struct side {
	int nex,to,val;
	side(){nex=0;}
}edge[MAXN<<1];
int scnt=0;
int head[MAXN]={0};
inline void link(int A,int B) {
	edge[++scnt].to=B;
	edge[scnt].nex=head[A];
	head[A]=scnt;
}

bool arr[MAXN]={0};
ll carr[MAXN],cs=0,col_cov[MAXN],col_cov2[MAXN];
int siz[MAXN],root_,n2,minn=1e9;
void getn2(int now,int fa) {
	n2++;
	siz[now]=0;
	for(int i=head[now];i;i=edge[i].nex)
        if(!arr[edge[i].to]&&fa!=edge[i].to)
            getn2(edge[i].to,now);
}
void getr(int now,int fa) {
    siz[now]=1;
    int ms=0;
    for(int i=head[now];i;i=edge[i].nex)
        if(!arr[edge[i].to]&&fa!=edge[i].to) {
            getr(edge[i].to,now);
            siz[now]+=siz[edge[i].to];
            ms=max(ms,siz[edge[i].to]);
            siz[edge[i].to]=0;
        }
    ms=max(ms,n2-siz[now]);
    if(minn>ms) {
        minn=ms;
        root_=now;
    }
}
int dis[MAXN],FA[MAXN]={0};
void getsiz(int now) {
	siz[now]=1;
    for(int i=head[now];i;i=edge[i].nex)
        if(!arr[edge[i].to]&&edge[i].to!=FA[now]) {
			FA[edge[i].to]=now;
            getsiz(edge[i].to);
            siz[now]+=siz[edge[i].to];
        }
}
void getd(int now,ll &S) {
    if(carr[col[now]]==0) cs++;
    carr[col[now]]++;
    S+=cs;
    for(int i=head[now];i;i=edge[i].nex)
        if(!arr[edge[i].to]&&edge[i].to!=FA[now])
			getd(edge[i].to,S);
	carr[col[now]]--;
    if(carr[col[now]]==0) {
    	cs--;
    	col_cov[col[now]]+=siz[now];
    }
}
void getd2(int now)
{
    carr[col[now]]++;
    for(int i=head[now];i;i=edge[i].nex)
        if(!arr[edge[i].to]&&edge[i].to!=FA[now])
            getd2(edge[i].to);
    carr[col[now]]--;
    if(carr[col[now]]==0) {
    	col_cov2[col[now]]+=siz[now];
    }
}
void del(int now)
{
	col_cov2[col[now]]=0;
    for(int i=head[now];i;i=edge[i].nex)
        if(!arr[edge[i].to]&&FA[now]!=edge[i].to)
            del(edge[i].to);
}
void del2(int now)
{
	carr[col[now]]=col_cov[col[now]]=col_cov2[col[now]]=0;
    for(int i=head[now];i;i=edge[i].nex)
        if(!arr[edge[i].to]&&FA[now]!=edge[i].to)
            del2(edge[i].to);
    FA[now]=0;
}
void getans(int now,int siz_root,int SUM) {
	if(carr[col[now]]==0) {
		SUM+=siz_root-(col_cov[col[now]]-col_cov2[col[now]]);
	}
	ans[now]+=SUM;
	carr[col[now]]++;
	for(int i=head[now];i;i=edge[i].nex)
        if(!arr[edge[i].to]&&FA[now]!=edge[i].to)
            getans(edge[i].to,siz_root,SUM);
    carr[col[now]]--;
    if(carr[col[now]]==0) {
		SUM-=siz_root-(col_cov[col[now]]-col_cov2[col[now]]);
	}
}
void di(int now) {
	getn2(now,0);
    minn=1e9;
    getr(now,0);
    now=root_;
    getsiz(now);
    arr[now]=1;
    vector<ll> V;
    ll Sum=1;
    carr[col[now]]=1;cs=1;
    col_cov[col[now]]=siz[now];
    for(int i=head[now];i;i=edge[i].nex)
        if(!arr[edge[i].to]) {
        	ll i2=0;
			FA[edge[i].to]=now;
	        getd(edge[i].to,i2);
	        Sum+=i2;
	        V.push_back(i2);
        }
    ans[now]+=Sum;
    for(int i=head[now],i2=0;i;i=edge[i].nex)
    	if(!arr[edge[i].to]) {
    		carr[col[now]]=1;
    		getd2(edge[i].to);
    		getans(edge[i].to,siz[now]-siz[edge[i].to],Sum-V[i2]);
    		del(edge[i].to);
    		i2++;
    	}
    cs=0;del2(now);
    for(int i=head[now],i2;i;i=edge[i].nex)
        if(!arr[edge[i].to]) {
			n2=0;
            di(edge[i].to);
            i2++;
        }
}

inline int read() {
	int A=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')
		ch=getchar();
	while(ch>='0'&&ch<='9') {
		A=A*10+ch-'0';
		ch=getchar();
	}
	return A; 
}

int main() {
    n=read();
    for(int i=1,i2;i<=n;i++) {
    	i2=read();
    	col[i]=i2;
    }
    for(int i=1,i2,i3;i<n;i++) {
        i2=read();i3=read();
        link(i2,i3);
        link(i3,i2);
    }
    
    di(1);
    
    for(int i=1;i<=n;i++) cout<<ans[i]<<endl;

    return 0;
}
```

---

## 作者：qwaszx (赞：0)

感觉很神

点分治，然后只需要考虑过一个点的所有链

直接做不好做，考虑对每种颜色分开算贡献.

重心$root$把树分成许多子树，对于一个点$u$，它对一个$lca(u,v)=root$的异色点$v$会造成$size[u]$的贡献.这样我们统计出每种颜色的贡献$s$以及所有颜色的贡献之和$sum$.

考虑一棵子树$S$，我们先消除它的贡献，然后这棵子树内的一个点$u$的答案就是

$sum-\text{u到S的根的链上所有颜色的s之和}+\text{u到S的根的链上的颜色数}$

但这样还是有问题，没有考虑根节点的颜色的影响，所以我们再处理出不存在和$root$相同颜色的点且包含$root$的极大子树的大小$siz$，然后如果$u$到$S$的根的链上没有出现过$color[root]$那就再加上$siz$

最后是$root$本身的答案 这个就是$sum-s[color[root]]+size[root]$了

代码还是挺丑的emmm常数巨大

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
const int N=5e5,INF=1e9;
int size[N],s[N],vis[N],to[N],cnt[N],c[N],mm,fst[N],nxt[N],root,n,nn,mx,siz;
long long sum,ans[N];
void ade(int u,int v)
{
    to[++mm]=v,nxt[mm]=fst[u],fst[u]=mm;
}
void findroot(int u,int fa)
{
    int mxson=0;
    for(int i=fst[u];i;i=nxt[i])
    {
        int v=to[i];if(v==fa||vis[v])continue;
        findroot(v,u);mxson=max(mxson,size[v]);
    }
    mxson=max(mxson,nn-size[u]);
    if(mxson<mx)mx=mxson,root=u;
}
void getsize(int u,int fa)
{
    size[u]=1;
    for(int i=fst[u];i;i=nxt[i])
    {
        int v=to[i];if(v==fa||vis[v])continue;
        getsize(v,u),size[u]+=size[v];
    }
}
void calc(int u,int fa,int f)
{
    if(++cnt[c[u]]==1)
        s[c[u]]+=f*size[u],sum+=f*size[u];
    if(!cnt[c[root]])siz+=f;
    for(int i=fst[u];i;i=nxt[i])
    {
        int v=to[i];if(v==fa||vis[v])continue;
        calc(v,u,f);
    }
    --cnt[c[u]];
}
void calcans(int u,int fa,int num,long long pres)
{
    if(++cnt[c[u]]==1)++num,pres+=s[c[u]];ans[u]+=sum-pres+num*mx;if(!cnt[c[root]])ans[u]+=siz;
    for(int i=fst[u];i;i=nxt[i])
    {
        int v=to[i];if(v==fa||vis[v])continue;
        calcans(v,u,num,pres);
    }
    --cnt[c[u]];
}
void solve(int u)
{
    vis[u]=1;getsize(u,0);siz=1;
    for(int i=fst[u];i;i=nxt[i])
    {
        int v=to[i];if(vis[v])continue;
        calc(v,0,1);
    }
    for(int i=fst[u];i;i=nxt[i])
    {
        int v=to[i];if(vis[v])continue;
        calc(v,0,-1);mx=size[u]-size[v];calcans(v,0,0,0);calc(v,0,1);
    }
    ans[u]+=sum-s[c[u]]+size[u];
    for(int i=fst[u];i;i=nxt[i])
    {
        int v=to[i];if(vis[v])continue;
        calc(v,0,-1);
    }
    for(int i=fst[u];i;i=nxt[i])
    {
        int v=to[i];if(vis[v])continue;
        nn=size[v],sum=0,mx=INF,findroot(v,0),solve(root);
    }
}
void fILe()
{
    freopen("in.txt","r",stdin);
    freopen("out.txt","w",stdout);
}
int main()
{
  //  fILe();
    scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%d",c+i);
    for(int i=1,u,v;i<n;i++)scanf("%d%d",&u,&v),ade(u,v),ade(v,u);
    nn=n,mx=INF,getsize(1,0),findroot(1,0),solve(root);
    for(int i=1;i<=n;i++)printf("%lld\n",ans[i]);
}
```

---

## 作者：LebronDurant (赞：0)

点分治

看到树上点对路径之类的基本就是点分治。考虑计算每个颜色的贡献。对于每一棵小树里的每个点，我分成两种颜色进行计算。

第一种是这个点到根的路径上没有这种颜色的。这种可以dfs处理出来每棵直接子树里颜色最先出现的位置的子树大小加到贡献里，画画图很容易看出来。

第二种是路径上有这种颜色。这种情况可以由这个点延伸到这棵小树里其他子树里的任意一个点。所以答案就是小树的size减去这棵子树的size。

细节的话，相当多。首先就是计算每个子树贡献的时候清空当前子树贡献。一开始只需要清空每个点对于coas的贡献。之后每新遇到一个颜色就把这个颜色在此子树中的贡献加回来，然后tmpans-=coas[a[x]]就好了。因为再往下走的时候可以延伸到所有其他子树的节点，所以tmpans可以减掉这个颜色的贡献，然后tps++。计算完贡献要把每个颜色的贡献加回来。

我把我的代码里每个数组/变量的意义列出来。

siz[te] te这个点子树大小

rt 当前小树的根

col没用上

cl[x] x这个颜色在当前点到根的路径上出现了几次

rem[ii] 存放当前子树里所有的点，便于清空。

rz rem数组的顶指针

tps 求每一个点答案的时候当前点到根的路径上有多少种颜色

b 存放当前小树里所有的点，便于清空。

z b数组的顶指针

rttot 单独计算根的答案时当前点到根的路径上由多少种颜色

totans 每个子树每个颜色第一次出现的位置的子树大小之和

val[x] x点对totans的贡献

coas[x] x颜色的贡献

tmpans 计算答案时临时totans减去当前子树的贡献

thcs[x] 当前子树x颜色的贡献

ans[x] x点的最终答案



```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
typedef long long ll;
#define N 100002
struct edge
{
    int to,nxxt;
}e[N<<1];
int head[N],cnt=1;
int n,a[N];
int siz[N],msz[N],sum,rt;
bool vis[N],col[N];
int cl[N];
int rem[N],rz,tps,b[N],z,rttot;
ll totans,val[N],coas[N],tmpans,thcs[N];
ll ans[N];
void getrt(int te,int la)
{
    siz[te]=1;
    msz[te]=0;
    cl[a[te]]=0;
    for(int i=head[te];i;i=e[i].nxxt)
    {
        int j=e[i].to;
        if(j==la||vis[j])continue;
        getrt(j,te);
        siz[te]+=siz[j];
        msz[te]=max(msz[te],siz[j]);
    }
    msz[te]=max(msz[te],sum-siz[te]);
    if(msz[te]<msz[rt])rt=te;
}
inline void ins(int u,int v)
{
    e[cnt].to=v;
    e[cnt].nxxt=head[u];
    head[u]=cnt++;
}
void dfs(int te,int la)
{
    rem[++rz]=te;
    cl[a[te]]++;
//	if(rt==3)printf("%d %d\n",te,cl[a[te]]);
    if(cl[a[te]]==1)
    {
        totans+=siz[te];
        coas[a[te]]+=siz[te];
        val[te]=siz[te];
    }
    for(int i=head[te];i;i=e[i].nxxt)
    {
        int j=e[i].to;
        if(vis[j]||j==la)continue;
        dfs(j,te);
    }
    cl[a[te]]--;
}
void df5(int te,int la,int trt)
{
    rem[++rz]=te;
    cl[a[te]]++; 
    if(cl[a[te]]==1)
    {
        tps++;
        tmpans=tmpans+thcs[a[te]]-coas[a[te]];
    }
    //printf("%d %d %d %d %d %lld cal\n",rt,te,tps,siz[rt],siz[trt],tmpans);
    ans[te]+=1ll*tps*(siz[rt]-siz[trt]);
    ans[te]+=1ll*tmpans;
    for(int i=head[te];i;i=e[i].nxxt)
    {
        int j=e[i].to;
        if(j==la||vis[j])continue;
        df5(j,te,trt);
    }
    cl[a[te]]--;
    if(cl[a[te]]==0)
    {
        tps--;
        tmpans=tmpans-thcs[a[te]]+coas[a[te]];
    }
}
void getsiz(int te,int la)
{
    siz[te]=1;
    for(int i=head[te];i;i=e[i].nxxt)
    {
        int j=e[i].to;
        if(vis[j]||j==la)continue;
        getsiz(j,te);
        siz[te]+=siz[j];
    }
}
void getrtans(int te,int wh,int la)
{
    for(int i=head[te];i;i=e[i].nxxt)
    {
        int j=e[i].to;
        if(j==la||vis[j])continue;
        cl[a[j]]++;
        if(cl[a[j]]==1)
        {
            rttot++;
        }
        ans[wh]+=rttot;
        getrtans(j,wh,te);
        cl[a[j]]--;
        if(!cl[a[j]])rttot--;
    }
}
void clecol(int te,int la)
{
    totans-=val[te];
    thcs[a[te]]+=val[te];
    rem[++rz]=te;
    for(int i=head[te];i;i=e[i].nxxt)
    {
        int j=e[i].to;
        if(vis[j]||j==la)continue;
        clecol(j,te);
    }
}
void adcol(int te,int la)
{
    totans+=val[te];
    for(int i=head[te];i;i=e[i].nxxt)
    {
        int j=e[i].to;
        if(vis[j]||j==la)continue;
        adcol(j,te);
    }
}
void calc(int te)
{
    rt=te;
    getsiz(te,te);
    totans=0;
    for(int i=head[te];i;i=e[i].nxxt)
    {
        int j=e[i].to;
        if(vis[j])continue;
        for(int ii=1;ii<=rz;ii++)cl[a[rem[ii]]]=0;
        rz=0;
        rem[++rz]=te;
        cl[a[te]]=1;
//		if(rt==3)printf("%d %d %d\n",j,cl[a[1]],cl[a[3]]);
//		printf("%lld totans\n",totans);
        dfs(j,te);
        for(int ii=1;ii<=rz;ii++)cl[a[rem[ii]]]=0; 
    }
    z=0;
    for(int i=head[te];i;i=e[i].nxxt)
    {
        int j=e[i].to;
        if(vis[j])continue;
        rz=0;
        rem[++rz]=te;
        cl[a[te]]=1;
        clecol(j,te);
        for(int ii=1;ii<=rz;ii++)cl[a[rem[ii]]]=0;
        rz=0;
        tmpans=totans;
        tmpans-=coas[a[te]];
        tps=1;
        cl[a[te]]=1;
        rt=te;
//		printf("%lld totans\n",totans);
        df5(j,te,j);
        for(int ii=1;ii<=rz;ii++)cl[a[rem[ii]]]=0;
        cl[a[te]]=1;
        adcol(j,te);
        for(int ii=1;ii<=rz;ii++)cl[a[rem[ii]]]=0,thcs[a[rem[ii]]]=0;
        for(int ii=1;ii<=rz;ii++)cl[a[rem[ii]]]=0,b[++z]=rem[ii];
        rz=0;
    }
    for(int i=1;i<=z;i++)coas[a[b[i]]]=0,cl[a[b[i]]]=0,val[b[i]]=0;
    rttot=1;
    cl[a[te]]=1;
    ans[te]++;
    getrtans(te,te,te);
    //printf("%d rt\n",rt);
    //for(int i=1;i<=n;i++)printf("%lld ",ans[i]);puts("");
}
void solve(int te)
{
    vis[te]=1;calc(te);
    for(int i=head[te];i;i=e[i].nxxt)
    {
        int j=e[i].to;
        if(vis[j])continue;
        rt=0;msz[rt]=n;sum=siz[j];
        getrt(j,te);
        solve(rt);
    }
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%d",&a[i]);
    for(int i=1;i<n;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        ins(x,y);
        ins(y,x);
    }
    msz[rt]=sum=n;
    getrt(1,1);
    solve(rt);
    for(int i=1;i<=n;i++)printf("%lld\n",ans[i]);
}

```


---


# 快递员

## 题目描述

Bob 的城市里有 $n$ 个邮递站，由于经济考虑，这些邮递站被 $n - 1$ 条带权无向边相连。即：这 $n$ 个邮递站构成了一棵树。

Bob 正在应聘一个快递员的工作，他需要送 $m$ 个商品，第 $i$ 个商品需要从 $u$ 送到 $v$。由于 Bob 不能带着商品走太长的路，所以对于一次送货，他需要先从快递中心到 $u$，再从 $u$ 回到快递中心，再从快递中心到 $v$，最后从 $v$ 返回快递中心。换句话说，如果设快递中心是 $c$ 号点，那么他的路径是 $c \rightarrow u \rightarrow c \rightarrow v \rightarrow c$。

现在 Bob 希望确定一个点作为快递中心，使得他送货所需的最长距离最小。显然，这个最长距离是个偶数，你只需要输出最长距离除以 $2$ 的结果即可。

## 说明/提示

对于 $25\%$ 的数据，满足 $1 \leq n, m \leq 1000$。

对于 $100\%$ 的数据，满足 $1 \leq n, m \leq 10^5, 1 \leq w_i \leq 1000$。

## 样例 #1

### 输入

```
3 1
1 2 1
2 3 1
1 3
```

### 输出

```
2```

# 题解

## 作者：徐致远 (赞：23)


完了...没高中读了QwQ，我要去打工送快递！！！QwQ


### 题解

这题其实还是挺好玩的。

首先随便钦定一个点，临时作为快递中心 。

然后可以$O(n)$计算出每一组点对到快递中心的距离和。设点对到快递中心最大距离和为$Max$，可能有多个点对到快递中心的距离和都是$Max$那么就把它们都存下来。

如果当前的快递中心在任意一组距离最大的点对之间最短路径上，那么答案就是$Max$不可能再小了。

如果有任意两组距离最大的点对，一组在当前快递中心的一棵子树里，另一组在另一棵子树里，那么答案同样也无法更小。

否则答案最优时的快递中心就有可能在当前唯一一棵有点对的子树中，那么就取这棵子树的重心作为临时快递中心，然后递归。由于每次取的都是重心，所以只会递归$\log n$层，总时间复杂度为$O(n\log n)$。

### 代码

```cpp
#include<cstdio>
#include<cstdlib>
using namespace std;
const int maxn=100005;
int n,m,u[maxn],v[maxn],tot,lnk[maxn],son[maxn*2],w[maxn*2],nxt[maxn*2],sum,siz[maxn],maxp[maxn],rt,sub[maxn],dist[maxn],que[maxn],ans=1000000000;bool vis[maxn];
inline int read()
{
	int ret=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9'){ret=ret*10+ch-'0';ch=getchar();}
	return ret*f;
}
inline void add_e(int x,int y,int z){tot++;son[tot]=y;w[tot]=z;nxt[tot]=lnk[x];lnk[x]=tot;}
void GetRoot(int now,int fa)     //找重心
{
	siz[now]=1;maxp[now]=0;
	for(int i=lnk[now];i;i=nxt[i])
	{
		if(vis[son[i]]||son[i]==fa) continue;
		GetRoot(son[i],now);siz[now]+=siz[son[i]];
		if(siz[son[i]]>maxp[now]) maxp[now]=siz[son[i]];
	}
	if(sum-siz[now]>maxp[now]) maxp[now]=sum-siz[now];
	if(maxp[now]<maxp[rt]) rt=now;
}
void GetDist(int now,int fa,int st)
{
	sub[now]=st;
	for(int i=lnk[now];i;i=nxt[i])
		if(son[i]!=fa)
			{dist[son[i]]=dist[now]+w[i];GetDist(son[i],now,st);}
}
inline void Print(){printf("%d\n",ans);exit(0);}   //输出答案
void Solve(int now)
{
	if(vis[now]) Print();
	vis[now]=true;dist[now]=0;
	for(int i=lnk[now];i;i=nxt[i])
		{dist[son[i]]=w[i];GetDist(son[i],now,son[i]);} //先暴力计算距离
	int Max=0,len=0,las=0;
	for(int i=1;i<=m;i++)
	{
		if(dist[u[i]]+dist[v[i]]>Max){len=1;que[len]=i;Max=dist[u[i]]+dist[v[i]];}
		else if(dist[u[i]]+dist[v[i]]==Max) que[++len]=i; //刷最大距离和
	}
	if(Max<ans) ans=Max;
	for(int i=1;i<=len;i++)
	{
		if(sub[u[que[i]]]!=sub[v[que[i]]]) Print();   //分情况考虑答案
		if(!las) las=sub[u[que[i]]];
		if(sub[u[que[i]]]!=las) Print(); 
	}
	rt=0;sum=siz[las];GetRoot(las,0);Solve(rt);    //递归解决
}
int main()
{
	n=read();m=read();
	for(int i=1;i<n;i++)
	{
		int a=read(),b=read(),c=read();
		add_e(a,b,c);add_e(b,a,c);
	}
	for(int i=1;i<=m;i++){u[i]=read();v[i]=read();}
	sum=maxp[0]=n;GetRoot(1,0);Solve(rt);
	Print();
	return 0;
}
```



---

## 作者：Huami360 (赞：9)

~~第一杯羹~~

[博客](https://www.cnblogs.com/Qihoo360/p/9675522.html)

这题因为一些小细节还是$debug$了很久。。。~~不过我第一次用脚本对拍，不亏。~~

先随便找一个点作为根，算出答案，即所有点对到这个点的距离和的最大值，并记录**所有**距离最大的点对。如果这个点在任意一个距离最大的点对之间的路径上，那么答案显然不能再优了，因为这个点对的答案是不能减小了的。如果有两个距离最大的点对不在根的同一子树中，答案也是显然不能再优了的，因为一个点对答案减小的同时，另一个会增大。只有当所有距离最大的点对在根的同一子树中，这时更优答案**可能**在这个子树里，向这个子树递归处理就行了。为什么说**可能**？因为往这个子树走的同时可能会存在在另一个子树中原本不是距离最大的点对变为距离最大的点对，所以我们要一直对答案取最小值。直接走最多会走$n$次，而如果我们每次都走子树的重心，最多走$logN$次，所以总时间复杂度$O(m\log n)$。

现在讲讲具体怎么实现，主要就难在怎么判断根在不在两个点之间的路径上。求$LCA$是最简单粗暴的方法，但时间复杂度要多一个$log$，其实类似于点分治里的统计，只需要看这个点对的两个点在不在同一子树里就行了，若在，则路径不经过根，反之亦然。

然后，看$Code$吧。

```cpp
#include <iostream>
#include <cstdio>
#define INF 2147483647
using namespace std;
inline int read(){
	int s = 0, w = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9') { if(ch == '-') w = -1; ch = getchar(); }
	while(ch >= '0' && ch <= '9') { s = s * 10 + ch - '0'; ch = getchar(); }
	return s * w;
}
const int MAXN = 100010;
struct Edge{
	int next, to, dis;
}e[MAXN << 1];
int head[MAXN], num, x[MAXN], y[MAXN], vis[MAXN], maxson[MAXN], p[MAXN], q[MAXN], belong[MAXN], deep[MAXN], size[MAXN];
int n, m, root, Max, ans = 2147483647;
inline void Add(int from, int to, int dis){
	e[++num].to = to;
	e[num].dis = dis;
	e[num].next = head[from];
	head[from] = num;
}
void getRoot(int u,int fa,int ALL){   //找重心
    size[u] = 1; maxson[u] = 0;
    for(int i = head[u]; i; i = e[i].next)
       if(e[i].to != fa && !vis[e[i].to]){
 	     getRoot(e[i].to, u, ALL);
	     size[u] += size[e[i].to];
         maxson[u] = max(maxson[u], size[e[i].to]);
       }
    maxson[u] = max(maxson[u], ALL - size[u]);
    if(maxson[u] < Max) root = u, Max = maxson[u];
}
void dfs(int u, int fa, int dep, int rt){ //算出每个点的深度，并标记属于根的哪棵子树
    belong[u] = rt;
    deep[u] = dep;
    for(int i = head[u]; i; i = e[i].next)
       if(e[i].to != fa)
         dfs(e[i].to, u, dep + e[i].dis, rt);
}
void Solve(int u){
    if(vis[u]){
      printf("%d\n", ans);
      exit(0);
    }      
    vis[u] = 1;
    for(int i = head[u]; i; i = e[i].next)
       dfs(e[i].to, u, e[i].dis, e[i].to);
    deep[u] = 0;
    Max = 0; p[0] = 0;
    int last = 0;
    for(int i = 1; i <= m; ++i)    //找出所有距离最大的点对并求出答案
       if(deep[x[i]] + deep[y[i]] > Max) 
         Max = deep[x[i]] + deep[y[i]], p[p[0] = 1] = i;
       else if(deep[x[i]] + deep[y[i]] == Max)
         p[++p[0]] = i;
    ans = min(ans, Max);   //更新答案
    for(int i = 1; i <= p[0]; ++i){
       if(belong[x[p[i]]] != belong[y[p[i]]]){  //如果有一个点对之间的路径经过根，当前答案一定是最优的
         printf("%d\n", ans);
         exit(0);
       }
       else 
         if(!last) last = belong[x[p[i]]];
         else if(last != belong[x[p[i]]]){  //如果两个点对不在同一子树里，当前答案也一定最优
           printf("%d\n", ans);
           exit(0);
         }
    }
    Max = 9996666;
    getRoot(last, u, size[last]);  //找子树的重心
    Solve(root);   //递归处理
}
int a, b, c;
int main(){
    n = read(); m = read();
    for(int i = 2; i <= n; ++i){
       a = read(); b = read(); c = read(); 
       Add(a, b, c); Add(b, a, c);
    }
    for(int i = 1; i <= m; ++i){
       x[i] = read(); y[i] = read();
    }
    Max = 9996666; getRoot(1, 0, n);
    Solve(root);
    return 0;
}

```

---

## 作者：¶凉笙 (赞：7)

## [题解] P4886 快递员

> [传送门](https://www.luogu.com.cn/problem/P4886)

### 前缀部分

**前缀知识：点分治。**

对于此题而言，与其说是点分治的题，不如说是利用了点分治的递归思想，因此如果你没有学过点分治也没问题。

### 题解

[更好的阅读体验](https://www.luogu.com.cn/blog/AG-Liangsheng/solution-p4886)

- 首先是树上路径问题，很自然的想到点分治。

- 题意不再赘述，但是本题的最高价值就在于**思考如何才能取得答案最优。**

**答案最优的情况（下面的“点对”都是对于距离最长的点对而言）**

- 第一种情况，存在一组点对使得他们两个之间的最短路径**经过当前的根节点**。

![](https://cdn.luogu.com.cn/upload/image_hosting/wdgyc9q4.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

- 第二种情况，**至少存在两组**点对分别分布在不同的点对内。$e.g.$，$(u1,v1)\in son1,(u2,v2)\in son2$

![](https://cdn.luogu.com.cn/upload/image_hosting/ryzv5su0.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

如果出现了以上两种情况，直接输出当前的最小 $ans$ 即可。

否则递归进入最大的点对所在的那棵子树。

### 细节部分

对于这道题来说，首先要明白它不是每一棵子树都要递归的。

所以就不排除下面这两种情况：

- 递归子树的时候，找到的 $rt$ 可能已经被 solve 过了。

- 有可能存在两种情况，使得这两种情况下可以互相转换（互相递归）。

什么意思呢？

比如现在有两个节点 $rt1,rt2$。

以这两个节点为根时，算法都表现出了**递归向另一方**的趋势，所以会导致 TLE。

这就是下面代码所说的细节。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
template <typename T>
inline T read(){
	T x=0;char ch=getchar();bool fl=false;
	while(!isdigit(ch)){if(ch=='-')fl=true;ch=getchar();}
	while(isdigit(ch)){
		x=(x<<3)+(x<<1)+(ch^48);ch=getchar();
	}
	return fl?-x:x;
}
const int maxn = 1e5 + 100;
struct edge{
	int to,nxt,w;
}e[maxn<<1];
int head[maxn],cnt=0;
inline void link(int u,int v,int w){
	e[++cnt].to=v;e[cnt].nxt=head[u];head[u]=cnt;e[cnt].w=w;
}
#define mp make_pair
const int INF = 0x3f3f3f3f;
int n,m,S,rt=0;
int mx[maxn],sz[maxn],de[maxn];
bool vis[maxn];
pair<int,int> p[maxn];
void find_rt(int u,int fa){
	sz[u]=1;mx[u]=0;
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v==fa || vis[v])continue;
		find_rt(v,u);
		sz[u]+=sz[v];
		mx[u]=max(mx[u],sz[v]);
	}
	mx[u]=max(mx[u],S-sz[u]);
	if(mx[rt]>mx[u])rt=u;
}
int col[maxn];
void dfs(int u,int fa,int c){
	col[u]=c;
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v==fa)continue;
		de[v]=de[u]+e[i].w;
		dfs(v,u,c);
	}
}
int ans=INF;
#include <vector>
#define Pair pair<int,int>
int s[maxn];
void solve(int u){
	if(vis[u]){
		printf("%d\n",ans);exit(0);
	}//细节
	vis[u]=true;de[u]=0;
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		de[v]=e[i].w;
		dfs(v,u,v);
	}
	int la=0,maxx=0;
	s[0]=0;
	for(int i=1;i<=m;i++){
		if(de[p[i].first]+de[p[i].second]>maxx){
			s[0]=0;s[++s[0]]=i;maxx=de[p[i].first]+de[p[i].second];
		}
		else if(de[p[i].first]+de[p[i].second]==maxx){
			s[++s[0]]=i;
		}
	}
	ans=min(ans,maxx);
	for(int i=1;i<=s[0];i++){
		if(col[p[s[i]].first]!=col[p[s[i]].second]){
			printf("%d\n",ans);exit(0);
		}
		else if(!la)la=col[p[s[i]].first];
		else if(la!=col[p[s[i]].first]){
			printf("%d\n",ans);exit(0);
		}
	}
	mx[rt=0]=INF;S=sz[la];
	find_rt(la,0);
	solve(rt);
}
#define read() read<int>()
int main(){
	n=read();m=read();
	for(int i=1,u,v,w;i<n;i++){
		u=read();v=read();w=read();
		link(u,v,w);link(v,u,w);
	}
	for(int i=1;i<=m;i++){
		int u=read(),v=read();
		p[i]=mp(u,v);
	}
	S=n;mx[rt=0]=INF;
	find_rt(1,0);
	solve(rt);
	return 0;
}
```

---

## 作者：封禁用户 (赞：3)

正解好像很简单，但我太菜了，打了一个 6KB 的无脑算做法。

算出答案，就是要把每个点距离每个起点与终点的和的最大值算出来。考虑如何快速维护这个东西。设起点为 $s_i$，终点为 $t_i$。

设我们计算的点为 $u$。

## Part 1

计算起点终点均在 $u$ 子树内。设这东西为 $mn_u$。这非常好统计，只需要在 $\operatorname{lca}(s_i,t_i)$ 的位置计算一下 $s_i$ 至 $t_i$ 的距离，转移：

$mn_u = \max\{\max\{mn_v+w\times 2\},\max\{\operatorname{dist}(s_i,t_i)\times [\operatorname{lca}(s_i,t_i)=u]\}\}$

$w$ 就是 $u,v$ 的边权。

但是一定要注意如果子树内什么都没有时一定要将值赋为 $-\inf$。

## Part 2

计算起点或终点有一个在 $u$ 子树内。显然 $s_i$ 到 $t_i$ 的路径一定经过 $u$，它的贡献就是 $\operatorname{dist}(s_i,t_i)$。这个可以用树链剖分维护。

## Part 3

考虑起点终点均在 $u$ 子树外的。我们在 dfs 的时候记录下祖先的答案，这样在进入 $u$ 的时候只用统计所有**经过 $father_u$ 或 $father_u$ 的其他儿子（不包括 $u$）并不进入 $u$ 子树的路径**。

再次分讨。

设 $x$ 为 $father_u$ 的其他儿子。

- 起点终点都在自己子树内的答案非常好算，就是 $mn_x$。

- 过 $x$ 且起点或终点有一个在 $x$ 子树内。这个东西可以在树链剖分的时候，对于 $s_i,t_i$，将除了 $\operatorname{lca}(s_i,t_i)$ 以及 $\operatorname{lca}(s_i,t_i)$ 下面的两个不能标记以外，将剩下的标上一个 $\operatorname{dist}(s_i,t_i)$。

![](https://cdn.luogu.com.cn/upload/image_hosting/wsy29qj4.png)

（标红的位置）

- 对于在这些位置的点 $x$ 来说，$s_i,t_i$ 路径是一定过 $x,father_u$，且一定不会进入 $u$ 的子树。也就是说，统计了 lca 是 $father_u$ 的祖先且进入 $x$ 子树的答案。

手玩一下，发现现在我们已统计了所有 lca 在除了 $father_u$ 以外的所有 $s_i,t_i$。考虑如何计算 lca 在 $father_u$ 的呢？

对于 $s_i,t_i$，lca 在 $father_u$，那它的答案只有在计算 $s_i$ 所在子树或 $t_i$ 所在子树时不能被统计答案。那我们用一个 `std::set` 记录当前 lca 在 $father_u$ 的可选的路径长度，把 $s_i$ 或 $t_i$ 在当前子树内的从 `std::set` 里面暂时删除，这样就可以综合上前面两条计算的以及从祖先遗传下来的答案，得到 $u$ 的答案。

因为一共只有 $m$ 条路径，在用 `std::set` 统计时一共只会 `insert` 或 `erase` $4$ 次，再算上树剖，一共是 $\mathcal{O}(m\log m+n \log^2 n)=\mathcal{O}(n \log^2 n)$ 的。虽然复杂度不如点分治，但却可以统计所有的答案。

## AC code

```cpp
#include<bits/stdc++.h>
#define int long long
#define f(i,j,n) for(int i=j;i<=n;i++)
#define F(i,n,j) for(int i=n;i>=j;i--)
#define updmax(a,b) a=max(a,b)
#define updmin(a,b) a=min(a,b)
#define pb push_back
#define XQZ
using namespace std;
namespace fsd{
#define gc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,MAXSIZE,stdin),p1==p2)?EOF:*p1++)
	const int MAXSIZE=1<<20;
	char buf[MAXSIZE],*p1,*p2;
	inline int read(){
		int ak=0,ioi=1;char c=gc();
		while(!isdigit(c)){if(c=='-')ioi=-1;c=gc();}
		while(isdigit(c))ak=ak*10+(c^48),c=gc();
		return ak*ioi;
	}
}
using namespace fsd;


const int N=1e5+10;
int n,m;
vector<pair<int,int> >h[N];
int dfn[N],cnt,mn[N],dp[N][20],dpw[N][20],dep[N],hs[N],siz[N];
int ans=LLONG_MAX/2;
int to[N];
struct aaa{int a,b,c;};
vector<aaa>sp[N];
int nx[N];
vector<pair<int,int> > go[N];
int nm[N],rr[N];
int up[N],tb[N];


void dfs0(int k,int prt,int dpe){
	siz[k]=1;
	dp[k][0]=prt;
	dep[k]=dpe;
	for(auto [v,p]:h[k]){
		if(v==prt)continue;
		dpw[v][0]=p;
		dfs0(v,k,dpe+1);
		if(siz[hs[k]]<siz[v])hs[k]=v;
		siz[k]+=siz[v];
	}
}
void dfs1(int k,int prt,int u){
	dfn[k]=++cnt;
	up[k]=u;
	if(hs[k])dfs1(hs[k],k,u);
	for(auto [v,p]:h[k]){
		if(v==prt||v==hs[k])continue;
		dfs1(v,k,v);
	}
}
void init(){
	dfs0(1,0,1);
	dfs1(1,0,1);
	f(j,1,19){
		f(i,1,n)dp[i][j]=dp[dp[i][j-1]][j-1],dpw[i][j]=dpw[i][j-1]+dpw[dp[i][j-1]][j-1];
	}
}


struct Mst{
	struct abc{
		int l,r,maxn=0,tg=0;
#define mid (((r-l)>>1)+l)
	}Tree[N*4];
	void build(int k,int l,int r){
		Tree[k].l=l,Tree[k].r=r;
		Tree[k].maxn=LLONG_MIN/4;
		if(l==r)return;
		build(k*2,l,mid),build(k*2+1,mid+1,r);
	}
	void upd(int k,int v){
		Tree[k].maxn=max(Tree[k].maxn,v);
		Tree[k].tg=max(Tree[k].tg,v);
	}
	void pushdown(int k){
		if(Tree[k].tg){
			upd(k*2,Tree[k].tg),upd(k*2+1,Tree[k].tg),Tree[k].tg=0;
		}
	}
	void modify(int k,int ll,int rr,int v){
		if(Tree[k].l>rr||Tree[k].r<ll)return;
		if(Tree[k].l>=ll&&Tree[k].r<=rr){upd(k,v);return;}
		pushdown(k);
		modify(k*2,ll,rr,v);
		modify(k*2+1,ll,rr,v);
	}
	int ask(int k,int p){
		if(Tree[k].l>p||Tree[k].r<p)return 0;
		if(Tree[k].l==Tree[k].r)return Tree[k].maxn;
		pushdown(k);
		return ask(k*2,p)+ask(k*2+1,p);
	}
}_mst,_mst1;
struct LC{
	void modify(int l,int r,int v){
		if(up[l]==up[r]){_mst.modify(1,min(dfn[l],dfn[r]),max(dfn[r],dfn[l]),v);return;}
		if(dep[up[l]]>dep[up[r]]){
			_mst.modify(1,dfn[up[l]],dfn[l],v);
			l=dp[up[l]][0];
		}else{
			_mst.modify(1,dfn[up[r]],dfn[r],v);
			r=dp[up[r]][0];
		}
		modify(l,r,v);
	}
}_t;
struct LC1{
	void modify(int l,int r,int v){
		if(up[l]==up[r]){_mst1.modify(1,min(dfn[l],dfn[r]),max(dfn[r],dfn[l]),v);return;}
		if(dep[up[l]]>dep[up[r]]){
			_mst1.modify(1,dfn[up[l]],dfn[l],v);
			l=dp[up[l]][0];
		}else{
			_mst1.modify(1,dfn[up[r]],dfn[r],v);
			r=dp[up[r]][0];
		}
		modify(l,r,v);
	}
}_t1;


pair<int,int> getl(int a,int b){
	if(dep[a]<dep[b])swap(a,b);
	int w=0;
	F(j,19,0){
		if(dep[dp[a][j]]>=dep[b])w+=dpw[a][j],a=dp[a][j];
	}
	if(a==b)return {a,w};
	F(j,19,0){
		if(dp[a][j]!=dp[b][j])w+=dpw[a][j]+dpw[b][j],a=dp[a][j],b=dp[b][j];
	}
	return {dp[a][0],w+dpw[a][0]+dpw[b][0]};
}
pair<int,int> getl2(int a,int b){
	if(dep[a]<dep[b])swap(a,b);
	int w=0;
	F(j,19,0){
		if(dep[dp[a][j]]>=dep[b])w+=1<<j,a=dp[a][j];
	}
	if(a==b)return {a,w};
	F(j,19,0){
		if(dp[a][j]!=dp[b][j])w+=1<<(j+1),a=dp[a][j],b=dp[b][j];
	}
	return {dp[a][0],w+dpw[a][0]+dpw[b][0]};
}
pair<int,int> getl3(int a,int b){
	if(a==b)return {0,0};
	if(dep[a]<dep[b])swap(a,b);
	int w=0;
	F(j,19,0){
		if(dep[dp[a][j]]>dep[b])w+=dpw[a][j],a=dp[a][j];
	}
	if((dep[a]==dep[b]?a:dp[a][0])==b)return {a,0};
	if(dep[a]!=dep[b])a=dp[a][0];
	F(j,19,0){
		if(dp[a][j]!=dp[b][j])w+=dpw[a][j]+dpw[b][j],a=dp[a][j],b=dp[b][j];
	}
	return {a,b};
}
int getll(int a,int b){
	F(j,19,0){
		if((1<<j)<=b){
			a=dp[a][j],b-=(1<<j);
		}
	}
	return a;
}


void dfs2(int k,int prt){
	tb[k]=_mst1.ask(1,dfn[k]);
	for(auto [v,p]:h[k]){
		if(v==prt)continue;
		dfs2(v,k);
		updmax(mn[k],mn[v]+p*2);
	}
}
void dfs(int k,int prt,int u){
	int thi=max(u,mn[k]);
	int q=_mst.ask(1,dfn[k]);
	thi=max(thi,q);
	updmin(ans,thi);
	int aa=LLONG_MIN/4;
	int ls=0;
	for(auto [v,p]:h[k]){
		if(v==prt)continue;
		updmax(to[v],aa);
		updmax(aa,mn[v]+p*2);
		updmax(aa,tb[v]);
		if(ls)nx[ls]=v,nm[v]=nm[ls]+1;
		ls=v;
	}
	aa=LLONG_MIN/4;
	for(int i=(int)h[k].size()-1;i>=0;i--){
		auto [v,p]=h[k][i];
		if(v==prt)continue;
		updmax(to[v],aa);
		updmax(aa,mn[v]+p*2);
		updmax(aa,tb[v]);
	}
	set<pair<int,int> > s;
	int i=0;
	for(auto [l,r,lon]:sp[k]){
		i++;
		pair<int,int> p=getl3(l,r);
		if(p.second)go[nx[p.second]].push_back({lon,i});
		if(p.first)go[nx[p.first]].push_back({lon,i});
		if(p.first)go[p.first].push_back({-lon,i});
		if(p.second)go[p.second].push_back({-lon,i});
		s.insert({lon,i});
	}
	updmax(u,rr[k]);
	for(auto [v,p]:h[k]){
		if(v==prt)continue;
		int nw=max(u,to[v]);
		for(auto [q,j]:go[v]){
			if(q<0){
				set<pair<int,int> >::iterator it=s.lower_bound({-q,j});
				if((*it).first==-q&&(*it).second==j)s.erase(it);
			}else{
				s.insert({q,j});
			}
		}
		if(!s.empty())updmax(nw,(*s.rbegin()).first);
		dfs(v,k,nw+p*2);
	}
}
void gs(){
	n=read(),m=read();
	f(i,1,n)rr[i]=tb[i]=mn[i]=to[i]=LLONG_MIN/4;
	_mst.build(1,1,n);
	_mst1.build(1,1,n);
	f(i,1,n-1){
		int p=read(),q=read(),v=read();
		h[p].push_back({q,v}),h[q].push_back({p,v});
	}
	init();
	f(i,1,m){
		int l=read(),r=read();
		pair<int,int> s=getl(l,r);
		_t.modify(l,r,s.second);
		if(s.first!=l)updmax(rr[l],s.second);
		if(s.first!=r)updmax(rr[r],s.second);
		updmax(mn[s.first],s.second);
		sp[s.first].push_back({l,r,s.second});
		int lca=s.first,le=s.second;
		s=getl2(l,lca);
		if(s.second>=2)_t1.modify(l,getll(l,s.second-2),le);
		s=getl2(r,lca);
		if(s.second>=2)_t1.modify(r,getll(r,s.second-2),le);
	}
	dfs2(1,0);
	dfs(1,0,LLONG_MIN/4);
	printf("%lld\n",ans);
}
signed main(){
	gs();
	return 0;
}
```

---

## 作者：Soulist (赞：3)

对淀粉质思想的运用$qwq$

我们考虑对于一个点对$(u,v)$，若其为最大值，且点$rt$在其路径上，那么显然答案是不能再小的，否则答案是可能可以更小的。

具体类比下来，对于一个$rt$而言，其肯定为答案有且仅有两种情况：

$1.$距离最远的点对$(u,v)$满足其分居在$rt$的两棵子树内

$2.$存在两个及以上的点对$(u,v)$满足这两个点在同一颗子树内，但是这多个子树不是同一颗。

否则，如果为如下情况，答案是可能会更小。

$3.$对于所有的距离最长的两个点对$(u,v)$都有其处于同一颗子树

那么我们就往那颗子树内走即可。

但是直接走下来复杂度还是$O(n^2)$的，因为我们每次统计答案都是暴力统计。

考虑每次对那颗子树求一个重心，那么就可以将问题规模缩小一半，因为我们可以保证可能更小的点就在这颗子树内。

复杂度$O((n+m)\log n)$

```cpp
#include<bits/stdc++.h>
using namespace std;
#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next )
#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )
#define re register
int read() {
	char cc = getchar(); int cn = 0, flus = 1;
	while(cc < '0' || cc > '9') {  if( cc == '-' ) flus = -flus;  cc = getchar();  }
	while(cc >= '0' && cc <= '9')  cn = cn * 10 + cc - '0', cc = getchar();
	return cn * flus;
}
const int N = 1e5 + 5 ; 
struct E {
	int to, next, w ; 
} e[N * 2] ;
int head[N], dis[N], fr[N], ed[N], Ans, cnt, n, m ; 
int rt, sum, vis[N], sz[N], dp[N], book[N] ; 
void add( int x, int y, int z ) {
	e[++ cnt] = (E){ y, head[x], z }, head[x] = cnt , 
	e[++ cnt] = (E){ x, head[y], z }, head[y] = cnt ; 
}
void get_rt( int x, int fa ) {
	sz[x] = 1, dp[x] = 1 ; 
	Next( i, x ) {
		int v = e[i].to ; if( v == fa || vis[v] ) continue ; 
		get_rt( v, x ), sz[x] += sz[v], dp[x] = max( dp[x], sz[v] ) ;
	} 
	dp[x] = max( dp[x], sum - sz[x] ) ;
	if( dp[x] < dp[rt] ) rt = x ; 
}
void dfs( int x, int fa, int p ) {
	book[x] = p ;
	Next( i, x ) {
		int v = e[i].to ; if( v == fa ) continue ; 
		dis[v] = e[i].w + dis[x], dfs( v, x, p ) ;
	}
}
void out() {
	printf("%d\n", Ans ) ; exit(0) ; 
}
void solve( int x ) {
	if( vis[x] ) out() ; 
	vis[x] = 1, dis[x] = 0 ;
	Next( i, x ) {
		int v = e[i].to ; dis[v] = dis[x] + e[i].w, dfs( v, x, v ) ;
	}
	int Mx = 0, zk = 0, chk = 0 ;
	rep( i, 1, m ) {
		int u = fr[i], v = ed[i] ; 
		if( dis[u] + dis[v] == Mx ) {
			if( book[u] != book[v] ) zk = 1 ; 
			if( book[u] == book[v] && book[u] != chk ) zk = 1 ; 
		}
		if( dis[u] + dis[v] > Mx ) {
			Mx = dis[u] + dis[v], zk = 0 ; 
			if( book[u] != book[v] ) zk = 1 ; 
			if( book[u] == book[v] ) chk = book[u] ; 
		}
	}
	Ans = min( Ans, Mx ) ;
	if( zk ) out() ; 
	else {
		rt = 0, sum = dp[0] = sz[chk], get_rt( chk, x ) ; 
		solve( rt ) ; 
	}
}
signed main()
{
	n = read(), m = read() ; int x, y, z ; 
	rep( i, 2, n ) x = read(), y = read(), z = read(), add( x, y, z ) ; 
	rep( i, 1, m ) fr[i] = read(), ed[i] = read() ; 
	rt = 0, dp[0] = sum = n, get_rt( 1, 0 ), Ans = 23333333 ;
	solve( rt ) ;
	return 0;
}

```

---

## 作者：Stump (赞：3)

点分治神题$orz$

首先考虑$O(nm)$的暴力，就是枚举任意点作为邮递站作根，暴力$dfs$，求出每组配送的最大代价，记作$cost_i$。

那么对于最优点作根，显然对于任意一条从根开始的链，$cost_i$都是递增的

于是我们可以点分治一下，每次做出当前子树的重心，对所有配送都求一遍代价，取$max$

对于一次配送，若其代价为$max$,并且两点跨过重心，或者多组配送在重心的不同子树，代价均为$max$，显然此时是最优点

否则迭代着继续点分治，显然只有$log$次

复杂度为$O(mlogn)$

```cpp
#include<cstdio>
#include<algorithm>
#include<cstdlib>
#define rep(i,s,t) for(register int i=s;i<=t;++i)
#define gi(x) read(x)
#define gii(x,y) read(x),read(y)
#define giii(x,y,z) read(x),read(y),read(z)
#define ms(f,x) memset(f,x,sizeof f)
#define open(x) freopen(#x".in","r",stdin),freopen(#x".out","w",stdout)
namespace IO{
    #define gc getchar()
    #define pc(x) putchar(x)
    template<typename T>inline void read(T &x){
        x=0;int f=1;char ch=gc;while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=gc;}
        while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=gc;x*=f;return;
    }
    template<typename T>inline void write(T x=0){
        T wr[51];wr[0]=0;if(x<0)pc('-'),x=-x;if(!x)pc(48);
        while(x)wr[++wr[0]]=x%10,x/=10;while(wr[0])pc(48+wr[wr[0]--]);return;
    }
}
using IO::read;
using IO::write;
using namespace std;
const int N=2e5+11;
int n,m,tot,rt,ans;
int nxt[N],las[N],to[N],w[N],sz[N],f[N],bel[N],dis[N],p[N];
int x[N],y[N];
bool vis[N];
inline void add(int x,int y,int z){
	nxt[++tot]=las[x];
	las[x]=tot;
	to[tot]=y;
	w[tot]=z;
}
inline void getroot(int x,int fa,int siz){
	sz[x]=1;f[x]=0;
	for(register int e=las[x];e;e=nxt[e]){
		if(to[e]==fa||vis[to[e]])continue;
		getroot(to[e],x,siz);
		sz[x]+=sz[to[e]];
		f[x]=max(f[x],sz[to[e]]);
	}
	f[x]=max(f[x],siz-sz[x]);
	if(f[x]<f[rt])rt=x;
}
inline void dfs(int x,int fa,int rt){
	bel[x]=rt;
	for(register int e=las[x];e;e=nxt[e]){
		if(to[e]==fa)continue;
		dis[to[e]]=dis[x]+w[e];
		dfs(to[e],x,rt);
	}
}
inline void solve(int u){
	if(vis[u]){
		printf("%d\n",ans);
		exit(0);
	}
	vis[u]=1,dis[u]=0;
	for(register int e=las[u];e;e=nxt[e])
		dis[to[e]]=w[e],dfs(to[e],u,to[e]);
	int Max=0,las=0;p[0]=0;
	rep(i,1,m)
		if(dis[x[i]]+dis[y[i]]>Max)
			Max=dis[x[i]]+dis[y[i]],p[p[0]=1]=i;
		else
			if(Max==dis[x[i]]+dis[y[i]])
				p[++p[0]]=i;
	ans=min(ans,Max);
	rep(i,1,p[0])
		if(bel[x[p[i]]]!=bel[y[p[i]]]){
			printf("%d\n",ans);
			exit(0);
		}
		else{
			if(!las)las=bel[x[p[i]]];
			else 
				if(bel[x[p[i]]]!=las){
					printf("%d\n",ans);
					exit(0);
				}
		}
	rt=0;
	getroot(las,u,sz[las]);
	solve(rt);
}
int main(){
	gii(n,m);
	rep(i,2,n){
		int u,v,w;
		giii(u,v,w);
		add(u,v,w),add(v,u,w);
	}
	rep(i,1,m)
		gii(x[i],y[i]);
	ans=1e9;
	f[rt=0]=n+1;
	getroot(1,1,n);
	solve(rt);
	return 0;
}
```

---

## 作者：RainySoul (赞：2)

点分治好题。

题目就是说给你一棵树与 $m$ 对 $(a_i,b_i)$，要你找出一个点 $x$ 以最小化 $\max_{i=1}^{m}dis(a_i,x)+dis(x,b_i)$。

考虑点分治，每次拎出来一个点 $u$ 假设它是快递中心，计算它到所有 $(a_i,b_i)$ 的最大值，如果有一个最大值对应的 $a_i$ 与 $b_i$ 属于 $u$ 的不同子树内（即经过 $u$），那么你可以直接输出答案了，因为很容易想到不可能更优了。

而如果所有最大值对应的 $(a_i,b_i)$ 都属于 $u$ 的同一子树内就递归这个子树尝试更小化答案。最后一种情况是存在多个 $(a_i,b_i)$ 分属不同的子树，那么由于边权 $w_i \ge 1$，如果递归子树一定会更大化答案，直接输出。

每次拎出重心，这样可以保证递归层数是 $O(\log n)$ 的，每次分治时间复杂度 $O(n)$，总时间复杂度 $O(n \log n)$，可以通过此题。

AC code：

```
#include<bits/stdc++.h>
using namespace std;
const int N=100010;
inline int read(){
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=x*10+c-'0';
        c=getchar();
    }
    return x*f;
}
struct zyx{int to,w;};
int n,m,rt,sum,ans=0x3f3f3f3f;
int sz[N],son[N],from[N],dis[N],a[N],b[N],vis[N];
vector<zyx> e[N];
void getrt(int now,int fa){
    sz[now]=1;
    son[now]=0;
    for(int i=0;i<(int)e[now].size();i++){
        int to=e[now][i].to;
        if(to==fa||vis[to])continue;
        getrt(to,now);
        sz[now]+=sz[to];
        son[now]=max(son[now],sz[to]);
    }
    son[now]=max(son[now],sum-sz[now]);
    if(son[now]<son[rt])rt=now;
}
void getdis(int now,int fa,int num){
    from[now]=num;
    for(int i=0;i<(int)e[now].size();i++){
        int to=e[now][i].to;
        if(to==fa)continue;
        dis[to]=dis[now]+e[now][i].w;
        getdis(to,now,num);
    }
} 
void update(int now,int fa){
    sz[now]=1;
    for(int i=0;i<(int)e[now].size();i++){
        int to=e[now][i].to;
        if(to==fa||vis[to])continue;
        update(to,now);
        sz[now]+=sz[to];
    }
}
vector<int> temp;
int get(int x){return dis[a[x]]+dis[b[x]];}
void solve(int now){
    vis[now]=1;
    dis[now]=0;
    memset(from,0,sizeof from);
    for(int i=0;i<(int)e[now].size();i++){
        int to=e[now][i].to;
        dis[to]=e[now][i].w;
        getdis(to,now,to);//求出now到每个点的距离
        //额外标记一下每个点是属于哪个子树的
        update(to,now);//这里是为了更新 以now为根的新树，每个点的子树大小，后面要用到
    }
    temp.clear();
    for(int i=1;i<=m;i++){
        if(temp.empty())temp.push_back(i);
        else if(get(temp[0])==get(i))temp.push_back(i);
        else if(get(i)>get(temp[0])){
            temp.clear();
            temp.push_back(i);
        }
    }
    int t=0;//如果最大值对应的 (a[i],b[i]) 属于同一子树，t就是这个儿子节点
    ans=min(ans,get(temp[0]));//更新答案
    for(int i=0;i<(int)temp.size();i++){
        if(from[a[temp[i]]]!=from[b[temp[i]]]){
            cout<<ans;
            exit(0);
        }
        else if(!t)t=from[a[temp[i]]];
        else if(t!=from[a[temp[i]]]){
            cout<<ans;
            exit(0);
        }
    }
    rt=0;
    son[rt]=sum=sz[t];//这里的 sz[t] 是新的，注意
    getrt(t,0);
    if(vis[rt]){//防止反复横跳
        cout<<ans<<'\n';
        exit(0);
    }
    solve(rt);
}
int main(){
    n=read(),m=read();
    for(int i=1;i<n;i++){
        int u=read(),v=read(),w=read();
        e[u].push_back((zyx){v,w});
        e[v].push_back((zyx){u,w});
    }
    for(int i=1;i<=m;i++)a[i]=read(),b[i]=read();
    son[rt]=sum=n;
    getrt(1,0);
    solve(rt);
    return 0;
}
```

后话：写代码的时候认为如果不使用那个 `update` 函数重新算一遍 $sz$ 就会出问题，实际上并不是这样的，[详见此帖](https://www.luogu.com/discuss/277295)，因此这个 `update` 可以不写。

---

## 作者：sangshang (赞：2)

## Preface

你敢跟我举行别样的码力大战吗？

~AC 后看题解发现这题是思维题。~

## Solution

考虑暴力维护点 $u$ 的答案。首先肯定要链剖，定义 $top_u$ 表示 $u$ 的链顶，$son_u$ 表示 $u$ 的重儿子。

定义如下标记：

- $allson_u$ 表示对 $u$ 整棵子树都有影响。

- $heavy_u$ 表示对点 $u$ 以及除了点 $u$ 的重儿子的子树都有贡献。

- 定义标记 $light_u$ 包含若干个二元组 $(val,x)$，表示对 $u$ 和除子节点 $x$ 以外的所有子树有影响。

- 定义标记 $pos_u$ 包含若干个三元组 $(val,x,y)$，表示对 $u$ 和除子节点 $x,y$ 以外的子树有影响。

- $pushup_u$ 为对 $u$ 所在链上的所有祖先（不包含自己），影响他们的 $heavy$ 标记。

- $pushupupdate_u$ 表示对 $u$ 所在链上所有祖先，影响他们的 $heavy$ 标记，且累加上到他们路径上的边的影响。

~终于写完定义了。~

对于每个操作 $(u,v)$。对于两点路径上的边，显然可以用如上标记维护。

具体地说就是设目前跳到 $u$，在 $pushup_u$ 打上标记，在 $light_u$ 打上 $x$ 为 $u$ 跳上来的节点的标记。而在 $u,v$ 在 $\text{LCA}$ 所在的链上相遇时，则要使用 $pos$ 标记，再用线段树维护 $heavy$ 标记。

对两点 $\text{LCA}(u,v)$ 到根节点，也可以维护，方法大致相似。

这样总共会打上 $\log n$ 个 $light$ 标记，$O(1)$ 个 $pos$ 标记，进行 $O(1)$ 次线段树操作。

打完标记最后下传时，对于 $light$ 标记，记录最大值和与最大值的 $x$ 不同的最大值（此时应该说次大值），即可实现均摊 $O(1)$，$pos$ 标记同理，只不过是分别记录 $x$ 不相同的最大值和 $y$ 不相同的最大值。

综上所述，时间复杂度 $O(n+q\log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace SOLUTION{
	const int maxn=1e5+5;
	typedef pair<int,int> pii;
	vector<pii>e[maxn];
	int fa[maxn],siz[maxn],son[maxn],deep[maxn],dist[maxn];
	inline void prework(int u,int father){
		fa[u]=father;
		siz[u]=1;
		deep[u]=deep[father]+1;
		int maxx=0;
		for(pii i:e[u]){
			int v=i.first;
			if(v!=father){
				dist[v]=dist[u]+i.second;
				prework(v,u);
				siz[u]+=siz[v];
				if(siz[v]>maxx){
					maxx=siz[v];
					son[u]=v;
				}
			}
		}
	}
	int top[maxn],dfn[maxn],sign;
	inline void get_top(int u,int Top){
		top[u]=Top;
		dfn[u]=++sign;
		if(!son[u]){
			return;
		}
		get_top(son[u],Top);
		for(pii i:e[u]){
			int v=i.first;
			if(v!=fa[u]&&v!=son[u]){
				get_top(v,v);
			}
		}
	}
	vector<pii>light[maxn];
	class three_value{
		public:
			int a,b,c;
			three_value(int a,int b,int c):a(a),b(b),c(c) {}
			three_value() {}
	};
	vector<three_value>pos[maxn];
	int allson[maxn],heavy[maxn],pushup[maxn],pushup_update[maxn],ans[maxn];
	int tree[maxn<<2];
	inline void update(int u,int l,int r,int x,int y,int newval){
		if(x<=l&&r<=y){
			tree[u]=max(tree[u],newval);
			return;
		}
		int mid=(l+r)>>1;
		if(x<=mid){
			update(u<<1,l,mid,x,y,newval);
		}
		if(mid<y){
			update(u<<1|1,mid+1,r,x,y,newval);
		}
	}
	inline int query(int u,int l,int r,int x){
		int res=-0x3f3f3f3f;
		while(l!=r){
			res=max(res,tree[u]);
			int mid=(l+r)>>1;
			if(x<=mid){
				u<<=1;
				r=mid;
			}
			else{
				u=(u<<1|1);
				l=mid+1;
			}
		}
		return max(res,tree[u]);
	}
	inline int LCA(int u,int v){
		while(top[u]!=top[v]){
			if(deep[top[u]]<deep[top[v]]){
				u^=v,v^=u,u^=v;
			}
			u=fa[top[u]];
		}
		return (deep[u]<=deep[v])?(u):(v);
	}
	inline void solve_path(int u,int v){
		int lca=LCA(u,v);
		int dis=dist[u]+dist[v]-(dist[lca]<<1);
		int lastu=0,lastv=0;
		while(top[u]!=top[v]){
			if(deep[top[u]]<deep[top[v]]){
				u^=v,v^=u,u^=v;
				lastu^=lastv,lastv^=lastu,lastu^=lastv;
			}
			pushup[u]=max(pushup[u],dis);
			light[u].push_back(make_pair(dis,lastu));
			lastu=top[u];
			u=fa[top[u]];
		}
		if(deep[u]>deep[v]){
			u^=v,v^=u,u^=v;
			lastu^=lastv,lastv^=lastu,lastu^=lastv;
		}
		if(u==v){
			pos[u].push_back(three_value(dis,lastu,lastv));
		}
		else{
			pos[u].push_back(three_value(dis,lastu,son[u]));
			light[v].push_back(make_pair(dis,lastv));
		}
		if(dfn[u]+1<dfn[v]){
			update(1,1,sign,dfn[u]+1,dfn[v]-1,dis);
		}
		while(top[u]!=1){
			pushup_update[u]=max(pushup_update[u],dis);
			dis+=((dist[u]-dist[fa[top[u]]])<<1);
			u=top[u];
			light[fa[u]].push_back(make_pair(dis,u));
			u=fa[u];
		}
		pushup_update[u]=max(pushup_update[u],dis);
	}
	inline void pushdown_tag(int u){
		heavy[u]=max(heavy[u],query(1,1,sign,dfn[u]));
		for(pii i:e[u]){
			int v=i.first;
			if(v!=fa[u]){
				pushdown_tag(v);
			}
		}
		if(fa[u]&&top[u]!=u){
			pushup[fa[u]]=max(pushup[fa[u]],pushup[u]);
			pushup_update[fa[u]]=max(pushup_update[fa[u]],pushup_update[u]+((dist[u]-dist[fa[u]])<<1));
			heavy[fa[u]]=max(heavy[fa[u]],pushup[u]);
			heavy[fa[u]]=max(heavy[fa[u]],pushup_update[u]+((dist[u]-dist[fa[u]])<<1));
		}
	}
	inline void get_answer(int u){
		ans[u]=max(ans[u],max(allson[u],heavy[u]));
		int maxx=-0x3f3f3f3f,it=0,second=-0x3f3f3f3f;
		for(pii i:light[u]){
			ans[u]=max(ans[u],i.first);
			if(i.first>maxx){
				it=i.second;
				maxx=i.first;
			}
		}
		ans[u]=max(ans[u],maxx);
		for(pii i:light[u]){
			if(i.second!=it){
				second=max(second,i.first);
			}
		}
		for(pii i:e[u]){
			int v=i.first;
			if(v!=fa[u]){
				allson[v]=max(allson[v],allson[u]+(i.second<<1));
				if(v!=son[u]){
					allson[v]=max(allson[v],heavy[u]+(i.second<<1));
				}
				if(v!=it){
					allson[v]=max(allson[v],maxx+(i.second<<1));
				}
				else{
					allson[v]=max(allson[v],second+(i.second<<1));
				}
			}
		}
		int itb=0,third=-0x3f3f3f3f;
		maxx=-0x3f3f3f3f,second=-0x3f3f3f3f,it=0;
		for(three_value i:pos[u]){
			if(i.a>maxx){
				maxx=i.a;
				it=i.b;
				itb=i.c;
			}
		}
		ans[u]=max(ans[u],maxx);
		for(three_value i:pos[u]){
			if(i.b!=it&&i.c!=it){
				second=max(second,i.a);
			}
			if(i.b!=itb&&i.c!=itb){
				third=max(third,i.a);
			}
		}
		for(pii i:e[u]){
			int v=i.first;
			if(v!=fa[u]){
				if(v==it){
					allson[v]=max(allson[v],second+(i.second<<1));
				}
				else if(v==itb){
					allson[v]=max(allson[v],third+(i.second<<1));
				}
				else{
					allson[v]=max(allson[v],maxx+(i.second<<1));
				}
				get_answer(v);
			}
		}
	}
	inline int Main(){
		int n,m;
		cin>>n>>m;
		for(int i=1;i<n;++i){
			int u,v,w;
			cin>>u>>v>>w;
			e[u].push_back(make_pair(v,w));
			e[v].push_back(make_pair(u,w));
		}
		prework(1,0);
		get_top(1,1);
		memset(pushup,-0x3f,sizeof(pushup));
		memset(pushup_update,-0x3f,sizeof(pushup_update));
		memset(heavy,-0x3f,sizeof(heavy));
		memset(allson,-0x3f,sizeof(allson));
		memset(tree,-0x3f,sizeof(tree));
		for(int i=1;i<=m;++i){
			int u,v;
			cin>>u>>v;
			solve_path(u,v);
		}
		pushdown_tag(1);
		get_answer(1);
		int output=0x3f3f3f3f;
		for(int i=1;i<=n;++i){
			output=min(output,ans[i]);
		}
		cout<<output<<"\n";
		return 0;
	}
}
int main(){
	//freopen("p4886.in","r",stdin);
	//freopen("mine.out","w",stdout);
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	SOLUTION::Main();
	return 0;
}
```

---

## 作者：未来姚班zyl (赞：2)

#### ~~这是俺的第 100 道紫题正好题解通道开着就来写一篇纪念一下。~~
## 题目大意
在一棵树中找到一个点，使得若干指定点对中与其距离之和的最大值最小。
## 题目分析
看到树与多对距离，第一时间就想到点分治。不过仔细思考之后，发现了一个问题：计算距离之和的时间复杂度似乎每次都得 $O(m)$，而且没有传递性，加上点分治的时间复杂度就会明显爆炸。所以要换一个角度来思考。

假如现在我确定了一个分治中心，对于点对，只有三种情况：
- 其中一个是当前的分治中心。
- 两点在不同子树。
- 两点在相同子树。

前两种情况等同于：**现在的分治中心是对应点对的 LCA**（指以分治中心为根），根节点在它们的最短路径上。这个性质引导我们思考另一个性质：对于一个点对，如果选择的点在它们之间的最短路径上，而这个点对对应的距离之和是最大值，那么答案不可能再优。因为，此时移动这个点，只能在最短路径上移，此时其它点对的距离和减少也没有任何意义，甚至还可能超过原本的答案。

那么最大值对应的点对就只剩第三种情况了。显然，对于一个最大值，更优解如果存在，就只可能在这个点对对应的子树内。否则答案一定更劣，因为最大值变大了。

这样的话，只有最大值对应的点对的所有点都在同一个子树内，才递归处理这个子树，否则直接输出答案。

每次选择子树重心，这样的话复杂度就可以稳定在 $O(m\log n)$ 了，吗？？

有一个问题没有被考虑到，就是跳进那个子树后，我就放弃了现在处理的答案，然而，这个答案可能就是最优的，因为跳进那个子树后可能会导致其他子树的点对的距离和“反超”现在的答案。但这不是大问题，因为如果出现这样的问题，直到两个分治中心相邻时，最优解才会出现，否则，移动后，答案依旧更劣。这时候问题变成了两个分治中心反复横跳。这样解决就更简单了：直接记录上一次的分治中心和答案，如果当前指向的子树的直接儿子就是上一次的分治中心，就直接输出两次答案的最小值，就能通过此题。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned long long
#define ui unsigned int
#define L xd[x].lc
#define R xd[x].rc
#define mid (l+r>>1)
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define per(x,y,z) for(int x=(y);x>=(z);x--)
#define edge(x) for(int i=h[(x)];i;i=nxt[i])
inline int read(){int s=0,w=1;char c=getchar();while(c<48||c>57) {if(c=='-') w=-1;c=getchar();}while(c>=48&&c<=57) s=(s<<1)+(s<<3)+c-48,c=getchar();return s*w;}
inline void pf(ll x){if(x<0) putchar('-'),x=-x;if(x>9)pf(x/10);putchar(x%10+48);}
#define rt return
#define ci const int
ci N=1e5+5;
ci inf=2147000000;
int cnt,n=read(),m=read(),h[N],f[N],to[N*2],nxt[N*2],w[N*2],mx,dep[N],siz[N],l[N],r[N],val[N];
bool vis[N];
inline void add(int a,int b,int c){
	to[++cnt]=b,nxt[cnt]=h[a],h[a]=cnt,w[cnt]=c;
}
inline void dfs_siz(int x,int fa){
	f[x]=fa,siz[x]=1;
	edge(x){
		int y=to[i];
		if(y^fa&&!vis[y])dfs_siz(y,x),siz[x]+=siz[y],mx=!fa?max(mx,siz[y]):0;
	}
}
int dp[N];
inline void dfs_zs(int x,int Siz,int &root){
	if(siz[x]^Siz)dp[x]=0;
	edge(x){
		int y=to[i];
		if(y^f[x]&&!vis[y])dfs_zs(y,Siz,root),dp[x]=max(dp[x],siz[y]);
	}
	dp[x]=max(dp[x],Siz-siz[x]-1);
	if(dp[x]<dp[root])root=x;
}
int bel[N];
inline void dfs_dep(int x,int fa,int id){
	bel[x]=id;
	edge(x){
		int y=to[i];
		if(y^fa)dep[y]=dep[x]+w[i],dfs_dep(y,x,id);
	}
}
int nx[N];
inline void solve(int root,int fr,int preans){//fr指上次的分治中心
	mx=0,dfs_siz(root,0),dp[root]=mx,dfs_zs(root,siz[root],root);
	int id=0,goal=0,ans=-inf;
	bel[root]=dep[root]=0;
	for(int i=h[root];i;i=nxt[i]){
		int y=to[i];
		dep[y]=w[i],dfs_dep(y,root,++id),nx[id]=y;//染色的同时记录对应子树的直接儿子
	}
	rep(i,1,m)val[i]=dep[l[i]]+dep[r[i]],ans=val[i]>ans?val[i]:ans;
	rep(i,1,m)if(val[i]==ans){
		if(bel[l[i]]^bel[r[i]])cout <<ans,exit(0);//不在同一子树
		if(goal&&goal^bel[l[i]])cout <<ans,exit(0);//出现矛盾
		goal=bel[l[i]];
	}
	vis[root]=1;
	if(nx[goal]==fr)cout <<min(ans,preans),exit(0);//如果直接儿子是上一个分治中心，输出两次答案最小值
	solve(nx[goal],root,ans);
}
int main(){
	for(int i=1,x,y,z;i^n;i++)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z);
	rep(i,1,m)l[i]=read(),r[i]=read();
	solve(1,0,inf);
	rt 0;
}
```


---

## 作者：lhm_ (赞：2)

考虑一个节点成为根节点后，如何判断其为最优的。

若最长距离的路径中的任意一条满足两个端点在当前根节点的两个不同的儿子中，则当前根节点为最优的。因为若将其调整为不在该路径上的点，最长路径的值会变大，将其调整为该路径上别的点，可能会产生更长的路径，因此该根节点为最优的。

若存在两条最长距离的路径的端点不来自同一个儿子，则当前根节点为最优的。这也是可以用调整来证明的。

因此可以考虑点分治，当前根节点若是最优的就直接结束分治，否则就到最长距离的路径端点对应的那个儿子中，以该子树的重心作为下次的分治中心。

```cpp
#include<bits/stdc++.h>
#define maxn 200010
#define inf 1000000000
using namespace std;
template<typename T> inline void read(T &x)
{
    x=0;char c=getchar();bool flag=false;
    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    if(flag)x=-x;
}
int n,m,ans=inf,root,tot,top;
int mx[maxn],siz[maxn],d[maxn],bel[maxn],st[maxn];
bool vis[maxn];
struct edge
{
    int to,nxt,v;
}e[maxn];
int head[maxn],edge_cnt;
void add(int from,int to,int val)
{
    e[++edge_cnt]={to,head[from],val},head[from]=edge_cnt;
}
struct query
{
    int x,y;
}q[maxn];
void dfs_root(int x,int fa)
{
    siz[x]=1,mx[x]=0;
    for(int i=head[x];i;i=e[i].nxt)
    {
        int y=e[i].to;
        if(vis[y]||y==fa) continue;
        dfs_root(y,x),siz[x]+=siz[y];
        mx[x]=max(mx[x],siz[y]);
    }
    mx[x]=max(mx[x],tot-siz[x]);
    if(mx[x]<mx[root]) root=x;
}
void dfs_dis(int x,int fa,int dis,int rt)
{
    bel[x]=rt,d[x]=dis;
    for(int i=head[x];i;i=e[i].nxt)
    {
        int y=e[i].to;
        if(y==fa) continue;
        dfs_dis(y,x,dis+e[i].v,rt);
    }
}
void solve(int x)
{
    vis[x]=true;
    for(int i=head[x];i;i=e[i].nxt)
        dfs_dis(e[i].to,x,e[i].v,e[i].to);
    int val=0,p;
    for(int i=1;i<=m;++i)
    {
        int v=d[q[i].x]+d[q[i].y];
        if(v>val) val=v,st[top=1]=i;
        else if(v==val) st[++top]=i;
    }
    ans=min(ans,val),p=bel[q[st[top]].x];
    if(vis[p]) return;
    for(int i=1;i<=top;++i)
    {
        int x=q[st[i]].x,y=q[st[i]].y;
        if(bel[x]!=bel[y]||bel[x]!=p) return;
    }
    root=0,tot=siz[p],dfs_root(p,x),solve(root);
}
int main()
{
    read(n),read(m);
    for(int i=1;i<n;++i)
    {
        int x,y,v;
        read(x),read(y),read(v);
        add(x,y,v),add(y,x,v);
    }
    for(int i=1;i<=m;++i) read(q[i].x),read(q[i].y);
    tot=mx[0]=n,dfs_root(1,0),solve(1),printf("%d",ans);
    return 0;
}
```

---

## 作者：moosssi (赞：2)

这道题一看就是点分治，但它和普通的点分治有点不一样，平常做的题，主要是考虑如何在每一层内快速统计答案，而这道题需我们确定当前点是否为最优解。

我们可以这样来考虑：首先，随便选一个点作为中心，暴力求出每条路径长度，并取最大值 $max$ ，如果有多个就一起存下来，在属于 $max$ 中的路径中有两种情况，要么经过这个点，要么没有。

如果有一条路径经过，这当前的 $max$ 就是答案，它没有更小的情况了，可以自行举例观察。

如果任意两条路径，都没经过当前节点, 并且在不同子树内， $max$ 也不会更小，你不能找出一种方案使两条路径距离都减小。

最后，满足所有路径都没经过中心且在一个子树内，就有可能有更小的答案，那么就找那个子树的重心作为中心，再执行之前的过程。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
int head[N],ver[N],net[N],edge[N],tot;
int n,m,s[N],d[N],ans=0x3f3f3f3f;
int f[N],dist[N],p[N];
bool st[N];
void add(int a,int b,int c){
	net[++tot]=head[a];
	head[a]=tot;
	ver[tot]=b;
	edge[tot]=c;
}
int get_siz(int x,int fa){//求子树大小 
	if(st[x])return 0;
	int res=1;
	for(int i=head[x];i;i=net[i]){
		int v=ver[i];
		if(v==fa)continue;
		res+=get_siz(v,x);
	}
	return res;
}
int get_wc(int x,int fa,int sum,int &wc){//求重心 
	if(st[x])return 0;
	int res=1,maxx=0;
	for(int i=head[x];i;i=net[i]){
		int v=ver[i];
		if(v==fa)continue;
		int t=get_wc(v,x,sum,wc);
		maxx=max(t,maxx);
		res+=t;
	}
	maxx=max(maxx,sum-res);
	if(maxx<=sum/2)wc=x;
	return res;
}
void get_dist(int x,int fa,int dis,int root){//预处理节点所属子树，和路径距离 
	dist[x]=dis;
	f[x]=root;
	for(int i=head[x];i;i=net[i]){
		int v=ver[i];
		if(v==fa)continue;
		get_dist(v,x,dis+edge[i],root);
	}
}
void calc(int x){//执行递归过程 
	if(st[x]){//防止死循环 
		printf("%d",ans);
		exit(0);
	}
	st[x]=1;
	dist[x]=0;
	for(int i=head[x];i;i=net[i]){
		int v=ver[i];
		get_dist(v,x,edge[i],v);
	}
	int maxx=0,pt=0;//p[]存的是路径距离为max的路径编号 
	for(int i=1;i<=m;i++){
		if(dist[s[i]]+dist[d[i]]>maxx){
			maxx=dist[s[i]]+dist[d[i]];
			pt=1,p[pt]=i;
		}
		else if(dist[s[i]]+dist[d[i]]==maxx){
			p[++pt]=i;
		}
	}
	ans=min(ans,maxx);
	int last=0;
	for(int i=1;i<=pt;i++){
		if(f[s[p[i]]]!=f[d[p[i]]]){//考虑之前说的第一种情况 
			printf("%d",ans);
			exit(0);
		}
		else{
			if(!last)last=f[s[p[i]]];
			else if(last!=f[s[p[i]]]){//第二种情况 
				printf("%d",ans);
				exit(0);
			}
		}
	}
	get_wc(last,x,get_siz(last,x),last);//找重心 
	calc(last);
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<n;i++){
		int a,b,c;
		scanf("%d%d%d",&a,&b,&c);
		add(a,b,c);
		add(b,a,c);
	}
	for(int i=1;i<=m;i++){
		scanf("%d%d",&s[i],&d[i]);
	}
	int root=1;
	get_wc(1,0,n,root);
	calc(root);
	printf("%d",ans);
	return 0;
}
```


---

## 作者：Mars_Dingdang (赞：1)

点分治好题。

## 题目大意
给定一棵树和 $m$ 个点对 $(x_i,y_i)$，求
$$\min_{u=1}^n\max_{i=1}^m\{dis(u,x_i)+dis(u,y_i)\}$$

$n,m\le 10^5$。

## 大体思路
做这道题之前可以先看看 [P7215](https://www.luogu.com.cn/problem/P7215)。

对于本题，考虑让当前分治中心作为枚举的中心点 $u$。暴力 dfs 计算出每个点到 $u$ 的距离 $dis_i$，然后对于所有的 $m$ 个点对，看最大值是多少。

假设取到最大距离的点对集合有 $M=\{i_1,i_2,\cdots,i_k\}$，则
- 如果存在 $i\in M$ 使得 $x_i\to y_i$ 的路径跨过了当前的分治中心 $u$，说明这个最大距离不可能更小（因为已经取到了 $dis(x_i,y_i)$，而 $dis(u,x_i)+dis(u,y_i)\ge dis(x_i,y_i)$）。

- 如果存在 $i,j\in M$ 使得 $x_i,x_j$ 位于**以** $u$ **为根的整棵树**的不同子树中时，使得 $i$ 的贡献减小必然使得 $j$ 的贡献增大，因此此时最大距离也不可能更小了。

对于上述两种情况，直接将当前答案作为最终答案输出即可。否则说明取到最大值的点对全部在 $u$ 的一棵子树里面，那么在这棵子树中枚举新的 $u$ 即可。枚举复杂度与子树大小有关，因此考虑点分治，每次以重心作为分治中心，这样枚举的层数至多是 $O(\log n)$ 层，每层中要求出所有 $n$ 个点到分治中心的距离，还要遍历 $m$ 个点对，复杂度为 $O(m+n)$。

因此总的时间复杂度为 $O((n+m)\log n)$。

注：**以 $u$ 为根的整棵树**是因为有些点可能落在当前分治块以外，这在一般的点分治题目如 P7215 中是不允许的。其时间复杂度：$T(n)=\sum T(sz_v)+O(N)$。因此 P7215 的性质使得如果当前分治块以外有关键点就寄了。

但本题每次只递归一个重心，$T(n)=T(\dfrac n 2)+O(N)$，故复杂度为单 $\log$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define rep(ii,aa,bb) for(re int ii = aa; ii <= bb; ii++)
#define Rep(ii,aa,bb) for(re int ii = aa; ii >= bb; ii--)
typedef long long ll;
typedef unsigned long long ull;
typedef double db;
typedef pair<int, int> PII;
const int maxn = 1e5 + 5;
template <typename T>
inline void chkmax(T &x, T y) {x = (x > y ? x : y);}
template <typename T>
inline void chkmin(T &x, T y) {x = (x < y ? x : y);}
namespace IO_ReadWrite {
	#define re register
	#define gg (p1 == p2 && (p2 = (p1 = _buf) + fread(_buf, 1, 1<<21, stdin), p1 == p2) ? EOF :*p1++)
	char _buf[1<<21], *p1 = _buf, *p2 = _buf;
	template <typename T>
	inline void read(T &x){
		x = 0; re T f=1; re char c = gg;
		while(c > 57 || c < 48){if(c == '-') f = -1;c = gg;}
		while(c >= 48 &&c <= 57){x = (x<<1) + (x<<3) + (c^48);c = gg;}
		x *= f;return;
	}
	inline void ReadChar(char &c){
		c = gg;
		while(!isalpha(c)) c = gg;
	}
	template <typename T>
	inline void write(T x){
		if(x < 0) putchar('-'), x = -x;
		if(x > 9) write(x/10);
		putchar('0' + x % 10);
	}
	template <typename T>
	inline void writeln(T x){write(x); putchar('\n');}
}
using namespace IO_ReadWrite;
int n, sz[maxn], f[maxn], rt, S, m;
PII a[maxn];
vector <PII> e[maxn];
bool vis[maxn];
inline void findrt(int u, int fa) {
	sz[u] = 1, f[u] = 0;
	for(auto [v, w] : e[u]) {
		if(v == fa || vis[v]) continue;
		findrt(v, u);
		sz[u] += sz[v];
		chkmax(f[u], sz[v]);
	}
	chkmax(f[u], S - sz[u]);
	if(f[u] < f[rt]) rt = u;
}
int dis[maxn], in[maxn], now, ans;
inline void dfs(int u, int fa) {
	in[u] = now;
	for(auto [v, w] : e[u]) {
		if(v == fa) continue;
		dis[v] = dis[u] + w;
		dfs(v, u);
	}
}
inline void solve(int u) {
	vis[u] = 1;
	set<int> st;
	auto calc = [&](int u) {
		dis[u] = 0;
		for(auto [v, w] : e[u]) {
//			if(vis[v]) continue;
			now = v;
			dis[v] = w;
			dfs(v, u);
		}
		int res = 0;
		rep(i, 1, m) {
			auto [x, y] = a[i];
			chkmax(res, dis[x] + dis[y]);
		}
		chkmin(ans, res);
		rep(i, 1, m) {
			auto [x, y] = a[i];
			if(dis[x] + dis[y] < res) continue;
			if(in[x] ^ in[y]) {
				writeln(ans);
				exit(0);
			}
			else st.insert(in[x]);
		}
	};
	calc(u);
	if(st.size() > 1) {
		writeln(ans);
		exit(0);
	}
	else if(st.size() == 1){
		int v = *st.begin();
		if(vis[v]) {
			writeln(ans);
			exit(0);			
		}
		S = sz[v], f[rt = 0] = n + 1;
		findrt(v, u);
		solve(rt);
	}
	else {
		writeln(ans);
		exit(0);
	}
}
int main () {
	read(n); read(m);
	rep(i, 1, n-1) {
		int u, v, w;
		read(u); read(v); read(w);
		e[u].emplace_back(v, w);
		e[v].emplace_back(u, w);
	}
	rep(i, 1, m) {
		int u, v;
		read(u), read(v);
		a[i] = {u, v};
	}
	ans = 2e9;
	S = n, f[rt = 0] = n + 1;
	findrt(1, 0);
	solve(rt);
	
	return 0;
}
```

---

## 作者：miao5 (赞：0)



先随便找一个点作为根，计算答案。

记录下来所有离根距离最大的点对。

分情况查看（其实是我自己一点一点拼凑出来的）：
 
- 如果目前的根在任意一对距离最大的点对上，那么答案就是一定的，不可能更优了。

- 如果有两个点对不在根的同一子树中，那么答案也不可能更优了。

- 如果所有距离最大的点对都在根的同一子树内，那么答案**可能**是可以增加的，向这个子树内递归处理即可。 

更新答案时一定要**取min**，因为**不一定**子树内的点就是更优的。 

code:

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
using namespace std;
const int MAXN=100010;
struct Edge{
	int nxt,to,dis;
}e[MAXN<<1];
int head[MAXN],num;
int x[MAXN],y[MAXN],vis[MAXN];
int maxson[MAXN],p[MAXN],q[MAXN];
int belong[MAXN],deep[MAXN],size[MAXN];
int n,m,root,maxn,ans=2147483647;
inline void add(int from,int to,int dis){
	e[++num].to=to;
	e[num].dis=dis;
	e[num].nxt=head[from];
	head[from]=num;
}
void g_e(int u,int fa,int all_){  
    size[u]=1;
	maxson[u]=0;
    for(int i=head[u];i;i=e[i].nxt){
    	if(e[i].to!=fa&&!vis[e[i].to]){
		    g_e(e[i].to,u,all_);
	        size[u]+=size[e[i].to];
            maxson[u]=max(maxson[u], size[e[i].to]);
        }
	} 
    maxson[u]=max(maxson[u],all_-size[u]);
    if(maxson[u]<maxn){
    	root=u;
		maxn=maxson[u];
	}
}
void dfs(int u,int fa,int dep,int rt){ 
    belong[u]=rt;
    deep[u]=dep;
    for(int i=head[u];i;i=e[i].nxt){
    	if(e[i].to!=fa) dfs(e[i].to,u,dep+e[i].dis,rt);
	}
}
void query(int u){
    if(vis[u]){
    	cout<<ans<<endl;
        exit(0);
    }      
    vis[u]=1;
    for(int i=head[u];i;i=e[i].nxt) dfs(e[i].to,u,e[i].dis,e[i].to);
    deep[u]=0;
    maxn=0; 
	p[0]=0;
    int last=0;
    for(int i=1;i<=m;i++){
    	if(deep[x[i]]+deep[y[i]]>maxn){
    		maxn=deep[x[i]]+deep[y[i]];
			p[p[0]=1]=i;
		}
        else if(deep[x[i]]+deep[y[i]]==maxn) p[++p[0]]=i;
	}
    ans=min(ans,maxn);   
    for(int i=1;i<=p[0];i++){
        if(belong[x[p[i]]]!=belong[y[p[i]]]){  
            cout<<ans<<endl;
            exit(0);
        }
        else{
        	if(!last) last=belong[x[p[i]]];
            else if(last!=belong[x[p[i]]]){  
                cout<<ans<<endl;
                exit(0);
            }
		} 
    }
    maxn=0x7fffffff;
    g_e(last,u,size[last]);
    query(root); 
}
int main(){
	cin>>n>>m; 
    for(int i=1;i<n;i++){
    	int a,b,c;
    	cin>>a>>b>>c;
        add(a,b,c); 
	    add(b,a,c);
    }
    for(int i=1;i<=m;i++) cin>>x[i]>>y[i];
    maxn=0x7fffffff; 
	g_e(1,0,n);
    query(root);
}
```


---

## 作者：_ctz (赞：0)

[安利$blog$](https://ctz45562.github.io/2019/08/27/洛谷-P4886-快递员/)

[传送门](https://www.luogu.org/problem/P4886)

介是你没有体验过的$chuan$新做法。

暴力点分治算出每个点作为中心时的答案。

对于路径$c\rightarrow u\rightarrow c\rightarrow v\rightarrow c$的长度除以$2$，我们可以看做$dis(u,v)+c$到路径$(u,v)$的距离乘$2$。

把路径分成两类：

经过分治中心的：

![]( https://cdn.luogu.com.cn/upload/pic/75315.png )

对于这种路径，$dfs$一遍树，当脱离了某条路径时，比如走边$(2,4)$或$(2,5)$，开始计算该路径的贡献。假设走边$(x,y)$脱离了该路径，则$y$子树内每个点$i$都会有$dis(i,x)\times 2+dis(u,v)$的贡献。

具体实现：给每条边维护一个权值$V$，对每条路径上的边的$V$对$dis(u,v)$取$\max$。算出每个点每条出边$V$的最大值和次大值。$dfs$时维护当前最大贡献$now$，对每个点，等于该点最大值的边选次小值更新$now$，否则选最大值，累加边权乘$2$即可。

这样会发现从根节点开始$dfs$时会出现这种情况：

![](https://cdn.luogu.com.cn/upload/pic/75316.png )

此时，红色路径和绿色路径为最大和次大。

由于一条路径可能会占据根节点的两条出边，维护最大值和次大值就出$bug$了。

这样我们直接维护一个堆把每条路径加进去，从根节点出发时把每条经过该点的路径删掉，统计完再加回去。

---

不经过分治中心的：

![](https://cdn.luogu.com.cn/upload/pic/75317.png )

把$(u,v)$的$lca$标记为关键点，并赋予一个权值$mx$为**所有标记它的点对中最大的$dis(u,v)$**。记$ma(i)$为$i$到其子树内所有关键点中（设关键点为$p$），最大的$mx(p)+dis(p,i)\times 2$。

转移很简单：$ma(i)=\max\{mx(i),\max\limits_{edge(i,j)}\{ma(j)+edge(i,j).l\times 2\}\}$

对根维护一个$ma1$和$ma2$表示根的儿子中最大和次大的$ma$。

$dfs$根的每个儿子$i$的子树，同样的，若$ma(i)=ma1$选$ma2$，否则选$ma1$为$now$，对每个点$j$的贡献就是$now+dis(root,j)\times 2$。

注意不用也不能在统计时进一步更新$now$了。

---

繁琐的细节：

分类路径时，可以巧妙运用$tarjan\ lca$。

处理边的$V$时，其实就是链取$\max$单点查。由于这些路径都**经过根节点**，直接对两端点取$\max$，统计子树最大值即可。

直接位于路径$(u,v)$的点算不上$(u,v)$的贡献，需要额外处理，可以在统计$V$时一块算，免去了树剖两个$\log$或$lct$的大常数。

由于一些神奇的原因，形如$(u,u)$的路径不会被算到，把$u$拆出来$u'$连上长为$0$的边，把路径改为$(u,u')$即可。

关于正确性：

如果一条路径经过根节点，就会统计上它对当前树内所有点的贡献。

否则会统计它对**和它不属于根节点同一个儿子的子树的节点**的贡献，然后分治它的子树。

我们就能把它对每个点的贡献算上。

关于复杂度：

随便想一想就会发现复杂度是$O((m+n)\log n)$的。

代码：

我的$priority\_queue$不知道为啥会在结束程序时炸掉于是~~抄~~手写的堆。

尽量精简了代码还是有$200+$行毕竟是暴力。

``` cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <vector>
#include <queue>

#define maxn 200005
#define inf 0x3f3f3f3f

using namespace std;

inline int read(){
	int x=0,y=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return y?-x:x;
}
namespace origin{
	int h[maxn],num;
	struct edge{
		int pre,to,l;
	}e[maxn<<1];
	inline void add(int from,int to,int l){
		e[++num].pre=h[from],h[from]=num,e[num].to=to,e[num].l=l;
		e[++num].pre=h[to],h[to]=num,e[num].to=from,e[num].l=l;
	}
}
int h[maxn],siz[maxn],top[maxn],son[maxn],deep[maxn],fa[maxn],F[maxn],qu[maxn][2],num,all,mx,root,cnt;
int ma1[maxn],ma2[maxn],ema1[maxn],ema2[maxn],ans[maxn],dis[maxn],ee[maxn],bl[maxn],sp[maxn];
vector<pair<int,int> >v[maxn];
vector<int>poi[maxn];
bool vis[maxn],ap[maxn];
struct heap{
	int H[maxn],heap_size;
	void push(int d){
		int now=++heap_size;
		H[heap_size]=d;
		while(now>1){
			if(H[now]<H[now>>1]) return;
			swap(H[now],H[now>>1]);
			now>>=1;
		}
	}
	void pop(){
		int now=1,next;
		H[1]=H[heap_size--];
		while((now<<1)<=heap_size){
			next=now<<1;
			if(next<heap_size&&H[next+1]>H[next]) next++;
			if(H[now]>H[next]) return;
			swap(H[now],H[next]);
			now=next;                      
		} 
	}
	bool empty(){return !(bool(heap_size));}
};
struct del_heap{
	heap q,d;
	void push(int x){q.push(x);}
	void del(int x){d.push(x);}
	void clear(){q.heap_size=d.heap_size=0;}
	int top(){
		while(!d.empty()&&q.H[1]==d.H[1])q.pop(),d.pop();
		if(q.empty())return -inf;
		return q.H[1];
	}
}q;
struct edge{
	int pre,to,l,v;
}e[maxn<<1];
int find(int x){
	if(F[x]==x)return x;
	return F[x]=find(F[x]);
}
inline void add(int from,int to,int l){
	e[++num].pre=h[from],h[from]=num,e[num].to=to,e[num].l=l,e[num].v=-inf;
}
void dfs1(int node=1){
	siz[node]=1;
	int x;
	for(register int i=h[node];i;i=e[i].pre){
		x=e[i].to;
		if(siz[x])continue;
		fa[x]=node,deep[x]=deep[node]+1,dis[x]=dis[node]+e[i].l;
		dfs1(x),siz[node]+=siz[x];
		if(siz[x]>siz[son[node]])son[node]=x;
	}
}
void dfs2(int node=1){
	vis[node]=1;
	if(son[node]){
		top[son[node]]=top[node],dfs2(son[node]);
		int x;
		for(register int i=h[node];i;i=e[i].pre){
			x=e[i].to;
			if(!vis[x])top[x]=x,dfs2(x);
		}
	}
}
inline int lca(int x,int y){
	while(top[x]!=top[y])deep[top[x]]<deep[top[y]]?y=fa[top[y]]:x=fa[top[x]];
	return deep[x]<deep[y]?x:y;
}
inline void check(int &m1,int &m2,int x){
	if(x>m1)m2=m1,m1=x;
	else if(x>m2)m2=x;
}
void getroot(int node,int f){
	int x,ma=0;
	for(register int i=h[node];i;i=e[i].pre){
		x=e[i].to;
		if(x==f||vis[x])continue;
		getroot(x,node),ma=max(ma,siz[x]);
	}
	ma=max(ma,all-siz[node]);
	if(ma<mx)mx=ma,root=node;
}
void init(int node,int f,int b){
	int x;
	bl[node]=b,ema1[node]=ema2[node]=ma1[node]=ma2[node]=-inf,ap[node]=1,F[node]=node;
	for(vector<pair<int,int> >::iterator iter=v[node].begin();iter!=v[node].end();++iter)
		if(ap[iter->first]){
			x=find(iter->first);
			if(x!=root)ma1[x]=max(ma1[x],iter->second);
			else {
				ee[iter->first]=max(ee[iter->first],iter->second),ee[node]=max(ee[node],iter->second);
				ma2[node]=max(ma2[node],iter->second),poi[b].push_back(iter->second);
				if(iter->first!=root)poi[bl[iter->first]].push_back(iter->second),ma2[iter->first]=max(ma2[iter->first],iter->second);
				q.push(iter->second);
			}
		}
	for(register int i=h[node];i;i=e[i].pre){
		x=e[i].to;
		if(x==f||vis[x])continue;
		init(x,node,b),F[x]=node,ma1[node]=max(ma1[node],ma1[x]+(e[i].l<<1));
	}
}
void calc(int node,int f,int now){
	siz[node]=1,ans[node]=max(ans[node],now);
	int x;
	for(register int i=h[node];i;i=e[i].pre){
		x=e[i].to;
		if(x==f||vis[x])continue;
		calc(x,node,max(e[i].v==ema1[node]?ema2[node]:ema1[node],max(now,ma2[node]))+(e[i].l<<1));
		siz[node]+=siz[x];
	}
}
void calc_edge_value(int node,int f){
	int x;
	for(register int i=h[node];i;i=e[i].pre){
		x=e[i].to;
		if(x==f||vis[x])continue;
		calc_edge_value(x,node);
		ee[node]=max(ee[node],ee[x]),check(ema1[node],ema2[node],e[i].v=ee[x]);
	}
	ans[node]=max(ans[node],ee[node]);
}
void clear(int node,int f){
	ap[node]=0,ee[node]=-inf;
	int x;
	for(register int i=h[node];i;i=e[i].pre){
		x=e[i].to;
		if(x==f||vis[x])continue;
		clear(x,node),e[i].v=-inf;
	}
}
void solve(int node){
	q.clear(),vis[node]=1;
	int x;
	ma1[node]=ma2[node]=-inf,F[node]=node,ap[node]=1,bl[node]=0;
	for(register int i=h[node];i;i=e[i].pre){
		x=e[i].to;
		if(vis[x])continue;
		init(x,node,x),F[x]=node,check(ma1[node],ma2[node],ma1[x]+(e[i].l<<1));
	}
	calc_edge_value(node,0);
	ans[node]=max(ans[node],ma1[node]);
	for(register int i=h[node];i;i=e[i].pre){
		x=e[i].to;
		if(vis[x])continue;
		for(register int j=0;j<poi[x].size();++j)q.del(poi[x][j]);
		calc(x,node,max((ma1[x]+(e[i].l<<1)==ma1[node]?ma2[node]:ma1[node]),q.top())+(e[i].l<<1));
		for(register int j=0;j<poi[x].size();++j)q.push(poi[x][j]);
		poi[x].clear();
	}
	clear(node,0);
	for(register int i=h[node];i;i=e[i].pre){
		x=e[i].to;
		if(vis[x])continue;
		mx=inf,all=siz[x],getroot(x,node),solve(root);
	}
}
void rebuild(int node=1,int f=0,int gf=0){
	int x;	
	if(node>all)for(register int i=h[node];i;i=e[i].pre){
		x=e[i].to;
		if(x==f)continue;
		rebuild(x,node,f);
	}
	else for(register int i=origin::h[node];i;i=origin::e[i].pre){
		x=origin::e[i].to;
		if(x==f||x==gf)continue;
		if(sp[x])add(node,sp[x],origin::e[i].l),add(sp[x],node,origin::e[i].l),add(sp[x],x,0),add(x,sp[x],0),x=sp[x];
		else add(node,x,origin::e[i].l),add(x,node,origin::e[i].l);
		rebuild(x,node,f);
	}
}
int DIS(int x,int y){
	return dis[x]+dis[y]-(dis[lca(x,y)]<<1);
}
int main(){
	memset(ee,~0x3f,sizeof ee);
	int n=all=read(),m=read(),k=n,x,y,z,res=inf;
	for(register int i=1;i<n;++i)x=read(),y=read(),z=read(),origin::add(x,y,z);
	for(register int i=1;i<=m;++i){
		qu[i][0]=x=read(),qu[i][1]=y=read();
		if(x==y&&!sp[x])sp[x]=++k,qu[i][1]=k;
	}
	if(sp[1])add(sp[1],1,0),add(1,sp[1],0);
	rebuild(1,sp[1]),dfs1(),dfs2();	
	for(register int i=1;i<=m;++i){
		x=qu[i][0],y=qu[i][1],z=dis[x]+dis[y]-(dis[lca(x,y)]<<1);
		v[x].push_back((pair<int,int>){y,z}),v[y].push_back((pair<int,int>){x,z});
	}
	memset(vis,0,sizeof vis);
	all=k,mx=inf,getroot(1,0),solve(root);
	for(register int i=1;i<=n;++i)res=min(res,ans[i]);
	printf("%d\n",res);
}
```



---


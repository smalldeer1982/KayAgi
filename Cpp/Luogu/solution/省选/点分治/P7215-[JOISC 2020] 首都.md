# [JOISC 2020] 首都

## 题目背景

JOI 国是一个庞大的国度。

## 题目描述

JOI 国拥有 $N$ 个城镇，编号为 $1$ 到 $N$，这些城镇由 $N-1$ 条双向道路连接。

JOI 国还拥有 $K$ 个城市，编号为 $1$ 到 $K$，第 $i$ 个城镇属于第 $C_i$ 个城市。

现在 JOI 国的总理 JOI 君 114514 世要挑选一个城市作为首都，从首都中的任一个城镇到达另一个首都中的城镇可以只经过首都中的城镇，但这明显是不合理的。

所以 JOI 君 114514 世要进行合并城市，合并城市 $x$ 和城市 $y$ 就会把城市 $y$ 里的所有小镇归为城市 $x$。

求能找到首都的最小合并次数。

## 说明/提示

#### 样例 1 解释

可以将城市 $1$ 和 $3$ 合并，然后选择城市 $1$ 作为首都。

#### 子任务

|子任务|特殊性质|分数|
|:-:|:-:|:-:|
|$1$|$N \le 20$|$1$|
|$2$|$N \le 2000$|$10$|
|$3$|每个城镇最多与两个城镇相连|$30$|
|$4$|无|$59$|

对于 $100\%$ 的数据，$1 \le K,u,v \le N \le 2 \times 10^5$，保证从任何一个城镇出发都能到达其他城镇，$1 \le C_i \le K$。

#### 说明

翻译自 [第１９回日本情報オリンピック　春季トレーニング合宿](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/index.html) [Day4 A 首都](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/day4/capital_city.pdf)。

## 样例 #1

### 输入

```
6 3
2 1
3 5
6 2
3 4
2 3
1
3
1
2
3
2```

### 输出

```
1```

## 样例 #2

### 输入

```
8 4
4 1
1 3
3 6
6 7
7 2
2 5
5 8
2
4
3
1
1
2
3
4```

### 输出

```
1```

## 样例 #3

### 输入

```
12 4
7 9
1 3
4 6
2 4
10 12
1 2
2 10
11 1
2 8
5 3
6 7
3
1
1
2
4
3
3
2
2
3
4
4```

### 输出

```
2```

# 题解

## 作者：一粒夸克 (赞：23)


## JOISC2020 首都

上课讲到了这题，口胡了一个树剖+线段树优化建图+缩点+拓扑排序的 $O(n$ $log^2$ $n)$的做法，下课后发现这种做法已经有人写过了。

那就再补一个 $zbk$ 的点分治做法。

### solution ：


与拓扑排序的做法相同，如果第 $i$ 个城市的两个城镇之间的路径经过了第 $j$ 个城市的一个小镇，那么我们如果想让第 $i$ 个城市连通，必须把 $i$ 和 $j$ 合并在一起。

那么我们对分治的每一层，我们假定要使分治中心所在的城市连通，然后不断将需要连通的节点放入队列中，当不再有新节点加入队列时，说明这些点已经连通了。

如果说遇到了一个需要连通的节点，但它不在当前子树内，直接退出即可。因为它在别的子树内，那么它到当前子树的路径会跨过上一层分治中心，因此在这层取得的答案不会比上一层更优。


### code ：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,rt;
int ver[400005],ne[400005],head[400005],cnt;
bool vis[200005],used[200005],vised[200005];
int col[200005],ans=1e9,tot;
inline void link(int x,int y){
	ver[++cnt]=y;
	ne[cnt]=head[x];
	head[x]=cnt;
}
int siz[200005],mxp[200005];
void find(int x,int fi,int tot){
	siz[x]=1;mxp[x]=0;
	for(int i=head[x];i;i=ne[i]){
		int u=ver[i];
		if(u==fi||vis[u])continue;
		find(u,x,tot);
		siz[x]+=siz[u];mxp[x]=max(mxp[x],siz[u]);
	}
	mxp[x]=max(mxp[x],tot-siz[x]);
	if(mxp[x]<mxp[rt])rt=x;
}
vector<int> vec[200005];
queue<int> q;
inline bool push(vector<int> &v){
	for(int i=0;i<v.size();i++){
		if(!used[v[i]])return 1;
		q.push(v[i]);
	}tot++;
	return 0;
}
int fa[200005];
void dfs1(int x,int fi){
	fa[x]=fi;
	for(int i=head[x];i;i=ne[i]){
		int u=ver[i];
		if(u==fi||vis[u])continue;
		dfs1(u,x);
	}
}
int stk[200005],top;
void del(int x,int fi){
	stk[top++]=x;used[x]=1;
	for(int i=head[x];i;i=ne[i]){
		int u=ver[i];
		if(u==fi||vis[u])continue;
		del(u,x);
	}
}
inline void calc(int x){
	tot=0;
	while(!q.empty())q.pop();
	vised[col[x]]=1;
	if(push(vec[col[x]]))return ;
	dfs1(x,x);
	while(!q.empty()){
		int u=q.front();q.pop();
		if(!vised[col[fa[u]]]){
			vised[col[fa[u]]]=1;
			if(push(vec[col[fa[u]]]))return ;
		}
	}
	ans=min(ans,tot);
}
void solve(int x){
	vis[x]=1;del(x,x);
	calc(x);
	while(top)--top,used[stk[top]]=vised[col[stk[top]]]=0;
	for(int i=head[x];i;i=ne[i]){
		int u=ver[i];
		if(vis[u])continue;
		rt=0;
		find(u,x,siz[u]);
		solve(rt);
	}
}
int main(){
	scanf("%d%d",&n,&k);
	for(int i=1;i<n;i++){
		int x,y;
		scanf("%d%d",&x,&y);
		link(x,y);link(y,x);
	}
	for(int i=1;i<=n;i++){
		scanf("%d",&col[i]);
		vec[col[i]].push_back(i);
	}
	mxp[rt=0]=n;
	find(1,1,n);
	solve(rt);
	printf("%d",ans-1);

	return 0;
}
```




---

## 作者：zghtyarecrenj (赞：15)

## JOISC2020 Day4 T1 Capital City

### 题意

有 $n$ 个小镇形成一棵树，第 $i$ 个小镇属于城市 $C_i$。要从城市里面选出一个首都，使得从首都中的任一个城镇到达另一个首都中的城镇可以只经过首都中的城镇。现在可能不存在这样的城市，所以求最少合并几个城市才能选出一个首都。

### 题解

考虑建图。若第 $i$ 个城市的小镇之间的路径经过第 $j$ 个城市的小镇，则我们连一条边 $(i,j)$。

在这张图中求出强连通分量，不难发现出度为 $0$ 的强连通分量的节点数最小值就是答案。

线段树优化建图+树剖+缩点不难解决。

```cpp
#include <bits/stdc++.h>

namespace zghtyarecrenj
{
	#define gc() getchar()
	template <typename Ty>
	inline void read(Ty &t)
	{
		t = 0; bool neg = 0; char ch = gc();
		while (ch != '-' && (ch < '0' || ch > '9')) ch = gc();
		if (ch == '-') neg = 1;
		do { t = t * 10 + ch - '0'; ch = gc(); } while (ch >= '0' && ch <= '9');
		if (neg) t = -t;
	}
} // namespace zghtyarecrenj

using zghtyarecrenj::read;

const int N = 2e5 + 5;
const int V = 1e6 + 5;

int k, n, c[N], pool, rt;
std::vector<int> g[N], G[V], a[N];
int dep[N], anc[N], siz[N], son[N], seg[N], rev[N], top[N], scnt;
int dfn[V], low[V], vis[V], res[V], cnt, sz[V], du[V], tot;
std::stack<int> s;

struct Node
{
	int L, R, ls, rs;
} T[N << 2];

int build(int l, int r)
{
	int k = ++pool;
	T[k].L = l, T[k].R = r;
	if (l == r)
	{
		G[k].push_back(c[rev[l]]);
		return k;
	}
	int mid = (l + r) / 2;
	T[k].ls = build(l, mid);
	T[k].rs = build(mid + 1, r);
	G[k].push_back(T[k].ls);
	G[k].push_back(T[k].rs);
	return k;
}

void add(int k, int x, int y, int d)
{
	if (x <= T[k].L && T[k].R <= y)
	{
		G[d].push_back(k);
		return;
	}
	int mid = (T[k].L + T[k].R) / 2;
	if (x <= mid)
		add(T[k].ls, x, y, d);
	if (y > mid)
		add(T[k].rs, x, y, d);
}

void dfs1(int u, int fa)
{
	dep[u] = dep[fa] + 1, anc[u] = fa, siz[u] = 1;
	for (int v : g[u])
		if (v != fa)
		{
			dfs1(v, u);
			siz[u] += siz[v];
			if (siz[v] > siz[son[u]])
				son[u] = v;
		}
}

void dfs2(int u, int tp)
{
	top[u] = tp, seg[u] = ++scnt, rev[scnt] = u;
	if (son[u]) dfs2(son[u], tp);
	for (int v : g[u])
		if (v != anc[u] && v != son[u])
			dfs2(v, v);
}

inline int lca(int u, int v)
{
	while (top[u] != top[v])
	{
		if (dep[top[u]] < dep[top[v]]) 
			std::swap(u, v);
		u = anc[top[u]];
	}
	return dep[u] < dep[v] ? u : v;
}

void modify(int u, int v)
{
	int cx = c[u];
	while (top[u] != top[v])
	{
		if (dep[top[u]] < dep[top[v]])
			std::swap(u, v);
		add(rt, seg[top[u]], seg[u], cx);
		u = anc[top[u]];
	}
	if (dep[v] > dep[u])
		std::swap(u, v);
	add(rt, seg[v], seg[u], cx);
}

void tarjan(int u)
{
	dfn[u] = low[u] = ++tot, vis[u] = 1, s.push(u);
	for (int v : G[u])
	{
		if (dfn[v] == -1)
		{
			tarjan(v);
			low[u] = std::min(low[u], low[v]);
		}
		else if (vis[v])
			low[u] = std::min(low[u], dfn[v]);
	}
	if (dfn[u] == low[u])
	{
		++cnt;
		while (1)
		{
			int cur = s.top(); s.pop();
			vis[cur] = 0, res[cur] = cnt;
			if (u == cur) break;
		}
	}
}

int main()
{
	read(n), read(k);
	for (int i = 1; i < n; ++i)
	{
		int x, y;
		read(x), read(y);
		g[x].push_back(y), g[y].push_back(x);
	}
	for (int i = 1; i <= n; ++i)
		read(c[i]), a[c[i]].push_back(i);
	pool = k;
	dfs1(1, 0);
	dfs2(1, 1);
	rt = build(1, n);
	for (int i = 1; i <= k; ++i)
		if (a[i].size() > 1)
		{
			int m = a[i][0];
			for (int j = 1; j < a[i].size(); ++j)
			{
					int l = lca(a[i][0], a[i][j]);
					if (a[i][j] != l) 
						modify(a[i][j], l);
					if (dep[l] < dep[m])
						m = l;
			}
			if (a[i][0] != m)
				modify(a[i][0], m);
		}
//	for (int i = 1; i <= pool; ++i)
//	{
//		printf("%d:\n", i);
//		for (int j : G[i]) printf("%d ", j); printf("\n");
//	}
	memset(dfn, -1, sizeof(dfn));
	for (int i = 1; i <= pool; ++i)
		if (dfn[i] == -1)
			tarjan(i);
	for (int i = 1; i <= k; ++i) 
		++sz[res[i]];
	for (int i = 1; i <= pool; ++i)
		for (int j : G[i])
			if (res[i] != res[j]) ++du[res[i]];
	int ans = 2e9;
	for (int i = 1; i <= k; ++i)
		if (!du[res[i]]) ans = std::min(ans, sz[res[i]] - 1);
	printf("%d\n", ans);
	return 0;
}
```



---

## 作者：_Diu_ (赞：11)

我校模拟赛一场搬了这个题，非常高兴赛时过了。

非常优美的点分治做法。

先想个暴力，我们枚举每个点，统计包含每个点 $u$ 的颜色数量最少的连通块。一个很朴素的做法就是以这个点为根搜一次，建立一个颜色队列，首先把该点的颜色入队，每次弹出一个颜色，把所有是这个颜色的点遍历一次，每次从这个点往父亲跳，如果出现新颜色就把它入队，如果出现已经遍历过的点说明它网上的点都遍历过了，就直接跳。

分析复杂度每次是 $O(n)$ 的，总时间是 $O(n^2)$ 的。

我们可以放到点分治上维护这个操作，每次以当前分治中心为枚举的点，不过如果在枚举过程中出现当前连通块外的点就直接结束，因为如果经过外面的点，那么相当于经过了某一级分治祖先，那么那级的颜色队列一定会被当前的遍历包含，要么相同，要么更劣，所以直接不用考虑。

发现每一次统计答案的时间复杂度最劣是 $O(点数)$ 的，总时间复杂度 $O(n\log n)$。

统计答案部分的代码：

```cpp
void get_ans(int u){
	if(!c[u])return;
	dep[u]=1,fa[u]=0;
	get_fa(u,u);
	st[tp=1]=c[u],vic[c[u]]=u;
	for(int k=1;k<=tp;k++){
//		printf("Col:%d\n",st[k]);
		for(int i=0;i<g[st[k]].size();i++){
			int v=g[st[k]][i];
			if(Vis[v]!=u)return;
			while(dep[v]){
				if(!c[v])return;
				if(vic[c[v]]!=u)vic[c[v]]=u,st[++tp]=c[v];
//				printf("Find:%d\n",v);
				dep[v]=0,v=fa[v];
			}
		}
	}
	ans=min(ans,tp-1);
//	printf("%d\n",tp-1);
}
```


---

## 作者：xht (赞：8)

答案相当于要找到一个包含颜色最少的连通块，满足连通块内的颜色和连通块外的颜色两两不同，我们称这样的连通块为**合法**连通块。

考虑点分治，对于每一次点分出来的重心和连通块，我们在连通块中找到最小的包含重心的合法连通块，用这个连通块的答案去更新答案。

这样，最优解一定会被更新到，时间复杂度 $\mathcal O(n \log n)$。

```cpp
const int N = 2e5 + 7;
int n, m, a[N], c[N], ans, f[N], s[N], rt, mn;
vi e[N], b[N], p;
bool u[N], v[N], w[N];

void getrt(int x, int S) {
	v[x] = 1, s[x] = 1;
	if (!b[a[x]].size()) p.pb(a[x]);
	b[a[x]].pb(x); 
	int o = 0;
	for (int y : e[x])
		if (!v[y] && !w[y]) getrt(y, S), s[x] += s[y], o = max(o, s[y]);
	o = max(o, S - s[x]);
	if (o < mn) rt = x, mn = o;
	v[x] = 0;
}

void dfs(int x) {
	v[x] = 1, s[x] = 1;
	for (int y : e[x])
		if (!v[y] && !w[y]) f[y] = x, dfs(y), s[x] += s[y];
	v[x] = 0;
}

void solve(int x, int S) {
	rt = x, mn = S, f[x] = 0, getrt(x, S), dfs(rt);
	queue<int> q;
	q.push(a[rt]), u[a[rt]] = 1, v[rt] = 1;
	int cnt = 0;
	bool ok = (int)b[a[rt]].size() == c[a[rt]];
	while (ok && q.size()) {
		int x = q.front();
		q.pop();
		for (int y : b[x])
			while (!v[y]) {
				v[y] = 1;
				if (!u[a[y]]) {
					if ((int)b[a[y]].size() != c[a[y]]) ok = 0;
					q.push(a[y]), u[a[y]] = 1, ++cnt;
				}
				y = f[y];
			}
	}
	if (ok) ans = min(ans, cnt);
	for (int x : p) {
		for (int y : b[x]) v[y] = 0;
		b[x].clear(), u[x] = 0;
	}
	p.clear();
	w[rt] = 1;
	int now = rt;
	for (int nxt : e[now])
		if (!w[nxt]) solve(nxt, s[nxt]);
}

int main() {
	rd(n), rd(m), ans = m;
	for (int i = 1, x, y; i < n; i++)
		rd(x), rd(y), e[x].pb(y), e[y].pb(x);
	for (int i = 1; i <= n; i++) rd(a[i]), ++c[a[i]];
	solve(1, n), print(ans);
	return 0;
}
```

---

## 作者：_LPF_ (赞：7)

PKUSC 之前发篇题解涨涨 RP，和已有的点分治的思考方向貌似不同。

> 给定树上每个点所属的城市，要求选则尽量少的城市，使得这些城市所有归属节点的并为一个树上连通块。

主要思路来源于链的部分分。发现可以分治做，每次钦定 $\text{mid}$ 所属城市为连通块中必选的城市。

因为跨过分治中心的点必须选它，也就必须选它所属的城市。然后实现一个 `expand` 函数不断扩展。

每个城市只会被扩展一次，每次扩展枚举城市中的所有点，并把该点到 $\text{mid}$ 的区间内的点都选择上，这是题意使然。

实现时采用单点取消来限制，如果一种城市的点跨过了当前分治中心，那么就把它取消掉。

这种城市显然不可能作为答案决策了，而 expand 合法的充要也恰恰是不会 expand 到被取消的点。

类似这样：

```cpp
bool vis[N], lim[N], used[N];
int ans, cur;

bool expand(int col, int mid) {
	vector<int> nxt;

	for(int o : vec[col])
		if(o <= mid) {
			int p = o;
			while(p <= mid) {
				if(vis[p]) break;

				vis[p] = true;
				if(lim[c[p]]) return false;
				else if(! used[c[p]]) nxt.push_back(c[p]), used[c[p]] = true, cur ++;
				p ++;
			}
		}
		else {
			int p = o;
			while(p > mid) {
				if(vis[p]) break;
				
				vis[p] = true;
				if(lim[c[p]]) return false;
				else if(! used[c[p]]) nxt.push_back(c[p]), used[c[p]] = true, cur ++;
				p --;
			}
		}

	for(int o : nxt) if(! expand(o, mid)) return false;
	return true;
}

void solve(int l, int r) {
	if(l == r) {if(vec[c[l]].size() == 1) ans = 0; return;}
	int mid = (l + r) >> 1;
	if(! lim[c[mid]]) {
		used[c[mid]] = true, cur = 1;
		if(expand(c[mid], mid)) ans = min(ans, cur - 1);
		per(i, mid, l) vis[i] = false, used[c[i]] = false;
		rep(i, mid + 1, r) vis[i] = false, used[c[i]] = false;
	}
	rep(i, l, mid) if(las[c[i]] > mid) lim[c[i]] = true;
	solve(l, mid);
	solve(mid + 1, r);
}
```

把链转到树上实际上更简单，直接点分治，然后每次强制选根，类似上面的 expand 过程即可。

实际上链到树的转换还一时糊涂，以为是钦定某个直接儿子为决策，然后想了半天以为树上不可做，然后才发现有个根是必选的（

还有一种硬上线段树优化建图 + 缩点的科技感浓浓的方法，感觉上没有点分治优美。

```cpp
const int N = 2e5 + 10;
int n, k, c[N], ans;
vector<int> G[N], vec[N];

int Rt, Mx, siz[N], mxp[N];
bool vis[N];

void dfsRt(int u, int fa) {
	siz[u] = mxp[u] = 1;
	for(int v : G[u]) if(v != fa && ! vis[v])
		dfsRt(v, u), 
		siz[u] += siz[v], 
		mxp[u] = max(mxp[u], siz[v]);
	mxp[u] = max(mxp[u], Mx - siz[u]);
	if(! Rt || mxp[u] < mxp[Rt]) Rt = u;
}

int cur, fa[N], blo[N];
bool lim[N], exd[N], used[N];

void dfsFa(int u, int Fa) {
	fa[u] = Fa, blo[c[u]] = 0;
	for(int v : G[u]) if(v != Fa && ! vis[v]) dfsFa(v, u);
}

vector<int> arc;

bool expand(int col) {
	vector<int> nxt;
	for(int o : vec[col]) {
		int p = o;
		while(p) {
			if(exd[p]) break; exd[p] = true, arc.push_back(p);
			if(lim[c[p]]) return false;
			else if(! used[c[p]]) used[c[p]] = true, cur ++, nxt.push_back(c[p]);
			p = fa[p];
		}
	}
	for(int o : nxt) if(! expand(o)) return false;
	return true;
}

void dfsCr(int u, int Fa, int top) {
	if(blo[c[u]] && blo[c[u]] != top) lim[c[u]] = true;
	blo[c[u]] = top, siz[u] = 1;

	for(int v : G[u]) if(v != Fa && ! vis[v]) dfsCr(v, u, top), siz[u] += siz[v];
}

void calc(int u) {
	if(lim[c[u]]) return;
	if(vec[c[u]].size() == 1) {ans = 0; return;}
	
	fa[u] = 0;
	for(int v : G[u]) if(! vis[v]) dfsFa(v, u);
	cur = 1, used[c[u]] = true;

	if(expand(c[u])) ans = min(ans, cur - 1);
	lim[c[u]] = true;
	for(int v : G[u]) if(! vis[v]) dfsCr(v, u, v);
	for(int v : arc) exd[v] = used[c[v]] = false;
	arc.clear();
}

void solve(int u) {
	vis[u] = true, calc(u);
	for(int v : G[u]) if(! vis[v])
		Rt = 0, Mx = siz[v], dfsRt(v, u), solve(Rt);
}

int main() {
	n = read(), k = read();
	rep(i, 2, n) {
		int u = read(), v = read();
		G[u].push_back(v);
		G[v].push_back(u);
	}
	rep(i, 1, n) c[i] = read(), vec[c[i]].push_back(i);
	ans = n;
	Rt = 0, Mx = n, dfsRt(1, 0), solve(Rt);
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：未来姚班zyl (赞：6)

## 题目大意

在一颗树上，每个点有一个点权，你的任务是选出一个最小的非空集合 $S$，使得所有点权属于 $S$ 的点属于同一个连通块内。

## 题目分析

首先不难想出一个 $O(n^2)$ 的暴力。我们依次钦定每个点为根，并且该点的权值在集合内。然后开始模拟：将被选的点加入一个队列，并不断地判断：弹出队首，如果当前点的父亲没有被选，则加入该点点权，并将所有对应的点入队。直到队列为空。正确性显然，因为我们每次都选择了必须选择的点。

问题在于，我们没有考虑点与点之间的可利用关系。

考虑贪心。

按照暴力的方法，对于以 $x$ 为根时的答案，一定不劣于以其它点为根时选了 $x$ 的方案。否则，以 $x$ 为根时就肯定能找到这样的方案。

这样就可以转换为点分治的板子了。复杂度 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define per(x,y,z) for(int x=(y);x>=(z);x--)
#define pb push_back
#define ull unsigned ll
#define e(x) for(int i=h[x],y=to[i];i;i=nxt[i],y=to[i])
#define E(x) for(auto y:p[x])
#define Pi pair<int,int>
#define ui unsigned ll
inline int read(){int s=0,w=1;char c=getchar();while(c<48||c>57) {if(c=='-') w=-1;c=getchar();}while(c>=48&&c<=57) s=(s<<1)+(s<<3)+c-48,c=getchar();return s*w;}
inline void pf(ll x){if(x<0) putchar('-'),x=-x;if(x>9)pf(x/10);putchar(x%10+48);}
const int N =2e5+5,M=1e6+5,inf=2147000000;
const double eps=1e-6;
const ll mod=1e9+7,llf=1e18;
const ui base=13331;
using namespace std;
int ans,n,k,h[N],to[N<<1],nxt[N<<1],cnt,c[N];
vector<int>p[N];
inline void add(int a,int b){
	to[++cnt]=b,nxt[cnt]=h[a],h[a]=cnt;
}
int siz[N],f[N],bel[N],fr[N];
bool vis[N];
inline void dfs(int x,int fa){
	siz[x]=1;
	e(x)if(y^fa&&!vis[y])dfs(y,x),siz[x]+=siz[y];
}
inline void Dfs(int x,int fa,int Siz,int &root){
	f[x]=0;
	e(x)if(y^fa&&!vis[y])f[x]=max(f[x],siz[y]),Dfs(y,x,Siz,root);
	f[x]=max(f[x],Siz-f[x]-1);
	if(f[x]<=f[root])root=x;
}
inline void dFs(int x,int fa,int root){
	fr[x]=fa,bel[x]=root;
	e(x)if(!vis[y]&&y^fa)dFs(y,x,root);
}
bool v[N];
int s[N],top,ct;
inline void sol(int root){
	while(top)v[s[top--]]=0;
	queue<int>q;
	ct=0;
	for(auto y:p[c[root]])if(bel[y]^root)return;
	else q.push(y),v[y]=1,s[++top]=y;
	int now=0;
	while(!q.empty()){
		int x=q.front();
		q.pop();
		if(x==root)continue;
		if(!v[fr[x]]){
			for(auto y:p[c[fr[x]]])if(bel[y]^root)return;
			else v[y]=1,s[++top]=y,q.push(y);
			now++;
		}
	}
	ans=min(ans,now);
	return;
		
}
inline void solve(int x){
	int root=0;f[0]=inf;
	dfs(x,0),Dfs(x,0,siz[x],root),dFs(root,0,root);
	sol(root);
	vis[root]=1;
	e(root)if(!vis[y])solve(y);
}
int main(){
	n=read(),k=read();
	for(int i=1,x,y;i^n;i++)x=read(),y=read(),add(x,y),add(y,x);
	rep(i,1,n)c[i]=read(),p[c[i]].pb(i);
	ans=k-1; 
	solve(1);
	cout <<ans;
	return 0;
}
```


---

## 作者：CQ_Bab (赞：5)

# 前言
这道题是老师拉到点分治题单中的，可是我却一眼就出了另一个做法。
# 思路
首先对于这道题可以发现如果一个颜色如果仅需要依靠另一种颜色而一次这样下去最后一个颜色也仅需要第一个颜色，那么这样的话就能只将这些合并起来即可。所以我们可以将这种状态转移成建边的形式，如果对于两种颜色 $x$ 和 $y$ 如果 $x$ 依靠 $y$ 则连一条边 $x\to y$，然后只需要找一个包含颜色且环中颜色数量最少的即可。

- 我们发现对于连边操作，是一个点向一段区间连边所以可以用树链剖分，然后从 $i$ 向 $l\sim r$ 连边即可，这里其实可以用线段树优化建边解决。
- 对于同一个颜色中，可以发现我们需要把每两个点经过的路径都被 $i$ 种颜色连边，但是这样暴力的话是 $n^2$ 的所以我们可以对于每一个点的 dfs 序进行排序然后只需要对于两两之间连边即可。
# 代码
```cpp
#include <bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
#include <ext/rope>
using namespace __gnu_pbds;
using namespace std;
#define int long long
#define pb push_back
#define rep(i,x,y) for(register int i=x;i<=y;i++)
#define rep1(i,x,y) for(register int i=x;i>=y;--i)
#define in(x) scanf("%lld",&x)
#define fire signed
#define il inline
il void print(int x) {
	if(x<0) putchar('-'),x=-x;
	if(x>=10) print(x/10);
	putchar(x%10+'0');
}
int T=1;
int n,k;
const int N=2e5+10,M=1e6+10;
vector<int>v[M],ve[M];
int c[M],dfn[M],low[M],idx,val[M],chu[M];
stack<int>s;
int sum;
int is[M],tot,siz1[M];
void tarjan(int x) {
	dfn[x]=low[x]=++idx;
	s.push(x);
	is[x]=1;
	for(auto to:ve[x]) {
		if(!dfn[to]) {
			tarjan(to);
			low[x]=min(low[x],low[to]);
		}else if(is[to]) low[x]=min(low[x],dfn[to]);
	}
	if(low[x]==dfn[x]) {
		int p;
		tot++;
		do{
			p=s.top();
			s.pop();
			is[p]=false;
			val[p]=tot;
			siz1[tot]+=(p<=k);
		}while(p!=x);
	}
}
int dui[M];
int son[M],siz[M],dep[M],fa[M],top[M];
void dfs(int x,int f) {
	siz[x]=1;
	fa[x]=f;
	dep[x]=dep[f]+1;
	int Max=false;
	for(auto to:v[x]) {
		if(to==f) continue;
		dfs(to,x);
		if(siz[to]>Max) {
			Max=siz[to];
			son[x]=to;
		}
		siz[x]+=siz[to];
	}
}
int dfn1[N],cnt;
void dfs1(int x,int h) {
	top[x]=h;
	dfn1[x]=++cnt;
	dui[cnt]=c[x];
	if(!son[x]) return ;
	dfs1(son[x],h);
	for(auto to:v[x]) if(!dfn1[to]) dfs1(to,to);
}
struct node{
	int l,r;
}tr[M];
void add(int x,int y) {
	sum=max({sum,x,y});
	ve[x].push_back(y);
}
vector<int>co[N];
void build(int u,int l,int r) {
	tr[u]={l,r};
	if(l==r) {
		add(u+k,dui[l]);
		return ;
	}
	int mid=l+r>>1;
	add(u+k,2*u+k);
	add(u+k,u*2+1+k);
	build(u<<1,l,mid);
	build(u<<1|1,mid+1,r);
}
void modify(int u,int l,int r,int k1) {
	if(tr[u].l>=l&&tr[u].r<=r) {
		add(k1,u+k);
		return ;
	} 
	int mid=tr[u].l+tr[u].r>>1;
	if(mid>=l) modify(u<<1,l,r,k1);
	if(mid<r) modify(u<<1|1,l,r,k1);
}
int arr[M];
bool cmp(int a,int b) {
	return dfn1[a]<dfn1[b];
}
void get(int x,int y,int k1) {
	while(top[x]!=top[y]) {
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		modify(1,dfn1[top[x]],dfn1[x],k1);
		x=fa[top[x]];
	}
	if(dfn1[x]>dfn1[y]) swap(x,y);
	modify(1,dfn1[x],dfn1[y],k1);
}
void solve() {
	in(n),in(k);
	rep(i,1,n-1) {
		int x,y;
		in(x),in(y);
		v[x].push_back(y);
		v[y].push_back(x);
	}
	rep(i,1,n) in(c[i]),co[c[i]].push_back(i);
	dfs(1,0);
	dfs1(1,1);
	build(1,1,n);
	rep(i,1,k) {
		int cc=false;
		for(auto to:co[i]) arr[++cc]=to;
		sort(arr+1,arr+1+cc,cmp);
		rep(j,1,cc-1) get(arr[j],arr[j+1],i);
	}
	rep(i,1,sum) if(!dfn[i]) tarjan(i);
	rep(i,1,sum) for(auto to:ve[i]) if(val[i]!=val[to]){
		chu[val[i]]++;
		break;
	} 
	int res=LONG_LONG_MAX;
	rep(i,1,tot) if(!chu[i]&&siz1[i]!=0) res=min(res,siz1[i]-1);
	print(res);
	return;
}
fire main() {
	while(T--) {
		solve();
	}
	return false;
}
```

---

## 作者：Aigony (赞：4)

深刻地认识到自己根本没学会点分治。

考虑朴素的暴力怎么做：枚举一个点作为根，考虑求出令这个点的颜色全部连通所需要的最少合并次数。维护一个队列，每次将队首的父亲塞进队列，如果这使得队列里出现了一个新颜色，则将这个颜色的所有点塞进队列。记录过程中访问过的颜色个数，单次复杂度线性，总复杂度 $\mathcal{O}(n^2)$。

贪心，发现有这样一条神奇的性质：如果以 $y$ 为根时选到了颜色 $x$，则以 $x$ 为根的答案一定不会更劣。

换句话说：如果我们在统计点 $x$ 时发现要选颜色 $y$，但我们已经知道了以 $y$ 为根的答案，则无需继续统计这个 $x$。

考虑点分治。对于每个分治重心，我们只考虑它子树内的答案。如果有与根同色却不在子树内的点存在，这代表着更优的答案已经在之前的分治过程中被统计，满足上述情况，可以直接舍掉。

时间复杂度 $\mathcal{O}(n\log n)$。

```cpp
const int N=2e5+5,inf=1e9;
int n,m,col[N];
vector<int> e[N],t[N];
int S,rt,vis[N],ans=inf,siz[N],fa[N];
int in[N],mx[N],Vs[N],vc[N];
void getrt(int u,int ff)
{
    siz[u]=1,fa[u]=ff; mx[u]=0;
    for(auto v:e[u]) if((v^ff)&&!vis[v])
    {
        getrt(v,u);
        mx[u]=max(mx[u],siz[v]);
        siz[u]+=siz[v];
    }
    mx[u]=max(mx[u],S-siz[u]);
    if(mx[u]<mx[rt]) rt=u;
}
queue<int> q;
void dfs(int u,int ff,int qwq)
{
    Vs[u]=qwq,in[u]=0,fa[u]=ff;
    for(auto v:e[u]) if(v!=ff&&!vis[v]) dfs(v,u,qwq);
} 
il int calc(int u)
{
    dfs(u,0,u);
    queue<int> q; q.push(u),in[u]=1;
    int res=0;
    while(!q.empty())
    {
        int x=q.front(); q.pop();
        if(x!=u&&!in[fa[x]]) in[fa[x]]=1,q.push(fa[x]);
        if(vc[col[x]]==u) continue;
        res++,vc[col[x]]=u;
        for(auto v:t[col[x]]) 
        {
            if(Vs[v]!=u) return inf;
            if(!in[v]) in[v]=1,q.push(v);
        }
    }
    return res;
}
void solve(int u)
{
    vis[u]=1; ans=min(ans,calc(u));
    for(auto v:e[u]) if(!vis[v])
    {
        getrt(v,0),S=siz[v],rt=0; getrt(v,0);
        solve(rt);
    }
}   
int main()
{
    n=read(),m=read();
    for(int i=1;i<n;i++)
    {
        int u=read(),v=read();
        e[u].push_back(v),e[v].push_back(u);
    }
    for(int i=1;i<=n;i++) col[i]=read(),t[col[i]].push_back(i);
    S=n,mx[0]=inf,rt=0; getrt(1,0);
    solve(rt);
    printf("%d\n",ans-1);
    return 0;
}
```

---

## 作者：cwfxlh (赞：3)

# [P7215](https://www.luogu.com.cn/problem/P7215)     

涉及到连通性，所以考虑使用点分治来求解。每次点分治的时候，钦定分治中心所在的节点是连通的，计算这种颜色的连通块大小。发现一个性质，如果有相同颜色但在当前分治子树外的点，则连通块必定包含上一层分治中心，而这样的贡献已经在上一层被计算了。所以点分治的时候只需要考虑当前分治子树内的点就可以了。每个点只会被扩展一次，于是扩展的复杂度是 $O(siz)$，总复杂度 $O(n\log n)$。   

代码：   

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,c[500003],num[500003],rt,sz[500003],F[500003],mx[500003],sumsz,mk[500003],ans,k1,k2,k3,k4,k5,k6,k7,k8,k9;
int stk[500003],tot,cs[500003];
vector<int>E[500003];
vector<int>lst[500003];
void get_rt(int now,int p){
	sz[now]=1;
	mx[now]=0;
	for(auto i:E[now]){
		if(i==p||mk[i])continue;
		get_rt(i,now);
		mx[now]=max(mx[now],sz[i]);
		sz[now]+=sz[i];
	}
	mx[now]=max(mx[now],sumsz-sz[now]);
	if(rt==-1||mx[now]<mx[rt])rt=now;
	return;
}
void dfs1(int now,int p){
	lst[c[now]].emplace_back(now);
	F[now]=p;
	for(auto i:E[now]){
		if(i==p||mk[i])continue;
		dfs1(i,now);
	}
	return;
}
void dfs2(int now,int p){
	lst[c[now]].clear();
	lst[c[now]].shrink_to_fit();
	sz[now]=1;
	for(auto i:E[now]){
		if(i==p||mk[i])continue;
		dfs2(i,now);
		sz[now]+=sz[i];
	}
	return;
}
void dfz(int now){
	lst[c[now]].emplace_back(now);
	mk[now]=1;
	for(auto i:E[now]){
		if(mk[i])continue;
		dfs1(i,now);
	}
	F[now]=0;
	stk[tot=1]=c[now];
	cs[c[now]]=1;
	for(int i=1;i<=tot;i++){
		for(auto j:lst[stk[i]]){
			k2=F[j];
			while(k2){
				if(cs[c[k2]]==1)break;
				stk[++tot]=c[k2];
				cs[c[k2]]=1;
				k2=F[k2];
			}
		}
	}
	for(int i=1;i<=tot;i++)cs[stk[i]]=0;
	for(int i=1;i<=tot;i++){
		if(num[stk[i]]!=lst[stk[i]].size())break;
		if(i==tot){
			ans=min(ans,tot);
		}
	}
	lst[c[now]].clear();
	lst[c[now]].shrink_to_fit();
	for(auto i:E[now]){
		if(mk[i])continue;
		dfs2(i,now);
	}
	for(auto i:E[now]){
		if(mk[i])continue;
		rt=-1;
		sumsz=sz[i];
		get_rt(i,0);
		dfz(rt);
	}
	return;
}
int main(){
	scanf("%d%d",&n,&k);
	ans=k;
	for(int i=1;i<n;i++){
		scanf("%d%d",&k1,&k2);
		E[k1].emplace_back(k2);
		E[k2].emplace_back(k1);
	}
	for(int i=1;i<=n;i++){
		scanf("%d",&c[i]);
		num[c[i]]++;
	}
	rt=-1;
	sumsz=n;
	get_rt(1,0);
	dfz(rt);
	printf("%d",ans-1);
	return 0;
}
```


---

## 作者：bluewindde (赞：2)

考虑一条链的情形。

![](https://cdn.luogu.com.cn/upload/image_hosting/j23gpwnz.png)

如图，将每个城市视为一条线段，容易发现交错（有交但不包含）的若干线段必须全部合并才能符合条件。但如果这么写会出错，原因是线段有包含关系，外层线段需要统计内层线段的答案，但内层线段不需要统计外层线段的答案。如果设内层线段为 $x$，外层线段为 $y$，则可以这样描述：

- 如果选 $x$ 作为首都，则不能选 $y$（选 $y$ 一定更劣）；
- 如果选 $y$ 作为首都，则必须选 $x$（满足作为首都的条件）。

这很像 2-SAT 问题，启发我们根据依赖关系建图：如果城市 $a$ 的两个城镇之间的路径经过城市 $b$，则连边 $a \rightarrow b$。答案即为没有出边（满足条件不依赖于合并更多城市）的最小的强连通分量的大小减 $1$。

暴力连边一定会超时，考虑优化建图：若当前对于城市 $x$ 建图，类似于建虚树，取出 $x$ 的所有城镇以及它们的所有 LCA 作为关键点。关键点之间使用树链剖分得到一段连续的链，将 $x$ 向链上的点所属的城市分别连边。

使用 **线段树优化建图**，在树剖得到的 DFS 序上建立线段树，每个叶子节点代表向其代表的原树上的点所属的城市连边，线段树内部父亲向儿子连边。如此操作后，每条链 $[l, r]$ 均可分解为至多 $O(\log n)$ 个极大区间。可以发现，新图一定与原图等价，但边的数量减小为可接受级别。

求强连通分量使用 Tarjan。

时间复杂度 $O(n \log^2 n)$。

代码

```cpp
#include <algorithm>
#include <iostream>
#include <set>
#include <vector>

using namespace std;

int n, k, rt;
int c[1000005];
vector<int> vec[1000005];
vector<int> G[1000005];
vector<int> include[1000005];

int f[1000005];
int dfn[1000005], dfn_clock;
int nfd[1000005];
int dep[1000005];
int son[1000005];
int top[1000005];
int siz[1000005];
static inline void dfs(int u, int fa) { // chain segmentation
    f[u] = fa;
    dep[u] = dep[fa] + 1;
    siz[u] = 1;
    for (auto v : vec[u]) {
        if (v == fa)
            continue;
        dfs(v, u);
        siz[u] += siz[v];
        if (siz[v] > siz[son[u]])
            son[u] = v;
    }
}
static inline void dfs2(int u) {
    dfn[u] = ++dfn_clock;
    nfd[dfn_clock] = u;
    if (!son[u])
        return;
    top[son[u]] = top[u];
    dfs2(son[u]);
    for (auto v : vec[u]) {
        if (v == f[u] || v == son[u])
            continue;
        top[v] = v;
        dfs2(v);
    }
}
static inline int LCA(int u, int v) {
    while (top[u] != top[v]) {
        if (dep[top[u]] < dep[top[v]])
            swap(u, v);
        u = f[top[u]];
    }
    if (dep[u] < dep[v])
        return u;
    return v;
}

struct node { // SGT optimize building graph
    int ls, rs;
} d[4000005];
int cnt;
static inline int build(int s, int t) {
    int p = ++cnt;
    if (s == t) {
        G[p].push_back(c[nfd[s]]);
        return p;
    }
    int mid = (s + t) >> 1;
    d[p].ls = build(s, mid);
    d[p].rs = build(mid + 1, t);
    G[p].push_back(d[p].ls);
    G[p].push_back(d[p].rs);
    return p;
}
static inline void addedge(int l, int r, int s, int t, int from, int p) {
    if (l <= s && r >= t) {
        G[from].push_back(p);
        return;
    }
    int mid = (s + t) >> 1;
    if (l <= mid)
        addedge(l, r, s, mid, from, d[p].ls);
    if (r > mid)
        addedge(l, r, mid + 1, t, from, d[p].rs);
}
static inline void add(int u, int v) {
    int col = c[u];
    while (top[u] != top[v]) {
        if (dep[top[u]] < dep[top[v]])
            swap(u, v);
        addedge(dfn[top[u]], dfn[u], 1, n, col, rt);
        u = f[top[u]];
    }
    if (dep[u] > dep[v])
        swap(u, v);
    addedge(dfn[u], dfn[v], 1, n, col, rt);
}

int t_dfn[1000005], t_low[1000005], t_dfn_clock;
int sta[1000005], tail;
bool insta[1000005];
vector<int> scc[1000005];
int belong[1000005];
int scc_cnt;
static inline void tarjan(int u) {
    t_dfn[u] = t_low[u] = ++t_dfn_clock;
    sta[++tail] = u;
    insta[u] = true;
    for (auto v : G[u]) {
        if (!t_dfn[v]) {
            tarjan(v);
            t_low[u] = min(t_low[u], t_low[v]);
        } else if (insta[v])
            t_low[u] = min(t_low[u], t_dfn[v]);
    }
    if (t_dfn[u] == t_low[u]) {
        ++scc_cnt;
        while (sta[tail] != u) {
            scc[scc_cnt].push_back(sta[tail]);
            belong[sta[tail]] = scc_cnt;
            insta[sta[tail]] = false;
            --tail;
        }
        scc[scc_cnt].push_back(u);
        belong[u] = scc_cnt;
        insta[u] = false;
        --tail;
    }
}

int sum[1000005];
int deg[1000005];

signed main() {
#ifndef ONLINE_JUDGE
    freopen("P7215.in", "r", stdin);
#endif
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> k;
    cnt = k;
    for (int i = 1; i < n; ++i) {
        int u, v;
        cin >> u >> v;
        vec[u].push_back(v);
        vec[v].push_back(u);
    }
    for (int i = 1; i <= n; ++i) {
        cin >> c[i];
        include[c[i]].push_back(i);
    }
    dfs(1, 0);
    top[1] = 1;
    dfs2(1);
    rt = build(1, n);
    for (int i = 1; i <= k; ++i) {
        if (include[i].size() > 1) { // like virtual tree
            int cur = include[i][0];
            for (size_t j = 1; j < include[i].size(); ++j) {
                int lca = LCA(include[i][0], include[i][j]);
                if (include[i][j] != lca)
                    add(include[i][j], lca);
                if (dep[lca] < dep[cur])
                    cur = lca;
            }
            if (include[i][0] != cur)
                add(include[i][0], cur);
        }
    }
    for (int i = 1; i <= cnt; ++i)
        if (!t_dfn[i])
            tarjan(i);
    for (int i = 1; i <= k; ++i)
        ++sum[belong[i]];
    for (int u = 1; u <= cnt; ++u)
        for (auto v : G[u])
            if (belong[u] != belong[v])
                ++deg[belong[u]];
    int ans = 1e9;
    for (int i = 1; i <= k; ++i)
        if (!deg[belong[i]])
            ans = min(ans, sum[belong[i]]);
    cout << ans - 1 << endl;
    return 0;
}
```

---

## 作者：__Aaaaaaaa (赞：2)

## 题目描述

给定一棵无根树，树上每个结点都有一个颜色，问最少可以使用多少次形如“将所有颜色为 $a$ 的结点变为颜色为 $b$ 的结点”这样的操作之后使得至少存在一种颜色的所有结点形成一颗连通子树。

## Solution
可以考虑一种颜色 $c$，将它作为目标颜色，将它的所有结点从树中取出来。

这样可以确定最小的一棵连通子树使得所有颜色为 $c$ 的结点都在这棵连通子树上。

但是连通子树上会存在许多其他颜色的结点。这样可以确定很多形如“必须将颜色 $d$ 归为颜色 $c$ 才能达成目标”的颜色之间的关系。然而只将所有 $d$ 变成 $c$ 是不够的。

将这样的颜色关系进行连边。$c$ 连向 $d$ 表示 “必须将颜色 $d$ 归为颜色 $c$ 才能达成所有颜色为 $c$ 的结点组成一棵连通子树”。

根据这样的依赖关系，对所有颜色都去尝试连边，然后将图建立出来。

可以发现，想要满足“所有颜色为 $c$ 的结点组成一棵连通子树”，必须要将点 $c$ 可以到达的所有颜色都变成 $c$。答案等价于点数最少的缩点之后出度为 $0$ 的强连通分量的点数。

而连边可以使用重链剖分+线段树优化建图，建立同色结点形成的连通子树可以使用类似虚树的建立方法。

~~这种方法太丑了不推荐~~，这种方法的时间复杂度是 $O(n\log^2_2n)$，瓶颈在于线段树优化建图和确定连通子树上，这些的常数是低于点分治的，效率良好。

## Code
```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
using namespace std;
const int N=2e5+10,L=N*4,M=1e7+10;
char buf[1<<20],*p1=buf,*p2=buf;
#define gc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<20,stdin),p1==p2)?EOF:*p1++)
inline int read(){int x=0;char ch=gc();while(ch>'9'||ch<'0'){ch=gc();}while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48),ch=gc();}return x;}
int n,m;
int h[N],h2[L],e[M],ne[M],ct=1;
void add(int h[],int x,int y){
	e[ct]=y,ne[ct]=h[x],h[x]=ct++;
}
int depth[N],dfn[N],fa[N],top[N],son[N],sz[N],ts;
void dfs1(int u,int v){
	depth[u]=depth[v]+1,fa[u]=v;
	sz[u]=1;
	for(int i=h[u];i;i=ne[i])if(e[i]!=v){
		dfs1(e[i],u);
		sz[u]+=sz[e[i]];
		if(sz[e[i]]>sz[son[u]])son[u]=e[i];
	}
}
int idf[N];
void dfs2(int u,int t){
	top[u]=t,dfn[u]=++ts;
	idf[ts]=u;
	if(!son[u])return;
	dfs2(son[u],t);
	for(int i=h[u];i;i=ne[i]){
		if(e[i]!=fa[u]&&e[i]!=son[u])
			dfs2(e[i],e[i]);
	}
}
int mark,root;
int idx;
struct tree{
	int l,r;
}tr[L];
void query(int s,int u,int l,int r,int L,int R){
	if(l>=L&&r<=R){
		add(h2,s,u);
		return;
	}
	int mid=l+r>>1;
	if(mid>=L)query(s,tr[u].l,l,mid,L,R);
	if(mid<R)query(s,tr[u].r,mid+1,r,L,R);
}
int c[N];
void build(int &u,int l,int r){
	u=++idx;
	if(l==r){
		add(h2,u,c[idf[l]]);
		return;
	}
	int mid=l+r>>1;
	build(tr[u].l,l,mid);
	build(tr[u].r,mid+1,r);
	add(h2,u,tr[u].l);
	add(h2,u,tr[u].r);
}
void update(int x,int y){
	int res=0,t=c[x];
	while(top[x]!=top[y]){
		if(depth[top[x]]<depth[top[y]])swap(x,y);
		query(t,root,1,n,dfn[top[x]],dfn[x]);
		x=fa[top[x]];
	}
	if(dfn[x]>dfn[y])swap(x,y);
	query(t,root,1,n,dfn[x],dfn[y]);
}
vector<int>v[N];
int cnt[L],scc,bel[L],ind[L];
int Dfn[L],Low[L],timestamp;
int stk[L],tt;
bool ins[L];
void tarjan(int u){
	Dfn[u]=Low[u]=++ts;
	stk[++tt]=u,ins[u]=true;
	for(int i=h2[u];i;i=ne[i]){
		int j=e[i];
		if(!Dfn[j]){
			tarjan(j);
			Low[u]=min(Low[u],Low[j]);
		}
		else if(ins[j])
			Low[u]=min(Low[u],Dfn[j]);
	}
	if(Dfn[u]==Low[u]){
		int j;
		++scc;
		do{
			ins[j=stk[tt--]]=false,cnt[scc]+=(j<=m),bel[j]=scc;
		}while(j!=u);
	}
}
bool dead[L];
int main(){
	n=read(),m=read();
	for(int i=1,x,y;i<n;++i){
		x=read(),y=read();
		add(h,x,y),add(h,y,x);
	}
	for(int i=1;i<=n;++i){
		c[i]=read();
		v[c[i]].emplace_back(i);
	}
	dfs1(1,0),dfs2(1,1);
	idx=m;
	build(root,1,n);
	for(int c=1;c<=m;++c){
		sort(v[c].begin(),v[c].end(),[](const int x,const int y){return dfn[x]<dfn[y];});
		++mark;
		if(v[c].size()==1){
			puts("0");
			return 0;
		}
		for(int i=0;i<v[c].size()-1;++i){
			update(v[c][i],v[c][i+1]);
		}
	}
	for(int i=1;i<=idx;++i)
		if(!Dfn[i])tarjan(i);
	for(int i=1;i<=idx;++i)if(!dead[bel[i]]){
		for(int j=h2[i];j;j=ne[j]){
			if(bel[e[j]]!=bel[i]){
				dead[bel[i]]=true;
				break;
			}
		}
	}
	int ans=1e9;
	for(int i=1;i<=scc;++i)if(!dead[i])
		ans=min(ans,cnt[i]-1);
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：myee (赞：2)

### 思路

显然答案可以认为是将若干个城市拼成一个城市后会联通。

考虑如果一个城市被选入答案中，则其对应所有节点构成的**虚树**上的所有城市均需被选择。

我们把这种关系连有向边，然后缩点，那么**无出度的最小 SCC 即为答案**；注意还要减 $1$。

直接连边是 $O(n^2)$ 的，怎么优化？

我们考虑直接倍增优化建图，从而点数、边数均为 $O(n\log n)$ 级别的。

注意倍增优化建图时的虚点贡献不能被计入答案中。

总复杂度 $O(n\log n)$。

### Code

这份实现的常数很大。

```cpp
const uint B=17;
uint F[B+1][200005],Dfn[200005],Dep[200005],n,k;
std::vector<uint>Way[200005],P[200005];
uint To[28000005],Last[28000005],End[4000005],REnd[4000005],cnt;
inline voi insert(uint u,uint v)
{
    Last[cnt]=End[u],To[cnt]=v,End[u]=cnt++;
    Last[cnt]=REnd[v],To[cnt]=u,REnd[v]=cnt++;
}
voi dfs(uint p,uint f)
{
    static uint cnt=0;Dfn[p]=cnt++,F[0][p]=f;
    for(uint i=1;(1u<<i)<=Dep[p]+1;i++)
        F[i][p]=F[i-1][F[i-1][p]],insert(i*n+k+p,(i-1)*n+k+p),insert(i*n+k+p,(i-1)*n+k+F[i-1][p]);
    for(auto s:Way[p])if(s!=f)Dep[s]=Dep[p]+1,dfs(s,p);
}
uint lca(uint u,uint v)
{
    if(Dep[u]<Dep[v])std::swap(u,v);
    for(uint i=B;~i;i--)if(Dep[u]-Dep[v]>=(1u<<i))u=F[i][u];
    if(u==v)return u;
    for(uint i=B;~i;i--)if(F[i][u]!=F[i][v])u=F[i][u],v=F[i][v];
    return F[0][u];
}
bol G[4000005];uint S[4000005],Id[4000005],Cnt[4000005];
voi dfs1(uint p)
{
    static uint cnt=0;
    G[p]=true;
    for(uint e=End[p];~e;e=Last[e])if(!G[To[e]])dfs1(To[e]);
    S[cnt++]=p;
}
voi dfs2(uint p,uint c)
{
    G[p]=false,Cnt[Id[p]=c]+=p<k;
    for(uint e=REnd[p];~e;e=Last[e])if(G[To[e]])dfs2(To[e],c);
}
int main()
{
#ifdef MYEE
    freopen("QAQ.in","r",stdin);
    freopen("QAQ.out","w",stdout);
#endif
    scanf("%u%u",&n,&k);
    for(uint i=0;i<n*B+k;i++)End[i]=REnd[i]=-1;
    for(uint i=1,u,v;i<n;i++)scanf("%u%u",&u,&v),Way[--u].push_back(--v),Way[v].push_back(u);
    for(uint i=0,v;i<n;i++)scanf("%u",&v),P[--v].push_back(i),insert(i+k,v);
    dfs(0,0);
    for(uint i=0;i<k;i++)
    {
        std::sort(P[i].begin(),P[i].end(),[&](uint a,uint b){return Dfn[a]<Dfn[b];});
        for(uint j=1,u,v,r;j<P[i].size();j++)
        {
            r=lca(u=P[i][j-1],v=P[i][j]);
            for(uint t=B;~t;t--)if(Dep[u]-Dep[r]>=(1u<<t))insert(i,t*n+k+u),u=F[t][u];
            for(uint t=B;~t;t--)if(Dep[v]-Dep[r]>=(1u<<t))insert(i,t*n+k+v),v=F[t][v];
            insert(i,k+r);
        }
    }
    for(uint i=0;i<n*B+k;i++)if(!G[i])dfs1(i);
    uint c=0;
    for(uint i=n*B+k-1;~i;i--)if(G[S[i]])dfs2(S[i],c++);
    for(uint i=0;i<cnt;i+=2)if(Id[To[i]]!=Id[To[i|1]])Cnt[Id[To[i|1]]]=0;
    uint ans=-1;
    while(c--)_min(ans,Cnt[c]-1);
    printf("%u\n",ans);
    return 0;
}
```


---

## 作者：ningago (赞：2)

建立新有向图 $G$。$G$ 中边 $x\to y$ 表示 $x$ 成为首都（的一部分）的前提是合并 $x,y$。

对于一种颜色 $p$，建出 $C_i=p$ 的所有节点的虚树。

由于可以用 $O(n)$ 条路径刻画虚树，则对于 $dfn$ 相邻的两个节点 $a,b$，其贡献为从 $c$ 向 $a, b$ 路径上所有节点的颜色连边。

此过程使用树链剖分套线段树优化建图维护即可。

对于图 $G$，先对其进行缩点为 $G'$。

所属强连通分量在 $G'$ 中有出边的颜色肯定不优，故答案为最小的无出边强连通分量大小（大小不包含线段树辅助点）。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>

#define test printf("now is %d\n", __LINE__);
#define M 1000010
#define N 200010
void ckmax(int &x, int y) { x = x > y ? x : y; }
void ckmin(int &x, int y) { x = x < y ? x : y; }
int n, m, col[N];
namespace Tree
{
	std::vector<int> Tr[N];
	int dfn[N], fdfn[N], sz[N], fa[N], dep[N], top[N], hson[N];
}
namespace Tarjan
{
	int idx;
	std::vector<int> g[M], G[M];
	int a[M], A[M];
	void init()
	{
		idx = m;
		std::fill(a + 1, a + 1 + m, 1);
	}
	void add_edge(int x, int y)
	{
		g[x].push_back(y);
	}
	void add_G(int x, int y)
	{
		G[x].push_back(y);
	}
	int dfn[M], low[M], sta[M], top;
	int scc[M];
	bool in_stack[M];
	void tarjan(int k)
	{
		dfn[k] = low[k] = ++dfn[0];
		in_stack[sta[++top] = k] = 1;
		for (auto nx : g[k])
		{
			if (!dfn[nx])
			{
				tarjan(nx);
				ckmin(low[k], low[nx]);
			}
			else if (in_stack[k])
				ckmin(low[k], dfn[nx]);
		}
		if (low[k] == dfn[k])
		{
			++scc[0];
			while (1)
			{
				int t = sta[top--];
				in_stack[t] = 0;
				scc[t] = scc[0];
				A[scc[0]] += a[t];
				if (t == k)
					break;
			}
		}
	}
	int solve()
	{
		for (int i = 1; i <= idx; i++)
			if (!dfn[i])
				tarjan(i);
		for (int k = 1; k <= idx; k++)
		{
			for (auto nx : g[k])
			{
				if (scc[k] == scc[nx])
					continue;
				add_G(scc[k], scc[nx]);
			}
		}
		int ans = 0x3f3f3f3f;
		for (int i = 1; i <= scc[0]; i++)
			if (G[i].empty())
				ckmin(ans, A[i]);
		return ans;
	}
} // namespace Tarjan

namespace SegTree
{
#define lson k << 1
#define rson k << 1 | 1
#define ls k << 1, l, mid
#define rs k << 1 | 1, mid + 1, r
	int id[N << 2];
	void build(int k, int l, int r)
	{
		id[k] = ++Tarjan::idx;
		if (l == r)
		{
			Tarjan::add_edge(id[k], col[Tree::fdfn[l]]);
			return;
		}
		int mid = (l + r) >> 1;
		build(ls);
		build(rs);
		Tarjan::add_edge(id[k], id[lson]);
		Tarjan::add_edge(id[k], id[rson]);
	}
	void add(int k, int l, int r, int ql, int qr, int z)
	{
		if (ql <= l && r <= qr)
		{
			Tarjan::add_edge(z, id[k]);
			return;
		}
		int mid = (l + r) >> 1;
		if (ql <= mid)
			add(ls, ql, qr, z);
		if (mid < qr)
			add(rs, ql, qr, z);
	}
}
namespace Tree
{
	void add(int x, int y)
	{
		Tr[x].push_back(y);
		Tr[y].push_back(x);
	}
	void dfs1(int k, int f, int deep)
	{
		fa[k] = f;
		dep[k] = deep;
		sz[k] = 1;
		int maxnum = 0;
		for (auto nx : Tr[k])
		{
			if (nx == f)
				continue;
			dfs1(nx, k, deep + 1);
			if (sz[nx] > maxnum)
				maxnum = sz[nx], hson[k] = nx;
			sz[k] += sz[nx];
		}
	}
	void dfs2(int k, int tp)
	{
		top[k] = tp;
		dfn[k] = ++dfn[0];
		fdfn[dfn[k]] = k;
		if (hson[k])
			dfs2(hson[k], tp);
		for (auto nx : Tr[k])
		{
			if (nx == fa[k] || nx == hson[k])
				continue;
			dfs2(nx, nx);
		}
	}
	int lca(int x, int y)
	{
		while (top[x] != top[y])
		{
			if (dep[top[x]] < dep[top[y]])
				x ^= y ^= x ^= y;
			x = fa[top[x]];
		}
		if (dep[x] > dep[y])
			return y;
		return x;
	}
	void add(int x, int y, int z)
	{
		while (top[x] != top[y])
		{
			if (dep[top[x]] < dep[top[y]])
				x ^= y ^= x ^= y;
			SegTree::add(1, 1, n, dfn[top[x]], dfn[x], z);
			x = fa[top[x]];
		}
		if (dep[x] > dep[y])
			x ^= y ^= x ^= y;
		SegTree::add(1, 1, n, dfn[x], dfn[y], z);
	}
	std::vector<int> v[N], a;
	void build()
	{
		for (int i = 1; i <= n; i++)
			v[col[i]].push_back(i);
		for (int c = 1; c <= m; c++)
		{
			if (v[c].empty())
				continue;
			a.clear();
			std::sort(v[c].begin(), v[c].end(), [&](int x, int y)
					  { return dfn[x] < dfn[y]; });
			int sz = v[c].size();
			for (int i = 0; i < sz - 1; i++)
			{
				a.push_back(v[c][i]);
				a.push_back(lca(v[c][i], v[c][i + 1]));
			}
			a.push_back(v[c][sz - 1]);
			std::sort(a.begin(), a.end(), [&](int x, int y)
					  { return dfn[x] < dfn[y]; });
			a.erase(std::unique(a.begin(), a.end()), a.end());
			sz = a.size();
			for (int i = 0; i < sz - 1; i++)
				add(a[i], a[i + 1], c);
		}
	}
}

int main()
{
	scanf("%d%d", &n, &m);
	for (int i = 1, x, y; i < n; i++)
		scanf("%d%d", &x, &y), Tree::add(x, y);
	for (int i = 1; i <= n; i++)
		scanf("%d", &col[i]);
	Tree::dfs1(1, 0, 1);
	Tree::dfs2(1, 1);
	Tarjan::init();
	SegTree::build(1, 1, n);
	Tree::build();
	printf("%d\n", Tarjan::solve() - 1);
	return 0;
}
```

---

## 作者：OIerBoy (赞：2)

# Sol
一个显然的 $O(n^2)$ 的暴力思路。

因为这是一颗树，我们就每一次将城镇 $1\sim n$ 定为根节点，将这个城镇的所属城市定为首都，而要求首都的其他城镇到根节点的路径上只有首都自己的城镇。可事实上路径中是会出现其他的城镇的，我们就需要将这个挡路的城镇的所属城市合并掉。在合并的同时我们也需要将被合并的城市的城镇同样纳入首都，继续维护。

这个过程看似很繁琐，有点绕，其实我们只需要一个队列用来维护需要判断路径的城镇就可以了。而它的时间复杂度也非常好证明，因为每一个城镇最多入队一次，而我们需要枚举的只有根节点，时间复杂度为 $O(n^2)$。

好了，暴力讲完了，我们来讲一讲正解。

我们发现，我们每一次需要维护城镇到根节点的路径，保证没有其他城市的城镇。那么按照暴力的思路，我们每次需要维护相同城镇中点对的路径。

可以考虑贪心，当我们选定城市 $i$ 为首都，则答案一定不劣在选定其他城市为首都时将城市 $i$ 合并的答案。

这样我们用点分治就可以解决了。
# Code
```cpp
#include<bits/stdc++.h>
#define int long long
#define N 200005
#define fir first
#define sec second
#define ls (x<<1)
#define rs (x<<1|1)
#define mid ((l+r)>>1)
#define Pr(i,j) pair<i,j>
#define MP(i,j) make_pair(i,j)
#define Fo(i,j) for(auto i:j)
#define FO(i,j,k) for(int i=j;i;i=k)
#define PB(i) push_back(i)
#define FFF(i,j,k) for(auto i=j;i!=k;++i)
#define For(i,j,k) for(long long i=j;i<=k;++i)
#define FoR(i,j,k) for(long long i=j;i^k;++i)
#define FOR(i,j,k) for(long long i=j;i>=k;--i)
using namespace std;
template <typename _Tp>void read(_Tp& first) {
    _Tp x = 0, f = 1; char c = getchar();
    while (!isdigit(c)) {if (c == '-') f = -1; c = getchar();}
    while (isdigit(c)) x = (x << 3) + (x << 1) + (c ^ '0'), c = getchar();
    first = x * f;
}
int n,k,cnt,rt,ans,x[N];
int siz[N],f[N],Max[N];
int vis[N],a[N],c[N];
int st[N],top;
vector<int>e[N],p[N];
void Getrt(int u,int fa,int s){
    siz[u]=1,Max[u]=0;
    Fo(v,e[u]){
        if(v==fa||vis[v])continue;
        Getrt(v,u,s);
        siz[u]+=siz[v];
        Max[u]=max(siz[v],Max[u]);
    }Max[u]=max(Max[u],s-Max[u]-1);
    if(!rt||Max[u]<=Max[rt])rt=u;
    return;
}
void Gfr(int u,int fa,int fr){
    f[u]=fa,a[u]=fr;
    Fo(v,e[u])if(!vis[v]&&v!=fa)Gfr(v,u,fr);
}
void calc(){
    while(top)c[st[top--]]=0;
    queue<int>q;
    Fo(v,p[x[rt]])
        if(a[v]!=rt)return;
        else q.push(v),c[v]=1,st[++top]=v;
    int now=0;
    while(!q.empty()){
        int u=q.front();q.pop();
        if(u==rt)continue;
        if(!c[f[u]]){
            Fo(v,p[x[f[u]]]){
                if(a[v]!=rt)return;
                else c[v]=1,st[++top]=v,q.push(v);
            }now++;
        }
    }
    ans=min(ans,now);
    return;
}
void solve(int u){
    vis[u]=1;
    calc();
    Fo(v,e[u]){
        if(vis[v])continue;
        rt=0;
        Getrt(v,0,siz[v]);
        Gfr(rt,0,rt);
//        cout<<rt<<endl;
        solve(rt);
    }
}
signed main(){
    read(n),read(k);
    FoR(i,1,n){
        int u,v;
        read(u),read(v);
        e[u].PB(v);
        e[v].PB(u);
    }
    For(i,1,n){
        read(x[i]);
        p[x[i]].PB(i);
    }
    ans=k-1;
    Max[0]=1e16;
    Getrt(1,0,n);
    Gfr(rt,0,rt);
//    cout<<rt<<endl;
    solve(rt);
    cout<<ans;
    return 0;
}
```


---

## 作者：PersistentLife (赞：1)

### [【JOISC2020】首都](https://www.luogu.com.cn/problem/P7215)

令一个点的“颜色”为初始时所属城市编号。

若最终选择的首都包含颜色为 $x$ 的节点，则一定会包含所有颜色为 $x$ 的节点中两两路径的并上的节点，也就是虚树上的节点。

我们可以找出若干个二元组 $(x,y)$，即若包含颜色为 $x$ 的节点，一定要包含颜色为 $y$ 的节点。对于每个 $x$，将所有颜色为 $x$ 的节点建虚树，并用树链剖分拆成 $O(m \log m)$ 个区间（$m$ 是颜色为 $x$ 的节点个数），这些区间内的颜色就是对应的 $y$，将颜色 $x$ 向这些 $y$ 连边，建立新图 $G'$，用 ST 表优化。

令 $cnt(i)$ 表示节点 $i$ 在新图 $G'$ 中能走到的节点个数，问题答案即为 $\min\{cnt(i)\}-1$，先强联通缩点，答案一定在没有出度的若干节点中产生。

复杂度 $O(n \log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define fi first
#define se second
#define pii pair<int,int>
#define mp make_pair
#define pb push_back
const int mod=998244353;
const int inf=0x3f3f3f3f;
char buf[1<<23],*p1=buf,*p2=buf,obuf[1<<23],*O=obuf;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
inline int read() {
	int x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)) x=x*10+(ch^48),ch=getchar();
	return x*f;
}
void print(long long x) {
    if(x>9) print(x/10);
    *O++=x%10+'0';
}
int to[400005];
int eL[200005],eR[200005],deg[200005],eP[200005];
struct LCA
{
	int dep[200005],dfn[200005],times;
	int st[20][400005],Lg[400005],Fa[200005];
	void dfs(int u,int fa)
	{
		Fa[u]=fa;
		dfn[u]=++times,st[0][times]=u;
		for(int i=eL[u];i<=eR[u];i++)
		{
			int v=to[i];
			if(v==fa) continue;
			dep[v]=dep[u]+1,dfs(v,u);
			st[0][++times]=u;
		}
	}
	int mindep(int x,int y)
	{
		if(dep[x]<dep[y]) return x;
		return y;
	}
	void build()
	{
		times=0,dep[1]=0;
		dfs(1,-1);
		Lg[1]=0,Lg[2]=1;
		for(int i=3;i<=times;i++) Lg[i]=Lg[i/2]+1;
		for(int k=1;k<20;k++) for(int i=1;i+(1<<k)-1<=times;i++) 
			st[k][i]=mindep(st[k-1][i],st[k-1][i+(1<<(k-1))]);
	}
	int getlca(int u,int v)
	{
		u=dfn[u],v=dfn[v];
		if(u>v) swap(u,v);
		int s=Lg[v-u+1];
		return mindep(st[s][u],st[s][v-(1<<s)+1]);
	}
}Lca;
int a[200005]; 
int dfn[200005],times,sz[200005],son[200005],val[200005],par[200005],dep[200005],top[200005];
int n,K,uidx;
vector <int> G[4000005];
int idx[19][200005],Lg[200005];
void init_graph_st()
{
	uidx=K+1;
	for(int i=1;i<=n;i++) idx[0][i]=val[i];
	Lg[1]=0,Lg[2]=1;
	for(int i=3;i<=n;i++) Lg[i]=Lg[i/2]+1;
	for(int k=1;k<19;k++) for(int i=1;i+(1<<k)-1<=n;i++)
	{
		idx[k][i]=++uidx;
		G[idx[k][i]].pb(idx[k-1][i]),G[idx[k][i]].pb(idx[k-1][i+(1<<(k-1))]); 
	} 
}
void link_graph_st(int u,int L,int R)
{
	int s=Lg[R-L+1];
	G[u].pb(idx[s][L]),G[u].pb(idx[s][R-(1<<s)+1]);
}
void link_HLD(int co,int u,int v)
{
	while(top[u]!=top[v])
    {
        if(dep[top[u]]<dep[top[v]]) swap(u,v);
        link_graph_st(co,dfn[top[u]],dfn[u]);
        u=par[top[u]];
    }
    if(dep[u]>dep[v]) swap(u,v);
    link_graph_st(co,dfn[u],dfn[v]);
}
void dfs0(int u,int fa)
{
	par[u]=fa,son[u]=0,sz[u]=1;
	dep[u]=dep[fa]+1;
	int maxx=0;
	for(int i=eL[u];i<=eR[u];i++)
	{
		int v=to[i];
		if(v==fa) continue;
		dfs0(v,u);
		sz[u]+=sz[v];
		if(sz[v]>maxx) maxx=sz[v],son[u]=v;
	}
}
void dfs1(int u,int fa)
{
	top[u]=fa,dfn[u]=++times;
	val[times]=a[u];
	if(son[u]) dfs1(son[u],fa);
	for(int i=eL[u];i<=eR[u];i++)
	{
		int v=to[i];
		if(v==son[u]||v==par[u]) continue;
		dfs1(v,v);
	}
}
vector <int> has[200005];
bool cmp(int x,int y)
{
	return dfn[x]<dfn[y];
}
int now[400005];
void addedge(int col)
{
	if(has[col].size()<=1)
	{
		puts("0");
		exit(0);
	}
	sort(has[col].begin(),has[col].end(),cmp);
	int len=0;
	for(int i=0;i<has[col].size();i++)
	{
		now[++len]=has[col][i];
		if(i) now[++len]=Lca.getlca(has[col][i-1],has[col][i]);
	}
	sort(now+1,now+len+1,cmp);
	len=unique(now+1,now+len+1)-now-1;
	for(int i=1;i<len;i++)
	{
		int l=Lca.getlca(now[i],now[i+1]);
	//	cout<<"add-path: "<<col<<" "<<l<<" "<<now[i+1]<<endl;
		link_HLD(col,l,now[i+1]);
	}
	//puts("ok");
}
int Dfn[4000005],Low[4000005],scccnt,Bl[4000005],Sum[4000005],stk[4000005],Top;
bool isend[4000005],vis[4000005];
void tarjan(int u)
{
	Dfn[u]=Low[u]=++times;
	vis[u]=1,stk[++Top]=u;
	for(int i=0;i<G[u].size();i++)
	{
		int v=G[u][i];
		if(!Dfn[v])
		{
			tarjan(v);
			Low[u]=min(Low[u],Low[v]);
		}
		else if(vis[v]) Low[u]=min(Low[u],Dfn[v]);
	}
	if(Low[u]==Dfn[u])
	{
		scccnt++;
		while(1)
		{
			int x=stk[Top];
			Top--;
			if(x<=K) Sum[scccnt]++;
			Bl[x]=scccnt,vis[x]=0;
			if(x==u) break;
		}
	}
}
int tU[200005],tV[200005];
void solve()
{
	n=read(),K=read();
	for(int i=1;i<n;i++)
	{
		tU[i]=read(),tV[i]=read();
		deg[tU[i]]++,deg[tV[i]]++;
	}
	for(int i=1,j=0;i<=n;i++) eL[i]=eP[i]=j,eR[i]=j+deg[i]-1,j=j+deg[i];
	for(int i=1;i<n;i++)
	{
		to[eP[tU[i]]]=tV[i];
		to[eP[tV[i]]]=tU[i];
		eP[tU[i]]++,eP[tV[i]]++;
	}
	for(int i=1;i<=n;i++) a[i]=read(),has[a[i]].pb(i);
	Lca.build();
	dfs0(1,1),dfs1(1,1);
	init_graph_st();
	for(int i=1;i<=K;i++) addedge(i);//,cout<<i<<endl;
	for(int i=1;i<=uidx;i++) if(!Dfn[i]) tarjan(i);
	int ans=K-1;
	for(int i=1;i<=uidx;i++) for(int j=0;j<G[i].size();j++) if(Bl[i]!=Bl[G[i][j]]) isend[Bl[i]]=1;
	for(int i=1;i<=K;i++) if(!isend[Bl[i]]) ans=min(ans,Sum[Bl[i]]-1);
	print(ans);
	fwrite(obuf,O-obuf,1,stdout);
}
signed main()
{
	int _=1;
//	cin>>_;
	while(_--) solve();
	return 0;
}
```


---

## 作者：Kevin090228 (赞：1)

首先考虑我们一定要选颜色 $1$ 时怎么做。显然我们此时一定要选择颜色 $1$ 虚树中所有的点，然后我们会得到一些新的颜色，然后我们又可以找到一些新的必须要选的点。具体的实现中我们可以随便选择一个颜色 $1$ 的点为根，然后进行 BFS 过程：选颜色 $x$ 的点之后要把其他所有颜色 $x$ 全选完且选点 $u$ 一定要选它的父亲。

直接暴力是 $O(n^2)$ 的，然后我们把它修改成点分治就可以得到一个简单的 $O(n\log n)$ 做法了。有点小细节。

---

## 作者：Find_Yourself (赞：0)

点分治。

考虑当前的分治重心的城市被完全联通。

这可以用队列接解决。每次放入一种城市，就把那些城镇的父亲加入队列，如果存在城镇不在当前分治重心的联通块内，那么说明必定存在另一个分治重心能算到它，直接退出即可。

剩下的和模板没有任何区别。

复杂度 $O(n\log n)$。

code:

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
int n,k,co[N],f[N],siz[N],vis[N],vis2[N],vis3[N],tmp[N],fa[N],rt,ans=INT_MAX/2,tot=0,cnt=0;
vector<int>adj[N],c[N];
void dfs(int u,int lst,int sum){
  siz[u]=1;f[u]=0;
  for(int i=0;i<adj[u].size();++i){
    int v=adj[u][i];if(v==lst||vis[v])continue;
    dfs(v,u,sum);siz[u]+=siz[v];
    f[u]=max(f[u],siz[v]);
  }
  f[u]=max(f[u],sum-siz[u]);
  if(f[u]<f[rt])rt=u;
}
void dfs2(int u,int lst){
  tmp[++tot]=u;vis2[u]=1;fa[u]=lst;
  for(int i=0;i<adj[u].size();++i){
    int v=adj[u][i];if(v==lst||vis[v])continue;
    dfs2(v,u);
  }
}
queue<int>q;
bool check(int w){
  for(int i=0;i<c[w].size();++i){
    int v=c[w][i];if(!vis2[v])return true;
    q.push(v);
  }
  ++cnt;
  return false;
}
void cal(int u){
  while(!q.empty())q.pop();
  vis3[co[u]]=1;
  if(check(co[u]))return;
  while(!q.empty()){
    int u=q.front();q.pop();
    if(!vis3[co[fa[u]]]){
      vis3[co[fa[u]]]=1;
      if(check(co[fa[u]]))return;
    }
  }
  ans=min(ans,cnt-1);
}
void solve(int u){
  vis[u]=1;tot=0;cnt=0;dfs2(u,u);cal(u);
  for(int i=1;i<=tot;++i)vis2[tmp[i]]=vis3[co[tmp[i]]]=0;
  for(int i=0;i<adj[u].size();++i){
    int v=adj[u][i];if(vis[v])continue;
    rt=0;dfs(v,u,siz[v]);solve(rt);
  }
}
int main(){
  ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
  cin>>n>>k;
  for(int i=1;i<n;++i){
    int u,v;cin>>u>>v;
    adj[u].push_back(v);adj[v].push_back(u);
  }
  for(int i=1;i<=n;++i){
    cin>>co[i];
    c[co[i]].push_back(i);
  }
  f[0]=1e9;dfs(1,0,n);solve(rt);
  cout<<ans<<endl;
  return 0;
}

```


---

## 作者：WZKQWQ (赞：0)

模拟赛赛时 AC，写一发题解。

原题城镇城市太容易混淆了，所以描述改成 $k$ 种颜色，每个城镇染了一种。

首先不难发现其实就是颜色之间有一些有向边，有向边 $(a,b)$ 存在表示 $a$ 中的城镇想两两互达必需要合并 $b$，原题的答案就是在这幅有向图中选出最少的点使得这些点没有出边连向其他点，这个可以先 tarjan 缩点再从出度为零的点中选包含最少颜色的点，问题在于图边数可能达到 $k^2$，所以考虑优化建图。

考虑点分治，以重心为根再对树上每个点建虚点，树点对应虚点向父亲对应的虚点连有向边，树点对应的虚点再向树点对应的颜色连有向边，最后如果这种颜色同时存在与重心两侧那么这种颜色向树上所有颜色是这种颜色的树点对应的虚点连有向边，在递归到子树做。

这样边数就是 $n \log n$ 的了，总复杂度 $O(n \log n)$，实现有些细节可以看代码（比如怎么维护颜色是不是同时存在重心两侧），模拟赛时这题时限是 $0.5s$，所以代码加了卡常把 dfs 换成了 bfs。

代码（臭长）：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 200005;
const int V = N * 20;
struct Edge{
	int nxt,to;
}e[V * 3];
int head[V],cnt;
void add(int x,int y){
	e[++cnt].to = y;
	e[cnt].nxt = head[x];
	head[x] = cnt;
}
stack<int>s;
int tot1,dfn[V],low[V],v1[V],fa[V],scc,num[V],v2[V];
int n,k,tot,c[N],v[N];
void tarjan(int x){
	s.push(x);
	v1[x] = 1;
	dfn[x] = low[x] = ++tot1;
	for(int i = head[x];i;i = e[i].nxt){
		int to = e[i].to;
		if(!dfn[to]){
			tarjan(to);
			low[x] = min(low[x],low[to]);
		} else if(v1[to]) low[x] = min(low[x],dfn[to]);
		//else low[x] = min(low[x],dfn[to]);
	}
	if(dfn[x] == low[x]){
		int y;
		++scc;
		do{
			y = s.top();
			s.pop();
			v1[y] = 0;
			fa[y] = scc;
			if(y <= k) ++num[scc];
		}while(y != x);
	}
}
vector<int>w[N];
int siz[N],id[N];
typedef pair<int,int> pr;
struct mque{
	int tou = 1,wei = 0;
	pr a[N];
	void push(pr x){a[++wei] = x;}
	void pop(){++tou;}
	pr front(){return a[tou];}
	bool empty(){return tou > wei;}	
	void clear(){tou = 1,wei = 0;}
}q;
void build(int x,int fa){
	siz[x] = 1;
	for(int to:w[x]){
		if(to == fa || v[to]) continue;
		build(to,x);
		siz[x] += siz[to];
	}
}
int dfsz(int x,int sum){
	q.clear();
	q.push({x,0});
	while(!q.empty()){
		pr tmp = q.front();
		q.pop();
		int x = tmp.first;
		int flag = (sum - siz[x] <= sum / 2);
		for(int to:w[x]){
			if(to == tmp.second || v[to]) continue;
			if(siz[to] > sum / 2) flag = 0;
			q.push({to,x});
		}
		if(flag) return x;
	}
//	int flag = (sum - siz[x] <= sum / 2);
//	for(int to:w[x]){
//		if(to == fa || v[to]) continue;
//		if(siz[to] > sum / 2) flag = 0;
//		int tmp = dfsz(to,x,sum);
//		if(tmp != -1) return tmp;
//	}
//	if(flag) return x;
//	else return -1;
}
int findz(int x){
	build(x,0);
	if(siz[x] == 1) return -1;
	return dfsz(x,siz[x]);
}
int o[N],cnt1;
void build1(int x){
	q.clear();
	q.push({x,0});
	while(!q.empty()){
		pr tmp = q.front();
		q.pop();
		int x = tmp.first;
		id[x] = ++tot;
		add(id[x],c[x]);
		o[++cnt1] = c[x];
		if(tmp.second) add(id[x],id[tmp.second]);
		for(int to:w[x]){
			if(to == tmp.second || v[to]) continue;
			q.push({to,x});
		}
	}
//	id[x] = ++tot;
//	add(id[x],c[x]);
//	o.push_back(c[x]);
//	for(int to:w[x]){
//		if(to == fa || v[to]) continue;
//		build1(to,x);
//		add(id[to],id[x]);
//	}
}
int t[N],_t[N],fi[N],ed[N];
void count(int x){
	q.clear();
	q.push({x,0});
	while(!q.empty()){
		pr tmp = q.front();
		q.pop();
		int x = tmp.first;
		++t[c[x]];
		for(int to:w[x]){
			if(to == tmp.second || v[to]) continue;
			q.push({to,x});
		}
	}
//	++t[c[x]];
//	for(int to:w[x]){
//		if(to == fa || v[to]) continue;
//		count(to,x);
//	}
}
void count1(int x,int fa,int now){
	q.clear();
	q.push({x,0});
	while(!q.empty()){
		pr tmp = q.front();
		q.pop();
		int x = tmp.first;
		if(_t[c[x]] == 0) fi[c[x]] = now;
		++_t[c[x]];
		if(_t[c[x]] == t[c[x]]) ed[c[x]] = now;
		for(int to:w[x]){
			if(to == tmp.second || v[to] || to == fa) continue;
			q.push({to,x});
		}
	}
//	if(_t[c[x]] == 0) fi[c[x]] = now;
//	++_t[c[x]];
//	if(_t[c[x]] == t[c[x]]) ed[c[x]] = now;
//	for(int to:w[x]){
//		if(to == fa || v[to]) continue;
//		count1(to,x,now);
//	}
}
void dfs(int x){
	q.clear();
	q.push({x,0});
	while(!q.empty()){
		pr tmp = q.front();
		q.pop();
		int x = tmp.first;
		if(fi[c[x]] != ed[c[x]]) add(c[x],id[x]);
		for(int to:w[x]){
			if(to == tmp.second || v[to]) continue;
			q.push({to,x});
		}
	}
//	if(fi[c[x]] != ed[c[x]]) add(c[x],id[x]);
//	for(int to:w[x]){
//		if(to == fa || v[to]) continue;
//		dfs(to,x);
//	}
}
void work(int x){
	cnt1 = 0;
	build1(x);
	for(int i = 1;i <= cnt1;++i) t[o[i]] = _t[o[i]] = fi[o[i]] = ed[o[i]] = 0;
	count(x);
	int tmp = 0;
	for(int to:w[x]){
		if(v[to]) continue;
		++tmp;
		count1(to,x,tmp);
	}
	dfs(x);
}
void df(int x){
	
	int root = findz(x);
	if(root == -1) return;
	//printf("k %d %d\n",x,root);
	work(root);
	v[root] = 1;
	for(int to:w[root]) if(!v[to]) df(to);
}
namespace INPUT_SPACE{
	const int S=(1<<20)+5;char B[S],*H,*T;inline int gc() { if(H==T) T=(H=B)+fread(B,1,S,stdin);return (H==T)?EOF:*H++; }
	inline int inn() { int x = 0,f = 1,ch;while((ch=gc())<'0'||ch>'9') if(ch == '-') f = -1;x=ch^'0';while((ch=gc())>='0'&&ch<='9') x=x*10+(ch^'0');return x * f; }
}using INPUT_SPACE::inn;
int main(){
	freopen("kingdom.in","r",stdin);
	freopen("kingdom.out","w",stdout);
	n = inn(),k = inn();
	tot = k;
	for(int i = 1,x,y;i < n;++i){
		x = inn(),y = inn();
		w[x].push_back(y);
		w[y].push_back(x);
	}
	for(int i = 1;i <= n;++i) c[i] = inn();
	df(1);
	for(int i = 1;i <= tot;++i) if(!dfn[i]) tarjan(i);
	for(int i = 1;i <= tot;++i){
		for(int j = head[i];j;j = e[j].nxt){
			int to = e[j].to;
			if(fa[i] != fa[to]) v2[fa[i]] = 1;
		} 
	}
	int ans = 1e9;
	for(int i = 1;i <= scc;++i) if(!v2[i]) ans = min(ans,num[i]);
	printf("%d\n",ans - 1);
	return 0;
}
/*
6 3
2 1
3 5
6 2
3 4
2 3
1
3
1
2
3
2
*/
```


---

## 作者：Isharmla (赞：0)

考试的时候脑子一抽，写了一个 $2^n\times n$ 的做法，狂砍一分，赛后发现是自己傻了，难受。

#### 一分做法
直接枚举最后答案可能包含的点，直接暴力验证，没什么好说的。

#### 十一分做法
也就是 $n^2$ 复杂度的做法，由于原图是一颗树，所以我们的答案选出来的部分一定一颗子树，我们钦定 $x$ 为根，对于所有和 $x$ 同色的点，直接扩展，看父亲是不是同色，否则就加入父亲的颜色的点，继续扩展。使用队列即可轻松维护，由于图最多扩展 $n$ 次，时间复杂度 $n^2$。

#### 满分做法
思考上一种做法的缺点在哪，问题就在于没有用点之间的关系。什么意思？也就是说，有的点明明不优秀，我还是算了。比如，我们假设 $x$ 为根，那么他就一定不劣于其他的为根的时候扩展到 $x$ 的情况。人话就是，我们计算 $x$ 和子树组成答案的时候，一定不会出现扩展到 $x$ 外部的情况，否则 $x$ 的父亲或祖先一定计算了这一种情况。

答案就变成了 $x$ 为根，和 $x$ 的子树某一点为根两种情况，淀粉质即可解决。

---


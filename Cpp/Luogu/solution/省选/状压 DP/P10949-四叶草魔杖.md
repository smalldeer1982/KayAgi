# 四叶草魔杖

## 题目描述

魔杖护法 Freda 融合了四件武器，于是魔杖顶端缓缓地生出了一棵四叶草，四片叶子幻发着淡淡的七色光。

圣剑护法 rainbow 取出了一个圆盘，圆盘上镶嵌着 $N$ 颗宝石，编号为 $0 \sim N-1$。

第 $i$ 颗宝石的能量是 $A_i$。

如果 $A\_i > 0$，表示这颗宝石能量过高，需要把 $A\_i$ 的能量传给其它宝石；如果 $A\_i < 0$，表示这颗宝石的能量过低，需要从其它宝石处获取 $-A\_i$ 的能量。

保证 $\sum A_i = 0$。

只有当所有宝石的能量均相同时，把四叶草魔杖插入圆盘中央，才能开启超自然之界的通道。

不过，只有 $M$ 对宝石之间可以互相传递能量，其中第 $i$ 对宝石之间无论传递多少能量，都要花费 $T_i$ 的代价。

探险队员们想知道，最少需要花费多少代价才能使所有宝石的能量都相同？

## 说明/提示

$2 \le N \le 16$,  
$0 \le M \le N*(N-1)/2$,  
$0 \le p\_i,q\_i < N$,  
$-1000 \le A_i \le 1000$,  
$0 \le T_i \le 1000$

## 样例 #1

### 输入

```
3 3
50 -20 -30
0 1 10
1 2 20
0 2 100```

### 输出

```
30
```

# 题解

## 作者：hansang (赞：6)

# P10949 四叶草魔杖
## 来源：算法进阶图论（练习）：四叶草魔杖
### 解法说明：
提示：此题样例应输出 $30$。

根据题目的数据范围，不难想到可以用状态压缩来解。

可是两个宝石能量的**传递**应该如何解决？我们把题目简化为在宝石 $i$ 和宝石 $j$ 之间传递能量的代价为 $w$，结果发现这和**最小生成树**的模版题很像。

我们定义一个数组，$dp[S]$ 表示当前宝石集合为 $S$ 传递完毕时花费的最小代价。其中 $S$ 是一个二进制数，它的第 $i$ 位为 $1$ 代表着 $S$ 集合中有宝石 $i$。

状态转移就应该是：

$$dp[S] \gets \min(dp[S],dp[T]+d[R])$$

其中 $T$ 和 $R$ 是 $S$ 的子集，$T \cup R$ 为 $S$。$d[R]$ 表示 $R$ 集合中宝石传递完毕的最小代价，可以用最小生成树计算出 $d[R]$ 的值。

可是我们发现：把每个宝石集合都计算一遍最小生成树，最后计算出来的总最小代价却有可能不是最优的。且最初的图**不一定连通**，一个个求最小生成树会无端多出很多时间。

我们考虑**只计算宝石能量值总和为 $0$ 的集合**，这样最后计算出的代价一定最优，且算法也更简洁。

还有点小细节，写在代码注释了。


### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10, inf=0x3f3f3f3f;
struct node{int x, y, c;} e[N];
int s[N], id[N], a[N], d[N], n, fa[N], m, dp[N]; //数组含义见上面文字
bool cmp(node n1, node n2) {return n1.c<n2.c;}
int findfa(int x) {return (fa[x]==x)? fa[x]: fa[x]=findfa(fa[x]);}
int Kruskal(int S){
    memset(fa, 0, sizeof(fa)); int ans=0;
    for(int i=1; i<=n; i++) 
        if((1<<(i-1))&S) fa[i]=i; //只有宝石i在当前集合S中时才执行

    for(int i=1; i<=m; i++){
        int x=e[i].x, y=e[i].y, c=e[i].c;
        if((!((1<<(x-1))&S)) || (!((1<<(y-1))&S))) //不在当前集合对答案无意义
            continue;
        int tx=findfa(x), ty=findfa(y);
        if(tx!=ty){
            ans+=c;
            fa[tx]=ty;
        }
    }

    int flag=-1;
    for(int i=1; i<=n; i++) if((1<<(i-1))&S){
        if(flag==-1) flag=findfa(i);
        else if(flag!=findfa(i)) return inf; //当前集合不连通，无解
    }
    return ans;

}
int main(){
    scanf("%d%d", &n, &m);
    for(int i=1; i<=n; i++) scanf("%d", &a[i]);
    for(int i=1; i<=m; i++){
        scanf("%d%d%d", &e[i].x, &e[i].y, &e[i].c);
        e[i].x++; e[i].y++;
    }

    if(m==0) {printf("0\n"); return 0;} //防止hack数据
    
    memset(s, 0, sizeof(s));
    for(int i=0; i<(1<<n); i++)
        for(int j=1; j<=n; j++) if((1<<(j-1))&i)
            s[i]+=a[j]; //s[i]存的是i集合中所有宝石的能量总和

    int len=0; memset(d, 0x3f, sizeof(d));
    sort(e+1, e+m+1, cmp); //排序之后就能保证是最小生成树
    for(int i=1; i<(1<<n); i++) if(s[i]==0){
        id[++len]=i; //当前集合i宝石的能量总和为0，记录一下
        d[i]=Kruskal(i);
    }

    memset(dp, 0x3f, sizeof(dp)); dp[0]=0;
    for(int x=1; x<=len; x++){
        int i=id[x];
        for(int j=i; j; j=(j-1)&i) //这里的j枚举的是i所有少一个1的状态 
        //因为之前记录是从小到大，所以i的子集如果合法的话一定在i之前更新了，可以放心用
            dp[i]=min(dp[i], dp[i^j]+d[j]); //状态转移
        //虽然最后dp[j]<=d[j]，但这里dp[j]有可能还没被更新，所以先用d[j]
    }
    if(dp[(1<<n)-1]==inf) printf("Impossible\n");
    else printf("%d\n", dp[(1<<n)-1]); //所有宝石传递完毕的最小代价
    return 0;
}
```

感谢观看。

 _"‌In bocca al lupo."_

---

## 作者：liangyanbang (赞：5)

[P10949 四叶草魔杖](https://www.luogu.com.cn/problem/P10949)

#### 分析

假设所有宝石都是联通的。首先观察到所有宝石的最小生成树是满足条件的一个解（但不是最优解）。

所以考虑将原图分成若干个连通子图，使得每个子图的点权值和为 $0$，且每个连通子图的最小生成树权值之和最小。

考虑 dp。设 $dp(S)$ 表示集合 $S$ 要花的最小代价，$\operatorname{MST}(S)$ 表示 $S$ 的最小生成树，$\operatorname{SUM}(S)$ 表示 $S$ 的点权之和，则有：

$$
dp(S)=\min_{T \subsetneqq S,\operatorname{SUM}(T)=0}\{dp(T)+\operatorname{MST}(S-T) \}
$$
和

$$
\operatorname{MST}(S)=\min_{(u,v,w)\in E,u\in S,v \in S}\{\operatorname{MST}(S-\{u \}+w) \}
$$

可以二进制状态压缩，预处理 $\operatorname{MST}(S)$ 的时间复杂度为 $O(m2^n)$，dp 的时间复杂度为 $O(3^n)$ （因为 $\sum_{i=0}^{n} C_n^i2^i =3^n$）。

#### 代码


```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#define reg register
using namespace std;
const int N=17;
int n,m,dp[1<<N],sum[1<<N],mst[1<<N],b[1<<N];
struct edge{
	int u,v,w;
} e[300];
int main(){
	ios::sync_with_stdio(0);
	cin>>n>>m;reg int x,y,z;
	for (int i=0;i<n;++i)cin>>sum[1<<i];
	for (int i=0;i<m;++i)cin>>e[i].u>>e[i].v>>e[i].w;
	for (int i=2;i<1<<n;++i)sum[i]=sum[i^(i&-i)]+sum[i&-i];
	memset(mst,0x3f,sizeof mst);mst[0]=0;
	for (int i=0;i<n;++i)mst[1<<i]=0;
	for (int i=1;i<1<<n;++i)
		for (int j=0;j<m;++j){
			x=e[j].u;y=e[j].v;z=e[j].w;
			if (!(i&(1<<x))||!(i&(1<<y)))continue; 
			mst[i]=min({mst[i],mst[i^(1<<x)]+z,mst[i^(1<<y)]+z});
		}
	memset(dp,0x3f,sizeof dp);dp[0]=0;
	for (reg int i=1;i<1<<n;++i){
		if (sum[i])continue;
		for (x=0,y=i;y;++x,y^=y&-y)b[1<<x]=y&-y;
		for (reg int j=0;j<1<<x;++j){
			for (y=j,z=0;y;y^=y&-y)z|=b[y&-y];
			if (sum[z])continue;
			dp[i]=min(dp[i],dp[z]+mst[i^z]);
		}
	}
	if (dp[(1<<n)-1]>=0x3f3f3f3f)cout<<"Impossible";
	else cout<<dp[(1<<n)-1];
	return 0;
}
```

---

## 作者：CJZJC (赞：5)

### 2024/10/16 更新：

- 修改了状态的枚举方式，时间复杂度变为 $O(3^n)$。

[题目传送门](https://www.luogu.com.cn/problem/P10949)

## 前言

本篇题解默认您已熟练掌握最小生成树、状压 dp 及其应用，如果您还不会，请先阅读相关博客。

## 分析

我们要选出一条边，通过边转移能量，使得所有宝石的能量都为 $0$。

这看上去挺麻烦的，让我们挖掘一下题目的性质。可以发现：

- 传递时能量总和不会变。

- 每条边的花费和传递的能量的多少没有关系。

请读者注意这两条性质，可以发现，如果一个联通块的能量总和为 $0$，则可以通过一系列的转移使得这个连通块的能量均为 $0$。

而要使一堆点联通，至少需要点数 $-1$ 条边，这就形成了一棵树，而最优的答案就是最小生成树的权值和，我们可以用 Kruskal 算法解决。

那这道题是求整个图的最小生成树吗？显然不是，因为图不连通也可能更优。

![](https://cdn.luogu.com.cn/upload/image_hosting/5kj6ciii.png)

这里给出一个例子，其中点 $1,2,3,4,5,6$ 的权值分别为 $-5,-5,10,-5,-5,10$，边权已在图中标出。

如果我们求整个图的最小生成树，求出来的答案会是 $5$，但是可以发现，我们选择 $1-2，1-3，4-5，4-6$ 这四条边也同样可以满足条件，但花费减少到了 $4$。

这时候，数据范围就有用了，题目中 $N$ 的范围为 $1 \leq N \leq 16$。我们就可以使用状压 dp 了。

设 $s_i$ 表示状态为 $i$ 时的能量总和，$calc_i$ 表示状态为 $i$ 时的最小生成树的花费，$ans_i$ 表示状态为 $i$ 时的答案。

显然，我们只需要在 $s_i = 0$ 时才计算 $calc_i$，因为在其他情况下计算 $calc_i$ 并不会被 $ans_i$ 用到。$calc_i$ 能使用 Kruskal 算法计算。并且 $calc_0=0$。

接下来考虑计算答案，答案肯定由几个能量总和为零的连通块的答案相加而来，于是可以列出如下状态转移方程：

$$ans_i = \begin{cases}
  inf & s_i \ne 0 \\
  \min_{j}^{s_j=0 \operatorname{and} j \in i}\{ans_{i \operatorname{xor} j} + calc_j\} & s_i = 0
\end{cases}$$

其中 $i,j$ 是枚举的状态。

初始 $ans_0=0$。

最终答案为 $ans_{2^n-1}$。

时间复杂度为 $O(3^n)$。

## 代码


```
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define N 16
int n, m, a[N], fa[N], dep[N], s[1 << N], calc[1 << N], ans[1 << N];
struct stu
{
    int u, v, w;
    friend bool operator<(stu a, stu b)
    {
        return a.w < b.w;
    }
} to[N * N];
int find(int x)
{
    return fa[x] == x ? x : fa[x] = find(fa[x]);
}
void merge(int x, int y)
{
    x = find(x);
    y = find(y);
    if (x == y)
    {
        return;
    }
    if (dep[x] > dep[y])
    {
        fa[y] = x;
        dep[x] += dep[y];
    }
    else
    {
        fa[x] = y;
        dep[y] += dep[x];
    }
}
int init(int x)
{
    for (int i = 0; i < n; i++)
    {
        fa[i] = i;
        dep[i] = 1;
    }
    int sum = __builtin_popcount(x) - 1, as = 0;
    if (sum <= 0)
    {
        return 0;
    }
    for (int i = 0; i < m; i++)
    {
        int u = to[i].u, v = to[i].v, w = to[i].w;
        if ((!(x & (1 << u))) || (!(x & (1 << v))))
        {
            continue;
        }
        if (find(u) == find(v))
        {
            continue;
        }
        sum--;
        as += w;
        merge(u, v);
        if (!sum)
        {
            break;
        }
    }
    if (sum != 0)
    {
        return 0x1f1f1f1f1f1f1f1f;
    }
    else
    {
        return as;
    }
}
signed main()
{
    cin >> n >> m;
    for (int i = 0; i < n; i++)
    {
        cin >> a[i];
    }
    for (int i = 1; i < (1 << n); i++)
    {
        for (int j = 0; j < n; j++)
        {
            if (i & (1 << j))
            {
                s[i] += a[j];
            }
        }
    }
    for (int i = 0; i < m; i++)
    {
        cin >> to[i].u >> to[i].v >> to[i].w;
    }
    sort(to, to + m);
    memset(calc, 0x1f, sizeof(calc));
    calc[0] = 0;
    for (int i = 1; i < (1 << n); i++)
    {
        if (s[i] == 0)
        {
            calc[i] = init(i);
        }
    }
    memset(ans, 0x1f, sizeof(ans));
    ans[0] = 0;
    for (int i = 0; i < (1 << n); i++)
    {
        if (s[i] == 0)
        {
            for (int j = i; j; j = (j - 1) & i)
            {
                ans[i] = min(ans[i], ans[i ^ j] + calc[j]);
            }
        }
    }
    int ANS = ans[(1 << n) - 1];
    if (ANS >= 1e15)
    {
        cout << "Impossible";
        return 0;
    }
    cout << ANS << endl;
    return 0;
}
```

通过仅用时 47ms。

---

## 作者：KinNa_Sky (赞：2)

没有想到最小生成树，所以暴力 dp 飞过去了？

设 $f_{sta}$ 表示 $sta$ 集合连起来的最小代价，$g_{sta}$ 表示 $sta$ 内每个数为 $0$ 的最小代价。

其中 $f$ 的转移为 $f_{sta} = \min\limits_{s \sub sta}\{ f_{s} + f_{sta \setminus s} + \operatorname{calc}(s, sta \setminus s)\}$。

$\operatorname{calc}(s, t)$ 表示两集合间的最小边。

最暴力的思路是枚举两个集合直接求，总复杂度 $O(3^nn^2)$；  
然后不难想到预处理处 $mn_{x, sta}$ 表示点 $x$ 到集合 $sta$ 的最小边，如果这时你是扫一遍 $n$ 判断 $x$ 是否在 $s$ 内的写法总复杂度 $O(3^nn)$，无法通过；  
如果你精细实现每次只找有用的点，那么总运算次数就是 $n$ 个元素集合的所有子集的总元素个数，对每个元素统计贡献可以算出运算次数是 $O(3^{n - 1}n)$，在 $n = 16$ 时需要约 $2\times 10^8$ 次运算。

幸运的是 2025 年洛谷神机开 O2 跑 2e8 如喝水般简单：  
![](https://cdn.luogu.com.cn/upload/image_hosting/c5mkx553.png)  
（1 秒 3e8 不是正常估算指标来着）

在处理完 $f$ 后计算 $g$，$g$ 实际上是考虑 $0$ 的连通块不加边的合并。  
那么初始值 $g_{sta} = \begin{cases}f_{sta} & sum_{sta} = 0 \\ +\infty & sum_{sta} \neq 0 \end{cases}$

转移有 $g_{sta} = \min\limits_{\substack{s\sub sta\\sum_s = 0}}(g_{sta}, g_{s} + g_{sta \setminus s}) \quad (sum_{sta} = 0)$。

[Code](https://www.luogu.com.cn/paste/y8593gsv) or [云剪切板站](https://www.luogu.me/paste/y8593gsv#)

---

## 作者：_zuoqingyuan (赞：2)

# 思路分析

容易发现，最后选择的边构成的图一定不会包含一个环，如果存在这种情况，把这个环中一条边去掉，元素之间的连通性不会变化，仍然可以直接或间接传递能量，且代价更小。

一种思路是先划分出联通块，然后判断每个联通块内部是否满足 $\sum A_i=0$，然后再求出每个联通块的最小生成树。把代价累加起来。

这样做也不一定是最优的，对于一个大联通块，如果我们可以把他划分成两个小联通块，且小联通块仍然满足 $\sum A_i=0$，则会得到一个权值更小的方案。

观察数据范围：$n\le 16,m\le \dfrac{n(n-1)}{2}$，显然可以使用指数级算法。

考虑状压 dp。

对于一个点集 $S$。定义 $\text{cost}(S)$ 为使满足 $u$ 联通且 $\sum_{u\in S}A_u=0$ 的最小代价。显然可以使用最小生成树算法求解。如无法满足要求 $\text{cost}(S)=\infty$。显然该函数可以预处理。

设 $dp_S$ 表示使 $\sum_{u\in S}A_u=0$ 的最小代价。则

$$dp_{S\cap T}\gets dp_S+\text{cost}(T)$$

转移的前提是 $S,T$ 交集为空。

# Code

完全图，使用 Prim 算法求最小生成树可以做到 $O(n^2)$，预处理枚举集合时间复杂度 $O(2^n)$，预处理总时间复杂度 $O(n^22^n)$。

dp 转移可以采用枚举子集的算法，时间复杂度 $O(3^n)$。总时间复杂度 $O(n^22^n+3^n)$。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
const int N=(1<<16),inf=0x3f3f3f3f;
int n,w[20][20],m,cost[N],dp[N],a[20],dis[20],mk[20];
int Prim(int s){
    memset(dis,0x3f,sizeof(dis));
    memset(mk,0,sizeof(mk));
    int cnt=0,t=s,st=0,res=0;
    for(int i=0;i<n;i++)if((s>>i)&1)st=i;
    while(t){cnt++,t-=(t&-t);}
    dis[st]=0;
    for(int i=1;i<=cnt;i++){
        st=-1;for(int j=0;j<n;j++)if(((s>>j)&1)&&!mk[j]&&(st==-1||dis[j]<dis[st]))st=j;
        if(dis[st]>=inf)return inf;mk[st]=1,res+=dis[st];
        for(int j=0;j<n;j++)if(((s>>j)&1)&&!mk[j])dis[j]=min(dis[j],w[st][j]);
    }
    return res;
}
void calc(int s){
    int res=0;
    for(int i=0;i<n;i++)if((s>>i)&1)res+=a[i];
    if(!res)cost[s]=Prim(s);
    return;
}
signed main(){
    memset(dp,0x3f,sizeof(dp));
    memset(cost,0x3f,sizeof(cost));
    memset(w,0x3f,sizeof(w));
    cin>>n>>m;
    for(int i=0;i<n;i++)cin>>a[i];
    for(int i=1,u,v,val;i<=m;i++){
        cin>>u>>v>>val;
        w[u][v]=w[v][u]=min(w[u][v],val);
    }
    for(int i=1;i<(1<<n);i++)calc(i);
    dp[0]=0;
    for(int i=0;i<(1<<n);i++){
        for(int j=i;j;j=(j-1)&i){
            dp[i]=min(dp[i],dp[i^j]+cost[j]);
        }
    }
    if(dp[(1<<n)-1]>=inf)printf("Impossible\n");
    else printf("%d\n",dp[(1<<n)-1]);
    return 0;
}
```

如有错误，请指出。

---

## 作者：minVan (赞：2)

**解题思路**

直接暴力枚举肯定过不了，考虑 dp。

也就是将原图分成若干个连通块，保证每个连通块内 $\sum a_i=0$，然后将总和加起来就可以了。

但这样的话 dp 数组相当于 $n$ 维，即就是看每一个节点是否在集合中。每一维都只有 $0,1$（选或不选）两种选择。

而 $n$ 只有 $16$，于是考虑二进制优化即状态压缩 dp，令 $f_i$ 表示将 $i$ 化为 $16$ 位二进制后如果每一位是 $1$ 那么就代表这个位数的节点在子图当中。

于是就有转移方程：

$$
f_i=\min_{i\operatorname{and}j=j}\{f_j+f_{i\operatorname{xor}j}\}
$$

初始时 $f_i=+\infty$。

每个 $f_i$ 的求法如下：

首先先算出 $f_i$ 所包含的节点个数以及 $a_i$ 的总和，如果总和不为 $0$ 或者这个子图不连通，那么均不满足条件退出。

然后就是跑一遍最小生成树，算出最小边权和，唯一的差异在于需要看每条边的两个端点是否在 $f_i$ 这个子图之内。

判断节点 $j$ 是否在 $f_i$ 的子图之内的函数如下：

```cpp
inline bool check(int x, int y) {
  return x >> y & 1;
}
```

**AC 代码，请勿抄袭。**

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 20;
int n, m, c[N], fa[N], f[70005];
struct node { int x, y, w; } e[N * N];
bool operator < (node x, node y) {
  return x.w < y.w;
}
inline int Find(int x) {
  return x == fa[x] ? x : fa[x] = Find(fa[x]);
}
inline bool check(int x, int y) {
  return x >> y & 1;
}
int main() {
  ios::sync_with_stdio(0);
  cin.tie(0), cout.tie(0);
  cin >> n >> m;
  for(int i = 0; i < n; i++) {
    cin >> c[i];
  }
  for(int i = 1; i <= m; i++) {
    cin >> e[i].x >> e[i].y >> e[i].w;
  }
  sort(e + 1, e + m + 1);
  memset(f, 0x3f, sizeof(f));
  f[0] = 0;
  for(int i = 1; i < (1 << n); i++) {
    static int s, cnt, t;
    s = cnt = t = 0;
    for(int j = 0; j < n; j++) {
      if(!check(i, j)) { continue; }
      s += c[j], fa[j] = j, ++cnt;
    }
    if(s) { continue; }
    for(int j = 1; j <= m; j++) if(check(i, e[j].x) && check(i, e[j].y)) {
      static int x, y;
      x = Find(e[j].x), y = Find(e[j].y);
      if(x == y) { continue; }
      s += e[j].w, ++t;
      fa[x] = y;
      if(t == cnt - 1) { break; }
    }
    if(t == cnt - 1) { f[i] = s; }
    for(int j = 1; j < i; j++) if((i & j) == j) {
      f[i] = min(f[i], f[j] + f[i - j]);
    }
  }
  if(f[(1 << n) - 1] != 0x3f3f3f3f) {
    cout << f[(1 << n) - 1];
  } else { cout << "Impossible"; }
  return 0;
}
```

---

## 作者：U•ェ•*U (赞：2)

本题是 $\texttt{BZOJ}$ 的原题，为啥不标明。**建议添加 $\texttt{Tags:}$ 动态规划、最小生成树、状态压缩**。

~~大眼观察法~~，发现本题可以转化成这样一个问题：将原图划分成若干个连通块，使得每个连通块内权值和为 $0$，求最小代价。

于是根据经验，不难想到 $\texttt{dp}$，但是直接以最经典的 $\texttt{dp}$ 去做的话肯定是过不了的。

再看一下，诶，$2\le n\le 16$ 可真小，于是考虑状压 $\texttt{dp}$（状态压缩动态规划），这样可以有效优化时空复杂度。

于是不妨用 $\texttt{kruscal}$ 求最小代价，然后再 $\texttt{dp}$。

我们设 $dp_i$ 表示状态为 $i$ 时最小的联通代价即可解决问题，时间上和空间上都很宽裕。

完结撒花~

---

## 作者：_jimmywang_ (赞：1)

首先传递能量是双向的，所以只需要关心点之间的连通性即可。容易发现我们的目标是选择一些边，使得最终的图中每个连通块的点权和都是 0，且选择的边权和最小。

首先如果我们对每一个 $S$ 都能算出“使子集 $S$ 连通的最小边权和”$val_S$（如果子集点权和非 0，那么 $val_S=\inf$），那么最终求解答案就是一个简单的枚举子集：$dp_S=\min_{s\subset S}(dp_s+val_{S\setminus s})$。

现在的目标转化为求解 $val_S$。注意到这就是“使图中点集连通的最小边权和”，上斯坦纳树板子即可。

---

## 作者：Polarisx (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10949)。

紫题认真的吗？

## 思路

对于一个点集 $S$，要让它能量归零当且仅当这个点集的 $a_i$ 和为 $0$，最小代价显然是该点集导出子图的最小生成树边权之和，容易发现最终选择的边一定是由若干个最小生成树拼凑而成的，再结合数据范围，我们可以直接上子集 DP，时间复杂度 $\mathcal O(2^nn^2\log m+3^n)$。

可以用子集 exp 优化到 $\mathcal O(2^nn^2\log m+2^nn^2)$，不过没什么必要。

```cpp
#include <bits/stdc++.h>
#define ll long long 
using namespace std;

const int Maxn=110;
const ll inf=1e15;
int n,m;
int a[Maxn];
int G[Maxn][Maxn];
ll g[1<<16|5];

struct edg{
    int u,v,w;
}E[Maxn];
int tot,f[Maxn];

int qfind(int key){
    return f[key]==key?key:f[key]=qfind(f[key]);
}

int main(){
    scanf("%d%d",&n,&m);
    for(int i=0;i<n;i++) scanf("%d",&a[i]);

    memset(G,-1,sizeof G);
    for(int i=0;i<m;i++){
        int u,v,w;
        scanf("%d%d%d",&u,&v,&w);
        G[u][v]=w;
    }
    for(int i=0;i<(1<<n);i++){
        tot=0; ll sm=0;
        for(int j=0;j<n;j++) f[j]=j;
        for(int j=0;j<n;j++) if(i>>j&1) sm+=a[j];
        if(sm!=0){
            g[i]=inf;
            continue;
        }
        for(int j=0;j<n;j++)
            for(int k=0;k<n;k++)
                if(G[j][k]!=-1 and i>>j&1 and i>>k&1)
                    E[++tot]=(edg){j,k,G[j][k]};
        sort(E+1,E+tot+1,[](edg x,edg y){
            return x.w<y.w;
        });
        ll ret=0; int cnt=0;
        for(int j=1;j<=tot;j++){
            int u=qfind(E[j].u),v=qfind(E[j].v);
            if(qfind(u)!=qfind(v)){
                f[v]=u; ++cnt;
                ret+=E[j].w;
            }
        }
        int p=__builtin_popcount(i); 
        
        if(cnt==p-1) g[i]=ret; else g[i]=inf;
    }
    for(int i=0;i<(1<<n);i++)
        for(int j=i;j;j=i&(j-1))
            g[i]=min(g[i],g[i^j]+g[j]);

    ll ans=g[(1<<n)-1];
    if(ans==inf){
        puts("Impossible");
        return 0;
    }
    printf("%lld",ans);
    

    return 0;
}
```

---


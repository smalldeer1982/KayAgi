# [NOI2015] 寿司晚宴

## 题目描述

为了庆祝 NOI 的成功开幕，主办方为大家准备了一场寿司晚宴。小 G 和小 W 作为参加 NOI 的选手，也被邀请参加了寿司晚宴。

在晚宴上，主办方为大家提供了 $n−1$ 种不同的寿司，编号 $1,2,3,\ldots,n-1$，其中第 $i$ 种寿司的美味度为 $i+1$。（即寿司的美味度为从 $2$ 到 $n$）

现在小 G 和小 W 希望每人选一些寿司种类来品尝，他们规定一种品尝方案为不和谐的当且仅当：小 G 品尝的寿司种类中存在一种美味度为 $x$ 的寿司，小 W 品尝的寿司中存在一种美味度为 $y$ 的寿司，而 $x$ 与 $y$ 不互质。

现在小 G 和小 W 希望统计一共有多少种和谐的品尝寿司的方案（对给定的正整数 $p$ 取模）。注意一个人可以不吃任何寿司。


## 说明/提示

【数据范围】


 ![](https://cdn.luogu.com.cn/upload/pic/1506.png) 


**勘误：$0 < p \le 10^9 $**

## 样例 #1

### 输入

```
3 10000```

### 输出

```
9```

## 样例 #2

### 输入

```
4 10000```

### 输出

```
21```

## 样例 #3

### 输入

```
100 100000000```

### 输出

```
3107203```

# 题解

## 作者：Orion545 (赞：164)

# 广告

[这里观赏体验更佳](https://www.cnblogs.com/dedicatus545/p/9261536.html)

# 思路

首先，要让两个人选的数字全部互质，那么有一个显然的充要条件：甲选的数字的质因数集合和乙选的数字的质因数集合没有交集

### 30pt

这种情况下n<=30，也就是说可用的质数只有10个，我们可以开个状压搞一搞

设$dp[S_1][S_2]$表示甲选择的质因数集合是$S_1$，乙是$S_2$的总情况数，

对于每个2-n分解质因数，把每个质因数是否出现状压起来存下来，dp的时候从前往后扫

那么可以刷表法做一波$dp[i][S_1|k][S_2]+=dp[i-1][S_1][S_2](k\;bitand\;S_2=0)$，或者$dp[i][S_1][S_2|k]+=dp[i-1][S_1][S_2](k\;bitand\ S_1=0)$，其中k是当前数的质因数集合，$bitand$是位与

滚动数组优化一下，把第一维去掉，总效率是$O(2^{20}n)$

### 100pt

这时有什么变化了呢？没错，n到了500以后可用的质因数变多了，我们无法把它们全部都压进一个数里面了

注意到，一个小于500的数，最多只可能有1个比22大的质因子

所以我们可以把这个质因子单独拿出来记录一下（没有就记为0）

然后，我们把2-n这些数按照大质因子大小排序，这样令大质因子相同的数排在一起（也就是不能甲乙同时选的）

我们记录三个相同数组：$dp[S_1][S_2],f1[][],f2[][]$，因为小质因数只有8个，所以$0\leq S_1,S_2\leq 255$

对于每一段大质因子相同的数，我们在这一段开始的时候把dp的值赋给f1和f2，然后在这一段内部用刷表法推f1和f2

具体来说这么做

$f1[i][S_1|k][S_2]+=f1[i-1][S_1][S_2](k\;bitand\;S_2=0)$

或者$f2[i][S_1][S_2|k]+=f2[i-1][S_1][S_2](k\;bitand\;S_1=0)$

其中k是当前数的**小**质因数集合（只有8个二进制位了）

大家应当看出来了，f1表示的就是这个大质因子让第一个人选，f2就是这个大质因子让第二个人选

这一段数推完以后，再把f1f2合并到dp里面，$dp[S_1][S_2]=f1[S_1][S_2]+f2[S_1][S_2]-dp[S_1][S_2]$

这里减掉一个dp是因为两种情况会重复统计两个人都不选的情况（也就是原来的dp[S_1][S_2]的值），减掉即可

最后答案就是$dp[0-255][0-255]$的和了

总时间复杂度为$O(n2^{16})$（居然比30pt做法还快【滑稽】）

# Code:

详细的实现见代码

```cpp
// luogu-judger-enable-o2
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll long long
using namespace std;
inline int read(){
    int re=0,flag=1;char ch=getchar();
    while(ch>'9'||ch<'0'){
        if(ch=='-') flag=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();
    return re*flag;
} 
int n,MOD;
int p[10]={0,2,3,5,7,11,13,17,19,0};
struct node{
    int val,big,S;//big就是大质因数，S是小质因数集合
    void init(){
        int i,tmp=val;big=-1;
        for(i=1;i<=8;i++){//分解质因数
            if(tmp%p[i]) continue;
            S|=(1<<i-1);
            while(tmp%p[i]==0) tmp/=p[i];
        }
        if(tmp!=1) big=tmp; 
    }
}a[510];
inline bool cmp(node l,node r){
    return l.big<r.big;
}
int pl(int l,int r){
    l+=r;
    return l>=MOD?l-MOD:l;
}
int dp[300][300],f1[300][300],f2[300][300];
int main(){
    n=read();MOD=read();int i,j,k;
    for(i=2;i<=n;i++) a[i-1].val=i,a[i-1].init();
    sort(a+1,a+n,cmp);
    dp[0][0]=1;
    for(i=1;i<n;i++){
        if(i==1||a[i].big!=a[i-1].big||a[i].big==-1){
            memcpy(f1,dp,sizeof(f1));
            memcpy(f2,dp,sizeof(f2));
        }
        for(j=255;j>=0;j--){
            for(k=255;k>=0;k--){//因为是滚动数组，所以一定要倒着推
                if(j&k) continue;
                if((a[i].S&j)==0) f2[j][k|a[i].S]=pl(f2[j][k|a[i].S],f2[j][k]);
                if((a[i].S&k)==0) f1[j|a[i].S][k]=pl(f1[j|a[i].S][k],f1[j][k]);
            }
        }
        if(i==n-1||a[i].big!=a[i+1].big||a[i].big==-1){
            for(j=0;j<=255;j++){
                for(k=0;k<=255;k++){
                    if(j&k) continue;
                    dp[j][k]=pl(f1[j][k],pl(f2[j][k],MOD-dp[j][k]));
                }
            }
        }
    }
    ll ans=0;
    for(j=0;j<=255;j++){
        for(k=0;k<=255;k++){
            if((j&k)==0&&dp[j][k]) ans=pl(ans,dp[j][k]);
        }
    }
    cout<<ans;
}
```

---

## 作者：翼德天尊 (赞：88)

萌新刚学状压 DP，所写如有不足，还望指出勿喷qwq

------------

### 题目大意

给定 $n-1$ 个正整数 $2,3,4\dots n$ 和两个集合，要将数装进集合中，要求两个集合的元素必须两两互质，求集合装数的总方案数。

------------

### 算法选择

都说这道题是状压 DP，那么问题来了，为什么是状压 DP 呢？

~~标签上写了~~

第一点是因为要求总方案数，DP 显然是不二选择。


第二点肯定是由于数据范围。观察到数据范围中 $n\le 500$，好像并不大，$500$ 以内质数个数有限，状压 DP 貌似可做。

第三点是如果考虑将盒子内的质数压成一个二进制状态，那么判断盒子内元素是否冲突只需要运用逻辑与运算即可，简单便捷。

所以，我们就使用状压 DP 做本题啦！

-----------

### 做法浅谈

#### 设计 dp 数组

既然确定是状压 DP，并且是要求方案数，那么 dp 数组当然就很好想了。考虑采用一般状压 DP 【处理到的地方】+【状态】的状态设计方式，我们可以用 $dp_{i,S,T}$ 表示当处理到前 $i$ 个数时，第一个集合状态为 $S$，第二个集合状态为 $T$ 时的总方案数。

又由于当我们处理到第 $i$ 个数字时，关于前 $i-1$ 个数字的状态是没有用的，所以我们可以采用滚动数组的方式，省去第一维。所以最终的状态设计为：
$$dp_{S,T}$$

#### 考虑转移

由于我们已经决定将每一个集合表示成一个二进制状态，所以我们的第一个想法肯定是用这个二进制状态的第 $i$ 位来表示这个集合中是否存在第 $i$ 个质数。

但是当查到 $500$ 以内的质数有 $95$ 个的时候，我便放弃了这个念头。

那怎么办呢？

考虑到一个关于质因子的性质：一个数的质因子最多只能有一个大于自己的算术平方根。（废话，有两个乘积就不是它了）所以我们可以考虑将所有的数按照大于算数平方根质因子（以下简称大质因子）分组。

对于相同大质因子的数，我们将 $dp$ 数组分成两个，分别表示只放入第一个集合和只放入第二个集合，并且分别进行 DP，这样才能保证这些数要不进第一个集合，要不进第二个集合，要不都不进，不会存在两个集合含有同样大质因子的数的情况。如此以来，我们就只关心小质因子的放入情况了，所以每一个状态只需要 $8$ 位（$500$ 的算术平方根为 $22$，其中只有 $8$ 个质数）即可。

每一组的数 DP 完之后，我们将两个 $dp$ 数组合到一块即可。处理贡献是由于这两个数组都还有原式数组的答案，所以需要再减去一个原式数组的答案，即：

```cpp
for (ll j=0;j<=255;j++)
	for (ll k=0;k<=255;k++){//枚举两个集合的状态
		if (j&k) continue;//两个集合不能冲突
		dp[j][k]=(dp1[j][k]+dp2[j][k]-dp[j][k]+p)%p;//处理贡献
}
```


那么对于分开的每一个 $dp$ 数组具体怎么转移呢？

很简单，设我们用 $dp1$ 数组代表只放入第二个集合的 $dp$ 数组，那么只要当前的数的质因子状态不和第一个集合冲突，我们都可以将放入该数后的 $dp1$ 数组加上原数组所做的贡献。$dp2$ 数组同理。

#### 统计答案

最后我们将 $dp$ 数组所有的合法状态相加即为答案。

注意方案数过多，记得开 `long long`。



------------


### 无注释 AC 代码

本题代码部分参考了题解中的代码，如觉结构相似，请勿责怪，思路第一，代码次之。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define N 505
ll n,p,dp[N][N],dp1[N][N],dp2[N][N],zhi[9]={2,3,5,7,11,13,17,19};
struct node{
	ll b,S,w;
}s[N];
ll read() {
	ll w=0,f=1;
	char c=getchar();
	while (c>'9'||c<'0') {
		if (c=='-') f=-1;
		c=getchar();
	}
	while (c>='0'&&c<='9') {
		w=(w<<3)+(w<<1)+(c^48);
		c=getchar();
	}
	return w*f;
}
void query(ll x){
	s[x].w=x;
	ll xx=x;
	for (int i=0;i<8;i++)
		if (xx%zhi[i]==0){
			s[x].S|=(1<<i);
			while (xx%zhi[i]==0) xx/=zhi[i];
		}
	if (xx^1) s[x].b=xx;
} 
bool tmp(node x,node y){
	return x.b<y.b;
}
int main() {
	n=read(),p=read();
	for (int i=2;i<=n;i++) query(i);
	sort(s+2,s+1+n,tmp);
	dp[0][0]=1;
	for (int i=2;i<=n;i++){
		if (s[i].b^s[i-1].b||!s[i].b){
			memcpy(dp1,dp,sizeof(dp));
			memcpy(dp2,dp,sizeof(dp));
		}
		for (ll x=255;x>=0;x--)
			for (ll y=255;y>=0;y--){
				if (x&y) continue;
				if ((s[i].S&x)==0) dp1[x][y|s[i].S]=(dp1[x][y|s[i].S]+dp1[x][y])%p;
				if ((s[i].S&y)==0) dp2[x|s[i].S][y]=(dp2[x|s[i].S][y]+dp2[x][y])%p;
			}
		if (i==n||s[i].b^s[i+1].b||!s[i].b)
			for (ll j=0;j<=255;j++)
				for (ll k=0;k<=255;k++){
					if (j&k) continue;
					dp[j][k]=(dp1[j][k]+dp2[j][k]-dp[j][k]+p)%p;
				}
	}
	ll ans=0;
	for (int i=0;i<=255;i++)
		for (int j=0;j<=255;j++){
			if (i&j) continue;
			ans=(ans+dp[i][j])%p;
		}
	printf("%lld\n",ans);
	return 0;
}
```

**如果对你有一定的帮助，请点个赞支持一下吧qwq**

---

## 作者：ethan_zhou (赞：43)

[更好的阅读体验](https://www.blog-e.top/2021/05/27/%E9%A2%98%E8%A7%A3-%E5%AF%BF%E5%8F%B8%E6%99%9A%E5%AE%B4/)

> upd 2021.6.18: 修改公式符号，更加形式化，添加 $50$ 分做法
>
> upd 2022.7.30: 修改转移方程的笔误，修改公式符号

介绍一种 $O(n \times 3^8)$ 的做法，目前是所有非打表代码中的最优解，~~其实只是把其他题解中的算法优化了一下。~~

## 定义

- $fac_i$ 表示 $i$ 的质因数集合
- $P=\{x\mid x\ \text{is prime},\ x\le n\}$

## 暴力 1

这题的暴力有很多种，在此只介绍可以优化成正解的暴力。

两个数互质，等效于他们没有共同的质因子，所以只需把每个数都分解质质因数，如下 dp：

- 状态：$dp(s_1,s_2)$ 表示考虑前 $i$ 个数（$i$ 被滚动掉了），小 G 选的数的包含的质因数集合为 $s_1$，小 W 的质因数集合为 $s_2$ 的情况数。
- 转移：

$$
\begin{aligned}
dp(s_1\cup fac_i,s_2)\leftarrow dp(s_1,s_2)+dp(s_1\cup fac_i,s_2)&\ &(fac_i\cap s_2=\varnothing)\cr
dp(s_1,s_2\cup fac_i)\leftarrow dp(s_1,s_2)+dp(s_1,s_2\cup fac_i)&&(fac_i\cap s_1=\varnothing)
\end{aligned}
$$

- 答案：

$$
\sum _{s_1,s_2 \subset P}{dp(s_1,s_2)\ (s_1\cap s_2=0))}
$$

复杂度 $O(n\times2^{20})$，能得 $30$ 分。

## 暴力 2

（该部分分对正解启发不大，一笔带过）

$dp(s)$ 表示在 前 $i$ 个数中，选的数质因数集合恰好为 $s$ 的情况数。然后再算出 $dp$ 的子集和，即 $f(s)=\sum_{i \subset s} dp(i)$ ，答案便是 $\sum _{i\subset P}dp(i)f(P \setminus i)$。

仅仅这样还是不够的，因为小于一百的质数有 $25$ 个，但是发现大于 $50$  的每个质因数只可能出现一次，所以我们可以只考虑剩下的小于等于 $50$ 的 $15$ 个质数，最后将答案乘以 $3^{\pi(n)-\pi(50)}$ 即可，可得 $50$ 分。

## 正解

$n \le 500$，则小于 $n$ 的质数大概有一百个了，仿佛就无法状压了。但经过仔细观察（看题解），发现每个数只可能有一个大于 $\sqrt{500}$ 的质因数，也就是说，每个数除了这个最大质因数之外，剩下的质因数都小于 $19$。

小于 $19$ 的质因数只有 $8$ 个，不难状压，所以我们只要考虑如何排除那些大质因数的干扰。

考虑将这些数按其**大质因数**排序，则大质因数相同的一个连续段中的每个数要么**只被小 G 选或不被选**，要么**只被小 W 选或不被选**。

考虑如下 dp：
- $dp(s_1,s_2)$ 含义与**暴力 1** 中的差不多，只不过这里的 $s_1$，$s_2$ 只状压了前 8 个质数的状态。
- 每次进入一个新的连续段，把 $dp$ 中的值复制到 $t_1，t_2$ 中。
	- 用 $t_1(s_1,s_2)$ 表示这个连续段中的数**只被小 G 选或不被选**的情况数
	- 用 $t_2(s_1,s_2)$ 表示这个连续段中的数**只被小 W 选或不被选**的情况数
	- 转移：
    
     $$\begin{aligned}
	   t_1(s_1\cup fac_i,s_2)\gets t_1(s_1\cup fac_i,s_2)+t_1(s_1,s_2)&\ &(fac_i\cap s_2=\varnothing)\cr
	   t_2(s_1,s_2\cup fac_i)\gets t_2(s_1,s_2\cup fac_i)+t_2(s_1,s_2)&&(fac_i\cap s_1=\varnothing)\cr
	   \end{aligned}$$
  
- 这个连续段结束之后，再用 $t_1$，$t_2$ 中的值更新 $dp$ 值：

$$
dp(s_1,s_2)\gets t_1(s_1,s_2)+t_2(s_1,s_2)-dp(s_1,s_2)
$$

为什么要减去 $dp(s_1,s_2)$ 呢？因为这一段中所有数都不选的情况被算了两次（$t_1$，$t_2$ 各一次）。

## 小优化

截止目前，算法复杂度还是 $O(n \times 4^8)$ 的，但是不难发现对于一个合法状态，是要求 $s_1$，$s_2$ 交为空的。因此真正有用的状态数只有 $3^8$ 量级。
所以我们可以如下枚举 $s_1$ 和 $s_2$：

```cpp
int ALL=1<<8;
for(int s1=ALL-1;~s1;s1--){//因为是滚动数组，所以集合必须从大到小枚举
	int tmp=(ALL-1)^s1;//s2 必定是 tmp 的子集
	for(int s2=tmp;s2;s2=(s2-1)&tmp)
		//blabla...
	//单独处理 s2=0 的情况
}
```


## 代码


```cpp
#include<bits/stdc++.h>
using namespace std;

#define fi first
#define se second
typedef pair<int,int> pi;

const int MXPRI=8;
const int ALL=1<<MXPRI;
const int MXN=505;
const int pri[]={2,3,5,7,11,13,17,19};

int n,p,dp[ALL][ALL],t1[ALL][ALL],t2[ALL][ALL];
pi arr[MXN];
inline int mod(int x){return x<p?x:x-p;}

int main(){
	scanf("%d%d",&n,&p);
	for(int i=2,j;i<=n;i++)
		for(arr[i].fi=i,j=0;j<MXPRI;j++)
			while(arr[i].fi%pri[j]==0)
				arr[i].fi/=pri[j],arr[i].se|=1<<j;
	sort(arr+2,arr+n+1);
	t1[0][0]=1;
	for(int i=2;i<=n;i++){
		if(arr[i].fi==1 || arr[i].fi!=arr[i-1].fi)
			for(int s1=ALL-1;~s1;s1--){
				int tmp=(ALL-1)^s1;
				for(int s2=tmp;s2;s2=(s2-1)&tmp)
					t1[s1][s2]=t2[s1][s2]=dp[s1][s2]=mod(p-dp[s1][s2]+mod(t1[s1][s2]+t2[s1][s2]));
				t1[s1][0]=t2[s1][0]=dp[s1][0]=mod(p-dp[s1][0]+mod(t1[s1][0]+t2[s1][0]));
			}

		for(int s1=ALL-1,fac=arr[i].se;~s1;s1--){
			int tmp=(ALL-1)^s1;
			for(int s2=tmp;s2;s2=(s2-1)&tmp){
				if(!(fac&s2))t1[s1|fac][s2]=mod(t1[s1|fac][s2]+t1[s1][s2]);
				if(!(fac&s1))t2[s1][s2|fac]=mod(t2[s1][s2|fac]+t2[s1][s2]);
			}
			t1[s1|fac][0]=mod(t1[s1|fac][0]+t1[s1][0]);
			if(!(fac&s1))t2[s1][fac]=mod(t2[s1][fac]+t2[s1][0]);
		}
	}
	int ans=0;
	for(int s1=ALL-1;~s1;s1--){
		int tmp=(ALL-1)^s1;
		for(int s2=tmp;s2;s2=(s2-1)&tmp)
			ans=mod(ans+mod(p-dp[s1][s2]+mod(t1[s1][s2]+t2[s1][s2])));
		ans=mod(ans+mod(p-dp[s1][0]+mod(t1[s1][0]+t2[s1][0])));
	}
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：C20203030 (赞：25)

**UPD 2020/12/4**：看这篇题解好像有些同学在看欸，但是原来是我一年半之前写的博客，难以讲清楚这么难的题目，现在我已经把整篇文章重构了一遍，希望能对你们有所帮助。

## 一、题目

**题意：**

有$[2,n]$一共$n-1$个数，两个人分别取子集$S$和$T$，要求不存在$x\in S,y\in T$，使得$gcd(x,y)\not= 1$

**数据范围：**

对于$30\%$的数据，$2\leq n\leq30$

对于$100\%$的数据，$2\leq n\leq 500$

## 二、解法

**0x01 暴力**

$gcd$ 容易想到用所含的质数是否有交来判断，考虑用一个质数集合表示我们的数集，而且质数在 $n\leq 30$ 的时候也不是很多，那么状压质数集合，设 $dp[j][k]$ 为 $S$ 的质数集合是 $j$，$T$ 的质数集合是 $k$ 的方案数，转移需要保证 $j$ 和 $k$ 永远不交，先把每个数质因数分解以后再做转移。

设新加进来的数的质因数集合为 $s$，那么转移就不难写出了：

$$dp[j|s][k]=dp[j][k]\;\;\; k\&s=0$$

$$dp[j][k]=dp[j][k|s]\;\;\;j\&s=0$$

时间复杂度$O(n\times 2^{10})$，那么就拿到了 $30$ 分的高分！

**0x02 优化**

好，现在我们面对的数据范围是 $n\leq500$，看似这个数据范围是非常恐怖的，$500$ 以内的质数如何状压？

但是你会发现很多质数是特殊的，学过最普通的判断质数方法的同学就知道：大于 $\sqrt n$ （本题是 $22$）的质数至多有一个，这个部分和第一个部分的区别就在这里，不要怕，问题仅仅是__多了这一些特殊的质数__

如何利用这一性质，请记住：__当你发现有题（无关顺序，排序对其无影响）做不动时，排序永远是你最坚强的后盾（无论是 $dp$ 还是贪心，排序可以让 $dp$ 更快）__，现在我们来考虑能否排序？

其实是可以的，我们把这些数__按他们的大质数排序__，那么大质数相同的这些数就__不能放在一起__，而只能放在一边了。可能读者还没有特别激动，但这是一条多么美妙的性质啊！

利用那条性质，我们设 $f_1[j][k]$ 为大质数放 $j$ 一边的方案数，$f_2[j][k]$ 表示大质数放 $k$ 一遍的方案数，不难发现两者的转移是独自进行的，所以用 $\tt 0x01$ 的方法就可以了。但这个状态仅仅对于一段大质数相同的数，过了这一段大质数相同的数之后我们就要干一些事情。

其实就是把 $f_1$ 和 $f_2$ 合并嘛，因为过了这一段之后讨论的就不是这个大质数了，所以就不用管了，合起来进入后面的阶段。在进入这个阶段前假设我们得到的 $dp$ 数组是 $dp’[i][j]$ 那么这个阶段结束过后的 $dp[i][j]$ 就要用 $f_1[j][k]+f_2[j][k]-dp[j][k]$ 来表示了，减掉他不需要多说吧，毕竟他是惟一相同的部分。

总结一下，当你看出大质数时，知道排序是永远滴神就可以做出此题。

**0x03 代码**

以前是照着第一篇题解写的，现在懒得新写一遍了，我有自信我讲清楚了


```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
#define LL long long
LL read()
{
	LL x=0,flag=1;char c;
	while((c=getchar())<'0' || c>'9') if(c=='-') flag=-1;
	while(c>='0' && c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return x*flag;
}
LL n,ans,mod;
LL dp[300][300],f1[300][300],f2[300][300];
int p[10]={0,2,3,5,7,11,13,17,19,0};
struct node
{
	LL val,big,S;
	bool operator < (const node &x) const {
		return big<x.big;
	}
	void init()
	{
		LL tmp=val;big=-1;
		for(LL i=1;i<=8;i++)
		{
			if(tmp%p[i]==0) S|=(1<<i-1);
			while(tmp%p[i]==0)
				tmp/=p[i];
		}
		if(tmp^1) big=tmp;
	}
}a[505];
int main()
{
	n=read();mod=read();
	for(LL i=2;i<=n;i++)
		a[i].val=i,a[i].init();//预处理每个数的质因数集合与它的大质数
	sort(a+2,a+1+n);//把大质数相同的放一起讨论
	dp[0][0]=1;
	for(LL i=2;i<=n;i++)
	{
		if(i==1 || a[i].big^a[i-1].big || a[i].big==-1)//如果都没有大质数或大质数不一样，就可以继承上一层合并的答案。（特判初始化） 
		{
			memcpy(f1,dp,sizeof dp);
			memcpy(f2,dp,sizeof dp);
		}
		for(LL j=255;j>=0;j--)//滚动数组 
			for(LL k=255;k>=0;k--)
			{
				if(j&k) continue;
				if((a[i].S&j)==0) f1[j][k|a[i].S]=(f1[j][k|a[i].S]+f1[j][k])%mod;
				if((a[i].S&k)==0) f2[j|a[i].S][k]=(f2[j|a[i].S][k]+f2[j][k])%mod;
			}
		if(i==n || a[i].big^a[i+1].big || a[i].big==-1)//如果都没有大质数或大质数不一样（跟下一层比较），则可以合并答案（特判结束） 
		{
			for(LL j=0;j<=255;j++)
				for(LL k=0;k<=255;k++)
				{
					if(j&k) continue;
					dp[j][k]=(f1[j][k]+f2[j][k]-dp[j][k]+mod)%mod;//减去重复的情况 
				}
		}
	}
	for(LL i=0;i<=255;i++)//统计答案 
		for(LL j=0;j<=255;j++)
		{
			if(i&j) continue;
			ans=(ans+dp[i][j])%mod;
		}
	printf("%lld\n",ans);
}
```

---

## 作者：Mr_HY43205 (赞：20)

[P2150 [NOI2015] 寿司晚宴](https://www.luogu.com.cn/problem/P2150)

### 题意
有一个 $n - 1$ 元素集合，从中选出两不相交子集 $G$ 和 $W$，使得 $\forall \ x\in G,y\in W$，有 $(x,y)=1$。求符合条件的方案数 $\bmod\ p$ 的值。

注：
1. $G,W$ 可以为 $\varnothing$；
1. $G,W$ 互换算两种不同方案。

###### 数据范围：
$2\leq n\leq 500,0<p\leq 10^{10}$。

###### 关键词：状态压缩动态规划，质数

------------
### 解题思路
本题分两部分进行说明：$30$ 分部分分和 $100$ 分正解
##### 30分：$2\leq n\leq 30$
首先，我们发现一个方案符合条件，当且仅当 $G$ 和 $W$ 中所包含的数的质因数不同。根据这个性质，可以想到枚举两边各自包含了哪些质因数。在这个部分分的数据范围中，$n\leq 30$，而 $30$ 以内的质数只有 $10$ 个。因此，我们可以使用状态压缩来记录每一个集合中各自包含了哪些质因数，从而用动态规划来求解。

动态规划的状态需要的是目前已考虑到的数，以及两个集合中各自包含的质因数。设 $f(i,G,W)$ 表示目前考虑到 $i$，小 G 集合中的质因数情况为 $G$，小 W 集合中的质因数情况为 $W$ 时的方案数。假设 $i$ 本身的质因数情况为 $sta$，递推方程为：
$$f(i,G|sta,W)=(f(i,G|sta,W)+f(i-1,G,W))\bmod\ p	,\ \text{if}\ sta\ \&\ W =0$$
$$f(i,G,W|sta)=(f(i,G,W|sta)+f(i-1,G,W))\bmod\ p,\ \text{if}\ sta\ \&\ G =0$$
在递推时，$G\ \&\ W\neq0$ 表示两边包含的质因数有重复，可以直接跳过。

$f$ 数组初始化为 $0$，初值为 $f(1,0,0)=1$。最终答案就是 $\sum\limits_{G\ \&\ W =\ 0}f(n,G,W)$。

由于对每一个质数来说，只可能在 $G$ 中出现，或在 $W$ 中出现，或者都不出现，共三种情况，因此该算法时间复杂度为 $O(n\cdot3^{10})$，空间复杂度为 $O(n\cdot4^{10})$。本题的空间限制（在洛谷）为 125MB，因此在实际应用上需要使用滚动数组把 $n$ 这一维空间省略掉。同时，在滚动数组更新时，需要每一次使用都把当前这一轮的数据清空。综上，本题的空间复杂度优化到 $O(4^{10})$，可以通过 $30$ 分部分分。

$30$ 分关键代码如下：

```cpp
int prime[11] = {1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29};
ll f[2][1 << 10][1 << 10];

    f[1][0][0] = 1;
    int cur = 0, old = 1;
    for (int i = 2; i <= n; i++, cur ^= 1, old ^= 1) {
        int sta = 0, tmp = i, idx = 1;
        while (tmp != 1) {
            if (tmp % prime[idx] == 0) {
                while (tmp % prime[idx] == 0)
                    tmp /= prime[idx];
                sta ^= 1 << (idx - 1);
            }
            idx++;
        }
        for (int G = 0; G <= all; G++)
            for (int W = 0; W <= all; W++)
                f[cur][G][W] = f[old][G][W];
        for (int G = 0; G <= all; G++) {
            for (int W = 0; W <= all; W++) {
                if (G & W) continue;
                if (!(sta & W)) f[cur][G | sta][W] = (f[cur][G | sta][W] + f[old][G][W]) % p;
                if (!(sta & G)) f[cur][G][W | sta] = (f[cur][G][W | sta] + f[old][G][W]) % p;
            }
        }
    }
```

在研究 $100$ 分数据范围之前，我们先来考虑一下上述算法还有什么优化空间。

有一些性质，可能之后不会全部用到，但是可以探索一下：

- 如果两个数所包含的质因数种类一样，那么我们就可以把它们统一计算。
- $500$ 以内的数包含的质因数种类不会超过 $4$ 种。
- 对于 $500$ 以内的数，其单个质因数的次数不会很高。
- 如果使用刚才的递推方法，那数字的顺序对答案是没有影响的。

有了这些性质，我们来思考一下 $100$ 分的做法。

##### 100分：$2\leq n\leq 500$
到了这一个数据范围，以上的算法就不适用了。$500$ 以内的质数有 $95$ 个，显然无法使用状态压缩。

从上述的几个性质出发，有一些初步的设想：比如可以只考虑一个数中每个质因数的次数只有一次的情况，然后通过计算质因数次数进行统计。于是我们发现，只有小于等于 $\sqrt n$ 的质数才可能在一个数中出现大于 $1$ 次。对于一个大于 $\sqrt n$ 的质数 $bigp_i$，不可能有一个数包含 $bigp_i^k,k>1$。

在 $n\leq 500$ 时，小于 $\sqrt n$ 的质数最多只有 $8$ 个。

既然如此，我们可以直接用状态压缩的方法记录前 $8$ 个质数，而对更大的质数进行单独处理。

根据我们之前的性质，数字的顺序对于最终答案没有影响。因此，我们可以把含有同一个大质数的数排列到一起，分成一段一段进行计算。

由于对于一个大质数 $bigp_i$，其只可能在 $G$ 中出现，或在 $W$ 中出现，或不出现，因此对于一个连续的包含 $bigp_i$ 的段，我们需要记录两个数组 $g(i,G,W)$ 和 $w(i,G,W)$，分别表示只有小 G 包含 $bigp_i$ 或只有小 W 包含 $bigp_i$ 时的方案数。

当数字中不包含大质数时，递推方程与之前相同。

当数字中包含大质数时，对于 $g$ 和 $w$，其递推方法如下：

1. 对于一个新的包含 $bigp_i$ 的段，$g$ 和 $w$ 的方案数和 $f$ 相同，递推方程有：
$$g(i,G,W)=w(i,G,W)=f(i,G,W)$$
2. 在同一段内：
- 对于 $f$ 来说，$f$ 表示两边都不选 $bigp_i$ 的方案数，因此没有变化。
- 对于 $g$ 来说，可以在已有 $bigp_i$ 的基础上加入 $bigp_i$，也可以在没选过 $bigp_i$ 的基础上加入 $bigp_i$。
- 对于 $w$ 来说同理。于是，递推方程有：
$$f(i,G,W)=f(i-1,G,W)$$
$$g(i,G|sta,W)=(g(i,G|sta,W)+g(i-1,G,W)+f(i,G,W)) \bmod\ p,\ \text{if}\ sta\ \&\ W =0$$
$$w(i,G,W|sta)=(w(i,G,W|sta)+w(i-1,G,W)+f(i,G,W)) \bmod\ p,\ \text{if}\ sta\ \&\ G =0$$

3. 如果一段结束了，要将总方案数记入 $f$，于是有：
$$f(i,G,W)=(f(i-1,G,W)+g(i-1,G,W)+w(i-1,G,W))\bmod\ p$$

以上就是整个的动态规划方程。其余的初始化、初值、结果与之前 $30$ 分时的方程一样。

还有一个问题，就是为什么不能对所有质数进行这样的计算，而要对大于 $\sqrt n$ 的质数单独计算呢？

对于小于等于 $\sqrt n$ 的质数，一个数中除了这个小质数还可能有另一个大质数，也就无法使用之前的方法进行单独计算。

这个方程的时间复杂度为 $O(n\cdot3^8)$，使用滚动数组后，空间复杂度为 $O(4^8)$，可以通过 $100$ 分的数据。

代码如下：
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

#define ll long long
const int maxN = 505;
int n;
ll p;
int bigp[maxN], sta[maxN], od[maxN], all = (1 << 8) - 1;
//bigp记录每个数中包含的大质数，如果没有则为1
//sta记录每个数中小质数的出现情况
//od记录递推顺序
int prime[8] = {2, 3, 5, 7, 11, 13, 17, 19};
ll f[2][1 << 8][1 << 8], g[2][1 << 8][1 << 8], w[2][1 << 8][1 << 8], ans = 0;

bool cmp(int a, int b) {		//对每个数包含的大质数排序函数
    if (bigp[a] != bigp[b]) return bigp[a] < bigp[b];
    else return a / bigp[a] < b / bigp[b];
}

int main() {
    cin >> n >> p;
    for (int i = 2; i <= n; i++) {	//预处理每个数的bigp，sta和od
        int t = i;
        for (int idx = 0; idx < 8; idx++) {
            if (t % prime[idx] == 0) {
                sta[i] ^= 1 << idx;
                while (t % prime[idx] == 0) t /= prime[idx];
            }
        }
        bigp[i] = t;
        od[i] = i;
    }
    sort(od + 2, od + n + 1, cmp);
    f[1][0][0] = 1;		//数组初始化
    int cur = 1, old = 0;
    for (int i = 2, x = od[i]; i <= n; i++, x = od[i]) {
        cur ^= 1;
        old ^= 1;
        for (int G = 0; G <= all; G++) {
            for (int W = 0; W <= all; W++) {		//滚动数组时清理当前一维数据
                f[cur][G][W] = f[old][G][W];
                g[cur][G][W] = g[old][G][W];
                w[cur][G][W] = w[old][G][W];
            }
        }
        for (int G = 0; G <= all; G++) {
            for (int W = 0; W <= all; W++) {
                if (G & W) continue;
                if (bigp[x] == 1) {		//分类讨论：无大质数
                    if ((sta[x] & W) == 0) f[cur][G | sta[x]][W] = (f[cur][G | sta[x]][W] + f[old][G][W]) % p;
                    if ((sta[x] & G) == 0) f[cur][G][W | sta[x]] = (f[cur][G][W | sta[x]] + f[old][G][W]) % p;
                }
                else if (bigp[x] != bigp[od[i - 1]]) {	//分类讨论：新的质数段
                    f[cur][G][W] = (f[old][G][W] + g[old][G][W] + w[old][G][W]) % p;
                    g[cur][G][W] = w[cur][G][W] = f[cur][G][W];
                }
                else {				//分类讨论：有大质数
                    if ((sta[x] & W) == 0) g[cur][G | sta[x]][W] = (g[cur][G | sta[x]][W] + g[old][G][W] + f[cur][G][W]) % p;
                    if ((sta[x] & G) == 0) w[cur][G][W | sta[x]] = (w[cur][G][W | sta[x]] + w[old][G][W] + f[cur][G][W]) % p;
                }
            }
        }
    }
    for (int G = 0; G <= all; G++) {
        for (int W = 0; W <= all; W++) {
            if (G & W) continue;
            ans = (ans + f[cur][G][W] + g[cur][G][W] + w[cur][G][W]) % p;		//统计答案
        }
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：比利♂海灵顿 (赞：11)

# NOI2015 寿司晚宴

为什么没有人用容斥呢? 本做法复杂度 $O(3^8n)$。

## 题意

[Link](https://www.luogu.com.cn/problem/P2150)

给正整数 $[2, n]$，选两个不交子集，使得两个子集中任意两个数互质。求方案数。

## 题目转化

分析性质，发现对于每个质数 $p$，两个数集中只有一个数集存在整除 $p$ 的元素。所以状态就是两个集合分别包含的质因数集合即可，必须要求两个集合 $\And$ 后是 $0$。

设 $n$ 以内有 $m$ 个质数，则复杂度是 $O(2^{2m}n)$。

## 根号分治

发现 $500$ 以内的数，大于 $19$ 的质因数最多有一个。

小于等于 $19$ 的质数只有 $2, 3, 5, 7, 11, 13, 17, 19$，共 $8$ 个。如果我们把包含大于 $19$ 质因数的数字先剔除不计，仅分配剩下这些质因数，那么每个人的集合有 $2^8$ 种情况，两个人的状态数是 $4^8$ 种，因为两个人的集合不交，每个元素的状态只有三种，在第一个集合中，在第二个集合中，不存在，所以一共是 $3^8$ 种有效状态。

假设我们现在确定了决策完未剔除的数字后，两个人的质因数集合。那么对于剔除的数字，我们可以枚举 $19$ 后面的质数，将所有以这个质数为最大质因数的数同时考虑，枚举三种情况，分别是把这些数按 $19$ 以内的质因数约束分配到第一个人的集合里，分配到第二个人的集合里，不分配。因为是按照确定的集合分配的，所以 $19$ 以内质因数是确定的，$19$ 以后的质因数也不会在待处理的数中出现，所以是正确的。

### 枚举 $S$ 直接求 $f_S$

我们把状态压成三进制，称为集合 $S$。每个 $S$ 唯一对应一个有序二进制集合二元组 $(A, B)$。其中 $A \And B = 0$ 表示两个人 $19$ 以内的因数情况。$S$ 的第 $i$ 位是 $0$，则 $A$，$B$ 的第 $i$ 位都为 $0$，如果 $S$ 的第 $i$ 位是 $1$ 或 $2$，则分别对应 $A$ 的第 $i$ 位为 $1$ 和 $B$ 的第 $i$ 位为 $1$。

对于每个 $S$，我们把 $[2, n]$ 每个数按照除以 $19$ 以内所有质因数的结果分类，可以算出 $f_S$ 表示选出的两个不交子集各自的质因数，分别是由 $S$ 确定的 $A$，$B$ 的子集的方案数。

定义三进制集合的 PopCnt 为这个集合不为 $0$ 的元素个数。我们发现对于一个方案 $x$，这个方案两个人的 $19$ 以内的质因数集合分别是 $A_x$ 和 $B_x$，这两个集合可以表示为三进制集合 $S_x$。那么它不仅会被 $f_{S_x}$ 统计，还会被 $S_x$ 的真超集的 $f$ 值所统计。

那么对于一个满足自己对应的 $S_x$ 的 PopCnt 为 $i$ 的方案，被 PopCnt 为 $j$ 的 $S$ ($j \geq i$) 所统计的次数，也就是 $S_x$ 的 PopCnt 为 $j$ 超集数量，即为:

$$
g_{j, i} = \binom{8 - i}{8 - j} * 2^{j - i}
$$

式子很容易理解，组合数就是枚举哪些在 $S_x$ 中为 $0$ 的位置在 $S$ 中也为 $0$，后面的 $2^{j - i}$ 则是讨论在 $S_x$ 中为 $0$ 但是在 $S$ 中不为 $0$ 的位置，到底取 $1$ 还是取 $2$，互相独立，满足乘法原理条件。

## 容斥

由上面的式子我们发现如果简单给 $f_S$ 求和，一个方案会被统计多次。所以考虑用容斥把答案凑出来。

因为方案 $x$ 的统计次数只和 $S_x$ 的 PopCnt 有关，所以 PopCnt 相同的 $S$ 的 $f_i$ 应当是同时考虑的，所以我们定义

$$
Sum_i = \sum_{PopCnt(S) = i} f_S
$$

也就是说我们希望能有一个数列 $a$，使得

$$
Ans = \sum_{i = 0}^8 a_iSum_i
$$

结合前面 $g$ 的表达式，那么对 $a$ 的要求就是: 可以使得对于所有 $i$，有

$$
\sum_{j = i}^8 a_ig_{j, i} = 1
$$

$g$ 的形式一眼会让人联想到二项式反演，但是在无聊的合格考过程中，我惊奇地发现:

$$
\sum_{j = i}^n \binom{n - i}{n - j} * 2^{j - i} * (-1)^{n - j} = 1
$$

也就是说

$$
\sum_{j = i}^8 (-1)^{j}g_{j, i} = 1\\
a_i = (-1)^i
$$

至于原因，我百思不得其解，但是只需要对每个 $S$ 求方案数，然后根据 $S$ 的元素数乘上相应的 $a$ 对答案进行统计即可。

## 代码实现

```cpp
const unsigned M(6561);
const unsigned Tri[10] = { 1,3,9,27,81,243,729,2187,6561 };
const unsigned Prime[10] = { 2,3,5,7,11,13,17,19 };
vector <unsigned> Bel[505];
unsigned long long Tmp(0), Mod(998244353), Ans(0);
unsigned PopCnt[7005], Need[7005][2];
unsigned Stack[505], STop(0), Have[505];
unsigned m, n;
unsigned A, B, D, t;
unsigned Cnt(0);
signed main() {
  n = RD(), Mod = RD();
  for (unsigned i(2); i <= n; ++i) {
    unsigned Ti(i);
    for (unsigned j(0); j < 8; ++j) {
      if (!(Ti % Prime[j])) Have[i] |= (1 << j);
      while (!(Ti % Prime[j])) Ti /= Prime[j];
    }
    if (Ti > 1) Stack[++STop] = Ti;
    Bel[Ti].push_back(i);
  }
  for (unsigned i(0); i < M; ++i) {
    for (unsigned j(0); j < 8; ++j) {
      unsigned Jth((i / Tri[j]) % 3);
      if (Jth) Need[i][(Jth & 1) ? 0 : 1] |= (1 << j);
    }
  }
  sort(Stack + 1, Stack + STop + 1);
  STop = unique(Stack + 1, Stack + STop + 1) - Stack - 1;
  for (unsigned i(0); i < M; ++i) PopCnt[i] = PopCnt[i / 3] + (bool)(i % 3);
  for (unsigned i(0); i < M; ++i) {
    Tmp = 1;
    for (auto j : Bel[1]) {
      if ((Have[j] & Need[i][0]) == Have[j]) { Tmp <<= 1; if (Tmp >= Mod) Tmp -= Mod; }
      if ((Have[j] & Need[i][1]) == Have[j]) { Tmp <<= 1; if (Tmp >= Mod) Tmp -= Mod; }
    }
    for (unsigned j(1); j <= STop; ++j) {
      A = 1, B = 1;
      for (auto k : Bel[Stack[j]]) {
        if ((Have[k] & Need[i][0]) == Have[k]) { A <<= 1; if (A >= Mod) A -= Mod; }
        if ((Have[k] & Need[i][1]) == Have[k]) { B <<= 1; if (B >= Mod) B -= Mod; }
      }
      Tmp = Tmp * (A + B - 1) % Mod;
    }
    Ans += (PopCnt[i] & 1) ? (Mod - Tmp) : Tmp;
    if (Ans >= Mod) Ans -= Mod;
  }
  printf("%llu\n", Ans);
  return Wild_Donkey;
}
```

---

## 作者：zhenglier (赞：8)

## 状态压缩+根号分块

~~（好吧其实这题没什么明确的算法）~~

题意：给出一个$n$，问有多少个集合$A,B\subseteq \{x|2\leq x\leq n\}$，满足$\forall a\in A,b\in B$都有$\gcd(a,b)=1$

先考虑最暴力的暴力，枚举所有子集，然后暴力判断，这样复杂度是$O(2^{2n}n)$的，连$30pts$都过不了。

再思考$30pts$的算法：

我们发现小于30的质数只有10个，可以使用状态压缩，将所有数预处理出它的质因子并状态压缩，然后就可以dp转移

设当前数$i$的质因子子集为$s$，对于每种质因子的分配情况（$j$为第一个人选的质因数子集，$k$为第二个人选的质因数子集），有dp式。
$$if(j\text{ bitand }s=0)dp[i+1][j][k\text{ bitor }s]+=dp[i][j][k] $$
$$if(k\text{ bitand }s=0)dp[i+1][j\text{ bitor }s][k]+=dp[i][j][k]$$

这个dp式子只有像背包一样倒着处理就能舍掉一维。

这样就可以得到$30pts$

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int n;
ll p;
ll add(ll x,ll y){return (x+y)%p;}
ll mul(ll x,ll y){return x*y%p;}
const int prime[10]={2,3,5,7,11,13,17,19,23,29},N=1<<10;
struct data{
    int val,S,big;
}d[510];
data new_data(int now){
    data d;
    d.val=now,d.S=0;
    for(int i=0;i<10;++i){
        if(now%prime[i]==0){
            d.S|=(1<<i);
        }
        while(now%prime[i]==0)now/=prime[i];
    }
    if(now!=1)d.big=now;
    else d.big=0;
    return d;
}
bool operator<(const data&a,const data&b){
    return a.big<b.big;
}
ll dp[N][N];
int main(){
    cin>>n>>p;
    for(int i=1;i<n;++i){
        d[i]=new_data(i+1);
    }
    sort(d+1,d+n);
    dp[0][0]++;
    for(int i=1;i<n;++i){
        int s=d[i].S;
        for(int j=N-1;~j;--j){
            for(int k=N-1;~k;--k){
                if((j&s)==0){
                    dp[j][k|s]=add(dp[j][k|s],dp[j][k]);
                }
                if((k&s)==0){
                    dp[j|s][k]=add(dp[j|s][k],dp[j][k]);
                }
            }
        }
    }
    ll ret=0;
    for(int i=0;i<N;++i){
        for(int j=0;j<N;++j){
            if((i&j)==0)
            ret=add(ret,dp[i][j]);
        }
    }
    cout<<ret<<endl;
}
```

再考虑$100pts$的方法：

因为$n$扩大到了500，所以无法把所有质因子都状态压缩，但是这里有一个性质，一个小于等于500的数，不可能有两个大于19的质因子(因为$23*23=529>500$)，所以我们可以把数用小于等于19的质因子先除尽，然后剩下的数作为大因子。

处于方便，我把小于等于19的质因子叫做小质因子，大于19的质因子叫做大质因子。

因为同一个大质因子不能出现在不同集合中，所以我们先将所有数按大质因子排序，对于一段大质因子相同的区间，先处理内部，再跟总体的dp合并。

对于大因子相同的区间，我们可以设$f[i][j][k]$表示前$i$个数中，第一个人的小质因子集合为$j$，第二个人的小质因子为$k$时的方案数。$f1$表示当前第一个人获得了当前的大质因子，$f2$表示当前第二个人获得了当前的大质因子。

处理完一段后，合并式为:
$$dp[i][j][k]=f1[i][j][k]+f2[i][j][k]-dp[i-len][j][k]$$
(len为当前区间的长度)

最后要减去$dp[i-len][j][k]$是因为如果两者都没选择大因子的情况会被算两次，要减去。

也可以倒序处理舍掉一维。

最后是AC代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int n;
ll p;
ll add(ll x,ll y){return(x+y)%p;}
const int prime[8]={2,3,5,7,11,13,17,19},N=1<<8;
struct data{
    int val,S,big;
}d[510];
data new_data(int now){
	data d;
	d.val=now,d.S=0;
    for(int i=0;i<8;++i){
        if(now%prime[i]==0){
            d.S|=(1<<i);
		}
		while(now%prime[i]==0)now/=prime[i];
	}
	if(now!=1)d.big=now;
    else d.big=0;
    return d;
}
bool operator<(const data&a,const data&b){
    return a.big<b.big;
}
ll dp[N][N],f1[N][N],f2[N][N];
int main(){
    cin>>n>>p;
    for(int i=1;i<n;++i){
        d[i]=new_data(i+1);
	}
	sort(d+1,d+n);
	dp[0][0]++;
	for(int i=1;i<n;++i){
		if(d[i].big!=d[i-1].big||d[i].big==0){
		    memcpy(f1,dp,sizeof f1);
		    memcpy(f2,dp,sizeof f2);
		}
		int s=d[i].S;
		for(int j=N-1;~j;--j){
		    for(int k=N-1;~k;--k){
		        if((j&s)==0)f1[j][k|s]=add(f1[j][k|s],f1[j][k]);
		        if((k&s)==0)f2[j|s][k]=add(f2[j|s][k],f2[j][k]);
			}
		}
		if(d[i].big==0||d[i].big!=d[i+1].big){
			for(int j=N-1;~j;--j){
			    for(int k=N-1;~k;--k){
			    	dp[j][k]=add(f1[j][k],add(f2[j][k],p-dp[j][k]));
				}
			}
		}
	}
	ll ret=0;
	for(int i=0;i<N;++i){
	    for(int j=0;j<N;++j){
	        if((i&j)==0)
			ret=add(ret,dp[i][j]);
		}
	}
	cout<<ret<<endl;
}
```

---

## 作者：BennyHu (赞：7)

# 人生第一道黑题hiahiahiahiahia!!!!!
**czl给我讲的**

上代码
```cpp
#include <algorithm>
#include <cstring>
#include <cstdio>
#define ll long long
using namespace std;
struct node{
    int st,big;
}dt[550];
const int pr[]={2,3,5,7,11,13,17,19};
ll dp[300][300],f1[300][300],f2[300][300];
ll mod,ans;
int n;
bool cmp(node x,node y){
    return x.big<y.big;
}
int main(){
    scanf("%d%lld",&n,&mod);
    for(int i=2;i<=n;++i)
    {
        int tmp=i;
        dt[i-1].st=0;
        for(int j=0;j<8;++j)
        {
            while(tmp%pr[j]==0&&tmp)
            {
                dt[i-1].st|=1<<j;
                tmp/=pr[j];
            }
        }
        if(tmp>1)dt[i-1].big=tmp;
        else dt[i-1].big=-1;
    }
    sort(dt+1,dt+n,cmp);
    dp[0][0]=1;
    for(int i=1;i<n;++i)
    {
        int zt=dt[i].st;
        if(i==1||dt[i].big==-1||dt[i].big!=dt[i-1].big)
        {
            memcpy(f1,dp,sizeof(f1));
            memcpy(f2,dp,sizeof(f2));
        }
        for(int j=(1<<8)-1;j>=0;j--)
        for(int k=(1<<8)-1;k>=0;k--)
        {
            if(!(k&zt))f1[j|zt][k]+=f1[j][k],f1[j|zt][k]=(f1[j|zt][k]+mod)%mod;
            if(!(j&zt))f2[j][k|zt]+=f2[j][k],f2[j][k|zt]=(f2[j][k|zt]+mod)%mod;
        }
        if(i==n-1||dt[i].big==-1||dt[i].big!=dt[i+1].big)
        {
            for(int j=(1<<8)-1;j>=0;j--)
            for(int k=(1<<8)-1;k>=0;k--)
            if(!(j&k))
            dp[j][k]=(f1[j][k]+f2[j][k]-dp[j][k]+mod)%mod;
        }
        
    }
    for(int j=(1<<8)-1;j>=0;j--)
    for(int k=(1<<8)-1;k>=0;k--)
    if(!(j&k))
    ans+=dp[j][k],ans=(ans+mod)%mod;
    printf("%lld",ans);
    return 0;
}
```


---

## 作者：罗旅洲 (赞：6)

/\*
首先显然只需要考虑不超过 √n 的质因子对题目的影响。然后因为剩下的质因子只会出现至多一次,

因为对于n,质因数分解,最多只有一个质因子大于√n.再考虑这个大质数放哪个集合

我们记 f(S 1 , S 2 ) 表示两个集合中出现的质因子集合分别为S 1 , S 2 的方案数。

dp(j ,k, t) 为甲拿s1,乙拿s2,这个大质数放入t集合. t=0 or 1;

这样,转移的时候就只需考虑包含当前这个大于 n 的质因子的数放入那个集合中即可。

\*/
            


            
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<cstdlib>
#include<cmath>
#include<algorithm>
using namespace std;
#define For(i,a,b) for(register int i=(a);i<=(b);++i)
#define Rep(i,a,b) for(register int i=(a);i>=(b);--i)
#define LL long long
int pri[8]={2,3,5,7,11,13,17,19},n,mod;    
int f[500][500],dp[500][500][2];
int ans=0;
struct node{
    int a,p;            //a:这个数的质因数集合  p:大质数
    bool operator < (const node & x) const 
    {  return p<x.p;  }
}num[501];
void init(){
    f[0][0]=1;
    For(i,2,n){
        int tmp=i;
        For(j,0,7)
            if(tmp%pri[j]==0){
                while(tmp%pri[j]==0) tmp/=pri[j];
                num[i].a|=(1<<j);
                }
        num[i].p=tmp;     //不能被那八个质数除的部分为要求的大质数
        }
    }
int main(){
#ifndef ONLINE_JUDGE
    freopen("a.in","r",stdin);
    freopen("a.out","w",stdout);
#endif
    scanf("%d%d",&n,&mod);
    init();            // 预处理每个数的质因数集合与它的大质数
    sort(num+2,num+n+1);    //把质数相同的放一起讨论
    For(i,2,n){
        if(num[i].p==1 || num[i].p!=num[i-1].p){    //如果全在集合or换了一个质数,就是不同类.同类不能同时选
            For(j,0,256) For(k,0,256)
                dp[j][k][0]=dp[j][k][1]=f[j][k];
        }
        Rep(j,256,0) Rep(k,256,0){        
           if((num[i].a & k) == 0)             // 如果该数集合与第二个人没交集,则可以放入第一个人集合
             dp[j | num[i].a][k][1] = ((LL)dp[j | num[i].a][k][1]+ dp[j][k][1]) % mod;
           if((num[i].a & j) == 0)             // 同理放入第二个集合
                dp[j][k | num[i].a][0] = ((LL)dp[j][k | num[i].a][0] + dp[j][k][0]) % mod;
        }
        if(num[i].p==1 || num[i].p!=num[i+1].p)        //每次换类别时要改变方案情况
            Rep(j,256,0) Rep(k,256,0)
                f[j][k]=((LL)dp[j][k][0]+dp[j][k][1]-f[j][k])%mod;    //这个数两人都不选时dp0 dp1都有包含
    }
    For(i,0,256) For(j,0,256)
        if((i&j) == 0)
            (ans+=f[i][j])%=mod;
    printf("%d\n",(ans+mod)%mod);
    return 0;
}
```

---

## 作者：pyyyyyy (赞：5)

[$\large\text{博客食用效果更佳}$](https://www.cnblogs.com/pyyyyyy/p/13156381.html)

### 题目
[P2150 [NOI2015]寿司晚宴](https://www.luogu.com.cn/problem/P2150)

> 给定$n-1$中不同的寿司，第$i$种寿司的美味度为$i+1$，小$G$和小$W$从中挑选一些来品尝，要求他们选得寿司中美味度必须都互质，问有多少种方案（对$p$取模）
>
> $2\le n \le500,0<p\le10^9$

### 思路

- $30pts$

$n\le 30$一共有$10$个质数，我们可以状压一下两人已经选的集合

显然对于一个寿司，如果它的质因子都不在在小$G$的集合里，那么它可以放入小$W$的集合里面

$f[i][s1][s2]$表示到第$i$个寿司，小$G$选择的质因子集合是$s1$,小$W$选的是$s2$

$\left\{\begin{matrix} f[i][s1|p_i][s2]+=f[i-1][s1][s2] & p_i\&s2=0 \\ f[i][s1][s2|p_i]+=f[i-1][s1][s2] & p_i\&s1=0 \end{matrix}\right. $

$p_i$为第$i$个寿司的质因数集合

上述转移方程竟然可以通过滚动数组来优化（奇怪的知识增加了

复杂度$O(2^{10}\times n)$，期望得分$30$

- $40pts$

没想到有什么只能过$40pts$的，如果有只能过$40pts$的麻烦告诉蒟蒻一下

- $70pts$

同样不知道,$qwq$

- $100pts$

> 对于$1$个数$n$它至多有$1$个$>\sqrt{n}$的质因子

根据上面的性质，我们没必要把所有质因子都状压，只需要将质因子进行分类

一类是”小因子“$<\sqrt{n}$，一类是大“因子”$> \sqrt{n}$

用$a[i].first$表示大因子集合，用$a[i].second$表示小因子集合

所有大因子相同的数显然只能放在一个集合中，所以按照大因子的大小排序，这样就可以把所有大因子相同的数放在一起算

在计算一段相同的大因子的数时，我们可以把$f[s1][s2]$拆成$g1[s1][s2]$和$g2[s1][s2]$分别表示这段数都放在集合$1$和集合$2$里的答案，$g1,g2$仍按照$30pts$的方程进行转移即可

则$f[s1][s2]=g1[s1][s2]+g2[s1][s2]-f[s1][s2]$($f[s1][s2]$加了两遍)

最终答案$ans=\sum\limits_{s1}\sum\limits_{s2}f[s1][s2]$

注意$s1=0$和$s2=0$的情况


###  code

``` cpp
/*
@ author:pyyyyyy/guhl37
-----思路------

-----debug-------
忽略了不选的情况了 
*/
#include<bits/stdc++.h>
#include<algorithm>
#define int long long
using namespace std;
const int prime[9]= {2,3,5,7,11,13,17,19};
int g[3][1<<9][1<<9],f[1<<9][1<<9];
int bin[30];
pair<int,int> a[555];
int n,p;
void pre() {
	bin[0]=1;
	for(int i=1; i<=20; ++i) bin[i]=bin[i-1]*2;
	for(int i=2; i<=n; ++i) {
		int x=i;
		for(int j=0; j<=7; ++j) {
			if(x%prime[j]==0) a[i].second|=bin[j];
			while(x%prime[j]==0) x/=prime[j];
		}
		a[i].first=x;
	}
	sort(a+2,a+1+n);
}
signed main() {
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	cin>>n>>p;
	pre();
	memset(f,0,sizeof(f));
	f[0][0]=1;
	for(int i=2; i<=n; ++i) {
		if(a[i].first==1 || a[i].first!=a[i-1].first || i==2) {
			memcpy(g[1],f,sizeof(g[1]));
			memcpy(g[2],f,sizeof(g[2]));
		}
		for(int s1=255; s1>=0; --s1) {
			for(int s2=255; s2>=0; --s2) {
				if(s1&s2) continue;
				if(!(s2&a[i].second)) g[1][s1|a[i].second][s2]=(g[1][s1|a[i].second][s2]+g[1][s1][s2])%p;
				if(!(s1&a[i].second)) g[2][s1][s2|a[i].second]=(g[2][s1][s2|a[i].second]+g[2][s1][s2])%p;
			}
		}
		if((i==n) || (a[i].first!=a[i+1].first) ||(a[i].first==1)) {
			for(int s1=255; s1>=0; --s1) {
				for(int s2=255; s2>=0; --s2) {
					if(s1&s2) continue;
					f[s1][s2]=(g[1][s1][s2]%p+g[2][s1][s2]%p-f[s1][s2]%p+p)%p;
				}
			}
		}
	}
	int ans=0;
	for(int s1=255; s1>=0; --s1)
		for(int s2=255; s2>=0; --s2)
			ans=(ans+f[s1][s2])%p;
	cout<<(ans%p+p)%p;
	return 0;
}
```


---

## 作者：kouylan (赞：4)

题目要求两集合的数互质，很自然想到把数都质因数分解，记录每个质数是否存在。

设 $f(s1,s2)$ 表示两个集合中数的质因数存在状态分别是 $s1,s2$ 时的方案数。

但直接做只有 $30$ 分，当 $n=500$ 时，质因数个数太多了。

但我们想，每个数中，超过 $\sqrt{n}$ 的质因数最多只有 $1$ 个（称为大质数 big prime，下面简称 $bp$），而不超过 $\sqrt{n}$ 的质数最多只有 $8$ 个（称为小质数 small prime，下面用 $sp$ 表示小质数的状态）。那我们可以用状压记录 $sp$，在把 $bp$ 相同的数放到一段，显然这一段内的数只能放到一个集合中，那么处理每一段时，我们可以再设 $f1(s1,s2),f2(s1,s2)$ 表示这一段数只放到一集合或二集合的方案数。

这样对于每一段，总的 $f(s1,s2)$ 就等于 $f1(s1,s2)+f2(s1,s2)-f(s1,s2)$，为什么最后要减去呢，因为如果这段数一个都不取，这种情况就会被多算一次。最后，答案就是所有 $f(s1,s2)$ 的加和。

下面是 AC 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long

const int P[] = {2,3,5,7,11,13,17,19};

int n,M,ans,f[1<<8][1<<8],f1[1<<8][1<<8],f2[1<<8][1<<8];
struct sushi{
	int v,bp,sp;
	bool operator < (const sushi b)
	{
		return bp<b.bp;
	}
}a[505];

signed main()
{
	cin>>n>>M;
	for(int i=1,tmp=0;i<n;i++)
	{
		a[i].v = tmp = i+1;
		for(int j=0;j<8;j++)
			if(tmp%P[j]==0)
			{
				a[i].sp |= 1<<j;
				while(tmp%P[j]==0)
					tmp /= P[j];
			}
		if(tmp>1)
			a[i].bp = tmp;
	}
	sort(a+1,a+n);
	int o=0;
	f[0][0] = 1;
	for(int i=1;i<n;i++)
	{
		if(a[i].bp==0 || a[i].bp!=a[i-1].bp)
		{
			for(int s1=0;s1<=255;s1++)
			for(int s2=0;s2<=255;s2++)
				f1[s1][s2] = f2[s1][s2] = f[s1][s2];
		}
		for(int s1=255;s1>=0;s1--)
		for(int s2=255;s2>=0;s2--)
		{
			if(s1&s2)
				continue;
			if((s2&a[i].sp)==0)
				f1[s1|a[i].sp][s2] = (f1[s1|a[i].sp][s2]+f1[s1][s2])%M;
			if((s1&a[i].sp)==0)
				f2[s1][s2|a[i].sp] = (f2[s1][s2|a[i].sp]+f2[s1][s2])%M;
		}
		if(i==n-1 || a[i].bp!=a[i+1].bp || a[i].bp==0)
		{
			for(int s1=0;s1<=255;s1++)
			for(int s2=0;s2<=255;s2++)
				if((s1&s2)==0)
					f[s1][s2] = (f1[s1][s2]+f2[s1][s2]-f[s1][s2]+M)%M;
		}
	}
	for(int s1=0;s1<=255;s1++)
	for(int s2=0;s2<=255;s2++)
		if((s1&s2)==0)
			ans = (ans+f[s1][s2])%M;
	cout<<ans<<endl;
	
	return 0;
}
```

祝大家 AC 愉快！

---

## 作者：晓彘 (赞：4)

这道题的主要要求是将2到n的自然数分到两组中并且要求两组数互质有多少种分法



首先我们要理解互质到底是什么意思，意思就是两个数的公因数只有1，那么题意就变成了将拥有公因数（除1外）的数分到一组中。



然后我初步考虑用状压模拟每组数分到的质因数的状态，可是问题来了500以内的质因数太多了模拟不完。于是这里我们可以用一种极为巧妙的方法来避免这个问题，那就是————只模拟一部分。那么这个方法又从何说起呢？



观察后我们可以发现小于根号500的质数只有8个，也就是说在这些数中一个数不可能同时包含两个大于十九的相同质因数，也就是说我们只需要模拟8个质数就好，剩下的质数只需要从只放1组与只放2组的角度考虑就可以了。



接下来讲一下代码如何实现：



①把一个数所包含的小质数的状态以及包含了什么大质数预处理出来（个人建议用结构体装，注意：如果不包含大质数则将它的大质数赋为一个特定的数，之后好特判）；



②将数按照大质数排序（为了让相同的大质数凑在一起）；



③直接进入循环，这里由于内存限制我们只有用滚动数组，创建两个分数组，如：f1[i][j](只放1组且1组小质数为i状态2组小质数为j状态时的分法数）和f2[i][j](只放2组且1组小质数为i状态2组小质数为j状态时的分法数)，然后在循环到没有大质数（前文①有伏笔）或大质数不一样的数时再把它们合并到主数组中。



若还有疑问可参考代码



```c
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
int xz[12]={2,3,5,7,11,13,17,19};
int n,c;
long long p,ans;
long long dp[260][260],f1[260][260],f2[260][260];
struct cmp
{
	int st;
	int bi;
} a[505];
bool cmp2(cmp x,cmp y)
{
	return x.bi<y.bi;
}
int main()
{
	scanf("%d%lld",&n,&p);
	for(int i=2;i<=n;i++) 
	{
		c=i;
		for(int j=0;j<8;j++)
		if(i%xz[j]==0)
		{
			a[i].st+=(1<<j);
			while(c%xz[j]==0)
			c/=xz[j];
		}
		a[i].bi=c;
	}//预处理 
	dp[0][0]=1;
	sort(a+2,a+n+1,cmp2);//排序 
	for(int i=2;i<=n;i++)
	{
		if(i==2||a[i].bi!=a[i-1].bi||a[i].bi==1)//判定是否为没有大质数或大质数不一样的数 
		{
			memcpy(f1,dp,sizeof(dp));
            memcpy(f2,dp,sizeof(dp));
		}
		for(int j=255;j>=0;j--)
		for(int k=255;k>=0;k--)
		{
			if((j&k)>0)
			continue;
			if((a[i].st&k)==0)
			{
				f1[a[i].st|j][k]+=f1[j][k];
				f1[a[i].st|j][k]%=p;
			}
			if((a[i].st&j)==0)
			{
				f2[j][a[i].st|k]+=f2[j][k];
				f2[j][a[i].st|k]%=p;
			}
		}
		if(i==n||a[i].bi!=a[i+1].bi||a[i].bi==1)
		for(int j=255;j>=0;j--)
		for(int k=255;k>=0;k--)
		{
			if((j&k)!=0)
			continue;
			dp[j][k]=(f1[j][k]+f2[j][k]-dp[j][k])%p;//转移方程 
		}//合并 
	}
	for(int j=255;j>=0;j--)
	for(int k=255;k>=0;k--)
	if((j&k)==0)
	{
		ans+=dp[j][k];
		ans%=p;
	}
	ans+=p;
	ans%=p;
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：eternal (赞：4)

可以发现，选了一个数等于是选了它的质因子。首先n只有500，所以小于根号500的质因子只有8个。我们可以把这8个质因子压成二进制位，形成2^8个集合。对于每个数，只可能含有不超过1个大于根号500的质因子，我们按这个将每个数分类。

把每个数存到一个结构体s里，s.kind表示这个数里大于根号500的质因子是什么，没有的话为1，s.se表示这个数小于根号500的质因子的包含情况，用二进制位压一下。

然后我们按kind排序。dp即可。

dp的时候把kind相同的放在一起dp。

设f[i][j]表示第一个人选了i这个质因数集合，第二个人选了j这个质因数集合的方案数。

对于每一类数开始dp时。先把f数组复制两遍到p[1]和p[2];

p[i][j][k]表示当前是第i个人进行操作，第1个人选的集合是j第二个人是k的方案数。

用p数组进行更新。

dp结束后要用p数组更新f数组。f=p1+p2-f; 因为两个p数组中都包含了选当前数的情况，然而这显然是不可以的，所以要减去之前的f。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int f[301][301],p[3][301][301],pp,ans;
int prime[8]={2,3,5,7,11,13,17,19},n;
struct use{
    int kind,se;
}s[600];
bool cmp(use a,use b)
{
    if (a.kind!=b.kind) return a.kind<b.kind;
    else return a.se<b.se;
}
int main()
{
    //freopen("dinner.in","r",stdin);
    //freopen("dinner.out","w",stdout);
    scanf("%d%d",&n,&pp);
    for (int i=1;i<=n;i++)
      {
        int temp;
        temp=i;
        for (int j=0;j<8;j++)
         if (temp%prime[j]==0)
           {
             s[i].se|=1<<j;
             while (temp%prime[j]==0) temp/=prime[j];
           }
         s[i].kind=temp;  
      }
    sort(s+2,s+n+1,cmp);
    f[0][0]=1;
    for (int i=2;i<=n;i++)
     {
         if (i==2||s[i].kind==1||s[i].kind!=s[i-1].kind)
           {
                memcpy(p[1],f,sizeof f );
                memcpy(p[2],f,sizeof f );
           }
          for (int j=255;j>=0;j--)
            for (int k=255;k>=0;k--)
              {
                  if ((k&s[i].se)==0) p[1][j|s[i].se][k]=(p[1][j|s[i].se][k]+p[1][j][k])%pp;
                 if ((j&s[i].se)==0) p[2][j][k|s[i].se]=(p[2][j][k|s[i].se]+p[2][j][k])%pp;
             }
       if (i==n||s[i].kind==1||s[i].kind!=s[i+1].kind)
         {
             for (int j=0;j<=255;j++)
               for (int k=0;k<=255;k++)
                 f[j][k]=((p[1][j][k]+p[2][j][k]-f[j][k])%pp+pp)%pp;
         }
     }
     ans=0;
     for (int i=0;i<=255;i++)
       for (int j=0;j<=255;j++)
         if ((i&j)==0) ans=(ans+f[i][j])%pp;
    cout<<ans<<endl;
}
```

---

## 作者：Plozia (赞：3)

宣传博客 $\to$ [link](https://blog.csdn.net/BWzhuzehao/article/details/117573424)

---------

题目上说要求小 G 选的数字和小 W 选的数字中两两之间不能互质也就是 $\gcd(x,y)=1$。

而要确认任意两数的 $\gcd$ 是否等于 1 我们可以只处理质数。

首先有一个关键点：

小 G 所选的数字与小 W 所选的数字不能有公共质因子。

知道了这个点，30 pts 的做法就好做了。

---------

30 pts：

因为当 $n \leq 30$ 的时候质数只有 10 个，因此我们可以状压。

设 $f_{i,j,k}$ 表示目前已经处理完前 $i$ 张卡牌，小 G 选的质数集合为 $j$，小 W 选的质数集合为 $k$ 的方案数，其中 $j \& k = 0$。

- 如果小 G 选的质数集合为 $j$，那么其能够选择的数就是 $j$ 中所有数互相组合的数。

设 $s_i$ 表示 $i$ 的质因数构成的质数集合状压后的结果。

那么有转移方程：

$$f_{i,j,k}=\sum (f_{i-1,j|s_i,k}+f_{i-1,j,k|s_i})$$

其中 $j \& k=0$，如果要统计 $f_{i-1,j|s_i,k}$ 要有 $s_i \& k=0$，如果要统计 $f_{i-1,j,k|s_i}$ 要有 $j \& s_i=0$。

发现这玩意只和 $f_{i-1}$ 有关，可以滚动数组滚掉第一维。

最后答案就是所有状态之和。

至此，30 pts 到手。

---------

100 pts：

现在 $n \leq 500$，质数变多了，我们要怎么办呢？

既然做到这道题，各位应该都知道一个定理：

- 对于任意一个正整数 $n$，其仅有一个大于 $\sqrt{n}$ 的质因数。

这里，$\sqrt{n}$ 约为 22。

因此我们可以考虑类似于根号分治的方法分个类，称所有大于 22 的质数为大质数，小于等于 22 的质数为小质数。

显然，小质数只有 8 个，因此我们可以考虑状压小质数。

对于大质数而言，我们可以按照大质数从大到小排个序，大质数相同的排在一起。

---------

对于所有大质数相同的数：

我们需要记录 3 个值 $f,f1,f2$。

$f$ 定义同 30 pts 的定义，$f1$ 要求是这些数不能是小 W 选的，$f2$ 要求是这些数不能是小 G 选的。

转移方程？上面改一下就好了啊qwq

需要注意的是因为这里的数归属有了限定（必须去小 G 那里或者是必须去小 W 那里），因此转移的时候不能搞错数组。

在这一类大质数处理完之后，我们可以得到最后的 $f$ 数组是：

$$f_{s1,s2}=f1_{s1,s2}+f2_{s1,s2}-f_{s1,s2}$$

为什么要减去 $f_{s1,s2}$ 呢？因为两者都不选的情况被重复统计了两次。

---------

Code：

```cpp
/*
========= Plozia =========
    Author:Plozia
    Problem:P2150 [NOI2015] 寿司晚宴
    Date:2021/6/4
========= Plozia =========
*/

#include <bits/stdc++.h>

typedef long long LL;
const int MAXN = 500 + 10;
int n, P, f[MAXN][MAXN], f1[MAXN][MAXN], f2[MAXN][MAXN], ans;
int Prime_Num[20] = {0, 2, 3, 5, 7, 11, 13, 17, 19};
struct node { int val, Prime, State; } a[MAXN];

int Read()
{
    int sum = 0, fh = 1; char ch = getchar();
    for (; ch < '0' || ch > '9'; ch = getchar()) fh -= (ch == '-') << 1;
    for (; ch >= '0' && ch <= '9'; ch = getchar()) sum = (sum << 3) + (sum << 1) + (ch ^ 48);
    return sum * fh;
}
int Max(int fir, int sec) { return (fir > sec) ? fir : sec; }
int Min(int fir, int sec) { return (fir < sec) ? fir : sec; }
bool cmp(const node &fir, const node &sec) { return fir.Prime > sec.Prime; }

int main()
{
    n = Read(), P = Read();
    for (int i = 2; i <= n; ++i)
    {
        a[i].val = i;
        for (int j = 1; j <= 8; ++j)
        {
            if (a[i].val % Prime_Num[j] == 0)
            {
                while (a[i].val % Prime_Num[j] == 0) a[i].val /= Prime_Num[j];
                a[i].State |= 1 << (j - 1);
            }
        }
        if (a[i].val != 1) a[i].Prime = a[i].val;
        else a[i].Prime = -1;
        a[i].val = i;
    }
    std::sort(a + 2, a + n + 1, cmp);
    f[0][0] = 1;
    for (int i = 2; i <= n; ++i)
    {
        if (i == 1 || a[i].Prime != a[i - 1].Prime || a[i].Prime == -1)
        {
            memcpy(f1, f, sizeof(f1)); memcpy(f2, f, sizeof(f2));
        }
        for (int j = 255; j >= 0; --j)
            for (int k = 255; k >= 0; --k)
            {
                if ((j & k) != 0) continue ;
                if ((a[i].State & j) == 0)
                {
                    f1[j][a[i].State | k] += f1[j][k];
                    if (f1[j][a[i].State | k] > P) f1[j][a[i].State | k] -= P;
                }
                if ((a[i].State & k) == 0)
                {
                    f2[j | a[i].State][k] += f2[j][k];
                    if (f2[j | a[i].State][k] > P) f2[j | a[i].State][k] -= P;
                }
            }
        if (i == n || a[i].Prime != a[i + 1].Prime || a[i].Prime == -1)
        {
            for (int j = 255; j >= 0; --j)
                for (int k = 255; k >= 0; --k)
                {
                    if ((j & k) != 0) continue ;
                    f[j][k] = ((f1[j][k] + f2[j][k]) % P + P - f[j][k]) % P;
                }
        }
    }
    for (int j = 255; j >= 0; --j)
        for (int k = 255; k >= 0; --k)
        {
            if ((j & k) != 0) continue ;
            ans += f[j][k]; if (ans > P) ans -= P;
        }
    printf("%d\n", ans); return 0;
}
```

---

## 作者：asuldb (赞：3)

[题目](https://www.luogu.org/problemnew/show/P2150)

这是一篇需要龟速乘的思博题解

我们考虑一下$n\leq 30$的睿智暴力，显然质因数个数少得一批，互质的条件又等价于没有公共的质因子，所以我们直接状压质因子，$dp[i][S_1][S_2]$表示前$i$个数考虑完了，第一个人选择的质因子状态为$S_1$，第二个人选择的质因子状态为$S_2$，转移的话就考虑当前这个数是给第一个人，第二个人还是两个人都不要就好了，显然可以滚动数组优化，又因为$S_1$和$S_2$不能有交，于是可以直接枚举补集

复杂度大概是$O(n3^{\pi(n)})$，$\pi(n)$表示不大于$n$的质数个数

我们发现$n\leq 500$时这个暴力不适用的原因是质因子个数太多了，但是考虑到一个非常小学生的结论，一个数$n$最多只会有一个超过$\sqrt{n}$的质因子，于是我们可以考虑单独讨论这个超过$\sqrt{n}$的质因子

状态还是暴力$dp$的状态，但是我们只压不超过$\sqrt{n}$的质因子，我们把所有数分解之后按照剩下的那个质因子排序，对于相同的质因子我们一起考虑，对于一个具有相同超过根号质因子的区间，我们发现这里面的数不能同时分给两个人，这样这个两个人就会具有一个相同的质因子了

对于一段最大值因子相同的区间，我们再做一个$dp$，设$f[S]$表示在这个区间里选择的数小于根号的质因子状态为$f$的方案数，做完这个$dp$后我们就考虑把这些$f$分给第一个人第二个人还是都不选，这里的转移还是一样，也是需要保证小于$\sqrt{n}$的质因子没有交，这里显然需要一个乘法，模数又是$10^{10}$级别的，于是需要龟速乘一下

复杂度大概是$O(n2^{\pi(\sqrt{n})}+(\pi(n)-\pi(\sqrt{n}))5^{\pi(n)})$

有点长的代码

```cpp
#include <bits/stdc++.h>
#define re register
#define LL long long
int n, len, o, l, is[505], p[505];
LL dp[2][257][257], f[505][257], mod;
struct Number {int res, s;}a[505];
inline int cmp(const Number &A, const Number &B) { return A.res < B.res; }
inline void solve(int L, int R) {
    memset(f[L-1], 0, sizeof(f[L-1]));
    f[L - 1][0] = 1;
    for (re int i = L; i <= R; i++)
        for (re int j = 0; j <= len; j++) {
            f[i][j | a[i].s] = (f[i][j | a[i].s] + f[i - 1][j]) % mod;
            f[i][j] = (f[i][j] + f[i - 1][j]) % mod;
        }
    f[R][0] = (f[R][0] - 1 + mod) % mod;
}
inline LL mul(LL a, LL b) {
    LL S = 0;
    for (; b; b >>= 1ll, a = (a + a) % mod)
        if (b & 1ll) S = (S + a) % mod;
    return S;
}
int main() {
    scanf("%d%lld", &n, &mod);
    is[1] = 1;
    for (re int i = 2; i <= n; i++) {
        if (!is[i]) p[++p[0]] = i;
        for (re int j = 1; j <= p[0] && p[j] * i <= n; j++) {
            is[p[j] * i] = 1;
            if (i % p[j] == 0) break;
        }
    }
    for (re int i = 2; i <= n; i++) {
        int x = i, s = 0;
        for (re int j = 1; j <= p[0] && p[j] * p[j] <= n; j++) {
            if (x % p[j]) continue;
            s |= 1 << (j - 1);
            while (x % p[j] == 0) x /= p[j];
        }
        a[i - 1].res = x, a[i - 1].s = s;
    }
    for (re int i = 1; i <= p[0]; i++)
        if (p[i] * p[i] <= n) ++len;
    len = (1 << len) - 1;
    std::sort(a + 1, a + n, cmp);
    dp[0][0][0] = 1;
    for (re int i = 1; i < n; i++) {
        if (a[i].res > 1) {l = i;break;}
        memset(dp[o ^ 1], 0, sizeof(dp[o ^ 1]));
        for (re int j = 0; j <= len; j++) {
            int S = len ^ j;
            for (re int t = S; t; t = (t - 1) & S) {
                if (!dp[o][j][t]) continue;
                dp[o ^ 1][j][t] = (dp[o ^ 1][j][t] + dp[o][j][t]) % mod;
                if (((j | a[i].s) & t) == 0)
                    dp[o ^ 1][j | a[i].s][t] = (dp[o ^ 1][j | a[i].s][t] + dp[o][j][t]) % mod;
                if ((j & (t | a[i].s)) == 0)
                    dp[o ^ 1][j][t | a[i].s] = (dp[o ^ 1][j][t | a[i].s] + dp[o][j][t]) % mod;
            }
            dp[o ^ 1][j][0] = (dp[o ^ 1][j][0] + dp[o][j][0]) % mod;
            dp[o ^ 1][j | a[i].s][0] = (dp[o ^ 1][j | a[i].s][0] + dp[o][j][0]) % mod;
            if ((a[i].s & j) == 0) dp[o ^ 1][j][a[i].s] = (dp[o ^ 1][j][a[i].s] + dp[o][j][0]) % mod;
        }
        o ^= 1;
    }
    for (re int i = l + 1; i <= n; i++) {
        if (a[i].res == a[i - 1].res) continue;
        solve(l, i - 1);
        memset(dp[o ^ 1], 0, sizeof(dp[o ^ 1]));
        for(re int k = 0; k <= len; k++) {
            if(!f[i - 1][k]) continue;
            for (re int j = 0; j <= len; j++) {
            int S = len ^ j;
            for (re int t = S; t; t = (t - 1) & S) {
                if (!dp[o][j][t]) continue;
                if (((j | k) & t) == 0)
                    dp[o ^ 1][j | k][t] = (dp[o ^ 1][j | k][t] + mul(dp[o][j][t], f[i - 1][k])) % mod;
                if ((j & (t | k)) == 0)
                    dp[o ^ 1][j][t | k] = (dp[o ^ 1][j][t | k] + mul(dp[o][j][t], f[i - 1][k])) % mod;
            }
            dp[o ^ 1][j | k][0] = (dp[o ^ 1][j | k][0] + mul(dp[o][j][0], f[i - 1][k])) % mod;
            if ((j & k) == 0) dp[o ^ 1][j][k] = (dp[o ^ 1][j][k] + mul(dp[o][j][0], f[i - 1][k])) % mod;
            }
        }
        for (re int j = 0; j <= len; j++) {
            int S = len ^ j;
            for (re int t = S; t; t = (t - 1) & S) {
                if (!dp[o][j][t]) continue;
                dp[o ^ 1][j][t] = (dp[o ^ 1][j][t] + dp[o][j][t]) % mod;
            }
            dp[o ^ 1][j][0] = (dp[o ^ 1][j][0] + dp[o][j][0]) % mod;
        }
        l = i;o ^= 1;
    }
    LL ans = 0;
    for (re int i = 0; i <= len; i++)
        for (re int j = 0; j <= len; j++)
            if ((i & j) == 0) ans = (ans + dp[o][i][j]) % mod;
    printf("%lld\n", ans);
    return 0;
}
```


---

## 作者：MikukuOvO (赞：2)

考虑最暴力的做法，$f[i][s_1][s_2]$表示考虑前$i$个点，小$G$选出的质数集合为$s_1$，小$W$选出的质数集合为$s_2$，考虑到$30$以内的指数只有$10$个，这样做的复杂度为$2^{20}n$。

考虑到$n \le 500$，那么这样做的复杂度是不行的，但是我们知道对于一个$\le n$的数最大只会有一个超过$\sqrt n$的质因数，这样我们发现最多只有$8$个$\le \sqrt{n}$的质因数。

整理一下做法，我们首先将$2-n$的数质因数分解，对于一个数得到他的$\le \sqrt n$质因数集合和一个大于$\sqrt n$的质因数$bigprime$，没有就设为$1$，我们再按照$bigprime$的大小排序，对于一段相同的$bigprime$，我们定义$f1[s_1][s_2],f2[s_1][s_2]$表示$bigprime$在$s_1,s_2$集合内的方案数，最后$f[s_1][s_2]=f1[s_1][s_2]+f2[s_1][s_2]-f[s_1][s_2]$。

[$code$](https://captaindag.github.io/2020/04/03/NOI2015-%E5%AF%BF%E5%8F%B8%E6%99%9A%E5%AE%B4/)

---

## 作者：红尘仙 (赞：1)

传送门 ： [寿司晚宴](https://www.luogu.com.cn/problem/P2150)
### 【Description】:
给定 $n - 1$ 个数 $a_i$ , $a_i$ 满足 $a_i = i + 1$ , 将 $n - 1$ 个数分成两堆，两堆必须满足互质，求解方案数。

+ 对于 $30\%$ 数据 满足 $n \leq 30$ 
+ 对于 $100\%$  数据 满足 $n \leq 500$ 

### 【Solution】:

#### Part 1 
对于 $30%$ 的数据 ， 我们显然能够想到，我们状压 $G$ 和 $W$ 选择的质数集。

方案数合法的充要条件 ：  
> $G$ 所选的集合 $P$ 和 $W$ 选择 $W$ 的集合满足 ：
$G\in S , W \in T , S \cap T = \phi$

> $S , T$ 是两个大质数集。 

我们发现 $n \leq 30$ 的时候，最多只有 $10$ 个 质数。 

为了表示整个局面和下一步的转移，我们设 $f_{i,G,W}$ 为 选完 $i$ 这个寿司，$G$ 选择的质数集， $W$ 选择的质数集  为 $G ,  W$ ,显然我们对于状态转移，就是这个寿司是选择，就有状态转移 ： 


 $f[i][G|P_i][W] += f[i - 1][G][W]$ , $p_i \text{\&} W = 0$

 $f[i][G][W|P_i] += f[i - 1][G][W]$ , $p_i \& W = 0$



$P_i$ 则是代表第 $i$ 个寿司的美味度的质因数集。 


$$Then \ \ we \ \ can \ \ get \ \ 30 \ \ points .$$

#### Part 2 , 3 

当 $n \leq 200$ 的时候，想不出来和 $n\leq 500$ 有什么不一样的做法。 

#### Part 4 

当 $n \leq 500$ 时 ， 显然状压 $500$ 以内的质因子集是不大现实，$500$ 以内的质数个数是 $95$ 个来着，状压个锤子 。 

有一个结论可能会帮你完成该题

> 对于一个数 $n$ 最多有一个 > $\sqrt n$ 的质因子。 


那么我们就能够直接取出这一个质因子即可。  设为 $big$ ，其他我们设为 $small$ ，$\sqrt 500$ 大概取 $22$ ，所以 我们求解 $small$ 的时候，只需要将 $22$ 以内的质数搞一下分解就好。

所有 $big$ 相同的数显然只能放在一个集合中，所以按照 $big$ 的大小排序，这样就可以把所有 $big$ 相同的数放在一起算 。 

在计算 $big$ 相同的时候，我们发现，就和 $30 \ \ opts$ 是一样的，我们设 $f_1[P][W] ,f_2[P][W]$ 去转移 $30 \ \ opts$ 的状态转移 。 

小小的容斥原理 $f[P][W]$ 加了两遍 

$f[P][W] = f_1[P][W] + f_2[P][W] - f[P][W]$ , 。 

最后取答案 $ans = \sum_{P}\sum_{W} f_{P,W}$ 。

### 【Code】

```
/*
Author : Zmonarch
知识点 ：代码实现看的第一篇题解。
*/
#include <bits/stdc++.h>
#define int long long
#define qwq register
#define qaq inline
#define inf 2147483647
using namespace std ;
const int kmaxn = 550 ;
const int kmod = 1e9 + 7 ;
const int eps = 1e-6 ;
const int num[] = {0 , 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19} ; 
inline int read() {
	int x = 0 , f = 1 ; char ch = getchar() ;
	while(!isdigit(ch)) {if(ch == '-') f = - 1 ; ch = getchar() ;}
	while( isdigit(ch)) {x = x * 10 + ch - '0' ; ch = getchar() ;}
	return x * f ;
}
int n , mod , ans ; 
int f[kmaxn][kmaxn] , f1[kmaxn][kmaxn] , f2[kmaxn][kmaxn] ; 
struct node 
{
	int S = 0 , big , val ; //质数集合 ， 大质数
	void init()  
	{
		int tmp = val ; big = 0 ;
		for(int i = 1 ; i <= 8 ; i++) //分解质因数 	
		{
			if(tmp % num[i]) continue ; 
			S |= (1 << (i - 1)) ;  
			while((tmp % num[i]) == 0) tmp /= num[i] ;  
		}
		if(tmp != 1) big = tmp ; 
	}
}a[kmaxn] ; 
inline bool cmp(node a , node b) {return a.big < b.big ;} 
signed main()
{
	n = read() , mod = read() ; 
	for(qwq int i = 2 ; i <= n ; i++) a[i - 1].val = i , a[i - 1].init() ; 
	std::sort(a + 1 , a + n , cmp) ;f[0][0] = 1 ; 
	for(qwq int i = 1 ; i <= n - 1 ; i++)
	{
		if((i == 1) || (a[i].big != a[i - 1].big) || (!a[i].big)) 
		{
			memcpy(f1 , f , sizeof(f1)) ; 
			memcpy(f2 , f , sizeof(f2)) ; 
		}
		for(int j=255; j>=0; j--) 
		  for(int k=255; k>=0; k--) 
		  {
		  	if(j & k) continue ; 
		  	if(!(a[i].S & j)) f2[j][k | a[i].S] = (f2[j][k | a[i].S] + f2[j][k]) % mod ; 
		  	if(!(a[i].S & k)) f1[j | a[i].S][k] = (f1[j | a[i].S][k] + f1[j][k]) % mod;
		  }
		if((i == n - 1) || (a[i].big != a[i + 1].big) || (!a[i].big))
		{
			for(int j=0; j<=255; j++) 
			 for(int k=0; k<=255; k++) 
			 {
			  	if(j & k) continue ; 
			  	f[j][k] = ( (f1[j][k] + f2[j][k] ) % mod - f[j][k] + mod) % mod ;
			 }
		} 
	}
	ans = 0 ; 
	for(int j=0; j<=255; j++) 
	 for(int k=0; k<=255; k++) 
	  if(!(j & k)) ans = (ans + f[j][k]) % mod ;
	printf("%lld\n" , ans) ; 
	return 0 ;
}
```





---

## 作者：panjoel (赞：1)

这题的意思相当于求将2−n的数划分成两个集合(有的数可以不用)的满足条件方案数。

条件是两个集合中的数互质。n⩽500

考虑n⩽20的情况，这时候总共只有88个质数，所以可以状压两个集合所包含的素数集合，每次枚举这个数被谁选择即可。

对于n⩽500,每个数最多只会有一个⩾$\sqrt{n}$
的质因子，所以对于一段最大质因子为p的数(p⩾$\sqrt{n}$)，要么划分进一个集合，要么都不选。

### AC代码
```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn = 505;
int n, mod, f[1 << 8][1 << 8], g[2][1 << 8][1 << 8];
pair<int, int> a[maxn];

inline int gi()
{
    char c = getchar();
    while (c < '0' || c > '9') c = getchar();
    int sum = 0;
    while ('0' <= c && c <= '9') sum = sum * 10 + c - 48, c = getchar();
    return sum;
}

const int maxp = 8;
const int p[8] = {
    2, 3, 5, 7, 11, 13, 17, 19
};

inline void inc(int &a, int b)
{
    a += b;
    if (a >= mod) a -= mod;
}

int main()
{
    n = gi(); mod = gi();
    for (int i = 2; i <= n; ++i) {
        int k = i;
        for (int j = 0; j < maxp; ++j)
            if (k % p[j] == 0) {
                a[i].second ^= 1 << j;
                while (k % p[j] == 0) k /= p[j];
            }
        a[i].first = k;
    }

    sort(a + 2, a + n + 1);
    f[0][0] = 1;
    for (int i = 2; i <= n; ++i) {
        if (i == 2 || a[i].first == 1 || a[i].first != a[i - 1].first) {
            memcpy(g[0], f, sizeof(g[0]));
            memcpy(g[1], f, sizeof(g[1]));
        }
        for (int s1 = (1 << maxp) - 1; s1 >= 0; --s1)
            for (int s2 = (1 << maxp) - 1; s2 >= 0; --s2) {
                if ((s2 & a[i].second) == 0) inc(g[0][s1 | a[i].second][s2], g[0][s1][s2]);
                if ((s1 & a[i].second) == 0) inc(g[1][s1][s2 | a[i].second], g[1][s1][s2]);
            }

        if (i == n || a[i].first == 1 || a[i].first != a[i + 1].first) {
            for (int s1 = (1 << maxp) - 1; ~s1; --s1)
                for (int s2 = (1 << maxp) - 1; ~s2; --s2) {
                    f[s1][s2] = g[0][s1][s2] + g[1][s1][s2] - f[s1][s2];
                    if (f[s1][s2] < 0) f[s1][s2] += mod;
                    if (f[s1][s2] >= mod) f[s1][s2] -= mod;
                }
        }

    }

    int ans = 0;
    for (int s1 = (1 << maxp) - 1; ~s1; --s1)
        for (int s2 = (1 << maxp) - 1; ~s2; --s2)
            if ((s1 & s2) == 0) inc(ans, f[s1][s2]);
    printf("%d\n", ans);

    return 0;
}
```


---

## 作者：Jayun (赞：0)

# 链接：

[洛谷](https://www.luogu.com.cn/problem/P2150)

[博客园](https://www.cnblogs.com/GJY-JURUO/p/14769806.html)

# 题目大意：

有 $n-1$ 个数，第 $i$ 数是 $i+1$。在这其中选两组数，求这两组数不互质的方案数。

$n\leq500$。

# 正文：

## 30pts：

分解质因数，在 $n\leq30$ 以内的素数只有 $10$ 个，设 $f_{i,a,b}$ 表示当前操作到第 $i$ 个数，第一组的素数集合是 $a$，第二组的素数集合是 $b$ 的方案数。

于是可以这么转移：

$$f_{i,a,b}\Rightarrow\left\{\begin{matrix}
f_{i+1,a\cup k,b}  & (b\cap k=\varnothing)\\
f_{i+1,a,b\cup k}  & (a\cap k=\varnothing)
\end{matrix}\right.$$

进行滚动数组，还可以优化空间。

时间复杂度 $\mathcal{O}(2^{20}n)$。

## 100pts：

一个小于等于 $n$ 的数只有若干个小于等于 $\sqrt{n}$ 的小质因数和最多一个大于 $\sqrt{n}$ 的大质因数。因为题目中有给定要互质，那么含有大质因数的数要么全分到 $a$ 要么全分到 $b$，那么再设 $g_{a,b},h_{a,b}$ 分别表示当前有大质因数的数全分给 $a$ 或 $b$ 的方案数。然后对每个数按大质因数分组（若没有，自己为独立一组），按组统计，合并。合并时，$f_{a,b}=g_{a,b}+h_{a,b}-f_{a,b}$，减去的是两组重复计算的两组都没有分到任何一个有大质因数的数的方案数。

# 代码：

```cpp
const int N = 510;

inline ll READ()
{
	ll x = 0, f = 1;
	char c = getchar();
	while (c != '-' && (c < '0' || c > '9')) c = getchar();
	if (c == '-') f = -f, c = getchar();
	while (c >= '0' && c <= '9') x = (x << 3) + (x << 1) + c - '0', c = getchar();
	return x * f;
}

int n;
ll p;
int pri[10] = {2, 3, 5, 7, 11, 13, 17, 19};

struct Val
{
	int val, part1, part2;
	Val(){part2 = -1;} 
	void Set(int x)
	{
		part2 = 0;
		val = x;
		for (int i = 0; i < 8; i++)
			for (; !(x % pri[i]); x /= pri[i]) part1 |= 1 << i; 
		if (x != 1) part2 = x;
	}
	bool operator < (Val &a) const
	{
		return part2 < a.part2;
	}
}a[N];

ll f[N][N], g[N][N], h[N][N], ans;

int main()
{
	n = READ(), p = READ(); 
	for (int i = 1; i < n; i++) a[i].Set(i + 1);
	
	sort (a + 1, a + n);
	
	f[0][0] = 1;
	for (int i = 1; i < n; i++)
	{
		if (i == 1 || a[i].part2 != a[i - 1].part2 || !a[i].part2)
		{
			memcpy(g, f, sizeof g);
			memcpy(h, f, sizeof h);
		}
		for (int j = 256; j >= 0; j--)
			for (int k = 256; k >= 0; k--)
				if(!(j & k))
				{
					if (!(a[i].part1 & k)) (g[j | a[i].part1][k] += g[j][k]) %= p;
					if (!(a[i].part1 & j)) (h[j][k | a[i].part1] += h[j][k]) %= p;
				}
		if (i == n - 1 || a[i].part2 != a[i + 1].part2 || !a[i].part2)
		{
			ans = 0;
			for (int j = 0; j <= 256; j++)
				for (int k = 0; k <= 256; k++)
					if(!(j & k)) f[j][k] = (g[j][k] + h[j][k] + p - f[j][k]) % p, ans = (ans + max(f[j][k], 0ll)) % p;
			if (i == n - 1) printf ("%lld\n", ans);
		}
	}
	
	return 0;
}
```

---

## 作者：ZBHRuaRua (赞：0)

首先考虑30分做法，我们可以发现30以内的质因子只有10个，那么将每个数分解质因数后，就可以直接状压了，倒序遍历所有情况即可。

F[ i ][ j ]表示左边是i这种情况，右边是j这种情况的情况数。

最后在统计答案时只需判断i&j是否等于0即可

那么100分的做法呢？

经过一阵思考（观摩题解），我们可以发现每个500以内的数最多有一个大于19的质因子（23 * 23>500),因此对于小于等于19的8个质因子，我们就像30分那样的做法做即可，对于大于19的质因子，我们把它存在结构体中的big变量中，并且以big大小对e数组进行排序，这样在一段相同的big区间中，我们只能把这个big质数分给左边或者右边或者两边都不分，利用这样的性质，我们即可写出代码啦，具体可以看一下注释

注意数组不要开大了，否则会因为空间大而导致时间爆，当然如果快读应该就没关系了

Code：
```
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<iostream>
#include<iomanip>
#include<algorithm>
#define ll long long
using namespace std;
ll n,mod;
struct node{
	ll big,zy;
}e[505];
ll prime[8]={2,3,5,7,11,13,17,19};
inline bool cmp(node a,node b)
{
	return a.big<b.big;
}
ll F[300][300];
ll p[3][300][300];
ll ans;
int main()
{
	scanf("%lld%lld",&n,&mod);
	for(int i=2;i<=n;i++)
	{
		ll tmp=i;
		for(int j=0;j<8;j++)
		{
			if(tmp%prime[j]==0)
			{
				e[i].zy=(e[i].zy<<1)+1;
			}
			else e[i].zy<<=1;
			while(tmp%prime[j]==0) tmp/=prime[j];
		}
		if(tmp>1) e[i].big=tmp;
	}
	sort(e+2,e+n+1,cmp);
	F[0][0]=1;
	for(int i=2;i<=n;i++)
	{
		if(!e[i].big||e[i].big!=e[i-1].big)
		{
			memcpy(p[1],F,sizeof(F));
			memcpy(p[2],F,sizeof(F));
		}  
		for(int j=255;j>=0;j--)
		for(int k=255;k>=0;k--)
		{
			if((j&e[i].zy)==0) p[1][j][k|e[i].zy]=(p[1][j][k|e[i].zy]+p[1][j][k])%mod;//p[1]代表把big分给右边
			if((k&e[i].zy)==0) p[2][j|e[i].zy][k]=(p[2][j|e[i].zy][k]+p[2][j][k])%mod;//p[2]代表把big分给左边
		}
		if(!e[i].big||e[i].big!=e[i+1].big)
		{
			for(int j=0;j<=255;j++)
			for(int k=0;k<=255;k++)
			{
				F[j][k]=((p[1][j][k]+p[2][j][k]-F[j][k])%mod+mod)%mod;//相当于原来的F【j】【k】代表big既不给左也不给右
			}
		}
	} 
	for(int i=0;i<=255;i++)
	for(int j=0;j<=255;j++)
	{
		if((i&j)==0)
		{
			ans+=F[i][j];
			ans%=mod;
		}
	}
	cout<<ans<<endl;
	return 0;
} 
```


---

## 作者：Vector_Mingfan (赞：0)

#### 题目：[P2150 [NOI2015]寿司晚宴](https://www.luogu.com.cn/problem/P2150)

O2优化终于有用了！(雾

![](https://cdn.luogu.com.cn/upload/image_hosting/hn7ixc4h.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

------------
切回正题：

~~这题一眼望去，以OIer的直觉，嗯，考DP。~~

$分析：本题大致可以理解成，两人不能有同一素数倍数的寿司。$

   小于 $\sqrt{500}$ 的素数有8个
   
  $ E.g. 选了6，相当于选了2，3，则；另一人不能选2，3的倍数$


------------


变量：

d p [ j ] [ k ] 表 示 小 G 为 j 小 W 为 k 的 方 案 数 ;

g [ 1 ] [ j ] [ k ] 表 示 小 G 选;

g [ 2 ] [ j ] [ k ] 表 示 小 w 选

注意一个数可能有大于$\sqrt{500}$的因数，但显然只能有一个，记录下为k、i，如果k、i相同也不能选

转 移 后 ： f [ j ] [ k ] = p [ 1 ] [ j ] [ k ] + p [ 2 ] [ j ] [ k ] - f [ j ] [ k ]  。

因为d p [ j ] [ k ]在g [ 1 ] , g [ 2 ]都算了 ， 所以我们要减去d p [ j ] [ k ]。


------------

代码如下：

```cpp
#include <iostream>
#include <cstdio>
#include<algorithm>
#define MAXX 505
#define nice 255
#define ll long long
using namespace std;

struct Node {
	ll S , K;
} a[MAXX];
ll N , tmp , Ans;
ll db[8] = {2 , 3 , 5 , 7 , 11 , 13 , 17 , 19};
ll g[3][MAXX][MAXX] , dp[MAXX][MAXX] , Mod;

bool cmp(Node a , Node b) {//排序 
	if (a.K != b.K ) return a.K < b.K ;
	else return a.S < b.S ;
}

int main(void) {
	scanf("%lld %lld",&N,&Mod);
	
	for (int i=1; i<=N; i++) {
		tmp = i;
		
		for (int j=0; j<8; j++) {
			if (!(tmp % db[j])) {
				a[i].S |= 1<<j;
				while (!(tmp % db[j])) {
					tmp /= db[j];
				}
			}
		}
		
		a[i].K = tmp;
	}
	
	stable_sort(a + 2 , a + N + 1 , cmp);
	
	dp[0][0] = 1; 
	for (ll i=2; i<=N; i++) {
		if (i == 2 or a[i].K == 1 or a[i].K != a[i - 1].K ) {
			for (ll j=0; j<=nice; j++) {
				for (ll k=0; k<=nice; k++) {
					g[1][j][k] = dp[j][k];
					g[2][j][k] = dp[j][k];
				}
			}
		}
		
		for (ll j=nice; j>=0; j--) {
			for (ll k=nice; k>=0; k--) {
				if ((k & a[i].S ) == 0) {
					g[1][j|a[i].S ][k] = (g[1][j|a[i].S ][k] + g[1][j][k]) % Mod;
				}
				if ((j & a[i].S ) == 0) {
					g[2][j][k|a[i].S ] = (g[2][j][k|a[i].S ] + g[2][j][k]) % Mod;
				}
			}
		}
		
		if (i == N or a[i].K == 1 or a[i].K != a[i + 1].K ) {
			for (ll j=0; j<=nice; j++) {
				for (ll k=0; k<=nice; k++) {
					dp[j][k]=((g[1][j][k] + g[2][j][k] - dp[j][k]) % Mod + Mod) % Mod;
				}
			}
		}
	}
	
	for (ll i=0; i<=nice; i++) {
		for (ll j=0; j<=nice; j++) {
			if ((i & j) == 0) {
				Ans = (Ans + dp[i][j]) % Mod;
			}
		}
	}
	
	printf("%lld",Ans);
	
	return 0;
}

```

---


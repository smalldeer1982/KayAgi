# [SCOI2009] 围豆豆

## 题目背景

四川NOI2009省选


## 题目描述

是不是平时在手机里玩吃豆豆游戏玩腻了呢？最近MOKIA手机上推出了一种新的围豆豆游戏，大家一起来试一试吧。


游戏的规则非常简单，在一个N×M的矩阵方格内分布着D颗豆子，每颗豆有不同的分值Vi。游戏者可以选择任意一个方格作为起始格，每次移动可以随意的走到相邻的四个格子，直到最终又回到起始格。最终游戏者的得分为所有被路径围住的豆豆的分值总和减去游戏者移动的步数。矩阵中某些格子内设有障碍物，任何时刻游戏者不能进入包含障碍物或豆子的格子。游戏者可能的最低得分为0，即什么都不做。


注意路径包围的概念，即某一颗豆在路径所形成的多边形（可能是含自交的复杂多边形）的内部。下面有两个例子：

 
 ![](https://cdn.luogu.com.cn/upload/pic/1690.png) 

第一个例子中，豆在路径围成的矩形内部，所以豆被围住了。第二个例子中，虽然路径经过了豆的周围的8个格子，但是路径形成的多边形内部并不包含豆，所以没有围住豆子。

布布最近迷上了这款游戏，但是怎么玩都拿不了高分。聪明的你决定写一个程序来帮助他顺利通关。


## 说明/提示

50%的数据满足1≤D≤3。

100%的数据满足1≤D≤9，1≤N, M≤10，-10000≤Vi≤10000。


## 样例 #1

### 输入

```
3 8
3
30 -100 30
00000000
010203#0
00000000
```

### 输出

```
38```

# 题解

## 作者：hzoi_liuchang (赞：25)

[我的博客](https://www.cnblogs.com/liuchanglc/p/12701293.html)
## 分析
 一看到是方格中的问题，数据范围又在10以下，显然是状态压缩DP了

这道题的细节比较多，而且用到了位运算，所以有些代码不太好理解，因此我感觉分块讲会比较好理解

### 问题一、数组的定义
如果你要进行动态规划，肯定要开一个数组存储存储结果

这道题开二维数组显然是不够用的，因为我们既要记录一个点的横坐标，又要记录一个点的纵坐标

我们设f[x][y][s]为走到坐标为（x,y）的点，且状态为S时所走过的路程长度

x,y的含义大家应该很容易就可以理解，关键是状态S

我们可以这样想在方格中最多有9个豆豆，所以我们可以用一个长度为9的二进制数来存储状态

什么意思呢？我们还是来举一个例子

比如说方格中有4个豆子，那么

0 0 0 0 表示你一个豆子也没有围上

0 0 1 0 表示你把第二个豆子围上

0 1 1 1 表示你把第1、2、3个豆子全部围上

这样的话大家应该就可以理解了

这里还需要注意的是，因为我们每一次开始遍历的起点不同，所以最终得到的答案也不同，因此我们每选择一个起点，就要重新将f数组初始化

### 问题二、围住的判断
只有某一颗豆在路径所形成的多边形（可能是含自交的复杂多边形）的内部时，我们才可以得到这个豆子的价值

我们来举几个例子
![](https://cdn.luogu.com.cn/upload/image_hosting/15iyuy2j.png)
 我们可以看到，左边的这两幅图中豆豆是可以被围住的，而右边的这两幅图中，豆豆是无法被围住的

那么它们分别有什么特点呢？

我们从豆豆开始向右引一条射线（其实向哪一个方向都可以），如果射线与路径的交点为奇数个，那么豆豆能被围住，反之则不能

 （这其实就是射线定理，大家有兴趣的话可以百度一下证明）

这样的话，我们只要判断路径与射线的交点个数是不是就可以了呢

其实还是不行，比如下面这幅图
![](https://cdn.luogu.com.cn/upload/image_hosting/d7zab315.png)
 射线与路径的交点有三个（绿色的圈圈住的部分），但是豆豆没有被包含在里面

所以只有当上下移动时，我们才可以给路径计数，如果是左右水平移动的话，我们就不能算进去
![](https://cdn.luogu.com.cn/upload/image_hosting/oiqtrb6d.png)
这是对于上下移动的判断，mx、my分别是移动之前点的横纵坐标，nx、ny分别是移动之后点的横纵坐标

ax数组记录的是所有豆豆的横坐标，ay数组记录的是所有豆豆的纵坐标

前面的四个判断是对于上下移动的判断，只有上下移动才可以计数

最后一个判断是判断该路径是否在豆豆的右边（因为我是向右引的射线）

当然你把里面的==都改成>=也可以，但是没有必要，因为你一次只能走一个格子

### 问题三、怎么由上一个格子的状态ms推出下一个格子的状态ns
先上代码
```cpp
int solve(int mx,int my,int nx,int ny,int ms){
    int ns=ms;
    for(int i=1;i<=d;i++){
        if(((mx==ax[i] && nx<ax[i]) || (mx<ax[i] && nx==ax[i])) && ny>ay[i]){
            ns^=(1<<(i-1));
        }
    }
    return ns;
}
```
mx、my分别是移动之前点的横纵坐标，nx、ny分别是移动之后点的横纵坐标

ms是上一个格子的状态，ns是下一个格子的状态（什么是状态我们在第一个问题中已经提到过了）

ax数组记录的是所有豆豆的横坐标，ay数组记录的是所有豆豆的纵坐标

在第三行我们枚举每一个豆豆，在第四行我们判断当前移动能否计数（问题二中已经说过）

最关键的就是第五行  ns^=(1<<(i-1))

这是什么意思呢，我们可以这样考虑

ns必定要由ms推导出来，我们枚举每一个豆豆，如果当前走的路径可以与射线相交，那么必定会改变交点个数的奇偶性

也就是说，豆豆本来在四边形内，走了这一步，就到了四边形外；或者豆豆本来在四边形外，走了这一步，就到了四边形内

我们知道状态S如果从右往左数第i位为1，则说明第i个豆豆在格子内，反之亦然

那么如果从右往左数第i位状态变化了，我们只需要将当前的状态和（1<<(i-1)）取异或，就相当于把第i为取反，其他位不变

这样就达到了我们的目的

（我感觉已经讲得很清楚了，如果再不理解，我也没有办法了）
## 问题四、通过什么来算出f数组呢
我们可以用SPFA，也可以用bfs

不同的是bfs每个元素只会进栈一次，而SPFA可以进很多次 

但是实际上你即使用SPFA每个点也只会松弛一次，因为你的路径只会越走越长用bfs和用SPFA没什么区别

但是要注意vis数组的初始化，用bfs的话vis数组必须初始化，但是用SPFA则不用

因为SPFAvis数组最后的状态必定都0

最终的状态转移方程为：ans=max(ans,val[i]-f[ii][jj][i])
val[i]是我们预处理出来的状态为i时豆子的总价值，预处理过程如下:
```cpp
  for(int i=0;i<mmax;i++){
        for(int j=1;j<=d;j++){
            if(i&(1<<(j-1))) val[i]+=da[j];
        }
    }
```
da[j]是第j个豆子的价值，ans使我们最终要的结果

豆子的总价值减去路程上的花费得出来的结果，最后再取一个最大值显然是我们想要的ans
## 代码（前面该说的都说了，注释我就少加点）
bfs版
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<queue>
#include<cstring>
using namespace std;
int n,m,d;
int mmax,f[11][11][1<<11],da[11],val[1<<11];
struct asd{
    int x,y,s;
    asd(int aa=0,int bb=0,int cc=0){
        x=aa,y=bb,s=cc;
    }
};//跑bfs的结构体
char c[11][11];
int xx[4]={0,-1,0,1},yy[4]={-1,0,1,0},ax[11],ay[11];
//xx,yy枚举走的方向，ax,ay记录豆豆的横纵坐标
int ans=-0x3f3f3f3f;//记录最终价值
int vis[11][11][1<<11];//判断该点是否已经遍历过
int solve(int mx,int my,int nx,int ny,int ms){
    int ns=ms;
    for(int i=1;i<=d;i++){
        if(((mx==ax[i] && nx<ax[i]) || (mx<ax[i] && nx==ax[i])) && ny>ay[i]){
            ns^=(1<<(i-1));
        }
    }
    return ns;
}
void bfs(int ii,int jj){
    queue<asd> q;
    q.push(asd(ii,jj,0));
    memset(f,0x3f,sizeof(f));
    memset(vis,0,sizeof(vis));
    f[ii][jj][0]=0;
    while(!q.empty()){
        asd aa=q.front();
        q.pop();
        int mx=aa.x,my=aa.y,ms=aa.s;
        vis[mx][my][ms]=1;
        for(int i=0;i<4;i++){
            int nx=mx+xx[i],ny=my+yy[i];
            if(nx<1 || ny<1 || nx>n || ny>m || (c[nx][ny]>='1' && c[nx][ny]<='9') || c[nx][ny]=='#') continue;
             //判断该点是否能走
            //注意豆豆所在的方格也不能走
            int ns=ms;
            if(i&1) ns=solve(mx,my,nx,ny,ms);
            //只有在上下走的时候才改变状态，否则状态不变
            //如果不能理解也可以写成i==1 || i==3
            if(vis[nx][ny][ns]==1) continue;    
            //如果已经更新过，就不再更新
            if(f[mx][my][ms]<f[nx][ny][ns]){
                f[nx][ny][ns]=f[mx][my][ms]+1;
                vis[nx][ny][ns]=1;
                q.push(asd(nx,ny,ns));
            }
        }
    }
    for(int i=0;i<mmax;i++){
        ans=max(ans,val[i]-f[ii][jj][i]);
    }
}
int main(){
    scanf("%d%d%d",&n,&m,&d);
    for(int i=1;i<=d;i++){
        scanf("%d",&da[i]);
    }
    mmax=1<<d;
    for(int i=0;i<mmax;i++){
        for(int j=1;j<=d;j++){
            if(i&(1<<(j-1))) val[i]+=da[j];
        }
    }
    for(int i=1;i<=n;i++){
        scanf("%s",c[i]+1);
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(c[i][j]>'0' && c[i][j]<='9'){
                int now=c[i][j]-'0';
                ax[now]=i,ay[now]=j;
            }
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(c[i][j]=='0'){
                bfs(i,j);
                //如果该点为0，就可以作为起点
            }
        }
    }
    printf("%d\n",ans);
    return 0;
}

```
SPFA版
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<queue>
#include<cstring>
using namespace std;
int n,m,d;
int mmax,f[11][11][1<<11],da[11],val[1<<11];
struct asd{
    int x,y,s;
    asd(int aa=0,int bb=0,int cc=0){
        x=aa,y=bb,s=cc;
    }
}b[11*11];
char c[11][11];
int xx[4]={0,-1,0,1},yy[4]={-1,0,1,0},ax[12],ay[12];
int ans=-0x3f3f3f3f;
int vis[12][12][1<<12];
inline int solve(int mx,int my,int nx,int ny,int ms){
    int ns=ms;
    for(int i=1;i<=d;i++){
        if(((mx==ax[i] && nx<ax[i]) || (mx<ax[i] && nx==ax[i])) && ny>ay[i]){
            ns^=(1<<(i-1));
        }
    }
    return ns;
}
inline void SPFA(int ii,int jj){
    queue<asd> q;
    q.push(asd(ii,jj,0));
    memset(f,0x3f,sizeof(f));
    f[ii][jj][0]=0;
    //memset(vis,0,sizeof(vis));
    while(!q.empty()){
        asd aa=q.front();
        q.pop();
        int mx=aa.x,my=aa.y,ms=aa.s;
        vis[mx][my][ms]=0;
        for(int i=0;i<4;i++){
            int nx=mx+xx[i],ny=my+yy[i];
            if(nx<1 || ny<1 || nx>n || ny>m || (c[nx][ny]>='1' && c[nx][ny]<='9') || c[nx][ny]=='#') continue;
            int ns=ms;
            if(i&1) ns=solve(mx,my,nx,ny,ms);
            if(f[mx][my][ms]<f[nx][ny][ns]){
                f[nx][ny][ns]=f[mx][my][ms]+1;
                if(vis[nx][ny][ns]==0){
                    vis[nx][ny][ns]=1;
                    q.push(asd(nx,ny,ns));
                }
            }
        }
    }
    for(int i=0;i<mmax;i++){
        ans=max(ans,val[i]-f[ii][jj][i]);
    }
}
int main(){
    scanf("%d%d%d",&n,&m,&d);
    for(int i=1;i<=d;i++){
        scanf("%d",&da[i]);
    }
    mmax=1<<d;
    for(int i=0;i<mmax;i++){
        for(int j=1;j<=d;j++){
            if(i&(1<<(j-1))) val[i]+=da[j];
        }
    }
    for(int i=1;i<=n;i++){
        scanf("%s",c[i]+1);
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(c[i][j]>'0' && c[i][j]<='9'){
                int now=c[i][j]-'0';
                ax[now]=i,ay[now]=j;
            }
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(c[i][j]=='0'){
                SPFA(i,j);
            }
        }
    }
    printf("%d\n",ans);
    return 0;
}

```
大家一定要注意vis数组的初始化

而且数组不要开太大，否则会T

下面是一个错解，也就是bfs的vis数组没有初始化
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<queue>
#include<cstring>
using namespace std;
int n,m,d;
int mmax,f[11][11][1<<11],da[11],val[1<<11];
struct asd{
    int x,y,s;
    asd(int aa=0,int bb=0,int cc=0){
        x=aa,y=bb,s=cc;
    }
};//跑bfs的结构体
char c[11][11];
int xx[4]={0,-1,0,1},yy[4]={-1,0,1,0},ax[11],ay[11];
//xx,yy枚举走的方向，ax,ay记录豆豆的横纵坐标
int ans=-0x3f3f3f3f;//记录最终价值
int vis[11][11][1<<11];//判断该点是否已经遍历过
int solve(int mx,int my,int nx,int ny,int ms){
    int ns=ms;
    for(int i=1;i<=d;i++){
        if(((mx==ax[i] && nx<ax[i]) || (mx<ax[i] && nx==ax[i])) && ny>ay[i]){
            ns^=(1<<(i-1));
        }
    }
    return ns;
}
void bfs(int ii,int jj){
    queue<asd> q;
    q.push(asd(ii,jj,0));
    memset(f,0x3f,sizeof(f));
    f[ii][jj][0]=0;
    while(!q.empty()){
        asd aa=q.front();
        q.pop();
        int mx=aa.x,my=aa.y,ms=aa.s;
        vis[mx][my][ms]=1;
        for(int i=0;i<4;i++){
            int nx=mx+xx[i],ny=my+yy[i];
            if(nx<1 || ny<1 || nx>n || ny>m || (c[nx][ny]>='1' && c[nx][ny]<='9') || c[nx][ny]=='#') continue;
             //判断该点是否能走
            //注意豆豆所在的方格也不能走
            int ns=ms;
            if(i&1) ns=solve(mx,my,nx,ny,ms);
            //只有在上下走的时候才改变状态，否则状态不变
            //如果不能理解也可以写成i==1 || i==3
            if(vis[nx][ny][ns]==1) continue;    
            //如果已经更新过，就不再更新
            if(f[mx][my][ms]<f[nx][ny][ns]){
                f[nx][ny][ns]=f[mx][my][ms]+1;
                if(vis[nx][ny][ns]==0){
                    vis[nx][ny][ns]=1;
                    q.push(asd(nx,ny,ns));
                }
            }
        }
    }
    for(int i=0;i<mmax;i++){
        ans=max(ans,val[i]-f[ii][jj][i]);
    }
}
int main(){
    scanf("%d%d%d",&n,&m,&d);
    for(int i=1;i<=d;i++){
        scanf("%d",&da[i]);
    }
    mmax=1<<d;
    for(int i=0;i<mmax;i++){
        for(int j=1;j<=d;j++){
            if(i&(1<<(j-1))) val[i]+=da[j];
        }
    }
    for(int i=1;i<=n;i++){
        scanf("%s",c[i]+1);
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(c[i][j]>'0' && c[i][j]<='9'){
                int now=c[i][j]-'0';
                ax[now]=i,ay[now]=j;
            }
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(c[i][j]=='0'){
                bfs(i,j);
                //如果该点为0，就可以作为起点
            }
        }
    }
    printf("%d\n",ans);
    return 0;
}

```
但是令人震惊的是，它竟然能过，而且比正解快10倍，只用70ms

引用pl.er()大佬的思路

它之所以快是因为第一次遍历之后vis数组没有初始化，于是在之后的遍历中它们就不会再进栈

但是这样做显然是错误的，比如下面这组数据

```
5 5
1
1000
00000
00000
01000
00000
00000
```
正解是992，但是错解却输出990

因此大家一定要注意

---

## 作者：lsj2009 (赞：7)

观察数据范围，容易想到的是状压 dp，设 $f_{x,y,s}$ 表示为当前在坐标 $(x,y)$，被包围的豆子状态是 $s$。

这题的最关键一步是如何判断豆子是否被包围。因为我们需要从某个点出发，再回到那个点，所以我们经过的路径必然是一个封闭的多边形。容易说明的是，如果我们从点 $(x,y)$ 作一条向右的射线（事实上，向任意方向都可以），如果他与 $k$ 条路径相交，$(x,y)$ 被包围当且仅当 $2\nmid k$。

考虑使用数学归纳法、对 $k$ 的奇偶性进行讨论易证，这里不再赘述。

然后考虑转移。首先对于前两维 $(x,y)$ 的转移时显然的，直接 $\text{bfs}$ 即可。最主要的是 $s$ 的转移。事实上，开始定义状态时，我们称 $s$ 为“被包围的豆子的状态”是不妥当的，更准确的应为 $s$ 为包围的豆子的 $k$ 的奇偶性状态，其中 $k$ 即为第二段中的定义，因为由第二段可知，我们只需要记录 $k$ 的奇偶性就可以判断该豆子是否在范围内。具体的，当我们从豆子上方走到豆子下方，或者从豆子下方走到豆子上方，而且我们是在豆子右边运动时，就将 $k$ 取反。

然后就做完了，复杂度大概是 $\Theta(n^2m^2\cdot 2^d)$，即枚举起止点时间 $\Theta(nm)$，进行 $\text{bfs}$ 计算的复杂度为 $\Theta(nm\cdot 2^d)$。

---

## 作者：Mr_HY43205 (赞：6)

[P2566 [SCOI2009]围豆豆](https://www.luogu.com.cn/problem/P2566)

### 题意
在 $N\times M$ 的网格中有 $D$ 颗豆子，第 $i$ 颗豆价值 $V_i$。图中有些格子上有障碍物。从任意一格开始，用一条回路围住豆子，得分为围住豆子的价值和减去回路的长度，求最高得分。

##### 注：
1. 回路不能经过豆子/障碍物所在格。
1. 最低得分为 $0$（不移动）。

##### 数据范围：
$1\leq N,M \leq 10,1\leq D\leq 9, |V_i|\leq10000$。

###### 关键词：状态压缩，动态规划，Dijkstra 算法

------------
### 解题思路
首先考虑搜索。搜索的基本思路就是找出一条回路，统计出得分并更新答案。因此，我们搜索的框架就是枚举起点，从一格出发向四个方向搜索，如果回到起点就更新答案。

搜索的状态可以记为
$$dfs(x, y)\to \begin{cases}
dfs(x+1,y) ,& \text{if}\ x < N\\
dfs(x-1,y) ,& \text{if}\ x > 1\\
dfs(x,y+1) ,& \text{if}\ y < M\\
dfs(x,y-1) ,& \text{if}\ y > 1\\
\end{cases}$$
其中，$dfs(x,y)$ 表示当前走到 $(x,y)$ 格的情况。

为了更新答案，我们需要记录围住的豆子情况，以及这条回路的长度。回路的长度可以在搜索的过程中记录，但是由于无法记录整条路径，所以只能在搜索时使用状态压缩方法记录围住豆子的情况 $sta$，状态变成了 $dfs(x,y,l,sta)$。

在更新答案时，我们可以通过提前预处理出每一个 $sta$ 对应的得分来在 $O(1)$ 的时间内计算，但是如何在搜索时记录 $sta$ 呢？其本质在于如何判断一颗豆是否在围成的多边形内。对于这个问题，在平面计算几何中有不同的解决办法。这里采用射线法。具体做法为：从这个点出发引一条任意方向的射线。如果这条射线与多边形边的交点个数为奇数，说明该点在多边形内部。反之则在外部。

这个方法可以方便地判断出一颗豆是否在围出的多边形内部。但具体实现起来还有一些细节要注意。

为了方便计算，我们取射线方向为正右方。每一次搜索到一颗豆的右方时，我们就改变这颗豆被包围的情况。于是，我们要判断什么时候应该改变一颗豆的包围情况。

首先，当一次搜索到一颗豆右方的格子时，就会使这颗豆子的情况改变。我们可以在搜索到 $(x,y)$ 时将这个格子左边的所有豆的包围情况改变。但是考虑几种情况：搜索时如果在 $(x,y)$ 折返，那 $(x,y)$ 会被经过一次，但豆的包围情况不会被改变；搜索时如果有一条边平行于射线，那这颗豆的包围情况就不能很好地计算。如图所示（圆形表示一颗豆子，灰色方格表示经过射线的格子）：
![](https://cdn.luogu.com.cn/upload/image_hosting/d5mv3tu5.png)

因此，我们不能简单地判断 $(x,y)$ 是否在豆的右边来决定豆的包围情况。事实上，只有在特定的方向上计算经过次数才有效。对于水平方向的移动，不计算包围情况。而对于竖直方向的移动，在从上方走到本格或从本格走到上方一格时计算包围情况。这样，就可以避免各种特殊情况，正确地计算出每一条回路包围了哪几颗豆子。

有了搜索的方法，我们可以考虑将其转化为动态规划。动态规划的状态记为 $f(x,y,sta)$，表示走到 $(x,y)$，围住豆子的情况为 $sta$ 时走过的最小距离。有转移方程：
$$f(x,y,sta')=\min\{f(x\pm1,y,sta),f(x,y\pm1,sta)\}+1$$
其中，$sta'$ 表示计算出的新包围情况。由于计算 $sta'$ 时需要判断每一颗豆子的情况，这个转移方程的时间复杂度为 $O(D)$。

对于枚举的每一个起点 $(sx,sy)$，有初始化数组为正无穷大，初值为 $f(sx,sy,0)=0$。最终答案为 $\min\limits_{sta}\{score[sta] - f(sx,sy,sta)\}$，$score[sta]$ 表示预处理出的包围情况为 $sta$ 时的分数。

动态规划的状态和方程有了，但是我们发现这个方程更新顺序不确定，不能直接递推。我们可以把递推方程改写为 $f(x,y,sta') = \min(f(x,y,sta'),f(lx,ly,sta)+1)$。$lx,ly$ 表示上一格的坐标。这个方程的形式与图论中的最短路松弛操作是一样的。由于代表边权的一项总是 $1$，也就是没有负权边，我们可以根据堆优化 Dijkstra 算法的方式来进行递推。

本题的算法流程：
- 输入，遍历网格，记录每一颗豆子的坐标；
- 预处理出 $score$ 数组；
- 枚举起点 $(sx,sy)$：
	- Dijkstra 递推方程；
    - 更新答案。

总时间复杂度为 $O(D\cdot2^D+(Dnm)^2\log(Dnm))$。

代码如下：
```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
#include <queue>
using namespace std;

const int maxN = 15;
int N, M, D, V[maxN];
int dx[maxN], dy[maxN], score[1 << 10];		//dx，dy 记录每一颗豆的坐标
char c[maxN][maxN];
int f[maxN][maxN][1 << 10];
bool vis[maxN][maxN][1 << 10];
int ans = 0;

struct status{	//记录状态，方便 Dijkstra 算法的堆优化
    int x, y, sta;
    bool operator< (const status &b) const {
        return f[x][y][sta] > f[b.x][b.y][b.sta];
    }
};
priority_queue <status> Q;
inline void dp(int lx, int ly, int x, int y, int laststa) {		//相当于图论中的 relax 操作
    int sta = laststa;
    if (x != lx) {
        for (int i = 1; i <= D; i++) {
            if (((x == dx[i] && lx < dx[i]) || (x < dx[i] && lx == dx[i])) && y > dy[i]) sta ^= (1 << (i - 1));
        }
    }
    if (f[x][y][sta] > f[lx][ly][laststa] + 1) {
        f[x][y][sta] = f[lx][ly][laststa] + 1;
        Q.push({x, y, sta});
    }
}
inline void Dijkstra(int sx, int sy) {		//计算 f 数组
    memset(f, 0x7f, sizeof(f));
    memset(vis, 0, sizeof(vis));
    f[sx][sy][0] = 0;
    Q.push({sx, sy, 0});
    while (!Q.empty()) {
        status cur = Q.top();
        Q.pop();
        int x = cur.x, y = cur.y, sta = cur.sta;
        vis[x][y][sta] = true;
        if (x < N && c[x + 1][y] == '0' && !vis[x + 1][y][sta]) dp(x, y, x + 1, y, sta);
        if (x > 1 && c[x - 1][y] == '0' && !vis[x - 1][y][sta]) dp(x, y, x - 1, y, sta);
        if (y < M && c[x][y + 1] == '0' && !vis[x][y + 1][sta]) dp(x, y, x, y + 1, sta);
        if (y > 1 && c[x][y - 1] == '0' && !vis[x][y - 1][sta]) dp(x, y, x, y - 1, sta);
    }
}


int main() {
    cin >> N >> M;
    cin >> D;
    for (int i = 1; i <= D; i++) {
        cin >> V[i];
    }
    for (int i = 1; i <= N; i++) {
        for (int j = 1; j <= M; j++) {
            cin >> c[i][j];
            if (c[i][j] - '0' <= 9 && c[i][j] - '0' >= 1) {
                dx[c[i][j] - '0'] = i;
                dy[c[i][j] - '0'] = j;
            }
        }
    }
    for (int sta = 0; sta < (1 << D); sta++) {
        for (int i = 1; i <= D; i++) {
            if ((sta & (1 << (i - 1))) != 0) score[sta] += V[i];	//预处理 score 数组
        }
    }
    for (int sx = 1; sx <= N; sx++) {
        for (int sy = 1; sy <= M; sy++) {
            if (c[sx][sy] != '0') continue;		//当 (sx,sy) 不能作为起点时剪枝
            Dijkstra(sx, sy);
            for (int sta = 0; sta < (1 << D); sta++) {
                ans = max(ans, score[sta] - f[sx][sy][sta]);
            }
        }
    }
    cout << ans << endl;
    return 0;
}
```


---

## 作者：Mambason (赞：5)

这题的难点就在于如何判断一个豆子是否在多边形内。

实际上有一个很好判断的方法，那就是可以引一条水平线，看和多边形有几个交点，有奇数个交点就在多边形内，否则在多边形外。

但是还有一个情况。就是如果路径从上往下，突然往水平拐，再往下拐，那么这是有偶数个交点的，但是豆子还是在多边形内。

不过我们可以把所有边当成上开下闭的边，只有当水平线与一条边的下端点相交才算进去。

然后我们可以直接写一个状压+$spfa$。


```cpp
#include <bits/stdc++.h>
#define il inline
#define RG register
#define ll long long
#define inf (1<<29)

using namespace std;

struct data{ int x,y,bin; }p[15];

const int d1[4]={0,0,-1,1};
const int d2[4]={-1,1,0,0};

int f[15][15][1<<12],vis[15][15][1<<12],g[15][15],val[15],S,n,m,all,ans;

queue<data> Q;

il int gi(){
  RG int x=0,q=1; RG char ch=getchar();
  while ((ch<'0' || ch>'9') && ch!='-') ch=getchar();
  if (ch=='-') q=-1,ch=getchar();
  while (ch>='0' && ch<='9') x=x*10+ch-48,ch=getchar();
  return q*x;
}

il char gc(){
  RG char ch=getchar();
  while ((ch<'0' || ch>'9') && ch!='#') ch=getchar();
  return ch;
}

il void spfa(RG int sx,RG int sy){
  for (RG int i=1;i<=n;++i)
    for (RG int j=1;j<=m;++j)
      for (RG int k=0;k<all;++k) f[i][j][k]=-inf;
  Q.push((data){sx,sy,0}),f[sx][sy][0]=0,vis[sx][sy][0]=1;
  while (!Q.empty()){
    RG data now=Q.front(); Q.pop();
    if (now.x==sx && now.y==sy)
      ans=max(ans,f[now.x][now.y][now.bin]);
    for (RG int k=0,x,y,yy,bin,del;k<4;++k){
      x=now.x+d1[k],y=now.y+d2[k];
      if (x<=0 || x>n || y<=0 || y>m || g[x][y]) continue;
      bin=now.bin,yy=max(y,now.y),del=0;
      if (k<=1){
    for (RG int i=1;i<=S;++i)
      if (p[i].y==yy && p[i].x<x){
        bin^=1<<(i-1);
        if (bin>>(i-1)&1) del+=val[i]; else del-=val[i];
      }
      }
      if (f[x][y][bin]<f[now.x][now.y][now.bin]+del-1){
    f[x][y][bin]=f[now.x][now.y][now.bin]+del-1;
    if (!vis[x][y][bin]) vis[x][y][bin]=1,Q.push((data){x,y,bin});
      }
    }
    vis[now.x][now.y][now.bin]=0;
  }
  return;
}

int main(){
#ifndef ONLINE_JUDGE
  freopen("bean.in","r",stdin);
  freopen("bean.out","w",stdout);
#endif
  n=gi(),m=gi(),S=gi(),all=1<<S;
  for (RG int i=1;i<=S;++i) val[i]=gi();
  for (RG int i=1;i<=n;++i)
    for (RG int j=1;j<=m;++j){
      RG char ch=gc();
      if (ch=='#') g[i][j]=-1; else g[i][j]=ch-'0';
      if (g[i][j]>=1 && g[i][j]<=9) p[g[i][j]]=(data){i,j};
    }
  for (RG int i=1;i<=n;++i)
    for (RG int j=1;j<=m;++j) if (!g[i][j]) spfa(i,j);
  cout<<ans; return 0;
}
```

---

## 作者：CrTsIr400 (赞：3)

## [P2566 [SCOI2009]围豆豆](https://www.luogu.com.cn/problem/P2566)

>你的 DP，又何必是 DP？

本题是一个细节较多的 DP。

DP 的状态设置和大家的差不多，设 $f_{S,x,y}$ 表示包含状态为 $S$ 的所有节点，现在走到了 $(x,y)$ 格点。

至于 $S$ 的处理我是记录了每个豆子**向上的射线**穿过**走过的路径**次数的奇偶性，具体的处理其它题解已经说明，不再赘述。

但是在这篇题解里面介绍一种神奇的 DP 框架，很方便输出路径、维护最优解个数，以及维护 $k$ 优解等等。

---

它就是我们熟悉的老伙伴：DAG 上面的 DP。

DAG 有许多优秀的性质，比如求出拓扑序，在拓扑序上面即可线性地做 DP。

同时，因为压缩成为了图，所以只需要维护一个一维的 DP 数组，在其所有转移点的答案根据转移边取最大值即可。

我们在利用拓扑排序做 DP 的时候往往需要根据状态转移方程建点、建边。

算法特性：

+ 时间空间都是 $O(n+m)$ 的，即状态加转移数。
+ 需要状态对图中节点编号一一映射（有些时候还需双射）。
+ 可以先拓扑排序，然后就顺序/倒序做，问题就变成了线性。

算法的好处：

+ 无需确定枚举顺序。
+ 只需要编码每个状态及其转移状态，对于初始值和最终答案适当设置起点终点即可。
+ 换而言之，我们不需要考虑转移漏的问题了。
+ 主要去计算的过程全程交给拓扑序上面的 DP。按照以往经验，这种 DP 非常简单。
+ 对于输出最优解的方案数，只需要在原图上保留每个点的最优决策边，从起点到终点数路径数量即可。对于输出（最优字典序）路径，是同理的。
+ 对于输出前 $k$ 优解，可以对于每个节点维护一个至多大小为 $k$ 的堆，这样编码十分简易。

不足之处：

+ 需要维护每个状态对节点编号的双射，这就导致了编码的一些不便。
+ 空间吃紧就不能用了。
+ 增加了一定码量，如果碰到比较简洁的 DP 甚至不如直接用数组维护得方便易懂。
+ 对于一些特殊图形（比如 1d/1d 动态规划的时候）不如使用其他特殊结构。
+ 对于图分层的情况，无法使用滚动数组优化 DP。

这样的算法框架还是要结合具体题目具体分析，适当时候采用，可以优化自己的代码，以及减少码量。

---

这道题目天生就支持使用 `bfs` 框架拓展，所以我们把每个状态视为**一个节点**，把状态转移视为**有向边**。

在本题之中我们把每个状态 $(S,x,y)$ **再次压缩**成为一个数字，变为节点编号。

首先枚举状态和状态转移方程，这里的状态可以随便枚举，反正是建边。

```cpp
for(I i=n-1;~i;--i)
	for(I j=m-1,T;~j;--j)
		if(a[i][j]=='0')
			for(I di=3;~di;--di){
				I x=i+dx[di],y=j+dy[di];
				if(0<=x&&x<n&&0<=y&&y<m&&a[x][y]=='0'){
					T=0;
					for(I k=n,ay;k;--k){
						ay=ps[k].second;
						if(((j==ay&&y==ay+1)||(y==ay&&j==ay+1))&&x<ps[k].first)
							T^=(1<<k-1);}
					for(I S=(1<<d)-1;~S;--S)
						conn(id(S,i,j),id(S^T,x,y));}}
```

然后枚举起点终点进行 DP。

碰到这里大家可能会写一个很长的 BFS，但是这里的 bfs 只有寥寥几行：

```cpp
I calc(I x,I y){
	I ans=-inf,st;
	for(I i=n*m*(1<<d);~i;--i)dis[i]=inf;
	dis[st=id(0,x,y)]=0;
	for(q[ql=qr=1]=st;ql<=qr;++ql){
		I x=q[ql];
		for(auto y:e[x]){
			if(dis[y]!=inf)continue;
			dis[y]=dis[x]+1;
			fr[y]=x;
			q[++qr]=y;}}
	for(I S=(1<<d)-1;~S;--S){
		ans=max(ans,anrs[S]-dis[id(S,x,y)]);}
	return ans;}
```

简不简单！因为把整个 DP 的所有状态浓缩到了这些节点里面，把所有状态转移方程浓缩到了边里面。

按照边无脑转移即可。

所以就写出了本题不是很长的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;typedef int I;typedef long long LL;const I inf=0x3f3f3f3f;
#define mp make_pair
const I N=11,dx[4]={0,0,-1,1},dy[4]={-1,1,0,0};
I n,m,d;
char a[N][N];
I v[N],anrs[513];
pair<I,I>ps[N];
I id(I S,I x,I y){
	return S*n*m+x*m+y;}
const I SN=51210;
vector<I>e[SN];
void conn(I x,I y){e[x].push_back(y);}
I dis[SN],q[SN],ql,qr,fr[SN];
I calc(I x,I y){
	I ans=-inf,st;
	for(I i=n*m*(1<<d);~i;--i)dis[i]=inf;
	dis[st=id(0,x,y)]=0;
	for(q[ql=qr=1]=st;ql<=qr;++ql){
		I x=q[ql];
		for(auto y:e[x]){
			if(dis[y]!=inf)continue;
			dis[y]=dis[x]+1;
			fr[y]=x;
			q[++qr]=y;}}
	for(I S=(1<<d)-1;~S;--S){
		ans=max(ans,anrs[S]-dis[id(S,x,y)]);}
	return ans;}
I main(){
	scanf("%d%d%d",&n,&m,&d);
	for(I i=1;i<=d;++i)scanf("%d",v+i);
	for(I S=(1<<d)-1;~S;--S){
		for(I i=1;i<=d;++i)if(S&(1<<i-1))anrs[S]+=v[i];}
	for(I i=0;i<n;++i){
		scanf("%s",a[i]);
		for(I j=0;j<m;++j){
			if('1'<=a[i][j]	&& a[i][j]<='9')
				ps[a[i][j]-'0']=mp(i,j);}}
	for(I i=n-1;~i;--i)
		for(I j=m-1,T;~j;--j)
			if(a[i][j]=='0')
				for(I di=3;~di;--di){
					I x=i+dx[di],y=j+dy[di];
					if(0<=x&&x<n&&0<=y&&y<m&&a[x][y]=='0'){
						T=0;
						for(I k=n,ay;k;--k){
							ay=ps[k].second;
							if(((j==ay&&y==ay+1)||(y==ay&&j==ay+1))&&x<ps[k].first)
								T^=(1<<k-1);}
						for(I S=(1<<d)-1;~S;--S)
							conn(id(S,i,j),id(S^T,x,y));}}
	I ans=-inf;
	for(I i=n-1;~i;--i)
		for(I j=m-1;~j;--j)
			if(a[i][j]=='0')
				ans=max(calc(i,j),ans);
	printf("%d\n",ans);
	return 0;
}
```

以后可能还有这种状态很复杂的 DP，编码和调试都是一件难事，但是这种方法还是能够稍稍简化调试的复杂度的。

只需要调试状态转移方程即可。

---

## 作者：zhangjiacheng (赞：2)

## 解题思路：状压dp
只要回路经过某豆豆的次数是奇数次，就意味着围住了豆豆。。路线经过豆豆的正右方的判断要小心。
#### 具体见代码：
```c++
#include<cstdio>
#include<iostream>
#include<cstring>
#include<queue>
using namespace std;
int q[11][11][1050],f[11][11],x[11],y[11],v[11],ans=0;
int n,m,d,dx[4]={1,-1,0,0},dy[4]={0,0,1,-1};

struct haha{
	int a,b,c;
}tem;

int gc(int a,int b)
{
	char t=' ';
	while (1) 
	{
		scanf("%c",&t);	
		if (t=='#') return -1;
		if (t>='0'&&t<='9')
		{
			x[t-'0']=a;y[t-'0']=b;
			return t-'0';	
		} 
	}
}

queue<haha>p;
int in[11][11][1050];
void doit(int stx,int sty)
{
//printf("\n%d %d:\n",stx,sty);
	memset(q ,0,sizeof(q ));
    memset(in,0,sizeof(in));
    q[stx][sty][0]=0;
    p.push({stx,sty,0});
    int tx,ty,tz,tq,cross;
    while (!p.empty())
    {
    	tem=p.front();p.pop();
    	for (int dir=0;dir<4;dir++)
    	{// tem.a tem.b tem.c -> tx,ty,tz
    		tx=tem.a+dx[dir];ty=tem.b+dy[dir];
    		if (tx<=0||ty<=0||tx>n||ty>m||f[tx][ty]!=0) continue;
    		tz=tem.c;tq=q[tem.a][tem.b][tem.c]-1;
    		if (dir<2)
    		{
    			cross=min(tx,tem.a);
    			for (int i=1;i<=d;i++)
    			{
    				if (x[i]!=cross||y[i]>ty) continue;
    				if (tz&(1<<(i-1)))
    					tq-=v[i];
    				else
    					tq+=v[i];
    				tz=tz^(1<<(i-1));
    			}
    		}
    		if (!in[tx][ty][tz])
    		{
    			q[tx][ty][tz]=tq;
    			p.push({tx,ty,tz});
    			in[tx][ty][tz]=1;
//printf(" %d %d %d (%d) -> %d %d %d (%d)\n",tem.a,tem.b,tem.c,q[tem.a][tem.b][tem.c],tx,ty,tz,tq);
    		}
    	}
    }
    for (int i=0;i<(1<<d);i++)
    	if (in[stx][sty][i])
    		ans=max(ans,q[stx][sty][i]);
}

int main()
{
	scanf("%d%d",&n,&m);
	scanf("%d",&d);
	for (int i=1;i<=d;i++)
	scanf("%d",&v[i]);
	
	for (int i=1;i<=n;i++)
	{
		for (int j=1;j<=m;j++)
		{
			f[i][j]=gc(i,j);
		}
	}
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++)
			if (f[i][j]==0)
				doit(i,j);
	printf("%d",ans);
}
```

---

## 作者：spdarkle (赞：1)

# P2566 [SCOI2009]围豆豆 题解

嗯，看到数据范围，不难发现这是一道状压。

根据动态规划的步骤，我们首先需要设计出状态，直觉告诉我们应该有一个维度存放状态 $S$，$S$ 的二进制下每一位代表了是否圈上了那个豆子。

而继续观察，需要刻画出这个状态，仅仅有这样一个并不能够唯一确定，故需要唯一确定这个状态，就很好办了，加两个维度表示坐标，当然，这样刻画状态虽然一个状态还是会表示很多种可能，但此时这些可能性都可以被化成一个最优解进而不影响答案，这里我们也可以看出状态压缩动态规划的状态设计就在于设计出来的状态一定是多个可能性的集合，取最优解，但不会影响答案的。

那么我们就可以设 $f[x,y,S]$ 表示终点在 $(x,y)$ 状态为 $S$ 的最大得分，这里为了方便计算，在代码中我改了一下，改成了 $f[x,y,S]$ 表示终点在 $(x,y)$ 状态为 $S$ 的最小步数，因为知道了 $S$ 就可以直接算出总的豆豆提供的贡献，那这道题就变成了一个图上的状压？！

那么模型已经出来了，就是借助最短路算法进行状压 DP ，我们就需要思考如何转移了，比如一个状态 $S$ 在什么样的情况下可以转到状态 $S'$。

很明显，状态发生变化肯定是和路线有关系的，现在需要思考在怎样的一种情况下，一个豆豆会被围住。

因为我们的路径最终是一条回路，所以其实上我们只需要考虑包围这个豆豆的多边形的一半即可，可以是豆豆左边的一半，也可以是右边的一半，甚至是上下的一半都行，然后就是[射线定理](https://www.pianshen.com/article/4349562259/)了，**判定一个点是否位于一个多边形中，只需要判定这个点引出一条射线与整个多边形的交点数量的奇偶性即可**。这个玩意儿就可以想到如何转移了，在代码中为了方便我选择了向右引出一条射线。

我们可以枚举每一个豆豆，看这一个新的步伐会不会对这个豆豆的包围产生影响，当然，我们向右引出的射线，交点数量只会在这个步伐是上下移动的时候才会改变，具体呈现出这个样子：

![](https://cdn.luogu.com.cn/upload/image_hosting/4e35tugw.png)


而对于奇偶性，用异或运算进行更改即可，于是更改状态的代码可以写成这个鸭子

```cpp
int find(int x1,int y1,int x2,int y2,int lst){//(x1,y1)->(x2,y2)
	int now=lst;
	if(x1==x2)return now;
	for(int i=1;i<=cnt;i++){
		if((x1==ax[i]&&x2>ax[i]||x2==ax[i]&&x1>ax[i])&&ay[i]<y2)now=now^(1<<(i-1));
	}
	return now;
}

```

那么有了状态这些，转移就很简单了，下面贴上代码


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
int n,m,ans=0xcfcfcfcf,cnt,dx[4]={0,0,1,-1},dy[4]={1,-1,0,0},ax[11],ay[11],val[11],a[11][11],f[11][11][1<<10],vis[11][11][1<<10],point[1<<10];
int find(int x1,int y1,int x2,int y2,int lst){
	int now=lst;
	if(x1==x2)return now;
	for(int i=1;i<=cnt;i++){
		if((x1==ax[i]&&x2>ax[i]||x2==ax[i]&&x1>ax[i])&&ay[i]<y2)now=now^(1<<(i-1));
	}
	return now;
}
struct node{
	int x,y,now,step;
};
queue<node>q;
void update(node a,node b){
	if(f[a.x][a.y][a.now]+1<f[b.x][b.y][b.now]){
		f[b.x][b.y][b.now]=f[a.x][a.y][a.now]+1;
		q.push(b);
	}
}
int SPFA(node x){
	q.push(x);
	memset(vis,0,sizeof vis);
	memset(f,0x3f,sizeof f);
	f[x.x][x.y][0]=0;
	while(q.size()){
		node u=q.front();q.pop();
		vis[u.x][u.y][u.now]=1;
		for(int i=0;i<4;i++){
			node v={u.x+dx[i],u.y+dy[i],find(u.x,u.y,u.x+dx[i],u.y+dy[i],u.now),u.step+1};
			if(v.x<1||v.x>n||v.y<1||v.y>m||vis[v.x][v.y][v.now]||a[v.x][v.y])continue;
			update(u,v);
		}
	}
}
int main(){
	scanf("%d%d%d",&n,&m,&cnt);
	for(int i=1;i<=cnt;i++)scanf("%d",&val[i]);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			char x;
			cin>>x;
			if(x=='#')a[i][j]=1;
			if('1'<=x&&x<='9')a[i][j]=1,ax[x-'0']=i,ay[x-'0']=j;
		}
	}
	for(int i=1;i<1<<cnt;i++){
		for(int j=1;j<=cnt;j++){
			if((i>>(j-1))&1)point[i]+=val[j];
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(a[i][j])continue;
			SPFA({i,j,0,0});
			for(int i1=0;i1<(1<<cnt);i1++){
				ans=max(ans,point[i1]-f[i][j][i1]);
			}
		}
	}
	printf("%d\n",ans);
}
```cpp

---

## 作者：xukuan (赞：1)

不明白为什么有dp的标签,这题个人更倾向于状压spfa

判断点是否在多边形内：从这个点向外引一条射线，若与多边形相交了奇数次，就在它的内部，否则在外部。

为了防止各种诡异情况（比如多边形类似“凹”字，然后过他的顶点；射线与边重合不算相交），这题的射线采用向正右方的射线

先来设计最短路的状态

用$f_{x,y,S}$表示当前在点$(x,y)$,状态为S要走的最短步数

$1 \leq D \leq 9$，显然状压，S的第i位表示数字i是否在多边形内

然后设计状态转移

如果当前状态为S，下一个点的状态为T，怎么从S推出T
1. 横着走：T=S
2. 竖着走：如果有一个数字在当前点的正左侧或者下一个点的正左侧（你不能确定下一步会不会转弯，因为这样就变成了重合，所以要算上当前点），那么改变它的状态（原来不在图形内的变成在内，在内的变成在外）

搜索题的特点是思路简单代码长，这题就说到这里，直接上代码

```cpp
#include<bits/stdc++.h>
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;

const ll N=15,D=10;
const ll dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};
ll n,m,k,ans,a[N],g[1<<D],f[N][N][1<<D],v[N][N][1<<D];
char s[N][N];
struct{
    ll x,y;
}place[N];
struct node{
    ll x,y,S;
};
queue<node> q;

inline bool check(ll x,ll y){
    return x>=1&&x<=n&&y>=1&&y<=m&&s[x][y]=='0';
}

inline ll getT(ll x,ll y,ll X,ll Y,ll S){
    ll T=S;
    for(ll i=1; i<=k; i++){
        if(((x==place[i].x&&X<place[i].x)||(x<place[i].x&&X==place[i].x))&&Y>place[i].y) T^=1<<(i-1);
    }
    return T;
}

inline void spfa(node S){
    while(!q.empty()) q.pop();
    memset(v,0,sizeof(v));
    memset(f,0x3f,sizeof(f));
    q.push(S); v[S.x][S.y][S.S]=1;
    f[S.x][S.y][S.S]=0;
    while(!q.empty()){
        ll x=q.front().x,y=q.front().y,S=q.front().S; q.pop();
        v[x][y][S]=0;
        for(ll i=0; i<4; i++){
            ll X=x+dx[i],Y=y+dy[i];
            if(check(X,Y)){
                ll T=S;
                if(i==0||i==2) T=getT(x,y,X,Y,S);
                if(f[x][y][S]+1<f[X][Y][T]){
                    f[X][Y][T]=f[x][y][S]+1;
                    if(!v[X][Y][T]){
                        q.push(node{X,Y,T});
                        v[X][Y][T]=1;
                    }
                }
            }
        }
    }
    for(ll i=0; i<(1<<k); i++) ans=max(ans,g[i]-f[S.x][S.y][i]);
}

int main(){
    cin>>n>>m>>k;
    for(ll i=1; i<=k; i++) scanf("%lld",&a[i]);
    for(ll i=1; i<=n; i++){
        scanf("%s",s[i]+1);
        for(ll j=1; j<=m; j++){
            if(s[i][j]>='1'&&s[i][j]<='9'){
                ll now=s[i][j]-48;
                place[now].x=i;
                place[now].y=j;
            }
        }
    }
    for(ll i=0; i<(1<<k); i++){
        for(ll j=1; j<=k; j++){
            if(i&(1<<(j-1))) g[i]+=a[j];
        }
    }
    for(ll i=1; i<=n; i++){
        for(ll j=1; j<=m; j++){
            if(s[i][j]=='0') spfa(node{i,j,0});
        }
    }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：Su_Zipei (赞：1)

## 分析
这道题看着前边的叙述好像不是很难，不就是把豆子围起来吗，一看数据，$状压DP$肯定是了，状压$DP$的本质其实还是暴力，既然我们已经选择了一个暴力，不如暴力到底，于是我开始枚举围成的路径，打了一堆写好后发现好像不对，（我最开始以为路径一定是矩形），然后.....**路径所形成的多边形（可能是含自交的复杂多边形）**，所以枚举是不现实的了，这里就有一个很神奇的办法，射线法判断点是不是在多边形内，一句话总结就是引一条切线，如果与多边形有偶数个交点，则在外部，奇数个则在内部，但你会发现当点在多边形的边上时这个是不成立的，所以我们还需要做点事情，我们只需要将这条边上开下闭即可，这样就不会出问题了。转移的时候怎么转移呢？

因为涉及到每个豆子，并且豆子和豆子都不一样，所以坐标就直接会占二维。状压$DP$的话还要额外再加一层状态，就是每个豆子放与不放，对应的二进制位为1则放否则不放。这样就确定好了状态，下面我们需要跑一条回路出来，我感觉没有比$SPFA$更合适的了，从每一个可以被围起来的点开始跑，一直跑到队列为空，那可能会死循环吗？**显然不会**，因为跑着跑着步数就变多了，然后就不会转移，然后就不会入队列了，所以不会死循环。

大概思路是有了，下面考虑一些细节的东西。

怎么判断是交了奇数次还是偶数次呢？有一个东西叫异或，很好用，之前写NOI ONLINE的一道题时也用过，对于当前状态，假如该路径经过了豆子引出的射线，就把该二进制位异或1，如果它原来是1，就是曾经经过，那么再次经过就应该是偶数次了，异或1后是0，考虑围住的豆子时就应该把这个减去，emm好像还不是很清楚，就是我当前的$DP$数组加上了这个豆子，但是我当前的状态并没有，所以转移的时候一定要把这颗豆子减去，反之则加上，我感觉这么做好像写起来会简单一些。


---

## 作者：artofproblemsolving (赞：0)

分析：

先介绍一下射线法的知识，该知识为计算组合内容，**用于判断一个点是否在一个多边形内。**

它的主要思想是从这个点向右做一条射线，数数这条射线与四边形的交点有几个。如果有奇数个交点，那么这个点在图形内部；若有偶数个交点，那么它在多边形外部（大多数情况下是这样的，因为还有考虑这条射线经过了多边形的一个内角大于 180° 的情况。但在此题中显然不用考虑）。利用这个思想，我们可以根据路径经过某个豆豆右侧射线次数的奇偶数来判断是否围在路径里。

下面来分析本题。

可以暴力枚举起点。状态的设计受以上启发，不仅需要记录当前的位置，还要记录经过每一个豆豆右射线的奇偶性情况。观察到经过每一个豆子右射线的奇偶性情况是一个 $D$ 位 01 串，不妨将其视为 $D$ 位的二进制数以方便记录。即状态 ```f[i][j][k]```  表示当前坐标 $(i,j)$，并且经过第 $t$ 个豆豆右射线的奇偶性为 ```k>>t&1``` （1 为奇数，0 为偶数）。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int in[11][11][1050],dp[11][11][1050],f[11][11],x[11],y[11],v[11],ans=0,n,m,d,dx[]={1,-1,0,0},dy[]={0,0,1,-1};
struct Node{
  int x,y,z;
}tem;
int gc(int a,int b){
  for(char t=getchar();;t=getchar()){
    if(t=='#') return -1;
    if(t>='0'&&t<='9'){
      x[t-'0']=a,y[t-'0']=b;
      return t-'0';
    }
  }
}
queue<Node>q;
void doit(int stx,int sty){
  memset(dp,0,sizeof(dp));
  memset(in,0,sizeof(in));
  dp[stx][sty][0]=0;
  q.push({stx,sty,0});
  int tx,ty,tz,tq,cross;
  while(!q.empty()){
    tem=q.front();
    q.pop();
    for(int dir=0;dir<4;dir++){
      tx=tem.x+dx[dir];ty=tem.y+dy[dir];tz=tem.z;
      if(tx<=0||ty<=0||tx>n||ty>m||f[tx][ty]!=0) continue;
      tq=dp[tem.x][tem.y][tem.z]-1;
      if(dir<2){
        cross=min(tx,tem.x);
        for(int i=1;i<=d;i++){
          if(x[i]!=cross||y[i]>ty) continue;
          if(tz>>i-1&1) tq-=v[i];
          else tq+=v[i];
          tz=tz^(1<<(i-1));
        }
      }
      if(!in[tx][ty][tz]++){
        dp[tx][ty][tz]=tq;
        q.push((Node){tx,ty,tz});
      }
    }
  }
  for(int i=0;i<1<<d;i++) if(in[stx][sty][i])ans=max(ans,dp[stx][sty][i]);
}
int main(){
  cin>>n>>m>>d;
  for(int i=1;i<=d;i++) cin>>v[i];
  for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
      f[i][j]=gc(i,j);
  for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++) if(!f[i][j]) doit(i,j);
  cout<<ans<<endl;
  return 0;
}
```


---


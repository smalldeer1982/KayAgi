# [HNOI2012] 集合选数

## 题目描述

《集合论与图论》这门课程有一道作业题，要求同学们求出 $\{ 1, 2, 3, 4, 5 \}$ 的所有满足以下条件的子集：若 $x$ 在该子集中，则 $2x$ 和 $3x$ 不能在该子集中。

同学们不喜欢这种具有枚举性质的题目，于是把它变成了以下问题：对于任意一个正整数 $n \le 10^5$，如何求出 $\{1,2,\ldots ,n\}$ 的满足上述约束条件的子集的个数（只需输出对 $10^9+1$ 取模的结果），现在这个问题就交给你了。

## 说明/提示

**【样例解释】**
 
有 $8$ 个集合满足要求，分别是空集，${1}$，$\{1,4\}$，$\{2\}$，$\{2,3\}$，$\{3\}$，$\{3,4\}$，$\{4\}$。

**【数据范围】**

对于 $30 \%$ 的数据，$n \le 20$。  
对于 $100 \%$ 的数据，$1 \le n \le 10^5$。

## 样例 #1

### 输入

```
4```

### 输出

```
8
 
```

# 题解

## 作者：Soulist (赞：57)

一道非常妙的构造题 $QwQ$

要 $2x$， $3x$ 都不在集合内，但直接处理貌似非常不好，所以我们需要构造出一个与原命题等价的命题。

貌似是这个，构造一个矩形，第一行第一列的元素为$1$，第一行的后面所有数均为前面的数的两倍。

接下来每列的数都是它上面的数的三倍。

大概构造出来长这样：

```cpp
1  2  4  8   16  32  ...
3  6  12 24  48  96  ...
9  18 36 72  ...
27 ...
```

那么对于这个矩形内，我们要做的就是求出这个矩形内，选出一些数，相邻的数不能选的方案数。

因为每个数都是前面那个数的 $2$ 倍，所以这个矩形最后长为 $log_2n$，宽为$log_3n$大概是 $17,12$ 不到的样子。

可以用状压$dp$解决

但是这个矩形并没有涵盖所有的数，所以我们需要对每个即不是 $2$ 的倍数又不是 $3$ 的倍数的数都类似的构造矩形，可以发现矩形内部元素不重复，然后根据乘法原理，将答案相乘即可。

复杂度大概是$O($能过$)$

```cpp
#include<bits/stdc++.h>
using namespace std;
int read() {
	char cc = getchar(); int cn = 0, flus = 1;
	while(cc < '0' || cc > '9') {  if( cc == '-' ) flus = -flus;  cc = getchar();  }
	while(cc >= '0' && cc <= '9')  cn = cn * 10 + cc - '0', cc = getchar();
	return cn * flus;
}
#define int long long
#define rep( i, s, t ) for( register int i = s; i <= t; ++ i ) 
const int mod = 1000000001;
const int maxn = ( 1 << 18 ) - 1;
const int N = 100000 + 5;
const int M = 20 ;
int n, book[N], Ans, line[M], g[maxn], a[M][M], end, dp[M][maxn], num, lim[M];
void init( int x ) {
	rep( i, 1, 11 ) {
		if( i == 1 ) a[i][1] = x;
		else a[i][1] = a[i - 1][1] * 3;
		//初始化矩形 
		if( a[i][1] > n ) break ;
		
		end = i, line[i] = 1, book[a[i][1]] = 1;
		//line表示第i行有多少列 
		rep( j, 2, 18 ) {
			a[i][j] = a[i][j - 1] * 2;
			if( a[i][j] > n ) break;
			line[i] = j, book[a[i][j]] = 1; // 用book标记这个元素被选过 
		}
		lim[i] = ( 1 << line[i] ) - 1; // lim表示第i行的数有多少个，起限制作用 
	}
}
void solve(int x) {
	num = 0 ;
	rep( i, 0, lim[1] ) dp[1][i] = g[i];
	rep( i, 2, end ) rep( j, 0, lim[i] ) {
		if( !g[j] ) continue ; //如果状态j不合法，就跳过 
		dp[i][j] = 0;
		rep( k, 0, lim[i - 1] )
			if( g[k] && ( (k & j) == 0 ) ) //如果状态k合法，且k与j没有位置相同 
			dp[i][j] += dp[i - 1][k], dp[i][j] %= mod;
	}
	rep( i, 0, lim[end] ) num += dp[end][i], num %= mod ;
}
signed main()
{
	n = read() ; Ans = 1;
	rep( i, 0, maxn ) g[i] = ( (i << 1) & (i) ) ? 0 : 1; //初始化哪些状态合法。 
	
	rep( i, 1, n ) if( !book[i] )  //如果这个数没有被选过。 
		init(i), solve(i), Ans = Ans * num % mod; //先构造矩形，然后状压dp 
	
	printf("%lld\n", Ans );
	return 0;
}
```

---

## 作者：ljk123 (赞：16)

# 集合选数题解

构造神题,

对于每一个不含质因数2和3的数字，

我们构造一个矩阵(可能并不满),

第一行第一列是这个数,

在同一行中，下一列的数是这一列的数的2倍，

在同一列中，下一行的数是这一行的数的3倍。

如果我们选矩阵中一个数,

则右边的数是这个数的两倍而不能选，

同理,下面的数同样不能选，

不能选左边的数，因为这个数是它的两倍，

不能选上面的数，因为这个数是它的三倍，

总结一下：

选了一个数就不能选相邻的数，

再一看，列数<=$log_{2}(n)<17$,行数<=$log_{3}(n)<11$

所以，状压啦：

每个不同的矩阵互不影响，根据乘法原理：每次得到的方案数之积即为答案。

代码：
```cpp
#include<bits/stdc++.h>
#define ll long long 
using namespace std;
const int N=4098,M=20,K=100006;
const ll mod=1e9+1;
int n,p,flag[N],book[K],num[M],f[M][N];
ll ans=1,sum;
inline int read(){
   int T=0,F=1; char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-') F=-1; ch=getchar();}
   while(ch>='0'&&ch<='9') T=(T<<3)+(T<<1)+(ch-48),ch=getchar();
   return F*T; 
}
void build(int x){
    p=1,sum=0; memset(f,0,sizeof(f)); memset(num,0,sizeof(num));
    for(int i=x;i<=n;i<<=1,++p) for(int j=i;j<=n;j*=3) ++num[p],book[j]=1;
    for(int i=0;i<(1<<num[1]);++i) f[1][i]=flag[i];
    for(int i=2;i<p;++i)
        for(int j=0;j<(1<<num[i-1]);++j)
            for(int k=0;k<(1<<num[i]);++k)
                if(flag[j]&&flag[k]&&!(j&k)) f[i][k]=(f[i][k]+f[i-1][j])%mod;
    for(int i=0;i<(1<<num[p-1]);++i) sum=(sum+f[p-1][i])%mod;
    ans=ans*sum%mod;
}
int main(){
    n=read();
    for(int i=0;i<=2048;++i) flag[i]=((i<<1)&i)?0:1;
    for(int i=1;i<=n;++i) if(!book[i]) build(i);
    printf("%lld\n",ans);
    return 0;
}
```


---

## 作者：huxulin (赞：13)

构造矩阵,这个矩阵左上角为第一个选的数,每一行都是一个公比为3的数列,每一列都是一个公比为2的数列.通过这个神奇的矩阵可以知道选一个数就不能选与之相邻的数.我们对每一行dp.用f[i][k]表示矩阵第i行状态为k的方案数,它就是上一行所有合法的状态总和.并且我们发现最多有18行,11列.最终答案就是对每一个数进行dp所得到的答案的乘积.(记得舍掉已在之前矩阵中出现过的数).自己做起来细节挺多的.

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>

typedef long long LL;

static const int maxm = 1e5 + 10;
static const int maxn = 20 + 10;
static const int MOD = 1000000001;

int f[maxn][maxm],lmt[maxm],mtx[maxn][maxn],vis[maxm],bin[maxm];
int n;
LL ans = 1;

int dp(int x){
    
    for(int i = 1;i <= 18;i++)lmt[i] = 0;
    
    mtx[1][1] = x;
    
    for(int i = 2 ;i <= 18;i++)
        if(mtx[i - 1][1] * 2 <= n)mtx[i][1] = mtx[i - 1][1] * 2;
        else mtx[i][1] = n + 1;
    
    for(int i = 1 ;i <= 18 ;i++)
        for(int j = 2;j <= 11 ;j++)
            if(mtx[i][j - 1] * 3 <= n)mtx[i][j] = mtx[i][j - 1] * 3;
            else mtx[i][j] = n + 1;
    
    for(int i = 1;i <= 18;i++)
        for(int j = 1;j <= 11;j++)
            if(mtx[i][j] <= n) lmt[i] += bin[j-1] , vis[mtx[i][j]] = 1;
    
    for(int i = 0;i <= 18;i++)
        for(int j = 0;j <= lmt[i];j++)
            f[i][j] = 0;
    f[0][0] = 1;
    
    for(int i = 0;i <= 18;i++)
        for(int j = 0;j <= lmt[i];j++)
            if(f[i][j])
                for(int k = 0;k <= lmt[i + 1];k++)
                    if(!(j & k) && (!(k & (k << 1))))
                        f[i + 1][k] = (f[i + 1][k] + f[i][j]) % MOD;
    return f[18][0];
}

int main(){
    scanf("%d",&n);
    
    bin[0] = 1;
    for(int i = 1;i <= n;i++)bin[i] = bin[i-1] << 1;
    
    for(int i = 1;i <= n;i++)
        if(!vis[i]) ans = (ans * dp(i)) % MOD;
    
    printf("%lld\n",ans);
    
    return 0;
}
```

---

## 作者：hahaha1215 (赞：12)

是一道很妙的构造+状压$dp$题吖.

看了很多题解都是开门见山地讲构建一个网格图,可是没讲怎么想到的吖,于是我决定来写一篇题解,可以当作其他题解的补充.

应该很多人看到题都会像我一样在草稿本上画下一个类似于下面的图,或者想:"选$1$,不选$2,3$;选$2$,不选$4,6$"等等.
对于每一个点,左儿子是它的两倍,右儿子是它的三倍.

![](https://cdn.luogu.com.cn/upload/image_hosting/0xd4ccuo.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

约束条件是:连了边的两个点是不可以同时选的,也就是只能隔一个选一个,但是这样显然不好做.于是考虑能不能再转化一下.仔细观察这个图会发现它特别像一棵树,但又不是,因为一个点有两个父亲,这是因为一个数可能是一个数的两倍同时又是另外一个数的三倍.再观察一下会发现这个图似乎是由许多小菱形组成的,于是把菱形拉成正方形会发现得到了一个倒三角.如下:

![](https://cdn.luogu.com.cn/upload/image_hosting/oi0l3hb3.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

显然我们可以把这个倒三角填满得到一个网格图.对于每一个点,它的下面是它的两倍,右边是它的三倍.这样一来,约束条件就变成了选了一个数,就不能选与它相邻的数(上,下,左,右).转化之后就成为了一般的状压$dp $解决的问题.但是,注意到这个表格并不能涵盖所有的数,我们需要对没有被涵盖的数再建一个如上的网格图,最后乘法原理统计下答案就好了.至于状压细节的讲述,可以参看其他题解.
### 温馨提醒

大数组别用$memset$,你很有可能会向我一样$T$掉.
### $Code$
```cpp
#include<bits/stdc++.h>
#define il inline
#define Ri register int
#define go(i,a,b) for(Ri i=a;i<=b;++i)
#define yes(i,a,b) for(Ri i=a;i>=b;--i)
#define e(i,u) for(Ri i=b[u];i;i=a[i].nt)
#define mem(a,b) memset(a,b,sizeof(a))
#define ll long long
#define db double
#define inf 2147483647
using namespace std;
il int read()
{
    Ri x=0,y=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')y=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+c-'0';c=getchar();}
    return x*y;
}
const int N=100010,mod=1e9+1;
int n,h[30],a[30][30],f[30][100000];ll as=1;//h[0]:一共有多少行 h[i]:第i行有多少数
vector<int>b[30];
bool vis[N];
il void build(Ri x)
{
    mem(h,0);
    while(x<=n)
    {
	Ri y=x;++h[0];
	while(y<=n)vis[y]=1,a[h[0]][++h[h[0]]]=y,y*=2;
	x*=3;
    }
}
il bool ck(Ri x,Ri ct)
{
    go(i,0,ct)if(x&(1<<i) && x&(1<<(i+1)))return 0;
    return 1;
}
il void init()
{
    go(i,1,h[0])b[i].clear();
    go(i,1,h[0])
    {
	go(j,0,(1<<h[i])-1)
	    if(ck(j,h[i]))b[i].push_back(j);
    }
}
il ll sol()
{
    init();
    go(i,1,h[0])go(j,0,(int)b[i].size()-1)f[i][j]=0;
    go(j,0,(int)b[1].size()-1)f[1][j]=1;
    go(i,2,h[0])
	go(j,0,(int)b[i].size()-1)
	go(k,0,(int)b[i-1].size()-1)
        {
	    if(!(b[i][j]&b[i-1][k]))
	    {
		f[i][j]=f[i][j]+f[i-1][k];
		if(f[i][j]>mod)f[i][j]-=mod;
	    }
	}
    ll ret=0;
    go(j,0,(int)b[h[0]].size()-1)
    {
	ret=ret+f[h[0]][j];
	if(ret>mod)ret-=mod;
    }
    return ret;
}
int main()
{
    n=read();
    go(i,1,n)
    {
	if(vis[i])continue;
	build(i);as=as*sol();if(as>mod)as%=mod;
    }
    printf("%lld\n",as);
    return 0;
}

```


---

## 作者：Nemlit (赞：7)

## [原文地址](https://www.cnblogs.com/bcoier/p/10788835.html)

题目要求若出现x，则不能出现2x，3x

所以我们考虑构造一个矩阵

$1\ 2\ 4 \ 8……$

$3\ 6\ 12\ 24……$

$9\ 18\ 36……$

$……$

不难发现，对于一个矩阵，若我选择了一个数x，则在矩阵内该数的相邻格子都不能选，题目就被转化成了[玉米田](https://www.luogu.org/problemnew/show/P1879)了，可以用状压DP解决

但是直接做是不对的，比如5就没有出现在这个序列中

所以我们可以构造多个矩阵，用乘法原理统计答案即可

```
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define re register
#define debug printf("Now is Line : %d\n",__LINE__)
#define file(a) freopen(#a".in","r",stdin);//freopen(#a".out","w",stdout)
#define int long long
#define inf 123456789
#define mod 1000000001
il int read() {
    re int x = 0, f = 1; re char c = getchar();
    while(c < '0' || c > '9') { if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - 48, c = getchar();
    return x * f;
}
#define rep(i, s, t) for(re int i = s; i <= t; ++ i)
#define drep(i, s, t) for(re int i = t; i >= s; -- i)
#define mem(k, p) memset(k, p, sizeof(k))
#define maxn 100005
int n, m, a[20][20], g[1 << 15], vis[maxn], H, L[20], dp[20][1 << 15], ans = 1;
il void martix(int x) {
    H = 0;
    rep(i, 1, 18) {
        a[i][1] = (i == 1) ? x : a[i - 1][1] * 2;
        if(a[i][1] > n) break;
        ++ H, L[i] = vis[a[i][1]] = 1;
        rep(j, 2, 11) {
            a[i][j] = a[i][j - 1] * 3;
            if(a[i][j] > n) break;
            L[i] = j, vis[a[i][j]] = 1;
        }
    }
}
il int solve() {
    rep(i, 0, (1 << L[1]) - 1) dp[1][i] = g[i];
    rep(i, 2, H) {
        rep(j, 0, (1 << L[i]) - 1) {
            if(!g[j]) continue;
            dp[i][j] = 0;
            rep(k, 0, (1 << L[i - 1]) - 1) {
                if(g[k] && (k & j) == 0) dp[i][j] += dp[i - 1][k];
            }
        }
    }
    int t = 0;
    rep(i, 0, (1 << L[H]) - 1) t = (t + dp[H][i]) % mod;
    return t;
}
signed main() {
    n = read();
    rep(i, 0, (1 << 11) - 1) g[i] = !(i & (i << 1));
    rep(i, 1, n) if(!vis[i]) martix(i), ans = ans * solve() % mod;
    printf("%lld", ans);
    return 0;
}
```

---

## 作者：xyz32768 (赞：7)

考虑构造出一个矩阵：

$$
\begin{matrix}

1 & 3 & 9 & 27 & ...\\

2 & 6 & 18 & 54 & ...\\

4 & 12 & 36 & 108 & ...\\

8 & 24 & 72 & 216 & ...\\

... & ... & ... & ... & ...

\end{matrix}

$$
即左上角的数为$1$，此外每个数都等于它左边的数乘$3$，上面的数乘$2$。

此问题就转化成了在矩阵中取出一些元素，不能取相邻元素的方案数。

由于矩阵的行数$≤17$，列数$≤11$，所以可以考虑状态压缩。

用$f[i][S]$表示到了第$i$行，此行的选取状态为$S$的方案数，就可以枚举上一行的状态进行转移了。

同时注意，**这个矩阵并没有涵盖$1$到$n$的所有数**。所以要以每一个**既不是$2$的倍数又不是$3$的倍数的数**作为矩阵的左上角进行DP，并将所有的结果相乘。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
const int N = 1e5 + 5, PYZ = 1e9 + 1, R = 20, C = (1 << 11) + 5;
int n, rw, cnt[N], f[R][C], tot, us[C], Nx[R]; bool vis[N];
int solve(int x) {
    int i, j, k; rw = 0; for (i = x; i <= n; i *= 2) {
        rw++; cnt[rw] = 0; for (j = i; j <= n; j *= 3)
            cnt[rw]++, vis[j] = 1;
    }
    for (j = 1; j <= Nx[cnt[1]]; j++) f[1][us[j]] = 1;
    for (i = 2; i <= rw; i++) for (j = 1; j <= Nx[cnt[i]]; j++) {
        int S = us[j]; f[i][S] = 0;
        for (k = 1; k <= Nx[cnt[i - 1]]; k++) {
            int T = us[k]; if (S & T) continue;
            f[i][S] = (f[i][S] + f[i - 1][T]) % PYZ;
        }
    }
    int res = 0; for (j = 1; j <= Nx[cnt[rw]]; j++)
        res = (res + f[rw][us[j]]) % PYZ; return res;
}
int main() {
    int i, j, res = 1; n = read();
    for (i = 0; i < (1 << 11); i++) {
        bool flag = 1; int pos = 0;
        for (j = 1; j < 11; j++) {
            if (((i >> j) & 1) & ((i >> j - 1) & 1))
                {flag = 0; break;}
            if ((i >> j) & 1) pos = j;
        }
        if (flag) {
            us[++tot] = i;
            if (i == (1 << pos)) Nx[pos] = tot - 1;
        }
    }
    Nx[11] = tot; for (i = 1; i <= n; i++)
        if (!vis[i]) res = (1ll * res * solve(i)) % PYZ;
    printf("%d\n", res);
    return 0;
}
```

---

## 作者：nekko (赞：2)

~~似乎在某中集训的时候有人讲过这个题……~~

首先通过手玩（模拟题意）一下，发现可以画出这样的几个图（举 $n=20$ 为例）：

```
1 3 9
2 6 18
4 12
8
16
```

```
5 15
10
20
```

```
7
14
```

```
11
```

```
13
```

```
17
```

```
19
```

然后会发现每个数字只会出现一次……

而且每行每列最多只有 $O(\log n)$ 个值……

这样就可以直接状态压缩动态规划了

设 $f_{i,S}$ 表示处理完了前 $i$ 行，当前行选择情况为 $S$ 的方案数

于是就可以转移了，注意判断当前行的大小是否不小于 $S$ 的最高可行位

``` cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e5 + 10, mod = 1e9 + 1;
int n, vis[N], num[N], cnt[1 << 21];
ll ans = 1, f[2][1 << 21];

void sol(int start) {
    int len = 0, height = 0;
    for(int i = start ; i <= n ; i *= 2) {
        ++ height;
        num[height] = 0;
        for(int j = i ; j <= n ; j *= 3) {
            vis[j] = 1;
            ++ num[height];
        }
        len = max(len, num[height]);
    }
    int p = 0;
    int mxs = 1 << len;
    for(int i = 0 ; i < mxs ; ++ i) f[p][i] = 0;
    f[p][0] = 1;
    for(int i = 1 ; i <= height ; ++ i) {
        p ^= 1;
        for(int i = 0 ; i < mxs ; ++ i) f[p][i] = 0;
        for(int s = 0 ; s < mxs ; ++ s) {
            if((s & (s << 1)) == 0 && cnt[s] <= num[i]) {
                for(int t = 0 ; t < mxs ; ++ t) {
                    if((t & (t << 1)) == 0 && cnt[t] <= num[i - 1]) {
                        if((s & t) == 0) {
                            (f[p][s] += f[p ^ 1][t]) %= mod;
                        }
                    }
                }
            }
        }
    }
    
    ll res = 0;
    for(int s = 0 ; s < mxs ; ++ s)
        (res += f[p][s]) %= mod;
        
    (ans *= res) %= mod;
}

int main() {
    for(int s = 0 ; s < (1 << 21) ; ++ s) {
        for(int i = 20 ; i ; -- i) {
            if((s >> (i - 1)) & 1) {
                cnt[s] = i;
                break;
            }
        }
    }
    scanf("%d", &n);
    for(int i = 1 ; i <= n ; ++ i) {
        if(!vis[i]) {
            sol(i);
        }
    }
    printf("%lld\n", (ans % mod + mod) % mod);
}
```

---

## 作者：Jμdge (赞：2)

## 构造矩阵什么的,同楼下大佬,这里简单解释一下就过

(构造矩阵后我们就把原问题转化为了求:在矩阵中选数,且两两不相邻的方案数)
```
矩阵中的行对应 x*2,列对应x*3
```
```cpp
//by Judge 
#include<cstdio>
#define ll long long
#define rint register int
#define max(a,b) ((a)>(b)?(a):(b))
using namespace std;
const int Mod=1e9+1;
const int M=1e5+10;
bool flag[M]; ll ans=1;
int n,f[25][1<<20],map[25][25];
inline ll calc(rint x){
    rint i,j,m=1,o=1,k,limit[20];
    for(map[1][1]=x,i=1;i<=20;++i){
        if(i>1){ //对第一列进行单独的处理(边界问题) 
            if(map[i-1][1]*2>n) break;
            map[i][1]=map[i-1][1]*2;
            flag[map[i][1]]=1;
        }
        for(m=i,j=2;j<=20;++j){
            if(map[i][j-1]*3>n) break;
            o=max(o,j);
            map[i][j]=map[i][j-1]*3;
            flag[map[i][j]]=1;
        }
    }
    // 这里是对矩阵中每一行的边界的处理,
	//因为有不能大于 n 的限制,每一行的右边界并不是固定的 
    for(i=1;i<=m;++i){ //枚举行 
        for(j=1;j<=o;++j)  //枚举列 
        	if(!map[i][j]) break;
        	else map[i][j]=0; 
        for(limit[i]=0;j<=o;++j)  //limit[i] 表示矩阵中第 i 行的边界 
			limit[i]|=(1<<(o-j));
    }
    
    for(j=0;j<(1<<o);++j) //状压预处理第一行可行的状态 
    	if(!(j&(j<<1))&&!(j&(j>>1))&&!(limit[1]&j)) f[1][j]=1;
    for(i=2;i<=m;++i)
	  for(j=0;j<(1<<o);++j)  //枚举当前行的状态 
        if(!(j&(j<<1))&&!(j&(j>>1))&&!(limit[i]&j)) //不能超过边界 
          for(f[i][j]=0,k=0;k<(1<<o);++k) //枚举上一行的状态 
            if(!(k&(k<<1))&&!(k&(k>>1))&&!(limit[i-1]&k)&&!(k&j)) //判断是否可行 
              f[i][j]=(f[i][j]+f[i-1][k])%Mod;  //方案数累加 
    int sum=0;
    for(i=0;i<(1<<o);++i)
      if(!(i&(i<<1))&&!(i&(i>>1))&&!(i&limit[m])) sum+=f[m][i]; //对总方案数进行累加 
    return sum;
}
int main(){
    scanf("%d",&n);
    for(rint i=1;i<=n;++i) if(!flag[i])  //如果已经在之前的矩阵中出现过了就不用再处理了 
    	ans=(ans*calc(i))%Mod; //ans 乘上 当前方案数 
    printf("%lld\n",ans);
}
```

---

## 作者：Newuser (赞：2)

本蒟蒻的小站：[Newuser小站：集合选数](http://www.newuser.top/2018/05/30/%e3%80%90hnoi2012%e9%9b%86%e5%90%88%e9%80%89%e6%95%b0%e3%80%91%e6%95%b0%e5%ad%a6%e6%9e%84%e9%80%a0%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9/)

我们考虑将这些数分化，由于每个数x是否可选只与 (x/2) (x/3) (x*2) (x*3) 有关，于是我们考虑到这个可以构造出一个矩阵

【1*x】【3*x】【9*x】 【27*x】 。。。。。

【2*x】【6*x】 【18*x】 …….

【4*x】【12*x】 【36*x】…..

【8*x】……
....

也就是矩阵的四周分别是我们提到的那些有关数，这样问题就转化为了在矩阵（事实上由于有n的限制其应该为一个锯齿状）里面选取不相邻元素的方案数。

我们可以显然可见，一直乘3，长度不会超过11，宽度也不会太多。我们具体解决的时候运用类似炮兵阵地[Luogu炮兵阵地](https://www.luogu.org/problemnew/show/P2704)Luogu炮兵阵地的思路搞一个DP或者记忆化搜索（事实上代码能力很弱的我只写得出记忆化）就可以了。由于对于一个矩阵其会有许多数没有包含进去。而对于这些没有包含的，我们对其一个一个建立矩阵然后DP。

由于这些彼此矩阵之间的数不会重复，也即恰好n个数建立完所有矩阵。而彼此矩阵之间不会有联系（我这边选了方案对方矩阵的方案数不受影响）我们直接乘法原理将所有矩阵方案数相乘即可。

稍微卡卡常也就过去了（当这一排的某个数超过n，这一排接下来的数就不需要构造了）

```cpp
//%%%
#include<bits/stdc++.h>
typedef long long ll;
using namespace std;
const ll mod = 1000000001LL;
ll n,S;
ll dp[20][1<<12];
ll jz[20][20];
bool mark[20][1<<12];
ll pos[20];
ll ans=1;
bool bb[100005];
bool check(ll now,ll last,ll pai)
{
	if( ( !(now&last) ) && ( (pos[pai]|now) == pos[pai] ) && ( !(now&(now>>1)) ) )   return true;
	else return false;
}
ll dfs(ll &limit,ll pai,ll now)
{
	if(mark[pai][now]) return dp[pai][now]%mod;
	mark[pai][now]=1;
	if(pai==limit) return dp[pai][now]=1;
	ll sum=0; 
	for(ll i=S;i>=0;i--)
	{
		if(check(i,now,pai+1))
		{
			sum = (sum + dfs(limit,pai+1,i))%mod;
		}
	}
	return dp[pai][now] = sum;
}
void gzdp(ll x)
{
	memset(pos,0,sizeof pos);
	ll chang=x,cc=1,kuan=x,kk=1;
	while(chang*3<=n) ++cc,chang*=3;
	while(kuan*2<=n) ++kk,kuan*=2;
	jz[1][1]=x; bb[x]=1;
	for(int i=2;i<=cc;i++) jz[1][i]=jz[1][i-1]*3,bb[jz[1][i]]=1;
	for(int i=2;i<=kk;i++)
	{
		jz[i][1]=jz[i-1][1]*2; bb[jz[i][1]]=1; pos[i]|=1;
		for(int j=2;j<=cc;j++)
		{
			jz[i][j]=jz[i][j-1]*3;
			if(jz[i][j]>n) break;
			else 
			{
				bb[jz[i][j]]=1;
				pos[i] |= (1<<(j-1));
			}
		}
	}
	S=(1<<cc)-1; pos[1]=S;
	ll sum = 0;
	for(int s=0;s<=S;s++)
	{
		if(check(s,0,1)) sum = ( sum + dfs( kk , 1,s ) )%mod;
	}
	ans = ans * sum%mod;
	for(ll i=1;i<=kk;i++)
	{
		for(ll j=0;j<=S;j++)
		{
			dp[i][j]=0;
			mark[i][j]=0;
		}
	}
}
int main()
{
	scanf("%lld",&n);
	for(ll i=1;i<=n;i++)
	{
		if(!bb[i]) gzdp(i);
	}
	printf("%lld",ans);
}
```

---

## 作者：kouylan (赞：1)

## 题解 P3226 【[HNOI2012]集合选数】

[洛谷题面传送门](https://www.luogu.com.cn/problem/P3226)

乍一看这道题，好像无从下手。那么我们就要把它转化成我们熟悉的模型或问题。那么，我们就需要构造。

我们来看这样一个矩形：

$1\ \ \ 3\ \ \ 9\ \ \ 27\ ...$

$2\ \ \ 6\ \ 18\ \ \ 54\ ...$

$4\ \ 12\ \ 36\ \ 108\ ...$

同一行内，右边的数是左边的数的 $3$ 倍；同一列内，下面的数是上面的数的 $2$ 倍。这样，我们就把原题转化成了这样一个题目：

在矩阵内选数，保证选出的数不相邻，求方案数。矩阵不一定满。也就是说，每一行的数可能不一样多（这很好理解，因为矩阵里每个数最多是 $n$）

而这个矩阵最多是 $log_2n\times log_3n$，也就不超过 $20\times 20$，直接状压dp即可。

最后一个小注意点，就是一个矩阵不能涵盖 $1$ ~ $n$ 所有的数。我们只需要多次构造矩阵，分别求出结果。最后根据乘法原理把所有矩阵的结果相乘就是答案。

下面是 AC 代码
```cpp
/*
luogu P3226
*/
#include <bits/stdc++.h>
using namespace std;

#define int long long

const int M = 1e9+1;

int k,n,m[20],a[20][20];
int ans=1,f[20][1<<15];
bool vis[100005];
vector<int> s[20];

bool legal(int x,int m)
{
	for(int i=1;i<=m;i++)
		if((x>>i&1)==1 && (x>>i-1&1)==1)
			return false;
	return true;
}

void init()
{
	for(int i=0;i<15;i++)
		for(int t=0;t<(1<<i);t++)
			if(legal(t,i))
				s[i].push_back(t);
}

void create(int st)
{
	n = 1;
	a[1][1] = st;
	vis[st] = true;
	int num=st;
	while(num*2<=k)
	{
		a[++n][1] = num*2;
		num *= 2;
		vis[num] = true;
	}
	for(int i=1;i<=n;i++)
	{
		num = a[i][1];
		m[i] = 1;
		while(num*3<=k)
		{
			a[i][++m[i]] = num*3;
			num *= 3;
			vis[num] = true;
		}
	}
}

int dp()
{
	f[0][0] = 1;
	for(int i=1;i<=n;i++)
		for(int u=0;u<s[m[i]].size();u++)
		{
			f[i][u] = 0;
			for(int v=0;v<s[m[i-1]].size();v++)
				if((s[m[i]][u]&s[m[i-1]][v])==0)
					f[i][u] = (f[i][u]+f[i-1][v])%M;
		}
	int res=0;
	for(int i=0;i<s[m[n]].size();i++)
		res = (res+f[n][i])%M;
	return res;
}

signed main()
{
	cin>>k;
	init();
	for(int i=1;i<=k;i++)
		if(!vis[i])
		{
			create(i);
			ans = ans*dp()%M;
		}
	cout<<ans<<endl;
	
	return 0;
}
```

祝大家 AC 愉快！

---

## 作者：lotus_grow (赞：1)

暴力的做法就是直接枚举 $1$ ~ $2^n$ $-1$ ，再判断这个数字代表的选择方案是否合法，统计答案即可。

依旧考虑状压，发现 $n<=100000$ ，直接状压显然不可做，那就考虑减少状态数。

根据题意，当选了一个数 $x$ ，那么 $2x$ ， $2x$ 就不能选，但是 $4x$ ，$6x$ 等是可以选的。

那可以构造一个等比数列，公比为 $2$ 或 $3$ ,可以得到数列中相邻两项不能同时选到。这样一个数列长度最多为 $18$ 或 $13$ 。

所以根据题意，构造一个矩阵，每一行中各个元素构成一个公比为 $3$ 的等比数列，每一列中各个元素构成一个公比为 $2$ 的等比数列。经计算得这个矩阵的规模最大为 $18*13$ 。然后就可以状压dp了。

设 $f[i][S]$ 表示选到第 $i$ 行，当前行选择状态为 $S$ 的方案数。那么显然转移方程为 $f[i][S]+=f[i-1][S']$ ，$S$ 与 $S'$ 都为合法状态且 $S$ & $S'=0$ 。

对于每个没在矩阵中出现的元素构造一个新的矩阵，因为两个矩阵中的所有元素都不相同，所以可以用乘法原理统计答案。

**代码**
```pascal
program ll;
const m=1000000001;
var n,i:longint;
    ans:int64;
    b:array[0..18] of longint;
    a:array[1..18,1..18] of longint;
    f:array[0..18,0..2048] of longint;
function cal(x:longint):longint;
var i,j,k:longint;
begin
  fillchar(b,sizeof(b),0);
  a[1,1]:=x;
  for i:=2 to 18 do
  if a[i-1,1]*2<=n then
  a[i,1]:=a[i-1,1]*2
  else
  a[i,1]:=n+1;
  for i:=1 to 18 do
  for j:=2 to 11 do
  if a[i,j-1]*3<=n then
  a[i,j]:=a[i,j-1]*3
  else a[i,j]:=n+1;
  for i:=1 to 18 do
  for j:=1 to 11 do
  if a[i,j]<=n then
  b[i]:=b[i] or (1<<(j-1));
  fillchar(f,sizeof(f),0);
  f[0,0]:=1;
  for i:=0 to 17 do
  for j:=0 to b[i] do
  if f[i,j]<>0 then
  for k:=0 to b[i+1] do
  if (j and k=0) and (k and (k>>1)=0) then
  f[i+1,k]:=(f[i,j]+f[i+1,k]) mod m;
  exit(f[18,0]);
end;
begin
  readln(n);
  ans:=1;
  for i:=1 to n do
  if (i mod 2<>0) and (i mod 3<>0) then
  ans:=ans*cal(i) mod m;
  writeln(ans);
end.
```

---

## 作者：__Iron (赞：0)

   
   记 **g[x]** 表示将x中的2,3因子去除后得到的值。（除去**所有**的2，3因子）
   
   若**g[x]!=g[y]**，那么x与y互不影响。
   
   因为：此时x不可能是y的二倍或三倍数（假定x > y）,
   
   举个例子：20和18，除去所有的2，3因子后变为 5 和 1。 显然他们不互相影响
   
   那么，对于互相有影响的一组数，**一定**能表示成**q * 2^a * 3^b(q为常数)。**
 
   每种q分别求解，再根据乘法原理相乘即可。
   
####    实现：
   
 当 q=1 时
        
   我们可以以a，b为行列画成一个棋盘 即
   
   1 * 2^0 * 3^0  、1 * 2^0 * 3^1 、1 * 2^0 * 3^2 ……
   
   1 * 2^1 * 3^0  、1 * 2^1 * 3^1 、1 * 2^1 * 3^2 ……
   
   1 * 2^2 * 3^0  、1 * 2^2 * 3^1 、1 * 2^2 * 3^2 ……
   
   1 * 2^2 * 3^0  、1 * 2^2 * 3^1 、1 * 2^2 * 3^2 ……
   
   ……
   
   每行大小不超过 n
   
   n的 范围 n<=100000
   
   在这个范围内，我们不难发现（打个表也可以），每行的个数**很少**（不到二十）。
   
   如果你对状态压缩dp比较熟悉，就联想到状压经典套路。
   
   **在做题过程中发现某一信息种类数很少。**
   
  当q>1 时，等同于q'= 1,n'=n/q 。
  
  因为：每行的数要满足 q * 2^a * 3^b <= n 移项等同于 2^a * 3^b <=n/q
  
###   code: 

   ```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<ctime>
#include<cstring>
using namespace std;
inline int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=x*10+ch-'0';
		ch=getchar();
	}
	return x*f;
}
const int N=1e5+7;
const int p=1e9+1;
int n,cnt_floor[20],cnt,cnt_status[20],status[20][150000];
long long fl[N],dp[20][150000];
long long ans=1;
inline int judge(int x){
	if(x&(x<<1)) return 0;
	if(x&(x>>1)) return 0;
	return 1;
}
inline int work(int x,int y){
   if(x&y) return 0;
   return 1; 
}
int main(){
	n=read();
	for(register int q=1;q<=n;q++){
	  if(q%2==0||q%3==0) continue;/*如果q是2，3的倍数，则q一定被选过
	  （我们要保证每种数只能选一次）*/ 
	  
	  if(fl[n/q]){ /*小剪枝，当n/q一样时，不重复计算*/ 
	  	ans=(ans*fl[n/q])%p;
	  	continue;
	  } 
	  
	  int a3=1,cnt=0;
	  for(register int i=0;;i++){//暴力处理每一行的个数 
	    int a2=1;
	    if(a3*a2>n/q) break;
	    cnt_floor[i+1]=0; cnt++;
	  	for(register int j=0;;j++){
	  		if(a3*a2>n/q) break;
	  		else  cnt_floor[i+1]++;
	  		a2*=2;
		  }
		  a3*=3;
	   }
	   
	  int max1=0;
	  for(register int i=1;i<=cnt;i++)//找出所有行最长的一行（处理下面合法状态用到） 
	    max1=max(cnt_floor[i],max1);
	    
	  for(register int i=1;i<=cnt;i++){/* 一般状态压缩我们会提前处理好合法状态，
	  可以有效减小时间复杂度*/ 
	  	cnt_status[i]=0;
	  	for(register int j=0;j<(1<<cnt_floor[i]);j++)
	     if(judge(j)) cnt_status[i]++,
		  status[i][cnt_status[i]]=j<<(max1-cnt_floor[i]);//行头对齐  
	  }
	  
	  for(register int i=1;i<=cnt_status[1];i++) dp[1][i]=1;//状压 
	  for(register int i=2;i<=cnt;i++){
	    for(register int k=1;k<=cnt_status[i];k++){
	    	dp[i][k]=0;
	     for(register int j=1;j<=cnt_status[i-1];j++)
	  	  if(work(status[i-1][j],status[i][k])) 
			dp[i][k]=(dp[i][k]+dp[i-1][j])%p;	
		}
	  }
	  
	  long long part_q=0;//计算n/q下，所有方案数 
	  for(register int i=1;i<=cnt_status[cnt];i++)
	   part_q=(part_q+dp[cnt][i])%p;
	  
	  ans=(ans*part_q)%p;//乘法原理 
	  
	  fl[n/q]=part_q;//标记 
	}
	printf("%lld",ans);
	return 0;
} 
```

   
   
      

---

## 作者：nofind (赞：0)

题意：https://www.luogu.org/problem/P3226

上来觉得是个f[i]表示前i个数的方案数,用组合数考虑添加i多出的方案数,结果不会了~

正解是个神仙构造

先看个矩阵：

```
1 2 4 8...

3 6 12 24...

9 18 36 72...

... ... ...
```
容易发现同一行每一个数右边的数是它的两倍,同一列每个数下边的数是它的三倍,每一行长度小于log2(n)，每一列长度小于log3(n)

这个矩阵有什么用?

我们发现对于矩阵中的一个数a[i][j]，a[i][j+1]和a[i+1][j]显然都不能选,假设这个矩阵包含了1~n中的所有数,那么显然有状压DP:

f[i][j]->前i行,第i行状态为j的方案数

f[i][j]+=f[i-1][k] (j,k合法,j&k==0)

是不是可做了~

但是这一个矩阵可能不包含1~n中的所有数,怎么办呢?

开一个vis数组记录数x是否在矩阵出现过,如果vis[x]==0,就以x为左上角,再建一个矩阵,求解一遍乘到答案中,显然新矩阵中的数不会在之前出现过(用分解质因数的方法证就可以了)

code:

```
#include<bits/stdc++.h>
using namespace std;
#define re register
#define int long long
const int maxn=100010;
const int mod=1000000001; 
int n,ans=1,res,last;
int line[20],lim[20];
int a[20][20],f[2][1<<20];
bool check[1<<20],vis[maxn];
inline void build(int x)
{
	for(re int i=1;i<=11;i++)
	{
		if(i==1)a[i][1]=x;
		else a[i][1]=a[i-1][1]*3;
		if(a[i][1]>n)break;
		last=i,line[i]=1,vis[a[i][1]]=1;
		for(re int j=2;j<=18;j++)
		{
			a[i][j]=a[i][j-1]*2;
			if(a[i][j]>n)break;
			line[i]=j;vis[a[i][j]]=1;
		}
		lim[i]=(1<<line[i])-1;
	}
	//printf("case::%d :%d\n",x,last);
}
inline void solve(int x)
{
	res=0;int now=1;
	for(re int i=0;i<=lim[1];i++)f[1][i]=check[i];
	for(re int i=2;i<=last;i++)
	{
		/*for(int j=0;j<=lim[i-1];j++)printf("%d ",f[now^1][j]);
		puts("");*/
		now=i&1;
		for(re int j=0;j<=lim[i];j++)
		{
			f[now][j]=0;
			if(!check[j])continue;
			for(re int k=0;k<=lim[i-1];k++)
			{
				if(check[k]&&!(k&j))f[now][j]=(f[now][j]+f[now^1][k])%mod;	
			}
		}
	}
	//printf("now::%d\n",now);
	//for(int i=0;i<=lim[last];i++)if(check[i])printf("%d\n",i);
	for(re int i=0;i<=lim[last];i++)if(check[i])res=(res+f[now][i])%mod;
	//printf("res::%d\n",res);
}
signed main()
{
	scanf("%lld",&n);
	for(re int i=0;i<(1<<18);i++)check[i]=((i<<1)&i)?0:1;
	for(re int i=1;i<=n;i++)
	{	
		if(vis[i])continue;
		build(i),solve(i);
		if(res)ans=(ans*res)%mod;
	}
	printf("%lld",ans);
	return 0;
} 
```




---


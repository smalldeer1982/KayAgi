# [JLOI2015] 管道连接

## 题目描述

小铭铭最近进入了某情报部门，该部门正在被如何建立安全的通道连接困扰。该部门有 $n$ 个情报站，用 $1$ 到 $n$ 的整数编号。给出 $m$ 对情报站 $(u_i,v_i)$ 和费用 $w_i$，表示情报站 $u_i$ 和 $v_i$ 之间可以花费 $w_i$ 单位资源建立通道。

如果一个情报站经过若干个建立好的通道可以到达另外一个情报站，那么这两个情报站就建立了通道连接。形式化地，若 $u_i$ 和 $v_i$ 建立了通道，那么它们建立了通道连接；若 $u_i$ 和 $v_i$ 均与 $t_i$ 建立了通道连接，那么 $u_i$ 和 $v_i$ 也建立了通道连接。

现在在所有的情报站中，有 $p$ 个重要情报站，其中每个情报站有一个特定的频道。小铭铭面临的问题是，需要花费最少的资源，使得任意相同频道的情报站之间都建立通道连接。

## 说明/提示

选择 $(1,5),(3,5),(2,5),(4,5)$ 这 $4$ 对情报站连接。

对于 $100\%$ 的数据，$1\le c_i\le p\le10$，$1\le u_i,v_i,d_i \le n \le 1000$，$0\le m \le 3000$，$0\le w_i \le2\times 10^4$。

## 样例 #1

### 输入

```
5 8 4
1 2 3
1 3 2
1 5 1
2 4 2
2 5 1
3 4 3
3 5 1
4 5 1
1 1
1 2
2 3
2 4```

### 输出

```
4```

# 题解

## 作者：seajupiter (赞：19)

（不好意思麻烦管理员啦，以前没用过图床，结果这回写完就把图删掉了/笑哭）

**算法：斯坦纳树+状压DP**

此题题意很简单，就是要在图中选出一些边把给出的几个点集各子内部的点连通起来，问最小边权和。

看道题目就很容易想到斯坦纳树，但是注意：**斯坦纳树是要求所有关键点联通，而此题只需要同一个类的关键点联通，不同类关键点连不连通都可以**。那么就不能直接斯坦纳树了，该怎么做呢？

我们考虑一下斯坦纳树的状态设计，$f_{s, i}$ 表示 $s$ 集合内部的点都联通且根为 i 时的最小代价，是不是有启发呢？这道题棘手之处就在于你不知道哪些类会连在一棵树里，那么就可以一样状压 DP 啊！

我们把点的类别（频道）叫做”颜色“，设 $g_s$ 表示把 $s$ 集合内部的点构成**斯坦纳树森林**，且保证

- 若某一个点在 $s$ 中，则所有与它相同颜色均在 $s$ 中；

- 所有同颜色的点在同一棵**斯坦纳树**中；

很显然有转移：

$g_s=\min\limits_{s' \subseteq s}{\ g_{s'}+g_{s-s'}}$

设所有关建点构成的集合为 $all$ ，最后的答案就是 $g_{all}$

**也许你可能有疑惑：这样合并不会重复算边吗？**

的确不错，是会重复算边，但是不影响。因为如果我们把所有的情况考虑到了，**由于边权非负，最后得到的最优答案一定时没有重复算边权的**。

但是我认为此题难点不在这里，而是在 $g$ 数组的初始化（也可能是我太菜了），因此在这里把我写的过程犯的几个错误说一下，希望能帮到一些朋友 QAQ。

先赋 inf：

```
	memset(g, 0x3f, sizeof(g));
```

然后解决初值问题。

最开始，我是这么写的（求大佬不要嘲笑啊）：

```cpp
	for(int i=1; i<=K; ++i) if(p[i]){
		int S=p[i];
		for(int j=1; j<=n; ++j)
			g[S]=min(g[S], f[S][j]);
//		print(S),cout<<g[S]<<endl;
	}
```

$p_i$ 表示颜色为 $i$ 的点构成的集合。

直接把每个类的点搞一棵斯坦纳树嘛，之后不就可以合并了？

然而错的很离谱（话说这题数据是真的水，到后面你就知道了）……

![WA 70分](https://cdn.luogu.com.cn/upload/image_hosting/z9vitp7h.png)

为什么？**因为完全可以把几类点放到一棵树里头啊！否则可能后面 DP 最小值就可能会得到重复算边代价的答案，导致答案偏大。**

那么，改一下就好了嘛：

```
for(int S=1; S<(1<<K); ++S){
	work(S);
	for(int i=1; i<=K; ++i) if(S&p[i]==p[i]){
		for(int j=1; j<=n; ++j)
			g[S]=min(g[S], f[S][j]);
		break;
	}
}
```

然而错的更离谱！要注意到，**&的优先级是低于==的！** 所以这样根本不是在判断是否为子集！

然而居然~

![WA 80](https://cdn.luogu.com.cn/upload/image_hosting/juxrvv91.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

好的赶快把这里改过来，以后要记得加括号，防止优先级问题。

改成了这样：

```cpp
	for(int S=1; S<(1<<K); ++S){
		work(S);
		for(int i=1; i<=K; ++i) if(p[i]&&(S&p[i])==p[i]){
			for(int j=1; j<=n; ++j)
				g[S]=min(g[S], f[S][j]);
			break;
		}
	}
```

结果~

![WA 85](https://cdn.luogu.com.cn/upload/image_hosting/tr322wb5.png)

噫，怎么还是WA，有毒啊QAQ~

再仔细想一想，肯定还是状压DP部分的问题（斯坦纳树我是先过了模板的）。

观察评测结果，发现这次结果似乎偏小了！那么一定是不合法的状态更新了答案，也就是说，与上面状态限制中的两条发生了违背。为什么会这样呢？

仔细考虑这个判断，我们的思路是：**只要这个集合包含了某一类点的全部，就可以建成一棵斯坦纳树。** 漏洞在哪里？举个例子，如果这个集合虽然包含了所有”红色点“，但是包含了**一部分**”黄色点“的话，其实是不满足我们列出的两个条件的，因为**有黄色点在这个集合中，然而并非所有黄色点都在这个集合中，也并非所有黄色点都在一棵斯坦纳树中**。

形式化地讲，在初始化的时候（把初始化集合的点全部建到一棵树里头去），一个集合 $s$ 合法，当且仅当：

**对于任何一种颜色，所有为此颜色的点要么全部在 $s$ 中，要么全部不在 $s$ 中**。

弄明白了这个，总算可以写出正确程序了：

```cpp
	for(int S=1; S<(1<<K); ++S){
		work(S);
		bool flag=true;
		for(int i=1; i<=K; ++i) if(p[i])
			if((S&p[i])!=p[i]&&(S&p[i])!=0) flag=false;
		if(flag) for(int i=1; i<=n; ++i)
			g[S]=min(g[S], f[S][i]);
	}
```

下面给出完整 AC 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
inline void read(int &x){
	char c=getchar();x=0;
	while(!isdigit(c))c=getchar();
	while(isdigit(c))x=x*10+c-'0',c=getchar();
}
const int N=1005, M=3005, V=N, E=M<<1, NUM=15, SZ=1<<10|5, inf=0x3f3f3f3f;
int n, m, K, key[NUM], col[NUM], p[NUM], f[SZ][N], ans, g[SZ];
int e, head[V], to[E], val[E], nxt[E];
inline void add(int u, int v, int w){
	to[++e]=v, val[e]=w;
	nxt[e]=head[u], head[u]=e;
}
inline void spfa(int *f){
	static bool inq[N];
	static queue<int> q;
	for(int i=1; i<=n; ++i) if(f[i]<inf)
		q.push(i), inq[i]=true;
	while(!q.empty()){
		int u=q.front(); q.pop(), inq[u]=false;
		for(int i=head[u]; i; i=nxt[i]){
			int v=to[i], w=val[i];
			if(f[v]>f[u]+w){
				f[v]=f[u]+w;
				if(!inq[v]) q.push(v), inq[v]=true;
			}
		}
	}
}
inline void work(int S){
	for(int s=(S-1)&S; s; s=(s-1)&S)
		for(int i=1; i<=n; ++i)
			f[S][i]=min(f[S][i], f[s][i]+f[S^s][i]);
	spfa(f[S]);
}
int main(){
	read(n);read(m);read(K);
	for(int i=1, u, v, w; i<=m; ++i){
		read(u);read(v);read(w);
		add(u, v, w), add(v, u, w);
	}
	memset(f, 0x3f, sizeof(f));
	memset(g, 0x3f, sizeof(g));
	for(int i=1; i<=K; ++i){
		read(col[i]);read(key[i]);
		f[1<<(i-1)][key[i]]=0;
		p[col[i]]|=(1<<(i-1));
	}
	for(int S=1; S<(1<<K); ++S){
		work(S);
		bool flag=true;
		for(int i=1; i<=K; ++i) if(p[i])
			if((S&p[i])!=p[i]&&(S&p[i])!=0) flag=false;
		if(flag) for(int i=1; i<=n; ++i)
			g[S]=min(g[S], f[S][i]);
	}
	for(int S=1; S<(1<<K); ++S)
		for(int s=(S-1)&S; s; s=(s-1)&S)
			g[S]=min(g[S], g[s]+g[S^s]);
	printf("%d\n", g[(1<<K)-1]);
	return 0;
}
```


这道题不能算是难题，但是写的时候还是要很注意细节，我就是因为这个初始化被坑了好久。所以建议大家在写 DP 的时候，要把状态的定义和转移条件等清晰地列出来，并根据这个考察代码的逻辑是否正确。希望这篇题解能帮到大家！（也希望管理员放通过一下，谢谢啦！）

---

## 作者：Log_x (赞：14)

**【解题思路】**

考虑把问题拆开，先得到在任意多个频道间建设管道的费用方案（因为不同频道的重要情报站的管道建设若有交集就可以节省费用），最后枚举所有情况，合并得到总共  $p$ 个频道的最小费用。

这时，对于任意多个频道，我们可以想到用**斯坦纳树**，就是构造包含这些关键点（重要情报站）的生成树的最小费用（因为是无向边，重要情报站之间互相连通）。

假设第 $l$~$r$ 个频道一共有 $\sum \limits^r_{i=l}P_i$ 个关键点，我们用 $\sum \limits^r_{i=l}P_i$ 位二进制数表示关键点是否在生成树上的状态。

对于斯坦纳树，令  $f[i][sta]$ 为一定包含点 $i$ ，关键点状态为 $sta$ 的最小费用。

则 $f[i][sta]$ 有两种转移：

$[1]. f[i][sta] = Min(f[i][s] + f[i][sta - s])$（$s$ 为 $sta$ 的子集）

即转移前的两种状态都包含点 $i$，它们的状态可以合并为 $sta$，同时保持初始时费用最小。

$[2]. f[i][sta] = Min(f[j][sta] + cst[i][j])$（其中 $i$ 号点和 $j$ 号点有边相连，费用为 $cst[i][j]$）

即包含点 $i$ 的当前最小费用可以通过与之相连的中间点 $j$ 更新为更优的方案。但这样就存在一个问题，如果我们枚举 $i,j$ ，则 $i$ 可由 $j$ 转移过来，而 $j$ 也可由 $i$ 转移过来，这明显与实际矛盾。因此我们要对所有存在方案的点 $j$ 跑 $SPFA$，以此寻找可以更新的点 $i$，跑 $SPFA$ 的同时也就避免了上述的问题。

之后我们记 $g[sta'] = Min(f[i][(1 << \sum \limits^r_{i=l}P_i) - 1])$  ，$sta’$ 是用 $p$ 位二进制数表示频道是否连通的状态(**与 $f[i][sta]$ 中的状态 $sta$ 表示意义不同**)，则 $g[sta']$ 表示频道状态为 $sta’$ 时的最优方案。

$g[sta']$ 的转移与 $f[i][sta]$ 的转移 $[1].$ 相同，也就是我们最上面所说的合并。即 $g[sta'] = Min(g[s'], g[sta' - s'])$（$s'$ 为 $sta'$ 的子集）。

最后的答案为 $g[(1 << p) - 1]$，得到的方案也就是**斯坦纳树森林**。

**【AC代码】**

```cpp
#include <iostream>  
#include <cstdio>  
#include <cstring>  
#include <algorithm>  
#include <queue>  
  
using namespace std;  
const int Maxn = 0x3f3f3f3f;  
const int N = 1005, M = 6005, L = 1 << 10;  
int lst[N], f[N][L], nxt[M], to[M], cst[M], g[L], c[12];   
int n, m, k, T, Cn; bool vis[N];  
queue<int> Q;  
  
template <class T> inline T Min(const T a, const T b) {return a < b? a : b;}  
template <class T> inline void CkMin(T &a, const T b) {if (a > b) a = b;}  
  
struct point  
{  
    int col, id;  
    #define col(x) a[x].col  
    #define id(x) a[x].id  
}a[12];  
  
inline bool cmp(const point x, const point y) {return x.col < y.col;}  
  
inline int get()  
{  
    char ch; bool f = false; int res = 0;  
    while (((ch = getchar()) < '0' || ch > '9') && ch != '-');  
    if (ch == '-') f = true;  
     else res = ch - '0';  
    while ((ch = getchar()) >='0' && ch <= '9')  
        res = (res << 3) + (res << 1) + ch - '0';  
    return f? ~res + 1 : res;  
}  
  
inline void put(int x)  
{  
    if (x < 0)  
      x = ~x + 1, putchar('-');  
    if (x > 9) put(x / 10);  
    putchar(x % 10 + 48);  
}  
  
inline void add(const int x, const int y, const int z)  
{  
    nxt[++T] = lst[x]; lst[x] = T; to[T] = y; cst[T] = z;  
    nxt[++T] = lst[y]; lst[y] = T; to[T] = x; cst[T] = z;  
}  
  
inline void SPFA(const int I)  
{  
    int x, y;  
    while (!Q.empty())  
    {  
        x = Q.front(); vis[x] = false; Q.pop();  
        for (int i = lst[x]; i; i = nxt[i])  
         if (f[y = to[i]][I] > f[x][I] + cst[i])  
         {  
            f[y][I] = f[x][I] + cst[i];  
            if (!vis[y]) vis[y] = true, Q.push(y);  
         }  
    }  
}  
  
inline int solve(const int cnt)  
{  
    int Cm = 1 << cnt;  
    for (int i = 1; i < Cm; ++i)  
    {  
        for (int j = 1; j <= n; ++j)  
        {  
            for (int k = (i - 1) & i; k; k = (k - 1) & i)  
            // 表示枚举子集：k不断减一就不会遗漏  
            // (k - 1) & i 表示状态 k 中包含的关键点总状态 i 中一定包含    
             CkMin(f[j][i], f[j][k] + f[j][i - k]);  
            if (f[j][i] != Maxn) vis[j] = true, Q.push(j);  
        }  
        SPFA(i);  
    }  
    int res = Maxn;  
    for (int i = 1; i <= n; ++i) CkMin(res, f[i][Cm - 1]);  
    return res;  
}  
  
int main()  
{   
    n = get(); m = get(); k = get(); int x, y;  
    for (int i = 1; i <= m; ++i)  
    {  
        x = get(); y = get();   
        add(x, y, get());  
    }  
    for (int i = 1; i <= k; ++i)   
        col(i) = get(), id(i) = get();  
    sort(a + 1, a + k + 1, cmp);  
    for (int i = 1; i <= k; ++i)  
    {  
        if (col(i) != col(i - 1)) Cn++; c[i] = Cn;  
    }  
    for (int i = 1; i <= k; ++i) col(i) = c[i]; //离散化 
    Cn = (1 << Cn);  
    memset(g, Maxn, sizeof(g));  
    for (int i = 1; i < Cn; ++i)  
    {  
        memset(f, Maxn, sizeof(f));  
        int cnt = 0;   
        for (int j = 1; j <= k; ++j)   
         if ((1 << col(j) - 1) & i) f[id(j)][1 << cnt++] = 0;  
        g[i] = solve(cnt);  
     }   
    for (int i = 1; i < Cn; ++i)  
     for (int j = (i - 1) & i; j; j = (j - 1) & i)  
      CkMin(g[i], g[j] + g[i - j]);  
    return put(g[Cn - 1]), 0;  
}  
```

---

## 作者：Demoe (赞：9)

### [题目传送门](https://www.luogu.com.cn/problem/P3264)

## 题意

- 给出一张 $n$ 个点，$m$ 条边带有 $p$ 的特殊点的图，每个特殊点有一个颜色。

- 要求选出若干条边，使得颜色相同的在同一个连通块内。

- 输出最小边权和。

----------------

先简单介绍一个问题类型。

**最小斯坦纳树**：在一张给定的带权无向图中，将其中 $k$ 个点变成连通块最少需要花费的代价。

因为最后连起来会是一棵树，所以就叫最小斯坦纳树。

令 $f_{i,S}$ 表示当前 $i$ 在的连通块中，点集状态为 $S$ 需要花费的最小费用。

## 转移方法

### 在一个点上汇合

我们需要合并不同的若干子集。

$f_{i,S1|S2}=min(f_{i,S1|S2})$

### 往一个方向走

需要一个SPFA实现。

$f_{j,S|w_j}=min(f_{i,S}+w_{i,j}$

回归本题。

### 最优解->斯坦纳森林。

不妨先用上述方法求出每个子集汇合需要的代价。

最后的解是若干个子集的并。

每个子集都是若干种**完整的颜色**。

利用一个子集dp完成。

```cpp
/*
***
还要继续努力
成为一名烤咕学家哦
***
*/
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=11,M=1005;
ll m,n,p,f[M][1<<N],g[1<<N],w[1<<N],k1,hd[M],ID[M],num[N],Q[M*M],vis[M];
struct Node{ll t,nxt,val;}s[M*10];
template <typename T> void rd(T &x){
	ll fl=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') fl=-fl;
	for(;isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+c-'0';
	x*=fl;
}
void wr(ll x){
	if(x<0) x=-x,putchar('-');
	if(x<10) putchar(x+'0');
	if(x>9) wr(x/10),putchar(x%10+'0');
}
void add(ll x,ll y,ll w){s[++k1].t=y; s[k1].nxt=hd[x]; s[k1].val=w; hd[x]=k1;}
void spfa(ll ID){
	Q[0]=0;
	for(ll i=1;i<=n;++i) if(f[i][ID]<(ll)1e9) Q[++Q[0]]=i,vis[i]=1;
	for(ll l=1;l<=Q[0];++l){
		ll p=Q[l];
		for(ll i=hd[p];i;i=s[i].nxt){
			ll k=s[i].t;
			if(f[k][ID]>f[p][ID]+s[i].val){
				f[k][ID]=f[p][ID]+s[i].val;
				if(!vis[k]){
					vis[k]=1;
					Q[++Q[0]]=k;
				}
			}
		}
		vis[p]=0;
	}
}
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	rd(n);rd(m);rd(p);
	for(ll i=1,u,v,val;i<=m;i++){
		rd(u);rd(v);rd(val);
		add(u,v,val);add(v,u,val); 
	}
	memset(ID,-1,sizeof(ID));
	for(ll i=1,x,y;i<=p;++i){
		rd(x);rd(y);
		ID[y]=i-1;num[x]|=(1<<(i-1));
	}
	memset(f,60,sizeof(f));
	for(ll i=1;i<=n;++i)
		if(ID[i]==-1) f[i][0]=0;
		else f[i][1<<ID[i]]=0;
	for(ll i=0;i<(1<<p);++i){
		if(i)
			for(ll k=1;k<=n;++k)
				for(ll j=(i-1)&i;j;j=(j-1)&i)
					f[k][i]=min(f[k][i],f[k][j]+f[k][i^j]);
		spfa(i);
	}
	memset(w,60,sizeof(w));
	for(ll i=0;i<(1<<p);++i)
		for(ll j=1;j<=n;++j) w[i]=min(w[i],f[j][i]);
	memset(g,60,sizeof(g));
	g[0]=0;
	for(ll i=1;i<(1<<p);++i)
		for(ll j=i;j;j=(j-1)&i){
			ll Num=0;
			for(ll k=0;k<p;++k) if(j&(1<<k)) Num|=num[k];
			g[i]=min(g[i],g[i^j]+w[Num]);
		}
	wr(g[(1<<p)-1]);puts("");
	return 0;
}
```

---

## 作者：jerry119 (赞：7)

前言：


如果还不知道斯坦纳树的童鞋可以看这两篇博客：

我的：Mine
我一开始学习的：Which I Have Studied

这道题，在我学习斯坦纳树之前就翻到了，是在洛谷上搜状压的时候看到的。那个时候还不知道斯坦纳树是个什么玩意，不过马上进行了学习。

然而学习了之后也没有什么卵用，发现并不只是斯坦纳树这么简单呐！


题解：


由于存在相同频率之间的连通，所以和一般的斯坦纳树是不同的（发现斯坦纳树所指定的结点频率是相同的），需要二次DP。

首先跑一遍斯坦纳树的板子，这就求出了 以某一个结点为树根并加入一些边使某几个点连通的最小值，那么我们可以用这个去更新另一个 DP 数组：Ans（S）。

方程：Ans（S）= minx（Ans（S），dp（i，S））；


定义 DP 数组 Ans （S），表示使状态 S 中所有点连通的最小费用，注意，这个 DP 的过程是有条件的：

首先枚举 S 集合（指定点集合），这个将这个状态 S 进行更新的条件是 S 必须：对于一个频率，要么包含该频率中的所有指定点，要么不包含于这个频率的任意结点！

接着枚举 S 的子集，这个子集 S1 也是要有条件的，也是 必须：对于一个频率，要么包含该频率中的所有指定点，要么不包含于这个频率的任意结点！

得到DP方程：Ans（S） = min（Ans（S），Ans（S1）+Ans（S^S1））；

这样最后的答案就是 Ans（1<<（p）-1）；

为什么要这样做呢？这样做不是和斯坦纳树中的 dp（i，S）数组重复了吗？

然而却有很大的区别，这样的 Ans（S）是使得 S 中相同的频率连通，而不是 S 中的所有点都连通！因为用于更新 S 的子集也满足这个条件，而 子集 和 子集对于 S 的补集没有联系，换句话说，两个子集内结点的连通互补干涉。

而加上频率的限制：


可以看出我们完全不用连边 2-5，因为这条边不改变相同频率的连通性！


所以带条件 Ans（S）经过DP更新后一定是最优解，并且保证没有额外边。


代码：

```cpp
#include <bits/stdc++.h>

std :: queue < int >  q ;

const  int  N = 2000 + 5 ;

struct  node {
    int  id , clr ;
}
dot [ 20 ] ;

int  head [ N << 3 ] , nxt [ N << 3 ] , dis [ N << 3 ] , to [ N << 3 ] , cn ;
int  dp [ N ] [ 1 << 11 ] , ans [ 1 << 11 ] , cnt [ 30 ] , sum [ 30 ] , n , m , p , S , x , y , w , inf ;
bool  vis [ N ] , ck [ 1 << 11 ] ;

int  minx ( int  a , int  b ) {
    return  a > b ? b : a ;
}

void  create ( int  u , int  v , int  d ) {
    cn ++ ;
    to [ cn ] = v ;
    dis [ cn ] = d ;
    nxt [ cn ] = head [ u ] ;
    head [ u ] = cn ;
}

void  spfa ( int  S ) {
    for ( int  i = 1 ; i <= n ; i ++ )
        if ( dp [ i ] [ S ] < inf )
            vis [ i ] = true , q . push ( i ) ;
    while ( ! q . empty ( ) ) {
        int  v , tmp = q . front ( ) ;
        q . pop ( ) ; vis [ tmp ] = false ;
        for ( int  i = head [ tmp ] ; i ; i = nxt [ i ] ) {
            v = to [ i ] ;
            if ( dp [ v ] [ S ] > dp [ tmp ] [ S ] + dis [ i ] ) {
                dp [ v ] [ S ] = dp [ tmp ] [ S ] + dis [ i ] ;
                if ( ! vis [ v ] ) {
                    vis [ v ] = true ;
                    q . push ( v ) ;
                }
            }
        }
  	}
}

bool  check ( int  S ) {
    memset ( cnt , 0 , sizeof ( cnt ) ) ;
    for ( int  i = 1 ; i <= p ; i ++ )
        if ( S & ( 1 << ( i - 1 ) ) )
            cnt [ dot [ i ] . clr ] ++ ;
    for ( int  i = 1 ; i <= 10 ; i ++ )
        if ( cnt [ i ]  &&  cnt [ i ]  !=  sum [ i ] )
            return  0 ;
    return  1 ;
}
 
int  main ( ) {
    
    scanf ( "%d%d%d" , & n , & m , & p ) ;
    memset ( dp , 127 / 3 , sizeof ( dp ) ) ;
    inf = dp [ 0 ] [ 0 ] ;
    S = ( 1 << p ) - 1 ;
    for ( int  i = 1 ; i <= m ; i ++ ) {
        scanf ( "%d%d%d" , & x , & y , & w ) ;
        create ( x , y , w ) ;
        create ( y , x , w ) ;
    }
    for ( int  i = 1 ; i <= p ; i ++ ) {
        scanf ( "%d%d" , & dot [ i ] . clr , & dot [ i ] . id ) ;
        sum [ dot [ i ] . clr ] ++ ;
    }
    for ( int  i = 1 ; i <= p ; i ++ )
        dp [ dot [ i ] . id ] [ 1 << ( i - 1 ) ] = 0 ; 
    for ( int  s = 0 ; s <= S ; s ++ ) {
    	for ( int  i = 1 ; i <= n ; i ++ )
        	for ( int  s1 = s ; s1 ; s1 = ( s1 - 1 ) & s )
                dp [ i ] [ s ] = minx ( dp [ i ] [ s ] , dp [ i ] [ s1 ] + dp [ i ] [ s ^ s1 ] ) ;
        spfa ( s ) ;
    }
    memset ( ans , 127 / 3 , sizeof ( ans ) ) ;
    for ( int  s = 0 ; s <= S ; s ++ )
        for ( int  i = 1 ; i <= n ; i ++ )
            ans [ s ] = minx ( ans [ s ] , dp [ i ] [ s ] ) ;
    for ( int  s1 = 0 ; s1 <= S ; s1 ++ )
        if ( check ( s1 ) )
            ck [ s1 ] = true ;
    for ( int  s = 0 ; s <= S ; s ++ )
        if ( ck [ s ] ) 
            for ( int  s1 = s ; s1 ; s1 = ( s1 - 1 ) & s )
                if ( ck [ s1 ] )
                    ans [ s ] = minx ( ans [ s ] , ans [ s1 ] + ans [ s ^ s1 ] ) ;
    printf ( "%d" , ans [ S ] ) ;
    return  0 ;
}
```

For Fun
Code for A+B Problem :

```cpp
#include <bits/stdc++.h>

void  init ( ) ;

int  head [ 1000 ] , nxt [ 1000 ] , dis [ 1000 ] , to [ 1000 ] , cn ;
int   dp [ 1000 ] [ 1000 ] ;
int  n , ans , a , b ;
bool  vis [ 1000 ] ;

std :: queue < int > q ;

void  create ( int  u , int  v , int d ) {
	cn ++ ;
	to [ cn ] = v ;
	dis [ cn ] = d ;
	nxt [ cn ] = head [ u ] ;
	head [ u ] = cn ;
}

void  Spfa ( int  S ) {
    for ( int  i = 1 ; i <= n ; i ++ )
        vis [ i ] = true , q . push ( i ) ;
    while ( ! q . empty ( ) ) {
        int  v , tmp = q . front ( ) ;
        q . pop ( ) ; vis [ tmp ] = false ;
        for ( int  i = head [ tmp ] ; i ; i = nxt [ i ] ) {
            v = to [ i ] ;
            if ( dp [ v ] [ S ] > dp [ tmp ] [ S ] + dis [ i ] ) {
                dp [ v ] [ S ] = dp [ tmp ] [ S ] + dis [ i ] ;
                if ( ! vis [ v ] ) {
                    vis [ v ] = true ;
                    q . push ( v ) ;
                }
            }
        }
  	}
}

int  main ( ) {
	scanf ( "%d%d" , & a , & b ) ;
	n = 5 ;
	create ( 1 , 2 , a + b ) ;
	create ( 2 , 1 , a + b ) ;
	create ( 1 , 3 , 192608170 ) ;
	create ( 3 , 1 , 192608170 ) ;
	create ( 2 , 3 , 192608170 ) ;
	create ( 3 , 2 , 192608170 ) ;
	create ( 4 , 3 , 192608170 ) ;
	create ( 3 , 4 , 192608170 ) ;
	create ( 5 , 4 , 192608170 ) ;
	create ( 4 , 5 , 192608170 ) ;
	memset ( dp , 0x3f , sizeof ( dp ) ) ;
	for ( int  i = 1 ; i <= 2 ; i ++ )
		dp [ 1 << ( i - 1 ) ] [ i ] = 0 ;
	for ( int  s = 0 ; s <= 3 ; s ++ ) {
    	for ( int  i = 1 ; i <= n ; i ++ )
        	for ( int  s1 = s ; s1 ; s1 = ( s1 - 1 ) & s )
                dp [ i ] [ s ] = std :: min ( dp [ i ] [ s ] , dp [ i ] [ s1 ] + dp [ i ] [ s ^ s1 ] ) ;
        Spfa ( s ) ;
    }
	printf ( "%d" , dp [ 1 ] [ 3 ] ) ;
	return  0 ;
} 
```

---

## 作者：louhao088 (赞：3)

最小斯坦纳树应用


最小斯坦纳树是一种状压 dp ，用来求在一个无向连通图里有几个关键点，边有权值，选择边的子集，使关键点连通且权值和最小的问题。

首先这个子集必然为一棵树，否则去掉一条边可定不会变劣。

令 $f_{i,j}$ 表示在以 i 为根的树里，已经有状态 j 的点连通的最小代价。

两种转移：

换根：$f_{i,j}= \min(f_{i,j},f_{k,j}+w(i,k))$

子集合并：$f_{i,j}=\min(f_{i,j},f_{i,s}+f_{i,j \land s})$

第一种我们可以用最短路的方法，用 dij 堆优化做。

第二种可以枚举子集，暴力维护。

时间复杂度 ：$O(n3^k+m \log m 2^n)$

在求完最小斯坦纳树后，继续枚举子集，一个子集无限制，一个子集为自己子集中包含的频道的所有情报站。

以此做一个 dp 即可。



------------
代码如下
```cpp
// Problem: P3264 [JLOI2015]管道连接
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P3264
// Memory Limit: 250 MB
// Time Limit: 1000 ms
// 2022-01-21 14:27:26
// Author : louhao088
// 

#include<bits/stdc++.h>
using namespace std;
//static char buf[1000000],*p1=buf,*p2=buf;
//#define getchar() p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++
#define pi pair<int,int>
#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define ls (rt<<1)
#define rs (rt<<1|1)
#define mid (l+r>>1)
#define lowbit (x&-x)
#define int long long
const int maxn=1024+5,M=34005;
inline int read()
{
	char ch=getchar();bool f=0;int x=0;
	for(;!isdigit(ch);ch=getchar())if(ch=='-')f=1;
	for(;isdigit(ch);ch=getchar())x=(x<<1)+(x<<3)+(ch^48);
	if(f==1)x=-x;return x;
}
inline void print(int x)
{
    static int a[55];int top=0;
    if(x<0) putchar('-'),x=-x;
    do{a[top++]=x%10,x/=10;}while(x);
    while(top) putchar(a[--top]+48);
}
int n,m,f[maxn][maxn],num[15],k,x,y,z,vis[maxn],w[maxn],g[maxn],id[maxn],a[maxn];
vector<pi>e[maxn];
priority_queue<pi>q;
void dij(int s)
{
	memset(vis,0,sizeof vis);
	while(!q.empty())
	{
		int x=q.top().se;q.pop();
		if(vis[x])continue;vis[x]=1;
		for(auto i:e[x])
			if(f[i.fi][s]>f[x][s]+i.se)
				f[i.fi][s]=f[x][s]+i.se,q.push(mp(-f[i.fi][s],i.fi));
	}
}
signed main()
{
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	n=read(),m=read(),k=read();memset(f,0x3f,sizeof f);
	for(int i=1;i<=m;i++)
		x=read(),y=read(),z=read(),e[x].pb(mp(y,z)),e[y].pb(mp(x,z));
	for(int i=1;i<=n;i++)f[i][0]=0;
	for(int i=1;i<=k;i++)
		id[i]=read(),a[i]=read(),num[id[i]]+=(1<<(i-1)),f[a[i]][(1<<(i-1))]=0;
	for(int j=1;j<(1<<k);j++)
	{
		for(int i=1;i<=n;i++)
		{
			for(int s=j&(j-1);s;s=j&(s-1))
				f[i][j]=min(f[i][s]+f[i][s^j],f[i][j]);
			if(f[i][j]!=0x3f3f3f3f)q.push(mp(-f[i][j],i));
		}
		dij(j);
	}
	memset(w,0x3f,sizeof w),memset(g,0x3f,sizeof g);
	for(int j=0;j<(1<<k);j++)
		for(int i=1;i<=n;i++)w[j]=min(w[j],f[i][j]);
	g[0]=0;
	for(int j=1;j<(1<<k);j++)
	{
		for(int s=j;s;s=j&(s-1))
		{
			int res=0;
			for(int i=0;i<k;i++)if(s&(1<<i))res=res|num[id[i-1]];
			g[j]=min(g[j],g[s^j]+w[res]);
		}
	}
	cout<<g[(1<<k)-1]<<endl;
 	return 0;
}


```



---

## 作者：cyffff (赞：2)

[$\text{Link}$](https://www.luogu.com.cn/problem/P3264)
## 题意
给出一张 $n$ 个点，$m$ 条有权边的无向连通图，其中有 $k$ 个点是关键点，每个关键点都有一个颜色 $c_i$。求图的一个子图，满足所有颜色相同的关键点连通，使得所包含的边集的权值和最小，求这个最小值。

$n\le 1000$，$m\le3000$，$c_i\le k\le10$
## 思路
首先考虑如果所有点都是一个颜色，就是 [$\text{P6192}$](https://www.luogu.com.cn/problem/P6192) 了，可以使用状压 $\text{dp}$ 求出最小斯坦纳树，如果还不会可以看看[我的题解](https://www.luogu.com.cn/blog/cyffff/solution-p6192)。

设 $f_S$ 表示集合 $S$ 内的颜色都已连通的答案。

考虑用 $dp_{i,S}$ 为 $f$ 初始化，再枚举子集转移得到答案。初始化时不能只初始化 $f_{\{i\}}$，而是要把所有 $f$ 初始化，否则可能出现重边的情况。

考虑使用 $\text{dfs}(x,stu_p,stu_c)$ 表示搜到第 $x$ 种颜色，前 $x$ 种颜色中关键点集合为 $stu_p$，选中颜色集合为 $stu_c$，搜到终止状态即 $x=k+1$ 时，我们令 $f_{stu_c}=\min_{i=1}^n dp_{i,stu_p}$ 即可。

最后直接枚举子集转移求出答案就做完了。

时间复杂度 $O(nm\times 2^k+n\times 3^k)$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
namespace IO{//by cyffff
	
}
const int N=1000+10,K=10;
int n,m,k,p[N],up,c[N];
int cnt,head[N];
int dp[N][1<<K],sub[N];
int dp2[1<<K],up2;
struct Edge{
	int to,nxt,w;
}a[N*6];
inline void add(int u,int v,int w){
	cnt++;
	a[cnt].to=v;
	a[cnt].w=w;
	a[cnt].nxt=head[u];
	head[u]=cnt;
}
queue<int>q;
bool vis[N];
inline void SPFA(int s){
	while(!q.empty()){
		int rt=q.front();
		q.pop();
		vis[rt]=0;
		for(int i=head[rt];i;i=a[i].nxt){
			int t=a[i].to;
			if(dp[t][s]>dp[rt][s]+a[i].w){
				dp[t][s]=dp[rt][s]+a[i].w;
				if(!vis[t])
					q.push(t),vis[t]=1;
			}
		}
	}
}
inline void dfs(int x,int stup,int stuc){
	if(x==k+1){
		for(int i=1;i<=n;i++)
			dp2[stuc]=min(dp2[stuc],dp[i][stup]);
		return ;
	}
	dfs(x+1,stup|sub[x],stuc|(1<<x-1));
	dfs(x+1,stup,stuc);
}
int main(){
	memset(dp,127/3,sizeof(dp));
	memset(dp2,127/3,sizeof(dp2));
	n=read(),m=read(),k=read();
	for(int i=1;i<=m;i++){
		int u=read(),v=read(),w=read();
		add(u,v,w),add(v,u,w); 
	}
	for(int i=1;i<=k;i++){
		c[i]=read(),p[i]=read();
		dp[p[i]][1<<i-1]=0;
		sub[c[i]]|=1<<i-1;
		up2|=1<<c[i]-1;
	}
	up=(1<<k)-1;
	for(int s1=0;s1<=up;s1++){
		for(int i=1;i<=n;i++){
			for(int s2=s1&s1-1;s2;s2=s2-1&s1)
				dp[i][s1]=min(dp[i][s1],dp[i][s2]+dp[i][s1^s2]);
			if(dp[i][s1]<1e9)
				q.push(i),vis[i]=1;
		}
		SPFA(s1);
	} 
	dfs(1,0,0);
	for(int s1=1;s1<=up2;s1++)
		for(int s2=s1;s2;s2=s2-1&s1)
			dp2[s1]=min(dp2[s1],dp2[s2]+dp2[s1^s2]);
	write(dp2[up2]);
	flush();
}
```
再见 qwq~

---

## 作者：ez_lcw (赞：2)

看到题面容易想到跟斯坦纳树有关。

那么我们不妨设 $f(i,sta)$ 表示根为 $i$，关键点的状压状态为 $sta$ 时的最小代价。

那么所有的 $f(i,sta)$ 我们都可以用斯坦纳树的模板求出来。

现在考虑如何达到题目的要求。

因为考虑到频道的数量也小于 $10$，所以考虑一下能不能也用状压解决。

设 $g(sta')$ 表示频道的状压状态为 $sta'$ 时的最小代价。（如果 $sta'$ 二进制下的第 $k$ 位是 $1$ 就说明第 $k$ 个频道的关键点都已经联通了，否则不连通）。

然后设 $stap(i)$ 表示第 $i$ 个频道的所有关键点的状压状态（类似于 $f(i,sta)$ 中的 $sta$）。

显然，这个东西可以在读入的时候预处理。

然后说一下我一开始的想法：

对于每一个频道 $i$，把 $g(1<<i)$ 的值设为 $\min(f(j,stap_i))$。然后其他的 $g()$ 都设为 $\inf$。

然后枚举每一个 $sta'$ 的状态，更新：$g(sta')=\min(g(s)+g(sta'-s))$。（其中 $s$ 是 $sta'$ 的子集）

但是我发现了一个重要的问题：

![](https://cdn.luogu.com.cn/upload/image_hosting/iwlkeikp.png)

比如说这个图中，所有节点都是关键节点，点 $1$、$4$ 是频道 $1$ 的关键节点，点 $2$、$3$ 是频道 $2$ 的关键节点。（点上的黑色数字代表点的编号，红色数字代表这个点所属的频道， 边上的数字代表这条边的权值）。

显然有 $g((1)_2)=\min f(i,(1001)_2)=w_1+w_2+w_3$，$g((10)_2)=\min f(i,(0110)_2)=w_2$。

那么会得出来：$g((11)_2)=w_1+2w_2+w_3$。

但显然 $g((11)_2)$ 应该等于 $w_1+w_2+w_3$。

这时候就会发现这样 dp 会算重边。

如何解决？

我想到的解决办法：

我们一开始初始化 $g()$ 的时候，本来是只初始化所有的 $g(1<<i)$，而我们现在把 $g()$ 的每一个状态都初始化。

意思是说，对于每一个 $sta'$，我们都用 $f()$ 对 $g(sta')$ 进行初始化。

具体过程可以看代码，用 dfs 实现。

最后再按原来的方法，更新：$g(sta')=\min(g(s)+g(sta'-s))$。（其中 $s$ 是 $sta'$ 的子集）

代码如下：

```cpp
#include<bits/stdc++.h>

#define N 1010
#define M 3010

using namespace std;

int n,m,p,anssta,id[15],num[15],stap[15];
int cnt,head[N],w[M<<1],to[M<<1],nxt[M<<1];
int f[N][1025],g[1025];
bool inq[N];

//anssta是答案的状压状态（形如sta'）
//stap是每一个频道对应的状压状态（形如sta）

queue<int>q;

void adde(int u,int v,int wi)
{
	to[++cnt]=v;
	w[cnt]=wi;
	nxt[cnt]=head[u];
	head[u]=cnt;
}

void spfa(int sta)
{
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		inq[u]=false;
		for(int i=head[u];i;i=nxt[i])
		{
			int v=to[i];
			if(f[u][sta]+w[i]<f[v][sta])
			{
				f[v][sta]=f[u][sta]+w[i];
				if(!inq[v])
				{
					inq[v]=true;
					q.push(v);
				}
			}
		}
	}
}

void dfs(int k,int sum,int sump)
{
	if(k==p+1)
	{
		for(int i=1;i<=n;i++)
			g[sump]=min(g[sump],f[i][sum]);
		return;
	}
	dfs(k+1,sum|stap[k],sump|(1<<(k-1)));//枚举选这个频道（sta'的第k位是1）
	dfs(k+1,sum,sump);//不选这个频道（sta'的第k位是0）
}

int main()
{
	memset(f,0x3f,sizeof(f));
	memset(g,0x3f,sizeof(g));
	scanf("%d%d%d",&n,&m,&p);
	for(int i=1;i<=m;i++)
	{
		int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		adde(u,v,w),adde(v,u,w);
	}
	for(int i=1;i<=p;i++)
	{
		scanf("%d%d",&id[i],&num[i]);
		f[num[i]][1<<(i-1)]=0;
		stap[id[i]]|=(1<<(i-1));
		anssta|=(1<<(id[i]-1));
	}
	int maxn=(1<<p)-1;
	for(int sta=1;sta<=maxn;sta++)
	{
		for(int i=1;i<=n;i++)
		{
			for(int now=sta;now;now=sta&(now-1))
				f[i][sta]=min(f[i][sta],f[i][now]+f[i][sta-now]);
			if(f[i][sta]!=0x3f3f3f3f)
			{
				q.push(i);
				inq[i]=true;
			}
		}
		spfa(sta);
	}
   //以上是模板斯坦纳树
	dfs(1,0,0);
	for(int sta=1;sta<=anssta;sta++)
		for(int now=sta;now;now=sta&(now-1))
			g[sta]=min(g[sta],g[now]+g[sta-now]);
	printf("%d\n",g[anssta]);
	return 0;
}
```

---

## 作者：小木虫 (赞：1)

题目大意：有若干不同类型的必选点和选选点，对于一个类型的必选点要求联通，求最后的最小生成树森林权值总和。  
对于有若干的必选点和选选点求最小生成树的问题我们称为斯坦纳树问题，这种问题的必选点数量会很少，可以使用状态压缩来求解，不同于普通的最小生成树算法，如 kruskal 和 prim 简单好写，基于边。斯坦纳树的求解依赖于重要点的状态压缩。  
dp 定义：$dp i,j$ 以 $i$ 点为根，重要点集状态为 j 的最小生成树边权和。  
很显然，对于这个 dp 有两个转移方程：  
$ f[j][i]=\min(f[j][i],f[j][i-k]+f[j][k]);$  
我们可以证明对于 $f[j][i]$ ，即覆盖状态为 $i$ 的最小生成树一定能够被分为形如这个状态转移方程的形式。  
$f[j][i]=\min(f[j][i],f[k][i]+disk(j,k));$  
$k$ 为 $j$ 的邻居节点， $disk$ 是边权。  
对于单个斯坦纳树的求解过程：  
1.找到所有重要点，将 dp 当前重要点 只有当前重要点的点集设为0，其它设为$inf$。  
2.从小到大枚举点集，在内部循环 i （当前点），在 $i$ 循环内部循环 $k$ （$k$必须为当前点集的子集），然后进行状态转移，方程：  
$f[j][i]=\min(f[j][i],f[j][i-k]+f[j][k]);$（第一次状态转移）  
如果这一通操作下来 $f j,i$ 不是 $inf$ 了（有解了），你将其加入 SPFA 队列中。  
3.在 i 循环退出后，进行当前点集下的一次 SPFA。 （第二次状态转移）  
害，说了这么多还是说不明白，上代码：  
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,p;
int x,y,z;
struct sta{
	int id;
	int com;
}station[15];
struct node{
	int x,y;
};
node tmp;
vector <node> edge[20010];
bool cmp(sta a,sta b){
	if(a.com<b.com)return true;
	else return false;
} 
int tot=1;
int f[5010][1<<11];
int g[1<<11];
int cnt;
void init(){
	for(int i=0;i<=n;i++){
		for(int j=0;j<=(1<<p)-1;j++){
			f[i][j]=1e9;
		}
	}
}
queue <int> Q;
bool vis[5010];
void primary_spfa(int I){
	int x,y;
	while(!Q.empty()){
		x=Q.front();
		Q.pop();
		vis[x]=false;
		for(int i=0;i<edge[x].size();i++){
			y=edge[x][i].x;
			if(f[y][I]>f[x][I]+edge[x][i].y){
				f[y][I]=f[x][I]+edge[x][i].y;
				if(!vis[y]){
					vis[y]=true;
					Q.push(y);
				}
			}
		}
	}
}
int solve(int cnt){
	for(int i=1;i<=(1<<cnt)-1;i++){
		for(int j=1;j<=n;j++){
			for (int k=(i-1)&i;k;k=(k-1)&i){
				f[j][i]=min(f[j][i],f[j][i-k]+f[j][k]);
			}
			if(f[j][i]!=1e9){
				vis[j]=true;
				Q.push(j);
			}
		}
		primary_spfa(i);
	}
	int ans=1e9;
	for(int i=1;i<=n;i++){
		ans=min(ans,f[i][(1<<cnt)-1]);
	}
	return ans;
}
int main(){
	cin>>n>>m>>p;
	for(int i=1;i<=m;i++){
		cin>>x>>y>>z;
		tmp.x=y;
		tmp.y=z;
		edge[x].push_back(tmp);
		tmp.x=x;
		edge[y].push_back(tmp);
	}
	for(int i=1;i<=p;i++){
		cin>>station[i].com>>station[i].id;
	}
	sort(station+1,station+1+p,cmp);
	for(int i=1;i<=p;i++){
		if(i!=1&&station[i].com!=station[i-1].com){
			++tot;
		}
		station[i].com=tot;
	}
	for(int i=1;i<=(1<<tot)-1;i++)g[i]=1e9;
	for(int i=1;i<=(1<<tot)-1;i++){
		cnt=0;
		init();
		for(int j=1;j<=p;j++){
			if((1<<(station[j].com-1))&i){
				++cnt;
				f[station[j].id][1<<(cnt-1)]=0;
			}
		}
		g[i]=solve(cnt);
	}
	for(int i=1;i<=(1<<tot)-1;i++){
		for (int j=(i-1)&i;j;j=(j-1)&i){
			g[i]=min(g[i],g[j]+g[i-j]);
		}
	} 
	cout<<g[(1<<tot)-1];
	return 0;
}
```


---

## 作者：半仙胡小桃 (赞：0)

## 题目描述：
给出一张图
给出若干个点和其频率，要求相同频率的点可以连通，求最小代价。
## 题目分析：
观察到带频率的点数很少，只有10个左右

那我们就可以做斯坦纳树

这些相同频率的点形成一个斯坦纳树，其实最后形成的是个斯坦纳树森林，所以最后要搞一下子集DP（雾
## 题目链接：
[Luogu 3264](https://www.luogu.org/problemnew/show/P3264)

[BZOJ 4006](http://www.lydsy.com/JudgeOnline/problem.php?id=4006)
## Ac 代码：

```
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <queue>
#include <cstring>
#include <vector>
const int maxm=6000; 
std::vector <int> p[20];
std::queue <int> dl;
int inf;
int f[maxm][1<<10],g[1<<10],n,m,num;
int head[maxm],to[maxm<<1],net[maxm<<1],cost[maxm<<1],cnt;
bool vis[maxm];
int pos[20],w[2000];
int point[20];
void addedge(int u,int v,int c)
{
	cnt++;
	to[cnt]=v,cost[cnt]=c,net[cnt]=head[u],head[u]=cnt;
}
void spfa(int sta)
{
	while(!dl.empty()) dl.pop();
	for(int i=1;i<=n;i++) 
     if(f[i][sta]<inf) dl.push(i),vis[i]=1;
    while(!dl.empty())
    {
    	int x=dl.front();
    	dl.pop();
    	vis[x]=0;
    	for(int i=head[x];i;i=net[i])
    	if(f[to[i]][sta]>f[x][sta]+cost[i])
    	{
    		f[to[i]][sta]=f[x][sta]+cost[i];
    		if(!vis[to[i]]) vis[to[i]]=1,dl.push(to[i]);
    	}
    }
}
bool check(int sta)
{
	for(int i=0;i<num;i++)
	if((sta>>i)&1)
	{
		int poi=pos[i+1];
		for(int j=0;j<p[poi].size();j++)
		 if(!((1<<(p[poi][j]-1))&sta)) return 0;
	}
	return 1;
}
int main()
{
	scanf("%d%d%d",&n,&m,&num);
	for(int i=1;i<=m;i++)
	{
		int u,v,c;
		scanf("%d%d%d",&u,&v,&c);
		addedge(u,v,c),addedge(v,u,c);
	}
	for(int i=1;i<=num;i++)
	{
		int dx,id;
		scanf("%d%d",&dx,&id);
		w[id]=i;
		p[dx].push_back(i);
		pos[i]=dx;
		point[i]=id;
	}
	memset(f,127/3,sizeof(f)),memset(g,127/3,sizeof(g));
	inf=f[0][0];
	for(int i=1;i<=num;i++)
	{
		int nowd=point[i];
		f[nowd][1<<(w[nowd]-1)]=0;
	}
	for(int s=0;s<(1<<num);s++)
	{
		for(int i=1;i<=n;i++)
		 for(int j=s&(s-1);j;j=(j-1)&s)
		  f[i][s]=std::min(f[i][s],f[i][j]+f[i][s-j]);
		spfa(s);
		for(int i=1;i<=n;i++) g[s]=std::min(g[s],f[i][s]);
	}
	for(int s=0;s<(1<<num);s++)
	 for(int i=s&(s-1);i;i=(i-1)&s)
	  if(check(i)&&check(s-i))
	   g[s]=std::min(g[s],g[i]+g[s-i]);
	printf("%d\n",g[(1<<num)-1]);
	return 0;
}
```


---


# [MtOI2018] gcd？人生赢家！

## 题目背景

gcd 是一个热爱游戏的人。

## 题目描述

gcd 最近在玩一个有趣的游戏。

我们把这个游戏抽象成一张图，图上有 $n$ 个点，gcd 需要寻找总计 $m$ 件宝物，它们分布在图上。

对于每件宝物而言，将会有一个前置集合 $S$。只有当取得所有前置宝物时，才能获得该宝物。

gcd 拥有一件神器，这件神器具有传送功能，它可以使用 $k$ 次，可以传送到一个任意节点。

对于游戏而言，肯定会有额外的成就，这些成就会奖励一定的传送次数，成就的达成是满足集合 $S$ 的一瞬间。

现在 gcd 想知道能最快通关的方法，请你求出通关的最少时间。

## 说明/提示

### 子任务

对于 $20\%$ 的数据，$s=0$。

对于 $100\%$ 的数据，$n\leq 200$，$m\leq 12$，$k\leq 4$，$s\leq 8$，$e\leq 20000$ ，奖励次数总和不超过 $8$，保证每两个宝物的位置不相同，可能有重边，保证有解。

### 题目来源

[MtOI2018 迷途の家の水题大赛](https://www.luogu.org/contest/11260) T5

出题人：b2019dy

78488

## 样例 #1

### 输入

```
3 2 0
1
1 1
1
2 3
3
1 2 20
1 3 20
3 2 1
0
0
1
```

### 输出

```
20```

## 样例 #2

### 输入

```
3 2 0
1
1 1
1
2 3
3
1 2 1
1 3 20
3 2 20
1 2
0
1```

### 输出

```
40```

# 题解

## 作者：Drawing_Yang (赞：5)

~~首先吐槽一句，这输入有点恶心。~~  

看到范围，很容易想到状压Dp，但又有不同之处，可以直接传送，这样是不是像分层图？  

于是考虑Dp+分层图。设$f[s][i][j]$为状态为$s$，最后一个点是第$i$个点，用了$j$次神器或奖励的传送次数。则可以很容易得到  

$f[s][i][j]=\min\{f[s'][t][j-1],f[s'][t][j]+g[p[i]][p[j]]\}$  

其中$p[i]$表示第$i$个需要到达的节点，$g[i][j]$表示$i,j$的最短路，$s'$是能转移到$s$的状态。

至于成就，读入时先存为一个状态，再在转移前枚举这个状态是否满足成就，当然，更好的方法是预处理出每个状态可以获得的传送次数。  

至于宝物的前置要求，同样读入时存为一个状态，在转移前判断这个状态是否满足对应的前置要求，即$t\&(bf[i])$是否等于$bf[i]$，等于则合法。

出题人还是比较良心，没有卡Floyd。  

根据这个方程，容易得到代码。  

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>
#define lowbit(x) ((x)&-(x))
using namespace std;
struct achievement {
	int s;
	int tis;
} ach[10];
int bf[20];
int a[(1<<12)];
int n,m,K,S,e,st;
int g[205][205];
int p[20],mx;
int f[1<<12][13][13];
void Read() {
	scanf("%d%d%d%d",&n,&m,&K,&S);
	for (int i=1; i<=S; i++) {//成就 
		int t;
		scanf("%d",&t);
		for (int j=1; j<=t; j++) {
			int a;
			scanf("%d",&a);
			ach[i].s|=(1<<(a-1));
		}
	}
	for (int i=1; i<=S; i++) {
		scanf("%d",&ach[i].tis);
		mx+=ach[i].tis;
	}
	for (int i=1; i<=m; i++) {
		scanf("%d",&p[i]);
	}
	scanf("%d",&e);
	for (int i=1; i<=e; i++) {
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		g[x][y]=g[y][x]=min(g[x][y],z);//注意重边 
	}
	for (int i=1; i<=m; i++) {
		int t;
		scanf("%d",&t);
		for (int j=1; j<=t; j++) {
			int a;
			scanf("%d",&a);
			bf[i]|=(1<<(a-1));//前置 
		}
	}
	scanf("%d",&st);
}
void Floyd() {//Floyd 
	for (int i=1; i<=n; i++) g[i][i]=0;
	for (int kk=1; kk<=n; kk++)
		for (int i=1; i<=n; i++)
			for (int j=1; j<=n; j++)
				g[i][j]=min(g[i][j],g[i][kk]+g[kk][j]);

}
void Dp() {
	memset(f,0x3f,sizeof(f));
	for (int i=1; i<=m; i++) {//初始化 
		if (!bf[i]) {
			f[1<<(i-1)][i][0]=g[st][p[i]]; 
			if (K>1) f[1<<(i-1)][i][1]=0;
		}
	}
	for (int s=0; s<(1<<m); s++) {
		for (int i=s; i; i-=lowbit(i)) {//用lowbit()来枚举，比直接枚举要快 
			for (int j=s-lowbit(i); j; j-=lowbit(j)) {//同理 
				int t1=log2(lowbit(i))+1,t2=log2(lowbit(j))+1;//获取节点 
				if (t1==t2) continue;
				if (((s-lowbit(i))&bf[t1])!=bf[t1]) continue;//判断是否满足前置要求 
				int os=0;
				for (int r=1; r<=S; r++) {//枚举改状态可以获得的传送次数 
					if (((s-lowbit(i))&ach[r].s)==ach[r].s)
						os+=ach[r].tis;
				}
				for (int k=0; k<=K+os; k++) {//更新 
					f[s][t1][k]=min(f[s][t1][k],f[s-lowbit(i)][t2][k]+g[p[t2]][p[t1]]);
					if (k!=0) f[s][t1][k]=min(f[s][t1][k],f[s-lowbit(i)][t2][k-1]);
				}
			}
		}
	}
}
void Print() {
	int ans=0x3f3f3f3f;
	for (int i=1; i<=m; i++) {
		for (int k=0; k<=K+mx; k++)
			ans=min(ans,f[(1<<m)-1][i][k]);
	}
	printf("%d",ans);
}
int main() {
	memset(g,0x3f,sizeof(g));
	Read();
	Floyd();
	Dp();
	Print();
	return 0;
}
```

---

## 作者：_Wind_Leaves_ShaDow_ (赞：0)

## 前言

正解是状压，但是状压 dp 很难调试。于是，在经过一段时间的观察后，我悟了：

**大多数状压 dp 的数据很小。我的意思是，它可以尝试搜索**。一道题的范围并不一定锁定一个算法，只要能够通过这一题，都是一个可以尝试的好算法。

## 扯回主题

本题算法：广搜，状态压缩。不是很难，但是细节很多。

本质上这个广搜是由状压转过来的，所以很容易地想到压缩宝藏（$m \leq 12$）。

我们的广搜节点定义为如下的结构体：

```cpp
struct Node{
	int p,zt,lef,stp;
   //当前点，当前状态，还剩几次瞬移，用了多少步
	bool operator >(const Node tmp)const{//重载运算符，特别重要
		return stp>tmp.stp;
	}
};
```
发现如果单独每一个点都要加入，时空开销会很大。但是如果重点在一个非宝藏的节点根本没用，这种节点只能用作两个宝藏节点之间的桥梁，于是跑一遍 **Floyd 最短路** 就可以不去管这些点。

可以发现，因为最短路的长度是不定的，可能后加进来的节点用的步数比现在的队列头少，此时应该先看这个节点。为了满足这个需求，我们需要使用优先队列：

```cpp
priority_queue<Node,vector<Node>,greater<Node> >q;//小根堆，步数小的在前
```

### 关于成就

预处理每一个状态可以得到的成就的得分，两个状态的得分差就是新增的瞬移步数。

其他的地方没有难点，只需要扣细节，详见代码吧。

### 代码 ~~（超丑码风，谨慎食用）~~

~~输入是毒瘤的，我们要拒绝这样的输入（雾）~~

记得宝藏节点和图的节点的区分，不注意很容易搞懵。

```cpp
#include <bits/stdc++.h>
#define INF 0x7fffffff
using namespace std;
const int N=(1<<12)+5;

int n,m,K,s,t1,t2,t3,st,cnt[N];//cnt[i]储存状态i可以得到的成就
int trs[15],ned[15];//trs[i]储存宝藏编号为i的对应点，ned[i]储存宝藏i的前提条件
int req[15],rwd[15];//成就的前提和奖励
int e,flo[205][205];
bool vis[15][N][15];//广搜记忆数组，注意是宝藏编号
struct Node{
	int p,zt,lef,stp;
	bool operator >(const Node tmp)const{
		return stp>tmp.stp;
	}
};
priority_queue<Node,vector<Node>,greater<Node> >q;

inline int count(int x){
	int ret=0;
	for(int i=1;i<=s;i++)if((x&req[i])==req[i])ret+=rwd[i];
	return ret;
}//处理每个状态的成就得分

int bfs(){
	for(int i=0;i<(1<<m);i++)cnt[i]=count(i);//预处理成就
	for(int i=1;i<=m;i++){//预处理开始的可能节点，因为st可能不是宝藏节点
		if(ned[i]==0){//这个点可以当作起点
			int nzt=(1<<(i-1));
			if(trs[i]!=st&&K>=1){//是st的话不需要消耗瞬移，没有瞬移步数不能瞬移
				vis[i][nzt][K-1+cnt[nzt]]=true;
				q.push({i,nzt,K-1+cnt[nzt],0});
			}
			q.push({i,nzt,K+cnt[nzt],flo[st][trs[i]]});//无论如何都可以走路到
			vis[i][nzt][K+cnt[nzt]]=true;
		}
	}
	while(!q.empty()){
		int np=q.top().p,nz=q.top().zt,nl=q.top().lef,nstep=q.top().stp;
		vis[np][nz][nl]=true;//注意在这里才标记，调了一天的血泪经验
		//因为在加点的时候标记会导致之后得到的更优解被吞
		if(nz==(1<<m)-1)return nstep;
		q.pop();
		t1=cnt[nz];
		for(int i=1;i<=m;i++){//下一个点
			if(np==i||(nz&ned[i])!=ned[i]||(nz&(1<<(i-1)))!=0)continue;//和当前点一样、没有满足这个点的前提、这个点到过，都不能来这个点
			int nxt=nz^(1<<(i-1));
			t2=cnt[nxt];//t2-t1代表从上个状态转移到这个状态新增多少步
			if(!vis[i][nxt][nl+(t2-t1)])q.push({i,nxt,nl+(t2-t1),nstep+flo[trs[np]][trs[i]]});//最短路
			if(nl>=1&&!vis[i][nxt][nl-1+(t2-t1)])q.push({i,nxt,nl-1+(t2-t1),nstep});//瞬移，注意看有没有瞬移次数
		}
	}
	return 0;
}

signed main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	memset(flo,0x3f,sizeof(flo));
	cin>>n>>m>>K>>s;
	for(int i=1;i<=n;i++)flo[i][i]=0;
	for(int i=1;i<=s;i++){
		cin>>t1;
		for(int j=1;j<=t1;j++){
			cin>>t2;
			req[i]|=(1<<(t2-1));
		}
	}
	for(int i=1;i<=s;i++)cin>>rwd[i];
	for(int i=1;i<=m;i++)cin>>trs[i];
	cin>>e;
	for(int i=1;i<=e;i++){
		cin>>t1>>t2>>t3;
		flo[t1][t2]=flo[t2][t1]=min(flo[t1][t2],t3);
	}
	for(int k=1;k<=n;k++)for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)flo[i][j]=min(flo[i][j],flo[i][k]+flo[k][j]);//Floyd
	for(int i=1;i<=m;i++){
		cin>>t1;
		for(int j=1;j<=t1;j++){
			cin>>t2;
			ned[i]|=(1<<(t2-1));
		}
	}
	cin>>st;
   //输入占了这么多行也真是服了
	cout<<bfs();//广搜
	return 0;
}
```

---

